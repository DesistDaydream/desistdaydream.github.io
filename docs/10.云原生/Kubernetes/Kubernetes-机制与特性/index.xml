<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>断念梦的站点 – Kubernetes 机制与特性</title><link>https://desistdaydream.github.io/docs/10.%E4%BA%91%E5%8E%9F%E7%94%9F/Kubernetes/Kubernetes-%E6%9C%BA%E5%88%B6%E4%B8%8E%E7%89%B9%E6%80%A7/</link><description>Recent content in Kubernetes 机制与特性 on 断念梦的站点</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><atom:link href="https://desistdaydream.github.io/docs/10.%E4%BA%91%E5%8E%9F%E7%94%9F/Kubernetes/Kubernetes-%E6%9C%BA%E5%88%B6%E4%B8%8E%E7%89%B9%E6%80%A7/index.xml" rel="self" type="application/rss+xml"/><item><title>Docs: Pod 是如何出现的</title><link>https://desistdaydream.github.io/docs/10.%E4%BA%91%E5%8E%9F%E7%94%9F/Kubernetes/Kubernetes-%E6%9C%BA%E5%88%B6%E4%B8%8E%E7%89%B9%E6%80%A7/Pod-%E6%98%AF%E5%A6%82%E4%BD%95%E5%87%BA%E7%8E%B0%E7%9A%84/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/10.%E4%BA%91%E5%8E%9F%E7%94%9F/Kubernetes/Kubernetes-%E6%9C%BA%E5%88%B6%E4%B8%8E%E7%89%B9%E6%80%A7/Pod-%E6%98%AF%E5%A6%82%E4%BD%95%E5%87%BA%E7%8E%B0%E7%9A%84/</guid><description>
&lt;h1 id="概述">概述&lt;a class="td-heading-self-link" href="#%e6%a6%82%e8%bf%b0" aria-label="Heading self-link">&lt;/a>&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://mp.weixin.qq.com/s/bL-85BhOj8H5Dis_94lmrQ">公众号 - 程序员白日梦，一文讲明白-K8S各核心架构组件&lt;/a>
&lt;ul>
&lt;li>&lt;a href="https://www.cnblogs.com/ZhuChangwu/p/16441181.html">https://www.cnblogs.com/ZhuChangwu/p/16441181.html&lt;/a>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;h2 id="pod-出现流程中的-watch-机制的应用">Pod 出现流程中的 Watch 机制的应用&lt;a class="td-heading-self-link" href="#pod-%e5%87%ba%e7%8e%b0%e6%b5%81%e7%a8%8b%e4%b8%ad%e7%9a%84-watch-%e6%9c%ba%e5%88%b6%e7%9a%84%e5%ba%94%e7%94%a8" aria-label="Heading self-link">&lt;/a>&lt;/h2>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/kubernetes/202408231408085.png" alt="image.png">&lt;/p>
&lt;ol>
&lt;li>通过 kubectl 命名发起请求。&lt;/li>
&lt;li>apiserver 通过对应的 kubeconfig 进行认证，认证通过后将 yaml 中的 pod 信息存到 etcd。&lt;/li>
&lt;li>Controller-Manager 通过 apiserver 的 &lt;a href="https://desistdaydream.github.io/docs/10.%E4%BA%91%E5%8E%9F%E7%94%9F/Kubernetes/Kubernetes%20%E6%9C%BA%E5%88%B6%E4%B8%8E%E7%89%B9%E6%80%A7/Watch%20and%20Informer.md">Watch&lt;/a> 接口发现了pod信息的更新，执行该资源所依赖的拓扑结构整合，整合后将对应的信息交给 apiserver，apiserver 写到 etcd。&lt;/li>
&lt;li>Scheduler 同样通过 apiserver 的 watch 接口更新到 pod 可以被调度，通过算法给 pod 分配节点，并将 pod 和对应节点绑定的信息交给 apiserver，apiserver 写到 etcd。&lt;/li>
&lt;li>kubelet 从 apiserver 获取需要创建的 pod 信息，调用 CNI 接口给 pod 创建 pod 网络，调用 CRI 接口去启动容器，调用 CSI 进行存储卷的挂载。&lt;/li>
&lt;li>网络，容器，存储创建完成后 pod 创建完成，等业务进程启动后，pod 运行成功。&lt;/li>
&lt;/ol>
&lt;h1 id="输入-kubectl-run-时会发生什么">输入 kubectl run 时会发生什么?&lt;a class="td-heading-self-link" href="#%e8%be%93%e5%85%a5-kubectl-run-%e6%97%b6%e4%bc%9a%e5%8f%91%e7%94%9f%e4%bb%80%e4%b9%88" aria-label="Heading self-link">&lt;/a>&lt;/h1>
&lt;blockquote>
&lt;p>参考:&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://github.com/jamiehannaford/what-happens-when-k8s">GitHub 项目，jamiehannaford/what-happens-when-k8s&lt;/a>
&lt;ul>
&lt;li>&lt;a href="https://icloudnative.io/posts/what-happens-when-k8s/">https://icloudnative.io/posts/what-happens-when-k8s/&lt;/a> 多了一张图&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/kubernetes/202408231539942.png" alt="1000">&lt;/p>
&lt;blockquote>
&lt;p>为了确保整体的简单性和易上手，Kubernetes 通过一些简单的抽象隐去操作背后的复杂逻辑，但作为一名有梦想的工程师，掌握其背后的真正思路是十分有必要的。本文以 Kubectl 创建 Pod 为例，向你揭露从客户端到 Kubelet 的请求的完整生命周期。&lt;/p>
&lt;/blockquote>
&lt;p>想象一下，当你想在 Kubernetes 集群部署 Nginx 时，你会执行以下命令：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>kubectl create deployment nginx --image&lt;span style="color:#ce5c00;font-weight:bold">=&lt;/span>nginx --replicas&lt;span style="color:#ce5c00;font-weight:bold">=&lt;/span>&lt;span style="color:#0000cf;font-weight:bold">3&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>几秒后，你将看到三个 Nginx Pod 分布在集群工作节点上。这相当神奇，但它背后究竟发生了什么？&lt;/p>
&lt;p>Kubernetes 是一个神奇的框架，它通过用户友好（user-friendly）的 API 处理跨基础架构的 Workload 部署。通过简单的抽象隐藏了背后的复杂性。但是，为了充分理解它为我们提供的价值，我们需要理解它的原理。&lt;/p>
&lt;p>本指南将带领你充分了解从 Kubectl 客户端到 Kubelet 请求的完整生命周期，并在必要时通过源代码解释它到底是什么。&lt;/p>
&lt;p>&lt;strong>注&lt;/strong>：本文所有内容基于 &lt;code>Kubernetes v1.14.0&lt;/code>。&lt;/p>
&lt;h2 id="kubectl">Kubectl&lt;a class="td-heading-self-link" href="#kubectl" aria-label="Heading self-link">&lt;/a>&lt;/h2>
&lt;h3 id="validation-and-generators">Validation and generators&lt;a class="td-heading-self-link" href="#validation-and-generators" aria-label="Heading self-link">&lt;/a>&lt;/h3>
&lt;p>首先，当我们敲下回车键执行命令后， Kubectl 会执行客户端验证，以确保非法的请求（例如，创建不支持的资源或使用&lt;a href="https://github.com/kubernetes/kubernetes/blob/v1.14.0/pkg/kubectl/cmd/run/run.go#L264">格式错误的镜像名称&lt;/a>）快速失败，并不会发送给 kube-apiserver，即通过减少不必要的负载来提高系统性能。&lt;/p>
&lt;p>验证通过后， Kubectl 开始构造它将发送给 kube-apiserver 的 HTTP 请求。在 Kubernetes 中，访问或更改状态的所有尝试都通过 kube-apiserver 进行，​​后者又与 etcd 进行通信。 Kubectl 客户端也不例外。为了构造 HTTP 请求， Kubectl 使用称为 &lt;a href="https://kubernetes.io/docs/user-guide/kubectl-conventions/#generators">generators&lt;/a> 的东西，这是一个负责序列化的抽象概念。&lt;/p>
&lt;p>你可能没有注意到，通过 &lt;code>kubectl run&lt;/code> 不仅可以运行 &lt;code>deployment&lt;/code>，还可以通过指定参数 &lt;code>--generator&lt;/code> 来部署其它 workload。&lt;/p>
&lt;p>如果没有指定 &lt;code>--generator&lt;/code> 参数的值， Kubectl 将会自动&lt;a href="https://github.com/kubernetes/kubernetes/blob/v1.14.0/pkg/kubectl/cmd/run/run.go#L319-L339">推断&lt;/a>资源的类型，具体如下：&lt;/p>
&lt;ul>
&lt;li>具有 &lt;code>--restart-policy=Always&lt;/code> 的资源被视为 Deployment；&lt;/li>
&lt;li>具有 &lt;code>--restart-policy=OnFailure&lt;/code> 的资源被视为 Job；&lt;/li>
&lt;li>具有 &lt;code>--restart-policy=Never&lt;/code> 的资源被视为 Pod。&lt;/li>
&lt;/ul>
&lt;p>Kubectl 还将确定是否需要触发其他操作，例如记录命令（用于部署或审计），或者此命令是否是 dry run。&lt;/p>
&lt;blockquote>
&lt;p>[!From wikipedia]&lt;/p>
&lt;p>空运行（dry run）也称为试运行（practice run），是刻意为了减轻可能失效的影响而有的测试流程。例如飞机公司会先在飞机停在陆地上时进行其弹射座椅的测试，之后才在飞机升空后主进行类似测试。陆地上的测试即为空运行。&lt;/p>
&lt;p>在验收程序（也称为工厂验收测试）的领域中，空运行是指分包商需在产品交给客户，进行真正的验收测试之前，先进行的完整测试。&lt;/p>
&lt;/blockquote>
&lt;p>当 Kubectl 判断出要创建一个 Deployment 后，它将使用 &lt;code>DeploymentV1Beta1 generator&lt;/code> 配合我们提供的参数，生成一个&lt;a href="https://github.com/kubernetes/kubernetes/blob/v1.14.0/pkg/kubectl/generate/versioned/run.go#L237">运行时对象（Runtime Object）&lt;/a>。&lt;/p>
&lt;h3 id="api-groups-and-version-negotiation">API groups and version negotiation&lt;a class="td-heading-self-link" href="#api-groups-and-version-negotiation" aria-label="Heading self-link">&lt;/a>&lt;/h3>
&lt;p>这里值得指出的是， Kubernetes 使用的是一个分类为 API Group 的版本化 API。它旨在对资源进行分类，以便于推理。&lt;/p>
&lt;p>同时，它还为单个 API 提供了更好的版本化方案。 Deployment 的 API Group 为 &lt;code>apps&lt;/code>，其最新版本为 &lt;code>v1&lt;/code>。这就是为什么需要在 Deployment manifests 顶部指定 &lt;code>apiVersion: apps/v1&lt;/code> 的原因。&lt;/p>
&lt;p>回归正文， Kubectl 生成运行时对象之后，它开始为它&lt;a href="https://github.com/kubernetes/kubernetes/blob/v1.14.0/pkg/kubectl/cmd/run/run.go#L674-L686">查找合适的 API Group 和版本&lt;/a>，然后组装一个知道该资源的各种 REST 语义的&lt;a href="https://github.com/kubernetes/kubernetes/blob/v1.14.0/pkg/kubectl/cmd/run/run.go#L705-L708">版本化客户端&lt;/a>。&lt;/p>
&lt;p>这个发现阶段称为版本协商 (version negotiation)，涉及 Kubectl 扫描 remote API 上的 &lt;code>/apis&lt;/code> 路径以检索所有可能的 API Group。&lt;/p>
&lt;p>由于 kube-apiserver 在 &lt;code>/apis&lt;/code> 路径中暴露其 OpenAPI 格式的 scheme 文档，因此客户端可以轻松的找到匹配的 API。&lt;/p>
&lt;p>为了提高性能， Kubectl 还将 &lt;a href="https://github.com/kubernetes/kubernetes/blob/v1.14.0/staging/src/k8s.io/cli-runtime/pkg/genericclioptions/config_flags.go#L234">OpenAPI scheme 缓存到 &lt;code>~/.kube/cache/discovery&lt;/code> 目录&lt;/a>。如果要了解 API 发现的完整过程，你可以尝试删除该目录并在运行 Kubectl 命令时将 &lt;code>-v&lt;/code> 参数的值设为最大，然后你将会在日志中看到所有试图找到这些 API 版本的 HTTP 请求。&lt;/p>
&lt;p>最后一步才是真正地&lt;a href="https://github.com/kubernetes/kubernetes/blob/v1.14.0/pkg/kubectl/cmd/run/run.go#L709">发送 HTTP 请求&lt;/a>。一旦请求获得成功的响应， Kubectl 将会根据所需的&lt;a href="https://github.com/kubernetes/kubernetes/blob/v1.14.0/pkg/kubectl/cmd/run/run.go#L459">输出格式&lt;/a>打印 success message。&lt;/p>
&lt;h3 id="client-auth">Client auth&lt;a class="td-heading-self-link" href="#client-auth" aria-label="Heading self-link">&lt;/a>&lt;/h3>
&lt;p>我们在上文中没有提到的一件事是客户端身份验证（这是在发送 HTTP 请求之前处理的），现在让我们来看看。&lt;/p>
&lt;p>为了成功发送请求， Kubectl 需要先进行身份验证。用户凭据一般存储在 &lt;code>kubeconfig&lt;/code> 文件中，但该文件可以存储在不同的位置。为了定位到它， Kubectl 执行以下操作：&lt;/p>
&lt;ul>
&lt;li>如果指定参数 &lt;code>--kubeconfig&lt;/code>，那么采用该值；&lt;/li>
&lt;li>如果指定环境变量 &lt;code>$KUBECONFIG&lt;/code>，那么采用该值；&lt;/li>
&lt;li>否则&lt;a href="https://github.com/kubernetes/client-go/blob/kubernetes-1.14.0/tools/clientcmd/loader.go#L52">查看默认的目录&lt;/a>，如 &lt;code>~/.kube&lt;/code>，并使用找到的第一个文件。&lt;/li>
&lt;/ul>
&lt;p>解析文件后，它会确定当前要使用的上下文，当前指向的集群以及与当前用户关联的所有身份验证信息。如果用户提供了额外的参数（例如 &lt;code>--username&lt;/code>），则这些值优先，并将覆盖 kubeconfig 中指定的值。&lt;/p>
&lt;p>一旦有了上述信息， Kubectl 就会填充客户端的配置，以便它能够适当地修饰 HTTP 请求：&lt;/p>
&lt;ul>
&lt;li>x509 证书使用 &lt;a href="https://github.com/kubernetes/client-go/blob/kubernetes-1.14.0/rest/transport.go#L80-L89">&lt;code>tls.TLSConfig&lt;/code>&lt;/a> 发送（包括 CA 证书）；&lt;/li>
&lt;li>bearer tokens 在 HTTP 请求头 Authorization 中&lt;a href="https://github.com/kubernetes/client-go/blob/kubernetes-1.14.0/transport/round_trippers.go#L316">发送&lt;/a>；&lt;/li>
&lt;li>用户名和密码通过 HTTP 基础认证&lt;a href="https://github.com/kubernetes/client-go/blob/kubernetes-1.14.0/transport/round_trippers.go#L197">发送&lt;/a>；&lt;/li>
&lt;li>OpenID 认证过程是由用户事先手动处理的，产生一个像 bearer token 一样被发送的 token。&lt;/li>
&lt;/ul>
&lt;h2 id="kube-apiserver">kube-apiserver&lt;a class="td-heading-self-link" href="#kube-apiserver" aria-label="Heading self-link">&lt;/a>&lt;/h2>
&lt;h3 id="authentication">Authentication&lt;a class="td-heading-self-link" href="#authentication" aria-label="Heading self-link">&lt;/a>&lt;/h3>
&lt;p>我们的请求已经发送成功，接下来呢？kube-apiserver！&lt;/p>
&lt;p>kube-apiserver 是客户端和系统组件用来持久化和检索集群状态的主要接口。为了执行其功能，它需要能够验证请求是否合法。此过程称为认证 （Authentication）。&lt;/p>
&lt;p>为了验证请求，当服务器首次启动时， kube-apiserver 会查看用户提供的所有 &lt;a href="https://v1-14.docs.kubernetes.io/docs/reference/command-line-tools-reference/kube-apiserver/">CLI 参数&lt;/a>，并组装合适的 authenticator 列表。&lt;/p>
&lt;p>举个例子：&lt;/p>
&lt;ul>
&lt;li>如果指定参数 &lt;code>--client-ca-file&lt;/code>，它会附加 x509 authenticator 到列表中；&lt;/li>
&lt;li>如果指定参数 &lt;code>--token-auth-file&lt;/code>，它会附加 token authenticator 到列表中。&lt;/li>
&lt;/ul>
&lt;p>每次收到请求时，都会&lt;a href="https://github.com/kubernetes/apiserver/blob/kubernetes-1.14.0/pkg/authentication/request/union/union.go#L53">遍历身份验证器列表&lt;/a>，直到成功为止：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://github.com/kubernetes/apiserver/blob/kubernetes-1.14.0/pkg/authentication/request/x509/x509.go#L89">x509 handler&lt;/a> 会验证 HTTP 请求是否是通过 CA 根证书签名的 TLS 密钥编码的；&lt;/li>
&lt;li>&lt;a href="https://github.com/kubernetes/apiserver/blob/kubernetes-1.14.0/pkg/authentication/request/bearertoken/bearertoken.go#L37">bearer token handler&lt;/a> 会验证 HTTP Authorization header 指定的 token 是否存在于 &lt;code>--token-auth-file&lt;/code> 参数提供的 token 文件中；&lt;/li>
&lt;li>&lt;a href="https://github.com/kubernetes/apiserver/blob/kubernetes-1.14.0/plugin/pkg/authenticator/request/basicauth/basicauth.go#L39">basicauth handler&lt;/a> 会简单验证 HTTP 请求的基本身份凭据。&lt;/li>
&lt;/ul>
&lt;p>如果所有 authenticator 都认证失败，则请求失败并返回汇总的错误信息。&lt;/p>
&lt;p>如果认证成功，则会从请求中删除 &lt;code>Authorization&lt;/code> 标头，并&lt;a href="https://github.com/kubernetes/apiserver/blob/kubernetes-1.14.0/pkg/endpoints/filters/authentication.go#L74-L77">将用户信息添加到其上下文中&lt;/a>。为之后的操作（例如授权和准入控制器）提供访问先前建立的用户身份的能力。&lt;/p>
&lt;h3 id="authorization">Authorization&lt;a class="td-heading-self-link" href="#authorization" aria-label="Heading self-link">&lt;/a>&lt;/h3>
&lt;p>好的，请求已发送，kube-apiserver 已成功验证我们是谁。终于解脱了？！&lt;/p>
&lt;p>想太多！&lt;/p>
&lt;p>虽然我们证明了自己是谁，但还没证明有权执行此操作。毕竟，身份 (identity) 和许可 (permission) 并不是一回事。因此 kube-apiserver 需要授权。&lt;/p>
&lt;p>kube-apiserver 处理授权的方式与身份验证非常相似：基于 &lt;a href="https://v1-14.docs.kubernetes.io/docs/reference/command-line-tools-reference/kube-apiserver/">CLI 参数&lt;/a> 输入，汇集一系列 authorizer， 这些 authorizer 将针对每个传入请求运行。如果所有 authorizer 都拒绝该请求，则该请求将导致 &lt;code>Forbidden&lt;/code> 响应并且&lt;a href="https://github.com/kubernetes/apiserver/blob/kubernetes-1.14.0/pkg/endpoints/filters/authorization.go#L76">不再继续&lt;/a>。如果单个 authorizer 批准，则请求继续。&lt;/p>
&lt;p>Kubernetes v1.14 的 authorizer 实例：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://github.com/kubernetes/apiserver/blob/kubernetes-1.14.0/plugin/pkg/authorizer/webhook/webhook.go#L152">webhook&lt;/a>：与集群外的 HTTP(S) 服务交互；&lt;/li>
&lt;li>&lt;a href="https://github.com/kubernetes/kubernetes/blob/v1.14.0/pkg/auth/authorizer/abac/abac.go#L224">ABAC&lt;/a>：执行静态文件中定义的策略；&lt;/li>
&lt;li>&lt;a href="https://github.com/kubernetes/kubernetes/blob/v1.14.0/plugin/pkg/auth/authorizer/rbac/rbac.go#L74">RBAC&lt;/a>：执行由集群管理员添加为 k8s 资源的 RBAC 规则；&lt;/li>
&lt;li>&lt;a href="https://github.com/kubernetes/kubernetes/blob/v1.14.0/plugin/pkg/auth/authorizer/node/node_authorizer.go#L80">Node&lt;/a>：确保 kubelet 只能访问自己节点上的资源。&lt;/li>
&lt;/ul>
&lt;h3 id="admission-controller">Admission Controller&lt;a class="td-heading-self-link" href="#admission-controller" aria-label="Heading self-link">&lt;/a>&lt;/h3>
&lt;p>好的，到目前为止，我们已经过认证并获得了 kube-apiserver 的授权。那接下来呢？&lt;/p>
&lt;p>从 kube-apiserver 的角度来看，它相信我们是谁并允许我们继续，但是对于 Kubernetes， 系统的其他组件对应该和不应该允许发生的内容有异议。所以 &lt;a href="https://v1-14.docs.kubernetes.io/docs/reference/access-authn-authz/admission-controllers/">Admission Controller&lt;/a> 该闪亮登场了。&lt;/p>
&lt;p>虽然 Authorization 的重点是回答用户是否具有权限，但是 Admission Controllers 仍会拦截该请求，以确保其符合集群的更广泛期望和规则。它们是对象持久化到 etcd 之前的最后一个堡垒，因此它们封装了剩余的系统检查以确保操作不会产生意外或负面结果。&lt;/p>
&lt;p>Admission Controller 的工作方式类似于 Authentication 和 Authorization 的工作方式，但有一个区别：如果单个 Admission Controller 失败，整个链断开，请求将失败。&lt;/p>
&lt;p>Admission Controller 设计的真正优势在于它致力于提升&lt;em>可扩展性&lt;/em>。每个控制器都作为插件存储在 &lt;a href="https://github.com/kubernetes/kubernetes/tree/v1.14.0/plugin/pkg/admission">plugin/pkg/admission&lt;/a> 目录中，最后编译进 kube-apiserver 二进制文件。&lt;/p>
&lt;p>Kubernetes 目前提供十多种 Admission Controller，此处建议阅读文档 &lt;a href="https://v1-14.docs.kubernetes.io/docs/reference/access-authn-authz/admission-controllers/">Kubernetes Admission Controller&lt;/a>。&lt;/p>
&lt;h2 id="etcd">etcd&lt;a class="td-heading-self-link" href="#etcd" aria-label="Heading self-link">&lt;/a>&lt;/h2>
&lt;p>到目前为止， Kubernetes 已经完全审查了传入的请求，并允许它往下走。在下一步中，kube-apiserver 将反序列化 HTTP 请求，构造运行时对象（runtime object）（有点像 kubectl generator 的逆过程），并将它们持久化到 etcd。&lt;/p>
&lt;p>这里插入一下，kube-apiserver 是怎么知道在接受我们的请求时该怎么做呢？&lt;/p>
&lt;p>在提供任何请求之前，kube-apiserver 会发生一系列非常复杂的步骤。让我们从第一次运行 kube-apiserver 二进制文件开始：&lt;/p>
&lt;ol>
&lt;li>当运行 kube-apiserver 二进制文件时，它会创建一个&lt;a href="https://github.com/kubernetes/kubernetes/blob/v1.14.0/cmd/kube-apiserver/app/server.go#L157">服务链&lt;/a>，允许 apiserver 聚合。这是一种支持多 apiserver 的方式；&lt;/li>
&lt;li>之后，它会创建一个用作默认实现的 &lt;a href="https://github.com/kubernetes/kubernetes/blob/v1.14.0/cmd/kube-apiserver/app/server.go#L179">generic apiserver&lt;/a>；&lt;/li>
&lt;li>使用生成的 OpenAPI scheme 填充 &lt;a href="https://github.com/kubernetes/apiserver/blob/kubernetes-1.14.0/pkg/server/config.go#L147">apiserver 配置&lt;/a>；&lt;/li>
&lt;li>然后，kube-apiserver 遍历 scheme 中指定的所有 API Group， 并为其构造 &lt;a href="https://github.com/kubernetes/kubernetes/blob/v1.14.0/pkg/master/master.go#L420">storage provider&lt;/a>。当你访问或变更资源状态时， kube-apiserver 就会调用这些 API Group；&lt;/li>
&lt;li>对于每个 API Group， 它还会迭代每个组版本，并为每个 HTTP 路由&lt;a href="https://github.com/kubernetes/apiserver/blob/kubernetes-1.14.0/pkg/endpoints/groupversion.go#L99">安装 REST 映射&lt;/a>。这允许 kube-apiserver 映射请求，并且一旦找到匹配就能够委托给正确的代码逻辑；&lt;/li>
&lt;li>对于本文的特定用例，将注册一个 &lt;a href="https://github.com/kubernetes/apiserver/blob/kubernetes-1.14.0/pkg/endpoints/installer.go#L737">POST handler&lt;/a>，该处理程序将委托给 &lt;a href="https://github.com/kubernetes/apiserver/blob/kubernetes-1.14.0/pkg/endpoints/handlers/create.go#L46">create resource handler&lt;/a>。&lt;/li>
&lt;/ol>
&lt;p>到目前为止， kube-apiserver 完全知道存在哪些路由及内部映射，当请求匹配时，可以知道调用哪些处理程序和存储程序。这是非常完美的设计模式。这里我们假设 HTTP 请求已经被 kube-apiserver 收到了：&lt;/p>
&lt;ol>
&lt;li>如果程序处理链可以将请求与注册的路由匹配，它会将该请求交给注册到该路由的 &lt;a href="https://github.com/kubernetes/apiserver/blob/kubernetes-1.14.0/pkg/server/handler.go#L146">dedicated handler&lt;/a>。否则它会回退到 &lt;a href="https://github.com/kubernetes/apiserver/blob/kubernetes-1.14.0/pkg/server/mux/pathrecorder.go#L248">path-based handler&lt;/a>（这是调用 &lt;code>/apis&lt;/code> 时会发生的情况）。如果没有为该路由注册处理程序，则会调用 &lt;a href="https://github.com/kubernetes/apiserver/blob/kubernetes-1.14.0/pkg/server/mux/pathrecorder.go#L254">not found handler&lt;/a>，最终返回 &lt;code>404&lt;/code>；&lt;/li>
&lt;li>幸运的是，我们有一个处理器名为 &lt;a href="https://github.com/kubernetes/apiserver/blob/kubernetes-1.14.0/pkg/endpoints/handlers/create.go#L46">createHandler&lt;/a>! 它有什么作用？它将首先解码 HTTP 请求并执行基础验证，例如确保请求提供的 JSON 与我们的版本化 API 资源匹配；&lt;/li>
&lt;li>&lt;a href="https://github.com/kubernetes/apiserver/blob/kubernetes-1.14.0/pkg/endpoints/handlers/create.go#L126-L138">审计和准入控制阶段&lt;/a>；&lt;/li>
&lt;li>然后，资源会通过 &lt;a href="https://github.com/kubernetes/apiserver/blob/kubernetes-1.14.0/pkg/registry/generic/registry/store.go#L359">storage provider&lt;/a> &lt;a href="https://github.com/kubernetes/apiserver/blob/kubernetes-1.14.0/pkg/endpoints/handlers/create.go#L156-L161">存储到 etcd 中&lt;/a>。默认情况下，保持到 etcd 的键的格式为 &lt;code>&amp;lt;namespace&amp;gt;/&amp;lt;name&amp;gt;&lt;/code>，当然，它也支持自定义；&lt;/li>
&lt;li>资源创建过程中出现的任何错误都会被捕获，最后 storage provider 会执行 get 调用来确认该资源是否被成功创建。如果需要额外的清理工作 (finalization)，就会调用后期创建的处理器和装饰器；&lt;/li>
&lt;li>最后，&lt;a href="https://github.com/kubernetes/apiserver/blob/kubernetes-1.14.0/pkg/endpoints/handlers/create.go#L170-L177">构造 HTTP 响应&lt;/a>并返回给客户端。&lt;/li>
&lt;/ol>
&lt;p>这么多步骤！能够坚持走到这里是非常了不起的，并且我们意识到了 kube-apiserver 实际上做了很多工作。总结一下：我们部署的 Deployment 现在存在于 etcd 中，但仍没有看到它真正的 work&amp;hellip;&lt;/p>
&lt;p>&lt;strong>注&lt;/strong>：在 Kubernetes v1.14 之前，这往后还有 Initializer 的步骤，该步骤在 v1.14 &lt;a href="https://github.com/kubernetes/kubernetes/issues/67113">被 webhook admission 取代&lt;/a>。&lt;/p>
&lt;h2 id="control-loops">Control loops&lt;a class="td-heading-self-link" href="#control-loops" aria-label="Heading self-link">&lt;/a>&lt;/h2>
&lt;h3 id="deployment-controller">Deployment Controller&lt;a class="td-heading-self-link" href="#deployment-controller" aria-label="Heading self-link">&lt;/a>&lt;/h3>
&lt;p>截至目前，我们的 Deployment 已经存储于 etcd 中，并且所有的初始化逻辑都已完成。接下来的阶段将涉及 Deployment 所依赖的资源拓扑结构。&lt;/p>
&lt;p>在 Kubernetes， Deployment 实际上只是 ReplicaSet 的集合，而 ReplicaSet 是 Pod 的集合。那么 Kubernetes 如何从一个 HTTP 请求创建这个层次结构呢？这就不得不提 Kubernetes 的内置控制器 （Controller）。&lt;/p>
&lt;p>Kubernetes 系统中使用了大量的 Controller， Controller 是一个用于将系统状态从&lt;code>当前状态&lt;/code>调谐到&lt;code>期望状态&lt;/code>的异步脚本。所有内置的 Controller 都通过组件 kube-controller-manager 并行运行，每种 Controller 都负责一种具体的控制流程。&lt;/p>
&lt;p>首先，我们介绍一下 Deployment Controller：&lt;/p>
&lt;p>将 Deployment 存储到 etcd 后，我们通过 kube-apiserver 可以看到它。当这个新资源可用时， Deployment Controller 会检测到它，它的工作是监听 Deployment 的更改。在我们的例子中， Controller 通过&lt;a href="https://github.com/kubernetes/kubernetes/blob/v1.14.0//pkg/controller/deployment/deployment_controller.go#L122">注册创建事件的回调函数&lt;/a>（更多相关信息，参见下文）。&lt;/p>
&lt;p>当我们的 Deployment 首次可用时，将执行此回调函数，并&lt;a href="https://github.com/kubernetes/kubernetes/blob/v1.14.0/pkg/controller/deployment/deployment_controller.go#L166-L170">将该对象添加到内部工作队列（internal work queue）&lt;/a>。&lt;/p>
&lt;p>当它处理我们的 Deployment 对象时，控制器将&lt;a href="https://github.com/kubernetes/kubernetes/blob/v1.14.0/pkg/controller/deployment/deployment_controller.go#L571">检查我们的 Deployment&lt;/a> 并意识到没有与之关联的 ReplicaSet 或 Pod。&lt;/p>
&lt;p>它通过使用标签选择器 (label selectors) 查询 kube-apiserver 来实现此功能。有趣的是，这个同步过程是状态不可知的。另外，它以相同的方式调谐新对象和已存在的对象。&lt;/p>
&lt;p>在意识到没有与其关联的 ReplicaSet 或 Pod 后，Deployment Controller 就会开始执行&lt;a href="https://github.com/kubernetes/kubernetes/blob/v1.14.0/pkg/controller/deployment/sync.go#L378">弹性伸缩流程 (scaling process)&lt;/a>。它通过推出（例如，创建）一个 ReplicaSet， 为其分配 label selector 并将其版本号设置为 1。&lt;/p>
&lt;p>ReplicaSet 的 PodSpec 字段是从 Deployment 的 manifest 以及其他相关元数据中复制而来。有时 Deployment 在此之后也需要更新（例如，如果设置了 process deadline）。&lt;/p>
&lt;p>当完成以上步骤之后，该 &lt;a href="https://github.com/kubernetes/kubernetes/blob/v1.14.0/pkg/controller/deployment/sync.go#L67">Deployment 的 status 就会被更新&lt;/a>，然后重新进入与之前相同的循环，等待 Deployment 与期望的状态相匹配。由于 Deployment Controller 只关心 ReplicaSet， 因此调谐过程将由 ReplicaSet Controller 继续。&lt;/p>
&lt;h3 id="replicaset-controller">ReplicaSet Controller&lt;a class="td-heading-self-link" href="#replicaset-controller" aria-label="Heading self-link">&lt;/a>&lt;/h3>
&lt;p>在上一步中，Deployment Controller 创建了属于该 Deployment 的第一个 ReplicaSet， 但仍然没有创建 Pod。 所以这里我们需要引入 ReplicaSet Controller！&lt;/p>
&lt;p>ReplicaSet Controller 的工作是监视 ReplicaSet 及其相关资源 Pod 的生命周期。与大多数其它控制器一样，它通过触发某些事件的处理程序来实现。&lt;/p>
&lt;p>当创建 ReplicaSet 时（由 Deployment Controller 创建），ReplicaSet Controller 会&lt;a href="https://github.com/kubernetes/kubernetes/blob/v1.14.0/pkg/controller/replicaset/replica_set.go#L583">检查新 ReplicaSet 的状态&lt;/a>，并意识到现有状态与期望状态之间存在偏差。然后，它试图通过&lt;a href="https://github.com/kubernetes/kubernetes/blob/v1.14.0/pkg/controller/replicaset/replica_set.go#L460">调整 pod 的副本数&lt;/a>来调谐这种状态。&lt;/p>
&lt;p>Pod 的创建也是&lt;a href="https://github.com/kubernetes/kubernetes/blob/v1.14.0/pkg/controller/replicaset/replica_set.go#L478-L499">批量&lt;/a>)进行的，从数量 &lt;code>SlowStartInitialBatchSize&lt;/code> 开始，然后在每次成功的迭代中以一种 &lt;code>slow start&lt;/code> 操作加倍。这样做的目的是在大量 Pod 启动失败时（例如，由于资源配额），可以减轻 kube-apiserver 由于大量不必要的 HTTP 请求导致崩溃的风险。&lt;/p>
&lt;p>Kubernetes 通过 Owner References （子资源的某个字段中引用其父资源的 ID） 来执行严格的资源对象层级结构。这确保了一旦 Controller 管理的资源被删除（级联删除），子资源就会被垃圾收集器删除，同时还为父资源提供了一种有效的方式来避免他们竞争同一个子资源（想象两对父母认为他们拥有同一个孩子的场景）。&lt;/p>
&lt;p>Owner References 的另一个好处是，它是有状态的。如果重启任何的 Controller，那么由于资源对象的拓扑关系与 Controller 无关，该重启时间不会影响到系统的稳定运行。这种对资源隔离的重视也体现在 Controller 本身的设计中： Controller 不能对自己没有明确拥有的资源进行操作，它们之间互不干涉，互不共享。&lt;/p>
&lt;p>有时系统中也会出现孤儿 （orphaned） 资源，通常由以下两种途径产生：&lt;/p>
&lt;ul>
&lt;li>父资源被删除，但子资源没有被删除&lt;/li>
&lt;li>垃圾收集策略禁止删除子资源&lt;/li>
&lt;/ul>
&lt;p>当发生这种情况时， Controller 将会确保孤儿资源拥有新的 Owner。 多个父资源可以相互竞争同一个孤儿资源，但只有一个会成功（其他父资源会收到一个验证错误）。&lt;/p>
&lt;h3 id="informers">Informers&lt;a class="td-heading-self-link" href="#informers" aria-label="Heading self-link">&lt;/a>&lt;/h3>
&lt;p>你可能已经注意到，有些 Controller（例如 RBAC 授权器或 Deployment Controller）需要检索集群状态然后才能正常运行。&lt;/p>
&lt;p>以 RBAC authorizer 举例，当请求进入时， authorizer 会将用户的初始状态缓存下来供以后使用，然后用它来检索与 etcd 中的用户关联的所有&lt;code>角色（Role）&lt;/code>和&lt;code>角色绑定（RoleBinding）&lt;/code>。&lt;/p>
&lt;p>那么 Controller 是如何访问和修改这些资源对象的呢？答案是引入 Informer。&lt;/p>
&lt;p>Infomer 是一种模式，它允许 Controller 订阅存储事件并列出它们感兴趣的资源。除了提供一个很好的工作抽象，它还需要处理很多细节，如缓存（缓存很重要，因为它减少了不必要的 kube-apiserver 连接，并减少了服务器端和控制端的重复序列化成本）。通过使用这种设计，它还允许 Controller 以线程安全 （thread safe） 的方式进行交互，而不必担心线程冲突。&lt;/p>
&lt;p>有关 Informer 的更多信息，可深入阅读 &lt;a href="http://borismattijssen.github.io/articles/kubernetes-informers-controllers-reflectors-stores">《Kubernetes: Controllers, Informers, Reflectors and Stores》&lt;/a>&lt;/p>
&lt;h3 id="scheduler">Scheduler&lt;a class="td-heading-self-link" href="#scheduler" aria-label="Heading self-link">&lt;/a>&lt;/h3>
&lt;p>当所有的 Controller 正常运行后，etcd 中就会保存一个 Deployment、一个 ReplicaSet 和 三个 Pod， 并且可以通过 kube-apiserver 查看到。然而，这些 Pod 还处于 &lt;code>Pending&lt;/code> 状态，因为它们还没有被调度到集群中合适的 Node 上。最终解决这个问题的 Controller 是 Scheduler。&lt;/p>
&lt;p>Scheduler 作为一个独立的组件运行在集群控制平面上，工作方式与其他 Controller 相同：监听事件并调谐状态。&lt;/p>
&lt;p>具体来说， Scheduler 的作用是过滤 PodSpec 中 &lt;code>NodeName&lt;/code> 字段为空的 Pod 并尝试将其调度到合适的节点。&lt;/p>
&lt;p>为了找到合适的节点， Scheduler 会使用特定的算法，默认调度算法工作流程如下：&lt;/p>
&lt;ol>
&lt;li>当 Scheduler 启动时，会注册&lt;a href="https://github.com/kubernetes/kubernetes/blob/v1.14.0/pkg/scheduler/algorithmprovider/defaults/defaults.go#L37">一系列默认的预选策略&lt;/a>，这些预选策略会&lt;a href="https://github.com/kubernetes/kubernetes/blob/v1.14.0/pkg/scheduler/core/generic_scheduler.go#L184">对候选节点进行评估&lt;/a>，判断候选节点是否满足候选 Pod 的需求。例如，如果 PodSpec 显式地限制了 CPU 和内存资源，并且节点的资源容量不满足候选 Pod 的需求时，Pod 就不会被调度到该节点上（资源容量 = 节点资源总量 - 节点中已运行的容器需求资源 （CPU 和内存）总和）；&lt;/li>
&lt;li>一旦选择了适当的节点，就会对剩余的节点运行一系列&lt;a href="https://github.com/kubernetes/kubernetes/blob/v1.14.0/pkg/scheduler/core/generic_scheduler.go#L639-L645">优先级函数&lt;/a>，以对候选节点进行打分。例如，为了在整个系统中分散工作负载，它将偏好于资源请求较少的节点（因为这表明运行的工作负载较少）。当它运行这些函数时，它为每个节点分配一个成绩。然后选择分数最高的节点进行调度。&lt;/li>
&lt;/ol>
&lt;p>一旦算法找到了合适的节点， Scheduler 就会&lt;a href="https://github.com/kubernetes/kubernetes/blob/v1.14.0/pkg/scheduler/scheduler.go#L559-L565">创建一个 Binding 对象&lt;/a>，该对象的 Name 和 Uid 与 Pod 相匹配，并且其 &lt;code>ObjectReference&lt;/code> 字段包含所选节点的名称，然后通过&lt;a href="https://github.com/kubernetes/kubernetes/blob/v1.14.0/pkg/scheduler/factory/factory.go#L734">发送 POST 请求&lt;/a>给 kube-apiserver。&lt;/p>
&lt;p>当 kube-apiserver 接收到此 Binding 对象时，注册表会将该对象反序列化 （registry deserializes） 并更新 Pod 资源中的以下字段：&lt;/p>
&lt;ol>
&lt;li>&lt;a href="https://github.com/kubernetes/kubernetes/blob/v1.14.0/pkg/registry/core/pod/storage/storage.go#L176">将 NodeName 的值设置为 Binding 对象 ObjectReference 中的 NodeName&lt;/a>；&lt;/li>
&lt;li>&lt;a href="https://github.com/kubernetes/kubernetes/blob/v1.14.0/pkg/registry/core/pod/storage/storage.go#L180-L182">添加相关的注释 (annotations)&lt;/a>；&lt;/li>
&lt;li>&lt;a href="https://github.com/kubernetes/kubernetes/blob/v1.14.0/pkg/registry/core/pod/storage/storage.go#L183-L186">将 PodScheduled 的 status 设置为 True&lt;/a>。&lt;/li>
&lt;/ol>
&lt;p>一旦 Scheduler 将 Pod 调度到某个节点上，该节点的 Kubelet 就会接管该 Pod 并开始部署。&lt;/p>
&lt;p>附注：自定义调度器：有趣的是预选策略和优先级函数 （predicates and priority functions） 都是可扩展的，可以使用参数 &lt;code>--policy-config-file&lt;/code> 来定义。这引入了一定程度的灵活性。管理员还可以在独立部署中运行自定义调度器（具有自定义处理逻辑的调度器）。如果 PodSpec 中包含 &lt;code>schedulerName&lt;/code>，Kubernetes 会将该 pod 的调度移交给使用该名称注册的调度器。&lt;/p>
&lt;h2 id="kubelet">Kubelet&lt;a class="td-heading-self-link" href="#kubelet" aria-label="Heading self-link">&lt;/a>&lt;/h2>
&lt;h3 id="pod-sync">Pod Sync&lt;a class="td-heading-self-link" href="#pod-sync" aria-label="Heading self-link">&lt;/a>&lt;/h3>
&lt;p>截至目前，所有的 Controller 都完成了工作，让我们来总结一下：&lt;/p>
&lt;ol>
&lt;li>HTTP 请求通过了认证、授权和准入控制阶段；&lt;/li>
&lt;li>一个 Deployment、ReplicaSet 和三个 Pod 被持久化到 etcd；&lt;/li>
&lt;li>最后每个 Pod 都被调度到合适的节点。&lt;/li>
&lt;/ol>
&lt;p>然而，到目前为止，所有的状态变化仅仅只是针对保存在 etcd 中的资源对象，接下来的步骤涉及到在工作节点之间运行具体的容器，这是分布式系统 Kubernetes 的关键因素。这些事情都是由 Kubelet 完成的。&lt;/p>
&lt;p>在 Kubernetes 集群中，每个 Node 节点上都会启动一个 Kubelet 服务进程，该进程用于处理 Scheduler 下发到本节点的 Pod 并管理其生命周期。这意味着它将处理 Pod 与 Container Runtime 之间所有的转换逻辑，包括挂载卷、容器日志、垃圾回收等操作。&lt;/p>
&lt;p>一个有用的方法，你可以把 Kubelet 当成一种特殊的 Controller，它每隔 20 秒（可以自定义）向 kube-apiserver 查询 Pod，过滤 NodeName 与自身所在节点匹配的 Pod 列表。&lt;/p>
&lt;p>一旦获取到了这个列表，它就会通过与自己的内部缓存进行比较来检测差异，如果有差异，就开始同步 Pod 列表。我们来看看同步过程是什么样的：&lt;/p>
&lt;ol>
&lt;li>如果 Pod 正在创建， Kubelet 就会&lt;a href="https://github.com/kubernetes/kubernetes/blob/v1.14.0/pkg/kubelet/kubelet.go#L1504">暴露一些指标&lt;/a>，可以用于在 Prometheus 中追踪 Pod 启动延时；&lt;/li>
&lt;li>然后，&lt;a href="https://github.com/kubernetes/kubernetes/blob/v1.14.0/pkg/kubelet/kubelet_pods.go#L1333">生成一个 PodStatus 对象&lt;/a>，表示 Pod 当前阶段的状态。Pod 的 Phase 状态是 Pod 在其生命周期中的高度概括，包括 &lt;code>Pending&lt;/code>，&lt;code>Running&lt;/code>，&lt;code>Succeeded&lt;/code>，&lt;code>Failed&lt;/code> 和 &lt;code>Unknown&lt;/code> 这几个值。状态的产生过程非常复杂，因此很有必要深入深挖一下：
&lt;ul>
&lt;li>首先，串行执行一系列 &lt;code>PodSyncHandlers&lt;/code>，每个处理器检查 Pod 是否应该运行在该节点上。当其中之一的处理器认为该 Pod 不应该运行在该节点上，则 Pod 的 Phase 值就会&lt;a href="https://github.com/kubernetes/kubernetes/blob/v1.14.0/pkg/kubelet/kubelet_pods.go#L1340-L1345">变成 &lt;code>PodFailed&lt;/code>&lt;/a> 并将从该节点被驱逐。例如，以 Job 为例，当一个 Pod 失败重试的时间超过了 &lt;code>activeDeadlineSeconds&lt;/code> 设置的值，就会将该 Pod 从该节点驱逐出去；&lt;/li>
&lt;li>接下来，Pod 的 Phase 值由 init 容器和主容器状态共同决定。由于主容器尚未启动，容器被视为处于&lt;a href="https://github.com/kubernetes/kubernetes/blob/v1.14.0/pkg/kubelet/kubelet_pods.go#L1284">等待阶段&lt;/a>，如果 &lt;a href="https://github.com/kubernetes/kubernetes/blob/v1.14.0/pkg/kubelet/kubelet_pods.go#L1298-L1301">Pod 中至少有一个容器处于等待阶段，则其 Phase 值为 &lt;code>Pending&lt;/code>&lt;/a>。&lt;/li>
&lt;li>最后，Pod 的 Condition 字段由 Pod 内所有容器状态决定。现在我们的容器还没有被容器运行时 (Container Runtime) 创建，所以，Kubelet &lt;a href="https://github.com/kubernetes/kubernetes/blob/v1.14.0/pkg/kubelet/status/generate.go#L72-L83">将 &lt;code>PodReady&lt;/code> 的状态设置为 False&lt;/a>。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>生成 PodStatus 之后，Kubelet 就会将它发送到 Pod 的 status 管理器，该管理器的任务是通过 kube-apiserver 异步更新 etcd 中的记录；&lt;/li>
&lt;li>接下来运行一系列 admit handlers 以确保该 Pod 具有正确的权限（包括强制执行 &lt;a href="https://github.com/kubernetes/kubernetes/blob/v1.14.0/pkg/kubelet/kubelet.go#L864-L865">AppArmor profiles 和 NO_NEW_PRIVS&lt;/a>），在该阶段被拒绝的 Pod 将永久处于 &lt;code>Pending&lt;/code> 状态；&lt;/li>
&lt;li>如果 Kubelet 启动时指定了 &lt;code>--cgroups-per-qos&lt;/code> 参数，Kubelet 就会为该 Pod 创建 cgroup 并设置对应的资源限制。这是为了更好的 Pod 服务质量（QoS）；&lt;/li>
&lt;li>为 Pod &lt;a href="https://github.com/kubernetes/kubernetes/blob/v1.14.0/pkg/kubelet/kubelet_pods.go#L826-L839">创建相应的数据目录&lt;/a>，包括：
&lt;ul>
&lt;li>Pod 目录 (通常是 &lt;code>/var/run/kubelet/pods/&amp;lt;podID&amp;gt;&lt;/code>)；&lt;/li>
&lt;li>Pod 的挂载卷目录 (&lt;code>&amp;lt;podDir&amp;gt;/volumes&lt;/code>)；&lt;/li>
&lt;li>Pod 的插件目录 (&lt;code>&amp;lt;podDir&amp;gt;/plugins&lt;/code>)。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>卷管理器会&lt;a href="https://github.com/kubernetes/kubernetes/blob/v1.14.0/pkg/kubelet/volumemanager/volume_manager.go#L339">挂载 &lt;code>Spec.Volumes&lt;/code> 中定义的相关数据卷&lt;/a>，然后等待挂载成功；&lt;/li>
&lt;li>从 kube-apiserver 中检索 &lt;code>Spec.ImagePullSecrets&lt;/code>，然后将对应的 Secret 注入到容器中；&lt;/li>
&lt;li>最后，通过容器运行时 （Container Runtime） 启动容器（下面会详细描述）。&lt;/li>
&lt;/ol>
&lt;h3 id="cri-and-pause-container">CRI and pause container&lt;a class="td-heading-self-link" href="#cri-and-pause-container" aria-label="Heading self-link">&lt;/a>&lt;/h3>
&lt;p>到了这个阶段，大量的初始化工作都已经完成，容器已经准备好开始启动了，而容器是由容器运行时（例如 Docker）启动的。&lt;/p>
&lt;p>为了更具可扩展性， Kubelet 使用 CRI （Container Runtime Interface） 来与具体的容器运行时进行交互。简而言之， CRI 提供了 Kubelet 和特定容器运行时实现之间的抽象。通过 &lt;a href="https://github.com/google/protobuf">protocol buffers&lt;/a>（一种更快的 JSON） 和 &lt;a href="https://grpc.io/">gRPC API&lt;/a>（一种非常适合执行 Kubernetes 操作的API）进行通信。&lt;/p>
&lt;p>这是一个非常酷的想法，因为通过在 Kubelet 和容器运行时之间使用已定义的接口约定，容器编排的实际实现细节变得无关紧要。重要的是接口约定。这允许以最小的开销添加新的容器运行时，因为没有核心 Kubernetes 代码需要更改！&lt;/p>
&lt;p>回到部署我们的容器，当一个 Pod 首次启动时， Kubelet &lt;a href="https://github.com/kubernetes/kubernetes/blob/v1.14.0/pkg/kubelet/kuberuntime/kuberuntime_sandbox.go#L65">调用 RunPodSandbox 远程过程命令 （remote procedure command RPC）&lt;/a>。沙箱 （sandbox） 是描述一组容器的 CRI 术语，在 Kubernetes 中对应的是 Pod。这个术语是故意模糊的，因此其他不使用容器的运行时，不会失去其意义（想象一个基于 hypervisor 的运行时，沙箱可能指的是 VM）。&lt;/p>
&lt;p>在我们的例子中，我们使用的是 Docker。 在 Docker 中，创建沙箱涉及创建 &lt;code>pause&lt;/code> 容器。&lt;/p>
&lt;p>&lt;code>pause&lt;/code> 容器像 Pod 中的所有其他容器的父级一样，因为它承载了工作负载容器最终将使用的许多 Pod 级资源。这些“资源”是 Linux Namespaces (IPC，Network，PID)。&lt;/p>
&lt;blockquote>
&lt;p>如果你不熟悉容器在 Linux 中的工作方式，那么我们快速回顾一下。 Linux 内核具有 Namespace 的概念，允许主机操作系统分割出一组专用资源（例如 CPU 或内存）并将其提供给一个进程，就好像它是世界上唯一使用它们的东西一样。 Cgroup 在这里也很重要，因为它们是 Linux 管理资源隔离的方式。 Docker 使用这两个内核功能来托管一个保证资源强制隔离的进程。更多信息，可深入阅读 &lt;a href="https://jvns.ca/blog/2016/10/10/what-even-is-a-container/">What even is a Container?&lt;/a>&lt;/p>
&lt;/blockquote>
&lt;p>&lt;code>pause&lt;/code> 容器提供了一种托管所有这些 Namespaces 的方法，并允许子容器共享它们。通过成为同一 Network Namespace 的一部分，一个好处是同一个 Pod 中的容器可以使用 localhost 相互访问。&lt;/p>
&lt;p>&lt;code>pause&lt;/code> 容器的第二个好处与 PID Namespace 有关。在这些 Namespace 中，进程形成一个分层树（hierarchical tree），顶部的“init” 进程负责“收获”僵尸进程。更多信息，请深入阅读 &lt;a href="https://www.ianlewis.org/en/almighty-pause-container">great blog post&lt;/a>。&lt;/p>
&lt;p>创建 &lt;code>pause&lt;/code> 容器后，将开始检查磁盘状态然后启动主容器。&lt;/p>
&lt;h3 id="cni-and-pod-networking">CNI and pod networking&lt;a class="td-heading-self-link" href="#cni-and-pod-networking" aria-label="Heading self-link">&lt;/a>&lt;/h3>
&lt;p>现在，我们的 Pod 有了基本的骨架：一个 &lt;code>pause&lt;/code> 容器，它托管所有 Namespaces 以允许 Pod 间通信。但容器网络如何运作以及建立的？&lt;/p>
&lt;p>当 Kubelet 为 Pod 设置网络时，它将任务委托给 &lt;code>CNI (Container Network Interface)&lt;/code> 插件。其运行方式与 Container Runtime Interface 类似。简而言之， CNI 是一种抽象，允许不同的网络提供商对容器使用不同的网络实现。&lt;/p>
&lt;p>Kubelet 通过 stdin 将 JSON 数据（配置文件位于 &lt;code>/etc/cni/net.d&lt;/code> 中）传输到相关的 CNI 二进制文件（位于 &lt;code>/opt/cni/bin&lt;/code>） 中与之交互。下面是一个简单的示例 JSON 配置文件：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-yaml" data-lang="yaml">&lt;span style="display:flex;">&lt;span>{&lt;span style="color:#f8f8f8;text-decoration:underline">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f8f8f8;text-decoration:underline"> &lt;/span>&lt;span style="color:#204a87;font-weight:bold">&amp;#34;cniVersion&amp;#34;: &lt;/span>&lt;span style="color:#4e9a06">&amp;#34;0.3.1&amp;#34;&lt;/span>&lt;span style="color:#000;font-weight:bold">,&lt;/span>&lt;span style="color:#f8f8f8;text-decoration:underline">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f8f8f8;text-decoration:underline"> &lt;/span>&lt;span style="color:#204a87;font-weight:bold">&amp;#34;name&amp;#34;: &lt;/span>&lt;span style="color:#4e9a06">&amp;#34;bridge&amp;#34;&lt;/span>&lt;span style="color:#000;font-weight:bold">,&lt;/span>&lt;span style="color:#f8f8f8;text-decoration:underline">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f8f8f8;text-decoration:underline"> &lt;/span>&lt;span style="color:#204a87;font-weight:bold">&amp;#34;type&amp;#34;: &lt;/span>&lt;span style="color:#4e9a06">&amp;#34;bridge&amp;#34;&lt;/span>&lt;span style="color:#000;font-weight:bold">,&lt;/span>&lt;span style="color:#f8f8f8;text-decoration:underline">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f8f8f8;text-decoration:underline"> &lt;/span>&lt;span style="color:#204a87;font-weight:bold">&amp;#34;bridge&amp;#34;: &lt;/span>&lt;span style="color:#4e9a06">&amp;#34;cnio0&amp;#34;&lt;/span>&lt;span style="color:#000;font-weight:bold">,&lt;/span>&lt;span style="color:#f8f8f8;text-decoration:underline">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f8f8f8;text-decoration:underline"> &lt;/span>&lt;span style="color:#204a87;font-weight:bold">&amp;#34;isGateway&amp;#34;: &lt;/span>&lt;span style="color:#204a87;font-weight:bold">true&lt;/span>&lt;span style="color:#000;font-weight:bold">,&lt;/span>&lt;span style="color:#f8f8f8;text-decoration:underline">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f8f8f8;text-decoration:underline"> &lt;/span>&lt;span style="color:#204a87;font-weight:bold">&amp;#34;ipMasq&amp;#34;: &lt;/span>&lt;span style="color:#204a87;font-weight:bold">true&lt;/span>&lt;span style="color:#000;font-weight:bold">,&lt;/span>&lt;span style="color:#f8f8f8;text-decoration:underline">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f8f8f8;text-decoration:underline"> &lt;/span>&lt;span style="color:#204a87;font-weight:bold">&amp;#34;ipam&amp;#34;: &lt;/span>{&lt;span style="color:#f8f8f8;text-decoration:underline">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f8f8f8;text-decoration:underline"> &lt;/span>&lt;span style="color:#204a87;font-weight:bold">&amp;#34;type&amp;#34;: &lt;/span>&lt;span style="color:#4e9a06">&amp;#34;host-local&amp;#34;&lt;/span>&lt;span style="color:#000;font-weight:bold">,&lt;/span>&lt;span style="color:#f8f8f8;text-decoration:underline">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f8f8f8;text-decoration:underline"> &lt;/span>&lt;span style="color:#204a87;font-weight:bold">&amp;#34;ranges&amp;#34;: &lt;/span>&lt;span style="color:#000;font-weight:bold">[&lt;/span>&lt;span style="color:#f8f8f8;text-decoration:underline">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f8f8f8;text-decoration:underline"> &lt;/span>&lt;span style="color:#000;font-weight:bold">[&lt;/span>{&lt;span style="color:#204a87;font-weight:bold">&amp;#34;subnet&amp;#34;: &lt;/span>&lt;span style="color:#4e9a06">&amp;#34;${POD_CIDR}&amp;#34;&lt;/span>}&lt;span style="color:#000;font-weight:bold">]&lt;/span>&lt;span style="color:#f8f8f8;text-decoration:underline">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f8f8f8;text-decoration:underline"> &lt;/span>&lt;span style="color:#000;font-weight:bold">],&lt;/span>&lt;span style="color:#f8f8f8;text-decoration:underline">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f8f8f8;text-decoration:underline"> &lt;/span>&lt;span style="color:#204a87;font-weight:bold">&amp;#34;routes&amp;#34;: [{&amp;#34;dst&amp;#34;: &lt;/span>&lt;span style="color:#4e9a06">&amp;#34;0.0.0.0/0&amp;#34;&lt;/span>}&lt;span style="color:#000;font-weight:bold">]&lt;/span>&lt;span style="color:#f8f8f8;text-decoration:underline">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f8f8f8;text-decoration:underline"> &lt;/span>}&lt;span style="color:#f8f8f8;text-decoration:underline">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f8f8f8;text-decoration:underline">&lt;/span>}&lt;span style="color:#f8f8f8;text-decoration:underline">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>CNI 插件还可以通过 &lt;code>CNI_ARGS&lt;/code> 环境变量为 Pod 指定其他的元数据，包括 Pod Name 和 Namespace。&lt;/p>
&lt;p>接下来会发生什么取决于 CNI 插件，这里，我们以 &lt;code>bridge&lt;/code> CNI 插件为例：&lt;/p>
&lt;ol>
&lt;li>该插件首先会在 Root Network Namespace（也就是宿主机的 Network Namespace） 中设置本地 Linux 网桥，以便为该主机上的所有容器提供网络服务；&lt;/li>
&lt;li>然后它会将一个网络接口 （veth 设备对的一端）插入到 &lt;code>pause&lt;/code> 容器的 Network Namespace 中，并将另一端连接到网桥上。你可以这样来理解 veth 设备对：它就像一根很长的管道，一端连接到容器，一端连接到 Root Network Namespace 中，允许数据包在中间传输；&lt;/li>
&lt;li>然后它会为 &lt;code>pause&lt;/code> 容器的网络接口分配一个 IP 并设置相应的路由，于是 Pod 就有了自己的 IP。IP 的分配是由 JSON 配置文件中指定的 IPAM Plugin 实现的；
&lt;ul>
&lt;li>IPAM Plugin 的工作方式和 CNI 插件类似：通过二进制文件调用并具有标准化的接口，每一个 IPAM Plugin 都必须要确定容器网络接口的 IP、子网以及网关和路由，并将信息返回给 CNI 插件。最常见的 IPAM Plugin 称为 host-local，它从预定义的一组地址池为容器分配 IP 地址。它将相关信息保存在主机的文件系统中，从而确保了单个主机上每个容器 IP 地址的唯一性。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>对于 DNS， Kubelet 将为 CNI 插件指定 Kubernetes 集群内部 DNS 服务器 IP 地址，确保正确设置容器的 &lt;code>resolv.conf&lt;/code> 文件。&lt;/li>
&lt;/ol>
&lt;h3 id="inter-host-networking">Inter-host networking&lt;a class="td-heading-self-link" href="#inter-host-networking" aria-label="Heading self-link">&lt;/a>&lt;/h3>
&lt;p>到目前为止，我们已经描述了容器如何与宿主机进行通信，但跨主机之间的容器如何通信呢？&lt;/p>
&lt;p>通常情况下， Kubernetes 使用 Overlay 网络来进行跨主机容器通信，这是一种动态同步多个主机间路由的方法。一个较常用的 Overlay 网络插件是 &lt;code>flannel&lt;/code>，它提供了跨节点的三层网络。&lt;/p>
&lt;p>flannel 不会管容器与宿主机之间的通信（这是 CNI 插件的职责），但它对主机间的流量传输负责。为此，它为主机选择一个子网并将其注册到 etcd。然后，它保留集群路由的本地表示，并将传出的数据包封装在 UDP 数据报中，确保它到达正确的主机。&lt;/p>
&lt;p>更多信息，请深入阅读 &lt;a href="https://github.com/coreos/flannel">CoreOS&amp;rsquo;s documentation&lt;/a>。&lt;/p>
&lt;h3 id="container-startup">Container startup&lt;a class="td-heading-self-link" href="#container-startup" aria-label="Heading self-link">&lt;/a>&lt;/h3>
&lt;p>所有的网络配置都已完成。还剩什么？真正地启动工作负载容器！&lt;/p>
&lt;p>一旦沙箱完成初始化并处于 &lt;code>active&lt;/code> 状态， Kubelet 将开始为其创建容器。首先&lt;a href="https://github.com/kubernetes/kubernetes/blob/v1.14.0/pkg/kubelet/kuberuntime/kuberuntime_manager.go#L736">启动 PodSpec 中定义的 Init Container&lt;/a>，然后再启动主容器。具体过程如下：&lt;/p>
&lt;ol>
&lt;li>&lt;a href="https://github.com/kubernetes/kubernetes/blob/v1.14.0/pkg/kubelet/kuberuntime/kuberuntime_container.go#L95">拉取容器的镜像&lt;/a>。如果是私有仓库的镜像，就会使用 PodSpec 中指定的 imagePullSecrets 来拉取该镜像；&lt;/li>
&lt;li>&lt;a href="https://github.com/kubernetes/kubernetes/blob/v1.14.0/pkg/kubelet/kuberuntime/kuberuntime_container.go#L124">通过 CRI 创建容器&lt;/a>。 Kubelet 使用 PodSpec 中的信息填充了一个 &lt;code>ContainerConfig&lt;/code> 数据结构（在其中定义了 command， image， labels， mounts， devices， environment variables 等），然后通过 protobufs 发送给 CRI。 对于 Docker 来说，它会将这些信息反序列化并填充到自己的配置信息中，然后再发送给 Dockerd 守护进程。在这个过程中，它会将一些元数据（例如容器类型，日志路径，sandbox ID 等）添加到容器中；&lt;/li>
&lt;li>然后 Kubelet 将容器注册到 CPU 管理器，它通过使用 &lt;code>UpdateContainerResources&lt;/code> CRI 方法给容器分配给本地节点上的 CPU 资源；&lt;/li>
&lt;li>最后&lt;a href="https://github.com/kubernetes/kubernetes/blob/v1.14.0/pkg/kubelet/kuberuntime/kuberuntime_container.go#L144">容器真正地启动&lt;/a>；&lt;/li>
&lt;li>如果 Pod 中包含 &lt;a href="https://v1-14.docs.kubernetes.io/docs/concepts/containers/container-lifecycle-hooks/">Container Lifecycle Hooks&lt;/a>，容器启动之后就会&lt;a href="https://github.com/kubernetes/kubernetes/blob/v1.14.0/pkg/kubelet/kuberuntime/kuberuntime_container.go#L170-L185">运行这些 Hooks&lt;/a>。 Hook 的类型包括两种：Exec（执行一段命令） 和 HTTP（发送HTTP请求）。如果 PostStart Hook 启动的时间过长、挂起或者失败，容器将永远不会变成 Running 状态。&lt;/li>
&lt;/ol>
&lt;h2 id="wrap-up">Wrap-up&lt;a class="td-heading-self-link" href="#wrap-up" aria-label="Heading self-link">&lt;/a>&lt;/h2>
&lt;p>最后的最后，现在我们的集群上应该会运行三个容器，分布在一个或多个工作节点上。所有的网络，数据卷和秘钥都由 Kubelet 填充，并通过 CRI 接口添加到容器中并配置成功！&lt;/p>
&lt;h1 id="来自-ai-的回答">来自 AI 的回答&lt;a class="td-heading-self-link" href="#%e6%9d%a5%e8%87%aa-ai-%e7%9a%84%e5%9b%9e%e7%ad%94" aria-label="Heading self-link">&lt;/a>&lt;/h1>
&lt;p>&lt;a href="https://www.perplexity.ai/search/zai-kubernetes-zhi-xing-zhi-xi-ByGElLvSToOBNYtvMa569g">https://www.perplexity.ai/search/zai-kubernetes-zhi-xing-zhi-xi-ByGElLvSToOBNYtvMa569g&lt;/a>&lt;/p>
&lt;h2 id="问-在-kubernetes-执行执行-apply-之后都经历了什么apiserver-controller-scheduler-etcd-kubelet-等组件都是如何调用">问: 在 kubernetes 执行执行 apply 之后，都经历了什么，apiserver controller scheduler etcd kubelet 等组件都是如何调用&lt;a class="td-heading-self-link" href="#%e9%97%ae-%e5%9c%a8-kubernetes-%e6%89%a7%e8%a1%8c%e6%89%a7%e8%a1%8c-apply-%e4%b9%8b%e5%90%8e%e9%83%bd%e7%bb%8f%e5%8e%86%e4%ba%86%e4%bb%80%e4%b9%88apiserver-controller-scheduler-etcd-kubelet-%e7%ad%89%e7%bb%84%e4%bb%b6%e9%83%bd%e6%98%af%e5%a6%82%e4%bd%95%e8%b0%83%e7%94%a8" aria-label="Heading self-link">&lt;/a>&lt;/h2>
&lt;p>当执行 &lt;code>kubectl apply -f rs.yaml&lt;/code> 创建资源时，Kubernetes 集群中的各个组件会经历以下流程:&lt;/p>
&lt;h3 id="答">答&lt;a class="td-heading-self-link" href="#%e7%ad%94" aria-label="Heading self-link">&lt;/a>&lt;/h3>
&lt;h4 id="1-api-server">1. API Server&lt;a class="td-heading-self-link" href="#1-api-server" aria-label="Heading self-link">&lt;/a>&lt;/h4>
&lt;ul>
&lt;li>API Server 接收到 kubectl 发送的创建资源请求&lt;/li>
&lt;li>API Server 将创建请求写入 etcd 中保存&lt;a href="https://kubernetes.feisky.xyz/concepts/components">&lt;/a>&lt;a href="https://www.cnblogs.com/ZhuChangwu/p/16441181.html">&lt;/a>&lt;/li>
&lt;/ul>
&lt;h4 id="2-etcd">2. etcd&lt;a class="td-heading-self-link" href="#2-etcd" aria-label="Heading self-link">&lt;/a>&lt;/h4>
&lt;ul>
&lt;li>etcd 接收到 API Server 写入的创建请求，并将其持久化存储&lt;a href="https://kubernetes.feisky.xyz/concepts/components">&lt;/a>&lt;a href="https://www.cnblogs.com/ZhuChangwu/p/16441181.html">&lt;/a>&lt;/li>
&lt;li>etcd 将创建事件的回调发送给 API Server&lt;a href="https://www.cnblogs.com/ZhuChangwu/p/16441181.html">&lt;/a>&lt;/li>
&lt;/ul>
&lt;h4 id="3-api-server">3. API Server&lt;a class="td-heading-self-link" href="#3-api-server" aria-label="Heading self-link">&lt;/a>&lt;/h4>
&lt;ul>
&lt;li>API Server 接收到 etcd 的创建事件回调&lt;/li>
&lt;li>API Server 将创建事件发送给 Controller Manager&lt;a href="https://www.cnblogs.com/ZhuChangwu/p/16441181.html">&lt;/a>&lt;/li>
&lt;/ul>
&lt;h4 id="4-controller-manager">4. Controller Manager&lt;a class="td-heading-self-link" href="#4-controller-manager" aria-label="Heading self-link">&lt;/a>&lt;/h4>
&lt;ul>
&lt;li>Controller Manager 中的 Replication Controller 监听到创建事件&lt;/li>
&lt;li>Replication Controller 处理请求，创建 ReplicaSet，并调整 Pod 副本数量至期望值&lt;a href="https://www.cnblogs.com/ZhuChangwu/p/16441181.html">&lt;/a>&lt;/li>
&lt;li>Replication Controller 告知 API Server 需要创建 Pod&lt;a href="https://www.cnblogs.com/ZhuChangwu/p/16441181.html">&lt;/a>&lt;/li>
&lt;/ul>
&lt;h4 id="5-api-server">5. API Server&lt;a class="td-heading-self-link" href="#5-api-server" aria-label="Heading self-link">&lt;/a>&lt;/h4>
&lt;ul>
&lt;li>API Server 接收到 Controller Manager 的创建 Pod 请求&lt;/li>
&lt;li>API Server 将创建 Pod 的请求写入 etcd&lt;a href="https://www.cnblogs.com/ZhuChangwu/p/16441181.html">&lt;/a>&lt;/li>
&lt;li>API Server 接收到 etcd 的 Pod 创建事件回调&lt;/li>
&lt;li>API Server 将 Pod 创建事件发送给 Scheduler&lt;a href="https://www.cnblogs.com/ZhuChangwu/p/16441181.html">&lt;/a>&lt;/li>
&lt;/ul>
&lt;h4 id="6-scheduler">6. Scheduler&lt;a class="td-heading-self-link" href="#6-scheduler" aria-label="Heading self-link">&lt;/a>&lt;/h4>
&lt;ul>
&lt;li>Scheduler 监听到 API Server 发送的创建 Pod 事件&lt;/li>
&lt;li>Scheduler 为 Pod 选择一个合适的 Node 节点进行调度&lt;a href="https://kubernetes.feisky.xyz/concepts/components">&lt;/a>&lt;a href="https://www.cnblogs.com/ZhuChangwu/p/16441181.html">&lt;/a>&lt;a href="http://www.asznl.com/post/33">&lt;/a>&lt;/li>
&lt;li>Scheduler 告知 API Server 调度结果&lt;a href="https://www.cnblogs.com/ZhuChangwu/p/16441181.html">&lt;/a>&lt;/li>
&lt;/ul>
&lt;h4 id="7-api-server">7. API Server&lt;a class="td-heading-self-link" href="#7-api-server" aria-label="Heading self-link">&lt;/a>&lt;/h4>
&lt;ul>
&lt;li>API Server 接收到 Scheduler 的调度结果&lt;/li>
&lt;li>API Server 将调度信息更新到 etcd 中&lt;a href="https://www.cnblogs.com/ZhuChangwu/p/16441181.html">&lt;/a>&lt;/li>
&lt;li>API Server 接收到 etcd 的调度更新事件回调&lt;/li>
&lt;li>API Server 将调度更新事件发送给对应 Node 上的 kubelet&lt;a href="https://www.cnblogs.com/ZhuChangwu/p/16441181.html">&lt;/a>&lt;/li>
&lt;/ul>
&lt;h4 id="8-kubelet">8. kubelet&lt;a class="td-heading-self-link" href="#8-kubelet" aria-label="Heading self-link">&lt;/a>&lt;/h4>
&lt;ul>
&lt;li>kubelet 监听到 API Server 发送的 Pod 创建事件&lt;/li>
&lt;li>kubelet 通过 CRI 接口与容器运行时(如 Docker)交互，创建并维护 Pod 中的容器&lt;a href="https://www.cnblogs.com/ZhuChangwu/p/16441181.html">&lt;/a>&lt;a href="http://www.asznl.com/post/33">&lt;/a>&lt;/li>
&lt;/ul>
&lt;p>总的来说，&lt;code>kubectl apply&lt;/code> 触发了一系列的事件，API Server 作为统一入口接收请求并与 etcd 交互存储数据，Controller Manager 监控资源状态并执行控制逻辑，Scheduler 为 Pod 选择合适的 Node，kubelet 负责容器的生命周期管理。各组件通过 watch API 监听事件并执行相应操作，最终达成集群期望状态。&lt;/p>
&lt;h2 id="问-controlerscheduler-都是如何直到如何访问到-apiserver-的在哪配置的-ipport-或者域名">问: controler、scheduler 都是如何直到如何访问到 apiserver 的？在哪配置的 IP:port 或者域名？&lt;a class="td-heading-self-link" href="#%e9%97%ae-controlerscheduler-%e9%83%bd%e6%98%af%e5%a6%82%e4%bd%95%e7%9b%b4%e5%88%b0%e5%a6%82%e4%bd%95%e8%ae%bf%e9%97%ae%e5%88%b0-apiserver-%e7%9a%84%e5%9c%a8%e5%93%aa%e9%85%8d%e7%bd%ae%e7%9a%84-ipport-%e6%88%96%e8%80%85%e5%9f%9f%e5%90%8d" aria-label="Heading self-link">&lt;/a>&lt;/h2>
&lt;h3 id="答-1">答&lt;a class="td-heading-self-link" href="#%e7%ad%94-1" aria-label="Heading self-link">&lt;/a>&lt;/h3>
&lt;p>Controller Manager 和 Scheduler 通过以下方式访问 API Server:&lt;/p>
&lt;h4 id="配置-api-server-地址">配置 API Server 地址&lt;a class="td-heading-self-link" href="#%e9%85%8d%e7%bd%ae-api-server-%e5%9c%b0%e5%9d%80" aria-label="Heading self-link">&lt;/a>&lt;/h4>
&lt;ul>
&lt;li>Controller Manager 和 Scheduler 在启动时通过命令行参数或配置文件指定 API Server 的地址,如 &lt;code>--master=http://192.168.1.100:8080&lt;/code>&lt;a href="https://kubernetes.io/docs/concepts/overview/components/">&lt;/a>&lt;/li>
&lt;li>也可以通过环境变量 &lt;code>KUBERNETES_MASTER&lt;/code> 设置 API Server 地址&lt;a href="https://kubernetes.io/docs/concepts/overview/components/">&lt;/a>&lt;/li>
&lt;/ul>
&lt;h4 id="使用-kubernetes-客户端库">使用 Kubernetes 客户端库&lt;a class="td-heading-self-link" href="#%e4%bd%bf%e7%94%a8-kubernetes-%e5%ae%a2%e6%88%b7%e7%ab%af%e5%ba%93" aria-label="Heading self-link">&lt;/a>&lt;/h4>
&lt;ul>
&lt;li>Controller Manager 和 Scheduler 内部使用 Kubernetes 客户端库与 API Server 进行交互&lt;/li>
&lt;li>客户端库会读取环境变量或配置文件中的 API Server 地址,如 &lt;code>KUBECONFIG&lt;/code> 环境变量指定的 kubeconfig 文件&lt;a href="https://kubernetes.io/docs/concepts/overview/components/">&lt;/a>&lt;/li>
&lt;li>客户端库提供了一系列 API 方法用于与 API Server 进行通信,如 &lt;code>RESTClient.Get()&lt;/code>、&lt;code>RESTClient.Put()&lt;/code> 等&lt;a href="https://mutoulazy.github.io/2020/04/14/kubernetes/framework/kubernetes-base-framework/">&lt;/a>&lt;/li>
&lt;/ul>
&lt;h4 id="通过-informer-机制-watch-数据">通过 Informer 机制 watch 数据&lt;a class="td-heading-self-link" href="#%e9%80%9a%e8%bf%87-informer-%e6%9c%ba%e5%88%b6-watch-%e6%95%b0%e6%8d%ae" aria-label="Heading self-link">&lt;/a>&lt;/h4>
&lt;ul>
&lt;li>Controller Manager 和 Scheduler 通过 Informer 机制 watch 所需的资源对象,如 Pod、Node 等&lt;a href="https://mutoulazy.github.io/2020/04/14/kubernetes/framework/kubernetes-base-framework/">&lt;/a>&lt;/li>
&lt;li>Informer 会缓存对象数据,并在对象变化时通知 Controller Manager 和 Scheduler&lt;/li>
&lt;li>Informer 内部使用客户端库与 API Server 进行交互,获取对象数据&lt;/li>
&lt;/ul>
&lt;p>总之,Controller Manager 和 Scheduler 在启动时配置 API Server 地址,然后使用客户端库与 API Server 进行交互,通过 Informer 机制 watch 所需的资源对象数据。这些组件都是通过标准的 Kubernetes 客户端库与 API Server 进行通信,而不是直接访问 API Server 的 HTTP 接口。&lt;/p>
&lt;h2 id="问-你提到了-api-server-将创建事件发送给-controller-manager-这个那-api-server-是如何找到-controller-的">问: 你提到了 API Server 将创建事件发送给 Controller Manager 这个，那 API Server 是如何找到 Controller 的？&lt;a class="td-heading-self-link" href="#%e9%97%ae-%e4%bd%a0%e6%8f%90%e5%88%b0%e4%ba%86-api-server-%e5%b0%86%e5%88%9b%e5%bb%ba%e4%ba%8b%e4%bb%b6%e5%8f%91%e9%80%81%e7%bb%99-controller-manager-%e8%bf%99%e4%b8%aa%e9%82%a3-api-server-%e6%98%af%e5%a6%82%e4%bd%95%e6%89%be%e5%88%b0-controller-%e7%9a%84" aria-label="Heading self-link">&lt;/a>&lt;/h2>
&lt;h3 id="答-2">答&lt;a class="td-heading-self-link" href="#%e7%ad%94-2" aria-label="Heading self-link">&lt;/a>&lt;/h3>
&lt;p>API Server 如何找到 Controller Manager 的机制主要依赖于以下几个方面：&lt;/p>
&lt;h4 id="1-事件通知机制">1. 事件通知机制&lt;a class="td-heading-self-link" href="#1-%e4%ba%8b%e4%bb%b6%e9%80%9a%e7%9f%a5%e6%9c%ba%e5%88%b6" aria-label="Heading self-link">&lt;/a>&lt;/h4>
&lt;ul>
&lt;li>&lt;strong>Watch 机制&lt;/strong>：API Server 使用 Watch 机制来监控 Kubernetes 集群中的资源状态变化。当资源（如 Pod、Deployment 等）发生变化时，API Server 会将这些事件推送给注册的 Controller Manager。Controller Manager 内部有多个 Controller，每个 Controller 负责特定资源的管理。&lt;/li>
&lt;li>&lt;strong>事件分发&lt;/strong>：API Server 会将变化的事件通过 HTTP 连接发送给 Controller Manager。Controller Manager 通过其内部的事件处理机制，接收并处理这些事件，从而做出相应的决策和操作&lt;a href="https://blog.csdn.net/liyunlong41/article/details/105992501">&lt;/a>&lt;a href="https://www.cnblogs.com/ZhuChangwu/p/16441181.html">&lt;/a>。&lt;/li>
&lt;/ul>
&lt;h4 id="2-client-go-库">2. Client-go 库&lt;a class="td-heading-self-link" href="#2-client-go-%e5%ba%93" aria-label="Heading self-link">&lt;/a>&lt;/h4>
&lt;ul>
&lt;li>&lt;strong>Kubernetes 客户端库&lt;/strong>：Controller Manager 使用 Kubernetes 的 client-go 库与 API Server 进行交互。client-go 库提供了一个高层次的 API，使得 Controller Manager 可以方便地与 API Server 进行通信，包括 List 和 Watch 操作。&lt;/li>
&lt;li>&lt;strong>注册 Handler&lt;/strong>：在 Controller Manager 中，Controller 会注册自己的事件处理程序（Handler），以便在接收到特定资源的事件时能够正确处理。例如，Deployment Controller 会注册处理 Deployment 相关事件的 Handler&lt;a href="https://blog.csdn.net/liyunlong41/article/details/105992501">&lt;/a>&lt;a href="https://blog.csdn.net/qq_40378034/article/details/135659138">&lt;/a>&lt;a href="https://mutoulazy.github.io/2020/04/14/kubernetes/framework/kubernetes-base-framework/">&lt;/a>。&lt;/li>
&lt;/ul>
&lt;h4 id="3-配置-api-server-地址">3. 配置 API Server 地址&lt;a class="td-heading-self-link" href="#3-%e9%85%8d%e7%bd%ae-api-server-%e5%9c%b0%e5%9d%80" aria-label="Heading self-link">&lt;/a>&lt;/h4>
&lt;ul>
&lt;li>&lt;strong>启动参数&lt;/strong>：Controller Manager 在启动时可以通过命令行参数（如 &lt;code>--master&lt;/code>）指定 API Server 的地址。这一地址通常是 API Server 的 IP 地址和端口号，或者是域名。&lt;/li>
&lt;li>&lt;strong>环境变量&lt;/strong>：此外，Controller Manager 还可以通过环境变量（如 &lt;code>KUBECONFIG&lt;/code>）来获取 API Server 的地址配置&lt;a href="https://www.cnblogs.com/xiao2shiqi/p/17898028.html">&lt;/a>&lt;a href="https://www.cnblogs.com/ZhuChangwu/p/16441181.html">&lt;/a>。&lt;/li>
&lt;/ul>
&lt;h2 id="总结">总结&lt;a class="td-heading-self-link" href="#%e6%80%bb%e7%bb%93" aria-label="Heading self-link">&lt;/a>&lt;/h2>
&lt;p>API Server 通过 Watch 机制主动通知 Controller Manager 资源状态的变化，Controller Manager 使用 client-go 库与 API Server 进行交互，并通过启动参数或环境变量配置 API Server 的地址。这种设计确保了 Kubernetes 集群中各个组件之间的高效通信和协作。&lt;/p>
&lt;h2 id="问-这-controllerscheduler-之类的程序是怎么被-watch-到的每隔一段时间找-api-server-建立连接吗">问: 这 controller、scheduler 之类的程序是怎么被 watch 到的？每隔一段时间找 api server 建立连接吗？&lt;a class="td-heading-self-link" href="#%e9%97%ae-%e8%bf%99-controllerscheduler-%e4%b9%8b%e7%b1%bb%e7%9a%84%e7%a8%8b%e5%ba%8f%e6%98%af%e6%80%8e%e4%b9%88%e8%a2%ab-watch-%e5%88%b0%e7%9a%84%e6%af%8f%e9%9a%94%e4%b8%80%e6%ae%b5%e6%97%b6%e9%97%b4%e6%89%be-api-server-%e5%bb%ba%e7%ab%8b%e8%bf%9e%e6%8e%a5%e5%90%97" aria-label="Heading self-link">&lt;/a>&lt;/h2>
&lt;h3 id="答-3">答&lt;a class="td-heading-self-link" href="#%e7%ad%94-3" aria-label="Heading self-link">&lt;/a>&lt;/h3>
&lt;p>Controller Manager 和 Scheduler 通过以下方式监听 API Server 的资源变化事件:&lt;/p>
&lt;h4 id="informer-机制">Informer 机制&lt;a class="td-heading-self-link" href="#informer-%e6%9c%ba%e5%88%b6" aria-label="Heading self-link">&lt;/a>&lt;/h4>
&lt;ul>
&lt;li>Controller Manager 和 Scheduler 在启动时会通过 Informer 机制 watch 所需的资源对象,如 Pod、Node 等[1][3]&lt;/li>
&lt;li>Informer 内部使用 Reflector 定期从 API Server 拉取资源列表,并监听资源变化事件&lt;/li>
&lt;li>当资源发生变化时,Reflector 会将事件推送到 DeltaFIFO 队列,Informer 再从队列中取出事件并通知 Controller Manager 和 Scheduler[3]&lt;/li>
&lt;/ul>
&lt;h4 id="长轮询-watch-机制">长轮询 Watch 机制&lt;a class="td-heading-self-link" href="#%e9%95%bf%e8%bd%ae%e8%af%a2-watch-%e6%9c%ba%e5%88%b6" aria-label="Heading self-link">&lt;/a>&lt;/h4>
&lt;ul>
&lt;li>Informer 在初始化时,Reflector 会先 List 从 API Server 获取所有资源对象[3]&lt;/li>
&lt;li>Reflector 将获取到的资源对象存储在本地缓存中&lt;/li>
&lt;li>Reflector 开始 Watch 监听资源变化事件,与 API Server 建立长连接&lt;/li>
&lt;li>当资源发生变化时,API Server 会将事件推送给 Reflector,Reflector 再将事件推送到 DeltaFIFO 队列[3]&lt;/li>
&lt;/ul>
&lt;p>总之,Controller Manager 和 Scheduler 通过 Informer 机制 watch 所需的资源对象,Informer 内部使用 Reflector 定期从 API Server 拉取资源列表,并建立长连接监听资源变化事件。当资源发生变化时,API Server 会将事件推送给 Reflector,Reflector 再将事件推送到 DeltaFIFO 队列,最终通知 Controller Manager 和 Scheduler 进行处理。这种机制确保了 Controller Manager 和 Scheduler 能够及时感知资源的变化,并作出相应的调整。&lt;/p>
&lt;p>Citations:
[1] &lt;a href="https://kubernetes.io/docs/concepts/scheduling-eviction/kube-scheduler/">https://kubernetes.io/docs/concepts/scheduling-eviction/kube-scheduler/&lt;/a>
[2] &lt;a href="https://github.com/kubernetes/kubernetes/issues/108556">https://github.com/kubernetes/kubernetes/issues/108556&lt;/a>
[3] &lt;a href="https://mutoulazy.github.io/2020/04/14/kubernetes/framework/kubernetes-base-framework/">https://mutoulazy.github.io/2020/04/14/kubernetes/framework/kubernetes-base-framework/&lt;/a>
[4] &lt;a href="https://www.stackstate.com/blog/kubernetes-architecture-part-2-control-plane-components/">https://www.stackstate.com/blog/kubernetes-architecture-part-2-control-plane-components/&lt;/a>
[5] &lt;a href="https://www.jorgeacetozi.com/single-post/kubernetes-master-components-etcd-api-server-controller-manager-and-scheduler">https://www.jorgeacetozi.com/single-post/kubernetes-master-components-etcd-api-server-controller-manager-and-scheduler&lt;/a>
[6] &lt;a href="https://konghq.com/blog/learning-center/kubernetes-controllers-vs-operators">https://konghq.com/blog/learning-center/kubernetes-controllers-vs-operators&lt;/a>
[7] &lt;a href="https://www.cnblogs.com/peteremperor/p/18066595">https://www.cnblogs.com/peteremperor/p/18066595&lt;/a>
[8] &lt;a href="https://sysdig.com/blog/how-to-monitor-kube-controller-manager/">https://sysdig.com/blog/how-to-monitor-kube-controller-manager/&lt;/a>&lt;/p></description></item><item><title>Docs: Watch and Informer</title><link>https://desistdaydream.github.io/docs/10.%E4%BA%91%E5%8E%9F%E7%94%9F/Kubernetes/Kubernetes-%E6%9C%BA%E5%88%B6%E4%B8%8E%E7%89%B9%E6%80%A7/Watch-and-Informer/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/10.%E4%BA%91%E5%8E%9F%E7%94%9F/Kubernetes/Kubernetes-%E6%9C%BA%E5%88%B6%E4%B8%8E%E7%89%B9%E6%80%A7/Watch-and-Informer/</guid><description>
&lt;h1 id="概述">概述&lt;a class="td-heading-self-link" href="#%e6%a6%82%e8%bf%b0" aria-label="Heading self-link">&lt;/a>&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://kubernetes.io/docs/reference/using-api/api-concepts/#efficient-detection-of-changes">官方文档, 参考 - API 概述 - Kubernetes API 概念, 高效监测变化&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://xuliangtang.github.io/posts/k8s-list-watch/#list-watch-%E6%9C%BA%E5%88%B6">K8s list-watch 机制和 Informer 模块&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>&lt;strong>Reflector&lt;/strong>&lt;/p>
&lt;p>在 Kubernetes 中，有5个主要的组件，分别是 master 节点上的 kube-api-server、kube-controller-manager 和 kube-scheduler，node 节点上的 kubelet 和kube-proxy 。这其中 kube-apiserver 是对外和对内提供资源的声明式 API 的组件，其它4个组件都需要和它交互。为了保证消息的实时性，有两种方式：&lt;/p>
&lt;ul>
&lt;li>客户端组件 (kubelet, scheduler, controller-manager 等) 轮询 apiserver&lt;/li>
&lt;li>apiserver 通知客户端&lt;/li>
&lt;/ul>
&lt;p>为了降低 kube-apiserver 的压力，有一个非常关键的机制就是 list-watch。list-watch 本质上也是 client 端监听 k8s 资源变化并作出相应处理的生产者消费者框架&lt;/p>
&lt;p>list-watach 机制需要满足以下需求：&lt;/p>
&lt;ol>
&lt;li>实时性 (即数据变化时，相关组件越快感知越好)&lt;/li>
&lt;li>保证消息的顺序性 (即消息要按发生先后顺序送达目的组件。很难想象在Pod创建消息前收到该Pod删除消息时组件应该怎么处理)&lt;/li>
&lt;li>保证消息不丢失或者有可靠的重新获取机制 (比如 kubelet 和 kube-apiserver 间网络闪断，需要保证网络恢复后kubelet可以收到网络闪断期间产生的消息)&lt;/li>
&lt;/ol>
&lt;h2 id="list-watch-机制">list-watch 机制&lt;a class="td-heading-self-link" href="#list-watch-%e6%9c%ba%e5%88%b6" aria-label="Heading self-link">&lt;/a>&lt;/h2>
&lt;p>list-watch 由两部分组成，分别是 list 和 watch。list 非常好理解，就是调用资源的 list API 罗列资源 ，基于 HTTP 短链接实现，watch 则是调用资源的 watch API 监听资源变更事件，基于 HTTP 长链接实现&lt;/p>
&lt;p>etcd 存储集群的数据信息，apiserver 作为统一入口，任何对数据的操作都必须经过 apiserver。客户端通过 list-watch 监听 apiserver 中资源的 create, update 和 delete 事件，并针对事件类型调用相应的事件处理函数&lt;/p>
&lt;h2 id="informer-机制">informer 机制&lt;a class="td-heading-self-link" href="#informer-%e6%9c%ba%e5%88%b6" aria-label="Heading self-link">&lt;/a>&lt;/h2>
&lt;p>k8s 的 informer 模块封装 list-watch API，用户只需要指定资源，编写事件处理函数，AddFunc, UpdateFunc 和 DeleteFunc 等。如下图所示，informer 首先通过 list API 罗列资源，然后调用 watch API 监听资源的变更事件，并将结果放入到一个 FIFO 队列，队列的另一头有协程从中取出事件，并调用对应的注册函数处理事件。Informer 还维护了一个只读的 Map Store 缓存，主要为了提升查询的效率，降低 apiserver 的负载&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/xuliangTang/picbeds/main/picgo/202212181902721.png" alt="">&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/xuliangTang/picbeds/main/picgo/202212181854816.jpeg" alt="">&lt;/p>
&lt;p>Reflector 从 API Server 中通过 List&amp;amp;Watch 得到资源的状态变化，把数据塞到 Delta Fifo 队列里（Reflector 相当于生产者），由 Informer 进行消费。更新时在回调里可以获得新值和旧值，旧值从 Indexer（store） 中获取&lt;/p>
&lt;ul>
&lt;li>FIFO ：先入先出队列，拥有队列基本方法（ADD，UPDATE，DELETE，LIST，POP，CLOSE 等）&lt;/li>
&lt;li>Delta ： 存储对象的行为（变化）类型（Added，Updated，Deleted，Sync 等）&lt;/li>
&lt;/ul>
&lt;p>如果要对一个资源支持多种监听方式，需要使用到 &lt;strong>SharedInformer&lt;/strong>（SharedIndexInformer）&lt;/p>
&lt;ul>
&lt;li>支持多个EventHandler . 可以认为是支持多个消费者，多个消费者之间共享 Indexer， Reflector 统一下发数据统一处理&lt;/li>
&lt;li>内置一个 Indexer（有一个叫做 threadSafeMap 的 struct 来实现 cache/thread_safe_store.go）&lt;/li>
&lt;/ul>
&lt;p>里面有个属性 sharedProcessor，用于协调和管理若干个处理器对象 processorListener（这是真正干活的对象）&lt;/p>
&lt;ul>
&lt;li>run()：阻塞运行&lt;/li>
&lt;li>pop()：好比不断从队列里取数据，完成对应的回调操作&lt;/li>
&lt;li>addCh：一个 channel，外部向它插入数据&lt;/li>
&lt;/ul>
&lt;p>好比 Reflector 向 deltaFifo 插入数据后，后分发给 ProcessListener，由 ProcessListener 执行具体的回调。Processor 里面可以放若干个 Listener，因此可以使用多个回调&lt;/p>
&lt;p>如果要对多个资源支持多种监听方式，需要使用到 &lt;strong>SharedInformerFactory&lt;/strong>，里面有个属性 informers 包含多个 SharedIndexInformer 对象&lt;/p>
&lt;p>client-go 使用 k8s.io/client-go/tools/cache 包里的 informer 对象进行 list-watch 机制的封装&lt;/p>
&lt;p>最粗暴的解释：&lt;/p>
&lt;ol>
&lt;li>初始化时，调 List API 获得全量 list，缓存起来(本地缓存)，这样就不需要每次请求都去请求 ApiServer&lt;/li>
&lt;li>调用 Watch API 去 watch 资源，发生变更后会通过一定机制维护缓存&lt;/li>
&lt;/ol></description></item><item><title>Docs: Leader Election(领导人选举)</title><link>https://desistdaydream.github.io/docs/10.%E4%BA%91%E5%8E%9F%E7%94%9F/Kubernetes/Kubernetes-%E6%9C%BA%E5%88%B6%E4%B8%8E%E7%89%B9%E6%80%A7/Leader-Election%E9%A2%86%E5%AF%BC%E4%BA%BA%E9%80%89%E4%B8%BE/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/10.%E4%BA%91%E5%8E%9F%E7%94%9F/Kubernetes/Kubernetes-%E6%9C%BA%E5%88%B6%E4%B8%8E%E7%89%B9%E6%80%A7/Leader-Election%E9%A2%86%E5%AF%BC%E4%BA%BA%E9%80%89%E4%B8%BE/</guid><description>
&lt;h1 id="概述">概述&lt;a class="td-heading-self-link" href="#%e6%a6%82%e8%bf%b0" aria-label="Heading self-link">&lt;/a>&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://kubernetes.io/blog/2016/01/simple-leader-election-with-kubernetes/">官方博客, Kubernetes 的简单领导人选举&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://zhengyinyong.com/post/kubernetes-pod-leader-election/">zhengyinyong&lt;/a>&lt;/li>
&lt;li>用法：
&lt;ul>
&lt;li>&lt;a href="https://mp.weixin.qq.com/s/LnF9ZIoi-sCUV9rxxEvDvQ">公众号-云原生实验室，巧用 Kubernetes 中的 Leader 选举机制来实现自己的 HA 应用&lt;/a>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;h2 id="为什么需要-pod-之间的-leader-election">为什么需要 Pod 之间的 Leader Election&lt;a class="td-heading-self-link" href="#%e4%b8%ba%e4%bb%80%e4%b9%88%e9%9c%80%e8%a6%81-pod-%e4%b9%8b%e9%97%b4%e7%9a%84-leader-election" aria-label="Heading self-link">&lt;/a>&lt;/h2>
&lt;p>一般来说，由 Deployment 创建的 1 个或多个 Pod 都是对等关系，彼此之间提供一样的服务。但是在某些场合，多个 Pod 之间需要有一个 Leader 的角色，即：&lt;/p>
&lt;ul>
&lt;li>&lt;strong>Pod 之间有且只有一个 Leader&lt;/strong>；&lt;/li>
&lt;li>&lt;strong>Leader 在一定周期不可用时，其他 Pod 会再选出一个 Leader&lt;/strong>；&lt;/li>
&lt;li>&lt;strong>由处于 Leader 身份的 Pod 来完成某些特殊的业务逻辑（通常是写操作）&lt;/strong>；&lt;/li>
&lt;/ul>
&lt;p>比如，当&lt;strong>多个 Pod 之间只需要一个写者&lt;/strong>时，如果不采用 Leader Election，那么就必须在 Pod 启动之初人为地配置一个 Leader。如果配置的 Leader 在后续的服务中失效且没有对应机制来生成新的 Leader，那么对应 Pod 服务就可能处于不可用状态，违背高可用原则。&lt;/p>
&lt;p>典型地，Kubernetes 的核心组件 kube-controller-manager 和 scheduler 就需要一个需要 Leader 的场景。当 kube-controller-manager 的启动参数设置 &lt;code>--leader-elect=true&lt;/code> 时，对应节点的 kube-controller-manager 在启动时会执行选主操作。当选出一个 Leader 之后，由 Leader 来启动所有的控制器。如果 Leader Pod 不可用，将会自动选出新的 Leader Pod，从而保障控制器仍处于运行状态。&lt;/p>
&lt;h2 id="一个简单的-leader-election-的例子">一个简单的 Leader Election 的例子&lt;a class="td-heading-self-link" href="#%e4%b8%80%e4%b8%aa%e7%ae%80%e5%8d%95%e7%9a%84-leader-election-%e7%9a%84%e4%be%8b%e5%ad%90" aria-label="Heading self-link">&lt;/a>&lt;/h2>
&lt;p>&lt;strong>备注&lt;/strong>：该例子取自项目&lt;a href="https://github.com/kubernetes/contrib/tree/master/election">文档&lt;/a>&lt;/p>
&lt;h3 id="启动一个-leader-elector-的-pod">启动一个 leader-elector 的 Pod&lt;a class="td-heading-self-link" href="#%e5%90%af%e5%8a%a8%e4%b8%80%e4%b8%aa-leader-elector-%e7%9a%84-pod" aria-label="Heading self-link">&lt;/a>&lt;/h3>
&lt;ul>
&lt;li>&lt;strong>创建一个&lt;/strong>&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>$ kubectl run leader-elector &lt;span style="color:#4e9a06">\
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#4e9a06">&lt;/span> --image&lt;span style="color:#ce5c00;font-weight:bold">=&lt;/span>k8s.gcr.io/leader-elector:0.5 &lt;span style="color:#4e9a06">\
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#4e9a06">&lt;/span> --replicas&lt;span style="color:#ce5c00;font-weight:bold">=&lt;/span>&lt;span style="color:#0000cf;font-weight:bold">3&lt;/span> &lt;span style="color:#4e9a06">\
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#4e9a06">&lt;/span> -- &lt;span style="color:#4e9a06">\
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#4e9a06">&lt;/span> --election&lt;span style="color:#ce5c00;font-weight:bold">=&lt;/span>example &lt;span style="color:#4e9a06">\
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#4e9a06">&lt;/span> --http&lt;span style="color:#ce5c00;font-weight:bold">=&lt;/span>0.0.0.0:4040
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ul>
&lt;li>副本数为 3，即将生成 3 个 Pod，如果运行成功，可观察到：&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>$ kubectl get po
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> NAME READY STATUS RESTARTS AGE
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> leader-elector-68dcb58d55-7dhdz 1/1 Running &lt;span style="color:#0000cf;font-weight:bold">0&lt;/span> 2m36s
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> leader-elector-68dcb58d55-g5zp8 1/1 Running &lt;span style="color:#0000cf;font-weight:bold">0&lt;/span> 2m36s
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> leader-elector-68dcb58d55-q45pd 1/1 Running &lt;span style="color:#0000cf;font-weight:bold">0&lt;/span> 2m36s
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ul>
&lt;li>&lt;strong>查看哪个 Pod 成为 Leader&lt;/strong>；&lt;/li>
&lt;/ul>
&lt;p>可以逐个查看 Pod 的日志：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>kubectl logs -f &lt;span style="color:#4e9a06">${&lt;/span>&lt;span style="color:#000">pod_name&lt;/span>&lt;span style="color:#4e9a06">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>如果是 Leader 的话，将会有如下的日志：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>$ kubectl logs leader-elector-68dcb58d55-g5zp8
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> leader-elector-9577494c7-l64lp is the leader
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> I0122 03:24:31.779331 &lt;span style="color:#0000cf;font-weight:bold">8&lt;/span> leaderelection.go:296&lt;span style="color:#ce5c00;font-weight:bold">]&lt;/span> lock is held by leader-elector-9577494c7-l64lp and has not yet expired
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> I0122 03:24:36.101800 &lt;span style="color:#0000cf;font-weight:bold">8&lt;/span> leaderelection.go:296&lt;span style="color:#ce5c00;font-weight:bold">]&lt;/span> lock is held by leader-elector-9577494c7-l64lp and has not yet expired
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> I0122 03:24:41.426387 &lt;span style="color:#0000cf;font-weight:bold">8&lt;/span> leaderelection.go:296&lt;span style="color:#ce5c00;font-weight:bold">]&lt;/span> lock is held by leader-elector-9577494c7-l64lp and has not yet expired
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> I0122 03:24:45.947321 &lt;span style="color:#0000cf;font-weight:bold">8&lt;/span> leaderelection.go:215&lt;span style="color:#ce5c00;font-weight:bold">]&lt;/span> sucessfully acquired lease default/example
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>leader-elector-68dcb58d55-g5zp8 is the leader
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>更通用的方式是查看资源锁的身份标识信息：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>kubectl get ep example -o yaml
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>通过查看 annotations 中的 &lt;code>control-plane.alpha.kubernetes.io/leader&lt;/code> 字段来获得 Leader 的信息；&lt;/p>
&lt;ul>
&lt;li>&lt;strong>使用&lt;/strong> &lt;code>leader-elector&lt;/code> 实现了一个简单的 HTTP 接口（&lt;code>:4040&lt;/code>）来查看当前 Leader：&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>curl http://localhost:8001/api/v1/namespaces/default/pods/leader-elector-5d77ccc44d-gwsgg:4040/proxy/
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ce5c00;font-weight:bold">{&lt;/span>&lt;span style="color:#4e9a06">&amp;#34;name&amp;#34;&lt;/span>:&lt;span style="color:#4e9a06">&amp;#34;leader-elector-5d77ccc44d-7tmgm&amp;#34;&lt;/span>&lt;span style="color:#ce5c00;font-weight:bold">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h1 id="如何使用-leader-elector">如何使用 leader-elector&lt;a class="td-heading-self-link" href="#%e5%a6%82%e4%bd%95%e4%bd%bf%e7%94%a8-leader-elector" aria-label="Heading self-link">&lt;/a>&lt;/h1>
&lt;p>如果自己的项目中需要用到 Leader Election 的逻辑，可以有两种方式：&lt;/p>
&lt;h2 id="将调用-leaderelection-库的逻辑内嵌到自己项目中">将调用 &lt;code>leaderelection&lt;/code> 库的逻辑内嵌到自己项目中&lt;a class="td-heading-self-link" href="#%e5%b0%86%e8%b0%83%e7%94%a8-leaderelection-%e5%ba%93%e7%9a%84%e9%80%bb%e8%be%91%e5%86%85%e5%b5%8c%e5%88%b0%e8%87%aa%e5%b7%b1%e9%a1%b9%e7%9b%ae%e4%b8%ad" aria-label="Heading self-link">&lt;/a>&lt;/h2>
&lt;p>Leader Election 库在 &lt;a href="https://github.com/kubernetes/client-go/tree/master/tools/leaderelection">https://github.com/kubernetes/client-go/tree/master/tools/leaderelection&lt;/a>&lt;/p>
&lt;h2 id="使用-sidecar-的方式">使用 Sidecar 的方式&lt;a class="td-heading-self-link" href="#%e4%bd%bf%e7%94%a8-sidecar-%e7%9a%84%e6%96%b9%e5%bc%8f" aria-label="Heading self-link">&lt;/a>&lt;/h2>
&lt;h1 id="leader-election-的实现">Leader Election 的实现&lt;a class="td-heading-self-link" href="#leader-election-%e7%9a%84%e5%ae%9e%e7%8e%b0" aria-label="Heading self-link">&lt;/a>&lt;/h1>
&lt;p>Leader Election 的过程本质上就是一个&lt;strong>竞争分布式锁&lt;/strong>的过程。在 Kubernetes 中，这个分布式锁是通过下面几个 **Resource(资源)**实现的：&lt;/p>
&lt;ul>
&lt;li>&lt;strong>Endpoints&lt;/strong> #&lt;/li>
&lt;li>&lt;strong>ConfigMaps&lt;/strong> #&lt;/li>
&lt;li>&lt;strong>Leases&lt;/strong> # 详见 [集群资源-Lease](/docs/10.云原生/2.3.Kubernetes%20 容器编排系统/1.API、Resource(资源)、Object(对象)/API%20 参考/集群资源.md 参考/集群资源.md)&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>谁先创建了某种资源，谁就获得锁&lt;/strong>。通常情况下，kube-scheduler 和 kube-controller-manager 使用 leases 资源来实现领导者选举。&lt;/p>
&lt;p>按照我们以往的惯例，带着问题去看源码。有这么几个问题：&lt;/p>
&lt;ul>
&lt;li>&lt;strong>Leader Election 如何竞选&lt;/strong> ？&lt;/li>
&lt;li>&lt;strong>Leader 不可用之后如何竞选新的 Leader&lt;/strong> ？&lt;/li>
&lt;/ul>
&lt;p>不同于 Raft 算法的一致性算法的 Leader 竞选，Pod 之间的 Leader Election 是&lt;strong>无状态&lt;/strong>的，也就是说&lt;strong>现在的 Leader 无需同步上一个 Leader 的数据信息，这就把竞选的过程变得非常简单：先到先得&lt;/strong>。说白了，就是谁先创建了这个资源，谁就是领导者了。&lt;/p>
&lt;p>这部分代码在 &lt;code>kubernetes/staging/src/k8s.io/client-go/tools/leaderelection&lt;/code> 中，取 1.9.2 版本来分析。&lt;/p>
&lt;h3 id="资源锁的实现">资源锁的实现&lt;a class="td-heading-self-link" href="#%e8%b5%84%e6%ba%90%e9%94%81%e7%9a%84%e5%ae%9e%e7%8e%b0" aria-label="Heading self-link">&lt;/a>&lt;/h3>
&lt;p>Kubernetes 实现了两种资源锁（resourcelock）：Endpoint 和 ConfigMap。&lt;strong>如果是基于 Endpoint 的资源锁，获取到锁的 Pod 将会在对应 Namespace 下创建对应的 Endpoint 对象，并在其 Annotations 上记录 Pod 的信息&lt;/strong>。&lt;/p>
&lt;p>比如 kube-controller-manager：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>$ kubectl get ep -n kube-system &lt;span style="color:#000;font-weight:bold">|&lt;/span> grep kube-controller-manager
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>kube-controller-manager &amp;lt;none&amp;gt; 41d
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>$ kubectl describe ep kube-controller-manager -n kube-system
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Name: kube-controller-manager
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Namespace: kube-system
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Labels: &amp;lt;none&amp;gt;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Annotations: control-plane.alpha.kubernetes.io/leader:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ce5c00;font-weight:bold">{&lt;/span>&lt;span style="color:#4e9a06">&amp;#34;holderIdentity&amp;#34;&lt;/span>:&lt;span style="color:#4e9a06">&amp;#34;szdc-k8sm-0-5&amp;#34;&lt;/span>,&lt;span style="color:#4e9a06">&amp;#34;leaseDurationSeconds&amp;#34;&lt;/span>:15,&lt;span style="color:#4e9a06">&amp;#34;acquireTime&amp;#34;&lt;/span>:&lt;span style="color:#4e9a06">&amp;#34;2018-12-11T0...
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#4e9a06">Subsets:
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#4e9a06">Events: &amp;lt;none&amp;gt;
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>发现在 kube-system 中创建了同名的 Endpoint（kube-controller-manager），并在 Annotations 中以设置了 key 为 &lt;code>control-plane.alpha.kubernetes.io/leader&lt;/code>，value 为对应 Leader 信息的 JSON 数据。同理，如果采用 ConfigMap 作为资源锁也是类似的实现模式。&lt;/p>
&lt;p>resourcelock 是以 interface 的形式对外暴露，在创建过程（&lt;code>New()&lt;/code>）通过相应的参数来控制具体实例化的过程：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8f5902;font-style:italic">// leaderelection/resourcelock/interface.go
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8f5902;font-style:italic">&lt;/span>&lt;span style="color:#204a87;font-weight:bold">type&lt;/span> &lt;span style="color:#000">Interface&lt;/span> &lt;span style="color:#204a87;font-weight:bold">interface&lt;/span> &lt;span style="color:#000;font-weight:bold">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#8f5902;font-style:italic">// Get returns the LeaderElectionRecord
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8f5902;font-style:italic">&lt;/span> &lt;span style="color:#000">Get&lt;/span>&lt;span style="color:#000;font-weight:bold">()&lt;/span> &lt;span style="color:#000;font-weight:bold">(&lt;/span>&lt;span style="color:#ce5c00;font-weight:bold">*&lt;/span>&lt;span style="color:#000">LeaderElectionRecord&lt;/span>&lt;span style="color:#000;font-weight:bold">,&lt;/span> &lt;span style="color:#204a87;font-weight:bold">error&lt;/span>&lt;span style="color:#000;font-weight:bold">)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#8f5902;font-style:italic">// Create attempts to create a LeaderElectionRecord
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8f5902;font-style:italic">&lt;/span> &lt;span style="color:#000">Create&lt;/span>&lt;span style="color:#000;font-weight:bold">(&lt;/span>&lt;span style="color:#000">ler&lt;/span> &lt;span style="color:#000">LeaderElectionRecord&lt;/span>&lt;span style="color:#000;font-weight:bold">)&lt;/span> &lt;span style="color:#204a87;font-weight:bold">error&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#8f5902;font-style:italic">// Update will update and existing LeaderElectionRecord
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8f5902;font-style:italic">&lt;/span> &lt;span style="color:#000">Update&lt;/span>&lt;span style="color:#000;font-weight:bold">(&lt;/span>&lt;span style="color:#000">ler&lt;/span> &lt;span style="color:#000">LeaderElectionRecord&lt;/span>&lt;span style="color:#000;font-weight:bold">)&lt;/span> &lt;span style="color:#204a87;font-weight:bold">error&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#8f5902;font-style:italic">// RecordEvent is used to record events
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8f5902;font-style:italic">&lt;/span> &lt;span style="color:#000">RecordEvent&lt;/span>&lt;span style="color:#000;font-weight:bold">(&lt;/span>&lt;span style="color:#204a87;font-weight:bold">string&lt;/span>&lt;span style="color:#000;font-weight:bold">)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#8f5902;font-style:italic">// Identity will return the locks Identity
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8f5902;font-style:italic">&lt;/span> &lt;span style="color:#000">Identity&lt;/span>&lt;span style="color:#000;font-weight:bold">()&lt;/span> &lt;span style="color:#204a87;font-weight:bold">string&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#8f5902;font-style:italic">// Describe is used to convert details on current resource lock
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8f5902;font-style:italic">&lt;/span> &lt;span style="color:#8f5902;font-style:italic">// into a string
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8f5902;font-style:italic">&lt;/span> &lt;span style="color:#000">Describe&lt;/span>&lt;span style="color:#000;font-weight:bold">()&lt;/span> &lt;span style="color:#204a87;font-weight:bold">string&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#000;font-weight:bold">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>其中 &lt;code>Get()&lt;/code>、&lt;code>Create()&lt;/code> 和 &lt;code>Update()&lt;/code> 本质上就是对 &lt;code>LeaderElectionRecord&lt;/code> 的读写操作。&lt;code>LeaderElectionRecord&lt;/code> 定义如下：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#204a87;font-weight:bold">type&lt;/span> &lt;span style="color:#000">LeaderElectionRecord&lt;/span> &lt;span style="color:#204a87;font-weight:bold">struct&lt;/span> &lt;span style="color:#000;font-weight:bold">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#8f5902;font-style:italic">// 标示当前资源锁的所有权的信息
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8f5902;font-style:italic">&lt;/span> &lt;span style="color:#000">HolderIdentity&lt;/span> &lt;span style="color:#204a87;font-weight:bold">string&lt;/span> &lt;span style="color:#4e9a06">`json:&amp;#34;holderIdentity&amp;#34;`&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#8f5902;font-style:italic">// 资源锁租约时间是多长
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8f5902;font-style:italic">&lt;/span> &lt;span style="color:#000">LeaseDurationSeconds&lt;/span> &lt;span style="color:#204a87;font-weight:bold">int&lt;/span> &lt;span style="color:#4e9a06">`json:&amp;#34;leaseDurationSeconds&amp;#34;`&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#8f5902;font-style:italic">// 锁获得的时间
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8f5902;font-style:italic">&lt;/span> &lt;span style="color:#000">AcquireTime&lt;/span> &lt;span style="color:#000">metav1&lt;/span>&lt;span style="color:#000;font-weight:bold">.&lt;/span>&lt;span style="color:#000">Time&lt;/span> &lt;span style="color:#4e9a06">`json:&amp;#34;acquireTime&amp;#34;`&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#8f5902;font-style:italic">// 续租的时间
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8f5902;font-style:italic">&lt;/span> &lt;span style="color:#000">RenewTime&lt;/span> &lt;span style="color:#000">metav1&lt;/span>&lt;span style="color:#000;font-weight:bold">.&lt;/span>&lt;span style="color:#000">Time&lt;/span> &lt;span style="color:#4e9a06">`json:&amp;#34;renewTime&amp;#34;`&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#8f5902;font-style:italic">// Leader 进行切换的次数
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8f5902;font-style:italic">&lt;/span> &lt;span style="color:#000">LeaderTransitions&lt;/span> &lt;span style="color:#204a87;font-weight:bold">int&lt;/span> &lt;span style="color:#4e9a06">`json:&amp;#34;leaderTransitions&amp;#34;`&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#000;font-weight:bold">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>理论上，&lt;code>LeaderElectionRecord&lt;/code> 是保存在资源锁的 Annotations 中，可以是任意的字符串，此处是将 JSON 序列化为字符串来进行存储。
在 &lt;code>leaderelection/resourcelock/configmaplock.go&lt;/code> 和 &lt;code>leaderelection/resourcelock/endpointslock.go&lt;/code> 分别是基于 Endpoint 和 ConfigMap 对上面接口的实现。拿 &lt;code>endpointslock.go&lt;/code> 来看，对这几个接口的实现实际上就是对 Endpoint 资源中 Annotations 的增删查改罢了，比较简单，就不详细展开。&lt;/p>
&lt;h3 id="竞争锁的过程">竞争锁的过程&lt;a class="td-heading-self-link" href="#%e7%ab%9e%e4%ba%89%e9%94%81%e7%9a%84%e8%bf%87%e7%a8%8b" aria-label="Heading self-link">&lt;/a>&lt;/h3>
&lt;p>完整的 Leader Election 过程在 &lt;code>leaderelection/leaderelection.go&lt;/code> 中。
整个过程可以简单描述为：&lt;/p>
&lt;ol>
&lt;li>&lt;strong>每个 Pod 在启动的时候都会创建&lt;/strong>；&lt;/li>
&lt;li>&lt;strong>在循环中，Pod 会定期（&lt;/strong>；&lt;/li>
&lt;li>&lt;strong>在循环周期中，Leader 会不断 Update 资源锁的对应时间信息，从节点则会不断检查资源锁是否过期，如果过期则尝试更新资源，标记资源所有权。这样一来，一旦 Leader 不可用，则对应的资源锁将得不到更新，过期之后其他从节点会再次创建新的资源锁成为 Leader&lt;/strong>；&lt;/li>
&lt;/ol>
&lt;p>其中，&lt;code>LeaderElector.Run()&lt;/code> 的源码为：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#204a87;font-weight:bold">func&lt;/span> &lt;span style="color:#000;font-weight:bold">(&lt;/span>&lt;span style="color:#000">le&lt;/span> &lt;span style="color:#ce5c00;font-weight:bold">*&lt;/span>&lt;span style="color:#000">LeaderElector&lt;/span>&lt;span style="color:#000;font-weight:bold">)&lt;/span> &lt;span style="color:#000">Run&lt;/span>&lt;span style="color:#000;font-weight:bold">()&lt;/span> &lt;span style="color:#000;font-weight:bold">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ce5c00;font-weight:bold">...&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#8f5902;font-style:italic">// 尝试创建锁
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8f5902;font-style:italic">&lt;/span> &lt;span style="color:#000">le&lt;/span>&lt;span style="color:#000;font-weight:bold">.&lt;/span>&lt;span style="color:#000">acquire&lt;/span>&lt;span style="color:#000;font-weight:bold">()&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#8f5902;font-style:italic">// Leader 更新资源锁的租约
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8f5902;font-style:italic">&lt;/span> &lt;span style="color:#000">le&lt;/span>&lt;span style="color:#000;font-weight:bold">.&lt;/span>&lt;span style="color:#000">renew&lt;/span>&lt;span style="color:#000;font-weight:bold">()&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ce5c00;font-weight:bold">...&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#000;font-weight:bold">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;code>acquire()&lt;/code> 会周期性地创建锁或探查锁有没有过期：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#204a87;font-weight:bold">func&lt;/span> &lt;span style="color:#000;font-weight:bold">(&lt;/span>&lt;span style="color:#000">le&lt;/span> &lt;span style="color:#ce5c00;font-weight:bold">*&lt;/span>&lt;span style="color:#000">LeaderElector&lt;/span>&lt;span style="color:#000;font-weight:bold">)&lt;/span> &lt;span style="color:#000">acquire&lt;/span>&lt;span style="color:#000;font-weight:bold">()&lt;/span> &lt;span style="color:#000;font-weight:bold">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ce5c00;font-weight:bold">...&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#000">wait&lt;/span>&lt;span style="color:#000;font-weight:bold">.&lt;/span>&lt;span style="color:#000">JitterUntil&lt;/span>&lt;span style="color:#000;font-weight:bold">(&lt;/span>&lt;span style="color:#204a87;font-weight:bold">func&lt;/span>&lt;span style="color:#000;font-weight:bold">()&lt;/span> &lt;span style="color:#000;font-weight:bold">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#8f5902;font-style:italic">// 尝试创建或者续约资源锁
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8f5902;font-style:italic">&lt;/span> &lt;span style="color:#000">succeeded&lt;/span> &lt;span style="color:#ce5c00;font-weight:bold">:=&lt;/span> &lt;span style="color:#000">le&lt;/span>&lt;span style="color:#000;font-weight:bold">.&lt;/span>&lt;span style="color:#000">tryAcquireOrRenew&lt;/span>&lt;span style="color:#000;font-weight:bold">()&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#8f5902;font-style:italic">// leader 可能发生了改变，执行相应的 OnNewLeader() 回调函数
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8f5902;font-style:italic">&lt;/span> &lt;span style="color:#000">le&lt;/span>&lt;span style="color:#000;font-weight:bold">.&lt;/span>&lt;span style="color:#000">maybeReportTransition&lt;/span>&lt;span style="color:#000;font-weight:bold">()&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#8f5902;font-style:italic">// 不成功说明创建资源失败，当前 Leader 是其他 Pod
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8f5902;font-style:italic">&lt;/span> &lt;span style="color:#204a87;font-weight:bold">if&lt;/span> &lt;span style="color:#000;font-weight:bold">!&lt;/span>&lt;span style="color:#000">succeeded&lt;/span> &lt;span style="color:#000;font-weight:bold">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ce5c00;font-weight:bold">...&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#204a87;font-weight:bold">return&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#000;font-weight:bold">}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ce5c00;font-weight:bold">...&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#000;font-weight:bold">},&lt;/span> &lt;span style="color:#000">le&lt;/span>&lt;span style="color:#000;font-weight:bold">.&lt;/span>&lt;span style="color:#000">config&lt;/span>&lt;span style="color:#000;font-weight:bold">.&lt;/span>&lt;span style="color:#000">RetryPeriod&lt;/span>&lt;span style="color:#000;font-weight:bold">,&lt;/span> &lt;span style="color:#000">JitterFactor&lt;/span>&lt;span style="color:#000;font-weight:bold">,&lt;/span> &lt;span style="color:#204a87;font-weight:bold">true&lt;/span>&lt;span style="color:#000;font-weight:bold">,&lt;/span> &lt;span style="color:#000">stop&lt;/span>&lt;span style="color:#000;font-weight:bold">)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#000;font-weight:bold">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>执行的周期为 &lt;code>RetryPeriod&lt;/code>。&lt;/p>
&lt;p>我们重点关注 &lt;code>tryAcquireOrRenew()&lt;/code> 的逻辑：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#204a87;font-weight:bold">func&lt;/span> &lt;span style="color:#000;font-weight:bold">(&lt;/span>&lt;span style="color:#000">le&lt;/span> &lt;span style="color:#ce5c00;font-weight:bold">*&lt;/span>&lt;span style="color:#000">leaderElector&lt;/span>&lt;span style="color:#000;font-weight:bold">)&lt;/span> &lt;span style="color:#000">tryAcquireOrRenew&lt;/span>&lt;span style="color:#000;font-weight:bold">()&lt;/span> &lt;span style="color:#204a87;font-weight:bold">bool&lt;/span> &lt;span style="color:#000;font-weight:bold">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#000">now&lt;/span> &lt;span style="color:#ce5c00;font-weight:bold">:=&lt;/span> &lt;span style="color:#000">metav1&lt;/span>&lt;span style="color:#000;font-weight:bold">.&lt;/span>&lt;span style="color:#000">Now&lt;/span>&lt;span style="color:#000;font-weight:bold">()&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#000">leaderElectionRecord&lt;/span> &lt;span style="color:#ce5c00;font-weight:bold">:=&lt;/span> &lt;span style="color:#000">rl&lt;/span>&lt;span style="color:#000;font-weight:bold">.&lt;/span>&lt;span style="color:#000">LeaderElectionRecord&lt;/span>&lt;span style="color:#000;font-weight:bold">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#000">HolderIdentity&lt;/span>&lt;span style="color:#000;font-weight:bold">:&lt;/span> &lt;span style="color:#000">le&lt;/span>&lt;span style="color:#000;font-weight:bold">.&lt;/span>&lt;span style="color:#000">config&lt;/span>&lt;span style="color:#000;font-weight:bold">.&lt;/span>&lt;span style="color:#000">Lock&lt;/span>&lt;span style="color:#000;font-weight:bold">.&lt;/span>&lt;span style="color:#000">Identity&lt;/span>&lt;span style="color:#000;font-weight:bold">(),&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#000">LeaseDurationSeconds&lt;/span>&lt;span style="color:#000;font-weight:bold">:&lt;/span> &lt;span style="color:#204a87">int&lt;/span>&lt;span style="color:#000;font-weight:bold">(&lt;/span>&lt;span style="color:#000">le&lt;/span>&lt;span style="color:#000;font-weight:bold">.&lt;/span>&lt;span style="color:#000">config&lt;/span>&lt;span style="color:#000;font-weight:bold">.&lt;/span>&lt;span style="color:#000">LeaseDuration&lt;/span>&lt;span style="color:#000;font-weight:bold">)&lt;/span> &lt;span style="color:#ce5c00;font-weight:bold">/&lt;/span> &lt;span style="color:#000">time&lt;/span>&lt;span style="color:#000;font-weight:bold">.&lt;/span>&lt;span style="color:#000">Second&lt;/span>&lt;span style="color:#000;font-weight:bold">),&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#8f5902;font-style:italic">// 将租约改成 now
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8f5902;font-style:italic">&lt;/span> &lt;span style="color:#000">RenewTime&lt;/span>&lt;span style="color:#000;font-weight:bold">:&lt;/span> &lt;span style="color:#000">now&lt;/span>&lt;span style="color:#000;font-weight:bold">,&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#000">AcquireTime&lt;/span>&lt;span style="color:#000;font-weight:bold">:&lt;/span> &lt;span style="color:#000">now&lt;/span>&lt;span style="color:#000;font-weight:bold">,&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#000;font-weight:bold">}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#8f5902;font-style:italic">// 获取当前的资源锁
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8f5902;font-style:italic">&lt;/span> &lt;span style="color:#000">oldLeaderElectionRecord&lt;/span>&lt;span style="color:#000;font-weight:bold">,&lt;/span> &lt;span style="color:#000">err&lt;/span> &lt;span style="color:#ce5c00;font-weight:bold">:=&lt;/span> &lt;span style="color:#000">le&lt;/span>&lt;span style="color:#000;font-weight:bold">.&lt;/span>&lt;span style="color:#000">config&lt;/span>&lt;span style="color:#000;font-weight:bold">.&lt;/span>&lt;span style="color:#000">Lock&lt;/span>&lt;span style="color:#000;font-weight:bold">.&lt;/span>&lt;span style="color:#000">Get&lt;/span>&lt;span style="color:#000;font-weight:bold">()&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#204a87;font-weight:bold">if&lt;/span> &lt;span style="color:#000">err&lt;/span> &lt;span style="color:#ce5c00;font-weight:bold">!=&lt;/span> &lt;span style="color:#204a87;font-weight:bold">nil&lt;/span> &lt;span style="color:#000;font-weight:bold">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ce5c00;font-weight:bold">...&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#8f5902;font-style:italic">// 执行到这里说明找不到资源锁，执行资源锁的创建动作
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8f5902;font-style:italic">&lt;/span> &lt;span style="color:#8f5902;font-style:italic">// 由于资源锁对应的底层 Kubernetes 资源 Endpoint 或 ConfigMap 是不可重复创建的，所以此处创建是安全的
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8f5902;font-style:italic">&lt;/span> &lt;span style="color:#204a87;font-weight:bold">if&lt;/span> &lt;span style="color:#000">err&lt;/span> &lt;span style="color:#000;font-weight:bold">=&lt;/span> &lt;span style="color:#000">le&lt;/span>&lt;span style="color:#000;font-weight:bold">.&lt;/span>&lt;span style="color:#000">config&lt;/span>&lt;span style="color:#000;font-weight:bold">.&lt;/span>&lt;span style="color:#000">Lock&lt;/span>&lt;span style="color:#000;font-weight:bold">.&lt;/span>&lt;span style="color:#000">Create&lt;/span>&lt;span style="color:#000;font-weight:bold">(&lt;/span>&lt;span style="color:#000">leaderElectionRecord&lt;/span>&lt;span style="color:#000;font-weight:bold">);&lt;/span> &lt;span style="color:#000">err&lt;/span> &lt;span style="color:#ce5c00;font-weight:bold">!=&lt;/span> &lt;span style="color:#204a87;font-weight:bold">nil&lt;/span> &lt;span style="color:#000;font-weight:bold">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ce5c00;font-weight:bold">...&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#000;font-weight:bold">}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ce5c00;font-weight:bold">...&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#000;font-weight:bold">}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#8f5902;font-style:italic">// 如果当前已经有 Leader，进行 Update 操作
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8f5902;font-style:italic">&lt;/span> &lt;span style="color:#8f5902;font-style:italic">// 如果当前是 Leader：Update 操作就是续租动作，即将对应字段的时间改成当前时间
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8f5902;font-style:italic">&lt;/span> &lt;span style="color:#8f5902;font-style:italic">// 如果是非 Leader 节点且可运行 Update 操作，则是一个抢夺资源锁的过程，谁先更新成功谁就抢到资源
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8f5902;font-style:italic">&lt;/span> &lt;span style="color:#ce5c00;font-weight:bold">...&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#8f5902;font-style:italic">// 如果还没有过期且当前不是 Leader，直接返回
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8f5902;font-style:italic">&lt;/span> &lt;span style="color:#8f5902;font-style:italic">// 只有 Leader 才进行续租操作且此时其他节点无须抢夺资源锁
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8f5902;font-style:italic">&lt;/span> &lt;span style="color:#204a87;font-weight:bold">if&lt;/span> &lt;span style="color:#000">le&lt;/span>&lt;span style="color:#000;font-weight:bold">.&lt;/span>&lt;span style="color:#000">observedTime&lt;/span>&lt;span style="color:#000;font-weight:bold">.&lt;/span>&lt;span style="color:#000">Add&lt;/span>&lt;span style="color:#000;font-weight:bold">(&lt;/span>&lt;span style="color:#000">le&lt;/span>&lt;span style="color:#000;font-weight:bold">.&lt;/span>&lt;span style="color:#000">config&lt;/span>&lt;span style="color:#000;font-weight:bold">.&lt;/span>&lt;span style="color:#000">LeaseDuration&lt;/span>&lt;span style="color:#000;font-weight:bold">).&lt;/span>&lt;span style="color:#000">After&lt;/span>&lt;span style="color:#000;font-weight:bold">(&lt;/span>&lt;span style="color:#000">now&lt;/span>&lt;span style="color:#000;font-weight:bold">.&lt;/span>&lt;span style="color:#000">Time&lt;/span>&lt;span style="color:#000;font-weight:bold">)&lt;/span> &lt;span style="color:#ce5c00;font-weight:bold">&amp;amp;&amp;amp;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#000">oldLeaderElectionRecord&lt;/span>&lt;span style="color:#000;font-weight:bold">.&lt;/span>&lt;span style="color:#000">HolderIdentity&lt;/span> &lt;span style="color:#ce5c00;font-weight:bold">!=&lt;/span> &lt;span style="color:#000">le&lt;/span>&lt;span style="color:#000;font-weight:bold">.&lt;/span>&lt;span style="color:#000">config&lt;/span>&lt;span style="color:#000;font-weight:bold">.&lt;/span>&lt;span style="color:#000">Lock&lt;/span>&lt;span style="color:#000;font-weight:bold">.&lt;/span>&lt;span style="color:#000">Identity&lt;/span>&lt;span style="color:#000;font-weight:bold">()&lt;/span> &lt;span style="color:#000;font-weight:bold">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ce5c00;font-weight:bold">...&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#204a87;font-weight:bold">return&lt;/span> &lt;span style="color:#204a87;font-weight:bold">false&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#000;font-weight:bold">}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ce5c00;font-weight:bold">...&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#8f5902;font-style:italic">// 更新资源
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8f5902;font-style:italic">&lt;/span> &lt;span style="color:#8f5902;font-style:italic">// 对于 Leader 来说，这是一个续租的过程
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8f5902;font-style:italic">&lt;/span> &lt;span style="color:#8f5902;font-style:italic">// 对于非 Leader 节点（仅在上一个资源锁已经过期），这是一个更新锁所有权的过程
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8f5902;font-style:italic">&lt;/span> &lt;span style="color:#204a87;font-weight:bold">if&lt;/span> &lt;span style="color:#000">err&lt;/span> &lt;span style="color:#000;font-weight:bold">=&lt;/span> &lt;span style="color:#000">le&lt;/span>&lt;span style="color:#000;font-weight:bold">.&lt;/span>&lt;span style="color:#000">config&lt;/span>&lt;span style="color:#000;font-weight:bold">.&lt;/span>&lt;span style="color:#000">Lock&lt;/span>&lt;span style="color:#000;font-weight:bold">.&lt;/span>&lt;span style="color:#000">Update&lt;/span>&lt;span style="color:#000;font-weight:bold">(&lt;/span>&lt;span style="color:#000">leaderElectionRecord&lt;/span>&lt;span style="color:#000;font-weight:bold">);&lt;/span> &lt;span style="color:#000">err&lt;/span> &lt;span style="color:#ce5c00;font-weight:bold">!=&lt;/span> &lt;span style="color:#204a87;font-weight:bold">nil&lt;/span> &lt;span style="color:#000;font-weight:bold">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ce5c00;font-weight:bold">...&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#000;font-weight:bold">}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#000;font-weight:bold">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>由上可以看出，&lt;code>tryAcquireOrRenew()&lt;/code> 就是一个不断尝试 Update 操作的过程。&lt;/p>
&lt;p>如果执行逻辑从 &lt;code>le.acquire()&lt;/code> 跳出，往下执行 &lt;code>le.renew()&lt;/code>，这说明当前 Pod 已经成功抢到资源锁成为 Leader，必须定期续租：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#204a87;font-weight:bold">func&lt;/span> &lt;span style="color:#000;font-weight:bold">(&lt;/span>&lt;span style="color:#000">le&lt;/span> &lt;span style="color:#ce5c00;font-weight:bold">*&lt;/span>&lt;span style="color:#000">LeaderElector&lt;/span>&lt;span style="color:#000;font-weight:bold">)&lt;/span> &lt;span style="color:#000">renew&lt;/span>&lt;span style="color:#000;font-weight:bold">()&lt;/span> &lt;span style="color:#000;font-weight:bold">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#000">stop&lt;/span> &lt;span style="color:#ce5c00;font-weight:bold">:=&lt;/span> &lt;span style="color:#204a87">make&lt;/span>&lt;span style="color:#000;font-weight:bold">(&lt;/span>&lt;span style="color:#204a87;font-weight:bold">chan&lt;/span> &lt;span style="color:#204a87;font-weight:bold">struct&lt;/span>&lt;span style="color:#000;font-weight:bold">{})&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#8f5902;font-style:italic">// period 为 0 说明会一直执行
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8f5902;font-style:italic">&lt;/span> &lt;span style="color:#000">wait&lt;/span>&lt;span style="color:#000;font-weight:bold">.&lt;/span>&lt;span style="color:#000">Until&lt;/span>&lt;span style="color:#000;font-weight:bold">(&lt;/span>&lt;span style="color:#204a87;font-weight:bold">func&lt;/span>&lt;span style="color:#000;font-weight:bold">()&lt;/span> &lt;span style="color:#000;font-weight:bold">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#8f5902;font-style:italic">// 每间隔 RetryPeriod 就执行 tryAcquireOrRenew()
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8f5902;font-style:italic">&lt;/span> &lt;span style="color:#8f5902;font-style:italic">// 如果 tryAcquireOrRenew() 返回 false 跳出 Poll()
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8f5902;font-style:italic">&lt;/span> &lt;span style="color:#8f5902;font-style:italic">// tryAcquireOrRenew() 返回 false 说明续租失败
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8f5902;font-style:italic">&lt;/span> &lt;span style="color:#000">err&lt;/span> &lt;span style="color:#ce5c00;font-weight:bold">:=&lt;/span> &lt;span style="color:#000">wait&lt;/span>&lt;span style="color:#000;font-weight:bold">.&lt;/span>&lt;span style="color:#000">Poll&lt;/span>&lt;span style="color:#000;font-weight:bold">(&lt;/span>&lt;span style="color:#000">le&lt;/span>&lt;span style="color:#000;font-weight:bold">.&lt;/span>&lt;span style="color:#000">config&lt;/span>&lt;span style="color:#000;font-weight:bold">.&lt;/span>&lt;span style="color:#000">RetryPeriod&lt;/span>&lt;span style="color:#000;font-weight:bold">,&lt;/span> &lt;span style="color:#000">le&lt;/span>&lt;span style="color:#000;font-weight:bold">.&lt;/span>&lt;span style="color:#000">config&lt;/span>&lt;span style="color:#000;font-weight:bold">.&lt;/span>&lt;span style="color:#000">RenewDeadline&lt;/span>&lt;span style="color:#000;font-weight:bold">,&lt;/span> &lt;span style="color:#204a87;font-weight:bold">func&lt;/span>&lt;span style="color:#000;font-weight:bold">()&lt;/span> &lt;span style="color:#000;font-weight:bold">(&lt;/span>&lt;span style="color:#204a87;font-weight:bold">bool&lt;/span>&lt;span style="color:#000;font-weight:bold">,&lt;/span> &lt;span style="color:#204a87;font-weight:bold">error&lt;/span>&lt;span style="color:#000;font-weight:bold">)&lt;/span> &lt;span style="color:#000;font-weight:bold">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#204a87;font-weight:bold">return&lt;/span> &lt;span style="color:#000">le&lt;/span>&lt;span style="color:#000;font-weight:bold">.&lt;/span>&lt;span style="color:#000">tryAcquireOrRenew&lt;/span>&lt;span style="color:#000;font-weight:bold">(),&lt;/span> &lt;span style="color:#204a87;font-weight:bold">nil&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#000;font-weight:bold">})&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#8f5902;font-style:italic">// 续租失败，说明已经不是 Leader
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8f5902;font-style:italic">&lt;/span> &lt;span style="color:#ce5c00;font-weight:bold">...&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#000;font-weight:bold">},&lt;/span> &lt;span style="color:#0000cf;font-weight:bold">0&lt;/span>&lt;span style="color:#000;font-weight:bold">,&lt;/span> &lt;span style="color:#000">stop&lt;/span>&lt;span style="color:#000;font-weight:bold">)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#000;font-weight:bold">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="如何使用-leaderelection-库">如何使用 &lt;code>leaderelection&lt;/code> 库&lt;a class="td-heading-self-link" href="#%e5%a6%82%e4%bd%95%e4%bd%bf%e7%94%a8-leaderelection-%e5%ba%93" aria-label="Heading self-link">&lt;/a>&lt;/h3>
&lt;p>让我们来关注一下 &lt;a href="https://github.com/kubernetes/contrib/tree/master/election">election&lt;/a> 的实现。&lt;/p>
&lt;p>主要的逻辑位于 &lt;code>election/lib/election.go&lt;/code>：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#204a87;font-weight:bold">func&lt;/span> &lt;span style="color:#000">RunElection&lt;/span>&lt;span style="color:#000;font-weight:bold">(&lt;/span>&lt;span style="color:#000">e&lt;/span> &lt;span style="color:#ce5c00;font-weight:bold">*&lt;/span>&lt;span style="color:#000">leaderelection&lt;/span>&lt;span style="color:#000;font-weight:bold">.&lt;/span>&lt;span style="color:#000">LeaderElector&lt;/span>&lt;span style="color:#000;font-weight:bold">)&lt;/span> &lt;span style="color:#000;font-weight:bold">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#000">wait&lt;/span>&lt;span style="color:#000;font-weight:bold">.&lt;/span>&lt;span style="color:#000">Forever&lt;/span>&lt;span style="color:#000;font-weight:bold">(&lt;/span>&lt;span style="color:#000">e&lt;/span>&lt;span style="color:#000;font-weight:bold">.&lt;/span>&lt;span style="color:#000">Run&lt;/span>&lt;span style="color:#000;font-weight:bold">,&lt;/span> &lt;span style="color:#0000cf;font-weight:bold">0&lt;/span>&lt;span style="color:#000;font-weight:bold">)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#000;font-weight:bold">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>主体逻辑很简单，就是不断执行 &lt;code>Run()&lt;/code>。而 &lt;code>Run()&lt;/code> 的实现就是上文中 &lt;code>leaderelection&lt;/code> 的 &lt;code>Run()&lt;/code> 。&lt;/p>
&lt;p>上层应用只需要创建（&lt;code>NewElection()&lt;/code>）创建 &lt;code>LeaderElector&lt;/code> 对象，然后在一个 loop 中调用 &lt;code>Run()&lt;/code> 即可。&lt;/p>
&lt;p>综上所述，Kubernetes 中 Pod 的选举过程本质上还是为了服务的高可用。&lt;/p>
&lt;h1 id="公众号---k8s技术圈kubernetes-源码剖析之-leader-选举">公众号 - k8s技术圈，Kubernetes 源码剖析之 Leader 选举&lt;a class="td-heading-self-link" href="#%e5%85%ac%e4%bc%97%e5%8f%b7---k8s%e6%8a%80%e6%9c%af%e5%9c%88kubernetes-%e6%ba%90%e7%a0%81%e5%89%96%e6%9e%90%e4%b9%8b-leader-%e9%80%89%e4%b8%be" aria-label="Heading self-link">&lt;/a>&lt;/h1>
&lt;blockquote>
&lt;ul>
&lt;li>&lt;a href="https://mp.weixin.qq.com/s/EPKShekTZWe04H1X2E21LQ">公众号 - k8s技术圈，Kubernetes 源码剖析之 Leader 选举&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>领导者选举要解决什么问题呢？首先，一个分布式集群中运行了多个组件，每个组件负责自身重要的功能。其中有一个组件因为某些原因而退出，此时整个集群的运作都受到了影响。&lt;strong>领导者选举就是要保证每个组件的高可用性&lt;/strong>，例如，在 Kubernetes 集群中，允许同时运行多个 kube-scheduler 节点，其中正常工作的只有一个 kube-scheduler 节点（即领导者节点），其他 kube-scheduler 节点为候选（Candidate）节点并处于阻塞状态。在领导者节点因某些原因而退出后，其他候选节点则通过领导者选举机制竞选，有一个候选节点成为领导者节点并接替之前领导者节点的工作。领导者选举机制如下图所示。&lt;/p>
&lt;h2 id="领导者选举机制">领导者选举机制&lt;a class="td-heading-self-link" href="#%e9%a2%86%e5%af%bc%e8%80%85%e9%80%89%e4%b8%be%e6%9c%ba%e5%88%b6" aria-label="Heading self-link">&lt;/a>&lt;/h2>
&lt;p>领导者选举机制是&lt;strong>分布式锁&lt;/strong>机制的一种，实现分布式锁有多种方式，例如可通过 ZooKeeper、Redis、Etcd 等存储服务。Kubernetes 系统依赖于 Etcd 做存储服务，系统中其他组件也是通过 Etcd 实现分布式锁的。kube-scheduler 组件在 Etcd 上实现分布式锁的原理如下。&lt;/p>
&lt;ul>
&lt;li>分布式锁依赖于 Etcd 上的一个 key，key 的操作都是&lt;strong>原子操作&lt;/strong>，将 key 作为分布式锁，它有两种状态——存在和不存在。&lt;/li>
&lt;li>key（分布式锁）不存在时：多节点中的一个节点成功创建该 key（获得锁）并写入自身节点的信息，获得锁的节点被称为领导者节点。领导者节点会定时更新（续约）该 key 的信息。&lt;/li>
&lt;li>key（分布式锁）存在时：其他节点处于阻塞状态并定时获取锁，这些节点被称为候选节点。候选节点定时获取锁的过程如下：定时获取 key 的数据，验证数据中领导者租约是否到期，如果未到期则不能抢占它，如果已到期则更新 key 并写入自身节点的信息，更新成功则成为领导者节点。&lt;/li>
&lt;/ul>
&lt;h2 id="资源锁">资源锁&lt;a class="td-heading-self-link" href="#%e8%b5%84%e6%ba%90%e9%94%81" aria-label="Heading self-link">&lt;/a>&lt;/h2>
&lt;p>Kubernetes 支持 3 种资源锁，资源锁的意思是基于 Etcd 集群的 key 在依赖于 Kubernetes 的某种资源下创建的分布式锁。3 种资源锁介绍如下：&lt;/p>
&lt;ul>
&lt;li>&lt;strong>EndpointsResourceLock&lt;/strong>：依赖于 Endpoints 资源，默认资源锁为该类型。&lt;/li>
&lt;li>&lt;strong>ConfigMapsResourceLock&lt;/strong>：依赖于 Configmaps 资源。&lt;/li>
&lt;li>&lt;strong>LeasesResourceLock&lt;/strong>：依赖于 Leases 资源。&lt;/li>
&lt;/ul>
&lt;p>可通过 &lt;code>--leader-elect-resource-lock&lt;/code> 参数指定使用哪种资源锁，如不指定则&lt;code>EndpointsResourceLock&lt;/code> 为默认资源锁。它的 key（分布式锁）存在于 Etcd 集群的 &lt;code>/registry/services/endpoints/kube-system/kube-scheduler&lt;/code> 中。该 key 中存储的是竞选为领导者节点的信息，它通过 &lt;code>LeaderElectionRecord&lt;/code> 结构体进行描述：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a40000">#&lt;/span> &lt;span style="color:#000">源码路径&lt;/span>&lt;span style="color:#a40000">：&lt;/span>&lt;span style="color:#000">vendor&lt;/span>&lt;span style="color:#ce5c00;font-weight:bold">/&lt;/span>&lt;span style="color:#000">k8s&lt;/span>&lt;span style="color:#000;font-weight:bold">.&lt;/span>&lt;span style="color:#000">io&lt;/span>&lt;span style="color:#ce5c00;font-weight:bold">/&lt;/span>&lt;span style="color:#000">client&lt;/span>&lt;span style="color:#ce5c00;font-weight:bold">-&lt;/span>&lt;span style="color:#204a87;font-weight:bold">go&lt;/span>&lt;span style="color:#ce5c00;font-weight:bold">/&lt;/span>&lt;span style="color:#000">tools&lt;/span>&lt;span style="color:#ce5c00;font-weight:bold">/&lt;/span>&lt;span style="color:#000">leaderelection&lt;/span>&lt;span style="color:#ce5c00;font-weight:bold">/&lt;/span>&lt;span style="color:#000">resourcelock&lt;/span>&lt;span style="color:#ce5c00;font-weight:bold">/&lt;/span>&lt;span style="color:#204a87;font-weight:bold">interface&lt;/span>&lt;span style="color:#000;font-weight:bold">.&lt;/span>&lt;span style="color:#204a87;font-weight:bold">go&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#204a87;font-weight:bold">type&lt;/span> &lt;span style="color:#000">LeaderElectionRecord&lt;/span> &lt;span style="color:#204a87;font-weight:bold">struct&lt;/span> &lt;span style="color:#000;font-weight:bold">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#000">HolderIdentity&lt;/span> &lt;span style="color:#204a87;font-weight:bold">string&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#000">LeaseDurationSeconds&lt;/span> &lt;span style="color:#204a87;font-weight:bold">int&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#000">AcquireTime&lt;/span> &lt;span style="color:#000">metav1&lt;/span>&lt;span style="color:#000;font-weight:bold">.&lt;/span>&lt;span style="color:#000">Time&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#000">RenewTime&lt;/span> &lt;span style="color:#000">metav1&lt;/span>&lt;span style="color:#000;font-weight:bold">.&lt;/span>&lt;span style="color:#000">Time&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#000">LeaderTransitions&lt;/span> &lt;span style="color:#204a87;font-weight:bold">int&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#000;font-weight:bold">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ul>
&lt;li>&lt;strong>HolderIdentity&lt;/strong>：领导者身份标识，通常为 Hostname_&amp;lt;hash 值&amp;gt;。&lt;/li>
&lt;li>&lt;strong>LeaseDurationSeconds&lt;/strong>：领导者租约的时长。&lt;/li>
&lt;li>&lt;strong>AcquireTime&lt;/strong>：领导者获得锁的时间。&lt;/li>
&lt;li>&lt;strong>RenewTime&lt;/strong>：领导者续租的时间。&lt;/li>
&lt;li>&lt;strong>LeaderTransitions&lt;/strong>：领导者选举切换的次数。&lt;/li>
&lt;/ul>
&lt;p>每种资源锁实现了对 key（资源锁）的操作方法，它的接口定义如下：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a40000">#&lt;/span> &lt;span style="color:#000">代码路径&lt;/span>&lt;span style="color:#a40000">：&lt;/span>&lt;span style="color:#000">vendor&lt;/span>&lt;span style="color:#ce5c00;font-weight:bold">/&lt;/span>&lt;span style="color:#000">k8s&lt;/span>&lt;span style="color:#000;font-weight:bold">.&lt;/span>&lt;span style="color:#000">io&lt;/span>&lt;span style="color:#ce5c00;font-weight:bold">/&lt;/span>&lt;span style="color:#000">client&lt;/span>&lt;span style="color:#ce5c00;font-weight:bold">-&lt;/span>&lt;span style="color:#204a87;font-weight:bold">go&lt;/span>&lt;span style="color:#ce5c00;font-weight:bold">/&lt;/span>&lt;span style="color:#000">tools&lt;/span>&lt;span style="color:#ce5c00;font-weight:bold">/&lt;/span>&lt;span style="color:#000">leaderelection&lt;/span>&lt;span style="color:#ce5c00;font-weight:bold">/&lt;/span>&lt;span style="color:#000">resourcelock&lt;/span>&lt;span style="color:#ce5c00;font-weight:bold">/&lt;/span>&lt;span style="color:#204a87;font-weight:bold">interface&lt;/span>&lt;span style="color:#000;font-weight:bold">.&lt;/span>&lt;span style="color:#204a87;font-weight:bold">go&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#204a87;font-weight:bold">type&lt;/span> &lt;span style="color:#000">Interface&lt;/span> &lt;span style="color:#204a87;font-weight:bold">interface&lt;/span> &lt;span style="color:#000;font-weight:bold">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#000">Get&lt;/span>&lt;span style="color:#000;font-weight:bold">()&lt;/span> &lt;span style="color:#000;font-weight:bold">(&lt;/span>&lt;span style="color:#000">LeaderElectionRecord&lt;/span>&lt;span style="color:#000;font-weight:bold">,&lt;/span> &lt;span style="color:#204a87;font-weight:bold">error&lt;/span>&lt;span style="color:#000;font-weight:bold">)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#000">Create&lt;/span>&lt;span style="color:#000;font-weight:bold">(&lt;/span>&lt;span style="color:#000">ler&lt;/span> &lt;span style="color:#000">LeaderElectionRecord&lt;/span>&lt;span style="color:#000;font-weight:bold">)&lt;/span> &lt;span style="color:#204a87;font-weight:bold">error&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#000">Update&lt;/span>&lt;span style="color:#000;font-weight:bold">(&lt;/span>&lt;span style="color:#000">ler&lt;/span> &lt;span style="color:#000">LeaderElectionRecord&lt;/span>&lt;span style="color:#000;font-weight:bold">)&lt;/span> &lt;span style="color:#204a87;font-weight:bold">error&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#000">RecordEvent&lt;/span>&lt;span style="color:#000;font-weight:bold">(&lt;/span>&lt;span style="color:#204a87;font-weight:bold">string&lt;/span>&lt;span style="color:#000;font-weight:bold">)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#000">Identity&lt;/span>&lt;span style="color:#000;font-weight:bold">()&lt;/span> &lt;span style="color:#204a87;font-weight:bold">string&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#000">Describe&lt;/span>&lt;span style="color:#000;font-weight:bold">()&lt;/span> &lt;span style="color:#204a87;font-weight:bold">string&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#000;font-weight:bold">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Get 方法用于获取资源锁的所有信息，Create 方法用于创建资源锁，Update 方法用于更新资源锁信息，RecordEvent 方法通过 EventBroadcaster 事件管理器记录事件，Identity 方法用于获取领导者身份标识，Describe 方法用于获取资源锁的信息。&lt;/p>
&lt;h2 id="领导者选举过程">领导者选举过程&lt;a class="td-heading-self-link" href="#%e9%a2%86%e5%af%bc%e8%80%85%e9%80%89%e4%b8%be%e8%bf%87%e7%a8%8b" aria-label="Heading self-link">&lt;/a>&lt;/h2>
&lt;p>领导者选举过程如下图所示：&lt;/p>
&lt;p>领导者选举过程&lt;/p>
&lt;p>&lt;code>le.acquire&lt;/code> 函数尝试从 Etcd 中获取资源锁，领导者节点获取到资源锁后会执行 kube-scheduler 的主要逻辑（即 &lt;code>le.config.Callbacks.OnStartedLeading&lt;/code> 回调函数），并通过 &lt;code>le.renew&lt;/code> 函数定时（默认值为 2 秒）对资源锁续约。候选节点获取不到资源锁，它不会退出并定时（默认值为 2 秒）尝试获取资源锁，直到成功为止。代码示例如下：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a40000">#&lt;/span> &lt;span style="color:#000">代码路径&lt;/span>&lt;span style="color:#a40000">：&lt;/span>&lt;span style="color:#000">vendor&lt;/span>&lt;span style="color:#ce5c00;font-weight:bold">/&lt;/span>&lt;span style="color:#000">k8s&lt;/span>&lt;span style="color:#000;font-weight:bold">.&lt;/span>&lt;span style="color:#000">io&lt;/span>&lt;span style="color:#ce5c00;font-weight:bold">/&lt;/span>&lt;span style="color:#000">client&lt;/span>&lt;span style="color:#ce5c00;font-weight:bold">-&lt;/span>&lt;span style="color:#204a87;font-weight:bold">go&lt;/span>&lt;span style="color:#ce5c00;font-weight:bold">/&lt;/span>&lt;span style="color:#000">tools&lt;/span>&lt;span style="color:#ce5c00;font-weight:bold">/&lt;/span>&lt;span style="color:#000">leaderelection&lt;/span>&lt;span style="color:#ce5c00;font-weight:bold">/&lt;/span>&lt;span style="color:#000">leaderelection&lt;/span>&lt;span style="color:#000;font-weight:bold">.&lt;/span>&lt;span style="color:#204a87;font-weight:bold">go&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#204a87;font-weight:bold">func&lt;/span> &lt;span style="color:#000;font-weight:bold">(&lt;/span>&lt;span style="color:#000">le&lt;/span> &lt;span style="color:#ce5c00;font-weight:bold">*&lt;/span>&lt;span style="color:#000">LeaderElector&lt;/span>&lt;span style="color:#000;font-weight:bold">)&lt;/span> &lt;span style="color:#000">Run&lt;/span>&lt;span style="color:#000;font-weight:bold">(&lt;/span>&lt;span style="color:#000">ctx&lt;/span> &lt;span style="color:#000">context&lt;/span>&lt;span style="color:#000;font-weight:bold">.&lt;/span>&lt;span style="color:#000">Context&lt;/span>&lt;span style="color:#000;font-weight:bold">)&lt;/span> &lt;span style="color:#000;font-weight:bold">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#204a87;font-weight:bold">defer&lt;/span> &lt;span style="color:#204a87;font-weight:bold">func&lt;/span>&lt;span style="color:#000;font-weight:bold">()&lt;/span> &lt;span style="color:#000;font-weight:bold">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#000">runtime&lt;/span>&lt;span style="color:#000;font-weight:bold">.&lt;/span>&lt;span style="color:#000">HandleCrash&lt;/span>&lt;span style="color:#000;font-weight:bold">()&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#000">le&lt;/span>&lt;span style="color:#000;font-weight:bold">.&lt;/span>&lt;span style="color:#000">config&lt;/span>&lt;span style="color:#000;font-weight:bold">.&lt;/span>&lt;span style="color:#000">Callbacks&lt;/span>&lt;span style="color:#000;font-weight:bold">.&lt;/span>&lt;span style="color:#000">OnStoppedLeading&lt;/span>&lt;span style="color:#000;font-weight:bold">()&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#000;font-weight:bold">}()&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#204a87;font-weight:bold">if&lt;/span> &lt;span style="color:#000;font-weight:bold">!&lt;/span>&lt;span style="color:#000">le&lt;/span>&lt;span style="color:#000;font-weight:bold">.&lt;/span>&lt;span style="color:#000">acquire&lt;/span>&lt;span style="color:#000;font-weight:bold">(&lt;/span>&lt;span style="color:#000">ctx&lt;/span>&lt;span style="color:#000;font-weight:bold">)&lt;/span> &lt;span style="color:#000;font-weight:bold">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#204a87;font-weight:bold">return&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#000;font-weight:bold">}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ce5c00;font-weight:bold">...&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#204a87;font-weight:bold">go&lt;/span> &lt;span style="color:#000">le&lt;/span>&lt;span style="color:#000;font-weight:bold">.&lt;/span>&lt;span style="color:#000">config&lt;/span>&lt;span style="color:#000;font-weight:bold">.&lt;/span>&lt;span style="color:#000">Callbacks&lt;/span>&lt;span style="color:#000;font-weight:bold">.&lt;/span>&lt;span style="color:#000">OnStartedLeading&lt;/span>&lt;span style="color:#000;font-weight:bold">(&lt;/span>&lt;span style="color:#000">ctx&lt;/span>&lt;span style="color:#000;font-weight:bold">)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#000">le&lt;/span>&lt;span style="color:#000;font-weight:bold">.&lt;/span>&lt;span style="color:#000">renew&lt;/span>&lt;span style="color:#000;font-weight:bold">(&lt;/span>&lt;span style="color:#000">ctx&lt;/span>&lt;span style="color:#000;font-weight:bold">)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#000;font-weight:bold">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;blockquote>
&lt;ol>
&lt;li>资源锁获取过程&lt;/li>
&lt;/ol>
&lt;/blockquote>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#204a87;font-weight:bold">func&lt;/span> &lt;span style="color:#000;font-weight:bold">(&lt;/span>&lt;span style="color:#000">le&lt;/span> &lt;span style="color:#ce5c00;font-weight:bold">*&lt;/span>&lt;span style="color:#000">LeaderElector&lt;/span>&lt;span style="color:#000;font-weight:bold">)&lt;/span> &lt;span style="color:#000">acquire&lt;/span>&lt;span style="color:#000;font-weight:bold">(&lt;/span>&lt;span style="color:#000">ctx&lt;/span> &lt;span style="color:#000">context&lt;/span>&lt;span style="color:#000;font-weight:bold">.&lt;/span>&lt;span style="color:#000">Context&lt;/span>&lt;span style="color:#000;font-weight:bold">)&lt;/span> &lt;span style="color:#204a87;font-weight:bold">bool&lt;/span> &lt;span style="color:#000;font-weight:bold">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ce5c00;font-weight:bold">...&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#000">wait&lt;/span>&lt;span style="color:#000;font-weight:bold">.&lt;/span>&lt;span style="color:#000">JitterUntil&lt;/span>&lt;span style="color:#000;font-weight:bold">(&lt;/span>&lt;span style="color:#204a87;font-weight:bold">func&lt;/span>&lt;span style="color:#000;font-weight:bold">()&lt;/span> &lt;span style="color:#000;font-weight:bold">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#000">succeeded&lt;/span> &lt;span style="color:#000;font-weight:bold">=&lt;/span> &lt;span style="color:#000">le&lt;/span>&lt;span style="color:#000;font-weight:bold">.&lt;/span>&lt;span style="color:#000">tryAcquireOrRenew&lt;/span>&lt;span style="color:#000;font-weight:bold">()&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#000">le&lt;/span>&lt;span style="color:#000;font-weight:bold">.&lt;/span>&lt;span style="color:#000">maybeReportTransition&lt;/span>&lt;span style="color:#000;font-weight:bold">()&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#204a87;font-weight:bold">if&lt;/span> &lt;span style="color:#000;font-weight:bold">!&lt;/span>&lt;span style="color:#000">succeeded&lt;/span> &lt;span style="color:#000;font-weight:bold">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#204a87;font-weight:bold">return&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#000;font-weight:bold">}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ce5c00;font-weight:bold">...&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#000">cancel&lt;/span>&lt;span style="color:#000;font-weight:bold">()&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#000;font-weight:bold">},&lt;/span> &lt;span style="color:#000">le&lt;/span>&lt;span style="color:#000;font-weight:bold">.&lt;/span>&lt;span style="color:#000">config&lt;/span>&lt;span style="color:#000;font-weight:bold">.&lt;/span>&lt;span style="color:#000">RetryPeriod&lt;/span>&lt;span style="color:#000;font-weight:bold">,&lt;/span> &lt;span style="color:#000">JitterFactor&lt;/span>&lt;span style="color:#000;font-weight:bold">,&lt;/span> &lt;span style="color:#204a87;font-weight:bold">true&lt;/span>&lt;span style="color:#000;font-weight:bold">,&lt;/span> &lt;span style="color:#000">ctx&lt;/span>&lt;span style="color:#000;font-weight:bold">.&lt;/span>&lt;span style="color:#000">Done&lt;/span>&lt;span style="color:#000;font-weight:bold">())&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#204a87;font-weight:bold">return&lt;/span> &lt;span style="color:#000">succeeded&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#000;font-weight:bold">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>获取资源锁的过程通过 &lt;code>wait.JitterUntil&lt;/code> 定时器定时执行，它接收一个 func 匿名函数和一个 stopCh Chan，内部会定时调用匿名函数，只有当 stopCh 关闭时，该定时器才会停止并退出。&lt;/p>
&lt;p>执行 &lt;code>le.tryAcquireOrRenew&lt;/code> 函数来获取资源锁。如果其获取资源锁失败，会通过 return 等待下一次定时获取资源锁。如果其获取资源锁成功，则说明当前节点可以成为领导者节点，退出 acquire 函数并返回 true。&lt;code>le.tryAcquireOrRenew&lt;/code> 代码示例如下。&lt;/p>
&lt;p>（1）首先，通过 &lt;code>le.config.Lock.Get&lt;/code> 函数获取资源锁，当资源锁不存在时，当前节点创建该 key（获取锁）并写入自身节点的信息，创建成功则当前节点成为领导者节点并返回 true。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#000">oldLeaderElectionRecord&lt;/span>&lt;span style="color:#000;font-weight:bold">,&lt;/span> &lt;span style="color:#000">err&lt;/span> &lt;span style="color:#ce5c00;font-weight:bold">:=&lt;/span> &lt;span style="color:#000">le&lt;/span>&lt;span style="color:#000;font-weight:bold">.&lt;/span>&lt;span style="color:#000">config&lt;/span>&lt;span style="color:#000;font-weight:bold">.&lt;/span>&lt;span style="color:#000">Lock&lt;/span>&lt;span style="color:#000;font-weight:bold">.&lt;/span>&lt;span style="color:#000">Get&lt;/span>&lt;span style="color:#000;font-weight:bold">()&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#204a87;font-weight:bold">if&lt;/span> &lt;span style="color:#000">err&lt;/span> &lt;span style="color:#ce5c00;font-weight:bold">!=&lt;/span> &lt;span style="color:#204a87;font-weight:bold">nil&lt;/span> &lt;span style="color:#000;font-weight:bold">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#204a87;font-weight:bold">if&lt;/span> &lt;span style="color:#000;font-weight:bold">!&lt;/span>&lt;span style="color:#000">errors&lt;/span>&lt;span style="color:#000;font-weight:bold">.&lt;/span>&lt;span style="color:#000">IsNotFound&lt;/span>&lt;span style="color:#000;font-weight:bold">(&lt;/span>&lt;span style="color:#000">err&lt;/span>&lt;span style="color:#000;font-weight:bold">)&lt;/span> &lt;span style="color:#000;font-weight:bold">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#204a87;font-weight:bold">return&lt;/span> &lt;span style="color:#204a87;font-weight:bold">false&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#000;font-weight:bold">}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#204a87;font-weight:bold">if&lt;/span> &lt;span style="color:#000">err&lt;/span> &lt;span style="color:#000;font-weight:bold">=&lt;/span> &lt;span style="color:#000">le&lt;/span>&lt;span style="color:#000;font-weight:bold">.&lt;/span>&lt;span style="color:#000">config&lt;/span>&lt;span style="color:#000;font-weight:bold">.&lt;/span>&lt;span style="color:#000">Lock&lt;/span>&lt;span style="color:#000;font-weight:bold">.&lt;/span>&lt;span style="color:#000">Create&lt;/span>&lt;span style="color:#000;font-weight:bold">(&lt;/span>&lt;span style="color:#000">leaderElectionRecord&lt;/span>&lt;span style="color:#000;font-weight:bold">);&lt;/span> &lt;span style="color:#000">err&lt;/span> &lt;span style="color:#ce5c00;font-weight:bold">!=&lt;/span> &lt;span style="color:#204a87;font-weight:bold">nil&lt;/span> &lt;span style="color:#000;font-weight:bold">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#204a87;font-weight:bold">return&lt;/span> &lt;span style="color:#204a87;font-weight:bold">false&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#000;font-weight:bold">}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#000">le&lt;/span>&lt;span style="color:#000;font-weight:bold">.&lt;/span>&lt;span style="color:#000">observedRecord&lt;/span> &lt;span style="color:#000;font-weight:bold">=&lt;/span> &lt;span style="color:#000">leaderElectionRecord&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#000">le&lt;/span>&lt;span style="color:#000;font-weight:bold">.&lt;/span>&lt;span style="color:#000">observedTime&lt;/span> &lt;span style="color:#000;font-weight:bold">=&lt;/span> &lt;span style="color:#000">le&lt;/span>&lt;span style="color:#000;font-weight:bold">.&lt;/span>&lt;span style="color:#000">clock&lt;/span>&lt;span style="color:#000;font-weight:bold">.&lt;/span>&lt;span style="color:#000">Now&lt;/span>&lt;span style="color:#000;font-weight:bold">()&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#204a87;font-weight:bold">return&lt;/span> &lt;span style="color:#204a87;font-weight:bold">true&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#000;font-weight:bold">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>（2）当资源锁存在时，更新本地缓存的租约信息。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#204a87;font-weight:bold">if&lt;/span> &lt;span style="color:#000;font-weight:bold">!&lt;/span>&lt;span style="color:#000">reflect&lt;/span>&lt;span style="color:#000;font-weight:bold">.&lt;/span>&lt;span style="color:#000">DeepEqual&lt;/span>&lt;span style="color:#000;font-weight:bold">(&lt;/span>&lt;span style="color:#000">le&lt;/span>&lt;span style="color:#000;font-weight:bold">.&lt;/span>&lt;span style="color:#000">observedRecord&lt;/span>&lt;span style="color:#000;font-weight:bold">,&lt;/span> &lt;span style="color:#ce5c00;font-weight:bold">*&lt;/span>&lt;span style="color:#000">oldLeaderElectionRecord&lt;/span>&lt;span style="color:#000;font-weight:bold">)&lt;/span> &lt;span style="color:#000;font-weight:bold">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#000">le&lt;/span>&lt;span style="color:#000;font-weight:bold">.&lt;/span>&lt;span style="color:#000">observedRecord&lt;/span> &lt;span style="color:#000;font-weight:bold">=&lt;/span> &lt;span style="color:#ce5c00;font-weight:bold">*&lt;/span>&lt;span style="color:#000">oldLeaderElectionRecord&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#000">le&lt;/span>&lt;span style="color:#000;font-weight:bold">.&lt;/span>&lt;span style="color:#000">observedTime&lt;/span> &lt;span style="color:#000;font-weight:bold">=&lt;/span> &lt;span style="color:#000">le&lt;/span>&lt;span style="color:#000;font-weight:bold">.&lt;/span>&lt;span style="color:#000">clock&lt;/span>&lt;span style="color:#000;font-weight:bold">.&lt;/span>&lt;span style="color:#000">Now&lt;/span>&lt;span style="color:#000;font-weight:bold">()&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#000;font-weight:bold">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>（3）候选节点会验证领导者节点的租约是否到期，如果尚未到期，暂时还不能抢占并返回 false。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#204a87;font-weight:bold">if&lt;/span> &lt;span style="color:#204a87">len&lt;/span>&lt;span style="color:#000;font-weight:bold">(&lt;/span>&lt;span style="color:#000">oldLeaderElectionRecord&lt;/span>&lt;span style="color:#000;font-weight:bold">.&lt;/span>&lt;span style="color:#000">HolderIdentity&lt;/span>&lt;span style="color:#000;font-weight:bold">)&lt;/span> &lt;span style="color:#000;font-weight:bold">&amp;gt;&lt;/span> &lt;span style="color:#0000cf;font-weight:bold">0&lt;/span> &lt;span style="color:#ce5c00;font-weight:bold">&amp;amp;&amp;amp;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#000">le&lt;/span>&lt;span style="color:#000;font-weight:bold">.&lt;/span>&lt;span style="color:#000">observedTime&lt;/span>&lt;span style="color:#000;font-weight:bold">.&lt;/span>&lt;span style="color:#000">Add&lt;/span>&lt;span style="color:#000;font-weight:bold">(&lt;/span>&lt;span style="color:#000">le&lt;/span>&lt;span style="color:#000;font-weight:bold">.&lt;/span>&lt;span style="color:#000">config&lt;/span>&lt;span style="color:#000;font-weight:bold">.&lt;/span>&lt;span style="color:#000">LeaseDuration&lt;/span>&lt;span style="color:#000;font-weight:bold">).&lt;/span>&lt;span style="color:#000">After&lt;/span>&lt;span style="color:#000;font-weight:bold">(&lt;/span>&lt;span style="color:#000">now&lt;/span>&lt;span style="color:#000;font-weight:bold">.&lt;/span>&lt;span style="color:#000">Time&lt;/span>&lt;span style="color:#000;font-weight:bold">)&lt;/span> &lt;span style="color:#ce5c00;font-weight:bold">&amp;amp;&amp;amp;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#000;font-weight:bold">!&lt;/span>&lt;span style="color:#000">le&lt;/span>&lt;span style="color:#000;font-weight:bold">.&lt;/span>&lt;span style="color:#000">IsLeader&lt;/span>&lt;span style="color:#000;font-weight:bold">()&lt;/span> &lt;span style="color:#000;font-weight:bold">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ce5c00;font-weight:bold">...&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#204a87;font-weight:bold">return&lt;/span> &lt;span style="color:#204a87;font-weight:bold">false&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#000;font-weight:bold">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>（4）如果是领导者节点，那么 AcquireTime（资源锁获得时间）和 LeaderTransitions（领导者进行切换的次数）字段保持不变。如果是候选节点，则说明领导者节点的租约到期，给 LeaderTransitions 字段加 1 并抢占资源锁。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#204a87;font-weight:bold">if&lt;/span> &lt;span style="color:#000">le&lt;/span>&lt;span style="color:#000;font-weight:bold">.&lt;/span>&lt;span style="color:#000">IsLeader&lt;/span>&lt;span style="color:#000;font-weight:bold">()&lt;/span> &lt;span style="color:#000;font-weight:bold">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#000">leaderElectionRecord&lt;/span>&lt;span style="color:#000;font-weight:bold">.&lt;/span>&lt;span style="color:#000">AcquireTime&lt;/span> &lt;span style="color:#000;font-weight:bold">=&lt;/span> &lt;span style="color:#000">oldLeaderElectionRecord&lt;/span>&lt;span style="color:#000;font-weight:bold">.&lt;/span>&lt;span style="color:#000">AcquireTime&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#000">leaderElectionRecord&lt;/span>&lt;span style="color:#000;font-weight:bold">.&lt;/span>&lt;span style="color:#000">LeaderTransitions&lt;/span> &lt;span style="color:#000;font-weight:bold">=&lt;/span> &lt;span style="color:#000">oldLeaderElectionRecord&lt;/span>&lt;span style="color:#000;font-weight:bold">.&lt;/span>&lt;span style="color:#000">LeaderTransitions&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#000;font-weight:bold">}&lt;/span> &lt;span style="color:#204a87;font-weight:bold">else&lt;/span> &lt;span style="color:#000;font-weight:bold">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#000">leaderElectionRecord&lt;/span>&lt;span style="color:#000;font-weight:bold">.&lt;/span>&lt;span style="color:#000">LeaderTransitions&lt;/span> &lt;span style="color:#000;font-weight:bold">=&lt;/span> &lt;span style="color:#000">oldLeaderElectionRecord&lt;/span>&lt;span style="color:#000;font-weight:bold">.&lt;/span>&lt;span style="color:#000">LeaderTransitions&lt;/span> &lt;span style="color:#ce5c00;font-weight:bold">+&lt;/span> &lt;span style="color:#0000cf;font-weight:bold">1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#000;font-weight:bold">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>（5）通过 &lt;code>le.config.Lock.Update&lt;/code> 函数尝试去更新租约记录，若更新成功，函数返回 true。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#204a87;font-weight:bold">if&lt;/span> &lt;span style="color:#000">err&lt;/span> &lt;span style="color:#000;font-weight:bold">=&lt;/span> &lt;span style="color:#000">le&lt;/span>&lt;span style="color:#000;font-weight:bold">.&lt;/span>&lt;span style="color:#000">config&lt;/span>&lt;span style="color:#000;font-weight:bold">.&lt;/span>&lt;span style="color:#000">Lock&lt;/span>&lt;span style="color:#000;font-weight:bold">.&lt;/span>&lt;span style="color:#000">Update&lt;/span>&lt;span style="color:#000;font-weight:bold">(&lt;/span>&lt;span style="color:#000">leaderElectionRecord&lt;/span>&lt;span style="color:#000;font-weight:bold">);&lt;/span> &lt;span style="color:#000">err&lt;/span> &lt;span style="color:#ce5c00;font-weight:bold">!=&lt;/span> &lt;span style="color:#204a87;font-weight:bold">nil&lt;/span> &lt;span style="color:#000;font-weight:bold">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#000">klog&lt;/span>&lt;span style="color:#000;font-weight:bold">.&lt;/span>&lt;span style="color:#000">Errorf&lt;/span>&lt;span style="color:#000;font-weight:bold">(&lt;/span>&lt;span style="color:#4e9a06">&amp;#34;Failed to update lock: %v&amp;#34;&lt;/span>&lt;span style="color:#000;font-weight:bold">,&lt;/span> &lt;span style="color:#000">err&lt;/span>&lt;span style="color:#000;font-weight:bold">)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#204a87;font-weight:bold">return&lt;/span> &lt;span style="color:#204a87;font-weight:bold">false&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#000;font-weight:bold">}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ce5c00;font-weight:bold">...&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#204a87;font-weight:bold">return&lt;/span> &lt;span style="color:#204a87;font-weight:bold">true&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;blockquote>
&lt;ol start="2">
&lt;li>领导者节点定时更新租约过程&lt;/li>
&lt;/ol>
&lt;/blockquote>
&lt;p>在领导者节点获取资源锁以后，会定时（默认值为 2 秒）循环更新租约信息，以保持长久的领导者身份。若因网络超时而导致租约信息更新失败，则说明被候选节点抢占了领导者身份，当前节点会退出进程。代码示例如下：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a40000">#&lt;/span> &lt;span style="color:#000">代码路径&lt;/span>&lt;span style="color:#a40000">：&lt;/span>&lt;span style="color:#000">vendor&lt;/span>&lt;span style="color:#ce5c00;font-weight:bold">/&lt;/span>&lt;span style="color:#000">k8s&lt;/span>&lt;span style="color:#000;font-weight:bold">.&lt;/span>&lt;span style="color:#000">io&lt;/span>&lt;span style="color:#ce5c00;font-weight:bold">/&lt;/span>&lt;span style="color:#000">client&lt;/span>&lt;span style="color:#ce5c00;font-weight:bold">-&lt;/span>&lt;span style="color:#204a87;font-weight:bold">go&lt;/span>&lt;span style="color:#ce5c00;font-weight:bold">/&lt;/span>&lt;span style="color:#000">tools&lt;/span>&lt;span style="color:#ce5c00;font-weight:bold">/&lt;/span>&lt;span style="color:#000">leaderelection&lt;/span>&lt;span style="color:#ce5c00;font-weight:bold">/&lt;/span>&lt;span style="color:#000">leaderelection&lt;/span>&lt;span style="color:#000;font-weight:bold">.&lt;/span>&lt;span style="color:#204a87;font-weight:bold">go&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#204a87;font-weight:bold">func&lt;/span> &lt;span style="color:#000;font-weight:bold">(&lt;/span>&lt;span style="color:#000">le&lt;/span> &lt;span style="color:#ce5c00;font-weight:bold">*&lt;/span>&lt;span style="color:#000">LeaderElector&lt;/span>&lt;span style="color:#000;font-weight:bold">)&lt;/span> &lt;span style="color:#000">renew&lt;/span>&lt;span style="color:#000;font-weight:bold">(&lt;/span>&lt;span style="color:#000">ctx&lt;/span> &lt;span style="color:#000">context&lt;/span>&lt;span style="color:#000;font-weight:bold">.&lt;/span>&lt;span style="color:#000">Context&lt;/span>&lt;span style="color:#000;font-weight:bold">)&lt;/span> &lt;span style="color:#000;font-weight:bold">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ce5c00;font-weight:bold">...&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#000">wait&lt;/span>&lt;span style="color:#000;font-weight:bold">.&lt;/span>&lt;span style="color:#000">Until&lt;/span>&lt;span style="color:#000;font-weight:bold">(&lt;/span>&lt;span style="color:#204a87;font-weight:bold">func&lt;/span>&lt;span style="color:#000;font-weight:bold">()&lt;/span> &lt;span style="color:#000;font-weight:bold">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ce5c00;font-weight:bold">...&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#000">err&lt;/span> &lt;span style="color:#ce5c00;font-weight:bold">:=&lt;/span> &lt;span style="color:#000">wait&lt;/span>&lt;span style="color:#000;font-weight:bold">.&lt;/span>&lt;span style="color:#000">PollImmediateUntil&lt;/span>&lt;span style="color:#000;font-weight:bold">(&lt;/span>&lt;span style="color:#000">le&lt;/span>&lt;span style="color:#000;font-weight:bold">.&lt;/span>&lt;span style="color:#000">config&lt;/span>&lt;span style="color:#000;font-weight:bold">.&lt;/span>&lt;span style="color:#000">RetryPeriod&lt;/span>&lt;span style="color:#000;font-weight:bold">,&lt;/span> &lt;span style="color:#204a87;font-weight:bold">func&lt;/span>&lt;span style="color:#000;font-weight:bold">()&lt;/span> &lt;span style="color:#000;font-weight:bold">(&lt;/span>&lt;span style="color:#204a87;font-weight:bold">bool&lt;/span>&lt;span style="color:#000;font-weight:bold">,&lt;/span> &lt;span style="color:#204a87;font-weight:bold">error&lt;/span>&lt;span style="color:#000;font-weight:bold">)&lt;/span> &lt;span style="color:#000;font-weight:bold">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#000">done&lt;/span> &lt;span style="color:#ce5c00;font-weight:bold">:=&lt;/span> &lt;span style="color:#204a87">make&lt;/span>&lt;span style="color:#000;font-weight:bold">(&lt;/span>&lt;span style="color:#204a87;font-weight:bold">chan&lt;/span> &lt;span style="color:#204a87;font-weight:bold">bool&lt;/span>&lt;span style="color:#000;font-weight:bold">,&lt;/span> &lt;span style="color:#0000cf;font-weight:bold">1&lt;/span>&lt;span style="color:#000;font-weight:bold">)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#204a87;font-weight:bold">go&lt;/span> &lt;span style="color:#204a87;font-weight:bold">func&lt;/span>&lt;span style="color:#000;font-weight:bold">()&lt;/span> &lt;span style="color:#000;font-weight:bold">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#204a87;font-weight:bold">defer&lt;/span> &lt;span style="color:#204a87">close&lt;/span>&lt;span style="color:#000;font-weight:bold">(&lt;/span>&lt;span style="color:#000">done&lt;/span>&lt;span style="color:#000;font-weight:bold">)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#000">done&lt;/span> &lt;span style="color:#ce5c00;font-weight:bold">&amp;lt;-&lt;/span> &lt;span style="color:#000">le&lt;/span>&lt;span style="color:#000;font-weight:bold">.&lt;/span>&lt;span style="color:#000">tryAcquireOrRenew&lt;/span>&lt;span style="color:#000;font-weight:bold">()&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#000;font-weight:bold">}()&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ce5c00;font-weight:bold">...&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#000;font-weight:bold">},&lt;/span> &lt;span style="color:#000">timeoutCtx&lt;/span>&lt;span style="color:#000;font-weight:bold">.&lt;/span>&lt;span style="color:#000">Done&lt;/span>&lt;span style="color:#000;font-weight:bold">())&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ce5c00;font-weight:bold">...&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#204a87;font-weight:bold">if&lt;/span> &lt;span style="color:#000">err&lt;/span> &lt;span style="color:#ce5c00;font-weight:bold">==&lt;/span> &lt;span style="color:#204a87;font-weight:bold">nil&lt;/span> &lt;span style="color:#000;font-weight:bold">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#000">klog&lt;/span>&lt;span style="color:#000;font-weight:bold">.&lt;/span>&lt;span style="color:#000">V&lt;/span>&lt;span style="color:#000;font-weight:bold">(&lt;/span>&lt;span style="color:#0000cf;font-weight:bold">5&lt;/span>&lt;span style="color:#000;font-weight:bold">).&lt;/span>&lt;span style="color:#000">Infof&lt;/span>&lt;span style="color:#000;font-weight:bold">(&lt;/span>&lt;span style="color:#4e9a06">&amp;#34;successfully renewed lease %v&amp;#34;&lt;/span>&lt;span style="color:#000;font-weight:bold">,&lt;/span> &lt;span style="color:#000">desc&lt;/span>&lt;span style="color:#000;font-weight:bold">)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#204a87;font-weight:bold">return&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#000;font-weight:bold">}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ce5c00;font-weight:bold">...&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#000">cancel&lt;/span>&lt;span style="color:#000;font-weight:bold">()&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#000;font-weight:bold">},&lt;/span> &lt;span style="color:#000">le&lt;/span>&lt;span style="color:#000;font-weight:bold">.&lt;/span>&lt;span style="color:#000">config&lt;/span>&lt;span style="color:#000;font-weight:bold">.&lt;/span>&lt;span style="color:#000">RetryPeriod&lt;/span>&lt;span style="color:#000;font-weight:bold">,&lt;/span> &lt;span style="color:#000">ctx&lt;/span>&lt;span style="color:#000;font-weight:bold">.&lt;/span>&lt;span style="color:#000">Done&lt;/span>&lt;span style="color:#000;font-weight:bold">())&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#204a87;font-weight:bold">if&lt;/span> &lt;span style="color:#000">le&lt;/span>&lt;span style="color:#000;font-weight:bold">.&lt;/span>&lt;span style="color:#000">config&lt;/span>&lt;span style="color:#000;font-weight:bold">.&lt;/span>&lt;span style="color:#000">ReleaseOnCancel&lt;/span> &lt;span style="color:#000;font-weight:bold">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#000">le&lt;/span>&lt;span style="color:#000;font-weight:bold">.&lt;/span>&lt;span style="color:#000">release&lt;/span>&lt;span style="color:#000;font-weight:bold">()&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#000;font-weight:bold">}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#000;font-weight:bold">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>领导者节点续约的过程通过 &lt;code>wait.PollImmediateUntil&lt;/code> 定时器定时执行，它接收一个 func 匿名函数（条件函数）和一个 stopCh，内部会定时调用条件函数，当条件函数返回 true 或 stopCh 关闭时，该定时器才会停止并退出。&lt;/p>
&lt;p>执行 &lt;code>le.tryAcquireOrRenew&lt;/code> 函数来实现领导者节点的续约，其原理与资源锁获取过程相同。le.tryAcquireOrRenew 函数返回 true 说明续约成功，并进入下一个定时续约；返回 false 则退出并执行 le.release 函数且释放资源锁。&lt;/p></description></item></channel></rss>