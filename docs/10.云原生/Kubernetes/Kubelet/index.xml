<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Kubelet on 断念梦的站点</title><link>https://desistdaydream.github.io/docs/10.%E4%BA%91%E5%8E%9F%E7%94%9F/Kubernetes/Kubelet/</link><description>Recent content in Kubelet on 断念梦的站点</description><generator>Hugo</generator><language>zh-cn</language><atom:link href="https://desistdaydream.github.io/docs/10.%E4%BA%91%E5%8E%9F%E7%94%9F/Kubernetes/Kubelet/index.xml" rel="self" type="application/rss+xml"/><item><title>Kubelet</title><link>https://desistdaydream.github.io/docs/10.%E4%BA%91%E5%8E%9F%E7%94%9F/Kubernetes/Kubelet/Kubelet/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/10.%E4%BA%91%E5%8E%9F%E7%94%9F/Kubernetes/Kubelet/Kubelet/</guid><description>概述 参考：
官方文档，参考-组件工具-kubelet Kubelet 是在每个节点上运行的主要 节点代理。它可以使用以下之一向 APIServer 注册节点：用于覆盖主机名的标志；或云提供商的特定逻辑。
kubelet 根据 PodSpec 起作用。 PodSpec 是一个描述 Pod 的 YAML 或 JSON 对象。 kubelet 接受通过各种机制（主要是通过 apiserver）提供的一组 PodSpec，并确保这些 PodSpec 中描述的容器正在运行且运行状况良好。 Kubelet 不管理不是 Kubernetes 创建的容器。一般情况， PodSpec 都是由在 k8s 对象的 yaml 文件中定义的。
kubelet 负责维护容器(CNI)的生命周期，同时也负责 Volume（CVI）和 Network（CNI）的管理。kubernetes 集群的宿主机上，启动的每一个 pod 都有由 kubelet 这个组件管理的。
kubelet 在每个 Node 上都会启动一个 kubelet daemon 进程，默认监听在 10250 端口。该进程用于处理 Master 节点(主要是 apiserver)下发到本节点的任务，管理 Pod 以及 Pod 中的容器。每个 kubelet 进程会在 APIServer 上注册节点自身信息，定期向 Master 节点汇报节点资源的使用情况，并通过 cAdvisor(kubelet 内部功能) 监控容器和节点资源。10248 为 kubelet 健康检查的 healthz 端口</description></item><item><title>Kubelet 配置</title><link>https://desistdaydream.github.io/docs/10.%E4%BA%91%E5%8E%9F%E7%94%9F/Kubernetes/Kubelet/Kubelet-%E9%85%8D%E7%BD%AE/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/10.%E4%BA%91%E5%8E%9F%E7%94%9F/Kubernetes/Kubelet/Kubelet-%E9%85%8D%E7%BD%AE/</guid><description>概述 参考：
官方文档，入门-生产环境-使用工具安装 Kubernetes-使用 kubeadm 引导集群-使用 kubeadm 配置集群中每个 kubelet 官方文档，参考-配置 APIs-Kubelet 配置(v1beta1) 可以通过两种方式配置 kubelet 运行时行为
config.yaml 配置文件 # config.yaml 文件默认路径为 /var/lib/kubelet/config.yaml ，可以通过 &amp;ndash;config &amp;lt;FILE&amp;gt; 来指定其他的文件。 这里是官方文档对于配置文件的概述。在章节中间部分，可以直接看到配置文件对应的代码中结构体，也就是配置文件详细内容 这里是配置文件中每个字段的详解，与代码中的结构体互相对应，只不过是整理后，可以直接在网页上查看，更清晰。 kubelet 命令行标志 这里是官方文档对命令行标志的详解 官方更推荐使用第一种方式，通过 config.yaml 的文件修改，来改变 kubelet 的运行时参数。
很多配置文件的内容与命令行标志具有一一对应的关系，比如：
配置文件 命令行标志 cgroupDriver: systemd &amp;ndash;cgroup-driver=systemd clusterDNS: [10.96.0.10,&amp;hellip;] &amp;ndash;cluster-dns=10.96.0.10,&amp;hellip; authentication.x509.clientCAFile: /etc/kubernetes/pki/ca.crt &amp;ndash;client-ca-file=/etc/kubernetes/pki/ca.crt 等等 等等 但是也有一些是没有对应关系的，只能通过配置文件，或者命令行标志配置。比如命令行标志的 --container-runtime 就无法在配置文件中配置。在命令行标志官方文档中，凡是标着 DEPRECATED 的命令行标志，都是可以在配置文件中配置的。
命令行标志详解 参考：
官方文档，参考 - 组件工具 - kubelet &amp;ndash;cni-conf-dir &amp;lt;STRING&amp;gt; # Warning：Alpha 功能。指定 STRING 目录中搜索 CNI 配置文件。 默认值：/etc/cni/net.</description></item><item><title>Runtime</title><link>https://desistdaydream.github.io/docs/10.%E4%BA%91%E5%8E%9F%E7%94%9F/Kubernetes/Kubelet/Runtime/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/10.%E4%BA%91%E5%8E%9F%E7%94%9F/Kubernetes/Kubelet/Runtime/</guid><description>概述 参考：
原文链接：白话 Kubernetes Runtime 回想最开始接触 k8s 的时候, 经常搞不懂 CRI 和 OCI 的联系和区别, 也不知道为啥要垫那么多的 “shim”(尤其是 containerd-shim 和 dockershim 这两个完全没啥关联的东西还恰好都叫 shim). 所以嘛, 这篇就写一写 k8s 的 runtime 部分, 争取一篇文章把下面这张 Landscape 里的核心项目给白话明白。
(以上理由其实都是为了说服自己写写水文也是可以的…)
典型的 Runtime 架构 我们从最常见的 runtime 方案 Docker 说起, 现在 Kubelet 和 Docker 的集成还是挺啰嗦的:
当 Kubelet 想要创建一个容器时, 有这么几步:
Kubelet 通过 CRI 接口(gRPC) 调用 dockershim, 请求创建一个容器. CRI 即容器运行时接口(Container Runtime Interface), 这一步中, Kubelet 可以视作一个简单的 CRI Client, 而 dockershim 就是接收请求的 Server. 目前 dockershim 的代码其实是内嵌在 Kubelet 中的, 所以接收调用的凑巧就是 Kubelet 进程; dockershim 收到请求后, 转化成 Docker Daemon 能听懂的请求, 发到 Docker Daemon 上请求创建一个容器; Docker Daemon 早在 1.</description></item><item><title>CRI 对比</title><link>https://desistdaydream.github.io/docs/10.%E4%BA%91%E5%8E%9F%E7%94%9F/Kubernetes/Kubelet/CRI-%E5%AF%B9%E6%AF%94/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/10.%E4%BA%91%E5%8E%9F%E7%94%9F/Kubernetes/Kubelet/CRI-%E5%AF%B9%E6%AF%94/</guid><description>原文：阳明公众号
下面是我已经测试的几个 CRI，并进行一些基准测试来对他们进行了简单的对比，希望对你有所帮助：
dockershim containerd crio 对于 cri-o，已经测试了 2 个后端：runc 和 crun，以测试对 cgroupsv2 的影响。
测试环境 我这里的测试环境是一个 1.19.4 版本的 kubernetes 集群，使用 ansible 进行创建（https://gitlab.com/incubateur-pe）。集群运行在 kvm 上，配置如下：
master：Centos/7, 2vcpus/2G 内存。 crio-crun 节点：Fedora-32, 2vcpus/4G 内存。 其他节点：Centos/7, 2vcpus/4G 内存. 底层是 i7-9700K ，64G 的内存和一个 mp510 nvme 硬盘。
创建集群 这里我直接使用 molecule 创建一个集群，并配置了它在每个 worker 节点上使用不同的 cri，对应的 ansible 源码位于：https://gitlab.com/incubateur-pe/kubernetes-bare-metal/-/tree/dev/molecule/criBench
使用上面的脚本，执行 molecule converge 命令后，大概 10 分钟左右，我们就可以得到一个如下所示的 kubernetes 集群。
接下来我们就可以进行一些简单的基准测试了。
测试 1. bucketbench 测试 Bucketbench (https://github.com/estesp/bucketbench) 是一个可以对容器引擎执行一系列操作的测试工具，它非常适合于了解之前每个节点的性能。
这里我们的测试参数很简单：
3 个线程 15 次循环 run/stop/delete 操作 对应的结果如下所示（ms 为单位）：</description></item><item><title>crictl 命令行工具</title><link>https://desistdaydream.github.io/docs/10.%E4%BA%91%E5%8E%9F%E7%94%9F/Kubernetes/Kubelet/crictl-%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%B7%A5%E5%85%B7/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/10.%E4%BA%91%E5%8E%9F%E7%94%9F/Kubernetes/Kubelet/crictl-%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%B7%A5%E5%85%B7/</guid><description>概述 参考：
项目地址 使用 crictl 对 kubernetes 进行调试 crictl 用于为 kubelet CRI 进行调试的 命令行工具
cri-tools 旨在为 Kubelet CRI 提供一系列调试和验证工具，其中包括：
crictl: kubelet 的 CRI 命令行工具 critest:kubelet CRI 的验证测试套件 用白话说就是：kubelet 如果要与 CRI 对接，那么如何检测对接成功呢，就是使用 crictl 工具来测试。还可以对已经与 kubelet 建立连接的 CRI 执行相关操作，比如启停容器等。
Note：要想使用 crictl 命令行工具，必须要先进行配置，指定好要操作的 CRI 的 endpoint，才可以正常使用
crictl 配置 /etc/crictl.yaml # crictl 命令行工具运行时配置文件
基本配置文件示例 runtime-endpoint: unix:///run/containerd/containerd.sock image-endpoint: unix:///run/containerd/containerd.sock timeout: 10 debug: true crictl 命令行工具 crictl [Global OPTIONS] COMMAND [COMMAND OPETIONS] [ARGUMENTS&amp;hellip;] COMMMAND
attach Attach to a running container create Create a new container exec Run a command in a running container version Display runtime version information images List images inspect Display the status of one or more containers inspecti Return the status of one or more images inspectp Display the status of one or more pods logs Fetch the logs of a container port-forward Forward local port to a pod ps List containers pull Pull an image from a registry runp Run a new pod rm Remove one or more containers rmi Remove one or more images rmp Remove one or more pods pods List pods start Start one or more created containers info # 显示与 crictl 对接的 CRI 信息 stop Stop one or more running containers stopp Stop one or more running pods update Update one or more running containers config Get and set crictl options stats List container(s) resource usage statistics completion Output bash shell completion code help, h Shows a list of commands or help for one command OPTIONS</description></item></channel></rss>