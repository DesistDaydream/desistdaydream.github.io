<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>CNI on 断念梦的站点</title><link>https://desistdaydream.github.io/docs/10.%E4%BA%91%E5%8E%9F%E7%94%9F/Kubernetes/Kubernetes-%E7%BD%91%E7%BB%9C/CNI/</link><description>Recent content in CNI on 断念梦的站点</description><generator>Hugo</generator><language>zh-cn</language><atom:link href="https://desistdaydream.github.io/docs/10.%E4%BA%91%E5%8E%9F%E7%94%9F/Kubernetes/Kubernetes-%E7%BD%91%E7%BB%9C/CNI/index.xml" rel="self" type="application/rss+xml"/><item><title>CNI</title><link>https://desistdaydream.github.io/docs/10.%E4%BA%91%E5%8E%9F%E7%94%9F/Kubernetes/Kubernetes-%E7%BD%91%E7%BB%9C/CNI/CNI/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/10.%E4%BA%91%E5%8E%9F%E7%94%9F/Kubernetes/Kubernetes-%E7%BD%91%E7%BB%9C/CNI/CNI/</guid><description>概述 参考：
GitHub 项目 GitHub,containernetworking-cni-规范 CNI 与 OCI 是类似的东西，都是一种规范。
Container Network Interface(容器网络接口，简称 CNI) 是一个 CNCF 项目，用于编写为 Linux 容器配置网络接口的插件。CNI 由两部分组成：
CNI Specification(规范) CNI Libraries(库) 由于 CNI 仅仅关注在容器的网络连接以及在删除容器时移出通过 CNI 分配的网络资源。所以，CNI 具有广泛的支持，并且该规范易于实现。
CNI Specification(规范) 每个 CNI 插件必须由 二进制文件 来实现，且这些文件应该可以被容器管理系统(比如 Kubernetes)调用。
CNI 插件负责将网络接口插入容器网络名称空间(例如 veth 对的一端)中，并在主机上进行任何必要的更改(例如将 veth 的另一端连接到网桥)。然后通过调用适当的 IPAM 插件，将 IP 分配给接口并设置与 IP 地址管理部分一致的路由。
CNI Libraries(库) 任何程序都可以调用 CNI 库来实现容器网络，比如 nerdctl、kubelet 等
CNI 的部署和使用方式 官方文档：https://kubernetes.io/docs/concepts/extend-kubernetes/compute-storage-net/network-plugins/#installation
CNI 规范与编程语言无关，并且 CNI 自身仅仅维护标准配置文件和基础插件，想要使用 CNI 来实现容器网络，只需根据标准，调用 CNI 库，即可在程序中实现(比如 nerdctl、kubelet 等)。这些通过 CNI 库实现了容器网络的程序，通过 CNI 插件为其所启动的容器，创建关联网络。</description></item><item><title>Calico</title><link>https://desistdaydream.github.io/docs/10.%E4%BA%91%E5%8E%9F%E7%94%9F/Kubernetes/Kubernetes-%E7%BD%91%E7%BB%9C/CNI/Calico/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/10.%E4%BA%91%E5%8E%9F%E7%94%9F/Kubernetes/Kubernetes-%E7%BD%91%E7%BB%9C/CNI/Calico/</guid><description>Calico 基本概念 基于以 BGP 协议构建网络，主要由三个部分组成
第一部分：Calico 的 CNI 插件。这是 Calico 与 Kubernetes 对接的部分
第二部分：Felix，一个 DaemonSet。负责在 Host 上插入路由规则(即：写入 Linux 内核的 FIB(转发信息库 Forwarding information base)，以及维护 Calico 所需的网络设备等工作
第三部分：BIRD，BGP Client。专门负责在集群内分发路由规则信息
Calico 利用 Linux 内核原生的路由和 iptables 防火墙功能。进出各个容器，虚拟机和主机的所有流量都会在路由到目标之前遍历这些内核规则。
calicoctl：允许您从简单的命令行界面实现高级策略和网络。 orchestrator plugins：提供与各种流行协调器的紧密集成和同步。 key/value store：保存 Calico 的策略和网络配置状态。比如 etcd calico/node：在每个主机上运行，从 key/value store 中读取相关的策略和网络配置信息，并在 Linux 内核中实现它。 Dikastes/Envoy：可选的 Kubernetes sidecar，通过相互 TLS 身份验证保护工作负载到工作负载的通信，并实施应用层策略。 Calico BGP 工作原理 实际上，Calico 项目提供的网络解决方案，与 Flannel 的 host-gw 模式，几乎是完全一样的。也就是说，Calico 也会在每台宿主机上，添加一个格式如下所示的路由规则：
&amp;lt; 目的容器 IP 地址段 &amp;gt; via &amp;lt; 网关的 IP 地址 &amp;gt; dev eth0 其中，网关的 IP 地址，正是目的容器所在宿主机的 IP 地址。</description></item><item><title>Flannel</title><link>https://desistdaydream.github.io/docs/10.%E4%BA%91%E5%8E%9F%E7%94%9F/Kubernetes/Kubernetes-%E7%BD%91%E7%BB%9C/CNI/Flannel/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/10.%E4%BA%91%E5%8E%9F%E7%94%9F/Kubernetes/Kubernetes-%E7%BD%91%E7%BB%9C/CNI/Flannel/</guid><description>概述 参考：
GitHub 项目，flannel-io/flannel Flannel 是一种专为 Kubernetes 设计的，简单、易于配置的 3 层网络结构，并且为 Kubernetes 提供了 CNI 插件。
支持多种后端：即使用什么方法进行进行数据的接收与发送
vxlan host-gw：host gateway UDP Flannel 在每台主机上运行一个名为 flanneld 的小型二进制程序作为代理，负责从更大的预配置地址空间中为每个主机分配 subnet lease(子网租期)。Flannel 直接使用 Kubernetes API 或 etcd 来存储网络配置、已分配的子网、以及任何辅助数据(比如主机的 IP)
子网获取逻辑 代码：./main.go —— WriteSubnetFile()
Flannel 启动时，在 ./main.go 中调用 WriteSubnetFile() 函数，用来生成 subnet 配置文件(默认在 /run/flannel/subnet.env)。
func main() { ...... if err := WriteSubnetFile(opts.subnetFile, config, opts.ipMasq, bn); err != nil { // Continue, even though it failed. log.Warningf(&amp;#34;Failed to write subnet file: %s&amp;#34;, err) } else { log.</description></item></channel></rss>