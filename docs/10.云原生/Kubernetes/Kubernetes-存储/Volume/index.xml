<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Volume on 断念梦的站点</title><link>https://desistdaydream.github.io/docs/10.%E4%BA%91%E5%8E%9F%E7%94%9F/Kubernetes/Kubernetes-%E5%AD%98%E5%82%A8/Volume/</link><description>Recent content in Volume on 断念梦的站点</description><generator>Hugo</generator><language>zh-cn</language><atom:link href="https://desistdaydream.github.io/docs/10.%E4%BA%91%E5%8E%9F%E7%94%9F/Kubernetes/Kubernetes-%E5%AD%98%E5%82%A8/Volume/index.xml" rel="self" type="application/rss+xml"/><item><title>Volume</title><link>https://desistdaydream.github.io/docs/10.%E4%BA%91%E5%8E%9F%E7%94%9F/Kubernetes/Kubernetes-%E5%AD%98%E5%82%A8/Volume/Volume/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/10.%E4%BA%91%E5%8E%9F%E7%94%9F/Kubernetes/Kubernetes-%E5%AD%98%E5%82%A8/Volume/Volume/</guid><description>概述 参考：
官方文档，概念-存储-卷 Volume(卷) 的工作流程：可以把 volume 想象成一个中间人，数据流走向：Container—Volum—StorageResource
要使用 Volume，Pod 的 Manifests 中需要指定要为 Pod 提供卷的类型（.spec.volumes 字段）以及将这些卷挂载到容器的位置（.spec.containers [*].volumeMounts 字段）。
Volume 中数据所在目录 /var/lib/kubelet/pods/PodUID/volumes/XXX # pod 中挂载的 volume，其数据都会保存在该目录下，就算是 nfs 这种远程存储，pod 也是会读取该目录下的某个目录，因为这个目录就是挂载 nfs 的目录。 Volume 的类型 参考：
官方文档，概念-存储-卷-卷类型(全部 Volume 类型的官方介绍) 注意：大量的第三方 In-Tree 类型的第三方卷插件(i.e.非 ConfigMap、Secret 等内置资源的卷插件)将会逐步被弃用，详情参考 Kubernetes 博客，Kubernetes 1.23: Kubernetes In-Tree to CSI Volume Migration Status Update
现阶段(1.21 版本)，Kubernetes 支持以下类型的 Volume：
awsElasticBlockStore azureDisk azureFile cephfs cinder configMap # 一种 Kubernetes 资源，使用 ConfigMap 资源中定义的内容作为 Volume。比如 key 是文件名，value 是文件内容。 downwardAPI emptyDir # 把宿主机上的目录作为 Volume fc (光纤通道) gcePersistentDisk hostPath # 把宿主机上的目录作为 Volume iscsi local # 把宿主机上的目录作为 Volume nfs # 将 NFS 服务提供的目录作为 Volume persistentVolumeClaim # 一种 Kubernetes 资源。详见 Persistent Volume(持久卷) 中关于 PVC 的说明 portworxVolume projected quobyte rbd secret # 一种 Kubernetes 资源。使用 Secret 资源中定义的内容作为 Volume。比如 key 是文件名，value 是文件内容。 storageOS vsphereVolume 上述类型都有各自的用法，常用类型的卷详见本章节下的子章节。</description></item><item><title>ConfigMap 与 Secret</title><link>https://desistdaydream.github.io/docs/10.%E4%BA%91%E5%8E%9F%E7%94%9F/Kubernetes/Kubernetes-%E5%AD%98%E5%82%A8/Volume/ConfigMap-%E4%B8%8E-Secret/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/10.%E4%BA%91%E5%8E%9F%E7%94%9F/Kubernetes/Kubernetes-%E5%AD%98%E5%82%A8/Volume/ConfigMap-%E4%B8%8E-Secret/</guid><description>概述 参考：
官方文档，概念-存储-卷-configMap 官方文档，任务-配置 Pods 和容器-使用 ConfigMap 配置 Pod ConfigMap 与 Secret 这两种资源是 Kubernetes 的配置管理中心，是一种特殊类型的 Volume。用来提供给从 k8s 集群外部到 pod 内部的应用，注入各种信息(配置文件、变量等)的功能。
这种类型的 Volume 不是为了存放 Container 中的数据，也不是用来进行 Container 与 Host 之间的数据交换。而是用来为 Container 提供预先定义好的数据。从 Container 的角度看，这些 Volume 里的信息就仿佛是被 Kubernetes &amp;ldquo;投射&amp;quot;进容器当中一样。
为什么需要 ConfigMap？ 几乎所有的应用开发中，都会涉及到配置文件的变更，比如说在 web 的程序中，需要连接数据库，缓存甚至是队列等等。而我们的一个应用程序从写第一行代码开始，要经历开发环境、测试环境、预发布环境直到最终的线上环境。而每一个环境都要定义其独立的各种配置。如果我们不能很好的管理这些配置文件，运维工作将顿时变的无比的繁琐。为此业内的一些大公司专门开发了自己的一套配置管理中心，如 360 的 Qcon，百度的 disconf 等。很多应用程序的配置需要通过配置文件，命令行参数和环境变量的组合配置来完成（“十二要素应用”等均要求去配置）。这些配置应该从 image 内容中解耦，以此来保持容器化应用程序的可移植性。
Kubernetes 也提供了自己的一套方案，即 ConfigMap。kubernetes 通过 ConfigMap 来实现对容器中应用的配置管理，configmap 是 kubernetes 中的一个资源，可以通过 yaml 来进行配置。每个运行 Pod 的环境都可以有自己的一套 configmap，只需要当 Pod 运行在此环境的时候，自动加载对应的 configmap 即可实现 Pod 中 container 的配置变更。secret 是加密的 configmap。</description></item><item><title>emptyDir、hostPath、local</title><link>https://desistdaydream.github.io/docs/10.%E4%BA%91%E5%8E%9F%E7%94%9F/Kubernetes/Kubernetes-%E5%AD%98%E5%82%A8/Volume/emptyDirhostPathlocal/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/10.%E4%BA%91%E5%8E%9F%E7%94%9F/Kubernetes/Kubernetes-%E5%AD%98%E5%82%A8/Volume/emptyDirhostPathlocal/</guid><description>emptyDir # 在 Pod 的生命周期中的空目录 该类型的 Volume 会随着 Pod 的摧毁重建而自动还原成初始状态。Pod 会创建一个逻辑上的 volume，把该 volum 挂载到一个 Pod 中每个 container 所定义的目录，所有 container 对自己挂载 volume 的目录进行的操作都会在其余 container 挂载该 volume 的目录中看到(每个 container 用于挂载的目录可以不一样，但是用到的 volume 都是同一个)。
medium：指定 volum 的存储媒介(即 volum 使用的存储资源)，默认使用 memory，这样两个容器的数据交互速度会非常快
sizeLimit：容量大小限制，限制 volume 的最大存储空间，如果不做限制，那么对于设备来说，用户数据交互的 volume 会非常浪费资源
获取 emptyDir 类型的 volume 在宿主机的路径的方式：
首先通过 kubectl get pod PODNAME -o yaml | grep uid 来获取 pod 的标识符
然后在目录/var/lib/kubelet/pods/PodID/volumes/kubernets.io~empty-dir/下面找到所有该 pod 所挂载的 empty 类型的 volume，该目录与 pod 中的目录是同步的，在该目录增删改的信息同样也会影响到 pod 对应的目录中。
hostPath # Node 上的文件或目录</description></item></channel></rss>