<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Storage Classes(存储类) on 断念梦的站点</title><link>https://desistdaydream.github.io/docs/10.%E4%BA%91%E5%8E%9F%E7%94%9F/Kubernetes/Kubernetes-%E5%AD%98%E5%82%A8/Storage-Classes%E5%AD%98%E5%82%A8%E7%B1%BB/</link><description>Recent content in Storage Classes(存储类) on 断念梦的站点</description><generator>Hugo</generator><language>zh-cn</language><atom:link href="https://desistdaydream.github.io/docs/10.%E4%BA%91%E5%8E%9F%E7%94%9F/Kubernetes/Kubernetes-%E5%AD%98%E5%82%A8/Storage-Classes%E5%AD%98%E5%82%A8%E7%B1%BB/index.xml" rel="self" type="application/rss+xml"/><item><title>Storage Classes(存储类)</title><link>https://desistdaydream.github.io/docs/10.%E4%BA%91%E5%8E%9F%E7%94%9F/Kubernetes/Kubernetes-%E5%AD%98%E5%82%A8/Storage-Classes%E5%AD%98%E5%82%A8%E7%B1%BB/Storage-Classes%E5%AD%98%E5%82%A8%E7%B1%BB/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/10.%E4%BA%91%E5%8E%9F%E7%94%9F/Kubernetes/Kubernetes-%E5%AD%98%E5%82%A8/Storage-Classes%E5%AD%98%E5%82%A8%E7%B1%BB/Storage-Classes%E5%AD%98%E5%82%A8%E7%B1%BB/</guid><description>概述 参考：
官方文档,概念-存储-存储类 官方文档,任务-管理集群-改变默认 StorageClass 在介绍的 [PV](/docs/10.云原生/2.3.Kubernetes%20 容器编排系统/9.Kubernetes%20 存储/Persistent%20Volume(持久卷).md Volume(持久卷).md) 时有个问题就是管理员需要先创建 pv 固定好容量，再让用户或者开发创建的 PVC 从中挑选，有时候 PVC 申请的时候未必会有满足容量要求的 PV 可以提供，甚至管理员维护大量的 PV 的工作也是非常繁重的。为了实现在创建完 PVC 后，K8S 可以自动创建 PV 的功能，则可以使用 Storage Class(存储类) 这个资源对象来满足这类需求。
Storage Class(存储类)，就像这个名字一样，Storage Class 是一个抽象的概念，用来抽象存储资源。一般情况都是把同类型的存储归为一类，比如 ssd 类型、hdd 类型等等，也可以按照功能划分，给订单组用的存储，给数据组用的存储等等。说白了，Storage Class 就是一块存储空间。
创建完 StorageClass 后，直接创建 PVC 并指定 storageClassName 参数的值为该 StorageClass 的名字，即可自动生成 PV，而不用手动创建。然后在 pod 中直接使用 PVC 作为 volume 进行挂载即可。
Storage Class 的实现方式 Storage Class Name(名字) Storage Class Name(存储类的名字) 是 PV、PVC 选择的标准，PV 与 PVC 总是会选择具有相同名字的 StorageClass 来进行配对。</description></item><item><title>Storage Class Provisioner</title><link>https://desistdaydream.github.io/docs/10.%E4%BA%91%E5%8E%9F%E7%94%9F/Kubernetes/Kubernetes-%E5%AD%98%E5%82%A8/Storage-Classes%E5%AD%98%E5%82%A8%E7%B1%BB/Storage-Class-Provisioner/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/10.%E4%BA%91%E5%8E%9F%E7%94%9F/Kubernetes/Kubernetes-%E5%AD%98%E5%82%A8/Storage-Classes%E5%AD%98%E5%82%A8%E7%B1%BB/Storage-Class-Provisioner/</guid><description>NFS Provisioner 参考：
GitHub GitHubOld 注意：NFS Provisioner 不支持容量限制功能 NFS subdir external provisioner 是一个自动 Provisioner，它使用您现有的和已配置的 NFS 服务器来通过持久卷声明来动态供应 Kubernetes 持久卷。PV 配置为 $ {namespace}-$ {pvcName}-$ {pvName}。
部署 NFS Provisioner 參考：
arifacthub GitHub GitHubOld 创建 namespace
apiVersion: v1 kind: Namespace metadata: name: storage 创建 rbac
kind: ServiceAccount apiVersion: v1 metadata: name: nfs-client-provisioner namespace: storage --- kind: ClusterRole apiVersion: rbac.authorization.k8s.io/v1 metadata: name: nfs-client-provisioner-runner rules: - apiGroups: [&amp;#34;&amp;#34;] resources: [&amp;#34;persistentvolumes&amp;#34;] verbs: [&amp;#34;get&amp;#34;, &amp;#34;list&amp;#34;, &amp;#34;watch&amp;#34;, &amp;#34;create&amp;#34;, &amp;#34;delete&amp;#34;] - apiGroups: [&amp;#34;&amp;#34;] resources: [&amp;#34;persistentvolumeclaims&amp;#34;] verbs: [&amp;#34;get&amp;#34;, &amp;#34;list&amp;#34;, &amp;#34;watch&amp;#34;, &amp;#34;update&amp;#34;] - apiGroups: [&amp;#34;storage.</description></item><item><title>StorageClass Manifest 详解</title><link>https://desistdaydream.github.io/docs/10.%E4%BA%91%E5%8E%9F%E7%94%9F/Kubernetes/Kubernetes-%E5%AD%98%E5%82%A8/Storage-Classes%E5%AD%98%E5%82%A8%E7%B1%BB/StorageClass-Manifest-%E8%AF%A6%E8%A7%A3/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/10.%E4%BA%91%E5%8E%9F%E7%94%9F/Kubernetes/Kubernetes-%E5%AD%98%E5%82%A8/Storage-Classes%E5%AD%98%E5%82%A8%E7%B1%BB/StorageClass-Manifest-%E8%AF%A6%E8%A7%A3/</guid><description>概述 参考：API 文档
其中带有 -required- 标志的为必须的字段
apiVersion: storage.k8s.io/v1 kind: StorageClass metadata: name: # 该 StorageClass 的名字 provisioner: -required- # 指定要使用的 provisioner。 parameters &amp;lt;map[string]string&amp;gt; # Provisioner 的配置参数，不同的 Provisioner 具有不同的参数 NFS Parameters archiveOnDelete: false # PV 删除时，是否存档数据。如果存档数据，则会在 PV 关联的目录名前加上 archived 字符串，以便保存数据。效果如下： [root@nfs-1 test]# ll -h total 0 drwxrwxrwx 4 root input 179 Dec 2 17:02 archived-rabbitmq-persistence-test-server-0-pvc-9e1aabf2-a072-44d1-92df-9cd0864f9fda drwxrwxrwx 4 root input 179 Dec 2 17:02 archived-rabbitmq-persistence-test-server-1-pvc-0409c70e-be04-43e1-9b4c-17b96930cb26 drwxrwxrwx 4 root input 179 Dec 2 17:02 archived-rabbitmq-persistence-test-server-2-pvc-01937680-cc6c-4118-86fc-ed420fdc275b drwxrwxrwx 4 root input 231 Dec 2 21:53 rabbitmq-persistence-test-server-0-pvc-ed8e801f-2659-4829-912b-669145c8396b drwxrwxrwx 4 root input 231 Dec 2 21:53 rabbitmq-persistence-test-server-1-pvc-72c85e1c-8c06-45b2-ba46-e223fafd24d5 drwxrwxrwx 4 root input 231 Dec 2 21:53 rabbitmq-persistence-test-server-2-pvc-9157e421-7150-45ab-8432-2be935dd69ef # 可以看到，前面三个时之前层经删除过的 PV，archiveOnDelete 参数改为 true 后，数据并不会被删除 reclaimPolicy: # 回收策略 StorageClass 动态创建的 PV 的回收策略。</description></item></channel></rss>