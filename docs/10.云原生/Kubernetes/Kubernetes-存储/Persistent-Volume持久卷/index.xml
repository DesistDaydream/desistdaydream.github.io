<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Persistent Volume(持久卷) on 断念梦的站点</title><link>https://desistdaydream.github.io/docs/10.%E4%BA%91%E5%8E%9F%E7%94%9F/Kubernetes/Kubernetes-%E5%AD%98%E5%82%A8/Persistent-Volume%E6%8C%81%E4%B9%85%E5%8D%B7/</link><description>Recent content in Persistent Volume(持久卷) on 断念梦的站点</description><generator>Hugo</generator><language>zh-cn</language><atom:link href="https://desistdaydream.github.io/docs/10.%E4%BA%91%E5%8E%9F%E7%94%9F/Kubernetes/Kubernetes-%E5%AD%98%E5%82%A8/Persistent-Volume%E6%8C%81%E4%B9%85%E5%8D%B7/index.xml" rel="self" type="application/rss+xml"/><item><title>Persistent Volume(持久卷)</title><link>https://desistdaydream.github.io/docs/10.%E4%BA%91%E5%8E%9F%E7%94%9F/Kubernetes/Kubernetes-%E5%AD%98%E5%82%A8/Persistent-Volume%E6%8C%81%E4%B9%85%E5%8D%B7/Persistent-Volume%E6%8C%81%E4%B9%85%E5%8D%B7/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/10.%E4%BA%91%E5%8E%9F%E7%94%9F/Kubernetes/Kubernetes-%E5%AD%98%E5%82%A8/Persistent-Volume%E6%8C%81%E4%B9%85%E5%8D%B7/Persistent-Volume%E6%8C%81%E4%B9%85%E5%8D%B7/</guid><description>PersistentVolume(持久卷) https://kubernetes.io/docs/concepts/storage/persistent-volumes/ kubernetes 的 volume 有一个问题就是不够灵活，且使用 volume 的用户必须要明确知道要使用的 volume 后端是用的什么类型的存储系统(例如 NFS 就需要配置 IP 和 PATH)。这与 kubernetes 的向用户和开发隐藏底层架构的目的有所背离，对存储资源最好的使用方式是能向计算资源一样，用户和开发人员无需了解 pod 资源究竟运行于哪个节点，也无需了解存储系统是什么类型的设备以及位于何处。他们只需要提出容量大小的需求(i.e.PVC)，k8s 管理员可以为其分配所需的空间。这就是 PV 与 PVC 的作用，抽象了底层的存储，使得存储系统的使用和管理两个职能互相解耦。这就好比创建一台虚拟机，并需求 20G 的存储空间，然后虚拟机管理系统就会自动创建出来，而不用去手动指定使用哪个存储空间了。
PersistentVolume(持久卷,简称 PV) 与 PersistentVolumeClaims(持久卷申请,简称 PVC) 是 kubernetes 中的一个 Resource(资源)，PVC 与 volume 不同，volume 的定义需要写进 Pod 的 manifest 中。而 PVC 对于 volume 来说就是一种 &amp;ldquo;volume 的类型&amp;rdquo;。
PV 就相当于虚拟机中的存储卷，虚拟了宿主机或者远程存储的存储资源。PVC 就相当于虚拟机里的一个物理磁盘。虚拟机里的磁盘其实就是通过存储卷来实现的，这与 PV 与 PVC 的关系基本一致。而下文讲的 StorageClass(存储类) 则相当于虚拟机中的存储池的概念了。 PV 与 PVC 为用户和管理员提供了一个 API 接口，抽象定义了存储的消费者-生产者模型(即从 k8s 系统来说，管理员使用 PV 生产一个 storage 资源，用户使用 PVC 消费一个 storage 资源) PV 与 PVC 的生命周期 详见：PV 与 PVC 的状态变化示例</description></item><item><title>PV 与 PVC 的状态变化示例</title><link>https://desistdaydream.github.io/docs/10.%E4%BA%91%E5%8E%9F%E7%94%9F/Kubernetes/Kubernetes-%E5%AD%98%E5%82%A8/Persistent-Volume%E6%8C%81%E4%B9%85%E5%8D%B7/PV-%E4%B8%8E-PVC-%E7%9A%84%E7%8A%B6%E6%80%81%E5%8F%98%E5%8C%96%E7%A4%BA%E4%BE%8B/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/10.%E4%BA%91%E5%8E%9F%E7%94%9F/Kubernetes/Kubernetes-%E5%AD%98%E5%82%A8/Persistent-Volume%E6%8C%81%E4%B9%85%E5%8D%B7/PV-%E4%B8%8E-PVC-%E7%9A%84%E7%8A%B6%E6%80%81%E5%8F%98%E5%8C%96%E7%A4%BA%E4%BE%8B/</guid><description>我们对 PV 和 PVC 的几种状态应该不算陌生，但是在使用过程中可能也会产生一些疑问，比如为什么 PV 变成 Failed 状态了，新创建的 PVC 如何能够绑定之前的 PV，我可以恢复之前的 PV 吗？这里我们就来对 PV 和 PVC 中的几种状态变化再次进行说明。
在不同的情况下，PV 和 PVC 的状态变化我们用如下所示的表格来进行说明：
创建 PV 正常情况下 PV 被创建成功后是 Available 状态：
apiVersion: v1 kind: PersistentVolume metadata: name: nfs-pv spec: storageClassName: manual capacity: storage: 1Gi accessModes: - ReadWriteOnce persistentVolumeReclaimPolicy: Retain nfs: path: /data/k8s # 指定nfs的挂载点 server: 10.151.30.1 # 指定nfs服务地址 直接创建上面的 PV 对象，就可以看到状态是 Available 状态，表示可以用于 PVC 绑定：
$ kubectl get pv nfs-pv NAME CAPACITY ACCESS MODES RECLAIM POLICY STATUS CLAIM STORAGECLASS REASON AGE nfs-pv 1Gi RWO Retain Available manual 7s 新建 PVC</description></item></channel></rss>