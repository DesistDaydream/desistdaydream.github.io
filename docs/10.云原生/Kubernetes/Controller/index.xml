<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Controller on 断念梦的站点</title><link>https://desistdaydream.github.io/docs/10.%E4%BA%91%E5%8E%9F%E7%94%9F/Kubernetes/Controller/</link><description>Recent content in Controller on 断念梦的站点</description><generator>Hugo</generator><language>zh-cn</language><atom:link href="https://desistdaydream.github.io/docs/10.%E4%BA%91%E5%8E%9F%E7%94%9F/Kubernetes/Controller/index.xml" rel="self" type="application/rss+xml"/><item><title>Controller</title><link>https://desistdaydream.github.io/docs/10.%E4%BA%91%E5%8E%9F%E7%94%9F/Kubernetes/Controller/Controller/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/10.%E4%BA%91%E5%8E%9F%E7%94%9F/Kubernetes/Controller/Controller/</guid><description>概述 参考：
官方文档，概念 - 集群架构 - 控制器 Controller(控制器) 是 Kubernetes 的大脑
在机器人和自动化技术中，控制环是一个控制系统状态不终止的循环。
比如：房间里的温度自动调节器，当我设置了温度，告诉温度调节器我的期望状态。房间的实际温度是当前状态。温度自动调节器就会让当前状态一直去接近期望状态。
kubernetes 的 Controller 就是这样一种东西，通过 apiserver 监控集群的期望状态，并致力于将当前状态转变为期望状态。而 controller 是一个更高层次的抽象概念，指代多种具有 controller 功能的资源，比如 deployment、statefulset 等等。
可以用一段 Go 语言风格的伪代码，来描述这个控制循环：
for { 实际状态 := 获取集群中对象 X 的实际状态（Actual State） 期望状态 := 获取集群中对象 X 的期望状态（Desired State） if 实际状态 == 期望状态{ 什么都不做 } else { 执行编排动作，将实际状态调整为期望状态 } } 在具体实现中，实际状态一般来自于 kubernetes 集群本身，e.g.kubelet 收集所在节点上容器状态和节点状态。而期望状态，一般来自于用户提交的 YAMl 文件。
以 Deployment 这种控制器为例，简单描述一下它对控制器模型的实现：
控制器从 Etcd 中获取到所有携带了“app: nginx”标签的 Pod，然后统计它们的数量，这就是实际状态； 用户提交的 yaml 文件中 Replicas 字段的值就是期望状态(提交的 yaml 也会保存到 etcd 中)； 控制器将两个状态做比较，然后根据比较结果，确定是创建 Pod，还是删除已有的 Pod 。 这个对比的操作通常被叫作 Reconcile(调和)。这个调谐的过程，则被称作 Reconcile Loop(调和循环) 或者 Sync Loop(同步循环)。这些词其实都代表一个东西：控制循环。</description></item><item><title>kube-controller-manager 实现控制器的程序</title><link>https://desistdaydream.github.io/docs/10.%E4%BA%91%E5%8E%9F%E7%94%9F/Kubernetes/Controller/kube-controller-manager-%E5%AE%9E%E7%8E%B0%E6%8E%A7%E5%88%B6%E5%99%A8%E7%9A%84%E7%A8%8B%E5%BA%8F/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/10.%E4%BA%91%E5%8E%9F%E7%94%9F/Kubernetes/Controller/kube-controller-manager-%E5%AE%9E%E7%8E%B0%E6%8E%A7%E5%88%B6%E5%99%A8%E7%9A%84%E7%A8%8B%E5%BA%8F/</guid><description>概述 参考：
kube-controller-manager 是实现 Kubernetes Controller(控制器) 的程序。一般在集群启动之前，由 kubelet 使用静态 Pod 以容器方式运行；或者使用 systemd 以 daemon 方式运行。
kube-controller-manager 启动后监听两个端口。
10257 端口是需要身份验证和授权的 https 服务端口。 10252 为不安全的 http 服务端口。 kube-controller-manager 高可用 参考：Leader Election(领导人选举)
我们都知道 k8s 核心组件，其中 apiserver 只用于接收 api 请求，不会主动进行各种动作，所以他们在每个节点都运行并且都可以接收请求，不会造成异常；kube-proxy 也是一样，只用于做端口转发，不会主动进行动作执行。 但是 scheduler, controller-manager 不同，他们参与了 Pod 的调度及具体的各种资源的管控，如果同时有多个 controller-manager 来对 Pod 资源进行调度，结果太美不敢看，那么 k8s 是如何做到正确运转的呢？ k8s 所有功能都是通过 services 对外暴露接口，而 services 对应的是具体的 endpoints ，那么来看下 scheduler 和 controller-manager 的 endpoints 是什么：
[root@node70 21:04:46 ~]$kubectl -n kube-system describe endpoints kube-scheduler Name: kube-scheduler Namespace: kube-system Labels: &amp;lt;none&amp;gt; Annotations: control-plane.</description></item></channel></rss>