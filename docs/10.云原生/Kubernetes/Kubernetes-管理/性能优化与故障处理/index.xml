<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>性能优化与故障处理 on 断念梦的站点</title><link>https://desistdaydream.github.io/docs/10.%E4%BA%91%E5%8E%9F%E7%94%9F/Kubernetes/Kubernetes-%E7%AE%A1%E7%90%86/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E4%B8%8E%E6%95%85%E9%9A%9C%E5%A4%84%E7%90%86/</link><description>Recent content in 性能优化与故障处理 on 断念梦的站点</description><generator>Hugo</generator><language>zh-cn</language><atom:link href="https://desistdaydream.github.io/docs/10.%E4%BA%91%E5%8E%9F%E7%94%9F/Kubernetes/Kubernetes-%E7%AE%A1%E7%90%86/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E4%B8%8E%E6%95%85%E9%9A%9C%E5%A4%84%E7%90%86/index.xml" rel="self" type="application/rss+xml"/><item><title>性能优化与故障处理</title><link>https://desistdaydream.github.io/docs/10.%E4%BA%91%E5%8E%9F%E7%94%9F/Kubernetes/Kubernetes-%E7%AE%A1%E7%90%86/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E4%B8%8E%E6%95%85%E9%9A%9C%E5%A4%84%E7%90%86/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E4%B8%8E%E6%95%85%E9%9A%9C%E5%A4%84%E7%90%86/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/10.%E4%BA%91%E5%8E%9F%E7%94%9F/Kubernetes/Kubernetes-%E7%AE%A1%E7%90%86/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E4%B8%8E%E6%95%85%E9%9A%9C%E5%A4%84%E7%90%86/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E4%B8%8E%E6%95%85%E9%9A%9C%E5%A4%84%E7%90%86/</guid><description>概述 参考：
为什么 Pod 突然就不见了？ https://mp.weixin.qq.com/s/bbp3OoEF0_Cc1obFBsROSg
创建测试容器 web apiVersion: v1 kind: Service metadata: name: myapp namespace: test labels: app: myapp spec: ipFamilyPolicy: PreferDualStack ipFamilies: - IPv6 - IPv4 ports: - name: http port: 80 targetPort: 80 nodePort: 30080 type: NodePort selector: app: myapp --- apiVersion: apps/v1 kind: Deployment metadata: labels: app: myapp name: myapp namespace: test spec: replicas: 1 selector: matchLabels: app: myapp template: metadata: name: myapp labels: app: myapp spec: containers: - name: myapp-container # image: lchdzh/network-test image: containous/whoami tty: true --- apiVersion: networking.</description></item><item><title>k8s CPU limit和throttling的迷思</title><link>https://desistdaydream.github.io/docs/10.%E4%BA%91%E5%8E%9F%E7%94%9F/Kubernetes/Kubernetes-%E7%AE%A1%E7%90%86/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E4%B8%8E%E6%95%85%E9%9A%9C%E5%A4%84%E7%90%86/k8s-CPU-limit%E5%92%8Cthrottling%E7%9A%84%E8%BF%B7%E6%80%9D/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/10.%E4%BA%91%E5%8E%9F%E7%94%9F/Kubernetes/Kubernetes-%E7%AE%A1%E7%90%86/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E4%B8%8E%E6%95%85%E9%9A%9C%E5%A4%84%E7%90%86/k8s-CPU-limit%E5%92%8Cthrottling%E7%9A%84%E8%BF%B7%E6%80%9D/</guid><description>概述 参考：
原文链接： https://nanmu.me/zh-cn/posts/2021/myth-of-k8s-cpu-limit-and-throttle/ https://mp.weixin.qq.com/s/QYJycJCaxB42xdEo3qHHHA 你应当小心设定 k8s 中负载的 CPU limit，太小的值会给你的程序带来额外的、无意义的延迟，太大的值会带来过大的爆炸半径，削弱集群的整体稳定性。
request 和 limit k8s 的一大好处就是资源隔离，通过设定负载的 request 和 limit，我们可以方便地让不同程序共存于合适的节点上。
其中，request 是给调度看的，调度会确保节点上所有负载的 CPU request 合计与内存 request 合计分别都不大于节点本身能够提供的 CPU 和内存，limit 是给节点（kubelet）看的，节点会保证负载在节点上只使用这么多 CPU 和内存。例如，下面配置意味着单个负载会调度到一个剩余 CPU request 大于 0.1 核，剩余 request 内存大于 200MB 的节点，并且负载运行时的 CPU 使用率不能高于 0.4 核（超过将被限流），内存使用不多余 300MB（超过将被 OOM Kill 并重启）。
resources: requests: memory: 200Mi cpu: &amp;quot;0.1&amp;quot; limits: memory: 300Mi cpu: &amp;quot;0.4&amp;quot;
CPU 的利用率 CPU 和内存不一样，它是量子化的，只有“使用中”和“空闲”两个状态。
我和老婆聊了聊 CPU 和内存的不同，她帮我画了一张插图 图/我的妻子
当我们说内存的使用率是 60%时，我们是在说内存有 60%在空间上已被使用，还有 40%的空间可以放入负载。但是，当我们说 CPU 的某个核的使用率是 60%时，我们是在说采样时间段内，CPU 的这个核在时间上有 60%的时间在忙，40%的时间在睡大觉。</description></item></channel></rss>