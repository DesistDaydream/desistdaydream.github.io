<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>断念梦的站点 – Pod 管理</title><link>https://desistdaydream.github.io/docs/10.%E4%BA%91%E5%8E%9F%E7%94%9F/Kubernetes/Pod/Pod-%E7%AE%A1%E7%90%86/</link><description>Recent content in Pod 管理 on 断念梦的站点</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><atom:link href="https://desistdaydream.github.io/docs/10.%E4%BA%91%E5%8E%9F%E7%94%9F/Kubernetes/Pod/Pod-%E7%AE%A1%E7%90%86/index.xml" rel="self" type="application/rss+xml"/><item><title>Docs: Security Context(安全环境)</title><link>https://desistdaydream.github.io/docs/10.%E4%BA%91%E5%8E%9F%E7%94%9F/Kubernetes/Pod/Pod-%E7%AE%A1%E7%90%86/Security-Context%E5%AE%89%E5%85%A8%E7%8E%AF%E5%A2%83/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/10.%E4%BA%91%E5%8E%9F%E7%94%9F/Kubernetes/Pod/Pod-%E7%AE%A1%E7%90%86/Security-Context%E5%AE%89%E5%85%A8%E7%8E%AF%E5%A2%83/</guid><description>
&lt;h1 id="概述">概述&lt;a class="td-heading-self-link" href="#%e6%a6%82%e8%bf%b0" aria-label="Heading self-link">&lt;/a>&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://kubernetes.io/docs/tasks/configure-pod-container/security-context/">官方文档,任务-配置 Pod 和 Containers&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://mp.weixin.qq.com/s/NFgQrvn_LyU0qQbhMZwDAQ">公众号-阳明&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>&lt;strong>Security Context(安全环境)&lt;/strong> 用来定义 Pod 或 Container 的特权与访问控制设置。 安全上下文包括但不限于：&lt;/p>
&lt;ul>
&lt;li>自主访问控制（Discretionary Access Control）：基于 &lt;a href="https://wiki.archlinux.org/index.php/users_and_groups">用户 ID（UID）和组 ID（GID）&lt;/a>. 来判定对对象（例如文件）的访问权限。&lt;/li>
&lt;li>&lt;a href="https://zh.wikipedia.org/wiki/%E5%AE%89%E5%85%A8%E5%A2%9E%E5%BC%BA%E5%BC%8FLinux">安全性增强的 Linux（SELinux）&lt;/a>： 为对象赋予安全性标签。&lt;/li>
&lt;li>以特权模式或者非特权模式运行。&lt;/li>
&lt;li>&lt;a href="https://linux-audit.com/linux-capabilities-hardening-linux-binaries-by-removing-setuid/">Linux 权能&lt;/a>: 为进程赋予 root 用户的部分特权而非全部特权。&lt;/li>
&lt;li>&lt;a href="https://kubernetes.io/zh/docs/tutorials/clusters/apparmor/">AppArmor&lt;/a>：使用程序框架来限制个别程序的权能。&lt;/li>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Seccomp">Seccomp&lt;/a>：过滤进程的系统调用。&lt;/li>
&lt;li>AllowPrivilegeEscalation：控制进程是否可以获得超出其父进程的特权。 此布尔值直接控制是否为容器进程设置 &lt;code>[no_new_privs](https://www.kernel.org/doc/Documentation/prctl/no_new_privs.txt)&lt;/code>标志。 当容器以特权模式运行或者具有 &lt;code>CAP_SYS_ADMIN&lt;/code> 权能时，AllowPrivilegeEscalation 总是为 true。&lt;/li>
&lt;li>readOnlyRootFilesystem：以只读方式加载容器的根文件系统。&lt;/li>
&lt;/ul>
&lt;p>以上条目不是安全上下文设置的完整列表 &amp;ndash; 请参阅 &lt;a href="https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.20/#securitycontext-v1-core">SecurityContext&lt;/a> 了解其完整列表。
关于在 Linux 系统中的安全机制的更多信息，可参阅 &lt;a href="https://www.linux.com/learn/overview-linux-kernel-security-features">Linux 内核安全性能力概述&lt;/a>。&lt;/p>
&lt;p>特别注意：限制自由，会产生很多问题，比如：&lt;/p>
&lt;ul>
&lt;li>使用 hostPath 类型的 volume 时，如果容器不以 root 用户运行，则无法对 hostPath 所在目录执行操作，任何写操作将会提示权限不够。因为目录权限 755&lt;/li>
&lt;/ul>
&lt;h1 id="应该了解的-10-个-kubernetes-安全上下文配置">应该了解的 10 个 Kubernetes 安全上下文配置&lt;a class="td-heading-self-link" href="#%e5%ba%94%e8%af%a5%e4%ba%86%e8%a7%a3%e7%9a%84-10-%e4%b8%aa-kubernetes-%e5%ae%89%e5%85%a8%e4%b8%8a%e4%b8%8b%e6%96%87%e9%85%8d%e7%bd%ae" aria-label="Heading self-link">&lt;/a>&lt;/h1>
&lt;p>在 Kubernetes 中安全地运行工作负载是很困难的，有很多配置都可能会影响到整个 Kubernetes API 的安全性，这需要我们有大量的知识积累来正确的实施。Kubernetes 在安全方面提供了一个强大的工具 securityContext，每个 Pod 和容器清单都可以使用这个属性。在本文中我们将了解各种 securityContext 的配置，探讨它们的含义，以及我们应该如何使用它们。
securityContext 设置在 PodSpec 和 ContainerSpec 规范中都有定义，这里我们分别用[P]和[C]来表示。需要注意的是，如果一个设置在两个作用域中都可以使用和配置，那么我们应该优先考虑设置容器级别的。&lt;/p>
&lt;h2 id="1runasnonroot-pc">1runAsNonRoot [P/C]&lt;a class="td-heading-self-link" href="#1runasnonroot-pc" aria-label="Heading self-link">&lt;/a>&lt;/h2>
&lt;p>我们知道容器是使用 namespaces 和 cgroups 来限制其进程，但只要在部署的时候做了一次错误的配置，就可以让这些进程访问主机上的资源。如果该进程以 root 身份运行，它对这些资源的访问权限与主机 root 账户是相同的。此外，如果其他 pod 或容器设置被用来减少约束（比如 procMount 或 capabilities），拥有一个 root UID 就会提高风险，除非你有一个非常好的原因，否则你不应该以 root 身份运行一个容器。
那么，如果你有一个使用 root 的镜像需要部署，那应该怎么办呢？&lt;/p>
&lt;h3 id="11-使用基础镜像中提供的用户">1.1 使用基础镜像中提供的用户&lt;a class="td-heading-self-link" href="#11-%e4%bd%bf%e7%94%a8%e5%9f%ba%e7%a1%80%e9%95%9c%e5%83%8f%e4%b8%ad%e6%8f%90%e4%be%9b%e7%9a%84%e7%94%a8%e6%88%b7" aria-label="Heading self-link">&lt;/a>&lt;/h3>
&lt;p>通常情况下，基础镜像已经创建并提供了一个用户，例如，官方的 Node.js 镜像带有一个 UID 为 1000 的名为 node 的用户，我们就可以使用该身份来运行容器，但他们并没有在 Dockerfile 中明确地设置当前用户。我们可以在运行时用 runAsUser 设置来配置它，或者用自定义的 Dockerfile 来更改镜像中的当前用户。这里我们来看看使用自定义的 Dockerfile 来构建我们自己的镜像的例子。
在不深入了解镜像构建的情况下，让我们假设我们有一个预先构建好的 npm 应用程序。这里是一个最小的 Dockerfile 文件，用来构建一个基于 node:slim 的镜像，并以提供的 node 用户身份运行。
FROM node:slim
COPY &amp;ndash;chown=node . /home/node/app/   &lt;em># &amp;lt;&amp;mdash; Copy app into the home directory with right ownership&lt;/em>
USER 1000                             &lt;em># &amp;lt;&amp;mdash; Switch active user to “node” (by UID)&lt;/em>
WORKDIR /home/node/app                &lt;em># &amp;lt;&amp;mdash; Switch current directory to app&lt;/em>
ENTRYPOINT [&amp;ldquo;npm&amp;rdquo;, &amp;ldquo;start&amp;rdquo;]           &lt;em># &amp;lt;&amp;mdash; This will now exec as the “node” user instead of root&lt;/em>&lt;/p>
&lt;p>其中以 USER 开头的一行就是关键设置，这使得 node 成为从这个镜像启动的任何容器里面的默认用户。我们使用 UID 而不是用户的名字，因为 Kubernetes 无法在启动容器前将镜像的默认用户名映射到 UID 上，并且在部署时指定 runAsNotRoot: true，会返回有关错误。&lt;/p>
&lt;h3 id="12-基础镜像没有提供用户">1.2 基础镜像没有提供用户&lt;a class="td-heading-self-link" href="#12-%e5%9f%ba%e7%a1%80%e9%95%9c%e5%83%8f%e6%b2%a1%e6%9c%89%e6%8f%90%e4%be%9b%e7%94%a8%e6%88%b7" aria-label="Heading self-link">&lt;/a>&lt;/h3>
&lt;p>如果我们使用的基础镜像没有提供一个可以使用的用户，那么我们又应该怎么做呢？对于大部分进程来说，我们只需在自定义的 Dockerfile 中创建一个用户并使用它即可。如下所示：
FROM node:slim
RUN useradd somebody -u 10001 &amp;ndash;create-home &amp;ndash;user-group  &lt;em># &amp;lt;&amp;mdash; Create a user&lt;/em>
COPY &amp;ndash;chown=somebody . /home/somebody/app/
USER 10001
WORKDIR /home/somebody/app
ENTRYPOINT [&amp;ldquo;npm&amp;rdquo;, &amp;ldquo;start&amp;rdquo;]&lt;/p>
&lt;p>这里我们增加了一行创建用户的 RUN 命令即可。不过需要注意的是这对于 node.js 和 npm 来说，这很好用，但是其他工具可能需要文件系统的不同元素进行所有权变更。如果遇到任何问题，需要查阅对应工具的文档。&lt;/p>
&lt;h2 id="2runasuserrunasgroup-pc">2runAsUser/runAsGroup [P/C]&lt;a class="td-heading-self-link" href="#2runasuserrunasgroup-pc" aria-label="Heading self-link">&lt;/a>&lt;/h2>
&lt;p>容器镜像可能有一个特定的用户或组，我们可以用 runAsUser 和 runAsGroup 来进行覆盖。通常，这些设置与包含具有相同所有权 ID 的文件的卷挂载结合在一起。
&amp;hellip;.
spec:
  containers:
    - name: web
      image: mycorp/webapp:1.2.3
  securityContext:
    runAsNonRoot: true
    runAsUser: 10001
&amp;hellip;.&lt;/p>
&lt;p>不过使用这些配置也是有风险的，因为你为容器做出的运行时决定可能与原始镜像不兼容。例如，jenkins/jenkins 镜像以名为 jenkins:jenkins 的&lt;strong>组:用户&lt;/strong>身份运行，其应用文件全部由该用户拥有。如果我们配置一个不同的用户，它将无法启动，因为该用户不存在于镜像的/etc/passwd 文件中。即使它以某种方式存在，它也很可能在读写 jenkins:jenkins 拥有的文件时出现问题。我们可以用一个简单的 docker 运行命令来验证这个问题。
$ docker run &amp;ndash;rm -it -u eric:eric jenkins/jenkins
docker: Error response from daemon: unable to find user eric: no matching entries in passwd file.&lt;/p>
&lt;p>上面我们提到确保容器进程不以 root 用户身份运行是一个非常好的主意，但不要依赖 runAsUser 或 runAsGroup 设置来保证这一点，未来有人可能会删除这些配置，请确保同时将 runAsNonRoot 设置为 true。&lt;/p>
&lt;h2 id="3selinuxoptions-pc">3seLinuxOptions [P/C]&lt;a class="td-heading-self-link" href="#3selinuxoptions-pc" aria-label="Heading self-link">&lt;/a>&lt;/h2>
&lt;p>SELinux 是一个用于控制对 Linux 系统上的应用、进程和文件进行访问的策略驱动系统，它在 Linux 内核中实现了 Linux 安全模块框架。SELinux 是基于标签的策略，它将一些标签应用于系统中的所有元素，然后将元素进行分组。这些标签被称为&lt;strong>安全上下文&lt;/strong>（不要和 Kubernetes 中的 securityContext 混淆了）- 由用户、角色、类型和可选的一些其他属性组成，格式为：user:role:type:level。
然后，SELinux 使用策略来定义特定上下文中的哪些进程可以访问系统中其他被标记的对象。SELinux 可以是严格执行 enforced 模式，在这种情况下，访问将被拒绝，如果被配置为允许的 permissive 模式，那么安全策略没有被强制执行，当安全策略规则应该拒绝访问时，访问仍然被允许，然而，此时会向日志文件发送一条消息，表示该访问应该被拒绝。在容器中，SELinux 通常给容器进程和容器镜像打上标签，以限制该进程只能访问镜像中的文件。
默认的 SELinux 策略将在实例化容器时由容器运行时应用，securityContext 中的 seLinuxOptions 允许配置自定义的 SELinux 策略标签，请注意，改变容器的 SELinux 策略标签有可能允许容器进程摆脱容器镜像并访问主机文件系统。
当然只有当宿主机操作系统支持 SELinux 时，这个功能才会起作用。&lt;/p>
&lt;h2 id="4seccompprofile-pc">4seccompProfile [P/C]&lt;a class="td-heading-self-link" href="#4seccompprofile-pc" aria-label="Heading self-link">&lt;/a>&lt;/h2>
&lt;p>Seccomp 表示一种安全计算模式，是 Linux 内核的一项功能，它可以限制一个特定进程从用户空间到内核的调用。seccomp 配置文件是使用一个 JSON 文件进行定义的，通常由一组系统调用和发生这些系统调用时的默认动作组成。如下配置所示：
{
    &amp;ldquo;defaultAction&amp;rdquo;: &amp;ldquo;SCMP_ACT_ERRNO&amp;rdquo;,
    &amp;ldquo;architectures&amp;rdquo;: [
        &amp;ldquo;SCMP_ARCH_X86_64&amp;rdquo;,
        &amp;ldquo;SCMP_ARCH_X86&amp;rdquo;,
        &amp;ldquo;SCMP_ARCH_X32&amp;rdquo;
    ],
    &amp;ldquo;syscalls&amp;rdquo;: [
        {
            &amp;ldquo;name&amp;rdquo;: &amp;ldquo;accept&amp;rdquo;,
            &amp;ldquo;action&amp;rdquo;: &amp;ldquo;SCMP_ACT_ALLOW&amp;rdquo;,
            &amp;ldquo;args&amp;rdquo;: []
        },
        {
            &amp;ldquo;name&amp;rdquo;: &amp;ldquo;accept4&amp;rdquo;,
            &amp;ldquo;action&amp;rdquo;: &amp;ldquo;SCMP_ACT_ALLOW&amp;rdquo;,
            &amp;ldquo;args&amp;rdquo;: []
        },
        &amp;hellip;
    ]
}&lt;/p>
&lt;p>Kubernetes 通过在 securityContext 中的 seccompProfile 属性来提供一个使用自定义配置文件的机制。
seccompProfile:
  type: Localhost
  localhostProfile: profiles/myprofile.json&lt;/p>
&lt;p>这里配置的 type 字段有三个可选的值：&lt;/p>
&lt;ul>
&lt;li>Localhost：其中 localhostProfile 配置为容器内的 seccomp 配置文件路径。&lt;/li>
&lt;li>Unconfined：其中没有配置文件。&lt;/li>
&lt;li>RuntimeDefault：其中使用容器运行时的默认值&amp;ndash;如果没有指定类型，就是默认值。&lt;/li>
&lt;/ul>
&lt;p>我们可以在 PodSecurityContext 或 securityContext 中使用这些配置，如果两者都配置了，就会使用容器级别中的配置。
此外与大多数安全相关的设置一样，&lt;strong>最小权限原则&lt;/strong>在此同样适用。只给你的容器访问它所需要的权限即可。首先创建一个配置文件，简单地记录哪些系统调用正在发生，然后测试你的应用程序，建立一套允许的系统调用规则。我们可以在 Kubernetes 教程(&lt;a href="https://kubernetes.io/docs/tutorials/clusters/seccomp">https://kubernetes.io/docs/tutorials/clusters/seccomp&lt;/a>)中找到关于Seccomp的更多信息。&lt;/p>
&lt;h2 id="5-避免使用特权容器-c">5 避免使用特权容器 [C]&lt;a class="td-heading-self-link" href="#5-%e9%81%bf%e5%85%8d%e4%bd%bf%e7%94%a8%e7%89%b9%e6%9d%83%e5%ae%b9%e5%99%a8-c" aria-label="Heading self-link">&lt;/a>&lt;/h2>
&lt;p>给容器授予特权模式是非常危险的，一般会有一种更简单的方式来实现特定的权限，或者可以通过授予 Linux Capabilities 权限来控制。容器运行时控制器着特权模式的具体实现，但是它会授予容器所有的特权，并解除由 cgroup 控制器执行的限制，它还可以修改 Linux 安全模块的配置，并允许容器内的进程逃离容器。
容器在宿主机中提供了进程隔离，所以即使容器是使用 root 身份运行的，也有容器运行时不授予容器的 Capabilities。如果配置了特权模式，容器运行时就会授予系统 root 的所有能力，从安全角度来看，这是很危险的，因为它允许对底层宿主机系统的所有操作访问。
避免使用特权模式，如果你的容器确实需要额外的能力，只需通过添加 capabilities 来满足你的需求。除非你的容器需要控制主机内核中的系统级设置，如访问特定的硬件或重新配置网络，并且需要访问主机文件系统，那么它就不需要特权模式。&lt;/p>
&lt;h2 id="6linux-capabilities-c">6Linux Capabilities [C]&lt;a class="td-heading-self-link" href="#6linux-capabilities-c" aria-label="Heading self-link">&lt;/a>&lt;/h2>
&lt;p>Capabilities 是一个内核级别的权限，它允许对内核调用权限进行更细粒度的控制，而不是简单地以 root 身份运行。Capabilities 包括更改文件权限、控制网络子系统和执行系统管理等功能。在 securityContext 中，Kubernetes 可以添加或删除 Capabilities，单个 Capabilities 或逗号分隔的列表可以作为一个字符串数组进行配置。另外，我们也可以使用 all 来添加或删除所有的配置。这种配置会被传递给容器运行时，在它创建容器的时候会配置上 Capabilities 集合，如果 securityContext 中没有配置，那么容器将会直接容器运行时提供的所有默认配置。
securityContext:
  capabilities:
    drop:
      - all
    add: [&amp;ldquo;MKNOD&amp;rdquo;]&lt;/p>
&lt;p>一般推荐的做法是先删除所有的配置，然后只添加你的应用程序实际需要的，在大部分情况下，应用程序在正常运行中实际上不需要任何 Capabilities，通过删除所有配置来测试，并通过监控审计日志来调试问题，看看哪些功能被阻止了。
请注意，当在 securityContext 中列出要放弃或添加的 Capabilities 时，你要删除内核在命名 Capabilities 时使用的 CAP_前缀。capsh 工具可以给我们一个比较友好的调试信息，可以来说明你的容器中到底启用了哪些 Capabilities，当然不要在生产容器中使用这个工具，因为这使得攻击者很容易弄清楚哪些 Capabilities 被启用了。&lt;/p>
&lt;h2 id="7-以只读文件系统运行-c">7 以只读文件系统运行 [C]&lt;a class="td-heading-self-link" href="#7-%e4%bb%a5%e5%8f%aa%e8%af%bb%e6%96%87%e4%bb%b6%e7%b3%bb%e7%bb%9f%e8%bf%90%e8%a1%8c-c" aria-label="Heading self-link">&lt;/a>&lt;/h2>
&lt;p>如果你的容器被入侵，而且它有一个可读写的文件系统，那么攻击者就可以随意地改变它的配置、安装软件，并有可能启动其他的漏洞。拥有一个只读的文件系统有助于防止这些类型的安全问题，因为它限制了攻击者可以执行的操作。一般来说，容器不应该要求对容器文件系统进行写入，如果你的应用程序是有状态数据，那么你应该使用外部持久化方法，如数据库、volume 或其他一些服务。另外，确保所有的日志都写到 stdout 或日志转发器上。&lt;/p>
&lt;h2 id="8procmount-c">8procMount [C]&lt;a class="td-heading-self-link" href="#8procmount-c" aria-label="Heading self-link">&lt;/a>&lt;/h2>
&lt;p>默认情况下，为了防止潜在的安全问题，容器运行时会屏蔽容器内/proc 文件系统的某些部分文件。然而有时需要访问/proc 的这些文件，特别是在使用嵌套容器时，因为它经常被用作集群内构建过程的一部分。该配置只有两个有效的选项：&lt;/p>
&lt;ul>
&lt;li>Default：保持标准的容器运行时行为&lt;/li>
&lt;li>Unmasked：它删除/proc 文件系统的所有屏蔽行为&lt;/li>
&lt;/ul>
&lt;p>显然只有当我们知道在做什么的时候才应该使用这个配置，如果你是为了构建镜像而使用它，请检查构建工具的最新版本，因为许多工具不再需要这个设置了，最好升级下工具并设置为 Default 默认的 procMount。&lt;/p>
&lt;h2 id="9fsgroupfsgroupchangepolicy-p">9fsGroup/fsGroupChangePolicy [P]&lt;a class="td-heading-self-link" href="#9fsgroupfsgroupchangepolicy-p" aria-label="Heading self-link">&lt;/a>&lt;/h2>
&lt;p>fsGroup 设置定义了一个组，当卷被 pod 挂载时，Kubernetes 将把卷中所有文件的权限改为该组。这里的行为也由 fsGroupChangePolicy 控制，它可以被设置为 onRootMismatch 或 Always。如果设置为 onRootMismatch 则只有当权限与容器 root 的权限不匹配时才会被改变。
不过在使用 fsGroup 时也要慎重，改变整个 volume 卷的组所有权会导致&lt;strong>变慢&lt;/strong>，如果是大型文件系统&lt;strong>启动也会延迟&lt;/strong>。如果共享同一卷的其他进程没有对新的 GID 的访问权限，它也会对这些进程造成损害。由于这个原因，一些共享文件系统如 NFS，没有实现这个功能。这些设置也不影响临时的 ephemeral 卷。&lt;/p>
&lt;h2 id="10sysctls-p">10sysctls [P]&lt;a class="td-heading-self-link" href="#10sysctls-p" aria-label="Heading self-link">&lt;/a>&lt;/h2>
&lt;p>Sysctls 是 Linux 内核的一个功能，它允许管理员修改内核配置。在一个完整的 Linux 操作系统中，这些是通过使用/etc/sysctl.conf 定义的，也可以使用 sysctl 工具进行修改。
securityContext 中的 sysctls 配置允许在容器中修改特定的 sysctls。只有一小部分的 sysctls 可以在每个容器的基础上进行修改，它们都在内核中被命名的。在这个可以配置的子集中，有些被认为是安全的，而更多的则被认为是不安全的，这取决于对其他 pod 的潜在影响。在集群中，不安全的 sysctls 通常是被禁用，需要由集群管理员专门开启。
鉴于有可能破坏底层操作系统的稳定，除非你有非常特殊的要求，否则应该避免通过 sysctls 修改内核参数。&lt;/p>
&lt;h2 id="11-总结">11 总结&lt;a class="td-heading-self-link" href="#11-%e6%80%bb%e7%bb%93" aria-label="Heading self-link">&lt;/a>&lt;/h2>
&lt;p>在用 securityContext 加固你的应用时，有很多事情需要注意。如果使用得当，它们是一种非常有效的工具，我们希望这个列表能帮助你的团队为你的工作负载和环境进行正确的安全配置。&lt;/p></description></item><item><title>Docs: 访问 Pod</title><link>https://desistdaydream.github.io/docs/10.%E4%BA%91%E5%8E%9F%E7%94%9F/Kubernetes/Pod/Pod-%E7%AE%A1%E7%90%86/%E8%AE%BF%E9%97%AE-Pod/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/10.%E4%BA%91%E5%8E%9F%E7%94%9F/Kubernetes/Pod/Pod-%E7%AE%A1%E7%90%86/%E8%AE%BF%E9%97%AE-Pod/</guid><description>
&lt;h1 id="概述">概述&lt;a class="td-heading-self-link" href="#%e6%a6%82%e8%bf%b0" aria-label="Heading self-link">&lt;/a>&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://jimmysong.io/kubernetes-handbook/guide/accessing-kubernetes-pods-from-outside-of-the-cluster.html">原文，jimmysong.io kubernetes 手书，指南-从集群外部访问 Pod &lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>本文主要讲解访问 kubenretes 中的 Pod 和 Serivce 的集中方式，包括如下几种：&lt;/p>
&lt;ul>
&lt;li>hostNetwork&lt;/li>
&lt;li>hostPort&lt;/li>
&lt;li>NodePort&lt;/li>
&lt;li>LoadBalancer&lt;/li>
&lt;li>Ingress&lt;/li>
&lt;/ul>
&lt;p>说是暴露 Pod 其实跟暴露 Service 是一回事，因为 Pod 就是 Service 的 backend。&lt;/p>
&lt;h1 id="hostnetwork-true">hostNetwork: true&lt;a class="td-heading-self-link" href="#hostnetwork-true" aria-label="Heading self-link">&lt;/a>&lt;/h1>
&lt;p>这是一种直接定义 Pod 网络的方式。&lt;/p>
&lt;p>如果在 Pod 中使用 hostNetwork:true 配置的话，在这种 pod 中运行的应用程序可以直接看到 pod 启动的主机的网络接口。在主机的所有网络接口上都可以访问到该应用程序。以下是使用主机网络的 pod 的示例定义：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-yaml" data-lang="yaml">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#204a87;font-weight:bold">apiVersion&lt;/span>&lt;span style="color:#000;font-weight:bold">:&lt;/span>&lt;span style="color:#f8f8f8;text-decoration:underline"> &lt;/span>&lt;span style="color:#000">v1&lt;/span>&lt;span style="color:#f8f8f8;text-decoration:underline">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f8f8f8;text-decoration:underline">&lt;/span>&lt;span style="color:#204a87;font-weight:bold">kind&lt;/span>&lt;span style="color:#000;font-weight:bold">:&lt;/span>&lt;span style="color:#f8f8f8;text-decoration:underline"> &lt;/span>&lt;span style="color:#000">Pod&lt;/span>&lt;span style="color:#f8f8f8;text-decoration:underline">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f8f8f8;text-decoration:underline">&lt;/span>&lt;span style="color:#204a87;font-weight:bold">metadata&lt;/span>&lt;span style="color:#000;font-weight:bold">:&lt;/span>&lt;span style="color:#f8f8f8;text-decoration:underline">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f8f8f8;text-decoration:underline"> &lt;/span>&lt;span style="color:#204a87;font-weight:bold">name&lt;/span>&lt;span style="color:#000;font-weight:bold">:&lt;/span>&lt;span style="color:#f8f8f8;text-decoration:underline"> &lt;/span>&lt;span style="color:#000">influxdb&lt;/span>&lt;span style="color:#f8f8f8;text-decoration:underline">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f8f8f8;text-decoration:underline">&lt;/span>&lt;span style="color:#204a87;font-weight:bold">spec&lt;/span>&lt;span style="color:#000;font-weight:bold">:&lt;/span>&lt;span style="color:#f8f8f8;text-decoration:underline">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f8f8f8;text-decoration:underline"> &lt;/span>&lt;span style="color:#204a87;font-weight:bold">hostNetwork&lt;/span>&lt;span style="color:#000;font-weight:bold">:&lt;/span>&lt;span style="color:#f8f8f8;text-decoration:underline"> &lt;/span>&lt;span style="color:#204a87;font-weight:bold">true&lt;/span>&lt;span style="color:#f8f8f8;text-decoration:underline">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f8f8f8;text-decoration:underline"> &lt;/span>&lt;span style="color:#204a87;font-weight:bold">containers&lt;/span>&lt;span style="color:#000;font-weight:bold">:&lt;/span>&lt;span style="color:#f8f8f8;text-decoration:underline">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f8f8f8;text-decoration:underline"> &lt;/span>- &lt;span style="color:#204a87;font-weight:bold">name&lt;/span>&lt;span style="color:#000;font-weight:bold">:&lt;/span>&lt;span style="color:#f8f8f8;text-decoration:underline"> &lt;/span>&lt;span style="color:#000">influxdb&lt;/span>&lt;span style="color:#f8f8f8;text-decoration:underline">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f8f8f8;text-decoration:underline"> &lt;/span>&lt;span style="color:#204a87;font-weight:bold">image&lt;/span>&lt;span style="color:#000;font-weight:bold">:&lt;/span>&lt;span style="color:#f8f8f8;text-decoration:underline"> &lt;/span>&lt;span style="color:#000">influxdb&lt;/span>&lt;span style="color:#f8f8f8;text-decoration:underline">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>部署该 Pod：&lt;/p>
&lt;pre tabindex="0">&lt;code>$ kubectl create -f influxdb-hostnetwork.yml
&lt;/code>&lt;/pre>&lt;p>访问该 pod 所在主机的 8086 端口：&lt;/p>
&lt;pre tabindex="0">&lt;code>curl -v http://$POD_IP:8086/ping
&lt;/code>&lt;/pre>&lt;p>将看到 204 No Content 的 204 返回码，说明可以正常访问。&lt;/p>
&lt;p>注意每次启动这个 Pod 的时候都可能被调度到不同的节点上，所有外部访问 Pod 的 IP 也是变化的，而且调度 Pod 的时候还需要考虑是否与宿主机上的端口冲突，因此一般情况下除非您知道需要某个特定应用占用特定宿主机上的特定端口时才使用 hostNetwork: true 的方式。&lt;/p>
&lt;p>这种 Pod 的网络模式有一个用处就是可以将网络插件包装在 Pod 中然后部署在每个宿主机上，这样该 Pod 就可以控制该宿主机上的所有网络。&lt;/p>
&lt;p>这种网络方式可以用来做 nginx Ingress controller。外部流量都需要通过 kubenretes node 节点的 80 和 443 端口。&lt;/p>
&lt;h1 id="hostport">hostPort&lt;a class="td-heading-self-link" href="#hostport" aria-label="Heading self-link">&lt;/a>&lt;/h1>
&lt;p>这是一种直接定义 Pod 网络的方式。&lt;/p>
&lt;p>hostPort 是直接将容器的端口与所调度的节点上的端口路由，这样用户就可以通过宿主机的 IP 加上来访问 Pod 了，如:。&lt;/p>
&lt;pre>&lt;code>apiVersion: v1
kind: Pod
metadata:
name: influxdb
spec:
containers:
-name: influxdb
image: influxdb
ports:
- containerPort:8086
hostPort:8086
&lt;/code>&lt;/pre>
&lt;p>这样做有个缺点，因为 Pod 重新调度的时候该 Pod 被调度到的宿主机可能会变动，这样就变化了，用户必须自己维护一个 Pod 与所在宿主机的对应关系&lt;/p>
&lt;h1 id="nodeport">NodePort&lt;a class="td-heading-self-link" href="#nodeport" aria-label="Heading self-link">&lt;/a>&lt;/h1>
&lt;p>NodePort 在 kubenretes 里是一个广泛应用的服务暴露方式。Kubernetes 中的 service 默认情况下都是使用的 ClusterIP 这种类型，这样的 service 会产生一个 ClusterIP，这个 IP 只能在集群内部访问，要想让外部能够直接访问 service，需要将 service type 修改为 nodePort。&lt;/p>
&lt;pre>&lt;code>apiVersion: v1
kind: Pod
metadata:
name: influxdb
labels:
name: influxdb
spec:
containers:
- name: influxdb
image: influxdb
ports:
- containerPort:8086
&lt;/code>&lt;/pre>
&lt;p>同时还可以给 service 指定一个 nodePort 值，范围是 30000-32767，这个值在 API server 的配置文件中，用&amp;ndash;service-node-port-range 定义。&lt;/p>
&lt;pre>&lt;code>kind: Service
apiVersion: v1
metadata:
name: influxdb
spec:
type: NodePort
ports:
- port:8086
nodePort:30000
selector:
name: influxdb
&lt;/code>&lt;/pre>
&lt;p>集群外就可以使用 kubernetes 任意一个节点的 IP 加上 30000 端口访问该服务了。kube-proxy 会自动将流量以 round-robin 的方式转发给该 service 的每一个 pod。&lt;/p>
&lt;p>这种服务暴露方式，无法让你指定自己想要的应用常用端口，不过可以在集群上再部署一个反向代理作为流量入口。&lt;/p>
&lt;h1 id="loadbalancer">LoadBalancer&lt;a class="td-heading-self-link" href="#loadbalancer" aria-label="Heading self-link">&lt;/a>&lt;/h1>
&lt;p>LoadBalancer 只能在 service 上定义。这是公有云提供的负载均衡器，如 AWS、Azure、CloudStack、GCE 等。&lt;/p>
&lt;pre>&lt;code>kind: Service
apiVersion: v1
metadata:
name: influxdb
spec:
type: LoadBalancer
ports:
- port:8086
selector:
name: influxdb
&lt;/code>&lt;/pre>
&lt;p>查看服务：&lt;/p>
&lt;pre>&lt;code>$ kubectl get svc influxdb
NAME CLUSTER-IP EXTERNAL-IP PORT(S)
AGEinfluxdb 10.97.121.42 10.13.242.236 8086:30051/TCP 39s
&lt;/code>&lt;/pre>
&lt;p>内部可以使用 ClusterIP 加端口来访问服务，如 19.97.121.42:8086。&lt;/p>
&lt;p>外部可以用以下两种方式访问该服务：&lt;/p>
&lt;ul>
&lt;li>使用任一节点的 IP 加 30051 端口访问该服务&lt;/li>
&lt;li>使用 EXTERNAL-IP 来访问，这是一个 VIP，是云供应商提供的负载均衡器 IP，如 10.13.242.236:8086。&lt;/li>
&lt;/ul>
&lt;h1 id="ingress">Ingress&lt;a class="td-heading-self-link" href="#ingress" aria-label="Heading self-link">&lt;/a>&lt;/h1>
&lt;p>Ingress 是自 kubernetes1.1 版本后引入的资源类型。必须要部署 Ingress controller 才能创建 Ingress 资源，Ingress controller 是以一种插件的形式提供。Ingress controller 是部署在 Kubernetes 之上的 Docker 容器。它的 Docker 镜像包含一个像 nginx 或 HAProxy 的负载均衡器和一个控制器守护进程。控制器守护程序从 Kubernetes 接收所需的 Ingress 配置。它会生成一个 nginx 或 HAProxy 配置文件，并重新启动负载平衡器进程以使更改生效。换句话说，Ingress controller 是由 Kubernetes 管理的负载均衡器。&lt;/p>
&lt;p>Kubernetes Ingress 提供了负载平衡器的典型特性：HTTP 路由，粘性会话，SSL 终止，SSL 直通，TCP 和 UDP 负载平衡等。目前并不是所有的 Ingress controller 都实现了这些功能，需要查看具体的 Ingress controller 文档。&lt;/p>
&lt;p>外部访问 URL &lt;a href="http://influxdb.kube.example.com/ping">http://influxdb.kube.example.com/ping&lt;/a> 访问该服务，入口就是 80 端口，然后 Ingress controller 直接将流量转发给后端 Pod，不需再经过 kube-proxy 的转发，比 LoadBalancer 方式更高效。&lt;/p>
&lt;h1 id="总结">总结&lt;a class="td-heading-self-link" href="#%e6%80%bb%e7%bb%93" aria-label="Heading self-link">&lt;/a>&lt;/h1>
&lt;p>总的来说 Ingress 是一个非常灵活和越来越得到厂商支持的服务暴露方式，包括 Nginx、HAProxy、Traefik，还有各种 Service Mesh，而其它服务暴露方式可以更适用于服务调试、特殊应用的部署。&lt;/p>
&lt;h1 id="参考">参考&lt;a class="td-heading-self-link" href="#%e5%8f%82%e8%80%83" aria-label="Heading self-link">&lt;/a>&lt;/h1>
&lt;p>&lt;a href="http://alesnosek.com/blog/2017/02/14/accessing-kubernetes-pods-from-outside-of-the-cluster/">Accessing Kubernetes Pods from Outside of the Cluster - alesnosek.com&lt;/a>&lt;/p></description></item><item><title>Docs: 为 Pod 注入数据</title><link>https://desistdaydream.github.io/docs/10.%E4%BA%91%E5%8E%9F%E7%94%9F/Kubernetes/Pod/Pod-%E7%AE%A1%E7%90%86/%E4%B8%BA-Pod-%E6%B3%A8%E5%85%A5%E6%95%B0%E6%8D%AE/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/10.%E4%BA%91%E5%8E%9F%E7%94%9F/Kubernetes/Pod/Pod-%E7%AE%A1%E7%90%86/%E4%B8%BA-Pod-%E6%B3%A8%E5%85%A5%E6%95%B0%E6%8D%AE/</guid><description>
&lt;h1 id="概述">概述&lt;a class="td-heading-self-link" href="#%e6%a6%82%e8%bf%b0" aria-label="Heading self-link">&lt;/a>&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://kubernetes.io/docs/tasks/inject-data-application/">官方文档, 任务 - 给应用注入数据&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;h1 id="将-pod-的-manifests-信息映射到容器中的环境变量上">将 Pod 的 Manifests 信息映射到容器中的环境变量上&lt;a class="td-heading-self-link" href="#%e5%b0%86-pod-%e7%9a%84-manifests-%e4%bf%a1%e6%81%af%e6%98%a0%e5%b0%84%e5%88%b0%e5%ae%b9%e5%99%a8%e4%b8%ad%e7%9a%84%e7%8e%af%e5%a2%83%e5%8f%98%e9%87%8f%e4%b8%8a" aria-label="Heading self-link">&lt;/a>&lt;/h1>
&lt;h2 id="用-pod-字段作为环境变量的值">用 Pod 字段作为环境变量的值&lt;a class="td-heading-self-link" href="#%e7%94%a8-pod-%e5%ad%97%e6%ae%b5%e4%bd%9c%e4%b8%ba%e7%8e%af%e5%a2%83%e5%8f%98%e9%87%8f%e7%9a%84%e5%80%bc" aria-label="Heading self-link">&lt;/a>&lt;/h2>
&lt;p>在这个练习中，你将创建一个包含一个容器的 Pod。这是该 Pod 的配置文件：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-yaml" data-lang="yaml">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#204a87;font-weight:bold">apiVersion&lt;/span>&lt;span style="color:#000;font-weight:bold">:&lt;/span>&lt;span style="color:#f8f8f8;text-decoration:underline"> &lt;/span>&lt;span style="color:#000">v1&lt;/span>&lt;span style="color:#f8f8f8;text-decoration:underline">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f8f8f8;text-decoration:underline">&lt;/span>&lt;span style="color:#204a87;font-weight:bold">kind&lt;/span>&lt;span style="color:#000;font-weight:bold">:&lt;/span>&lt;span style="color:#f8f8f8;text-decoration:underline"> &lt;/span>&lt;span style="color:#000">Pod&lt;/span>&lt;span style="color:#f8f8f8;text-decoration:underline">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f8f8f8;text-decoration:underline">&lt;/span>&lt;span style="color:#204a87;font-weight:bold">metadata&lt;/span>&lt;span style="color:#000;font-weight:bold">:&lt;/span>&lt;span style="color:#f8f8f8;text-decoration:underline">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f8f8f8;text-decoration:underline"> &lt;/span>&lt;span style="color:#204a87;font-weight:bold">name&lt;/span>&lt;span style="color:#000;font-weight:bold">:&lt;/span>&lt;span style="color:#f8f8f8;text-decoration:underline"> &lt;/span>&lt;span style="color:#000">dapi-envars-fieldref&lt;/span>&lt;span style="color:#f8f8f8;text-decoration:underline">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f8f8f8;text-decoration:underline">&lt;/span>&lt;span style="color:#204a87;font-weight:bold">spec&lt;/span>&lt;span style="color:#000;font-weight:bold">:&lt;/span>&lt;span style="color:#f8f8f8;text-decoration:underline">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f8f8f8;text-decoration:underline"> &lt;/span>&lt;span style="color:#204a87;font-weight:bold">containers&lt;/span>&lt;span style="color:#000;font-weight:bold">:&lt;/span>&lt;span style="color:#f8f8f8;text-decoration:underline">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f8f8f8;text-decoration:underline"> &lt;/span>- &lt;span style="color:#204a87;font-weight:bold">name&lt;/span>&lt;span style="color:#000;font-weight:bold">:&lt;/span>&lt;span style="color:#f8f8f8;text-decoration:underline"> &lt;/span>&lt;span style="color:#000">test-container&lt;/span>&lt;span style="color:#f8f8f8;text-decoration:underline">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f8f8f8;text-decoration:underline"> &lt;/span>&lt;span style="color:#204a87;font-weight:bold">image&lt;/span>&lt;span style="color:#000;font-weight:bold">:&lt;/span>&lt;span style="color:#f8f8f8;text-decoration:underline"> &lt;/span>&lt;span style="color:#000">k8s.gcr.io/busybox&lt;/span>&lt;span style="color:#f8f8f8;text-decoration:underline">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f8f8f8;text-decoration:underline"> &lt;/span>&lt;span style="color:#204a87;font-weight:bold">command&lt;/span>&lt;span style="color:#000;font-weight:bold">:&lt;/span>&lt;span style="color:#f8f8f8;text-decoration:underline"> &lt;/span>&lt;span style="color:#000;font-weight:bold">[&lt;/span>&lt;span style="color:#4e9a06">&amp;#34;sh&amp;#34;&lt;/span>&lt;span style="color:#000;font-weight:bold">,&lt;/span>&lt;span style="color:#f8f8f8;text-decoration:underline"> &lt;/span>&lt;span style="color:#4e9a06">&amp;#34;-c&amp;#34;&lt;/span>&lt;span style="color:#000;font-weight:bold">]&lt;/span>&lt;span style="color:#f8f8f8;text-decoration:underline">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f8f8f8;text-decoration:underline"> &lt;/span>&lt;span style="color:#204a87;font-weight:bold">args&lt;/span>&lt;span style="color:#000;font-weight:bold">:&lt;/span>&lt;span style="color:#f8f8f8;text-decoration:underline">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f8f8f8;text-decoration:underline"> &lt;/span>- &lt;span style="color:#000">while true; do&lt;/span>&lt;span style="color:#f8f8f8;text-decoration:underline">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f8f8f8;text-decoration:underline"> &lt;/span>&lt;span style="color:#000">echo -en &amp;#39;\n&amp;#39;;&lt;/span>&lt;span style="color:#f8f8f8;text-decoration:underline">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f8f8f8;text-decoration:underline"> &lt;/span>&lt;span style="color:#000">printenv MY_NODE_NAME MY_POD_NAME MY_POD_NAMESPACE;&lt;/span>&lt;span style="color:#f8f8f8;text-decoration:underline">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f8f8f8;text-decoration:underline"> &lt;/span>&lt;span style="color:#000">printenv MY_POD_IP MY_POD_SERVICE_ACCOUNT;&lt;/span>&lt;span style="color:#f8f8f8;text-decoration:underline">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f8f8f8;text-decoration:underline"> &lt;/span>&lt;span style="color:#000">sleep 10;&lt;/span>&lt;span style="color:#f8f8f8;text-decoration:underline">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f8f8f8;text-decoration:underline"> &lt;/span>&lt;span style="color:#000">done;&lt;/span>&lt;span style="color:#f8f8f8;text-decoration:underline">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f8f8f8;text-decoration:underline"> &lt;/span>&lt;span style="color:#204a87;font-weight:bold">env&lt;/span>&lt;span style="color:#000;font-weight:bold">:&lt;/span>&lt;span style="color:#f8f8f8;text-decoration:underline">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f8f8f8;text-decoration:underline"> &lt;/span>- &lt;span style="color:#204a87;font-weight:bold">name&lt;/span>&lt;span style="color:#000;font-weight:bold">:&lt;/span>&lt;span style="color:#f8f8f8;text-decoration:underline"> &lt;/span>&lt;span style="color:#000">MY_NODE_NAME&lt;/span>&lt;span style="color:#f8f8f8;text-decoration:underline">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f8f8f8;text-decoration:underline"> &lt;/span>&lt;span style="color:#204a87;font-weight:bold">valueFrom&lt;/span>&lt;span style="color:#000;font-weight:bold">:&lt;/span>&lt;span style="color:#f8f8f8;text-decoration:underline">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f8f8f8;text-decoration:underline"> &lt;/span>&lt;span style="color:#204a87;font-weight:bold">fieldRef&lt;/span>&lt;span style="color:#000;font-weight:bold">:&lt;/span>&lt;span style="color:#f8f8f8;text-decoration:underline">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f8f8f8;text-decoration:underline"> &lt;/span>&lt;span style="color:#204a87;font-weight:bold">fieldPath&lt;/span>&lt;span style="color:#000;font-weight:bold">:&lt;/span>&lt;span style="color:#f8f8f8;text-decoration:underline"> &lt;/span>&lt;span style="color:#000">spec.nodeName&lt;/span>&lt;span style="color:#f8f8f8;text-decoration:underline">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f8f8f8;text-decoration:underline"> &lt;/span>- &lt;span style="color:#204a87;font-weight:bold">name&lt;/span>&lt;span style="color:#000;font-weight:bold">:&lt;/span>&lt;span style="color:#f8f8f8;text-decoration:underline"> &lt;/span>&lt;span style="color:#000">MY_POD_NAME&lt;/span>&lt;span style="color:#f8f8f8;text-decoration:underline">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f8f8f8;text-decoration:underline"> &lt;/span>&lt;span style="color:#204a87;font-weight:bold">valueFrom&lt;/span>&lt;span style="color:#000;font-weight:bold">:&lt;/span>&lt;span style="color:#f8f8f8;text-decoration:underline">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f8f8f8;text-decoration:underline"> &lt;/span>&lt;span style="color:#204a87;font-weight:bold">fieldRef&lt;/span>&lt;span style="color:#000;font-weight:bold">:&lt;/span>&lt;span style="color:#f8f8f8;text-decoration:underline">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f8f8f8;text-decoration:underline"> &lt;/span>&lt;span style="color:#204a87;font-weight:bold">fieldPath&lt;/span>&lt;span style="color:#000;font-weight:bold">:&lt;/span>&lt;span style="color:#f8f8f8;text-decoration:underline"> &lt;/span>&lt;span style="color:#000">metadata.name&lt;/span>&lt;span style="color:#f8f8f8;text-decoration:underline">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f8f8f8;text-decoration:underline"> &lt;/span>- &lt;span style="color:#204a87;font-weight:bold">name&lt;/span>&lt;span style="color:#000;font-weight:bold">:&lt;/span>&lt;span style="color:#f8f8f8;text-decoration:underline"> &lt;/span>&lt;span style="color:#000">MY_POD_NAMESPACE&lt;/span>&lt;span style="color:#f8f8f8;text-decoration:underline">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f8f8f8;text-decoration:underline"> &lt;/span>&lt;span style="color:#204a87;font-weight:bold">valueFrom&lt;/span>&lt;span style="color:#000;font-weight:bold">:&lt;/span>&lt;span style="color:#f8f8f8;text-decoration:underline">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f8f8f8;text-decoration:underline"> &lt;/span>&lt;span style="color:#204a87;font-weight:bold">fieldRef&lt;/span>&lt;span style="color:#000;font-weight:bold">:&lt;/span>&lt;span style="color:#f8f8f8;text-decoration:underline">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f8f8f8;text-decoration:underline"> &lt;/span>&lt;span style="color:#204a87;font-weight:bold">fieldPath&lt;/span>&lt;span style="color:#000;font-weight:bold">:&lt;/span>&lt;span style="color:#f8f8f8;text-decoration:underline"> &lt;/span>&lt;span style="color:#000">metadata.namespace&lt;/span>&lt;span style="color:#f8f8f8;text-decoration:underline">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f8f8f8;text-decoration:underline"> &lt;/span>- &lt;span style="color:#204a87;font-weight:bold">name&lt;/span>&lt;span style="color:#000;font-weight:bold">:&lt;/span>&lt;span style="color:#f8f8f8;text-decoration:underline"> &lt;/span>&lt;span style="color:#000">MY_POD_IP&lt;/span>&lt;span style="color:#f8f8f8;text-decoration:underline">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f8f8f8;text-decoration:underline"> &lt;/span>&lt;span style="color:#204a87;font-weight:bold">valueFrom&lt;/span>&lt;span style="color:#000;font-weight:bold">:&lt;/span>&lt;span style="color:#f8f8f8;text-decoration:underline">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f8f8f8;text-decoration:underline"> &lt;/span>&lt;span style="color:#204a87;font-weight:bold">fieldRef&lt;/span>&lt;span style="color:#000;font-weight:bold">:&lt;/span>&lt;span style="color:#f8f8f8;text-decoration:underline">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f8f8f8;text-decoration:underline"> &lt;/span>&lt;span style="color:#204a87;font-weight:bold">fieldPath&lt;/span>&lt;span style="color:#000;font-weight:bold">:&lt;/span>&lt;span style="color:#f8f8f8;text-decoration:underline"> &lt;/span>&lt;span style="color:#000">status.podIP&lt;/span>&lt;span style="color:#f8f8f8;text-decoration:underline">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f8f8f8;text-decoration:underline"> &lt;/span>- &lt;span style="color:#204a87;font-weight:bold">name&lt;/span>&lt;span style="color:#000;font-weight:bold">:&lt;/span>&lt;span style="color:#f8f8f8;text-decoration:underline"> &lt;/span>&lt;span style="color:#000">MY_POD_SERVICE_ACCOUNT&lt;/span>&lt;span style="color:#f8f8f8;text-decoration:underline">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f8f8f8;text-decoration:underline"> &lt;/span>&lt;span style="color:#204a87;font-weight:bold">valueFrom&lt;/span>&lt;span style="color:#000;font-weight:bold">:&lt;/span>&lt;span style="color:#f8f8f8;text-decoration:underline">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f8f8f8;text-decoration:underline"> &lt;/span>&lt;span style="color:#204a87;font-weight:bold">fieldRef&lt;/span>&lt;span style="color:#000;font-weight:bold">:&lt;/span>&lt;span style="color:#f8f8f8;text-decoration:underline">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f8f8f8;text-decoration:underline"> &lt;/span>&lt;span style="color:#204a87;font-weight:bold">fieldPath&lt;/span>&lt;span style="color:#000;font-weight:bold">:&lt;/span>&lt;span style="color:#f8f8f8;text-decoration:underline"> &lt;/span>&lt;span style="color:#000">spec.serviceAccountName&lt;/span>&lt;span style="color:#f8f8f8;text-decoration:underline">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f8f8f8;text-decoration:underline"> &lt;/span>&lt;span style="color:#204a87;font-weight:bold">restartPolicy&lt;/span>&lt;span style="color:#000;font-weight:bold">:&lt;/span>&lt;span style="color:#f8f8f8;text-decoration:underline"> &lt;/span>&lt;span style="color:#000">Never&lt;/span>&lt;span style="color:#f8f8f8;text-decoration:underline">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>这个配置文件中，你可以看到五个环境变量。&lt;code>env&lt;/code> 字段是一个 &lt;a href="https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.21/#envvar-v1-core">EnvVars&lt;/a>. 对象的数组。 数组中第一个元素指定 &lt;code>MY_NODE_NAME&lt;/code> 这个环境变量从 Pod 的 &lt;code>spec.nodeName&lt;/code> 字段获取变量值。 同样，其它环境变量也是从 Pod 的字段获取它们的变量值。&lt;/p>
&lt;blockquote>
&lt;p>&lt;strong>说明：&lt;/strong> 本示例中的字段是 Pod 字段，不是 Pod 中 Container 的字段。&lt;/p>
&lt;/blockquote>
&lt;p>创建 Pod：&lt;/p>
&lt;pre>&lt;code>kubectl apply -f https://k8s.io/examples/pods/inject/dapi-envars-pod.yaml
&lt;/code>&lt;/pre>
&lt;p>验证 Pod 中的容器运行正常：&lt;/p>
&lt;pre>&lt;code>kubectl get pods
&lt;/code>&lt;/pre>
&lt;p>查看容器日志：&lt;/p>
&lt;pre>&lt;code>kubectl logs dapi-envars-fieldref
&lt;/code>&lt;/pre>
&lt;p>输出信息显示了所选择的环境变量的值：&lt;/p>
&lt;pre>&lt;code>minikube
dapi-envars-fieldref
default
172.17.0.4
default
&lt;/code>&lt;/pre>
&lt;p>要了解为什么这些值在日志中，请查看配置文件中的&lt;code>command&lt;/code> 和 &lt;code>args&lt;/code>字段。 当容器启动时，它将五个环境变量的值写入 stdout。每十秒重复执行一次。
接下来，通过打开一个 Shell 进入 Pod 中运行的容器：&lt;/p>
&lt;pre>&lt;code>kubectl exec -it dapi-envars-fieldref -- sh
&lt;/code>&lt;/pre>
&lt;p>在 Shell 中，查看环境变量：&lt;/p>
&lt;pre>&lt;code>/# printenv
&lt;/code>&lt;/pre>
&lt;p>输出信息显示环境变量已经设置为 Pod 字段的值。&lt;/p>
&lt;pre>&lt;code>MY_POD_SERVICE_ACCOUNT=default
...
MY_POD_NAMESPACE=default
MY_POD_IP=172.17.0.4
...
MY_NODE_NAME=minikube
...
MY_POD_NAME=dapi-envars-fieldref
&lt;/code>&lt;/pre>
&lt;h2 id="用-container-字段作为环境变量的值">用 Container 字段作为环境变量的值&lt;a class="td-heading-self-link" href="#%e7%94%a8-container-%e5%ad%97%e6%ae%b5%e4%bd%9c%e4%b8%ba%e7%8e%af%e5%a2%83%e5%8f%98%e9%87%8f%e7%9a%84%e5%80%bc" aria-label="Heading self-link">&lt;/a>&lt;/h2>
&lt;p>前面的练习中，你将 Pod 字段作为环境变量的值。 接下来这个练习中，你将用 Container 字段作为环境变量的值。这里是包含一个容器的 Pod 的配置文件：
&lt;a href="https://notes-learning.oss-cn-beijing.aliyuncs.com/ooyi9u/1621520643090-327ae7d2-cb76-4240-b963-9070371cdaca.svg">&lt;code>pods/inject/dapi-envars-container.yaml&lt;/code>&lt;/a>&lt;/p>
&lt;pre>&lt;code>apiVersion: v1
kind: Pod
metadata:
name: dapi-envars-resourcefieldref
spec:
containers:
- name: test-container
image: k8s.gcr.io/busybox:1.24
command: [ &amp;quot;sh&amp;quot;, &amp;quot;-c&amp;quot;]
args:
- while true; do
echo -en '\n';
printenv MY_CPU_REQUEST MY_CPU_LIMIT;
printenv MY_MEM_REQUEST MY_MEM_LIMIT;
sleep 10;
done;
resources:
requests:
memory: &amp;quot;32Mi&amp;quot;
cpu: &amp;quot;125m&amp;quot;
limits:
memory: &amp;quot;64Mi&amp;quot;
cpu: &amp;quot;250m&amp;quot;
env:
- name: MY_CPU_REQUEST
valueFrom:
resourceFieldRef:
containerName: test-container
resource: requests.cpu
- name: MY_CPU_LIMIT
valueFrom:
resourceFieldRef:
containerName: test-container
resource: limits.cpu
- name: MY_MEM_REQUEST
valueFrom:
resourceFieldRef:
containerName: test-container
resource: requests.memory
- name: MY_MEM_LIMIT
valueFrom:
resourceFieldRef:
containerName: test-container
resource: limits.memory
restartPolicy: Never
&lt;/code>&lt;/pre>
&lt;p>这个配置文件中，你可以看到四个环境变量。&lt;code>env&lt;/code> 字段是一个 &lt;a href="https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.21/#envvar-v1-core">EnvVars&lt;/a>. 对象的数组。数组中第一个元素指定 &lt;code>MY_CPU_REQUEST&lt;/code> 这个环境变量从 Container 的 &lt;code>requests.cpu&lt;/code> 字段获取变量值。同样，其它环境变量也是从 Container 的字段获取它们的变量值。&lt;/p>
&lt;blockquote>
&lt;p>&lt;strong>说明：&lt;/strong> 本例中使用的是 Container 的字段而不是 Pod 的字段。&lt;/p>
&lt;/blockquote>
&lt;p>创建 Pod：&lt;/p>
&lt;pre>&lt;code>kubectl apply -f https://k8s.io/examples/pods/inject/dapi-envars-container.yaml
&lt;/code>&lt;/pre>
&lt;p>验证 Pod 中的容器运行正常：&lt;/p>
&lt;pre>&lt;code>kubectl get pods
&lt;/code>&lt;/pre>
&lt;p>查看容器日志：&lt;/p>
&lt;pre>&lt;code>kubectl logs dapi-envars-resourcefieldref
&lt;/code>&lt;/pre>
&lt;p>输出信息显示了所选择的环境变量的值：&lt;/p>
&lt;pre>&lt;code>1
1
33554432
67108864
&lt;/code>&lt;/pre></description></item></channel></rss>