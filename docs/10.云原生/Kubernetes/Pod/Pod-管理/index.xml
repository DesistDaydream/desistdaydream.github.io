<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Pod 管理 on 断念梦的站点</title><link>https://desistdaydream.github.io/docs/10.%E4%BA%91%E5%8E%9F%E7%94%9F/Kubernetes/Pod/Pod-%E7%AE%A1%E7%90%86/</link><description>Recent content in Pod 管理 on 断念梦的站点</description><generator>Hugo</generator><language>zh-cn</language><atom:link href="https://desistdaydream.github.io/docs/10.%E4%BA%91%E5%8E%9F%E7%94%9F/Kubernetes/Pod/Pod-%E7%AE%A1%E7%90%86/index.xml" rel="self" type="application/rss+xml"/><item><title>Security Context(安全环境)</title><link>https://desistdaydream.github.io/docs/10.%E4%BA%91%E5%8E%9F%E7%94%9F/Kubernetes/Pod/Pod-%E7%AE%A1%E7%90%86/Security-Context%E5%AE%89%E5%85%A8%E7%8E%AF%E5%A2%83/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/10.%E4%BA%91%E5%8E%9F%E7%94%9F/Kubernetes/Pod/Pod-%E7%AE%A1%E7%90%86/Security-Context%E5%AE%89%E5%85%A8%E7%8E%AF%E5%A2%83/</guid><description>概述 参考：
官方文档，任务-配置 Pod 和 Containers 公众号-阳明 Security Context(安全环境) 用来定义 Pod 或 Container 的特权与访问控制设置。 安全上下文包括但不限于：
自主访问控制（Discretionary Access Control）：基于 用户 ID（UID）和组 ID（GID）. 来判定对对象（例如文件）的访问权限。 安全性增强的 Linux（SELinux）： 为对象赋予安全性标签。 以特权模式或者非特权模式运行。 Linux 权能: 为进程赋予 root 用户的部分特权而非全部特权。 AppArmor：使用程序框架来限制个别程序的权能。 Seccomp：过滤进程的系统调用。 AllowPrivilegeEscalation：控制进程是否可以获得超出其父进程的特权。 此布尔值直接控制是否为容器进程设置 [no_new_privs](https://www.kernel.org/doc/Documentation/prctl/no_new_privs.txt)标志。 当容器以特权模式运行或者具有 CAP_SYS_ADMIN 权能时，AllowPrivilegeEscalation 总是为 true。 readOnlyRootFilesystem：以只读方式加载容器的根文件系统。 以上条目不是安全上下文设置的完整列表 &amp;ndash; 请参阅 SecurityContext 了解其完整列表。 关于在 Linux 系统中的安全机制的更多信息，可参阅 Linux 内核安全性能力概述。
特别注意：限制自由，会产生很多问题，比如：
使用 hostPath 类型的 volume 时，如果容器不以 root 用户运行，则无法对 hostPath 所在目录执行操作，任何写操作将会提示权限不够。因为目录权限 755 应该了解的 10 个 Kubernetes 安全上下文配置 在 Kubernetes 中安全地运行工作负载是很困难的，有很多配置都可能会影响到整个 Kubernetes API 的安全性，这需要我们有大量的知识积累来正确的实施。Kubernetes 在安全方面提供了一个强大的工具 securityContext，每个 Pod 和容器清单都可以使用这个属性。在本文中我们将了解各种 securityContext 的配置，探讨它们的含义，以及我们应该如何使用它们。 securityContext 设置在 PodSpec 和 ContainerSpec 规范中都有定义，这里我们分别用[P]和[C]来表示。需要注意的是，如果一个设置在两个作用域中都可以使用和配置，那么我们应该优先考虑设置容器级别的。</description></item><item><title>访问 Pod</title><link>https://desistdaydream.github.io/docs/10.%E4%BA%91%E5%8E%9F%E7%94%9F/Kubernetes/Pod/Pod-%E7%AE%A1%E7%90%86/%E8%AE%BF%E9%97%AE-Pod/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/10.%E4%BA%91%E5%8E%9F%E7%94%9F/Kubernetes/Pod/Pod-%E7%AE%A1%E7%90%86/%E8%AE%BF%E9%97%AE-Pod/</guid><description>概述 参考：
原文，jimmysong.io kubernetes 手书，指南-从集群外部访问 Pod 本文主要讲解访问 kubenretes 中的 Pod 和 Serivce 的集中方式，包括如下几种：
hostNetwork hostPort NodePort LoadBalancer Ingress 说是暴露 Pod 其实跟暴露 Service 是一回事，因为 Pod 就是 Service 的 backend。
hostNetwork: true 这是一种直接定义 Pod 网络的方式。
如果在 Pod 中使用 hostNetwork:true 配置的话，在这种 pod 中运行的应用程序可以直接看到 pod 启动的主机的网络接口。在主机的所有网络接口上都可以访问到该应用程序。以下是使用主机网络的 pod 的示例定义：
apiVersion: v1 kind: Pod metadata: name: influxdb spec: hostNetwork: true containers: - name: influxdb image: influxdb 部署该 Pod：
$ kubectl create -f influxdb-hostnetwork.yml 访问该 pod 所在主机的 8086 端口：</description></item><item><title>为 Pod 注入数据</title><link>https://desistdaydream.github.io/docs/10.%E4%BA%91%E5%8E%9F%E7%94%9F/Kubernetes/Pod/Pod-%E7%AE%A1%E7%90%86/%E4%B8%BA-Pod-%E6%B3%A8%E5%85%A5%E6%95%B0%E6%8D%AE/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/10.%E4%BA%91%E5%8E%9F%E7%94%9F/Kubernetes/Pod/Pod-%E7%AE%A1%E7%90%86/%E4%B8%BA-Pod-%E6%B3%A8%E5%85%A5%E6%95%B0%E6%8D%AE/</guid><description>概述 参考：
官方文档，任务 - 给应用注入数据 将 Pod 的 Manifests 信息映射到容器中的环境变量上 用 Pod 字段作为环境变量的值 在这个练习中，你将创建一个包含一个容器的 Pod。这是该 Pod 的配置文件：
apiVersion: v1 kind: Pod metadata: name: dapi-envars-fieldref spec: containers: - name: test-container image: k8s.gcr.io/busybox command: [&amp;#34;sh&amp;#34;, &amp;#34;-c&amp;#34;] args: - while true; do echo -en &amp;#39;\n&amp;#39;; printenv MY_NODE_NAME MY_POD_NAME MY_POD_NAMESPACE; printenv MY_POD_IP MY_POD_SERVICE_ACCOUNT; sleep 10; done; env: - name: MY_NODE_NAME valueFrom: fieldRef: fieldPath: spec.nodeName - name: MY_POD_NAME valueFrom: fieldRef: fieldPath: metadata.name - name: MY_POD_NAMESPACE valueFrom: fieldRef: fieldPath: metadata.</description></item></channel></rss>