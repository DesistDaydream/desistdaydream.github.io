<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>API Server 源码 on 断念梦的站点</title><link>https://desistdaydream.github.io/docs/10.%E4%BA%91%E5%8E%9F%E7%94%9F/Kubernetes/Kubernetes-%E5%BC%80%E5%8F%91/%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/API-Server-%E6%BA%90%E7%A0%81/</link><description>Recent content in API Server 源码 on 断念梦的站点</description><generator>Hugo</generator><language>zh-cn</language><atom:link href="https://desistdaydream.github.io/docs/10.%E4%BA%91%E5%8E%9F%E7%94%9F/Kubernetes/Kubernetes-%E5%BC%80%E5%8F%91/%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/API-Server-%E6%BA%90%E7%A0%81/index.xml" rel="self" type="application/rss+xml"/><item><title>API Server 源码</title><link>https://desistdaydream.github.io/docs/10.%E4%BA%91%E5%8E%9F%E7%94%9F/Kubernetes/Kubernetes-%E5%BC%80%E5%8F%91/%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/API-Server-%E6%BA%90%E7%A0%81/API-Server-%E6%BA%90%E7%A0%81/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/10.%E4%BA%91%E5%8E%9F%E7%94%9F/Kubernetes/Kubernetes-%E5%BC%80%E5%8F%91/%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/API-Server-%E6%BA%90%E7%A0%81/API-Server-%E6%BA%90%E7%A0%81/</guid><description>概述 参考：
公众号,API Server service 的实现</description></item><item><title>kube-apiserver 的设计与实现 · 田飞雨</title><link>https://desistdaydream.github.io/docs/10.%E4%BA%91%E5%8E%9F%E7%94%9F/Kubernetes/Kubernetes-%E5%BC%80%E5%8F%91/%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/API-Server-%E6%BA%90%E7%A0%81/kube-apiserver-%E7%9A%84%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0-%E7%94%B0%E9%A3%9E%E9%9B%A8/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/10.%E4%BA%91%E5%8E%9F%E7%94%9F/Kubernetes/Kubernetes-%E5%BC%80%E5%8F%91/%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/API-Server-%E6%BA%90%E7%A0%81/kube-apiserver-%E7%9A%84%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0-%E7%94%B0%E9%A3%9E%E9%9B%A8/</guid><description>kube-apiserver 的设计与实现 · 田飞雨
kube-apiserver 是 kubernetes 中与 etcd 直接交互的一个组件，其控制着 kubernetes 中核心资源的变化。它主要提供了以下几个功能：
提供 Kubernetes API，包括认证授权、数据校验以及集群状态变更等，供客户端及其他组件调用； 代理集群中的一些附加组件组件，如 Kubernetes UI、metrics-server、npd 等； 创建 kubernetes 服务，即提供 apiserver 的 Service，kubernetes Service； 资源在不同版本之间的转换； kube-apiserver 处理流程 kube-apiserver 主要通过对外提供 API 的方式与其他组件进行交互，可以调用 kube-apiserver 的接口 $ curl -k https://&amp;lt;masterIP&amp;gt;:6443或者通过其提供的 swagger-ui 获取到，其主要有以下三种 API：
core group：主要在 /api/v1 下； named groups：其 path 为 /apis/$NAME/$VERSION； 暴露系统状态的一些 API：如/metrics 、/healthz 等； API 的 URL 大致以 /apis/group/version/namespaces/my-ns/myresource 组成，其中 API 的结构大致如下图所示：
了解了 kube-apiserver 的 API 后，下面会介绍 kube-apiserver 如何处理一个 API 请求，一个请求完整的流程如下图所示：</description></item><item><title>Kubernetes并发控制和资源变更</title><link>https://desistdaydream.github.io/docs/10.%E4%BA%91%E5%8E%9F%E7%94%9F/Kubernetes/Kubernetes-%E5%BC%80%E5%8F%91/%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/API-Server-%E6%BA%90%E7%A0%81/Kubernetes%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6%E5%92%8C%E8%B5%84%E6%BA%90%E5%8F%98%E6%9B%B4/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/10.%E4%BA%91%E5%8E%9F%E7%94%9F/Kubernetes/Kubernetes-%E5%BC%80%E5%8F%91/%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/API-Server-%E6%BA%90%E7%A0%81/Kubernetes%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6%E5%92%8C%E8%B5%84%E6%BA%90%E5%8F%98%E6%9B%B4/</guid><description>概述 参考：
公众号，云原生实验室，Kubernetes 是如何控制并发和资源变更的 原文，简书，Kubernetes 并发控制和资源变更 并发控制 并发控制指的是当多个用户同时更新运行时，用于保护数据库完整性的各种技术。并发机制不正确可能导致脏读、幻读和不可重复读等此类问题。并发控制的目的是保证一个用户的工作不会对另一个用户的工作产生不合理的影响。
悲观锁 悲观锁在操作数据时比较悲观，认为别人会同时修改数据。因此操作数据时直接把数据锁住，直到操作完成后才会释放锁；上锁期间其他人不能修改数据。
悲观锁主要用于数据争用激烈的环境，以及发生并发冲突时使用锁保护数据的成本要低于回滚事务的成本的环境中。
优点
是“先取锁再访问”的保守策略，为数据处理的安全提供了保证。 缺点
在效率方面，处理加锁的机制会让数据库产生额外的开销，还有增加产生死锁的机会； 在只读型事务处理中由于不会产生冲突，也没必要使用锁，这样做只能增加系统负载； 会降低了并行性，一个事务如果锁定了某行数据，其他事务就必须等待该事务处理完才可以处理那行数据。 乐观锁 乐观锁在操作数据时非常乐观，认为别人不会同时修改数据。因此乐观锁不会上锁，只是在执行更新的时候判断一下在此期间别人是否修改了数据：如果别人修改了数据则放弃操作，否则执行操作。
乐观并发控制多数用于数据争用不大、冲突较少的环境中，这种环境中，偶尔回滚事务的成本会低于读取数据时锁定数据的成本，因此可以获得比其他并发控制方法更高的吞吐量。
优点
不会产生任何锁和死锁 有更高的吞吐量 缺点
ABA 问题是乐观锁一个常见的问题 循环时间长开销大 乐观锁一般会使用版本号机制或 CAS 算法实现：
版本号机制 一般是在数据表中加上一个数据版本号 version 字段，表示数据被修改的次数，当数据被修改时，version 值会加一。当线程 A 要更新数据值时，在读取数据的同时也会读取 version 值，在提交更新时，若刚才读取到的 version 值为当前数据库中的 version 值相等时才更新，否则重试更新操作，直到更新成功。
CAS 算法 即compare and swap（比较与交换），是一种有名的无锁算法。无锁编程，即不使用锁的情况下实现多线程之间的变量同步，也就是在没有线程被阻塞的情况下实现变量的同步，所以也叫非阻塞同步（Non-blocking Synchronization）。CAS 算法涉及到三个操作数
需要读写的内存值 V 进行比较的值 A 拟写入的新值 B 当且仅当 V 的值等于 A 时，CAS 通过原子方式用新值 B 来更新 V 的值，否则不会执行任何操作（比较和替换是一个原子操作）。一般情况下是一个自旋操作，即不断的重试。
Kubernetes 并发控制 在 Kubernetes 集群中，外部用户及内部组件频繁的数据更新操作，导致系统的数据并发读写量非常大。假设采用悲观并行的控制方法，将严重损耗集群性能，因此 Kubernetes 采用乐观并行的控制方法。</description></item></channel></rss>