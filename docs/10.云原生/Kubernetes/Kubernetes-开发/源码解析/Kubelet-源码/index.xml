<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Kubelet 源码 on 断念梦的站点</title><link>https://desistdaydream.github.io/docs/10.%E4%BA%91%E5%8E%9F%E7%94%9F/Kubernetes/Kubernetes-%E5%BC%80%E5%8F%91/%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/Kubelet-%E6%BA%90%E7%A0%81/</link><description>Recent content in Kubelet 源码 on 断念梦的站点</description><generator>Hugo</generator><language>zh-cn</language><atom:link href="https://desistdaydream.github.io/docs/10.%E4%BA%91%E5%8E%9F%E7%94%9F/Kubernetes/Kubernetes-%E5%BC%80%E5%8F%91/%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/Kubelet-%E6%BA%90%E7%A0%81/index.xml" rel="self" type="application/rss+xml"/><item><title>EvictionManager 模块</title><link>https://desistdaydream.github.io/docs/10.%E4%BA%91%E5%8E%9F%E7%94%9F/Kubernetes/Kubernetes-%E5%BC%80%E5%8F%91/%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/Kubelet-%E6%BA%90%E7%A0%81/EvictionManager-%E6%A8%A1%E5%9D%97/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/10.%E4%BA%91%E5%8E%9F%E7%94%9F/Kubernetes/Kubernetes-%E5%BC%80%E5%8F%91/%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/Kubelet-%E6%BA%90%E7%A0%81/EvictionManager-%E6%A8%A1%E5%9D%97/</guid><description>概述 参考：
公众号-云原生实验室，Kubernetes 单机侧的驱逐策略总结 本文转自 Edwardesire 的博客，原文：https://edwardesire.com/posts/process-eviction-under-k8s/ 进程驱逐：当机器存在资源压力时，可能是由于有恶意程序在消耗系统资源，或者是 overcommit 导致。系统通过控制机器上的进程存活来减少单个程序对系统的整体影响。驱逐阶段最关键的就是选择合适的进程，通过最小代价来保证系统的稳定。在执行层面上可以分为两种驱逐方式：
用户空间驱逐：通过守护进程之类的机制，触发式主动清理进程。 内核空间驱逐：内核在无法分配内存时，通过 oom_killer 选择进程终止来释放资源。 本文从 k8s 出发，总结不同层次下的驱逐流程和进程选择策略。
Kubelet 驱逐策略 k8s 除了支持 API 发起的主动驱逐，还支持用户空间的 pod 驱逐（将资源大户的进程终止）。对于不可压缩资源：内存、disk（nodefs）、pid，kubelet 会监控相应的指标来触发 pod 驱逐。K8S 依据 pod 的资源消耗和优先级来驱逐 pod 来回收资源：
如果 pod 资源使用量超过资源请求值，则优先驱逐 依据 pod priority 驱逐 pod 真实资源使用量越高则越优先驱逐 我们可以得出：
当 BestEffort 和 Burstable pod 的资源使用量超过请求值时，会依据 pod priority 和超过请求多少来判断驱逐顺序。也不会有特例的 pod 能够不被驱逐的风险。当 Guaranteed 和 Busrtable pod 的使用量低于请求值时，基于 pod priority 确定驱逐顺序。 这一切的逻辑都在 kubelet 的 eviction manager 实现。
Eviction manager Manager 的接口定义包含主流程的启动函数以及提供给 kubelet 上报节点状态的：</description></item><item><title>Kubelet 启动流程</title><link>https://desistdaydream.github.io/docs/10.%E4%BA%91%E5%8E%9F%E7%94%9F/Kubernetes/Kubernetes-%E5%BC%80%E5%8F%91/%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/Kubelet-%E6%BA%90%E7%A0%81/Kubelet-%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/10.%E4%BA%91%E5%8E%9F%E7%94%9F/Kubernetes/Kubernetes-%E5%BC%80%E5%8F%91/%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/Kubelet-%E6%BA%90%E7%A0%81/Kubelet-%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/</guid><description>概述 启动 首先从 kubelet 的 main() 函数开始，调用 app.NewKubeletCommand() 方法以获取配置文件中的参数、校验参数、为参数设置默认值。主要逻辑为：
解析命令行参数； 为 kubelet 初始化 feature gates 参数； 加载 kubelet 配置文件； 校验配置文件中的参数； 检查 kubelet 是否启用动态配置功能； 初始化 kubeletDeps，kubeletDeps 包含 kubelet 运行所必须的配置，是为了实现 dependency injection，其目的是为了把 kubelet 依赖的组件对象作为参数传进来，这样可以控制 kubelet 的行为； 调用 Run() 函数； main() - 入口 源码：[cmd/kubelet/kubelet.go](https://github.com/kubernetes/kubernetes/blob/master/cmd/kubelet/kubelet.go)
func main() { command := app.NewKubeletCommand() // kubelet 使用一个配置文件，并对标志和该配置文件进行自己的特殊解析。 // 完成后，它会初始化日志记录。因此，它不像其他更简单的命令那样使用 cli.Run() code := run(command) os.Exit(code) } func run(command *cobra.Command) int { defer logs.FlushLogs() rand.Seed(time.Now().UnixNano()) command.SetGlobalNormalizationFunc(cliflag.WordSepNormalizeFunc) if err := command.</description></item><item><title>Kubelet 源码</title><link>https://desistdaydream.github.io/docs/10.%E4%BA%91%E5%8E%9F%E7%94%9F/Kubernetes/Kubernetes-%E5%BC%80%E5%8F%91/%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/Kubelet-%E6%BA%90%E7%A0%81/Kubelet-%E6%BA%90%E7%A0%81/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/10.%E4%BA%91%E5%8E%9F%E7%94%9F/Kubernetes/Kubernetes-%E5%BC%80%E5%8F%91/%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/Kubelet-%E6%BA%90%E7%A0%81/Kubelet-%E6%BA%90%E7%A0%81/</guid><description>概述 参考：
田飞雨博客，源码阅读笔记-kubernetes-kubelet 公众号，CNCF-Kubernetes 源码分析之 kubelet(一) https://mp.weixin.qq.com/mp/appmsgalbum?action=getalbum&amp;__biz=Mzk0NTE4OTU0Ng==&amp;scene=1&amp;album_id=1632443286688677893&amp;count=3#wechat_redirect 博客 - 一直肥羊的思考，kubelet 内部实现解析 博客 - ljchen&amp;rsquo;s Notes，Kubelet 源码结构简介 更新时间：2022 年 2 月 23 日，Kubernetes 的源码目录随着更新迭代，也在不断变化中
目录结构 kubelet 代码分两部分，在 cmd/kubelet 和 pkg/kubelet 中
cmd/kubelet/* $ tree -L 2 -p cmd/kubelet cmd/kubelet ├── [-rwxrwxrwx] BUILD ├── [-rwxrwxrwx] OWNERS ├── [drwxrwxrwx] app │ ├── [-rwxrwxrwx] BUILD │ ├── [-rwxrwxrwx] OWNERS │ ├── [-rwxrwxrwx] auth.go │ ├── [-rwxrwxrwx] init_others.go │ ├── [-rwxrwxrwx] init_windows.go │ ├── [-rwxrwxrwx] init_windows_test.</description></item><item><title>PodWorker 模块</title><link>https://desistdaydream.github.io/docs/10.%E4%BA%91%E5%8E%9F%E7%94%9F/Kubernetes/Kubernetes-%E5%BC%80%E5%8F%91/%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/Kubelet-%E6%BA%90%E7%A0%81/PodWorker-%E6%A8%A1%E5%9D%97/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/10.%E4%BA%91%E5%8E%9F%E7%94%9F/Kubernetes/Kubernetes-%E5%BC%80%E5%8F%91/%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/Kubelet-%E6%BA%90%E7%A0%81/PodWorker-%E6%A8%A1%E5%9D%97/</guid><description>概述 PodWorkers 子模块主要的作用就是处理针对每一个的 Pod 的更新事件，比如 Pod 的创建，删除，更新。而 podWorkers 采取的基本思路是：为每一个 Pod 都单独创建一个 goroutine 和更新事件的 channel，goroutine 会阻塞式的等待 channel 中的事件，并且对获取的事件进行处理。而 podWorkers 对象自身则主要负责对更新事件进行下发。
准备运行 Pod podWorkers.UpdatePod() - 更新事件的 channel updatePod 将配置更改或终止状态传递到 POD。 POD 可以是可变的，终止或终止，并且如果在 APIServer 上删除，则将转换为终止，它被发现具有终端阶段（成功或失败），或者如果它被 kubelet 驱逐。
为每一个 Pod 都单独创建一个 goroutine 和更新事件的 channel，goroutine 会阻塞式的等待 channel 中的事件，并且对获取的事件进行处理。而 podWorkers 对象自身则主要负责对更新事件进行下发。
源码：pkg/kubelet/pod_workers.go
func (p *podWorkers) UpdatePod(options UpdatePodOptions) { // 处理当 Pod 是孤儿(无配置)并且我们仅通过仅运行生命周期的终止部分来获得运行时状态 pod := options.Pod var isRuntimePod bool if options.RunningPod != nil { if options.Pod == nil { pod = options.</description></item><item><title>SyncLoop 模块</title><link>https://desistdaydream.github.io/docs/10.%E4%BA%91%E5%8E%9F%E7%94%9F/Kubernetes/Kubernetes-%E5%BC%80%E5%8F%91/%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/Kubelet-%E6%BA%90%E7%A0%81/SyncLoop-%E6%A8%A1%E5%9D%97/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/10.%E4%BA%91%E5%8E%9F%E7%94%9F/Kubernetes/Kubernetes-%E5%BC%80%E5%8F%91/%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/Kubelet-%E6%BA%90%E7%A0%81/SyncLoop-%E6%A8%A1%E5%9D%97/</guid><description>概述 参考：
SyncLoop 模块，Kubelet 同步循环
kubelet 的工作核心就是在围绕着不同的生产者生产出来的不同的有关 pod 的消息来调用相应的消费者（不同的子模块）完成不同的行为(创建和删除 pod 等)，即图中的控制循环（SyncLoop），通过不同的事件驱动这个控制循环运行。
本文仅分析新建 pod 的流程，当一个 pod 完成调度，与一个 node 绑定起来之后，这个 pod 就会触发 kubelet 在循环控制里注册的 handler，上图中的 HandlePods 部分。此时，通过检查 pod 在 kubelet 内存中的状态，kubelet 就能判断出这是一个新调度过来的 pod，从而触发 Handler 里的 ADD 事件对应的逻辑处理。然后 kubelet 会为这个 pod 生成对应的 podStatus，接着检查 pod 所声明的 volume 是不是准备好了，然后调用下层的容器运行时。如果是 update 事件的话，kubelet 就会根据 pod 对象具体的变更情况，调用下层的容器运行时进行容器的重建。
kubelet 创建 pod 的流程 Note：注意 14，,15 步，kubelet 会先将生成配置(volume 挂载、配置主机名等等)，才会去启动 pod，哪怕 pod 启动失败，挂载依然存在。
同步循环 kubelet.syncLoop() - 同步循环入口 syncLoop 中首先定义了一个 syncTicker 和 housekeepingTicker，即使没有需要更新的 pod 配置，kubelet 也会定时去做同步和清理 pod 的工作。然后在 for 循环中一直调用 syncLoopIteration，如果在每次循环过程中出现比较严重的错误，kubelet 会记录到 runtimeState 中，遇到错误就等待 5 秒中继续循环。</description></item></channel></rss>