<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>API 访问控制 on 断念梦的站点</title><link>https://desistdaydream.github.io/docs/10.%E4%BA%91%E5%8E%9F%E7%94%9F/Kubernetes/API-%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6/</link><description>Recent content in API 访问控制 on 断念梦的站点</description><generator>Hugo</generator><language>zh-cn</language><atom:link href="https://desistdaydream.github.io/docs/10.%E4%BA%91%E5%8E%9F%E7%94%9F/Kubernetes/API-%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6/index.xml" rel="self" type="application/rss+xml"/><item><title>API 访问控制</title><link>https://desistdaydream.github.io/docs/10.%E4%BA%91%E5%8E%9F%E7%94%9F/Kubernetes/API-%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6/API-%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/10.%E4%BA%91%E5%8E%9F%E7%94%9F/Kubernetes/API-%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6/API-%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6/</guid><description>概述 参考：
官方文档，概念 - 安全 - Kubernetes API 的访问控制 认证用于身份验证，授权用于权限检查，准入控制机制用于补充授权机制
客户端与服务端的概念：谁向谁发请求，前者就是客户端，所在在这里，客户端与服务端没有绝对。一个服务既可以是客户端也可以是服务端，kubectl 在控制集群需要给 apiservice 发送 get，creat，delete 等指令的时候，kubectl 就是 apiservice 的客户端；而 apiservice 需要往 etcd 写入数据的时候，apiservice 就是 etcd 的客户端。
当客户端向服务端发起请求的时候，服务端需要对客户端进行认证以便确认客户端身份是否可以接入；接入后再进行授权检查，检查该身份的请求是否可以在服务端执行。所以后面介绍的 认证 与 授权 是相辅相成，不可分隔，创建完认证之后，需要为这个认证信息进行授权，才是一套完整的鉴权机制
比如现在有这么一个场景，张三要去商场买酱油。当张三到达商场后，保安人员首先要对张三进行认证，确认张三这个人可以进入商场；然后张三到达货柜拿走酱油去结账，收银人员进行授权检查，核验张三是否有权力购买酱油。
在 kubernetes 集群中，就是类似张三买酱油的场景。。。各个组件与资源对象之间的互相访问，在大多数时候，都需要进行认证与授权的检查。
API Server 是集群的入口，不管是对资源对象的增删改查，还是访问集群中的某些对象，不可避免得只能与 API Server 交互，虽然在访问某些管理组件的 https 端口时，也需要进行认证，但是这种访问是属于基本的 https 访问。所以，在与其说是 k8s 的认证与授权，不如说是 kubernetes API 的访问控制。因为不管是从外部(kubeclt 等)、还是内部(controller-manager、某个 pod 访问集群资源)，都逃不开与 kubernetes API，也就是 api-server 这个组件的交互。毕竟 kubernetes API 是集群的唯一入口。。。就算是在集群内部署的 pod，如果想要访问集群内的资源，也逃不开 kubernetes API~~
当然，使用 curl 命令来访问 controller、scheduler 时、或者 etcd 互相交互，都属于 认证与授权 的概念范畴~只不过这种情况不占大多数，所以就不再单独讨论了。这些认证授权方式与 API 的认证授权类似。</description></item><item><title>Admission Controllers 准入控制器</title><link>https://desistdaydream.github.io/docs/10.%E4%BA%91%E5%8E%9F%E7%94%9F/Kubernetes/API-%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6/Admission-Controllers-%E5%87%86%E5%85%A5%E6%8E%A7%E5%88%B6%E5%99%A8/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/10.%E4%BA%91%E5%8E%9F%E7%94%9F/Kubernetes/API-%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6/Admission-Controllers-%E5%87%86%E5%85%A5%E6%8E%A7%E5%88%B6%E5%99%A8/</guid><description>概述 参考：
官方文档，参考-API 访问控制-使用准入控制器 官方文档，参考-API 访问控制-动态准入控制 理清 Kubernetes 中的准入控制（Admission Controller） 公众号 - 运维开发故事，开发一个禁止删除 namespace 的控制器 准入控制器是一段代码，它会在请求通过 认证和授权 之后、对象被持久化之前，拦截到达 API Server 的请求。
由于准入控制器是拦截 API Server 中最后的持久化逻辑，所以现阶段 准入控制器在 kube-apiserver 自身中实现，一共由于两大类准入控制器
静态准入控制器 # kube-apiserver 默认内置的准入控制器，可以从 准入控制器列表 查看。 比如 istio 为每个 Pod 注入 Sidecar 的功能，就是通过 Mutating 准入控制器实现的。 动态准入控制器 # 以 Webhook 的形式运行，请求到达 kube-apiserver 后将会根据 ValidatingWebhookConfiguration 资源的定义，将请求转发给自己编写的控制器来处理后再返回给 kube-apiserver。 比如我们编写了一个程序：如果请求是删除 namespace 资源的话，则进制删除。那么将这个程序部署到 k8s 时，再创建一个 ValidatingWebhookConfiguration 对面，以告诉 API Server 将请求转发给咱编写的程序。此时咱的程序处理请求后，会告诉 API Server 是否可以继续执行这个请求。 准入控制器通常用以执行 Validating(验证)、Mutating(变更) 操作
验证操作即验证该请求是否可以执行 变更操作就是类似于 Istion，将创建的 Pod 中加入其他字段或减少某些字段。 目前版本中，默认启用的准入控制器 CertificateApproval CertificateSigning CertificateSubjectRestriction DefaultIngressClass DefaultStorageClass DefaultTolerationSeconds LimitRanger MutatingAdmissionWebhook NamespaceLifecycle PersistentVolumeClaimResize PodSecurity Priority ResourceQuota RuntimeClass ServiceAccount StorageObjectInUseProtection TaintNodesByCondition ValidatingAdmissionWebhook</description></item><item><title>最佳实践</title><link>https://desistdaydream.github.io/docs/10.%E4%BA%91%E5%8E%9F%E7%94%9F/Kubernetes/API-%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6/%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/10.%E4%BA%91%E5%8E%9F%E7%94%9F/Kubernetes/API-%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6/%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/</guid><description>创建一个超级权限 创建一个 ServiceAccount kubectl create serviceaccount -n user-sa-manage test-admin 将该 ServiceAccount 绑定到 cluster-admin 这个 clusterrole，以赋予最高权限 kubectl create clusterrolebinding test-admin &amp;ndash;clusterrole=cluster-admin &amp;ndash;serviceaccount=user-sa-manage:test-admin 此时，sa 账户就具有超级权限了，可以通过该 sa 的 token 给应用程序使用，以便可以最大化操作集群 获取 TOKEN kubectl get secrets -n user-sa-manage -o jsonpath=&amp;quot;{.items[?(@.metadata.annotations[&amp;lsquo;kubernetes.io/service-account.name&amp;rsquo;]==&amp;lsquo;test-admin&amp;rsquo;)].data.token}&amp;quot;|base64 -d 使用 Service Account 的 Token 创建非管理员用户 如果想要使用 Token 对集群进行操作，其实，并不一定要创建一个 KubeConfig 文件，在通过 Kubernetes API 获取集群信息时，直接使用 Token 认证的方式即可，比如：
kubernetes-dashboard 的 web 登录可以使用 Token 通过 REST 访问 API 可以传递 Authorization: Bearer ${TOKEN} 请求头时使用 Token。 创建 SA，并为 SA 授权 创建一个名称空间，专门用来存放 SA。然后创建一个名为 lch 的 SA。</description></item></channel></rss>