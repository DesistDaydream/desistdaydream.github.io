<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>断念梦 – 2.Kubelet 节点代理</title><link>https://desistdaydream.github.io/docs/10.%E4%BA%91%E5%8E%9F%E7%94%9F/2.3.Kubernetes-%E5%AE%B9%E5%99%A8%E7%BC%96%E6%8E%92%E7%B3%BB%E7%BB%9F/2.Kubelet-%E8%8A%82%E7%82%B9%E4%BB%A3%E7%90%86/</link><description>Recent content in 2.Kubelet 节点代理 on 断念梦</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><atom:link href="https://desistdaydream.github.io/docs/10.%E4%BA%91%E5%8E%9F%E7%94%9F/2.3.Kubernetes-%E5%AE%B9%E5%99%A8%E7%BC%96%E6%8E%92%E7%B3%BB%E7%BB%9F/2.Kubelet-%E8%8A%82%E7%82%B9%E4%BB%A3%E7%90%86/index.xml" rel="self" type="application/rss+xml"/><item><title>Docs: 2.Kubelet 节点代理</title><link>https://desistdaydream.github.io/docs/10.%E4%BA%91%E5%8E%9F%E7%94%9F/2.3.Kubernetes-%E5%AE%B9%E5%99%A8%E7%BC%96%E6%8E%92%E7%B3%BB%E7%BB%9F/2.Kubelet-%E8%8A%82%E7%82%B9%E4%BB%A3%E7%90%86/2.Kubelet-%E8%8A%82%E7%82%B9%E4%BB%A3%E7%90%86/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/10.%E4%BA%91%E5%8E%9F%E7%94%9F/2.3.Kubernetes-%E5%AE%B9%E5%99%A8%E7%BC%96%E6%8E%92%E7%B3%BB%E7%BB%9F/2.Kubelet-%E8%8A%82%E7%82%B9%E4%BB%A3%E7%90%86/2.Kubelet-%E8%8A%82%E7%82%B9%E4%BB%A3%E7%90%86/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://kubernetes.io/docs/reference/command-line-tools-reference/kubelet/">官方文档，参考-组件工具-kubelet&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>Kubelet 是在每个节点上运行的主要“节点代理”。它可以使用以下之一向 APIServer 注册节点：用于覆盖主机名的标志；或云提供商的特定逻辑。&lt;/p>
&lt;p>kubelet 根据 PodSpec 起作用。 PodSpec 是一个描述 Pod 的 YAML 或 JSON 对象。 kubelet 接受通过各种机制（主要是通过 apiserver）提供的一组 PodSpec，并确保这些 PodSpec 中描述的容器正在运行且运行状况良好。 Kubelet 不管理不是 Kubernetes 创建的容器。一般情况， PodSpec 都是由在 k8s 对象的 yaml 文件中定义的。&lt;/p>
&lt;p>kubelet 负责维护容器(CNI)的生命周期，同时也负责 Volume（CVI）和 Network（CNI）的管理。kubernetes 集群的宿主机上，启动的每一个 pod 都有由 kubelet 这个组件管理的。&lt;/p>
&lt;p>kubelet 在每个 Node 上都会启动一个 kubelet daemon 进程，默认监听在 &lt;strong>10250&lt;/strong> 端口。该进程用于处理 Master 节点(主要是 apiserver)下发到本节点的任务，管理 Pod 以及 Pod 中的容器。每个 kubelet 进程会在 APIServer 上注册节点自身信息，定期向 Master 节点汇报节点资源的使用情况，并通过 cAdvisor(kubelet 内部功能) 监控容器和节点资源。10248 为 kubelet 健康检查的 healthz 端口&lt;/p>
&lt;p>Note:如果 master 节点不运行 pod 的话，是不用部署 kubelet 的。&lt;/p>
&lt;p>kubelet 使用 PodSpec 来对其所在节点的 Pod 进行管理，PodSpec(Pod Specification)是描述 pod 的 yaml 或者 json 对象。PodSpec 一般是 yaml 或者 json 格式的文本文件。这些 PodSpecs 有 4 个来源&lt;/p>
&lt;ol>
&lt;li>apiserver：使用最多的方式，通过 kubectl 命令向 apiserver 提交 PodSpec 文件，然后 apiserver 再下发给相应节点的 node。还有一个通过 APIServer 监听 etcd 目录，同步 PodSpec&lt;/li>
&lt;li>File：kubelet 定期监控某个路径(默认路径为/etc/kubernetes/manifests)下所有文件，把这些文件当做 PodSpec，这种方式也就是所谓的 staticPod(静态 Pod)。默认情况下每 20 秒监控一下，可以通过 flag 进行配置，配置时可以指定具体的路径以及监控周期&lt;/li>
&lt;li>HTTP endpoint(URL)：使用&amp;ndash;manifest-url 参数，让 kubelet 每 20 秒检查一次 URL 指定的 endpoint(端点)&lt;/li>
&lt;li>HTTP server：kubelet 监听 HTTP 请求，并响应简单的 API 以提交新的 Pod 清单&lt;/li>
&lt;/ol>
&lt;h2 id="static-pod静态-pod">Static Pod：静态 Pod&lt;/h2>
&lt;p>所有以非 API Server 方式创建的 Pod 都叫 Static Pod。&lt;/p>
&lt;p>kubelet 的工作核心，就是一个控制循环。驱动这个控制循环运行的实践，包括四种&lt;/p>
&lt;ol>
&lt;li>Pod 更新事件&lt;/li>
&lt;li>Pod 生命周期变化&lt;/li>
&lt;li>kubelet 本身设置的执行周期&lt;/li>
&lt;li>定时的清理事件&lt;/li>
&lt;/ol>
&lt;p>注意：kubelet 调用下层容器运行时的执行过程，并不会直接调用 Docker 的 API，而是通过一组叫作 CRI（Container Runtime Interface，容器运行时接口）的 gRPC 接口来间接执行的。gRPC 接口规范详见官网：&lt;a href="https://grpc.io/docs/">https://grpc.io/docs/&lt;/a>&lt;/p>
&lt;p>kubelet 是集群的基础设施，其他主要组件如果不以 daemon 形式运行，则依赖 kubelet 以 pod 方式启动，这样，才可以组成集群最基本的形态。&lt;/p>
&lt;h2 id="kubelet-metrics">Kubelet Metrics&lt;/h2>
&lt;p>详见：k8s 主要组件 metrics 获取指南&lt;/p>
&lt;h1 id="kubelet-部署">Kubelet 部署&lt;/h1>
&lt;pre>&lt;code>cat &amp;lt;&amp;lt;EOF &amp;gt; /etc/yum.repos.d/kubernetes.repo
[kubernetes]
name=Kubernetes
baseurl=https://mirrors.aliyun.com/kubernetes/yum/repos/kubernetes-el7-x86_64/
enabled=1
gpgcheck=1
repo_gpgcheck=1
gpgkey=https://mirrors.aliyun.com/kubernetes/yum/doc/yum-key.gpg https://mirrors.aliyun.com/kubernetes/yum/doc/rpm-package-key.gpg
EOF
yum install -y kubelet
&lt;/code>&lt;/pre>
&lt;h1 id="kubelet-关联文件与配置">Kubelet 关联文件与配置&lt;/h1>
&lt;p>kubelet 可以通过多个地方读取其自身的配置并更改自己的行为方式，可以通过指定的 yaml 格式的文件读取配置信息，也可以直接指定命令行参数传递到 kubelet 程序中。&lt;/p>
&lt;p>&lt;strong>/var/lib/kubelet/*&lt;/strong> # kubelet 配置文件目录、以及运行时数据目录，包含基础配置文件、证书、通过 kubelet 启动的容器信息等等&lt;/p>
&lt;ul>
&lt;li>./config.yaml # kubelet 基础配置文件。一般在 kubelet 启动时使用 &amp;ndash;cofnig 参数指定该读取该文件的路径进行加载。
&lt;ul>
&lt;li>Note：该文件内容与 kubectl get configmap -n kube-system kubelet-config-X.XX -o yaml 命令所得结果一样
&lt;ul>
&lt;li>如果想要在 kubelet 运行时动态得更改其配置，则可以修改 configmap 中的内容，详见：&lt;a href="https://kubernetes.io/docs/tasks/administer-cluster/reconfigure-kubelet/">https://kubernetes.io/docs/tasks/administer-cluster/reconfigure-kubelet/&lt;/a>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>./kubeadm-flags.env # 该文件将内容作为 kubelet 参数，在 kubelet 启动时加载，常用来在 kubeadm 初始化时使用&lt;/li>
&lt;li>./pods/* # kubelet 启动的 Pod 的数据保存路径，其内目录名为 Pod 的 uid 。
&lt;ul>
&lt;li>./${POD_UID}/volumes/* # 对应 pod 挂载的 volume 保存路径，其内目录为 kubernetes.io~TYPE ，其中 TYPE 为 volume 的类型。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>./pki/* # kubelet 与 apiserver 交互时所用到的证书存放目录。
&lt;ul>
&lt;li>./kubelet.crt # 在 kubelet 完成 TLS bootstrapping 后并且没有配置 &amp;ndash;feature-gates=RotateKubeletServerCertificate=true 时生成；这种情况下该文件为一个独立于 apiserver CA 的自签 CA 证书，有效期为 1 年；被用作 kubelet 10250 api 端口。当其他东西需要访问 kubelet 的 api 时，需要使用该证书作为认证。&lt;/li>
&lt;li>./kubelet-client-current.pem # 与 API server 通讯所用到的证书，与 apiserver 交互后生成。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>/etc/kubernetes/*&lt;/strong> # Kubernetes 系统组件运行时目录。&lt;/p>
&lt;ul>
&lt;li>./manifests/* # Kubelet 默认从该目录中读取 Pod 的 Manifests 文件，以运行静态类型 Pod。&lt;/li>
&lt;li>kubelet 在 k8s 集群交互时认证文件所在目录，kubelet 需要读取认证配置，用来与 apiserver 进行交互。
&lt;ul>
&lt;li>./bootstrap-kubelet.conf # 用于 TLS 引导程序的 KubeConfig 文件。该 kubeconfig 文件的用户信息为 token。该文件用于 kubelet 所在节点不在集群中时，向集群发起注册请求所用，如果节点已在集群中，则会自动生成 kubelet.conf 文件&lt;/li>
&lt;li>./kubelet.conf # 具有唯一 kubelet 标识的 KubeConfig 文件(与 kubectl 的 config 文件一样，用于 kubelet 与 apiserver 交互时提供认证信息)。该 kubeconfig 文件的用户信息为客户端证书和私钥，一般在 kubelet 启动时由 bootstrap-kubelet.conf 文件生成。
&lt;ul>
&lt;li>当该文件不存在时，会在 kubelet 启动时，由 bootstrap-kubelet.confg 生成&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>/etc/sysconfig/kubelet&lt;/strong> # 与 /var/lib/kubelet/kubeadm-flags.env 文件作用一样 ，将内容作为 kubelet 参数，在 kubelet 启动时加载。一般用于让用户指定 kubelet 的运行时参数 。 KUBELET_EXTRA_ARGS 在标志链中排在最后，并且在其他设置冲突时具有最高优先级。&lt;/p>
&lt;ul>
&lt;li>Note：对于 DEB 系统，配置文件位于：/etc/default/kubelet&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>/usr/lib/systemd/system/kubelet.service.d/10-kubeadm.confg&lt;/strong> # 与 kubelet 守护进程运行参数&lt;/p>
&lt;h1 id="kubelet-的启动过程--kubelet-与-apiserver-的交互说明">Kubelet 的启动过程 &amp;amp;&amp;amp; Kubelet 与 APIServer 的交互说明&lt;/h1>
&lt;h2 id="kubelet-启动过程">kubelet 启动过程：&lt;/h2>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>kubelet 启动流程源码分析&lt;/li>
&lt;li>&lt;a href="https://xiaohanliang.gitbook.io/notes/k8s/zhi-shi-yu-ding-yi/jie-dian-zu-jian-kubelet/kubelet-qi-dong-liu-cheng">https://xiaohanliang.gitbook.io/notes/k8s/zhi-shi-yu-ding-yi/jie-dian-zu-jian-kubelet/kubelet-qi-dong-liu-cheng&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.jianshu.com/p/e07d84cce9f9">https://www.jianshu.com/p/e07d84cce9f9&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;ol>
&lt;li>读取配置 kubelet 配置文件。kubelet 启动时首先会根据 &lt;code>--config=PATH&lt;/code> 参数指定路径(默认 /var/lib/kubelet/config.yaml)读取配置文件，并根据其内配置加载 kubelet 相关参数，
&lt;ol>
&lt;li>根据 ca 配置路径加载 ca.crt 文件，并在 /var/lib/kubelet/pki 目录下生成关于 kubelet 的 10250 私有 api 端口所需的 crt 与 key 文件。&lt;/li>
&lt;li>如果该文件不存在或有问题，则启动失败。&lt;/li>
&lt;/ol>
&lt;/li>
&lt;li>配置与 apiserver 通信的 kubeconfig 文件。根据 &amp;ndash;bootstrap-kubeconfig=PATH 参数加载 /etc/kubernetes/bootstrap-kubelet.conf 文件(如果不存在则根据 &amp;ndash;kubeconfig=PATH 参数加载 /etc/kubernetes/kubelet.conf 文件)，两个文件都不存在则报错
&lt;ol>
&lt;li>如果当前节点不在集群中，则会执行证书申请操作
&lt;ol>
&lt;li>首先 kubelet 向 bootstrap-kubelet.conf 文件内配置的 apiserver(文件中 server 的配置) 发送加入集群的申请申，同时 kubelet 会根据 bootstrap-kubelet.conf 文件生成 kubelet.conf 文件，将该 kubeconfig 文件中的 user 认证方式改为证书认证方式，并指定证书路径为/var/lib/kubelet/pki/kubelet-client-current.pem。&lt;/li>
&lt;li>在集群 master 上执行 kubectl get csr 命令获取当前申请列表，并使用 kubectl certificate approve XXXX 命令通过该节点的申请&lt;/li>
&lt;li>master 节点的 controller-manager 处理完该请求后，本地 kubelet 将生成 kubelet.conf 文件所需证书，并保存在 /var/lib/kubelet/pki/ 目录下，以 /var/lib/kubelet/pki/kubelet-client-current.pem-TIME 命名，并建立软件链接指向该文件。&lt;/li>
&lt;/ol>
&lt;/li>
&lt;li>如果当前节点已在集群中，则会根据 bootstrap-kubelet.conf 文件生成 kubelet.conf 文件，且根据 kubelet.conf 文件中的证书信息与 apiserver 进行通信。&lt;/li>
&lt;li>如果当前节点已在集群且存在 kubelet.conf 文件，则使用该 kubeconfig 文件与 apiserver 进行交互后执行后续操作&lt;/li>
&lt;/ol>
&lt;/li>
&lt;li>初始化 kubelet 组件内部模块
&lt;ol>
&lt;li>会在 /var/lib/kubelet 目录下添加相关文件，用以驱动 pod 及 kubelet 相关功能。&lt;/li>
&lt;li>检查 cgroup 驱动设置与 CRI 的 cgroup 驱动设置是否一致，如果不一致则启动失败&lt;/li>
&lt;li>等等操作，后续有发现再补充&lt;/li>
&lt;/ol>
&lt;/li>
&lt;li>启动 kubelet 内部模块及服务(Note：当 csr 申请发送后，即可执行后续工作，无需等待申请审批通过)&lt;/li>
&lt;/ol>
&lt;h2 id="kubelet-启动后的工作原理">kubelet 启动后的工作原理&lt;/h2>
&lt;p>kubelet 的工作核心就是在围绕着不同的生产者生产出来的不同的有关 pod 的消息来调用相应的消费者（不同的子模块）完成不同的行为(创建和删除 pod 等)，即图中的控制循环（SyncLoop），通过不同的事件驱动这个控制循环运行。如下图所示：
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/rf1qwi/1616120074647-12f084c2-e91c-475d-93d4-f4e3fd3e61ef.png" alt="">&lt;/p>
&lt;h3 id="kubelet-创建-pod-流程">kubelet 创建 pod 流程&lt;/h3>
&lt;p>参考：
&lt;a href="https://www.jianshu.com/p/5e0c9d1dbe95">https://www.jianshu.com/p/5e0c9d1dbe95&lt;/a>
&lt;a href="https://www.kubernetes.org.cn/6766.html">https://www.kubernetes.org.cn/6766.html&lt;/a>
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/rf1qwi/1616120074625-d25d5fad-d58b-4142-958d-b1aee16d8e71.png" alt="">&lt;/p>
&lt;p>Note：注意 14，,15 步，kubelet 会先将生成配置(volume 挂载、配置主机名等等)，才会去启动 pod，哪怕 pod 启动失败，挂载依然存在。&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/rf1qwi/1616120074636-5f1f460b-6cf2-4190-ab01-6284178805e6.png" alt="">&lt;/p>
&lt;h1 id="kubelet-所管理三大板块">Kubelet 所管理三大板块&lt;/h1>
&lt;h2 id="kubelet-负责所在节点-containercri-的管理">kubelet 负责所在节点 Container(CRI) 的管理&lt;/h2>
&lt;p>CRI 的起源：
官方介绍：&lt;a href="https://kubernetes.io/blog/2016/12/container-runtime-interface-cri-in-kubernetes/">https://kubernetes.io/blog/2016/12/container-runtime-interface-cri-in-kubernetes/&lt;/a>&lt;/p>
&lt;p>Kubernetes 项目之所以要在 kubelet 中引入这样一层单独的抽象，是为了对 Kubernetes 屏蔽下层容器运行时的差异。因为 Kubernets 是一个编排工具，不只可以编排 Docker，还可以编排除 Docker 以外的其余的容器项目。而每种容器项目的实现方式不尽相同，为了解决这个问题，那么可以把 kubelet 对容器的操作，统一抽象成一个借口，这样，kubelet 就只需要跟这个借口打交道，而作为具体的容器项目，它们只需要自己提供一个该接口的实现，然后对 kubelet 暴露出 gRPC 服务即可(docker shim 现在集成在了 kubelet 中，以后会单独拿出来甚至废弃)&lt;/p>
&lt;p>CRI 的运作方式：&lt;/p>
&lt;ul>
&lt;li>当 kubernetes 通过编排能力声明一个 Pod 后，调度器会为这个 pod 选择一个具体的 Node 来运行，这时候，该 Node 上的 kubelet 会通过 SyncLoop 判断需要执行的具体操作，这个时候 kubelet 会调用一个叫做 GenericRuntime 的通用组件来发起创建 Pod 的 CRI 请求。&lt;/li>
&lt;li>CRI shim(CRI 垫片，宿主机与 kubelet 之间的东西)来响应 CRI 请求，然后把请求“翻译”成对后端容器项目的请求或者操作。&lt;/li>
&lt;li>每个容器项目都会自己实现一个 CRI shim，然后 CRI shim 收到的请求会转给对应的容器守护进程(e.g.docker 项目里的 dockerd)，由该守护进程进行容器的创建、更改、删除、exec 等操作&lt;/li>
&lt;/ul>
&lt;p>当前主流的 CRI 有如下几种：&lt;/p>
&lt;ul>
&lt;li>Docker(kubelet 默认的 CRI)
&lt;ul>
&lt;li>Note：kubelet 内置 dockershim，在启动或，会生成 dockersim.sock 文件，kubelet 与 crictl 都会默认与该文件关联&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>CRI-O&lt;/li>
&lt;li>Containerd(通常与 docker 同时安装)&lt;/li>
&lt;li>Frakti(kata OCI 的实现)&lt;/li>
&lt;/ul>
&lt;p>kubelet 与 CRI 对接的方式&lt;/p>
&lt;ul>
&lt;li>kubelet 根据参数 &amp;ndash;container-runtime-endpoint 来决定其所绑定的 CRI sock。默认使用 docker 的 sock，路径为：/var/run/dockershim.sock
&lt;ul>
&lt;li>可以通过 crictl 工具来测试目标 sock 是否可用，crictl 用法详见：crictl 命令行工具&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>如果使用不同的 CRI 运行时，则需要为 kubelet 指定不同的 flag。 例如，当使用非 docker CRI 时， 则需要使用 &amp;ndash;container-runtime=remote 与 &amp;ndash;container-runtime-path-endpoint=&amp;lt;PATH&amp;gt; 指定 CRI 端点。endpoint 的值为指定 CRI 的 sock 文件。&lt;/li>
&lt;li>各个 CRI 需要进行配置才可与 kubelet 对接成功，如果不进行初始化配置，则 kubelet 无法获取到该 CRI 对于 k8s 的相关配置参数&lt;/li>
&lt;/ul>
&lt;p>kubelet 通过如下两个命令行标志来指定要使用的 CRI&lt;/p>
&lt;pre>&lt;code>--container-runtime=remote
--container-runtime-endpoint=unix:///run/containerd/containerd.sock
&lt;/code>&lt;/pre>
&lt;h2 id="kubelet-负责所在节点-networkcni-的管理">kubelet 负责所在节点 Network(CNI) 的管理&lt;/h2>
&lt;p>kubelet 对 cni(Container Network Interface 容器网络接口)的调用详见另一片关于网络介绍的文章：&lt;a href="https://www.yuque.com/go/doc/33164217">Kubernetes 的网络&lt;/a>&lt;/p>
&lt;p>kubelet 配置 pod 网络时，首先会读取下 /etc/cni/net.d/_ 目录下的配置，查看当前所使用的 CNI 插件及插件参数，比如现在是 flannel ，那么 flannel 会将 /run/flannel/subnet.env 文件的配置信息传递给 kubelet ，然后 kubelet 使用 /opt/cni/bin/_ 目录中的二进制文件，来处理处理 pod 的网络信息。&lt;/p>
&lt;h2 id="kubelet-负责所在节点-volumecvi-的管理">kubelet 负责所在节点 Volume(CVI) 的管理&lt;/h2></description></item><item><title>Docs: CRI 对比</title><link>https://desistdaydream.github.io/docs/10.%E4%BA%91%E5%8E%9F%E7%94%9F/2.3.Kubernetes-%E5%AE%B9%E5%99%A8%E7%BC%96%E6%8E%92%E7%B3%BB%E7%BB%9F/2.Kubelet-%E8%8A%82%E7%82%B9%E4%BB%A3%E7%90%86/CRI-%E5%AF%B9%E6%AF%94/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/10.%E4%BA%91%E5%8E%9F%E7%94%9F/2.3.Kubernetes-%E5%AE%B9%E5%99%A8%E7%BC%96%E6%8E%92%E7%B3%BB%E7%BB%9F/2.Kubelet-%E8%8A%82%E7%82%B9%E4%BB%A3%E7%90%86/CRI-%E5%AF%B9%E6%AF%94/</guid><description>
&lt;p>原文：&lt;a href="https://mp.weixin.qq.com/s/H3vUUvEiOfLkd_YEoo8sNg">阳明公众号&lt;/a>&lt;/p>
&lt;p>下面是我已经测试的几个 CRI，并进行一些基准测试来对他们进行了简单的对比，希望对你有所帮助：&lt;/p>
&lt;ul>
&lt;li>dockershim&lt;/li>
&lt;li>containerd&lt;/li>
&lt;li>crio&lt;/li>
&lt;/ul>
&lt;p>对于 cri-o，已经测试了 2 个后端：runc 和 crun，以测试对 &lt;code>cgroupsv2&lt;/code> 的影响。&lt;/p>
&lt;h2 id="测试环境">测试环境&lt;/h2>
&lt;p>我这里的测试环境是一个 1.19.4 版本的 kubernetes 集群，使用 ansible 进行创建（&lt;a href="https://gitlab.com/incubateur-pe">https://gitlab.com/incubateur-pe&lt;/a>）。集群运行在 kvm 上，配置如下：&lt;/p>
&lt;ul>
&lt;li>master：Centos/7, 2vcpus/2G 内存。&lt;/li>
&lt;li>crio-crun 节点：Fedora-32, 2vcpus/4G 内存。&lt;/li>
&lt;li>其他节点：Centos/7, 2vcpus/4G 内存.&lt;/li>
&lt;/ul>
&lt;p>底层是 i7-9700K ，64G 的内存和一个 mp510 nvme 硬盘。&lt;/p>
&lt;h2 id="创建集群">创建集群&lt;/h2>
&lt;p>这里我直接使用 molecule 创建一个集群，并配置了它在每个 worker 节点上使用不同的 cri，对应的 ansible 源码位于：&lt;a href="https://gitlab.com/incubateur-pe/kubernetes-bare-metal/-/tree/dev/molecule/criBench">https://gitlab.com/incubateur-pe/kubernetes-bare-metal/-/tree/dev/molecule/criBench&lt;/a>&lt;/p>
&lt;p>使用上面的脚本，执行 &lt;code>molecule converge&lt;/code> 命令后，大概 10 分钟左右，我们就可以得到一个如下所示的 kubernetes 集群。&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/czfhxy/1616120034837-61ee3a87-ccca-4c3a-91ff-983ad9808b6d.png" alt="">&lt;/p>
&lt;p>接下来我们就可以进行一些简单的基准测试了。&lt;/p>
&lt;h2 id="测试">测试&lt;/h2>
&lt;h3 id="1-bucketbench-测试">1. bucketbench 测试&lt;/h3>
&lt;p>Bucketbench (&lt;a href="https://github.com/estesp/bucketbench">https://github.com/estesp/bucketbench&lt;/a>) 是一个可以对容器引擎执行一系列操作的测试工具，它非常适合于了解之前每个节点的性能。&lt;/p>
&lt;p>这里我们的测试参数很简单：&lt;/p>
&lt;ul>
&lt;li>3 个线程&lt;/li>
&lt;li>15 次循环&lt;/li>
&lt;li>run/stop/delete 操作&lt;/li>
&lt;/ul>
&lt;p>对应的结果如下所示（ms 为单位）：&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/czfhxy/1616120034822-55f1f7a0-b8cf-422b-9490-f0a7b5f8593d.png" alt="">&lt;/p>
&lt;p>我们可以看到在性能上还是有相当大的差异的。但是需要注意的是我们这里为什么测试了 5 个实例呢？上面不是只有 4 个 worker 节点吗？&lt;/p>
&lt;p>这里其实是因为这里我们使用的 docker 客户端并不是 kubernetes 使用的，事实上 docker 实现了 CRI，并提供了一个 socket，这个 socket 和其他 cri socket 一样可以调用。所以这里的区别是：&lt;/p>
&lt;ul>
&lt;li>docker-shim：是通过 cri 的 socket 来做测试&lt;/li>
&lt;li>docker-cli：是通过 docker 客户端来做测试&lt;/li>
&lt;/ul>
&lt;p>但是实际上 docker 并没有想象中那么差，在这个测试中我们可以看到他比 cri-o 要快点，当然这个测试中很明显 dockerd 是表现最好的。&lt;/p>
&lt;h3 id="2-kubernetes-测试">2. kubernetes 测试&lt;/h3>
&lt;p>上面的测试并不能完整说明这几个 cri 之间的差距，当它们被 kubernetes 使用的时候，它们表现又如何呢？是否不止 &lt;code>run/stop/delete&lt;/code> 这些操作？性能上的差异在真正的集群上又有什么意义吗?&lt;/p>
&lt;p>下面我们就来深入了解下，这次我们使用集群中的 Prometheus、Grafana 来可视化监控指标，对应的自定义 dashboard 数据可以在 &lt;a href="https://gitlab.com/ulrich.giraud/bench-cri/-/blob/master/dashboard/dashboard_bench.json">https://gitlab.com/ulrich.giraud/bench-cri/-/blob/master/dashboard/dashboard_bench.json&lt;/a> 这里获取。由于只是测试容器运行时，不是工作负载，所以这里我们只是简单的在集群中部署的一个 busybox 镜像并一直 sleep 的 DaemonSet 应用。&lt;/p>
&lt;pre>&lt;code>apiVersion: apps/v1kind: DaemonSetmetadata: name: benchds-replaceme namespace: benchds labels: k8s-app: benchdsspec: selector: matchLabels: name: benchds template: metadata: labels: name: benchds spec: containers: - name: benchds image: busybox:latest command: - sleep - infinity resources: limits: memory: 20Mi requests: cpu: 10m memory: 20Mi
&lt;/code>&lt;/pre>
&lt;p>该 DamonSet 将用唯一的名称进行部署：&lt;/p>
&lt;ul>
&lt;li>100 次（两次创建之间有一定延迟）&lt;/li>
&lt;li>批量 100 次&lt;/li>
&lt;li>批量 1000 次&lt;/li>
&lt;/ul>
&lt;p>对应的 Grafana 展示图表信息如下所示：&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/czfhxy/1616120034839-e6353428-f475-4c08-9be7-73a5d7b656c2.png" alt="">&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/czfhxy/1616120034856-b41bdfbc-a4b4-477a-914c-95f009b88193.png" alt="">&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/czfhxy/1616120034825-ef0d77c9-202f-45f6-aeb5-6282f10214e7.png" alt="">&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/czfhxy/1616120034888-e1840303-2907-45d0-a780-05119ec475eb.png" alt="">&lt;/p>
&lt;p>缓慢创建数百个 DaemonSets&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/czfhxy/1616120034850-86008be9-f893-47c9-a20b-d18523e12d20.png" alt="">&lt;/p>
&lt;p>快速创建数百个 DaemonSets&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/czfhxy/1616120034854-a1a537e5-e71e-4313-aec4-42265497e49d.png" alt="">&lt;/p>
&lt;p>快速创建数千个 DaemonSets&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/czfhxy/1616120034848-339697b7-b147-4af4-aae5-08728a93332c.png" alt="">&lt;/p>
&lt;p>现在我们来分析下上面的测试结果。&lt;/p>
&lt;ul>
&lt;li>Cri-o/runc：令人惊讶的是，在所有 create/delete 中是最慢的，但在其他方面处于中等水平。&lt;/li>
&lt;li>Cri-o/crun：在 create/delete 方面不是很好，但是在其他方面表现是最好的。&lt;/li>
&lt;li>Containerd：表现非常好，几乎在所有情况下都可以快速响应。&lt;/li>
&lt;li>Docker：在 create/delete 方面比 cri-o 快，但在 status/list 请求方面是最慢的。&lt;/li>
&lt;/ul>
&lt;p>status/list 请求是 cri 上最频繁的请求，所以这也是性能最重要的地方，cri-o 在这里似乎是更好的选择，其次就是 containerd。&lt;/p>
&lt;p>containerd 在所有指标上的表现都比较好，应该是最均衡的一个选择了。另外一方面，docker 并没有得到很好的测试结果，但是无论负载情况如何，它的表现基本上都是一致的。&lt;/p>
&lt;h2 id="总结">总结&lt;/h2>
&lt;p>从纯性能角度来说，确实有比 docker 更好的替代品，我们的集群也不会替换 docker 产生什么影响。从另外一个角度来看，kubernetes 这次废弃 docker 的事情也算是一件好事，让更多的人意识到 docker 并不是唯一可用的 CRI，甚至不是唯一的构建镜像工具。&lt;/p>
&lt;p>在我看来，docker 仍然是让整个容器化向前发展的一个伟大工具。但是好像我还没有回答我最初的问题，那就是：我应该为我的 k8s 集群使用什么 CRI？&lt;/p>
&lt;p>从我个人角度考虑的话，我个人的选择是：containerd，他速度快，配置方便，相当可靠和安全，不过 cri-o 已经支持 cgroupsv2 了，所以如果我使用 fedora 或者 centos/8 的话我会优先选择 cri-o。&lt;/p>
&lt;blockquote>
&lt;p>原文链接：&lt;a href="https://ulrich-giraud.medium.com/which-cri-should-i-use-to-replace-docker-for-my-kubernetes-cluster-14a45c080004">https://ulrich-giraud.medium.com/which-cri-should-i-use-to-replace-docker-for-my-kubernetes-cluster-14a45c080004&lt;/a>&lt;/p>
&lt;/blockquote></description></item><item><title>Docs: crictl 命令行工具</title><link>https://desistdaydream.github.io/docs/10.%E4%BA%91%E5%8E%9F%E7%94%9F/2.3.Kubernetes-%E5%AE%B9%E5%99%A8%E7%BC%96%E6%8E%92%E7%B3%BB%E7%BB%9F/2.Kubelet-%E8%8A%82%E7%82%B9%E4%BB%A3%E7%90%86/crictl-%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%B7%A5%E5%85%B7/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/10.%E4%BA%91%E5%8E%9F%E7%94%9F/2.3.Kubernetes-%E5%AE%B9%E5%99%A8%E7%BC%96%E6%8E%92%E7%B3%BB%E7%BB%9F/2.Kubelet-%E8%8A%82%E7%82%B9%E4%BB%A3%E7%90%86/crictl-%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%B7%A5%E5%85%B7/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://github.com/kubernetes-sigs/cri-tools">项目地址&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://kubernetes.io/docs/tasks/debug-application-cluster/crictl/">使用 crictl 对 kubernetes 进行调试&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>crictl 用于为 kubelet CRI 进行调试的 命令行工具&lt;/p>
&lt;p>cri-tools 旨在为 Kubelet CRI 提供一系列调试和验证工具，其中包括：&lt;/p>
&lt;ul>
&lt;li>crictl: kubelet 的 CRI 命令行工具&lt;/li>
&lt;li>critest:kubelet CRI 的验证测试套件&lt;/li>
&lt;/ul>
&lt;p>用白话说就是：kubelet 如果要与 CRI 对接，那么如何检测对接成功呢，就是使用 crictl 工具来测试。还可以对已经与 kubelet 建立连接的 CRI 执行相关操作，比如启停容器等。&lt;/p>
&lt;p>Note：要想使用 crictl 命令行工具，必须要先进行配置，指定好要操作的 CRI 的 endpoint，才可以正常使用&lt;/p>
&lt;h1 id="crictl-配置">crictl 配置&lt;/h1>
&lt;p>&lt;strong>/etc/crictl.yaml&lt;/strong> # crictl 命令行工具运行时配置文件&lt;/p>
&lt;h2 id="基本配置文件示例">基本配置文件示例&lt;/h2>
&lt;pre>&lt;code>runtime-endpoint: unix:///run/containerd/containerd.sock
image-endpoint: unix:///run/containerd/containerd.sock
timeout: 10
debug: true
&lt;/code>&lt;/pre>
&lt;h1 id="crictl-命令行工具">crictl 命令行工具&lt;/h1>
&lt;p>&lt;strong>crictl [Global OPTIONS] COMMAND [COMMAND OPETIONS] [ARGUMENTS&amp;hellip;]&lt;/strong>
COMMMAND&lt;/p>
&lt;ul>
&lt;li>attach Attach to a running container&lt;/li>
&lt;li>create Create a new container&lt;/li>
&lt;li>exec Run a command in a running container&lt;/li>
&lt;li>version Display runtime version information&lt;/li>
&lt;li>images List images&lt;/li>
&lt;li>inspect Display the status of one or more containers&lt;/li>
&lt;li>inspecti Return the status of one or more images&lt;/li>
&lt;li>inspectp Display the status of one or more pods&lt;/li>
&lt;li>logs Fetch the logs of a container&lt;/li>
&lt;li>port-forward Forward local port to a pod&lt;/li>
&lt;li>ps List containers&lt;/li>
&lt;li>pull Pull an image from a registry&lt;/li>
&lt;li>runp Run a new pod&lt;/li>
&lt;li>rm Remove one or more containers&lt;/li>
&lt;li>rmi Remove one or more images&lt;/li>
&lt;li>rmp Remove one or more pods&lt;/li>
&lt;li>pods List pods&lt;/li>
&lt;li>start Start one or more created containers&lt;/li>
&lt;li>&lt;strong>info&lt;/strong> # 显示与 crictl 对接的 CRI 信息&lt;/li>
&lt;li>stop Stop one or more running containers&lt;/li>
&lt;li>stopp Stop one or more running pods&lt;/li>
&lt;li>update Update one or more running containers&lt;/li>
&lt;li>config Get and set crictl options&lt;/li>
&lt;li>stats List container(s) resource usage statistics&lt;/li>
&lt;li>completion Output bash shell completion code&lt;/li>
&lt;li>help, h Shows a list of commands or help for one command&lt;/li>
&lt;/ul>
&lt;p>OPTIONS&lt;/p>
&lt;p>EXAMPLE&lt;/p>
&lt;ul>
&lt;li>crictl info # 显示与 crictl 对接的 CRI 信息&lt;/li>
&lt;li>crictl pull docker.io/lchdzh/pause:3.1 # 拉取 dockerhub 上的 lchdzh 中的 pause 镜像&lt;/li>
&lt;/ul></description></item><item><title>Docs: Kubelet 配置详解</title><link>https://desistdaydream.github.io/docs/10.%E4%BA%91%E5%8E%9F%E7%94%9F/2.3.Kubernetes-%E5%AE%B9%E5%99%A8%E7%BC%96%E6%8E%92%E7%B3%BB%E7%BB%9F/2.Kubelet-%E8%8A%82%E7%82%B9%E4%BB%A3%E7%90%86/Kubelet-%E9%85%8D%E7%BD%AE%E8%AF%A6%E8%A7%A3/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/10.%E4%BA%91%E5%8E%9F%E7%94%9F/2.3.Kubernetes-%E5%AE%B9%E5%99%A8%E7%BC%96%E6%8E%92%E7%B3%BB%E7%BB%9F/2.Kubelet-%E8%8A%82%E7%82%B9%E4%BB%A3%E7%90%86/Kubelet-%E9%85%8D%E7%BD%AE%E8%AF%A6%E8%A7%A3/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://kubernetes.io/zh/docs/setup/production-environment/tools/kubeadm/kubelet-integration/">官方文档，入门-生产环境-使用工具安装 Kubernetes-使用 kubeadm 引导集群-使用 kubeadm 配置集群中每个 kubelet&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://kubernetes.io/docs/reference/config-api/kubelet-config.v1beta1/">官方文档，参考-配置 APIs-Kubelet 配置(v1beta1)&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>可以通过两种方式配置 kubelet 运行时行为&lt;/p>
&lt;ol>
&lt;li>&lt;strong>config.yaml 配置文件&lt;/strong> # config.yaml 文件默认路径为 /var/lib/kubelet/config.yaml ，可以通过 &amp;ndash;config &amp;lt;FILE&amp;gt; 来指定其他的文件。
&lt;ol>
&lt;li>&lt;a href="https://kubernetes.io/docs/tasks/administer-cluster/kubelet-config-file/">这里&lt;/a>是官方文档对于配置文件的概述。在&lt;a href="https://github.com/kubernetes/kubernetes/blob/master/staging/src/k8s.io/kubelet/config/v1beta1/types.go">章节中间部分&lt;/a>，可以直接看到配置文件对应的代码中结构体，也就是配置文件详细内容&lt;/li>
&lt;li>&lt;a href="https://kubernetes.io/docs/reference/config-api/kubelet-config.v1beta1/">这里&lt;/a>是配置文件中每个字段的详解，与代码中的结构体互相对应，只不过是整理后，可以直接在网页上查看，更清晰。&lt;/li>
&lt;/ol>
&lt;/li>
&lt;li>&lt;strong>kubelet 命令行标志&lt;/strong>
&lt;ol>
&lt;li>&lt;a href="https://kubernetes.io/docs/reference/command-line-tools-reference/kubelet/">这里&lt;/a>是官方文档对命令行标志的详解&lt;/li>
&lt;/ol>
&lt;/li>
&lt;/ol>
&lt;p>官方更推荐使用第一种方式，通过 config.yaml 的文件修改，来改变 kubelet 的运行时参数。&lt;/p>
&lt;p>很多配置文件的内容与命令行标志具有一一对应的关系，比如：&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>配置文件&lt;/th>
&lt;th>命令行标志&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>cgroupDriver: systemd&lt;/td>
&lt;td>&amp;ndash;cgroup-driver=systemd&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>clusterDNS: [10.96.0.10,&amp;hellip;]&lt;/td>
&lt;td>&amp;ndash;cluster-dns=10.96.0.10,&amp;hellip;&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>authentication.x509.clientCAFile: /etc/kubernetes/pki/ca.crt&lt;/td>
&lt;td>&amp;ndash;client-ca-file=/etc/kubernetes/pki/ca.crt&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>等等&lt;/td>
&lt;td>等等&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>但是也有一些是没有对应关系的，只能通过配置文件，或者命令行标志配置。比如命令行标志的 &lt;code>--container-runtime&lt;/code> 就无法在配置文件中配置。在命令行标志官方文档中，凡是标着 &lt;code>DEPRECATED&lt;/code> 的命令行标志，都是可以在配置文件中配置的。&lt;/p>
&lt;h1 id="命令行标志详解">命令行标志详解&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://kubernetes.io/docs/reference/command-line-tools-reference/kubelet/">官方文档,参考-组件工具-kubelet&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>&lt;strong>&amp;ndash;cni-conf-dir &amp;lt;STRING&amp;gt;&lt;/strong> # Warning：Alpha 功能。指定 STRING 目录中搜索 CNI 配置文件。 &lt;code>默认值：/etc/cni/net.d&lt;/code>
仅当 CRI 为 docker 时此标志才有效&lt;/p>
&lt;p>&lt;strong>&amp;ndash;config=&amp;lt;STRING&amp;gt;&lt;/strong> # 加载配置文件的路径。kubelet 将从该标志指定的文件中加载其初始配置。&lt;/p>
&lt;p>&lt;strong>&amp;ndash;pod-infra-container-image &amp;lt;STRINIG&amp;gt;&lt;/strong> # 指定在每个 pod 中将会使用的 network/ipc 名称空间的基础容器。&lt;code>默认值：k8s.gcr.io/pause:3.1&lt;/code>
这个就是用来指定 infra 基础设施容器。&lt;/p>
&lt;p>&lt;strong>&amp;ndash;container-runtime &amp;lt;STRING&amp;gt;&lt;/strong> # kubelet 要使用的容器运行时，也就是要对接的 CRI。&lt;code>默认值：docker&lt;/code>。
remote # 表示使用其他运行时。需要配合 &lt;code>--container-runtime-endpoint&lt;/code> 标志一起使用。&lt;/p>
&lt;p>&lt;strong>&amp;ndash;container-runtime-endpoint &amp;lt;STRING&amp;gt;&lt;/strong> # kubelet 要使用的运行时的路径。&lt;code>默认值：unix:///var/run/dockershim.sock&lt;/code>
STRING 是 socket 路径，现阶段只支持 UNIX sock，后面还可以支持远程，比如通过 http 来连接运行时。&lt;/p>
&lt;p>**&amp;ndash;image-service-endpoint &amp;lt;STRING&amp;gt; **# kubelet 处理镜像所用的后端路径。若未指定，则于 &lt;code>--container-runtime-endpoint&lt;/code> 标志的值相同&lt;/p>
&lt;h1 id="配置文件详解">配置文件详解&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://kubernetes.io/docs/tasks/administer-cluster/kubelet-config-file/">官方文档,任务-通过配置文件设置 kubelet 参数&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://kubernetes.io/docs/reference/config-api/kubelet-config.v1beta1/">官方文档,参考-配置 APIs-Kubelet 配置&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://github.com/kubernetes/kubernetes/blob/master/staging/src/k8s.io/kubelet/config/v1beta1/types.go">代码&lt;/a> # 该代码是 Go 结构体与 JSON 格式的解析对应关系。其中的注释就是配置文件各字段的含义&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>**apiVersion: **kubelet.config.k8s.io/v1beta1
**kind: **KubeletConfiguration
**address: &amp;lt;STRING&amp;gt; **# kubelet 服务的 IP。默认为 0.0.0.0
**cgroupDriver: &amp;lt;cgroupfs|systemd&amp;gt; **# kubelet 用于操纵主机上 cgroup 的驱动程序。&lt;code>默认值：cgroupfs&lt;/code>
**imageMinimumGCAge: &amp;lt;DURATION&amp;gt; **# 未使用的 image 进行垃圾回收之前的最小期限。&lt;code>默认值：2m&lt;/code>
&lt;strong>nodeStatusReportFrequency: &amp;lt;DURATION&amp;gt;&lt;/strong> # 节点状态报告频率。&lt;code>默认值：10s&lt;/code>
&lt;strong>nodeStatusUpdateFrequency: &amp;lt;DURATION&amp;gt;&lt;/strong> # 节点状态更新频率。&lt;code>默认值：5m&lt;/code>
&lt;strong>resolvConf: &amp;lt;STRING&amp;gt;&lt;/strong> # kubelet 启动的容器所使用的解析器的配置文件。&lt;code>默认值：/etc/resolv.conf&lt;/code>&lt;/p>
&lt;ul>
&lt;li>Ubuntu 中，配置则会被改为 &lt;code>/run/systemd/resolve/resolv.conf&lt;/code>&lt;/li>
&lt;/ul>
&lt;h2 id="配置文件示例">配置文件示例&lt;/h2>
&lt;p>下面是 kubelet 1.18.8 版本的基本示例，其中通过 kubeadm 传递了 cgroupDriver 的值。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-yaml" data-lang="yaml">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">apiVersion&lt;/span>: &lt;span style="color:#ae81ff">kubelet.config.k8s.io/v1beta1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">kind&lt;/span>: &lt;span style="color:#ae81ff">KubeletConfiguration&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">authentication&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">anonymous&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">enabled&lt;/span>: &lt;span style="color:#66d9ef">false&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">webhook&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">cacheTTL&lt;/span>: &lt;span style="color:#ae81ff">0s&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">enabled&lt;/span>: &lt;span style="color:#66d9ef">true&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">x509&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">clientCAFile&lt;/span>: &lt;span style="color:#ae81ff">/etc/kubernetes/pki/ca.crt&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">authorization&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">mode&lt;/span>: &lt;span style="color:#ae81ff">Webhook&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">webhook&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">cacheAuthorizedTTL&lt;/span>: &lt;span style="color:#ae81ff">0s&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">cacheUnauthorizedTTL&lt;/span>: &lt;span style="color:#ae81ff">0s&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">cgroupDriver&lt;/span>: &lt;span style="color:#ae81ff">systemd&lt;/span> &lt;span style="color:#75715e">#kubelet 用于操纵主机上 cgroup 的驱动程序。 (默认为 cgroupfs )&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">clusterDNS&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#ae81ff">10.96.0.10&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">clusterDomain&lt;/span>: &lt;span style="color:#ae81ff">cluster.local&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">cpuManagerReconcilePeriod&lt;/span>: &lt;span style="color:#ae81ff">0s&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">evictionPressureTransitionPeriod&lt;/span>: &lt;span style="color:#ae81ff">0s&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">fileCheckFrequency&lt;/span>: &lt;span style="color:#ae81ff">0s&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">healthzBindAddress&lt;/span>: &lt;span style="color:#ae81ff">127.0.0.1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">healthzPort&lt;/span>: &lt;span style="color:#ae81ff">10248&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">httpCheckFrequency&lt;/span>: &lt;span style="color:#ae81ff">0s&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">imageMinimumGCAge&lt;/span>: &lt;span style="color:#ae81ff">0s&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">nodeStatusReportFrequency&lt;/span>: &lt;span style="color:#ae81ff">0s&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">nodeStatusUpdateFrequency&lt;/span>: &lt;span style="color:#ae81ff">0s&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">rotateCertificates&lt;/span>: &lt;span style="color:#66d9ef">true&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">runtimeRequestTimeout&lt;/span>: &lt;span style="color:#ae81ff">0s&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">staticPodPath&lt;/span>: &lt;span style="color:#ae81ff">/etc/kubernetes/manifests&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">streamingConnectionIdleTimeout&lt;/span>: &lt;span style="color:#ae81ff">0s&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">syncFrequency&lt;/span>: &lt;span style="color:#ae81ff">0s&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">volumeStatsAggPeriod&lt;/span>: &lt;span style="color:#ae81ff">0s&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div></description></item><item><title>Docs: Kubelet 特性</title><link>https://desistdaydream.github.io/docs/10.%E4%BA%91%E5%8E%9F%E7%94%9F/2.3.Kubernetes-%E5%AE%B9%E5%99%A8%E7%BC%96%E6%8E%92%E7%B3%BB%E7%BB%9F/2.Kubelet-%E8%8A%82%E7%82%B9%E4%BB%A3%E7%90%86/Kubelet-%E7%89%B9%E6%80%A7/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/10.%E4%BA%91%E5%8E%9F%E7%94%9F/2.3.Kubernetes-%E5%AE%B9%E5%99%A8%E7%BC%96%E6%8E%92%E7%B3%BB%E7%BB%9F/2.Kubelet-%E8%8A%82%E7%82%B9%E4%BB%A3%E7%90%86/Kubelet-%E7%89%B9%E6%80%A7/</guid><description/></item></channel></rss>