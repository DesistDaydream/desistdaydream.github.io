<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>断念梦 – 3.Pod 集群最小的工作单元</title><link>https://desistdaydream.github.io/docs/10.%E4%BA%91%E5%8E%9F%E7%94%9F/2.3.Kubernetes-%E5%AE%B9%E5%99%A8%E7%BC%96%E6%8E%92%E7%B3%BB%E7%BB%9F/3.Pod-%E9%9B%86%E7%BE%A4%E6%9C%80%E5%B0%8F%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8D%95%E5%85%83/</link><description>Recent content in 3.Pod 集群最小的工作单元 on 断念梦</description><generator>Hugo -- gohugo.io</generator><atom:link href="https://desistdaydream.github.io/docs/10.%E4%BA%91%E5%8E%9F%E7%94%9F/2.3.Kubernetes-%E5%AE%B9%E5%99%A8%E7%BC%96%E6%8E%92%E7%B3%BB%E7%BB%9F/3.Pod-%E9%9B%86%E7%BE%A4%E6%9C%80%E5%B0%8F%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8D%95%E5%85%83/index.xml" rel="self" type="application/rss+xml"/><item><title>Docs: Pod 的资源管理</title><link>https://desistdaydream.github.io/docs/10.%E4%BA%91%E5%8E%9F%E7%94%9F/2.3.Kubernetes-%E5%AE%B9%E5%99%A8%E7%BC%96%E6%8E%92%E7%B3%BB%E7%BB%9F/3.Pod-%E9%9B%86%E7%BE%A4%E6%9C%80%E5%B0%8F%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8D%95%E5%85%83/Pod-%E7%9A%84%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/10.%E4%BA%91%E5%8E%9F%E7%94%9F/2.3.Kubernetes-%E5%AE%B9%E5%99%A8%E7%BC%96%E6%8E%92%E7%B3%BB%E7%BB%9F/3.Pod-%E9%9B%86%E7%BE%A4%E6%9C%80%E5%B0%8F%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8D%95%E5%85%83/Pod-%E7%9A%84%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86/</guid><description/></item><item><title>Docs: Pod 生命周期</title><link>https://desistdaydream.github.io/docs/10.%E4%BA%91%E5%8E%9F%E7%94%9F/2.3.Kubernetes-%E5%AE%B9%E5%99%A8%E7%BC%96%E6%8E%92%E7%B3%BB%E7%BB%9F/3.Pod-%E9%9B%86%E7%BE%A4%E6%9C%80%E5%B0%8F%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8D%95%E5%85%83/Pod-%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/10.%E4%BA%91%E5%8E%9F%E7%94%9F/2.3.Kubernetes-%E5%AE%B9%E5%99%A8%E7%BC%96%E6%8E%92%E7%B3%BB%E7%BB%9F/3.Pod-%E9%9B%86%E7%BE%A4%E6%9C%80%E5%B0%8F%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8D%95%E5%85%83/Pod-%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/</guid><description/></item><item><title>Docs: 3.Pod 集群最小的工作单元</title><link>https://desistdaydream.github.io/docs/10.%E4%BA%91%E5%8E%9F%E7%94%9F/2.3.Kubernetes-%E5%AE%B9%E5%99%A8%E7%BC%96%E6%8E%92%E7%B3%BB%E7%BB%9F/3.Pod-%E9%9B%86%E7%BE%A4%E6%9C%80%E5%B0%8F%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8D%95%E5%85%83/3.Pod-%E9%9B%86%E7%BE%A4%E6%9C%80%E5%B0%8F%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8D%95%E5%85%83/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/10.%E4%BA%91%E5%8E%9F%E7%94%9F/2.3.Kubernetes-%E5%AE%B9%E5%99%A8%E7%BC%96%E6%8E%92%E7%B3%BB%E7%BB%9F/3.Pod-%E9%9B%86%E7%BE%A4%E6%9C%80%E5%B0%8F%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8D%95%E5%85%83/3.Pod-%E9%9B%86%E7%BE%A4%E6%9C%80%E5%B0%8F%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8D%95%E5%85%83/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://kubernetes.io/docs/concepts/workloads/pods/">官方文档,概念-工作负载-Pods&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>Pod 是 Kubernetes 的&lt;strong>最小工作单元&lt;/strong>，是一个逻辑概念。Kubernetes 真正处理的，还是通过 CRI 在 HostOS 上的 Namespace 和 Cgroups。所谓的 Pod 只是一组共享了某些资源的 Container，这一组 Container 共享同一个 NetworkNamespace 并且可以声明共享同一个 Volume。&lt;/p>
&lt;p>&lt;strong>Infrastructure(基础设施，简称 Infra) 容器&lt;/strong>：为了保证多个 Container 在共享的时候是对等关系(一般情况可以先启动 ContainerA，再启动 ContainerB 并共享 ContainerA 的资源，但是这样 A 与 B 不对等，A 是必须先启动才能启动 B)，需要一个中间 Container，即 &lt;strong>Infra 容器&lt;/strong>，Infra 容器 永远是第一个被创建的 Container，想要共享某些资源的 Container 则通过加入 NetworkNamespce 的方式，与 Infra 容器 关联在一起。效果如图
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/iogldt/1616119861463-06b2877d-519d-43a9-a6e4-6fc743d6ee30.jpeg" alt="">&lt;/p>
&lt;ol>
&lt;li>Infra 类型的 Container 使用一个名为 pause 的镜像，就像它的名字一样，永远处于&amp;quot;暂停&amp;quot;状态&lt;/li>
&lt;li>Kubernetes 为每个 Pod 都附属了 k8s.gcr.ip/pause，这个 Container 只接管 Pod 的网络信息，业务 Container 通过加入网络 Container 的网络来实现网络共享。此容器随着 pod 创建而创建，随着 Pod 删除而删除。该容器是对业务 pod 的命名空间的解析。Note：如果想要更改该容器，则需要在 kubelet 中使用&amp;ndash;pod-infra-container-image 参数进行配置&lt;/li>
&lt;li>与 Infra 关联的 Container 的所有 NetworkNamespace 必然是完全一样的。&lt;/li>
&lt;li>该链接有一种详细的解释&lt;/li>
&lt;li>Note：对于 kubelet 来说，这种容器称为 Sandbox。每次 kubelet 创建 pod 时，首先创建的也是 sandbox(i.e.pause)容器&lt;/li>
&lt;/ol>
&lt;p>一组 Container 共享 Infra 的 NetworkNamespace 意味着：&lt;/p>
&lt;ol>
&lt;li>它们可以直接使用 localhost 进行通信&lt;/li>
&lt;li>它们看到的网络设备跟 Infra 容器中看到的完全一样&lt;/li>
&lt;li>一个 Pod 只能有有一个 IP 地址，就是这个 Pod 的 NetworkNamespace 对应的 IP 地址&lt;/li>
&lt;li>Pod 的生命周期只跟 Infra 容器一致，同与 Infra 关联的所有 Container 无关&lt;/li>
&lt;li>Pod 中的所有 Container 的进出流量都是通过 Infra 容器完成的，所以网络插件不必关心除 Infra 以外的容器的启动与否，只需关注如何配置 Pod(也就是 Infra 容器的 NetworkNamespace)即可&lt;/li>
&lt;/ol>
&lt;p>每个 Pod 包含一个或多个容器。Pod 中的容器会作为一个整体被 Master 调度到一个 Node 上运行。&lt;/p>
&lt;p>如果把 Pod 想象成一台&amp;quot;服务器&amp;quot;，把 Container 想象成运行在这台服务器中的&amp;quot;用户程序&amp;quot;&lt;/p>
&lt;ol>
&lt;li>凡是调度、网络、存储、以及安全相关的字段，基本都是 Pod 级别的，比如：&lt;/li>
&lt;li>配置这台&amp;quot;服务器&amp;quot;的网卡(Pod 的网络)、配置这台“服务器”的磁盘(Pod 的存储，Volume)、配置这台”服务器“的防火墙(Pod 中的安全)、配置这台”服务器“运行在哪个机房(Pod 的调度)&lt;/li>
&lt;li>凡是资源配额、所要使用的 port、探测该进程是否存活或就绪、需要使用&amp;quot;服务器&amp;quot;上的哪块 Volume 等等字段，都是 Container 级别的&lt;/li>
&lt;/ol>
&lt;h2 id="kubernetes-引入-pod-主要基于下面两个目的">Kubernetes 引入 Pod 主要基于下面两个目的&lt;/h2>
&lt;ol>
&lt;li>可管理性。
&lt;ol>
&lt;li>有些 Container 天生就是需要紧密联系，一起工作。Pod 提供了比容器更高层次的抽象，将它们封装到一个部署单元中。Kubernetes 以 Pod 为最小单位进行调度、扩展、共享资源、管理生命周期。&lt;/li>
&lt;/ol>
&lt;/li>
&lt;li>通信和资源共享。
&lt;ol>
&lt;li>Pod 中的所有 Container 使用同一个网络 namespace，即相同的 IP 地址和 Port 空间。它们可以直接用 localhost 通信。同样的，这些 Container 可以共享存储，当 Kubernetes 挂载 volume 到 Pod，本质上是将 volume 挂载到 Pod 中的每一个 Container。user,mnt,pnt。&lt;/li>
&lt;/ol>
&lt;/li>
&lt;li>使用户从传统虚拟机环境向容器环境迁移更加平滑，可以把 Pod 想象成 VM，Pod 中的 Container 是 VM 中的进程，甚至可以启动一个 systemd 的 Container&lt;/li>
&lt;li>还可以把 Pod 理解为传统环境中的物理主机&lt;/li>
&lt;/ol>
&lt;h2 id="container-设计模式">Container 设计模式&lt;/h2>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/iogldt/1616119861478-cf678269-344a-4932-8448-c9eee14a8438.png" alt="">&lt;/p>
&lt;ul>
&lt;li>&lt;strong>sidecar&lt;/strong> #(该英文的解释“跨斗”：一辆小而低的车辆，安装在摩托车旁边，用于载客，就像右图中的样子)，所以该模式就类似于这个，指可以再一个 Pod 中启动一个辅助 Container，来完成一些独立于主进程(主 Container)之外的工作。
&lt;ul>
&lt;li>比如 Container 的日志收集：现在有一个 APP，需要不断把日志文件输出到 Container 的/var/log 目录中。这时，把一个 Pod 里的 Volume 挂载到应用 Container 的/var/log 目录上，然后在 Pod 中同时运行一个 sidecar 的 Container 也声明挂载同一个 Volume 到自己的/var/log 目录上，然后 sidecar 只需要不断得从自己的/var/log 目录里读取日志文件，转发到 MongoDB 或者 Elasticsearch 中存储起来即可。&lt;/li>
&lt;li>Istio 项目也是使用 sidecar 模式的 Container 完成微服务治理的原理。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h2 id="pod-的类型">Pod 的类型&lt;/h2>
&lt;ul>
&lt;li>动态 Pod：由 k8s 管理，网络组件，监控，等等，这些在 使用 kubeadm 初始化集群后才创建的 Pod 为动态 Pod&lt;/li>
&lt;li>静态 Pod：由 kubelet 直接管理的，在 /etc/kubernetes/manifest/ 目录下的 yaml 文件&lt;/li>
&lt;/ul>
&lt;h1 id="pod-使用方式">Pod 使用方式&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://kubernetes.io/docs/concepts/workloads/pods/init-containers/">官方文档，概念-工作敷在-Pod-初始化容器&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://kubernetes.io/docs/concepts/workloads/pods/ephemeral-containers/">官方文档，概念-工作负载-Pod-临时容器&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;ul>
&lt;li>运行单一 Container。
&lt;ul>
&lt;li>one-container-per-Pod 是 Kubernetes 最常见的模型，这种情况下，只是将单个 Container 简单封装成 Pod。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>运行多个 Container。
&lt;ul>
&lt;li>这些 Container 联系必须非常紧密，而且需要直接共享资源的应该放到一个 Pod 中(注意：当使用多 Container 的时候，其中一个 Container 要加上 command 的参数，否则其中一个起不来。因为 container 如果不执行某些命令，则启动后会自动结束，详见 docker 说明 1.LXC 与 Docker 入门最佳实践.note 里《Dokcer 的工作模式》章节)&lt;/li>
&lt;li>比如：File Puller 会定期从外部的 Content Manager 中拉取最新的文件，将其存放在共享的 volume 中。Web Server 从 volume 读取文件，响应 Consumer 的请求。这两个容器是紧密协作的，它们一起为 Consumer 提供最新的数据；同时它们也通过 volume 共享数据。所以放到一个 Pod 是合适的。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>在 Pod 中，可运行的容器分为三类：&lt;/p>
&lt;ul>
&lt;li>&lt;strong>ephemeral_container(临时容器)&lt;/strong> # 与 1.23 版本进入 beta，用来调试集群&lt;/li>
&lt;li>&lt;strong>init_container(初始化容器)&lt;/strong> # 在应用容器启动前运行一次就结束的，常用来为容器运行初始化运行环境，比如设置权限等等&lt;/li>
&lt;li>&lt;strong>application_container(应用容器)&lt;/strong> # 真正运行业务的容器。&lt;/li>
&lt;/ul>
&lt;p>这三类容器，可以在 kubelet 代码中找到运行逻辑，详见 [《kubelet 源码解析-PodWorker 模块》](/docs/IT学习笔记/10.云原生/2.3.Kubernetes%20 容器编排系统/Kubernetes%20 开发/源码解析/Kubelet%20 源码/PodWorker%20 模块.md 开发/源码解析/Kubelet 源码/PodWorker 模块.md)&lt;/p>
&lt;h2 id="ephemeral_container临时容器">ephemeral_container(临时容器)&lt;/h2>
&lt;h2 id="init_container初始化容器">init_container(初始化容器)&lt;/h2>
&lt;p>Pod 能够具有多个容器，应用运行在容器里面，但是它也可能有一个或多个先于应用容器启动的 Init 容器。Init 容器在所有容器运行之前执行（run-to-completion），常用来初始化配置。&lt;/p>
&lt;p>如果为一个 Pod 指定了多个 Init 容器，那些容器会按顺序一次运行一个。 每个 Init 容器必须运行成功，下一个才能够运行。 当所有的 Init 容器运行完成时，Kubernetes 初始化 Pod 并像平常一样运行应用容器。&lt;/p>
&lt;p>下面是一个 Init 容器的示例：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-yaml" data-lang="yaml">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">apiVersion&lt;/span>: &lt;span style="color:#ae81ff">v1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">kind&lt;/span>: &lt;span style="color:#ae81ff">Pod&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">metadata&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">name&lt;/span>: &lt;span style="color:#ae81ff">init-demo&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">spec&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">containers&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#f92672">name&lt;/span>: &lt;span style="color:#ae81ff">nginx&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">image&lt;/span>: &lt;span style="color:#ae81ff">nginx&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">ports&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#f92672">containerPort&lt;/span>: &lt;span style="color:#ae81ff">80&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">volumeMounts&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#f92672">name&lt;/span>: &lt;span style="color:#ae81ff">workdir&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">mountPath&lt;/span>: &lt;span style="color:#ae81ff">/usr/share/nginx/html&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e"># These containers are run during pod initialization&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">initContainers&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#f92672">name&lt;/span>: &lt;span style="color:#ae81ff">install&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">image&lt;/span>: &lt;span style="color:#ae81ff">busybox&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">command&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#ae81ff">wget&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#e6db74">&amp;#34;-O&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#e6db74">&amp;#34;/work-dir/index.html&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#ae81ff">http://kubernetes.io&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">volumeMounts&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#f92672">name&lt;/span>: &lt;span style="color:#ae81ff">workdir&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">mountPath&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;/work-dir&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">dnsPolicy&lt;/span>: &lt;span style="color:#ae81ff">Default&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">volumes&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#f92672">name&lt;/span>: &lt;span style="color:#ae81ff">workdir&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">emptyDir&lt;/span>: {}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>因为 Init 容器具有与应用容器分离的单独镜像，使用 init 容器启动相关代码具有如下优势：&lt;/p>
&lt;ol>
&lt;li>它们可以包含并运行实用工具，出于安全考虑，是不建议在应用容器镜像中包含这些实用工具的。&lt;/li>
&lt;li>它们可以包含使用工具和定制化代码来安装，但是不能出现在应用镜像中。例如，创建镜像没必要 FROM 另一个镜像，只需要在安装过程中使用类似 sed、 awk、 python 或 dig 这样的工具。&lt;/li>
&lt;li>应用镜像可以分离出创建和部署的角色，而没有必要联合它们构建一个单独的镜像。&lt;/li>
&lt;li>它们使用 Linux Namespace，所以对应用容器具有不同的文件系统视图。因此，它们能够具有访问 Secret 的权限，而应用容器不能够访问。&lt;/li>
&lt;li>它们在应用容器启动之前运行完成，然而应用容器并行运行，所以 Init 容器提供了一种简单的方式来阻塞或延迟应用容器的启动，直到满足了一组先决条件。&lt;/li>
&lt;/ol>
&lt;p>Init 容器的资源计算，选择一下两者的较大值：&lt;/p>
&lt;ol>
&lt;li>所有 Init 容器中的资源使用的最大值&lt;/li>
&lt;li>Pod 中所有容器资源使用的总和&lt;/li>
&lt;/ol>
&lt;p>Init 容器的重启策略：&lt;/p>
&lt;ol>
&lt;li>如果 Init 容器执行失败，Pod 设置的 restartPolicy 为 Never，则 pod 将处于 fail 状态。否则 Pod 将一直重新执行每一个 Init 容器直到所有的 Init 容器都成功。&lt;/li>
&lt;li>如果 Pod 异常退出，重新拉取 Pod 后，Init 容器也会被重新执行。所以在 Init 容器中执行的任务，需要保证是幂等的。&lt;/li>
&lt;/ol>
&lt;h2 id="container容器--也称为-application_container应用容器">container(容器) # 也称为 application_container(应用容器)&lt;/h2>
&lt;h1 id="pod-名字的命名规范">Pod 名字的命名规范&lt;/h1>
&lt;p>一般情况都不会直接使用 Pod，而是通过 Controller 来创建。通过 Controller 创建一个 POD 的流程为，以及 POD 名字的命名方式每个对象的命名方式是：子对象的名字 = 父对象名字 + 随机字符串或数字。如图所示，Controller 详见：2.0.Controller：控制器.note
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/iogldt/1616119861434-f2c4735b-c549-40a4-ab70-67217755ed3f.png" alt="">&lt;/p>
&lt;ol>
&lt;li>用户通过 kubectl 创建 Deployment。&lt;/li>
&lt;li>Deployment 创建 ReplicaSet。&lt;/li>
&lt;li>ReplicaSet 创建 Pod。&lt;/li>
&lt;/ol></description></item><item><title>Docs: Security Context(安全环境)</title><link>https://desistdaydream.github.io/docs/10.%E4%BA%91%E5%8E%9F%E7%94%9F/2.3.Kubernetes-%E5%AE%B9%E5%99%A8%E7%BC%96%E6%8E%92%E7%B3%BB%E7%BB%9F/3.Pod-%E9%9B%86%E7%BE%A4%E6%9C%80%E5%B0%8F%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8D%95%E5%85%83/Pod-%E7%AE%A1%E7%90%86/Security-Context%E5%AE%89%E5%85%A8%E7%8E%AF%E5%A2%83/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/10.%E4%BA%91%E5%8E%9F%E7%94%9F/2.3.Kubernetes-%E5%AE%B9%E5%99%A8%E7%BC%96%E6%8E%92%E7%B3%BB%E7%BB%9F/3.Pod-%E9%9B%86%E7%BE%A4%E6%9C%80%E5%B0%8F%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8D%95%E5%85%83/Pod-%E7%AE%A1%E7%90%86/Security-Context%E5%AE%89%E5%85%A8%E7%8E%AF%E5%A2%83/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://kubernetes.io/docs/tasks/configure-pod-container/security-context/">官方文档,任务-配置 Pod 和 Containers&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://mp.weixin.qq.com/s/NFgQrvn_LyU0qQbhMZwDAQ">公众号-阳明&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>&lt;strong>Security Context(安全环境)&lt;/strong> 用来定义 Pod 或 Container 的特权与访问控制设置。 安全上下文包括但不限于：&lt;/p>
&lt;ul>
&lt;li>自主访问控制（Discretionary Access Control）：基于 &lt;a href="https://wiki.archlinux.org/index.php/users_and_groups">用户 ID（UID）和组 ID（GID）&lt;/a>. 来判定对对象（例如文件）的访问权限。&lt;/li>
&lt;li>&lt;a href="https://zh.wikipedia.org/wiki/%E5%AE%89%E5%85%A8%E5%A2%9E%E5%BC%BA%E5%BC%8FLinux">安全性增强的 Linux（SELinux）&lt;/a>： 为对象赋予安全性标签。&lt;/li>
&lt;li>以特权模式或者非特权模式运行。&lt;/li>
&lt;li>&lt;a href="https://linux-audit.com/linux-capabilities-hardening-linux-binaries-by-removing-setuid/">Linux 权能&lt;/a>: 为进程赋予 root 用户的部分特权而非全部特权。&lt;/li>
&lt;li>&lt;a href="https://kubernetes.io/zh/docs/tutorials/clusters/apparmor/">AppArmor&lt;/a>：使用程序框架来限制个别程序的权能。&lt;/li>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Seccomp">Seccomp&lt;/a>：过滤进程的系统调用。&lt;/li>
&lt;li>AllowPrivilegeEscalation：控制进程是否可以获得超出其父进程的特权。 此布尔值直接控制是否为容器进程设置 &lt;code>[no_new_privs](https://www.kernel.org/doc/Documentation/prctl/no_new_privs.txt)&lt;/code>标志。 当容器以特权模式运行或者具有 &lt;code>CAP_SYS_ADMIN&lt;/code> 权能时，AllowPrivilegeEscalation 总是为 true。&lt;/li>
&lt;li>readOnlyRootFilesystem：以只读方式加载容器的根文件系统。&lt;/li>
&lt;/ul>
&lt;p>以上条目不是安全上下文设置的完整列表 &amp;ndash; 请参阅 &lt;a href="https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.20/#securitycontext-v1-core">SecurityContext&lt;/a> 了解其完整列表。
关于在 Linux 系统中的安全机制的更多信息，可参阅 &lt;a href="https://www.linux.com/learn/overview-linux-kernel-security-features">Linux 内核安全性能力概述&lt;/a>。&lt;/p>
&lt;p>特别注意：限制自由，会产生很多问题，比如：&lt;/p>
&lt;ul>
&lt;li>使用 hostPath 类型的 volume 时，如果容器不以 root 用户运行，则无法对 hostPath 所在目录执行操作，任何写操作将会提示权限不够。因为目录权限 755&lt;/li>
&lt;/ul>
&lt;h1 id="应该了解的-10-个-kubernetes-安全上下文配置">应该了解的 10 个 Kubernetes 安全上下文配置&lt;/h1>
&lt;p>在 Kubernetes 中安全地运行工作负载是很困难的，有很多配置都可能会影响到整个 Kubernetes API 的安全性，这需要我们有大量的知识积累来正确的实施。Kubernetes 在安全方面提供了一个强大的工具 securityContext，每个 Pod 和容器清单都可以使用这个属性。在本文中我们将了解各种 securityContext 的配置，探讨它们的含义，以及我们应该如何使用它们。
securityContext 设置在 PodSpec 和 ContainerSpec 规范中都有定义，这里我们分别用[P]和[C]来表示。需要注意的是，如果一个设置在两个作用域中都可以使用和配置，那么我们应该优先考虑设置容器级别的。&lt;/p>
&lt;h2 id="1runasnonroot-pc">1runAsNonRoot [P/C]&lt;/h2>
&lt;p>我们知道容器是使用 namespaces 和 cgroups 来限制其进程，但只要在部署的时候做了一次错误的配置，就可以让这些进程访问主机上的资源。如果该进程以 root 身份运行，它对这些资源的访问权限与主机 root 账户是相同的。此外，如果其他 pod 或容器设置被用来减少约束（比如 procMount 或 capabilities），拥有一个 root UID 就会提高风险，除非你有一个非常好的原因，否则你不应该以 root 身份运行一个容器。
那么，如果你有一个使用 root 的镜像需要部署，那应该怎么办呢？&lt;/p>
&lt;h3 id="11-使用基础镜像中提供的用户">1.1 使用基础镜像中提供的用户&lt;/h3>
&lt;p>通常情况下，基础镜像已经创建并提供了一个用户，例如，官方的 Node.js 镜像带有一个 UID 为 1000 的名为 node 的用户，我们就可以使用该身份来运行容器，但他们并没有在 Dockerfile 中明确地设置当前用户。我们可以在运行时用 runAsUser 设置来配置它，或者用自定义的 Dockerfile 来更改镜像中的当前用户。这里我们来看看使用自定义的 Dockerfile 来构建我们自己的镜像的例子。
在不深入了解镜像构建的情况下，让我们假设我们有一个预先构建好的 npm 应用程序。这里是一个最小的 Dockerfile 文件，用来构建一个基于 node:slim 的镜像，并以提供的 node 用户身份运行。
FROM node:slim
COPY &amp;ndash;chown=node . /home/node/app/   &lt;em># &amp;lt;&amp;mdash; Copy app into the home directory with right ownership&lt;/em>
USER 1000                             &lt;em># &amp;lt;&amp;mdash; Switch active user to “node” (by UID)&lt;/em>
WORKDIR /home/node/app                &lt;em># &amp;lt;&amp;mdash; Switch current directory to app&lt;/em>
ENTRYPOINT [&amp;ldquo;npm&amp;rdquo;, &amp;ldquo;start&amp;rdquo;]           &lt;em># &amp;lt;&amp;mdash; This will now exec as the “node” user instead of root&lt;/em>&lt;/p>
&lt;p>其中以 USER 开头的一行就是关键设置，这使得 node 成为从这个镜像启动的任何容器里面的默认用户。我们使用 UID 而不是用户的名字，因为 Kubernetes 无法在启动容器前将镜像的默认用户名映射到 UID 上，并且在部署时指定 runAsNotRoot: true，会返回有关错误。&lt;/p>
&lt;h3 id="12-基础镜像没有提供用户">1.2 基础镜像没有提供用户&lt;/h3>
&lt;p>如果我们使用的基础镜像没有提供一个可以使用的用户，那么我们又应该怎么做呢？对于大部分进程来说，我们只需在自定义的 Dockerfile 中创建一个用户并使用它即可。如下所示：
FROM node:slim
RUN useradd somebody -u 10001 &amp;ndash;create-home &amp;ndash;user-group  &lt;em># &amp;lt;&amp;mdash; Create a user&lt;/em>
COPY &amp;ndash;chown=somebody . /home/somebody/app/
USER 10001
WORKDIR /home/somebody/app
ENTRYPOINT [&amp;ldquo;npm&amp;rdquo;, &amp;ldquo;start&amp;rdquo;]&lt;/p>
&lt;p>这里我们增加了一行创建用户的 RUN 命令即可。不过需要注意的是这对于 node.js 和 npm 来说，这很好用，但是其他工具可能需要文件系统的不同元素进行所有权变更。如果遇到任何问题，需要查阅对应工具的文档。&lt;/p>
&lt;h2 id="2runasuserrunasgroup-pc">2runAsUser/runAsGroup [P/C]&lt;/h2>
&lt;p>容器镜像可能有一个特定的用户或组，我们可以用 runAsUser 和 runAsGroup 来进行覆盖。通常，这些设置与包含具有相同所有权 ID 的文件的卷挂载结合在一起。
&amp;hellip;.
spec:
  containers:
    - name: web
      image: mycorp/webapp:1.2.3
  securityContext:
    runAsNonRoot: true
    runAsUser: 10001
&amp;hellip;.&lt;/p>
&lt;p>不过使用这些配置也是有风险的，因为你为容器做出的运行时决定可能与原始镜像不兼容。例如，jenkins/jenkins 镜像以名为 jenkins:jenkins 的&lt;strong>组:用户&lt;/strong>身份运行，其应用文件全部由该用户拥有。如果我们配置一个不同的用户，它将无法启动，因为该用户不存在于镜像的/etc/passwd 文件中。即使它以某种方式存在，它也很可能在读写 jenkins:jenkins 拥有的文件时出现问题。我们可以用一个简单的 docker 运行命令来验证这个问题。
$ docker run &amp;ndash;rm -it -u eric:eric jenkins/jenkins
docker: Error response from daemon: unable to find user eric: no matching entries in passwd file.&lt;/p>
&lt;p>上面我们提到确保容器进程不以 root 用户身份运行是一个非常好的主意，但不要依赖 runAsUser 或 runAsGroup 设置来保证这一点，未来有人可能会删除这些配置，请确保同时将 runAsNonRoot 设置为 true。&lt;/p>
&lt;h2 id="3selinuxoptions-pc">3seLinuxOptions [P/C]&lt;/h2>
&lt;p>SELinux 是一个用于控制对 Linux 系统上的应用、进程和文件进行访问的策略驱动系统，它在 Linux 内核中实现了 Linux 安全模块框架。SELinux 是基于标签的策略，它将一些标签应用于系统中的所有元素，然后将元素进行分组。这些标签被称为&lt;strong>安全上下文&lt;/strong>（不要和 Kubernetes 中的 securityContext 混淆了）- 由用户、角色、类型和可选的一些其他属性组成，格式为：user:role:type:level。
然后，SELinux 使用策略来定义特定上下文中的哪些进程可以访问系统中其他被标记的对象。SELinux 可以是严格执行 enforced 模式，在这种情况下，访问将被拒绝，如果被配置为允许的 permissive 模式，那么安全策略没有被强制执行，当安全策略规则应该拒绝访问时，访问仍然被允许，然而，此时会向日志文件发送一条消息，表示该访问应该被拒绝。在容器中，SELinux 通常给容器进程和容器镜像打上标签，以限制该进程只能访问镜像中的文件。
默认的 SELinux 策略将在实例化容器时由容器运行时应用，securityContext 中的 seLinuxOptions 允许配置自定义的 SELinux 策略标签，请注意，改变容器的 SELinux 策略标签有可能允许容器进程摆脱容器镜像并访问主机文件系统。
当然只有当宿主机操作系统支持 SELinux 时，这个功能才会起作用。&lt;/p>
&lt;h2 id="4seccompprofile-pc">4seccompProfile [P/C]&lt;/h2>
&lt;p>Seccomp 表示一种安全计算模式，是 Linux 内核的一项功能，它可以限制一个特定进程从用户空间到内核的调用。seccomp 配置文件是使用一个 JSON 文件进行定义的，通常由一组系统调用和发生这些系统调用时的默认动作组成。如下配置所示：
{
    &amp;ldquo;defaultAction&amp;rdquo;: &amp;ldquo;SCMP_ACT_ERRNO&amp;rdquo;,
    &amp;ldquo;architectures&amp;rdquo;: [
        &amp;ldquo;SCMP_ARCH_X86_64&amp;rdquo;,
        &amp;ldquo;SCMP_ARCH_X86&amp;rdquo;,
        &amp;ldquo;SCMP_ARCH_X32&amp;rdquo;
    ],
    &amp;ldquo;syscalls&amp;rdquo;: [
        {
            &amp;ldquo;name&amp;rdquo;: &amp;ldquo;accept&amp;rdquo;,
            &amp;ldquo;action&amp;rdquo;: &amp;ldquo;SCMP_ACT_ALLOW&amp;rdquo;,
            &amp;ldquo;args&amp;rdquo;: []
        },
        {
            &amp;ldquo;name&amp;rdquo;: &amp;ldquo;accept4&amp;rdquo;,
            &amp;ldquo;action&amp;rdquo;: &amp;ldquo;SCMP_ACT_ALLOW&amp;rdquo;,
            &amp;ldquo;args&amp;rdquo;: []
        },
        &amp;hellip;
    ]
}&lt;/p>
&lt;p>Kubernetes 通过在 securityContext 中的 seccompProfile 属性来提供一个使用自定义配置文件的机制。
seccompProfile:
  type: Localhost
  localhostProfile: profiles/myprofile.json&lt;/p>
&lt;p>这里配置的 type 字段有三个可选的值：&lt;/p>
&lt;ul>
&lt;li>Localhost：其中 localhostProfile 配置为容器内的 seccomp 配置文件路径。&lt;/li>
&lt;li>Unconfined：其中没有配置文件。&lt;/li>
&lt;li>RuntimeDefault：其中使用容器运行时的默认值&amp;ndash;如果没有指定类型，就是默认值。&lt;/li>
&lt;/ul>
&lt;p>我们可以在 PodSecurityContext 或 securityContext 中使用这些配置，如果两者都配置了，就会使用容器级别中的配置。
此外与大多数安全相关的设置一样，&lt;strong>最小权限原则&lt;/strong>在此同样适用。只给你的容器访问它所需要的权限即可。首先创建一个配置文件，简单地记录哪些系统调用正在发生，然后测试你的应用程序，建立一套允许的系统调用规则。我们可以在 Kubernetes 教程(&lt;a href="https://kubernetes.io/docs/tutorials/clusters/seccomp">https://kubernetes.io/docs/tutorials/clusters/seccomp&lt;/a>)中找到关于Seccomp的更多信息。&lt;/p>
&lt;h2 id="5-避免使用特权容器-c">5 避免使用特权容器 [C]&lt;/h2>
&lt;p>给容器授予特权模式是非常危险的，一般会有一种更简单的方式来实现特定的权限，或者可以通过授予 Linux Capabilities 权限来控制。容器运行时控制器着特权模式的具体实现，但是它会授予容器所有的特权，并解除由 cgroup 控制器执行的限制，它还可以修改 Linux 安全模块的配置，并允许容器内的进程逃离容器。
容器在宿主机中提供了进程隔离，所以即使容器是使用 root 身份运行的，也有容器运行时不授予容器的 Capabilities。如果配置了特权模式，容器运行时就会授予系统 root 的所有能力，从安全角度来看，这是很危险的，因为它允许对底层宿主机系统的所有操作访问。
避免使用特权模式，如果你的容器确实需要额外的能力，只需通过添加 capabilities 来满足你的需求。除非你的容器需要控制主机内核中的系统级设置，如访问特定的硬件或重新配置网络，并且需要访问主机文件系统，那么它就不需要特权模式。&lt;/p>
&lt;h2 id="6linux-capabilities-c">6Linux Capabilities [C]&lt;/h2>
&lt;p>Capabilities 是一个内核级别的权限，它允许对内核调用权限进行更细粒度的控制，而不是简单地以 root 身份运行。Capabilities 包括更改文件权限、控制网络子系统和执行系统管理等功能。在 securityContext 中，Kubernetes 可以添加或删除 Capabilities，单个 Capabilities 或逗号分隔的列表可以作为一个字符串数组进行配置。另外，我们也可以使用 all 来添加或删除所有的配置。这种配置会被传递给容器运行时，在它创建容器的时候会配置上 Capabilities 集合，如果 securityContext 中没有配置，那么容器将会直接容器运行时提供的所有默认配置。
securityContext:
  capabilities:
    drop:
      - all
    add: [&amp;ldquo;MKNOD&amp;rdquo;]&lt;/p>
&lt;p>一般推荐的做法是先删除所有的配置，然后只添加你的应用程序实际需要的，在大部分情况下，应用程序在正常运行中实际上不需要任何 Capabilities，通过删除所有配置来测试，并通过监控审计日志来调试问题，看看哪些功能被阻止了。
请注意，当在 securityContext 中列出要放弃或添加的 Capabilities 时，你要删除内核在命名 Capabilities 时使用的 CAP_前缀。capsh 工具可以给我们一个比较友好的调试信息，可以来说明你的容器中到底启用了哪些 Capabilities，当然不要在生产容器中使用这个工具，因为这使得攻击者很容易弄清楚哪些 Capabilities 被启用了。&lt;/p>
&lt;h2 id="7-以只读文件系统运行-c">7 以只读文件系统运行 [C]&lt;/h2>
&lt;p>如果你的容器被入侵，而且它有一个可读写的文件系统，那么攻击者就可以随意地改变它的配置、安装软件，并有可能启动其他的漏洞。拥有一个只读的文件系统有助于防止这些类型的安全问题，因为它限制了攻击者可以执行的操作。一般来说，容器不应该要求对容器文件系统进行写入，如果你的应用程序是有状态数据，那么你应该使用外部持久化方法，如数据库、volume 或其他一些服务。另外，确保所有的日志都写到 stdout 或日志转发器上。&lt;/p>
&lt;h2 id="8procmount-c">8procMount [C]&lt;/h2>
&lt;p>默认情况下，为了防止潜在的安全问题，容器运行时会屏蔽容器内/proc 文件系统的某些部分文件。然而有时需要访问/proc 的这些文件，特别是在使用嵌套容器时，因为它经常被用作集群内构建过程的一部分。该配置只有两个有效的选项：&lt;/p>
&lt;ul>
&lt;li>Default：保持标准的容器运行时行为&lt;/li>
&lt;li>Unmasked：它删除/proc 文件系统的所有屏蔽行为&lt;/li>
&lt;/ul>
&lt;p>显然只有当我们知道在做什么的时候才应该使用这个配置，如果你是为了构建镜像而使用它，请检查构建工具的最新版本，因为许多工具不再需要这个设置了，最好升级下工具并设置为 Default 默认的 procMount。&lt;/p>
&lt;h2 id="9fsgroupfsgroupchangepolicy-p">9fsGroup/fsGroupChangePolicy [P]&lt;/h2>
&lt;p>fsGroup 设置定义了一个组，当卷被 pod 挂载时，Kubernetes 将把卷中所有文件的权限改为该组。这里的行为也由 fsGroupChangePolicy 控制，它可以被设置为 onRootMismatch 或 Always。如果设置为 onRootMismatch 则只有当权限与容器 root 的权限不匹配时才会被改变。
不过在使用 fsGroup 时也要慎重，改变整个 volume 卷的组所有权会导致&lt;strong>变慢&lt;/strong>，如果是大型文件系统&lt;strong>启动也会延迟&lt;/strong>。如果共享同一卷的其他进程没有对新的 GID 的访问权限，它也会对这些进程造成损害。由于这个原因，一些共享文件系统如 NFS，没有实现这个功能。这些设置也不影响临时的 ephemeral 卷。&lt;/p>
&lt;h2 id="10sysctls-p">10sysctls [P]&lt;/h2>
&lt;p>Sysctls 是 Linux 内核的一个功能，它允许管理员修改内核配置。在一个完整的 Linux 操作系统中，这些是通过使用/etc/sysctl.conf 定义的，也可以使用 sysctl 工具进行修改。
securityContext 中的 sysctls 配置允许在容器中修改特定的 sysctls。只有一小部分的 sysctls 可以在每个容器的基础上进行修改，它们都在内核中被命名的。在这个可以配置的子集中，有些被认为是安全的，而更多的则被认为是不安全的，这取决于对其他 pod 的潜在影响。在集群中，不安全的 sysctls 通常是被禁用，需要由集群管理员专门开启。
鉴于有可能破坏底层操作系统的稳定，除非你有非常特殊的要求，否则应该避免通过 sysctls 修改内核参数。&lt;/p>
&lt;h2 id="11-总结">11 总结&lt;/h2>
&lt;p>在用 securityContext 加固你的应用时，有很多事情需要注意。如果使用得当，它们是一种非常有效的工具，我们希望这个列表能帮助你的团队为你的工作负载和环境进行正确的安全配置。&lt;/p></description></item><item><title>Docs: 访问 Pod</title><link>https://desistdaydream.github.io/docs/10.%E4%BA%91%E5%8E%9F%E7%94%9F/2.3.Kubernetes-%E5%AE%B9%E5%99%A8%E7%BC%96%E6%8E%92%E7%B3%BB%E7%BB%9F/3.Pod-%E9%9B%86%E7%BE%A4%E6%9C%80%E5%B0%8F%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8D%95%E5%85%83/Pod-%E7%AE%A1%E7%90%86/%E8%AE%BF%E9%97%AE-Pod/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/10.%E4%BA%91%E5%8E%9F%E7%94%9F/2.3.Kubernetes-%E5%AE%B9%E5%99%A8%E7%BC%96%E6%8E%92%E7%B3%BB%E7%BB%9F/3.Pod-%E9%9B%86%E7%BE%A4%E6%9C%80%E5%B0%8F%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8D%95%E5%85%83/Pod-%E7%AE%A1%E7%90%86/%E8%AE%BF%E9%97%AE-Pod/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://jimmysong.io/kubernetes-handbook/guide/accessing-kubernetes-pods-from-outside-of-the-cluster.html">原文，jimmysong.io kubernetes 手书，指南-从集群外部访问 Pod &lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>本文主要讲解访问 kubenretes 中的 Pod 和 Serivce 的集中方式，包括如下几种：&lt;/p>
&lt;ul>
&lt;li>hostNetwork&lt;/li>
&lt;li>hostPort&lt;/li>
&lt;li>NodePort&lt;/li>
&lt;li>LoadBalancer&lt;/li>
&lt;li>Ingress&lt;/li>
&lt;/ul>
&lt;p>说是暴露 Pod 其实跟暴露 Service 是一回事，因为 Pod 就是 Service 的 backend。&lt;/p>
&lt;h1 id="hostnetwork-true">hostNetwork: true&lt;/h1>
&lt;p>这是一种直接定义 Pod 网络的方式。&lt;/p>
&lt;p>如果在 Pod 中使用 hostNetwork:true 配置的话，在这种 pod 中运行的应用程序可以直接看到 pod 启动的主机的网络接口。在主机的所有网络接口上都可以访问到该应用程序。以下是使用主机网络的 pod 的示例定义：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-yaml" data-lang="yaml">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">apiVersion&lt;/span>: &lt;span style="color:#ae81ff">v1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">kind&lt;/span>: &lt;span style="color:#ae81ff">Pod&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">metadata&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">name&lt;/span>: &lt;span style="color:#ae81ff">influxdb&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">spec&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">hostNetwork&lt;/span>: &lt;span style="color:#66d9ef">true&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">containers&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#f92672">name&lt;/span>: &lt;span style="color:#ae81ff">influxdb&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">image&lt;/span>: &lt;span style="color:#ae81ff">influxdb&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>部署该 Pod：&lt;/p>
&lt;pre tabindex="0">&lt;code>$ kubectl create -f influxdb-hostnetwork.yml
&lt;/code>&lt;/pre>&lt;p>访问该 pod 所在主机的 8086 端口：&lt;/p>
&lt;pre tabindex="0">&lt;code>curl -v http://$POD_IP:8086/ping
&lt;/code>&lt;/pre>&lt;p>将看到 204 No Content 的 204 返回码，说明可以正常访问。&lt;/p>
&lt;p>注意每次启动这个 Pod 的时候都可能被调度到不同的节点上，所有外部访问 Pod 的 IP 也是变化的，而且调度 Pod 的时候还需要考虑是否与宿主机上的端口冲突，因此一般情况下除非您知道需要某个特定应用占用特定宿主机上的特定端口时才使用 hostNetwork: true 的方式。&lt;/p>
&lt;p>这种 Pod 的网络模式有一个用处就是可以将网络插件包装在 Pod 中然后部署在每个宿主机上，这样该 Pod 就可以控制该宿主机上的所有网络。&lt;/p>
&lt;p>这种网络方式可以用来做 nginx Ingress controller。外部流量都需要通过 kubenretes node 节点的 80 和 443 端口。&lt;/p>
&lt;h1 id="hostport">hostPort&lt;/h1>
&lt;p>这是一种直接定义 Pod 网络的方式。&lt;/p>
&lt;p>hostPort 是直接将容器的端口与所调度的节点上的端口路由，这样用户就可以通过宿主机的 IP 加上来访问 Pod 了，如:。&lt;/p>
&lt;pre>&lt;code>apiVersion: v1
kind: Pod
metadata:
name: influxdb
spec:
containers:
-name: influxdb
image: influxdb
ports:
- containerPort:8086
hostPort:8086
&lt;/code>&lt;/pre>
&lt;p>这样做有个缺点，因为 Pod 重新调度的时候该 Pod 被调度到的宿主机可能会变动，这样就变化了，用户必须自己维护一个 Pod 与所在宿主机的对应关系&lt;/p>
&lt;h1 id="nodeport">NodePort&lt;/h1>
&lt;p>NodePort 在 kubenretes 里是一个广泛应用的服务暴露方式。Kubernetes 中的 service 默认情况下都是使用的 ClusterIP 这种类型，这样的 service 会产生一个 ClusterIP，这个 IP 只能在集群内部访问，要想让外部能够直接访问 service，需要将 service type 修改为 nodePort。&lt;/p>
&lt;pre>&lt;code>apiVersion: v1
kind: Pod
metadata:
name: influxdb
labels:
name: influxdb
spec:
containers:
- name: influxdb
image: influxdb
ports:
- containerPort:8086
&lt;/code>&lt;/pre>
&lt;p>同时还可以给 service 指定一个 nodePort 值，范围是 30000-32767，这个值在 API server 的配置文件中，用&amp;ndash;service-node-port-range 定义。&lt;/p>
&lt;pre>&lt;code>kind: Service
apiVersion: v1
metadata:
name: influxdb
spec:
type: NodePort
ports:
- port:8086
nodePort:30000
selector:
name: influxdb
&lt;/code>&lt;/pre>
&lt;p>集群外就可以使用 kubernetes 任意一个节点的 IP 加上 30000 端口访问该服务了。kube-proxy 会自动将流量以 round-robin 的方式转发给该 service 的每一个 pod。&lt;/p>
&lt;p>这种服务暴露方式，无法让你指定自己想要的应用常用端口，不过可以在集群上再部署一个反向代理作为流量入口。&lt;/p>
&lt;h1 id="loadbalancer">LoadBalancer&lt;/h1>
&lt;p>LoadBalancer 只能在 service 上定义。这是公有云提供的负载均衡器，如 AWS、Azure、CloudStack、GCE 等。&lt;/p>
&lt;pre>&lt;code>kind: Service
apiVersion: v1
metadata:
name: influxdb
spec:
type: LoadBalancer
ports:
- port:8086
selector:
name: influxdb
&lt;/code>&lt;/pre>
&lt;p>查看服务：&lt;/p>
&lt;pre>&lt;code>$ kubectl get svc influxdb
NAME CLUSTER-IP EXTERNAL-IP PORT(S)
AGEinfluxdb 10.97.121.42 10.13.242.236 8086:30051/TCP 39s
&lt;/code>&lt;/pre>
&lt;p>内部可以使用 ClusterIP 加端口来访问服务，如 19.97.121.42:8086。&lt;/p>
&lt;p>外部可以用以下两种方式访问该服务：&lt;/p>
&lt;ul>
&lt;li>使用任一节点的 IP 加 30051 端口访问该服务&lt;/li>
&lt;li>使用 EXTERNAL-IP 来访问，这是一个 VIP，是云供应商提供的负载均衡器 IP，如 10.13.242.236:8086。&lt;/li>
&lt;/ul>
&lt;h1 id="ingress">Ingress&lt;/h1>
&lt;p>Ingress 是自 kubernetes1.1 版本后引入的资源类型。必须要部署 Ingress controller 才能创建 Ingress 资源，Ingress controller 是以一种插件的形式提供。Ingress controller 是部署在 Kubernetes 之上的 Docker 容器。它的 Docker 镜像包含一个像 nginx 或 HAProxy 的负载均衡器和一个控制器守护进程。控制器守护程序从 Kubernetes 接收所需的 Ingress 配置。它会生成一个 nginx 或 HAProxy 配置文件，并重新启动负载平衡器进程以使更改生效。换句话说，Ingress controller 是由 Kubernetes 管理的负载均衡器。&lt;/p>
&lt;p>Kubernetes Ingress 提供了负载平衡器的典型特性：HTTP 路由，粘性会话，SSL 终止，SSL 直通，TCP 和 UDP 负载平衡等。目前并不是所有的 Ingress controller 都实现了这些功能，需要查看具体的 Ingress controller 文档。&lt;/p>
&lt;p>外部访问 URL &lt;a href="http://influxdb.kube.example.com/ping">http://influxdb.kube.example.com/ping&lt;/a> 访问该服务，入口就是 80 端口，然后 Ingress controller 直接将流量转发给后端 Pod，不需再经过 kube-proxy 的转发，比 LoadBalancer 方式更高效。&lt;/p>
&lt;h1 id="总结">总结&lt;/h1>
&lt;p>总的来说 Ingress 是一个非常灵活和越来越得到厂商支持的服务暴露方式，包括 Nginx、HAProxy、Traefik，还有各种 Service Mesh，而其它服务暴露方式可以更适用于服务调试、特殊应用的部署。&lt;/p>
&lt;h1 id="参考">参考&lt;/h1>
&lt;p>&lt;a href="http://alesnosek.com/blog/2017/02/14/accessing-kubernetes-pods-from-outside-of-the-cluster/">Accessing Kubernetes Pods from Outside of the Cluster - alesnosek.com&lt;/a>&lt;/p></description></item><item><title>Docs: 为 Pod 注入数据</title><link>https://desistdaydream.github.io/docs/10.%E4%BA%91%E5%8E%9F%E7%94%9F/2.3.Kubernetes-%E5%AE%B9%E5%99%A8%E7%BC%96%E6%8E%92%E7%B3%BB%E7%BB%9F/3.Pod-%E9%9B%86%E7%BE%A4%E6%9C%80%E5%B0%8F%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8D%95%E5%85%83/Pod-%E7%AE%A1%E7%90%86/%E4%B8%BA-Pod-%E6%B3%A8%E5%85%A5%E6%95%B0%E6%8D%AE/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/10.%E4%BA%91%E5%8E%9F%E7%94%9F/2.3.Kubernetes-%E5%AE%B9%E5%99%A8%E7%BC%96%E6%8E%92%E7%B3%BB%E7%BB%9F/3.Pod-%E9%9B%86%E7%BE%A4%E6%9C%80%E5%B0%8F%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8D%95%E5%85%83/Pod-%E7%AE%A1%E7%90%86/%E4%B8%BA-Pod-%E6%B3%A8%E5%85%A5%E6%95%B0%E6%8D%AE/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://kubernetes.io/docs/tasks/inject-data-application/">官方文档,任务-给应用注入数据&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;h1 id="将-pod-的-manifests-信息映射到容器中的环境变量上">将 Pod 的 Manifests 信息映射到容器中的环境变量上&lt;/h1>
&lt;h2 id="用-pod-字段作为环境变量的值">用 Pod 字段作为环境变量的值&lt;/h2>
&lt;p>在这个练习中，你将创建一个包含一个容器的 Pod。这是该 Pod 的配置文件：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-yaml" data-lang="yaml">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">apiVersion&lt;/span>: &lt;span style="color:#ae81ff">v1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">kind&lt;/span>: &lt;span style="color:#ae81ff">Pod&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">metadata&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">name&lt;/span>: &lt;span style="color:#ae81ff">dapi-envars-fieldref&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">spec&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">containers&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#f92672">name&lt;/span>: &lt;span style="color:#ae81ff">test-container&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">image&lt;/span>: &lt;span style="color:#ae81ff">k8s.gcr.io/busybox&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">command&lt;/span>: [&lt;span style="color:#e6db74">&amp;#34;sh&amp;#34;&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;-c&amp;#34;&lt;/span>]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">args&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#ae81ff">while true; do&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ae81ff">echo -en &amp;#39;\n&amp;#39;;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ae81ff">printenv MY_NODE_NAME MY_POD_NAME MY_POD_NAMESPACE;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ae81ff">printenv MY_POD_IP MY_POD_SERVICE_ACCOUNT;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ae81ff">sleep 10;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ae81ff">done;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">env&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#f92672">name&lt;/span>: &lt;span style="color:#ae81ff">MY_NODE_NAME&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">valueFrom&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">fieldRef&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">fieldPath&lt;/span>: &lt;span style="color:#ae81ff">spec.nodeName&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#f92672">name&lt;/span>: &lt;span style="color:#ae81ff">MY_POD_NAME&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">valueFrom&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">fieldRef&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">fieldPath&lt;/span>: &lt;span style="color:#ae81ff">metadata.name&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#f92672">name&lt;/span>: &lt;span style="color:#ae81ff">MY_POD_NAMESPACE&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">valueFrom&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">fieldRef&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">fieldPath&lt;/span>: &lt;span style="color:#ae81ff">metadata.namespace&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#f92672">name&lt;/span>: &lt;span style="color:#ae81ff">MY_POD_IP&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">valueFrom&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">fieldRef&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">fieldPath&lt;/span>: &lt;span style="color:#ae81ff">status.podIP&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#f92672">name&lt;/span>: &lt;span style="color:#ae81ff">MY_POD_SERVICE_ACCOUNT&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">valueFrom&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">fieldRef&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">fieldPath&lt;/span>: &lt;span style="color:#ae81ff">spec.serviceAccountName&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">restartPolicy&lt;/span>: &lt;span style="color:#ae81ff">Never&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>这个配置文件中，你可以看到五个环境变量。&lt;code>env&lt;/code> 字段是一个 &lt;a href="https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.21/#envvar-v1-core">EnvVars&lt;/a>. 对象的数组。 数组中第一个元素指定 &lt;code>MY_NODE_NAME&lt;/code> 这个环境变量从 Pod 的 &lt;code>spec.nodeName&lt;/code> 字段获取变量值。 同样，其它环境变量也是从 Pod 的字段获取它们的变量值。&lt;/p>
&lt;blockquote>
&lt;p>&lt;strong>说明：&lt;/strong> 本示例中的字段是 Pod 字段，不是 Pod 中 Container 的字段。&lt;/p>
&lt;/blockquote>
&lt;p>创建 Pod：&lt;/p>
&lt;pre>&lt;code>kubectl apply -f https://k8s.io/examples/pods/inject/dapi-envars-pod.yaml
&lt;/code>&lt;/pre>
&lt;p>验证 Pod 中的容器运行正常：&lt;/p>
&lt;pre>&lt;code>kubectl get pods
&lt;/code>&lt;/pre>
&lt;p>查看容器日志：&lt;/p>
&lt;pre>&lt;code>kubectl logs dapi-envars-fieldref
&lt;/code>&lt;/pre>
&lt;p>输出信息显示了所选择的环境变量的值：&lt;/p>
&lt;pre>&lt;code>minikube
dapi-envars-fieldref
default
172.17.0.4
default
&lt;/code>&lt;/pre>
&lt;p>要了解为什么这些值在日志中，请查看配置文件中的&lt;code>command&lt;/code> 和 &lt;code>args&lt;/code>字段。 当容器启动时，它将五个环境变量的值写入 stdout。每十秒重复执行一次。
接下来，通过打开一个 Shell 进入 Pod 中运行的容器：&lt;/p>
&lt;pre>&lt;code>kubectl exec -it dapi-envars-fieldref -- sh
&lt;/code>&lt;/pre>
&lt;p>在 Shell 中，查看环境变量：&lt;/p>
&lt;pre>&lt;code>/# printenv
&lt;/code>&lt;/pre>
&lt;p>输出信息显示环境变量已经设置为 Pod 字段的值。&lt;/p>
&lt;pre>&lt;code>MY_POD_SERVICE_ACCOUNT=default
...
MY_POD_NAMESPACE=default
MY_POD_IP=172.17.0.4
...
MY_NODE_NAME=minikube
...
MY_POD_NAME=dapi-envars-fieldref
&lt;/code>&lt;/pre>
&lt;h2 id="用-container-字段作为环境变量的值">用 Container 字段作为环境变量的值&lt;/h2>
&lt;p>前面的练习中，你将 Pod 字段作为环境变量的值。 接下来这个练习中，你将用 Container 字段作为环境变量的值。这里是包含一个容器的 Pod 的配置文件：
&lt;a href="https://notes-learning.oss-cn-beijing.aliyuncs.com/ooyi9u/1621520643090-327ae7d2-cb76-4240-b963-9070371cdaca.svg">&lt;code>pods/inject/dapi-envars-container.yaml&lt;/code>&lt;/a>&lt;/p>
&lt;pre>&lt;code>apiVersion: v1
kind: Pod
metadata:
name: dapi-envars-resourcefieldref
spec:
containers:
- name: test-container
image: k8s.gcr.io/busybox:1.24
command: [ &amp;quot;sh&amp;quot;, &amp;quot;-c&amp;quot;]
args:
- while true; do
echo -en '\n';
printenv MY_CPU_REQUEST MY_CPU_LIMIT;
printenv MY_MEM_REQUEST MY_MEM_LIMIT;
sleep 10;
done;
resources:
requests:
memory: &amp;quot;32Mi&amp;quot;
cpu: &amp;quot;125m&amp;quot;
limits:
memory: &amp;quot;64Mi&amp;quot;
cpu: &amp;quot;250m&amp;quot;
env:
- name: MY_CPU_REQUEST
valueFrom:
resourceFieldRef:
containerName: test-container
resource: requests.cpu
- name: MY_CPU_LIMIT
valueFrom:
resourceFieldRef:
containerName: test-container
resource: limits.cpu
- name: MY_MEM_REQUEST
valueFrom:
resourceFieldRef:
containerName: test-container
resource: requests.memory
- name: MY_MEM_LIMIT
valueFrom:
resourceFieldRef:
containerName: test-container
resource: limits.memory
restartPolicy: Never
&lt;/code>&lt;/pre>
&lt;p>这个配置文件中，你可以看到四个环境变量。&lt;code>env&lt;/code> 字段是一个 &lt;a href="https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.21/#envvar-v1-core">EnvVars&lt;/a>. 对象的数组。数组中第一个元素指定 &lt;code>MY_CPU_REQUEST&lt;/code> 这个环境变量从 Container 的 &lt;code>requests.cpu&lt;/code> 字段获取变量值。同样，其它环境变量也是从 Container 的字段获取它们的变量值。&lt;/p>
&lt;blockquote>
&lt;p>&lt;strong>说明：&lt;/strong> 本例中使用的是 Container 的字段而不是 Pod 的字段。&lt;/p>
&lt;/blockquote>
&lt;p>创建 Pod：&lt;/p>
&lt;pre>&lt;code>kubectl apply -f https://k8s.io/examples/pods/inject/dapi-envars-container.yaml
&lt;/code>&lt;/pre>
&lt;p>验证 Pod 中的容器运行正常：&lt;/p>
&lt;pre>&lt;code>kubectl get pods
&lt;/code>&lt;/pre>
&lt;p>查看容器日志：&lt;/p>
&lt;pre>&lt;code>kubectl logs dapi-envars-resourcefieldref
&lt;/code>&lt;/pre>
&lt;p>输出信息显示了所选择的环境变量的值：&lt;/p>
&lt;pre>&lt;code>1
1
33554432
67108864
&lt;/code>&lt;/pre></description></item></channel></rss>