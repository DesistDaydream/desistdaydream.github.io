<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>断念梦 – CSI</title><link>https://desistdaydream.github.io/docs/10.%E4%BA%91%E5%8E%9F%E7%94%9F/2.3.Kubernetes-%E5%AE%B9%E5%99%A8%E7%BC%96%E6%8E%92%E7%B3%BB%E7%BB%9F/9.Kubernetes-%E5%AD%98%E5%82%A8/CSI/</link><description>Recent content in CSI on 断念梦</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><atom:link href="https://desistdaydream.github.io/docs/10.%E4%BA%91%E5%8E%9F%E7%94%9F/2.3.Kubernetes-%E5%AE%B9%E5%99%A8%E7%BC%96%E6%8E%92%E7%B3%BB%E7%BB%9F/9.Kubernetes-%E5%AD%98%E5%82%A8/CSI/index.xml" rel="self" type="application/rss+xml"/><item><title>Docs: CSI</title><link>https://desistdaydream.github.io/docs/10.%E4%BA%91%E5%8E%9F%E7%94%9F/2.3.Kubernetes-%E5%AE%B9%E5%99%A8%E7%BC%96%E6%8E%92%E7%B3%BB%E7%BB%9F/9.Kubernetes-%E5%AD%98%E5%82%A8/CSI/CSI-1/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/10.%E4%BA%91%E5%8E%9F%E7%94%9F/2.3.Kubernetes-%E5%AE%B9%E5%99%A8%E7%BC%96%E6%8E%92%E7%B3%BB%E7%BB%9F/9.Kubernetes-%E5%AD%98%E5%82%A8/CSI/CSI-1/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://github.com/container-storage-interface/spec">GitHub 项目,规范&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>CSI 是与 &lt;a href="https://www.yuque.com/go/doc/33165299">CNI &lt;/a>类似的东西，都是一种规范。&lt;/p>
&lt;p>Container Storage Interface，容器存储接口（CSI）为容器编排系统（如 Kubernetes）定义了一个标准接口，以将任意存储系统暴露给其容器工作负载。&lt;/p>
&lt;h2 id="csi-specification-规范介绍">CSI Specification 规范介绍&lt;/h2>
&lt;p>官方文档：&lt;a href="https://github.com/container-storage-interface/spec/blob/master/spec.md">https://github.com/container-storage-interface/spec/blob/master/spec.md&lt;/a>&lt;/p>
&lt;h1 id="背景">背景&lt;/h1>
&lt;p>CSI 出现之前，很多存储类型的 PV，比如 iSCSI、NFS、CephFS 等等(&lt;a href="https://kubernetes.io/docs/concepts/storage/persistent-volumes/#types-of-persistent-volumes">详见 k8s 官方支持列表&lt;/a>)。这些类型的存储的代码，放在 Kubernetes 代码仓库中，这种称为 &lt;strong>in-tree&lt;/strong> 类型的存储(也就是在代码树中)。这里代理的问题是 Kubernetes 代码与 第三方存储厂商的代码&lt;strong>强耦合&lt;/strong>。&lt;/p>
&lt;ul>
&lt;li>更改 in-tree 类型的存储代码，用户必须更新 K8s 组件，成本较高&lt;/li>
&lt;li>in-tree 存储代码中的 bug 会引发 K8s 组件不稳定&lt;/li>
&lt;li>K8s 社区需要负责维护及测试 in-tree 类型的存储功能&lt;/li>
&lt;li>in-tree 存储插件享有与 K8s 核心组件同等的特权，存在安全隐患&lt;/li>
&lt;li>三方存储开发者必须遵循 K8s 社区的规则开发 in-tree 类型存储代码&lt;/li>
&lt;/ul>
&lt;p>**CSI(容器存储接口) **标准的出现解决了上述问题，将三方存储代码与 K8S 代码解耦，使得三方存储厂商研发人员只需实现 CSI 接口（无需关注容器平台是 K8s 还是 Swarm 等）。&lt;/p></description></item><item><title>Docs: CSI</title><link>https://desistdaydream.github.io/docs/10.%E4%BA%91%E5%8E%9F%E7%94%9F/2.3.Kubernetes-%E5%AE%B9%E5%99%A8%E7%BC%96%E6%8E%92%E7%B3%BB%E7%BB%9F/9.Kubernetes-%E5%AD%98%E5%82%A8/CSI/CSI/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/10.%E4%BA%91%E5%8E%9F%E7%94%9F/2.3.Kubernetes-%E5%AE%B9%E5%99%A8%E7%BC%96%E6%8E%92%E7%B3%BB%E7%BB%9F/9.Kubernetes-%E5%AD%98%E5%82%A8/CSI/CSI/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://mp.weixin.qq.com/s/A9xWKMmrxPyOEiCs_sicYQ">公众号,一文读懂容器存储接口 CSI&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>&lt;strong>导读：&lt;/strong> 在&lt;a href="https://mp.weixin.qq.com/s?__biz=MzUzNzYxNjAzMg==&amp;amp;mid=2247490043&amp;amp;idx=1&amp;amp;sn=c09ad4a9bc790f4b742abd8ca1301ffb&amp;amp;scene=21#wechat_redirect">《一文读懂 K8s 持久化存储流程》&lt;/a>一文我们重点介绍了 K8s 内部的存储流程，以及 PV、PVC、StorageClass、Kubelet 等之间的调用关系。接下来本文将将重点放在 CSI（Container Storage Interface）容器存储接口上，探究什么是 CSI 及其内部工作原理。&lt;/p>
&lt;h1 id="csi-核心流程介绍">CSI 核心流程介绍&lt;/h1>
&lt;p>在详细介绍 CSI 组件及其接口之前，我们先对 K8s 中 CSI 存储流程进行一个介绍。&lt;a href="https://mp.weixin.qq.com/s?__biz=MzUzNzYxNjAzMg==&amp;amp;mid=2247490043&amp;amp;idx=1&amp;amp;sn=c09ad4a9bc790f4b742abd8ca1301ffb&amp;amp;scene=21#wechat_redirect">《一文读懂 K8s 持久化存储流程》&lt;/a>一文介绍了 K8s 中的 Pod 在挂载存储卷时需经历三个的阶段：Provision/Delete（创盘 / 删盘）、Attach/Detach（挂接 / 摘除）和 Mount/Unmount（挂载 / 卸载），下面以图文的方式讲解 K8s 在这三个阶段使用 CSI 的流程。&lt;/p>
&lt;h3 id="1-provisioning-volumes">&lt;strong>1. Provisioning Volumes&lt;/strong>&lt;/h3>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/d6843a53-f815-4b10-a58d-610dd47e1665/640" alt="">&lt;/p>
&lt;ol>
&lt;li>&lt;strong>集群管理员&lt;/strong>创建 StorageClass 资源，该 StorageClass 中包含 CSI 插件名称（provisioner:pangu.csi.alibabacloud.com）以及存储类必须的参数（parameters: type=cloud_ssd）。sc.yaml 文件如下：&lt;/li>
&lt;/ol>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/d6843a53-f815-4b10-a58d-610dd47e1665/640" alt="">&lt;/p>
&lt;ol start="2">
&lt;li>&lt;strong>用户&lt;/strong>创建 PersistentVolumeClaim 资源，PVC 指定存储大小及 StorageClass（如上）。pvc.yaml 文件如下：&lt;/li>
&lt;/ol>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/d6843a53-f815-4b10-a58d-610dd47e1665/640" alt="">&lt;/p>
&lt;ol start="3">
&lt;li>**卷控制器（PersistentVolumeController）**观察到集群中新创建的 PVC 没有与之匹配的 PV，且其使用的存储类型为 out-of-tree，于是为 PVC 打 annotation：volume.beta.kubernetes.io/storage-provisioner=[out-of-tree CSI 插件名称]（本例中即为 provisioner:pangu.csi.alibabacloud.com）。&lt;/li>
&lt;li>&lt;strong>External Provisioner 组件&lt;/strong>观察到 PVC 的 annotation 中包含 &amp;ldquo;volume.beta.kubernetes.io/storage-provisioner&amp;rdquo; 且其 value 是自己，于是开始创盘流程。&lt;/li>
&lt;/ol>
&lt;ul>
&lt;li>获取相关 StorageClass 资源并从中获取参数（本例中 parameters 为   type=cloud_ssd），用于后面 CSI 函数调用。&lt;/li>
&lt;li>通过 unix domain socket 调用&lt;strong>外部 CSI 插件&lt;/strong>的 &lt;strong>CreateVolume 函数&lt;/strong>。&lt;/li>
&lt;/ul>
&lt;ol start="5">
&lt;li>&lt;strong>外部 CSI 插件&lt;/strong>返回成功后表示盘创建完成，此时 &lt;strong>External Provisioner 组件&lt;/strong>会在集群创建一个 PersistentVolume 资源。&lt;/li>
&lt;li>&lt;strong>卷控制器&lt;/strong>会将 PV 与 PVC 进行绑定。&lt;/li>
&lt;/ol>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/d6843a53-f815-4b10-a58d-610dd47e1665/640" alt="">&lt;/p>
&lt;h3 id="2-attaching-volumes">&lt;strong>2. Attaching Volumes&lt;/strong>&lt;/h3>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/d6843a53-f815-4b10-a58d-610dd47e1665/640" alt="">&lt;/p>
&lt;ol>
&lt;li>**AD 控制器（AttachDetachController）&lt;strong>观察到使用 CSI 类型 PV 的 Pod 被调度到某一节点，此时 &lt;strong>AD 控制器&lt;/strong>会调用&lt;/strong>内部 in-tree CSI 插件（csiAttacher）**的 Attach 函数。&lt;/li>
&lt;li>**内部 in-tree CSI 插件（csiAttacher）**会创建一个 VolumeAttachment 对象到集群中。&lt;/li>
&lt;li>&lt;strong>External Attacher&lt;/strong>观察到该 VolumeAttachment 对象，并调用&lt;strong>外部 CSI&lt;/strong> &lt;strong>插件&lt;/strong>的 &lt;strong>ControllerPublish 函数&lt;/strong>以将卷挂接到对应节点上。&lt;strong>外部 CSI 插件&lt;/strong>挂载成功后，&lt;strong>External Attacher&lt;/strong> 会更新相关 VolumeAttachment 对象的 .Status.Attached 为 true。&lt;/li>
&lt;/ol>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/d6843a53-f815-4b10-a58d-610dd47e1665/640" alt="">&lt;/p>
&lt;ol start="4">
&lt;li>**AD 控制器内部 in-tree CSI 插件（csiAttacher）**观察到 VolumeAttachment 对象的 .Status.Attached 设置为 true，于是更新 &lt;strong>AD 控制器&lt;/strong>内部状态（ActualStateOfWorld），该状态会显示在 Node 资源的 .Status.VolumesAttached 上。&lt;/li>
&lt;/ol>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/d6843a53-f815-4b10-a58d-610dd47e1665/640" alt="">&lt;/p>
&lt;h3 id="3-mounting-volumes">&lt;strong>3. Mounting Volumes&lt;/strong>&lt;/h3>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/d6843a53-f815-4b10-a58d-610dd47e1665/640" alt="">&lt;/p>
&lt;ol>
&lt;li>**Volume Manager（Kubelet 组件）&lt;strong>观察到有新的使用 CSI 类型 PV 的 Pod 调度到本节点上，于是调用&lt;/strong>内部 in-tree CSI 插件（csiAttacher）**的 WaitForAttach 函数。&lt;/li>
&lt;li>**内部 in-tree CSI 插件（csiAttacher）**等待集群中 VolumeAttachment 对象状态 .Status.Attached 变为 true。&lt;/li>
&lt;li>&lt;strong>in-tree CSI 插件（csiAttacher）&lt;strong>调用 MountDevice 函数，该函数内部通过 unix domain socket 调用&lt;/strong>外部 CSI 插件&lt;/strong>的 &lt;strong>NodeStageVolume 函数&lt;/strong>；之后&lt;strong>插件（csiAttacher）&lt;strong>调用&lt;/strong>内部 in-tree CSI 插件（csiMountMgr）&lt;strong>的 SetUp 函数，该函数内部会通过 unix domain socket 调用&lt;/strong>外部 CSI 插件&lt;/strong>的 &lt;strong>NodePublishVolume 函数&lt;/strong>。&lt;/li>
&lt;/ol>
&lt;h3 id="4-unmounting-volumes">&lt;strong>4. Unmounting Volumes&lt;/strong>&lt;/h3>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/d6843a53-f815-4b10-a58d-610dd47e1665/640" alt="">&lt;/p>
&lt;ol>
&lt;li>&lt;strong>用户&lt;/strong>删除相关 Pod。&lt;/li>
&lt;li>&lt;strong>Volume Manager（Kubelet 组件）&lt;strong>观察到包含 CSI 存储卷的 Pod 被删除，于是调用&lt;/strong>内部 in-tree CSI 插件（csiMountMgr）&lt;strong>的 TearDown 函数，该函数内部会通过 unix domain socket 调用&lt;/strong>外部 CSI 插件&lt;/strong>的 &lt;strong>NodeUnpublishVolume 函数&lt;/strong>。&lt;/li>
&lt;li>&lt;strong>Volume Manager（Kubelet 组件）&lt;strong>调用&lt;/strong>内部 in-tree CSI 插件（csiAttacher）&lt;strong>的 UnmountDevice 函数，该函数内部会通过 unix domain socket 调用&lt;/strong>外部 CSI 插件&lt;/strong>的 &lt;strong>NodeUnpublishVolume 函数&lt;/strong>。&lt;/li>
&lt;/ol>
&lt;h3 id="5-detaching-volumes">&lt;strong>5. Detaching Volumes&lt;/strong>&lt;/h3>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/d6843a53-f815-4b10-a58d-610dd47e1665/640" alt="">&lt;/p>
&lt;ol>
&lt;li>&lt;strong>AD 控制器&lt;/strong>观察到包含 CSI 存储卷的 Pod 被删除，此时该控制器会调用**内部 in-tree CSI 插件（csiAttacher）**的 Detach 函数。&lt;/li>
&lt;li>**csiAttache****r** 会删除集群中相关 VolumeAttachment 对象（但由于存在 finalizer，va 对象不会立即删除）。&lt;/li>
&lt;li>&lt;strong>External Attacher&lt;/strong> 观察到集群中 VolumeAttachment 对象的 DeletionTimestamp 非空，于是调用&lt;strong>外部 CSI 插件&lt;/strong>的 &lt;strong>ControllerUnpublish 函数&lt;/strong>以将卷从对应节点上摘除。&lt;strong>外部 CSI 插件&lt;/strong>摘除成功后，&lt;strong>External Attacher&lt;/strong> 会移除相关 VolumeAttachment 对象的 finalizer 字段，此时 VolumeAttachment 对象被彻底删除。&lt;/li>
&lt;li>&lt;strong>AD 控制器&lt;/strong>中**内部 in-tree CSI 插件（csiAttacher）**观察到 VolumeAttachment 对象已删除，于是更新 &lt;strong>AD 控制器&lt;/strong>中的内部状态；同时 &lt;strong>AD 控制器&lt;/strong>更新 Node 资源，此时 Node 资源的 .Status.VolumesAttached 上已没有相关挂接信息。&lt;/li>
&lt;/ol>
&lt;h3 id="6-deleting-volumes">&lt;strong>6. Deleting Volumes&lt;/strong>&lt;/h3>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/d6843a53-f815-4b10-a58d-610dd47e1665/640" alt="">&lt;/p>
&lt;ol>
&lt;li>&lt;strong>用户&lt;/strong>删除相关 PVC。&lt;/li>
&lt;li>&lt;strong>External Provisioner 组件&lt;/strong>观察到 PVC 删除事件，根据 PVC 的回收策略（Reclaim）执行不同操作：&lt;/li>
&lt;/ol>
&lt;ul>
&lt;li>Delete：调用&lt;strong>外部 CSI 插件&lt;/strong>的 &lt;strong>DeleteVolume 函数&lt;/strong>以删除卷；一旦卷成功删除，&lt;strong>Provisioner&lt;/strong> 会删除集群中对应 PV 对象。&lt;/li>
&lt;li>Retain：**Provisione****r** 不执行卷删除操作。&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/d6843a53-f815-4b10-a58d-610dd47e1665/640" alt="">&lt;/p>
&lt;p>&lt;strong>CSI Sidecar 组件介绍&lt;/strong>&lt;/p>
&lt;p>为使 K8s 适配 CSI 标准，社区将与 K8s 相关的存储流程逻辑放在了 CSI Sidecar 组件中。&lt;/p>
&lt;h3 id="1-node-driver-registrar">&lt;strong>1. Node Driver Registrar&lt;/strong>&lt;/h3>
&lt;h3 id="1功能">&lt;strong>1）功能&lt;/strong>&lt;/h3>
&lt;p>&lt;strong>Node-Driver-Registrar 组件&lt;/strong>会将&lt;strong>外部 CSI 插件&lt;/strong>注册到 &lt;strong>Kubelet&lt;/strong>，从而使 &lt;strong>Kubelet&lt;/strong> 通过特定的 Unix Domain Socket 来调用&lt;strong>外部 CSI 插件函数&lt;/strong>（Kubelet 会调用外部 CSI 插件的 NodeGetInfo、NodeStageVolume、NodePublishVolume、NodeGetVolumeStats 等函数）。&lt;/p>
&lt;h3 id="2原理">&lt;strong>2）原理&lt;/strong>&lt;/h3>
&lt;p>&lt;strong>Node-Driver-Registrar 组件&lt;/strong>通过 Kubelet 外部插件注册机制实现注册，注册成功后：&lt;/p>
&lt;ul>
&lt;li>&lt;strong>Kubelet&lt;/strong> 为本节点 Node 资源打 annotation：&lt;strong>Kubelet&lt;/strong> 调用&lt;strong>外部 CSI 插件&lt;/strong>的 &lt;strong>NodeGetInfo 函数&lt;/strong>，其返回值 [nodeID]、[driverName] 将作为值用于 &amp;ldquo;csi.volume.kubernetes.io/nodeid&amp;rdquo; 键。&lt;/li>
&lt;li>&lt;strong>Kubelet&lt;/strong> 更新 Node Label：将 &lt;strong>NodeGetInfo 函数&lt;/strong>返回的 [AccessibleTopology] 值用于节点的 Label。&lt;/li>
&lt;li>&lt;strong>Kubelet&lt;/strong> 更新 Node Status：将 &lt;strong>NodeGetInfo 函数&lt;/strong>返回的 maxAttachLimit（节点最大可挂载卷数量）更新到 Node 资源的 Status.Allocatable：attachable-volumes-csi-[driverName]=[maxAttachLimit]。&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/d6843a53-f815-4b10-a58d-610dd47e1665/640" alt="">&lt;/p>
&lt;ul>
&lt;li>&lt;strong>Kubelet&lt;/strong> 更新 CSINode 资源（没有则创建）：将 [driverName]、[nodeID]、[maxAttachLimit]、[AccessibleTopology] 更新到 Spec 中（拓扑仅保留 Key 值）。&lt;/li>
&lt;/ul>
&lt;h3 id="2-external-provisioner">&lt;strong>2. External Provisioner&lt;/strong>&lt;/h3>
&lt;h3 id="1功能-1">&lt;strong>1）功能&lt;/strong>&lt;/h3>
&lt;p>创建 / 删除实际的存储卷，以及代表存储卷的 PV 资源。&lt;/p>
&lt;h3 id="2原理-1">&lt;strong>2）原理&lt;/strong>&lt;/h3>
&lt;p>&lt;strong>External-Provisioner&lt;/strong> 在启动时需指定参数 &amp;ndash; provisioner，该参数指定 Provisioner 名称，与 StorageClass 中的 provisioner 字段对应。&lt;/p>
&lt;p>&lt;strong>External-Provisioner&lt;/strong> 启动后会 watch 集群中的 PVC 和 PV 资源。&lt;/p>
&lt;p>对于集群中的 PVC 资源：&lt;/p>
&lt;ul>
&lt;li>判断 PVC 是否需要动态创建存储卷，标准如下：&lt;/li>
&lt;li>PVC 的 annotation 中是否包含 &amp;ldquo;volume.beta.kubernetes.io/storage-provisioner&amp;rdquo; 键（由卷控制器创建），并且其值是否与 Provisioner 名称相等。&lt;/li>
&lt;li>PVC 对应 StorageClass 的 VolumeBindingMode 字段若为 WaitForFirstConsumer，则 PVC 的 annotation 中必须包含 &amp;ldquo;volume.kubernetes.io/selected-node&amp;rdquo; 键（详见调度器如何处理 WaitForFirstConsumer），且其值不为空；若为 Immediate 则表示需要 Provisioner 立即提供动态存储卷。&lt;/li>
&lt;li>通过特定的 Unix Domain Socket 调用&lt;strong>外部 CSI 插件&lt;/strong>的 &lt;strong>CreateVolume 函数&lt;/strong>。&lt;/li>
&lt;li>创建 PV 资源，PV 名称为 [Provisioner 指定的 PV 前缀] - [PVC uuid]。&lt;/li>
&lt;/ul>
&lt;p>对于集群中的 PV 资源：&lt;/p>
&lt;ul>
&lt;li>判断 PV 是否需要删除，标准如下：&lt;/li>
&lt;li>判断其 .Status.Phase 是否为 Release。&lt;/li>
&lt;li>判断其 .Spec.PersistentVolumeReclaimPolicy 是否为 Delete。&lt;/li>
&lt;li>判断其是否包含 annotation（pv.kubernetes.io/provisioned-by），且其值是否为自己。&lt;/li>
&lt;li>通过特定的 Unix Domain Socket 调用&lt;strong>外部 CSI 插件&lt;/strong>的 &lt;strong>DeleteVolume 接口&lt;/strong>。&lt;/li>
&lt;li>删除集群中的 PV 资源。&lt;/li>
&lt;/ul>
&lt;h3 id="3-external-attacher">&lt;strong>3. External Attacher&lt;/strong>&lt;/h3>
&lt;h3 id="1功能-2">&lt;strong>1）功能&lt;/strong>&lt;/h3>
&lt;p>挂接 / 摘除存储卷。&lt;/p>
&lt;h3 id="2原理-2">&lt;strong>2）原理&lt;/strong>&lt;/h3>
&lt;p>&lt;strong>External-Attacher&lt;/strong>内部会时刻 watch 集群中的 VolumeAttachment 资源和 PersistentVolume 资源。&lt;/p>
&lt;p>对于 VolumeAttachment 资源：&lt;/p>
&lt;ul>
&lt;li>从 VolumeAttachment 资源中获得 PV 的所有信息，如 volume ID、node ID、挂载 Secret 等。&lt;/li>
&lt;li>判断 VolumeAttachment 的 DeletionTimestamp 字段是否为空来判断其为卷挂接或卷摘除：若为卷挂接则通过特定的 Unix Domain Socket 调用&lt;strong>外部 CSI 插件&lt;/strong>的 &lt;strong>ControllerPublishVolume 接口&lt;/strong>；若为卷摘除则通过特定的 Unix Domain Socket 调用&lt;strong>外部 CSI 插件&lt;/strong>的 &lt;strong>ControllerUnpublishVolume 接口&lt;/strong>。&lt;/li>
&lt;/ul>
&lt;p>对于 PersistentVolume 资源：&lt;/p>
&lt;ul>
&lt;li>在挂接时为相关 PV 打上 Finalizer：external-attacher/[driver 名称]。&lt;/li>
&lt;li>当 PV 处于删除状态时（DeletionTimestamp 非空），删除 Finalizer：external-attacher/[driver 名称]。&lt;/li>
&lt;/ul>
&lt;h3 id="4-external-resizer">&lt;strong>4. External Resizer&lt;/strong>&lt;/h3>
&lt;h3 id="1功能-3">&lt;strong>1）功能&lt;/strong>&lt;/h3>
&lt;p>扩容存储卷。&lt;/p>
&lt;h3 id="2原理-3">&lt;strong>2）原理&lt;/strong>&lt;/h3>
&lt;p>&lt;strong>External-Resizer&lt;/strong> 内部会 watch 集群中的 PersistentVolumeClaim 资源。&lt;/p>
&lt;p>对于 PersistentVolumeClaim 资源：&lt;/p>
&lt;ul>
&lt;li>判断 PersistentVolumeClaim 资源是否需要扩容：PVC 状态需要是 Bound 且 .Status.Capacity 与 .Spec.Resources.Requests 不等。&lt;/li>
&lt;li>更新 PVC 的 .Status.Conditions，表明此时处于 Resizing 状态。&lt;/li>
&lt;li>通过特定的 Unix Domain Socket 调用&lt;strong>外部 CSI 插件&lt;/strong>的 &lt;strong>ControllerExpandVolume 接口&lt;/strong>。&lt;/li>
&lt;li>更新 PV 的 .Spec.Capacity。&lt;/li>
&lt;li>若 CSI 支持文件系统在线扩容，ControllerExpandVolume 接口返回值中 NodeExpansionRequired 字段为 true，&lt;strong>External-Resizer&lt;/strong> 更新 PVC 的 .Status.Conditions 为 FileSystemResizePending 状态；若不支持则扩容成功，&lt;strong>External-Resizer&lt;/strong> 更新 PVC 的 .Status.Conditions 为空，且更新 PVC 的 .Status.Capacity。&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>Volume Manager（Kubelet 组件）&lt;strong>观察到存储卷需在线扩容，于是通过特定的 Unix Domain Socket 调用&lt;/strong>外部 CSI 插件&lt;/strong>的 &lt;strong>NodeExpandVolume 接口&lt;/strong>实现文件系统扩容。&lt;/p>
&lt;h3 id="5-livenessprobe">&lt;strong>5. livenessprobe&lt;/strong>&lt;/h3>
&lt;h3 id="1功能-4">&lt;strong>1）功能&lt;/strong>&lt;/h3>
&lt;p>检查 CSI 插件是否正常。&lt;/p>
&lt;h3 id="2原理-4">&lt;strong>2）原理&lt;/strong>&lt;/h3>
&lt;p>通过对外暴露一个 / healthz HTTP 端口以服务 kubelet 的探针探测器，内部是通过特定的 Unix Domain Socket 调用&lt;strong>外部 CSI 插件&lt;/strong>的 &lt;strong>Probe 接口&lt;/strong>。&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/d6843a53-f815-4b10-a58d-610dd47e1665/640" alt="">&lt;/p>
&lt;p>&lt;strong>CSI 接口介绍&lt;/strong>&lt;/p>
&lt;p>三方存储厂商需实现 CSI 插件的三大接口：&lt;strong>IdentityServer、ControllerServer、NodeServer&lt;/strong>。&lt;/p>
&lt;h3 id="1-identityserver">&lt;strong>1. IdentityServer&lt;/strong>&lt;/h3>
&lt;p>IdentityServer 主要用于认证 CSI 插件的身份信息。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-typescript" data-lang="typescript">&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">type&lt;/span> &lt;span style="color:#a6e22e">IdentityServer&lt;/span> &lt;span style="color:#66d9ef">interface&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">GetPluginInfo&lt;/span>(&lt;span style="color:#a6e22e">context&lt;/span>.&lt;span style="color:#a6e22e">Context&lt;/span>, &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">GetPluginInfoRequest&lt;/span>) (&lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">GetPluginInfoResponse&lt;/span>, &lt;span style="color:#a6e22e">error&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">GetPluginCapabilities&lt;/span>(&lt;span style="color:#a6e22e">context&lt;/span>.&lt;span style="color:#a6e22e">Context&lt;/span>, &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">GetPluginCapabilitiesRequest&lt;/span>) (&lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">GetPluginCapabilitiesResponse&lt;/span>, &lt;span style="color:#a6e22e">error&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">Probe&lt;/span>(&lt;span style="color:#a6e22e">context&lt;/span>.&lt;span style="color:#a6e22e">Context&lt;/span>, &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">ProbeRequest&lt;/span>) (&lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">ProbeResponse&lt;/span>, &lt;span style="color:#a6e22e">error&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="2-controllerserver">&lt;strong>2. ControllerServer&lt;/strong>&lt;/h3>
&lt;p>ControllerServer 主要负责存储卷及快照的创建 / 删除以及挂接 / 摘除操作。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-typescript" data-lang="typescript">&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">type&lt;/span> &lt;span style="color:#a6e22e">ControllerServer&lt;/span> &lt;span style="color:#66d9ef">interface&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">CreateVolume&lt;/span>(&lt;span style="color:#a6e22e">context&lt;/span>.&lt;span style="color:#a6e22e">Context&lt;/span>, &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">CreateVolumeRequest&lt;/span>) (&lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">CreateVolumeResponse&lt;/span>, &lt;span style="color:#a6e22e">error&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">DeleteVolume&lt;/span>(&lt;span style="color:#a6e22e">context&lt;/span>.&lt;span style="color:#a6e22e">Context&lt;/span>, &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">DeleteVolumeRequest&lt;/span>) (&lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">DeleteVolumeResponse&lt;/span>, &lt;span style="color:#a6e22e">error&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">ControllerPublishVolume&lt;/span>(&lt;span style="color:#a6e22e">context&lt;/span>.&lt;span style="color:#a6e22e">Context&lt;/span>, &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">ControllerPublishVolumeRequest&lt;/span>) (&lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">ControllerPublishVolumeResponse&lt;/span>, &lt;span style="color:#a6e22e">error&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">ControllerUnpublishVolume&lt;/span>(&lt;span style="color:#a6e22e">context&lt;/span>.&lt;span style="color:#a6e22e">Context&lt;/span>, &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">ControllerUnpublishVolumeRequest&lt;/span>) (&lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">ControllerUnpublishVolumeResponse&lt;/span>, &lt;span style="color:#a6e22e">error&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">ValidateVolumeCapabilities&lt;/span>(&lt;span style="color:#a6e22e">context&lt;/span>.&lt;span style="color:#a6e22e">Context&lt;/span>, &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">ValidateVolumeCapabilitiesRequest&lt;/span>) (&lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">ValidateVolumeCapabilitiesResponse&lt;/span>, &lt;span style="color:#a6e22e">error&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">ListVolumes&lt;/span>(&lt;span style="color:#a6e22e">context&lt;/span>.&lt;span style="color:#a6e22e">Context&lt;/span>, &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">ListVolumesRequest&lt;/span>) (&lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">ListVolumesResponse&lt;/span>, &lt;span style="color:#a6e22e">error&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">GetCapacity&lt;/span>(&lt;span style="color:#a6e22e">context&lt;/span>.&lt;span style="color:#a6e22e">Context&lt;/span>, &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">GetCapacityRequest&lt;/span>) (&lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">GetCapacityResponse&lt;/span>, &lt;span style="color:#a6e22e">error&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">ControllerGetCapabilities&lt;/span>(&lt;span style="color:#a6e22e">context&lt;/span>.&lt;span style="color:#a6e22e">Context&lt;/span>, &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">ControllerGetCapabilitiesRequest&lt;/span>) (&lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">ControllerGetCapabilitiesResponse&lt;/span>, &lt;span style="color:#a6e22e">error&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">CreateSnapshot&lt;/span>(&lt;span style="color:#a6e22e">context&lt;/span>.&lt;span style="color:#a6e22e">Context&lt;/span>, &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">CreateSnapshotRequest&lt;/span>) (&lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">CreateSnapshotResponse&lt;/span>, &lt;span style="color:#a6e22e">error&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">DeleteSnapshot&lt;/span>(&lt;span style="color:#a6e22e">context&lt;/span>.&lt;span style="color:#a6e22e">Context&lt;/span>, &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">DeleteSnapshotRequest&lt;/span>) (&lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">DeleteSnapshotResponse&lt;/span>, &lt;span style="color:#a6e22e">error&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">ListSnapshots&lt;/span>(&lt;span style="color:#a6e22e">context&lt;/span>.&lt;span style="color:#a6e22e">Context&lt;/span>, &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">ListSnapshotsRequest&lt;/span>) (&lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">ListSnapshotsResponse&lt;/span>, &lt;span style="color:#a6e22e">error&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">ControllerExpandVolume&lt;/span>(&lt;span style="color:#a6e22e">context&lt;/span>.&lt;span style="color:#a6e22e">Context&lt;/span>, &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">ControllerExpandVolumeRequest&lt;/span>) (&lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">ControllerExpandVolumeResponse&lt;/span>, &lt;span style="color:#a6e22e">error&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="3-nodeserver">&lt;strong>3. NodeServer&lt;/strong>&lt;/h3>
&lt;p>NodeServer 主要负责存储卷挂载 / 卸载操作。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-typescript" data-lang="typescript">&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">type&lt;/span> &lt;span style="color:#a6e22e">NodeServer&lt;/span> &lt;span style="color:#66d9ef">interface&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">NodeStageVolume&lt;/span>(&lt;span style="color:#a6e22e">context&lt;/span>.&lt;span style="color:#a6e22e">Context&lt;/span>, &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">NodeStageVolumeRequest&lt;/span>) (&lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">NodeStageVolumeResponse&lt;/span>, &lt;span style="color:#a6e22e">error&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">NodeUnstageVolume&lt;/span>(&lt;span style="color:#a6e22e">context&lt;/span>.&lt;span style="color:#a6e22e">Context&lt;/span>, &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">NodeUnstageVolumeRequest&lt;/span>) (&lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">NodeUnstageVolumeResponse&lt;/span>, &lt;span style="color:#a6e22e">error&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">NodePublishVolume&lt;/span>(&lt;span style="color:#a6e22e">context&lt;/span>.&lt;span style="color:#a6e22e">Context&lt;/span>, &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">NodePublishVolumeRequest&lt;/span>) (&lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">NodePublishVolumeResponse&lt;/span>, &lt;span style="color:#a6e22e">error&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">NodeUnpublishVolume&lt;/span>(&lt;span style="color:#a6e22e">context&lt;/span>.&lt;span style="color:#a6e22e">Context&lt;/span>, &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">NodeUnpublishVolumeRequest&lt;/span>) (&lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">NodeUnpublishVolumeResponse&lt;/span>, &lt;span style="color:#a6e22e">error&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">NodeGetVolumeStats&lt;/span>(&lt;span style="color:#a6e22e">context&lt;/span>.&lt;span style="color:#a6e22e">Context&lt;/span>, &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">NodeGetVolumeStatsRequest&lt;/span>) (&lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">NodeGetVolumeStatsResponse&lt;/span>, &lt;span style="color:#a6e22e">error&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">NodeExpandVolume&lt;/span>(&lt;span style="color:#a6e22e">context&lt;/span>.&lt;span style="color:#a6e22e">Context&lt;/span>, &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">NodeExpandVolumeRequest&lt;/span>) (&lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">NodeExpandVolumeResponse&lt;/span>, &lt;span style="color:#a6e22e">error&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">NodeGetCapabilities&lt;/span>(&lt;span style="color:#a6e22e">context&lt;/span>.&lt;span style="color:#a6e22e">Context&lt;/span>, &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">NodeGetCapabilitiesRequest&lt;/span>) (&lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">NodeGetCapabilitiesResponse&lt;/span>, &lt;span style="color:#a6e22e">error&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">NodeGetInfo&lt;/span>(&lt;span style="color:#a6e22e">context&lt;/span>.&lt;span style="color:#a6e22e">Context&lt;/span>, &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">NodeGetInfoRequest&lt;/span>) (&lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">NodeGetInfoResponse&lt;/span>, &lt;span style="color:#a6e22e">error&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/d6843a53-f815-4b10-a58d-610dd47e1665/640" alt="">&lt;/p>
&lt;p>&lt;strong>K8s CSI API 对象&lt;/strong>&lt;/p>
&lt;p>K8s 为支持 CSI 标准，包含如下 API 对象：&lt;/p>
&lt;ul>
&lt;li>CSINode&lt;/li>
&lt;li>CSIDriver&lt;/li>
&lt;li>VolumeAttachment&lt;/li>
&lt;/ul>
&lt;h3 id="1-csinode">&lt;strong>1. CSINode&lt;/strong>&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-properties" data-lang="properties">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">apiVersion&lt;/span>&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#e6db74">storage.k8s.io/v1beta1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">kind&lt;/span>&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#e6db74">CSINode&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">metadata&lt;/span>&lt;span style="color:#f92672">:&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">name&lt;/span>&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#e6db74">node-10.212.101.210&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">spec&lt;/span>&lt;span style="color:#f92672">:&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">drivers&lt;/span>&lt;span style="color:#f92672">:&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">-&lt;/span> &lt;span style="color:#e6db74">name: yodaplugin.csi.alibabacloud.com&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">nodeID&lt;/span>&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#e6db74">node-10.212.101.210&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">topologyKeys&lt;/span>&lt;span style="color:#f92672">:&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">-&lt;/span> &lt;span style="color:#e6db74">kubernetes.io/hostname&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">-&lt;/span> &lt;span style="color:#e6db74">name: pangu.csi.alibabacloud.com&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">nodeID&lt;/span>&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#e6db74">a5441fd9013042ee8104a674e4a9666a&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">topologyKeys&lt;/span>&lt;span style="color:#f92672">:&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">-&lt;/span> &lt;span style="color:#e6db74">topology.pangu.csi.alibabacloud.com/zone&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>作用：&lt;/p>
&lt;ol>
&lt;li>判断&lt;strong>外部 CSI 插件&lt;/strong>是否注册成功。在 Node Driver Registrar 组件向 Kubelet 注册完毕后，Kubelet 会创建该资源，故不需要显式创建 CSINode 资源。&lt;/li>
&lt;li>将 Kubernetes 中 Node 资源名称与三方存储系统中节点名称（nodeID）一一对应。此处 &lt;strong>Kubelet&lt;/strong> 会调用&lt;strong>外部 CSI 插件&lt;/strong> NodeServer 的 &lt;strong>GetNodeInfo 函数&lt;/strong>获取 nodeID。&lt;/li>
&lt;li>显示卷拓扑信息。CSINode 中 topologyKeys 用来表示存储节点的拓扑信息，卷拓扑信息会使得 &lt;strong>Scheduler&lt;/strong> 在 Pod 调度时选择合适的存储节点。&lt;/li>
&lt;/ol>
&lt;h3 id="2-csidriver">&lt;strong>2. CSIDriver&lt;/strong>&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-properties" data-lang="properties">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">apiVersion&lt;/span>&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#e6db74">storage.k8s.io/v1beta1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">kind&lt;/span>&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#e6db74">CSIDriver&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">metadata&lt;/span>&lt;span style="color:#f92672">:&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">name&lt;/span>&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#e6db74">pangu.csi.alibabacloud.com&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">spec&lt;/span>&lt;span style="color:#f92672">:&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">attachRequired&lt;/span>&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#e6db74">true&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">podInfoOnMount&lt;/span>&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#e6db74">true&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">volumeLifecycleModes&lt;/span>&lt;span style="color:#f92672">:&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">-&lt;/span> &lt;span style="color:#e6db74">Persistent&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>作用：&lt;/p>
&lt;ol>
&lt;li>简化&lt;strong>外部 CSI 插件&lt;/strong>的发现。由集群管理员创建，通过 kubectl get csidriver 即可得知环境上有哪些 CSI 插件。&lt;/li>
&lt;li>自定 义 Kubernetes 行为，如一些外部 CSI 插件不需要执行卷挂接（VolumeAttach）操作，则可以设置 .spec.attachRequired 为 false。&lt;/li>
&lt;/ol>
&lt;h3 id="3-volumeattachment">&lt;strong>3. VolumeAttachment&lt;/strong>&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-properties" data-lang="properties">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">apiVersion&lt;/span>&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#e6db74">storage.k8s.io/v1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">kind&lt;/span>&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#e6db74">VolumeAttachment&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">metadata&lt;/span>&lt;span style="color:#f92672">:&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">annotations&lt;/span>&lt;span style="color:#f92672">:&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">csi.alpha.kubernetes.io/node-id&lt;/span>&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#e6db74">21481ae252a2457f9abcb86a3d02ba05&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">finalizers&lt;/span>&lt;span style="color:#f92672">:&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">-&lt;/span> &lt;span style="color:#e6db74">external-attacher/pangu-csi-alibabacloud-com&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">name&lt;/span>&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#e6db74">csi-0996e5e9459e1ccc1b3a7aba07df4ef7301c8e283d99eabc1b69626b119ce750&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">spec&lt;/span>&lt;span style="color:#f92672">:&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">attacher&lt;/span>&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#e6db74">pangu.csi.alibabacloud.com&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">nodeName&lt;/span>&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#e6db74">node-10.212.101.241&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">source&lt;/span>&lt;span style="color:#f92672">:&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">persistentVolumeName&lt;/span>&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#e6db74">pangu-39aa24e7-8877-11eb-b02f-021234350de1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">status&lt;/span>&lt;span style="color:#f92672">:&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">attached&lt;/span>&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#e6db74">true&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>作用：VolumeAttachment 记录了存储卷的挂接 / 摘除信息以及节点信息。&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/d6843a53-f815-4b10-a58d-610dd47e1665/640" alt="">&lt;/p>
&lt;p>&lt;strong>支持特性&lt;/strong>&lt;/p>
&lt;h3 id="1-拓扑支持">&lt;strong>1. 拓扑支持&lt;/strong>&lt;/h3>
&lt;p>在 StorageClass 中有 AllowedTopologies 字段：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-properties" data-lang="properties">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">apiVersion&lt;/span>&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#e6db74">storage.k8s.io/v1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">kind&lt;/span>&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#e6db74">StorageClass&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">metadata&lt;/span>&lt;span style="color:#f92672">:&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">name&lt;/span>&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#e6db74">csi-pangu&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">provisioner&lt;/span>&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#e6db74">pangu.csi.alibabacloud.com&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">parameters&lt;/span>&lt;span style="color:#f92672">:&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">type&lt;/span>&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#e6db74">cloud_ssd&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">volumeBindingMode&lt;/span>&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#e6db74">Immediate&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">allowedTopologies&lt;/span>&lt;span style="color:#f92672">:&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">-&lt;/span> &lt;span style="color:#e6db74">matchLabelExpressions:&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">-&lt;/span> &lt;span style="color:#e6db74">key: topology.pangu.csi.alibabacloud.com/zone&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">values&lt;/span>&lt;span style="color:#f92672">:&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">-&lt;/span> &lt;span style="color:#e6db74">zone-1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">-&lt;/span> &lt;span style="color:#e6db74">zone-2&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;strong>外部 CSI 插件&lt;/strong>部署后会为每个节点打标，打标内容 &lt;strong>NodeGetInfo 函数&lt;/strong>返回的 [AccessibleTopology] 值（详见 Node Driver Registrar 部分）。&lt;/p>
&lt;p>&lt;strong>External Provisioner&lt;/strong> 在调用 CSI 插件的 CreateVolume 接口之前，会在请求参数设置 AccessibilityRequirements：&lt;/p>
&lt;ul>
&lt;li>对于 WaitForFirstConsumer&lt;/li>
&lt;li>当 PVC 的 anno 中包含 &amp;ldquo;volume.kubernetes.io/selected-node&amp;rdquo; 且不为空，则先获取对应节点 CSINode 的 TopologyKeys，然后根据该 TopologyKeys 键从 Node 资源的 Label 获取 Values 值，最后拿该 Values 值与 StorageClass 的 AllowedTopologies 比对，判断其是否包含于其中；若不包含则报错。&lt;/li>
&lt;li>对于 Immediately&lt;/li>
&lt;li>将 StorageClass 的 AllowedTopologies 的值填进来，若 StorageClass 没有设置 AllowedTopologies 则将所有包含 TopologyKeys 键的节点 Value 添进来。&lt;/li>
&lt;/ul>
&lt;h3 id="scheduler-如何处理使用存储卷调度">&lt;strong>Scheduler 如何处理使用存储卷调度&lt;/strong>&lt;/h3>
&lt;blockquote>
&lt;p>基于社区 1.18 版本调度器&lt;/p>
&lt;/blockquote>
&lt;p>调度器的调度过程主要有如下三步：&lt;/p>
&lt;ul>
&lt;li>&lt;strong>预选（Filter）&lt;/strong>：筛选满足 Pod 调度要求的节点列表。&lt;/li>
&lt;li>&lt;strong>优选（Score）&lt;/strong>：通过内部的优选算法为节点打分，获得最高分数的节点即为选中的节点。&lt;/li>
&lt;li>&lt;strong>绑定（Bind）&lt;/strong>：调度器将调度结果通知给 kube-apiserver，更新 Pod 的 .spec.nodeName 字段。&lt;/li>
&lt;/ul>
&lt;p>调度器预选阶段：处理 Pod 的 PVC/PV 绑定关系以及动态供应 PV（Dynamic Provisioning），同时使调度器调度时考虑 Pod 所使用 PV 的节点亲和性。详细调度过程如下：&lt;/p>
&lt;ol>
&lt;li>Pod 不包含 PVC 直接跳过。&lt;/li>
&lt;li>FindPodVolumes&lt;/li>
&lt;/ol>
&lt;ul>
&lt;li>获取 Pod 的 boundClaims、claimsToBind 以及 unboundClaimsImmediate。&lt;/li>
&lt;li>boundClaims：已 Bound 的 PVC&lt;/li>
&lt;li>claimsToBind：PVC 对应 StorageClass 的 VolumeBindingMode 为 VolumeBindingWaitForFirstConsumer&lt;/li>
&lt;li>unboundClaimsImmediate：PVC 对应 StorageClass 的 VolumeBindingMode 为 VolumeBindingImmediate&lt;/li>
&lt;li>若 len(unboundClaimsImmediate) 不为空，表示这种 PVC 需要立即绑定 PV（即存 PVC 创建后，立刻动态创建 PV 并将其绑定到 PVC，该过程不走调度），若 PVC 处于 unbound 阶段则报错。&lt;/li>
&lt;li>若 len(boundClaims) 不为空，则检查 PVC 对应 PV 的节点亲和性与当前节点的 Label 是否冲突，若冲突则报错（可检查 Immediate 类型的 PV 拓扑）。&lt;/li>
&lt;li>若 len(claimsToBind) 不为空&lt;/li>
&lt;li>先检查环境中已有的 PV 能否与该 PVC 匹配（findMatchingVolumes），将能够匹配 PVC 的 PV 记录在调度器的 cache 中。&lt;/li>
&lt;li>未匹配到 PV 的 PVC 走动态调度流程，动态调度主要通过 StorageClass 的 AllowedTopologies 字段判断当前调度节点是否满足拓扑要求（针对 WaitForFirstConsumer 类型的 PVC）。&lt;/li>
&lt;/ul>
&lt;p>调度器优选阶段不讨论。&lt;/p>
&lt;p>调度器 Assume 阶段&lt;/p>
&lt;blockquote>
&lt;p>调度器会先 Assume PV/PVC，再 Assume Pod。&lt;/p>
&lt;/blockquote>
&lt;ol>
&lt;li>将当前待调度的 Pod 进行深拷贝。&lt;/li>
&lt;li>AssumePodVolumes（针对 WaitForFirstConsumer 类型的 PVC）&lt;/li>
&lt;/ol>
&lt;ul>
&lt;li>更改调度器 cache 中已经 Match 的 PV 信息：设置 annotation：pv.kubernetes.io/bound-by-controller=&amp;ldquo;yes&amp;rdquo;。&lt;/li>
&lt;li>更改调度器 cache 中未匹配到 PV 的 PVC，设置 annotation：volume.kubernetes.io/selected-node=【所选节点】。&lt;/li>
&lt;/ul>
&lt;ol start="3">
&lt;li>Assume Pod 完毕&lt;/li>
&lt;/ol>
&lt;ul>
&lt;li>更改调度器 cache 中 Pod 的 .Spec.NodeName 为【所选节点】。&lt;/li>
&lt;/ul>
&lt;p>调度器 Bind 阶段&lt;/p>
&lt;p>BindPodVolumes：&lt;/p>
&lt;ul>
&lt;li>调用 Kubernetes 的 API 更新集群中 PV/PVC 资源，使其与调度器 Cache 中的 PV/PVC 一致。&lt;/li>
&lt;li>检查 PV/PVC 状态：&lt;/li>
&lt;li>检查所有 PVC 是否已处于 Bound 状态。&lt;/li>
&lt;li>检查所有 PV 的 NodeAffinity 是否与节点 Label 冲突。&lt;/li>
&lt;li>调度器执行 Bind 操作：调用 Kubernetes 的 API 更新 Pod 的 .Spec.NodeName 字段。&lt;/li>
&lt;/ul>
&lt;h3 id="2-存储卷扩容">&lt;strong>2. 存储卷扩容&lt;/strong>&lt;/h3>
&lt;p>存储卷扩容部分在 External Resizer 部分已提到，故不再赘述。用户只需要编辑 PVC 的 .Spec.Resources.Requests.Storage 字段即可，注意只可扩容不可缩容。&lt;/p>
&lt;p>若 PV 扩容失败，此时 PVC 无法重新编辑 spec 字段的 storage 为原来的值（只可扩容不可缩容）。参考 K8s 官网提供的 PVC 还原方法：&lt;/p>
&lt;p>&lt;em>&lt;a href="https://kubernetes.io/docs/concepts/storage/persistent-volumes/#recovering-from-failure-when-expanding-volumes">https://kubernetes.io/docs/concepts/storage/persistent-volumes/#recovering-from-failure-when-expanding-volumes&lt;/a>&lt;/em>&lt;/p>
&lt;h3 id="3-单节点卷数量限制">&lt;strong>3. 单节点卷数量限制&lt;/strong>&lt;/h3>
&lt;p>卷数量限制在 Node Driver Registrar 部分已提到，故不再赘述。&lt;/p>
&lt;h3 id="4-存储卷监控">&lt;strong>4. 存储卷监控&lt;/strong>&lt;/h3>
&lt;p>存储商需实现 CSI 插件的 NodeGetVolumeStats 接口，Kubelet 会调用该函数，并反映在其 metrics 上：&lt;/p>
&lt;ul>
&lt;li>kubelet_volume_stats_capacity_bytes：存储卷容量&lt;/li>
&lt;li>kubelet_volume_stats_used_bytes：存储卷已使用容量&lt;/li>
&lt;li>kubelet_volume_stats_available_bytes：存储卷可使用容量&lt;/li>
&lt;li>kubelet_volume_stats_inodes：存储卷 inode 总量&lt;/li>
&lt;li>kubelet_volume_stats_inodes_used：存储卷 inode 使用量&lt;/li>
&lt;li>kubelet_volume_stats_inodes_free：存储卷 inode 剩余量&lt;/li>
&lt;/ul>
&lt;h3 id="5-secret">&lt;strong>5. Secret&lt;/strong>&lt;/h3>
&lt;p>CSI 存储卷支持传入 Secret 来处理不同流程中所需要的私密数据，目前 StorageClass 支持如下 Parameter：&lt;/p>
&lt;ul>
&lt;li>csi.storage.k8s.io/provisioner-secret-name&lt;/li>
&lt;li>csi.storage.k8s.io/provisioner-secret-namespace&lt;/li>
&lt;li>csi.storage.k8s.io/controller-publish-secret-name&lt;/li>
&lt;li>csi.storage.k8s.io/controller-publish-secret-namespace&lt;/li>
&lt;li>csi.storage.k8s.io/node-stage-secret-name&lt;/li>
&lt;li>csi.storage.k8s.io/node-stage-secret-namespace&lt;/li>
&lt;li>csi.storage.k8s.io/node-publish-secret-name&lt;/li>
&lt;li>csi.storage.k8s.io/node-publish-secret-namespace&lt;/li>
&lt;li>csi.storage.k8s.io/controller-expand-secret-name&lt;/li>
&lt;li>csi.storage.k8s.io/controller-expand-secret-namespace&lt;/li>
&lt;/ul>
&lt;p>Secret 会包含在对应 CSI 接口的参数中，如对于 CreateVolume 接口而言则包含在 CreateVolumeRequest.Secrets 中。&lt;/p>
&lt;h3 id="6-块设备">&lt;strong>6. 块设备&lt;/strong>&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-properties" data-lang="properties">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">apiVersion&lt;/span>&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#e6db74">apps/v1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">kind&lt;/span>&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#e6db74">StatefulSet&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">metadata&lt;/span>&lt;span style="color:#f92672">:&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">name&lt;/span>&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#e6db74">nginx-example&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">spec&lt;/span>&lt;span style="color:#f92672">:&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">selector&lt;/span>&lt;span style="color:#f92672">:&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">matchLabels&lt;/span>&lt;span style="color:#f92672">:&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">app&lt;/span>&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#e6db74">nginx&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">serviceName&lt;/span>&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#e6db74">&amp;#34;nginx&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">volumeClaimTemplates&lt;/span>&lt;span style="color:#f92672">:&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">-&lt;/span> &lt;span style="color:#e6db74">metadata:&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">name&lt;/span>&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#e6db74">html&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">spec&lt;/span>&lt;span style="color:#f92672">:&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">accessModes&lt;/span>&lt;span style="color:#f92672">:&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">-&lt;/span> &lt;span style="color:#e6db74">ReadWriteOnce&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">volumeMode&lt;/span>&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#e6db74">Block&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">storageClassName&lt;/span>&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#e6db74">csi-pangu&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">resources&lt;/span>&lt;span style="color:#f92672">:&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">requests&lt;/span>&lt;span style="color:#f92672">:&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">storage&lt;/span>&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#e6db74">40Gi&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">template&lt;/span>&lt;span style="color:#f92672">:&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">metadata&lt;/span>&lt;span style="color:#f92672">:&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">labels&lt;/span>&lt;span style="color:#f92672">:&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">app&lt;/span>&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#e6db74">nginx&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">spec&lt;/span>&lt;span style="color:#f92672">:&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">containers&lt;/span>&lt;span style="color:#f92672">:&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">-&lt;/span> &lt;span style="color:#e6db74">name: nginx&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">image&lt;/span>&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#e6db74">nginx&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">volumeDevices&lt;/span>&lt;span style="color:#f92672">:&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">-&lt;/span> &lt;span style="color:#e6db74">devicePath: &amp;#34;/dev/vdb&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">name&lt;/span>&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#e6db74">html&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>三方存储厂商需实现 NodePublishVolume 接口。Kubernetes 提供了针对块设备的工具包（&amp;ldquo;k8s.io/kubernetes/pkg/util/mount&amp;rdquo;），在 NodePublishVolume 阶段可调用该工具的 EnsureBlock 和 MountBlock 函数。&lt;/p>
&lt;h3 id="7-卷快照--卷克隆能力">&lt;strong>7. 卷快照 / 卷克隆能力&lt;/strong>&lt;/h3>
&lt;p>鉴于本文篇幅，此处不做过多原理性介绍。读者感兴趣见官方介绍：卷快照、卷克隆。&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/d6843a53-f815-4b10-a58d-610dd47e1665/640" alt="">&lt;/p>
&lt;p>&lt;strong>总结&lt;/strong>&lt;/p>
&lt;p>本文首先对 CSI 核心流程进行了大体介绍，并结合 CSI Sidecar 组件、CSI 接口、API 对象对 CSI 标准进行了深度解析。在 K8s 上，使用任何一种 CSI 存储卷都离不开上面的流程，环境上的容器存储问题也一定是其中某个环节出现了问题。本文对其流程进行梳理，以便于广大程序猿（媛）排查环境问题。&lt;/p>
&lt;p>容器存储的坑比较多，专有云环境下尤其如此。不过挑战越多，机遇也越多！目前国内专有云市场群雄逐鹿，阿里云云原生部门欢迎大侠的加入，一起共创未来！若有意向可投简历至邮箱：huizhi.szh@alibaba-inc.com。&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/d6843a53-f815-4b10-a58d-610dd47e1665/640" alt="">&lt;/p>
&lt;p>&lt;strong>KubeMeet 杭州站开放报名！&lt;/strong>&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/d6843a53-f815-4b10-a58d-610dd47e1665/640" alt="">&lt;/p>
&lt;p>4 月 17 日，云原生基金会 CNCF 和阿里巴巴联合主办的「KubeMeet 开发者沙龙 · 云原生应用管理专场」来到杭州啦！这里有 Kubernetes 生态开发者都在关注的开源项目，以及阿里巴巴、携程、第四范式的一线云原生落地实践。点击**【阅读原文】** 赶紧报名吧！&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/d6843a53-f815-4b10-a58d-610dd47e1665/640" alt="">&lt;/p>
&lt;p>&lt;strong>戳原文，立即报名！&lt;/strong>
&lt;a href="https://mp.weixin.qq.com/s/A9xWKMmrxPyOEiCs_sicYQ">https://mp.weixin.qq.com/s/A9xWKMmrxPyOEiCs_sicYQ&lt;/a>&lt;/p></description></item><item><title>Docs: longhorn</title><link>https://desistdaydream.github.io/docs/10.%E4%BA%91%E5%8E%9F%E7%94%9F/2.3.Kubernetes-%E5%AE%B9%E5%99%A8%E7%BC%96%E6%8E%92%E7%B3%BB%E7%BB%9F/9.Kubernetes-%E5%AD%98%E5%82%A8/CSI/longhorn/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/10.%E4%BA%91%E5%8E%9F%E7%94%9F/2.3.Kubernetes-%E5%AE%B9%E5%99%A8%E7%BC%96%E6%8E%92%E7%B3%BB%E7%BB%9F/9.Kubernetes-%E5%AD%98%E5%82%A8/CSI/longhorn/</guid><description>
&lt;h1 id="heading">&lt;/h1>
&lt;h1 id="longhorn-介绍">Longhorn 介绍&lt;/h1>
&lt;p>官方文档：&lt;a href="https://longhorn.io/docs">https://longhorn.io/docs&lt;/a>&lt;/p>
&lt;p>Longhorn 是一个用于 Kubernetes 的轻量、可靠且功能强大的分布式 block storage(块存储) 系统&lt;/p></description></item><item><title>Docs: Rook</title><link>https://desistdaydream.github.io/docs/10.%E4%BA%91%E5%8E%9F%E7%94%9F/2.3.Kubernetes-%E5%AE%B9%E5%99%A8%E7%BC%96%E6%8E%92%E7%B3%BB%E7%BB%9F/9.Kubernetes-%E5%AD%98%E5%82%A8/CSI/Rook/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/10.%E4%BA%91%E5%8E%9F%E7%94%9F/2.3.Kubernetes-%E5%AE%B9%E5%99%A8%E7%BC%96%E6%8E%92%E7%B3%BB%E7%BB%9F/9.Kubernetes-%E5%AD%98%E5%82%A8/CSI/Rook/</guid><description>
&lt;h1 id="rook-简介">Rook 简介&lt;/h1>
&lt;p>官方文档：&lt;a href="https://rook.github.io/docs/rook/master/">https://rook.github.io/docs/rook/master/&lt;/a>&lt;/p>
&lt;p>Rook 是一个开源的 cloud-native storage orchestrator(云原生存储协调器), 提供平台和框架；为各种存储解决方案提供平台、框架和支持，以便与云原生环境本地集成。Rook 作为云原生存储的编排系统，可以直接帮助维护人员管理有状态的存储程序。可以说是一个 SAAS，Storage as a service。&lt;/p>
&lt;p>Rook 将存储软件转变为自我管理、自我扩展和自我修复的存储服务，它通过自动化部署、引导、配置、置备、扩展、升级、迁移、灾难恢复、监控和资源管理来实现此目的。&lt;/p>
&lt;p>Rook 目前支持 Ceph、NFS、Minio Object Store、CockroachDB 等。这些存储的作用其中之一就是为各个业务提供存储空间，以便统一管理。e.g.使用 Rook 创建一个分布式的 ceph 集群，然后作为 k8s 集群的 storageClass，在某 Pod 需要使用卷的时候，可以直接从 ceph 集群中，拿去存储空间来使用。&lt;/p>
&lt;p>Rook 使用底层云本机容器管理、调度和编排平台提供的工具来实现它自身的功能。&lt;/p>
&lt;p>Rook 使用 Kubernetes 原语使 Ceph 存储系统能够在 Kubernetes 上运行。下图说明了 Ceph Rook 如何与 Kubernetes 集成：&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/kll50k/1616117730705-c83c3c8d-40a2-4f54-a1bc-eff7e8f6f84a.jpeg" alt="">&lt;/p>
&lt;p>随着 Rook 在 Kubernetes 集群中运行，Kubernetes 应用程序可以挂载由 Rook 管理的块设备和文件系统，或者可以使用 S3 / Swift API 提供对象存储。Rook oprerator 自动配置存储组件并监控群集，以确保存储处于可用和健康状态。&lt;/p>
&lt;p>Rook oprerator 是一个简单的容器，具有引导和监视存储集群所需的全部功能。oprerator 将启动并监控 ceph monitor pods 和 OSDs 的守护进程，它提供基本的 RADOS 存储。oprerator 通过初始化运行服务所需的 pod 和其他组件来管理池，对象存储（S3 / Swift）和文件系统的 CRD。&lt;/p>
&lt;p>oprerator 将监视存储后台驻留程序以确保群集正常运行。Ceph mons 将在必要时启动或故障转移，并在群集增长或缩小时进行其他调整。oprerator 还将监视 api 服务请求的所需状态更改并应用更改。&lt;/p>
&lt;p>Rook oprerator 还创建了 Rook agent。这些 agent 是在每个 Kubernetes 节点上部署的 pod。每个 agent 都配置一个 Flexvolume 插件，该插件与 Kubernetes 的 volume controller 集成在一起。处理节点上所需的所有存储操作，例如附加网络存储设备，安装卷和格式化文件系统。&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/kll50k/1616117730704-e5377336-af63-4167-a704-e1cd1eeaa124.jpeg" alt="">&lt;/p>
&lt;p>该 rook 容器包括所有必需的 Ceph 守护进程和工具来管理和存储所有数据 - 数据路径没有变化。 rook 并没有试图与 Ceph 保持完全的忠诚度。 许多 Ceph 概念（如 placement groups 和 crush maps）都是隐藏的，因此您无需担心它们。 相反，Rook 为管理员创建了一个简化的用户体验，包括物理资源，池，卷，文件系统和 buckets。 同时，可以在需要时使用 Ceph 工具应用高级配置。&lt;/p>
&lt;p>Rook 在 golang 中实现。Ceph 在 C ++中实现，其中数据路径被高度优化。我们相信这种组合可以提供两全其美的效果。&lt;/p></description></item><item><title>Docs: Rook</title><link>https://desistdaydream.github.io/docs/10.%E4%BA%91%E5%8E%9F%E7%94%9F/2.3.Kubernetes-%E5%AE%B9%E5%99%A8%E7%BC%96%E6%8E%92%E7%B3%BB%E7%BB%9F/9.Kubernetes-%E5%AD%98%E5%82%A8/CSI/Rook/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/10.%E4%BA%91%E5%8E%9F%E7%94%9F/2.3.Kubernetes-%E5%AE%B9%E5%99%A8%E7%BC%96%E6%8E%92%E7%B3%BB%E7%BB%9F/9.Kubernetes-%E5%AD%98%E5%82%A8/CSI/Rook/</guid><description/></item></channel></rss>