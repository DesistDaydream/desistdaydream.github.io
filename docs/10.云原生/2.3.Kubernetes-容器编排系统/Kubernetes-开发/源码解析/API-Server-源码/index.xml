<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>断念梦 – API Server 源码</title><link>https://desistdaydream.github.io/docs/10.%E4%BA%91%E5%8E%9F%E7%94%9F/2.3.Kubernetes-%E5%AE%B9%E5%99%A8%E7%BC%96%E6%8E%92%E7%B3%BB%E7%BB%9F/Kubernetes-%E5%BC%80%E5%8F%91/%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/API-Server-%E6%BA%90%E7%A0%81/</link><description>Recent content in API Server 源码 on 断念梦</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><atom:link href="https://desistdaydream.github.io/docs/10.%E4%BA%91%E5%8E%9F%E7%94%9F/2.3.Kubernetes-%E5%AE%B9%E5%99%A8%E7%BC%96%E6%8E%92%E7%B3%BB%E7%BB%9F/Kubernetes-%E5%BC%80%E5%8F%91/%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/API-Server-%E6%BA%90%E7%A0%81/index.xml" rel="self" type="application/rss+xml"/><item><title>Docs: kube-apiserver 的设计与实现 · 田飞雨</title><link>https://desistdaydream.github.io/docs/10.%E4%BA%91%E5%8E%9F%E7%94%9F/2.3.Kubernetes-%E5%AE%B9%E5%99%A8%E7%BC%96%E6%8E%92%E7%B3%BB%E7%BB%9F/Kubernetes-%E5%BC%80%E5%8F%91/%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/API-Server-%E6%BA%90%E7%A0%81/kube-apiserver-%E7%9A%84%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0-%E7%94%B0%E9%A3%9E%E9%9B%A8/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/10.%E4%BA%91%E5%8E%9F%E7%94%9F/2.3.Kubernetes-%E5%AE%B9%E5%99%A8%E7%BC%96%E6%8E%92%E7%B3%BB%E7%BB%9F/Kubernetes-%E5%BC%80%E5%8F%91/%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/API-Server-%E6%BA%90%E7%A0%81/kube-apiserver-%E7%9A%84%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0-%E7%94%B0%E9%A3%9E%E9%9B%A8/</guid><description>
&lt;p>&lt;a href="https://blog.tianfeiyu.com/source-code-reading-notes/kubernetes/kube_apiserver.html">kube-apiserver 的设计与实现 · 田飞雨&lt;/a>&lt;/p>
&lt;ul>
&lt;li>
&lt;p>&lt;a href="#kube-apiserver-%E5%A4%84%E7%90%86%E6%B5%81%E7%A8%8B">kube-apiserver 处理流程&lt;/a>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="#kube-apiserver--%E4%B8%AD%E7%9A%84%E7%BB%84%E4%BB%B6">kube-apiserver 中的组件&lt;/a>&lt;/p>
&lt;ul>
&lt;li>
&lt;p>&lt;a href="#aggregator">Aggregator&lt;/a>&lt;/p>
&lt;ul>
&lt;li>&lt;a href="#%E5%90%AF%E7%94%A8-api-aggregation">启用 API Aggregation&lt;/a>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="#kubeapiserver">KubeAPIServer&lt;/a>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="#apiextensionserver">APIExtensionServer&lt;/a>&lt;/p>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="#kube-apiserver-%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90">kube-apiserver 启动流程分析&lt;/a>&lt;/p>
&lt;ul>
&lt;li>
&lt;p>&lt;a href="#run">Run&lt;/a>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="#createserverchain">CreateServerChain&lt;/a>&lt;/p>
&lt;ul>
&lt;li>&lt;a href="#createkubeapiserverconfig">CreateKubeAPIServerConfig&lt;/a>&lt;/li>
&lt;li>&lt;a href="#buildgenericconfig">buildGenericConfig&lt;/a>&lt;/li>
&lt;li>&lt;a href="#createapiextensionsserver">createAPIExtensionsServer&lt;/a>&lt;/li>
&lt;li>&lt;a href="#createkubeapiserver">CreateKubeAPIServer&lt;/a>&lt;/li>
&lt;li>&lt;a href="#kubeapiserverconfigcompletenew">kubeAPIServerConfig.Complete().New&lt;/a>&lt;/li>
&lt;li>&lt;a href="#minstalllegacyapi">m.InstallLegacyAPI&lt;/a>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="#createaggregatorserver">createAggregatorServer&lt;/a>&lt;/p>
&lt;ul>
&lt;li>&lt;a href="#aggregatorconfigcompletenewwithdelegate">aggregatorConfig.Complete().NewWithDelegate&lt;/a>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="#preparedrun">prepared.Run&lt;/a>&lt;/p>
&lt;ul>
&lt;li>&lt;a href="#snonblockingrun">s.NonBlockingRun&lt;/a>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="#storagefactory-%E7%9A%84%E6%9E%84%E5%BB%BA">storageFactory 的构建&lt;/a>&lt;/p>
&lt;ul>
&lt;li>
&lt;p>&lt;a href="#newlegacyreststorage">NewLegacyRESTStorage&lt;/a>&lt;/p>
&lt;ul>
&lt;li>
&lt;p>&lt;a href="#podstorenewstorage">podstore.NewStorage&lt;/a>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="#storecompletewithoptions">store.CompleteWithOptions&lt;/a>&lt;/p>
&lt;ul>
&lt;li>&lt;a href="#newetcd3storage">newETCD3Storage&lt;/a>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="#%E8%B7%AF%E7%94%B1%E6%B3%A8%E5%86%8C">路由注册&lt;/a>&lt;/p>
&lt;ul>
&lt;li>&lt;a href="#aregisterresourcehandlers">a.registerResourceHandlers&lt;/a>&lt;/li>
&lt;li>&lt;a href="#restfulcreatenamedresource">restfulCreateNamedResource&lt;/a>&lt;/li>
&lt;li>&lt;a href="#createhandler">createHandler&lt;/a>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="#%E6%80%BB%E7%BB%93">总结&lt;/a>&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>kube-apiserver 是 kubernetes 中与 etcd 直接交互的一个组件，其控制着 kubernetes 中核心资源的变化。它主要提供了以下几个功能：&lt;/p>
&lt;ul>
&lt;li>提供 &lt;a href="https://kubernetes.io/docs/concepts/overview/kubernetes-api/">Kubernetes API&lt;/a>，包括认证授权、数据校验以及集群状态变更等，供客户端及其他组件调用；&lt;/li>
&lt;li>代理集群中的一些附加组件组件，如 Kubernetes UI、metrics-server、npd 等；&lt;/li>
&lt;li>创建 kubernetes 服务，即提供 apiserver 的 Service，kubernetes Service；&lt;/li>
&lt;li>资源在不同版本之间的转换；&lt;/li>
&lt;/ul>
&lt;h3 id="kube-apiserver-处理流程">kube-apiserver 处理流程&lt;/h3>
&lt;p>kube-apiserver 主要通过对外提供 API 的方式与其他组件进行交互，可以调用 kube-apiserver 的接口 &lt;code>$ curl -k https://&amp;lt;masterIP&amp;gt;:6443&lt;/code>或者通过其提供的 &lt;strong>swagger-ui&lt;/strong> 获取到，其主要有以下三种 API：&lt;/p>
&lt;ul>
&lt;li>core group：主要在 &lt;code>/api/v1&lt;/code> 下；&lt;/li>
&lt;li>named groups：其 path 为 &lt;code>/apis/$NAME/$VERSION&lt;/code>；&lt;/li>
&lt;li>暴露系统状态的一些 API：如&lt;code>/metrics&lt;/code> 、&lt;code>/healthz&lt;/code> 等；&lt;/li>
&lt;/ul>
&lt;p>API 的 URL 大致以 &lt;code>/apis/group/version/namespaces/my-ns/myresource&lt;/code> 组成，其中 API 的结构大致如下图所示：&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/21d11c56-5813-47dd-b77c-03faddb69a0d/API-server-space-1.png" alt="">&lt;/p>
&lt;p>了解了 kube-apiserver 的 API 后，下面会介绍 kube-apiserver 如何处理一个 API 请求，一个请求完整的流程如下图所示：&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/21d11c56-5813-47dd-b77c-03faddb69a0d/API-server-flow-2.png" alt="">&lt;/p>
&lt;p>此处以一次 POST 请求示例说明，当请求到达 kube-apiserver 时，kube-apiserver 首先会执行在 http filter chain 中注册的过滤器链，该过滤器对其执行一系列过滤操作，主要有认证、鉴权等检查操作。当 filter chain 处理完成后，请求会通过 route 进入到对应的 handler 中，handler 中的操作主要是与 etcd 的交互，在 handler 中的主要的操作如下所示：&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/21d11c56-5813-47dd-b77c-03faddb69a0d/API-server-storage-flow-2.png" alt="">&lt;/p>
&lt;p>&lt;strong>Decoder&lt;/strong>&lt;/p>
&lt;p>kubernetes 中的多数 resource 都会有一个 &lt;code>internal version&lt;/code>，因为在整个开发过程中一个 resource 可能会对应多个 version，比如 deployment 会有 &lt;code>extensions/v1beta1&lt;/code>，&lt;code>apps/v1&lt;/code>。 为了避免出现问题，kube-apiserver 必须要知道如何在每一对版本之间进行转换（例如，v1⇔v1alpha1，v1⇔v1beta1，v1beta1⇔v1alpha1），因此其使用了一个特殊的&lt;code>internal version&lt;/code>，&lt;code>internal version&lt;/code> 作为一个通用的 version 会包含所有 version 的字段，它具有所有 version 的功能。 Decoder 会首先把 creater object 转换到 &lt;code>internal version&lt;/code>，然后将其转换为 &lt;code>storage version&lt;/code>，&lt;code>storage version&lt;/code> 是在 etcd 中存储时的另一个 version。&lt;/p>
&lt;p>在解码时，首先从 HTTP path 中获取期待的 version，然后使用 scheme 以正确的 version 创建一个与之匹配的空对象，并使用 JSON 或 protobuf 解码器进行转换，在转换的第一步中，如果用户省略了某些字段，Decoder 会把其设置为默认值。&lt;/p>
&lt;p>&lt;strong>Admission&lt;/strong>&lt;/p>
&lt;p>在解码完成后，需要通过验证集群的全局约束来检查是否可以创建或更新对象，并根据集群配置设置默认值。在 &lt;code>k8s.io/kubernetes/plugin/pkg/admission&lt;/code> 目录下可以看到 kube-apiserver 可以使用的所有全局约束插件，kube-apiserver 在启动时通过设置 &lt;code>--enable-admission-plugins&lt;/code> 参数来开启需要使用的插件，通过 &lt;code>ValidatingAdmissionWebhook&lt;/code> 或 &lt;code>MutatingAdmissionWebhook&lt;/code> 添加的插件也都会在此处进行工作。&lt;/p>
&lt;p>&lt;strong>Validation&lt;/strong>&lt;/p>
&lt;p>主要检查 object 中字段的合法性。&lt;/p>
&lt;p>在 handler 中执行完以上操作后最后会执行与 etcd 相关的操作，POST 操作会将数据写入到 etcd 中，以上在 handler 中的主要处理流程如下所示：&lt;/p>
&lt;pre>&lt;code>v1beta1 ⇒ internal ⇒ | ⇒ | ⇒ v1 ⇒ json/yaml ⇒ etcd
admission validation
&lt;/code>&lt;/pre>
&lt;h3 id="kube-apiserver-中的组件">kube-apiserver 中的组件&lt;/h3>
&lt;p>kube-apiserver 共由 3 个组件构成（Aggregator、KubeAPIServer、APIExtensionServer），这些组件依次通过 Delegation 处理请求：&lt;/p>
&lt;ul>
&lt;li>&lt;strong>Aggregator&lt;/strong>：暴露的功能类似于一个七层负载均衡，将来自用户的请求拦截转发给其他服务器，并且负责整个 APIServer 的 Discovery 功能；&lt;/li>
&lt;li>&lt;strong>KubeAPIServer&lt;/strong> ：负责对请求的一些通用处理，认证、鉴权等，以及处理各个内建资源的 REST 服务；&lt;/li>
&lt;li>&lt;strong>APIExtensionServer&lt;/strong>：主要处理 CustomResourceDefinition（CRD）和 CustomResource（CR）的 REST 请求，也是 Delegation 的最后一环，如果对应 CR 不能被处理的话则会返回 404。&lt;/li>
&lt;/ul>
&lt;p>Aggregator 和 APIExtensionsServer 对应两种主要扩展 APIServer 资源的方式，即分别是 AA 和 CRD。&lt;/p>
&lt;h4 id="aggregator">Aggregator&lt;/h4>
&lt;p>Aggregator 通过 APIServices 对象关联到某个 Service 来进行请求的转发，其关联的 Service 类型进一步决定了请求转发形式。Aggregator 包括一个 &lt;code>GenericAPIServer&lt;/code> 和维护自身状态的 Controller。其中 &lt;code>GenericAPIServer&lt;/code> 主要处理 &lt;code>apiregistration.k8s.io&lt;/code> 组下的 APIService 资源请求。&lt;/p>
&lt;p>&lt;strong>Aggregator 除了处理资源请求外还包含几个 controller：&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>1、&lt;code>apiserviceRegistrationController&lt;/code>：负责 APIServices 中资源的注册与删除；&lt;/li>
&lt;li>2、&lt;code>availableConditionController&lt;/code>：维护 APIServices 的可用状态，包括其引用 Service 是否可用等；&lt;/li>
&lt;li>3、&lt;code>autoRegistrationController&lt;/code>：用于保持 API 中存在的一组特定的 APIServices；&lt;/li>
&lt;li>4、&lt;code>crdRegistrationController&lt;/code>：负责将 CRD GroupVersions 自动注册到 APIServices 中；&lt;/li>
&lt;li>5、&lt;code>openAPIAggregationController&lt;/code>：将 APIServices 资源的变化同步至提供的 OpenAPI 文档；&lt;/li>
&lt;/ul>
&lt;p>kubernetes 中的一些附加组件，比如 metrics-server 就是通过 Aggregator 的方式进行扩展的，实际环境中可以通过使用 &lt;a href="https://github.com/kubernetes-sigs/apiserver-builder-alpha">apiserver-builder&lt;/a> 工具轻松以 Aggregator 的扩展方式创建自定义资源。&lt;/p>
&lt;h5 id="启用-api-aggregation">启用 API Aggregation&lt;/h5>
&lt;p>在 kube-apiserver 中需要增加以下配置来开启 API Aggregation：&lt;/p>
&lt;pre>&lt;code>--proxy-client-cert-file=/etc/kubernetes/certs/proxy.crt
--proxy-client-key-file=/etc/kubernetes/certs/proxy.key
--requestheader-client-ca-file=/etc/kubernetes/certs/proxy-ca.crt
--requestheader-allowed-names=aggregator
--requestheader-extra-headers-prefix=X-Remote-Extra-
--requestheader-group-headers=X-Remote-Group
--requestheader-username-headers=X-Remote-User
&lt;/code>&lt;/pre>
&lt;h4 id="kubeapiserver">KubeAPIServer&lt;/h4>
&lt;p>KubeAPIServer 主要是提供对 API Resource 的操作请求，为 kubernetes 中众多 API 注册路由信息，暴露 RESTful API 并且对外提供 kubernetes service，使集群中以及集群外的服务都可以通过 RESTful API 操作 kubernetes 中的资源。&lt;/p>
&lt;h4 id="apiextensionserver">APIExtensionServer&lt;/h4>
&lt;p>APIExtensionServer 作为 Delegation 链的最后一层，是处理所有用户通过 Custom Resource Definition 定义的资源服务器。&lt;/p>
&lt;p>其中包含的 controller 以及功能如下所示：&lt;/p>
&lt;ul>
&lt;li>1、&lt;code>openapiController&lt;/code>：将 crd 资源的变化同步至提供的 OpenAPI 文档，可通过访问 &lt;code>/openapi/v2&lt;/code> 进行查看；&lt;/li>
&lt;li>2、&lt;code>crdController&lt;/code>：负责将 crd 信息注册到 apiVersions 和 apiResources 中，两者的信息可通过 &lt;code>$ kubectl api-versions&lt;/code> 和 &lt;code>$ kubectl api-resources&lt;/code> 查看；&lt;/li>
&lt;li>3、&lt;code>namingController&lt;/code>：检查 crd obj 中是否有命名冲突，可在 crd &lt;code>.status.conditions&lt;/code> 中查看；&lt;/li>
&lt;li>4、&lt;code>establishingController&lt;/code>：检查 crd 是否处于正常状态，可在 crd &lt;code>.status.conditions&lt;/code> 中查看；&lt;/li>
&lt;li>5、&lt;code>nonStructuralSchemaController&lt;/code>：检查 crd obj 结构是否正常，可在 crd &lt;code>.status.conditions&lt;/code> 中查看；&lt;/li>
&lt;li>6、&lt;code>apiApprovalController&lt;/code>：检查 crd 是否遵循 kubernetes API 声明策略，可在 crd &lt;code>.status.conditions&lt;/code> 中查看；&lt;/li>
&lt;li>7、&lt;code>finalizingController&lt;/code>：类似于 finalizes 的功能，与 CRs 的删除有关；&lt;/li>
&lt;/ul>
&lt;h3 id="kube-apiserver-启动流程分析">kube-apiserver 启动流程分析&lt;/h3>
&lt;blockquote>
&lt;p>kubernetes 版本：v1.16&lt;/p>
&lt;/blockquote>
&lt;p>首先分析 kube-apiserver 的启动方式，kube-apiserver 也是通过其 &lt;code>Run&lt;/code> 方法启动主逻辑的，在&lt;code>Run&lt;/code> 方法调用之前会进行解析命令行参数、设置默认值等。&lt;/p>
&lt;h4 id="run">Run&lt;/h4>
&lt;p>&lt;code>Run&lt;/code> 方法的主要逻辑为：&lt;/p>
&lt;ul>
&lt;li>1、调用 &lt;code>CreateServerChain&lt;/code> 构建服务调用链并判断是否启动非安全的 http server，http server 链中包含 apiserver 要启动的三个 server，以及为每个 server 注册对应资源的路由；&lt;/li>
&lt;li>2、调用 &lt;code>server.PrepareRun&lt;/code> 进行服务运行前的准备，该方法主要完成了健康检查、存活检查和&lt;code>OpenAPI&lt;/code>路由的注册工作；&lt;/li>
&lt;li>3、调用 &lt;code>prepared.Run&lt;/code> 启动 https server；&lt;/li>
&lt;/ul>
&lt;p>server 的初始化使用委托模式，通过 DelegationTarget 接口，把基本的 API Server、CustomResource、Aggregator 这三种服务采用链式结构串联起来，对外提供服务。&lt;/p>
&lt;p>&lt;code>k8s.io/kubernetes/cmd/kube-apiserver/app/server.go:147&lt;/code>&lt;/p>
&lt;pre>&lt;code>func Run(completeOptions completedServerRunOptions, stopCh &amp;lt;-chan struct{}) error {
server, err := CreateServerChain(completeOptions, stopCh)
if err != nil {
return err
}
prepared, err := server.PrepareRun()
if err != nil {
return err
}
return prepared.Run(stopCh)
}
&lt;/code>&lt;/pre>
&lt;h4 id="createserverchain">CreateServerChain&lt;/h4>
&lt;p>&lt;code>CreateServerChain&lt;/code> 是完成 server 初始化的方法，里面包含 &lt;code>APIExtensionsServer&lt;/code>、&lt;code>KubeAPIServer&lt;/code>、&lt;code>AggregatorServer&lt;/code> 初始化的所有流程，最终返回 &lt;code>aggregatorapiserver.APIAggregator&lt;/code> 实例，初始化流程主要有：http filter chain 的配置、API Group 的注册、http path 与 handler 的关联以及 handler 后端存储 etcd 的配置。其主要逻辑为：&lt;/p>
&lt;ul>
&lt;li>1、调用 &lt;code>CreateKubeAPIServerConfig&lt;/code> 创建 KubeAPIServer 所需要的配置，主要是创建 &lt;code>master.Config&lt;/code>，其中会调用 &lt;code>buildGenericConfig&lt;/code> 生成 genericConfig，genericConfig 中包含 apiserver 的核心配置；&lt;/li>
&lt;li>2、判断是否启用了扩展的 API server 并调用 &lt;code>createAPIExtensionsConfig&lt;/code> 为其创建配置，apiExtensions server 是一个代理服务，用于代理 kubeapiserver 中的其他 server，比如 metric-server；&lt;/li>
&lt;li>3、调用 &lt;code>createAPIExtensionsServer&lt;/code> 创建 apiExtensionsServer 实例；&lt;/li>
&lt;li>4、调用 &lt;code>CreateKubeAPIServer&lt;/code>初始化 kubeAPIServer；&lt;/li>
&lt;li>5、调用 &lt;code>createAggregatorConfig&lt;/code> 为 aggregatorServer 创建配置并调用 &lt;code>createAggregatorServer&lt;/code> 初始化 aggregatorServer；&lt;/li>
&lt;li>6、配置并判断是否启动非安全的 http server；&lt;/li>
&lt;/ul>
&lt;p>&lt;code>k8s.io/kubernetes/cmd/kube-apiserver/app/server.go:165&lt;/code>&lt;/p>
&lt;pre>&lt;code>func CreateServerChain(completedOptions completedServerRunOptions, stopCh &amp;lt;-chan struct{}) (*aggregatorapiserver.APIAggregator, error) {
nodeTunneler, proxyTransport, err := CreateNodeDialer(completedOptions)
if err != nil {
return nil, err
}
// 1、为 kubeAPIServer 创建配置
kubeAPIServerConfig, insecureServingInfo, serviceResolver, pluginInitializer, admissionPostStartHook, err := CreateKubeAPIServerConfig(completedOptions, nodeTunneler, proxyTransport)
if err != nil {
return nil, err
}
// 2、判断是否配置了 APIExtensionsServer，创建 apiExtensionsConfig
apiExtensionsConfig, err := createAPIExtensionsConfig(*kubeAPIServerConfig.GenericConfig, kubeAPIServerConfig.ExtraConfig.VersionedInformers, pluginInitializer, completedOptions.ServerRunOptions, completedOptions.MasterCount,
serviceResolver, webhook.NewDefaultAuthenticationInfoResolverWrapper(proxyTransport, kubeAPIServerConfig.GenericConfig.LoopbackClientConfig))
if err != nil {
return nil, err
}
// 3、初始化 APIExtensionsServer
apiExtensionsServer, err := createAPIExtensionsServer(apiExtensionsConfig, genericapiserver.NewEmptyDelegate())
if err != nil {
return nil, err
}
// 4、初始化 KubeAPIServer
kubeAPIServer, err := CreateKubeAPIServer(kubeAPIServerConfig, apiExtensionsServer.GenericAPIServer, admissionPostStartHook)
if err != nil {
return nil, err
}
// 5、创建 AggregatorConfig
aggregatorConfig, err := createAggregatorConfig(*kubeAPIServerConfig.GenericConfig, completedOptions.ServerRunOptions, kubeAPIServerConfig. ExtraConfig.VersionedInformers, serviceResolver, proxyTransport, pluginInitializer)
if err != nil {
return nil, err
}
// 6、初始化 AggregatorServer
aggregatorServer, err := createAggregatorServer(aggregatorConfig, kubeAPIServer.GenericAPIServer, apiExtensionsServer.Informers)
if err != nil {
return nil, err
}
// 7、判断是否启动非安全端口的 http server
if insecureServingInfo != nil {
insecureHandlerChain := kubeserver.BuildInsecureHandlerChain(aggregatorServer.GenericAPIServer.UnprotectedHandler(), kubeAPIServerConfig.GenericConfig)
if err := insecureServingInfo.Serve(insecureHandlerChain, kubeAPIServerConfig.GenericConfig.RequestTimeout, stopCh); err != nil {
return nil, err
}
}
return aggregatorServer, nil
}
&lt;/code>&lt;/pre>
&lt;h5 id="createkubeapiserverconfig">CreateKubeAPIServerConfig&lt;/h5>
&lt;p>在 &lt;code>CreateKubeAPIServerConfig&lt;/code> 中主要是调用 &lt;code>buildGenericConfig&lt;/code> 创建 genericConfig 以及构建 master.Config 对象。&lt;/p>
&lt;p>&lt;code>k8s.io/kubernetes/cmd/kube-apiserver/app/server.go:271&lt;/code>&lt;/p>
&lt;pre>&lt;code>func CreateKubeAPIServerConfig(
s completedServerRunOptions,
nodeTunneler tunneler.Tunneler,
proxyTransport *http.Transport,
) (......) {
// 1、构建 genericConfig
genericConfig, versionedInformers, insecureServingInfo, serviceResolver, pluginInitializers, admissionPostStartHook, storageFactory, lastErr = buildGenericConfig(s.ServerRunOptions, proxyTransport)
if lastErr != nil {
return
}
......
// 2、初始化所支持的 capabilities
capabilities.Initialize(capabilities.Capabilities{
AllowPrivileged: s.AllowPrivileged,
PrivilegedSources: capabilities.PrivilegedSources{
HostNetworkSources: []string{},
HostPIDSources: []string{},
HostIPCSources: []string{},
},
PerConnectionBandwidthLimitBytesPerSec: s.MaxConnectionBytesPerSec,
})
// 3、获取 service ip range 以及 api server service IP
serviceIPRange, apiServerServiceIP, lastErr := master.DefaultServiceIPRange(s.PrimaryServiceClusterIPRange)
if lastErr != nil {
return
}
......
// 4、构建 master.Config 对象
config = &amp;amp;master.Config{......}
if nodeTunneler != nil {
config.ExtraConfig.KubeletClientConfig.Dial = nodeTunneler.Dial
}
if config.GenericConfig.EgressSelector != nil {
config.ExtraConfig.KubeletClientConfig.Lookup = config.GenericConfig.EgressSelector.Lookup
}
return
}
&lt;/code>&lt;/pre>
&lt;h5 id="buildgenericconfig">buildGenericConfig&lt;/h5>
&lt;p>主要逻辑为：&lt;/p>
&lt;ul>
&lt;li>1、调用 &lt;code>genericapiserver.NewConfig&lt;/code> 生成默认的 genericConfig，genericConfig 中主要配置了 &lt;code>DefaultBuildHandlerChain&lt;/code>，&lt;code>DefaultBuildHandlerChain&lt;/code> 中包含了认证、鉴权等一系列 http filter chain；&lt;/li>
&lt;li>2、调用 &lt;code>master.DefaultAPIResourceConfigSource&lt;/code> 加载需要启用的 API Resource，集群中所有的 API Resource 可以在代码的 &lt;code>k8s.io/api&lt;/code> 目录中看到，随着版本的迭代也会不断变化；&lt;/li>
&lt;li>3、为 genericConfig 中的部分字段设置默认值；&lt;/li>
&lt;li>4、调用 &lt;code>completedStorageFactoryConfig.New&lt;/code> 创建 storageFactory，后面会使用 storageFactory 为每种 API Resource 创建对应的 RESTStorage；&lt;/li>
&lt;/ul>
&lt;p>&lt;code>k8s.io/kubernetes/cmd/kube-apiserver/app/server.go:386&lt;/code>&lt;/p>
&lt;pre>&lt;code>func buildGenericConfig(
s *options.ServerRunOptions,
proxyTransport *http.Transport,
) (......) {
// 1、为 genericConfig 设置默认值
genericConfig = genericapiserver.NewConfig(legacyscheme.Codecs)
genericConfig.MergedResourceConfig = master.DefaultAPIResourceConfigSource()
if lastErr = s.GenericServerRunOptions.ApplyTo(genericConfig); lastErr != nil {
return
}
......
genericConfig.OpenAPIConfig = genericapiserver.DefaultOpenAPIConfig(......)
genericConfig.OpenAPIConfig.Info.Title = &amp;quot;Kubernetes&amp;quot;
genericConfig.LongRunningFunc = filters.BasicLongRunningRequestCheck(
sets.NewString(&amp;quot;watch&amp;quot;, &amp;quot;proxy&amp;quot;),
sets.NewString(&amp;quot;attach&amp;quot;, &amp;quot;exec&amp;quot;, &amp;quot;proxy&amp;quot;, &amp;quot;log&amp;quot;, &amp;quot;portforward&amp;quot;),
)
kubeVersion := version.Get()
genericConfig.Version = &amp;amp;kubeVersion
storageFactoryConfig := kubeapiserver.NewStorageFactoryConfig()
storageFactoryConfig.ApiResourceConfig = genericConfig.MergedResourceConfig
completedStorageFactoryConfig, err := storageFactoryConfig.Complete(s.Etcd)
if err != nil {
lastErr = err
return
}
// 初始化 storageFactory
storageFactory, lastErr = completedStorageFactoryConfig.New()
if lastErr != nil {
return
}
if genericConfig.EgressSelector != nil {
storageFactory.StorageConfig.Transport.EgressLookup = genericConfig.EgressSelector.Lookup
}
// 2、初始化 RESTOptionsGetter，后期根据其获取操作 Etcd 的句柄，同时添加 etcd 的健康检查方法
if lastErr = s.Etcd.ApplyWithStorageFactoryTo(storageFactory, genericConfig); lastErr != nil {
return
}
// 3、设置使用 protobufs 用来内部交互，并且禁用压缩功能
genericConfig.LoopbackClientConfig.ContentConfig.ContentType = &amp;quot;application/vnd.kubernetes.protobuf&amp;quot;
genericConfig.LoopbackClientConfig.DisableCompression = true
// 4、创建 clientset
kubeClientConfig := genericConfig.LoopbackClientConfig
clientgoExternalClient, err := clientgoclientset.NewForConfig(kubeClientConfig)
if err != nil {
lastErr = fmt.Errorf(&amp;quot;failed to create real external clientset: %v&amp;quot;, err)
return
}
versionedInformers = clientgoinformers.NewSharedInformerFactory(clientgoExternalClient, 10*time.Minute)
// 5、创建认证实例，支持多种认证方式：请求 Header 认证、Auth 文件认证、CA 证书认证、Bearer token 认证、
// ServiceAccount 认证、BootstrapToken 认证、WebhookToken 认证等
genericConfig.Authentication.Authenticator, genericConfig.OpenAPIConfig.SecurityDefinitions, err = BuildAuthenticator(s, clientgoExternalClient, versionedInformers)
if err != nil {
lastErr = fmt.Errorf(&amp;quot;invalid authentication config: %v&amp;quot;, err)
return
}
// 6、创建鉴权实例，包含：Node、RBAC、Webhook、ABAC、AlwaysAllow、AlwaysDeny
genericConfig.Authorization.Authorizer, genericConfig.RuleResolver, err = BuildAuthorizer(s, versionedInformers)
......
serviceResolver = buildServiceResolver(s.EnableAggregatorRouting, genericConfig.LoopbackClientConfig.Host, versionedInformers)
authInfoResolverWrapper := webhook.NewDefaultAuthenticationInfoResolverWrapper(proxyTransport, genericConfig.LoopbackClientConfig)
// 7、审计插件的初始化
lastErr = s.Audit.ApplyTo(......)
if lastErr != nil {
return
}
// 8、准入插件的初始化
pluginInitializers, admissionPostStartHook, err = admissionConfig.New(proxyTransport, serviceResolver)
if err != nil {
lastErr = fmt.Errorf(&amp;quot;failed to create admission plugin initializer: %v&amp;quot;, err)
return
}
err = s.Admission.ApplyTo(......)
if err != nil {
lastErr = fmt.Errorf(&amp;quot;failed to initialize admission: %v&amp;quot;, err)
}
return
}
&lt;/code>&lt;/pre>
&lt;p>以上主要分析 KubeAPIServerConfig 的初始化，其他两个 server config 的初始化暂且不详细分析，下面接着继续分析 server 的初始化。&lt;/p>
&lt;h5 id="createapiextensionsserver">createAPIExtensionsServer&lt;/h5>
&lt;p>APIExtensionsServer 是最先被初始化的，在 &lt;code>createAPIExtensionsServer&lt;/code> 中调用 &lt;code>apiextensionsConfig.Complete().New&lt;/code> 来完成 server 的初始化，其主要逻辑为：&lt;/p>
&lt;ul>
&lt;li>1、首先调用 &lt;code>c.GenericConfig.New&lt;/code> 按照&lt;code>go-restful&lt;/code>的模式初始化 Container，在 &lt;code>c.GenericConfig.New&lt;/code> 中会调用 &lt;code>NewAPIServerHandler&lt;/code> 初始化 handler，APIServerHandler 包含了 API Server 使用的多种 http.Handler 类型，包括 &lt;code>go-restful&lt;/code> 以及 &lt;code>non-go-restful&lt;/code>，以及在以上两者之间选择的 Director 对象，&lt;code>go-restful&lt;/code> 用于处理已经注册的 handler，&lt;code>non-go-restful&lt;/code> 用来处理不存在的 handler，API URI 处理的选择过程为：&lt;code>FullHandlerChain-&amp;gt; Director -&amp;gt;{GoRestfulContainer， NonGoRestfulMux}&lt;/code>。在 &lt;code>c.GenericConfig.New&lt;/code> 中还会调用 &lt;code>installAPI&lt;/code>来添加包括 &lt;code>/&lt;/code>、&lt;code>/debug/*&lt;/code>、&lt;code>/metrics&lt;/code>、&lt;code>/version&lt;/code> 等路由信息。三种 server 在初始化时首先都会调用 &lt;code>c.GenericConfig.New&lt;/code> 来初始化一个 genericServer，然后进行 API 的注册；&lt;/li>
&lt;li>2、调用 &lt;code>s.GenericAPIServer.InstallAPIGroup&lt;/code> 在路由中注册 API Resources，此方法的调用链非常深，主要是为了将需要暴露的 API Resource 注册到 server 中，以便能通过 http 接口进行 resource 的 REST 操作，其他几种 server 在初始化时也都会执行对应的 &lt;code>InstallAPI&lt;/code>；&lt;/li>
&lt;li>3、初始化 server 中需要使用的 controller，主要有 &lt;code>openapiController&lt;/code>、&lt;code>crdController&lt;/code>、&lt;code>namingController&lt;/code>、&lt;code>establishingController&lt;/code>、&lt;code>nonStructuralSchemaController&lt;/code>、&lt;code>apiApprovalController&lt;/code>、&lt;code>finalizingControlle&lt;/code>r；&lt;/li>
&lt;li>4、将需要启动的 controller 以及 informer 添加到 PostStartHook 中；&lt;/li>
&lt;/ul>
&lt;p>&lt;code>k8s.io/kubernetes/cmd/kube-apiserver/app/apiextensions.go:94&lt;/code>&lt;/p>
&lt;pre>&lt;code>func createAPIExtensionsServer(apiextensionsConfig *apiextensionsapiserver.Config, delegateAPIServer genericapiserver.DelegationTarget) (* apiextensionsapiserver.CustomResourceDefinitions, error) {
return apiextensionsConfig.Complete().New(delegateAPIServer)
}
&lt;/code>&lt;/pre>
&lt;p>&lt;code>k8s.io/kubernetes/staging/src/k8s.io/apiextensions-apiserver/pkg/apiserver/apiserver.go:132&lt;/code>&lt;/p>
&lt;pre>&lt;code>func (c completedConfig) New(delegationTarget genericapiserver.DelegationTarget) (*CustomResourceDefinitions, error) {
// 1、初始化 genericServer
genericServer, err := c.GenericConfig.New(&amp;quot;apiextensions-apiserver&amp;quot;, delegationTarget)
if err != nil {
return nil, err
}
s := &amp;amp;CustomResourceDefinitions{
GenericAPIServer: genericServer,
}
// 2、初始化 APIGroup Info，APIGroup 指该 server 需要暴露的 API
apiResourceConfig := c.GenericConfig.MergedResourceConfig
apiGroupInfo := genericapiserver.NewDefaultAPIGroupInfo(apiextensions.GroupName, Scheme, metav1.ParameterCodec, Codecs)
if apiResourceConfig.VersionEnabled(v1beta1.SchemeGroupVersion) {
storage := map[string]rest.Storage{}
customResourceDefintionStorage := customresourcedefinition.NewREST(Scheme, c.GenericConfig.RESTOptionsGetter)
storage[&amp;quot;customresourcedefinitions&amp;quot;] = customResourceDefintionStorage
storage[&amp;quot;customresourcedefinitions/status&amp;quot;] = customresourcedefinition.NewStatusREST(Scheme, customResourceDefintionStorage)
apiGroupInfo.VersionedResourcesStorageMap[v1beta1.SchemeGroupVersion.Version] = storage
}
if apiResourceConfig.VersionEnabled(v1.SchemeGroupVersion) {
......
}
// 3、注册 APIGroup
if err := s.GenericAPIServer.InstallAPIGroup(&amp;amp;apiGroupInfo); err != nil {
return nil, err
}
// 4、初始化需要使用的 controller
crdClient, err := internalclientset.NewForConfig(s.GenericAPIServer.LoopbackClientConfig)
if err != nil {
return nil, fmt.Errorf(&amp;quot;failed to create clientset: %v&amp;quot;, err)
}
s.Informers = internalinformers.NewSharedInformerFactory(crdClient, 5*time.Minute)
......
establishingController := establish.NewEstablishingController(s.Informers.Apiextensions().InternalVersion(). CustomResourceDefinitions(), crdClient.Apiextensions())
crdHandler, err := NewCustomResourceDefinitionHandler(......)
if err != nil {
return nil, err
}
s.GenericAPIServer.Handler.NonGoRestfulMux.Handle(&amp;quot;/apis&amp;quot;, crdHandler)
s.GenericAPIServer.Handler.NonGoRestfulMux.HandlePrefix(&amp;quot;/apis/&amp;quot;, crdHandler)
crdController := NewDiscoveryController(s.Informers.Apiextensions().InternalVersion().CustomResourceDefinitions(), versionDiscoveryHandler, groupDiscoveryHandler)
namingController := status.NewNamingConditionController(s.Informers.Apiextensions().InternalVersion().CustomResourceDefinitions(), crdClient.Apiextensions())
nonStructuralSchemaController := nonstructuralschema.NewConditionController(s.Informers.Apiextensions().InternalVersion(). CustomResourceDefinitions(), crdClient.Apiextensions())
apiApprovalController := apiapproval.NewKubernetesAPIApprovalPolicyConformantConditionController(s.Informers.Apiextensions(). InternalVersion().CustomResourceDefinitions(), crdClient.Apiextensions())
finalizingController := finalizer.NewCRDFinalizer(
s.Informers.Apiextensions().InternalVersion().CustomResourceDefinitions(),
crdClient.Apiextensions(),
crdHandler,
)
var openapiController *openapicontroller.Controller
if utilfeature.DefaultFeatureGate.Enabled(apiextensionsfeatures.CustomResourcePublishOpenAPI) {
openapiController = openapicontroller.NewController(s.Informers.Apiextensions().InternalVersion().CustomResourceDefinitions())
}
// 5、将 informer 以及 controller 添加到 PostStartHook 中
s.GenericAPIServer.AddPostStartHookOrDie(&amp;quot;start-apiextensions-informers&amp;quot;, func(context genericapiserver.PostStartHookContext) error {
s.Informers.Start(context.StopCh)
return nil
})
s.GenericAPIServer.AddPostStartHookOrDie(&amp;quot;start-apiextensions-controllers&amp;quot;, func(context genericapiserver.PostStartHookContext) error {
......
go crdController.Run(context.StopCh)
go namingController.Run(context.StopCh)
go establishingController.Run(context.StopCh)
go nonStructuralSchemaController.Run(5, context.StopCh)
go apiApprovalController.Run(5, context.StopCh)
go finalizingController.Run(5, context.StopCh)
return nil
})
s.GenericAPIServer.AddPostStartHookOrDie(&amp;quot;crd-informer-synced&amp;quot;, func(context genericapiserver.PostStartHookContext) error {
return wait.PollImmediateUntil(100*time.Millisecond, func() (bool, error) {
return s.Informers.Apiextensions().InternalVersion().CustomResourceDefinitions().Informer().HasSynced(), nil
}, context.StopCh)
})
return s, nil
}
&lt;/code>&lt;/pre>
&lt;p>以上是 APIExtensionsServer 的初始化流程，其中最核心方法是 &lt;code>s.GenericAPIServer.InstallAPIGroup&lt;/code>，也就是 API 的注册过程，三种 server 中 API 的注册过程都是其核心。&lt;/p>
&lt;h5 id="createkubeapiserver">CreateKubeAPIServer&lt;/h5>
&lt;p>本节继续分析 KubeAPIServer 的初始化，在&lt;code>CreateKubeAPIServer&lt;/code> 中调用了 &lt;code>kubeAPIServerConfig.Complete().New&lt;/code> 来完成相关的初始化操作。&lt;/p>
&lt;h5 id="kubeapiserverconfigcompletenew">kubeAPIServerConfig.Complete().New&lt;/h5>
&lt;p>主要逻辑为：&lt;/p>
&lt;ul>
&lt;li>1、调用 &lt;code>c.GenericConfig.New&lt;/code> 初始化 GenericAPIServer，其主要实现在上文已经分析过；&lt;/li>
&lt;li>2、判断是否支持 logs 相关的路由，如果支持，则添加 &lt;code>/logs&lt;/code> 路由；&lt;/li>
&lt;li>3、调用 &lt;code>m.InstallLegacyAPI&lt;/code> 将核心 API Resource 添加到路由中，对应到 apiserver 就是以 &lt;code>/api&lt;/code> 开头的 resource；&lt;/li>
&lt;li>4、调用 &lt;code>m.InstallAPIs&lt;/code> 将扩展的 API Resource 添加到路由中，在 apiserver 中即是以 &lt;code>/apis&lt;/code> 开头的 resource；&lt;/li>
&lt;/ul>
&lt;p>&lt;code>k8s.io/kubernetes/cmd/kube-apiserver/app/server.go:214&lt;/code>&lt;/p>
&lt;pre>&lt;code>func CreateKubeAPIServer(......) (*master.Master, error) {
kubeAPIServer, err := kubeAPIServerConfig.Complete().New(delegateAPIServer)
if err != nil {
return nil, err
}
kubeAPIServer.GenericAPIServer.AddPostStartHookOrDie(&amp;quot;start-kube-apiserver-admission-initializer&amp;quot;, admissionPostStartHook)
return kubeAPIServer, nil
}
&lt;/code>&lt;/pre>
&lt;p>&lt;code>k8s.io/kubernetes/pkg/master/master.go:325&lt;/code>&lt;/p>
&lt;pre>&lt;code>func (c completedConfig) New(delegationTarget genericapiserver.DelegationTarget) (*Master, error) {
......
// 1、初始化 GenericAPIServer
s, err := c.GenericConfig.New(&amp;quot;kube-apiserver&amp;quot;, delegationTarget)
if err != nil {
return nil, err
}
// 2、注册 logs 相关的路由
if c.ExtraConfig.EnableLogsSupport {
routes.Logs{}.Install(s.Handler.GoRestfulContainer)
}
m := &amp;amp;Master{
GenericAPIServer: s,
}
// 3、安装 LegacyAPI
if c.ExtraConfig.APIResourceConfigSource.VersionEnabled(apiv1.SchemeGroupVersion) {
legacyRESTStorageProvider := corerest.LegacyRESTStorageProvider{
StorageFactory: c.ExtraConfig.StorageFactory,
ProxyTransport: c.ExtraConfig.ProxyTransport,
......
}
if err := m.InstallLegacyAPI(&amp;amp;c, c.GenericConfig.RESTOptionsGetter, legacyRESTStorageProvider); err != nil {
return nil, err
}
}
restStorageProviders := []RESTStorageProvider{
auditregistrationrest.RESTStorageProvider{},
authenticationrest.RESTStorageProvider{Authenticator: c.GenericConfig.Authentication.Authenticator, APIAudiences: c.GenericConfig. Authentication.APIAudiences},
......
}
// 4、安装 APIs
if err := m.InstallAPIs(c.ExtraConfig.APIResourceConfigSource, c.GenericConfig.RESTOptionsGetter, restStorageProviders...); err != nil {
return nil, err
}
if c.ExtraConfig.Tunneler != nil {
m.installTunneler(c.ExtraConfig.Tunneler, corev1client.NewForConfigOrDie(c.GenericConfig.LoopbackClientConfig).Nodes())
}
m.GenericAPIServer.AddPostStartHookOrDie(&amp;quot;ca-registration&amp;quot;, c.ExtraConfig.ClientCARegistrationHook.PostStartHook)
return m, nil
}
&lt;/code>&lt;/pre>
&lt;h5 id="minstalllegacyapi">m.InstallLegacyAPI&lt;/h5>
&lt;p>此方法的主要功能是将 core API 注册到路由中，是 apiserver 初始化流程中最核心的方法之一，不过其调用链非常深，下面会进行深入分析。将 API 注册到路由其最终的目的就是对外提供 RESTful API 来操作对应 resource，注册 API 主要分为两步，第一步是为 API 中的每个 resource 初始化 RESTStorage 以此操作后端存储中数据的变更，第二步是为每个 resource 根据其 verbs 构建对应的路由。&lt;code>m.InstallLegacyAPI&lt;/code> 的主要逻辑为：&lt;/p>
&lt;ul>
&lt;li>1、调用 &lt;code>legacyRESTStorageProvider.NewLegacyRESTStorage&lt;/code> 为 LegacyAPI 中各个资源创建 RESTStorage，RESTStorage 的目的是将每种资源的访问路径及其后端存储的操作对应起来；&lt;/li>
&lt;li>2、初始化 &lt;code>bootstrap-controller&lt;/code>，并将其加入到 PostStartHook 中，&lt;code>bootstrap-controller&lt;/code> 是 apiserver 中的一个 controller，主要功能是创建系统所需要的一些 namespace 以及创建 kubernetes service 并定期触发对应的 sync 操作，apiserver 在启动后会通过调用 PostStartHook 来启动 &lt;code>bootstrap-controller&lt;/code>；&lt;/li>
&lt;li>3、在为资源创建完 RESTStorage 后，调用 &lt;code>m.GenericAPIServer.InstallLegacyAPIGroup&lt;/code> 为 APIGroup 注册路由信息，&lt;code>InstallLegacyAPIGroup&lt;/code>方法的调用链非常深，主要为&lt;code>InstallLegacyAPIGroup--&amp;gt; installAPIResources --&amp;gt; InstallREST --&amp;gt; Install --&amp;gt; registerResourceHandlers&lt;/code>，最终核心的路由构造在&lt;code>registerResourceHandlers&lt;/code>方法内，该方法比较复杂，其主要功能是通过上一步骤构造的 REST Storage 判断该资源可以执行哪些操作（如 create、update 等），将其对应的操作存入到 action 中，每一个 action 对应一个标准的 REST 操作，如 create 对应的 action 操作为 POST、update 对应的 action 操作为 PUT。最终根据 actions 数组依次遍历，对每一个操作添加一个 handler 方法，注册到 route 中去，再将 route 注册到 webservice 中去，webservice 最终会注册到 container 中，遵循 go-restful 的设计模式；&lt;/li>
&lt;/ul>
&lt;p>关于 &lt;code>legacyRESTStorageProvider.NewLegacyRESTStorage&lt;/code> 以及 &lt;code>m.GenericAPIServer.InstallLegacyAPIGroup&lt;/code> 方法的详细说明在后文中会继续进行讲解。&lt;/p>
&lt;p>&lt;code>k8s.io/kubernetes/pkg/master/master.go:406&lt;/code>&lt;/p>
&lt;pre>&lt;code>func (m *Master) InstallLegacyAPI(......) error {
legacyRESTStorage, apiGroupInfo, err := legacyRESTStorageProvider.NewLegacyRESTStorage(restOptionsGetter)
if err != nil {
return fmt.Errorf(&amp;quot;Error building core storage: %v&amp;quot;, err)
}
controllerName := &amp;quot;bootstrap-controller&amp;quot;
coreClient := corev1client.NewForConfigOrDie(c.GenericConfig.LoopbackClientConfig)
bootstrapController := c.NewBootstrapController(legacyRESTStorage, coreClient, coreClient, coreClient, coreClient.RESTClient())
m.GenericAPIServer.AddPostStartHookOrDie(controllerName, bootstrapController.PostStartHook)
m.GenericAPIServer.AddPreShutdownHookOrDie(controllerName, bootstrapController.PreShutdownHook)
if err := m.GenericAPIServer.InstallLegacyAPIGroup(genericapiserver.DefaultLegacyAPIPrefix, &amp;amp;apiGroupInfo); err != nil {
return fmt.Errorf(&amp;quot;Error in registering group versions: %v&amp;quot;, err)
}
return nil
}
&lt;/code>&lt;/pre>
&lt;p>&lt;code>InstallAPIs&lt;/code> 与 &lt;code>InstallLegacyAPI&lt;/code> 的主要流程是类似的，限于篇幅此处不再深入分析。&lt;/p>
&lt;h4 id="createaggregatorserver">createAggregatorServer&lt;/h4>
&lt;p>&lt;code>AggregatorServer&lt;/code> 主要用于自定义的聚合控制器的，使 CRD 能够自动注册到集群中。&lt;/p>
&lt;p>主要逻辑为：&lt;/p>
&lt;ul>
&lt;li>1、调用 &lt;code>aggregatorConfig.Complete().NewWithDelegate&lt;/code> 创建 aggregatorServer；&lt;/li>
&lt;li>2、初始化 &lt;code>crdRegistrationController&lt;/code> 和 &lt;code>autoRegistrationController&lt;/code>，&lt;code>crdRegistrationController&lt;/code> 负责注册 CRD，&lt;code>autoRegistrationController&lt;/code> 负责将 CRD 对应的 APIServices 自动注册到 apiserver 中，CRD 创建后可通过 &lt;code>$ kubectl get apiservices&lt;/code> 查看是否注册到 apiservices 中；&lt;/li>
&lt;li>3、将 &lt;code>autoRegistrationController&lt;/code> 和 &lt;code>crdRegistrationController&lt;/code> 加入到 PostStartHook 中；&lt;/li>
&lt;/ul>
&lt;p>&lt;code>k8s.io/kubernetes/cmd/kube-apiserver/app/aggregator.go:124&lt;/code>&lt;/p>
&lt;pre>&lt;code>func createAggregatorServer(......) (*aggregatorapiserver.APIAggregator, error) {
// 1、初始化 aggregatorServer
aggregatorServer, err := aggregatorConfig.Complete().NewWithDelegate(delegateAPIServer)
if err != nil {
return nil, err
}
// 2、初始化 auto-registration controller
apiRegistrationClient, err := apiregistrationclient.NewForConfig(aggregatorConfig.GenericConfig.LoopbackClientConfig)
if err != nil {
return nil, err
}
autoRegistrationController := autoregister.NewAutoRegisterController(......)
apiServices := apiServicesToRegister(delegateAPIServer, autoRegistrationController)
crdRegistrationController := crdregistration.NewCRDRegistrationController(......)
err = aggregatorServer.GenericAPIServer.AddPostStartHook(&amp;quot;kube-apiserver-autoregistration&amp;quot;, func(context genericapiserver.PostStartHookContext) error {
go crdRegistrationController.Run(5, context.StopCh)
go func() {
if aggregatorConfig.GenericConfig.MergedResourceConfig.AnyVersionForGroupEnabled(&amp;quot;apiextensions.k8s.io&amp;quot;) {
crdRegistrationController.WaitForInitialSync()
}
autoRegistrationController.Run(5, context.StopCh)
}()
return nil
})
if err != nil {
return nil, err
}
err = aggregatorServer.GenericAPIServer.AddBootSequenceHealthChecks(
makeAPIServiceAvailableHealthCheck(
&amp;quot;autoregister-completion&amp;quot;,
apiServices,
aggregatorServer.APIRegistrationInformers.Apiregistration().V1().APIServices(),
),
)
if err != nil {
return nil, err
}
return aggregatorServer, nil
}
&lt;/code>&lt;/pre>
&lt;h5 id="aggregatorconfigcompletenewwithdelegate">aggregatorConfig.Complete().NewWithDelegate&lt;/h5>
&lt;p>&lt;code>aggregatorConfig.Complete().NewWithDelegate&lt;/code> 是初始化 aggregatorServer 的方法，主要逻辑为：&lt;/p>
&lt;ul>
&lt;li>1、调用 &lt;code>c.GenericConfig.New&lt;/code> 初始化 GenericAPIServer，其内部的主要功能在上文已经分析过；&lt;/li>
&lt;li>2、调用 &lt;code>apiservicerest.NewRESTStorage&lt;/code> 为 APIServices 资源创建 RESTStorage，RESTStorage 的目的是将每种资源的访问路径及其后端存储的操作对应起来；&lt;/li>
&lt;li>3、调用 &lt;code>s.GenericAPIServer.InstallAPIGroup&lt;/code> 为 APIGroup 注册路由信息；&lt;/li>
&lt;/ul>
&lt;p>&lt;code>k8s.io/kubernetes/staging/src/k8s.io/kube-aggregator/pkg/apiserver/apiserver.go:158&lt;/code>&lt;/p>
&lt;pre>&lt;code>func (c completedConfig) NewWithDelegate(delegationTarget genericapiserver.DelegationTarget) (*APIAggregator, error) {
openAPIConfig := c.GenericConfig.OpenAPIConfig
c.GenericConfig.OpenAPIConfig = nil
// 1、初始化 genericServer
genericServer, err := c.GenericConfig.New(&amp;quot;kube-aggregator&amp;quot;, delegationTarget)
if err != nil {
return nil, err
}
apiregistrationClient, err := clientset.NewForConfig(c.GenericConfig.LoopbackClientConfig)
if err != nil {
return nil, err
}
informerFactory := informers.NewSharedInformerFactory(
apiregistrationClient,
5*time.Minute,
)
s := &amp;amp;APIAggregator{
GenericAPIServer: genericServer,
delegateHandler: delegationTarget.UnprotectedHandler(),
......
}
// 2、为 API 注册路由
apiGroupInfo := apiservicerest.NewRESTStorage(c.GenericConfig.MergedResourceConfig, c.GenericConfig.RESTOptionsGetter)
if err := s.GenericAPIServer.InstallAPIGroup(&amp;amp;apiGroupInfo); err != nil {
return nil, err
}
// 3、初始化 apiserviceRegistrationController、availableController
apisHandler := &amp;amp;apisHandler{
codecs: aggregatorscheme.Codecs,
lister: s.lister,
}
s.GenericAPIServer.Handler.NonGoRestfulMux.Handle(&amp;quot;/apis&amp;quot;, apisHandler)
s.GenericAPIServer.Handler.NonGoRestfulMux.UnlistedHandle(&amp;quot;/apis/&amp;quot;, apisHandler)
apiserviceRegistrationController := NewAPIServiceRegistrationController(informerFactory.Apiregistration().V1().APIServices(), s)
availableController, err := statuscontrollers.NewAvailableConditionController(
......
)
if err != nil {
return nil, err
}
// 4、添加 PostStartHook
s.GenericAPIServer.AddPostStartHookOrDie(&amp;quot;start-kube-aggregator-informers&amp;quot;, func(context genericapiserver.PostStartHookContext) error {
informerFactory.Start(context.StopCh)
c.GenericConfig.SharedInformerFactory.Start(context.StopCh)
return nil
})
s.GenericAPIServer.AddPostStartHookOrDie(&amp;quot;apiservice-registration-controller&amp;quot;, func(context genericapiserver.PostStartHookContext) error {
go apiserviceRegistrationController.Run(context.StopCh)
return nil
})
s.GenericAPIServer.AddPostStartHookOrDie(&amp;quot;apiservice-status-available-controller&amp;quot;, func(context genericapiserver.PostStartHookContext) error {
go availableController.Run(5, context.StopCh)
return nil
})
return s, nil
}
&lt;/code>&lt;/pre>
&lt;p>以上是对 AggregatorServer 初始化流程的分析，可以看出，在创建 APIExtensionsServer、KubeAPIServer 以及 AggregatorServer 时，其模式都是类似的，首先调用 &lt;code>c.GenericConfig.New&lt;/code> 按照&lt;code>go-restful&lt;/code>的模式初始化 Container，然后为 server 中需要注册的资源创建 RESTStorage，最后将 resource 的 APIGroup 信息注册到路由中。&lt;/p>
&lt;p>至此，CreateServerChain 中流程已经分析完，其中的调用链如下所示：&lt;/p>
&lt;pre>&lt;code> |--&amp;gt; CreateNodeDialer
|
|--&amp;gt; CreateKubeAPIServerConfig
|
CreateServerChain --|--&amp;gt; createAPIExtensionsConfig
|
| |--&amp;gt; c.GenericConfig.New
|--&amp;gt; createAPIExtensionsServer --&amp;gt; apiextensionsConfig.Complete().New --|
| |--&amp;gt; s.GenericAPIServer.InstallAPIGroup
|
| |--&amp;gt; c.GenericConfig.New --&amp;gt; legacyRESTStorageProvider.NewLegacyRESTStorage
| |
|--&amp;gt; CreateKubeAPIServer --&amp;gt; kubeAPIServerConfig.Complete().New --|--&amp;gt; m.InstallLegacyAPI
| |
| |--&amp;gt; m.InstallAPIs
|
|
|--&amp;gt; createAggregatorConfig
|
| |--&amp;gt; c.GenericConfig.New
| |
|--&amp;gt; createAggregatorServer --&amp;gt; aggregatorConfig.Complete().NewWithDelegate --|--&amp;gt; apiservicerest.NewRESTStorage
|
|--&amp;gt; s.GenericAPIServer.InstallAPIGroup
&lt;/code>&lt;/pre>
&lt;h4 id="preparedrun">prepared.Run&lt;/h4>
&lt;p>在 &lt;code>Run&lt;/code> 方法中首先调用 &lt;code>CreateServerChain&lt;/code> 完成各 server 的初始化，然后调用 &lt;code>server.PrepareRun&lt;/code> 完成服务启动前的准备工作，最后调用 &lt;code>prepared.Run&lt;/code> 方法来启动安全的 http server。&lt;code>server.PrepareRun&lt;/code> 主要完成了健康检查、存活检查和&lt;code>OpenAPI&lt;/code>路由的注册工作，下面继续分析 &lt;code>prepared.Run&lt;/code> 的流程，在 &lt;code>prepared.Run&lt;/code> 中主要调用 &lt;code>s.NonBlockingRun&lt;/code> 来完成启动工作。&lt;/p>
&lt;p>&lt;code>k8s.io/kubernetes/staging/src/k8s.io/kube-aggregator/pkg/apiserver/apiserver.go:269&lt;/code>&lt;/p>
&lt;pre>&lt;code>func (s preparedAPIAggregator) Run(stopCh &amp;lt;-chan struct{}) error {
return s.runnable.Run(stopCh)
}
&lt;/code>&lt;/pre>
&lt;p>&lt;code>k8s.io/kubernetes/staging/src/k8s.io/apiserver/pkg/server/genericapiserver.go:316&lt;/code>&lt;/p>
&lt;pre>&lt;code>func (s preparedGenericAPIServer) Run(stopCh &amp;lt;-chan struct{}) error {
delayedStopCh := make(chan struct{})
go func() {
defer close(delayedStopCh)
&amp;lt;-stopCh
time.Sleep(s.ShutdownDelayDuration)
}()
// 调用 s.NonBlockingRun 完成启动流程
err := s.NonBlockingRun(delayedStopCh)
if err != nil {
return err
}
// 当收到退出信号后完成一些收尾工作
&amp;lt;-stopCh
err = s.RunPreShutdownHooks()
if err != nil {
return err
}
&amp;lt;-delayedStopCh
s.HandlerChainWaitGroup.Wait()
return nil
}
&lt;/code>&lt;/pre>
&lt;h5 id="snonblockingrun">s.NonBlockingRun&lt;/h5>
&lt;p>&lt;code>s.NonBlockingRun&lt;/code> 的主要逻辑为：&lt;/p>
&lt;ul>
&lt;li>1、判断是否要启动审计日志服务；&lt;/li>
&lt;li>2、调用 &lt;code>s.SecureServingInfo.Serve&lt;/code> 配置并启动 https server；&lt;/li>
&lt;li>3、执行 postStartHooks；&lt;/li>
&lt;li>4、向 systemd 发送 ready 信号；&lt;/li>
&lt;/ul>
&lt;p>&lt;code>k8s.io/kubernetes/staging/src/k8s.io/apiserver/pkg/server/genericapiserver.go:351&lt;/code>&lt;/p>
&lt;pre>&lt;code>func (s preparedGenericAPIServer) NonBlockingRun(stopCh &amp;lt;-chan struct{}) error {
auditStopCh := make(chan struct{})
// 1、判断是否要启动审计日志
if s.AuditBackend != nil {
if err := s.AuditBackend.Run(auditStopCh); err != nil {
return fmt.Errorf(&amp;quot;failed to run the audit backend: %v&amp;quot;, err)
}
}
// 2、启动 https server
internalStopCh := make(chan struct{})
var stoppedCh &amp;lt;-chan struct{}
if s.SecureServingInfo != nil &amp;amp;&amp;amp; s.Handler != nil {
var err error
stoppedCh, err = s.SecureServingInfo.Serve(s.Handler, s.ShutdownTimeout, internalStopCh)
if err != nil {
close(internalStopCh)
close(auditStopCh)
return err
}
}
go func() {
&amp;lt;-stopCh
close(s.readinessStopCh)
close(internalStopCh)
if stoppedCh != nil {
&amp;lt;-stoppedCh
}
s.HandlerChainWaitGroup.Wait()
close(auditStopCh)
}()
// 3、执行 postStartHooks
s.RunPostStartHooks(stopCh)
// 4、向 systemd 发送 ready 信号
if _, err := systemd.SdNotify(true, &amp;quot;READY=1\n&amp;quot;); err != nil {
klog.Errorf(&amp;quot;Unable to send systemd daemon successful start message: %v\n&amp;quot;, err)
}
return nil
}
&lt;/code>&lt;/pre>
&lt;p>以上就是 server 的初始化以及启动流程过程的分析，上文已经提到各 server 初始化过程中最重要的就是 API Resource RESTStorage 的初始化以及路由的注册，由于该过程比较复杂，下文会单独进行讲述。&lt;/p>
&lt;h3 id="storagefactory-的构建">storageFactory 的构建&lt;/h3>
&lt;p>上文已经提到过，apiserver 最终实现的 handler 对应的后端数据是以 &lt;strong>Store&lt;/strong> 的结构保存的，这里以 &lt;code>/api&lt;/code> 开头的路由举例，通过&lt;code>NewLegacyRESTStorage&lt;/code>方法创建各个资源的&lt;strong>RESTStorage&lt;/strong>。RESTStorage 是一个结构体，具体的定义在&lt;code>k8s.io/apiserver/pkg/registry/generic/registry/store.go&lt;/code>下，结构体内主要包含&lt;code>NewFunc&lt;/code>返回特定资源信息、&lt;code>NewListFunc&lt;/code>返回特定资源列表、&lt;code>CreateStrategy&lt;/code>特定资源创建时的策略、&lt;code>UpdateStrategy&lt;/code>更新时的策略以及&lt;code>DeleteStrategy&lt;/code>删除时的策略等重要方法。在&lt;code>NewLegacyRESTStorage&lt;/code>内部，可以看到创建了多种资源的 RESTStorage。&lt;/p>
&lt;p>&lt;code>NewLegacyRESTStorage&lt;/code> 的调用链为 &lt;code>CreateKubeAPIServer --&amp;gt; kubeAPIServerConfig.Complete().New --&amp;gt; m.InstallLegacyAPI --&amp;gt; legacyRESTStorageProvider.NewLegacyRESTStorage&lt;/code>。&lt;/p>
&lt;h4 id="newlegacyreststorage">NewLegacyRESTStorage&lt;/h4>
&lt;p>一个 API Group 下的资源都有其 REST 实现，&lt;code>k8s.io/kubernetes/pkg/registry&lt;/code>下所有的 Group 都有一个 rest 目录，存储的就是对应资源的 RESTStorage。在&lt;code>NewLegacyRESTStorage&lt;/code>方法中，通过&lt;code>NewREST&lt;/code>或者&lt;code>NewStorage&lt;/code>会生成各种资源对应的 Storage，此处以 pod 为例进行说明。&lt;/p>
&lt;p>&lt;code>k8s.io/kubernetes/pkg/registry/core/rest/storage_core.go:102&lt;/code>&lt;/p>
&lt;pre>&lt;code>func (c LegacyRESTStorageProvider) NewLegacyRESTStorage(restOptionsGetter generic.RESTOptionsGetter) (LegacyRESTStorage, genericapiserver. APIGroupInfo, error) {
apiGroupInfo := genericapiserver.APIGroupInfo{
PrioritizedVersions: legacyscheme.Scheme.PrioritizedVersionsForGroup(&amp;quot;&amp;quot;),
VersionedResourcesStorageMap: map[string]map[string]rest.Storage{},
Scheme: legacyscheme.Scheme,
ParameterCodec: legacyscheme.ParameterCodec,
NegotiatedSerializer: legacyscheme.Codecs,
}
var podDisruptionClient policyclient.PodDisruptionBudgetsGetter
if policyGroupVersion := (schema.GroupVersion{Group: &amp;quot;policy&amp;quot;, Version: &amp;quot;v1beta1&amp;quot;}); legacyscheme.Scheme. IsVersionRegistered(policyGroupVersion) {
var err error
podDisruptionClient, err = policyclient.NewForConfig(c.LoopbackClientConfig)
if err != nil {
return LegacyRESTStorage{}, genericapiserver.APIGroupInfo{}, err
}
}
// 1、LegacyAPI 下的 resource RESTStorage 的初始化
restStorage := LegacyRESTStorage{}
podTemplateStorage, err := podtemplatestore.NewREST(restOptionsGetter)
if err != nil {
return LegacyRESTStorage{}, genericapiserver.APIGroupInfo{}, err
}
eventStorage, err := eventstore.NewREST(restOptionsGetter, uint64(c.EventTTL.Seconds()))
if err != nil {
return LegacyRESTStorage{}, genericapiserver.APIGroupInfo{}, err
}
limitRangeStorage, err := limitrangestore.NewREST(restOptionsGetter)
if err != nil {
return LegacyRESTStorage{}, genericapiserver.APIGroupInfo{}, err
}
......
endpointsStorage, err := endpointsstore.NewREST(restOptionsGetter)
if err != nil {
return LegacyRESTStorage{}, genericapiserver.APIGroupInfo{}, err
}
nodeStorage, err := nodestore.NewStorage(restOptionsGetter, c.KubeletClientConfig, c.ProxyTransport)
if err != nil {
return LegacyRESTStorage{}, genericapiserver.APIGroupInfo{}, err
}
// 2、pod RESTStorage 的初始化
podStorage, err := podstore.NewStorage(......)
if err != nil {
return LegacyRESTStorage{}, genericapiserver.APIGroupInfo{}, err
}
......
serviceClusterIPAllocator, err := ipallocator.NewAllocatorCIDRRange(&amp;amp;serviceClusterIPRange, func(max int, rangeSpec string) (allocator. Interface, error) {
......
})
if err != nil {
return LegacyRESTStorage{}, genericapiserver.APIGroupInfo{}, fmt.Errorf(&amp;quot;cannot create cluster IP allocator: %v&amp;quot;, err)
}
restStorage.ServiceClusterIPAllocator = serviceClusterIPRegistry
var secondaryServiceClusterIPAllocator ipallocator.Interface
if utilfeature.DefaultFeatureGate.Enabled(features.IPv6DualStack) &amp;amp;&amp;amp; c.SecondaryServiceIPRange.IP != nil {
......
}
var serviceNodePortRegistry rangeallocation.RangeRegistry
serviceNodePortAllocator, err := portallocator.NewPortAllocatorCustom(c.ServiceNodePortRange, func(max int, rangeSpec string) (allocator.Interface, error) {
......
})
if err != nil {
return LegacyRESTStorage{}, genericapiserver.APIGroupInfo{}, fmt.Errorf(&amp;quot;cannot create cluster port allocator: %v&amp;quot;, err)
}
restStorage.ServiceNodePortAllocator = serviceNodePortRegistry
controllerStorage, err := controllerstore.NewStorage(restOptionsGetter)
if err != nil {
return LegacyRESTStorage{}, genericapiserver.APIGroupInfo{}, err
}
serviceRest, serviceRestProxy := servicestore.NewREST(......)
// 3、restStorageMap 保存 resource http path 与 RESTStorage 对应关系
restStorageMap := map[string]rest.Storage{
&amp;quot;pods&amp;quot;: podStorage.Pod,
&amp;quot;pods/attach&amp;quot;: podStorage.Attach,
&amp;quot;pods/status&amp;quot;: podStorage.Status,
&amp;quot;pods/log&amp;quot;: podStorage.Log,
&amp;quot;pods/exec&amp;quot;: podStorage.Exec,
&amp;quot;pods/portforward&amp;quot;: podStorage.PortForward,
&amp;quot;pods/proxy&amp;quot;: podStorage.Proxy,
......
&amp;quot;componentStatuses&amp;quot;: componentstatus.NewStorage(componentStatusStorage{c.StorageFactory}.serversToValidate),
}
......
}
&lt;/code>&lt;/pre>
&lt;h5 id="podstorenewstorage">podstore.NewStorage&lt;/h5>
&lt;p>&lt;code>podstore.NewStorage&lt;/code> 是为 pod 生成 storage 的方法，该方法主要功能是为 pod 创建后端存储最终返回一个 RESTStorage 对象，其中调用 &lt;code>store.CompleteWithOptions&lt;/code> 来创建后端存储的。&lt;/p>
&lt;p>&lt;code>k8s.io/kubernetes/pkg/registry/core/pod/storage/storage.go:71&lt;/code>&lt;/p>
&lt;pre>&lt;code>func NewStorage(......) (PodStorage, error) {
store := &amp;amp;genericregistry.Store{
NewFunc: func() runtime.Object { return &amp;amp;api.Pod{} },
NewListFunc: func() runtime.Object { return &amp;amp;api.PodList{} },
......
}
options := &amp;amp;generic.StoreOptions{
RESTOptions: optsGetter,
AttrFunc: pod.GetAttrs,
TriggerFunc: map[string]storage.IndexerFunc{&amp;quot;spec.nodeName&amp;quot;: pod.NodeNameTriggerFunc},
}
// 调用 store.CompleteWithOptions
if err := store.CompleteWithOptions(options); err != nil {
return PodStorage{}, err
}
statusStore := *store
statusStore.UpdateStrategy = pod.StatusStrategy
ephemeralContainersStore := *store
ephemeralContainersStore.UpdateStrategy = pod.EphemeralContainersStrategy
bindingREST := &amp;amp;BindingREST{store: store}
// PodStorage 对象
return PodStorage{
Pod: &amp;amp;REST{store, proxyTransport},
Binding: &amp;amp;BindingREST{store: store},
LegacyBinding: &amp;amp;LegacyBindingREST{bindingREST},
Eviction: newEvictionStorage(store, podDisruptionBudgetClient),
Status: &amp;amp;StatusREST{store: &amp;amp;statusStore},
EphemeralContainers: &amp;amp;EphemeralContainersREST{store: &amp;amp;ephemeralContainersStore},
Log: &amp;amp;podrest.LogREST{Store: store, KubeletConn: k},
Proxy: &amp;amp;podrest.ProxyREST{Store: store, ProxyTransport: proxyTransport},
Exec: &amp;amp;podrest.ExecREST{Store: store, KubeletConn: k},
Attach: &amp;amp;podrest.AttachREST{Store: store, KubeletConn: k},
PortForward: &amp;amp;podrest.PortForwardREST{Store: store, KubeletConn: k},
}, nil
}
&lt;/code>&lt;/pre>
&lt;p>可以看到最终返回的对象里对 pod 的不同操作都是一个 REST 对象，REST 中自动集成了 &lt;code>genericregistry.Store&lt;/code> 对象，而 &lt;code>store.CompleteWithOptions&lt;/code> 方法就是对 &lt;code>genericregistry.Store&lt;/code> 对象中存储实例就行初始化的。&lt;/p>
&lt;pre>&lt;code>type REST struct {
*genericregistry.Store
proxyTransport http.RoundTripper
}
type BindingREST struct {
store *genericregistry.Store
}
......
&lt;/code>&lt;/pre>
&lt;h5 id="storecompletewithoptions">store.CompleteWithOptions&lt;/h5>
&lt;p>&lt;code>store.CompleteWithOptions&lt;/code> 主要功能是为 store 中的配置设置一些默认的值以及根据提供的 options 更新 store，其中最主要的就是初始化 store 的后端存储实例。&lt;/p>
&lt;p>在&lt;code>CompleteWithOptions&lt;/code>方法内，调用了&lt;code>options.RESTOptions.GetRESTOptions&lt;/code> 方法，其最终返回&lt;code>generic.RESTOptions&lt;/code> 对象，&lt;code>generic.RESTOptions&lt;/code> 对象中包含对 etcd 初始化的一些配置、数据序列化方法以及对 etcd 操作的 storage.Interface 对象。其会依次调用&lt;code>StorageWithCacher--&amp;gt;NewRawStorage--&amp;gt;Create&lt;/code>方法创建最终依赖的后端存储。&lt;/p>
&lt;p>&lt;code>k8s.io/kubernetes/staging/src/k8s.io/apiserver/pkg/registry/generic/registry/store.go:1192&lt;/code>&lt;/p>
&lt;pre>&lt;code>func (e *Store) CompleteWithOptions(options *generic.StoreOptions) error {
......
var isNamespaced bool
switch {
case e.CreateStrategy != nil:
isNamespaced = e.CreateStrategy.NamespaceScoped()
case e.UpdateStrategy != nil:
isNamespaced = e.UpdateStrategy.NamespaceScoped()
default:
return fmt.Errorf(&amp;quot;store for %s must have CreateStrategy or UpdateStrategy set&amp;quot;, e.DefaultQualifiedResource.String())
}
......
// 1、调用 options.RESTOptions.GetRESTOptions
opts, err := options.RESTOptions.GetRESTOptions(e.DefaultQualifiedResource)
if err != nil {
return err
}
// 2、设置 ResourcePrefix
prefix := opts.ResourcePrefix
if !strings.HasPrefix(prefix, &amp;quot;/&amp;quot;) {
prefix = &amp;quot;/&amp;quot; + prefix
}
if prefix == &amp;quot;/&amp;quot; {
return fmt.Errorf(&amp;quot;store for %s has an invalid prefix %q&amp;quot;, e.DefaultQualifiedResource.String(), opts.ResourcePrefix)
}
if e.KeyRootFunc == nil &amp;amp;&amp;amp; e.KeyFunc == nil {
......
}
keyFunc := func(obj runtime.Object) (string, error) {
......
}
// 3、以下操作主要是将 opts 对象中的值赋值到 store 对象中
if e.DeleteCollectionWorkers == 0 {
e.DeleteCollectionWorkers = opts.DeleteCollectionWorkers
}
e.EnableGarbageCollection = opts.EnableGarbageCollection
if e.ObjectNameFunc == nil {
......
}
if e.Storage.Storage == nil {
e.Storage.Codec = opts.StorageConfig.Codec
var err error
e.Storage.Storage, e.DestroyFunc, err = opts.Decorator(
opts.StorageConfig,
prefix,
keyFunc,
e.NewFunc,
e.NewListFunc,
attrFunc,
options.TriggerFunc,
)
if err != nil {
return err
}
e.StorageVersioner = opts.StorageConfig.EncodeVersioner
if opts.CountMetricPollPeriod &amp;gt; 0 {
stopFunc := e.startObservingCount(opts.CountMetricPollPeriod)
previousDestroy := e.DestroyFunc
e.DestroyFunc = func() {
stopFunc()
if previousDestroy != nil {
previousDestroy()
}
}
}
}
return nil
}
&lt;/code>&lt;/pre>
&lt;p>&lt;code>options.RESTOptions&lt;/code> 是一个 interface，想要找到其 &lt;code>GetRESTOptions&lt;/code> 方法的实现必须知道 &lt;code>options.RESTOptions&lt;/code> 初始化时对应的实例，其初始化是在 &lt;code>CreateKubeAPIServerConfig --&amp;gt; buildGenericConfig --&amp;gt; s.Etcd.ApplyWithStorageFactoryTo&lt;/code> 方法中进行初始化的，&lt;code>RESTOptions&lt;/code> 对应的实例为 &lt;code>StorageFactoryRestOptionsFactory&lt;/code>，所以 PodStorage 初始时构建的 store 对象中&lt;code>genericserver.Config.RESTOptionsGetter&lt;/code> 实际的对象类型为 &lt;code>StorageFactoryRestOptionsFactory&lt;/code>，其 &lt;code>GetRESTOptions&lt;/code> 方法如下所示：&lt;/p>
&lt;p>&lt;code>k8s.io/kubernetes/staging/src/k8s.io/apiserver/pkg/server/options/etcd.go:253&lt;/code>&lt;/p>
&lt;pre>&lt;code>func (f *StorageFactoryRestOptionsFactory) GetRESTOptions(resource schema.GroupResource) (generic.RESTOptions, error) {
storageConfig, err := f.StorageFactory.NewConfig(resource)
if err != nil {
return generic.RESTOptions{}, fmt.Errorf(&amp;quot;unable to find storage destination for %v, due to %v&amp;quot;, resource, err.Error())
}
ret := generic.RESTOptions{
StorageConfig: storageConfig,
Decorator: generic.UndecoratedStorage,
DeleteCollectionWorkers: f.Options.DeleteCollectionWorkers,
EnableGarbageCollection: f.Options.EnableGarbageCollection,
ResourcePrefix: f.StorageFactory.ResourcePrefix(resource),
CountMetricPollPeriod: f.Options.StorageConfig.CountMetricPollPeriod,
}
if f.Options.EnableWatchCache {
sizes, err := ParseWatchCacheSizes(f.Options.WatchCacheSizes)
if err != nil {
return generic.RESTOptions{}, err
}
cacheSize, ok := sizes[resource]
if !ok {
cacheSize = f.Options.DefaultWatchCacheSize
}
// 调用 generic.StorageDecorator
ret.Decorator = genericregistry.StorageWithCacher(cacheSize)
}
return ret, nil
}
&lt;/code>&lt;/pre>
&lt;p>在 &lt;code>genericregistry.StorageWithCacher&lt;/code> 中又调用了不同的方法最终会调用 &lt;code>factory.Create&lt;/code> 来初始化存储实例，其调用链为：&lt;code>genericregistry.StorageWithCacher --&amp;gt; generic.NewRawStorage --&amp;gt; factory.Create&lt;/code>。&lt;/p>
&lt;p>&lt;code>k8s.io/kubernetes/staging/src/k8s.io/apiserver/pkg/storage/storagebackend/factory/factory.go:30&lt;/code>&lt;/p>
&lt;pre>&lt;code>func Create(c storagebackend.Config) (storage.Interface, DestroyFunc, error) {
switch c.Type {
case &amp;quot;etcd2&amp;quot;:
return nil, nil, fmt.Errorf(&amp;quot;%v is no longer a supported storage backend&amp;quot;, c.Type)
// 目前 k8s 只支持使用 etcd v3
case storagebackend.StorageTypeUnset, storagebackend.StorageTypeETCD3:
return newETCD3Storage(c)
default:
return nil, nil, fmt.Errorf(&amp;quot;unknown storage type: %s&amp;quot;, c.Type)
}
}
&lt;/code>&lt;/pre>
&lt;h6 id="newetcd3storage">newETCD3Storage&lt;/h6>
&lt;p>在 &lt;code>newETCD3Storage&lt;/code> 中，首先通过调用 &lt;code>newETCD3Client&lt;/code> 创建 etcd 的 client，client 的创建最终是通过 etcd 官方提供的客户端工具 &lt;a href="https://github.com/etcd-io/etcd/tree/master/clientv3">clientv3&lt;/a> 进行创建的。&lt;/p>
&lt;p>&lt;code>k8s.io/kubernetes/staging/src/k8s.io/apiserver/pkg/storage/storagebackend/factory/etcd3.go:209&lt;/code>&lt;/p>
&lt;pre>&lt;code>func newETCD3Storage(c storagebackend.Config) (storage.Interface, DestroyFunc, error) {
stopCompactor, err := startCompactorOnce(c.Transport, c.CompactionInterval)
if err != nil {
return nil, nil, err
}
client, err := newETCD3Client(c.Transport)
if err != nil {
stopCompactor()
return nil, nil, err
}
var once sync.Once
destroyFunc := func() {
once.Do(func() {
stopCompactor()
client.Close()
})
}
transformer := c.Transformer
if transformer == nil {
transformer = value.IdentityTransformer
}
return etcd3.New(client, c.Codec, c.Prefix, transformer, c.Paging), destroyFunc, nil
}
&lt;/code>&lt;/pre>
&lt;p>至此对于 pod resource 中 store 的构建基本分析完成，不同 resource 对应一个 REST 对象，其中又引用了 &lt;code>genericregistry.Store&lt;/code> 对象，最终是对 &lt;code>genericregistry.Store&lt;/code> 的初始化。在分析完 store 的初始化后还有一个重要的步骤就是路由的注册，路由注册主要的流程是为 resource 根据不同 verbs 构建 http path 以及将 path 与对应 handler 进行绑定。&lt;/p>
&lt;h4 id="路由注册">路由注册&lt;/h4>
&lt;p>上文 RESTStorage 的构建对应的是 &lt;code>InstallLegacyAPI&lt;/code> 中的 &lt;code>legacyRESTStorageProvider.NewLegacyRESTStorage&lt;/code> 方法，下面继续分析 &lt;code>InstallLegacyAPI&lt;/code> 中的 &lt;code>m.GenericAPIServer.InstallLegacyAPIGroup&lt;/code> 方法的实现。&lt;/p>
&lt;p>&lt;code>k8s.io/kubernetes/pkg/master/master.go:406&lt;/code>&lt;/p>
&lt;pre>&lt;code>func (m *Master) InstallLegacyAPI(......) error {
legacyRESTStorage, apiGroupInfo, err := legacyRESTStorageProvider.NewLegacyRESTStorage(restOptionsGetter)
if err != nil {
return fmt.Errorf(&amp;quot;Error building core storage: %v&amp;quot;, err)
}
......
if err := m.GenericAPIServer.InstallLegacyAPIGroup(genericapiserver.DefaultLegacyAPIPrefix, &amp;amp;apiGroupInfo); err != nil {
return fmt.Errorf(&amp;quot;Error in registering group versions: %v&amp;quot;, err)
}
return nil
}
&lt;/code>&lt;/pre>
&lt;p>&lt;code>m.GenericAPIServer.InstallLegacyAPIGroup&lt;/code> 的调用链非常深，最终是为 Group 下每一个 API resources 注册 handler 及路由信息，其调用链为：&lt;code>m.GenericAPIServer.InstallLegacyAPIGroup --&amp;gt; s.installAPIResources --&amp;gt; apiGroupVersion.InstallREST --&amp;gt; installer.Install --&amp;gt; a.registerResourceHandlers&lt;/code>。其中几个方法的作用如下所示：&lt;/p>
&lt;ul>
&lt;li>&lt;code>s.installAPIResources&lt;/code>：为每一个 API resource 调用 &lt;code>apiGroupVersion.InstallREST&lt;/code> 添加路由；&lt;/li>
&lt;li>&lt;code>apiGroupVersion.InstallREST&lt;/code>：将 &lt;code>restful.WebServic&lt;/code> 对象添加到 container 中；&lt;/li>
&lt;li>&lt;code>installer.Install&lt;/code>：返回最终的 &lt;code>restful.WebService&lt;/code> 对象&lt;/li>
&lt;/ul>
&lt;h5 id="aregisterresourcehandlers">a.registerResourceHandlers&lt;/h5>
&lt;p>该方法实现了 &lt;code>rest.Storage&lt;/code> 到 &lt;code>restful.Route&lt;/code> 的转换，其首先会判断 API Resource 所支持的 REST 接口，然后为 REST 接口添加对应的 handler，最后将其注册到路由中。&lt;/p>
&lt;p>&lt;code>k8s.io/kubernetes/staging/src/k8s.io/apiserver/pkg/endpoints/installer.go:181&lt;/code>&lt;/p>
&lt;pre>&lt;code>func (a *APIInstaller) registerResourceHandlers(path string, storage rest.Storage, ws *restful.WebService) (*metav1.APIResource, error) {
admit := a.group.Admit
......
// 1、判断该 resource 实现了哪些 REST 操作接口，以此来判断其支持的 verbs 以便为其添加路由
creater, isCreater := storage.(rest.Creater)
namedCreater, isNamedCreater := storage.(rest.NamedCreater)
lister, isLister := storage.(rest.Lister)
getter, isGetter := storage.(rest.Getter)
getterWithOptions, isGetterWithOptions := storage.(rest.GetterWithOptions)
gracefulDeleter, isGracefulDeleter := storage.(rest.GracefulDeleter)
collectionDeleter, isCollectionDeleter := storage.(rest.CollectionDeleter)
updater, isUpdater := storage.(rest.Updater)
patcher, isPatcher := storage.(rest.Patcher)
watcher, isWatcher := storage.(rest.Watcher)
connecter, isConnecter := storage.(rest.Connecter)
storageMeta, isMetadata := storage.(rest.StorageMetadata)
storageVersionProvider, isStorageVersionProvider := storage.(rest.StorageVersionProvider)
if !isMetadata {
storageMeta = defaultStorageMetadata{}
}
exporter, isExporter := storage.(rest.Exporter)
if !isExporter {
exporter = nil
}
......
// 2、为 resource 添加对应的 actions 并根据是否支持 namespace
switch {
case !namespaceScoped:
......
actions = appendIf(actions, action{&amp;quot;LIST&amp;quot;, resourcePath, resourceParams, namer, false}, isLister)
actions = appendIf(actions, action{&amp;quot;POST&amp;quot;, resourcePath, resourceParams, namer, false}, isCreater)
actions = appendIf(actions, action{&amp;quot;DELETECOLLECTION&amp;quot;, resourcePath, resourceParams, namer, false}, isCollectionDeleter)
actions = appendIf(actions, action{&amp;quot;WATCHLIST&amp;quot;, &amp;quot;watch/&amp;quot; + resourcePath, resourceParams, namer, false}, allowWatchList)
actions = appendIf(actions, action{&amp;quot;GET&amp;quot;, itemPath, nameParams, namer, false}, isGetter)
if getSubpath {
actions = appendIf(actions, action{&amp;quot;GET&amp;quot;, itemPath + &amp;quot;/{path:*}&amp;quot;, proxyParams, namer, false}, isGetter)
}
actions = appendIf(actions, action{&amp;quot;PUT&amp;quot;, itemPath, nameParams, namer, false}, isUpdater)
actions = appendIf(actions, action{&amp;quot;PATCH&amp;quot;, itemPath, nameParams, namer, false}, isPatcher)
actions = appendIf(actions, action{&amp;quot;DELETE&amp;quot;, itemPath, nameParams, namer, false}, isGracefulDeleter)
actions = appendIf(actions, action{&amp;quot;WATCH&amp;quot;, &amp;quot;watch/&amp;quot; + itemPath, nameParams, namer, false}, isWatcher)
actions = appendIf(actions, action{&amp;quot;CONNECT&amp;quot;, itemPath, nameParams, namer, false}, isConnecter)
actions = appendIf(actions, action{&amp;quot;CONNECT&amp;quot;, itemPath + &amp;quot;/{path:*}&amp;quot;, proxyParams, namer, false}, isConnecter &amp;amp;&amp;amp; connectSubpath)
default:
......
actions = appendIf(actions, action{&amp;quot;LIST&amp;quot;, resourcePath, resourceParams, namer, false}, isLister)
actions = appendIf(actions, action{&amp;quot;POST&amp;quot;, resourcePath, resourceParams, namer, false}, isCreater)
actions = appendIf(actions, action{&amp;quot;DELETECOLLECTION&amp;quot;, resourcePath, resourceParams, namer, false}, isCollectionDeleter)
actions = appendIf(actions, action{&amp;quot;WATCHLIST&amp;quot;, &amp;quot;watch/&amp;quot; + resourcePath, resourceParams, namer, false}, allowWatchList)
actions = appendIf(actions, action{&amp;quot;GET&amp;quot;, itemPath, nameParams, namer, false}, isGetter)
......
}
// 3、根据 action 创建对应的 route
kubeVerbs := map[string]struct{}{}
reqScope := handlers.RequestScope{
Serializer: a.group.Serializer,
ParameterCodec: a.group.ParameterCodec,
Creater: a.group.Creater,
Convertor: a.group.Convertor,
......
}
......
// 4、从 rest.Storage 到 restful.Route 映射
// 为每个操作添加对应的 handler
for _, action := range actions {
......
verbOverrider, needOverride := storage.(StorageMetricsOverride)
switch action.Verb {
case &amp;quot;GET&amp;quot;: ......
case &amp;quot;LIST&amp;quot;:
case &amp;quot;PUT&amp;quot;:
case &amp;quot;PATCH&amp;quot;:
// 此处以 POST 操作进行说明
case &amp;quot;POST&amp;quot;:
var handler restful.RouteFunction
// 5、初始化 handler
if isNamedCreater {
handler = restfulCreateNamedResource(namedCreater, reqScope, admit)
} else {
handler = restfulCreateResource(creater, reqScope, admit)
}
handler = metrics.InstrumentRouteFunc(action.Verb, group, version, resource, subresource, requestScope, metrics.APIServerComponent, handler)
article := GetArticleForNoun(kind, &amp;quot; &amp;quot;)
doc := &amp;quot;create&amp;quot; + article + kind
if isSubresource {
doc = &amp;quot;create &amp;quot; + subresource + &amp;quot; of&amp;quot; + article + kind
}
// 6、route 与 handler 进行绑定
route := ws.POST(action.Path).To(handler).
Doc(doc).
Param(ws.QueryParameter(&amp;quot;pretty&amp;quot;, &amp;quot;If 'true', then the output is pretty printed.&amp;quot;)).
Operation(&amp;quot;create&amp;quot;+namespaced+kind+strings.Title(subresource)+operationSuffix).
Produces(append(storageMeta.ProducesMIMETypes(action.Verb), mediaTypes...)...).
Returns(http.StatusOK, &amp;quot;OK&amp;quot;, producedObject).
Returns(http.StatusCreated, &amp;quot;Created&amp;quot;, producedObject).
Returns(http.StatusAccepted, &amp;quot;Accepted&amp;quot;, producedObject).
Reads(defaultVersionedObject).
Writes(producedObject)
if err := AddObjectParams(ws, route, versionedCreateOptions); err != nil {
return nil, err
}
addParams(route, action.Params)
// 7、添加到路由中
routes = append(routes, route)
case &amp;quot;DELETE&amp;quot;:
case &amp;quot;DELETECOLLECTION&amp;quot;:
case &amp;quot;WATCH&amp;quot;:
case &amp;quot;WATCHLIST&amp;quot;:
case &amp;quot;CONNECT&amp;quot;:
default:
}
......
return &amp;amp;apiResource, nil
}
&lt;/code>&lt;/pre>
&lt;h5 id="restfulcreatenamedresource">restfulCreateNamedResource&lt;/h5>
&lt;p>&lt;code>restfulCreateNamedResource&lt;/code> 是 POST 操作对应的 handler，最终会调用 &lt;code>createHandler&lt;/code> 方法完成。&lt;/p>
&lt;p>&lt;code>k8s.io/kubernetes/staging/src/k8s.io/apiserver/pkg/endpoints/installer.go:1087&lt;/code>&lt;/p>
&lt;pre>&lt;code>func restfulCreateNamedResource(r rest.NamedCreater, scope handlers.RequestScope, admit admission.Interface) restful.RouteFunction {
return func(req *restful.Request, res *restful.Response) {
handlers.CreateNamedResource(r, &amp;amp;scope, admit)(res.ResponseWriter, req.Request)
}
}
func CreateNamedResource(r rest.NamedCreater, scope *RequestScope, admission admission.Interface) http.HandlerFunc {
return createHandler(r, scope, admission, true)
}
&lt;/code>&lt;/pre>
&lt;h5 id="createhandler">createHandler&lt;/h5>
&lt;p>&lt;code>createHandler&lt;/code> 是将数据写入到后端存储的方法，对于资源的操作都有相关的权限控制，在 &lt;code>createHandler&lt;/code> 中首先会执行 &lt;code>decoder&lt;/code> 和 &lt;code>admission&lt;/code> 操作，然后调用 &lt;code>create&lt;/code> 方法完成 resource 的创建，在 &lt;code>create&lt;/code> 方法中会进行 &lt;code>validate&lt;/code> 以及最终将数据保存到后端存储中。&lt;code>admit&lt;/code> 操作即执行 kube-apiserver 中的 admission-plugins，admission-plugins 在 &lt;code>CreateKubeAPIServerConfig&lt;/code> 中被初始化为了 admissionChain，其初始化的调用链为 &lt;code>CreateKubeAPIServerConfig --&amp;gt; buildGenericConfig --&amp;gt; s.Admission.ApplyTo --&amp;gt; a.GenericAdmission.ApplyTo --&amp;gt; a.Plugins.NewFromPlugins&lt;/code>，最终在 &lt;code>a.Plugins.NewFromPlugins&lt;/code> 中将所有已启用的 plugins 封装为 admissionChain，此处要执行的 admit 操作即执行 admission-plugins 中的 admit 操作。&lt;/p>
&lt;p>&lt;code>createHandler&lt;/code> 中调用的 create 方法是&lt;code>genericregistry.Store&lt;/code> 对象的方法，在每个 resource 初始化 RESTStorage 都会引入 &lt;code>genericregistry.Store&lt;/code> 对象。&lt;/p>
&lt;p>&lt;code>createHandler&lt;/code> 中所有的操作就是本文开头提到的请求流程，如下所示：&lt;/p>
&lt;pre>&lt;code>v1beta1 ⇒ internal ⇒ | ⇒ | ⇒ v1 ⇒ json/yaml ⇒ etcd
admission validation
&lt;/code>&lt;/pre>
&lt;p>&lt;code>k8s.io/kubernetes/staging/src/k8s.io/apiserver/pkg/endpoints/handlers/create.go:46&lt;/code>&lt;/p>
&lt;pre>&lt;code>func createHandler(r rest.NamedCreater, scope *RequestScope, admit admission.Interface, includeName bool) http.HandlerFunc {
return func(w http.ResponseWriter, req *http.Request) {
trace := utiltrace.New(&amp;quot;Create&amp;quot;, utiltrace.Field{&amp;quot;url&amp;quot;, req.URL.Path})
defer trace.LogIfLong(500 * time.Millisecond)
......
gv := scope.Kind.GroupVersion()
// 1、得到合适的SerializerInfo
s, err := negotiation.NegotiateInputSerializer(req, false, scope.Serializer)
if err != nil {
scope.err(err, w, req)
return
}
// 2、找到合适的 decoder
decoder := scope.Serializer.DecoderToVersion(s.Serializer, scope.HubGroupVersion)
body, err := limitedReadBody(req, scope.MaxRequestBodyBytes)
if err != nil {
scope.err(err, w, req)
return
}
......
defaultGVK := scope.Kind
original := r.New()
trace.Step(&amp;quot;About to convert to expected version&amp;quot;)
// 3、decoder 解码
obj, gvk, err := decoder.Decode(body, &amp;amp;defaultGVK, original)
......
ae := request.AuditEventFrom(ctx)
admit = admission.WithAudit(admit, ae)
audit.LogRequestObject(ae, obj, scope.Resource, scope.Subresource, scope.Serializer)
userInfo, _ := request.UserFrom(ctx)
if len(name) == 0 {
_, name, _ = scope.Namer.ObjectName(obj)
}
// 4、执行 admit 操作，即执行 kube-apiserver 启动时加载的 admission-plugins，
admissionAttributes := admission.NewAttributesRecord(......)
if mutatingAdmission, ok := admit.(admission.MutationInterface); ok &amp;amp;&amp;amp; mutatingAdmission.Handles(admission.Create) {
err = mutatingAdmission.Admit(ctx, admissionAttributes, scope)
if err != nil {
scope.err(err, w, req)
return
}
}
......
// 5、执行 create 操作
result, err := finishRequest(timeout, func() (runtime.Object, error) {
return r.Create(
ctx,
name,
obj,
rest.AdmissionToValidateObjectFunc(admit, admissionAttributes, scope),
options,
)
})
......
}
}
&lt;/code>&lt;/pre>
&lt;h3 id="总结">总结&lt;/h3>
&lt;p>本文主要分析 kube-apiserver 的启动流程，kube-apiserver 中包含三个 server，分别为 KubeAPIServer、APIExtensionsServer 以及 AggregatorServer，三个 server 是通过委托模式连接在一起的，初始化过程都是类似的，首先为每个 server 创建对应的 config，然后初始化 http server，http server 的初始化过程为首先初始化 &lt;code>GoRestfulContainer&lt;/code>，然后安装 server 所包含的 API，安装 API 时首先为每个 API Resource 创建对应的后端存储 RESTStorage，再为每个 API Resource 支持的 verbs 添加对应的 handler，并将 handler 注册到 route 中，最后将 route 注册到 webservice 中，启动流程中 RESTFul API 的实现流程是其核心，至于 kube-apiserver 中认证鉴权等 filter 的实现、多版本资源转换、kubernetes service 的实现等一些细节会在后面的文章中继续进行分析。&lt;/p>
&lt;p>参考：&lt;/p>
&lt;p>&lt;a href="https://mp.weixin.qq.com/s/hTEWatYLhTnC5X0FBM2RWQ">https://mp.weixin.qq.com/s/hTEWatYLhTnC5X0FBM2RWQ&lt;/a>&lt;/p>
&lt;p>&lt;a href="https://bbbmj.github.io/2019/04/13/Kubernetes/code-analytics/kube-apiserver/">https://bbbmj.github.io/2019/04/13/Kubernetes/code-analytics/kube-apiserver/&lt;/a>&lt;/p>
&lt;p>&lt;a href="https://mp.weixin.qq.com/s/TQuqAAzBjeWHwKPJZ3iJhA">https://mp.weixin.qq.com/s/TQuqAAzBjeWHwKPJZ3iJhA&lt;/a>&lt;/p>
&lt;p>&lt;a href="https://blog.openshift.com/kubernetes-deep-dive-api-server-part-1/">https://blog.openshift.com/kubernetes-deep-dive-api-server-part-1/&lt;/a>&lt;/p>
&lt;p>&lt;a href="https://www.jianshu.com/p/daa4ff387a78">https://www.jianshu.com/p/daa4ff387a78&lt;/a>&lt;/p></description></item><item><title>Docs: Kubernetes并发控制和资源变更</title><link>https://desistdaydream.github.io/docs/10.%E4%BA%91%E5%8E%9F%E7%94%9F/2.3.Kubernetes-%E5%AE%B9%E5%99%A8%E7%BC%96%E6%8E%92%E7%B3%BB%E7%BB%9F/Kubernetes-%E5%BC%80%E5%8F%91/%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/API-Server-%E6%BA%90%E7%A0%81/Kubernetes%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6%E5%92%8C%E8%B5%84%E6%BA%90%E5%8F%98%E6%9B%B4/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/10.%E4%BA%91%E5%8E%9F%E7%94%9F/2.3.Kubernetes-%E5%AE%B9%E5%99%A8%E7%BC%96%E6%8E%92%E7%B3%BB%E7%BB%9F/Kubernetes-%E5%BC%80%E5%8F%91/%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/API-Server-%E6%BA%90%E7%A0%81/Kubernetes%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6%E5%92%8C%E8%B5%84%E6%BA%90%E5%8F%98%E6%9B%B4/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://mp.weixin.qq.com/s/pLmKnu-PY6hdcO7qmdvb5A">公众号，云原生实验室，Kubernetes 是如何控制并发和资源变更的&lt;/a>
&lt;ul>
&lt;li>&lt;a href="https://www.jianshu.com/p/ac830694a2cf">原文，简书，Kubernetes 并发控制和资源变更&lt;/a>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;h2 id="并发控制">并发控制&lt;/h2>
&lt;blockquote>
&lt;p>并发控制指的是当多个用户同时更新运行时，用于保护数据库完整性的各种技术。并发机制不正确可能导致脏读、幻读和不可重复读等此类问题。并发控制的目的是保证一个用户的工作不会对另一个用户的工作产生不合理的影响。&lt;/p>
&lt;/blockquote>
&lt;h3 id="悲观锁">悲观锁&lt;/h3>
&lt;p>悲观锁在操作数据时比较悲观，认为别人会同时修改数据。因此操作数据时直接把数据锁住，直到操作完成后才会释放锁；上锁期间其他人不能修改数据。&lt;/p>
&lt;p>悲观锁&lt;strong>主要用于数据争用激烈的环境&lt;/strong>，以及发生并发冲突时使用锁保护数据的成本要低于回滚事务的成本的环境中。&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/c5cda339-e90c-4fc0-9636-e84a6a8ad8fe/13618762-8d6f0d002e92278f.png" alt="">&lt;/p>
&lt;p>&lt;strong>优点&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>是“先取锁再访问”的保守策略，为数据处理的安全提供了保证。&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>缺点&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>在效率方面，处理加锁的机制会让数据库产生额外的开销，还有增加产生&lt;a href="https://links.jianshu.com/go?to=https%3A%2F%2Fzh.wikipedia.org%2Fwiki%2F%25E6%25AD%25BB%25E9%2594%2581">死锁&lt;/a>的机会；&lt;/li>
&lt;li>在只读型事务处理中由于不会产生冲突，也没必要使用锁，这样做只能增加系统&lt;a href="https://links.jianshu.com/go?to=https%3A%2F%2Fzh.wikipedia.org%2Fwiki%2F%25E8%25B4%259F%25E8%25BD%25BD">负载&lt;/a>；&lt;/li>
&lt;li>会降低了并行性，一个事务如果锁定了某行数据，其他事务就必须等待该事务处理完才可以处理那行数据。&lt;/li>
&lt;/ul>
&lt;h3 id="乐观锁">乐观锁&lt;/h3>
&lt;p>乐观锁在操作数据时非常乐观，认为别人不会同时修改数据。因此乐观锁不会上锁，只是在执行更新的时候判断一下在此期间别人是否修改了数据：如果别人修改了数据则放弃操作，否则执行操作。&lt;/p>
&lt;p>乐观并发控制多数&lt;strong>用于数据争用不大、冲突较少的环境中&lt;/strong>，这种环境中，偶尔回滚事务的成本会低于读取数据时锁定数据的成本，因此可以获得比其他并发控制方法更高的吞吐量。&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/c5cda339-e90c-4fc0-9636-e84a6a8ad8fe/13618762-64ac5f6be8446a30.png" alt="">&lt;/p>
&lt;p>&lt;strong>优点&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>不会产生任何锁和死锁&lt;/li>
&lt;li>有更高的吞吐量&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>缺点&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://links.jianshu.com/go?to=https%3A%2F%2Fzh.wikipedia.org%2Fwiki%2F%25E6%25AF%2594%25E8%25BE%2583%25E5%25B9%25B6%25E4%25BA%25A4%25E6%258D%25A2%23ABA%25E9%2597%25AE%25E9%25A2%2598">ABA 问题&lt;/a>是乐观锁一个常见的问题&lt;/li>
&lt;li>循环时间长开销大&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>乐观锁一般会使用版本号机制或 CAS 算法实现：&lt;/strong>&lt;/p>
&lt;h4 id="版本号机制">&lt;strong>版本号机制&lt;/strong>&lt;/h4>
&lt;p>一般是在数据表中加上一个数据版本号 version 字段，表示数据被修改的次数，当数据被修改时，version 值会加一。当线程 A 要更新数据值时，在读取数据的同时也会读取 version 值，在提交更新时，若刚才读取到的 version 值为当前数据库中的 version 值相等时才更新，否则重试更新操作，直到更新成功。&lt;/p>
&lt;h4 id="cas-算法">&lt;strong>CAS 算法&lt;/strong>&lt;/h4>
&lt;p>即&lt;strong>compare and swap（比较与交换）&lt;/strong>，是一种有名的&lt;strong>无锁算法&lt;/strong>。无锁编程，即不使用锁的情况下实现多线程之间的变量同步，也就是在没有线程被阻塞的情况下实现变量的同步，所以也叫非阻塞同步（Non-blocking Synchronization）。&lt;strong>CAS 算法&lt;/strong>涉及到三个操作数&lt;/p>
&lt;ul>
&lt;li>需要读写的内存值 V&lt;/li>
&lt;li>进行比较的值 A&lt;/li>
&lt;li>拟写入的新值 B&lt;/li>
&lt;/ul>
&lt;p>当且仅当 V 的值等于 A 时，CAS 通过原子方式用新值 B 来更新 V 的值，否则不会执行任何操作（比较和替换是一个原子操作）。一般情况下是一个&lt;strong>自旋操作&lt;/strong>，即&lt;strong>不断的重试&lt;/strong>。&lt;/p>
&lt;h2 id="kubernetes-并发控制">Kubernetes 并发控制&lt;/h2>
&lt;p>在 Kubernetes 集群中，外部用户及内部组件频繁的数据更新操作，导致系统的数据并发读写量非常大。假设采用悲观并行的控制方法，将严重损耗集群性能，因此 Kubernetes 采用乐观并行的控制方法。&lt;/p>
&lt;h3 id="resource-version">Resource Version&lt;/h3>
&lt;p>Kubernetes 通过定义资源版本字段实现了乐观并发控制，资源版本 (ResourceVersion)字段包含在 Kubernetes 对象的元数据 (Metadata)中。这个字符串格式的字段标识了对象的内部版本号。&lt;/p>
&lt;p>通过 API Server 获取到的所有对象中，都有一个”resourceVersion”的字段。如：&lt;/p>
&lt;pre>&lt;code>apiVersion: v1
kind: Pod
metadata:
resourceVersion: &amp;quot;879232&amp;quot;
selfLink: /api/v1/namespaces/default/pods/nginx-1zr5x
uid: 9910eaf7-f0f3-11e7-a0b3-0800274a4ec3
&lt;/code>&lt;/pre>
&lt;p>该 Pod 的 resourceVersion 为 879232，更新该 Pod 时，Kubernetes 会比较该 resourceVersion 和 ETCD 中对象的 resourceVersion，在一致的情况下都会更新，一旦发生更新，该对象的 resourceVersion 值也会改变。&lt;/p>
&lt;h4 id="resource-version-生成机制">Resource Version 生成机制&lt;/h4>
&lt;p>下面的代码是 Kubernetes 从 ETCD 中获取对象的过程，我们可以从其中发现 Resource Version 的来源。&lt;/p>
&lt;pre>&lt;code>func (s *store) Get(ctx context.Context, key string, resourceVersion string, out runtime.Object, ignoreNotFound bool) error {
key = path.Join(s.pathPrefix, key)
startTime := time.Now()
getResp, err := s.client.KV.Get(ctx, key, s.getOps...)
metrics.RecordEtcdRequestLatency(&amp;quot;get&amp;quot;, getTypeName(out), startTime)
if err != nil {
return err
}
if len(getResp.Kvs) == 0 {
if ignoreNotFound {
return runtime.SetZeroValue(out)
}
return storage.NewKeyNotFoundError(key, 0)
}
kv := getResp.Kvs[0]
data, _, err := s.transformer.TransformFromStorage(kv.Value, authenticatedDataString(key))
if err != nil {
return storage.NewInternalError(err.Error())
}
return decode(s.codec, s.versioner, data, out, kv.ModRevision)
}
&lt;/code>&lt;/pre>
&lt;p>从代码中我们可以看到，Resource Version 使用的是 ETCD 的 ModRevision。&lt;/p>
&lt;p>ResourceVersion 字段在 Kubernetes 中除了用在上述并发控制机制外，还用在 Kubernetes 的 list-watch 机制中。Client 端的 list-watch 分为两个步骤，先 list 取回所有对象，再以增量的方式 watch 后续对象。Client 端在 list 取回所有对象后，将会把最新对象的 ResourceVersion 作为下一步 watch 操作的起点参数，也即 Kube-Apiserver 以收到的 ResourceVersion 为起始点返回后续数据，保证了 list-watch 中数据的连续性与完整性。&lt;/p>
&lt;h4 id="etcd-version">ETCD Version&lt;/h4>
&lt;p>ETCD 共四种_version_&lt;/p>
&lt;ul>
&lt;li>Revision&lt;/li>
&lt;li>ModRevision&lt;/li>
&lt;li>Version&lt;/li>
&lt;li>CreateRevision&lt;/li>
&lt;/ul>
&lt;p>关于他们的区别可以看下这个&lt;a href="https://links.jianshu.com/go?to=https%3A%2F%2Fgithub.com%2Fetcd-io%2Fetcd%2Fissues%2F6518">issue：what is different about Revision, ModRevision and Version?&lt;/a>&lt;/p>
&lt;blockquote>
&lt;p>the Revision is the current revision of etcd. It is incremented every time the v3 backed is modified (e.g., Put, Delete, Txn). ModRevision is the etcd revision of the last update to a key. Version is the number of times the key has been modified since it was created. Get(&amp;hellip;, WithRev(rev)) will perform a Get as if the etcd store is still at revision rev.&lt;/p>
&lt;/blockquote>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>字段&lt;/th>
&lt;th>作用范围&lt;/th>
&lt;th>说明&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>Version&lt;/td>
&lt;td>Key&lt;/td>
&lt;td>单个 Key 的修改次数，单调递增&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Revision&lt;/td>
&lt;td>全局&lt;/td>
&lt;td>Key 在集群中的全局版本号，全局唯一&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>ModRevison&lt;/td>
&lt;td>Key&lt;/td>
&lt;td>Key 最后一次修改时的 Revision&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>CreateRevision&lt;/td>
&lt;td>全局&lt;/td>
&lt;td>Key 创建时的 Revision&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>《&lt;a href="https://links.jianshu.com/go?to=https%3A%2F%2Fblog.dianduidian.com%2Fpost%2Fkubernetes-resourceversion%25E5%258E%259F%25E7%2590%2586%25E5%2588%2586%25E6%259E%2590%2F">Kubernetes 对象版本控制 ResourceVersion 和 Generation 原理分析&lt;/a>》中详细讲解了 Etcd Version 的变化过程。&lt;/p>
&lt;h3 id="generation">Generation&lt;/h3>
&lt;p>Generation 表示对象元配置信息（包括 spec 和 annotations）变更的次数。&lt;/p>
&lt;pre>&lt;code>apiVersion: apps/v1
kind: Deployment
metadata:
annotations:
deployment.kubernetes.io/revision: &amp;quot;1&amp;quot;
creationTimestamp: &amp;quot;2022-03-29T06:40:30Z&amp;quot;
generation: 2
&lt;/code>&lt;/pre>
&lt;p>以 Deployment 为例，当某个 Deployment 对象被创建时，其 Generation 被设置为 1：&lt;/p>
&lt;pre>&lt;code>func (deploymentStrategy) PrepareForCreate(ctx context.Context, obj runtime.Object) {
deployment := obj.(*apps.Deployment)
deployment.Status = apps.DeploymentStatus{}
deployment.Generation = 1
pod.DropDisabledTemplateFields(&amp;amp;deployment.Spec.Template, nil)
}
&lt;/code>&lt;/pre>
&lt;p>每次当该 Deployment 对象的 spec 或 annotations 发生变化时，其 Generation + 1：&lt;/p>
&lt;pre>&lt;code>func (deploymentStrategy) PrepareForUpdate(ctx context.Context, obj, old runtime.Object) {
newDeployment := obj.(*apps.Deployment)
oldDeployment := old.(*apps.Deployment)
newDeployment.Status = oldDeployment.Status
pod.DropDisabledTemplateFields(&amp;amp;newDeployment.Spec.Template, &amp;amp;oldDeployment.Spec.Template)
// Spec updates bump the generation so that we can distinguish between
// scaling events and template changes, annotation updates bump the generation
// because annotations are copied from deployments to their replica sets.
// 当 spec 或 annotations 发生变化时，其 Generation + 1
if !apiequality.Semantic.DeepEqual(newDeployment.Spec, oldDeployment.Spec) ||
!apiequality.Semantic.DeepEqual(newDeployment.Annotations, oldDeployment.Annotations) {
newDeployment.Generation = oldDeployment.Generation + 1
}
}
&lt;/code>&lt;/pre>
&lt;h2 id="资源变更">资源变更&lt;/h2>
&lt;h3 id="create">Create&lt;/h3>
&lt;p>Kubernetes 对象的创建流程如下：&lt;/p>
&lt;ol>
&lt;li>
&lt;p>判断对象的 resourceVersion 是否合法，如果 resourceVersion != 0，则抛出错误&lt;/p>
&lt;/li>
&lt;li>
&lt;p>对待处理对象做一些预处理：把 resourceVersion 和 selfLink 置为空&lt;/p>
&lt;/li>
&lt;li>
&lt;p>对待处理对象进行编码，转换成二进制，进而转换成可被 ETCD 接受的格式&lt;/p>
&lt;/li>
&lt;li>
&lt;p>判断 key 是否已存在，如果不存在，则存入 ETCD，否则返回错误信息&lt;/p>
&lt;/li>
&lt;li>
&lt;p>记录执行耗时&lt;/p>
&lt;/li>
&lt;li>
&lt;p>返回存储好的数据，并将 ETCD 中更新后的 Reversion 设置为 resourceVersion&lt;/p>
&lt;p>func (s *store) Create(ctx context.Context, key string, obj, out runtime.Object, ttl uint64) error {&lt;/p>
&lt;pre>&lt;code> if version, err := s.versioner.ObjectResourceVersion(obj); err == nil &amp;amp;&amp;amp; version != 0 {
return errors.New(&amp;quot;resourceVersion should not be set on objects to be created&amp;quot;)
}
if err := s.versioner.PrepareObjectForStorage(obj); err != nil {
return fmt.Errorf(&amp;quot;PrepareObjectForStorage failed: %v&amp;quot;, err)
}
data, err := runtime.Encode(s.codec, obj)
if err != nil {
return err
}
key = path.Join(s.pathPrefix, key)
opts, err := s.ttlOpts(ctx, int64(ttl))
if err != nil {
return err
}
newData, err := s.transformer.TransformToStorage(data, authenticatedDataString(key))
if err != nil {
return storage.NewInternalError(err.Error())
}
startTime := time.Now()
txnResp, err := s.client.KV.Txn(ctx).If(
notFound(key),
).Then(
clientv3.OpPut(key, string(newData), opts...),
).Commit()
metrics.RecordEtcdRequestLatency(&amp;quot;create&amp;quot;, getTypeName(obj), startTime)
if err != nil {
return err
}
if !txnResp.Succeeded {
return storage.NewKeyExistsError(key, 0)
}
if out != nil {
putResp := txnResp.Responses[0].GetResponsePut()
return decode(s.codec, s.versioner, data, out, putResp.Header.Revision)
}
return nil
&lt;/code>&lt;/pre>
&lt;p>}&lt;/p>
&lt;/li>
&lt;/ol>
&lt;h3 id="update">Update&lt;/h3>
&lt;p>Kubernetes 实现了 Update 和 Patch 两个对象更新的方法，两者提供不同的更新操作方式，但冲突判断机制是相同的。&lt;/p>
&lt;p>对于 Update，客户端更新请求中包含的是整个 obj 对象，服务器端将对比该请求中的 obj 对象和服务器端最新 obj 对象的 ResourceVersion 值。如果相等，则表明未发生冲突，将成功更新整个对象。反之若不相等则返回 409 冲突错误， Kube-Apiserver 中冲突判断的代码片段如下。
Kubernetes 对象的更新流程如下：&lt;/p>
&lt;ol>
&lt;li>获取当前更新请求中 obj 对象的 ResourceVersion 值，及服务器端最新 obj 对象 (existing) 的 ResourceVersion 值&lt;/li>
&lt;li>如果当前更新请求中 bj 对象的 ResourceVersion 值等于 0，即客户端未设置该值，则判断是否要硬改写 (AllowUnconditionalUpdate)，如配置为硬改写策略，将直接更新 obj 对象&lt;/li>
&lt;li>如果当前更新请求中 obj 对象的 ResourceVersion 值不等于 0，则判断两个 ResourceVersion 值是否一致，不一致返回冲突错误 (OptimisticLockErrorMsg)&lt;/li>
&lt;/ol>
&lt;p>[图片上传失败&amp;hellip;(image-67a94f-1648537253951)]&lt;/p>
&lt;p>上图展示了多个用户同时 update 某一个资源对象时会发生的事情。而如果如果发生了 Conflict 冲突，对于 User A 而言应该做的就是做一次重试，再次获取到最新版本的对象，修改后重新提交 update，因此：&lt;/p>
&lt;ol>
&lt;li>用户修改 YAML 后提交 update 失败，是因为 YAML 文件中没有包含 resourceVersion 字段。对于 update 请求而言，应该取出当前 K8s 中的对象做修改后提交；&lt;/li>
&lt;li>如果两个用户同时对一个资源对象做 update，不管操作的是对象中同一个字段还是不同字段，都存在并发控制的机制确保两个用户的 update 请求不会发生覆盖。&lt;/li>
&lt;/ol>
&lt;p>Update 流程相关代码实现如下：&lt;/p>
&lt;pre>&lt;code>func (s *store) GuaranteedUpdate(
ctx context.Context, key string, out runtime.Object, ignoreNotFound bool,
preconditions *storage.Preconditions, tryUpdate storage.UpdateFunc, suggestion ...runtime.Object) error {
trace := utiltrace.New(&amp;quot;GuaranteedUpdate etcd3&amp;quot;, utiltrace.Field{&amp;quot;type&amp;quot;, getTypeName(out)})
defer trace.LogIfLong(500 * time.Millisecond)
v, err := conversion.EnforcePtr(out)
if err != nil {
return fmt.Errorf(&amp;quot;unable to convert output object to pointer: %v&amp;quot;, err)
}
key = path.Join(s.pathPrefix, key)
getCurrentState := func() (*objState, error) {
startTime := time.Now()
getResp, err := s.client.KV.Get(ctx, key, s.getOps...)
metrics.RecordEtcdRequestLatency(&amp;quot;get&amp;quot;, getTypeName(out), startTime)
if err != nil {
return nil, err
}
return s.getState(getResp, key, v, ignoreNotFound)
}
var origState *objState
var mustCheckData bool
if len(suggestion) == 1 &amp;amp;&amp;amp; suggestion[0] != nil {
origState, err = s.getStateFromObject(suggestion[0])
if err != nil {
return err
}
mustCheckData = true
} else {
origState, err = getCurrentState()
if err != nil {
return err
}
}
trace.Step(&amp;quot;initial value restored&amp;quot;)
transformContext := authenticatedDataString(key)
for {
if err := preconditions.Check(key, origState.obj); err != nil {
if !mustCheckData {
return err
}
origState, err = getCurrentState()
if err != nil {
return err
}
mustCheckData = false
continue
}
ret, ttl, err := s.updateState(origState, tryUpdate)
if err != nil {
if !mustCheckData {
return err
}
origState, err = getCurrentState()
if err != nil {
return err
}
mustCheckData = false
continue
}
data, err := runtime.Encode(s.codec, ret)
if err != nil {
return err
}
if !origState.stale &amp;amp;&amp;amp; bytes.Equal(data, origState.data) {
if mustCheckData {
origState, err = getCurrentState()
if err != nil {
return err
}
mustCheckData = false
if !bytes.Equal(data, origState.data) {
continue
}
}
if !origState.stale {
return decode(s.codec, s.versioner, origState.data, out, origState.rev)
}
}
newData, err := s.transformer.TransformToStorage(data, transformContext)
if err != nil {
return storage.NewInternalError(err.Error())
}
opts, err := s.ttlOpts(ctx, int64(ttl))
if err != nil {
return err
}
trace.Step(&amp;quot;Transaction prepared&amp;quot;)
startTime := time.Now()
txnResp, err := s.client.KV.Txn(ctx).If(
clientv3.Compare(clientv3.ModRevision(key), &amp;quot;=&amp;quot;, origState.rev),
).Then(
clientv3.OpPut(key, string(newData), opts...),
).Else(
clientv3.OpGet(key),
).Commit()
metrics.RecordEtcdRequestLatency(&amp;quot;update&amp;quot;, getTypeName(out), startTime)
if err != nil {
return err
}
trace.Step(&amp;quot;Transaction committed&amp;quot;)
if !txnResp.Succeeded {
getResp := (*clientv3.GetResponse)(txnResp.Responses[0].GetResponseRange())
klog.V(4).Infof(&amp;quot;GuaranteedUpdate of %s failed because of a conflict, going to retry&amp;quot;, key)
origState, err = s.getState(getResp, key, v, ignoreNotFound)
if err != nil {
return err
}
trace.Step(&amp;quot;Retry value restored&amp;quot;)
mustCheckData = false
continue
}
putResp := txnResp.Responses[0].GetResponsePut()
return decode(s.codec, s.versioner, data, out, putResp.Header.Revision)
}
}
&lt;/code>&lt;/pre>
&lt;h3 id="patch">Patch&lt;/h3>
&lt;p>相比 Update 请求包含整个 obj 对象，Patch 请求实现了更细粒度的对象更新操作，其请求中只包含需要更新的字段。例如要更新 pod 中 container 的镜像，可使用如下命令：&lt;/p>
&lt;pre>&lt;code>kubectl patch pod my-pod -p '{&amp;quot;spec&amp;quot;:{&amp;quot;containers&amp;quot;:[{&amp;quot;name&amp;quot;:&amp;quot;my-container&amp;quot;,&amp;quot;image&amp;quot;:&amp;quot;new-image&amp;quot;}]}}'
&lt;/code>&lt;/pre>
&lt;p>服务器端只收到以上的 patch 信息，然后通过如下代码将该 patch 更新到 Etcd 中。&lt;/p>
&lt;p>Kubernetes 对象的 Patch 更新流程如下：&lt;/p>
&lt;ol>
&lt;li>
&lt;p>首先判断 patch 的类型，根据类型选择相应的 mechanism&lt;/p>
&lt;/li>
&lt;li>
&lt;p>利用 DefaultUpdatedObjectInfo 方法将 applyPatch (应用 Patch 的方法)添加到 admission chain 的头部&lt;/p>
&lt;/li>
&lt;li>
&lt;p>最终还是调用上述 Update 方法执行更新操作&lt;/p>
&lt;p>func (p *patcher) patchResource(ctx context.Context, scope *RequestScope) (runtime.Object, bool, error) {
p.namespace = request.NamespaceValue(ctx)
switch p.patchType {
case types.JSONPatchType, types.MergePatchType:
p.mechanism = &amp;amp;jsonPatcher{
patcher: p,
fieldManager: scope.FieldManager,
}
case types.StrategicMergePatchType:
schemaReferenceObj, err := p.unsafeConvertor.ConvertToVersion(p.restPatcher.New(), p.kind.GroupVersion())
if err != nil {
return nil, false, err
}
p.mechanism = &amp;amp;smpPatcher{
patcher: p,
schemaReferenceObj: schemaReferenceObj,
fieldManager: scope.FieldManager,
}&lt;/p>
&lt;pre>&lt;code> case types.ApplyPatchType:
p.mechanism = &amp;amp;applyPatcher{
fieldManager: scope.FieldManager,
patch: p.patchBytes,
options: p.options,
creater: p.creater,
kind: p.kind,
}
p.forceAllowCreate = true
default:
return nil, false, fmt.Errorf(&amp;quot;%v: unimplemented patch type&amp;quot;, p.patchType)
}
wasCreated := false
p.updatedObjectInfo = rest.DefaultUpdatedObjectInfo(nil, p.applyPatch, p.applyAdmission)
result, err := finishRequest(p.timeout, func() (runtime.Object, error) {
options := patchToUpdateOptions(p.options)
updateObject, created, updateErr := p.restPatcher.Update(ctx, p.name, p.updatedObjectInfo, p.createValidation, p.updateValidation, p.forceAllowCreate, options)
wasCreated = created
return updateObject, updateErr
})
return result, wasCreated, err
&lt;/code>&lt;/pre>
&lt;p>}&lt;/p>
&lt;/li>
&lt;/ol>
&lt;p>相比 Update，Patch 的主要优势在于客户端&lt;strong>不必提供全量的 obj 对象信息&lt;/strong>。客户端只需以 patch 的方式提交要修改的字段信息，服务器端会将该 patch 数据应用到最新获取的 obj 中。省略了 Client 端获取、修改再提交全量 obj 的步骤，降低了数据被修改的风险，更大大减小了冲突概率。 由于 Patch 方法在传输效率及冲突概率上都占有绝对优势，目前 Kubernetes 中几乎所有更新操作都采用了 Patch 方法，我们在编写代码时也应该注意使用 Patch 方法。&lt;/p>
&lt;p>不过，patch 的复杂点在于，目前 K8s 提供了 4 种 patch 策略：json patch、merge patch、strategic merge patch、apply patch(server-side apply)。通过 kubectl patch -h 命令我们也可以看到这个策略选项（默认采用 strategic)&lt;/p>
&lt;h4 id="json-patch">json patch&lt;/h4>
&lt;p>在 RFC6902 协议的定义中，JSON Patch 是执行在资源对象上的一系列操作，如下所示：&lt;/p>
&lt;pre>&lt;code>{
&amp;quot;op&amp;quot;: &amp;quot;add&amp;quot;,
&amp;quot;path&amp;quot;: &amp;quot;/spec/containers/0/image&amp;quot;,
&amp;quot;value&amp;quot;: &amp;quot;busybox:latest&amp;quot;
}
&lt;/code>&lt;/pre>
&lt;ul>
&lt;li>op: 表示对资源对象的操作，主要有以下六种操作。
&lt;ol>
&lt;li>add&lt;/li>
&lt;li>replace&lt;/li>
&lt;li>remove&lt;/li>
&lt;li>move&lt;/li>
&lt;li>copy&lt;/li>
&lt;li>test&lt;/li>
&lt;/ol>
&lt;/li>
&lt;li>path: 表示被作资源对象的路径. 例如/spec/containers/0/image 表示要操作的对象是“spec.containers[0].image”&lt;/li>
&lt;li>value: 表示预修改的值。&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>新增容器&lt;/strong>：&lt;/p>
&lt;pre>&lt;code>kubectl patch deployment/foo --type='json' -p \
'[{&amp;quot;op&amp;quot;:&amp;quot;add&amp;quot;,&amp;quot;path&amp;quot;:&amp;quot;/spec/template/spec/containers/1&amp;quot;,&amp;quot;value&amp;quot;:{&amp;quot;name&amp;quot;:&amp;quot;nginx&amp;quot;,&amp;quot;image&amp;quot;:&amp;quot;nginx:alpine&amp;quot;}}]'
&lt;/code>&lt;/pre>
&lt;p>&lt;strong>修改已有的容器镜像&lt;/strong>:&lt;/p>
&lt;pre>&lt;code>kubectl patch deployment/foo --type='json' -p \
'[{&amp;quot;op&amp;quot;:&amp;quot;replace&amp;quot;,&amp;quot;path&amp;quot;:&amp;quot;/spec/template/spec/containers/0/image&amp;quot;,&amp;quot;value&amp;quot;:&amp;quot;app-image:v2&amp;quot;}]'
&lt;/code>&lt;/pre>
&lt;p>根据 http patch 原子性的定义，当某个 op(操作)不成功,则整个 patch 都不成功。&lt;/p>
&lt;h4 id="merge-patch">merge patch&lt;/h4>
&lt;p>merge patch 必须包含一个对资源对象的部分描述，json 对象。该 json 对象被提交到服务端，并和服务端的当前对象进行合并，从而创建新的对象。完整的替换列表，也就是说，新的列表定义会替换原有的定义。&lt;/p>
&lt;p>例如(设置 label)：&lt;/p>
&lt;pre>&lt;code>kubectl patch deployment/foo --type='merge' -p '{&amp;quot;metadata&amp;quot;:{&amp;quot;labels&amp;quot;:{&amp;quot;test-key&amp;quot;:&amp;quot;foo&amp;quot;}}}'
&lt;/code>&lt;/pre>
&lt;p>使用 merge patch 也有如下限制：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>如果 value 的值为 null,表示要删除对应的键，因此我们无法将 value 的值设置为 null, 如下，表示删除键 f&lt;/p>
&lt;p>{
&amp;ldquo;a&amp;rdquo;:&amp;ldquo;z&amp;rdquo;,
&amp;ldquo;c&amp;rdquo;: {
&amp;ldquo;f&amp;rdquo;: null
}
}&lt;/p>
&lt;/li>
&lt;li>
&lt;p>merge patch 无法单独更新一个列表(数组)中的某个元素，因此不管我们是要在 containers 里新增容器、还是修改已有容器的 image、env 等字段，都要用整个 containers 列表(数组)来提交 patch：&lt;/p>
&lt;p>kubectl patch deployment/foo &amp;ndash;type=&amp;lsquo;merge&amp;rsquo; -p &lt;br>
&amp;lsquo;{&amp;ldquo;spec&amp;rdquo;:{&amp;ldquo;template&amp;rdquo;:{&amp;ldquo;spec&amp;rdquo;:{&amp;ldquo;containers&amp;rdquo;:[{&amp;ldquo;name&amp;rdquo;:&amp;ldquo;app&amp;rdquo;,&amp;ldquo;image&amp;rdquo;:&amp;ldquo;app-image:v2&amp;rdquo;},{&amp;ldquo;name&amp;rdquo;:&amp;ldquo;nginx&amp;rdquo;,&amp;ldquo;image&amp;rdquo;:&amp;ldquo;nginx:alpline&amp;rdquo;}]}}}}&amp;rsquo;&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h4 id="strategic-merge-patch">strategic merge patch&lt;/h4>
&lt;p>参考《&lt;a href="https://links.jianshu.com/go?to=https%3A%2F%2Fwww.kubeclub.cn%2Fkubernetes%2F122.html">kubernetes 中 update 与 patch 的区别&lt;/a>》&lt;/p>
&lt;h4 id="apply-patch">apply patch&lt;/h4>
&lt;p>参考《&lt;a href="https://links.jianshu.com/go?to=https%3A%2F%2Fwww.kubeclub.cn%2Fkubernetes%2F122.html">kubernetes 中 update 与 patch 的区别&lt;/a>》&lt;/p>
&lt;h3 id="delete">Delete&lt;/h3>
&lt;p>Kubernetes 对象的删除流程如下：&lt;/p>
&lt;ol>
&lt;li>判断目标对象类型是否正确：是否为指针类型，是否不为 nil&lt;/li>
&lt;li>删除之前，先从 ETCD 中获取对应的数据，并判断该删除操作是否满足前置条件&lt;/li>
&lt;li>通过比对 ModVersion 判断这段时间内目标对象是否被其他进程/线程修改，如果未被修改，则执行删除操作；否则执行 Get 操作，删除失败，打印错误信息，并重新尝试删除&lt;/li>
&lt;li>删除成功，返回被删除的数据&lt;/li>
&lt;/ol>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">func&lt;/span> (&lt;span style="color:#a6e22e">s&lt;/span> &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">store&lt;/span>) &lt;span style="color:#a6e22e">Delete&lt;/span>(&lt;span style="color:#a6e22e">ctx&lt;/span> &lt;span style="color:#a6e22e">context&lt;/span>.&lt;span style="color:#a6e22e">Context&lt;/span>, &lt;span style="color:#a6e22e">key&lt;/span> &lt;span style="color:#66d9ef">string&lt;/span>, &lt;span style="color:#a6e22e">out&lt;/span> &lt;span style="color:#a6e22e">runtime&lt;/span>.&lt;span style="color:#a6e22e">Object&lt;/span>, &lt;span style="color:#a6e22e">preconditions&lt;/span> &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">storage&lt;/span>.&lt;span style="color:#a6e22e">Preconditions&lt;/span>, &lt;span style="color:#a6e22e">validateDeletion&lt;/span> &lt;span style="color:#a6e22e">storage&lt;/span>.&lt;span style="color:#a6e22e">ValidateObjectFunc&lt;/span>) &lt;span style="color:#66d9ef">error&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">v&lt;/span>, &lt;span style="color:#a6e22e">err&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">conversion&lt;/span>.&lt;span style="color:#a6e22e">EnforcePtr&lt;/span>(&lt;span style="color:#a6e22e">out&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> &lt;span style="color:#a6e22e">err&lt;/span> &lt;span style="color:#f92672">!=&lt;/span> &lt;span style="color:#66d9ef">nil&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#a6e22e">fmt&lt;/span>.&lt;span style="color:#a6e22e">Errorf&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;unable to convert output object to pointer: %v&amp;#34;&lt;/span>, &lt;span style="color:#a6e22e">err&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">key&lt;/span> = &lt;span style="color:#a6e22e">path&lt;/span>.&lt;span style="color:#a6e22e">Join&lt;/span>(&lt;span style="color:#a6e22e">s&lt;/span>.&lt;span style="color:#a6e22e">pathPrefix&lt;/span>, &lt;span style="color:#a6e22e">key&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#a6e22e">s&lt;/span>.&lt;span style="color:#a6e22e">conditionalDelete&lt;/span>(&lt;span style="color:#a6e22e">ctx&lt;/span>, &lt;span style="color:#a6e22e">key&lt;/span>, &lt;span style="color:#a6e22e">out&lt;/span>, &lt;span style="color:#a6e22e">v&lt;/span>, &lt;span style="color:#a6e22e">preconditions&lt;/span>, &lt;span style="color:#a6e22e">validateDeletion&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">func&lt;/span> (&lt;span style="color:#a6e22e">s&lt;/span> &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">store&lt;/span>) &lt;span style="color:#a6e22e">conditionalDelete&lt;/span>(&lt;span style="color:#a6e22e">ctx&lt;/span> &lt;span style="color:#a6e22e">context&lt;/span>.&lt;span style="color:#a6e22e">Context&lt;/span>, &lt;span style="color:#a6e22e">key&lt;/span> &lt;span style="color:#66d9ef">string&lt;/span>, &lt;span style="color:#a6e22e">out&lt;/span> &lt;span style="color:#a6e22e">runtime&lt;/span>.&lt;span style="color:#a6e22e">Object&lt;/span>, &lt;span style="color:#a6e22e">v&lt;/span> &lt;span style="color:#a6e22e">reflect&lt;/span>.&lt;span style="color:#a6e22e">Value&lt;/span>, &lt;span style="color:#a6e22e">preconditions&lt;/span> &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">storage&lt;/span>.&lt;span style="color:#a6e22e">Preconditions&lt;/span>, &lt;span style="color:#a6e22e">validateDeletion&lt;/span> &lt;span style="color:#a6e22e">storage&lt;/span>.&lt;span style="color:#a6e22e">ValidateObjectFunc&lt;/span>) &lt;span style="color:#66d9ef">error&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">startTime&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">time&lt;/span>.&lt;span style="color:#a6e22e">Now&lt;/span>()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">getResp&lt;/span>, &lt;span style="color:#a6e22e">err&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">s&lt;/span>.&lt;span style="color:#a6e22e">client&lt;/span>.&lt;span style="color:#a6e22e">KV&lt;/span>.&lt;span style="color:#a6e22e">Get&lt;/span>(&lt;span style="color:#a6e22e">ctx&lt;/span>, &lt;span style="color:#a6e22e">key&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">metrics&lt;/span>.&lt;span style="color:#a6e22e">RecordEtcdRequestLatency&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;get&amp;#34;&lt;/span>, &lt;span style="color:#a6e22e">getTypeName&lt;/span>(&lt;span style="color:#a6e22e">out&lt;/span>), &lt;span style="color:#a6e22e">startTime&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> &lt;span style="color:#a6e22e">err&lt;/span> &lt;span style="color:#f92672">!=&lt;/span> &lt;span style="color:#66d9ef">nil&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#a6e22e">err&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">origState&lt;/span>, &lt;span style="color:#a6e22e">err&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">s&lt;/span>.&lt;span style="color:#a6e22e">getState&lt;/span>(&lt;span style="color:#a6e22e">getResp&lt;/span>, &lt;span style="color:#a6e22e">key&lt;/span>, &lt;span style="color:#a6e22e">v&lt;/span>, &lt;span style="color:#66d9ef">false&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> &lt;span style="color:#a6e22e">err&lt;/span> &lt;span style="color:#f92672">!=&lt;/span> &lt;span style="color:#66d9ef">nil&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#a6e22e">err&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> &lt;span style="color:#a6e22e">preconditions&lt;/span> &lt;span style="color:#f92672">!=&lt;/span> &lt;span style="color:#66d9ef">nil&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> &lt;span style="color:#a6e22e">err&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">preconditions&lt;/span>.&lt;span style="color:#a6e22e">Check&lt;/span>(&lt;span style="color:#a6e22e">key&lt;/span>, &lt;span style="color:#a6e22e">origState&lt;/span>.&lt;span style="color:#a6e22e">obj&lt;/span>); &lt;span style="color:#a6e22e">err&lt;/span> &lt;span style="color:#f92672">!=&lt;/span> &lt;span style="color:#66d9ef">nil&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#a6e22e">err&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> &lt;span style="color:#a6e22e">err&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">validateDeletion&lt;/span>(&lt;span style="color:#a6e22e">ctx&lt;/span>, &lt;span style="color:#a6e22e">origState&lt;/span>.&lt;span style="color:#a6e22e">obj&lt;/span>); &lt;span style="color:#a6e22e">err&lt;/span> &lt;span style="color:#f92672">!=&lt;/span> &lt;span style="color:#66d9ef">nil&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#a6e22e">err&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">startTime&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">time&lt;/span>.&lt;span style="color:#a6e22e">Now&lt;/span>()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">txnResp&lt;/span>, &lt;span style="color:#a6e22e">err&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">s&lt;/span>.&lt;span style="color:#a6e22e">client&lt;/span>.&lt;span style="color:#a6e22e">KV&lt;/span>.&lt;span style="color:#a6e22e">Txn&lt;/span>(&lt;span style="color:#a6e22e">ctx&lt;/span>).&lt;span style="color:#a6e22e">If&lt;/span>(
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">clientv3&lt;/span>.&lt;span style="color:#a6e22e">Compare&lt;/span>(&lt;span style="color:#a6e22e">clientv3&lt;/span>.&lt;span style="color:#a6e22e">ModRevision&lt;/span>(&lt;span style="color:#a6e22e">key&lt;/span>), &lt;span style="color:#e6db74">&amp;#34;=&amp;#34;&lt;/span>, &lt;span style="color:#a6e22e">origState&lt;/span>.&lt;span style="color:#a6e22e">rev&lt;/span>),
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ).&lt;span style="color:#a6e22e">Then&lt;/span>(
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">clientv3&lt;/span>.&lt;span style="color:#a6e22e">OpDelete&lt;/span>(&lt;span style="color:#a6e22e">key&lt;/span>),
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ).&lt;span style="color:#a6e22e">Else&lt;/span>(
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">clientv3&lt;/span>.&lt;span style="color:#a6e22e">OpGet&lt;/span>(&lt;span style="color:#a6e22e">key&lt;/span>),
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ).&lt;span style="color:#a6e22e">Commit&lt;/span>()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">metrics&lt;/span>.&lt;span style="color:#a6e22e">RecordEtcdRequestLatency&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;delete&amp;#34;&lt;/span>, &lt;span style="color:#a6e22e">getTypeName&lt;/span>(&lt;span style="color:#a6e22e">out&lt;/span>), &lt;span style="color:#a6e22e">startTime&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> &lt;span style="color:#a6e22e">err&lt;/span> &lt;span style="color:#f92672">!=&lt;/span> &lt;span style="color:#66d9ef">nil&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#a6e22e">err&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> !&lt;span style="color:#a6e22e">txnResp&lt;/span>.&lt;span style="color:#a6e22e">Succeeded&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">getResp&lt;/span> = (&lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">clientv3&lt;/span>.&lt;span style="color:#a6e22e">GetResponse&lt;/span>)(&lt;span style="color:#a6e22e">txnResp&lt;/span>.&lt;span style="color:#a6e22e">Responses&lt;/span>[&lt;span style="color:#ae81ff">0&lt;/span>].&lt;span style="color:#a6e22e">GetResponseRange&lt;/span>())
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">klog&lt;/span>.&lt;span style="color:#a6e22e">V&lt;/span>(&lt;span style="color:#ae81ff">4&lt;/span>).&lt;span style="color:#a6e22e">Infof&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;deletion of %s failed because of a conflict, going to retry&amp;#34;&lt;/span>, &lt;span style="color:#a6e22e">key&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">continue&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#a6e22e">decode&lt;/span>(&lt;span style="color:#a6e22e">s&lt;/span>.&lt;span style="color:#a6e22e">codec&lt;/span>, &lt;span style="color:#a6e22e">s&lt;/span>.&lt;span style="color:#a6e22e">versioner&lt;/span>, &lt;span style="color:#a6e22e">origState&lt;/span>.&lt;span style="color:#a6e22e">data&lt;/span>, &lt;span style="color:#a6e22e">out&lt;/span>, &lt;span style="color:#a6e22e">origState&lt;/span>.&lt;span style="color:#a6e22e">rev&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="参考文档">参考文档&lt;/h2>
&lt;p>&lt;a href="https://links.jianshu.com/go?to=https%3A%2F%2Fwww.cnblogs.com%2Fhuaweiyuncce%2Fp%2F10001148.html">Kubernetes 并发控制与数据一致性的实现原理&lt;/a>&lt;/p>
&lt;p>&lt;a href="https://links.jianshu.com/go?to=https%3A%2F%2Fwww.kubeclub.cn%2Fkubernetes%2F122.html">kubernetes 中 update 与 patch 的区别&lt;/a>&lt;/p>
&lt;p>&lt;a href="https://links.jianshu.com/go?to=https%3A%2F%2Fblog.dianduidian.com%2Fpost%2Fkubernetes-resourceversion%25E5%258E%259F%25E7%2590%2586%25E5%2588%2586%25E6%259E%2590%2F">Kubernetes 对象版本控制 ResourceVersion 和 Generation 原理分析&lt;/a>&lt;/p>
&lt;h3 id="heading">&lt;/h3></description></item></channel></rss>