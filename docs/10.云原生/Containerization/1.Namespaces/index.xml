<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>断念梦的站点 – 1.Namespaces</title><link>https://desistdaydream.github.io/docs/10.%E4%BA%91%E5%8E%9F%E7%94%9F/Containerization/1.Namespaces/</link><description>Recent content in 1.Namespaces on 断念梦的站点</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><atom:link href="https://desistdaydream.github.io/docs/10.%E4%BA%91%E5%8E%9F%E7%94%9F/Containerization/1.Namespaces/index.xml" rel="self" type="application/rss+xml"/><item><title>Docs: 1.Namespaces</title><link>https://desistdaydream.github.io/docs/10.%E4%BA%91%E5%8E%9F%E7%94%9F/Containerization/1.Namespaces/1.Namespaces/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/10.%E4%BA%91%E5%8E%9F%E7%94%9F/Containerization/1.Namespaces/1.Namespaces/</guid><description>
&lt;h1 id="概述">概述&lt;a class="td-heading-self-link" href="#%e6%a6%82%e8%bf%b0" aria-label="Heading self-link">&lt;/a>&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Linux_namespaces">Wiki, Linux_namespaces&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://segmentfault.com/a/1190000009732550">思否，Linux Namespace 和 Cgroup&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.junmajinlong.com/virtual/namespace">骏马金龙博客，Linux namespace&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://mp.weixin.qq.com/s/rhO5GUuWycRiFxdYaV-yiQ">公众号，YP 小站-Namespace 机制详解&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://mp.weixin.qq.com/s/lscMpc5BWAEzjgYw6H0wBw">公众号，开发内功修炼-Linux 网络名称空间&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://mp.weixin.qq.com/s/jJ9peydbNSd6Fv5bsJR3yA">公众号，MoeLove-彻底搞懂容器技术的基石：namespace&lt;/a>
&lt;ul>
&lt;li>&lt;a href="https://mp.weixin.qq.com/s/o5nZZzOTNXOFjv2aaIZ6OA">https://mp.weixin.qq.com/s/o5nZZzOTNXOFjv2aaIZ6OA&lt;/a>(下)&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>Linux Namespaces(Linux 名称空间) 是 Linux 内核的一个特性，Namespaces 可以对内核资源进行划分，使得一组进程看到一组资源，而另一组进程看到一组不同的资源。&lt;/p>
&lt;blockquote>
&lt;p>这里的资源包括 进程 ID、主机名、用户 ID、网络 等等。&lt;/p>
&lt;/blockquote>
&lt;p>如果把 Linux 操作系统比作一个大房子，那名称空间指的就是这个房子中的一个个房间，住在每个房间里的人都自以为独享了整个房子的资源，但其实大家仅仅只是在共享的基础之上互相隔离，共享指的是共享全局的资源，而隔离指的是局部上彼此保持隔离，因而名称空间的本质就是指：一种在空间上隔离的概念，当下盛行的许多容器虚拟化技术（典型代表如 LXC、Docker）就是基于 Linux 名称空间的概念而来的。&lt;/p>
&lt;p>很早以前的 Unix 有一个叫 &lt;a href="https://desistdaydream.github.io/docs/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Kernel/Process/Chroot.md">Chroot&lt;/a> 的系统调用（通过修改根目录把用户 &lt;strong>jail(监狱)&lt;/strong> 到一个特定目录下），Chroot 提供了一种简单的隔离模式(隔离目录)：Chroot 内部的文件系统无法访问外部的内容。Linux Namespace 就是基于 Chroot 的概念扩展而来，提供了对系统下更多资源的隔离机制。&lt;/p>
&lt;p>操作系统通过虚拟内存技术，使得每个用户进程都认为自己拥有所有的物理内存，这是操作系统对内存的虚拟化。操作系统通过分时调度系统，每个进程都能被【公平地】调度执行，即每个进程都能获取到 CPU，使得每个进程都认为自己在进程活动期间拥有所有的 CPU 时间，这是操作系统对 CPU 的虚拟化。&lt;/p>
&lt;p>从这两种虚拟化方式可推知，当使用某种虚拟化技术去管理进程时，进程会认为自己拥有某种物理资源的全部。&lt;/p>
&lt;p>虚拟内存和分时系统均是对物理资源进行虚拟化，其实操作系统中还有很多非物理资源，比如用户权限系统资源、网络协议栈资源、文件系统挂载路径资源等。通过 Linux 的 namespace 功能，可以对这些非物理全局资源进行虚拟化。&lt;/p>
&lt;p>Linux namespace 是在当前运行的系统环境中创建(隔离)另一个进程的运行环境出来，并在此运行环境中将一些必要的系统全局资源进行【虚拟化】。进程可以运行在指定的 namespace 中，因此，namespace 中的每个进程都认为自己拥有所有这些虚拟化的全局资源。&lt;/p>
&lt;h2 id="背景">背景&lt;a class="td-heading-self-link" href="#%e8%83%8c%e6%99%af" aria-label="Heading self-link">&lt;/a>&lt;/h2>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/gp34mf/1640133594098-db8cd29e-8628-4117-a5ec-ea14de312485.webp" alt="">
Linux Namespaces 的灵感来自 &lt;a href="https://en.wikipedia.org/wiki/Plan_9_from_Bell_Labs">Plan 9 from Bell Labs&lt;/a> 中大量使用的名称空间功能。Plan 9 from Bell Labs 是贝尔实验室弄出来的分布式操作系统。&lt;/p>
&lt;h2 id="linux-namespace-类型">Linux Namespace 类型&lt;a class="td-heading-self-link" href="#linux-namespace-%e7%b1%bb%e5%9e%8b" aria-label="Heading self-link">&lt;/a>&lt;/h2>
&lt;p>Note：随着技术的发展，Linux 内核支持的的 Namespace 类型在逐步增加&lt;/p>
&lt;p>目前，Linux 已经支持 8 种全局资源的虚拟化(每种资源都是随着 Linux 内核版本的迭代而逐渐加入的，因此有些内核版本可能不具备某种 namespace)：&lt;/p>
&lt;ul>
&lt;li>cgroup namespace：该 namespace 可单独管理自己的 cgroup&lt;/li>
&lt;li>ipc namespace：该 namespace 有自己的 IPC，比如共享内存、信号量等&lt;/li>
&lt;li>network namespace：该 namespace 有自己的网络资源，包括网络协议栈、网络设备、路由表、防火墙、端口等&lt;/li>
&lt;li>mount namespace：该 namespace 有自己的挂载信息，即拥有独立的目录层次&lt;/li>
&lt;li>pid namespace：该 namespace 有自己的进程号，使得 namespace 中的进程 PID 单独编号，比如可以 PID=1&lt;/li>
&lt;li>time namespace：该 namespace 有自己的启动时间点信息和单调时间，比如可设置某个 namespace 的开机时间点为 1 年前启动，再比如不同的 namespace 创建后可能流逝的时间不一样&lt;/li>
&lt;li>user namespace：该 namespace 有自己的用户权限管理机制(比如独立的 UID/GID)，使得 namespace 更安全&lt;/li>
&lt;li>uts namespace：该 namepsace 有自己的主机信息，包括主机名(hostname)、NIS domain name&lt;/li>
&lt;/ul>
&lt;p>用户可以同时创建具有多种资源类型的 namespace，比如创建一个同时具有 uts、pid 和 user 的 namespace。&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>类型&lt;/th>
&lt;th>功能说明&lt;/th>
&lt;th>系统调用参数&lt;/th>
&lt;th>内核版本&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>MNT Namespace&lt;/td>
&lt;td>提供磁盘挂载点和文件系统的隔离能力&lt;/td>
&lt;td>CLONE_NEWNS&lt;/td>
&lt;td>2.4.19&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>IPC Namespace&lt;/td>
&lt;td>提供进程间通信的隔离能力&lt;/td>
&lt;td>CLONE_NEWIPC&lt;/td>
&lt;td>2.6.19&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Net Namespace&lt;/td>
&lt;td>提供网络隔离能力&lt;/td>
&lt;td>CLONE_NEWNET&lt;/td>
&lt;td>2.6.29&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>UTS Namespace&lt;/td>
&lt;td>提供主机名隔离能力&lt;/td>
&lt;td>CLONE_NEWUTS&lt;/td>
&lt;td>2.6.19&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>PID Namespace&lt;/td>
&lt;td>提供进程隔离能力&lt;/td>
&lt;td>CLONE_NEWPID&lt;/td>
&lt;td>2.6.24&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>User Namespace&lt;/td>
&lt;td>提供用户隔离能力&lt;/td>
&lt;td>CLONE_NEWUSER&lt;/td>
&lt;td>3.8&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>CGroup Namespace&lt;/td>
&lt;td>Cgroup root directory&lt;/td>
&lt;td>&lt;/td>
&lt;td>4.6&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h2 id="理解-linux-namespace">理解 Linux namespace&lt;a class="td-heading-self-link" href="#%e7%90%86%e8%a7%a3-linux-namespace" aria-label="Heading self-link">&lt;/a>&lt;/h2>
&lt;p>用户可以创建指定类型的 namespace 并将进程放入该 namespace 中运行，这表示从当前的系统运行环境中隔离一个进程的运行环境，在此 namespace 中运行的进程将认为自己享有该 namespace 中的独立资源。&lt;/p>
&lt;p>实际上，即使用户没有手动创建 Linux namespace，Linux 系统开机后也会创建一个默认的 namespace，称为 root namespace，所有进程默认都运行在 root namespace 中，每个进程都认为自己拥有该 namespace 中的所有系统全局资源。&lt;/p>
&lt;p>回顾一下 Linux 的开机启动流程，内核加载成功后将初始化系统运行环境，这个运行环境就是 root namespace 环境，系统运行环境初始化完成后，便可以认为操作系统已经开始工作了。&lt;/p>
&lt;p>每一个 namespace 都基于当前内核，无论是默认的 root namespace 还是用户创建的每一个 namespace，都基于当前内核工作。所以可以认为 namespace 是内核加载后启动的一个特殊系统环境，用户进程可以在此环境中独立享用资源。更严格地说，root namespace 直接基于内核，而用户创建的 namespace 运行环境基于当前所在的 namespace。之所以用户创建的 namespace 不直接基于内核环境，是因为每一个 namespace 可能都会修改某些运行时内核参数。&lt;/p>
&lt;p>比如，用户创建的 uts namespace1 中修改了主机名为 ns1，然后在 namespace1 中创建 uts namespace2 时，namespace2 默认将共享 namespace1 的其他资源并拷贝 namespace1 的主机名资源，因此 namespace2 的主机名初始时也是 ns1。当然，namespace2 是隔离的，可以修改其主机名为 ns2，这不会影响其他 namespace，修改后，将只有 namespace2 中的进程能看到其主机名为 ns2。&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/gp34mf/1616122902978-3836fe05-d484-4fba-8626-939d6795c4d2.png" alt="">&lt;/p>
&lt;p>可以通过如下方式查看某个进程运行在哪一个 namespace 中，即该进程享有的独立资源来自于哪一个 namespace。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8f5902;font-style:italic"># ls -l /proc/&amp;lt;PID&amp;gt;/ns&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>$ ls -l /proc/&lt;span style="color:#000">$$&lt;/span>/ns &lt;span style="color:#000;font-weight:bold">|&lt;/span> awk &lt;span style="color:#4e9a06">&amp;#39;{print $1,$(NF-2),$(NF-1),$NF}&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>lrwxrwxrwx cgroup -&amp;gt; cgroup:&lt;span style="color:#ce5c00;font-weight:bold">[&lt;/span>4026531835&lt;span style="color:#ce5c00;font-weight:bold">]&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>lrwxrwxrwx ipc -&amp;gt; ipc:&lt;span style="color:#ce5c00;font-weight:bold">[&lt;/span>4026531839&lt;span style="color:#ce5c00;font-weight:bold">]&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>lrwxrwxrwx mnt -&amp;gt; mnt:&lt;span style="color:#ce5c00;font-weight:bold">[&lt;/span>4026531840&lt;span style="color:#ce5c00;font-weight:bold">]&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>lrwxrwxrwx net -&amp;gt; net:&lt;span style="color:#ce5c00;font-weight:bold">[&lt;/span>4026531992&lt;span style="color:#ce5c00;font-weight:bold">]&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>lrwxrwxrwx pid -&amp;gt; pid:&lt;span style="color:#ce5c00;font-weight:bold">[&lt;/span>4026531836&lt;span style="color:#ce5c00;font-weight:bold">]&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>lrwxrwxrwx pid_for_children -&amp;gt; pid:&lt;span style="color:#ce5c00;font-weight:bold">[&lt;/span>4026531836&lt;span style="color:#ce5c00;font-weight:bold">]&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>lrwxrwxrwx user -&amp;gt; user:&lt;span style="color:#ce5c00;font-weight:bold">[&lt;/span>4026531837&lt;span style="color:#ce5c00;font-weight:bold">]&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>lrwxrwxrwx uts -&amp;gt; uts:&lt;span style="color:#ce5c00;font-weight:bold">[&lt;/span>4026531838&lt;span style="color:#ce5c00;font-weight:bold">]&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>$ sudo ls -l /proc/1/ns &lt;span style="color:#000;font-weight:bold">|&lt;/span> awk &lt;span style="color:#4e9a06">&amp;#39;{print $1,$(NF-2),$(NF-1),$NF}&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>lrwxrwxrwx cgroup -&amp;gt; cgroup:&lt;span style="color:#ce5c00;font-weight:bold">[&lt;/span>4026531835&lt;span style="color:#ce5c00;font-weight:bold">]&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>lrwxrwxrwx ipc -&amp;gt; ipc:&lt;span style="color:#ce5c00;font-weight:bold">[&lt;/span>4026531839&lt;span style="color:#ce5c00;font-weight:bold">]&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>lrwxrwxrwx mnt -&amp;gt; mnt:&lt;span style="color:#ce5c00;font-weight:bold">[&lt;/span>4026531840&lt;span style="color:#ce5c00;font-weight:bold">]&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>lrwxrwxrwx net -&amp;gt; net:&lt;span style="color:#ce5c00;font-weight:bold">[&lt;/span>4026531992&lt;span style="color:#ce5c00;font-weight:bold">]&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>lrwxrwxrwx pid -&amp;gt; pid:&lt;span style="color:#ce5c00;font-weight:bold">[&lt;/span>4026531836&lt;span style="color:#ce5c00;font-weight:bold">]&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>lrwxrwxrwx pid_for_children -&amp;gt; pid:&lt;span style="color:#ce5c00;font-weight:bold">[&lt;/span>4026531836&lt;span style="color:#ce5c00;font-weight:bold">]&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>lrwxrwxrwx user -&amp;gt; user:&lt;span style="color:#ce5c00;font-weight:bold">[&lt;/span>4026531837&lt;span style="color:#ce5c00;font-weight:bold">]&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>lrwxrwxrwx uts -&amp;gt; uts:&lt;span style="color:#ce5c00;font-weight:bold">[&lt;/span>4026531838&lt;span style="color:#ce5c00;font-weight:bold">]&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>这些文件表示当前进程打开的 namespace 资源，每一个文件都是一个软链接，所指向的文件是一串格式特殊的名称。冒号后面中括号内的数值表示该 namespace 的 inode。如果不同进程的 namespace inode 相同，说明这些进程属于同一个 namespace。&lt;/p>
&lt;p>从结果上来看，每个进程都运行在多个 namespace 中，且 pid=1 和 &lt;code>pid=$$(当前 Shell 进程)两个进程的 namespace 完全一样，说明它们运行在相同的环境下(root namespace)&lt;/code>。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8f5902;font-style:italic"># namespace 概念和细节相关 man 文档。这些 man 手册在 3.10 内核及之前版本是没有的&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>man namespaces
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>man uts_namespaces
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>man network_namespaces
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>man ipc_namespaces
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>man pid_namespaces
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>man mount_namespaces
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>man user_namespaces
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>man time_namespaces
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>man cgroup_namespaces
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8f5902;font-style:italic"># namespace 管理工具&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>man unshare &lt;span style="color:#8f5902;font-style:italic"># 创建namespace&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>man nscreate &lt;span style="color:#8f5902;font-style:italic"># 创建namespace，老版本的内核没有该工具&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>man nsenter &lt;span style="color:#8f5902;font-style:italic"># 切换namespace&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>man lsns &lt;span style="color:#8f5902;font-style:italic"># 查看当前已创建的namespace&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h1 id="namespace-的具体实现">Namespace 的具体实现&lt;a class="td-heading-self-link" href="#namespace-%e7%9a%84%e5%85%b7%e4%bd%93%e5%ae%9e%e7%8e%b0" aria-label="Heading self-link">&lt;/a>&lt;/h1>
&lt;p>对于 Linux 系统来说，自己本身就是一个 Namespace。系统启动的第一个进程 systemd 自己就有对应的 6 个名称空间，可以通过 lsns 命令看到 pid 为 1 的进程所使用的 Namespace，我们平时操作的地方就是 systemd 所在的 jail，所以能看到的 &lt;code>/&lt;/code> 就是 systemd 所在 jail 规定出来的 &lt;code>/&lt;/code>&lt;/p>
&lt;p>Linux Namespace 主要使用三个系统调用来实现&lt;/p>
&lt;ul>
&lt;li>&lt;strong>clone()&lt;/strong> # 实现线程的系统调用，用来创建一个新的进程 。&lt;/li>
&lt;li>&lt;strong>unshare()&lt;/strong> # 使某进程脱离某个 Namespace&lt;/li>
&lt;li>&lt;strong>setns()&lt;/strong> # 把某进程加入到某个 Namespace&lt;/li>
&lt;/ul>
&lt;p>每个 NameSpace 的说明：&lt;/p>
&lt;ol>
&lt;li>当调用 clone 时，设定了 CLONE_NEWPID，就会创建一个新的 PID Namespace，clone 出来的新进程将成为 Namespace 里的第一个进程。一个 PID Namespace 为进程提供了一个独立的 PID 环境，PID Namespace 内的 PID 将从 1 开始，在 Namespace 内调用 fork，vfork 或 clone 都将产生一个在该 Namespace 内独立的 PID。新创建的 Namespace 里的第一个进程在该 Namespace 内的 PID 将为 1，就像一个独立的系统里的 init 进程一样。该 Namespace 内的孤儿进程都将以该进程为父进程，当该进程被结束时，该 Namespace 内所有的进程都会被结束。PID Namespace 是层次性，新创建的 Namespace 将会是创建该 Namespace 的进程属于的 Namespace 的子 Namespace。子 Namespace 中的进程对于父 Namespace 是可见的，一个进程将拥有不止一个 PID，而是在所在的 Namespace 以及所有直系祖先 Namespace 中都将有一个 PID。系统启动时，内核将创建一个默认的 PID Namespace，该 Namespace 是所有以后创建的 Namespace 的祖先，因此系统所有的进程在该 Namespace 都是可见的。&lt;/li>
&lt;li>当调用 clone 时，设定了 CLONE_NEWIPC，就会创建一个新的 IPC Namespace，clone 出来的进程将成为 Namespace 里的第一个进程。一个 IPC Namespace 有一组 System V IPC objects 标识符构成，这标识符有 IPC 相关的系统调用创建。在一个 IPC Namespace 里面创建的 IPC object 对该 Namespace 内的所有进程可见，但是对其他 Namespace 不可见，这样就使得不同 Namespace 之间的进程不能直接通信，就像是在不同的系统里一样。当一个 IPC Namespace 被销毁，该 Namespace 内的所有 IPC object 会被内核自动销毁。
&lt;ol>
&lt;li>PID Namespace 和 IPC Namespace 可以组合起来一起使用，只需在调用 clone 时，同时指定 CLONE_NEWPID 和 CLONE_NEWIPC，这样新创建的 Namespace 既是一个独立的 PID 空间又是一个独立的 IPC 空间。不同 Namespace 的进程彼此不可见，也不能互相通信，这样就实现了进程间的隔离&lt;/li>
&lt;/ol>
&lt;/li>
&lt;li>当调用 clone 时，设定了 CLONE_NEWNS，就会创建一个新的 mount Namespace。每个进程都存在于一个 mount Namespace 里面，mount Namespace 为进程提供了一个文件层次视图。如果不设定这个 flag，子进程和父进程将共享一个 mount Namespace，其后子进程调用 mount 或 umount 将会影响到所有该 Namespace 内的进程。如果子进程在一个独立的 mount Namespace 里面，就可以调用 mount 或 umount 建立一份新的文件层次视图。该 flag 配合 pivot_root 系统调用，可以为进程创建一个独立的目录空间。&lt;/li>
&lt;li>当调用 clone 时，设定了 CLONE_NEWNET，就会创建一个新的 Network Namespace。一个 Network Namespace 为进程提供了一个完全独立的网络协议栈的视图。包括网络设备接口，IPv4 和 IPv6 协议栈，IP 路由表，防火墙规则，sockets 等等。一个 Network Namespace 提供了一份独立的网络环境，就跟一个独立的系统一样。一个物理设备只能存在于一个 Network Namespace 中，可以从一个 Namespace 移动另一个 Namespace 中。虚拟网络设备(virtual network device)提供了一种类似管道的抽象，可以在不同的 Namespace 之间建立隧道。利用虚拟化网络设备，可以建立到其他 Namespace 中的物理设备的桥接。当一个 Network Namespace 被销毁时，物理设备会被自动移回 init Network Namespace，即系统最开始的 Namespace&lt;/li>
&lt;li>当调用 clone 时，设定了 CLONE_NEWUTS，就会创建一个新的 UTS Namespace。一个 UTS Namespace 就是一组被 uname 返回的标识符。新的 UTS Namespace 中的标识符通过复制调用进程所属的 Namespace 的标识符来初始化。Clone 出来的进程可以通过相关系统调用改变这些标识符，比如调用 sethostname 来改变该 Namespace 的 hostname。这一改变对该 Namespace 内的所有进程可见。CLONE_NEWUTS 和 CLONE_NEWNET 一起使用，可以虚拟出一个有独立主机名和网络空间的环境，就跟网络上一台独立的主机一样。&lt;/li>
&lt;/ol>
&lt;p>以上所有 clone flag 都可以一起使用，为进程提供了一个独立的运行环境。LXC 正是通过在 clone 时设定这些 flag，为进程创建一个有独立 PID，IPC，FS，Network，UTS 空间的 container。一个 container 就是一个虚拟的运行环境，对 container 里的进程是透明的，它会以为自己是直接在一个系统上运行的。&lt;/p>
&lt;h1 id="namespace-关联文件">Namespace 关联文件&lt;a class="td-heading-self-link" href="#namespace-%e5%85%b3%e8%81%94%e6%96%87%e4%bb%b6" aria-label="Heading self-link">&lt;/a>&lt;/h1>
&lt;p>主信息：&lt;/p>
&lt;ul>
&lt;li>&lt;strong>/proc/PID/ns/&lt;/strong> # 由于 namespace 都是与进程相关联，那么可以通过从每个进程的 ns 目录查看相关进程的 namespace 使用情况&lt;/li>
&lt;/ul>
&lt;p>Network Namespace：&lt;/p>
&lt;ul>
&lt;li>&lt;strong>/var/run/netns/NAME&lt;/strong> # 该目录为 &lt;code>ip netns&lt;/code> 命令所能调取查看的目录
&lt;ul>
&lt;li>如果想让 &lt;code>ip netns&lt;/code> 命令查看到网络名称空间的信息，则需要把 /proc/PID/ns/net 文件链接到该目录即可&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul></description></item><item><title>Docs: Network Namespace</title><link>https://desistdaydream.github.io/docs/10.%E4%BA%91%E5%8E%9F%E7%94%9F/Containerization/1.Namespaces/Network-Namespace/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/10.%E4%BA%91%E5%8E%9F%E7%94%9F/Containerization/1.Namespaces/Network-Namespace/</guid><description/></item><item><title>Docs: PID Namespace</title><link>https://desistdaydream.github.io/docs/10.%E4%BA%91%E5%8E%9F%E7%94%9F/Containerization/1.Namespaces/PID-Namespace/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/10.%E4%BA%91%E5%8E%9F%E7%94%9F/Containerization/1.Namespaces/PID-Namespace/</guid><description>
&lt;h1 id="概述">概述&lt;a class="td-heading-self-link" href="#%e6%a6%82%e8%bf%b0" aria-label="Heading self-link">&lt;/a>&lt;/h1>
&lt;p>PID namespace 用来隔离进程的 PID 空间，使得不同 PID namespace 里的进程 PID 可以重复且互不影响。PID namesapce 对容器类应用特别重要， 可以实现容器内进程的暂停/恢复等功能，还可以支持容器在跨主机的迁移前后保持内部进程的 PID 不发生变化。&lt;/p>
&lt;p>说明：本文的演示环境为 ubuntu 16.04。&lt;/p>
&lt;h1 id="pid-namesapce-与-proc">PID namesapce 与 /proc&lt;a class="td-heading-self-link" href="#pid-namesapce-%e4%b8%8e-proc" aria-label="Heading self-link">&lt;/a>&lt;/h1>
&lt;p>Linux 下的每个进程都有一个对应的 /proc/PID 目录，该目录包含了大量的有关当前进程的信息。 对一个 PID namespace 而言，/proc 目录只包含当前 namespace 和它所有子孙后代 namespace 里的进程的信息。&lt;/p>
&lt;p>创建一个新的 PID namespace 后，如果想让子进程中的 top、ps 等依赖 /proc 文件系统的命令工作，还需要挂载 /proc 文件系统。下面的例子演示了挂载 /proc 文件系统的重要性。先输出当前进程的 PID，然后查看其 PID namespace，接着通过 unshare 命令创建新的 PID namespace：&lt;/p>
&lt;p>$ sudo unshare &amp;ndash;pid &amp;ndash;mount &amp;ndash;fork /bin/bash&lt;/p>
&lt;p>该命令会同时创建新的 PID 和 mount namespace，然后再查看此时的 PID namespace：&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/kvsekb/1616122886405-a8e61f79-d690-4eb0-a0ff-818a704e6d35.png" alt="">&lt;/p>
&lt;p>上图中的结果似乎不是我们想要的，因为显示的 PID namespace 并没有变化。让我们接着做实验：&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/kvsekb/1616122886383-f38feb75-27c3-4dcb-87ab-03d41a12597c.png" alt="">&lt;/p>
&lt;p>看样子 ps 命令显示的 PID 还是旧 namespace 中的编号，而 &lt;code>$$&lt;/code> 为 1 说明当前进程已经被认为是该 PID namespace 中的 1 号进程了。再看看 1 号进程的详细信息：/sbin/init，这是系统的 init 进程，这一切看起来实在是太乱了。&lt;/p>
&lt;p>造成混乱的原因是当前进程没有正确的挂载 /proc 文件系统，由于我们新的 mount namespace 的挂载信息是从老的 namespace 拷贝过来的，所以这里看到的还是老 namespace 里面的进程号为 1 的信息。执行下面的命令挂载 /proc 文件系统：&lt;/p>
&lt;p>$ mount -t proc proc /proc&lt;/p>
&lt;p>然后再来检查相关的信息：&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/kvsekb/1616122886486-f50ebf2c-d8c3-42a5-87e6-55661eea4442.png" alt="">&lt;/p>
&lt;p>这次就符合我们的预期了，显示了新的 PID namespace，当前 PID namespace 中的 1 号进程也变成了 bash 进程。&lt;/p>
&lt;p>其实 unshare 命令提供了一个专门的选项 &amp;ndash;mount-proc 来配合 PID namespce 的创建：&lt;/p>
&lt;p>$ sudo unshare &amp;ndash;pid &amp;ndash;mount-proc &amp;ndash;fork /bin/bash&lt;/p>
&lt;p>这样在创建了 PID 和 Mount namespace 后，会自动挂载 /proc 文件系统，就不需要我们手动执行 mount -t proc proc /proc 命令了。&lt;/p>
&lt;h1 id="不能修改的进程-pid-namespace">不能修改的进程 PID namespace&lt;a class="td-heading-self-link" href="#%e4%b8%8d%e8%83%bd%e4%bf%ae%e6%94%b9%e7%9a%84%e8%bf%9b%e7%a8%8b-pid-namespace" aria-label="Heading self-link">&lt;/a>&lt;/h1>
&lt;p>在前面的演示中我们为 unshare 命令添加了 &amp;ndash;fork /bin/bash 参数：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>sudo unshare --pid --mount-proc --fork /bin/bash
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&amp;ndash;fork 是为了让 unshare 进程 fork 一个新的进程出来，然后再用 /bin/bash 替换掉新的进程中执行的命令。需要这么做是由于 PID namespace 本身的特点导致的。进程所属的 PID namespace 在它创建的时候就确定了，不能更改，所以调用 unshare 和 nsenter 等命令后，原进程还是属于老的 PID namespace，新 fork 出来的进程才属于新的 PID namespace。&lt;/p>
&lt;p>我们在一个 shell 中执行下面的命令：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#204a87">echo&lt;/span> &lt;span style="color:#000">$$&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>sudo unshare --pid --mount-proc --fork /bin/bash
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/kvsekb/1616122886376-06b3b42c-1259-4ee9-987b-4aa84f6902c9.png" alt="">&lt;/p>
&lt;p>然后新打开一个 shell 检查进程所属的 PID namespace：&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/kvsekb/1616122886440-1017aa5f-bde5-4274-974a-c05c6cce2900.png" alt="">&lt;/p>
&lt;p>查看进程树中进程所属的 PID namespace，只有被 unshare fork 出来的 bash 进程加入了新的 PID namespace。&lt;/p>
&lt;h1 id="pid-namespace-的嵌套">PID namespace 的嵌套&lt;a class="td-heading-self-link" href="#pid-namespace-%e7%9a%84%e5%b5%8c%e5%a5%97" aria-label="Heading self-link">&lt;/a>&lt;/h1>
&lt;p>PID namespace 可以嵌套，也就是说有父子关系，除了系统初始化时创建的根 PID namespace 之外，其它的 PID namespace 都有一个父 PID namespace。一个 PID namespace 的父是指：通过 clone 或 unshare 方法创建 PID namespace 的进程所在的 PID namespace。&lt;/p>
&lt;p>在当前 namespace 里面创建的所有新的 namespace 都是当前 namespace 的子 namespace。父 namespace 里面可以看到所有子孙后代 namespace 里的进程信息，而子 namespace 里看不到祖先或者兄弟 namespace 里的进程信息。一个进程在 PID namespace 的嵌套结构中的每一个可以被看到的层中都有一个 PID。这里所谓的 &amp;ldquo;看到&amp;rdquo; 是指可以对这个进程执行操作，比如发送信号等。&lt;/p>
&lt;p>目前 PID namespace 最多可以嵌套 32 层，由内核中的宏 MAX_PID_NS_LEVEL 来定义。&lt;/p>
&lt;p>在一个 PID namespace 里的进程，它的父进程可能不在当前 namespace 中，而是在外面的 namespace 里(外面的 namespace 指当前 namespace 的父 namespace)，这类进程的 PPID 都是 0。比如新创建的 PID namespace 里面的第一个进程，他的父进程就在外面的 PID namespace 里。通过 setns 的方式将子进程加入到新 PID namespace 中的进程的父进程也在外面的 namespace 中。&lt;/p>
&lt;p>我们可以把子进程加入到新的子 PID namespace 中，但是却不能把子进程加入到任何祖先 PID namespace 中。&lt;/p>
&lt;p>下面我们通过示例来获得一些直观的感受。&lt;/p>
&lt;p>打开第一个 shell 窗口&lt;/p>
&lt;p>先创建查看下当前进程的 PID，然后创建三个嵌套的 PID namespace：&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/kvsekb/1616122886410-3a934def-3f2c-4541-a2f2-d28c8d80f6c9.png" alt="">&lt;/p>
&lt;p>打开第二个 shell 窗口&lt;/p>
&lt;p>在另一个 shell 中查看 2616 进程的子进程：&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/kvsekb/1616122886370-ef366f0a-e064-4b32-a14d-625ced4763c7.png" alt="">&lt;/p>
&lt;p>bash(2616)───&lt;/p>
&lt;p>sudo(2686)───unshare(2687)───bash(2688)───&lt;/p>
&lt;p>sudo(2709)───unshare(2710)───bash(2711)───&lt;/p>
&lt;p>sudo(2722)───unshare(2723)───bash(2724)&lt;/p>
&lt;p>下面我们通过 PID 来查看上面进程属于的 PID namespace：&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/kvsekb/1616122886493-49897cb4-18c2-4315-bd7c-12a413e2e1f5.png" alt="">&lt;/p>
&lt;p>这与我们创建 PID namespace 看到的结果是一样的。然后我们通过 /proc/[pid]/status 看看 2724 号进程在不同 PID namespace 中的 PID：&lt;/p>
&lt;p>$ grep pid /proc/2724/status&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/kvsekb/1616122886378-eaaa01db-c976-420f-acad-e0479d79dd86.png" alt="">&lt;/p>
&lt;p>在我们创建的三个 PID namespace 中，PID 分别为 27, 24 和 1。&lt;/p>
&lt;p>接下来我们使用 nsenter 命令进入到 2711(我们创建的第二个 PID namespace) 进程所在的 PID namespace：&lt;/p>
&lt;p>$ sudo nsenter &amp;ndash;mount &amp;ndash;pid -t 2711 /bin/bash&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/kvsekb/1616122886389-2790e3fc-01f0-46ab-834b-ef289d3d2b2a.png" alt="">&lt;/p>
&lt;p>查看进程树，这里 bash(14) 就是最后一个 PID namespace 中 PID 为 1 的进程。细心的读者可能已经发现了，pstree 命令并没有显示我们通过 nsenter 添加进来的 bash 进程，让我们来看看究竟：&lt;/p>
&lt;p>$ ps -ef&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/kvsekb/1616122886439-d8bc9728-9778-4be7-b1c9-5e0a6764e91c.png" alt="">&lt;/p>
&lt;p>有两个 PPID 为 0 的进程，PID 为 38 的进程不属于当前 PID namespace 中 init 进程的子进程，所以不会被 pstree 显示。这也是我们创建的 PID namespace 根最外层的 PID namespace 不一样的地方：可以有多个 PPID 为 0 的进程。&lt;/p>
&lt;p>再看上图中的 TTY 列，可以通过它看出命令是在哪个 shell 窗口中执行的。pts/17 代表的是我们打开的第一个 shell 窗口，pts/2 代表我们打开的第二个 shell 窗口。&lt;/p>
&lt;p>&lt;strong>打开第三个 shell 窗口&lt;/strong>&lt;/p>
&lt;p>使用 nsenter 命令进入到 2688(我们创建的第一个 PID namespace) 进程所在的 PID namespace：&lt;/p>
&lt;p>$ sudo nsenter &amp;ndash;mount &amp;ndash;pid -t 2688 /bin/bash&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/kvsekb/1616122886381-127b6075-ca47-4585-a69f-986d6a6adc07.png" alt="">&lt;/p>
&lt;p>查看进程树，这里 bash(27) 是最后一个 PID namespace 中 PID 为 1 的进程。bash(14) 是第二个 PID namespace 中 PID 为 1 的进程。用 ps 命令查看进程信息：&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/kvsekb/1616122886409-c1968a43-132f-4094-8456-27b9e7f7c6f7.png" alt="">&lt;/p>
&lt;p>PID 为 51 和 66 的进程都是由 nsenter 命令添加的 bash 进程。到这里我们也可以看出，同样的进程在不同的 PID namespace 中拥有不同的 PID。&lt;/p>
&lt;p>最后我们尝试给第二个 shell 窗口中的 bash 进程(51)发送一个信号：&lt;/p>
&lt;p>$ kill 51&lt;/p>
&lt;p>回到第二个 shell 窗口&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/kvsekb/1616122886459-abb3009d-9daa-4b83-a175-99a98fc2e5ae.png" alt="">&lt;/p>
&lt;p>此时 bash 进程已经被 kill 掉了，这说明从父 PID namespace 中可以给子 PID namespace 中的进程发送信号。&lt;/p>
&lt;h1 id="pid-namespace-中的-init-进程">PID namespace 中的 init 进程&lt;a class="td-heading-self-link" href="#pid-namespace-%e4%b8%ad%e7%9a%84-init-%e8%bf%9b%e7%a8%8b" aria-label="Heading self-link">&lt;/a>&lt;/h1>
&lt;p>在一个新的 PID namespace 中创建的第一个进程的 PID 为 1，该进程被称为这个 PID namespace 中的 init 进程。&lt;/p>
&lt;p>在 Linux 系统中，进程的 PID 从 1 开始往后不断增加，并且不能重复（当然进程退出后，PID 会被回收再利用），进程的 PID 为 1 的进程是内核启动的第一个应用层进程，被称为 init 进程(不同的 init 系统的进程名称可能不太一样)。这个进程具有特殊意义，当 init 进程退出时，系统也将退出。所以除了在 init 进程里指定了 handler 的信号外，内核会帮 init 进程屏蔽掉其他任何信号，这样可以防止其他进程不小心 kill 掉 init 进程导致系统挂掉。&lt;/p>
&lt;p>不过有了 PID namespace 后，可以通过在父 PID namespace 中发送 SIGKILL 或者 SIGSTOP 信号来终止子 PID namespace 中的 PID 为 1 的进程。由于 PID 为 1 的进程的特殊性，当这个进程停止后，内核将会给这个 PID namespace 里的所有其他进程发送 SIGKILL 信号，致使其他所有进程都停止，最终 PID namespace 被销毁掉。&lt;/p>
&lt;p>当一个进程的父进程退出后，该进程就变成了孤儿进程。孤儿进程会被当前 PID namespace 中 PID 为 1 的进程接管，而不是被最外层的系统级别的 init 进程接管。&lt;/p>
&lt;p>下面我们通过示例来获得一些直观的感受。&lt;/p>
&lt;p>继续以上面三个 PID namespace 为例，第一步，先回到第一个 shell 窗口， 新启动两个 bash 进程：&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/kvsekb/1616122886449-14d989ed-8a56-45c7-abc5-6c60c637fbd1.png" alt="">&lt;/p>
&lt;p>首先，利用 unshare、nohup 和 sleep 命令组合，创建出父子进程。下面的命令 fork 出一个子进程并在后台 sleep 一小时：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>unshare --fork nohup sleep 3600&lt;span style="color:#000;font-weight:bold">&amp;amp;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>pstree -p
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/kvsekb/1616122886445-7ba2a5b3-2ddd-4bb3-8e05-1f8681fafc75.png" alt="">&lt;/p>
&lt;p>然后我们 kill 掉进程 unshare(34)：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#204a87">kill&lt;/span> &lt;span style="color:#0000cf;font-weight:bold">34&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>pstree -p
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/kvsekb/1616122886453-307dde0f-fbca-4fea-ac99-9bd9c9c58a38.png" alt="">&lt;/p>
&lt;p>如同我们期望的一样，进程 sleep(35) 被当前 PID namespace 中的 init 进程 bash(1) 收养了！&lt;/p>
&lt;p>现在 kill 掉进程 sleep(35)并重新执行 unshare &amp;ndash;fork nohup sleep 3600&amp;amp; 命令：&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/kvsekb/1616122886426-d531a43e-5154-4ac7-93e8-3207e9350c9e.png" alt="">&lt;/p>
&lt;p>我们得到了和刚才相同的进程关系，只是进程的 PID 发生了一些变化。&lt;/p>
&lt;p>第二步，回到第三个 shell 窗口&lt;/p>
&lt;p>先检查当前的进程树：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>$ pstree -p
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>bash&lt;span style="color:#ce5c00;font-weight:bold">(&lt;/span>1&lt;span style="color:#ce5c00;font-weight:bold">)&lt;/span>───
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>sudo&lt;span style="color:#ce5c00;font-weight:bold">(&lt;/span>12&lt;span style="color:#ce5c00;font-weight:bold">)&lt;/span>───unshare&lt;span style="color:#ce5c00;font-weight:bold">(&lt;/span>13&lt;span style="color:#ce5c00;font-weight:bold">)&lt;/span>───bash&lt;span style="color:#ce5c00;font-weight:bold">(&lt;/span>14&lt;span style="color:#ce5c00;font-weight:bold">)&lt;/span>───
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>sudo&lt;span style="color:#ce5c00;font-weight:bold">(&lt;/span>25&lt;span style="color:#ce5c00;font-weight:bold">)&lt;/span>───unshare&lt;span style="color:#ce5c00;font-weight:bold">(&lt;/span>26&lt;span style="color:#ce5c00;font-weight:bold">)&lt;/span>───bash&lt;span style="color:#ce5c00;font-weight:bold">(&lt;/span>27&lt;span style="color:#ce5c00;font-weight:bold">)&lt;/span>───bash&lt;span style="color:#ce5c00;font-weight:bold">(&lt;/span>79&lt;span style="color:#ce5c00;font-weight:bold">)&lt;/span>───bash&lt;span style="color:#ce5c00;font-weight:bold">(&lt;/span>89&lt;span style="color:#ce5c00;font-weight:bold">)&lt;/span>───unshare&lt;span style="color:#ce5c00;font-weight:bold">(&lt;/span>105&lt;span style="color:#ce5c00;font-weight:bold">)&lt;/span>───sleep&lt;span style="color:#ce5c00;font-weight:bold">(&lt;/span>106&lt;span style="color:#ce5c00;font-weight:bold">)&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>我们先 kill 掉 sleep 进程的父进程 unshare(105)：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#204a87">kill&lt;/span> &lt;span style="color:#0000cf;font-weight:bold">105&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>pstree -p
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/kvsekb/1616122886466-1722c940-d36c-4d31-8fb8-6152fb71f100.png" alt="">&lt;/p>
&lt;p>进程 sleep(106)被 bash(27) 收养了而不是 baus(1)，这说明孤儿进程只会被自己 PID namespace 中的 init 进程收养。&lt;/p>
&lt;p>接下来 kill 掉第二个 PID namespace 中的 init 进程，即这里的 bash(14)：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#204a87">kill&lt;/span> -SIGKILL &lt;span style="color:#0000cf;font-weight:bold">14&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>pstree -p
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/kvsekb/1616122886430-1bc975f7-e52c-4e9d-b045-ff2ab5584bf0.png" alt="">&lt;/p>
&lt;p>此时第一个和第三个 shell 窗口都回到了我们创建的第一个 PID namespace 中。我们创建的第二个和第三个 PID namespace 中的进程都被系统清除掉了。&lt;/p>
&lt;h1 id="总结">总结&lt;a class="td-heading-self-link" href="#%e6%80%bb%e7%bb%93" aria-label="Heading self-link">&lt;/a>&lt;/h1>
&lt;p>PID namespace 具有比较显著的点，比如可以嵌套，对 init 进程的特殊照顾，孤儿进程的收养等等。尤其是一旦进程的 PID namespace 确定后就不能改变的特点，与其它的 namespace 是完全不一样的。&lt;/p>
&lt;p>参考：&lt;/p>
&lt;p>Linux Namespace PID&lt;/p>
&lt;p>PID namespaces&lt;/p>
&lt;p>PID namespaces2&lt;/p>
&lt;p>pid namespace man page&lt;/p></description></item><item><title>Docs: UTS Namespace</title><link>https://desistdaydream.github.io/docs/10.%E4%BA%91%E5%8E%9F%E7%94%9F/Containerization/1.Namespaces/UTS-Namespace/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/10.%E4%BA%91%E5%8E%9F%E7%94%9F/Containerization/1.Namespaces/UTS-Namespace/</guid><description>
&lt;h1 id="概述">概述&lt;a class="td-heading-self-link" href="#%e6%a6%82%e8%bf%b0" aria-label="Heading self-link">&lt;/a>&lt;/h1>
&lt;p>&lt;strong>UTS(UNIX Time-Sharing System)&lt;/strong> Namespace 可隔离 hostname 和 NIS Domain name 资源，使得一个宿主机可拥有多个主机名或 Domain Name。换句话说，可让不同 namespace 中的进程看到不同的主机名。&lt;/p>
&lt;p>例如，使用 unshare 命令(较新版本 Linux 内核还支持 nscreate 命令)创建一个新的 uts namespace：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8f5902;font-style:italic"># -u或--uts表示创建一个uts namespace&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8f5902;font-style:italic"># 这个namespace中运行/bin/bash程序&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>$ hostname
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>longshuai-vm &lt;span style="color:#8f5902;font-style:italic"># 当前root namespace的主机名为longshuai-vm&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>$ sudo unshare -u /bin/bash
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>root@longshuai-vm:/home/longshuai# &lt;span style="color:#8f5902;font-style:italic"># 进入了新的namespace中的shell&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8f5902;font-style:italic"># 其主机名初始时也是longshuai-vm，&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8f5902;font-style:italic"># 其拷贝自上级namespace资源&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>上面指定运行的是/bin/bash 程序，这会进入交互式模式，当执行 exit 时，bash 退出，回到当前的 namespace 中。也可以指定在 namespace 中运行其他程序，例如 unshare -u sleep 3 表示在 uts namespace 中睡眠 3 秒后退出并回到当前 namespace。&lt;/p>
&lt;p>因为是 uts namespace，所以可在此 namespace 中修改主机名：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8f5902;font-style:italic"># 修改该namespace的主机名为ns1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8f5902;font-style:italic"># 修改后会立即生效，但不会显示在当前Shell提示符下&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8f5902;font-style:italic"># 需重新加载Shell环境&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>root@longshuai-vm:/home/longshuai# hostname ns1
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>root@longshuai-vm:/home/longshuai# hostname
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>ns1
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>root@longshuai-vm:/home/longshuai# &lt;span style="color:#204a87">exec&lt;/span> &lt;span style="color:#000">$SHELL&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>root@ns1:/home/longshuai#
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>namespace 中修改的主机名不会直接修改主机名配置文件(如/etc/hostname)，而是修改内核属性/proc/sys/kernel/hostname：&lt;/p>
&lt;pre>&lt;code>root@ns1:/home/longshuai# cat /proc/sys/kernel/hostname
ns1
root@ns1:/home/longshuai# cat /etc/hostname
longshuai-vm
&lt;/code>&lt;/pre>
&lt;p>创建了新的 namespace 并在其中运行/bin/bash 进程后，再去关注一下进程关系：&lt;/p>
&lt;pre>&lt;code># ns1中的bash进程PID
root@ns1:/home/longshuai# echo $$
14279
# bash进程(PID=14279)和grep进程运行在ns1 namespace中，
# 其父进程sudo(PID=14278)运行在ns1的上级namespace即root namespace中
root@ns1:/home/longshuai# pstree -p | grep $$
|-sshd(10848)---bash(10850)---sudo(14278)---bash(14279)-+-grep(14506)
# 运行在ns1中当前bash进程(PID=14279)的namespace
root@ns1:/home/longshuai# ls -l /proc/14279/ns
lrwxrwxrwx ... cgroup -&amp;gt; 'cgroup:[4026531835]'
lrwxrwxrwx ... ipc -&amp;gt; 'ipc:[4026531839]'
lrwxrwxrwx ... mnt -&amp;gt; 'mnt:[4026531840]'
lrwxrwxrwx ... net -&amp;gt; 'net:[4026531992]'
lrwxrwxrwx ... pid -&amp;gt; 'pid:[4026531836]'
lrwxrwxrwx ... pid_for_children -&amp;gt; 'pid:[4026531836]'
lrwxrwxrwx ... user -&amp;gt; 'user:[4026531837]'
lrwxrwxrwx ... uts -&amp;gt; 'uts:[4026532588]' # 注意这一行，和sudo进程的uts inode不同
# 父进程sudo(PID=14278)不在ns1中，它的namespace信息
root@ns1:/home/longshuai# ls -l /proc/14278/ns
lrwxrwxrwx ... cgroup -&amp;gt; 'cgroup:[4026531835]'
lrwxrwxrwx ... ipc -&amp;gt; 'ipc:[4026531839]'
lrwxrwxrwx ... mnt -&amp;gt; 'mnt:[4026531840]'
lrwxrwxrwx ... net -&amp;gt; 'net:[4026531992]'
lrwxrwxrwx ... pid -&amp;gt; 'pid:[4026531836]'
lrwxrwxrwx ... pid_for_children -&amp;gt; 'pid:[4026531836]'
lrwxrwxrwx ... user -&amp;gt; 'user:[4026531837]'
lrwxrwxrwx ... uts -&amp;gt; 'uts:[4026531838]' # 注意这一行，和PID=1的uts inode相同
&lt;/code>&lt;/pre>
&lt;p>回到创建 uts namespace 时敲下的 unshare 命令：&lt;/p>
&lt;pre>&lt;code>sudo unshare -u /bin/bash
&lt;/code>&lt;/pre>
&lt;p>1
Shell&lt;/p>
&lt;p>从进程关系&amp;hellip;&amp;mdash;sudo(14278)&amp;mdash;bash(14279)可知两个进程 PID 是连续的，说明 unshare 程序对应的进程被/bin/bash 程序通过 execve()替换了。&lt;/p>
&lt;p>详细的过程如下：「sudo 进程运行在当前 namespace 中，它将 fork 一个新进程来运行 unshare 程序，unshare 程序加载完成后，将创建一个新的 uts namespace，unshare 进程自身将加入到这个 uts namespace 中，unshare 进程内部再 exec 加载/bin/bash，于是 unshare 进程被替换为/bin/bash 进程，/bin/bash 进程也将运行在 uts namespace 中」。&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/lu9a00/1616122843124-f5e9da25-edb1-45f4-8eb3-58a15fb18d89.png" alt="">&lt;/p>
&lt;p>当 namespace 中的/bin/bash 进程退出，该 namespace 中将没有任何进程，该 namespace 将自动销毁。注意，在默认情况下，namespace 中必须要有至少一个进程，否则将被自动被销毁。但也有一些手段可以让 namespace 持久化，即使已经没有任何进程在其中运行。&lt;/p>
&lt;p>如果在 ns1 中再创建一个 namespace ns2，这个 ns2 初始时将共享 ns1 的其他资源并拷贝 ns1 的主机名资源，其初始主机名也为 ns1。&lt;/p>
&lt;pre>&lt;code>$ sudo unshare -u /bin/bash # 在root namespace环境下创建一个namespace
root@longshuai-vm:/home/longshuai# hostname ns1 # 修改主机名为ns1
root@longshuai-vm:/home/longshuai# hostname
ns1
# 在ns1中创建一个namespace
############ 注意没有sudo
root@longshuai-vm:/home/longshuai# unshare -u /bin/bash
root@ns1:/home/longshuai# hostname # 初始主机名拷贝自上级namespace的主机名ns1
ns1
root@ns1:/home/longshuai# hostname ns2
root@ns1:/home/longshuai# hostname # 修改主机名为ns2
ns2
root@ns1:/home/longshuai# exit
exit
root@longshuai-vm:/home/longshuai# hostname # ns2修改主机名不影响ns1
ns1
root@longshuai-vm:/home/longshuai# exit
exit
[~]-&amp;gt;$ hostname # ns1修改主机名不影响root namespace
longshuai-vm
&lt;/code>&lt;/pre>
&lt;p>注意，即使 root namespace 当前用户为 longshuai，但因为使用了 sudo 创建 ns1，进入 ns1 后其用户名为 root，所以在 ns1 中执行 unshare 命令创建新的 namespace 不需要再使用 sudo。&lt;/p>
&lt;pre>&lt;code>$ echo $USER # 当前root namespace的用户为longshuai
longshuai
$ sudo unshare -u /bin/bash
root@longshuai-vm:/home/longshuai# echo $USER # ns中的用户名变为root
root
root@longshuai-vm:/home/longshuai# id;echo $HOME;echo ~
uid=0(root) gid=0(root) groups=0(root)
/root
/root
&lt;/code>&lt;/pre></description></item></channel></rss>