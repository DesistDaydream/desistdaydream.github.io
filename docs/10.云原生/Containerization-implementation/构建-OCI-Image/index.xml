<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>构建 OCI Image on 断念梦的站点</title><link>https://desistdaydream.github.io/docs/10.%E4%BA%91%E5%8E%9F%E7%94%9F/Containerization-implementation/%E6%9E%84%E5%BB%BA-OCI-Image/</link><description>Recent content in 构建 OCI Image on 断念梦的站点</description><generator>Hugo</generator><language>zh-cn</language><atom:link href="https://desistdaydream.github.io/docs/10.%E4%BA%91%E5%8E%9F%E7%94%9F/Containerization-implementation/%E6%9E%84%E5%BB%BA-OCI-Image/index.xml" rel="self" type="application/rss+xml"/><item><title>构建 OCI Image</title><link>https://desistdaydream.github.io/docs/10.%E4%BA%91%E5%8E%9F%E7%94%9F/Containerization-implementation/%E6%9E%84%E5%BB%BA-OCI-Image/%E6%9E%84%E5%BB%BA-OCI-Image/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/10.%E4%BA%91%E5%8E%9F%E7%94%9F/Containerization-implementation/%E6%9E%84%E5%BB%BA-OCI-Image/%E6%9E%84%E5%BB%BA-OCI-Image/</guid><description>概述 参考：
官方文档，使用 Docker 开发-构建镜像-编写 Dockerfile 的最佳实践 在容器刚刚流行的时候，想要构建一个容器镜像通常只有两种方式：
通过对 Container 执行 commit 命令来创建基于该 Container 的 Image 通过 Dockerfile 功能来构建 Image Dockerfile 构建镜像的方式逐渐成为主流甚至标准，但是随着各个项目的去 Docker 化，大家都想消除自身对 Docker 的依赖，这其中包括 Docker 项目的起源 Moby，从这里(moby/moby 的 issue #34227)可以略窥 12。但是 Dockerfile 的影响已经深入人心，所以各家一时半会也无法完全舍弃，只能说基于 Dockerfile 形式进行优化。时至今日(2022 年 6 月 3 日)，Dockerfile 依然是最常见最通用的构建镜像的方式，不管构建程序是什么，总归是要通过 Dockerfile 文件的。
Dockerfile 参考：
官方文档 Dockerfile 参考 Docker 通过读取 Dockerfile 文件中的指令来构建符合 OCI 标准的容器镜像。Dockerfile 这个称呼有多个理解方式，可以是指一个功能，也可以指一个文件的文件名，也可以代指一类文件的统称。
DockerFile 功能的工作逻辑 找一个专用目录，在目录中放入默认的名为 Dockerfile 的文件，该文件名首字母必须大写 Dockerfile 文件，类似于一个脚本，使用 docker build 命令创建镜像的时候默认使用名为 Dockerfile 的文件，通过该文件中的各种指令来执行操作。（如果想使用其余名字的文件，则需要使用-f 参数来指明需要使用的 DockerFile 的文件，这时候可以使用名字不为 Dockerfile 的文件） 如果该 Image 中需要打包进去很多文件(比如 rpm 包、配置文件等等)，则这些文件必须做好后，放到 Dockerfile 所在的目录中(可以有子目录)。 使用 docker build 命令并用指定目录路径，则该命令会自动查找该目录下的名为 Dockerfile 文件并根据其中内容创建 Image，效果如上图所示 具体过程详解如下 首先在当前目录创建一个名为 Dockerfile 的文件，在该文件中写入需要执行的指令 ~]# ll total 4 -rw-r--r--.</description></item><item><title>Dockerfile 指令</title><link>https://desistdaydream.github.io/docs/10.%E4%BA%91%E5%8E%9F%E7%94%9F/Containerization-implementation/%E6%9E%84%E5%BB%BA-OCI-Image/Dockerfile-%E6%8C%87%E4%BB%A4/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/10.%E4%BA%91%E5%8E%9F%E7%94%9F/Containerization-implementation/%E6%9E%84%E5%BB%BA-OCI-Image/Dockerfile-%E6%8C%87%E4%BB%A4/</guid><description>概述 参考：
官方文档 官方文档 - 构建镜像的最佳实践 FROM - 指定 base 镜像 FROM 指令将会初始化一个新的构建阶段，并设置用于后续指令所使用的 BaseImage(基础镜像)。所以一个有效的 Dockerfile 必须从 FROM 指令开始。ARG 是唯一一个可以在 FROM 指令前面的指令，除此以外，FROM 可以说是必须存在的基础字段且为 DokerFile 文件的第一个非注释行。
一个 Dockerfile 中可以有多个 FROM 指令，每出现一个 FROM 指令，即表示一个老阶段的结束，一个新阶段的开始。
Syntax(语法) from [&amp;ndash;platform=&amp;lt;PLATFORM&amp;gt;] &amp;lt;image&amp;gt;[:&amp;lt;TAG&amp;gt; | @[DIGEST] ] [AS &amp;lt;NAME&amp;gt;] 附加指令：
AS &amp;lt;NAME&amp;gt; # 为当前构建阶段起一个名字。该附加指令有如下几种用法： 在开始构建之前，可是使用 &amp;ndash;target 指令指定指定要从 STRING 这个阶段开始构建镜像。 在构建中，COPY 指令可以使用 &amp;ndash;from=&amp;lt;NAME&amp;gt; 参数来指定数据源是来自某个构建阶段内的数据，也就是说，COPY 指令不止可以从宿主机拷贝文件到容器中，还可以从上一个构建阶段的容器中，拷贝其内容到当前容器中。这也为多阶段构建模式中，减少镜像体积打下来坚实基础。 TAG 和 DIGEST # 该附加指令是可选的，若不指定镜像的 TAG，则默认使用 latest。 用法 Docker 还存在一个特殊的镜像，名为 scratch。这个镜像是虚拟的概念，并不实际存在，它表示一个空白的镜像。
如果以 scratch 为基础镜像的话，意味着本次构建阶段不以任何镜像为基础，接下来所写的指令将作为镜像第一层开始存在。 不以任何系统为基础，直接将可执行文件复制进镜像的做法并不罕见，比如 coreos/etcd。对于 Linux 下静态编译的程序来说，并不需要有操作系统提供运行时支持，所需的一切库都已经在可执行文件里了，因此直接 FROM scratch 会让镜像体积更加小巧。使用 Go 语言 开发的应用很多会使用这种方式来制作镜像，这也是为什么有人认为 Go 是特别适合容器微服务架构的语言的原因之一。 LABEL - 为镜像添加标签 Syntax(语法) label &amp;lt;key&amp;gt;=&amp;lt;value&amp;gt; &amp;lt;key&amp;gt;=&amp;lt;value&amp;gt; &amp;lt;key&amp;gt;=&amp;lt;value&amp;gt; .</description></item><item><title>Multi-Stage Builds(多阶段构建)</title><link>https://desistdaydream.github.io/docs/10.%E4%BA%91%E5%8E%9F%E7%94%9F/Containerization-implementation/%E6%9E%84%E5%BB%BA-OCI-Image/Multi-Stage-Builds%E5%A4%9A%E9%98%B6%E6%AE%B5%E6%9E%84%E5%BB%BA/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/10.%E4%BA%91%E5%8E%9F%E7%94%9F/Containerization-implementation/%E6%9E%84%E5%BB%BA-OCI-Image/Multi-Stage-Builds%E5%A4%9A%E9%98%B6%E6%AE%B5%E6%9E%84%E5%BB%BA/</guid><description>概述 参考：
官方文档 https://docs.docker.com/build/building/multi-stage/ 两个奇技淫巧，将 Docker 镜像体积减小 99% https://mp.weixin.qq.com/s/6bgtD0Aer6-3u4u9jWBBhw
对于刚接触容器的人来说，他们很容易被自己构建的 Docker 镜像体积吓到，我只需要一个几 MB 的可执行文件而已，为何镜像的体积会达到 1 GB 以上？本文将会介绍几个奇技淫巧来帮助你精简镜像，同时又不牺牲开发人员和运维人员的操作便利性。本系列文章将分为三个部分：
第一部分着重介绍多阶段构建（multi-stage builds），因为这是镜像精简之路至关重要的一环。在这部分内容中，我会解释静态链接和动态链接的区别，它们对镜像带来的影响，以及如何避免那些不好的影响。中间会穿插一部分对 Alpine 镜像的介绍。
第二部分将会针对不同的语言来选择适当的精简策略，其中主要讨论 Go ，同时也涉及到了 Java ， Node ， Python ， Ruby 和 Rust 。这一部分也会详细介绍 Alpine 镜像的避坑指南。什么？你不知道 Alpine 镜像有哪些坑？我来告诉你。
第三部分将会探讨适用于大多数语言和框架的通用精简策略，例如使用常见的基础镜像、提取可执行文件和减小每一层的体积。同时还会介绍一些更加奇特或激进的工具，例如 Bazel ， Distroless ， DockerSlim 和 UPX ，虽然这些工具在某些特定场景下能带来奇效，但大多情况下会起到反作用。
本文介绍第一部分。
01 万恶之源 我敢打赌，每一个初次使用自己写好的代码构建 Docker 镜像的人都会被镜像的体积吓到，来看一个例子。
让我们搬出那个屡试不爽的 hello world C 程序：
/* hello.c */ int main () { puts(&amp;#34;Hello, world!&amp;#34;); return 0; } 并通过下面的 Dockerfile 构建镜像：</description></item><item><title>BuildKit 构建工具</title><link>https://desistdaydream.github.io/docs/10.%E4%BA%91%E5%8E%9F%E7%94%9F/Containerization-implementation/%E6%9E%84%E5%BB%BA-OCI-Image/BuildKit-%E6%9E%84%E5%BB%BA%E5%B7%A5%E5%85%B7/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/10.%E4%BA%91%E5%8E%9F%E7%94%9F/Containerization-implementation/%E6%9E%84%E5%BB%BA-OCI-Image/BuildKit-%E6%9E%84%E5%BB%BA%E5%B7%A5%E5%85%B7/</guid><description>概述 参考：
GitHub 项目，moby/buildkit 官方文档 知乎，官方下一代Docker镜像构建神器 &amp;ndash; BuildKit BuildKit 是 Docker 上游社区(Moby)推出的下一代镜像构建神器，可以更加快速，有效，安全地构建容器镜像。Docker v18.06 已经集成了该组件。BuildKit 可用于多种导出格式（例如 OCI 或 Docker）以及前端支持（Dockerfile），并提供高效缓存和运行并行构建操作等功能。BuildKit 仅需要容器运行时就能执行，当前受支持的运行时包括 Containerd 和 Runc。
构建步骤优化 Docker 提供的原始构建最令人沮丧的问题之一是 Dockerfile 指令执行构建步骤的顺序性。在引入多阶段构建之后，可以将构建步骤分组为单独的逻辑构建任务在同一个 Dockerfile 中。
有时，这些构建阶段是彼此完全独立的，这意味着它们可以并行执行-或根本不需要执行。遗憾的是，传统的 Docker 镜像构建无法满足这种灵活性。这意味着构建时间通常会比绝对必要的时间更长。
相比之下，BuildKit 会创建一个构建步骤之间的依赖关系图，并使用该图来确定可以忽略构建的哪些元素;可以并行执行的元素;需要顺序执行的元素。这可以更有效地执行构建，这对开发人员来说很有价值，因为他们可以迭代其应用程序的镜像构建。
高效灵活的缓存 虽然在旧版 Docker 镜像构建中缓存构建步骤非常有用，但效率却不如预期。作为对构建后端的重写，BuildKit 在此方面进行了改进，并提供了更快，更准确的缓存机制。使用为构建生成的依赖关系图，并且基于指令定义和构建步骤内容。
BuildKit 提供的另一个巨大好处是以构建缓存导入和导出的形式出现，正如 Kaniko 和 Makisu 允许将构建缓存推送到远程注册表一样，BuildKit 也是如此，但是 BuildKit 使您可以灵活地将缓存嵌入到内部注册表中。镜像（内联）并将它们放在一起（虽然不是每个注册表都支持），或者将它们分开导入。也可以将缓存导出到本地目录以供以后使用。
当从头开始建立构建环境而没有任何先前的构建历史时，导入构建缓存的能力就发挥了自己的作用：导入“预热”缓存，对于临时 CI/CD 环境特别有用。
工件 当使用旧版 Docker 镜像构建器构建镜像时，将生成的镜像添加到 Docker 守护进程管理的本地镜像的缓存中。需要单独的docker push将该镜像上载到远程容器镜像注册表。新的工件构建工具通过允许您在构建调用时指定镜像推送来增强体验，BuildKit 也不例外，它还允许以几种不同格式输出镜像；本地目录中的文件，本地 tarball，一个本地 OCI 镜像 tarball，一个 Docker 镜像 tarball，一个存储在本地缓存中的 Docker 镜像以及一个推送到注册表的 Docker 镜像，有很多格式！</description></item><item><title>Dockerfile 样例</title><link>https://desistdaydream.github.io/docs/10.%E4%BA%91%E5%8E%9F%E7%94%9F/Containerization-implementation/%E6%9E%84%E5%BB%BA-OCI-Image/Dockerfile-%E6%A0%B7%E4%BE%8B/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/10.%E4%BA%91%E5%8E%9F%E7%94%9F/Containerization-implementation/%E6%9E%84%E5%BB%BA-OCI-Image/Dockerfile-%E6%A0%B7%E4%BE%8B/</guid><description>生成一个具有基本网络工具的容器，可以用来测试
FROM centos:centos7.8.2003 ENV LANG=zh_CN.UTF-8 \ LANGUAGE=zh_CN:zh \ LC_ALL=zh_CN.UTF-8 RUN yum install -y epel-release.noarch &amp;amp;&amp;amp; \ yum install -y iproute bind-utils nginx glibc-common tcpdump telnet &amp;amp;&amp;amp; \ yum clean all &amp;amp;&amp;amp; \ rm -rf /tmp/* rm -rf /var/cache/yum/* &amp;amp;&amp;amp; \ localedef -c -f UTF-8 -i zh_CN zh_CN.UTF-8 &amp;amp;&amp;amp; \ ln -sf /usr/share/zoneinfo/Asia/Shanghai /etc/localtime COPY index.html /usr/share/nginx/html EXPOSE 80/tcp CMD [&amp;#34;/usr/sbin/nginx&amp;#34;,&amp;#34;-g&amp;#34;,&amp;#34;daemon off;&amp;#34;] ~]# cat index.html &amp;lt;meta charset=&amp;#34;utf-8&amp;#34;/&amp;gt; &amp;lt;h1&amp;gt;网络测试容器 desist-daydream 1&amp;lt;/h1&amp;gt; 使用 alpine 版本让镜像更小</description></item></channel></rss>