<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>容器管理 on 断念梦的站点</title><link>https://desistdaydream.github.io/docs/10.%E4%BA%91%E5%8E%9F%E7%94%9F/Containerization-implementation/%E5%AE%B9%E5%99%A8%E7%AE%A1%E7%90%86/</link><description>Recent content in 容器管理 on 断念梦的站点</description><generator>Hugo</generator><language>zh-cn</language><atom:link href="https://desistdaydream.github.io/docs/10.%E4%BA%91%E5%8E%9F%E7%94%9F/Containerization-implementation/%E5%AE%B9%E5%99%A8%E7%AE%A1%E7%90%86/index.xml" rel="self" type="application/rss+xml"/><item><title>容器非root启动</title><link>https://desistdaydream.github.io/docs/10.%E4%BA%91%E5%8E%9F%E7%94%9F/Containerization-implementation/%E5%AE%B9%E5%99%A8%E7%AE%A1%E7%90%86/%E5%AE%B9%E5%99%A8%E9%9D%9Eroot%E5%90%AF%E5%8A%A8/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/10.%E4%BA%91%E5%8E%9F%E7%94%9F/Containerization-implementation/%E5%AE%B9%E5%99%A8%E7%AE%A1%E7%90%86/%E5%AE%B9%E5%99%A8%E9%9D%9Eroot%E5%90%AF%E5%8A%A8/</guid><description>概述 参考：
官方文档，Rootless 模式 容器非 root 启动改造的经验 参考：
zhangguanzhang，容器非 root 启动改造的经验 最近业务容器的非 root 启动改造实战案例经验，后续有新的也更新进来
改造 前提须知 这里列举些基础知识
使用 root 不安全的举例 虽然 linux 有 user namespace 隔离技术，但是 docker 不支持类似 podman 那样的给每个容器设置范围性的 uidmap 映射（当然 k8s 现在也不支持），并且容器默认配置下的权限虽然去掉了一些。但是容器内还是能对挂载进去的进行修改的，比如帖子 rm -rf * 前一定一定要看清当前目录 老哥的操作：
docker run --rm -v /mnt/sda1:/mnt/sda1 -it alpine cp /mnt/sda1/somefile.tar.gz . tar xzvf somefile.tar.gz cd somefile-v1.0 ls # 看了看内容觉得不是自己想要的，回上一级目录准备删掉： cd .. rm -rf * 嗯，alpine 默认的 workdir 是 / ，所以删除 rm -rf /*。当然还有其他不安全的，所以在业务角度上，我们需要给容器内进程设置在非 root 下最小的运行权限。</description></item><item><title>容器中使用 GPU</title><link>https://desistdaydream.github.io/docs/10.%E4%BA%91%E5%8E%9F%E7%94%9F/Containerization-implementation/%E5%AE%B9%E5%99%A8%E7%AE%A1%E7%90%86/%E5%AE%B9%E5%99%A8%E4%B8%AD%E4%BD%BF%E7%94%A8-GPU/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/10.%E4%BA%91%E5%8E%9F%E7%94%9F/Containerization-implementation/%E5%AE%B9%E5%99%A8%E7%AE%A1%E7%90%86/%E5%AE%B9%E5%99%A8%E4%B8%AD%E4%BD%BF%E7%94%A8-GPU/</guid><description>概述 参考：
Nvidia 参考：
Nvidia 官方文档，容器工具包 - 安装指南 安装 Container Toolkit(容器工具包，简称 ctk)
Notes: 若不安装 ctk，启动容器指定 GPU 时将会报错: docker: Error response from daemon: could not select device driver &amp;quot;&amp;quot; with capabilities: [[gpu]]. 3
Ubuntu
curl -fsSL https://nvidia.github.io/libnvidia-container/gpgkey | sudo gpg --dearmor -o /usr/share/keyrings/nvidia-container-toolkit-keyring.gpg \ &amp;amp;&amp;amp; curl -s -L https://nvidia.github.io/libnvidia-container/stable/deb/nvidia-container-toolkit.list | \ sed &amp;#39;s#deb https://#deb [signed-by=/usr/share/keyrings/nvidia-container-toolkit-keyring.gpg] https://#g&amp;#39; | \ sudo tee /etc/apt/sources.list.d/nvidia-container-toolkit.list apt update apt install -y nvidia-container-toolkit 最佳实践 Docker 19.03，增加了对&amp;ndash;gpus 选项的支持，我们在 docker 里面想读取 nvidia 显卡再也不需要额外的安装 nvidia-docker 了，下面开始实战 安装 nvidia-container-runtime： 查看官网（https://nvidia.</description></item><item><title>容器镜像管理</title><link>https://desistdaydream.github.io/docs/10.%E4%BA%91%E5%8E%9F%E7%94%9F/Containerization-implementation/%E5%AE%B9%E5%99%A8%E7%AE%A1%E7%90%86/%E5%AE%B9%E5%99%A8%E9%95%9C%E5%83%8F%E7%AE%A1%E7%90%86/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/10.%E4%BA%91%E5%8E%9F%E7%94%9F/Containerization-implementation/%E5%AE%B9%E5%99%A8%E7%AE%A1%E7%90%86/%E5%AE%B9%E5%99%A8%E9%95%9C%E5%83%8F%E7%AE%A1%E7%90%86/</guid><description>概述 参考:
镜像加速 参考：
https://gist.github.com/y0ngb1n/7e8f16af3242c7815e7ca2f0833d3ea6 由于众所周知的原因，国内从 Docker Hub 拉取镜像会遇到困难，此时可以配置镜像加速器。
https://dockerproxy.com https://docker.m.daocloud.io https://github.com/DaoCloud/public-image-mirror 阿里云: https://&amp;lt;你的ID&amp;gt;.mirror.aliyuncs.com https://cr.console.aliyun.com/cn-hangzhou/instances/mirrors 2024-06-06 后不再可用 科大镜像: https://docker.mirrors.ustc.edu.cn/ 网易: https://hub-mirror.c.163.com/ 七牛云加速器: https://reg-mirror.qiniu.com 2024 年 6 月 6 日，中国加大封锁力度，所有镜像源先后下架不再提供服务。
https://x.com/whyyoutouzhele/status/1798731317322133642 https://linux.do/t/topic/106872 https://mp.weixin.qq.com/s/pXrxedldKOoD97bMDYy3pQ https://docker.m.daocloud.io 还能用来 pull 到一部分主流镜像
2024 年 9 月 10 日，可以不通过代理直接从 dockerhub pull 到镜像
可用镜像站点 &amp;#34;registry-mirrors&amp;#34;: [ &amp;#34;https://docker.m.daocloud.io&amp;#34;, &amp;#34;https://dockerhub.icu&amp;#34;, &amp;#34;https://docker.1panel.live&amp;#34;, &amp;#34;https://docker.anyhub.us.kg&amp;#34;, &amp;#34;https://dhub.kubesre.xyz&amp;#34; ], https://github.com/kubesre/docker-registry-mirrors
Skopeo 参考：
GitHub 项目，containers/skopeo https://www.modb.pro/db/251368 https://blog.k8s.li/skopeo.html Skopeo 是一个命令行客户端应用程序，可以对容器镜像和镜像存储库执行各种操作。
Syntax(语法) skopeo [FLAGS] COMMAND
list-tags - 列出指定镜像的所有 Tags sync - 同步一个或多个镜像从一个位置到另一个位置 sync 子命令可以将容器镜像从一个地方拷贝到另一个地方。</description></item><item><title>使用 Tini 清理 Docker 容器僵死进程</title><link>https://desistdaydream.github.io/docs/10.%E4%BA%91%E5%8E%9F%E7%94%9F/Containerization-implementation/%E5%AE%B9%E5%99%A8%E7%AE%A1%E7%90%86/%E4%BD%BF%E7%94%A8-Tini-%E6%B8%85%E7%90%86-Docker-%E5%AE%B9%E5%99%A8%E5%83%B5%E6%AD%BB%E8%BF%9B%E7%A8%8B/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/10.%E4%BA%91%E5%8E%9F%E7%94%9F/Containerization-implementation/%E5%AE%B9%E5%99%A8%E7%AE%A1%E7%90%86/%E4%BD%BF%E7%94%A8-Tini-%E6%B8%85%E7%90%86-Docker-%E5%AE%B9%E5%99%A8%E5%83%B5%E6%AD%BB%E8%BF%9B%E7%A8%8B/</guid><description>使用 Tini 清理 Docker 容器僵死进程
最近在 Tini 的仓库下看到作者对 Tini 优势的精彩回复，搬运过来，粗糙翻译，献给拥有同样疑惑的你。
写在前面 我们在查看一些大项目的 Dockerfile 时经常发现，它们的 ENTRYPOINT 中往往都有 tini 的身影：
Rancher 官方镜像
Jenkins 官方镜像
那 Tini 到底是什么？为什么大家都喜欢在镜像中使用它呢？
开发者的疑问 我注意到 Jenkins 的官方镜像中使用了 Tini，所以我很好奇它是什么。它看起来一定很有用，可能解决了一些我不知道的问题。你能用 “说人话” 的方式简单解释一下 Tini 相对于直接以 CMD 运行 shell 脚本的优势吗？
我的几个容器的 ENTRYPOINT 都设置了一个 docker-entrypoint.sh 脚本，里面基本上都是以 “exec &amp;ldquo;$@&amp;quot;” 的方式在运行，我应该使用 Tini 来代替吗？
来自作者的回复 问得好！但这解释可能有点长，所以请耐心听我说（我知道你要求简短，但我真的做不到，捂脸~）。
首先，我们先简单聊聊 Jenkins。当您运行 Docker 容器时，Docker 会将它与系统的其他部分隔离开来。这种隔离发生在不同的级别（例如网络、文件系统、进程）。
但 Tini 并不真正关注网络或文件系统，所以让我们把注意力放在 Tini 的一个重要概念上：进程。
每个 Docker 容器都是一个 PID 命名空间，这意味着容器中的进程与主机上的其他进程是隔离的。PID 命名空间是一棵树，从 PID 1 开始，通常称为 init。</description></item></channel></rss>