<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>容器运行时管理 on 断念梦的站点</title><link>https://desistdaydream.github.io/docs/10.%E4%BA%91%E5%8E%9F%E7%94%9F/Containerization-implementation/%E5%AE%B9%E5%99%A8%E7%AE%A1%E7%90%86/%E5%AE%B9%E5%99%A8%E8%BF%90%E8%A1%8C%E6%97%B6%E7%AE%A1%E7%90%86/</link><description>Recent content in 容器运行时管理 on 断念梦的站点</description><generator>Hugo</generator><language>zh-cn</language><atom:link href="https://desistdaydream.github.io/docs/10.%E4%BA%91%E5%8E%9F%E7%94%9F/Containerization-implementation/%E5%AE%B9%E5%99%A8%E7%AE%A1%E7%90%86/%E5%AE%B9%E5%99%A8%E8%BF%90%E8%A1%8C%E6%97%B6%E7%AE%A1%E7%90%86/index.xml" rel="self" type="application/rss+xml"/><item><title>改变运行状态的容器配置</title><link>https://desistdaydream.github.io/docs/10.%E4%BA%91%E5%8E%9F%E7%94%9F/Containerization-implementation/%E5%AE%B9%E5%99%A8%E7%AE%A1%E7%90%86/%E5%AE%B9%E5%99%A8%E8%BF%90%E8%A1%8C%E6%97%B6%E7%AE%A1%E7%90%86/%E6%94%B9%E5%8F%98%E8%BF%90%E8%A1%8C%E7%8A%B6%E6%80%81%E7%9A%84%E5%AE%B9%E5%99%A8%E9%85%8D%E7%BD%AE/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/10.%E4%BA%91%E5%8E%9F%E7%94%9F/Containerization-implementation/%E5%AE%B9%E5%99%A8%E7%AE%A1%E7%90%86/%E5%AE%B9%E5%99%A8%E8%BF%90%E8%A1%8C%E6%97%B6%E7%AE%A1%E7%90%86/%E6%94%B9%E5%8F%98%E8%BF%90%E8%A1%8C%E7%8A%B6%E6%80%81%E7%9A%84%E5%AE%B9%E5%99%A8%E9%85%8D%E7%BD%AE/</guid><description>修改已创建容器的端口映射 参考：
公众号-进击云原生，骚操作！居然能修改已运行的 Docker 容器端口映射？ 其实吧。。。还是直接用 docker-compose 省事。
在 /var/lib/docker/containers/$(docker inspect ${容器名称} --format '{{.Id}}')/hostconfig.json 文件中找到 &amp;quot;PortBindings&amp;quot;:{} 字段 比如：
{ &amp;#34;PortBindings&amp;#34;: { &amp;#34;8502/tcp&amp;#34;: [ { &amp;#34;HostIp&amp;#34;: &amp;#34;&amp;#34;, &amp;#34;HostPort&amp;#34;: &amp;#34;8502&amp;#34; } ], &amp;#34;8505/tcp&amp;#34;: [ { &amp;#34;HostIp&amp;#34;: &amp;#34;&amp;#34;, &amp;#34;HostPort&amp;#34;: &amp;#34;8505&amp;#34; } ] } } 如果 config.v2.json 配置文件或者 config.json 文件也有关于端口的字段，也需要同步修改。只需要修改 &amp;quot;ExposedPorts&amp;quot;: {} 相关之处。 比如：
{ &amp;#34;Args&amp;#34;: [], &amp;#34;Config&amp;#34;: { &amp;#34;ExposedPorts&amp;#34;: { &amp;#34;8502/tcp&amp;#34;: {}, &amp;#34;8505/tcp&amp;#34;: {} }, &amp;#34;Entrypoint&amp;#34;: [&amp;#34;/bin/sh&amp;#34;] } } 修改完成后启动容器即可，这样就不用删除容器了。</description></item><item><title>进入容器文件系统</title><link>https://desistdaydream.github.io/docs/10.%E4%BA%91%E5%8E%9F%E7%94%9F/Containerization-implementation/%E5%AE%B9%E5%99%A8%E7%AE%A1%E7%90%86/%E5%AE%B9%E5%99%A8%E8%BF%90%E8%A1%8C%E6%97%B6%E7%AE%A1%E7%90%86/%E8%BF%9B%E5%85%A5%E5%AE%B9%E5%99%A8%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/10.%E4%BA%91%E5%8E%9F%E7%94%9F/Containerization-implementation/%E5%AE%B9%E5%99%A8%E7%AE%A1%E7%90%86/%E5%AE%B9%E5%99%A8%E8%BF%90%E8%A1%8C%E6%97%B6%E7%AE%A1%E7%90%86/%E8%BF%9B%E5%85%A5%E5%AE%B9%E5%99%A8%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/</guid><description>概述 参考：
公众号-CNCF，容器文件在哪？检查容器文件系统 如果你经常使用容器，那么你很有可能希望在某个时刻查看正在运行的容器的文件系统。也许容器无法正常运行，你想读取一些日志，也许你想检查容器内部的一些配置文件… 或者，你可能像我一样，想在该容器中的二进制文件上放置一些 eBPF 探针（稍后将详细介绍）。
不管原因是什么，在这篇文章中，我们将介绍一些可以用来检查容器中的文件的方法。
我们将从研究容器文件系统的简单和通常推荐的方法开始，并讨论为什么它们不能总是工作。接下来，我们将对 Linux 内核如何管理容器文件系统有一个基本的了解，我们将利用这一了解以不同但仍然简单的方式检查文件系统。
方法一：Exec 到容器中 如果你快速搜索如何检查容器的文件系统，你会发现一个常见的解决方案是使用 Docker 命令：
docker exec -it mycontainer /bin/bash 这是一个很好的开始。如果它能满足你的所有需求，你应该继续使用它。
然而，这种方法的一个缺点是，它需要在容器中存在一个 shell。如果容器中没有 / bin/bash、/bin/sh 或其他 shell，那么这种方法将不起作用。例如，我们为 Pixie 项目构建的许多容器都是基于无 distroless 的，并且没有包含一个 shell 来保持镜像较小。在这些情况下，这种方法不起作用。
即使 shell 可用，你也无法访问所有你习惯使用的工具。因此，如果容器中没有安装 grep，那么你也不能访问 grep。这是另一个找更好工作的理由。
方法二：使用 nsenter 如果你再深入一点，就会意识到容器进程与 Linux 主机上的其他进程一样，只是在命名空间中运行，以使它们与系统的其他部分隔离。
所以你可以使用 nsenter 命令来输入目标容器的命名空间，使用类似这样的东西：
# Get the host PID of the process in the container PID=$(docker container inspect mycontainer | jq &amp;#39;.[0].State.Pid&amp;#39;) # Use nsenter to go into the container’s mount namespace.</description></item><item><title>容器运行时管理</title><link>https://desistdaydream.github.io/docs/10.%E4%BA%91%E5%8E%9F%E7%94%9F/Containerization-implementation/%E5%AE%B9%E5%99%A8%E7%AE%A1%E7%90%86/%E5%AE%B9%E5%99%A8%E8%BF%90%E8%A1%8C%E6%97%B6%E7%AE%A1%E7%90%86/%E5%AE%B9%E5%99%A8%E8%BF%90%E8%A1%8C%E6%97%B6%E7%AE%A1%E7%90%86/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/10.%E4%BA%91%E5%8E%9F%E7%94%9F/Containerization-implementation/%E5%AE%B9%E5%99%A8%E7%AE%A1%E7%90%86/%E5%AE%B9%E5%99%A8%E8%BF%90%E8%A1%8C%E6%97%B6%E7%AE%A1%E7%90%86/%E5%AE%B9%E5%99%A8%E8%BF%90%E8%A1%8C%E6%97%B6%E7%AE%A1%E7%90%86/</guid><description>概述 参考：
容器运行时通常都是由实现容器的工具自己管理的，如果要说真正通用的管理，可能只有 runc 了，而 runc 本质就是通过类似 unshare、nsenter 等 Util-linux Utilities 包中的工具完成容器运行时的功能。
unshare - 创建 namesapce 参考：
Manual(手册)，unshare(1) Manual(手册)，unshare(2) 这是 System call 在新的 namespace 中运行程序。unshare 命令创建新的 namespace（由下面描述的命令行选项指定），然后执行指定的程序。如果未给出程序，则运行&amp;quot;${SHELL}&amp;quot;（默认值：/bin/sh）
nsenter - 使用其他进程的名称空间运行程序 参考：
Manual(手册)，nsenter(1) 就像这个工具的名字一样，nsenter(namespace enter)。进入一个或多个其他进程的名称空间，然后运行指定的程序。如果没有给出指定的程序(语法中的 PROGRAM)，则运行默认的 ${SHELL}。
Syntax(语法) nsenter [OPTIONS] [PROGRAM[ARGUMENTS]]
OPTIONS:
-a, &amp;ndash;all # 进入所有名称空间 -t, &amp;ndash;target &amp;lt;PID&amp;gt; # 指定要进入命名空间的目标进程的 PID -m, &amp;ndash;mount[=file]：进入 mount 命令空间。如果指定了 file，则进入 file 的命令空间 -u, &amp;ndash;uts[=file]：进入 uts 命令空间。如果指定了 file，则进入 file 的命令空间 -i, &amp;ndash;ipc[=file]：进入 ipc 命令空间。如果指定了 file，则进入 file 的命令空间 -n, &amp;ndash;net[=file]：进入 net 命令空间。如果指定了 file，则进入 file 的命令空间 -p, &amp;ndash;pid[=file]：进入 pid 命令空间。如果指定了 file，则进入 file 的命令空间 -U, &amp;ndash;user[=file]：进入 user 命令空间。如果指定了 file，则进入 file 的命令空间 -G, &amp;ndash;setgid gid：设置运行程序的 gid -S, &amp;ndash;setuid uid：设置运行程序的 uid -r, &amp;ndash;root[=directory]：设置根目录 -w, &amp;ndash;wd[=directory]：设置工作目录 EXAMPLE 从普通用户进入到 root 用户空间 sudo nsenter -t 1 -n 获取到容器的 PID docker inspect &amp;ndash;format &amp;ldquo;{{.</description></item></channel></rss>