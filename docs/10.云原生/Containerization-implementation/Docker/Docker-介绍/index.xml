<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Docker 介绍 on 断念梦的站点</title><link>https://desistdaydream.github.io/docs/10.%E4%BA%91%E5%8E%9F%E7%94%9F/Containerization-implementation/Docker/Docker-%E4%BB%8B%E7%BB%8D/</link><description>Recent content in Docker 介绍 on 断念梦的站点</description><generator>Hugo</generator><language>zh-cn</language><atom:link href="https://desistdaydream.github.io/docs/10.%E4%BA%91%E5%8E%9F%E7%94%9F/Containerization-implementation/Docker/Docker-%E4%BB%8B%E7%BB%8D/index.xml" rel="self" type="application/rss+xml"/><item><title>Docker 架构的演变</title><link>https://desistdaydream.github.io/docs/10.%E4%BA%91%E5%8E%9F%E7%94%9F/Containerization-implementation/Docker/Docker-%E4%BB%8B%E7%BB%8D/Docker-%E6%9E%B6%E6%9E%84%E7%9A%84%E6%BC%94%E5%8F%98/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/10.%E4%BA%91%E5%8E%9F%E7%94%9F/Containerization-implementation/Docker/Docker-%E4%BB%8B%E7%BB%8D/Docker-%E6%9E%B6%E6%9E%84%E7%9A%84%E6%BC%94%E5%8F%98/</guid><description>原文链接：https://blog.csdn.net/csdnnews/article/details/90746002
Docker 是如何工作的？这是一个简单的问题，但答案却是出乎意料的复杂。你可能很多次地听说过“守护进程(daemon)”和“运行时(runtime)”这两个术语，但可能从未真正理解它们的含义以及它们是如何配合在一起的。如果你像我一样，涉过源头去发现真相，那么，在你沉溺于代码之海时，你并不孤单。让我们面对现实吧，假想 Docker 的源代码是一顿意式大餐，而你正在狼吞虎咽你的美味意面。
就像一把叉子可以把面条送到你的口中，这篇文章会将 Docker 的技术的方方面面组织在一起并导入你饥饿的大脑。
为了更好地理解现在，我们首先需要回顾过去。2013 年，dotCloud 公司的 Solomon Hykes 在那年的 Python 大会上发表了 Linux 容器的未来的演讲（https://www.youtube.com/watch?v=wW9CAH9nSLs，需科学上网），第一次将 Docker 带入了公众的视线。让我们将他的 git 代码库回溯到 2013 年 1 月，这个 Docker 开发更轻松的时间。
Docker 2013 是如何工作的？
Docker 由两个主要组件组成，一个供用户使用的命令行应用程序和一个管理容器的守护进程。这个守护进程依赖两个子组件来执行它的任务：在宿主主机文件系统上用来存储镜像和容器数据的存储组件；以及用于抽象原始内核调用来构建 Linux 容器的 LXC 接口。
命令行应用程序
Docker 命令行应用程序是管理你的 Docker 运行副本已知的所有镜像和容器的人工界面。它相对简单，因为所有的管理都是由守护进程完成的。应用程序开始于一个 main 函数：
funcmain() { var err error ... // Example: &amp;#34;/var/run/docker.sock&amp;#34;, &amp;#34;run&amp;#34; conn, err := rcli.CallTCP(os.Getenv(&amp;#34;DOCKER&amp;#34;), os.Args[1:]...) ... receive_stdout := future.Go(func()error { _, err := io.Copy(os.Stdout, conn) return err }) .</description></item><item><title>docker-shim 何去何从</title><link>https://desistdaydream.github.io/docs/10.%E4%BA%91%E5%8E%9F%E7%94%9F/Containerization-implementation/Docker/Docker-%E4%BB%8B%E7%BB%8D/docker-shim-%E4%BD%95%E5%8E%BB%E4%BD%95%E4%BB%8E/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/10.%E4%BA%91%E5%8E%9F%E7%94%9F/Containerization-implementation/Docker/Docker-%E4%BB%8B%E7%BB%8D/docker-shim-%E4%BD%95%E5%8E%BB%E4%BD%95%E4%BB%8E/</guid><description>概述 关于 dockershim 即将灭亡的传言无疑存在严重夸大。如果一直有关注 Kubernetes 生态系统，很多朋友一时之间可能确实被 Kubernetes 1.20 版本的发布公告弄得有点不知所措。从公告内容来看，自 1.20 版本开始 dockershim 将被全面弃用。但请不要恐慌，调整呼吸，一切都会好起来。
更重要的是，Mirantis 现已同意与 Docker 开展合作，在 Kubernetes 之外独立维护 shim 代码并将其作为 Docker Engine API 的统一 CRI 接口。对于 Mirantis 客户而言，这意味着 Docker Engine 的商业支持版本 Mirantis Container Runtime（MCR）也将提供 CRI 兼容能力。我们将从https://github.com/dims/cri-d...，并逐步将其转化为开源项目https://github.com/Mirantis/c...。换句话说，你可以像之前一样继续基于 Docker Engine 构建 Kubernetes，唯一的区别就是 dockershim 由内置方案变成了外部方案。我们将共同努力，保证它在保持原有功能的同时，顺利通过各类一致性测试并提供与此前内置版本相同的使用体验。Mirantis 将在 Mirantis Kubernetes Engine 中使用 dockershim，Docker 方面也将在 Docker Desktop 中继续提供 dockershim。
从头说起……
用过 Kubernetes 的朋友都清楚，它的最大作用就是编排各类容器。对不少用户来说，容器已经与 Docker 完全统一了起来。但这种说法并不准确，Docker 本身只是彻底改变了容器技术并将其推向了通用舞台，因此 Docker Engine 也成为 Kubernetes 所支持的第一种（也是最初唯一一种）容器运行时。
但 Kubernetes 社区并不打算长期保持这样的状态。
从长远来看，社区希望能够使用多种不同类型的容器，因此参与者们创建了容器运行时接口（CRI），也就是容器引擎与 Kubernetes 间进行通信的标准方式。如果容器引擎与 CRI 相兼容，即可轻松在 Kubernetes 当中运行。</description></item></channel></rss>