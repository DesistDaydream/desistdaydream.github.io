<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Docker on 断念梦的站点</title><link>https://desistdaydream.github.io/docs/10.%E4%BA%91%E5%8E%9F%E7%94%9F/Containerization-implementation/Docker/</link><description>Recent content in Docker on 断念梦的站点</description><generator>Hugo</generator><language>zh-cn</language><atom:link href="https://desistdaydream.github.io/docs/10.%E4%BA%91%E5%8E%9F%E7%94%9F/Containerization-implementation/Docker/index.xml" rel="self" type="application/rss+xml"/><item><title>Docker</title><link>https://desistdaydream.github.io/docs/10.%E4%BA%91%E5%8E%9F%E7%94%9F/Containerization-implementation/Docker/Docker/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/10.%E4%BA%91%E5%8E%9F%E7%94%9F/Containerization-implementation/Docker/Docker/</guid><description>概述 参考：
官方文档，指南 官方文档，手册 官方文档，参考 Docker 是一个基于 Containerization(容器化) 的开放式平台，可以 开发、分享、运行应用程序。Docker 分为两个版本
Docker-CE # 社区版 Docker-EE # 商业版 Docker 为了解决 LXC 无法批量管理、复刻容器等问题应运而生，简化用户对容器的应用。Docker 是 Docker.inc 公司开源的一个基于 LXC 技术之上构建的 Container 引擎，不再使用模板技术，而是使用了 Docker Image 文件的方式来创建。Image 是放在统一的互联网仓库中，当需要使用 Container 的时候，直接 run 或者 creat 等即可从仓库中下载到该 Image，然后基于该 Image 再运行 Container。
Note：一开始，Docker 在 linux 上实现容器技术的后端使用的是 lxc，后来使用 runc 来代替。
Docker 架构 Docker 对使用者来讲是一个 C/S 模式的架构，Client 和 Server 使用 REST API 通过 UNIX Socket 或者网络进行通信。Compose 同样也可以作为客户端。
官方将这种架构称为 Docker Engine(引擎)，通常这个引擎具有：
一个 Server 进程 dockerd，长时间以 Daemon 形式运行 与 dockerd 通信的 API 一个 CLI 程序 docker dockerd 是实现容器能力的核心，用来管理 Docker Objects(Docker 对象)，e.</description></item><item><title>Docker 部署</title><link>https://desistdaydream.github.io/docs/10.%E4%BA%91%E5%8E%9F%E7%94%9F/Containerization-implementation/Docker/Docker-%E9%83%A8%E7%BD%B2/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/10.%E4%BA%91%E5%8E%9F%E7%94%9F/Containerization-implementation/Docker/Docker-%E9%83%A8%E7%BD%B2/</guid><description>概述 参考：
官方文档，安装-概述 Centos 安装 Ubuntu 安装 二进制安装 安装 Docker 套件 方法 1：使用 Linux 的包管理器安装 使用包管理器安装 # centos yum install -y yum-utils device-mapper-persistent-data lvm2 yum-config-manager --add-repo http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo yum install -y docker-ce # ubuntu sudo apt-get -y install apt-transport-https ca-certificates curl gnupg-agent software-properties-common curl -fsSL https://repo.huaweicloud.com/docker-ce/linux/ubuntu/gpg | sudo apt-key add - sudo add-apt-repository &amp;#34;deb [arch=amd64] https://repo.huaweicloud.com/docker-ce/linux/ubuntu $(lsb_release -cs) stable&amp;#34; sudo apt-get -y update sudo apt-get -y install docker-ce 若 centos8 提示无法安装 contained.</description></item><item><title>Docker Configuration</title><link>https://desistdaydream.github.io/docs/10.%E4%BA%91%E5%8E%9F%E7%94%9F/Containerization-implementation/Docker/Docker-Configuration/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/10.%E4%BA%91%E5%8E%9F%E7%94%9F/Containerization-implementation/Docker/Docker-Configuration/</guid><description>概述 参考：
官方文档，参考 - 命令行参考 - Daemon CLI https://blog.csdn.net/u013948858/article/details/79974796 Docker 的守护进程为 dockerd，dockerd 可以通过两种方式配置运行时行为
/etc/docker/daemon.json 配置文件 dockerd 命令的 flags ，可以将 flags 添加到 dockerd.service 中。 [!Note] 配置文件中的配置，也可以通过 dockerd 的命令行参数(也就是 flags)指定，比如配置文件中的 data-root 字段，对应的 dockerd flags 为 &amp;ndash;data-root
配置文件示例 dockerd 配置文件是 JSON 格式，基本常用的配置内容如下。
{ // 指定 docker pull 时，首先去连接的 registry。 &amp;#34;registry-mirrors&amp;#34;: [ &amp;#34;http://172.38.40.180&amp;#34;, &amp;#34;https://ac1rmo5p.mirror.aliyuncs.com&amp;#34; ], // 指定运行 docker 操作的不安全的 registry 的列表 &amp;#34;insecure-registries&amp;#34;: [&amp;#34;http://172.38.40.180&amp;#34;], // 指定 docker 运行时其他的选项，这里面指定 docker 的 cgroupdriver 为 systemd &amp;#34;exec-opts&amp;#34;: [&amp;#34;native.cgroupdriver=systemd&amp;#34;], // 指定 docker 的日志驱动为 json-file &amp;#34;log-driver&amp;#34;: &amp;#34;json-file&amp;#34;, // 指定 docker 记录容器日志的参数，这里指定容器日志文件大小最大为100m &amp;#34;log-opts&amp;#34;: { &amp;#34;max-size&amp;#34;: &amp;#34;100m&amp;#34; }, // 指定 docker 的存储驱动类型为 overlay2 &amp;#34;storage-driver&amp;#34;: &amp;#34;overlay2&amp;#34;, // 指定 docker 存储驱动的其他选项 &amp;#34;storage-opts&amp;#34;: [&amp;#34;overlay2.</description></item><item><title>Docker Image</title><link>https://desistdaydream.github.io/docs/10.%E4%BA%91%E5%8E%9F%E7%94%9F/Containerization-implementation/Docker/Docker-Image/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/10.%E4%BA%91%E5%8E%9F%E7%94%9F/Containerization-implementation/Docker/Docker-Image/</guid><description>概述 参考：
思否，走进docker(02)：image(镜像)是什么？ 在虚拟化中，运行程序的地方是一个虚拟的操作系统。而容器技术中，运行程序的地方是一个容器 image(镜像)。
容器的镜像与虚拟机的虚拟系统有异曲同工之妙，基本原理相似，只不过虚拟系统可以像正常安装系统一样进行安装，而容器镜像，则是一个已经打包好的操作系统，可以开箱即用。
由于这种构造，docker 公司研究出一种技术，就是联合文件系统(UnionFS(Union File System))。可以将镜像分为多层(layers)，每层附加一个功能。
实现联合文件系统的驱动程序：docker 本身支持 overlay，overlay2，aufs，btrfs，devicemapper，vfs 等
Container Image 的分层结构(联合文件系统) http://www.cnblogs.com/CloudMan6/p/6806193.html
Container Image 采用分层结构，最底层为 bootfs，其它为 rootfs
bootfs：用于系统引导的文件系统，包括 bootloader 和 kernel，Container 启动完成后会被卸载以节约内存资源 rootfs：位于 bootfs 之上，表现为 Container 的根文件系统； 传统模式中，系统启动时，内核挂载 rootfs 时会先将其挂载为只读模式，完整性自检完成后将其重新挂载为读写模式。 docker 中，rootfs 由内核挂载为“只读”模式，然后通过“联合挂载”技术额外挂载一个“可写(writable)”层。 可以这么理解：
通过一个 Base Image 启动了一个 Container，然后安装一个 vim 编辑器，commit 这个 container，生成的新镜像就是两层，第一层是系统，第二层是 vim。 这时候用这个这个新的 image 启动一个 Container 后，再安装一个 Nginx，然后 commit 这个 Container，生成的新镜像就是三层，1 系统、2vim、3nginx。 以此类推，每一次 Container 的变化被 commit 后都可以当作一层。 对 Container 的操作产生的变化，是在可写的容器层中进行的 可写(writable)的层(layers) 当容器启动时，一个新的“可读写”层被加载到镜像的顶部。这一层通常被称作“容器层”，“容器层”之下的都叫“镜像层”。位于下层的 image 称为父镜像(parent image)，最底层的称为基础镜像(base image)</description></item><item><title>Docker Runtime</title><link>https://desistdaydream.github.io/docs/10.%E4%BA%91%E5%8E%9F%E7%94%9F/Containerization-implementation/Docker/Docker-Runtime/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/10.%E4%BA%91%E5%8E%9F%E7%94%9F/Containerization-implementation/Docker/Docker-Runtime/</guid><description>概述 参考：
官方文档，引擎 - 替换 runtime Docker Runtime 和 Docker Image 一样，也有标准，也由 OCI 维护，官方详解地址为：runtime-spec。Docker 默认使用 Containerd 来控制 Container 的配置、执行环境和生命周期，包括创建、启动和停止容器。Containerd 默认使用 runc 作为其容器运行时。
容器的配置被指定为 config.json ，并详细说明了可以创建容器的字段。指定执行环境是为了确保容器内运行的应用程序在运行时之间具有一致的环境，以及为容器的生命周期定义的常见操作。
runtime 规范有如下几个，所有人必须遵守该规范来使用 runtime 。
Filesystem Bundle # 文件系统捆绑。bundle 是以某种方式组织的一组文件，包含了容器所需要的所有信息，有了这个 bundle 后，符合 runtime 标准的程序(e.g.runc)就可以根据 bundle 启动容器了(哪怕没有 docker，也可以启动一个容器)。 Runtime and Lifecycle # Linux-specific Runtime and Lifecycle # 这是关于 linux 平台的 Runtime 与 Lifecycle Configuration # Configuration 包含对容器执行标准操作(比如 create、start、stop 等)所必须的元数据。这包括要运行的过程、要注入的环境变量、要使用的沙盒功能等等。不同平台(linux、window 等)，有不同的规范。 Linux-specific configuration # 这是关于 linux 平台的 Configuration Docker create 有了 image 之后，就可以使用 image 来创建并启动 container 了。</description></item><item><title>Docker API</title><link>https://desistdaydream.github.io/docs/10.%E4%BA%91%E5%8E%9F%E7%94%9F/Containerization-implementation/Docker/Docker-API/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/10.%E4%BA%91%E5%8E%9F%E7%94%9F/Containerization-implementation/Docker/Docker-API/</guid><description>概述 参考：
官方文档，参考 - API - 引擎 Docker API 官方文档：https://docs.docker.com/engine/api/latest/</description></item><item><title>Docker Network</title><link>https://desistdaydream.github.io/docs/10.%E4%BA%91%E5%8E%9F%E7%94%9F/Containerization-implementation/Docker/Docker-Network/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/10.%E4%BA%91%E5%8E%9F%E7%94%9F/Containerization-implementation/Docker/Docker-Network/</guid><description>概述 参考：
官方文档，引擎 - 网络 DNS 容器连接到默认网络时，会使用与主机相同的 DNS Server，继承主机的 /etc/resolv.conf。
容器连接到自定义网络时，会使用 Docker 内嵌的 DNS Server（127.0.0.11:53），将 容器 ID、容器名、别名 注册为 DNS 解析记录，以便其他容器可以通过这些域名访问到自己。示例可以参考下文 ”Bridge“ 驱动程序中的示例
Docker 网络的驱动程序 https://docs.docker.com/engine/network/drivers/
Docker 使用驱动程序实现网络子系统的核心能力，网络子系统是可插拔的。默认存在如下几种驱动程序：
bridge # 默认驱动程序。当应用程序在需要与同一主机上的其他容器通信的容器中运行时，通常会使用 Bridge(桥接) 网络。 host # 取消容器与 Docker 主机之间的网络隔离，直接使用主机的网络 overlay ipvlan macvlan none # 容器与宿主机及其他容器完全隔离。 none 不适用于 Swarm 服务。用人话说就是不使用任何网络驱动程序。 网络插件：我们可以安装和使用第三方网络插件，以实现 Docker 自身无法实现的网络功能 Bridge https://docs.docker.com/engine/network/drivers/bridge
当 Docker 启动时，会自动创建一个名为 brdige，Bridge 驱动类型的网络。默认情况下新启动的容器都会连接到 bridge 网络。
~]# docker network ls NETWORK ID NAME DRIVER SCOPE dadd048eefa0 bridge bridge local 84cab5ef9276 host host local 4718cdfcb116 monitoring bridge local 4d68f227ca5d none null local Notes: 名为 bridge 的是默认 Bridge 类型网络；名为 monitoring 的是用户自定义的 Bridge 类型网络。</description></item><item><title>Docker Storage</title><link>https://desistdaydream.github.io/docs/10.%E4%BA%91%E5%8E%9F%E7%94%9F/Containerization-implementation/Docker/Docker-Storage/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/10.%E4%BA%91%E5%8E%9F%E7%94%9F/Containerization-implementation/Docker/Docker-Storage/</guid><description>概述 参考：
官方文档，在生产环境运行你的应用 - 管理应用数据 - 存储概述 当关闭并重启 Container 的时候，其内的数据不受影响；但删除 Docker 容器后，则其内对最上面的可写层操作的内容则全部丢失，这时候会存在几个问题
存储于联合文件系统中，不易于宿主机访问 容器间数据共享不便 删除容器会使数据丢失 为了解决这些问题，可以通过三种 Storage 方式来将文件存储于宿主机中
volume volume 类型的 storage 是通过 docker volume 命令显式得创建一个抽象的内容，创建完一个 volume 会，会在 /var/lib/docker/volumes/* 目录下生成与 volume 同名的目录，在将 volume 挂载进 Container 中时，也就是将 /var/lib/docker/volmes/XXX 目录挂载进去。非 Docker 进程不应修改文件系统的这一部分。卷是在 Docker 中持久保存数据的最佳方法。 bind mounts 可以存储在主机系统上的任何位置。它们甚至可能是重要的系统文件或目录。Docker 主机或 Docker 容器上的非 Docker 进程可以随时对其进行修改。 tmpfs mount 仅存储在主机系统的内存中，并且永远不会写入主机系统的文件系统中。 无论使用哪种方式，目的都是让宿主机上的某个“目录或者文件”绕过联合文件系统，与 Container 中的一个或多个“目录或文件”绑定，对目录中的操作，在 Container 和 Host 中都能看到(i.e.在宿主机目录中创建一个文件，Container 中对应的目录也会看到这个文件)，一个 Volume 可以绑定到多个 Container 上去。
这三种方式唯一的差异就是数据在 docker 宿主机上的位置，bind mount 和 volume 会在宿主机的文件系统中、而 tmpfs mount 则在宿主机的内存中。如下图所示：</description></item><item><title>Docker 权限管理</title><link>https://desistdaydream.github.io/docs/10.%E4%BA%91%E5%8E%9F%E7%94%9F/Containerization-implementation/Docker/Docker-%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/10.%E4%BA%91%E5%8E%9F%E7%94%9F/Containerization-implementation/Docker/Docker-%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86/</guid><description>概述 参考：
Docker Capabilities Capabilities 详见 Linux Capabilities 权限管理章节
我们说 Docker 容器本质上就是一个进程，所以理论上容器就会和进程一样会有一些默认的开放权限，默认情况下 Docker 会删除必须的 capabilities 之外的所有 capabilities，因为在容器中我们经常会以 root 用户来运行，使用 capabilities 现在后，容器中的使用的 root 用户权限就比我们平时在宿主机上使用的 root 用户权限要少很多了，这样即使出现了安全漏洞，也很难破坏或者获取宿主机的 root 权限，所以 Docker 支持 Capabilities 对于容器的安全性来说是非常有必要的。 不过我们在运行容器的时候可以通过指定 --privileded 参数来开启容器的超级权限，这个参数一定要慎用，因为他会获取系统 root 用户所有能力赋值给容器，并且会扫描宿主机的所有设备文件挂载到容器内部，所以是非常危险的操作。 但是如果你确实需要一些特殊的权限，我们可以通过 --cap-add 和 --cap-drop 这两个参数来动态调整，可以最大限度地保证容器的使用安全。下面表格中列出的 Capabilities 是 Docker 默认给容器添加的，我们可以通过 --cap-drop 去除其中一个或者多个： docker capabilities 下面表格中列出的 Capabilities 是 Docker 默认删除的，我们可以通过--cap-add添加其中一个或者多个： docker drop capabilities
--cap-add和--cap-drop 这两参数都支持ALL值，比如如果你想让某个容器拥有除了MKNOD之外的所有内核权限，那么可以执行下面的命令： $ sudo docker run --cap-add=ALL --cap-drop=MKNOD ...
比如现在我们需要修改网络接口数据，默认情况下是没有权限的，因为需要的 NET_ADMIN 这个 Capabilities 默认被移除了：</description></item></channel></rss>