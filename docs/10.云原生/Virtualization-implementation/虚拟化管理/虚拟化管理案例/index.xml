<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>虚拟化管理案例 on 断念梦的站点</title><link>https://desistdaydream.github.io/docs/10.%E4%BA%91%E5%8E%9F%E7%94%9F/Virtualization-implementation/%E8%99%9A%E6%8B%9F%E5%8C%96%E7%AE%A1%E7%90%86/%E8%99%9A%E6%8B%9F%E5%8C%96%E7%AE%A1%E7%90%86%E6%A1%88%E4%BE%8B/</link><description>Recent content in 虚拟化管理案例 on 断念梦的站点</description><generator>Hugo</generator><language>zh-cn</language><atom:link href="https://desistdaydream.github.io/docs/10.%E4%BA%91%E5%8E%9F%E7%94%9F/Virtualization-implementation/%E8%99%9A%E6%8B%9F%E5%8C%96%E7%AE%A1%E7%90%86/%E8%99%9A%E6%8B%9F%E5%8C%96%E7%AE%A1%E7%90%86%E6%A1%88%E4%BE%8B/index.xml" rel="self" type="application/rss+xml"/><item><title>创建虚拟机及创建后常见操作</title><link>https://desistdaydream.github.io/docs/10.%E4%BA%91%E5%8E%9F%E7%94%9F/Virtualization-implementation/%E8%99%9A%E6%8B%9F%E5%8C%96%E7%AE%A1%E7%90%86/%E8%99%9A%E6%8B%9F%E5%8C%96%E7%AE%A1%E7%90%86%E6%A1%88%E4%BE%8B/%E5%88%9B%E5%BB%BA%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%8F%8A%E5%88%9B%E5%BB%BA%E5%90%8E%E5%B8%B8%E8%A7%81%E6%93%8D%E4%BD%9C/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/10.%E4%BA%91%E5%8E%9F%E7%94%9F/Virtualization-implementation/%E8%99%9A%E6%8B%9F%E5%8C%96%E7%AE%A1%E7%90%86/%E8%99%9A%E6%8B%9F%E5%8C%96%E7%AE%A1%E7%90%86%E6%A1%88%E4%BE%8B/%E5%88%9B%E5%BB%BA%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%8F%8A%E5%88%9B%E5%BB%BA%E5%90%8E%E5%B8%B8%E8%A7%81%E6%93%8D%E4%BD%9C/</guid><description>概述 使用 virt-install 在 CLI 创建 VM 时指定 vnc 并监听在 0.0.0.0 上。使用实例中最简单的命令即可，最简单的命令只需要指定网络、连接显示的方式、系统版本、cpu、内存即可，其他虚拟设备都会又 virt-install 自动添加。并不影响性能和使用等方面。
使用 VNC 客户端连接 VM 并安装操作系统。
安装完成后，根据虚拟化调试和优化指南调优，virsh edit XXX 修改文件
使用 systemctl enable serial-getty@ttyS0.service --now 启动 serial-getty 服务，以便通过 virsh console 命令连接虚拟机
压缩 qcow2 文件，创建 backing file 的 qcow2 和 xml 文件当做模板以便批量创建虚拟机所用
qemu-img convert -c -O qcow2 test.qcow2 test.qcow2.new</description></item><item><title>扩大 KVM 虚拟机 image 镜像</title><link>https://desistdaydream.github.io/docs/10.%E4%BA%91%E5%8E%9F%E7%94%9F/Virtualization-implementation/%E8%99%9A%E6%8B%9F%E5%8C%96%E7%AE%A1%E7%90%86/%E8%99%9A%E6%8B%9F%E5%8C%96%E7%AE%A1%E7%90%86%E6%A1%88%E4%BE%8B/%E6%89%A9%E5%A4%A7-KVM-%E8%99%9A%E6%8B%9F%E6%9C%BA-image-%E9%95%9C%E5%83%8F/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/10.%E4%BA%91%E5%8E%9F%E7%94%9F/Virtualization-implementation/%E8%99%9A%E6%8B%9F%E5%8C%96%E7%AE%A1%E7%90%86/%E8%99%9A%E6%8B%9F%E5%8C%96%E7%AE%A1%E7%90%86%E6%A1%88%E4%BE%8B/%E6%89%A9%E5%A4%A7-KVM-%E8%99%9A%E6%8B%9F%E6%9C%BA-image-%E9%95%9C%E5%83%8F/</guid><description>概述 直接使用 qemu-img resize 的时候一定要先备份镜像。先使用 virsh shutdown VM 关闭镜像再进行如下操作：
给原始系统文件添加磁盘空间 qemu-img resize centos7-baseImage-50G.qcow2 +500G 进入虚拟机操作新建硬盘分区 parted /dev/vda mkpart primary XXX 100%(XX 改为指定的最后一块扇区的容量) 扩容 LVM，注意/dev/vda4 设备为真实情况的设备名称，注意修改 partprobe(可能还需要重启) pvcreate /dev/vda4 vgextend vg0 /dev/vda4 lvextend -l+100%FREE /dev/mapper/vg0-root 这里可以使用 lvextend -l +单元数量 /dev/mapper/vg0-lv101 扩展文件系统大小，注意 /dev/mapper/vg0-root 修改为真实情况的分区路径 XFS 文件系统 xfs_growfs /dev/mapper/vg0-root EXT 文件系统 resize2fs /dev/mapper/vg0-root (-f 强制扩展)</description></item><item><title>通过 veth 设备查找对应的虚拟机</title><link>https://desistdaydream.github.io/docs/10.%E4%BA%91%E5%8E%9F%E7%94%9F/Virtualization-implementation/%E8%99%9A%E6%8B%9F%E5%8C%96%E7%AE%A1%E7%90%86/%E8%99%9A%E6%8B%9F%E5%8C%96%E7%AE%A1%E7%90%86%E6%A1%88%E4%BE%8B/%E9%80%9A%E8%BF%87-veth-%E8%AE%BE%E5%A4%87%E6%9F%A5%E6%89%BE%E5%AF%B9%E5%BA%94%E7%9A%84%E8%99%9A%E6%8B%9F%E6%9C%BA/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/10.%E4%BA%91%E5%8E%9F%E7%94%9F/Virtualization-implementation/%E8%99%9A%E6%8B%9F%E5%8C%96%E7%AE%A1%E7%90%86/%E8%99%9A%E6%8B%9F%E5%8C%96%E7%AE%A1%E7%90%86%E6%A1%88%E4%BE%8B/%E9%80%9A%E8%BF%87-veth-%E8%AE%BE%E5%A4%87%E6%9F%A5%E6%89%BE%E5%AF%B9%E5%BA%94%E7%9A%84%E8%99%9A%E6%8B%9F%E6%9C%BA/</guid><description>概述 通过 xml 文件查看虚拟机的 mac 地址
~]# grep &amp;#34;mac addr&amp;#34; lchTest.xml &amp;lt;mac address=&amp;#39;52:54:00:6a:86:89&amp;#39;/&amp;gt; 筛选网络设备 mac
~]# ip a | grep &amp;#34;86:89&amp;#34; -B 1 127: vnet1: &amp;lt;BROADCAST,MULTICAST,UP,LOWER_UP&amp;gt; mtu 1500 qdisc pfifo_fast master br1 state UNKNOWN group default qlen 1000 link/ether fe:54:00:6a:86:89 brd ff:ff:ff:ff:ff:ff 由此可见，vnet 设备的 mac 与虚拟机的 mac 在后面几位是永远保持一致的，所以可以通过 vnet 设备的 mac ，从所有虚拟机中的 xml 进行筛选就行可以找到 vnet 设备对应的虚拟机了。
应用实例 比如我现在能看到 4 个 vnet 设备。
~]# ip a ..... 62: vnet3: &amp;lt;BROADCAST,MULTICAST,UP,LOWER_UP&amp;gt; mtu 1500 qdisc pfifo_fast master br1 state UNKNOWN group default qlen 1000 link/ether fe:54:00:5c:11:85 brd ff:ff:ff:ff:ff:ff inet6 fe80::fc54:ff:fe5c:1185/64 scope link valid_lft forever preferred_lft forever 79: vnet0: &amp;lt;BROADCAST,MULTICAST,UP,LOWER_UP&amp;gt; mtu 1500 qdisc mq master br1 state UNKNOWN group default qlen 1000 link/ether fe:54:00:68:20:51 brd ff:ff:ff:ff:ff:ff inet6 fe80::fc54:ff:fe68:2051/64 scope link valid_lft forever preferred_lft forever 127: vnet1: &amp;lt;BROADCAST,MULTICAST,UP,LOWER_UP&amp;gt; mtu 1500 qdisc pfifo_fast master br1 state UNKNOWN group default qlen 1000 link/ether fe:54:00:6a:86:89 brd ff:ff:ff:ff:ff:ff inet6 fe80::fc54:ff:fe6a:8689/64 scope link valid_lft forever preferred_lft forever 139: vnet2: &amp;lt;BROADCAST,MULTICAST,UP,LOWER_UP&amp;gt; mtu 1500 qdisc pfifo_fast master br1 state UNKNOWN group default qlen 1000 link/ether fe:54:00:3a:95:ef brd ff:ff:ff:ff:ff:ff inet6 fe80::fc54:ff:fe3a:95ef/64 scope link valid_lft forever preferred_lft forever 我想看看 vnet3 是关联到哪个虚拟机上了，就可以进行如下操作：(首先看到 vnet3 的 mac 为 fe:54:00:5c:11:85)</description></item><item><title>在线热迁移</title><link>https://desistdaydream.github.io/docs/10.%E4%BA%91%E5%8E%9F%E7%94%9F/Virtualization-implementation/%E8%99%9A%E6%8B%9F%E5%8C%96%E7%AE%A1%E7%90%86/%E8%99%9A%E6%8B%9F%E5%8C%96%E7%AE%A1%E7%90%86%E6%A1%88%E4%BE%8B/%E8%99%9A%E6%8B%9F%E6%9C%BA%E8%BF%81%E7%A7%BB/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/10.%E4%BA%91%E5%8E%9F%E7%94%9F/Virtualization-implementation/%E8%99%9A%E6%8B%9F%E5%8C%96%E7%AE%A1%E7%90%86/%E8%99%9A%E6%8B%9F%E5%8C%96%E7%AE%A1%E7%90%86%E6%A1%88%E4%BE%8B/%E8%99%9A%E6%8B%9F%E6%9C%BA%E8%BF%81%E7%A7%BB/</guid><description>概述 参考：
Libvirt 文档，Guest 迁移 客人在主机之间迁移是一个复杂的问题，有许多可能的解决方案，每种解决方案都有自己的优点和缺点。为了实现虚拟机管理程序集成和管理员部署的最大灵活性，libvirt 实现了多种迁移选项。
手动迁移示例 拷贝如下几个文件
/var/lib/libvirt/images/ 目录中的 qcow2 文件 /etc/libvirt/qemy/ 目录中的 xml 文件 /var/lib/libvirt/qemu/snapshot/ 目录中的以 VM 命令的 snapshot 目录 使用 virsh define XXX.xml 命令创建虚拟机
使用 virsh snapshot-create --redefine --xmlfile XXX.xml DOMAIN 命令为虚拟机还原快照的元数据
也可以在 define 虚拟机后，再将 snapshot/ 目录下目录拷贝过来，也是可以识别到的。之所以要 define 后再拷贝，是因为 define 时将会清空 snapshot/${VM_NAME}/ 目录。 KVM 实现虚拟机在线热迁移 参考：
51CTO，KVM 实现虚拟机在线热迁移 KVM 虚拟机的迁移有两种方法：
静态迁移（冷迁移）：对于冷迁移，就是在虚拟机关闭状态下，将虚拟机的磁盘文件及.xml 配置文件（这两个文件组成了一个虚拟机）复制到要迁移到的目标主机上，然后在目标主机上使用“virsh define *.xml”命令重新定义虚拟机即可。 动态迁移（热迁移）：对于热迁移，比较常用，通常是这台服务器上正在跑着一些业务，而这些业务又不允许中断，那么就需要使用热迁移了，这篇博文将详细写出热迁移的步骤。 1、冷迁移
通常我们存放虚拟机磁盘的目录都是挂在的一个 nfs 文件系统的磁盘，而这个磁盘通常是 LVM 文件系统。所以需要进行冷迁移时，只要在目标主机上挂载这个 nfs 文件系统，就可以看到要迁移的那个虚拟机的磁盘文件，通常以.qcow2 或.raw 结尾的，然后，只需将虚拟机的.xml 配置文件发送到目标服务器上，然后重新定义一下即可通过“virsh list &amp;ndash;all”命令查看到迁移过来的虚拟机。</description></item><item><title>克隆与批量创建虚拟机</title><link>https://desistdaydream.github.io/docs/10.%E4%BA%91%E5%8E%9F%E7%94%9F/Virtualization-implementation/%E8%99%9A%E6%8B%9F%E5%8C%96%E7%AE%A1%E7%90%86/%E8%99%9A%E6%8B%9F%E5%8C%96%E7%AE%A1%E7%90%86%E6%A1%88%E4%BE%8B/%E5%85%8B%E9%9A%86%E4%B8%8E%E6%89%B9%E9%87%8F%E5%88%9B%E5%BB%BA%E8%99%9A%E6%8B%9F%E6%9C%BA/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/10.%E4%BA%91%E5%8E%9F%E7%94%9F/Virtualization-implementation/%E8%99%9A%E6%8B%9F%E5%8C%96%E7%AE%A1%E7%90%86/%E8%99%9A%E6%8B%9F%E5%8C%96%E7%AE%A1%E7%90%86%E6%A1%88%E4%BE%8B/%E5%85%8B%E9%9A%86%E4%B8%8E%E6%89%B9%E9%87%8F%E5%88%9B%E5%BB%BA%E8%99%9A%E6%8B%9F%E6%9C%BA/</guid><description>概述 参考：
https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/7/html/virtualization_deployment_and_administration_guide/cloning-a-vm 注意：CentOS7 想要挂载 Ubuntu 20.04 虚拟机内的文件是不行的，内核不支持，报错如下：
~]# guestmount --rw -a /var/lib/libvirt/images/common-ubuntu-test.bj-test.qcow2 -m /dev/ubuntu-vg/lv-0 /mnt/test libguestfs: error: mount_options: mount exited with status 32: mount: wrong fs type, bad option, bad superblock on /dev/mapper/ubuntu--vg-lv--0, missing codepage or helper program, or other error In some cases useful info is found in syslog - try dmesg | tail or so. guestmount: ‘/dev/ubuntu-vg/lv-0’ could not be mounted. guestmount: Did you mean to mount one of these filesystems?</description></item><item><title>多宿主机集中管理</title><link>https://desistdaydream.github.io/docs/10.%E4%BA%91%E5%8E%9F%E7%94%9F/Virtualization-implementation/%E8%99%9A%E6%8B%9F%E5%8C%96%E7%AE%A1%E7%90%86/%E8%99%9A%E6%8B%9F%E5%8C%96%E7%AE%A1%E7%90%86%E6%A1%88%E4%BE%8B/%E5%A4%9A%E5%AE%BF%E4%B8%BB%E6%9C%BA%E9%9B%86%E4%B8%AD%E7%AE%A1%E7%90%86/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/10.%E4%BA%91%E5%8E%9F%E7%94%9F/Virtualization-implementation/%E8%99%9A%E6%8B%9F%E5%8C%96%E7%AE%A1%E7%90%86/%E8%99%9A%E6%8B%9F%E5%8C%96%E7%AE%A1%E7%90%86%E6%A1%88%E4%BE%8B/%E5%A4%9A%E5%AE%BF%E4%B8%BB%E6%9C%BA%E9%9B%86%E4%B8%AD%E7%AE%A1%E7%90%86/</guid><description>概述 参考：
除了 OpenStack 以外，市面上没有多少可以批量管理 KVM 主机的项目 o(╯□╰)o 唯一能搜到的只有一个 WebVirtCloud ~~~~
为什么要用 Python 写前端呢。。。裂开了。。。。o(╯□╰)o
WebVirtCloud 参考：
GitHub 项目，retspen/webvirtmgr(已于 2018 年停止更新，被 webvirtcloud 代替) GitHub 项目，retspen/webvirtcloud WebVirtCloud 是一个由 Python 的 Web 框架 Django 编写的前后端一体项目。
WebVirtCloud 有多个组件
Nginx 监听 80 端口，入口，用来响应 /static/ 下的各种静态资源 Webvirtcloud 监听 8000 端口，处理 IP:PORT/ 路径的访问请求，展示出的进程名为 gunicorn Gunicorn(Green Unicorn) 是一个 UNIX 下符合 WSGI 规范的 HTTP 服务器(说简单点就是一个类似 Nginx 程序)。 WSGI 指定了“web 服务器”和“Python web 应用/ web 框架”之间的标准接口，以提高 web 应用在一系列 web 服务器间的移植性。 Novnc 监听 6080 端口，处理 IP:PORT/novncd/ 路径的访问请求，展示出的进程名为 novncd WebVirtCloud 在容器中通过老式的 runsvdir 运行，runsvdir 会读取 -P 选项指定的目录，可以看到，runsv 程序后的参数，就是 /etc/service/ 目录下的目录名</description></item></channel></rss>