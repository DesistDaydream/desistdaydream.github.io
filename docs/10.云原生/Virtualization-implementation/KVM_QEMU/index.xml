<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>KVM/QEMU on 断念梦的站点</title><link>https://desistdaydream.github.io/docs/10.%E4%BA%91%E5%8E%9F%E7%94%9F/Virtualization-implementation/KVM_QEMU/</link><description>Recent content in KVM/QEMU on 断念梦的站点</description><generator>Hugo</generator><language>zh-cn</language><atom:link href="https://desistdaydream.github.io/docs/10.%E4%BA%91%E5%8E%9F%E7%94%9F/Virtualization-implementation/KVM_QEMU/index.xml" rel="self" type="application/rss+xml"/><item><title>KVM/QEMU</title><link>https://desistdaydream.github.io/docs/10.%E4%BA%91%E5%8E%9F%E7%94%9F/Virtualization-implementation/KVM_QEMU/KVM_QEMU/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/10.%E4%BA%91%E5%8E%9F%E7%94%9F/Virtualization-implementation/KVM_QEMU/KVM_QEMU/</guid><description>概述 参考：
KVM 官网 Ubuntu 官方文档，虚拟化-qemu KVM 背景 Kernel-based Virtual Machine(基于内核的虚拟化机器，简称 KVM)， 是 Linux 的一个内核模块，就叫 kvm，只用于管理虚拟 CPU 和内存。该内核模块使得 Linux 变成了一个 Hypervisor。
它由 Quramnet 开发，该公司于 2008 年被 Red Hat 收购。 它支持 x86 (32 and 64 位), s390, Powerpc 等 CPU。 它从 Linux 2.6.20 起就作为一模块被包含在 Linux 内核中。 它需要支持虚拟化扩展的 CPU。 它是完全开源的。 KVM 实际是 Linux 内核提供的虚拟化架构，可将内核直接充当 Hypervisor 来使用。KVM 需要宿主机的 CPU 本身支持虚拟化扩展，如 intel VT 和 AMD AMD-V 技术。KVM 自 2.6.20 版本后已合入主干并发行。除了支持 x86 的处理器，同时也支持 S/390,PowerPC,IA-61 以及 ARM 等平台。</description></item><item><title>QEMU 设备模拟逻辑</title><link>https://desistdaydream.github.io/docs/10.%E4%BA%91%E5%8E%9F%E7%94%9F/Virtualization-implementation/KVM_QEMU/QEMU-%E8%AE%BE%E5%A4%87%E6%A8%A1%E6%8B%9F%E9%80%BB%E8%BE%91/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/10.%E4%BA%91%E5%8E%9F%E7%94%9F/Virtualization-implementation/KVM_QEMU/QEMU-%E8%AE%BE%E5%A4%87%E6%A8%A1%E6%8B%9F%E9%80%BB%E8%BE%91/</guid><description>概述 参考：
官方文档，系统模拟-设备模拟 QEMU 模拟设备主要是半虚拟化设备，从这里可以看到简单的介绍。
QEMU Storage Emulation(QEMU 存储模拟) 与 网络模拟 类似，QEMU 想要让虚拟机获得一块硬盘，也需要由两部分组成一个完整的存储功能。
front-end(前端) # VM 中的 块设备 back-end(后端) # 宿主机中的与 VM 中模拟出来的块设备进行交互的设备。 QEMU Network Emulation(QEMU 网络模拟) 参考：
https://wiki.qemu.org/Documentation/Networking https://www.qemu.org/docs/master/system/net.html https://www.qemu.org/2018/05/31/nic-parameter/，老版原理，将弃用 QEMU 想要让虚拟机与外界互通，需要由两部分组成一个完整的网络功能：
front-end(前端) # VM 中的 NIC(Network Interface Controller，即人们常说的网卡)。 VM 中的 NIC 是由 QEMU 模拟出来的，在支持 PCI 卡的系统上，通常可以是 e1000 网卡、rtl8139 网卡、virtio-net 设备。 back-end(后端) # 宿主机中的与 VM 中模拟出来的 NIC 进行交互的设备。 back-end 有多种类型可以使用，这些后端可以用于将 VM 连接到真实网络，或连接到另一个 VM TAP# 将 VM 连接到真实网络的标准方法 User mode network stack 效果如图所示： 基本应用示例 在使用 qemu-kvm 命令创建虚拟机时，通过一组两个选项来为虚拟机创建一个网络设备。比如：</description></item><item><title>KVM/QEMU 部署</title><link>https://desistdaydream.github.io/docs/10.%E4%BA%91%E5%8E%9F%E7%94%9F/Virtualization-implementation/KVM_QEMU/KVM_QEMU-%E9%83%A8%E7%BD%B2/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/10.%E4%BA%91%E5%8E%9F%E7%94%9F/Virtualization-implementation/KVM_QEMU/KVM_QEMU-%E9%83%A8%E7%BD%B2/</guid><description>概述 参考：
官方文档，安装 TODO: 官方文档里没有教安装 qemu-system 的地方呀~o(╯□╰)o 前期准备 查看 CPU 是否支持 KVM，筛选出来相关信息才可以正常使用 KVM
egrep &amp;ldquo;(svm|vmx)&amp;rdquo; /proc/cpuinfo 安装虚拟化组件 CentOS yum install qemu-kvm
Ubuntu 检查环境
sudo apt update sudo apt install -y cpu-checker kvm-ok sudo apt install qemu-system
qemu-system 与 CPU 架构的说明 ARM QEMU 可以模拟 32 位和 64 位 Arm CPU。使用 qemu-system-aarch64 可执行文件模拟 64 位 Arm 机器。您可以使用 qemu-system-arm 或 qemu-system-aarch64 来模拟 32 位 Arm 机器：通常，适用于 qemu-system-arm 的命令行在与 qemu-system-aarch64 一起使用时表现相同。</description></item><item><title>KVM/QEMU 镜像管理</title><link>https://desistdaydream.github.io/docs/10.%E4%BA%91%E5%8E%9F%E7%94%9F/Virtualization-implementation/KVM_QEMU/KVM_QEMU-%E9%95%9C%E5%83%8F%E7%AE%A1%E7%90%86/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/10.%E4%BA%91%E5%8E%9F%E7%94%9F/Virtualization-implementation/KVM_QEMU/KVM_QEMU-%E9%95%9C%E5%83%8F%E7%AE%A1%E7%90%86/</guid><description>概述 参考：
官方文档，系统模拟-磁盘镜像 GitHub 文档，qemu/qemu/docs/interop/qcow2.txt Wiki, qcow 其他 https://www.unixmen.com/qemu-kvm-using-copy-write-mode/ https://opengers.github.io/virtualization/kvm-libvirt-qemu-5/ KVM/QEMU 通过 qemu-img 命令行工具管理虚拟机镜像。
QEMU Copy On Write 注意：
使用该特性创建出来虚拟机之后，整个快照链的根节点(i.e.backingfile 虚拟机)一定要不有任何更改，否则会导致基于其创建的其他所有虚拟机文件系统出现问题。比如变成 read-only 状态。 QEMU Copy On Write(QEMU 写时复制，简称 QCOW) 是 QEMU 创建的虚拟机使用的磁盘镜像文件的文件格式。
当使用 QCOW 时，不会对原始磁盘映像应用任何更改。所有更改都记录在其他的 QCOW 文件中。多个 QCOW 文件可以指向同一个镜像，而不会危及基本系统。QEMU/KVM 允许将 QCOW 文件的更改合并到原始图像中。
修改 backingfile 后，导致依赖 backingfile 的虚拟机的文件系统崩溃 https://www.cnblogs.com/fengrenzw/p/3383773.html
https://www.cnblogs.com/fengrenzw/p/3383773.html
我们知道 qcow2 的磁盘格式可以带来很大的便利性，因为部署的时候可以减少大量的时间、空间，可以增量备份、快照等非常诱人的特性。
因为下边可能会有点绕：
backing_file：后端，母镜像
qcow2：前端，子镜像
在使用的时候可能会遇到一种情况，就是使用 backing_file 时，如果修改了 backing_file，“可能”会导致前端的 qcow2 的崩溃，出现这种问题个人觉得是很正常的，并且是可以完全避免的。所以，在 openstack 在使用 qcow2 的过程中会使用 glance 镜像管理来保证它的安全和完整性，我们在使用 qcow2 的时候也务必不回去修改它。
至于为什么会出现这种现象，下面简单分析一下，可能会有些纰漏、错误，但感觉整体思路上不会有太大的偏差。</description></item><item><title>KVM/QEMU 运行时管理</title><link>https://desistdaydream.github.io/docs/10.%E4%BA%91%E5%8E%9F%E7%94%9F/Virtualization-implementation/KVM_QEMU/KVM_QEMU-%E8%BF%90%E8%A1%8C%E6%97%B6%E7%AE%A1%E7%90%86/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/10.%E4%BA%91%E5%8E%9F%E7%94%9F/Virtualization-implementation/KVM_QEMU/KVM_QEMU-%E8%BF%90%E8%A1%8C%E6%97%B6%E7%AE%A1%E7%90%86/</guid><description>概述 参考：
KVM/QEMU 通过 qemu-system 命令行工具管理虚拟机运行时</description></item><item><title>最佳实践</title><link>https://desistdaydream.github.io/docs/10.%E4%BA%91%E5%8E%9F%E7%94%9F/Virtualization-implementation/KVM_QEMU/%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/10.%E4%BA%91%E5%8E%9F%E7%94%9F/Virtualization-implementation/KVM_QEMU/%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/</guid><description>概述 参考：
QEMU 文档，系统模拟-介绍-运行 https://notes.wadeism.net/post/kvm-create-vm-clone-by-overlay/ 注意：本最佳实践仅适用于独立使用 qemu-img、qemu-system 等 KVM/QEMU 的命令行工具，不包括 libvirtd 的工具
QEMU 命令行的一般形式可以表示为：
$ qemu-system-x86_64 [machine opts] \ [cpu opts] \ [accelerator opts] \ [device opts] \ [backend opts] \ [interface opts] \ [boot opts] 在下面的示例中，我们首先定义一台机器，它是用于运行 Aarch64 来宾的通用平台。我们启用虚拟化，因此我们可以在模拟来宾中使用 KVM。由于机器带有一些内置的 pflash 设备，我们给它们命名，以便我们稍后可以覆盖默认值。virtvirt
$ qemu-system-aarch64 \ -machine type=virt,virtualization=on,pflash0=rom,pflash1=efivars \ -m 4096 \ 然后，我们使用为我们提供 QEMU 能够模拟的所有 Arm 功能的选项定义 4 个 vCPU。我们启用了更加仿真友好的 Arm 指针身份验证算法实现。我们明确指定 TCG 加速，即使 QEMU 无论如何都会默认为它。
-cpu max,pauth-impdef=on \ -smp 4 \ -accel tcg \ 由于平台没有任何默认网络或存储设备，我们需要定义它们。我们给他们 id 以便我们稍后可以将他们与后端链接。</description></item></channel></rss>