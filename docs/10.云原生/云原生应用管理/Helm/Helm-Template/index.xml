<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Helm Template on 断念梦的站点</title><link>https://desistdaydream.github.io/docs/10.%E4%BA%91%E5%8E%9F%E7%94%9F/%E4%BA%91%E5%8E%9F%E7%94%9F%E5%BA%94%E7%94%A8%E7%AE%A1%E7%90%86/Helm/Helm-Template/</link><description>Recent content in Helm Template on 断念梦的站点</description><generator>Hugo</generator><language>zh-cn</language><atom:link href="https://desistdaydream.github.io/docs/10.%E4%BA%91%E5%8E%9F%E7%94%9F/%E4%BA%91%E5%8E%9F%E7%94%9F%E5%BA%94%E7%94%A8%E7%AE%A1%E7%90%86/Helm/Helm-Template/index.xml" rel="self" type="application/rss+xml"/><item><title>Named Templates(命名模板)</title><link>https://desistdaydream.github.io/docs/10.%E4%BA%91%E5%8E%9F%E7%94%9F/%E4%BA%91%E5%8E%9F%E7%94%9F%E5%BA%94%E7%94%A8%E7%AE%A1%E7%90%86/Helm/Helm-Template/Named-Templates%E5%91%BD%E5%90%8D%E6%A8%A1%E6%9D%BF/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/10.%E4%BA%91%E5%8E%9F%E7%94%9F/%E4%BA%91%E5%8E%9F%E7%94%9F%E5%BA%94%E7%94%A8%E7%AE%A1%E7%90%86/Helm/Helm-Template/Named-Templates%E5%91%BD%E5%90%8D%E6%A8%A1%E6%9D%BF/</guid><description>概述 参考：
官方文档：https://helm.sh/docs/chart_template_guide/named_templates/ Named Templates(命名模板，有时称为 partial(部分) 或 subtemplate(子模板)) 是限定在一个文件内部的模板，并起一个名称。Named Templates 可以在一个文件中定义，并在其他地方使用它们。
我们有两种创建方法，以及几种不同的使用方法。
在 控制结构与变量 章节中，我们介绍了声明和管理模板三个动作：define，template，和 block。在本节中，我们将介绍这三个动作，并介绍一个 include 函数，与 template 类似功能。
在命名模板时要注意一个重要的细节：模板名称是全局的。如果声明两个具有相同名称的模板，则最后加载一个模板是起作用的模板。由于子 chart 中的模板与顶级模板一起编译，因此注意小心地使用特定 chart 的名称来命名模板。
通用的命名约定是为每个定义的模板添加 chart 名称：{{define &amp;ldquo;mychart.labels&amp;rdquo;}}。通过使用特定 chart 名称作为前缀，我们可以避免由于同名模板的两个不同 chart 而可能出现的任何冲突。
partials 和 _ 文件
到目前为止，我们已经使用了一个文件，一个文件包含一个模板。但 Helm 的模板语言允许创建指定的嵌入模板，可以通过名称访问。
在我们开始编写这些模板之前，有一些文件命名约定值得一提：
大多数文件 templates/ 被视为包含 Kubernetes manifests NOTES.txt 是一个例外 名称以下划线（_）开头的文件被假定为没有内部 manifest。这些文件不会渲染 Kubernetes 对象定义，而是在其他 chart 模板中随处可用以供调用。 这些文件用于存储 partials 和辅助程序。事实上，当我们第一次创建时 mychart，我们看到一个叫做文件 _helpers.tpl。该文件是模板 partials 的默认位置。
define 定义模板 &amp;amp;&amp;amp; template 引用模板 define 定义模板，语法如下：
{{ define &amp;#34;MY.</description></item><item><title>Helm Template</title><link>https://desistdaydream.github.io/docs/10.%E4%BA%91%E5%8E%9F%E7%94%9F/%E4%BA%91%E5%8E%9F%E7%94%9F%E5%BA%94%E7%94%A8%E7%AE%A1%E7%90%86/Helm/Helm-Template/Helm-Template/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/10.%E4%BA%91%E5%8E%9F%E7%94%9F/%E4%BA%91%E5%8E%9F%E7%94%9F%E5%BA%94%E7%94%A8%E7%AE%A1%E7%90%86/Helm/Helm-Template/Helm-Template/</guid><description>概述 参考：
官方文档，Chart 模板指南 Helm 的 Template(模板) 可以生成 manifests 文件，这些文件是 kuberntes 用于描述资源的 yaml 。
Template 背景 helm 作为 kuberntes 的包管理器，用来在 k8s 集群中安装应用程序。众所周知，对于 k8s 来说，一个应用不应该是一个简单的 pod，应该包含该 pod 的运行方式(比如 deployment)、pod 的配置文件(configmip)、这个程序如何对外提供服务(service、ingress)等等等一系列的信息。这些信息都是通过 yaml 来描述如何工作的。可以想象，如果一个应用程序，其实是一堆 yaml 文件的话，那么 helm 本质上就是管理这些 yaml 文件的。而一个应用程序想要让用户来使用，必然还涉及到自定义的问题。比如应用程序的名字、配置文件中的内容、对外提供服务所要暴露的端口等等信息。
既然有这样的需求，那么为了让一个应用程序可以自定义，template 就应运而生。template 就是可以将这些 yaml 文件中的 value 变成一种变量的形式，然后通过其他方式(helm 命令行 &amp;ndash;set 标志或者 value.yaml 文件等)来对这些变量进行赋值，来实现应用程序自定义的效果。
helm templete 使用 Go 语言的 Template 来实现。而 go template 具有丰富的功能，除了可以普通赋值以外，还可以使用控制结构(比如 if&amp;hellip;else、range 等)来将赋值的过程更具体和多次赋值。
注意： 当我们谈论“ Helm 模板语言”时，就好像它是特定于 Helm 一样，但它实际上是 Go 模板语言，一些额外功能以及各种包装程序的组合，以将某些对象暴露给模板。当您了解模板时，Go 模板上的许多资源可能会有所帮助。</description></item><item><title>Pipeline 与 Function</title><link>https://desistdaydream.github.io/docs/10.%E4%BA%91%E5%8E%9F%E7%94%9F/%E4%BA%91%E5%8E%9F%E7%94%9F%E5%BA%94%E7%94%A8%E7%AE%A1%E7%90%86/Helm/Helm-Template/Pipeline-%E4%B8%8E-Function/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/10.%E4%BA%91%E5%8E%9F%E7%94%9F/%E4%BA%91%E5%8E%9F%E7%94%9F%E5%BA%94%E7%94%A8%E7%AE%A1%E7%90%86/Helm/Helm-Template/Pipeline-%E4%B8%8E-Function/</guid><description>概述 参考：
官方文档：https://helm.sh/docs/chart_template_guide/functions_and_pipelines/ 将 .Values 对象中的字符串注入模板时，应引用这些字符串。我们可以通过在 **Template Directive(模板指令)**中调用 quota 函数来实现，比如下面这个示例，会将引入的指转换为字符串类型：
apiVersion: v1 kind: ConfigMap metadata: name: {{.Release.Name}}-configmap data: myvalue: &amp;#34;Hello World&amp;#34; drink: {{quote .Values.favorite.drink}} food: {{quote .Values.favorite.food}} 模板函数遵循语法 functionName arg1 arg2...。在上面的代码片段中，quote .Values.favorite.drink 调用 quote 函数并将一个参数传递给它。
Helm 拥有超过 60 种可用函数。其中一些是由 Go template language(Go 模板语言) 本身定义的。其他大多数都是 Sprig template library(Sprig 模板库) 的一部分。随着示例的进行，我们将看到其中的许多例子。
注意：虽然我们将 Helm template language(Helm 模板语言) 视为 Helm 特有的，但它实际上是 Go 模板语言，一些额外函数和各种包装器的组合，以将某些对象暴露给模板。Go 模板上的许多资源在了解模板时可能会有所帮助。
Pipeline 管道 在 Helm 的 Template 中，**Pipeline(管道)**的概念与 Go Template 中 Pipeline 的概念不同，并不是指产生数据的操作。</description></item><item><title>Subcharts 与 Global Values</title><link>https://desistdaydream.github.io/docs/10.%E4%BA%91%E5%8E%9F%E7%94%9F/%E4%BA%91%E5%8E%9F%E7%94%9F%E5%BA%94%E7%94%A8%E7%AE%A1%E7%90%86/Helm/Helm-Template/Subcharts-%E4%B8%8E-Global-Values/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/10.%E4%BA%91%E5%8E%9F%E7%94%9F/%E4%BA%91%E5%8E%9F%E7%94%9F%E5%BA%94%E7%94%A8%E7%AE%A1%E7%90%86/Helm/Helm-Template/Subcharts-%E4%B8%8E-Global-Values/</guid><description>概述 参考：官方文档
假如 Chart A 依赖的 Chart B，则 Chart B 称之为 SubCharts(子图表)。
SubCharts 受以下规范约束
SubCharts 是“独立的”，这意味着 SubCharts 永远不能显式依赖其父图表。 因此，SubCharts 无法访问其父级的 Values。 父图表可以覆盖 SubCharts 的 Values。 Helm 具有可被所有图表访问的 Global Values(全局值) 的概念。</description></item><item><title>关于 Template 的其他说明</title><link>https://desistdaydream.github.io/docs/10.%E4%BA%91%E5%8E%9F%E7%94%9F/%E4%BA%91%E5%8E%9F%E7%94%9F%E5%BA%94%E7%94%A8%E7%AE%A1%E7%90%86/Helm/Helm-Template/%E5%85%B3%E4%BA%8E-Template-%E7%9A%84%E5%85%B6%E4%BB%96%E8%AF%B4%E6%98%8E/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/10.%E4%BA%91%E5%8E%9F%E7%94%9F/%E4%BA%91%E5%8E%9F%E7%94%9F%E5%BA%94%E7%94%A8%E7%AE%A1%E7%90%86/Helm/Helm-Template/%E5%85%B3%E4%BA%8E-Template-%E7%9A%84%E5%85%B6%E4%BB%96%E8%AF%B4%E6%98%8E/</guid><description>如何 Debug Templates 官方文档：https://helm.sh/docs/chart_template_guide/debugging/
调试模板可能会很棘手，因为渲染的模板已发送到 Kubernetes API 服务器，该服务器可能会出于格式化以外的其他原因而拒绝 YAML 文件。
有一些命令可以帮助您调试。
helm lint 是验证图表是否遵循最佳做法的首选工具 helm install --dry-run --debug或helm template --debug：我们已经看到了这个技巧。这是让服务器呈现模板，然后返回生成的清单文件的好方法。 helm get manifest：这是查看服务器上安装了哪些模板的好方法。 helm template ：用于调试模板渲染结果 当您的 YAML 无法解析，但您想查看生成的内容时，检索 YAML 的一种简单方法是在模板中注释掉问题部分，然后重新运行helm install --dry-run --debug：
apiVersion: v2 # some: problem section # {{ .Values.foo | quote }} 上面的内容将呈现并返回完整的注释：
apiVersion: v2 # some: problem section # &amp;#34;bar&amp;#34; 这提供了一种查看生成的内容的快速方法，而不会阻止 YAML 分析错误。
.helmignore 文件 https://helm.sh/docs/chart_template_guide/helm_ignore_file/
NOTES.txt 文件 https://helm.sh/docs/chart_template_guide/notes_files/
其他 https://helm.sh/docs/chart_template_guide/wrapping_up/
关于 YAML 与 Go 数据类型 和 Go 模板的说明 https://helm.</description></item><item><title>控制结构与变量</title><link>https://desistdaydream.github.io/docs/10.%E4%BA%91%E5%8E%9F%E7%94%9F/%E4%BA%91%E5%8E%9F%E7%94%9F%E5%BA%94%E7%94%A8%E7%AE%A1%E7%90%86/Helm/Helm-Template/%E6%8E%A7%E5%88%B6%E7%BB%93%E6%9E%84%E4%B8%8E%E5%8F%98%E9%87%8F/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/10.%E4%BA%91%E5%8E%9F%E7%94%9F/%E4%BA%91%E5%8E%9F%E7%94%9F%E5%BA%94%E7%94%A8%E7%AE%A1%E7%90%86/Helm/Helm-Template/%E6%8E%A7%E5%88%B6%E7%BB%93%E6%9E%84%E4%B8%8E%E5%8F%98%E9%87%8F/</guid><description>Control Structures 控制结构 参考：官方文档
控制结构在模板板中被称为 actions(动作)
Helm 模板中有如下几种控制结构：
if/else # 一个条件判断的代码块 with # 用于更改当前作用域 range # 用于循环遍历数组或者 map。 除此之外，还提供了一些声明和使用命名模板的控制结构：
define # 在模板中声明一个新的命名模板 template # 导入一个命名模板 block # 声明了一种特殊的可填写模板区域 define、template、block 这三种控制结构，放在 named template(命名模板) 中进行详解，详见：Named Templates(命名模板)
在下文的各种示例中，我们使用下面这种数据，来让各种控制结构进行处理，values.yaml 文件如下：
favorite: drink: water food: sushi game: &amp;#39;WOW &amp;amp; PAL&amp;#39; sushiKinds: - sashimi - name: hot - name: handRoll rice: more - name: IF/ELSE if/else 判断语句的语法如下：
{{ if PIPELINE }} # Do something {{ else if OTHER PIPELINE }} # Do something else {{ else }} # Default case {{ end }} 当 PIPELINE 值为以下内容，判定为 false：</description></item></channel></rss>