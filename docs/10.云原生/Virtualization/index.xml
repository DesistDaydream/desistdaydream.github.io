<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Virtualization on 断念梦的站点</title><link>https://desistdaydream.github.io/docs/10.%E4%BA%91%E5%8E%9F%E7%94%9F/Virtualization/</link><description>Recent content in Virtualization on 断念梦的站点</description><generator>Hugo</generator><language>zh-cn</language><atom:link href="https://desistdaydream.github.io/docs/10.%E4%BA%91%E5%8E%9F%E7%94%9F/Virtualization/index.xml" rel="self" type="application/rss+xml"/><item><title>Virtualization</title><link>https://desistdaydream.github.io/docs/10.%E4%BA%91%E5%8E%9F%E7%94%9F/Virtualization/Virtualization/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/10.%E4%BA%91%E5%8E%9F%E7%94%9F/Virtualization/Virtualization/</guid><description>概述 参考：
Wiki, Virtualization RedHat 7 虚拟化入门指南 Redhat 8 官方对虚拟化的定义 RedHat 7 对“虚拟化性能不行”这个误区的辟谣 Ubuntu 官方文档，虚拟化-介绍 Virtualization(虚拟化) 是用于运行软件的广义的计算机术语。通常情况下，Virtualization(虚拟化) 体现在让单个可以运行多个操作系统，这些操作系统同时运行，而又是互相独立的。
虚拟化是云计算的基础。简单的说，虚拟化使得在一台物理的服务器上可以跑多台虚拟机，虚拟机共享物理机的 CPU、内存、IO 硬件资源，但逻辑上虚拟机之间是相互隔离的。物理机我们一般称为 Host(宿主机)，宿主机上面的虚拟机称为 Guest(客户机)。那么 Host 是如何将自己的硬件资源虚拟化，并提供给 Guest 使用的呢？这个主要是通过一个叫做 Hypervisor 的程序实现的。
Hypervisor 参考：https://www.redhat.com/zh/topics/virtualization/what-is-a-hypervisor
Hypervisor 是用来创建与运行虚拟机的软件、固件或硬件。被 Hypervisor 用来运行一个或多个虚拟机的设备称为 Host Machine(宿主机)，这些虚拟机则称为 Guest Machine(客户机)。Hypervisor 有时也被称为 Virtual Machine Monitor (虚拟机监视器，简称 VMM)
虚拟化技术的分类 根据 Hypervisor 的实现方式和所处的位置，虚拟化又分为两种：1 型虚拟化和 2 型虚拟化
半虚拟化（para-virtualization）：TYPE1，也叫裸金属虚拟化比如 Vmware ESXi、Xen 等是一款类似于操作系统的 Hypervisor，直接运行在硬件之上，需要修改 Guest OS 的内核，让 VM 知道自己是虚拟机 完全虚拟化（full-virtualization）：TYPE2，物理机上首先安装常规的操作系统，比如 Redhat、Ubuntu 和 Windows。Hypervisor 作为 OS 上的一个程序模块运行，并对管理虚拟机进行管理。比如 Vmware Workstation、KVM 等是一款类似于软件的 Hypervisor，运行于操作系统之上，VM 不知道自己是虚拟机 BT：软件，二进制翻译。性能很差 HVM：硬件，硬件辅助的虚拟化。性能很好。现阶段 KVM 主要基于硬件辅助进行虚拟化 硬件辅助全虚拟化主要使用了支持虚拟化功能的 CPU 进行支撑，CPU 可以明确的分辨出来自 GuestOS 的特权指令，并针对 GuestOS 进行特权操作，而不会影响到 HostOS。 从更深入的层次来说，虚拟化 CPU 形成了新的 CPU 执行状态 —— Non-Root Mode&amp;amp; Root Mode。从上图中可以看见，GuestOS 运行在 Non-Root Mode 的 Ring 0 核心态中，这表明 GuestOS 能够直接执行特却指令而不再需要 特权解除 和 陷入模拟 机制。并且在硬件层上面紧接的就是虚拟化层的 VMM，而不需要 HostOS。这是因为在硬件辅助全虚拟化的 VMM 会以一种更具协作性的方式来实现虚拟化 —— 将虚拟化模块加载到 HostOS 的内核中，例如：KVM，KVM 通过在 HostOS 内核中加载 KVM Kernel Module 来将 HostOS 转换成为一个 VMM。所以此时 VMM 可以看作是 HostOS，反之亦然。这种虚拟化方式创建的 GuestOS 知道自己是正在虚拟化模式中运行的 GuestOS，KVM 就是这样的一种虚拟化实现解决方案。 OS 级别虚拟化：容器级虚拟化，准确来说不能叫虚拟化了，只能叫容器技术无 Hypervisor，将用户空间分隔为多个，彼此互相隔离，每个 VM 中没有独立内核，OpenVZ、LXC(Linux container)、libcontainer 等，比如 Docker，Docker 的基础是 LXC。 模拟(Emulation)：比如 QEMU，PearPC，Bochs 库虚拟化：WINE 应用程序虚拟化：JVM 理论上 Type1 和 Typ2 之间的区别 1 型虚拟化一般对硬件虚拟化功能进行了特别优化，性能上比 2 型要高； 2 型虚拟化因为基于普通的操作系统，会比较灵活，比如支持虚拟机嵌套。嵌套意味着可以在 KVM 虚拟机中再运行 KVM。 虚拟化总结(云计算基础，实现云功能的灵活调度) 所谓的云计算：当一台虚拟机需要跨越多个物理机进行数据交互，比如拿来运行 VM 的物理主机不止一台，在每台物理机上按需启动既定数量的 VM，每个 VM 有多少 CPU 和 MEM，每个 VM 启动在哪个物理机上，启动 VM 需要的存储设备在什么地方，存储设备中的系统是临时安装，还是通过一个已经装好的系统模板直接使用，还有多个 VM 跨物理主机进行网络通信等等一系列工作，可以使用一个虚拟化管理工具(VM Manager)来实现，这个管理器的功能即可称为云计算。在没有这个管理器的时候，人们只能人为手工从把 VM 从一台物理机移动到另一台物理机，非常不灵活。</description></item><item><title>Computing Virtualization</title><link>https://desistdaydream.github.io/docs/10.%E4%BA%91%E5%8E%9F%E7%94%9F/Virtualization/Computing-Virtualization/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/10.%E4%BA%91%E5%8E%9F%E7%94%9F/Virtualization/Computing-Virtualization/</guid><description>概述 参考：
CPU 虚拟化(vCPU=virtual CPU # 虚拟 CPU)
使用如下命令可以查看该 CPU 是否支持虚拟化
egrep -o &amp;lsquo;(vmx|svm)&amp;rsquo; /proc/cpuinfo
如果有输出 vmx 或者 svm，就说明当前的 CPU 支持 KVM。CPU 厂商 Intel 和 AMD 都支持虚拟化了，除非是非常老的 CPU。
在 CUP 虚拟化的图片中，宿主机有两个物理 CPU，上面起了两个虚机 VM1 和 VM2。 VM1 有两个 vCPU，VM2 有 4 个 vCPU。可以看到 VM1 和 VM2 分别有两个和 4 个线程在两个物理 CPU 上调度。
虚机的 vCPU 总数可以超过物理 CPU 数量，这个叫 CPU overcommit（超配）。 KVM 允许 overcommit，这个特性使得虚机能够充分利用宿主机的 CPU 资源，但前提是在同一时刻，不是所有的虚机都满负荷运行。 当然，如果每个虚机都很忙，反而会影响整体性能，所以在使用 overcommit 的时候，需要对虚机的负载情况有所了解，需要测试。</description></item><item><title>Memory Virtualization</title><link>https://desistdaydream.github.io/docs/10.%E4%BA%91%E5%8E%9F%E7%94%9F/Virtualization/Memory-Virtualization/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/10.%E4%BA%91%E5%8E%9F%E7%94%9F/Virtualization/Memory-Virtualization/</guid><description>概述 参考：
Wiki, Memory_virtualization 为了在一台机器上运行多个虚拟机，KVM 需要实现 VA（虚拟内存） -&amp;gt; PA（物理内存） -&amp;gt; MA（机器内存）之间的地址转换。虚机 OS 控制虚拟地址到客户内存物理地址的映射 （VA -&amp;gt; PA），但是虚机 OS 不能直接访问实际机器内存，因此 KVM 需要负责映射客户物理内存到实际机器内存 （PA -&amp;gt; MA）。内存也是可以 overcommit 的，即所有虚机的内存之和可以超过宿主机的物理内存。但使用时也需要充分测试，否则性能会受影响。</description></item><item><title>Storage Virtualization</title><link>https://desistdaydream.github.io/docs/10.%E4%BA%91%E5%8E%9F%E7%94%9F/Virtualization/Storage-Virtualization/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/10.%E4%BA%91%E5%8E%9F%E7%94%9F/Virtualization/Storage-Virtualization/</guid><description>概述 参考：
Wiki, Storage_virtualization 存储虚拟化(I/O) KVM 模式的存储虚拟化 第一种：存储虚拟化是通过存储池（Storage Pool）和卷（Volume）来管理的 Storage Pool 是宿主机上可以看到的一片存储空间，可以是多种类型。 文件目录类型的 Storage Pool 。KVM 将宿主机目录 /var/lib/libvirt/images/ 作为默认的 Storage Pool。 KVM 将 HOST 目录 /var/lib/libvirt/images/ 作为默认的 Storage Pool KVM 所有可以使用的 Storage Pool 都定义在宿主机的 /etc/libvirt/storage 目录下，每个 Pool 一个 xml 文件，默认有一个 default.xml LVM 类型的 Storage Pool。宿主机上 VG 中的 LV 也可以作为虚拟磁盘分配给虚拟机使用。不过，LV 由于没有磁盘的 MBR 引导记录，不能作为虚拟机的启动盘，只能作为数据盘使用。 KVM 还支持 iSCSI，Ceph 等多种类型的 Storage Pool，最常用的就是目录类型，其他类型可以参考文档http://libvirt.org/storage.html Volume 是在 Storage Pool 中划分出的一块空间，宿主机将 Volume 分配给虚拟机，Volume 在虚拟机中看到的就是一块硬盘。Volume 是 Storage Pool 目录下面的文件，一个文件就是一个 Volume(使用文件做 Volume 有很多优点：存储方便、移植性好、可复制)。Volume 分为几种类型，类型如下 qcow2 # 是推荐使用的格式，QEMU V2 磁盘镜像格式，cow 表示 copy on write，能够节省磁盘空间，支持 AES 加密，支持 zlib 压缩，支持多快照，功能很多。 raw # 是默认格式，即原始磁盘镜像格式，移植性好，性能好，但大小固定，不能节省磁盘空间。 vmdk # 是 VMWare 的虚拟磁盘格式，也就是说 VMWare 虚机可以直接在 KVM 上 运行。</description></item><item><title>I/O Virtualization</title><link>https://desistdaydream.github.io/docs/10.%E4%BA%91%E5%8E%9F%E7%94%9F/Virtualization/I_O-Virtualization/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/10.%E4%BA%91%E5%8E%9F%E7%94%9F/Virtualization/I_O-Virtualization/</guid><description>概述 参考：
Wiki, I/O virtualization I/O Virtualization(输入/输出虚拟化) 是一种广义的虚拟化概念。
VFIO 是 I/O 虚拟化的一种具体实现方式，专注于将设备直通给虚拟机，让虚拟机可以直接控制物理设备，从而获得接近于物理机的性能。</description></item></channel></rss>