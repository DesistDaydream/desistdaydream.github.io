<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>断念梦 – 7.HTTP</title><link>https://desistdaydream.github.io/docs/IT%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/4.%E6%95%B0%E6%8D%AE%E9%80%9A%E4%BF%A1/%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/7.HTTP/</link><description>Recent content in 7.HTTP on 断念梦</description><generator>Hugo -- gohugo.io</generator><atom:link href="https://desistdaydream.github.io/docs/IT%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/4.%E6%95%B0%E6%8D%AE%E9%80%9A%E4%BF%A1/%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/7.HTTP/index.xml" rel="self" type="application/rss+xml"/><item><title>Docs: 7.HTTP</title><link>https://desistdaydream.github.io/docs/IT%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/4.%E6%95%B0%E6%8D%AE%E9%80%9A%E4%BF%A1/%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/7.HTTP/7.HTTP/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/IT%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/4.%E6%95%B0%E6%8D%AE%E9%80%9A%E4%BF%A1/%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/7.HTTP/7.HTTP/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://tools.ietf.org/html/rfc2616">RFC 2616&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://developer.mozilla.org/en-US/docs/Web/HTTP">Mozilla 官方 HTTP 开发文档&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://mp.weixin.qq.com/s/bUy220-ect00N4gnO0697A">公众号-小林 coding，硬核！30 张图解 HTTP 常见的面试题&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://mp.weixin.qq.com/s/WQpxfwLArltKEjEAdOO2Pw">公众号-码海，51 张图助你彻底掌握 HTTP 协议&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>&lt;strong>HyperText Transfer Protocol(超文本传输协议，简称 HTTP)&lt;/strong>。是基于 TCP 的用于分布式、协作式、超媒体的信息系统的应用层协议。HTTP 是 &lt;a href="https://en.wikipedia.org/wiki/World_Wide_Web">World Wide Web(万维网,简称 WWW.就是我们俗称的 Web)&lt;/a> 的数据通信基础。&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/rlkp9t/1616161240441-f2958719-b738-4698-9fca-64d90f3471ba.png" alt="">&lt;/p>
&lt;h2 id="http-标准的演化">HTTP 标准的演化&lt;/h2>
&lt;blockquote>
&lt;p>参考：&lt;a href="https://www.infoq.cn/article/2014/06/http-11-updated">InfoQ 中的消息&lt;/a>&lt;/p>
&lt;/blockquote>
&lt;p>在 2014 年之前，HTTP/1.1 版本的标准为 &lt;a href="https://tools.ietf.org/html/rfc2616">RFC 2616&lt;/a>，但由于&lt;a href="https://tools.ietf.org/html/rfc7230#appendix-A.2">某些原因&lt;/a>，为了让标准更规范，HTTP/1.1 被拆分成了 6 个部分：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://tools.ietf.org/html/rfc7230">RFC7230 - HTTP/1.1&lt;/a>: Message Syntax and Routing(消息语法和路由)。这里包含 低级的消息解析 和 链接管理。&lt;/li>
&lt;li>&lt;a href="https://tools.ietf.org/html/rfc7231">RFC7231 - HTTP/1.1&lt;/a>: Semantics and Content(语意和内容)。这里面包含了 Methods、Status Codes、Headers&lt;/li>
&lt;li>RFC7232 - HTTP/1.1: Conditional Requests - e.g., If-Modified-Since&lt;/li>
&lt;li>RFC7233 - HTTP/1.1: Range Requests - getting partial content&lt;/li>
&lt;li>RFC7234 - HTTP/1.1: Caching - browser and intermediary caches&lt;/li>
&lt;li>RFC7235 - HTTP/1.1: Authentication - a framework for HTTP authentication&lt;/li>
&lt;/ul>
&lt;h2 id="http-三个部分">HTTP 三个部分&lt;/h2>
&lt;h3 id="1-协议">1. 「协议」&lt;/h3>
&lt;p>在生活中，我们也能随处可见「协议」，例如：&lt;/p>
&lt;ul>
&lt;li>刚毕业时会签一个「三方协议」；&lt;/li>
&lt;li>找房子时会签一个「租房协议」；&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/rlkp9t/1616161240448-b1263f75-a700-4431-9d6b-a99b36a58214.png" alt="">
三方协议和租房协议&lt;/p>
&lt;p>生活中的协议，本质上与计算机中的协议是相同的，协议的特点:&lt;/p>
&lt;ul>
&lt;li>「&lt;strong>协&lt;/strong>」字，代表的意思是必须有&lt;strong>两个以上的参与者&lt;/strong>。例如三方协议里的参与者有三个：你、公司、学校三个；租房协议里的参与者有两个：你和房东。&lt;/li>
&lt;li>「&lt;strong>议&lt;/strong>」字，代表的意思是对参与者的一种&lt;strong>行为约定和规范&lt;/strong>。例如三方协议里规定试用期期限、毁约金等；租房协议里规定租期期限、每月租金金额、违约如何处理等。&lt;/li>
&lt;/ul>
&lt;p>针对 HTTP &lt;strong>协议&lt;/strong>，我们可以这么理解。&lt;/p>
&lt;p>HTTP 是一个用在计算机世界里的&lt;strong>协议&lt;/strong>。它使用计算机能够理解的语言确立了一种计算机之间交流通信的规范（&lt;strong>两个以上的参与者&lt;/strong>），以及相关的各种控制和错误处理方式（&lt;strong>行为约定和规范&lt;/strong>）。&lt;/p>
&lt;h3 id="2-传输">2. 「传输」&lt;/h3>
&lt;p>所谓的「传输」，很好理解，就是把一堆东西从 A 点搬到 B 点，或者从 B 点 搬到 A 点。&lt;/p>
&lt;p>别轻视了这个简单的动作，它至少包含两项重要的信息。&lt;/p>
&lt;p>HTTP 协议是一个&lt;strong>双向协议&lt;/strong>。&lt;/p>
&lt;p>我们在上网冲浪时，浏览器是请求方 A ，百度网站就是应答方 B。双方约定用 HTTP 协议来通信，于是浏览器把请求数据发送给网站，网站再把一些数据返回给浏览器，最后由浏览器渲染在屏幕，就可以看到图片、视频了。
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/rlkp9t/1616161240434-514ef4d5-6830-46f1-9674-7c6564798dfd.png" alt="">
Request(请求) - (Response)应答&lt;/p>
&lt;p>数据虽然是在 A 和 B 之间传输，但允许中间有&lt;strong>中转或接力&lt;/strong>。&lt;/p>
&lt;p>就好像第一排的同学想传递纸条给最后一排的同学，那么传递的过程中就需要经过好多个同学（中间人），这样的传输方式就从「A &amp;lt; &amp;mdash; &amp;gt; B」，变成了「A &amp;lt;-&amp;gt; N &amp;lt;-&amp;gt; M &amp;lt;-&amp;gt; B」。&lt;/p>
&lt;p>而在 HTTP 里，需要中间人遵从 HTTP 协议，只要不打扰基本的数据传输，就可以添加任意额外的东西。&lt;/p>
&lt;p>针对&lt;strong>传输&lt;/strong>，我们可以进一步理解了 HTTP。&lt;/p>
&lt;p>HTTP 是一个在计算机世界里专门用来在&lt;strong>两点之间传输数据&lt;/strong>的约定和规范。&lt;/p>
&lt;h3 id="3-超文本">3. 「超文本」&lt;/h3>
&lt;p>HTTP 传输的内容是「超文本」。&lt;/p>
&lt;p>我们先来理解「文本」，在互联网早期的时候只是简单的字符文字，但现在「文本」的涵义已经可以扩展为图片、视频、压缩包等，在 HTTP 眼里这些都算作「文本」。&lt;/p>
&lt;p>再来理解「超文本」，它就是&lt;strong>超越了普通文本的文本&lt;/strong>，它是文字、图片、视频等的混合体，最关键有超链接，能从一个超文本跳转到另外一个超文本。&lt;/p>
&lt;p>HTML 格式的文件就是最常见的超文本了，它本身只是纯文字文件，但内部用很多标签定义了图片、视频等的链接，再经过浏览器的解释，呈现给我们的就是一个文字、有画面的网页了。&lt;/p>
&lt;h2 id="总结">总结&lt;/h2>
&lt;p>OK，经过了对 HTTP 里这三个名词的详细解释，就可以给出比「超文本传输协议」这七个字更准确更有技术含量的答案：&lt;/p>
&lt;p>&lt;strong>HTTP 是一个在计算机世界里专门在「两点」之间「传输」文字、图片、音频、视频等「超文本」数据的「约定和规范」。&lt;/strong>&lt;/p>
&lt;blockquote>
&lt;p>这里的两点可以是服务器到本地电脑，本地电脑到服务器、服务器到服务器、电脑到电脑，等等。&lt;/p>
&lt;/blockquote>
&lt;h1 id="http-请求过程概述">HTTP 请求过程概述&lt;/h1>
&lt;p>HTTP 事务由一次 &lt;strong>Client 的 Request(请求)&lt;/strong> 和 &lt;strong>Server 的 Response(响应)&lt;/strong> 组成。即 HTTP 协议是 Stateless(无状态)。(因为连接一次后就断开了，不会持久化存储任何数据)&lt;/p>
&lt;p>比如一个用户(Client 客户端)向服务器发起了一个请求，请求一个页面，在该页面输入完用户名和密码后进行登录后，如果刷新页面，那么就需要重新输入用户名和密码，因为 client 向 server 只请求了一个页面，请求完成后，连接就断开了，后续的请求是新的，没法再用以前的信息。这时候为了解决该问题，引用了 Cookie 和 Session 保持 的概念。&lt;/p>
&lt;p>相关技术&lt;/p>
&lt;ol>
&lt;li>Cookie：类似于 Token，相当于一个令牌，当访问一个 web server 的时候，server 发给 client 一个 Cookie，让 client 保存在本地，再次访问的时候，即可通过该 Cookie 识别身份&lt;/li>
&lt;li>Session(会话)保持：关联至 Cookie：当你在动态网页上访问了一些信息，比如购物车，在购物车添加一件物品，即通过 Session 功能来保存该信息，以便下次登录还能使用。否则下次登录购物车中的东西就没了&lt;/li>
&lt;/ol>
&lt;h2 id="流程简述">流程简述&lt;/h2>
&lt;ul>
&lt;li>建立或处理连接，接收请求或拒绝请求
&lt;ul>
&lt;li>建立 TCP 连接，WEB 浏览器向 Web 服务器发送请求&lt;/li>
&lt;li>web 浏览器发送请求头部信息
&lt;ul>
&lt;li>建立连接后，客户机发送一个请求给服务器，请求方式的格式为：URL、协议版本号、后面是 MIME 信息包括请求修饰符、客户机信息和可能得内容&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Server 接收请求，并应答
&lt;ul>
&lt;li>WEB 服务器接收到请求后，给予相应的响应信息，其格式为一个状态行，包括信息的协议版本号、一个成功或错误的代码，后边是 MIME 信息包括服务器信息、实体信息和可能得内容&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Server 处理请求
&lt;ul>
&lt;li>Web 服务器发送应答头信息&lt;/li>
&lt;li>Web 服务器向浏览器发送数据&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Client 访问资源
&lt;ul>
&lt;li>WEB 服务器关闭 TCP 连接&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>构建响应报文&lt;/li>
&lt;li>发送响应报文&lt;/li>
&lt;li>记录日志&lt;/li>
&lt;/ul>
&lt;h1 id="http-报文格式">HTTP 报文格式&lt;/h1>
&lt;h2 id="request-与-response-报文">Request 与 Response 报文&lt;/h2>
&lt;h3 id="request-请求报文">Request 请求报文&lt;/h3>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/rlkp9t/1616161240468-d9f13310-3f67-43b8-b5b7-b48dde683170.png" alt="">&lt;/p>
&lt;ul>
&lt;li>&lt;strong>Method&lt;/strong> # 请求方法，用于表明 Client 希望 Server 对 Resource 执行的动作。常用：GET、POST、DELETE&lt;/li>
&lt;li>&lt;strong>URL&lt;/strong> # HTTP 请求的 URL。
&lt;ul>
&lt;li>&lt;strong>Params&lt;/strong> # URL 参数。就是 URL 中的 Query 部分&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>Version&lt;/strong> # 发送给 Server 的请求的 HTTP 协议版本。&lt;/li>
&lt;li>**Headers **# 请求头。&lt;/li>
&lt;li>**Body **# 请求体。&lt;/li>
&lt;/ul>
&lt;blockquote>
&lt;p>这里面有一个要注意的地方，就是 Params 与 Headers，&lt;strong>Params 是 URL 的一部分&lt;/strong>，但是 Headers 不是。虽然两者的作用类似，都是用来定义这个请求中应该发送给对方的一些基本信息、认证信息 等等。但是在一个 HTTP 的请求中，两者所处的位置是不一样，用于不同场景。&lt;/p>
&lt;/blockquote>
&lt;p>&lt;strong>Authorization&lt;/strong> # 认证信息。这是一个比较特殊的东西，可以存在于 URL 的 Params 中、Headers 中、Body 中。请求报文的各个部分，都可以填写认证信息。&lt;/p>
&lt;ul>
&lt;li>当 Server 需要一个认证信息时，就需要在 HTTP 请求中加入认证相关的信息。&lt;/li>
&lt;/ul>
&lt;h4 id="example">EXAMPLE&lt;/h4>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/rlkp9t/1616161240442-63d3fc7f-80c2-43e4-bec5-50061f2e02f2.png" alt="">&lt;/p>
&lt;h3 id="response-响应报文">Response 响应报文&lt;/h3>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/rlkp9t/1616161240462-a29c9d65-119a-4b70-993f-bd1a4cfbbd7e.png" alt="">&lt;/p>
&lt;ul>
&lt;li>&lt;strong>Version&lt;/strong> # 响应给 Client 的 HTTP 版本。&lt;/li>
&lt;li>&lt;strong>Status&lt;/strong> # HTTP 响应状态。用来标记请求过程中发生的情况，由 server 告诉 client。响应状态由两部分组成&lt;/li>
&lt;li>&lt;strong>StatusCode&lt;/strong> # 状态码。统一为 3 位的数字。
&lt;ul>
&lt;li>各个状态码的含义，见&lt;a href="https://www.yuque.com/go/doc/33218939">状态码详解章节&lt;/a>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>**ReasonPhrase **# 原因短语。用来表示产生该状态的原因的简要说明&lt;/li>
&lt;li>&lt;strong>Headers&lt;/strong> # 响应头。&lt;/li>
&lt;li>&lt;strong>Body&lt;/strong> # 响应体。实体部分，请求时附加的数据或响应时附加的数据&lt;/li>
&lt;/ul>
&lt;h4 id="example-1">EXAMPLE&lt;/h4>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/rlkp9t/1616161240440-85fac56c-d3ed-44dc-94f3-20d60017e622.png" alt="">&lt;/p>
&lt;h2 id="http-header">HTTP Header&lt;/h2>
&lt;blockquote>
&lt;p>参考：&lt;a href="https://tools.ietf.org/html/rfc2616">RFC 2616&lt;/a>&lt;/p>
&lt;/blockquote>
&lt;p>HTTP 请求和响应报文的 Header(头) 基本都是 Key/Value(键值) 格式，Key 与 Value 以冒号分隔，此外，除了标准的头部字段之外，还可以添加自定义头，这就给 HTTP 带来了无限的扩展可能。注意，Value 不区分大小写。&lt;/p>
&lt;p>HTTP 协议规定了非常多的 Header 字段，可以实现各种各样的功能，但基本上可以分为以下四类&lt;/p>
&lt;ol>
&lt;li>&lt;strong>General Header(通用头)&lt;/strong> # 在请求头和响应头里都可以出现；&lt;/li>
&lt;li>&lt;strong>Request Header(请求头)&lt;/strong> # 仅能出现在请求头里，进一步说明请求信息或者额外的附加条件；&lt;/li>
&lt;li>&lt;strong>Response Header(响应头)&lt;/strong> # 仅能出现在响应头里，补充说明响应报文的信息；&lt;/li>
&lt;li>&lt;strong>Entity Header(实体头)&lt;/strong> # 它实际上属于通用字段，但专门描述 body 的额外信息。&lt;/li>
&lt;li>&lt;strong>Extension Header(扩展头)&lt;/strong> # 不在标准规范中，可以通过自定义头实现更多定制化需求的 Header 信息。&lt;/li>
&lt;/ol>
&lt;p>&lt;strong>对 HTTP 报文的解析和处理其实本质上就是对头字段的处理&lt;/strong>，HTTP 的连接管理，缓存控制，内容协商等都是通过头字段来处理的，&lt;strong>理解了头字段，基本上也就理解了 HTTP&lt;/strong>，所以理解头字段非常重要。&lt;/p>
&lt;p>详见：&lt;a href="https://www.yuque.com/go/doc/33218949">HTTP 协议头部字段详解&lt;/a>&lt;/p>
&lt;p>注意：这种分类是在 RFC 2616 标准中定义的，在新的 RFC 7231 中，已经看不到这种分类了&lt;/p>
&lt;h2 id="http-的请求-method方法">HTTP 的请求 Method(方法)&lt;/h2>
&lt;p>根据 HTTP 标准，HTTP 请求可以使用多种请求方法。 HTTP 的 1.0 版本中只有三种请求方法： GET, POST 和 HEAD 方法。到了 1.1 版本时，新增加了五种请求方法：OPTIONS, PUT, DELETE, TRACE 和 CONNECT 方法。&lt;/p>
&lt;ul>
&lt;li>&lt;strong>GET&lt;/strong> # 从服务器获取了资源
&lt;ul>
&lt;li>请求指定的页面信息，并返回实体主体。&lt;/li>
&lt;li>GET 请求请提交的数据放置在 HTTP 请求协议头中，GET 方法通过 URL 请求来传递用户的输入，GET 方式的提交你需要用 Request.QueryString 来取得变量的值。&lt;/li>
&lt;li>GET 方法提交数据，可能会带来安全性的问题，数据被浏览器缓存。&lt;/li>
&lt;li>GET 请求有长度限制。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>HEAD&lt;/strong> # 只从 server 获取文档的响应首部（报文中的 Headers）
&lt;ul>
&lt;li>类似于 get 请求，只不过返回的响应中没有具体的内容，用于获取报头。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>POST&lt;/strong> # 向 server 发送要处理的数据
&lt;ul>
&lt;li>向指定资源提交数据进行处理请求（例如提交表单或者上传文件）。&lt;/li>
&lt;li>POST 请求可能会导致新的资源的建立和/或已有资源的修改。&lt;/li>
&lt;li>POST 方式提交时，你必须通过 Request.Form 来访问提交的内容&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>PUT&lt;/strong> # 将请求的主体存储在 server 上
&lt;ul>
&lt;li>从客户端向服务器传送的数据取代指定的文档的内容。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>DELETE&lt;/strong> # 请求删除 server 上通过 URL 指定的文档，DELETE 请求一般返回 3 种码
&lt;ul>
&lt;li>200（OK）——删除成功，同时返回已经删除的资源。&lt;/li>
&lt;li>202（Accepted）——删除请求已经接受，但没有被立即执行（资源也许已经被转移到了待删除区域）。&lt;/li>
&lt;li>204（No Content）——删除请求已经被执行，但是没有返回资源（也许是请求删除不存在的资源造成的）。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>OPTIONS&lt;/strong> #** **请求服务器返回对指定资源支持使用的请求方法
&lt;ul>
&lt;li>允许客户端查看服务器的性能。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>TRACE&lt;/strong> # 追踪请求到达 server 中间经过的 server agent
&lt;ul>
&lt;li>回显服务器收到的请求，主要用于测试或诊断。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h3 id="get-与-post">GET 与 POST&lt;/h3>
&lt;p>&lt;code>Get&lt;/code> 方法的含义是请求&lt;strong>从服务器获取资源&lt;/strong>，这个资源可以是静态的文本、页面、图片视频等。&lt;/p>
&lt;p>比如，你打开我的文章，浏览器就会发送 GET 请求给服务器，服务器就会返回文章的所有文字及资源。
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/rlkp9t/1649668233003-6c01ab91-90f8-4ea8-8095-5448302146e8.jpeg" alt="">
而&lt;code>POST&lt;/code> 方法则是相反操作，它向 &lt;code>URI&lt;/code> 指定的资源提交数据，数据就放在报文的 body 里。&lt;/p>
&lt;p>比如，你在我文章底部，敲入了留言后点击「提交」（&lt;strong>暗示你们留言&lt;/strong>），浏览器就会执行一次 POST 请求，把你的留言文字放进了报文 body 里，然后拼接好 POST 请求头，通过 TCP 协议发送给服务器。
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/rlkp9t/1649668232954-1a090cec-1a9c-4c11-a370-d49b4156cac3.jpeg" alt="">
GET 和 POST 方法都是安全和幂等的吗？&lt;/p>
&lt;p>先说明下安全和幂等的概念：&lt;/p>
&lt;ul>
&lt;li>在 HTTP 协议里，所谓的「安全」是指请求方法不会「破坏」服务器上的资源。&lt;/li>
&lt;li>所谓的「幂等」，意思是多次执行相同的操作，结果都是「相同」的。&lt;/li>
&lt;/ul>
&lt;p>那么很明显 &lt;strong>GET 方法就是安全且幂等的&lt;/strong>，因为它是「只读」操作，无论操作多少次，服务器上的数据都是安全的，且每次的结果都是相同的。&lt;/p>
&lt;p>&lt;strong>POST&lt;/strong> 因为是「新增或提交数据」的操作，会修改服务器上的资源，所以是&lt;strong>不安全&lt;/strong>的，且多次提交数据就会创建多个资源，所以&lt;strong>不是幂等&lt;/strong>的。&lt;/p></description></item><item><title>Docs: HTTP Header</title><link>https://desistdaydream.github.io/docs/IT%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/4.%E6%95%B0%E6%8D%AE%E9%80%9A%E4%BF%A1/%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/7.HTTP/HTTP-Header/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/IT%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/4.%E6%95%B0%E6%8D%AE%E9%80%9A%E4%BF%A1/%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/7.HTTP/HTTP-Header/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://tools.ietf.org/html/rfc2616#section-4.2">RFC 2616-Message Headers&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://tools.ietf.org/html/rfc7231#section-5">RFC 7231,第五章-请求头字段&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://datatracker.ietf.org/doc/html/rfc7231#section-7">RFC 7231,第七章-响应头字段&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/List_of_HTTP_header_fields">Wiki,List of HTTP header fields&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers">Mozilla 官方文档&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>一般情况下，在浏览器按 F12 后查看到的首部大部分都是请求和响应首部,这俩首部的信息通常包含了通用首部中的信息
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/rzfx0t/1616161207830-cf569808-255f-4e34-9f02-d7da892c9170.jpeg" alt="">
HTTP 请求和响应报文的 Header(头) 基本都是 Key/Value Pair(键/值对) 格式的 &lt;strong>Field(字段)&lt;/strong>，每个字段都是以冒号分割的 &lt;strong>键/值对&lt;/strong>。此外，除了标准的 Header 字段之外，还可以添加自定义 Header，这就给 HTTP 带来了无限的扩展可能。注意，&lt;strong>Key 不区分大小写&lt;/strong>。&lt;/p>
&lt;p>自定义 Header 历来以 &lt;code>X-&lt;/code> 开头，但是该约定在 2012 年 6 月被弃用，因为它在非标准字段成为标准字段时会造成不必要的麻烦，详见 &lt;a href="https://datatracker.ietf.org/doc/html/rfc6648">RFC 6648&lt;/a>。IANA 维护了一个通用的 &lt;a href="https://www.iana.org/assignments/message-headers/message-headers.xhtml">&lt;strong>HTTP Header 列表&lt;/strong>&lt;/a>，其中包括 RFC 中定义的标准头以及不在 RFC 中定义的扩展头；并且在同一个页面还有新的提议增加的 HTTP Header 列表。&lt;/p>
&lt;p>HTTP (RFC 2616 版本)规定了非常多的 Header 字段，可以实现各种各样的功能，但基本上可以分为以下四类&lt;/p>
&lt;ol>
&lt;li>&lt;strong>General Header(通用头)&lt;/strong> # 在请求头和响应头里都可以出现；&lt;/li>
&lt;li>&lt;strong>Request Header(请求头)&lt;/strong> # 仅能出现在请求头里，进一步说明请求信息或者额外的附加条件；&lt;/li>
&lt;li>&lt;strong>Response Header(响应头)&lt;/strong> # 仅能出现在响应头里，补充说明响应报文的信息；&lt;/li>
&lt;li>&lt;strong>Entity Header(实体头)&lt;/strong> # 它实际上属于通用字段，但专门描述 body 的额外信息。&lt;/li>
&lt;li>&lt;strong>Extension Header(扩展头)&lt;/strong> # 不在标准规范中，可以通过自定义头实现更多定制化需求的 Header 信息。&lt;/li>
&lt;/ol>
&lt;p>&lt;strong>对 HTTP 报文的解析和处理其实本质上就是对头字段的处理&lt;/strong>，HTTP 的连接管理，缓存控制，内容协商等都是通过头字段来处理的，&lt;strong>理解了头字段，基本上也就理解了 HTTP&lt;/strong>，所以理解头字段非常重要。&lt;/p>
&lt;h2 id="新版-http-header-规范">新版 HTTP Header 规范&lt;/h2>
&lt;p>注意：上面描述分类是在 RFC 2616 标准中定义的，在新的 RFC 7231 中，已经看不到这种分类了，仅仅简单得分为请求头和响应头&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://tools.ietf.org/html/rfc7231#section-5">Request Header(请求头)&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://tools.ietf.org/html/rfc7231#section-7">Response Header(响应头)&lt;/a>&lt;/li>
&lt;/ul>
&lt;p>而这两类头字段下，又有各自的子分类&lt;/p>
&lt;p>在 2014 年之后的新版规范中，并非所有出现在请求中的 Header 都称为请求头，比如 Content-Length，在 RFC 2616 中称为 Entity Header(实体头)，而在新版规范中，称之为元数据。这也为 HTTP 2.0 的 &lt;a href="https://desistdaydream.github.io/docs/IT%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/4.%E6%95%B0%E6%8D%AE%E9%80%9A%E4%BF%A1/%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/7.HTTP/HTTP2.md">Header 压缩&lt;/a> 打下了基础&lt;/p>
&lt;h1 id="request-header请求头">Request Header(请求头)&lt;/h1>
&lt;p>Request Header(请求头) 主要是在每个 HTTP 的请求中指定。包含要获取的资源或请求某个资源的客户端本身的信息，以便服务端可以根据这些内容，来定制响应。&lt;/p>
&lt;p>Request Header 中，将各种 Header 分为多个类别&lt;/p>
&lt;ul>
&lt;li>Controls # 控制本次 HTTP 请求的行为&lt;/li>
&lt;li>Conditionals # 条件相关 Header&lt;/li>
&lt;li>Content Negotiation # 内容协商相关 Header&lt;/li>
&lt;li>Authentication Credentials # 认证相关的 Header&lt;/li>
&lt;li>Request Context # 请求上下文&lt;/li>
&lt;/ul>
&lt;h2 id="controls控制">Controls(控制)&lt;/h2>
&lt;p>Controls 类型的请求头用来指定客户端如何处理本次 HTTP 请求。
&lt;strong>Cache-Control&lt;/strong> # 缓存控制
&lt;strong>Expect&lt;/strong> # 期待服务器的特定行为
&lt;strong>Host&lt;/strong> # 请求资源所在服务器。客户端指定自己想访问的服务器的 &lt;code>域名&lt;/code> 或者 &lt;code>IP:PORT&lt;/code>。例如：&lt;code>Host：www.baidu.com&lt;/code>&lt;/p>
&lt;ul>
&lt;li>Note：输入的什么网址，请求的就是什么，输入域名就是域名，输入 IP 就是 IP&lt;/li>
&lt;li>Note：当服务器接到这个请求时，如果自身无法处理 ip 或者无法处理域名，则该请求就会丢弃(比如 k8s 的 ingress)。所以在测试的时候一般使用 curl 命令请求 IP 时加上 -H 参数以自己制定 URL 内容即可，否则如果服务器不处理 IP 的话，就会返回 404&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>Max-Forwards&lt;/strong># 最大传输逐跳数
&lt;strong>Pragma&lt;/strong> #
&lt;strong>Range&lt;/strong> # 实体的字节范围请求
&lt;strong>TE&lt;/strong># 传输编码的优先级&lt;/p>
&lt;h2 id="conditionals条件">Conditionals(条件)&lt;/h2>
&lt;p>&lt;strong>If-Match&lt;/strong> # 比较实体标记(ETag)
&lt;strong>If-None-Match&lt;/strong> # 比较实体标记(与 If-Match 相反)
&lt;strong>If-Modified-Since&lt;/strong> # 比较资源的更新时间
&lt;strong>If-Unmodified-Since&lt;/strong># 比较资源的更新时间(与 If-Modified-Since 相反)
&lt;strong>If-Range&lt;/strong># 资源未更新时发送实体 Byte 的范围请求&lt;/p>
&lt;h2 id="content-negotiation内容协商">Content Negotiation(内容协商)&lt;/h2>
&lt;p>&lt;strong>Accept&lt;/strong> # 用户代理可处理的媒体类型
&lt;strong>Accept-[ Charset | Encoding | Language]&lt;/strong> # 通知 server 自己可接收的媒体类型[字符集|编码格式|语言]&lt;/p>
&lt;h2 id="authentication-credentials认证">Authentication Credentials(认证)&lt;/h2>
&lt;p>&lt;strong>Authorization&lt;/strong> # Web 认证信息。IANA 维护了一个&lt;a href="https://www.iana.org/assignments/http-authschemes/http-authschemes.xhtml">身份验证方案的列表&lt;/a>&lt;/p>
&lt;ul>
&lt;li>&lt;strong>Basic&lt;/strong> # 基本认证。就是用户名和密码。如果用户名和密码为 &lt;code>admin/admin1234&lt;/code> 的话，该字段应该是这样的：
&lt;ul>
&lt;li>&lt;code>Authorization: Basic YWRtaW46YWRtaW4xMjM0&lt;/code>&lt;/li>
&lt;li>也就是说，用户名和密码是 &lt;code>admin:admin1234&lt;/code> 这样的 base64 编码后的格式&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>Bearer&lt;/strong> # 不记名令牌。&lt;/li>
&lt;li>&amp;hellip;&amp;hellip;&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>Proxy-Authorization&lt;/strong> # 代理服务器要求客户端的认证信息&lt;/p>
&lt;h2 id="request-context">Request Context&lt;/h2>
&lt;p>&lt;strong>From&lt;/strong> # 用户的电子邮箱地址
&lt;strong>Referer&lt;/strong> # 对请求中 URI 的原始获取方
&lt;strong>User-Agent&lt;/strong> # HTTP 客户端程序的信息&lt;/p>
&lt;h1 id="response-header响应头">Response Header(响应头)&lt;/h1>
&lt;p>包含有关响应的补充信息，如其位置或服务器本身(名称和版本等)的消息头。&lt;/p>
&lt;p>Response Header 中，将各种 Header 分为多个类别：&lt;/p>
&lt;ul>
&lt;li>Control Data&lt;/li>
&lt;li>Validator Header Fields&lt;/li>
&lt;li>Authentication Challenges&lt;/li>
&lt;li>Response Context&lt;/li>
&lt;/ul>
&lt;h2 id="control-data控制数据">Control Data(控制数据)&lt;/h2>
&lt;p>控制服务端如何处理 HTTP 响应
Age # 推算资源创建经过时间
Cache-Control #
Expires #
Data #
Location #
Retry-After #
Vary #
Warning #&lt;/p>
&lt;h2 id="validator-header-fields验证器头字段">Validator Header Fields(验证器头字段)&lt;/h2>
&lt;p>&lt;strong>ETag&lt;/strong> # 资源的匹配信息
&lt;strong>Last-Modified&lt;/strong> # 最后一次修改时间&lt;/p>
&lt;h2 id="authentication-challenges">Authentication Challenges&lt;/h2>
&lt;p>&lt;strong>WWW-Authenticate&lt;/strong> # 服务器对客户端的认证信息
&lt;strong>Proxy-Authorization&lt;/strong> # 代理服务器要求客户端的认证信息&lt;/p>
&lt;h2 id="response-context">Response Context&lt;/h2>
&lt;p>&lt;strong>Accept-Ranges&lt;/strong> # 是否接受字节范围请求
&lt;strong>Allow&lt;/strong> #
&lt;strong>Server&lt;/strong># HTTP 服务器的安装信息&lt;/p>
&lt;h1 id="extension-header扩展头">&lt;strong>Extension Header(扩展头)&lt;/strong>&lt;/h1>
&lt;p>通常情况下，一个 web 界面有 N 多个资源，比如 index.html 首页是一个资源，首页中有各种 img，css，js 等静态或动态资源，当用户访问一个网站后，除了要请求主页资源，还需要再请求主页上各个图片，板式，功能等资源，每一个资源都有一个单独的报文。也就说有可能每一类资源都可以单独存在在一个相对应的集群服务器群中，比如通过一个图片的 URL，可以直接访问该图片，而不用在网站主页才能看到；而这些资源都需要前端负载均衡器来进行调度用户请求到相应的服务器中去拿去资源，这时候 LB 的压力会非常大，为了解决这种问题，人们就可以根据自己的协商，定义一些标准之外的 Header。&lt;/p>
&lt;h1 id="老版本的两个-header-笔记">老版本的两个 Header 笔记&lt;/h1>
&lt;h2 id="general-header通用头">General Header(通用头)&lt;/h2>
&lt;p>同时适用于请求和响应消息，但与最终消息主体中传输的数据无关的消息头。
&lt;strong>Cache-Control&lt;/strong> # 控制缓存的行为&lt;/p>
&lt;ul>
&lt;li>no-cache：不缓存&lt;/li>
&lt;li>max-age：缓存最大保留时间&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>Connection&lt;/strong> # 逐跳首部、连接的管理。连接状态。HTTP/2 中不在支持该 Header&lt;/p>
&lt;ul>
&lt;li>keepalive(长连接)：需要实时更新的网络资源，比如网络游戏，具体点就是网页上的游戏，需要实时连接，如果游戏中每一步操作都要进行 TCP 建连，然后各种请求和响应，那么用户体验会非常不好，也会极大得消耗网络带宽，所以需要使用类似 keepalive 这种长连接&lt;/li>
&lt;li>close(短连接)：不需要实时更新的网络资源，当浏览静态网页资源的时候，当把整个网页发送给用户之后即可关闭连接，因为网页资源已经发送到 Client 本地，不需要实时更新了&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>Date&lt;/strong># 创建报文的日期时间
&lt;strong>Pragma&lt;/strong># 报文指令
&lt;strong>Trailer&lt;/strong># 报文末端的首部一览
&lt;strong>Transfer-Encoding&lt;/strong># 指定报文主体的传输编码方式
&lt;strong>Upgrade&lt;/strong># 升级为其他协议
&lt;strong>Via&lt;/strong># 报文经过的中间节点。也就是代理服务器的相关信息。
&lt;strong>Warning&lt;/strong> # 错误通知&lt;/p>
&lt;h2 id="entity-header实体头">Entity Header(实体头)&lt;/h2>
&lt;p>包含有关实体主体的更多信息，比如主体长(Content-Length)度或其 MIME 类型。
Allow：列出对此实体可使用的请求方法
Location：告诉 client 真正的实体位于何处
Content-
缓存相关&lt;/p>
&lt;ol>
&lt;li>ETag # 实体扩展标签&lt;/li>
&lt;li>Expires # 实体过期时间&lt;/li>
&lt;li>Last-Modified # 最后一次修改时间&lt;/li>
&lt;/ol>
&lt;p>&lt;strong>Content-Length&lt;/strong># 实体主体的大小(单位 :字节)&lt;/p></description></item><item><title>Docs: HTTP Status Codes</title><link>https://desistdaydream.github.io/docs/IT%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/4.%E6%95%B0%E6%8D%AE%E9%80%9A%E4%BF%A1/%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/7.HTTP/HTTP-Status-Codes/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/IT%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/4.%E6%95%B0%E6%8D%AE%E9%80%9A%E4%BF%A1/%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/7.HTTP/HTTP-Status-Codes/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://datatracker.ietf.org/doc/html/rfc7231#section-6">RFC 7231,第六章-响应状态码&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;h1 id="http-的-status-状态码和-reason-phrase-原因短语">HTTP 的 Status 状态码和 Reason-Phrase 原因短语&lt;/h1>
&lt;p>常用 200,301,302,304,401,403,404,500,502&lt;/p>
&lt;h2 id="http-常见的状态码">HTTP 常见的状态码&lt;/h2>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/ytigiz/1616161194550-be1a091b-4d94-4180-97cb-9a54f082ca47.png" alt="">&lt;/p>
&lt;h2 id="五大类-http-状态码">五大类 HTTP 状态码&lt;/h2>
&lt;p>&lt;em>1xx&lt;/em>&lt;/p>
&lt;p>&lt;code>1xx&lt;/code> 类状态码属于&lt;strong>提示信息&lt;/strong>，是协议处理中的一种中间状态，实际用到的比较少。&lt;/p>
&lt;p>&lt;em>2xx&lt;/em>&lt;/p>
&lt;p>&lt;code>2xx&lt;/code> 类状态码表示服务器&lt;strong>成功&lt;/strong>处理了客户端的请求，也是我们最愿意看到的状态。&lt;/p>
&lt;p>「&lt;strong>200 OK&lt;/strong>」是最常见的成功状态码，表示一切正常。如果是非 &lt;code>HEAD&lt;/code> 请求，服务器返回的响应头都会有 body 数据。&lt;/p>
&lt;p>「&lt;strong>204 No Content&lt;/strong>」也是常见的成功状态码，与 200 OK 基本相同，但响应头没有 body 数据。&lt;/p>
&lt;p>「&lt;strong>206 Partial Content&lt;/strong>」是应用于 HTTP 分块下载或断点续传，表示响应返回的 body 数据并不是资源的全部，而是其中的一部分，也是服务器处理成功的状态。&lt;/p>
&lt;p>&lt;em>3xx&lt;/em>&lt;/p>
&lt;p>&lt;code>3xx&lt;/code> 类状态码表示客户端请求的资源发送了变动，需要客户端用新的 URL 重新发送请求获取资源，也就是&lt;strong>重定向&lt;/strong>。&lt;/p>
&lt;p>「&lt;strong>301 Moved Permanently&lt;/strong>」表示永久重定向，说明请求的资源已经不存在了，需改用新的 URL 再次访问。&lt;/p>
&lt;p>「&lt;strong>302 Found&lt;/strong>」表示临时重定向，说明请求的资源还在，但暂时需要用另一个 URL 来访问。&lt;/p>
&lt;p>301 和 302 都会在响应头里使用字段 &lt;code>Location&lt;/code>，指明后续要跳转的 URL，浏览器会自动重定向新的 URL。&lt;/p>
&lt;p>「&lt;strong>304 Not Modified&lt;/strong>」不具有跳转的含义，表示资源未修改，重定向已存在的缓冲文件，也称缓存重定向，用于缓存控制。&lt;/p>
&lt;p>&lt;em>4xx&lt;/em>&lt;/p>
&lt;p>&lt;code>4xx&lt;/code> 类状态码表示客户端发送的&lt;strong>报文有误&lt;/strong>，服务器无法处理，也就是错误码的含义。&lt;/p>
&lt;p>「&lt;strong>400 Bad Request&lt;/strong>」表示客户端请求的报文有错误，但只是个笼统的错误。&lt;/p>
&lt;p>「&lt;strong>403 Forbidden&lt;/strong>」表示服务器禁止访问资源，并不是客户端的请求出错。&lt;/p>
&lt;p>「&lt;strong>404 Not Found&lt;/strong>」表示请求的资源在服务器上不存在或未找到，所以无法提供给客户端。&lt;/p>
&lt;p>&lt;em>5xx&lt;/em>&lt;/p>
&lt;p>&lt;code>5xx&lt;/code> 类状态码表示客户端请求报文正确，但是&lt;strong>服务器处理时内部发生了错误&lt;/strong>，属于服务器端的错误码。&lt;/p>
&lt;p>「&lt;strong>500 Internal Server Error&lt;/strong>」与 400 类型，是个笼统通用的错误码，服务器发生了什么错误，我们并不知道。&lt;/p>
&lt;p>「&lt;strong>501 Not Implemented&lt;/strong>」表示客户端请求的功能还不支持，类似“即将开业，敬请期待”的意思。&lt;/p>
&lt;p>「&lt;strong>502 Bad Gateway&lt;/strong>」通常是服务器作为网关或代理时返回的错误码，表示服务器自身工作正常，访问后端服务器发生了错误。&lt;/p>
&lt;p>「&lt;strong>503 Service Unavailable&lt;/strong>」表示服务器当前很忙，暂时无法响应服务器，类似“网络服务正忙，请稍后重试”的意思。&lt;/p>
&lt;h1 id="状态码">状态码&lt;/h1>
&lt;h2 id="消息1xx">消息，1XX&lt;/h2>
&lt;p>这一类型的状态码，代表请求已被接受，需要继续处理。这类响应是临时响应，只包含状态行和某些可选的响应头信息，并以空行结束。由于 HTTP/1.0 协议中没有定义任何 1xx 状态码，所以除非在某些试验条件下，服务器禁止向此类客户端发送 1xx 响应。&lt;/p>
&lt;ul>
&lt;li>100 Continue，客户端应当继续发送请求。这个临时响应是用来通知客户端它的部分请求已经被服务器接收，且仍未被拒绝。客户端应当继续发送请求的剩余部分，或者如果请求已经完成，忽略这个响应。服务器必须在请求完成后向客户端发送一个最终响应。&lt;/li>
&lt;li>101 Switching Protocols，服务器已经理解了客户端的请求，并将通过 Upgrade 消息头通知客户端采用不同的协议来完成这个请求。在发送完这个响应最后的空行后，服务器将会切换到在 Upgrade 消息头中定义的那些协议。只有在切换新的协议更有好处的时候才应该采取类似措施。例如，切换到新的 HTTP 版本比旧版本更有优势，或者切换到一个实时且同步的协议以传送利用此类特性的资源。&lt;/li>
&lt;/ul>
&lt;h2 id="成功2xx200-206">成功，2XX，（200-206）&lt;/h2>
&lt;p>这一类型的状态码，代表请求已成功被服务器接收、理解、并接受&lt;/p>
&lt;ul>
&lt;li>200 OK，请求已成功，请求的所有数据通过响应报文的 Entity-Body 这一部分发送&lt;/li>
&lt;li>201 Created，请求已经被实现，而且有一个新的资源已经依据请求的需要而建立，且其 URI 已经随 Location 头信息返回。假如需要的资源无法及时建立的话，应当返回 &amp;lsquo;202 Accepted&amp;rsquo;。&lt;/li>
&lt;li>202 Accepted，服务器已接受请求，但尚未处理。正如它可能被拒绝一样，最终该请求可能会也可能不会被执行。在异步操作的场合下，没有比发送这个状态码更方便的做法了。返回 202 状态码的响应的目的是允许服务器接受其他过程的请求（例如某个每天只执行一次的基于批处理的操作），而不必让客户端一直保持与服务器的连接直到批处理操作全部完成。在接受请求处理并返回 202 状态码的响应应当在返回的实体中包含一些指示处理当前状态的信息，以及指向处理状态监视器或状态预测的指针，以便用户能够估计操作是否已经完成。&lt;/li>
&lt;li>203 Non-Authoritative Information，服务器已成功处理了请求，但返回的实体头部元信息不是在原始服务器上有效的确定集合，而是来自本地或者第三方的拷贝。当前的信息可能是原始版本的子集或者超集。例如，包含资源的元数据可能导致原始服务器知道元信息的超集。使用此状态码不是必须的，而且只有在响应不使用此状态码便会返回 200 OK 的情况下才是合适的。&lt;/li>
&lt;li>204 No Content，服务器成功处理了请求，但不需要返回任何实体内容，并且希望返回更新了的元信息。响应可能通过实体头部的形式，返回新的或更新后的元信息。如果存在这些头部信息，则应当与所请求的变量相呼应。如果客户端是浏览器的话，那么用户浏览器应保留发送了该请求的页面，而不产生任何文档视图上的变化，即使按照规范新的或更新后的元信息应当被应用到用户浏览器活动视图中的文档。由于 204 响应被禁止包含任何消息体，因此它始终以消息头后的第一个空行结尾。&lt;/li>
&lt;li>205 Reset Content，服务器成功处理了请求，且没有返回任何内容。但是与 204 响应不同，返回此状态码的响应要求请求者重置文档视图。该响应主要是被用于接受用户输入后，立即重置表单，以便用户能够轻松地开始另一次输入。&lt;/li>
&lt;li>与 204 响应一样，该响应也被禁止包含任何消息体，且以消息头后的第一个空行结束。&lt;/li>
&lt;li>206 Partial Content，服务器已经成功处理了部分 GET 请求。类似于 FlashGet 或者迅雷这类的 HTTP 下载工具都是使用此类响应实现断点续传或者将一个大文档分解为多个下载段同时下载。该请求必须包含 Range 头信息来指示客户端希望得到的内容范围，并且可能包含 If-Range 来作为请求条件。
&lt;ul>
&lt;li>响应必须包含如下的头部域：&lt;/li>
&lt;li>Content-Range 用以指示本次响应中返回的内容的范围；如果是 Content-Type 为 multipart/byteranges 的多段下载，则每一 multipart 段中都应包含 Content-Range 域用以指示本段的内容范围。假如响应中包含 Content-Length，那么它的数值必须匹配它返回的内容范围的真实字节数。&lt;/li>
&lt;li>Date&lt;/li>
&lt;li>ETag 和/或 Content-Location，假如同样的请求本应该返回 200 响应。&lt;/li>
&lt;li>Expires, Cache-Control，和/或 Vary，假如其值可能与之前相同变量的其他响应对应的值不同的话。&lt;/li>
&lt;li>假如本响应请求使用了 If-Range 强缓存验证，那么本次响应不应该包含其他实体头；假如本响应的请求使用了 If-Range 弱缓存验证，那么本次响应禁止包含其他实体头；这避免了缓存的实体内容和更新了的实体头信息之间的不一致。否则，本响应就应当包含所有本应该返回 200 响应中应当返回的所有实体头部域。&lt;/li>
&lt;li>假如 ETag 或 Last-Modified 头部不能精确匹配的话，则客户端缓存应禁止将 206 响应返回的内容与之前任何缓存过的内容组合在一起。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>207 Multi-Status，由 WebDAV(RFC 2518)扩展的状态码，代表之后的消息体将是一个 XML 消息，并且可能依照之前子请求数量的不同，包含一系列独立的响应代码。&lt;/li>
&lt;/ul>
&lt;h2 id="重定向3xx300-305">重定向，3XX（300-305）&lt;/h2>
&lt;p>这类状态码代表需要客户端采取进一步的操作才能完成请求。通常，这些状态码用来重定向，后续的请求地址（重定向目标）在本次响应的 Location 域中指明。当且仅当后续的请求所使用的方法是 GET 或者 HEAD 时，用户浏览器才可以在没有用户介入的情况下自动提交所需要的后续请求。客户端应当自动监测无限循环重定向（例如：A-&amp;gt;A，或者 A-&amp;gt;B-&amp;gt;C-&amp;gt;A），因为这会导致服务器和客户端大量不必要的资源消耗。按照 HTTP/1.0 版规范的建议，浏览器不应自动访问超过 5 次的重定向。&lt;/p>
&lt;ul>
&lt;li>300 Multiple Choices，被请求的资源有一系列可供选择的回馈信息，每个都有自己特定的地址和浏览器驱动的商议信息。用户或浏览器能够自行选择一个首选的地址进行重定向。除非这是一个 HEAD 请求，否则该响应应当包括一个资源特性及地址的列表的实体，以便用户或浏览器从中选择最合适的重定向地址。这个实体的格式由 Content-Type 定义的格式所决定。浏览器可能根据响应的格式以及浏览器自身能力，自动作出最合适的选择。当然，RFC 2616 规范并没有规定这样的自动选择该如何进行。如果服务器本身已经有了首选的回馈选择，那么在 Location(位置)中应当指明这个回馈的 URL；浏览器可能会将这个 Location 值作为自动重定向的地址。此外，除非额外指定，否则这个响应也是可缓存的。&lt;/li>
&lt;li>301 Moved Permanently，永久重定向被请求的资源已永久移动到新位置，并且将来任何对此资源的引用都应该使用本响应返回的若干个 URL 之一。如果可能，拥有链接编辑功能的客户端应当自动把请求的地址修改为从服务器反馈回来的地址。除非额外指定，否则这个响应也是可缓存的。新的永久性的 URL 应当在响应的 Location 域中返回。除非这是一个 HEAD 请求，否则响应的实体中应当包含指向新的 URI 的超链接及简短说明。如果这不是一个 GET 或者 HEAD 请求，因此浏览器禁止自动进行重定向，除非得到用户的确认，因为请求的条件可能因此发生变化。
&lt;ul>
&lt;li>注意：对于某些使用 HTTP/1.0 协议的浏览器，当它们发送的 POST 请求得到了一个 301 响应的话，接下来的重定向请求将会变成 GET 方式。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>302 Move temporarily，临时重定向请求的资源临时从不同的 URL 响应请求。由于这样的重定向是临时的，客户端应当继续向原有地址发送以后的请求。只有在 Cache-Control 或 Expires 中进行了指定的情况下，这个响应才是可缓存的。如果这不是一个 GET 或者 HEAD 请求，那么浏览器禁止自动进行重定向，除非得到用户的确认，因为请求的条件可能因此发生变化。&lt;/li>
&lt;li>303 See Other，对应当前请求的响应可以在另一个 URI 上被找到，而且客户端应当采用 GET 的方式访问那个资源。这个方法的存在主要是为了允许由脚本激活的 POST 请求输出重定向到一个新的资源。这个新的 URI 不是原始资源的替代引用。同时，303 响应禁止被缓存。当然，第二个请求（重定向）可能被缓存。&lt;/li>
&lt;li>304 Not Modified，缓存没被修改，client 发出条件式请求，但 server 上的资源未曾发生改变（比如本地有缓存，client 就发出条件请求，向 server 确认该缓存是否有更新）如果客户端发送了一个带条件的 GET 请求且该请求已被允许，而文档的内容（自上次访问以来或者根据请求的条件）并没有改变，则服务器应当返回这个状态码。304 响应禁止包含消息体，因此始终以消息头后的第一个空行结尾。
&lt;ul>
&lt;li>该响应必须包含以下的头信息：
&lt;ul>
&lt;li>Date，除非这个服务器没有时钟。假如没有时钟的服务器也遵守这些规则，那么代理服务器以及客户端可以自行将 Date 字段添加到接收到的响应头中去，缓存机制将会正常工作。&lt;/li>
&lt;li>ETag 和/或 Content-Location，假如同样的请求本应返回 200 响应。&lt;/li>
&lt;li>Expires, Cache-Control，和/或 Vary，假如其值可能与之前相同变量的其他响应对应的值不同的话。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>假如本响应请求使用了强缓存验证，那么本次响应不应该包含其他实体头；否则（例如，某个带条件的 GET 请求使用了弱缓存验证），本次响应禁止包含其他实体头；这避免了缓存了的实体内容和更新了的实体头信息之间的不一致。&lt;/li>
&lt;li>假如某个 304 响应指明了当前某个实体没有缓存，那么缓存系统必须忽视这个响应，并且重复发送不包含限制条件的请求。&lt;/li>
&lt;li>假如接收到一个要求更新某个缓存条目的 304 响应，那么缓存系统必须更新整个条目以反映所有在响应中被更新的字段的值。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>305 Use Proxy，被请求的资源必须通过指定的代理才能被访问。Location 域中将给出指定的代理所在的 URI 信息，接收者需要重复发送一个单独的请求，通过这个代理才能访问相应资源。只有原始服务器才能建立 305 响应。&lt;/li>
&lt;li>306 Switch Proxy，在最新版的规范中，306 状态码已经不再被使用。&lt;/li>
&lt;li>307 Temporary Redirect，请求的资源临时从不同的 URI 响应请求。新的临时性的 URI 应当在响应的 Location 域中返回。除非这是一个 HEAD 请求，否则响应的实体中应当包含指向新的 URI 的超链接及简短说明。因为部分浏览器不能识别 307 响应，因此需要添加上述必要信息以便用户能够理解并向新的 URI 发出访问请求。如果这不是一个 GET 或者 HEAD 请求，那么浏览器禁止自动进行重定向，除非得到用户的确认，因为请求的条件可能因此发生变化。&lt;/li>
&lt;/ul>
&lt;h2 id="client-错误4xx400-415">client 错误，4XX（400-415）&lt;/h2>
&lt;p>这类的状态码代表了客户端看起来可能发生了错误，妨碍了服务器的处理。除非响应的是一个 HEAD 请求，否则服务器就应该返回一个解释当前错误状况的实体，以及这是临时的还是永久性的状况。这些状态码适用于任何请求方法。浏览器应当向用户显示任何包含在此类错误响应中的实体内容。&lt;/p>
&lt;p>如果错误发生时客户端正在传送数据，那么使用 TCP 的服务器实现应当仔细确保在关闭客户端与服务器之间的连接之前，客户端已经收到了包含错误信息的数据包。如果客户端在收到错误信息后继续向服务器发送数据，服务器的 TCP 栈将向客户端发送一个重置数据包，以清除该客户端所有还未识别的输入缓冲，以免这些数据被服务器上的应用程序读取并干扰后者。&lt;/p>
&lt;ul>
&lt;li>400 Bad Request
&lt;ul>
&lt;li>语义有误，当前请求无法被服务器理解。除非进行修改，否则客户端不应该重复提交这个请求。&lt;/li>
&lt;li>请求参数有误。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>401 Unauthorized，当前请求需要用户验证。该响应必须包含一个适用于被请求资源的 WWW-Authenticate 信息头用以询问用户信息。客户端可以重复提交一个包含恰当的 Authorization 头信息的请求。如果当前请求已经包含了 Authorization 证书，那么 401 响应代表着服务器验证已经拒绝了那些证书。如果 401 响应包含了与前一个响应相同的身份验证询问，且浏览器已经至少尝试了一次验证，那么浏览器应当向用户展示响应中包含的实体信息，因为这个实体信息中可能包含了相关诊断信息。参见 RFC 2617。&lt;/li>
&lt;li>402 Payment Required，该状态码是为了将来可能的需求而预留的。&lt;/li>
&lt;li>403 Forbidden，请求被禁止，服务器已经理解请求，但是拒绝执行它。与 401 响应不同的是，身份验证并不能提供任何帮助，而且这个请求也不应该被重复提交。如果这不是一个 HEAD 请求，而且服务器希望能够讲清楚为何请求不能被执行，那么就应该在实体内描述拒绝的原因。当然服务器也可以返回一个 404 响应，假如它不希望让客户端获得任何信息。&lt;/li>
&lt;li>404 Not Found，server 无法找到 client 请求的 resource。没有信息能够告诉用户这个状况到底是暂时的还是永久的。假如服务器知道情况的话，应当使用 410 状态码来告知旧资源因为某些内部的配置机制问题，已经永久的不可用，而且没有任何可以跳转的地址。404 这个状态码被广泛应用于当服务器不想揭示到底为何请求被拒绝或者没有其他适合的响应可用的情况下。出现这个错误的最有可能的原因是服务器端没有这个页面。&lt;/li>
&lt;li>405 Method Not Allowed，请求行中指定的请求方法不能被用于请求相应的资源。该响应必须返回一个 Allow 头信息用以表示出当前资源能够接受的请求方法的列表。鉴于 PUT，DELETE 方法会对服务器上的资源进行写操作，因而绝大部分的网页服务器都不支持或者在默认配置下不允许上述请求方法，对于此类请求均会返回 405 错误。&lt;/li>
&lt;li>406 Not Acceptable，请求的资源的内容特性无法满足请求头中的条件，因而无法生成响应实体。除非这是一个 HEAD 请求，否则该响应就应当返回一个包含可以让用户或者浏览器从中选择最合适的实体特性以及地址列表的实体。实体的格式由 Content-Type 头中定义的媒体类型决定。浏览器可以根据格式及自身能力自行作出最佳选择。但是，规范中并没有定义任何作出此类自动选择的标准。&lt;/li>
&lt;li>407 Proxy Authentication Required，与 401 响应类似，只不过客户端必须在代理服务器上进行身份验证。代理服务器必须返回一个 Proxy-Authenticate 用以进行身份询问。客户端可以返回一个 Proxy-Authorization 信息头用以验证。参见 RFC 2617。&lt;/li>
&lt;li>408 Request Timeout，请求超时。客户端没有在服务器预备等待的时间内完成一个请求的发送。客户端可以随时再次提交这一请求而无需进行任何更改。&lt;/li>
&lt;li>409 Conflict，由于和被请求的资源的当前状态之间存在冲突，请求无法完成。这个代码只允许用在这样的情况下才能被使用：用户被认为能够解决冲突，并且会重新提交新的请求。该响应应当包含足够的信息以便用户发现冲突的源头。冲突通常发生于对 PUT 请求的处理中。例如，在采用版本检查的环境下，某次 PUT 提交的对特定资源的修改请求所附带的版本信息与之前的某个（第三方）请求向冲突，那么此时服务器就应该返回一个 409 错误，告知用户请求无法完成。此时，响应实体中很可能会包含两个冲突版本之间的差异比较，以便用户重新提交归并以后的新版本。&lt;/li>
&lt;li>410 Gone，被请求的资源在服务器上已经不再可用，而且没有任何已知的转发地址。这样的状况应当被认为是永久性的。如果可能，拥有链接编辑功能的客户端应当在获得用户许可后删除所有指向这个地址的引用。如果服务器不知道或者无法确定这个状况是否是永久的，那么就应该使用 404 状态码。除非额外说明，否则这个响应是可缓存的。410 响应的目的主要是帮助网站管理员维护网站，通知用户该资源已经不再可用，并且服务器拥有者希望所有指向这个资源的远端连接也被删除。这类事件在限时、增值服务中很普遍。同样，410 响应也被用于通知客户端在当前服务器站点上，原本属于某个个人的资源已经不再可用。当然，是否需要把所有永久不可用的资源标记为'410 Gone&amp;rsquo;，以及是否需要保持此标记多长时间，完全取决于服务器拥有者。&lt;/li>
&lt;li>411 Length Required，服务器拒绝在没有定义 Content-Length 头的情况下接受请求。在添加了表明请求消息体长度的有效 Content-Length 头之后，客户端可以再次提交该请求。&lt;/li>
&lt;li>412 Precondition Failed。服务器在验证在请求的头字段中给出先决条件时，没能满足其中的一个或多个。这个状态码允许客户端在获取资源时在请求的元信息（请求头字段数据）中设置先决条件，以此避免该请求方法被应用到其希望的内容以外的资源上。&lt;/li>
&lt;li>413 Request Entity Too Large。服务器拒绝处理当前请求，因为该请求提交的实体数据大小超过了服务器愿意或者能够处理的范围。此种情况下，服务器可以关闭连接以免客户端继续发送此请求。如果这个状况是临时的，服务器应当返回一个 Retry-After 的响应头，以告知客户端可以在多少时间以后重新尝试。&lt;/li>
&lt;li>414 Request-URI Too Long。请求的 URL 长度超过了服务器能够解释的长度，因此服务器拒绝对该请求提供服务。这比较少见，通常的情况包括：
&lt;ul>
&lt;li>本应使用 POST 方法的表单提交变成了 GET 方法，导致查询字符串（Query String）过长。&lt;/li>
&lt;li>重定向 URL “黑洞”，例如每次重定向把旧的 URI 作为新的 URI 的一部分，导致在若干次重定向后 URI 超长。&lt;/li>
&lt;li>客户端正在尝试利用某些服务器中存在的安全漏洞攻击服务器。这类服务器使用固定长度的缓冲读取或操作请求的 URI，当 GET 后的参数超过某个数值后，可能会产生缓冲区溢出，导致任意代码被执行。没有此类漏洞的服务器，应当返回 414 状态码。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>415 Unsupported Media Type。对于当前请求的方法和所请求的资源，请求中提交的实体并不是服务器中所支持的格式，因此请求被拒绝。&lt;/li>
&lt;li>416 Requested Range Not Satisfiable。如果请求中包含了 Range 请求头，并且 Range 中指定的任何数据范围都与当前资源的可用范围不重合，同时请求中又没有定义 If-Range 请求头，那么服务器就应当返回 416 状态码。假如 Range 使用的是字节范围，那么这种情况就是指请求指定的所有数据范围的首字节位置都超过了当前资源的长度。服务器也应当在返回 416 状态码的同时，包含一个 Content-Range 实体头，用以指明当前资源的长度。这个响应也被禁止使用 multipart/byteranges 作为其 Content-Type。&lt;/li>
&lt;li>417 Expectation Failed。在请求头 Expect 中指定的预期内容无法被服务器满足，或者这个服务器是一个代理服务器，它有明显的证据证明在当前路由的下一个节点上，Expect 的内容无法被满足。&lt;/li>
&lt;li>421 too many connections。There are too many connections from your internet address 从当前客户端所在的 IP 地址到服务器的连接数超过了服务器许可的最大范围。通常，这里的 IP 地址指的是从服务器上看到的客户端地址（比如用户的网关或者代理服务器地址）。在这种情况下，连接数的计算可能涉及到不止一个终端用户。&lt;/li>
&lt;li>426 Upgrade Required 是一种 HTTP 协议的错误状态代码，表示服务器拒绝处理客户端使用当前协议发送的请求，但是可以接受其使用升级后的协议发送的请求。比如 http1.0 发起请求，http1.1 响应请求，一般会出现这个状态码&lt;/li>
&lt;/ul>
&lt;h2 id="server-错误5xx500-505">server 错误，5XX（500-505）&lt;/h2>
&lt;p>（5、6 字头）这类状态码代表了服务器在处理请求的过程中有错误或者异常状态发生，也有可能是服务器意识到以当前的软硬件资源无法完成对请求的处理。除非这是一个 HEAD 请求，否则服务器应当包含一个解释当前错误状态以及这个状况是临时的还是永久的解释信息实体。浏览器应当向用户展示任何在当前响应中被包含的实体。这些状态码适用于任何响应方法。&lt;/p>
&lt;ul>
&lt;li>500 Internal Server Error。服务器遇到了一个未曾预料的状况，导致了它无法完成对请求的处理。一般来说，这个问题都会在服务器端的源代码出现错误时出现。&lt;/li>
&lt;li>501 Not Implemented。服务器不支持当前请求所需要的某个功能。当服务器无法识别请求的方法，并且无法支持其对任何资源的请求。&lt;/li>
&lt;li>502 Bad Gateway。作为网关或者代理工作的服务器尝试执行请求时，从上游服务器接收到无效的响应。&lt;/li>
&lt;li>503 Service Unavailable。由于临时的服务器维护或者过载，服务器当前无法处理请求。这个状况是临时的，并且将在一段时间以后恢复。如果能够预计延迟时间，那么响应中可以包含一个 Retry-After 头用以标明这个延迟时间。如果没有给出这个 Retry-After 信息，那么客户端应当以处理 500 响应的方式处理它。
&lt;ul>
&lt;li>注意：503 状态码的存在并不意味着服务器在过载的时候必须使用它。某些服务器只不过是希望拒绝客户端的连接。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>504 Gateway Timeout。作为网关或者代理工作的服务器尝试执行请求时，未能及时从上游服务器（URI 标识出的服务器，例如 HTTP、FTP、LDAP）或者辅助服务器（例如 DNS）收到响应。
&lt;ul>
&lt;li>注意：某些代理服务器在 DNS 查询超时时会返回 400 或者 500 错误&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>505 HTTP Version Not Supported。服务器不支持，或者拒绝支持在请求中使用的 HTTP 版本。这暗示着服务器不能或不愿使用与客户端相同的版本。响应中应当包含一个描述了为何版本不被支持以及服务器支持哪些协议的实体。&lt;/li>
&lt;li>506 Variant Also Negotiates。由《透明内容协商协议》（RFC 2295）扩展，代表服务器存在内部配置错误：被请求的协商变元资源被配置为在透明内容协商中使用自己，因此在一个协商处理中不是一个合适的重点。&lt;/li>
&lt;li>507 Insufficient Storage。服务器无法存储完成请求所必须的内容。这个状况被认为是临时的。WebDAV (RFC 4918)&lt;/li>
&lt;li>509 Bandwidth Limit Exceeded。服务器达到带宽限制。这不是一个官方的状态码，但是仍被广泛使用。&lt;/li>
&lt;li>510 Not Extended。获取资源所需要的策略并没有被满足。（RFC 2774）&lt;/li>
&lt;li>600 Unparseable Response Headers。源站没有返回响应头部，只返回实体内容&lt;/li>
&lt;/ul></description></item><item><title>Docs: HTTP 的 持久化 与 认证_授权</title><link>https://desistdaydream.github.io/docs/IT%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/4.%E6%95%B0%E6%8D%AE%E9%80%9A%E4%BF%A1/%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/7.HTTP/HTTP-%E7%9A%84-%E6%8C%81%E4%B9%85%E5%8C%96-%E4%B8%8E-%E8%AE%A4%E8%AF%81_%E6%8E%88%E6%9D%83/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/IT%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/4.%E6%95%B0%E6%8D%AE%E9%80%9A%E4%BF%A1/%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/7.HTTP/HTTP-%E7%9A%84-%E6%8C%81%E4%B9%85%E5%8C%96-%E4%B8%8E-%E8%AE%A4%E8%AF%81_%E6%8E%88%E6%9D%83/</guid><description/></item><item><title>Docs: HTTP 的 持久化 与 认证/授权</title><link>https://desistdaydream.github.io/docs/IT%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/4.%E6%95%B0%E6%8D%AE%E9%80%9A%E4%BF%A1/%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/7.HTTP/HTTP-%E7%9A%84-%E6%8C%81%E4%B9%85%E5%8C%96-%E4%B8%8E-%E8%AE%A4%E8%AF%81_%E6%8E%88%E6%9D%83/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/IT%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/4.%E6%95%B0%E6%8D%AE%E9%80%9A%E4%BF%A1/%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/7.HTTP/HTTP-%E7%9A%84-%E6%8C%81%E4%B9%85%E5%8C%96-%E4%B8%8E-%E8%AE%A4%E8%AF%81_%E6%8E%88%E6%9D%83/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>原文链接：&lt;a href="https://juejin.cn/post/6844904034181070861">https://juejin.cn/post/6844904034181070861&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;h1 id="傻傻分不清之-cookiesessiontokenjwt">傻傻分不清之 Cookie、Session、Token、JWT&lt;/h1>
&lt;h2 id="什么是认证authentication">什么是认证（Authentication）&lt;/h2>
&lt;ul>
&lt;li>通俗地讲就是&lt;strong>验证当前用户的身份&lt;/strong>，证明“你是你自己”（比如：你每天上下班打卡，都需要通过指纹打卡，当你的指纹和系统里录入的指纹相匹配时，就打卡成功）&lt;/li>
&lt;li>互联网中的认证：
&lt;ul>
&lt;li>用户名密码登录&lt;/li>
&lt;li>邮箱发送登录链接&lt;/li>
&lt;li>手机号接收验证码&lt;/li>
&lt;li>只要你能收到邮箱/验证码，就默认你是账号的主人&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h2 id="什么是授权authorization">什么是授权（Authorization）&lt;/h2>
&lt;ul>
&lt;li>&lt;strong>用户授予第三方应用访问该用户某些资源的权限&lt;/strong>
&lt;ul>
&lt;li>你在安装手机应用的时候，APP 会询问是否允许授予权限（访问相册、地理位置等权限）&lt;/li>
&lt;li>你在访问微信小程序时，当登录时，小程序会询问是否允许授予权限（获取昵称、头像、地区、性别等个人信息）&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>实现授权的方式有：cookie、session、token、OAuth&lt;/li>
&lt;/ul>
&lt;h2 id="什么是凭证credentials">什么是凭证（Credentials）&lt;/h2>
&lt;ul>
&lt;li>&lt;strong>实现认证和授权的前提&lt;/strong>是需要一种**媒介（证书）**来标记访问者的身份
&lt;ul>
&lt;li>在战国时期，商鞅变法，发明了照身帖。照身帖由官府发放，是一块打磨光滑细密的竹板，上面刻有持有人的头像和籍贯信息。国人必须持有，如若没有就被认为是黑户，或者间谍之类的。&lt;/li>
&lt;li>在现实生活中，每个人都会有一张专属的&lt;a href="https://baike.baidu.com/item/%E5%B1%85%E6%B0%91%E8%BA%AB%E4%BB%BD%E8%AF%81/2080960">居民身份证&lt;/a>，是用于证明持有人身份的一种法定&lt;a href="https://baike.baidu.com/item/%E8%AF%81%E4%BB%B6/5804999">证件&lt;/a>。通过身份证，我们可以办理手机卡/银行卡/个人贷款/交通出行等等，这就是&lt;strong>认证的凭证。&lt;/strong>&lt;/li>
&lt;li>在互联网应用中，一般网站（如掘金）会有两种模式，游客模式和登录模式。游客模式下，可以正常浏览网站上面的文章，一旦想要点赞/收藏/分享文章，就需要登录或者注册账号。当用户登录成功后，服务器会给该用户使用的浏览器颁发一个令牌（token），这个令牌用来表明你的身份，每次浏览器发送请求时会带上这个令牌，就可以使用游客模式下无法使用的功能。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h2 id="什么是-cookie">什么是 Cookie&lt;/h2>
&lt;ul>
&lt;li>&lt;strong>HTTP 是无状态的协议（对于事务处理没有记忆能力，每次客户端和服务端会话完成时，服务端不会保存任何会话信息&lt;/strong>）：每个请求都是完全独立的，服务端无法确认当前访问者的身份信息，无法分辨上一次的请求发送者和这一次的发送者是不是同一个人。所以服务器与浏览器为了进行会话跟踪（知道是谁在访问我），就必须主动的去维护一个状态，这个状态用于告知服务端前后两个请求是否来自同一浏览器。而这个状态需要通过 cookie 或者 session 去实现。&lt;/li>
&lt;li>&lt;strong>cookie 存储在客户端：&lt;/strong> cookie 是服务器发送到用户浏览器并保存在本地的一小块数据，它会在浏览器下次向同一服务器再发起请求时被携带并发送到服务器上。&lt;/li>
&lt;li>&lt;strong>cookie 是不可跨域的：&lt;/strong> 每个 cookie 都会绑定单一的域名，无法在别的域名下获取使用，&lt;strong>一级域名和二级域名之间是允许共享使用的&lt;/strong>（&lt;strong>靠的是 domain）&lt;/strong>。&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>cookie 重要的属性&lt;/strong>&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>属性&lt;/th>
&lt;th>说明&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>&lt;strong>name=value&lt;/strong>&lt;/td>
&lt;td>键值对，设置 Cookie 的名称及相对应的值，都必须是&lt;strong>字符串类型&lt;/strong>&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>- 如果值为 Unicode 字符，需要为字符编码。
- 如果值为二进制数据，则需要使用 BASE64 编码。
|
| &lt;strong>domain&lt;/strong> | 指定 cookie 所属域名，默认是当前域名 |
| &lt;strong>path&lt;/strong> | &lt;strong>指定 cookie 在哪个路径（路由）下生效，默认是 &amp;lsquo;/&amp;rsquo;&lt;/strong>。
如果设置为 &lt;code>/abc&lt;/code>，则只有 &lt;code>/abc&lt;/code> 下的路由可以访问到该 cookie，如：&lt;code>/abc/read&lt;/code>。 |
| &lt;strong>maxAge&lt;/strong> | cookie 失效的时间，单位秒。如果为整数，则该 cookie 在 maxAge 秒后失效。如果为负数，该 cookie 为临时 cookie ，关闭浏览器即失效，浏览器也不会以任何形式保存该 cookie 。如果为 0，表示删除该 cookie 。默认为 -1。
- &lt;strong>比 expires 好用&lt;/strong>。
|
| &lt;strong>expires&lt;/strong> | 过期时间，在设置的某个时间点后该 cookie 就会失效。
一般浏览器的 cookie 都是默认储存的，当关闭浏览器结束这个会话的时候，这个 cookie 也就会被删除 |
| &lt;strong>secure&lt;/strong> | 该 cookie 是否仅被使用安全协议传输。安全协议有 HTTPS，SSL 等，在网络上传输数据之前先将数据加密。默认为 false。
当 secure 值为 true 时，cookie 在 HTTP 中是无效，在 HTTPS 中才有效。 |
| &lt;strong>httpOnly&lt;/strong> | &lt;strong>如果给某个 cookie 设置了 httpOnly 属性，则无法通过 JS 脚本 读取到该 cookie 的信息，但还是能通过 Application 中手动修改 cookie，所以只是在一定程度上可以防止 XSS 攻击，不是绝对的安全&lt;/strong> |
| | |&lt;/p>
&lt;h2 id="什么是-session">什么是 Session&lt;/h2>
&lt;ul>
&lt;li>&lt;strong>session 是另一种记录服务器和客户端会话状态的机制&lt;/strong>&lt;/li>
&lt;li>&lt;strong>session 是基于 cookie 实现的，session 存储在服务器端，sessionId 会被存储到客户端的 cookie 中&lt;/strong>&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/rv7ih5/1623681275011-42bd5bea-dbaf-4605-95a2-c433d48b78c8.webp" alt="">&lt;/p>
&lt;ul>
&lt;li>&lt;strong>session 认证流程：&lt;/strong>
&lt;ul>
&lt;li>用户第一次请求服务器的时候，服务器根据用户提交的相关信息，创建对应的 Session&lt;/li>
&lt;li>请求返回时将此 Session 的唯一标识信息 SessionID 返回给浏览器&lt;/li>
&lt;li>浏览器接收到服务器返回的 SessionID 信息后，会将此信息存入到 Cookie 中，同时 Cookie 记录此 SessionID 属于哪个域名&lt;/li>
&lt;li>当用户第二次访问服务器的时候，请求会自动判断此域名下是否存在 Cookie 信息，如果存在自动将 Cookie 信息也发送给服务端，服务端会从 Cookie 中获取 SessionID，再根据 SessionID 查找对应的 Session 信息，如果没有找到说明用户没有登录或者登录失效，如果找到 Session 证明用户已经登录可执行后面操作。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>根据以上流程可知，&lt;strong>SessionID 是连接 Cookie 和 Session 的一道桥梁&lt;/strong>，大部分系统也是根据此原理来验证用户登录状态。&lt;/p>
&lt;h2 id="cookie-和-session-的区别">Cookie 和 Session 的区别&lt;/h2>
&lt;ul>
&lt;li>&lt;strong>安全性：&lt;/strong> Session 比 Cookie 安全，Session 是存储在服务器端的，Cookie 是存储在客户端的。&lt;/li>
&lt;li>&lt;strong>存取值的类型不同&lt;/strong>：Cookie 只支持存字符串数据，想要设置其他类型的数据，需要将其转换成字符串，Session 可以存任意数据类型。&lt;/li>
&lt;li>&lt;strong>有效期不同：&lt;/strong> Cookie 可设置为长时间保持，比如我们经常使用的默认登录功能，Session 一般失效时间较短，客户端关闭（默认情况下）或者 Session 超时都会失效。&lt;/li>
&lt;li>&lt;strong>存储大小不同：&lt;/strong> 单个 Cookie 保存的数据不能超过 4K，Session 可存储数据远高于 Cookie，但是当访问量过多，会占用过多的服务器资源。&lt;/li>
&lt;/ul>
&lt;h2 id="什么是-token令牌">什么是 Token（令牌）&lt;/h2>
&lt;h3 id="acesss-token">Acesss Token&lt;/h3>
&lt;ul>
&lt;li>&lt;strong>访问资源接口（API）时所需要的资源凭证&lt;/strong>&lt;/li>
&lt;li>&lt;strong>简单 token 的组成：&lt;/strong> uid(用户唯一的身份标识)、time(当前时间的时间戳)、sign（签名，token 的前几位以哈希算法压缩成的一定长度的十六进制字符串）&lt;/li>
&lt;li>&lt;strong>特点：&lt;/strong>
&lt;ul>
&lt;li>&lt;strong>服务端无状态化、可扩展性好&lt;/strong>&lt;/li>
&lt;li>&lt;strong>支持移动端设备&lt;/strong>&lt;/li>
&lt;li>安全&lt;/li>
&lt;li>支持跨程序调用&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>token 的身份验证流程：&lt;/strong>&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/rv7ih5/1623681275029-dccf3312-cfa7-4ac5-9008-0697991e35b3.webp" alt="">&lt;/p>
&lt;ol>
&lt;li>客户端使用用户名跟密码请求登录&lt;/li>
&lt;li>服务端收到请求，去验证用户名与密码&lt;/li>
&lt;li>验证成功后，服务端会签发一个 token 并把这个 token 发送给客户端&lt;/li>
&lt;li>客户端收到 token 以后，会把它存储起来，比如放在 cookie 里或者 localStorage 里&lt;/li>
&lt;li>客户端每次向服务端请求资源的时候需要带着服务端签发的 token&lt;/li>
&lt;li>服务端收到请求，然后去验证客户端请求里面带着的 token ，如果验证成功，就向客户端返回请求的数据&lt;/li>
&lt;/ol>
&lt;ul>
&lt;li>&lt;strong>每一次请求都需要携带 token，需要把 token 放到 HTTP 的 Header 里&lt;/strong>&lt;/li>
&lt;li>&lt;strong>基于 token 的用户认证是一种服务端无状态的认证方式，服务端不用存放 token 数据。用解析 token 的计算时间换取 session 的存储空间，从而减轻服务器的压力，减少频繁的查询数据库&lt;/strong>&lt;/li>
&lt;li>&lt;strong>token 完全由应用管理，所以它可以避开同源策略&lt;/strong>&lt;/li>
&lt;/ul>
&lt;h3 id="refresh-token">Refresh Token&lt;/h3>
&lt;ul>
&lt;li>
&lt;p>另外一种 token——refresh token&lt;/p>
&lt;/li>
&lt;li>
&lt;p>refresh token 是专用于刷新 access token 的 token。如果没有 refresh token，也可以刷新 access token，但每次刷新都要用户输入登录用户名与密码，会很麻烦。有了 refresh token，可以减少这个麻烦，客户端直接用 refresh token 去更新 access token，无需用户进行额外的操作。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/rv7ih5/1623681275000-372bff85-cf45-4502-a00d-981a4d52f36b.webp" alt="">&lt;/p>
&lt;ul>
&lt;li>Access Token 的有效期比较短，当 Acesss Token 由于过期而失效时，使用 Refresh Token 就可以获取到新的 Token，如果 Refresh Token 也失效了，用户就只能重新登录了。&lt;/li>
&lt;li>Refresh Token 及过期时间是存储在服务器的数据库中，只有在申请新的 Acesss Token 时才会验证，不会对业务接口响应时间造成影响，也不需要向 Session 一样一直保持在内存中以应对大量的请求。&lt;/li>
&lt;/ul>
&lt;h2 id="token-和-session-的区别">Token 和 Session 的区别&lt;/h2>
&lt;ul>
&lt;li>Session 是一种&lt;strong>记录服务器和客户端会话状态的机制，使服务端有状态化，可以记录会话信息&lt;/strong>。而 Token 是&lt;strong>令牌&lt;/strong>，&lt;strong>访问资源接口（API）时所需要的资源凭证&lt;/strong>。Token &lt;strong>使服务端无状态化，不会存储会话信息。&lt;/strong>&lt;/li>
&lt;li>Session 和 Token 并不矛盾，作为身份认证 Token 安全性比 Session 好，因为每一个请求都有签名还能防止监听以及重放攻击，而 Session 就必须依赖链路层来保障通讯安全了。&lt;strong>如果你需要实现有状态的会话，仍然可以增加 Session 来在服务器端保存一些状态。&lt;/strong>&lt;/li>
&lt;li>所谓 Session 认证只是简单的把 User 信息存储到 Session 里，因为 SessionID 的不可预测性，暂且认为是安全的。而 Token ，如果指的是 OAuth Token 或类似的机制的话，提供的是 认证 和 授权 ，认证是针对用户，授权是针对 App 。其目的是让某 App 有权利访问某用户的信息。这里的 Token 是唯一的。不可以转移到其它 App 上，也不可以转到其它用户上。Session 只提供一种简单的认证，即只要有此 SessionID ，即认为有此 User 的全部权利。是需要严格保密的，这个数据应该只保存在站方，不应该共享给其它网站或者第三方 App。所以简单来说：&lt;strong>如果你的用户数据可能需要和第三方共享，或者允许第三方调用 API 接口，用 Token 。如果永远只是自己的网站，自己的 App，用什么就无所谓了。&lt;/strong>&lt;/li>
&lt;/ul>
&lt;h2 id="什么是-jwt">什么是 JWT&lt;/h2>
&lt;ul>
&lt;li>JSON Web Token（简称 JWT）是目前最流行的&lt;strong>跨域认证&lt;/strong>解决方案。&lt;/li>
&lt;li>是一种&lt;strong>认证授权机制&lt;/strong>。&lt;/li>
&lt;li>JWT 是为了在网络应用环境间&lt;strong>传递声明&lt;/strong>而执行的一种基于 JSON 的开放标准（&lt;a href="https://tools.ietf.org/html/rfc7519">RFC 7519&lt;/a>）。JWT 的声明一般被用来在身份提供者和服务提供者间传递被认证的用户身份信息，以便于从资源服务器获取资源。比如用在用户登录上。&lt;/li>
&lt;li>可以使用 HMAC 算法或者是 RSA 的公/私秘钥对 JWT 进行签名。因为数字签名的存在，这些传递的信息是可信的。&lt;/li>
&lt;li>&lt;strong>阮一峰老师的 &lt;a href="http://www.ruanyifeng.com/blog/2018/07/json_web_token-tutorial.html">JSON Web Token 入门教程&lt;/a> 讲的非常通俗易懂，这里就不再班门弄斧了&lt;/strong>&lt;/li>
&lt;/ul>
&lt;h3 id="生成-jwt">生成 JWT&lt;/h3>
&lt;p>&lt;a href="https://jwt.io/">jwt.io/&lt;/a>
&lt;a href="https://www.jsonwebtoken.io/">www.jsonwebtoken.io/&lt;/a>&lt;/p>
&lt;h3 id="jwt-的原理">JWT 的原理&lt;/h3>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/rv7ih5/1623681275062-caae1d23-b1ee-4012-a7a6-551725463c32.webp" alt="">&lt;/p>
&lt;ul>
&lt;li>
&lt;p>&lt;strong>JWT 认证流程：&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>
&lt;p>用户输入用户名/密码登录，服务端认证成功后，会返回给客户端一个 JWT&lt;/p>
&lt;/li>
&lt;li>
&lt;p>客户端将 token 保存到本地（通常使用 localstorage，也可以使用 cookie）&lt;/p>
&lt;/li>
&lt;li>
&lt;p>当用户希望访问一个受保护的路由或者资源的时候，需要请求头的 Authorization 字段中使用 Bearer 模式添加 JWT，其内容看起来是下面这样&lt;/p>
&lt;p>Authorization: Bearer &lt;!-- raw HTML omitted -->
复制代码&lt;/p>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>服务端的保护路由将会检查请求头 Authorization 中的 JWT 信息，如果合法，则允许用户的行为&lt;/p>
&lt;/li>
&lt;li>
&lt;p>因为 JWT 是自包含的（内部包含了一些会话信息），因此减少了需要查询数据库的需要&lt;/p>
&lt;/li>
&lt;li>
&lt;p>因为 JWT 并不使用 Cookie 的，所以你可以使用任何域名提供你的 API 服务而不需要担心跨域资源共享问题（CORS）&lt;/p>
&lt;/li>
&lt;li>
&lt;p>因为用户的状态不再存储在服务端的内存中，所以这是一种无状态的认证机制&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h3 id="jwt-的使用方式">JWT 的使用方式&lt;/h3>
&lt;ul>
&lt;li>客户端收到服务器返回的 JWT，可以储存在 Cookie 里面，也可以储存在 localStorage。&lt;/li>
&lt;/ul>
&lt;h4 id="方式一">方式一&lt;/h4>
&lt;ul>
&lt;li>
&lt;p>当用户希望访问一个受保护的路由或者资源的时候，可以把它放在 Cookie 里面自动发送，但是这样不能跨域，所以更好的做法是放在 HTTP 请求头信息的 Authorization 字段里，使用 Bearer 模式添加 JWT。&lt;/p>
&lt;p>GET /calendar/v1/events
Host: api.example.com
Authorization: Bearer &lt;!-- raw HTML omitted -->
复制代码&lt;/p>
&lt;/li>
&lt;li>
&lt;p>用户的状态不会存储在服务端的内存中，这是一种 &lt;strong>无状态的认证机制&lt;/strong>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>服务端的保护路由将会检查请求头 Authorization 中的 JWT 信息，如果合法，则允许用户的行为。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>由于 JWT 是自包含的，因此减少了需要查询数据库的需要&lt;/p>
&lt;/li>
&lt;li>
&lt;p>JWT 的这些特性使得我们可以完全依赖其无状态的特性提供数据 API 服务，甚至是创建一个下载流服务。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>因为 JWT 并不使用 Cookie ，所以你可以使用任何域名提供你的 API 服务而&lt;strong>不需要担心跨域资源共享问题&lt;/strong>（CORS）&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h4 id="方式二">方式二&lt;/h4>
&lt;ul>
&lt;li>跨域的时候，可以把 JWT 放在 POST 请求的数据体里。&lt;/li>
&lt;/ul>
&lt;h4 id="方式三">方式三&lt;/h4>
&lt;ul>
&lt;li>
&lt;p>通过 URL 传输&lt;/p>
&lt;p>&lt;a href="http://www.example.com/user?token=xxx">http://www.example.com/user?token=xxx&lt;/a>
复制代码&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h3 id="项目中使用-jwt">项目中使用 JWT&lt;/h3>
&lt;p>&lt;a href="https://github.com/yjdjiayou/jwt-demo">&lt;strong>项目地址&lt;/strong>&lt;/a>&lt;/p>
&lt;h2 id="token-和-jwt-的区别">Token 和 JWT 的区别&lt;/h2>
&lt;p>&lt;strong>相同：&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>都是访问资源的令牌&lt;/li>
&lt;li>都可以记录用户的信息&lt;/li>
&lt;li>都是使服务端无状态化&lt;/li>
&lt;li>都是只有验证成功后，客户端才能访问服务端上受保护的资源&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>区别：&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>Token：服务端验证客户端发送过来的 Token 时，还需要查询数据库获取用户信息，然后验证 Token 是否有效。&lt;/li>
&lt;li>JWT： 将 Token 和 Payload 加密后存储于客户端，服务端只需要使用密钥解密进行校验（校验也是 JWT 自己实现的）即可，不需要查询或者减少查询数据库，因为 JWT 自包含了用户信息和加密的数据。&lt;/li>
&lt;/ul>
&lt;h2 id="常见的前后端鉴权方式">常见的前后端鉴权方式&lt;/h2>
&lt;ol>
&lt;li>Session-Cookie&lt;/li>
&lt;li>Token 验证（包括 JWT，SSO）&lt;/li>
&lt;li>OAuth2.0（开放授权）&lt;/li>
&lt;/ol>
&lt;h2 id="常见的加密算法">常见的加密算法&lt;/h2>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/rv7ih5/1623681275046-ccd24609-06ff-4db8-95c9-6619fb91e5ae.webp" alt="">&lt;/p>
&lt;ul>
&lt;li>哈希算法(Hash Algorithm)又称散列算法、散列函数、哈希函数，是一种从任何一种数据中创建小的数字“指纹”的方法。哈希算法将数据重新打乱混合，重新创建一个哈希值。&lt;/li>
&lt;li>哈希算法主要用来保障数据真实性(即完整性)，即发信人将原始消息和哈希值一起发送，收信人通过相同的哈希函数来校验原始数据是否真实。&lt;/li>
&lt;li>哈希算法通常有以下几个特点：
&lt;ul>
&lt;li>正像快速：原始数据可以快速计算出哈希值&lt;/li>
&lt;li>逆向困难：通过哈希值基本不可能推导出原始数据&lt;/li>
&lt;li>输入敏感：原始数据只要有一点变动，得到的哈希值差别很大&lt;/li>
&lt;li>冲突避免：很难找到不同的原始数据得到相同的哈希值，宇宙中原子数大约在 10 的 60 次方到 80 次方之间，所以 2 的 256 次方有足够的空间容纳所有的可能，算法好的情况下冲突碰撞的概率很低：
&lt;ul>
&lt;li>2 的 128 次方为 340282366920938463463374607431768211456，也就是 10 的 39 次方级别&lt;/li>
&lt;li>2 的 160 次方为 1.4615016373309029182036848327163e+48，也就是 10 的 48 次方级别&lt;/li>
&lt;li>2 的 256 次方为 1.1579208923731619542357098500869 × 10 的 77 次方，也就是 10 的 77 次方&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>注意：&lt;/strong>&lt;/p>
&lt;ol>
&lt;li>以上不能保证数据被恶意篡改，原始数据和哈希值都可能被恶意篡改，要保证不被篡改，可以使用 RSA 公钥私钥方案，再配合哈希值。&lt;/li>
&lt;li>哈希算法主要用来防止计算机传输过程中的错误，早期计算机通过前 7 位数据第 8 位奇偶校验码来保障（12.5% 的浪费效率低），对于一段数据或文件，通过哈希算法生成 128bit 或者 256bit 的哈希值，如果校验有问题就要求重传。&lt;/li>
&lt;/ol>
&lt;h2 id="常见问题">常见问题&lt;/h2>
&lt;h3 id="使用-cookie-时需要考虑的问题">使用 cookie 时需要考虑的问题&lt;/h3>
&lt;ul>
&lt;li>因为存储在客户端，容易被客户端篡改，使用前需要验证合法性&lt;/li>
&lt;li>不要存储敏感数据，比如用户密码，账户余额&lt;/li>
&lt;li>使用 httpOnly 在一定程度上提高安全性&lt;/li>
&lt;li>尽量减少 cookie 的体积，能存储的数据量不能超过 4kb&lt;/li>
&lt;li>设置正确的 domain 和 path，减少数据传输&lt;/li>
&lt;li>&lt;strong>cookie 无法跨域&lt;/strong>&lt;/li>
&lt;li>一个浏览器针对一个网站最多存 20 个 Cookie，浏览器一般只允许存放 300 个 Cookie&lt;/li>
&lt;li>&lt;strong>移动端对 cookie 的支持不是很好，而 session 需要基于 cookie 实现，所以移动端常用的是 token&lt;/strong>&lt;/li>
&lt;/ul>
&lt;h3 id="使用-session-时需要考虑的问题">使用 session 时需要考虑的问题&lt;/h3>
&lt;ul>
&lt;li>将 session 存储在服务器里面，当用户同时在线量比较多时，这些 session 会占据较多的内存，需要在服务端定期的去清理过期的 session&lt;/li>
&lt;li>当网站采用&lt;strong>集群部署&lt;/strong>的时候，会遇到多台 web 服务器之间如何做 session 共享的问题。因为 session 是由单个服务器创建的，但是处理用户请求的服务器不一定是那个创建 session 的服务器，那么该服务器就无法拿到之前已经放入到 session 中的登录凭证之类的信息了。&lt;/li>
&lt;li>当多个应用要共享 session 时，除了以上问题，还会遇到跨域问题，因为不同的应用可能部署的主机不一样，需要在各个应用做好 cookie 跨域的处理。&lt;/li>
&lt;li>&lt;strong>sessionId 是存储在 cookie 中的，假如浏览器禁止 cookie 或不支持 cookie 怎么办？&lt;/strong> 一般会把 sessionId 跟在 url 参数后面即重写 url，所以 session 不一定非得需要靠 cookie 实现&lt;/li>
&lt;li>&lt;strong>移动端对 cookie 的支持不是很好，而 session 需要基于 cookie 实现，所以移动端常用的是 token&lt;/strong>&lt;/li>
&lt;/ul>
&lt;h3 id="使用-token-时需要考虑的问题">使用 token 时需要考虑的问题&lt;/h3>
&lt;ul>
&lt;li>如果你认为用数据库来存储 token 会导致查询时间太长，可以选择放在内存当中。比如 redis 很适合你对 token 查询的需求。&lt;/li>
&lt;li>&lt;strong>token 完全由应用管理，所以它可以避开同源策略&lt;/strong>&lt;/li>
&lt;li>&lt;strong>token 可以避免 CSRF 攻击(因为不需要 cookie 了)&lt;/strong>&lt;/li>
&lt;li>&lt;strong>移动端对 cookie 的支持不是很好，而 session 需要基于 cookie 实现，所以移动端常用的是 token&lt;/strong>&lt;/li>
&lt;/ul>
&lt;h3 id="使用-jwt-时需要考虑的问题">使用 JWT 时需要考虑的问题&lt;/h3>
&lt;ul>
&lt;li>因为 JWT 并不依赖 Cookie 的，所以你可以使用任何域名提供你的 API 服务而不需要担心跨域资源共享问题（CORS）&lt;/li>
&lt;li>JWT 默认是不加密，但也是可以加密的。生成原始 Token 以后，可以用密钥再加密一次。&lt;/li>
&lt;li>JWT 不加密的情况下，不能将秘密数据写入 JWT。&lt;/li>
&lt;li>JWT 不仅可以用于认证，也可以用于交换信息。有效使用 JWT，可以降低服务器查询数据库的次数。&lt;/li>
&lt;li>JWT 最大的优势是服务器不再需要存储 Session，使得服务器认证鉴权业务可以方便扩展。但这也是 JWT 最大的缺点：由于服务器不需要存储 Session 状态，因此使用过程中无法废弃某个 Token 或者更改 Token 的权限。也就是说一旦 JWT 签发了，到期之前就会始终有效，除非服务器部署额外的逻辑。&lt;/li>
&lt;li>JWT 本身包含了认证信息，一旦泄露，任何人都可以获得该令牌的所有权限。为了减少盗用，JWT 的有效期应该设置得比较短。对于一些比较重要的权限，使用时应该再次对用户进行认证。&lt;/li>
&lt;li>JWT 适合一次性的命令认证，颁发一个有效期极短的 JWT，即使暴露了危险也很小，由于每次操作都会生成新的 JWT，因此也没必要保存 JWT，真正实现无状态。&lt;/li>
&lt;li>为了减少盗用，JWT 不应该使用 HTTP 协议明码传输，要使用 HTTPS 协议传输。&lt;/li>
&lt;/ul>
&lt;h3 id="使用加密算法时需要考虑的问题">使用加密算法时需要考虑的问题&lt;/h3>
&lt;ul>
&lt;li>绝不要以&lt;strong>明文存储&lt;/strong>密码&lt;/li>
&lt;li>&lt;strong>永远使用 哈希算法 来处理密码，绝不要使用 Base64 或其他编码方式来存储密码，这和以明文存储密码是一样的，使用哈希，而不要使用编码&lt;/strong>。编码以及加密，都是双向的过程，而密码是保密的，应该只被它的所有者知道， 这个过程必须是单向的。哈希正是用于做这个的，从来没有解哈希这种说法， 但是编码就存在解码，加密就存在解密。&lt;/li>
&lt;li>绝不要使用弱哈希或已被破解的哈希算法，像 MD5 或 SHA1 ，只使用强密码哈希算法。&lt;/li>
&lt;li>绝不要以明文形式显示或发送密码，即使是对密码的所有者也应该这样。如果你需要 “忘记密码” 的功能，可以随机生成一个新的 &lt;strong>一次性的&lt;/strong>（这点很重要）密码，然后把这个密码发送给用户。&lt;/li>
&lt;/ul>
&lt;h3 id="分布式架构下-session-共享方案">分布式架构下 session 共享方案&lt;/h3>
&lt;h4 id="1-session-复制">1. session 复制&lt;/h4>
&lt;ul>
&lt;li>任何一个服务器上的 session 发生改变（增删改），该节点会把这个 session 的所有内容序列化，然后广播给所有其它节点，不管其他服务器需不需要 session ，以此来保证 session 同步&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>优点：&lt;/strong> 可容错，各个服务器间 session 能够实时响应。
&lt;strong>缺点：&lt;/strong> 会对网络负荷造成一定压力，如果 session 量大的话可能会造成网络堵塞，拖慢服务器性能。&lt;/p>
&lt;h4 id="2-粘性-session-ip-绑定策略">2. 粘性 session /IP 绑定策略&lt;/h4>
&lt;ul>
&lt;li>&lt;strong>采用 Ngnix 中的 ip_hash 机制，将某个 ip 的所有请求都定向到同一台服务器上，即将用户与服务器绑定。&lt;/strong> 用户第一次请求时，负载均衡器将用户的请求转发到了 A 服务器上，如果负载均衡器设置了粘性 session 的话，那么用户以后的每次请求都会转发到 A 服务器上，相当于把用户和 A 服务器粘到了一块，这就是粘性 session 机制。&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>优点：&lt;/strong> 简单，不需要对 session 做任何处理。
&lt;strong>缺点：&lt;/strong> 缺乏容错性，如果当前访问的服务器发生故障，用户被转移到第二个服务器上时，他的 session 信息都将失效。
&lt;strong>适用场景：&lt;/strong> 发生故障对客户产生的影响较小；服务器发生故障是低概率事件 。
&lt;strong>实现方式：&lt;/strong> 以 Nginx 为例，在 upstream 模块配置 ip_hash 属性即可实现粘性 session。&lt;/p>
&lt;h4 id="3-session-共享常用">3. session 共享（常用）&lt;/h4>
&lt;ul>
&lt;li>使用分布式缓存方案比如 Memcached 、Redis 来缓存 session，但是要求 Memcached 或 Redis 必须是集群&lt;/li>
&lt;li>把 session 放到 Redis 中存储，虽然架构上变得复杂，并且需要多访问一次 Redis ，但是这种方案带来的好处也是很大的：
&lt;ul>
&lt;li>实现了 session 共享；&lt;/li>
&lt;li>可以水平扩展（增加 Redis 服务器）；&lt;/li>
&lt;li>服务器重启 session 不丢失（不过也要注意 session 在 Redis 中的刷新/失效机制）；&lt;/li>
&lt;li>不仅可以跨服务器 session 共享，甚至可以跨平台（例如网页端和 APP 端）&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/rv7ih5/1623681275027-55a77f32-68e2-4a4e-9636-10ddd23989f8.webp" alt="">&lt;/p>
&lt;h4 id="4-session-持久化">4. session 持久化&lt;/h4>
&lt;ul>
&lt;li>将 session 存储到数据库中，保证 session 的持久化&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>优点：&lt;/strong> 服务器出现问题，session 不会丢失
&lt;strong>缺点：&lt;/strong> 如果网站的访问量很大，把 session 存储到数据库中，会对数据库造成很大压力，还需要增加额外的开销维护数据库。&lt;/p>
&lt;h3 id="只要关闭浏览器-session-真的就消失了">&lt;strong>只要关闭浏览器 ，session 真的就消失了？&lt;/strong>&lt;/h3>
&lt;p>不对。对 session 来说，除非程序通知服务器删除一个 session，否则服务器会一直保留，程序一般都是在用户做 log off 的时候发个指令去删除 session。
然而浏览器从来不会主动在关闭之前通知服务器它将要关闭，因此服务器根本不会有机会知道浏览器已经关闭，之所以会有这种错觉，是大部分 session 机制都使用会话 cookie 来保存 session id，而关闭浏览器后这个 session id 就消失了，再次连接服务器时也就无法找到原来的 session。如果服务器设置的 cookie 被保存在硬盘上，或者使用某种手段改写浏览器发出的 HTTP 请求头，把原来的 session id 发送给服务器，则再次打开浏览器仍然能够打开原来的 session。
恰恰是&lt;strong>由于关闭浏览器不会导致 session 被删除，迫使服务器为 session 设置了一个失效时间，当距离客户端上一次使用 session 的时间超过这个失效时间时，服务器就认为客户端已经停止了活动，才会把 session 删除以节省存储空间。&lt;/strong>&lt;/p>
&lt;h2 id="项目地址">项目地址&lt;/h2>
&lt;p>&lt;a href="https://github.com/yjdjiayou/jwt-demo">&lt;strong>在项目中使用 JWT&lt;/strong>&lt;/a>&lt;/p>
&lt;h2 id="后语">后语&lt;/h2>
&lt;ul>
&lt;li>本文只是基于自己的理解讲了理论知识，因为对后端/算法知识不是很熟，如有谬误，还请告知，万分感谢&lt;/li>
&lt;li>如果本文对你有所帮助，还请点个赞~~&lt;/li>
&lt;/ul>
&lt;h2 id="参考">参考&lt;/h2>
&lt;p>&lt;a href="https://baike.baidu.com/item/cookie/1119?fr=aladdin">&lt;strong>百度百科-cookie&lt;/strong>&lt;/a>
&lt;a href="https://baike.baidu.com/item/session/479100?fr=aladdin#3">&lt;strong>百度百科-session&lt;/strong>&lt;/a>
&lt;a href="https://juejin.im/post/6844903864810864647">&lt;strong>详解 Cookie，Session，Token&lt;/strong>&lt;/a>
&lt;a href="https://juejin.im/post/6844904009061367821#heading-0">&lt;strong>一文彻底搞懂 Cookie、Session、Token 到底是什么&lt;/strong>&lt;/a>
&lt;strong>&lt;a href="https://www.cnblogs.com/lyzg/p/6067766.html">3 种 web 会话管理的方式&lt;/a>！！！&lt;/strong>
&lt;strong>&lt;a href="https://www.cnblogs.com/JamesWang1993/p/8593494.html">Token ，Cookie 和 Session 的区别&lt;/a>！！！&lt;/strong>
&lt;strong>&lt;a href="https://www.cnblogs.com/moyand/p/9047978.html">彻底理解 cookie、session、token&lt;/a>！！！&lt;/strong>
&lt;a href="https://juejin.im/post/6844903781704941576">&lt;strong>前端鉴权&lt;/strong>&lt;/a>
&lt;a href="https://zh.wikipedia.org/wiki/SHA-1">&lt;strong>SHA-1&lt;/strong>&lt;/a>
&lt;a href="https://zh.wikipedia.org/wiki/SHA-2">&lt;strong>SHA-2&lt;/strong>&lt;/a>
&lt;a href="https://zh.wikipedia.org/wiki/SHA-3">&lt;strong>SHA-3&lt;/strong>&lt;/a>
&lt;a href="https://blog.csdn.net/zhezhebie/article/details/71631077">&lt;strong>不要再使用 MD5 和 SHA1 加密密码了！&lt;/strong>&lt;/a>
&lt;a href="https://www.liaoxuefeng.com/wiki/1022910821149312/1023025778520640">&lt;strong>廖雪峰 Node 教程之 crypto&lt;/strong>&lt;/a>&lt;/p>
&lt;h2 id="推荐阅读">推荐阅读&lt;/h2>
&lt;p>&lt;a href="https://juejin.im/post/6844904021233238024">&lt;strong>你真的了解 React 生命周期吗&lt;/strong>&lt;/a>
&lt;strong>&lt;a href="https://juejin.im/post/6844903985338400782">React Hooks 详解 【近 1W 字】+ 项目实战&lt;/a>&lt;/strong>
&lt;strong>&lt;a href="https://juejin.im/post/6844904017487724557">React SSR 详解【近 1W 字】+ 2 个项目实战&lt;/a>&lt;/strong>
&lt;strong>&lt;a href="https://juejin.im/post/6844903966849892359">从 0 到 1 实现一款简易版 Webpack&lt;/a>&lt;/strong>&lt;/p></description></item><item><title>Docs: HTTP 的实现</title><link>https://desistdaydream.github.io/docs/IT%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/4.%E6%95%B0%E6%8D%AE%E9%80%9A%E4%BF%A1/%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/7.HTTP/HTTP-%E7%9A%84%E5%AE%9E%E7%8E%B0/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/IT%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/4.%E6%95%B0%E6%8D%AE%E9%80%9A%E4%BF%A1/%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/7.HTTP/HTTP-%E7%9A%84%E5%AE%9E%E7%8E%B0/</guid><description>
&lt;p>HTTP 服务器的程序(想提供 web 服务必须要安装一下程序中的一个)&lt;/p>
&lt;ul>
&lt;li>httpd(apache)&lt;/li>
&lt;li>nginx&lt;/li>
&lt;li>lighttpd&lt;/li>
&lt;li>应用程序服务器：上面的程序如果不附加插件则只支持静态的网页，装上下面的程序还能解析 PHP 等动态界面
&lt;ul>
&lt;li>IIS&lt;/li>
&lt;li>tomcat，jetty，就 boss，resin&lt;/li>
&lt;li>webshpere,weblogic,oc4j&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h1 id="httpd">httpd&lt;/h1>
&lt;p>apache(a patchy server)的特性&lt;/p>
&lt;ul>
&lt;li>高度模块化：core+modules&lt;/li>
&lt;li>DSO：Dynamic Shared Object&lt;/li>
&lt;li>MPM：Multipath Processing Modules 多路处理模块，不同的工作方式，可以切换，使用不同模块可以满足不同需求
&lt;ul>
&lt;li>prefork：多进程模型，每个进程响应一个请求
&lt;ul>
&lt;li>一个主进程：负责生成 n 个子近侧很难过，子进程也成为工作进程，每个子进程处理一个用户请求，即便没有用户请求，也会预先生成多个空闲进程，随时等待请求到达，最大不超过 1024 个&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>worker：多线程模型
&lt;ul>
&lt;li>一个主进程：负责生成子进程；负责创建套接字；负责接收请求，并将其派发给某子进程进行处理；&lt;/li>
&lt;li>多个子进程：每个子进程负责生成多个线程；&lt;/li>
&lt;li>每个线程：负责响应用户请求；&lt;/li>
&lt;li>并发响应数量：m*n&lt;/li>
&lt;li>m：子进程数量&lt;/li>
&lt;li>n：每个子进程所能创建的最大线程数量；&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>event：事件驱动模型，多进程模型，每个进程响应多个请求（老版本系统不支持，systemd 系统支持）
&lt;ul>
&lt;li>一个主进程 ：负责生成子进程；负责创建套接字；负责接收请求，并将其派发给某子进程进行处理；&lt;/li>
&lt;li>子进程：基于事件驱动机制直接响应多个请求；&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h2 id="httpd-配置">Httpd 配置&lt;/h2>
&lt;p>程序环境(.init 系统下)&lt;/p>
&lt;ul>
&lt;li>配置文件
&lt;ul>
&lt;li>/etc/httpd/conf/httpd.conf&lt;/li>
&lt;li>/etc/httpd/conf.d/*.conf&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>服务脚本
&lt;ul>
&lt;li>/etc/rc.d/init.d/httpd&lt;/li>
&lt;li>配置文件/etc/sysconfig/httpd&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>主程序文件
&lt;ul>
&lt;li>/usr/sbin/httpd&lt;/li>
&lt;li>/usr/sbin/httpd.event&lt;/li>
&lt;li>/usr/sbin/httpd.worker&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>日志文件目录
&lt;ul>
&lt;li>/var/log/httpd
&lt;ul>
&lt;li>access_log:访问日志&lt;/li>
&lt;li>error_log:错误日志&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>站点文档目录
&lt;ul>
&lt;li>/var/www/html&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul></description></item><item><title>Docs: HTTP 管理</title><link>https://desistdaydream.github.io/docs/IT%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/4.%E6%95%B0%E6%8D%AE%E9%80%9A%E4%BF%A1/%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/7.HTTP/HTTP-%E7%AE%A1%E7%90%86/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/IT%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/4.%E6%95%B0%E6%8D%AE%E9%80%9A%E4%BF%A1/%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/7.HTTP/HTTP-%E7%AE%A1%E7%90%86/</guid><description/></item><item><title>Docs: HTTP 管理</title><link>https://desistdaydream.github.io/docs/IT%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/4.%E6%95%B0%E6%8D%AE%E9%80%9A%E4%BF%A1/%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/7.HTTP/HTTP-%E7%AE%A1%E7%90%86/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/IT%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/4.%E6%95%B0%E6%8D%AE%E9%80%9A%E4%BF%A1/%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/7.HTTP/HTTP-%E7%AE%A1%E7%90%86/</guid><description/></item><item><title>Docs: HTTP 缓存</title><link>https://desistdaydream.github.io/docs/IT%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/4.%E6%95%B0%E6%8D%AE%E9%80%9A%E4%BF%A1/%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/7.HTTP/HTTP-%E7%BC%93%E5%AD%98/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/IT%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/4.%E6%95%B0%E6%8D%AE%E9%80%9A%E4%BF%A1/%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/7.HTTP/HTTP-%E7%BC%93%E5%AD%98/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://mp.weixin.qq.com/s/bUy220-ect00N4gnO0697A">公众号-小林 coding，硬核！30 张图解 HTTP 常见的面试题&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://mp.weixin.qq.com/s/fvvnQ3xI1nz-Ri3vBfG2lw">公众号-小林 coding，告别 HTTP&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;h3 id="http-缓存有哪些实现方式">HTTP 缓存有哪些实现方式？&lt;/h3>
&lt;p>对于一些具有重复性的 HTTP 请求，比如每次请求得到的数据都一样的，我们可以把这对「请求-响应」的数据都&lt;strong>缓存在本地&lt;/strong>，那么下次就直接读取本地的数据，不必在通过网络获取服务器的响应了，这样的话 HTTP/1.1 的性能肯定肉眼可见的提升。&lt;/p>
&lt;p>所以，避免发送 HTTP 请求的方法就是通过&lt;strong>缓存技术&lt;/strong>，HTTP 设计者早在之前就考虑到了这点，因此 HTTP 协议的头部有不少是针对缓存的字段。&lt;/p>
&lt;p>HTTP 缓存有两种实现方式，分别是&lt;strong>强制缓存和协商缓存&lt;/strong>。&lt;/p>
&lt;h3 id="什么是强制缓存">什么是强制缓存？&lt;/h3>
&lt;p>强缓存指的是只要浏览器判断缓存没有过期，则直接使用浏览器的本地缓存，决定是否使用缓存的主动性在于浏览器这边。&lt;/p>
&lt;p>如下图中，返回的是 200 状态码，但在 size 项中标识的是 from disk cache，就是使用了强制缓存。&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/884948f1-0dd2-48b3-8dd0-41b261df0633/1649668520864-47bf15a0-854c-4725-ae4f-45751f99cf0f.png" alt="">&lt;/p>
&lt;p>强缓存是利用下面这两个 HTTP 响应头部（Response Header）字段实现的，它们都用来表示资源在客户端缓存的有效期：&lt;/p>
&lt;ul>
&lt;li>&lt;code>Cache-Control&lt;/code>， 是一个相对时间；&lt;/li>
&lt;li>&lt;code>Expires&lt;/code>，是一个绝对时间；&lt;/li>
&lt;/ul>
&lt;p>如果 HTTP 响应头部同时有 Cache-Control 和 Expires 字段的话，&lt;strong>Cache-Control 的优先级高于 Expires&lt;/strong> 。&lt;/p>
&lt;p>Cache-control 选项更多一些，设置更加精细，所以建议使用 Cache-Control 来实现强缓存。具体的实现流程如下：&lt;/p>
&lt;ul>
&lt;li>当浏览器第一次请求访问服务器资源时，服务器会在返回这个资源的同时，在 Response 头部加上 Cache-Control，Cache-Control 中设置了过期时间大小；&lt;/li>
&lt;li>浏览器再次请求访问服务器中的该资源时，会先&lt;strong>通过请求资源的时间与 Cache-Control 中设置的过期时间大小，来计算出该资源是否过期&lt;/strong>，如果没有，则使用该缓存，否则重新请求服务器；&lt;/li>
&lt;li>服务器再次收到请求后，会再次更新 Response 头部的 Cache-Control。&lt;/li>
&lt;/ul>
&lt;h3 id="什么是协商缓存">什么是协商缓存？&lt;/h3>
&lt;p>当我们在浏览器使用开发者工具的时候，你可能会看到过某些请求的响应码是 &lt;code>304&lt;/code>，这个是告诉浏览器可以使用本地缓存的资源，通常这种通过服务端告知客户端是否可以使用缓存的方式被称为协商缓存。&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/884948f1-0dd2-48b3-8dd0-41b261df0633/1649668520944-8c9a8b13-8145-4ffc-9334-3d5eb46c4231.png" alt="">&lt;/p>
&lt;p>上图就是一个协商缓存的过程，所以&lt;strong>协商缓存就是与服务端协商之后，通过协商结果来判断是否使用本地缓存&lt;/strong>。&lt;/p>
&lt;p>协商缓存可以基于两种头部来实现。&lt;/p>
&lt;p>第一种：请求头部中的 &lt;code>If-Modified-Since&lt;/code> 字段与响应头部中的 &lt;code>Last-Modified&lt;/code> 字段实现，这两个字段的意思是：&lt;/p>
&lt;ul>
&lt;li>响应头部中的 &lt;code>Last-Modified&lt;/code>：标示这个响应资源的最后修改时间；&lt;/li>
&lt;li>请求头部中的 &lt;code>If-Modified-Since&lt;/code>：当资源过期了，发现响应头中具有 Last-Modified 声明，则再次发起请求的时候带上 Last-Modified 的时间，服务器收到请求后发现有 If-Modified-Since 则与被请求资源的最后修改时间进行对比（Last-Modified），如果最后修改时间较新（大），说明资源又被改过，则返回最新资源，HTTP 200 OK；如果最后修改时间较旧（小），说明资源无新修改，响应 HTTP 304 走缓存。&lt;/li>
&lt;/ul>
&lt;p>第二种：请求头部中的 &lt;code>If-None-Match&lt;/code> 字段与响应头部中的 &lt;code>ETag&lt;/code> 字段，这两个字段的意思是：&lt;/p>
&lt;ul>
&lt;li>响应头部中 &lt;code>Etag&lt;/code>：唯一标识响应资源；&lt;/li>
&lt;li>请求头部中的 &lt;code>If-None-Match&lt;/code>：当资源过期时，浏览器发现响应头里有 Etag，则再次向服务器发起请求时，会将请求头 If-None-Match 值设置为 Etag 的值。服务器收到请求后进行比对，如果资源没有变化返回 304，如果资源变化了返回 200。&lt;/li>
&lt;/ul>
&lt;p>第一种实现方式是基于时间实现的，第二种实现方式是基于一个唯一标识实现的，相对来说后者可以更加准确地判断文件内容是否被修改，避免由于时间篡改导致的不可靠问题。&lt;/p>
&lt;p>如果 HTTP 响应头部同时有 Etag 和 Last-Modified 字段的时候， Etag 的优先级更高，也就是先会判断 Etag 是否变化了，如果 Etag 没有变化，然后再看  Last-Modified。&lt;/p>
&lt;p>注意，&lt;strong>协商缓存这两个字段都需要配合强制缓存中 Cache-control 字段来使用，只有在未能命中强制缓存的时候，才能发起带有协商缓存字段的请求&lt;/strong>。&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/884948f1-0dd2-48b3-8dd0-41b261df0633/1649668520918-e343317a-4c73-4f3c-b059-fc656dab9631.png" alt="">&lt;/p>
&lt;p>使用 ETag 字段实现的协商缓存的过程如下；&lt;/p>
&lt;ul>
&lt;li>当浏览器第一次请求访问服务器资源时，服务器会在返回这个资源的同时，在 Response 头部加上 ETag 唯一标识，这个唯一标识的值是根据当前请求的资源生成的；&lt;/li>
&lt;li>当浏览器再次请求访问服务器中的该资源时，首先会先检查强制缓存是否过期，如果没有过期，则直接使用本地缓存；如果缓存过期了，会在 Request 头部加上 If-None-Match 字段，该字段的值就是 ETag 唯一标识；&lt;/li>
&lt;li>服务器再次收到请求后，&lt;strong>会根据请求中的 If-None-Match 值与当前请求的资源生成的唯一标识进行比较&lt;/strong>：&lt;/li>
&lt;li>&lt;strong>如果值相等，则返回 304 Not Modified，不会返回资源&lt;/strong>；&lt;/li>
&lt;li>如果不相等，则返回 200 状态码和返回资源，并在 Response 头部加上新的 ETag 唯一标识；&lt;/li>
&lt;li>如果浏览器收到 304 的请求响应状态码，则会从本地缓存中加载资源，否则更新资源。&lt;/li>
&lt;/ul>
&lt;h3 id="httpsmpweixinqqcomsbuy220-ect00n4gno0697a">&lt;a href="https://mp.weixin.qq.com/s/bUy220-ect00N4gnO0697A">&lt;/a>&lt;/h3></description></item><item><title>Docs: HTTP 缓存</title><link>https://desistdaydream.github.io/docs/IT%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/4.%E6%95%B0%E6%8D%AE%E9%80%9A%E4%BF%A1/%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/7.HTTP/HTTP-%E7%BC%93%E5%AD%98/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/IT%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/4.%E6%95%B0%E6%8D%AE%E9%80%9A%E4%BF%A1/%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/7.HTTP/HTTP-%E7%BC%93%E5%AD%98/</guid><description/></item><item><title>Docs: HTTP 相关的协议或规范</title><link>https://desistdaydream.github.io/docs/IT%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/4.%E6%95%B0%E6%8D%AE%E9%80%9A%E4%BF%A1/%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/7.HTTP/HTTP-%E7%9B%B8%E5%85%B3%E7%9A%84%E5%8D%8F%E8%AE%AE%E6%88%96%E8%A7%84%E8%8C%83/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/IT%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/4.%E6%95%B0%E6%8D%AE%E9%80%9A%E4%BF%A1/%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/7.HTTP/HTTP-%E7%9B%B8%E5%85%B3%E7%9A%84%E5%8D%8F%E8%AE%AE%E6%88%96%E8%A7%84%E8%8C%83/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;p>HTTP 无法单独存在，要想让它生效，必须依赖其他的协议或者规范&lt;/p>
&lt;h2 id="uri-与-url">URI 与 URL&lt;/h2>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Uniform_Resource_Identifier">Wiki&lt;/a>,&lt;a href="https://en.wikipedia.org/wiki/Uniform_Resource_Identifier">URI&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Internationalized_Resource_Identifier">Wiki&lt;/a>,&lt;a href="https://en.wikipedia.org/wiki/Internationalized_Resource_Identifier">IRI&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/URL">Wiki,URL&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Clean_URL">Wiki,CleanURL-slug&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Percent-encoding">Wiki,URL encoding&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.rfc-editor.org/rfc/rfc3986.html">RFC 3986,Uniform Resource Identifier(URI): Generic Syntax&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.rfc-editor.org/rfc/rfc1738">RFC 1738,Uniform Resource Locators (URL)&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.ruanyifeng.com/blog/2010/02/url_encoding.html">https://www.ruanyifeng.com/blog/2010/02/url_encoding.html&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>既然 HTTP 的本质是是在两点之间传输超文本，那么这个超文本又该如何表示呢？我们应该如何正确得找到这个超文本呢？所以，人们将超文本描述为 &lt;strong>Resource(资源)&lt;/strong>，互联网上如此之多得资源，就需要一个唯一标识符来标识每一个资源。URI 就是这么一个用来标识资源的规范。
**Uniform Resource Identifier(统一资源标识符，简称 URI) **是 Web 技术使用的唯一标识符。URI 可以用于标识任何东西，包括现实世界中的对象，例如人和地方，概念或信息资源，例如网页和书籍。某些 URI 提供了一种在网络上(在 Internet 上或在另一个专用网络上，例如在计算机文件系统或 Intranet 上)定位和检索信息资源的方法，它们是 &lt;strong>Uniform Resource Locator(统一资源定位符，简称 URL)&lt;/strong>。而其他 URI 仅提供一个唯一名称，而没有找到或检索该资源的信息，这类 URI 被称为 &lt;strong>Uniform Resource Name(统一资源名称，简称 URN)&lt;/strong>。&lt;/p>
&lt;blockquote>
&lt;p>尽管 URI 仍然是常用术语，但定义 URI 的规范已经被 Internationalized Resource Identifiers(国际化资源标识符，简称 IRI) 的规范所取代。IRI 扩展了 URI 的定义，以便 IRI 可以处理诸如 Kanji(汉字) 之类的字符集，而不是仅限于 ASCII。&lt;/p>
&lt;/blockquote>
&lt;p>**Uniform Resource Locator(统一资源定位符，简称 URL) **是 URI 的一种子集。
要强制区分 URL 和 URI/IRI 这两种标准化术语是很难的。实际上，两者都使用同一种算法，因此没必要强行区分二者的区别，而且 URL 这个词也更具有人气。所以没有必要强制区分 URI 与 URL。&lt;/p>
&lt;h3 id="url-syntaxurl-语法">URL Syntax(URL 语法)&lt;/h3>
&lt;p>URL 主要由四个部分组成：协议、主机、端口、路径&lt;/p>
&lt;p>&lt;strong>&lt;code>Scheme:\[//Authority]/Path\[?query]\[#fragment]&lt;/code>&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>&lt;strong>Scheme://&lt;/strong> # URL 方案，即访问协议,指定低层使用的协议(例如：http, https, ftp)&lt;/li>
&lt;li>&lt;strong>Authority&lt;/strong> # 分为三个部分 &lt;code>[UserInfo@]Host[:Port]&lt;/code>&lt;/li>
&lt;li>&lt;strong>UserInfo&lt;/strong> # 认证信息。由于安全原因，现在这个年代，都省略这部分，而通过其他方式传递认证信息。&lt;/li>
&lt;li>&lt;strong>Host:PORT&lt;/strong> # 服务器 IP 地址或者域名:要访问的端口号&lt;/li>
&lt;li>&lt;strong>/PATH&lt;/strong> # 要访问的资源路径。即资源在主机上的存放相对路径。&lt;/li>
&lt;li>&lt;strong>QUERY&lt;/strong> # 其实就是参数。用于给动态网页或接口传递参数，可有多个参数，用“&amp;amp;”符号隔开，每个参数的名和值用“=”符号隔开。&lt;/li>
&lt;li>&lt;strong>Fragment&lt;/strong> # 片段，主要用于浏览器中。当前页面的其中一段的位置，比如一篇小说有 N 个章节在统一页面显示，开头有目录，点击某一个章节会跳到该页面的某一段，该段的开头就是整个页面的片段，类似于一个位置锚定的作用，该字段即实现这个功能&lt;/li>
&lt;/ul>
&lt;h3 id="url-slug">URL slug&lt;/h3>
&lt;p>URL slug 是位于域扩展名之后的 URL 或链接的一部分。&lt;/p>
&lt;ul>
&lt;li>它们可用于网站：
&lt;ul>
&lt;li>&lt;a href="https://www.rebrandly.com/links">www.rebrandly.com/links&lt;/a> # &amp;rsquo;links&amp;rsquo; 是 URL Slug。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>或者它们可以用于您的自定义短链接：
&lt;ul>
&lt;li>rebrandly.rocks/content-curation # &amp;lsquo;content-curation&amp;rsquo; 是 URL slug。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h3 id="url-encodingurl-编码">URL Encoding(URL 编码)&lt;/h3>
&lt;p>通常来说，URL 只能使用英文字母、阿拉伯数字和某些标点符号。那么如果在 URL 中想使用其他字符，比如中文或某些特殊字符怎么办呢？
上述问题就是 URL 编码的由来。在初期，并没有 RFC 规定具体如何进行编码，而是由应用程序自行处理。这就导致 URL 编码称为一个混乱的领域。
在浏览器中，如果输入 &lt;code>http://www.google.com/你好&lt;/code>，则会被编码为 &lt;code>http://www.google.com/%E4%BD%A0%E5%A5%BD&lt;/code>。这里面的规则非常简单：&lt;/p>
&lt;ul>
&lt;li>你好 两个汉子的 UTF-8 编码结果为 E4 BD A0 E5 A5 BD，每个字节前面加上个 &lt;code>%&lt;/code>，就得到了 URL 编码。&lt;/li>
&lt;/ul>
&lt;h3 id="example">EXAMPLE&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span> userinfo host port
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ┌──┴───┐ ┌──────┴──────┐ ┌┴┐
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> https://john.doe@www.example.com:123/forum/questions/?tag&lt;span style="color:#f92672">=&lt;/span>networking&amp;amp;order&lt;span style="color:#f92672">=&lt;/span>newest#top
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> └─┬─┘ └───────────┬──────────────┘└───────┬───────┘ └───────────┬─────────────┘ └┬┘
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> scheme authority path query fragment
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ul>
&lt;li>&lt;code>unix:///run/containerd/containerd.sock&lt;/code> # 这也是 URI 的一种，这就是不同于网络定位符的地方，没有域名之类的东西。Scheme 后面直接接的是 PATH&lt;/li>
&lt;/ul>
&lt;h2 id="tcpip">TCP/IP&lt;/h2>
&lt;p>详见：&lt;a href="https://www.yuque.com/go/doc/33218376">TCP/IP 相关文章&lt;/a>&lt;/p>
&lt;h2 id="dns">DNS&lt;/h2>
&lt;p>详见：&lt;a href="https://www.yuque.com/go/doc/33218346">DNS 相关文章&lt;/a>&lt;/p></description></item><item><title>Docs: HTTP2</title><link>https://desistdaydream.github.io/docs/IT%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/4.%E6%95%B0%E6%8D%AE%E9%80%9A%E4%BF%A1/%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/7.HTTP/HTTP2/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/IT%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/4.%E6%95%B0%E6%8D%AE%E9%80%9A%E4%BF%A1/%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/7.HTTP/HTTP2/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://tools.ietf.org/html/rfc7540">RFC,7540&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://http2.github.io/">官网&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://mp.weixin.qq.com/s/WQpxfwLArltKEjEAdOO2Pw">51 张图助你彻底掌握 HTTP 协议&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://mp.weixin.qq.com/s/a83_NE-ww36FZsy320MQFQ">https://mp.weixin.qq.com/s/a83_NE-ww36FZsy320MQFQ&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>HTTP 2.0 在性能上实现了很大的飞跃，更难得的是它在改进的同时保持了语义的不变，与 HTTP 1.1 的语义完全相同！比如请求方法、URI、状态码、头字段等概念都保留不变，这样就消除了再学习的成本，在我们的日常软件升级中，&lt;strong>向下兼容&lt;/strong>非常重要，也是促进产品大规模使用的一个前提，不然你一升级，各种接口之类的全换了，谁还敢升。 &lt;strong>HTTP 2.0 只在语法上做了重要改进，完全变更了 HTTP 报文的传输格式&lt;/strong>&lt;/p>
&lt;p>在语法上主要实现了以下改造&lt;/p>
&lt;h3 id="1头部压缩">1、头部压缩&lt;/h3>
&lt;p>HTTP 1.1 考虑了 body 的压缩，但没有考虑 header 的压缩, 经常出现传了头部上百，上千字节，但 Body 却只有几十字节的情况，浪费了带宽，而且我们知道从 1.1 开始默认是长连接，几百上千个请求都用的这个连接，而请求的头部很多都是重复的，造成了带宽的极大浪费!想象一下面的这个请求，为了传输区区 「name=michale 」这几个字节，却要传输如此巨量的头部，浪费的带宽确实惊人。&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/ucykv5/1616161148212-dbadab6a-315e-4589-8750-cb9f05553948.png" alt="">&lt;/p>
&lt;p>那么 HTTP 2.0 是如何解决的呢？它开发了专门的 「HPACK」算法，在客户端和服务器两端建立字典，用索引号表示重复的字符串，还采用哈夫曼编码来压缩数字和整数，可以达到最高达 90% 的压缩率&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/ucykv5/1616161148192-45f35344-e164-46ee-aa3c-61a0bba6c732.png" alt="">&lt;/p>
&lt;p>这里简单解释下，头部压缩需要在支持 HTTP 2.0 的客户端和服务器之间：&lt;/p>
&lt;ol>
&lt;li>维护一份静态的字典（Static table），包含常见的头部名称，以及特别常见的头部名称与值的组合。这样的话如果请求响应命中了静态字典，直接发索引号即可&lt;/li>
&lt;li>维护一份相同的动态字典（Dynamic table），可以动态地添加字典，这样的话如果客户端首次请求由于「User-Agent: xxx」,「host:xxx」,「Cookie」这些的动态键值对没有命中静态字典，还是会传给服务器，但服务器收到后会基于传过来的键值对创建动态字典条目，如上图的「User-Agent: xxx」对应数字 62，「host:xxx」对应数字 63，这样双方都创建动态条目后，之后就可以用只传 62，63 这样的索引号来通信了！显而易见，传输数据急遽降低，极大地提升了传输效率！需要注意的是动态字典是每个连接自己维护的，也就是对于每个连接而言，首次都必须发送动态键值对&lt;/li>
&lt;li>支持基于静态哈夫曼码表的哈夫曼编码（Huffman Coding）：对于静态、动态字典中不存在的内容，可以使用哈夫曼编码来减小体积。HTTP/2 使用了一份静态哈夫曼码表（详见），也需要内置在客户端和服务端之中。&lt;/li>
&lt;/ol>
&lt;h3 id="2二进制格式">2、二进制格式&lt;/h3>
&lt;p>HTTP 1.1 是纯文本形式，而 2.0 是完全的二进制形式，它把 TCP 协议的部分特性挪到了应用层，把原来的 Header+Body 消息打散为了数个小版的二进制&amp;quot;帧&amp;quot;（Frame）,“HEADERS”帧存放头数据、“DATA”帧存放实体数据&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/ucykv5/1616161148271-6532e9c1-a86d-4794-ae42-de56f5188c1a.png" alt="">&lt;/p>
&lt;p>这些二进制帧只认 0，1，基于这种考虑 http 2.0 的协议解析决定采用二进制格式，使用二进制的形式虽然对人不友好，但&lt;strong>大大方便了计算机的解析&lt;/strong>，原来使用纯文本容易出现多义性，如大小写，空白字符等，程序在处理时必须用复杂的状态机，&lt;strong>效率低，还麻烦&lt;/strong>。而使用二进制的话可以严格规定字段大小、顺序、标志位等格式，“对就是对，错就是错”，&lt;strong>解析起来没有歧义，实现简单，而且体积小、速度快。&lt;/strong>&lt;/p>
&lt;h3 id="3-流">3. 流&lt;/h3>
&lt;p>HTTP 2 定义了「流」（stream）的的概念，它是二进制帧的双向传输序列，同一个消息往返的数据帧 （header 帧和 data 帧）会分配一个唯一的流 ID，这样我们就能区分每一个请求。在这个虚拟的流里，数据帧按先后次序传输，到达应答方后，将这些数据帧按它们的先后顺序组装起来，最后解析 HTTP 1.1 的请求头和实体。&lt;/p>
&lt;p>在&lt;strong>同一时间&lt;/strong>，请求方可以在流里发请求，应答方也可以也流里发响应，对比 HTTP 1.1 一个连接一次只能处理一次请求-应答，吞吐量大大提升&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/ucykv5/1616161148223-75161729-344f-4bd8-98f5-10f6f23aab4c.png" alt="">&lt;/p>
&lt;p>&lt;strong>如图示，一个连接里多个流可以同时收发请求-应答数据帧，每个流中数据包按序传输组装&lt;/strong>&lt;/p>
&lt;p>所有的流都是在同一个连接中流动的，这也是 HTTP 2.0 经典的&lt;strong>多路复用&lt;/strong>（ Multiplexing），另外由于每个流都是独立的，所以谁先处理好请求，谁就可以先将响应通过连接发送给对方，也就解决了队头阻塞的问题。&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/ucykv5/1616161148167-417e8e93-dbe1-43d6-b4b0-ffdda356eb36.png" alt="">&lt;/p>
&lt;p>&lt;strong>如图示，在 HTTP 2 中，两个请求同时发送，可以同时接收，而在 HTTP 1.1 中必须等上一个请求响应后才能处理下一个请求&lt;/strong>&lt;/p>
&lt;h3 id="http-2-的队头阻塞">HTTP 2 的队头阻塞&lt;/h3>
&lt;p>HTTP 2 引入的流，帧等语法层面的改造确实让其传输效率有了质的飞跃，但是它依然存在着队头阻塞，这是咋回事？&lt;/p>
&lt;p>其实主要是因为 HTTP 2 的分帧主要是在应用层处理的，而分帧最终还是要传给下层的 TCP 层经由它封装后再进行传输，每个连接最终还是顺序传输这些包，
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/ucykv5/1616161148187-3d17b319-06b7-4fb6-98cd-7a3ce63af1d8.png" alt="">
&lt;strong>如图示：流只是我们虚拟出来的概念，最终在连接层面还是顺序传的&lt;/strong>&lt;/p>
&lt;p>TCP 是可靠连接，为了保证这些包能顺序传给对方，会进行丢包重传机制，如果传了三个包，后两个包传成功，但第一个包传失败了，TCP 协议栈会把已收到的包暂存到缓存区中，停下等待第一个包的重传成功，这样的话在网络不佳的情况下只要一个包阻塞了，由于重传机制，后面的包就被阻塞了，上层应用由于拿不到包也只能干瞪眼了。&lt;/p>
&lt;p>由于这是 TCP 协议层面的机制，无法改造，所以 HTTP 2 的队头阻塞是不可避免的。HTTP 3 对此进行了改进，将 TCP 换成了 UDP 来进行传输，由于 UDP 是无序的，不需要断建连，包之间没有依赖关系，所以从根本上解决了“队头阻塞”, 当然由于 UDP 本身的这些特性不足以支撑可靠的通信，所以 Google 在 UDP 的基础上也加了 TCP 的连接管理，拥塞窗口，流量控制等机制，这套协议我们称之为 QUIC 协议。
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/ucykv5/1616161148202-483920df-f46e-43fc-83b2-75c6e80cd747.png" alt="">
可以看到不管是 HTTP 2 还是 3 它们底层都支持用 TLS，保留了 HTTPS 安全的特性，这也可以理解，在互联网发展如此迅猛的今天，各大企业也越来越重视通信安全。&lt;/p></description></item><item><title>Docs: HTTP3</title><link>https://desistdaydream.github.io/docs/IT%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/4.%E6%95%B0%E6%8D%AE%E9%80%9A%E4%BF%A1/%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/7.HTTP/HTTP3/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/IT%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/4.%E6%95%B0%E6%8D%AE%E9%80%9A%E4%BF%A1/%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/7.HTTP/HTTP3/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://mp.weixin.qq.com/s/Fwxfzzu6QdqyiYUI38afIQ"> &amp;gt; &lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;h1 id="quic">QUIC&lt;/h1>
&lt;ul>
&lt;li>原文：&lt;a href="https://mp.weixin.qq.com/s/Fwxfzzu6QdqyiYUI38afIQ">公众号-编程指北，如何用 UDP 实现可靠传输&lt;/a>&lt;/li>
&lt;/ul>
&lt;blockquote>
&lt;p>&lt;strong>自 2015 年以来，QUIC 协议开始在 IETF 进行标准化并被国内外各大厂商相继落地。鉴于 QUIC 具备“0RTT 建联”、“支持连接迁移”等诸多优势，并将成为下一代互联网协议：HTTP3.0 的底层传输协议，蚂蚁集团支付宝客户端团队与接入网关团队于 2018 年下半年开始在移动支付、海外加速等场景落地 QUIC。&lt;/strong>&lt;/p>
&lt;/blockquote>
&lt;p>本文是综述篇，介绍&lt;strong>QUIC&lt;/strong>  在蚂蚁的整体落地情况。&lt;/p>
&lt;p>之所以是综述，是因为 QUIC 协议过于复杂，如果对标已有的协议，QUIC 近似等于 HTTP + TLS +TCP，无法详细的毕其功于一役，因此我们通过综述的方式将落地的重点呈现给读者，主要介绍如下几个部分：&lt;/p>
&lt;ul>
&lt;li>QUIC 背景：简单全面的介绍下 QUIC 相关的背景知识&lt;/li>
&lt;li>方案选型设计：详细介绍蚂蚁的落地方案如何另辟蹊径、优雅的支撑 QUIC 的诸多特性，包括连接迁移等&lt;/li>
&lt;li>落地场景：介绍 QUIC 在蚂蚁的两个落地场景，包括：支付宝客户端链路以及海外加速链路&lt;/li>
&lt;li>几项关键技术：介绍落地 QUIC 过程中核心需要解决的问题，以及我们使用的方案，包括：“支持连接迁移”、“提升 0RTT 比例&amp;quot;， &amp;ldquo;支持 UDP 无损升级”以及“客户端智能选路”  等&lt;/li>
&lt;li>几项关键的技术专利&lt;/li>
&lt;/ul>
&lt;p>本文也是 QUIC 协议介绍的第一篇，后续我们会把更多的落地细节、体验优化手段、性能优化手段、安全与高可用、QUIC 新技术等呈现给大家。&lt;/p>
&lt;p>【注】蚂蚁 QUIC 开发团队包括：支付宝客户端团队的梅男、苍茫、述言，以及接入网关的伯琴、子荃、毅丝。&lt;/p>
&lt;p>&lt;strong>QUIC  背景介绍&lt;/strong>&lt;/p>
&lt;p>鉴于读者的背景可能不同，在开始本文之前，我们先简单介绍下 QUIC 相关的背景知识，如果您对这个协议的更多设计细节感兴趣，可以参见相关 Draft：&lt;a href="https://datatracker.ietf.org/wg/quic/documents/">https://datatracker.ietf.org/wg/quic/documents/&lt;/a>&lt;/p>
&lt;h2 id="一quic-是什么">&lt;strong>一、QUIC 是什么？&lt;/strong>&lt;/h2>
&lt;p>简单来说，QUIC (Quick UDP Internet Connections) 是一种基于 UDP 封装的安全   可靠传输协议，他的目标是取代 TCP 并自包含 TLS 成为标准的安全传输协议。下图是 QUIC 在协议栈中的位置，基于 QUIC 承载的 HTTP 协议进一步被标准化为 HTTP3.0。&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/ed23ba12-a45f-4b3f-a00e-fcf7716c950a/640" alt="">&lt;/p>
&lt;h2 id="二为什么是-quic-">&lt;strong>二、为什么是 QUIC ？&lt;/strong>&lt;/h2>
&lt;p>在 QUIC 出现之前，TCP 承载了 90% 多的互联网流量，似乎也没什么问题，那又为何会出现革命者 QUIC 呢？这主要是因为发展了几十年的 TCP 面临 “协议僵化问题”，表现在几方面：&lt;/p>
&lt;ol>
&lt;li>网络设备支持 TCP 时的僵化，表现在：对于一些防火墙或者 NAT 等设备，如果 TCP 引入了新的特性，比如增加了某些 TCP OPTION 等，可能会被认为是攻击而丢包，导致新特性在老的网络设备上无法工作。&lt;/li>
&lt;li>网络操作系统升级困难导致的 TCP 僵化，一些 TCP 的特性无法快速的被演进。&lt;/li>
&lt;li>除此之外，当应用层协议优化到 TLS1.3、 HTTP2.0 后， 传输层的优化也提上了议程，QUIC 在 TCP 基础上，取其精华去其糟粕具有如下的硬核优势：&lt;/li>
&lt;/ol>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/ed23ba12-a45f-4b3f-a00e-fcf7716c950a/640" alt="">&lt;/p>
&lt;h2 id="三quic-生态圈发展简史">&lt;strong>三、QUIC 生态圈发展简史&lt;/strong>&lt;/h2>
&lt;p>下图是 QUIC 从创建到现在为止的一些比较重要的时间节点，2021 年，QUIC V1 即将成为 RFC，结束百花齐放的态势。&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/ed23ba12-a45f-4b3f-a00e-fcf7716c950a/640" alt="">&lt;/p>
&lt;p>介绍完 QUIC 相关背景，之后我们来介绍蚂蚁的整个落地的内容，这里为了便于阐述，我们用蚂蚁 QUIC 的 一、二、三、四 来进行概括总结，即 “一套落地框架”、“两个落地场景”、“三篇创新专利保护”、“四项关键技术”。&lt;/p>
&lt;p>&lt;strong>一套落地框架&lt;/strong>&lt;/p>
&lt;p>蚂蚁的接入网关是基于多进程的 NGINX 开发的 (内部称为 Spanner，协议卸载的扳手)，而 UDP 在多进程编程模型上存在诸多挑战，典型的像无损升级等。为了设计一套完备的框架，我们在落地前充分考虑了服务端在云上部署上的方便性、扩展性、以及性能问题，设计了如下的落地框架以支撑不同的落地场景：&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/ed23ba12-a45f-4b3f-a00e-fcf7716c950a/640" alt="">&lt;/p>
&lt;p>在这套框架中，包括如下两个组件：&lt;/p>
&lt;ol>
&lt;li>QUIC LB 组件：基于 NGINX 4 层 UDP Stream 模块开发，用来基于 QUIC DCID 中携带的服务端信息进行路由，以支持连接迁移。&lt;/li>
&lt;li>NGINX QUIC 服务器：开发了 NGINX_QUIC_MODULE，每个 Worker 监听两种类型的端口：
（1）BASE PORT ，每个 Worker 使用的相同的端口号，以 Reuseport 的形式监听，并暴露给 QUIC LB，用以接收客户端过来的第一个 RTT 中的数据包，这类包的特点是 DCID 由客户端生成，没有路由信息。
（2）Working PORT，每个 Worker 使用的不同的端口号，是真正的工作端口，用以接收第一个 RTT 之后的 QUIC 包，这类包的特定是 DCID 由服务端的进程生成携带有服务端的信息。&lt;/li>
&lt;/ol>
&lt;p>当前框架支持的能力包括如下：&lt;/p>
&lt;ol>
&lt;li>在不用修改内核的情况下，完全在用户态支持 QUIC 的连接迁移，以及连接迁移时 CID 的 Update&lt;/li>
&lt;li>在不用修改内核的情况下，完全在用户态支持 QUIC 的无损升级以及其他运维问题&lt;/li>
&lt;li>支持真正意义上的 0RTT ，并可提升 0RTT 的比例&lt;/li>
&lt;/ol>
&lt;p>为何能支持上述能力，我们后面会展开叙述&lt;/p>
&lt;p>&lt;strong>两个落地场景&lt;/strong>&lt;/p>
&lt;p>我们由近及远的两个落地场景如下：&lt;/p>
&lt;p>&lt;strong>场景一、支付宝移动端落地&lt;/strong>&lt;/p>
&lt;p>如下为我们落地架构的示意图，支付宝手机客户端通过 QUIC 携带 HTTP 请求，通过 QUIC LB 等四层网关将请求转发到 Spanner （蚂蚁内部基于 NGINX 开发的 7 层网关），在 Spanner 上我们将 QUIC 请求 Proxy 成 TCP 请求，发送给业务网关（RS）。&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/ed23ba12-a45f-4b3f-a00e-fcf7716c950a/640" alt="">&lt;/p>
&lt;p>具体的方案选型如下：&lt;/p>
&lt;ul>
&lt;li>支持的 QUIC 版本是 gQUIC Q46。&lt;/li>
&lt;li>NGINX QUIC MODULE 支持 QUIC 的接入和 PROXY 成 TCP 的能力。&lt;/li>
&lt;li>支持包括移动支付、基金、蚂蚁森林在内的所有的 RPC 请求。&lt;/li>
&lt;li>当前选择 QUIC 链路的方式有两种 ：&lt;/li>
&lt;/ul>
&lt;ol>
&lt;li>Backup 模式，即在 TCP 链路无法使用的情况下，降级到 QUIC 链路。&lt;/li>
&lt;li>Smart 模式，即 TCP 和 QUIC 竞速，在 TCP 表现力弱于 QUIC 的情况下，下次请求主动使用 QUIC 链路。&lt;/li>
&lt;/ol>
&lt;p>在此场景下，通过使用 QUIC 可以获得的红利包括：&lt;/p>
&lt;ol>
&lt;li>在客户端连接发生迁移的时候，可以不断链继续服务&lt;/li>
&lt;li>客户端在首次发起连接时，可以节省 TCP 三次握手的时间&lt;/li>
&lt;li>对于弱网情况，QUIC 的传输控制可以带来传输性能提升&lt;/li>
&lt;/ol>
&lt;p>**场景二、**海外加速落地&lt;/p>
&lt;p>蚂蚁集团从 2018 年开始自研了海外的动态加速平台 AGNA（Ant Global Network Accelerator）以替换第三方厂商的加速服务。AGNA 通过在海外部署接入点：Local Proxy(LP) 以及在国内部署接出点：Remote Proxy （RP）的方式，将用户的海外请求通过 LP 和 RP 的加速链路回源国内。如下图所示，我们将 QUIC 部署在 LP 和 RP 之间的链路。&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/ed23ba12-a45f-4b3f-a00e-fcf7716c950a/640" alt="">&lt;/p>
&lt;p>在海外接入点上(LP)，每一个 TCP 连接都被 Proxy 成 QUIC 上的一个 Stream 进行承载，在国内接出点上(RP), 每一个 QUIC Stream 又被 Proxy 成一个 TCP 连接，LP 和 RP 之间使用 QUIC 长连接。&lt;/p>
&lt;p>在此场景下，通过使用 QUIC 可以获得的红利包括：&lt;/p>
&lt;ol>
&lt;li>通过 QUIC 长连接的上的 Stream 承载 TCP 请求，避免每次的跨海建联。&lt;/li>
&lt;li>对于跨海的网络，QUIC 的传输控制可以带来传输性能提升。&lt;/li>
&lt;/ol>
&lt;p>&lt;strong>三篇关键专利&lt;/strong>&lt;/p>
&lt;p>到目前为止，我们把落地过程中一些创新的技术点通过申请专利进行了保护，并积极在 IETF 进行标准化分享我们的研究成果，包括：&lt;/p>
&lt;h3 id="专利一">&lt;strong>专利一&lt;/strong>&lt;/h3>
&lt;p>我们将落地场景 2 中，通过 QUIC Stream 进行四层代理的手段来进行海外回源的加速方法进行专利保护，提出：“一种基于 QUIC 协议代理的的链路加速方法”，目前此专利已经获得美国专利授权，专利号：CN110213241A。&lt;/p>
&lt;h3 id="专利二">&lt;strong>专利二&lt;/strong>&lt;/h3>
&lt;p>将我们落地框架中的 QUIC LB 组件作为专利进行保护，提出：“一种无状态、一致性、分布式的 QUIC 负载均衡设备”，目前此专利还在受理中。由于通过 QUIC LB 可以很好的支持 QUIC 协议的连接迁移问题，所以目前 IETF QUIC WG 上有关于 QUIC LB 相关的草案，我们目前已经参与到 Draft 的讨论和制定中，后序相关的方案也会继续推广到云上产品。&lt;/p>
&lt;h3 id="专利三">&lt;strong>专利三&lt;/strong>&lt;/h3>
&lt;p>将我们解决的 UDP 的无损升级方法进行专利保护，提出 “一种 QUIC 服务器无损升级方案”，目前此专利还在受理中。由于 UDP 无损升级问题是一个业界难题，当前有些手段需要在用户态进行跳转，性能损失较大，我们的方案可以在我们的落地框架中解决当前问题，关于这个方案的细节我们再后面的关键技术中进行介绍。&lt;/p>
&lt;p>&lt;strong>四项关键技术&lt;/strong>&lt;/p>
&lt;p>在整个的落地中，我们设计的方案围绕解决几个核心问题展开，形成了四项关键技术，分别如下&lt;/p>
&lt;h4 id="技术点-1优雅的支持连接迁移能力">&lt;strong>技术点 1.优雅的支持连接迁移能力&lt;/strong>&lt;/h4>
&lt;h4 id="先说-连接迁移面临的问题-上文有提到quic-有一项比较重要的功能是支持连接迁移这里的连接迁移是指如果客户端在长连接保持的情况下切换网络比如从-4g-切换到-wifi--或者因为-nat-rebinding-导致五元组发生变化quic-依然可以在新的五元组上继续进行连接状态quic-之所以能支持连接迁移一个原因是-quic-底层是基于无连接的-udp另一个重要原因是因为-quic-使用唯一的-cid-来标识一个连接而不是五元组">先说  **连接迁移面临的问题 ，**上文有提到，QUIC 有一项比较重要的功能是支持连接迁移。这里的连接迁移是指：如果客户端在长连接保持的情况下切换网络，比如从 4G 切换到 Wifi , 或者因为 NAT Rebinding 导致五元组发生变化，QUIC 依然可以在新的五元组上继续进行连接状态。QUIC 之所以能支持连接迁移，一个原因是 QUIC 底层是基于无连接的 UDP，另一个重要原因是因为 QUIC 使用唯一的 CID 来标识一个连接，而不是五元组。&lt;/h4>
&lt;p>如下图所示，是 QUIC 支持连接的一个示意图，当客户端出口地址从 A 切换成 B 的时候，因为 CID 保持不变，所以在 QUIC 服务器上，依然可以查询到对应的 Session 状态。&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/ed23ba12-a45f-4b3f-a00e-fcf7716c950a/640" alt="">&lt;/p>
&lt;p>然而，理论很丰满，落地却很艰难，在端到端的落地过程中，因为引入了负载均衡设备，会导致在连接迁移时，所有依赖五元组 Hash 做转发或者关联 Session 的机制失效。以 LVS 为例，连接迁移后， LVS 依靠五元组寻址会导致寻址的服务器存在不一致。即便 LVS 寻址正确，当报文到达服务器时，内核根据五元组关联进程，依然会寻址出错。同时，IETF Draft 要求，连接迁移时 CID 需要更新掉，这就为仅依靠 CID 来转发的计划同样变的不可行。&lt;/p>
&lt;h4 id="再说-我们的解决方法为了解决此问题我们设计了开篇介绍的落地框架这里我们将方案做一些简化和抽象整体思路如下图所示">再说  **我们的解决方法，**为了解决此问题，我们设计了开篇介绍的落地框架，这里我们将方案做一些简化和抽象，整体思路如下图所示：&lt;/h4>
&lt;ol>
&lt;li>在四层负载均衡上，我们设计了 QUIC LoadBalancer 的机制：&lt;/li>
&lt;li>我们在 QUIC 的 CID 中扩展了一些字段（ServerInfo）用来关联 QUIC Server 的 IP 和 Working Port 信息。&lt;/li>
&lt;li>在发生连接迁移的时候，QUIC LoadBalancer 可以依赖 CID 中的 ServerInfo 进行路由，避免依赖五元组关联 Session 导致的问题。&lt;/li>
&lt;li>在 CID 需要 Update 的时候，NewCID 中的 ServerInfo 保留不变，这样就避免在 CID 发生 Update 时，仅依赖 CID Hash 挑选后端导致的寻址不一致问题。&lt;/li>
&lt;li>在 QUIC 服务器多进程工作模式上，我们突破了 NGINX 固有的多 Worker 监听在相同端口上的桎梏，设计了多端口监听的机制，每个 Worker 在工作端口上进行隔离，并将端口的信息携带在对 First Initial Packet 的回包的 CID 中，这样代理的好处是：&lt;/li>
&lt;li>无论是否连接迁移，QUIC LB 都可以根据 ServerInfo，将报文转发到正确的进程。&lt;/li>
&lt;li>而业界普遍的方案是修改内核，将 Reuse port 机制改为 Reuse CID 机制，即内核根据 CID 挑选进程。即便后面可以通过 ebpf 等手段支持，但我们认为这种修改内核的机制对底层过于依赖，不利于方案的大规模部署和运维，尤其在公有云上。&lt;/li>
&lt;li>使用独立端口，也有利于多进程模式下，UDP 无损升级问题的解决，这个我们在技术点 3 中介绍。&lt;/li>
&lt;/ol>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/ed23ba12-a45f-4b3f-a00e-fcf7716c950a/640" alt="">&lt;/p>
&lt;p>&lt;strong>技术点 2.提升  0RTT  握手比例&lt;/strong>&lt;/p>
&lt;h4 id="这里先-介绍-quic-0rtt-原理前文我们介绍过-quic-支持传输层握手和安全加密层握手都在一个-0rtt-内完成tls13-本身就支持加密层握手的-0rtt所以不足为奇而-quic-如何实现传输层握手支持-0rtt-呢我们先看下传输层握手的目的即服务端校验客户端是真正想握手的客户端地址不存在欺骗从而避免伪造源地址攻击在-tcp-中服务端依赖三次握手的最后一个-ack-来校验客户端是真正的客户端即只有真正的客户端才会收到-sever-的-syn_ack-并回复">这里先  &lt;strong>介绍 QUIC 0RTT 原理&lt;/strong>。前文我们介绍过， QUIC 支持传输层握手和安全加密层握手都在一个 0RTT 内完成。TLS1.3 本身就支持加密层握手的 0RTT，所以不足为奇。而 QUIC 如何实现传输层握手支持 0RTT 呢？我们先看下传输层握手的目的，即：服务端校验客户端是真正想握手的客户端，地址不存在欺骗，从而避免伪造源地址攻击。在 TCP 中，服务端依赖三次握手的最后一个 ACK 来校验客户端是真正的客户端，即只有真正的客户端才会收到 Sever 的 syn_ack 并回复。&lt;/h4>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/ed23ba12-a45f-4b3f-a00e-fcf7716c950a/640" alt="">&lt;/p>
&lt;p>QUIC 同样需要对握手的源地址做校验，否则便会存在 UDP 本身的 DDOS 问题，那 QUIC 是如何实现的？依赖 STK(Source Address Token) 机制。这里我们先声明下，跟 TLS 类似，QUIC 的 0RTT 握手，是建立在已经同一个服务器建立过连接的基础上，所以如果是纯的第一次连接，仍然需要一个 RTT 来获取这个 STK。如下图所示，我们介绍下这个原理：&lt;/p>
&lt;ol>
&lt;li>类似于 Session Ticket 原理，Server 会将客户端的地址和当前的 Timestamp 通过自己的 KEY 加密生成 STK。&lt;/li>
&lt;li>Client 下次握手的时候，将 STK 携带过来，由于 STK 无法篡改，所以 Server 通过自己的 KEY 解密，如果解出来的地址和客户端此次握手的地址一致，且时间在有效期内，则表示客户端可信，便可以建立连接。&lt;/li>
&lt;li>由于客户端第一次握手的时候，没有这个 STK，所以服务度会回复 REJ 这次握手的信息，并携带 STK。&lt;/li>
&lt;/ol>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/ed23ba12-a45f-4b3f-a00e-fcf7716c950a/640" alt="">&lt;/p>
&lt;p>理论上说，只要客户端缓存了这个 STK，下次握手的时候带过来，服务端便可以直接校验通过，即实现传输层的 0RTT。但是真实的场景却存在&lt;strong>如下两个问题&lt;/strong>：&lt;/p>
&lt;ol>
&lt;li>因为 STK 是服务端加密的，所以如果下次这个客户端路由到别的服务器上了，则这个服务器也需要可以识别出来。&lt;/li>
&lt;li>STK 中 encode 的是上一次客户端的地址，如果下一次客户端携带的地址发生了变化，则同样会导致校验失败。此现象在移动端发生的概率非常大，尤其是 IPV6 场景下，客户端的出口地址会经常发生变化。&lt;/li>
&lt;/ol>
&lt;h4 id="再介绍下我们的解决方法-第一个问题比较好解我们只要保证集群内的机器生成-stk-的秘钥一致即可第二个问题我们的解题思路是">再介绍下&lt;strong>我们的解决方法。&lt;/strong> 第一个问题比较好解，我们只要保证集群内的机器生成 STK 的秘钥一致即可。&lt;strong>第二个问题，我们的解题思路是&lt;/strong>：&lt;/h4>
&lt;ol>
&lt;li>我们在 STK 中扩展了一个 Client ID, 这个 Clinet ID 是客户端通过无线保镖黑盒生成并全局唯一不变的，类似于一个设备的 SIMID，客户端通过加密的 Trasnport Parameter 传递给服务端，服务端在 STK 中包含这个 ID。&lt;/li>
&lt;li>如果因为 Client IP 发生变化导致校验 STK 校验失败，便会去校验 Client ID，因为 ID 对于一个 Client 是永远不变的，所以可以校验成功，当然前提是，这个客户端是真实的。为了防止 Client ID 的泄露等，我们会选择性对 Client ID 校验能力做限流保护。&lt;/li>
&lt;/ol>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/ed23ba12-a45f-4b3f-a00e-fcf7716c950a/640" alt="">&lt;/p>
&lt;h4 id="技术点-3-支持-quic-无损升级">&lt;strong>技术点 3. 支持 QUIC 无损升级&lt;/strong>&lt;/h4>
&lt;h4 id="我们知道-udp-无损升级是业界难题-无损升级是指在-reload-或者更新二进制时老的进程可以处理完存量连接上的数据后优雅退出以-nginx-为例这里先介绍下-tcp-是如何处理无损升级的主要是如下的两个步骤">我们知道  &lt;strong>UDP 无损升级是业界难题。&lt;/strong> 无损升级是指在 reload 或者更新二进制时，老的进程可以处理完存量连接上的数据后优雅退出。以 NGINX 为例，这里先介绍下 TCP 是如何处理无损升级的，主要是如下的两个步骤：&lt;/h4>
&lt;ol>
&lt;li>老进程先关闭 listening socket，待存量连接请求都结束后，再关闭连接套接字&lt;/li>
&lt;li>新进程从老进程继承 listening socket , 开始 accept 新的请求&lt;/li>
&lt;/ol>
&lt;p>而 UDP 无法做到无损升级是因为 UDP 只有一个 listening socket 没有类似 TCP 的连接套接字，所有的收发数据包都在这个 socket 上，导致下面的热升级步骤会存在问题：&lt;/p>
&lt;ol>
&lt;li>在热升级的时候，old process fork 出 new process 后，new process 会继承 listening socket 并开始 recv msg。&lt;/li>
&lt;li>而 old process 此时如果关闭 listenging socket， 则在途的数据包便无法接收，达不到优雅退出的目的。&lt;/li>
&lt;li>而如果继续监听，则新老进程都会同时收取新连接上的报文，导致老进程无法退出。&lt;/li>
&lt;/ol>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/ed23ba12-a45f-4b3f-a00e-fcf7716c950a/640" alt="">&lt;/p>
&lt;h4 id="这里介绍下相关的解决方法-针对此问题业界有一些方法比如在数据包中携带进程号当数据包收发错乱后在新老进程之间做一次转发考虑到接入层上的性能等原因我们不希望数据再做一次跳转结合我们的落地架构我们设计了如下的-基于多端口轮转的无损升级方案简单来说我们让新老进程监听在不同的端口组并携带在-cid-中这样-quic-lb-就可以根据端口转发到新老进程为了便于运维我们采用端口轮转的方式新老进程会在-reload-n-次之后重新开始之前选中的端口如下图所示">这里介绍下&lt;strong>相关的解决方法。&lt;/strong> 针对此问题，业界有一些方法，比如：在数据包中携带进程号，当数据包收发错乱后，在新老进程之间做一次转发。考虑到接入层上的性能等原因，我们不希望数据再做一次跳转。结合我们的落地架构，我们设计了如下的  &lt;strong>基于多端口轮转的无损升级方案&lt;/strong>，简单来说，我们让新老进程监听在不同的端口组并携带在 CID 中，这样 QUIC LB 就可以根据端口转发到新老进程。为了便于运维，我们采用端口轮转的方式，新老进程会在 reload N 次之后，重新开始之前选中的端口。如下图所示：&lt;/h4>
&lt;ol>
&lt;li>无损升级期间，老进程的 Baseport 端口关闭，这样不会再接受 first intial packet, 类似于关闭了 tcp 的 listening socket。&lt;/li>
&lt;li>老进程的工作端口，继续工作，用来接收当前进程上残余的流量。&lt;/li>
&lt;li>新进程的 Baseport 开始工作，用来接收 first initial packet, 开启新的连接，类似于开启了 tcp 的 listening socket。&lt;/li>
&lt;li>新进程的 working port = (I + 1) mod N,  N 是指同时支持新老进程的状态的次数，例如 N = 4， 表示可以同时 reload 四次，四种 Old, New1, New2, New3 四种状态同时并存，I 是上一个进程工作的端口号，这里 + 1 是因为只有一个 worker, 如果 worker 数有 M 个，则加 M。&lt;/li>
&lt;li>建好的连接便被 Load Balancer 转移到新进程的监听端口的 Working Port 上。&lt;/li>
&lt;/ol>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/ed23ba12-a45f-4b3f-a00e-fcf7716c950a/640" alt="">&lt;/p>
&lt;p>&lt;strong>技术点 4.客户端智能选路&lt;/strong>&lt;/p>
&lt;p>尽管落地 QUIC 的愿望是好的，但是新事物的发展并不是一帆风顺的。由于 QUIC 是基于 UDP 的，而 UDP 相比于 TCP 在运营商的支持上并非友好，表现在：&lt;/p>
&lt;ol>
&lt;li>在带宽紧张的时候，UDP 会经常被限流。&lt;/li>
&lt;li>一些防火墙对于 UDP 包会直接 Drop。&lt;/li>
&lt;li>NAT 网关针对 UDP 的 Session 存活时间也较短。&lt;/li>
&lt;/ol>
&lt;p>同时，根据观察发现，不同的手机厂商对于 UDP 的支持能力也不同，所以在落地过程中，如果盲目的将所有流量完全切为 QUIC 可能会导致一些难以预料的结果。为此，我们在客户端上，设计了开篇介绍的 TCP 和 QUIC 相互 Backup 的链路，如下图所示，我们实时探测 TCP 链路和 QUIC 链路的 RTT、丢包率、请求完成时间、错误率等指标情况，并根据一定的量化方法对两种链路进行打分，根据评分高低，决定选择走哪种链路，从而避免寻址只走一条链路导致的问题。&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/ed23ba12-a45f-4b3f-a00e-fcf7716c950a/640" alt="">&lt;/p>
&lt;p>&lt;strong>做个总结&lt;/strong>&lt;/p>
&lt;p>本文主要综述性的介绍了 QUIC 在蚂蚁的落地方案、场景以及一些关键技术。&lt;strong>关键技术上&lt;/strong>，主要介绍了我们如何通过创造性的提出 QUIC LB 组件、以及多端口监听的机制来优雅的支持  QUIC 的连接迁移机制、QUIC 服务端的无损升级等，依赖这套方案我们的接入网关不需要像业界一样依赖底层内核的改动，这极大的方便了我们方案的部署，尤其在公有云场景下。除了连接迁移以外，我们还提出了 0RTT 建联提升方案、客户端智能选路方案，以最大化 QUIC 在移动端上的收益。截止当前，QUIC 已经在支付宝移动端以及全球加速链路&lt;strong>两个场景&lt;/strong>上平稳运行，并带来了较好的业务收益。&lt;/p>
&lt;p>&lt;strong>未来规划&lt;/strong>&lt;/p>
&lt;p>两年来，我们主要以社区的 gQuic 为基础，充分发挥 QUIC 的协议优势，并结合蚂蚁的业务特征以最大化移动端收益为目标，创造性的提出了一些解决方案，并积极向社区和 IETF 进行推广。在未来，随着蚂蚁在更多业务上的开展和探索以及 HTTP3.0/QUIC 即将成为标准，我们会主要围绕以下几个方向继续深挖 QUIC 的价值：&lt;/p>
&lt;ol>
&lt;li>我们将利用 QUIC 在应用层实现的优势，设计一套统一的具备自适应业务类型和网络类型的 QUIC 传输控制框架，对不同类型的业务和网络类型，做传输上的调优，以优化业务的网络传输体验。&lt;/li>
&lt;li>将 gQUIC 切换成 IETF QUIC，推进标准的 HTTP3.0 在蚂蚁的进一步落地。&lt;/li>
&lt;li>将蚂蚁的 QUIC LB 技术点向 IETF QUIC LB 进行推进，并最终演变为标准的 QUIC LB。&lt;/li>
&lt;li>探索并落地 MPQUIC（多路径 QUIC）  技术，最大化在移动端的收益。&lt;/li>
&lt;li>继续 QUIC 的性能优化工作，使用 UDP GSO， eBPF，io_uring 等内核技术。&lt;/li>
&lt;li>探索 QUIC 在内网承载东西向流量的机会。&lt;/li>
&lt;/ol></description></item><item><title>Docs: HTTPS</title><link>https://desistdaydream.github.io/docs/IT%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/4.%E6%95%B0%E6%8D%AE%E9%80%9A%E4%BF%A1/%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/7.HTTP/HTTPS/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/IT%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/4.%E6%95%B0%E6%8D%AE%E9%80%9A%E4%BF%A1/%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/7.HTTP/HTTPS/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;p>**Hyper Text Transfer Protocol over Secure Socket Layer(简称 HTTPS) **是以安全为目标的 HTTP 通道，简单讲是 HTTP 的安全版。即 HTTP 下加入 SSL 层，HTTPS 的安全基础是 SSL，因此加密的详细内容就需要 SSL。 它是一个 URI scheme（抽象标识符体系），句法类同 http:体系。用于安全的 HTTP 数据传输。https://URL 表明它使用了 HTTP，但 HTTPS 存在不同于 HTTP 的默认端口及一个加密/身份验证层（在 HTTP 与 TCP 之间）。这个系统的最初研发由网景公司(Netscape)进行，并内置于其浏览器 Netscape Navigator 中，提供了身份验证与加密通讯方法。现在它被广泛用于万维网上安全敏感的通讯，例如交易支付方面。&lt;/p>
&lt;h2 id="http-和-https-区别">HTTP 和 HTTPS 区别&lt;/h2>
&lt;p>https 本质是 http 与 ssl 结合的协议，并没有绝对意义上的 https 协议。需要到 ca 申请证书，一般免费证书很少，需要交费。&lt;/p>
&lt;p>http 是超文本传输协议，信息是明文传输，https 则是具有安全性的 ssl 加密传输协议 http 和 https 使用的是完全不同的连接方式用的端口也不一样：前者是 80，后者是 443。&lt;/p>
&lt;p>http 的连接很简单，是无状态的 HTTPS 协议是由 SSL+HTTP 协议构建的可进行加密传输、身份认证的网络协议 要比 http 协议安全&lt;/p>
&lt;h2 id="https-解决的问题">HTTPS 解决的问题&lt;/h2>
&lt;p>（1）信任主机的问题。&lt;/p>
&lt;p>采用 https 的 server 必须从 CA 申请一个用于证明服务器用途类型的证书。&lt;/p>
&lt;p>该证书只有用于对应的 server 的时候，客户度才信任次主机。所以目前所有的银行系统网站，关键部分应用都是 https 的。 客户通过信任该证书，从而信任了该主机。其实这样做效率很低，但是银行更侧重安全。 这一点对我们没有任何意义，我们的 server，采用的证书不管自己 issue 还是从公众的地方 issue， 客户端都是自己人，所以我们也就肯定信任该 server。&lt;/p>
&lt;p>（2）通讯过程中的数据的泄密和被窜改。&lt;/p>
&lt;p>1)一般意义上的 https， 就是 server 有一个证书。&lt;/p>
&lt;p>a) 主要目的是保证 server 就是他声称的 server。这个跟第一点一样。&lt;/p>
&lt;p>b) 服务端和客户端之间的所有通讯，都是加密的。&lt;/p>
&lt;p>i、具体讲，是客户端产生一个对称的密钥，通过 server 的证书来交换密钥。 一般意义上的握手过程。&lt;/p>
&lt;p>ii、加下来所有的信息往来就都是加密的。 第三方即使截获，也没有任何意义。因为他没有密钥。 当然窜改也就没有什么意义了。&lt;/p>
&lt;p>2)少许对客户端有要求的情况下，会要求客户端也必须有一个证书。&lt;/p>
&lt;p>a) 这里客户端证书，其实就类似表示个人信息的时候，除了用户名/密码， 还有一个 CA 认证过的身份。 应为个人证书一般来说上别人无法模拟的，所有这样能够更深的确认自己的身份。&lt;/p>
&lt;p>b) 目前少数个人银行的专业版是这种做法，具体证书可能是拿 U 盘作为一个备份的载体。像我用的交通银行的网上银行就是采取的这种方式。 HTTPS 一定是繁琐的。&lt;/p>
&lt;p>a) 本来简单的 http 协议，一个 get 一个 response。由于 https 要还密钥和确认加密算法的需要。单握手就需要 6/7 个往返。&lt;/p>
&lt;p>i、任何应用中，过多的 round trip 肯定影响性能。&lt;/p>
&lt;p>b) 接下来才是具体的 http 协议，每一次响应或者请求， 都要求客户端和服务端对会话的内容做加密/解密。&lt;/p>
&lt;p>i、尽管对称加密/解密效率比较高，可是仍然要消耗过多的 CPU，为此有专门的 SSL 芯片。 如果 CPU 信能比较低的话，肯定会降低性能，从而不能 serve 更多的请求。&lt;/p>
&lt;p>附 SSL 的简介&lt;/p>
&lt;p>SSL 是 Netscape 公司所提出的安全保密协议，在浏览器(如 Internet Explorer、Netscape Navigator)和 Web 服务器(如 Netscape 的 Netscape Enterprise Server、ColdFusion Server 等等)之间构造安全通道来进行数据传输，SSL 运行在 TCP/IP 层之上、应用层之下，为应用程序提供加密数据通道，它采用了 RC4、MD5 以及 RSA 等加密算法，使用 40 位的密钥，适用于商业信息的加密。&lt;/p>
&lt;p>同时，Netscape 公司相应开发了 HTTPS 协议并内置于其浏览器中，HTTPS 实际上就是 SSL over HTTP，它使用默认端口 443，而不是像 HTTP 那样使用端口 80 来和 TCP/IP 进行通信。HTTPS 协议使用 SSL 在发送方把原始数据进行加密，然 后在接受方进行解密，加密和解密需要发送方和接受方通过交换共知的密钥来实现，因此，所传送的数据不容易被网络黑客截获和解密。&lt;/p>
&lt;p>然而，加密和解密过程需要耗费系统大量的开销，严重降低机器的性能，相关测试数据表明使用 HTTPS 协议传输数据的工作效率只有使用 HTTP 协议传输的十分之一。&lt;/p>
&lt;p>假如为了安全保密，将一个网站所有的 Web 应用都启用 SSL 技术来加密，并使用 HTTPS 协议进行传输，那么该网站的性能和效率将会大大降低，而且 没有这个必要，因为一般来说并不是所有数据都要求那么高的安全保密级别，所以，我们只需对那些涉及机密数据的交互处理使用 HTTPS 协议，这样就做到鱼与 熊掌兼得。总之不需要用 https 的地方，就尽量不要用。&lt;/p>
&lt;h1 id="双向认证">双向认证&lt;/h1>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/qygdgr/1660900843557-9912cd1f-2f59-4860-97e3-f9a8640772bf.png" alt="">&lt;/p></description></item><item><title>Docs: HTTPS</title><link>https://desistdaydream.github.io/docs/IT%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/4.%E6%95%B0%E6%8D%AE%E9%80%9A%E4%BF%A1/%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/7.HTTP/HTTPS/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/IT%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/4.%E6%95%B0%E6%8D%AE%E9%80%9A%E4%BF%A1/%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/7.HTTP/HTTPS/</guid><description/></item></channel></rss>