<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>断念梦 – ArgoCD</title><link>https://desistdaydream.github.io/docs/IT%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/10.%E4%BA%91%E5%8E%9F%E7%94%9F/DevOps/ArgoCD/</link><description>Recent content in ArgoCD on 断念梦</description><generator>Hugo -- gohugo.io</generator><atom:link href="https://desistdaydream.github.io/docs/IT%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/10.%E4%BA%91%E5%8E%9F%E7%94%9F/DevOps/ArgoCD/index.xml" rel="self" type="application/rss+xml"/><item><title>Docs: Argo CD</title><link>https://desistdaydream.github.io/docs/IT%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/10.%E4%BA%91%E5%8E%9F%E7%94%9F/DevOps/ArgoCD/Argo-CD/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/IT%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/10.%E4%BA%91%E5%8E%9F%E7%94%9F/DevOps/ArgoCD/Argo-CD/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://github.com/argoproj/argo-cd">GitHub 项目，argoproj/argo-cd&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://mp.weixin.qq.com/s/r1DnnHptOTaS_Gp8tpPWdg">Argo CD 保姆级入门教程&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>在上一篇『👉&lt;a href="http://mp.weixin.qq.com/s?__biz=MzU1MzY4NzQ1OA==&amp;amp;mid=2247509873&amp;amp;idx=1&amp;amp;sn=dd6daee66f39a965e4680ecd91f884d7&amp;amp;chksm=fbede7bccc9a6eaa6ddf5d082ed20a31d1956425eb8129428b2e2701fb216ef331a706f6d008&amp;amp;scene=21#wechat_redirect">GitOps 介绍[1]&lt;/a>』中，我介绍了什么是 GitOps，包括 GitOps 的原则和优势，以及 GitOps 与 DevOps 的区别。本文将介绍用于实施 GitOps 的工具 Argo CD。&lt;/p>
&lt;p>Argo CD 是以 Kubernetes 作为基础设施，遵循声明式 GitOps 理念的持续交付（continuous delivery, CD）工具，支持多种配置管理工具，包括 ksonnet/jsonnet、kustomize 和 Helm 等。它的配置和使用非常简单，并且自带一个简单易用的可视化界面。&lt;/p>
&lt;p>按照官方定义，Argo CD 被实现为一个 Kubernetes 控制器，它会持续监控正在运行的应用，并将当前的实际状态与 Git 仓库中声明的期望状态进行比较，如果实际状态不符合期望状态，就会更新应用的实际状态以匹配期望状态。&lt;/p>
&lt;p>在正式开始解读和使用 Argo CD 之前，我们需要先搞清楚为什么需要 Argo CD？它能给我们带来什么价值？&lt;/p>
&lt;h2 id="传统-cd-工作流">传统 CD 工作流&lt;/h2>
&lt;p>从上篇文章『👉&lt;a href="http://mp.weixin.qq.com/s?__biz=MzU1MzY4NzQ1OA==&amp;amp;mid=2247509873&amp;amp;idx=1&amp;amp;sn=dd6daee66f39a965e4680ecd91f884d7&amp;amp;chksm=fbede7bccc9a6eaa6ddf5d082ed20a31d1956425eb8129428b2e2701fb216ef331a706f6d008&amp;amp;scene=21#wechat_redirect">GitOps 介绍[2]&lt;/a>』可以知道，目前大多数 CI/CD 工具都使用基于 Push 的部署模式，例如 Jenkins、CircleCI 等。这种模式一般都会在 CI 流水线运行完成后执行一个命令（比如 kubectl）将应用部署到目标环境中。&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/cogrm6/1662076442944-8d47843e-5af5-4d31-ba22-3e8e6194bc88.jpeg" alt="">&lt;/p>
&lt;p>这种 CD 模式的缺陷很明显：&lt;/p>
&lt;ul>
&lt;li>需要安装配置额外工具（比如 kubectl）；&lt;/li>
&lt;li>需要 Kubernetes 对其进行授权；&lt;/li>
&lt;li>需要云平台授权；&lt;/li>
&lt;li>无法感知部署状态。也就无法感知期望状态与实际状态的偏差，需要借助额外的方案来保障一致性。&lt;/li>
&lt;/ul>
&lt;p>下面以 Argo CD 为例，来看看遵循声明式 GitOps 理念的 CD 工具是怎么实现的。&lt;/p>
&lt;h2 id="使用-argo-cd-的-cd-工作流">使用 Argo CD 的 CD 工作流&lt;/h2>
&lt;p>和传统 CI/CD 工具一样，CI 部分并没有什么区别，无非就是测试、构建镜像、推送镜像、修改部署清单等等。重点在于 CD 部分。&lt;/p>
&lt;p>Argo CD 会被部署在 Kubernetes 集群中，使用的是基于 Pull 的部署模式，它会周期性地监控应用的实际状态，也会周期性地拉取 Git 仓库中的配置清单，并将实际状态与期望状态进行比较，如果实际状态不符合期望状态，就会更新应用的实际状态以匹配期望状态。&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/cogrm6/1662076443010-40f73633-ab15-4158-8e71-f792a2b8fe11.png" alt="">&lt;/p>
&lt;p>无论是通过 CI 流水线触发更新 K8s 编排文件，还是 DevOps 工程师直接修改 K8s 编排文件，Argo CD 都会自动拉取最新的配置并应用到 K8s 集群中。&lt;/p>
&lt;p>最终会得到一个相互隔离的 CI 与 CD 流水线，CI 流水线通常由研发人员（或者 DevOps 团队）控制，CD 流水线通常由集群管理员（或者 DevOps 团队）控制。&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/cogrm6/1662076442866-9f57ee65-a081-468a-8013-cb6319c73a51.png" alt="">&lt;/p>
&lt;h2 id="argo-cd-的优势">Argo CD 的优势&lt;/h2>
&lt;p>下面我们来看看 Argo CD 相较于传统 CD 工具有哪些比较明显的优势。&lt;/p>
&lt;h3 id="git-作为应用的唯一真实来源">Git 作为应用的唯一真实来源&lt;/h3>
&lt;p>所有 K8s 的声明式配置都保存在 Git 中，并把 Git 作为应用的唯一事实来源，我们不再需要手动更新应用（比如执行脚本，执行 kubectl apply 或者 helm install 命令），只需要通过统一的接口（Git）来更新应用。&lt;/p>
&lt;p>此外，Argo CD 不仅会监控 Git 仓库中声明的期望状态，还会监控集群中应用的实际状态，并将两种状态进行对比，只要实际状态不符合期望状态，实际状态就会被修正与期望状态一致。所以即使有人修改了集群中应用的状态（比如修改了副本数量），Argo CD 还是会将其恢复到之前的状态。&lt;strong>这就真正确保了 Git 仓库中的编排文件可以作为集群状态的唯一真实来源。&lt;/strong>&lt;/p>
&lt;p>当然，有时候我们需要快速更新应用并进行调试，通过 Git 来触发更新还是慢了点，这也不是没有办法，我们可以修改 Argo CD 的配置，使其不对手动修改的部分进行覆盖或者回退，而是直接发送告警，提醒管理员不要忘了将更新提交到 Git 仓库中。&lt;/p>
&lt;h3 id="快速回滚">快速回滚&lt;/h3>
&lt;p>Argo CD 会定期拉取最新配置并应用到集群中，一旦最新的配置导致应用出现了故障（比如应用启动失败），我们可以通过 Git History 将应用状态快速恢复到上一个可用的状态。&lt;/p>
&lt;p>如果你有多个 Kubernetes 集群使用同一个 Git 仓库，这个优势会更明显，因为你不需要分别在不同的集群中通过 &lt;code>kubectl delete&lt;/code> 或者 &lt;code>helm uninstall&lt;/code> 等手动方式进行回滚，只需要将 Git 仓库回滚到上一个可用的版本，Argo CD 便会自动同步。&lt;/p>
&lt;h3 id="集群灾备">集群灾备&lt;/h3>
&lt;p>如果你在青云[3]北京 3 区中的 KubeSphere[4] 集群出现故障，且短期内不可恢复，可以直接创建一个新集群，然后将 Argo CD 连接到 Git 仓库，这个仓库包含了整个集群的所有配置声明。最终新集群的状态会与之前旧集群的状态一致，完全不需要人工干预。&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/cogrm6/1662076442877-2851ab43-7392-4cf9-8328-2403d8d2c586.png" alt="">&lt;/p>
&lt;h3 id="使用-git-实现访问控制">使用 Git 实现访问控制&lt;/h3>
&lt;p>通常在生产环境中是不允许所有人访问 Kubernetes 集群的，如果直接在 Kubernetes 集群中控制访问权限，必须要使用复杂的 RBAC 规则。在 Git 仓库中控制权限就比较简单了，例如所有人（DevOps 团队，运维团队，研发团队，等等）都可以向仓库中提交 Pull Request，但只有高级工程师可以合并 Pull Request。&lt;/p>
&lt;p>这样做的好处是，除了集群管理员和少数人员之外，其他人不再需要直接访问 Kubernetes 集群，只需访问 Git 仓库即可。对于程序而言也是如此，类似于 Jenkins 这样的 CI 工具也不再需要访问 Kubernetes 的权限，因为只有 Argo CD 才可以 apply 配置清单，而且 Argo CD 已经部署在 Kubernetes 集群中，必要的访问权限已经配置妥当，这样就不需要给集群外的任意人或工具提供访问的证书，可以提供更强大的安全保障。&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/cogrm6/1662076443389-772dc87a-8c2c-4ba9-aad2-310ec93fcb50.png" alt="">&lt;/p>
&lt;h3 id="扩展-kubernetes">扩展 Kubernetes&lt;/h3>
&lt;p>虽然 Argo CD 可以部署在 Kubernetes 集群中，享受 Kubernetes 带来的好处，但这不是 Argo CD 专属的呀！Jenkins 不是也可以部署在 Kubernetes 中吗？Argo CD 有啥特殊的吗？&lt;/p>
&lt;p>那当然有了，没这金刚钻也不敢揽这瓷器活啊，Argo CD 巧妙地利用了 Kubernetes 集群中的很多功能来实现自己的目的，例如所有的资源都存储在 Etcd 集群中，利用 Kubernetes 的控制器来监控应用的实际状态并与期望状态进行对比，等等。&lt;/p>
&lt;p>这样做最直观的好处就是&lt;strong>可以实时感知应用的部署状态&lt;/strong>。例如，当你在 Git 仓库中更新配置清单中的镜像版本后，Argo CD 会将集群中的应用更新到最新版本，你可以在 Argo CD 的可视化界面中实时查看更新状态（比如 Pod 创建成功，应用成功运行并且处于健康状态，或者应用运行失败需要进行回滚操作）。&lt;/p>
&lt;h2 id="argo-cd-架构">Argo CD 架构&lt;/h2>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/cogrm6/1662076443403-3ee90747-ee9b-44c4-9990-0ec25bff6e51.png" alt="">&lt;/p>
&lt;p>从功能架构来看，Argo CD 主要有三个组件：API Server、Repository Server 和 Application Controller。从 GitOps 工作流的角度来看，总共分为 3 个阶段：检索、调谐和呈现。&lt;/p>
&lt;h3 id="检索----repository-server">检索 &amp;ndash; Repository Server&lt;/h3>
&lt;p>检索阶段会克隆应用声明式配置清单所在的 Git 仓库，并将其缓存到本地存储。包含 Kubernetes 原生的配置清单、Helm Chart 以及 Kustomize 配置清单。履行这些职责的组件就是 &lt;strong>Repository Server&lt;/strong>。&lt;/p>
&lt;h3 id="调谐----application-controller">调谐 &amp;ndash; Application Controller&lt;/h3>
&lt;p>调谐（Reconcile）阶段是最复杂的，这个阶段会将 &lt;strong>Repository Server&lt;/strong> 获得的配置清单与反映集群当前状态的实时配置清单进行对比，一旦检测到应用处于 &lt;code>OutOfSync&lt;/code> 状态，&lt;strong>Application Controller&lt;/strong> 就会采取修正措施，使集群的实际状态与期望状态保持一致。&lt;/p>
&lt;h3 id="呈现----api-server">呈现 &amp;ndash; API Server&lt;/h3>
&lt;p>最后一个阶段是呈现阶段，由 Argo CD 的 &lt;strong>API Server&lt;/strong> 负责，它本质上是一个 gRPC/REST Server，提供了一个无状态的可视化界面，用于展示调谐阶段的结果。同时还提供了以下这些功能：&lt;/p>
&lt;ul>
&lt;li>应用管理和状态报告；&lt;/li>
&lt;li>调用与应用相关的操作（例如同步、回滚、以及用户自定义的操作）；&lt;/li>
&lt;li>Git 仓库与集群凭证管理（以 Kubernetes Secret 的形式存储）；&lt;/li>
&lt;li>为外部身份验证组件提供身份验证和授权委托；&lt;/li>
&lt;li>RBAC 增强；&lt;/li>
&lt;li>Git Webhook 事件的监听器/转发器。&lt;/li>
&lt;/ul>
&lt;h2 id="部署-argo-cd">部署 Argo CD&lt;/h2>
&lt;p>Argo CD 有两种不同的部署模式：&lt;/p>
&lt;h3 id="多租户">多租户&lt;/h3>
&lt;p>Argo CD 最常用的部署模式是多租户，一般如果组织内部包含多个应用研发团队，就会采用这种部署模式。用户可以使用可视化界面或者 argocd CLI 来访问 Argo CD。argocd CLI 必须先通过 &lt;code>argocd login &amp;lt;server-host&amp;gt;&lt;/code> 来获取 Argo CD 的访问授权。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-c" data-lang="c">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#960050;background-color:#1e0010">$&lt;/span> argocd login SERVER [flags]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">## Login to Argo CD using a username and password
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">$&lt;/span> argocd login cd.argoproj.io
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">## Login to Argo CD using SSO
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">$&lt;/span> argocd login cd.argoproj.io &lt;span style="color:#f92672">--&lt;/span>sso
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">## Configure direct access using Kubernetes API server
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">$&lt;/span> argocd login cd.argoproj.io &lt;span style="color:#f92672">--&lt;/span>core
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>多租户模式提供了两种不同的配置清单：&lt;/p>
&lt;h4 id="非高可用">非高可用&lt;/h4>
&lt;p>推荐用于测试和演示环境，不推荐在生产环境下使用。有两种部署清单可供选择：&lt;/p>
&lt;ul>
&lt;li>install.yaml[5] - 标准的 Argo CD 部署清单，拥有集群管理员权限。可以使用 Argo CD 在其运行的集群内部署应用程序，也可以通过接入外部集群的凭证将应用部署到外部集群中。&lt;/li>
&lt;li>namespace-install.yaml[6] - 这个部署清单只需要 namespace 级别的权限。如果你不需要在 Argo CD 运行的集群中部署应用，只需通过接入外部集群的凭证将应用部署到外部集群中，推荐使用此部署清单。还有一种花式玩法，你可以为每个团队分别部署单独的 Argo CD 实例，但是每个 Argo CD 实例都可以使用特殊的凭证（例如 &lt;code>argocd cluster add &amp;lt;CONTEXT&amp;gt; --in-cluster --namespace &amp;lt;YOUR NAMESPACE&amp;gt;&lt;/code>）将应用部署到同一个集群中（即 &lt;code>kubernetes.svc.default&lt;/code>，也就是内部集群）。&lt;/li>
&lt;/ul>
&lt;blockquote>
&lt;p>⚠️ 注意：namespace-install.yaml 配置清单中并不包含 Argo CD 的 CRD，需要自己提前单独部署：&lt;code>kubectl apply -k https://github.com/argoproj/argo-cd/manifests/crds\?ref\=stable&lt;/code>。&lt;/p>
&lt;/blockquote>
&lt;h4 id="高可用">高可用&lt;/h4>
&lt;p>与非高可用部署清单包含的组件相同，但增强了高可用能力和弹性能力，推荐在生产环境中使用。&lt;/p>
&lt;ul>
&lt;li>ha/install.yaml[7] - 与上文提到的 install.yaml 的内容相同，但配置了相关组件的多个副本。&lt;/li>
&lt;li>ha/namespace-install.yaml[8] - 与上文提到的 namespace-install.yaml 相同，但配置了相关组件的多个副本。&lt;/li>
&lt;/ul>
&lt;h3 id="core">Core&lt;/h3>
&lt;p>Core 模式也就是最精简的部署模式，不包含 API Server 和可视化界面，只部署了每个组件的轻量级（非高可用）版本。&lt;/p>
&lt;p>用户需要 Kubernetes 访问权限来管理 Argo CD，因此必须使用下面的命令来配置 argocd CLI：&lt;/p>
&lt;p>&lt;code>$ kubectl config set-context --current --namespace=argocd # change current kube context to argocd namespace $ argocd login --core&lt;/code>&lt;/p>
&lt;p>也可以使用命令 &lt;code>argocd admin dashboard&lt;/code> 手动启用可视化界面。&lt;/p>
&lt;p>具体的配置清单位于 Git 仓库中的 core-install.yaml[9]。&lt;/p>
&lt;hr>
&lt;p>除了直接通过原生的配置清单进行部署，Argo CD 还支持额外的配置清单管理工具。&lt;/p>
&lt;h3 id="kustomize">Kustomize&lt;/h3>
&lt;p>Argo CD 配置清单也可以使用 Kustomize 来部署，建议通过远程的 URL 来调用配置清单，使用 patch 来配置自定义选项。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-yaml" data-lang="yaml">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">apiVersion&lt;/span>: &lt;span style="color:#ae81ff">kustomize.config.k8s.io/v1beta1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">kind&lt;/span>: &lt;span style="color:#ae81ff">Kustomization&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">namespace&lt;/span>: &lt;span style="color:#ae81ff">argocd&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">resources&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#ae81ff">https://raw.githubusercontent.com/argoproj/argo-cd/v2.0.4/manifests/ha/install.yaml&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="helm">Helm&lt;/h3>
&lt;p>Argo CD 的 Helm Chart 目前由社区维护，地址：https://github.com/argoproj/argo-helm/tree/master/charts/argo-cd[10]。
接下来开始部署 Argo CD：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>$ kubectl create namespace argocd
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>$ kubectl apply -n argocd -f https://raw.githubusercontent.com/argoproj/argo-cd/stable/manifests/install.yaml
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>查看部署结果：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>$ kubectl -n argocd get pod
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>argocd-applicationset-controller-69879c47c-pcbkg 1/1 Running &lt;span style="color:#ae81ff">0&lt;/span> 26m
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>argocd-notifications-controller-6b4b74d8d8-s7mrz 1/1 Running &lt;span style="color:#ae81ff">0&lt;/span> 26m
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>argocd-redis-65596bf87-2hzcv 1/1 Running &lt;span style="color:#ae81ff">0&lt;/span> 26m
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>argocd-dex-server-78c9764884-6lcww 1/1 Running &lt;span style="color:#ae81ff">0&lt;/span> 26m
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>argocd-repo-server-657d46f8b-87rzq 1/1 Running &lt;span style="color:#ae81ff">0&lt;/span> 26m
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>argocd-application-controller-0 1/1 Running &lt;span style="color:#ae81ff">0&lt;/span> 26m
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>argocd-server-6b48df79dd-b7bkw 1/1 Running &lt;span style="color:#ae81ff">0&lt;/span> 26m
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="访问-argo-cd">访问 Argo CD&lt;/h2>
&lt;p>部署完成后，可以通过 Service &lt;code>argocd-server&lt;/code> 来访问可视化界面。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>$ kubectl -n argocd get svc
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>NAME TYPE CLUSTER-IP EXTERNAL-IP PORT&lt;span style="color:#f92672">(&lt;/span>S&lt;span style="color:#f92672">)&lt;/span> AGE
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>argocd-applicationset-controller ClusterIP 10.105.250.212 &amp;lt;none&amp;gt; 7000/TCP,8080/TCP 5m10s
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>argocd-dex-server ClusterIP 10.108.88.97 &amp;lt;none&amp;gt; 5556/TCP,5557/TCP,5558/TCP 5m10s
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>argocd-metrics ClusterIP 10.103.11.245 &amp;lt;none&amp;gt; 8082/TCP 5m10s
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>argocd-notifications-controller-metrics ClusterIP 10.98.136.200 &amp;lt;none&amp;gt; 9001/TCP 5m9s
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>argocd-redis ClusterIP 10.110.151.108 &amp;lt;none&amp;gt; 6379/TCP 5m9s
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>argocd-repo-server ClusterIP 10.109.131.197 &amp;lt;none&amp;gt; 8081/TCP,8084/TCP 5m9s
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>argocd-server ClusterIP 10.98.23.255 &amp;lt;none&amp;gt; 80/TCP,443/TCP 5m9s
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>argocd-server-metrics ClusterIP 10.103.184.121 &amp;lt;none&amp;gt; 8083/TCP 5m8s
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>如果你的客户端可以直连 Service IP，那就直接可以通过 argocd-server 的 Cluster IP 来访问。或者可以直接通过本地端口转发来访问：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>$ kubectl port-forward svc/argocd-server -n argocd 8080:443
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Forwarding from 127.0.0.1:8080 -&amp;gt; &lt;span style="color:#ae81ff">8080&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Forwarding from &lt;span style="color:#f92672">[&lt;/span>::1&lt;span style="color:#f92672">]&lt;/span>:8080 -&amp;gt; &lt;span style="color:#ae81ff">8080&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>初始密码以明文形式存储在 Secret &lt;code>argocd-initial-admin-secret&lt;/code> 中，可以通过以下命令获取：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>$ kubectl -n argocd get secret argocd-initial-admin-secret -o jsonpath&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;{.data.password}&amp;#34;&lt;/span> | base64 -d; echo
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>也可以通过以下命令来修改登录密码：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>$ argocd account update-password --account admin --current-password xxxx --new-password xxxx
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>登录后的界面：
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/cogrm6/1662076443531-40c539e0-8797-4c46-b641-f433feeb83b8.png" alt="">&lt;/p>
&lt;h2 id="argo-cd-核心概念">Argo CD 核心概念&lt;/h2>
&lt;p>在正式开始使用 Argo CD 之前，需要先了解两个基本概念。&lt;/p>
&lt;h3 id="argo-cd-application">Argo CD Application&lt;/h3>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/cogrm6/1662076443778-4339e877-616e-464e-a6ef-b2f02ff400e6.png" alt="">&lt;/p>
&lt;p>Argo CD 中的 Application 定义了 Kubernetes 资源的&lt;strong>来源&lt;/strong>（Source）和&lt;strong>目标&lt;/strong>（Destination）。来源指的是 Git 仓库中 Kubernetes 资源配置清单所在的位置，而目标是指资源在 Kubernetes 集群中的部署位置。&lt;/p>
&lt;p>来源可以是原生的 Kubernetes 配置清单，也可以是 Helm Chart 或者 Kustomize 部署清单。&lt;/p>
&lt;p>目标指定了 Kubernetes 集群中 API Server 的 URL 和相关的 namespace，这样 Argo CD 就知道将应用部署到哪个集群的哪个 namespace 中。&lt;/p>
&lt;p>简而言之，&lt;strong>Application 的职责就是将目标 Kubernetes 集群中的 namespace 与 Git 仓库中声明的期望状态连接起来&lt;/strong>。&lt;/p>
&lt;p>Application 的配置清单示例：&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/cogrm6/1662076443806-967865f5-cc3a-4f10-b687-16c0c479a069.jpeg" alt="">&lt;/p>
&lt;p>如果有多个团队，每个团队都要维护大量的应用，就需要用到 Argo CD 的另一个概念：&lt;strong>项目&lt;/strong>（Project）。&lt;/p>
&lt;h3 id="argo-cd-project">Argo CD Project&lt;/h3>
&lt;p>Argo CD 中的项目（Project）可以用来对 Application 进行分组，不同的团队使用不同的项目，这样就实现了多租户环境。项目还支持更细粒度的访问权限控制：&lt;/p>
&lt;ul>
&lt;li>限制部署内容（受信任的 Git 仓库）；&lt;/li>
&lt;li>限制目标部署环境（目标集群和 namespace）；&lt;/li>
&lt;li>限制部署的资源类型（例如 RBAC、CRD、DaemonSets、NetworkPolicy 等）；&lt;/li>
&lt;li>定义项目角色，为 Application 提供 RBAC（与 OIDC group 或者 JWT 令牌绑定）。&lt;/li>
&lt;/ul>
&lt;h2 id="demo-演示">Demo 演示&lt;/h2>
&lt;p>最后通过一个简单的示例来展示 Argo CD 的工作流程。&lt;/p>
&lt;h3 id="准备-git-仓库">准备 Git 仓库&lt;/h3>
&lt;p>在 GitHub 上创建一个项目，取名为 argocd-lab[13]，为了方便实验将仓库设置为公共仓库。在仓库中新建 dev 目录，在目录中创建两个 YAML 配置清单，分别是 &lt;code>deployment.yaml&lt;/code> 和 &lt;code>service.yaml&lt;/code>。&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/cogrm6/1662076443997-1e374e40-cdf9-49dc-b9a1-68269c22df40.png" alt="">
配置清单内容如下：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-yaml" data-lang="yaml">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># deployment.yaml&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">apiVersion&lt;/span>: &lt;span style="color:#ae81ff">apps/v1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">kind&lt;/span>: &lt;span style="color:#ae81ff">Deployment&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">metadata&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">name&lt;/span>: &lt;span style="color:#ae81ff">myapp&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">spec&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">selector&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">matchLabels&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">app&lt;/span>: &lt;span style="color:#ae81ff">myapp&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">replicas&lt;/span>: &lt;span style="color:#ae81ff">2&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">template&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">metadata&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">labels&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">app&lt;/span>: &lt;span style="color:#ae81ff">myapp&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">spec&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">containers&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#f92672">name&lt;/span>: &lt;span style="color:#ae81ff">myapp&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">image&lt;/span>: &lt;span style="color:#ae81ff">nginx:latest&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">ports&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#f92672">containerPort&lt;/span>: &lt;span style="color:#ae81ff">80&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># service.yaml&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">apiVersion&lt;/span>: &lt;span style="color:#ae81ff">v1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">kind&lt;/span>: &lt;span style="color:#ae81ff">Service&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">metadata&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">name&lt;/span>: &lt;span style="color:#ae81ff">myapp-service&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">spec&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">selector&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">app&lt;/span>: &lt;span style="color:#ae81ff">myapp&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">ports&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#f92672">port&lt;/span>: &lt;span style="color:#ae81ff">80&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">protocol&lt;/span>: &lt;span style="color:#ae81ff">TCP&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">targetPort&lt;/span>: &lt;span style="color:#ae81ff">80&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>接下来在仓库根目录中创建一个 Application 的配置清单：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-yaml" data-lang="yaml">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># application.yaml&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">apiVersion&lt;/span>: &lt;span style="color:#ae81ff">argoproj.io/v1alpha1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">kind&lt;/span>: &lt;span style="color:#ae81ff">Application&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">metadata&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">name&lt;/span>: &lt;span style="color:#ae81ff">myapp-argo-application&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">namespace&lt;/span>: &lt;span style="color:#ae81ff">argocd&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">spec&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">project&lt;/span>: &lt;span style="color:#ae81ff">default&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">source&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">repoURL&lt;/span>: &lt;span style="color:#ae81ff">https://github.com/yangchuansheng/argocd-lab.git&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">targetRevision&lt;/span>: &lt;span style="color:#ae81ff">HEAD&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">path&lt;/span>: &lt;span style="color:#ae81ff">dev&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">destination&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">server&lt;/span>: &lt;span style="color:#ae81ff">https://kubernetes.default.svc&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">namespace&lt;/span>: &lt;span style="color:#ae81ff">myapp&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">syncPolicy&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">syncOptions&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#ae81ff">CreateNamespace=true&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">automated&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">selfHeal&lt;/span>: &lt;span style="color:#66d9ef">true&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">prune&lt;/span>: &lt;span style="color:#66d9ef">true&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>参数解释：&lt;/p>
&lt;ul>
&lt;li>&lt;strong>syncPolicy&lt;/strong> : 指定自动同步策略和频率，不配置时需要手动触发同步。&lt;/li>
&lt;li>&lt;strong>syncOptions&lt;/strong> : 定义同步方式。&lt;/li>
&lt;li>&lt;strong>CreateNamespace=true&lt;/strong> : 如果不存在这个 namespace，就会自动创建它。&lt;/li>
&lt;li>&lt;strong>automated&lt;/strong> : 检测到实际状态与期望状态不一致时，采取的同步措施。&lt;/li>
&lt;li>&lt;strong>selfHeal&lt;/strong> : 当集群世纪状态不符合期望状态时，自动同步。&lt;/li>
&lt;li>&lt;strong>prune&lt;/strong> : 自动同步时，删除 Git 中不存在的资源。&lt;/li>
&lt;/ul>
&lt;p>Argo CD 默认情况下&lt;strong>每 3 分钟&lt;/strong>会检测 Git 仓库一次，用于判断应用实际状态是否和 Git 中声明的期望状态一致，如果不一致，状态就转换为 &lt;code>OutOfSync&lt;/code>。默认情况下并不会触发更新，除非通过 &lt;code>syncPolicy&lt;/code> 配置了自动同步。&lt;/p>
&lt;p>如果嫌周期性同步太慢了，也可以通过设置 Webhook 来使 Git 仓库更新时立即触发同步。具体的使用方式会放到后续的教程中，本文不再赘述。&lt;/p>
&lt;h3 id="创建-application">创建 Application&lt;/h3>
&lt;p>现在万事具备，只需要通过 application.yaml 创建 Application 即可。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>$ kubectl apply -f application.yaml
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>application.argoproj.io/myapp-argo-application created
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>在 Argo CD 可视化界面中可以看到应用已经创建成功了。
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/cogrm6/1662076444145-4526c86e-f5b5-43c3-8737-ec29479adfdf.png" alt="">
点进去可以看到应用的同步详情和各个资源的健康状况。
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/cogrm6/1662076444129-228cbe84-33c0-4d98-ad77-d0e76e9292b5.png" alt="">
&lt;strong>如果你更新了 deployment.yaml 中的镜像，Argo CD 会自动检测到 Git 仓库中的更新，并且将集群中 Deployment 的镜像更新为 Git 仓库中最新设置的镜像版本。&lt;/strong>&lt;/p>
&lt;h2 id="总结">总结&lt;/h2>
&lt;p>本文介绍了 Argo CD 的优势、架构和工作原理，并通过一个简单的示例对其功能进行演示，比如修改 Git 仓库内容后，可以自动触发更新。还可以通过 Event Source 和 Trigger 实现更多自动化部署的需求。&lt;/p>
&lt;p>在部署 Kubernetes 资源时，Argo CD 还支持 Kustomize、Helm、Ksonnet 等资源描述方式，包括其他更高级的使用方式都会在后续的教程中为大家一一道来，敬请期待。&lt;/p>
&lt;h3 id="引用链接">引用链接&lt;/h3>
&lt;p>[1]&lt;/p>
&lt;p>GitOps 介绍: &lt;a href="https://icloudnative.io/">&lt;em>https://icloudnative.io/&lt;/em>&lt;/a>&lt;/p>
&lt;p>[2]&lt;/p>
&lt;p>GitOps 介绍: &lt;a href="https://icloudnative.io/">&lt;em>https://icloudnative.io/&lt;/em>&lt;/a>&lt;/p>
&lt;p>[3]&lt;/p>
&lt;p>青云: &lt;a href="https://www.qingcloud.com/">&lt;em>https://www.qingcloud.com/&lt;/em>&lt;/a>&lt;/p>
&lt;p>[4]&lt;/p>
&lt;p>KubeSphere: &lt;a href="https://kubesphere.com.cn">&lt;em>https://kubesphere.com.cn&lt;/em>&lt;/a>&lt;/p>
&lt;p>[5]&lt;/p>
&lt;p>install.yaml: &lt;a href="https://github.com/argoproj/argo-cd/blob/master/manifests/install.yaml">&lt;em>https://github.com/argoproj/argo-cd/blob/master/manifests/install.yaml&lt;/em>&lt;/a>&lt;/p>
&lt;p>[6]&lt;/p>
&lt;p>namespace-install.yaml: &lt;a href="https://github.com/argoproj/argo-cd/blob/master/manifests/namespace-install.yaml">&lt;em>https://github.com/argoproj/argo-cd/blob/master/manifests/namespace-install.yaml&lt;/em>&lt;/a>&lt;/p>
&lt;p>[7]&lt;/p>
&lt;p>ha/install.yaml: &lt;a href="https://github.com/argoproj/argo-cd/blob/master/manifests/ha/install.yaml">&lt;em>https://github.com/argoproj/argo-cd/blob/master/manifests/ha/install.yaml&lt;/em>&lt;/a>&lt;/p>
&lt;p>[8]&lt;/p>
&lt;p>ha/namespace-install.yaml: &lt;a href="https://github.com/argoproj/argo-cd/blob/master/manifests/ha/namespace-install.yaml">&lt;em>https://github.com/argoproj/argo-cd/blob/master/manifests/ha/namespace-install.yaml&lt;/em>&lt;/a>&lt;/p>
&lt;p>[9]&lt;/p>
&lt;p>core-install.yaml: &lt;a href="https://github.com/argoproj/argo-cd/blob/master/manifests/core-install.yaml">&lt;em>https://github.com/argoproj/argo-cd/blob/master/manifests/core-install.yaml&lt;/em>&lt;/a>&lt;/p>
&lt;p>[10]&lt;/p>
&lt;p>&lt;a href="https://github.com/argoproj/argo-helm/tree/master/charts/argo-cd:">https://github.com/argoproj/argo-helm/tree/master/charts/argo-cd:&lt;/a> &lt;a href="https://github.com/argoproj/argo-helm/tree/master/charts/argo-cd">&lt;em>https://github.com/argoproj/argo-helm/tree/master/charts/argo-cd&lt;/em>&lt;/a>&lt;/p>
&lt;p>[11]&lt;/p>
&lt;p>KubeSphere Cloud 托管集群服务: &lt;a href="https://kubesphere.cloud/console/resource/">&lt;em>https://kubesphere.cloud/console/resource/&lt;/em>&lt;/a>&lt;/p>
&lt;p>[12]&lt;/p>
&lt;p>&lt;a href="https://kubesphere.cloud">https://kubesphere.cloud&lt;/a>: &lt;a href="https://kubesphere.cloud/">&lt;em>https://kubesphere.cloud/&lt;/em>&lt;/a>&lt;/p>
&lt;p>[13]&lt;/p>
&lt;p>argocd-lab: &lt;a href="https://github.com/yangchuansheng/argocd-lab">&lt;em>https://github.com/yangchuansheng/argocd-lab&lt;/em>&lt;/a>&lt;/p>
&lt;p>[14]&lt;/p>
&lt;p>KubeSphere 从 3.3.0 开始: &lt;a href="https://kubesphere.com.cn/news/kubesphere-3.3.0-ga-announcement/">&lt;em>https://kubesphere.com.cn/news/kubesphere-3.3.0-ga-announcement/&lt;/em>&lt;/a>&lt;/p></description></item></channel></rss>