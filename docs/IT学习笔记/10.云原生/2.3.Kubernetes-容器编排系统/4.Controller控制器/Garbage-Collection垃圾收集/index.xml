<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>断念梦 – Garbage Collection(垃圾收集)</title><link>https://desistdaydream.github.io/docs/IT%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/10.%E4%BA%91%E5%8E%9F%E7%94%9F/2.3.Kubernetes-%E5%AE%B9%E5%99%A8%E7%BC%96%E6%8E%92%E7%B3%BB%E7%BB%9F/4.Controller%E6%8E%A7%E5%88%B6%E5%99%A8/Garbage-Collection%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86/</link><description>Recent content in Garbage Collection(垃圾收集) on 断念梦</description><generator>Hugo -- gohugo.io</generator><atom:link href="https://desistdaydream.github.io/docs/IT%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/10.%E4%BA%91%E5%8E%9F%E7%94%9F/2.3.Kubernetes-%E5%AE%B9%E5%99%A8%E7%BC%96%E6%8E%92%E7%B3%BB%E7%BB%9F/4.Controller%E6%8E%A7%E5%88%B6%E5%99%A8/Garbage-Collection%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86/index.xml" rel="self" type="application/rss+xml"/><item><title>Docs: Finalizers</title><link>https://desistdaydream.github.io/docs/IT%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/10.%E4%BA%91%E5%8E%9F%E7%94%9F/2.3.Kubernetes-%E5%AE%B9%E5%99%A8%E7%BC%96%E6%8E%92%E7%B3%BB%E7%BB%9F/4.Controller%E6%8E%A7%E5%88%B6%E5%99%A8/Garbage-Collection%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86/Finalizers/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/IT%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/10.%E4%BA%91%E5%8E%9F%E7%94%9F/2.3.Kubernetes-%E5%AE%B9%E5%99%A8%E7%BC%96%E6%8E%92%E7%B3%BB%E7%BB%9F/4.Controller%E6%8E%A7%E5%88%B6%E5%99%A8/Garbage-Collection%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86/Finalizers/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://kubernetes.io/docs/concepts/overview/working-with-objects/finalizers/">官方文档，概念-概述-使用 Kubernetes 对象-Finalizers&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://mp.weixin.qq.com/s/U8ZhfjWDzLhFUaRxvLIVDw">公众号-云原生之路，熟悉又陌生的 k8s 字段：finalizers&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://kubernetes.io/blog/2021/05/14/using-finalizers-to-control-deletion/">Kubernetes 博客，使用 Finalizers 控制删除&lt;/a>
&lt;ul>
&lt;li>&lt;a href="https://mp.weixin.qq.com/s/pbq0jEIqfu3Sc-B0eultWA">公众号-云原生实验室，使用 Finalizers 来删除那些死活删不掉的 K8S 资源&lt;/a>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>&lt;strong>Finalizer(终结器)&lt;/strong> 是一个存放键的列表，不具有任何实际意义，类似于 annotations 字段的功能。它告诉 Kubernetes 在完全删除标记为删除的资源之前等待满足特定条件。终结器提醒控制器清理已删除对象拥有的资源。只有一个对象的 &lt;code>metadata.finalizers&lt;/code> 字段的值为空，该对象才可以被删除。&lt;/p>
&lt;p>带有 &lt;code>finalizers&lt;/code> 字段的对象无法删除的原因大致如下：&lt;/p>
&lt;ul>
&lt;li>对象存在 &lt;code>finalizers&lt;/code>，关联的控制器故障未能执行或执行 finalizer 函数 hang 住 : 比如 namespace 控制器无法删除完空间内所有的对象， 特别是在使用 aggregated apiserver 时，第三方 apiserver 服务故障导致无法删除其对象。 此时，需要会恢复第三方 apiserver 服务或移除该 apiserver 的聚合，具体选择哪种方案需根据实际情况而定。&lt;/li>
&lt;li>集群内安装的控制器给一些对象增加了自定义 finalizers，未删除完 fianlizers 就下线了该控制器，导致这些 fianlizers 没有控制器来移除他们。此时，有两种方式可以正常删除这些对象，其一，恢复该控制器，控制器会移除 finalizers 字段，其二，手动移除 finalizers 字段(多出现于自定义 operator)，具体选择哪种方案根据实际情况而定。
&lt;ul>
&lt;li>RabbitMQ Operator 就是这种情况，但是 Prometheus Operator 就没这问题。。。。o(╯□╰)o~~~&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h1 id="熟悉又陌生的-k8s-字段finalizers">熟悉又陌生的 k8s 字段：finalizers&lt;/h1>
&lt;p>经常操作 Kubernetes 集群的同学肯定对 finalizers 字段不陌生，每当删除 namespace 或 pod 等一些 Kubernetes 资源时，有时资源状态会卡在 Terminating，很长时间无法删除，甚至有时增加 &amp;ndash;force flag 之后还是无法正常删除。这时就需要 edit 该资源，将 finalizers 字段设置为 []，之后 Kubernetes 资源就正常删除了。&lt;/p>
&lt;p>这是一个比较常见的操作，但是当有人问 finalizers 字段的作用是什么的时候，我是懵逼的，我甚至不知道这个熟悉又陌生的单词怎么读！那么这篇文章就来探索一下 finalizers 这个字段到底是做什么的，在实践中应该怎么应用这个字段。（另外，这个单词读作 [&amp;lsquo;faɪnəlaɪzər]）&lt;/p>
&lt;p>Finalizers 字段属于 Kubernetes GC 垃圾收集器，是一种删除拦截机制，能够让控制器实现异步的删除前（Pre-delete）回调。其存在于任何一个资源对象的 Meta[1] 中，在 k8s 源码中声明为 []string，该 Slice 的内容为需要执行的拦截器名称。&lt;/p>
&lt;p>对带有 Finalizer 的对象的第一个删除请求会为其 metadata.deletionTimestamp 设置一个值，但不会真的删除对象。一旦此值被设置，finalizers 列表中的值就只能被移除。&lt;/p>
&lt;p>当 metadata.deletionTimestamp 字段被设置时，负责监测该对象的各个控制器会通过轮询对该对象的更新请求来执行它们所要处理的所有 Finalizer。当所有 Finalizer 都被执行过，资源被删除。&lt;/p>
&lt;p>metadata.deletionGracePeriodSeconds 的取值控制对更新的轮询周期。&lt;/p>
&lt;p>每个控制器要负责将其 Finalizer 从列表中去除。&lt;/p>
&lt;p>每执行完一个就从 finalizers 中移除一个，直到 finalizers 为空，之后其宿主资源才会被真正的删除。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// DeletionTimestamp is RFC 3339 date and time at which this resource will be deleted. This
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// field is set by the server when a graceful deletion is requested by the user, and is not
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// directly settable by a client. The resource is expected to be deleted (no longer visible
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// from resource lists, and not reachable by name) after the time in this field, once the
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// finalizers list is empty. As long as the finalizers list contains items, deletion is blocked.
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// Once the deletionTimestamp is set, this value may not be unset or be set further into the
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// future, although it may be shortened or the resource may be deleted prior to this time.
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// For example, a user may request that a pod is deleted in 30 seconds. The Kubelet will react
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// by sending a graceful termination signal to the containers in the pod. After that 30 seconds,
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// the Kubelet will send a hard termination signal (SIGKILL) to the container and after cleanup,
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// remove the pod from the API. In the presence of network partitions, this object may still
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// exist after this timestamp, until an administrator or automated process can determine the
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// resource is fully terminated.
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// If not set, graceful deletion of the object has not been requested.
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">//
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// Populated by the system when a graceful deletion is requested.
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// Read-only.
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// +optional
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#a6e22e">DeletionTimestamp&lt;/span> &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">Time&lt;/span> &lt;span style="color:#e6db74">`json:&amp;#34;deletionTimestamp,omitempty&amp;#34; protobuf:&amp;#34;bytes,9,opt,name=deletionTimestamp&amp;#34;`&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// Number of seconds allowed for this object to gracefully terminate before
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// it will be removed from the system. Only set when deletionTimestamp is also set.
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// May only be shortened.
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// Read-only.
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// +optional
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#a6e22e">DeletionGracePeriodSeconds&lt;/span> &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#66d9ef">int64&lt;/span> &lt;span style="color:#e6db74">`json:&amp;#34;deletionGracePeriodSeconds,omitempty&amp;#34; protobuf:&amp;#34;varint,10,opt,name=deletionGracePeriodSeconds&amp;#34;`&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// Must be empty before the object is deleted from the registry. Each entry
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// is an identifier for the responsible component that will remove the entry
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// from the list. If the deletionTimestamp of the object is non-nil, entries
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// in this list can only be removed.
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// Finalizers may be processed and removed in any order. Order is NOT enforced
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// because it introduces significant risk of stuck finalizers.
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// finalizers is a shared field, any actor with permission can reorder it.
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// If the finalizer list is processed in order, then this can lead to a situation
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// in which the component responsible for the first finalizer in the list is
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// waiting for a signal (field value, external system, or other) produced by a
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// component responsible for a finalizer later in the list, resulting in a deadlock.
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// Without enforced ordering finalizers are free to order amongst themselves and
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// are not vulnerable to ordering changes in the list.
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// +optional
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// +patchStrategy=merge
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#a6e22e">Finalizers&lt;/span> []&lt;span style="color:#66d9ef">string&lt;/span> &lt;span style="color:#e6db74">`json:&amp;#34;finalizers,omitempty&amp;#34; patchStrategy:&amp;#34;merge&amp;#34; protobuf:&amp;#34;bytes,14,rep,name=finalizers&amp;#34;`&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="在-operator-中的应用">在 Operator 中的应用&lt;/h2>
&lt;p>知道了 Finalizers 是什么，那么当然也要知道怎么用 Finalizers 了。在实际开发 Operator 时，删除前（Pre-delete）回调是一个比较常见的功能，用于处理一些在资源删除前需要处理的逻辑，如：关联资源释放、释放资源通知、相关数据清理，甚至是阻止资源删除。一般 Finalizers 的处理也是会 Reconcile 中实现的，下面就使用 chaosblade-operator[2] 中的源码，简单介绍一些 Finalizers 的使用方式。&lt;/p>
&lt;p>首先要了解的是 ChaosBlade-Operator 的工作原理：每个实验都会以 CR 的形式部署到 k8s 集群中，之后由 chaosblade-operator 来操作以 DaemonSet 形式部署 chaosblade-tool 对具体资源进行混沌实验。停止实验只需删除对应 CR 即可，在删除 CR 时，首先会执行一遍实验恢复逻辑，之后才会将 CR 删除。但如果恢复实验失败，则会将 CR 的 Phase 设置为 Destroying，而在 Reconcile 中观测到 Phase 状态为 Destroying 或者 metadata.deletionTimestamp 不为空时，就会不会移除 finalizers 中的拦截器名称，阻止该 CR 被删除。&lt;/p>
&lt;p>这样设计的目的是为了在实验恢复失败后，让用户去主动查看实验恢复失败原因，如果是一些意外原因导致的实验恢复失败，及时去处理。在确认原因后，可使用 CLI 工具增加 &amp;ndash;force-remove 进去强制删除，项目维护者在 Issue#368[3] 中也就这个设计给出了解答。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// pkg/controller/chaosblade/controller.go 部分源码
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#f92672">...&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">const&lt;/span> &lt;span style="color:#a6e22e">chaosbladeFinalizer&lt;/span> = &lt;span style="color:#e6db74">&amp;#34;finalizer.chaosblade.io&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">...&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">func&lt;/span> (&lt;span style="color:#a6e22e">r&lt;/span> &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">ReconcileChaosBlade&lt;/span>) &lt;span style="color:#a6e22e">Reconcile&lt;/span>(&lt;span style="color:#a6e22e">request&lt;/span> &lt;span style="color:#a6e22e">reconcile&lt;/span>.&lt;span style="color:#a6e22e">Request&lt;/span>) (&lt;span style="color:#a6e22e">reconcile&lt;/span>.&lt;span style="color:#a6e22e">Result&lt;/span>, &lt;span style="color:#66d9ef">error&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">reqLogger&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">logrus&lt;/span>.&lt;span style="color:#a6e22e">WithField&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;Request.Name&amp;#34;&lt;/span>, &lt;span style="color:#a6e22e">request&lt;/span>.&lt;span style="color:#a6e22e">Name&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">forget&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">reconcile&lt;/span>.&lt;span style="color:#a6e22e">Result&lt;/span>{}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// Fetch the RC instance
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#a6e22e">cb&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#f92672">&amp;amp;&lt;/span>&lt;span style="color:#a6e22e">v1alpha1&lt;/span>.&lt;span style="color:#a6e22e">ChaosBlade&lt;/span>{}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">err&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">r&lt;/span>.&lt;span style="color:#a6e22e">client&lt;/span>.&lt;span style="color:#a6e22e">Get&lt;/span>(&lt;span style="color:#a6e22e">context&lt;/span>.&lt;span style="color:#a6e22e">TODO&lt;/span>(), &lt;span style="color:#a6e22e">request&lt;/span>.&lt;span style="color:#a6e22e">NamespacedName&lt;/span>, &lt;span style="color:#a6e22e">cb&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> &lt;span style="color:#a6e22e">err&lt;/span> &lt;span style="color:#f92672">!=&lt;/span> &lt;span style="color:#66d9ef">nil&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#a6e22e">forget&lt;/span>, &lt;span style="color:#66d9ef">nil&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> len(&lt;span style="color:#a6e22e">cb&lt;/span>.&lt;span style="color:#a6e22e">Spec&lt;/span>.&lt;span style="color:#a6e22e">Experiments&lt;/span>) &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#a6e22e">forget&lt;/span>, &lt;span style="color:#66d9ef">nil&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// Destroyed-&amp;gt;delete
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#75715e">// Remove the Finalizer if the CR object status is destroyed to delete it
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">if&lt;/span> &lt;span style="color:#a6e22e">cb&lt;/span>.&lt;span style="color:#a6e22e">Status&lt;/span>.&lt;span style="color:#a6e22e">Phase&lt;/span> &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#a6e22e">v1alpha1&lt;/span>.&lt;span style="color:#a6e22e">ClusterPhaseDestroyed&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">cb&lt;/span>.&lt;span style="color:#a6e22e">SetFinalizers&lt;/span>(&lt;span style="color:#a6e22e">remove&lt;/span>(&lt;span style="color:#a6e22e">cb&lt;/span>.&lt;span style="color:#a6e22e">GetFinalizers&lt;/span>(), &lt;span style="color:#a6e22e">chaosbladeFinalizer&lt;/span>))
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">err&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">r&lt;/span>.&lt;span style="color:#a6e22e">client&lt;/span>.&lt;span style="color:#a6e22e">Update&lt;/span>(&lt;span style="color:#a6e22e">context&lt;/span>.&lt;span style="color:#a6e22e">TODO&lt;/span>(), &lt;span style="color:#a6e22e">cb&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> &lt;span style="color:#a6e22e">err&lt;/span> &lt;span style="color:#f92672">!=&lt;/span> &lt;span style="color:#66d9ef">nil&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">reqLogger&lt;/span>.&lt;span style="color:#a6e22e">WithError&lt;/span>(&lt;span style="color:#a6e22e">err&lt;/span>).&lt;span style="color:#a6e22e">Errorln&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;remove chaosblade finalizer failed at destroyed phase&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#a6e22e">forget&lt;/span>, &lt;span style="color:#66d9ef">nil&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> &lt;span style="color:#a6e22e">cb&lt;/span>.&lt;span style="color:#a6e22e">Status&lt;/span>.&lt;span style="color:#a6e22e">Phase&lt;/span> &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#a6e22e">v1alpha1&lt;/span>.&lt;span style="color:#a6e22e">ClusterPhaseDestroying&lt;/span> &lt;span style="color:#f92672">||&lt;/span> &lt;span style="color:#a6e22e">cb&lt;/span>.&lt;span style="color:#a6e22e">GetDeletionTimestamp&lt;/span>() &lt;span style="color:#f92672">!=&lt;/span> &lt;span style="color:#66d9ef">nil&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">err&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">r&lt;/span>.&lt;span style="color:#a6e22e">finalizeChaosBlade&lt;/span>(&lt;span style="color:#a6e22e">reqLogger&lt;/span>, &lt;span style="color:#a6e22e">cb&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> &lt;span style="color:#a6e22e">err&lt;/span> &lt;span style="color:#f92672">!=&lt;/span> &lt;span style="color:#66d9ef">nil&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">reqLogger&lt;/span>.&lt;span style="color:#a6e22e">WithError&lt;/span>(&lt;span style="color:#a6e22e">err&lt;/span>).&lt;span style="color:#a6e22e">Errorln&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;finalize chaosblade failed at destroying phase&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#a6e22e">forget&lt;/span>, &lt;span style="color:#66d9ef">nil&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">...&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#a6e22e">forget&lt;/span>, &lt;span style="color:#66d9ef">nil&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>如果 Phase 状态为 Destroyed，则从 Finalizers 中移除 finalizer.chaosblade.io，之后正常删除 CR。&lt;/p>
&lt;p>[1] Meta: &lt;a href="https://github.com/kubernetes/apimachinery/blob/master/pkg/apis/meta/v1/types.go#L246">https://github.com/kubernetes/apimachinery/blob/master/pkg/apis/meta/v1/types.go#L246&lt;/a>&lt;/p>
&lt;p>[2] chaosblade-operator: &lt;a href="https://github.com/chaosblade-io/chaosblade-operator">https://github.com/chaosblade-io/chaosblade-operator&lt;/a>&lt;/p>
&lt;p>[3] Issue#368: &lt;a href="https://github.com/chaosblade-io/chaosblade/issues/368">https://github.com/chaosblade-io/chaosblade/issues/368&lt;/a>&lt;/p>
&lt;h1 id="finalizers-字段的处理">finalizers 字段的处理&lt;/h1>
&lt;p>快速清空对象中的 finalizers 字段&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>kubectl get namespace test -o json &lt;span style="color:#ae81ff">\
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">&lt;/span> | tr -d &lt;span style="color:#e6db74">&amp;#34;\n&amp;#34;&lt;/span> | sed &lt;span style="color:#e6db74">&amp;#34;s/\&amp;#34;finalizers\&amp;#34;: \[[^]]\+\]/\&amp;#34;finalizers\&amp;#34;: []/&amp;#34;&lt;/span> &lt;span style="color:#ae81ff">\
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">&lt;/span> | kubectl replace --raw /api/v1/namespaces/test/finalize -f -
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div></description></item><item><title>Docs: Garbage Collection(垃圾收集)</title><link>https://desistdaydream.github.io/docs/IT%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/10.%E4%BA%91%E5%8E%9F%E7%94%9F/2.3.Kubernetes-%E5%AE%B9%E5%99%A8%E7%BC%96%E6%8E%92%E7%B3%BB%E7%BB%9F/4.Controller%E6%8E%A7%E5%88%B6%E5%99%A8/Garbage-Collection%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86/Garbage-Collection%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/IT%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/10.%E4%BA%91%E5%8E%9F%E7%94%9F/2.3.Kubernetes-%E5%AE%B9%E5%99%A8%E7%BC%96%E6%8E%92%E7%B3%BB%E7%BB%9F/4.Controller%E6%8E%A7%E5%88%B6%E5%99%A8/Garbage-Collection%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86/Garbage-Collection%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://kubernetes.io/docs/concepts/architecture/garbage-collection/">官方文档，概念-Kubernetes 架构-垃圾收集&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://lib.jimmysong.io/kubernetes-handbook/concepts/garbage-collection/">宋净超-云原生资料库-Kubernetes 基础教程，集群资源管理-垃圾收集&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>&lt;strong>Garbage Collection(垃圾收集)&lt;/strong> 功能用来删除曾经拥有 owner(拥有者) 但不再拥有 owner 的某些对象。&lt;/p>
&lt;p>比如张三拥有 100 块钱，则张三就是这 100 块钱的 owner，当张三死亡后，那么这 100 块钱则不再具有 owner。&lt;/p>
&lt;p>注意：垃圾收集是 beta 特性，在 Kubernetes 1.4 及以上版本默认启用。&lt;/p>
&lt;h2 id="garbage-collector-垃圾收集器">Garbage Collector 垃圾收集器&lt;/h2>
&lt;p>Garbage Collector 是 k8s 垃圾收集功能的具体实现。Garbage Collector 属于 Kubernetes Controller 的一部分。kube-controller-manager 的 &lt;code>--controllers&lt;/code> 命令行标志的值中包含 garbagecollector，用以控制是否启用该控制器。&lt;/p>
&lt;p>垃圾收集器在 kubernetes 的代码中的位置在这里：&lt;a href="https://github.com/kubernetes/kubernetes/tree/master/pkg/controller/garbagecollector">pkg/controller/garbagecollector&lt;/a>。&lt;/p>
&lt;h1 id="owner-和-dependent">Owner 和 Dependent&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://kubernetes.io/docs/concepts/overview/working-with-objects/owners-dependents/">官方文档，概念-概述-使用 Kubernetes 对象-属主与从属&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>在 Kubernetes 中&lt;/p>
&lt;ul>
&lt;li>&lt;strong>Owner(拥有者/属主)&lt;/strong> # 一些 Kubernetes 对象是其它对象的 Owner。例如，一个 Deployment 是一组 Pod 的 Owner(i.e.deployment 拥有这些 pod)。&lt;/li>
&lt;li>&lt;strong>Dependent(依赖他人者/从属)&lt;/strong> # 被 Owner 拥有的对象被称 Dependent(从属) 对象，该 Dependent 属于该 Owner。&lt;/li>
&lt;/ul>
&lt;p>每个 Dependent 对象具有一个指向其 owner 对象的 metadata.ownerReferences 字段。&lt;/p>
&lt;p>有时，Kubernetes 会自动设置 ownerReference 的值。例如，当创建一个 ReplicaSet 时，Kubernetes 自动设置 ReplicaSet 中每个 Pod 的 ownerReference 字段值。在 1.6 版本，Kubernetes 会自动为一些对象设置 ownerReference 的值，这些对象是由 ReplicationController、ReplicaSet、StatefulSet、DaemonSet 和 Deployment 所创建或管理。&lt;/p>
&lt;p>也可以通过手动设置 ownerReference 的值，来指定 Owner 和 Dependent 之间的关系。&lt;/p>
&lt;p>下面的配置文件，表示一个具有 3 个 Pod 的 ReplicaSet：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-yaml" data-lang="yaml">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">apiVersion&lt;/span>: &lt;span style="color:#ae81ff">extensions/v1beta1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">kind&lt;/span>: &lt;span style="color:#ae81ff">ReplicaSet&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">metadata&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">name&lt;/span>: &lt;span style="color:#ae81ff">my-repset&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">spec&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">replicas&lt;/span>: &lt;span style="color:#ae81ff">3&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">selector&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">matchLabels&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">pod-is-for&lt;/span>: &lt;span style="color:#ae81ff">garbage-collection-example&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">template&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">metadata&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">labels&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">pod-is-for&lt;/span>: &lt;span style="color:#ae81ff">garbage-collection-example&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">spec&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">containers&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#f92672">name&lt;/span>: &lt;span style="color:#ae81ff">nginx&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">image&lt;/span>: &lt;span style="color:#ae81ff">nginx&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>如果创建该 ReplicaSet，然后查看 Pod 的 metadata 字段，能够看到 OwnerReferences 字段：&lt;/p>
&lt;pre>&lt;code>kubectl create -f https://k8s.io/docs/concepts/abstractions/controllers/my-repset.yaml
kubectl get pods --output=yaml
&lt;/code>&lt;/pre>
&lt;p>输出显示了 Pod 的 Owner 是名为 my-repset 的 ReplicaSet：&lt;/p>
&lt;pre>&lt;code>apiVersion: v1
kind: Pod
metadata:
...
ownerReferences:
- apiVersion: extensions/v1beta1
controller: true
blockOwnerDeletion: true
kind: ReplicaSet
name: my-repset
uid: d9607e19-f88f-11e6-a518-42010a800195
...
&lt;/code>&lt;/pre>
&lt;h1 id="垃圾收集器删除-dependent-的方式">垃圾收集器删除 Dependent 的方式&lt;/h1>
&lt;p>当删除对象时，可以指定是否该对象的 Dependent 也自动删除掉。自动删除 Dependent 的行为称为 &lt;strong>Cascading Deletion(级联删除)&lt;/strong>。Kubernetes 中有两种级联删除的模式：&lt;strong>Background(后台) 模式&lt;/strong>和 &lt;strong>Foreground(前台) 模式&lt;/strong>。&lt;/p>
&lt;p>如果删除对象时，不自动删除它的 Dependent，这些 Dependent 被称为 orphaned(孤立) 对象。&lt;/p>
&lt;h2 id="foreground前台-级联删除">Foreground(前台) 级联删除&lt;/h2>
&lt;p>在 foreground 级联删除 模式下，根对象首先进入 “deletion in progress(删除中)” 状态。在该状态时会有如下的情况：&lt;/p>
&lt;ul>
&lt;li>对象仍然可以通过 REST API 可见&lt;/li>
&lt;li>会设置对象的 deletionTimestamp 字段&lt;/li>
&lt;li>对象的 metadata.finalizers 字段包含了值 foregroundDeletion&lt;/li>
&lt;/ul>
&lt;p>一旦被设置为 deletion in progress 状态，垃圾收集器会删除对象的所有 Dependent。垃圾收集器删除了所有 “Blocking” 的 Dependent（对象的 ownerReference.blockOwnerDeletion=true）之后，它会删除 Owner 对象。&lt;/p>
&lt;p>注意，在 “foreground 删除” 模式下，Dependent 只有通过 ownerReference.blockOwnerDeletion 才能阻止删除 Owner 对象。在 Kubernetes 1.7 版本中将增加 admission controller，基于 Owner 对象上的删除权限来控制用户去设置 blockOwnerDeletion 的值为 true，所以未授权的 Dependent 不能够延迟 Owner 对象的删除。&lt;/p>
&lt;p>如果一个对象的 ownerReferences 字段被一个 Controller（例如 Deployment 或 ReplicaSet）设置，blockOwnerDeletion 会被自动设置，没必要手动修改这个字段。&lt;/p>
&lt;h2 id="background后台-级联删除">Background(后台) 级联删除&lt;/h2>
&lt;p>在 background 级联删除 模式下，Kubernetes 会立即删除 Owner 对象，然后垃圾收集器会在后台删除这些 Dependent。&lt;/p>
&lt;h2 id="设置级联删除策略">设置级联删除策略&lt;/h2>
&lt;p>通过为 Owner 对象设置 deleteOptions.propagationPolicy 字段，可以控制级联删除策略。可能的取值包括：“orphan”、“Foreground” 或 “Background”。&lt;/p>
&lt;p>对很多 Controller 资源，包括 ReplicationController、ReplicaSet、StatefulSet、DaemonSet 和 Deployment，默认的垃圾收集策略是 orphan。因此，除非指定其它的垃圾收集策略，否则所有 Dependent 对象使用的都是 orphan 策略。&lt;/p>
&lt;p>注意：本段所指的默认值是指 REST API 的默认值，并非 kubectl 命令的默认值，kubectl 默认为级联删除，后面会讲到。&lt;/p>
&lt;p>下面是一个在后台删除 Dependent 对象的例子：&lt;/p>
&lt;pre>&lt;code>kubectl proxy --port=8080
curl -X DELETE localhost:8080/apis/extensions/v1beta1/namespaces/default/replicasets/my-repset \
-d '{&amp;quot;kind&amp;quot;:&amp;quot;DeleteOptions&amp;quot;,&amp;quot;apiVersion&amp;quot;:&amp;quot;v1&amp;quot;,&amp;quot;propagationPolicy&amp;quot;:&amp;quot;Background&amp;quot;}' \
-H &amp;quot;Content-Type: application/json&amp;quot;
&lt;/code>&lt;/pre>
&lt;p>下面是一个在前台删除 Dependent 对象的例子：&lt;/p>
&lt;pre>&lt;code>kubectl proxy --port=8080
curl -X DELETE localhost:8080/apis/extensions/v1beta1/namespaces/default/replicasets/my-repset \
-d '{&amp;quot;kind&amp;quot;:&amp;quot;DeleteOptions&amp;quot;,&amp;quot;apiVersion&amp;quot;:&amp;quot;v1&amp;quot;,&amp;quot;propagationPolicy&amp;quot;:&amp;quot;Foreground&amp;quot;}' \
-H &amp;quot;Content-Type: application/json&amp;quot;
&lt;/code>&lt;/pre>
&lt;p>下面是一个孤儿 Dependent 的例子：&lt;/p>
&lt;pre>&lt;code>kubectl proxy --port=8080
curl -X DELETE localhost:8080/apis/extensions/v1beta1/namespaces/default/replicasets/my-repset \
-d '{&amp;quot;kind&amp;quot;:&amp;quot;DeleteOptions&amp;quot;,&amp;quot;apiVersion&amp;quot;:&amp;quot;v1&amp;quot;,&amp;quot;propagationPolicy&amp;quot;:&amp;quot;Orphan&amp;quot;}' \
-H &amp;quot;Content-Type: application/json&amp;quot;
&lt;/code>&lt;/pre>
&lt;p>kubectl 也支持级联删除。 通过设置 &amp;ndash;cascade 为 true，可以使用 kubectl 自动删除 Dependent 对象。设置 &amp;ndash;cascade 为 false，会使 Dependent 对象成为孤儿 Dependent 对象。&amp;ndash;cascade 的默认值是 true。&lt;/p>
&lt;p>下面是一个例子，使一个 ReplicaSet 的 Dependent 对象成为孤立 Dependent：&lt;/p>
&lt;pre>&lt;code>kubectl delete replicaset my-repset --cascade=false
&lt;/code>&lt;/pre></description></item></channel></rss>