<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>断念梦 – Keepalived</title><link>https://desistdaydream.github.io/docs/IT%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/3.%E9%9B%86%E7%BE%A4%E4%B8%8E%E5%88%86%E5%B8%83%E5%BC%8F/Keepalived/</link><description>Recent content in Keepalived on 断念梦</description><generator>Hugo -- gohugo.io</generator><atom:link href="https://desistdaydream.github.io/docs/IT%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/3.%E9%9B%86%E7%BE%A4%E4%B8%8E%E5%88%86%E5%B8%83%E5%BC%8F/Keepalived/index.xml" rel="self" type="application/rss+xml"/><item><title>Docs: Keepalived 介绍</title><link>https://desistdaydream.github.io/docs/IT%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/3.%E9%9B%86%E7%BE%A4%E4%B8%8E%E5%88%86%E5%B8%83%E5%BC%8F/Keepalived/1.1.Keepalived-%E4%BB%8B%E7%BB%8D/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/IT%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/3.%E9%9B%86%E7%BE%A4%E4%B8%8E%E5%88%86%E5%B8%83%E5%BC%8F/Keepalived/1.1.Keepalived-%E4%BB%8B%E7%BB%8D/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="http://www.keepalived.org/">官网&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>Keepalived 特点：&lt;/p>
&lt;ul>
&lt;li>Active/passive 模式&lt;/li>
&lt;li>Keepalived 是 vrrp 协议在 Linux 主机上以守护进程方式的实现&lt;/li>
&lt;li>能够根据配置文件自动生成 ipvs 规则&lt;/li>
&lt;li>对各 RS 做健康状态检测&lt;/li>
&lt;/ul>
&lt;h1 id="万字长文带你从-0-学习-keepalived">万字长文带你从 0 学习 Keepalived&lt;/h1>
&lt;p>负载均衡器（Load Balancer, LB ）是一组能够将 IP 数据流以负载均衡形式转发到多台物理服务器的集成软件。有硬件负载均衡器和软件负载均衡器之分，硬件负载均衡器主要是在访问网络和服务器之间配置物理负载均衡设备，客户端对物理服务器的访问请求首先会抵达负载均衡设备，然后再由负载均衡设备根据一定的负载算法转发到后端服务器。相比而言，软件负载均衡器不需要特定的物理设备，只需在相应的操作系统上部署具有负载均衡功能的软件即可。&lt;/p>
&lt;p>在 Openstack 高可用集群部署中，服务的负载均衡和高可用主要有两种主流的实现方案，即 HAProxy+ Keepalived 和 Pacemaker+HAProxy 方案。由于 OpenStack 服务组件多样，不同服务均需要进行特定的高可用设计，并且从集群资源统一调度和集群稳定性的角度考虑，后一种方案是多数 OpenStack 厂商的高可用部署方案首选，但是选用后一方案并不意味着 Keepalived 在 OpenStack 高可用集群部署中不被使用。由于 Keepalived 的主要作用之一是进行虚拟路由的故障切换，其在 Neutron 的 L3 高可用设计与实现中起着举足轻重的作用。&lt;/p>
&lt;h1 id="11-keepalived-及-lvs-概述">1.1 keepalived 及 LVS 概述&lt;/h1>
&lt;p>Keepalived 的项目实现的主要目标是简化 LVS 项目的配置并增强其稳定性，即 Keepalived 是对 LVS 项目的扩展增强。&lt;/p>
&lt;p>Keepalived 为 Linux 系统和基于 Linux 的架构提供了负载均衡和高可用能力，其负载均衡功能主要源自集成在 Linux 内核中的 LVS 项目模块 IPVS( IP Virtual Server ），基于 IPVS 提供的 4 层 TCP/IP 协议负载均衡， Keepalived 也具备负载均衡的功能，此外， Keepalived 还实现了基于多层 TCP/IP 协议（ 3 层、4 层、5/7 层）的健康检查机制，因此， Keepalived 在 LVS 负载均衡功能的基础上，还提供了 LVS 集群物理服务器池健康检查和故障节点隔离的功能。&lt;/p>
&lt;p>除了扩展 LVS 的负载均衡服务器健康检查能力， Keepalived 还基于虚拟路由冗余协议（ Virtual Route Redundancy Protocol, VRRP )实现了 LVS 负载均衡服务器的故障切换转移，即 Keepalived 还实现了 LVS 负载均衡器的高可用性。Keepalived 就是为 LVS 集群节点提供健康检查和为 LVS 负载均衡服务器提供故障切换的用户空间进程。&lt;/p>
&lt;p>图为 Keepalived 的原理架构图，从图中可以看到， Keepalived 的多数核心功能模块均位于用户空间，而仅有 IPVS 和 NETLINK 模块位于内核空间，但是这两个内核模块正是 Keepalived 实现负载均衡和路由高可用的核心模块，其中的 NETLINK 主要用于提供高级路由及其相关的网络功能。Keepalived 的大部分功能模块位于用户空间，其中几个核心功能模块的介绍如下。&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/watgs2/1616132514380-d0730061-c06c-433e-8b33-8868d6966373.jpeg" alt="">&lt;/p>
&lt;ul>
&lt;li>WatchDog ：其主要负责监控 Checkers 和 VRRP 子进程的运行状况。&lt;/li>
&lt;li>Checkers ：此功能模块主要负责真实服务器的健康检查（ HealthChecking )，是 Keepalived 最主要的功能之一，因为 HealthChecking 是负载均衡功能稳定运行的基础， LVS 集群节点的故障隔离和重新加入均依赖于 HealthChecking 的结果。&lt;/li>
&lt;li>VRRPStack ：此功能模块主要负责负载均衡器之间的故障切换，如果集群架构中仅使用一个 LVS 负载均衡器，由于本身不具备故障切换的条件，则 VRRPStack 不是必须的。&lt;/li>
&lt;li>IPVS Wrapper ：此模块主要用来发送设定的规则到内核 IPVS 代码。Keepalived 的设计目标是构建高可用的 LVS 负载均衡群集， Keepalived 在运行中将会通过 IPVSWrapper 模块调用 IPVSAdmin 工具来创建虚拟服务器，检查和管理 LVS 集群物理服务器池。&lt;/li>
&lt;li>Netlink Reflector ：此功能模块主要用来设定 VRRP 的 VIP 地址并提供相关的网络功能，该模块通过与内核中的 NETLINK 模块交互，从而为 Keepalived 提供路由高可用功能。&lt;/li>
&lt;/ul>
&lt;p>从 Keepalived 的实现原理和功能来看， Keepalived 是开源负载均衡项目 LVS 的增强和虚拟路由协议 VRRP 实现的集合，即 Keepalived 通过整合和增强 LVS 与 VRRP 来提供高可用的负载均衡系统架构。&lt;/p>
&lt;h1 id="12-keepalived-工作原理">1.2 KeepAlived 工作原理&lt;/h1>
&lt;p>Keepalived 本质上是提供数据流转发与服务器健康检查并具备故障切换的高可用路由，而数据转发与健康检查是对 LVS 功能的扩展和增强，因此也可以认为 Keepalived 是运行在用户空间的 LVS 路由（LVS Router) 进程。在实际应用中， Keepalived 通常部署在两台主备或一主多备的服务器上，即 Keepalived 进程既运行在 Active/Master 状态的 LVS Router 中，也运行在 Passive/Slave 状态的 LVS Router 中，而所有运行 Keepalived 进程的 LVS Router 都遵循虚拟路由冗余协议 VRRP。在 VRRP 的协议框架下，作为 Master 的 Router 将会处理两个主要任务，即转发客户端访问请求到后端物理服务器以进行负载均衡和周期性的发送 VRRP 协议报文，而作为 Slave 的 Routers 则负责接收 VRRP 报文，如果某一时刻作为 Slave 的 Routers 接收 VRRP 报文失败，则认为 Master Router 故障， 并从 Slave Routers 中重新选举产生一个新的 Master Router 。&lt;/p>
&lt;p>Keepalived 是一个与 LVS Router 相关的控制进程，在 RHEL7 /Centos7 系统中，Keepalived 由 Systemctl 命令通过读取/etc/keepalived/keepalived.conf 配置文件来启动。在遵循 VRRP 协议的 Master Router 中， Keepalived 进程会启动内核中的 LVS 服务以创建虚拟服务器，并根据配置拓扑对服务运行状况进行监控。此外，Master Router 还会向 Slave Routers 发送周期性的 VRRP 广播报文，而 Master Router 运行状态的正常与否是由 Slave Routers 上的 VRRP 实例决定的。如果在用户预置的时间段内 Slave Router 不能接收到 VRRP 报文，则 Keepalived 认为 Master Router 故障，同时触发 LVS Router 的 Failover 操作。&lt;/p>
&lt;p>在 Failover 的过程中， Keepalived 创建的虚拟服务器会被清除，新的 Master Router 将接管 VIP 发送 ARP 信息、设置 IPVS Table 记录条目（Virtual Server）以及物理服务器的健康检查和发送 VRRP 广播报文。Keepalived 的 Failover 操作针对的是四层 TCP/ IP 协议，即传输层，因为 TCP 在传输层上进行的是基于链路连接的数据传输。所以，当服务器在响应 TCP 请求时，如果出现设置时间段的 Timeout，则 Keepalived 的健康检查机制将会监测到该情况并认为该服务器故障，然后将其从服务器池中移除（故障服务器隔离） 。图 3-4 是基于 Keepalived 设计的具有二层拓扑的负载均衡架构，该架构分为两个层次。第一层为负载均衡层，由一个 Active 和多个 Backup 的 LVS Routers 组成，其中，每个 LVS Router 都配置有两个网络接口，一个接入 Internet 网络，另一个接入内部私有网络， Active 的 LVS Router 在这两个网络接口间进行数据转发。在图 3-4 的负载均衡架构中，位于第一层的 LVS Routers 和第二层的物理服务器通过私网接口接人相同的局域网中， Active 的 LVSRouter 通过 NAT 技术将 Internet 数据流转发到私网物理服务器上，而这些位于第二层的物理服务器运行着最终响应请求的服务。&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/watgs2/1616132514345-97aedaa2-8dd5-40fa-a7bb-79f9c9fa0ac6.jpeg" alt="">&lt;/p>
&lt;p>位于二层私网中的服务器在与 Internet 交互时必须经过主 LVS Router 的 NAT 转发， 并且对于外部网络中的客户端而言，访问二层私网中的物理服务器就如访问同处 Internet 网络中的服务，因为从客户端的角度来看，访问请求的目的地址正是位于主 LVS Router 上的 VIP 地址，而该 VIP 与客户端地址处于相同网络中， VIP 还可以是管理员指定的互联网域名，如www.example.com 。VIP 在 Keepalived 的配置中通常被指定到一个或者多个虚拟服务器上，而虚拟服务器的主要任务便是监昕 VIP 及相应端口上的请求，当主 LVS Router 进行 Failover 操作的时候， VIP 会从一个 LVS Router 转移到另一个 LVS（因此 VIP 也称为浮动 IP)。&lt;/p>
&lt;p>在 Keepalived 负载均衡架构的 VIP 配置中，每个将 LVS Router 连接到 Internet 的物理网卡接口均可配置多个 VIP ，并且每个 VIP 对应着不同的 Virtual Server ，即多个 VirtualServers 可以同时监听相同物理网卡上的不同 VIP ，其中每个 VIP 都对应着不同的服务。例如， Linux 系统中的接口 eth0 将 LVS Router 连接到 Internet 中，则可以在 eth0 上配置一个地址为 192.168.115.100 的 VIP 以用于响应 HTTP 服务请求，同时还可以在 eth0 上配置另一个地址为 192.168.115.200 的 VIP 以用于响应 FTP 服务请求。在这里， HTTP 服务和 FTP 服务均对应着监听不同 VIP 的 Virtual Server 。在由一个 Active Router 和一个 Backup Router 组成的 Keepalived 负载均衡架构中， Active Router 的主要任务就是将 VIP 上的请求转发到选中的某个后端服务器上，具体服务器的选举机制则由 Keepalived 所支持的负载均衡算法来决定。&lt;/p>
&lt;p>此外， Active Router 还负责动态监控后端服务器上特定服务的健康状况，监控方式主要是 Keepalived 自带的三种健康检测机制，即简单 TCP 连接、HTTP 和 HTTPS。就简单 TCP 连接检测方式， Active Router 会周期性地对服务器上某个特定端口进行 TCP 连接，如果 TCP 连接超时或者中断则认为服务不可用，而对于 HTTP 和 HTTPS 检测方式， ActiveRouter 通过周期性地抓取（ Fetch ）请求 URL 并验证其内容来判断服务的可用性。与此同时， Backup Router 一直处于 Standby 状态， LVS router 的 Failover 由 VRRP 来处理。&lt;/p>
&lt;p>在 Keepalived 进程启动的时候，所有 LVS Routers 会加人一个用来接收和发送 VRRP 广播的多播组， 由于 VRRP 是一种基于优先级的协议，因此在启动之初优先级高的 LVS Router 会被选举为 Master Router ，而 Master Router 将会周期性地向多播组中的成员发送 VRRP 广播。如果多播组中的 Backup Routers 在一定时间内接收 VRRP 广播失败，则重新选举新的 Master Router ，新的 Master Router 将会接管 VIP 并广播地址解析协议（ Address ResolutionProtocol, ARP ）信息。而当故障 Router 重新恢复后，根据该 Router 的优先级情况，其可能恢复到 Master 状态也可能保持为 Backup 状态。&lt;/p>
&lt;p>图中的两层负载均衡架构是最常见的部署环境，主要用于很多数据源变化不是很频繁的数据请求服务中，如静态 Web 页面站点，因为后端独立服务器（Real Severs ）之间不会自动进行数据同步。图 3-5 为基于 Keepalived 的三层负载均衡架构，在三层负载均衡架构中，前端的 LVS Router 负责将访问请求转发到物理服务器（ Real Servers ）中，然后 Real Server 再通过网络形式访问可共享的数据源。&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/watgs2/1616132514381-c261d4f3-8895-48fb-b4c8-ea8a73ab2882.jpeg" alt="">&lt;/p>
&lt;p>对于数据请求比较繁忙的 FTP 站点，三层架构是最为理想的负载均衡架构，在这种架构下，可供访问的数据源集中存储在高可用的集群服务器上， Real Servers 通过 NFS 共享目录或者 Samba 文件共享等网络文件系统形式来访问数据。此外，类似的三层负载均衡架构在需要提供中心化及数据库事务处理高可用的 Web 站点中也被普遍使用，如果将 Keepalived 负载均衡器配置为 Active/Active 双活模式，则还可以将三层负载均衡架构同时用于提供 FTP 和 Web 数据库服务。&lt;/p>
&lt;h1 id="13-keepalived-的负载均衡算法">1.3 KeepAlived 的负载均衡算法&lt;/h1>
&lt;p>Keepalived 所使用的负载均调度机制由集成到内核中的 IPVS 模块提供， IPVS 是 LVS 项目的核心功能模块，其设计的主要目的之一就是解决单 IP 多服务器的工作环境，IPVS 模块使得基于 TCP/IP 传输层（ 第 4 层）的数据交换成为可能。在实际使用中， IPVS 会在内核中创建一个名为 IPVS Table 的表，该表记录了后端服务器的地址及服务运行状态，通过 IPVS Table, Keepalived 便可跟踪并将请求路由到后端物理服务器中， 即 LVS Router 利用此表将来自 Keepalived 虚拟服务器地址的请求转发到后端服务器池中，同时将后端服务器的处理结果转发给客户端。此外， IPVS table 的表结构主要取决于管理员对指定的虚拟服务器所设置的负载均衡算法， Keepalived 支持以下几种负载均衡算法。&lt;/p>
&lt;p>( 1 ) Round-Robin&lt;/p>
&lt;p>即所谓的轮询负载均衡，在这种算法中，服务请求会被依次转发到服务器池中的每一个服务器上，而不去评估服务器的当前负载或者处理能力，服务器池中的每一个服务器都被平等对待。如果使用 Round-Robin 负载均衡算法，每台后端服务器会轮询依次处理服务请求。&lt;/p>
&lt;p>( 2 ) Weighted Round-Robin&lt;/p>
&lt;p>即加权 Round-Robin 算法，是对 Round-Robin 算法的一种扩展。在这种算法中，请求被依次转发到每一台服务器上，但是当前负载较轻或者计算能力较大的服务器会被转发更多的请求，服务器的处理能力通过用户指定的权重因子来决定，权重因子可以根据负载信息动态上调或者下调。如果服务器的配置差别较大，导致不同服务器的处理能力相差较大，则加权的 Round-Robin 算法会是不错的选择，但是如果请求负载频繁变动，则权重较大的服务器可能会超负荷工作。&lt;/p>
&lt;p>( 3 ) Least-Connection&lt;/p>
&lt;p>即最少连接算法，在这种算法中，请求被转发到活动连接较少的服务器上。在 Keepalived 的实际使用中， LVS Router 一直在利用内核中的 IPVS Table 来记录后端服务器的活动连接，从而动态跟踪每个服务器的活动连接数。最少连接数算法是一种动态决策算法，它比较适合服务器池中每个成员的处理能力都大致相当，同时负载请求又频繁变化的场景， 如果不同服务器有不同的处理能力，则下面的加权最少连接数算法较为合适。&lt;/p>
&lt;p>( 4 ) Weighted Least-Connections&lt;/p>
&lt;p>即加权最少连接数算法，在这种算法中，路由会根据服务器的权重，转发更多的请求到连接数较少的服务器上。服务器的处理能力通过用户指定的权重因子来决定，权重因子可以根据负载信息动态上调或者下调。一般来说，服务器加权算法主要用于集群存在不同类型服务器，而服务器配置和处理能力相差较大的场景中。&lt;/p>
&lt;p>( 5) Destination Hash ScheduIing&lt;/p>
&lt;p>即目标地址哈希算法，通过在静态 Hash 表中查询目的 IP 地址来确定请求要转发的服务器，这类算法主要用于缓存代理服务器集群中。&lt;/p>
&lt;p>( 6 ) Source Hash Scheduling&lt;/p>
&lt;p>即源地址哈希算法，通过在静态 Hash 表中查询源 IP 地址来确定请求要转发的服务器，这类算法主要应用于存在多防火墙的 LVS Router 中。&lt;/p>
&lt;p>( 7 ) Shortest Expected Delay&lt;/p>
&lt;p>即最小延时算法，在这种算法中，请求被转发到具有最小连接响应延时的服务器上。&lt;/p>
&lt;h1 id="14-keepalived-路由方式">1.4 Keepalived 路由方式&lt;/h1>
&lt;p>（1） NAT&lt;/p>
&lt;p>图 3-6 为基于 NAT 路由实现的 Keepalived 负载均衡器，在 NAT 机制下，每个 LVS Router 需要两个网络接口。假设 eth0 为接人 Internet 的网络接口，则 eth0 上配置有一个真实的 IP 地址，同时还配置了一个浮动 IP 地址（Floating IP ）假设 eth1 为接入后端私有网络的接口， 则 eth1 上也配置有一个真实 IP 地址和一个浮动 IP 地址。在出现故障切换 Failover 的时候， 接人 Internet 的虚拟接口和接入私有网络的虚拟接口会同时切换到 Backup 的 LVSRouter 上，而为了不影响对 Internet 客户端的请求响应，位于私有网络中的后端服务器均使用 NAT 路由的浮动 IP 作为与主 LVS Router 通信的默认路由。&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/watgs2/1616132514427-959ff4e7-b87e-4b5f-a914-d6b110653af9.jpeg" alt="">&lt;/p>
&lt;p>对外提供服务的公有 VIP(Public Virtual IP Address ）和私有 NAT VIP(NAT Virtual IP Address）均被配置在物理网卡上而最佳的配置方式是将两个 VIP 各自配置到不同的物理网卡上，即在这种配置下，每个 LVS Router 节点最多只需两个物理网卡。在 NAT 路由转发中，主 LVS Router 负责接收请求，并将请求的目的地址替换成 LVS Router 的 NAT Virtual IP 地址，再将其转发到选中的后端服务器上，同时服务器处理后的应答数据也通过 LVS Router 将其地址替换成 LVS Router 的 Public Virtual IP 地址，然后再转发给 Internet 客户端，这个过程也称为 IP 伪装，因为对客户端而言，服务器的真实 IP 地址已被隐藏。&lt;/p>
&lt;p>在 NAT 路由实现的负载均衡中，后端服务器上可以运行各种操作系统，即后端服务器上的操作系统类型并不影响 LVS Router 的 NAT 路由功能，但是，使用 NAT 路由方式存在的一个缺点是， LVS Router 在大规模集群部署中可能会是一个瓶颈，因为 LVS Router 要同时负责进出双向数据流的 IP 地址替换。&lt;/p>
&lt;p>（2） DR&lt;/p>
&lt;p>相对于其他的负载均衡网络拓扑， DR(Direct Routing）路由方式为基于 Keepalived 的负载均衡系统提供了更高的网络性能， DR 路由方式允许后端服务器直接将处理后的应答数据返回给客户端，而无需经过 LVS Router 的处理操作，DR 路由方案极大降低了 LVS Router 造成网络瓶颈的可能性。如图 3-7 所示。在基于 Keepalived 的负载均衡架构中， Keepalived 的最佳路由方式是 DR 路由，即在配置 Keepalived 的路由方式时，优先将其设置为 DR 。&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/watgs2/1616132514433-6d061a2c-ec2a-43ea-a749-4acef265787f.jpeg" alt="">&lt;/p></description></item><item><title>Docs: Keepalived 配置示例</title><link>https://desistdaydream.github.io/docs/IT%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/3.%E9%9B%86%E7%BE%A4%E4%B8%8E%E5%88%86%E5%B8%83%E5%BC%8F/Keepalived/10.1.Keepalived-%E9%85%8D%E7%BD%AE%E7%A4%BA%E4%BE%8B/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/IT%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/3.%E9%9B%86%E7%BE%A4%E4%B8%8E%E5%88%86%E5%B8%83%E5%BC%8F/Keepalived/10.1.Keepalived-%E9%85%8D%E7%BD%AE%E7%A4%BA%E4%BE%8B/</guid><description>
&lt;h1 id="满足基本-ha-功能的配置">满足基本 HA 功能的配置&lt;/h1>
&lt;pre>&lt;code>global_defs {
notification_email {
root@localhost
}
notification_email_from Alexandre.Cassen@firewall.loc
smtp_server 127.0.0.1
smtp_connect_timeout 30
router_id LVS_DEVEL
script_user root
}
vrrp_script chk_haproxy {
script “killall -0 haproxy”
interval 1
weight -2
}
vrrp_instance VI_1 {
state MASTER #备节点改成BACKUP
interface ens33
virtual_router_id 51
priority 101 #倍节点改成100
advert_int 1
authentication {
auth_type PASS
auth_pass 1111
}
virtual_ipaddress {
192.168.0.75
}
track_script {
chk_haproxy
}
notify_master &amp;quot;/etc/keepalived/notify master&amp;quot; root
notify_backup &amp;quot;/etc/keepalived/notify backup&amp;quot; root
notify_fault &amp;quot;/etc/keepalived/notify fault&amp;quot; root
}
include /etc/keepalived/include/*
&lt;/code>&lt;/pre>
&lt;p>基本 LVS 的配置&lt;/p>
&lt;pre>&lt;code>virtual_server 192.168.0.63 80 {
delay_loop 6
lvs_sched rr
lvs_method DR
protocol TCP
real_server 192.168.1.71 80 {
TCP_CHECK {
connect_timeout 10
}
}
real_server 192.168.0.72 80 {
TCP_CHECK {
connect_timout 10
}
}
}
&lt;/code>&lt;/pre>
&lt;p>keepalive 双主模型&lt;/p>
&lt;pre>&lt;code>global_defs {
notification_email {
linuxedu@foxmail.com
}
notification_email_from kanotify@magedu.com
smtp_connect_timeout 3
smtp_server 127.0.0.1
router_id LVS_DEVEL
}
vrrp_script chk_haproxy {
script &amp;quot;killall -0 haproxy&amp;quot;
interval 1
weight -2
}
vrrp_instance VI_1 {
interface eth0
state MASTER # BACKUP for slave routers
priority 101 # 100 for BACKUP
virtual_router_id 51
garp_master_delay 1
authentication {
auth_type PASS
auth_pass password
}
track_interface {
eth0
}
virtual_ipaddress {
192.168.0.75
}
track_script {
chk_haproxy
}
notify_master &amp;quot;/etc/keepalived/notify.sh master&amp;quot;
notify_backup &amp;quot;/etc/keepalived/notify.sh backup&amp;quot;
notify_fault &amp;quot;/etc/keepalived/notify.sh fault&amp;quot;
}
vrrp_instance VI_2 {
interface eth0
state BACKUP # BACKUP for slave routers
priority 100 # 100 for BACKUP
virtual_router_id 52
garp_master_delay 1
authentication {
auth_type PASS
auth_pass password
}
track_interface {
eth0
}
virtual_ipaddress {
192.168.0.75
}
track_script {
chk_haproxy
}
notify_master &amp;quot;/etc/keepalived/notify.sh master&amp;quot;
notify_backup &amp;quot;/etc/keepalived/notify.sh backup&amp;quot;
notify_fault &amp;quot;/etc/keepalived/notify.sh fault&amp;quot;
}
&lt;/code>&lt;/pre>
&lt;h1 id="keepalived-所用到的脚本示例">keepalived 所用到的脚本示例&lt;/h1>
&lt;p>下面是一个 notify.sh 脚本的简单示例：&lt;/p>
&lt;pre>&lt;code>#!/bin/bash
# Author: MageEdu &amp;lt;linuxedu@foxmail.com&amp;gt;
# description: An example of notify script
vip=192.168.0.75
contact='root@localhost'
notify() {
mailsubject=&amp;quot;`hostname` to be $1: $vip floating&amp;quot;
mailbody=&amp;quot;`date '+%F %H:%M:%S'`: vrrp transition, `hostname` changed to be $1&amp;quot;
echo $mailbody | mail -s &amp;quot;$mailsubject&amp;quot; $contact
}
case &amp;quot;$1&amp;quot; in
master)
notify master
systemctl start haproxy.service
exit 0
;;
backup)
notify backup
systemctl stop haproxy.service
exit 0
;;
fault)
notify fault
/etc/rc.d/init.d/haproxy stop
exit 0
;;
*)
echo 'Usage: `basename $0` {master|backup|fault}'
exit 1
;;
esac
&lt;/code>&lt;/pre>
&lt;p>keepalived 通知脚本进阶示例：&lt;/p>
&lt;p>下面的脚本可以接受选项，其中：&lt;/p>
&lt;p>-s, &amp;ndash;service SERVICE,&amp;hellip;：指定服务脚本名称，当状态切换时可自动启动、重启或关闭此服务；&lt;/p>
&lt;p>-a, &amp;ndash;address VIP: 指定相关虚拟路由器的 VIP 地址；&lt;/p>
&lt;p>-m, &amp;ndash;mode {mm|mb}：指定虚拟路由的模型，mm 表示主主，mb 表示主备；它们表示相对于同一种服务而方，其 VIP 的工作类型；&lt;/p>
&lt;p>-n, &amp;ndash;notify {master|backup|fault}：指定通知的类型，即 vrrp 角色切换的目标角色；&lt;/p>
&lt;p>-h, &amp;ndash;help：获取脚本的使用帮助；&lt;/p>
&lt;pre>&lt;code>#!/bin/bash
# Author: MageEdu &amp;lt;linuxedu@foxmail.com&amp;gt;
# description: An example of notify script
# Usage: notify.sh -m|--mode {mm|mb} -s|--service SERVICE1,... -a|--address VIP -n|--notify {master|backup|falut} -h|--help
#contact='linuxedu@foxmail.com'
helpflag=0
serviceflag=0
modeflag=0
addressflag=0
notifyflag=0
contact='root@localhost'
Usage() {
echo &amp;quot;Usage: notify.sh [-m|--mode {mm|mb}] [-s|--service SERVICE1,...] &amp;lt;-a|--address VIP&amp;gt; &amp;lt;-n|--notify {master|backup|falut}&amp;gt;&amp;quot;
echo &amp;quot;Usage: notify.sh -h|--help&amp;quot;
}
ParseOptions() {
local I=1;
if [ $# -gt 0 ]; then
while [ $I -le $# ]; do
case $1 in
-s|--service)
[ $# -lt 2 ] &amp;amp;&amp;amp; return 3
serviceflag=1
services=(`echo $2|awk -F&amp;quot;,&amp;quot; '{for(i=1;i&amp;lt;=NF;i++) print $i}'`)
shift 2 ;;
-h|--help)
helpflag=1
return 0
shift
;;
-a|--address)
[ $# -lt 2 ] &amp;amp;&amp;amp; return 3
addressflag=1
vip=$2
shift 2
;;
-m|--mode)
[ $# -lt 2 ] &amp;amp;&amp;amp; return 3
mode=$2
shift 2
;;
-n|--notify)
[ $# -lt 2 ] &amp;amp;&amp;amp; return 3
notifyflag=1
notify=$2
shift 2
;;
*)
echo &amp;quot;Wrong options...&amp;quot;
Usage
return 7
;;
esac
done
return 0
fi
}
#workspace=$(dirname $0)
RestartService() {
if [ ${#@} -gt 0 ]; then
for I in $@; do
if [ -x /etc/rc.d/init.d/$I ]; then
/etc/rc.d/init.d/$I restart
else
echo &amp;quot;$I is not a valid service...&amp;quot;
fi
done
fi
}
StopService() {
if [ ${#@} -gt 0 ]; then
for I in $@; do
if [ -x /etc/rc.d/init.d/$I ]; then
/etc/rc.d/init.d/$I stop
else
echo &amp;quot;$I is not a valid service...&amp;quot;
fi
done
fi
}
Notify() {
mailsubject=&amp;quot;`hostname` to be $1: $vip floating&amp;quot;
mailbody=&amp;quot;`date '+%F %H:%M:%S'`, vrrp transition, `hostname` changed to be $1.&amp;quot;
echo $mailbody | mail -s &amp;quot;$mailsubject&amp;quot; $contact
}
# Main Function
ParseOptions $@
[ $? -ne 0 ] &amp;amp;&amp;amp; Usage &amp;amp;&amp;amp; exit 5
[ $helpflag -eq 1 ] &amp;amp;&amp;amp; Usage &amp;amp;&amp;amp; exit 0
if [ $addressflag -ne 1 -o $notifyflag -ne 1 ]; then
Usage
exit 2
fi
mode=${mode:-mb}
case $notify in
'master')
if [ $serviceflag -eq 1 ]; then
RestartService ${services[*]}
fi
Notify master
;;
'backup')
if [ $serviceflag -eq 1 ]; then
if [ &amp;quot;$mode&amp;quot; == 'mb' ]; then
StopService ${services[*]}
else
RestartService ${services[*]}
fi
fi
Notify backup
;;
'fault')
Notify fault
;;
*)
Usage
exit 4
;;
esac
&lt;/code>&lt;/pre>
&lt;p>在 keepalived.conf 配置文件中，其调用方法如下所示：&lt;/p>
&lt;pre>&lt;code>notify_master &amp;quot;/etc/keepalived/notify.sh -n master -a 172.16.100.1&amp;quot;
notify_backup &amp;quot;/etc/keepalived/notify.sh -n backup -a 172.16.100.1&amp;quot;
notify_fault &amp;quot;/etc/keepalived/notify.sh -n fault -a 172.16.100.1&amp;quot;
&lt;/code>&lt;/pre>
&lt;h1 id="keepalived-日志配置">keepalived 日志配置&lt;/h1>
&lt;p>建议使用 local2 级别日志，因为 keepalived_healthcheckers 默认为 local2 级别，新版 keepalived 已不用改该配置&lt;/p>
&lt;p>修改启动参数,将 -D 改为 -D -d -S 0&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>sed -i &lt;span style="color:#e6db74">&amp;#39;s/\(KEEPALIVED_OPTIONS=\)&amp;#34;-D&amp;#34;/\1&amp;#34;-D -d -S 0&amp;#34;/&amp;#39;&lt;/span> /etc/sysconfig/keepalived
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>修改 rsyslog 配置&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>cat &amp;gt; /etc/rsyslog.d/keepalived-log.conf &lt;span style="color:#e6db74">&amp;lt;&amp;lt; EOF
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">local0.* /var/log/keepalived/keepalived.log
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">&amp;amp; stop
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">EOF&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>配置日志轮替&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>cat &amp;gt; /etc/logrotate.d/keepalived &lt;span style="color:#e6db74">&amp;lt;&amp;lt; \EOF
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">/var/log/keepalived/keepalived.log {
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74"> daily
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74"> copytruncate
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74"> rotate 10
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74"> missingok
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74"> dateext
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74"> notifempty
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74"> compress
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74"> sharedscripts
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74"> postrotate
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74"> /bin/kill -HUP `cat /var/run/syslogd.pid 2&amp;gt; /dev/null` 2&amp;gt; /dev/null || true
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74"> /bin/kill -HUP `cat /var/run/rsyslogd.pid 2&amp;gt; /dev/null` 2&amp;gt; /dev/null || true
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74"> endscript
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">}
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">EOF&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>systemctl restart rsyslog
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div></description></item><item><title>Docs: Keepalived 配置详解</title><link>https://desistdaydream.github.io/docs/IT%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/3.%E9%9B%86%E7%BE%A4%E4%B8%8E%E5%88%86%E5%B8%83%E5%BC%8F/Keepalived/1.2.Keepalived-%E9%85%8D%E7%BD%AE%E8%AF%A6%E8%A7%A3/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/IT%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/3.%E9%9B%86%E7%BE%A4%E4%B8%8E%E5%88%86%E5%B8%83%E5%BC%8F/Keepalived/1.2.Keepalived-%E9%85%8D%E7%BD%AE%E8%AF%A6%E8%A7%A3/</guid><description>
&lt;h1 id="keepalived-使用">Keepalived 使用&lt;/h1>
&lt;p>keepalived 启动流程：&lt;/p>
&lt;ul>
&lt;li>启动三个进程（主进程、healthcheck 进程、vrrp 进程）之后，先进入 backup 状态，运行一次 vrrp_script 成功后发现没有主，这时候会进入 master 状态，拉起 VIP，完成启动。&lt;/li>
&lt;li>切换的流程：&lt;/li>
&lt;li>原 keepalived master 节点，运行检查脚本异常，则 keepalived 进入 FAULT 状态，释放 vip，原 backup 的 keepalived 会接管 VIP。&lt;/li>
&lt;li>注意事项：VIP 必须在 master 上。为了这个要求，需要在主库上先启动 keepalived。&lt;/li>
&lt;/ul>
&lt;h1 id="keepalived-配置">Keepalived 配置&lt;/h1>
&lt;p>&lt;strong>/etc/sysconfig/keepalived&lt;/strong> # keepalived 运行时参数配置&lt;/p>
&lt;p>&lt;strong>/etc/keepalived/keepalived.conf&lt;/strong> # keepalived 基本配置文件&lt;/p>
&lt;blockquote>
&lt;p>Note：keepalived 配置文件的运行时加载功能，可以通过命令 kill -HUP $(cat /var/run/keepalived.pid) 实现。该功能需要在 1.2.20 及以上版本才能实现&lt;/p>
&lt;/blockquote>
&lt;p>下面是一个基本的 keepalived.conf 文件的配置示例&lt;/p>
&lt;pre tabindex="0">&lt;code class="language-config" data-lang="config">! Configuration File for keepalived
global_defs { #全局配置段
notification_email {
admin@example. com
}
notification_email_from noreply@example.com
smtp_server 127.0.0.1
smtp_connect_timeout 60
router_id LVS_DEVEL
script_user root
}
vrrp_script chk_haproxy {
script &amp;#34;killall -0 haproxy&amp;#34;
interval 1
weight 2
}
vrrp_sync_group VG1 { #VRRP组配置段
group {
VI_1
VI_2
}
}
vrrp_instance VI_1 { #VRRP 实例VI_1配置段
state MASTER
interface eth0
virtual_router_id 50
priority 100
advert_int 1
authentication {
auth_type PASS
auth_pass password123
}
virtual_ipaddress {
10.0.0.1
}
track_script {
chk_haproxy
}
}
vrrp_instance VI_2 { #VRRP 实例VI_2配置段
state MASTER
interface eth1
virtual_router_id 2
priority 100
advert_int 1
authentication{
auth_type PASS
auth_pass password123
}
virtual_ipaddress {
192.168.1.1
}
notify_master &amp;#34;/etc/keepalived/notify.sh master&amp;#34; #定义该节点变为master后执行的脚本
notify_backup &amp;#34;/etc/keepalived/notify.sh backup&amp;#34; #定义该节点变为backup后执行的脚本
notify_fault &amp;#34;/etc/keepalived/notify.sh fault&amp;#34; #定义该节点变为fault后执行的脚本
}
virtual_server 10.0.0.1 80 { #虚拟服务器LVS 配置段
delay_loop 6
lvs_sched rr
lvs_method DR
protocol TCP
sorry_server 127.0.0.1 80
real_server 192.168.1.20 80 { #定义后端服务器1
XXX_CHECK {
connect timeout 10
}
}
real_server 192.168.1.21 80 { #定义后端服务器2
XXX_CHECK {
connect timeout 10
}
}
}
&lt;/code>&lt;/pre>&lt;p>从 Keepalived 配置文件/etc/keepalived/keepalived.conf 中的内容可以看到， Keepalived 的配置主要分为三个模块， 即全局配置段、VRRP 定义段、虚拟服务器 LVS 配置段。&lt;/p>
&lt;h1 id="配置文件-keywords关键字-详解">配置文件 keywords(关键字) 详解&lt;/h1>
&lt;p>注意：各个大版本之间的 keyword 有很大区别，名称以及所在位置都有区别，千万注意！！！！&lt;/p>
&lt;h2 id="1全局配置段">1.全局配置段&lt;/h2>
&lt;p>全局配置段（ global_defs ）的主要作用之一就是 Keepalived 出现故障时的邮件通知管理员，让管理员以邮件形式知道 Keepalived 的运行情况。通常情况下，邮件通知不是必须的，用户可以选择其他监控方式来对 Keepalived 进行监控，如 Nagios。需要说明的是，全局配置段对 Keepalived 来说是可选的，其内容并不是 Keepalived 配置所必须的。全局配置段的几个主要配置参数说明如下：&lt;/p>
&lt;p>&lt;strong>global_defs&lt;/strong> #&lt;/p>
&lt;ul>
&lt;li>
&lt;p>Notification_email # 用于配置接收邮件的负载均衡器的管理员群组邮箱。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Notification_email_from # 自定义发出邮件的邮箱地址，即管理员邮件显示的发件人。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>SMTP # 指定简单邮件参数协议服务器地址，一般为本机。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>LVS_ID # LVS 负载均衡器标志，同一网络中其值唯一。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>script_user &amp;lt;USER&amp;gt;&lt;/strong> # 指定 vrrp_script 定义的脚本&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>enable_script_security&lt;/strong> # 开启脚本安全&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>vrrp_script ScriptName { &amp;hellip; }&lt;/strong> # 定义检查脚本以便后面的 track_script 关键字来引用，若检查状态码为非 0 失败，则引用该脚本的 VRRP 变成 Fault 状态，若定义了 weight 字段且优先级比其余节点都低，则变为 Backup 状态&lt;/p>
&lt;ul>
&lt;li>
&lt;p>&lt;strong>script &amp;ldquo;/PATH/FILE&amp;rdquo;&lt;/strong> # 定义需要执行的脚本或者需要执行的脚本的路径&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>interval&lt;/strong> # 脚本调用间隔的秒数，默认 1 秒&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>timeout&lt;/strong> # 定义调用失败多少秒后，确认该脚本失败&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>weight&lt;/strong> # 脚本执行失败后，调整调用了该脚本的 vrrp 的优先级(priority)。i.e.降低或者提高优先级的数值，INTEGER 值为-254 到 254 之间&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>rise&lt;/strong> # 判断服务正常的检查次数，正常多少次，会进行状态转变&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>fall&lt;/strong># 判断服务异常的检查次数，异常多少次，会进行状态转转变&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>user USERNAME [GROUPNAME]&lt;/strong> # 运行该脚本的用户&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>init_fail&lt;/strong> # 定义该脚本默认为失败状态&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h2 id="2vrrp-配置段">2.VRRP 配置段&lt;/h2>
&lt;p>VRRP 配置段主要用于定义 VRRP 组，在 Keepalived 发生任何状态变化时，被定义在 VRRP 组中的 VRRP 实例作为逻辑整体一致行动，如在发生 LVS Router 故障切换 Failover 的过程中， VRRP 组中的实例会作为一致整体同时切换。在本节的演示配置中，同一个 VRRP 组内配置了两个 VRRP 实例，分别是针对外部网络的 VRRP_EXT 实例和针对内部私有网络的 VRRP_INT 实例。VRRP 配置段中的关键参数说明如下。&lt;/p>
&lt;p>&lt;strong>vrrp_sync_group {&amp;hellip;}&lt;/strong> # VRRP 实例一致组，用于定义 VRRP 一致组中的成员，组内的 VRRP 实例行为是一致的，如在 Failover 的时候， 一致组内的 VRRP 实例将同时迁移。在本机示例中，当 LBl 出现故障时， VRRP INT 和 VRRP EXT 实例将同时切换到 LB2 上。如果 不定义组，那么如果一台设备上有俩网卡的时候，只有一块网卡坏了的话，定义在另一块网卡上的 VRRP 则还在原来的设备上运行，无法自动切换到备用设备上。&lt;/p>
&lt;p>&lt;strong>vrrp_instance {&amp;hellip;}&lt;/strong> # VRRP 实例，用于配置一个 VRRP 服务进程实例，其中的 state 设定了当前节点 VRRP 实例的主备状态，在主 LVS Router 中，该值应该为 MASTER,在备 LVS Router 中，其值为 BACKUP 。正常情况下只有 Master 的 LVS Router 在工作， Backup 的 LVS Router 处于 Standby 状态。&lt;/p>
&lt;ul>
&lt;li>
&lt;p>&lt;strong>state&lt;/strong> # 当前节点的初始状态&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>interface&lt;/strong> # 对外提供服务的网络接口，如 eth0 和 eth1，选择服务接口时，一定要核实清楚，LV Router 的 VIP 将会配置到这个物理接口上。也可以配置多个实例在同一个网卡上，然后每个实例配置不同优先级，HOST1 上的实例 1 是主实例 2 是备，HOST2 上的实例 1 是备实例 2 是主，这样可以实现两台 HOST 双主模式负载均衡流量&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>virtual_Router_id&lt;/strong> # VRID，虚拟路由标志，同一个 VRRP 实例使用唯一的标识。即同一个 VRRP 实例中，MASTER 和 BACKUP 状态的 VRRP 实例中，VRID 值是相同的，同时在全部 VRRP 组内是唯一的。&lt;/p>
&lt;ul>
&lt;li>Note：如果在同网段有相同的 vrid 号，则 keepalived 会无限输出报错日志。使用 tcpdump -nn -i any net 224.0.0.0/8 |grep vrid 命令可以查到该网段都有哪些 vrid 号正在使用&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>priority&lt;/strong> # 此参数指明了该 VRRP 实例的优先级，数字越大说明优先级越高，取值范围为 0-255 ，在同一个 VRRP 实例里， MASTER 的优先级高于 BACKUP。若 MASTER 的 Priority 值为 100 ，那 BACKUP 的 Priority 只能是 99 或更小的数值。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>nopreempt&lt;/strong> # 开启非抢占模式。允许低优先级的节点保持 MASTER 角色，即使高优先级的节点从故障中恢复也是如此。i.e.不会触发选举过程。只有当前 BACKUP 节点 认为 MASTER 不存在时，才会重新选举。&lt;/p>
&lt;ul>
&lt;li>
&lt;p>Note：该模式会引发这个问题 Keepalived 非抢占模式 VIP 不漂移问题&lt;/p>
&lt;ul>
&lt;li>如果想要使用非抢占模式，主备的 keepalived 的 state 都不能是 MASTER。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>advert_int&lt;/strong> # Master 路由发送 VRRP 广播的时间间隔，单位为秒。默认为 1 秒&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>authentication {&amp;hellip;}&lt;/strong> # 包含验证类型和验证密码，类型主要有 PASS 和 AH 两种，通常使用的类型为 PASS 验证密码为明文，同一 VRRP 实例 MASTER 与 BACKUP 使用相同的密码才能正常通信。&lt;/p>
&lt;ul>
&lt;li>
&lt;p>&lt;strong>auth_type PASS|AH&lt;/strong> # 认证类型。Note：只能是 PASS 或 AH 选项，不能写别的，否则报错：unknown authentication type &amp;rsquo;lvs'&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>auth_pass PASSWORD&lt;/strong> # 认证的密码&lt;/p>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>virtual_ipaddress {IP}&lt;/strong> # 虚拟 IP 地址，即 VIP，可以有多个虚拟 IP 、地址，每个地址占一行，不需要指定子网掩码。作为 Standby 的负载均衡器，LB2 的 keepalived.conf 配置文件与 LB1 类似，其不同之处在于 VRRP 实例配置段中的的 VRRP 实例 State 和 Priority 参数的设置，如 LB1 中的 State 为 Master, LB2 中的 State 为 BACKUP ，并且 LB2 中 VRRP 实例的 Priority 必须小于 LB1 中的优先级。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>track_script {ScriptName}&lt;/strong> # 引用全局配置段中 vrrp_script 关键字的名为 ScriptName 的脚本&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>notify_master &amp;ldquo;/PATH/ScriptName ARGS&amp;rdquo;&lt;/strong> # 定义该节点变为 master 后执行的脚本&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>notify_backup &amp;ldquo;/PATH/ScriptName ARGS&amp;rdquo;&lt;/strong> # 定义该节点变为 backup 后执行的脚本&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>notify_fault &amp;ldquo;/PATH/ScriptName ARGS&amp;rdquo;&lt;/strong> # 定义该节点变为 fault 后执行的脚本&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h2 id="3-虚拟服务器-lvs-配置段">3. 虚拟服务器 LVS 配置段&lt;/h2>
&lt;p>虚拟服务器（ Virtual Server ）配置段主要定义 LVS 的监昕虚拟 IP 地址和对应的后端服务器及其健康检测机制，虚拟服务器的定义段是 Keepalived 框架最重要的部分。此部分的定义主要分为一个 Virtual Server 的定义和多个 Real Servers 的定义， Virtual Server 由 VRRP 中定义的 VIP 加上端口号构成，而 Real Server 由后端服务器节点 IP 和端口号构成，相关的配置参数说明如下。&lt;/p>
&lt;p>&lt;strong>virtual_server {&amp;hellip;}&lt;/strong> # lvs 中调度器的配置&lt;/p>
&lt;ul>
&lt;li>
&lt;p>&lt;strong>delay_Loop NUM&lt;/strong> # 健康检查的时间间隔，单位为秒。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>lvs_sched&lt;/strong> # 指定负载均衡算法，示例中的 rr 表示 Round-Robin 轮询算法。(老版本的 keyword 为 lb_algo)&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>lvs_method&lt;/strong> # 采用的路由方法，示例中采用的是 DR 路由，还可以采用 NAT 和 TUN 路由。(老版本的 keyword 为 lb_kind)&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>persistence_timeout&lt;/strong> # 指定连接持久的超时时间。默认 6 分钟。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>protocol&lt;/strong># 转发协议，一般有 TCP 和 UDP 两种。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>connect_timeout # 连接超时时间。默认 5 秒。当 RS 检查失败 5 秒后，即判断该 RS 无响应，从 ipvs 组中踢出&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>retry&lt;/strong> # 重试次数。默认 1 次。当 RS 检查失败后，再次检查的次数。(老版本的 keyword 为 nb_get_retry)&lt;/p>
&lt;/li>
&lt;li>
&lt;p>delay_before_retry # 失败后，让 RS 重新加回 ipvs 组重试的次数。默认 1 次。当 rs 检查 1 次成功后，就将该 RS 重新加入 ipvs 组&lt;/p>
&lt;/li>
&lt;li>
&lt;p>sorry_server :用于定义当后端所有 real server 挂掉后，使用哪台设备进行回应&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>real_server IP PORT {&amp;hellip;}&lt;/strong> # 后端服务器配置，i.e.lvs 中 RS 的配置&lt;/p>
&lt;ul>
&lt;li>
&lt;p>&lt;strong>CHECK {&amp;hellip;}&lt;/strong> # 指定健康检查的方式。TCP 就是测试目标端口通不通。HTTP 则是测试指定资源的响应码&lt;/p>
&lt;ul>
&lt;li>
&lt;p>可用的 CHECK 有如下几个，常用的标黄&lt;/p>
&lt;/li>
&lt;li>
&lt;p>HTTP_GET|SSL_GET|TCP_CHECK|SMTP_CHECK|DNS_CHECK|MISC_CHECK|BFD_CHECK|UDP_CHECK|PING_CHECK|FILE_CHECK&lt;/p>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h2 id="4-其他配置">4. 其他配置&lt;/h2>
&lt;p>&lt;strong>include &amp;lt;FILE&amp;gt;&lt;/strong> # 指定要包含的其他配置文件。FILE 可以用绝对路径，也可以使用通配符。指定的 FILE 中的内容将作为 keepalived 配置内容附加到主配置后面&lt;/p>
&lt;h2 id="检查脚本配置示例">检查脚本配置示例&lt;/h2>
&lt;p>定义脚本用于把 MASTER 节点的优先值降低 20，以实现主备切换，在指定目录中创建一个 down 文件，也可以使用别的判断方式&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>vrrp_script chk_mantaince_down &lt;span style="color:#f92672">{&lt;/span> &lt;span style="color:#75715e">#配置一个名为chk_mantaince_down的脚本&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e"># 当某个文件存在时，权重减20&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> script &lt;span style="color:#e6db74">&amp;#34;[[ -f /etc/keepalived/down ]] &amp;amp;&amp;amp; exit 1 || exit 0&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> interval &lt;span style="color:#ae81ff">1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> weight -20
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>判断 nginx 进程是否存在，如果不存在则权重-2 使之变为 BACKUP&lt;/p>
&lt;pre tabindex="0">&lt;code>vrrp_script chk_haproxy {
# 判断haproxy进程是否存在，如果不存在则权重-2使之变为BACKUP
script &amp;#34;killall -0 haproxy&amp;#34; # 可以使用这个语句判断nginx，script &amp;#34;killall -0 nginx &amp;amp;&amp;gt; /dev/null&amp;#34;
interval 1 # 运行脚本的时间间隔
weight -2
}
&lt;/code>&lt;/pre>&lt;p>引用脚本&lt;/p>
&lt;pre tabindex="0">&lt;code>vrrp_instance VI_1 {
...
track_script { # 在VRRP实例中引用哪些keepalived.conf中定义的脚本
chk_mantaince_down
}
notify_master &amp;#34;/etc/keepalived/notify.sh master&amp;#34; # 定义该节点变为master后执行的脚本
notify_backup &amp;#34;/etc/keepalived/notify.sh backup&amp;#34; # 定义该节点变为backup后执行的脚本
notify_fault &amp;#34;/etc/keepalived/notify.sh fault&amp;#34; # 定义该节点变为fault后执行的脚本
}
&lt;/code>&lt;/pre></description></item><item><title>Docs: keepalived+nginx 配置示例</title><link>https://desistdaydream.github.io/docs/IT%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/3.%E9%9B%86%E7%BE%A4%E4%B8%8E%E5%88%86%E5%B8%83%E5%BC%8F/Keepalived/10.2.keepalived+nginx-%E9%85%8D%E7%BD%AE%E7%A4%BA%E4%BE%8B/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/IT%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/3.%E9%9B%86%E7%BE%A4%E4%B8%8E%E5%88%86%E5%B8%83%E5%BC%8F/Keepalived/10.2.keepalived+nginx-%E9%85%8D%E7%BD%AE%E7%A4%BA%E4%BE%8B/</guid><description>
&lt;h1 id="适用于-keepalived-的-node-节点的前端负载均衡的配置">适用于 keepalived 的 node 节点的前端负载均衡的配置&lt;/h1>
&lt;h3 id="keepalivedconf-主节点配置内容">keepalived.conf 主节点配置内容&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>cat &amp;gt; /etc/keepalived/keepalived.conf &lt;span style="color:#e6db74">&amp;lt;&amp;lt; EOF
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">global_defs {
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74"> router_id k8s-master-dr
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74"> script_user root
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74"> enable_script_security
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">}
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">vrrp_script check_nginx {
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74"> script &amp;#34;/etc/keepalived/check_nginx.sh&amp;#34;
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74"> interval 3
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74"> weight -2
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74"> fall 2
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74"> rise 2
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">}
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">vrrp_instance VI_K8S {
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74"> state BACKUP
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74"> interface eth0
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74"> virtual_router_id 60
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74"> priority 101
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74"> nopreempt
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74"> authentication {
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74"> auth_type PASS
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74"> auth_pass 4be37dc3b4c90194d1600c483e10ad1d
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74"> }
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74"> virtual_ipaddress {
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74"> 172.40.0.60
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74"> }
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74"> track_script {
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74"> check_nginx
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74"> }
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">}
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">EOF&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="keepalivedconf-备节点配置内容">keepalived.conf 备节点配置内容&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>cat &amp;gt; /etc/keepalived/keepalived.conf &lt;span style="color:#e6db74">&amp;lt;&amp;lt; EOF
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">global_defs {
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74"> router_id k8s-master-dr
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74"> script_user root
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74"> enable_script_security
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">}
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">vrrp_script check_nginx {
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74"> script &amp;#34;/etc/keepalived/check_nginx.sh&amp;#34;
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74"> interval 3
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74"> weight -2
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74"> fall 2
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74"> rise 2
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">}
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">vrrp_instance VI_K8S {
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74"> state BACKUP
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74"> interface eth0
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74"> virtual_router_id 60
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74"> priority 100
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74"> nopreempt
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74"> authentication {
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74"> auth_type PASS
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74"> auth_pass 4be37dc3b4c90194d1600c483e10ad1d
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74"> }
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74"> virtual_ipaddress {
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74"> 172.40.0.60
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74"> }
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74"> track_script {
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74"> check_nginx
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74"> }
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">}
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">EOF&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="check_nginxsh-配置内容">check_nginx.sh 配置内容&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>cat &amp;gt; /etc/keepalived/check_nginx.sh &lt;span style="color:#e6db74">&amp;lt;&amp;lt; \EOF
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">#!/bin/bash
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">pidof nginx #检查memcached服务
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">if [[ $? == 0 ]];then #检查成功
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74"> /sbin/iptables -S | grep vrrp
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74"> if [[ $? == 0 ]]; then #如果iptable中有vrrp的配置，删除它
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74"> /sbin/iptables -D OUTPUT -p vrrp -j DROP
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74"> fi
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74"> exit 0
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">else #检查失败
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74"> /sbin/iptables -S | grep vrrp
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74"> if [[ $? != 0 ]]; then
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74"> /sbin/iptables -A OUTPUT -p vrrp -j DROP #如果iptable中没有vrrp的条目，禁止vrrp发出
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74"> fi
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74"> exit 1
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">fi
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">EOF&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>chmod &lt;span style="color:#ae81ff">755&lt;/span> /etc/keepalived/check_nginx.sh
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div></description></item><item><title>Docs: 问题实例：Keepalived 非抢占模式 VIP 不漂移</title><link>https://desistdaydream.github.io/docs/IT%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/3.%E9%9B%86%E7%BE%A4%E4%B8%8E%E5%88%86%E5%B8%83%E5%BC%8F/Keepalived/%E9%97%AE%E9%A2%98%E5%AE%9E%E4%BE%8BKeepalived-%E9%9D%9E%E6%8A%A2%E5%8D%A0%E6%A8%A1%E5%BC%8F-VIP-%E4%B8%8D%E6%BC%82%E7%A7%BB/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/IT%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/3.%E9%9B%86%E7%BE%A4%E4%B8%8E%E5%88%86%E5%B8%83%E5%BC%8F/Keepalived/%E9%97%AE%E9%A2%98%E5%AE%9E%E4%BE%8BKeepalived-%E9%9D%9E%E6%8A%A2%E5%8D%A0%E6%A8%A1%E5%BC%8F-VIP-%E4%B8%8D%E6%BC%82%E7%A7%BB/</guid><description>
&lt;h1 id="keepalived-非抢占模式下-vip-不漂移问题">Keepalived 非抢占模式下 VIP 不漂移问题&lt;/h1>
&lt;p>Keepalived 主要是通过虚拟路由冗余来实现高可用功能。本文将不对 keepalived 的基本原理进行阐述，可参考文章 Keepalived 详细介绍简介、keepalived vip 漂移基本原理及选举算法。本文记录了在实践过程中使用 keepalived 时，在 weight 值变化的情况下 vip 不漂移的问题及解决方法。&lt;/p>
&lt;p>场景&lt;/p>
&lt;p>3 个 keepalived 节点, vip 为 172.31.23.6：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>devops1a-zoocassa0 172.31.23.22&lt;/p>
&lt;/li>
&lt;li>
&lt;p>devops1a-zoocassa1 172.31.23.23&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>预期&lt;/p>
&lt;ol>
&lt;li>
&lt;p>两个节点初始都设为 BACKUP，按照优先级（priority）选举 MASTER；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>在两个节点上检查 memcached 服务状态，失败则降低优先级；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>如果 MASTER(假设为 devops1a-zoocassa0)上检查失败，BACKUP 上检查成功，则优先级高的 BACKUP 节点(假设为 devops1a-zoocassa1)切换为 MASTER 节点；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>之前检查失败的 MASTER(devops1a-zoocassa0)上的服务恢复时, 之前的 BACKUP 节点(devops1a-zoocassa1)服务检查也成功，即使 devops1a-zoocassa0 优先级恢复到高于 devops1a-zoocassa1,也不再成为 MASTER(不抢占)。&lt;/p>
&lt;/li>
&lt;/ol>
&lt;h2 id="不成功配置范例">不成功配置范例&lt;/h2>
&lt;p>主节点 dr-1 配置&lt;/p>
&lt;pre>&lt;code>global_defs {
router_id k8s-master-dr
}
vrrp_script check_nginx {
script &amp;quot;pidof nginx&amp;quot;
interval 3
weight -2
fall 2
rise 2
}
vrrp_instance VI_K8S {
state BACKUP
interface eth0
virtual_router_id 60
priority 101
nopreempt
authentication {
auth_type PASS
auth_pass 4be37dc3b4c90194d1600c483e10ad1d
}
virtual_ipaddress {
172.40.0.60
}
track_script {
check_nginx
}
}
&lt;/code>&lt;/pre>
&lt;p>备节点 dr-2 配置&lt;/p>
&lt;pre>&lt;code>global_defs {
router_id k8s-master-dr
}
vrrp_script check_nginx {
script &amp;quot;pidof nginx&amp;quot;
interval 3
weight -2
fall 2
rise 2
}
vrrp_instance VI_K8S {
state BACKUP
interface eth0
virtual_router_id 60
priority 100
nopreempt
authentication {
auth_type PASS
auth_pass 4be37dc3b4c90194d1600c483e10ad1d
}
virtual_ipaddress {
172.40.0.60
}
track_script {
check_nginx
}
}
&lt;/code>&lt;/pre>
&lt;p>以上述配置文件内容作为 keepalived 配置文件 /etc/keepalived/keepalived.conf，在两个个节点上启动 keepalived：&lt;code>systemctl restart keepalived&lt;/code>&lt;/p>
&lt;p>会发现存在如下问题：&lt;/p>
&lt;ol>
&lt;li>
&lt;p>优先级高的 dr-1 可能没有成为 MASTER 节点（多试几次，可能每次选举的 MASTER 节点都不同），不符合预期中的第 1 点；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>假设 dr-1 成为了 MASTER 节点，关掉 dr-1 上的 memcached 服务：&lt;code>systemctl stop keepalived&lt;/code>&lt;/p>
&lt;/li>
&lt;/ol>
&lt;p>此时运行 service keepalived status，发现 dr-1 的 weight 值降低且低于 dr-2 ，但是 dr-2 并没有成为 MASTER 节点，不符合预期中的第 3 点。&lt;/p>
&lt;ol>
&lt;li>将配置文件中的 nginx 去掉以后，可以解决上述问题，符合预期中的第 1，2，3 点，但是当原 MASTER 节点上服务恢复后，原 MASTER 会重新成为 MASTER 角色，这不符合预期中的第 4 点（不抢占）；&lt;/li>
&lt;/ol>
&lt;h2 id="问题原因">问题原因：&lt;/h2>
&lt;p>在网上查阅到的资料中，大都认为按照上述配置后可以完全符合预期中的 4 个点，不会出现 MASTER 节点服务检查失败后 VIP 不漂移的问题。但是实践是检验真理的唯一标准，配置 nopreemt 后，不仅是会让原 MASTER 节点服务恢复后不抢占，而是会完全的不选举新 MASTER(从头到尾永远不切换，除非 BACKUP 认为当前集群中不存在 MASTER, 才会重新选举)，这样便可以解释出现的问题 1 和问题 2 了：&lt;/p>
&lt;p>问题 1 的原因在于：&lt;/p>
&lt;ol>
&lt;li>
&lt;p>先启动的节点将自己选举为 MASTER, 在收到其他节点的 vrrp 报文后不会按照优先级调整自己的角色；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>后启动的节点收到了 MASTER 的 vrrp 报文，发现已经存在 MASTER，由于不抢占，自动进入 BACKUP 状态；&lt;/p>
&lt;/li>
&lt;/ol>
&lt;p>问题 2 的原因在于：&lt;/p>
&lt;ol>
&lt;li>设置了 nopreempt, 永远不发生角色切换；&lt;/li>
&lt;/ol>
&lt;p>下面是官方文档中对于 nopreempt 的解释：&lt;/p>
&lt;pre>&lt;code>&amp;quot;nopreempt&amp;quot; allows the lower priority machine to maintain the master role,
even when a higher priority machine comes back online.
NOTE: For this to work, the initial state of this entry must be BACKUP.
&lt;/code>&lt;/pre>
&lt;h2 id="解决方案">解决方案&lt;/h2>
&lt;p>要想同时满足预期中的效果，其实只要做到两点：&lt;/p>
&lt;p>当 MASTER 上的服务检查失败时，触发重新选举；&lt;/p>
&lt;p>设置不抢占（已经做到）；&lt;/p>
&lt;p>那么如何实现第一点呢？重新选举意味着:&lt;/p>
&lt;ol>
&lt;li>
&lt;p>BACKUP 成为 MASTER，要求 BACKUP 节点认为当前节点中没有 MASTER 节点；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>MASTER 成为 BACKUP，要求 MASTER 节点感知到环境中存在别的 MASTER 节点，从而进入 BACKUP 状态；&lt;/p>
&lt;/li>
&lt;/ol>
&lt;p>节点之间通过 VRRP 报文获得相互的优先级及状态信息，因此，可以通过在服务检查失败时，配置防火墙，禁止本机的 VRRP 报文发出即可。这样，BACKUP 节点收不到 MASTER 节点的 VRRP 报文，认为 MASTER 节点不存在，同时 MASTER 节点能收到其他节点的 VRRP 报文，感知到新 MASTER 的产生，从而进入 BACKUP 状态。&lt;/p>
&lt;p>配置详见：&lt;a href="https://www.yuque.com/go/doc/33183799">keepalived+nginx 配置示例&lt;/a>&lt;/p>
&lt;p>重启 keepalived 服务，测试成功。&lt;/p></description></item></channel></rss>