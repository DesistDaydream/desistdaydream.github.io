<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>断念梦 – Linux 图形处理</title><link>https://desistdaydream.github.io/docs/11.%E5%A4%9A%E5%AA%92%E4%BD%93/%E5%9B%BE%E5%BD%A2%E5%A4%84%E7%90%86/Linux-%E5%9B%BE%E5%BD%A2%E5%A4%84%E7%90%86/</link><description>Recent content in Linux 图形处理 on 断念梦</description><generator>Hugo -- gohugo.io</generator><atom:link href="https://desistdaydream.github.io/docs/11.%E5%A4%9A%E5%AA%92%E4%BD%93/%E5%9B%BE%E5%BD%A2%E5%A4%84%E7%90%86/Linux-%E5%9B%BE%E5%BD%A2%E5%A4%84%E7%90%86/index.xml" rel="self" type="application/rss+xml"/><item><title>Docs: freedesktop</title><link>https://desistdaydream.github.io/docs/11.%E5%A4%9A%E5%AA%92%E4%BD%93/%E5%9B%BE%E5%BD%A2%E5%A4%84%E7%90%86/Linux-%E5%9B%BE%E5%BD%A2%E5%A4%84%E7%90%86/freedesktop/_index_/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/11.%E5%A4%9A%E5%AA%92%E4%BD%93/%E5%9B%BE%E5%BD%A2%E5%A4%84%E7%90%86/Linux-%E5%9B%BE%E5%BD%A2%E5%A4%84%E7%90%86/freedesktop/_index_/</guid><description/></item><item><title>Docs: XDG</title><link>https://desistdaydream.github.io/docs/11.%E5%A4%9A%E5%AA%92%E4%BD%93/%E5%9B%BE%E5%BD%A2%E5%A4%84%E7%90%86/Linux-%E5%9B%BE%E5%BD%A2%E5%A4%84%E7%90%86/freedesktop/XDG/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/11.%E5%A4%9A%E5%AA%92%E4%BD%93/%E5%9B%BE%E5%BD%A2%E5%A4%84%E7%90%86/Linux-%E5%9B%BE%E5%BD%A2%E5%A4%84%E7%90%86/freedesktop/XDG/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://www.freedesktop.org/wiki/Specifications/">freedesktop 规范&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>freedesktop.org 制定互操作性规范，但我们不是官方标准机构。项目不需要实施所有这些规范，也不需要认证。&lt;/p>
&lt;p>这些规范许多都在 &lt;strong>X Desktop Group(简称 XDG)&lt;/strong> 的旗帜下。（Cross-Desktop Group 代表跨桌面组）&lt;/p>
&lt;p>其中一些规范正在（非常）活跃地使用，并且有大量感兴趣的开发人员。其中许多被认为是稳定的，不需要进一步开发，并且可能没有积极的发展。其中一些未被使用或广泛实施。&lt;/p>
&lt;h1 id="常见变量">常见变量&lt;/h1>
&lt;p>&lt;a href="https://specifications.freedesktop.org/basedir-spec/latest/ar01s03.html">https://specifications.freedesktop.org/basedir-spec/latest/ar01s03.html&lt;/a>&lt;/p>
&lt;p>&lt;code>XDG_CACHE_HOME&lt;/code> 定义了应该存储用户特定的非必要数据文件的基本目录。如果 &lt;code>$XDG_CACHE_HOME&lt;/code> 未设置或为空，则应使用等于 &lt;code>$HOME/.cache&lt;/code> 的默认值。这是一个 Linux 和 Unix 操作系统环境变量，Windows 系统中并没有这个环境变量。&lt;/p></description></item><item><title>Docs: GSettings 与 Dconf</title><link>https://desistdaydream.github.io/docs/11.%E5%A4%9A%E5%AA%92%E4%BD%93/%E5%9B%BE%E5%BD%A2%E5%A4%84%E7%90%86/Linux-%E5%9B%BE%E5%BD%A2%E5%A4%84%E7%90%86/GSettings-%E4%B8%8E-Dconf/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/11.%E5%A4%9A%E5%AA%92%E4%BD%93/%E5%9B%BE%E5%BD%A2%E5%A4%84%E7%90%86/Linux-%E5%9B%BE%E5%BD%A2%E5%A4%84%E7%90%86/GSettings-%E4%B8%8E-Dconf/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;/blockquote>
&lt;h1 id="gsetting-命令行工具">gsetting 命令行工具&lt;/h1>
&lt;h2 id="应用示例">应用示例&lt;/h2>
&lt;p>关闭 Ubuntu 20.04 的桌面动画效果&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>gsettings set org.gnome.desktop.interface enable-animations false
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div></description></item><item><title>Docs: Linux 图形处理</title><link>https://desistdaydream.github.io/docs/11.%E5%A4%9A%E5%AA%92%E4%BD%93/%E5%9B%BE%E5%BD%A2%E5%A4%84%E7%90%86/Linux-%E5%9B%BE%E5%BD%A2%E5%A4%84%E7%90%86/Linux-%E5%9B%BE%E5%BD%A2%E5%A4%84%E7%90%86/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/11.%E5%A4%9A%E5%AA%92%E4%BD%93/%E5%9B%BE%E5%BD%A2%E5%A4%84%E7%90%86/Linux-%E5%9B%BE%E5%BD%A2%E5%A4%84%E7%90%86/Linux-%E5%9B%BE%E5%BD%A2%E5%A4%84%E7%90%86/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;h1 id="xorg-x11-wayland-linux-display-servers-and-protocols-explained">Xorg, X11, Wayland? Linux Display Servers And Protocols Explained&lt;/h1>
&lt;p>原文链接：&lt;a href="https://linuxiac.com/xorg-x11-wayland-linux-display-servers-and-protocols-explained/">https://linuxiac.com/xorg-x11-wayland-linux-display-servers-and-protocols-explained/&lt;/a>&lt;/p>
&lt;p>&lt;strong>Have you ever wondered what exactly X server, Xorg, X11, Wayland and stuff like that does? Wayland vs Xorg, what is better? This guide is for you.&lt;/strong>
You always stumble upon those terms, and know they have something to do regarding the graphics, but you’d like to know more.&lt;/p>
&lt;h3 id="what-is-display-server-in-linux">What is display server in Linux?&lt;/h3>
&lt;p>A display server  is a program whose primary task is to coordinate the input and output of its clients to and from the rest of the operating system, the hardware, and each other. The display server communicates with its clients over the display server protocol.
The display server is a key component in any graphical user interface, specifically the windowing system. It is the basic component of Graphical User Interface (GUI) which sits between the graphical interface and the kernel. So, thanks to a display server, you can use your computer with GUI. Without it, you would only be restricted to a command line interface.
It is very important to not confuse display server with desktop environment. The desktop environments (&lt;a href="https://linuxiac.com/gnome-3-38-is-here-with-new-app-grid-and-better-performence/">Gnome&lt;/a>, KDE, Xfce, MATE, etc.) uses display server underneath it.
The display server communicates with its clients over the display server protocol. There are three display server protocols available in Linux. X11 and Wayland are two of them. The third, &lt;a href="https://mir-server.io/">Mir&lt;/a>, is beyond the scope of this tutorial.&lt;/p>
&lt;h3 id="x-window-system-xorg-x11-explained">X Window System, Xorg, X11, explained&lt;/h3>
&lt;p>X Window System, often referred to merely as X, is really old. First originating in 1984, it ended up being the default windowing system for most UNIX-like operating systems, including Linux.
&lt;strong>X.Org server&lt;/strong> is the free and open-source implementation of the X Window System display server stewarded by the &lt;a href="https://www.x.org/">X.Org Foundation&lt;/a>. It is an application that interacts with client applications via the X11 protocol to draw things on a display and to send input events like mouse movements, clicks, and keystrokes. Typically, one would start an X server which will wait for clients applications to connect to it. Xorg is based on a client/server model and thus allows clients to run either locally or remotely on a different machine.
If it’s not obvious, it’s implicit in the design of X11 that the application and the display don’t have to be on the same computer. At the time X was developed, it was very common that the X server would run on a workstation and the users would run applications on a remote computer with more processing power.
&lt;strong>X11&lt;/strong> is a network protocol. It describes how messages are exchanged between a client (application) and the display (server). These messages typically carry primitive drawing commands like “draw a box”, “write these character at this position”, “the left mouse button has been clicked”, etc.
But X11 is old, and it was still a pile of hacks sitting on top of a protocol not truly overhauled for over 30 years. Most of the features that the X Server protocol provided were not used anymore. Pretty much all of the work that X11 did was redelegated to the individual applications and the window manager. And yet all of those old features are still there, weighing down on all of these applications, hurting performance and security.&lt;/p>
&lt;h3 id="wayland-the-next-generation-display-server">Wayland, the next-generation display server&lt;/h3>
&lt;p>&lt;strong>Wayland&lt;/strong> was begun by Kristian Hogsberg, an X.Org developer, as a personal project in 2008. &lt;a href="https://wayland.freedesktop.org/">It is a communication protocol&lt;/a> that specifies the communication between a display server and its clients. Wayland is developed as a free and open-source community-driven project with the aim of replacing the X Window System (also known as X11, or Xorg ) with a modern, secure, and simpler windowing system.
In Wayland, the compositor is the display server. &lt;strong>Compositor&lt;/strong>, is a window manager that provides applications with an off-screen buffer for each window. The window manager composites the window buffers into an image representing the screen and writes the result into the display memory.
The Wayland protocol lets the compositor send the input events directly to the clients and lets the client send the damage event directly to the compositor.
As in the X case, when the client receives the event it updates the user interface (UI) in response. But, in the Wayland rendering happens in the client, and the client just sends a request to the compositor to indicate the region that was updated.
Wayland’s main advantage over X is that it is starting from scratch. One of the main reasons for X’s complexity is that, over the years, its role has changed. As a result, today, X11 acts largely as “a really terrible” communications protocol between the client and the window manager.
Wayland is also superior when it comes to security. With X11, it’s possible to do something known as “keylogging” by allowing any program to exist in the background and read what’s happening with other windows open in the X11 area. With Wayland this simply won’t happen, as each program works independently.&lt;/p>
&lt;h3 id="conclusion">Conclusion&lt;/h3>
&lt;p>However, the X Window System still has many advantages over Wayland. Even though Wayland eliminates most of the design flaws of the Xorg it has its own issues. Even though the Wayland project has been up for more than ten years things are not 100% stable. As of 2020, the majority of video games and graphics-intensive applications for Linux are still written for X11. Also, many closed-source graphics drivers, such as those for NVIDIA GPUs, do not yet offer complete support for Wayland.
X cannot last and Wayland, in many ways, is an improvement. But for now the vast majority of native applications that exist were written for Xorg. Until those apps are all ported, Xorg needs to be maintained. Wayland is not very stable yet, compared to Xorg.&lt;/p></description></item><item><title>Docs: VNC</title><link>https://desistdaydream.github.io/docs/11.%E5%A4%9A%E5%AA%92%E4%BD%93/%E5%9B%BE%E5%BD%A2%E5%A4%84%E7%90%86/Linux-%E5%9B%BE%E5%BD%A2%E5%A4%84%E7%90%86/VNC/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/11.%E5%A4%9A%E5%AA%92%E4%BD%93/%E5%9B%BE%E5%BD%A2%E5%A4%84%E7%90%86/Linux-%E5%9B%BE%E5%BD%A2%E5%A4%84%E7%90%86/VNC/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Virtual_Network_Computing">Wiki,VNC&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://github.com/rfbproto/rfbproto">GitHub 项目，rfbproto/rfbproto&lt;/a>(RFB 协议规范)&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>&lt;strong>Virtual Network Computing(虚拟网络计算，简称 VNC)&lt;/strong> 是一种图形桌面共享系统，VNC 使用 &lt;strong>RFB Protocol(远程帧缓冲协议)&lt;/strong> 以控制另一台计算机；它将键盘和鼠标输入从一台计算机传输到另一台计算机，通过网络中继更新显示器上的信息。&lt;/p>
&lt;p>VNC 是独立于平台的——有许多基于 GUI 的操作系统和 Java 的客户端和服务器。多个客户端可以同时连接到 VNC 服务器。该技术的流行用途包括远程技术支持和从家庭计算机访问工作计算机上的文件，反之亦然。&lt;/p>
&lt;p>为什么没法通过 VNC 连接物理机的 CLI，但是可以连接虚拟机的 CLI 呢？！在 &lt;a href="https://github.com/rfbproto/rfbproto/issues/18">rfbproto/rfbproto 的 #18 issue&lt;/a> 中倒是说了 QEMU 中内置了 VNC/RFB，并对该协议进行了一些修改以支持一些额外的功能&lt;/p>
&lt;h1 id="tigervnc">TigerVNC&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://github.com/TigerVNC/tigervnc">GitHub 项目，TigerVNC/tigernvc&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://tigervnc.org/">官网&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>TigerVNC 是 VNC 的高性能、平台无关的实现，是一个 C/S 架构应用程序，允许用户在远程机器上启动图形应用程序并与之交互。&lt;/p>
&lt;h2 id="安装-tigervnc">安装 TigerVNC&lt;/h2>
&lt;p>CentOS&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>yum install tigervnc-server
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Ubuntu&lt;/p>
&lt;h1 id="realvnc">RealVNC&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://www.realvnc.com/en/">官网&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote></description></item><item><title>Docs: X Window</title><link>https://desistdaydream.github.io/docs/11.%E5%A4%9A%E5%AA%92%E4%BD%93/%E5%9B%BE%E5%BD%A2%E5%A4%84%E7%90%86/Linux-%E5%9B%BE%E5%BD%A2%E5%A4%84%E7%90%86/X-Window/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/11.%E5%A4%9A%E5%AA%92%E4%BD%93/%E5%9B%BE%E5%BD%A2%E5%A4%84%E7%90%86/Linux-%E5%9B%BE%E5%BD%A2%E5%A4%84%E7%90%86/X-Window/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/X_Window_System_protocols_and_architecture">Wiki,X Window 系统协议和架构&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/X_window_manager">Wiki,X Window 管理器&lt;/a>&lt;/li>
&lt;li>&lt;a href="http://linux.vbird.org/linux_basic/0590xwindow.php">鸟哥的 Linux 私房菜,第二十三章、X Window&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>Unix Like 操作系统不是只能进行服务器的架设而已，在美编、排版、制图、多媒体应用上也是有其需要的。 这些需求都需要用到图形介面 (Graphical User Interface, GUI) 的操作的， 所以后来才有所谓的 X Window System 这玩意儿。那么为啥图形窗口介面要称为 X 呢？因为就英文字母来看 X 是在 W(indow) 后面，因此，人们就戏称这一版的窗口介面为 X (有下一版的新窗口之意)！&lt;/p>
&lt;p>事实上， X Window System 是个非常大的架构，他还用到网络功能呢！也就是说，其实 X 窗口系统是能够跨网络与跨操作系统平台的！&lt;/p>
&lt;h2 id="x-window-的发展简史">X Window 的发展简史&lt;/h2>
&lt;p>X Window 系统最早是由 MIT (Massachusetts Institute of Technology, 麻省理工学院) 在 1984 年发展出来的， 当初 X 就是在 Unix 的 System V 这个操作系统版本上面开发出来的。在开发 X 时，开发者就希望这个窗口介面不要与硬件有强烈的相关性，这是因为如果与硬件的相关性高，那就等於是一个操作系统了， 如此一来的应用性会比较局限。因此 X 在当初就是以应用程序的概念来开发的，而非以操作系统来开发。&lt;/p>
&lt;p>由於这个 X 希望能够透过网络进行图形介面的存取，因此发展出许多的 X 通讯协议，这些网络架构非常的有趣， 所以吸引了很多厂商加入研发，因此 X 的功能一直持续在加强！一直到 1987 年更改 X 版本到 X11 ，这一版 X 取得了明显的进步， 后来的窗口介面改良都是架构於此一版本，因此后来 X 窗口也被称为 X11 。这个版本持续在进步当中，到了 1994 年发布了新版的 X11R6 ，后来的架构都是沿用此一释出版本，所以后来的版本定义就变成了类似 1995 年的 X11R6.3 之类的样式。 (注 1)&lt;/p>
&lt;p>1992 年 XFree86 (&lt;a href="http://www.xfree86.org/">http://www.xfree86.org/&lt;/a>) 计画顺利展开， 该计画持续在维护 X11R6 的功能性，包括对新硬件的支持以及更多新增的功能等等。当初定名为 XFree86 其实是根据『 X + Free software + x86 硬件 』而来的呢。早期 Linux 所使用的 X Window 的主要核心都是由 XFree86 这个计画所提供的，因此，我们常常将 X 系统与 XFree86 挂上等号的说。&lt;/p>
&lt;p>不过由於一些授权的问题导致 XFree86 无法继续提供类似 GPL 的自由软件，后来 Xorg 基金会就接手 X11R6 的维护！ Xorg (&lt;a href="http://www.x.org/">http://www.x.org/&lt;/a>) 利用当初 MIT 发布的类似自由软件的授权， 将 X11R6 拿来进行维护，并且在 2004 年发布了 X11R6.8 版本，更在 2005 年后发表了 X11R7.x 版。 现在我们 CentOS 5.x 使用的 X 就是 Xorg 提供的 X11R7 喔！ 而这个 X11R6/X11R7 的版本是自由软件，因此很多组织都利用这个架构去设计他们的图形介面喔！包括 Mac OS X v10.3 也曾利用过这个架构来设计他们的窗口呢！我们的 CentOS 也是利用 Xorg 提供的 X11 啦！&lt;/p>
&lt;p>从上面的说明，我们可以知道的是：&lt;/p>
&lt;ul>
&lt;li>在 Unix Like 上面的图形使用者界面 (GUI) 被称为 X 或 X11；&lt;/li>
&lt;li>X11 是一个『软件』而不是一个操作系统；&lt;/li>
&lt;li>X11 是利用网络架构来进行图形介面的运行与绘制；&lt;/li>
&lt;li>较著名的 X 版本为 X11R6 这一版，目前大部分的 X 都是这一版演化出来的 (包括 X11R7)；&lt;/li>
&lt;li>现在大部分的 distribution 使用的 X 都是由 Xorg 基金会所提供的 X11 软件；&lt;/li>
&lt;li>X11 使用的是 MIT 授权，为类似 GPL 的自由软件授权方式。&lt;/li>
&lt;/ul>
&lt;h1 id="x-原理">X 原理&lt;/h1>
&lt;p>X Window system 是个利用网络架构的图形使用者接口软件，基本上是分成 X Server 与 X Client 两个元件而已喔！&lt;/p>
&lt;ol>
&lt;li>X Server 管理硬件&lt;/li>
&lt;li>X Client 则是应用程序。&lt;/li>
&lt;/ol>
&lt;p>在运行上，X Client 应用程序会将所想要呈现的画面告知 X Server ，最终由 X server 来将结果通过他所管理的硬件绘制出来！整体的架构我们大约可以使用如下的图示来作个介绍：[2]
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/qpbz9c/1616164721534-04137e6f-04ce-41e4-8b0a-2a4765c43e41.png" alt="">
上面的图示非常有趣喔！我们在用户端想要取得来自服务器的图形数据时，我们用户端使用的当然是用户端的硬件设备啊， 所以，X Server 的重点就是在管理用户端的硬件，包括接受键盘/鼠标等设备的输入信息， 并且将图形绘制到屏幕上（请注意上图的所有元件之间的箭头指示）。但是到底要绘制个啥东西呢？绘图总是需要一些数据才能绘制吧？此时 X Client(就是 X 应用程序) 就很重要啦！他主要提供的就是告知 X Server 要绘制啥东西。那照这样的想法来思考，我们是想要取得远端服务器的绘图数据来我们的计算机上面显示嘛！所以啰，远端服务器提供的是 X client 软件啊！&lt;/p>
&lt;p>注意：在 X Window 环境中的 C/S 架构与通常意义上的 C/S 架构不太一样，有点反着来的感觉。&lt;/p>
&lt;h2 id="x-server--硬件管理屏幕绘制与提供字体功能">X Server # 硬件管理、屏幕绘制与提供字体功能&lt;/h2>
&lt;p>既然 X Window System 是要显示图形接口，因此理所当然的需要一个元件来管理我主机上面的所有硬件设备才行！这个任务就是 X Server 所负责的。而我们在 X 发展简史当中提到的 XFree86 计划及 Xorg 基金会，主要提供的就是这个 X Server 啦！那么 X Server 管理的设备主要有哪些呢？其实与输入/输出有关喔！包括键盘、鼠标、手写板、显示器（monitor） 、屏幕分辨率与色彩深度、显卡（包含驱动程序） 与显示的字体等等，都是 X Server 管理的。&lt;/p>
&lt;p>咦！显卡、屏幕以及键盘鼠标的设置，不是在开机的时候 Linux 系统以 systemd 的相关设置处理好了吗？为何 X Server 还要重新设置啊？这是因为 X Window 在 Linux 里面仅能算是“一套很棒的软件”， 所以 X Window 有自己的配置文件，你必须要针对他的配置文件设置妥当才行。也就是说， Linux 的设置与 X Server 的设置不一定要相同的！因此，你在 CentOS 7 的 multi-user.target 想要玩图形接口时，就得要载入 X Window 需要的驱动程序才行～总之， X Server 的主要功能就是在管理“主机”上面的显示硬件与驱动程序。&lt;/p>
&lt;p>既然 X Window System 是以通过网络取得图形接口的一个架构，那么用户端是如何取得服务器端提供的图形画面呢？由于服务器与用户端的硬件不可能完全相同，因此我们用户端当然不可能使用到服务器端的硬件显示功能！举例来说，你的用户端计算机并没有 3D 影像加速功能，那么你的画面可能呈现出服务器端提供的 3D 加速吗？当然不可能吧！所以啰 X Server 的目的在管理用户端的硬件设备！也就是说：“每部用户端主机都需要安装 X Server，而服务器端则是提供 X Client 软件， 以提供用户端绘图所需要的数据数据”。&lt;/p>
&lt;p>X Server/X Client 的互动并非仅有 client &amp;ndash;&amp;gt; server，两者其实有互动的！从上图 23.1.1 我们也可以发现， X Server 还有一个重要的工作，那就是将来自输入设备（如键盘、鼠标等） 的动作告知 X Client， 你晓得， X Server 既然是管理这些周边硬件，所以，周边硬件的动作当然是由 X Server 来管理的， 但是 X Server 本身并不知道周边设备这些动作会造成什么显示上的效果， 因此 X Server 会将周边设备的这些动作行为告知 X Client ，让 X Client 去伤脑筋。&lt;/p>
&lt;h2 id="x-client--负责-x-server-要求的事件之处理">X Client # 负责 X Server 要求的“事件”之处理&lt;/h2>
&lt;p>前面提到的 X Server 主要是管理显示接口与在屏幕上绘图，同时将输入设备的行为告知 X Client， 此时 X Client 就会依据这个输入设备的行为来开始处理，最后 X Client 会得到“ 嗯！这个输入设备的行为会产生某个图示”，然后将这个图示的显示数据回传给 X Server ， X server 再根据 X Client 传来的绘图数据将他描图在自己的屏幕上，来得到显示的结果。&lt;/p>
&lt;p>也就是说， X Client 最重要的工作就是处理来自 X Server 的动作，将该动作处理成为绘图数据， 再将这些绘图数据传回给 X Server 啰！由于 X Client 的目的在产生绘图的数据，因此我们也称呼 X Client 为 X Application(X 应用程序)。而且，每个 X Client 并不知道其他 X Client 的存在， 意思是说，如果有两个以上的 X client 同时存在时，两者并不知道对方到底传了什么数据给 X Server ， 因此 X Client 的绘图常常会互相重叠而产生困扰喔！&lt;/p>
&lt;p>举个例子来说，当我们在 X Window 的画面中，将鼠标向右移动，那他是怎么告知 X Server 与 X Client 的呢？首先， X server 会侦测到鼠标的移动，但是他不知道应该怎么绘图啊！此时，他将鼠标的这个动作告知 X Client， X Client 就会去运算，结果得到，嘿嘿！其实要将鼠标指标向右移动几个像素，然后将这个结果告知 X server ， 接下来，您就会看到 X Server 将鼠标指标向右移动啰～&lt;/p>
&lt;p>这样做有什么好处啊？最大的好处是， X Client 不需要知道 X Server 的硬件配备与操作系统！因为 X Client 单纯就是在处理绘图的数据而已，本身是不绘图的。所以，在用户端的 X Server 用的是什么硬件？用的是哪套操作系统？服务器端的 X Client 根本不需要知道～相当的先进与优秀～对吧！^_^ 整个运行流程可以参考下图：用户端用的是什么操作系统在 Linux 主机端是不在乎的！
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/qpbz9c/1622302517121-61886ebd-b390-479f-a848-0558c2909ded.gif" alt="">
图 23.1.2、X Server 用户端的操作系统与 X client 的沟通示意&lt;/p>
&lt;h2 id="x-window-manager--特殊的-x-client-负责管理所有的-x-client-软件">X Window Manager # 特殊的 X Client ，负责管理所有的 X client 软件&lt;/h2>
&lt;p>刚刚前面提到，X Client 的主要工作是将来自 X Server 的数据处理成为绘图数据，再回传给 X Server 而已， 所以 X Client 本身是不知道他在 X Server 当中的位置、大小以及其他相关信息的。这也是上面我们谈到的， X Client 彼此不知道对方在屏幕的哪个位置啊！为了克服这个问题，因此就有 Window Manager(窗口管理器) 的产生了。窗口管理器也是 X client ，只是他主要在负责全部 X client 的控管，还包括提供某些特殊的功能，例如：&lt;/p>
&lt;ul>
&lt;li>提供许多的控制元素，包括工作列、背景桌面的设置等等；&lt;/li>
&lt;li>管理虚拟桌面（virtual desktop）；&lt;/li>
&lt;li>提供窗口控制参数，这包括窗口的大小、窗口的重叠显示、窗口的移动、窗口的最小化等等。&lt;/li>
&lt;/ul>
&lt;p>当 X Window Manager 开始运作时，&lt;a href="https://zh.wikipedia.org/wiki/X_Window%E7%B3%BB%E7%B5%B1%E7%9A%84%E5%8D%94%E8%AD%B0%E5%92%8C%E6%9E%B6%E6%A7%8B">X-Server&lt;/a> 和 X-Client 之间的交互，会重定向 X Window Manager。每当要显示一个新视窗时，这个请求便会被重定向到 X Window Manager，它会决定视窗的初始位置。此外，大部分较新的 X Window Manager 会改变视窗的亲属关系，通常会在视窗顶部加上标题栏，并在视窗周围加上装饰性的框架。这两个部分皆由视窗管理器来控制，而不是其它程序。因此，当用户点击或拖曳那些组件时，X Window Manager 会进行适当的动作（如移动或改变视窗的大小）。&lt;/p>
&lt;p>X Window Manager 也负责处理&lt;a href="https://zh.wikipedia.org/wiki/%E5%9C%96%E7%A4%BA">图标&lt;/a>，图标并不存在于 &lt;a href="https://zh.wikipedia.org/wiki/X_Window%E6%A0%B8%E5%BF%83%E5%8D%94%E8%AD%B0">X Window 核心协议&lt;/a>的层次中。当用户将视窗最小化时，X Window Manager 会取消视窗的映射（使其不可见），并完成适当的动作，将视窗改显示成图标。某些 X Window Manager 并不支持图标功能。&lt;/p>
&lt;p>X Window Manager 主要的目标，就如同其名，是用来管理视窗的。许多 X Window Manager 提供附加的功能，如处理鼠标在&lt;a href="https://zh.wikipedia.org/w/index.php?title=%E6%A0%B9%E8%A6%96%E7%AA%97&amp;amp;action=edit&amp;amp;redlink=1">根视窗&lt;/a>上的点击，呈现出窗格以及其它的可视化组件，处理按键（例如 Alt-F4 可关闭视窗），判定哪一个应用程序在引导时运行等等。&lt;/p>
&lt;p>我们常常听到的 KDE, GNOME, XFCE 还有阳春到爆的 twm 等等，都是一些窗口管理员的专案计划啦！这些专案计划中，每种窗口管理员所用以开发的显示发动机都不太相同，所著重的方向也不一样， 因此我们才会说，在 Linux 下面，每套 Window Manager 都是独特存在的，不是换了桌面与显示效果而已， 而是连显示的发动机都不会一样喔！下面是这些常见的 Window Manager 全名与链接：&lt;/p>
&lt;ul>
&lt;li>&lt;strong>GNU Network Object Model Environment(简称 GNOME)&lt;/strong>：&lt;a href="http://www.gnome.org/">http://www.gnome.org/&lt;/a>&lt;/li>
&lt;li>&lt;strong>K Desktop Enviroment(简称 KDE)&lt;/strong>：&lt;a href="http://kde.org/">http://kde.org/&lt;/a>&lt;/li>
&lt;li>&lt;strong>Tab Window Manager(简称 TWM)&lt;/strong>：&lt;a href="http://xwinman.org/vtwm.php">http://xwinman.org/vtwm.php&lt;/a>&lt;/li>
&lt;li>&lt;strong>XForms Common Environment(简称 XFCE)&lt;/strong>：&lt;a href="http://www.xfce.org/">http://www.xfce.org/&lt;/a>&lt;/li>
&lt;/ul>
&lt;p>由于 Linux 越来越朝向 Desktop 桌面电脑使用方向走，因此窗口管理员的角色会越来越重要！目前我们 CentOS 默认提供的有 GNOME 与 KDE ，这两个窗口管理员上面还有提供非常多的 X client 软件， 包括办公室生产力软件（Open Office） 以及常用的网络功能（firefox 浏览器、 Thunderbird 收发信件软件） 等。现在使用者想要接触 Linux 其实真的越来越简单了，如果不要架设服务器，那么 Linux 桌面的使用与 Windows 系统可以说是一模一样的！不需要学习也能够入门哩！^_^&lt;/p>
&lt;p>那么你知道 X Server / X client / window manager 的关系了吗？我们举 CentOS 默认的 GNOME 为例好了， 由于我们要在本机端启动 X Window system ，因此，在我们的 CentOS 主机上面必须要有 Xorg 的 X server 核心， 这样才能够提供屏幕的绘制啊～然后为了让窗口管理更方便，于是就加装了 GNOME 这个计划的 window manager ， 然后为了让自己的使用更方便，于是就在 GNOME 上面加上更多的窗口应用软件，包括输入法等等的， 最后就建构出我们的 X Window System 啰～ ^_^！所以你也会知道，X server/X client/Window Manager 是同时存在于我们一部 Linux 主机上头的啦！&lt;/p>
&lt;h3 id="display-manager--提供登陆需求">Display Manager # 提供登陆需求&lt;/h3>
&lt;p>谈完了上述的数据后，我们得要了解一下，那么我如何取得 X Window 的控制？在本机的命令行下面你可以输入 startx 来启动 X 系统，此时由于你已经登陆系统了，因此不需要重新登陆即可取得 X 环境。但如果是 graphical.target 的环境呢？你会发现在 tty1 或其他 tty 的地方有个可以让你使用图形接口登陆（输入帐号密码） 的咚咚，那个是啥？是 X Server/X client 还是什么的？其实那是个 Display Manager 啦！这个 display manager 最大的任务就是提供登陆的环境， 并且载入使用者选择的 Window Manager 与语系等数据喔！&lt;/p>
&lt;p>几乎所有的大型窗口管理员专案计划都会提供 display manager 的，在 CentOS 上面我们主要利用的是 GNOME 的 GNOME Display Manager(gdm) 这支程序来提供 tty1 的图形接口登陆喔！至于登陆后取得的窗口管理员，则可以在 gdm 上面进行选择的！我们在第四章介绍的登陆环境，那个环境其实就是 gdm 提供的啦！再回去参考看看图示吧！^_^！所以说，并非 gdm 只能提供 GNOME 的登陆而已喔！&lt;/p>
&lt;ul>
&lt;li>GDM3 # GNOME 管理器&lt;/li>
&lt;li>KDM # KDE 管理器&lt;/li>
&lt;li>LightDM&lt;/li>
&lt;/ul>
&lt;h2 id="xdmcp--x-显示管理控制协议">XDMCP # X 显示管理控制协议&lt;/h2>
&lt;p>当 X server, X client 都在同一部主机上面的时候，你可以很轻松的启动一个完整的 X Window System。但是如果你想要透过这个机制在网络上面启动 X 呢？此时你得先在客户端启动一个 X server 将图形接口绘图所需要的硬件装置配置好， 并且启动一个 X server 常见的接收埠口(通常是 port 6000)，然后再由服务器端的 X client 取得绘图数据，再将数据绘制成图啰。透过这个机制，你可以在任何一部启动 X server 登入服务器喔！而且不管你的操作系统是啥呢！意义就像下图， 如此一来，你就可以取得服务器所提供的图形接口环境啦！
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/qpbz9c/1622307045187-e725761e-968e-455a-bdf4-797f37215985.png" alt="">
但是如果你是使用最笨的方法在客户端自己启动 X server ，然后在告诉服务器将 X client 程序一个一个的加载回来，那就太累人了吧！我们之前上面不是提到过可以用 display manager 来管理使用者的登入与启动 X 吗？那服务器能不能提供一个类似的服务，那我们直接透过服务器的 display manager 就能够提供我们登入的认证与加载自己选择的 window manager 的话，这样就太棒了！能够达到吗？当然可以啊！那就是透过 Xdmcp (X display manager control protocol) (&lt;a href="http://cn.linux.vbird.org/linux_server/0310telnetssh_3.php#ps3">注 3&lt;/a> )啦！&lt;/p>
&lt;p>Xdmcp 启动后会在服务器的 udp 177 开始监听，然后当客户端的 X server 联机到服务器的 port 177 之后， 我们的 Xdmcp 就会在客户端的 X server 放上用户输入账密的图形接口程序啰！那你就能透过这个 Xdmcp 去加载服务器所提供的类似 Window Manager 的相关 X client 啰！那你就能够取得图形接口的远程联机服务器哩！赞吧！&lt;/p>
&lt;p>那么什么时候会出现多使用者连入服务器取得 X 的情况呢？以鸟哥的例子来说，鸟哥实验室有一组 Linux 在进行数值模拟，他输出的结果是 NetCDF 档案，我们必须使用 PAVE 这一套软件去处理这些数据。但是我们有两三个人同时都会使用到那个功能，偏偏 Linux 主机是放在机架柜里面的，要我们挤在那个小小的空间前面『站着』操作计算机，可真是讨人厌啊～这个时候，我们就会架设图形接口的远程登录服务器，让我们可以『多人同时以图形接口登入 Linux 主机』来操作我们自己的程序！很棒，不是吗！&lt;/p>
&lt;h2 id="x-serverx-clientx-window-manager-之间的关系">X Server、X Client、X Window Manager 之间的关系&lt;/h2>
&lt;p>X Server、X Client、X Window Manager 之间的关系很像操作系统与应用程序之间的关系。很早之前，一台电脑只能运行一个程序，就好比只能运行 一个 X Client。所以，为了同时运行多个程序，就产生了操作系统。而为了同时打开多个图形界面，也就产生了 X Window Manager。&lt;/p>
&lt;h1 id="x-的安装">X 的安装&lt;/h1>
&lt;h2 id="x-server-安装">x Server 安装&lt;/h2>
&lt;p>yum install xorg-x11-xauth xorg-x11-server-utils&lt;/p>
&lt;p>有了服务端之后，一些简单的 X 程序就可以通过 X client 打开了。&lt;/p>
&lt;p>Node：xorg-x11-xinit 包含 xorg-x11-xauth xorg-x11-server-utils 这两个包，有时候安装 xorg-x11-xinit 即可&lt;/p>
&lt;p>X server 安装完成后，可以安装 xorg-x11-apps 包，这里面有一些 x 程序，可以测试系统的图形接口。&lt;/p>
&lt;p>Note: 在 centos8 下安装 apps 包，需要先开启 PowerTools 库(yum config-manager &amp;ndash;set-enabled PowerTools)&lt;/p>
&lt;ul>
&lt;li>/usr/bin/luit&lt;/li>
&lt;li>/usr/bin/oclock&lt;/li>
&lt;li>/usr/bin/x11perf&lt;/li>
&lt;li>/usr/bin/x11perfcomp&lt;/li>
&lt;li>/usr/bin/xbiff&lt;/li>
&lt;li>/usr/bin/xclipboard&lt;/li>
&lt;li>/usr/bin/xclock&lt;/li>
&lt;li>/usr/bin/xconsole&lt;/li>
&lt;li>/usr/bin/xcursorgen&lt;/li>
&lt;li>/usr/bin/xcutsel&lt;/li>
&lt;li>/usr/bin/xdpr&lt;/li>
&lt;li>/usr/bin/xeyes&lt;/li>
&lt;li>/usr/bin/xfd&lt;/li>
&lt;li>/usr/bin/xfontsel&lt;/li>
&lt;li>/usr/bin/xload&lt;/li>
&lt;li>/usr/bin/xlogo&lt;/li>
&lt;li>/usr/bin/xmag&lt;/li>
&lt;li>/usr/bin/xmessage&lt;/li>
&lt;li>/usr/bin/xpr&lt;/li>
&lt;li>/usr/bin/xvidtune&lt;/li>
&lt;li>/usr/bin/xwd&lt;/li>
&lt;li>/usr/bin/xwud&lt;/li>
&lt;/ul>
&lt;h2 id="x-client-安装">X Client 安装&lt;/h2>
&lt;ol>
&lt;li>xshell 工具在官方提供了一个 Xmanager 的软件，该软件可以作为 X Client 所用。&lt;/li>
&lt;/ol>
&lt;h2 id="heading">&lt;/h2></description></item><item><title>Docs: Xrdp</title><link>https://desistdaydream.github.io/docs/11.%E5%A4%9A%E5%AA%92%E4%BD%93/%E5%9B%BE%E5%BD%A2%E5%A4%84%E7%90%86/Linux-%E5%9B%BE%E5%BD%A2%E5%A4%84%E7%90%86/Xrdp/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/11.%E5%A4%9A%E5%AA%92%E4%BD%93/%E5%9B%BE%E5%BD%A2%E5%A4%84%E7%90%86/Linux-%E5%9B%BE%E5%BD%A2%E5%A4%84%E7%90%86/Xrdp/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://github.com/neutrinolabs/xrdp">GitHub 项目，neutrinolabs/xrdp&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://tecadmin.net/how-to-install-xrdp-on-ubuntu-20-04/">https://tecadmin.net/how-to-install-xrdp-on-ubuntu-20-04/&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>&lt;strong>XRDP&lt;/strong> 使用 &lt;strong>Microsoft 的 Remote Desktop Protocol(远程桌面协议，简称 RDP)&lt;/strong> 提供了一个图形界面以登录到计算机。XRDP 接受来自各种 RDP 客户端的连接。比如：&lt;/p>
&lt;ul>
&lt;li>FreeRDP&lt;/li>
&lt;li>rdesktop&lt;/li>
&lt;li>KRDC&lt;/li>
&lt;li>NeutrinoRDP&lt;/li>
&lt;li>Windows MSTSC (Microsoft Terminal Services Client, aka mstsc.exe)&lt;/li>
&lt;li>Microsoft Remote Desktop (found on Microsoft Store, which is distinct from MSTSC)&lt;/li>
&lt;/ul>
&lt;p>XRDP 主要针对 Linux 操作系统，可以让 Windows，使用其自带的远程桌面，通过 RDP 协议，远程控制装有 XRDP 的 Linux 系统，以实现远程图形化控制。&lt;/p>
&lt;h1 id="为-ubuntu-安装-xrdp">为 Ubuntu 安装 Xrdp&lt;/h1>
&lt;p>远程桌面协议允许用户访问远程系统桌面。 XRDP 服务向您提供使用 Microsoft RDP（远程桌面协议）的远程计算机的图形登录。 XRDP 还支持双向剪贴板传输（文本，位图，文件），音频重定向和驱动器重定向（在远程计算机上安装本地客户端驱动器）。
XRDP 是 Ubuntu 系统的易于安装和可配置的服务。但您还可以使用 VNC Server 访问 Ubuntu 系统的远程桌面。在 Ubuntu 20.04 系统上找到安装 VNC 服务器的教程。
本教程可帮助您在 Ubuntu 20.04 Linux 系统上安装远程桌面（XRDP）。还提供在系统上安装桌面环境的说明。&lt;/p>
&lt;h2 id="安装桌面环境">安装桌面环境&lt;/h2>
&lt;p>默认情况下，Ubuntu Server 没有已安装的桌面环境。 XRDP 服务器旨在仅控制桌面系统。因此，您需要向系统添加桌面环境。
使用 &lt;code>tasksel&lt;/code> 工具安装桌面环境&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>sudo apt update &lt;span style="color:#f92672">&amp;amp;&amp;amp;&lt;/span> sudo apt upgrade
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>apt install tasksel -y
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>安装 Tasksel 后，使用命令 &lt;code>tasksel&lt;/code> 启动程序：&lt;/p>
&lt;p>应该看到以下界面：
&lt;a href="https://tecadmin.net/wp-content/uploads/2020/11/tasksel-ubuntu-desktop.png">&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/ff73o6/1630033188975-4b9f059c-5f81-4263-8965-bb83636058bf.png" alt="image.png">&lt;/a>
使用箭头键向下滚动列表并查找 &lt;code>Ubuntu minimal desktop&lt;/code>。接下来，按空格键选择它，然后按 Tab 键选择确定，然后按 Enter 安装 &lt;code>Ubuntu minimal desktop&lt;/code> 桌面。&lt;/p>
&lt;p>安装所有包后，&lt;code>reboot&lt;/code> 重启操作系统&lt;/p>
&lt;h2 id="安装-xrdp-包">安装 xrdp 包&lt;/h2>
&lt;p>XRDP 软件包可在默认系统存储库下提供。您可以通过执行以下命令在 Ubuntu 系统上安装远程桌面。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>sudo apt install xrdp -y
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="配置-xrdp">配置 XRDP&lt;/h2>
&lt;p>在安装过程中，XRDP 在您的系统中添加了名为“XRDP”的系统中的用户。 XRDP 会话使用证书密钥文件“/etc/sl/private/ssl-cert-snakeoil.key”，它与远程桌面播放一个重要的角色。
要正确工作，请使用以下命令将 XRDP 用户添加到“SSL-Cert”组。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>sudo usermod -a -G ssl-cert xrdp
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>有时用户面临黑屏的问题出现在后台。因此，我是一个介绍在背景中解析黑屏问题的步骤。在文本编辑器中编辑 XRDP 文件 /etc/xrdp/startwm.sh：&lt;/p>
&lt;p>在 测试 和执行 XSession 的命令之间添加这些命令:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>Unset DBUS_SESSION_ADDRESS
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Unset XDG_RUNTIME_DIR
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>如下所示：
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/ff73o6/1630060168909-03b02b6b-c076-479b-ab43-ccad7d2993ff.png" alt="image.png">
通过运行下面给出的命令重新启动 XRDP 服务：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>sudo systemctl restart xrdp
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="连接到远程桌面">连接到远程桌面&lt;/h2>
&lt;p>xrdp 默认监听 3389 端口，防火墙放通该端口&lt;/p>
&lt;p>XRDP 服务已成功安装并准备连接。在 Windows 客户端上，打开 RDP 客户端并输入 Ubuntu 系统的 IP 地址。&lt;/p>
&lt;p>您可以通过在运行窗口或命令行中键入“mstsc”来启动 RDP 客户端。
&lt;a href="https://tecadmin.net/wp-content/uploads/2021/06/connect-xrdp.png">&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/ff73o6/1630033188968-627c5a91-5c70-4d84-8b6d-5513705883ad.png" alt="image.png">&lt;/a>
一旦连接成功，远程系统提示用于身份验证。输入远程 Ubuntu 系统的登录凭据以获取远程桌面访问。
&lt;a href="https://tecadmin.net/wp-content/uploads/2021/06/xrdp-enter-login-credentials.png">&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/ff73o6/1630033190060-961f359c-adbe-4058-84fc-fa92a0ff780e.png" alt="image.png">&lt;/a>&lt;/p>
&lt;h1 id="xrdp-配置">Xrdp 配置&lt;/h1>
&lt;p>&lt;strong>/etc/xrdp/*&lt;/strong> #&lt;/p>
&lt;ul>
&lt;li>&lt;strong>./sesman.ini&lt;/strong> #&lt;/li>
&lt;li>&lt;strong>./xrdp.ini&lt;/strong> #&lt;/li>
&lt;/ul>
&lt;h1 id="ubuntu-desktop-可能需要优化的地方">Ubuntu Desktop 可能需要优化的地方&lt;/h1>
&lt;h2 id="sorry-that-didnt-work-please-try-again抱歉登录失败请再试一次-问题">sorry, that didn’t work please try again(抱歉，登录失败，请再试一次) 问题&lt;/h2>
&lt;p>注释掉下面文件文件中 &lt;code>auth required pam_succeed_if.so user != root quiet_success&lt;/code> 这一行&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>sudo sed -i.bak &lt;span style="color:#e6db74">&amp;#39;s/^auth.*quiet_success/#&amp;amp;/&amp;#39;&lt;/span> /etc/pam.d/gdm-autologin
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>sudo sed -i.bak &lt;span style="color:#e6db74">&amp;#39;s/^auth.*quiet_success/#&amp;amp;/&amp;#39;&lt;/span> /etc/pam.d/gdm-password
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="关闭-ubuntu-2004-的桌面动画效果">关闭 Ubuntu 20.04 的桌面动画效果&lt;/h2>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>gsettings set org.gnome.desktop.interface enable-animations false
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>注意：改命令仅对当前用户生效。&lt;/p>
&lt;h2 id="xrdp_mm_process_login_response-login-failed">xrdp_mm_process_login_response: login failed&lt;/h2>
&lt;p>问题原因：远程桌面没有正确关闭，虽然在 windows 系统关闭远程桌面连接，但是在里 linux 上的进程还在运行，导致连接数量达到上限，出现问题。&lt;/p>
&lt;p>解决：通过设置 sesman.in 文件内的参数解决：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>sudo sed -i.bak &lt;span style="color:#e6db74">&amp;#39;s/KillDisconnected=false/KillDisconnected=true/&amp;#39;&lt;/span> /etc/xrdp/sesman.ini
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>可以修改会话设置 ：将最大会话限制该大 MaxSessions=50; 将 KillDisconnected=1；则每次断开连接时，linux 都会关闭会话进程。 然后重启/etc/init.d/xrdp restart 就可解决问题&lt;/p>
&lt;h2 id="其他未知问题">其他未知问题&lt;/h2>
&lt;p>sudo sed -i.bak &amp;ldquo;4 a # Improved Look n Feel Method\ncat &amp;laquo;EOF &amp;gt; ~/.xsessionrc\nexport GNOME_SHELL_SESSION_MODE=ubuntu\nexport XDG_CURRENT_DESKTOP=ubuntu:GNOME\nexport XDG_CONFIG_DIRS=/etc/xdg/xdg-ubuntu:/etc/xdg\nEOF\n&amp;rdquo; /etc/xrdp/startwm.sh&lt;/p>
&lt;p>sudo sed -i &amp;rsquo;s/allowed_users=console/allowed_users=anybody/&amp;rsquo; /etc/X11/Xwrapper.config[&lt;/p>
&lt;p>](https://blog.csdn.net/u014447845/article/details/80291678)
在 /etc/profile.d/ 目录中添加 &lt;code>source &amp;lt;(kubectl completion bash)&lt;/code> 这种命令会导致 xrdp 登录失败，现象是输入完用户名和密码之后就闪退。
[&lt;/p>
&lt;p>](https://blog.csdn.net/u014447845/article/details/80291678)&lt;/p></description></item></channel></rss>