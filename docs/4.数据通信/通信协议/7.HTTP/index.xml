<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>断念梦 – 7.HTTP</title><link>https://desistdaydream.github.io/docs/4.%E6%95%B0%E6%8D%AE%E9%80%9A%E4%BF%A1/%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/7.HTTP/</link><description>Recent content in 7.HTTP on 断念梦</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><atom:link href="https://desistdaydream.github.io/docs/4.%E6%95%B0%E6%8D%AE%E9%80%9A%E4%BF%A1/%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/7.HTTP/index.xml" rel="self" type="application/rss+xml"/><item><title>Docs: 7.HTTP</title><link>https://desistdaydream.github.io/docs/4.%E6%95%B0%E6%8D%AE%E9%80%9A%E4%BF%A1/%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/7.HTTP/7.HTTP/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/4.%E6%95%B0%E6%8D%AE%E9%80%9A%E4%BF%A1/%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/7.HTTP/7.HTTP/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://tools.ietf.org/html/rfc2616">RFC 2616&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://developer.mozilla.org/en-US/docs/Web/HTTP">Mozilla 官方 HTTP 开发文档&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://mp.weixin.qq.com/s/bUy220-ect00N4gnO0697A">公众号-小林 coding，硬核！30 张图解 HTTP 常见的面试题&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://mp.weixin.qq.com/s/WQpxfwLArltKEjEAdOO2Pw">公众号-码海，51 张图助你彻底掌握 HTTP 协议&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>&lt;strong>HyperText Transfer Protocol(超文本传输协议，简称 HTTP)&lt;/strong>。是基于 TCP 的用于分布式、协作式、超媒体的信息系统的应用层协议。HTTP 是 &lt;a href="https://en.wikipedia.org/wiki/World_Wide_Web">World Wide Web(万维网,简称 WWW.就是我们俗称的 Web)&lt;/a> 的数据通信基础。&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/rlkp9t/1616161240441-f2958719-b738-4698-9fca-64d90f3471ba.png" alt="">&lt;/p>
&lt;h2 id="http-标准的演化">HTTP 标准的演化&lt;/h2>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://www.infoq.cn/article/2014/06/http-11-updated">InfoQ 中的消息&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>在 2014 年之前，HTTP/1.1 版本的标准为 &lt;a href="https://tools.ietf.org/html/rfc2616">RFC 2616&lt;/a>，但由于&lt;a href="https://tools.ietf.org/html/rfc7230#appendix-A.2">某些原因&lt;/a>，为了让标准更规范，HTTP/1.1 被拆分成了 6 个部分：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://tools.ietf.org/html/rfc7230">RFC7230 - HTTP/1.1&lt;/a>: Message Syntax and Routing(消息语法和路由)。这里包含 低级的消息解析 和 链接管理。&lt;/li>
&lt;li>&lt;a href="https://tools.ietf.org/html/rfc7231">RFC7231 - HTTP/1.1&lt;/a>: Semantics and Content(语意和内容)。这里面包含了 Methods、Status Codes、Headers&lt;/li>
&lt;li>RFC7232 - HTTP/1.1: Conditional Requests - e.g., If-Modified-Since&lt;/li>
&lt;li>RFC7233 - HTTP/1.1: Range Requests - getting partial content&lt;/li>
&lt;li>RFC7234 - HTTP/1.1: Caching - browser and intermediary caches&lt;/li>
&lt;li>RFC7235 - HTTP/1.1: Authentication - a framework for HTTP authentication&lt;/li>
&lt;/ul>
&lt;h2 id="http-三个部分">HTTP 三个部分&lt;/h2>
&lt;h3 id="1-协议">1. 「协议」&lt;/h3>
&lt;p>在生活中，我们也能随处可见「协议」，例如：&lt;/p>
&lt;ul>
&lt;li>刚毕业时会签一个「三方协议」；&lt;/li>
&lt;li>找房子时会签一个「租房协议」；&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/rlkp9t/1616161240448-b1263f75-a700-4431-9d6b-a99b36a58214.png" alt="">&lt;/p>
&lt;p>三方协议和租房协议&lt;/p>
&lt;p>生活中的协议，本质上与计算机中的协议是相同的，协议的特点:&lt;/p>
&lt;ul>
&lt;li>「&lt;strong>协&lt;/strong>」字，代表的意思是必须有&lt;strong>两个以上的参与者&lt;/strong>。例如三方协议里的参与者有三个：你、公司、学校三个；租房协议里的参与者有两个：你和房东。&lt;/li>
&lt;li>「&lt;strong>议&lt;/strong>」字，代表的意思是对参与者的一种&lt;strong>行为约定和规范&lt;/strong>。例如三方协议里规定试用期期限、毁约金等；租房协议里规定租期期限、每月租金金额、违约如何处理等。&lt;/li>
&lt;/ul>
&lt;p>针对 HTTP &lt;strong>协议&lt;/strong>，我们可以这么理解。&lt;/p>
&lt;p>HTTP 是一个用在计算机世界里的&lt;strong>协议&lt;/strong>。它使用计算机能够理解的语言确立了一种计算机之间交流通信的规范（&lt;strong>两个以上的参与者&lt;/strong>），以及相关的各种控制和错误处理方式（&lt;strong>行为约定和规范&lt;/strong>）。&lt;/p>
&lt;h3 id="2-传输">2. 「传输」&lt;/h3>
&lt;p>所谓的「传输」，很好理解，就是把一堆东西从 A 点搬到 B 点，或者从 B 点 搬到 A 点。&lt;/p>
&lt;p>别轻视了这个简单的动作，它至少包含两项重要的信息。&lt;/p>
&lt;p>HTTP 协议是一个&lt;strong>双向协议&lt;/strong>。&lt;/p>
&lt;p>我们在上网冲浪时，浏览器是请求方 A ，百度网站就是应答方 B。双方约定用 HTTP 协议来通信，于是浏览器把请求数据发送给网站，网站再把一些数据返回给浏览器，最后由浏览器渲染在屏幕，就可以看到图片、视频了。
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/rlkp9t/1616161240434-514ef4d5-6830-46f1-9674-7c6564798dfd.png" alt="">&lt;/p>
&lt;p>Request(请求) - (Response)应答&lt;/p>
&lt;p>数据虽然是在 A 和 B 之间传输，但允许中间有&lt;strong>中转或接力&lt;/strong>。&lt;/p>
&lt;p>就好像第一排的同学想传递纸条给最后一排的同学，那么传递的过程中就需要经过好多个同学（中间人），这样的传输方式就从「A &amp;lt; &amp;mdash; &amp;gt; B」，变成了「A &amp;lt;-&amp;gt; N &amp;lt;-&amp;gt; M &amp;lt;-&amp;gt; B」。&lt;/p>
&lt;p>而在 HTTP 里，需要中间人遵从 HTTP 协议，只要不打扰基本的数据传输，就可以添加任意额外的东西。&lt;/p>
&lt;p>针对&lt;strong>传输&lt;/strong>，我们可以进一步理解了 HTTP。&lt;/p>
&lt;p>HTTP 是一个在计算机世界里专门用来在&lt;strong>两点之间传输数据&lt;/strong>的约定和规范。&lt;/p>
&lt;h3 id="3-超文本">3. 「超文本」&lt;/h3>
&lt;p>HTTP 传输的内容是「超文本」。&lt;/p>
&lt;p>我们先来理解「文本」，在互联网早期的时候只是简单的字符文字，但现在「文本」的涵义已经可以扩展为图片、视频、压缩包等，在 HTTP 眼里这些都算作「文本」。&lt;/p>
&lt;p>再来理解「超文本」，它就是&lt;strong>超越了普通文本的文本&lt;/strong>，它是文字、图片、视频等的混合体，最关键有超链接，能从一个超文本跳转到另外一个超文本。&lt;/p>
&lt;p>HTML 格式的文件就是最常见的超文本了，它本身只是纯文字文件，但内部用很多标签定义了图片、视频等的链接，再经过浏览器的解释，呈现给我们的就是一个文字、有画面的网页了。&lt;/p>
&lt;h2 id="总结">总结&lt;/h2>
&lt;p>OK，经过了对 HTTP 里这三个名词的详细解释，就可以给出比「超文本传输协议」这七个字更准确更有技术含量的答案：&lt;/p>
&lt;p>&lt;strong>HTTP 是一个在计算机世界里专门在「两点」之间「传输」文字、图片、音频、视频等「超文本」数据的「约定和规范」。&lt;/strong>&lt;/p>
&lt;blockquote>
&lt;p>这里的两点可以是服务器到本地电脑，本地电脑到服务器、服务器到服务器、电脑到电脑，等等。&lt;/p>
&lt;/blockquote>
&lt;h1 id="http-请求过程概述">HTTP 请求过程概述&lt;/h1>
&lt;p>HTTP 事务由一次 &lt;strong>Client 的 Request(请求)&lt;/strong> 和 &lt;strong>Server 的 Response(响应)&lt;/strong> 组成。&lt;/p>
&lt;p>HTTP 是一个客户端—服务器协议：请求由一个实体，即&lt;strong>用户代理（user agent）&lt;/strong>，或是一个可以代表它的代理方（proxy）发出。大多数情况下，这个&lt;strong>用户代理都是一个网页浏览器&lt;/strong>，不过它也可能是任何东西，比如一个爬取网页来充实、维护搜索引擎索引的机器爬虫（其实就是代码写的具有发起 HTTP 请求的程序，毕竟浏览器也是代码写的）。&lt;/p>
&lt;blockquote>
&lt;p>之所以用 用户代理 这个词，早期主要是用来描述实体的，发起请求的行为应该是用户操作的，而代替用户发起请求的，就是 用户的代理 了嘛。。。早期一般没有爬虫之类的东西，都是用户使用浏览器这个用户代理发起请求的。&lt;/p>
&lt;/blockquote>
&lt;p>每个请求都会被发送到一个服务端，它会处理这个请求并提供一个称作 &lt;em>响应&lt;/em> 的回复。在客户端与服务端之间，还有许许多多的被称为&lt;a href="https://developer.mozilla.org/zh-CN/docs/Glossary/Proxy_server">代理&lt;/a>的实体，履行不同的作用，例如充当网关或&lt;a href="https://developer.mozilla.org/zh-CN/docs/Glossary/Cache">缓存&lt;/a>。&lt;/p>
&lt;h2 id="http-的无状态">HTTP 的无状态&lt;/h2>
&lt;p>HTTP 协议是 Stateless(无状态)。(因为连接一次后就断开了，不会持久化存储任何数据)&lt;/p>
&lt;p>比如一个用户(Client 客户端)向服务器发起了一个请求，请求一个页面，在该页面输入完用户名和密码后进行登录后，如果刷新页面，那么就需要重新输入用户名和密码，因为 client 向 server 只请求了一个页面，请求完成后，连接就断开了，后续的请求是新的，没法再用以前的信息。这时候为了解决该问题，引用了 Cookie 和 Session 保持 的概念。&lt;/p>
&lt;p>相关技术&lt;/p>
&lt;ul>
&lt;li>Cookie：类似于 Token，相当于一个令牌，当访问一个 web server 的时候，server 发给 client 一个 Cookie，让 client 保存在本地，再次访问的时候，即可通过该 Cookie 识别身份&lt;/li>
&lt;li>Session(会话)保持：关联至 Cookie：当你在动态网页上访问了一些信息，比如购物车，在购物车添加一件物品，即通过 Session 功能来保存该信息，以便下次登录还能使用。否则下次登录购物车中的东西就没了&lt;/li>
&lt;/ul>
&lt;h2 id="流程简述">流程简述&lt;/h2>
&lt;ul>
&lt;li>建立或处理连接，接收请求或拒绝请求
&lt;ul>
&lt;li>建立 TCP 连接，WEB 浏览器向 Web 服务器发送请求&lt;/li>
&lt;li>web 浏览器发送请求头部信息
&lt;ul>
&lt;li>建立连接后，客户机发送一个请求给服务器，请求方式的格式为：URL、协议版本号、后面是 MIME 信息包括请求修饰符、客户机信息和可能得内容&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Server 接收请求，并应答
&lt;ul>
&lt;li>WEB 服务器接收到请求后，给予相应的响应信息，其格式为一个状态行，包括信息的协议版本号、一个成功或错误的代码，后边是 MIME 信息包括服务器信息、实体信息和可能得内容&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Server 处理请求
&lt;ul>
&lt;li>Web 服务器发送应答头信息&lt;/li>
&lt;li>Web 服务器向浏览器发送数据&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Client 访问资源
&lt;ul>
&lt;li>WEB 服务器关闭 TCP 连接&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>构建响应报文&lt;/li>
&lt;li>发送响应报文&lt;/li>
&lt;li>记录日志&lt;/li>
&lt;/ul>
&lt;h1 id="http-报文格式">HTTP 报文格式&lt;/h1>
&lt;h2 id="request-与-response-报文">Request 与 Response 报文&lt;/h2>
&lt;h3 id="request-请求报文">Request 请求报文&lt;/h3>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/rlkp9t/1616161240468-d9f13310-3f67-43b8-b5b7-b48dde683170.png" alt="">&lt;/p>
&lt;ul>
&lt;li>&lt;strong>Method&lt;/strong> # 请求方法，用于表明 Client 希望 Server 对 Resource 执行的动作。常用：GET、POST、DELETE&lt;/li>
&lt;li>&lt;strong>URL&lt;/strong> # HTTP 请求的 URL。
&lt;ul>
&lt;li>&lt;strong>Params&lt;/strong> # URL 参数。就是 URL 中的 Query 部分&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>Version&lt;/strong> # 发送给 Server 的请求的 HTTP 协议版本。&lt;/li>
&lt;li>&lt;strong>Headers&lt;/strong> # 请求头。&lt;/li>
&lt;li>&lt;strong>Body&lt;/strong> # 请求体。&lt;/li>
&lt;/ul>
&lt;blockquote>
&lt;p>这里面有一个要注意的地方，就是 Params 与 Headers，&lt;strong>Params 是 URL 的一部分&lt;/strong>，但是 Headers 不是。虽然两者的作用类似，都是用来定义这个请求中应该发送给对方的一些基本信息、认证信息 等等。但是在一个 HTTP 的请求中，两者所处的位置是不一样，用于不同场景。&lt;/p>
&lt;/blockquote>
&lt;p>&lt;strong>Authorization&lt;/strong> # 认证信息。这是一个比较特殊的东西，可以存在于 URL 的 Params 中、Headers 中、Body 中。请求报文的各个部分，都可以填写认证信息。&lt;/p>
&lt;ul>
&lt;li>当 Server 需要一个认证信息时，就需要在 HTTP 请求中加入认证相关的信息。&lt;/li>
&lt;/ul>
&lt;h4 id="example">EXAMPLE&lt;/h4>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/rlkp9t/1616161240442-63d3fc7f-80c2-43e4-bec5-50061f2e02f2.png" alt="">&lt;/p>
&lt;h3 id="response-响应报文">Response 响应报文&lt;/h3>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/rlkp9t/1616161240462-a29c9d65-119a-4b70-993f-bd1a4cfbbd7e.png" alt="">&lt;/p>
&lt;ul>
&lt;li>&lt;strong>Version&lt;/strong> # 响应给 Client 的 HTTP 版本。&lt;/li>
&lt;li>&lt;strong>Status&lt;/strong> # HTTP 响应状态。用来标记请求过程中发生的情况，由 server 告诉 client。响应状态由两部分组成&lt;/li>
&lt;li>&lt;strong>StatusCode&lt;/strong> # 状态码。统一为 3 位的数字。
&lt;ul>
&lt;li>各个状态码的含义，见 &lt;a href="docs/4.%E6%95%B0%E6%8D%AE%E9%80%9A%E4%BF%A1/%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/7.HTTP/HTTP%20Status%20Codes.md">HTTP Status Codes&lt;/a>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>ReasonPhrase&lt;/strong> # 原因短语。用来表示产生该状态的原因的简要说明&lt;/li>
&lt;li>&lt;strong>Headers&lt;/strong> # 响应头。&lt;/li>
&lt;li>&lt;strong>Body&lt;/strong> # 响应体。实体部分，请求时附加的数据或响应时附加的数据&lt;/li>
&lt;/ul>
&lt;h4 id="example-1">EXAMPLE&lt;/h4>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/rlkp9t/1616161240440-85fac56c-d3ed-44dc-94f3-20d60017e622.png" alt="">&lt;/p>
&lt;h2 id="http-header">HTTP Header&lt;/h2>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://datatracker.ietf.org/doc/html/rfc2616#section-14">RFC 2616，14 Header Field Definitions&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>HTTP 请求和响应报文的 Header(头) 基本都是 Key/Value(键值) 格式，Key 与 Value 以冒号分隔，此外，除了标准的头部字段之外，还可以添加自定义头，这就给 HTTP 带来了无限的扩展可能。注意，Value 不区分大小写。&lt;/p>
&lt;p>HTTP 协议规定了非常多的 Header 字段，可以实现各种各样的功能，但基本上可以分为以下几类&lt;/p>
&lt;ul>
&lt;li>&lt;strong>General Header(通用头)&lt;/strong> # 在请求头和响应头里都可以出现；&lt;/li>
&lt;li>&lt;strong>Request Header(请求头)&lt;/strong> # 仅能出现在请求头里，进一步说明请求信息或者额外的附加条件；&lt;/li>
&lt;li>&lt;strong>Response Header(响应头)&lt;/strong> # 仅能出现在响应头里，补充说明响应报文的信息；&lt;/li>
&lt;li>&lt;strong>Entity Header(实体头)&lt;/strong> # 它实际上属于通用字段，但专门描述 body 的额外信息。&lt;/li>
&lt;li>&lt;strong>Extension Header(扩展头)&lt;/strong> # 不在标准规范中，可以通过自定义头实现更多定制化需求的 Header 信息。&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>对 HTTP 报文的解析和处理其实本质上就是对头字段的处理&lt;/strong>，HTTP 的连接管理，缓存控制，内容协商等都是通过头字段来处理的，&lt;strong>理解了头字段，基本上也就理解了 HTTP&lt;/strong>，所以理解头字段非常重要。&lt;/p>
&lt;p>详见：&lt;a href="https://desistdaydream.github.io/docs/4.%E6%95%B0%E6%8D%AE%E9%80%9A%E4%BF%A1/%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/7.HTTP/HTTP%20Header.md">HTTP Header&lt;/a>&lt;/p>
&lt;blockquote>
&lt;p>注意：这种分类是在 RFC 2616 标准中定义的，在新的 RFC 7231 中，已经看不到这种分类了&lt;/p>
&lt;/blockquote>
&lt;h2 id="http-的请求-method方法">HTTP 的请求 Method(方法)&lt;/h2>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://datatracker.ietf.org/doc/html/rfc2616#section-5.1.1">RFC 2616，5.1.1 Method&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Methods">Mozilla 官方 HTTP 开发文档，HTTP 请求方法&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>根据 HTTP 标准，HTTP 请求可以使用多种请求方法。 HTTP 的 1.0 版本中只有三种请求方法： GET, POST 和 HEAD 方法。到了 1.1 版本时，新增加了五种请求方法：OPTIONS, PUT, DELETE, TRACE 和 CONNECT 方法。&lt;/p>
&lt;ul>
&lt;li>&lt;strong>GET&lt;/strong> # 从服务器获取了资源
&lt;ul>
&lt;li>请求指定的页面信息，并返回实体主体。&lt;/li>
&lt;li>GET 请求请提交的数据放置在 HTTP 请求协议头中，GET 方法通过 URL 请求来传递用户的输入，GET 方式的提交你需要用 Request.QueryString 来取得变量的值。&lt;/li>
&lt;li>GET 方法提交数据，可能会带来安全性的问题，数据被浏览器缓存。&lt;/li>
&lt;li>GET 请求有长度限制。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>HEAD&lt;/strong> # 只从 server 获取文档的响应首部（报文中的 Headers）
&lt;ul>
&lt;li>类似于 get 请求，只不过返回的响应中没有具体的内容，用于获取报头。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>POST&lt;/strong> # 向 server 发送要处理的数据
&lt;ul>
&lt;li>向指定资源提交数据进行处理请求（例如提交表单或者上传文件）。&lt;/li>
&lt;li>POST 请求可能会导致新的资源的建立和/或已有资源的修改。&lt;/li>
&lt;li>POST 方式提交时，你必须通过 Request.Form 来访问提交的内容&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>PUT&lt;/strong> # 将请求的主体存储在 server 上
&lt;ul>
&lt;li>从客户端向服务器传送的数据取代指定的文档的内容。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>DELETE&lt;/strong> # 请求删除 server 上通过 URL 指定的文档，DELETE 请求一般返回 3 种码
&lt;ul>
&lt;li>200（OK）——删除成功，同时返回已经删除的资源。&lt;/li>
&lt;li>202（Accepted）——删除请求已经接受，但没有被立即执行（资源也许已经被转移到了待删除区域）。&lt;/li>
&lt;li>204（No Content）——删除请求已经被执行，但是没有返回资源（也许是请求删除不存在的资源造成的）。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>OPTIONS&lt;/strong> # 请求服务器返回对指定资源支持使用的请求方法
&lt;ul>
&lt;li>允许客户端查看服务器的性能。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>TRACE&lt;/strong> # 追踪请求到达 server 中间经过的 server agent
&lt;ul>
&lt;li>回显服务器收到的请求，主要用于测试或诊断。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h3 id="get-与-post">GET 与 POST&lt;/h3>
&lt;p>&lt;code>Get&lt;/code> 方法的含义是请求&lt;strong>从服务器获取资源&lt;/strong>，这个资源可以是静态的文本、页面、图片视频等。&lt;/p>
&lt;p>比如，你打开我的文章，浏览器就会发送 GET 请求给服务器，服务器就会返回文章的所有文字及资源。&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/rlkp9t/1649668233003-6c01ab91-90f8-4ea8-8095-5448302146e8.jpeg" alt="">&lt;/p>
&lt;p>而&lt;code>POST&lt;/code> 方法则是相反操作，它向 &lt;code>URI&lt;/code> 指定的资源提交数据，数据就放在报文的 body 里。&lt;/p>
&lt;p>比如，你在我文章底部，敲入了留言后点击「提交」（&lt;strong>暗示你们留言&lt;/strong>），浏览器就会执行一次 POST 请求，把你的留言文字放进了报文 body 里，然后拼接好 POST 请求头，通过 TCP 协议发送给服务器。
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/rlkp9t/1649668232954-1a090cec-1a9c-4c11-a370-d49b4156cac3.jpeg" alt="">
GET 和 POST 方法都是安全和幂等的吗？&lt;/p>
&lt;p>先说明下安全和幂等的概念：&lt;/p>
&lt;ul>
&lt;li>在 HTTP 协议里，所谓的「安全」是指请求方法不会「破坏」服务器上的资源。&lt;/li>
&lt;li>所谓的「幂等」，意思是多次执行相同的操作，结果都是「相同」的。&lt;/li>
&lt;/ul>
&lt;p>那么很明显 &lt;strong>GET 方法就是安全且幂等的&lt;/strong>，因为它是「只读」操作，无论操作多少次，服务器上的数据都是安全的，且每次的结果都是相同的。&lt;/p>
&lt;p>&lt;strong>POST&lt;/strong> 因为是「新增或提交数据」的操作，会修改服务器上的资源，所以是&lt;strong>不安全&lt;/strong>的，且多次提交数据就会创建多个资源，所以&lt;strong>不是幂等&lt;/strong>的。&lt;/p>
&lt;h1 id="http-相关的协议或规范">HTTP 相关的协议或规范&lt;/h1>
&lt;p>HTTP 无法单独存在，要想让它生效，必须依赖其他的协议或者规范&lt;/p>
&lt;h2 id="url">URL&lt;/h2>
&lt;p>详见 &lt;a href="docs/4.%E6%95%B0%E6%8D%AE%E9%80%9A%E4%BF%A1/%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/7.HTTP/URL%20%E4%B8%8E%20URI.md">URL 与 URI&lt;/a>&lt;/p>
&lt;h2 id="tcpip">TCP/IP&lt;/h2>
&lt;p>详见：&lt;a href="docs/4.%E6%95%B0%E6%8D%AE%E9%80%9A%E4%BF%A1/%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/3_4.TCP_IP/3_4.TCP_IP.md">3_4.TCP_IP&lt;/a>&lt;/p>
&lt;h2 id="dns">DNS&lt;/h2>
&lt;p>详见：&lt;a href="docs/4.%E6%95%B0%E6%8D%AE%E9%80%9A%E4%BF%A1/DNS/DNS.md">DNS&lt;/a>&lt;/p></description></item><item><title>Docs: URL 与 URI</title><link>https://desistdaydream.github.io/docs/4.%E6%95%B0%E6%8D%AE%E9%80%9A%E4%BF%A1/%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/7.HTTP/URL-%E4%B8%8E-URI/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/4.%E6%95%B0%E6%8D%AE%E9%80%9A%E4%BF%A1/%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/7.HTTP/URL-%E4%B8%8E-URI/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Uniform_Resource_Identifier">Wiki，URI&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Internationalized_Resource_Identifier">Wiki，IRI&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/URL">Wiki，URL&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Clean_URL">Wiki，CleanURL-slug&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Percent-encoding">Wiki，URL encoding&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.rfc-editor.org/rfc/rfc3986.html">RFC 3986，Uniform Resource Identifier(URI): Generic Syntax&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.rfc-editor.org/rfc/rfc1738">RFC 1738，Uniform Resource Locators (URL)&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.ruanyifeng.com/blog/2010/02/url_encoding.html">https://www.ruanyifeng.com/blog/2010/02/url_encoding.html&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>既然 HTTP 的本质是是在两点之间传输超文本，那么这个超文本又该如何表示呢？我们应该如何正确得找到这个超文本呢？所以，人们将超文本描述为 &lt;strong>Resource(资源)&lt;/strong>，互联网上如此之多得资源，就需要一个唯一标识符来标识每一个资源。URI 就是这么一个用来标识资源的规范。&lt;/p>
&lt;p>&lt;strong>Uniform Resource Identifier(统一资源标识符，简称 URI)&lt;/strong> 是 Web 技术使用的唯一标识符。URI 可以用于标识任何东西，包括现实世界中的对象，例如人和地方，概念或信息资源，例如网页和书籍。某些 URI 提供了一种在网络上(在 Internet 上或在另一个专用网络上，例如在计算机文件系统或 Intranet 上)定位和检索信息资源的方法，它们是 &lt;strong>Uniform Resource Locator(统一资源定位符，简称 URL)&lt;/strong>。而其他 URI 仅提供一个唯一名称，而没有找到或检索该资源的信息，这类 URI 被称为 &lt;strong>Uniform Resource Name(统一资源名称，简称 URN)&lt;/strong>。&lt;/p>
&lt;blockquote>
&lt;p>尽管 URI 仍然是常用术语，但定义 URI 的规范已经被 Internationalized Resource Identifiers(国际化资源标识符，简称 IRI) 的规范所取代。IRI 扩展了 URI 的定义，以便 IRI 可以处理诸如 Kanji(汉字) 之类的字符集，而不是仅限于 ASCII。&lt;/p>
&lt;/blockquote>
&lt;p>&lt;strong>Uniform Resource Locator(统一资源定位符，简称 URL)&lt;/strong> 是 URI 的一种子集。&lt;/p>
&lt;p>要强制区分 URL 和 URI/IRI 这两种标准化术语是很难的。实际上，两者都使用同一种算法，因此没必要强行区分二者的区别，而且 URL 这个词也更具有人气。所以没有必要强制区分 URI 与 URL。&lt;/p>
&lt;h1 id="url-syntaxurl-语法">URL Syntax(URL 语法)&lt;/h1>
&lt;p>URL 主要由四个部分组成：协议、主机、端口、路径&lt;/p>
&lt;p>&lt;strong>&lt;code>**Scheme:[//Authority]/Path[?query][#fragment]**&lt;/code>&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>&lt;strong>Scheme://&lt;/strong> # URL 方案，即访问协议,指定低层使用的协议(例如：http, https, ftp)&lt;/li>
&lt;li>&lt;strong>Authority&lt;/strong> # 分为三个部分 &lt;code>[UserInfo@]Host[:Port]&lt;/code>&lt;/li>
&lt;li>&lt;strong>UserInfo&lt;/strong> # 认证信息。由于安全原因，现在这个年代，都省略这部分，而通过其他方式传递认证信息。&lt;/li>
&lt;li>&lt;strong>Host:PORT&lt;/strong> # 服务器 IP 地址或者域名:要访问的端口号&lt;/li>
&lt;li>&lt;strong>/PATH&lt;/strong> # 要访问的资源路径。即资源在主机上的存放相对路径。
&lt;ul>
&lt;li>注意：其实 &lt;code>/&lt;/code> 也算作 PATH 的一部分，只不过访问一个网站时，访问的默认资源就是 &lt;code>/&lt;/code>，并且也便于人类阅读，所以很多网站访问时虽然末尾没有 &lt;code>/&lt;/code>，其实是隐藏了。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>QUERY&lt;/strong> # 其实就是参数。用于给动态网页或接口传递参数，可有多个参数，用“&amp;amp;”符号隔开，每个参数的名和值用“=”符号隔开。&lt;/li>
&lt;li>&lt;strong>Fragment&lt;/strong> # 片段，主要用于浏览器中。当前页面的其中一段的位置，比如一篇小说有 N 个章节在统一页面显示，开头有目录，点击某一个章节会跳到该页面的某一段，该段的开头就是整个页面的片段，类似于一个位置锚定的作用，该字段即实现这个功能&lt;/li>
&lt;/ul>
&lt;h1 id="url-slug">URL slug&lt;/h1>
&lt;p>URL slug 是位于域扩展名之后的 URL 或链接的一部分。&lt;/p>
&lt;ul>
&lt;li>它们可用于网站：
&lt;ul>
&lt;li>&lt;a href="https://www.rebrandly.com/links">www.rebrandly.com/links&lt;/a> # &amp;rsquo;links&amp;rsquo; 是 URL Slug。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>或者它们可以用于您的自定义短链接：
&lt;ul>
&lt;li>rebrandly.rocks/content-curation # &amp;lsquo;content-curation&amp;rsquo; 是 URL slug。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h1 id="example">EXAMPLE&lt;/h1>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span> userinfo host port
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ┌──┴───┐ ┌──────┴──────┐ ┌┴┐
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> https://john.doe@www.example.com:123/forum/questions/?tag&lt;span style="color:#f92672">=&lt;/span>networking&amp;amp;order&lt;span style="color:#f92672">=&lt;/span>newest#top
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> └─┬─┘ └───────────┬──────────────┘└───────┬───────┘ └───────────┬─────────────┘ └┬┘
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> scheme authority path query fragment
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ul>
&lt;li>&lt;code>unix:///run/containerd/containerd.sock&lt;/code> # 这也是 URI 的一种，这就是不同于网络定位符的地方，没有域名之类的东西。Scheme 后面直接接的是 PATH&lt;/li>
&lt;/ul>
&lt;h1 id="url-编码">URL 编码&lt;/h1>
&lt;p>URL Encoding(URL 编码)&lt;/p>
&lt;p>通常来说，URL 只能使用英文字母、阿拉伯数字和某些标点符号。那么如果在 URL 中想使用其他字符，比如中文或某些特殊字符怎么办呢？&lt;/p>
&lt;p>上述问题就是 URL 编码的由来。在初期，并没有 RFC 规定具体如何进行编码，而是由应用程序自行处理。这就导致 URL 编码称为一个混乱的领域。&lt;/p>
&lt;p>在浏览器中，如果输入 &lt;code>http://www.google.com/断念梦&lt;/code>，则会被编码为 &lt;code>http://www.google.com/%E6%96%AD%E5%BF%B5%E6%A2%A6&lt;/code>。这里面的规则非常简单：&lt;/p>
&lt;ul>
&lt;li>这三个汉字的 UTF-8 编码结果分别为
&lt;ul>
&lt;li>断: E6 96 AD&lt;/li>
&lt;li>念: E5 BF B5&lt;/li>
&lt;li>梦: E6 A2 A6&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>“断念梦” 三个汉字的 Unicode 编码结果为 E4 BD A0 E5 A5 BD，每个字节前面加上个 &lt;code>%&lt;/code>，就得到了 URL 编码。&lt;/li>
&lt;/ul></description></item><item><title>Docs: HTTP Header</title><link>https://desistdaydream.github.io/docs/4.%E6%95%B0%E6%8D%AE%E9%80%9A%E4%BF%A1/%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/7.HTTP/HTTP-Header/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/4.%E6%95%B0%E6%8D%AE%E9%80%9A%E4%BF%A1/%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/7.HTTP/HTTP-Header/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://tools.ietf.org/html/rfc2616#section-4.2">RFC 2616-Message Headers&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://tools.ietf.org/html/rfc7231#section-5">RFC 7231，第五章-请求头字段&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://datatracker.ietf.org/doc/html/rfc7231#section-7">RFC 7231，第七章-响应头字段&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers">MDN，参考-HTTP-HTTP 头&lt;/a> 这是一个全部可用的标准 Header 列表&lt;/li>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/List_of_HTTP_header_fields">Wiki，List of HTTP header fields&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>一般情况下，在打开浏览器按的开发者工具（一般为 F12 键）后，查看到的首部大部分都是请求和响应首部,这俩首部的信息通常包含了通用首部中的信息&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/http/1616161207830-cf569808-255f-4e34-9f02-d7da892c9170.jpeg" alt="">&lt;/p>
&lt;p>HTTP 请求和响应报文的 Header(头) 基本都是 Key/Value Pair(键/值对) 格式的 &lt;strong>Field(字段)&lt;/strong>，每个字段都是以冒号分割的 &lt;strong>键/值对&lt;/strong>。此外，除了标准的 Header 字段之外，还可以添加自定义 Header，这就给 HTTP 带来了无限的扩展可能。注意，&lt;strong>Key 不区分大小写&lt;/strong>。&lt;/p>
&lt;p>自定义 Header 历来以 &lt;code>X-&lt;/code> 开头，但是该约定在 2012 年 6 月被弃用，因为它在非标准字段成为标准字段时会造成不必要的麻烦，详见 &lt;a href="https://datatracker.ietf.org/doc/html/rfc6648">RFC 6648&lt;/a>。IANA 维护了一个通用的 &lt;a href="https://www.iana.org/assignments/message-headers/message-headers.xhtml">&lt;strong>HTTP Header 列表&lt;/strong>&lt;/a>，其中包括 RFC 中定义的标准头以及不在 RFC 中定义的扩展头；并且在同一个页面还有新的提议增加的 HTTP Header 列表。&lt;/p>
&lt;p>HTTP(RFC 2616 版本) 规定了非常多的 Header 字段，可以实现各种各样的功能，但基本上可以分为以下几类&lt;/p>
&lt;ol>
&lt;li>&lt;strong>General Header(通用头)&lt;/strong> # 在请求头和响应头里都可以出现；&lt;/li>
&lt;li>&lt;strong>Request Header(请求头)&lt;/strong> # 仅能出现在请求头里，进一步说明请求信息或者额外的附加条件；&lt;/li>
&lt;li>&lt;strong>Response Header(响应头)&lt;/strong> # 仅能出现在响应头里，补充说明响应报文的信息；&lt;/li>
&lt;li>&lt;strong>Entity Header(实体头)&lt;/strong> # 它实际上属于通用字段，但专门描述 body 的额外信息。&lt;/li>
&lt;li>&lt;strong>Extension Header(扩展头)&lt;/strong> # 不在标准规范中，可以通过自定义头实现更多定制化需求的 Header 信息。&lt;/li>
&lt;/ol>
&lt;p>&lt;strong>对 HTTP 报文的解析和处理其实本质上就是对头字段的处理&lt;/strong>，HTTP 的连接管理，缓存控制，内容协商等都是通过头字段来处理的，&lt;strong>理解了头字段，基本上也就理解了 HTTP&lt;/strong>，所以理解头字段非常重要。&lt;/p>
&lt;h2 id="新版-http-header-规范">新版 HTTP Header 规范&lt;/h2>
&lt;p>注意：上面描述分类是在 RFC 2616 标准中定义的，在新的 RFC 7231 中，已经看不到这种分类了，仅仅简单得分为请求头和响应头&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://tools.ietf.org/html/rfc7231#section-5">Request Header(请求头)&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://tools.ietf.org/html/rfc7231#section-7">Response Header(响应头)&lt;/a>&lt;/li>
&lt;/ul>
&lt;p>而这两类头字段下，又有各自的子分类&lt;/p>
&lt;p>在 2014 年之后的新版规范中，并非所有出现在请求中的 Header 都称为请求头，比如 Content-Length，在 RFC 2616 中称为 Entity Header(实体头)，而在新版规范中，称之为元数据。这也为 HTTP 2.0 的 &lt;a href="https://desistdaydream.github.io/docs/4.%E6%95%B0%E6%8D%AE%E9%80%9A%E4%BF%A1/%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/7.HTTP/HTTP2.md">Header 压缩&lt;/a> 打下了基础&lt;/p>
&lt;h1 id="request-header请求头">Request Header(请求头)&lt;/h1>
&lt;p>Request Header(请求头) 主要是在每个 HTTP 的请求中指定。包含要获取的资源或请求某个资源的客户端本身的信息，以便服务端可以根据这些内容，来定制响应。&lt;/p>
&lt;p>Request Header 中，将各种 Header 分为多个类别&lt;/p>
&lt;ul>
&lt;li>Controls # 控制本次 HTTP 请求的行为&lt;/li>
&lt;li>Conditionals # 条件相关 Header&lt;/li>
&lt;li>Content Negotiation # 内容协商相关 Header&lt;/li>
&lt;li>Authentication Credentials # 认证相关的 Header&lt;/li>
&lt;li>Request Context # 请求上下文&lt;/li>
&lt;/ul>
&lt;h2 id="controls控制">Controls(控制)&lt;/h2>
&lt;p>Controls 类型的请求头用来指定客户端如何处理本次 HTTP 请求。&lt;/p>
&lt;p>&lt;strong>Cache-Control&lt;/strong> # 缓存控制&lt;/p>
&lt;p>&lt;strong>Expect&lt;/strong> # 期待服务器的特定行为&lt;/p>
&lt;p>&lt;strong>Host&lt;/strong> # 请求资源所在服务器。客户端指定自己想访问的服务器的 &lt;code>域名&lt;/code> 或者 &lt;code>IP:PORT&lt;/code>。例如：&lt;code>Host：www.baidu.com&lt;/code>&lt;/p>
&lt;ul>
&lt;li>Note：输入的什么网址，请求的就是什么，输入域名就是域名，输入 IP 就是 IP&lt;/li>
&lt;li>Note：当服务器接到这个请求时，如果自身无法处理 ip 或者无法处理域名，则该请求就会丢弃(比如 k8s 的 ingress)。所以在测试的时候一般使用 curl 命令请求 IP 时加上 -H 参数以自己制定 URL 内容即可，否则如果服务器不处理 IP 的话，就会返回 404&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>Max-Forwards&lt;/strong># 最大传输逐跳数&lt;/p>
&lt;p>&lt;strong>Pragma&lt;/strong> #&lt;/p>
&lt;p>&lt;strong>Range&lt;/strong> # 实体的字节范围请求&lt;/p>
&lt;p>&lt;strong>TE&lt;/strong># 传输编码的优先级&lt;/p>
&lt;h2 id="conditionals条件">Conditionals(条件)&lt;/h2>
&lt;p>&lt;strong>If-Match&lt;/strong> # 比较实体标记(ETag)&lt;/p>
&lt;p>&lt;strong>If-None-Match&lt;/strong> # 比较实体标记(与 If-Match 相反)&lt;/p>
&lt;p>&lt;strong>If-Modified-Since&lt;/strong> # 比较资源的更新时间&lt;/p>
&lt;p>&lt;strong>If-Unmodified-Since&lt;/strong># 比较资源的更新时间(与 If-Modified-Since 相反)&lt;/p>
&lt;p>&lt;strong>If-Range&lt;/strong># 资源未更新时发送实体 Byte 的范围请求&lt;/p>
&lt;h2 id="content-negotiation内容协商">Content Negotiation(内容协商)&lt;/h2>
&lt;p>&lt;strong>Accept&lt;/strong> # 用户代理可处理的媒体类型
&lt;strong>Accept-[ Charset | Encoding | Language]&lt;/strong> # 通知 server 自己可接收的媒体类型[字符集|编码格式|语言]&lt;/p>
&lt;h2 id="authentication-credentials认证">Authentication Credentials(认证)&lt;/h2>
&lt;p>&lt;strong>Authorization&lt;/strong> # Web 认证信息。IANA 维护了一个&lt;a href="https://www.iana.org/assignments/http-authschemes/http-authschemes.xhtml">身份验证方案的列表&lt;/a>&lt;/p>
&lt;ul>
&lt;li>&lt;strong>Basic&lt;/strong> # 基本认证。就是用户名和密码。如果用户名和密码为 &lt;code>admin/admin1234&lt;/code> 的话，该字段应该是这样的：
&lt;ul>
&lt;li>&lt;code>Authorization: Basic YWRtaW46YWRtaW4xMjM0&lt;/code>&lt;/li>
&lt;li>也就是说，用户名和密码是 &lt;code>admin:admin1234&lt;/code> 这样的 base64 编码后的格式&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>Bearer&lt;/strong> # 不记名令牌。&lt;/li>
&lt;li>&amp;hellip;&amp;hellip;&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>Proxy-Authorization&lt;/strong> # 代理服务器要求客户端的认证信息&lt;/p>
&lt;h2 id="request-context">Request Context&lt;/h2>
&lt;p>&lt;strong>From&lt;/strong> # 用户的电子邮箱地址&lt;/p>
&lt;p>&lt;strong>Referer&lt;/strong> # 对请求中 URI 的原始获取方&lt;/p>
&lt;p>&lt;strong>User-Agent&lt;/strong> # HTTP 客户端程序的信息&lt;/p>
&lt;h1 id="response-header响应头">Response Header(响应头)&lt;/h1>
&lt;p>包含有关响应的补充信息，如其位置或服务器本身(名称和版本等)的消息头。&lt;/p>
&lt;p>Response Header 中，将各种 Header 分为多个类别：&lt;/p>
&lt;ul>
&lt;li>Control Data&lt;/li>
&lt;li>Validator Header Fields&lt;/li>
&lt;li>Authentication Challenges&lt;/li>
&lt;li>Response Context&lt;/li>
&lt;/ul>
&lt;h2 id="control-data控制数据">Control Data(控制数据)&lt;/h2>
&lt;p>控制服务端如何处理 HTTP 响应&lt;/p>
&lt;ul>
&lt;li>Age # 推算资源创建经过时间&lt;/li>
&lt;li>Cache-Control #&lt;/li>
&lt;li>Expires #&lt;/li>
&lt;li>Data #&lt;/li>
&lt;li>Location #&lt;/li>
&lt;li>Retry-After #&lt;/li>
&lt;li>Vary #&lt;/li>
&lt;li>Warning #&lt;/li>
&lt;/ul>
&lt;h2 id="validator-header-fields验证器头字段">Validator Header Fields(验证器头字段)&lt;/h2>
&lt;p>&lt;strong>ETag&lt;/strong> # 资源的匹配信息&lt;/p>
&lt;p>&lt;strong>Last-Modified&lt;/strong> # 最后一次修改时间&lt;/p>
&lt;h2 id="authentication-challenges">Authentication Challenges&lt;/h2>
&lt;p>&lt;strong>WWW-Authenticate&lt;/strong> # 服务器对客户端的认证信息&lt;/p>
&lt;p>&lt;strong>Proxy-Authorization&lt;/strong> # 代理服务器要求客户端的认证信息&lt;/p>
&lt;h2 id="response-context">Response Context&lt;/h2>
&lt;p>&lt;strong>Accept-Ranges&lt;/strong> # 是否接受字节范围请求&lt;/p>
&lt;p>&lt;strong>Allow&lt;/strong> #&lt;/p>
&lt;p>&lt;strong>Server&lt;/strong># HTTP 服务器的安装信息&lt;/p>
&lt;h1 id="extension-header扩展头">&lt;strong>Extension Header(扩展头)&lt;/strong>&lt;/h1>
&lt;p>通常情况下，一个 web 界面有 N 多个资源，比如 index.html 首页是一个资源，首页中有各种 img，css，js 等静态或动态资源，当用户访问一个网站后，除了要请求主页资源，还需要再请求主页上各个图片，板式，功能等资源，每一个资源都有一个单独的报文。也就说有可能每一类资源都可以单独存在在一个相对应的集群服务器群中，比如通过一个图片的 URL，可以直接访问该图片，而不用在网站主页才能看到；而这些资源都需要前端负载均衡器来进行调度用户请求到相应的服务器中去拿去资源，这时候 LB 的压力会非常大，为了解决这种问题，人们就可以根据自己的协商，定义一些标准之外的 Header。&lt;/p>
&lt;h1 id="mdn-的-http-header-列表">MDN 的 HTTP Header 列表&lt;/h1>
&lt;p>RFC 7231 中 HTTP Header 分类方式好像并不是特别好的方式，在 RFC 9110 中，已经没有 RFC 7231 的那种请求头分类章节了。&lt;/p>
&lt;p>很多 HTTP Header 既可以当做 Request Header 又可以当做 Response Header，比如 Cache-Control、等等。所以 MDN 使用 Header 的功能进行分类&lt;/p>
&lt;ul>
&lt;li>验证&lt;/li>
&lt;li>缓存&lt;/li>
&lt;li>控制&lt;/li>
&lt;li>Cookie&lt;/li>
&lt;li>。。。等等&lt;/li>
&lt;/ul>
&lt;h2 id="cookie">Cookie&lt;/h2>
&lt;p>&lt;a href="https://datatracker.ietf.org/doc/html/rfc6265">RFC 6265&lt;/a>&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>Header&lt;/th>
&lt;th>Header 分类&lt;/th>
&lt;th>Herader 用途&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>&lt;strong>Cookie&lt;/strong>&lt;/td>
&lt;td>请求头&lt;/td>
&lt;td>客户端将存储的 cookie 在 Cookie 标头中发送到源服务器。&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;strong>Set-Cookie&lt;/strong>&lt;/td>
&lt;td>响应头&lt;/td>
&lt;td>Set-Cookie HTTP 响应头用于将 cookie 从服务器发送到客户端。&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table></description></item><item><title>Docs: HTTP Status Codes</title><link>https://desistdaydream.github.io/docs/4.%E6%95%B0%E6%8D%AE%E9%80%9A%E4%BF%A1/%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/7.HTTP/HTTP-Status-Codes/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/4.%E6%95%B0%E6%8D%AE%E9%80%9A%E4%BF%A1/%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/7.HTTP/HTTP-Status-Codes/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://datatracker.ietf.org/doc/html/rfc7231#section-6">RFC 7231,第六章-响应状态码&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;h1 id="http-的-status-状态码和-reason-phrase-原因短语">HTTP 的 Status 状态码和 Reason-Phrase 原因短语&lt;/h1>
&lt;p>常用 200,301,302,304,401,403,404,500,502&lt;/p>
&lt;h2 id="http-常见的状态码">HTTP 常见的状态码&lt;/h2>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/ytigiz/1616161194550-be1a091b-4d94-4180-97cb-9a54f082ca47.png" alt="">&lt;/p>
&lt;h2 id="五大类-http-状态码">五大类 HTTP 状态码&lt;/h2>
&lt;p>&lt;em>1xx&lt;/em>&lt;/p>
&lt;p>&lt;code>1xx&lt;/code> 类状态码属于&lt;strong>提示信息&lt;/strong>，是协议处理中的一种中间状态，实际用到的比较少。&lt;/p>
&lt;p>&lt;em>2xx&lt;/em>&lt;/p>
&lt;p>&lt;code>2xx&lt;/code> 类状态码表示服务器&lt;strong>成功&lt;/strong>处理了客户端的请求，也是我们最愿意看到的状态。&lt;/p>
&lt;p>「&lt;strong>200 OK&lt;/strong>」是最常见的成功状态码，表示一切正常。如果是非 &lt;code>HEAD&lt;/code> 请求，服务器返回的响应头都会有 body 数据。&lt;/p>
&lt;p>「&lt;strong>204 No Content&lt;/strong>」也是常见的成功状态码，与 200 OK 基本相同，但响应头没有 body 数据。&lt;/p>
&lt;p>「&lt;strong>206 Partial Content&lt;/strong>」是应用于 HTTP 分块下载或断点续传，表示响应返回的 body 数据并不是资源的全部，而是其中的一部分，也是服务器处理成功的状态。&lt;/p>
&lt;p>&lt;em>3xx&lt;/em>&lt;/p>
&lt;p>&lt;code>3xx&lt;/code> 类状态码表示客户端请求的资源发送了变动，需要客户端用新的 URL 重新发送请求获取资源，也就是&lt;strong>重定向&lt;/strong>。&lt;/p>
&lt;p>「&lt;strong>301 Moved Permanently&lt;/strong>」表示永久重定向，说明请求的资源已经不存在了，需改用新的 URL 再次访问。&lt;/p>
&lt;p>「&lt;strong>302 Found&lt;/strong>」表示临时重定向，说明请求的资源还在，但暂时需要用另一个 URL 来访问。&lt;/p>
&lt;p>301 和 302 都会在响应头里使用字段 &lt;code>Location&lt;/code>，指明后续要跳转的 URL，浏览器会自动重定向新的 URL。&lt;/p>
&lt;p>「&lt;strong>304 Not Modified&lt;/strong>」不具有跳转的含义，表示资源未修改，重定向已存在的缓冲文件，也称缓存重定向，用于缓存控制。&lt;/p>
&lt;p>&lt;em>4xx&lt;/em>&lt;/p>
&lt;p>&lt;code>4xx&lt;/code> 类状态码表示客户端发送的&lt;strong>报文有误&lt;/strong>，服务器无法处理，也就是错误码的含义。&lt;/p>
&lt;p>「&lt;strong>400 Bad Request&lt;/strong>」表示客户端请求的报文有错误，但只是个笼统的错误。&lt;/p>
&lt;p>「&lt;strong>403 Forbidden&lt;/strong>」表示服务器禁止访问资源，并不是客户端的请求出错。&lt;/p>
&lt;p>「&lt;strong>404 Not Found&lt;/strong>」表示请求的资源在服务器上不存在或未找到，所以无法提供给客户端。&lt;/p>
&lt;p>&lt;em>5xx&lt;/em>&lt;/p>
&lt;p>&lt;code>5xx&lt;/code> 类状态码表示客户端请求报文正确，但是&lt;strong>服务器处理时内部发生了错误&lt;/strong>，属于服务器端的错误码。&lt;/p>
&lt;p>「&lt;strong>500 Internal Server Error&lt;/strong>」与 400 类型，是个笼统通用的错误码，服务器发生了什么错误，我们并不知道。&lt;/p>
&lt;p>「&lt;strong>501 Not Implemented&lt;/strong>」表示客户端请求的功能还不支持，类似“即将开业，敬请期待”的意思。&lt;/p>
&lt;p>「&lt;strong>502 Bad Gateway&lt;/strong>」通常是服务器作为网关或代理时返回的错误码，表示服务器自身工作正常，访问后端服务器发生了错误。&lt;/p>
&lt;p>「&lt;strong>503 Service Unavailable&lt;/strong>」表示服务器当前很忙，暂时无法响应服务器，类似“网络服务正忙，请稍后重试”的意思。&lt;/p>
&lt;h1 id="状态码">状态码&lt;/h1>
&lt;h2 id="消息1xx">消息，1XX&lt;/h2>
&lt;p>这一类型的状态码，代表请求已被接受，需要继续处理。这类响应是临时响应，只包含状态行和某些可选的响应头信息，并以空行结束。由于 HTTP/1.0 协议中没有定义任何 1xx 状态码，所以除非在某些试验条件下，服务器禁止向此类客户端发送 1xx 响应。&lt;/p>
&lt;ul>
&lt;li>100 Continue，客户端应当继续发送请求。这个临时响应是用来通知客户端它的部分请求已经被服务器接收，且仍未被拒绝。客户端应当继续发送请求的剩余部分，或者如果请求已经完成，忽略这个响应。服务器必须在请求完成后向客户端发送一个最终响应。&lt;/li>
&lt;li>101 Switching Protocols，服务器已经理解了客户端的请求，并将通过 Upgrade 消息头通知客户端采用不同的协议来完成这个请求。在发送完这个响应最后的空行后，服务器将会切换到在 Upgrade 消息头中定义的那些协议。只有在切换新的协议更有好处的时候才应该采取类似措施。例如，切换到新的 HTTP 版本比旧版本更有优势，或者切换到一个实时且同步的协议以传送利用此类特性的资源。&lt;/li>
&lt;/ul>
&lt;h2 id="成功2xx200-206">成功，2XX，（200-206）&lt;/h2>
&lt;p>这一类型的状态码，代表请求已成功被服务器接收、理解、并接受&lt;/p>
&lt;ul>
&lt;li>200 OK，请求已成功，请求的所有数据通过响应报文的 Entity-Body 这一部分发送&lt;/li>
&lt;li>201 Created，请求已经被实现，而且有一个新的资源已经依据请求的需要而建立，且其 URI 已经随 Location 头信息返回。假如需要的资源无法及时建立的话，应当返回 &amp;lsquo;202 Accepted&amp;rsquo;。&lt;/li>
&lt;li>202 Accepted，服务器已接受请求，但尚未处理。正如它可能被拒绝一样，最终该请求可能会也可能不会被执行。在异步操作的场合下，没有比发送这个状态码更方便的做法了。返回 202 状态码的响应的目的是允许服务器接受其他过程的请求（例如某个每天只执行一次的基于批处理的操作），而不必让客户端一直保持与服务器的连接直到批处理操作全部完成。在接受请求处理并返回 202 状态码的响应应当在返回的实体中包含一些指示处理当前状态的信息，以及指向处理状态监视器或状态预测的指针，以便用户能够估计操作是否已经完成。&lt;/li>
&lt;li>203 Non-Authoritative Information，服务器已成功处理了请求，但返回的实体头部元信息不是在原始服务器上有效的确定集合，而是来自本地或者第三方的拷贝。当前的信息可能是原始版本的子集或者超集。例如，包含资源的元数据可能导致原始服务器知道元信息的超集。使用此状态码不是必须的，而且只有在响应不使用此状态码便会返回 200 OK 的情况下才是合适的。&lt;/li>
&lt;li>204 No Content，服务器成功处理了请求，但不需要返回任何实体内容，并且希望返回更新了的元信息。响应可能通过实体头部的形式，返回新的或更新后的元信息。如果存在这些头部信息，则应当与所请求的变量相呼应。如果客户端是浏览器的话，那么用户浏览器应保留发送了该请求的页面，而不产生任何文档视图上的变化，即使按照规范新的或更新后的元信息应当被应用到用户浏览器活动视图中的文档。由于 204 响应被禁止包含任何消息体，因此它始终以消息头后的第一个空行结尾。&lt;/li>
&lt;li>205 Reset Content，服务器成功处理了请求，且没有返回任何内容。但是与 204 响应不同，返回此状态码的响应要求请求者重置文档视图。该响应主要是被用于接受用户输入后，立即重置表单，以便用户能够轻松地开始另一次输入。&lt;/li>
&lt;li>与 204 响应一样，该响应也被禁止包含任何消息体，且以消息头后的第一个空行结束。&lt;/li>
&lt;li>206 Partial Content，服务器已经成功处理了部分 GET 请求。类似于 FlashGet 或者迅雷这类的 HTTP 下载工具都是使用此类响应实现断点续传或者将一个大文档分解为多个下载段同时下载。该请求必须包含 Range 头信息来指示客户端希望得到的内容范围，并且可能包含 If-Range 来作为请求条件。
&lt;ul>
&lt;li>响应必须包含如下的头部域：&lt;/li>
&lt;li>Content-Range 用以指示本次响应中返回的内容的范围；如果是 Content-Type 为 multipart/byteranges 的多段下载，则每一 multipart 段中都应包含 Content-Range 域用以指示本段的内容范围。假如响应中包含 Content-Length，那么它的数值必须匹配它返回的内容范围的真实字节数。&lt;/li>
&lt;li>Date&lt;/li>
&lt;li>ETag 和/或 Content-Location，假如同样的请求本应该返回 200 响应。&lt;/li>
&lt;li>Expires, Cache-Control，和/或 Vary，假如其值可能与之前相同变量的其他响应对应的值不同的话。&lt;/li>
&lt;li>假如本响应请求使用了 If-Range 强缓存验证，那么本次响应不应该包含其他实体头；假如本响应的请求使用了 If-Range 弱缓存验证，那么本次响应禁止包含其他实体头；这避免了缓存的实体内容和更新了的实体头信息之间的不一致。否则，本响应就应当包含所有本应该返回 200 响应中应当返回的所有实体头部域。&lt;/li>
&lt;li>假如 ETag 或 Last-Modified 头部不能精确匹配的话，则客户端缓存应禁止将 206 响应返回的内容与之前任何缓存过的内容组合在一起。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>207 Multi-Status，由 WebDAV(RFC 2518)扩展的状态码，代表之后的消息体将是一个 XML 消息，并且可能依照之前子请求数量的不同，包含一系列独立的响应代码。&lt;/li>
&lt;/ul>
&lt;h2 id="重定向3xx300-305">重定向，3XX（300-305）&lt;/h2>
&lt;p>Notes: 在访问一个网页时，除非收到 3XX 重定向的响应，否则浏览器地址栏中的地址是不会改变的，比如 Nginx 中的 rewrite 功能，如果不使用 &lt;strong>redirect&lt;/strong> 或 &lt;strong>permanent&lt;/strong> 标志，那么所有的 URL 改变都是针对 Nginx 内部来说的。&lt;/p>
&lt;p>这类状态码代表需要客户端采取进一步的操作才能完成请求。通常，这些状态码用来重定向，后续的请求地址（重定向的目标）在本次响应头的 Location 字段中指明。当且仅当后续的请求所使用的方法是 GET 或者 HEAD 时，用户浏览器才可以在没有用户介入的情况下自动提交所需要的后续请求。客户端应当自动监测无限循环重定向（例如：A-&amp;gt;A，或者 A-&amp;gt;B-&amp;gt;C-&amp;gt;A），因为这会导致服务器和客户端大量不必要的资源消耗。按照 HTTP/1.0 版规范的建议，浏览器不应自动访问超过 5 次的重定向。&lt;/p>
&lt;ul>
&lt;li>300 Multiple Choices，被请求的资源有一系列可供选择的回馈信息，每个都有自己特定的地址和浏览器驱动的商议信息。用户或浏览器能够自行选择一个首选的地址进行重定向。除非这是一个 HEAD 请求，否则该响应应当包括一个资源特性及地址的列表的实体，以便用户或浏览器从中选择最合适的重定向地址。这个实体的格式由 Content-Type 定义的格式所决定。浏览器可能根据响应的格式以及浏览器自身能力，自动作出最合适的选择。当然，RFC 2616 规范并没有规定这样的自动选择该如何进行。如果服务器本身已经有了首选的回馈选择，那么在 Location(位置)中应当指明这个回馈的 URL；浏览器可能会将这个 Location 值作为自动重定向的地址。此外，除非额外指定，否则这个响应也是可缓存的。&lt;/li>
&lt;li>301 Moved Permanently，永久重定向被请求的资源已永久移动到新位置，并且将来任何对此资源的引用都应该使用本响应返回的若干个 URL 之一。如果可能，拥有链接编辑功能的客户端应当自动把请求的地址修改为从服务器反馈回来的地址。除非额外指定，否则这个响应也是可缓存的。新的永久性的 URL 应当在响应的 Location 域中返回。除非这是一个 HEAD 请求，否则响应的实体中应当包含指向新的 URI 的超链接及简短说明。如果这不是一个 GET 或者 HEAD 请求，因此浏览器禁止自动进行重定向，除非得到用户的确认，因为请求的条件可能因此发生变化。
&lt;ul>
&lt;li>注意：对于某些使用 HTTP/1.0 协议的浏览器，当它们发送的 POST 请求得到了一个 301 响应的话，接下来的重定向请求将会变成 GET 方式。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>302 Move temporarily，临时重定向请求的资源临时从不同的 URL 响应请求。由于这样的重定向是临时的，客户端应当继续向原有地址发送以后的请求。只有在 Cache-Control 或 Expires 中进行了指定的情况下，这个响应才是可缓存的。如果这不是一个 GET 或者 HEAD 请求，那么浏览器禁止自动进行重定向，除非得到用户的确认，因为请求的条件可能因此发生变化。&lt;/li>
&lt;li>303 See Other，对应当前请求的响应可以在另一个 URI 上被找到，而且客户端应当采用 GET 的方式访问那个资源。这个方法的存在主要是为了允许由脚本激活的 POST 请求输出重定向到一个新的资源。这个新的 URI 不是原始资源的替代引用。同时，303 响应禁止被缓存。当然，第二个请求（重定向）可能被缓存。&lt;/li>
&lt;li>304 Not Modified，缓存没被修改，client 发出条件式请求，但 server 上的资源未曾发生改变（比如本地有缓存，client 就发出条件请求，向 server 确认该缓存是否有更新）如果客户端发送了一个带条件的 GET 请求且该请求已被允许，而文档的内容（自上次访问以来或者根据请求的条件）并没有改变，则服务器应当返回这个状态码。304 响应禁止包含消息体，因此始终以消息头后的第一个空行结尾。
&lt;ul>
&lt;li>该响应必须包含以下的头信息：
&lt;ul>
&lt;li>Date，除非这个服务器没有时钟。假如没有时钟的服务器也遵守这些规则，那么代理服务器以及客户端可以自行将 Date 字段添加到接收到的响应头中去，缓存机制将会正常工作。&lt;/li>
&lt;li>ETag 和/或 Content-Location，假如同样的请求本应返回 200 响应。&lt;/li>
&lt;li>Expires, Cache-Control，和/或 Vary，假如其值可能与之前相同变量的其他响应对应的值不同的话。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>假如本响应请求使用了强缓存验证，那么本次响应不应该包含其他实体头；否则（例如，某个带条件的 GET 请求使用了弱缓存验证），本次响应禁止包含其他实体头；这避免了缓存了的实体内容和更新了的实体头信息之间的不一致。&lt;/li>
&lt;li>假如某个 304 响应指明了当前某个实体没有缓存，那么缓存系统必须忽视这个响应，并且重复发送不包含限制条件的请求。&lt;/li>
&lt;li>假如接收到一个要求更新某个缓存条目的 304 响应，那么缓存系统必须更新整个条目以反映所有在响应中被更新的字段的值。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>305 Use Proxy，被请求的资源必须通过指定的代理才能被访问。Location 域中将给出指定的代理所在的 URI 信息，接收者需要重复发送一个单独的请求，通过这个代理才能访问相应资源。只有原始服务器才能建立 305 响应。&lt;/li>
&lt;li>306 Switch Proxy，在最新版的规范中，306 状态码已经不再被使用。&lt;/li>
&lt;li>307 Temporary Redirect，请求的资源临时从不同的 URI 响应请求。新的临时性的 URI 应当在响应的 Location 域中返回。除非这是一个 HEAD 请求，否则响应的实体中应当包含指向新的 URI 的超链接及简短说明。因为部分浏览器不能识别 307 响应，因此需要添加上述必要信息以便用户能够理解并向新的 URI 发出访问请求。如果这不是一个 GET 或者 HEAD 请求，那么浏览器禁止自动进行重定向，除非得到用户的确认，因为请求的条件可能因此发生变化。&lt;/li>
&lt;/ul>
&lt;h2 id="client-错误4xx400-415">client 错误，4XX（400-415）&lt;/h2>
&lt;p>这类的状态码代表了客户端看起来可能发生了错误，妨碍了服务器的处理。除非响应的是一个 HEAD 请求，否则服务器就应该返回一个解释当前错误状况的实体，以及这是临时的还是永久性的状况。这些状态码适用于任何请求方法。浏览器应当向用户显示任何包含在此类错误响应中的实体内容。&lt;/p>
&lt;p>如果错误发生时客户端正在传送数据，那么使用 TCP 的服务器实现应当仔细确保在关闭客户端与服务器之间的连接之前，客户端已经收到了包含错误信息的数据包。如果客户端在收到错误信息后继续向服务器发送数据，服务器的 TCP 栈将向客户端发送一个重置数据包，以清除该客户端所有还未识别的输入缓冲，以免这些数据被服务器上的应用程序读取并干扰后者。&lt;/p>
&lt;ul>
&lt;li>400 Bad Request
&lt;ul>
&lt;li>语义有误，当前请求无法被服务器理解。除非进行修改，否则客户端不应该重复提交这个请求。&lt;/li>
&lt;li>请求参数有误。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>401 Unauthorized，当前请求需要用户验证。该响应必须包含一个适用于被请求资源的 WWW-Authenticate 信息头用以询问用户信息。客户端可以重复提交一个包含恰当的 Authorization 头信息的请求。如果当前请求已经包含了 Authorization 证书，那么 401 响应代表着服务器验证已经拒绝了那些证书。如果 401 响应包含了与前一个响应相同的身份验证询问，且浏览器已经至少尝试了一次验证，那么浏览器应当向用户展示响应中包含的实体信息，因为这个实体信息中可能包含了相关诊断信息。参见 RFC 2617。&lt;/li>
&lt;li>402 Payment Required，该状态码是为了将来可能的需求而预留的。&lt;/li>
&lt;li>403 Forbidden，请求被禁止，服务器已经理解请求，但是拒绝执行它。与 401 响应不同的是，身份验证并不能提供任何帮助，而且这个请求也不应该被重复提交。如果这不是一个 HEAD 请求，而且服务器希望能够讲清楚为何请求不能被执行，那么就应该在实体内描述拒绝的原因。当然服务器也可以返回一个 404 响应，假如它不希望让客户端获得任何信息。&lt;/li>
&lt;li>404 Not Found，server 无法找到 client 请求的 resource。没有信息能够告诉用户这个状况到底是暂时的还是永久的。假如服务器知道情况的话，应当使用 410 状态码来告知旧资源因为某些内部的配置机制问题，已经永久的不可用，而且没有任何可以跳转的地址。404 这个状态码被广泛应用于当服务器不想揭示到底为何请求被拒绝或者没有其他适合的响应可用的情况下。出现这个错误的最有可能的原因是服务器端没有这个页面。&lt;/li>
&lt;li>405 Method Not Allowed，请求行中指定的请求方法不能被用于请求相应的资源。该响应必须返回一个 Allow 头信息用以表示出当前资源能够接受的请求方法的列表。鉴于 PUT，DELETE 方法会对服务器上的资源进行写操作，因而绝大部分的网页服务器都不支持或者在默认配置下不允许上述请求方法，对于此类请求均会返回 405 错误。&lt;/li>
&lt;li>406 Not Acceptable，请求的资源的内容特性无法满足请求头中的条件，因而无法生成响应实体。除非这是一个 HEAD 请求，否则该响应就应当返回一个包含可以让用户或者浏览器从中选择最合适的实体特性以及地址列表的实体。实体的格式由 Content-Type 头中定义的媒体类型决定。浏览器可以根据格式及自身能力自行作出最佳选择。但是，规范中并没有定义任何作出此类自动选择的标准。&lt;/li>
&lt;li>407 Proxy Authentication Required，与 401 响应类似，只不过客户端必须在代理服务器上进行身份验证。代理服务器必须返回一个 Proxy-Authenticate 用以进行身份询问。客户端可以返回一个 Proxy-Authorization 信息头用以验证。参见 RFC 2617。&lt;/li>
&lt;li>408 Request Timeout，请求超时。客户端没有在服务器预备等待的时间内完成一个请求的发送。客户端可以随时再次提交这一请求而无需进行任何更改。&lt;/li>
&lt;li>409 Conflict，由于和被请求的资源的当前状态之间存在冲突，请求无法完成。这个代码只允许用在这样的情况下才能被使用：用户被认为能够解决冲突，并且会重新提交新的请求。该响应应当包含足够的信息以便用户发现冲突的源头。冲突通常发生于对 PUT 请求的处理中。例如，在采用版本检查的环境下，某次 PUT 提交的对特定资源的修改请求所附带的版本信息与之前的某个（第三方）请求向冲突，那么此时服务器就应该返回一个 409 错误，告知用户请求无法完成。此时，响应实体中很可能会包含两个冲突版本之间的差异比较，以便用户重新提交归并以后的新版本。&lt;/li>
&lt;li>410 Gone，被请求的资源在服务器上已经不再可用，而且没有任何已知的转发地址。这样的状况应当被认为是永久性的。如果可能，拥有链接编辑功能的客户端应当在获得用户许可后删除所有指向这个地址的引用。如果服务器不知道或者无法确定这个状况是否是永久的，那么就应该使用 404 状态码。除非额外说明，否则这个响应是可缓存的。410 响应的目的主要是帮助网站管理员维护网站，通知用户该资源已经不再可用，并且服务器拥有者希望所有指向这个资源的远端连接也被删除。这类事件在限时、增值服务中很普遍。同样，410 响应也被用于通知客户端在当前服务器站点上，原本属于某个个人的资源已经不再可用。当然，是否需要把所有永久不可用的资源标记为'410 Gone&amp;rsquo;，以及是否需要保持此标记多长时间，完全取决于服务器拥有者。&lt;/li>
&lt;li>411 Length Required，服务器拒绝在没有定义 Content-Length 头的情况下接受请求。在添加了表明请求消息体长度的有效 Content-Length 头之后，客户端可以再次提交该请求。&lt;/li>
&lt;li>412 Precondition Failed。服务器在验证在请求的头字段中给出先决条件时，没能满足其中的一个或多个。这个状态码允许客户端在获取资源时在请求的元信息（请求头字段数据）中设置先决条件，以此避免该请求方法被应用到其希望的内容以外的资源上。&lt;/li>
&lt;li>413 Request Entity Too Large。服务器拒绝处理当前请求，因为该请求提交的实体数据大小超过了服务器愿意或者能够处理的范围。此种情况下，服务器可以关闭连接以免客户端继续发送此请求。如果这个状况是临时的，服务器应当返回一个 Retry-After 的响应头，以告知客户端可以在多少时间以后重新尝试。&lt;/li>
&lt;li>414 Request-URI Too Long。请求的 URL 长度超过了服务器能够解释的长度，因此服务器拒绝对该请求提供服务。这比较少见，通常的情况包括：
&lt;ul>
&lt;li>本应使用 POST 方法的表单提交变成了 GET 方法，导致查询字符串（Query String）过长。&lt;/li>
&lt;li>重定向 URL “黑洞”，例如每次重定向把旧的 URI 作为新的 URI 的一部分，导致在若干次重定向后 URI 超长。&lt;/li>
&lt;li>客户端正在尝试利用某些服务器中存在的安全漏洞攻击服务器。这类服务器使用固定长度的缓冲读取或操作请求的 URI，当 GET 后的参数超过某个数值后，可能会产生缓冲区溢出，导致任意代码被执行。没有此类漏洞的服务器，应当返回 414 状态码。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>415 Unsupported Media Type。对于当前请求的方法和所请求的资源，请求中提交的实体并不是服务器中所支持的格式，因此请求被拒绝。&lt;/li>
&lt;li>416 Requested Range Not Satisfiable。如果请求中包含了 Range 请求头，并且 Range 中指定的任何数据范围都与当前资源的可用范围不重合，同时请求中又没有定义 If-Range 请求头，那么服务器就应当返回 416 状态码。假如 Range 使用的是字节范围，那么这种情况就是指请求指定的所有数据范围的首字节位置都超过了当前资源的长度。服务器也应当在返回 416 状态码的同时，包含一个 Content-Range 实体头，用以指明当前资源的长度。这个响应也被禁止使用 multipart/byteranges 作为其 Content-Type。&lt;/li>
&lt;li>417 Expectation Failed。在请求头 Expect 中指定的预期内容无法被服务器满足，或者这个服务器是一个代理服务器，它有明显的证据证明在当前路由的下一个节点上，Expect 的内容无法被满足。&lt;/li>
&lt;li>421 too many connections。There are too many connections from your internet address 从当前客户端所在的 IP 地址到服务器的连接数超过了服务器许可的最大范围。通常，这里的 IP 地址指的是从服务器上看到的客户端地址（比如用户的网关或者代理服务器地址）。在这种情况下，连接数的计算可能涉及到不止一个终端用户。&lt;/li>
&lt;li>426 Upgrade Required 是一种 HTTP 协议的错误状态代码，表示服务器拒绝处理客户端使用当前协议发送的请求，但是可以接受其使用升级后的协议发送的请求。比如 http1.0 发起请求，http1.1 响应请求，一般会出现这个状态码&lt;/li>
&lt;/ul>
&lt;h2 id="server-错误5xx500-505">server 错误，5XX（500-505）&lt;/h2>
&lt;p>（5、6 字头）这类状态码代表了服务器在处理请求的过程中有错误或者异常状态发生，也有可能是服务器意识到以当前的软硬件资源无法完成对请求的处理。除非这是一个 HEAD 请求，否则服务器应当包含一个解释当前错误状态以及这个状况是临时的还是永久的解释信息实体。浏览器应当向用户展示任何在当前响应中被包含的实体。这些状态码适用于任何响应方法。&lt;/p>
&lt;ul>
&lt;li>500 Internal Server Error。服务器遇到了一个未曾预料的状况，导致了它无法完成对请求的处理。一般来说，这个问题都会在服务器端的源代码出现错误时出现。&lt;/li>
&lt;li>501 Not Implemented。服务器不支持当前请求所需要的某个功能。当服务器无法识别请求的方法，并且无法支持其对任何资源的请求。&lt;/li>
&lt;li>502 Bad Gateway。作为网关或者代理工作的服务器尝试执行请求时，从上游服务器接收到无效的响应。&lt;/li>
&lt;li>503 Service Unavailable。由于临时的服务器维护或者过载，服务器当前无法处理请求。这个状况是临时的，并且将在一段时间以后恢复。如果能够预计延迟时间，那么响应中可以包含一个 Retry-After 头用以标明这个延迟时间。如果没有给出这个 Retry-After 信息，那么客户端应当以处理 500 响应的方式处理它。
&lt;ul>
&lt;li>注意：503 状态码的存在并不意味着服务器在过载的时候必须使用它。某些服务器只不过是希望拒绝客户端的连接。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>504 Gateway Timeout。作为网关或者代理工作的服务器尝试执行请求时，未能及时从上游服务器（URI 标识出的服务器，例如 HTTP、FTP、LDAP）或者辅助服务器（例如 DNS）收到响应。
&lt;ul>
&lt;li>注意：某些代理服务器在 DNS 查询超时时会返回 400 或者 500 错误&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>505 HTTP Version Not Supported。服务器不支持，或者拒绝支持在请求中使用的 HTTP 版本。这暗示着服务器不能或不愿使用与客户端相同的版本。响应中应当包含一个描述了为何版本不被支持以及服务器支持哪些协议的实体。&lt;/li>
&lt;li>506 Variant Also Negotiates。由《透明内容协商协议》（RFC 2295）扩展，代表服务器存在内部配置错误：被请求的协商变元资源被配置为在透明内容协商中使用自己，因此在一个协商处理中不是一个合适的重点。&lt;/li>
&lt;li>507 Insufficient Storage。服务器无法存储完成请求所必须的内容。这个状况被认为是临时的。WebDAV (RFC 4918)&lt;/li>
&lt;li>509 Bandwidth Limit Exceeded。服务器达到带宽限制。这不是一个官方的状态码，但是仍被广泛使用。&lt;/li>
&lt;li>510 Not Extended。获取资源所需要的策略并没有被满足。（RFC 2774）&lt;/li>
&lt;li>600 Unparseable Response Headers。源站没有返回响应头部，只返回实体内容&lt;/li>
&lt;/ul></description></item><item><title>Docs: HTTP 的 持久化 与 认证_授权</title><link>https://desistdaydream.github.io/docs/4.%E6%95%B0%E6%8D%AE%E9%80%9A%E4%BF%A1/%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/7.HTTP/HTTP-%E4%BC%9A%E8%AF%9D%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/4.%E6%95%B0%E6%8D%AE%E9%80%9A%E4%BF%A1/%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/7.HTTP/HTTP-%E4%BC%9A%E8%AF%9D%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86/</guid><description/></item><item><title>Docs: HTTP 的实现</title><link>https://desistdaydream.github.io/docs/4.%E6%95%B0%E6%8D%AE%E9%80%9A%E4%BF%A1/%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/7.HTTP/HTTP-%E7%9A%84%E5%AE%9E%E7%8E%B0/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/4.%E6%95%B0%E6%8D%AE%E9%80%9A%E4%BF%A1/%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/7.HTTP/HTTP-%E7%9A%84%E5%AE%9E%E7%8E%B0/</guid><description>
&lt;p>HTTP 服务器的程序(想提供 web 服务必须要安装一下程序中的一个)&lt;/p>
&lt;ul>
&lt;li>httpd(apache)&lt;/li>
&lt;li>nginx&lt;/li>
&lt;li>lighttpd&lt;/li>
&lt;li>应用程序服务器：上面的程序如果不附加插件则只支持静态的网页，装上下面的程序还能解析 PHP 等动态界面
&lt;ul>
&lt;li>IIS&lt;/li>
&lt;li>tomcat，jetty，就 boss，resin&lt;/li>
&lt;li>webshpere,weblogic,oc4j&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h1 id="httpd">httpd&lt;/h1>
&lt;p>apache(a patchy server)的特性&lt;/p>
&lt;ul>
&lt;li>高度模块化：core+modules&lt;/li>
&lt;li>DSO：Dynamic Shared Object&lt;/li>
&lt;li>MPM：Multipath Processing Modules 多路处理模块，不同的工作方式，可以切换，使用不同模块可以满足不同需求
&lt;ul>
&lt;li>prefork：多进程模型，每个进程响应一个请求
&lt;ul>
&lt;li>一个主进程：负责生成 n 个子近侧很难过，子进程也成为工作进程，每个子进程处理一个用户请求，即便没有用户请求，也会预先生成多个空闲进程，随时等待请求到达，最大不超过 1024 个&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>worker：多线程模型
&lt;ul>
&lt;li>一个主进程：负责生成子进程；负责创建套接字；负责接收请求，并将其派发给某子进程进行处理；&lt;/li>
&lt;li>多个子进程：每个子进程负责生成多个线程；&lt;/li>
&lt;li>每个线程：负责响应用户请求；&lt;/li>
&lt;li>并发响应数量：m*n&lt;/li>
&lt;li>m：子进程数量&lt;/li>
&lt;li>n：每个子进程所能创建的最大线程数量；&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>event：事件驱动模型，多进程模型，每个进程响应多个请求（老版本系统不支持，systemd 系统支持）
&lt;ul>
&lt;li>一个主进程 ：负责生成子进程；负责创建套接字；负责接收请求，并将其派发给某子进程进行处理；&lt;/li>
&lt;li>子进程：基于事件驱动机制直接响应多个请求；&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h2 id="httpd-配置">Httpd 配置&lt;/h2>
&lt;p>程序环境(.init 系统下)&lt;/p>
&lt;ul>
&lt;li>配置文件
&lt;ul>
&lt;li>/etc/httpd/conf/httpd.conf&lt;/li>
&lt;li>/etc/httpd/conf.d/*.conf&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>服务脚本
&lt;ul>
&lt;li>/etc/rc.d/init.d/httpd&lt;/li>
&lt;li>配置文件/etc/sysconfig/httpd&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>主程序文件
&lt;ul>
&lt;li>/usr/sbin/httpd&lt;/li>
&lt;li>/usr/sbin/httpd.event&lt;/li>
&lt;li>/usr/sbin/httpd.worker&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>日志文件目录
&lt;ul>
&lt;li>/var/log/httpd
&lt;ul>
&lt;li>access_log:访问日志&lt;/li>
&lt;li>error_log:错误日志&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>站点文档目录
&lt;ul>
&lt;li>/var/www/html&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul></description></item><item><title>Docs: HTTP 管理</title><link>https://desistdaydream.github.io/docs/4.%E6%95%B0%E6%8D%AE%E9%80%9A%E4%BF%A1/%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/7.HTTP/HTTP-%E7%AE%A1%E7%90%86/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/4.%E6%95%B0%E6%8D%AE%E9%80%9A%E4%BF%A1/%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/7.HTTP/HTTP-%E7%AE%A1%E7%90%86/</guid><description/></item><item><title>Docs: HTTP 缓存</title><link>https://desistdaydream.github.io/docs/4.%E6%95%B0%E6%8D%AE%E9%80%9A%E4%BF%A1/%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/7.HTTP/HTTP-%E7%BC%93%E5%AD%98/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/4.%E6%95%B0%E6%8D%AE%E9%80%9A%E4%BF%A1/%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/7.HTTP/HTTP-%E7%BC%93%E5%AD%98/</guid><description/></item><item><title>Docs: HTTP2</title><link>https://desistdaydream.github.io/docs/4.%E6%95%B0%E6%8D%AE%E9%80%9A%E4%BF%A1/%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/7.HTTP/HTTP2/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/4.%E6%95%B0%E6%8D%AE%E9%80%9A%E4%BF%A1/%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/7.HTTP/HTTP2/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://tools.ietf.org/html/rfc7540">RFC，7540&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://http2.github.io/">官网&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://mp.weixin.qq.com/s/WQpxfwLArltKEjEAdOO2Pw">51 张图助你彻底掌握 HTTP 协议&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://mp.weixin.qq.com/s/a83_NE-ww36FZsy320MQFQ">https://mp.weixin.qq.com/s/a83_NE-ww36FZsy320MQFQ&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>HTTP 2.0 在性能上实现了很大的飞跃，更难得的是它在改进的同时保持了语义的不变，与 HTTP 1.1 的语义完全相同！比如请求方法、URI、状态码、头字段等概念都保留不变，这样就消除了再学习的成本，在我们的日常软件升级中，&lt;strong>向下兼容&lt;/strong>非常重要，也是促进产品大规模使用的一个前提，不然你一升级，各种接口之类的全换了，谁还敢升。 &lt;strong>HTTP 2.0 只在语法上做了重要改进，完全变更了 HTTP 报文的传输格式&lt;/strong>&lt;/p>
&lt;p>在语法上主要实现了以下改造&lt;/p>
&lt;h3 id="1头部压缩">1、头部压缩&lt;/h3>
&lt;p>HTTP 1.1 考虑了 body 的压缩，但没有考虑 header 的压缩, 经常出现传了头部上百，上千字节，但 Body 却只有几十字节的情况，浪费了带宽，而且我们知道从 1.1 开始默认是长连接，几百上千个请求都用的这个连接，而请求的头部很多都是重复的，造成了带宽的极大浪费!想象一下面的这个请求，为了传输区区 「name=michale 」这几个字节，却要传输如此巨量的头部，浪费的带宽确实惊人。&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/ucykv5/1616161148212-dbadab6a-315e-4589-8750-cb9f05553948.png" alt="">&lt;/p>
&lt;p>那么 HTTP 2.0 是如何解决的呢？它开发了专门的 「HPACK」算法，在客户端和服务器两端建立字典，用索引号表示重复的字符串，还采用哈夫曼编码来压缩数字和整数，可以达到最高达 90% 的压缩率&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/ucykv5/1616161148192-45f35344-e164-46ee-aa3c-61a0bba6c732.png" alt="">&lt;/p>
&lt;p>这里简单解释下，头部压缩需要在支持 HTTP 2.0 的客户端和服务器之间：&lt;/p>
&lt;ol>
&lt;li>维护一份静态的字典（Static table），包含常见的头部名称，以及特别常见的头部名称与值的组合。这样的话如果请求响应命中了静态字典，直接发索引号即可&lt;/li>
&lt;li>维护一份相同的动态字典（Dynamic table），可以动态地添加字典，这样的话如果客户端首次请求由于「User-Agent: xxx」,「host:xxx」,「Cookie」这些的动态键值对没有命中静态字典，还是会传给服务器，但服务器收到后会基于传过来的键值对创建动态字典条目，如上图的「User-Agent: xxx」对应数字 62，「host:xxx」对应数字 63，这样双方都创建动态条目后，之后就可以用只传 62，63 这样的索引号来通信了！显而易见，传输数据急遽降低，极大地提升了传输效率！需要注意的是动态字典是每个连接自己维护的，也就是对于每个连接而言，首次都必须发送动态键值对&lt;/li>
&lt;li>支持基于静态哈夫曼码表的哈夫曼编码（Huffman Coding）：对于静态、动态字典中不存在的内容，可以使用哈夫曼编码来减小体积。HTTP/2 使用了一份静态哈夫曼码表（详见），也需要内置在客户端和服务端之中。&lt;/li>
&lt;/ol>
&lt;h3 id="2二进制格式">2、二进制格式&lt;/h3>
&lt;p>HTTP 1.1 是纯文本形式，而 2.0 是完全的二进制形式，它把 TCP 协议的部分特性挪到了应用层，把原来的 Header+Body 消息打散为了数个小版的二进制&amp;quot;帧&amp;quot;（Frame）,“HEADERS”帧存放头数据、“DATA”帧存放实体数据&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/ucykv5/1616161148271-6532e9c1-a86d-4794-ae42-de56f5188c1a.png" alt="">&lt;/p>
&lt;p>这些二进制帧只认 0，1，基于这种考虑 http 2.0 的协议解析决定采用二进制格式，使用二进制的形式虽然对人不友好，但&lt;strong>大大方便了计算机的解析&lt;/strong>，原来使用纯文本容易出现多义性，如大小写，空白字符等，程序在处理时必须用复杂的状态机，&lt;strong>效率低，还麻烦&lt;/strong>。而使用二进制的话可以严格规定字段大小、顺序、标志位等格式，“对就是对，错就是错”，&lt;strong>解析起来没有歧义，实现简单，而且体积小、速度快。&lt;/strong>&lt;/p>
&lt;h3 id="3-流">3. 流&lt;/h3>
&lt;p>HTTP 2 定义了「流」（stream）的的概念，它是二进制帧的双向传输序列，同一个消息往返的数据帧 （header 帧和 data 帧）会分配一个唯一的流 ID，这样我们就能区分每一个请求。在这个虚拟的流里，数据帧按先后次序传输，到达应答方后，将这些数据帧按它们的先后顺序组装起来，最后解析 HTTP 1.1 的请求头和实体。&lt;/p>
&lt;p>在&lt;strong>同一时间&lt;/strong>，请求方可以在流里发请求，应答方也可以也流里发响应，对比 HTTP 1.1 一个连接一次只能处理一次请求-应答，吞吐量大大提升&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/ucykv5/1616161148223-75161729-344f-4bd8-98f5-10f6f23aab4c.png" alt="">&lt;/p>
&lt;p>&lt;strong>如图示，一个连接里多个流可以同时收发请求-应答数据帧，每个流中数据包按序传输组装&lt;/strong>&lt;/p>
&lt;p>所有的流都是在同一个连接中流动的，这也是 HTTP 2.0 经典的&lt;strong>多路复用&lt;/strong>（ Multiplexing），另外由于每个流都是独立的，所以谁先处理好请求，谁就可以先将响应通过连接发送给对方，也就解决了队头阻塞的问题。&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/ucykv5/1616161148167-417e8e93-dbe1-43d6-b4b0-ffdda356eb36.png" alt="">&lt;/p>
&lt;p>&lt;strong>如图示，在 HTTP 2 中，两个请求同时发送，可以同时接收，而在 HTTP 1.1 中必须等上一个请求响应后才能处理下一个请求&lt;/strong>&lt;/p>
&lt;h3 id="http-2-的队头阻塞">HTTP 2 的队头阻塞&lt;/h3>
&lt;p>HTTP 2 引入的流，帧等语法层面的改造确实让其传输效率有了质的飞跃，但是它依然存在着队头阻塞，这是咋回事？&lt;/p>
&lt;p>其实主要是因为 HTTP 2 的分帧主要是在应用层处理的，而分帧最终还是要传给下层的 TCP 层经由它封装后再进行传输，每个连接最终还是顺序传输这些包，
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/ucykv5/1616161148187-3d17b319-06b7-4fb6-98cd-7a3ce63af1d8.png" alt="">
&lt;strong>如图示：流只是我们虚拟出来的概念，最终在连接层面还是顺序传的&lt;/strong>&lt;/p>
&lt;p>TCP 是可靠连接，为了保证这些包能顺序传给对方，会进行丢包重传机制，如果传了三个包，后两个包传成功，但第一个包传失败了，TCP 协议栈会把已收到的包暂存到缓存区中，停下等待第一个包的重传成功，这样的话在网络不佳的情况下只要一个包阻塞了，由于重传机制，后面的包就被阻塞了，上层应用由于拿不到包也只能干瞪眼了。&lt;/p>
&lt;p>由于这是 TCP 协议层面的机制，无法改造，所以 HTTP 2 的队头阻塞是不可避免的。HTTP 3 对此进行了改进，将 TCP 换成了 UDP 来进行传输，由于 UDP 是无序的，不需要断建连，包之间没有依赖关系，所以从根本上解决了“队头阻塞”, 当然由于 UDP 本身的这些特性不足以支撑可靠的通信，所以 Google 在 UDP 的基础上也加了 TCP 的连接管理，拥塞窗口，流量控制等机制，这套协议我们称之为 QUIC 协议。
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/ucykv5/1616161148202-483920df-f46e-43fc-83b2-75c6e80cd747.png" alt="">
可以看到不管是 HTTP 2 还是 3 它们底层都支持用 TLS，保留了 HTTPS 安全的特性，这也可以理解，在互联网发展如此迅猛的今天，各大企业也越来越重视通信安全。&lt;/p></description></item><item><title>Docs: HTTP3</title><link>https://desistdaydream.github.io/docs/4.%E6%95%B0%E6%8D%AE%E9%80%9A%E4%BF%A1/%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/7.HTTP/HTTP3/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/4.%E6%95%B0%E6%8D%AE%E9%80%9A%E4%BF%A1/%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/7.HTTP/HTTP3/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://mp.weixin.qq.com/s/Fwxfzzu6QdqyiYUI38afIQ">支付宝二面：如何用 UDP 实现可靠传输？&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;h1 id="quic">QUIC&lt;/h1>
&lt;ul>
&lt;li>原文：&lt;a href="https://mp.weixin.qq.com/s/Fwxfzzu6QdqyiYUI38afIQ">公众号-编程指北，如何用 UDP 实现可靠传输&lt;/a>&lt;/li>
&lt;/ul>
&lt;blockquote>
&lt;p>&lt;strong>自 2015 年以来，QUIC 协议开始在 IETF 进行标准化并被国内外各大厂商相继落地。鉴于 QUIC 具备“0RTT 建联”、“支持连接迁移”等诸多优势，并将成为下一代互联网协议：HTTP3.0 的底层传输协议，蚂蚁集团支付宝客户端团队与接入网关团队于 2018 年下半年开始在移动支付、海外加速等场景落地 QUIC。&lt;/strong>&lt;/p>
&lt;/blockquote>
&lt;p>本文是综述篇，介绍&lt;strong>QUIC&lt;/strong>  在蚂蚁的整体落地情况。&lt;/p>
&lt;p>之所以是综述，是因为 QUIC 协议过于复杂，如果对标已有的协议，QUIC 近似等于 HTTP + TLS +TCP，无法详细的毕其功于一役，因此我们通过综述的方式将落地的重点呈现给读者，主要介绍如下几个部分：&lt;/p>
&lt;ul>
&lt;li>QUIC 背景：简单全面的介绍下 QUIC 相关的背景知识&lt;/li>
&lt;li>方案选型设计：详细介绍蚂蚁的落地方案如何另辟蹊径、优雅的支撑 QUIC 的诸多特性，包括连接迁移等&lt;/li>
&lt;li>落地场景：介绍 QUIC 在蚂蚁的两个落地场景，包括：支付宝客户端链路以及海外加速链路&lt;/li>
&lt;li>几项关键技术：介绍落地 QUIC 过程中核心需要解决的问题，以及我们使用的方案，包括：“支持连接迁移”、“提升 0RTT 比例&amp;quot;， &amp;ldquo;支持 UDP 无损升级”以及“客户端智能选路”  等&lt;/li>
&lt;li>几项关键的技术专利&lt;/li>
&lt;/ul>
&lt;p>本文也是 QUIC 协议介绍的第一篇，后续我们会把更多的落地细节、体验优化手段、性能优化手段、安全与高可用、QUIC 新技术等呈现给大家。&lt;/p>
&lt;p>【注】蚂蚁 QUIC 开发团队包括：支付宝客户端团队的梅男、苍茫、述言，以及接入网关的伯琴、子荃、毅丝。&lt;/p>
&lt;p>&lt;strong>QUIC  背景介绍&lt;/strong>&lt;/p>
&lt;p>鉴于读者的背景可能不同，在开始本文之前，我们先简单介绍下 QUIC 相关的背景知识，如果您对这个协议的更多设计细节感兴趣，可以参见相关 Draft：&lt;a href="https://datatracker.ietf.org/wg/quic/documents/">https://datatracker.ietf.org/wg/quic/documents/&lt;/a>&lt;/p>
&lt;h2 id="一quic-是什么">&lt;strong>一、QUIC 是什么？&lt;/strong>&lt;/h2>
&lt;p>简单来说，QUIC (Quick UDP Internet Connections) 是一种基于 UDP 封装的安全   可靠传输协议，他的目标是取代 TCP 并自包含 TLS 成为标准的安全传输协议。下图是 QUIC 在协议栈中的位置，基于 QUIC 承载的 HTTP 协议进一步被标准化为 HTTP3.0。&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/ed23ba12-a45f-4b3f-a00e-fcf7716c950a/640" alt="">&lt;/p>
&lt;h2 id="二为什么是-quic-">&lt;strong>二、为什么是 QUIC ？&lt;/strong>&lt;/h2>
&lt;p>在 QUIC 出现之前，TCP 承载了 90% 多的互联网流量，似乎也没什么问题，那又为何会出现革命者 QUIC 呢？这主要是因为发展了几十年的 TCP 面临 “协议僵化问题”，表现在几方面：&lt;/p>
&lt;ol>
&lt;li>网络设备支持 TCP 时的僵化，表现在：对于一些防火墙或者 NAT 等设备，如果 TCP 引入了新的特性，比如增加了某些 TCP OPTION 等，可能会被认为是攻击而丢包，导致新特性在老的网络设备上无法工作。&lt;/li>
&lt;li>网络操作系统升级困难导致的 TCP 僵化，一些 TCP 的特性无法快速的被演进。&lt;/li>
&lt;li>除此之外，当应用层协议优化到 TLS1.3、 HTTP2.0 后， 传输层的优化也提上了议程，QUIC 在 TCP 基础上，取其精华去其糟粕具有如下的硬核优势：&lt;/li>
&lt;/ol>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/ed23ba12-a45f-4b3f-a00e-fcf7716c950a/640" alt="">&lt;/p>
&lt;h2 id="三quic-生态圈发展简史">&lt;strong>三、QUIC 生态圈发展简史&lt;/strong>&lt;/h2>
&lt;p>下图是 QUIC 从创建到现在为止的一些比较重要的时间节点，2021 年，QUIC V1 即将成为 RFC，结束百花齐放的态势。&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/ed23ba12-a45f-4b3f-a00e-fcf7716c950a/640" alt="">&lt;/p>
&lt;p>介绍完 QUIC 相关背景，之后我们来介绍蚂蚁的整个落地的内容，这里为了便于阐述，我们用蚂蚁 QUIC 的 一、二、三、四 来进行概括总结，即 “一套落地框架”、“两个落地场景”、“三篇创新专利保护”、“四项关键技术”。&lt;/p>
&lt;p>&lt;strong>一套落地框架&lt;/strong>&lt;/p>
&lt;p>蚂蚁的接入网关是基于多进程的 NGINX 开发的 (内部称为 Spanner，协议卸载的扳手)，而 UDP 在多进程编程模型上存在诸多挑战，典型的像无损升级等。为了设计一套完备的框架，我们在落地前充分考虑了服务端在云上部署上的方便性、扩展性、以及性能问题，设计了如下的落地框架以支撑不同的落地场景：&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/ed23ba12-a45f-4b3f-a00e-fcf7716c950a/640" alt="">&lt;/p>
&lt;p>在这套框架中，包括如下两个组件：&lt;/p>
&lt;ol>
&lt;li>QUIC LB 组件：基于 NGINX 4 层 UDP Stream 模块开发，用来基于 QUIC DCID 中携带的服务端信息进行路由，以支持连接迁移。&lt;/li>
&lt;li>NGINX QUIC 服务器：开发了 NGINX_QUIC_MODULE，每个 Worker 监听两种类型的端口：
（1）BASE PORT ，每个 Worker 使用的相同的端口号，以 Reuseport 的形式监听，并暴露给 QUIC LB，用以接收客户端过来的第一个 RTT 中的数据包，这类包的特点是 DCID 由客户端生成，没有路由信息。
（2）Working PORT，每个 Worker 使用的不同的端口号，是真正的工作端口，用以接收第一个 RTT 之后的 QUIC 包，这类包的特定是 DCID 由服务端的进程生成携带有服务端的信息。&lt;/li>
&lt;/ol>
&lt;p>当前框架支持的能力包括如下：&lt;/p>
&lt;ol>
&lt;li>在不用修改内核的情况下，完全在用户态支持 QUIC 的连接迁移，以及连接迁移时 CID 的 Update&lt;/li>
&lt;li>在不用修改内核的情况下，完全在用户态支持 QUIC 的无损升级以及其他运维问题&lt;/li>
&lt;li>支持真正意义上的 0RTT ，并可提升 0RTT 的比例&lt;/li>
&lt;/ol>
&lt;p>为何能支持上述能力，我们后面会展开叙述&lt;/p>
&lt;p>&lt;strong>两个落地场景&lt;/strong>&lt;/p>
&lt;p>我们由近及远的两个落地场景如下：&lt;/p>
&lt;p>&lt;strong>场景一、支付宝移动端落地&lt;/strong>&lt;/p>
&lt;p>如下为我们落地架构的示意图，支付宝手机客户端通过 QUIC 携带 HTTP 请求，通过 QUIC LB 等四层网关将请求转发到 Spanner （蚂蚁内部基于 NGINX 开发的 7 层网关），在 Spanner 上我们将 QUIC 请求 Proxy 成 TCP 请求，发送给业务网关（RS）。&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/ed23ba12-a45f-4b3f-a00e-fcf7716c950a/640" alt="">&lt;/p>
&lt;p>具体的方案选型如下：&lt;/p>
&lt;ul>
&lt;li>支持的 QUIC 版本是 gQUIC Q46。&lt;/li>
&lt;li>NGINX QUIC MODULE 支持 QUIC 的接入和 PROXY 成 TCP 的能力。&lt;/li>
&lt;li>支持包括移动支付、基金、蚂蚁森林在内的所有的 RPC 请求。&lt;/li>
&lt;li>当前选择 QUIC 链路的方式有两种 ：&lt;/li>
&lt;/ul>
&lt;ol>
&lt;li>Backup 模式，即在 TCP 链路无法使用的情况下，降级到 QUIC 链路。&lt;/li>
&lt;li>Smart 模式，即 TCP 和 QUIC 竞速，在 TCP 表现力弱于 QUIC 的情况下，下次请求主动使用 QUIC 链路。&lt;/li>
&lt;/ol>
&lt;p>在此场景下，通过使用 QUIC 可以获得的红利包括：&lt;/p>
&lt;ol>
&lt;li>在客户端连接发生迁移的时候，可以不断链继续服务&lt;/li>
&lt;li>客户端在首次发起连接时，可以节省 TCP 三次握手的时间&lt;/li>
&lt;li>对于弱网情况，QUIC 的传输控制可以带来传输性能提升&lt;/li>
&lt;/ol>
&lt;p>**场景二、**海外加速落地&lt;/p>
&lt;p>蚂蚁集团从 2018 年开始自研了海外的动态加速平台 AGNA（Ant Global Network Accelerator）以替换第三方厂商的加速服务。AGNA 通过在海外部署接入点：Local Proxy(LP) 以及在国内部署接出点：Remote Proxy （RP）的方式，将用户的海外请求通过 LP 和 RP 的加速链路回源国内。如下图所示，我们将 QUIC 部署在 LP 和 RP 之间的链路。&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/ed23ba12-a45f-4b3f-a00e-fcf7716c950a/640" alt="">&lt;/p>
&lt;p>在海外接入点上(LP)，每一个 TCP 连接都被 Proxy 成 QUIC 上的一个 Stream 进行承载，在国内接出点上(RP), 每一个 QUIC Stream 又被 Proxy 成一个 TCP 连接，LP 和 RP 之间使用 QUIC 长连接。&lt;/p>
&lt;p>在此场景下，通过使用 QUIC 可以获得的红利包括：&lt;/p>
&lt;ol>
&lt;li>通过 QUIC 长连接的上的 Stream 承载 TCP 请求，避免每次的跨海建联。&lt;/li>
&lt;li>对于跨海的网络，QUIC 的传输控制可以带来传输性能提升。&lt;/li>
&lt;/ol>
&lt;p>&lt;strong>三篇关键专利&lt;/strong>&lt;/p>
&lt;p>到目前为止，我们把落地过程中一些创新的技术点通过申请专利进行了保护，并积极在 IETF 进行标准化分享我们的研究成果，包括：&lt;/p>
&lt;h3 id="专利一">&lt;strong>专利一&lt;/strong>&lt;/h3>
&lt;p>我们将落地场景 2 中，通过 QUIC Stream 进行四层代理的手段来进行海外回源的加速方法进行专利保护，提出：“一种基于 QUIC 协议代理的的链路加速方法”，目前此专利已经获得美国专利授权，专利号：CN110213241A。&lt;/p>
&lt;h3 id="专利二">&lt;strong>专利二&lt;/strong>&lt;/h3>
&lt;p>将我们落地框架中的 QUIC LB 组件作为专利进行保护，提出：“一种无状态、一致性、分布式的 QUIC 负载均衡设备”，目前此专利还在受理中。由于通过 QUIC LB 可以很好的支持 QUIC 协议的连接迁移问题，所以目前 IETF QUIC WG 上有关于 QUIC LB 相关的草案，我们目前已经参与到 Draft 的讨论和制定中，后序相关的方案也会继续推广到云上产品。&lt;/p>
&lt;h3 id="专利三">&lt;strong>专利三&lt;/strong>&lt;/h3>
&lt;p>将我们解决的 UDP 的无损升级方法进行专利保护，提出 “一种 QUIC 服务器无损升级方案”，目前此专利还在受理中。由于 UDP 无损升级问题是一个业界难题，当前有些手段需要在用户态进行跳转，性能损失较大，我们的方案可以在我们的落地框架中解决当前问题，关于这个方案的细节我们再后面的关键技术中进行介绍。&lt;/p>
&lt;p>&lt;strong>四项关键技术&lt;/strong>&lt;/p>
&lt;p>在整个的落地中，我们设计的方案围绕解决几个核心问题展开，形成了四项关键技术，分别如下&lt;/p>
&lt;h4 id="技术点-1优雅的支持连接迁移能力">&lt;strong>技术点 1.优雅的支持连接迁移能力&lt;/strong>&lt;/h4>
&lt;h4 id="先说-连接迁移面临的问题-上文有提到quic-有一项比较重要的功能是支持连接迁移这里的连接迁移是指如果客户端在长连接保持的情况下切换网络比如从-4g-切换到-wifi--或者因为-nat-rebinding-导致五元组发生变化quic-依然可以在新的五元组上继续进行连接状态quic-之所以能支持连接迁移一个原因是-quic-底层是基于无连接的-udp另一个重要原因是因为-quic-使用唯一的-cid-来标识一个连接而不是五元组">先说  **连接迁移面临的问题 ，**上文有提到，QUIC 有一项比较重要的功能是支持连接迁移。这里的连接迁移是指：如果客户端在长连接保持的情况下切换网络，比如从 4G 切换到 Wifi , 或者因为 NAT Rebinding 导致五元组发生变化，QUIC 依然可以在新的五元组上继续进行连接状态。QUIC 之所以能支持连接迁移，一个原因是 QUIC 底层是基于无连接的 UDP，另一个重要原因是因为 QUIC 使用唯一的 CID 来标识一个连接，而不是五元组。&lt;/h4>
&lt;p>如下图所示，是 QUIC 支持连接的一个示意图，当客户端出口地址从 A 切换成 B 的时候，因为 CID 保持不变，所以在 QUIC 服务器上，依然可以查询到对应的 Session 状态。&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/ed23ba12-a45f-4b3f-a00e-fcf7716c950a/640" alt="">&lt;/p>
&lt;p>然而，理论很丰满，落地却很艰难，在端到端的落地过程中，因为引入了负载均衡设备，会导致在连接迁移时，所有依赖五元组 Hash 做转发或者关联 Session 的机制失效。以 LVS 为例，连接迁移后， LVS 依靠五元组寻址会导致寻址的服务器存在不一致。即便 LVS 寻址正确，当报文到达服务器时，内核根据五元组关联进程，依然会寻址出错。同时，IETF Draft 要求，连接迁移时 CID 需要更新掉，这就为仅依靠 CID 来转发的计划同样变的不可行。&lt;/p>
&lt;h4 id="再说-我们的解决方法为了解决此问题我们设计了开篇介绍的落地框架这里我们将方案做一些简化和抽象整体思路如下图所示">再说  **我们的解决方法，**为了解决此问题，我们设计了开篇介绍的落地框架，这里我们将方案做一些简化和抽象，整体思路如下图所示：&lt;/h4>
&lt;ol>
&lt;li>在四层负载均衡上，我们设计了 QUIC LoadBalancer 的机制：&lt;/li>
&lt;li>我们在 QUIC 的 CID 中扩展了一些字段（ServerInfo）用来关联 QUIC Server 的 IP 和 Working Port 信息。&lt;/li>
&lt;li>在发生连接迁移的时候，QUIC LoadBalancer 可以依赖 CID 中的 ServerInfo 进行路由，避免依赖五元组关联 Session 导致的问题。&lt;/li>
&lt;li>在 CID 需要 Update 的时候，NewCID 中的 ServerInfo 保留不变，这样就避免在 CID 发生 Update 时，仅依赖 CID Hash 挑选后端导致的寻址不一致问题。&lt;/li>
&lt;li>在 QUIC 服务器多进程工作模式上，我们突破了 NGINX 固有的多 Worker 监听在相同端口上的桎梏，设计了多端口监听的机制，每个 Worker 在工作端口上进行隔离，并将端口的信息携带在对 First Initial Packet 的回包的 CID 中，这样代理的好处是：&lt;/li>
&lt;li>无论是否连接迁移，QUIC LB 都可以根据 ServerInfo，将报文转发到正确的进程。&lt;/li>
&lt;li>而业界普遍的方案是修改内核，将 Reuse port 机制改为 Reuse CID 机制，即内核根据 CID 挑选进程。即便后面可以通过 ebpf 等手段支持，但我们认为这种修改内核的机制对底层过于依赖，不利于方案的大规模部署和运维，尤其在公有云上。&lt;/li>
&lt;li>使用独立端口，也有利于多进程模式下，UDP 无损升级问题的解决，这个我们在技术点 3 中介绍。&lt;/li>
&lt;/ol>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/ed23ba12-a45f-4b3f-a00e-fcf7716c950a/640" alt="">&lt;/p>
&lt;p>&lt;strong>技术点 2.提升  0RTT  握手比例&lt;/strong>&lt;/p>
&lt;h4 id="这里先-介绍-quic-0rtt-原理前文我们介绍过-quic-支持传输层握手和安全加密层握手都在一个-0rtt-内完成tls13-本身就支持加密层握手的-0rtt所以不足为奇而-quic-如何实现传输层握手支持-0rtt-呢我们先看下传输层握手的目的即服务端校验客户端是真正想握手的客户端地址不存在欺骗从而避免伪造源地址攻击在-tcp-中服务端依赖三次握手的最后一个-ack-来校验客户端是真正的客户端即只有真正的客户端才会收到-sever-的-syn_ack-并回复">这里先  &lt;strong>介绍 QUIC 0RTT 原理&lt;/strong>。前文我们介绍过， QUIC 支持传输层握手和安全加密层握手都在一个 0RTT 内完成。TLS1.3 本身就支持加密层握手的 0RTT，所以不足为奇。而 QUIC 如何实现传输层握手支持 0RTT 呢？我们先看下传输层握手的目的，即：服务端校验客户端是真正想握手的客户端，地址不存在欺骗，从而避免伪造源地址攻击。在 TCP 中，服务端依赖三次握手的最后一个 ACK 来校验客户端是真正的客户端，即只有真正的客户端才会收到 Sever 的 syn_ack 并回复。&lt;/h4>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/ed23ba12-a45f-4b3f-a00e-fcf7716c950a/640" alt="">&lt;/p>
&lt;p>QUIC 同样需要对握手的源地址做校验，否则便会存在 UDP 本身的 DDOS 问题，那 QUIC 是如何实现的？依赖 STK(Source Address Token) 机制。这里我们先声明下，跟 TLS 类似，QUIC 的 0RTT 握手，是建立在已经同一个服务器建立过连接的基础上，所以如果是纯的第一次连接，仍然需要一个 RTT 来获取这个 STK。如下图所示，我们介绍下这个原理：&lt;/p>
&lt;ol>
&lt;li>类似于 Session Ticket 原理，Server 会将客户端的地址和当前的 Timestamp 通过自己的 KEY 加密生成 STK。&lt;/li>
&lt;li>Client 下次握手的时候，将 STK 携带过来，由于 STK 无法篡改，所以 Server 通过自己的 KEY 解密，如果解出来的地址和客户端此次握手的地址一致，且时间在有效期内，则表示客户端可信，便可以建立连接。&lt;/li>
&lt;li>由于客户端第一次握手的时候，没有这个 STK，所以服务度会回复 REJ 这次握手的信息，并携带 STK。&lt;/li>
&lt;/ol>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/ed23ba12-a45f-4b3f-a00e-fcf7716c950a/640" alt="">&lt;/p>
&lt;p>理论上说，只要客户端缓存了这个 STK，下次握手的时候带过来，服务端便可以直接校验通过，即实现传输层的 0RTT。但是真实的场景却存在&lt;strong>如下两个问题&lt;/strong>：&lt;/p>
&lt;ol>
&lt;li>因为 STK 是服务端加密的，所以如果下次这个客户端路由到别的服务器上了，则这个服务器也需要可以识别出来。&lt;/li>
&lt;li>STK 中 encode 的是上一次客户端的地址，如果下一次客户端携带的地址发生了变化，则同样会导致校验失败。此现象在移动端发生的概率非常大，尤其是 IPV6 场景下，客户端的出口地址会经常发生变化。&lt;/li>
&lt;/ol>
&lt;h4 id="再介绍下我们的解决方法-第一个问题比较好解我们只要保证集群内的机器生成-stk-的秘钥一致即可第二个问题我们的解题思路是">再介绍下&lt;strong>我们的解决方法。&lt;/strong> 第一个问题比较好解，我们只要保证集群内的机器生成 STK 的秘钥一致即可。&lt;strong>第二个问题，我们的解题思路是&lt;/strong>：&lt;/h4>
&lt;ol>
&lt;li>我们在 STK 中扩展了一个 Client ID, 这个 Clinet ID 是客户端通过无线保镖黑盒生成并全局唯一不变的，类似于一个设备的 SIMID，客户端通过加密的 Trasnport Parameter 传递给服务端，服务端在 STK 中包含这个 ID。&lt;/li>
&lt;li>如果因为 Client IP 发生变化导致校验 STK 校验失败，便会去校验 Client ID，因为 ID 对于一个 Client 是永远不变的，所以可以校验成功，当然前提是，这个客户端是真实的。为了防止 Client ID 的泄露等，我们会选择性对 Client ID 校验能力做限流保护。&lt;/li>
&lt;/ol>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/ed23ba12-a45f-4b3f-a00e-fcf7716c950a/640" alt="">&lt;/p>
&lt;h4 id="技术点-3-支持-quic-无损升级">&lt;strong>技术点 3. 支持 QUIC 无损升级&lt;/strong>&lt;/h4>
&lt;h4 id="我们知道-udp-无损升级是业界难题-无损升级是指在-reload-或者更新二进制时老的进程可以处理完存量连接上的数据后优雅退出以-nginx-为例这里先介绍下-tcp-是如何处理无损升级的主要是如下的两个步骤">我们知道  &lt;strong>UDP 无损升级是业界难题。&lt;/strong> 无损升级是指在 reload 或者更新二进制时，老的进程可以处理完存量连接上的数据后优雅退出。以 NGINX 为例，这里先介绍下 TCP 是如何处理无损升级的，主要是如下的两个步骤：&lt;/h4>
&lt;ol>
&lt;li>老进程先关闭 listening socket，待存量连接请求都结束后，再关闭连接套接字&lt;/li>
&lt;li>新进程从老进程继承 listening socket , 开始 accept 新的请求&lt;/li>
&lt;/ol>
&lt;p>而 UDP 无法做到无损升级是因为 UDP 只有一个 listening socket 没有类似 TCP 的连接套接字，所有的收发数据包都在这个 socket 上，导致下面的热升级步骤会存在问题：&lt;/p>
&lt;ol>
&lt;li>在热升级的时候，old process fork 出 new process 后，new process 会继承 listening socket 并开始 recv msg。&lt;/li>
&lt;li>而 old process 此时如果关闭 listenging socket， 则在途的数据包便无法接收，达不到优雅退出的目的。&lt;/li>
&lt;li>而如果继续监听，则新老进程都会同时收取新连接上的报文，导致老进程无法退出。&lt;/li>
&lt;/ol>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/ed23ba12-a45f-4b3f-a00e-fcf7716c950a/640" alt="">&lt;/p>
&lt;h4 id="这里介绍下相关的解决方法-针对此问题业界有一些方法比如在数据包中携带进程号当数据包收发错乱后在新老进程之间做一次转发考虑到接入层上的性能等原因我们不希望数据再做一次跳转结合我们的落地架构我们设计了如下的-基于多端口轮转的无损升级方案简单来说我们让新老进程监听在不同的端口组并携带在-cid-中这样-quic-lb-就可以根据端口转发到新老进程为了便于运维我们采用端口轮转的方式新老进程会在-reload-n-次之后重新开始之前选中的端口如下图所示">这里介绍下&lt;strong>相关的解决方法。&lt;/strong> 针对此问题，业界有一些方法，比如：在数据包中携带进程号，当数据包收发错乱后，在新老进程之间做一次转发。考虑到接入层上的性能等原因，我们不希望数据再做一次跳转。结合我们的落地架构，我们设计了如下的  &lt;strong>基于多端口轮转的无损升级方案&lt;/strong>，简单来说，我们让新老进程监听在不同的端口组并携带在 CID 中，这样 QUIC LB 就可以根据端口转发到新老进程。为了便于运维，我们采用端口轮转的方式，新老进程会在 reload N 次之后，重新开始之前选中的端口。如下图所示：&lt;/h4>
&lt;ol>
&lt;li>无损升级期间，老进程的 Baseport 端口关闭，这样不会再接受 first intial packet, 类似于关闭了 tcp 的 listening socket。&lt;/li>
&lt;li>老进程的工作端口，继续工作，用来接收当前进程上残余的流量。&lt;/li>
&lt;li>新进程的 Baseport 开始工作，用来接收 first initial packet, 开启新的连接，类似于开启了 tcp 的 listening socket。&lt;/li>
&lt;li>新进程的 working port = (I + 1) mod N,  N 是指同时支持新老进程的状态的次数，例如 N = 4， 表示可以同时 reload 四次，四种 Old, New1, New2, New3 四种状态同时并存，I 是上一个进程工作的端口号，这里 + 1 是因为只有一个 worker, 如果 worker 数有 M 个，则加 M。&lt;/li>
&lt;li>建好的连接便被 Load Balancer 转移到新进程的监听端口的 Working Port 上。&lt;/li>
&lt;/ol>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/ed23ba12-a45f-4b3f-a00e-fcf7716c950a/640" alt="">&lt;/p>
&lt;p>&lt;strong>技术点 4.客户端智能选路&lt;/strong>&lt;/p>
&lt;p>尽管落地 QUIC 的愿望是好的，但是新事物的发展并不是一帆风顺的。由于 QUIC 是基于 UDP 的，而 UDP 相比于 TCP 在运营商的支持上并非友好，表现在：&lt;/p>
&lt;ol>
&lt;li>在带宽紧张的时候，UDP 会经常被限流。&lt;/li>
&lt;li>一些防火墙对于 UDP 包会直接 Drop。&lt;/li>
&lt;li>NAT 网关针对 UDP 的 Session 存活时间也较短。&lt;/li>
&lt;/ol>
&lt;p>同时，根据观察发现，不同的手机厂商对于 UDP 的支持能力也不同，所以在落地过程中，如果盲目的将所有流量完全切为 QUIC 可能会导致一些难以预料的结果。为此，我们在客户端上，设计了开篇介绍的 TCP 和 QUIC 相互 Backup 的链路，如下图所示，我们实时探测 TCP 链路和 QUIC 链路的 RTT、丢包率、请求完成时间、错误率等指标情况，并根据一定的量化方法对两种链路进行打分，根据评分高低，决定选择走哪种链路，从而避免寻址只走一条链路导致的问题。&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/ed23ba12-a45f-4b3f-a00e-fcf7716c950a/640" alt="">&lt;/p>
&lt;p>&lt;strong>做个总结&lt;/strong>&lt;/p>
&lt;p>本文主要综述性的介绍了 QUIC 在蚂蚁的落地方案、场景以及一些关键技术。&lt;strong>关键技术上&lt;/strong>，主要介绍了我们如何通过创造性的提出 QUIC LB 组件、以及多端口监听的机制来优雅的支持  QUIC 的连接迁移机制、QUIC 服务端的无损升级等，依赖这套方案我们的接入网关不需要像业界一样依赖底层内核的改动，这极大的方便了我们方案的部署，尤其在公有云场景下。除了连接迁移以外，我们还提出了 0RTT 建联提升方案、客户端智能选路方案，以最大化 QUIC 在移动端上的收益。截止当前，QUIC 已经在支付宝移动端以及全球加速链路&lt;strong>两个场景&lt;/strong>上平稳运行，并带来了较好的业务收益。&lt;/p>
&lt;p>&lt;strong>未来规划&lt;/strong>&lt;/p>
&lt;p>两年来，我们主要以社区的 gQuic 为基础，充分发挥 QUIC 的协议优势，并结合蚂蚁的业务特征以最大化移动端收益为目标，创造性的提出了一些解决方案，并积极向社区和 IETF 进行推广。在未来，随着蚂蚁在更多业务上的开展和探索以及 HTTP3.0/QUIC 即将成为标准，我们会主要围绕以下几个方向继续深挖 QUIC 的价值：&lt;/p>
&lt;ol>
&lt;li>我们将利用 QUIC 在应用层实现的优势，设计一套统一的具备自适应业务类型和网络类型的 QUIC 传输控制框架，对不同类型的业务和网络类型，做传输上的调优，以优化业务的网络传输体验。&lt;/li>
&lt;li>将 gQUIC 切换成 IETF QUIC，推进标准的 HTTP3.0 在蚂蚁的进一步落地。&lt;/li>
&lt;li>将蚂蚁的 QUIC LB 技术点向 IETF QUIC LB 进行推进，并最终演变为标准的 QUIC LB。&lt;/li>
&lt;li>探索并落地 MPQUIC（多路径 QUIC）  技术，最大化在移动端的收益。&lt;/li>
&lt;li>继续 QUIC 的性能优化工作，使用 UDP GSO， eBPF，io_uring 等内核技术。&lt;/li>
&lt;li>探索 QUIC 在内网承载东西向流量的机会。&lt;/li>
&lt;/ol></description></item><item><title>Docs: HTTPS</title><link>https://desistdaydream.github.io/docs/4.%E6%95%B0%E6%8D%AE%E9%80%9A%E4%BF%A1/%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/7.HTTP/HTTPS/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/4.%E6%95%B0%E6%8D%AE%E9%80%9A%E4%BF%A1/%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/7.HTTP/HTTPS/</guid><description/></item></channel></rss>