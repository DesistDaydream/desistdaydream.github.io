<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>断念梦 – HTTP 管理</title><link>https://desistdaydream.github.io/docs/4.%E6%95%B0%E6%8D%AE%E9%80%9A%E4%BF%A1/%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/7.HTTP/HTTP-%E7%AE%A1%E7%90%86/</link><description>Recent content in HTTP 管理 on 断念梦</description><generator>Hugo -- gohugo.io</generator><atom:link href="https://desistdaydream.github.io/docs/4.%E6%95%B0%E6%8D%AE%E9%80%9A%E4%BF%A1/%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/7.HTTP/HTTP-%E7%AE%A1%E7%90%86/index.xml" rel="self" type="application/rss+xml"/><item><title>Docs: CORS跨域(一)：深入理解跨域请求概念及其根因</title><link>https://desistdaydream.github.io/docs/4.%E6%95%B0%E6%8D%AE%E9%80%9A%E4%BF%A1/%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/7.HTTP/HTTP-%E7%AE%A1%E7%90%86/CORS%E8%B7%A8%E5%9F%9F%E4%B8%80%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%B7%A8%E5%9F%9F%E8%AF%B7%E6%B1%82%E6%A6%82%E5%BF%B5%E5%8F%8A%E5%85%B6%E6%A0%B9%E5%9B%A0/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/4.%E6%95%B0%E6%8D%AE%E9%80%9A%E4%BF%A1/%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/7.HTTP/HTTP-%E7%AE%A1%E7%90%86/CORS%E8%B7%A8%E5%9F%9F%E4%B8%80%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%B7%A8%E5%9F%9F%E8%AF%B7%E6%B1%82%E6%A6%82%E5%BF%B5%E5%8F%8A%E5%85%B6%E6%A0%B9%E5%9B%A0/</guid><description>
&lt;p>&lt;strong>原文链接：&lt;/strong>&lt;a href="https://mp.weixin.qq.com/s/dynx7wrSINYFKZgGPcD3zQ">https://mp.weixin.qq.com/s/dynx7wrSINYFKZgGPcD3zQ&lt;/a>&lt;/p>
&lt;blockquote>
&lt;p>&lt;strong>❝Talk is cheap. Show me the money.&lt;/strong>&amp;gt; ❞&lt;/p>
&lt;/blockquote>
&lt;h1 id="前言">前言&lt;/h1>
&lt;p>你好，我是&lt;strong>YourBatman&lt;/strong>。
做 Web 开发的小伙伴对“跨域”定并不陌生，像狗皮膏药一样粘着几乎每位同学，对它可谓既爱又恨。跨域请求之于创业、小型公司来讲是个头疼的问题，因为这类企业还未沉淀出一套行之有效的、统一的解决方案。
让人担忧的是，据我了解不少程序员同学（不乏有高级开发）碰到跨域问题大都一头雾水：&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/glml9g/1624260182917-3c20dcea-66db-4950-bd08-2ca996afbd43.webp" alt="">然后很自然的 用谷歌去百度一下搜索答案，但相关文章可能参差不齐、鱼龙混杂。短则半天长则一天（包含改代码、部署等流程）此问题才得以解决，一个“小小跨域”问题成功偷走你的宝贵时间。
既然跨域是个如此常见（特别是当下前后端分离的开发模式），因此深入理解 CORS 变得就异常的重要了（反倒前端工程师不用太了解），因此早在 2019 年我刚开始写博客那会就有过较为详细的系列文章：&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/glml9g/1624260182890-838bfbb6-192c-4666-8af4-a89e80a8aad6.png" alt="">现在把它搬到公众号形成技术专栏，并且加点料，让它更深、更全面、更系统的帮助到你，希望可以助你从此不再怕 Cors 跨域资源共享问题。&lt;/p>
&lt;h2 id="本文提纲">本文提纲&lt;/h2>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/glml9g/1624260182696-51d2c077-47b0-4137-b399-a8bc3183bb21.png" alt="">&lt;/p>
&lt;h2 id="版本约定">版本约定&lt;/h2>
&lt;ul>
&lt;li>JDK：8&lt;/li>
&lt;li>Servlet：4.x&lt;/li>
&lt;/ul>
&lt;h1 id="正文">正文&lt;/h1>
&lt;p>文章遵循一贯的风格，本文将采用概念 + 代码示例的方式，层层递进的进行展开叙述。那么上菜，先来个示例预览，模拟一下&lt;strong>跨域请求&lt;/strong>，后面的一些的概念示例将以此作为抓手。&lt;/p>
&lt;h2 id="模拟跨域请求">模拟跨域请求&lt;/h2>
&lt;p>要模拟跨域请求的根本是需要&lt;strong>两个源&lt;/strong>：让请求的来源和目标源不一样。这里我就使用 IDEA 作为静态 Web 服务器（63342），Tomcat 作为后端动态 Servlet 服务器（8080）。&lt;/p>
&lt;blockquote>
&lt;p>&lt;strong>❝&lt;/strong>&amp;gt; 说明：服务器都在本机，端口不一样即可
❞&lt;/p>
&lt;/blockquote>
&lt;h3 id="前端代码">前端代码&lt;/h3>
&lt;p>index.html&lt;/p>
&lt;pre>&lt;code>&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html lang=&amp;quot;en&amp;quot;&amp;gt;
&amp;lt;head&amp;gt;
&amp;lt;meta charset=&amp;quot;UTF-8&amp;quot;&amp;gt;
&amp;lt;title&amp;gt;CORS跨域请求&amp;lt;/title&amp;gt;
&amp;lt;!--导入Jquery--&amp;gt;
&amp;lt;script src=&amp;quot;https://cdn.bootcdn.net/ajax/libs/jquery/3.6.0/jquery.js&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
&amp;lt;button id=&amp;quot;btn&amp;quot;&amp;gt;跨域从服务端获取内容&amp;lt;/button&amp;gt;
&amp;lt;div id=&amp;quot;content&amp;quot;&amp;gt;&amp;lt;/div&amp;gt;
&amp;lt;script&amp;gt;
$(&amp;quot;#btn&amp;quot;).click(function () {
// 跨域请求
$.get(&amp;quot;http://localhost:8080/cors&amp;quot;, function (result) {
$(&amp;quot;#content&amp;quot;).append(result).append(&amp;quot;&amp;lt;br/&amp;gt;&amp;quot;);
});
// 同域请求
$.get(&amp;quot;http://localhost:63342&amp;quot;);
$.post(&amp;quot;http://localhost:63342&amp;quot;);
});
&amp;lt;/script&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/code>&lt;/pre>
&lt;p>使用 IDEA 作为静态 web 服务器，浏览器输入地址即可访问（注：端口号为 63342）：&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/glml9g/1624260183029-7a7f9241-b8f1-43b1-830a-55e244ea8427.png" alt="">&lt;/p>
&lt;h3 id="后端代码">后端代码&lt;/h3>
&lt;p>后端写个 Servlet 来接收 cors 请求&lt;/p>
&lt;pre>&lt;code>/**
* 在此处添加备注信息
*
* @author YourBatman. &amp;lt;a href=mailto:yourbatman@aliyun.com&amp;gt;Send email to me&amp;lt;/a&amp;gt;
* @site https://yourbatman.cn
* @date 2021/6/9 10:36
* @since 0.0.1
*/
@Slf4j
@WebServlet(urlPatterns = &amp;quot;/cors&amp;quot;)
public class CorsServlet extends HttpServlet {
@Override
protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
String requestURI = req.getRequestURI();
String method = req.getMethod();
String originHeader = req.getHeader(&amp;quot;Origin&amp;quot;);
log.info(&amp;quot;收到请求：{}，方法：{}， Origin头：{}&amp;quot;, requestURI, method, originHeader);
resp.getWriter().write(&amp;quot;hello cors...&amp;quot;);
}
}
&lt;/code>&lt;/pre>
&lt;p>启动后端服务器，点击页面上的&lt;strong>按钮&lt;/strong>，结果如下：&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/glml9g/1624260183029-6d0cd299-4e43-4c40-b451-8a036ce30019.png" alt="">服务端控制台输出：&lt;/p>
&lt;pre>&lt;code>... INFO c.y.cors.servlet.CorsServlet - 收到请求：/cors，方法：GET， Origin头：http://localhost:63342
&lt;/code>&lt;/pre>
&lt;blockquote>
&lt;p>&lt;strong>❝&lt;/strong>&amp;gt; 服务端输出日志，说明即使前端的 Http Status 是 error，但服务端还是收到&lt;strong>并处理了&lt;/strong>这个请求的
❞
下面以此代码示例为基础，普及一下和 Cors 跨域资源共享相关的概念。&lt;/p>
&lt;/blockquote>
&lt;h2 id="hostrefererorigin-的区别">Host、Referer、Origin 的区别&lt;/h2>
&lt;p>这哥三看起来很是相似，下面对概念作出区分。&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/glml9g/1624260182992-b5ba405f-82dd-4071-a854-b6d62a458711.png" alt="">&lt;/p>
&lt;ul>
&lt;li>&lt;strong>Host&lt;/strong>：去哪里。&lt;strong>域名+端口&lt;/strong>。值为客户端将要访问的远程主机，浏览器在发送 Http 请求时会带有此 Header&lt;/li>
&lt;li>&lt;strong>Referer&lt;/strong>：来自哪里。&lt;strong>协议+域名+端口+路径+参数&lt;/strong>。当前请求的&lt;strong>来源页面&lt;/strong>的地址，服务端一般使用 Referer 首部识别访问来源，可能会以此进行统计分析、日志记录以及缓存优化等
&lt;ul>
&lt;li>来源页面协议为 File 或者 Data URI（如页面从本地打开的）&lt;/li>
&lt;li>来源页面是 Https，而目标 URL 是 http&lt;/li>
&lt;li>浏览器地址栏直接输入网址访问，或者通过浏览器的书签直接访问&lt;/li>
&lt;li>使用 JS 的 location.href 跳转&lt;/li>
&lt;li>&amp;hellip;&lt;/li>
&lt;li>常见应用场景：百度的搜索广告就会分析 Referer 来判断打开站点是从百度搜索跳转的，还是直接 URL 输入地址的&lt;/li>
&lt;li>一般情况下浏览器会带有此 Header，但这些 case 不会带有 Referer 这个头&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>Origin&lt;/strong>：来自哪里（跨域）。&lt;strong>协议+域名+端口&lt;/strong>。它用于 Cors 请求和同域 POST 请求&lt;/li>
&lt;/ul>
&lt;p>可以看到 Referer 与 Origin 功能相似，前者一般用于统计和阻止盗链，后者用于 CORS 请求。但是还是有几点不同：&lt;/p>
&lt;ol>
&lt;li>
&lt;p>只有&lt;strong>跨域请求&lt;/strong>，或者&lt;strong>同域时发送 post&lt;/strong>请求，才会携带 Origin 请求头；而 Referer 只要浏览器能获取到都会携带（除了上面说明的几种 case 外）&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/glml9g/1624260183074-01c3b097-a969-4628-8afc-1b048c8cab82.png" alt="">&lt;/p>
&lt;/li>
&lt;li>
&lt;p>若浏览器不能获取到请求源页面地址（如上面的几种 case），Referer 头不会发送，但 Origin 依旧会发送，只是值是 null 而已（注：虽然值为 null，但此请求依旧属于 Cors 请求哦），如下图所示：&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/glml9g/1624260183177-3c056e2d-4e67-4242-995e-a946a5f4692e.png" alt="">&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Origin 的值只包括&lt;strong>协议、域名和端口&lt;/strong>，而 Rerferer 不但包括协议、域名、端口还包括路径，参数，注意不包括 hash 值&lt;/p>
&lt;/li>
&lt;/ol>
&lt;h2 id="浏览器的同源策略">浏览器的同源策略&lt;/h2>
&lt;p>浏览器的职责是展示/渲染 document、css、script 脚本等，但是这些资源（将 document、css、script 统一称为资源）可能来自不同的地方，如本地、远程服务器、甚至黑客的服务器&amp;hellip;&amp;hellip;浏览器作为万维网的入口，是我们接入互联网最重要的软件之一（甚至没有之一），因此它的安全性显得尤为重要，这就出现了浏览器的同源策略。
&lt;strong>同源策略&lt;/strong>是浏览器一个重要的安全策略，它用于限制一个 origin 源的 document 或者它加载的脚本如何能与另一个 origin 源的资源进行交互。它能帮助阻隔恶意文档，&lt;strong>减少&lt;/strong>（并不是杜绝）可能被攻击的媒介。&lt;/p>
&lt;blockquote>
&lt;p>&lt;strong>❝&lt;/strong>&amp;gt; 方便和安全往往是相悖的：安全性增高了，方便性就会有所降低
❞
那么问题来了，什么才算同源？&lt;/p>
&lt;/blockquote>
&lt;h3 id="同源的定义">同源的定义&lt;/h3>
&lt;p>URL 被称作：统一资源定位符，同源是针对 URL 而言的。一个完整的 URL 各部分如下图所示：&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/glml9g/1624260182773-6d283640-a36c-47f5-891b-35544f3429f1.png" alt="">&lt;/p>
&lt;blockquote>
&lt;p>&lt;strong>❝&lt;/strong>&amp;gt; Tips：域名和 host 是等同的概念，域名+端口号 = host+端口号（大部分情况下你看到域名并没有端口号，那是采用了默认端口号 80 而已）
❞
&lt;strong>同源：只和上图的前两部分（protocol + domain）有关，规则为：全部相同则为同源&lt;/strong>。这个定义不难理解，但有几点需要再强调一下：&lt;/p>
&lt;/blockquote>
&lt;ul>
&lt;li>两部分必须&lt;strong>完全一样&lt;/strong>才算同源&lt;/li>
&lt;li>这里的 domain 包含 port 端口号，所以总共是两部分而非三部分
&lt;ul>
&lt;li>当然也有说三部分的（协议+host+port），理解其含义就成&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>下面通过举例来彻底了解下。譬如，我的源 URL 为：&lt;code>[http://www.baidu.com/api/user](http://www.baidu.com/api/user)&lt;/code>，下面表格描述了不同 URL 的各类情况：&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:left">URL&lt;/th>
&lt;th style="text-align:left">是否同源&lt;/th>
&lt;th style="text-align:left">原因说明&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:left">&lt;code>[http://www.baidu.com/account](http://www.baidu.com/account)&lt;/code>&lt;/td>
&lt;td style="text-align:left">是&lt;/td>
&lt;td style="text-align:left">前两部分相同，path 路径不一样而已&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:left">&lt;code>[http://www.baidu.com/account?name=a](http://www.baidu.com/account?name=a)&lt;/code>&lt;/td>
&lt;td style="text-align:left">是&lt;/td>
&lt;td style="text-align:left">前两部分相同，path 路径、参数不同而已&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:left">&lt;code>[https://www.baidu.com/api/user](https://www.baidu.com/api/user)&lt;/code>&lt;/td>
&lt;td style="text-align:left">否&lt;/td>
&lt;td style="text-align:left">协议不同&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:left">&lt;code>[http://www.baidu.com:8080/api/user](http://www.baidu.com:8080/api/user)&lt;/code>&lt;/td>
&lt;td style="text-align:left">否&lt;/td>
&lt;td style="text-align:left">端口不同(domain 不同)&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:left">&lt;code>[http://map.baidu.com/api/user](http://map.baidu.com/api/user)&lt;/code>&lt;/td>
&lt;td style="text-align:left">否&lt;/td>
&lt;td style="text-align:left">host 不同(domain 不同)&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="不同源的网络访问">不同源的网络访问&lt;/h3>
&lt;p>浏览器同源策略的存在，限制了不同源之间的交互，实为不便。但是浏览器也开了一些“绿灯”，让其不受同源策略的约束。此种情况一般可分为如下三类：&lt;/p>
&lt;ol>
&lt;li>跨域写操作（Cross-origin writes）：一般是被允许的。如链接（如 a 标签）、重定向以及表单提交（如 form 表单的提交）&lt;/li>
&lt;li>跨域资源嵌入（Cross-origin embedding）：一般是允许的。比如下面这些例子：
&lt;ol>
&lt;li>&lt;code>&amp;lt;script src=&amp;quot;...&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;&lt;/code>标签嵌入 js 脚本&lt;/li>
&lt;li>&lt;code>&amp;lt;link rel=&amp;quot;stylesheet&amp;quot; href=&amp;quot;...&amp;quot;&amp;gt;&lt;/code>标签嵌入 CSS&lt;/li>
&lt;li>&lt;code>&amp;lt;img&amp;gt;&lt;/code>展示的图片&lt;/li>
&lt;li>&lt;code>&amp;lt;video&amp;gt;&lt;/code>和&lt;code>&amp;lt;audio&amp;gt;&lt;/code>媒体资源&lt;/li>
&lt;li>&lt;code>&amp;lt;object&amp;gt;、 &amp;lt;embed&amp;gt; 、&amp;lt;applet&amp;gt;&lt;/code>嵌入的插件&lt;/li>
&lt;li>CSS 中使用&lt;code>@font-face&lt;/code>引入字体&lt;/li>
&lt;li>通过&lt;code>&amp;lt;iframe&amp;gt;&lt;/code>载入资源&lt;/li>
&lt;/ol>
&lt;/li>
&lt;li>跨域读操作（Cross-origin reads）：一般是&lt;strong>不被允许&lt;/strong>的。比如我们的 http 接口请求等都属于此范畴，也是本专栏关注的焦点&lt;/li>
&lt;/ol>
&lt;p>简单总结成一句话：&lt;strong>浏览器自己&lt;/strong>是可以发起跨域请求的（比如 a 标签、img 标签、form 表单等），但是 Javascript 是不能去跨域获取资源（如 ajax）。&lt;/p>
&lt;h3 id="如何允许不同源的网络访问">如何允许不同源的网络访问&lt;/h3>
&lt;p>上面说到的第三种情况：跨域读操作一般是不允许跨域访问的，而这种情况是我们开发过程中最关心、最常见的 case，因此必须解决。&lt;/p>
&lt;blockquote>
&lt;p>&lt;strong>❝&lt;/strong>&amp;gt; Tips：这里的读指的是广义上的读，指的是从服务器获取资源（有 response）的都叫读操作，而和具体是什么 Http Method 无关。换句话讲，所有的 Http API 接口请求都在这里都指的是读操作
❞
可以使用 CORS 来允许跨源访问。&lt;strong>CORS 是 HTTP 的一部分&lt;/strong>，它允许服务端来指定哪些主机可以从这个服务端加载资源。&lt;/p>
&lt;/blockquote>
&lt;h2 id="什么是-cors-跨域">什么是 Cors 跨域&lt;/h2>
&lt;p>Cors(Cross-origin resource sharing)：跨域资源共享，它是&lt;strong>浏览器&lt;/strong>的一个技术&lt;strong>规范&lt;/strong>，由 W3C 规定，规范的 wiki 地址在此：&lt;a href="https://www.w3.org/wiki/CORS_Enabled#What_is_CORS_about.3F">https://www.w3.org/wiki/CORS_Enabled#What_is_CORS_about.3F&lt;/a>&lt;/p>
&lt;blockquote>
&lt;p>&lt;strong>❝&lt;/strong>&amp;gt; 话外音：它是浏览器的一种（自我保护）行为，并且已形成规范。也就是说：backend 请求 backend 是不存在此现象的喽
❞
若想实现 Cors 机制的跨域请求，是需要浏览器和服务器同时支持的。关于浏览器对 CORS 的支持情况：现在都 2021 年了，so 可以认为 100%的浏览器都是支持的，再加上 CORS 的整个过程都由浏览器自动完成，&lt;strong>前端无需做任何设置&lt;/strong>，所以前端工程师的 ajax 原来怎么用现在还是怎么用，它对前段开发人员是完全透明的。&lt;/p>
&lt;/blockquote>
&lt;h3 id="为何需要-cors-跨域访问">为何需要 Cors 跨域访问？&lt;/h3>
&lt;p>浏览器费尽心思的搞个同源策略来保护我们的安全，但为何又需要跨域来打破这种安全策略呢？其实啊，这一切都和互联网的快速发展有关~
随着 Web 开放的程度越来越高，页面的内容也是越来越丰富。因此页面上出现的元素也就越来越多：图片、视频、各种文字内容等。为了分而治之，一个页面的内容可能来自不同地方，也就是不同的 domain 域，因此通过 API 跨域访问成了&lt;strong>必然&lt;/strong>。
浏览器作为进入 Internet 最大的入口，很长时间它是个大互联公司的必争之地，因此市面上并存的浏览器种类繁多且鱼龙混扎：IE 7、8、9、10，Chrome、Safari、火狐，每个浏览器对跨域的实现可能都不一样。因此对开发者而言亟待需要一个规范的、统一方案，它就是&lt;code>Cors&lt;/code>。
&lt;strong>CORS（Cross-Origin Resource Sharing）由 W3C 组织于 2009-03-17 编写工作草案，直到 2014-01-16 才正式毕业成为行业规范，所有浏览器得以遵守&lt;/strong>。至此，程序员同学们在解决跨域问题上，只需按照 Cors 规范实施即可。&lt;/p>
&lt;h3 id="cors-的工作原理">Cors 的工作原理&lt;/h3>
&lt;p>Web 资源涉及到两个角色：浏览器（消费者）和服务器（提供者），面向这两个角色来了解 Cors 的原理非常简单，如下图所示：&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/glml9g/1624260183135-6470a44e-03d9-49d7-af38-910b998f158c.png" alt="">&lt;/p>
&lt;ol>
&lt;li>若浏览器发送的是个跨域请求，http 请求中就会携带一个名为&lt;strong>Origin&lt;/strong>的头表明自己的“位置”，如&lt;code>Origin: http://localhost:5432&lt;/code>&lt;/li>
&lt;li>服务端接到请求后，就可以根据传过来的 Origin 头做逻辑，决定是否要将资源共享给这个源喽。而这个决定通过响应头&lt;strong>Access-Control-Allow-Origin&lt;/strong>来承载，它的 value 值可以是任意值，有如下情况：
&lt;ol>
&lt;li>值为&lt;code>*&lt;/code>，通配符，允许所有的 Origin 共享此资源&lt;/li>
&lt;li>值为 http://localhost:5432（也就是和 Origin 相同），共享给此 Origin&lt;/li>
&lt;li>值为非 http://localhost:5432（也就是和 Origin 不相同），不共享给此 Origin&lt;/li>
&lt;li>无此头：不共享给此 origin&lt;/li>
&lt;li>有此头：值有如下可能情况&lt;/li>
&lt;/ol>
&lt;/li>
&lt;li>浏览器接收到 Response 响应后，会去提取 Access-Control-Allow-Origin 这个头。然后根据上述规则来决定要接收此响应内容还是拒绝&lt;/li>
&lt;/ol>
&lt;blockquote>
&lt;p>&lt;strong>❝&lt;/strong>&amp;gt; Tips：Access-Control-Allow-Origin 响应头只能有 1 个，且 value 值就是个字符串。另外，value 值即使写为&lt;code>[http://aa.com,http://bb.com](http://aa.com,http://bb.com)&lt;/code>这种也属于一个而非两个值
❞&lt;/p>
&lt;/blockquote>
&lt;h3 id="cors-细粒度控制授权响应头">Cors 细粒度控制：授权响应头&lt;/h3>
&lt;p>在 Cors 规范中，除了可以通过&lt;strong>Access-Control-Allow-Origin&lt;/strong>响应头来对主体资源（URL 级别）进行授权外，还提供了针对于具体响应头更细粒度的控制，这个响应头就是：&lt;strong>Access-Control-Expose-Headers&lt;/strong>。换句话讲，该头用于规定哪些响应头（们）可以暴露给前端，默认情况下这 6 个响应头无需特别的显示指定就支持：&lt;/p>
&lt;ul>
&lt;li>Cache-Control&lt;/li>
&lt;li>Content-Language&lt;/li>
&lt;li>Content-Type&lt;/li>
&lt;li>Expires&lt;/li>
&lt;li>Last-Modified&lt;/li>
&lt;li>Pragma&lt;/li>
&lt;/ul>
&lt;p>若不在此值里面的头将&lt;strong>不会返回给前端&lt;/strong>（其实返回了，只是浏览器让其对前端不可见了而已，对 JavaScript 也不可见哦）。
&lt;strong>但是，但是，但是&lt;/strong>，这种细粒度控制 header 的机制对简单请求是无效的，只针对于非简单请求（也叫复杂请求）。由此可见，将哪些类型的跨域资源请求划分为简单请求的范畴就显得特备重要了。&lt;/p>
&lt;h3 id="何为简单请求">何为简单请求&lt;/h3>
&lt;p>Cors 规范定义简单请求的原则是：请求不是以更新（添加、修改和删除）资源为目的，服务端对请求的处理不会导致自身维护资源的改变。对于简单跨域资源请求来说，浏览器将两个步骤（取得授权和获取资源）合二为一，由于不涉及到资源的改变，所以不会带来任何副作用。
对于一个请求，必须&lt;strong>同时符合&lt;/strong>如下要求才被划为简单请求：&lt;/p>
&lt;ol>
&lt;li>Http Method 只能为其一：
&lt;ol>
&lt;li>GET&lt;/li>
&lt;li>POST&lt;/li>
&lt;li>HEAD&lt;/li>
&lt;/ol>
&lt;/li>
&lt;li>请求头只能在如下范围：
&lt;ol>
&lt;li>application/x-www-form-urlencoded&lt;/li>
&lt;li>multipart/form-data&lt;/li>
&lt;li>text/plain&lt;/li>
&lt;li>Accept&lt;/li>
&lt;li>Accept-Language&lt;/li>
&lt;li>Content-Language&lt;/li>
&lt;li>&lt;strong>Content-Type&lt;/strong>，其中它的值必须如下其一：&lt;/li>
&lt;/ol>
&lt;/li>
&lt;/ol>
&lt;p>除此之外的请求都为非简单请求（也可称为复杂请求）。非简单请求可能对服务端资源改变，因此 Cors 规定浏览器在发出此类请求&lt;strong>之前&lt;/strong>必须有一个“预检（Preflight）”机制，这也就是我们熟悉的&lt;code>OPTIONS&lt;/code>请求。&lt;/p>
&lt;h3 id="什么是-preflight-预检机制">什么是 Preflight 预检机制&lt;/h3>
&lt;p>顾名思义，它表示在浏览器发出&lt;strong>真正&lt;/strong>请求&lt;strong>之前&lt;/strong>，先发送一个预检请求，这个在 Http 里就是 OPTIONS 请求方式。这个请求很特殊，它不包含主体（无请求参数、请求体等），主要就是将一些凭证、授权相关的辅助信息放在请求头里交给服务器去做决策。因此它除了携带 Origin 请求头外，还会额外携带如下两个&lt;strong>请求头&lt;/strong>：&lt;/p>
&lt;ul>
&lt;li>&lt;strong>Access-Control-Request-Method&lt;/strong>：真正请求的方法&lt;/li>
&lt;li>&lt;strong>Access-Control-Request-Headers&lt;/strong>：真正请求的&lt;strong>自定义&lt;/strong>请求头（若没有自定义的就是空呗）&lt;/li>
&lt;/ul>
&lt;p>服务端在接收到此类请求后，就可以根据其值做逻辑决策啦。如果允许预检请求通过，返回个 200 即可，否则返回 400 或者 403 呗。
如果预检成功，在响应里应该包含上文提到的响应头&lt;strong>Access-Control-Allow-Origin&lt;/strong>和&lt;strong>Access-Control-Expose-Headers&lt;/strong>，除此之外，服务端还可以做更精细化的控制，这些精细化控制的响应头为：&lt;/p>
&lt;ul>
&lt;li>&lt;strong>Access-Control-Allow-Methods&lt;/strong>：允许实际请求的 Http 方法（们）&lt;/li>
&lt;li>&lt;strong>Access-Control-Allow-Headers&lt;/strong>：允许实际请求的请求头（们）&lt;/li>
&lt;li>&lt;strong>Access-Control-Max-Age&lt;/strong>：允许浏览器缓存此结果多久，单位：&lt;strong>秒&lt;/strong>。有了缓存，以后就不用每次请求都发送预检请求啦&lt;/li>
&lt;/ul>
&lt;blockquote>
&lt;p>&lt;strong>❝&lt;/strong>&amp;gt; 说明：以上响应头并不是必须的。若没有此响应头，代表接受所有
❞
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/glml9g/1624260183047-fe0cff44-2fad-43ff-9b1d-418e6cc8bbd2.webp" alt="">预检请求完成后，有个关键点，便是浏览器拿到预检请求的响应后的处理逻辑，这里描述如下：&lt;/p>
&lt;/blockquote>
&lt;ol>
&lt;li>先通过自己的 Origin 匹配预检响应中的&lt;strong>Access-Control-Allow-Origin&lt;/strong>的值，若不匹配就结束请求，若匹配就继续下一步验证
&lt;ol>
&lt;li>关于 Access-Control-Allow-Origin 的验证逻辑，请参考文上描述&lt;/li>
&lt;/ol>
&lt;/li>
&lt;li>拿到预检响应中的&lt;strong>Access-Control-Allow-Methods&lt;/strong>头。若此头不存在，则进行下一步，若存在则校验预检请求头 Access-Control-Request-Method 的值是否在此列表中，在其内继续下一步，否则失败&lt;/li>
&lt;li>拿到预检响应中的&lt;strong>Access-Control-Request-Headers&lt;/strong>头。同请求头中的&lt;strong>Access-Control-Allow-Headers&lt;/strong>值记性比较，&lt;strong>全部包含在内&lt;/strong>则匹配成功，否则失败&lt;/li>
&lt;/ol>
&lt;p>以上全部匹配成功，就代表预检成功，可以开始发送正式请求了。值得一提的事，Access-Control-Max-Age 控制预检结果的浏览器缓存，若缓存还生效的话，是不用单独再发送 OPTIONS 请求的，匹配成功直接发送目标真实即可。&lt;/p>
&lt;h4 id="access-control-max-age-使用细节">Access-Control-Max-Age 使用细节&lt;/h4>
&lt;p>Access-Control-Max-Age 用于控制浏览器缓存预检请求结果的时间，这里存在一些使用细节你需要注意：&lt;/p>
&lt;ol>
&lt;li>若浏览器禁用了缓存，也就是勾选了&lt;code>Disable cache&lt;/code>，那么此属性无效。也就说每次都还得发送 OPTIONS 请求&lt;/li>
&lt;li>判断此缓存结果的因素有两个：
&lt;ol>
&lt;li>必须是同一 URL（也就是 Origin 相同才会去找对应的缓存）&lt;/li>
&lt;li>header 变化了，也会重新去发 OPTIONS 请求（当然若去掉一些 header 编程简单请求了，就另当别论喽）&lt;/li>
&lt;/ol>
&lt;/li>
&lt;/ol>
&lt;h2 id="跨域请求代码示例">跨域请求代码示例&lt;/h2>
&lt;p>正所谓说再多，也抵不上跑几个 case，毕竟 show me your code 才是最重要。下面就针对跨域情况的简单请求、非简单请求（预检通过、预检不通过）等 case 分别用代码（基于文首代码）说明。&lt;/p>
&lt;h3 id="简单请求">简单请求&lt;/h3>
&lt;p>简单请求正如其名，是最简单的请求方式。&lt;/p>
&lt;pre>&lt;code>// 跨域请求
$.get(&amp;quot;http://localhost:8080/cors&amp;quot;, function (result) {
$(&amp;quot;#content&amp;quot;).append(result).append(&amp;quot;&amp;lt;br/&amp;gt;&amp;quot;);
});
&lt;/code>&lt;/pre>
&lt;p>服务端结果：&lt;/p>
&lt;pre>&lt;code>INFO ...CorsServlet - 收到请求：/cors，方法：GET， Origin头：http://localhost:63342
&lt;/code>&lt;/pre>
&lt;p>浏览器结果：&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/glml9g/1624260183182-8f80baa8-d029-42c4-8bce-a29833a2f28d.png" alt="">若想让请求正常，只需在服务端响应头里“加点料”就成：&lt;/p>
&lt;pre>&lt;code>...
resp.setHeader(&amp;quot;Access-Control-Allow-Origin&amp;quot;,&amp;quot;http://localhost:63342&amp;quot;);
resp.getWriter().write(&amp;quot;hello cors...&amp;quot;);
...
&lt;/code>&lt;/pre>
&lt;p>再次请求，结果成功：&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/glml9g/1624260182990-03d5ab7f-9e0f-42a9-852e-7f1d0f6d6430.png" alt="">
对于简单请求来讲，服务端只需要设置&lt;strong>Access-Control-Allow-Origin&lt;/strong>这个一个头即可，一个即可。&lt;/p>
&lt;h3 id="非简单请求">非简单请求&lt;/h3>
&lt;p>非简单请求的模拟非常简单，随便打破一个简单请求的约束即可。比如我们先在上面 get 请求的基础上自定义个请求头：&lt;/p>
&lt;pre>&lt;code>$.ajax({
type: &amp;quot;get&amp;quot;,
url: &amp;quot;http://localhost:8080/cors&amp;quot;,
headers: {secret:&amp;quot;kkjtjnbgjlfrfgv&amp;quot;,token: &amp;quot;abc123&amp;quot;}
});
&lt;/code>&lt;/pre>
&lt;p>服务端代码：&lt;/p>
&lt;pre>&lt;code>/**
* 在此处添加备注信息
*
* @author YourBatman. &amp;lt;a href=mailto:yourbatman@aliyun.com&amp;gt;Send email to me&amp;lt;/a&amp;gt;
* @site https://yourbatman.cn
* @date 2021/6/9 10:36
* @since 0.0.1
*/
@Slf4j
@WebServlet(urlPatterns = &amp;quot;/cors&amp;quot;)
public class CorsServlet extends HttpServlet {
@Override
protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
String requestURI = req.getRequestURI();
String method = req.getMethod();
String originHeader = req.getHeader(&amp;quot;Origin&amp;quot;);
log.info(&amp;quot;收到请求：{}，方法：{}， Origin头：{}&amp;quot;, requestURI, method, originHeader);
resp.setHeader(&amp;quot;Access-Control-Allow-Origin&amp;quot;,&amp;quot;http://localhost:63342&amp;quot;);
resp.setHeader(&amp;quot;Access-Control-Expose-Headers&amp;quot;,&amp;quot;token,secret&amp;quot;);
resp.setHeader(&amp;quot;Access-Control-Allow-Headers&amp;quot;,&amp;quot;token,secret&amp;quot;); // 一般来讲，让此头的值是上面那个的【子集】（或相同）
resp.getWriter().write(&amp;quot;hello cors...&amp;quot;);
}
}
&lt;/code>&lt;/pre>
&lt;p>点击按钮，浏览器发送请求，结果为：&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/glml9g/1624260183014-9b0617b6-5b7b-4c38-b7e1-c7fe01a03cdd.png" alt="">根本原因为：OPTIONS 的响应头里并未含有任何跨域相关信息，虽然预检通过（注意：这个预检是通过的哟，预检不通过的场景就不用额外演示了吧~），但预检的结果经浏览器判断此跨域实际请求不能发出，所以给拦下来了。
从代码层面问题就出现在&lt;code>resp.setHeader(xxx,xxx)&lt;/code>放在了处理实际方法的 Get 方法上，显然不对嘛，应该放在&lt;code>doOptions()&lt;/code>方法里才行：&lt;/p>
&lt;pre>&lt;code>@Override
protected void doOptions(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
super.doOptions(req, resp);
resp.setHeader(&amp;quot;Access-Control-Allow-Origin&amp;quot;,&amp;quot;http://localhost:63342&amp;quot;);
resp.setHeader(&amp;quot;Access-Control-Expose-Headers&amp;quot;,&amp;quot;token,secret&amp;quot;);
resp.setHeader(&amp;quot;Access-Control-Allow-Headers&amp;quot;,&amp;quot;token,secret&amp;quot;); // 一般来讲，让此头的值是上面那个的【子集】（或相同）
}
&lt;/code>&lt;/pre>
&lt;p>在此运行，一切正常：&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/glml9g/1624260182853-033ea229-1f94-47fe-abf1-be70ab519582.webp" alt="">值得特别注意的是：设置跨域的响应头这块代码，在处理真实请求的 doGet 里也必须得有，否则服务端处理了，浏览器“不认”也是会出跨域错误的。
另外就是，Access-Control-Allow-Headers/Access-Control-Expose-Headers 这两个头里必须包含你的请求的自定义的 Header（标准的 header 不需要包含），否则依旧跨域失败哦~
在实际生产场景中，Http 请求的 Content-type 大都是&lt;code>application/json&lt;/code>并非简单请求的头，所以有个现实情况是：&lt;strong>实际的跨域请求中，几乎 100%的情况下我们发的都是非简单请求&lt;/strong>。&lt;/p>
&lt;h2 id="cros-跨域使用展望">Cros 跨域使用展望&lt;/h2>
&lt;p>如上代码示例，处理简单请求尚且简单，但对于非简单请求来说，我们在 doOptions 和 doGet 都写了一段 setHeader 的代码，是否觉得麻烦呢？
另外，对于&lt;strong>Access-Control-Allow-Origin&lt;/strong>若我需要允许多个源怎么办呢？&lt;/p>
&lt;blockquote>
&lt;p>&lt;strong>❝&lt;/strong>&amp;gt; Tips：Access-Control-Allow-Origin 头只允许一个，且 Access-Control-Allow-Origin:a.com,b.com 依旧算作一个源的，它没有逗号分隔的“特性”。从命名的艺术你也可看出，它并非是 xxx-Origins 而是 xxx-Origin
❞
既然实际场景中几乎 100%都是非简单请求，那么对于控制非简单请求的&lt;strong>Access-Control-Allow-Methods&lt;/strong>、&lt;strong>Access-Control-Allow-Headers&lt;/strong>、&lt;strong>Access-Control-Max-Age&lt;/strong>这些都都改如何赋值？是否有最佳实践？
现在我们大都在 Spring Framework/Spring Boot 场景下开发应用，框架层面是否提供一些优雅的解决方案？
作为一名后端开发工程师（编程语言不限），也许你从未处理过跨域问题，那么到底是谁默默的帮你解决了这一切呢？是否想知其所以然？
如果这些问题也是你在使用过程中的疑问，或者希望了解的知识点，那么请关注专栏吧。&lt;/p>
&lt;/blockquote>
&lt;h1 id="总结">总结&lt;/h1>
&lt;p>本文用很长的篇幅介绍了 Cors 跨域资源共享的相关知识，并且用代码做了示范，希望能助你通关 Cors 这个狗皮膏药一样粘着我们的硬核知识点。本文文字叙述较多，介绍了同源、跨域、Cors 的几乎所有概念，虽然略显难啃，但这些是指导我们实践的说明书。
革命尚未统一，带着 👆🏻 给到的问题，一起开启通过 Cors 跨域之旅吧~&lt;/p>
&lt;h2 id="本文思考题">本文思考题&lt;/h2>
&lt;p>本文已被&lt;code>[https://yourbatman.cn](https://yourbatman.cn)&lt;/code>收录。所属专栏：&lt;strong>点拨-Cors 跨域&lt;/strong>，后台回复“专栏列表”即可查看详情。
&lt;strong>看完了不一定懂，看懂了不一定会&lt;/strong>。来，3 个思考题帮你复盘：&lt;/p>
&lt;ol>
&lt;li>试想一下，如果浏览器没有同源策略，将有多大的风险？&lt;/li>
&lt;li>Cors 共涉及到哪些请求头？哪些响应头？&lt;/li>
&lt;li>你所知道的解决 Cors 跨域问题最佳实践是什么？&lt;/li>
&lt;/ol>
&lt;h2 id="推荐阅读">推荐阅读&lt;/h2>
&lt;ul>
&lt;li>&lt;a href="https://mp.weixin.qq.com/s?__biz=MzI0MTUwOTgyOQ==&amp;amp;mid=2247493900&amp;amp;idx=1&amp;amp;sn=f903380f7d7065192959b07acd1683ae&amp;amp;scene=21#wechat_redirect">10. 原来是这么玩的，@DateTimeFormat 和@NumberFormat&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://mp.weixin.qq.com/s?__biz=MzI0MTUwOTgyOQ==&amp;amp;mid=2247491641&amp;amp;idx=1&amp;amp;sn=794c1fadf5d5144df83079a549d3b15f&amp;amp;scene=21#wechat_redirect">9. 细节见真章，Formatter 注册中心的设计很讨巧&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://mp.weixin.qq.com/s?__biz=MzI0MTUwOTgyOQ==&amp;amp;mid=2247491457&amp;amp;idx=1&amp;amp;sn=dc16a2b7f069df4b0329e66365efd980&amp;amp;scene=21#wechat_redirect">8. 格式化器大一统 &amp;ndash; Spring 的 Formatter 抽象&lt;/a>&lt;/li>
&lt;/ul></description></item><item><title>Docs: HTTP 优化</title><link>https://desistdaydream.github.io/docs/4.%E6%95%B0%E6%8D%AE%E9%80%9A%E4%BF%A1/%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/7.HTTP/HTTP-%E7%AE%A1%E7%90%86/HTTP-%E4%BC%98%E5%8C%96/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/4.%E6%95%B0%E6%8D%AE%E9%80%9A%E4%BF%A1/%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/7.HTTP/HTTP-%E7%AE%A1%E7%90%86/HTTP-%E4%BC%98%E5%8C%96/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;p>参考：&lt;a href="https://mp.weixin.qq.com/s/1Vb87OGa05a7zkbRrLsLGg">原文链接&lt;/a>&lt;/p>
&lt;p>问你一句：「*&lt;strong>* 你知道 HTTP/1.1 该如何优化吗？**&lt;/strong>」&lt;/p>
&lt;p>我想你第一时间想到的是，使用 KeepAlive 将 HTTP/1.1 从短连接改成长链接。&lt;/p>
&lt;p>这个确实是一个优化的手段，它是从底层的传输层这一方向入手的，通过减少 TCP 连接建立和断开的次数，来减少了网络传输的延迟，从而提高 HTTP/1.1 协议的传输效率。&lt;/p>
&lt;p>但其实还可以从其他方向来优化 HTTP/1.1 协议，比如有如下 3 种优化思路：&lt;/p>
&lt;ul>
&lt;li>&lt;em>尽量避免发送 HTTP 请求&lt;/em>；&lt;/li>
&lt;li>&lt;em>在需要发送 HTTP 请求时，考虑如何减少请求次数&lt;/em>；&lt;/li>
&lt;li>&lt;em>减少服务器的 HTTP 响应的数据大小&lt;/em>；&lt;/li>
&lt;/ul>
&lt;p>下面，就针对这三种思路具体看看有哪些优化方法。&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/wdgp8s/1649668055309-f75050df-d892-4df4-a1b8-485a3d983297.png" alt="">&lt;/p>
&lt;hr>
&lt;h3 id="1-如何避免发送-http-请求">1 如何避免发送 HTTP 请求？&lt;/h3>
&lt;p>这个思路你看到是不是觉得很奇怪，不发送 HTTP 请求，那还客户端还怎么和服务器交互数据？小林你这不是耍流氓嘛？&lt;/p>
&lt;p>冷静冷静，你说的没错，客户端当然要向服务器发送请求的。&lt;/p>
&lt;p>但是，对于一些具有重复性的 HTTP 请求，比如每次请求得到的数据都一样的，我们可以把这对「请求 - 响应」的数据都&lt;strong>缓存在本地&lt;/strong>，那么下次就直接读取本地的数据，不必在通过网络获取服务器的响应了，这样的话 HTTP/1.1 的性能肯定肉眼可见的提升。&lt;/p>
&lt;p>所以，避免发送 HTTP 请求的方法就是通过&lt;strong>缓存技术&lt;/strong>，HTTP 设计者早在之前就考虑到了这点，因此 HTTP 协议的头部有不少是针对缓存的字段。&lt;/p>
&lt;p>那缓存是如何做到的呢？&lt;/p>
&lt;p>客户端会把第一次请求以及响应的数据保存在本地磁盘上，其中将请求的 URL 作为 key，而响应作为 value，两者形成映射关系。&lt;/p>
&lt;p>这样当后续发起相同的请求时，就可以先在本地磁盘上通过 key 查到对应的 value，也就是响应，如果找到了，就直接从本地读取该响应。毋庸置疑，读取本次磁盘的速度肯定比网络请求快得多，如下图：&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/wdgp8s/1649668055405-5c6b569c-02bd-4e0a-b5e0-4fac6ceccdf9.png" alt="">&lt;/p>
&lt;p>聪明的你可能想到了，万一缓存的响应不是最新的，而客户端并不知情，那么该怎么办呢？&lt;/p>
&lt;p>放心，这个问题 HTTP 设计者早已考虑到。&lt;/p>
&lt;p>所以，服务器在发送 HTTP 响应时，会估算一个过期的时间，并把这个信息放到响应头部中，这样客户端在查看响应头部的信息时，一旦发现缓存的响应是过期的，则就会重新发送网络请求。HTTP 关于缓说明会的头部字段很多，这部分内容留在下次文章，这次暂时不具体说明。&lt;/p>
&lt;p>如果客户端从第一次请求得到的响应头部中发现该响应过期了，客户端重新发送请求，假设服务器上的资源并没有变更，还是老样子，那么你觉得还要在服务器的响应带上这个资源吗？&lt;/p>
&lt;p>很显然不带的话，可以提高 HTTP 协议的性能，那具体如何做到呢？&lt;/p>
&lt;p>只需要客户端在重新发送请求时，在请求的  &lt;code>Etag&lt;/code>  头部带上第一次请求的响应头部中的摘要，这个摘要是唯一标识响应的资源，当服务器收到请求后，会将本地资源的摘要与请求中的摘要做个比较。&lt;/p>
&lt;p>如果不同，那么说明客户端的缓存已经没有价值，服务器在响应中带上最新的资源。&lt;/p>
&lt;p>如果相同，说明客户端的缓存还是可以继续使用的，那么服务器&lt;strong>仅返回不含有包体的  &lt;strong>&lt;code>**304 Not Modified**&lt;/code>&lt;/strong>  响应&lt;/strong>，告诉客户端仍然有效，这样就可以减少响应资源在网络中传输的延时，如下图：&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/wdgp8s/1649668055482-075cc0a2-91a4-4ec0-9e71-91bcce17381b.png" alt="">&lt;/p>
&lt;p>缓存真的是性能优化的一把万能钥匙，小到 CPU Cache、Page Cache、Redis Cache，大到 HTTP 协议的缓存。&lt;/p>
&lt;hr>
&lt;h3 id="2-如何减少-http-请求次数">2 如何减少 HTTP 请求次数？&lt;/h3>
&lt;p>减少 HTTP 请求次数自然也就提升了 HTTP 性能，可以从这 3 个方面入手：&lt;/p>
&lt;ul>
&lt;li>&lt;em>减少重定向请求次数&lt;/em>；&lt;/li>
&lt;li>&lt;em>合并请求&lt;/em>；&lt;/li>
&lt;li>&lt;em>延迟发送请求&lt;/em>；&lt;/li>
&lt;/ul>
&lt;h4 id="21-减少重定向请求次数">2.1 减少重定向请求次数&lt;/h4>
&lt;p>我们先来看看什么是&lt;strong>重定向请求&lt;/strong>？&lt;/p>
&lt;p>服务器上的一个资源可能由于迁移、维护等原因从 url1 移至 url2 后，而客户端不知情，它还是继续请求 url1，这时服务器不能粗暴地返回错误，而是通过  &lt;code>302&lt;/code>  响应码和  &lt;code>Location&lt;/code>  头部，告诉客户端该资源已经迁移至 url2 了，于是客户端需要再发送 url2 请求以获得服务器的资源。&lt;/p>
&lt;p>那么，如果重定向请求越多，那么客户端就要多次发起 HTTP 请求，每一次的 HTTP 请求都得经过网络，这无疑会越降低网络性能。&lt;/p>
&lt;p>另外，服务端这一方往往不只有一台服务器，比如源服务器上一级是代理服务器，然后代理服务器才与客户端通信，这时客户端重定向就会导致客户端与代理服务器之间需要 2 次消息传递，如下图：&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/wdgp8s/1649668055379-b9c5c223-4625-4ce4-8af9-3a85613d2fd3.png" alt="">&lt;/p>
&lt;p>如果&lt;strong>重定向的工作交由代理服务器完成，就能减少 HTTP 请求次数了&lt;/strong>，如下图：&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/wdgp8s/1649668055355-3afcffb9-c9b0-4263-81a4-b7b472828862.png" alt="">&lt;/p>
&lt;p>而且当代理服务器知晓了重定向规则后，可以进一步减少消息传递次数，如下图：&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/wdgp8s/1649668056072-7ae663e5-5fcc-44ba-bd4a-e713d9bcd9d8.png" alt="">&lt;/p>
&lt;p>除了  &lt;code>302&lt;/code>  重定向响应码，还有其他一些重定向的响应码，你可以从下图看到：&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/wdgp8s/1649668056138-0b18be21-b2c0-4cc7-90df-5613477c941e.png" alt="">&lt;/p>
&lt;p>其中，&lt;code>301&lt;/code>  和  &lt;code>308&lt;/code>  响应码是告诉客户端可以将重定向响应缓存到本地磁盘，之后客户端就自动用 url2 替代 url1 访问服务器的资源。&lt;/p>
&lt;h4 id="22-合并请求">2.2 合并请求&lt;/h4>
&lt;p>如果把多个访问小文件的请求合并成一个大的请求，虽然传输的总资源还是一样，但是减少请求，也就意味着&lt;strong>减少了重复发送的 HTTP 头部&lt;/strong>。&lt;/p>
&lt;p>另外由于 HTTP/1.1 是请求响应模型，如果第一个发送的请求，未收到对应的响应，那么后续的请求就不会发送，于是为了防止单个请求的阻塞，所以一般浏览器会同时发起 5-6 个请求，每一个请求都是不同的 TCP 连接，那么如果合并了请求，也就会&lt;strong>减少 TCP 连接的数量，因而省去了 TCP 握手和慢启动过程耗费的时间&lt;/strong>。&lt;/p>
&lt;p>接下来，具体看看合并请求的几种方式。&lt;/p>
&lt;p>有的网页会含有很多小图片、小图标，有多少个小图片，客户端就要发起多少次请求。那么对于这些小图片，我们可以考虑使用  &lt;code>CSS Image Sprites&lt;/code>  技术把它们合成一个大图片，这样浏览器就可以用一次请求获得一个大图片，然后再根据 CSS 数据把大图片切割成多张小图片。&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/wdgp8s/1649668056210-aaa25f9e-eccf-45d3-a4ae-65a5a28597ec.png" alt="">&lt;/p>
&lt;p>图来源于：墨染枫林的 CSDN&lt;/p>
&lt;p>这种方式就是&lt;strong>通过将多个小图片合并成一个大图片来减少 HTTP 请求的次数，以减少 HTTP 请求的次数，从而减少网络的开销&lt;/strong>。&lt;/p>
&lt;p>除了将小图片合并成大图片的方式，还有服务端使用  &lt;code>webpack&lt;/code>  等打包工具将 js、css 等资源合并打包成大文件，也是能达到类似的效果。&lt;/p>
&lt;p>另外，还可以将图片的二进制数据用  &lt;code>base64&lt;/code>  编码后，以 URL 的形式潜入到 HTML 文件，跟随 HTML 文件一并发送.&lt;/p>
&lt;pre>&lt;code>&amp;lt;image src=&amp;quot;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAPoAAAFKCAIAAAC7M9WrAAAACXBIWXMAA ... /&amp;gt;
&lt;/code>&lt;/pre>
&lt;p>这样客户端收到 HTML 后，就可以直接解码出数据，然后直接显示图片，就不用再发起图片相关的请求，这样便减少了请求的次数。&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/wdgp8s/1649668056402-ae46bb78-755b-4a92-9da3-4c1738895cdc.png" alt="">&lt;/p>
&lt;p>图来源于：陈健平的 CSDN&lt;/p>
&lt;p>可以看到，&lt;strong>合并请求的方式就是合并资源，以一个大资源的请求替换多个小资源的请求&lt;/strong>。&lt;/p>
&lt;p>但是这样的合并请求会带来新的问题，&lt;strong>当大资源中的某一个小资源发生变化后，客户端必须重新下载整个完整的大资源文件&lt;/strong>，这显然带来了额外的网络消耗。&lt;/p>
&lt;h4 id="23-延迟发送请求">2.3 延迟发送请求&lt;/h4>
&lt;p>不要一口气吃成大胖子，一般 HTML 里会含有很多 HTTP 的 URL，当前不需要的资源，我们没必要也获取过来，于是可以通过「&lt;strong>按需获取&lt;/strong>」的方式，来减少第一时间的 HTTP 请求次数。&lt;/p>
&lt;p>请求网页的时候，没必要把全部资源都获取到，而是只获取当前用户所看到的页面资源，当用户向下滑动页面的时候，再向服务器获取接下来的资源，这样就达到了延迟发送请求的效果。&lt;/p>
&lt;hr>
&lt;h3 id="3-如何减少-http-响应的数据大小">3 如何减少 HTTP 响应的数据大小？&lt;/h3>
&lt;p>对于 HTTP 的请求和响应，通常 HTTP 的响应的数据大小会比较大，也就是服务器返回的资源会比较大。&lt;/p>
&lt;p>于是，我们可以考虑对响应的资源进行&lt;strong>压缩&lt;/strong>，这样就可以减少响应的数据大小，从而提高网络传输的效率。&lt;/p>
&lt;p>压缩的方式一般分为 2 种，分别是：&lt;/p>
&lt;ul>
&lt;li>&lt;em>无损压缩&lt;/em>；&lt;/li>
&lt;li>&lt;em>有损压缩&lt;/em>；&lt;/li>
&lt;/ul>
&lt;h4 id="31-无损压缩">3.1 无损压缩&lt;/h4>
&lt;p>无损压缩是指资源经过压缩后，信息不被破坏，还能完全恢复到压缩前的原样，适合用在文本文件、程序可执行文件、程序源代码。&lt;/p>
&lt;p>首先，我们针对代码的语法规则进行压缩，因为通常代码文件都有很多换行符或者空格，这些是为了帮助程序员更好的阅读，但是机器执行时并不要这些符，把这些多余的符号给去除掉。&lt;/p>
&lt;p>接下来，就是无损压缩了，需要对原始资源建立统计模型，利用这个统计模型，将常出现的数据用较短的二进制比特序列表示，将不常出现的数据用较长的二进制比特序列表示，生成二进制比特序列一般是「霍夫曼编码」算法。&lt;/p>
&lt;p>gzip 就是比较常见的无损压缩。客户端支持的压缩算法，会在 HTTP 请求中通过头部中的  &lt;code>Accept-Encoding&lt;/code>  字段告诉服务器：&lt;/p>
&lt;pre>&lt;code>Accept-Encoding: gzip, deflate, br
&lt;/code>&lt;/pre>
&lt;p>服务器收到后，会从中选择一个服务器支持的或者合适的压缩算法，然后使用此压缩算法对响应资源进行压缩，最后通过响应头部中的  &lt;code>content-encoding&lt;/code>  字段告诉客户端该资源使用的压缩算法。&lt;/p>
&lt;pre>&lt;code>content-encoding: gzip
&lt;/code>&lt;/pre>
&lt;p>gzip 的压缩效率相比 Google 推出的 Brotli 算法还是差点意思，也就是上文中的 br，所以如果可以，服务器应该选择压缩效率更高的 br 压缩算法。&lt;/p>
&lt;h4 id="32-有损压缩">3.2 有损压缩&lt;/h4>
&lt;p>与无损压缩相对的就是有损压缩，经过此方法压缩，解压的数据会与原始数据不同但是非常接近。&lt;/p>
&lt;p>有损压缩主要将次要的数据舍弃，牺牲一些质量来减少数据量、提高压缩比，这种方法经常用于压缩多媒体数据，比如音频、视频、图片。&lt;/p>
&lt;p>可以通过 HTTP 请求头部中的  &lt;code>Accept&lt;/code>  字段里的「 q 质量因子」，告诉服务器期望的资源质量。&lt;/p>
&lt;pre>&lt;code>Accept: audio/*; q=0.2, audio/basic
&lt;/code>&lt;/pre>
&lt;p>关于图片的压缩，目前压缩比较高的是 Google 推出的  &lt;strong>WebP 格式&lt;/strong>，它与常见的 Png 格式图片的压缩比例对比如下图：&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/wdgp8s/1649668056461-8cf206e8-fa3d-4df9-be2e-57709cb9cb6f.png" alt="">&lt;/p>
&lt;p>来源于：&lt;a href="https://isparta.github.io/compare-webp/index.html">https://isparta.github.io/compare-webp/index.html&lt;/a>&lt;/p>
&lt;p>可以发现，相同图片质量下，WebP 格式的图片大小都比 Png 格式的图片小，所以对于大量图片的网站，可以考虑使用 WebP 格式的图片，这将大幅度提升网络传输的性能。&lt;/p>
&lt;p>关于音视频的压缩，音视频主要是动态的，每个帧都有时序的关系，通常时间连续的帧之间的变化是很小的。&lt;/p>
&lt;p>比如，一个在看书的视频，画面通常只有人物的手和书桌上的书是会有变化的，而其他地方通常都是静态的，于是只需要在一个静态的关键帧，使用&lt;strong>增量数据&lt;/strong>来表达后续的帧，这样便减少了很多数据，提高了网络传输的性能。对于视频常见的编码格式有 H264、H265 等，音频常见的编码格式有 AAC、AC3。&lt;/p>
&lt;hr>
&lt;h3 id="总结">总结&lt;/h3>
&lt;p>这次主要从 3 个方面介绍了优化 HTTP/1.1 协议的思路。&lt;/p>
&lt;p>第一个思路是，通过缓存技术来避免发送 HTTP 请求。客户端收到第一个请求的响应后，可以将其缓存在本地磁盘，下次请求的时候，如果缓存没过期，就直接读取本地缓存的响应数据。如果缓存过期，客户端发送请求的时候带上响应数据的摘要，服务器比对后发现资源没有变化，就发出不带包体的 304 响应，告诉客户端缓存的响应仍然有效。&lt;/p>
&lt;p>第二个思路是，减少 HTTP 请求的次数，有以下的方法：&lt;/p>
&lt;ol>
&lt;li>将原本由客户端处理的重定向请求，交给代理服务器处理，这样可以减少重定向请求的次数；&lt;/li>
&lt;li>将多个小资源合并成一个大资源再传输，能够减少 HTTP 请求次数以及 头部的重复传输，再来减少 TCP 连接数量，进而省去 TCP 握手和慢启动的网络消耗；&lt;/li>
&lt;li>按需访问资源，只访问当前用户看得到 / 用得到的资源，当客户往下滑动，再访问接下来的资源，以此达到延迟请求，也就减少了同一时间的 HTTP 请求次数。&lt;/li>
&lt;/ol>
&lt;p>第三思路是，通过压缩响应资源，降低传输资源的大小，从而提高传输效率，所以应当选择更优秀的压缩算法。&lt;/p>
&lt;p>不管怎么优化 HTTP/1.1 协议都是有限的，不然也不会出现 HTTP/2 和 HTTP/3 协议，后续我们再来介绍 HTTP/2 和 HTTP/3 协议。&lt;/p>
&lt;p>好了，此次分享到这就结束了，如果这篇文章对你有帮助，欢迎来个三连，&lt;strong>你们的支持就是小林的最大动力&lt;/strong>，我们下次见！&lt;/p>
&lt;hr>
&lt;h6 id="巨人的肩膀">巨人的肩膀&lt;/h6>
&lt;ol>
&lt;li>&lt;a href="https://isparta.github.io/compare-webp/index.html">https://isparta.github.io/compare-webp/index.html&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://zh.wikipedia.org/wiki/https://en.wikipedia.org/wiki/Lossy_compression">https://zh.wikipedia.org/wiki/https://en.wikipedia.org/wiki/Lossy_compression&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Lossless_compression">https://en.wikipedia.org/wiki/Lossless_compression&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://time.geekbang.org/column/article/242667">https://time.geekbang.org/column/article/242667&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.tutorialrepublic.com/css-tutorial/css-sprites.php">https://www.tutorialrepublic.com/css-tutorial/css-sprites.php&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://blog.csdn.net/weixin_38055381/article/details/81504716">https://blog.csdn.net/weixin_38055381/article/details/81504716&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://blog.csdn.net/weixin_44151887/article/details/106278559">https://blog.csdn.net/weixin_44151887/article/details/106278559&lt;/a>&lt;/li>
&lt;/ol>
&lt;h6 id="推荐阅读">推荐阅读&lt;/h6>
&lt;h6 id="优化-https-的手段你知道几个httpmpweixinqqcoms__bizmzuxodazndg4nqmid2247488081idx1sna285752b4b1516830ba1f549323d3580chksmf98e56fbcef9dfedcfe006a920722a52bd865f0c1211ba8449cc55b32a7de2df1ddd88a25fb7scene21wechat_redirect">&lt;a href="http://mp.weixin.qq.com/s?__biz=MzUxODAzNDg4NQ==&amp;amp;mid=2247488081&amp;amp;idx=1&amp;amp;sn=a285752b4b1516830ba1f549323d3580&amp;amp;chksm=f98e56fbcef9dfedcfe006a920722a52bd865f0c1211ba8449cc55b32a7de2df1ddd88a25fb7&amp;amp;scene=21#wechat_redirect">优化 HTTPS 的手段，你知道几个？&lt;/a>&lt;/h6>
&lt;h6 id="硬核30-张图解-http-常见的面试题httpmpweixinqqcoms__bizmzuxodazndg4nqmid2247483971idx1sn8f2d5dae3d95efc446061b352c8e9961chksmf98e46e9cef9cfff1f6bee1974b8dc27dcc42f0627dcf8ff0c0df8dbaa7a1f74587e3fafc167scene21wechat_redirect">&lt;a href="http://mp.weixin.qq.com/s?__biz=MzUxODAzNDg4NQ==&amp;amp;mid=2247483971&amp;amp;idx=1&amp;amp;sn=8f2d5dae3d95efc446061b352c8e9961&amp;amp;chksm=f98e46e9cef9cfff1f6bee1974b8dc27dcc42f0627dcf8ff0c0df8dbaa7a1f74587e3fafc167&amp;amp;scene=21#wechat_redirect">硬核！30 张图解 HTTP 常见的面试题&lt;/a>&lt;/h6>
&lt;hr>
&lt;p>&lt;a href="https://mp.weixin.qq.com/s/1Vb87OGa05a7zkbRrLsLGg">https://mp.weixin.qq.com/s/1Vb87OGa05a7zkbRrLsLGg&lt;/a>&lt;/p></description></item><item><title>Docs: 跨域</title><link>https://desistdaydream.github.io/docs/4.%E6%95%B0%E6%8D%AE%E9%80%9A%E4%BF%A1/%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/7.HTTP/HTTP-%E7%AE%A1%E7%90%86/%E8%B7%A8%E5%9F%9F/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/4.%E6%95%B0%E6%8D%AE%E9%80%9A%E4%BF%A1/%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/7.HTTP/HTTP-%E7%AE%A1%E7%90%86/%E8%B7%A8%E5%9F%9F/</guid><description>
&lt;h1 id="什么是跨域怎么解决跨域问题">什么是跨域？怎么解决跨域问题？&lt;/h1>
&lt;p>原文链接：&lt;a href="https://www.huaweicloud.com/articles/aac70d91034fc29ba92cde78f0b867f8.html">https://www.huaweicloud.com/articles/aac70d91034fc29ba92cde78f0b867f8.html&lt;/a>&lt;/p>
&lt;h2 id="什么是跨域">&lt;strong>什么是跨域？&lt;/strong>&lt;/h2>
&lt;p>跨域，指的是浏览器不能执行其他网站的脚本。它是由浏览器的同源策略造成的，是浏览器对&lt;a href="">JavaScript&lt;/a>施加的安全限制。
&lt;strong>所谓同源是指，域名，协议，端口均相同，不明白没关系，举个栗子：&lt;/strong>
&lt;strong>&lt;a href="http://www.123.com/index.html">http://www.123.com/index.html&lt;/a> 调用 &lt;a href="http://www.123.com/server.">http://www.123.com/server.&lt;/a>&lt;a href="">PHP&lt;/a> （非跨域）&lt;/strong>
&lt;strong>&lt;a href="http://www.123.com/index.html">http://www.123.com/index.html&lt;/a> 调用 &lt;a href="http://www.456.com/server.">http://www.456.com/server.&lt;/a>&lt;a href="">php&lt;/a> （主域名不同:123/456，跨域）&lt;/strong>
&lt;strong>&lt;a href="http://abc.123.com/index.html">http://abc.123.com/index.html&lt;/a> 调用 &lt;a href="http://def.123.com/server.php">http://def.123.com/server.php&lt;/a> （子域名不同:abc/def，跨域）&lt;/strong>
&lt;strong>&lt;a href="http://www.123.com:8080/index.html">http://www.123.com:8080/index.html&lt;/a> 调用 &lt;a href="http://www.123.com:8081/server.php">http://www.123.com:8081/server.php&lt;/a> （端口不同:8080/8081，跨域）&lt;/strong>
&lt;strong>&lt;a href="http://www.123.com/index.html">http://www.123.com/index.html&lt;/a> 调用 &lt;a href="https://www.123.com/server.php">https://www.123.com/server.php&lt;/a> （协议不同:http/https，跨域）&lt;/strong>
&lt;strong>请注意：localhost 和 127.0.0.1 虽然都指向本机，但也属于跨域。&lt;/strong>
浏览器执行&lt;a href="">javascript&lt;/a>脚本时，会检查这个脚本属于哪个页面，如果不是同源页面，就不会被执行。
&lt;strong>解决办法：&lt;/strong>
&lt;strong>1、JSONP：&lt;/strong>
使用方式就不赘述了，但是要注意 JSONP 只支持 GET 请求，不支持 POST 请求。&lt;/p>
&lt;h2 id="jsonp-原理">JSONP 原理&lt;/h2>
&lt;p>ajax 请求受同源策略影响，不允许进行跨域请求，而 script 标签 src 属性中的链接却可以访问跨域的 js 脚本，利用这个特性，服务端不再返回 JSON 格式的数据，而是返回一段调用某个函数的 js 代码，在 src 中进行了调用，这样实现了跨域。
jsonp 其实是一种特定的格式，一般是   fun(json 格式参数)，
服务端：&lt;/p>
&lt;pre>&lt;code>header('Content-type: application/json');
//获取回调函数名
$jsoncallback = htmlspecialchars($_REQUEST ['jsoncallback']);
//json数据
$json_data = '[&amp;quot;customername1&amp;quot;,&amp;quot;customername2&amp;quot;]';
//输出jsonp格式的数据
echo $jsoncallback . &amp;quot;(&amp;quot; . $json_data . &amp;quot;)&amp;quot;;
客户端：
function callbackFunction(result, methodName)
{
console.log(result[0]);
};
&amp;lt;script&amp;gt;&amp;lt;/script&amp;gt;
&lt;/code>&lt;/pre>
&lt;p>其实就是返回一个 js 文件，里面执行了 callbackFunction 方法；因为引用 js 文件不存在跨域的问题，这样问题就解决啦~~~
&lt;strong>2、代理：&lt;/strong>
例如www.123.com/index.html需要调用www.456.com/server.php，可以写一个接口www.123.com/server.php，由这个接口在后端去调用www.456.com/server.php并拿到返回值，然后再返回给index.html，这就是一个代理的模式。相当于绕过了浏览器端，自然就不存在跨域问题。
&lt;strong>3、PHP 端修改 header（XHR2 方式）&lt;/strong>
在 php 接口脚本中加入以下两句即可：
header(&amp;lsquo;Access-Control-Allow-Origin:*&amp;rsquo;);//允许所有来源访问
header(&amp;lsquo;Access-Control-Allow-Method:POST,GET&amp;rsquo;);//允许访问的方式
转载于:https://www.cnblogs.com/wmm123/p/11498899.html&lt;/p>
&lt;h1 id="不要再问我跨域的问题了">不要再问我跨域的问题了&lt;/h1>
&lt;p>参考：&lt;a href="https://segmentfault.com/a/1190000015597029">原文链接&lt;/a>
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/qud8hv/1616980608618-d2bc8a97-8f95-46e7-adef-f5e1f731f81c.gif" alt="">
写下这篇文章后我想，要不以后就把这种基础的常见知识都归到这个“不要再问我 XX 的问题”，形成一系列内容，希望大家看完之后再有人问你这些问题，你心里会窃喜：“嘿嘿，是时候展现真正的技术了！”一、&amp;gt; &lt;a href="https://segmentfault.com/a/1190000015438195">不要再问我 this 的指向问题了&lt;/a>
跨域这两个字就像一块狗皮膏药一样黏在每一个前端开发者身上，无论你在工作上或者面试中无可避免会遇到这个问题。为了应付面试，我每次都随便背几个方案，也不知道为什么要这样干，反正面完就可以扔了，我想工作上也不会用到那么多乱七八糟的方案。到了真正工作，开发环境有 webpack-dev-server 搞定，上线了服务端的大佬们也会配好，配了什么我不管，反正不会跨域就是了。日子也就这么混过去了，终于有一天，我觉得不能再继续这样混下去了，我一定要彻底搞懂这个东西！于是就有了这篇文章。&lt;/p>
&lt;h2 id="要掌握跨域首先要知道为什么会有跨域这个问题出现">要掌握跨域，首先要知道为什么会有跨域这个问题出现&lt;/h2>
&lt;p>确实，我们这种搬砖工人就是为了混口饭吃嘛，好好的调个接口告诉我跨域了，这种阻碍我们轻松搬砖的事情真恶心！为什么会跨域？是谁在搞事情？为了找到这个问题的始作俑者，请点击&lt;a href="https://developer.mozilla.org/zh-CN/docs/Web/Security/Same-origin_policy">浏览器的同源策略&lt;/a>。
这么官方的东西真难懂，没关系，至少你知道了，因为浏览器的同源策略导致了跨域，就是浏览器在搞事情。
所以，浏览器为什么要搞事情？就是不想给好日子我们过？对于这样的质问，浏览器甩锅道：“同源策略限制了从同一个源加载的文档或脚本如何与来自另一个源的资源进行交互。这是一个用于隔离潜在恶意文件的重要安全机制。”
这么官方的话术真难懂，没关系，至少你知道了，似乎这是个安全机制。
所以，究竟为什么需要这样的安全机制？这样的安全机制解决了什么问题？别急，让我们继续研究下去。&lt;/p>
&lt;h2 id="没有同源策略限制的两大危险场景">没有同源策略限制的两大危险场景&lt;/h2>
&lt;p>据我了解，浏览器是从两个方面去做这个同源策略的，一是针对接口的请求，二是针对 Dom 的查询。试想一下没有这样的限制上述两种动作有什么危险。&lt;/p>
&lt;h3 id="没有同源策略限制的接口请求">没有同源策略限制的接口请求&lt;/h3>
&lt;p>有一个小小的东西叫 cookie 大家应该知道，一般用来处理登录等场景，目的是让服务端知道谁发出的这次请求。如果你请求了接口进行登录，服务端验证通过后会在响应头加入 Set-Cookie 字段，然后下次再发请求的时候，浏览器会自动将 cookie 附加在 HTTP 请求的头字段 Cookie 中，服务端就能知道这个用户已经登录过了。知道这个之后，我们来看场景： 1.你准备去清空你的购物车，于是打开了买买买网站www.maimaimai.com，然后登录成功，一看，购物车东西这么少，不行，还得买多点。 2.你在看有什么东西买的过程中，你的好基友发给你一个链接www.nidongde.com，一脸yin笑地跟你说：“你懂的”，你毫不犹豫打开了。 3.你饶有兴致地浏览着www.nidongde.com，谁知这个网站暗地里做了些不可描述的事情！由于没有同源策略的限制，它向www.maimaimai.com发起了请求！聪明的你一定想到上面的话“服务端验证通过后会在响应头加入Set-Cookie字段，然后下次再发请求的时候，浏览器会自动将cookie附加在HTTP请求的头字段Cookie中”，这样一来，这个不法网站就相当于登录了你的账号，可以为所欲为了！如果这不是一个买买买账号，而是你的银行账号，那……
这就是传说中的 CSRF 攻击&lt;a href="http://www.cnblogs.com/hyddd/archive/2009/04/09/1432744.html">浅谈 CSRF 攻击方式&lt;/a>。
看了这波 CSRF 攻击我在想，即使有了同源策略限制，但 cookie 是明文的，还不是一样能拿下来。于是我看了一些 cookie 相关的文章&lt;a href="https://segmentfault.com/a/1190000004556040#articleHeader6">聊一聊 cookie&lt;/a>、&lt;a href="https://harttle.land/2015/08/10/cookie-session.html">Cookie/Session 的机制与安全&lt;/a>，知道了服务端可以设置 httpOnly，使得前端无法操作 cookie，如果没有这样的设置，像 XSS 攻击就可以去获取到 cookie&lt;a href="https://www.cnblogs.com/TankXiao/archive/2012/03/21/2337194.html">Web 安全测试之 XSS&lt;/a>；设置 secure，则保证在 https 的加密通信中传输以防截获。&lt;/p>
&lt;h3 id="没有同源策略限制的-dom-查询">没有同源策略限制的 Dom 查询&lt;/h3>
&lt;p>1.有一天你刚睡醒，收到一封邮件，说是你的银行账号有风险，赶紧点进www.yinghang.com改密码。你吓尿了，赶紧点进去，还是熟悉的银行登录界面，你果断输入你的账号密码，登录进去看看钱有没有少了。 2.睡眼朦胧的你没看清楚，平时访问的银行网站是www.yinhang.com，而现在访问的是www.yinghang.com，这个钓鱼网站做了什么呢？&lt;/p>
&lt;pre>&lt;code>// HTML
&amp;lt;iframe name=&amp;quot;yinhang&amp;quot; src=&amp;quot;www.yinhang.com&amp;quot;&amp;gt;&amp;lt;/iframe&amp;gt;
// JS
// 由于没有同源策略的限制，钓鱼网站可以直接拿到别的网站的Dom
const iframe = window.frames['yinhang']
const node = iframe.document.getElementById('你输入账号密码的Input')
console.log(`拿到了这个${node}，我还拿不到你刚刚输入的账号密码吗`)
&lt;/code>&lt;/pre>
&lt;p>由此我们知道，同源策略确实能规避一些危险，不是说有了同源策略就安全，只是说同源策略是一种浏览器最基本的安全机制，毕竟能提高一点攻击的成本。其实没有刺不穿的盾，只是攻击的成本和攻击成功后获得的利益成不成正比。&lt;/p>
&lt;h2 id="跨域正确的打开方式">跨域正确的打开方式&lt;/h2>
&lt;p>经过对同源策略的了解，我们应该要消除对浏览器的误解，同源策略是浏览器做的一件好事，是用来防御来自邪门歪道的攻击，但总不能为了不让坏人进门而把全部人都拒之门外吧。没错，我们这种正人君子只要打开方式正确，就应该可以跨域。
下面将一个个演示正确打开方式，但在此之前，有些准备工作要做。为了本地演示跨域，我们需要： 1.随便跑起一份前端代码（以下前端是随便跑起来的 vue），地址是&lt;a href="http://localhost/">http://localhost&lt;/a>:9099。 2.随便跑起一份后端代码（以下后端是随便跑起来的 node koa2），地址是&lt;a href="http://localhost/">http://localhost&lt;/a>:9971。&lt;/p>
&lt;h3 id="同源策略限制下接口请求的正确打开方式">同源策略限制下接口请求的正确打开方式&lt;/h3>
&lt;p>&lt;strong>1.JSONP&lt;/strong>
在 HTML 标签里，一些标签比如 script、img 这样的获取资源的标签是没有跨域限制的，利用这一点，我们可以这样干：
后端写个小接口&lt;/p>
&lt;pre>&lt;code>// 处理成功失败返回格式的工具
const {successBody} = require('../utli')
class CrossDomain {
static async jsonp (ctx) {
// 前端传过来的参数
const query = ctx.request.query
// 设置一个cookies
ctx.cookies.set('tokenId', '1')
// query.cb是前后端约定的方法名字，其实就是后端返回一个直接执行的方法给前端，由于前端是用script标签发起的请求，所以返回了这个方法后相当于立马执行，并且把要返回的数据放在方法的参数里。
ctx.body = `${query.cb}(${JSON.stringify(successBody({msg: query.msg}, 'success'))})`
}
}
module.exports = CrossDomain
&lt;/code>&lt;/pre>
&lt;p>简单版前端&lt;/p>
&lt;pre>&lt;code>&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html&amp;gt;
&amp;lt;head&amp;gt;
&amp;lt;meta charset=&amp;quot;utf-8&amp;quot;&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
&amp;lt;script type='text/javascript'&amp;gt;
// 后端返回直接执行的方法，相当于执行这个方法，由于后端把返回的数据放在方法的参数里，所以这里能拿到res。
window.jsonpCb = function (res) {
console.log(res)
}
&amp;lt;/script&amp;gt;
&amp;lt;script src='http://localhost:9871/api/jsonp?msg=helloJsonp&amp;amp;cb=jsonpCb' type='text/javascript'&amp;gt;&amp;lt;/script&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/code>&lt;/pre>
&lt;p>简单封装一下前端这个套路&lt;/p>
&lt;pre>&lt;code>/**
* JSONP请求工具
* @param url 请求的地址
* @param data 请求的参数
* @returns {Promise&amp;lt;any&amp;gt;}
*/
const request = ({url, data}) =&amp;gt; {
return new Promise((resolve, reject) =&amp;gt; {
// 处理传参成xx=yy&amp;amp;aa=bb的形式
const handleData = (data) =&amp;gt; {
const keys = Object.keys(data)
const keysLen = keys.length
return keys.reduce((pre, cur, index) =&amp;gt; {
const value = data[cur]
const flag = index !== keysLen - 1 ? '&amp;amp;' : ''
return `${pre}${cur}=${value}${flag}`
}, '')
}
// 动态创建script标签
const script = document.createElement('script')
// 接口返回的数据获取
window.jsonpCb = (res) =&amp;gt; {
document.body.removeChild(script)
delete window.jsonpCb
resolve(res)
}
script.src = `${url}?${handleData(data)}&amp;amp;cb=jsonpCb`
document.body.appendChild(script)
})
}
// 使用方式
request({
url: 'http://localhost:9871/api/jsonp',
data: {
// 传参
msg: 'helloJsonp'
}
}).then(res =&amp;gt; {
console.log(res)
})
&lt;/code>&lt;/pre>
&lt;p>&lt;strong>2.空 iframe 加 form&lt;/strong>
细心的朋友可能发现，JSONP 只能发 GET 请求，因为本质上 script 加载资源就是 GET，那么如果要发 POST 请求怎么办呢？
后端写个小接口&lt;/p>
&lt;pre>&lt;code>// 处理成功失败返回格式的工具
const {successBody} = require('../utli')
class CrossDomain {
static async iframePost (ctx) {
let postData = ctx.request.body
console.log(postData)
ctx.body = successBody({postData: postData}, 'success')
}
}
module.exports = CrossDomain
&lt;/code>&lt;/pre>
&lt;p>前端&lt;/p>
&lt;pre>&lt;code>const requestPost = ({url, data}) =&amp;gt; {
// 首先创建一个用来发送数据的iframe.
const iframe = document.createElement('iframe')
iframe.name = 'iframePost'
iframe.style.display = 'none'
document.body.appendChild(iframe)
const form = document.createElement('form')
const node = document.createElement('input')
// 注册iframe的load事件处理程序,如果你需要在响应返回时执行一些操作的话.
iframe.addEventListener('load', function () {
console.log('post success')
})
form.action = url
// 在指定的iframe中执行form
form.target = iframe.name
form.method = 'post'
for (let name in data) {
node.name = name
node.value = data[name].toString()
form.appendChild(node.cloneNode())
}
// 表单元素需要添加到主文档中.
form.style.display = 'none'
document.body.appendChild(form)
form.submit()
// 表单提交后,就可以删除这个表单,不影响下次的数据发送.
document.body.removeChild(form)
}
// 使用方式
requestPost({
url: 'http://localhost:9871/api/iframePost',
data: {
msg: 'helloIframePost'
}
})
&lt;/code>&lt;/pre>
&lt;p>&lt;strong>3.CORS&lt;/strong>
CORS 是一个 W3C 标准，全称是&amp;quot;跨域资源共享&amp;quot;（Cross-origin resource sharing）&lt;a href="http://www.ruanyifeng.com/blog/2016/04/cors.html">跨域资源共享 CORS 详解&lt;/a>。看名字就知道这是处理跨域问题的标准做法。CORS 有两种请求，简单请求和非简单请求。
这里引用上面链接阮一峰老师的文章说明一下简单请求和非简单请求。浏览器将 CORS 请求分成两类：简单请求（simple request）和非简单请求（not-so-simple request）。
只要同时满足以下两大条件，就属于简单请求。
（1) 请求方法是以下三种方法之一：&lt;/p>
&lt;ul>
&lt;li>HEAD&lt;/li>
&lt;li>GET&lt;/li>
&lt;li>POST&lt;/li>
&lt;/ul>
&lt;p>（2）HTTP 的头信息不超出以下几种字段：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>Accept&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Accept-Language&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Content-Language&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Last-Event-ID&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Content-Type：只限于三个值 application/x-www-form-urlencoded、multipart/form-data、text/plain&lt;/p>
&lt;p>1.简单请求
后端&lt;/p>
&lt;pre>&lt;code>// 处理成功失败返回格式的工具
const {successBody} = require('../utli')
class CrossDomain {
static async cors (ctx) {
const query = ctx.request.query
// *时cookie不会在http请求中带上
ctx.set('Access-Control-Allow-Origin', '*')
ctx.cookies.set('tokenId', '2')
ctx.body = successBody({msg: query.msg}, 'success')
}
}
module.exports = CrossDomain
&lt;/code>&lt;/pre>
&lt;/li>
&lt;/ul>
&lt;p>前端什么也不用干，就是正常发请求就可以，如果需要带 cookie 的话，前后端都要设置一下，下面那个非简单请求例子会看到。&lt;/p>
&lt;pre>&lt;code>fetch(`http://localhost:9871/api/cors?msg=helloCors`).then(res =&amp;gt; {
console.log(res)
})
&lt;/code>&lt;/pre>
&lt;p>2.非简单请求
非简单请求会发出一次预检测请求，返回码是 204，预检测通过才会真正发出请求，这才返回 200。这里通过前端发请求的时候增加一个额外的 headers 来触发非简单请求。&lt;/p>
&lt;p>后端&lt;/p>
&lt;pre>&lt;code>// 处理成功失败返回格式的工具
const {successBody} = require('../utli')
class CrossDomain {
static async cors (ctx) {
const query = ctx.request.query
// 如果需要http请求中带上cookie，需要前后端都设置credentials，且后端设置指定的origin
ctx.set('Access-Control-Allow-Origin', 'http://localhost:9099')
ctx.set('Access-Control-Allow-Credentials', true)
// 非简单请求的CORS请求，会在正式通信之前，增加一次HTTP查询请求，称为&amp;quot;预检&amp;quot;请求（preflight）
// 这种情况下除了设置origin，还需要设置Access-Control-Request-Method以及Access-Control-Request-Headers
ctx.set('Access-Control-Request-Method', 'PUT,POST,GET,DELETE,OPTIONS')
ctx.set('Access-Control-Allow-Headers', 'Origin, X-Requested-With, Content-Type, Accept, t')
ctx.cookies.set('tokenId', '2')
ctx.body = successBody({msg: query.msg}, 'success')
}
}
module.exports = CrossDomain
&lt;/code>&lt;/pre>
&lt;p>一个接口就要写这么多代码，如果想所有接口都统一处理，有什么更优雅的方式呢？见下面的 koa2-cors。&lt;/p>
&lt;pre>&lt;code>const path = require('path')
const Koa = require('koa')
const koaStatic = require('koa-static')
const bodyParser = require('koa-bodyparser')
const router = require('./router')
const cors = require('koa2-cors')
const app = new Koa()
const port = 9871
app.use(bodyParser())
// 处理静态资源 这里是前端build好之后的目录
app.use(koaStatic(
path.resolve(__dirname, '../dist')
))
// 处理cors
app.use(cors({
origin: function (ctx) {
return 'http://localhost:9099'
},
credentials: true,
allowMethods: ['GET', 'POST', 'DELETE'],
allowHeaders: ['t', 'Content-Type']
}))
// 路由
app.use(router.routes()).use(router.allowedMethods())
// 监听端口
app.listen(9871)
console.log(`[demo] start-quick is starting at port ${port}`)
&lt;/code>&lt;/pre>
&lt;p>前端&lt;/p>
&lt;pre>&lt;code>fetch(`http://localhost:9871/api/cors?msg=helloCors`, {
// 需要带上cookie
credentials: 'include',
// 这里添加额外的headers来触发非简单请求
headers: {
't': 'extra headers'
}
}).then(res =&amp;gt; {
console.log(res)
})
&lt;/code>&lt;/pre>
&lt;p>&lt;strong>4.代理&lt;/strong>
想一下，如果我们请求的时候还是用前端的域名，然后有个东西帮我们把这个请求转发到真正的后端域名上，不就避免跨域了吗？这时候，Nginx 出场了。
Nginx 配置&lt;/p>
&lt;pre>&lt;code>server{
# 监听9099端口
listen 9099;
# 域名是localhost
server_name localhost;
#凡是localhost:9099/api这个样子的，都转发到真正的服务端地址http://localhost:9871
location ^~ /api {
proxy_pass http://localhost:9871;
}
}
&lt;/code>&lt;/pre>
&lt;p>前端就不用干什么事情了，除了写接口，也没后端什么事情了&lt;/p>
&lt;pre>&lt;code>// 请求的时候直接用回前端这边的域名http://localhost:9099，这就不会跨域，然后Nginx监听到凡是localhost:9099/api这个样子的，都转发到真正的服务端地址http://localhost:9871
fetch('http://localhost:9099/api/iframePost', {
method: 'POST',
headers: {
'Accept': 'application/json',
'Content-Type': 'application/json'
},
body: JSON.stringify({
msg: 'helloIframePost'
})
})
&lt;/code>&lt;/pre>
&lt;p>Nginx 转发的方式似乎很方便！但这种使用也是看场景的，如果后端接口是一个公共的 API，比如一些公共服务获取天气什么的，前端调用的时候总不能让运维去配置一下 Nginx，如果兼容性没问题（IE 10 或者以上），CROS 才是更通用的做法吧。&lt;/p>
&lt;h3 id="同源策略限制下-dom-查询的正确打开方式">同源策略限制下 Dom 查询的正确打开方式&lt;/h3>
&lt;p>&lt;strong>1.postMessage&lt;/strong>
window.postMessage() 是 HTML5 的一个接口，专注实现不同窗口不同页面的跨域通讯。
为了演示方便，我们将 hosts 改一下：127.0.0.1 crossDomain.com，现在访问域名 crossDomain.com 就等于访问 127.0.0.1。
这里是&lt;a href="http://localhost/">http://localhost&lt;/a>:9099/#/crossDomain，发消息方&lt;/p>
&lt;pre>&lt;code>&amp;lt;template&amp;gt;
&amp;lt;div&amp;gt;
&amp;lt;button @click=&amp;quot;postMessage&amp;quot;&amp;gt;给http://crossDomain.com:9099发消息&amp;lt;/button&amp;gt;
&amp;lt;iframe name=&amp;quot;crossDomainIframe&amp;quot; src=&amp;quot;http://crossdomain.com:9099&amp;quot;&amp;gt;&amp;lt;/iframe&amp;gt;
&amp;lt;/div&amp;gt;
&amp;lt;/template&amp;gt;
&amp;lt;script&amp;gt;
export default {
mounted () {
window.addEventListener('message', (e) =&amp;gt; {
// 这里一定要对来源做校验
if (e.origin === 'http://crossdomain.com:9099') {
// 来自http://crossdomain.com:9099的结果回复
console.log(e.data)
}
})
},
methods: {
// 向http://crossdomain.com:9099发消息
postMessage () {
const iframe = window.frames['crossDomainIframe']
iframe.postMessage('我是[http://localhost:9099], 麻烦你查一下你那边有没有id为app的Dom', 'http://crossdomain.com:9099')
}
}
}
&amp;lt;/script&amp;gt;
&lt;/code>&lt;/pre>
&lt;p>这里是&lt;a href="http://crossdomain.com/">http://crossdomain.com&lt;/a>:9099，接收消息方&lt;/p>
&lt;pre>&lt;code>&amp;lt;template&amp;gt;
&amp;lt;div&amp;gt;
我是http://crossdomain.com:9099
&amp;lt;/div&amp;gt;
&amp;lt;/template&amp;gt;
&amp;lt;script&amp;gt;
export default {
mounted () {
window.addEventListener('message', (e) =&amp;gt; {
// 这里一定要对来源做校验
if (e.origin === 'http://localhost:9099') {
// http://localhost:9099发来的信息
console.log(e.data)
// e.source可以是回信的对象，其实就是http://localhost:9099窗口对象(window)的引用
// e.origin可以作为targetOrigin
e.source.postMessage(`我是[http://crossdomain.com:9099]，我知道了兄弟，这就是你想知道的结果：${document.getElementById('app') ? '有id为app的Dom' : '没有id为app的Dom'}`, e.origin);
}
})
}
}
&amp;lt;/script&amp;gt;
&lt;/code>&lt;/pre>
&lt;p>结果可以看到：
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/qud8hv/1616980608839-5a31e5c5-6ed7-4593-9081-bae13f3f1213.png" alt="">
&lt;strong>2.document.domain&lt;/strong>
这种方式只适合主域名相同，但子域名不同的 iframe 跨域。
比如主域名是&lt;a href="http://crossdomain.com/">http://crossdomain.com&lt;/a>:9099，子域名是&lt;a href="http://child.crossdomain.com/">http://child.crossdomain.com&lt;/a>:9099，这种情况下给两个页面指定一下 document.domain 即 document.domain = crossdomain.com 就可以访问各自的 window 对象了。
&lt;strong>3.canvas 操作图片的跨域问题&lt;/strong>
这个应该是一个比较冷门的跨域问题，张大神已经写过了我就不再班门弄斧了&lt;a href="https://www.zhangxinxu.com/wordpress/2018/02/crossorigin-canvas-getimagedata-cors/">解决 canvas 图片 getImageData,toDataURL 跨域问题&lt;/a>&lt;/p>
&lt;h2 id="最后">最后&lt;/h2>
&lt;p>希望看完这篇文章之后，再有人问跨域的问题，你可以嘴角微微上扬，冷笑一声：“不要再问我跨域的问题了。”
扬长而去。&lt;/p></description></item></channel></rss>