<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>断念梦的站点 – HTTP 的 持久化 与 认证_授权</title><link>https://desistdaydream.github.io/docs/4.%E6%95%B0%E6%8D%AE%E9%80%9A%E4%BF%A1/%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/HTTP/HTTP-%E4%BC%9A%E8%AF%9D%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86/</link><description>Recent content in HTTP 的 持久化 与 认证_授权 on 断念梦的站点</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><atom:link href="https://desistdaydream.github.io/docs/4.%E6%95%B0%E6%8D%AE%E9%80%9A%E4%BF%A1/%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/HTTP/HTTP-%E4%BC%9A%E8%AF%9D%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86/index.xml" rel="self" type="application/rss+xml"/><item><title>Docs: HTTP 会话状态管理</title><link>https://desistdaydream.github.io/docs/4.%E6%95%B0%E6%8D%AE%E9%80%9A%E4%BF%A1/%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/HTTP/HTTP-%E4%BC%9A%E8%AF%9D%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86/HTTP-%E4%BC%9A%E8%AF%9D%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/4.%E6%95%B0%E6%8D%AE%E9%80%9A%E4%BF%A1/%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/HTTP/HTTP-%E4%BC%9A%E8%AF%9D%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86/HTTP-%E4%BC%9A%E8%AF%9D%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86/</guid><description>
&lt;h1 id="概述">概述&lt;a class="td-heading-self-link" href="#%e6%a6%82%e8%bf%b0" aria-label="Heading self-link">&lt;/a>&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>HTTP 会话状态管理包含认证/授权&lt;/p>
&lt;h1 id="傻傻分不清之-cookiesessiontokenjwt">傻傻分不清之 Cookie、Session、Token、JWT&lt;a class="td-heading-self-link" href="#%e5%82%bb%e5%82%bb%e5%88%86%e4%b8%8d%e6%b8%85%e4%b9%8b-cookiesessiontokenjwt" aria-label="Heading self-link">&lt;/a>&lt;/h1>
&lt;p>原文：&lt;a href="https://juejin.cn/post/6844904034181070861">掘金，傻傻分不清之 Cookie、Session、Token、JWT&lt;/a>&lt;/p>
&lt;h2 id="什么是认证authentication">什么是认证（Authentication）&lt;a class="td-heading-self-link" href="#%e4%bb%80%e4%b9%88%e6%98%af%e8%ae%a4%e8%af%81authentication" aria-label="Heading self-link">&lt;/a>&lt;/h2>
&lt;ul>
&lt;li>通俗地讲就是&lt;strong>验证当前用户的身份&lt;/strong>，证明“你是你自己”（比如：你每天上下班打卡，都需要通过指纹打卡，当你的指纹和系统里录入的指纹相匹配时，就打卡成功）&lt;/li>
&lt;li>互联网中的认证：
&lt;ul>
&lt;li>用户名密码登录&lt;/li>
&lt;li>邮箱发送登录链接&lt;/li>
&lt;li>手机号接收验证码&lt;/li>
&lt;li>只要你能收到邮箱/验证码，就默认你是账号的主人&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h2 id="什么是授权authorization">什么是授权（Authorization）&lt;a class="td-heading-self-link" href="#%e4%bb%80%e4%b9%88%e6%98%af%e6%8e%88%e6%9d%83authorization" aria-label="Heading self-link">&lt;/a>&lt;/h2>
&lt;ul>
&lt;li>&lt;strong>用户授予第三方应用访问该用户某些资源的权限&lt;/strong>
&lt;ul>
&lt;li>你在安装手机应用的时候，APP 会询问是否允许授予权限（访问相册、地理位置等权限）&lt;/li>
&lt;li>你在访问微信小程序时，当登录时，小程序会询问是否允许授予权限（获取昵称、头像、地区、性别等个人信息）&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>实现授权的方式有：cookie、session、token、OAuth&lt;/li>
&lt;/ul>
&lt;h2 id="什么是凭证credentials">什么是凭证（Credentials）&lt;a class="td-heading-self-link" href="#%e4%bb%80%e4%b9%88%e6%98%af%e5%87%ad%e8%af%81credentials" aria-label="Heading self-link">&lt;/a>&lt;/h2>
&lt;ul>
&lt;li>&lt;strong>实现认证和授权的前提&lt;/strong> 是需要一种 &lt;strong>媒介(证书)&lt;/strong> 来标记访问者的身份
&lt;ul>
&lt;li>在战国时期，商鞅变法，发明了照身帖。照身帖由官府发放，是一块打磨光滑细密的竹板，上面刻有持有人的头像和籍贯信息。国人必须持有，如若没有就被认为是黑户，或者间谍之类的。&lt;/li>
&lt;li>在现实生活中，每个人都会有一张专属的&lt;a href="https://baike.baidu.com/item/%E5%B1%85%E6%B0%91%E8%BA%AB%E4%BB%BD%E8%AF%81/2080960">居民身份证&lt;/a>，是用于证明持有人身份的一种法定&lt;a href="https://baike.baidu.com/item/%E8%AF%81%E4%BB%B6/5804999">证件&lt;/a>。通过身份证，我们可以办理手机卡/银行卡/个人贷款/交通出行等等，这就是&lt;strong>认证的凭证。&lt;/strong>&lt;/li>
&lt;li>在互联网应用中，一般网站（如掘金）会有两种模式，游客模式和登录模式。游客模式下，可以正常浏览网站上面的文章，一旦想要点赞/收藏/分享文章，就需要登录或者注册账号。当用户登录成功后，服务器会给该用户使用的浏览器颁发一个令牌（token），这个令牌用来表明你的身份，每次浏览器发送请求时会带上这个令牌，就可以使用游客模式下无法使用的功能。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h2 id="什么是-cookie">什么是 Cookie&lt;a class="td-heading-self-link" href="#%e4%bb%80%e4%b9%88%e6%98%af-cookie" aria-label="Heading self-link">&lt;/a>&lt;/h2>
&lt;ul>
&lt;li>&lt;strong>HTTP 是无状态的协议（对于事务处理没有记忆能力，每次客户端和服务端会话完成时，服务端不会保存任何会话信息&lt;/strong>）：每个请求都是完全独立的，服务端无法确认当前访问者的身份信息，无法分辨上一次的请求发送者和这一次的发送者是不是同一个人。所以服务器与浏览器为了进行会话跟踪（知道是谁在访问我），就必须主动的去维护一个状态，这个状态用于告知服务端前后两个请求是否来自同一浏览器。而这个状态需要通过 cookie 或者 session 去实现。&lt;/li>
&lt;li>&lt;strong>cookie 存储在客户端：&lt;/strong> cookie 是服务器发送到用户浏览器并保存在本地的一小块数据，它会在浏览器下次向同一服务器再发起请求时被携带并发送到服务器上。&lt;/li>
&lt;li>&lt;strong>cookie 是不可跨域的：&lt;/strong> 每个 cookie 都会绑定单一的域名，无法在别的域名下获取使用，&lt;strong>一级域名和二级域名之间是允许共享使用的&lt;/strong>（&lt;strong>靠的是 domain）&lt;/strong>。&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>cookie 重要的属性&lt;/strong>&lt;/p>
&lt;p>name=value # 键值对，设置 Cookie 的名称及相对应的值，都必须是字符串类型- 如果值为 Unicode 字符，需要为字符编码。- 如果值为二进制数据，则需要使用 BASE64 编码。&lt;/p>
&lt;p>domain # 指定 cookie 所属域名，默认是当前域名&lt;/p>
&lt;p>path # 指定 cookie 在哪个路径（路由）下生效，默认是 &amp;lsquo;/&amp;rsquo;。如果设置为 /abc，则只有 /abc 下的路由可以访问到该 cookie，如：/abc/read。&lt;/p>
&lt;p>maxAge # cookie 失效的时间，单位秒。如果为整数，则该 cookie 在 maxAge 秒后失效。如果为负数，该 cookie 为临时 cookie ，关闭浏览器即失效，浏览器也不会以任何形式保存该 cookie 。如果为 0，表示删除该 cookie 。默认为 -1。- 比 expires 好用。&lt;/p>
&lt;p>expires # 过期时间，在设置的某个时间点后该 cookie 就会失效。一般浏览器的 cookie 都是默认储存的，当关闭浏览器结束这个会话的时候，这个 cookie 也就会被删除&lt;/p>
&lt;p>secure # 该 cookie 是否仅被使用安全协议传输。安全协议有 HTTPS，SSL等，在网络上传输数据之前先将数据加密。默认为false。当 secure 值为 true 时，cookie 在 HTTP 中是无效，在 HTTPS 中才有效。&lt;/p>
&lt;p>httpOnly # 如果给某个 cookie 设置了 httpOnly 属性，则无法通过 JS 脚本 读取到该 cookie 的信息，但还是能通过 Application 中手动修改 cookie，所以只是在一定程度上可以防止 XSS 攻击，不是绝对的安全&lt;/p>
&lt;h2 id="什么是-session">什么是 Session&lt;a class="td-heading-self-link" href="#%e4%bb%80%e4%b9%88%e6%98%af-session" aria-label="Heading self-link">&lt;/a>&lt;/h2>
&lt;ul>
&lt;li>&lt;strong>session 是另一种记录服务器和客户端会话状态的机制&lt;/strong>&lt;/li>
&lt;li>&lt;strong>session 是基于 cookie 实现的，session 存储在服务器端，sessionId 会被存储到客户端的 cookie 中&lt;/strong>&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/rv7ih5/1623681275011-42bd5bea-dbaf-4605-95a2-c433d48b78c8.webp" alt="">&lt;/p>
&lt;ul>
&lt;li>&lt;strong>session 认证流程：&lt;/strong>
&lt;ul>
&lt;li>用户第一次请求服务器的时候，服务器根据用户提交的相关信息，创建对应的 Session&lt;/li>
&lt;li>请求返回时将此 Session 的唯一标识信息 SessionID 返回给浏览器&lt;/li>
&lt;li>浏览器接收到服务器返回的 SessionID 信息后，会将此信息存入到 Cookie 中，同时 Cookie 记录此 SessionID 属于哪个域名&lt;/li>
&lt;li>当用户第二次访问服务器的时候，请求会自动判断此域名下是否存在 Cookie 信息，如果存在自动将 Cookie 信息也发送给服务端，服务端会从 Cookie 中获取 SessionID，再根据 SessionID 查找对应的 Session 信息，如果没有找到说明用户没有登录或者登录失效，如果找到 Session 证明用户已经登录可执行后面操作。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>根据以上流程可知，&lt;strong>SessionID 是连接 Cookie 和 Session 的一道桥梁&lt;/strong>，大部分系统也是根据此原理来验证用户登录状态。&lt;/p>
&lt;h2 id="cookie-和-session-的区别">Cookie 和 Session 的区别&lt;a class="td-heading-self-link" href="#cookie-%e5%92%8c-session-%e7%9a%84%e5%8c%ba%e5%88%ab" aria-label="Heading self-link">&lt;/a>&lt;/h2>
&lt;ul>
&lt;li>&lt;strong>安全性：&lt;/strong> Session 比 Cookie 安全，Session 是存储在服务器端的，Cookie 是存储在客户端的。&lt;/li>
&lt;li>&lt;strong>存取值的类型不同&lt;/strong>：Cookie 只支持存字符串数据，想要设置其他类型的数据，需要将其转换成字符串，Session 可以存任意数据类型。&lt;/li>
&lt;li>&lt;strong>有效期不同：&lt;/strong> Cookie 可设置为长时间保持，比如我们经常使用的默认登录功能，Session 一般失效时间较短，客户端关闭（默认情况下）或者 Session 超时都会失效。&lt;/li>
&lt;li>&lt;strong>存储大小不同：&lt;/strong> 单个 Cookie 保存的数据不能超过 4K，Session 可存储数据远高于 Cookie，但是当访问量过多，会占用过多的服务器资源。&lt;/li>
&lt;/ul>
&lt;h2 id="什么是-token令牌">什么是 Token（令牌）&lt;a class="td-heading-self-link" href="#%e4%bb%80%e4%b9%88%e6%98%af-token%e4%bb%a4%e7%89%8c" aria-label="Heading self-link">&lt;/a>&lt;/h2>
&lt;h3 id="acesss-token">Acesss Token&lt;a class="td-heading-self-link" href="#acesss-token" aria-label="Heading self-link">&lt;/a>&lt;/h3>
&lt;ul>
&lt;li>&lt;strong>访问资源接口（API）时所需要的资源凭证&lt;/strong>&lt;/li>
&lt;li>&lt;strong>简单 token 的组成：&lt;/strong> uid(用户唯一的身份标识)、time(当前时间的时间戳)、sign（签名，token 的前几位以哈希算法压缩成的一定长度的十六进制字符串）&lt;/li>
&lt;li>&lt;strong>特点：&lt;/strong>
&lt;ul>
&lt;li>&lt;strong>服务端无状态化、可扩展性好&lt;/strong>&lt;/li>
&lt;li>&lt;strong>支持移动端设备&lt;/strong>&lt;/li>
&lt;li>安全&lt;/li>
&lt;li>支持跨程序调用&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>token 的身份验证流程：&lt;/strong>&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/rv7ih5/1623681275029-dccf3312-cfa7-4ac5-9008-0697991e35b3.webp" alt="">&lt;/p>
&lt;ol>
&lt;li>客户端使用用户名跟密码请求登录&lt;/li>
&lt;li>服务端收到请求，去验证用户名与密码&lt;/li>
&lt;li>验证成功后，服务端会签发一个 token 并把这个 token 发送给客户端&lt;/li>
&lt;li>客户端收到 token 以后，会把它存储起来，比如放在 cookie 里或者 localStorage 里&lt;/li>
&lt;li>客户端每次向服务端请求资源的时候需要带着服务端签发的 token&lt;/li>
&lt;li>服务端收到请求，然后去验证客户端请求里面带着的 token ，如果验证成功，就向客户端返回请求的数据&lt;/li>
&lt;/ol>
&lt;ul>
&lt;li>&lt;strong>每一次请求都需要携带 token，需要把 token 放到 HTTP 的 Header 里&lt;/strong>&lt;/li>
&lt;li>&lt;strong>基于 token 的用户认证是一种服务端无状态的认证方式，服务端不用存放 token 数据。用解析 token 的计算时间换取 session 的存储空间，从而减轻服务器的压力，减少频繁的查询数据库&lt;/strong>&lt;/li>
&lt;li>&lt;strong>token 完全由应用管理，所以它可以避开同源策略&lt;/strong>&lt;/li>
&lt;/ul>
&lt;h3 id="refresh-token">Refresh Token&lt;a class="td-heading-self-link" href="#refresh-token" aria-label="Heading self-link">&lt;/a>&lt;/h3>
&lt;ul>
&lt;li>
&lt;p>另外一种 token——refresh token&lt;/p>
&lt;/li>
&lt;li>
&lt;p>refresh token 是专用于刷新 access token 的 token。如果没有 refresh token，也可以刷新 access token，但每次刷新都要用户输入登录用户名与密码，会很麻烦。有了 refresh token，可以减少这个麻烦，客户端直接用 refresh token 去更新 access token，无需用户进行额外的操作。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/rv7ih5/1623681275000-372bff85-cf45-4502-a00d-981a4d52f36b.webp" alt="">&lt;/p>
&lt;ul>
&lt;li>Access Token 的有效期比较短，当 Acesss Token 由于过期而失效时，使用 Refresh Token 就可以获取到新的 Token，如果 Refresh Token 也失效了，用户就只能重新登录了。&lt;/li>
&lt;li>Refresh Token 及过期时间是存储在服务器的数据库中，只有在申请新的 Acesss Token 时才会验证，不会对业务接口响应时间造成影响，也不需要向 Session 一样一直保持在内存中以应对大量的请求。&lt;/li>
&lt;/ul>
&lt;h2 id="token-和-session-的区别">Token 和 Session 的区别&lt;a class="td-heading-self-link" href="#token-%e5%92%8c-session-%e7%9a%84%e5%8c%ba%e5%88%ab" aria-label="Heading self-link">&lt;/a>&lt;/h2>
&lt;ul>
&lt;li>Session 是一种&lt;strong>记录服务器和客户端会话状态的机制，使服务端有状态化，可以记录会话信息&lt;/strong>。而 Token 是&lt;strong>令牌&lt;/strong>，&lt;strong>访问资源接口（API）时所需要的资源凭证&lt;/strong>。Token &lt;strong>使服务端无状态化，不会存储会话信息。&lt;/strong>&lt;/li>
&lt;li>Session 和 Token 并不矛盾，作为身份认证 Token 安全性比 Session 好，因为每一个请求都有签名还能防止监听以及重放攻击，而 Session 就必须依赖链路层来保障通讯安全了。&lt;strong>如果你需要实现有状态的会话，仍然可以增加 Session 来在服务器端保存一些状态。&lt;/strong>&lt;/li>
&lt;li>所谓 Session 认证只是简单的把 User 信息存储到 Session 里，因为 SessionID 的不可预测性，暂且认为是安全的。而 Token ，如果指的是 OAuth Token 或类似的机制的话，提供的是 认证 和 授权 ，认证是针对用户，授权是针对 App 。其目的是让某 App 有权利访问某用户的信息。这里的 Token 是唯一的。不可以转移到其它 App 上，也不可以转到其它用户上。Session 只提供一种简单的认证，即只要有此 SessionID ，即认为有此 User 的全部权利。是需要严格保密的，这个数据应该只保存在站方，不应该共享给其它网站或者第三方 App。所以简单来说：&lt;strong>如果你的用户数据可能需要和第三方共享，或者允许第三方调用 API 接口，用 Token 。如果永远只是自己的网站，自己的 App，用什么就无所谓了。&lt;/strong>&lt;/li>
&lt;/ul>
&lt;h2 id="什么是-jwt">什么是 JWT&lt;a class="td-heading-self-link" href="#%e4%bb%80%e4%b9%88%e6%98%af-jwt" aria-label="Heading self-link">&lt;/a>&lt;/h2>
&lt;ul>
&lt;li>JSON Web Token（简称 JWT）是目前最流行的&lt;strong>跨域认证&lt;/strong>解决方案。&lt;/li>
&lt;li>是一种&lt;strong>认证授权机制&lt;/strong>。&lt;/li>
&lt;li>JWT 是为了在网络应用环境间&lt;strong>传递声明&lt;/strong>而执行的一种基于 JSON 的开放标准（&lt;a href="https://tools.ietf.org/html/rfc7519">RFC 7519&lt;/a>）。JWT 的声明一般被用来在身份提供者和服务提供者间传递被认证的用户身份信息，以便于从资源服务器获取资源。比如用在用户登录上。&lt;/li>
&lt;li>可以使用 HMAC 算法或者是 RSA 的公/私秘钥对 JWT 进行签名。因为数字签名的存在，这些传递的信息是可信的。&lt;/li>
&lt;li>&lt;strong>阮一峰老师的 &lt;a href="http://www.ruanyifeng.com/blog/2018/07/json_web_token-tutorial.html">JSON Web Token 入门教程&lt;/a> 讲的非常通俗易懂，这里就不再班门弄斧了&lt;/strong>&lt;/li>
&lt;/ul>
&lt;h3 id="生成-jwt">生成 JWT&lt;a class="td-heading-self-link" href="#%e7%94%9f%e6%88%90-jwt" aria-label="Heading self-link">&lt;/a>&lt;/h3>
&lt;p>&lt;a href="https://jwt.io/">jwt.io/&lt;/a>
&lt;a href="https://www.jsonwebtoken.io/">www.jsonwebtoken.io/&lt;/a>&lt;/p>
&lt;h3 id="jwt-的原理">JWT 的原理&lt;a class="td-heading-self-link" href="#jwt-%e7%9a%84%e5%8e%9f%e7%90%86" aria-label="Heading self-link">&lt;/a>&lt;/h3>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/rv7ih5/1623681275062-caae1d23-b1ee-4012-a7a6-551725463c32.webp" alt="">&lt;/p>
&lt;ul>
&lt;li>&lt;strong>JWT 认证流程：&lt;/strong>
&lt;ul>
&lt;li>用户输入用户名/密码登录，服务端认证成功后，会返回给客户端一个 JWT&lt;/li>
&lt;li>客户端将 token 保存到本地（通常使用 localstorage，也可以使用 cookie）&lt;/li>
&lt;li>当用户希望访问一个受保护的路由或者资源的时候，需要请求头的 Authorization 字段中使用 Bearer 模式添加 JWT，其内容看起来是下面这样&lt;/li>
&lt;li>&lt;code>Authorization: Bearer &amp;lt;token&amp;gt;&lt;/code>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>服务端的保护路由将会检查请求头 Authorization 中的 JWT 信息，如果合法，则允许用户的行为&lt;/li>
&lt;li>因为 JWT 是自包含的（内部包含了一些会话信息），因此减少了需要查询数据库的需要&lt;/li>
&lt;li>因为 JWT 并不使用 Cookie 的，所以你可以使用任何域名提供你的 API 服务而不需要担心跨域资源共享问题（CORS）&lt;/li>
&lt;li>因为用户的状态不再存储在服务端的内存中，所以这是一种无状态的认证机制&lt;/li>
&lt;/ul>
&lt;h3 id="jwt-的使用方式">JWT 的使用方式&lt;a class="td-heading-self-link" href="#jwt-%e7%9a%84%e4%bd%bf%e7%94%a8%e6%96%b9%e5%bc%8f" aria-label="Heading self-link">&lt;/a>&lt;/h3>
&lt;ul>
&lt;li>客户端收到服务器返回的 JWT，可以储存在 Cookie 里面，也可以储存在 localStorage。&lt;/li>
&lt;/ul>
&lt;h4 id="方式一">方式一&lt;a class="td-heading-self-link" href="#%e6%96%b9%e5%bc%8f%e4%b8%80" aria-label="Heading self-link">&lt;/a>&lt;/h4>
&lt;ul>
&lt;li>当用户希望访问一个受保护的路由或者资源的时候，可以把它放在 Cookie 里面自动发送，但是这样不能跨域，所以更好的做法是放在 HTTP 请求头信息的 Authorization 字段里，使用 Bearer 模式添加 JWT。&lt;/li>
&lt;/ul>
&lt;pre tabindex="0">&lt;code>GET /calendar/v1/events
Host: api.example.com
Authorization: Bearer &amp;lt;token&amp;gt;
&lt;/code>&lt;/pre>&lt;ul>
&lt;li>用户的状态不会存储在服务端的内存中，这是一种 &lt;strong>无状态的认证机制&lt;/strong>&lt;/li>
&lt;li>服务端的保护路由将会检查请求头 Authorization 中的 JWT 信息，如果合法，则允许用户的行为。&lt;/li>
&lt;li>由于 JWT 是自包含的，因此减少了需要查询数据库的需要&lt;/li>
&lt;li>JWT 的这些特性使得我们可以完全依赖其无状态的特性提供数据 API 服务，甚至是创建一个下载流服务。&lt;/li>
&lt;li>因为 JWT 并不使用 Cookie ，所以你可以使用任何域名提供你的 API 服务而&lt;strong>不需要担心跨域资源共享问题&lt;/strong>（CORS）&lt;/li>
&lt;/ul>
&lt;h4 id="方式二">方式二&lt;a class="td-heading-self-link" href="#%e6%96%b9%e5%bc%8f%e4%ba%8c" aria-label="Heading self-link">&lt;/a>&lt;/h4>
&lt;ul>
&lt;li>跨域的时候，可以把 JWT 放在 POST 请求的数据体里。&lt;/li>
&lt;/ul>
&lt;h4 id="方式三">方式三&lt;a class="td-heading-self-link" href="#%e6%96%b9%e5%bc%8f%e4%b8%89" aria-label="Heading self-link">&lt;/a>&lt;/h4>
&lt;ul>
&lt;li>
&lt;p>通过 URL 传输&lt;/p>
&lt;p>&lt;a href="http://www.example.com/user?token=xxx">http://www.example.com/user?token=xxx&lt;/a>
复制代码&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h3 id="项目中使用-jwt">项目中使用 JWT&lt;a class="td-heading-self-link" href="#%e9%a1%b9%e7%9b%ae%e4%b8%ad%e4%bd%bf%e7%94%a8-jwt" aria-label="Heading self-link">&lt;/a>&lt;/h3>
&lt;p>&lt;a href="https://github.com/yjdjiayou/jwt-demo">&lt;strong>项目地址&lt;/strong>&lt;/a>&lt;/p>
&lt;h2 id="token-和-jwt-的区别">Token 和 JWT 的区别&lt;a class="td-heading-self-link" href="#token-%e5%92%8c-jwt-%e7%9a%84%e5%8c%ba%e5%88%ab" aria-label="Heading self-link">&lt;/a>&lt;/h2>
&lt;p>&lt;strong>相同：&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>都是访问资源的令牌&lt;/li>
&lt;li>都可以记录用户的信息&lt;/li>
&lt;li>都是使服务端无状态化&lt;/li>
&lt;li>都是只有验证成功后，客户端才能访问服务端上受保护的资源&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>区别：&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>Token：服务端验证客户端发送过来的 Token 时，还需要查询数据库获取用户信息，然后验证 Token 是否有效。&lt;/li>
&lt;li>JWT： 将 Token 和 Payload 加密后存储于客户端，服务端只需要使用密钥解密进行校验（校验也是 JWT 自己实现的）即可，不需要查询或者减少查询数据库，因为 JWT 自包含了用户信息和加密的数据。&lt;/li>
&lt;/ul>
&lt;h2 id="常见的前后端鉴权方式">常见的前后端鉴权方式&lt;a class="td-heading-self-link" href="#%e5%b8%b8%e8%a7%81%e7%9a%84%e5%89%8d%e5%90%8e%e7%ab%af%e9%89%b4%e6%9d%83%e6%96%b9%e5%bc%8f" aria-label="Heading self-link">&lt;/a>&lt;/h2>
&lt;ol>
&lt;li>Session-Cookie&lt;/li>
&lt;li>Token 验证（包括 JWT，SSO）&lt;/li>
&lt;li>OAuth2.0（开放授权）&lt;/li>
&lt;/ol>
&lt;h2 id="常见的加密算法">常见的加密算法&lt;a class="td-heading-self-link" href="#%e5%b8%b8%e8%a7%81%e7%9a%84%e5%8a%a0%e5%af%86%e7%ae%97%e6%b3%95" aria-label="Heading self-link">&lt;/a>&lt;/h2>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/rv7ih5/1623681275046-ccd24609-06ff-4db8-95c9-6619fb91e5ae.webp" alt="">&lt;/p>
&lt;ul>
&lt;li>哈希算法(Hash Algorithm)又称散列算法、散列函数、哈希函数，是一种从任何一种数据中创建小的数字“指纹”的方法。哈希算法将数据重新打乱混合，重新创建一个哈希值。&lt;/li>
&lt;li>哈希算法主要用来保障数据真实性(即完整性)，即发信人将原始消息和哈希值一起发送，收信人通过相同的哈希函数来校验原始数据是否真实。&lt;/li>
&lt;li>哈希算法通常有以下几个特点：
&lt;ul>
&lt;li>正像快速：原始数据可以快速计算出哈希值&lt;/li>
&lt;li>逆向困难：通过哈希值基本不可能推导出原始数据&lt;/li>
&lt;li>输入敏感：原始数据只要有一点变动，得到的哈希值差别很大&lt;/li>
&lt;li>冲突避免：很难找到不同的原始数据得到相同的哈希值，宇宙中原子数大约在 10 的 60 次方到 80 次方之间，所以 2 的 256 次方有足够的空间容纳所有的可能，算法好的情况下冲突碰撞的概率很低：
&lt;ul>
&lt;li>2 的 128 次方为 340282366920938463463374607431768211456，也就是 10 的 39 次方级别&lt;/li>
&lt;li>2 的 160 次方为 1.4615016373309029182036848327163e+48，也就是 10 的 48 次方级别&lt;/li>
&lt;li>2 的 256 次方为 1.1579208923731619542357098500869 × 10 的 77 次方，也就是 10 的 77 次方&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>注意：&lt;/strong>&lt;/p>
&lt;ol>
&lt;li>以上不能保证数据被恶意篡改，原始数据和哈希值都可能被恶意篡改，要保证不被篡改，可以使用 RSA 公钥私钥方案，再配合哈希值。&lt;/li>
&lt;li>哈希算法主要用来防止计算机传输过程中的错误，早期计算机通过前 7 位数据第 8 位奇偶校验码来保障（12.5% 的浪费效率低），对于一段数据或文件，通过哈希算法生成 128bit 或者 256bit 的哈希值，如果校验有问题就要求重传。&lt;/li>
&lt;/ol>
&lt;h2 id="常见问题">常见问题&lt;a class="td-heading-self-link" href="#%e5%b8%b8%e8%a7%81%e9%97%ae%e9%a2%98" aria-label="Heading self-link">&lt;/a>&lt;/h2>
&lt;h3 id="使用-cookie-时需要考虑的问题">使用 cookie 时需要考虑的问题&lt;a class="td-heading-self-link" href="#%e4%bd%bf%e7%94%a8-cookie-%e6%97%b6%e9%9c%80%e8%a6%81%e8%80%83%e8%99%91%e7%9a%84%e9%97%ae%e9%a2%98" aria-label="Heading self-link">&lt;/a>&lt;/h3>
&lt;ul>
&lt;li>因为存储在客户端，容易被客户端篡改，使用前需要验证合法性&lt;/li>
&lt;li>不要存储敏感数据，比如用户密码，账户余额&lt;/li>
&lt;li>使用 httpOnly 在一定程度上提高安全性&lt;/li>
&lt;li>尽量减少 cookie 的体积，能存储的数据量不能超过 4kb&lt;/li>
&lt;li>设置正确的 domain 和 path，减少数据传输&lt;/li>
&lt;li>&lt;strong>cookie 无法跨域&lt;/strong>&lt;/li>
&lt;li>一个浏览器针对一个网站最多存 20 个 Cookie，浏览器一般只允许存放 300 个 Cookie&lt;/li>
&lt;li>&lt;strong>移动端对 cookie 的支持不是很好，而 session 需要基于 cookie 实现，所以移动端常用的是 token&lt;/strong>&lt;/li>
&lt;/ul>
&lt;h3 id="使用-session-时需要考虑的问题">使用 session 时需要考虑的问题&lt;a class="td-heading-self-link" href="#%e4%bd%bf%e7%94%a8-session-%e6%97%b6%e9%9c%80%e8%a6%81%e8%80%83%e8%99%91%e7%9a%84%e9%97%ae%e9%a2%98" aria-label="Heading self-link">&lt;/a>&lt;/h3>
&lt;ul>
&lt;li>将 session 存储在服务器里面，当用户同时在线量比较多时，这些 session 会占据较多的内存，需要在服务端定期的去清理过期的 session&lt;/li>
&lt;li>当网站采用&lt;strong>集群部署&lt;/strong>的时候，会遇到多台 web 服务器之间如何做 session 共享的问题。因为 session 是由单个服务器创建的，但是处理用户请求的服务器不一定是那个创建 session 的服务器，那么该服务器就无法拿到之前已经放入到 session 中的登录凭证之类的信息了。&lt;/li>
&lt;li>当多个应用要共享 session 时，除了以上问题，还会遇到跨域问题，因为不同的应用可能部署的主机不一样，需要在各个应用做好 cookie 跨域的处理。&lt;/li>
&lt;li>&lt;strong>sessionId 是存储在 cookie 中的，假如浏览器禁止 cookie 或不支持 cookie 怎么办？&lt;/strong> 一般会把 sessionId 跟在 url 参数后面即重写 url，所以 session 不一定非得需要靠 cookie 实现&lt;/li>
&lt;li>&lt;strong>移动端对 cookie 的支持不是很好，而 session 需要基于 cookie 实现，所以移动端常用的是 token&lt;/strong>&lt;/li>
&lt;/ul>
&lt;h3 id="使用-token-时需要考虑的问题">使用 token 时需要考虑的问题&lt;a class="td-heading-self-link" href="#%e4%bd%bf%e7%94%a8-token-%e6%97%b6%e9%9c%80%e8%a6%81%e8%80%83%e8%99%91%e7%9a%84%e9%97%ae%e9%a2%98" aria-label="Heading self-link">&lt;/a>&lt;/h3>
&lt;ul>
&lt;li>如果你认为用数据库来存储 token 会导致查询时间太长，可以选择放在内存当中。比如 redis 很适合你对 token 查询的需求。&lt;/li>
&lt;li>&lt;strong>token 完全由应用管理，所以它可以避开同源策略&lt;/strong>&lt;/li>
&lt;li>&lt;strong>token 可以避免 CSRF 攻击(因为不需要 cookie 了)&lt;/strong>&lt;/li>
&lt;li>&lt;strong>移动端对 cookie 的支持不是很好，而 session 需要基于 cookie 实现，所以移动端常用的是 token&lt;/strong>&lt;/li>
&lt;/ul>
&lt;h3 id="使用-jwt-时需要考虑的问题">使用 JWT 时需要考虑的问题&lt;a class="td-heading-self-link" href="#%e4%bd%bf%e7%94%a8-jwt-%e6%97%b6%e9%9c%80%e8%a6%81%e8%80%83%e8%99%91%e7%9a%84%e9%97%ae%e9%a2%98" aria-label="Heading self-link">&lt;/a>&lt;/h3>
&lt;ul>
&lt;li>因为 JWT 并不依赖 Cookie 的，所以你可以使用任何域名提供你的 API 服务而不需要担心跨域资源共享问题（CORS）&lt;/li>
&lt;li>JWT 默认是不加密，但也是可以加密的。生成原始 Token 以后，可以用密钥再加密一次。&lt;/li>
&lt;li>JWT 不加密的情况下，不能将秘密数据写入 JWT。&lt;/li>
&lt;li>JWT 不仅可以用于认证，也可以用于交换信息。有效使用 JWT，可以降低服务器查询数据库的次数。&lt;/li>
&lt;li>JWT 最大的优势是服务器不再需要存储 Session，使得服务器认证鉴权业务可以方便扩展。但这也是 JWT 最大的缺点：由于服务器不需要存储 Session 状态，因此使用过程中无法废弃某个 Token 或者更改 Token 的权限。也就是说一旦 JWT 签发了，到期之前就会始终有效，除非服务器部署额外的逻辑。&lt;/li>
&lt;li>JWT 本身包含了认证信息，一旦泄露，任何人都可以获得该令牌的所有权限。为了减少盗用，JWT 的有效期应该设置得比较短。对于一些比较重要的权限，使用时应该再次对用户进行认证。&lt;/li>
&lt;li>JWT 适合一次性的命令认证，颁发一个有效期极短的 JWT，即使暴露了危险也很小，由于每次操作都会生成新的 JWT，因此也没必要保存 JWT，真正实现无状态。&lt;/li>
&lt;li>为了减少盗用，JWT 不应该使用 HTTP 协议明码传输，要使用 HTTPS 协议传输。&lt;/li>
&lt;/ul>
&lt;h3 id="使用加密算法时需要考虑的问题">使用加密算法时需要考虑的问题&lt;a class="td-heading-self-link" href="#%e4%bd%bf%e7%94%a8%e5%8a%a0%e5%af%86%e7%ae%97%e6%b3%95%e6%97%b6%e9%9c%80%e8%a6%81%e8%80%83%e8%99%91%e7%9a%84%e9%97%ae%e9%a2%98" aria-label="Heading self-link">&lt;/a>&lt;/h3>
&lt;ul>
&lt;li>绝不要以&lt;strong>明文存储&lt;/strong>密码&lt;/li>
&lt;li>&lt;strong>永远使用 哈希算法 来处理密码，绝不要使用 Base64 或其他编码方式来存储密码，这和以明文存储密码是一样的，使用哈希，而不要使用编码&lt;/strong>。编码以及加密，都是双向的过程，而密码是保密的，应该只被它的所有者知道， 这个过程必须是单向的。哈希正是用于做这个的，从来没有解哈希这种说法， 但是编码就存在解码，加密就存在解密。&lt;/li>
&lt;li>绝不要使用弱哈希或已被破解的哈希算法，像 MD5 或 SHA1 ，只使用强密码哈希算法。&lt;/li>
&lt;li>绝不要以明文形式显示或发送密码，即使是对密码的所有者也应该这样。如果你需要 “忘记密码” 的功能，可以随机生成一个新的 &lt;strong>一次性的&lt;/strong>（这点很重要）密码，然后把这个密码发送给用户。&lt;/li>
&lt;/ul>
&lt;h3 id="分布式架构下-session-共享方案">分布式架构下 session 共享方案&lt;a class="td-heading-self-link" href="#%e5%88%86%e5%b8%83%e5%bc%8f%e6%9e%b6%e6%9e%84%e4%b8%8b-session-%e5%85%b1%e4%ba%ab%e6%96%b9%e6%a1%88" aria-label="Heading self-link">&lt;/a>&lt;/h3>
&lt;h4 id="1-session-复制">1. session 复制&lt;a class="td-heading-self-link" href="#1-session-%e5%a4%8d%e5%88%b6" aria-label="Heading self-link">&lt;/a>&lt;/h4>
&lt;ul>
&lt;li>任何一个服务器上的 session 发生改变（增删改），该节点会把这个 session 的所有内容序列化，然后广播给所有其它节点，不管其他服务器需不需要 session ，以此来保证 session 同步&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>优点：&lt;/strong> 可容错，各个服务器间 session 能够实时响应。
&lt;strong>缺点：&lt;/strong> 会对网络负荷造成一定压力，如果 session 量大的话可能会造成网络堵塞，拖慢服务器性能。&lt;/p>
&lt;h4 id="2-粘性-session-ip-绑定策略">2. 粘性 session /IP 绑定策略&lt;a class="td-heading-self-link" href="#2-%e7%b2%98%e6%80%a7-session-ip-%e7%bb%91%e5%ae%9a%e7%ad%96%e7%95%a5" aria-label="Heading self-link">&lt;/a>&lt;/h4>
&lt;ul>
&lt;li>&lt;strong>采用 Ngnix 中的 ip_hash 机制，将某个 ip 的所有请求都定向到同一台服务器上，即将用户与服务器绑定。&lt;/strong> 用户第一次请求时，负载均衡器将用户的请求转发到了 A 服务器上，如果负载均衡器设置了粘性 session 的话，那么用户以后的每次请求都会转发到 A 服务器上，相当于把用户和 A 服务器粘到了一块，这就是粘性 session 机制。&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>优点：&lt;/strong> 简单，不需要对 session 做任何处理。
&lt;strong>缺点：&lt;/strong> 缺乏容错性，如果当前访问的服务器发生故障，用户被转移到第二个服务器上时，他的 session 信息都将失效。
&lt;strong>适用场景：&lt;/strong> 发生故障对客户产生的影响较小；服务器发生故障是低概率事件 。
&lt;strong>实现方式：&lt;/strong> 以 Nginx 为例，在 upstream 模块配置 ip_hash 属性即可实现粘性 session。&lt;/p>
&lt;h4 id="3-session-共享常用">3. session 共享（常用）&lt;a class="td-heading-self-link" href="#3-session-%e5%85%b1%e4%ba%ab%e5%b8%b8%e7%94%a8" aria-label="Heading self-link">&lt;/a>&lt;/h4>
&lt;ul>
&lt;li>使用分布式缓存方案比如 Memcached 、Redis 来缓存 session，但是要求 Memcached 或 Redis 必须是集群&lt;/li>
&lt;li>把 session 放到 Redis 中存储，虽然架构上变得复杂，并且需要多访问一次 Redis ，但是这种方案带来的好处也是很大的：
&lt;ul>
&lt;li>实现了 session 共享；&lt;/li>
&lt;li>可以水平扩展（增加 Redis 服务器）；&lt;/li>
&lt;li>服务器重启 session 不丢失（不过也要注意 session 在 Redis 中的刷新/失效机制）；&lt;/li>
&lt;li>不仅可以跨服务器 session 共享，甚至可以跨平台（例如网页端和 APP 端）&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/rv7ih5/1623681275027-55a77f32-68e2-4a4e-9636-10ddd23989f8.webp" alt="">&lt;/p>
&lt;h4 id="4-session-持久化">4. session 持久化&lt;a class="td-heading-self-link" href="#4-session-%e6%8c%81%e4%b9%85%e5%8c%96" aria-label="Heading self-link">&lt;/a>&lt;/h4>
&lt;ul>
&lt;li>将 session 存储到数据库中，保证 session 的持久化&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>优点：&lt;/strong> 服务器出现问题，session 不会丢失
&lt;strong>缺点：&lt;/strong> 如果网站的访问量很大，把 session 存储到数据库中，会对数据库造成很大压力，还需要增加额外的开销维护数据库。&lt;/p>
&lt;h3 id="只要关闭浏览器-session-真的就消失了">&lt;strong>只要关闭浏览器 ，session 真的就消失了？&lt;/strong>&lt;a class="td-heading-self-link" href="#%e5%8f%aa%e8%a6%81%e5%85%b3%e9%97%ad%e6%b5%8f%e8%a7%88%e5%99%a8-session-%e7%9c%9f%e7%9a%84%e5%b0%b1%e6%b6%88%e5%a4%b1%e4%ba%86" aria-label="Heading self-link">&lt;/a>&lt;/h3>
&lt;p>不对。对 session 来说，除非程序通知服务器删除一个 session，否则服务器会一直保留，程序一般都是在用户做 log off 的时候发个指令去删除 session。&lt;/p>
&lt;p>然而浏览器从来不会主动在关闭之前通知服务器它将要关闭，因此服务器根本不会有机会知道浏览器已经关闭，之所以会有这种错觉，是大部分 session 机制都使用会话 cookie 来保存 session id，而关闭浏览器后这个 session id 就消失了，再次连接服务器时也就无法找到原来的 session。如果服务器设置的 cookie 被保存在硬盘上，或者使用某种手段改写浏览器发出的 HTTP 请求头，把原来的 session id 发送给服务器，则再次打开浏览器仍然能够打开原来的 session。&lt;/p>
&lt;p>恰恰是&lt;strong>由于关闭浏览器不会导致 session 被删除，迫使服务器为 session 设置了一个失效时间，当距离客户端上一次使用 session 的时间超过这个失效时间时，服务器就认为客户端已经停止了活动，才会把 session 删除以节省存储空间。&lt;/strong>&lt;/p>
&lt;h2 id="项目地址">项目地址&lt;a class="td-heading-self-link" href="#%e9%a1%b9%e7%9b%ae%e5%9c%b0%e5%9d%80" aria-label="Heading self-link">&lt;/a>&lt;/h2>
&lt;p>&lt;a href="https://github.com/yjdjiayou/jwt-demo">&lt;strong>在项目中使用 JWT&lt;/strong>&lt;/a>&lt;/p>
&lt;h2 id="后语">后语&lt;a class="td-heading-self-link" href="#%e5%90%8e%e8%af%ad" aria-label="Heading self-link">&lt;/a>&lt;/h2>
&lt;ul>
&lt;li>本文只是基于自己的理解讲了理论知识，因为对后端/算法知识不是很熟，如有谬误，还请告知，万分感谢&lt;/li>
&lt;li>如果本文对你有所帮助，还请点个赞~~&lt;/li>
&lt;/ul>
&lt;h2 id="参考">参考&lt;a class="td-heading-self-link" href="#%e5%8f%82%e8%80%83" aria-label="Heading self-link">&lt;/a>&lt;/h2>
&lt;p>&lt;a href="https://baike.baidu.com/item/cookie/1119?fr=aladdin">&lt;strong>百度百科-cookie&lt;/strong>&lt;/a>
&lt;a href="https://baike.baidu.com/item/session/479100?fr=aladdin#3">&lt;strong>百度百科-session&lt;/strong>&lt;/a>
&lt;a href="https://juejin.im/post/6844903864810864647">&lt;strong>详解 Cookie，Session，Token&lt;/strong>&lt;/a>
&lt;a href="https://juejin.im/post/6844904009061367821#heading-0">&lt;strong>一文彻底搞懂 Cookie、Session、Token 到底是什么&lt;/strong>&lt;/a>
&lt;strong>&lt;a href="https://www.cnblogs.com/lyzg/p/6067766.html">3 种 web 会话管理的方式&lt;/a>！！！&lt;/strong>
&lt;strong>&lt;a href="https://www.cnblogs.com/JamesWang1993/p/8593494.html">Token ，Cookie 和 Session 的区别&lt;/a>！！！&lt;/strong>
&lt;strong>&lt;a href="https://www.cnblogs.com/moyand/p/9047978.html">彻底理解 cookie、session、token&lt;/a>！！！&lt;/strong>
&lt;a href="https://juejin.im/post/6844903781704941576">&lt;strong>前端鉴权&lt;/strong>&lt;/a>
&lt;a href="https://zh.wikipedia.org/wiki/SHA-1">&lt;strong>SHA-1&lt;/strong>&lt;/a>
&lt;a href="https://zh.wikipedia.org/wiki/SHA-2">&lt;strong>SHA-2&lt;/strong>&lt;/a>
&lt;a href="https://zh.wikipedia.org/wiki/SHA-3">&lt;strong>SHA-3&lt;/strong>&lt;/a>
&lt;a href="https://blog.csdn.net/zhezhebie/article/details/71631077">&lt;strong>不要再使用 MD5 和 SHA1 加密密码了！&lt;/strong>&lt;/a>
&lt;a href="https://www.liaoxuefeng.com/wiki/1022910821149312/1023025778520640">&lt;strong>廖雪峰 Node 教程之 crypto&lt;/strong>&lt;/a>&lt;/p></description></item><item><title>Docs: Cookie AND Session</title><link>https://desistdaydream.github.io/docs/4.%E6%95%B0%E6%8D%AE%E9%80%9A%E4%BF%A1/%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/HTTP/HTTP-%E4%BC%9A%E8%AF%9D%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86/Cookie-AND-Session/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/4.%E6%95%B0%E6%8D%AE%E9%80%9A%E4%BF%A1/%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/HTTP/HTTP-%E4%BC%9A%E8%AF%9D%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86/Cookie-AND-Session/</guid><description>
&lt;h1 id="概述">概述&lt;a class="td-heading-self-link" href="#%e6%a6%82%e8%bf%b0" aria-label="Heading self-link">&lt;/a>&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Cookies">MDN，参考-HTTP-使用 HTTP cookies&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;h1 id="cookie">Cookie&lt;a class="td-heading-self-link" href="#cookie" aria-label="Heading self-link">&lt;/a>&lt;/h1>
&lt;p>HTTP Cookie（也叫 Web Cookie 或浏览器 Cookie）是服务器发送到用户浏览器并保存在本地的一小块数据。浏览器会存储 cookie 并在下次向同一服务器再发起请求时携带并发送到服务器上。通常，它用于告知服务端两个请求是否来自同一浏览器——如保持用户的登录状态。Cookie 使基于&lt;a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Overview#http_%E6%98%AF%E6%97%A0%E7%8A%B6%E6%80%81%EF%BC%8C%E6%9C%89%E4%BC%9A%E8%AF%9D%E7%9A%84">无状态&lt;/a>的 HTTP 协议记录稳定的状态信息成为了可能。&lt;/p>
&lt;p>背景&lt;/p>
&lt;ul>
&lt;li>HTTP 是无状态协议，服务器不能记录浏览器的访问状态，也就是说服务器不能区分两次请求是否由同一个客户端发出&lt;/li>
&lt;li>&lt;strong>Cookie(小甜饼)&lt;/strong> 就是解决 HTTP 协议无状态的方案之一&lt;/li>
&lt;li>Cookie 实际上就是服务器保存再浏览器上的一段信息。浏览器有了 Cookie 之后，每次向服务器发送请求时都会同时将该信息发送给服务器，服务器收到请求后，就可以根据该信息处理请求&lt;/li>
&lt;li>Cookie 由服务器创建，并发送给浏览器，最终由浏览器保存&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/qpvk57/1616161168269-5454b393-dbe3-4518-a3e0-480ab5358176.png" alt="">&lt;/p>
&lt;p>Cookie 的用途&lt;/p>
&lt;ul>
&lt;li>保持用户登陆状态，由于不够安全，有其他方式替代，比如 JWT 等。&lt;/li>
&lt;li>京东未登录的状态下，使用 Cookie 存储购物车中的物品的&lt;/li>
&lt;/ul>
&lt;blockquote>
&lt;p>淘宝不是这么实现的，淘宝必须登录才能浏览详细商品&lt;/p>
&lt;/blockquote>
&lt;ul>
&lt;li>上一次连接时打开的页面&lt;/li>
&lt;li>与某个账号关联&lt;/li>
&lt;li>等等&lt;/li>
&lt;/ul>
&lt;h2 id="cookie-的属性">Cookie 的属性&lt;a class="td-heading-self-link" href="#cookie-%e7%9a%84%e5%b1%9e%e6%80%a7" aria-label="Heading self-link">&lt;/a>&lt;/h2>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/qpvk57/1623676019731-6e1d1e07-4c5a-4d22-a396-32d3e541c07f.png" alt="image.png">&lt;/p>
&lt;p>一个 cookie 将会具有如下字段：&lt;/p>
&lt;ul>
&lt;li>&lt;strong>name&lt;/strong> # cookie 的名称&lt;/li>
&lt;li>&lt;strong>value&lt;/strong># cookie 的值&lt;/li>
&lt;li>&lt;strong>domain&lt;/strong> # 可以访问此 cookie 的域名&lt;/li>
&lt;li>&lt;strong>path&lt;/strong># 可以访问此 cookie 的页面路径。比如 domain 是 desistdaydream.ltd，path 是 /cookie，那么只有访问 &lt;a href="http://desistdaydream.ltd/cookie">http://desistdaydream.ltd/cookie&lt;/a> 路径下的页面时，才可以读取此 cookie&lt;/li>
&lt;li>&lt;strong>MaxAge&lt;/strong>或 &lt;strong>Expires&lt;/strong> # 设置 cookie 持久化时的过期时长
&lt;ul>
&lt;li>注意：Expires 是老式的过期方法， 如果可以，应该使用 MaxAge 设置过期时间，但有些老版本的浏览器不支持 MaxAge。 如果要支持所有浏览器，要么使用 Expires，要么同时使用 MaxAge 和 Expires。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>size&lt;/strong> # cookie 的大小&lt;/li>
&lt;li>&lt;strong>httpOnly&lt;/strong> # 是否允许别人通过 js 获取自己的 cookie
&lt;ul>
&lt;li>httpOnly 属性限制了 cookie 对 HTTP 请求的作用范围。特别的，该属性指示用户代理忽略那些通过&amp;quot;非 HTTP&amp;quot; 方式对 cookie 的访问（比如浏览器暴露给 js 的接口）。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>secure&lt;/strong> # 是否只能通过 https 访问&lt;/li>
&lt;/ul>
&lt;p>注意：&lt;/p>
&lt;ul>
&lt;li>HttpOnly 属性和 Secure 属性相互独立：一个 cookie 既可以是 HttpOnly 的也可以有 Secure 属性。 在前段时间的项目中我就用 js 去读取一个 cookie，结果怎么都取不到这个值，最后查证这个 cookie 是 httpOnly 的，花了近 2 个小时，悲剧了。&lt;/li>
&lt;/ul>
&lt;p>Cookie 的缺点&lt;/p>
&lt;ul>
&lt;li>不安全，明文&lt;/li>
&lt;li>增加带宽消耗&lt;/li>
&lt;li>可以在客户端手动禁用&lt;/li>
&lt;li>Cookie 是有上限的，最大 4096 字节&lt;/li>
&lt;/ul>
&lt;h1 id="session">Session&lt;a class="td-heading-self-link" href="#session" aria-label="Heading self-link">&lt;/a>&lt;/h1>
&lt;p>背景&lt;/p>
&lt;p>Cookie 虽然在一定程度上解决了 &amp;ldquo;保持状态&amp;rdquo; 的需求，但是由于 Cookie 本身最大支持 4096 字节，以及 Cookie 本身保存在客户端，可能被拦截或窃取，因此就需要有一种新的东西，它能支持更多的字节，并且他保存在服务器，有较高的安全性，这，就是 &lt;strong>Session(会话)&lt;/strong>。&lt;/p>
&lt;p>但是这时，问题又来了，基于 HTTP 协议的无状态特征，服务器根本不知道访问者是谁。又如何保存呢？此时，Cookie 又来了，起到了一个桥接的作用。&lt;/p>
&lt;p>用户登录成功之后，我们在服务端为每个用户创建一个特定的 &lt;strong>SessionData&lt;/strong>和 &lt;strong>SessionID&lt;/strong>，他们一一对应。其中：&lt;/p>
&lt;ul>
&lt;li>SessionData 是在服务端保存的一个数据结构，用来跟踪用户的状态，这个数据可以保存在集群、数据库、文件中
&lt;ul>
&lt;li>这个 SessionData 的数据结构一般都是 KEY/VALUE 类型的结构，相当于一个 **大 map。**可以保存在内存中、关系型数据库、Rdis、文件、等等地方&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>SessionID 作为唯一标识符，通常会写入到用户的 Cookie 中。&lt;/li>
&lt;/ul>
&lt;p>所以，&lt;strong>Session 必须依赖于 Cookie 才能使用&lt;/strong>，生成一个 SessionID 放在 Cookie 里传给客户端即可。&lt;/p>
&lt;p>在互联网早期，访问一个网站为了持久化，将用户名和密码放在 cookie 里，一条信息就对应一条 cookie。&lt;/p>
&lt;p>比如访问 baidu.com 后，浏览器记录了这么几个 cookie：&lt;/p>
&lt;ul>
&lt;li>username: DesistDaydream&lt;/li>
&lt;li>password: mypassword&lt;/li>
&lt;li>XXX: XXXX&lt;/li>
&lt;li>YYY: YYY&lt;/li>
&lt;li>&amp;hellip;..等等&lt;/li>
&lt;/ul>
&lt;p>而使用了 Session 之后，Cookie 不再记录这些敏感信息，只保存一个 ID 用来标识这个 Session：&lt;/p>
&lt;ul>
&lt;li>sessionID: DesistDaydream&lt;/li>
&lt;/ul>
&lt;p>剩下的信息一般都保存在服务器本地，根据 sessionID 找到对应信息即可&lt;/p>
&lt;p>Session 逻辑&lt;/p>
&lt;p>这是一个简单的 Session 处理请求的逻辑&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/qpvk57/1616161168291-de47fffb-605b-41a5-ae65-aa3004c78762.png" alt="">&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/qpvk57/1616161168320-400fd569-42fc-41ba-a439-6556a456a72e.png" alt="">&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/qpvk57/1616161168293-4d7ef534-5772-4f15-8eaf-ccf0aa43f1db.png" alt="">&lt;/p>
&lt;h2 id="session-设计思路">Session 设计思路&lt;a class="td-heading-self-link" href="#session-%e8%ae%be%e8%ae%a1%e6%80%9d%e8%b7%af" aria-label="Heading self-link">&lt;/a>&lt;/h2>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/qpvk57/1616161168286-70f4c25f-49bd-4b84-8b50-f0bca0900dd1.png" alt="">&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/qpvk57/1616161168270-49a7f14e-1cf0-4e50-8ddc-3cc8d9537544.png" alt="">&lt;/p>
&lt;p>Session 本质上是一个 K/V ，通过 key 进行增删改查。可以存储在 RAM 或者 Redis 中。&lt;/p>
&lt;ul>
&lt;li>一般有多个 Session，所以需要一个管理器统一管理&lt;/li>
&lt;li>Session 一般作为中间件，所以需要暴露结构给其他代码使用&lt;/li>
&lt;/ul>
&lt;p>Session 接口设计&lt;/p>
&lt;ul>
&lt;li>Set()&lt;/li>
&lt;li>Get()&lt;/li>
&lt;li>Del()&lt;/li>
&lt;li>Save() # 持久存储&lt;/li>
&lt;/ul>
&lt;p>SessionMgr 接口设计&lt;/p>
&lt;ul>
&lt;li>Init() # 初始化，加载 RAM 或 Redis&lt;/li>
&lt;li>CreateSession() # 创建一个新的 Session&lt;/li>
&lt;li>GetSession() # 通过 SessionID 获取对应的 Session 对象&lt;/li>
&lt;/ul>
&lt;p>RAM Session 设计&lt;/p>
&lt;ul>
&lt;li>
&lt;p>定义 RAM Session 对象&lt;/p>
&lt;ul>
&lt;li>SessionID&lt;/li>
&lt;li>存 K/V 的 map&lt;/li>
&lt;li>读写锁&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>构造函数，为了获取对象&lt;/p>
&lt;ul>
&lt;li>Set()&lt;/li>
&lt;li>Get()&lt;/li>
&lt;li>Del()&lt;/li>
&lt;li>Save()&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>RAM SessionMgr 设计&lt;/p>
&lt;ul>
&lt;li>定义 Memory SessionMgr 对象
&lt;ul>
&lt;li>存放所有 Session 的 map&lt;/li>
&lt;li>读写锁&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>构造函数
&lt;ul>
&lt;li>Init()&lt;/li>
&lt;li>CreateSession()&lt;/li>
&lt;li>GetSession()&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>Redis Session 设计&lt;/p>
&lt;ul>
&lt;li>定义 RedisSession 对象
&lt;ul>
&lt;li>SessionID&lt;/li>
&lt;li>存 K/V 的 map&lt;/li>
&lt;li>读写锁&lt;/li>
&lt;li>Redis 连接池&lt;/li>
&lt;li>记录内存中 map 是否被修改的编辑&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>构造函数
&lt;ul>
&lt;li>Set()&lt;/li>
&lt;li>Get()&lt;/li>
&lt;li>Del()&lt;/li>
&lt;li>Save()&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>Redis SessionMgr 设计&lt;/p>
&lt;ul>
&lt;li>定义 Redis SessionMgr 对象
&lt;ul>
&lt;li>Redis 地址、密码、连接池、读写锁&lt;/li>
&lt;li>存放所有 Session 的 map&lt;/li>
&lt;li>读写锁&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>构造函数
&lt;ul>
&lt;li>Init()&lt;/li>
&lt;li>CreateSession()&lt;/li>
&lt;li>GetSession()&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul></description></item><item><title>Docs: Token 与 JWT</title><link>https://desistdaydream.github.io/docs/4.%E6%95%B0%E6%8D%AE%E9%80%9A%E4%BF%A1/%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/HTTP/HTTP-%E4%BC%9A%E8%AF%9D%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86/Token-%E4%B8%8E-JWT/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/4.%E6%95%B0%E6%8D%AE%E9%80%9A%E4%BF%A1/%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/HTTP/HTTP-%E4%BC%9A%E8%AF%9D%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86/Token-%E4%B8%8E-JWT/</guid><description>
&lt;h1 id="概述">概述&lt;a class="td-heading-self-link" href="#%e6%a6%82%e8%bf%b0" aria-label="Heading self-link">&lt;/a>&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://jwt.io/">JWT 官网&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://datatracker.ietf.org/doc/html/rfc7519">RFC 7519&lt;/a>&lt;/li>
&lt;li>&lt;a href="http://www.ruanyifeng.com/blog/2018/07/json_web_token-tutorial.html">阮一峰，JSON Web Token 入门教程&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;h1 id="jwt">JWT&lt;a class="td-heading-self-link" href="#jwt" aria-label="Heading self-link">&lt;/a>&lt;/h1>
&lt;p>&lt;strong>JSON Web Token(简称 JWT)&lt;/strong> 是目前最流行的跨域认证解决方案。JWT 是一个开放标准(&lt;a href="https://tools.ietf.org/html/rfc7519">RFC 7519&lt;/a>)，定义了一种紧凑且子包含的方式，用于在各方之间以 JSON 对象的形式安全地传输信息。该信息可以被验证和信任，因为它是经过数字签名的。可以通过 RSA 或 ECDSA 这种公钥/私钥对进行签名、也可以使用 HMAC 进行签名。&lt;/p>
&lt;h2 id="背景">背景&lt;a class="td-heading-self-link" href="#%e8%83%8c%e6%99%af" aria-label="Heading self-link">&lt;/a>&lt;/h2>
&lt;h3 id="跨域认证的问题">跨域认证的问题&lt;a class="td-heading-self-link" href="#%e8%b7%a8%e5%9f%9f%e8%ae%a4%e8%af%81%e7%9a%84%e9%97%ae%e9%a2%98" aria-label="Heading self-link">&lt;/a>&lt;/h3>
&lt;p>互联网服务离不开用户认证。一般流程是下面这样。&lt;/p>
&lt;ol>
&lt;li>用户向服务器发送用户名和密码。&lt;/li>
&lt;li>服务器验证通过后，在当前对话（session）里面保存相关数据，比如用户角色、登录时间等等。&lt;/li>
&lt;li>服务器向用户返回一个 session_id，写入用户的 Cookie。&lt;/li>
&lt;li>用户随后的每一次请求，都会通过 Cookie，将 session_id 传回服务器。&lt;/li>
&lt;li>服务器收到 session_id，找到前期保存的数据，由此得知用户的身份。&lt;/li>
&lt;/ol>
&lt;p>这种模式的问题在于，扩展性（scaling）不好。单机当然没有问题，如果是服务器集群，或者是跨域的服务导向架构，就要求 session 数据共享，每台服务器都能够读取 session。&lt;/p>
&lt;p>举例来说，A 网站和 B 网站是同一家公司的关联服务。现在要求，用户只要在其中一个网站登录，再访问另一个网站就会自动登录，请问怎么实现？&lt;/p>
&lt;p>一种解决方案是 session 数据持久化，写入数据库或别的持久层。各种服务收到请求后，都向持久层请求数据。这种方案的优点是架构清晰，缺点是工程量比较大。另外，持久层万一挂了，就会单点失败。&lt;/p>
&lt;p>另一种方案是服务器索性不保存 session 数据了，所有数据都保存在客户端，每次请求都发回服务器。JWT 就是这种方案的一个代表。&lt;/p>
&lt;h2 id="jwt-的原理">JWT 的原理&lt;a class="td-heading-self-link" href="#jwt-%e7%9a%84%e5%8e%9f%e7%90%86" aria-label="Heading self-link">&lt;/a>&lt;/h2>
&lt;p>JWT 的原理是，服务器认证以后，生成一个 JSON 对象，发回给用户，就像下面这样。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-json" data-lang="json">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#000;font-weight:bold">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#204a87;font-weight:bold">&amp;#34;姓名&amp;#34;&lt;/span>&lt;span style="color:#000;font-weight:bold">:&lt;/span> &lt;span style="color:#4e9a06">&amp;#34;张三&amp;#34;&lt;/span>&lt;span style="color:#000;font-weight:bold">,&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#204a87;font-weight:bold">&amp;#34;角色&amp;#34;&lt;/span>&lt;span style="color:#000;font-weight:bold">:&lt;/span> &lt;span style="color:#4e9a06">&amp;#34;管理员&amp;#34;&lt;/span>&lt;span style="color:#000;font-weight:bold">,&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#204a87;font-weight:bold">&amp;#34;到期时间&amp;#34;&lt;/span>&lt;span style="color:#000;font-weight:bold">:&lt;/span> &lt;span style="color:#4e9a06">&amp;#34;2018年7月1日0点0分&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#000;font-weight:bold">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>以后，用户与服务端通信的时候，都要发回这个 JSON 对象。服务器完全只靠这个对象认定用户身份。为了防止用户篡改数据，服务器在生成这个对象的时候，会加上签名（详见后文）。&lt;/p>
&lt;p>服务器就不保存任何 session 数据了，也就是说，服务器变成无状态了，从而比较容易实现扩展。&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/sn00y2/1623744463253-b71ac60f-9871-4aef-8c37-8166947d5b58.webp" alt="">&lt;/p>
&lt;h2 id="jwt-的数据结构">JWT 的数据结构&lt;a class="td-heading-self-link" href="#jwt-%e7%9a%84%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84" aria-label="Heading self-link">&lt;/a>&lt;/h2>
&lt;p>实际的 JWT 大概就像下面这样。&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/sn00y2/1623651349414-4518a10e-dbd4-4461-a4e2-a039518e8355.jpeg" alt="">&lt;/p>
&lt;p>它是一个很长的字符串，中间用点（.）分隔成三个部分。&lt;font color="#ff0000">注意，JWT 内部是没有换行的，这里只是为了便于展示，将它写成了几行。&lt;/font>&lt;/p>
&lt;p>JWT 的三个部分依次如下。&lt;/p>
&lt;ul>
&lt;li>&lt;strong>Header(头部)&lt;/strong> #&lt;/li>
&lt;li>&lt;strong>Payload(负载)&lt;/strong> #&lt;/li>
&lt;li>&lt;strong>Signature(签名)&lt;/strong> #&lt;/li>
&lt;/ul>
&lt;p>写成一行，就是下面的样子。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>Header.Payload.Signature
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/sn00y2/1623651350412-81b31181-9912-4411-a330-00e6e92e791b.jpeg" alt="">&lt;/p>
&lt;h3 id="header">Header&lt;a class="td-heading-self-link" href="#header" aria-label="Heading self-link">&lt;/a>&lt;/h3>
&lt;p>Header 部分是一个 JSON 对象，描述 JWT 的元数据，通常是下面的样子。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-json" data-lang="json">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#000;font-weight:bold">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#204a87;font-weight:bold">&amp;#34;alg&amp;#34;&lt;/span>&lt;span style="color:#000;font-weight:bold">:&lt;/span> &lt;span style="color:#4e9a06">&amp;#34;HS256&amp;#34;&lt;/span>&lt;span style="color:#000;font-weight:bold">,&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#204a87;font-weight:bold">&amp;#34;typ&amp;#34;&lt;/span>&lt;span style="color:#000;font-weight:bold">:&lt;/span> &lt;span style="color:#4e9a06">&amp;#34;JWT&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#000;font-weight:bold">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ul>
&lt;li>alg # 表示签名的算法（algorithm），默认是 HMAC SHA256(写成 HS256)&lt;/li>
&lt;li>typ # 表示这个令牌（token）的类型（type），JWT 令牌统一写为 JWT。&lt;/li>
&lt;/ul>
&lt;p>最后，将上面的 JSON 对象使用 Base64URL 算法（详见后文）转成字符串。&lt;/p>
&lt;h3 id="payload">Payload&lt;a class="td-heading-self-link" href="#payload" aria-label="Heading self-link">&lt;/a>&lt;/h3>
&lt;p>Payload 部分也是一个 JSON 对象，用来存放实际需要传递的数据。Payload 由多个 &lt;strong>Claims(要求)&lt;/strong> 组成。Claims 通常用来描述实体和附加数据，实体通常来说就是一个用户。&lt;/p>
&lt;p>一共有三种类型的 Claims：&lt;/p>
&lt;ul>
&lt;li>&lt;strong>Registered Claims(已注册要求)&lt;/strong>，其实就是 JWT 默认自带的。JWT 规定了 7 个默认的 Claims。
&lt;ul>
&lt;li>&lt;strong>iss(issuer)&lt;/strong> # 签发人。与 x509 证书的 Issuer 概念一样&lt;/li>
&lt;li>&lt;strong>sub(subject)&lt;/strong> # 主体。与 x509 证书的 Subject 概念一样&lt;/li>
&lt;li>&lt;strong>aud(audience)&lt;/strong> # 受众，就是 JWT 的人或程序或某事物&lt;/li>
&lt;li>&lt;strong>exp(expiration time)&lt;/strong> # 过期时间。这个时间必须要大于 &lt;code>iat&lt;/code> 字段指定的时间&lt;/li>
&lt;li>&lt;strong>nbf(Not Before)&lt;/strong> # 生效时间。定义在什么时间之前该 JWT 是不可用的。类似 X.509 中的 &lt;code>Not Before&lt;/code> 字段。&lt;/li>
&lt;li>&lt;strong>iat(Issued At)&lt;/strong> # 签发时间。&lt;/li>
&lt;li>&lt;strong>jti(JWT ID)&lt;/strong> # JWT 的 ID，主要用来作为一次性 Token，从而回避重放攻击&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>Public Claims(公共要求)&lt;/strong>，使用 JWT 时的自定义 Claims。
&lt;ul>
&lt;li>但是给 Public Claims 命名时，要注意不要与 &lt;a href="https://www.iana.org/assignments/jwt/jwt.xhtml">IANA JSON Web Token Registry&lt;/a> 中定义的名称相冲突。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>Private Claims(私有要求)&lt;/strong>，也是一种自定义的 Claims，通常用来共享信息。JWT 的生产者和消费者可以同意使用 Private Claims，而不是其他两种类型的 Claims。&lt;/li>
&lt;/ul>
&lt;p>下面就是一个有效的 Payload 的示例：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-json" data-lang="json">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#000;font-weight:bold">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#204a87;font-weight:bold">&amp;#34;sub&amp;#34;&lt;/span>&lt;span style="color:#000;font-weight:bold">:&lt;/span> &lt;span style="color:#4e9a06">&amp;#34;1234567890&amp;#34;&lt;/span>&lt;span style="color:#000;font-weight:bold">,&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#204a87;font-weight:bold">&amp;#34;name&amp;#34;&lt;/span>&lt;span style="color:#000;font-weight:bold">:&lt;/span> &lt;span style="color:#4e9a06">&amp;#34;John Doe&amp;#34;&lt;/span>&lt;span style="color:#000;font-weight:bold">,&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#204a87;font-weight:bold">&amp;#34;admin&amp;#34;&lt;/span>&lt;span style="color:#000;font-weight:bold">:&lt;/span> &lt;span style="color:#204a87;font-weight:bold">true&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#000;font-weight:bold">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>注意，JWT 默认是不加密的，任何人都可以读到，所以不要把敏感信息放在 JWT 中。&lt;/p>
&lt;p>这个 JSON 对象也要使用 Base64URL 算法转成字符串。&lt;/p>
&lt;h3 id="signature">Signature&lt;a class="td-heading-self-link" href="#signature" aria-label="Heading self-link">&lt;/a>&lt;/h3>
&lt;p>&lt;strong>Signature(签名)&lt;/strong> 是对前 Header 与 Payload 的签名，防止数据篡改。&lt;/p>
&lt;p>首先，需要指定一个 secret(密钥)。这个密钥只有服务器才知道，不能泄露给用户。然后，使用 Header 里面指定的签名算法（默认是 HMAC SHA256），按照下面的公式产生签名。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-text" data-lang="text">&lt;span style="display:flex;">&lt;span>HMACSHA256(
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> base64UrlEncode(HEADER) + &amp;#34;.&amp;#34; +
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> base64UrlEncode(PAYLOAD),
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> secret)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>当我们要解析 JWT 时，也要使用相同 Secret，如果 Secret，则验证签名将会失败，JWT 这个 Token 也就失效了~这就是签名的重要性啦~&lt;/p>
&lt;h3 id="总结">总结&lt;a class="td-heading-self-link" href="#%e6%80%bb%e7%bb%93" aria-label="Heading self-link">&lt;/a>&lt;/h3>
&lt;p>算出 Signature 以后，把 Header、Payload、Signature 三个部分拼成一个字符串，每个部分之间用&amp;quot;点&amp;quot;（.）分隔，这就组成了一个字符串类型的 JWT。&lt;/p>
&lt;p>&lt;strong>Base64URL&lt;/strong>&lt;/p>
&lt;p>前面提到，Header 和 Payload 串型化的算法是 Base64URL。这个算法跟 Base64 算法基本类似，但有一些小的不同。&lt;/p>
&lt;p>JWT 作为一个令牌（token），有些场合可能会放到 URL（比如 api.example.com/?token=xxx）。Base64 有三个字符+、/和=，在 URL 里面有特殊含义，所以要被替换掉：=被省略、+替换成-，/替换成_ 。这就是 Base64URL 算法。&lt;/p>
&lt;h2 id="jwt-的使用方式">JWT 的使用方式&lt;a class="td-heading-self-link" href="#jwt-%e7%9a%84%e4%bd%bf%e7%94%a8%e6%96%b9%e5%bc%8f" aria-label="Heading self-link">&lt;/a>&lt;/h2>
&lt;p>客户端收到服务器返回的 JWT，可以储存在 Cookie 里面，也可以储存在 localStorage。&lt;/p>
&lt;p>此后，客户端每次与服务器通信，都要带上这个 JWT。你可以把它放在 Cookie 里面自动发送，但是这样不能跨域，所以更好的做法是放在 HTTP 请求的头信息 Authorization 字段里面。&lt;/p>
&lt;p>&lt;code>Authorization: Bearer &amp;lt;TOKEN&amp;gt;&lt;/code>&lt;/p>
&lt;p>另一种做法是，跨域的时候，JWT 就放在 POST 请求的数据体里面。&lt;/p>
&lt;h2 id="jwt-的几个特点">JWT 的几个特点&lt;a class="td-heading-self-link" href="#jwt-%e7%9a%84%e5%87%a0%e4%b8%aa%e7%89%b9%e7%82%b9" aria-label="Heading self-link">&lt;/a>&lt;/h2>
&lt;p>（1）JWT 默认是不加密，但也是可以加密的。生成原始 Token 以后，可以用密钥再加密一次。
（2）JWT 不加密的情况下，不能将秘密数据写入 JWT。
（3）JWT 不仅可以用于认证，也可以用于交换信息。有效使用 JWT，可以降低服务器查询数据库的次数。
（4）JWT 的最大缺点是，由于服务器不保存 session 状态，因此无法在使用过程中废止某个 token，或者更改 token 的权限。也就是说，一旦 JWT 签发了，在到期之前就会始终有效，除非服务器部署额外的逻辑。
（5）JWT 本身包含了认证信息，一旦泄露，任何人都可以获得该令牌的所有权限。为了减少盗用，JWT 的有效期应该设置得比较短。对于一些比较重要的权限，使用时应该再次对用户进行认证。
（6）为了减少盗用，JWT 不应该使用 HTTP 协议明码传输，要使用 HTTPS 协议传输。&lt;/p>
&lt;h2 id="参考链接">参考链接&lt;a class="td-heading-self-link" href="#%e5%8f%82%e8%80%83%e9%93%be%e6%8e%a5" aria-label="Heading self-link">&lt;/a>&lt;/h2>
&lt;ul>
&lt;li>&lt;a href="https://jwt.io/introduction/">Introduction to JSON Web Tokens&lt;/a>， by Auth0&lt;/li>
&lt;li>&lt;a href="https://medium.com/@bryanmanuele/sessionless-authentication-withe-jwts-with-node-express-passport-js-69b059e4b22c">Sessionless Authentication using JWTs (with Node + Express + Passport JS)&lt;/a>, by Bryan Manuele&lt;/li>
&lt;li>&lt;a href="https://github.com/dwyl/learn-json-web-tokens/blob/master/README.md">Learn how to use JSON Web Tokens&lt;/a>, by dwyl&lt;/li>
&lt;/ul></description></item></channel></rss>