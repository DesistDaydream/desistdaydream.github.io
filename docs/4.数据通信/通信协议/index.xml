<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>断念梦的站点 – 通信协议</title><link>https://desistdaydream.github.io/docs/4.%E6%95%B0%E6%8D%AE%E9%80%9A%E4%BF%A1/%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/</link><description>Recent content in 通信协议 on 断念梦的站点</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><atom:link href="https://desistdaydream.github.io/docs/4.%E6%95%B0%E6%8D%AE%E9%80%9A%E4%BF%A1/%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/index.xml" rel="self" type="application/rss+xml"/><item><title>Docs: 通信协议</title><link>https://desistdaydream.github.io/docs/4.%E6%95%B0%E6%8D%AE%E9%80%9A%E4%BF%A1/%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/4.%E6%95%B0%E6%8D%AE%E9%80%9A%E4%BF%A1/%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/</guid><description>
&lt;h1 id="概述">概述&lt;a class="td-heading-self-link" href="#%e6%a6%82%e8%bf%b0" aria-label="Heading self-link">&lt;/a>&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Communication_protocol">Wiki，Communication Protocol&lt;/a>(通信协议)&lt;/li>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Encapsulation_(networking)">Wiki，Encapsulation&lt;/a>(封装)&lt;/li>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Protocol_data_unit">Wiki，PDU&lt;/a>
&lt;ul>
&lt;li>注：Wiki 中将网络层 PDU 描述为 Packet 不够准确，详见 RFC 1325&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Service_data_unit">Wiki，SDU&lt;/a>&lt;/li>
&lt;li>RFC，&lt;a href="https://datatracker.ietf.org/doc/html/rfc1325">1325&lt;/a>、&lt;a href="https://datatracker.ietf.org/doc/html/rfc1594">1594&lt;/a>、&lt;a href="https://datatracker.ietf.org/doc/html/rfc2664">2664&lt;/a>
&lt;ul>
&lt;li>这几个 RFC 是一些关于互联网的仅供参考的常见问答，里面包含一些名词解释，2664 是最新版&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;h1 id="网络系统的分层架构">网络系统的分层架构&lt;a class="td-heading-self-link" href="#%e7%bd%91%e7%bb%9c%e7%b3%bb%e7%bb%9f%e7%9a%84%e5%88%86%e5%b1%82%e6%9e%b6%e6%9e%84" aria-label="Heading self-link">&lt;/a>&lt;/h1>
&lt;p>因特网是一个极为复杂的系统，这个系统有许多部分：大量的应用程序和协议、各种类型的端系统、分组交换机和各种类型的链路级媒体 等等等等。面对这种巨大的复杂性，我们迫切得需要组织整个网络体系结构。&lt;/p>
&lt;p>网络设计者以 &lt;strong>Layer(分层)&lt;/strong> 的方式组织协议以及实现这些协议的硬件/软件。每个协议属于这些层次之一，各层的所有协议被统称为 &lt;strong>Protocol Stack(协议栈)&lt;/strong>。&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/bdmhzx/1628914014057-a14c5659-364a-4bfb-ad46-0dbec7375997.png" alt="image.png|800">&lt;/p>
&lt;h1 id="encapsulation封装">Encapsulation(封装)&lt;a class="td-heading-self-link" href="#encapsulation%e5%b0%81%e8%a3%85" aria-label="Heading self-link">&lt;/a>&lt;/h1>
&lt;p>&lt;strong>Encapsulation(封装)&lt;/strong> 是一种设计模块化通信协议的方法，是将上层数据经过处理，变为下层数据的过程。处理完成后的实体称为 &lt;strong>Protocol Data Unit(协议数据单元，简称 PDU)&lt;/strong> 或 &lt;strong>Service Data Unit(服务数据单元，简称 SDU)&lt;/strong>。&lt;/p>
&lt;blockquote>
&lt;p>PDU 与 SDU 通常来说可以一起理解，楞要说区别，可有有以下几点&lt;/p>
&lt;ul>
&lt;li>SDU 并不会跨主机，可以说，比如说同一个主机应用层往传输层发送的内容。而 PDU 则是两个不同主机，由 A 主机应用层发送到 B 主机应用层的内容。&lt;/li>
&lt;li>SDU 是 PDU 的一个子集&lt;/li>
&lt;li>SDU 是 PDU 中的一个 Payload(有效载荷)&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>比如，主机 A 要向主机 B 发送一条信息。这条信息就称为 &lt;strong>Data(数据)/Payload(有效载荷)&lt;/strong>。这条消息从主机 A 发送出去之前，会被各种协议进行处理，这个处理的过程，就是 Encapsulation(封装)，封装之后的产物就是 PDU，不同网络层的 PDU 叫法不同：&lt;/p>
&lt;ul>
&lt;li>&lt;strong>Message(报文)&lt;/strong> # 应用层的协议封装的 PDU
&lt;ul>
&lt;li>比如 HTTP Message(HTTP 报文)&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>Segment(段)&lt;/strong> # 传输层的协议封装的 PDU
&lt;ul>
&lt;li>比如 TCP Segment(TCP 段)。为什么称为 Segment(段) 呢，可以想象，从应用层接收到的数据通常会大于 MSS(1460 Bytes)，只要大于 MSS 的数据，都会被分为一段一段的，逐一发送。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>Datagram(数据报)&lt;/strong> # 网络层的协议封装的 PDU
&lt;ul>
&lt;li>比如 IP Datagram(IP 数据报)。当 IP Datagram 的大小超过 MTU 时，将会被 &lt;strong>Fragment(分片(动词))&lt;/strong>，被拆分的每一个部分称为 &lt;strong>Fragment(片(名词))&lt;/strong>
&lt;ul>
&lt;li>每一个 Framment 在很多场景和日常交流中，也被称为 &lt;strong>Packet(包)&lt;/strong>，所以很多文档也将网络层协议封装的 PDU 称为 Packet&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>Frame(帧)&lt;/strong> # 链路层的协议封装的 PDU&lt;/li>
&lt;li>&lt;strong>bit(比特)&lt;/strong> # 物理层的协议封装的 PDU&lt;/li>
&lt;/ul>
&lt;p>随着发展，名词 &lt;strong>Packet(包)&lt;/strong> 具有更广泛的意义，甚至，可以把 Packet 当做 PDU 来看。这个术语使用松散，虽然某些互联网文献使用它来专门指，通过物理网络发送的数据，但很多其他文献将互联网视为分组交换网络，并将 IP Datagram 描述为 Packet(这一段描述可以在 &lt;a href="https://datatracker.ietf.org/doc/html/rfc1325#page-30">RFC1325-术语&lt;/a>中找到)。&lt;/p>
&lt;p>其实，Message、Segment，Datagram，Packet，Frame 是存在于同条记录中的，是基于所在协议层不同而取了不同的名字。我们可以用一个形象的例子对数据包的概念加以说明：我们在邮局邮寄产品时，虽然产品本身带有自己的包装盒，但是在邮寄的时候只用产品原包装盒来包装显然是不行的。必须把内装产品的包装盒放到一个邮局指定的专用纸箱里，这样才能够邮寄。这里，产品包装盒相当于数据包，里面放着的产品相当于可用的数据，而专用纸箱就相当于帧，且一个帧中通常只有一个数据包。&lt;/p>
&lt;h2 id="封装内的字段结构">封装内的字段结构&lt;a class="td-heading-self-link" href="#%e5%b0%81%e8%a3%85%e5%86%85%e7%9a%84%e5%ad%97%e6%ae%b5%e7%bb%93%e6%9e%84" aria-label="Heading self-link">&lt;/a>&lt;/h2>
&lt;p>一个完整的 PDU 由两个字段组成&lt;/p>
&lt;ul>
&lt;li>&lt;strong>Header(首部)&lt;/strong> # 用来定义数据要传输的目标
&lt;ul>
&lt;li>不同协议的首部信息各不相同。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>Payload(有效载荷)&lt;/strong> # 需要传输的数据
&lt;ul>
&lt;li>可以表示为最原本的数据，从下层协议来看，也可以把上层协议封装而成的 SDU 当做 Payload。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>通过抓包工具，抓出来的包，在 Wireshark 上查看，就可以看到各种协议封装后，PDU 中的信息。这里以一个 HTTP 的响应包为例&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/bdmhzx/1629077712291-6d02d74d-54f4-494b-9b6f-1a850d99005e.png" alt="image.png">
可以看到每一层的封装信息，我们现在展开传输层，可以看到如下内容
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/bdmhzx/1629077829616-4487b427-08b0-4799-8d16-37e6e3717286.png" alt="image.png">&lt;/p>
&lt;p>如果展开网络层，则可以看到如下内容：&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/bdmhzx/1629078088587-4b67122f-443c-4e5e-a08b-41f438267ffb.png" alt="image.png">&lt;/p>
&lt;p>这里就是 IP Datagram 首部的所有信息&lt;/p>
&lt;p>在 各个协议的详解中，可以看到各种首部的所有信息，与抓包显示出来的都是可以一一对上的。&lt;/p>
&lt;h1 id="协议">协议&lt;a class="td-heading-self-link" href="#%e5%8d%8f%e8%ae%ae" aria-label="Heading self-link">&lt;/a>&lt;/h1>
&lt;h2 id="纯二层协议">纯二层协议&lt;a class="td-heading-self-link" href="#%e7%ba%af%e4%ba%8c%e5%b1%82%e5%8d%8f%e8%ae%ae" aria-label="Heading self-link">&lt;/a>&lt;/h2>
&lt;p>&lt;strong>Point-to-Point Protocol(点对点协议，简称 PPP)&lt;/strong> &lt;a href="https://en.wikipedia.org/wiki/Point-to-Point_Protocol">https://en.wikipedia.org/wiki/Point-to-Point_Protocol&lt;/a>&lt;/p>
&lt;p>&lt;a href="https://desistdaydream.github.io/docs/4.%E6%95%B0%E6%8D%AE%E9%80%9A%E4%BF%A1/%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/ARP%20%E4%B8%8E%20NDP.md">ARP 与 NDP&lt;/a>&lt;/p>
&lt;h2 id="纯三层协议">纯三层协议&lt;a class="td-heading-self-link" href="#%e7%ba%af%e4%b8%89%e5%b1%82%e5%8d%8f%e8%ae%ae" aria-label="Heading self-link">&lt;/a>&lt;/h2>
&lt;p>&lt;a href="https://desistdaydream.github.io/docs/4.%E6%95%B0%E6%8D%AE%E9%80%9A%E4%BF%A1/%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/TCP_IP/IP/IP.md">IP&lt;/a>&lt;/p>
&lt;h2 id="纯四层协议">纯四层协议&lt;a class="td-heading-self-link" href="#%e7%ba%af%e5%9b%9b%e5%b1%82%e5%8d%8f%e8%ae%ae" aria-label="Heading self-link">&lt;/a>&lt;/h2>
&lt;p>&lt;a href="https://desistdaydream.github.io/docs/4.%E6%95%B0%E6%8D%AE%E9%80%9A%E4%BF%A1/%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/TCP_IP/TCP/TCP.md">TCP&lt;/a>&lt;/p>
&lt;h2 id="上层协议">上层协议&lt;a class="td-heading-self-link" href="#%e4%b8%8a%e5%b1%82%e5%8d%8f%e8%ae%ae" aria-label="Heading self-link">&lt;/a>&lt;/h2>
&lt;p>&lt;a href="https://desistdaydream.github.io/docs/4.%E6%95%B0%E6%8D%AE%E9%80%9A%E4%BF%A1/%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/HTTP/HTTP.md">HTTP&lt;/a>&lt;/p>
&lt;p>&lt;strong>Remote Authentication Dial-In User Service(远程用户拨号认证，简称 RADUS)&lt;/strong> 是一种 7 层协议，RADUS 是一种分布式的、客户端/服务器结构的信息交互协议，能保护网络不受未授权访问的干扰，常应用在既要求较高安全性、又允许远程用户访问的各种网络环境中。RADIUS 协议为标准协议，基本所有主流设备均支持，在实际网络中应用最多。RADIUS 使用UDP（User Datagram Protocol，用户数据报协议）作为传输协议，具有良好的实时性；同时也支持重传机制和备用服务器机制，具有较好的可靠性；实现较为简单，适用于大用户量时服务器端的多线程结构。&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://info.support.huawei.com/info-finder/encyclopedia/zh/RADIUS.html">https://info.support.huawei.com/info-finder/encyclopedia/zh/RADIUS.html&lt;/a>&lt;/li>
&lt;/ul></description></item><item><title>Docs: 通信协议通用概念</title><link>https://desistdaydream.github.io/docs/4.%E6%95%B0%E6%8D%AE%E9%80%9A%E4%BF%A1/%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE%E9%80%9A%E7%94%A8%E6%A6%82%E5%BF%B5/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/4.%E6%95%B0%E6%8D%AE%E9%80%9A%E4%BF%A1/%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE%E9%80%9A%E7%94%A8%E6%A6%82%E5%BF%B5/</guid><description>
&lt;h1 id="mtu-与-mss">MTU 与 MSS&lt;a class="td-heading-self-link" href="#mtu-%e4%b8%8e-mss" aria-label="Heading self-link">&lt;/a>&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Maximum_transmission_unit">Wiki，MTU&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Maximum_segment_size">Wiki，MSS&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>&lt;strong>Maximum Transmission Unit(即最大传输单元，简称 MTU)&lt;/strong> 是一个二层的概念；以太网最大的 mtu 就是 1500（它是不包含二层头部的，加上头部应该为 1518 bytes，2bit 的以太网类型+6bit 的 DMAC+6bit 的 SMAC+4bit 的 FCS），每个以太网帧都有最小的大小 64bytes，最大不能超过 1518bytes&lt;/p>
&lt;p>注：&lt;/p>
&lt;ol>
&lt;li>小于 64Bytes 的数据帧一般是由于以太网冲突产生的 “碎片”或者线路干扰或者坏的以太网接口产生的，对于大于 1518Bytes 的数据帧我们一般把它叫做 Giant 帧，这种一般是由于线路干扰或者坏的以太网口产生&lt;/li>
&lt;li>以太网 EthernetII 最大的数据帧是 1518Bytes，是指包含以太网帧的帧头（DMAC 目的 MAC 地址 48bit=6Bytes+SMAC 源 MAC 地址 48bit=6Bytes+Type 域 2bytes）14Bytes 和帧尾 CRC 校验部分 4Bytes （这个部份有时候大家也把它叫做 FCS）&lt;/li>
&lt;/ol>
&lt;p>IP MTU 是一个三层概念，它包含了三层头部及所有载荷，根据下层为上层服务的，上层基于下层才能做进一步的扩展的原则，尽管 IP MTU 的变化范围很大（68-65535），但也不得不照顾以太网 MTU 的限制,说白了就是 ip 对以太网的妥协。&lt;/p>
&lt;p>网络层 IP 协议会检查每个从上层协议下来的数据包的大小，并根据本机 MTU 的大小决定是否作“分片”处理&lt;/p>
&lt;p>&lt;strong>Maximum Segment Size(最大段长度，简称 MSS)&lt;/strong> 是 TCP 里面的一个概念，它是 TCP 数据包每次能够传输的最大数据分段，不包含包头部分，它与 IP MTU 满足如下关系：&lt;/p>
&lt;p>IP MTU=MSS+20bytes（IP 包头）+20bytes（TCP 包头）&lt;/p>
&lt;p>当然，如果传输的时候还承载有其他协议，还要加些包头在前面。&lt;/p>
&lt;p>注：为了达到最佳的传输效能，TCP 协议在建立连接的时候通常要协商双方的 MSS 值，这个值 TCP 协议在实现的时候往往用 MTU 值代替（需要减去 IP 数据包报头的大小 20Bytes 和 TCP 数据段的包头 20Bytes），所以往往 MSS 为 1460。通讯双方会根据双方提供的 MSS 值得最小值确定为这次连接的最大 MSS 值。&lt;/p>
&lt;p>4.简言之，mtu 就是总的最后发出去的报文大小，MSS 就是需要发出去的数据大小，比如 PPPoE，就是在以太网上承载 PPP 协议（点到点连接协议），它包括 6bytes 的 PPPoE 头部和 2bytes 的 PPP 协议 ID 号，此时，由于以太网的 MTU 值为 1500，所以上层 PPP 负载数据不能超过 1492 字节，也就是相当于在 PPPOE 环境下的 MTU 是 1492 字节，MSS 是 1452 字节（1492 字节-20-20）。&lt;/p>
&lt;p>重点：&lt;/p>
&lt;p>MTU 不包含 帧头（18byte） 指帧头后面的所有负载，与 ip mtu 的区别就是在帧头和 ip 头之间可能会有其他协议头（比如 GRE 头、pppoe 头、MPLS 标签，这些协议头都是在帧头后 ip 头前）&lt;/p>
&lt;p>ip MTU 包含 ip 头（20byte） 指 ip 头本身及后面的所有负载，一个普通的以太网数据包 mtu=ip mut，只有封装了其他协议头部时 mtu=ip mut+其他协议头部+负载（tcp 头+tcp-mss）&lt;/p>
&lt;p>TCP-MSS 不包含 tcp 头（20byte） 指 tcp 头后面的所有负载&lt;/p>
&lt;p>IP MTU=tcp-MSS+20bytes（IP 包头）+20bytes（TCP 包头）&lt;/p>
&lt;p>&lt;a href="https://serverfault.com/questions/500448/mysterious-fragmentation-required-rejections-from-gateway-vm">https://serverfault.com/questions/500448/mysterious-fragmentation-required-rejections-from-gateway-vm&lt;/a>&lt;/p>
&lt;h1 id="mslrttttl">MSL、RTT、TTL&lt;a class="td-heading-self-link" href="#mslrttttl" aria-label="Heading self-link">&lt;/a>&lt;/h1>
&lt;p>原文链接：&lt;a href="https://my.oschina.net/vbird/blog/1525869">https://my.oschina.net/vbird/blog/1525869&lt;/a>&lt;/p>
&lt;p>在&lt;a href="https://my.oschina.net/vbird/blog/1507479">《TCP 关闭状态分析》&lt;/a>一文中，段落“TIME_WAIT”中提到：&lt;/p>
&lt;p>之后等待 2 个最大的报文存活周期（这是因为：一是保证残留网络报文不会被新连接接收而产生数据错乱，由于自己上一次发送的数据报文可能还残留在网络中，等待 &lt;strong>2MSL&lt;/strong> 时间可以保证所有残留的网络报文在自己关闭前都已经超时。二是确保自己最后 ACK 发送到对端，因为 ACK 发送也可能会发送失败，这时对端会重新发送 FIN，如果已经 CLOSED 了那么对端将收到 RST 而不是 ACK 了，这不符合 TCP 可靠关闭的策略。）&lt;/p>
&lt;h2 id="msl">MSL&lt;a class="td-heading-self-link" href="#msl" aria-label="Heading self-link">&lt;/a>&lt;/h2>
&lt;p>Maximum Segment Lifetime 缩写，译为“报文最大生存时间”。它指的是任何报文在网络上存在的最长时间，超过这个时间的报文将会被丢弃。标准规范中规定 MSL 为 2 分钟，实际应用中常用的是 30s，1min 和 2min 等。
2MSL 即两倍的 MSL，TCP 的 TIME_WAIT 状态也称为&lt;strong>2MSL 等待状态&lt;/strong>，当 TCP 的一端发起主动关闭，在发出最后一个 ACK 包后，即第 3 次挥手完成后发送了第四次挥手的 ACK 包后就进入了 TIME_WAIT 状态，必须在此状态上停留两倍的 MSL 时间，等待 2MSL 时间主要目的是怕最后一个 ACK 包对方没收到，那么对方在超时后将重发第三次挥手的 FIN 包，主动关闭端接到重发的 FIN 包后可以再发一个 ACK 应答包。在 TIME_WAIT 状态时两端的端口不能使用，要等到 2MSL 时间结束才可继续使用。当连接处于 2MSL 等待阶段时任何迟到的报文段都将被丢弃。不过在实际应用中可以通过设置 &lt;strong>SO_REUSEADDR&lt;/strong>选项达到不必等待 2MSL 时间结束再使用此端口。&lt;/p>
&lt;p>在 &lt;a href="https://github.com/torvalds/linux/blob/v5.12/include/net/tcp.h#L121">Linux Kernel 5.12 版本的源码码&lt;/a> 可以看到默认值是 60&lt;/p>
&lt;h2 id="rtt">RTT&lt;a class="td-heading-self-link" href="#rtt" aria-label="Heading self-link">&lt;/a>&lt;/h2>
&lt;blockquote>
&lt;p>To this end, we define the &lt;strong>round-trip time (RTT)&lt;/strong>, which is the time it takes for a small packet to travel from client to server and then back to the client.&lt;/p>
&lt;/blockquote>
&lt;p>&lt;strong>Round-Trip Time(往返时间，简称 RTT)&lt;/strong>，简单理解的话，RTT 指的是客户端到服务端往返所花费的时间。其实 RTT 的定义是一个很小的分组(这里的很小也就是说对于发送方来说“开始发送”和“发送完”是同一个时刻。换句话说这个分组是没有长度的，传输时延可以忽略不计)，从客户端发送到接收端再返回客户端的时间。TCP 三次握手中发送的 SYN、ACK 以及四次挥手中使用到的 FIN 的交换就是这样的例子，ping 命令使用的也是这么一个非常小的包来试探网络的情况。如果是长度不可忽略的分组，接收方在接收到最后一比特数据后才会发送 ACK，实际也等价于发送最后一 bit 到接收到 ACK 的时间间隔。
TCP 含有动态估算 RTT 的算法。TCP 还持续估算一个给定连接的 RTT，这是因为 RTT 受网络传输拥塞程序的变化而变化。&lt;/p>
&lt;h2 id="ttl">TTL&lt;a class="td-heading-self-link" href="#ttl" aria-label="Heading self-link">&lt;/a>&lt;/h2>
&lt;p>详见 &lt;a href="https://desistdaydream.github.io/docs/4.%E6%95%B0%E6%8D%AE%E9%80%9A%E4%BF%A1/%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/TCP_IP/IP/IP%20Header.md">IP Header&lt;/a> 的 TTL 部分。&lt;/p>
&lt;h1 id="dmz-与-upnp">DMZ 与 UPnP&lt;a class="td-heading-self-link" href="#dmz-%e4%b8%8e-upnp" aria-label="Heading self-link">&lt;/a>&lt;/h1>
&lt;p>DMZ 主机的作用：设置 DMZ 主机，就是让一台内网电脑完全暴露在外网，也就是任何由外部发起的连接到路由的数据都会被转发到设定的内网主机。这样做的坏处就是路由无法提供自身的防火墙来保护内网的这台机器，存在一定的风险，一般情况下不推荐。&lt;/p>
&lt;h1 id="interpacket-gap">Interpacket gap&lt;a class="td-heading-self-link" href="#interpacket-gap" aria-label="Heading self-link">&lt;/a>&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Interpacket_gap">Wiki，Interpacket gap&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>&lt;strong>Interpacket gap(包间隙，简称 IPG)&lt;/strong> 也称为 &lt;strong>interframe gap(IFG)&lt;/strong> 是网络数据包或网络帧之间可能需要的暂停。根据所使用的物理层协议或编码，暂停可能是必要的，以允许接收器时钟恢复，允许接收器准备另一个数据包（例如，从低功耗状态上电）或其他目的。可以将其视为保护间隔的特定情况。&lt;/p></description></item><item><title>Docs: ARP 与 NDP</title><link>https://desistdaydream.github.io/docs/4.%E6%95%B0%E6%8D%AE%E9%80%9A%E4%BF%A1/%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/ARP-%E4%B8%8E-NDP/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/4.%E6%95%B0%E6%8D%AE%E9%80%9A%E4%BF%A1/%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/ARP-%E4%B8%8E-NDP/</guid><description>
&lt;h1 id="概述">概述&lt;a class="td-heading-self-link" href="#%e6%a6%82%e8%bf%b0" aria-label="Heading self-link">&lt;/a>&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Address_Resolution_Protocol">Wiki，ARP&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Neighbor_Discovery_Protocol">Wiki，NDP&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.rfc-editor.org/rfc/rfc826.html">RFC 826&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://mp.weixin.qq.com/s/_5Wgsx4mEoDZgwv9-yHYEA">公众号，36 张图详解 ARP&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>&lt;strong>Address Resolution Protoco(地址解析协议，简称 ARP)&lt;/strong> 是一种通信协议，该协议可以通过给定的网络层地址(通常是 IPv4 地址)，发现与之相关联的链路层地址(通常你是 MAC 地址)。ARP 于 1982 年在 &lt;a href="https://www.rfc-editor.org/rfc/rfc826.html">RFC 826&lt;/a> 中定义。说白了，就是根据 IP 地址查询对应 MAC 地址的协议。&lt;/p>
&lt;p>注意：在 IPv6 网络环境下，APR 的功能已经被 NDP 替代&lt;/p>
&lt;p>对应关系：一个 ip 地址对应一个 MAC 地址。多个 ip 地址可以对应一个 MAC 地址(e.g.一个网卡上配置两个 ip)&lt;/p>
&lt;h2 id="arp-报文">ARP 报文&lt;a class="td-heading-self-link" href="#arp-%e6%8a%a5%e6%96%87" aria-label="Heading self-link">&lt;/a>&lt;/h2>
&lt;p>在抓包时，可以抓到如下几种 ARP 包&lt;/p>
&lt;ul>
&lt;li>ARP, Request who-has 10.10.100.254 tell 10.10.100.101, length 28
&lt;ul>
&lt;li>在局域网中询问谁有 10.10.100.254，告诉自己，自己就是 10.10.100.101&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>ARP, Reply 10.10.100.254 is-at 00:0f:e2:ff:05:92, length 46
&lt;ul>
&lt;li>当 10.10.100.254 收到 arp 广播包之后，就会进行 reply(响应)，10.10.100.254 的 mac 地址是 00:0f:e2:ff:05:92&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>这时候 10.10.100.101 就会更新自己的 arp 表，记录下来 10.10.100.254 与 00:0f:e2:ff:05:92 的对应关系&lt;/li>
&lt;/ul>
&lt;p>ARP 报文分为 &lt;strong>ARP 请求报文&lt;/strong>和 &lt;strong>ARP 应答报文&lt;/strong>，它们的报文格式相同，但是各个字段的取值不同。&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/nguycm/1623911614198-6f1cde9d-cf37-4711-b6ce-cd9b8b1ccdd5.png" alt="">ARP 报文格式&lt;/p>
&lt;p>ARP 报文中各个字段的含义如下。&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/nguycm/1623911614222-e8fe87d5-ca7b-494c-99c1-b8b1be472301.png" alt="">&lt;/p>
&lt;h1 id="arp-原理">ARP 原理&lt;a class="td-heading-self-link" href="#arp-%e5%8e%9f%e7%90%86" aria-label="Heading self-link">&lt;/a>&lt;/h1>
&lt;p>ARP 是通过 **ARP Request(请求) **和 **ARP Reply(响应) **报文确定 MAC 地址的。
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/nguycm/1623910582328-062e8f26-c6da-4ee5-97e4-857507dbb707.png" alt="">&lt;/p>
&lt;h2 id="同网段交互流程">同网段交互流程&lt;a class="td-heading-self-link" href="#%e5%90%8c%e7%bd%91%e6%ae%b5%e4%ba%a4%e4%ba%92%e6%b5%81%e7%a8%8b" aria-label="Heading self-link">&lt;/a>&lt;/h2>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>root@lichenhao:~# tcpdump -i any host 172.19.42.202
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>tcpdump: verbose output suppressed, use -v or -vv &lt;span style="color:#204a87;font-weight:bold">for&lt;/span> full protocol decode
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>listening on any, link-type LINUX_SLL &lt;span style="color:#ce5c00;font-weight:bold">(&lt;/span>Linux cooked v1&lt;span style="color:#ce5c00;font-weight:bold">)&lt;/span>, capture size &lt;span style="color:#0000cf;font-weight:bold">262144&lt;/span> bytes
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>14:13:38.036170 ARP, Request who-has 172.19.42.202 tell lichenhao.bj-test, length &lt;span style="color:#0000cf;font-weight:bold">28&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>14:13:38.036549 ARP, Reply 172.19.42.202 is-at 00:be:d5:ef:24:4e &lt;span style="color:#ce5c00;font-weight:bold">(&lt;/span>oui Unknown&lt;span style="color:#ce5c00;font-weight:bold">)&lt;/span>, length &lt;span style="color:#0000cf;font-weight:bold">46&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>14:13:38.036583 IP lichenhao.bj-test &amp;gt; 172.19.42.202: ICMP &lt;span style="color:#204a87">echo&lt;/span> request, id 3, seq 1, length &lt;span style="color:#0000cf;font-weight:bold">64&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>14:13:38.036821 IP 172.19.42.202 &amp;gt; lichenhao.bj-test: ICMP &lt;span style="color:#204a87">echo&lt;/span> reply, id 3, seq 1, length &lt;span style="color:#0000cf;font-weight:bold">64&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>如上所示，当前主机没有 172.19.42.202 主机的 arp 关系表，当我们向 172.19.42.202 发送 icmp 请求时，数据包将会经历如下过程：&lt;/p>
&lt;p>假如主机 A 向同一网段上的主机 B 发送数据。主机 A 的 IP 地址为 &lt;code>10.0.0.1&lt;/code> ，主机 B 的 IP 地址为 &lt;code>10.0.0.2&lt;/code> ，主机 C 的 IP 地址为 &lt;code>10.0.0.3&lt;/code> 。它们都不知道对方的 MAC 地址。ARP 地址解析过程如下：
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/nguycm/1623910652117-bd47d4a3-1fb2-4f50-9b4f-bc8e5c2a1b2b.png" alt="">&lt;/p>
&lt;ol>
&lt;li>&lt;strong>主机 A&lt;/strong> 首先查看自己的 ARP 表（即 ARP 缓存表），确定是否有主机 B 的 IP 地址对应表项。如果有，则直接使用表项中的 MAC 地址进行封装，封装成帧后发送给主机 B 。&lt;/li>
&lt;/ol>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/nguycm/1623910669257-9b3f2f80-ddd3-4501-807e-96acfe414c20.png" alt="">&lt;/p>
&lt;ol start="2">
&lt;li>如果&lt;strong>主机 A&lt;/strong> 的 ARP 表没有对应的表项，就发送一个广播帧，源 IP 和源 MAC 地址是主机 A ，目的 IP 地址是主机 B ，目的 MAC 地址是广播 MAC 地址，即 &lt;code>FFFF-FFFF-FFFF&lt;/code> 。这就是 &lt;strong>ARP 请求报文&lt;/strong>。&lt;/li>
&lt;/ol>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/nguycm/1623910669279-c6354c1b-c098-4974-b4cd-22e93fc54efe.png" alt="">&lt;/p>
&lt;ol start="3">
&lt;li>ARP 请求是广播报文，同一个网段的所有主机都能收到。只有主机 B 发现报文中的目的 IP 地址是自己，于是&lt;strong>主机 B&lt;/strong> 发送响应报文给主机 A ，源 MAC 地址和源 IP 地址是主机 B ，目的 MAC 地址和目的 IP 地址是主机 A ，这个报文就叫 &lt;strong>ARP 响应报文&lt;/strong>。同时，主机 B 的 ARP 表记录主机 A 的映射关系，即主机 A 的 IP 地址和 MAC 地址的对应关系。&lt;/li>
&lt;/ol>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/nguycm/1623910669203-16790059-e9ef-45f9-9c9b-28f5f835c556.png" alt="">&lt;/p>
&lt;ol start="4">
&lt;li>&lt;strong>主机 C&lt;/strong> 也收到了 ARP 请求报文，但目的 IP 地址不是自己，所以不会进行响应。于是主机 C 添加主机 A 的映射关系到 ARP 表，并丢弃 ARP 请求报文。&lt;/li>
&lt;/ol>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/nguycm/1623910669305-20a3b990-6012-45d5-8462-176106ad6dd6.png" alt="">&lt;/p>
&lt;ol start="5">
&lt;li>主机 A 收到 ARP 响应报文后，添加主机 B 的映射关系，同时用主机 B 的 MAC 地址做为目的地址封装成帧，并发送给主机 B 。&lt;/li>
&lt;/ol>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/nguycm/1623910669300-be2dccaa-122c-41d2-92b6-3b035e70335d.png" alt="">
如果每发送一个 IP 报文就要进行一次 ARP 请求，来确定 MAC 地址，那将会造成不必要的网络流量，通常的做法是用 ARP 表记录 IP 地址和 MAC 地址的映射关系。主机发送报文时，首先会查看它的 &lt;strong>ARP 表&lt;/strong>，目的是为了确定是否是已知的设备 MAC 地址。如果有，就直接使用；如果没有，就发起 ARP 请求获取。不过，缓存是有一定期限的。ARP 表项在&lt;strong>老化时间&lt;/strong>（ &lt;code>aging time&lt;/code> ）内是有效的，如果老化时间内未被使用，表项就会被删除。
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/nguycm/1623910669502-4614b748-fac7-4301-bc85-68ccec45c91a.png" alt="">
ARP 表项分为&lt;strong>动态 ARP 表项&lt;/strong>和&lt;strong>静态 ARP 表项&lt;/strong>：&lt;/p>
&lt;ul>
&lt;li>&lt;strong>动态 ARP 表项&lt;/strong>由 ARP 动态获取，因此在网络通信中，无需事先知道 MAC 地址，只要有 IP 地址即可。如果老化时间内未被使用，表项就会被自动删除。&lt;/li>
&lt;li>&lt;strong>静态 ARP 表项&lt;/strong>是手工配置，不会老化。静态 ARP 表项的优先级高于动态 ARP 表项，可以将相应的动态 ARP 表项覆盖。&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/nguycm/1623910669307-374038c8-0ab6-4a06-ad5a-b55240326db1.png" alt="">&lt;/p>
&lt;h2 id="跨网段交互流程">跨网段交互流程&lt;a class="td-heading-self-link" href="#%e8%b7%a8%e7%bd%91%e6%ae%b5%e4%ba%a4%e4%ba%92%e6%b5%81%e7%a8%8b" aria-label="Heading self-link">&lt;/a>&lt;/h2>
&lt;ol>
&lt;li>在 client 向 server 发送数据时，内核会在该数据包外封装 源 IP、源 MAC、目的 IP，由于目的 MAC 未知，所以不填&lt;/li>
&lt;li>数据包经过交换、路由等设备后，到达 server 前的交换机，交换机根据自身的 arp 表，找到目的 IP 与哪个口的 mac 地址相关联，则把数据包交给响应的网口，以便顺利到达 server。&lt;/li>
&lt;li>server 收到数据包后，内核会把最外层的 IP 与 MAC 都玻璃，并交给相对应的用户空间内的程序，处理完成后，再发送数据响应 client&lt;/li>
&lt;li>此时 server 已经有个 client 的 MAC 与 IP，所以在内核封装的时候，会填写源 IP、源 MAC、目的 IP、目的 MAC。&lt;/li>
&lt;li>之后数据包到达 client 前面的交换机时，交换机发现目的 IP 与 MAC，则更新或者保持不变 arp 表，并把数据包交给 MAC 为目的 MAC 的端口，以便数据送达 client&lt;/li>
&lt;li>这样就完成了两台设备之间的互相通信以及数据报文的完整封装&lt;/li>
&lt;li>否则第一次发送数据的时候，如果是不在本网段的地址，则目的 MAC 一般都是未知的，除非已经建立连接之后，才能根据数据包的源 MAC 知道响应的时候目的 MAC 填什么&lt;/li>
&lt;/ol>
&lt;h1 id="免费-arp-广播-与-一般-arp-广播">免费 ARP 广播 与 一般 ARP 广播&lt;a class="td-heading-self-link" href="#%e5%85%8d%e8%b4%b9-arp-%e5%b9%bf%e6%92%ad-%e4%b8%8e-%e4%b8%80%e8%88%ac-arp-%e5%b9%bf%e6%92%ad" aria-label="Heading self-link">&lt;/a>&lt;/h1>
&lt;ul>
&lt;li>&lt;strong>免费 arp 广播&lt;/strong> # 在设备首次接通网线之后，会进行 arp 广播，告诉大家自己的 IP 与 MAC 对应关系。当局域网内的设备收到这个免费的 arp 广播时，没有该 arp 记录则会添加，如果该 arp 记录改变了则会更新。&lt;/li>
&lt;li>&lt;strong>一般 arp 广播&lt;/strong> # 在对本机未知同网段的设备发送数据时，会进行 arp 广播，询问该设备在哪里。&lt;/li>
&lt;li>“免费 arp 广播”与“一般 arp 广播”的区别：
&lt;ol>
&lt;li>普通的 arp 请求如果目的地址不是本机，则本机就直接丢弃了，但是免费的 arp 广播，则会在本机保留或者更新。&lt;/li>
&lt;/ol>
&lt;/li>
&lt;/ul>
&lt;p>如果目的 IP 不在本网段，则不会进行 arp 广播，因为目的地址不在本网段的设备，发送出去直接就到网关了，而网关在接入的时候、每隔 N 时间，都会发送 arp 来询问网关在哪。至于交换机测，也是同样的道理，本网段的设备，在需要发送数据包的时候，如果 arp 表里没有，则会先进行 arp 广播再发送。因为这些都是通过 mac 地址来进行二层发送的。&lt;/p>
&lt;p>&lt;strong>免费 ARP&lt;/strong> 是一种特殊的 ARP 请求，它并非通过 IP 找到对应的 MAC 地址，而是当主机启动的时候，发送一个免费 ARP 请求，即请求自己的 IP 地址的 MAC 地址。
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/nguycm/1623911576682-1a99a60a-4fa9-4480-8061-cec725fe9073.webp" alt="">
与普通 ARP 请求报文的区别在于报文中的目标 IP 地址。普通 ARP 报文中的目标 IP 地址是其它主机的 IP 地址；而免费 ARP 的请求报文中，&lt;strong>目标 IP 地址是自己的 IP 地址&lt;/strong>。
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/nguycm/1623911577030-243f8668-60e2-4952-bac9-beef00f9cba4.png" alt="">
免费 ARP 的作用：&lt;/p>
&lt;ul>
&lt;li>起到一个&lt;strong>宣告&lt;/strong>作用。它以广播的形式将数据包发送出去，不需要得到回应，只为了告诉其它主机自己的 IP 地址和 MAC 地址。&lt;/li>
&lt;li>可用于&lt;strong>检测 IP 地址冲突&lt;/strong>。当一台主机发送了免费 ARP 请求报文后，如果收到了 ARP 响应报文，则说明网络内已经存在使用该 IP 地址的主机。&lt;/li>
&lt;li>可用于&lt;strong>更新&lt;/strong>其它主机的 ARP 缓存表。如果该主机更换了网卡，而其它主机的 ARP 缓存表仍然保留着原来的 MAC 地址。这时，通过免费的 ARP 数据包，更新其它主机的 ARP 缓存表。&lt;/li>
&lt;/ul>
&lt;h1 id="ndp">NDP&lt;a class="td-heading-self-link" href="#ndp" aria-label="Heading self-link">&lt;/a>&lt;/h1></description></item><item><title>Docs: BGP</title><link>https://desistdaydream.github.io/docs/4.%E6%95%B0%E6%8D%AE%E9%80%9A%E4%BF%A1/%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/BGP/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/4.%E6%95%B0%E6%8D%AE%E9%80%9A%E4%BF%A1/%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/BGP/</guid><description>
&lt;h1 id="概述">概述&lt;a class="td-heading-self-link" href="#%e6%a6%82%e8%bf%b0" aria-label="Heading self-link">&lt;/a>&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;/blockquote>
&lt;p>&lt;strong>Border Gateway Protocol(边界网关协议，简称 BFP)&lt;/strong> 是一个 Linux 内核原生就支持的、专门用在大规模数据中心里维护不同的“自治系统”之间路由信息的、无中心的路由协议。&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/pzl1r1/1616161506385-ecfc3cc9-11e3-4188-adfe-c551023cf332.jpeg" alt="">&lt;/p>
&lt;p>在这个图中，我们有两个自治系统（Autonomous System，简称为 AS）：AS 1 和 AS 2。而所谓的一个自治系统，指的是一个组织管辖下的所有 IP 网络和路由器的全体。你可以把它想象成一个小公司里的所有主机和路由器。在正常情况下，自治系统之间不会有任何“来往”。&lt;/p>
&lt;p>但是，如果这样两个自治系统里的主机，要通过 IP 地址直接进行通信，我们就必须使用路由器把这两个自治系统连接起来。&lt;/p>
&lt;p>比如，AS 1 里面的主机 10.10.0.2，要访问 AS 2 里面的主机 172.17.0.3 的话。它发出的 IP 包，就会先到达自治系统 AS 1 上的路由器 Router 1。&lt;/p>
&lt;p>而在此时，Router 1 的路由表里，有这样一条规则，即：目的地址是 172.17.0.2 包，应该经过 Router 1 的 C 接口，发往网关 Router 2（即：自治系统 AS 2 上的路由器）。&lt;/p>
&lt;p>所以 IP 包就会到达 Router 2 上，然后经过 Router 2 的路由表，从 B 接口出来到达目的主机 172.17.0.3。&lt;/p>
&lt;p>但是反过来，如果主机 172.17.0.3 要访问 10.10.0.2，那么这个 IP 包，在到达 Router 2 之后，就不知道该去哪儿了。因为在 Router 2 的路由表里，并没有关于 AS 1 自治系统的任何路由规则。&lt;/p>
&lt;p>所以这时候，网络管理员就应该给 Router 2 也添加一条路由规则，比如：目标地址是 10.10.0.2 的 IP 包，应该经过 Router 2 的 C 接口，发往网关 Router 1。&lt;/p>
&lt;p>像上面这样负责把自治系统连接在一起的路由器，我们就把它形象地称为：边界网关。它跟普通路由器的不同之处在于，它的路由表里拥有其他自治系统里的主机路由信息。&lt;/p>
&lt;p>上面的这部分原理，相信你理解起来应该很容易。毕竟，路由器这个设备本身的主要作用，就是连通不同的网络。但是，你可以想象一下，假设我们现在的网络拓扑结构非常复杂，每个自治系统都有成千上万个&lt;/p>
&lt;p>主机、无数个路由器，甚至是由多个公司、多个网络提供商、多个自治系统组成的复合自治系统呢？&lt;/p>
&lt;p>这时候，如果还要依靠人工来对边界网关的路由表进行配置和维护，那是绝对不现实的。而这种情况下，BGP 大显身手的时刻就到了。在使用了 BGP 之后，你可以认为，在每个边界网关上都会运行着一个小程序，它们会将各自的路由表信息，通过 TCP 传输给其他的边界网关。而其他边界网关上的这个小程序，则会对收到的这些数据进行分析，然后将需要的信息添加到自己的路由表里。这样，图 2 中 Router 2 的路由表里，就会自动出现 10.10.0.2 和 10.10.0.3 对应的路由规则了。&lt;/p>
&lt;p>所以说，所谓 BGP，就是在大规模网络中实现节点路由信息共享的一种协议。而 BGP 的这个能力，正好可以取代 Flannel 维护主机上路由表的功能。而且，BGP 这种原生就是为大规模网络环境而实现的协议，其可靠性和可扩展性，远非 Flannel 自己的方案可比。&lt;/p>
&lt;p>Note：BGP 协议实际上是最复杂的一种路由协议。我在这里的讲述和所举的例子，仅是为了能够帮助你建立对 BGP 的感性认识，并不代表 BGP 真正的实现方式。&lt;/p></description></item><item><title>Docs: DHCP</title><link>https://desistdaydream.github.io/docs/4.%E6%95%B0%E6%8D%AE%E9%80%9A%E4%BF%A1/%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/DHCP/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/4.%E6%95%B0%E6%8D%AE%E9%80%9A%E4%BF%A1/%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/DHCP/</guid><description>
&lt;h1 id="概述">概述&lt;a class="td-heading-self-link" href="#%e6%a6%82%e8%bf%b0" aria-label="Heading self-link">&lt;/a>&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Dynamic_Host_Configuration_Protocol">Wiki，DHCP&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>&lt;strong>Dynamic Host Configuration Protocol(动态主机设置协议，简称 DHCP)&lt;/strong> 主要用于由一部主机来自动的分配所有的网络参数给指定网段内的所有设备。&lt;/p>
&lt;p>DHCP 可以分配的网络参数有 IP 地址、掩码、网关、DNS 等&lt;/p>
&lt;p>DHCP 的运作方式：
他主要由客户端发送广播包给整个物理网段内的所有主机， 若该网段内有 DHCP 服务器时，就会响应客户端的 DHCP 请求。所以，DHCP 服务器与客户端是应该要在同一个物理网段内的，如果想跨网段提供 DHCP 服务，需要在对应网段启用 dhcrelay 服务。&lt;/p>
&lt;p>至于整个 DHCP 封包在服务器与客户端的来来回回情况如右图，具体有 4 个步骤&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/sc7lh2/1616161468691-c82332ec-254e-485f-861d-9186e60a3dd8.jpeg" alt="">&lt;/p>
&lt;ul>
&lt;li>&lt;strong>DISCOVER(发现)&lt;/strong> # 客户端利用广播封包发送搜索 DHCP 服务器的封包：
&lt;ul>
&lt;li>若客户端网络设定使用 DHCP 协议取得 IP (在 Windows 内为『自动取得 IP』)，则当客户端开机或者是重新启动网络卡时， 客户端主机会发送出搜寻 DHCP 服务器的 UDP 封包给所有物理网段内的计算机。此封包的目标 IP 会是 255.255.255.255， 所以一般主机接收到这个封包后会直接予以丢弃，但若局域网络内有 DHCP 服务器时，则会开始进行后续行为。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>OFFER(提供)&lt;/strong> # DHCP 服务端提供客户端网络相关的租约以供选择
&lt;ul>
&lt;li>DHCP 服务器在接收到这个客户端的要求后，会针对这个客户端的硬件地址 (MAC) 与本身的设定数据来进行下列工作：
&lt;ul>
&lt;li>到服务器的登录文件中寻找该用户之前是否曾经用过某个 IP ，若有且该 IP 目前无人使用，则提供此 IP 给客户端；&lt;/li>
&lt;li>若配置文件针对该 MAC 提供额外的固定 IP (static IP) 时，则提供该固定 IP 给客户端；&lt;/li>
&lt;li>若不符合上述两个条件，则随机取用目前没有被使用的 IP 参数给客户端，并记录下来。&lt;/li>
&lt;li>总之，服务器端会针对客户端的要求提供一组网络参数租约给客户端选择，由于此时客户端尚未有 IP ，因此服务器端响应的封包信息中， 主要是针对客户端的 MAC 来给予回应。此时服务器端会保留这个租约然后开始等待客户端的回应。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>REQUEST(请求)&lt;/strong> # 客户端决定选择的 DHCP 服务器提供的网络参数租约并回报服务器
&lt;ul>
&lt;li>由于局域网络内可能并非仅有一部 DHCP 服务器，但客户端仅能接受一组网络参数的租约。 因此客户端必需要选择是否要认可该服务器提供的相关网络参数的租约。当决定好使用此服务器的网络参数租约后， 客户端便开始使用这组网络参数来设定自己的网络环境。此外，客户端也会发送一个广播封包给所有物理网段内的主机， 告知已经接受该服务器的租约。此时若有第二台以上的 DHCP 服务器，则这些没有被接受的服务器会收回该 IP 租约。至于被接受的 DHCP 服务器会继续进行底下的动作。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>Acknowledge(确认，ACK)&lt;/strong> # 服务端记录该次租约行为并回报客户端已确认的响应封包信息
- 当服务器端收到客户端的确认选择后，服务器会回传确认的响应封包，并且告知客户端这个网络参数租约的期限， 并且开始租约计时喔！那么该次租约何时会到期而被解约，可以这样想：
- 客户端脱机：不论是关闭网络接口 (ifdown)、重新启动 (reboot)、关机 (shutdown) 等行为，皆算是脱机状态，这个时候 Server 端就会将该 IP 回收，并放到 Server 自己的备用区中，等待未来的使用；
- 客户端租约到期：前面提到 DHCP server 端发放的 IP 有使用的期限，客户端使用这个 IP 到达期限规定的时间，而且没有重新提出 DHCP 的申请时，就需要将 IP 缴回去！这个时候就会造成断线。但用户也可以再向 DHCP 服务器要求再次分配 IP 啰。&lt;/li>
&lt;/ul>
&lt;p>这四个步骤也称为 DHCP 分配地址时的需要进行的 DORA 进程&lt;/p>
&lt;h2 id="dhcp-租约">DHCP 租约&lt;a class="td-heading-self-link" href="#dhcp-%e7%a7%9f%e7%ba%a6" aria-label="Heading self-link">&lt;/a>&lt;/h2>
&lt;p>每次 DHCP 服务给客户端提供网络参数时，同时会提供一个有效时间，该有效时间表示客户端使用这些参数的有效时间，当有效时间过了之后，客户端则不再拥有这些网络参数。租约是由客户端发起请求具体租用时间，然后服务器回应是否可以给客户端租用这些时间。&lt;/p>
&lt;p>DHCP 提供的租约信息保存在 /var/lib/dhcpd/dhcpd.lesses 文件中，租约中包括这些参数：提供的 IP，客户端 MAC，租赁时长&lt;/p>
&lt;h1 id="isc-dhcp">ISC-DHCP&lt;a class="td-heading-self-link" href="#isc-dhcp" aria-label="Heading self-link">&lt;/a>&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://www.isc.org/dhcp/">ISC DHCP 官网&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://access.redhat.com/documentation/zh-cn/red_hat_enterprise_linux/8/html/configuring_and_managing_networking/providing-dhcp-services_configuring-and-managing-networking#setting-up-the-dhcp-service-for-subnets-directly-connected-to-the-dhcp-server_providing-dhcp-services">https://access.redhat.com/documentation/zh-cn/red_hat_enterprise_linux/8/html/configuring_and_managing_networking/providing-dhcp-services_configuring-and-managing-networking#setting-up-the-dhcp-service-for-subnets-directly-connected-to-the-dhcp-server_providing-dhcp-services&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>ISC-DHCP 提供了一个完整的开源解决方案，用来实现 DHCP 服务端、DHCP 客户端、DHCP 中继代理 这几种 DHCP 服务，可以将 ISC-DHCP 看作一个&lt;strong>程序的集合&lt;/strong>。ISC DHCP 支持 IPv4 和 IPv6，适用于大批量和高可靠性的应用&lt;/p>
&lt;p>CentOS 和 Ubuntu 安装的都是 ISC 分发的 DCHP 程序，不过 ISC 官方已经推荐使用 Kea DHCP 替代 ISC DHCP&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/sc7lh2/1643021582679-beb6a411-3391-4577-a658-295acbd0f2a5.png" alt="image.png">&lt;/p>
&lt;p>注意：&lt;/p>
&lt;ul>
&lt;li>在为 IPv6 分配地址时，通常需要与 radvd 程序一起运行，详见 &lt;a href="#NMGBa">DHCPv6 与 radvd 章节&lt;/a>&lt;/li>
&lt;/ul>
&lt;h2 id="安装">安装&lt;a class="td-heading-self-link" href="#%e5%ae%89%e8%a3%85" aria-label="Heading self-link">&lt;/a>&lt;/h2>
&lt;h3 id="centos">CentOS&lt;a class="td-heading-self-link" href="#centos" aria-label="Heading self-link">&lt;/a>&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>yum install dhcp
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>CentOS 的包是真的不更新。。。囧。。。。好多这种情况了。。。包中写的网址都是错误的。。。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>~&lt;span style="color:#ce5c00;font-weight:bold">]&lt;/span>&lt;span style="color:#8f5902;font-style:italic"># yum info dhcp&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Loaded plugins: fastestmirror, product-id, search-disabled-repos, subscription-manager
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>This system is not registered with an entitlement server. You can use subscription-manager to register.
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Loading mirror speeds from cached hostfile
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> * base: mirrors.tuna.tsinghua.edu.cn
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> * epel: mirrors.tuna.tsinghua.edu.cn
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> * extras: mirrors.tuna.tsinghua.edu.cn
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> * updates: mirrors.tuna.tsinghua.edu.cn
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Available Packages
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Name : dhcp
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Arch : x86_64
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Epoch : &lt;span style="color:#0000cf;font-weight:bold">12&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Version : 4.2.5
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Release : 83.el7.centos.1
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Size : &lt;span style="color:#0000cf;font-weight:bold">515&lt;/span> k
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Repo : updates/7/x86_64
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Summary : Dynamic host configuration protocol software
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>URL : http://isc.org/products/DHCP/ // 在 ISC 官网。。。这个页面已经没了。。。。。
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>License : ISC
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Description : DHCP &lt;span style="color:#ce5c00;font-weight:bold">(&lt;/span>Dynamic Host Configuration Protocol&lt;span style="color:#ce5c00;font-weight:bold">)&lt;/span> is a protocol which allows
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> : individual devices on an IP network to get their own network
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> : configuration information &lt;span style="color:#ce5c00;font-weight:bold">(&lt;/span>IP address, subnetmask, broadcast address,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> : etc.&lt;span style="color:#ce5c00;font-weight:bold">)&lt;/span> from a DHCP server. The overall purpose of DHCP is to make it
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> : easier to administer a large network.
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> :
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> : To use DHCP on your network, install a DHCP service &lt;span style="color:#ce5c00;font-weight:bold">(&lt;/span>or relay agent&lt;span style="color:#ce5c00;font-weight:bold">)&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> : and on clients run a DHCP client daemon. The dhcp package provides
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> : the ISC DHCP service and relay agent.
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="ubunt">Ubunt&lt;a class="td-heading-self-link" href="#ubunt" aria-label="Heading self-link">&lt;/a>&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>apt install isc-dhcp-server
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>包的信息&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>~&lt;span style="color:#ce5c00;font-weight:bold">]&lt;/span>&lt;span style="color:#8f5902;font-style:italic"># apt-cache show isc-dhcp-server&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Package: isc-dhcp-server
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Architecture: amd64
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Version: 4.4.1-2.1ubuntu5.20.04.2
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Priority: optional
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Section: net
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Source: isc-dhcp
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Origin: Ubuntu
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Maintainer: Ubuntu Developers &amp;lt;ubuntu-devel-discuss@lists.ubuntu.com&amp;gt;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Original-Maintainer: Debian ISC DHCP Maintainers &amp;lt;isc-dhcp@packages.debian.org&amp;gt;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Bugs: https://bugs.launchpad.net/ubuntu/+filebug
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Installed-Size: &lt;span style="color:#0000cf;font-weight:bold">1503&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Depends: debconf &lt;span style="color:#ce5c00;font-weight:bold">(&lt;/span>&amp;gt;&lt;span style="color:#ce5c00;font-weight:bold">=&lt;/span> 0.5&lt;span style="color:#ce5c00;font-weight:bold">)&lt;/span> &lt;span style="color:#000;font-weight:bold">|&lt;/span> debconf-2.0, libc6 &lt;span style="color:#ce5c00;font-weight:bold">(&lt;/span>&amp;gt;&lt;span style="color:#ce5c00;font-weight:bold">=&lt;/span> 2.15&lt;span style="color:#ce5c00;font-weight:bold">)&lt;/span>, libdns-export1109, libirs-export161, libisc-export1105, debianutils &lt;span style="color:#ce5c00;font-weight:bold">(&lt;/span>&amp;gt;&lt;span style="color:#ce5c00;font-weight:bold">=&lt;/span> 2.8.2&lt;span style="color:#ce5c00;font-weight:bold">)&lt;/span>, lsb-base, adduser
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Recommends: isc-dhcp-common
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Suggests: policykit-1, isc-dhcp-server-ldap, policycoreutils
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Breaks: isc-dhcp-common &lt;span style="color:#ce5c00;font-weight:bold">(=&lt;/span> 4.3.3-1&lt;span style="color:#ce5c00;font-weight:bold">)&lt;/span>, logcheck-database &lt;span style="color:#ce5c00;font-weight:bold">(=&lt;/span> 1.3.17~&lt;span style="color:#ce5c00;font-weight:bold">)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Replaces: isc-dhcp-common &lt;span style="color:#ce5c00;font-weight:bold">(=&lt;/span> 4.3.3-1&lt;span style="color:#ce5c00;font-weight:bold">)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Filename: pool/main/i/isc-dhcp/isc-dhcp-server_4.4.1-2.1ubuntu5.20.04.2_amd64.deb
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Size: &lt;span style="color:#0000cf;font-weight:bold">454712&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>MD5sum: 92a2ec90073e62f5fe65ecb840e2fcd9
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>SHA1: 1f1253f7bcd4a8d3bec5d9736d4238115635df21
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>SHA256: b537b40e5c35054d8d3f82060936de737b08f1daa48e731652aa230170f0b21a
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>SHA512: f00f30b52b085dcf9737c7cd5d37095ecdbcf9750e7bf1e5ca1f80591d1ad9f24d5b29b2c89d40dee639803b7e1e90b92f8b3396d8976a1171321eef5d960559
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Homepage: http://www.isc.org
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Description-en: ISC DHCP server &lt;span style="color:#204a87;font-weight:bold">for&lt;/span> automatic IP address assignment
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> This is the Internet Software Consortium&lt;span style="color:#a40000">&amp;#39;&lt;/span>s DHCP server.
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Dynamic Host Configuration Protocol &lt;span style="color:#ce5c00;font-weight:bold">(&lt;/span>DHCP&lt;span style="color:#ce5c00;font-weight:bold">)&lt;/span> is a protocol like BOOTP
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ce5c00;font-weight:bold">(&lt;/span>actually dhcpd includes much of the functionality of bootpd&lt;span style="color:#ce5c00;font-weight:bold">)&lt;/span>. It
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> gives client machines &lt;span style="color:#4e9a06">&amp;#34;leases&amp;#34;&lt;/span> &lt;span style="color:#204a87;font-weight:bold">for&lt;/span> IP addresses and can
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> automatically &lt;span style="color:#204a87">set&lt;/span> their network configuration.
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> This server can handle multiple ethernet interfaces.
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Description-md5: 38647f497f13c9a0a99f9d9cf772d70d
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="dhcp-程序关联文件">dhcp 程序关联文件&lt;a class="td-heading-self-link" href="#dhcp-%e7%a8%8b%e5%ba%8f%e5%85%b3%e8%81%94%e6%96%87%e4%bb%b6" aria-label="Heading self-link">&lt;/a>&lt;/h2>
&lt;p>/etc/default/isc-dhcp-server #&lt;/p>
&lt;p>/etc/dhcp/dhcpd.conf # dhcpd 程序运行时行为的配置文件&lt;/p>
&lt;p>/var/lib/dhcpd/dhcpd.leases 与 /var/lib/dhcpd/dhcpd.leases~ # DHCP 的客户端租约的缓存文件&lt;/p>
&lt;ul>
&lt;li>所有从 DHCP 服务器获取 IP 的客户端信息都会记录在这个文件里&lt;/li>
&lt;li>并且 dhcp 服务会探测所能分配的 IP 是否被占用，所有被占用的记录也会记在这个文件里&lt;/li>
&lt;li>注意：当 DHCP 无法按照预想的样子分配 IP 的时候，可以尝试清除该文件里的内容，让其重新获取信息&lt;/li>
&lt;/ul>
&lt;h3 id="配置文件样例">配置文件样例&lt;a class="td-heading-self-link" href="#%e9%85%8d%e7%bd%ae%e6%96%87%e4%bb%b6%e6%a0%b7%e4%be%8b" aria-label="Heading self-link">&lt;/a>&lt;/h3>
&lt;p>dhcp4&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-nginx" data-lang="nginx">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#204a87;font-weight:bold">ddns-update-style&lt;/span> &lt;span style="color:#4e9a06">interim&lt;/span>&lt;span style="color:#000;font-weight:bold">;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#204a87;font-weight:bold">allow&lt;/span> &lt;span style="color:#4e9a06">booting&lt;/span>&lt;span style="color:#000;font-weight:bold">;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#204a87;font-weight:bold">allow&lt;/span> &lt;span style="color:#4e9a06">bootp&lt;/span>&lt;span style="color:#000;font-weight:bold">;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#204a87;font-weight:bold">ignore&lt;/span> &lt;span style="color:#4e9a06">client-updates&lt;/span>&lt;span style="color:#000;font-weight:bold">;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#204a87;font-weight:bold">set&lt;/span> &lt;span style="color:#4e9a06">vendorclass&lt;/span> &lt;span style="color:#000;font-weight:bold">=&lt;/span> &lt;span style="color:#4e9a06">option&lt;/span> &lt;span style="color:#4e9a06">vendor-class-identifier&lt;/span>&lt;span style="color:#000;font-weight:bold">;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#204a87;font-weight:bold">option&lt;/span> &lt;span style="color:#4e9a06">pxe-system-type&lt;/span> &lt;span style="color:#4e9a06">code&lt;/span> &lt;span style="color:#0000cf;font-weight:bold">93&lt;/span> &lt;span style="color:#000;font-weight:bold">=&lt;/span> &lt;span style="color:#4e9a06">unsigned&lt;/span> &lt;span style="color:#4e9a06">integer&lt;/span> &lt;span style="color:#0000cf;font-weight:bold">16&lt;/span>&lt;span style="color:#000;font-weight:bold">;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8f5902;font-style:italic">#以下是dhcp服务所能租赁的具体网段的IP信息
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8f5902;font-style:italic">&lt;/span>&lt;span style="color:#204a87;font-weight:bold">subnet&lt;/span> &lt;span style="color:#0000cf;font-weight:bold">192&lt;/span>&lt;span style="color:#4e9a06">.168.10.0&lt;/span> &lt;span style="color:#4e9a06">netmask&lt;/span> &lt;span style="color:#0000cf;font-weight:bold">255&lt;/span>&lt;span style="color:#4e9a06">.255.255.0&lt;/span> &lt;span style="color:#000;font-weight:bold">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#8f5902;font-style:italic"># 指定要分配的网关
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8f5902;font-style:italic">&lt;/span> &lt;span style="color:#204a87;font-weight:bold">option&lt;/span> &lt;span style="color:#4e9a06">routers&lt;/span> &lt;span style="color:#0000cf;font-weight:bold">192&lt;/span>&lt;span style="color:#4e9a06">.168.10.1&lt;/span>&lt;span style="color:#000;font-weight:bold">;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#8f5902;font-style:italic"># 指定要分配的DNS地址
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8f5902;font-style:italic">&lt;/span> &lt;span style="color:#204a87;font-weight:bold">option&lt;/span> &lt;span style="color:#4e9a06">domain-name-servers&lt;/span> &lt;span style="color:#0000cf;font-weight:bold">114&lt;/span>&lt;span style="color:#4e9a06">.114.114.114&lt;/span>&lt;span style="color:#000;font-weight:bold">;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#8f5902;font-style:italic"># 指定要分配的子网掩码
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8f5902;font-style:italic">&lt;/span> &lt;span style="color:#204a87;font-weight:bold">option&lt;/span> &lt;span style="color:#4e9a06">subnet-mask&lt;/span> &lt;span style="color:#0000cf;font-weight:bold">255&lt;/span>&lt;span style="color:#4e9a06">.255.255.0&lt;/span>&lt;span style="color:#000;font-weight:bold">;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#8f5902;font-style:italic"># 指定可分配的IP地址范围是从哪到哪
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8f5902;font-style:italic">&lt;/span> &lt;span style="color:#204a87;font-weight:bold">range&lt;/span> &lt;span style="color:#4e9a06">dynamic-bootp&lt;/span> &lt;span style="color:#0000cf;font-weight:bold">192&lt;/span>&lt;span style="color:#4e9a06">.168.10.100&lt;/span> &lt;span style="color:#0000cf;font-weight:bold">192&lt;/span>&lt;span style="color:#4e9a06">.168.10.254&lt;/span>&lt;span style="color:#000;font-weight:bold">;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#8f5902;font-style:italic"># 默认租赁时间，如果客户端没有请求租约，则提供默认时间，数值单位为秒
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8f5902;font-style:italic">&lt;/span> &lt;span style="color:#204a87;font-weight:bold">default-lease-time&lt;/span> &lt;span style="color:#0000cf;font-weight:bold">21600&lt;/span>&lt;span style="color:#000;font-weight:bold">;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#8f5902;font-style:italic"># 最大租赁时间，可以提供给客户端租用网络参数的最大时间，数值单位为秒
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8f5902;font-style:italic">&lt;/span> &lt;span style="color:#204a87;font-weight:bold">max-lease-time&lt;/span> &lt;span style="color:#0000cf;font-weight:bold">43200&lt;/span>&lt;span style="color:#000;font-weight:bold">;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#8f5902;font-style:italic"># PXE环境下指定的提供引导程序的服务器。i.e.该参数的值为PEX服务端的设备IP或HostName。
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8f5902;font-style:italic">&lt;/span> &lt;span style="color:#8f5902;font-style:italic"># 比如cobbler服务所在的服务器地址，或者tftp服务所在服务地址等等
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8f5902;font-style:italic">&lt;/span> &lt;span style="color:#204a87;font-weight:bold">next-server&lt;/span> &lt;span style="color:#0000cf;font-weight:bold">10&lt;/span>&lt;span style="color:#4e9a06">.10.17.15&lt;/span>&lt;span style="color:#000;font-weight:bold">;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#204a87;font-weight:bold">class&lt;/span> &lt;span style="color:#4e9a06">&amp;#34;pxeclients&amp;#34;&lt;/span> &lt;span style="color:#000;font-weight:bold">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#204a87;font-weight:bold">match&lt;/span> &lt;span style="color:#4e9a06">if&lt;/span> &lt;span style="color:#4e9a06">substring&lt;/span> &lt;span style="color:#4e9a06">(option&lt;/span> &lt;span style="color:#4e9a06">vendor-class-identifier,&lt;/span> &lt;span style="color:#0000cf;font-weight:bold">0&lt;/span>&lt;span style="color:#4e9a06">,&lt;/span> &lt;span style="color:#0000cf;font-weight:bold">9&lt;/span>&lt;span style="color:#4e9a06">)&lt;/span> &lt;span style="color:#000;font-weight:bold">=&lt;/span> &lt;span style="color:#4e9a06">&amp;#34;PXEClient&amp;#34;&lt;/span>&lt;span style="color:#000;font-weight:bold">;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#204a87;font-weight:bold">if&lt;/span> &lt;span style="color:#4e9a06">option&lt;/span> &lt;span style="color:#4e9a06">pxe-system-type&lt;/span> &lt;span style="color:#000;font-weight:bold">=&lt;/span> &lt;span style="color:#000">00&lt;/span>&lt;span style="color:#000;font-weight:bold">:&lt;/span>&lt;span style="color:#0000cf;font-weight:bold">02&lt;/span> &lt;span style="color:#000;font-weight:bold">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#204a87;font-weight:bold">filename&lt;/span> &lt;span style="color:#4e9a06">&amp;#34;ia64/elilo.efi&amp;#34;&lt;/span>&lt;span style="color:#000;font-weight:bold">;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#000;font-weight:bold">}&lt;/span> &lt;span style="color:#204a87;font-weight:bold">else&lt;/span> &lt;span style="color:#4e9a06">if&lt;/span> &lt;span style="color:#4e9a06">option&lt;/span> &lt;span style="color:#4e9a06">pxe-system-type&lt;/span> &lt;span style="color:#000;font-weight:bold">=&lt;/span> &lt;span style="color:#000">00&lt;/span>&lt;span style="color:#000;font-weight:bold">:&lt;/span>&lt;span style="color:#0000cf;font-weight:bold">06&lt;/span> &lt;span style="color:#000;font-weight:bold">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#204a87;font-weight:bold">filename&lt;/span> &lt;span style="color:#4e9a06">&amp;#34;grub/grub-x86.efi&amp;#34;&lt;/span>&lt;span style="color:#000;font-weight:bold">;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#000;font-weight:bold">}&lt;/span> &lt;span style="color:#204a87;font-weight:bold">else&lt;/span> &lt;span style="color:#4e9a06">if&lt;/span> &lt;span style="color:#4e9a06">option&lt;/span> &lt;span style="color:#4e9a06">pxe-system-type&lt;/span> &lt;span style="color:#000;font-weight:bold">=&lt;/span> &lt;span style="color:#000">00&lt;/span>&lt;span style="color:#000;font-weight:bold">:&lt;/span>&lt;span style="color:#0000cf;font-weight:bold">07&lt;/span> &lt;span style="color:#000;font-weight:bold">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#204a87;font-weight:bold">filename&lt;/span> &lt;span style="color:#4e9a06">&amp;#34;grub/grub-x86_64.efi&amp;#34;&lt;/span>&lt;span style="color:#000;font-weight:bold">;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#000;font-weight:bold">}&lt;/span> &lt;span style="color:#204a87;font-weight:bold">else&lt;/span> &lt;span style="color:#4e9a06">if&lt;/span> &lt;span style="color:#4e9a06">option&lt;/span> &lt;span style="color:#4e9a06">pxe-system-type&lt;/span> &lt;span style="color:#000;font-weight:bold">=&lt;/span> &lt;span style="color:#000">00&lt;/span>&lt;span style="color:#000;font-weight:bold">:&lt;/span>&lt;span style="color:#0000cf;font-weight:bold">09&lt;/span> &lt;span style="color:#000;font-weight:bold">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#204a87;font-weight:bold">filename&lt;/span> &lt;span style="color:#4e9a06">&amp;#34;grub/grub-x86_64.efi&amp;#34;&lt;/span>&lt;span style="color:#000;font-weight:bold">;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#000;font-weight:bold">}&lt;/span> &lt;span style="color:#204a87;font-weight:bold">else&lt;/span> &lt;span style="color:#000;font-weight:bold">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#204a87;font-weight:bold">filename&lt;/span> &lt;span style="color:#4e9a06">&amp;#34;pxelinux.0&amp;#34;&lt;/span>&lt;span style="color:#000;font-weight:bold">;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#000;font-weight:bold">}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#000;font-weight:bold">}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#000;font-weight:bold">}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8f5902;font-style:italic"># group for Cobbler DHCP tag: default
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8f5902;font-style:italic">&lt;/span>&lt;span style="color:#204a87;font-weight:bold">group&lt;/span> &lt;span style="color:#000;font-weight:bold">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#000;font-weight:bold">}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8f5902;font-style:italic">#当有其余网段需要分配时，可以继续添加相关信息
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8f5902;font-style:italic">&lt;/span>&lt;span style="color:#204a87;font-weight:bold">subnet&lt;/span> &lt;span style="color:#0000cf;font-weight:bold">10&lt;/span>&lt;span style="color:#4e9a06">.10.17.0&lt;/span> &lt;span style="color:#4e9a06">netmask&lt;/span> &lt;span style="color:#0000cf;font-weight:bold">255&lt;/span>&lt;span style="color:#4e9a06">.255.255.0&lt;/span> &lt;span style="color:#000;font-weight:bold">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#204a87;font-weight:bold">option&lt;/span> &lt;span style="color:#4e9a06">domain-name-servers&lt;/span> &lt;span style="color:#0000cf;font-weight:bold">114&lt;/span>&lt;span style="color:#4e9a06">.114.114.114&lt;/span>&lt;span style="color:#000;font-weight:bold">;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#204a87;font-weight:bold">option&lt;/span> &lt;span style="color:#4e9a06">routers&lt;/span> &lt;span style="color:#0000cf;font-weight:bold">10&lt;/span>&lt;span style="color:#4e9a06">.10.17.1&lt;/span>&lt;span style="color:#000;font-weight:bold">;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#204a87;font-weight:bold">range&lt;/span> &lt;span style="color:#4e9a06">dynamic-bootp&lt;/span> &lt;span style="color:#0000cf;font-weight:bold">10&lt;/span>&lt;span style="color:#4e9a06">.10.17.15&lt;/span> &lt;span style="color:#0000cf;font-weight:bold">10&lt;/span>&lt;span style="color:#4e9a06">.10.17.22&lt;/span>&lt;span style="color:#000;font-weight:bold">;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#204a87;font-weight:bold">option&lt;/span> &lt;span style="color:#4e9a06">subnet-mask&lt;/span> &lt;span style="color:#0000cf;font-weight:bold">255&lt;/span>&lt;span style="color:#4e9a06">.255.255.0&lt;/span>&lt;span style="color:#000;font-weight:bold">;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#204a87;font-weight:bold">next-server&lt;/span> &lt;span style="color:#0000cf;font-weight:bold">10&lt;/span>&lt;span style="color:#4e9a06">.10.17.15&lt;/span>&lt;span style="color:#000;font-weight:bold">;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#204a87;font-weight:bold">default-lease-time&lt;/span> &lt;span style="color:#0000cf;font-weight:bold">21600&lt;/span>&lt;span style="color:#000;font-weight:bold">;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#204a87;font-weight:bold">max-lease-time&lt;/span> &lt;span style="color:#0000cf;font-weight:bold">43200&lt;/span>&lt;span style="color:#000;font-weight:bold">;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#000;font-weight:bold">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>dhcp6&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-properties" data-lang="properties">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#c4a000">default-lease-time&lt;/span> &lt;span style="color:#4e9a06">600;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#c4a000">max-lease-time&lt;/span> &lt;span style="color:#4e9a06">7200;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#c4a000">log-facility&lt;/span> &lt;span style="color:#4e9a06">local7;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#c4a000">subnet6&lt;/span> &lt;span style="color:#4e9a06">2001:db8:0:1::/64 {&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#8f5902;font-style:italic"># 可以分配的地址范围&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#c4a000">range6&lt;/span> &lt;span style="color:#4e9a06">2001:db8:0:1::129 2001:db8:0:1::254;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#8f5902;font-style:italic"># 为客户端分配的临时地址&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#c4a000">range6&lt;/span> &lt;span style="color:#4e9a06">2001:db8:0:1::/64 temporary;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#8f5902;font-style:italic"># Prefix range for delegation to sub-routers&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#c4a000">prefix6&lt;/span> &lt;span style="color:#4e9a06">2001:db8:0:100:: 2001:db8:0:f00:: /56;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#8f5902;font-style:italic"># 一些可选的配置&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#c4a000">option&lt;/span> &lt;span style="color:#4e9a06">dhcp6.name-servers fec0:0:0:1::1;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#c4a000">option&lt;/span> &lt;span style="color:#4e9a06">dhcp6.domain-search &amp;#34;domain.example&amp;#34;;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#8f5902;font-style:italic"># 将 IP 地址与 MAC 绑定的示例&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#c4a000">host&lt;/span> &lt;span style="color:#4e9a06">specialclient {&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#c4a000">host-identifier&lt;/span> &lt;span style="color:#4e9a06">option dhcp6.client-id 00:01:00:01:4a:1f:ba:e3:60:b9:1f:01:23:45;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#c4a000">fixed-address6&lt;/span> &lt;span style="color:#4e9a06">2001:db8:0:1::127;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a40000"> }&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a40000">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h1 id="kea-dhcp">Kea-DHCP&lt;a class="td-heading-self-link" href="#kea-dhcp" aria-label="Heading self-link">&lt;/a>&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://www.isc.org/kea/">Kea DHCP 官网&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;h1 id="dhcrelaydhcp-中继器简介">DhcRelay(DHCP 中继器)简介&lt;a class="td-heading-self-link" href="#dhcrelaydhcp-%e4%b8%ad%e7%bb%a7%e5%99%a8%e7%ae%80%e4%bb%8b" aria-label="Heading self-link">&lt;/a>&lt;/h1>
&lt;p>DHCP Relay，DHCP 中继器，用于从没有 DHCP 服务的子网中连接到其他子网上的一个或多个 DHCP 服务器，来中继(代理、转发)DHCP 和 BOOTP 请求。它支持 DHCPv4 / BOOTP 和 DHCPv6 协议。实际应用：e.g.我有两个网段 192.168.10.0/24 和 192.168.20.0/24，在 10 网段有 DHCP 服务器，但是 20 网段没有，这时候就可以在 20 网段的设备上开启 dhcrelay 服务，然后指定一个 DHCP 服务器，来为 20 网段进行 DHCP 服务。&lt;/p>
&lt;h2 id="dhcrelay-的使用方法">dhcrelay 的使用方法&lt;a class="td-heading-self-link" href="#dhcrelay-%e7%9a%84%e4%bd%bf%e7%94%a8%e6%96%b9%e6%b3%95" aria-label="Heading self-link">&lt;/a>&lt;/h2>
&lt;h2 id="dhcrelay-命令">dhcrelay 命令&lt;a class="td-heading-self-link" href="#dhcrelay-%e5%91%bd%e4%bb%a4" aria-label="Heading self-link">&lt;/a>&lt;/h2>
&lt;p>语法格式：&lt;/p>
&lt;ul>
&lt;li>dhcrelay [ -4 ] [ -dqaD ] [ -p port ] [ -c count ] [ -A length ] [ -pf pid-file ] [ &amp;ndash;no-pid ] [ -m append | replace | forward | dis‐card ] [ -i interface0 [ &amp;hellip; -i interfaceN ] ] server0 [ &amp;hellip;serverN ]&lt;/li>
&lt;li>dhcrelay -6 [ -dqI ] [ -p port ] [ -c count ] [ -pf pid-file ] [ &amp;ndash;no-pid ] -l lower0 [ &amp;hellip; -l lowerN ] -u upper0 [ &amp;hellip; -u upperN ]&lt;/li>
&lt;/ul>
&lt;p>OPTIONS&lt;/p>
&lt;ul>
&lt;li>-i # 在指定网络接口上监听 DHCPv4 / BOOTP 查询。&lt;/li>
&lt;/ul>
&lt;p>EXAMPLE&lt;/p>
&lt;ul>
&lt;li>dhcrelay 192.168.10.12 # 在本机开启 dhcp 中继代理，指定目的 DHCP 服务器 IP 为 192.168.10.12&lt;/li>
&lt;/ul>
&lt;h1 id="dhcpv6-与-radvd">DHCPv6 与 radvd&lt;a class="td-heading-self-link" href="#dhcpv6-%e4%b8%8e-radvd" aria-label="Heading self-link">&lt;/a>&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://access.redhat.com/documentation/zh-cn/red_hat_enterprise_linux/8/html/configuring_and_managing_networking/providing-dhcp-services_configuring-and-managing-networking#comparison-of-dhcpv6-to-radvd_providing-dhcp-services">https://access.redhat.com/documentation/zh-cn/red_hat_enterprise_linux/8/html/configuring_and_managing_networking/providing-dhcp-services_configuring-and-managing-networking#comparison-of-dhcpv6-to-radvd_providing-dhcp-services&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>在 IPv6 网络中，只有路由器广告信息在 IPv6 默认网关上提供信息。因此，如果您要在需要默认网关设置的子网中使用 DHCPv6，还必须配置路由器广告服务，如 Router Advertisement Daemon（radvd）。&lt;/p>
&lt;p>radvd 服务使用路由器广告数据包中的标记声明 DHCPv6 服务器可用。&lt;/p>
&lt;p>路由器广告守护进程（radvd）发送路由器公告信息，这是 IPv6 无状态自动配置所需的。这可让用户根据这些公告自动配置其地址、设置、路由和选择默认路由器。
本节中的步骤解释了如何配置 radvd。
&lt;strong>先决条件&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>您以 root 用户身份登录。&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>流程&lt;/strong>&lt;/p>
&lt;ol>
&lt;li>安装 radvd 软件包：# yum install radvd&lt;/li>
&lt;li>编辑 /etc/radvd.conf 文件并添加以下配置：&lt;/li>
&lt;/ol>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-properties" data-lang="properties">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#c4a000">interface&lt;/span> &lt;span style="color:#4e9a06">ens3&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a40000">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#c4a000">AdvSendAdvert&lt;/span> &lt;span style="color:#4e9a06">on;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#c4a000">AdvManagedFlag&lt;/span> &lt;span style="color:#4e9a06">on;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#c4a000">AdvOtherConfigFlag&lt;/span> &lt;span style="color:#4e9a06">on;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#c4a000">prefix&lt;/span> &lt;span style="color:#4e9a06">2001:db8:0:1::/64 {&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a40000"> };&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a40000">};&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ol start="3">
&lt;li>这些设置将 radvd 配置为在 enp1s0 设备中为 2001:db8:0:1::/64 子网发送路由器广告信息。AdvManagedFlag on 设置定义客户端应该从 DHCP 服务器接收 IP 地址，AdvOtherConfigFlag 参数设置为 on 定义客户端也应该从 DHCP 服务器接收非地址信息。&lt;/li>
&lt;li>（可选）配置 radvd 会在系统引导时自动启动：# systemctl enable radvd&lt;/li>
&lt;li>启动 radvd 服务：# systemctl start radvd&lt;/li>
&lt;li>另外，还可显示路由器公告软件包的内容和配置的值 radvd 发送：# radvdump&lt;/li>
&lt;/ol>
&lt;p>&lt;strong>其它资源&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>有关配置 radvd 的详情，请查看 radvd.conf(5) man page。&lt;/li>
&lt;li>如需 radvd 的示例配置，请参阅 /usr/share/doc/radvd/radvd.conf.example 文件。&lt;/li>
&lt;/ul></description></item><item><title>Docs: FTP</title><link>https://desistdaydream.github.io/docs/4.%E6%95%B0%E6%8D%AE%E9%80%9A%E4%BF%A1/%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/FTP/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/4.%E6%95%B0%E6%8D%AE%E9%80%9A%E4%BF%A1/%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/FTP/</guid><description>
&lt;h1 id="概述">概述&lt;a class="td-heading-self-link" href="#%e6%a6%82%e8%bf%b0" aria-label="Heading self-link">&lt;/a>&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/File_Transfer_Protocol">Wiki，File_Transfer_Protocol&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>&lt;strong>File Transfer Protocol(文件传输协议，简称 FTP)&lt;/strong> 是因特网网络上历史最悠久的网络工具，从 1971 年由 A KBHUSHAN 提出第一个 FTP 的 RFC（RFC114）至今近半个世纪来，FTP 凭借其独特的优势一直都是因特网中最重要、最广泛的服务之一。&lt;/p>
&lt;p>FTP 的目标是提高文件的共享性，提供非直接使用远程计算机，使存储介质对用户透明和可靠高效地传送数据。它能操作任何类型的文件而不需要进一步处理，就像 MIME 或 Unicode 一样。但是，FTP 有着极高的延时，这意味着，从开始请求到第一次接收需求数据之间的时间，会非常长；并且不时的必须执行一些冗长的登录进程。&lt;/p></description></item><item><title>Docs: HTTP</title><link>https://desistdaydream.github.io/docs/4.%E6%95%B0%E6%8D%AE%E9%80%9A%E4%BF%A1/%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/HTTP/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/4.%E6%95%B0%E6%8D%AE%E9%80%9A%E4%BF%A1/%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/HTTP/</guid><description/></item><item><title>Docs: ICMP</title><link>https://desistdaydream.github.io/docs/4.%E6%95%B0%E6%8D%AE%E9%80%9A%E4%BF%A1/%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/ICMP/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/4.%E6%95%B0%E6%8D%AE%E9%80%9A%E4%BF%A1/%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/ICMP/</guid><description>
&lt;h1 id="概述">概述&lt;a class="td-heading-self-link" href="#%e6%a6%82%e8%bf%b0" aria-label="Heading self-link">&lt;/a>&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://mp.weixin.qq.com/s/AKiUyMbsGhOZi7cDAhSGkg">公众号,24 张图搞定 ICMP&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;h3 id="icmp">ICMP&lt;a class="td-heading-self-link" href="#icmp" aria-label="Heading self-link">&lt;/a>&lt;/h3>
&lt;p>&lt;strong>IP&lt;/strong> 是尽力传输的网络协议，提供的数据传输服务是&lt;strong>不可靠&lt;/strong>的、无连接的，不能保证数据包能成功到达目的地。那么问题来了：如何确定数据包成功到达目的地？
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/boov5o/1622087956279-d468d429-a172-4d1d-8296-bd855385f80b.png" alt="">不可靠传输
这需要一个网络层协议，提供错误检测功能和报告机制功能，于是出现了 &lt;strong>ICMP&lt;/strong>（互联网控制消息协议）。ICMP 的主要功能是，&lt;strong>确认 IP 包是否成功送达目的地址&lt;/strong>，&lt;strong>通知发送过程中 IP 包被丢弃的原因&lt;/strong>。有了这些功能，就可以检查网络是否正常、网络配置是否正确、设备是否异常等信息，方便进行&lt;strong>网络问题诊断&lt;/strong>。
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/boov5o/1622087956391-eae4cc3c-7eb0-47aa-875a-154dec57c1cf.png" alt="">ICMP 网络诊断功能
&lt;strong>举个栗子&lt;/strong>：如果在传输过程中，发生了某个错误，设备便会向源设备返回一条 ICMP 消息，告诉它发生的错误类型。
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/boov5o/1622087956489-289bd365-0f3c-4891-b798-016dcab13bb4.png" alt="">ICMP 举例
ICMP 消息是通过 IP 进行传输，但它的目的并不是让 IP 成为一种可靠的协议，而是对传输中发生的问题进行反馈。ICMP 消息的传输同样得不到可靠性保证，也有可能在传输过程中丢失。因此 ICMP 不是传输层的补充，应该把它当做&lt;strong>网络层协议&lt;/strong>。&lt;/p>
&lt;h4 id="icmp-消息封装">ICMP 消息封装&lt;a class="td-heading-self-link" href="#icmp-%e6%b6%88%e6%81%af%e5%b0%81%e8%a3%85" aria-label="Heading self-link">&lt;/a>&lt;/h4>
&lt;p>ICMP 消息使用 IP 来封装，&lt;strong>封装格式&lt;/strong>如下图。
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/boov5o/1622087956425-eb063720-58a0-4b78-bfa8-39c2e96d569d.png" alt="">ICMP 封装格式
其中 &lt;strong>type&lt;/strong>（类型）字段表示 ICMP 消息的类型，&lt;strong>code&lt;/strong>（代码）字段表示 ICMP 消息的具体含义。例如：type 值为 3 表示目的不可达消息（ Destination Unreachable Message ），若 code 值为 0 表示目的网络不可达（ Network Unreachable ）。常见的 ICMP 消息类型如下图。
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/boov5o/1622087956257-cc3d7e06-5c0f-4f20-9026-48917ba962ee.png" alt="">ICMP 消息类型
从功能上，ICMP 的消息可分为两类：一类是通知出错原因的&lt;strong>错误消息&lt;/strong>，另一类是用于诊断的&lt;strong>查询消息&lt;/strong>。
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/boov5o/1622087956583-0a4b1076-322c-4b5f-bd43-8b5364ce42a4.png" alt="">错误消息和查询消息&lt;/p>
&lt;h4 id="常见的-icmp-消息类型">常见的 ICMP 消息类型&lt;a class="td-heading-self-link" href="#%e5%b8%b8%e8%a7%81%e7%9a%84-icmp-%e6%b6%88%e6%81%af%e7%b1%bb%e5%9e%8b" aria-label="Heading self-link">&lt;/a>&lt;/h4>
&lt;ul>
&lt;li>&lt;strong>回送请求消息&lt;/strong>（ Echo Request ）：是由源设备（主机或路由器等）向一个指定的目的设备发出的请求。这种消息用来测试目的地是否可达。&lt;/li>
&lt;li>&lt;strong>回送响应消息&lt;/strong>（ Echo Reply ）：对 Echo Request 的响应。目的设备发送 Echo Reply 来响应收到的 Echo Request 。最常用的 ping 命令就是使用 Echo Request 和 Echo Reply 来实现的。&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/boov5o/1622087956612-4e223795-e42d-4c78-8be6-48000ccc7632.png" alt="">回送消息&lt;/p>
&lt;ul>
&lt;li>&lt;strong>目的不可达&lt;/strong>（ Destination Unreachable ）：路由器无法将 IP 包发送给目的地址时，会给源设备返回一个 Destination Unreachable 消息，并在消息中显示不可达的具体原因。
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/boov5o/1622087956380-16033d96-d332-4f13-9a3a-3d24a50b113d.png" alt="">目的不可达实际情况下，经常会遇到的错误代码是 1 ，表示主机不可达，它是指路由表中没有目的设备的信息，或目的设备没有连接到网络。&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/boov5o/1622087956460-afdf7e80-77ee-4e32-8e0d-749e9bc5c483.png" alt="">目的不可达类型&lt;/p>
&lt;ul>
&lt;li>&lt;strong>参数问题&lt;/strong>（ Parameter Problem ）：路由器发现 IP 包头出现错误或非法值后，向源设备发送一个 Parameter Problem 消息。这个消息包含有问题的 IP 头，或错误字段的提示信息。&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/boov5o/1622087956530-5dcf521e-a938-4961-b7b1-00d735a998b6.png" alt="">参数问题消息&lt;/p>
&lt;ul>
&lt;li>&lt;strong>重定向&lt;/strong>（ Redirect ）：如果路由器发现一条更优的路径发送数据，那么它就会返回一个 Redirect 消息给主机。这个消息包含了最合适的路由信息和源数据。
实际情况下，这种 Redirect 消息会引发路由问题，所以不进行这种设置。比如：路由器的路由表不准确时，ICMP 有可能就无法正常工作。&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/boov5o/1622087956439-255f3c69-1653-431d-81a4-9592520ed469.png" alt="">重定向&lt;/p>
&lt;ul>
&lt;li>&lt;strong>超时&lt;/strong>（ Time Exceeded ）：IP 包中有一个字段是 TTL（生存周期），它的值每经过一次路由器就减 1 ，直到减到 0 时 IP 包会被丢弃。这时，路由器会发送一个 Time Exceeded 消息给源设备，并通知 IP 包已被丢弃。
设置 TTL 的主要目的，是当路由发生环路时，避免 IP 包无休止的在网络上转发。还可以用 TTL 控制 IP 包的可达范围，比如设置一个较小的 TTL 值。&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/boov5o/1622087956563-69d4450f-834a-4f6e-9ae0-f54f6ad81866.png" alt="">超时&lt;/p>
&lt;ul>
&lt;li>&lt;strong>时间戳请求/时间戳响应&lt;/strong>（ Timestamp Request / Timestamp Reply ）：时间戳可以记录 ICMP 消息一次往返所需的时间。源设备发送一个带有发送时间的 Timestamp Request 消息，目的设备收到后，发送一个带有原设备发送时间、目的设备接收时间以及目的设备发送时间的 Timestamp Reply 消息。源设备收到 Timestamp Reply 时，并同时记录到达时间。这些时间戳可以估计网络上的传输时间。&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/boov5o/1622087956537-0334836c-2e44-4f22-83c5-b81cf4d3031a.png" alt="">时间戳&lt;/p>
&lt;h3 id="icmp-的应用">ICMP 的应用&lt;a class="td-heading-self-link" href="#icmp-%e7%9a%84%e5%ba%94%e7%94%a8" aria-label="Heading self-link">&lt;/a>&lt;/h3>
&lt;p>ICMP 被广泛应用于网络测试，最常用的 &lt;strong>ping&lt;/strong> 和 &lt;strong>tracert&lt;/strong> 网络测试工具，都是使用 ICMP 协议实现的。&lt;/p>
&lt;h4 id="ping">ping&lt;a class="td-heading-self-link" href="#ping" aria-label="Heading self-link">&lt;/a>&lt;/h4>
&lt;p>ping 是 ICMP 最著名的一个应用，通过 ping 可以&lt;strong>测试网络的可达性&lt;/strong>，即网络上的报文能否成功到达目的地。使用 ping 命令时，源设备向目的设备发送 &lt;em>Echo request&lt;/em> 消息，目的地址是目的设备的 IP 地址。目的设备收到 &lt;em>Echo request&lt;/em> 消息后，向源设备回应一个 &lt;em>Echo reply&lt;/em> 消息，可知目的设备是可达的。也可以通过 ping 命令来判断目标主机是否启用。
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/boov5o/1622087956406-67c2d46c-ad49-4904-8ead-569eaeb0ef80.png" alt="">ping
如果中间某个路由器没有到达目的网络的路由，便会向源设备回应一个 &lt;em>Destination Unreachable&lt;/em> 消息，告知目的设备不可达。
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/boov5o/1622087956546-e4b22038-cd77-4ba6-a18a-8f58b0961db2.png" alt="">ping 目的不可达
如果源主机在一定时间内无法收到回应报文，就认为目的设备不可达，并显示超时。
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/boov5o/1622087956386-8c862599-839b-4eba-a995-b9267f202d65.png" alt="">超时
需要注意的是 ping 过程是双向的消息通信，只有双向都成功传输时，才能说明通信是正常的。另外主机也可能因为防火墙拦截，导致 ping 不通。&lt;/p>
&lt;h4 id="tracert">tracert&lt;a class="td-heading-self-link" href="#tracert" aria-label="Heading self-link">&lt;/a>&lt;/h4>
&lt;p>ping 工具只能测试目的设备的连通性，但是看不到数据包的传输路径。所以在网络不通的情况下，无法知道网络问题发生在哪个位置。tracert 工具可以查看数据包的&lt;strong>整条传输路径&lt;/strong>，包括途中经过的&lt;strong>中间设备&lt;/strong>。
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/boov5o/1622087956431-46f8e00a-d012-428d-8bcc-247f97e0b7a6.png" alt="">tracert
IP 头部的 &lt;strong>TTL&lt;/strong> 字段是为避免数据包循环转发而设计的。每经过一个路由器，数据包头中的 TTL 值减 1 。如果 TTL 值为 0 则丢弃报文，并向源设备回应一个 Time Exceeded 消息，告知错误类型。tracert 就是基于 TTL 字段和 ICMP 协议实现的。在 Windows 中命令是 &lt;strong>tracert&lt;/strong> ，在 Unix 、MacOS 中命令是 &lt;strong>traceroute&lt;/strong> 。
使用 tracert 命令时，源设备的 tracert &lt;strong>逐跳发送数据包&lt;/strong>，并等待每一个响应报文。发送第一个数据包时，TTL 值设为 1 。第一个路由器收到数据包后 TTL 值减 1 ，随即丢弃数据包，并返回一个 &lt;em>Time Exceeded&lt;/em> 消息。源设备的 tracert 收到响应报文后，取出源 IP 地址，即路径上的第一个路由器地址。然后 tracert 发送一个 TTL 值为 2 的数据包。第一个路由器将 TTL 值减 1 ，并转发数据包。第二个路由器再将 TTL 值减 1 ，丢弃数据包并返回一个 &lt;em>Time Exceeded&lt;/em> 消息。tracert 收到响应报文后，取出源 IP 地址，即路径上的第二个路由器地址。类似步骤，tracert 逐跳获得每一个路由器的地址，并探测到目的设备的可达性。
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/boov5o/1622087956576-de3f09ef-891d-4830-bef8-c84ef221aac4.png" alt="">tracert
tracert 过程也是双向的消息通信，只有双向都成功传输时，才能正确探测路径。另外主机安装了防火墙，也可能造成路径探测失败。&lt;/p>
&lt;h3 id="网络实战">网络实战&lt;a class="td-heading-self-link" href="#%e7%bd%91%e7%bb%9c%e5%ae%9e%e6%88%98" aria-label="Heading self-link">&lt;/a>&lt;/h3>
&lt;h4 id="ping-1">ping&lt;a class="td-heading-self-link" href="#ping-1" aria-label="Heading self-link">&lt;/a>&lt;/h4>
&lt;p>在 Windows 电脑上使用 &lt;strong>ping&lt;/strong> 命令，并查看返回信息。
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/boov5o/1622087956590-14d0d35c-c869-48f1-be86-6ffd13a9591e.png" alt="">ping 命令
同步&lt;strong>抓包&lt;/strong>进行验证。
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/boov5o/1622087956373-656b7067-8cd6-4d87-9fcf-f18863eae6ec.png" alt="">ping 抓包
还可以直接使用 ping 命令，查看 ping 命令的&lt;strong>使用方法&lt;/strong>。
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/boov5o/1622087956428-2fb4954b-c839-4523-b3a2-ff3565ba6188.png" alt="">ping 命令用法&lt;/p>
&lt;h4 id="tracert-1">tracert&lt;a class="td-heading-self-link" href="#tracert-1" aria-label="Heading self-link">&lt;/a>&lt;/h4>
&lt;p>在 Windows 电脑上使用 &lt;strong>tracert&lt;/strong> 命令，并查看返回信息。
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/boov5o/1622087956498-ede48849-269f-4fe6-883e-1ed11215e544.png" alt="">tracert 命令
同步&lt;strong>抓包&lt;/strong>进行验证。
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/boov5o/1622087956533-997964bf-42cb-4306-92bc-11b97ccd05e9.png" alt="">tracert 抓包
也可以直接使用 tracert 命令，查看 tracert 命令的&lt;strong>使用方法&lt;/strong>。
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/boov5o/1622087956443-84a5971e-0af1-4287-b740-d0160533e903.png" alt="">tracert 用法&lt;/p>
&lt;hr>
&lt;p>&lt;strong>饮水思源：&lt;/strong>
TCP/IP 详解 卷 1：协议 - Kevin R.Fall
网络基础 - 田果
图解 TCP/IP - 竹下隆史
路由交换技术 - 杭州华三通信技术有限公司&lt;/p>
&lt;h1 id="icmpv6">ICMPv6&lt;a class="td-heading-self-link" href="#icmpv6" aria-label="Heading self-link">&lt;/a>&lt;/h1>
&lt;p>ICMPv6 是 IPv6 的基础协议之一，定义在 RFC 2463 中。用来传递报文转发中产生的信息或者错误。ICMPv6 定义的报文被广泛地应用在其他协议中，包括 NDP(邻居发现协议)、PathMTU 发现机制 等等。&lt;/p></description></item><item><title>Docs: NTP</title><link>https://desistdaydream.github.io/docs/4.%E6%95%B0%E6%8D%AE%E9%80%9A%E4%BF%A1/%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/NTP/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/4.%E6%95%B0%E6%8D%AE%E9%80%9A%E4%BF%A1/%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/NTP/</guid><description>
&lt;h1 id="概述">概述&lt;a class="td-heading-self-link" href="#%e6%a6%82%e8%bf%b0" aria-label="Heading self-link">&lt;/a>&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Network_Time_Protocol">WIki，NTP&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>&lt;strong>Network Time Protocol(网络时间协议，简称 NTP)&lt;/strong> 是在数据网络潜伏时间可变的计算机系统之间通过分组交换进行时钟同步的一个网络协议，位于 OSI 模型的应用层。自 1985 年以来，NTP 是目前仍在使用的最古老的互联网协议之一。NTP 由特拉华大学的 David L. Mills 设计。&lt;/p>
&lt;p>NTP 意图将所有参与计算机的协调世界时（UTC）时间同步到几毫秒的误差内。[1]:3 它使用 Marzullo 算法的修改版来选择准确的时间服务器，其设计旨在减轻可变网络延迟造成的影响。NTP 通常可以在公共互联网保持几十毫秒的误差，并且在理想的局域网环境中可以实现超过 1 毫秒的精度。不对称路由和拥塞控制可能导致 100 毫秒（或更高）的错误。[2][3]&lt;/p>
&lt;p>该协议通常描述为一种主从式架构，但它也可以用在点对点网络中，对等体双方可将另一端认定为潜在的时间源。[1]:20 发送和接收时间戳采用用户数据报协议（UDP）的端口 123 实现。[4][5]这也可以使用广播或多播，其中的客户端在最初的往返校准交换后被动地监听时间更新。[3]NTP 提供一个即将到来闰秒调整的警告，但不会传输有关本地时区或夏时制的信息。[2][3]&lt;/p>
&lt;p>当前协议为版本 4（NTPv4），这是一个 RFC 5905 文档中的建议标准。它向下兼容指定于 RFC 1305 的版本 3。&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/lqlu60/1616161444690-ae048176-3985-441b-86bb-8fcaf5569d90.jpeg" alt="">&lt;/p>
&lt;p>NTP 的设计者 David L. Mills。&lt;/p>
&lt;p>1979 年，网络时间同步技术在纽约的国家计算机会议上于运行在跨大西洋卫星网络的互联网服务上公开演示，这可能是该技术的首次公开演示。该技术后在 1981 年互联网工程笔记（IEN）173 中描述，并根据 RFC 778 文档开发为一个公开协议。该技术首先被部署在一个本地网络，作为 Hello 路由协议的一部分，并在 Fuzzball（一个用于网络原型的实验操作系统，已运行多年）中实现。&lt;/p>
&lt;p>现在还有其他的相关网络工具。这包括 Daytime 和 Time 协议用以记录事件时间，以及互联网控制消息协议和 IP 时间戳选项（RFC 781）。更多完整的同步系统，虽然缺乏 NTP 的数据分析和时钟规律算法，包括 Unix 守护进程 timed 在内的软件其使用选举算法为所有客户端指定服务器。以及数字时间同步服务（Digital Time Synchronization Service，DTSS）使用类似构 NTP 阶层模型的服务器层次结构。&lt;/p>
&lt;p>1985 年，NTPv0 被实现于 Fuzzball 和 Unix，文档化于 RFC 958 的 NTP 数据包头、和往返延迟和偏移计算都被留存至 NTPv4。尽管当时可用的计算机和网络相对较慢，但在跨大西洋链路上也获取了优于 100 毫秒的精度，在以太网网络上准确度为几十毫秒。&lt;/p>
&lt;p>1988 年，一个更完整的 NTPv1 协议规范及相关的算法发表在 RFC 1059。它利用了 RFC 956 的文献中的实验结果和时钟滤波算法，并是第一个描述客户端-服务器和点对点网络模型的版本。1991 年，NTPv1 架构、协议和算法通过 David L. Mills 在 IEEE Transactions on Communications 发布的一篇文章得到了工程学界的更广泛关注。&lt;/p>
&lt;p>1989 年，RFC 1119 发布通过有限状态机定义的 NTPv2，使用伪代码来描述其操作。它引入了一个管理协议和加密认证方案，它们留存至 NTPv4。社区批评 NTP 的设计缺乏形式正确性原则。他们的替代设计包括 Marzullo 算法，其修改版本已及时添加到 NTP。这个时代的大多数算法也大部分留存至 NTPv4。&lt;/p>
&lt;p>1992 年，RFC 1305 定义了 NTPv3。该 RFC 包括一个对所有错误来源的分析，从参考时钟至最终客户端，这使帮助度量和选择最佳服务器成为可能（在其中几个候选者反对的情况下）。广播模式被引入。&lt;/p>
&lt;p>在接下来的几年里，随着新特性的添加和算法的改进，显然还需要一个新的协议版本。[6]2010 年，RFC 5905 发布了一个对 NTPv4 的建议规范，但该协议自那时以来已经显著改变，截至 2014 年，更新的 RFC 尚未发布。[7]在 Mills 从特拉华大学退休后，该参考实现目前由 Harlan Stenn 保持为一个开放源代码项目。[8][9]&lt;/p>
&lt;p>时钟层[编辑]&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/lqlu60/1616161444688-dd02f9db-d4f3-4ba6-b2a1-10daf2c80df3.jpeg" alt="">&lt;/p>
&lt;p>美国海军天文台备用主时钟 Schriever AFB (Colorado)是一个第 0 层的 NTP 源&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/lqlu60/1616161444707-1f04a452-f5ae-4d30-abaa-6646e633ffa0.jpeg" alt="">&lt;/p>
&lt;p>黄色箭头表示直接连接；红色箭头表示网络连接。&lt;/p>
&lt;p>NTP 使用一个分层、半分层的时间源系统。该层次的每个级别被称为“stratum”，顶层分配为数字 0。一个通过阶层 n 同步的服务器将运行在阶层 n + 1。数字表示与参考时钟的距离，用于防止层次结构中的循环依赖性。阶层并不总是指示质量或可靠性；在阶层 3 的时间源得到比阶层 2 时间源更高的时间质量也很常见。电信系统对时钟层使用不同的定义。以下提供了阶层 0、1、2、3 的简要描述。&lt;/p>
&lt;p>阶层 0（Stratum 0）&lt;/p>
&lt;p>这些是高精度计时设备，例如原子钟（如铯、铷）、GPS 时钟或其他无线电时钟。它们生成非常精确的脉冲秒信号，触发所连接计算机上的中断和时间戳。阶层 0 设备也称为参考（基准）时钟。&lt;/p>
&lt;p>阶层 1&lt;/p>
&lt;p>这些与阶层 0 设备相连、在几微秒误差内同步系统时钟的计算机。阶层 1 服务器可能与其他阶层 1 服务器对等相连，以进行完整性检查和备份。[10]它们也被称为主要（primary）时间服务器。[2][3]&lt;/p>
&lt;p>阶层 2&lt;/p>
&lt;p>这些计算机通过网络与阶层 1 服务器同步。提供阶层 2 的计算机将查询多个阶层 1 服务器。阶层 2 计算机也可能与其他阶层 2 计算机对等相连，为对等组中的所有设备提供更健全稳定的时间。&lt;/p>
&lt;p>阶层 3&lt;/p>
&lt;p>这些计算机与阶层 2 的服务器同步。它们使用与阶层 2 相同的算法进行对等和数据采样，并可以自己作为服务器担任阶层 4 计算机，以此类推。&lt;/p>
&lt;p>阶层的上限为 15；阶层 16 被用于标识设备未同步。每台计算机上的 NTP 算法相互构造一个贝尔曼-福特算法最短路径生成树，以最小化所有客户端到阶层 1 服务器的累积往返延迟。[1]:20&lt;/p>
&lt;p>时间戳[编辑]&lt;/p>
&lt;p>NTP 使用 64 比特的时间戳，其中 32 位表示秒，32 位表示秒的小数，给出一个每 232 秒（136 年）才会翻转的时间尺度，理论分辨率 2−32 秒（233 皮秒）。NTP 以 1900 年 1 月 1 日作为开始时间，因此第一次翻转将在 2036 年 2 月 7 日发生。[11][12]&lt;/p>
&lt;p>NTP 的未来版本可能将时间表示扩展到 128 位：其中 64 位表示秒，64 位表示秒的小数。当前的 NTPv4 格式支持“时代数字”（Era Number）和“时代偏移”（Era Offset），正确使用它们应该有助于解决日期翻转问题。据 Mills 称：“64 位的秒小数足以分辨光子以光速通过电子所需的时间。64 位的秒足以提供明确的时间表示，直到宇宙变暗。”[13][note 1]&lt;/p>
&lt;p>时钟同步算法[编辑]&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/lqlu60/1616161444690-fed573bb-2fbf-45f7-b1db-69f4d664acee.jpeg" alt="">&lt;/p></description></item><item><title>Docs: RTSP</title><link>https://desistdaydream.github.io/docs/4.%E6%95%B0%E6%8D%AE%E9%80%9A%E4%BF%A1/%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/RTSP/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/4.%E6%95%B0%E6%8D%AE%E9%80%9A%E4%BF%A1/%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/RTSP/</guid><description>
&lt;h1 id="概述">概述&lt;a class="td-heading-self-link" href="#%e6%a6%82%e8%bf%b0" aria-label="Heading self-link">&lt;/a>&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Real_Time_Streaming_Protocol">Wiki，Real_Time_Streaming_Protocol&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>&lt;strong>Real Time Streaming Protocol(实时流协议，简称 RTSP)&lt;/strong> 是一种网络应用协议，专为娱乐和通信系统的使用，以控制流媒体服务器。&lt;/p></description></item><item><title>Docs: SSDP</title><link>https://desistdaydream.github.io/docs/4.%E6%95%B0%E6%8D%AE%E9%80%9A%E4%BF%A1/%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/SSDP/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/4.%E6%95%B0%E6%8D%AE%E9%80%9A%E4%BF%A1/%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/SSDP/</guid><description>
&lt;h1 id="概述">概述&lt;a class="td-heading-self-link" href="#%e6%a6%82%e8%bf%b0" aria-label="Heading self-link">&lt;/a>&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;p>-&lt;a href="https://en.wikipedia.org/wiki/Simple_Service_Discovery_Protocol">Wiki，Simple_Service_Discovery_Protocol&lt;/a>&lt;/p>
&lt;/blockquote>
&lt;p>&lt;strong>Simple Service Discovery Protocol(简单服务发现协议，简称 SSDP)&lt;/strong> 是一种基于 &lt;a href="https://desistdaydream.github.io/docs/4.%E6%95%B0%E6%8D%AE%E9%80%9A%E4%BF%A1/%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/TCP_IP/TCP_IP.md">TCP_IP&lt;/a>&lt;/p>
&lt;p>SSDP 使用 239.255.255.250 组播地址&lt;/p>
&lt;p>SSDP 是 UPnP 技术的基础。&lt;/p></description></item><item><title>Docs: SSL 与 TLS</title><link>https://desistdaydream.github.io/docs/4.%E6%95%B0%E6%8D%AE%E9%80%9A%E4%BF%A1/%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/SSL-%E4%B8%8E-TLS/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/4.%E6%95%B0%E6%8D%AE%E9%80%9A%E4%BF%A1/%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/SSL-%E4%B8%8E-TLS/</guid><description>
&lt;h1 id="概述">概述&lt;a class="td-heading-self-link" href="#%e6%a6%82%e8%bf%b0" aria-label="Heading self-link">&lt;/a>&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Transport_Layer_Security">Wiki，TLS&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>为了解决人类在互联网世界信息的安全性，所研究出来的相关技术&lt;/p>
&lt;p>安全机制：加密、数字签名、访问控制、数据完整性、认证交换、流量填充、路由控制、公证&lt;/p>
&lt;p>安全服务：认证、访问控制、数据保密性(连接保密性、无连接保密性、选择与保密性、流量保密性)、数据完整性、不可否认性&lt;/p>
&lt;h2 id="ssltls-介绍">SSL/TLS 介绍&lt;a class="td-heading-self-link" href="#ssltls-%e4%bb%8b%e7%bb%8d" aria-label="Heading self-link">&lt;/a>&lt;/h2>
&lt;p>&lt;strong>Secure Socket Layer(安全的套接字层，简称 SSL)&lt;/strong> # 一个安全协议&lt;/p>
&lt;p>&lt;strong>Transport Layer Security(传输层安全，简称 TLS)&lt;/strong># SSL3.0 的升级版&lt;/p>
&lt;p>SSL/TLS 就是在应用层与传输层中间又加了半层，应用层协议可以自行决定改层的功能，比如 http 协议用了这半层，就是 https。&lt;/p>
&lt;p>SSL/TLS 的分层设计&lt;/p>
&lt;ol>
&lt;li>最底层，基础算法原语的实现，比如 aes，rsa，md5 等&lt;/li>
&lt;li>各种算法的实现&lt;/li>
&lt;li>组合算法实现的半成品&lt;/li>
&lt;li>用各种组件拼装而成的各种成品密码学协议/软件，tls,ssh 等 openssh 也是用 openssl 实现的软件&lt;/li>
&lt;/ol>
&lt;p>&lt;strong>key(密钥)&lt;/strong> # 在密码学中，是指某个用来完成加密、解密、完整性验证等密码学应用的秘密信息。对于加密算法，key 指定明文转换成密文；对于解密算法，key 指定密文转换成明文&lt;/p>
&lt;ul>
&lt;li>&lt;strong>Plaintext or Cleartext(明文)&lt;/strong> # 在密码学中，明文是未加密的信息，可以供人类和计算机读取的信息&lt;/li>
&lt;li>&lt;strong>Ciphertext or Cyphertext(密文)&lt;/strong># 在密码学中，密文是明文通过加密算法计算后生成的人类或计算器无法读取的一种信息&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>PKI：Public Key Infrastructure(公开密钥基础建设，简称 PKI)&lt;/strong>，又称公开密钥基础架构、公钥基础建设、公钥基础设施、公开密码匙基础建设或公钥基础架构，是一组由硬件、软件、参与者、管理政策与流程组成的基础架构，其目的在于创造、管理、分配、使用、存储以及撤销数字证书。&lt;/p>
&lt;p>PKI 是借助 CA（权威数字证书颁发/认证机构）将用户的个人身份跟公开密钥链接在一起，它能够确保每个用户身份的唯一性，这种链接关系是通过注册和发布过程实现，并且根据担保级别，链接关系可能由 CA 和各种软件或在人为监督下完成。PKI 用来确定链接关系的这一角色称为 RA（Registration Authority, 注册管理中心），RA 能够确保公开密钥和个人身份链接，可以防抵赖，防篡改。在微软的公钥基础建设下，RA 又被称为 CA，目前大多数称为 CA。&lt;/p>
&lt;p>PKI 组成要素
从上面可以得知 PKI 的几个主要组成要素，用户（使用 PKI 的人或机构），认证机构（CA，颁发证书的人或机构），仓库（保存证书的数据库）等。&lt;/p>
&lt;ol>
&lt;li>签证机构：CA(Certificate authority)证书权威机构&lt;/li>
&lt;li>注册机构：RA&lt;/li>
&lt;li>证书吊销列表:CRL&lt;/li>
&lt;li>证书存取库：&lt;/li>
&lt;li>x.509：一种证书格式规范&lt;/li>
&lt;/ol>
&lt;h1 id="通信加密安全实例">通信加密安全实例&lt;a class="td-heading-self-link" href="#%e9%80%9a%e4%bf%a1%e5%8a%a0%e5%af%86%e5%ae%89%e5%85%a8%e5%ae%9e%e4%be%8b" aria-label="Heading self-link">&lt;/a>&lt;/h1>
&lt;p>甲要发送数据给乙，甲为了只让乙看到&lt;/p>
&lt;ol>
&lt;li>首先，甲用单向加密算法提取数据的特征码，然后用自己的私钥加密这段特征码，并附加在这段数据的后面。&lt;/li>
&lt;li>甲用对称密钥，把整个数据加密。再用乙的公钥加密这个对称密钥，并附加在特征码后面&lt;/li>
&lt;li>乙先用自己的私钥解密出来对称密钥是什么。再使用对称加密机制，用解密出来的对称密钥解密整个数据和加密的特征码。&lt;/li>
&lt;li>乙再对方的公钥解密特征码，得到特征码，使用同样的单向加密算法计算特征码是否一样，则说明数据完整&lt;/li>
&lt;/ol>
&lt;p>密钥交换：IKE，DH&lt;/p>
&lt;p>openSSL 与 gpg(pgp 协议)&lt;/p>
&lt;h1 id="关联文件">关联文件&lt;a class="td-heading-self-link" href="#%e5%85%b3%e8%81%94%e6%96%87%e4%bb%b6" aria-label="Heading self-link">&lt;/a>&lt;/h1>
&lt;p>Linux 发行版中，有一个目录会保存一些常见的 CA 证书，称之为[信任仓库](/docs/7.信息安全/Cryptography(密码学)/公开密钥加密/证书%20 与%20PKI.md 与 PKI.md)：&lt;/p>
&lt;ul>
&lt;li>CentOS 发行版
&lt;ul>
&lt;li>&lt;strong>/etc/pki/ca-trust/extracted/openssl/ca-bundle.trust.crt&lt;/strong> # 包含所有证书，每个证书前一行有注释&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Ubuntu 发行版
&lt;ul>
&lt;li>&lt;strong>/etc/ssl/certs/*&lt;/strong> # 该目录中一个证书一个文件&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h1 id="分类">分类&lt;a class="td-heading-self-link" href="#%e5%88%86%e7%b1%bb" aria-label="Heading self-link">&lt;/a>&lt;/h1>
&lt;p>#信息安全 #SSL #TLS&lt;/p></description></item><item><title>Docs: TCP/IP</title><link>https://desistdaydream.github.io/docs/4.%E6%95%B0%E6%8D%AE%E9%80%9A%E4%BF%A1/%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/TCP_IP/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/4.%E6%95%B0%E6%8D%AE%E9%80%9A%E4%BF%A1/%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/TCP_IP/</guid><description/></item><item><title>Docs: VRRP</title><link>https://desistdaydream.github.io/docs/4.%E6%95%B0%E6%8D%AE%E9%80%9A%E4%BF%A1/%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/VRRP/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/4.%E6%95%B0%E6%8D%AE%E9%80%9A%E4%BF%A1/%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/VRRP/</guid><description>
&lt;h1 id="概述">概述&lt;a class="td-heading-self-link" href="#%e6%a6%82%e8%bf%b0" aria-label="Heading self-link">&lt;/a>&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>&lt;strong>Virtual Router Redundancy Protocol(虚拟路由冗余协议，简称 VRRP)&lt;/strong> 是一种容错协议，其主要目的是解决路由单点故障的问题。VRRP 协议将局域网内的一组路由器虚拟为单个路由，通常将其称为一个路由备份组， 而这组路由器内包括一个 Master 路由（ 即活动路由器）和若干个 Backup 路由（即备份路由器）， VRRP 虚拟路由示意图如图 3-3 所示。在图 3-3 中 RouterA 、RouterB 和 RouterC 属于同一个 VRRP 组，组成一个虚拟路由器，而由 VRRP 协议虚拟出来的路由器拥有自己的 IP 地址 10.110.10.1 ，而备份组内的路由器也有自己的 IP 地址（如 Master 的 IP 地址为 10.110.10.5, Backup 的 IP 地址为 10.110.10.6 和 10.110.10.7）。&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/cv6gcm/1616161487047-bb1bc9ee-9e3e-40a2-9a92-403553eb3520.jpeg" alt="">&lt;/p>
&lt;ol>
&lt;li>
&lt;p>虚拟 IP：VIP，Virtual IP Address，在实际使用中，局域网内的主机仅仅知道这命虚拟路由器的 IP 地址 10 .110.10.1，而并不知道具体的 Master 路由器的 IP 地址以及 Backup 路由器的 IP 地址。局域网内的主机将自己的默认路由下一跳地址设置为该虚拟路由器的 IP 地址 10.110.10.1 之后，网络内的主机就通过这个虚拟的路由器来与其他网络进行通信。在通信过程中，如果备份组内的 Master 路由器故障，则 Backup 路由器将会通过选举机制重新选出一个新的 Master 路由器，从而继续向网络内的主机提供路由服务，最终实现了路由功能的高可用。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>此外，虚拟 IP 可以配置多个，比如 RouteA,B,C 的各个端口 1 绑定成一个 VIP1，RouteA,B,C 的各个端口 2 绑定成另一个 VIP2，RouteA,B,C 的各个端口 3 绑定成另一个 VIP3 以此类推，一组 VRRP 中，可以有多个 VIP，VIP1 的主路由是 Route1，VIP2 的主路由是 Route2，VIP3 的主路由是 Route3，各个 VIP 坏了，都可以有另外两台 Route 来代替工作，这样也解决了资源闲置问题，所有设备都是主，另外两台也是各个主设备的备设备&lt;/p>
&lt;/li>
&lt;li>
&lt;p>虚拟 MAC 地址：如果某一时刻 VIP 在 RouteA 上，当 A 坏了之后，VIP 自动转移到了 RouteB 上，但是对于后端的 Host 来说，该 VIP 所对应的 MAC 地址已经改变了，是该 VIP 所配置的物理网卡的 MAC 地址，这意味着之前 Host 已经缓存下来了这个对应规则，则再发送数据的时候，还会使用原来的 MAC，发送给坏了的 RouteA。为了解决这个情况，则可以使用虚拟 MAC 地址的方案,使用一个虚拟的 MAC 与 VIP 绑定&lt;/p>
&lt;/li>
&lt;li>
&lt;p>ARP 欺骗：当一台新设备接入网络后，可以使用自问自答方式，广播问一下“网关在哪里”，然后自己广播回答“网关在这里”，这时候，这台设备就可以拿到网关的 IP 所对应的自己的端口的 MAC 地址了&lt;/p>
&lt;/li>
&lt;li>
&lt;p>优先级：路由器开启 VRRP 功能后，会根据设定的优先级确定自己在备份组中的角色。优先级高的路由器成为 Master 路由器，优先级低的成为 Backup 路由器，并且 Master 路由器定期发送 VRRP 通告报文，通知备份组内的其他 Backup 路由器自己工作正常， 而备用路由器则启动定时器等待通告报文的到来。（如何判断 Master 路由器是否正常工作？）如果 Backup 路由器的定时器超时后仍未收到 Master 路由器发送来的 VRRP 通告报文， 则认为 Master 路由器已经故障，此时 Backup 路由器会认为自己是主用路由器（备份组内的路由器会根据优先级选举出新的 Master 路由器），并对外发送 VRRP 通告报文。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>此外， VRRP 在提高路由可靠性的同时，还简化了主机的路由配置， 在具有多播或广播能力的局域网中，借助 VRRP 能在某台路由器出现故障时仍然提供高可靠的默认链路，有效避免单一链路发生故障后网络中断的问题，并且无需修改主机动态路由协议、路由发现协议等配置信息。&lt;/p>
&lt;/li>
&lt;/ol>
&lt;h1 id="试验">试验：&lt;a class="td-heading-self-link" href="#%e8%af%95%e9%aa%8c" aria-label="Heading self-link">&lt;/a>&lt;/h1>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/cv6gcm/1616161487021-bdc76b76-08cd-4480-b281-3230f6e829a3.jpeg" alt="">&lt;/p>
&lt;p>PC11 在 VLAN10 中 192.168.10.11，PC21 在 VLAN20 中 192.168.20.21，如果让两台设备互通，那么需要通过三层路由实现&lt;/p>
&lt;p>为了实现路由冗余，在网关所在设备启 VRRP 协议，保证一个路由（网关）坏掉的情况，可以有另一个代替。&lt;/p>
&lt;p>那么首先需要在 VRRP master 和 VRRPbackup 设备上配置 VLAN10 和 VLAN20 的虚拟网关 IP，以及给每个 VLAN 配置一个 IP 以启动该 VLAN 接口，如图所示 （需要设置优先级 priority 以确保其中一台设备始终为 MASTER，优先级默认为 100）&lt;/p>
&lt;p>VRRPmaster 的配置&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/cv6gcm/1616161487070-34b33cb9-f96b-4142-934b-ad1261217e5d.jpeg" alt="">&lt;/p>
&lt;p>VRRPbackup 的配置&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/cv6gcm/1616161487028-8f6c1dca-c7d6-4dda-92cb-d00a1251a495.jpeg" alt="">&lt;/p>
&lt;p>其余基础配置：&lt;/p>
&lt;ol>
&lt;li>
&lt;p>port link-type trunk&lt;/p>
&lt;pre>&lt;code> port trunk allow-pass vlan 10 20 交换机互联端口为trunk切允许相应vlan通过
&lt;/code>&lt;/pre>
&lt;/li>
&lt;li>
&lt;p>port link-type access&lt;/p>
&lt;pre>&lt;code> port default vlan 10 指定接入层交换机接入设备端口的VLAN以实现隔离
&lt;/code>&lt;/pre>
&lt;/li>
&lt;/ol>
&lt;p>两个路由之间互相发送报文保证双方是主还是备（注：当 VRRP 两个设备互相无法收到验证报文的时候，会出现两台都是 MASTER 的情况）&lt;/p>
&lt;p>为了实现更高的冗余效果，可以在两台 VRRP 设备上增加级联线（即互联两台设备）该极连线采取链路聚合原则（上图的 23，24 口），具体配置如下：&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/cv6gcm/1616161487040-d85f0bfa-26c8-45f4-85a8-a7ab3a98234f.jpeg" alt="">&lt;/p>
&lt;p>并且使用 interface eth-trunk 1&lt;/p>
&lt;pre>&lt;code> trunkport gigabitethernet 0/0/x to 0/0/y 该命令，创建聚合端口并且把X到Y的端口都加到聚合组里去
&lt;/code>&lt;/pre></description></item><item><title>Docs: WebSocket</title><link>https://desistdaydream.github.io/docs/4.%E6%95%B0%E6%8D%AE%E9%80%9A%E4%BF%A1/%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/WebSocket/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/4.%E6%95%B0%E6%8D%AE%E9%80%9A%E4%BF%A1/%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/WebSocket/</guid><description/></item><item><title>Docs: TCP 与 HTTP</title><link>https://desistdaydream.github.io/docs/4.%E6%95%B0%E6%8D%AE%E9%80%9A%E4%BF%A1/%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/TCP-%E4%B8%8E-HTTP/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/4.%E6%95%B0%E6%8D%AE%E9%80%9A%E4%BF%A1/%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/TCP-%E4%B8%8E-HTTP/</guid><description/></item><item><title>Docs: Tunneling Protocol(隧道协议)</title><link>https://desistdaydream.github.io/docs/4.%E6%95%B0%E6%8D%AE%E9%80%9A%E4%BF%A1/%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/Tunneling-Protocol/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/4.%E6%95%B0%E6%8D%AE%E9%80%9A%E4%BF%A1/%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/Tunneling-Protocol/</guid><description/></item><item><title>Docs: WebDAV</title><link>https://desistdaydream.github.io/docs/4.%E6%95%B0%E6%8D%AE%E9%80%9A%E4%BF%A1/%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/WebDAV/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/4.%E6%95%B0%E6%8D%AE%E9%80%9A%E4%BF%A1/%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/WebDAV/</guid><description>
&lt;h1 id="概述">概述&lt;a class="td-heading-self-link" href="#%e6%a6%82%e8%bf%b0" aria-label="Heading self-link">&lt;/a>&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/WebDAV">Wiki，WebDAV&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.rfc-editor.org/rfc/rfc4918.html">RFC 4918， HTTP Extensions for Web Distributed Authoring and Versioning (WebDAV) &lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.zhihu.com/question/30719209">https://www.zhihu.com/question/30719209&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>&lt;strong>Web Distributed Authoring and Versioning(Web 分布式创作和版本控制，简称 WebDAV)&lt;/strong> 是 HTTP 的一组扩展，它允许&lt;a href="https://en.wikipedia.org/wiki/User_agent">用户代理&lt;/a>通过提供&lt;a href="https://en.wikipedia.org/wiki/Concurrency_control">并发控制&lt;/a>和&lt;a href="https://en.wikipedia.org/wiki/Namespace">命名空间操作的设施，&lt;/a>直接在 &lt;a href="https://en.wikipedia.org/wiki/Web_server">HTTP Web 服务器&lt;/a> 中协作创作内容，从而允许 Web 被视为一种 可写的、协作的 媒体，而不仅仅是一种只读媒体。WebDAV 定义在 &lt;a href="https://datatracker.ietf.org/doc/html/rfc4918">RFC 4918&lt;/a> 中&lt;/p>
&lt;p>当我们使用符合 WebDAV 标准的程序部署了服务端之后，通过客户端，就可以使用 HTTP 协议访问服务端&lt;/p>
&lt;h2 id="应用示例">应用示例&lt;a class="td-heading-self-link" href="#%e5%ba%94%e7%94%a8%e7%a4%ba%e4%be%8b" aria-label="Heading self-link">&lt;/a>&lt;/h2>
&lt;p>通过 WebDAV，可以将互联网上的网盘提供商，将自身的网盘，挂载到操作系统上，作为一个盘符&lt;/p>
&lt;p>HTTP 协议定义了几种请求: GET, POST,PUT 等用来下载文件上传数据。WebDAV 在标准的 HTTP 协议上扩展了特有的请求方式: PROPFIND, MOVE, COPY 等。 然后用这些请求，操作 web 服务器上的磁盘(像不像一个网盘！！！)&lt;/p>
&lt;p>&lt;strong>注意: 在 Nginx 等代理后面的 WebDAV 无法执行那些扩展的请求方式，比如 MOVE 等，实际情况是重命名时将会报错 &lt;code>Dir.Rename error: DirMove MOVE call failed: Bad Gateway: 502 Bad Gateway&lt;/code>，可能是因为 Nginx 不支持，具体应该如何配置解决这个问题的方法还没找到。&lt;/strong>&lt;/p></description></item></channel></rss>