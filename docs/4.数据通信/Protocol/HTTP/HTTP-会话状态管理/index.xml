<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>HTTP 的 持久化 与 认证_授权 on 断念梦的站点</title><link>https://desistdaydream.github.io/docs/4.%E6%95%B0%E6%8D%AE%E9%80%9A%E4%BF%A1/Protocol/HTTP/HTTP-%E4%BC%9A%E8%AF%9D%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86/</link><description>Recent content in HTTP 的 持久化 与 认证_授权 on 断念梦的站点</description><generator>Hugo</generator><language>zh-cn</language><atom:link href="https://desistdaydream.github.io/docs/4.%E6%95%B0%E6%8D%AE%E9%80%9A%E4%BF%A1/Protocol/HTTP/HTTP-%E4%BC%9A%E8%AF%9D%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86/index.xml" rel="self" type="application/rss+xml"/><item><title>HTTP 会话状态管理</title><link>https://desistdaydream.github.io/docs/4.%E6%95%B0%E6%8D%AE%E9%80%9A%E4%BF%A1/Protocol/HTTP/HTTP-%E4%BC%9A%E8%AF%9D%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86/HTTP-%E4%BC%9A%E8%AF%9D%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/4.%E6%95%B0%E6%8D%AE%E9%80%9A%E4%BF%A1/Protocol/HTTP/HTTP-%E4%BC%9A%E8%AF%9D%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86/HTTP-%E4%BC%9A%E8%AF%9D%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86/</guid><description>概述 参考：
HTTP 会话状态管理包含认证/授权
傻傻分不清之 Cookie、Session、Token、JWT 原文：掘金，傻傻分不清之 Cookie、Session、Token、JWT
什么是认证（Authentication） 通俗地讲就是验证当前用户的身份，证明“你是你自己”（比如：你每天上下班打卡，都需要通过指纹打卡，当你的指纹和系统里录入的指纹相匹配时，就打卡成功） 互联网中的认证： 用户名密码登录 邮箱发送登录链接 手机号接收验证码 只要你能收到邮箱/验证码，就默认你是账号的主人 什么是授权（Authorization） 用户授予第三方应用访问该用户某些资源的权限 你在安装手机应用的时候，APP 会询问是否允许授予权限（访问相册、地理位置等权限） 你在访问微信小程序时，当登录时，小程序会询问是否允许授予权限（获取昵称、头像、地区、性别等个人信息） 实现授权的方式有：cookie、session、token、OAuth 什么是凭证（Credentials） 实现认证和授权的前提 是需要一种 媒介(证书) 来标记访问者的身份 在战国时期，商鞅变法，发明了照身帖。照身帖由官府发放，是一块打磨光滑细密的竹板，上面刻有持有人的头像和籍贯信息。国人必须持有，如若没有就被认为是黑户，或者间谍之类的。 在现实生活中，每个人都会有一张专属的居民身份证，是用于证明持有人身份的一种法定证件。通过身份证，我们可以办理手机卡/银行卡/个人贷款/交通出行等等，这就是认证的凭证。 在互联网应用中，一般网站（如掘金）会有两种模式，游客模式和登录模式。游客模式下，可以正常浏览网站上面的文章，一旦想要点赞/收藏/分享文章，就需要登录或者注册账号。当用户登录成功后，服务器会给该用户使用的浏览器颁发一个令牌（token），这个令牌用来表明你的身份，每次浏览器发送请求时会带上这个令牌，就可以使用游客模式下无法使用的功能。 什么是 Cookie HTTP 是无状态的协议（对于事务处理没有记忆能力，每次客户端和服务端会话完成时，服务端不会保存任何会话信息）：每个请求都是完全独立的，服务端无法确认当前访问者的身份信息，无法分辨上一次的请求发送者和这一次的发送者是不是同一个人。所以服务器与浏览器为了进行会话跟踪（知道是谁在访问我），就必须主动的去维护一个状态，这个状态用于告知服务端前后两个请求是否来自同一浏览器。而这个状态需要通过 cookie 或者 session 去实现。 cookie 存储在客户端： cookie 是服务器发送到用户浏览器并保存在本地的一小块数据，它会在浏览器下次向同一服务器再发起请求时被携带并发送到服务器上。 cookie 是不可跨域的： 每个 cookie 都会绑定单一的域名，无法在别的域名下获取使用，一级域名和二级域名之间是允许共享使用的（靠的是 domain）。 cookie 重要的属性
name=value # 键值对，设置 Cookie 的名称及相对应的值，都必须是字符串类型- 如果值为 Unicode 字符，需要为字符编码。- 如果值为二进制数据，则需要使用 BASE64 编码。
domain # 指定 cookie 所属域名，默认是当前域名
path # 指定 cookie 在哪个路径（路由）下生效，默认是 &amp;lsquo;/&amp;rsquo;。如果设置为 /abc，则只有 /abc 下的路由可以访问到该 cookie，如：/abc/read。</description></item><item><title>Cookie AND Session</title><link>https://desistdaydream.github.io/docs/4.%E6%95%B0%E6%8D%AE%E9%80%9A%E4%BF%A1/Protocol/HTTP/HTTP-%E4%BC%9A%E8%AF%9D%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86/Cookie-AND-Session/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/4.%E6%95%B0%E6%8D%AE%E9%80%9A%E4%BF%A1/Protocol/HTTP/HTTP-%E4%BC%9A%E8%AF%9D%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86/Cookie-AND-Session/</guid><description>概述 参考：
MDN，参考-HTTP-使用 HTTP cookies Cookie HTTP Cookie（也叫 Web Cookie 或浏览器 Cookie）是服务器发送到用户浏览器并保存在本地的一小块数据。浏览器会存储 cookie 并在下次向同一服务器再发起请求时携带并发送到服务器上。通常，它用于告知服务端两个请求是否来自同一浏览器——如保持用户的登录状态。Cookie 使基于无状态的 HTTP 协议记录稳定的状态信息成为了可能。
背景
HTTP 是无状态协议，服务器不能记录浏览器的访问状态，也就是说服务器不能区分两次请求是否由同一个客户端发出 Cookie(小甜饼) 就是解决 HTTP 协议无状态的方案之一 Cookie 实际上就是服务器保存再浏览器上的一段信息。浏览器有了 Cookie 之后，每次向服务器发送请求时都会同时将该信息发送给服务器，服务器收到请求后，就可以根据该信息处理请求 Cookie 由服务器创建，并发送给浏览器，最终由浏览器保存 Cookie 的用途
保持用户登陆状态，由于不够安全，有其他方式替代，比如 JWT 等。 京东未登录的状态下，使用 Cookie 存储购物车中的物品的 淘宝不是这么实现的，淘宝必须登录才能浏览详细商品
上一次连接时打开的页面 与某个账号关联 等等 Cookie 的属性 一个 cookie 将会具有如下字段：
name # cookie 的名称 value# cookie 的值 domain # 可以访问此 cookie 的域名 path# 可以访问此 cookie 的页面路径。比如 domain 是 desistdaydream.ltd，path 是 /cookie，那么只有访问 http://desistdaydream.ltd/cookie 路径下的页面时，才可以读取此 cookie MaxAge或 Expires # 设置 cookie 持久化时的过期时长 注意：Expires 是老式的过期方法， 如果可以，应该使用 MaxAge 设置过期时间，但有些老版本的浏览器不支持 MaxAge。 如果要支持所有浏览器，要么使用 Expires，要么同时使用 MaxAge 和 Expires。 size # cookie 的大小 httpOnly # 是否允许别人通过 js 获取自己的 cookie httpOnly 属性限制了 cookie 对 HTTP 请求的作用范围。特别的，该属性指示用户代理忽略那些通过&amp;quot;非 HTTP&amp;quot; 方式对 cookie 的访问（比如浏览器暴露给 js 的接口）。 secure # 是否只能通过 https 访问 注意：</description></item><item><title>Token 与 JWT</title><link>https://desistdaydream.github.io/docs/4.%E6%95%B0%E6%8D%AE%E9%80%9A%E4%BF%A1/Protocol/HTTP/HTTP-%E4%BC%9A%E8%AF%9D%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86/Token-%E4%B8%8E-JWT/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/4.%E6%95%B0%E6%8D%AE%E9%80%9A%E4%BF%A1/Protocol/HTTP/HTTP-%E4%BC%9A%E8%AF%9D%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86/Token-%E4%B8%8E-JWT/</guid><description>概述 参考：
JWT 官网 RFC 7519 阮一峰，JSON Web Token 入门教程 JWT JSON Web Token(简称 JWT) 是目前最流行的跨域认证解决方案。JWT 是一个开放标准(RFC 7519)，定义了一种紧凑且子包含的方式，用于在各方之间以 JSON 对象的形式安全地传输信息。该信息可以被验证和信任，因为它是经过数字签名的。可以通过 RSA 或 ECDSA 这种公钥/私钥对进行签名、也可以使用 HMAC 进行签名。
背景 跨域认证的问题 互联网服务离不开用户认证。一般流程是下面这样。
用户向服务器发送用户名和密码。 服务器验证通过后，在当前对话（session）里面保存相关数据，比如用户角色、登录时间等等。 服务器向用户返回一个 session_id，写入用户的 Cookie。 用户随后的每一次请求，都会通过 Cookie，将 session_id 传回服务器。 服务器收到 session_id，找到前期保存的数据，由此得知用户的身份。 这种模式的问题在于，扩展性（scaling）不好。单机当然没有问题，如果是服务器集群，或者是跨域的服务导向架构，就要求 session 数据共享，每台服务器都能够读取 session。
举例来说，A 网站和 B 网站是同一家公司的关联服务。现在要求，用户只要在其中一个网站登录，再访问另一个网站就会自动登录，请问怎么实现？
一种解决方案是 session 数据持久化，写入数据库或别的持久层。各种服务收到请求后，都向持久层请求数据。这种方案的优点是架构清晰，缺点是工程量比较大。另外，持久层万一挂了，就会单点失败。
另一种方案是服务器索性不保存 session 数据了，所有数据都保存在客户端，每次请求都发回服务器。JWT 就是这种方案的一个代表。
JWT 的原理 JWT 的原理是，服务器认证以后，生成一个 JSON 对象，发回给用户，就像下面这样。
{ &amp;#34;姓名&amp;#34;: &amp;#34;张三&amp;#34;, &amp;#34;角色&amp;#34;: &amp;#34;管理员&amp;#34;, &amp;#34;到期时间&amp;#34;: &amp;#34;2018年7月1日0点0分&amp;#34; } 以后，用户与服务端通信的时候，都要发回这个 JSON 对象。服务器完全只靠这个对象认定用户身份。为了防止用户篡改数据，服务器在生成这个对象的时候，会加上签名（详见后文）。</description></item></channel></rss>