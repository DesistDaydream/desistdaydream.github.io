<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>HTTP on 断念梦的站点</title><link>https://desistdaydream.github.io/docs/4.%E6%95%B0%E6%8D%AE%E9%80%9A%E4%BF%A1/Protocol/HTTP/</link><description>Recent content in HTTP on 断念梦的站点</description><generator>Hugo</generator><language>zh-cn</language><atom:link href="https://desistdaydream.github.io/docs/4.%E6%95%B0%E6%8D%AE%E9%80%9A%E4%BF%A1/Protocol/HTTP/index.xml" rel="self" type="application/rss+xml"/><item><title>HTTP</title><link>https://desistdaydream.github.io/docs/4.%E6%95%B0%E6%8D%AE%E9%80%9A%E4%BF%A1/Protocol/HTTP/HTTP/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/4.%E6%95%B0%E6%8D%AE%E9%80%9A%E4%BF%A1/Protocol/HTTP/HTTP/</guid><description>概述 参考：
RFC 2616 Mozilla 官方 HTTP 开发文档 公众号-小林 coding，硬核！30 张图解 HTTP 常见的面试题 公众号-码海，51 张图助你彻底掌握 HTTP 协议 HyperText Transfer Protocol(超文本传输协议，简称 HTTP)。是基于 TCP 的用于分布式、协作式、超媒体的信息系统的应用层协议。HTTP 是 World Wide Web(万维网,简称 WWW.就是我们俗称的 Web) 的数据通信基础。
HTTP 标准的演化 参考：
InfoQ 中的消息 在 2014 年之前，HTTP/1.1 版本的标准为 RFC 2616，但由于某些原因，为了让标准更规范，HTTP/1.1 被拆分成了 6 个部分：
RFC7230 - HTTP/1.1: Message Syntax and Routing(消息语法和路由)。这里包含 低级的消息解析 和 链接管理。 RFC7231 - HTTP/1.1: Semantics and Content(语意和内容)。这里面包含了 Methods、Status Codes、Headers RFC7232 - HTTP/1.1: Conditional Requests - e.g., If-Modified-Since RFC7233 - HTTP/1.</description></item><item><title>HTTP2</title><link>https://desistdaydream.github.io/docs/4.%E6%95%B0%E6%8D%AE%E9%80%9A%E4%BF%A1/Protocol/HTTP/HTTP2/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/4.%E6%95%B0%E6%8D%AE%E9%80%9A%E4%BF%A1/Protocol/HTTP/HTTP2/</guid><description>概述 参考：
RFC，7540 官网 51 张图助你彻底掌握 HTTP 协议 https://mp.weixin.qq.com/s/a83_NE-ww36FZsy320MQFQ HTTP 2.0 在性能上实现了很大的飞跃，更难得的是它在改进的同时保持了语义的不变，与 HTTP 1.1 的语义完全相同！比如请求方法、URI、状态码、头字段等概念都保留不变，这样就消除了再学习的成本，在我们的日常软件升级中，向下兼容非常重要，也是促进产品大规模使用的一个前提，不然你一升级，各种接口之类的全换了，谁还敢升。 HTTP 2.0 只在语法上做了重要改进，完全变更了 HTTP 报文的传输格式
在语法上主要实现了以下改造
1、头部压缩 HTTP 1.1 考虑了 body 的压缩，但没有考虑 header 的压缩, 经常出现传了头部上百，上千字节，但 Body 却只有几十字节的情况，浪费了带宽，而且我们知道从 1.1 开始默认是长连接，几百上千个请求都用的这个连接，而请求的头部很多都是重复的，造成了带宽的极大浪费!想象一下面的这个请求，为了传输区区 「name=michale 」这几个字节，却要传输如此巨量的头部，浪费的带宽确实惊人。
那么 HTTP 2.0 是如何解决的呢？它开发了专门的 「HPACK」算法，在客户端和服务器两端建立字典，用索引号表示重复的字符串，还采用哈夫曼编码来压缩数字和整数，可以达到最高达 90% 的压缩率
这里简单解释下，头部压缩需要在支持 HTTP 2.0 的客户端和服务器之间：
维护一份静态的字典（Static table），包含常见的头部名称，以及特别常见的头部名称与值的组合。这样的话如果请求响应命中了静态字典，直接发索引号即可 维护一份相同的动态字典（Dynamic table），可以动态地添加字典，这样的话如果客户端首次请求由于「User-Agent: xxx」,「host:xxx」,「Cookie」这些的动态键值对没有命中静态字典，还是会传给服务器，但服务器收到后会基于传过来的键值对创建动态字典条目，如上图的「User-Agent: xxx」对应数字 62，「host:xxx」对应数字 63，这样双方都创建动态条目后，之后就可以用只传 62，63 这样的索引号来通信了！显而易见，传输数据急遽降低，极大地提升了传输效率！需要注意的是动态字典是每个连接自己维护的，也就是对于每个连接而言，首次都必须发送动态键值对 支持基于静态哈夫曼码表的哈夫曼编码（Huffman Coding）：对于静态、动态字典中不存在的内容，可以使用哈夫曼编码来减小体积。HTTP/2 使用了一份静态哈夫曼码表（详见），也需要内置在客户端和服务端之中。 2、二进制格式 HTTP 1.1 是纯文本形式，而 2.0 是完全的二进制形式，它把 TCP 协议的部分特性挪到了应用层，把原来的 Header+Body 消息打散为了数个小版的二进制&amp;quot;帧&amp;quot;（Frame）,“HEADERS”帧存放头数据、“DATA”帧存放实体数据</description></item><item><title>HTTP3</title><link>https://desistdaydream.github.io/docs/4.%E6%95%B0%E6%8D%AE%E9%80%9A%E4%BF%A1/Protocol/HTTP/HTTP3/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/4.%E6%95%B0%E6%8D%AE%E9%80%9A%E4%BF%A1/Protocol/HTTP/HTTP3/</guid><description>概述 参考：
Wiki, HTTP/3 HTTP/3 是用于在万维网上交换信息的超文本传输​​协议的第三个主要版本，是对广泛部署的 HTTP/1.1 和 HTTP/2 的补充。与之前依赖完善的 TCP（于 1974 年发布）的版本不同，HTTP/3 使用 QUIC（于 2021 年正式引入），一种基于 UDP 构建的多路复用传输协议。</description></item><item><title>URL 与 URI</title><link>https://desistdaydream.github.io/docs/4.%E6%95%B0%E6%8D%AE%E9%80%9A%E4%BF%A1/Protocol/HTTP/URL-%E4%B8%8E-URI/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/4.%E6%95%B0%E6%8D%AE%E9%80%9A%E4%BF%A1/Protocol/HTTP/URL-%E4%B8%8E-URI/</guid><description>概述 参考：
Wiki, URI Wiki, IRI Wiki, URL Wiki, CleanURL-slug Wiki, URL encoding RFC 3986, Uniform Resource Identifier(URI): Generic Syntax RFC 1738, Uniform Resource Locators (URL) https://www.ruanyifeng.com/blog/2010/02/url_encoding.html 既然 HTTP 的本质是是在两点之间传输超文本，那么这个超文本又该如何表示呢？我们应该如何正确得找到这个超文本呢？所以，人们将超文本描述为 Resource(资源)，互联网上如此之多得资源，就需要一个唯一标识符来标识每一个资源。URI 就是这么一个用来标识资源的规范。
Uniform Resource Identifier(统一资源标识符，简称 URI) 是 Web 技术使用的唯一标识符。URI 可以用于标识任何东西，包括现实世界中的对象，例如人和地方，概念或信息资源，例如网页和书籍。某些 URI 提供了一种在网络上(在 Internet 上或在另一个专用网络上，例如在计算机文件系统或 Intranet 上)定位和检索信息资源的方法，它们是 Uniform Resource Locator(统一资源定位符，简称 URL)。而其他 URI 仅提供一个唯一名称，而没有找到或检索该资源的信息，这类 URI 被称为 Uniform Resource Name(统一资源名称，简称 URN)。
尽管 URI 仍然是常用术语，但定义 URI 的规范已经被 Internationalized Resource Identifiers(国际化资源标识符，简称 IRI) 的规范所取代。IRI 扩展了 URI 的定义，以便 IRI 可以处理诸如 Kanji(汉字) 之类的字符集，而不是仅限于 ASCII。</description></item><item><title>HTTP Header</title><link>https://desistdaydream.github.io/docs/4.%E6%95%B0%E6%8D%AE%E9%80%9A%E4%BF%A1/Protocol/HTTP/HTTP-Header/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/4.%E6%95%B0%E6%8D%AE%E9%80%9A%E4%BF%A1/Protocol/HTTP/HTTP-Header/</guid><description>概述 参考：
RFC 2616-Message Headers RFC 7231，第五章-请求头字段 RFC 7231，第七章-响应头字段 MDN，参考-HTTP-HTTP 头 这是一个全部可用的标准 Header 列表 Wiki, List of HTTP header fields 一般情况下，在打开浏览器按的开发者工具（一般为 F12 键）后，查看到的首部大部分都是请求和响应首部,这俩首部的信息通常包含了通用首部中的信息
HTTP 请求和响应报文的 Header(头) 基本都是 Key/Value Pair(键/值对) 格式的 Field(字段)，每个字段都是以冒号分割的 键/值对。此外，除了标准的 Header 字段之外，还可以添加自定义 Header，这就给 HTTP 带来了无限的扩展可能。注意，Key 不区分大小写。
自定义 Header 历来以 X- 开头，但是该约定在 2012 年 6 月被弃用，因为它在非标准字段成为标准字段时会造成不必要的麻烦，详见 RFC 6648。IANA 维护了一个通用的 HTTP Header 列表，其中包括 RFC 中定义的标准头以及不在 RFC 中定义的扩展头；并且在同一个页面还有新的提议增加的 HTTP Header 列表。
HTTP(RFC 2616 版本) 规定了非常多的 Header 字段，可以实现各种各样的功能，但基本上可以分为以下几类
General Header(通用头) # 在请求头和响应头里都可以出现； Request Header(请求头) # 仅能出现在请求头里，进一步说明请求信息或者额外的附加条件； Response Header(响应头) # 仅能出现在响应头里，补充说明响应报文的信息； Entity Header(实体头) # 它实际上属于通用字段，但专门描述 body 的额外信息。 Extension Header(扩展头) # 不在标准规范中，可以通过自定义头实现更多定制化需求的 Header 信息。 对 HTTP 报文的解析和处理其实本质上就是对头字段的处理，HTTP 的连接管理，缓存控制，内容协商等都是通过头字段来处理的，理解了头字段，基本上也就理解了 HTTP，所以理解头字段非常重要。</description></item><item><title>HTTP Status Codes</title><link>https://desistdaydream.github.io/docs/4.%E6%95%B0%E6%8D%AE%E9%80%9A%E4%BF%A1/Protocol/HTTP/HTTP-Status-Codes/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/4.%E6%95%B0%E6%8D%AE%E9%80%9A%E4%BF%A1/Protocol/HTTP/HTTP-Status-Codes/</guid><description>概述 参考：
RFC 7231,第六章-响应状态码 HTTP 的 Status 状态码和 Reason-Phrase 原因短语 常用 200,301,302,304,401,403,404,500,502
HTTP 常见的状态码 五大类 HTTP 状态码 1xx
1xx 类状态码属于提示信息，是协议处理中的一种中间状态，实际用到的比较少。
2xx
2xx 类状态码表示服务器成功处理了客户端的请求，也是我们最愿意看到的状态。
「200 OK」是最常见的成功状态码，表示一切正常。如果是非 HEAD 请求，服务器返回的响应头都会有 body 数据。
「204 No Content」也是常见的成功状态码，与 200 OK 基本相同，但响应头没有 body 数据。
「206 Partial Content」是应用于 HTTP 分块下载或断点续传，表示响应返回的 body 数据并不是资源的全部，而是其中的一部分，也是服务器处理成功的状态。
3xx
3xx 类状态码表示客户端请求的资源发送了变动，需要客户端用新的 URL 重新发送请求获取资源，也就是重定向。
「301 Moved Permanently」表示永久重定向，说明请求的资源已经不存在了，需改用新的 URL 再次访问。
「302 Found」表示临时重定向，说明请求的资源还在，但暂时需要用另一个 URL 来访问。
301 和 302 都会在响应头里使用字段 Location，指明后续要跳转的 URL，浏览器会自动重定向新的 URL。
「304 Not Modified」不具有跳转的含义，表示资源未修改，重定向已存在的缓冲文件，也称缓存重定向，用于缓存控制。
4xx
4xx 类状态码表示客户端发送的报文有误，服务器无法处理，也就是错误码的含义。</description></item><item><title>HTTP 的实现</title><link>https://desistdaydream.github.io/docs/4.%E6%95%B0%E6%8D%AE%E9%80%9A%E4%BF%A1/Protocol/HTTP/HTTP-%E7%9A%84%E5%AE%9E%E7%8E%B0/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/4.%E6%95%B0%E6%8D%AE%E9%80%9A%E4%BF%A1/Protocol/HTTP/HTTP-%E7%9A%84%E5%AE%9E%E7%8E%B0/</guid><description>HTTP 服务器的程序(想提供 web 服务必须要安装一下程序中的一个)
httpd(apache) nginx lighttpd 应用程序服务器：上面的程序如果不附加插件则只支持静态的网页，装上下面的程序还能解析 PHP 等动态界面 IIS tomcat，jetty，就 boss，resin webshpere,weblogic,oc4j httpd apache(a patchy server)的特性
高度模块化：core+modules DSO：Dynamic Shared Object MPM：Multipath Processing Modules 多路处理模块，不同的工作方式，可以切换，使用不同模块可以满足不同需求 prefork：多进程模型，每个进程响应一个请求 一个主进程：负责生成 n 个子近侧很难过，子进程也成为工作进程，每个子进程处理一个用户请求，即便没有用户请求，也会预先生成多个空闲进程，随时等待请求到达，最大不超过 1024 个 worker：多线程模型 一个主进程：负责生成子进程；负责创建套接字；负责接收请求，并将其派发给某子进程进行处理； 多个子进程：每个子进程负责生成多个线程； 每个线程：负责响应用户请求； 并发响应数量：m*n m：子进程数量 n：每个子进程所能创建的最大线程数量； event：事件驱动模型，多进程模型，每个进程响应多个请求（老版本系统不支持，systemd 系统支持） 一个主进程 ：负责生成子进程；负责创建套接字；负责接收请求，并将其派发给某子进程进行处理； 子进程：基于事件驱动机制直接响应多个请求； Httpd 配置 程序环境(.init 系统下)
配置文件 /etc/httpd/conf/httpd.conf /etc/httpd/conf.d/*.conf 服务脚本 /etc/rc.d/init.d/httpd 配置文件/etc/sysconfig/httpd 主程序文件 /usr/sbin/httpd /usr/sbin/httpd.event /usr/sbin/httpd.worker 日志文件目录 /var/log/httpd access_log:访问日志 error_log:错误日志 站点文档目录 /var/www/html</description></item></channel></rss>