<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>断念梦的站点 – HTTP</title><link>https://desistdaydream.github.io/docs/4.%E6%95%B0%E6%8D%AE%E9%80%9A%E4%BF%A1/Protocol/HTTP/</link><description>Recent content in HTTP on 断念梦的站点</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><atom:link href="https://desistdaydream.github.io/docs/4.%E6%95%B0%E6%8D%AE%E9%80%9A%E4%BF%A1/Protocol/HTTP/index.xml" rel="self" type="application/rss+xml"/><item><title>Docs: HTTP</title><link>https://desistdaydream.github.io/docs/4.%E6%95%B0%E6%8D%AE%E9%80%9A%E4%BF%A1/Protocol/HTTP/HTTP/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/4.%E6%95%B0%E6%8D%AE%E9%80%9A%E4%BF%A1/Protocol/HTTP/HTTP/</guid><description>
&lt;h1 id="概述">概述&lt;a class="td-heading-self-link" href="#%e6%a6%82%e8%bf%b0" aria-label="Heading self-link">&lt;/a>&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://tools.ietf.org/html/rfc2616">RFC 2616&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://developer.mozilla.org/en-US/docs/Web/HTTP">Mozilla 官方 HTTP 开发文档&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://mp.weixin.qq.com/s/bUy220-ect00N4gnO0697A">公众号-小林 coding，硬核！30 张图解 HTTP 常见的面试题&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://mp.weixin.qq.com/s/WQpxfwLArltKEjEAdOO2Pw">公众号-码海，51 张图助你彻底掌握 HTTP 协议&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>&lt;strong>HyperText Transfer Protocol(超文本传输协议，简称 HTTP)&lt;/strong>。是基于 TCP 的用于分布式、协作式、超媒体的信息系统的应用层协议。HTTP 是 &lt;a href="https://en.wikipedia.org/wiki/World_Wide_Web">World Wide Web(万维网,简称 WWW.就是我们俗称的 Web)&lt;/a> 的数据通信基础。&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/rlkp9t/1616161240441-f2958719-b738-4698-9fca-64d90f3471ba.png" alt="">&lt;/p>
&lt;h2 id="http-标准的演化">HTTP 标准的演化&lt;a class="td-heading-self-link" href="#http-%e6%a0%87%e5%87%86%e7%9a%84%e6%bc%94%e5%8c%96" aria-label="Heading self-link">&lt;/a>&lt;/h2>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://www.infoq.cn/article/2014/06/http-11-updated">InfoQ 中的消息&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>在 2014 年之前，HTTP/1.1 版本的标准为 &lt;a href="https://tools.ietf.org/html/rfc2616">RFC 2616&lt;/a>，但由于&lt;a href="https://tools.ietf.org/html/rfc7230#appendix-A.2">某些原因&lt;/a>，为了让标准更规范，HTTP/1.1 被拆分成了 6 个部分：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://tools.ietf.org/html/rfc7230">RFC7230 - HTTP/1.1&lt;/a>: Message Syntax and Routing(消息语法和路由)。这里包含 低级的消息解析 和 链接管理。&lt;/li>
&lt;li>&lt;a href="https://tools.ietf.org/html/rfc7231">RFC7231 - HTTP/1.1&lt;/a>: Semantics and Content(语意和内容)。这里面包含了 Methods、Status Codes、Headers&lt;/li>
&lt;li>RFC7232 - HTTP/1.1: Conditional Requests - e.g., If-Modified-Since&lt;/li>
&lt;li>RFC7233 - HTTP/1.1: Range Requests - getting partial content&lt;/li>
&lt;li>RFC7234 - HTTP/1.1: Caching - browser and intermediary caches&lt;/li>
&lt;li>RFC7235 - HTTP/1.1: Authentication - a framework for HTTP authentication&lt;/li>
&lt;/ul>
&lt;h2 id="http-三个部分">HTTP 三个部分&lt;a class="td-heading-self-link" href="#http-%e4%b8%89%e4%b8%aa%e9%83%a8%e5%88%86" aria-label="Heading self-link">&lt;/a>&lt;/h2>
&lt;h3 id="1-协议">1. 「协议」&lt;a class="td-heading-self-link" href="#1-%e5%8d%8f%e8%ae%ae" aria-label="Heading self-link">&lt;/a>&lt;/h3>
&lt;p>在生活中，我们也能随处可见「协议」，例如：&lt;/p>
&lt;ul>
&lt;li>刚毕业时会签一个「三方协议」；&lt;/li>
&lt;li>找房子时会签一个「租房协议」；&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/rlkp9t/1616161240448-b1263f75-a700-4431-9d6b-a99b36a58214.png" alt="">&lt;/p>
&lt;p>三方协议和租房协议&lt;/p>
&lt;p>生活中的协议，本质上与计算机中的协议是相同的，协议的特点:&lt;/p>
&lt;ul>
&lt;li>「&lt;strong>协&lt;/strong>」字，代表的意思是必须有&lt;strong>两个以上的参与者&lt;/strong>。例如三方协议里的参与者有三个：你、公司、学校三个；租房协议里的参与者有两个：你和房东。&lt;/li>
&lt;li>「&lt;strong>议&lt;/strong>」字，代表的意思是对参与者的一种&lt;strong>行为约定和规范&lt;/strong>。例如三方协议里规定试用期期限、毁约金等；租房协议里规定租期期限、每月租金金额、违约如何处理等。&lt;/li>
&lt;/ul>
&lt;p>针对 HTTP &lt;strong>协议&lt;/strong>，我们可以这么理解。&lt;/p>
&lt;p>HTTP 是一个用在计算机世界里的&lt;strong>协议&lt;/strong>。它使用计算机能够理解的语言确立了一种计算机之间交流通信的规范（&lt;strong>两个以上的参与者&lt;/strong>），以及相关的各种控制和错误处理方式（&lt;strong>行为约定和规范&lt;/strong>）。&lt;/p>
&lt;h3 id="2-传输">2. 「传输」&lt;a class="td-heading-self-link" href="#2-%e4%bc%a0%e8%be%93" aria-label="Heading self-link">&lt;/a>&lt;/h3>
&lt;p>所谓的「传输」，很好理解，就是把一堆东西从 A 点搬到 B 点，或者从 B 点 搬到 A 点。&lt;/p>
&lt;p>别轻视了这个简单的动作，它至少包含两项重要的信息。&lt;/p>
&lt;p>HTTP 协议是一个&lt;strong>双向协议&lt;/strong>。&lt;/p>
&lt;p>我们在上网冲浪时，浏览器是请求方 A ，百度网站就是应答方 B。双方约定用 HTTP 协议来通信，于是浏览器把请求数据发送给网站，网站再把一些数据返回给浏览器，最后由浏览器渲染在屏幕，就可以看到图片、视频了。
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/rlkp9t/1616161240434-514ef4d5-6830-46f1-9674-7c6564798dfd.png" alt="">&lt;/p>
&lt;p>Request(请求) - (Response)应答&lt;/p>
&lt;p>数据虽然是在 A 和 B 之间传输，但允许中间有&lt;strong>中转或接力&lt;/strong>。&lt;/p>
&lt;p>就好像第一排的同学想传递纸条给最后一排的同学，那么传递的过程中就需要经过好多个同学（中间人），这样的传输方式就从「A &amp;lt; &amp;mdash; &amp;gt; B」，变成了「A &amp;lt;-&amp;gt; N &amp;lt;-&amp;gt; M &amp;lt;-&amp;gt; B」。&lt;/p>
&lt;p>而在 HTTP 里，需要中间人遵从 HTTP 协议，只要不打扰基本的数据传输，就可以添加任意额外的东西。&lt;/p>
&lt;p>针对&lt;strong>传输&lt;/strong>，我们可以进一步理解了 HTTP。&lt;/p>
&lt;p>HTTP 是一个在计算机世界里专门用来在&lt;strong>两点之间传输数据&lt;/strong>的约定和规范。&lt;/p>
&lt;h3 id="3-超文本">3. 「超文本」&lt;a class="td-heading-self-link" href="#3-%e8%b6%85%e6%96%87%e6%9c%ac" aria-label="Heading self-link">&lt;/a>&lt;/h3>
&lt;p>HTTP 传输的内容是「超文本」。&lt;/p>
&lt;p>我们先来理解「文本」，在互联网早期的时候只是简单的字符文字，但现在「文本」的涵义已经可以扩展为图片、视频、压缩包等，在 HTTP 眼里这些都算作「文本」。&lt;/p>
&lt;p>再来理解「超文本」，它就是&lt;strong>超越了普通文本的文本&lt;/strong>，它是文字、图片、视频等的混合体，最关键有超链接，能从一个超文本跳转到另外一个超文本。&lt;/p>
&lt;p>HTML 格式的文件就是最常见的超文本了，它本身只是纯文字文件，但内部用很多标签定义了图片、视频等的链接，再经过浏览器的解释，呈现给我们的就是一个文字、有画面的网页了。&lt;/p>
&lt;h2 id="总结">总结&lt;a class="td-heading-self-link" href="#%e6%80%bb%e7%bb%93" aria-label="Heading self-link">&lt;/a>&lt;/h2>
&lt;p>OK，经过了对 HTTP 里这三个名词的详细解释，就可以给出比「超文本传输协议」这七个字更准确更有技术含量的答案：&lt;/p>
&lt;p>&lt;strong>HTTP 是一个在计算机世界里专门在「两点」之间「传输」文字、图片、音频、视频等「超文本」数据的「约定和规范」。&lt;/strong>&lt;/p>
&lt;blockquote>
&lt;p>这里的两点可以是服务器到本地电脑，本地电脑到服务器、服务器到服务器、电脑到电脑，等等。&lt;/p>
&lt;/blockquote>
&lt;h1 id="http-请求过程概述">HTTP 请求过程概述&lt;a class="td-heading-self-link" href="#http-%e8%af%b7%e6%b1%82%e8%bf%87%e7%a8%8b%e6%a6%82%e8%bf%b0" aria-label="Heading self-link">&lt;/a>&lt;/h1>
&lt;p>HTTP 事务由一次 &lt;strong>Client 的 Request(请求)&lt;/strong> 和 &lt;strong>Server 的 Response(响应)&lt;/strong> 组成。&lt;/p>
&lt;p>HTTP 是一个客户端—服务器协议：请求由一个实体，即 &lt;strong>User Agent(用户代理)&lt;/strong>，或是一个可以代表它的代理方（proxy）发出。大多数情况下，这个&lt;strong>用户代理都是一个网页浏览器&lt;/strong>，不过它也可能是任何东西，比如一个爬取网页来充实、维护搜索引擎索引的机器爬虫（其实就是代码写的具有发起 HTTP 请求的程序，毕竟浏览器也是代码写的）。&lt;/p>
&lt;blockquote>
&lt;p>之所以用 &lt;a href="https://desistdaydream.github.io/docs/Web/Web.md#Glossary(%E6%9C%AF%E8%AF%AD)">用户代理&lt;/a> 这个词，早期主要是用来描述实体的，发起请求的行为应该是用户操作的，而代替用户发起请求的，就是 用户的代理 了嘛。。。早期一般没有爬虫之类的东西，都是用户使用浏览器这个用户代理发起请求的。&lt;/p>
&lt;/blockquote>
&lt;p>每个请求都会被发送到一个服务端，它会处理这个请求并提供一个称作 &lt;em>响应&lt;/em> 的回复。在客户端与服务端之间，还有许许多多的被称为&lt;a href="https://developer.mozilla.org/zh-CN/docs/Glossary/Proxy_server">代理&lt;/a>的实体，履行不同的作用，例如充当网关或&lt;a href="https://developer.mozilla.org/zh-CN/docs/Glossary/Cache">缓存&lt;/a>。&lt;/p>
&lt;h2 id="http-的无状态">HTTP 的无状态&lt;a class="td-heading-self-link" href="#http-%e7%9a%84%e6%97%a0%e7%8a%b6%e6%80%81" aria-label="Heading self-link">&lt;/a>&lt;/h2>
&lt;p>HTTP 协议是 Stateless(无状态)。(因为连接一次后就断开了，不会持久化存储任何数据)&lt;/p>
&lt;p>比如一个用户(Client 客户端)向服务器发起了一个请求，请求一个页面，在该页面输入完用户名和密码后进行登录后，如果刷新页面，那么就需要重新输入用户名和密码，因为 client 向 server 只请求了一个页面，请求完成后，连接就断开了，后续的请求是新的，没法再用以前的信息。这时候为了解决该问题，引用了 Cookie 和 Session 保持 的概念。&lt;/p>
&lt;p>相关技术&lt;/p>
&lt;ul>
&lt;li>Cookie：类似于 Token，相当于一个令牌，当访问一个 web server 的时候，server 发给 client 一个 Cookie，让 client 保存在本地，再次访问的时候，即可通过该 Cookie 识别身份&lt;/li>
&lt;li>Session(会话)保持：关联至 Cookie：当你在动态网页上访问了一些信息，比如购物车，在购物车添加一件物品，即通过 Session 功能来保存该信息，以便下次登录还能使用。否则下次登录购物车中的东西就没了&lt;/li>
&lt;/ul>
&lt;h2 id="流程简述">流程简述&lt;a class="td-heading-self-link" href="#%e6%b5%81%e7%a8%8b%e7%ae%80%e8%bf%b0" aria-label="Heading self-link">&lt;/a>&lt;/h2>
&lt;ul>
&lt;li>建立或处理连接，接收请求或拒绝请求
&lt;ul>
&lt;li>建立 TCP 连接，WEB 浏览器向 Web 服务器发送请求&lt;/li>
&lt;li>web 浏览器发送请求头部信息
&lt;ul>
&lt;li>建立连接后，客户机发送一个请求给服务器，请求方式的格式为：URL、协议版本号、后面是 MIME 信息包括请求修饰符、客户机信息和可能得内容&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Server 接收请求，并应答
&lt;ul>
&lt;li>WEB 服务器接收到请求后，给予相应的响应信息，其格式为一个状态行，包括信息的协议版本号、一个成功或错误的代码，后边是 MIME 信息包括服务器信息、实体信息和可能得内容&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Server 处理请求
&lt;ul>
&lt;li>Web 服务器发送应答头信息&lt;/li>
&lt;li>Web 服务器向浏览器发送数据&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Client 访问资源
&lt;ul>
&lt;li>WEB 服务器关闭 TCP 连接&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>构建响应报文&lt;/li>
&lt;li>发送响应报文&lt;/li>
&lt;li>记录日志&lt;/li>
&lt;/ul>
&lt;h1 id="http-报文格式">HTTP 报文格式&lt;a class="td-heading-self-link" href="#http-%e6%8a%a5%e6%96%87%e6%a0%bc%e5%bc%8f" aria-label="Heading self-link">&lt;/a>&lt;/h1>
&lt;h2 id="request-与-response-报文">Request 与 Response 报文&lt;a class="td-heading-self-link" href="#request-%e4%b8%8e-response-%e6%8a%a5%e6%96%87" aria-label="Heading self-link">&lt;/a>&lt;/h2>
&lt;h3 id="request-请求报文">Request 请求报文&lt;a class="td-heading-self-link" href="#request-%e8%af%b7%e6%b1%82%e6%8a%a5%e6%96%87" aria-label="Heading self-link">&lt;/a>&lt;/h3>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/rlkp9t/1616161240468-d9f13310-3f67-43b8-b5b7-b48dde683170.png" alt="">&lt;/p>
&lt;ul>
&lt;li>&lt;strong>Method&lt;/strong> # 请求方法，用于表明 Client 希望 Server 对 Resource 执行的动作。常用：GET、POST、DELETE&lt;/li>
&lt;li>&lt;strong>URL&lt;/strong> # HTTP 请求的 URL。
&lt;ul>
&lt;li>&lt;strong>Params&lt;/strong> # URL 参数。就是 URL 中的 Query 部分&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>Version&lt;/strong> # 发送给 Server 的请求的 HTTP 协议版本。&lt;/li>
&lt;li>&lt;strong>Headers&lt;/strong> # 请求头。&lt;/li>
&lt;li>&lt;strong>Body&lt;/strong> # 请求体。&lt;/li>
&lt;/ul>
&lt;blockquote>
&lt;p>这里面有一个要注意的地方，就是 Params 与 Headers，&lt;strong>Params 是 URL 的一部分&lt;/strong>，但是 Headers 不是。虽然两者的作用类似，都是用来定义这个请求中应该发送给对方的一些基本信息、认证信息 等等。但是在一个 HTTP 的请求中，两者所处的位置是不一样，用于不同场景。&lt;/p>
&lt;/blockquote>
&lt;p>&lt;strong>Authorization&lt;/strong> # 认证信息。这是一个比较特殊的东西，可以存在于 URL 的 Params 中、Headers 中、Body 中。请求报文的各个部分，都可以填写认证信息。&lt;/p>
&lt;ul>
&lt;li>当 Server 需要一个认证信息时，就需要在 HTTP 请求中加入认证相关的信息。&lt;/li>
&lt;/ul>
&lt;h4 id="example">EXAMPLE&lt;a class="td-heading-self-link" href="#example" aria-label="Heading self-link">&lt;/a>&lt;/h4>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/rlkp9t/1616161240442-63d3fc7f-80c2-43e4-bec5-50061f2e02f2.png" alt="">&lt;/p>
&lt;h3 id="response-响应报文">Response 响应报文&lt;a class="td-heading-self-link" href="#response-%e5%93%8d%e5%ba%94%e6%8a%a5%e6%96%87" aria-label="Heading self-link">&lt;/a>&lt;/h3>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/rlkp9t/1616161240462-a29c9d65-119a-4b70-993f-bd1a4cfbbd7e.png" alt="">&lt;/p>
&lt;ul>
&lt;li>&lt;strong>Version&lt;/strong> # 响应给 Client 的 HTTP 版本。&lt;/li>
&lt;li>&lt;strong>Status&lt;/strong> # HTTP 响应状态。用来标记请求过程中发生的情况，由 server 告诉 client。响应状态由两部分组成&lt;/li>
&lt;li>&lt;strong>StatusCode&lt;/strong> # 状态码。统一为 3 位的数字。
&lt;ul>
&lt;li>各个状态码的含义，见 &lt;a href="https://desistdaydream.github.io/docs/4.%E6%95%B0%E6%8D%AE%E9%80%9A%E4%BF%A1/Protocol/HTTP/HTTP%20Status%20Codes.md">HTTP Status Codes&lt;/a>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>ReasonPhrase&lt;/strong> # 原因短语。用来表示产生该状态的原因的简要说明&lt;/li>
&lt;li>&lt;strong>Headers&lt;/strong> # 响应头。&lt;/li>
&lt;li>&lt;strong>Body&lt;/strong> # 响应体。实体部分，请求时附加的数据或响应时附加的数据&lt;/li>
&lt;/ul>
&lt;h4 id="example-1">EXAMPLE&lt;a class="td-heading-self-link" href="#example-1" aria-label="Heading self-link">&lt;/a>&lt;/h4>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/rlkp9t/1616161240440-85fac56c-d3ed-44dc-94f3-20d60017e622.png" alt="">&lt;/p>
&lt;h2 id="http-header">HTTP Header&lt;a class="td-heading-self-link" href="#http-header" aria-label="Heading self-link">&lt;/a>&lt;/h2>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://datatracker.ietf.org/doc/html/rfc2616#section-14">RFC 2616，14 Header Field Definitions&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>HTTP 请求和响应报文的 Header(头) 基本都是 Key/Value(键值) 格式，Key 与 Value 以冒号分隔，此外，除了标准的头部字段之外，还可以添加自定义头，这就给 HTTP 带来了无限的扩展可能。注意，Value 不区分大小写。&lt;/p>
&lt;p>HTTP 协议规定了非常多的 Header 字段，可以实现各种各样的功能，但基本上可以分为以下几类&lt;/p>
&lt;ul>
&lt;li>&lt;strong>General Header(通用头)&lt;/strong> # 在请求头和响应头里都可以出现；&lt;/li>
&lt;li>&lt;strong>Request Header(请求头)&lt;/strong> # 仅能出现在请求头里，进一步说明请求信息或者额外的附加条件；&lt;/li>
&lt;li>&lt;strong>Response Header(响应头)&lt;/strong> # 仅能出现在响应头里，补充说明响应报文的信息；&lt;/li>
&lt;li>&lt;strong>Entity Header(实体头)&lt;/strong> # 它实际上属于通用字段，但专门描述 body 的额外信息。&lt;/li>
&lt;li>&lt;strong>Extension Header(扩展头)&lt;/strong> # 不在标准规范中，可以通过自定义头实现更多定制化需求的 Header 信息。&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>对 HTTP 报文的解析和处理其实本质上就是对头字段的处理&lt;/strong>，HTTP 的连接管理，缓存控制，内容协商等都是通过头字段来处理的，&lt;strong>理解了头字段，基本上也就理解了 HTTP&lt;/strong>，所以理解头字段非常重要。&lt;/p>
&lt;p>详见：&lt;a href="https://desistdaydream.github.io/docs/4.%E6%95%B0%E6%8D%AE%E9%80%9A%E4%BF%A1/Protocol/HTTP/HTTP%20Header.md">HTTP Header&lt;/a>&lt;/p>
&lt;blockquote>
&lt;p>注意：这种分类是在 RFC 2616 标准中定义的，在新的 RFC 7231 中，已经看不到这种分类了&lt;/p>
&lt;/blockquote>
&lt;h2 id="http-的请求-method方法">HTTP 的请求 Method(方法)&lt;a class="td-heading-self-link" href="#http-%e7%9a%84%e8%af%b7%e6%b1%82-method%e6%96%b9%e6%b3%95" aria-label="Heading self-link">&lt;/a>&lt;/h2>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://datatracker.ietf.org/doc/html/rfc2616#section-5.1.1">RFC 2616，5.1.1 Method&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Methods">Mozilla 官方 HTTP 开发文档，HTTP 请求方法&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>根据 HTTP 标准，HTTP 请求可以使用多种请求方法。 HTTP 的 1.0 版本中只有三种请求方法： GET, POST 和 HEAD 方法。到了 1.1 版本时，新增加了五种请求方法：OPTIONS, PUT, DELETE, TRACE 和 CONNECT 方法。&lt;/p>
&lt;ul>
&lt;li>&lt;strong>GET&lt;/strong> # 从服务器获取了资源
&lt;ul>
&lt;li>请求指定的页面信息，并返回实体主体。&lt;/li>
&lt;li>GET 请求请提交的数据放置在 HTTP 请求协议头中，GET 方法通过 URL 请求来传递用户的输入，GET 方式的提交你需要用 Request.QueryString 来取得变量的值。&lt;/li>
&lt;li>GET 方法提交数据，可能会带来安全性的问题，数据被浏览器缓存。&lt;/li>
&lt;li>GET 请求有长度限制。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>HEAD&lt;/strong> # 只从 server 获取文档的响应首部（报文中的 Headers）
&lt;ul>
&lt;li>类似于 get 请求，只不过返回的响应中没有具体的内容，用于获取报头。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>POST&lt;/strong> # 向 server 发送要处理的数据
&lt;ul>
&lt;li>向指定资源提交数据进行处理请求（例如提交表单或者上传文件）。&lt;/li>
&lt;li>POST 请求可能会导致新的资源的建立和/或已有资源的修改。&lt;/li>
&lt;li>POST 方式提交时，你必须通过 Request.Form 来访问提交的内容&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>PUT&lt;/strong> # 将请求的主体存储在 server 上
&lt;ul>
&lt;li>从客户端向服务器传送的数据取代指定的文档的内容。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>DELETE&lt;/strong> # 请求删除 server 上通过 URL 指定的文档，DELETE 请求一般返回 3 种码
&lt;ul>
&lt;li>200（OK）——删除成功，同时返回已经删除的资源。&lt;/li>
&lt;li>202（Accepted）——删除请求已经接受，但没有被立即执行（资源也许已经被转移到了待删除区域）。&lt;/li>
&lt;li>204（No Content）——删除请求已经被执行，但是没有返回资源（也许是请求删除不存在的资源造成的）。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>OPTIONS&lt;/strong> # 请求服务器返回对指定资源支持使用的请求方法
&lt;ul>
&lt;li>允许客户端查看服务器的性能。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>TRACE&lt;/strong> # 追踪请求到达 server 中间经过的 server agent
&lt;ul>
&lt;li>回显服务器收到的请求，主要用于测试或诊断。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h3 id="get-与-post">GET 与 POST&lt;a class="td-heading-self-link" href="#get-%e4%b8%8e-post" aria-label="Heading self-link">&lt;/a>&lt;/h3>
&lt;p>&lt;code>Get&lt;/code> 方法的含义是请求&lt;strong>从服务器获取资源&lt;/strong>，这个资源可以是静态的文本、页面、图片视频等。&lt;/p>
&lt;p>比如，你打开我的文章，浏览器就会发送 GET 请求给服务器，服务器就会返回文章的所有文字及资源。&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/rlkp9t/1649668233003-6c01ab91-90f8-4ea8-8095-5448302146e8.jpeg" alt="">&lt;/p>
&lt;p>而&lt;code>POST&lt;/code> 方法则是相反操作，它向 &lt;code>URI&lt;/code> 指定的资源提交数据，数据就放在报文的 body 里。&lt;/p>
&lt;p>比如，你在我文章底部，敲入了留言后点击「提交」（&lt;strong>暗示你们留言&lt;/strong>），浏览器就会执行一次 POST 请求，把你的留言文字放进了报文 body 里，然后拼接好 POST 请求头，通过 TCP 协议发送给服务器。
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/rlkp9t/1649668232954-1a090cec-1a9c-4c11-a370-d49b4156cac3.jpeg" alt="">
GET 和 POST 方法都是安全和幂等的吗？&lt;/p>
&lt;p>先说明下安全和幂等的概念：&lt;/p>
&lt;ul>
&lt;li>在 HTTP 协议里，所谓的「安全」是指请求方法不会「破坏」服务器上的资源。&lt;/li>
&lt;li>所谓的「幂等」，意思是多次执行相同的操作，结果都是「相同」的。&lt;/li>
&lt;/ul>
&lt;p>那么很明显 &lt;strong>GET 方法就是安全且幂等的&lt;/strong>，因为它是「只读」操作，无论操作多少次，服务器上的数据都是安全的，且每次的结果都是相同的。&lt;/p>
&lt;p>&lt;strong>POST&lt;/strong> 因为是「新增或提交数据」的操作，会修改服务器上的资源，所以是&lt;strong>不安全&lt;/strong>的，且多次提交数据就会创建多个资源，所以&lt;strong>不是幂等&lt;/strong>的。&lt;/p>
&lt;h1 id="http-相关的协议或规范">HTTP 相关的协议或规范&lt;a class="td-heading-self-link" href="#http-%e7%9b%b8%e5%85%b3%e7%9a%84%e5%8d%8f%e8%ae%ae%e6%88%96%e8%a7%84%e8%8c%83" aria-label="Heading self-link">&lt;/a>&lt;/h1>
&lt;p>HTTP 无法单独存在，要想让它生效，必须依赖其他的协议或者规范&lt;/p>
&lt;h2 id="url">URL&lt;a class="td-heading-self-link" href="#url" aria-label="Heading self-link">&lt;/a>&lt;/h2>
&lt;p>详见 &lt;a href="https://desistdaydream.github.io/docs/4.%E6%95%B0%E6%8D%AE%E9%80%9A%E4%BF%A1/Protocol/HTTP/URL%20%E4%B8%8E%20URI.md">URL 与 URI&lt;/a>&lt;/p>
&lt;h2 id="tcpip">TCP/IP&lt;a class="td-heading-self-link" href="#tcpip" aria-label="Heading self-link">&lt;/a>&lt;/h2>
&lt;p>详见：&lt;a href="https://desistdaydream.github.io/docs/4.%E6%95%B0%E6%8D%AE%E9%80%9A%E4%BF%A1/Protocol/TCP_IP/TCP_IP.md">TCP_IP&lt;/a>&lt;/p>
&lt;h2 id="dns">DNS&lt;a class="td-heading-self-link" href="#dns" aria-label="Heading self-link">&lt;/a>&lt;/h2>
&lt;p>详见：&lt;a href="https://desistdaydream.github.io/docs/4.%E6%95%B0%E6%8D%AE%E9%80%9A%E4%BF%A1/DNS/DNS.md">DNS&lt;/a>&lt;/p></description></item><item><title>Docs: HTTP3</title><link>https://desistdaydream.github.io/docs/4.%E6%95%B0%E6%8D%AE%E9%80%9A%E4%BF%A1/Protocol/HTTP/HTTP3/</link><pubDate>Thu, 12 Oct 2023 11:19:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/4.%E6%95%B0%E6%8D%AE%E9%80%9A%E4%BF%A1/Protocol/HTTP/HTTP3/</guid><description>
&lt;h1 id="概述">概述&lt;a class="td-heading-self-link" href="#%e6%a6%82%e8%bf%b0" aria-label="Heading self-link">&lt;/a>&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/HTTP/3">Wiki, HTTP/3&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>HTTP/3 是用于在万维网上交换信息的超文本传输​​协议的第三个主要版本，是对广泛部署的 HTTP/1.1 和 HTTP/2 的补充。与之前依赖完善的 TCP（于 1974 年发布）的版本不同，HTTP/3 使用 &lt;a href="https://desistdaydream.github.io/docs/4.%E6%95%B0%E6%8D%AE%E9%80%9A%E4%BF%A1/Protocol/UDP/QUIC.md">QUIC&lt;/a>（于 2021 年正式引入），一种基于 UDP 构建的多路复用传输协议。&lt;/p></description></item><item><title>Docs: HTTP2</title><link>https://desistdaydream.github.io/docs/4.%E6%95%B0%E6%8D%AE%E9%80%9A%E4%BF%A1/Protocol/HTTP/HTTP2/</link><pubDate>Wed, 12 Oct 2022 11:20:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/4.%E6%95%B0%E6%8D%AE%E9%80%9A%E4%BF%A1/Protocol/HTTP/HTTP2/</guid><description>
&lt;h1 id="概述">概述&lt;a class="td-heading-self-link" href="#%e6%a6%82%e8%bf%b0" aria-label="Heading self-link">&lt;/a>&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://tools.ietf.org/html/rfc7540">RFC，7540&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://http2.github.io/">官网&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://mp.weixin.qq.com/s/WQpxfwLArltKEjEAdOO2Pw">51 张图助你彻底掌握 HTTP 协议&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://mp.weixin.qq.com/s/a83_NE-ww36FZsy320MQFQ">https://mp.weixin.qq.com/s/a83_NE-ww36FZsy320MQFQ&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>HTTP 2.0 在性能上实现了很大的飞跃，更难得的是它在改进的同时保持了语义的不变，与 HTTP 1.1 的语义完全相同！比如请求方法、URI、状态码、头字段等概念都保留不变，这样就消除了再学习的成本，在我们的日常软件升级中，&lt;strong>向下兼容&lt;/strong>非常重要，也是促进产品大规模使用的一个前提，不然你一升级，各种接口之类的全换了，谁还敢升。 &lt;strong>HTTP 2.0 只在语法上做了重要改进，完全变更了 HTTP 报文的传输格式&lt;/strong>&lt;/p>
&lt;p>在语法上主要实现了以下改造&lt;/p>
&lt;h3 id="1头部压缩">1、头部压缩&lt;a class="td-heading-self-link" href="#1%e5%a4%b4%e9%83%a8%e5%8e%8b%e7%bc%a9" aria-label="Heading self-link">&lt;/a>&lt;/h3>
&lt;p>HTTP 1.1 考虑了 body 的压缩，但没有考虑 header 的压缩, 经常出现传了头部上百，上千字节，但 Body 却只有几十字节的情况，浪费了带宽，而且我们知道从 1.1 开始默认是长连接，几百上千个请求都用的这个连接，而请求的头部很多都是重复的，造成了带宽的极大浪费!想象一下面的这个请求，为了传输区区 「name=michale 」这几个字节，却要传输如此巨量的头部，浪费的带宽确实惊人。&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/ucykv5/1616161148212-dbadab6a-315e-4589-8750-cb9f05553948.png" alt="">&lt;/p>
&lt;p>那么 HTTP 2.0 是如何解决的呢？它开发了专门的 「HPACK」算法，在客户端和服务器两端建立字典，用索引号表示重复的字符串，还采用哈夫曼编码来压缩数字和整数，可以达到最高达 90% 的压缩率&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/ucykv5/1616161148192-45f35344-e164-46ee-aa3c-61a0bba6c732.png" alt="">&lt;/p>
&lt;p>这里简单解释下，头部压缩需要在支持 HTTP 2.0 的客户端和服务器之间：&lt;/p>
&lt;ol>
&lt;li>维护一份静态的字典（Static table），包含常见的头部名称，以及特别常见的头部名称与值的组合。这样的话如果请求响应命中了静态字典，直接发索引号即可&lt;/li>
&lt;li>维护一份相同的动态字典（Dynamic table），可以动态地添加字典，这样的话如果客户端首次请求由于「User-Agent: xxx」,「host:xxx」,「Cookie」这些的动态键值对没有命中静态字典，还是会传给服务器，但服务器收到后会基于传过来的键值对创建动态字典条目，如上图的「User-Agent: xxx」对应数字 62，「host:xxx」对应数字 63，这样双方都创建动态条目后，之后就可以用只传 62，63 这样的索引号来通信了！显而易见，传输数据急遽降低，极大地提升了传输效率！需要注意的是动态字典是每个连接自己维护的，也就是对于每个连接而言，首次都必须发送动态键值对&lt;/li>
&lt;li>支持基于静态哈夫曼码表的哈夫曼编码（Huffman Coding）：对于静态、动态字典中不存在的内容，可以使用哈夫曼编码来减小体积。HTTP/2 使用了一份静态哈夫曼码表（详见），也需要内置在客户端和服务端之中。&lt;/li>
&lt;/ol>
&lt;h3 id="2二进制格式">2、二进制格式&lt;a class="td-heading-self-link" href="#2%e4%ba%8c%e8%bf%9b%e5%88%b6%e6%a0%bc%e5%bc%8f" aria-label="Heading self-link">&lt;/a>&lt;/h3>
&lt;p>HTTP 1.1 是纯文本形式，而 2.0 是完全的二进制形式，它把 TCP 协议的部分特性挪到了应用层，把原来的 Header+Body 消息打散为了数个小版的二进制&amp;quot;帧&amp;quot;（Frame）,“HEADERS”帧存放头数据、“DATA”帧存放实体数据&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/ucykv5/1616161148271-6532e9c1-a86d-4794-ae42-de56f5188c1a.png" alt="">&lt;/p>
&lt;p>这些二进制帧只认 0，1，基于这种考虑 http 2.0 的协议解析决定采用二进制格式，使用二进制的形式虽然对人不友好，但&lt;strong>大大方便了计算机的解析&lt;/strong>，原来使用纯文本容易出现多义性，如大小写，空白字符等，程序在处理时必须用复杂的状态机，&lt;strong>效率低，还麻烦&lt;/strong>。而使用二进制的话可以严格规定字段大小、顺序、标志位等格式，“对就是对，错就是错”，&lt;strong>解析起来没有歧义，实现简单，而且体积小、速度快。&lt;/strong>&lt;/p>
&lt;h3 id="3-流">3. 流&lt;a class="td-heading-self-link" href="#3-%e6%b5%81" aria-label="Heading self-link">&lt;/a>&lt;/h3>
&lt;p>HTTP 2 定义了「流」（stream）的的概念，它是二进制帧的双向传输序列，同一个消息往返的数据帧 （header 帧和 data 帧）会分配一个唯一的流 ID，这样我们就能区分每一个请求。在这个虚拟的流里，数据帧按先后次序传输，到达应答方后，将这些数据帧按它们的先后顺序组装起来，最后解析 HTTP 1.1 的请求头和实体。&lt;/p>
&lt;p>在&lt;strong>同一时间&lt;/strong>，请求方可以在流里发请求，应答方也可以也流里发响应，对比 HTTP 1.1 一个连接一次只能处理一次请求-应答，吞吐量大大提升&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/ucykv5/1616161148223-75161729-344f-4bd8-98f5-10f6f23aab4c.png" alt="">&lt;/p>
&lt;p>&lt;strong>如图示，一个连接里多个流可以同时收发请求-应答数据帧，每个流中数据包按序传输组装&lt;/strong>&lt;/p>
&lt;p>所有的流都是在同一个连接中流动的，这也是 HTTP 2.0 经典的&lt;strong>多路复用&lt;/strong>（ Multiplexing），另外由于每个流都是独立的，所以谁先处理好请求，谁就可以先将响应通过连接发送给对方，也就解决了队头阻塞的问题。&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/ucykv5/1616161148167-417e8e93-dbe1-43d6-b4b0-ffdda356eb36.png" alt="">&lt;/p>
&lt;p>&lt;strong>如图示，在 HTTP 2 中，两个请求同时发送，可以同时接收，而在 HTTP 1.1 中必须等上一个请求响应后才能处理下一个请求&lt;/strong>&lt;/p>
&lt;h3 id="http-2-的队头阻塞">HTTP 2 的队头阻塞&lt;a class="td-heading-self-link" href="#http-2-%e7%9a%84%e9%98%9f%e5%a4%b4%e9%98%bb%e5%a1%9e" aria-label="Heading self-link">&lt;/a>&lt;/h3>
&lt;p>HTTP 2 引入的流，帧等语法层面的改造确实让其传输效率有了质的飞跃，但是它依然存在着队头阻塞，这是咋回事？&lt;/p>
&lt;p>其实主要是因为 HTTP 2 的分帧主要是在应用层处理的，而分帧最终还是要传给下层的 TCP 层经由它封装后再进行传输，每个连接最终还是顺序传输这些包，
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/ucykv5/1616161148187-3d17b319-06b7-4fb6-98cd-7a3ce63af1d8.png" alt="">
&lt;strong>如图示：流只是我们虚拟出来的概念，最终在连接层面还是顺序传的&lt;/strong>&lt;/p>
&lt;p>TCP 是可靠连接，为了保证这些包能顺序传给对方，会进行丢包重传机制，如果传了三个包，后两个包传成功，但第一个包传失败了，TCP 协议栈会把已收到的包暂存到缓存区中，停下等待第一个包的重传成功，这样的话在网络不佳的情况下只要一个包阻塞了，由于重传机制，后面的包就被阻塞了，上层应用由于拿不到包也只能干瞪眼了。&lt;/p>
&lt;p>由于这是 TCP 协议层面的机制，无法改造，所以 HTTP 2 的队头阻塞是不可避免的。HTTP 3 对此进行了改进，将 TCP 换成了 UDP 来进行传输，由于 UDP 是无序的，不需要断建连，包之间没有依赖关系，所以从根本上解决了“队头阻塞”, 当然由于 UDP 本身的这些特性不足以支撑可靠的通信，所以 Google 在 UDP 的基础上也加了 TCP 的连接管理，拥塞窗口，流量控制等机制，这套协议我们称之为 QUIC 协议。
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/ucykv5/1616161148202-483920df-f46e-43fc-83b2-75c6e80cd747.png" alt="">
可以看到不管是 HTTP 2 还是 3 它们底层都支持用 TLS，保留了 HTTPS 安全的特性，这也可以理解，在互联网发展如此迅猛的今天，各大企业也越来越重视通信安全。&lt;/p></description></item><item><title>Docs: URL 与 URI</title><link>https://desistdaydream.github.io/docs/4.%E6%95%B0%E6%8D%AE%E9%80%9A%E4%BF%A1/Protocol/HTTP/URL-%E4%B8%8E-URI/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/4.%E6%95%B0%E6%8D%AE%E9%80%9A%E4%BF%A1/Protocol/HTTP/URL-%E4%B8%8E-URI/</guid><description>
&lt;h1 id="概述">概述&lt;a class="td-heading-self-link" href="#%e6%a6%82%e8%bf%b0" aria-label="Heading self-link">&lt;/a>&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Uniform_Resource_Identifier">Wiki, URI&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Internationalized_Resource_Identifier">Wiki, IRI&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/URL">Wiki, URL&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Clean_URL">Wiki, CleanURL-slug&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Percent-encoding">Wiki, URL encoding&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.rfc-editor.org/rfc/rfc3986.html">RFC 3986，Uniform Resource Identifier(URI): Generic Syntax&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.rfc-editor.org/rfc/rfc1738">RFC 1738，Uniform Resource Locators (URL)&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.ruanyifeng.com/blog/2010/02/url_encoding.html">https://www.ruanyifeng.com/blog/2010/02/url_encoding.html&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>既然 HTTP 的本质是是在两点之间传输超文本，那么这个超文本又该如何表示呢？我们应该如何正确得找到这个超文本呢？所以，人们将超文本描述为 &lt;strong>Resource(资源)&lt;/strong>，互联网上如此之多得资源，就需要一个唯一标识符来标识每一个资源。URI 就是这么一个用来标识资源的规范。&lt;/p>
&lt;p>&lt;strong>Uniform Resource Identifier(统一资源标识符，简称 URI)&lt;/strong> 是 Web 技术使用的唯一标识符。URI 可以用于标识任何东西，包括现实世界中的对象，例如人和地方，概念或信息资源，例如网页和书籍。某些 URI 提供了一种在网络上(在 Internet 上或在另一个专用网络上，例如在计算机文件系统或 Intranet 上)定位和检索信息资源的方法，它们是 &lt;strong>Uniform Resource Locator(统一资源定位符，简称 URL)&lt;/strong>。而其他 URI 仅提供一个唯一名称，而没有找到或检索该资源的信息，这类 URI 被称为 &lt;strong>Uniform Resource Name(统一资源名称，简称 URN)&lt;/strong>。&lt;/p>
&lt;blockquote>
&lt;p>尽管 URI 仍然是常用术语，但定义 URI 的规范已经被 Internationalized Resource Identifiers(国际化资源标识符，简称 IRI) 的规范所取代。IRI 扩展了 URI 的定义，以便 IRI 可以处理诸如 Kanji(汉字) 之类的字符集，而不是仅限于 ASCII。&lt;/p>
&lt;/blockquote>
&lt;p>&lt;strong>Uniform Resource Locator(统一资源定位符，简称 URL)&lt;/strong> 是 URI 的一种子集。&lt;/p>
&lt;p>要强制区分 URL 和 URI/IRI 这两种标准化术语是很难的。实际上，两者都使用同一种算法，因此没必要强行区分二者的区别，而且 URL 这个词也更具有人气。所以没有必要强制区分 URI 与 URL。&lt;/p>
&lt;h1 id="url-syntaxurl-语法">URL Syntax(URL 语法)&lt;a class="td-heading-self-link" href="#url-syntaxurl-%e8%af%ad%e6%b3%95" aria-label="Heading self-link">&lt;/a>&lt;/h1>
&lt;blockquote>
&lt;p>参考:&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://www.rfc-editor.org/rfc/rfc3986.html#section-3">https://www.rfc-editor.org/rfc/rfc3986.html#section-3&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>URL 主要由四个部分组成：协议、主机、端口、路径&lt;/p>
&lt;p>&lt;strong>&lt;code>**Scheme:[//Authority]/Path[?query][#fragment]**&lt;/code>&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>&lt;strong>Scheme://&lt;/strong> # URL 方案，即访问协议,指定低层使用的协议(例如：http, https, ftp)&lt;/li>
&lt;li>&lt;strong>Authority&lt;/strong> # 分为三个部分 &lt;code>[UserInfo@]Host[:Port]&lt;/code>&lt;/li>
&lt;li>&lt;strong>UserInfo&lt;/strong> # 认证信息。由于安全原因，现在这个年代，都省略这部分，而通过其他方式传递认证信息。&lt;/li>
&lt;li>&lt;strong>Host:PORT&lt;/strong> # 服务器 IP 地址或者域名:要访问的端口号&lt;/li>
&lt;li>&lt;strong>/PATH&lt;/strong> # 要访问的资源路径。即资源在主机上的存放相对路径。
&lt;ul>
&lt;li>注意：其实 &lt;code>/&lt;/code> 也算作 PATH 的一部分，只不过访问一个网站时，访问的默认资源就是 &lt;code>/&lt;/code>，并且也便于人类阅读，所以很多网站访问时虽然末尾没有 &lt;code>/&lt;/code>，其实是隐藏了。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>QUERY&lt;/strong> # 其实就是参数。用于给动态网页或接口传递参数，可有多个参数，用“&amp;amp;”符号隔开，每个参数的名和值用“=”符号隔开。&lt;/li>
&lt;li>&lt;strong>Fragment&lt;/strong> # 片段，主要用于浏览器中。当前页面的其中一段的位置，比如一篇小说有 N 个章节在统一页面显示，开头有目录，点击某一个章节会跳到该页面的某一段，该段的开头就是整个页面的片段，类似于一个位置锚定的作用，该字段即实现这个功能&lt;/li>
&lt;/ul>
&lt;h1 id="url-slug">URL slug&lt;a class="td-heading-self-link" href="#url-slug" aria-label="Heading self-link">&lt;/a>&lt;/h1>
&lt;p>URL slug 是位于域扩展名之后的 URL 或链接的一部分。&lt;/p>
&lt;ul>
&lt;li>它们可用于网站：
&lt;ul>
&lt;li>&lt;a href="https://www.rebrandly.com/links">www.rebrandly.com/links&lt;/a> # &amp;rsquo;links&amp;rsquo; 是 URL Slug。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>或者它们可以用于您的自定义短链接：
&lt;ul>
&lt;li>rebrandly.rocks/content-curation # &amp;lsquo;content-curation&amp;rsquo; 是 URL slug。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h1 id="example">EXAMPLE&lt;a class="td-heading-self-link" href="#example" aria-label="Heading self-link">&lt;/a>&lt;/h1>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span> userinfo host port
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ┌──┴───┐ ┌──────┴──────┐ ┌┴┐
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> https://john.doe@www.example.com:123/forum/questions/?tag&lt;span style="color:#ce5c00;font-weight:bold">=&lt;/span>networking&lt;span style="color:#000;font-weight:bold">&amp;amp;&lt;/span>&lt;span style="color:#000">order&lt;/span>&lt;span style="color:#ce5c00;font-weight:bold">=&lt;/span>newest#top
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> └─┬─┘ └───────────┬──────────────┘└───────┬───────┘ └───────────┬─────────────┘ └┬┘
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> scheme authority path query fragment
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ul>
&lt;li>&lt;code>unix:///run/containerd/containerd.sock&lt;/code> # 这也是 URI 的一种，这就是不同于网络定位符的地方，没有域名之类的东西。Scheme 后面直接接的是 PATH&lt;/li>
&lt;/ul>
&lt;h1 id="url-编码">URL 编码&lt;a class="td-heading-self-link" href="#url-%e7%bc%96%e7%a0%81" aria-label="Heading self-link">&lt;/a>&lt;/h1>
&lt;p>URL Encoding(URL 编码)&lt;/p>
&lt;p>通常来说，URL 只能使用英文字母、阿拉伯数字和某些标点符号。那么如果在 URL 中想使用其他字符，比如中文或某些特殊字符怎么办呢？&lt;/p>
&lt;p>上述问题就是 URL 编码的由来。在初期，并没有 RFC 规定具体如何进行编码，而是由应用程序自行处理。这就导致 URL 编码称为一个混乱的领域。&lt;/p>
&lt;p>在浏览器中，如果输入 &lt;code>http://www.google.com/断念梦&lt;/code>，则会被编码为 &lt;code>http://www.google.com/%E6%96%AD%E5%BF%B5%E6%A2%A6&lt;/code>。这里面的规则非常简单：&lt;/p>
&lt;ul>
&lt;li>这三个汉字的 UTF-8 编码结果分别为
&lt;ul>
&lt;li>断: E6 96 AD&lt;/li>
&lt;li>念: E5 BF B5&lt;/li>
&lt;li>梦: E6 A2 A6&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>“断念梦” 三个汉字的 Unicode 编码结果为 E4 BD A0 E5 A5 BD，每个字节前面加上个 &lt;code>%&lt;/code>，就得到了 URL 编码。&lt;/li>
&lt;/ul></description></item><item><title>Docs: HTTP Header</title><link>https://desistdaydream.github.io/docs/4.%E6%95%B0%E6%8D%AE%E9%80%9A%E4%BF%A1/Protocol/HTTP/HTTP-Header/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/4.%E6%95%B0%E6%8D%AE%E9%80%9A%E4%BF%A1/Protocol/HTTP/HTTP-Header/</guid><description>
&lt;h1 id="概述">概述&lt;a class="td-heading-self-link" href="#%e6%a6%82%e8%bf%b0" aria-label="Heading self-link">&lt;/a>&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://tools.ietf.org/html/rfc2616#section-4.2">RFC 2616-Message Headers&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://tools.ietf.org/html/rfc7231#section-5">RFC 7231，第五章-请求头字段&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://datatracker.ietf.org/doc/html/rfc7231#section-7">RFC 7231，第七章-响应头字段&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers">MDN，参考-HTTP-HTTP 头&lt;/a> 这是一个全部可用的标准 Header 列表&lt;/li>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/List_of_HTTP_header_fields">Wiki, List of HTTP header fields&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>一般情况下，在打开浏览器按的开发者工具（一般为 F12 键）后，查看到的首部大部分都是请求和响应首部,这俩首部的信息通常包含了通用首部中的信息&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/http/1616161207830-cf569808-255f-4e34-9f02-d7da892c9170.jpeg" alt="">&lt;/p>
&lt;p>HTTP 请求和响应报文的 Header(头) 基本都是 Key/Value Pair(键/值对) 格式的 &lt;strong>Field(字段)&lt;/strong>，每个字段都是以冒号分割的 &lt;strong>键/值对&lt;/strong>。此外，除了标准的 Header 字段之外，还可以添加自定义 Header，这就给 HTTP 带来了无限的扩展可能。注意，&lt;strong>Key 不区分大小写&lt;/strong>。&lt;/p>
&lt;p>自定义 Header 历来以 &lt;code>X-&lt;/code> 开头，但是该约定在 2012 年 6 月被弃用，因为它在非标准字段成为标准字段时会造成不必要的麻烦，详见 &lt;a href="https://datatracker.ietf.org/doc/html/rfc6648">RFC 6648&lt;/a>。IANA 维护了一个通用的 &lt;a href="https://www.iana.org/assignments/message-headers/message-headers.xhtml">&lt;strong>HTTP Header 列表&lt;/strong>&lt;/a>，其中包括 RFC 中定义的标准头以及不在 RFC 中定义的扩展头；并且在同一个页面还有新的提议增加的 HTTP Header 列表。&lt;/p>
&lt;p>HTTP(RFC 2616 版本) 规定了非常多的 Header 字段，可以实现各种各样的功能，但基本上可以分为以下几类&lt;/p>
&lt;ol>
&lt;li>&lt;strong>General Header(通用头)&lt;/strong> # 在请求头和响应头里都可以出现；&lt;/li>
&lt;li>&lt;strong>Request Header(请求头)&lt;/strong> # 仅能出现在请求头里，进一步说明请求信息或者额外的附加条件；&lt;/li>
&lt;li>&lt;strong>Response Header(响应头)&lt;/strong> # 仅能出现在响应头里，补充说明响应报文的信息；&lt;/li>
&lt;li>&lt;strong>Entity Header(实体头)&lt;/strong> # 它实际上属于通用字段，但专门描述 body 的额外信息。&lt;/li>
&lt;li>&lt;strong>Extension Header(扩展头)&lt;/strong> # 不在标准规范中，可以通过自定义头实现更多定制化需求的 Header 信息。&lt;/li>
&lt;/ol>
&lt;p>&lt;strong>对 HTTP 报文的解析和处理其实本质上就是对头字段的处理&lt;/strong>，HTTP 的连接管理，缓存控制，内容协商等都是通过头字段来处理的，&lt;strong>理解了头字段，基本上也就理解了 HTTP&lt;/strong>，所以理解头字段非常重要。&lt;/p>
&lt;h2 id="新版-http-header-规范">新版 HTTP Header 规范&lt;a class="td-heading-self-link" href="#%e6%96%b0%e7%89%88-http-header-%e8%a7%84%e8%8c%83" aria-label="Heading self-link">&lt;/a>&lt;/h2>
&lt;p>注意：上面描述分类是在 RFC 2616 标准中定义的，在新的 RFC 7231 中，已经看不到这种分类了，仅仅简单得分为请求头和响应头&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://tools.ietf.org/html/rfc7231#section-5">Request Header(请求头)&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://tools.ietf.org/html/rfc7231#section-7">Response Header(响应头)&lt;/a>&lt;/li>
&lt;/ul>
&lt;p>而这两类头字段下，又有各自的子分类&lt;/p>
&lt;p>在 2014 年之后的新版规范中，并非所有出现在请求中的 Header 都称为请求头，比如 Content-Length，在 RFC 2616 中称为 Entity Header(实体头)，而在新版规范中，称之为元数据。这也为 HTTP 2.0 的 &lt;a href="https://desistdaydream.github.io/docs/4.%E6%95%B0%E6%8D%AE%E9%80%9A%E4%BF%A1/Protocol/HTTP/HTTP2.md">Header 压缩&lt;/a> 打下了基础&lt;/p>
&lt;h1 id="request-header请求头">Request Header(请求头)&lt;a class="td-heading-self-link" href="#request-header%e8%af%b7%e6%b1%82%e5%a4%b4" aria-label="Heading self-link">&lt;/a>&lt;/h1>
&lt;p>Request Header(请求头) 主要是在每个 HTTP 的请求中指定。包含要获取的资源或请求某个资源的客户端本身的信息，以便服务端可以根据这些内容，来定制响应。&lt;/p>
&lt;p>Request Header 中，将各种 Header 分为多个类别&lt;/p>
&lt;ul>
&lt;li>Controls # 控制本次 HTTP 请求的行为&lt;/li>
&lt;li>Conditionals # 条件相关 Header&lt;/li>
&lt;li>Content Negotiation # 内容协商相关 Header&lt;/li>
&lt;li>Authentication Credentials # 认证相关的 Header&lt;/li>
&lt;li>Request Context # 请求上下文&lt;/li>
&lt;/ul>
&lt;h2 id="controls控制">Controls(控制)&lt;a class="td-heading-self-link" href="#controls%e6%8e%a7%e5%88%b6" aria-label="Heading self-link">&lt;/a>&lt;/h2>
&lt;p>Controls 类型的请求头用来指定客户端如何处理本次 HTTP 请求。&lt;/p>
&lt;p>&lt;strong>Cache-Control&lt;/strong> # 缓存控制&lt;/p>
&lt;p>&lt;strong>Expect&lt;/strong> # 期待服务器的特定行为&lt;/p>
&lt;p>&lt;strong>Host&lt;/strong> # 请求资源所在服务器。客户端指定自己想访问的服务器的 &lt;code>域名&lt;/code> 或者 &lt;code>IP:PORT&lt;/code>。例如：&lt;code>Host：www.baidu.com&lt;/code>&lt;/p>
&lt;ul>
&lt;li>Note：输入的什么网址，请求的就是什么，输入域名就是域名，输入 IP 就是 IP&lt;/li>
&lt;li>Note：当服务器接到这个请求时，如果自身无法处理 ip 或者无法处理域名，则该请求就会丢弃(比如 k8s 的 ingress)。所以在测试的时候一般使用 curl 命令请求 IP 时加上 -H 参数以自己制定 URL 内容即可，否则如果服务器不处理 IP 的话，就会返回 404&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>Max-Forwards&lt;/strong># 最大传输逐跳数&lt;/p>
&lt;p>&lt;strong>Pragma&lt;/strong> #&lt;/p>
&lt;p>&lt;strong>Range&lt;/strong> # 实体的字节范围请求&lt;/p>
&lt;p>&lt;strong>TE&lt;/strong># 传输编码的优先级&lt;/p>
&lt;h2 id="conditionals条件">Conditionals(条件)&lt;a class="td-heading-self-link" href="#conditionals%e6%9d%a1%e4%bb%b6" aria-label="Heading self-link">&lt;/a>&lt;/h2>
&lt;p>&lt;strong>If-Match&lt;/strong> # 比较实体标记(ETag)&lt;/p>
&lt;p>&lt;strong>If-None-Match&lt;/strong> # 比较实体标记(与 If-Match 相反)&lt;/p>
&lt;p>&lt;strong>If-Modified-Since&lt;/strong> # 比较资源的更新时间&lt;/p>
&lt;p>&lt;strong>If-Unmodified-Since&lt;/strong># 比较资源的更新时间(与 If-Modified-Since 相反)&lt;/p>
&lt;p>&lt;strong>If-Range&lt;/strong># 资源未更新时发送实体 Byte 的范围请求&lt;/p>
&lt;h2 id="content-negotiation内容协商">Content Negotiation(内容协商)&lt;a class="td-heading-self-link" href="#content-negotiation%e5%86%85%e5%ae%b9%e5%8d%8f%e5%95%86" aria-label="Heading self-link">&lt;/a>&lt;/h2>
&lt;p>&lt;strong>Accept&lt;/strong> # 用户代理可处理的媒体类型&lt;/p>
&lt;p>&lt;strong>Accept-[ Charset | Encoding | Language]&lt;/strong> # 通知 server 自己可接收的媒体类型[字符集|编码格式|语言]&lt;/p>
&lt;h2 id="authentication-credentials认证">Authentication Credentials(认证)&lt;a class="td-heading-self-link" href="#authentication-credentials%e8%ae%a4%e8%af%81" aria-label="Heading self-link">&lt;/a>&lt;/h2>
&lt;p>&lt;strong>Authorization&lt;/strong> # Web 认证信息。IANA 维护了一个&lt;a href="https://www.iana.org/assignments/http-authschemes/http-authschemes.xhtml">身份验证方案的列表&lt;/a>&lt;/p>
&lt;ul>
&lt;li>&lt;strong>Basic&lt;/strong> # 基本认证。就是用户名和密码。如果用户名和密码为 &lt;code>admin/admin1234&lt;/code> 的话，该字段应该是这样的：
&lt;ul>
&lt;li>&lt;code>Authorization: Basic YWRtaW46YWRtaW4xMjM0&lt;/code>&lt;/li>
&lt;li>也就是说，用户名和密码是 &lt;code>admin:admin1234&lt;/code> 这样的 base64 编码后的格式&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>Bearer&lt;/strong> # 不记名令牌。&lt;/li>
&lt;li>&amp;hellip;&amp;hellip;&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>Proxy-Authorization&lt;/strong> # 代理服务器要求客户端的认证信息&lt;/p>
&lt;h2 id="request-context">Request Context&lt;a class="td-heading-self-link" href="#request-context" aria-label="Heading self-link">&lt;/a>&lt;/h2>
&lt;p>&lt;strong>From&lt;/strong> # 用户的电子邮箱地址&lt;/p>
&lt;p>&lt;strong>Referer&lt;/strong> # 对请求中 URI 的原始获取方&lt;/p>
&lt;p>&lt;strong>User-Agent&lt;/strong> # HTTP 客户端程序的信息。i.e. 本次请求是由什么程序发送的&lt;/p>
&lt;h1 id="response-header响应头">Response Header(响应头)&lt;a class="td-heading-self-link" href="#response-header%e5%93%8d%e5%ba%94%e5%a4%b4" aria-label="Heading self-link">&lt;/a>&lt;/h1>
&lt;p>包含有关响应的补充信息，如其位置或服务器本身(名称和版本等)的消息头。&lt;/p>
&lt;p>Response Header 中，将各种 Header 分为多个类别：&lt;/p>
&lt;ul>
&lt;li>Control Data&lt;/li>
&lt;li>Validator Header Fields&lt;/li>
&lt;li>Authentication Challenges&lt;/li>
&lt;li>Response Context&lt;/li>
&lt;/ul>
&lt;h2 id="control-data控制数据">Control Data(控制数据)&lt;a class="td-heading-self-link" href="#control-data%e6%8e%a7%e5%88%b6%e6%95%b0%e6%8d%ae" aria-label="Heading self-link">&lt;/a>&lt;/h2>
&lt;p>控制服务端如何处理 HTTP 响应&lt;/p>
&lt;ul>
&lt;li>Age # 推算资源创建经过时间&lt;/li>
&lt;li>Cache-Control #&lt;/li>
&lt;li>Expires #&lt;/li>
&lt;li>Data #&lt;/li>
&lt;li>Location #&lt;/li>
&lt;li>Retry-After #&lt;/li>
&lt;li>Vary #&lt;/li>
&lt;li>Warning #&lt;/li>
&lt;/ul>
&lt;h2 id="validator-header-fields验证器头字段">Validator Header Fields(验证器头字段)&lt;a class="td-heading-self-link" href="#validator-header-fields%e9%aa%8c%e8%af%81%e5%99%a8%e5%a4%b4%e5%ad%97%e6%ae%b5" aria-label="Heading self-link">&lt;/a>&lt;/h2>
&lt;p>&lt;strong>ETag&lt;/strong> # 资源的匹配信息&lt;/p>
&lt;p>&lt;strong>Last-Modified&lt;/strong> # 最后一次修改时间&lt;/p>
&lt;h2 id="authentication-challenges">Authentication Challenges&lt;a class="td-heading-self-link" href="#authentication-challenges" aria-label="Heading self-link">&lt;/a>&lt;/h2>
&lt;p>&lt;strong>WWW-Authenticate&lt;/strong> # 服务器对客户端的认证信息&lt;/p>
&lt;p>&lt;strong>Proxy-Authorization&lt;/strong> # 代理服务器要求客户端的认证信息&lt;/p>
&lt;h2 id="response-context">Response Context&lt;a class="td-heading-self-link" href="#response-context" aria-label="Heading self-link">&lt;/a>&lt;/h2>
&lt;p>&lt;strong>Accept-Ranges&lt;/strong> # 是否接受字节范围请求&lt;/p>
&lt;p>&lt;strong>Allow&lt;/strong> #&lt;/p>
&lt;p>&lt;strong>Server&lt;/strong># HTTP 服务器的安装信息&lt;/p>
&lt;h1 id="extension-header扩展头">Extension Header(扩展头)&lt;a class="td-heading-self-link" href="#extension-header%e6%89%a9%e5%b1%95%e5%a4%b4" aria-label="Heading self-link">&lt;/a>&lt;/h1>
&lt;p>通常情况下，一个 web 界面有 N 多个资源，比如 index.html 首页是一个资源，首页中有各种 img，css，js 等静态或动态资源，当用户访问一个网站后，除了要请求主页资源，还需要再请求主页上各个图片，板式，功能等资源，每一个资源都有一个单独的报文。也就说有可能每一类资源都可以单独存在在一个相对应的集群服务器群中，比如通过一个图片的 URL，可以直接访问该图片，而不用在网站主页才能看到；而这些资源都需要前端负载均衡器来进行调度用户请求到相应的服务器中去拿去资源，这时候 LB 的压力会非常大，为了解决这种问题，人们就可以根据自己的协商，定义一些标准之外的 Header。&lt;/p>
&lt;h1 id="mdn-的-http-header-列表">MDN 的 HTTP Header 列表&lt;a class="td-heading-self-link" href="#mdn-%e7%9a%84-http-header-%e5%88%97%e8%a1%a8" aria-label="Heading self-link">&lt;/a>&lt;/h1>
&lt;p>RFC 7231 中 HTTP Header 分类方式好像并不是特别好的方式，在 RFC 9110 中，已经没有 RFC 7231 的那种请求头分类章节了。&lt;/p>
&lt;p>很多 HTTP Header 既可以当做 Request Header 又可以当做 Response Header，比如 Cache-Control、等等。所以 MDN 使用 Header 的功能进行分类&lt;/p>
&lt;ul>
&lt;li>验证&lt;/li>
&lt;li>缓存&lt;/li>
&lt;li>控制&lt;/li>
&lt;li>Cookie&lt;/li>
&lt;li>。。。等等&lt;/li>
&lt;/ul>
&lt;h2 id="cookie">Cookie&lt;a class="td-heading-self-link" href="#cookie" aria-label="Heading self-link">&lt;/a>&lt;/h2>
&lt;p>&lt;a href="https://datatracker.ietf.org/doc/html/rfc6265">RFC 6265&lt;/a>&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>Header&lt;/th>
&lt;th>Header 分类&lt;/th>
&lt;th>Herader 用途&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>&lt;strong>Cookie&lt;/strong>&lt;/td>
&lt;td>请求头&lt;/td>
&lt;td>客户端将存储的 cookie 在 Cookie 标头中发送到源服务器。&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;strong>Set-Cookie&lt;/strong>&lt;/td>
&lt;td>响应头&lt;/td>
&lt;td>Set-Cookie HTTP 响应头用于将 cookie 从服务器发送到客户端。客户端接收到 Set-Cookie 响应头后，将会咱自身内部设置 cookie。&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>Notes: 如果想要设置 Cookie，服务端必须使用 Set-Cookie 将 cookie 的 key 和 value 发送给服务端。如果想要在登录时获取某些 Cookie 信息，也可以从 Set-Cookie 响应头中查找&lt;/p>
&lt;p>比如登录京东&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/http/202406211748714.png" alt="image.png">&lt;/p></description></item><item><title>Docs: HTTP Status Codes</title><link>https://desistdaydream.github.io/docs/4.%E6%95%B0%E6%8D%AE%E9%80%9A%E4%BF%A1/Protocol/HTTP/HTTP-Status-Codes/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/4.%E6%95%B0%E6%8D%AE%E9%80%9A%E4%BF%A1/Protocol/HTTP/HTTP-Status-Codes/</guid><description>
&lt;h1 id="概述">概述&lt;a class="td-heading-self-link" href="#%e6%a6%82%e8%bf%b0" aria-label="Heading self-link">&lt;/a>&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://datatracker.ietf.org/doc/html/rfc7231#section-6">RFC 7231,第六章-响应状态码&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;h1 id="http-的-status-状态码和-reason-phrase-原因短语">HTTP 的 Status 状态码和 Reason-Phrase 原因短语&lt;a class="td-heading-self-link" href="#http-%e7%9a%84-status-%e7%8a%b6%e6%80%81%e7%a0%81%e5%92%8c-reason-phrase-%e5%8e%9f%e5%9b%a0%e7%9f%ad%e8%af%ad" aria-label="Heading self-link">&lt;/a>&lt;/h1>
&lt;p>常用 200,301,302,304,401,403,404,500,502&lt;/p>
&lt;h2 id="http-常见的状态码">HTTP 常见的状态码&lt;a class="td-heading-self-link" href="#http-%e5%b8%b8%e8%a7%81%e7%9a%84%e7%8a%b6%e6%80%81%e7%a0%81" aria-label="Heading self-link">&lt;/a>&lt;/h2>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/ytigiz/1616161194550-be1a091b-4d94-4180-97cb-9a54f082ca47.png" alt="">&lt;/p>
&lt;h2 id="五大类-http-状态码">五大类 HTTP 状态码&lt;a class="td-heading-self-link" href="#%e4%ba%94%e5%a4%a7%e7%b1%bb-http-%e7%8a%b6%e6%80%81%e7%a0%81" aria-label="Heading self-link">&lt;/a>&lt;/h2>
&lt;p>&lt;em>1xx&lt;/em>&lt;/p>
&lt;p>&lt;code>1xx&lt;/code> 类状态码属于&lt;strong>提示信息&lt;/strong>，是协议处理中的一种中间状态，实际用到的比较少。&lt;/p>
&lt;p>&lt;em>2xx&lt;/em>&lt;/p>
&lt;p>&lt;code>2xx&lt;/code> 类状态码表示服务器&lt;strong>成功&lt;/strong>处理了客户端的请求，也是我们最愿意看到的状态。&lt;/p>
&lt;p>「&lt;strong>200 OK&lt;/strong>」是最常见的成功状态码，表示一切正常。如果是非 &lt;code>HEAD&lt;/code> 请求，服务器返回的响应头都会有 body 数据。&lt;/p>
&lt;p>「&lt;strong>204 No Content&lt;/strong>」也是常见的成功状态码，与 200 OK 基本相同，但响应头没有 body 数据。&lt;/p>
&lt;p>「&lt;strong>206 Partial Content&lt;/strong>」是应用于 HTTP 分块下载或断点续传，表示响应返回的 body 数据并不是资源的全部，而是其中的一部分，也是服务器处理成功的状态。&lt;/p>
&lt;p>&lt;em>3xx&lt;/em>&lt;/p>
&lt;p>&lt;code>3xx&lt;/code> 类状态码表示客户端请求的资源发送了变动，需要客户端用新的 URL 重新发送请求获取资源，也就是&lt;strong>重定向&lt;/strong>。&lt;/p>
&lt;p>「&lt;strong>301 Moved Permanently&lt;/strong>」表示永久重定向，说明请求的资源已经不存在了，需改用新的 URL 再次访问。&lt;/p>
&lt;p>「&lt;strong>302 Found&lt;/strong>」表示临时重定向，说明请求的资源还在，但暂时需要用另一个 URL 来访问。&lt;/p>
&lt;p>301 和 302 都会在响应头里使用字段 &lt;code>Location&lt;/code>，指明后续要跳转的 URL，浏览器会自动重定向新的 URL。&lt;/p>
&lt;p>「&lt;strong>304 Not Modified&lt;/strong>」不具有跳转的含义，表示资源未修改，重定向已存在的缓冲文件，也称缓存重定向，用于缓存控制。&lt;/p>
&lt;p>&lt;em>4xx&lt;/em>&lt;/p>
&lt;p>&lt;code>4xx&lt;/code> 类状态码表示客户端发送的&lt;strong>报文有误&lt;/strong>，服务器无法处理，也就是错误码的含义。&lt;/p>
&lt;p>「&lt;strong>400 Bad Request&lt;/strong>」表示客户端请求的报文有错误，但只是个笼统的错误。&lt;/p>
&lt;p>「&lt;strong>403 Forbidden&lt;/strong>」表示服务器禁止访问资源，并不是客户端的请求出错。&lt;/p>
&lt;p>「&lt;strong>404 Not Found&lt;/strong>」表示请求的资源在服务器上不存在或未找到，所以无法提供给客户端。&lt;/p>
&lt;p>&lt;em>5xx&lt;/em>&lt;/p>
&lt;p>&lt;code>5xx&lt;/code> 类状态码表示客户端请求报文正确，但是&lt;strong>服务器处理时内部发生了错误&lt;/strong>，属于服务器端的错误码。&lt;/p>
&lt;p>「&lt;strong>500 Internal Server Error&lt;/strong>」与 400 类型，是个笼统通用的错误码，服务器发生了什么错误，我们并不知道。&lt;/p>
&lt;p>「&lt;strong>501 Not Implemented&lt;/strong>」表示客户端请求的功能还不支持，类似“即将开业，敬请期待”的意思。&lt;/p>
&lt;p>「&lt;strong>502 Bad Gateway&lt;/strong>」通常是服务器作为网关或代理时返回的错误码，表示服务器自身工作正常，访问后端服务器发生了错误。&lt;/p>
&lt;p>「&lt;strong>503 Service Unavailable&lt;/strong>」表示服务器当前很忙，暂时无法响应服务器，类似“网络服务正忙，请稍后重试”的意思。&lt;/p>
&lt;h1 id="状态码">状态码&lt;a class="td-heading-self-link" href="#%e7%8a%b6%e6%80%81%e7%a0%81" aria-label="Heading self-link">&lt;/a>&lt;/h1>
&lt;h2 id="消息1xx">消息，1XX&lt;a class="td-heading-self-link" href="#%e6%b6%88%e6%81%af1xx" aria-label="Heading self-link">&lt;/a>&lt;/h2>
&lt;p>这一类型的状态码，代表请求已被接受，需要继续处理。这类响应是临时响应，只包含状态行和某些可选的响应头信息，并以空行结束。由于 HTTP/1.0 协议中没有定义任何 1xx 状态码，所以除非在某些试验条件下，服务器禁止向此类客户端发送 1xx 响应。&lt;/p>
&lt;ul>
&lt;li>100 Continue，客户端应当继续发送请求。这个临时响应是用来通知客户端它的部分请求已经被服务器接收，且仍未被拒绝。客户端应当继续发送请求的剩余部分，或者如果请求已经完成，忽略这个响应。服务器必须在请求完成后向客户端发送一个最终响应。&lt;/li>
&lt;li>101 Switching Protocols，服务器已经理解了客户端的请求，并将通过 Upgrade 消息头通知客户端采用不同的协议来完成这个请求。在发送完这个响应最后的空行后，服务器将会切换到在 Upgrade 消息头中定义的那些协议。只有在切换新的协议更有好处的时候才应该采取类似措施。例如，切换到新的 HTTP 版本比旧版本更有优势，或者切换到一个实时且同步的协议以传送利用此类特性的资源。&lt;/li>
&lt;/ul>
&lt;h2 id="成功2xx200-206">成功，2XX，（200-206）&lt;a class="td-heading-self-link" href="#%e6%88%90%e5%8a%9f2xx200-206" aria-label="Heading self-link">&lt;/a>&lt;/h2>
&lt;p>这一类型的状态码，代表请求已成功被服务器接收、理解、并接受&lt;/p>
&lt;ul>
&lt;li>200 OK，请求已成功，请求的所有数据通过响应报文的 Entity-Body 这一部分发送&lt;/li>
&lt;li>201 Created，请求已经被实现，而且有一个新的资源已经依据请求的需要而建立，且其 URI 已经随 Location 头信息返回。假如需要的资源无法及时建立的话，应当返回 &amp;lsquo;202 Accepted&amp;rsquo;。&lt;/li>
&lt;li>202 Accepted，服务器已接受请求，但尚未处理。正如它可能被拒绝一样，最终该请求可能会也可能不会被执行。在异步操作的场合下，没有比发送这个状态码更方便的做法了。返回 202 状态码的响应的目的是允许服务器接受其他过程的请求（例如某个每天只执行一次的基于批处理的操作），而不必让客户端一直保持与服务器的连接直到批处理操作全部完成。在接受请求处理并返回 202 状态码的响应应当在返回的实体中包含一些指示处理当前状态的信息，以及指向处理状态监视器或状态预测的指针，以便用户能够估计操作是否已经完成。&lt;/li>
&lt;li>203 Non-Authoritative Information，服务器已成功处理了请求，但返回的实体头部元信息不是在原始服务器上有效的确定集合，而是来自本地或者第三方的拷贝。当前的信息可能是原始版本的子集或者超集。例如，包含资源的元数据可能导致原始服务器知道元信息的超集。使用此状态码不是必须的，而且只有在响应不使用此状态码便会返回 200 OK 的情况下才是合适的。&lt;/li>
&lt;li>204 No Content，服务器成功处理了请求，但不需要返回任何实体内容，并且希望返回更新了的元信息。响应可能通过实体头部的形式，返回新的或更新后的元信息。如果存在这些头部信息，则应当与所请求的变量相呼应。如果客户端是浏览器的话，那么用户浏览器应保留发送了该请求的页面，而不产生任何文档视图上的变化，即使按照规范新的或更新后的元信息应当被应用到用户浏览器活动视图中的文档。由于 204 响应被禁止包含任何消息体，因此它始终以消息头后的第一个空行结尾。&lt;/li>
&lt;li>205 Reset Content，服务器成功处理了请求，且没有返回任何内容。但是与 204 响应不同，返回此状态码的响应要求请求者重置文档视图。该响应主要是被用于接受用户输入后，立即重置表单，以便用户能够轻松地开始另一次输入。&lt;/li>
&lt;li>与 204 响应一样，该响应也被禁止包含任何消息体，且以消息头后的第一个空行结束。&lt;/li>
&lt;li>206 Partial Content，服务器已经成功处理了部分 GET 请求。类似于 FlashGet 或者迅雷这类的 HTTP 下载工具都是使用此类响应实现断点续传或者将一个大文档分解为多个下载段同时下载。该请求必须包含 Range 头信息来指示客户端希望得到的内容范围，并且可能包含 If-Range 来作为请求条件。
&lt;ul>
&lt;li>响应必须包含如下的头部域：&lt;/li>
&lt;li>Content-Range 用以指示本次响应中返回的内容的范围；如果是 Content-Type 为 multipart/byteranges 的多段下载，则每一 multipart 段中都应包含 Content-Range 域用以指示本段的内容范围。假如响应中包含 Content-Length，那么它的数值必须匹配它返回的内容范围的真实字节数。&lt;/li>
&lt;li>Date&lt;/li>
&lt;li>ETag 和/或 Content-Location，假如同样的请求本应该返回 200 响应。&lt;/li>
&lt;li>Expires, Cache-Control，和/或 Vary，假如其值可能与之前相同变量的其他响应对应的值不同的话。&lt;/li>
&lt;li>假如本响应请求使用了 If-Range 强缓存验证，那么本次响应不应该包含其他实体头；假如本响应的请求使用了 If-Range 弱缓存验证，那么本次响应禁止包含其他实体头；这避免了缓存的实体内容和更新了的实体头信息之间的不一致。否则，本响应就应当包含所有本应该返回 200 响应中应当返回的所有实体头部域。&lt;/li>
&lt;li>假如 ETag 或 Last-Modified 头部不能精确匹配的话，则客户端缓存应禁止将 206 响应返回的内容与之前任何缓存过的内容组合在一起。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>207 Multi-Status，由 WebDAV(RFC 2518)扩展的状态码，代表之后的消息体将是一个 XML 消息，并且可能依照之前子请求数量的不同，包含一系列独立的响应代码。&lt;/li>
&lt;/ul>
&lt;h2 id="重定向3xx300-305">重定向，3XX（300-305）&lt;a class="td-heading-self-link" href="#%e9%87%8d%e5%ae%9a%e5%90%913xx300-305" aria-label="Heading self-link">&lt;/a>&lt;/h2>
&lt;p>Notes: 在访问一个网页时，除非收到 3XX 重定向的响应，否则浏览器地址栏中的地址是不会改变的，比如 Nginx 中的 rewrite 功能，如果不使用 &lt;strong>redirect&lt;/strong> 或 &lt;strong>permanent&lt;/strong> 标志，那么所有的 URL 改变都是针对 Nginx 内部来说的。&lt;/p>
&lt;p>这类状态码代表需要客户端采取进一步的操作才能完成请求。通常，这些状态码用来重定向，后续的请求地址（重定向的目标）在本次响应头的 Location 字段中指明。当且仅当后续的请求所使用的方法是 GET 或者 HEAD 时，用户浏览器才可以在没有用户介入的情况下自动提交所需要的后续请求。客户端应当自动监测无限循环重定向（例如：A-&amp;gt;A，或者 A-&amp;gt;B-&amp;gt;C-&amp;gt;A），因为这会导致服务器和客户端大量不必要的资源消耗。按照 HTTP/1.0 版规范的建议，浏览器不应自动访问超过 5 次的重定向。&lt;/p>
&lt;ul>
&lt;li>300 Multiple Choices，被请求的资源有一系列可供选择的回馈信息，每个都有自己特定的地址和浏览器驱动的商议信息。用户或浏览器能够自行选择一个首选的地址进行重定向。除非这是一个 HEAD 请求，否则该响应应当包括一个资源特性及地址的列表的实体，以便用户或浏览器从中选择最合适的重定向地址。这个实体的格式由 Content-Type 定义的格式所决定。浏览器可能根据响应的格式以及浏览器自身能力，自动作出最合适的选择。当然，RFC 2616 规范并没有规定这样的自动选择该如何进行。如果服务器本身已经有了首选的回馈选择，那么在 Location(位置)中应当指明这个回馈的 URL；浏览器可能会将这个 Location 值作为自动重定向的地址。此外，除非额外指定，否则这个响应也是可缓存的。&lt;/li>
&lt;li>301 Moved Permanently，永久重定向被请求的资源已永久移动到新位置，并且将来任何对此资源的引用都应该使用本响应返回的若干个 URL 之一。如果可能，拥有链接编辑功能的客户端应当自动把请求的地址修改为从服务器反馈回来的地址。除非额外指定，否则这个响应也是可缓存的。新的永久性的 URL 应当在响应的 Location 域中返回。除非这是一个 HEAD 请求，否则响应的实体中应当包含指向新的 URI 的超链接及简短说明。如果这不是一个 GET 或者 HEAD 请求，因此浏览器禁止自动进行重定向，除非得到用户的确认，因为请求的条件可能因此发生变化。
&lt;ul>
&lt;li>注意：对于某些使用 HTTP/1.0 协议的浏览器，当它们发送的 POST 请求得到了一个 301 响应的话，接下来的重定向请求将会变成 GET 方式。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>302 Move temporarily，临时重定向请求的资源临时从不同的 URL 响应请求。由于这样的重定向是临时的，客户端应当继续向原有地址发送以后的请求。只有在 Cache-Control 或 Expires 中进行了指定的情况下，这个响应才是可缓存的。如果这不是一个 GET 或者 HEAD 请求，那么浏览器禁止自动进行重定向，除非得到用户的确认，因为请求的条件可能因此发生变化。&lt;/li>
&lt;li>303 See Other，对应当前请求的响应可以在另一个 URI 上被找到，而且客户端应当采用 GET 的方式访问那个资源。这个方法的存在主要是为了允许由脚本激活的 POST 请求输出重定向到一个新的资源。这个新的 URI 不是原始资源的替代引用。同时，303 响应禁止被缓存。当然，第二个请求（重定向）可能被缓存。&lt;/li>
&lt;li>304 Not Modified，缓存没被修改，client 发出条件式请求，但 server 上的资源未曾发生改变（比如本地有缓存，client 就发出条件请求，向 server 确认该缓存是否有更新）如果客户端发送了一个带条件的 GET 请求且该请求已被允许，而文档的内容（自上次访问以来或者根据请求的条件）并没有改变，则服务器应当返回这个状态码。304 响应禁止包含消息体，因此始终以消息头后的第一个空行结尾。
&lt;ul>
&lt;li>该响应必须包含以下的头信息：
&lt;ul>
&lt;li>Date，除非这个服务器没有时钟。假如没有时钟的服务器也遵守这些规则，那么代理服务器以及客户端可以自行将 Date 字段添加到接收到的响应头中去，缓存机制将会正常工作。&lt;/li>
&lt;li>ETag 和/或 Content-Location，假如同样的请求本应返回 200 响应。&lt;/li>
&lt;li>Expires, Cache-Control，和/或 Vary，假如其值可能与之前相同变量的其他响应对应的值不同的话。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>假如本响应请求使用了强缓存验证，那么本次响应不应该包含其他实体头；否则（例如，某个带条件的 GET 请求使用了弱缓存验证），本次响应禁止包含其他实体头；这避免了缓存了的实体内容和更新了的实体头信息之间的不一致。&lt;/li>
&lt;li>假如某个 304 响应指明了当前某个实体没有缓存，那么缓存系统必须忽视这个响应，并且重复发送不包含限制条件的请求。&lt;/li>
&lt;li>假如接收到一个要求更新某个缓存条目的 304 响应，那么缓存系统必须更新整个条目以反映所有在响应中被更新的字段的值。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>305 Use Proxy，被请求的资源必须通过指定的代理才能被访问。Location 域中将给出指定的代理所在的 URI 信息，接收者需要重复发送一个单独的请求，通过这个代理才能访问相应资源。只有原始服务器才能建立 305 响应。&lt;/li>
&lt;li>306 Switch Proxy，在最新版的规范中，306 状态码已经不再被使用。&lt;/li>
&lt;li>307 Temporary Redirect，请求的资源临时从不同的 URI 响应请求。新的临时性的 URI 应当在响应的 Location 域中返回。除非这是一个 HEAD 请求，否则响应的实体中应当包含指向新的 URI 的超链接及简短说明。因为部分浏览器不能识别 307 响应，因此需要添加上述必要信息以便用户能够理解并向新的 URI 发出访问请求。如果这不是一个 GET 或者 HEAD 请求，那么浏览器禁止自动进行重定向，除非得到用户的确认，因为请求的条件可能因此发生变化。&lt;/li>
&lt;/ul>
&lt;h2 id="client-错误4xx400-415">client 错误，4XX（400-415）&lt;a class="td-heading-self-link" href="#client-%e9%94%99%e8%af%af4xx400-415" aria-label="Heading self-link">&lt;/a>&lt;/h2>
&lt;p>这类的状态码代表了客户端看起来可能发生了错误，妨碍了服务器的处理。除非响应的是一个 HEAD 请求，否则服务器就应该返回一个解释当前错误状况的实体，以及这是临时的还是永久性的状况。这些状态码适用于任何请求方法。浏览器应当向用户显示任何包含在此类错误响应中的实体内容。&lt;/p>
&lt;p>如果错误发生时客户端正在传送数据，那么使用 TCP 的服务器实现应当仔细确保在关闭客户端与服务器之间的连接之前，客户端已经收到了包含错误信息的数据包。如果客户端在收到错误信息后继续向服务器发送数据，服务器的 TCP 栈将向客户端发送一个重置数据包，以清除该客户端所有还未识别的输入缓冲，以免这些数据被服务器上的应用程序读取并干扰后者。&lt;/p>
&lt;ul>
&lt;li>400 Bad Request
&lt;ul>
&lt;li>语义有误，当前请求无法被服务器理解。除非进行修改，否则客户端不应该重复提交这个请求。&lt;/li>
&lt;li>请求参数有误。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>401 Unauthorized，当前请求需要用户验证。该响应必须包含一个适用于被请求资源的 WWW-Authenticate 信息头用以询问用户信息。客户端可以重复提交一个包含恰当的 Authorization 头信息的请求。如果当前请求已经包含了 Authorization 证书，那么 401 响应代表着服务器验证已经拒绝了那些证书。如果 401 响应包含了与前一个响应相同的身份验证询问，且浏览器已经至少尝试了一次验证，那么浏览器应当向用户展示响应中包含的实体信息，因为这个实体信息中可能包含了相关诊断信息。参见 RFC 2617。&lt;/li>
&lt;li>402 Payment Required，该状态码是为了将来可能的需求而预留的。&lt;/li>
&lt;li>403 Forbidden，请求被禁止，服务器已经理解请求，但是拒绝执行它。与 401 响应不同的是，身份验证并不能提供任何帮助，而且这个请求也不应该被重复提交。如果这不是一个 HEAD 请求，而且服务器希望能够讲清楚为何请求不能被执行，那么就应该在实体内描述拒绝的原因。当然服务器也可以返回一个 404 响应，假如它不希望让客户端获得任何信息。&lt;/li>
&lt;li>404 Not Found，server 无法找到 client 请求的 resource。没有信息能够告诉用户这个状况到底是暂时的还是永久的。假如服务器知道情况的话，应当使用 410 状态码来告知旧资源因为某些内部的配置机制问题，已经永久的不可用，而且没有任何可以跳转的地址。404 这个状态码被广泛应用于当服务器不想揭示到底为何请求被拒绝或者没有其他适合的响应可用的情况下。出现这个错误的最有可能的原因是服务器端没有这个页面。&lt;/li>
&lt;li>405 Method Not Allowed，请求行中指定的请求方法不能被用于请求相应的资源。该响应必须返回一个 Allow 头信息用以表示出当前资源能够接受的请求方法的列表。鉴于 PUT，DELETE 方法会对服务器上的资源进行写操作，因而绝大部分的网页服务器都不支持或者在默认配置下不允许上述请求方法，对于此类请求均会返回 405 错误。&lt;/li>
&lt;li>406 Not Acceptable，请求的资源的内容特性无法满足请求头中的条件，因而无法生成响应实体。除非这是一个 HEAD 请求，否则该响应就应当返回一个包含可以让用户或者浏览器从中选择最合适的实体特性以及地址列表的实体。实体的格式由 Content-Type 头中定义的媒体类型决定。浏览器可以根据格式及自身能力自行作出最佳选择。但是，规范中并没有定义任何作出此类自动选择的标准。&lt;/li>
&lt;li>407 Proxy Authentication Required，与 401 响应类似，只不过客户端必须在代理服务器上进行身份验证。代理服务器必须返回一个 Proxy-Authenticate 用以进行身份询问。客户端可以返回一个 Proxy-Authorization 信息头用以验证。参见 RFC 2617。&lt;/li>
&lt;li>408 Request Timeout，请求超时。客户端没有在服务器预备等待的时间内完成一个请求的发送。客户端可以随时再次提交这一请求而无需进行任何更改。&lt;/li>
&lt;li>409 Conflict，由于和被请求的资源的当前状态之间存在冲突，请求无法完成。这个代码只允许用在这样的情况下才能被使用：用户被认为能够解决冲突，并且会重新提交新的请求。该响应应当包含足够的信息以便用户发现冲突的源头。冲突通常发生于对 PUT 请求的处理中。例如，在采用版本检查的环境下，某次 PUT 提交的对特定资源的修改请求所附带的版本信息与之前的某个（第三方）请求向冲突，那么此时服务器就应该返回一个 409 错误，告知用户请求无法完成。此时，响应实体中很可能会包含两个冲突版本之间的差异比较，以便用户重新提交归并以后的新版本。&lt;/li>
&lt;li>410 Gone，被请求的资源在服务器上已经不再可用，而且没有任何已知的转发地址。这样的状况应当被认为是永久性的。如果可能，拥有链接编辑功能的客户端应当在获得用户许可后删除所有指向这个地址的引用。如果服务器不知道或者无法确定这个状况是否是永久的，那么就应该使用 404 状态码。除非额外说明，否则这个响应是可缓存的。410 响应的目的主要是帮助网站管理员维护网站，通知用户该资源已经不再可用，并且服务器拥有者希望所有指向这个资源的远端连接也被删除。这类事件在限时、增值服务中很普遍。同样，410 响应也被用于通知客户端在当前服务器站点上，原本属于某个个人的资源已经不再可用。当然，是否需要把所有永久不可用的资源标记为'410 Gone&amp;rsquo;，以及是否需要保持此标记多长时间，完全取决于服务器拥有者。&lt;/li>
&lt;li>411 Length Required，服务器拒绝在没有定义 Content-Length 头的情况下接受请求。在添加了表明请求消息体长度的有效 Content-Length 头之后，客户端可以再次提交该请求。&lt;/li>
&lt;li>412 Precondition Failed。服务器在验证在请求的头字段中给出先决条件时，没能满足其中的一个或多个。这个状态码允许客户端在获取资源时在请求的元信息（请求头字段数据）中设置先决条件，以此避免该请求方法被应用到其希望的内容以外的资源上。&lt;/li>
&lt;li>413 Request Entity Too Large。服务器拒绝处理当前请求，因为该请求提交的实体数据大小超过了服务器愿意或者能够处理的范围。此种情况下，服务器可以关闭连接以免客户端继续发送此请求。如果这个状况是临时的，服务器应当返回一个 Retry-After 的响应头，以告知客户端可以在多少时间以后重新尝试。&lt;/li>
&lt;li>414 Request-URI Too Long。请求的 URL 长度超过了服务器能够解释的长度，因此服务器拒绝对该请求提供服务。这比较少见，通常的情况包括：
&lt;ul>
&lt;li>本应使用 POST 方法的表单提交变成了 GET 方法，导致查询字符串（Query String）过长。&lt;/li>
&lt;li>重定向 URL “黑洞”，例如每次重定向把旧的 URI 作为新的 URI 的一部分，导致在若干次重定向后 URI 超长。&lt;/li>
&lt;li>客户端正在尝试利用某些服务器中存在的安全漏洞攻击服务器。这类服务器使用固定长度的缓冲读取或操作请求的 URI，当 GET 后的参数超过某个数值后，可能会产生缓冲区溢出，导致任意代码被执行。没有此类漏洞的服务器，应当返回 414 状态码。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>415 Unsupported Media Type。对于当前请求的方法和所请求的资源，请求中提交的实体并不是服务器中所支持的格式，因此请求被拒绝。&lt;/li>
&lt;li>416 Requested Range Not Satisfiable。如果请求中包含了 Range 请求头，并且 Range 中指定的任何数据范围都与当前资源的可用范围不重合，同时请求中又没有定义 If-Range 请求头，那么服务器就应当返回 416 状态码。假如 Range 使用的是字节范围，那么这种情况就是指请求指定的所有数据范围的首字节位置都超过了当前资源的长度。服务器也应当在返回 416 状态码的同时，包含一个 Content-Range 实体头，用以指明当前资源的长度。这个响应也被禁止使用 multipart/byteranges 作为其 Content-Type。&lt;/li>
&lt;li>417 Expectation Failed。在请求头 Expect 中指定的预期内容无法被服务器满足，或者这个服务器是一个代理服务器，它有明显的证据证明在当前路由的下一个节点上，Expect 的内容无法被满足。&lt;/li>
&lt;li>421 too many connections。There are too many connections from your internet address 从当前客户端所在的 IP 地址到服务器的连接数超过了服务器许可的最大范围。通常，这里的 IP 地址指的是从服务器上看到的客户端地址（比如用户的网关或者代理服务器地址）。在这种情况下，连接数的计算可能涉及到不止一个终端用户。&lt;/li>
&lt;li>426 Upgrade Required 是一种 HTTP 协议的错误状态代码，表示服务器拒绝处理客户端使用当前协议发送的请求，但是可以接受其使用升级后的协议发送的请求。比如 http1.0 发起请求，http1.1 响应请求，一般会出现这个状态码&lt;/li>
&lt;/ul>
&lt;h2 id="server-错误5xx500-505">server 错误，5XX（500-505）&lt;a class="td-heading-self-link" href="#server-%e9%94%99%e8%af%af5xx500-505" aria-label="Heading self-link">&lt;/a>&lt;/h2>
&lt;p>（5、6 字头）这类状态码代表了服务器在处理请求的过程中有错误或者异常状态发生，也有可能是服务器意识到以当前的软硬件资源无法完成对请求的处理。除非这是一个 HEAD 请求，否则服务器应当包含一个解释当前错误状态以及这个状况是临时的还是永久的解释信息实体。浏览器应当向用户展示任何在当前响应中被包含的实体。这些状态码适用于任何响应方法。&lt;/p>
&lt;ul>
&lt;li>500 Internal Server Error。服务器遇到了一个未曾预料的状况，导致了它无法完成对请求的处理。一般来说，这个问题都会在服务器端的源代码出现错误时出现。&lt;/li>
&lt;li>501 Not Implemented。服务器不支持当前请求所需要的某个功能。当服务器无法识别请求的方法，并且无法支持其对任何资源的请求。&lt;/li>
&lt;li>502 Bad Gateway。作为网关或者代理工作的服务器尝试执行请求时，从上游服务器接收到无效的响应。&lt;/li>
&lt;li>503 Service Unavailable。由于临时的服务器维护或者过载，服务器当前无法处理请求。这个状况是临时的，并且将在一段时间以后恢复。如果能够预计延迟时间，那么响应中可以包含一个 Retry-After 头用以标明这个延迟时间。如果没有给出这个 Retry-After 信息，那么客户端应当以处理 500 响应的方式处理它。
&lt;ul>
&lt;li>注意：503 状态码的存在并不意味着服务器在过载的时候必须使用它。某些服务器只不过是希望拒绝客户端的连接。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>504 Gateway Timeout。作为网关或者代理工作的服务器尝试执行请求时，未能及时从上游服务器（URI 标识出的服务器，例如 HTTP、FTP、LDAP）或者辅助服务器（例如 DNS）收到响应。
&lt;ul>
&lt;li>注意：某些代理服务器在 DNS 查询超时时会返回 400 或者 500 错误&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>505 HTTP Version Not Supported。服务器不支持，或者拒绝支持在请求中使用的 HTTP 版本。这暗示着服务器不能或不愿使用与客户端相同的版本。响应中应当包含一个描述了为何版本不被支持以及服务器支持哪些协议的实体。&lt;/li>
&lt;li>506 Variant Also Negotiates。由《透明内容协商协议》（RFC 2295）扩展，代表服务器存在内部配置错误：被请求的协商变元资源被配置为在透明内容协商中使用自己，因此在一个协商处理中不是一个合适的重点。&lt;/li>
&lt;li>507 Insufficient Storage。服务器无法存储完成请求所必须的内容。这个状况被认为是临时的。WebDAV (RFC 4918)&lt;/li>
&lt;li>509 Bandwidth Limit Exceeded。服务器达到带宽限制。这不是一个官方的状态码，但是仍被广泛使用。&lt;/li>
&lt;li>510 Not Extended。获取资源所需要的策略并没有被满足。（RFC 2774）&lt;/li>
&lt;li>600 Unparseable Response Headers。源站没有返回响应头部，只返回实体内容&lt;/li>
&lt;/ul></description></item><item><title>Docs: HTTP 的 持久化 与 认证_授权</title><link>https://desistdaydream.github.io/docs/4.%E6%95%B0%E6%8D%AE%E9%80%9A%E4%BF%A1/Protocol/HTTP/HTTP-%E4%BC%9A%E8%AF%9D%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/4.%E6%95%B0%E6%8D%AE%E9%80%9A%E4%BF%A1/Protocol/HTTP/HTTP-%E4%BC%9A%E8%AF%9D%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86/</guid><description/></item><item><title>Docs: HTTP 的实现</title><link>https://desistdaydream.github.io/docs/4.%E6%95%B0%E6%8D%AE%E9%80%9A%E4%BF%A1/Protocol/HTTP/HTTP-%E7%9A%84%E5%AE%9E%E7%8E%B0/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/4.%E6%95%B0%E6%8D%AE%E9%80%9A%E4%BF%A1/Protocol/HTTP/HTTP-%E7%9A%84%E5%AE%9E%E7%8E%B0/</guid><description>
&lt;p>HTTP 服务器的程序(想提供 web 服务必须要安装一下程序中的一个)&lt;/p>
&lt;ul>
&lt;li>httpd(apache)&lt;/li>
&lt;li>nginx&lt;/li>
&lt;li>lighttpd&lt;/li>
&lt;li>应用程序服务器：上面的程序如果不附加插件则只支持静态的网页，装上下面的程序还能解析 PHP 等动态界面
&lt;ul>
&lt;li>IIS&lt;/li>
&lt;li>tomcat，jetty，就 boss，resin&lt;/li>
&lt;li>webshpere,weblogic,oc4j&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h1 id="httpd">httpd&lt;a class="td-heading-self-link" href="#httpd" aria-label="Heading self-link">&lt;/a>&lt;/h1>
&lt;p>apache(a patchy server)的特性&lt;/p>
&lt;ul>
&lt;li>高度模块化：core+modules&lt;/li>
&lt;li>DSO：Dynamic Shared Object&lt;/li>
&lt;li>MPM：Multipath Processing Modules 多路处理模块，不同的工作方式，可以切换，使用不同模块可以满足不同需求
&lt;ul>
&lt;li>prefork：多进程模型，每个进程响应一个请求
&lt;ul>
&lt;li>一个主进程：负责生成 n 个子近侧很难过，子进程也成为工作进程，每个子进程处理一个用户请求，即便没有用户请求，也会预先生成多个空闲进程，随时等待请求到达，最大不超过 1024 个&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>worker：多线程模型
&lt;ul>
&lt;li>一个主进程：负责生成子进程；负责创建套接字；负责接收请求，并将其派发给某子进程进行处理；&lt;/li>
&lt;li>多个子进程：每个子进程负责生成多个线程；&lt;/li>
&lt;li>每个线程：负责响应用户请求；&lt;/li>
&lt;li>并发响应数量：m*n&lt;/li>
&lt;li>m：子进程数量&lt;/li>
&lt;li>n：每个子进程所能创建的最大线程数量；&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>event：事件驱动模型，多进程模型，每个进程响应多个请求（老版本系统不支持，systemd 系统支持）
&lt;ul>
&lt;li>一个主进程 ：负责生成子进程；负责创建套接字；负责接收请求，并将其派发给某子进程进行处理；&lt;/li>
&lt;li>子进程：基于事件驱动机制直接响应多个请求；&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h2 id="httpd-配置">Httpd 配置&lt;a class="td-heading-self-link" href="#httpd-%e9%85%8d%e7%bd%ae" aria-label="Heading self-link">&lt;/a>&lt;/h2>
&lt;p>程序环境(.init 系统下)&lt;/p>
&lt;ul>
&lt;li>配置文件
&lt;ul>
&lt;li>/etc/httpd/conf/httpd.conf&lt;/li>
&lt;li>/etc/httpd/conf.d/*.conf&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>服务脚本
&lt;ul>
&lt;li>/etc/rc.d/init.d/httpd&lt;/li>
&lt;li>配置文件/etc/sysconfig/httpd&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>主程序文件
&lt;ul>
&lt;li>/usr/sbin/httpd&lt;/li>
&lt;li>/usr/sbin/httpd.event&lt;/li>
&lt;li>/usr/sbin/httpd.worker&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>日志文件目录
&lt;ul>
&lt;li>/var/log/httpd
&lt;ul>
&lt;li>access_log:访问日志&lt;/li>
&lt;li>error_log:错误日志&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>站点文档目录
&lt;ul>
&lt;li>/var/www/html&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul></description></item><item><title>Docs: HTTP 管理</title><link>https://desistdaydream.github.io/docs/4.%E6%95%B0%E6%8D%AE%E9%80%9A%E4%BF%A1/Protocol/HTTP/HTTP-%E7%AE%A1%E7%90%86/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/4.%E6%95%B0%E6%8D%AE%E9%80%9A%E4%BF%A1/Protocol/HTTP/HTTP-%E7%AE%A1%E7%90%86/</guid><description/></item><item><title>Docs: HTTP 缓存</title><link>https://desistdaydream.github.io/docs/4.%E6%95%B0%E6%8D%AE%E9%80%9A%E4%BF%A1/Protocol/HTTP/HTTP-%E7%BC%93%E5%AD%98/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/4.%E6%95%B0%E6%8D%AE%E9%80%9A%E4%BF%A1/Protocol/HTTP/HTTP-%E7%BC%93%E5%AD%98/</guid><description/></item><item><title>Docs: HTTPS</title><link>https://desistdaydream.github.io/docs/4.%E6%95%B0%E6%8D%AE%E9%80%9A%E4%BF%A1/Protocol/HTTP/HTTPS/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/4.%E6%95%B0%E6%8D%AE%E9%80%9A%E4%BF%A1/Protocol/HTTP/HTTPS/</guid><description/></item></channel></rss>