<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>断念梦的站点 – Tunneling Protocol(隧道协议)</title><link>https://desistdaydream.github.io/docs/4.%E6%95%B0%E6%8D%AE%E9%80%9A%E4%BF%A1/Protocol/Tunneling-Protocol/</link><description>Recent content in Tunneling Protocol(隧道协议) on 断念梦的站点</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><atom:link href="https://desistdaydream.github.io/docs/4.%E6%95%B0%E6%8D%AE%E9%80%9A%E4%BF%A1/Protocol/Tunneling-Protocol/index.xml" rel="self" type="application/rss+xml"/><item><title>Docs: Tunneling Protocol</title><link>https://desistdaydream.github.io/docs/4.%E6%95%B0%E6%8D%AE%E9%80%9A%E4%BF%A1/Protocol/Tunneling-Protocol/Tunneling-Protocol/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/4.%E6%95%B0%E6%8D%AE%E9%80%9A%E4%BF%A1/Protocol/Tunneling-Protocol/Tunneling-Protocol/</guid><description>
&lt;h1 id="概述">概述&lt;a class="td-heading-self-link" href="#%e6%a6%82%e8%bf%b0" aria-label="Heading self-link">&lt;/a>&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Tunneling_protocol">Wiki, Tunneling Protocol&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Overlay_network">Wiki, Overlay Network&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>&lt;strong>Tunneling Protocol(隧道协议)&lt;/strong> 是一种通信协议，允许数据从一个网络移动到另一个网络。该协议通过通信协议中 &lt;a href="https://desistdaydream.github.io/docs/4.%E6%95%B0%E6%8D%AE%E9%80%9A%E4%BF%A1/Protocol/%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE.md#Encapsulation(%E5%B0%81%E8%A3%85)">Encapsulation(封装)&lt;/a> 的过程跨公共网络发送专用网络通信。因为隧道涉及将流量数据重新打包为不同的形式，可能以加密为标准，它可以隐藏通过隧道运行的流量的性质。隧道协议通过使用数据包的 Payload(数据部分) 来承载实际提供服务的数据包。隧道使用分层协议模型，例如 OSI 或 TCP/IP 协议套件中的那些，但在使用有效载荷承载网络通常不提供的服务时通常会违反分层。通常，在分层模型中，传送协议在与有效载荷协议相同或更高的级别上运行。&lt;/p>
&lt;p>隧道技术是一种通过使用互联网络的基础设施在网络之间传递数据的方式。使用隧道传递的数据（或负载）可以是不同协议的数据帧或包。隧道协议将其它协议的数据帧或包重新封装然后通过隧道发送。新的帧头提供路由信息，以便通过互联网传递被封装的负载数据。&lt;/p>
&lt;p>隧道的常见用途&lt;/p>
&lt;ul>
&lt;li>隧道协议可以允许外部协议在不支持该特定协议的网络上运行，例如在 IPv4 上运行 IPv6。&lt;/li>
&lt;li>另一个重要用途是提供仅使用底层网络服务提供的不切实际或不安全的服务，例如向其物理网络地址不属于公司网络的远程用户提供公司网络地址。&lt;/li>
&lt;li>用户还可以使用隧道“潜入”防火墙，使用防火墙通常会阻止的协议，但“包装”在防火墙不会阻止的协议中，例如 HTTP。如果防火墙策略没有明确排除这种“包装”，则此技巧可以绕过预期的防火墙策略（或任何一组互锁的防火墙策略）。&lt;/li>
&lt;li>另一种基于 HTTP 的隧道方法使用 HTTP CONNECT 方法/命令。客户端向 HTTP 代理发出 HTTP CONNECT 命令。然后，代理与特定的 server:port 建立 TCP 连接，并在该 server:port 和客户端连接之间中继数据。 [1]因为这会产生安全漏洞，所以支持 CONNECT 的 HTTP 代理通常会限制对 CONNECT 方法的访问。代理仅允许连接到特定端口，例如 HTTPS 的 443。&lt;/li>
&lt;/ul>
&lt;p>应用场景：&lt;/p>
&lt;ul>
&lt;li>一个公司在天津与北京分别有一个办公地点，天津的内网为 10.0.0.0/24，北京的内网为 10.0.1.0/24。那么如何让两个内网互通呢?可以使用 tunnel 技术，在两地公网出口建立隧道连接。天津访问北京的时候，目的内网地址是封装在公网 IP 里面的，这样就可以让私网地址的数据在公网传输。比如大企业都有自己的隧道网络，当使用个人电脑，安装上某些隧道软件后，那么这台电脑就可以访问公司内部网络了。&lt;/li>
&lt;/ul>
&lt;h2 id="overlay">Overlay&lt;a class="td-heading-self-link" href="#overlay" aria-label="Heading self-link">&lt;/a>&lt;/h2>
&lt;p>&lt;strong>Overlay(叠加网络)&lt;/strong> 实际上是一种隧道封装技术，是对隧道技术的扩展。传统隧道技术仅限于隧道两端通信，而 Overlay 网络则可以实现 N 个端点之间的互相通信。&lt;/p>
&lt;h2 id="vpn">VPN&lt;a class="td-heading-self-link" href="#vpn" aria-label="Heading self-link">&lt;/a>&lt;/h2>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Virtual_private_network">Wiki, VPN&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>&lt;strong>Virtual Private Network(虚拟专用网络，简称 VPN)&lt;/strong> 是通过&lt;strong>隧道协议&lt;/strong>建立的虚拟点对点连接。可以从逻辑上，让人们将通过 VPN 将两个或多个互不连接的网络打通，组成一个更大型的局域网。&lt;/p>
&lt;p>VPN 程序&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://github.com/gsliepen/tinc">tinc&lt;/a> 是一个虚拟专用网络 (VPN) 守护程序&lt;/li>
&lt;/ul>
&lt;h1 id="protocol">Protocol&lt;a class="td-heading-self-link" href="#protocol" aria-label="Heading self-link">&lt;/a>&lt;/h1>
&lt;p>Tunnel 技术的实现方式：&lt;/p>
&lt;ul>
&lt;li>基于数据包:
&lt;ul>
&lt;li>IP in IP，比 GRE 更小的负载头，并且适合只有负载一个 IP 流的情况。&lt;/li>
&lt;li>&lt;a href="https://desistdaydream.github.io/docs/4.%E6%95%B0%E6%8D%AE%E9%80%9A%E4%BF%A1/Protocol/Tunneling%20Protocol/GRE.md">GRE&lt;/a>，支持多种网络层协议和多路技术&lt;/li>
&lt;li>&lt;a href="https://desistdaydream.github.io/docs/4.%E6%95%B0%E6%8D%AE%E9%80%9A%E4%BF%A1/Protocol/Tunneling%20Protocol/PPTP.md">PPTP&lt;/a>（点对点隧道协议）&lt;/li>
&lt;li>SSTP 安全的 PPTP&lt;/li>
&lt;li>IPsec/L2TP（数据链接层隧道协议）&lt;/li>
&lt;li>&lt;a href="https://desistdaydream.github.io/docs/4.%E6%95%B0%E6%8D%AE%E9%80%9A%E4%BF%A1/Protocol/Tunneling%20Protocol/WireGuard/WireGuard.md">WireGuard&lt;/a>&lt;/li>
&lt;li>依赖其他协议实现的隧道功能
&lt;ul>
&lt;li>SSL&lt;/li>
&lt;li>SSH&lt;/li>
&lt;li>SOCKS&lt;/li>
&lt;li>等&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;hr>
&lt;p>&lt;strong>Encrypted Tunnel Protocol(加密的隧道协议)&lt;/strong> 用以保障通信安全。很长时间以来，Linux 中加密隧道的标准解决方案是 IPsec。&lt;/p>
&lt;p>基于这种安全能的实现，很多这类协议都被用来规避审查，以便从中国境内可以顺利访问国际互联网。&lt;/p>
&lt;p>Shadowsocks&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Shadowsocks">https://en.wikipedia.org/wiki/Shadowsocks&lt;/a>&lt;/li>
&lt;/ul>
&lt;p>&lt;a href="https://desistdaydream.github.io/docs/4.%E6%95%B0%E6%8D%AE%E9%80%9A%E4%BF%A1/Protocol/Tunneling%20Protocol/Vmess.md">Vmess&lt;/a>&lt;/p>
&lt;p>VLESS&lt;/p>
&lt;p>Trojan/Trojan-Go&lt;/p>
&lt;p>Hysteria&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://github.com/apernet/hysteria">https://github.com/apernet/hysteria&lt;/a>&lt;/li>
&lt;/ul>
&lt;h2 id="实现各种隧道协议的系统">实现各种隧道协议的系统&lt;a class="td-heading-self-link" href="#%e5%ae%9e%e7%8e%b0%e5%90%84%e7%a7%8d%e9%9a%a7%e9%81%93%e5%8d%8f%e8%ae%ae%e7%9a%84%e7%b3%bb%e7%bb%9f" aria-label="Heading self-link">&lt;/a>&lt;/h2>
&lt;p>&lt;a href="https://github.com/libreswan/libreswan">libreswan&lt;/a> # IPsec 服务器&lt;/p>
&lt;p>&lt;a href="https://github.com/xelerance/xl2tpd">xl2tpd&lt;/a> # L2TP 提供者&lt;/p>
&lt;p>&lt;a href="https://desistdaydream.github.io/docs/4.%E6%95%B0%E6%8D%AE%E9%80%9A%E4%BF%A1/Protocol/Tunneling%20Protocol/WireGuard/WireGuard.md">WireGuard&lt;/a>&lt;/p>
&lt;p>OpenVPN # 基于 SSL 的 VPN 系统，广泛使用 OpenSSL 加密库和 TLS 协议。&lt;/p>
&lt;h1 id="overlay-1">Overlay&lt;a class="td-heading-self-link" href="#overlay-1" aria-label="Heading self-link">&lt;/a>&lt;/h1>
&lt;p>overlay 技术，一般都需要一个第三方程序来实现(这个程序可以是一个守护进程、内核等等)。这个程序的作用就是让本身并不互通的内部网络可以互通(比如不同宿主机上的容器互通 2.flannel.note 或者不同宿主机上的虚拟机互通或者)。而让这些网络互通的信息(比如路由、arp 等)就是由这个第三方程序来保存并维护的。如下图所示&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/qw0o0m/1616160946658-7d2f69f8-d44e-4bd6-981c-5752d093bdff.jpeg" alt="">&lt;/p>
&lt;p>现在想要 10.244.0.1 可以 ping 通 10.244.1.1。那么 node1 就需要知道 10.244.1.1 在哪台宿主机上。而这种信息，就是靠可以实现 overlay 功能的程序或者内核(甚至几条路由表的规则)来保存并维护的。凡是连接到 overlay 程序的容器，其本身的 IP 以及所在宿主机的 IP，都会被保存下来，以便通信时可以使用。而这些数据，宿主机并不需要知道，在把要发送的数据包交给宿主机的网络栈时，数据包中的目的地址，如果是 10.244.1.0/24 网段的，那么 192.168.0.1 宿主机本身并不知道，所以，overlay 程序的其中一个功能，就是在数据包外面进行封装，把本身的目的地址掩盖起来，并把自己维护的信息中的可以被宿主机识别的 IP 地址填上，这样，就会形成 IP 套 IP 的效果，也就是上面的 tunnel 的效果。这时候，当宿主机收到数据包的时候，就会清楚的知道，要发送到哪里，而 node2 再接收到数据包并解封装后，会看到 overlay 程序封装的信息，就会把数据包交给本机的 overlay 程序，进行后续处理.&lt;/p>
&lt;p>Overlay 技术的实现就是 VXLAN，关于 VXLAN 的介绍，可以参考 &lt;a href="https://desistdaydream.github.io/docs/10.%E4%BA%91%E5%8E%9F%E7%94%9F/Kubernetes/Kubernetes%20%E7%BD%91%E7%BB%9C/CNI/Flannel.md">Flannel&lt;/a> 中的 VXLAN 模型，其中有关于 VXLAN 工作流程的详细讲解&lt;/p></description></item><item><title>Docs: PPTP</title><link>https://desistdaydream.github.io/docs/4.%E6%95%B0%E6%8D%AE%E9%80%9A%E4%BF%A1/Protocol/Tunneling-Protocol/PPTP/</link><pubDate>Sat, 18 Jul 2020 09:37:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/4.%E6%95%B0%E6%8D%AE%E9%80%9A%E4%BF%A1/Protocol/Tunneling-Protocol/PPTP/</guid><description>
&lt;h1 id="概述">概述&lt;a class="td-heading-self-link" href="#%e6%a6%82%e8%bf%b0" aria-label="Heading self-link">&lt;/a>&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;/blockquote>
&lt;p>&lt;strong>Point-to-Point Tunneling Protocol(点对点隧道协议，简称 PPTP)&lt;/strong> 是一种过时的实现虚拟专用网络的方法。 PPTP 有许多众所周知的安全问题。&lt;/p>
&lt;blockquote>
&lt;p>Note：pptpd 存在安全隐患，详情可参考&lt;a href="http://pptpclient.sourceforge.net/protocol-security.phtml">这里&lt;/a>&lt;/p>
&lt;/blockquote>
&lt;p>PPTP 使用 TCP 控制通道和通用路由封装隧道来封装 PPP 数据包。许多现代 VPN 使用各种形式的 UDP 来实现相同的功能。&lt;/p>
&lt;h1 id="poptop">Poptop&lt;a class="td-heading-self-link" href="#poptop" aria-label="Heading self-link">&lt;/a>&lt;/h1>
&lt;p>Poptop 是 The PPTP Server for Linux&lt;/p>
&lt;p>官方网址：http://poptop.sourceforge.net/&lt;/p>
&lt;h2 id="poptop-的安装">Poptop 的安装&lt;a class="td-heading-self-link" href="#poptop-%e7%9a%84%e5%ae%89%e8%a3%85" aria-label="Heading self-link">&lt;/a>&lt;/h2>
&lt;p>需要 epel 源&lt;/p>
&lt;p>yum install pptpd&lt;/p>
&lt;h2 id="poptop-关联文件与配置">Poptop 关联文件与配置&lt;a class="td-heading-self-link" href="#poptop-%e5%85%b3%e8%81%94%e6%96%87%e4%bb%b6%e4%b8%8e%e9%85%8d%e7%bd%ae" aria-label="Heading self-link">&lt;/a>&lt;/h2>
&lt;p>&lt;strong>/etc/pptpd.conf&lt;/strong> # pptpd 主程序的主配置文件&lt;/p>
&lt;p>localip IP # 当远程客户端连接到本地服务时，服务端建立虚拟网卡所用的 ip&lt;/p>
&lt;p>remoteip IP-Range # 远程客户端连接到本地服务后，可以分配的给客户端的 ip 范围&lt;/p>
&lt;p>Note：这俩配置完成后，当客户端连接时，就会出现下面虚拟网卡。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>4: ppp0: &amp;lt;POINTOPOINT,MULTICAST,NOARP,UP,LOWER_UP&amp;gt; mtu &lt;span style="color:#0000cf;font-weight:bold">1396&lt;/span> qdisc pfifo_fast state UNKNOWN group default qlen &lt;span style="color:#0000cf;font-weight:bold">3&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> link/ppp
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> inet 192.168.0.1 peer 192.168.0.234/32 scope global ppp0
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> valid_lft forever preferred_lft forever
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>/etc/ppp/options.pptpd # pptpd 主程序运行时参数&lt;/p>
&lt;p>ms-dns IP # 配置 DNS&lt;/p>
&lt;p>/etc/ppp/chap-secrets # 配置客户端连接时所用的用户名、密码、协议&lt;/p>
&lt;pre tabindex="0">&lt;code># Secrets for authentication using CHAP
# client server secret IP addresses
desistdaydream pptpd desistdaydream *
&lt;/code>&lt;/pre>&lt;p>client # 指定用户名&lt;/p>
&lt;p>server # 指定该用户连接时所用的协议&lt;/p>
&lt;p>secret # 指定该用户密码&lt;/p>
&lt;p>IP addresses # 所用的 ip,ip 可以用*表示该用户可用所有 ip&lt;/p>
&lt;h2 id="其他系统配置">其他系统配置&lt;a class="td-heading-self-link" href="#%e5%85%b6%e4%bb%96%e7%b3%bb%e7%bb%9f%e9%85%8d%e7%bd%ae" aria-label="Heading self-link">&lt;/a>&lt;/h2>
&lt;p>添加路由转发功能&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>cat &amp;gt;&amp;gt; /etc/sysctl.conf &lt;span style="color:#4e9a06">&amp;lt;&amp;lt; EOF
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#4e9a06">net.ipv4.ip_forward = 1
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#4e9a06">EOF&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>sysctl -p
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>配置防火墙&lt;/p>
&lt;pre tabindex="0">&lt;code>iptables -t nat -A POSTROUTING -s 192.168.0.0/24 -o eth0 -j MASQUERADE
&lt;/code>&lt;/pre>&lt;p>VPN iptables NAT 配置&lt;/p>
&lt;pre tabindex="0">&lt;code>iptables -t nat -A POSTROUTING -s 10.254.13.0/24 ! -d 10.254.13.0/24 -j SNAT --to-source 123.151.161.92
iptables -t nat -A POSTROUTING -s 192.168.16.0/20 -j MASQUERADE
&lt;/code>&lt;/pre>&lt;p>windows 配置&lt;/p></description></item><item><title>Docs: GRE</title><link>https://desistdaydream.github.io/docs/4.%E6%95%B0%E6%8D%AE%E9%80%9A%E4%BF%A1/Protocol/Tunneling-Protocol/GRE/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/4.%E6%95%B0%E6%8D%AE%E9%80%9A%E4%BF%A1/Protocol/Tunneling-Protocol/GRE/</guid><description>
&lt;h1 id="概述">概述&lt;a class="td-heading-self-link" href="#%e6%a6%82%e8%bf%b0" aria-label="Heading self-link">&lt;/a>&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>&lt;strong>Generic Routing Encapsulation(通用路由封装，简称 GRE)&lt;/strong> 是一种隧道协议，在数据两端，对数据进行封装和解封装。是 Cisco Systems 开发的隧道协议，可以通过 Internet 协议网络将各种网络层协议封装在虚拟点对点链路中。&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/qp0rg3/1616160946635-68a0d422-0333-48eb-aa84-f8f03f1c76a0.jpeg" alt="">&lt;/p>
&lt;p>如上图，当从本机想要通过隧道发送数据时，会通过 GRE 模块进行封装，然后把对外通信的 IP 地址当做 GRE 的外部地址，封装在最外成变成新的 IP。此时，GRE 还会有一个内部地址用来与隧道的对端进行协商，以便识别公网上的隧道两端的设备&lt;/p>
&lt;h2 id="linux-下实现-gre">Linux 下实现 GRE&lt;a class="td-heading-self-link" href="#linux-%e4%b8%8b%e5%ae%9e%e7%8e%b0-gre" aria-label="Heading self-link">&lt;/a>&lt;/h2>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/qp0rg3/1616160946644-61636d63-9002-4967-b9e5-98fb974f4fb7.jpeg" alt="">&lt;/p>
&lt;p>场景一：&lt;/p>
&lt;p>如果 Linux1 想要访问 10.10.2.0/24 网段的设备，这时候可以使用 GRE 建立隧道来实 现。比如在 Linux1 上想访问 10.10.2.100 这台设备，把数据包通过手动添加路由的方式，直接送给 tun 设备，tun 设备会直接把数据包发送给其隧道的对端(i.e.Linux2)，当 Linux2 收到这个数据包时，会发现 GRE 的包头，并解开 GRE 后发现真实的目的地址(10.10.2.100)，这时候可以在 Linux2 上做一个 snat，指明源地址 172.16.0.1/32 且目的地址是 10.10.2.0/24 网段的数据包全部把源地址转换成 10.10.2.1(如果不做 snat，源地址是 172.16.0.1，在回包的时候，是无法回去的，否则再添加其余路由条目)&lt;/p>
&lt;p>场景二：&lt;/p>
&lt;p>10.10.0.1/24 与 10.10.1.1/24 作为网段的网关使用，可以让两边的内网机器，直接互相访问。同样需要手动添加路由，目的地址是对端内网网段的 IP 的数据包送给 tun 设备。&lt;/p>
&lt;p>注意：在 Linux1 上 ping172.16.0.2 的时候，在 Linux2 上抓包的话，会显示源地址是 172.16.0.1。&lt;/p>
&lt;h2 id="配置方式">配置方式&lt;a class="td-heading-self-link" href="#%e9%85%8d%e7%bd%ae%e6%96%b9%e5%bc%8f" aria-label="Heading self-link">&lt;/a>&lt;/h2>
&lt;p>通过配置文件来进行配置&lt;/p>
&lt;p>Linux1的tun设备的配置文件：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-ini" data-lang="ini">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#c4a000">DEVICE&lt;/span>&lt;span style="color:#ce5c00;font-weight:bold">=&lt;/span>&lt;span style="color:#4e9a06">tun0&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#c4a000">ONBOOT&lt;/span>&lt;span style="color:#ce5c00;font-weight:bold">=&lt;/span>&lt;span style="color:#4e9a06">yes&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#c4a000">TYPE&lt;/span>&lt;span style="color:#ce5c00;font-weight:bold">=&lt;/span>&lt;span style="color:#4e9a06">GRE&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#c4a000">PEER_OUTER_IPADDR&lt;/span>&lt;span style="color:#ce5c00;font-weight:bold">=&lt;/span>&lt;span style="color:#4e9a06">100.0.2.100&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#c4a000">PEER_INNER_IPADDR&lt;/span>&lt;span style="color:#ce5c00;font-weight:bold">=&lt;/span>&lt;span style="color:#4e9a06">172.16.0.2/30&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#c4a000">MY_OUTER_IPADDR&lt;/span>&lt;span style="color:#ce5c00;font-weight:bold">=&lt;/span>&lt;span style="color:#4e9a06">100.0.1.100&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#c4a000">MY_INNER_IPADDR&lt;/span>&lt;span style="color:#ce5c00;font-weight:bold">=&lt;/span>&lt;span style="color:#4e9a06">172.16.0.1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#c4a000">KEY&lt;/span>&lt;span style="color:#ce5c00;font-weight:bold">=&lt;/span>&lt;span style="color:#4e9a06">desistdaydream&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#c4a000">BOOTPROTO&lt;/span>&lt;span style="color:#ce5c00;font-weight:bold">=&lt;/span>&lt;span style="color:#4e9a06">none&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8f5902;font-style:italic"># 配置完成后会自动下面的路由信息&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#c4a000">172.16.0.2/30 dev tun0 proto kernel scope link src 172.16.0.1/30&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Linux2的tun设备的配置文件：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-ini" data-lang="ini">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#c4a000">DEVICE&lt;/span>&lt;span style="color:#ce5c00;font-weight:bold">=&lt;/span>&lt;span style="color:#4e9a06">tun0&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#c4a000">ONBOOT&lt;/span>&lt;span style="color:#ce5c00;font-weight:bold">=&lt;/span>&lt;span style="color:#4e9a06">yes&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#c4a000">TYPE&lt;/span>&lt;span style="color:#ce5c00;font-weight:bold">=&lt;/span>&lt;span style="color:#4e9a06">GRE&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#c4a000">PEER_OUTER_IPADDR&lt;/span>&lt;span style="color:#ce5c00;font-weight:bold">=&lt;/span>&lt;span style="color:#4e9a06">100.0.1.100&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#c4a000">PEER_INNER_IPADDR&lt;/span>&lt;span style="color:#ce5c00;font-weight:bold">=&lt;/span>&lt;span style="color:#4e9a06">172.16.0.1/30&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#c4a000">MY_OUTER_IPADDR&lt;/span>&lt;span style="color:#ce5c00;font-weight:bold">=&lt;/span>&lt;span style="color:#4e9a06">100.0.2.100&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#c4a000">MY_INNER_IPADDR&lt;/span>&lt;span style="color:#ce5c00;font-weight:bold">=&lt;/span>&lt;span style="color:#4e9a06">172.16.0.2&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#c4a000">KEY&lt;/span>&lt;span style="color:#ce5c00;font-weight:bold">=&lt;/span>&lt;span style="color:#4e9a06">desistdaydream&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#c4a000">BOOTPROTO&lt;/span>&lt;span style="color:#ce5c00;font-weight:bold">=&lt;/span>&lt;span style="color:#4e9a06">none&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8f5902;font-style:italic"># 配置完成后会自动下面的路由信息&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#c4a000">172.16.0.1/30 dev tun0 proto kernel scope link src 172.16.0.2/30&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>如果想要实现场景一的功能,可以在 Linux1 上添加路由条目：&lt;code>ip route add 10.10.2.0/24 dev tun0&lt;/code>。在 Linux 添加 snat 规则：&lt;code>iptables -t nat -A POSTROUTING -s 1772.16.0.1 -d 10.10.2.0/24 -j SNAT --to-source 10.10.2.1&lt;/code>&lt;/p>
&lt;p>配置文件说明：&lt;/p>
&lt;ul>
&lt;li>PEER_OUTER_IPADDR=100.0.2.100 # 隧道外部对端地址。i.e.能让两台服务器互相访问的对端地址&lt;/li>
&lt;li>PEER_INNER_IPADDR=172.16.0.2/30 # 隧道内部对端地址。i.e.对端服务器的 tun 设备的 IP&lt;/li>
&lt;li>MY_OUTER_IPADDR=100.0.1.100 # 隧道外部本地地址。i.e.能让两台服务器互相访问的本地地址&lt;/li>
&lt;li>MY_INNER_IPADDR=172.16.0.1 # 隧道内部本地地址。i.e.本服务器的 tun 设备的 ip&lt;/li>
&lt;/ul>
&lt;p>从命令行来体现的话，PEER 就是命令行中的 remote 和 peer。MY 就是 local&lt;/p>
&lt;p>通过 ip 命令来进行配置&lt;/p>
&lt;p>Linux1 上的命令&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>ip tunnel add tun0 mode gre remote 100.0.2.100 &lt;span style="color:#204a87">local&lt;/span> 100.0.1.100
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>ip addr add 172.16.0.1/30 peer 172.16.0.2/30 dev tun0
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>ip route add 10.10.2.0/24 dev tun0
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Linux2 上的命令&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>ip tunnel add tun0 mode gre remote 100.0.2.100 &lt;span style="color:#204a87">local&lt;/span> 100.0.1.100
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>ip addr add 172.16.0.1/30 peer 172.16.0.2/30 dev tun0
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>ip route add 10.10.1.0/24 dev tun0
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>通过 NetworkManager 来进行配置&lt;/p>
&lt;p>Linux1 上的命令&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>nmcli connection add con-name tun0 ifname tun0 &lt;span style="color:#204a87">type&lt;/span> ip-tunnel mode gre ip-tunnel.remote 100.0.2.100 ip-tunnel.local 100.0.1.100 ipv4.method manual ipv4.addresses 172.16.0.1/30
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>ip route add 10.10.2.0/24 dev tun0
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Linux2 上的命令&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>nmcli connection add con-name tun0 ifname tun0 &lt;span style="color:#204a87">type&lt;/span> ip-tunnel mode gre ip-tunnel.remote 100.0.1.100 ip-tunnel.local 100.0.2.100 ipv4.method manual ipv4.addresses 172.16.0.2/30
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>ip route add 10.10.1.0/24 dev tun0
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div></description></item><item><title>Docs: IPsec and L2TP</title><link>https://desistdaydream.github.io/docs/4.%E6%95%B0%E6%8D%AE%E9%80%9A%E4%BF%A1/Protocol/Tunneling-Protocol/IPsec-and-L2TP/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/4.%E6%95%B0%E6%8D%AE%E9%80%9A%E4%BF%A1/Protocol/Tunneling-Protocol/IPsec-and-L2TP/</guid><description>
&lt;h1 id="概述">概述&lt;a class="td-heading-self-link" href="#%e6%a6%82%e8%bf%b0" aria-label="Heading self-link">&lt;/a>&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/IPsec">Wiki, IPsec&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Layer_2_Tunneling_Protocol">Wiki, L2TP&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>&lt;strong>Internet Protocol Security(因特网协议安全，简称 IPsec)&lt;/strong> 是一种安全网络协议套件，可对数据包进行身份验证和加密，以通过 Internet 协议网络在两台计算机之间提供安全的加密通信。它用于虚拟专用网络 (VPN)。&lt;/p>
&lt;p>&lt;strong>Layer 2 Tunneling Protocol(2层隧道协议，简称 L2TP)&lt;/strong> 是一种隧道协议，用于支持虚拟专用网络 (VPN) 或作为 ISP 提供服务的一部分。它仅对其自己的控制消息使用加密（“隐藏”）（使用可选的预共享秘密），并且其本身不提供任何内容加密或机密性。相反，它为第 2 层提供隧道（可以加密），并且隧道本身可以通过第 3 层加密协议（例如 IPsec）进行传递。&lt;/p>
&lt;p>&lt;a href="https://www.zhihu.com/question/279686051">知乎，既然IPsec有隧道模式，为什么还有L2TP+IPsec这样的组合？&lt;/a>&lt;/p>
&lt;p>您好，这是必应。根据我从网络上搜索到的信息，我给您简单介绍一下 ipsec 和 l2tp 的区别：&lt;/p>
&lt;ul>
&lt;li>ipsec 是一种安全协议，它可以在网络层对数据进行加密、认证和完整性保护，防止数据被窃听、篡改或伪造。&lt;/li>
&lt;li>l2tp 是一种隧道协议，它可以在数据链路层对数据进行封装和传输，实现不同网络之间的透明连接。&lt;/li>
&lt;li>ipsec 和 l2tp 可以单独使用，也可以结合使用。当单独使用时，ipsec可以提供数据的安全性，但不能跨越不同的网络类型；l2tp可以提供数据的透明性，但不能保证数据的安全性。&lt;/li>
&lt;li>当结合使用时，ipsec 和 l2tp 可以互补，实现数据的安全和透明传输。一般有两种组合方式：ipsec over l2tp 和 l2tp over ipsec。前者是先用ipsec加密数据，再用l2tp封装数据；后者是先用l2tp封装数据，再用 ipsec 加密数据。&lt;/li>
&lt;/ul>
&lt;h1 id="libreswan">Libreswan&lt;a class="td-heading-self-link" href="#libreswan" aria-label="Heading self-link">&lt;/a>&lt;/h1>
&lt;p>&lt;a href="https://github.com/libreswan/libreswan">https://github.com/libreswan/libreswan&lt;/a>&lt;/p>
&lt;p>&lt;a href="https://libreswan.org/">https://libreswan.org/&lt;/a>&lt;/p>
&lt;p>&lt;a href="https://github.com/hwdsl2/setup-ipsec-vpn/blob/master/README-zh.md">https://github.com/hwdsl2/setup-ipsec-vpn/blob/master/README-zh.md&lt;/a>&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://github.com/hwdsl2/docker-ipsec-vpn-server/blob/master/README-zh.md">https://github.com/hwdsl2/docker-ipsec-vpn-server/blob/master/README-zh.md&lt;/a>&lt;/li>
&lt;/ul>
&lt;h1 id="ikev2-客户端">IKEv2 客户端&lt;a class="td-heading-self-link" href="#ikev2-%e5%ae%a2%e6%88%b7%e7%ab%af" aria-label="Heading self-link">&lt;/a>&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://github.com/hwdsl2/setup-ipsec-vpn/blob/master/docs/ikev2-howto-zh.md">https://github.com/hwdsl2/setup-ipsec-vpn/blob/master/docs/ikev2-howto-zh.md&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>现代操作系统支持 IKEv2 协议标准。因特网密钥交换（英语：Internet Key Exchange，简称 IKE 或 IKEv2）是一种网络协议，归属于 IPsec 协议族之下，用以创建安全关联 (Security Association, SA)。与 IKE 版本 1 相比较，IKEv2 的 &lt;a href="https://en.wikipedia.org/wiki/Internet_Key_Exchange#Improvements_with_IKEv2">功能改进&lt;/a> 包括比如通过 MOBIKE 实现 Standard Mobility 支持，以及更高的可靠性。&lt;/p>
&lt;p>Libreswan 支持通过使用 RSA 签名算法的 X.509 Machine Certificates 来对 IKEv2 客户端进行身份验证。该方法无需 IPsec PSK, 用户名或密码。它可以用于 Windows, macOS, iOS, Android, Chrome OS, Linux 和 RouterOS。&lt;/p>
&lt;p>默认情况下，运行 VPN 安装脚本时会自动配置 IKEv2。如果你想了解有关配置 IKEv2 的更多信息，请参见 &lt;a href="https://github.com/hwdsl2/setup-ipsec-vpn/blob/master/docs/ikev2-howto-zh.md#%E4%BD%BF%E7%94%A8%E8%BE%85%E5%8A%A9%E8%84%9A%E6%9C%AC%E9%85%8D%E7%BD%AE-ikev2">使用辅助脚本配置 IKEv2&lt;/a>。Docker 用户请看 &lt;a href="https://github.com/hwdsl2/docker-ipsec-vpn-server/blob/master/README-zh.md#%E9%85%8D%E7%BD%AE%E5%B9%B6%E4%BD%BF%E7%94%A8-ikev2-vpn">配置并使用 IKEv2 VPN&lt;/a>。&lt;/p></description></item><item><title>Docs: Tailscale</title><link>https://desistdaydream.github.io/docs/4.%E6%95%B0%E6%8D%AE%E9%80%9A%E4%BF%A1/Protocol/Tunneling-Protocol/Tailscale/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/4.%E6%95%B0%E6%8D%AE%E9%80%9A%E4%BF%A1/Protocol/Tunneling-Protocol/Tailscale/</guid><description/></item><item><title>Docs: WireGuard</title><link>https://desistdaydream.github.io/docs/4.%E6%95%B0%E6%8D%AE%E9%80%9A%E4%BF%A1/Protocol/Tunneling-Protocol/WireGuard/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/4.%E6%95%B0%E6%8D%AE%E9%80%9A%E4%BF%A1/Protocol/Tunneling-Protocol/WireGuard/</guid><description/></item><item><title>Docs: TODO</title><link>https://desistdaydream.github.io/docs/4.%E6%95%B0%E6%8D%AE%E9%80%9A%E4%BF%A1/Protocol/Tunneling-Protocol/TODO/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/4.%E6%95%B0%E6%8D%AE%E9%80%9A%E4%BF%A1/Protocol/Tunneling-Protocol/TODO/</guid><description>
&lt;h1 id="概述">概述&lt;a class="td-heading-self-link" href="#%e6%a6%82%e8%bf%b0" aria-label="Heading self-link">&lt;/a>&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>&lt;a href="https://github.com/drunkdream/turbo-tunnel">https://github.com/drunkdream/turbo-tunnel&lt;/a>&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://github.com/turbo-tunnel/docs">https://github.com/turbo-tunnel/docs&lt;/a>&lt;/li>
&lt;/ul>
&lt;p>&lt;a href="https://github.com/turbo-tunnel/telnet-go">https://github.com/turbo-tunnel/telnet-go&lt;/a> # 这是一个用go实现的&lt;code>telnet&lt;/code>程序，你可以把它当作一个普通的 telnet 客户端来用（访问中文 telnet 服务端可能会有乱码）。当然，它的真正用途并不在此，而是用于当 SSH 服务端不支持端口转发时建立一个 TCP 隧道。实现原理是通过将 socket 双向通信转换为对&lt;code>stdin&lt;/code>和&lt;code>stdout&lt;/code>的读写，而&lt;code>stderr&lt;/code>则用于日志或错误信息的输出。&lt;/p></description></item><item><title>Docs: Vmess</title><link>https://desistdaydream.github.io/docs/4.%E6%95%B0%E6%8D%AE%E9%80%9A%E4%BF%A1/Protocol/Tunneling-Protocol/Vmess/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/4.%E6%95%B0%E6%8D%AE%E9%80%9A%E4%BF%A1/Protocol/Tunneling-Protocol/Vmess/</guid><description>
&lt;h1 id="概述">概述&lt;a class="td-heading-self-link" href="#%e6%a6%82%e8%bf%b0" aria-label="Heading self-link">&lt;/a>&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>date: &amp;ldquo;2024-12-09T14:22&amp;rdquo;&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>&lt;a href="https://www.chengxiaobai.com/essays/v2ray-trojan-xray.html">https://www.chengxiaobai.com/essays/v2ray-trojan-xray.html&lt;/a>&lt;/p>
&lt;p>Vmess 协议是 V2Ray 项目的主流加密协议&lt;/p>
&lt;h1 id="xray">Xray&lt;a class="td-heading-self-link" href="#xray" aria-label="Heading self-link">&lt;/a>&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>原文: &lt;a href="https://qoant.com/2021/04/vps-with-xray/">https://qoant.com/2021/04/vps-with-xray/&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>V2Fly 与 V2Ray&lt;/p>
&lt;p>V2Fly 是 V2Ray 的延伸，因为 V2Ray 仓库的作者失踪，所以建立了 V2Fly，本质上两者没区别。&lt;/p>
&lt;h2 id="xray-介绍">Xray 介绍&lt;a class="td-heading-self-link" href="#xray-%e4%bb%8b%e7%bb%8d" aria-label="Heading self-link">&lt;/a>&lt;/h2>
&lt;p>由于 Debian 包维护人员发现 &lt;a href="https://github.com/XTLS/Go">XTLS库&lt;/a> 的 LICENSE 不是 BSD 许可，提了一个 issue 希望作者 &lt;a href="https://github.com/rprx">@rprx&lt;/a> 能修改 LISENCE 许可方便打包，详见 &lt;a href="https://github.com/XTLS/Go/issues/9">https://github.com/XTLS/Go/issues/9&lt;/a>。由这个 issue 引发了广泛讨论，rprx 认为目前许可不是问题，也有不少人认为协议是立场的体现，各执一词。&lt;/p>
&lt;p>最终 V2ray(V2fly社区) 维护团队经过投票确认 XTLS 不符合 V2ray 的 MIT 协议，并在 &lt;a href="https://github.com/v2fly/v2ray-core/releases/tag/v4.33.0">V2ray-core 4.33.0版本&lt;/a>移除了 XTLS。rprx 和其拥护者行动起来，很快就创建了 &lt;a href="https://github.com/XTLS">Project X&lt;/a> 项目和其核心 &lt;a href="https://github.com/XTLS/Xray-core">Xray&lt;/a>（Xray取名来自XTLS和V2ray的结合），并以 XTLS 为核心协议陆续发布了 Xray-core 的多个版本，于是 Xray 诞生了。&lt;/p>
&lt;p>XTLS 和 Xray 离不开作者 &lt;a href="https://github.com/rprx">@rprx&lt;/a> 的辛勤付出，因此也简要介绍一下 &lt;a href="https://github.com/rprx">@rprx&lt;/a>：&lt;/p>
&lt;ol>
&lt;li>&lt;a href="https://github.com/rprx">@rprx&lt;/a> 是VLESS协议的设计者，在介绍VLESS协议时写下了“性能至上、可扩展性空前，目标是全场景终极协议”的宏壮愿景；&lt;/li>
&lt;li>&lt;a href="https://github.com/rprx">@rprx&lt;/a> 是XTLS的作者，在&lt;a href="https://github.com/XTLS/Go">XTLS库&lt;/a>中写下了“THE FUTURE”的霸气描述。将内外两条 TLS 连接结合，rprx 可能不是第一个有这想法的人，但却是第一个将其实现、并成熟应用到实际中的作者。从使用表现上看，XTLS 无愧于 rprx 对其的评价：“划时代的革命性概念与技术：XTLS”，以及社区给出的“黑科技”称谓；&lt;/li>
&lt;li>&lt;a href="https://github.com/rprx">@rprx&lt;/a> 是 Project X 和 Xray 项目的创始人。由于 LICENSE 理念之争，rprx 创建了对标 Project V 和 V2ray-core 的 Project X 和 Xray-core 项目，广受欢迎。&lt;/li>
&lt;/ol>
&lt;h2 id="xray-和-v2ray-的区别">Xray 和 V2ray 的区别&lt;a class="td-heading-self-link" href="#xray-%e5%92%8c-v2ray-%e7%9a%84%e5%8c%ba%e5%88%ab" aria-label="Heading self-link">&lt;/a>&lt;/h2>
&lt;p>在说明 Xray 和 V2ray 区别之前，先说一下三个相近但不同的概念：&lt;/p>
&lt;ul>
&lt;li>&lt;strong>V2ray：&lt;/strong> Project V是用于构建基础通信网络的工具合集，其核心工具称为V2Ray。V2ray主要负责网络协议和功能的实现，既可以单独运行，也可以和其它工具配合。V2ray官网是：&lt;a href="https://v2ray.com/">https://v2ray.com/&lt;/a>，Github项目主页是：&lt;a href="https://github.com/v2ray">https://github.com/v2ray&lt;/a>，TG讨论组是：&lt;a href="https://t.me/projectv2ray">@projectv2ray&lt;/a>；&lt;/li>
&lt;li>&lt;strong>V2fly：&lt;/strong> 出现一些科学上网作者被喝茶事件后，V2ray原开发者长期不上线，其他维护者没有完整权限，导致V2ray项目维护困难。因此社区在2019年组建了V2fly组织，继续维护V2ray，也是目前V2ray发展的主力。V2fly官网是：&lt;a href="https://www.v2fly.org/">https://www.v2fly.org&lt;/a>，Github项目主页是：&lt;a href="https://github.com/v2fly">https://github.com/v2fly&lt;/a>，TG通知频道：&lt;a href="https://t.me/v2fly">@v2fly&lt;/a>，TG交流群为：&lt;a href="https://t.me/v2fly_chat">@v2fly_chat&lt;/a>；&lt;/li>
&lt;li>&lt;strong>Xray：&lt;/strong> 因许可理念之争，VLESS 和 XTLS 的作者单独创建了 Xray 项目，目前是 V2ray 的超集，后续可能有不同的发展路线。Xray 文档官网：&lt;a href="https://xtls.github.io/">https://xtls.github.io/&lt;/a>，Github 项目主页：&lt;a href="https://github.com/XTLS">https://github.com/XTLS&lt;/a>，TG 交流群：&lt;a href="https://t.me/projectXray">@projectXray&lt;/a>。&lt;/li>
&lt;/ul>
&lt;p>从上面可以看到，先有 V2ray(Project V)，然后是 V2fly，最后才出来 Xray(Project X)。其中 V2fly 是 V2ray 的社区，可以认为两者是同一个组织。&lt;/p>
&lt;p>Xray 和 V2ray 区别如下：&lt;/p>
&lt;ol>
&lt;li>&lt;strong>Xray是V2ray的一个分支(Fork)&lt;/strong>。Xray 项目基于V2ray而来，其支持并且兼容V2ray的配置；&lt;/li>
&lt;li>&lt;strong>Xray是V2ray的超集&lt;/strong>。虽然最新版 V2ray 删除了XTLS，但仍保留VLESS协议。Xray提供完整的VLESS和XTLS支持，目前是V2ray的超集，但后续Xray可能会有会有自己的发展方向；&lt;/li>
&lt;li>&lt;strong>如果使用 XTLS，强烈推荐使用 Xray&lt;/strong>，不使用 XTLS 的情况下，使用 V2ray 和 Xray 均可。&lt;/li>
&lt;/ol>
&lt;p>简而言之，Xray 是 V2Ray 的项目分支，Xray 是 V2Ray 的超集，就跟 Trojan-Go 和 Trojan-GFW 的关系类似，而且 Xray 性能更好、速度更快，更新迭代也更频繁。由于自 V2ray-core 4.33.0 版本起，删除了 XTLS 黑科技，但仍然支持 VLESS，所以是否原生支持 XTLS 是 Xray 和 V2Ray 最大的区别之一。&lt;/p>
&lt;h1 id="概述-1">概述&lt;a class="td-heading-self-link" href="#%e6%a6%82%e8%bf%b0-1" aria-label="Heading self-link">&lt;/a>&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://github.com/v2fly/v2ray-core">GItHub 项目，v2fly/v2ray-core&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://github.com/Loyalsoldier/v2ray-rules-dat">路由规则&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>V2Ray 是 Project V 下的一个工具。Project V 是一个包含一系列构建特定网络环境工具的项目，而 V2Ray 属于最核心的一个。 官方中介绍 &lt;code>Project V 提供了单一的内核和多种界面操作方式。内核（V2Ray）用于实际的网络交互、路由等针对网络数据的处理，而外围的用户界面程序提供了方便直接的操作流程。&lt;/code> 不过从时间上来说，先有 V2Ray 才有 Project V。 如果还是不理解，那么简单地说，V2Ray 是一个与 Shadowsocks 类似的代理软件，可以用来科学上网（翻墙）学习国外先进科学技术。&lt;/p></description></item><item><title>Docs: 为什么集群需要 Overlay 网络</title><link>https://desistdaydream.github.io/docs/4.%E6%95%B0%E6%8D%AE%E9%80%9A%E4%BF%A1/Protocol/Tunneling-Protocol/%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9B%86%E7%BE%A4%E9%9C%80%E8%A6%81-Overlay-%E7%BD%91%E7%BB%9C/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/4.%E6%95%B0%E6%8D%AE%E9%80%9A%E4%BF%A1/Protocol/Tunneling-Protocol/%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9B%86%E7%BE%A4%E9%9C%80%E8%A6%81-Overlay-%E7%BD%91%E7%BB%9C/</guid><description>
&lt;p>原文链接：&lt;a href="https://mp.weixin.qq.com/s/a1omUj17yNVUuymh6DYpRQ">https://mp.weixin.qq.com/s/a1omUj17yNVUuymh6DYpRQ&lt;/a>&lt;/p>
&lt;p>对计算机网络或者 Kubernetes 网络稍有了解的工程师都应该听说过延展网络（Overlay Network），Overlay 网络其实并不是一门新技术，它是指构建在另一个网络上的计算机网络[^1]，这是一种网络虚拟化技术的形式，近年来云计算虚拟化技术的演进促进了网络虚拟化技术的应用。&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/lcrm4c/1624243869971-71eafc04-3ced-425e-9226-32b69b133817.webp" alt="">&lt;/p>
&lt;p>overlay-network&lt;/p>
&lt;p>&lt;strong>图 1 - 延展网络&lt;/strong>&lt;/p>
&lt;p>因为 Overlay 网络是建立在另一个计算机网络之上的虚拟网络，所以它不能独立出现，Overlay 底层依赖的网络就是 Underlay 网络，这两个概念也经常成对出现。&lt;/p>
&lt;p>Underlay 网络是专门用来承载用户 IP 流量的基础架构层，它与 Overlay 网络之间的关系有点类似物理机和虚拟机。Underlay 网络和物理机都是真正存在的实体，它们分别对应着真实存在的网络设备和计算设备，而 Overlay 网络和虚拟机都是依托在下层实体使用软件虚拟出来的层级。&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/lcrm4c/1624243869927-88673791-c226-48bf-9ee6-32410fa3988f.webp" alt="">&lt;/p>
&lt;p>network-and-compute&lt;/p>
&lt;p>&lt;strong>图 2 - 网络与计算&lt;/strong>&lt;/p>
&lt;p>在分析 Overlay 网络的作用之前，我们需要对它的常见实现有大概的了解，在实践中我们一般会使用虚拟局域网扩展技术（Virtual Extensible LAN，VxLAN）组建 Overlay 网络。在下图中，两个物理机可以通过三层的 IP 网络互相访问：&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/lcrm4c/1624243869969-8cc90217-72b1-4195-bc6c-2e176ebb3182.webp" alt="">&lt;/p>
&lt;p>VxLAN-overlay-network&lt;/p>
&lt;p>&lt;strong>图 3 - VxLAN 组成的 Overlay 网络&lt;/strong>&lt;/p>
&lt;blockquote>
&lt;p>VxLAN 使用虚拟隧道端点（Virtual Tunnel End Point、VTEP）设备对服务器发出和收到的数据包进行二次封装和解封。&lt;/p>
&lt;/blockquote>
&lt;p>上图中两个 VTEP 会相互连接并获得网络中的 MAC 地址、IP 地址等信息，例如，服务器 1 中的 VTEP 需要知道想要访问绿色网络中的 10.0.0.2 虚拟机需要先访问 IP 地址为 204.79.197.200 的服务器 2。这些配置可以被网络管理员手动配置、自动学习、也可以通过上层的管理器设置。当绿色的 10.0.0.1 虚拟机想要向绿色的 10.0.0.2 发送数据时，会经过以下几个步骤：&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/lcrm4c/1624243870013-9b420580-675c-42e9-8609-260ab4f0604f.webp" alt="">&lt;/p>
&lt;p>overlay-network-packet&lt;/p>
&lt;p>&lt;strong>图 4 - Overlay 网络中的数据包&lt;/strong>&lt;/p>
&lt;ol>
&lt;li>绿色的 10.0.0.1 会将 IP 数据包发送给 VTEP；&lt;/li>
&lt;li>服务器 1 的 VTEP 收到 10.0.0.1 发送的数据包后；
&lt;ol>
&lt;li>从收到的 IP 数据包中获取目的虚拟机的 MAC 地址；&lt;/li>
&lt;li>在本地的转发表中查找该 MAC 地址所在服务器的 IP 地址，即 204.79.197.200；&lt;/li>
&lt;li>将绿色虚拟机所在的虚拟网络标识符（VxLAN Network Identifier、VNI）以及原始的 IP 数据包作为负载，构建新的 UDP 数据包；&lt;/li>
&lt;li>将新的 UDP 数据包发送到网络中；&lt;/li>
&lt;/ol>
&lt;/li>
&lt;li>服务器 2 的 VTEP 收到 UDP 数据包后；
&lt;ol>
&lt;li>去掉 UDP 数据包中的协议头；&lt;/li>
&lt;li>查看数据包中 VNI；&lt;/li>
&lt;li>将 IP 数据包转发给目标的绿色服务器 10.0.0.2；&lt;/li>
&lt;/ol>
&lt;/li>
&lt;li>绿色的 10.0.0.2 会收到绿色服务器 10.0.0.1 发送的数据包；&lt;/li>
&lt;/ol>
&lt;p>在数据包的传输过程中，通信的双方都不知道底层网络做的这些转换，它们认为两者可以通过二层的网络互相访问，但是实际上经过了三层 IP 网络的中转，通过 VTEP 之间建立的隧道实现了连通。除了 VxLAN 之外，Overlay 网络还有很多实现方案，不过也都大同小异。Overlay 网络虽然能够利用底层网络在多数据中心之间组成二层网络，但是它的封包和拆包过程也会带来额外开销，所以为什么我们的集群需要 Overlay 网络呢，本文将介绍 Overlay 网络解决的三个问题：&lt;/p>
&lt;ul>
&lt;li>云计算中集群内的、跨集群的或者数据中心间的虚拟机和实例的迁移比较常见；&lt;/li>
&lt;li>单个集群中的虚拟机规模可能非常大，大量的 MAC 地址和 ARP 请求会为网络设备带来巨大的压力；&lt;/li>
&lt;li>传统的网络隔离技术 VLAN 只能建立 4096 个虚拟网络，公有云以及大规模的虚拟化集群需要更多的虚拟网络才能满足网络隔离的需求；&lt;/li>
&lt;/ul>
&lt;h2 id="虚拟机迁移">虚拟机迁移&lt;a class="td-heading-self-link" href="#%e8%99%9a%e6%8b%9f%e6%9c%ba%e8%bf%81%e7%a7%bb" aria-label="Heading self-link">&lt;/a>&lt;/h2>
&lt;p>Kuberentes 目前已经是容器编排领域的事实标准了，虽然很多传统行业仍然在使用物理机部署服务，但是越来越多的计算任务在未来都会跑在虚拟机上。虚拟机迁移是将虚拟机从一个物理硬件设备移到另一个设备的过程，因为日常的更新维护，集群中的大规模虚拟机迁移是比较常见的事情，上千台物理机组成的大集群使得集群内的资源调度变得更加容易，我们可以通过虚拟机迁移来提高资源的利用率、容忍虚拟机的错误并提高节点的可移植性[^3]。
当虚拟机所在的宿主机因为维护或者其他原因宕机时，当前实例就需要迁移到其他的宿主机上，为了保证业务不中断，我们需要保证迁移过程中的 IP 地址不变，因为 Overlay 是在网络层实现二层网络，所以多个物理机之间只要网络层可达就能组建虚拟的局域网，虚拟机或者容器迁移后仍然处于同一个二层网络，也就不需要改变 IP 地址。
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/lcrm4c/1624243869941-afef4a32-0ad9-40b0-9bd1-39b6d32cb600.png" alt="">virtual-machine-migration
&lt;strong>图 5 - 跨数据中心的虚拟机迁移&lt;/strong>
如上图所示，迁移后的虚拟机与其他的虚拟机虽然位于不同的数据中心，但是由于上述两个数据中心之间可以通过 IP 协议连通，所以迁移后的虚拟机仍然可以通过 Overlay 网络与原集群的虚拟机组成二层网络，集群内部的主机也完全不清楚、不关心底层的网络架构，它们只知道不同虚拟机之间是可以连通的。&lt;/p>
&lt;h2 id="虚拟机规模">虚拟机规模&lt;a class="td-heading-self-link" href="#%e8%99%9a%e6%8b%9f%e6%9c%ba%e8%a7%84%e6%a8%a1" aria-label="Heading self-link">&lt;/a>&lt;/h2>
&lt;p>我们在 &lt;a href="http://mp.weixin.qq.com/s?__biz=MzU5NTAzNjc3Mg==&amp;amp;mid=2247484307&amp;amp;idx=1&amp;amp;sn=0a60a1ea71b4b40f95c8fe6af7e46134&amp;amp;chksm=fe795c98c90ed58e83d17597525f82e4b44c13fa08000c27833e8ef107d0a2836161b0582389&amp;amp;scene=21#wechat_redirect">为什么 Mac 地址不需要全球唯一&lt;/a> 曾经介绍过二层网络的通信需要依赖 MAC 地址，一个传统的二层网络需要网络设备中存储从 IP 地址到 MAC 地址的转发表。
目前 Kuberentes 官方支持的最大集群为 5000 节点，如果这 5000 个节点中的每个节点都仅仅包含一个容器，这对于内部的网络设备其实没有太大的压力，但是在实际情况下 5000 节点的集群中都包含几万甚至几十万个容器，当某个容器向集群中发送 ARP 请求，集群中的全部容器都会收到 ARP 请求，这时会带来极高的网络负载。
在使用 VxLAN 搭建的 Overlay 网络中，网络会将虚拟机发送的数据重新封装成 IP 数据包，这样网络只需要知道不同 VTEP 的 MAC 地址，由此可以将 MAC 地址表项中的几十万条数据降低到几千条，ARP 请求也只会在集群中的 VTEP 之间扩散，远端的 VTEP 将数据拆包后也仅会在本地广播，不会影响其他的 VTEP，虽然这对于集群中的网络设备仍然有较高的要求，但是已经极大地降低了核心网络设备的压力。
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/lcrm4c/1624243870178-125ad3a5-532e-47ba-9379-c42abd2f47f0.webp" alt="">overlay-network-and-arp
&lt;strong>图 6 - Overlay 网络中的 ARP 请求&lt;/strong>
Overlay 网络其实与软件定义网络（Software-defined networking、SDN）[^4]密切相关，而 SDN 引入了数据平面和控制平面，其中数据平面负责转发数据，而控制平面负责计算并分发转发表。VxLAN 的 RFC7348 中只定义了数据平面的内容，由该技术组成的网络可以通过传统的自学习模式学习网络中的 MAC 与 ARP 表项[^5]，但是在大规模的集群中，我们仍然需要引入控制平面分发路由转发表。&lt;/p>
&lt;h2 id="网络隔离">网络隔离&lt;a class="td-heading-self-link" href="#%e7%bd%91%e7%bb%9c%e9%9a%94%e7%a6%bb" aria-label="Heading self-link">&lt;/a>&lt;/h2>
&lt;p>大规模的数据中心往往都会对外提供云计算服务，同一个物理集群可能会被拆分成多个小块分配给不同的租户（Tenant），因为二层网络的数据帧可能会进行广播，所以出于安全的考虑这些不同的租户之间需要进行网络隔离，避免租户之间的流量互相影响甚至恶意攻击。传统的网络隔离会使用虚拟局域网技术（Virtual LAN、VLAN），VLAN 会使用 12 比特表示虚拟网络 ID，虚拟网络的上限是 4096 个。
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/lcrm4c/1624243869983-c3c0d932-4687-4196-bb2a-f4a195875050.webp" alt="">vlan-header
&lt;strong>图 7 - VLAN 协议头&lt;/strong>
4096 个虚拟网络对于大规模的数据中心来说远远不够，VxLAN 会使用 24 比特的 VNI 表示虚拟网络个数，总共可以表示 16,777,216 个虚拟网络，这也就能满足数据中心多租户网络隔离的需求了。
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/lcrm4c/1624243869900-0608465f-d0b1-438d-89a9-e1fc96a43b2f.webp" alt="">VxLAN-packet
&lt;strong>图 8 - VxLAN 协议头&lt;/strong>
更多的虚拟网络其实是 VxLAN 顺手带来的好处，它不应该成为使用 VxLAN 的决定性因素。VLAN 协议的扩展协议 IEEE 802.1ad 允许我们在以太网帧中加入两个 802.1Q 的协议头，两个 VLAN ID 组成的 24 比特也可以表示 16,777,216 个虚拟网络[^6]，所以想要解决网络隔离不是使用 VxLAN 或者 Overlay 网络的充分条件。&lt;/p>
&lt;h2 id="总结">总结&lt;a class="td-heading-self-link" href="#%e6%80%bb%e7%bb%93" aria-label="Heading self-link">&lt;/a>&lt;/h2>
&lt;p>今天的数据中心包含多个集群以及海量的物理机，Overlay 网络是虚拟机和底层网络设备之间的中间层，通过 Overlay 网络这一个中间层，我们可以解决虚拟机的迁移问题、降低二层核心网络设备的压力并提供更大规模的虚拟网络数量：&lt;/p>
&lt;ul>
&lt;li>在使用 VxLAN 构成二层网络中，虚拟机在不同集群、不同可用区和不同数据中心迁移后，仍然可以保证二层网络的可达性，这能够帮助我们保证线上业务的可用性、提升集群的资源利用率、容忍虚拟机和节点的故障；&lt;/li>
&lt;li>集群中虚拟机的规模可能是物理机是几十倍，与物理机构成的传统集群相比，虚拟机构成的集群包含的 MAC 地址数量可能多一两个数量级，网络设备很难承担如此大规模的二层网络请求，Overlay 网络通过 IP 封包和控制平面可以减少集群中的 MAC 地址表项和 ARP 请求；&lt;/li>
&lt;li>VxLAN 的协议头使用 24 位的 VNI 表示虚拟网络，总共可以表示 1600 万的虚拟网络，我们可以为不同的虚拟网络单独分配网络带宽，满足多租户的网络隔离需求；&lt;/li>
&lt;/ul>
&lt;p>需要注意的是，Overlay 网络只是一种在物理网络上的虚拟网络，使用该技术并不能直接解决集群中的规模性等问题，而 VxLAN 也不是组建 Overlay 网络的唯一方法，在不同场景中我们可以考虑使用不同的技术，例如：NVGRE、GRE 等。到最后，我们还是来看一些比较开放的相关问题，有兴趣的读者可以仔细思考一下下面的问题：&lt;/p>
&lt;ul>
&lt;li>VxLAN 将原始数据包封装成 UDP 在网络上分发，那么 NVGRE 和 STT 分别使用哪些方法传输数据呢？&lt;/li>
&lt;li>在 Kubernetes 中部署 Overlay 网络应该使用什么技术或者软件？&lt;/li>
&lt;/ul>
&lt;blockquote>
&lt;p>如果对文章中的内容有疑问或者想要了解更多软件工程上一些设计决策背后的原因，可以在博客下面留言，作者会及时回复本文相关的疑问并选择其中合适的主题作为后续的内容。&lt;/p>
&lt;/blockquote>
&lt;h2 id="推荐阅读">推荐阅读&lt;a class="td-heading-self-link" href="#%e6%8e%a8%e8%8d%90%e9%98%85%e8%af%bb" aria-label="Heading self-link">&lt;/a>&lt;/h2>
&lt;ul>
&lt;li>&lt;a href="http://mp.weixin.qq.com/s?__biz=MzU5NTAzNjc3Mg==&amp;amp;mid=2247484307&amp;amp;idx=1&amp;amp;sn=0a60a1ea71b4b40f95c8fe6af7e46134&amp;amp;chksm=fe795c98c90ed58e83d17597525f82e4b44c13fa08000c27833e8ef107d0a2836161b0582389&amp;amp;scene=21#wechat_redirect">MAC 地址为什么不需要全球唯一&lt;/a>&lt;/li>
&lt;li>&lt;a href="http://mp.weixin.qq.com/s?__biz=MzU5NTAzNjc3Mg==&amp;amp;mid=2247484317&amp;amp;idx=1&amp;amp;sn=c9d18d6a01b103f1bf4e825f94f90105&amp;amp;chksm=fe795c96c90ed58095f67b8dd21caa8ec4da4c6e6376623ae8da47b43299b1be6cbb88240d4f&amp;amp;scene=21#wechat_redirect">为什么 IPv6 难以取代 IPv4&lt;/a>&lt;/li>
&lt;/ul></description></item><item><title>Docs: 支持各种隧道协议的客户端</title><link>https://desistdaydream.github.io/docs/4.%E6%95%B0%E6%8D%AE%E9%80%9A%E4%BF%A1/Protocol/Tunneling-Protocol/%E6%94%AF%E6%8C%81%E5%90%84%E7%A7%8D%E9%9A%A7%E9%81%93%E5%8D%8F%E8%AE%AE%E7%9A%84%E5%AE%A2%E6%88%B7%E7%AB%AF/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/4.%E6%95%B0%E6%8D%AE%E9%80%9A%E4%BF%A1/Protocol/Tunneling-Protocol/%E6%94%AF%E6%8C%81%E5%90%84%E7%A7%8D%E9%9A%A7%E9%81%93%E5%8D%8F%E8%AE%AE%E7%9A%84%E5%AE%A2%E6%88%B7%E7%AB%AF/</guid><description>
&lt;h1 id="clash">Clash&lt;a class="td-heading-self-link" href="#clash" aria-label="Heading self-link">&lt;/a>&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://github.com/Dreamacro/clash">GitHub 项目，Dreamacro/clash&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://github.com/Dreamacro/clash/wiki">GitHub 项目 Wiki&lt;/a>（官方文档）&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;blockquote>
&lt;p>[!Attention] 据说作者已被抓，2023-11-2 仓库没了&lt;/p>
&lt;p>Clash Core 删库跑路后的选择&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://github.com/MetaCubeX/Clash.Meta">https://github.com/MetaCubeX/Clash.Meta&lt;/a> # Clash.Meta&lt;/li>
&lt;li>&lt;a href="https://github.com/MetaCubeX/mihomo/tree/Meta">https://github.com/MetaCubeX/mihomo/tree/Meta&lt;/a> # Clash.Meta&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>Clash 是一个 Go 语言开发的代理客户端，支持多种服务端协议，比如 Vmess、Shadowsocks、Trojan、Snell 等。&lt;/p>
&lt;p>Clash 特性：&lt;/p>
&lt;ul>
&lt;li>支持身份验证的本地 HTTP/HTTPS/SOCKS 服务器&lt;/li>
&lt;li>VMess、Shadowsocks、Trojan、Snell 协议支持远程连接&lt;/li>
&lt;li>内置 DNS 服务器，旨在最大限度地减少 DNS 污染攻击的影响，支持 DoH/DoT 上游和假 IP。&lt;/li>
&lt;li>基于域、GEOIP、IPCIDR 或进程的规则将数据包转发到不同的节点&lt;/li>
&lt;li>远程组允许用户实施强大的规则。支持自动回退、负载平衡或基于延迟的自动选择节点&lt;/li>
&lt;li>远程提供者，允许用户远程获取节点列表，而不是在配置中硬编码&lt;/li>
&lt;li>Netfilter TCP 重定向。使用 .在您的 Internet 网关上部署 Clash iptables。&lt;/li>
&lt;li>全面的 HTTP RESTful API 控制器&lt;/li>
&lt;/ul>
&lt;h2 id="规则">规则&lt;a class="td-heading-self-link" href="#%e8%a7%84%e5%88%99" aria-label="Heading self-link">&lt;/a>&lt;/h2>
&lt;ul>
&lt;li>DOMAIN-SUFFIX：域名后缀匹配&lt;/li>
&lt;li>DOMAIN：域名匹配&lt;/li>
&lt;li>DOMAIN-KEYWORD：域名关键字匹配&lt;/li>
&lt;li>IP-CIDR：IP 段匹配&lt;/li>
&lt;li>SRC-IP-CIDR：源 IP 段匹配&lt;/li>
&lt;li>GEOIP：GEOIP 数据库（国家代码）匹配&lt;/li>
&lt;li>DST-PORT：目标端口匹配&lt;/li>
&lt;li>SRC-PORT：源端口匹配&lt;/li>
&lt;li>PROCESS-NAME：源进程名匹配&lt;/li>
&lt;li>RULE-SET：根据 &lt;a href="#O5lZf">Rule Provider&lt;/a> 匹配&lt;/li>
&lt;li>MATCH：全匹配&lt;/li>
&lt;/ul>
&lt;h3 id="rule-providers规则提供器">Rule Providers(规则提供器)&lt;a class="td-heading-self-link" href="#rule-providers%e8%a7%84%e5%88%99%e6%8f%90%e4%be%9b%e5%99%a8" aria-label="Heading self-link">&lt;/a>&lt;/h3>
&lt;p>&lt;a href="https://github.com/Loyalsoldier/clash-rules">GitHub 项目，Loyalsoldier/clash-rules&lt;/a> 根据 &lt;a href="https://github.com/Loyalsoldier/v2ray-rules-dat">Loyalsoldier/v2ray-rules-dat&lt;/a> 项目生成了适用于 Clash 的规则集合。有点类似于 iptables 中的 ipset&lt;/p>
&lt;h2 id="clash-关联文件与配置">Clash 关联文件与配置&lt;a class="td-heading-self-link" href="#clash-%e5%85%b3%e8%81%94%e6%96%87%e4%bb%b6%e4%b8%8e%e9%85%8d%e7%bd%ae" aria-label="Heading self-link">&lt;/a>&lt;/h2>
&lt;p>&lt;strong>~/.config/clash/&lt;/strong> #&lt;/p>
&lt;ul>
&lt;li>&lt;strong>./providers/&lt;/strong> # rule-providers 规则保存路径&lt;/li>
&lt;/ul>
&lt;h2 id="clash-客户端">Clash 客户端&lt;a class="td-heading-self-link" href="#clash-%e5%ae%a2%e6%88%b7%e7%ab%af" aria-label="Heading self-link">&lt;/a>&lt;/h2>
&lt;ul>
&lt;li>&lt;a href="https://github.com/Kr328/ClashForAndroid">GitHub 项目，Kr328/ClashForAndroid&lt;/a> # 安卓客户端
&lt;ul>
&lt;li>已删库&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>ClashN # &lt;a href="https://github.com/2dust/clashN">https://github.com/2dust/clashN&lt;/a>
&lt;ul>
&lt;li>已合并到 v2rayN 项目&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>ClashX：Clash 的 Mac 图形客户端，&lt;a href="https://github.com/yichengchen/clashX">GitHub 项目，yichengchen/clashX&lt;/a>
&lt;ul>
&lt;li>已删库&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>ClashForAndroid：Clash 的 Android 图形客户端，&lt;a href="https://github.com/Kr328/ClashForAndroid">GitHub 项目，Kr328/ClashForAndroid&lt;/a>
&lt;ul>
&lt;li>已删库&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Clash for Windows：Clash 的 Windows/macOS 图形客户端，&lt;a href="https://github.com/Fndroid/clash_for_windows_pkg">GitHub 项目，Fndroid/clash_for_windows_pkg&lt;/a>。详见&lt;a href="#Clash%20for%20Windows">下文&lt;/a>
&lt;ul>
&lt;li>已删库&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>clash-verge &lt;a href="https://github.com/zzzgydi/clash-verge/tree/main">https://github.com/zzzgydi/clash-verge/tree/main&lt;/a> 基于 &lt;a href="https://github.com/MetaCubeX/Clash.Meta">Clash.Meta&lt;/a>。已归档跑路&lt;/li>
&lt;/ul>
&lt;hr>
&lt;p>&lt;a href="https://github.com/clash-verge-rev/clash-verge-rev">https://github.com/clash-verge-rev/clash-verge-rev&lt;/a> clash-verge 的延续！基于 &lt;a href="https://github.com/MetaCubeX/mihomo/tree/Meta">Clash Meta&lt;/a>&lt;/p>
&lt;p>这些 GUI 客户端中，通常都内嵌了 Clash 二进制文件&lt;/p>
&lt;h1 id="clash-for-windows">Clash for Windows&lt;a class="td-heading-self-link" href="#clash-for-windows" aria-label="Heading self-link">&lt;/a>&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://github.com/Fndroid/clash_for_windows_pkg">GitHub 项目， Fndroid/clash_for_windows_pkg&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://docs.cfw.lbyczf.com/">https://docs.cfw.lbyczf.com/&lt;/a> 这是谁从 GitHub 中生成的？&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>Clash for Windows 通常简称 CFW。&lt;/p>
&lt;h2 id="配置文件预处理">配置文件预处理&lt;a class="td-heading-self-link" href="#%e9%85%8d%e7%bd%ae%e6%96%87%e4%bb%b6%e9%a2%84%e5%a4%84%e7%90%86" aria-label="Heading self-link">&lt;/a>&lt;/h2>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://docs.cfw.lbyczf.com/contents/parser.html">官方文档，配置文件预处理&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>当配置文件更新时，通过配置文件预处理功能可添加我们个人自定义的一些配置。常用来为订阅添加配置。&lt;/p>
&lt;p>因为订阅中会下载默认配置，每次手动修改不够方便，所以配置文件预处理就是一种类似于额外配置的功能&lt;/p>
&lt;p>在 &lt;code>Settings-Profiles-Parsers&lt;/code> 处编辑文件即可进行配置，简单示例：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-yaml" data-lang="yaml">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#204a87;font-weight:bold">parsers&lt;/span>&lt;span style="color:#000;font-weight:bold">:&lt;/span>&lt;span style="color:#f8f8f8;text-decoration:underline">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f8f8f8;text-decoration:underline"> &lt;/span>- &lt;span style="color:#204a87;font-weight:bold">url&lt;/span>&lt;span style="color:#000;font-weight:bold">:&lt;/span>&lt;span style="color:#f8f8f8;text-decoration:underline"> &lt;/span>&lt;span style="color:#4e9a06">&amp;#34;https://订阅地址&amp;#34;&lt;/span>&lt;span style="color:#f8f8f8;text-decoration:underline">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f8f8f8;text-decoration:underline"> &lt;/span>&lt;span style="color:#204a87;font-weight:bold">yaml&lt;/span>&lt;span style="color:#000;font-weight:bold">:&lt;/span>&lt;span style="color:#f8f8f8;text-decoration:underline"> &lt;/span>{}&lt;span style="color:#f8f8f8;text-decoration:underline">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f8f8f8;text-decoration:underline"> &lt;/span>&lt;span style="color:#204a87;font-weight:bold">code&lt;/span>&lt;span style="color:#000;font-weight:bold">:&lt;/span>&lt;span style="color:#f8f8f8;text-decoration:underline"> &lt;/span>&lt;span style="color:#000;font-weight:bold">|&lt;/span>&lt;span style="color:#8f5902;font-style:italic">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8f5902;font-style:italic"> &amp;#34;STRING&amp;#34;&lt;/span>&lt;span style="color:#f8f8f8;text-decoration:underline">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f8f8f8;text-decoration:underline"> &lt;/span>&lt;span style="color:#204a87;font-weight:bold">file&lt;/span>&lt;span style="color:#000;font-weight:bold">:&lt;/span>&lt;span style="color:#f8f8f8;text-decoration:underline"> &lt;/span>&lt;span style="color:#4e9a06">&amp;#34;/PATH/TO/JS_FILE&amp;#34;&lt;/span>&lt;span style="color:#f8f8f8;text-decoration:underline">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>当配置文件触发刷新时，Clash for Windows 会读取 &lt;code>parsers.yaml&lt;/code> 字段中定义的内容，将对应的值插入或合并到通过 &lt;code>parsers.url&lt;/code> 字段指定的订阅的配置文件&lt;/p>
&lt;ul>
&lt;li>&lt;strong>url(STRING)&lt;/strong> # 指定需要预处理的订阅地址&lt;/li>
&lt;li>&lt;strong>yaml(OBJECT)&lt;/strong> # 通过 YAML 格式进行预处理。即 yaml 字段下直接定义规则。&lt;/li>
&lt;li>&lt;strong>code(STRING)&lt;/strong> # 通过 JavaScript 代码进行预处理。即 code 字段下的 js 代码直接定义规则&lt;/li>
&lt;li>&lt;strong>file(STRING)&lt;/strong> # 代替 code 中的代码内容，让 Clash for windows 读取指定文件中的 JS 代码。&lt;/li>
&lt;/ul>
&lt;p>yaml、code、file 是三种生成规则的方式，可以任选其一即可。&lt;/p>
&lt;h3 id="yaml">YAML&lt;a class="td-heading-self-link" href="#yaml" aria-label="Heading self-link">&lt;/a>&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-yaml" data-lang="yaml">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#204a87;font-weight:bold">parsers&lt;/span>&lt;span style="color:#000;font-weight:bold">:&lt;/span>&lt;span style="color:#f8f8f8;text-decoration:underline">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f8f8f8;text-decoration:underline"> &lt;/span>- &lt;span style="color:#204a87;font-weight:bold">url&lt;/span>&lt;span style="color:#000;font-weight:bold">:&lt;/span>&lt;span style="color:#f8f8f8;text-decoration:underline"> &lt;/span>&lt;span style="color:#4e9a06">&amp;#34;https://订阅地址&amp;#34;&lt;/span>&lt;span style="color:#f8f8f8;text-decoration:underline">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f8f8f8;text-decoration:underline"> &lt;/span>&lt;span style="color:#204a87;font-weight:bold">yaml&lt;/span>&lt;span style="color:#000;font-weight:bold">:&lt;/span>&lt;span style="color:#f8f8f8;text-decoration:underline"> &lt;/span>{}&lt;span style="color:#f8f8f8;text-decoration:underline">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f8f8f8;text-decoration:underline"> &lt;/span>&lt;span style="color:#204a87;font-weight:bold">append-rules&lt;/span>&lt;span style="color:#000;font-weight:bold">:&lt;/span>&lt;span style="color:#f8f8f8;text-decoration:underline"> &lt;/span>&lt;span style="color:#8f5902;font-style:italic"># 在 rules 字段最后添加规则&lt;/span>&lt;span style="color:#f8f8f8;text-decoration:underline">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f8f8f8;text-decoration:underline"> &lt;/span>- &lt;span style="color:#000">PROCESS-NAME,chrome.exe,Ghelper&lt;/span>&lt;span style="color:#f8f8f8;text-decoration:underline">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f8f8f8;text-decoration:underline"> &lt;/span>- &lt;span style="color:#000">MATCH,DIRECT&lt;/span>&lt;span style="color:#f8f8f8;text-decoration:underline">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f8f8f8;text-decoration:underline"> &lt;/span>&lt;span style="color:#204a87;font-weight:bold">commands&lt;/span>&lt;span style="color:#000;font-weight:bold">:&lt;/span>&lt;span style="color:#f8f8f8;text-decoration:underline">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f8f8f8;text-decoration:underline"> &lt;/span>- &lt;span style="color:#000">rules.-3-&lt;/span>&lt;span style="color:#f8f8f8;text-decoration:underline"> &lt;/span>&lt;span style="color:#8f5902;font-style:italic"># 删除配置文件中 rules 字段中倒数第三个元素&lt;/span>&lt;span style="color:#f8f8f8;text-decoration:underline">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>yaml 字段下可用的字段有：&lt;/p>
&lt;ul>
&lt;li>&lt;strong>append-rules([]STRING)&lt;/strong> # 数组合并至原配置 rules 数组后&lt;/li>
&lt;li>&lt;strong>prepend-rules([]STRING)&lt;/strong> # 数组合并至原配置 rules 数组前&lt;/li>
&lt;li>&lt;strong>append-proxies 数组&lt;/strong> # 数组合并至原配置 proxies 数组后&lt;/li>
&lt;li>&lt;strong>prepend-proxies 数组&lt;/strong> # 数组合并至原配置 proxies 数组前&lt;/li>
&lt;li>&lt;strong>append-proxy-groups 数组&lt;/strong> # 数组合并至原配置 proxy-groups 数组后&lt;/li>
&lt;li>&lt;strong>prepend-proxy-groups 数组&lt;/strong> # 数组合并至原配置 proxy-groups 数组前&lt;/li>
&lt;li>&lt;strong>mix-proxy-providers 对象&lt;/strong> # 对象合并至原配置 proxy-providers 中&lt;/li>
&lt;li>&lt;strong>mix-rule-providers 对象&lt;/strong> # 对象合并至原配置 rule-providers 中&lt;/li>
&lt;li>&lt;strong>mix-object 对象&lt;/strong> # 对象合并至原配置最外层中&lt;/li>
&lt;li>&lt;strong>commands([]STRING)&lt;/strong> # 在上面操作完成后执行简单命令操作配置文件&lt;/li>
&lt;/ul>
&lt;h3 id="javascript">JavaScript&lt;a class="td-heading-self-link" href="#javascript" aria-label="Heading self-link">&lt;/a>&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-yaml" data-lang="yaml">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#204a87;font-weight:bold">parsers&lt;/span>&lt;span style="color:#000;font-weight:bold">:&lt;/span>&lt;span style="color:#f8f8f8;text-decoration:underline">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f8f8f8;text-decoration:underline"> &lt;/span>- &lt;span style="color:#204a87;font-weight:bold">url&lt;/span>&lt;span style="color:#000;font-weight:bold">:&lt;/span>&lt;span style="color:#f8f8f8;text-decoration:underline"> &lt;/span>&lt;span style="color:#000">https://example.com/profile.yaml&lt;/span>&lt;span style="color:#f8f8f8;text-decoration:underline">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f8f8f8;text-decoration:underline"> &lt;/span>&lt;span style="color:#204a87;font-weight:bold">code&lt;/span>&lt;span style="color:#000;font-weight:bold">:&lt;/span>&lt;span style="color:#f8f8f8;text-decoration:underline"> &lt;/span>&lt;span style="color:#000;font-weight:bold">|&lt;/span>&lt;span style="color:#8f5902;font-style:italic">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8f5902;font-style:italic"> module.exports.parse = async (raw, { axios, yaml, notify, console }, { name, url, interval, selected }) =&amp;gt; {
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8f5902;font-style:italic"> const obj = yaml.parse(raw)
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8f5902;font-style:italic"> return yaml.stringify(obj)
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8f5902;font-style:italic"> }&lt;/span>&lt;span style="color:#f8f8f8;text-decoration:underline">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;blockquote>
&lt;p>这里的 async 是 JS 中的一个关键字，用来指明函数是异步的，类似于 go 语言中在函数前加个 go 关键字表示并发。&lt;/p>
&lt;/blockquote>
&lt;p>这里相当于定义一个异步的 &lt;code>parse()&lt;/code> 函数，并导出它以便供 CFW 直接调用。&lt;code>parse()&lt;/code> 函数时接收 3 个参数，其中包含从订阅中获取到的配置文件内容，对配置进行一些自定义操作后，将会 return 配置文件内容给 CFW ，此时 CFW 会使用获取到的返回值更新该订阅的配置文件。&lt;/p>
&lt;p>&lt;code>parse()&lt;/code> 的三个参数：&lt;/p>
&lt;ul>
&lt;li>&lt;strong>raw&lt;/strong> # 从 url 中获取到的配置文件内容&lt;/li>
&lt;li>&lt;strong>{ axios, yaml, notify, console }&lt;/strong> # 导入的工具类对象/方法。可以直接在 &lt;code>parse()&lt;/code> 方法中调用
&lt;ul>
&lt;li>axios # 一个处理网络请求的库，&lt;a href="https://github.com/axios/axios">GitHub 项目，axios/axios&lt;/a>&lt;/li>
&lt;li>yaml # YAML 解析器库，&lt;a href="https://github.com/eemeli/yaml">GitHub 项目，eemeli/yaml&lt;/a>&lt;/li>
&lt;li>notify # 发出系统通知方法，签名为 &lt;code>function notify(title:string, message:string, silent:bool)&lt;/code>&lt;/li>
&lt;li>console # 这里的 console 可以将内容输出至文件，方便调试。在 Settings 界面中 Profiles.Console Output 出可以打开该文件
&lt;ul>
&lt;li>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/hr9k1t/1654315106258-ceecd242-6d51-4b9f-b9ba-a79377934be2.png" alt="image.png">&lt;/li>
&lt;li>该文件默认保存在 &lt;code>%LOCALAPPDATA%\Temp\cw-parser.log&lt;/code> 处&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>homeDir # Home Directory 目录&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>{ name, url, interval, selected }&lt;/strong> # 配置文件元数据
&lt;ul>
&lt;li>name # 订阅的名称&lt;/li>
&lt;li>url # 订阅的 URL&lt;/li>
&lt;li>interval # 订阅的更新策略&lt;/li>
&lt;li>selected：策略组选择缓存，数组&lt;/li>
&lt;li>mode：模式缓存&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h4 id="简单示例">简单示例&lt;a class="td-heading-self-link" href="#%e7%ae%80%e5%8d%95%e7%a4%ba%e4%be%8b" aria-label="Heading self-link">&lt;/a>&lt;/h4>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-javascript" data-lang="javascript">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#000">module&lt;/span>&lt;span style="color:#000;font-weight:bold">.&lt;/span>&lt;span style="color:#000">exports&lt;/span>&lt;span style="color:#000;font-weight:bold">.&lt;/span>&lt;span style="color:#000">parse&lt;/span> &lt;span style="color:#ce5c00;font-weight:bold">=&lt;/span> &lt;span style="color:#204a87;font-weight:bold">async&lt;/span> &lt;span style="color:#000;font-weight:bold">(&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#000">raw&lt;/span>&lt;span style="color:#000;font-weight:bold">,&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#000;font-weight:bold">{&lt;/span> &lt;span style="color:#000">axios&lt;/span>&lt;span style="color:#000;font-weight:bold">,&lt;/span> &lt;span style="color:#000">yaml&lt;/span>&lt;span style="color:#000;font-weight:bold">,&lt;/span> &lt;span style="color:#000">notify&lt;/span>&lt;span style="color:#000;font-weight:bold">,&lt;/span> &lt;span style="color:#000">console&lt;/span> &lt;span style="color:#000;font-weight:bold">},&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#000;font-weight:bold">{&lt;/span> &lt;span style="color:#000">name&lt;/span>&lt;span style="color:#000;font-weight:bold">,&lt;/span> &lt;span style="color:#000">url&lt;/span>&lt;span style="color:#000;font-weight:bold">,&lt;/span> &lt;span style="color:#000">interval&lt;/span>&lt;span style="color:#000;font-weight:bold">,&lt;/span> &lt;span style="color:#000">selected&lt;/span> &lt;span style="color:#000;font-weight:bold">}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#000;font-weight:bold">)&lt;/span> &lt;span style="color:#000;font-weight:bold">=&amp;gt;&lt;/span> &lt;span style="color:#000;font-weight:bold">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#204a87;font-weight:bold">const&lt;/span> &lt;span style="color:#000">obj&lt;/span> &lt;span style="color:#ce5c00;font-weight:bold">=&lt;/span> &lt;span style="color:#000">yaml&lt;/span>&lt;span style="color:#000;font-weight:bold">.&lt;/span>&lt;span style="color:#000">parse&lt;/span>&lt;span style="color:#000;font-weight:bold">(&lt;/span>&lt;span style="color:#000">raw&lt;/span>&lt;span style="color:#000;font-weight:bold">)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#000">console&lt;/span>&lt;span style="color:#000;font-weight:bold">.&lt;/span>&lt;span style="color:#000">log&lt;/span>&lt;span style="color:#000;font-weight:bold">(&lt;/span>&lt;span style="color:#000">name&lt;/span>&lt;span style="color:#000;font-weight:bold">)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#000">console&lt;/span>&lt;span style="color:#000;font-weight:bold">.&lt;/span>&lt;span style="color:#000">log&lt;/span>&lt;span style="color:#000;font-weight:bold">(&lt;/span>&lt;span style="color:#000">url&lt;/span>&lt;span style="color:#000;font-weight:bold">)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#000">console&lt;/span>&lt;span style="color:#000;font-weight:bold">.&lt;/span>&lt;span style="color:#000">log&lt;/span>&lt;span style="color:#000;font-weight:bold">(&lt;/span>&lt;span style="color:#000">interval&lt;/span>&lt;span style="color:#000;font-weight:bold">)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#000">console&lt;/span>&lt;span style="color:#000;font-weight:bold">.&lt;/span>&lt;span style="color:#000">log&lt;/span>&lt;span style="color:#000;font-weight:bold">(&lt;/span>&lt;span style="color:#000">selected&lt;/span>&lt;span style="color:#000;font-weight:bold">)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#204a87;font-weight:bold">return&lt;/span> &lt;span style="color:#000">yaml&lt;/span>&lt;span style="color:#000;font-weight:bold">.&lt;/span>&lt;span style="color:#000">stringify&lt;/span>&lt;span style="color:#000;font-weight:bold">(&lt;/span>&lt;span style="color:#000">obj&lt;/span>&lt;span style="color:#000;font-weight:bold">)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#000;font-weight:bold">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>在 Console Output 文件中会输出如下内容：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>Ghelper
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>https://ghelper.me/clash/XXXXXX
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#0000cf;font-weight:bold">0&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ce5c00;font-weight:bold">[]&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>这个简单示例并没有对从订阅中获取的原始配置进行任何更改，仅仅是输出了一些信息，然后直接将配置原封不动返回给了 CFW。&lt;/p>
&lt;h1 id="v2ray-客户端">V2Ray 客户端&lt;a class="td-heading-self-link" href="#v2ray-%e5%ae%a2%e6%88%b7%e7%ab%af" aria-label="Heading self-link">&lt;/a>&lt;/h1>
&lt;h3 id="qv2rayhttpsgithubcomqv2rayqv2ray">&lt;a href="https://github.com/Qv2ray/Qv2ray">Qv2ray&lt;/a>&lt;a class="td-heading-self-link" href="#qv2rayhttpsgithubcomqv2rayqv2ray" aria-label="Heading self-link">&lt;/a>&lt;/h3>
&lt;p>跨平台 V2Ray 客户端，支持 Linux、Windows、macOS，可通过插件系统支持 SSR / Trojan / Trojan-Go / NaiveProxy 等协议&lt;/p>
&lt;h3 id="sagernethttpsgithubcomsagernetsagernet">&lt;a href="https://github.com/SagerNet/SagerNet">SagerNet&lt;/a>&lt;a class="td-heading-self-link" href="#sagernethttpsgithubcomsagernetsagernet" aria-label="Heading self-link">&lt;/a>&lt;/h3>
&lt;p>已归档&lt;/p>
&lt;p>SagerNet 是一个基于 V2Ray 的 Android 通用代理应用。&lt;/p>
&lt;h3 id="v2raynhttpsgithubcom2dustv2rayn">&lt;a href="https://github.com/2dust/v2rayN">V2rayN&lt;/a>&lt;a class="td-heading-self-link" href="#v2raynhttpsgithubcom2dustv2rayn" aria-label="Heading self-link">&lt;/a>&lt;/h3>
&lt;p>V2RayN 是一个基于 V2Ray 内核的 Windows 客户端。&lt;/p>
&lt;h3 id="v2rayahttpsgithubcomv2rayav2raya">&lt;a href="https://github.com/v2rayA/v2rayA">v2rayA&lt;/a>&lt;a class="td-heading-self-link" href="#v2rayahttpsgithubcomv2rayav2raya" aria-label="Heading self-link">&lt;/a>&lt;/h3>
&lt;p>基于 web GUI 的跨平台 V2Ray 客户端，在 Linux 上支持全局透明代理，其他平台上支持系统代理。&lt;/p></description></item></channel></rss>