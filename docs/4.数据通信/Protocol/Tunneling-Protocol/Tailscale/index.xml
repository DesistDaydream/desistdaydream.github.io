<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Tailscale on 断念梦的站点</title><link>https://desistdaydream.github.io/docs/4.%E6%95%B0%E6%8D%AE%E9%80%9A%E4%BF%A1/Protocol/Tunneling-Protocol/Tailscale/</link><description>Recent content in Tailscale on 断念梦的站点</description><generator>Hugo</generator><language>zh-cn</language><atom:link href="https://desistdaydream.github.io/docs/4.%E6%95%B0%E6%8D%AE%E9%80%9A%E4%BF%A1/Protocol/Tunneling-Protocol/Tailscale/index.xml" rel="self" type="application/rss+xml"/><item><title>Tailscale</title><link>https://desistdaydream.github.io/docs/4.%E6%95%B0%E6%8D%AE%E9%80%9A%E4%BF%A1/Protocol/Tunneling-Protocol/Tailscale/Tailscale/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/4.%E6%95%B0%E6%8D%AE%E9%80%9A%E4%BF%A1/Protocol/Tunneling-Protocol/Tailscale/Tailscale/</guid><description>WireGuard 相比于传统 VPN 的核心优势是没有 VPN 网关，所有节点之间都可以点对点（P2P）连接，也就是我之前提到的全互联模式（full mesh），效率更高，速度更快，成本更低。
WireGuard 目前最大的痛点就是上层应用的功能不够健全，因为 WireGuard 推崇的是 Unix 的哲学，WireGuard 本身只是一个内核级别的模块，只是一个数据平面，至于上层的更高级的功能（比如秘钥交换机制，UDP 打洞，ACL 等），需要通过用户空间的应用来实现。
所以为了基于 WireGuard 实现更完美的 VPN 工具，现在已经涌现出了很多项目在互相厮杀。Netmaker 通过可视化界面来配置 WireGuard 的全互联模式，它支持 UDP 打洞、多租户等各种高端功能，几乎适配所有平台，非常强大。然而现实世界是复杂的，无法保证所有的 NAT 都能打洞成功，且 Netmaker 目前还没有 fallback 机制，如果打洞失败，无法 fallback 改成走中继节点。Tailscale 在这一点上比 Netmaker 高明许多，它支持 fallback 机制，可以尽最大努力实现全互联模式，部分节点即使打洞不成功，也能通过中继节点在这个虚拟网络中畅通无阻。
概述 参考：
GitHub 项目，tailscale/tailscale 官网 公众号，云原声实验室-Tailscal 开源版本让你的 WireGuard 直接起飞 Tailscale 是一种基于 WireGuard 的虚拟组网工具，和 Netmaker 类似，最大的区别在于 Tailscale 是在用户态实现了 WireGuard 协议，而 Netmaker 直接使用了内核态的 WireGuard。所以 Tailscale 相比于内核态 WireGuard 性能会有所损失，但与 OpenVPN 之流相比还是能甩好几十条街的，Tailscale 虽然在性能上做了些许取舍，但在功能和易用性上绝对是完爆其他工具：
开箱即用 无需配置防火墙 没有额外的配置 高安全性/私密性 自动密钥轮换 点对点连接 支持用户审查端到端的访问记录 在原有的 ICE、STUN 等 UDP 协议外，实现了 DERP TCP 协议来实现 NAT 穿透 基于公网的控制服务器下发 ACL 和配置，实现节点动态更新 通过第三方（如 Google） SSO 服务生成用户和私钥，实现身份认证 简而言之，我们可以将 Tailscale 看成是更为易用、功能更完善的 WireGuard。</description></item><item><title>Headscale</title><link>https://desistdaydream.github.io/docs/4.%E6%95%B0%E6%8D%AE%E9%80%9A%E4%BF%A1/Protocol/Tunneling-Protocol/Tailscale/Headscale/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/4.%E6%95%B0%E6%8D%AE%E9%80%9A%E4%BF%A1/Protocol/Tunneling-Protocol/Tailscale/Headscale/</guid><description>概述 参考：
GitHub 项目，juanfont/headscale 公众号，云原声实验室 - Tailscal 开源版本让你的 WireGuard 直接起飞 馆长博客，headscale 搭建和应用场景 Tailscale 的控制服务器是不开源的，而且对免费用户有诸多限制，这是人家的摇钱树，可以理解。好在目前有一款开源的实现叫 Headscale，这也是唯一的一款，希望能发展壮大。
Headscale 由欧洲航天局的 Juan Font 使用 Go 语言开发，在 BSD 许可下发布，实现了 Tailscale 控制服务器的所有主要功能，可以部署在企业内部，没有任何设备数量的限制，且所有的网络流量都由自己控制。
目前 Headscale 还没有可视化界面，期待后续更新吧。
Headscale 关联文件与配置 /etc/headscale/config.yaml # Headscale 运行时配置文件
/var/lib/headscale/# Headscale 运行时数据目录。包括 数据库文件、证书 等
./db.sqlite # Headscale 使用 sqlite 作为数据库 这里是配置文件示例
Headscale 部署 Headscale 部署很简单，推荐直接在 Linux 主机上安装。
理论上来说只要你的 Headscale 服务可以暴露到公网出口就行，但最好不要有 NAT，所以推荐将 Headscale 部署在有公网 IP 的云主机上。
准备一些环境变量 export HeadscaleVersion=&amp;#34;0.22.3&amp;#34; export HeadscaleArch=&amp;#34;amd64&amp;#34; # Headscale 用于与各个节点通信的 IP export HeadscaleAddr=&amp;#34;https://X.</description></item><item><title>tailscale CLI</title><link>https://desistdaydream.github.io/docs/4.%E6%95%B0%E6%8D%AE%E9%80%9A%E4%BF%A1/Protocol/Tunneling-Protocol/Tailscale/tailscale-CLI/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/4.%E6%95%B0%E6%8D%AE%E9%80%9A%E4%BF%A1/Protocol/Tunneling-Protocol/Tailscale/tailscale-CLI/</guid><description>概述 参考：
官方文档，参考 - CLI Syntax(语法) tailscale COMMAND
netcheck # 打印本地网络状况分析。主要是显示当前可用的 DERP 以及本机到各个 DERP 的连接延迟 等信息。 ping &amp;lt;HOST&amp;gt; # 通过 Tailscale ping 指定主机，看看本机是如何路由到目标的（是直通还是经过了 DERP） set # 改变指定的配置。 up set &amp;ndash;accept-routes # 是否接受其他节点公开的路由信息。默认值: false
&amp;ndash;advertise-routes # 向整个 Tailscale 网络公开本机的路由。也就是说告诉其他节点访问哪些 IP 要经过本机。默认值: 空，值是以 , 分割的 CIDR 格式的子网
EXAMPLE</description></item><item><title>Tailscale DERP</title><link>https://desistdaydream.github.io/docs/4.%E6%95%B0%E6%8D%AE%E9%80%9A%E4%BF%A1/Protocol/Tunneling-Protocol/Tailscale/Tailscale-DERP/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/4.%E6%95%B0%E6%8D%AE%E9%80%9A%E4%BF%A1/Protocol/Tunneling-Protocol/Tailscale/Tailscale-DERP/</guid><description>概述 参考：
公众号，自建 DERP 中继服务器，从此 Tailscale 畅通无阻 官方文档，自定义 DERP 服务器 上篇文章介绍了如何使用 Headscale 替代 Tailscale 官方的控制服务器，并接入各个平台的客户端。本文将会介绍如何让 Tailscale 使用自定义的 DERP Servers。可能很多人都不知道 DERP 是个啥玩意儿，没关系，我先从 中继服务器 开始讲起。
STUN 是什么 Tailscale 的终极目标是让两台处于网络上的任何位置的机器建立点对点连接（直连），但现实世界是复杂的，大部份情况下机器都位于 NAT 和防火墙后面，这时候就需要通过打洞来实现直连，也就是 NAT 穿透。
NAT 按照 NAT 映射行为和有状态防火墙行为可以分为多种类型，但对于 NAT 穿透来说根本不需要关心这么多类型，只需要看 NAT 或者有状态防火墙是否会严格检查目标 Endpoint，根据这个因素，可以将 NAT 分为 Easy NAT 和 Hard NAT。
Easy NAT 及其变种称为 “Endpoint-Independent Mapping” (EIM，终点无关的映射) 这里的 Endpoint 指的是目标 Endpoint，也就是说，有状态防火墙只要看到有客户端自己发起的出向包，就会允许相应的入向包进入，不管这个入向包是谁发进来的都可以。 hard NAT 以及变种称为 “Endpoint-Dependent Mapping”（EDM，终点相关的映射） 这种 NAT 会针对每个目标 Endpoint 来生成一条相应的映射关系。在这样的设备上，如果客户端向某个目标 Endpoint 发起了出向包，假设客户端的公网 IP 是 2.</description></item><item><title>Tailscale ACL 访问控制策略</title><link>https://desistdaydream.github.io/docs/4.%E6%95%B0%E6%8D%AE%E9%80%9A%E4%BF%A1/Protocol/Tunneling-Protocol/Tailscale/Tailscale-ACL-%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6%E7%AD%96%E7%95%A5/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/4.%E6%95%B0%E6%8D%AE%E9%80%9A%E4%BF%A1/Protocol/Tunneling-Protocol/Tailscale/Tailscale-ACL-%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6%E7%AD%96%E7%95%A5/</guid><description>概述 参考：
公众号-云原生实验室，ailscale ACL 访问控制策略完全指南！ 大家好，我是米开朗基杨。
前面几篇文章给大家给介绍了 Tailscale 和 Headscale，包括 👉Headscale 的安装部署和各个平台客户端的接入，以及如何打通各个节点所在的局域网。同时还介绍了👉 如何自建私有的 DERP 服务器，并让 Tailscale 使用我们自建的 DERP 服务器。
今天我们来探索一下更复杂的场景。想象有这么一个场景，我系统通过 Tailscale 方便的连接一台不完全属于我的设备， 这台设备可能还有其他人也在使用。如果我仅仅是安装一个 Tailscale， 那么所有能登录这台设备的人都可以通过 Tailscale 连接我所有的设备。
我能不能实现这样一种需求：我可以连接这台节点，但是这台节点不能连接我的其他节点？
这就是 Tailscale ACL（Access Control List）干的事情。ACL 可以严格限制特定用户或设备在 Tailscale 网络上访问的内容。
虽然 Headscale 兼容 Tailscale 的 ACL，但还是有些许差异的。本文所讲的 ACL 只适用于 Headscale，如果你使用的是官方的控制服务器，有些地方可能跟预期不符，请自行参考 Tailscale 的官方文档。
Tailscale/Headscale 的默认访问规则是 default deny，也就是黑名单模式，只有在访问规则明确允许的情况下设备之间才能通信。所以 Tailscale/Headscale 默认会使用 allowall 访问策略进行初始化，该策略允许加入到 Tailscale 网络的所有设备之间可以相互访问。
Tailscale/Headscale 通过使用 group 这种概念，可以只用非常少的规则就能表达大部分安全策略。除了 group 之外，还可以为设备打 tag 来进一步扩展访问策略。结合 group 和 tag 就可以构建出强大的基于角色的访问控制（RBAC）策略。
关于 Tailscale 访问控制系统的详情可以参考这篇文章：基于角色的访问控制（RBAC）：演进历史、设计理念及简洁实现[1]。这篇文章深入探讨了访问控制系统的历史，从设计层面分析了 DAC -&amp;gt; MAC -&amp;gt; RBAC -&amp;gt; ABAC 的演进历程及各模型的优缺点、适用场景等， 然后从实际需求出发，一步步地设计出一个实用、简洁、真正符合 RBAC 理念的访问控制系统。</description></item></channel></rss>