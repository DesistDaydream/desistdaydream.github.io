<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Tailscale on 断念梦的站点</title><link>https://desistdaydream.github.io/docs/4.%E6%95%B0%E6%8D%AE%E9%80%9A%E4%BF%A1/Protocol/Tunneling-Protocol/Tailscale/</link><description>Recent content in Tailscale on 断念梦的站点</description><generator>Hugo</generator><language>zh-cn</language><atom:link href="https://desistdaydream.github.io/docs/4.%E6%95%B0%E6%8D%AE%E9%80%9A%E4%BF%A1/Protocol/Tunneling-Protocol/Tailscale/index.xml" rel="self" type="application/rss+xml"/><item><title>Tailscale</title><link>https://desistdaydream.github.io/docs/4.%E6%95%B0%E6%8D%AE%E9%80%9A%E4%BF%A1/Protocol/Tunneling-Protocol/Tailscale/Tailscale/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/4.%E6%95%B0%E6%8D%AE%E9%80%9A%E4%BF%A1/Protocol/Tunneling-Protocol/Tailscale/Tailscale/</guid><description>WireGuard 相比于传统 VPN 的核心优势是没有 VPN 网关，所有节点之间都可以点对点（P2P）连接，也就是我之前提到的全互联模式（full mesh），效率更高，速度更快，成本更低。
WireGuard 目前最大的痛点就是上层应用的功能不够健全，因为 WireGuard 推崇的是 Unix 的哲学，WireGuard 本身只是一个内核级别的模块，只是一个数据平面，至于上层的更高级的功能（比如秘钥交换机制，UDP 打洞，ACL 等），需要通过用户空间的应用来实现。
所以为了基于 WireGuard 实现更完美的 VPN 工具，现在已经涌现出了很多项目在互相厮杀。Netmaker 通过可视化界面来配置 WireGuard 的全互联模式，它支持 UDP 打洞、多租户等各种高端功能，几乎适配所有平台，非常强大。然而现实世界是复杂的，无法保证所有的 NAT 都能打洞成功，且 Netmaker 目前还没有 fallback 机制，如果打洞失败，无法 fallback 改成走中继节点。Tailscale 在这一点上比 Netmaker 高明许多，它支持 fallback 机制，可以尽最大努力实现全互联模式，部分节点即使打洞不成功，也能通过中继节点在这个虚拟网络中畅通无阻。
概述 参考：
GitHub 项目，tailscale/tailscale 官网 公众号 - 云原声实验室，Tailscal 开源版本让你的 WireGuard 直接起飞 Tailscale 的开源方案 Tailscale 是一种基于 WireGuard 的虚拟组网工具，和 Netmaker 类似，最大的区别在于 Tailscale 是在用户态实现了 WireGuard 协议，而 Netmaker 直接使用了内核态的 WireGuard。所以 Tailscale 相比于内核态 WireGuard 性能会有所损失，但与 OpenVPN 之流相比还是能甩好几十条街的，Tailscale 虽然在性能上做了些许取舍，但在功能和易用性上绝对是完爆其他工具：</description></item><item><title>Tailscale ACL</title><link>https://desistdaydream.github.io/docs/4.%E6%95%B0%E6%8D%AE%E9%80%9A%E4%BF%A1/Protocol/Tunneling-Protocol/Tailscale/Tailscale-ACL/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/4.%E6%95%B0%E6%8D%AE%E9%80%9A%E4%BF%A1/Protocol/Tunneling-Protocol/Tailscale/Tailscale-ACL/</guid><description>概述 参考：
官方文档，使用 ACL 管理权限 官方文档，参考 - Tailnet 策略文件语法 Tailscale 博客，RBAC 的初衷 ACL 的配置示例 groups https://tailscale.com/kb/1337/policy-syntax#groups
hosts https://tailscale.com/kb/1337/policy-syntax#hosts
acls https://tailscale.com/kb/1337/policy-syntax#acls
dst dst 字段设置一个访问目标的列表，该列表是一组适用于某 acl 规则的访问目标。
列表中的每个元素格式为 HOST:PORTS。i.e. 1 个 host，1 个或多个 ports。
HOST 可以是一以下任意类型
Type Example Description Any * Includes any destination (no restrictions). User shreya@example.com Includes any device currently signed in as the provided user. Group group:&amp;lt;group-name&amp;gt; Includes all users in the provided group. Tailscale IP address 100.101.102.103 Includes only the device that owns the provided Tailscale IP address.</description></item><item><title>tailscale CLI</title><link>https://desistdaydream.github.io/docs/4.%E6%95%B0%E6%8D%AE%E9%80%9A%E4%BF%A1/Protocol/Tunneling-Protocol/Tailscale/tailscale-CLI/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/4.%E6%95%B0%E6%8D%AE%E9%80%9A%E4%BF%A1/Protocol/Tunneling-Protocol/Tailscale/tailscale-CLI/</guid><description>概述 参考：
官方文档，参考 - CLI Syntax(语法) tailscale COMMAND
netcheck # 打印本地网络状况分析。主要是显示当前可用的 DERP 以及本机到各个 DERP 的连接延迟 等信息。 ping &amp;lt;HOST&amp;gt; # 通过 Tailscale ping 指定主机，看看本机是如何路由到目标的（是直通还是经过了 DERP） set # 改变指定的配置。 login/logout login 登录到 Tailscale 协调服务器
logout 从Tailscale 协调服务器登出，并使节点的密钥过期
up/down 连接/断开 与 Tailscaled 的链接。断开后，Tailscale 协调服务器（e.g. Headscale）将不会连接到该节点。
set &amp;ndash;accept-routes # 是否接受其他节点公开的路由信息。默认值: false
Tips: 对应 /var/lib/tailscale/tailscaled.state 文件中 .profile-XXX 字段中的 .RouteAll 字段 &amp;ndash;advertise-routes # 向整个 Tailscale 网络公开本机的路由。也就是说告诉其他节点访问哪些 IP 要经过本机。默认值: 空，值是以 , 分割的 CIDR 格式的子网
switch 显示或切换到不同的 Tailscale 账户。</description></item><item><title>Tailscale DERP</title><link>https://desistdaydream.github.io/docs/4.%E6%95%B0%E6%8D%AE%E9%80%9A%E4%BF%A1/Protocol/Tunneling-Protocol/Tailscale/Tailscale-DERP/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/4.%E6%95%B0%E6%8D%AE%E9%80%9A%E4%BF%A1/Protocol/Tunneling-Protocol/Tailscale/Tailscale-DERP/</guid><description>概述 参考：
公众号，自建 DERP 中继服务器，从此 Tailscale 畅通无阻 官方文档，自定义 DERP 服务器 上篇文章介绍了如何使用 Headscale 替代 Tailscale 官方的控制服务器，并接入各个平台的客户端。本文将会介绍如何让 Tailscale 使用自定义的 DERP Servers。可能很多人都不知道 DERP 是个啥玩意儿，没关系，我先从 中继服务器 开始讲起。
STUN 是什么 Tailscale 的终极目标是让两台处于网络上的任何位置的机器建立点对点连接（直连），但现实世界是复杂的，大部份情况下机器都位于 NAT 和防火墙后面，这时候就需要通过打洞来实现直连，也就是 NAT 穿透。
NAT 按照 NAT 映射行为和有状态防火墙行为可以分为多种类型，但对于 NAT 穿透来说根本不需要关心这么多类型，只需要看 NAT 或者有状态防火墙是否会严格检查目标 Endpoint，根据这个因素，可以将 NAT 分为 Easy NAT 和 Hard NAT。
Easy NAT 及其变种称为 “Endpoint-Independent Mapping” (EIM，终点无关的映射) 这里的 Endpoint 指的是目标 Endpoint，也就是说，有状态防火墙只要看到有客户端自己发起的出向包，就会允许相应的入向包进入，不管这个入向包是谁发进来的都可以。 hard NAT 以及变种称为 “Endpoint-Dependent Mapping”（EDM，终点相关的映射） 这种 NAT 会针对每个目标 Endpoint 来生成一条相应的映射关系。在这样的设备上，如果客户端向某个目标 Endpoint 发起了出向包，假设客户端的公网 IP 是 2.</description></item><item><title>Headscale</title><link>https://desistdaydream.github.io/docs/4.%E6%95%B0%E6%8D%AE%E9%80%9A%E4%BF%A1/Protocol/Tunneling-Protocol/Tailscale/Headscale/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/4.%E6%95%B0%E6%8D%AE%E9%80%9A%E4%BF%A1/Protocol/Tunneling-Protocol/Tailscale/Headscale/</guid><description>概述 参考：
GitHub 项目，juanfont/headscale 公众号 - 云原声实验室，Tailscal 开源版本让你的 WireGuard 直接起飞 馆长博客，headscale 搭建和应用场景 Tailscale 的控制服务器是不开源的，而且对免费用户有诸多限制，这是人家的摇钱树，可以理解。好在目前有一款开源的实现叫 Headscale，这也是唯一的一款，希望能发展壮大。
Headscale 由欧洲航天局的 Juan Font 使用 Go 语言开发，在 BSD 许可下发布，实现了 Tailscale 控制服务器的所有主要功能，可以部署在企业内部，没有任何设备数量的限制，且所有的网络流量都由自己控制。
目前 Headscale 还没有可视化界面，期待后续更新吧。
Headscale 部署 理论上来说只要你的 Headscale 服务可以暴露到公网出口就行，但最好不要有 NAT，所以推荐将 Headscale 部署在有公网 IP 的云主机上。
安装程序与应用配置 准备一些环境变量
export HeadscaleVersion=&amp;#34;0.22.3&amp;#34; export HeadscaleArch=&amp;#34;amd64&amp;#34; # 各个 Tailscale 节点与 Headscale 通信的 IP export HeadscaleAddr=&amp;#34;https://X.X.X.X:YYY&amp;#34; 准备 Headscale 相关文件及目录。从 GitHub 仓库的 Release 页面下载最新版的二进制文件。
wget --output-document=/usr/local/bin/headscale \ https://github.com/juanfont/headscale/releases/download/v${HeadscaleVersion}/headscale_${HeadscaleVersion}_linux_${HeadscaleArch} chmod +x /usr/local/bin/headscale 创建相关目录及文件
mkdir -p /etc/headscale mkdir -p /var/lib/headscale touch /var/lib/headscale/db.</description></item><item><title>Tailscale: How it works</title><link>https://desistdaydream.github.io/docs/4.%E6%95%B0%E6%8D%AE%E9%80%9A%E4%BF%A1/Protocol/Tunneling-Protocol/Tailscale/Tailscale-How-it-works/</link><pubDate>Sat, 21 Mar 2020 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/4.%E6%95%B0%E6%8D%AE%E9%80%9A%E4%BF%A1/Protocol/Tunneling-Protocol/Tailscale/Tailscale-How-it-works/</guid><description>Blog 博客 | 三月 20, 2020
How Tailscale works Tailscale 工作原理 People often ask us for an overview of how Tailscale works. We’ve been putting off answering that, because we kept changing it! But now things have started to settle down.
人们经常要求我们概述 Tailscale 的工作原理。我们一直推迟回答这个问题，因为我们的架构在不断演进！但现在系统已逐渐趋于稳定。
Let’s go through the entire Tailscale system from bottom to top, the same way we built it (but skipping some zigzags we took along the way). With this information, you should be able to build your own Tailscale replacement… except you don’t have to, since our node software is open source and we have a flexible free plan.</description></item></channel></rss>