<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>通信协议 on 断念梦的站点</title><link>https://desistdaydream.github.io/docs/4.%E6%95%B0%E6%8D%AE%E9%80%9A%E4%BF%A1/Protocol/</link><description>Recent content in 通信协议 on 断念梦的站点</description><generator>Hugo</generator><language>zh-cn</language><atom:link href="https://desistdaydream.github.io/docs/4.%E6%95%B0%E6%8D%AE%E9%80%9A%E4%BF%A1/Protocol/index.xml" rel="self" type="application/rss+xml"/><item><title>通信协议</title><link>https://desistdaydream.github.io/docs/4.%E6%95%B0%E6%8D%AE%E9%80%9A%E4%BF%A1/Protocol/%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/4.%E6%95%B0%E6%8D%AE%E9%80%9A%E4%BF%A1/Protocol/%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/</guid><description>概述 参考：
Wiki, Communication Protocol(通信协议) Wiki, Encapsulation(封装) Wiki, PDU 注：Wiki 中将网络层 PDU 描述为 Packet 不够准确，详见 RFC 1594 中 13 节 Packet 的名词解释 Wiki, SDU RFC 1325、RFC 1594、RFC 2664 这几个 RFC 是一些关于互联网的仅供参考的常见问答，里面包含一些名词解释，2664 是最新版 Communication Protocol(通信协议) 是一个规则系统，允许通信系统的两个或多个实体通过物理量的任何变化来传输信息。该协议定义了通信的规则、语法、语义和同步以及可能的错误恢复方法。协议可以通过硬件、软件或两者的组合来实现。
网络系统的分层架构 因特网是一个极为复杂的系统，这个系统有许多部分：大量的应用程序和协议、各种类型的端系统、分组交换机和各种类型的链路级媒体 等等等等。面对这种巨大的复杂性，我们迫切得需要组织整个网络体系结构。
网络设计者以 Layer(分层) 的方式组织协议以及实现这些协议的硬件/软件。每个协议属于这些层次之一，各层的所有协议被统称为 Protocol Stack(协议栈)。
Encapsulation(封装) Encapsulation(封装) 是一种设计模块化通信协议的方法，是将上层数据经过处理，变为下层数据的过程。处理完成后的实体称为 Protocol Data Unit(协议数据单元，简称 PDU) 或 Service Data Unit(服务数据单元，简称 SDU)。
PDU 与 SDU 通常来说可以一起理解，楞要说区别，可有有以下几点
SDU 并不会跨主机，可以说，比如说同一个主机应用层往传输层发送的内容。而 PDU 则是两个不同主机，由 A 主机应用层发送到 B 主机应用层的内容。 SDU 是 PDU 的一个子集 SDU 是 PDU 中的一个 Payload(有效载荷) 比如，主机 A 要向主机 B 发送一条信息。这条信息就称为 Data(数据)/Payload(有效载荷)。这条消息从主机 A 发送出去之前，会被各种协议进行处理，这个处理的过程，就是 Encapsulation(封装)，封装之后的产物就是 PDU，不同网络层的 PDU 叫法不同：</description></item><item><title>ARP 与 NDP</title><link>https://desistdaydream.github.io/docs/4.%E6%95%B0%E6%8D%AE%E9%80%9A%E4%BF%A1/Protocol/ARP-%E4%B8%8E-NDP/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/4.%E6%95%B0%E6%8D%AE%E9%80%9A%E4%BF%A1/Protocol/ARP-%E4%B8%8E-NDP/</guid><description>概述 参考：
Wiki, ARP Wiki, NDP RFC 826 公众号，36 张图详解 ARP Address Resolution Protoco(地址解析协议，简称 ARP) 是一种通信协议，该协议可以通过给定的网络层地址(通常是 IPv4 地址)，发现与之相关联的链路层地址(通常你是 MAC 地址)。ARP 于 1982 年在 RFC 826 中定义。说白了，就是根据 IP 地址查询对应 MAC 地址的协议。
注意：在 IPv6 网络环境下，APR 的功能已经被 NDP 替代
对应关系：一个 ip 地址对应一个 MAC 地址。多个 ip 地址可以对应一个 MAC 地址(e.g.一个网卡上配置两个 ip)
ARP 报文 在抓包时，可以抓到如下几种 ARP 包
ARP, Request who-has 10.10.100.254 tell 10.10.100.101, length 28 在局域网中询问谁有 10.10.100.254，告诉自己，自己就是 10.10.100.101 ARP, Reply 10.10.100.254 is-at 00:0f:e2:ff:05:92, length 46 当 10.</description></item><item><title>通信协议通用概念</title><link>https://desistdaydream.github.io/docs/4.%E6%95%B0%E6%8D%AE%E9%80%9A%E4%BF%A1/Protocol/%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE%E9%80%9A%E7%94%A8%E6%A6%82%E5%BF%B5/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/4.%E6%95%B0%E6%8D%AE%E9%80%9A%E4%BF%A1/Protocol/%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE%E9%80%9A%E7%94%A8%E6%A6%82%E5%BF%B5/</guid><description>MTU 与 MSS 参考：
Wiki, MTU Wiki, MSS Maximum Transmission Unit(即最大传输单元，简称 MTU) 是一个二层的概念；以太网最大的 mtu 就是 1500（它是不包含二层头部的，加上头部应该为 1518 bytes，2bit 的以太网类型+6bit 的 DMAC+6bit 的 SMAC+4bit 的 FCS），每个以太网帧都有最小的大小 64bytes，最大不能超过 1518bytes
注：
小于 64Bytes 的数据帧一般是由于以太网冲突产生的 “碎片”或者线路干扰或者坏的以太网接口产生的，对于大于 1518Bytes 的数据帧我们一般把它叫做 Giant 帧，这种一般是由于线路干扰或者坏的以太网口产生 以太网 EthernetII 最大的数据帧是 1518Bytes，是指包含以太网帧的帧头（DMAC 目的 MAC 地址 48bit=6Bytes+SMAC 源 MAC 地址 48bit=6Bytes+Type 域 2bytes）14Bytes 和帧尾 CRC 校验部分 4Bytes （这个部份有时候大家也把它叫做 FCS） IP MTU 是一个三层概念，它包含了三层头部及所有载荷，根据下层为上层服务的，上层基于下层才能做进一步的扩展的原则，尽管 IP MTU 的变化范围很大（68-65535），但也不得不照顾以太网 MTU 的限制,说白了就是 ip 对以太网的妥协。
网络层 IP 协议会检查每个从上层协议下来的数据包的大小，并根据本机 MTU 的大小决定是否作“分片”处理</description></item><item><title>BGP</title><link>https://desistdaydream.github.io/docs/4.%E6%95%B0%E6%8D%AE%E9%80%9A%E4%BF%A1/Protocol/BGP/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/4.%E6%95%B0%E6%8D%AE%E9%80%9A%E4%BF%A1/Protocol/BGP/</guid><description>概述 参考：
Border Gateway Protocol(边界网关协议，简称 BFP) 是一个 Linux 内核原生就支持的、专门用在大规模数据中心里维护不同的“自治系统”之间路由信息的、无中心的路由协议。
在这个图中，我们有两个自治系统（Autonomous System，简称为 AS）：AS 1 和 AS 2。而所谓的一个自治系统，指的是一个组织管辖下的所有 IP 网络和路由器的全体。你可以把它想象成一个小公司里的所有主机和路由器。在正常情况下，自治系统之间不会有任何“来往”。
但是，如果这样两个自治系统里的主机，要通过 IP 地址直接进行通信，我们就必须使用路由器把这两个自治系统连接起来。
比如，AS 1 里面的主机 10.10.0.2，要访问 AS 2 里面的主机 172.17.0.3 的话。它发出的 IP 包，就会先到达自治系统 AS 1 上的路由器 Router 1。
而在此时，Router 1 的路由表里，有这样一条规则，即：目的地址是 172.17.0.2 包，应该经过 Router 1 的 C 接口，发往网关 Router 2（即：自治系统 AS 2 上的路由器）。
所以 IP 包就会到达 Router 2 上，然后经过 Router 2 的路由表，从 B 接口出来到达目的主机 172.17.0.3。
但是反过来，如果主机 172.17.0.3 要访问 10.10.0.2，那么这个 IP 包，在到达 Router 2 之后，就不知道该去哪儿了。因为在 Router 2 的路由表里，并没有关于 AS 1 自治系统的任何路由规则。</description></item><item><title>ICMP</title><link>https://desistdaydream.github.io/docs/4.%E6%95%B0%E6%8D%AE%E9%80%9A%E4%BF%A1/Protocol/ICMP/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/4.%E6%95%B0%E6%8D%AE%E9%80%9A%E4%BF%A1/Protocol/ICMP/</guid><description>概述 参考：
公众号,24 张图搞定 ICMP ICMP IP 是尽力传输的网络协议，提供的数据传输服务是不可靠的、无连接的，不能保证数据包能成功到达目的地。那么问题来了：如何确定数据包成功到达目的地？ 不可靠传输 这需要一个网络层协议，提供错误检测功能和报告机制功能，于是出现了 ICMP（互联网控制消息协议）。ICMP 的主要功能是，确认 IP 包是否成功送达目的地址，通知发送过程中 IP 包被丢弃的原因。有了这些功能，就可以检查网络是否正常、网络配置是否正确、设备是否异常等信息，方便进行网络问题诊断。 ICMP 网络诊断功能 举个栗子：如果在传输过程中，发生了某个错误，设备便会向源设备返回一条 ICMP 消息，告诉它发生的错误类型。 ICMP 举例 ICMP 消息是通过 IP 进行传输，但它的目的并不是让 IP 成为一种可靠的协议，而是对传输中发生的问题进行反馈。ICMP 消息的传输同样得不到可靠性保证，也有可能在传输过程中丢失。因此 ICMP 不是传输层的补充，应该把它当做网络层协议。
ICMP 消息封装 ICMP 消息使用 IP 来封装，封装格式如下图。 ICMP 封装格式 其中 type（类型）字段表示 ICMP 消息的类型，code（代码）字段表示 ICMP 消息的具体含义。例如：type 值为 3 表示目的不可达消息（ Destination Unreachable Message ），若 code 值为 0 表示目的网络不可达（ Network Unreachable ）。常见的 ICMP 消息类型如下图。 ICMP 消息类型 从功能上，ICMP 的消息可分为两类：一类是通知出错原因的错误消息，另一类是用于诊断的查询消息。 错误消息和查询消息
常见的 ICMP 消息类型 回送请求消息（ Echo Request ）：是由源设备（主机或路由器等）向一个指定的目的设备发出的请求。这种消息用来测试目的地是否可达。 回送响应消息（ Echo Reply ）：对 Echo Request 的响应。目的设备发送 Echo Reply 来响应收到的 Echo Request 。最常用的 ping 命令就是使用 Echo Request 和 Echo Reply 来实现的。 回送消息</description></item><item><title>VRRP</title><link>https://desistdaydream.github.io/docs/4.%E6%95%B0%E6%8D%AE%E9%80%9A%E4%BF%A1/Protocol/VRRP/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/4.%E6%95%B0%E6%8D%AE%E9%80%9A%E4%BF%A1/Protocol/VRRP/</guid><description>概述 参考：
Virtual Router Redundancy Protocol(虚拟路由冗余协议，简称 VRRP) 是一种容错协议，其主要目的是解决路由单点故障的问题。VRRP 协议将局域网内的一组路由器虚拟为单个路由，通常将其称为一个路由备份组， 而这组路由器内包括一个 Master 路由（ 即活动路由器）和若干个 Backup 路由（即备份路由器）， VRRP 虚拟路由示意图如图 3-3 所示。在图 3-3 中 RouterA 、RouterB 和 RouterC 属于同一个 VRRP 组，组成一个虚拟路由器，而由 VRRP 协议虚拟出来的路由器拥有自己的 IP 地址 10.110.10.1 ，而备份组内的路由器也有自己的 IP 地址（如 Master 的 IP 地址为 10.110.10.5, Backup 的 IP 地址为 10.110.10.6 和 10.110.10.7）。
虚拟 IP：VIP，Virtual IP Address，在实际使用中，局域网内的主机仅仅知道这命虚拟路由器的 IP 地址 10 .110.10.1，而并不知道具体的 Master 路由器的 IP 地址以及 Backup 路由器的 IP 地址。局域网内的主机将自己的默认路由下一跳地址设置为该虚拟路由器的 IP 地址 10.110.10.1 之后，网络内的主机就通过这个虚拟的路由器来与其他网络进行通信。在通信过程中，如果备份组内的 Master 路由器故障，则 Backup 路由器将会通过选举机制重新选出一个新的 Master 路由器，从而继续向网络内的主机提供路由服务，最终实现了路由功能的高可用。</description></item><item><title>DHCP</title><link>https://desistdaydream.github.io/docs/4.%E6%95%B0%E6%8D%AE%E9%80%9A%E4%BF%A1/Protocol/DHCP/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/4.%E6%95%B0%E6%8D%AE%E9%80%9A%E4%BF%A1/Protocol/DHCP/</guid><description>概述 参考：
Wiki, DHCP Dynamic Host Configuration Protocol(动态主机设置协议，简称 DHCP) 主要用于由一部主机来自动的分配所有的网络参数给指定网段内的所有设备。
DHCP 可以分配的网络参数有 IP 地址、掩码、网关、DNS 等
DHCP 的运作方式： 他主要由客户端发送广播包给整个物理网段内的所有主机， 若该网段内有 DHCP 服务器时，就会响应客户端的 DHCP 请求。所以，DHCP 服务器与客户端是应该要在同一个物理网段内的，如果想跨网段提供 DHCP 服务，需要在对应网段启用 dhcrelay 服务。
至于整个 DHCP 封包在服务器与客户端的来来回回情况如右图，具体有 4 个步骤
DISCOVER(发现) # 客户端利用广播封包发送搜索 DHCP 服务器的封包： 若客户端网络设定使用 DHCP 协议取得 IP (在 Windows 内为『自动取得 IP』)，则当客户端开机或者是重新启动网络卡时， 客户端主机会发送出搜寻 DHCP 服务器的 UDP 封包给所有物理网段内的计算机。此封包的目标 IP 会是 255.255.255.255， 所以一般主机接收到这个封包后会直接予以丢弃，但若局域网络内有 DHCP 服务器时，则会开始进行后续行为。 OFFER(提供) # DHCP 服务端提供客户端网络相关的租约以供选择 DHCP 服务器在接收到这个客户端的要求后，会针对这个客户端的硬件地址 (MAC) 与本身的设定数据来进行下列工作： 到服务器的登录文件中寻找该用户之前是否曾经用过某个 IP ，若有且该 IP 目前无人使用，则提供此 IP 给客户端； 若配置文件针对该 MAC 提供额外的固定 IP (static IP) 时，则提供该固定 IP 给客户端； 若不符合上述两个条件，则随机取用目前没有被使用的 IP 参数给客户端，并记录下来。 总之，服务器端会针对客户端的要求提供一组网络参数租约给客户端选择，由于此时客户端尚未有 IP ，因此服务器端响应的封包信息中， 主要是针对客户端的 MAC 来给予回应。此时服务器端会保留这个租约然后开始等待客户端的回应。 REQUEST(请求) # 客户端决定选择的 DHCP 服务器提供的网络参数租约并回报服务器 由于局域网络内可能并非仅有一部 DHCP 服务器，但客户端仅能接受一组网络参数的租约。 因此客户端必需要选择是否要认可该服务器提供的相关网络参数的租约。当决定好使用此服务器的网络参数租约后， 客户端便开始使用这组网络参数来设定自己的网络环境。此外，客户端也会发送一个广播封包给所有物理网段内的主机， 告知已经接受该服务器的租约。此时若有第二台以上的 DHCP 服务器，则这些没有被接受的服务器会收回该 IP 租约。至于被接受的 DHCP 服务器会继续进行底下的动作。 Acknowledge(确认，ACK) # 服务端记录该次租约行为并回报客户端已确认的响应封包信息 - 当服务器端收到客户端的确认选择后，服务器会回传确认的响应封包，并且告知客户端这个网络参数租约的期限， 并且开始租约计时喔！那么该次租约何时会到期而被解约，可以这样想： - 客户端脱机：不论是关闭网络接口 (ifdown)、重新启动 (reboot)、关机 (shutdown) 等行为，皆算是脱机状态，这个时候 Server 端就会将该 IP 回收，并放到 Server 自己的备用区中，等待未来的使用； - 客户端租约到期：前面提到 DHCP server 端发放的 IP 有使用的期限，客户端使用这个 IP 到达期限规定的时间，而且没有重新提出 DHCP 的申请时，就需要将 IP 缴回去！这个时候就会造成断线。但用户也可以再向 DHCP 服务器要求再次分配 IP 啰。 这四个步骤也称为 DHCP 分配地址时的需要进行的 DORA 进程</description></item><item><title>FTP</title><link>https://desistdaydream.github.io/docs/4.%E6%95%B0%E6%8D%AE%E9%80%9A%E4%BF%A1/Protocol/FTP/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/4.%E6%95%B0%E6%8D%AE%E9%80%9A%E4%BF%A1/Protocol/FTP/</guid><description>概述 参考：
RFC 959, FILE TRANSFER PROTOCOL (FTP) Wiki, File_Transfer_Protocol File Transfer Protocol(文件传输协议，简称 FTP) 是因特网网络上历史最悠久的网络工具，从 1971 年由 A KBHUSHAN 提出第一个 FTP 的 RFC（RFC114）至今近半个世纪来，FTP 凭借其独特的优势一直都是因特网中最重要、最广泛的服务之一。
FTP 的目标是提高文件的共享性，提供非直接使用远程计算机，使存储介质对用户透明和可靠高效地传送数据。它能操作任何类型的文件而不需要进一步处理，就像 MIME 或 Unicode 一样。但是，FTP 有着极高的延时，这意味着，从开始请求到第一次接收需求数据之间的时间，会非常长；并且不时的必须执行一些冗长的登录进程。
SFTP 参考：
Wiki, SSH_File_Transfer_Protocol SSH File Transfer Protocol(SSH 文件传输协议，简称 SFTP) 也称为 Secure File Transfer Protocol(安全文件传输协议)，是一种网络协议，可通过任何可靠的数据流提供文件访问、文件传输和文件管理。它由 IETF 设计，作为 Secure Shell Protocol(SSH) 2.0 版的扩展，提供安全文件传输功能，并且由于卓越的安全性而被视为文件传输协议 (FTP) 的替代品。
IETF 互联网草案指出，尽管该协议是在 SSH-2 协议的上下文中描述的，但它可以用于许多不同的应用程序，例如通过传输层安全性 (TLS) 进行安全文件传输和管理传输VPN 应用程序中的信息。
该协议假定它在安全通道（例如 SSH）上运行，服务器已经对客户端进行了身份验证，并且客户端用户的身份可供该协议使用。
也就是说，想要使用 SFTP，通常是先建立安全的连接（e.g. SSH、etc.），然后基于该安全的连接实现 FTP 相关能力。
SFTP 不一定是通过 SSH 运行的 FTP（绝大部分都是通过 SSH），而是由 IETF SECSH 工作组从头开始设计的新协议。它有时会与简单文件传输协议混淆。</description></item><item><title>NTP</title><link>https://desistdaydream.github.io/docs/4.%E6%95%B0%E6%8D%AE%E9%80%9A%E4%BF%A1/Protocol/NTP/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/4.%E6%95%B0%E6%8D%AE%E9%80%9A%E4%BF%A1/Protocol/NTP/</guid><description>概述 参考：
Wiki, NTP Network Time Protocol(网络时间协议，简称 NTP) 是在数据网络潜伏时间可变的计算机系统之间通过分组交换进行时钟同步的一个网络通信协议，位于 OSI 模型的应用层。自 1985 年以来，NTP 是目前仍在使用的最古老的互联网协议之一。NTP 由特拉华大学的 David L. Mills 设计。
NTP 意图将所有参与计算机的协调世界时（UTC）时间同步到几毫秒的误差内。:3 它使用 Marzullo 算法的修改版来选择准确的时间服务器，其设计旨在减轻可变网络延迟造成的影响。NTP 通常可以在公共互联网保持几十毫秒的误差，并且在理想的局域网环境中可以实现超过 1 毫秒的精度。不对称路由和拥塞控制可能导致 100 毫秒（或更高）的错误。
该协议通常描述为一种主从式架构，但它也可以用在点对点网络中，对等体双方可将另一端认定为潜在的时间源。:20 发送和接收时间戳采用用户数据报协议（UDP）的端口 123 实现。这也可以使用广播或多播，其中的客户端在最初的往返校准交换后被动地监听时间更新。]NTP 提供一个即将到来闰秒调整的警告，但不会传输有关本地时区或夏时制的信息。
当前协议为版本 4（NTPv4），这是一个 RFC 5905 文档中的建议标准。它向下兼容指定于 RFC 1305 的版本 3。
NTP 的设计者 David L. Mills。
1979 年，网络时间同步技术在纽约的国家计算机会议上于运行在跨大西洋卫星网络的互联网服务上公开演示，这可能是该技术的首次公开演示。该技术后在 1981 年互联网工程笔记（IEN）173 中描述，并根据 RFC 778 文档开发为一个公开协议。该技术首先被部署在一个本地网络，作为 Hello 路由协议的一部分，并在 Fuzzball（一个用于网络原型的实验操作系统，已运行多年）中实现。
现在还有其他的相关网络工具。这包括 Daytime 和 Time 协议用以记录事件时间，以及互联网控制消息协议和 IP 时间戳选项（RFC 781）。更多完整的同步系统，虽然缺乏 NTP 的数据分析和时钟规律算法，包括 Unix 守护进程 timed 在内的软件其使用选举算法为所有客户端指定服务器。以及数字时间同步服务（Digital Time Synchronization Service，DTSS）使用类似构 NTP 阶层模型的服务器层次结构。</description></item><item><title>RTSP</title><link>https://desistdaydream.github.io/docs/4.%E6%95%B0%E6%8D%AE%E9%80%9A%E4%BF%A1/Protocol/RTSP/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/4.%E6%95%B0%E6%8D%AE%E9%80%9A%E4%BF%A1/Protocol/RTSP/</guid><description>概述 参考：
Wiki, Real_Time_Streaming_Protocol Real Time Streaming Protocol(实时流协议，简称 RTSP) 是一种网络应用协议，专为娱乐和通信系统的使用，以控制流媒体服务器。</description></item><item><title>Secure Shell Protocol</title><link>https://desistdaydream.github.io/docs/4.%E6%95%B0%E6%8D%AE%E9%80%9A%E4%BF%A1/Protocol/Secure-Shell-Protocol/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/4.%E6%95%B0%E6%8D%AE%E9%80%9A%E4%BF%A1/Protocol/Secure-Shell-Protocol/</guid><description>概述 参考：
Wiki, Secure_Shell_Protocol https://www.digitalocean.com/community/tutorials/how-to-set-up-ssh-keys-on-centos-8 Secure Shell Protocol(安全外壳协议，简称 SSH) 是一种加密的通信协议，可在不安全的网络中为网络服务提供安全的传输环境。SSH 通过在网络中创建安全隧道来实现 SSH 客户端与服务器之间的连接。虽然任何网络服务都可以通过 SSH 实现安全传输，SSH 最常见的用途是远程登录系统，人们通常利用 SSH 来传输命令行界面和远程执行命令。使用频率最高的场合类 Unix 系统，但是 Windows 操作系统也能有限度地使用 SSH。2015 年，微软宣布将在未来的操作系统中提供原生 SSH 协议支持，Windows 10 1809 版本已提供可手动安装的 OpenSSH 工具
SSH 的实现 OpenSSH
Go 语言的 SSH 实现
https://github.com/search?q=sshd+language%3AGo&amp;ref=opensearch&amp;type=repositories GitHub 项目，jpillora/sshd-lite 对应博客 https://blog.gopheracademy.com/go-and-ssh/ https://github.com/nwtgck/handy-sshd https://github.com/Matir/sshdog 其他 https://github.com/shazow/ssh-chat</description></item><item><title>SSDP</title><link>https://desistdaydream.github.io/docs/4.%E6%95%B0%E6%8D%AE%E9%80%9A%E4%BF%A1/Protocol/SSDP/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/4.%E6%95%B0%E6%8D%AE%E9%80%9A%E4%BF%A1/Protocol/SSDP/</guid><description>概述 参考：
-Wiki, Simple_Service_Discovery_Protocol
Simple Service Discovery Protocol(简单服务发现协议，简称 SSDP) 是一种基于 TCP_IP
SSDP 使用 239.255.255.250 组播地址
SSDP 是 UPnP 技术的基础。</description></item><item><title>其他</title><link>https://desistdaydream.github.io/docs/4.%E6%95%B0%E6%8D%AE%E9%80%9A%E4%BF%A1/Protocol/%E5%85%B6%E4%BB%96/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/4.%E6%95%B0%E6%8D%AE%E9%80%9A%E4%BF%A1/Protocol/%E5%85%B6%E4%BB%96/</guid><description>概述 参考：
Telnet 参考：
RFC 854 - TELNET PROTOCOL SPECIFICATION RFC 855 - TELNET OPTION SPECIFICATIONS RFC 857 - TELNET ECHO OPTION RFC 858 - TELNET SUPPRESS GO AHEAD OPTION RFC 1091 - Telnet Terminal-Type Option RFC 1143 - The Q Method of Implementing TELNET Option Negotiation Wiki, Telnet Python Telnet 库
https://docs.python.org/3/library/telnetlib.html 已弃用，将在 3.13 删除
Go Telnet 库
https://github.com/ebarkie/telnet 可以实现 Telnet 服务端
https://github.com/reiver/go-telnet
https://blog.csdn.net/wangkai_123456/article/details/70167943
Telnet 仅仅是基于 TCP 的类似 Echo 逻辑，建立 TCP 连接后，Telnet 服务端需要与客户端协商一些内容，</description></item><item><title>WebDAV</title><link>https://desistdaydream.github.io/docs/4.%E6%95%B0%E6%8D%AE%E9%80%9A%E4%BF%A1/Protocol/WebDAV/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/4.%E6%95%B0%E6%8D%AE%E9%80%9A%E4%BF%A1/Protocol/WebDAV/</guid><description>概述 参考：
Wiki, WebDAV RFC 4918， HTTP Extensions for Web Distributed Authoring and Versioning (WebDAV) https://www.zhihu.com/question/30719209 Web Distributed Authoring and Versioning(Web 分布式创作和版本控制，简称 WebDAV) 是 HTTP 的一组扩展，它允许用户代理通过提供并发控制和命名空间操作的设施，直接在 HTTP Web 服务器 中协作创作内容，从而允许 Web 被视为一种 可写的、协作的 媒体，而不仅仅是一种只读媒体。WebDAV 定义在 RFC 4918 中
当我们使用符合 WebDAV 标准的程序部署了服务端之后，通过客户端，就可以使用 HTTP 协议访问服务端
应用示例 通过 WebDAV，可以将互联网上的网盘提供商，将自身的网盘，挂载到操作系统上，作为一个盘符
HTTP 协议定义了几种请求: GET, POST,PUT 等用来下载文件上传数据。WebDAV 在标准的 HTTP 协议上扩展了特有的请求方式: PROPFIND, MOVE, COPY 等。 然后用这些请求，操作 web 服务器上的磁盘(像不像一个网盘！！！)
注意: 在 Nginx 等代理后面的 WebDAV 无法执行那些扩展的请求方式，比如 MOVE 等，实际情况是重命名时将会报错 Dir.Rename error: DirMove MOVE call failed: Bad Gateway: 502 Bad Gateway，可能是因为 Nginx 不支持，具体应该如何配置解决这个问题的方法还没找到。</description></item></channel></rss>