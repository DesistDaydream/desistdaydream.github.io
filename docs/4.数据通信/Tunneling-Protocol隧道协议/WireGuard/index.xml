<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>断念梦 – WireGuard</title><link>https://desistdaydream.github.io/docs/4.%E6%95%B0%E6%8D%AE%E9%80%9A%E4%BF%A1/Tunneling-Protocol%E9%9A%A7%E9%81%93%E5%8D%8F%E8%AE%AE/WireGuard/</link><description>Recent content in WireGuard on 断念梦</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><atom:link href="https://desistdaydream.github.io/docs/4.%E6%95%B0%E6%8D%AE%E9%80%9A%E4%BF%A1/Tunneling-Protocol%E9%9A%A7%E9%81%93%E5%8D%8F%E8%AE%AE/WireGuard/index.xml" rel="self" type="application/rss+xml"/><item><title>Docs: WireGuard</title><link>https://desistdaydream.github.io/docs/4.%E6%95%B0%E6%8D%AE%E9%80%9A%E4%BF%A1/Tunneling-Protocol%E9%9A%A7%E9%81%93%E5%8D%8F%E8%AE%AE/WireGuard/WireGuard/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/4.%E6%95%B0%E6%8D%AE%E9%80%9A%E4%BF%A1/Tunneling-Protocol%E9%9A%A7%E9%81%93%E5%8D%8F%E8%AE%AE/WireGuard/WireGuard/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://www.wireguard.com/">官网&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://github.com/WireGuard/wireguard-linux">GitHub 项目，WrieGuard/wireguard-linux&lt;/a>
&lt;ul>
&lt;li>&lt;a href="https://git.zx2c4.com/wireguard-linux/tree/drivers/net/wireguard/">zx2c4 源码&lt;/a>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/WireGuard">Wiki,WireGuard&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://blog.ipfire.org/post/why-not-wireguard">IPFire 博客，Why Not WireGuard&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://fuckcloudnative.io/posts/wireguard-docs-theory/">米开朗基杨博客，WireGuard 教程：WireGuard 的工作原理&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://zhangguanzhang.github.io/2020/08/05/wireguard-for-personal/">张馆长博客，个人办公用 wireguard 组网笔记&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>WireGuard 是一种可以实现加密 VPN 的通信协议。通常也表示为实现该通信协议的软件。&lt;/p>
&lt;p>WireGuard 是由 Jason Donenfeld 等人用 C 语言编写的一个开源 VPN 协议，被视为下一代 VPN 协议，旨在解决许多困扰 IPSec/IKEv2、OpenVPN 或 L2TP 等其他 VPN 协议的问题。它与 Tinc 和 MeshBird 等现代 VPN 产品有一些相似之处，即加密技术先进、配置简单。从 2020 年 1 月开始，它已经并入了 Linux 内核的 5.6 版本，这意味着大多数 Linux 发行版的用户将拥有一个开箱即用的 WireGuard。&lt;/p>
&lt;p>WireGuard 没有传统的 Server 端、Client 端的概念，在 WireGuard 构建的 VPN 环境中，使用 &lt;strong>Peer&lt;/strong> 来描述 VPN 中的每一个网络节点，这个 Peer 可以是 服务器、路由器 等等。通常来说，一个具有固定公网 IP 的 Peer，非官方得称为 &lt;strong>Bounce Server/Relay Server(弹跳服务器/中继服务器)&lt;/strong>。各个在 NAT 后面的 Peer，可以通过 Bounce Server 这个 Peer 直接互通。&lt;/p>
&lt;h1 id="待整理文章内容">待整理文章内容&lt;/h1>
&lt;p>WireGuard 与其他 VPN 协议的性能测试对比：
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/kpbis3/1616160904902-4ab1975e-fa98-4b9e-b63b-775e63fa1828.jpeg" alt="">
可以看到 WireGuard 直接碾压其他 VPN 协议。再来说说 OpenVPN，大约有 10 万行代码，而 WireGuard 只有大概 4000 行代码，代码库相当精简，简直就是件艺术品啊。你再看看 OpenVPN 的性能，算了不说了。&lt;/p>
&lt;p>WireGuard 优点：&lt;/p>
&lt;ul>
&lt;li>配置精简，可直接使用默认值&lt;/li>
&lt;li>只需最少的密钥管理工作，每个主机只需要 1 个公钥和 1 个私钥。&lt;/li>
&lt;li>就像普通的以太网接口一样，以 Linux 内核模块的形式运行，资源占用小。&lt;/li>
&lt;li>能够将部分流量或所有流量通过 VPN 传送到局域网内的任意主机。&lt;/li>
&lt;li>能够在网络故障恢复之后自动重连，戳到了其他 VPN 的痛处。&lt;/li>
&lt;li>比目前主流的 VPN 协议，连接速度要更快，延迟更低（见上图）。&lt;/li>
&lt;li>使用了更先进的加密技术，具有前向加密和抗降级攻击的能力。&lt;/li>
&lt;li>支持任何类型的二层网络通信，例如 ARP、DHCP 和 ICMP，而不仅仅是 TCP/HTTP。&lt;/li>
&lt;li>可以运行在主机中为容器之间提供通信，也可以运行在容器中为主机之间提供通信。&lt;/li>
&lt;/ul>
&lt;p>WireGuard 不能做的事：&lt;/p>
&lt;ul>
&lt;li>类似 gossip 协议实现网络自愈。&lt;/li>
&lt;li>通过信令服务器突破双重 NAT。&lt;/li>
&lt;li>通过中央服务器自动分配和撤销密钥。&lt;/li>
&lt;li>发送原始的二层以太网帧。&lt;/li>
&lt;/ul>
&lt;p>当然，你可以使用 WireGuard 作为底层协议来实现自己想要的功能，从而弥补上述这些缺憾。&lt;/p>
&lt;p>本系列 WireGuard 教程分为两个部分，第一部分偏理论，第二部分偏实践。本文是第一部分，下面开始正文教程。&lt;/p>
&lt;ol>
&lt;li>WireGuard 术语&lt;/li>
&lt;/ol>
&lt;p>Peer/Node/Device&lt;/p>
&lt;p>连接到 VPN 并为自己注册一个 VPN 子网地址（如 192.0.2.3）的主机。还可以通过使用逗号分隔的 CIDR 指定子网范围，为其自身地址以外的 IP 地址选择路由。&lt;/p>
&lt;p>中继服务器（Bounce Server）&lt;/p>
&lt;p>一个公网可达的对等节点，可以将流量中继到 NAT 后面的其他对等节点。Bounce Server 并不是特殊的节点，它和其他对等节点一样，唯一的区别是它有公网 IP，并且开启了内核级别的 IP 转发，可以将 VPN 的流量转发到其他客户端。&lt;/p>
&lt;p>子网（Subnet）&lt;/p>
&lt;p>一组私有 IP，例如 192.0.2.1-255 或 192.168.1.1/24，一般在 NAT 后面，例如办公室局域网或家庭网络。&lt;/p>
&lt;p>CIDR 表示法&lt;/p>
&lt;p>这是一种使用掩码表示子网大小的方式，这个不用解释了。&lt;/p>
&lt;p>NAT&lt;/p>
&lt;p>子网的私有 IP 地址由路由器提供，通过公网无法直接访问私有子网设备，需要通过 NAT 做网络地址转换。路由器会跟踪发出的连接，并将响应转发到正确的内部 IP。&lt;/p>
&lt;p>公开端点（Public Endpoint）&lt;/p>
&lt;p>节点的公网 IP 地址:端口，例如 123.124.125.126:1234，或者直接使用域名 some.domain.tld:1234。如果对等节点不在同一子网中，那么节点的公开端点必须使用公网 IP 地址。&lt;/p>
&lt;p>私钥（Private key）&lt;/p>
&lt;p>单个节点的 WireGuard 私钥，生成方法是：wg genkey &amp;gt; example.key。&lt;/p>
&lt;p>公钥（Public key）&lt;/p>
&lt;p>单个节点的 WireGuard 公钥，生成方式为：wg pubkey &amp;lt; example.key &amp;gt; example.key.pub。&lt;/p>
&lt;p>DNS&lt;/p>
&lt;p>域名服务器，用于将域名解析为 VPN 客户端的 IP，不让 DNS 请求泄漏到 VPN 之外。&lt;/p>
&lt;ol start="2">
&lt;li>WireGuard 工作原理&lt;/li>
&lt;/ol>
&lt;p>中继服务器工作原理&lt;/p>
&lt;p>中继服务器（Bounce Server）和普通的对等节点一样，它能够在 NAT 后面的 VPN 客户端之间充当中继服务器，可以将收到的任何 VPN 子网流量转发到正确的对等节点。事实上 WireGuard 并不关心流量是如何转发的，这个由系统内核和 iptables 规则处理。&lt;/p>
&lt;p>如果所有的对等节点都是公网可达的，则不需要考虑中继服务器，只有当有对等节点位于 NAT 后面时才需要考虑。&lt;/p>
&lt;p>在 WireGuard 里，客户端和服务端基本是平等的，差别只是谁主动连接谁而已。双方都会监听一个 UDP 端口，谁主动连接，谁就是客户端。主动连接的客户端需要指定对端的公网地址和端口，被动连接的服务端不需要指定其他对等节点的地址和端口。如果客户端和服务端都位于 NAT 后面，需要加一个中继服务器，客户端和服务端都指定中继服务器作为对等节点，它们的通信流量会先进入中继服务器，然后再转发到对端。&lt;/p>
&lt;p>WireGuard 是支持漫游的，也就是说，双方不管谁的地址变动了，WireGuard 在看到对方从新地址说话的时候，就会记住它的新地址（跟 mosh 一样，不过是双向的）。所以双方要是一直保持在线，并且通信足够频繁的话（比如配置 persistent-keepalive），两边的 IP 都不固定也不影响的。&lt;/p>
&lt;p>Wireguard 如何路由流量&lt;/p>
&lt;p>利用 WireGuard 可以组建非常复杂的网络拓扑，这里主要介绍几个典型的拓扑：&lt;/p>
&lt;p>① 端到端直接连接&lt;/p>
&lt;p>这是最简单的拓扑，所有的节点要么在同一个局域网，要么直接通过公网访问，这样 WireGuard 可以直接连接到对端，不需要中继跳转。&lt;/p>
&lt;p>② 一端位于 NAT 后面，另一端直接通过公网暴露&lt;/p>
&lt;p>这种情况下，最简单的方案是：通过公网暴露的一端作为服务端，另一端指定服务端的公网地址和端口，然后通过 persistent-keepalive 选项维持长连接，让 NAT 记得对应的映射关系。&lt;/p>
&lt;p>③ 两端都位于 NAT 后面，通过中继服务器连接&lt;/p>
&lt;p>大多数情况下，当通信双方都在 NAT 后面的时候，NAT 会做源端口随机化处理，直接连接可能比较困难。可以加一个中继服务器，通信双方都将中继服务器作为对端，然后维持长连接，流量就会通过中继服务器进行转发。&lt;/p>
&lt;p>④ 两端都位于 NAT 后面，通过 UDP NAT 打洞&lt;/p>
&lt;p>上面也提到了，当通信双方都在 NAT 后面的时候，直接连接不太现实，因为大多数 NAT 路由器对源端口的随机化相当严格，不可能提前为双方协调一个固定开放的端口。必须使用一个信令服务器（STUN），它会在中间沟通分配给对方哪些随机源端口。通信双方都会和公共信令服务器进行初始连接，然后它记录下随机的源端口，并将其返回给客户端。这其实就是现代 P2P 网络中 WebRTC 的工作原理。有时候，即使有了信令服务器和两端已知的源端口，也无法直接连接，因为 NAT 路由器严格规定只接受来自原始目的地址（信令服务器）的流量，会要求新开一个随机源端口来接受来自其他 IP 的流量（比如其他客户端试图使用原来的通信源端口）。运营商级别的 NAT 就是这么干的，比如蜂窝网络和一些企业网络，它们专门用这种方法来防止打洞连接。更多细节请参考下一部分的 NAT 到 NAT 连接实践的章节。&lt;/p>
&lt;p>如果某一端同时连接了多个对端，当它想访问某个 IP 时，如果有具体的路由可用，则优先使用具体的路由，否则就会将流量转发到中继服务器，然后中继服务器再根据系统路由表进行转发。你可以通过测量 ping 的时间来计算每一跳的长度，并通过检查对端的输出（wg show wg0）来找到 WireGuard 对一个给定地址的路由方式。&lt;/p>
&lt;p>WireGuard 报文格式&lt;/p>
&lt;p>WireGuard 使用加密的 UDP 报文来封装所有的数据，UDP 不保证数据包一定能送达，也不保证按顺序到达，但隧道内的 TCP 连接可以保证数据有效交付。WireGuard 的报文格式如下图所示：
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/kpbis3/1616160904918-24e86676-6f0a-4804-8669-45d68a22e23d.jpeg" alt="">
关于 WireGuard 报文的更多信息可以参考下面几篇文档：&lt;/p>
&lt;ul>
&lt;li>wireshark.org/docs/dfref/w/wg.html[1]&lt;/li>
&lt;li>Lekensteyn/wireguard-dissector[2]&lt;/li>
&lt;li>nbsoftsolutions.com/blog/viewing-wireguard-traffic-with-tcpdump[3]&lt;/li>
&lt;/ul>
&lt;p>WireGuard 的性能&lt;/p>
&lt;p>WireGuard 声称其性能比大多数 VPN 协议更好，但这个事情有很多争议，比如某些加密方式支持硬件层面的加速。&lt;/p>
&lt;p>WireGuard 直接在内核层面处理路由，直接使用系统内核的加密模块来加密数据，和 Linux 原本内置的密码子系统共存，原有的子系统能通过 API 使用 WireGuard 的 Zinc 密码库。WireGuard 使用 UDP 协议传输数据，在不使用的情况下默认不会传输任何 UDP 数据包，所以比常规 VPN 省电很多，可以像 55 一样一直挂着使用，速度相比其他 VPN 也是压倒性优势。
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/kpbis3/1616160904933-319867cc-3391-4d97-bf43-e8c40786c553.jpeg" alt="">
关于性能比较的更多信息可以参考下面几篇文档：&lt;/p>
&lt;ul>
&lt;li>wireguard.com/performance[4]&lt;/li>
&lt;li>reddit.com/r/linux/comments/9bnowo/wireguard_benchmark_between_two_servers_with_10[5]&lt;/li>
&lt;li>restoreprivacy.com/openvpn-ipsec-wireguard-l2tp-ikev2-protocols[6]&lt;/li>
&lt;/ul>
&lt;p>WireGuard 安全模型
WireGuard 使用以下加密技术来保障数据的安全：&lt;/p>
&lt;ul>
&lt;li>使用 ChaCha20 进行对称加密，使用 Poly1305 进行数据验证。&lt;/li>
&lt;li>利用 Curve25519 进行密钥交换。&lt;/li>
&lt;li>使用 BLAKE2 作为哈希函数。&lt;/li>
&lt;li>使用 HKDF 进行解密。&lt;/li>
&lt;/ul>
&lt;p>WireGuard 的加密技术本质上是 Trevor Perrin 的 Noise 框架的实例化，它简单高效，其他的 VPN 都是通过一系列协商、握手和复杂的状态机来保障安全性。WireGuard 就相当于 VPN 协议中的 qmail，代码量比其他 VPN 协议少了好几个数量级。&lt;/p>
&lt;p>关于 WireGuard 加密的更多资料请参考下方链接：&lt;/p>
&lt;ul>
&lt;li>wireguard.com/papers/wireguard.pdf[7]&lt;/li>
&lt;li>eprint.iacr.org/2018/080.pdf[8]&lt;/li>
&lt;li>courses.csail.mit.edu/6.857/2018/project/He-Xu-Xu-WireGuard.pdf[9]&lt;/li>
&lt;li>wireguard.com/talks/blackhat2018-slides.pdf[10]&lt;/li>
&lt;li>arstechnica.com/gadgets/2018/08/wireguard-vpn-review-fast-connections-amaze-but-windows-support-needs-to-happen[11]&lt;/li>
&lt;/ul>
&lt;p>WireGuard 密钥管理
WireGuard 通过为每个对等节点提供简单的公钥和私钥来实现双向认证，每个对等节点在设置阶段生成密钥，且只在对等节点之间共享密钥。每个节点除了公钥和私钥，不再需要其他证书或预共享密钥。&lt;/p>
&lt;p>在更大规模的部署中，可以使用 Ansible 或 Kubernetes Secrets 等单独的服务来处理密钥的生成、分发和销毁。&lt;/p>
&lt;p>下面是一些有助于密钥分发和部署的服务：&lt;/p>
&lt;ul>
&lt;li>pypi.org/project/wireguard-p2p[12]&lt;/li>
&lt;li>trailofbits/algo[13]&lt;/li>
&lt;li>StreisandEffect/streisand[14]&lt;/li>
&lt;li>its0x08/wg-install[15]&lt;/li>
&lt;li>brittson/wireguard_config_maker[16]&lt;/li>
&lt;li>wireguardconfig.com[17]&lt;/li>
&lt;/ul>
&lt;p>如果你不想在 wg0.conf 配置文件中直接硬编码，可以从文件或命令中读取密钥，这使得通过第三方服务管理密钥变得更加容易：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">[&lt;/span>Interface&lt;span style="color:#f92672">]&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>...
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>PostUp &lt;span style="color:#f92672">=&lt;/span> wg set %i private-key /etc/wireguard/wg0.key &amp;lt;&lt;span style="color:#f92672">(&lt;/span>cat /some/path/%i/privkey&lt;span style="color:#f92672">)&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>从技术上讲，多个服务端之间可以共享相同的私钥，只要客户端不使用相同的密钥同时连接到两个服务器。但有时客户端会需要同时连接多台服务器，例如，你可以使用 DNS 轮询来均衡两台服务器之间的连接，这两台服务器配置相同。大多数情况下，每个对等节点都应该使用独立的的公钥和私钥，这样每个对等节点都不能读取到对方的流量，保障了安全性。&lt;/p>
&lt;p>理论部分就到这里，下篇文章将会手把手教你如何从零开始配置 WireGuard，这里会涉及到很多高级的配置方法，例如动态 IP、NAT 到 NAT、IPv6 等等。&lt;/p>
&lt;h2 id="高级特性">高级特性&lt;/h2>
&lt;h3 id="ipv6">IPv6&lt;/h3>
&lt;p>前面的例子主要使用 &lt;code>IPv4&lt;/code>，WireGuard 也支持 &lt;code>IPv6&lt;/code>。例如：&lt;/p>
&lt;pre>&lt;code>[Interface]
AllowedIps = 192.0.2.3/24, 2001:DB8::/64
[Peer]
...
AllowedIPs = 0.0.0.0/0, ::/0
&lt;/code>&lt;/pre>
&lt;h3 id="转发所有流量">转发所有流量&lt;/h3>
&lt;p>如果你想通过 VPN 转发所有的流量，包括 VPN 子网和公网流量，需要在 &lt;code>[Peer]&lt;/code> 的 &lt;code>AllowedIPs&lt;/code> 中添加 &lt;code>0.0.0.0/0, ::/0&lt;/code>。
即便只转发 &lt;code>IPv4&lt;/code> 流量，也要指定一个 &lt;code>IPv6&lt;/code> 网段，以避免将 &lt;code>IPv6&lt;/code> 数据包泄露到 VPN 之外。详情参考：&lt;strong>reddit.com/r/WireGuard/comments/b0m5g2/ipv6_leaks_psa_for_anyone_here_using_wireguard_to&lt;/strong>[5]
例如：&lt;/p>
&lt;pre>&lt;code>[Interface]
# Name = phone.example-vpn.dev
Address = 192.0.2.3/32
PrivateKey = &amp;lt;private key for phone.example-vpn.dev&amp;gt;
[Peer]
# Name = public-server1.example-vpn.dev
PublicKey = &amp;lt;public key for public-server1.example-vpn.dev&amp;gt;
Endpoint = public-server1.example-vpn.dev:51820
AllowedIPs = 0.0.0.0/0, ::/0
&lt;/code>&lt;/pre>
&lt;p>一般只有把 VPN 当做武当纵云梯来用时，才会需要转发所有流量，不多说，点到为止。&lt;/p>
&lt;h3 id="nat-to-nat-连接">NAT-to-NAT 连接&lt;/h3>
&lt;p>如果两个对等节点（peer）都位于 NAT 后面，想不通过中继服务器直接连接，需要保证至少有一个对等节点（peer）具有稳定的公网出口，使用静态公网 IP 或者通过 &lt;code>DDNS&lt;/code> 动态更新 &lt;code>FQDN&lt;/code> 都可以。
&lt;code>WebRTC&lt;/code> 协议可以动态配置两个 NAT 之间的连接，它可以通过信令服务器来检测每个主机的 &lt;code>IP:Port&lt;/code> 组合。而 WireGuard 没有这个功能，它没有没有信令服务器来动态搜索其他主机，只能硬编码 &lt;code>Endpoint+ListenPort&lt;/code>，并通过 &lt;code>PersistentKeepalive&lt;/code> 来维持连接。
总结一下 NAT-to-NAT 连接的前提条件：&lt;/p>
&lt;ul>
&lt;li>至少有一个对等节点（peer）有固定的公网 IP，如果都没有固定的公网 IP，也可以使用 &lt;code>DDNS&lt;/code> 来维护一个稳定的域名。&lt;/li>
&lt;li>至少有一个对等节点（peer）指定 UDP &lt;code>ListenPort&lt;/code>，而且它的 NAT 路由器不能做 UDP 源端口随机化，否则返回的数据包将被发送到之前指定的 &lt;code>ListenPort&lt;/code>，并被路由器丢弃，不会发送到新分配的随机端口。&lt;/li>
&lt;li>所有的对等节点（peer）必须在 &lt;code>[Peer]&lt;/code> 配置中启用其他对等节点（peer）的 &lt;code>PersistentKeepalive&lt;/code>，这样就可以维持连接的持久性。&lt;/li>
&lt;/ul>
&lt;p>对于通信双方来说，只要&lt;strong>服务端&lt;/strong>所在的 NAT 路由器没有指定到 NAT 后面的对等节点（peer）的转发规则，就需要进行 UDP 打洞。
UDP 打洞的原理：&lt;/p>
&lt;ol>
&lt;li>&lt;code>Peer1&lt;/code> 向 &lt;code>Peer2&lt;/code> 发送一个 UDP 数据包，不过 &lt;code>Peer2&lt;/code> 的 NAT 路由器不知道该将这个包发给谁，直接丢弃了，不过没关系，这一步的目的是让 &lt;code>Peer1&lt;/code> 的 NAT 路由器能够接收 UDP 响应并转发到后面的 &lt;code>Peer1&lt;/code>。&lt;/li>
&lt;li>&lt;code>Peer2&lt;/code> 向 &lt;code>Peer1&lt;/code> 发送一个 UDP 数据包，由于上一步的作用，&lt;code>Peer1&lt;/code> 的 NAT 路由器已经建立临时转发规则，可以接收 UDP 响应，所以可以接收到该数据包，并转发到 &lt;code>Peer1&lt;/code>。&lt;/li>
&lt;li>&lt;code>Peer1&lt;/code> 向 &lt;code>Peer2&lt;/code> 发送一个 UDP 响应，由于上一步的作用，由于上一步的作用，&lt;code>Peer2&lt;/code> 的 NAT 路由器已经可以接收 UDP 响应，所以可以接收到该数据包，并转发到 &lt;code>Peer2&lt;/code>。&lt;/li>
&lt;/ol>
&lt;p>&lt;strong>这种发送一个初始的数据包被拒绝，然后利用路由器已建立的转发规则来接收响应的过程被称为 『UDP 打洞』。&lt;/strong>
当你发送一个 UDP 数据包出去时，路由器通常会创建一个临时规则来映射源地址/端口和目的地址/端口，反之亦然。从目的地址和端口返回的 UDP 数据包会被转发到原来的源地址和端口，这就是大多数 UDP 应用在 NAT 后面的运作方式（如 BitTorrent、Skype 等）。这个临时规则会在一段时间后失效，所以 NAT 后面的客户端必须通过 &lt;code>PersistentKeepalive&lt;/code> 定期发送数据包来维持连接的持久性。
当两个对等节点（peer）都位于 NAT 后面时，要想让 UDP 打洞生效，需要两个节点在差不多的时间向对方发送数据包，这就意味着双方需要提前知道对方的公网地址和端口号，可以在 &lt;code>wg0.conf&lt;/code> 中指定。&lt;/p>
&lt;h4 id="udp-打洞的局限性">UDP 打洞的局限性&lt;/h4>
&lt;p>从 2019 年开始，很多以前用过的老式打洞方法都不再有效了。以前很著名的就是 &lt;strong>pwnat&lt;/strong>[6] 开创的一种新的打洞方法，它能够在不需要代理、第三方服务器、upnp、DMZ、sproofing、dns 转换的情况下实现 NAT 中的 P2P 通信。它的原理也很简单：
通过让客户端假装成为一个互联网上任意的 &lt;code>ICMP&lt;/code> 跳跃点（ a random hop on the Internet）来解决这个问题，从而让服务端能够获取到客户端的 IP 地址。&lt;code>traceroute&lt;/code> 命令也是使用这项技术来检测 Internet 上的跳跃点。
具体来说，当服务器启动时，它开始向固定地址 &lt;code>3.3.3.3&lt;/code> 发送固定的 &lt;strong>ICMP 回应请求包&lt;/strong>（ICMP echo request packets）。显然，我们无法从 &lt;code>3.3.3.3&lt;/code> 收到返回的 &lt;strong>ICMP 回应数据包&lt;/strong>（ICMP echo packets）。然而，&lt;code>3.3.3.3&lt;/code> 并不是我们可以访问的主机，我们也不是想伪装成它来发 ICMP 回应数据包。相反，pwnat 技术的实现原理在于，当我们的客户端想要连接服务端时，客户端（知道服务器 IP 地址）会向服务端送 &lt;strong>ICMP 超时数据包&lt;/strong>（ICMP Time Exceeded packet）。这个 ICMP 数据包里面包含了服务端发送到 &lt;code>3.3.3.3&lt;/code> 的原始固定 &lt;strong>ICMP 回应请求包&lt;/strong>。
为什么要这样做呢？好吧，我们假装是互联网上的一个 ICMP 跳越点，礼貌地告诉服务器它原来的 &lt;strong>ICMP 回应请求包&lt;/strong>无法传递到 &lt;code>3.3.3.3&lt;/code>。而你的 NAT 是一个聪明的设备，它会注意到 &lt;strong>ICMP 超时数据包&lt;/strong>内的数据包与服务器发出 &lt;strong>ICMP 回应请求包&lt;/strong>相匹配。然后它将 &lt;strong>ICMP 超时数据包&lt;/strong>转发回 NAT 后面的服务器，包括来自客户端的完整 IP 数据包头，从而让服务端知道客户端 IP 地址是什么！
现在这种类似的 UDP 打洞方法受到了很多的限制，详情可以参考&lt;a href="http://mp.weixin.qq.com/s?__biz=MzU1MzY4NzQ1OA==&amp;amp;mid=2247485991&amp;amp;idx=1&amp;amp;sn=b1a79b565e82ca034ae2c2b2bd9e3bcb&amp;amp;chksm=fbee4aeacc99c3fc0cf45c8ae9a84beb44874383cf337e284083cc81abaf23cbcf65ab58ea39&amp;amp;scene=21#wechat_redirect">上篇文章&lt;/a>，这里不过多阐述。除了 UDP 打洞之外，我们仍然可以使用硬编码的方式指定两个对等节点（peer）的公网地址和端口号，这个方法对大多数 NAT 网络都有效。&lt;/p>
&lt;h4 id="源端口随机化">源端口随机化&lt;/h4>
&lt;p>如果所有的对等节点（peer）都在具有严格的 UDP 源端口随机化的 NAT 后面（比如大多数蜂窝网络），那么无法实现 &lt;code>NAT-to-NAT&lt;/code> 连接。因为双方都无法协商出一个 &lt;code>ListenPort&lt;/code>，并保证自己的 NAT 在发出 ping 包后能够接收发往该端口的流量，所以就无法初始化打洞，导致连接失败。因此，一般在 &lt;code>LTE/3G&lt;/code> 网络中无法进行 p2p 通信。&lt;/p>
&lt;h4 id="使用信令服务器">使用信令服务器&lt;/h4>
&lt;p>上节提到了，如果所有的对等节点（peer）都在具有严格的 UDP 源端口随机化的 NAT 后面，就无法直接实现 &lt;code>NAT-to-NAT&lt;/code> 连接，但通过第三方的信令服务器是可以实现的。信令服务器相当于一个中转站，它会告诉通信双方关于对方的 &lt;code>IP:Port&lt;/code> 信息。这里有几个项目可以参考：&lt;/p>
&lt;ul>
&lt;li>&lt;strong>takutakahashi/wg-connect&lt;/strong>[7]&lt;/li>
&lt;li>&lt;strong>git.zx2c4.com/wireguard-tools/tree/contrib/nat-hole-punching&lt;/strong>[8]&lt;/li>
&lt;/ul>
&lt;h4 id="动态-ip-地址">动态 IP 地址&lt;/h4>
&lt;p>WireGuard 只会在启动时解析域名，如果你使用 &lt;code>DDNS&lt;/code> 来动态更新域名解析，那么每当 IP 发生变化时，就需要重新启动 WireGuard。目前建议的解决方案是使用 &lt;code>PostUp&lt;/code> 钩子每隔几分钟或几小时重新启动 WireGuard 来强制解析域名。
总的来说，&lt;code>NAT-to-NAT&lt;/code> 连接极为不稳定，而且还有一堆其他的限制，所以还是建议通过中继服务器来通信。
NAT-to-NAT 配置示例：
Peer1：&lt;/p>
&lt;pre>&lt;code>[Interface]
...
ListenPort = 12000
[Peer]
...
Endpoint = peer2.example-vpn.dev:12000
PersistentKeepalive = 25
&lt;/code>&lt;/pre>
&lt;p>Peer2：&lt;/p>
&lt;pre>&lt;code>[Interface]
...
ListenPort = 12000
[Peer]
...
Endpoint = peer1.example-vpn.dev:12000
PersistentKeepalive = 25
&lt;/code>&lt;/pre>
&lt;p>更多资料：&lt;/p>
&lt;ul>
&lt;li>&lt;strong>samyk/pwnat&lt;/strong>&lt;/li>
&lt;li>&lt;strong>en.wikipedia.org/wiki/UDP_hole_punching&lt;/strong>&lt;/li>
&lt;li>&lt;strong>stackoverflow.com/questions/8892142/udp-hole-punching-algorithm&lt;/strong>&lt;/li>
&lt;li>&lt;strong>stackoverflow.com/questions/12359502/udp-hole-punching-not-going-through-on-3g&lt;/strong>&lt;/li>
&lt;li>&lt;strong>stackoverflow.com/questions/11819349/udp-hole-punching-not-possible-with-mobile-provider&lt;/strong>&lt;/li>
&lt;li>&lt;strong>WireGuard/WireGuard@&lt;code>master&lt;/code>/contrib/examples/nat-hole-punching&lt;/strong>&lt;/li>
&lt;li>&lt;strong>staaldraad.github.io/2017/04/17/nat-to-nat-with-wireguard&lt;/strong>&lt;/li>
&lt;li>&lt;strong>golb.hplar.ch/2019/01/expose-server-vpn.html&lt;/strong>&lt;/li>
&lt;/ul>
&lt;h3 id="动态分配子网-ip">动态分配子网 IP&lt;/h3>
&lt;p>这里指的是对等节点（peer）的 VPN 子网 IP 的动态分配，类似于 DHCP，不是指 &lt;code>Endpoint&lt;/code>。
WireGuard 官方已经在开发动态分配子网 IP 的功能，具体的实现可以看这里：&lt;strong>WireGuard/wg-dynamic&lt;/strong>[17]
当然，你也可以使用 &lt;code>PostUp&lt;/code> 在运行时从文件中读取 IP 值来实现一个动态分配 IP 的系统，类似于 Kubernetes 的 CNI 插件。例如：&lt;/p>
&lt;pre>&lt;code>[Interface]
...
PostUp = wg set %i allowed-ips /etc/wireguard/wg0.key &amp;lt;(some command)
&lt;/code>&lt;/pre>
&lt;h3 id="奇技淫巧">奇技淫巧&lt;/h3>
&lt;h4 id="共享一个-peersconf-文件">共享一个 peers.conf 文件&lt;/h4>
&lt;p>介绍一个秘密功能，可以简化 WireGuard 的配置工作。如果某个 &lt;code>peer&lt;/code> 的公钥与本地接口的私钥能够配对，那么 WireGuard 会忽略该 &lt;code>peer&lt;/code>。利用这个特性，我们可以在所有节点上共用同一个 peer 列表，每个节点只需要单独定义一个 &lt;code>[Interface]&lt;/code> 就行了，即使列表中有本节点，也会被忽略。具体方式如下：&lt;/p>
&lt;ul>
&lt;li>每个对等节点（peer）都有一个单独的 &lt;code>/etc/wireguard/wg0.conf&lt;/code> 文件，只包含 &lt;code>[Interface]&lt;/code> 部分的配置。&lt;/li>
&lt;li>每个对等节点（peer）共用同一个 &lt;code>/etc/wireguard/peers.conf&lt;/code> 文件，其中包含了所有的 peer。&lt;/li>
&lt;li>Wg0.conf 文件中需要配置一个 PostUp 钩子，内容为 &lt;code>PostUp = wg addconf /etc/wireguard/peers.conf&lt;/code>。&lt;/li>
&lt;/ul>
&lt;p>关于 &lt;code>peers.conf&lt;/code> 的共享方式有很多种，你可以通过 &lt;code>ansible&lt;/code> 这样的工具来分发，可以使用 &lt;code>Dropbox&lt;/code> 之类的网盘来同步，当然也可以使用 &lt;code>ceph&lt;/code> 这种分布式文件系统来将其挂载到不同的节点上。&lt;/p>
&lt;h4 id="从文件或命令输出中读取配置">从文件或命令输出中读取配置&lt;/h4>
&lt;p>WireGuard 也可以从任意命令的输出或文件中读取内容来修改配置的值，利用这个特性可以方便管理密钥，例如可以在运行时从 &lt;code>Kubernetes Secrets&lt;/code> 或 &lt;code>AWS KMS&lt;/code> 等第三方服务读取密钥。&lt;/p>
&lt;h3 id="容器化">容器化&lt;/h3>
&lt;p>WireGuard 也可以跑在容器中，最简单的方式是使用 &lt;code>--privileged&lt;/code> 和 &lt;code>--cap-add=all&lt;/code> 参数，让容器可以加载内核模块。
你可以让 WireGuard 跑在容器中，向宿主机暴露一个网络接口；也可以让 WireGuard 运行在宿主机中，向特定的容器暴露一个接口。
下面给出一个具体的示例，本示例中的 &lt;code>vpn_test&lt;/code> 容器通过 WireGuard 中继服务器来路由所有流量。本示例中给出的容器配置是 &lt;code>docker-compose&lt;/code> 的配置文件格式。
中继服务器容器配置：&lt;/p>
&lt;pre>&lt;code>version: '3'
services:
wireguard:
image: linuxserver/wireguard
ports:
- 51820:51820/udp
cap_add:
- NET_ADMIN
- SYS_MODULE
volumes:
- /lib/modules:/lib/modules
- ./wg0.conf:/config/wg0.conf:ro
&lt;/code>&lt;/pre>
&lt;p>中继服务器 WireGuard 配置 &lt;code>wg0.conf&lt;/code>：&lt;/p>
&lt;pre>&lt;code>[Interface]
# Name = relay1.wg.example.com
Address = 192.0.2.1/24
ListenPort = 51820
PrivateKey = oJpRt2Oq27vIB5/UVb7BRqCwad2YMReQgH5tlxz8YmI=
DNS = 1.1.1.1,8.8.8.8
PostUp = iptables -A FORWARD -i wg0 -j ACCEPT; iptables -t nat -A POSTROUTING -o eth0 -j MASQUERADE; ip6tables -A FORWARD -i wg0 -j ACCEPT; ip6tables -t nat -A POSTROUTING -o eth0 -j MASQUERADE
PostDown = iptables -D FORWARD -i wg0 -j ACCEPT; iptables -t nat -D POSTROUTING -o eth0 -j MASQUERADE; ip6tables -D FORWARD -i wg0 -j ACCEPT; ip6tables -t nat -D POSTROUTING -o eth0 -j MASQUERADE
[Peer]
# Name = peer1.wg.example.com
PublicKey = I+hXRAJOG/UE2IQvIHsou2zTgkUyPve2pzvHTnd/2Gg=
AllowedIPs = 192.0.2.2/32
&lt;/code>&lt;/pre>
&lt;p>客户端容器配置：&lt;/p>
&lt;pre>&lt;code>version: '3'
services:
wireguard:
image: linuxserver/wireguard
cap_add:
- NET_ADMIN
- SYS_MODULE
volumes:
- /lib/modules:/lib/modules
- ./wg0.conf:/config/wg0.conf:ro
vpn_test:
image: curlimages/curl
entrypoint: curl -s http://whatismyip.akamai.com/
network_mode: 'service:wireguard'
&lt;/code>&lt;/pre>
&lt;p>客户端 WireGuard 配置 &lt;code>wg0.conf&lt;/code>：&lt;/p>
&lt;pre>&lt;code>[Interface]
# Name = peer1.wg.example.com
Address = 192.0.2.2/32
PrivateKey = YCW76edD4W7nZrPbWZxPZhcs32CsBLIi1sEhsV/sgk8=
DNS = 1.1.1.1,8.8.8.8
[Peer]
# Name = relay1.wg.example.com
Endpoint = relay1.wg.example.com:51820
PublicKey = zJNKewtL3gcHdG62V3GaBkErFtapJWsAx+2um0c0B1s=
AllowedIPs = 192.0.2.1/24,0.0.0.0/0
PersistentKeepalive = 21
&lt;/code>&lt;/pre>
&lt;h1 id="wireguard-关联文件与配置">WireGuard 关联文件与配置&lt;/h1>
&lt;p>&lt;strong>/etc/wireguard/&lt;/strong> # WireGuard 运行时配置文件的存放路径。&lt;/p>
&lt;h1 id="命令行工具">命令行工具&lt;/h1>
&lt;h2 id="wg-quick">wg-quick&lt;/h2>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://man7.org/linux/man-pages/man8/wg-quick.8.html">Manual(手册)，wg-quick(8)&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;h3 id="syntax语法">Syntax(语法)&lt;/h3>
&lt;p>&lt;strong>wg-quick [ up | down | save | strip ] [ CONFIG_FILE | INTERFACE ]&lt;/strong>&lt;/p></description></item><item><title>Docs: WireGuard 部署</title><link>https://desistdaydream.github.io/docs/4.%E6%95%B0%E6%8D%AE%E9%80%9A%E4%BF%A1/Tunneling-Protocol%E9%9A%A7%E9%81%93%E5%8D%8F%E8%AE%AE/WireGuard/WireGuard-%E9%83%A8%E7%BD%B2/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/4.%E6%95%B0%E6%8D%AE%E9%80%9A%E4%BF%A1/Tunneling-Protocol%E9%9A%A7%E9%81%93%E5%8D%8F%E8%AE%AE/WireGuard/WireGuard-%E9%83%A8%E7%BD%B2/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>原文链接：&lt;a href="https://mp.weixin.qq.com/s/vbt30eEGcp5JP5sHAPkwhw">https://mp.weixin.qq.com/s/vbt30eEGcp5JP5sHAPkwhw&lt;/a>&lt;/li>
&lt;li>英文原文链接：&lt;a href="https://github.com/pirate/wireguard-docs">https://github.com/pirate/wireguard-docs&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;h1 id="安装-wireguard-包">安装 WireGuard 包&lt;/h1>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># CentOS7&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>yum install epel-release.noarch elrepo-release.noarch -y
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>yum install --enablerepo&lt;span style="color:#f92672">=&lt;/span>elrepo-kernel kmod-wireguard wireguard-tools -y
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># 如果使用的是非标准内核，需要安装 DKMS 包，待验证&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>yum install https://dl.fedoraproject.org/pub/epel/epel-release-latest-7.noarch.rpm
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>curl -o /etc/yum.repos.d/jdoss-wireguard-epel-7.repo https://copr.fedorainfracloud.org/coprs/jdoss/wireguard/repo/epel-7/jdoss-wireguard-epel-7.repo
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>yum install wireguard-dkms wireguard-tools
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># CentOS Stream&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>yum install epel-release.noarch elrepo-release.noarch -y
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>yum install --enablerepo&lt;span style="color:#f92672">=&lt;/span>elrepo-kernel kmod-wireguard wireguard-tools
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># Ubuntu ≥ 18.04&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>apt install wireguard
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># MacOS&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>brew install wireguard-tools
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># Windows 客户端下载地址：&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>https://download.wireguard.com/windows-client/wireguard-amd64-0.1.1.msi
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>在中继服务器上开启 IP 地址转发：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>cat &amp;gt; /etc/sysctl.d/wireguard.conf &lt;span style="color:#e6db74">&amp;lt;&amp;lt;EOF
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">net.ipv4.ip_forward = 1
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">net.ipv4.conf.all.proxy_arp = 1
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">EOF&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>sysctl -p /etc/sysctl.conf
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h1 id="编写配置文件">编写配置文件&lt;/h1>
&lt;p>配置文件可以放在任何路径下，但必须通过绝对路径引用。默认路径是 &lt;code>/etc/wireguard/&lt;/code>。下面通过三个 Peer 组成网络拓扑的配置进行演示&lt;/p>
&lt;h2 id="生成密钥">生成密钥&lt;/h2>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># 生成中继服务器 Peer 的公钥与私钥&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>wg genkey | tee /etc/wireguard/key/gw-privatekey | wg pubkey &amp;gt; /etc/wireguard/key/gw-publickey
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># 生成其他 Peer 的公钥与私钥&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>wg genkey | tee /etc/wireguard/key/peer-client-privatekey | wg pubkey &amp;gt; /etc/wireguard/key/peer-client-publickey
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>wg genkey | tee /etc/wireguard/key/peer-company-privatekey | wg pubkey &amp;gt; /etc/wireguard/key/peer-company-publickey
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="在中继服务器上生成所有-peer-的配置文件">在中继服务器上，生成所有 Peer 的配置文件&lt;/h2>
&lt;h3 id="配置中继服务器-peer">配置中继服务器 Peer&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>cat &amp;gt; /etc/wireguard/wg-company.conf &lt;span style="color:#e6db74">&amp;lt;&amp;lt;EOF
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">[Interface]
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">ListenPort = 16000
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">Address = 10.1.0.254/24
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">PrivateKey = $(cat /etc/wireguard/key/gw-privatekey)
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">PostUp = iptables -A FORWARD -i %i -j ACCEPT; iptables -A FORWARD -o %i -j ACCEPT; iptables -t nat -A POSTROUTING -o ens3 -j MASQUERADE
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">PostDown = iptables -D FORWARD -i %i -j ACCEPT; iptables -D FORWARD -o %i -j ACCEPT; iptables -t nat -D POSTROUTING -o ens3 -j MASQUERADE
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">[Peer]
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74"># 客户端
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">PublicKey = $(cat /etc/wireguard/key/peer-client-publickey)
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">AllowedIPs = 10.1.0.253/32
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">[Peer]
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74"># 天津-公司
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">PublicKey = $(cat /etc/wireguard/key/peer-company-publickey)
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">AllowedIPs = 10.1.0.1/32, 172.38.0.0/16, 10.20.5.0/24
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">EOF&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="配置其他-peer">配置其他 Peer&lt;/h3>
&lt;p>生成配置后，将配置文件拷贝到对应 Peer 的 /etc/wireguard 目录下&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>cat &amp;gt; /etc/wireguard/client-company.conf &lt;span style="color:#e6db74">&amp;lt;&amp;lt;EOF
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">[Interface]
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">PrivateKey = $(cat /etc/wireguard/key/peer-client-privatekey)
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">Address = 10.1.0.253/24
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">[Peer]
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">PublicKey = $(cat /etc/wireguard/key/gw-publickey)
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">AllowedIPs = 10.1.0.0/24, 10.20.5.0/24, 172.38.0.0/16
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">Endpoint = $(curl -4 -s ip.sb):16000
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">PersistentKeepalive = 30
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">EOF&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>cat &amp;gt; /etc/wireguard/peer-company.conf &lt;span style="color:#e6db74">&amp;lt;&amp;lt;EOF
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">[Interface]
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">PrivateKey = $(cat /etc/wireguard/key/peer-company-privatekey)
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">Address = 10.1.0.1/24
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74"># 由于需要通过家里的 Peer 访问公司内很多网段，所以公司内的 Peer 同样需要开启转发以访问其它网段
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">PostUp = iptables -A FORWARD -i %i -j ACCEPT; iptables -A FORWARD -o %i -j ACCEPT; iptables -t nat -A POSTROUTING -o ens33 -j MASQUERADE
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">PostDown = iptables -D FORWARD -i %i -j ACCEPT; iptables -D FORWARD -o %i -j ACCEPT; iptables -t nat -D POSTROUTING -o ens33 -j MASQUERADE
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">[Peer]
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">PublicKey = $(cat /etc/wireguard/key/gw-publickey)
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">AllowedIPs = 10.1.0.0/24, 192.168.0.0/24
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">Endpoint = $(curl -4 -s ip.sb):16000
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">PersistentKeepalive = 30
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">EOF&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h1 id="启动与停止">启动与停止&lt;/h1>
&lt;p>启动中继服务器 Peer&lt;/p>
&lt;pre>&lt;code>wg-quick up /etc/wireguard/company-wg.conf
&lt;/code>&lt;/pre>
&lt;p>启动其他 Peer&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>wg-quick up /etc/wireguard/company-client.conf
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>wg-quick up /etc/wireguard/company.conf
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>服务启动时，本质是只是执行了几条命令，比如我现在使用 wg-company 配置启动 WireGuard：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">[&lt;/span>root@hw-cloud-xngy-jump-server-linux-1 ~&lt;span style="color:#f92672">]&lt;/span>&lt;span style="color:#75715e"># wg-quick up /etc/wireguard/company-wg.conf&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">[&lt;/span>&lt;span style="color:#75715e">#] ip link add company-wg type wireguard&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">[&lt;/span>&lt;span style="color:#75715e">#] wg setconf company-wg /dev/fd/63&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">[&lt;/span>&lt;span style="color:#75715e">#] ip -4 address add 10.1.0.254/24 dev company-wg&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">[&lt;/span>&lt;span style="color:#75715e">#] ip link set mtu 1420 up dev company-wg&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">[&lt;/span>&lt;span style="color:#75715e">#] ip -4 route add 10.20.5.0/24 dev company-wg&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">[&lt;/span>&lt;span style="color:#75715e">#] ip -4 route add 172.38.0.0/16 dev company-wg&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">[&lt;/span>&lt;span style="color:#75715e">#] iptables -A FORWARD -i company-wg -j ACCEPT; iptables -A FORWARD -o company-wg -j ACCEPT; iptables -t nat -A POSTROUTING -o ens3 -j MASQUERADE&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>可以看到执行了如下几部操作&lt;/p>
&lt;ul>
&lt;li>创建 wireguard 类型的 网络设备，并设置该网络设备
&lt;ul>
&lt;li>ip link add wg-company type wireguar&lt;/li>
&lt;li>ip link set mtu 1420 up dev wg-company&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>根据 &lt;code>[Interface]&lt;/code> 部分的配置，为新添加的网络设备添加 IP 地址
&lt;ul>
&lt;li>ip -4 address add 10.1.0.254/24 dev wg-company&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>根据所有 &lt;code>[Peer]&lt;/code> 部分的配置，为主机添加路由条目
&lt;ul>
&lt;li>ip -4 route add 10.20.5.0/24 dev wg-company&lt;/li>
&lt;li>ip -4 route add 172.38.0.0/16 dev wg-company&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>为了让中继服务器可以转发数据包，需要配置 Netfilter 规则。这个规则，可以在 &lt;code>[Interface]&lt;/code> 部分的配置中通过 PostUp 字段定义
&lt;ul>
&lt;li>iptables -A FORWARD -i wg-company -j ACCEPT&lt;/li>
&lt;li>iptables -A FORWARD -o wg-company -j ACCEPT&lt;/li>
&lt;li>iptables -t nat -A POSTROUTING -o ens3 -j MASQUERADE&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>可以看到，即使我们不使用 wg-quick 命令，通过上述操作，同样可以激活 WireGuard，毕竟，WireGuard 已经被包含在 Linux Kernel 当中了，我们只需要创建出来 WireGuard 类型的网络设备，并配置好路由条目，即可转发数据包，实现 VPN 的功能。&lt;/p>
&lt;h2 id="通过-systemd-启动-wireguard">通过 systemd 启动 Wireguard&lt;/h2>
&lt;p>WireGuard 安装完成后，会生成一个 &lt;code>wg-qucik@.service&lt;/code> 的 Unit 文件：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">[&lt;/span>root@hw-cloud-xngy-jump-server-linux-1 /etc/wireguard&lt;span style="color:#f92672">]&lt;/span>&lt;span style="color:#75715e"># systemctl cat wg-quick@.service&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># /lib/systemd/system/wg-quick@.service&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">[&lt;/span>Unit&lt;span style="color:#f92672">]&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Description&lt;span style="color:#f92672">=&lt;/span>WireGuard via wg-quick&lt;span style="color:#f92672">(&lt;/span>8&lt;span style="color:#f92672">)&lt;/span> &lt;span style="color:#66d9ef">for&lt;/span> %I
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>After&lt;span style="color:#f92672">=&lt;/span>network-online.target nss-lookup.target
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Wants&lt;span style="color:#f92672">=&lt;/span>network-online.target nss-lookup.target
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>PartOf&lt;span style="color:#f92672">=&lt;/span>wg-quick.target
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Documentation&lt;span style="color:#f92672">=&lt;/span>man:wg-quick&lt;span style="color:#f92672">(&lt;/span>8&lt;span style="color:#f92672">)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Documentation&lt;span style="color:#f92672">=&lt;/span>man:wg&lt;span style="color:#f92672">(&lt;/span>8&lt;span style="color:#f92672">)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Documentation&lt;span style="color:#f92672">=&lt;/span>https://www.wireguard.com/
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Documentation&lt;span style="color:#f92672">=&lt;/span>https://www.wireguard.com/quickstart/
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Documentation&lt;span style="color:#f92672">=&lt;/span>https://git.zx2c4.com/wireguard-tools/about/src/man/wg-quick.8
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Documentation&lt;span style="color:#f92672">=&lt;/span>https://git.zx2c4.com/wireguard-tools/about/src/man/wg.8
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">[&lt;/span>Service&lt;span style="color:#f92672">]&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Type&lt;span style="color:#f92672">=&lt;/span>oneshot
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>RemainAfterExit&lt;span style="color:#f92672">=&lt;/span>yes
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>ExecStart&lt;span style="color:#f92672">=&lt;/span>/usr/bin/wg-quick up %i
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>ExecStop&lt;span style="color:#f92672">=&lt;/span>/usr/bin/wg-quick down %i
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Environment&lt;span style="color:#f92672">=&lt;/span>WG_ENDPOINT_RESOLUTION_RETRIES&lt;span style="color:#f92672">=&lt;/span>infinity
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">[&lt;/span>Install&lt;span style="color:#f92672">]&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>WantedBy&lt;span style="color:#f92672">=&lt;/span>multi-user.target
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>从 &lt;code>[Service]&lt;/code> 部分可以看到，启动和停止服务，就是通过 wg-quick 命令实现的。&lt;/p>
&lt;p>所以想要在让 Peer 开机自启 WireGuard，只需要执行如下操作即可：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>systemctl enable wg-quick@wg-company --now
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>systemctl enable wg-quick@client-company --now
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>systemctl enable wg-quick@company --now
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h1 id="查看信息">查看信息&lt;/h1>
&lt;p>接口：&lt;/p>
&lt;pre>&lt;code># 查看系统 VPN 接口信息
$ ip link show wg-company
# 查看 VPN 接口详细信息
$ wg show all
$ wg show wg-company
&lt;/code>&lt;/pre>
&lt;p>地址：&lt;/p>
&lt;pre>&lt;code># 查看 VPN 接口地址
$ ip address show wg-company
&lt;/code>&lt;/pre>
&lt;p>路由&lt;/p>
&lt;pre>&lt;code># 查看系统路由表
$ ip route show table main
$ ip route show table local
# 获取到特定 IP 的路由
$ ip route get 192.0.2.3
&lt;/code>&lt;/pre></description></item><item><title>Docs: Wireguard 全互联模式（full mesh）权威指南</title><link>https://desistdaydream.github.io/docs/4.%E6%95%B0%E6%8D%AE%E9%80%9A%E4%BF%A1/Tunneling-Protocol%E9%9A%A7%E9%81%93%E5%8D%8F%E8%AE%AE/WireGuard/Wireguard-%E5%85%A8%E4%BA%92%E8%81%94%E6%A8%A1%E5%BC%8Ffull-mesh%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/4.%E6%95%B0%E6%8D%AE%E9%80%9A%E4%BF%A1/Tunneling-Protocol%E9%9A%A7%E9%81%93%E5%8D%8F%E8%AE%AE/WireGuard/Wireguard-%E5%85%A8%E4%BA%92%E8%81%94%E6%A8%A1%E5%BC%8Ffull-mesh%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97/</guid><description/></item><item><title>Docs: 流量伪装</title><link>https://desistdaydream.github.io/docs/4.%E6%95%B0%E6%8D%AE%E9%80%9A%E4%BF%A1/Tunneling-Protocol%E9%9A%A7%E9%81%93%E5%8D%8F%E8%AE%AE/WireGuard/%E6%B5%81%E9%87%8F%E4%BC%AA%E8%A3%85/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/4.%E6%95%B0%E6%8D%AE%E9%80%9A%E4%BF%A1/Tunneling-Protocol%E9%9A%A7%E9%81%93%E5%8D%8F%E8%AE%AE/WireGuard/%E6%B5%81%E9%87%8F%E4%BC%AA%E8%A3%85/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;/blockquote>
&lt;p>WireGuard 在国内网络环境下会遇到一个致命的问题：&lt;strong>UDP 封锁/限速&lt;/strong>。虽然通过 WireGuard 可以在隧道内传输任何基于 IP 的协议（TCP、UDP、ICMP、SCTP、IPIP、GRE 等），但 WireGuard 隧道本身是通过 UDP 协议进行通信的，而国内运营商根本没有能力和精力根据 TCP 和 UDP 的不同去深度定制不同的 QoS 策略，几乎全部采取一刀切的手段：对 UDP 进行限速甚至封锁。
虽然运营商对 UDP 不友好，但却无力深度检测 TCP 连接的真实性。既然对 TCP 连接睁一只眼闭一只眼，那我将 UDP 连接伪装成 TCP 连接不就蒙混过关了。目前支持将 UDP 流量伪装成 TCP 流量的主流工具是 &lt;a href="https://github.com/wangyu-/udp2raw-tunnel">udp2raw&lt;/a>，另一款比它更强大的新工具：&lt;a href="https://github.com/dndx/phantun">Phantun&lt;/a>。&lt;/p>
&lt;h1 id="udp2raw">udp2raw&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://github.com/wangyu-/udp2raw">GitHub 项目，wangyu-/udp2raw&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>使用原始套接字将 UDP 流量转换为加密的 UDP/FakeTCP/ICMP 流量的隧道，帮助您绕过 UDP 防火墙（或不稳定的 UDP 环境）&lt;/p>
&lt;h2 id="部署">部署&lt;/h2>
&lt;p>这里我使用 docker 部署的，实体进程和相关文档见 &lt;a href="https://github.com/wangyu-/udp2raw-tunnel/blob/master/doc/README.zh-cn.md#%E8%BF%90%E8%A1%8C">udp2raw 运行&lt;/a>
Linux server 端 :&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># 监听86的tcp端口，把86端口收到的伪装成tcp的udp报文转发到 127.0.0.1:16000 上&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>docker run &lt;span style="color:#ae81ff">\
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">&lt;/span> -d --name udp2raw &lt;span style="color:#ae81ff">\
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">&lt;/span> --restart always &lt;span style="color:#ae81ff">\
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">&lt;/span> --net host &lt;span style="color:#ae81ff">\
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">&lt;/span> --cap-add NET_RAW &lt;span style="color:#ae81ff">\
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">&lt;/span> --cap-add NET_ADMIN &lt;span style="color:#ae81ff">\
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">&lt;/span> -v /run/xtables.lock:/run/xtables.lock &lt;span style="color:#ae81ff">\
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">&lt;/span> zhangguanzhang/udp2raw &lt;span style="color:#ae81ff">\
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">&lt;/span> -s -l 0.0.0.0:86 &lt;span style="color:#ae81ff">\
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">&lt;/span> -r 127.0.0.1:16000 &lt;span style="color:#ae81ff">\
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">&lt;/span> -k passwd123 &lt;span style="color:#ae81ff">\
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">&lt;/span> --raw-mode faketcp &lt;span style="color:#ae81ff">\
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">&lt;/span> --cipher-mode xor -a
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Linux 或者软路由系统 client 端，软路径 openwrt 的话 iptables 的锁文件是位于 /var/run/xtables.lock，常规系统是 `/run/xtables.lock :&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># 监听16000的 udp 端口，把16000端口收到的udp报文伪装成tcp发到 &amp;lt;public_ip&amp;gt;:86 上&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>docker run --net host &lt;span style="color:#ae81ff">\
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">&lt;/span> -d --name udp2raw &lt;span style="color:#ae81ff">\
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">&lt;/span> --restart always &lt;span style="color:#ae81ff">\
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">&lt;/span> --cap-add NET_RAW &lt;span style="color:#ae81ff">\
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">&lt;/span> --cap-add NET_ADMIN &lt;span style="color:#ae81ff">\
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">&lt;/span> -v /var/run/xtables.lock:/run/xtables.lock &lt;span style="color:#ae81ff">\
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">&lt;/span> zhangguanzhang/udp2raw &lt;span style="color:#ae81ff">\
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">&lt;/span> -c -l 0.0.0.0:16000 &lt;span style="color:#ae81ff">\
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">&lt;/span> -r &amp;lt;public_ip&amp;gt;:86 &lt;span style="color:#ae81ff">\
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">&lt;/span> -k passwd123 &lt;span style="color:#ae81ff">\
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">&lt;/span> --raw-mode faketcp &lt;span style="color:#ae81ff">\
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">&lt;/span> --cipher-mode xor -a
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;a href="https://github.com/wangyu-/udp2raw-multiplatform">windows 客户端下载&lt;/a>，运行命令参考:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>./udp2raw_mp.exe -c -l 0.0.0.0:16000 -r &amp;lt;public_ip&amp;gt;:86 -k passwd123 --raw-mode faketcp --cipher-mode xor
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>所有 client 端的 [peer] 部分里之前连云主机的 ip 都写成 127.0.0.1:16000，这样 wg 客户端是先向本地的 udp2raw 客户端发 udp 报文，然后报文被封装成 tcp 发往云主机上的 udp2raw server，再到 wg server 上。
&lt;strong>客户端和云主机上&lt;/strong> 的 wg 的 mtu 设置成 1280(网上有写 1200 的，但是 windows 的 wg 客户端无法启动，邮件询问作者说最小 1280 才能启动)。例如我路由器配置&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">[&lt;/span>Interface&lt;span style="color:#f92672">]&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>...
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>MTU &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">1280&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">[&lt;/span>Peer&lt;span style="color:#f92672">]&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>...
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Endpoint &lt;span style="color:#f92672">=&lt;/span> 127.0.0.1:16000
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>PersistentKeepalive &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">10&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>windows 的 wg 目前 Endpoint 必须写本机的 ip（ipconfig 命令查看），不能写 127.0.0.1，否则无法连 peer（日志会一直刷 Failed to send handshake initiation write udp4 0.0.0.0:xxx-&amp;gt;127.0.0.1:16000: wsasendto: The requested address is not valid in its context），这个 bug 已经反馈给作者了。
udp2raw 的 client 连上 server 后，双方都会打印下面日志:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># server&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>changed state to server_ready
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># client&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>changed state from to client_handshake2 to client_ready
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="qos">qos&lt;/h2>
&lt;p>不同运营商可能不一样，比如你 A 和 B 同时 udp2raw 你云主机，A 可以 B 不可以，可以考虑换下 &amp;ndash;raw-mode 和 &amp;ndash;seq-mode ，有的可能 faketcp，有的可能 udp ，有的可能 icmp&lt;/p>
&lt;h2 id="一个注意点">一个注意点&lt;/h2>
&lt;p>openwrt 上在接口 添加 wireguard 接口，然后 peer 那里的 ip 写 127.0.0.1(也就是 openwrt 上的 udp2raw 的 ip)可能不行，换成 openwrt 的 局域网 ip 试下&lt;/p>
&lt;h1 id="phantun">Phantun&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://github.com/dndx/phantun">GitHub 项目，dndx/phantun&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://mp.weixin.qq.com/s/lgOqd7cMy8hFqST9uSih6w">公众号-米开朗基杨，突破运营商 QoS 封锁，WireGuard 真有“一套”！&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>Phantun 整个项目&lt;strong>完全使用 Rust 实现&lt;/strong>，性能吊打 udp2raw。它的初衷和 udp2raw 类似，都是为了实现一种简单的用户态 TCP 状态机来对 UDP 流量做伪装。主要的目的是希望能让 UDP 流量看起来像是 TCP，又不希望受到 TCP retransmission 或者 congestion control 的影响。
需要申明的是，&lt;strong>Phantun 的目标不是为了替代 udp2raw&lt;/strong>，从一开始 Phantun 就希望设计足够的简单高效，所以 udp2raw 支持的 &lt;strong>ICMP 隧道，加密，防止重放&lt;/strong>等等功能 Phantun 都选择不实现。
Phantun 假设 UDP 协议本身已经解决了这些问题，所以整个转发过程就是简单的明文换头加上一些必要的 TCP   状态控制信息。对于我日常使用的 WireGuard 来说，Phantun 这种设计是足够安全的，因为 WireGuard   的协议已经更好的实现了这些安全功能。
Phantun 使用 TUN 接口来收发 3 层数据包，udp2raw 使用 Raw Socket + BFP 过滤器。个人感觉基于 TUN 的实现要稍微的优雅一点，而且跨平台移植也要更容易。
Phantun 的 TCP 连接是按需创建的，只启动 Client 不会主动去连接服务器，需要第一个数据包到达了后才会按需创建。每个 UDP   流都有自己独立的 TCP 连接。这一点跟 udp2raw 很不一样，udp2raw 所有的 UDP 连接共用一个 TCP 连接。这样做的坏处就是 udp2raw 需要额外的头部信息来区分连接，更加增加了头部的开销。跟纯 UDP 比较，Phantun 每个数据包的额外头部开销是 12  byte，udp2raw 根据我的测试达到了 44 bytes 。&lt;/p>
&lt;h2 id="phantun-工作原理">Phantun 工作原理&lt;/h2>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/ki33gz7920yk6idk/1669018288492-b85eb3fd-aeea-49b6-b81a-5ccdf8976c28.jpeg" alt="">
Phantun 分为服务端和客户端，服务端会监听一个端口，比如 4567（通过 &lt;code>--local&lt;/code> 参数指定），并将 UDP 数据包转发到 UDP 服务（这里指的就是服务端 WireGuard 的监听端口和地址，通过 &lt;code>--remote&lt;/code> 参数指定）。
客户端也会监听一个端口，比如 &lt;code>127.0.0.1:4567&lt;/code>（通过 &lt;code>--local&lt;/code> 参数指定），并且通过 &lt;code>--remote&lt;/code> 参数与服务端（比如 &lt;code>10.0.0.1:4567&lt;/code>）建立连接。
客户端与服务端都会创建一个 TUN 网卡，客户端 TUN 网卡默认分配的 IPv4/IPv6 地址分别是 &lt;code>192.168.200.2&lt;/code> 和 &lt;code>fcc8::2&lt;/code>，服务端 TUN 网卡默认分配的 IPv4/IPv6 地址分别是 &lt;code>192.168.201.2&lt;/code> 和 &lt;code>fcc9::2&lt;/code>。
客户端与服务端都需要开启 IP forwarding，并且需要创建相应的 NAT 规则。客户端在流量离开物理网卡之前，需要对 IP &lt;code>192.168.200.2&lt;/code> 进行 SNAT；服务端在流量进入网卡之前，需要将 IP DNAT 为 &lt;code>192.168.201.2&lt;/code>。&lt;/p>
&lt;h2 id="phantun-配置步骤">Phantun 配置步骤&lt;/h2>
&lt;p>接下来我会通过一个示例来演示如何使用 Phantun 将 WireGuard 的 UDP 流量伪装成 TCP。我们需要在服务端和客户端分别安装 phantun，可以到 release 页面[3]下载，推荐下载静态编译版本 &lt;code>phantun_x86_64-unknown-linux-musl.zip&lt;/code>。&lt;/p>
&lt;h3 id="服务端">服务端&lt;/h3>
&lt;p>假设服务端的公网 IP 地址是 &lt;code>121.36.134.95&lt;/code>，WireGuard 监听端口是 &lt;code>51822&lt;/code>。首先修改配置文件 &lt;code>/etc/wireguard/wg0.conf&lt;/code>，在 &lt;code>[Interface]&lt;/code> 中添加以下配置：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-properties" data-lang="properties">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">MTU&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">1300&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">PreUp&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">iptables -t nat -A PREROUTING -p tcp -i eth0 --dport 4567 -j DNAT --to-destination 192.168.201.2&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">PreUp&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">RUST_LOG=info phantun_server --local 4567 --remote 127.0.0.1:51822 &amp;amp;&amp;gt; /var/log/phantun_server.log &amp;amp;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">PostDown&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">iptables -t nat -D PREROUTING -p tcp -i eth0 --dport 4567 -j DNAT --to-destination 192.168.201.2&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">PostDown&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">killall phantun_server || true&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>你需要将 eth0 替换为你服务端的物理网卡名。MTU 值先不管，后面再告诉大家调试方法。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-properties" data-lang="properties">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">PreUp&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">iptables -t nat -A PREROUTING -p tcp -i eth0 --dport 4567 -j DNAT --to-destination 192.168.201.2&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>这条 iptables 规则表示将 &lt;code>4567&lt;/code> 端口的入站流量 DNAT 为 TUN 网卡的 IP 地址。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-properties" data-lang="properties">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">PreUp&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">RUST_LOG=info phantun_server --local 4567 --remote 127.0.0.1:51822 &amp;amp;&amp;gt; /var/log/phantun_server.log &amp;amp;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>这里会启动 phantun_server，监听在 &lt;code>4567&lt;/code> 端口，并将 UDP 数据包转发到 WireGuard。
服务端完整的 WireGuard 配置：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-properties" data-lang="properties">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># local settings for Endpoint B&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#960050;background-color:#1e0010">[Interface]&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">PrivateKey&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">QH1BJzIZcGo89ZTykxls4i2DKgvByUkHIBy3BES2gX8=&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">Address&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">10.0.0.2/32&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">ListenPort&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">51822&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">MTU&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">1300&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">PreUp&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">iptables -t nat -A PREROUTING -p tcp -i eth0 --dport 4567 -j DNAT --to-destination 192.168.201.2&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">PreUp&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">RUST_LOG=info phantun_server --local 4567 --remote 127.0.0.1:51822 &amp;amp;&amp;gt; /var/log/phantun_server.log &amp;amp;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">PostDown&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">iptables -t nat -D PREROUTING -p tcp -i eth0 --dport 4567 -j DNAT --to-destination 192.168.201.2&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">PostDown&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">killall phantun_server || true&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># remote settings for Endpoint A&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#960050;background-color:#1e0010">[Peer]&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">PublicKey&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">wXtD/VrRo92JHc66q4Ypmnd4JpMk7b1Sb0AcT+pJfwY=&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">AllowedIPs&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">10.0.0.1/32&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>最后重启 WireGuard 即可：&lt;code>systemctl restart wg-quick@wg0&lt;/code>&lt;/p>
&lt;h3 id="客户端">客户端&lt;/h3>
&lt;p>假设客户端的 WireGuard 监听端口是 &lt;code>51821&lt;/code>。首先修改配置文件 &lt;code>/etc/wireguard/wg0.conf&lt;/code>，在 &lt;code>[Interface]&lt;/code> 中添加以下配置：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-properties" data-lang="properties">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">MTU&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">1300&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">PreUp&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">iptables -t nat -A POSTROUTING -o eth0 -s 192.168.200.2 -j MASQUERADE&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">PreUp&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">RUST_LOG=info phantun_client --local 127.0.0.1:4567 --remote 121.36.134.95:4567 &amp;amp;&amp;gt; /var/log/phantun_client.log &amp;amp;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">PostDown&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">iptables -t nat -D POSTROUTING -o eth0 -s 192.168.200.2 -j MASQUERADE&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">PostDown&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">killall phantun_client || true&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>你需要将 eth0 替换为你服务端的物理网卡名。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-properties" data-lang="properties">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">PreUp&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">iptables -t nat -A POSTROUTING -o eth0 -s 192.168.200.2 -j MASQUERADE&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>这条 iptables 规则表示对来自 &lt;code>192.168.200.2&lt;/code>（TUN 网卡） 的出站流量进行 MASQUERADE。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-properties" data-lang="properties">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">PreUp&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">RUST_LOG=info phantun_client --local 127.0.0.1:4567 --remote 121.36.134.95:4567 &amp;amp;&amp;gt; /var/log/phantun_client.log &amp;amp;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>这里会启动 phantun_client，监听在 &lt;code>4567&lt;/code> 端口，并与服务端建立连接，将伪装的 TCP 数据包传送给服务端。
除此之外还需要修改 WireGuard peer 的 Endpoint，将其修改为 127.0.0.1:4567。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-properties" data-lang="properties">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">Endpoint&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">127.0.0.1:4567&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>客户端完整的 WireGuard 配置：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-properties" data-lang="properties">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># local settings for Endpoint A&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#960050;background-color:#1e0010">[Interface]&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">PrivateKey&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">0Pyz3cIg2gRt+KxZ0Vm1PvSIU+0FGufPIzv92jTyGWk=&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">Address&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">10.0.0.1/32&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">ListenPort&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">51821&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">MTU&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">1300&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">PreUp&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">iptables -t nat -A POSTROUTING -o eth0 -s 192.168.200.2 -j MASQUERADE&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">PreUp&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">RUST_LOG=info phantun_client --local 127.0.0.1:4567 --remote 121.36.134.95:4567 &amp;amp;&amp;gt; /var/log/phantun_client.log &amp;amp;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">PostDown&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">iptables -t nat -D POSTROUTING -o eth0 -s 192.168.200.2 -j MASQUERADE&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">PostDown&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">killall phantun_client || true&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># remote settings for Endpoint B&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#960050;background-color:#1e0010">[Peer]&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">PublicKey&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">m40NDb5Cqtb78b1DVwY1+kxbG2yEcRhxlrLm/DlPpz8=&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">Endpoint&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">127.0.0.1:4567&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">AllowedIPs&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">10.0.0.2/32&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">PersistentKeepalive&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">25&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>最后重启 WireGuard 即可：&lt;code>systemctl restart wg-quick@wg0&lt;/code>
查看 phantun_client 的日志：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>$ tail -f /var/log/phantun_client.log
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> INFO client &amp;gt; Remote address is: 121.36.134.95:4567
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> INFO client &amp;gt; &lt;span style="color:#ae81ff">1&lt;/span> cores available
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> INFO client &amp;gt; Created TUN device tun0
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> INFO client &amp;gt; New UDP client from 127.0.0.1:51821
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> INFO fake_tcp &amp;gt; Sent SYN to server
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> INFO fake_tcp &amp;gt; Connection to 121.36.134.95:4567 established
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>查看 wg0 接口：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>$ wg show wg0
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>interface: wg0
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> public key: wXtD/VrRo92JHc66q4Ypmnd4JpMk7b1Sb0AcT+pJfwY&lt;span style="color:#f92672">=&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> private key: &lt;span style="color:#f92672">(&lt;/span>hidden&lt;span style="color:#f92672">)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> listening port: &lt;span style="color:#ae81ff">51821&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>peer: m40NDb5Cqtb78b1DVwY1+kxbG2yEcRhxlrLm/DlPpz8&lt;span style="color:#f92672">=&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> endpoint: 127.0.0.1:4567
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> allowed ips: 10.0.0.2/32
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> latest handshake: &lt;span style="color:#ae81ff">1&lt;/span> minute, &lt;span style="color:#ae81ff">57&lt;/span> seconds ago
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> transfer: &lt;span style="color:#ae81ff">184&lt;/span> B received, &lt;span style="color:#ae81ff">648&lt;/span> B sent
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> persistent keepalive: every &lt;span style="color:#ae81ff">25&lt;/span> seconds
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>测试连通性：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>$ ping 10.0.0.2 -c &lt;span style="color:#ae81ff">3&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>PING 10.0.0.2 &lt;span style="color:#f92672">(&lt;/span>10.0.0.2&lt;span style="color:#f92672">)&lt;/span> 56&lt;span style="color:#f92672">(&lt;/span>84&lt;span style="color:#f92672">)&lt;/span> bytes of data.
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">64&lt;/span> bytes from 10.0.0.2: icmp_seq&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span> ttl&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">64&lt;/span> time&lt;span style="color:#f92672">=&lt;/span>13.7 ms
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">64&lt;/span> bytes from 10.0.0.2: icmp_seq&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">2&lt;/span> ttl&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">64&lt;/span> time&lt;span style="color:#f92672">=&lt;/span>14.4 ms
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">64&lt;/span> bytes from 10.0.0.2: icmp_seq&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">3&lt;/span> ttl&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">64&lt;/span> time&lt;span style="color:#f92672">=&lt;/span>15.0 ms
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>--- 10.0.0.2 ping statistics ---
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">3&lt;/span> packets transmitted, &lt;span style="color:#ae81ff">3&lt;/span> received, 0% packet loss, time 2005ms
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>rtt min/avg/max/mdev &lt;span style="color:#f92672">=&lt;/span> 13.718/14.373/15.047/0.542 ms
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="客户端多服务端">客户端（多服务端）&lt;/h3>
&lt;p>如果客户端想和多个服务端建立连接，则新增的服务端配置如下：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-properties" data-lang="properties">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">PreUp&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">RUST_LOG=info phantun_client --local 127.0.0.1:4568 --remote xxxx:4567 --tun-local=192.168.202.1 --tun-peer=192.168.202.2 &amp;amp;&amp;gt; /var/log/phantun_client.log &amp;amp;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">PostDown&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">iptables -t nat -D POSTROUTING -o eth0 -s 192.168.202.2 -j MASQUERADE&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>本地监听端口需要选择一个与之前不同的端口，同理，TUN 网卡的地址也需要修改。最终的配置如下：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-properties" data-lang="properties">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># local settings for Endpoint A&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#960050;background-color:#1e0010">[Interface]&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">PrivateKey&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">0Pyz3cIg2gRt+KxZ0Vm1PvSIU+0FGufPIzv92jTyGWk=&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">Address&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">10.0.0.1/32&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">ListenPort&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">51821&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">MTU&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">1300&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">PreUp&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">iptables -t nat -A POSTROUTING -o eth0 -s 192.168.200.2 -j MASQUERADE&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">PreUp&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">RUST_LOG=info phantun_client --local 127.0.0.1:4567 --remote 121.36.134.95:4567 &amp;amp;&amp;gt; /var/log/phantun_client.log &amp;amp;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">PreUp&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">RUST_LOG=info phantun_client --local 127.0.0.1:4568 --remote xxxx:4567 --tun-local=192.168.202.1 --tun-peer=192.168.202.2 &amp;amp;&amp;gt; /var/log/phantun_client.log &amp;amp;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">PostDown&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">iptables -t nat -D POSTROUTING -o eth0 -s 192.168.200.2 -j MASQUERADE&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">PostDown&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">iptables -t nat -D POSTROUTING -o eth0 -s 192.168.202.2 -j MASQUERADE&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">PostDown&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">killall phantun_client || true&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># remote settings for Endpoint B&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#960050;background-color:#1e0010">[Peer]&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">PublicKey&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">m40NDb5Cqtb78b1DVwY1+kxbG2yEcRhxlrLm/DlPpz8=&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">Endpoint&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">127.0.0.1:4567&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">AllowedIPs&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">10.0.0.2/32&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">PersistentKeepalive&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">25&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="mtu-调优">MTU 调优&lt;/h2>
&lt;p>如果你使用 ping 或者 dig 等工具（小数据包）测试 WireGuard 隧道能够正常工作，但浏览器或者远程桌面（大数据包）却无法正常访问，很有可能是 MTU 的问题，你需要将 MTU 的值调小一点。
Phantun 官方建议将 MTU 的值设为 &lt;code>1428&lt;/code>（假设物理网卡的 MTU 是 1500），但经我测试是有问题的。建议直接将 MTU 设置为最低值 &lt;code>1280&lt;/code>，然后渐渐增加，直到无法正常工作为止，此时你的 MTU 就是最佳值。&lt;/p></description></item><item><title>Docs: 配置详解</title><link>https://desistdaydream.github.io/docs/4.%E6%95%B0%E6%8D%AE%E9%80%9A%E4%BF%A1/Tunneling-Protocol%E9%9A%A7%E9%81%93%E5%8D%8F%E8%AE%AE/WireGuard/%E9%85%8D%E7%BD%AE%E8%AF%A6%E8%A7%A3/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/4.%E6%95%B0%E6%8D%AE%E9%80%9A%E4%BF%A1/Tunneling-Protocol%E9%9A%A7%E9%81%93%E5%8D%8F%E8%AE%AE/WireGuard/%E9%85%8D%E7%BD%AE%E8%AF%A6%E8%A7%A3/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://zhangguanzhang.github.io/2020/08/05/wireguard-for-personal/">https://zhangguanzhang.github.io/2020/08/05/wireguard-for-personal/&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://fuckcloudnative.io/posts/wireguard-docs-practice/#peer">https://fuckcloudnative.io/posts/wireguard-docs-practice/#peer&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>WireGuard 使用 &lt;strong>INI&lt;/strong> 作为其配置文件格式。配置文件可以放在任何路径下，但必须通过绝对路径引用。默认路径是 &lt;code>/etc/wireguard/*.conf&lt;/code>。&lt;/p>
&lt;p>配置文件的命名形式必须为 &lt;code>${WireGuard_Interface_Name}.conf&lt;/code>。通常情况下 WireGuard 接口名称以 &lt;code>wg&lt;/code> 为前缀，并从 &lt;code>0&lt;/code> 开始编号，但你也可以使用其他名称，只要符合正则表达式 &lt;code>^[a-zA-Z0-9_=+.-]{1,15}$&lt;/code> 就行。当启动时，如果配置文件中有 wg0.conf 文件，则会创建一个名为 wg0 的网络设备。效果如下
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/opfrn4/1630110240584-d9fccfed-8434-4ed6-a7b7-d42796fed26c.png" alt="image.png">
注意：&lt;code>${WireGuard_Interface_Name}&lt;/code> 不能过长，否则将会报错：&lt;code>wg-quick: The config file must be a valid interface name, followed by .conf&lt;/code>&lt;/p>
&lt;h2 id="基本配置示例">基本配置示例&lt;/h2>
&lt;pre>&lt;code>[Interface]
# Name = node1.example.tld
Address = 192.0.2.3/32
ListenPort = 51820
PrivateKey = localPrivateKeyAbcAbcAbc=
DNS = 1.1.1.1,8.8.8.8
Table = 12345
MTU = 1500
PreUp = /bin/example arg1 arg2 %i
PostUp = /bin/example arg1 arg2 %i
PreDown = /bin/example arg1 arg2 %i
PostDown = /bin/example arg1 arg2 %i
[Peer]
# Name = node2-node.example.tld
AllowedIPs = 192.0.2.1/24
Endpoint = node1.example.tld:51820
PublicKey = remotePublicKeyAbcAbcAbc=
PersistentKeepalive = 25
&lt;/code>&lt;/pre>
&lt;h1 id="interface">[Interface]&lt;/h1>
&lt;p>Interface 部分定义本地 VPN 配置。例如：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>本地节点是客户端，只路由自身的流量，只暴露一个 IP。&lt;/p>
&lt;p>[Interface]&lt;/p>
&lt;h1 id="name--phoneexample-vpndev">Name = phone.example-vpn.dev&lt;/h1>
&lt;p>Address = 192.0.2.5/32
PrivateKey = &lt;!-- raw HTML omitted -->&lt;/p>
&lt;/li>
&lt;li>
&lt;p>本地节点是中继服务器，它可以将流量转发到其他对等节点（peer），并公开整个 VPN 子网的路由。&lt;/p>
&lt;p>[Interface]&lt;/p>
&lt;h1 id="name--public-server1example-vpntld">Name = public-server1.example-vpn.tld&lt;/h1>
&lt;p>Address = 192.0.2.1/24
ListenPort = 51820
PrivateKey = &lt;!-- raw HTML omitted -->
DNS = 1.1.1.1&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h2 id="address">Address&lt;/h2>
&lt;p>定义本地节点应该对哪个地址范围进行路由。如果是常规的客户端，则将其设置为节点本身的单个 IP（使用 CIDR 指定，例如 192.0.2.3/32）；如果是中继服务器，则将其设置为可路由的子网范围。
例如：&lt;/p>
&lt;ul>
&lt;li>常规客户端，只路由自身的流量：&lt;code>Address = 192.0.2.3/32&lt;/code>&lt;/li>
&lt;li>中继服务器，可以将流量转发到其他对等节点（peer）：&lt;code>Address = 192.0.2.1/24&lt;/code>&lt;/li>
&lt;li>也可以指定多个子网或 IPv6 子网：&lt;code>Address = 192.0.2.1/24,2001:DB8::/64&lt;/code>&lt;/li>
&lt;/ul>
&lt;h2 id="listenport">ListenPort&lt;/h2>
&lt;p>当本地节点是中继服务器时，需要通过该参数指定端口来监听传入 VPN 连接，默认端口号是 &lt;code>51820&lt;/code>。常规客户端不需要此选项。&lt;/p>
&lt;h2 id="privatekey">PrivateKey&lt;/h2>
&lt;p>本地节点的私钥，所有节点（包括中继服务器）都必须设置。不可与其他服务器共用。
私钥可通过命令 &lt;code>wg genkey &amp;gt; example.key&lt;/code> 来生成。&lt;/p>
&lt;h2 id="dns">DNS&lt;/h2>
&lt;p>通过 DHCP 向客户端宣告 DNS 服务器。客户端将会使用这里指定的 DNS 服务器来处理 VPN 子网中的 DNS 请求，但也可以在系统中覆盖此选项。例如：&lt;/p>
&lt;ul>
&lt;li>如果不配置则使用系统默认 DNS&lt;/li>
&lt;li>可以指定单个 DNS：&lt;code>DNS = 1.1.1.1&lt;/code>&lt;/li>
&lt;li>也可以指定多个 DNS：&lt;code>DNS = 1.1.1.1,8.8.8.8&lt;/code>&lt;/li>
&lt;/ul>
&lt;h2 id="table">Table&lt;/h2>
&lt;p>定义 VPN 子网使用的路由表，默认不需要设置。该参数有两个特殊的值需要注意：&lt;/p>
&lt;ul>
&lt;li>&lt;strong>Table = off&lt;/strong> : 禁止创建路由&lt;/li>
&lt;li>&lt;strong>Table = auto（默认值）&lt;/strong> : 将路由添加到系统默认的 table 中，并启用对默认路由的特殊处理。&lt;/li>
&lt;/ul>
&lt;p>例如：&lt;code>Table = 1234&lt;/code>&lt;/p>
&lt;h2 id="mtu">MTU&lt;/h2>
&lt;p>定义连接到对等节点（peer）的 &lt;code>MTU&lt;/code>（Maximum Transmission Unit，最大传输单元），默认不需要设置，一般由系统自动确定。&lt;/p>
&lt;h2 id="preup">PreUp&lt;/h2>
&lt;p>启动 VPN 接口之前运行的命令。这个选项可以指定多次，按顺序执行。
例如：&lt;/p>
&lt;ul>
&lt;li>添加路由：&lt;code>PreUp = ip rule add ipproto tcp dport 22 table 1234&lt;/code>&lt;/li>
&lt;/ul>
&lt;h2 id="postup">PostUp&lt;/h2>
&lt;p>启动 VPN 接口之后运行的命令。这个选项可以指定多次，按顺序执行。
例如：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>从文件或某个命令的输出中读取配置值：&lt;/p>
&lt;p>PostUp = wg set %i private-key /etc/wireguard/wg0.key &amp;lt;(some command here)&lt;/p>
&lt;/li>
&lt;li>
&lt;p>添加一行日志到文件中：&lt;/p>
&lt;p>PostUp = echo &amp;ldquo;$(date +%s) WireGuard Started&amp;rdquo; &amp;raquo; /var/log/wireguard.log&lt;/p>
&lt;/li>
&lt;li>
&lt;p>调用 WebHook：&lt;/p>
&lt;p>PostUp = curl &lt;a href="https://events.example.dev/wireguard/started/?key=abcdefg">https://events.example.dev/wireguard/started/?key=abcdefg&lt;/a>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>添加路由：&lt;/p>
&lt;p>PostUp = ip rule add ipproto tcp dport 22 table 1234&lt;/p>
&lt;/li>
&lt;li>
&lt;p>添加 iptables 规则，启用数据包转发：&lt;/p>
&lt;p>PostUp = iptables -A FORWARD -i %i -j ACCEPT; iptables -A FORWARD -o %i -j ACCEPT; iptables -t nat -A POSTROUTING -o eth0 -j MASQUERADE&lt;/p>
&lt;/li>
&lt;li>
&lt;p>强制 WireGuard 重新解析对端域名的 IP 地址：&lt;/p>
&lt;p>PostUp = resolvectl domain %i &amp;ldquo;~.&amp;rdquo;; resolvectl dns %i 192.0.2.1; resolvectl dnssec %i yes&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h2 id="predown">PreDown&lt;/h2>
&lt;p>停止 VPN 接口之前运行的命令。这个选项可以指定多次，按顺序执行。
例如：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>添加一行日志到文件中：&lt;/p>
&lt;p>PreDown = echo &amp;ldquo;$(date +%s) WireGuard Going Down&amp;rdquo; &amp;raquo; /var/log/wireguard.log&lt;/p>
&lt;/li>
&lt;li>
&lt;p>调用 WebHook：&lt;/p>
&lt;p>PreDown = curl &lt;a href="https://events.example.dev/wireguard/stopping/?key=abcdefg">https://events.example.dev/wireguard/stopping/?key=abcdefg&lt;/a>&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h2 id="postdown">PostDown&lt;/h2>
&lt;p>停止 VPN 接口之后运行的命令。这个选项可以指定多次，按顺序执行。
例如：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>添加一行日志到文件中：&lt;/p>
&lt;p>PostDown = echo &amp;ldquo;$(date +%s) WireGuard Going Down&amp;rdquo; &amp;raquo; /var/log/wireguard.log&lt;/p>
&lt;/li>
&lt;li>
&lt;p>调用 WebHook：&lt;/p>
&lt;p>PostDown = curl &lt;a href="https://events.example.dev/wireguard/stopping/?key=abcdefg">https://events.example.dev/wireguard/stopping/?key=abcdefg&lt;/a>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>删除 iptables 规则，关闭数据包转发：&lt;/p>
&lt;p>PostDown = iptables -D FORWARD -i %i -j ACCEPT; iptables -D FORWARD -o %i -j ACCEPT; iptables -t nat -D POSTROUTING -o eth0 -j MASQUERADE&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h1 id="peer">[Peer]&lt;/h1>
&lt;p>定义能够为一个或多个地址路由流量的 Peer 的 VPN 设置。Peer 可以是将流量转发到其他 Peer 的中继服务器，也可以是通过公网或内网直连的客户端。
中继服务器必须将所有的客户端定义为对等节点（peer），除了中继服务器之外，其他客户端都不能将位于 NAT 后面的节点定义为对等节点（peer），因为路由不可达。对于那些只为自己路由流量的客户端，只需将中继服务器作为对等节点（peer），以及其他需要直接访问的节点。
举个例子，在下面的配置中，&lt;code>public-server1&lt;/code> 作为中继服务器，其他的客户端有的是直连，有的位于 NAT 后面：&lt;/p>
&lt;ul>
&lt;li>&lt;code>public-server1&lt;/code>（中继服务器）
[peer] : &lt;code>public-server2&lt;/code>, &lt;code>home-server&lt;/code>, &lt;code>laptop&lt;/code>, &lt;code>phone&lt;/code>&lt;/li>
&lt;li>&lt;code>public-server2&lt;/code>（直连客户端）
[peer] : &lt;code>public-server1&lt;/code>&lt;/li>
&lt;li>&lt;code>home-server&lt;/code>（客户端位于 NAT 后面）
[peer] : &lt;code>public-server1&lt;/code>, &lt;code>public-server2&lt;/code>&lt;/li>
&lt;li>&lt;code>laptop&lt;/code>（客户端位于 NAT 后面）
[peer] : &lt;code>public-server1&lt;/code>, &lt;code>public-server2&lt;/code>&lt;/li>
&lt;li>&lt;code>phone&lt;/code>（客户端位于 NAT 后面）
[peer] : &lt;code>public-server1&lt;/code>, &lt;code>public-server2&lt;/code>&lt;/li>
&lt;/ul>
&lt;p>配置示例：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>对等节点（peer）是路由可达的客户端，只为自己路由流量&lt;/p>
&lt;p>[Peer]&lt;/p>
&lt;h1 id="name--public-server2example-vpndev">Name = public-server2.example-vpn.dev&lt;/h1>
&lt;p>Endpoint = public-server2.example-vpn.dev:51820
PublicKey = &lt;!-- raw HTML omitted -->
AllowedIPs = 192.0.2.2/32&lt;/p>
&lt;/li>
&lt;li>
&lt;p>对等节点（peer）是位于 NAT 后面的客户端，只为自己路由流量&lt;/p>
&lt;p>[Peer]&lt;/p>
&lt;h1 id="name--home-serverexample-vpndev">Name = home-server.example-vpn.dev&lt;/h1>
&lt;p>Endpoint = home-server.example-vpn.dev:51820
PublicKey = &lt;!-- raw HTML omitted -->
AllowedIPs = 192.0.2.3/32&lt;/p>
&lt;/li>
&lt;li>
&lt;p>对等节点（peer）是中继服务器，用来将流量转发到其他对等节点（peer）&lt;/p>
&lt;p>[Peer]&lt;/p>
&lt;h1 id="name--public-server1example-vpntld-1">Name = public-server1.example-vpn.tld&lt;/h1>
&lt;p>Endpoint = public-server1.example-vpn.tld:51820
PublicKey = &lt;!-- raw HTML omitted -->&lt;/p>
&lt;h1 id="路由整个-vpn-子网的流量">路由整个 VPN 子网的流量&lt;/h1>
&lt;p>AllowedIPs = 192.0.2.1/24
PersistentKeepalive = 25&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h2 id="endpoint">Endpoint&lt;/h2>
&lt;p>指定 其他 Peer 的公网地址。如果 Peer 位于 NAT 后面或者没有稳定的公网访问地址，则忽略这个字段。通常只需要指定&lt;strong>中继服务器&lt;/strong>的 &lt;code>Endpoint&lt;/code>，当然有稳定公网 IP 的节点也可以指定。例如：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>通过 IP 指定：&lt;/p>
&lt;p>Endpoint = 123.124.125.126:51820&lt;/p>
&lt;/li>
&lt;li>
&lt;p>通过域名指定：&lt;/p>
&lt;p>Endpoint = public-server1.example-vpn.tld:51820&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>NAT 后的任何 Peer 都会将 AllowedIPs 指定网段的数据包，发送到 Endpoint。&lt;/p>
&lt;h2 id="allowedips">AllowedIPs&lt;/h2>
&lt;p>当该 Peer 向本 Peer 发送数据包时，只有源地址在该字段指定的地址范围内时，才会处理这些数据包，否则直接丢弃。同时，本 Peer 会根据该字段的地址范围，在路由表中添加路由条目。比如：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">[&lt;/span>Interface&lt;span style="color:#f92672">]&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Address &lt;span style="color:#f92672">=&lt;/span> 10.1.0.254/24
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">[&lt;/span>Peer&lt;span style="color:#f92672">]&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>AllowedIPs &lt;span style="color:#f92672">=&lt;/span> 10.1.0.1/32, 172.16.0.0/24
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>则路由表会出现如下条目&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>10.1.0.0/24 dev wg0 proto kernel scope link src 10.1.0.254
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>172.16.0.0/24 dev wg0 scope link
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>也就是说，凡是发送给 AllowedIPs 字段中指定的地址范围的数据包，都会通过 WireGuard 生成的网络设备处理后发出去。&lt;/p>
&lt;p>如果 Peer 是常规的客户端，则将其设置为节点本身的单个 IP；如果 Peer 是中继服务器，则将其设置为可路由的子网范围。可以使用 &lt;code>,&lt;/code> 来指定多个 IP 或子网范围。该字段也可以指定多次。&lt;/p>
&lt;p>当决定如何对一个数据包进行路由时，系统首先会选择最具体的路由，如果不匹配再选择更宽泛的路由。例如，对于一个发往 &lt;code>192.0.2.3&lt;/code> 的数据包，系统首先会寻找地址为 &lt;code>192.0.2.3/32&lt;/code> 的对等节点（peer），如果没有再寻找地址为 &lt;code>192.0.2.1/24&lt;/code> 的对等节点（peer），以此类推。&lt;/p>
&lt;p>例如：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>对等节点（peer）是常规客户端，只路由自身的流量：&lt;/p>
&lt;p>AllowedIPs = 192.0.2.3/32&lt;/p>
&lt;/li>
&lt;li>
&lt;p>对等节点（peer）是中继服务器，可以将流量转发到其他对等节点（peer）：&lt;/p>
&lt;p>AllowedIPs = 192.0.2.1/24&lt;/p>
&lt;/li>
&lt;li>
&lt;p>对等节点（peer）是中继服务器，可以转发所有的流量，包括外网流量和 VPN 流量，可以用来干嘛你懂得：&lt;/p>
&lt;p>AllowedIPs = 0.0.0.0/0,::/0&lt;/p>
&lt;/li>
&lt;li>
&lt;p>对等节点（peer）是中继服务器，可以路由其自身和其他对等节点（peer）的流量：&lt;/p>
&lt;p>AllowedIPs = 192.0.2.3/32,192.0.2.4/32&lt;/p>
&lt;/li>
&lt;li>
&lt;p>对等节点（peer）是中继服务器，可以路由其自身的流量和它所在的内网的流量：&lt;/p>
&lt;p>AllowedIPs = 192.0.2.3/32,192.168.1.1/24&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>本质上&lt;/strong>
&lt;strong>Endpoint 与 AllowedIPs 两个字段将会组成路由条目，可以这么描述：&lt;/strong>&lt;code>**目的地址是 AllowedIPs 的数据包，下一跳是 Endpoint**&lt;/code>&lt;strong>。也可以不指定 Endpoint，而是仅仅将数据包送入 WireGuard 创建的网络设备中。&lt;/strong>&lt;/p>
&lt;h2 id="publickey">PublicKey&lt;/h2>
&lt;p>Peer 的公钥，所有节点（包括中继服务器）都必须设置。可与其他对等节点（peer）共用同一个公钥。
公钥可通过命令 &lt;code>wg pubkey &amp;lt; example.key &amp;gt; example.key.pub&lt;/code> 来生成，其中 &lt;code>example.key&lt;/code> 是上面生成的私钥。
例如：&lt;code>PublicKey = somePublicKeyAbcdAbcdAbcdAbcd=&lt;/code>&lt;/p>
&lt;h2 id="persistentkeepalive">PersistentKeepalive&lt;/h2>
&lt;p>如果连接是从一个位于 NAT 后面的对等节点（peer）到一个公网可达的对等节点（peer），那么 NAT 后面的对等节点（peer）必须定期发送一个出站 ping 包来检查连通性，如果 IP 有变化，就会自动更新&lt;code>Endpoint&lt;/code>。
例如：&lt;/p>
&lt;ul>
&lt;li>本地节点与对等节点（peer）可直连：该字段不需要指定，因为不需要连接检查。&lt;/li>
&lt;li>对等节点（peer）位于 NAT 后面：该字段不需要指定，因为维持连接是客户端（连接的发起方）的责任。&lt;/li>
&lt;li>本地节点位于 NAT 后面，对等节点（peer）公网可达：需要指定该字段 &lt;code>PersistentKeepalive = 25&lt;/code>，表示每隔 &lt;code>25&lt;/code> 秒发送一次 ping 来检查连接。&lt;/li>
&lt;/ul>
&lt;h1 id="配置示例">配置示例&lt;/h1>
&lt;h2 id="最简单的配置">最简单的配置&lt;/h2>
&lt;p>在带公网的 Peer 上执行如下指令生成三对公私钥、以及 3 个配置文件&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>wg genkey | tee gw-privatekey | wg pubkey &amp;gt; gw-publickey
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>wg genkey | tee peer1-privatekey | wg pubkey &amp;gt; peer1-publickey
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>wg genkey | tee peer2-privatekey | wg pubkey &amp;gt; peer2-publickey
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>wg genkey | tee peer3-privatekey | wg pubkey &amp;gt; peer3-publickey
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>带公网的 Peer 配置文件&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>cat &amp;gt; wg0.conf &lt;span style="color:#e6db74">&amp;lt;&amp;lt;EOF
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">[Interface]
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74"># 除了本 Peer 以外的其他 Peer 连接本 Peer 所使用的端口，也表示本 Peer 监听的 UDP 端口号。
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">ListenPort = 16000
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74"># 用来表示 WireGuard 在本 Peer 上创建的网络设备的 IP，每个 Peer 都是独立的
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74"># 说白了，就是本 Peer 用来与其他 Peer 通信的网络设备的 IP 地址和网段
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">Address = 10.1.0.254/24
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">PrivateKey = $(cat gw-privatekey)
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74"># 用来处理流量转发的 iptables 规则
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">PostUp = iptables -A FORWARD -i %i -j ACCEPT; iptables -A FORWARD -o %i -j ACCEPT; iptables -t nat -A POSTROUTING -o eth0 -j MASQUERADE
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">PostDown = iptables -D FORWARD -i %i -j ACCEPT; iptables -D FORWARD -o %i -j ACCEPT; iptables -t nat -D POSTROUTING -o eth0 -j MASQUERADE
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74"># peer1
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">[Peer]
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">PublicKey = $(cat peer1-publickey)
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">AllowedIPs = 10.1.0.1/32, 172.16.0.0/24
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74"># peer2
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">[Peer]
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">PublicKey = $(cat peer2-publickey)
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">AllowedIPs = 10.1.0.2/32, 172.19.42.0/24
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74"># peer3
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">[Peer]
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">PublicKey = $(cat peer3-publickey)
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">AllowedIPs = 10.1.0.3/32, 192.168.31.0/24
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">EOF&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Peer1 配置文件&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>cat &amp;gt; peer1.conf &lt;span style="color:#e6db74">&amp;lt;&amp;lt;EOF
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">[Interface]
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">PrivateKey = $(cat peer1-privatekey)
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74"># 用来表示 WireGuard 在本 Peer 上创建的网络设备的 IP，每个 Peer 都是独立的
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">Address = 10.1.0.1/24
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">[Peer]
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74"># gateway的公钥
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">PublicKey = $(cat gw-publickey)
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">AllowedIPs = 10.1.0.0/24, 172.19.42.0/24, 192.168.31.0/24
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74"># gateway 公网ip和端口
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">Endpoint = $(curl -s ip.sb):16000
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">PersistentKeepalive = 10
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">EOF&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Peer2 配置文件&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>cat &amp;gt; peer2.conf &lt;span style="color:#e6db74">&amp;lt;&amp;lt;EOF
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">[Interface]
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">PrivateKey = $(cat peer2-privatekey)
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">Address = 10.1.0.2/24
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">[Peer]
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">PublicKey = $(cat gw-publickey)
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">AllowedIPs = 10.1.0.0/24, 172.16.0.0/24, 192.168.31.0/24
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">Endpoint = $(curl -s ip.sb):16000
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">PersistentKeepalive = 10
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">EOF&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Peer3 配置文件&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>cat &amp;gt; peer3.conf &lt;span style="color:#e6db74">&amp;lt;&amp;lt;EOF
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">[Interface]
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">PrivateKey = $(cat peer3-privatekey)
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">Address = 10.1.0.3/24
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">[Peer]
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">PublicKey = $(cat gw-publickey)
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">AllowedIPs = 10.1.0.0/24, 172.19.42.0/24, 172.16.0.0/24
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">Endpoint = $(curl -s ip.sb):16000
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">PersistentKeepalive = 10
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">EOF&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>此时，在 Peer1 上使用 peer1.conf 文件启动 WireGuard；在 Peer2 上使用 peer2.conf 文件启动 WireGuard；在 Peer3 上使用 peer3.conf 文件启动 WireGuard。然后 Peer{1,2,3} 这三个节点就可以互通了~&lt;/p>
&lt;h1 id="unit-文件">Unit 文件&lt;/h1>
&lt;p>WireGuard 使用包管理器安装后，会自动创建一个由 Systemd 管理的 Unit 文件：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">[&lt;/span>root@hw-cloud-xngy-jump-server-linux-1 ~&lt;span style="color:#f92672">]&lt;/span>&lt;span style="color:#75715e"># systemctl cat wg-quick@.service&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># /lib/systemd/system/wg-quick@.service&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">[&lt;/span>Unit&lt;span style="color:#f92672">]&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Description&lt;span style="color:#f92672">=&lt;/span>WireGuard via wg-quick&lt;span style="color:#f92672">(&lt;/span>8&lt;span style="color:#f92672">)&lt;/span> &lt;span style="color:#66d9ef">for&lt;/span> %I
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>After&lt;span style="color:#f92672">=&lt;/span>network-online.target nss-lookup.target
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Wants&lt;span style="color:#f92672">=&lt;/span>network-online.target nss-lookup.target
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>PartOf&lt;span style="color:#f92672">=&lt;/span>wg-quick.target
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Documentation&lt;span style="color:#f92672">=&lt;/span>man:wg-quick&lt;span style="color:#f92672">(&lt;/span>8&lt;span style="color:#f92672">)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Documentation&lt;span style="color:#f92672">=&lt;/span>man:wg&lt;span style="color:#f92672">(&lt;/span>8&lt;span style="color:#f92672">)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Documentation&lt;span style="color:#f92672">=&lt;/span>https://www.wireguard.com/
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Documentation&lt;span style="color:#f92672">=&lt;/span>https://www.wireguard.com/quickstart/
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Documentation&lt;span style="color:#f92672">=&lt;/span>https://git.zx2c4.com/wireguard-tools/about/src/man/wg-quick.8
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Documentation&lt;span style="color:#f92672">=&lt;/span>https://git.zx2c4.com/wireguard-tools/about/src/man/wg.8
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">[&lt;/span>Service&lt;span style="color:#f92672">]&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Type&lt;span style="color:#f92672">=&lt;/span>oneshot
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>RemainAfterExit&lt;span style="color:#f92672">=&lt;/span>yes
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>ExecStart&lt;span style="color:#f92672">=&lt;/span>/usr/bin/wg-quick up %i
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>ExecStop&lt;span style="color:#f92672">=&lt;/span>/usr/bin/wg-quick down %i
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Environment&lt;span style="color:#f92672">=&lt;/span>WG_ENDPOINT_RESOLUTION_RETRIES&lt;span style="color:#f92672">=&lt;/span>infinity
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">[&lt;/span>Install&lt;span style="color:#f92672">]&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>WantedBy&lt;span style="color:#f92672">=&lt;/span>multi-user.target
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>我们可以通过 Unit 来配置 WireGuard 的开机自启，将 WireGuard 的维护工作交给 Systemd。&lt;/p></description></item><item><title>Docs: 应用示例</title><link>https://desistdaydream.github.io/docs/4.%E6%95%B0%E6%8D%AE%E9%80%9A%E4%BF%A1/Tunneling-Protocol%E9%9A%A7%E9%81%93%E5%8D%8F%E8%AE%AE/WireGuard/%E5%BA%94%E7%94%A8%E7%A4%BA%E4%BE%8B/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/4.%E6%95%B0%E6%8D%AE%E9%80%9A%E4%BF%A1/Tunneling-Protocol%E9%9A%A7%E9%81%93%E5%8D%8F%E8%AE%AE/WireGuard/%E5%BA%94%E7%94%A8%E7%A4%BA%E4%BE%8B/</guid><description/></item></channel></rss>