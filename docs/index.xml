<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>断念梦 – 文档</title><link>https://desistdaydream.github.io/docs/</link><description>Recent content in 文档 on 断念梦</description><generator>Hugo -- gohugo.io</generator><atom:link href="https://desistdaydream.github.io/docs/index.xml" rel="self" type="application/rss+xml"/><item><title>Docs: 1.Bootloader</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/1.bootloader/1.bootloader/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/1.bootloader/1.bootloader/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Bootloader">Wiki,Bootloader&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>&lt;strong>Bootloader(引导加载程序)&lt;/strong> 是负责 &lt;a href="https://en.wikipedia.org/wiki/Booting">booting(引导)&lt;/a> 计算器的软件。通常也被称为 Bootstrap Loader、Bootstrap。&lt;/p>
&lt;p>当计算机关闭时，操作系统、应用程序代码和数据 ‍‌ 仍存储在非易失性存储器中。当计算机开机时，它通常没有操作系统或其随机存取存储器 (RAM) 中的加载程序。计算机首先执行存储在只读存储器（ROM，以及后来的 EEPROM、NOR 闪存）中的相对较小的程序以及一些需要的数据，以初始化 RAM（特别是在 x86 系统上），访问非易失性设备（通常是块设备，例如 NAND 闪存）或可以将操作系统程序和数据加载到 RAM 中的设备。&lt;/p>
&lt;h1 id="配置">配置&lt;/h1>
&lt;p>&lt;strong>/boot/*&lt;/strong> # 所有关于系统引导启动的配置信息，都在该目录下
&lt;strong>/boot/grub2/*&lt;/strong> #
&lt;strong>/etc/default/grub&lt;/strong> #&lt;/p>
&lt;h1 id="引导管理命令行工具">引导管理命令行工具&lt;/h1>
&lt;p>grub2-*
grubby
grub2-mkconfig&lt;/p></description></item><item><title>Docs: 2.Kernel(内核)</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2.kernel%E5%86%85%E6%A0%B8/kernel%E5%86%85%E6%A0%B8/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2.kernel%E5%86%85%E6%A0%B8/kernel%E5%86%85%E6%A0%B8/</guid><description>
&lt;h2 id="操作系统-os-与内核-kernel-有什么区别">操作系统 OS 与内核 Kernel 有什么区别？&lt;/h2>
&lt;p>原文链接：&lt;a href="https://mp.weixin.qq.com/s/-5tDn2-IS6Xo6DwQJN4c3Q">https://mp.weixin.qq.com/s/-5tDn2-IS6Xo6DwQJN4c3Q&lt;/a>&lt;/p>
&lt;p>&lt;strong>通用底盘技术&lt;/strong>
Canoo 公司有一项核心技术专利，这就是它们的通用电动底盘技术，长得是这个样子，非常像一个滑板：
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/egzxwb/1624588718457-99ed8a8e-d53b-465e-8d99-4345935ad5a4.webp" alt="">
这个带轮子、有电池、能动的滑板已经包含了一辆车&lt;strong>最核心&lt;/strong>的组件，差的就是一个外壳。这个看起来像滑板的东西就是所谓的电池系统和底盘一体化技术，Canoo 公司在它们的通用底盘上加装不同的外壳就能制造出不同的车型。
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/egzxwb/1624588718511-01fe725d-cd0d-48d1-a4e8-1010d7d5a69b.png" alt="">&lt;/p>
&lt;h5 id="什么是内核">&lt;strong>什么是内核？&lt;/strong>&lt;/h5>
&lt;p>在上面这个示例中，&lt;strong>包含轮子以及电池系统的底盘就好比内核，而套上外壳加上椅子以及内饰后的整体成品就好比操作系统&lt;/strong>。内核仅仅是操作系统的一部分，是真正与硬件交互的那部分软件，与硬件交互包括读写硬盘、读写网盘、读写内存以及任何连接到系统中的硬件。除了与硬件交互外，内核还负责分配资源，分配什么资源呢？所谓资源就是硬件，比如 CPU 时间、内存、IO 等等，这些都是资源。&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/egzxwb/1624588718454-36e25783-bbc0-49ec-a620-26d8580cee9d.png" alt="">因此，内核的职责就是以进程的形式来分配 CPU 时间，以虚拟内存的形式来分配物理内存，以文件的形式来管理 IO 设备。&lt;/p>
&lt;h5 id="什么是操作系统">&lt;strong>什么是操作系统？&lt;/strong>&lt;/h5>
&lt;p>然而只有一个内核实际上是做不了什么真正有用的事情，就像上面示例中那个通用底盘一样，这个底盘确实能跑起来，但你没办法开着这样一个底盘出去浪，因为这个底盘很难用。因此，你不得不加装上方向盘、座椅以及车身外壳等，同样的道理，内核是给人用的，为了与内核交互，发明了命令行以及图形界面 GUI。&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/egzxwb/1624588718509-9945a71c-556e-4b5a-be9f-8a123c68473c.png" alt="">在 Windows 平台就是给程序员提供编程接口的是 Windows API，这层 API 包罗万象，不但包括上文提到对系统调用的封装，还包括其它功能，像创建带有图形界面的应用程序等等。&lt;strong>但在 Linux 世界你找不到一种类似 Windows API 的东西&lt;/strong>，毕竟 Windows 是微软自家产品，什么都可以打包起来，Linux 只是一个开源的内核，如果一定要找一个类似的东西话那就是 libc，也就是 C 标准库，这里同样包括了对系统调用的封装以及一些库函数，但 libc 不包含创建带有图形界面应用程序的功能。现在我们知道了，操作系统需要提供两种接口：&lt;/p>
&lt;ul>
&lt;li>给用户提供操作接口。&lt;/li>
&lt;li>给程序员提供编程接口。&lt;/li>
&lt;/ul>
&lt;p>这些就是好比汽车的外壳，我们(用户和程序员)看得见摸得着，外壳加上底盘——也就是内核，才是功能完善的操作系统。&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/egzxwb/1624588718491-8aabc98e-8938-4b52-95fd-265d5f7d95b8.webp" alt="">&lt;/p>
&lt;h5 id="各种各样的操作系统">&lt;strong>各种各样的操作系统&lt;/strong>&lt;/h5>
&lt;p>实际上我们熟悉的 Linux 只是内核而不能称得上是操作系统，Ubuntu 则可以认为是操作系统，其内核是 Linux；RedHat 也是操作系统，其内核同样是 Linux；我们可以看到，尽管 Ubuntu 和 RedHat 是不同的操作系统，但其内核可以是相同的。这就好比它们可以基于同样的底盘打造出不同的车型。而我们熟悉的 Windows 也是操作系统，其内核是 Windows NT 内核。&lt;/p>
&lt;h5 id="总结">&lt;strong>总结&lt;/strong>&lt;/h5>
&lt;p>内核就像本文开头提到的电动底盘，包含了一个汽车的最核心元素；但这样一个底盘并没有什么实际用处，当搭配上外壳以及座椅后才是一辆真正有用的车，这就好比操作系统。值得注意的是，不同的操作系统可以有相同的内核。&lt;/p>
&lt;h1 id="宏内核与微内核">宏内核与微内核&lt;/h1>
&lt;p>原文链接：&lt;a href="https://mp.weixin.qq.com/s/jIuLkapBssGnBn1IoIdWQQ">公众号-码农的荒岛求生，操作系统的实现：什么是宏内核、微内核&lt;/a>&lt;/p>
&lt;h2 id="大一统全部运行在内核态">大一统，全部运行在内核态&lt;/h2>
&lt;p>&lt;strong>最简单的划分就是没有划分&lt;/strong>，我们可以把所有内核代码放在内核态，内核中的任何代码都拥有控制硬件的全部特权，显然这种设计方法非常简单，因为操作系统设计者不用费心去想哪一部分该放在内核态。&lt;/p>
&lt;p>由于全部内核程序都运行在内核态，编译好的内核程序就是一个单独的二进制可执行文件，这时的操作系统运行起来后就是一个大进程，所有内核代码运行在一个单独的地址空间中，这和我们实现的稍微复杂的单进程应用程序类似，这种大一统的设计就是所谓的宏内核，monolithic kernel，个人认为叫“一体化内核”更形象些。&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/egzxwb/1650439475125-4fe94b34-90ba-43d8-8a9b-3c5860730e20.png" alt="">&lt;/p>
&lt;p>这种组织方式和 TCP/IP 协议栈的分层实现有点类似。&lt;/p>
&lt;p>现在内核代码已经组织好了，毕竟内核是为上层应用提供服务的，那么上层应用该怎样调用内核代码呢？这就是系统调用的作用，system call。&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/egzxwb/1650439474086-a1f789d1-05e4-4c7c-9c39-d6274ac2b0aa.png" alt="">&lt;/p>
&lt;p>上层应用程序通过系统调用与内核进行交互。&lt;/p>
&lt;p>由于内核代码唯一同一个地址空间中，因此内核中各部分的交互极为简单，就是普通的函数调用，文件系统中的某块 cache 可以非常容易的被虚拟内存系统共享使用。&lt;/p>
&lt;p>但宏内核也是有缺点的，由于内核代码位于同一个地址空间，代码趋于复杂化，复杂就容易出错，但内核和普通程序不同，一旦内核中某一模块出现 bug 将导致整个内核崩溃，底层的内核崩溃后上层的应用程序就无法继续正常推进，整个系统就下图一样。。crash&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/egzxwb/1650439474129-b3976f1b-3567-4d8a-b82d-2e5fd9e647cd.gif" alt="">&lt;/p>
&lt;p>当然也有人不在乎在这一点，Linus 认为内核中有 bug 正常，&lt;strong>有 bug 就找到它、修复它而不是用某种机制试图忽略它&lt;/strong>，没错，C++中的异常就是试图忽略 bug 的机制，这就是为什么很多公司的规范中禁止使用异常的原因。&lt;/p>
&lt;p>总之，内核崩溃后就必须重启计算机。&lt;/p>
&lt;h4 id="heading">&lt;/h4>
&lt;h2 id="保留核心非必要不留在内核">保留核心，非必要不留在内核&lt;/h2>
&lt;p>为减少内核崩溃的风险，一个简单的办法就是让内核尽量精简，只保留核心部分运行在内核态，其它代码以用户态进程的形式运行，就像这样：&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/egzxwb/1650439474079-a7429422-8348-4fe1-b423-79e30fe7763d.png" alt="">&lt;/p>
&lt;p>运行在用户态的操作系统程序被称为 server，像负责文件操作的 File Server 等，此时用户进程想要使用操作系统提供的服务的话就必须借助进程间通信，inter-process communication，即 IPC，借助内核，消息从一个进程发送到另一个进程然后等待返回。&lt;/p>
&lt;p>这样，内核只需要对上层应用提供一些简单的接口即可，像创建进程、发送消息等，这种实现方式可以让内核尽可能简单，因为大部分内核程序都运行在用户态，且运行在不同的地址空间中，此时设备驱动中的 bug 不会影响到内核，这种操作系统的实现方式就被称为微内核， micro kernel。&lt;/p>
&lt;p>就像宏内核那样，微内核也有自己的缺点，那就是性能。由于宏内核的代码都在同一个地址空间中，因此模块间的交互可以非常简单，简单的函数调用即可，但模块间交互对微内核来说则可能涉及进程间通信，看上图，如果某个应用程序需要请求使用 File Server，这条链路涉及到：&lt;/p>
&lt;pre>&lt;code>请求：应用程序 -&amp;gt; 内核 -&amp;gt; File server
返回：Filer server -&amp;gt; 内核 -&amp;gt; 应用程序
&lt;/code>&lt;/pre>
&lt;p>每一个&amp;quot;-&amp;gt;&amp;ldquo;都涉及上下文切换，而这对宏内核来说则简单很多。&lt;/p>
&lt;h4 id="heading-1">&lt;/h4>
&lt;p>&lt;strong>现实中是什么样子？&lt;/strong>&lt;/p>
&lt;p>现实的操作系统中两种实现方式都很常见，Linux 以及许多 Unix 就是典型的宏内核，而 Mac OS X 以及 Windows NT 则一般认为是微内核，华为的鸿蒙 Harmony OS 则宣传是微内核。&lt;/p></description></item><item><title>Docs: 4.CPU 管理</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2.kernel%E5%86%85%E6%A0%B8/4.cpu-%E7%AE%A1%E7%90%86/cpu-%E7%AE%A1%E7%90%86/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2.kernel%E5%86%85%E6%A0%B8/4.cpu-%E7%AE%A1%E7%90%86/cpu-%E7%AE%A1%E7%90%86/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://time.geekbang.org/column/article/69859">极客时间，Linux 性能优化实战-03 基础篇：经常说的 CPU 上下文切换是什么意思&lt;/a>&lt;/li>
&lt;li>&lt;a href="http://linuxperf.com/?p=209">LinuxPerformance 博客，进程切换：自愿与强制&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>在 Linux 中，CPU 的管理，绝大部分时间都是在进行任务的调度，所以很多时候也称为&lt;strong>调度管理&lt;/strong>。&lt;/p>
&lt;h2 id="cpu-多线程并发并行-概念">&lt;strong>CPU 多线程、并发、并行 概念&lt;/strong>&lt;/h2>
&lt;p>Node：在这里时间片只是一种描述，理解 CPU 的并行与并发概念就好&lt;/p>
&lt;p>1、CPU 时间分片、多线程？
如果线程数不多于 CPU 核心数，会把各个线程都分配一个核心，不需分片，而当线程数多于 CPU 核心数时才会分片。&lt;/p>
&lt;p>2、并发和并行的区别&lt;/p>
&lt;ul>
&lt;li>并发：当有多个线程在操作时,如果系统只有一个 CPU,把 CPU 运行时间划分成若干个时间片,分配给各个线程执行，在一个时间段的线程代码运行时，其它线程处于挂起状态。这种方式我们称之为_ _&lt;strong>Concurrent(并发)&lt;/strong>。并发=间隔发生&lt;/li>
&lt;li>并行：当系统有一个以上 CPU 时,则线程的操作有可能非并发。当一个 CPU 执行一个线程时，另一个 CPU 可以执行另一个线程，两个线程互不抢占 CPU 资源，可以同时进行，这种方式我们称之为 &lt;strong>Parallel(并行)&lt;/strong>。 并行=同时进行&lt;/li>
&lt;/ul>
&lt;p>区别：并行是指两个或者多个事件在同一时刻发生；而并发是指两个或多个事件在同一时间间隔内发生。&lt;/p>
&lt;p>并行是同时做多件事情。&lt;/p>
&lt;p>并发表示同时发生了多件事情，通过时间片切换，哪怕只有单一的核心，也可以实现“同时做多件事情”这个效果。&lt;/p>
&lt;p>根据底层是否有多处理器，并发与并行是可以等效的，这并不是两个互斥的概念。&lt;/p>
&lt;p>举个我们开发中会遇到的例子，我们说资源请求并发数达到了 1 万。这里的意思是有 1 万个请求同时过来了。但是这里很明显不可能真正的同时去处理这 1 万个请求的吧！&lt;/p>
&lt;p>如果这台机器的处理器有 4 个核心，不考虑超线程，那么我们认为同时会有 4 个线程在跑。也就是说，并发访问数是 1 万，而底层真实的并行处理的请求数是 4。如果并发数小一些只有 4 的话，又或者你的机器牛逼有 1 万个核心，那并发在这里和并行一个效果。也就是说，并发可以是虚拟的同时执行，也可以是真的同时执行。而并行的意思是真的同时执行。&lt;/p>
&lt;p>结论是：并行是我们物理时空观下的同时执行，而并发则是操作系统用线程这个模型抽象之后站在线程的视角上看到的“同时”执行。&lt;/p>
&lt;h3 id="time-slice时间片-概念">time slice(时间片) 概念&lt;/h3>
&lt;blockquote>
&lt;p>参考：&lt;a href="https://en.wikipedia.org/wiki/Preemption_(computing)#Time_slice">https://en.wikipedia.org/wiki/Preemption_(computing)#Time_slice&lt;/a>&lt;/p>
&lt;/blockquote>
&lt;p>The period of time for which a process is allowed to run in a preemptive multitasking system is generally called the &lt;em>time slice&lt;/em> or &lt;em>quantum&lt;/em>.&lt;/p>
&lt;p>&lt;strong>time slice(时间片)&lt;/strong> 是一个程序运行在&lt;a href="https://en.wikipedia.org/wiki/Preemption_(computing)">抢占式多任务系统&lt;/a>中的一段时间。也可以称为 quantum(量子)。&lt;/p>
&lt;h2 id="cpu-使用率概念">CPU 使用率概念&lt;/h2>
&lt;p>CPU 不像硬盘、内存，并不具备逻辑上数量、大小、空间之类的概念。只要使用 CPU，就是使用了这个 CPU 的全部，也就无法通过大小之类的概念来衡量一个 CPU，所以我们日常所说的 CPU 的使用率 ，实际上是指的在一段时间范围内，CPU 执行 &lt;strong>Tasks(任务)&lt;/strong> 花费时间的百分比。比如 60 分钟内，一颗 CPU 执行各种任务花费了 6 分钟，则 CPU 在这一小时时间内的使用率为 10%。&lt;/p>
&lt;blockquote>
&lt;p>上文说的 &lt;strong>Tasks(任务)&lt;/strong>，即会指系统中的进程、线程，也代表各种硬件去请求 CPU 执行的各种事情，比如网卡接收到数据，就会告诉 CPU 需要处理(i.e.中断)。&lt;/p>
&lt;/blockquote>
&lt;p>在 Linux 系统中，CPU 的使用率一般可分为 4 大类：&lt;/p>
&lt;ol>
&lt;li>User Time(用户进程运行时间)&lt;/li>
&lt;li>System Time(系统内核运行时间)&lt;/li>
&lt;li>Idle Time(空闲时间)&lt;/li>
&lt;li>Steal Time(被抢占时间)&lt;/li>
&lt;/ol>
&lt;p>除了 Idle Time 外，CPU 在其余时间都处于工作运行状态。
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/srucoz/1616168021555-68fba1de-f5d5-462d-bef6-a78b476521ad.png" alt="">&lt;/p>
&lt;p>通常而言，我们泛指的整体 CPU 使用率为 User Time 和 Systime 占比之和(例如 tsar 中 CPU util)，即：
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/srucoz/1616168021559-394ecaa6-59db-453a-b5b1-c5ab88193f49.png" alt="">&lt;/p>
&lt;p>为了便于定位问题，大多数性能统计工具都将这 4 类时间片进一步扩展成了 8 类，如下图，是在 top 命令的 man 手册中对 CPU 使用率的分类。
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/srucoz/1616168021546-ebe53556-f50b-49f2-8477-c10cf2b8f2f5.png" alt="">&lt;/p>
&lt;ul>
&lt;li>us：用户进程空间中未改变过优先级的进程占用 CPU 百分比&lt;/li>
&lt;li>sy：内核空间占用 CPU 百分比&lt;/li>
&lt;li>ni：用户进程空间内改变过优先级的进程占用 CPU 百分比&lt;/li>
&lt;li>id：空闲时间百分比&lt;/li>
&lt;li>wa：等待 I/O 的时间百分比&lt;/li>
&lt;li>hi：硬中断时间百分比&lt;/li>
&lt;li>si：软中断时间百分比&lt;/li>
&lt;li>st：虚拟化时被其余 VM 窃取时间百分比&lt;/li>
&lt;/ul>
&lt;p>这 8 类分片中，除 wa 和 id 外，其余分片 CPU 都处于工作态。&lt;/p>
&lt;h1 id="调度算法">调度算法&lt;/h1>
&lt;blockquote>
&lt;p>详见：&lt;a href="https://www.yuque.com/go/doc/33222924">CPU 调度算法&lt;/a>&lt;/p>
&lt;/blockquote>
&lt;p>首先明确一个概念：&lt;strong>Task(任务)&lt;/strong>，一个进程从处理到结束就算一个任务，处理网卡收到的数据包也算一个任务。一般来说，CPU 就是在处理一个个的 &lt;strong>Task(任务)&lt;/strong>，并度过其一生。&lt;/p>
&lt;p>在 Linux 内核中，进程和线程都是用 tark_struct 结构体表示的，区别在于线程的 tark_struct 结构体里部分资源是共享了进程已创建的资源，比如内存地址空间、代码段、文件描述符等，所以 Linux 中的线程也被称为轻量级进程，因为线程的 tark_struct 相比进程的 tark_struct 承载的 资源比较少，因此以「轻」得名。&lt;/p>
&lt;p>一般来说，没有创建线程的进程，是只有单个执行流，它被称为是主线程。如果想让进程处理更多的事情，可以创建多个线程分别去处理，但不管怎么样，它们对应到内核里都是 tark_struct。&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/srucoz/1616168021545-596ecf70-ac19-4620-8845-bfe72ef7bdce.jpeg" alt="">&lt;/p>
&lt;p>所以，Linux 内核里的调度器，调度的对象就是 tark_struct，接下来我们就把这个数据结构统称为任务。&lt;/p>
&lt;p>在 Linux 系统中，根据任务的优先级以及响应要求，主要分为两种，其中优先级的数值越小，优先级越高：&lt;/p>
&lt;ul>
&lt;li>实时任务，对系统的响应时间要求很高，也就是要尽可能快的执行实时任务，优先级在 0~99 范围内的就算实时任务；&lt;/li>
&lt;li>普通任务，响应时间没有很高的要求，优先级在 100~139 范围内都是普通任务级别；&lt;/li>
&lt;/ul>
&lt;p>也就是说，在 LInux 内核中，实时任务总是比普通任务的优先级要高。&lt;/p></description></item><item><title>Docs: 5.登录 Linux 与 访问控制</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/5.%E7%99%BB%E5%BD%95-linux-%E4%B8%8E-%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6/5.%E7%99%BB%E5%BD%95-linux-%E4%B8%8E-%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/5.%E7%99%BB%E5%BD%95-linux-%E4%B8%8E-%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6/5.%E7%99%BB%E5%BD%95-linux-%E4%B8%8E-%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;/blockquote>
&lt;p>想要登录 Linux，必须通过 [&lt;strong>Terminal(终端)&lt;/strong>](/docs/IT学习笔记/1.操作系统/4.Terminal%20 与%20Shell/4.Terminal%20 与%20Shell.md 与 Shell.md)，我们才可以与操作系统进行交互。&lt;/p>
&lt;p>本质上，想要登录 Linux，必然需要调用某些程序(比如 Shell)，以便分配一个终端。通常，我们有多种方式可供选择：&lt;/p>
&lt;ul>
&lt;li>本地命令行登录&lt;/li>
&lt;li>远程命令行登录&lt;/li>
&lt;li>图形界面登录&lt;/li>
&lt;/ul>
&lt;p>Linux 操作系统是一个多用户操作系统，所以除了 &lt;strong>Terminal(终端)&lt;/strong> 以外，还需 &lt;strong>Account(账户)&lt;/strong> 才可以登录上去，Linux 操作系统允许多个用户访问安装在一台机器上的单个系统。每个 &lt;strong>User(用户)&lt;/strong> 都在自己的 &lt;strong>Account(账户)&lt;/strong> 下操作。因此，Account Manager 代表了 Linux 系统管理的核心要素。&lt;/p>
&lt;h1 id="登录-linux">登录 Linux&lt;/h1>
&lt;p>我们可以通过多种方式登录 Linux&lt;/p>
&lt;ul>
&lt;li>本地登录&lt;/li>
&lt;li>远程登录&lt;/li>
&lt;/ul>
&lt;h2 id="通过本地-tty-登陆-linux-系统">通过本地 TTY 登陆 Linux 系统&lt;/h2>
&lt;p>登录 Linux 最基本的方式，就是使用 &lt;code>login&lt;/code> 程序。&lt;/p>
&lt;h3 id="login-程序">login 程序&lt;/h3>
&lt;p>由于历史原因，&lt;code>login&lt;/code> 可能被包含在两个包中：&lt;/p>
&lt;ul>
&lt;li>util-linux&lt;/li>
&lt;li>shadow-utils&lt;/li>
&lt;/ul>
&lt;h4 id="login-的登录行为">login 的登录行为&lt;/h4>
&lt;p>当我们刚刚安装完操作系统，systemd-logind.service 服务会让我们看到这样的画面
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/gwpmr6/1634785246289-3a353c73-2899-4b6c-8341-ffc4a02008ef.png" alt="image.png">
想要在服务器本地登录系统，则需要进行认证，在输入用户名之后，实际上是调用了 &lt;code>login&lt;/code> 这个二进制程序，看到：
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/gwpmr6/1634785206973-885fa7fb-3dfb-4fb1-80c8-1c56cb903974.png" alt="image.png">
此时我们通过远程方式(如果可以的话)登录服务器，查看进程，将会看到名为 login 的进程&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>~&lt;span style="color:#f92672">]&lt;/span>$ pgrep login -alf
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">600&lt;/span> /lib/systemd/systemd-logind
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">1476&lt;/span> /bin/login -p --
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>当我们输入完密码，经过[访问控制](/docs/IT学习笔记/1.操作系统/5.登录%20Linux%20 与%20 访问控制/Access%20Control(访问控制).md Linux 与 访问控制/Access Control(访问控制).md)相关程序的认证之后，login 工具会为我们分配一个 ttyX 的终端设备，然后我们就可以通过 tty 所关联的 Shell(通常是 bash)，与系统进行交互
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/gwpmr6/1634785329507-0cb1fcec-8c6e-4fd0-a99f-005a2b19807e.png" alt="image.png">&lt;/p>
&lt;h4 id="login-关联文件与配置">login 关联文件与配置&lt;/h4>
&lt;p>&lt;strong>/etc/login.defs&lt;/strong> # shadow 与 password 套件的配置文件。
&lt;strong>/etc/pam.d/login&lt;/strong> #&lt;/p>
&lt;h2 id="通过远程的方式来登陆-linux-系统">通过远程的方式来登陆 Linux 系统&lt;/h2>
&lt;h3 id="ssh-程序">ssh 程序&lt;/h3>
&lt;p>详见：&lt;a href="https://www.yuque.com/go/doc/33222417">Secure Shell(SSH) 安全外壳协议&lt;/a>&lt;/p>
&lt;pre>&lt;code>root 981 1 0 Jul08 ? Ss 0:00 /usr/sbin/sshd -D
root 1947 981 0 09:05 ? Ss 0:00 \_ sshd: root@pts/0
root 1949 1947 1 09:05 pts/0 Ss 0:00 \_ -bash
root 1970 1949 0 09:05 pts/0 R+ 0:00 \_ ps -ef f
&lt;/code>&lt;/pre>
&lt;p>OpenSSH 会为用户分配一个 Pseudoterminal(伪终端，即 pts) 以便用户可以与操作系统进行交互。&lt;/p>
&lt;h1 id="登录提示信息">登录提示信息&lt;/h1>
&lt;p>通过 &lt;code>touch ~/.hushlogin&lt;/code> 命令可以为当前用户禁用欢迎信息。&lt;/p>
&lt;h2 id="motd">MOTD&lt;/h2>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Motd_(Unix)">Wiki:MOTD&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://man7.org/linux/man-pages/man5/motd.5.html">Manual(手册),MOTD&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>&lt;strong>Message of the day(每日消息，简称 MOTD)&lt;/strong> 是一种比向所有用户发送一个邮件更有效的发送共同的信息的方式&lt;/p>
&lt;h4 id="motd-关联文件">MOTD 关联文件&lt;/h4>
&lt;p>**/etc/default/motd-news **# 动态 MOTD 新闻信息配置，新闻信息主要是互联网相关的
**/etc/update-motd.d/* **# MOTD 执行脚本保存路径
&lt;strong>~/.hushlogin&lt;/strong> # 该文件存在时，将为当前用户禁用 MOTD 消息
&lt;strong>/etc/pam.d/sshd&lt;/strong> # PAM 模块中可以为 sshd 配置 MOTD。&lt;/p>
&lt;h1 id="访问控制">访问控制&lt;/h1>
&lt;p>Linux 的登录与访问控制是相辅相成的，一个用户想要登录 Linux，通常来说都需要经过访问控制系统对其所使用的账户进行认证，只有认证通过后，才可以正常登录。&lt;/p>
&lt;p>一个正常的 Linux 发行版操作系统，通常都提供了多种方式&lt;/p>
&lt;ul>
&lt;li>密码&lt;/li>
&lt;li>会话&lt;/li>
&lt;li>账户锁定&lt;/li>
&lt;li>等等&amp;hellip;&amp;hellip;&lt;/li>
&lt;/ul>
&lt;h2 id="account-manager账户管理">Account Manager(账户管理)&lt;/h2>
&lt;p>详见 [Account Manager(账户管理)](/docs/IT学习笔记/1.操作系统/5.登录%20Linux%20 与%20 访问控制/Account%20Manager(账户管理).md Linux 与 访问控制/Account Manager(账户管理).md)&lt;/p></description></item><item><title>Docs: 6.Package 管理</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/6.package-%E7%AE%A1%E7%90%86/package-%E7%AE%A1%E7%90%86/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/6.package-%E7%AE%A1%E7%90%86/package-%E7%AE%A1%E7%90%86/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;/blockquote>
&lt;p>在 Linux 操作系统中，Package 就是指应用程序的安装包。保存 Package 的地方(网站、ISO 等)称为 &lt;strong>Repository(简称 Repo)&lt;/strong>，我们可以从各种 Linux 发行版的官方 Repo 中下载对应的可用的 Package，以安装到这些发行版的 Linux 系统中。&lt;/p>
&lt;blockquote>
&lt;p>注意：哪怕两个发行版的包管理器相同，也不代表他们的 Package 是可以公用的，比如 CentOS 和 OpenEuler 都用 yum，但是 CentOS 的 Package 是无法装在 OpenEuler 上的，安装时将会报错(比如包与包之间 &lt;strong>conflict(冲突)&lt;/strong>)&lt;/p>
&lt;/blockquote>
&lt;h1 id="linux-各发行版的官方-repo-站点">Linux 各发行版的官方 Repo 站点&lt;/h1>
&lt;ul>
&lt;li>包含很多发行版的 Repo 站点: &lt;a href="https://pkgs.org/">https://pkgs.org/&lt;/a>&lt;/li>
&lt;li>OpenEuler: &lt;a href="https://repo.openeuler.org/">https://repo.openeuler.org/&lt;/a>&lt;/li>
&lt;li>CentOS: &lt;a href="https://centos.pkgs.org/">https://centos.pkgs.org/&lt;/a>&lt;/li>
&lt;li>Ubuntu: &lt;a href="https://packages.ubuntu.com/">https://packages.ubuntu.com/&lt;/a>
&lt;ul>
&lt;li>在这里可以找到 jammy 版本(20.04 TLS)的所有软件包列表: &lt;a href="https://packages.ubuntu.com/jammy/allpackages">https://packages.ubuntu.com/jammy/allpackages&lt;/a>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul></description></item><item><title>Docs: 7.Process 管理</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2.kernel%E5%86%85%E6%A0%B8/7.process-%E7%AE%A1%E7%90%86/process-%E7%AE%A1%E7%90%86/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2.kernel%E5%86%85%E6%A0%B8/7.process-%E7%AE%A1%E7%90%86/process-%E7%AE%A1%E7%90%86/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://blog.csdn.net/ljianhui/article/details/46718835">原文连接&lt;/a>，本文为 IBM RedBook 的 &lt;a href="http://users.polytech.unice.fr/~bilavarn/fichier/elec5_linux/linux_perf_and_tuning_IBM.pdf">Linux Performanceand Tuning Guidelines&lt;/a> 的 1.1 节的翻译&lt;/li>
&lt;li>&lt;a href="https://mp.weixin.qq.com/s/fzLcAkYwKhj-9hgoVkTzaw">阿里技术，CPU 飙高，系统性能问题如何排查？&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>进程管理是操作系统的最重要的功能之一。有效率的进程管理能保证一个程序平稳而高效地运行。它包括进程调度、中断处理、信号、进程优先级、上下文切换、进程状态、进度内存等。&lt;/p>
&lt;p>&lt;strong>Process(进程)&lt;/strong> 实际是运行在 CPU 中的一个** Program(应用程序) 的实体**。在 Linux 系统中，能够同时运行多个进程，Linux 通过在短的时间间隔内轮流运行这些进程而实现“多任务”。这一短的时间间隔称为“时间片”，让进程轮流运行的方法称为“进程调度” ，完成调度的程序称为调度程序。&lt;/p>
&lt;p>进程调度控制进程对 CPU 的访问。当需要选择下一个进程运行时，由调度程序选择最值得运行的进程。可运行进程实际上是仅等待 CPU 资源的进程，如果某个进程在等待其它资源，则该进程是不可运行进程。Linux 使用了比较简单的基于优先级的进程调度算法选择新的进程。&lt;/p>
&lt;p>通过多任务机制，每个进程可认为只有自己独占计算机，从而简化程序的编写。每个进程有自己单独的地址空间，并且只能由这一进程访问，这样，操作系统避免了进程之间的互相干扰以及“坏”程序对系统可能造成的危害。 为了完成某特定任务，有时需要综合两个程序的功能，例如一个程序输出文本，而另一个程序对文本进行排序。为此，操作系统还提供进程间的通讯机制来帮助完成这样的任务。Linux 中常见的进程间通讯机制有信号、管道、共享内存、信号量和套接字等。&lt;/p>
&lt;p>内核通过 SCI 提供了一个 API 来创建一个新进程(fork、exec 或 Portable Operating System Interface [POSⅨ] 函数)、停止进程(kill、exit)、并在它们之间进行通信和同步(signal 或者 POSⅨ 机制)。&lt;/p>
&lt;p>计算机实际上可以做的事情实质上非常简单，比如计算两个数的和，再比如在内存中寻找到某个地址等等。这些最基础的计算机动作被称为指令(instruction)。所谓的程序(program)，就是这样一系列指令的所构成的集合。通过程序，我们可以让计算机完成复杂的操作。程序大多数时候被存储为可执行的文件。这样一个可执行文件就像是一个菜谱，计算机可以按照菜谱作出可口的饭菜。&lt;/p>
&lt;p>Program(程序) 和 Process(进程) 的区别是什么呢?&lt;/p>
&lt;ol>
&lt;li>在很久很久以前，计算机刚出现的时候，是没有操作系统的，那时候一台机器只是运行一个程序，得出数据，后来人们为了同时运行多个程序从而研究出了操作系统，在操作系统之上可以运行多个程序&lt;/li>
&lt;li>进程是程序的一个具体实现。类似于按照食谱，真正去做菜的过程。同一个程序可以执行多次，每次都可以在内存中开辟独立的空间来装载，从而产生多个进程。不同的进程还可以拥有各自独立的 IO 接口。&lt;/li>
&lt;/ol>
&lt;p>操作系统的一个重要功能就是为进程提供方便，比如说为进程分配内存空间，管理进程的相关信息等等，就好像是为我们准备好了一个精美的厨房。&lt;/p>
&lt;h2 id="进程的生命周期">进程的生命周期&lt;/h2>
&lt;p>每一个进程都有其生命周期，例如创建、运行、终止和消除。这些阶段会在系统启动和运行中重复无数次。因此，进程的生命周期对于其性能的分析是非常重要的。下图展示了经典的进程生命周期。
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/ld23ik/1616167507353-2f676d82-88da-483c-a939-399f284d6425.jpeg" alt="">
不会关闭的常驻进程可以称为 &lt;strong>Daemon Process(守护进程，简称 Daemon)&lt;/strong>&lt;/p>
&lt;blockquote>
&lt;p>一般 daemon 的名称都会在进程名后加一个字母 d 作为 daemon 的 process，比如 vsftp 的 daemon 就是 vsftpd。&lt;/p>
&lt;/blockquote>
&lt;p>当一个进程创建一个新的进程，创建进程(父进程)的进程调用 一个 fork() 系统调用。当 fork() 系统调用被调用，它得到该新创建进程（子进程）的进程描述并调用一个新的进程 id。它复制该值到父进程进程描述到子进程中。此时整个的父进程的地址空间是没有被复制的；父子进程共享相同的地址空间。&lt;/p>
&lt;p>exec() 系统调用复制新的程序到子进程的地址空间。因为父子进程共享地址空间，写入一个新的程序的数据会引起一个分页错误。在这种情况下，内存会分配新的物理内存页给子进程。&lt;/p>
&lt;p>这个推迟的操作叫作写时复制。子进程通常运行他们自己的程序而不是与父进程运行相同的程序。这个操作避免了不必要的开销，因为复制整个地址空间是一个非常缓慢和效率低下的操作，它需要使用大量的处理器时间和资源。&lt;/p>
&lt;p>当程序已经执行完成，子进程通过调用 exit()系统调用终止。exit()系统调用释放进程大部分的数据并通过发送一个信号通知其父进程。此时，子进程是一个被叫作僵尸进程的进程（参阅 page 7 的“Zombie processes”）。&lt;/p>
&lt;p>子进程不会被完全移除直到其父进程知道其子进程的调用 wait()系统调用而终止。当父进程被通知子进程终止，它移除子进程的所有数据结构并释放它的进程描述。&lt;/p>
&lt;h2 id="父进程与子进程">父进程与子进程&lt;/h2>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/ld23ik/1616167507409-d531245f-abbe-4a2a-b575-d2ae72c6949f.jpeg" alt="">&lt;/p>
&lt;ul>
&lt;li>用颜色的线标示的两列，左侧的为进程号(PID)右侧的为父进程号(PPID)&lt;/li>
&lt;li>子进程与父进程的环境变量相同&lt;/li>
&lt;li>老进程成为新进程的父进程(parent process)，而相应的，新进程就是老的进程的子进程(child process)。一个进程除了有一个 PID 之外，还会有一个 PPID(parent PID)来存储的父进程 PID。如果我们循着 PPID 不断向上追溯的话，总会发现其源头是 init 进程。所以说，所有的进程也构成一个以 init 为根的树状结构。&lt;/li>
&lt;li>如上图所示，我们查询当前 shell 下的进程：
&lt;ul>
&lt;li>我们可以看到，第二个进程 ps 是第一个进程 bash 的子进程。&lt;/li>
&lt;li>还可以用 &lt;code>pstree&lt;/code> 命令来显示整个进程树。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>fork() 通常作为一个函数被调用。这个函数会有两次返回，将子进程的 PID 返回给父进程，0 返回给子进程。实际上，子进程总可以查询自己的 PPID 来知道自己的父进程是谁，这样，一对父进程和子进程就可以随时查询对方。&lt;/li>
&lt;li>通常在调用 fork 函数之后，程序会设计一个 if 选择结构。当 PID 等于 0 时，说明该进程为子进程，那么让它执行某些指令,比如说使用 exec 库函数(library function)读取另一个程序文件，并在当前的进程空间执行 (这实际上是我们使用 fork 的一大目的: 为某一程序创建进程)；而当 PID 为一个正整数时，说明为父进程，则执行另外一些指令。由此，就可以在子进程建立之后，让它执行与父进程不同的功能。&lt;/li>
&lt;/ul>
&lt;h3 id="子进程的-termination终结">子进程的 termination(终结)&lt;/h3>
&lt;p>当子进程终结时，它会通知父进程，并清空自己所占据的内存，并在内核里留下自己的退出信息(exit code，如果顺利运行，为 0；如果有错误或异常状况，为&amp;gt;0 的整数)。在这个信息里，会解释该进程为什么退出。父进程在得知子进程终结时，有责任对该子进程使用 wait 系统调用。这个 wait 函数能从内核中取出子进程的退出信息，并清空该信息在内核中所占据的空间。但是，如果父进程早于子进程终结，子进程就会成为一个孤儿(orphand)进程。孤儿进程会被过继给 init 进程，init 进程也就成了该进程的父进程。init 进程负责该子进程终结时调用 wait 函数。&lt;/p>
&lt;p>当然，一个糟糕的程序也完全可能造成子进程的退出信息滞留在内核中的状况（父进程不对子进程调用 wait 函数），这样的情况下，子进程成为僵尸(zombie)进程。当大量僵尸进程积累时，内存空间会被挤占。&lt;/p>
&lt;h2 id="thread线程">Thread(线程)&lt;/h2>
&lt;p>一个线程是一个单独的进程生成的一个执行单元。它与其他的线程并行地运行在同一个进程中。各个线程可以共享进程的资源，例如内存、地址空间、打开的文件等等。它们能访问相同的程序数据集。线程也被叫作轻量级的进程（Light Weight Process，LWP）。因为它们共享资源，所以每个线程不应该在同一时间改变它们共享的资源。互斥的实现、锁、序列化等是用户程序的责任。&lt;/p>
&lt;p>从性能的角度来说，创建线程的开销比创建进程少，因数创建一个线程时不需要复制资源。另一方面，进程和线程拥在调度算法上有相似的特性。&lt;strong>内核以相似的方式处理它们&lt;/strong>。
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/ld23ik/1616167507380-b6ae3b1e-b47c-454c-b3c7-9942dde4f480.jpeg" alt="">
所以，一个进程创建的线程，也是可以运行在多个 CPU 上的。
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/ld23ik/1616645843002-c07df4a7-3d7a-4969-8203-4bc20169721a.png" alt="image.png">
在现在的 Linux 实现中，线程支持 UNIX 的可移植操作系统接口（POSIX）标准库。在 Linux 操作系统中有几种可用的线程实现。以下是广泛使用的线程库：&lt;/p>
&lt;p>Linux Threads 自从 Linux 内核 2.0 起就已经被作为默认的线程实现。Linux Threads 的一些实现并不符合 POSIX 标准。Native POSIX Thread Library（NPTL）正在取代 Linux Threads。Linux Threads 在将来的 Linux 企业发行版中将不被支持。&lt;/p>
&lt;p>Native POSIX Thread Libary（NPTL）&lt;/p>
&lt;p>NPTL 最初是由红帽公司开发的。NPTL 与 POSIX 更加兼容。通过 Linux 内核 2.6 的高级特性，例如，新的 clone()系统调用、信号处理的实现等等，它具有比 LinuxThreads 更高的性能和伸缩性。&lt;/p>
&lt;p>NPTL 与 LinuxThreads 有一些不兼容。一个依赖于 LinuxThreads 的应用可能不能在 NPTL 实现中工作。&lt;/p>
&lt;p>Next Generation POSIX Thread（NGPT）&lt;/p>
&lt;p>NGPT 是一个 IBM 开发的 POSIX 线程库。现在处于维护阶段并且在未来也没有开发计划。&lt;/p>
&lt;p>使用 LD_ASSUME_KERNEL 环境变量，你可以选择在应用中使用哪一个线程库。&lt;/p>
&lt;h2 id="linux-内核代码中的-process">Linux 内核代码中的 Process&lt;/h2>
&lt;p>在 Linux 中，&lt;strong>Process(进程) 属于&lt;/strong> &lt;strong>Task(任务)&lt;/strong> 的一种类型，都被 task_struct 结构管理，该结构同时被叫作进程描述。一个进程描述包含一个运行进程所有的必要信息，例如进程标识、进程属性和构建进程的资源。如果你了解该进程构造，你就能理解对于进程的运行和性能来说，什么是重要的。&lt;/p>
&lt;p>v5.14 代码：&lt;a href="https://github.com/torvalds/linux/blob/v5.14/include/linux/sched.h#L661">include/linux/sched.h&lt;/a>&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-c" data-lang="c">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">struct&lt;/span> task_struct {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#ifdef CONFIG_THREAD_INFO_IN_TASK
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#75715e">/*
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> * For reasons of header soup (see current_thread_info()), this
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> * must be the first element of task_struct.
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> */&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">struct&lt;/span> thread_info thread_info;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#endif
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> ......
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 进程状态
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">unsigned&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span> __state;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 进程唯一标识符
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">pid_t&lt;/span> pid;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">pid_t&lt;/span> tgid;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 进程名称，上限 16 字符
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">char&lt;/span> comm[TASK_COMM_LEN];
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 打开的文件
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">struct&lt;/span> files_struct &lt;span style="color:#f92672">*&lt;/span>files;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ......
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>下图展示了进程结构相关的进程信息概述。
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/ld23ik/1616167507336-aaeec645-b9df-41c3-99ab-6bf39aed4f42.jpeg" alt="">
其实从这里能看出来，从某种角度来看，**对于内核来说并没有线程这个概念。Linux 把所有的线程都当做进程来实现，内核也没有特别的调度算法来处理线程。**线程仅仅被视为一个与其他进程共享某些资源的进程，和进程一样，每个线程也都是有自己的 &lt;code>task_struct&lt;/code>，所以在内核中，线程看起来就是一个普通的进程。线程也被称作轻量级进程，一个进程可以有多个线程，线程拥有自己独立的栈，切换也由操作系统调度。在 Linux 上可以通过 &lt;code>pthread_create()&lt;/code> 方法或者 &lt;code>clone()&lt;/code> 系统调用创建；&lt;/p>
&lt;h1 id="进程优先级和-nice-值">进程优先级和 nice 值&lt;/h1>
&lt;p>进程优先级是一个数值，它通过动态的优先级和静态的优先级来决定进程被 CPU 处理的顺序。一个拥有更高进程优先级的进程拥有更大的机率得到处理器的处理。&lt;/p>
&lt;p>内核根据进程的行为和特性使用试探算法，动态地调整调高或调低动态优先级。一个用户进程可以通过使用进程的 nice 值间接改变静态优先级。一个拥有更高静态优先级的进程将会拥有更长的时间片（进程能在处理上运行多长时间）。&lt;/p>
&lt;p>Linux 支持从 19（最低优先级）到-20（最高优先级）的 nice 值。默认值为 0。把程序的 nice 值修改为负数（使进程的优先级更高），需要以 root 身份登陆或使用 su 命令以 root 身份执行。&lt;/p>
&lt;h1 id="上下文切换">上下文切换&lt;/h1>
&lt;p>在进程运行过程中，进程的运行信息被保存于处理器的寄存器和它的缓存中。正在执行的进程加载到寄存器中的数据集被称为上下文。为了切换进程，运行中进程的上下文将会被保存，接下来的运行进程的上下文将被被恢复到寄存器中。进程描述和内核模式堆栈的区域将会用来保存上下文。这个切换被称为上下文切换。过多的上下文切换是不受欢迎的，因为处理器每次都必须清空刷新寄存器和缓存，为新的进程制造空间。它可能会引起性能问题。&lt;/p>
&lt;p>下图说明了上下文切换如何工作。
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/ld23ik/1616167507475-6f5a9385-f033-4c00-8344-2953197b973c.jpeg" alt="">&lt;/p>
&lt;h1 id="中断处理">中断处理&lt;/h1>
&lt;p>中断处理是优先级最高的任务之一。中断通常由 I/O 设备产生，例如网络接口卡、键盘、磁盘控制器、串行适配器等等。中断处理器通过一个事件通知内核（例如，键盘输入、以太网帧到达等等）。它让内核中断进程的执行，并尽可能快地执行中断处理，因为一些设备需要快速的响应。它是系统稳定的关键。当一个中断信号到达内核，内核必须切换当前的进程到一个新的中断处理进程。这意味着中断引起了上下文切换，因此大量的中断将会引起性能的下降。&lt;/p>
&lt;p>在 Linux 的实现中，有两种类型的中断。硬中断是由请求响应的设备发出的（磁盘 I/O 中断、网络适配器中断、键盘中断、鼠标中断）。软中断被用于处理可以延迟的任务（TCP/IP 操作，SCSI 协议操作等等）。你可以在 &lt;code>/proc/interrupts&lt;/code> 文件中查看硬中断的相关信息。&lt;/p>
&lt;p>在多处理器的环境中，中断被每一个处理器处理。绑定中断到单个的物理处理中能提高系统的性能。更多的细节，请参阅 4.4.2，“CPU 的中断处理亲和力”。&lt;/p>
&lt;h1 id="进程的状态">进程的状态&lt;/h1>
&lt;p>每一个进程拥有自己的状态，状态表示了进程当前在发生什么。LINUX 2.6 以后的内核中，在进程的执行期间进程的状态会发生改变，进程一般存在 7 种基础状态：D-不可中断睡眠、R-可执行、S-可中断睡眠、T-暂停态、t-跟踪态、X-死亡态、Z-僵尸态，这几种状态在 ps 命令的 man 手册中有对应解释。&lt;/p>
&lt;ul>
&lt;li>**D **＃不间断的睡眠（通常是 IO）&lt;/li>
&lt;li>&lt;strong>R&lt;/strong> ＃正在运行或可运行（在运行队列上）&lt;/li>
&lt;li>&lt;strong>S&lt;/strong> ＃可中断的睡眠（等待事件完成）&lt;/li>
&lt;li>&lt;strong>T&lt;/strong> ＃被作业控制信号停止&lt;/li>
&lt;li>**t **＃在跟踪过程中被调试器停止&lt;/li>
&lt;li>&lt;strong>X&lt;/strong> ＃已死（永远都不会出现）&lt;/li>
&lt;li>&lt;strong>Z&lt;/strong> ＃已终止运行（“僵尸”）的进程，已终止但未由其父进程获得&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/ld23ik/1616167507456-ca89ed8d-d8a1-4cd6-96ab-c78372840f4a.jpeg" alt="">&lt;/p>
&lt;h2 id="d-task_uninterruptible不可中断睡眠态">D (TASK_UNINTERRUPTIBLE)，不可中断睡眠态。&lt;/h2>
&lt;p>顾名思义，位于这种状态的进程处于睡眠中，并且不允许被其他进程或中断(异步信号)打断。因此这种状态的进程，是无法使用 kill -9 杀死的(kill 也是一种信号)，除非重启系统(没错，就是这么头硬)。不过这种状态一般由 I/O 等待(比如磁盘 I/O、网络 I/O、外设 I/O 等)引起，出现时间非常短暂，大多很难被 PS 或者 TOP 命令捕获(除非 I/O HANG 死)。SLEEP 态进程不会占用任何 CPU 资源。&lt;/p>
&lt;h2 id="r-task_running可执行态">R (TASK_RUNNING)，可执行态。&lt;/h2>
&lt;p>这种状态的进程都位于 CPU 的可执行队列中，正在运行或者正在等待运行，即不是在上班就是在上班的路上。&lt;/p>
&lt;p>在此状态下，表示进程正在 CPU 中运行或在队列中等待运行（运行队列）。&lt;/p>
&lt;h2 id="s-task_interruptible可中断睡眠态">S (TASK_INTERRUPTIBLE)，可中断睡眠态。&lt;/h2>
&lt;p>不同于 D，这种状态的进程虽然也处于睡眠中，但是是允许被中断的。这种进程一般在等待某事件的发生（比如 socket 连接、信号量等），而被挂起。一旦这些时间完成，进程将被唤醒转为 R 态。如果不在高负载时期，系统中大部分进程都处于 S 态。SLEEP 态进程不会占用任何 CPU 资源。&lt;/p>
&lt;p>在此状态下，进程被暂停并等待一个某些条件状态的到达。如果一个进程处于 TASK_INTERRUPTIBLE 状态并接收到一个停止的信号，进程的状态将会被改变并中断操作。一个典型的 TASK_INTERRUPTIBLE 状态的进程的例子是一个进程等待键盘中断。&lt;/p>
&lt;h2 id="t--t-task_stopped--task_traced暂停-or-跟踪态">T &amp;amp; t (TASK_STOPPED &amp;amp; TASK_TRACED)，暂停 or 跟踪态。&lt;/h2>
&lt;p>这种两种状态的进程都处于运行停止的状态。不同之处是暂停态一般由于收到 SIGSTOP、SIGTSTP、SIGTTIN、SIGTTOUT 四种信号被停止，而跟踪态是由于进程被另一个进程跟踪引起(比如 gdb 断点）。暂停态进程会释放所有占用资源。&lt;/p>
&lt;p>TASK_STOPPED 在此状态下的进程被某些信号（如 SIGINT，SIGSTOP）暂停。进程正在等待通过一个信号恢复运行，例如 SIGCONT。&lt;/p>
&lt;h2 id="z-exit_zombietask_zombie-僵尸态">Z (EXIT_ZOMBIE/TASK_ZOMBIE), 僵尸态。&lt;/h2>
&lt;p>这种状态的进程实际上已经结束了，但是父进程还没有回收它的资源（比如进程的描述符、PID 等）。僵尸态进程会释放除进程入口之外的所有资源。&lt;/p>
&lt;p>当一个进程调用 exit()系统调用退出后，它的父进程应该知道该进程的终止。处于 TASK_ZOMBIE 状态的进程会等待其父进程通知其释放所有的数据结构。&lt;/p>
&lt;p>当一个进程接收到一个信号而终止，它在结束自己之前，通常需要一些时间来结束所有的任务（例如关闭打开的文件）。在这个通常非常短暂的时间内，该进程就是一个僵尸进程。&lt;/p>
&lt;p>进程已经完成所有的关闭任务后，它会向父进程报告其即将终止。有些时候，一个僵尸进程不能把自己终止，这将会引导它的状态显示为 z（zombie）。&lt;/p>
&lt;p>使用 kill 命令来关闭这样的一个进程是不可能的，因为该进程已经被认为已经死掉了。如果你不能清除僵尸进程，你可以结束其父进程，然后僵尸进程也随之消失。但是，如果父进程为 init 进程，你不能结束它。init 进程是一个非常重要的进程，因此可能需要重启系统来清除僵尸进程。&lt;/p>
&lt;h2 id="x-exit_dead-死亡态">X (EXIT_DEAD), 死亡态。&lt;/h2>
&lt;p>进程的真正结束态，这种状态一般在正常系统中捕获不到。&lt;/p>
&lt;h1 id="进程内存段">进程内存段&lt;/h1>
&lt;p>进程使用其自身的内存区域来执行工作。工作的变化根据情况和进程的使用而决定。进程可以拥有不同的工作量特性和不同的数据大小需求。进程必须处理各种数据大小。为了满足需求，Linux 内核为每个进程使用动态申请内存的机制。进程内存分配的数据结构如图 1-7 所示。&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/ld23ik/1616167507458-2bbc9553-910c-4d66-9ad1-8f45893277da.jpeg" alt="">&lt;/p>
&lt;p>图 1-7 进程地址空间&lt;/p>
&lt;p>进程内存区由以下几部分组成：&lt;/p>
&lt;p>Text 段&lt;/p>
&lt;p>该区域用于存储运行代码。&lt;/p>
&lt;p>Data 段&lt;/p>
&lt;p>数据段包括三个区域。&lt;/p>
&lt;p>– Data：该区域存储已被初始化的数据，如静态变量。&lt;/p>
&lt;p>– BSS：该区域存储初始化为 0 的数据。数据被初始化为 0。&lt;/p>
&lt;p>– Heap：该区域用于根据需求使用 malloc()动态申请的内存。堆向高地址方向增长。&lt;/p>
&lt;p>Stack 段&lt;/p>
&lt;p>该区域用于存储局部变量、函数参数和返回函数的地址。栈向低地址方向增长。&lt;/p>
&lt;p>用户进程的地址空间内存分布可以使用 pmap 命令来查看。你可以使用 ps 命令来查看内存段的大小。可以参阅 2.3.10 的“pmap”，“ps 和 pstree”。&lt;/p>
&lt;h1 id="进程的-exit-code退出码">进程的 exit code(退出码)&lt;/h1>
&lt;p>在 Linux 系统中，程序可以在执行终止后传递值给其父进程，这个值被称为 &lt;strong>exit code(退出码)&lt;/strong> 或 **exit status(退出状态)**或 &lt;strong>reture status(返回码)&lt;/strong>。在 POSIX 系统中，惯例做法是当程序成功执行时 **exit code 为 0 **，当程序执行失败时 **exit code 非 0 **。&lt;/p>
&lt;p>传递状态码为何重要？如果你在命令行脚本上下文中查看状态码，答案显而易见。任何有用的脚本，它将不可避免地要么被其他脚本所使用，要么被 bash 单行脚本包裹所使用。特别是脚本被用来与自动化工具 SaltStack 或者监测工具 Nagios 配合使用。这些工具会执行脚本并检查它的状态，来确定脚本是否执行成功。&lt;/p>
&lt;p>其中最重要的原因是，即使你不定义状态码，它仍然存在于你的脚本中。如果你不定义恰当的退出码，执行失败的脚本可能会返回成功的状态，这样会导致问题，问题大小取决于你的脚本做了什么。&lt;/p>
&lt;p>Linux 提供了一个专门的变量$?来保存上个已执行命令的退出状态码。&lt;/p>
&lt;p>对于需要进行检查的命令，必须在其运行完毕后立刻查看或使用$?变量，它的值会变成由 shell 所执行的最后一条命令的退出状态码。&lt;/p>
&lt;p>一个成功结束的命令的退出状态码是 0，如果一个命令结束时有错误，退出状态码就是一个正数值（1-255）。&lt;/p>
&lt;p>Linux 上执行 exit 可使 shell 以指定的状态值退出。若不设置状态值参数，则 shell 以预设值退出。状态值 0 代表执行成功，其他值代表执行失败。exit 也可用在 script，离开正在执行的 script，回到 shell。&lt;/p>
&lt;p>Linux 错误退出状态码没有什么标准可循，但有一些可用的参考。&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/ld23ik/1616167507500-9f1aab01-171b-4ece-a6fa-9f576852a403.webp" alt="">&lt;/p>
&lt;p>关于具体的服务，相应的退出码，由开发者代码决定。&lt;/p>
&lt;p>&lt;strong>Linux 进程退出码&lt;/strong>&lt;/p>
&lt;p>&lt;a href="https://jin-yang.github.io/post/linux-process-exit-code-introduce.html">https://jin-yang.github.io/post/linux-process-exit-code-introduce.html&lt;/a>&lt;/p>
&lt;p>&lt;strong>Linux 退出状态码及 exit 命令&lt;/strong>&lt;/p>
&lt;p>&lt;a href="https://www.cnblogs.com/01-single/p/7206664.html">https://www.cnblogs.com/01-single/p/7206664.html&lt;/a>&lt;/p>
&lt;p>&lt;strong>理解 Exit Code 并学会如何在 Bash 脚本中使用&lt;/strong>&lt;/p>
&lt;p>&lt;a href="http://blog.jayxhj.com/2016/02/understanding-exit-codes-and-how-to-use-them-in-bash-scripts">http://blog.jayxhj.com/2016/02/understanding-exit-codes-and-how-to-use-them-in-bash-scripts&lt;/a>&lt;/p>
&lt;p>&lt;strong>Appendix E. Exit Codes With Special Meanings&lt;/strong>&lt;/p>
&lt;p>&lt;a href="http://www.tldp.org/LDP/abs/html/exitcodes.html">http://www.tldp.org/LDP/abs/html/exitcodes.html&lt;/a>&lt;/p>
&lt;p>&lt;strong>What is the authoritative list of Docker Run exit codes?&lt;/strong>&lt;/p>
&lt;p>&lt;a href="https://stackoverflow.com/questions/31297616/what-is-the-authoritative-list-of-docker-run-exit-codes">https://stackoverflow.com/questions/31297616/what-is-the-authoritative-list-of-docker-run-exit-codes&lt;/a>&lt;/p>
&lt;p>&lt;strong>Identifying Exit Codes and their meanings&lt;/strong>&lt;/p>
&lt;p>&lt;a href="https://support.circleci.com/hc/en-us/articles/360002341673-Identifying-Exit-Codes-and-their-meanings">https://support.circleci.com/hc/en-us/articles/360002341673-Identifying-Exit-Codes-and-their-meanings&lt;/a>&lt;/p>
&lt;p>&lt;strong>OpenShift Exit Status Codes&lt;/strong>&lt;/p>
&lt;p>&lt;a href="https://access.redhat.com/documentation/en-US/OpenShift_Online/2.0/html/Cartridge_Specification_Guide/Exit_Status_Codes.html">https://access.redhat.com/documentation/en-US/OpenShift_Online/2.0/html/Cartridge_Specification_Guide/Exit_Status_Codes.html&lt;/a>&lt;/p></description></item><item><title>Docs: Containerd</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/10.%E4%BA%91%E5%8E%9F%E7%94%9F/2.2.%E5%AE%9E%E7%8E%B0%E5%AE%B9%E5%99%A8%E7%9A%84%E5%B7%A5%E5%85%B7/containerd/containerd/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/10.%E4%BA%91%E5%8E%9F%E7%94%9F/2.2.%E5%AE%9E%E7%8E%B0%E5%AE%B9%E5%99%A8%E7%9A%84%E5%B7%A5%E5%85%B7/containerd/containerd/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://containerd.io/">官网&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://github.com/containerd/containerd">GitHub 项目，containerd/containerd&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://github.com/containerd/containerd/blob/main/docs/PLUGINS.md">GitHub 项目文档，containerd/docs/PLUGINS.md&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://fuckcloudnative.io/posts/getting-started-with-containerd/">云原生实验室，Containerd 使用教程&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://blog.frognew.com/tags/containerd.html">架构小白，Containerd 标签&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://mp.weixin.qq.com/s/Dr6851XnkNLVFHaj1b13RQ">公众号-云原生实验室，容器中的 Shim 到底是个什么鬼&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>Containerd 是行业标准的容器运行时，着重于简单性，健壮性和可移植性。&lt;/p>
&lt;h2 id="containerd-的前世今生">Containerd 的前世今生&lt;/h2>
&lt;p>很久以前，Docker 强势崛起，以“镜像”这个大招席卷全球，对其他容器技术进行致命的降维打击，使其毫无招架之力，就连 Google 也不例外。Google 为了不被拍死在沙滩上，被迫拉下脸面（当然，跪舔是不可能的），希望 Docker 公司和自己联合推进一个开源的容器运行时作为 Docker 的核心依赖，不然就走着瞧。Docker 公司觉得自己的智商被侮辱了，走着瞧就走着瞧，谁怕谁啊！&lt;/p>
&lt;p>很明显，Docker 公司的这个决策断送了自己的大好前程，造成了今天的悲剧。&lt;/p>
&lt;p>紧接着，Google 联合 Red Hat、IBM 等几位巨佬连哄带骗忽悠 Docker 公司将 &lt;code>libcontainer&lt;/code> 捐给中立的社区（OCI，Open Container Intiative），并改名为 &lt;code>runc&lt;/code>，不留一点 Docker 公司的痕迹~~这还不够，为了彻底扭转 Docker 一家独大的局面，几位大佬又合伙成立了一个基金会叫 &lt;code>CNCF&lt;/code>（Cloud Native Computing Fundation），这个名字想必大家都很熟了，我就不详细介绍了。CNCF 的目标很明确，既然在当前的维度上干不过 Docker，干脆往上爬，升级到大规模容器编排的维度，以此来击败 Docker。Docker 公司当然不甘示弱，搬出了 Swarm 和 Kubernetes 进行 PK，最后的结局大家都知道了，Swarm 战败。然后 Docker 公司耍了个小聪明，将自己的核心依赖 &lt;code>Containerd&lt;/code> 捐给了 CNCF，以此来标榜 Docker 是一个 PaaS 平台。&lt;/p>
&lt;p>很明显，这个小聪明又大大加速了自己的灭亡。
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/ox2yd7/1616122481377-1a01b919-efe6-450a-a439-5493a17e6d70.png" alt="">
巨佬们心想，想当初想和你合作搞个中立的核心运行时，你死要面子活受罪，就是不同意，好家伙，现在自己搞了一个，还捐出来了，马老师，发生甚莫事了？&lt;/p>
&lt;p>这好吗？&lt;/p>
&lt;p>这不好&lt;/p>
&lt;p>也罢，这倒省事了，我就直接拿 &lt;code>Containerd&lt;/code> 来做文章吧。首先呢，为了表示 Kubernetes 的中立性，当然要搞个标准化的容器运行时接口，只要适配了这个接口的容器运行时，都可以和我一起玩耍哦，第一个支持这个接口的当然就是 &lt;code>Containerd&lt;/code> 啦。至于这个接口的名字，大家应该都知道了，它叫 CRI（Container Runntime Interface）。这样还不行，为了蛊惑 Docker 公司，Kubernetes 暂时先委屈自己，专门在自己的组件中集成了一个 &lt;code>shim&lt;/code>（你可以理解为垫片），用来将 CRI 的调用翻译成 Docker 的 API，让 Docker 也能和自己愉快地玩耍，温水煮青蛙，养肥了再杀。。。&lt;/p>
&lt;p>就这样，Kubernetes 一边假装和 Docker 愉快玩耍，一边背地里不断优化 Containerd 的健壮性以及和 CRI 对接的丝滑性。现在 Containerd 的翅膀已经完全硬了，是时候卸下我的伪装，和 Docker say bye bye 了。后面的事情大家也都知道了~~&lt;/p>
&lt;p>Docker 这门技术成功了，Docker 这个公司却失败了。&lt;/p>
&lt;h2 id="containerd-架构">&lt;strong>Containerd 架构&lt;/strong>&lt;/h2>
&lt;p>时至今日，Containerd 已经变成一个工业级的容器运行时了，连口号都有了：超简单！超健壮！可移植性超强！&lt;/p>
&lt;p>当然，为了让 Docker 以为自己不会抢饭碗，Containerd 声称自己的设计目的主要是为了嵌入到一个更大的系统中（暗指 Kubernetes），而不是直接由开发人员或终端用户使用。&lt;/p>
&lt;p>事实上呢，Containerd 现在基本上啥都能干了，开发人员或者终端用户可以在宿主机中管理完整的容器生命周期，包括容器镜像的传输和存储、容器的执行和管理、存储和网络等。大家可以考虑学起来了。&lt;/p>
&lt;p>先来看看 Containerd 的架构：
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/ox2yd7/1616122481393-e3bb2fce-f18d-40ec-ac46-4c6d6a664cd6.png" alt="">
可以看到 Containerd 仍然采用标准的 C/S 架构，服务端通过 &lt;code>GRPC&lt;/code> 协议提供稳定的 API，客户端通过调用服务端的 API 进行高级的操作。&lt;/p>
&lt;p>为了解耦，Containerd 将不同的职责划分给不同的组件，每个组件就相当于一个&lt;strong>子系统&lt;/strong>（subsystem）。连接不同子系统的组件被称为模块。&lt;/p>
&lt;p>总体上 Containerd 被划分为两个子系统：&lt;/p>
&lt;ul>
&lt;li>&lt;strong>Bundle&lt;/strong> : 在 Containerd 中，&lt;code>Bundle&lt;/code> 包含了配置、元数据和根文件系统数据，你可以理解为容器的文件系统。而 &lt;strong>Bundle 子系统&lt;/strong>允许用户从镜像中提取和打包 Bundles。&lt;/li>
&lt;li>&lt;strong>Runtime&lt;/strong> : Runtime 子系统用来执行 Bundles，比如创建容器。&lt;/li>
&lt;/ul>
&lt;p>其中，每一个子系统的行为都由一个或多个&lt;strong>模块&lt;/strong>协作完成（架构图中的 &lt;code>Core&lt;/code> 部分）。每一种类型的模块都以 **Plugin(插件) **的形式集成到 Containerd 中，而且插件之间是相互依赖的。例如，上图中的每一个长虚线的方框都表示一种类型的插件，包括 &lt;code>Service Plugin&lt;/code>、&lt;code>Metadata Plugin&lt;/code>、&lt;code>GC Plugin&lt;/code>、&lt;code>Runtime Plugin&lt;/code> 等，其中 &lt;code>Service Plugin&lt;/code> 又会依赖 Metadata Plugin、GC Plugin 和 Runtime Plugin。每一个小方框都表示一个细分的插件，例如 &lt;code>Metadata Plugin&lt;/code> 依赖 Containers Plugin、Content Plugin 等。总之，万物皆插件，插件就是模块，模块就是插件。
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/ox2yd7/1616122481388-5272b6c1-efb6-49f4-a180-5425bef8ed64.png" alt="">
这里介绍几个常用的插件：&lt;/p>
&lt;ul>
&lt;li>&lt;strong>Content Plugin&lt;/strong> : 提供对镜像中可寻址内容的访问，所有不可变的内容都被存储在这里。&lt;/li>
&lt;li>&lt;strong>Snapshot Plugin&lt;/strong> : 用来管理容器镜像的文件系统快照。镜像中的每一个 layer 都会被解压成文件系统快照，类似于 Docker 中的 &lt;code>graphdriver&lt;/code>。&lt;/li>
&lt;li>&lt;strong>Metrics&lt;/strong> : 暴露各个组件的监控指标。&lt;/li>
&lt;/ul>
&lt;p>从总体来看，Containerd 被分为三个大块：&lt;code>Storage&lt;/code>、&lt;code>Metadata&lt;/code> 和 &lt;code>Runtime&lt;/code>，可以将上面的架构图提炼一下：
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/ox2yd7/1616122481410-b77c18a6-2bcd-48be-b676-1b285bf1c862.png" alt="">
这是使用 &lt;strong>bucketbench[1]&lt;/strong> 对 &lt;code>Docker&lt;/code>、&lt;code>crio&lt;/code> 和 &lt;code>Containerd&lt;/code> 的性能测试结果，包括启动、停止和删除容器，以比较它们所耗的时间：
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/ox2yd7/1616122481422-8a56805f-3ef0-46a4-be19-a0a5b1eef44f.png" alt="">
可以看到 Containerd 在各个方面都表现良好，总体性能还是优越于 &lt;code>Docker&lt;/code> 和 &lt;code>crio&lt;/code> 的。&lt;/p>
&lt;h1 id="containerd-关联文件">Containerd 关联文件&lt;/h1>
&lt;p>&lt;strong>/etc/containerd/config.toml&lt;/strong> # Containerd 运行时配置文件。该文件可以通过 containerd config default 命令来生成一个默认的配置。
&lt;strong>/var/lib/containerd/*&lt;/strong> # Root(根) 文件夹。用于保存持久化数据，镜像、元数据 所在路径。包括 Snapshots, Content, Metadata 以及各种插件的数据。每一个插件都有自己单独的目录，Containerd 本身不存储任何数据，它的所有功能都来自于已加载的插件。&lt;/p>
&lt;ul>
&lt;li>.**/io.containerd.content.v1.content/* **# 镜像的上下文
&lt;ul>
&lt;li>.**/blobs/* **# 镜像文件系统布局中，blobs 目录数据的存放路径&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>./io.containerd.snapshotter.v1.overlayfs/*&lt;/strong> # 镜像的层信息所在目录。&lt;/li>
&lt;li>/var/lib/containerd 目录下的内容详解，见 [《Containerd Image 章节》](/docs/IT学习笔记/10.云原生/2.2.实现容器的工具/Containerd/Containerd%20Image.md Image.md)&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>/run/containerd/*&lt;/strong> # State(状态) 文件夹。用于保存运行时产生的临时数据，也就是容器启动后数据存放目录。包括 sockets、pid、挂载点、运行时状态以及不需要持久化保存的插件数据。&lt;/p>
&lt;ul>
&lt;li>&lt;strong>./io.containerd.runtime.VERSION.ID/*&lt;/strong> # Containerd 运行容器时所使用的 runtime 插件，该目录的名称就是插件的版本和名称。该目录下的目录以名称空间命名。
&lt;ul>
&lt;li>&lt;strong>./NAMESPACE/*&lt;/strong> # 指定名称空间下的容器启动后的数据(主要就是符合 OCI 标准的 一组 Bundle 文件)保存路径，其内目录名为 ContainerID。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h2 id="目录结构">目录结构&lt;/h2>
&lt;p>在 /var/lib/containerd 和 /run/containerd 目录下，保存了 Containerd 运行所需的所有数据。Containerd 本身不存储任何数据，所有数据都来源于插件的功能。
看一下目录下的层次结构就一目了然了：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>? → tree -L &lt;span style="color:#ae81ff">2&lt;/span> /var/lib/containerd/
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>/var/lib/containerd/
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>├── io.containerd.content.v1.content
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>│ ├── blobs
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>│ └── ingest
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>├── io.containerd.grpc.v1.cri
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>│ ├── containers
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>│ └── sandboxes
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>├── io.containerd.metadata.v1.bolt
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>│ └── meta.db
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>├── io.containerd.runtime.v1.linux
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>│ └── k8s.io
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>├── io.containerd.runtime.v2.task
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>├── io.containerd.snapshotter.v1.aufs
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>│ └── snapshots
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>├── io.containerd.snapshotter.v1.btrfs
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>├── io.containerd.snapshotter.v1.native
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>│ └── snapshots
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>├── io.containerd.snapshotter.v1.overlayfs
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>│ ├── metadata.db
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>│ └── snapshots
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>└── tmpmounts
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">18&lt;/span> directories, &lt;span style="color:#ae81ff">2&lt;/span> files
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>每个子目录，其实都表示的是一个插件名称。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>? → tree -L &lt;span style="color:#ae81ff">2&lt;/span> /run/containerd/
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>/run/containerd/
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>├── containerd.sock
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>├── containerd.sock.ttrpc
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>├── io.containerd.grpc.v1.cri
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>│ ├── containers
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>│ └── sandboxes
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>├── io.containerd.runtime.v1.linux
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>│ └── k8s.io
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>├── io.containerd.runtime.v2.task
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>└── runc
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> └── k8s.io
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">8&lt;/span> directories, &lt;span style="color:#ae81ff">2&lt;/span> files
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h1 id="containerd-插件">Containerd 插件&lt;/h1></description></item><item><title>Docs: Containerd 配置详解</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/10.%E4%BA%91%E5%8E%9F%E7%94%9F/2.2.%E5%AE%9E%E7%8E%B0%E5%AE%B9%E5%99%A8%E7%9A%84%E5%B7%A5%E5%85%B7/containerd/containerd-%E9%85%8D%E7%BD%AE%E8%AF%A6%E8%A7%A3/containerd-%E9%85%8D%E7%BD%AE%E8%AF%A6%E8%A7%A3/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/10.%E4%BA%91%E5%8E%9F%E7%94%9F/2.2.%E5%AE%9E%E7%8E%B0%E5%AE%B9%E5%99%A8%E7%9A%84%E5%B7%A5%E5%85%B7/containerd/containerd-%E9%85%8D%E7%BD%AE%E8%AF%A6%E8%A7%A3/containerd-%E9%85%8D%E7%BD%AE%E8%AF%A6%E8%A7%A3/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://github.com/containerd/containerd/blob/main/docs/man/containerd-config.toml.5.md">Manual(手册),containerd-config.toml(5)&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://manpages.debian.org/bullseye/containerd/containerd-config.toml.5.en.html">Debian Manual&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>Containerd 使用 &lt;a href="https://desistdaydream.github.io/docs/IT%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/2.%E7%BC%96%E7%A8%8B/%E6%97%A0%E6%B3%95%E5%88%86%E7%B1%BB%E7%9A%84%E8%AF%AD%E8%A8%80/TOML.md">TOML&lt;/a> 作为配置文件的格式，默认配置文件为 /etc/containerd/config.toml，我们可以通过命令来生成一个包含所有配置字段的默认配置文件&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>mkdir -p /etc/containerd
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>containerd config default &amp;gt; /etc/containerd/config.toml
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h1 id="配置文件详解">配置文件详解&lt;/h1>
&lt;h1 id="通用配置">[通用]配置&lt;/h1>
&lt;p>&lt;strong>version = 2&lt;/strong> #
&lt;strong>root = &amp;lt;STRING&amp;gt;&lt;/strong> # Containerd 持久化数据路径。&lt;code>默认值：/var/lib/containerd&lt;/code>。
&lt;strong>state = &amp;lt;STRING&amp;gt;&lt;/strong> # Containerd 临时数据路径。&lt;code>默认值：/run/containerd&lt;/code>。
&lt;strong>oom_score = 0&lt;/strong> # 设置 Containerd 的 OOM 权重。&lt;code>默认值：0&lt;/code>。
Containerd 是容器的守护者，一旦发生内存不足的情况，理想的情况应该是先杀死容器，而不是杀死 Containerd。所以需要调整 Containerd 的 &lt;code>OOM&lt;/code> 权重，减少其被 &lt;strong>OOM Kill&lt;/strong> 的几率。最好是将 &lt;code>oom_score&lt;/code> 的值调整为比其他守护进程略低的值。这里的 oom_socre 其实对应的是 &lt;code>/proc/&amp;lt;pid&amp;gt;/oom_socre_adj&lt;/code>，在早期的 Linux 内核版本里使用 &lt;code>oom_adj&lt;/code> 来调整权重, 后来改用 &lt;code>oom_socre_adj&lt;/code> 了。该文件描述如下：
在计算最终的 &lt;code>badness score&lt;/code> 时，会在计算结果是中加上 &lt;code>oom_score_adj&lt;/code> ,这样用户就可以通过该在值来保护某个进程不被杀死或者每次都杀某个进程。其取值范围为 &lt;code>-1000&lt;/code> 到 &lt;code>1000&lt;/code>。如果将该值设置为 &lt;code>-1000&lt;/code>，则进程永远不会被杀死，因为此时 &lt;code>badness score&lt;/code> 永远返回 0。建议 Containerd 将该值设置为 &lt;code>-999&lt;/code> 到 &lt;code>0&lt;/code> 之间。如果作为 Kubernetes 的 Worker 节点，可以考虑设置为 &lt;code>-999&lt;/code>。&lt;/p>
&lt;h1 id="cgroup-配置">[cgroup] 配置&lt;/h1>
&lt;h1 id="debug-配置">[debug] 配置&lt;/h1>
&lt;h1 id="grpc-配置表">[grpc] 配置表&lt;/h1>
&lt;p>&lt;strong>address = &lt;!-- raw HTML omitted -->&lt;/strong> # Containerd 监听的 GRPC 路径。&lt;code>默认值：/run/containerd/containerd.sock&lt;/code>&lt;/p>
&lt;h1 id="metrics-配置">[metrics] 配置&lt;/h1>
&lt;h1 id="plugins-配置">[plugins] 配置&lt;/h1>
&lt;p>详见 [《Plugin 配置》](/docs/IT学习笔记/10.云原生/2.2.实现容器的工具/Containerd/Containerd%20 配置详解/Plugin%20 配置.md 配置详解/Plugin 配置.md) 章节&lt;/p>
&lt;h1 id="timeouts-配置">[timeouts] 配置&lt;/h1>
&lt;h1 id="ttrpc-配置表">[ttrpc] 配置表&lt;/h1>
&lt;h1 id="配置文件示例">配置文件示例&lt;/h1>
&lt;h2 id="镜像加速配置示例">镜像加速配置示例&lt;/h2>
&lt;p>Containerd 的镜像仓库 mirror 与 Docker 相比有两个区别：&lt;/p>
&lt;ul>
&lt;li>Containerd 只支持通过 &lt;code>CRI&lt;/code> 拉取镜像的 mirror，也就是说，只有通过 &lt;code>crictl&lt;/code> 或者 Kubernetes 调用时 mirror 才会生效，通过 &lt;code>ctr&lt;/code> 拉取是不会生效的。&lt;/li>
&lt;li>&lt;code>Docker&lt;/code> 只支持为 &lt;code>Docker Hub&lt;/code> 配置 mirror，而 &lt;code>Containerd&lt;/code> 支持为任意镜像仓库配置 mirror。&lt;/li>
&lt;/ul>
&lt;p>所以需要修改的部分如下：&lt;/p>
&lt;pre>&lt;code>[plugins.&amp;quot;io.containerd.grpc.v1.cri&amp;quot;.registry]
[plugins.&amp;quot;io.containerd.grpc.v1.cri&amp;quot;.registry.mirrors]
[plugins.&amp;quot;io.containerd.grpc.v1.cri&amp;quot;.registry.mirrors.&amp;quot;docker.io&amp;quot;]
endpoint = [&amp;quot;https://dockerhub.mirrors.nwafu.edu.cn&amp;quot;]
[plugins.&amp;quot;io.containerd.grpc.v1.cri&amp;quot;.registry.mirrors.&amp;quot;k8s.gcr.io&amp;quot;]
endpoint = [&amp;quot;https://registry.aliyuncs.com/k8sxio&amp;quot;]
[plugins.&amp;quot;io.containerd.grpc.v1.cri&amp;quot;.registry.mirrors.&amp;quot;gcr.io&amp;quot;]
endpoint = [&amp;quot;xxx&amp;quot;]
&lt;/code>&lt;/pre>
&lt;h1 id="systemd-配置">Systemd 配置&lt;/h1>
&lt;p>建议通过 systemd 配置 Containerd 作为守护进程运行，配置文件在上文已经被解压出来了：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">[&lt;/span>Unit&lt;span style="color:#f92672">]&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Description&lt;span style="color:#f92672">=&lt;/span>containerd container runtime
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Documentation&lt;span style="color:#f92672">=&lt;/span>https://containerd.io
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>After&lt;span style="color:#f92672">=&lt;/span>network.target local-fs.target
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">[&lt;/span>Service&lt;span style="color:#f92672">]&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>ExecStartPre&lt;span style="color:#f92672">=&lt;/span>-/sbin/modprobe overlay
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>ExecStart&lt;span style="color:#f92672">=&lt;/span>/usr/local/bin/containerd
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Type&lt;span style="color:#f92672">=&lt;/span>notify
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Delegate&lt;span style="color:#f92672">=&lt;/span>yes
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>KillMode&lt;span style="color:#f92672">=&lt;/span>process
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Restart&lt;span style="color:#f92672">=&lt;/span>always
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>RestartSec&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">5&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># Having non-zero Limit*s causes performance problems due to accounting overhead&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># in the kernel. We recommend using cgroups to do container-local accounting.&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>LimitNPROC&lt;span style="color:#f92672">=&lt;/span>infinity
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>LimitCORE&lt;span style="color:#f92672">=&lt;/span>infinity
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>LimitNOFILE&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">1048576&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># Comment TasksMax if your systemd version does not supports it.&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># Only systemd 226 and above support this version.&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>TasksMax&lt;span style="color:#f92672">=&lt;/span>infinity
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>OOMScoreAdjust&lt;span style="color:#f92672">=&lt;/span>-999
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">[&lt;/span>Install&lt;span style="color:#f92672">]&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>WantedBy&lt;span style="color:#f92672">=&lt;/span>multi-user.target
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>这里有两个重要的参数：&lt;/p>
&lt;ul>
&lt;li>&lt;strong>Delegate&lt;/strong> : 这个选项允许 Containerd 以及运行时自己管理自己创建的容器的 &lt;code>cgroups&lt;/code>。如果不设置这个选项，systemd 就会将进程移到自己的 &lt;code>cgroups&lt;/code> 中，从而导致 Containerd 无法正确获取容器的资源使用情况。&lt;/li>
&lt;li>&lt;strong>KillMode&lt;/strong> : 这个选项用来处理 Containerd 进程被杀死的方式。默认情况下，systemd 会在进程的 cgroup 中查找并杀死 Containerd 的所有子进程，这肯定不是我们想要的。&lt;code>KillMode&lt;/code>字段可以设置的值如下。我们需要将 KillMode 的值设置为 &lt;code>process&lt;/code>，这样可以确保升级或重启 Containerd 时不杀死现有的容器。
&lt;ul>
&lt;li>&lt;strong>control-group&lt;/strong>（默认值）：当前控制组里面的所有子进程，都会被杀掉&lt;/li>
&lt;li>&lt;strong>process&lt;/strong>：只杀主进程&lt;/li>
&lt;li>&lt;strong>mixed&lt;/strong>：主进程将收到 SIGTERM 信号，子进程收到 SIGKILL 信号&lt;/li>
&lt;li>&lt;strong>none&lt;/strong>：没有进程会被杀掉，只是执行服务的 stop 命令。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul></description></item><item><title>Docs: ECMAScript 环境安装与使用</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/2.%E7%BC%96%E7%A8%8B/%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/ecmascript/ecmascript-%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8/ecmascript-%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/2.%E7%BC%96%E7%A8%8B/%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/ecmascript/ecmascript-%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8/ecmascript-%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;/blockquote>
&lt;p>有两种运行时环境可以运行 ECMAScript 代码(Javascript、Typescript)&lt;/p>
&lt;ul>
&lt;li>**Browser **# 浏览器就是 ECMAScript 的运行时环境。&lt;/li>
&lt;li>&lt;strong>Node.js&lt;/strong> # 在服务器或 PC 上安装 Node.js 环境以运行 ECMAScript 代码&lt;/li>
&lt;li>&lt;strong>Deno&lt;/strong> # &lt;a href="https://github.com/denoland/deno">GtiHub 项目，denoland/deno&lt;/a>。据说要替代 Node.js，很尴尬的是。。。早期 18 年的 issue 中被各种国人无意义灌水&lt;/li>
&lt;li>&lt;strong>Bun&lt;/strong> # &lt;a href="https://github.com/oven-sh/bun">GtiHub 项目，oven-sh/bun&lt;/a>&lt;/li>
&lt;/ul>
&lt;p>但是这两者可以提供的 API 能力各不相同&lt;/p>
&lt;ul>
&lt;li>Browser 可以提供的 dockument、window 和其他关于 DOM 或其他 Web 平台 API 的对象。&lt;/li>
&lt;li>Node.js 则可以提供很多操作系统相关的 API，比如文件的读写、进程管理、网络通信等等。&lt;/li>
&lt;/ul>
&lt;p>Node.js 与 Browser 都是基于 Chrome V8 引擎的 ECMAScript 运行时环境&lt;/p>
&lt;p>你也许会想，直接在我的硬盘上创建好 HTML 和 JavaScript 文件，然后用浏览器打开，不就可以看到效果了吗？&lt;/p>
&lt;p>这种方式运行部分 JavaScript 代码没有问题，但由于浏览器的安全限制，以 file:// 开头的地址无法执行如联网等 JavaScript 代码，最终，你还是需要架设一个 Web 服务器，然后以 http:// 开头的地址来正常执行所有 JavaScript 代码。&lt;/p>
&lt;p>所以，想要运行 JavaScript 编写的静态文件，通常都需要一个可以提供 HTTP 服务的程序，以便响应客户端的请求返回这些静态文件。通常在生产环境中，我们都会将静态资源文件放到 Nginx 的目录中，由 Nginx 为客户端提供 HTTP 服务。&lt;/p>
&lt;p>而本地测试时，我们通过 npm 与 yarn 工具即可安装一个简易的 HTTP 服务，这个 HTTP 服务都是由 JS 代码写的，必须要保证本地有 Node.js 环境，即可启动一个 HTTP 服务&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># Npm 安装 http-server&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>~&lt;span style="color:#f92672">]&lt;/span>&lt;span style="color:#75715e"># npm install http-server&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># Yarn 安装 http-server&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>~&lt;span style="color:#f92672">]&lt;/span>&lt;span style="color:#75715e"># yarn add http-server&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>http-server 来源于 &lt;a href="https://github.com/http-party/http-server">GitHub 项目，http-party/http-server&lt;/a>&lt;/p>
&lt;p>通过 &lt;code>npm exec serve&lt;/code> 命令将会安装另一个名为 serve 的库以运行 HTTP 服务，默认在 3000 端口上启动 HTTP 服务，通过浏览器访问 localhost:3000 即可获取到所有自己编写的静态文件，便于让开发人员在本地调试。&lt;/p>
&lt;h2 id="重点运行具有-module模块-功能的静态资源">(重点)运行具有 Module(模块) 功能的静态资源&lt;/h2>
&lt;p>从《ECMAScript 模块》章节可以看到，当我们使用 &lt;code>import name from './one.js'&lt;/code> 导入的模块是一个文件时，那么这个文件将会被响应给浏览器，如果使用 &lt;code>import name from 'one'&lt;/code> 导入的模块是一组文件时，此时浏览器无法直接识别，将会产生报错。因为浏览器想要执行这一组文件需要发起很多次的请求将所有文件都加载到本地，这其中的路由路径将是不可控的。&lt;/p>
&lt;p>所以，此时我们则需要想办法将这一组文件变为一个文件响应给浏览器以便加载代码。这个转换的操作，我们可以使用打包工具(i.e.Webpack、Vite 等等) 将源代码&lt;strong>打包编译&lt;/strong>成新的静态文件即可。&lt;/p>
&lt;p>后面的逻辑，与基本运行 ECMAScript 代码的行为就是一样的了。&lt;/p>
&lt;h2 id="使用-vite-运行-ecmascript-代码">使用 Vite 运行 ECMAScript 代码&lt;/h2>
&lt;p>npm、yarn 的打包后运行代码的速度非常缓慢，才是推荐使用 Vite 工具启动 HTTP 服务并运行 JS/TS 代码，详见：[《Vite》](/docs/IT学习笔记/2.编程/高级编程语言/ECMAScript/ECMAScript%20 工具/Vite.md 工具/Vite.md) 章节&lt;/p>
&lt;h2 id="运行-typesript">运行 TypeSript&lt;/h2>
&lt;p>Node.js 和 浏览器都无法直接运行 TypeScript 代码，这是因为 TS 的代码需要先转换为 JS 代码才可以运行。此时就需要一种工具，先转换再运行，或者直接转换运行一体。&lt;/p>
&lt;ul>
&lt;li>&lt;strong>tsc&lt;/strong> # 将 TS 代码转换为 JS 代码。&lt;code>npm install -g typescript&lt;/code>&lt;/li>
&lt;li>&lt;strong>ts-node&lt;/strong> # 可以直接转换并运行 TS 代码，&lt;code>npm install -g ts-node&lt;/code> 安装即可&lt;/li>
&lt;/ul>
&lt;h1 id="nodejs">Node.js&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://nodejs.org/en/">org 官网&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://nodejs.dev/">dev 官网&lt;/a>&lt;/li>
&lt;li>&lt;a href="http://nodejs.cn/">dev 官网中文翻译&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Node.js">Wiki,Node.js&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>Node.js 是基于 Chrome V8 引擎的 ECMAScript 运行时环境，由 RyanDahl 于 2009 年 5 月 27 日发布。转年(i.e.2010 年 1 月)，为 Node.js 环境引入了一个名为 npm 的包管理器。包管理器使程序员更容易发布和共享 Node.js 的源代码，旨在简化包的安装、更新、卸载。&lt;/p>
&lt;p>Browser 和 Node.js 都是 ECMAScript 的运行时环境，但是这两者可以提供的 API 能力各不相同&lt;/p>
&lt;ul>
&lt;li>Browser 可以提供的 dockument、window 和其他关于 DOM 或其他 Web 平台 API 的对象。&lt;/li>
&lt;li>Node.js 则可以提供很多操作系统相关的 API，比如文件的读写、进程管理、网络通信等等。&lt;/li>
&lt;/ul>
&lt;p>通过 Node.js，可以让我们使用一种语言编写前端与后端。我们甚至可以通过 npm 与 yarn 安装第三方库后，使用 Node.js 在本地监听端口并响应给客户端静态资源文件。&lt;/p>
&lt;h2 id="安装-nodejs">安装 Node.js&lt;/h2>
&lt;h3 id="linux">Linux&lt;/h3>
&lt;p>从&lt;a href="https://nodejs.org/zh-cn/download/">官网&lt;/a>下载 Linux 版的 &lt;code>.tar.xg&lt;/code> 包，并解压&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>export NodejsVersion&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;v16.15.0&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>wget https://nodejs.org/dist/&lt;span style="color:#e6db74">${&lt;/span>NodejsVersion&lt;span style="color:#e6db74">}&lt;/span>/node-&lt;span style="color:#e6db74">${&lt;/span>NodejsVersion&lt;span style="color:#e6db74">}&lt;/span>-linux-x64.tar.xz
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>tar -xvf node-&lt;span style="color:#e6db74">${&lt;/span>NodejsVersion&lt;span style="color:#e6db74">}&lt;/span>-linux-x64.tar.xz -C /usr/local/
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>mv /usr/local/node-&lt;span style="color:#e6db74">${&lt;/span>NodejsVersion&lt;span style="color:#e6db74">}&lt;/span>-linux-x64 /usr/local/nodejs
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>配置环境变量&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>sudo tee /etc/profile.d/nodejs.sh &amp;gt; /dev/null &amp;lt;&amp;lt;-&lt;span style="color:#e6db74">&amp;#34;EOF&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>export PATH&lt;span style="color:#f92672">=&lt;/span>$PATH:/usr/local/nodejs/bin
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>EOF
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="windows">Windows&lt;/h3>
&lt;p>警告！！！由于 msi 安装包会修改 %PREFIX% 为 &lt;code>%APPDATA%\npm&lt;/code> ，并将该目录到 $PATH。我个人推荐下载 zip，并自己解压到想要的位置后，手动配置环境变量。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-powershell" data-lang="powershell">&lt;span style="display:flex;">&lt;span>$NodejsVersion = &lt;span style="color:#e6db74">&amp;#34;18.14.1&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>$NodejsUrl = &lt;span style="color:#e6db74">&amp;#34;https://nodejs.org/dist/v&lt;/span>$NodejsVersion&lt;span style="color:#e6db74">/node-v&lt;/span>$NodejsVersion&lt;span style="color:#e6db74">-win-x64.zip&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>$TempZipFile = &lt;span style="color:#e6db74">&amp;#34;D:\tmp\nodejs.zip&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>$ExtractPath = &lt;span style="color:#e6db74">&amp;#34;D:\Tools&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># Download the zip file to a temporary location&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Invoke-WebRequest -Uri $NodejsUrl -OutFile $TempZipFile
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># Extract the contents of the zip file to the installation directory and rename the top-level directory to &amp;#34;nodejs&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Expand-Archive -Path $TempZipFile -DestinationPath $ExtractPath
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Rename-Item -Path &lt;span style="color:#e6db74">&amp;#34;&lt;/span>$ExtractPath&lt;span style="color:#e6db74">\node-v&lt;/span>$NodejsVersion&lt;span style="color:#e6db74">-win-x64&amp;#34;&lt;/span> -NewName &lt;span style="color:#e6db74">&amp;#34;nodejs&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>将 nodejs/ 目录添加到用户的 PATH 环境变量中&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-powershell" data-lang="powershell">&lt;span style="display:flex;">&lt;span>$path = [&lt;span style="color:#66d9ef">Environment&lt;/span>]::GetEnvironmentVariable(&lt;span style="color:#e6db74">&amp;#34;Path&amp;#34;&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;User&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>$newPath = &lt;span style="color:#e6db74">&amp;#34;D:\Tools\nodejs&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>[&lt;span style="color:#66d9ef">Environment&lt;/span>]::SetEnvironmentVariable(&lt;span style="color:#e6db74">&amp;#34;Path&amp;#34;&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;&lt;/span>$path&lt;span style="color:#e6db74">;&lt;/span>$newPath&lt;span style="color:#e6db74">&amp;#34;&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;User&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="目录结构">目录结构&lt;/h3>
&lt;p>Linux 目录结构，node_modules/ 目录在 lib/ 目录下，这点与 Windows 不同。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">]&lt;/span>&lt;span style="color:#75715e"># tree -L 2 -F&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>.
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>├── bin/
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>│   ├── corepack -&amp;gt; ../lib/node_modules/corepack/dist/corepack.js*
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>│   ├── node*
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>│   ├── npm -&amp;gt; ../lib/node_modules/npm/bin/npm-cli.js*
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>│   ├── npx -&amp;gt; ../lib/node_modules/npm/bin/npx-cli.js*
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>│   ├── pnpm -&amp;gt; ../lib/node_modules/corepack/dist/pnpm.js*
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>│   ├── pnpx -&amp;gt; ../lib/node_modules/corepack/dist/pnpx.js*
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>│   ├── yarn -&amp;gt; ../lib/node_modules/corepack/dist/yarn.js*
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>│   └── yarnpkg -&amp;gt; ../lib/node_modules/corepack/dist/yarnpkg.js*
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>├── CHANGELOG.md
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>├── include/
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>│   └── node/
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>├── lib/
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>│   └── node_modules/
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>├── LICENSE
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>├── README.md
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>└── share/
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ├── doc/
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ├── man/
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> └── systemtap/
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Windows 目录结构&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>$ tree -L &lt;span style="color:#ae81ff">2&lt;/span> -F
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>./
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>├── CHANGELOG.md*
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>├── LICENSE*
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>├── README.md*
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>├── corepack*
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>├── corepack.cmd*
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>├── install_tools.bat*
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>├── node.exe*
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>├── node_etw_provider.man*
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>├── node_modules/
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>│   ├── corepack/
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>│   └── npm/
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>├── nodevars.bat*
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>├── npm*
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>├── npm.cmd*
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>├── npx*
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>└── npx.cmd*
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="nvm">NVM&lt;/h2>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://github.com/nvm-sh/nvm">GitHub 项目，nvm-sh/nvm&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>&lt;strong>Node Version Manager(Node.js 版本管理器，简称 NVM)&lt;/strong>&lt;/p>
&lt;h2 id="nodejs-关联文件与配置">Node.js 关联文件与配置&lt;/h2>
&lt;p>详见：&lt;a href="docs/IT%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/2.%E7%BC%96%E7%A8%8B/%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/ECMAScript/ECMAScript%20%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8/ECMAScript%20%E6%A8%A1%E5%9D%97%E4%B8%8E%E5%8C%85%E7%9A%84%E4%BD%BF%E7%94%A8%E4%B8%8E%E7%AE%A1%E7%90%86.md#npm%20%E5%85%B3%E8%81%94%E6%96%87%E4%BB%B6%E4%B8%8E%E9%85%8D%E7%BD%AE">npm 关键文件与配置&lt;/a>&lt;/p>
&lt;h1 id="初始化项目">初始化项目&lt;/h1>
&lt;p>npm 等包管理工具下载完框架后，会自动生成项目目录，这些目录是已经初始化完成的项目，包含了很多必要的文件，比如 package.json 等。&lt;/p>
&lt;p>随着学习深入，会逐步总结一个前端项目如果不使用框架从头构建的话会需要什么。&lt;/p>
&lt;ul>
&lt;li>&lt;strong>public/&lt;/strong> 目录存放公共资源&lt;/li>
&lt;li>&lt;strong>src/&lt;/strong> # 所有代码都在 src/ 目录下&lt;/li>
&lt;li>&lt;strong>.eslintrc.cjs&lt;/strong> # ESLint 程序配置&lt;/li>
&lt;li>&lt;strong>.prettierc.json&lt;/strong> # Prettier 插件的配置&lt;/li>
&lt;li>&lt;strong>env.d.ts&lt;/strong> #&lt;/li>
&lt;li>&lt;strong>index.html&lt;/strong> # 程序入口&lt;/li>
&lt;li>[&lt;strong>package.json&lt;/strong>](/docs/IT学习笔记/2.编程/高级编程语言/ECMAScript/ECMAScript%20 环境安装与使用/package.json.md 环境安装与使用/package.json.md) # 包管理器配置文件，比如 npm、pnpm 等&lt;/li>
&lt;li>&lt;strong>vite.config.ts&lt;/strong> # Vite 程序给项目打包时使用的配置&lt;/li>
&lt;li>&lt;strong>tsconfig.json&lt;/strong> #&lt;/li>
&lt;li>&lt;strong>tsconfig.config.json&lt;/strong> # [TSConfig](/docs/IT学习笔记/2.编程/高级编程语言/ECMAScript/ECMAScript%20 环境安装与使用/TSConfig.md 环境安装与使用/TSConfig.md) 文件&lt;/li>
&lt;/ul>
&lt;h2 id="javascript-项目初始化">JavaScript 项目初始化&lt;/h2>
&lt;p>无&lt;/p>
&lt;h2 id="typescript-项目初始化">TypeScript 项目初始化&lt;/h2>
&lt;p>使用 &lt;code>npm install -g typescript&lt;/code> 安装 tsc 命令。&lt;/p>
&lt;p>使用 &lt;code>tsc init&lt;/code> 命令将会生成 [TSConfig](/docs/IT学习笔记/2.编程/高级编程语言/ECMAScript/ECMAScript%20 环境安装与使用/TSConfig.md 环境安装与使用/TSConfig.md) 文件。&lt;/p>
&lt;h1 id="编译与打包">编译与打包&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://github.com/webpack/webpack">GitHub 项目，webpack/webpack&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://github.com/rollup/rollup">GitHub 项目，rollup/rollup&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>大型项目通常都要打包，打包工具有很多：&lt;/p>
&lt;ul>
&lt;li>Webpack&lt;/li>
&lt;li>Rollup&lt;/li>
&lt;li>Vite&lt;/li>
&lt;li>&amp;hellip;&amp;hellip;等等&lt;/li>
&lt;/ul>
&lt;h1 id="常见问题">常见问题&lt;/h1>
&lt;h2 id="nodejs-无法使用-es6-语法问题">Node.js 无法使用 ES6 语法问题&lt;/h2>
&lt;p>无法使用 import 关键字导入模块。参考 &lt;a href="https://nodejs.org/docs/latest-v16.x/api/esm.html#enabling">https://nodejs.org/docs/latest-v16.x/api/esm.html#enabling&lt;/a>，在 package.json 文件中设置 &lt;code>&amp;quot;type&amp;quot;: &amp;quot;module&amp;quot;&lt;/code> 或者使用 &lt;code>--input-type=module&lt;/code> 命令行参数以告诉 Node.js 使用 ECMAScript 模块加载器。默认情况下，Node.js 使用 CommonJS 模块加载器。&lt;/p></description></item><item><title>Docs: File System 管理</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/y.windows-%E7%AE%A1%E7%90%86/file_system_%E7%AE%A1%E7%90%86/file_system_%E7%AE%A1%E7%90%86/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/y.windows-%E7%AE%A1%E7%90%86/file_system_%E7%AE%A1%E7%90%86/file_system_%E7%AE%A1%E7%90%86/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://www.howtogeek.com/318177/what-is-the-appdata-folder-in-windows/">https://www.howtogeek.com/318177/what-is-the-appdata-folder-in-windows/&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>&lt;strong>%USERPROFILE%/AppData/*&lt;/strong> #&lt;/p>
&lt;ul>
&lt;li>&lt;strong>./Local/*&lt;/strong> #&lt;/li>
&lt;li>&lt;strong>./LocalLow/*&lt;/strong> #&lt;/li>
&lt;li>&lt;strong>./Roaming/*&lt;/strong> #&lt;/li>
&lt;/ul>
&lt;p>刚装完的 win10 专业版，用户的 AppData 中将会有如下结构：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-powershell" data-lang="powershell">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">%&lt;/span>USERPROFILE%\appdata\Local
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">%&lt;/span>USERPROFILE%\appdata\LocalLow
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">%&lt;/span>USERPROFILE%\appdata\Roaming
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">%&lt;/span>USERPROFILE%\appdata\Local\Comms
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">%&lt;/span>USERPROFILE%\appdata\Local\ConnectedDevicesPlatform
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">%&lt;/span>USERPROFILE%\appdata\Local\D3DSCache
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">%&lt;/span>USERPROFILE%\appdata\Local\Microsoft
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">%&lt;/span>USERPROFILE%\appdata\Local\Packages
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">%&lt;/span>USERPROFILE%\appdata\Local\Temp
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">%&lt;/span>USERPROFILE%\appdata\LocalLow\Microsoft
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">%&lt;/span>USERPROFILE%\appdata\LocalLow\MSLiveStickerWhiteList
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">%&lt;/span>USERPROFILE%\appdata\Roaming\Adobe
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">%&lt;/span>USERPROFILE%\appdata\Roaming\Microsoft
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>最主要的是这三个目录下的 Microsfot 目录，还有 Packages 目录。在整理 AppData 时，不要误删了。&lt;/p>
&lt;h1 id="program-files">Program Files&lt;/h1>
&lt;p>该目录存储安装在计算机上的大多数应用程序的执行文件。&lt;/p>
&lt;h1 id="program-filesx86">Program Files(x86)&lt;/h1>
&lt;p>该目录存储在 64 位 Windows 系统上安装的 32 位应用程序的执行文件。&lt;/p>
&lt;h1 id="programdata">ProgramData&lt;/h1>
&lt;p>该目录存储全局数据，包括应用程序的配置文件，以及系统的安装和更新信息。&lt;/p>
&lt;h1 id="users">Users&lt;/h1>
&lt;p>该目录存储在 Windows 系统上创建的每个用户的个人文件夹，如桌面、文档和图片。&lt;/p>
&lt;h1 id="windows">Windows&lt;/h1>
&lt;p>Windows 操作系统的核心文件和 DLL 文件都存储在此目录中。&lt;/p>
&lt;p>&lt;strong>./System32/&lt;/strong> # 类似于 Linux 中的 /usr/sbin/ 目录，系统自带的命令、服务、msc 的可执行文件都在这里。&lt;/p></description></item><item><title>Docs: Go 环境安装与使用</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/2.%E7%BC%96%E7%A8%8B/%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/go/go-%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8/go-%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/2.%E7%BC%96%E7%A8%8B/%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/go/go-%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8/go-%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://golang.org/doc/install">官方文档，下载并安装 Go&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://golang.org/doc/manage-install">官方文档，安装多个版本的 Go&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://pkg.go.dev/cmd/go">Go 包，标准库-cmd-go&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://github.com/goproxy/goproxy.cn/issues/61">GitHub 项目-goproxy-goproxy.io 与 goproxy.cn 说明&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>我们可以通过一个名为 go 的二进制文件实现绝大部分日常的 编码、编译 等工作，只要安装好 Go 的环境即可。&lt;/p>
&lt;h1 id="安装-go">安装 Go&lt;/h1>
&lt;h2 id="linux-安装">Linux 安装&lt;/h2>
&lt;p>从&lt;a href="https://golang.org/dl/">官网&lt;/a>下载 linux 版的 &lt;code>.tar.gz&lt;/code> 包&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>export GoVersion&lt;span style="color:#f92672">=&lt;/span>1.18.5
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>wget https://go.dev/dl/go&lt;span style="color:#e6db74">${&lt;/span>GoVersion&lt;span style="color:#e6db74">}&lt;/span>.linux-amd64.tar.gz
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>tar -C /usr/local -xvzf go&lt;span style="color:#e6db74">${&lt;/span>GoVersion&lt;span style="color:#e6db74">}&lt;/span>.linux-amd64.tar.gz
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>配置环境变量，以便让 shell 可以执行 go 命令并立刻生效&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>sudo tee /etc/profile.d/go.sh &amp;gt; /dev/null &amp;lt;&amp;lt;-&lt;span style="color:#e6db74">&amp;#34;EOF&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># export GOPATH=/opt/gopath&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># export PATH=$PATH:\$GOPATH/bin:/usr/local/go/bin&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>export PATH&lt;span style="color:#f92672">=&lt;/span>$PATH:/usr/local/go/bin
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>export GO111MODULE&lt;span style="color:#f92672">=&lt;/span>on
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>export GOPROXY&lt;span style="color:#f92672">=&lt;/span>https://goproxy.cn,https://goproxy.io,https://mirrors.aliyun.com/goproxy/,direct
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>export CGO_ENABLED&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">0&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>EOF
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>source /etc/profile.d/go.sh
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;blockquote>
&lt;p>CGO_ENABLED 开启后 Go 代码最终编译的可执行文件都是要有外部依赖的。不过我们依然可以通过 disable CGO_ENABLED 来编译出纯静态的 Go 程序，常用于交叉编译
CGO_ENABLED 关闭即可编译出纯静态的 Go 程序，可以用于 alpine 镜像中。&lt;/p>
&lt;/blockquote>
&lt;h2 id="windows-安装">Windows 安装&lt;/h2>
&lt;p>从&lt;a href="https://golang.org/dl/">官网&lt;/a>下载 Windows 版的 msi 安装包&lt;/p>
&lt;p>双击安装 Golang&lt;/p>
&lt;p>配置环境变量，执行命令&lt;/p>
&lt;ul>
&lt;li>go env -w GOPATH=D:\Tools\GoPath&lt;/li>
&lt;li>go env -w GOPROXY=https://goproxy.cn,https://goproxy.io,direct&lt;/li>
&lt;li>go env -w GO111MODULE=on&lt;/li>
&lt;/ul>
&lt;h2 id="安装多个版本的-go">安装多个版本的 Go&lt;/h2>
&lt;p>获取其余版本的 golang&lt;/p>
&lt;ul>
&lt;li>go install golang.org/dl/goX.XX.X@latest&lt;/li>
&lt;li>goX.XX.X download&lt;/li>
&lt;/ul>
&lt;p>新下载的 golang 版本可以像这样使用，在 go 后面加上版本号&lt;/p>
&lt;ul>
&lt;li>goX.XX.X version&lt;/li>
&lt;/ul>
&lt;p>通过 goX.XX.X env 命令查看该 go 版本的变量，可以看到，默认的 GOROOT 是在 ~/sdk/goX.XX.X 目录下的&lt;/p>
&lt;p>所以如果想要切换默认的 go 版本(比如某个程序调用 go 命令时)，只需要将环境变量 GOROOT 指向该目录即可，之后使用 go 命令即可为当前指定的版本&lt;/p>
&lt;h1 id="初始化项目">初始化项目&lt;/h1>
&lt;p>Go 的项目通常由 &lt;a href="https://www.typescriptlang.org/">Go Module&lt;/a> 管理，项目目录中通常必须包含如下几个文件：&lt;/p>
&lt;ul>
&lt;li>go.mod&lt;/li>
&lt;li>go.sum&lt;/li>
&lt;/ul>
&lt;p>go 相关工具通过 &lt;code>go.mod&lt;/code> 与 &lt;code>go.sum&lt;/code> 两个文件管理项目及其依赖&lt;/p>
&lt;p>使用 &lt;code>go mod init &amp;lt;NAME&amp;gt;&lt;/code> 命令在当前目录会创建一个 go.mod 文件。有任何新的 import，都可以通过 &lt;code>go mod tidy&lt;/code> 生成依赖文件再生成 &lt;code>go.sum&lt;/code> 文件。&lt;/p>
&lt;h1 id="编译-go">编译 Go&lt;/h1>
&lt;p>若想在 Windows 中编译依赖 gcc 的项目，则需要安装 gcc 编译器（i.e.&lt;a href="https://sourceforge.net/projects/mingw-w64/">MinGW-w64&lt;/a>）在 file 标签中，下载 &lt;a href="https://sourceforge.net/projects/mingw-w64/files/Toolchains%20targetting%20Win64/Personal%20Builds/mingw-builds/8.1.0/threads-win32/seh/x86_64-8.1.0-release-win32-seh-rt_v6-rev0.7z">x86_64-win32-seh&lt;/a> 这个版本并安装即可。这是一个 tar 包，解压完成后，需要在 Windows 的 ${PATH} 环境变量中，添加解压出来的 bin 目录，通常都在 &lt;code>PATH\TO\x86_64-8.1.0-release-win32-seh-rt_v6-rev0\mingw64\bin&lt;/code> 这里&lt;/p>
&lt;h2 id="交叉编译">交叉编译&lt;/h2>
&lt;p>Linux 下编译出 Windows 的程序。需要安装 Windows 版的 gcc 工具（i.e.&lt;a href="https://www.mingw-w64.org/">MinGW-w64&lt;/a>）(有的环境还需要安装 gcc-multilib 包)&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>sudo apt-get install gcc-mingw-w64
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>GOOS&lt;span style="color:#f92672">=&lt;/span>windows GOARCH&lt;span style="color:#f92672">=&lt;/span>amd64 CGO_ENABLED&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span> CC&lt;span style="color:#f92672">=&lt;/span>x86_64-w64-mingw32-gcc go build
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="在容器中编译">在容器中编译&lt;/h2>
&lt;h3 id="golang-镜像">golang 镜像&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>docker run -it -v /&lt;span style="color:#e6db74">${&lt;/span>YourPackageSrc&lt;span style="color:#e6db74">}&lt;/span>:/go/work &lt;span style="color:#ae81ff">\
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">&lt;/span> -w /go/work &lt;span style="color:#ae81ff">\
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">&lt;/span> golang:1.17 go build
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>多次使用&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>docker run -it --network host --name golang &lt;span style="color:#ae81ff">\
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">&lt;/span> -v /root/projects:/root/projects &lt;span style="color:#ae81ff">\
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">&lt;/span> -v /root/go:/go &lt;span style="color:#ae81ff">\
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">&lt;/span> golang:1.17 /bin/bash
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>一次性构建&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>docker run -it -v /root/projects/&lt;span style="color:#e6db74">${&lt;/span>Project&lt;span style="color:#e6db74">}&lt;/span>:/go/work &lt;span style="color:#ae81ff">\
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">&lt;/span> -w /go/work &lt;span style="color:#ae81ff">\
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">&lt;/span> golang:1.17 go build cmd/XX.go
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="go-mingw-镜像">go-mingw 镜像&lt;/h3>
&lt;p>镜像，用于使用基于官方 Go Docker 镜像的 MinGW-w64 工具链为 Windows 构建 Go 二进制文件。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>docker run --rm -it -v /&lt;span style="color:#e6db74">${&lt;/span>YourPackageSrc&lt;span style="color:#e6db74">}&lt;/span>:/go/work &lt;span style="color:#ae81ff">\
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">&lt;/span> -w /go/work &lt;span style="color:#ae81ff">\
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">&lt;/span> -e GOPROXY&lt;span style="color:#f92672">=&lt;/span>https://goproxy.cn,https://goproxy.io,direct
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> x1unix/go-mingw go build
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h1 id="go-关联文件与配置">Go 关联文件与配置&lt;/h1>
&lt;p>Go 程序的很多关联文件都可以通过 Go 环境变量进行配置，所以绝大部分关联文件都以变量的形式记录。
&lt;strong>$GOPATH&lt;/strong> # GOPATH 环境变量列出了寻找 Go 代码的位置。&lt;strong>同时也是存储 Go 模块的目录，即 go mod 相关命令保存数据的目录&lt;/strong>。&lt;/p>
&lt;ul>
&lt;li>&lt;strong>./pkg/mod/&lt;/strong> # 存储下载的源代码。&lt;/li>
&lt;li>&lt;strong>./bin/&lt;/strong> # 存储编译的命令。下载的依赖包中若包含二进制文件，也会保存在这个目录中&lt;/li>
&lt;/ul>
&lt;h2 id="go-环境变量">Go 环境变量&lt;/h2>
&lt;p>Go 通过环境变量来配置其运行行为，通过 go env 命令可以看到当前使用的环境变量：
&lt;strong>GO111MODULE=&amp;ldquo;on|off&amp;rdquo;&lt;/strong> # 设置是否使用 go mod，该环境变量将于 1.17 版本删除，并从此开始仅支持 go mod
GOARCH=&amp;ldquo;amd64&amp;rdquo;
GOBIN=&amp;quot;&amp;quot;
GOCACHE=&amp;quot;/root/.cache/go-build&amp;quot;
GOENV=&amp;quot;/root/.config/go/env&amp;quot;
GOEXE=&amp;quot;&amp;quot;
GOFLAGS=&amp;quot;&amp;quot;
GOHOSTARCH=&amp;ldquo;amd64&amp;rdquo;
GOHOSTOS=&amp;ldquo;linux&amp;rdquo;
GOINSECURE=&amp;quot;&amp;quot;
GOMODCACHE=&amp;quot;/root/go/pkg/mod&amp;quot;
GONOPROXY=&amp;quot;&amp;quot;
GONOSUMDB=&amp;quot;&amp;quot;
GOOS=&amp;ldquo;linux&amp;rdquo;
&lt;strong>GOPATH=&lt;!-- raw HTML omitted -->&lt;/strong> # 设置 gopath 所在路径。默认值：&lt;code>~/go&lt;/code>
GOPRIVATE=&amp;quot;&amp;quot;
**GOPROXY=&lt;!-- raw HTML omitted --> **# 设置 go get、go install 命令时，所使用的代理服务器。可以加快获取第三方库的速度。
&lt;strong>GOROOT=&lt;!-- raw HTML omitted -->&lt;/strong> # Go 的安装路径。默认值：Go 的安装路径，Linux 中通常为 /usr/local/go
GOSUMDB=&amp;ldquo;sum.golang.org&amp;rdquo;
GOTMPDIR=&amp;quot;&amp;quot;
GOTOOLDIR=&amp;quot;/usr/local/go/pkg/tool/linux_amd64&amp;quot;
GOVCS=&amp;quot;&amp;quot;
GOVERSION=&amp;ldquo;go1.16.4&amp;rdquo;
GCCGO=&amp;ldquo;gccgo&amp;rdquo;
AR=&amp;ldquo;ar&amp;rdquo;
CC=&amp;ldquo;gcc&amp;rdquo;
CXX=&amp;ldquo;g++&amp;rdquo;
&lt;strong>CGO_ENABLED=&amp;ldquo;0&amp;rdquo;&lt;/strong> # CGO_ENABLED 开启后 Go 代码最终编译的可执行文件都是要有外部依赖的。不过我们依然可以通过 disable CGO_ENABLED 来编译出纯静态的 Go 程序，常用于交叉编译。CGO_ENABLED 关闭即可编译出纯静态的 Go 程序，可以用于 alpine 镜像中。
GOMOD=&amp;quot;/dev/null&amp;quot;
CGO_CFLAGS=&amp;quot;-g -O2&amp;quot;
CGO_CPPFLAGS=&amp;quot;&amp;quot;
CGO_CXXFLAGS=&amp;quot;-g -O2&amp;quot;
CGO_FFLAGS=&amp;quot;-g -O2&amp;quot;
CGO_LDFLAGS=&amp;quot;-g -O2&amp;quot;
PKG_CONFIG=&amp;ldquo;pkg-config&amp;rdquo;
GOGCCFLAGS=&amp;quot;-fPIC -m64 -fmessage-length=0 -fdebug-prefix-map=/tmp/go-build1775394647=/tmp/go-build -gno-record-gcc-switches&amp;quot;&lt;/p>
&lt;h2 id="goproxy-说明">goproxy 说明&lt;/h2>
&lt;p>我把老哥的 Issue 转移到这里来了哈，这个项目才是 &lt;a href="https://goproxy.cn/">goproxy.cn&lt;/a> 的源代码。&lt;a href="https://github.com/goproxy/goproxy">Goproxy&lt;/a> 是这个项目所基于的底层 Go module proxy 实现，它针对的不只是国内的开发者，所以既不建议用中文也不适合讨论 &lt;a href="https://goproxy.cn/">goproxy.cn&lt;/a>。这里讨论老哥你的问题才更为合适。
我先说一下 &lt;a href="https://goproxy.cn/">goproxy.cn&lt;/a> 和 &lt;a href="https://goproxy.io/">goproxy.io&lt;/a> 的背景。io 是由坤哥（&lt;a href="https://github.com/oiooj">@oiooj&lt;/a>）开发出来的，要早于 cn 出现几个月，目前由他跑在他所任职的公司腾讯云的香港区服务器上。cn 是由我发起的，现在完全属于七牛云，也备案在他们名下，自然所有的 CDN 资源和服务器资源都是由他们提供的，我目前跟 cn 的关系是属于它的维护者，并不是拥有者。
再说一下为什么会有两个这么相似的域名且功能类似的项目存在。我注册 cn 是去年二月底，当时是直接查询的 cn 后缀，因为我想的是这种项目肯定也就咱们中国是刚需要单独再来一套，所以并没有查询别的后缀，因为我认为 cn 实在是太合适了。并且由于当时我还在忙我的本科毕设和其他的一下事情，二月份我并没有开始开发 cn，等开发完了跟七牛云的 CEO 许叔（&lt;a href="https://github.com/xushiwei">@xushiwei&lt;/a>）谈交给他们运营时候，我才第一次听同学说到了 io。但当时我点进 io 的 GitHub 仓库一看发现并没有任何地方提到中国并且全是英文就下意识以为它是个国外项目，就没做过多研究，并且的 io 服务器当时也在美国我访问速度有些慢，就也没在意了。
最后再说一下为什么两个项目没有合并了一起发展。这个我和坤哥是有讨论过的，因为有人找上了我跟坤哥。并且坤哥也同意了最后我的提议合并了两个项目，将 cn 留作国内的公共代理，将 io 的代理类流量重定向到 cn 并后续将 io 用作一款搭代理的开源软件来面向全球提供给大家替换掉 JFrog 的一款商业产品，目前只有这一种解决方案才能保持两个功能独立且都能继续存活下去。坤哥之所以能同意我的这个提议一方面是坤哥所任职的公司加班过于严重，还有一方面是他自身没有精力维护了。然后之所以选择留 cn 做公共代理一方面是这两个域名里面只有 cn 能做备案能挂上 CDN 服务，因为这种类型的项目 CDN 服务是刚需，还有一方面是 io 这个域名后缀做全球化项目比 cn 更为合适，所以留 io 作国内代理把 cn 用作面向全球的搭代理的软件就显得很别扭了。
为什么两个项目现在没有合并呢？这个就不是因为我们两个作者了，因为我们两个作者已经达成了一致可以合并。这里面还有第三方地插足（为保其名誉我暂时不提具体是谁），其认为公共代理必须交由其所掌控的“社区”来运营，cn 已经过户给了一家商业公司无法再过户给其所掌控的“社区”，所以 cn 在其眼里就变成了一个其所描述的邪恶公司所拥有的商业产品，于是其要求我和七牛商谈放弃 cn 并全力投入为其做别的开发，于是被我拒绝。最后坤哥在中间处境比较尴尬，所以合并的事儿也就暂时搁置了。
最后，简单来总结一下就是，&lt;a href="https://goproxy.cn/">goproxy.cn&lt;/a> 和 &lt;a href="https://goproxy.io/">goproxy.io&lt;/a> 目前并无直接关系。或许之后没有了第三方地插足它们两个会合并变得有关系，但在那之前它们唯一能联系在一起的是它们都可以用作为 Go module proxy。至于哪个快、哪个稳、哪个香、用哪个，这个需要老哥你自己做判断了，我跟坤哥的关系并不差，所以我现在不会妄加评论。更何况现在 &lt;code>GOPROXY&lt;/code> 不是支持逗号列表嘛。❤️&lt;/p>
&lt;h2 id="gopath">GOPATH&lt;/h2>
&lt;p>注意：以下对 GOPATH 的理解是在 golang1.13 版本之前&lt;/p>
&lt;p>GOPATH 就是 go 项目的工作目录，是开发人员写代码的目录。&lt;/p>
&lt;p>GOPATH 里面一般包含 bin、pkg、src 这 3 个文件夹。&lt;/p>
&lt;p>项目文件夹一般是放在 src 目录中&lt;/p>
&lt;p>一般情况下，如果自己在开发多个项目，那么最好一个项目对应一个 GOPATH 路径。这时候只需要切换 GOPATH 环境变量的值，就可以编译运行对应的项目了。(比如我有两个项目目录/root/cobra 和/root/bee，这俩目录可以分别作为 GOPATH 变量的值，想开发哪个，就把 GOPATH 变量的值改为对应的目录路径)&lt;/p>
&lt;p>这样做的目的主要是为了让每个项目所依赖的库等东西，可以分开而不会冲突&lt;/p>
&lt;p>现在有 go module 之后，就可以不用把项目放在 GOPATH 路径下了。具体 go module 的作用详见 1.4.Go module 的介绍及使用.1 新功能 module 的介绍及使用&lt;/p></description></item><item><title>Docs: IPVS</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/3.%E9%9B%86%E7%BE%A4%E4%B8%8E%E5%88%86%E5%B8%83%E5%BC%8F/lvs/ipvs/ipvs/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/3.%E9%9B%86%E7%BE%A4%E4%B8%8E%E5%88%86%E5%B8%83%E5%BC%8F/lvs/ipvs/ipvs/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/IP_Virtual_Server">Wiki,IPVS&lt;/a>&lt;/li>
&lt;li>&lt;a href="http://www.linuxvirtualserver.org/software/ipvs.html">官方文档&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>&lt;strong>IP Virtual Service(IP 虚拟服务，简称 IPVS)&lt;/strong> 是基于 &lt;a href="https://desistdaydream.github.io/docs/IT%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2.Kernel(%E5%86%85%E6%A0%B8)/8.Network%20%E7%AE%A1%E7%90%86/Linux%20%E7%BD%91%E7%BB%9C%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6/Netfilter%20%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6%E7%B3%BB%E7%BB%9F/Netfilter%20%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6%E7%B3%BB%E7%BB%9F.md">Netfilter&lt;/a> 的 Linux 内核模块，用来实现 &lt;a href="docs/IT%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/3.%E9%9B%86%E7%BE%A4%E4%B8%8E%E5%88%86%E5%B8%83%E5%BC%8F/LVS/LVS.md">LVS&lt;/a> 集群中的 &lt;strong>Scheduler(调度器)&lt;/strong> 功能。启动这个模块的 Linux 服务器就变成了 LVS 系统中的 &lt;strong>Director&lt;/strong>，此时，这个服务器可以看作是一种高效的 Layer-4(四层) 交换机。在 Director 上运行 IPVS 代码是 LVS 的基本要素。&lt;/p>
&lt;p>IPVS 在服务器上运行，并充当 RS 集群前面的负载均衡器。IPVS 可以将基于 TCP 和 UDP 的服务请求定向到真实服务器，并使真实服务器的服务在单个 IP 地址上表现为虚拟服务。当一个 TCP 连接的初始 SYN 报文到达时，IPVS 就选择一台服务器，将报文转发给它。此后通过查发报文的 IP 和 TCP 报文头地址，保证此连接的后继报文被转发到相同的服务器。这样，IPVS 无法检查到请求的内容再选择服务器，这就要求后端的服务器组是提供相同的服务，不管请求被送到哪一台服务器，返回结果都应该是一样的。但是在有一些应用中后端的服务器可能功能不一，有的是提供 HTML 文档的 Web 服务器，有的是提供图片的 Web 服务器，有的是提供 CGI 的 Web 服务器。这时，就需要基于内容请求分发 (Content-Based Request Distribution)，同时基于内容请求分发可以提高后端服务器上访问的局部性。&lt;/p>
&lt;ul>
&lt;li>一个 ipvs 主机可以同时定义多个 cluster service&lt;/li>
&lt;li>一个 cluster service 上至少应该定义一个 real server，定义时指明 lvs-type，以及 lvs scheduler&lt;/li>
&lt;/ul>
&lt;p>用白话理解 IPVS：
IPVS 就是包括 Director 和 RS 在内的所有设备上的 IP，统一虚拟成一个 IP，这个 IP 就是面向用户的唯一 IP，用户通过这个 IP，就可以访问集群，让集群为其提供服务，这也是负载均衡的体现，也是集群的体现，把很多设备当做一个整体来看。&lt;/p>
&lt;h2 id="ipvs-与-lvs-的关系">IPVS 与 LVS 的关系&lt;/h2>
&lt;p>LVS 更偏向于描述一个概念，而 IPVS 程序则是实现 LVS 的最核心部分。通过 IPVS 以及其管理工具 ipvsadm，可以实现 LVS 中的 Director(指挥器)。而 RS，本质上并不需要 LVS 或者 IPVS 代码支持，只需要在 DR 模式下，配置一些内核参数即可。&lt;/p>
&lt;p>而随着发展，IPVS 已经存单独的程序，被包含在 Linux 内核中，成了了默认自带的模块。&lt;/p>
&lt;p>可以这么说，IPVS 就是 LVS；也可以说，LVS 包含 ipvs 与 ipvsadm。&lt;/p>
&lt;h1 id="ipvs-配置">IPVS 配置&lt;/h1>
&lt;p>ipvs 可以通过两种方式进行配置：&lt;/p>
&lt;ul>
&lt;li>ipvsadm 命令&lt;/li>
&lt;li>ipvs 模块参数&lt;/li>
&lt;/ul>
&lt;p>ipvs 是一个内核模块，所以，想要配置 ipvs 则需要以&lt;a href="https://desistdaydream.github.io/docs/IT%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2.Kernel(%E5%86%85%E6%A0%B8)/1.Linux%20Kernel/Module(%E6%A8%A1%E5%9D%97).md">内核模块&lt;/a>的配置方式来进行配置。可以通过 modinfo -p ip_vs 命令查看该模块可以配置的参数&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>~&lt;span style="color:#f92672">]&lt;/span>&lt;span style="color:#75715e"># modinfo -p ip_vs&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>conn_tab_bits:Set connections&lt;span style="color:#960050;background-color:#1e0010">&amp;#39;&lt;/span> hash size &lt;span style="color:#f92672">(&lt;/span>int&lt;span style="color:#f92672">)&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>现阶段，可用的参数只有一个：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>&lt;strong>conn_tab_bits&lt;/strong> # 设置连接表的大小。&lt;code>默认值：12&lt;/code>。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>该参数控制下面示例中 size 的大小，2 的 12 次方，4096&lt;/p>
&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>root@lichenhao:~# ipvsadm -ln
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>IP Virtual Server version 1.2.1 &lt;span style="color:#f92672">(&lt;/span>size&lt;span style="color:#f92672">=&lt;/span>4096&lt;span style="color:#f92672">)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Prot LocalAddress:Port Scheduler Flags
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> -&amp;gt; RemoteAddress:Port Forward Weight ActiveConn InActConn
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>IPVS connection hash table size，该表用于记录每个进来的连接及路由去向的信息（这个和 iptables 跟踪表类似）。连接的 Hash 表要容纳几百万个并发连接，任何一个报文到达都需要查找连接 Hash 表。Hash 表的查找复杂度为 O(n/m)，其中 n 为 Hash 表中对象的个数，m 为 Hash 表的桶个数。当对象在 Hash 表中均匀分布和 Hash 表的桶个数与对象个数一样多时，Hash 表的查找复杂度可以接近 O(1)&lt;/p>
&lt;p>连接跟踪表中，每行称为一个 hash bucket（hash 桶），桶的个数是一个固定的值 CONFIG_IP_VS_TAB_BITS，默认为 12（2 的 12 次方，4096）。这个值可以调整，该值的大小应该在 8 到 20 之间。&lt;/p>
&lt;p>LVS 的调优建议将 hash table 的值设置为不低于并发连接数。例如，并发连接数为 200，Persistent 时间为 200S，那么 hash 桶的个数应设置为尽可能接近 200x200=40000，2 的 15 次方为 32768 就可以了。当 ip_vs_conn_tab_bits=20 时，哈希表的的大小（条目）为 pow(2,20)，即 1048576。&lt;/p>
&lt;p>这里的 hash 桶的个数，并不是 LVS 最大连接数限制。LVS 使用哈希链表解决“哈希冲突”，当连接数大于这个值时，必然会出现哈稀冲突，会（稍微）降低性能，但是并不对在功能上对 LVS 造成影响。&lt;/p>
&lt;p>修改模块参数：echo &amp;ldquo;options ip_vs conn_tab_bits=22&amp;rdquo; &amp;gt; /etc/modprobe.d/ip_vs.conf，效果如下：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>IP Virtual Server version 1.2.1 &lt;span style="color:#f92672">(&lt;/span>size&lt;span style="color:#f92672">=&lt;/span>4194304&lt;span style="color:#f92672">)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Prot LocalAddress:Port Scheduler Flags
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> -&amp;gt; RemoteAddress:Port Forward Weight ActiveConn InActConn
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>TCP 10.10.9.60:30000 rr persistent &lt;span style="color:#ae81ff">30&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> -&amp;gt; 10.10.9.69:30000 Route &lt;span style="color:#ae81ff">1&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> -&amp;gt; 10.10.9.70:30000 Route &lt;span style="color:#ae81ff">1&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div></description></item><item><title>Docs: KVM/QEMU</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/10.%E4%BA%91%E5%8E%9F%E7%94%9F/1.2.%E5%AE%9E%E7%8E%B0%E8%99%9A%E6%8B%9F%E5%8C%96%E7%9A%84%E5%B7%A5%E5%85%B7/kvm_qemu/kvm_qemu/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/10.%E4%BA%91%E5%8E%9F%E7%94%9F/1.2.%E5%AE%9E%E7%8E%B0%E8%99%9A%E6%8B%9F%E5%8C%96%E7%9A%84%E5%B7%A5%E5%85%B7/kvm_qemu/kvm_qemu/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://www.linux-kvm.org/page/Main_Page">官网&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://ubuntu.com/server/docs/virtualization-qemu">Ubuntu 官方文档，虚拟化-qemu&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;h2 id="kvm-背景">KVM 背景&lt;/h2>
&lt;p>&lt;strong>Kernel-based Virtual Machine(基于内核的虚拟化机器，简称 KVM)&lt;/strong>， 是 Linux 的一个内核模块，就叫 &lt;strong>kvm&lt;/strong>，只用于管理虚拟 CPU 和内存。该内核模块使得 Linux 变成了一个 Hypervisor。&lt;/p>
&lt;ul>
&lt;li>它由 Quramnet 开发，该公司于 2008 年&lt;strong>被 Red Hat 收购&lt;/strong>。&lt;/li>
&lt;li>它支持 x86 (32 and 64 位), s390, Powerpc 等 CPU。&lt;/li>
&lt;li>它从 Linux 2.6.20 起就作为一模块被包含在 Linux 内核中。&lt;/li>
&lt;li>它需要支持虚拟化扩展的 CPU。&lt;/li>
&lt;li>它是完全开源的。&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/zuowkm/1616124035086-2c826a6e-2fd2-402b-babd-06bfe2380e3d.png" alt="">
KVM 实际是 Linux 内核提供的虚拟化架构，可将内核直接充当 Hypervisor 来使用。KVM 需要宿主机的 CPU 本身支持虚拟化扩展，如 intel VT 和 AMD AMD-V 技术。KVM 自 2.6.20 版本后已合入主干并发行。除了支持 x86 的处理器，同时也支持 S/390,PowerPC,IA-61 以及 ARM 等平台。&lt;/p>
&lt;p>KVM 包含包含两个内核模块&lt;/p>
&lt;ol>
&lt;li>kvm 用来实现核心虚拟化功能&lt;/li>
&lt;li>kvm-intel # 与处理器强相关的模块&lt;/li>
&lt;/ol>
&lt;p>KVM 本身只提供了 CPU 和 Memory 的虚拟化，并暴露了一个** **&lt;code>**/dev/kvm**&lt;/code> 设备，以供宿主机上的用户空间的程序访问(比如 下文提到的 QEMU)。用户空间的程序通过 **/dev/kvm** 接口可以实现多种功能：&lt;/p>
&lt;h2 id="qemu-背景">QEMU 背景&lt;/h2>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>QEMU 官网：&lt;a href="https://www.qemu.org/">https://www.qemu.org/&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>QEMU 是一个通过软件实现的完全虚拟化程序，通过动态二进制转换来模拟 CPU，并模拟一系列的硬件，使虚拟机认为自己和硬件直接打交道，其实是同 QEMU 模拟出来的硬件打交道，QEMU 再将这些指令翻译给真正硬件进行操作。通过这种模式，虚拟机可以和主机上的硬盘，网卡，CPU，CD-ROM，音频设备和 USB 设备进行交互。但由于所有指令都需要经过 QEMU 来翻译，因而性能会比较差
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/zuowkm/1616124035102-78899618-45f3-4dcc-9de1-9c80ecd532cb.jpeg" alt="">&lt;/p>
&lt;h2 id="kvmqemu-诞生">KVM/QEMU 诞生&lt;/h2>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/zuowkm/1616124035098-45602829-f8bc-4f49-b65d-56b8dba6c466.png" alt="图片来源：RedHat8 Virtualization Architecture 在 KVM/QEMU Storage Stack Performance Discussion 这篇文章中，作者还画了一个非常形象的图，可以作为参考，下面缩小的图就是" title="图片来源：RedHat8 Virtualization Architecture 在 KVM/QEMU Storage Stack Performance Discussion 这篇文章中，作者还画了一个非常形象的图，可以作为参考，下面缩小的图就是">
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/zuowkm/1616124035057-cdeb1319-ee83-4674-99c3-70a16da96211.jpeg" alt="">
从前面的背景介绍可知，KVM 实现了 CPU 和 Memory 的虚拟化，但 KVM 并不能模拟其他设备，所以需要其他东西来支持其他设备的模拟；而 QEMU 是通过纯软件实现的一套完整的虚拟化，但是性能非常低下。所以 KVM 与 QEMU 天然得相辅相成，KVM 的开发者选择了比较成熟的开源虚拟化软件 QEMU 来模拟 I/O 设备(网卡，磁盘等)，最后形成了 KVM/QEMU。&lt;/p>
&lt;p>在 KVM/QEMU 中，KVM 运行在内核空间，QEMU 运行在用户空间，实际模拟创建、管理各种虚拟硬件，QEMU 将 KVM 整合了进来，通过 ioctl() 系统调用来调用 /dev/kvm 设备，从而将 CPU 指令的部分交给内核模块来做，KVM 实现了 CPU 和 Memory 的虚拟化，QEMU 模拟 IO 设备(磁盘，网卡，显卡等)，KVM 加上 QEMU 后就是完整意义上的服务器虚拟化。&lt;/p>
&lt;p>综上所述，QEMU-KVM 具有两大作用：&lt;/p>
&lt;ul>
&lt;li>KVM 负责 cpu，内存 的虚拟&lt;/li>
&lt;li>QEMU 负责 I/O 设备 的模拟。比如显卡、PCI、USB、声卡、网卡、存储设备等等。&lt;/li>
&lt;/ul>
&lt;h2 id="结语">结语&lt;/h2>
&lt;p>QEMU-KVM，是 QEMU 的一个特定于 KVM 加速模块的分支，里面包含了很多关于 KVM 的特定代码，与 KVM 模块一起配合使用。&lt;/p>
&lt;p>目前 QEMU-KVM 已经与 QEMU 合二为一，所有特定于 KVM 的代码也都合入了 QEMU，当需要与 KVM 模块配合使用的时候，只需要在 QEMU 命令行加上 &amp;ndash;enable-kvm 就可以。&lt;/p>
&lt;h1 id="kvmqeum-虚拟化实现原理">KVM/QEUM 虚拟化实现原理&lt;/h1>
&lt;p>KVM/QEMU 主要通过以下组件来实现完整的虚拟化功能&lt;/p>
&lt;ul>
&lt;li>**kvm.ko.xz **# kvm 内核模块。用来模拟 CPU 与 RAM。&lt;/li>
&lt;li>&lt;strong>/dev/kvm&lt;/strong> # 一个字符设备(也是一个接口)。供用户空间的程序使用 &lt;code>ioctl()&lt;/code> 系统调用来访问 kvm 模块&lt;/li>
&lt;li>&lt;strong>qemu-kvm&lt;/strong> # 一个二进制文件。用来调用&lt;code>/dev/kvm&lt;/code>设备，并为虚拟机模拟各种 I/O 设备。qemu-kvm 也是最基本的用于创建虚拟机的命令行工具。&lt;/li>
&lt;/ul>
&lt;p>KVM/QEMU 通过 &lt;a href="https://www.yuque.com/go/doc/33175246">qemu-kvm 命令行工具&lt;/a>来创建 VM。qemu-kvm 程序使用 /dev/kvm 接口来调用 kvm 模块，以运行 VM。qemu-vm 也是创建 VM 的最基础工具。使用 /dev/kvm 接口的 qemu-kvm 程序可以提供如下能力：&lt;/p>
&lt;ul>
&lt;li>设置 VM 的地址空间。宿主机必须提供固件镜像(通常为模拟出来的 BIOS)以便让 VM 可以引导到 操作系统中&lt;/li>
&lt;li>为 VM 模拟 I/O 设备。&lt;/li>
&lt;li>将 VM 的视频显示映射回宿主机上。&lt;/li>
&lt;/ul>
&lt;h2 id="virtualization-cpu--memory">Virtualization CPU &amp;amp;&amp;amp; Memory&lt;/h2>
&lt;h3 id="cpu-虚拟化">CPU 虚拟化&lt;/h3>
&lt;p>QEMU 创建 CPU 线程，在初始化的时候设置好相应的虚拟 CPU 寄存器的值，然后调用 KVM 的接口，运行虚拟机，在物理 CPU 上执行虚拟机代码。&lt;/p>
&lt;p>在虚拟机运行时，KVM 会截获虚拟机中的敏感指令，当虚拟机中的代码是敏感指令或者满足了一定的退出条件时，CPU 会从 VMX non-root 模式退出到 KVM，这就是下图的 VM exit。虚拟机的退出首先陷入到 KVM 进行处理，但是如果遇到 KVM 无法处理的事件，比如虚拟机写了设备的寄存器地址，那么 KVM 就会将这个操作交给 QEMU 处理。当 QEMU/KVM 处理好了退出事件后，又会将 CPU 置于 VMX non-root 模式，也就是下图的 VM Entry。&lt;/p>
&lt;p>KVM 使用 VMCS 结构来保存 VM Exit 和 VM Entry
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/zuowkm/1616124035076-0336490e-7922-482c-91be-ee6b0a2ba562.png" alt="">&lt;/p>
&lt;h3 id="memory-虚拟化">Memory 虚拟化&lt;/h3>
&lt;p>QEMU 初始化时调用 KVM 接口告知 KVM，虚拟机所需要的物理内存，通过 mmap 分配宿主机的虚拟内存空间作为虚拟机的物理内存，QEMU 在更新内存布局时会持续调用 KVM 通知内核 KVM 模块虚拟机的内存分布。&lt;/p>
&lt;p>在 CPU 支持 EPT（拓展页表）后，CPU 会自动完成&lt;strong>虚拟机物理地址&lt;/strong>到&lt;strong>宿主机物理地址&lt;/strong>的转换。虚拟机第一次访问内存的时候会陷入 KVM，KVM 逐渐建立起 EPT 页面。这样后续的虚拟机的虚拟 CPU 访问虚拟机&lt;strong>虚拟内存地址&lt;/strong>时，会先被转换为&lt;strong>虚拟机物理地址&lt;/strong>，接着查找 EPT 表，获取宿主机物理地址
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/zuowkm/1616124035074-4de2d638-b8fb-499c-a1de-92ce5e6a10b3.png" alt="">&lt;/p>
&lt;h2 id="paravirtualized-devices半虚拟化设备">Paravirtualized Devices(半虚拟化设备)&lt;/h2>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/7/html/virtualization_getting_started_guide/sec-virtualization_getting_started-products-virtualized-hardware-devices#sec-Virtualization_Getting_Started-Products-paravirtdevices">RedHat7 虚拟化硬件设备章节中的半虚拟化章节&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>半虚拟化设备，就是 Qemu 模拟的各种 I/O 设备&lt;/p>
&lt;p>在 QEMU/KVM 早期模拟其他的硬件(如存储、网络设备)性能不足。为了提高 IO 设备性能，所以产生了 &lt;strong>Paravirtualized Devices(半虚拟化设备)&lt;/strong>，Paravirtualized(半虚拟化) 为 VM 使用宿主机上的设备提供了&lt;strong>快速且高效的通讯方式&lt;/strong>。KVM/QEMU 使用 &lt;strong>Virtio API&lt;/strong> 作为 VM 与 Hypervisor 的中间层，以便为 VM 提供 Paravirtualized Devices(半虚拟化设备)。&lt;/p>
&lt;blockquote>
&lt;p>一些半虚拟化设备可以有效减少 I/O 的延迟，并把 I/O 的吞吐量提高至接近裸机的水平。&lt;/p>
&lt;/blockquote>
&lt;p>所有 &lt;strong>Virtio&lt;/strong> 设备都&lt;strong>由两部分组成&lt;/strong>：&lt;/p>
&lt;ul>
&lt;li>**Host Device **# 宿主机设备(也称为后端设备)&lt;/li>
&lt;li>&lt;strong>Guest Device&lt;/strong> # 虚拟机设备(也称为前端设备)&lt;/li>
&lt;/ul>
&lt;p>Paravirtualizd device driver(半虚拟化设备驱动) 可以让 VM 直接访问宿主机上的物理硬件设备。
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/zuowkm/1616124035106-08438d88-b937-43b9-af1c-01ddb6771941.jpeg" alt="">
现阶段有多种半虚拟化设备可供使用&lt;/p>
&lt;ul>
&lt;li>virtio-net(半虚拟化网络设备) # 半虚拟化网络设备是一种虚拟网络设备，可通过增加的 I/O 性能和较低的延迟为虚拟机提供网络访问。&lt;/li>
&lt;li>virtio-blk(半虚拟化块设备) # 半虚拟化块设备是一种高性能的虚拟存储设备，可为虚拟机提供更高的 I / O 性能和更低的延迟。 虚拟机管理程序支持半虚拟化的块设备，该设备已连接到虚拟机（必须仿真的软盘驱动器除外）。&lt;/li>
&lt;li>virtio-scsi(半虚拟化控制器设备) # 半虚拟化 SCSI 控制器设备是一种更为灵活且可扩展的 virtio-blk 替代品。virtio-scsi 客机能继承目标设备的各种特征，并且能操作几百个设备，相比之下，virtio-blk 仅能处理 28 台设备。&lt;/li>
&lt;li>半虚拟化时钟&lt;/li>
&lt;li>virtio-serial(半虚拟化串口设备) #&lt;/li>
&lt;li>virtio-ballon(气球设备) # 气球（ballon）设备可以指定虚拟机的部分内存为没有被使用（这个过程被称为气球“&lt;em>充气&lt;/em> ” — inflation），从而使这部分内存可以被主机（或主机上的其它虚拟机）使用。当虚拟机这部分内存时，气球可以进行“&lt;em>放气&lt;/em> ”（deflated），主机就会把这部分内存重新分配给虚拟机。&lt;/li>
&lt;li>virtio-rng(半虚拟化随机数生成器)&lt;/li>
&lt;li>QXL(半虚拟化显卡) # 半虚拟化显卡与 QXL 驱动一同提供了一个有效地显示来自远程主机的虚拟机图形界面。SPICE 需要 QXL 驱动。&lt;/li>
&lt;/ul>
&lt;h3 id="创建虚拟机示例">创建虚拟机示例&lt;/h3>
&lt;p>qemu-kvm 命令中的 &lt;code>-device&lt;/code> 选项用于指定前端设备，比如 网卡、磁盘、usb 等等。而 &lt;code>-XXXXdev&lt;/code>等选项则是为了指定宿后端设备。比如宿主机上的文件、socket 等等&lt;/p>
&lt;p>qemu-kvm 使用 &lt;code>-device&lt;/code> 选项指定的参数将这些模拟出来的硬件设备，通过 ID 关联到&lt;code>-XXXdev&lt;/code>定的宿主机文件上。&lt;/p>
&lt;p>而在新版，则使用了更简单的方式，通过一个选项，来直接指定半虚拟化的两端设备，比如使用 &lt;code>-drive&lt;/code> 代替 &lt;code>-device&lt;/code> 和 &lt;code>-blockdev&lt;/code>、使用 &lt;code>-nic&lt;/code> 代替 &lt;code>-device&lt;/code> 和 &lt;code>-netdev&lt;/code> 等等。&lt;/p>
&lt;p>比如下面的示例：&lt;/p>
&lt;pre>&lt;code>qemu-kvm -m 4096 -smp 2 -name test \
# 模拟块设备
# -drive 使新版选项，是 -blockdev 和 -device 两个参数的集合，可以模拟一个块设备
# Host Device 为 /var/lib/libvirt/images/test-2.bj-net.qcow2
# Guest Device 为 virtio-blk 设备
-drive file=/var/lib/libvirt/images/test-2.bj-net.qcow2,format=qcow2,if=virtio \
-vnc :3 \
# 模拟网卡
# -netdev 指定 Host Device(宿主机设备) 为 tap 类型的网络设备
# -device 指定 Guest Device(虚拟机设备) 为 virtio-net 设备
-netdev tap,id=n1 \
-device virtio-net,netdev=n1 \
# 模拟串口
# -chardev 指定 Host Device(宿主机设备)为 socket
# -device 指定 Guest Device(虚拟机设备)为 virtio-serial
# virtserialport 是 virtio-serial-port 的意思
-chardev socket,path=/tmp/qga.sock,server,nowait,id=qga0 \
-device virtio-serial \
-device virtserialport,chardev=qga0,name=org.qemu.guest_agent.0
&lt;/code>&lt;/pre>
&lt;p>可以看到，所有通过 -device 选项在 VM 中模拟的硬件设备，都会根据 ID 关联到宿主机的某个文件或者设备上。&lt;/p>
&lt;p>而且还有一个 -drive 选项这种更简单的使用方式，来免去设定 ID 的困扰，并且输入的字符更少。&lt;/p>
&lt;h2 id="总结一下">总结一下&lt;/h2>
&lt;p>KVM/QEMU 虚拟化环境中，除了 CPU 与 Memory 是通过 KVM 虚拟化的，其他所有硬件设备，都是通过 QEMU 模拟出来，并且，要想让模拟出来的硬件设备能正常工作(模拟的硬件与宿主机交互)，则还需要在宿主机上创建与之关联的文件。所以，一共两部分来实现 QEMU 的模拟功能。&lt;/p>
&lt;ol>
&lt;li>&lt;strong>一部分是 QEMU 在 VM 中模拟出来的各种硬件&lt;/strong>&lt;/li>
&lt;li>&lt;strong>另一部分是在宿主机中与 VM 中模拟出来的硬件对应的各种文件或设备&lt;/strong>。&lt;/li>
&lt;/ol>
&lt;p>这两部分共同实现了 VM 中模拟的硬件与宿主机交互的能力。如果 VM 中的硬件与宿主机无法交互，那么是无法使用滴~~~&lt;/p>
&lt;h1 id="qemu-storage-emulationqemu-存储模拟">QEMU Storage Emulation(QEMU 存储模拟)&lt;/h1>
&lt;p>与 &lt;a href="https://www.yuque.com/desistdaydream/learning/tkr8dt#03psa">网络模拟&lt;/a> 类似，QEMU 想要让虚拟机获得一块硬盘，也需要由两部分组成一个完整的存储功能。&lt;/p>
&lt;ol>
&lt;li>&lt;strong>front-end(前端)&lt;/strong> # VM 中的 块设备&lt;/li>
&lt;li>**back-end(后端) **# 宿主机中的与 VM 中模拟出来的块设备进行交互的设备。&lt;/li>
&lt;/ol>
&lt;h1 id="qemu-network-emulationqemu-网络模拟">QEMU Network Emulation(QEMU 网络模拟)&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://wiki.qemu.org/Documentation/Networking">https://wiki.qemu.org/Documentation/Networking&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.qemu.org/docs/master/system/net.html">https://www.qemu.org/docs/master/system/net.html&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.qemu.org/2018/05/31/nic-parameter/">https://www.qemu.org/2018/05/31/nic-parameter/&lt;/a>，老版原理，将弃用&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>QEMU 想要让虚拟机与外界互通，需要由两部分组成一个完整的网络功能：&lt;/p>
&lt;ul>
&lt;li>&lt;strong>front-end(前端)&lt;/strong> # VM 中的 NIC(Network Interface Controller，即人们常说的&lt;code>网卡&lt;/code>)。
&lt;ul>
&lt;li>VM 中的 NIC 是由 QEMU 模拟出来的，在支持 PCI 卡的系统上，通常可以是 e1000 网卡、rtl8139 网卡、virtio-net 设备。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>**back-end(后端) **# 宿主机中的与 VM 中模拟出来的 NIC 进行交互的设备。
&lt;ul>
&lt;li>back-end 有多种类型可以使用，这些后端可以用于将 VM 连接到真实网络，或连接到另一个 VM
&lt;ul>
&lt;li>&lt;a href="https://www.qemu.org/docs/master/system/net.html#using-tap-network-interfaces">TAP &lt;/a># 将 VM 连接到真实网络的标准方法&lt;/li>
&lt;li>&lt;a href="https://www.qemu.org/docs/master/system/net.html#using-the-user-mode-network-stack">User mode network stack&lt;/a>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>效果如图所示：
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/zuowkm/1616124035097-0a64383e-f37f-4cc3-bdc2-3c7502189b7d.png" alt="">&lt;/p>
&lt;h2 id="基本应用示例">基本应用示例&lt;/h2>
&lt;p>在使用 qemu-kvm 命令创建虚拟机时，通过一组两个选项来为虚拟机创建一个网络设备。比如：&lt;/p>
&lt;ul>
&lt;li>&lt;code>-netdev tap,id=n1&lt;/code> # 在宿主机创建一个&lt;code>后端设备&lt;/code>，这是一个 tap 类型的网络设备(tap 类型的设备路径为 /dev/net/tun)&lt;/li>
&lt;li>&lt;code>-device virtio-net-pci,netdev=n1&lt;/code> # 在 VM 中模拟一个&lt;code>前端设备&lt;/code>，这是一个 virtio-net-pci 类型的网卡&lt;/li>
&lt;/ul>
&lt;p>完整的命令如下：&lt;/p>
&lt;pre>&lt;code>qemu-kvm -m 4096 -smp 2 -name test \
-drive file=/var/lib/libvirt/images/test-1.bj-net.qcow2,format=qcow2,if=virtio \
-netdev tap,id=n1 \
-device virtio-net-pci,netdev=n1 \
-vnc :3
&lt;/code>&lt;/pre>
&lt;p>此时 qemu-kvm 发现 &lt;code>后端设备的 id&lt;/code> 与 &lt;code>前端设备的属性(netdev)的值&lt;/code> 一致，那么 qemu-kvm 就会将 两端设备关联。因此，在 VM 启动时，其打开了设备文件 /dev/net/tun 并获得了读写该文件的文件描述符 (FD)XX，同时向内核注册了一个 tap 类型虚拟网卡 tapX，tapX 与 FD XX 关联，虚拟机关闭时 tapX 设备会被内核释放。此虚拟网卡 tapX 一端连接用户空间程序 qemu-kvm，另一端连接主机链路层。&lt;/p>
&lt;pre>&lt;code>## 通过进程，获取该进程所使用的网络设备
# 当先宿主机上有3个虚拟机，分别对应 82649、82747、144776 这三个进程
# 82649 与 82747 使用网卡多队列功能，启用了8个队列，144776 仅有一个网卡队列
# 所以，82649 与 82747 打开了8个 /dev/net/tun 设备，而 144776 打开了1个 /dev/net/tun 设备
[root@host-3 fdinfo]# lsof /dev/net/tun
COMMAND PID USER FD TYPE DEVICE SIZE/OFF NODE NAME
qemu-kvm 82649 qemu 27u CHR 10,200 0t0 102414 /dev/net/tun
qemu-kvm 82649 qemu 29u CHR 10,200 0t0 102414 /dev/net/tun
qemu-kvm 82649 qemu 31u CHR 10,200 0t0 102414 /dev/net/tun
qemu-kvm 82649 qemu 32u CHR 10,200 0t0 102414 /dev/net/tun
qemu-kvm 82649 qemu 33u CHR 10,200 0t0 102414 /dev/net/tun
qemu-kvm 82649 qemu 34u CHR 10,200 0t0 102414 /dev/net/tun
qemu-kvm 82649 qemu 35u CHR 10,200 0t0 102414 /dev/net/tun
qemu-kvm 82649 qemu 36u CHR 10,200 0t0 102414 /dev/net/tun
qemu-kvm 82747 qemu 28u CHR 10,200 0t0 102414 /dev/net/tun
qemu-kvm 82747 qemu 31u CHR 10,200 0t0 102414 /dev/net/tun
qemu-kvm 82747 qemu 32u CHR 10,200 0t0 102414 /dev/net/tun
qemu-kvm 82747 qemu 33u CHR 10,200 0t0 102414 /dev/net/tun
qemu-kvm 82747 qemu 34u CHR 10,200 0t0 102414 /dev/net/tun
qemu-kvm 82747 qemu 35u CHR 10,200 0t0 102414 /dev/net/tun
qemu-kvm 82747 qemu 36u CHR 10,200 0t0 102414 /dev/net/tun
qemu-kvm 82747 qemu 37u CHR 10,200 0t0 102414 /dev/net/tun
qemu-kvm 144776 qemu 31u CHR 10,200 0t0 102414 /dev/net/tun
# 查看 144776 进程的 fdinfo 中的 31 号描述符文件，可以看到该进程关联的网络设备是 vnet2
[root@host-3 fdinfo]# cat /proc/144776/fdinfo/31
pos: 0
flags: 0104002
mnt_id: 20
iff: vnet2
## 通过网络设备，获取使用该设备的进程
# 可以通过一条命令来直接获取使用指定 pid 设备的进程
# 下面的命令可以获取使用 vnet2 这个 tap 类型的网络设备的进程。
[root@host-3 fdinfo]# egrep -l iff:.*vnet2 /proc/*/fdinfo/* 2&amp;gt; /dev/null | cut -d/ -f3
144776
&lt;/code>&lt;/pre>
&lt;p>所以 144776 这个进程下的虚拟机经过其内部网卡发送的数据包，都会发送到 /dev/net/tun 设备上，然后根据其文件描述符，找到对应的 tap 设备，将数据包转发过去。这样，虚拟机的数据就通过网络，发送到物理机上了。&lt;/p>
&lt;blockquote>
&lt;p>获取 tap 设备 与 VM 关联性的方法参考：&lt;a href="https://unix.stackexchange.com/questions/462171/how-to-find-the-connection-between-tap-interface-and-its-file-descriptor">https://unix.stackexchange.com/questions/462171/how-to-find-the-connection-between-tap-interface-and-its-file-descriptor&lt;/a>&lt;/p>
&lt;/blockquote>
&lt;h2 id="virbr0-说明">virbr0 说明&lt;/h2>
&lt;p>virbr0 是 KVM 默认创建的一个 Bridge，其作用是为连接其上的虚机网卡提供 NAT 访问外网的功能。virbr0 默认分配了一个 IP 192.168.122.1，并为连接其上的其他虚拟网卡提供 DHCP 服务。&lt;/p>
&lt;ul>
&lt;li>需要说明的是，使用 NAT 的虚机 VM1 可以访问外网，但外网无法直接访问 VM1。 因为 VM1 发出的网络包源地址并不是 192.168.122.6，而是被 NAT 替换为宿主机的 IP 了。&lt;/li>
&lt;li>这个与使用 br0 不一样，在 br0 的情况下，VM1 通过自己的 IP 直接与外网通信，不会经过 NAT 地址转换。&lt;/li>
&lt;/ul></description></item><item><title>Docs: Libvirt</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/10.%E4%BA%91%E5%8E%9F%E7%94%9F/1.2.%E5%AE%9E%E7%8E%B0%E8%99%9A%E6%8B%9F%E5%8C%96%E7%9A%84%E5%B7%A5%E5%85%B7/%E8%99%9A%E6%8B%9F%E5%8C%96%E7%AE%A1%E7%90%86/libvirt/libvirt/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/10.%E4%BA%91%E5%8E%9F%E7%94%9F/1.2.%E5%AE%9E%E7%8E%B0%E8%99%9A%E6%8B%9F%E5%8C%96%E7%9A%84%E5%B7%A5%E5%85%B7/%E8%99%9A%E6%8B%9F%E5%8C%96%E7%AE%A1%E7%90%86/libvirt/libvirt/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://github.com/libvirt">GitHub 组织，libvirt&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://libvirt.org/">官网&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>Libvirt 是用于管理虚拟化平台的开源的 API，后台程序和管理工具。它可以用于管理 KVM、Xen、VMware ESX，QEMU 和其他虚拟化技术。&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/gglb2f/1616123800173-58542239-2205-4586-bcc0-4edde6579a3f.png" alt="">&lt;/p>
&lt;p>Libvirt 提供了管理虚拟机和其它虚拟化功能（如：存储和网络接口等）的便利途径。这些软件包括：一个长期稳定的 C 语言 API、一个守护进程（libvirtd）和一个命令行工具（virsh）。Libvirt 的主要目标是提供一个单一途径以管理不同类型的虚拟化环境(也称为 drivers 或者 hypervisors )，包括：KVM/QEMU，Xen，VMware， VirtualBox hypervisors，LXC，OpenVZ&lt;/p>
&lt;p>Libvirt 包含 3 个东西：libvirtd、API、virsh&lt;/p>
&lt;ul>
&lt;li>libvirtd # 是守护进程，服务程序，接收和处理 API 请求&lt;/li>
&lt;li>API # 库使得其他人可以开发基于 Libvirt 的高级工具，比如 virt-manager、virt-install、virt-viewer 等。&lt;/li>
&lt;li>virsh # 是我们经常要用的命令行工具&lt;/li>
&lt;/ul>
&lt;p>Note：其实 libvirtd 在绝大部分情况下是与 qemu/kvm 相搭配来使用，都是开源的，并且 redhat 官方推荐的也是使用 libvirt 管理 kvm 虚拟机&lt;/p>
&lt;h2 id="libvirt-原理">Libvirt 原理&lt;/h2>
&lt;p>libvirt 支持不同的虚拟化类型，所以需要一种方法来指定所要连接的虚拟化驱动。&lt;/p>
&lt;p>libvirt 使用 URI 来与各种类型的虚拟化程序连接。官方文档：&lt;a href="https://libvirt.org/uri.html">https://libvirt.org/uri.html&lt;/a>&lt;/p>
&lt;p>libvirt 将使用以下逻辑来确定要使用的 URI。&lt;/p>
&lt;ul>
&lt;li>环境变量 LIBVIRT_DEFAULT_URI&lt;/li>
&lt;li>客户端配置文件 uri_default 参数&lt;/li>
&lt;li>依次探查每个虚拟机监控程序，直到找到有效的虚拟机监控程序&lt;/li>
&lt;/ul>
&lt;h1 id="libvirt-关联文件与配置">Libvirt 关联文件与配置&lt;/h1>
&lt;p>&lt;strong>/etc/libvirt/*&lt;/strong> #&lt;/p>
&lt;ul>
&lt;li>&lt;strong>./libvirt.conf&lt;/strong> # 用于配置用于与虚拟化程序连接的 URI 别名，以及默认 URI&lt;/li>
&lt;li>.&lt;strong>/libvirtd.conf&lt;/strong> # libvirtd 守护进程的配置文件&lt;/li>
&lt;li>.&lt;strong>/qemu/*&lt;/strong> # xml 格式的配置文件存放路径，配置文件包括该 VM 的元数据(名字，uuid，内存，cpu 等)，设备配置(包括使用的硬盘文件的路径，网络类型等)，配置文件为 xml 格式。创建完一台 VM 后，会在该目录下生成对应 VM 名字的 xml 文件&lt;/li>
&lt;li>&lt;strong>./network/*&lt;/strong> #&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>/etc/sysconfig/*&lt;/strong> #&lt;/p>
&lt;ul>
&lt;li>&lt;strong>./libvirtd&lt;/strong> #&lt;/li>
&lt;/ul>
&lt;p>**/var/lib/libvirt/* **#&lt;/p>
&lt;ul>
&lt;li>**./images/* **# 所有通过 libvirt 创建的虚拟机所生成的 images 都保存在该目录下&lt;/li>
&lt;li>**./qemu/snapshot/* **# 创建快照 xml 文件都保存在该目录下&lt;/li>
&lt;/ul></description></item><item><title>Docs: Linux 管理</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/x.linux-%E7%AE%A1%E7%90%86/linux%E7%AE%A1%E7%90%86/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/x.linux-%E7%AE%A1%E7%90%86/linux%E7%AE%A1%E7%90%86/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://www.gnu.org/manual/">GNU Manual(手册)&lt;/a> — Linux 中很多核心程序，都是 GNU 组织下的软件。&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>系统管理员可以通过 一系列用户空间的二进制应用程序来管理 Linux 操作系统。Linux 内核自带了一个名为 coreutils 包，包含了很多最基本的管理工具。&lt;/p>
&lt;p>除了 Coreutils 包，还有很多很多的应用程序，一起组成了一套工具栈，系统管理员可以根据自身的需求，有选择得安装并使用它们。&lt;/p>
&lt;h1 id="coreutils">Coreutils&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/GNU_Core_Utilities">Wiki,GNU Core Utilies&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.gnu.org/software/coreutils/manual/">官方文档&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>GNU Core Utilities 是 GNU 操作系统的基本文件、Shell、文本操作的实用程序。同时，也是现在绝大部分 Linux 发行版内置的实用程序。&lt;/p>
&lt;p>Coreutils 通常可以通过各种 Linux 发行版的包管理器直接安装。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>root@lichenhao:~/downloads# apt-cache show coreutils
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Package: coreutils
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Architecture: amd64
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Version: 8.30-3ubuntu2
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Multi-Arch: foreign
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Priority: required
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Essential: yes
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Section: utils
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Origin: Ubuntu
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Maintainer: Ubuntu Developers &amp;lt;ubuntu-devel-discuss@lists.ubuntu.com&amp;gt;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Original-Maintainer: Michael Stone &amp;lt;mstone@debian.org&amp;gt;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Bugs: https://bugs.launchpad.net/ubuntu/+filebug
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Installed-Size: &lt;span style="color:#ae81ff">7196&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Pre-Depends: libacl1 &lt;span style="color:#f92672">(&lt;/span>&amp;gt;&lt;span style="color:#f92672">=&lt;/span> 2.2.23&lt;span style="color:#f92672">)&lt;/span>, libattr1 &lt;span style="color:#f92672">(&lt;/span>&amp;gt;&lt;span style="color:#f92672">=&lt;/span> 1:2.4.44&lt;span style="color:#f92672">)&lt;/span>, libc6 &lt;span style="color:#f92672">(&lt;/span>&amp;gt;&lt;span style="color:#f92672">=&lt;/span> 2.28&lt;span style="color:#f92672">)&lt;/span>, libselinux1 &lt;span style="color:#f92672">(&lt;/span>&amp;gt;&lt;span style="color:#f92672">=&lt;/span> 2.1.13&lt;span style="color:#f92672">)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Filename: pool/main/c/coreutils/coreutils_8.30-3ubuntu2_amd64.deb
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Size: &lt;span style="color:#ae81ff">1249368&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>MD5sum: e8e201b6d1b7f39776da07f6713e1675
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>SHA1: 1d4ab60c729a361d46a90d92defaca518b2918d2
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>SHA256: 99aa50af84de1737735f2f51e570d60f5842aa1d4a3129527906e7ffda368853
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Homepage: http://gnu.org/software/coreutils
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Description-en: GNU core utilities
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> This package contains the basic file, shell and text manipulation
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> utilities which are expected to exist on every operating system.
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Specifically, this package includes:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> arch base64 basename cat chcon chgrp chmod chown chroot cksum comm cp
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> csplit cut date dd df dir dircolors dirname du echo env expand expr
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> factor false flock fmt fold groups head hostid id install join link ln
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> logname ls md5sum mkdir mkfifo mknod mktemp mv nice nl nohup nproc numfmt
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> od paste pathchk pinky pr printenv printf ptx pwd readlink realpath rm
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> rmdir runcon sha*sum seq shred sleep sort split stat stty sum sync tac
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> tail tee test timeout touch tr true truncate tsort tty uname unexpand
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> uniq unlink users vdir wc who whoami yes
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Description-md5: d0d975dec3625409d24be1238cede238
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Task: minimal
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>这个包中，通常包含如下应用程序&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>arch base64 basename cat chcon chgrp chmod chown chroot cksum comm cp csplit cut date dd df dir dircolors dirname du echo env expand expr factor false flock fmt fold groups head hostid id install join link ln logname ls md5sum mkdir mkfifo mknod mktemp mv nice nl nohup nproc numfmt od paste pathchk pinky pr printenv printf ptx pwd readlink realpath rm rmdir runcon sha*sum seq shred sleep sort split stat stty sum sync tac tail tee test timeout touch tr true truncate tsort tty uname unexpand uniq unlink users vdir wc who whoami yes
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>可以发现，这些命令就是我们日常经常使用那些~&lt;/p>
&lt;h1 id="util-linux">Util-linux&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://github.com/util-linux/util-linux">GitHub 项目，util-linux/util-linux&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Util-linux">Wiki,Util-linux&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>util-linux 是由 Linux 内核组织分发的标准软件包，用作 Linux 操作系统的一部分。一个分支 util-linux-ng（ng 的意思是“下一代”）是在开发停滞时创建的，但截至 2011 年 1 月，它已重命名为 util-linux，并且是该软件包的正式版本。&lt;/p>
&lt;p>Util-linux 包中通常包含如下程序：&lt;/p>
&lt;ul>
&lt;li>addpart&lt;/li>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Getty_(Unix)">agetty&lt;/a>&lt;/li>
&lt;li>blkdiscard&lt;/li>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Blkid">blkid&lt;/a>&lt;/li>
&lt;li>blkzone&lt;/li>
&lt;li>&lt;a href="https://en.wikipedia.org/w/index.php?title=Blockdev&amp;amp;action=edit&amp;amp;redlink=1">blockdev&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Cal_(command)">cal&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Cfdisk">cfdisk&lt;/a>&lt;/li>
&lt;li>chcpu&lt;/li>
&lt;li>chfn&lt;/li>
&lt;li>chmem&lt;/li>
&lt;li>choom&lt;/li>
&lt;li>chrt&lt;/li>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Chsh">chsh&lt;/a>&lt;/li>
&lt;li>col (legacy)&lt;/li>
&lt;li>colcrt&lt;/li>
&lt;li>colrm&lt;/li>
&lt;li>column&lt;/li>
&lt;li>ctrlaltdel&lt;/li>
&lt;li>delpart&lt;/li>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Dmesg">dmesg&lt;/a>&lt;/li>
&lt;li>eject&lt;/li>
&lt;li>fallocate&lt;/li>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Fdformat">fdformat&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Fdisk">fdisk&lt;/a>&lt;/li>
&lt;li>fincore&lt;/li>
&lt;li>findfs&lt;/li>
&lt;li>findmnt&lt;/li>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/File_locking">flock&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Fsck">fsck&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Fsck">fsck&lt;/a>.&lt;a href="https://en.wikipedia.org/wiki/Cramfs">cramfs&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Fsck">fsck&lt;/a>.&lt;a href="https://en.wikipedia.org/wiki/MINIX_file_system">minix&lt;/a>&lt;/li>
&lt;li>fsfreeze&lt;/li>
&lt;li>fstrim&lt;/li>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Getopt">getopt&lt;/a>&lt;/li>
&lt;li>hardlink&lt;/li>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Hex_dump#od_and_hexdump">hexdump&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://en.wikipedia.org/w/index.php?title=Hwclock&amp;amp;action=edit&amp;amp;redlink=1">hwclock&lt;/a> (query and set the hardware clock (RTC))&lt;/li>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Ionice">ionice&lt;/a>&lt;/li>
&lt;li>ipcmk&lt;/li>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Ipcrm">ipcrm&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Ipcs">ipcs&lt;/a>&lt;/li>
&lt;li>irqtop&lt;/li>
&lt;li>isosize&lt;/li>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Kill_(Unix)">kill&lt;/a>&lt;/li>
&lt;li>last&lt;/li>
&lt;li>ldattach&lt;/li>
&lt;li>line (legacy)&lt;/li>
&lt;li>logger&lt;/li>
&lt;li>login&lt;/li>
&lt;li>look&lt;/li>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Losetup">losetup&lt;/a>&lt;/li>
&lt;li>lsblk&lt;/li>
&lt;li>lscpu&lt;a href="https://en.wikipedia.org/wiki/Util-linux#cite_note-8">[8]&lt;/a>&lt;/li>
&lt;li>lsfd&lt;/li>
&lt;li>lsipc&lt;/li>
&lt;li>lsirq&lt;a href="https://en.wikipedia.org/wiki/Util-linux#cite_note-9">[9]&lt;/a>&lt;/li>
&lt;li>lslocks&lt;/li>
&lt;li>lslogins&lt;/li>
&lt;li>lsmem&lt;/li>
&lt;li>lsns&lt;/li>
&lt;li>mcookie&lt;/li>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Mesg">mesg&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Mkfs">mkfs&lt;/a> (legacy)&lt;/li>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Mkfs">mkfs&lt;/a>.&lt;a href="https://en.wikipedia.org/wiki/Boot_File_System">bfs&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Mkfs">mkfs&lt;/a>.&lt;a href="https://en.wikipedia.org/wiki/Cramfs">cramfs&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Mkfs">mkfs&lt;/a>.&lt;a href="https://en.wikipedia.org/wiki/MINIX_file_system">minix&lt;/a>&lt;/li>
&lt;li>mkswap&lt;/li>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/More_(command)">more&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Mount_(Unix)">mount&lt;/a>&lt;/li>
&lt;li>mountpoint&lt;/li>
&lt;li>namei&lt;/li>
&lt;li>newgrp&lt;/li>
&lt;li>nologin&lt;/li>
&lt;li>nsenter&lt;/li>
&lt;li>partx&lt;/li>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Pg_(Unix)">pg&lt;/a> (legacy)&lt;/li>
&lt;li>pivot_root&lt;/li>
&lt;li>prlimit&lt;a href="https://en.wikipedia.org/wiki/Util-linux#cite_note-10">[10]&lt;/a>&lt;/li>
&lt;li>raw&lt;/li>
&lt;li>readprofile&lt;/li>
&lt;li>rename&lt;/li>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Nice_(Unix)">renice&lt;/a>&lt;/li>
&lt;li>reset (legacy)&lt;/li>
&lt;li>resizepart&lt;/li>
&lt;li>rev&lt;/li>
&lt;li>rfkill&lt;/li>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/RTC_Alarm">rtcwake&lt;/a>&lt;/li>
&lt;li>runuser&lt;/li>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Script_(Unix)">script&lt;/a>&lt;/li>
&lt;li>scriptlive&lt;/li>
&lt;li>scriptreplay&lt;/li>
&lt;li>setarch (including architecture symlinks such as i386, linux32, linux64, x86_64, etc.)&lt;/li>
&lt;li>setpriv&lt;/li>
&lt;li>setsid&lt;/li>
&lt;li>setterm&lt;/li>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Sfdisk">sfdisk&lt;/a>&lt;/li>
&lt;li>su&lt;/li>
&lt;li>sulogin&lt;/li>
&lt;li>swaplabel&lt;/li>
&lt;li>swapoff&lt;/li>
&lt;li>swapon&lt;/li>
&lt;li>switch_root&lt;/li>
&lt;li>taskset&lt;/li>
&lt;li>tunelp (deprecated)&lt;a href="https://en.wikipedia.org/wiki/Util-linux#cite_note-11">[11]&lt;/a>&lt;/li>
&lt;li>ul&lt;/li>
&lt;li>umount&lt;/li>
&lt;li>unshare&lt;/li>
&lt;li>utmpdump&lt;/li>
&lt;li>uuidd&lt;/li>
&lt;li>uuidgen&lt;/li>
&lt;li>uuidparse&lt;/li>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Vipw">vipw&lt;/a> (including symlink to vigr)&lt;/li>
&lt;li>wall&lt;/li>
&lt;li>wdctl&lt;/li>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Whereis">whereis&lt;/a>&lt;/li>
&lt;li>wipefs&lt;/li>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Write_(Unix)">write&lt;/a>&lt;/li>
&lt;li>zramctl&lt;/li>
&lt;/ul>
&lt;h3 id="removed">Removed&lt;/h3>
&lt;p>Utilities formerly included, but removed as of 1 July 2015:&lt;/p>
&lt;ul>
&lt;li>arch&lt;a href="https://en.wikipedia.org/wiki/Util-linux#cite_note-12">[12]&lt;/a>&lt;/li>
&lt;li>chkdupexe&lt;a href="https://en.wikipedia.org/wiki/Util-linux#cite_note-13">[13]&lt;/a>&lt;/li>
&lt;li>clock&lt;a href="https://en.wikipedia.org/wiki/Util-linux#cite_note-14">[14]&lt;/a>&lt;/li>
&lt;li>cytune&lt;a href="https://en.wikipedia.org/wiki/Util-linux#cite_note-15">[15]&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Ddate">ddate&lt;/a> (removed from default build&lt;a href="https://en.wikipedia.org/wiki/Util-linux#cite_note-16">[16]&lt;/a> before being removed&lt;a href="https://en.wikipedia.org/wiki/Util-linux#cite_note-17">[17]&lt;/a> altogether)&lt;/li>
&lt;li>elvtune&lt;a href="https://en.wikipedia.org/wiki/Util-linux#cite_note-18">[18]&lt;/a>&lt;/li>
&lt;li>fastboot&lt;a href="https://en.wikipedia.org/wiki/Util-linux#cite_note-simpleinit-19">[19]&lt;/a>&lt;/li>
&lt;li>fasthalt&lt;a href="https://en.wikipedia.org/wiki/Util-linux#cite_note-simpleinit-19">[19]&lt;/a>&lt;/li>
&lt;li>halt&lt;a href="https://en.wikipedia.org/wiki/Util-linux#cite_note-simpleinit-19">[19]&lt;/a>&lt;/li>
&lt;li>initctl&lt;a href="https://en.wikipedia.org/wiki/Util-linux#cite_note-simpleinit-19">[19]&lt;/a>&lt;/li>
&lt;li>ramsize (formerly a symlink to rdev)&lt;a href="https://en.wikipedia.org/wiki/Util-linux#cite_note-rdev-20">[20]&lt;/a>&lt;/li>
&lt;li>rdev&lt;a href="https://en.wikipedia.org/wiki/Util-linux#cite_note-rdev-20">[20]&lt;/a>&lt;/li>
&lt;li>reboot&lt;a href="https://en.wikipedia.org/wiki/Util-linux#cite_note-simpleinit-19">[19]&lt;/a>&lt;/li>
&lt;li>rootflags (formerly a symlink to rdev)&lt;a href="https://en.wikipedia.org/wiki/Util-linux#cite_note-rdev-20">[20]&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Shutdown_(command)">shutdown&lt;/a>&lt;a href="https://en.wikipedia.org/wiki/Util-linux#cite_note-simpleinit-19">[19]&lt;/a>&lt;/li>
&lt;li>simpleinit&lt;a href="https://en.wikipedia.org/wiki/Util-linux#cite_note-simpleinit-19">[19]&lt;/a>&lt;/li>
&lt;li>tailf&lt;a href="https://en.wikipedia.org/wiki/Util-linux#cite_note-tailf-21">[21]&lt;/a>&lt;/li>
&lt;li>vidmode (formerly a symlink to rdev)&lt;a href="https://en.wikipedia.org/wiki/Util-linux#cite_note-rdev-20">[20]&lt;/a>&lt;/li>
&lt;/ul></description></item><item><title>Docs: Linux 管理案例</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/x.linux-%E7%AE%A1%E7%90%86/linux-%E7%AE%A1%E7%90%86%E6%A1%88%E4%BE%8B/linux-%E7%AE%A1%E7%90%86%E6%A1%88%E4%BE%8B/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/x.linux-%E7%AE%A1%E7%90%86/linux-%E7%AE%A1%E7%90%86%E6%A1%88%E4%BE%8B/linux-%E7%AE%A1%E7%90%86%E6%A1%88%E4%BE%8B/</guid><description>
&lt;h1 id="重置-linux-的-root-密码">重置 Linux 的 root 密码&lt;/h1>
&lt;h2 id="进入紧急模式">进入紧急模式&lt;/h2>
&lt;p>详见《[Linux 的紧急模式或救援模式](/docs/IT学习笔记/1.操作系统/X.Linux%20 管理/性能优化%20 与%20 故障处理/Linux%20 的紧急模式或救援模式.md 与 故障处理/Linux 的紧急模式或救援模式.md)》&lt;/p>
&lt;h2 id="修改密码">修改密码&lt;/h2>
&lt;ul>
&lt;li>切换到原系统执行：&lt;code>chroot /sysroot/&lt;/code>&lt;/li>
&lt;li>更改 root 密码：&lt;code>passwd root&lt;/code>&lt;/li>
&lt;li>在/目录下创建一个.autorelabel 文件，而有这个文件存在，系统在重启时就会对整个文件系统进行 relabeling
&lt;ul>
&lt;li>&lt;code>touch /.autorelabel&lt;/code>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;code>exit&lt;/code>&lt;/li>
&lt;li>&lt;code>reboot&lt;/code>&lt;/li>
&lt;/ul>
&lt;h1 id="修改网卡名">修改网卡名&lt;/h1>
&lt;p>centos 系统&lt;/p>
&lt;ul>
&lt;li>vi /etc/default/grub
&lt;ul>
&lt;li>GRUB_CMDLINE_LINUX=&amp;ldquo;net.ifnames=0 biosdevname=0 crashkernel=auto rd.lvm.lv=myvg/root rd.lvm.lv=myvg/swap rhgb quiet&amp;rdquo;&lt;/li>
&lt;li>注意，标红位置改为自己的 lvm 中 volume group 的名字&lt;/li>
&lt;li>主要就是添加紫色内容的字符串&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>grub2-mkconfig -o /boot/grub2/grub.cfg&lt;/li>
&lt;li>mv /etc/sysconfig/network-scripts/ifcfg-ens33 /etc/sysconfig/network-scripts/ifcfg-eth0&lt;/li>
&lt;li>sed -i &amp;ldquo;s/ens33/eth0/g&amp;rdquo; /etc/sysconfig/network-scripts/ifcfg-eth0&lt;/li>
&lt;/ul>
&lt;p>ubuntu 系统&lt;/p>
&lt;ul>
&lt;li>修改 grub 文件
&lt;ul>
&lt;li>vim /etc/default/grub&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>查找
&lt;ul>
&lt;li>GRUB_CMDLINE_LINUX=&amp;quot;&amp;quot;&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>修改为
&lt;ul>
&lt;li>GRUB_CMDLINE_LINUX=&amp;ldquo;net.ifnames=0 biosdevname=0&amp;rdquo;&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>重新生成 grub 引导配置文件
&lt;ul>
&lt;li>grub-mkconfig -o /boot/grub/grub.cfg&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>修改网络配置 ens32 为 eth0
&lt;ul>
&lt;li>vim /etc/netplan/01-netcfg.yaml&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/gvagsg/1616163849544-f4eac668-9a60-40ef-b291-c28f82e1e661.jpeg" alt="">&lt;/p></description></item><item><title>Docs: Linux 网络栈管理</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2.kernel%E5%86%85%E6%A0%B8/8.network-%E7%AE%A1%E7%90%86/linux-%E7%BD%91%E7%BB%9C%E6%A0%88%E7%AE%A1%E7%90%86/linux-%E7%BD%91%E7%BB%9C%E6%A0%88%E7%AE%A1%E7%90%86/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2.kernel%E5%86%85%E6%A0%B8/8.network-%E7%AE%A1%E7%90%86/linux-%E7%BD%91%E7%BB%9C%E6%A0%88%E7%AE%A1%E7%90%86/linux-%E7%BD%91%E7%BB%9C%E6%A0%88%E7%AE%A1%E7%90%86/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://www.kernel.org/doc/html/latest/networking/index.html">Kernel 文档-Linux Networkiing Documentation&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.kernel.org/doc/html/latest/networking/kapi.html">Kernel 文档-Linux Networking and Network Devices APIs&lt;/a>&lt;/li>
&lt;li>&lt;a href="http://arthurchiao.art/index.html">arthurchiao.art 的文章&lt;/a>
&lt;ul>
&lt;li>&lt;a href="http://arthurchiao.art/blog/tuning-stack-rx-zh/">[译] Linux 网络栈监控和调优：接收数据（2016）&lt;/a>&lt;/li>
&lt;li>&lt;a href="http://arthurchiao.art/blog/tuning-stack-tx-zh/">[译] Linux 网络栈监控和调优：发送数据（2017）&lt;/a>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>和磁盘设备类似，Linux 用户想要使用网络功能，不能通过直接操作硬件完成，而需要直接或间接的操作一个 Linux 为我们抽象出来的设备，即通用的 &lt;strong>Linux 网络设备&lt;/strong>来完成。一个常见的情况是，系统里装有一个硬件网卡，Linux 会在系统里为其生成一个网络设备实例，如 eth0，用户需要对 eth0 发出命令以配置或使用它了。更多的硬件会带来更多的设备实例，虚拟的硬件也会带来更多的设备实例。&lt;/p>
&lt;p>网卡本身并不会连接连接任何网络，网卡需要相应的配置文件来告诉他们如何实现网络连接。而让网卡与配置文件关联的过程，就是 network.service 这类服务来实现的&lt;/p>
&lt;p>在 Linux 系统中，一般使用“网络设备”这种称呼，来描述硬件物理网卡设备在系统中的实例。在不同的语境中，有时也简称为 “设备”、“DEV” 等等。网络设备可以是一块真实机器上的网卡，也可以是创建的虚拟的网卡。&lt;/p>
&lt;p>而网络设备与网卡之间如何建立关系，就是网卡驱动程序的工作了，不同的网卡，驱动不一样，可以实现的功能也各有千秋。所以，想要系统出现 eth0 这种网络设备，网卡驱动程序是必须存在的，否则，没有驱动，也就无法识别硬件，无法识别硬件，在系统中也就不知道如何操作这个硬件。&lt;/p>
&lt;h2 id="常见术语">常见术语&lt;/h2>
&lt;h3 id="datapath数据路径">DataPath(数据路径)&lt;/h3>
&lt;p>网络数据在内核中进行网络传输时，所经过的所有点组合起来，称为数据路径。&lt;/p>
&lt;h3 id="socket-buffer简称-sk_buff-或-skb">Socket Buffer(简称 sk_buff 或 skb)&lt;/h3>
&lt;p>在内核代码中是一个名为 &lt;a href="https://www.kernel.org/doc/html/latest/networking/kapi.html#c.sk_buff">&lt;strong>sk_buff&lt;/strong>&lt;/a>** **的结构体。内核显然需要一个数据结构来储存报文的信息。这就是 skb 的作用。
sk_buff 结构自身并不存储报文内容，它通过多个指针指向真正的报文内存空间:
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/efrsi8/1617849698535-471768e0-dcf8-4471-8dd2-605a1bc4e020.png" alt="image.png">
sk_buff 是一个贯穿整个协议栈层次的结构，在各层间传递时，内核只需要调整 sk_buff 中的指针位置就行。
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/efrsi8/1617849692989-54095177-b85c-449e-8c66-3b026e4925da.png" alt="image.png">&lt;/p>
&lt;h3 id="device设备">DEVICE(设备)&lt;/h3>
&lt;p>在内核代码中，是一个名为 &lt;a href="https://www.kernel.org/doc/html/latest/networking/kapi.html#c.net_device">&lt;strong>net_device&lt;/strong>&lt;/a> 的结构体。一个巨大的数据结构，描述一个网络设备的所有 属性、数据 等信息。&lt;/p>
&lt;h1 id="linux-网络功能的实现">Linux 网络功能的实现&lt;/h1>
&lt;h1 id="数据包的-transmit发送-与-receive接收-过程概览">数据包的 Transmit(发送) 与 Receive(接收) 过程概览&lt;/h1>
&lt;h2 id="receive接收-过程">Receive(接收) 过程&lt;/h2>
&lt;p>本文将拿 &lt;strong>Intel I350&lt;/strong> 网卡的 &lt;code>igb&lt;/code> 驱动作为参考，网卡的 data sheet 这里可以下 载 &lt;a href="http://www.intel.com/content/dam/www/public/us/en/documents/datasheets/ethernet-controller-i350-datasheet.pdf">PDF&lt;/a> （警告：文件很大）。
从比较高的层次看，一个数据包从被网卡接收到进入 socket 接收队列的整个过程如下：&lt;/p>
&lt;ol>
&lt;li>加载网卡驱动，初始化&lt;/li>
&lt;li>包从外部网络进入网卡&lt;/li>
&lt;li>网卡（通过 DMA）将包 copy 到内核内存中的 ring buffer&lt;/li>
&lt;li>产生硬件中断，通知系统收到了一个包&lt;/li>
&lt;li>驱动调用 NAPI，如果轮询（poll）还没开始，就开始轮询&lt;/li>
&lt;li>&lt;code>ksoftirqd&lt;/code> 进程调用 NAPI 的 &lt;code>poll&lt;/code> 函数从 ring buffer 收包（&lt;code>poll&lt;/code> 函数是网卡 驱动在初始化阶段注册的；每个 CPU 上都运行着一个 &lt;code>ksoftirqd&lt;/code> 进程，在系统启动期 间就注册了）&lt;/li>
&lt;li>ring buffer 里包对应的内存区域解除映射（unmapped）&lt;/li>
&lt;li>（通过 DMA 进入）内存的数据包以 &lt;code>skb&lt;/code> 的形式被送至更上层处理&lt;/li>
&lt;li>如果 packet steering 功能打开，或者网卡有多队列，网卡收到的包会被分发到多个 CPU&lt;/li>
&lt;li>包从队列进入协议层&lt;/li>
&lt;li>协议层处理包&lt;/li>
&lt;li>包从协议层进入相应 socket 的接收队列&lt;/li>
&lt;/ol>
&lt;p>接下来会详细介绍这个过程。&lt;/p>
&lt;h2 id="transmit发送-过程">Transmit(发送) 过程&lt;/h2>
&lt;p>本文将拿&lt;strong>Intel I350&lt;/strong>网卡的 &lt;code>igb&lt;/code> 驱动作为参考，网卡的 data sheet 这里可以下载 &lt;a href="http://www.intel.com/content/dam/www/public/us/en/documents/datasheets/ethernet-controller-i350-datasheet.pdf">PDF&lt;/a> （警告：文件很大）。
从比较高的层次看，一个数据包从用户程序到达硬件网卡的整个过程如下：&lt;/p>
&lt;ol>
&lt;li>使用&lt;strong>系统调用&lt;/strong>（如 &lt;code>sendto&lt;/code>，&lt;code>sendmsg&lt;/code> 等）写数据&lt;/li>
&lt;li>数据穿过&lt;strong>socket 子系统&lt;/strong>，进入&lt;strong>socket 协议族&lt;/strong>（protocol family）系统（在我们的例子中为 &lt;code>AF_INET&lt;/code>）&lt;/li>
&lt;li>协议族处理：数据穿过&lt;strong>协议层&lt;/strong>，这一过程（在许多情况下）会将&lt;strong>数据&lt;/strong>（data）转换成&lt;strong>数据包&lt;/strong>（packet）&lt;/li>
&lt;li>数据穿过&lt;strong>路由层&lt;/strong>，这会涉及路由缓存和 ARP 缓存的更新；如果目的 MAC 不在 ARP 缓存表中，将触发一次 ARP 广播来查找 MAC 地址&lt;/li>
&lt;li>穿过协议层，packet 到达&lt;strong>设备无关层&lt;/strong>（device agnostic layer）&lt;/li>
&lt;li>使用 XPS（如果启用）或散列函数&lt;strong>选择发送队列&lt;/strong>&lt;/li>
&lt;li>调用网卡驱动的&lt;strong>发送函数&lt;/strong>&lt;/li>
&lt;li>数据传送到网卡的 &lt;code>qdisc&lt;/code>（queue discipline，排队规则）&lt;/li>
&lt;li>qdisc 会直接&lt;strong>发送数据&lt;/strong>（如果可以），或者将其放到队列，下次触发&lt;code>**NET_TX**&lt;/code>** 类型软中断**（softirq）的时候再发送&lt;/li>
&lt;li>数据从 qdisc 传送给驱动程序&lt;/li>
&lt;li>驱动程序创建所需的&lt;strong>DMA 映射&lt;/strong>，以便网卡从 RAM 读取数据&lt;/li>
&lt;li>驱动向网卡发送信号，通知&lt;strong>数据可以发送了&lt;/strong>&lt;/li>
&lt;li>&lt;strong>网卡从 RAM 中获取数据并发送&lt;/strong>&lt;/li>
&lt;li>发送完成后，设备触发一个&lt;strong>硬中断&lt;/strong>（IRQ），表示发送完成&lt;/li>
&lt;li>&lt;strong>硬中断处理函数&lt;/strong>被唤醒执行。对许多设备来说，这会&lt;strong>触发 &lt;strong>&lt;code>**NET_RX**&lt;/code>&lt;/strong> 类型的软中断&lt;/strong>，然后 NAPI poll 循环开始收包&lt;/li>
&lt;li>poll 函数会调用驱动程序的相应函数，&lt;strong>解除 DMA 映射&lt;/strong>，释放数据&lt;/li>
&lt;/ol>
&lt;h1 id="网络栈关联文件">网络栈关联文件&lt;/h1>
&lt;p>不同的 Linux 发行版，所使用的上层网络配置程序各不相同，各种程序所读取的配置文件也各不相同。&lt;/p>
&lt;ul>
&lt;li>对于 RedHat 相关的发行版，网络配置在 /etc/sysconfig/network-scripts/ 目录中&lt;/li>
&lt;li>对于 Debian 相关的发行版，网络配置在 /etc/network/ 目录中&lt;/li>
&lt;/ul>
&lt;p>在这些目录中，其实都是通过脚本来实现的&lt;/p>
&lt;p>后来随着时代的发展，涌现出很多通用的网络管理程序，比如 Netplan、NetworkManager、systemd-networkd 等等，这样就可以让各个发行版使用相同的程序来管理网络了，减少切换发行版而需要学习对应配置的成本，并且也更利于发展。&lt;/p></description></item><item><title>Docs: LVS</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/3.%E9%9B%86%E7%BE%A4%E4%B8%8E%E5%88%86%E5%B8%83%E5%BC%8F/lvs/lvs/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/3.%E9%9B%86%E7%BE%A4%E4%B8%8E%E5%88%86%E5%B8%83%E5%BC%8F/lvs/lvs/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Linux_Virtual_Server">Wiki,LVS&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/IP_Virtual_Server">Wiki,IPVS&lt;/a>&lt;/li>
&lt;li>&lt;a href="http://www.linuxvirtualserver.org/">官网&lt;/a>&lt;/li>
&lt;li>&lt;a href="http://www.linuxvirtualserver.org/zh/">官网,中文&lt;/a>&lt;/li>
&lt;li>&lt;a href="http://www.austintek.com/LVS/LVS-HOWTO/HOWTO/">官方文档,HOWTO&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>&lt;strong>Linux Virtual Server(Linux 虚拟服务器，简称 LVC)&lt;/strong> 是一个可以实现虚拟的服务器集群功能的项目，用于实现负载均衡的软件技术。一般情况下，LVS 代之一组服务器，对于外部客户端来说，这似乎是一台服务器，所以，也称为 &lt;strong>。&lt;/strong>&lt;/p>
&lt;p>目前，LVS 项目已经被集成到 Linux 内核中，并通过 &lt;a href="docs/IT%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/3.%E9%9B%86%E7%BE%A4%E4%B8%8E%E5%88%86%E5%B8%83%E5%BC%8F/LVS/IPVS/IPVS.md">IPVS&lt;/a>模块实现。LVS 具有良好的可靠性、可扩展性和可操作性，加上其实现最优的集群服务性能所需的低廉成本， LVS 的负载均衡功能经常被用于高性能、高可用的服务器群集中。&lt;/p>
&lt;p>LVS 项目在 1998 年 5 月由&lt;a href="https://baike.baidu.com/item/%E7%AB%A0%E6%96%87%E5%B5%A9/6689425">章文嵩&lt;/a>博士成立，是中国国内最早出现的自由软件项目之一。在 linux2.2 内核时，IPVS 就已经以内核补丁的形式出现。从 2.4 版本以后 IPVS 已经成为 Linux 内核官方标准内核的一部分&lt;/p>
&lt;h2 id="名词解释">名词解释&lt;/h2>
&lt;p>调度器的称呼：scheduler，director，dispatcher，balancer&lt;/p>
&lt;ul>
&lt;li>
&lt;p>&lt;strong>Director(指挥器)&lt;/strong> # 运行 IPVS 的节点。&lt;/p>
&lt;ul>
&lt;li>&lt;strong>IPVS(IP 虚拟服务)&lt;/strong> # 实现调度功能的程序。是一个 Linux 内核模块。实际上，IPVS 就是一个 &lt;strong>Schedulers(调度器)&lt;/strong>。
&lt;ul>
&lt;li>&lt;strong>Forwarding Method(转发方法)&lt;/strong> # Forwarding Method 用来确定 Director 如何将数据包从客户端转发到 Real Servers。如果把 Director 比做路由器，其转发数据包的规则与普通路由器有所不同。
&lt;ul>
&lt;li>Forwarding Method 其实就是指 LVS 的工作模式，当前有 LVS-NAT、LVS-DR、LVS-TUN 这几种。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>ipvsadm&lt;/strong> # 为 IPVS 程序配置调度规则的用户端应用程序。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>Real Server(真实服务器，简称 RS)&lt;/strong> # 处理来自客户端请求的节点&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>Linux Virtual Server(简称 LVS)&lt;/strong> # Director 与 Real Server 共同组成 LVS 集群。这些机器一起构成虚拟服务器，对于客户端来说，它表现为一台机器。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>Client IP&lt;/strong> # CIP,客户端 IP，用户发送请求报文的 IP&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>Director IP&lt;/strong> # DIP,调度器 IP&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>Virual IP&lt;/strong> # VIP,虚拟 IP，用于提供提供虚拟服务的 IP,该 IP 存在于 Director 和 RS 上&lt;/p>
&lt;ul>
&lt;li>为什么叫虚拟的 IP，因为这个 IP 可以代表 Director，也可以代表很多 RS，把 Director 和 RS 的很多 IP 合成 一个 IP，就称为虚拟的 IP。&lt;/li>
&lt;li>为什么需要虚拟 IP 呢，这就涉及到为什么要有 LVS 了，VIP 就是集群服务的一种体现，1.Cluster 集群，LB 负载均衡，HA 高可用.note 在这篇文章中第一段就是说明了集群的作用，为了让用户不用直接找 RS，而把所有的设备当做一个整体，用户看到的只有一个 IP，而不是那么多 RS 的 IP。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>Real Server IP&lt;/strong> # RIP,调度 IP，真实服务器 IP&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h2 id="lvs-architecture架构">LVS Architecture(架构)&lt;/h2>
&lt;p>典型的 LVS 集群架构如图 所示。在 LVS 负载均衡集群架构中，尽管整个集群内部有多个物理节点在处理用户发出的请求，但是在用户看来，所有的内部应用都是透明的，用户只是在使用一个虚拟服务器提供的高性能服务，这也是 Linux 虚拟服务器项目，即 LVS 项目的主要名称来源，如下是对 LVS 集群架构中各个层次的功能描述。
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/zzd89g/1622466145377-4664be5a-f6bd-4537-94eb-72054d13d096.png" alt="">&lt;/p>
&lt;p>在基于 LVS 项目架构的服务器集群系统中，通常包含三个功能层次：&lt;/p>
&lt;ul>
&lt;li>&lt;strong>Load Balancer(负载均衡)&lt;/strong> # 是整个集群系统的前端机器，在一组服务器之间均衡来自客户端的请求，让客户端认为所有服务都来自同一个 IP。
&lt;ul>
&lt;li>Director(调度器) 就是在该层工作&lt;/li>
&lt;li>负载均衡层位于整个集群系统的最前端，由一台或者多台 Director 组成， IPVS 模块就安装在 Director Server 的系统上，而 Director Server 的主要功能类似路由器，其包含了完成 LVS 负载转发功能所设定的路由表， Director 利用这些路由表信息把用户的请求分发到 Sever Cluster 层的物理服务器(Real Server) 上。此外，为了监测各个 Real Server 服务器的健康状况，在 Director Server 上还要安装监控模块 Ldirectord，当监控到某个 Real Server 不可用时，该服务器会被从 LVS 路由表中剔除，恢复时又会重新加入。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>Server Cluster(服务器集群)&lt;/strong> # 这是一组运行实际网络服务的服务器，如 Web、邮件、FTP、DNS 和媒体服务。
&lt;ul>
&lt;li>Real Server(真实服务器) 就是在该层工作&lt;/li>
&lt;li>服务器阵列或服务器池由一组实际运行应用服务的物理机器组成，Real Server 可以是 Web 服务器、Mail 服务器、FTP 服务器、DNS 服务器以及视频服务器中的一个或者多个的组合。每个 Real Server 之间通过高速的 LAN 或分布在各地的 WAN 相连接。在实际应用中，为了减少资源浪费， Director Server 也可以同时兼任 Real Server 的角色，即在 Real Server 同时部署 IPVS 模块。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>Shared Storage(共享存储)&lt;/strong> # 为服务器提供共享的存储空间，便于提供相同的服务。
&lt;ul>
&lt;li>共享存储可以是数据库系统、网络文件系统或分布式文件系统。服务器节点需要动态更新的数据应该存储在基于数据的系统中，当服务器节点在数据库系统中并行读写数据时，数据库系统可以保证并发数据访问的一致性。静态数据通常保存在 NFS、CIFS 等网络文件系统中，以便所有服务器节点共享数据。但是，单个网络文件系统的可扩展性是有限的，例如单个 NFS/CIFS 只能支持 4 到 8 个服务器的数据访问。对于大型集群系统，分布式/集群文件系统可以用于共享存储，例如 GPFS，Coda 和 GFS，然后共享存储也可以根据系统需求进行扩展。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>通常情况下，一个 LVS 集群由两类节点组成：&lt;/p>
&lt;ul>
&lt;li>&lt;strong>Director(指挥器)&lt;/strong> # 前端接收客户端请求的节点，并将请求转发给后端 Real Server。Director 通过 IPVS 与 ipvsadm 来实现。&lt;/li>
&lt;li>**Real Server(真实服务器) **# 处理客户端请求的节点。&lt;/li>
&lt;/ul>
&lt;p>这些服务器一起组成了一个虚拟服务器，对于访问他们的客户端来说，它表现为一台机器。&lt;/p>
&lt;p>LVS 的工作模式&lt;/p>
&lt;p>LVS 的 IP 负载均衡技术是通过 IPVS 模块来实现的， IPVS 是 LVS 集群系统的核心软件，其主要安装在集群的 Director Server 上，并在 Director Server 上虚拟出一个 IP 地址，用户对服务的访问只能通过该虚拟 IP 地址实现。这个虚拟 IP 通常称为 LVS 的 VIP(Virtual IP)，用户的访问请求首先经过 VIP 到达 Director，然后由 Director 从 Real Server 列表中按照一定的负载均衡算法选取一个服务节点响应用户的请求。在这个过程中，当用户的请求到达 Director Server 后， Director Server 如何将请求转发到提供服务的 Real Server 节点，而 Real Server 节点又如何将数据返回给用户， 这是 IPVS 实现负载均衡的核心技术。&lt;/p>
&lt;p>IPVS 实现数据路由转发的机制如下几种：&lt;/p>
&lt;ol>
&lt;li>&lt;strong>NAT&lt;/strong> # 支持端口映射但是 DIP 与 RIP 必须要在同一网段&lt;/li>
&lt;li>&lt;strong>DR&lt;/strong> # 不支持端口影响且调度与 RS 必须在同一网络&lt;/li>
&lt;li>&lt;strong>TUN&lt;/strong> # 各 RS 可以放在不同的地域且都在公网上被人直接访问&lt;/li>
&lt;li>&lt;strong>FullNAT&lt;/strong> # 可以在内部构建复杂网络，比如不同 RS 可以跨机房跨网络，而且可以隐藏 RS 不被公网直接访问)&lt;/li>
&lt;/ol>
&lt;p>NAT(Network Address Translation)&lt;/p>
&lt;p>即通过网络地址转换的虚拟服务器技术。在这种负载转发方案中，当用户的请求到达调度器时，调度器自动将请求报文的目标 IP 地址（ VIP ）替换成 LVS 选中的后端 Real Server 地址，同时报文的目标端口也替换为选中的 Real Server 对应端口， 最后将报文请求发送给选中的 Real Server 进行处理。当 Real Server 处理完请求并将结果数据返回给用户时，需要再次经过负载调度器，此时调度器进行相反的地址替换操作，即将报文的源地址和源端口改成 VIP 地址和相应端口，然后把数据发送给用户，完成整个负载调度过程。可以看出，在这种方式下，用户请求和响应报文都必须经过 Director Server 进行地址转换，请求时进行目的地址转换（ Destination Network Address Translation, DNAT ），响应时进行源地址转换（ Source Network Address Translation, SNAT ）。在这种情况下，如果用户请求越来越多，调度器的处理能力就会成为集群服务快速响应的瓶颈。&lt;/p>
&lt;p>LVS-NAT(Network Address Translation)实测可调度 10 台以内的 RS&lt;/p>
&lt;p>多目标 IP 的 DNAT,通过将请求报文中的目标地址和目标端口改为某挑出的 RS 的 RIP 和 PORT 实现转发&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/zzd89g/1616132542821-5af6ee6a-a6d2-4e55-808d-cc00112912f7.jpeg" alt="">
lvs-nat 的特性&lt;/p>
&lt;ol>
&lt;li>
&lt;p>RS 应该使用私有地址&lt;/p>
&lt;/li>
&lt;li>
&lt;p>RS 的网关必须指向 DIP&lt;/p>
&lt;/li>
&lt;li>
&lt;p>RIP 和 DIP 必须在同一网段内&lt;/p>
&lt;/li>
&lt;li>
&lt;p>请求和响应的报文都得经过 Director，在高负载场景中，Director 很可能成为性能瓶颈(因为既要处理请求报文也要处理响应服方的转发,请求报文一般很小,但响应报文一般都比较大)&lt;/p>
&lt;/li>
&lt;li>
&lt;p>支持端口映射,即可修改请求报文的目标端口.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Director 必须是 Linux 系统，RS 可以是任意支持集群服务的操作系统.&lt;/p>
&lt;/li>
&lt;/ol>
&lt;p>lvs-nat 修改请求报文的目的 IP&lt;/p>
&lt;ol>
&lt;li>注意：该类型中 DIP 与 RIP 必须在同一网段且 RS 的网关为 DIP2，所以 Director 需要有两块网卡，DIP1 与 CIP 想通，DIP2 与 RS 想通。所有请求都经过调度器，包括请求报文和响应报文,调度器压力很大&lt;/li>
&lt;li>数据包到达 Director 时，做 dnat(将 VIP 改为 RIP)，然后发送给 RS。&lt;/li>
&lt;li>RS 处理完数据包返回响应给 Director，源 IP 是 RIP，目标 IP 是 CIP&lt;/li>
&lt;li>这时候 Director 收到响应包后，做 snat(将源 IP 改为 VIP)&lt;/li>
&lt;/ol>
&lt;p>DR(Direct Routing)&lt;/p>
&lt;p>即直接路由技术实现的虚拟服务器。这种技术在调度连接和管理上与 VSNAT 和 VSTUN 技术是一样的，不过它的报文转发方式与前两种均不同， VSDR 通过改写请求报文的 MAC 地址，将请求直接发送到选中的 Real Server ，而 Real Server 则将响应直接返回给客户端。因此，这种技术不仅避免了 VSNAT 中的 IP 地址转换，同时也避免了 VS TUN 中的 IP 隧道开销，所以 VSDR 是三种负载调度机制中性能最高的实现方案。但是，在这种方案下， Director Server 与 Real Sever 必须在同一物理网段上存在互联。&lt;/p>
&lt;p>LVS/DR(Direct Routing 直接路由) 实测可以调度 7、8 十台 RS&lt;/p>
&lt;p>通过为请求报文重新封装一个 MAC 首部进行转发,源 MAC 是 DIP 所在的接口的 MAC,目标 MAC 是某挑选出的 RS 的 RIP 所在接口的 MAC 地址;源 IP/PORT,以及目标 IP/PORT 均保持不变,请求报文经过 Dirctor 但响应报文不再经过 Dirctor
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/zzd89g/1616132542832-728aa1cf-07b1-47b3-8cdf-d8918c6789e6.jpeg" alt="">&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/zzd89g/1616132542795-f5e7f61e-e8c9-4b6e-bcd5-6c038fb30f7f.jpeg" alt="">&lt;/p>
&lt;h3 id="dr-类型工作流程">DR 类型工作流程&lt;/h3>
&lt;p>如上图所示：当客户端请求 VIP 时，通过互联网到达前端路由 Route1，再通过交换机到达 Dirctor 上；而 Dirctor 在收到请求报文后，通过定义在 ipvs 规则中的各 rip 去获得各 RS 的 MAC 地址，并在此报文外再封装一个 MAC 地址,源 MAC 为 Dirctor 的 DIP 端口的 MAC 而目标 MAC 改为其中被调度算法选中一个 RS 的 MAC，但该报文的目标 ip(VIP)不变，最后通过 DIP 接口发送给 RS；为了 RS 能接收 Dirctor 发来的报文，需要在各 RS 上也配置 VIP，但 RS 上的 VIP 是需要隔离前端 arp 广播的，所以需要将各 RS 上的 VIP 隐藏（RS 上的 VIP 通常配置到 lo 网卡接口的别名上，并配合修改 Linux 内核参数来实现隔离 arp 广播）；而 RS 封装响应报文时，源 IP 为 VIP，目标 ip 为 CIP，并通过 RIP 的网络接口直接向外发送响应，不再经过 Dirctor。&lt;/p>
&lt;p>需要注意的是：因为 Route1 的 A 点的 IP 和 Dirctor 的 VIP 在同一网段内，VIP 通常是公网 IP；而 DIP、RIP 通常是私有 IP，且这两个 IP 通常也应在同一物理网络内；假设 RIP 与 Route1 的 A 接口(同 Director 的 VIP DIP)在同一网段，则这时可将 RS 的网关指向 Route1，否则，Route2 只能其它路由器(如 Route2)接口访问互联网，且 Route2 的 C 点的 IP 需要与 RIP 在同一网段内，此时 RIP 响应的报文就通过 Route2 发送。&lt;/p>
&lt;ul>
&lt;li>1.RIP 与 DIP 在同一 IP 网络，RS 可以使用私有地址，也可以使用公网地址，此时可以直接通过互联网连入 RS，以实现配置、监控等&lt;/li>
&lt;li>2.RS 的网关一定不能指向 DIP&lt;/li>
&lt;li>3.RS 跟 Director 要在同一物理网络内（不能有路由器分隔,因为要将报文封装 MAC 首部进行报文转发）&lt;/li>
&lt;li>4.请求报文必须经过 Director，但响应报文不能经过 Director 而是由 RS 直接发往 Client 以释放 Directory 的压力。&lt;/li>
&lt;li>5.不支持端口映射(因为响应报文不经过 Director)&lt;/li>
&lt;li>6.RS 可以使用大多数的操作系统&lt;/li>
&lt;li>7.Director 的 VIP 对外可见，RS 的 VIP 对外不可见&lt;/li>
&lt;li>8.RS 跟 Director 都得配置使用 VIP&lt;/li>
&lt;li>9.确保前端路由器将目标 IP 为 VIP 的请求报文发往 Director(上文的设置)&lt;/li>
&lt;/ul>
&lt;p>lvs-dr(direct routing) #操纵新的 MAC 地址，直接路由，默认的 LVS 类型，通过请求报文的目标 MAC 地址进行转发，即需要 ARP 的 IP 与 MAC 映射表才能转发，由于调度器是基于二层 MAC 来调度的，所以调度器与 RS 必须要在同一个 VLAN 中
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/zzd89g/1616132542782-786ee136-62a7-4fb6-8faf-2a43c660d620.jpeg" alt="">&lt;/p>
&lt;ol>
&lt;li>如图所示，请求报文直接到调度器，然后调度器选择一台 RS，让这台 RS 来响应该请求，RS 与用户直接交互，不再经过调度器，只有请求报文经过调度器，响应报文是不经过调度器的(RS 的网关不能指定到 DIP)所以用户访问的业务 IP 都是该业务的调度器的浮动 IP，通过调度器来给用户选择一台提供服务的主机，这样调度器没有压力。&lt;/li>
&lt;li>RS 构建响应报文响应用户请求的时候，需要使用 VIP 来进行响应，因为用户请求的是 VIP，RS 只能用 VIP 来进行响应。每台 RS 都有一个 VIP，但是用户请求的 VIP 必须要到调度器上，那么这时候在 VIP 上就需要绑定 mac 地址了，以 mac 地址来区分调度器与 RS。&lt;/li>
&lt;li>所以 Director 在调度主机的时候，会把选择的 RS 的物理网卡的 MAC 地址加进请求报文中作为目的 mac 地址，然后转发给 RS。（用户依然会通过 VIP 来访问，但是数据到交换机的时候，是根据 MAC 地址来转发该数据到 RS，这样就实现了 RS 与用户的直接交互；所以当用户断开连接再次请求后，由于请求报文目的 MAC 地址没了，所以交换机会根据本身的 arp 表把，找到 mac 地址，这时候依然是 Director，则数据包到 Director 的时候需要重新配分新的 RS）&lt;/li>
&lt;li>由于 Linux 从哪网卡收的就要从哪个网卡发，为了解决响应报文中的源地址不能是 RS 的 IP 的问题，那么每台 RS 的 VIP 则不配置在物理网卡上，而是配置在这台机器 lo(loopback)接口上，给 lo 起一个别名用作 VIP，具体原因如下
&lt;ol>
&lt;li>由于路由器一般是动态学习 ARP 包的（一般动态配置 DHCP 的话），当内网的机器要发送一个到外部的 ip 包，那么它就会请求 路由器的 Mac 地址，发送一个 arp 请求，这个 arp 请求里面包括了自己的 ip 地址和 Mac 地址，而 linux 默认是使用 ip 的源 ip 地址作为 arp 里面 的源 ip 地址，而不是使用发送设备上面的 ，这样在 lvs 这样的架构下，所有 RS 发送包都是同一个 VIP 地址，那么 arp 请求就会包括 VIP 地址和设备 Mac，而路由器收到这个 arp 请求就会更新自己的 arp 缓存，这样就会造成 ip 欺骗了，VIP 被抢夺，这样调度器的 VIP 就被被 RS 抢走，这样就会出现问题，下一个数据包就无法正确发送给调度器了。所以需要给每台 RS 都要配置 arp 的通告以及响应规则以实现该功能&lt;/li>
&lt;li>&lt;strong>arp_ignore&lt;/strong> # arp 忽略，响应 arp 请求时的动作，由该项参数决定
&lt;ol>
&lt;li>参数 0：默认参数，只要收到 arp 请求，无论是哪个地址，都做出响应&lt;/li>
&lt;li>参数 1：推荐设置，只响应目的 IP 地址为接收网卡上的本地地址的 arp 请求。(如果外面有人询问 VIP，由于 VIP 在 lo 上，不在接收网卡上，所以不会响应询问 VIP 的 arp 通告。这样防止 VIP 的 arp 被抢夺)。&lt;/li>
&lt;li>参数 2：只响应目标 IP 地址是来访网络接口本地地址的 ARP 查询请求,且来访 IP 必须在该网络接口的子网段内&lt;/li>
&lt;li>参数 3：不回应该网络界面的 arp 请求，而只对设置的唯一和连接地址做出回应&lt;/li>
&lt;li>参数 4-7：保留未使用&lt;/li>
&lt;li>参数 8：不回应所有（本地地址）的 arp 查询&lt;/li>
&lt;/ol>
&lt;/li>
&lt;li>**arp_announce **# arp 宣告，通告 arp 给别人时的动作；以及是否接收 arp 通告，并记录；由该项参数决定
&lt;ol>
&lt;li>参数 0：默认参数，把本机所有网卡上的所有地址通告给网络中（不管任何情况，使用发送或者转发的数据包的源 IP 作为发送 ARP 请求的 Sender IP）(与参数 1 的区别：不管目的 IP 与本地接口的 IP 在不在同一个网段，都是用发送源 IP 作为 Sender IP）&lt;/li>
&lt;li>参数 1：尽量避免从本网络的外部接口向非本网络中的网络,通告非本网络中的接口的地址（只有当数据包的目的 IP 与本地某个接口的网段相同时，才使用发送或者转发的数据包的源 IP 作为发送 ARP 请求的 Sender IP，不属于则按参数 2 处理）
&lt;ol>
&lt;li>本网络的意思就是：比如 192.168.0.0/24 是一个网络，192.168.1.0/24 是另一个网络，0.0 网络中的地址尽量不通告给 1.0 网络中的地址，但是当需要发送数据的时候，还是需要进行通告&lt;/li>
&lt;/ol>
&lt;/li>
&lt;li>参数 2：推荐设置，在发送 arp 宣告的时候不使用数据包的源 IP，使用能与目标主机通信的最佳地址来作为发送 ARP 的 Sender IP，优先选择对外接口的主 IP；（loopback 不是对外接口）(e.g.在 RS 给 client 发送响应数据包的时候，默认情况下，会先给发送 arp 通告，询问网关在哪。由于数据包的源 IP 是 VIP，MAC 是发送数据包的物理网卡的 MAC；目的 IP 是 client 的 ip，目的 mac 未知，所以 arp 通告的源 IP 也是 VIP，那么这时候，交换机就会更新 VIP 与 MAC 的对应关系，此时产生问题，因为 VIP 应该与 director 的 MAC 绑定才对，但是现在收到的这个 arp 通告说是 VIP 应该与 RS 绑定，这明显是不应该发生的。所以在发送数据包之前的 arp 通告，不能使用 VIP，而是使用本机的物理网卡来进行 arp 通告。不过这个从 RS 发出的数据包的封包其实源 IP 还是 VIP、源 MAC 是物理网卡的 MAC，这样在 client 收到 RS 的响应包之后与 RS 交互发送数据包，目的 IP 则是 VIP，目的 MAC 则是 RS 物理网卡的 MAC，当交换机收到 client 发的包时，解开封包看到目的 mac 地址是 RS 的，则直接就把数据包交给对应的网口了，至于 IP 则是在三层路由的时候才用的，当交换机已经收到这个包时，就会把 IP 拆开直接使用 MAC 来传输数据包。而当 RS 与 client 断开连接后，client 再次主动发的数据包到交换机时，目的 MAC 是未知的，交换机就会把数据包交给 director 来进行处理，因为交换机的 arp 表里已经把 VIP 与 director 的 mac 绑定了)。arp 原理详见 ARP.note
&lt;ol>
&lt;li>三者 ARP 的通告规则区别：参数 0 是不管什么时候把所有 IP 都通告，参数 1 是不同网段需要通信的时候才通告，有死亡时间，过一段时间，该 ARP 表自动消失，参数 2 是使用最优的 IP 进行 ARP 通告，不是对外接口(比如 loopback)的永不通告&lt;/li>
&lt;/ol>
&lt;/li>
&lt;/ol>
&lt;/li>
&lt;/ol>
&lt;/li>
&lt;li>所以，为了满足 dr 类型的需要，arp_ignore 设置为 1（RS 响应 arp 通告的时候 VIP 不在接收 arp 请求这个接口上就不会响应），arp_announce 需要设置为 2(RS 在发送 arp 通告的时候不使用 VIP 作为源 IP)，该配置为内核参数配置，在/proc/sys/net/ipv4/conf/all 目录和/proc/sys/net/ipv4/conf/lo 目录下的两个文件进行配置&lt;/li>
&lt;li>再次注意：进行 RS 配置的时候，需要先修改 arp 的配置，再配置 lo 的 VIP。否则如果直接配置 VIP，则会使用 lo 的 VIP 来响应询问 VIP 在哪的 arp 通告，这时候 VIP 与 MAC 的对应关系就会一直变化，这样立刻就会发生 arp 抢夺&lt;/li>
&lt;/ol>
&lt;h2 id="tunip-tunneling">TUN(IP Tunneling)&lt;/h2>
&lt;p>即 IP 隧道技术实现的虚拟服务器。VS TUN 与 VSNAT 技术的报文转发方法不同，在 VS TUN 方式中，调度器采用 IP 隧道技术将用户请求转发到某个选中的 Real Server 上，而这个 Real Server 将直接响应用户的请求，不再经过前端调度器。此外， IP TUN 技术对 RealServer 的地域位置没有要求，其既可以与 Director Server 位于同一个网段，也可位于独立网络中。因此，在 VS TUN 方式中，调度器将只处理用户的报文请求，而无需进行转发， 故集群系统的响应速率相对而言得到极大提高。&lt;/p>
&lt;p>LVS/TUN
模型：在原请求 IP 报文之外新加一个 IP 首部(这个新添加的 IP 首部其源 IP 是 DIP,目标 IP 是 RIP),将报文发往挑选出的目标 RS.
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/zzd89g/1616132542822-64d36467-fa78-48c8-af3c-ea93ccfeea8b.jpeg" alt="">
TUN
TUN 类型工作流程(主要是为了容灾,因为 Director 与各 RS 是在不同网段中,所以可以存在于不同的物理空间)&lt;/p>
&lt;p>LVS TUN 类型特性&lt;/p>
&lt;p>1.RIP，DIP，VIP 都得是公网地址&lt;/p>
&lt;p>2.RS 的网关不会指向也不可能指向 DIP&lt;/p>
&lt;p>3.请求报文经过 Directory，但响应报文一定不经过 Director&lt;/p>
&lt;p>4.不支持端口映射&lt;/p>
&lt;p>5.RS 的 OS 必须得支持隧道功能 ??&lt;/p>
&lt;p>2.4 LVS/FULLNAT (LVS 默认不支持此类型)&lt;/p>
&lt;p>通过同时修改请求报文的源 IP 地址和目标 IP 地址进行转发&lt;/p>
&lt;p>报文件从客户端到调度器时的源 目标 IP : CIP&amp;ndash;&amp;gt;VIP&lt;/p>
&lt;p>报文从 Director 到 RS 时的源 目标 IP 分别是: DIP&amp;ndash;&amp;gt;RIP&lt;/p>
&lt;p>特点&lt;/p>
&lt;ol>
&lt;li>VIP 是公网地址,RIP 和 DIP 是私网地址,且通常不在同一 IP 网络,因此,RIP 的网关一般不会指向 DIP&lt;/li>
&lt;li>RS 收到的请求报文源地址是 DIP,因此只需响应给 DIP, 但 Dirctor 还要将其发往 Client&lt;/li>
&lt;li>请求和响应报文都经由 Dirctor&lt;/li>
&lt;li>支持端口映射.&lt;/li>
&lt;/ol>
&lt;p>lvs-tun(ip tunneling) #在原请求 IP 报文之外新加一个 IP 首部，IP 隧道技术&lt;/p>
&lt;ol>
&lt;li>不修改请求报文的 IP 首部，通过在原有的 IP 首部之外，再封装一个 IP 首部(比如为了运送一袋米，我扛着米运相当于 IP 首部，我骑着驴送，驴相当于新封装的 IP 首部)&lt;/li>
&lt;li>调度器收到请求报文时，再封装一层 IP 首部，把源 IP 至目标 IP 中的的 CIP 至 VIP 放在 DIP 至 RIP 的报文里面，DIP 至 RIP 相当于路由，所以可以不在同一网段,并且 RS 必须支持隧道技术，在解封装的时候，必须明白为什么在拆开 IP 首部之后还有一层 IP 首部&lt;/li>
&lt;li>不支持端口映射，且 RS 的网关不能指向 DIP。&lt;/li>
&lt;/ol>
&lt;p>lvs-fullnat #修改请求报文的源和目标 IP&lt;/p>
&lt;ol>
&lt;li>调度器同时修改请求报文的目标地址和源地址进行转发。把源 IP 和目标 IP 从 CIP—VIP 改成 DIP—RIP&lt;/li>
&lt;li>VIP 是公网地址，RIP 和 DIP 是私网地址，二者无须在同一网络中&lt;/li>
&lt;li>RS 接收到的请求报文的源地址为 DIP，因为要响应给 DIP&lt;/li>
&lt;li>调度器一样要承担很大压力&lt;/li>
&lt;/ol>
&lt;h2 id="note">Note&lt;/h2>
&lt;ol>
&lt;li>为什么在 Director 上除了 DIP 本身还需要一个单独的 VIP，而不可以把 DIP 当做 VIP 来用
&lt;ol>
&lt;li>如果 DIP 与 VIP 一样，那么在 Director 发送 arp 广播的时候，RS 在收到 arp 广播后，回应的报文会回给自己(因为 RS 设备上 lo 网卡上的 VIP 就是 DIP)，这样调度器上的 arp 表里就无法获得后端 RS 的 MAC 地址。如果多了一个 VIP，那么 RS 在回应 Director 的 arp 广播时，就不会回应到自己身上，因为 RS 的 lo 网卡上的 IP 为单独的 VIP，而不同于 DIP。&lt;/li>
&lt;li>结论：在调度器上，除了本身的 DIP 以外，必须要一个 VIP&lt;/li>
&lt;/ol>
&lt;/li>
&lt;li>http 本身是 stateless 无状态的，无法追踪目标来源
&lt;ol>
&lt;li>session 保持机制：会话保持机制，保证 http 协议可以在用户终端连接再次连接后还能存有之前的操作记录
&lt;ol>
&lt;li>session 绑定：将来自于同一个 client 的请求始终绑定在一个 RS 上，不会被调度到别的 RS 上&lt;/li>
&lt;li>session 集群:&lt;/li>
&lt;li>session 服务器&lt;/li>
&lt;/ol>
&lt;/li>
&lt;/ol>
&lt;/li>
&lt;/ol>
&lt;h1 id="scheduling调度-方法">Scheduling(调度) 方法&lt;/h1>
&lt;p>LVS 的调度方法分为两类(静态算法、动态算法)，共 10 种&lt;/p>
&lt;p>在转发方式选定的情况下，采用哪种调度算法将决定整个负载均衡的性能表现。不同的算法适用于不同的生产环境，有时可能需要针对特殊需求自行设计调度算法。&lt;/p>
&lt;ol>
&lt;li>静态方法：仅根据算法本身进行调度（注重起点公平）
&lt;ol>
&lt;li>RR(Round Robin) # 轮询，论调，轮流调度，第一个请求给 RS1，第二个请求给 RS2，第 n 个请求给 RSn，第 n+1 个请求给 RS1。。。。。&lt;/li>
&lt;li>WRR(Weighted RR) # 加权(Weight)轮询，能者多劳，给 RS1 一个请求，就给 RS2 几倍的请求&lt;/li>
&lt;li>SH(Source hash) # 源地址哈希，实现 session 保持的机制,来自同一个 IP 的请求将始终调度到同一个 RS&lt;/li>
&lt;li>DH(Destination Hash) # 目标地址哈希，只要请求的是同一个资源，则将请求调度到同一个 RS,比如 CDN 中所有用户都请求一个资源被调度到一台 RS 上&lt;/li>
&lt;/ol>
&lt;/li>
&lt;li>动态方法：根据算法以及各 RS 的当前负载状态进行调度 Overhead
&lt;ol>
&lt;li>LC(Least Connection) # 最小连接数，新来的请求报文调度给连接数最小的 RS
&lt;ol>
&lt;li>Overhead=Active*256+Inactive&lt;/li>
&lt;/ol>
&lt;/li>
&lt;li>WLC(Weighted LC) # 加权(Weight)最小连接数 默认的调度器类型
&lt;ol>
&lt;li>Overhead=(Active*256+Inactive)/weight&lt;/li>
&lt;/ol>
&lt;/li>
&lt;li>SED(Shortest Expection Delay) # 最短期望延迟
&lt;ol>
&lt;li>Overhead=(Active+1)*256/weight&lt;/li>
&lt;/ol>
&lt;/li>
&lt;li>NQ(Never Queue) # SED 算法的改进&lt;/li>
&lt;li>LBLC(Locality-Based LC) # 基于本地的最小连接数，动态的 DH 算法，正向代理情形下的 cache server 调度&lt;/li>
&lt;li>LBLCR(Locality-Based LC with Replication) # 带复制功能的 LBLC，相当于几台 RS(HCS)中的资源可以互相共享&lt;/li>
&lt;/ol>
&lt;/li>
&lt;/ol>
&lt;h1 id="ldirectord-技术介绍以及产生的原因">LDirectorD 技术介绍，以及产生的原因&lt;/h1>
&lt;p>IPVS 有一个缺陷，无法检查后端 Real Server 的健康状态，就是使用 HA 给 LVS 中的 Director 实现了高可用，也不一定能保证后端的各 RS 可以正常响应用户的请求，当其中一台 RS 不能使用时，访问 vip，还会去调度 down 掉的这台 RS，并返回一个错误的页面。这种情况是不合理的，所以我们需要一个 LVS 的健康检查机制，以便当 RS 无法响应时，可以及时通知给 Director，让其不再把请求调度给这台坏掉的 RS 上。为了实现这个功能，就用到了 heartbea 中的 ldirectord，ldirectord 以守护进程运行在后台，提供生成规则以及 Health check 健康检查
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/zzd89g/1616132542796-003ca683-5cd4-4f31-85ec-6b92628f2017.jpeg" alt="">
该程序依赖于自己的配置文件生成 ipvs 规则，因此，定义集群服务、添加 RS、调度方法等都在配置文件中指定，而无须手动用 ipvsadm 命令更改&lt;/p>
&lt;h2 id="配置">配置&lt;/h2>
&lt;p>/etc/ha.d/ldirectord.cf&lt;/p>
&lt;h2 id="ldirectordcf-文件说明">ldirectord.cf 文件说明&lt;/h2>
&lt;p>&lt;strong>Global Directives&lt;/strong> # 全局指令，对所有的 Virtual Services 都有效&lt;/p>
&lt;ul>
&lt;li>checktimeout=3 # 检查的超时时间，当对 RS 的健康检查时间超过 3 秒的时候的则认为该 RS 不可用&lt;/li>
&lt;li>checkinterval=1 # 检查时间间隔，即每 1 秒都对后端 RS 进行一次健康检查&lt;/li>
&lt;li>#fallback=127.0.0.1:80 #&lt;/li>
&lt;li>autoreload=yes # 该配置文件是否自动装载&lt;/li>
&lt;li>#logfile=&amp;quot;/var/log/ldirectord.log&amp;quot; # 指明日志文件的 PATH&lt;/li>
&lt;li>#logfile=&amp;ldquo;local0&amp;rdquo; #&lt;/li>
&lt;li>#emailalert=&amp;ldquo;&lt;a href="mailto:admin@x.y.z">admin@x.y.z&lt;/a>&amp;rdquo; # 警告信息发送的邮箱地址&lt;/li>
&lt;li>#emailalertfreq=3600 # 每隔多久发送一次警告信息到邮箱&lt;/li>
&lt;li>#emailalertstatus=all # 通知的 email 信息是全部&lt;/li>
&lt;li>quiescent=no # 静默工作模式&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>Sample for an XXXXX&lt;/strong> # 对于多种虚拟服务的配置样例，直接修改这一部分内容，可以实现健康检查的基本模式，其中前三行为必须要定义的 LVS 的定义以及调度规则，剩下的所有行定义的都是为 ldirectord 对后端 RS 的健康检查方式，当这些健康检查方式失败的时候，则说明该 RS 不可用&lt;/p>
&lt;ul>
&lt;li>virtual=IP:PORT # 定义 VIP 的地址和端口&lt;/li>
&lt;li>real=IP[[-&amp;gt;IP]:[PORT]] TYPE # 定义 RS 的 IP 地址和 LVS 类型，类型名介绍详见 LB 的 Packet-Forwarding-Method(LVS Type)内容，其中-&amp;gt;IP 可以实现从哪个 IP 至哪个 IP 的地址段的定义
&lt;ul>
&lt;li>gate # TYPE 为 DR 类型&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>fallback=IP:PORT TYPE # 定义当 RS 全部失效时，使用的 server 的地址，端口，LVS 类型。&lt;/li>
&lt;li>scheduler=SCHEDULER # 定义 LB 集群中的调度规则，规则类型详见 LB 中的 Director 调度方法&lt;/li>
&lt;li>service=TYPE # 定义健康检查的应用层 Protocol，注意：只有当 checktype 指定为 negotiate 的时候，该定义才有意义
&lt;ul>
&lt;li>TYPE 类型包括：ftp|http|stmp|mysql 等&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>protocol=tcp # 定义健康检查的传输层 Protocol&lt;/li>
&lt;li>checktype=negotiate # 定义健康检查的方法
&lt;ul>
&lt;li>connect # 传输层检查，向对方端口尝试发送连接请求&lt;/li>
&lt;li>negotiate # 应用层检查协商方法&lt;/li>
&lt;li>ping # 网络层检查，ICMP 协议&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>checkport=80 # 定义健康检查的端口号&lt;/li>
&lt;li>request=&amp;ldquo;index.html&amp;rdquo; # 定义健康检查请求目标 server 的哪个页面&lt;/li>
&lt;li>receive=&amp;ldquo;Test Page&amp;rdquo; # 定义健康检查中 request 中所定义的页面请求后回复的内容包含什么信息&lt;/li>
&lt;li>virtualhost=www.x.y.z # 定义健康检查虚拟主机的主机名&lt;/li>
&lt;/ul></description></item><item><title>Docs: Microsoft Management Console</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/y.windows-%E7%AE%A1%E7%90%86/microsoft_management_console/microsoft_management_console/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/y.windows-%E7%AE%A1%E7%90%86/microsoft_management_console/microsoft_management_console/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Microsoft_Management_Console">Wiki，Microsoft Management Console&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>&lt;strong>Microsoft Management Console(微软管理控制台，简称 MMC)&lt;/strong> 是 Microsoft Windows 的一个组件，它为系统管理员和高级用户提供了一个用于配置和监控系统的界面。它于 1998 年首次与 Windows NT 4.0 的 Option Pack 一起推出，后来与 Windows 2000 及其后续版本预捆绑在一起。&lt;/p>
&lt;h1 id="msc">msc&lt;/h1>
&lt;p>MSC(Microsoft Snap-In Control)文件，是&lt;a href="https://baike.baidu.com/item/%E5%BE%AE%E8%BD%AF%E7%AE%A1%E7%90%86%E6%8E%A7%E5%88%B6%E5%8F%B0/267174?fromModule=lemma_inlink">微软管理控制台&lt;/a>MMC(Microsoft Management Console)用来添加/删除的嵌入式管理单元文件。通常通过MMC来管理，可点击“文件”菜单中的“添加/删除管理单元”操作来管理当前系统中已经安装的MSC文件。可以点击开始/运行，然后输入下列文件名就可以打开相应的控制窗口。&lt;/p></description></item><item><title>Docs: Modules</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/9.%E8%BF%90%E7%BB%B4/ansible/modules/modules/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/9.%E8%BF%90%E7%BB%B4/ansible/modules/modules/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://docs.ansible.com/ansible/latest/module_plugin_guide/modules_intro.html">官方文档，使用 Ansible 模块和插件-模块介绍&lt;/a>
&lt;ul>
&lt;li>&lt;a href="https://docs.ansible.com/ansible/2.10/user_guide/modules.html">2.10 版本&lt;/a>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>&lt;strong>Modules(模块)&lt;/strong> 也被称为 &lt;strong>Task Plugins(任务插件)&lt;/strong> 或 &lt;strong>Library Plugins(插件库)&lt;/strong>，Modules 是可以从 Ansible 的命令行或 Playbook 的任务中使用的代码块。Ansible 通常在受管理节点上执行每个模块以完成任务，并收集返回值。&lt;/p>
&lt;blockquote>
&lt;p>注意：在 Ansible 2.10 及以上的版本中，大多数模块都被托管到 &lt;strong>Collections(集合)&lt;/strong> 中。&lt;/p>
&lt;/blockquote>
&lt;p>我们可以通过命令行使用模块执行任务，比如&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>ansible webservers -m service -a &lt;span style="color:#e6db74">&amp;#34;name=httpd state=started&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>ansible webservers -m ping
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>ansible webservers -m command -a &lt;span style="color:#e6db74">&amp;#34;/sbin/reboot -t now&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>也可以在 Playbooks 中使用模块执行任务，比如&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-yaml" data-lang="yaml">&lt;span style="display:flex;">&lt;span>- &lt;span style="color:#f92672">name&lt;/span>: &lt;span style="color:#ae81ff">restart webserver&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">service&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">name&lt;/span>: &lt;span style="color:#ae81ff">httpd&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">state&lt;/span>: &lt;span style="color:#ae81ff">restarted&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>等效于&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>ansible webservers -m service -a &lt;span style="color:#e6db74">&amp;#34;name=httpd state=started&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>每个模块都可以接受参数，以空格分割的 &lt;code>KEY=VALUE&lt;/code> 格式。&lt;/p>
&lt;blockquote>
&lt;p>注意：在命令行中使用模块与在 Playbooks 中使用模块时，可以传递的参数不太一样，比如 command 或 shell 模块，只需要传递需要运行的命令这个参数即可，但是在 Playbooks 中使用这两个模块，还可以传递其他参数。&lt;/p>
&lt;/blockquote>
&lt;p>所有模块执行完成后，都会有返回一个 JSON 格式的数据，这意味着可以使用任何编程语言编写模块。模块应该是幂等的，如果检测到当前状态与所需要的最终状态匹配，则应该避免再进行任何更改。&lt;/p>
&lt;p>下面我们拿一个最简单的模块举例，ansible.builtin.command 模块，当我们使用 command 模块时，可以为其传递参数，在其执行完任务之后，还会有返回值。&lt;/p>
&lt;h2 id="简单示例">简单示例&lt;/h2>
&lt;p>假如现在有这么一个 Playbooks&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-yaml" data-lang="yaml">&lt;span style="display:flex;">&lt;span>- &lt;span style="color:#f92672">name&lt;/span>: &lt;span style="color:#ae81ff">test&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">command&lt;/span>: &lt;span style="color:#ae81ff">whoami&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">register&lt;/span>: &lt;span style="color:#ae81ff">info&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>- &lt;span style="color:#f92672">name&lt;/span>: &lt;span style="color:#ae81ff">debug&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">debug&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">msg&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;{{info}}&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>这个 Playbooks 的意思就是在受管理节点上执行 &lt;code>whoami&lt;/code> 命令，并将返回值保存到 info 变量中，通过 debug 模块，将 info 变量中的内容输出出来，效果如下：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-json" data-lang="json">&lt;span style="display:flex;">&lt;span>[&lt;span style="color:#960050;background-color:#1e0010">lichenhao@hw-cloud-xngy-jump-server-linux&lt;/span>&lt;span style="color:#ae81ff">-2&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">~/projects/DesistDaydream/ehualu/ansible/playbook&lt;/span>]&lt;span style="color:#960050;background-color:#1e0010">$&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">ansible-playbook&lt;/span> &lt;span style="color:#ae81ff">90&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">-test.yaml&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#960050;background-color:#1e0010">PLAY&lt;/span> [&lt;span style="color:#960050;background-color:#1e0010">test&lt;/span>] &lt;span style="color:#960050;background-color:#1e0010">*******************************************************************************************************************************************************************&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#960050;background-color:#1e0010">TASK&lt;/span> [&lt;span style="color:#ae81ff">90&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">-test&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">:&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">test&lt;/span>] &lt;span style="color:#960050;background-color:#1e0010">*********************************************************************************************************************************************************&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#960050;background-color:#1e0010">changed:&lt;/span> [&lt;span style="color:#960050;background-color:#1e0010">hw-cloud-xngy-jump-server-linux&lt;/span>&lt;span style="color:#ae81ff">-2&lt;/span>]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#960050;background-color:#1e0010">TASK&lt;/span> [&lt;span style="color:#ae81ff">90&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">-test&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">:&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">debug&lt;/span>] &lt;span style="color:#960050;background-color:#1e0010">********************************************************************************************************************************************************&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#960050;background-color:#1e0010">ok:&lt;/span> [&lt;span style="color:#960050;background-color:#1e0010">hw-cloud-xngy-jump-server-linux&lt;/span>&lt;span style="color:#ae81ff">-2&lt;/span>] &lt;span style="color:#960050;background-color:#1e0010">=&amp;gt;&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;info&amp;#34;&lt;/span>: {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;ansible_facts&amp;#34;&lt;/span>: {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;discovered_interpreter_python&amp;#34;&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;/usr/bin/python3&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> },
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;changed&amp;#34;&lt;/span>: &lt;span style="color:#66d9ef">true&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;cmd&amp;#34;&lt;/span>: [
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#34;whoami&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ],
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;delta&amp;#34;&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;0:00:00.002447&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;end&amp;#34;&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;2021-10-09 23:05:10.491190&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;failed&amp;#34;&lt;/span>: &lt;span style="color:#66d9ef">false&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;rc&amp;#34;&lt;/span>: &lt;span style="color:#ae81ff">0&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;start&amp;#34;&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;2021-10-09 23:05:10.488743&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;stderr&amp;#34;&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;stderr_lines&amp;#34;&lt;/span>: [],
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;stdout&amp;#34;&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;root&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;stdout_lines&amp;#34;&lt;/span>: [
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#34;root&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#960050;background-color:#1e0010">PLAY&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">RECAP&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">********************************************************************************************************************************************************************&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#960050;background-color:#1e0010">hw-cloud-xngy-jump-server-linux&lt;/span>&lt;span style="color:#ae81ff">-2&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">:&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">ok=&lt;/span>&lt;span style="color:#ae81ff">2&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">changed=&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">unreachable=&lt;/span>&lt;span style="color:#ae81ff">0&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">failed=&lt;/span>&lt;span style="color:#ae81ff">0&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">skipped=&lt;/span>&lt;span style="color:#ae81ff">0&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">rescued=&lt;/span>&lt;span style="color:#ae81ff">0&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">ignored=&lt;/span>&lt;span style="color:#ae81ff">0&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>我们对比&lt;a href="https://docs.ansible.com/ansible/latest/collections/ansible/builtin/command_module.html#return-values">官方文档中 command 模块的返回值&lt;/a>，可以看到，与文档中的返回值保持一致。
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/shqrrv/1633792369531-e531b4d1-5c2b-427c-ade8-6207d5d6020b.png" alt="image.png">&lt;/p>
&lt;h2 id="总结">总结&lt;/h2>
&lt;p>所以，这也是为什么将 Moduels 称为代码的原因，&lt;strong>所谓的 Modules，本质上就是代码写出来的程序，就像 Functions&lt;/strong>，具有形参，可以接受实参，执行完成后，还会有返回值。Ansible 通过模块执行完一个任务之后，就会处理这些返回值，将其 或保存、或展示、或丢弃 等等。同时，在 Playbooks 中，还可以通过判断语句，根据返回值的内容，决定下一个任务的运行模式。&lt;/p>
&lt;p>我们可以通过 &lt;code>ansible-doc -l&lt;/code> 命令查看所有可用的模块，或者从&lt;a href="https://docs.ansible.com/ansible/latest/collections/index.html#list-of-collections">官方文档-Collections 文档&lt;/a>中查看所有模块
还可以使用&lt;code> ansible-doc MODULE&lt;/code> 命令查看指定模块的文档&lt;/p>
&lt;h1 id="模块分类">模块分类&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://docs.ansible.com/ansible/2.9/modules/modules_by_category.html">官方文档 2.9，用户指南-使用模块-模块索引&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://docs.ansible.com/ansible/latest/collections/index_module.html">官方文档 2.10+，所有模块和插件的索引-所有模块的索引&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>在 2.10 版本之前，模块的分类非常清晰；2.10 版本之后，由于模块被合并到集合中，所以很多已经分类的模块被合并到 &lt;a href="https://docs.ansible.com/ansible/latest/collections/index_module.html#ansible-builtin">builtin(内置) 模块&lt;/a>这个类别中，在这里则不再进行细致划分，非常乱。。。。&lt;/p>
&lt;p>模块的保存位置（ansible python module location）也产生了变化：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>~&lt;span style="color:#f92672">]&lt;/span>&lt;span style="color:#75715e"># ansible --version&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>ansible 2.9.6
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> config file &lt;span style="color:#f92672">=&lt;/span> /etc/ansible/ansible.cfg
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> configured module search path &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#f92672">[&lt;/span>&lt;span style="color:#e6db74">&amp;#39;/home/lichenhao/.ansible/plugins/modules&amp;#39;&lt;/span>, &lt;span style="color:#e6db74">&amp;#39;/usr/share/ansible/plugins/modules&amp;#39;&lt;/span>&lt;span style="color:#f92672">]&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ansible python module location &lt;span style="color:#f92672">=&lt;/span> /usr/lib/python3/dist-packages/ansible
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> executable location &lt;span style="color:#f92672">=&lt;/span> /usr/bin/ansible
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> python version &lt;span style="color:#f92672">=&lt;/span> 3.8.10 &lt;span style="color:#f92672">(&lt;/span>default, Jun &lt;span style="color:#ae81ff">22&lt;/span> 2022, 20:18:18&lt;span style="color:#f92672">)&lt;/span> &lt;span style="color:#f92672">[&lt;/span>GCC 9.4.0&lt;span style="color:#f92672">]&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/shqrrv/1669781692961-2dda8a1f-3eec-4687-beb3-fa3d141c1b5e.png" alt="image.png">&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>~&lt;span style="color:#f92672">]&lt;/span>&lt;span style="color:#75715e"># ansible --version&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>ansible &lt;span style="color:#f92672">[&lt;/span>core 2.13.6&lt;span style="color:#f92672">]&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> config file &lt;span style="color:#f92672">=&lt;/span> /etc/ansible/ansible.cfg
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> configured module search path &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#f92672">[&lt;/span>&lt;span style="color:#e6db74">&amp;#39;/root/.ansible/plugins/modules&amp;#39;&lt;/span>, &lt;span style="color:#e6db74">&amp;#39;/usr/share/ansible/plugins/modules&amp;#39;&lt;/span>&lt;span style="color:#f92672">]&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ansible python module location &lt;span style="color:#f92672">=&lt;/span> /root/.local/lib/python3.8/site-packages/ansible
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ansible collection location &lt;span style="color:#f92672">=&lt;/span> /root/.ansible/collections:/usr/share/ansible/collections
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> executable location &lt;span style="color:#f92672">=&lt;/span> /usr/bin/ansible
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> python version &lt;span style="color:#f92672">=&lt;/span> 3.8.10 &lt;span style="color:#f92672">(&lt;/span>default, Jun &lt;span style="color:#ae81ff">22&lt;/span> 2022, 20:18:18&lt;span style="color:#f92672">)&lt;/span> &lt;span style="color:#f92672">[&lt;/span>GCC 9.4.0&lt;span style="color:#f92672">]&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> jinja version &lt;span style="color:#f92672">=&lt;/span> 3.1.2
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> libyaml &lt;span style="color:#f92672">=&lt;/span> True
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/shqrrv/1669781684010-2cc9f6a7-cb1e-4e93-bf81-e41ef417c23c.png" alt="image.png">&lt;/p></description></item><item><title>Docs: Netfilter 流量控制系统</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2.kernel%E5%86%85%E6%A0%B8/8.network-%E7%AE%A1%E7%90%86/linux-%E7%BD%91%E7%BB%9C%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6/netfilter-%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6%E7%B3%BB%E7%BB%9F/netfilter-%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6%E7%B3%BB%E7%BB%9F/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2.kernel%E5%86%85%E6%A0%B8/8.network-%E7%AE%A1%E7%90%86/linux-%E7%BD%91%E7%BB%9C%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6/netfilter-%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6%E7%B3%BB%E7%BB%9F/netfilter-%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6%E7%B3%BB%E7%BB%9F/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://www.netfilter.org/index.html">Netfilter 官网&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.netfilter.org/documentation/index.html">Netfilter 官方文档&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Netfilter">Wiki-Netfilter&lt;/a>&lt;/li>
&lt;li>&lt;a href="http://arthurchiao.art/index.html">arthurchiao.art 的文章&lt;/a>：
&lt;ul>
&lt;li>&lt;a href="http://arthurchiao.art/blog/deep-dive-into-iptables-and-netfilter-arch-zh/">[译] 深入理解 iptables 和 netfilter 架构&lt;/a>&lt;/li>
&lt;li>&lt;a href="http://arthurchiao.art/blog/conntrack-design-and-implementation-zh/">连接跟踪（conntrack）：原理、应用及 Linux 内核实现&lt;/a>&lt;/li>
&lt;li>&lt;a href="http://arthurchiao.art/blog/nat-zh/">[译] NAT - 网络地址转换（2016）&lt;/a>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;h2 id="netfilter">Netfilter&lt;/h2>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/gral7u/1616165512374-db897dd5-0704-42f2-a1d8-441af05f247c.jpeg" alt="">&lt;/p>
&lt;p>Netfilter 是 Linux 操作系统核心层内部的一个数据包处理模块集合的统称。一种网络筛选系统，对数据包进入以及出去本机进行的一些控制与管理。该功能的所有模块可以通过下图所示的目录进行查找，其中还包括 ipvs 等。
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/gral7u/1616165512330-720231f3-a4f2-4a51-96cf-137a36724b74.jpeg" alt="">
Netfilter 项目支持如下功能&lt;/p>
&lt;ul>
&lt;li>网络地址转换(Network Address Translate)&lt;/li>
&lt;li>数据包过滤&lt;/li>
&lt;li>数据包日志记录&lt;/li>
&lt;li>用户空间数据包队列&lt;/li>
&lt;li>其他数据包处理&lt;/li>
&lt;li>等等&lt;/li>
&lt;/ul>
&lt;p>Netfilter Hooks 是 Linux 内核中的一个框架，它会让 Netfilter 的模块在 Linux 网络堆栈的不同位置注册回调函数。然后，为遍历 Linux 网络堆栈中相应 Hook 的每个数据包调用已注册的回调函数。&lt;/p>
&lt;ul>
&lt;li>用白话说：内核加入了 Netfilter 模块后，每个数据包进来之后，都会经过五个 Hooks 点来处理，以便决定每个数据包的走向。&lt;/li>
&lt;/ul>
&lt;h2 id="hooks">Hooks&lt;/h2>
&lt;p>hooks function(钩子函数) 是 Linux 网络栈中的流量检查点。所有流量通过网卡进入内核或从内核出去都会调用 Hook 函数来进行检查，并根据其规则进行过滤。Netfilter 框架中一共有 5 个 Hook，就是下文定义的“五链”。&lt;/p>
&lt;ul>
&lt;li>当一个数据包在其中一个 Hooks 中匹配到自己的规则后，则会进入下一个 Hook 寻找匹配自身的规则，直到将 5 个 Hook 挨个匹配一遍。&lt;/li>
&lt;li>可以把 Hook 想象成地铁站的闸机，通过闸机的人，就是数据流量，这个能不能从闸机过去，则看闸机对这个人身份验证的结果，是放行还是阻止&lt;/li>
&lt;/ul>
&lt;h2 id="iptabelesnftables">iptabeles/nftables&lt;/h2>
&lt;p>工作于用户空间的管理工具，对 5 个 hook 进行规则管理，iptabels 或 nftables 进程，开机后，只是把设定好的规则写进 hook 中&lt;/p>
&lt;p>Netfilter 所设置的规则是存放在内核内存中的，Iptables 是一个应用层(Ring3)的应用程序，它通过 Netfilter 放出的接口来对存放在内核内存中的 Xtables(Netfilter 的配置表)进行修改(这是一个典型的 Ring3 和 Ring0 配合的架构)&lt;/p>
&lt;h1 id="五链chain">五链(Chain)&lt;/h1>
&lt;p>把每个 Hook 上的规则都串起来类似于一条链子，所以称为链，一共 5 个 Hook，所以有 5 个 Chain。每个规则都是由“源 IP、目标 IP、端口、目标”等信息组合起来的。(i.e 对从哪来的或者到哪去的 IP 的哪个端口，要执行什么动作或‘引用什么 Chain 来对这个数据包执行什么动作’)&lt;/p>
&lt;ol>
&lt;li>&lt;strong>PREROUTING 链&lt;/strong> # 路由前，处理刚到达本机并在路由转发前的数据包。它会转换数据包中的目标 IP 地址（destination ip address），通常用于 DNAT(destination NAT)。处理完成之后分成两种情况，目的 IP 为本机网口则 INPUT，目的 IP 非本机网口则 FORWARD&lt;/li>
&lt;li>&lt;strong>INPUT 链&lt;/strong> # 进入，处理来自外部的数据。&lt;/li>
&lt;li>&lt;strong>FORWARD 链&lt;/strong> # 转发，将数据转发到本机的其他网络设备上。(需要开启 linux 的 IP 转发功能 net.ipv4.ip_forward=1 才会进入该流程；就算 ping 的是本机的其余网络设备上的 IP，也是由接收该数据包的网络设备进行回应)，FORWARD 的行为类似于路由器，系统中每个网络设备就是路由器上的每个端口，只有打开转发功能，才可以把数据包路由到其余端口上。
&lt;ol>
&lt;li>虚拟化或容器技术中，如果一台设备中有多个网段，一般都会打开转发功能，以实现不同网段路由互通的效果。&lt;/li>
&lt;li>或者服务器作为 VPN 使用时，由于不同网络设备所属网段不同，也需要打开转发功能。&lt;/li>
&lt;li>等等&lt;/li>
&lt;/ol>
&lt;/li>
&lt;li>**OUTPUT 链 **# 出去，处理向外发送的数据。&lt;/li>
&lt;li>**POSTROUTING 链 **# 路由后，处理即将离开本机的数据包。它会转换数据包中的源 IP 地址（source ip address），通常用于 SNAT（source NAT）。(该路由是通过 Linux 中定义的 route 规则发送的，与内核的 ip_forward 无关)&lt;/li>
&lt;li>**自定义链 **# 用户自己定义的链，不会调用系统 Hook，而是由系统默认的 5 个链在 target 中定义引用&lt;/li>
&lt;/ol>
&lt;h2 id="规则rule匹配match规则的匹配条件匹配的用法详见iptables-框架工具介绍">规则(Rule)匹配(Match)：(规则的匹配条件)匹配的用法详见：iptables 框架工具介绍&lt;/h2>
&lt;p>规则，需要有具体的内容才能称为规则，所以 Match 就是规则中的具体内容。&lt;/p>
&lt;p>每条链上的规则，需要对流量进行匹配后才能对该流量进行相应的处理，匹配内容包括“数据包的源地址、目标地址、协议、目标等”，(e.g.这个数据使用哪个协议从哪来的到哪去的目标是什么)
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/gral7u/1616165512349-f2e6f4c5-d617-4b04-a432-f9a7389120df.jpeg" alt="">
Match 功能的实现依赖于模块(类似于内核的模块)，比如右图，可以使用命令 rpm -ql iptables | grep &amp;ldquo;.so&amp;quot;查看都有哪些模块，其中的 XXX.so 就是各个功能的模块，大写字母是 target 所用的模块，小写字母是基本匹配与扩展匹配所用的模块&lt;/p>
&lt;ol>
&lt;li>基本匹配：源地址、目标地址、协议、入流网卡、出流网卡&lt;/li>
&lt;li>扩展匹配：用于对基本匹配的内容扩充，包括两类，普通的扩展匹配和基于
&lt;ol>
&lt;li>通用扩展匹配，可以直接使用。&lt;/li>
&lt;li>基于基本匹配的扩展匹配。需要有基本匹配规则才可以使用。
&lt;ol>
&lt;li>e.g.需要匹配某些端口，这类匹配必须基于 tcp 匹配规则上使用，否则无效(e.g.-p tcp -m tcp -m multiport &amp;ndash;dport22,23,24)&lt;/li>
&lt;/ol>
&lt;/li>
&lt;/ol>
&lt;/li>
&lt;li>目标(target)：每个规则中的目标。即在每条链上对每个进出流量匹配上之后应该执行什么动作，Target 包括以下几种
&lt;ol>
&lt;li>ACCEPT #允许流量通过&lt;/li>
&lt;li>REJECT #拒绝流量通过&lt;/li>
&lt;li>DROP #丢弃，不响应，发送方无法判断是被拒绝&lt;/li>
&lt;li>RETURN #返回调用链&lt;/li>
&lt;li>MARK #做防火墙标记&lt;/li>
&lt;li>用于 nat 表的 target
&lt;ol>
&lt;li>DNAT|SNAT #{目的|源}地址转换&lt;/li>
&lt;li>REDIRECT #端口重定向&lt;/li>
&lt;li>MASQUERADE #地址伪装类似于 SNAT，但是不用指明要转换的地址，而是自动选择要转换的地址，用于外部地址不固定的情况&lt;/li>
&lt;/ol>
&lt;/li>
&lt;li>用于 raw 表的 target
&lt;ol>
&lt;li>NOTRACK #raw 表专用的 target，用于对匹配规则进行 notrack(不跟踪)处理&lt;/li>
&lt;/ol>
&lt;/li>
&lt;li>LOG #将数据包的相关信息记录日志，执行完该目标后，会继续匹配后面的规则&lt;/li>
&lt;li>引用自定义链 #直接使用“-j 自定义链的名称”即可，让基本 5 个 Chain 上匹配成功的数据包继续执行自定义链上的规则。&lt;/li>
&lt;/ol>
&lt;/li>
&lt;/ol>
&lt;p>注意，这里面的路由指数据包在 Linux 本机内部路由&lt;/p>
&lt;h2 id="linux-数据包路由原理iptablesnetfilter-入门学习">Linux 数据包路由原理、Iptables/netfilter 入门学习&lt;/h2>
&lt;p>数据流处理流程简介&lt;/p>
&lt;p>注意：每个数据包在 CHAIN 中匹配到适用于自己的规则之后，则直接进入下一个 CHAIN，而不会遍历 CHAIN 中每条规则去挨个匹配适用于自己的规则。比如下面两种情况&lt;/p>
&lt;p>INPUT 链默认 DROP，匹配第一条：目的端口是 9090 的数据 DROP，然后不再检查下一项，那么 9090 无法访问&lt;/p>
&lt;pre>&lt;code>-P INPUT DROP
-A INPUT -p tcp -m tcp --dport 9090 -j DROP
-A INPUT -p tcp -m tcp --dport 9090 -j ACCEPT
&lt;/code>&lt;/pre>
&lt;p>INPUT 链默认 DROP，匹配第一条目的端口是 9090 的数据 ACCEPT，然后不再检查下一条规则，则 9090 可以访问&lt;/p>
&lt;pre>&lt;code>-P INPUT DROP
-A INPUT -p tcp -m tcp --dport 9090 -j ACCEPT
-A INPUT -p tcp -m tcp --dport 9090 -j DROP
&lt;/code>&lt;/pre>
&lt;p>匹配条件：根据协议报文特征指定&lt;/p>
&lt;ol>
&lt;li>基本匹配条件&lt;/li>
&lt;li>扩展匹配条件&lt;/li>
&lt;/ol>
&lt;p>处理动作：&lt;/p>
&lt;ol>
&lt;li>内建处理机制&lt;/li>
&lt;li>自定义处理机制&lt;/li>
&lt;li>注意：自定义的链不会有流量经过，而是在主要的 5 链中引用自定义链上的规则，来实现对流量的处理&lt;/li>
&lt;/ol>
&lt;p>下图是从服务器外部进入网卡，再进入网络栈的数据流走向，如果直接是服务器内部服务生成的数据包进入网络栈，则不适用于该图
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/gral7u/1616165512341-aeeeff06-b602-4340-bc4f-cd582144f85f.jpeg" alt="">&lt;/p>
&lt;ol>
&lt;li>当一个数据包进入网卡时，数据包首先进入 PREROUTING 链，在 PREROUTING 链中我们有机会修改数据包的 DestIP(目的 IP)，然后内核的&amp;quot;路由模块&amp;quot;根据&amp;quot;数据包目的 IP&amp;quot;以及&amp;quot;内核中的路由表&amp;quot;判断是否需要转送出去(注意，这个时候数据包的 DestIP 有可能已经被我们修改过了)&lt;/li>
&lt;li>如果数据包就是进入本机的(即数据包的目的 IP 是本机的网口 IP)，数据包就会沿着图向下移动，到达 INPUT 链。数据包到达 INPUT 链后，任何进程都会收到它&lt;/li>
&lt;li>本机上运行的程序也可以发送数据包，这些数据包经过 OUTPUT 链，然后到达 POSTROTING 链输出(注意，这个时候数据包的 SrcIP 有可能已经被我们修改过了)&lt;/li>
&lt;li>如果数据包是要转发出去的(即目的 IP 地址不再当前子网中)，且内核允许转发，数据包就会向右移动，经过 FORWARD 链，然后到达 POSTROUTING 链输出(选择对应子网的网口发送出去)&lt;/li>
&lt;/ol>
&lt;p>出于安全考虑，Linux 系统默认是禁止数据包转发的。所谓转发即当主机拥有多于一块的网卡时，其中一块收到数据包，根据数据包的目的 ip 地址将包发往本机另一网卡，该网卡根据路由表继续发送数据包。这通常就是路由器所要实现的功能。&lt;/p>
&lt;p>配置 Linux 系统的 ip 转发功能，首先保证硬件连通，然后打开系统的转发功能，less /proc/sys/net/ipv4/ip_forward，该文件内容为 0，表示禁止数据包转发，1 表示允许，将其修改为 1。可使用命令 echo &amp;ldquo;1&amp;rdquo; &amp;gt; /proc/sys/net/ipv4/ip_forward 修改文件内容，重启网络服务或主机后效果不再。若要其自动执行，可将命令 echo &amp;ldquo;1&amp;rdquo; &amp;gt; /proc/sys/net/ipv4/ip_forward 写入脚本/etc/rc.d/rc.local 或者 在/etc/sysconfig/network 脚本中添加 FORWARD_IPV4=&amp;ldquo;YES&amp;rdquo;&lt;/p>
&lt;h1 id="natnetwork-address-translation网络地址转换">NAT(Network Address Translation)网络地址转换&lt;/h1>
&lt;p>NAT 为了安全性而产生的，主要用来隐藏本地主机的 IP 地址&lt;/p>
&lt;h2 id="snatsource-源地址转换针对请求报文的源地址而言">SNAT：Source 源地址转换，针对请求报文的源地址而言&lt;/h2>
&lt;p>当想访问外网的时候，把源地址转换，作用于 POSTROUTING 链&lt;/p>
&lt;p>常用于内网私网地址转换成公网地址，比如家用路由器&lt;/p>
&lt;h2 id="dnatdestination-目的地址转换针对请求报文的目标地址而言">DNAT：Destination 目的地址转换，针对请求报文的目标地址而言&lt;/h2>
&lt;p>当从外部访问某 IP 时，把目的 IP 转换，作用于 PREROUTING、FORWARD 链&lt;/p>
&lt;p>把内网中的服务器发布到外网中去，&lt;/p>
&lt;p>常用于公网访问一个公司的公网 IP，但是由私网 IP 来提供服务，比如 LVS 的 nat 模型&lt;/p>
&lt;p>比如在公司内网中提供一个 web 服务，但是由于是私网地址，来自互联网的任何请求无法送达这台 web 服务器，这时候我们可以对外宣称公司的 web 服务在一个公网的 IP 地址上，但是公网的 IP 地址所在服务器上又没有提供 web 服务，这时候，来自外网访问的请求，全部 DNAT 成私网 IP，即可对外提供请求。&lt;/p>
&lt;h2 id="注意">注意：&lt;/h2>
&lt;p>由于 SNAT 与 DNAT 在描述的时候主要是都是针对请求报文而言的，那么当地址转换以后，响应报文响应的是转换后的地址，这时候就无法把响应请求送还给发起请求的设备了，这怎么办呢？这时候，同样需要一个地址转换，只不过通过 NAT 机制自行完成的，如何自动完成呢？这里面会有一个连接追踪机制，跟踪每一个数据连接（详见：&lt;a href="https://www.yuque.com/go/doc/33221811">ConnTrack 连接跟踪机制&lt;/a>），当响应报文到来的时候，根据连接追踪表中的信息记录的请求报文是怎么转换的相关信息，来对响应报文进行 NAT 转换。&lt;/p></description></item><item><title>Docs: NetworkManager</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2.kernel%E5%86%85%E6%A0%B8/8.network-%E7%AE%A1%E7%90%86/linux-%E7%BD%91%E7%BB%9C%E6%A0%88%E7%AE%A1%E7%90%86/networkmanager/networkmanager/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2.kernel%E5%86%85%E6%A0%B8/8.network-%E7%AE%A1%E7%90%86/linux-%E7%BD%91%E7%BB%9C%E6%A0%88%E7%AE%A1%E7%90%86/networkmanager/networkmanager/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://github.com/NetworkManager/NetworkManager">GitHub 项目，NetworkManager/NetworkManager&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://gitlab.freedesktop.org/NetworkManager/NetworkManager">GitLab 项目，freedesktop-NetworkManager/NetworkManager&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://networkmanager.dev/docs/api/latest/NetworkManager.conf.html">Manual(手册),NetworkManager.conf(5)&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://networkmanager.dev/">官网&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>&lt;strong>NetworkManager daemon&lt;/strong> 是管理网络的守护进程。该守护进程尝试通过管理主网络连接和其他网络接口（如以太网，WiFi 和移动宽带设备），使网络配置和操作尽可能轻松自动。 除非禁用该行为，否则 NetworkManager 将在该设备的连接可用时连接任何网络设备。 有关网络的信息通过 D-Bus 接口导出到任何感兴趣的应用程序，提供丰富的 API，用于检查和控制网络设置和操作。&lt;/p>
&lt;h1 id="connection">Connection&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://networkmanager.dev/docs/api/latest/nm-settings-nmcli.html">Manual(手册),nm-settings-nmcli(5)&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://networkmanager.dev/docs/api/latest/nm-settings-dbus.html">Manual(手册),nm-settings-dbus(5)&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://networkmanager.dev/docs/api/latest/nm-settings-keyfile.html">Manual(手册),nm-settings-keyfile(5)&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://networkmanager.dev/docs/api/latest/nm-settings-ifcfg-rh.html">Manual(手册),nm-settings-ifcfg-rh(5)&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>NetworkManager 将所有网络配置抽象成 &lt;strong>Connection(连接)&lt;/strong>，这些 Connection 的配置中包含网络配置(比如 IP 地址、网关等)。当 NetworkManager 激活网络设备上的 Connection 时，将为这个网络设备应用配置文件中的内容，并建立活动的网络连接。所以，可以创建多个 Connection 来关联到一个网络设备上；这样，它们就可以灵活地具有用于不同网络需求的各种网络配置。&lt;/p>
&lt;p>&lt;strong>用白话说就是：Connection 就是“网络配置”，网络设备(device)关联并使用“网络配置”来实现联网。而 NetworkManager 就是管理这些 Connection 的。Connection 可以表示一个概念，也可以表示一个配置文件。&lt;/strong>&lt;/p>
&lt;h2 id="connection-插件">Connection 插件&lt;/h2>
&lt;p>NetworkManager 通过 &lt;strong>Plugins(插件)&lt;/strong> 的方式来管理 Connection 配置文件。在不同的 Linux 发行版中，所使用的插件各不相同，但是默认情况下，NetworkManager 使始终启用名为 &lt;strong>keyfile&lt;/strong> 的插件，这是一个通用插件，当其他插件无法支持某些类型的 Connection 配置时，keyfile 插件将会自动提供支持。keyfile 插件会将 Connection 文件保存到 /etc/NetworkManager/system-connections/、/usr/lib/NetworkManager/system-connections/、/run/NetworkManager/system-connections/ 这三个目录中。&lt;/p>
&lt;p>可以在 /etc/NetworkManager/NetworkManager.conf 文件中配置想要使用的插件，插件用于读写系统范围的连接配置文件。当指定多个插件时，将从所有列出的插件中读取 Connections。写入 Connections 时，会要求插件按照此处列出的顺序保存连接；如果第一个插件无法写出该连接类型（或无法写出任何连接），则尝试下一个插件。如果没有插件可以保存连接，则会向用户返回错误。&lt;/p>
&lt;p>可用插件的数量是特定于发行版的。所有可用的插件详见 &lt;a href="https://networkmanager.dev/docs/api/latest/NetworkManager.conf.html#settings-plugins">Manual(手册) 中 Plugins 章节&lt;/a>&lt;/p>
&lt;p>&lt;strong>keyfile&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>keyfile 插件是支持 NetworkManager 拥有的所有连接类型和功能的&lt;strong>通用插件&lt;/strong>。它以 .ini 格式在 /etc/NetworkManager/system-connections 文件中写入连接配置。
&lt;ul>
&lt;li>有关文件格式的详细信息，请参阅 nm-settings-keyfile(5)。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>keyfile 插件存储的连接文件可能包含纯文本形式的 passwords、secrets、private keys，因此它将仅对 root 用户可读，并且插件将忽略除 root 用户或组之外的任何用户或组可读或可写的文件。
&lt;ul>
&lt;li>有关如何避免以纯文本形式存储密码，请参阅 nm-settings(5) 中的“秘密标志类型”。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>此插件始终处于活动状态，并将自动用于存储其他插件不支持的连接。&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>ifcfg-rh&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>此插件用于 Fedora 和 Red Hat Enterprise Linux 发行版，用于从标准 /etc/sysconfig/network-scripts/ifcfg-* 文件读取和写入配置。它目前支持读取 Ethernet, Wi-Fi, InfiniBand, VLAN, Bond, Bridge, Team 这几种类型的连接。启用 ifcfg-rh 隐式启用 ibft 插件(如果可用)。这可以通过添加 no-ibft 来禁用。&lt;/li>
&lt;li>有关 ifcfg 文件格式的更多信息，请参见 /usr/share/doc/initscripts/sysconfig.txt 和 nm-settings-ifcfg-rh(5)。&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>ifupdown&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>This plugin is used on the Debian and Ubuntu distributions, and reads Ethernet and Wi-Fi connections from /etc/network/interfaces.&lt;/li>
&lt;li>This plugin is read-only; any connections (of any type) added from within NetworkManager when you are using this plugin will be saved using the keyfile plugin instead.&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>ibft, no-ibft&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>These plugins are deprecated and their selection has no effect. This is now handled by nm-initrd-generator.&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>ifcfg-suse, ifnet&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>These plugins are deprecated and their selection has no effect. The keyfile plugin should be used instead.&lt;/li>
&lt;/ul>
&lt;h2 id="connection-d-bus">Connection D-Bus&lt;/h2>
&lt;p>NetworkManager 还会将这些 Connection 配置导出到 D-Bus 上，比如，通过 &lt;strong>busctl&lt;/strong> 命令，可也获取 Connection 中的内容：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">[&lt;/span>root@ansible dispatcher.d&lt;span style="color:#f92672">]&lt;/span>&lt;span style="color:#75715e"># busctl get-property org.freedesktop.NetworkManager /org/freedesktop/NetworkManager/Devices/2 org.freedesktop.NetworkManager.Device Interface&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>s &lt;span style="color:#e6db74">&amp;#34;ens33&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>所以，真正的底层实现，是通过 D-bus 中的网络设备配置文件来实现的&lt;/p>
&lt;h2 id="connection-关联文件">Connection 关联文件&lt;/h2>
&lt;p>默认情况下，由 &lt;strong>keyfile 插件&lt;/strong>管理 &lt;strong>INI 格式&lt;/strong>的 Connection 配置文件。并默认保存在 /etc/NetworkManager/system-connections/ 目录中。&lt;/p>
&lt;blockquote>
&lt;p>注意：&lt;/p>
&lt;ul>
&lt;li>在 RedHad 相关的发行版中，NetworkManager 会运行名为 ifcfg-rh 的插件，插件会将 /etc/NetworkManager/system-connections/ 目录中的 Connection 配置文件翻译成老式配置文件格式，并保存在 /etc/sysconfig/network-scripts/ 目录中&lt;/li>
&lt;li>&lt;strong>所以，在 RedHad 中，是无法从 /etc/NetworkManager/system-connections/ 目录中找到连接配置文件&lt;/strong>&lt;/li>
&lt;li>若想禁用 ifcfg-rh 插件，只需要在 /etc/NetworkManager/NetworkManager.conf 文件中的 main 部分添加 plugins=keyfile 即可&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>在 D-Bus API 上的 Connection 配置中，将 INI 中的 &lt;strong>Sections(部分) 称为 Settings(设置)&lt;/strong>，Setting 即是 &lt;strong>Properties(属性)&lt;/strong> 的集合。所以，很多文档，都将 Connection 表示为一组特定的、封装好的、独立的 &lt;strong>Settings(集合)&lt;/strong> 集合。Connection 由一个或多个 Settings 组成。&lt;/p>
&lt;p>&lt;strong>Settings&lt;/strong>用于描述一个 Connection。每个 Setting 都具有一个或多个 &lt;code>**Property(属性)**&lt;/code> 。Setting 与 Property 中间以点 &lt;code>.&lt;/code> 连接。每个 Setting.Property 都会有一个值。&lt;/p>
&lt;p>一个 Connection 有哪些 Settings，Setting 又有哪些 Property，以及这些 Property 都有什么作用，详见&lt;a href="https://www.yuque.com/go/doc/33221861">Connection 配置文件详解&lt;/a>&lt;/p>
&lt;p>下面的命令，可以从 D-Bus API 中获取配置文件所在路径&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># CentOS 中使用 ifcfg-rh 插件&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>~&lt;span style="color:#f92672">]&lt;/span>&lt;span style="color:#75715e"># busctl get-property org.freedesktop.NetworkManager /org/freedesktop/NetworkManager/Settings/4 org.freedesktop.NetworkManager.Settings.Connection Filename&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>s &lt;span style="color:#e6db74">&amp;#34;/etc/sysconfig/network-scripts/ifcfg-enp25s0f3&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># CentOS 中不使用 ifcfg-rh 插件&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>~&lt;span style="color:#f92672">]&lt;/span>&lt;span style="color:#75715e"># busctl get-property org.freedesktop.NetworkManager /org/freedesktop/NetworkManager/Settings/4 org.freedesktop.NetworkManager.Settings.Connection Filename&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>s &lt;span style="color:#e6db74">&amp;#34;/etc/NetworkManager/system-connections/eth1&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>可以看到，使用不同的插件，配置文件所在路径是不同的&lt;/p>
&lt;p>&lt;strong>用白话说：如果说 Connection 是一个配置文件的话，Setting 就是配置文件中的 &lt;code>context(配置段，或称为&amp;quot;配置环境&amp;quot;)&lt;/code>，&lt;code>Property(属性)&lt;/code> 是该配置环境下的 &lt;code>keyword(关键字,或称为&amp;quot;键&amp;quot;、&amp;quot;字段&amp;quot;)&lt;/code>&lt;/strong>。所以，一般情况下，Connection 也可以描述为由一个或多个 Property(属性) 组成。我们都把 Setting.Property 简称为 属性。&lt;strong>其实 Setting 就是很多产品的配置文件中的 Context&lt;/strong>。&lt;/p>
&lt;h3 id="配置文件示例">配置文件示例&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>~&lt;span style="color:#f92672">]&lt;/span>&lt;span style="color:#75715e"># cat /etc/NetworkManager/system-connections/ens3.nmconnection&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">[&lt;/span>connection&lt;span style="color:#f92672">]&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>id&lt;span style="color:#f92672">=&lt;/span>ens3
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>uuid&lt;span style="color:#f92672">=&lt;/span>8f8541bc-4893-418b-98d4-fbc7433747cf
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>type&lt;span style="color:#f92672">=&lt;/span>ethernet
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>interface-name&lt;span style="color:#f92672">=&lt;/span>ens3
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>permissions&lt;span style="color:#f92672">=&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">[&lt;/span>ethernet&lt;span style="color:#f92672">]&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>mac-address-blacklist&lt;span style="color:#f92672">=&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">[&lt;/span>ipv4&lt;span style="color:#f92672">]&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>address1&lt;span style="color:#f92672">=&lt;/span>172.19.42.248/24,172.19.42.1
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>dns-search&lt;span style="color:#f92672">=&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>method&lt;span style="color:#f92672">=&lt;/span>manual
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">[&lt;/span>ipv6&lt;span style="color:#f92672">]&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>addr-gen-mode&lt;span style="color:#f92672">=&lt;/span>stable-privacy
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>dns-search&lt;span style="color:#f92672">=&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>method&lt;span style="color:#f92672">=&lt;/span>auto
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">[&lt;/span>proxy&lt;span style="color:#f92672">]&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>如果通过 nmcli 命令查看这个 Connection，格式如下：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>~&lt;span style="color:#f92672">]&lt;/span>&lt;span style="color:#75715e"># nmcli connection show eth0&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>connection.id: ens3
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>connection.uuid: 8f8541bc-4893-418b-98d4-fbc7433747cf
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>connection.type: 802-3-ethernet
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>connection.interface-name: eth0
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>.........
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>ipv4.method: manual
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>ipv4.dns: 223.5.5.5
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>ipv4.addresses: 172.19.42.248/24
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>ipv4.gateway: 172.19.42.1
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>.......
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>第一列中的 connection 与 ipv4 就是 Setting。其中 id、uuid、type、interface-name 都是 connection 这个 Setting 的 Property，而 method、dns 等等都是 ipv4 这个 Setting 的 Property。第二列就是同一行 Property 对应的值。&lt;/p>
&lt;h2 id="networkmanager-api">NetworkManager API&lt;/h2>
&lt;p>NetworkManager 提供了一个 API，用来管理 Connection、检查网络配置等。&lt;a href="https://www.yuque.com/go/doc/33221856">nmcli 这个命令行工具&lt;/a>是官方提供的用于使用 API 的客户端应用程序。&lt;/p>
&lt;blockquote>
&lt;p>也可以手动管理 Connection 文件，就跟出现 NetworkManager 之前一样，手动配置 /etc/sysconfig/network-scripts 目录下的网络设备配置文件，然后重启 deamon 进程以便加载这些文件即可。&lt;/p>
&lt;/blockquote>
&lt;p>注意：&lt;/p>
&lt;ol>
&lt;li>一个网络设备(device)可以关联多个 connection，但是同一时间只能有一个与该网络设备(device)关联 connection 处于 active 状态。这就可以让一个网卡(device)同时具备多个配置，可以随时切换。&lt;/li>
&lt;li>NetworkManager 默认不会识别到配置文件的更改 并会继续使用旧的配置数据。如果更改 /etc/NetworkManager/system-connections/ 目录下的配置文件，那么需要让 NetworkManager 再次读取已经改动过的配置文件，如果想要确保这件事，需要执行如下几条命令
&lt;ol>
&lt;li>nmcli connection reload # 让 Connection 重新加载以读取配置文件&lt;/li>
&lt;li>nmcli connection up ConnectionName # 再次启动指定的 Connection，这里的 up 也有 restart 的意思&lt;/li>
&lt;/ol>
&lt;/li>
&lt;/ol>
&lt;h1 id="networkmanager-关联文件">NetworkManager 关联文件&lt;/h1>
&lt;p>&lt;strong>/etc/NetworkManager/*&lt;/strong> #&lt;/p>
&lt;ul>
&lt;li>&lt;strong>./conf.d/*&lt;/strong> # 类似 include 功能，是 NetworkManager.conf 文件的内容片段。&lt;/li>
&lt;li>&lt;strong>./NetworkManager.conf&lt;/strong> # NetworkManager 程序的运行时配置文件&lt;/li>
&lt;li>&lt;strong>./system-connections/*&lt;/strong> # 每个 Connection 的配置文件保存路径。
&lt;ul>
&lt;li>在 RedHad 中，该路径被修改到 /etc/sysconfig/network-scripts/ 上去了。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>/run/NetworkManager/*&lt;/strong> #&lt;/p>
&lt;ul>
&lt;li>&lt;strong>./system-connections/*&lt;/strong> # 自动生成的 Connection 的配置文件保存路径。&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>/usr/lib/NetworkManager/*&lt;/strong> #&lt;/p>
&lt;ul>
&lt;li>&lt;strong>./system-connections/*&lt;/strong> #&lt;/li>
&lt;/ul>
&lt;h1 id="常见问题">常见问题&lt;/h1>
&lt;h2 id="lacp-在-networkmanager-管理的-bonding-不工作">LACP 在 NetworkManager 管理的 Bonding 不工作&lt;/h2>
&lt;p>&lt;a href="https://github.com/systemd/systemd/issues/15208">https://github.com/systemd/systemd/issues/15208&lt;/a>&lt;/p>
&lt;p>当 systemd 版本在 242、243、245 时，NetworkManager 对于 802.3ad 模式的 Bonding 在发送 LACP 包是可能会产生异常&lt;/p>
&lt;p>如果通过 NetworkManager 创建的 Bond 网络设备失效，有如下几种可用的解决方式：&lt;/p>
&lt;ul>
&lt;li>通过 ip 命令先删除网络设备，再通过 ip 命令添加即可。
&lt;ul>
&lt;li>ip link set bond1 down&lt;/li>
&lt;li>ip link del bond1&lt;/li>
&lt;li>ip link add bond1 type bond mod 802.3ad&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul></description></item><item><title>Docs: Percona</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/5.%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8/%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/percona/percona/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/5.%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8/%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/percona/percona/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://github.com/percona">GitHub 组织，Percona&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.percona.com/">官网&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Percona">Wiki，Percona&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>&lt;strong>Percona是一家位于&lt;/strong>&lt;a href="https://en.wikipedia.org/wiki/Durham,_North_Carolina">北卡罗来纳州达勒姆&lt;/a>的美国公司，为 &lt;a href="https://en.wikipedia.org/wiki/MySQL">MySQL&lt;/a>、&lt;a href="https://en.wikipedia.org/wiki/MariaDB">MariaDB&lt;/a>、&lt;a href="https://en.wikipedia.org/wiki/PostgreSQL">PostgreSQL&lt;/a>、&lt;a href="https://en.wikipedia.org/wiki/MongoDB">MongoDB&lt;/a> 和 &lt;a href="https://en.wikipedia.org/wiki/RocksDB">RocksDB&lt;/a>用户开发了许多开源软件项目。该公司每年约 2500 万美元的收入来自数据库系统的支持、咨询和托管服务。&lt;/p>
&lt;p>该公司由 Peter Zaitsev 和 Vadim Tkachenko 于 2006 年创立。&lt;/p>
&lt;ul>
&lt;li>Percona Monitoring and Management # 用于管理和监控 MySQL、PostgreSQL、MongoDB 和 ProxySQL 性能的开源平台&lt;/li>
&lt;li>Percona XtraDB cluster # 用于 MySQL 集群和高可用性的高扩展性解决方案
&lt;ul>
&lt;li>&lt;a href="https://github.com/percona/percona-xtradb-cluster">https://github.com/percona/percona-xtradb-cluster&lt;/a>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul></description></item><item><title>Docs: Percona XtraDB Cluster</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/5.%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8/%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/percona/percona-xtradb-cluster/percona-xtradb-cluster/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/5.%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8/%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/percona/percona-xtradb-cluster/percona-xtradb-cluster/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://github.com/percona/percona-xtradb-cluster">GitHub 项目，percona/percona-xtradb-cluster&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.percona.com/software/mysql-database/percona-xtradb-cluster">官网&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;h1 id="部署-pxc">部署 PXC&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://docs.percona.com/percona-xtradb-cluster/latest/install/index.html">官方文档，安装 PXC 集群&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;h3 id="使用-docker-部署">使用 Docker 部署&lt;/h3>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://docs.percona.com/percona-xtradb-cluster/8.0/install/docker.html#docker">Running Percona XtraDB Cluster in a Docker Container - Percona XtraDB Cluster&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;h3 id="使用-pxc-operator-在-kubernetes-中部署">使用 PXC Operator 在 Kubernetes 中部署&lt;/h3>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://docs.percona.com/percona-operator-for-mysql/pxc/kubectl.html">官方文档，快速开始指南-使用 kubectl 安装 PXC Operator&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://docs.percona.com/percona-operator-for-mysql/pxc/kubernetes.html">官方文档，高级安装指南-通用 Kubernetes 安装&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;h3 id="快速体验">快速体验&lt;/h3>
&lt;p>部署 Operator&lt;/p>
&lt;p>kubectl apply -f &lt;a href="https://raw.githubusercontent.com/percona/percona-xtradb-cluster-operator/v1.12.0/deploy/bundle.yaml">https://raw.githubusercontent.com/percona/percona-xtradb-cluster-operator/v1.12.0/deploy/bundle.yaml&lt;/a>&lt;/p>
&lt;p>部署 PXC&lt;/p>
&lt;p>kubectl apply -f &lt;a href="https://raw.githubusercontent.com/percona/percona-xtradb-cluster-operator/v1.12.0/deploy/cr.yaml">https://raw.githubusercontent.com/percona/percona-xtradb-cluster-operator/v1.12.0/deploy/cr.yaml&lt;/a>&lt;/p>
&lt;h3 id="高级安装">高级安装&lt;/h3>
&lt;p>创建名称空间&lt;/p>
&lt;p>kubectl create namespace pxc&lt;/p>
&lt;p>kubectl apply -f crd.yaml&lt;/p>
&lt;p>kubectl apply -n pxc -f rbac.yaml&lt;/p>
&lt;p>kubectl apply -n pxc -f operator.yaml&lt;/p>
&lt;p>kubectl apply -n pxc -f secrets.yaml&lt;/p>
&lt;p>kubectl apply -n pxc -f cr.yaml&lt;/p></description></item><item><title>Docs: Plugins</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/9.%E8%BF%90%E7%BB%B4/ansible/plugins/plugins/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/9.%E8%BF%90%E7%BB%B4/ansible/plugins/plugins/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://docs.ansible.com/ansible/latest/plugins/plugins.html">官方文档，使用插件&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>插件是增强 Ansible 核心功能的代码段。Ansible 使用插件架构来启用丰富，灵活和可扩展的功能集。&lt;/p>
&lt;p>朗读 Ansible 附带了许多方便的插件，您可以轻松编写自己的插件。&lt;/p>
&lt;p>本节介绍 Ansible 随附的各种类型的插件：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://docs.ansible.com/ansible/latest/plugins/action.html">Action Plugins&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://docs.ansible.com/ansible/latest/plugins/become.html">Become Plugins&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://docs.ansible.com/ansible/latest/plugins/cache.html">Cache Plugins&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://docs.ansible.com/ansible/latest/plugins/callback.html">Callback Plugins&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://docs.ansible.com/ansible/latest/plugins/cliconf.html">Cliconf Plugins&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://desistdaydream.github.io/docs/IT%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/9.%E8%BF%90%E7%BB%B4/Ansible/Plugins/Connection%20%E6%8F%92%E4%BB%B6.md">Connection 插件&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://docs.ansible.com/ansible/latest/plugins/httpapi.html">Httpapi Plugins&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://docs.ansible.com/ansible/latest/plugins/inventory.html">Inventory Plugins&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://docs.ansible.com/ansible/latest/plugins/lookup.html">Lookup Plugins&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://docs.ansible.com/ansible/latest/plugins/netconf.html">Netconf Plugins&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://docs.ansible.com/ansible/latest/plugins/shell.html">Shell Plugins&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://docs.ansible.com/ansible/latest/plugins/strategy.html">Strategy Plugins&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://docs.ansible.com/ansible/latest/plugins/vars.html">Vars Plugins&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://docs.ansible.com/ansible/latest/user_guide/playbooks_filters.html">Filters&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://docs.ansible.com/ansible/latest/user_guide/playbooks_tests.html">Tests&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://docs.ansible.com/ansible/latest/user_guide/plugin_filtering_config.html">Plugin Filter Configuration&lt;/a>&lt;/li>
&lt;/ul></description></item><item><title>Docs: PowerShell</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/4.terminal-%E4%B8%8E-shell/windows_shell/powershell/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/4.terminal-%E4%B8%8E-shell/windows_shell/powershell/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://learn.microsoft.com/en-us/powershell">官方文档，PowerShell&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>PowerShell 是一种跨平台的任务自动化解决方案，由命令行 shell、脚本语言和配置管理框架组成。 PowerShell 在 Windows、Linux 和 macOS 上运行。&lt;/p>
&lt;p>PowerShell 的独特之处在于，它接受并返回 .NET 对象，而非纯文本。这个特点让 PowerShell 可以更轻松地在一个管道中串联不通的命令。&lt;/p>
&lt;blockquote>
&lt;p>这里面所说的对象，就是面向对象编程中常说的“对象”，就像 Go 语言中的 Struct 类似的东西，只不过是 .NET 语言中的对象。&lt;/p>
&lt;/blockquote>
&lt;p>这些对象在被接收后，再交给格式化函数处理，以人类可读的方式，输出出来。&lt;/p>
&lt;h2 id="powershell-命令">PowerShell 命令&lt;/h2>
&lt;p>PowerShell 中可以执行的命令分两类&lt;/p>
&lt;ul>
&lt;li>系统上的可执行命令。&lt;/li>
&lt;li>cmdlet&lt;/li>
&lt;/ul>
&lt;p>PowerShell 内置了一组 &lt;strong>cmdlet(全称 command-lets)&lt;/strong>，cmdlet 并不是一个独立的可执行文件，而是一种统称，cmdlet 被收集在 PowerShell 模块中，可以按需加载它们。可以用任何编译的 .NET 语言或 PowerShell 脚本语言来编写 cmdlet。&lt;/p>
&lt;p>cmdlet 中每个命令的名称都是由 &lt;strong>Verb-Noun(动词-名词)&lt;/strong> 组成，比如 Get-Command 命令用于获取在 CLI 中注册的所有 cmdlet。&lt;/p>
&lt;p>我们可以通过如下几个命令来搜索可用的 cmdlet&lt;/p>
&lt;ul>
&lt;li>&lt;code>Get-Verb&lt;/code> # 获取所有可用的动词&lt;/li>
&lt;li>&lt;code>Get-Command&lt;/code> # 此命令会检索计算机上安装的所有命令的列表。&lt;/li>
&lt;li>&lt;code>Get-Member&lt;/code> # 基于其他命令运行，可以获取 cmdlet 返回的对象信息，包括对象中的&lt;strong>属性、方法、等等&lt;/strong>&lt;/li>
&lt;li>&lt;code>Get-Help&lt;/code> # 以命令名称为参数调用此命令，将显示一个帮助页面，其中说明了命令的各个部分。&lt;/li>
&lt;/ul>
&lt;p>从本笔记的 &lt;a href="https://desistdaydream.github.io/docs/IT%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Y.Windows%20%E7%AE%A1%E7%90%86/Windows%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/_index.md">Windows 管理工具&lt;/a> 目录查找所有可用的命令，以及查看命令的用法&lt;/p>
&lt;p>我们可以通过 &lt;code>$psversiontable&lt;/code> 和 &lt;code>$host&lt;/code> 变量查看 PowerShell 版本信息&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-powershell" data-lang="powershell">&lt;span style="display:flex;">&lt;span>PS C:\&amp;gt; $psversiontable
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Name Value
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>---- -----
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>PSVersion &lt;span style="color:#ae81ff">7.3&lt;/span>.2
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>PSEdition Core
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>GitCommitId &lt;span style="color:#ae81ff">7.3&lt;/span>.2
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>OS Microsoft Windows &lt;span style="color:#ae81ff">10.0&lt;/span>.19045
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Platform Win32NT
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>PSCompatibleVersions {&lt;span style="color:#ae81ff">1.0&lt;/span>, &lt;span style="color:#ae81ff">2.0&lt;/span>, &lt;span style="color:#ae81ff">3.0&lt;/span>, &lt;span style="color:#ae81ff">4.0&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">…&lt;/span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>PSRemotingProtocolVersion &lt;span style="color:#ae81ff">2.3&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>SerializationVersion &lt;span style="color:#ae81ff">1.1&lt;/span>.0.1
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>WSManStackVersion &lt;span style="color:#ae81ff">3.0&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>PS C:\&amp;gt; $host
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Name &lt;span style="color:#960050;background-color:#1e0010">:&lt;/span> ConsoleHost
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Version &lt;span style="color:#960050;background-color:#1e0010">:&lt;/span> &lt;span style="color:#ae81ff">7.3&lt;/span>.2
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>InstanceId &lt;span style="color:#960050;background-color:#1e0010">:&lt;/span> 518ca4c4-e959-4d51-b3bb-cdcb3d5a1484
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>UI &lt;span style="color:#960050;background-color:#1e0010">:&lt;/span> System.Management.Automation.Internal.Host.InternalHostUserInterface
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>CurrentCulture &lt;span style="color:#960050;background-color:#1e0010">:&lt;/span> zh-CN
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>CurrentUICulture &lt;span style="color:#960050;background-color:#1e0010">:&lt;/span> zh-CN
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>PrivateData &lt;span style="color:#960050;background-color:#1e0010">:&lt;/span> Microsoft.PowerShell.ConsoleHost+ConsoleColorProxy
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>DebuggerEnabled &lt;span style="color:#960050;background-color:#1e0010">:&lt;/span> True
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>IsRunspacePushed &lt;span style="color:#960050;background-color:#1e0010">:&lt;/span> False
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Runspace &lt;span style="color:#960050;background-color:#1e0010">:&lt;/span> System.Management.Automation.Runspaces.LocalRunspace
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h1 id="安装与更新">安装与更新&lt;/h1>
&lt;h1 id="使用-powershell">使用 PowerShell&lt;/h1>
&lt;p>&lt;code>powershell&lt;/code> 和 &lt;code>pwsh&lt;/code> 这几个命令一般都是用来打开 PowerShell 的，同时也是执行 PowerShell 脚本的前置命令。就像执行 Bash 脚本前加个 &lt;code>bash&lt;/code> 命令一样&lt;/p>
&lt;h1 id="item">ITEM&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://learn.microsoft.com/en-us/powershell/scripting/lang-spec/chapter-03#33-items">官方文档-PowerShell，脚本-基本概念-Items&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>PowerShell 中会抽象出一个 &lt;strong>Item(项)&lt;/strong> 的概念，Item 可以一个 &lt;strong>Alias(别名)&lt;/strong>、&lt;strong>Variable(变量)&lt;/strong>、&lt;strong>Function(函数)&lt;/strong>、&lt;strong>EnvironmentVariable(环境变量)&lt;/strong>、甚至可以是文件系统中的 &lt;strong>File(文件)&lt;/strong> 或者 &lt;strong>Directory(目录)&lt;/strong>。&lt;/p>
&lt;p>我们常用的 &lt;code>ls&lt;/code> 命令，在 PowerShell 中其实就是调用了 &lt;code>Get-ChildItem&lt;/code> 命令&lt;/p>
&lt;h1 id="porviders提供器-和-drives驱动器">Porviders(提供器) 和 Drives(驱动器)&lt;/h1>
&lt;p>在 PowerShell 中，Providers 和 Drives 是提供对不同数据源（如文件系统、注册表、Certificate 等）的访问的特定接口。Drives 则是实际代表特定数据源的容器，比如本地磁盘驱动器、注册表驱动器等。使用 PowerShell 可以对这些数据源进行管理和操作。&lt;/p></description></item><item><title>Docs: Prometheus</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/6.%E5%8F%AF%E8%A7%82%E6%B5%8B%E6%80%A7/%E7%9B%91%E6%8E%A7%E7%B3%BB%E7%BB%9F/prometheus/prometheus-%E8%A1%8D%E7%94%9F%E5%93%81/prometheus-operator/cr-%E8%AF%A6%E8%A7%A3/prometheus/prometheus/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/6.%E5%8F%AF%E8%A7%82%E6%B5%8B%E6%80%A7/%E7%9B%91%E6%8E%A7%E7%B3%BB%E7%BB%9F/prometheus/prometheus-%E8%A1%8D%E7%94%9F%E5%93%81/prometheus-operator/cr-%E8%AF%A6%E8%A7%A3/prometheus/prometheus/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;p>参考 &lt;a href="https://desistdaydream.github.io/docs/IT%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/6.%E5%8F%AF%E8%A7%82%E6%B5%8B%E6%80%A7/%E7%9B%91%E6%8E%A7%E7%B3%BB%E7%BB%9F/Prometheus/Prometheus.md">Prometheus&lt;/a> 文中关于 Prometheus Server 的部署我们发现，手动来维护 Prometheus Server 是相当费力的，而在 kubernetes 中，可以借助 operater 帮助我们来完成 Prometheus Server 的创建与维护工作，甚至连自动发现配置都可以。&lt;/p>
&lt;h1 id="prometheus-crd-部署">Prometheus CRD 部署&lt;/h1>
&lt;p>当在 k8s 中部署了 operator 之后，部署 Prometheus Server 就变成了声明一个 Prometheus 资源。&lt;/p>
&lt;p>这是声明一个 Prometheus 类型的资源的 manifest 示例：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-yaml" data-lang="yaml">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">apiVersion&lt;/span>: &lt;span style="color:#ae81ff">monitoring.coreos.com/v1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">kind&lt;/span>: &lt;span style="color:#ae81ff">Prometheus&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">metadata&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">name&lt;/span>: &lt;span style="color:#ae81ff">test&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">namespace&lt;/span>: &lt;span style="color:#ae81ff">monitor&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">spec&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">replicas&lt;/span>: &lt;span style="color:#ae81ff">1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">serviceAccountName&lt;/span>: &lt;span style="color:#ae81ff">prometheus&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>注意：&lt;/p>
&lt;ul>
&lt;li>由于 Prometheus Server 容器需要读取集群内其他资源对象的数据，所以需要给 Prometheus 资源生成的 Pod 一个足够权限的 serviceAccount。&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>kubectl create -n monitor serviceaccount prometheus
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>kubectl create clusterrolebinding prometheus-admin --clusterrole&lt;span style="color:#f92672">=&lt;/span>cluster-admin --serviceaccount&lt;span style="color:#f92672">=&lt;/span>monitor:prometheus
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>声明好 Prometheus 资源，则会看到一个名为 test 的 Prometheus 对象；该对象会自动帮助我们创建一个名为 prometheus-test 的 Statefulsets 对象；这个 Statefulsets 中的 pod 包括 2 个容器，1 个 Prometheus Server 容器，和 1 个 sidecar container；还会有一个 service 来关联到这些 pod 上&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">[&lt;/span>root@master-1 prometheus-operator&lt;span style="color:#f92672">]&lt;/span>&lt;span style="color:#75715e"># kubectl get -n monitor prometheus&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>NAME VERSION REPLICAS AGE
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>test &lt;span style="color:#ae81ff">1&lt;/span> 2m17s
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">[&lt;/span>root@master-1 prometheus-operator&lt;span style="color:#f92672">]&lt;/span>&lt;span style="color:#75715e"># kubectl get -n monitor statefulsets.apps&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>NAME READY AGE
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>prometheus-test 1/1 2m20s
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">[&lt;/span>root@master-1 prometheus-operator&lt;span style="color:#f92672">]&lt;/span>&lt;span style="color:#75715e"># kubectl get -n monitor pod&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>NAME READY STATUS RESTARTS AGE
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>prometheus-operator-6cdb7d79fb-mgv97 1/1 Running &lt;span style="color:#ae81ff">0&lt;/span> 4m49s
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>prometheus-test-0 2/2 Running &lt;span style="color:#ae81ff">0&lt;/span> 73s
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">[&lt;/span>root@master-1 prometheus-operator&lt;span style="color:#f92672">]&lt;/span>&lt;span style="color:#75715e"># kubectl get -n monitor service&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>NAME TYPE CLUSTER-IP EXTERNAL-IP PORT&lt;span style="color:#f92672">(&lt;/span>S&lt;span style="color:#f92672">)&lt;/span> AGE
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>prometheus-operated ClusterIP None &amp;lt;none&amp;gt; 9090/TCP 2m57s
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>prometheus-operator ClusterIP None &amp;lt;none&amp;gt; 8080/TCP 5m12s
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">[&lt;/span>root@master-1 prometheus-operator&lt;span style="color:#f92672">]&lt;/span>&lt;span style="color:#75715e"># kubectl get -n monitor pod prometheus-test-0 -oyaml | neat | grep image&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> image: quay.io/prometheus/prometheus
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> image: quay.io/prometheus-operator/prometheus-config-reloader:v0.45.0
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ul>
&lt;li>quay.io/prometheus/prometheus # Prometheus Server 主程序&lt;/li>
&lt;li>quay.io/prometheus-operator/prometheus-config-reloader:v0.45.0 # 处理 ServiceMonitor、PodMonitor、PrometheusRule 获取到的配置信息，并传递给上面的 prometheus 容器&lt;/li>
&lt;/ul>
&lt;p>这时候一个 Prometheus Server 就部署完成了，可以使用 kubectl port-forward -n monitor service/prometheus-operated 9090:9090 &amp;ndash;address=0.0.0.0 命令来暴露服务的端口，然后访问 https://HostIP:9090，就可以看到 prometheus 的 web 界面了&lt;/p>
&lt;p>现在的 Prometheus 没有任何配置，如图所示。
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/chh1bv/1616068816344-2c704165-0427-47bd-99a8-706e6df77fb0.png" alt="">
如果想要给 prometheus 添加配置，则需要使用 ServiceMonitor、PodMonitor 这些 CRD，或者为 Prometheus 对象添加 additionalScrapeConfigs 字段来引用附加配置，不能直接手动修改配置文件，因为配置文件是通过 sidecar 容器 自动生成的，就算手动修改了也会被还原，因为 operator 会持续监测配置文件与其他方式获取的配置内容是否匹配。&lt;/p>
&lt;h1 id="prometheus-生成的-pod-资源的组成">Prometheus 生成的 Pod 资源的组成&lt;/h1>
&lt;p>&lt;strong>包含 2 个容器，共享部分 volume&lt;/strong>&lt;/p>
&lt;ol>
&lt;li>prometheus # Prometheus Server 主程序。&lt;/li>
&lt;li>config-reloader # 处理 ServiceMonitor、PodMonitor、PrometheusRule 获取到的配置信息，并传递给上面的 prometheus 容器&lt;/li>
&lt;/ol>
&lt;h2 id="prometheus-容器">Prometheus 容器&lt;/h2>
&lt;p>prometheus server 主程序，包括程序启动的一些参数也会提前设置好默认值，如下所示：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-yaml" data-lang="yaml">&lt;span style="display:flex;">&lt;span>- &lt;span style="color:#f92672">args&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - --&lt;span style="color:#ae81ff">web.console.templates=/etc/prometheus/consoles&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - --&lt;span style="color:#ae81ff">web.console.libraries=/etc/prometheus/console_libraries&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - --&lt;span style="color:#ae81ff">config.file=/etc/prometheus/config_out/prometheus.env.yaml&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - --&lt;span style="color:#ae81ff">storage.tsdb.path=/prometheus&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - --&lt;span style="color:#ae81ff">storage.tsdb.retention.time=24h&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - --&lt;span style="color:#ae81ff">web.enable-lifecycle&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - --&lt;span style="color:#ae81ff">storage.tsdb.no-lockfile&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - --&lt;span style="color:#ae81ff">web.route-prefix=/&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">image&lt;/span>: &lt;span style="color:#ae81ff">quay.io/prometheus/prometheus&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">name&lt;/span>: &lt;span style="color:#ae81ff">prometheus&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">ports&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#f92672">containerPort&lt;/span>: &lt;span style="color:#ae81ff">9090&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">name&lt;/span>: &lt;span style="color:#ae81ff">web&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">readinessProbe&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">failureThreshold&lt;/span>: &lt;span style="color:#ae81ff">120&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">httpGet&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">path&lt;/span>: &lt;span style="color:#ae81ff">/-/ready&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">port&lt;/span>: &lt;span style="color:#ae81ff">web&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">periodSeconds&lt;/span>: &lt;span style="color:#ae81ff">5&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">timeoutSeconds&lt;/span>: &lt;span style="color:#ae81ff">3&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">terminationMessagePolicy&lt;/span>: &lt;span style="color:#ae81ff">FallbackToLogsOnError&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">volumeMounts&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e"># 配置文件存储路径，与 config-reloader 挂载同一个名为 config-out 的卷。config-reloader 会将处理好的配置文件放在该卷中。&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#f92672">mountPath&lt;/span>: &lt;span style="color:#ae81ff">/etc/prometheus/config_out&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">name&lt;/span>: &lt;span style="color:#ae81ff">config-out&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">readOnly&lt;/span>: &lt;span style="color:#66d9ef">true&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#f92672">mountPath&lt;/span>: &lt;span style="color:#ae81ff">/etc/prometheus/certs&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">name&lt;/span>: &lt;span style="color:#ae81ff">tls-assets&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">readOnly&lt;/span>: &lt;span style="color:#66d9ef">true&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#f92672">mountPath&lt;/span>: &lt;span style="color:#ae81ff">/prometheus&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">name&lt;/span>: &lt;span style="color:#ae81ff">prometheus-test-db&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#f92672">mountPath&lt;/span>: &lt;span style="color:#ae81ff">/etc/prometheus/rules/prometheus-test-rulefiles-0&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">name&lt;/span>: &lt;span style="color:#ae81ff">prometheus-test-rulefiles-0&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>配置文件使用 config_out 目录，挂载该目录的卷与下面的一个名为 prometheus-config-reloader 的容器的卷相同，所以配置文件是通过 prometheus-config-reloader 容器来生成的。&lt;/p>
&lt;h2 id="config-reloader-容器">config-reloader 容器&lt;/h2>
&lt;p>该容器用于热更新 prometheus server 的主配置文件&lt;/p>
&lt;p>ServiceMonitor 资源会将生成的配置文件写到名为 config 的 secret 中，然后该 container 解压该文件并拷贝到 config-out 卷中。由于 config-out 卷会挂载到该 container 与 prometheus 容器中，所以该卷内的文件也是共享的。然后该程序会执行参数中 reload-url 的的值，对 prometheus 的配置进行热更新&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-yaml" data-lang="yaml">&lt;span style="display:flex;">&lt;span>- &lt;span style="color:#f92672">args&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - --&lt;span style="color:#ae81ff">listen-address=:8080&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - --&lt;span style="color:#ae81ff">reload-url=http://localhost:9090/-/reload&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - --&lt;span style="color:#ae81ff">config-file=/etc/prometheus/config/prometheus.yaml.gz&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - --&lt;span style="color:#ae81ff">config-envsubst-file=/etc/prometheus/config_out/prometheus.env.yaml&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - --&lt;span style="color:#ae81ff">watched-dir=/etc/prometheus/rules/prometheus-test-rulefiles-0&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">command&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#ae81ff">/bin/prometheus-config-reloader&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">env&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#f92672">name&lt;/span>: &lt;span style="color:#ae81ff">POD_NAME&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">valueFrom&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">fieldRef&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">fieldPath&lt;/span>: &lt;span style="color:#ae81ff">metadata.name&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#f92672">name&lt;/span>: &lt;span style="color:#ae81ff">SHARD&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">value&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;0&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">image&lt;/span>: &lt;span style="color:#ae81ff">quay.io/prometheus-operator/prometheus-config-reloader:v0.45.0&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">name&lt;/span>: &lt;span style="color:#ae81ff">config-reloader&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">ports&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#f92672">containerPort&lt;/span>: &lt;span style="color:#ae81ff">8080&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">name&lt;/span>: &lt;span style="color:#ae81ff">reloader-web&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">resources&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">limits&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">cpu&lt;/span>: &lt;span style="color:#ae81ff">100m&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">memory&lt;/span>: &lt;span style="color:#ae81ff">50Mi&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">terminationMessagePolicy&lt;/span>: &lt;span style="color:#ae81ff">FallbackToLogsOnError&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">volumeMounts&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">#&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#f92672">mountPath&lt;/span>: &lt;span style="color:#ae81ff">/etc/prometheus/config&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">name&lt;/span>: &lt;span style="color:#ae81ff">config&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e"># 处理 config 卷中的内容，并生成 Prometheus Server 可读的配置文件，放在 config-out 卷中。&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#f92672">mountPath&lt;/span>: &lt;span style="color:#ae81ff">/etc/prometheus/config_out&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">name&lt;/span>: &lt;span style="color:#ae81ff">config-out&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#f92672">mountPath&lt;/span>: &lt;span style="color:#ae81ff">/etc/prometheus/rules/prometheus-test-rulefiles-0&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">name&lt;/span>: &lt;span style="color:#ae81ff">prometheus-test-rulefiles-0&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="pod-中所使用的-volume">Pod 中所使用的 volume&lt;/h2>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-yaml" data-lang="yaml">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">volumes&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#f92672">name&lt;/span>: &lt;span style="color:#ae81ff">config&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">secret&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">secretName&lt;/span>: &lt;span style="color:#ae81ff">prometheus-test&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#f92672">name&lt;/span>: &lt;span style="color:#ae81ff">tls-assets&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">secret&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">secretName&lt;/span>: &lt;span style="color:#ae81ff">prometheus-test-tls-assets&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#f92672">emptyDir&lt;/span>: {}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">name&lt;/span>: &lt;span style="color:#ae81ff">config-out&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#f92672">configMap&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">name&lt;/span>: &lt;span style="color:#ae81ff">prometheus-test-rulefiles-0&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">name&lt;/span>: &lt;span style="color:#ae81ff">prometheus-test-rulefiles-0&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#f92672">emptyDir&lt;/span>: {}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">name&lt;/span>: &lt;span style="color:#ae81ff">prometheus-test-db&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ul>
&lt;li>&lt;strong>config&lt;/strong> # 通过 ServiceMonitor 等途径生成的配置文以 .gz 的压缩方式，保存在这个卷中
&lt;ul>
&lt;li>通过 ServiceMonitor 等途径获取的配置文件，放在这个卷中，经过 config-reloader 容器处理后，将生成的配置文件放到 config-out 卷中。&lt;/li>
&lt;li>这个 prometheus-test 的 Secret 对象中存储的是配置文件的 .gz 格式的内容。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-yaml" data-lang="yaml">&lt;span style="display:flex;">&lt;span>[&lt;span style="color:#ae81ff">root@master-1 prometheus-operator]# kubectl get secrets prometheus-test -oyaml | neat&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">apiVersion&lt;/span>: &lt;span style="color:#ae81ff">v1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">data&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">prometheus.yaml.gz&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">kind&lt;/span>: &lt;span style="color:#ae81ff">Secret&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">metadata&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">annotations&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">empty&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;true&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">labels&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">managed-by&lt;/span>: &lt;span style="color:#ae81ff">prometheus-operator&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">name&lt;/span>: &lt;span style="color:#ae81ff">prometheus-test&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">namespace&lt;/span>: &lt;span style="color:#ae81ff">default&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">type&lt;/span>: &lt;span style="color:#ae81ff">Opaque&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ul>
&lt;li>**config-out **# config 卷中的配置文件解压缩后保存在这个卷中。Prometheus Server 也挂载了这个卷，可以读取其中的配置文件。&lt;/li>
&lt;li>&lt;strong>prometheus-test-db&lt;/strong> # Prometheus Server 的数据存储卷。这里默认是 emptyDir 类型，可以通过 PV 等方式持久化&lt;/li>
&lt;/ul>
&lt;h1 id="prometheus-配置文件的变化">Prometheus 配置文件的变化&lt;/h1>
&lt;h2 id="servicemontiroselect">serviceMontiroSelect&lt;/h2>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-yaml" data-lang="yaml">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">apiVersion&lt;/span>: &lt;span style="color:#ae81ff">monitoring.coreos.com/v1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">kind&lt;/span>: &lt;span style="color:#ae81ff">Prometheus&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">metadata&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">name&lt;/span>: &lt;span style="color:#ae81ff">test&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">namespace&lt;/span>: &lt;span style="color:#ae81ff">monitor&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">spec&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">replicas&lt;/span>: &lt;span style="color:#ae81ff">1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">serviceAccountName&lt;/span>: &lt;span style="color:#ae81ff">prometheus&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">serviceMonitorSelector&lt;/span>: {}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>添加该字段后，配置文件会增加一些内容&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/chh1bv/1616068816303-8c92c25b-378d-4617-8d35-02e286c35e84.png" alt="">
这些内容可以在 prometheus-test 这个 secret 中看到，可以看到，secret 中的内容就是配置文件压缩后进行 base64 编码后的值。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-yaml" data-lang="yaml">&lt;span style="display:flex;">&lt;span>[&lt;span style="color:#ae81ff">root@master-1 prometheus-operator]# kubectl get secrets -n monitor prometheus-test -oyaml | neat&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">apiVersion&lt;/span>: &lt;span style="color:#ae81ff">v1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">data&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">prometheus.yaml.gz&lt;/span>: &lt;span style="color:#ae81ff">H4sIAAAAAAAA/2yQPUuEMRCE+/yKLSxUiDmwSydo6UcvEvbiXAzsm7xscsf57yXxE7VbZnZmHzZJ3bJ4Q4QDy557riXk0qEHFk+Xm2aIWlRe8UfGsUMLSxDeQtooIVq1Lugv2DdPSy25V3Udrf8yg2KVHNnTyenD/XW4u7q9OTO6F4RdFjRvLDn06L4jbrjth2BHrx3qjNiNO7945UXMB2+sZZdT8/T4ZFigPZc0IOccFBP7a8sQWeI4HuBpWs9a14mtSDj6f+g/yxYunKDvp94CAAD//wMwvnNTAQAA&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">kind&lt;/span>: &lt;span style="color:#ae81ff">Secret&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">metadata&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">annotations&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">generated&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;true&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">labels&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">managed-by&lt;/span>: &lt;span style="color:#ae81ff">prometheus-operator&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">name&lt;/span>: &lt;span style="color:#ae81ff">prometheus-test&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">namespace&lt;/span>: &lt;span style="color:#ae81ff">monitor&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">type&lt;/span>: &lt;span style="color:#ae81ff">Opaque&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>[&lt;span style="color:#ae81ff">root@master-1 prometheus-operator]# echo &amp;#34;H4sIAAAAAAAA/2yQPUuEMRCE+/yKLSxUiDmwSydo6UcvEvbiXAzsm7xscsf57yXxE7VbZnZmHzZJ3bJ4Q4QDy557riXk0qEHFk+Xm2aIWlRe8UfGsUMLSxDeQtooIVq1Lugv2DdPSy25V3Udrf8yg2KVHNnTyenD/XW4u7q9OTO6F4RdFjRvLDn06L4jbrjth2BHrx3qjNiNO7945UXMB2+sZZdT8/T4ZFigPZc0IOccFBP7a8sQWeI4HuBpWs9a14mtSDj6f+g/yxYunKDvp94CAAD//wMwvnNTAQAA&amp;#34; | base64 -d &amp;gt; 123.gz&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>[&lt;span style="color:#ae81ff">root@master-1 prometheus-operator]# gzip -d 123.gz&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>[&lt;span style="color:#ae81ff">root@master-1 prometheus-operator]# cat 123&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">global&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">evaluation_interval&lt;/span>: &lt;span style="color:#ae81ff">30s&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">scrape_interval&lt;/span>: &lt;span style="color:#ae81ff">30s&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">external_labels&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">prometheus&lt;/span>: &lt;span style="color:#ae81ff">monitor/test&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">prometheus_replica&lt;/span>: &lt;span style="color:#ae81ff">$(POD_NAME)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">rule_files&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>- &lt;span style="color:#ae81ff">/etc/prometheus/rules/prometheus-test-rulefiles-0/*.yaml&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">scrape_configs&lt;/span>: []
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">alerting&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">alert_relabel_configs&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#f92672">action&lt;/span>: &lt;span style="color:#ae81ff">labeldrop&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">regex&lt;/span>: &lt;span style="color:#ae81ff">prometheus_replica&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">alertmanagers&lt;/span>: []
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="additionalscrapeconfigs">additionalScrapeConfigs&lt;/h2>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://github.com/prometheus-operator/prometheus-operator/blob/master/Documentation/additional-scrape-config.md">官方文档&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>在使用 Prometheus Operator 时，会有一些很特殊的需求，无法通过 ServiceMonitor 或者 PodMonitor 来自动生成配置，这些配置，就可以通过 additionalScrapeConfigs 来添加到 Prometheus Server 的配置文件中。&lt;/p>
&lt;p>我们可以按照原始的 Prometheus 的 scrape_config 配置环境的格式，写到一个 &lt;code>文件A&lt;/code> 中，然后用 &lt;code>文件A&lt;/code> 创建一个 Secret 对象。并在 additionalScrapeConfigs 字段中，引用这个 Secret 对象中的指定数据，即可将 &lt;code>文件A&lt;/code> 的配置附加到 Prometheus Server 的配置文件中。&lt;/p>
&lt;p>种方式常用来为 Prometheus Server 创建静态的 Scrape 配置。就是 scrape_cofig 配置环境中的 static_configs&lt;/p>
&lt;p>比我，我们创建一个简单的抓取配置。假设命名为&lt;code>prometheus-additional.yaml&lt;/code>&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>cat &amp;gt; prometheus-additional.yaml &lt;span style="color:#e6db74">&amp;lt;&amp;lt;EOF
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">- job_name: &amp;#34;prometheus&amp;#34;
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74"> static_configs:
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74"> - targets: [&amp;#34;localhost:9090&amp;#34;]
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">EOF&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>然后，创建一个该文件的 Secret 对象。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>kubectl create -n monitor secret generic additional-scrape-configs --from-file&lt;span style="color:#f92672">=&lt;/span>prometheus-additional.yaml --dry-run -oyaml &amp;gt; additional-scrape-configs.yaml
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>这个 secret 应该是这个样子的&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-yaml" data-lang="yaml">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">apiVersion&lt;/span>: &lt;span style="color:#ae81ff">v1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">data&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">prometheus-additional.yaml&lt;/span>: &lt;span style="color:#ae81ff">LSBqb2JfbmFtZTogInByb21ldGhldXMiCiAgc3RhdGljX2NvbmZpZ3M6CiAgLSB0YXJnZXRzOiBbImxvY2FsaG9zdDo5MDkwIl0K&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">kind&lt;/span>: &lt;span style="color:#ae81ff">Secret&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">metadata&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">creationTimestamp&lt;/span>: &lt;span style="color:#66d9ef">null&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">name&lt;/span>: &lt;span style="color:#ae81ff">additional-scrape-configs&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">namespace&lt;/span>: &lt;span style="color:#ae81ff">monitor&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>创建这个 Secret 资源&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>kubectl apply -f additional-scrape-configs.yaml
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>最后，在 Prometheus 这个 CRD 中引用这个额外的配置&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-yaml" data-lang="yaml">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">apiVersion&lt;/span>: &lt;span style="color:#ae81ff">monitoring.coreos.com/v1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">kind&lt;/span>: &lt;span style="color:#ae81ff">Prometheus&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">metadata&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">name&lt;/span>: &lt;span style="color:#ae81ff">test&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">namespace&lt;/span>: &lt;span style="color:#ae81ff">monitor&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">spec&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">replicas&lt;/span>: &lt;span style="color:#ae81ff">1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">serviceAccountName&lt;/span>: &lt;span style="color:#ae81ff">prometheus&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">serviceMonitorSelector&lt;/span>: {}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e"># 在这里引用 additional-scrape-configs 这个 secret 对象下的 .data 字段中，名为 prometheus-additional.yaml 的值。&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">additionalScrapeConfigs&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">name&lt;/span>: &lt;span style="color:#ae81ff">additional-scrape-configs&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">key&lt;/span>: &lt;span style="color:#ae81ff">prometheus-additional.yaml&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>这时，在 Prometheus Server 中，就会多出一些 scrape_configs 里的配置：&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/chh1bv/1616068816288-3ce64fdc-877c-41cc-a4b1-c404caff295a.png" alt="">
注意：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>仅对所有的附加抓取配置使用一个 Secret。也就是说所有的附加配置都要写到一个文件里&lt;/p>
&lt;/li>
&lt;li>
&lt;p>现阶段 secret 与 prometheus 这俩资源必须在同一个名称空间下&lt;/p>
&lt;/li>
&lt;/ul></description></item><item><title>Docs: Prometheus</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/6.%E5%8F%AF%E8%A7%82%E6%B5%8B%E6%80%A7/%E7%9B%91%E6%8E%A7%E7%B3%BB%E7%BB%9F/prometheus/prometheus/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/6.%E5%8F%AF%E8%A7%82%E6%B5%8B%E6%80%A7/%E7%9B%91%E6%8E%A7%E7%B3%BB%E7%BB%9F/prometheus/prometheus/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://prometheus.io/docs/introduction/overview/">官方文档&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://yunlzheng.gitbook.io/prometheus-book/">yunlzheng 写的电子书&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://github.com/Tencent-Cloud-Native/tkedocs">GitHub 项目，Tencent-Cloud-Native/tkedocs&lt;/a>(我个人总结完绝大部分文档后发现的这个项目)&lt;/li>
&lt;li>Prometheus 纪录片
&lt;ul>
&lt;li>&lt;a href="https://www.youtube.com/watch?v=rT4fJNbfe14">YouTube&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.bilibili.com/video/BV1aW4y147GX">B 站翻译&lt;/a>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>Prometheus 是由 SoundCloud 开发的 开源监控报警系统 和 时间序列数据库(TSDB) 。&lt;strong>Time Series(时间序列)&lt;/strong> 概念详见：&lt;a href="https://www.yuque.com/go/doc/33147376">Prometheus 数据模型&lt;/a>。使用 Go 语言开发，是 Google BorgMon 监控系统的开源版本。&lt;/p>
&lt;blockquote>
&lt;p>题外话：Google 的 Borg 诞生了 kuberntes、Google 的 Borgmon 诞生了 Prometheus&lt;/p>
&lt;/blockquote>
&lt;p>2016 年由 Google 发起 Linux 基金会旗下的 Cloud Native Computing Foundation(云原生计算基金会), 将 Prometheus 纳入其下第二大开源项目。Prometheus 目前在开源社区相当活跃。&lt;/p>
&lt;h2 id="prometheus-架构概述">Prometheus 架构概述&lt;/h2>
&lt;p>Prometheus 的基本原理是通过 HTTP 协议周期性抓取被监控组件的状态，任意组件只要提供对应的 HTTP 接口就可以接入监控。不需要任何 SDK 或者其他的集成过程。这样做非常适合做虚拟化环境监控系统，比如 VM、Docker、Kubernetes 等。输出被监控组件信息的 HTTP 接口被叫做 exporter 。&lt;/p>
&lt;p>下面这张图说明了 Prometheus 的整体架构，以及生态中的一些组件作用：
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/usvgfl/1616041189523-5ca97287-5886-4ab9-a4f8-6c249117e314.jpeg" alt="">
Prometheus 生态圈中包含了多个组件，其中许多组件是可选的，多数 Prometheus 组件是 Go 语言写的，使得这些组件很容易编译和部署：&lt;/p>
&lt;ul>
&lt;li>&lt;strong>Prometheus Server&lt;/strong> # 主要负责数据抓取和存储，提供 PromQL 查询语言的支持。用于收集和存储时间序列数据。
&lt;ul>
&lt;li>定期从配置好的 Jobs 中&lt;strong>拉取 &lt;strong>Exporters 采集的&lt;/strong> Metrics(指标)&lt;/strong> 数据；或者&lt;strong>接收&lt;/strong>来自 &lt;strong>Pushgateway&lt;/strong>(类似 zabbix 的 proxy) 发过来的 Metrics；或者从其他的 Prometheus Server 中拉取 Metrics。&lt;/li>
&lt;li>Prometheus Server 在本地存储收集到的 Metrics，并通过一定 &lt;strong>RecordingRule(记录规则)&lt;/strong> 进行清理和整理数据，并把得到的结果存储到新的时间序列中。还会运行已定义好的 &lt;strong>AlertingRule(告警规则)&lt;/strong>，记录新的时间序列或者向 Alertmanager 推送警报。&lt;/li>
&lt;li>由于 Metrics 都是通过 HTTP 或者 HTTPS 协议提供的，所以 Prometheus Server 在抓取 Metrics 时，也就是发起一次 HTTP 或者 HTTPS 的 GET 请求&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>Instrumenting&lt;/strong> # 为 Prometheus 提供指标的工具或代码
&lt;ul>
&lt;li>**Exporters **# 导出器。Exporter 是 Prometheus 的一类数据采集组件的总称。它负责从设备上搜集数据，并将其转化为 Prometheus 支持的格式(一般情况下 exporter 是安装在需要采集数据的设备上的程序，并监听某个 port。但是如果想要收集 snmp 信息的话，则有专门的 snmp-exporter 安装在某个地方；再收集指定设备的 snmp 信息，然后 prometheus 再找 snmp-exporter 去收集数据)。与传统的数据采集组件不同的是，它并不向中央服务器发送数据，而是等待中央服务器主动前来抓取。Prometheus 提供多种类型的 Exporter 用于采集各种不同服务的运行状态。目前支持的有数据库、硬件、消息中间件、存储系统、HTTP 服务器、JMX 等。&lt;/li>
&lt;li>&lt;strong>Client Library&lt;/strong> # 客户端库(客户端 SDK)，官方提供的客户端类库有 go、java、scala、python、ruby，其他还有很多第三方开发的类库，支持 nodejs、php、erlang 等。为需要监控的服务生成相应的 Metrics 并暴露给 Prometheus server。当 Prometheus server 来 pull 时，直接返回实时状态的 Metrics。&lt;/li>
&lt;li>**Push Gateway **# 支持 Client 主动推送 Metrics 到 PushGateway，而 PrometheusServer 只是定时去 Gateway 上抓取数据。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>Alertmanager&lt;/strong> # 警告管理器，用来进行报警。从 Prometheus server 端接收到 alerts 后，会进行去除重复数据，分组，并路由到对收的接受方式，发出报警。常见的接收方式有：电子邮件，pagerduty，OpsGenie, webhook 等。&lt;/li>
&lt;li>&lt;strong>prometheus_cli&lt;/strong> # 命令行工具。&lt;/li>
&lt;li>&lt;strong>其他辅助性工具&lt;/strong>
&lt;ul>
&lt;li>Prometheus 通过 PromQL 和其他 API 可视化地展示收集的数据。Prometheus 支持很多方式的图表可视化，例如 Grafana、自带的 PrometheusDashboard 以及自身提供的模版引擎等等。Prometheus 还提供 HTTP API 的查询方式，自定义所需要的输出。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>Prometheus 适用的场景&lt;/p>
&lt;ul>
&lt;li>Prometheus 在记录纯数字时间序列方面表现非常好。它既适用于面向服务器等硬件指标的监控，也适用于高动态的面向服务架构的监控。对于现在流行的微服务，Prometheus 的多维度数据收集和数据筛选查询语言也是非常的强大。Prometheus 是为服务的可靠性而设计的，当服务出现故障时，它可以使你快速定位和诊断问题。它的搭建过程对硬件和服务没有很强的依赖关系。&lt;/li>
&lt;/ul>
&lt;p>Prometheus 不适用的场景&lt;/p>
&lt;ul>
&lt;li>Prometheus 它的价值在于可靠性，甚至在很恶劣的环境下，你都可以随时访问它和查看系统服务各种指标的统计信息。 如果你对统计数据需要 100%的精确，它并不适用，例如：它不适用于实时计费系统。&lt;/li>
&lt;/ul>
&lt;h3 id="总结prometheus-从-instrumenting-那里抓取监控数据储存完了哈哈哈哈哈">总结：prometheus 从 Instrumenting 那里抓取监控数据，储存。完了~~~~哈哈哈哈哈&lt;/h3>
&lt;h2 id="instrumenting检测仪表装置-的实现方式">Instrumenting(检测仪表装置) 的实现方式&lt;/h2>
&lt;p>Prometheus 可以通过 3 种方式从目标上 Scrape(抓取) 指标：&lt;/p>
&lt;ul>
&lt;li>&lt;strong>Exporters&lt;/strong> # 外部抓取程序&lt;/li>
&lt;li>&lt;strong>Instrumentation&lt;/strong> # 可以理解为内嵌的 Exporter，比如 Prometheus Server 的 9090 端口的 &lt;code>/metrics&lt;/code> 就属于此类。
&lt;ul>
&lt;li>说白了，就是目标自己就可以吐出符合 Prometheus 格式的指标数据&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>Pushgateway&lt;/strong> # 针对需要推送指标的应用&lt;/li>
&lt;/ul>
&lt;h2 id="label-与-relabeling">Label 与 Relabeling&lt;/h2>
&lt;p>详见 &lt;a href="https://desistdaydream.github.io/docs/IT%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/6.%E5%8F%AF%E8%A7%82%E6%B5%8B%E6%80%A7/%E7%9B%91%E6%8E%A7%E7%B3%BB%E7%BB%9F/Prometheus/Target(%E7%9B%AE%E6%A0%87)%20%E4%B8%8E%20Relabeling(%E9%87%8D%E6%96%B0%E6%A0%87%E8%AE%B0).md">Label 与 Relabeling 章节&lt;/a>&lt;/p>
&lt;h2 id="instrumenting-的安装与使用">Instrumenting 的安装与使用&lt;/h2>
&lt;p>详见 &lt;a href="https://desistdaydream.github.io/docs/IT%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/6.%E5%8F%AF%E8%A7%82%E6%B5%8B%E6%80%A7/%E7%9B%91%E6%8E%A7%E7%B3%BB%E7%BB%9F/Instrumenting/Instrumenting.md">Instrumenting 章节&lt;/a>&lt;/p>
&lt;h1 id="prometheus-部署">Prometheus 部署&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://prometheus.io/docs/prometheus/latest/installation/">官方文档，Prometheus-安装&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>官方系统版本可在这里下载：&lt;a href="https://prometheus.io/download/">https://prometheus.io/download/&lt;/a>&lt;/p>
&lt;p>Prometheus 官方有多种部署方案，比如：Docker 容器、Ansible、Chef、Puppet、Saltstack 等。Prometheus 用 Golang 实现，因此具有天然可移植性(支持 Linux、Windows、macOS 和 Freebsd)。&lt;/p>
&lt;h2 id="二进制文件运行-prometheus-server">二进制文件运行 Prometheus Server&lt;/h2>
&lt;ul>
&lt;li>&lt;a href="https://github.com/prometheus/prometheus/releases/">https://github.com/prometheus/prometheus/releases/&lt;/a> 在该页面下直接下载 prometheus 的进制文件 &lt;code>prometheus-版本号.linux-amd64.tar.gz&lt;/code> 并解压，其中包含 prometheus 的主程序还有 yaml 格式的配置文件以及运行所需要的依赖库&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>export PromVersion&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;2.25.1&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>wget https://github.com/prometheus/prometheus/releases/download/v&lt;span style="color:#e6db74">${&lt;/span>PromVersion&lt;span style="color:#e6db74">}&lt;/span>/prometheus-&lt;span style="color:#e6db74">${&lt;/span>PromVersion&lt;span style="color:#e6db74">}&lt;/span>.linux-amd64.tar.gz
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ul>
&lt;li>创建/usr/local/prometheus 目录，并将解压的所有文件移动到该目录下&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>mkdir /usr/local/prometheus
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>tar -zxvf prometheus-&lt;span style="color:#e6db74">${&lt;/span>PromVersion&lt;span style="color:#e6db74">}&lt;/span>.linux-amd64.tar.gz -C /usr/local/prometheus/ --strip-components&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ul>
&lt;li>创建 Systemd 服务,在 ExecStart 字段上，使用运行时标志来对 prometheus 进行基本运行配置，标志说明详见下文&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>cat &amp;gt; /usr/lib/systemd/system/prometheus.service &lt;span style="color:#e6db74">&amp;lt;&amp;lt; EOF
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">[Unit]
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">Description=prometheus
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">After=network.target
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">[Service]
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">Type=simple
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">User=root
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">ExecStart=/usr/local/prometheus/prometheus \
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74"> --web.console.templates=/usr/local/prometheus/consoles \
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74"> --web.console.libraries=/usr/local/prometheus/console_libraries \
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74"> --config.file=/usr/local/prometheus/prometheus.yml \
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74"> --storage.tsdb.path=/var/lib/prometheusData \
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74"> --web.enable-lifecycle
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">Restart=on-failure
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">[Install]
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">WantedBy=multi-user.target
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">EOF&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ul>
&lt;li>启动 Prometheus&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>systemctl start prometheus
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="容器运行-prometheus">容器运行 prometheus&lt;/h2>
&lt;p>获取配置文件.&lt;/p>
&lt;blockquote>
&lt;p>也可以不获取配置文件，去掉启动时的 -v /etc/monitoring/prometheus:/etc/prometheus/config_out 与 &amp;ndash;config.file=/etc/prometheus/config_out/prometheus.yml 这两行即可
获取配置文件主要是为了让后续测试可以更方便得修改文件&lt;/p>
&lt;/blockquote>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>mkdir -p /opt/monitoring/prometheus
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>docker run -d --name prometheus --rm prom/prometheus
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>docker cp prometheus:/etc/prometheus /opt/monitoring/prometheus
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>mv /opt/monitoring/prometheus/prometheus /opt/monitoring/prometheus/config
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>docker stop prometheus
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>运行 Prometheus Server&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>docker run -d --name prometheus --restart&lt;span style="color:#f92672">=&lt;/span>always &lt;span style="color:#ae81ff">\
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">&lt;/span> --network host &lt;span style="color:#ae81ff">\
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">&lt;/span> -v /etc/localtime:/etc/localtime &lt;span style="color:#ae81ff">\
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">&lt;/span> -v /opt/monitoring/prometheus/config:/etc/prometheus/config_out &lt;span style="color:#ae81ff">\
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">&lt;/span> prom/prometheus &lt;span style="color:#ae81ff">\
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">&lt;/span> --config.file&lt;span style="color:#f92672">=&lt;/span>/etc/prometheus/config_out/prometheus.yml
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h1 id="prometheus-关联文件与配置">Prometheus 关联文件与配置&lt;/h1>
&lt;p>**/etc/prometheus/prometheus.yml **# Prometheus Server 运行时的配置文件。可通过 &amp;ndash;config.file 标志指定其他文件。
&lt;strong>/etc/prometheus/rule.yml&lt;/strong> # Prometheus Rule 配置文件。该文件默认不存在，需手动创建。可以在 prometheus.yml 配置中指定其他文件。&lt;/p>
&lt;h2 id="prometheus-配置示例">Prometheus 配置示例&lt;/h2>
&lt;h3 id="默认配置文件">默认配置文件&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-yaml" data-lang="yaml">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># 全局配置&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">global&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">scrape_interval&lt;/span>: &lt;span style="color:#ae81ff">15s&lt;/span> &lt;span style="color:#75715e"># 默认抓取间隔, 15秒向目标抓取一次数据。&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">evaluation_interval&lt;/span>: &lt;span style="color:#ae81ff">15s&lt;/span> &lt;span style="color:#75715e"># 每15秒评估一次规则，默认为1分钟。&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e"># scrape_timeout is set to the global default (10s).&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e"># 告警报警配置，设置prometheus主程序对接alertmanager程序的&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">alerting&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">alertmanagers&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#f92672">static_configs&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#f92672">targets&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e"># - alertmanagerIP:9093&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># 指定要使用的规则文件位置，并加载一次，根据全局配置中的 evaluation_interval 来定期评估&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># 从所有匹配到的文件中读取配置内容。可以使用正则表达式匹配多个符合的文件。Prometheus支持两种规则&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># 其一是记录规则(recording rules)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># 其二是告警规则(alerting rules)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">rule_files&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e"># - &amp;#34;first.rules&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e"># - &amp;#34;second.rules&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># 抓取配置，prometheus抓取exporter上的数据时的配置，一个job就是一个抓取工作，其中可以包括1个或者多个目标&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># 目标指的是可以被 prometheus 采集的服务器、服务等。&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># 默认配置里，Prometheus Server 会抓取本地9090端口上数据。该端口上的 exporter 就是 PrometheusServer 自己的 exporter&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">scrape_configs&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># job_name 指定要 scrape(抓取) 的 job(工作) 名称，名称必须是唯一的&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># 并且在这个配置内的时间序例，每一条都会自动添加上这个{job_name:&amp;#34;prometheus&amp;#34;}的标签。&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>- &lt;span style="color:#f92672">job_name&lt;/span>: &lt;span style="color:#e6db74">&amp;#39;prometheus&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e"># 设定该job的抓取时间间隔&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">scrape_interval&lt;/span>: &lt;span style="color:#ae81ff">5s&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">static_configs&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#f92672">targets&lt;/span>: [&lt;span style="color:#e6db74">&amp;#39;localhost:9090&amp;#39;&lt;/span>]
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="具有-node_exporter-的配置简单文件">具有 node_exporter 的配置简单文件&lt;/h3>
&lt;p>抓取部署了 node_exporter 设备的监控数据的方式及 prometheus.yml 配置文件说明
prometheus 会从 Node Exporter 所在服务器的 http://IP:9100/metrics 这个地址里的内容来获取该设备的监控数据
所以需要给 prometheus 创建一个工作(i.e.job)。一个 job 就是一个抓取监控数据的工作，其中包括要抓取目标的 ip 和 port，还可以设置标签进行分类，还能进行抓取筛选等等，下面提供一个基本的配置
修改 prometheus.yml，加入下面的监控目标，以便让 prometheus 监控这个已经安装了 node_exporter 的设备&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-yaml" data-lang="yaml">&lt;span style="display:flex;">&lt;span>- &lt;span style="color:#f92672">job_name&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;linux&amp;#34;&lt;/span> &lt;span style="color:#75715e">#新增一个job，名为linux&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">static_configs&lt;/span>: &lt;span style="color:#75715e"># 使用静态配置&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#f92672">targets&lt;/span>: [&lt;span style="color:#e6db74">&amp;#34;10.10.100.101:9100&amp;#34;&lt;/span>] &lt;span style="color:#75715e">#添加一个要抓取数据的目标，指定IP与PORT 。node_exporter所安装的设备&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">labels&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">instance&lt;/span>: &lt;span style="color:#ae81ff">lchTest&lt;/span> &lt;span style="color:#75715e">#给该目标添加一个标签&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>现在，prometheus.yml 配置文件中中一共定义了两个监控：一个是默认自带监控 prometheus 自身服务，另一个是我们新增的 job，这个 job 就是要抓取目标是 10.10.100.101 这台服务器上的监控数据&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-yaml" data-lang="yaml">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">scrape_configs&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#f92672">job_name&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;prometheus&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">static_configs&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#f92672">targets&lt;/span>: [&lt;span style="color:#e6db74">&amp;#34;localhost:9090&amp;#34;&lt;/span>]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#f92672">job_name&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;linux&amp;#34;&lt;/span> &lt;span style="color:#75715e">#指定job名称&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">static_configs&lt;/span>: &lt;span style="color:#75715e">#设定静态配置&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#f92672">targets&lt;/span>: [&lt;span style="color:#e6db74">&amp;#34;10.10.100.101:9100&amp;#34;&lt;/span>] &lt;span style="color:#75715e">#指定node_exporter所安装设备的ip:port&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">labels&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">instance&lt;/span>: &lt;span style="color:#ae81ff">lchTest&lt;/span> &lt;span style="color:#75715e">#给该target一个label来分类，常用于在查询语句中的筛选条件&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>访问 Prometheus Web，在 Status-&amp;gt;Targets 页面下，我们可以看到我们配置的两个 Target，它们的 State 为 UP
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/usvgfl/1616041189541-1dfdddd7-ee74-4f32-8df6-8821cf415a14.jpeg" alt="">&lt;/p>
&lt;h1 id="prometheus-的基本使用方式">Prometheus 的基本使用方式&lt;/h1>
&lt;p>Prometheus 运行后默认会监听在 9090 端口，可以通过访问 9090 端口来打开 Prometheus 的 web 界面
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/usvgfl/1616041189523-861a164c-3f79-42af-bd88-44c4baf2e349.jpeg" alt="">
Prometheus 本身也是自带 exporter 的,我们通过请求 http://ip:9090/metrics 可以查看从 exporter 中能具体抓到哪些 metrics。
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/usvgfl/1616041189563-4125f137-160f-48dd-b4f6-dfd6af94aed0.jpeg" alt="">&lt;/p>
&lt;p>这里以 Prometheus 本身数据为例，简单演示下在 Web 中查询指定表达式及图形化显示查询结果。
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/usvgfl/1616041189526-ee545ef0-965e-499c-b80f-b6cdaf05c974.jpeg" alt="">
[&lt;/p>
&lt;h1 id="instrumentingmd">](Instrumenting.md)&lt;/h1></description></item><item><title>Docs: Tunneling Protocol(隧道协议)</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/4.%E6%95%B0%E6%8D%AE%E9%80%9A%E4%BF%A1/tunneling-protocol%E9%9A%A7%E9%81%93%E5%8D%8F%E8%AE%AE/tunneling-protocol%E9%9A%A7%E9%81%93%E5%8D%8F%E8%AE%AE/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/4.%E6%95%B0%E6%8D%AE%E9%80%9A%E4%BF%A1/tunneling-protocol%E9%9A%A7%E9%81%93%E5%8D%8F%E8%AE%AE/tunneling-protocol%E9%9A%A7%E9%81%93%E5%8D%8F%E8%AE%AE/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Tunneling_protocol">Wiki,Tunneling Protocol&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Overlay_network">Wiki,Overlay Network&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Virtual_private_network">Wiki,VPN&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>&lt;strong>Tunneling Protocol(隧道协议)&lt;/strong> 是一种通信协议，允许数据从一个网络移动到另一个网络。该协议通过 &lt;a href="https://www.yuque.com/desistdaydream/learning/qv9w7o#Q2Gsb">Encapsulation(封装)&lt;/a> 的过程跨公共网络发送专用网络通信。因为隧道涉及将流量数据重新打包为不同的形式，可能以加密为标准，它可以隐藏通过隧道运行的流量的性质。隧道协议通过使用数据包的 Payload(数据部分) 来承载实际提供服务的数据包。隧道使用分层协议模型，例如 OSI 或 TCP/IP 协议套件中的那些，但在使用有效载荷承载网络通常不提供的服务时通常会违反分层。通常，在分层模型中，传送协议在与有效载荷协议相同或更高的级别上运行。&lt;/p>
&lt;p>隧道技术是一种通过使用互联网络的基础设施在网络之间传递数据的方式。使用隧道传递的数据（或负载）可以是不同协议的数据帧或包。隧道协议将其它协议的数据帧或包重新封装然后通过隧道发送。新的帧头提供路由信息，以便通过互联网传递被封装的负载数据。&lt;/p>
&lt;p>隧道的常见用途&lt;/p>
&lt;ul>
&lt;li>隧道协议可以允许外部协议在不支持该特定协议的网络上运行，例如在 IPv4 上运行 IPv6。&lt;/li>
&lt;li>另一个重要用途是提供仅使用底层网络服务提供的不切实际或不安全的服务，例如向其物理网络地址不属于公司网络的远程用户提供公司网络地址。&lt;/li>
&lt;li>用户还可以使用隧道“潜入”防火墙，使用防火墙通常会阻止的协议，但“包装”在防火墙不会阻止的协议中，例如 HTTP。如果防火墙策略没有明确排除这种“包装”，则此技巧可以绕过预期的防火墙策略（或任何一组互锁的防火墙策略）。&lt;/li>
&lt;li>另一种基于 HTTP 的隧道方法使用 HTTP CONNECT 方法/命令。客户端向 HTTP 代理发出 HTTP CONNECT 命令。然后，代理与特定的 server:port 建立 TCP 连接，并在该 server:port 和客户端连接之间中继数据。 [1]因为这会产生安全漏洞，所以支持 CONNECT 的 HTTP 代理通常会限制对 CONNECT 方法的访问。代理仅允许连接到特定端口，例如 HTTPS 的 443。&lt;/li>
&lt;/ul>
&lt;h2 id="overlay">Overlay&lt;/h2>
&lt;p>&lt;strong>Overlay(叠加网络)&lt;/strong> 实际上是一种隧道封装技术，是对隧道技术的扩展。传统隧道技术仅限于隧道两端通信，而 Overlay 网络则可以实现 N 个端点之间的互相通信。&lt;/p>
&lt;h2 id="vpn">VPN&lt;/h2>
&lt;p>&lt;strong>Virtual Private Network(虚拟专用网络，简称 VPN)&lt;/strong> 是通过&lt;strong>隧道协议&lt;/strong>建立的虚拟点对点连接。可以从逻辑上，让人们将通过 VPN 将两个或多个互不连接的网络打通，组成一个更大型的局域网。&lt;/p>
&lt;h1 id="tunnel">Tunnel&lt;/h1>
&lt;p>应用场景：&lt;/p>
&lt;ol>
&lt;li>一个公司在天津与北京分别有一个办公地点，天津的内网为 10.0.0.0/24，北京的内网为 10.0.1.0/24。那么如何让两个内网互通呢?可以使用 tunnel 技术，在两地公网出口建立隧道连接。天津访问北京的时候，目的内网地址是封装在公网 IP 里面的，这样就可以让私网地址的数据在公网传输。比如大企业都有自己的隧道网络，当使用个人电脑，安装上某些隧道软件后，那么这台电脑就可以访问公司内部网络了。&lt;/li>
&lt;/ol>
&lt;p>Tunnel 技术的实现方式：&lt;/p>
&lt;ul>
&lt;li>基于数据包:
&lt;ul>
&lt;li>IPsec&lt;/li>
&lt;li>一般路由封装（GRE），支持多种网络层协议和多路技术&lt;/li>
&lt;li>IP in IP[2]，比 GRE 更小的负载头，并且适合只有负载一个 IP 流的情况。&lt;/li>
&lt;li>L2TP（数据链接层隧道协议）[3]&lt;/li>
&lt;li>MPLS （多协议标签交换）&lt;/li>
&lt;li>GTP&lt;/li>
&lt;li>PPTP（点对点隧道协议） [4]&lt;/li>
&lt;li>PPPoE（基于以太网的点对点隧道）&lt;/li>
&lt;li>PPPoA（基于 ATM 的点对点隧道）&lt;/li>
&lt;li>IEEE 802.1Q （以太网 VLANs）&lt;/li>
&lt;li>DLSw（SNA 负载互联网协议）&lt;/li>
&lt;li>XOT（X.25 数据片负载 TCP）&lt;/li>
&lt;li>IPv6 穿隧：6to4、6in4、Teredo&lt;/li>
&lt;li>Anything In Anything （AYIYA，例如：IPv6 over UDP over IPv4, IPv4 over IPv6, IPv6 over TCP IPv4 等）&lt;/li>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/WireGuard">WireGuard&lt;/a>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>基于流:
&lt;ul>
&lt;li>传输层安全&lt;/li>
&lt;li>SSH&lt;/li>
&lt;li>SOCKS&lt;/li>
&lt;li>HTTP CONNECT 命令&lt;/li>
&lt;li>各式的电路层级的代理服务器协议，如 Microsoft Proxy Server 的 Winsock Redirection Protocol 或 WinGate Winsock Redirection Service.&lt;/li>
&lt;li>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h1 id="overlay-1">Overlay&lt;/h1>
&lt;p>overlay 技术，一般都需要一个第三方程序来实现(这个程序可以是一个守护进程、内核等等)。这个程序的作用就是让本身并不互通的内部网络可以互通(比如不同宿主机上的容器互通 2.flannel.note 或者不同宿主机上的虚拟机互通或者)。而让这些网络互通的信息(比如路由、arp 等)就是由这个第三方程序来保存并维护的。如下图所示
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/qw0o0m/1616160946658-7d2f69f8-d44e-4bd6-981c-5752d093bdff.jpeg" alt="">
现在想要 10.244.0.1 可以 ping 通 10.244.1.1。那么 node1 就需要知道 10.244.1.1 在哪台宿主机上。而这种信息，就是靠可以实现 overlay 功能的程序或者内核(甚至几条路由表的规则)来保存并维护的。凡是连接到 overlay 程序的容器，其本身的 IP 以及所在宿主机的 IP，都会被保存下来，以便通信时可以使用。而这些数据，宿主机并不需要知道，在把要发送的数据包交给宿主机的网络栈时，数据包中的目的地址，如果是 10.244.1.0/24 网段的，那么 192.168.0.1 宿主机本身并不知道，所以，overlay 程序的其中一个功能，就是在数据包外面进行封装，把本身的目的地址掩盖起来，并把自己维护的信息中的可以被宿主机识别的 IP 地址填上，这样，就会形成 IP 套 IP 的效果，也就是上面的 tunnel 的效果。这时候，当宿主机收到数据包的时候，就会清楚的知道，要发送到哪里，而 node2 再接收到数据包并解封装后，会看到 overlay 程序封装的信息，就会把数据包交给本机的 overlay 程序，进行后续处理.&lt;/p>
&lt;p>Overlay 技术的实现就是 VXLAN，关于 VXLAN 的介绍，可以参考 2.flannel.note 中的 VXLAN 模型，其中有关于 VXLAN 工作流程的详细讲解&lt;/p></description></item><item><title>Docs: 安装操作系统</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%AE%9E%E7%94%A8%E5%B7%A5%E5%85%B7/%E5%AE%89%E8%A3%85%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E5%AE%89%E8%A3%85%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%AE%9E%E7%94%A8%E5%B7%A5%E5%85%B7/%E5%AE%89%E8%A3%85%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E5%AE%89%E8%A3%85%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Windows_Preinstallation_Environment">Wiki，Windows_Preinstallation_Environment&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Live_USB">Wiki，Live_USB&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>我们想要安装操作系统，通常都需要将一个 &lt;strong>Bootable Media(启动介质)&lt;/strong> 放到 &lt;strong>Operating System Installation Media(操作系统安装介质)&lt;/strong> 中，一般使用介质制作工具(UltraISO、Rufus 等)来实现。这个&lt;strong>操作系统的安装介质&lt;/strong>可以是 &lt;strong>U盘、光盘、网络存储等&lt;/strong>。&lt;/p>
&lt;p>之后，将需要安装系统的计算机与介质连接，这个介质将会被加载到内存中，从而提供一个临时的环境(这个环境有可能会类似操作系统)，人类在这个环境中可以访问计算机硬件资源和文件系统的环境，从而利用介质中的安装程序，将操作系统安装到计算机中。毕竟，只要能访问到硬件资源了了，剩下的就是将文件写入到硬盘中即可。&lt;/p>
&lt;p>除了最基本的启动介质，很多操作系统的发行商还会提供一个具有微型系统能力的启动介质，这种介质除了最基本的安装能力外，还提供了很多额外的工具，以便可以修复、管理计算机，或者修复操作系统。Windows 和 Linux 对这种启动介质有各自的称呼&lt;/p>
&lt;ul>
&lt;li>&lt;strong>Preinstallation Environment&lt;/strong> # Windows 微型系统的称呼。简称 WinPE&lt;/li>
&lt;li>&lt;strong>Live&lt;/strong> # Linux 微型系统的称呼。比如 Ubuntu Live&lt;/li>
&lt;/ul>
&lt;h1 id="ghost">Ghost&lt;/h1>
&lt;h2 id="概述-1">概述&lt;/h2>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Ghost_(disk_utility)">Wiki,Ghost(disk utility)&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote></description></item><item><title>Docs: 编程技术</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/2.%E7%BC%96%E7%A8%8B/%E7%BC%96%E7%A8%8B%E6%8A%80%E6%9C%AF/%E7%BC%96%E7%A8%8B%E6%8A%80%E6%9C%AF/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/2.%E7%BC%96%E7%A8%8B/%E7%BC%96%E7%A8%8B%E6%8A%80%E6%9C%AF/%E7%BC%96%E7%A8%8B%E6%8A%80%E6%9C%AF/</guid><description>
&lt;h1 id="crud增删改查">CRUD(增删改查)&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Create,_read,_update_and_delete">Wiki,CRUD&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>在计算机编程中，&lt;strong>Create、Read、Update、Delete(创建、读取、更新、删除，简称 增删改查(CRUD))&lt;/strong> 是持久性存储的四个基本操作。[1] CRUD 有时也用于描述用户界面约定，这些约定便于使用基于计算机的表单和报告查看、搜索和更改信息。这个词很可能是詹姆斯·马丁 (James Martin) 在他的 1983 著作《管理数据库环境》中首次推广的。
are the four basic operations of &lt;a href="https://en.wikipedia.org/wiki/Persistent_storage">persistent storage&lt;/a>.&lt;a href="https://en.wikipedia.org/wiki/Create,_read,_update_and_delete#cite_note-james-martin-1">[1]&lt;/a> CRUD is also sometimes used to describe &lt;a href="https://en.wikipedia.org/wiki/User_interface">user interface&lt;/a> conventions that facilitate viewing, searching, and changing information using computer-based &lt;a href="https://en.wikipedia.org/wiki/Form_(document)">forms&lt;/a> and &lt;a href="https://en.wikipedia.org/wiki/Report">reports&lt;/a>. The term was likely first popularized by &lt;a href="https://en.wikipedia.org/wiki/James_Martin_(author)">James Martin&lt;/a> in his 1983 book &lt;em>Managing the Data-base environment&lt;/em>.&lt;/p>
&lt;h1 id="projects项目">Projects(项目)&lt;/h1>
&lt;p>项目一般就是指开发一个程序。
从写代码的角度看，一个项目就是一个文件夹，该文件夹中包含该项目所需要依赖的第三方库，项目主体的代码，可执行文件等。&lt;/p>
&lt;h1 id="前端与后端">前端与后端&lt;/h1>
&lt;p>后端：一般是用来处理客户端发送的请求，并将前端写的 页面代码 文件，发送给客户端；或者从数据库获取数据，并填充到前端页面中；等等
前端：一般用来展示的，客户端收到的页面文件(比如输入用户名和密码的框，下拉框等等)，都是由前端工程师来写的，一般是 html 等。&lt;/p>
&lt;h2 id="前后端交互">前后端交互&lt;/h2>
&lt;p>前端与后端之间的交互取决于是前后端分离还不分离&lt;/p>
&lt;ul>
&lt;li>前后端不分离时，通常由后端代码渲染 html 等静态资源文件，&lt;strong>此时客户端访问的是由后端代码监听的端口&lt;/strong>&lt;/li>
&lt;li>前后端分离时，又分多种情况
&lt;ul>
&lt;li>将 html 等静态资源放在 Nginx 等可以提供 HTTP 服务的程序中，然后通过后端提供的 API 进行交互，&lt;strong>此时客户端访问的是由提供 HTTP 服务程序监听的端口&lt;/strong>&lt;/li>
&lt;li>将 html 等静态资源与后端代码放在一起，这种行为通常称为“XX 语言嵌入静态资源”，&lt;strong>此时客户端访问的是由后端程序监听的端口&lt;/strong>
&lt;ul>
&lt;li>比如 Go 语言在 1.16 版本中推出的 embed 库即可实现该效果&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h2 id="前端">前端&lt;/h2>
&lt;p>&lt;strong>htmx&lt;/strong> # 不使用 JavaScript 也可以和浏览器进行交互&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://mp.weixin.qq.com/s/oGk8QtvHwvPDDkOpR5dLzQ">https://mp.weixin.qq.com/s/oGk8QtvHwvPDDkOpR5dLzQ&lt;/a>&lt;/li>
&lt;/ul>
&lt;h1 id="库标准库第三方库与框架">库、标准库、第三方库与框架&lt;/h1>
&lt;p>每种编程语言都具有最基本的功能，比如输入、输出等，这些都属于基本库。比如我使用 print 想输出一些内容，则是调用输出所用的库来实现这个效果。这些基本库都是内置在各个编程语言当中的，可以直接调用。
但是有时候会有很复杂的需求， 比如对系统的某些程序进行操作、对数据库进行操作、写出来的程序如何设置子命令和参数等等等。这些复杂的需求，如果使用基本的编程语言来实现，是非常麻烦的，这时候如果有人可以提前使用编程语言的基本功能来创作一个可以实现某个具体功能的程序就好了。
这个创作出来的基本程序就可以称之为“库或者框架”
至于库和框架的区别：库的英语为 Library ( 简写 Lib )，框架的英语为 Framework。库和框架都是一种有别于软件、面向程序开发者的产品形式。正因为如此，也有很多人误以为库就是框架，或者认为指定语言的库就是框架。&lt;/p>
&lt;ul>
&lt;li>库：库是将代码集合成的一个产品，供程序员调用。面向对象的代码组织形式而成的库也叫类库。面向过程的代码组织形式而成的库也叫函数库。在函数库中的可直接使用的函数叫库函数。开发者在使用库的时候，只需要使用库的一部分类或函数，然后继续实现自己的功能。
&lt;ul>
&lt;li>标准库：就是各种语言自带的库，比如 go 里的 fmt 库，用来输出。这些标准库与语言的关键字构成了编程语言的基本功能。&lt;/li>
&lt;li>第三方库：是对编程语言的扩展，比如一种语言需要更多丰富的功能，而不仅有标准库的功能的时候，可以导入第三方库并使用它们。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>框架：框架则是为解决一个(一类)问题而开发的产品，框架用户一般只需要使用框架提供的类或函数，即可实现全部功能。可以说，框架是库的升级版。开发者在使用框架的时候，必须使用这个框架的全部代码。&lt;/li>
&lt;/ul>
&lt;p>库更像一个一个小的功能，比如使代码可以操作数据库这个功能，使代码可以监听在设备的某个端口上等等。
而框架则更像一个还没完成的程序，只有一些大体框架，其中具体的内容，可以根据自己的喜好去填充，说白了，就是一种规范，只要根据这个规范，就可以实现自己的某个程序。比如想开发一个 web 程序，就可以使用一个 web 框架，这个框架会给开发者直接提供一个基本的后端，至于其中的内容，开发者再去详细填写就好了
框架和库的比较可以想像为:
假如我们要买一台电脑：电脑内的每个部件就是编程语言的一个个关键字&lt;/p>
&lt;ol>
&lt;li>框架为我们提供了已经装好的电脑，我们只要买回来就能用，但你必须把整个电脑买回来。这样用户自然轻松许多，但会导致很多人用一样的电脑，或你想自定义某个部件将需要修改这个框架。&lt;/li>
&lt;li>库就如自己组装的电脑。库为我们提供了很多部件，我们需要自己组装，如果某个部件库未提供，我们也可以自己做。库的使用非常灵活，但没有框架方便。&lt;/li>
&lt;/ol>
&lt;p>然后通过对库和框架的使用，可以使该电脑实现我们自己想要的功能，比如玩游戏、办公、看电影等等。
程序开发中的框架(例如 1000 万+行的 Qt)往往是对常见功能的封装(类似于成语对常用含义的代指，不同点在于应用框架最终对 CPU 表达含义时候会把成语替换为原本含义-通过函数调用),抛开框架，程序会变得因缺少一些&amp;rsquo;固定成语&amp;rsquo;(函数)的&amp;rsquo;释义&amp;rsquo;(函数实现)而变得无法执行。
所以，程序框架理解为基础或者机械标准件(例如螺丝螺母这些有明确标准的机械部件)更为贴切。
这样理解，假如你要造一辆马车，在没有框架的情况下，你需要自己去伐木，去把木头做成木板，木棍，然后组成轮子，门，等部件，然后组装起来，但如果你用了框架，就相当于你有现成的轮子，门等部件，你只需要组装一下就可以了。
可以说，一个框架是一个可复用的设计构件，它规定了应用的体系结构，阐明了整个设计、协作构件之间的依赖关系、责任分配和控制流程，表现为一组抽象类以及其实例之间协作的方法，它为构件复用提供了上下文(Context)关系。因此构件库的大规模重用也需要框架。
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/cr7gm9/1616163790618-a4887423-a11b-4cfa-be93-a852be8c838f.jpeg" alt="">
拓展资料：
框架（Framework）是整个或部分系统的可重用设计，表现为一组抽象构件及构件实例间交互的方法;另一种定义认为，框架是可被应用开发者定制的应用骨架。前者是从应用方面而后者是从目的方面给出的定义。&lt;/p>
&lt;h2 id="例子">例子&lt;/h2>
&lt;p>拿 go 语言举例，当获取完一个第三方库之后(比如通过 go get 命令安装)，有时候会有一个命令行工具，比如 cobra，所以，也可以把库当做一个应用程序。而大部分时候，是不会出现一个命令行工具的，在获取完库之后，需要在 import 代码中进行引用，即可使用库中的相关函数。&lt;/p></description></item><item><title>Docs: 多媒体处理工具</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/11_%E5%A4%9A%E5%AA%92%E4%BD%93/%E5%A4%9A%E5%AA%92%E4%BD%93%E5%A4%84%E7%90%86%E5%B7%A5%E5%85%B7/%E5%A4%9A%E5%AA%92%E4%BD%93%E5%A4%84%E7%90%86%E5%B7%A5%E5%85%B7/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/11_%E5%A4%9A%E5%AA%92%E4%BD%93/%E5%A4%9A%E5%AA%92%E4%BD%93%E5%A4%84%E7%90%86%E5%B7%A5%E5%85%B7/%E5%A4%9A%E5%AA%92%E4%BD%93%E5%A4%84%E7%90%86%E5%B7%A5%E5%85%B7/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://zhuanlan.zhihu.com/p/138863913">知乎，视频录制、视频剪辑、字幕制作&amp;hellip;&amp;hellip;当一名 UP 主需要哪些软件&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>视频录制&lt;/p>
&lt;ul>
&lt;li>OBS Studio&lt;/li>
&lt;/ul>
&lt;p>视频剪辑&lt;/p>
&lt;ul>
&lt;li>Premiere&lt;/li>
&lt;li>Shotcut&lt;/li>
&lt;li>必剪 # B 站的&lt;/li>
&lt;/ul>
&lt;p>字幕制作&lt;/p>
&lt;ul>
&lt;li>听见字幕&lt;/li>
&lt;/ul>
&lt;h1 id="obs-studio">OBS Studio&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://github.com/obsproject/obs-studio">GitHub 项目，obsproject/obs-studio&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://obsproject.com/">官网&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>&lt;strong>Open Broadcaster Software(开放广播软件，简称 OBS)&lt;/strong> 是一款用于视频录制和直播的免费和开源软件&lt;/p>
&lt;h1 id="shotcut">Shotcut&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://github.com/mltframework/shotcut">GitHub 项目，mltframework/shotcut&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://shotcut.org/">官网&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>导出视频：https://jingyan.baidu.com/article/86f4a73e2716ee77d752695a.html&lt;/p>
&lt;h1 id="音频处理">音频处理&lt;/h1>
&lt;h2 id="buzz">Buzz&lt;/h2>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://github.com/chidiwilliams/buzz">GitHub 项目，chidiwilliams/buzz&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.bilibili.com/video/BV1sG411N7RS">B 站，真正的最强字幕神器，离线语音转文字，一键搞定！&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>Buzz 可以在我们的个人计算机上离线转录和翻译音频。由 OpenAI 的 Whisper 提供支持。&lt;/p>
&lt;h1 id="图片处理">图片处理&lt;/h1>
&lt;h2 id="photopea">Photopea&lt;/h2>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://github.com/photopea/photopea">GitHub 项目，photopea/photopea&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.photopea.com/">官网&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>在线图片编辑工具&lt;/p>
&lt;h2 id="photodemon">PhotoDemon&lt;/h2>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://github.com/tannerhelland/PhotoDemon">GitHub 项目，tannerhelland/PhotoDemon&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://photodemon.org/">官网&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>小巧玲珑的图片编辑工具&lt;/p>
&lt;p>图片处理工具&lt;/p>
&lt;h2 id="其他">其他&lt;/h2>
&lt;p>&lt;a href="https://github.com/Sanster/lama-cleaner">Lama Cleaner&lt;/a> # 基于 SOTA AI 模型构建的开源图片处理工具&lt;/p></description></item><item><title>Docs: 访问虚拟机</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/10.%E4%BA%91%E5%8E%9F%E7%94%9F/1.2.%E5%AE%9E%E7%8E%B0%E8%99%9A%E6%8B%9F%E5%8C%96%E7%9A%84%E5%B7%A5%E5%85%B7/kvm_qemu/%E8%AE%BF%E9%97%AE%E8%99%9A%E6%8B%9F%E6%9C%BA/%E8%AE%BF%E9%97%AE%E8%99%9A%E6%8B%9F%E6%9C%BA/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/10.%E4%BA%91%E5%8E%9F%E7%94%9F/1.2.%E5%AE%9E%E7%8E%B0%E8%99%9A%E6%8B%9F%E5%8C%96%E7%9A%84%E5%B7%A5%E5%85%B7/kvm_qemu/%E8%AE%BF%E9%97%AE%E8%99%9A%E6%8B%9F%E6%9C%BA/%E8%AE%BF%E9%97%AE%E8%99%9A%E6%8B%9F%E6%9C%BA/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/8/html/configuring_and_managing_virtualization/getting-started-with-virtualization-in-rhel-8_configuring-and-managing-virtualization#assembly_connecting-to-virtual-machines_virt-getting-started">RedHat 官方文档，8-配置和管理虚拟化-2.4 章.连接到虚拟机&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>我们可以通过多种方式与虚拟机进行交互：&lt;/p>
&lt;ul>
&lt;li>Cockpit # 基于 Web 的控制台&lt;/li>
&lt;li>Virt Manager 程序 # GUI 程序&lt;/li>
&lt;li>Virt Viewer 程序 # GUI 程序&lt;/li>
&lt;li>virsh console 子命令 # CLI 程序&lt;/li>
&lt;li>众所周知的 ssh&lt;/li>
&lt;/ul>
&lt;h1 id="cockpit">Cockpit&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://github.com/cockpit-project">GitHub 项目，cockpit-project&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://cockpit-project.org/">官网&lt;/a>&lt;/li>
&lt;li>注意：
&lt;ul>
&lt;li>RHEL 8 仍支持虚拟机管理器（virt-manager）应用程序，但已弃用。Web 控制台打算在后续版本中替代它。因此，建议您熟悉用于在 GUI 中管理虚拟化的 Web 控制台。详见：&lt;a href="https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/8/html-single/configuring_and_managing_virtualization/index#overview-of-virtual-machine-management-using-the-web-console_using-the-rhel-8-web-console-for-managing-vms">https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/8/html-single/configuring_and_managing_virtualization/index#overview-of-virtual-machine-management-using-the-web-console_using-the-rhel-8-web-console-for-managing-vms&lt;/a>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>Cockpit 是一个基于 Web 的用于管理服务器的图形界面&lt;/p>
&lt;h2 id="安装-cockpit">安装 Cockpit&lt;/h2>
&lt;p>CentOS&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>yum install cockpit -y &lt;span style="color:#f92672">&amp;amp;&amp;amp;&lt;/span> yum install cockpit-machines -y
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>systemctl start cockpit &lt;span style="color:#f92672">&amp;amp;&amp;amp;&lt;/span> systemctl enable cockpit
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Ubuntu&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>apt update
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>apt install -y cockpit cockpit-machines
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>其中 cockpit-machines 是 cockpit 的插件，用于为 cockpit 添加虚拟机管理功能。&lt;/p>
&lt;h2 id="使用-cockpit">使用 Cockpit&lt;/h2>
&lt;p>Cockpit 开箱即用，安装完成后直接访问 http://IP:9090，打开 web 界面，使用系统的用户和密码登陆即可。web 页面管理虚拟机，效果如图&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/pn75i9/1616123978493-8d5e61ed-edc9-4962-8cb1-391f17c883ff.jpeg" alt="">
&lt;a href="https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/8/html-single/configuring_and_managing_virtualization/index#overview-of-virtual-machine-management-using-the-web-console_using-the-rhel-8-web-console-for-managing-vms">
&lt;/a>&lt;/p>
&lt;h1 id="使用虚拟机的串行控制台">使用虚拟机的串行控制台&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/8/html/configuring_and_managing_virtualization/getting-started-with-virtualization-in-rhel-8_configuring-and-managing-virtualization#proc_opening-a-virtual-machine-serial-console_assembly_connecting-to-virtual-machines">红帽官方文档，8-2.配置和管理虚拟化-2.4.4.打开虚拟机串行控制台&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>使用 virsh console 命令，可以连接到虚拟机的串行控制台。&lt;/p>
&lt;p>有两种方法可以开启虚拟机内的串行控制台&lt;/p>
&lt;p>方法一：修改 grub 参数&lt;/p>
&lt;p>在虚拟机上，编辑 &lt;code>/etc/default/grub&lt;/code> 文件并将 &lt;strong>console=ttyS0&lt;/strong> 添加到以 &lt;strong>GRUB_CMDLINE_LINUX&lt;/strong> 开头的行中。&lt;/p>
&lt;p>清除可能会阻止您更改生效的内核选项。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># grub2-editenv - unset kernelopts&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>重新载入 Grub 配置：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># grub2-mkconfig -o /boot/grub2/grub.cfg&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Generating grub configuration file ...
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Found linux image: /boot/vmlinuz-3.10.0-948.el7.x86_64
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Found initrd image: /boot/initramfs-3.10.0-948.el7.x86_64.img
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">[&lt;/span>...&lt;span style="color:#f92672">]&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">done&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>重启虚拟机。&lt;/p>
&lt;p>方法二：启动 serial-getty 服务&lt;/p>
&lt;p>在虚拟机上启动 serial-getty@.service 服务并在开启服务的时候指定一个终端。执行如下命令即可：&lt;code>systemctl enable serial-getty@ttyS0.service --now&lt;/code>&lt;/p>
&lt;h1 id="访问远程虚拟化主机">访问远程虚拟化主机&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/8/html/configuring_and_managing_virtualization/getting-started-with-virtualization-in-rhel-8_configuring-and-managing-virtualization#setting-up-easy-access-to-remote-virtualization-hosts_assembly_connecting-to-virtual-machines">红帽官方文档，8-配置和管理虚拟化-第二章.虚拟化入门-2.4.5.设置对远程虚拟化主机的轻松访问&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>当我们想要使用 libvirt 程序管理远程主机上的 VM 时，可以使用 &lt;code>-c qemu+ssh://root@HOST/system&lt;/code> 语法管理远程宿主机上的虚拟机。效果如下：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>~&lt;span style="color:#f92672">]&lt;/span>&lt;span style="color:#75715e"># virsh -c qemu+ssh://root@172.19.42.201/system list&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>root@172.19.42.201&lt;span style="color:#960050;background-color:#1e0010">&amp;#39;&lt;/span>s password:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Id Name State
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>----------------------------------------------------
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ae81ff">1&lt;/span> node-1.bj-net running
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;a href="https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/8/html/configuring_and_managing_virtualization/getting-started-with-virtualization-in-rhel-8_configuring-and-managing-virtualization#setting-up-easy-access-to-remote-virtualization-hosts_assembly_connecting-to-virtual-machines">https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/8/html/configuring_and_managing_virtualization/getting-started-with-virtualization-in-rhel-8_configuring-and-managing-virtualization#setting-up-easy-access-to-remote-virtualization-hosts_assembly_connecting-to-virtual-machines&lt;/a>&lt;/p></description></item><item><title>Docs: 解谜计算机科学</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/2.%E7%BC%96%E7%A8%8B/%E8%A7%A3%E8%B0%9C%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E8%A7%A3%E8%B0%9C%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/2.%E7%BC%96%E7%A8%8B/%E8%A7%A3%E8%B0%9C%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E8%A7%A3%E8%B0%9C%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="http://www.yinwang.org/blog-cn/2018/04/13/computer-science">王垠博客，解谜计算机科学&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Category:Computer_science">Wiki 分类，Computer science(计算机科学)&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Category:Computer_programming">Wiki 分类，Computer programming(计算机编程)&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Category:Programming_language_concepts">Wiki 分类，Programming language concepts(编程语言概念)&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Category:Programming_constructs">Wiki 分类，Programming constructs(编程结构)&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Category:Programming_languages">Wiki 分类，Programming languages(编程语言)&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Category:Programming_paradigms">Wiki 分类，Programming paradigms(编程范式)&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Identifier_(computer_languages)">Wiki,Identifier(标识符)&lt;/a>
&lt;ul>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Symbol">Wiki,Symbol(符号)&lt;/a>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Data_type">Wiki,DataType&lt;/a>(数据类型)&lt;/li>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Variable_(computer_science)">Wiki,Variables&lt;/a>(变量)&lt;/li>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Assignment_(computer_science)">Wiki,Assignment&lt;/a>(赋值)&lt;/li>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Declaration_(computer_programming)">Wiki,Declaration(声明) 与 Definition(定义)&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>要掌握一个学科的精髓，不能从细枝末节开始。人脑的能力很大程度上受限于信念。一个人不相信自己的时候，他就做不到本来可能的事。信心是很重要的，信心却容易被挫败。如果只见树木不见森林，人会失去信心，以为要到猴年马月才能掌握一个学科。&lt;/p>
&lt;p>所以我们不从 “树木” 开始，而是引导读者一起来探索这背后的“森林”，把计算机科学最根本的概念用浅显的例子解释，让读者领会到它们的本质。把这些概念稍作发展，你就得到逐渐完整的把握。你一开头就掌握着整个学科，而且一直掌握着它，只不过增添更多细节而已。这就像画画，先勾勒出轮廓，一遍遍的增加细节，日臻完善，却不失去对大局的把握。&lt;/p>
&lt;p>一般计算机专业的学生学了很多课程，可是直到毕业都没能回答一个基础问题：什么是计算？这一章会引导你去发现这个问题的答案。不要小看这基础的问题，它经常是解决现实问题的重要线索。世界上有太多不理解它的人，他们走了很多的弯路，掉进很多的坑，制造出过度复杂或者有漏洞的理论和技术。&lt;/p>
&lt;p>接下来，我们就来理解几个关键的概念，由此接触到计算的本质。&lt;/p>
&lt;h2 id="手指算术">手指算术&lt;/h2>
&lt;p>每个人都做过计算，只是大部分人都没有理解自己在做什么。回想一下幼儿园（大概四岁）的时候，妈妈问你：“帮我算一下，4+3 等于几？” 你掰了一会手指，回答：7。当你掰手指的时候，你自己就是一台简单的计算机。&lt;/p>
&lt;p>不要小看了这手指算术，它蕴含着深刻的原理。计算机科学植根于这类非常简单的过程，而不是复杂的高等数学。&lt;/p>
&lt;p>现在我们来回忆一下这个过程。这里应该有一段动画，但现阶段还没有。请你对每一步发挥一下想象力，增加点 “画面感”。&lt;/p>
&lt;ol>
&lt;li>当妈妈问你 “4+3 等于几” 的时候，她是一个程序员，你是一台计算机。计算机得到程序员的输入：4，+，3。&lt;/li>
&lt;li>听到妈妈的问题之后，你拿出两只手，左手伸出四个指头，右手伸出三个指头。&lt;/li>
&lt;li>接着你开始自己的计算过程。一根根地数那些竖起来的手指，每数一根你就把它弯下去，表示它已经被数过了。你念道：“1，2，3，4，5，6，7。”&lt;/li>
&lt;li>现在已经没有手指伸着，所以你把最后数到的那个数作为答案：7！整个计算过程就结束了。&lt;/li>
&lt;/ol>
&lt;h2 id="identifier标识符-和-model模型">Identifier(标识符) 和 Model(模型)&lt;/h2>
&lt;p>这里的幼儿园手指算术包含着深刻的哲学问题，现在我们来初步体会一下这个问题。&lt;/p>
&lt;p>当妈妈说 “帮我算 4+3” 的时候，4，+，3，三个字符传到你耳朵里，它们都是 &lt;strong>Identifier(标识符)&lt;/strong>，有的时候也称为 &lt;strong>symbol(符号)&lt;/strong>。符号是 “表面” 的东西：光是盯着 “4” 和“3”这两个阿拉伯数字的曲线，一个像旗子，一个像耳朵，你是不能做什么的。你需要先用脑子把它们转换成对应的“模型”（model）。这就是为什么你伸出两只手，一只手表示 4，另一只表示 3。&lt;/p>
&lt;p>这两只手的手势是 “可操作” 的。比如，你把左手再多弯曲一个手指，它就变成 “3”。你再伸开一根手指，它就变成“5”。所以手指是一个相当好的机械模型，它是可以动，可操作的。把符号“4” 和“3”转换成手指模型之后，你就可以开始计算了。&lt;/p>
&lt;p>你怎么知道 “4” 和“3”对应什么样的手指模型呢？因为妈妈以前教过你。十根手指，对应着 1 到 10 十个数。这就是为什么人都用十进制数做算术。&lt;/p>
&lt;p>我们现在没必要深究这个问题。我只是提示你，分清 “符号” 和“模型”是重要的。&lt;/p>
&lt;h2 id="计算图">计算图&lt;/h2>
&lt;p>在计算机领域，我们经常用一些抽象的图示来表达计算的过程，这样就能直观地看到信息的流动和转换。这种图示看起来是一些形状用箭头连接起来。我在这里把它叫做 “计算图”。&lt;/p>
&lt;p>对于以上的手指算术 &lt;code>4 + 3&lt;/code>，我们可以用下图来表示它：&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/85e3436b-9762-45b3-b0bb-38c1f87e416d/adder.png" alt="">&lt;/p>
&lt;p>图中的箭头表示信息的流动方向。说到 “流动”，你可以想象一下水的流动。首先我们看到数字 4 和 3 流进了一个圆圈，圆圈里有一个“+” 号。这个圆圈就是你，一个会做手指加法的小孩。妈妈给你两个数 4 和 3，你现在把它们加起来，得到 7 作为结果。&lt;/p>
&lt;p>注意圆圈的输入和输出方向是由箭头决定的，我们可以根据需要调整那些箭头的位置，只要箭头的连接关系和方向不变就行。它们不一定都是从左到右，也可能从右到左或者从上到下，但 “出入关系” 都一样：4 和 3 进去，结果 7 出来。比如它还可以是这样：&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/85e3436b-9762-45b3-b0bb-38c1f87e416d/adder-topdown.png" alt="">&lt;/p>
&lt;p>我们用带加号的圆圈表示一个 “加法器”。顾名思义，加法器可以帮我们完成加法。在上个例子里，你就是一个加法器。我们也可以用其他装置作为加法器，比如一堆石头，一个算盘，某种电子线路…… 只要它能做加法就行。&lt;/p>
&lt;p>具体要怎么做加法，就像你具体如何掰手指，很多时候我们是不关心的，我们只需要知道这个东西能做加法就行。圆圈把具体的加法操作给 “抽象化” 了，这个蓝色的圆圈可以代表很多种东西。抽象（abstraction）是计算机科学至关重要的思维方法，它帮助我们进行高层面的思考，而不为细节所累。&lt;/p>
&lt;h2 id="expression表达式">Expression(表达式)&lt;/h2>
&lt;p>计算机科学当然不止 4 + 3 这么简单，但它的基本元素确实是如此简单。我们可以创造出很复杂的系统，然而归根结底，它们只是在按某种顺序计算像 4 + 3 这样的东西。&lt;/p>
&lt;p>4 + 3 是一个很简单的表达式（expression）。你也许没听说过 “表达式” 这个词，但我们先不去定义它。我们先来看一个稍微复杂一些的表达式：&lt;/p>
&lt;p>这个表达式比 &lt;code>4 + 3&lt;/code> 多了一个运算，我们把它叫做 “复合表达式”。这个表达式也可以用计算图来表示：&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/85e3436b-9762-45b3-b0bb-38c1f87e416d/add-mult.png" alt="">&lt;/p>
&lt;p>你知道它为什么是这个样子吗？它表示的意思是，先计算 &lt;code>4 + 3&lt;/code>，然后把结果（7）传送到一个 “乘法器”，跟 2 相乘，得到最后的结果。那正好就是 &lt;code>2 * (4 + 3)&lt;/code> 这个表达式的含义，它的结果应该是 14。&lt;/p>
&lt;p>为什么要先计算 &lt;code>4 + 3&lt;/code> 呢？因为当我们看到乘法器 &lt;code>2 * ...&lt;/code> 的时候，其中一个输入（2）是已知的，而另外一个输入必须通过加法器的输出得到。加法器的结果是由 4 和 3 相加得到的，所以我们必须先计算 &lt;code>4 + 3&lt;/code>，然后才能与 2 相乘。&lt;/p>
&lt;p>小学的时候，你也许学过：“括号内的内容要先计算”。其实括号只是 “符号层” 的东西，它并不存在于计算图里面。我这里讲的“计算图”，其实才是本质的东西。数学的括号一类的东西，都只是表象，它们是符号或者叫“语法”。从某种意义上讲，计算图才是表达式的本质或者“模型”，而“2 * (4 + 3)” 这串符号，只是对计算图的一种表示或者 “编码”（coding）。&lt;/p>
&lt;p>这里我们再次体会到了 “符号” 和“模型”的差别。符号是对模型的 “表示” 或者“编码”。我们必须从符号得到模型，才能进行操作。这种从符号到模型的转换过程，在计算机科学里叫做“语法分析”（parsing）。我们会在后面的章节理解这个过程。&lt;/p>
&lt;p>我们现在来给表达式做一个初步的定义。这并不是完整的定义，但你应该试着理解这种定义的方式。稍后我们会逐渐补充这个定义，逐渐完善。&lt;/p>
&lt;p>定义（表达式）：&lt;strong>表达式&lt;/strong>可以是如下几种东西。&lt;/p>
&lt;ol>
&lt;li>数字是一个表达式。比如 1，2，4，15，……&lt;/li>
&lt;li>表达式 + 表达式。两个表达式相加，也是表达式。&lt;/li>
&lt;li>表达式 - 表达式。两个表达式相减，也是表达式。&lt;/li>
&lt;li>表达式 * 表达式。两个表达式相乘，也是表达式。&lt;/li>
&lt;li>表达式 / 表达式。两个表达式相除，也是表达式。&lt;/li>
&lt;/ol>
&lt;p>注意，由于我们之前讲过的符号和模型的差别，为了完全忠于我们的本质认识，这里的 “表达式 + 表达式” 虽然看起来是一串符号，它必须被想象成它所对应的模型。当你看到 “表达式” 的时候，你的脑子里应该浮现出它对应的计算图，而不是一串符号。这个计算图的画面大概是这个样子，其中左边的大方框里可以是任意两个表达式。&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/85e3436b-9762-45b3-b0bb-38c1f87e416d/expression-graph.png" alt="">&lt;/p>
&lt;p>是不是感觉这个定义有点奇怪？因为在 “表达式” 的定义里，我们用到了 “表达式” 自己。这种定义叫做“递归定义”。所谓&lt;strong>递归&lt;/strong>（recursion），就是在一个东西的定义里引用这个东西自己。看上去很奇怪，好像绕回去了一样。递归是一个重要的概念，我们会在将来深入理解它。&lt;/p>
&lt;p>现在我们可以来验证一下，根据我们的定义，&lt;code>2 * (4 + 3)&lt;/code> 确实是一个表达式：&lt;/p>
&lt;ul>
&lt;li>首先根据第一种形式，我们知道 4 是表达式，因为它是一个数字。3 也是表达式，因为它是一个数字。&lt;/li>
&lt;li>所以 &lt;code>4 + 3&lt;/code> 是表达式，因为 &lt;code>+&lt;/code> 的左右都是表达式，它满足表达式定义的第二种形式。&lt;/li>
&lt;li>所以 &lt;code>2 * (4 + 3)&lt;/code> 是表达式，因为 &lt;code>*&lt;/code> 的左右都是表达式，它满足表达式定义的第四种形式。&lt;/li>
&lt;/ul>
&lt;h2 id="parallel-computing并行计算">Parallel Computing(并行计算)&lt;/h2>
&lt;p>考虑这样一个表达式：&lt;/p>
&lt;pre>&lt;code>(4 + 3) * (1 + 2)
&lt;/code>&lt;/pre>
&lt;p>它对应一个什么样的计算图呢？大概是这样：
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/85e3436b-9762-45b3-b0bb-38c1f87e416d/parallel.png" alt="">
如果妈妈只有你一个小孩，你应该如何用手指算出它的结果呢？你大概有两种办法。&lt;/p>
&lt;p>第一种办法：先算出 4+3，结果是 7。然后算出 1+2，结果是 3。然后算 7*3，结果是 21。&lt;/p>
&lt;p>第二种办法：先算出 1+2，结果是 3。然后算出 4+3，结果是 7。然后算 7*3，结果是 21。&lt;/p>
&lt;p>注意到没有，你要么先算 4+3，要么先算 1+2，你不能同时算 4+3 和 1+2。为什么呢？因为你只有两只手，所以算 4+3 的时候你就没法算 1+2，反之也是这样。总之，你妈妈只有你一个加法器，所以一次只能做一个加法。&lt;/p>
&lt;p>现在假设你还有一个妹妹，她跟你差不多年纪，她也会手指算术。妈妈现在就多了一些办法来计算这个表达式。她可以这样做：让你算 4+3，不等你算完，马上让妹妹算 1+2。等到你们的结果（7 和 3）都出来之后，让你或者妹妹算 7*3。&lt;/p>
&lt;p>发现没有，在某一段时间之内，你和妹妹_同时_在做加法计算。这种时间上重叠的计算，叫做&lt;strong>并行计算&lt;/strong>（parallel computing）。&lt;/p>
&lt;p>你和妹妹同时计算，得到结果的速度可能会比你一个人算更快。如果你妈妈还有其它几个孩子，计算复杂的式子就可能快很多，这就是并行计算潜在的好处。所谓 “潜在” 的意思是，这种好处不一定会实现。比如，如果你的妹妹做手指算数的速度比你慢很多，你做完了 4+3，只好等着她慢慢的算 1+2。这也许比你自己依次算 4+3 和 1+2 还要慢。&lt;/p>
&lt;p>即使妹妹做算术跟你一样快，这里还有个问题。你和妹妹算出结果 7 和 3 之后，得把结果传递给下一个计算 7*3 的那个人（也许是你，也许是你妹妹）。这种 “通信” 会带来时间的延迟，叫做“通信开销”。如果你们其中一个说话慢，这比起一个人来做计算可能还要慢。&lt;/p>
&lt;p>如何根据计算单元能力的不同和通信开销的差异，来最大化计算的效率，降低需要的时间，就成为了并行计算领域研究的内容。并行计算虽然看起来是一个 “博大精深” 的领域，可是你如果理解了我这里说的那点东西，就很容易理解其余的内容。&lt;/p>
&lt;h2 id="variable变量-和-assignment赋值">Variable(变量) 和 Assignment(赋值)&lt;/h2>
&lt;p>变量是与关联的&lt;strong>符号名称(变量的标识符)&lt;/strong> 配对的&lt;strong>存储位置(由内存地址标识)&lt;/strong>。这个&lt;strong>存储地址&lt;/strong>其包含称为&lt;strong>值&lt;/strong>的一些已知或未知数量的信息;变量的&lt;strong>存储地址&lt;/strong>是通过一个名叫&lt;strong>指针&lt;/strong>的东西来获取，也是&lt;strong>值&lt;/strong>的一种，指针的&lt;strong>值&lt;/strong>就是其所指向的变量的&lt;strong>存储地址&lt;/strong>；注意：变量的&lt;strong>存储地址的值&lt;/strong>与&lt;strong>存储地址中包含的值&lt;/strong>是两个不同的东西。指针与变量的代码示例&lt;/p>
&lt;p>变量是一个可以改变内容的固定标识符，比如我定义“这台电脑的名字”叫“XXX”，“这台电脑的名字”就是标识符(不变的内容)，存在于计算机的某个位置，“XXX”就是可以改变的内容 i.e.变量的值，给不变的内容定义不同的内容&lt;/p>
&lt;ul>
&lt;li>比如 X=1，X=2，X=3 等等，&lt;strong>X&lt;/strong> 就是不变的，1，2，3 等等都是可变的，X 就是一个变量，可以被赋予某些内容&lt;/li>
&lt;li>比如：&lt;strong>LANG&lt;/strong> 是一个语言的规定，你赋予他一个内容，就相当于定义了这个环境下所显示的语言，比如 LANG=US，LANG=CN 等等。LANG 这叫定义语言，这是不变的，可变的是后面的自定义内容，语言（不变）= 英语，汉语，日语（可变）。&lt;/li>
&lt;/ul>
&lt;p>如果你有一个复杂的表达式，比如&lt;/p>
&lt;pre>&lt;code>(5 - 3) * (4 + (2 * 3 - 5) * 6)
&lt;/code>&lt;/pre>
&lt;p>由于它有比较多的嵌套，人的眼睛是难以看清楚的，它要表达的意义也会难懂。这时候，你希望可以用一些 “名字” 来代表中间结果，这样表达式就更容易理解。&lt;/p>
&lt;p>打个比方，这就像你有一个亲戚，他是你妈妈的表姐的女儿的丈夫。你不想每次都称他 “我妈妈的表姐的女儿的丈夫”，所以你就用他的名字“叮当” 来指代他，一下子就简单了。&lt;/p>
&lt;p>我们来看一个例子。之前的复合表达式&lt;/p>
&lt;p>其实可以被转换为等价的，含有变量的代码：&lt;/p>
&lt;pre>&lt;code>{
a = 4 + 3 // 变量 a 得到 4+3 的值
2 * a // 代码块的值
}
&lt;/code>&lt;/pre>
&lt;p>其中 &lt;code>a&lt;/code> 是一个名字。&lt;code>a = 4 + 3&lt;/code> 是一个 “赋值语句”，它的意思是：用 a 来代表 4 + 3 的值。这种名字，计算机术语叫做 &lt;strong>variable(变量)&lt;/strong>。&lt;/p>
&lt;p>这段代码的意思可以简单地描述为：计算 &lt;code>4 + 3&lt;/code>，把它的结果表示为 &lt;code>a&lt;/code>，然后计算 &lt;code>2 * a&lt;/code> 作为最后的结果。&lt;/p>
&lt;p>有些东西可能扰乱了你的视线。两根斜杠 &lt;code>//&lt;/code> 后面一直到行末的文字叫做 “注释”，是给人看的说明文字。它们对代码的逻辑不产生作用，执行的时候可以忽略。许多语言都有类似这种注释，它们可以帮助阅读的人，但是会被机器忽略。&lt;/p>
&lt;p>这段代码执行过程会是这样：先计算 &lt;code>4 + 3&lt;/code> 得到 7，用 &lt;code>a&lt;/code> 记住这个中间结果 7。接着计算 &lt;code>2 * a&lt;/code> ，也就是计算 &lt;code>2 * 7&lt;/code>，所以最后结果是 14。很显然，这跟 &lt;code>2 * (4 + 3)&lt;/code> 的结果是一样的。&lt;/p>
&lt;p>&lt;code>a&lt;/code> 叫做一个变量，它是一个符号，可以用来代表任意的值。除了 &lt;code>a&lt;/code>，你还有许多的选择，比如 b, c, d, x, y, foo, bar, u21… 只要它不会被误解成其它东西就行。&lt;/p>
&lt;p>如果你觉得这里面的 “神奇” 成分太多，那我们现在来做更深一层的理解……&lt;/p>
&lt;p>再看一遍上面的代码。这整片代码叫做一个 “代码块”（block），或者叫一个 “序列”（sequence）。这个代码块包括两条语句，分别是 &lt;code>a = 4 + 3&lt;/code> 和 &lt;code>2 * a&lt;/code>。代码块里的语句会从上到下依次执行。所以我们先执行 &lt;code>a = 4 + 3&lt;/code>，然后执行 &lt;code>2 * a&lt;/code>。&lt;/p>
&lt;p>最后一条语句 &lt;code>2 * a&lt;/code> 比较特别，它是这个代码块的 “值”，也就是最后结果。之前的语句都是在为生成这个最后的值做准备。换句话说，这整个代码块的值就是 &lt;code>2 * a&lt;/code> 的值。不光这个例子是这样，这是一个通用的原理：代码块的最后一条语句，总是这个代码块的值。&lt;/p>
&lt;p>我们在代码块的前后加上花括号 &lt;code>{...}&lt;/code> 进行标注，这样里面的语句就不会跟外面的代码混在一起。这两个花括号叫做 “边界符”。我们今后会经常遇到代码块，它存在于几乎所有的程序语言里，只是语法稍有不同。比如有些语言可能用括号 &lt;code>(...)&lt;/code> 或者 &lt;code>BEGIN...END&lt;/code> 来表示边界，而不是用花括号。&lt;/p>
&lt;p>这片代码已经有点像常用的编程语言了，但我们暂时不把它具体化到某一种语言。我不想固化你的思维方式。在稍后的章节，我们会把这种抽象的表达法对应到几种常见的语言，这样一来你就能理解几乎所有的程序语言。&lt;/p>
&lt;p>另外还有一点需要注意，同一个变量可以被多次赋值。它的值会随着赋值语句而改变。举个例子：&lt;/p>
&lt;pre>&lt;code>{
a = 4 + 3
b = a
a = 2 * 5
c = a
}
&lt;/code>&lt;/pre>
&lt;p>这段代码执行之后，&lt;code>b&lt;/code> 的值是 7，而 &lt;code>c&lt;/code> 的值是 10。你知道为什么吗？因为 &lt;code>a = 4 + 3&lt;/code> 之后，a 的值是 7。&lt;code>b = a&lt;/code> 使得 &lt;code>b&lt;/code> 得到值 7。然后 &lt;code>a = 2 * 5&lt;/code> 把 &lt;code>a&lt;/code> 的值改变了，它现在是 10。所以 &lt;code>c = a&lt;/code> 使得 &lt;code>c&lt;/code> 得到 10。&lt;/p>
&lt;p>对同一个变量多次赋值虽然是可以的，但通常来说这不是一种好的写法，它可能引起程序的混淆，应该尽量避免。只有当变量表示的 “意义” 相同的时候，你才应该对它重复赋值。&lt;/p>
&lt;h2 id="data-type数据类型">Data type(数据类型)&lt;/h2>
&lt;p>**Data Type(数据类型) **用来对一组相关值进行分类，描述可对其执行的操作并定义它们的存储方式。通常也会称为 &lt;strong>Literal(字面量)&lt;/strong>&lt;/p>
&lt;h2 id="compile编译">Compile(编译)&lt;/h2>
&lt;p>一旦引入了变量，我们就可以不用复合表达式。因为你可以把任意复杂的复合表达式拆开成 “单操作算术表达式”（像 4 + 3 这样的），使用一些变量记住中间结果，一步一步算下去，得到最后的结果。&lt;/p>
&lt;p>举一个复杂点的例子，也就是这一节最开头的那个表达式：&lt;/p>
&lt;pre>&lt;code>(5 - 3) * (4 + (2 * 3 - 5) * 6)
&lt;/code>&lt;/pre>
&lt;p>它可以被转化为一串语句：&lt;/p>
&lt;pre>&lt;code>{
a = 2 * 3
b = a - 5
c = b * 6
d = 4 + c
e = 5 - 3
e * d
}
&lt;/code>&lt;/pre>
&lt;p>最后的表达式 &lt;code>e * d&lt;/code>，算出来就是原来的表达式的值。你观察一下，是不是每个操作都非常简单，不包含嵌套的复合表达式？你可以自己验算一下，它确实算出跟原表达式一样的结果。&lt;/p>
&lt;p>在这里，我们自己动手做了 &lt;strong>compiler(编译器)&lt;/strong> 的工作。通常来说，编译器是一种程序，它的任务是把一片代码“翻译” 成另外一种等价形式。这里我们没有写编译器，可是我们自己做了编译器的工作。我们手动地把一个嵌套的复合表达式，编译成了一系列的简单算术语句。&lt;/p>
&lt;p>这些语句的结果与原来的表达式完全一致。这种保留原来语义的翻译过程，叫做 &lt;strong>compile(编译)&lt;/strong>。&lt;/p>
&lt;p>我们为什么需要编译呢？原因有好几种。我不想在这里做完整的解释，但从这个例子我们可以看到，编译之后我们就不再需要复杂的嵌套表达式了。我们只需要设计很简单的，只会做单操作算术的机器，就可以算出复杂的嵌套的表达式。实际上最后这段代码已经非常接近现代处理器（CPU）的汇编代码（assembly）。我们只需要多加一些转换，它就可以变成机器指令。&lt;/p>
&lt;p>我们暂时不写编译器，因为你还缺少一些必要的知识。这当然也不是编译技术的所有内容，它还包含另外一些东西。但从这一开头，你就已经初步理解了编译器是什么，你只需要在将来加深这种理解。&lt;/p>
&lt;h2 id="function函数">Function(函数)&lt;/h2>
&lt;p>到目前为止，我们做的计算都是在已知的数字之上，而在现实的计算中我们往往有一些未知数。比如我们想要表达一个 “风扇控制器”，有了它之后，风扇的转速总是当前气温的两倍。这个“当前气温” 就是一个未知数。&lt;/p>
&lt;p>我们的 “风扇控制器” 必须要有一个“输入”（input），用于得到当前的温度 t，它是一个温度传感器的读数。它还要有一个输出，就是温度的两倍。&lt;/p>
&lt;p>那么我们可以用这样的方式来表达我们的风扇控制器：&lt;/p>
&lt;p>不要把这想成任何一种程序语言，这只是我们自己的表达法。箭头 &lt;code>-&amp;gt;&lt;/code> 的左边表示输入，右边表示输出，够简单吧。&lt;/p>
&lt;p>你可以把 &lt;code>t&lt;/code> 想象成从温度传感器出来的一根电线，它连接到风扇控制器上，风扇控制器会把它的输入（t）乘以 2。这个画面像这个样子：
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/85e3436b-9762-45b3-b0bb-38c1f87e416d/function1.png" alt="">
我们谈论风扇控制器的时候，其实不关心它的输入是哪里来的，输出到哪里去。如果我们把温度传感器和风扇从画面里拿掉，就变成这个样子：
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/85e3436b-9762-45b3-b0bb-38c1f87e416d/function2.jpg" alt="">
这幅图才是你需要认真理解的函数的计算图。你发现了吗，这幅图画正好对应了之前的风扇控制器的符号表示：&lt;code>t -&amp;gt; t*2&lt;/code>。看到符号就想象出画面，你就得到了符号背后的模型。&lt;/p>
&lt;p>像 &lt;code>t -&amp;gt; t*2&lt;/code> 这样具有未知数作为输入的构造，我们把它叫做 function(函数)。其中 &lt;code>t&lt;/code> 这个符号，叫做这个函数的参数。&lt;/p>
&lt;h2 id="parameter参数-与-variable变量">Parameter(参数) 与 Variable(变量)&lt;/h2>
&lt;p>你可能发现了，函数的参数和我们之前了解的 “变量” 是很类似的，它们都是一个符号。之前我们用了 &lt;code>a, b, c, d, e&lt;/code> 现在我们有一个 &lt;code>t&lt;/code>，这些名字我们都是随便起的，只要它们不要重复就好。如果名字重复的话，可能会带来混淆和干扰。&lt;/p>
&lt;p>其实参数和变量这两种概念不只是相似，它们的本质就是一样的。如果你深刻理解它们的相同本质，你的脑子就可以少记忆很多东西，而且它可能帮助你对代码做出一些有趣而有益的转化。在上一节你已经看到，我用 “电线” 作为比方来帮助你理解参数。你也可以用同样的方法来理解变量。&lt;/p>
&lt;p>比如我们之前的变量 &lt;code>a&lt;/code>：&lt;/p>
&lt;p>它可以被想象成什么样的画面呢？
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/85e3436b-9762-45b3-b0bb-38c1f87e416d/wire.png" alt="">
我故意把箭头方向画成从右往左，这样它就更像上面的代码。从这个图画里，你也许可以看到变量 &lt;code>a&lt;/code> 和风扇控制器图里的参数 &lt;code>t&lt;/code>，其实没有任何本质差别。它们都表示一根电线，那根电线进入乘法器，将会被乘以 2，然后输出。如果你把这些都看成是电路，那么变量 &lt;code>a&lt;/code> 和参数 &lt;code>t&lt;/code> 都代表一根电线而已。&lt;/p>
&lt;p>然后你还发现一个现象，那就是你可以把 &lt;code>a&lt;/code> 这个名字换成任何其它名字（比如 &lt;code>b&lt;/code>），而这幅图不会产生实质的改变。&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/85e3436b-9762-45b3-b0bb-38c1f87e416d/rename.png" alt="">&lt;/p>
&lt;p>这说明什么问题呢？这说明以下的代码（把 &lt;code>a&lt;/code> 换成了 &lt;code>b）&lt;/code>跟之前的是等价的：&lt;/p>
&lt;p>根据几乎一样的电线命名变化，你也可以对之前的函数得到一样的结论：&lt;code>t -&amp;gt; t*2&lt;/code> 和 &lt;code>u -&amp;gt; u*2&lt;/code>，和 &lt;code>x -&amp;gt; x*2&lt;/code> 都是一回事。&lt;/p>
&lt;p>名字是很重要的东西，但它们具体叫什么，对于机器并没有实质的意义，只要它们不要相互混淆就可以。但名字对于人是很重要的，因为人脑没有机器那么精确。不好的变量和参数名会导致代码难以理解，引起程序员的混乱和错误。所以通常说来，你需要给变量和参数起好的名字。&lt;/p>
&lt;p>什么样的名字好呢？我会在后面集中讲解。&lt;/p>
&lt;h2 id="named-function有名字的函数">Named function(有名字的函数)&lt;/h2>
&lt;p>既然变量可以代表 “值”，那么一个自然的想法，就是让变量代表函数。所以就像我们可以写&lt;/p>
&lt;p>我们似乎也应该可以写&lt;/p>
&lt;p>对的，你可以这么做。&lt;code>f = t-&amp;gt;t*2&lt;/code> 还有一个更加传统的写法，就像数学里的函数写法：&lt;/p>
&lt;p>请仔细观察 &lt;code>t&lt;/code> 的位置变化。我们在函数名字的右边写一对括号，在里面放上参数的名字。&lt;/p>
&lt;p>注意，你不可以只写&lt;/p>
&lt;p>你必须明确的指出函数的参数是什么，否则你就不会明白函数定义里的 &lt;code>t&lt;/code> 是什么东西。明确指出 &lt;code>t&lt;/code> 是一个 “输入”，你才会知道它是函数的输入，是一个未知数，&lt;strong>而不是在函数外面定义的其它变量&lt;/strong>。&lt;/p>
&lt;p>这个看似简单的道理，很多数学家都不明白，所以他们经常这样写书：&lt;/p>
&lt;blockquote>
&lt;p>有一个函数 y = x*2&lt;/p>
&lt;/blockquote>
&lt;p>这是错误的，因为他没有明确指出 “&lt;code>x&lt;/code> 是函数 y 的参数”。如果这句话之前他们又定义过 &lt;code>x&lt;/code>，你就会疑惑这是不是之前那个 &lt;code>x&lt;/code>。很多人就是因为这些糊里糊涂的写法而看不懂数学书。这不怪他们，只怪数学家自己对于语言不严谨。&lt;/p>
&lt;h2 id="function-call函数调用">Function call(函数调用)&lt;/h2>
&lt;p>有了函数，我们可以给它起名字，可是我们怎么使用它的值呢？&lt;/p>
&lt;p>由于函数里面有未知数（参数），所以你必须告诉它这些未知数，它里面的代码才会执行，给你结果。比如之前的风扇控制器函数&lt;/p>
&lt;p>它需要一个温度作为输入，才会给你一个输出。于是你就这样给它一个输入：&lt;/p>
&lt;p>你把输入写在函数名字后面的括号里。那么你就会得到输出：4。也就是说 &lt;code>f(2)&lt;/code> 的值是 4。&lt;/p>
&lt;p>如果你没有调用一个函数，函数体是不会被执行的。因为它不知道未知数是什么，所以什么事也做不了。那么我们定义函数的时候，比如&lt;/p>
&lt;p>当看到这个定义的时候，机器应该做什么呢？它只是记录下：有这么一个函数，它的参数是 &lt;code>t&lt;/code>，它需要计算 &lt;code>t*2&lt;/code>，它的名字叫 &lt;code>f&lt;/code>。但是机器不会立即计算 &lt;code>t*2&lt;/code>，因为它不知道 &lt;code>t&lt;/code> 是多少。&lt;/p>
&lt;h2 id="branch分支">Branch(分支)&lt;/h2>
&lt;p>直到现在，我们的代码都是从头到尾，闷头闷脑地执行，不问任何问题。我们缺少一种 “问问题” 的方法。比如，如果我想表达这样一个“食物选择器”：如果气温低于 22 度，就返回 “hotpot” 表示今天吃火锅，否则返回 “ice cream” 表示今天吃冰激凌。&lt;/p>
&lt;p>我们可以把它图示如下：
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/85e3436b-9762-45b3-b0bb-38c1f87e416d/branch.png" alt="">
中间这种判断结构叫做 “分支”（branching），它一般用菱形表示。为什么叫分支呢？你想象一下，代码就像一条小溪，平时它沿着一条路线流淌。当它遇到一个棱角分明的大石头，就分成两个支流，分开流淌。&lt;/p>
&lt;p>我们的判断条件 &lt;code>t &amp;lt; 22&lt;/code> 就像一块大石头，我们的 “代码流” 碰到它就会分开成两支，分别做不同的事情。跟溪流不同的是，这种分支不是随机的，而是根据条件来决定，而且分支之后只有一支继续执行，而另外一边不会被执行。&lt;/p>
&lt;p>我们现在看到的都是图形化表示的模型，为了书写方便，现在我们要从符号的层面来表示这个模型。我们需要一种符号表示法来表达分支，我们把它叫做 &lt;code>if&lt;/code>（如果）。我们的饮料选择器代码可以这样写：&lt;/p>
&lt;pre>&lt;code>t -&amp;gt; if (t &amp;lt; 22)
{
&amp;quot;hotpot&amp;quot;
}
else
{
&amp;quot;ice cream&amp;quot;
}
&lt;/code>&lt;/pre>
&lt;p>它是一个函数，输入是一个温度。&lt;code>if&lt;/code> 后面的括号里放我们的判断条件。后面接着条件成立时执行的代码块，然后是一个 &lt;code>else&lt;/code>，然后是条件不成立时执行的代码。它说：如果温度低于 22 度，我们就吃火锅，否则就吃冰激凌。&lt;/p>
&lt;p>其中的 &lt;code>else&lt;/code> 是一个特殊的符号，它表示 “否则”。看起来不知道为什么 &lt;code>else&lt;/code> 要在那里？对的，它只是一个装饰品。我们已经有足够的表达力来分辨两个分支，不过有了 &lt;code>else&lt;/code> 似乎更加好看一些。很多语言里面都有 else 这个标记词在那里，所以我也把它放在那里。&lt;/p>
&lt;p>这只是一个最简单的例子，其实那两个代码块里面不止可以写一条语句。你可以有任意多的语句，就像这样：&lt;/p>
&lt;pre>&lt;code>t -&amp;gt;
if (t &amp;lt; 22)
{
a = 4 + 3
b = a * 2
&amp;quot;hotpot&amp;quot;
}
else
{
x = &amp;quot;ice cream&amp;quot;
x
}
&lt;/code>&lt;/pre>
&lt;p>这段代码和之前是等价的，你知道为什么吗？&lt;/p>
&lt;h2 id="declaration声明-与-definition定义">Declaration(声明) 与 Definition(定义)&lt;/h2>
&lt;p>上面描述了很多计算机科学的基本要素，那么上面那么多字的描述，是如何定义的呢？~不定义一个东西，是没法使用它的~~~&lt;/p>
&lt;p>在计算机编程中，&lt;strong>Declaration(声明)&lt;/strong> 是一种语言结构，用以指定 Identifier(标识符) 的属性，i.e.声明一个词(标识符)代表什么，也就是说，将 Identifier(标识符) 绑定到某种概念上。&lt;/p>
&lt;blockquote>
&lt;p>比如，用白话说就是：我声明，A 表示一个函数、B 表示一个字符串类型的变量，等等&lt;/p>
&lt;/blockquote>
&lt;p>Declaration 最常用于函数、变量、常量、类型定义 等等。Declaration 用于向编译器宣布实体的存在，在某些强类型的编程语言中，使用 函数、变量、常量 等等要素之前需要先 Declaration 它们，再使用比如 为变量赋值、调用函数 等等)。&lt;/p>
&lt;p>在某些场景下，&lt;strong>Declaration(声明)&lt;/strong> 与 &lt;strong>Definition(定义)&lt;/strong> 这两个词比较容易混淆。&lt;/p>
&lt;ul>
&lt;li>在非正式用法中
&lt;ul>
&lt;li>Declaration 纯指声明(仅类型，无值或主体)&lt;/li>
&lt;li>Definition 指包含值或主体的声明。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>在正式使用中
&lt;ul>
&lt;li>Declaration 包含非正式用法中的两种含义。在 Declaration 的同时，有的时候我们会为标识符定义一个初始值。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>上面的描述，把定义当做了赋值的行为。实际上，Definition 还有另外一种行为含义，这种行为应该是在 Declaration 之前的。比如下面的例子：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>// 这里我们定义了一个类型与函数。定义时，指定了这些东西应该具有的属性
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>definition string XXXXX
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>definition func YYYYY
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>// 这里我们声明了一个类型与函数。
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>// 标识符A 绑定到了字符串
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>// 标识符B 绑定到了函数
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>var identifierA string
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>func iderntifierB&lt;span style="color:#f92672">(){&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Do Something
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>// 此时我们可以使用这些已经声明的标识符
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>stringType &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#34;Hello World&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>DefinitionFunc&lt;span style="color:#f92672">()&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>也就是说，Definition(定义) 这个词更符合人类的日常用于，定义一个事物，就是对这个事物进行总结，就好比科学，我们通过观察自然界的现象，来定义一个科学定律，然后通过定律推导出定理。总结一下就是：&lt;/p>
&lt;ul>
&lt;li>&lt;strong>Definition 用来指定 Type(类型)。不管是编程语言自带的基本类型，还是符合类型，甚至是自己自定义的类型，都称为“定义类型”&lt;/strong>&lt;/li>
&lt;li>&lt;strong>Declaration 用来指定 Identifier(标识符)，并将该 Identifier(标识符) 绑定到 Type(类型) 上。称为“声明标识符”&lt;/strong>&lt;/li>
&lt;/ul>
&lt;p>但是，在现代中，Declaration 与 Definition 经常会混用，经常会有人说：定义类型、声明类型、定义变量、声明变量、定义函数、声明函数 等等等等。&lt;/p>
&lt;p>比如，当我们使用一个未声明的变量时，某些编程语言经常会提示 undefined(未定义)~~~~o(╯□╰)o 其实，更准确的提示应该是 undeclared。&lt;/p>
&lt;blockquote>
&lt;p>说的就是你，Go 语言，Declaration 与 Definition 不分~~~
不过除了这个编译器的错误提示有歧义以外，其它描述基本都是准确的，绝大部分都是 Declaration(声明)，只有一个地方用到了 Definition(定义)，主要就是在 &lt;a href="https://go.dev/ref/spec#Type_declarations">Go 的参考&lt;/a>中，可以看到 Type Declaration 与 Type Definition 之间的区别。也就是说，只有在描述一个新的类型时，才称为“定义类型”&lt;/p>
&lt;ul>
&lt;li>比如 &lt;code>type XXXX struct&lt;/code>，我们就称为 &lt;strong>定义结构体&lt;/strong>，&lt;code>var structID XXXX&lt;/code>，我们就称为&lt;strong>声明 XXXX 类型结构体。&lt;/strong>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>后记：
其实，定义类型这个行为，再扩展一下，也可以称为建模，这是[面向对象编程](/docs/IT学习笔记/2.编程/解谜计算机科学/Object-oriented%20Programming(面向对象编程).md Programming(面向对象编程).md)的基本要素。人们通过对现实世界的观察、总结，定义了很多基本类型，比如 数字、字符串、布尔 等等。这些基本类型都是一个个已经建立好的模型，只不过是最基本的，而我们可以使用这些基本模型，建立更复杂的模型。所以，定义类型 这个行为，从某种角度来看，就是建立模型。&lt;/p>
&lt;h1 id="计算的要素">计算的要素&lt;/h1>
&lt;p>好了，现在你已经掌握了计算机科学的几乎所有基本要素。每一个编程语言都包括这些构造：&lt;/p>
&lt;ul>
&lt;li>基础的数值。比如整数，字符串，布尔值等。&lt;/li>
&lt;li>表达式。包括基本的算术表达式，嵌套的表达式。&lt;/li>
&lt;li>变量和赋值语句。&lt;/li>
&lt;li>分支语句。&lt;/li>
&lt;li>函数和函数调用。&lt;/li>
&lt;/ul>
&lt;p>你也许可以感觉到，我是把这些构造按照 “从小到大” 的顺序排列的。这也许可以帮助你的理解。&lt;/p>
&lt;p>现在你可以回想一下你对它们的印象。每当学习一种新的语言或者系统，你只需要在里面找到对应的构造，而不需要从头学习。这就是掌握所有程序语言的秘诀。这就像学开车一样，一旦你掌握了油门，刹车，换挡器，方向盘，速度表的功能和用法，你就学会了开所有的汽车，不管它是什么型号的汽车。&lt;/p>
&lt;p>我们在这一章不仅理解了这些要素，而且为它们定义了一种我们自己的 “语言”。显然这个语言只能在我们的头脑里运行，因为我们没有实现这个语言的系统。在后面的章节，我会逐渐的把我们这种语言映射到现有的多种语言里面，然后你就能掌握这些语言了。&lt;/p>
&lt;p>但是请不要以为掌握了语言就学会了编程或者学会了计算机科学。掌握语言就像学会了各种汽车部件的工作原理。几分钟之内，初学者就能让车子移动，转弯，停止。可是完了之后你还需要学习交通规则，你需要许许多多的实战练习和经验，掌握各种复杂情况下的策略，才能成为一个合格的驾驶员。如果你想成为赛车手，那就还需要很多倍的努力。&lt;/p>
&lt;p>但是请不要被我这些话吓到了，你没有那么多的竞争者。现在的情况是，世界上就没有很多合格的计算机科学驾驶员，更不要说把车开得流畅的赛车手。绝大部分的 “程序员” 连最基本的引擎，油门，刹车，方向盘的工作原理都不明白，思维方式就不对，所以根本没法独自上路，一上路就出车祸。很多人把过错归结在自己的车身上，以为换一辆车马上就能成为好的驾驶员。这是一种世界范围的计算机教育的失败。&lt;/p>
&lt;p>在后面的章节，我会引导你成为一个合格的驾驶员，随便拿一辆车就能开好。&lt;/p>
&lt;h1 id="什么是计算">什么是计算&lt;/h1>
&lt;p>现在你掌握了计算所需要的基本元素，可是什么是计算呢？我好像仍然没有告诉你。这是一个很哲学的问题，不同的人可能会告诉你不同的结果。我试图从最广义的角度来告诉你这个问题的答案。&lt;/p>
&lt;p>当你小时候用手指算 &lt;code>4+3&lt;/code>，那是计算。如果后来你学会了打算盘，你用算盘算 4+3，那也是计算。后来你从我这里学到了表达式，变量，函数，调用，分支语句…… 在每一新的构造加入的过程中，你都在了解不同的计算。&lt;/p>
&lt;p>所以从最广义来讲，计算就是 “机械化的信息处理”。所谓机械化，你可以用手指算，可以用算盘，可以用计算器，或者计算机。这些机器里面可以有代码，也可以没有代码，全是电子线路，甚至可以是生物活动或者化学反应。不同的机器也可以有不同的计算功能，不同的速度和性能……&lt;/p>
&lt;p>有这么多种计算的事实不免让人困惑，总害怕少了点什么，其实你可以安心。如果你掌握了上一节的 “计算要素”，那么你就掌握了几乎所有类型的计算系统所需要的东西。你在后面所需要做的只是加深这种理解，并且把它“对应” 到现实世界遇到的各种计算机器里面。&lt;/p>
&lt;p>为什么你可以相信计算机科学的精华就只有这些呢？因为计算就是处理信息，信息有它诞生的位置（输入设备，固定数值），它传输的方式（赋值，函数调用，返回值），它被查看的地方（分支）。你想不出对于信息还有什么其它的操作，所以你就很安心的相信了，这就是计算机科学这种 “棋类游戏” 的全部规则。&lt;/p>
&lt;p>（如果你觉得这篇文章有启发，可以点击这里&lt;a href="http://www.yinwang.org/blog-cn/2016/04/13/pay-blog">付费&lt;/a>）&lt;/p></description></item><item><title>Docs: 紧急模式或救援模式</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/x.linux-%E7%AE%A1%E7%90%86/%E6%80%A7%E8%83%BD%E8%AF%84%E4%BC%B0%E4%B8%8E%E6%95%85%E9%9A%9C%E5%A4%84%E7%90%86/%E6%95%85%E9%9A%9C%E5%A4%84%E7%90%86/%E7%B4%A7%E6%80%A5%E6%A8%A1%E5%BC%8F%E6%88%96%E6%95%91%E6%8F%B4%E6%A8%A1%E5%BC%8F/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/x.linux-%E7%AE%A1%E7%90%86/%E6%80%A7%E8%83%BD%E8%AF%84%E4%BC%B0%E4%B8%8E%E6%95%85%E9%9A%9C%E5%A4%84%E7%90%86/%E6%95%85%E9%9A%9C%E5%A4%84%E7%90%86/%E7%B4%A7%E6%80%A5%E6%A8%A1%E5%BC%8F%E6%88%96%E6%95%91%E6%8F%B4%E6%A8%A1%E5%BC%8F/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;p>Linux 系统难免出现问题，下面总结了一些在出现问题时，可以用到的修复方式。&lt;/p>
&lt;p>比如 单用户模式、GRUB 命令操作、Linux 救援模式 的故障修复案例。&lt;/p>
&lt;p>一般的故障修复，都是通过进入一个微型系统，并在微型系统中关联正常系统，来实现对正常系统进行修复操作的。常见的微型系统大体分为两类：&lt;/p>
&lt;ul>
&lt;li>&lt;strong>存在于内核中的微型系统，通过内核来启动&lt;/strong>&lt;/li>
&lt;li>&lt;strong>通过外部挂载(光盘、usb 等)的方式来启动&lt;/strong>
&lt;ul>
&lt;li>Preinstallation Environment 版本与 Live 版本是 Windows 和 Linux 的预安装系统的两种微型系统的称呼。&lt;/li>
&lt;li>部分 Linux 发行版的安装 iso 中也会自带一个微型系统（比如 CentOS），而没有专门的 Live 系统。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h1 id="emergency紧急-模式">Emergency(紧急) 模式&lt;/h1>
&lt;p>Linux 系统提供了紧急模式(类似 Windows 安全模式)，该模式镶嵌在内核中。可以在最小环境中(仅仅运行系统所需的必要程序)进行系统维护。在紧急模式中，Linux 引导进入根 shell，网络被禁用，只有少数进程运行。紧急模式可以用来修改文件系统损坏、还原配置文件、移动用户数据等。&lt;/p>
&lt;h2 id="启动紧急模式">启动紧急模式&lt;/h2>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/ewdpso/1616163959565-28b07db0-d297-4c04-bdf7-b31a43af0106.jpeg" alt="">&lt;/p>
&lt;p>在该界面选中想要使用的内核后，按 e 键 ，进入编辑启动参数界面&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/ewdpso/1616163959592-6d0be599-731a-4f6c-b6b1-9e195991cfb9.jpeg" alt="">&lt;/p>
&lt;p>在上图红框位置将 ro 改为 rw init=/sysroot/bin/sh 。然后按 ctrl+x 来启动。这时候，就进入了紧急模式，紧急模式的界面是像下图这样的&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/ewdpso/1616163959556-b1d3734e-d706-47fc-a83c-131c6f049baa.jpeg" alt="">&lt;/p>
&lt;p>这是一个 sh 的 shell(也可以启动其他 shell，比如 bash 等)，可以执行一些基本命令，目录结构如下&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>:/# ls
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>bin dev dracut-state.sh etc init lib lib64 proc root run sbin shutdown sys sysroot tmp usr var
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>其中 &lt;code>sysroot&lt;/code> 目录，就是我们正常启动系统时，所看到的 &lt;code>/&lt;/code> 目录&lt;/p>
&lt;p>在这种模式下，可以看到，仅有个别进程在运行，/init rhgb 是该系统模式下的第一个进程，与正常系统不同。&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/ewdpso/1616163959562-5047fe7d-4089-43e3-933c-0eb9ab6c80d4.jpeg" alt="">&lt;/p>
&lt;p>sh 进程是因为我们需要一个可以操作的 shell，所以在修改启动项时添加的。&lt;/p>
&lt;p>实际上，所谓的紧急模式，就是在安装 linux 系统时，内核中内置的一个微型系统，进入该微型系统后，咱正常系统的根目录，就被挂载到微型系统的/sysroot 下了，由于没有挂载其他物理磁盘，也没有任何多余进程运行，所以只要内核是好的，那么紧急模式是可以正常进入的。&lt;/p>
&lt;p>该模式可以用来修复一些与非内核错误的一些故障&lt;/p>
&lt;h1 id="rescue救援-模式">Rescue(救援) 模式&lt;/h1>
&lt;p>当紧急模式不可用时，说明内核或者内核相关出现问题，这时候，我们就需要使用救援模式了。&lt;/p>
&lt;p>救援模式并不在已经安装的系统或者内核上，而是通过外部挂载 linux 系统镜像来启动。相当于通过外挂的系统镜像来启动一个微型系统，来诊断并修复当前系统&lt;/p>
&lt;h2 id="启动救援模式">启动救援模式&lt;/h2>
&lt;p>首先需要将系统镜像挂载到设备上，物理机直接插入光盘或者 U 盘，并修改启动项；虚拟机的话同理，将 linux 系统镜像挂载进虚拟机然后通过该系统镜像启动系统。&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/ewdpso/1616163959557-c45d87ec-9d2c-4296-b14a-fdd3f7b710e1.jpeg" alt="">&lt;/p>
&lt;p>在上图选择 Troubleshooting 后，选择 Rescue a CentOS system（救援一个 centos 系统）&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/ewdpso/1616163959573-28e0e935-14ef-4a12-8d1f-20ad9d79a274.jpeg" alt="">&lt;/p>
&lt;p>在上图蓝线上半部分，选择 1 继续之后。将会启动一个微型系统，并进入一个 shell，其中会提示我们，设备上正常系统的 / 目录被挂载到 /mnt/sysimage ，该情况与 紧急模式 一样，只是正常系统的跟目录被挂载的路径不同罢了。&lt;/p>
&lt;p>通过光盘启动的微型系统，明显比紧急模式的微型系统 功能更加完善，可以看到有很多进程&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/ewdpso/1616163959579-0a7e5ff3-ae98-4560-8a00-c3b58808a04d.jpeg" alt="">&lt;/p>
&lt;p>同样也是一个 sh 的 shell。可以在该 shell 下，进入 /mnt/sysimage 目录来对正常的系统进行修复&lt;/p>
&lt;h2 id="这类模式常见使用方式">这类模式常见使用方式&lt;/h2>
&lt;p>由于进入这类救援模式后，原本系统的 &lt;code>/&lt;/code> 被挂载到微型系统的的其他目录，这之后直接使用 chroot /PATH/DIR 命令，即可将当前 / 目录转变到原本系统上，然后就可以更方便的定位问题了，如果不进行 chroot，那么操作目录的时候，其实挺不方便的~~~~&lt;/p>
&lt;h2 id="ubuntu-的-rescue-模式">Ubuntu 的 Rescue 模式&lt;/h2>
&lt;p>网上充斥着大量的垃圾信息，并没有明确指导如何通过挂盘来进入 Rescue 模式，实际上，Ubuntu Server 版的 ISO 并没有提供这个功能，那么有两种方式来实现：&lt;/p>
&lt;ul>
&lt;li>使用 Ubuntu Desktop 的 ISO，进入界面后选择 &lt;strong>Try Ubuntu&lt;/strong>，也就是网上常说的 &lt;strong>Live CD&lt;/strong> 模式。只不过这是图形界面，进入后配置好 root 密码，可以使用 &lt;code>ctrl + alt + f3&lt;/code> 来切换 TTY，并在 CLI 下进行修复工作&lt;/li>
&lt;li>使用 CentOS 的 ISO 进入 Rescue 模式，同样可以修复挂载 Ubuntu 的分区到指定的目录。&lt;/li>
&lt;/ul>
&lt;h1 id="如何在-centos-8-上启动到紧急模式">如何在 CentOS 8 上启动到紧急模式&lt;/h1>
&lt;p>原文链接：&lt;a href="https://linuxhint.com/boot-emergency-mode-centos-8/">https://linuxhint.com/boot-emergency-mode-centos-8/&lt;/a>
在最新的 CentOS 中，即 CentOS 8 紧急模式和救援模式已经取代了运行级别的概念。运行级别是用于各种任务的不同模式。在 CentOS 8 中，Rescue 模式相当于单用户模式，而紧急启动模式提供了一个最小的环境来修复您的系统。
今天我们将学习如何将 CentOS 8 启动到救援和紧急模式。&lt;/p>
&lt;h2 id="如何启动进入救援模式">如何启动进入救援模式&lt;/h2>
&lt;p>救援模式需要 root 密码进行身份验证，并允许您在正常启动过程不起作用时恢复系统。救援模式将尝试设置所有本地文件系统并启动一些基本系统服务。救援模式不启动网络接口，也不允许多个用户登录。
启动计算机并等待 GRUB 菜单出现。&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/ewdpso/1630379281707-861e3e5b-49c3-4721-9e4e-d2f0dd9239cc.png" alt="image.png">&lt;/p>
&lt;p>现在按“e”打开编辑菜单：&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/ewdpso/1630379281756-579ed222-fa5a-48c6-9182-5a19adc12983.png" alt="image.png">&lt;/p>
&lt;p>现在，找到以下面的屏幕截图所示的“Linux”关键字开头的行：&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/ewdpso/1630379280843-f87b7899-36d3-4049-8ba5-38f918926497.png" alt="image.png">&lt;/p>
&lt;p>使用键盘上的终点按钮转到线的末尾，并在行结束时添加以下参数：&lt;/p>
&lt;p>systemd.Unit = Rescue.target.&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/ewdpso/1630379280876-d0125040-66ac-4757-abde-e5089a4c1b4e.png" alt="image.png">&lt;/p>
&lt;p>按 Ctrl + X 启动系统，但此时使用新参数将让您输入救援模式。&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/ewdpso/1630379280860-c9be44a2-22e8-4fa5-a6c7-4dc77dffa729.png" alt="image.png">&lt;/p>
&lt;p>操作系统会要求 root 密码。在提供密码后，您将进入救援模式。&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/ewdpso/1630379281433-ed1c7906-6118-4f92-a7cc-1dc556b445a6.png" alt="image.png">&lt;/p>
&lt;p>现在，您可以在救援模式下修复系统。&lt;/p>
&lt;p>完成救援模式后，您可以通过运行“退出”命令来退出救援/紧急模式。&lt;/p>
&lt;h2 id="启动进入紧急模式">启动进入紧急模式&lt;/h2>
&lt;p>紧急模式甚至救援模式不起作用时，恢复系统的最小环境。紧急将根文件安装为只读，并不尝试挂载本地文件系统。紧急模式也没有启动网络接口。&lt;/p>
&lt;p>将系统启动到紧急模式的过程与救援模式相同。&lt;/p>
&lt;p>首先，启动计算机并等待 GRUB 菜单显示：&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/ewdpso/1630379281944-4f628d77-411e-4319-af8c-1a1557c7e8ce.png" alt="image.png">&lt;/p>
&lt;p>现在按“E”打开编辑菜单：&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/ewdpso/1630379282293-94e66990-034a-4b85-8cfa-7e9262ade0a8.png" alt="image.png">&lt;/p>
&lt;p>现在定位以“Linux”关键字开头的行，如下屏幕截图所示：&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/ewdpso/1630379282273-c76fcd43-02db-4a14-b7e3-52b4ca27cb3e.png" alt="image.png">&lt;/p>
&lt;p>使用键盘上的终点按钮转到线的末尾，并在行结束时添加以下参数：&lt;/p>
&lt;p>systemd.unit = Encrasst.target.&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/ewdpso/1630379283117-bf48ec7a-b48c-4d23-bd05-b284dce0dcb3.png" alt="image.png">&lt;/p>
&lt;p>按 Ctrl + X 启动系统，但此时使用新参数将让您输入紧急模式。&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/ewdpso/1630379283276-16043784-d87e-4a63-8c3b-95c4c030fd98.png" alt="image.png">&lt;/p>
&lt;p>提供密码后，您将进入紧急模式。&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/ewdpso/1630379283239-886da796-8374-441c-a133-2e28b376336d.png" alt="image.png">&lt;/p>
&lt;p>现在，即使救援模式不起作用，您也可以在紧急模式下修复系统。&lt;/p>
&lt;p>完成紧急模式后，您可以通过运行“退出”命令来退出救援/紧急模式。&lt;/p></description></item><item><title>Docs: 区块链</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%8C%BA%E5%9D%97%E9%93%BE/%E5%8C%BA%E5%9D%97%E9%93%BE/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%8C%BA%E5%9D%97%E9%93%BE/%E5%8C%BA%E5%9D%97%E9%93%BE/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://www.bilibili.com/video/BV1T34y117Y9">B 站，汪杰解惑 NFT-02&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>2008 年 10 月 31 日 《Bitconi: A Peer-to-Peer Electronic Cash System 》&lt;/p>
&lt;ul>
&lt;li>保证信息的完整性和真实性&lt;/li>
&lt;li>保证信息的不可否认性&lt;/li>
&lt;/ul>
&lt;h1 id="数字加密货币">数字加密货币&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>如何把狗狗币|柴犬币 shib|放在 imtoken 钱包和 metamask 狐狸钱包中？
&lt;ul>
&lt;li>这里教如何添加代币，如何添加钱包中的网络&lt;/li>
&lt;li>&lt;a href="https://www.youtube.com/watch?v=Gn4FCh5DEvg">https://www.youtube.com/watch?v=Gn4FCh5DEvg&lt;/a>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>【狐狸钱包】一分钟学会，如何一键添加各种主网？
&lt;ul>
&lt;li>&lt;a href="https://www.youtube.com/watch?v=f1JU8TGImA0">https://www.youtube.com/watch?v=f1JU8TGImA0&lt;/a>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>钱包&lt;/p>
&lt;ul>
&lt;li>MetaMask 钱包&lt;/li>
&lt;li>Coinbase Wallet 钱包&lt;/li>
&lt;li>imtoken 钱包&lt;/li>
&lt;/ul>
&lt;p>NFT 交易平台&lt;/p>
&lt;ul>
&lt;li>OpenSea&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>Percentage Fee(版税)&lt;/strong> # 即提成的百分比。每次 NFT 交易时，最初的创建者会获得交易额的百分比的收入。
**Gas Fee(气体费) **# 铸造一个 NFT 是有成本的，需要向矿工支付 Gas Fee&lt;/p>
&lt;p>钱包中的网络：就是“链”也就是“区块链”的链。在各种链上，可以搜索在当钱链上的交易记录。&lt;/p>
&lt;h2 id="eth">ETH&lt;/h2>
&lt;p>&lt;strong>Etherscan 是&lt;/strong>以太坊网络的区块链浏览器。 该网站可用于搜索交易、区块、钱包地址、智能合约以及其它链上数据，属于最热门的以太坊区块链浏览器之一，免费向用户开放。 使用&lt;strong>Etherscan&lt;/strong>即可详细了解如何与区块链、其他钱包以及 DAapp 进行交互&lt;/p>
&lt;p>&lt;a href="https://etherscan.io/address/0xED783c0ee7444435d31555f0Ab23E30ac2d0a9Eb">https://etherscan.io/address/0xED783c0ee7444435d31555f0Ab23E30ac2d0a9Eb&lt;/a>&lt;/p>
&lt;h2 id="链">链&lt;/h2>
&lt;ul>
&lt;li>HECO # 火币的链
&lt;ul>
&lt;li>火币的“区块链浏览器”&lt;a href="https://hecoinfo.com/">https://hecoinfo.com/&lt;/a>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Etherscan # 以太坊的链
&lt;ul>
&lt;li>以太坊的“区块链浏览器”&lt;a href="https://etherscan.io/">https://etherscan.io/&lt;/a>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h2 id="应用示例">应用示例&lt;/h2>
&lt;p>当我们从交易所中将各种数字货币提取到钱包中后，虽然可以看到交易已完成，但是我们在钱包中却看不到。&lt;/p>
&lt;p>这是因为，在我们提币时，需要填写一个“提币网络”，这个“提币网络”其实就是指的区块链中的“链”，对应的就是各个钱包中的“网络”。&lt;/p>
&lt;p>所以我们首先应该先为钱包添加对应交易的“链”。&lt;/p>
&lt;h3 id="添加链">添加链&lt;/h3>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/lddbaw/1647499683695-dd622c13-b54a-4ff3-b643-63f616244c4e.png" alt="image.png">
从对应的“链”找到其 URL，这里以火币的 HECO 链为例，从&lt;a href="https://hecoinfo.com/apis#rpc">这里&lt;/a>可以找到 HECO 的 Endpoint 与 链 ID
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/lddbaw/1647499855988-a4357488-abd5-436f-abb8-805f64774e9f.png" alt="image.png">
然后将 Endpoint 和 链 ID 填入，即可在钱包中添加“链”
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/lddbaw/1647499879301-9ec3af5b-4d36-495b-ade5-41710057a624.png" alt="image.png">
后续提币的操作时，我们选择的“提币网络”也要与“链”对应上才行，交易记录通常都是保存在交易双方所在的链上。&lt;/p>
&lt;h3 id="获取交易记录-h">获取交易记录 h&lt;/h3>
&lt;p>在火币交易记录查到 &lt;code>交易ID&lt;/code>
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/lddbaw/1647498496139-aa024459-ea29-47f5-b918-400007cd2539.png" alt="image.png">&lt;/p>
&lt;h3 id="获取代币的合约地址">获取代币的合约地址&lt;/h3>
&lt;p>在&lt;a href="https://hecoinfo.com/">火币链&lt;/a>页面搜索该交易
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/lddbaw/1647498548140-52d38f6c-0e7b-4a3b-89d8-2907bea8d3c9.png" alt="image.png">
可以获取到交易细节，然后查看 Tokens Transferred 中的 &lt;code>For&lt;/code> 信息
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/lddbaw/1647498734107-01e68293-ec25-4b4d-9db8-1c5ca84a8552.png" alt="image.png">
然后就可以获取到交易代币的合约地址
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/lddbaw/1647498797213-df1d9e0c-c2b7-466c-8936-58f930d053ab.png" alt="image.png">
这个地址就是钱包中，添加自定义代币时，所使用的地址。&lt;/p>
&lt;ul>
&lt;li>USDT: 0xa71edc38d189767582c38a3145b5873052c3e47a&lt;/li>
&lt;li>DOGE: 0x40280E26A572745B1152A54D1D44F365DaA51618&lt;/li>
&lt;/ul>
&lt;h3 id="导入代币">导入代币&lt;/h3>
&lt;p>填入地址后，代币符号与小数精度将会自动出现
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/lddbaw/1647498857327-a04a31ff-ff5c-4e32-8809-8bcc8582bdd2.png" alt="image.png">&lt;/p></description></item><item><title>Docs: 日志系统</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/6.%E5%8F%AF%E8%A7%82%E6%B5%8B%E6%80%A7/%E6%97%A5%E5%BF%97%E7%B3%BB%E7%BB%9F/%E6%97%A5%E5%BF%97%E7%B3%BB%E7%BB%9F/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/6.%E5%8F%AF%E8%A7%82%E6%B5%8B%E6%80%A7/%E6%97%A5%E5%BF%97%E7%B3%BB%E7%BB%9F/%E6%97%A5%E5%BF%97%E7%B3%BB%E7%BB%9F/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Syslog">Wiki,Syslog&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://datatracker.ietf.org/doc/html/rfc5424">RFC 5424&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;h2 id="背景">背景&lt;/h2>
&lt;p>在系统上，不管是系统本身还是外部程序，在开始、运行、结束的一整套过程中，都会产生信息，这些信息包括:何时、何地(来源 IP)、何人(什么程序)、发生了什么事情等。i.e.记录系统在什么时候由哪个程序做了什么样的行为时，发生了何种事件等等。而发生的事情又有等级的区别，哪些信息是危险的，哪些信息是标准可以不用关注的等。这些信息就统称为日志(Log)。随着时代发展，操作系统、程序、硬件设备等等都会产生日志，如此众多的日志需要一个标准来进行定义，这个日志标准就是 &lt;strong>Syslog Protocol&lt;/strong>，由 IETF 给定的 RFC 5424 规范来执行。而在 IT 行业，一般也把各个事务所生成的日志称为 syslog。&lt;/p>
&lt;h2 id="日志的生成">日志的生成&lt;/h2>
&lt;p>操作系统、进程和应用程序的编写者完全清楚他们将生成的事件。在某些情况下，生成消息用来说明状态。可以是一段时间一次，也可以由其他方式触发，例如在程序退出时。在其他情况下，消息是由遇到的条件产生的。在这些情况下，不管是状态消息或者包含一些类型的警告都可能被产生。操作系统、进程和应用程序的编写者可能会在详单中确定消息的数量。这些详单中通常包括发出消息的设备，同时包含消息的严重级别。这样，操作员可以有选择地筛选消息，可以更快的定位更加重要的和有处理时间限制的消息，同时可以将状态或消息信息放在文件中，将来阅读他们。其他显示和保存信息的方式也可以存在。&lt;/p>
&lt;p>必须在设备中配置一些规则，这些规则可以告诉设备显示还是转发事件消息。这些规则是十分灵活的。管理员可能希望所有的信息都保存在本地，同时所有高优先级的消息都会转发到另一台设备中。他们可能发现，将某些设备的信息发送到一些或所有用户的设备中，同时显示在系统控制台上是很合适的。然而，管理员决定将事件信息发送到 syslog 采集器中，在采集器中包含了组成设备的信息以及发送的严重级别，同时定义了远程接收器。例如，系统管理员可能想让所有由邮件设备发出的消息被转发到一个特定的事件信息采集器中。管理员还可以让所有内核生成的事件信息被发送到另一台 syslog 接收器中，同时，将内核产生的 critical 严重级别的消息发送到第三台设备中。同时，将显示在系统控制台中的信息 email 给部分用户，同时将他们保存在设备本地磁盘的文件中。反之，可以将本地进程产生的消息显示在控制台中，但不保存也不转发。所有事件的规则都在设备中生成。因为管理员知道 collector 会收集到哪种类型的事件，他们会在 syslog 服务器中配置相应的规则。&lt;/p>
&lt;p>消息的内容因创建者而异。建议将消息按照一定格式编写，这样人们就可以阅读他们。在消息中加入时间戳和发出消息的设备以及进程的标识符是一个很好的建议。但他们都不是必须的。&lt;/p>
&lt;p>假设任何进程和设备都有可能产生事件消息。可能包含没有任何本地存储空间的设备，例如打印机、路由器、集线器、交换机以及无盘工作站。在这种情况下，将事件消息传送到 collector 可能是必要的，以便操作者可以记录并希望看到它们。&lt;/p>
&lt;h2 id="日志的收集">日志的收集&lt;/h2>
&lt;p>日志收集起来，才能方便管理人员进行查看并进行故障排除。如此众多事物的日志如果想要统一管理，就需要一套程序来对所有事物的日志进行收集、处理、保存、过滤、分析等，可以实现该功能的程序有以下几个：&lt;/p>
&lt;ul>
&lt;li>sysLog 程序与 syslog 标准重名，是早期的 Linux 用于处理系统上所有事物日志的程序&lt;/li>
&lt;li>RsysLog 是 sysLog 的升级版&lt;/li>
&lt;li>ELK/EFK 是很重量级，功能很全的 3 款程序的统称
&lt;ul>
&lt;li>Eleasticsearch 是一个存储系统和搜索引擎&lt;/li>
&lt;li>logstash、Fluentd 日志收集&lt;/li>
&lt;li>kibana 日志的前端展示&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h2 id="日志的生成与收集的通用流程">日志的生成与收集的通用流程&lt;/h2>
&lt;p>当一个程序生成日志后，一般调用一个 output() 函数，把生成的日志输出到某处，e.g.文件、内存、STDOUT 等&lt;/p>
&lt;p>而日志采集程序一般会调用一个 input() 函数，来从某处获取日志，然后再调用 output() 函数来把日志转发或转存&lt;/p>
&lt;h1 id="the-syslog-protocol系统日志协议--即-syslog-规范">The Syslog Protocol(系统日志协议) # 即 syslog 规范&lt;/h1>
&lt;p>每个程序如果产生的日志格式都不一样，也不便于收集归档，更不便于分类查看，所以需要一个统的规范，这个规范包括可收集哪些程序的日志、日志的格式、级别的定义等&lt;/p>
&lt;h2 id="架构">架构&lt;/h2>
&lt;p>Syslog Protocol 采用分层架构设计，共分为 3 层&lt;/p>
&lt;ul>
&lt;li>&amp;ldquo;syslog content&amp;rdquo; syslog 内容层。is the management information contained in a syslog message.&lt;/li>
&lt;li>&amp;ldquo;syslog application&amp;quot;syslog 应用程序层。处理系统日志消息的生成、解释、路由、存储&lt;/li>
&lt;li>&amp;ldquo;syslog transport&amp;quot;syslog 传输层。将消息放到 puts messages on the wire and takes them off the wire.&lt;/li>
&lt;/ul>
&lt;p>每层架构中都会执行某些类型的功能&lt;/p>
&lt;ul>
&lt;li>originator：发起者。生成将要在消息中携带的 syslog 内容&lt;/li>
&lt;li>collector：采集器。收集 syslog 内容以供进一步分析&lt;/li>
&lt;li>relay：中继。转发消息，接收来自 originators 或其他 relaysd 的消息，并将其发送给 collectors 或其他 relays&lt;/li>
&lt;li>transport sender：传输发送器。将 syslog 消息传递给特定的传输协议&lt;/li>
&lt;li>transport receiver：传输接收器。从特定的传输协议获取 syslog 消息&lt;/li>
&lt;/ul>
&lt;h2 id="syslog-信息的构成格式">syslog 信息的构成格式&lt;/h2>
&lt;p>每个程序在编写的都时候都会定义日志格式，大部分都会遵循“syslog”标准。不同事物的日志格式不尽相同，详情请见相关事物的文档，不过一般情况下，日志内容都应该包含，时间，某物，在哪，做了什么。&lt;/p>
&lt;p>The Syslog Protocol 规定了每条 syslog 信息应该包含如下内容：&lt;/p>
&lt;p>HEADER Structured-Data [MSG] # 头部信息，结构化数据，消息主体&lt;/p>
&lt;ul>
&lt;li>HEADER=PRI VERSION TIMESTAMP HOSTNAME # 优先级、版本、时间出、主机名
&lt;ul>
&lt;li>PRI=Facility*8+Severity # Priority 优先级是一个值，计算方式通过两部分计算，“Facility 设施”与“Severity 严重性”。具体见本章下文具体描述&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Structured-Data= #&lt;/li>
&lt;/ul>
&lt;h3 id="facility设施">Facility(设施)&lt;/h3>
&lt;p>Facility 用来表示产生该信息的硬件设备、协议、系统软件、操作系统等可以产生日志消息的事物类别。由于世界上事物太多，所以最好以类别的方式来对各个事务进行分类，所以使用 &lt;strong>Facility(设施)&lt;/strong> 来描述。比如&lt;code>security/authorization&lt;/code>这个设施中就包含很多关于安全认证的应用程序产生的日志类别。&lt;/p>
&lt;p>每个 Facility 都对应一个值以便进行 PRI 的计算，以下是 RFC5424 中规定的几十类 Facility。其中括号中的数字表示 Facility 对应的 Numerical Code(数字码)。&lt;/p>
&lt;ul>
&lt;li>&lt;strong>kernel messages(0)&lt;/strong> # 内核信息类&lt;/li>
&lt;li>&lt;strong>user-level messages(1)&lt;/strong> # 用户层信息类，比如用户使用 logger 命令来记录日志功能&lt;/li>
&lt;li>&lt;strong>mail system(2)&lt;/strong> # 邮件系统类型&lt;/li>
&lt;li>&lt;strong>system daemons(3)&lt;/strong> # 系统守护进程类，比如 systemd 管理的服务的信息。&lt;/li>
&lt;li>&lt;strong>security/authorization messages(4)&lt;/strong> # 安全与认证信息类，比如 login、ssh、su 等需要账号密码的。&lt;/li>
&lt;li>&lt;strong>messages generated internally by syslogd(5)&lt;/strong> # 由 syslog 相关协议产生的信息类，就是 rsyslog 程序本身的日志信息。&lt;/li>
&lt;li>&lt;strong>line printer subsystem(6)&lt;/strong> # 打印子系统类&lt;/li>
&lt;li>&lt;strong>network news subsystem(7)&lt;/strong> #&lt;/li>
&lt;li>&lt;strong>UUCP subsystem(8)&lt;/strong> #&lt;/li>
&lt;li>&lt;strong>clock daemon(9)&lt;/strong> #&lt;/li>
&lt;li>&lt;strong>security/authorization messages(10)&lt;/strong> #&lt;/li>
&lt;li>&lt;strong>FTP daemon(11)&lt;/strong> # FTP&lt;/li>
&lt;li>&lt;strong>NTP subsystem(12)&lt;/strong> # NTP 子系统&lt;/li>
&lt;li>&lt;strong>log audit(13)&lt;/strong> # 日志审计&lt;/li>
&lt;li>&lt;strong>log alert(14)&lt;/strong> # 日志报警&lt;/li>
&lt;li>&lt;strong>clock daemon(note 2)(15)&lt;/strong> #&lt;/li>
&lt;li>&lt;strong>local use 0~7 (local0~7)(16~23)&lt;/strong> # 留给用户自定义的类别，比如可以把某些程序归为 Local0~7 中的某一类，然后来收集该类的日志&lt;/li>
&lt;/ul>
&lt;h3 id="severity">Severity&lt;/h3>
&lt;p>Severity 用来表示该日志信息的严重程度，也叫日志的级别 Level。为了便于日志管理，需要对日志的内容进行划分，哪些信息是正常的，哪些信息是错误的，哪些信息是警告等等。一般情况分为以下几类，其中第一列数字表示对应的 Severity 的值，第二列为 Severity 的名称以及其所描述的严重程度的具体概念。以下严重程度由高到底进行排列，debug 属于特殊的 Severity&lt;/p>
&lt;ul>
&lt;li>0 Emergency: 系统不可用 system is unusable&lt;/li>
&lt;li>1 Alert: 必须立即采取行动 action must be taken immediately&lt;/li>
&lt;li>2 Critical: 临界状态 critical conditions&lt;/li>
&lt;li>3 Error: 错误状态 error conditions&lt;/li>
&lt;li>4 Warning: 警告状态 warning conditions&lt;/li>
&lt;li>5 Notice: 正常但是值得注意的状态 normal but significant condition&lt;/li>
&lt;li>6 Informational: 信息 informational messages&lt;/li>
&lt;li>7 Debug: debug 级别的信息 debug-level messages&lt;/li>
&lt;/ul>
&lt;h1 id="常见日志级别">常见日志级别&lt;/h1>
&lt;p>Emergency ( 紧急 ): 关于 SYN 攻击、Tear Drop 攻击及 Ping of Death 攻击的消息。
Alert ( 警示 ): 关于需要立即引起注意的情况 ( 例如防火墙攻击和许可密钥到期 ) 的消息。
Critical (关键 ): 关于可能影响设备功能的情况 [例如高可用性 (HA) 状态更改 ]的消息。
Error (错误): 关于可能影响设备功能的错误情况 (例如反病毒扫描失败或与 SSH 服务器通信失败) 的消息。
Warning( 警告 ):关于可能影响设备功能的情况(例如连接到电子邮件服务器失败或认证失败、超时和成功)的消息。
Notification (通知 ): 关于常规事件 ( 包括由 admin 发起的配置更改 ) 的消息。
Information ( 信息 ): 可提供关于系统操作一般信息的消息。
Debugging ( 调试 ): 可提供调试时所用详细信息的消息。&lt;/p></description></item><item><title>Docs: 文件管理</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2.kernel%E5%86%85%E6%A0%B8/6.file_system_%E7%AE%A1%E7%90%86/%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86/%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2.kernel%E5%86%85%E6%A0%B8/6.file_system_%E7%AE%A1%E7%90%86/%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86/%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Computer_file">Wiki,Computer file&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Category:Computer_files">Wiki-Category,Computer files&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/End-of-file">Wiki,End of file&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://mp.weixin.qq.com/s/qJdoXTv_XS_4ts9YuzMNIw">公众号，小林 coding-一口气搞懂「文件系统」，就靠这 25 张图了&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://mp.weixin.qq.com/s/tXEfsLqdePjcPS6FKa-qzg">另一个公众号&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>从[文件系统](&amp;lt;/docs/IT学习笔记/1.操作系统/2.Kernel(内核)/6.File%20System%20 管理/6.File%20System%20 管理.md&amp;raquo;)文章可以看出来，File(文件) 是一个组织存储在计算机中数据的逻辑概念，以便让人们可以清楚得知道每一段数据的起始位置、结束位置，甚至可以通过为文件命名来立刻反应过来这段数据的作用。&lt;/p>
&lt;p>所谓的查看文件，其实是指找到一段数据的开头和结尾，并查看这段数据。对于程序员来说文件是一个很简单的概念，我们只需要将其理解为一个 N byte 的序列就可以了：**b1, b2, b3, b4, &amp;hellip;&amp;hellip;. bN。**程序员使用 I/O 最终都逃不过文件。&lt;/p>
&lt;p>所有的 I/O 设备都被抽象为了文件这个概念，&lt;strong>Everything is File(一切皆文件)&lt;/strong>，磁盘、网络数据、终端，甚至进程间通信工具管道等都被当做文件对待。
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/tudy8a/1616167656114-9b5d8779-6322-4740-aa6c-47ef53a1aef6.jpeg" alt="">
所有的 I/O 操作也都是通过文件读写来实现的，&lt;strong>这一非常优雅的抽象可以让程序员使用一套接口就能实现所有 I/O 操作&lt;/strong>。
常用的 I/O 操作接口一般有以下几类：&lt;/p>
&lt;ul>
&lt;li>打开文件，open&lt;/li>
&lt;li>改变读写位置，seek&lt;/li>
&lt;li>文件读写，read、write&lt;/li>
&lt;li>关闭文件，close&lt;/li>
&lt;/ul>
&lt;p>程序员通过这几个接口几乎可以实现所有 I/O 操作，这就是文件这个概念的强大之处。
在 Linux 中一切皆文件，目录也是文件的一种类型，就连块设备、套接字、终端、管道等等，都被当做 File(文件)来对待。
下面是一个在 Linux 中最常见的列出文件的命令 &lt;code>[ls -l](https://www.yuque.com/desistdaydream/learning/ynhtw7#bmqgU)&lt;/code> 所能查看的文件基本信息&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>~&lt;span style="color:#f92672">]&lt;/span>&lt;span style="color:#75715e"># ls -lh&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>total 20K
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>lrwxrwxrwx. &lt;span style="color:#ae81ff">1&lt;/span> root root &lt;span style="color:#ae81ff">7&lt;/span> May &lt;span style="color:#ae81ff">24&lt;/span> &lt;span style="color:#ae81ff">2019&lt;/span> bin -&amp;gt; usr/bin
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>dr-xr-xr-x. &lt;span style="color:#ae81ff">5&lt;/span> root root 4.0K May &lt;span style="color:#ae81ff">24&lt;/span> &lt;span style="color:#ae81ff">2019&lt;/span> boot
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>drwxr-xr-x &lt;span style="color:#ae81ff">20&lt;/span> root root 3.1K May &lt;span style="color:#ae81ff">14&lt;/span> 09:38 dev
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>drwxr-xr-x. &lt;span style="color:#ae81ff">82&lt;/span> root root 8.0K Jun &lt;span style="color:#ae81ff">21&lt;/span> 19:42 etc
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>......
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;table>
&lt;thead>
&lt;tr>
&lt;th>类型与权限&lt;/th>
&lt;th>硬连接数&lt;/th>
&lt;th>所属主&lt;/th>
&lt;th>所属组&lt;/th>
&lt;th>大小&lt;/th>
&lt;th>时间&lt;/th>
&lt;th>文件名&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>lrwxrwxrwx.&lt;/td>
&lt;td>1&lt;/td>
&lt;td>root&lt;/td>
&lt;td>root&lt;/td>
&lt;td>7&lt;/td>
&lt;td>May 24 2019&lt;/td>
&lt;td>bin -&amp;gt; usr/bin&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>dr-xr-xr-x.&lt;/td>
&lt;td>5&lt;/td>
&lt;td>root&lt;/td>
&lt;td>root&lt;/td>
&lt;td>4.0K&lt;/td>
&lt;td>May 24 2019&lt;/td>
&lt;td>boot&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>drwxr-xr-x&lt;/td>
&lt;td>20&lt;/td>
&lt;td>root&lt;/td>
&lt;td>root&lt;/td>
&lt;td>3.1K&lt;/td>
&lt;td>May 14 09:38&lt;/td>
&lt;td>dev&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>&lt;code>类型与权限&lt;/code>这一列一共 11 个字符，共分为 3 个部分：&lt;/p>
&lt;ul>
&lt;li>第一部分 # 第 1 个字符为 &lt;a href="#%E6%96%87%E4%BB%B6%E7%9A%84%E7%B1%BB%E5%9E%8B">文件的类型&lt;/a>，具体类型含义见下文&lt;/li>
&lt;li>第二部分 # 中间 9 个字符。用来表示文件的基本权限，详见&lt;a href="#%E6%96%87%E4%BB%B6%E7%9A%84%E6%9D%83%E9%99%90">文件的权限&lt;/a>部分。
&lt;ul>
&lt;li>第一组为文件拥有者的权限&lt;/li>
&lt;li>第二组是文件所属组的权限&lt;/li>
&lt;li>第三组是其他的权限。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>第三部分 # 最后 1 个字符。用来表示该文件是否有其他权限特殊权限管理该文件的访问。
&lt;ul>
&lt;li>&lt;code>+&lt;/code> # 具有 &lt;a href="https://desistdaydream.github.io/docs/IT%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/5.%E7%99%BB%E5%BD%95%20Linux%20%E4%B8%8E%20%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6/Access%20Control(%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6)/ACL.md">ACL&lt;/a> 的文件。&lt;/li>
&lt;li>&lt;code>.&lt;/code> # 具有 &lt;a href="https://desistdaydream.github.io/docs/IT%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/5.%E7%99%BB%E5%BD%95%20Linux%20%E4%B8%8E%20%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6/SELinux/SELinux.md">SELinux&lt;/a> 安全上下文的文件。若没有 &lt;code>.&lt;/code>，则该文件不受 SELinux 控制。&lt;/li>
&lt;li>注意：
&lt;ul>
&lt;li>当添加了 ACL 权限后，只显示 &lt;code>+&lt;/code>，&lt;code>.&lt;/code> 看不到了。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>简单示例：
&lt;ul>
&lt;li>比如上面例子中 boot 文件第一列属性为 &lt;code>dr-xr-xr-x.&lt;/code> 表示该文件是一个目录，文件的拥有者、属组、其他，都具有 r 和 x 权限(i.e.读和执行权限)，由 SELinux 管理。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>&lt;code>时间&lt;/code> 这一列中包含如下几种：&lt;/p>
&lt;ul>
&lt;li>&lt;strong>atime&lt;/strong> # 访问时间。读取文件或者执行文件时，该时间会变化&lt;/li>
&lt;li>&lt;strong>ctime&lt;/strong> # 在写入文件、更改所有者、权限或链接设置时随 Inode 的内容更改而更改的时间&lt;/li>
&lt;li>&lt;strong>mtime&lt;/strong> # 在写入文件时随文件内容的更改而更改的时间。&lt;code>默认限制这个时间&lt;/code>。&lt;/li>
&lt;/ul>
&lt;h2 id="文件的类型">文件的类型&lt;/h2>
&lt;p>Linux 中的文件有下面几种类型(左侧是该类型文件的标识符)：&lt;/p>
&lt;ul>
&lt;li>**- **# 普通文件&lt;/li>
&lt;li>&lt;strong>b&lt;/strong> # 块设备&lt;/li>
&lt;li>&lt;strong>c&lt;/strong> # 字符设备&lt;/li>
&lt;li>&lt;strong>d&lt;/strong> # 目录&lt;/li>
&lt;li>&lt;strong>D&lt;/strong> # door(Solaris) 这是啥？~&lt;/li>
&lt;li>&lt;strong>l&lt;/strong> # 符号链接&lt;/li>
&lt;li>&lt;strong>M&lt;/strong> # off-line(migrated) 文件（Cray DMF） 这是啥？~&lt;/li>
&lt;li>&lt;strong>n&lt;/strong> # 网络专用文件&lt;/li>
&lt;li>&lt;strong>p&lt;/strong> # FIFO(管道)&lt;/li>
&lt;li>&lt;strong>P&lt;/strong> # 端口&lt;/li>
&lt;li>**s **# 套接字&lt;/li>
&lt;li>&lt;strong>?&lt;/strong> # 其他文件类型&lt;/li>
&lt;/ul>
&lt;blockquote>
&lt;p>Note：占用存储空间的类型：文件、目录、符号链接(符号链接记录的是路径路径不长时存在 innode 里面)。其他四种：套接字、块设备、字符设备、管道是伪文件，不占用磁盘空间。&lt;/p>
&lt;/blockquote>
&lt;h2 id="文件的权限">文件的权限&lt;/h2>
&lt;p>文件最基本的权限详见 《&lt;a href="https://desistdaydream.github.io/docs/IT%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/5.%E7%99%BB%E5%BD%95%20Linux%20%E4%B8%8E%20%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6/Access%20Control(%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6)/Access%20Control(%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6).md">Access Control(访问控制)&lt;/a>》章节，Linux 中的所有文件都可以被三个拥有者拥有，每个拥有者又可以具有 3 个权限
除了上述基于角色的权限以外，文件还可以具有高级权限，比如 ACL、SUID、SGID、SBIT、chattr 命令添加的权限、SELinux 控制的权限，等等等。&lt;/p>
&lt;h1 id="文件的使用">文件的使用&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Hard_link">Wiki,Hard link&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Symbolic_link">WIki,Symbolic link&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>从&lt;a href="https://desistdaydream.github.io/docs/IT%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2.Kernel(%E5%86%85%E6%A0%B8)/6.File_System_%E7%AE%A1%E7%90%86/6.File_System_%E7%AE%A1%E7%90%86#%E6%96%87%E4%BB%B6%E7%BB%84%E7%BB%87%E7%BB%93%E6%9E%84">文件系统章节中的文件组织结构&lt;/a>可知，我们使用 &lt;a href="docs/IT%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2.Kernel(%E5%86%85%E6%A0%B8)/6.File_System_%E7%AE%A1%E7%90%86/%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86/Inode.md">Inode(索引节点)&lt;/a> 定位一个文件。而打开文件后，我们可以获取到文件的 [FileDesc(文件描述符)](/docs/IT学习笔记/1.操作系统/2.Kernel(内核)/6.File%20System%20管理/文件管理/File%20Descriptor(文件描述符).md Descriptor(文件描述符).md)，所有对文件的读写操作，都是基于文件描述符进行的。&lt;/p>
&lt;p>&lt;strong>我们平时看到的人类可读的文件名，实际上是一个指向 Inode 的硬连接&lt;/strong>。&lt;/p>
&lt;h2 id="symbolic-link符合链接-与-hard-link硬链接">Symbolic link(符合链接) 与 Hard link(硬链接)&lt;/h2>
&lt;p>在计算机中 **Symbolic link(符号链接，也称为 软连接) **与 &lt;strong>Hard link(硬连接)&lt;/strong> 都是用以指向一个目标的文件或路径。&lt;/p>
&lt;ul>
&lt;li>Hard link 是将名称与文件相关联的 directory entry(目录项)，目录项概念详见《&lt;a href="docs/IT%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2.Kernel(%E5%86%85%E6%A0%B8)/6.File_System_%E7%AE%A1%E7%90%86/_index.md">文件系统管理&lt;/a>》章节&lt;/li>
&lt;li>Symbolic link 是一个文件，通过指定路径指向一个目标(文件或目录)&lt;/li>
&lt;/ul>
&lt;p>在文件系统中，人类看到的每个文件都是一个 inode 的硬连接。为文件创建额外的硬链接使得该文件的内容可以通过额外的路径访问（即通过不同的名称或在不同的目录中）。但是并不一定需要软链接，软链接与目标文件本质上是两个完全不通的文件。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>~/tmp&lt;span style="color:#f92672">]&lt;/span>&lt;span style="color:#75715e"># ls -il&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>total &lt;span style="color:#ae81ff">0&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">917508&lt;/span> -rw-r--r-- &lt;span style="color:#ae81ff">2&lt;/span> root root &lt;span style="color:#ae81ff">0&lt;/span> Dec &lt;span style="color:#ae81ff">15&lt;/span> 13:15 hard
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">917509&lt;/span> lrwxrwxrwx &lt;span style="color:#ae81ff">1&lt;/span> root root &lt;span style="color:#ae81ff">4&lt;/span> Dec &lt;span style="color:#ae81ff">15&lt;/span> 13:15 hardln -&amp;gt; hard
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">917508&lt;/span> -rw-r--r-- &lt;span style="color:#ae81ff">2&lt;/span> root root &lt;span style="color:#ae81ff">0&lt;/span> Dec &lt;span style="color:#ae81ff">15&lt;/span> 13:15 hardln2
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>在这里 hard 是原始文件，inode 为 917508&lt;/p>
&lt;ul>
&lt;li>hardln 是一个软链接，inode 为 917509，hardln 指向的 hard 文件的 inode 则是 917508&lt;/li>
&lt;li>hardln2 与 hard 本质上都是 inode 为 917508 的文件
&lt;ul>
&lt;li>可以这么说， hard 与 hardln2 都是一个指向 inode 为 917508 的硬连接。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>硬链接是&lt;strong>多个目录项中的 inode(索引节点)指向一个文件&lt;/strong>，也就是指向同一个 inode，但是 inode 是不可能跨越文件系统的，每个文件系统都有各自的 inode 数据结构和列表，所以&lt;strong>硬链接是不可用于跨文件系统的&lt;/strong>。由于多个目录项都是指向一个 inode，那么&lt;strong>只有删除文件的所有硬链接以及源文件时，系统才会彻底删除该文件。&lt;/strong>
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/tudy8a/1616167677117-992b018e-1ff6-4d7e-88f2-5783e0d0dadc.png" alt="">
如何查看硬链接的文件都在哪：&lt;/p>
&lt;ul>
&lt;li>使用 &lt;code>ls -i&lt;/code>，查看该硬链接的索引节点号。&lt;/li>
&lt;li>使用 &lt;code>find / -inum XXXX&lt;/code>，查看具有该索引节点号的所有文件所在位置。&lt;/li>
&lt;/ul>
&lt;p>注：&lt;code>rm ${find ./ -inum 2310630}&lt;/code> 搜索节点 2310630 的文件，并删除。&lt;/p>
&lt;p>软链接相当于重新创建一个文件，这个文件有&lt;strong>独立的 inode&lt;/strong>，但是这个&lt;strong>文件的内容是另外一个文件的路径&lt;/strong>，所以访问软链接的时候，实际上相当于访问到了另外一个文件，所以&lt;strong>软链接是可以跨文件系统的&lt;/strong>，甚至&lt;strong>目标文件被删除了，链接文件还是在的，只不过指向的文件找不到了而已。&lt;/strong>
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/tudy8a/1616167677115-040a0c08-44ba-46b8-900a-db111dc7c93c.png" alt="">
软链接目标文件只能是一个文件，通过该文件指向源文件或者文件夹，类似于 windows 的快捷方式，软连接会创建一个单独的 inode。&lt;/p>
&lt;p>如何查看软连接的文件都在哪：&lt;/p>
&lt;ul>
&lt;li>find -type l # 查看当前目录下的所有软连接文件&lt;/li>
&lt;li>ls -l ${find -type l} # 通过反引号先执行查找命令，然后查找到的结果用 ls -l 显示详细信息&lt;/li>
&lt;li>find /etc -type l -exec ls -l {} ; | grep ifcfg-eth1 # 查找/etc 下的软链接文件，并且显示详细信息，然后筛选这些信息中包含 ifcfg-eth1 的条目&lt;/li>
&lt;/ul>
&lt;h2 id="文件的读写过程">文件的读写过程&lt;/h2>
&lt;p>我们从用户角度来看文件的话，就是我们要怎么使用文件？首先，我们得通过系统调用来打开一个文件。
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/tudy8a/1616167677045-043724c9-8f38-483d-b322-1e474f0568d1.png" alt="">&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-c" data-lang="c">&lt;span style="display:flex;">&lt;span>fd &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#a6e22e">open&lt;/span>(name, flag); &lt;span style="color:#960050;background-color:#1e0010">#&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">打开文件&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>...&lt;span style="color:#a6e22e">write&lt;/span>(fd,...); &lt;span style="color:#960050;background-color:#1e0010">#&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">写数据&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>...&lt;span style="color:#a6e22e">close&lt;/span>(fd); &lt;span style="color:#960050;background-color:#1e0010">#&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">关闭文件&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>上面简单的代码是读取一个文件的过程：&lt;/p>
&lt;ul>
&lt;li>首先用 &lt;code>open&lt;/code> 系统调用打开文件，&lt;code>open&lt;/code> 的参数中包含文件的路径名和文件名。&lt;/li>
&lt;li>使用 &lt;code>write&lt;/code> 写数据，其中 &lt;code>write&lt;/code> 使用 &lt;code>open&lt;/code> 所返回的&lt;strong>文件描述符&lt;/strong>，并不使用文件名作为参数。&lt;/li>
&lt;li>使用完文件后，要用 &lt;code>close&lt;/code> 系统调用关闭文件，避免资源的泄露。&lt;/li>
&lt;/ul>
&lt;p>我们打开了一个文件后，操作系统会跟踪进程打开的所有文件，所谓的跟踪呢，就是操作系统为每个进程维护一个打开文件表，文件表里的每一项代表「&lt;strong>文件描述符&lt;/strong>」，所以说文件描述符是打开文件的标识。
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/tudy8a/1616167677065-7a31a536-72df-48b0-adcf-06883b40ed19.png" alt="">
操作系统在打开文件表中维护着打开文件的状态和信息：&lt;/p>
&lt;ul>
&lt;li>文件指针：系统跟踪上次读写位置作为当前文件位置指针，这种指针对打开文件的某个进程来说是唯一的；&lt;/li>
&lt;li>文件打开计数器：文件关闭时，操作系统必须重用其打开文件表条目，否则表内空间不够用。因为多个进程可能打开同一个文件，所以系统在删除打开文件条目之前，必须等待最后一个进程关闭文件，该计数器跟踪打开和关闭的数量，当该计数为 0 时，系统关闭文件，删除该条目；&lt;/li>
&lt;li>文件磁盘位置：绝大多数文件操作都要求系统修改文件数据，该信息保存在内存中，以免每个操作都从磁盘中读取；&lt;/li>
&lt;li>访问权限：每个进程打开文件都需要有一个访问模式（创建、只读、读写、添加等），该信息保存在进程的打开文件表中，以便操作系统能允许或拒绝之后的 I/O 请求；&lt;/li>
&lt;/ul>
&lt;p>在用户视角里，文件就是一个持久化的数据结构，但操作系统并不会关心你想存在磁盘上的任何的数据结构，操作系统的视角是如何把文件数据和磁盘块对应起来。&lt;/p>
&lt;p>所以，用户和操作系统对文件的读写操作是有差异的，用户习惯以字节的方式读写文件，而操作系统则是以数据块来读写文件，那屏蔽掉这种差异的工作就是文件系统了。&lt;/p>
&lt;p>我们来分别看一下，读文件和写文件的过程：&lt;/p>
&lt;ul>
&lt;li>当用户进程从文件读取 1 个字节大小的数据时，文件系统则需要获取字节所在的数据块，再返回数据块对应的用户进程所需的数据部分。&lt;/li>
&lt;li>当用户进程把 1 个字节大小的数据写进文件时，文件系统则找到需要写入数据的数据块的位置，然后修改数据块中对应的部分，最后再把数据块写回磁盘。&lt;/li>
&lt;/ul>
&lt;p>所以说，&lt;strong>文件系统的基本操作单位是数据块&lt;/strong>。&lt;/p>
&lt;h1 id="目录的存储">目录的存储&lt;/h1>
&lt;p>基于 Linux 一切皆文件的设计思想，目录其实也是个文件，你甚至可以通过 &lt;code>vim&lt;/code> 打开它，它也有 inode，inode 里面也是指向一些块。&lt;/p>
&lt;p>和普通文件不同的是，&lt;strong>普通文件的块里面保存的是文件数据，而目录文件的块里面保存的是目录里面一项一项的文件信息。&lt;/strong>&lt;/p>
&lt;p>在目录文件的块中，最简单的保存格式就是&lt;strong>列表&lt;/strong>，就是一项一项地将目录下的文件信息（如文件名、文件 inode、文件类型等）列在表里。&lt;/p>
&lt;p>列表中每一项就代表该目录下的文件的文件名和对应的 inode，通过这个 inode，就可以找到真正的文件。
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/tudy8a/1616167677111-6682b310-2f92-4f63-b22a-9821ba99345c.png" alt="">
目录格式哈希表通常，第一项是「&lt;code>.&lt;/code>」，表示当前目录，第二项是「&lt;code>..&lt;/code>」，表示上一级目录，接下来就是一项一项的文件名和 inode。&lt;/p>
&lt;p>如果一个目录有超级多的文件，我们要想在这个目录下找文件，按照列表一项一项的找，效率就不高了。&lt;/p>
&lt;p>于是，保存目录的格式改成&lt;strong>哈希表&lt;/strong>，对文件名进行哈希计算，把哈希值保存起来，如果我们要查找一个目录下面的文件名，可以通过名称取哈希。如果哈希能够匹配上，就说明这个文件的信息在相应的块里面。&lt;/p>
&lt;p>Linux 系统的 ext 文件系统就是采用了哈希表，来保存目录的内容，这种方法的优点是查找非常迅速，插入和删除也较简单，不过需要一些预备措施来避免哈希冲突。&lt;/p>
&lt;p>目录查询是通过在磁盘上反复搜索完成，需要不断地进行 I/O 操作，开销较大。所以，为了减少 I/O 操作，把当前使用的文件目录缓存在内存，以后要使用该文件时只要在内存中操作，从而降低了磁盘操作次数，提高了文件系统的访问速度。&lt;/p></description></item><item><title>Docs: 系统审计</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E7%B3%BB%E7%BB%9F%E5%AE%A1%E8%AE%A1/%E7%B3%BB%E7%BB%9F%E5%AE%A1%E8%AE%A1/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E7%B3%BB%E7%BB%9F%E5%AE%A1%E8%AE%A1/%E7%B3%BB%E7%BB%9F%E5%AE%A1%E8%AE%A1/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/7/html/security_guide/chap-system_auditing">红帽产品文档，RedHat7-安全指南-第 7 章 系统审计&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>Linux 审计系统提供了一种方式来跟踪系统中的安全相关信息。根据预配置的规则，审计会生成日志条目，以记录有关系统上发生事件的尽可能多的信息。对于关键任务环境而言，此信息对于确定安全策略的违反者及其执行的操作至关重要。Audit 不会为您的系统提供额外的安全性，而是可用于发现系统上使用的安全策略违规。通过 SELinux 等其他安全措施可以进一步阻止这些冲突。&lt;/p>
&lt;p>以下列表总结了审计可以在其日志文件中记录的一些信息：&lt;/p>
&lt;ul>
&lt;li>事件的日期和时间、类型和结果.&lt;/li>
&lt;li>主题和对象的敏感度标签。&lt;/li>
&lt;li>事件与触发事件的用户的身份相关联。&lt;/li>
&lt;li>对 Audit 配置的所有修改，并尝试访问 Audit 日志文件。&lt;/li>
&lt;li>所有身份验证机制的使用，如 SSH 和 Kerberos 等。&lt;/li>
&lt;li>对任何受信任数据库的更改，如 /etc/passwd.&lt;/li>
&lt;li>尝试从系统导入或导出信息.&lt;/li>
&lt;li>根据用户身份、主题和对象标签以及其他属性，包含或排除事件。&lt;/li>
&lt;/ul>
&lt;p>使用审计系统也是许多安全相关认证的一项要求。审计旨在满足或超过以下认证或合规指南的要求：&lt;/p>
&lt;ul>
&lt;li>受控访问保护配置文件(CAPP)&lt;/li>
&lt;li>标记的安全保护配置文件(LSPP)&lt;/li>
&lt;li>规则集基本访问控制(RSBAC)&lt;/li>
&lt;li>国家工业安全计划操作手册(NISPOM)&lt;/li>
&lt;li>联邦信息安全管理法案(FISMA)&lt;/li>
&lt;li>支付卡行业 - 数据安全标准(PCI-DSS)&lt;/li>
&lt;li>安全技术实施指南(STIG)&lt;/li>
&lt;/ul>
&lt;p>审计还包括：&lt;/p>
&lt;ul>
&lt;li>由国家信息保障合作伙伴(NIAP)和最佳安全行业(BSI)评估。&lt;/li>
&lt;li>通过红帽企业 Linux 5 上的 LSPP/CAPP/RSBAC/EAL4+ 认证.&lt;/li>
&lt;li>红帽企业 Linux 6 上经过操作系统保护配置文件/评估保证级别 4+(OSPP/EAL4+)认证.&lt;/li>
&lt;/ul>
&lt;h3 id="使用案例">使用案例&lt;/h3>
&lt;p>&lt;strong>监视文件访问&lt;/strong> # 审计可以跟踪文件或目录是否已访问、修改、执行或文件属性是否已更改。例如，这可用于检测对重要文件的访问，并在其中一个文件损坏时提供审计跟踪。&lt;/p>
&lt;p>&lt;strong>监控系统调用&lt;/strong> # 可将审计配置为在每次使用特定系统调用时生成日志条目。例如，这可用于通过监控 settimeofday、clock_adjtime 和其他时间相关系统调用来跟踪系统时间的更改。&lt;/p>
&lt;p>&lt;strong>记录用户运行的命令&lt;/strong> # 审计可以跟踪文件是否已执行，因此可以定义规则以记录特定命令的每次执行。例如，可以为 /bin 目录中的每个可执行文件定义规则。然后，可以按用户 ID 搜索生成的日志条目，以生成每个用户所执行命令的审计跟踪。&lt;/p>
&lt;p>&lt;strong>记录系统路径名称的执行&lt;/strong> # 除了观察在规则调用时转换索引节点路径的文件访问之外，审计现在还可以观察路径的执行，即使路径在规则调用中不存在，或者在规则调用后替换了文件。这允许规则在升级程序可执行文件或甚至安装之前继续运行。&lt;/p>
&lt;p>&lt;strong>记录安全事件&lt;/strong> # pam_faillock 身份验证模块能够记录失败的登录尝试。也可以将审计设置为记录失败的登录尝试，并提供试图登录的用户的附加信息。&lt;/p>
&lt;p>&lt;strong>搜索事件&lt;/strong> # Audit 提供 ausearch 实用程序，可用于过滤日志条目并根据多个条件提供完整的审计跟踪。&lt;/p>
&lt;p>&lt;strong>运行摘要报告&lt;/strong> # aureport 实用程序可用于生成记录的事件的日常报告等。然后，系统管理员可以分析这些报告，并进一步调查可疑活动。&lt;/p>
&lt;p>&lt;strong>监控网络访问&lt;/strong> # iptables 和 ebtables 实用程序可以配置为触发审计事件，使系统管理员能够监控网络访问。&lt;/p></description></item><item><title>Docs: 性能评估与故障处理</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/x.linux-%E7%AE%A1%E7%90%86/%E6%80%A7%E8%83%BD%E8%AF%84%E4%BC%B0%E4%B8%8E%E6%95%85%E9%9A%9C%E5%A4%84%E7%90%86/%E6%80%A7%E8%83%BD%E8%AF%84%E4%BC%B0%E4%B8%8E%E6%95%85%E9%9A%9C%E5%A4%84%E7%90%86/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/x.linux-%E7%AE%A1%E7%90%86/%E6%80%A7%E8%83%BD%E8%AF%84%E4%BC%B0%E4%B8%8E%E6%95%85%E9%9A%9C%E5%A4%84%E7%90%86/%E6%80%A7%E8%83%BD%E8%AF%84%E4%BC%B0%E4%B8%8E%E6%95%85%E9%9A%9C%E5%A4%84%E7%90%86/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://time.geekbang.org/column/intro/100020901">极客时间,Linux 性能优化实战&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://mp.weixin.qq.com/s/Tnerf7M_a6HUC4ucaOWzeg">公众号,刘超的通俗云计算-读完这篇文章，就再也不怕遇到网络问题啦&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;h1 id="常见问题简述">常见问题简述&lt;/h1>
&lt;p>当你发现某台机器无论做什么都慢, 而 cpu 和内核却不是瓶颈的时候, 那有可能是内核慢了。机器上定时任务的执行过多, 内核缓存一直增加, 导致内核速度变慢了. 它一变慢, 引发了 tcp 握手时间变长, 最后造成用户体验下降. 既然发现了问题, 解决方案也比较容易搜索到了, 增加任务, 检查内核是否变慢, 慢了的话就清理一次：&lt;code>sync &amp;amp;&amp;amp; echo 3 &amp;gt; /proc/sys/vm/drop_caches&lt;/code>&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/behafi/1647529106727-4e5af00a-e6ee-4b86-9b82-cec9262f4601.png" alt="image.png">
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/behafi/1647529081502-9a4d7eae-e062-48bb-bdf7-24a6ffef8d67.png" alt="image.png">
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/behafi/1647529150105-9e34e168-1ad1-4896-a501-9cb77aa38661.png" alt="image.png">&lt;/p></description></item><item><title>Docs: 字符的编码与解码</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/8.%E9%80%9A%E7%94%A8%E6%8A%80%E6%9C%AF/%E7%BC%96%E7%A0%81%E8%A7%A3%E7%A0%81%E4%B8%8E%E5%8D%8F%E8%AE%AE/%E5%AD%97%E7%AC%A6%E7%9A%84%E7%BC%96%E7%A0%81%E4%B8%8E%E8%A7%A3%E7%A0%81/%E5%AD%97%E7%AC%A6%E7%9A%84%E7%BC%96%E7%A0%81%E4%B8%8E%E8%A7%A3%E7%A0%81/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/8.%E9%80%9A%E7%94%A8%E6%8A%80%E6%9C%AF/%E7%BC%96%E7%A0%81%E8%A7%A3%E7%A0%81%E4%B8%8E%E5%8D%8F%E8%AE%AE/%E5%AD%97%E7%AC%A6%E7%9A%84%E7%BC%96%E7%A0%81%E4%B8%8E%E8%A7%A3%E7%A0%81/%E5%AD%97%E7%AC%A6%E7%9A%84%E7%BC%96%E7%A0%81%E4%B8%8E%E8%A7%A3%E7%A0%81/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Character_encoding">Wiki,Character encoding&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/ASCII">Wiki-ASCII&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Unicode">Wiki-Unicode&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://home.unicode.org/">Unicode 官网&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://unicode.org/main.html">Unicode 技术网站&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.unicode.org/charts/unihan.html">Unicode 字符集汉子数据库&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Variable-length_code">Wiki,Variable-length code&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/UTF-8">Wiki-UTF-8&lt;/a>&lt;/li>
&lt;li>&lt;a href="http://www.ruanyifeng.com/blog/2007/10/ascii_unicode_and_utf-8.html">阮一峰博客&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://mp.weixin.qq.com/s/vTh4LP8_Qew-S8s-3KqwJA">公众号,k8s 技术圈-计算机字符编码的前世今生&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.bilibili.com/video/av246038798">B 站,Golang 合辑-P1 string(这个 P 讲的就是字符的编码与解码)&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>我们知道计算机只认识二进制数据，其他格式的数据都需要转换成二进制才能被计算机处理，也就是说我们在计算机上看到的文本、视频、可执行程序等格式的文件，最终都会转换成二进制数据交给计算机处理&lt;/p>
&lt;p>计算机中最小的数据单位是 &lt;strong>bit&lt;/strong>，也叫&lt;strong>二进制位(简称：位)&lt;/strong>，每一个 bit 都有 0 和 1 两种状态，最早的计算机在设计时采用了 &lt;strong>8 个 bit 作为一个 Byte(字节)&lt;/strong>，所以一个字节能表示的最大整数就是二进制的 11111111 等于十进制的 255，一共 256 个数字(即.0~255)，想要表示更大的整数就必须要用多个字节，例如两个字节可以表示最大的整数就是二进制的 1111111111111111，共 16 位，等于十进制的 65535。&lt;/p>
&lt;p>更多的字节，就可以表示更大的数值范围，比如 32 位，最大可以表示为 4,294,967,295，我们平时说的 32 位电脑、64 位电脑，也是同一个意思，所以就说 32 位电脑，没法传输 4 G 以上的文件，就是因为其最大可以表示的数字就是 4,294,967,295，更大的文件，已经无法识别了。整数可以这么表示，那么字符怎么办呢？一堆二进制的 0 和 1，任何计算都无法算出字母 A 吧？~o(╯□╰)o&lt;/p>
&lt;p>聪明的人类啊~~~如果无法通过计算得到，那么就中转一下，人为规定就好了~比如：&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>字符&lt;/th>
&lt;th>十进制编号&lt;/th>
&lt;th>二进制编号&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>A&lt;/td>
&lt;td>65&lt;/td>
&lt;td>0100 0001&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>B&lt;/td>
&lt;td>66&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&amp;hellip;&amp;hellip;&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>a&lt;/td>
&lt;td>97&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&amp;hellip;&amp;hellip;&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>要存储字符时，就存储这个数值；要读取字符时，按照映射关系，找到这个字符；就像这样，收录许多字符，然后给它们一一编号，得到一个字符与编号的对照表，这就是 &lt;strong>Character sets(字符集)&lt;/strong>，经过这么多年的发展，大家对这个术语有很多种叫法：Character encoding(字符编码)、Character map(字符映射)、Code page(代码页) 都可以表示同一个概念。&lt;/p>
&lt;h1 id="ascii">ASCII&lt;/h1>
&lt;p>由于计算机是由美国人发明的，在 1967 年美国人制订了一套&lt;strong>字符集&lt;/strong>，规定了包含大小写字母、数字和一些符号共计 128 个字符与二进制数字的对应关系，这一套字符编码被称为 &lt;strong>American Standard Code for Information Interchange(美国标准信息交换码，简称 ASCII)&lt;/strong>，ASCII 一直沿用至今。&lt;/p>
&lt;p>英文比较简单，用 128 个符号编码就够了，就算需要其他的对应关系，也只需要扩展一下 ASCII 即可，一个 Byte，一共可以表示 256 个字符。但是用来表示中文就不够了，单单汉字就有超过 8 万个，所以就有了针对中文的编码标准出现，例如我们经常见到的 GB2312 字符集，使用两个字节表示一个汉字，理论上最多可以表示 65535 个；没有繁体字也不行啊，所以出现了 BIG 5 字符集；但是依然有许多字符没被收录。&lt;/p>
&lt;p>世界上有上百种语言，每种语言都有自己的编码标准，例如韩文编码 EUC_KR，日文编码 Shift_JIS，俄文编码 KOI8-R，为了促进互联网的发展，本着全球化统一标准的目的，制作一个通用字符集，&lt;strong>Unicode 应运而生。&lt;/strong>&lt;/p>
&lt;h1 id="unicode">Unicode&lt;/h1>
&lt;p>**Universal Coded Character Set(通用编码的字符集，简称 Unicode)，&lt;strong>在汉语中又称为&lt;/strong> 万国码、国际码、统一码，**它于 1990 年开始研发，并于 1994 年正式公布。&lt;strong>Unicode&lt;/strong> 对世界上大部分的文字系统进行了整理，使每一个文字符号都用独一无二的编码表示，当前 Unicode 最新的版本为 2019 年 5 月公布的 12.1.0，已经收录超过 13 万个字符，很明显 2 个字节已经无法保证所有字符都独一无二了，实际上最新的 Unicode 规定可以占用 4 字节来表示一个字符，理论上最多能表示 231 共计 2147483648 个字符。&lt;/p>
&lt;p>Unicode 使用 16 进制格式来表示一个字符，比如：
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/gptlcx/1616470249845-a210b975-ff93-4945-ba7e-aa06332e2473.png" alt="image.png">
&lt;code>\u&lt;/code> 是一个用来表示 Unicode 的标记。当计算机识别到这个标记时，就会使用 Unicode 进行解码。&lt;code>4f60&lt;/code> 表示 &lt;code>你&lt;/code>，&lt;code>597d&lt;/code> 表示 &lt;code>好&lt;/code>。&lt;/p>
&lt;p>所以随着技术的发展，Unicode 慢慢成为了一种 &lt;strong>Unicode Standard(Unicode 标准)&lt;/strong>&lt;/p>
&lt;h2 id="unicode-的问题">Unicode 的问题&lt;/h2>
&lt;p>需要注意的是，Unicode 只是一个字符集，它只规定了符号的二进制代码，却没有规定这个二进制代码应该如何存储。&lt;/p>
&lt;p>比如，汉字 &lt;code>严&lt;/code> 的 Unicode 是十六进制数 &lt;code>4E25&lt;/code>，转换成二进制数足足有 15 个 bit 位(&lt;code>100111000100101&lt;/code>)，也就是说，这个符号的表示至少需要 2 个字节。表示其他更大的符号，可能需要 3 个字节或者 4 个字节，甚至更多。&lt;/p>
&lt;p>这里就有两个严重的问题，第一个问题是，如何才能区别 Unicode 和 ASCII ？计算机怎么知道三个字节表示一个符号，而不是分别表示三个符号呢？第二个问题是，我们已经知道，英文字母只用一个字节表示就够了，如果 Unicode 统一规定，每个符号用三个或四个字节表示，那么每个英文字母前都必然有二到三个字节是 0，这对于存储来说是极大的浪费，文本文件的大小会因此大出二三倍，这是无法接受的。&lt;/p>
&lt;p>它们造成的结果是：&lt;/p>
&lt;ul>
&lt;li>出现了 Unicode 的多种存储方式，也就是说有许多种不同的二进制格式，可以用来表示 Unicode。&lt;/li>
&lt;li>Unicode 在很长一段时间内无法推广，直到互联网的出现。&lt;/li>
&lt;/ul>
&lt;p>其中一种 Unicode 的存储方式如下：
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/gptlcx/1636861654037-a5bcf9bc-3a12-4958-b308-71955c77229d.png" alt="image.png">
上图左侧的几个字符，通过字符集找到对应的二进制编号之后，你怎么知道这一大串二进制内容，就是 &lt;code>eggo世界&lt;/code> 这几个字符呢？&lt;/p>
&lt;p>正常来说是这样的：
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/gptlcx/1636861731027-04bdc7aa-cedd-456a-abd9-e07793eff7ed.png" alt="image.png">
但是，也可以这样啊：
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/gptlcx/1636861748931-7e8aa489-51ae-4b25-bba2-efe7ec588bc7.png" alt="image.png">&lt;/p>
&lt;p>这里面的主要问题，就是 **划分字符边界。**所以，我们需要一种编码规则，通过字符集中的对照关系，对二进制进行编码。&lt;/p>
&lt;p>那么可以这样，不管编号多大多小，统一按照最长的来，位数不够，高位补零，效果如下：
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/gptlcx/1636861872939-a637432d-a70e-4606-b7e8-b9d50450b19b.png" alt="image.png">
这种方式，&lt;strong>Fixed-length codes(固定长度编码)&lt;/strong>。虽然字符边界的问题解决了，但是。。。。。这么存数据。。。非常浪费内存啊。。。。&lt;/p>
&lt;p>互联网的普及，强烈要求出现一种统一的编码方式。既然&lt;strong>固定长度编码&lt;/strong>不行，咱就来个 &lt;strong>Variable length code(可变长度编码)。&lt;/strong>&lt;/p>
&lt;p>**UTF-8 **就是在互联网上使用最广的一种 &lt;strong>Unicode 的编码规则&lt;/strong>。其他实现方式还包括 UTF-16（字符用两个字节或四个字节表示）和 UTF-32（字符用四个字节表示），不过在互联网上基本不用。&lt;/p>
&lt;h2 id="utf">UTF&lt;/h2>
&lt;p>&lt;strong>Unicode Transformation Formats(Unicode 转换格式，简称 UTF) 是&lt;/strong>根据 Unicode 实现的一种编码&lt;strong>规则&lt;/strong>。&lt;/p>
&lt;p>Unicode 标准定义了 &lt;strong>Unicode Transformation Formats(Unicode 转换格式，简称 UTF)&lt;/strong>。UTF-8、UTF-16、UTF-32 以及其他几种编码。最常用的编码是 UTF-8&lt;/p>
&lt;h3 id="utf-8">UTF-8&lt;/h3>
&lt;p>UTF-8 最大的一个特点，它是一种变长的编码方式。它可以使用 1~4 个 Bytes 表示一个字符(最多 32 个 bit)，根据不同的符号而变化字节长度。&lt;/p>
&lt;p>UTF-8 顾名思义，是一套以 8 位为一个编码单位的可变长编码。会&lt;strong>将一个 &amp;ldquo;Unicom 编号&amp;rdquo; 重新编码为 1 到 4 个字节&lt;/strong>&lt;/p>
&lt;p>既然是可变长度编码，那么小编号的字符就要少占字节，大编号的多占字节，但是，怎么划分字符的边界呢？有这么一种方案：&lt;/p>
&lt;p>UTF -8 首先定义一组模板，规范如下：&lt;/p>
&lt;ul>
&lt;li>首先获取到该字符的 Unicom 编号，然后根据该字符编号，决定对字符编码时所使用的模板，每个字符编码后存储时，所使用的 &amp;ldquo;Bytes 数&amp;rdquo; 不同&lt;/li>
&lt;li>如果字符需要存储 1 Bytes，则，字节的第一位设为 0。
&lt;ul>
&lt;li>后面 7 位为这个符号的 Unicode 码。因此对于英语字母，UTF-8 编码和 ASCII 码是相同的。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>如果字符需要存储 n Bytes(&lt;code>n &amp;gt; 1&lt;/code>)，则一个字节的前 n 个 bit 位都设为 1，第 n + 1 bit 位 设为 0，后面字节的前 两 bit 位 一律设为 10。
&lt;ul>
&lt;li>剩下的没有提及的二进制位，全部为这个符号的 Unicode 码。
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>Unicom 编号&lt;/th>
&lt;th>字节数&lt;/th>
&lt;th>最高位标识位&lt;/th>
&lt;th>模板(二进制)&lt;/th>
&lt;th>模板(十六进制)&lt;/th>
&lt;th>模板可以填充的 bit 数&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>0~127&lt;/td>
&lt;td>1 Bytes&lt;/td>
&lt;td>0&lt;/td>
&lt;td>0???????&lt;/td>
&lt;td>0000 0000-0000 007F&lt;/td>
&lt;td>7&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>128~2047&lt;/td>
&lt;td>2 Bytes&lt;/td>
&lt;td>110 和 10&lt;/td>
&lt;td>110????? 10??????&lt;/td>
&lt;td>0000 0080-0000 07FF&lt;/td>
&lt;td>5 + 6&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>2048~65535&lt;/td>
&lt;td>3 Bytes&lt;/td>
&lt;td>1110 和 10 和 10&lt;/td>
&lt;td>1110???? 10?????? 10??????&lt;/td>
&lt;td>0000 0800-0000 FFFF&lt;/td>
&lt;td>4 + 6 + 6&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>65536~4294967295&lt;/td>
&lt;td>4 Bytes&lt;/td>
&lt;td>11110 和 10 和 10 和 10&lt;/td>
&lt;td>11110??? 10?????? 10?????? 10??????&lt;/td>
&lt;td>0001 0000-0010 FFFF&lt;/td>
&lt;td>3 + 6 + 6 + 6&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>跟据上表，解读 UTF-8 编码非常简单。如果一个 Bytes 的第一个 bit 是 0，则这个字节单独就是一个字符；如果第一位是 1，则连续有多少个 1，就表示当前字符占用多少个字节。&lt;/p>
&lt;p>比如：&lt;/p>
&lt;ul>
&lt;li>&lt;code>01100101&lt;/code> 最高位为 0，则表示这是一个只占 1 Bytes 的字符，并且是在 0~127 编号范围内的字符。
&lt;ul>
&lt;li>除去标识 bit，剩下的 7 bit 就是该字符的二进制编号，即 &lt;code>1100101&lt;/code>，十进制是 &lt;code>101&lt;/code>，十六进制是 &lt;code>0065&lt;/code>，也就是字符 &lt;code>e&lt;/code>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;code>11100100 10111000 10010110&lt;/code> 最高位是 1110，则表示这是一个占用 3 bytes 的字符，并且要和后面两个以 10 开头的字节共同表示一个字符，并且是在 2048~65535 编号范围内的字符。
&lt;ul>
&lt;li>除去标识 bit，剩下的 bit 组合起来，即 &lt;code>01001110 00010110&lt;/code>，十进制是 &lt;code>19990&lt;/code>，十六进制是 &lt;code>4E16&lt;/code> ，也就是字符 &lt;code>世&lt;/code>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>字符 &lt;code>界&lt;/code> 在 Unicode 中的编号为 &lt;code>30028&lt;/code>，十六进制是 &lt;code>754C&lt;/code>，二进制是 &lt;code>01110101 01001100&lt;/code>，也就是说，如果想要使用 UTF-8 对字符编码后储存，则应该占用 3 Byes，所以应该使用 &lt;code>1110???? 10?????? 10??????&lt;/code> 模板。
&lt;ul>
&lt;li>将 &lt;code>界&lt;/code> 的二进制 bit 填入到模板中，得到 &lt;code>**1110**0111 **10**010101 **10**001100&lt;/code>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h3 id="总结">总结&lt;/h3>
&lt;p>虽然使用 UTF-8 对字符进行编码后，依然会浪费一部分 bit，但是对比&lt;a href="#DRcSC">定长编码&lt;/a>，已经极大得节省了存储空间。&lt;/p>
&lt;h2 id="unicode-与-utf-的区别">Unicode 与 UTF 的区别&lt;/h2>
&lt;p>简单来说：&lt;/p>
&lt;ul>
&lt;li>Unicode 是 字符集，即字符与编号的对应关系&lt;/li>
&lt;li>UTF 是 编码规则&lt;/li>
&lt;/ul>
&lt;p>其中：&lt;/p>
&lt;ul>
&lt;li>字符集：为每一个「字符」分配一个唯一的 ID（学名为码位 / 码点 / Code Point）&lt;/li>
&lt;li>编码规则：将「码位」转换为字节序列的规则&lt;/li>
&lt;/ul>
&lt;p>广义的 Unicode 是一个标准，定义了一个字符集以及一系列的编码规则，即 Unicode 字符集和 UTF-8、UTF-16、UTF-32 等等编码规则……&lt;/p>
&lt;p>Unicode 字符集为每一个字符分配一个编号，例如「知」的 Unicom 编号是 30693，记作 U+77E5（30693 的十六进制为 0x77E5）。&lt;/p>
&lt;p>UTF-8 顾名思义，是一套以 8 位为一个编码单位的可变长编码。会将一个编号重新编码为 1 到 4 个字节：&lt;/p>
&lt;pre>&lt;code>U+ 0000 ~ U+ 007F: 0XXXXXXX
U+ 0080 ~ U+ 07FF: 110XXXXX 10XXXXXX
U+ 0800 ~ U+ FFFF: 1110XXXX 10XXXXXX 10XXXXXX
U+10000 ~ U+10FFFF: 11110XXX 10XXXXXX 10XXXXXX 10XXXXXX
&lt;/code>&lt;/pre>
&lt;p>根据上表中的编码规则，之前的「知」字的码位 U+77E5 属于第三行的范围：&lt;/p>
&lt;pre>&lt;code>7 7 E 5
0111 0111 1110 0101 二进制的 77E5
--------------------------
0111 011111 100101 二进制的 77E5
1110XXXX 10XXXXXX 10XXXXXX 模版（上表第三行）
11100111 10011111 10100101 代入模版
E 7 9 F A 5
&lt;/code>&lt;/pre>
&lt;p>这就是将 U+77E5 按照 UTF-8 编码为字节序列 E79FA5 的过程。反之亦然。&lt;/p>
&lt;h1 id="乱码的出现">乱码的出现&lt;/h1>
&lt;p>从上边的编码介绍中我们已经知道了不同编码的存在，那么想要查看一个文件，就必须知道他的编码方式，用错误的编码方式打开文件就会出现乱码。
linux 下可以通过 file 命令查看文件的编码方式&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>root@lichenhao:~# touch encoding_file
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>root@lichenhao:~# file encoding_file
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>encoding_file: empty
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>root@lichenhao:~# echo &lt;span style="color:#e6db74">&amp;#34;hello world!&amp;#34;&lt;/span> &amp;gt; encoding_file
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>root@lichenhao:~# file encoding_file
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>encoding_file: ASCII text
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>root@lichenhao:~# echo &lt;span style="color:#e6db74">&amp;#34;你好，世界！&amp;#34;&lt;/span> &amp;gt;&amp;gt; encoding_file
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>root@lichenhao:~# file encoding_file
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>encoding_file: UTF-8 Unicode text
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>工作中我们在 XSHELL 之类的终端中查看文件时出现的乱码就是系统或文件保存的中文编码与终端设置的编码不一致，从而导致解码错误。这里涉及到三方编码：&lt;/p>
&lt;ol>
&lt;li>文件内容或文件名&lt;/li>
&lt;li>SHELL 环境的语言编码&lt;/li>
&lt;li>XSHELL 之类的终端编码&lt;/li>
&lt;/ol>
&lt;p>需要保持三方编码统一，才不会有乱码的出现，其中 SHELL 环境的语言编码指的是登陆服务器的 SHELL 环境时指定的语言编码，例如 LANG、LC_*这些变量设置的编码，XSHELL 之类终端编码就是这类终端软件设置的编码
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/gptlcx/1616053185837-0c93a28f-6155-47e3-9cf4-bbb563b402c1.jpeg" alt="">
所有遇到的乱码问题都仔细检查以上三方编码是否一致，就可以顺利解决了，同时也建议在工作中制定相应的规范，减少乱码的发生&lt;/p>
&lt;p>此时，我现在将 Xshell 中的编码规则变为其他的
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/gptlcx/1616475169200-5248e6d0-2b70-47f6-9a88-5f7c46a4758c.png" alt="image.png">
此时再看这个文件，就发现，已经无法正确解码了:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>root@lichenhao:~# cat encoding_file
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>hello world!
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>浣??ソ锛???????
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="乱码处理技巧">乱码处理技巧&lt;/h2>
&lt;ol>
&lt;li>临时切换命令输出语言
正常情况下命令的输出结果都遵循系统设置的语言编码，例如&lt;/li>
&lt;/ol>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>root@ops-coffee:~# echo $LANG
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>zh_CN.UTF-8
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>root@ops-coffee:~# date
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>2020年 03月 04日 星期三 19:00:55 HKT
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>root@ops-coffee:~# export LANG&lt;span style="color:#f92672">=&lt;/span>en_US.UTF-8
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>root@ops-coffee:~# echo $LANG
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>en_US.UTF-8
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>root@ops-coffee:~# date
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Wed Mar &lt;span style="color:#ae81ff">4&lt;/span> 19:01:21 HKT &lt;span style="color:#ae81ff">2020&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>运维脚本中，我们希望所有系统执行相同命令的时候输出的结果一致，不要因为字符集不同而产生不同的结果，那么如可处理呢？在命令前添加 LC_ALL=C&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>root@ops-coffee:~# date
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>2020年 03月 04日 星期三 19:05:58 HKT
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>root@ops-coffee:~# LC_ALL&lt;span style="color:#f92672">=&lt;/span>C date
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Wed Mar &lt;span style="color:#ae81ff">4&lt;/span> 19:06:05 HKT &lt;span style="color:#ae81ff">2020&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>这里之所以用 LC_ALL 是因为在 LOCALE 标准中，LC_ALL 优先级最高：LC_ALL&amp;gt;LC_*&amp;gt;LANG&lt;/p>
&lt;ol start="2">
&lt;li>批量转换文件名编码&lt;/li>
&lt;/ol>
&lt;p>有时候我们会遇到文件名或者目录名乱码的问题，尤其是在不同类型系统之间传输时，可以借助 rsync 实现批量转换文件名或目录名的编码
rsync -av &amp;ndash;iconv=GBK,UTF8 /www/ /nav/
iconv 模块在 rsync 的 3.0 以后版本中才支持，用法为&amp;ndash;iconv=,，需要注意的是，本地两个目录之间同步时 LOCAL 表示的是源目录的文件名编码，通过网络同步时 LOCAL 表示本地编码&lt;/p></description></item><item><title>Docs: Containerd 部署</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/10.%E4%BA%91%E5%8E%9F%E7%94%9F/2.2.%E5%AE%9E%E7%8E%B0%E5%AE%B9%E5%99%A8%E7%9A%84%E5%B7%A5%E5%85%B7/containerd/containerd-%E9%83%A8%E7%BD%B2/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/10.%E4%BA%91%E5%8E%9F%E7%94%9F/2.2.%E5%AE%9E%E7%8E%B0%E5%AE%B9%E5%99%A8%E7%9A%84%E5%B7%A5%E5%85%B7/containerd/containerd-%E9%83%A8%E7%BD%B2/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://github.com/containerd/containerd/blob/main/docs/getting-started.md">GitHub 文档，containerd/containerd/docs/getting-started.md&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;h1 id="安装-containerd">安装 Containerd&lt;/h1>
&lt;p>是否需要 libseccomp2 依赖？待验证&lt;/p>
&lt;h2 id="使用包管理器安装">使用包管理器安装&lt;/h2>
&lt;h3 id="centos">CentOS&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>yum install -y yum-utils device-mapper-persistent-data lvm2
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>yum-config-manager --add-repo http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>yum install -y containerd.io
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="ubuntu">Ubuntu&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>sudo apt-get -y install apt-transport-https ca-certificates curl gnupg-agent software-properties-common
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>curl -fsSL https://mirrors.aliyun.com/docker-ce/linux/ubuntu/gpg | sudo apt-key add -
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>sudo add-apt-repository &lt;span style="color:#e6db74">&amp;#34;deb [arch=amd64] https://mirrors.aliyun.com/docker-ce/linux/ubuntu &lt;/span>&lt;span style="color:#66d9ef">$(&lt;/span>lsb_release -cs&lt;span style="color:#66d9ef">)&lt;/span>&lt;span style="color:#e6db74"> stable&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>sudo apt-get -y update
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>sudo apt-get -y install containerd.io
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="配置-unit-文件">配置 unit 文件&lt;/h3>
&lt;p>略&lt;/p>
&lt;h2 id="使用二进制文件安装">使用二进制文件安装&lt;/h2>
&lt;p>通常，我们使用二进制安装 Containerd 时，除了 Containerd 的本体，还需要安装 runc 与 CNI。&lt;/p>
&lt;p>注意：在 1.6.0 版本的更新说明中，对 Releases 中的包进行一些调整，将在未来的 2.0 版本之后弃用一些东西&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/gg4dmt/1654268589875-dff18ee5-d643-489f-9c13-b8bc1dd4e99d.png" alt="image.png">&lt;/p>
&lt;p>这里说的主要是对那些整合包的弃用，让 containerd 的 realease 更纯粹，那些带着 cni 或 cri 的整合包，都没有了。并且，根据 1.6 版本的官方文档的安装说明，CRI 功能已经整合在 containerd 中，所以更无须下载整合包了。&lt;/p>
&lt;h3 id="安装-containerd-1">安装 Containerd&lt;/h3>
&lt;p>在 &lt;a href="https://github.com/containerd/containerd/releases">release&lt;/a> 页面下载二进制程序压缩包，解压并将二进制程序放到 $PATH 中&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>export ARCH&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;amd64&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>export CONTAINER_VERSION&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;1.6.16&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>export OS&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;linux&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>wget https://github.com/containerd/containerd/releases/download/v&lt;span style="color:#e6db74">${&lt;/span>CONTAINER_VERSION&lt;span style="color:#e6db74">}&lt;/span>/containerd-&lt;span style="color:#e6db74">${&lt;/span>CONTAINER_VERSION&lt;span style="color:#e6db74">}&lt;/span>-&lt;span style="color:#e6db74">${&lt;/span>OS&lt;span style="color:#e6db74">}&lt;/span>-&lt;span style="color:#e6db74">${&lt;/span>ARCH&lt;span style="color:#e6db74">}&lt;/span>.tar.gz
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>tar Cxzvf /usr/local containerd-&lt;span style="color:#e6db74">${&lt;/span>CONTAINER_VERSION&lt;span style="color:#e6db74">}&lt;/span>-&lt;span style="color:#e6db74">${&lt;/span>OS&lt;span style="color:#e6db74">}&lt;/span>-&lt;span style="color:#e6db74">${&lt;/span>ARCH&lt;span style="color:#e6db74">}&lt;/span>.tar.gz
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="安装-runc">安装 runc&lt;/h3>
&lt;p>从 &lt;a href="https://github.com/opencontainers/runc/releases">GitHub 项目，opencontainers/runc 的 Releases&lt;/a> 处下载 &lt;code>runc.&amp;lt;ARCH&amp;gt;&lt;/code> 二进制文件，拷贝到 &lt;code>/usr/local/sbin/runc&lt;/code> 处&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>export ARCH&lt;span style="color:#f92672">=&lt;/span>amd64
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>cp runc.&lt;span style="color:#e6db74">${&lt;/span>ARCH&lt;span style="color:#e6db74">}&lt;/span> /usr/local/sbin/runc &lt;span style="color:#f92672">&amp;amp;&amp;amp;&lt;/span> chmod &lt;span style="color:#ae81ff">755&lt;/span> /usr/local/sbin/runc
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="安装-cni-插件">安装 CNI 插件&lt;/h3>
&lt;p>从 &lt;a href="https://github.com/containernetworking/plugins/releases">GitHub 项目，containernetworking/plugins 的 Releases&lt;/a> 处下载 &lt;code>cni-plugins-&amp;lt;OS&amp;gt;-&amp;lt;ARCH&amp;gt;-&amp;lt;VERSION&amp;gt;.tgz&lt;/code> 文件，解压到 &lt;code>/opt/cni/bin/&lt;/code> 目录下&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>export OS&lt;span style="color:#f92672">=&lt;/span>linux
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>export ARCH&lt;span style="color:#f92672">=&lt;/span>amd64
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>export VERSION&lt;span style="color:#f92672">=&lt;/span>v1.1.1
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>mkdir -p /opt/cni/bin
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>tar Cxzvf /opt/cni/bin cni-plugins-&lt;span style="color:#e6db74">${&lt;/span>OS&lt;span style="color:#e6db74">}&lt;/span>-&lt;span style="color:#e6db74">${&lt;/span>ARCH&lt;span style="color:#e6db74">}&lt;/span>-&lt;span style="color:#e6db74">${&lt;/span>VERSION&lt;span style="color:#e6db74">}&lt;/span>.tgz
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="配置-unit-文件-1">配置 Unit 文件&lt;/h3>
&lt;p>从 &lt;a href="https://github.com/containerd/containerd/blob/main/containerd.service">GitHub 项目文件，containerd/containerd/containerd.service&lt;/a> 中下载用于 Systemd 的 Unit 文件。(对于 cri-containerd-&amp;hellip;. 类型的 release 压缩文件中包含 Unit 文件)&lt;/p>
&lt;p>这是一个 1.4.4 版本的 continerd.service 文件样例：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">[&lt;/span>Unit&lt;span style="color:#f92672">]&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Description&lt;span style="color:#f92672">=&lt;/span>containerd container runtime
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Documentation&lt;span style="color:#f92672">=&lt;/span>https://containerd.io
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>After&lt;span style="color:#f92672">=&lt;/span>network.target local-fs.target
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">[&lt;/span>Service&lt;span style="color:#f92672">]&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>ExecStartPre&lt;span style="color:#f92672">=&lt;/span>-/sbin/modprobe overlay
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>ExecStart&lt;span style="color:#f92672">=&lt;/span>/usr/local/bin/containerd
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Type&lt;span style="color:#f92672">=&lt;/span>notify
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Delegate&lt;span style="color:#f92672">=&lt;/span>yes
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>KillMode&lt;span style="color:#f92672">=&lt;/span>process
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Restart&lt;span style="color:#f92672">=&lt;/span>always
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>RestartSec&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">5&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># Having non-zero Limit*s causes performance problems due to accounting overhead&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># in the kernel. We recommend using cgroups to do container-local accounting.&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>LimitNPROC&lt;span style="color:#f92672">=&lt;/span>infinity
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>LimitCORE&lt;span style="color:#f92672">=&lt;/span>infinity
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>LimitNOFILE&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">1048576&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># Comment TasksMax if your systemd version does not supports it.&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># Only systemd 226 and above support this version.&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>TasksMax&lt;span style="color:#f92672">=&lt;/span>infinity
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>OOMScoreAdjust&lt;span style="color:#f92672">=&lt;/span>-999
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">[&lt;/span>Install&lt;span style="color:#f92672">]&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>WantedBy&lt;span style="color:#f92672">=&lt;/span>multi-user.target
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h1 id="配置并启动-containerd">配置并启动 Containerd&lt;/h1>
&lt;h2 id="添加-containerd-配置文件">添加 containerd 配置文件&lt;/h2>
&lt;p>通过命令生成配置文件&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>containerd config default &amp;gt; /etc/containerd/config.toml
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="修改内核参数">修改内核参数&lt;/h2>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>cat &amp;gt; /etc/sysctl.d/containerd.conf &lt;span style="color:#e6db74">&amp;lt;&amp;lt; EOF
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">net.ipv4.ip_forward = 1
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">EOF&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>sysctl -p /etc/sysctl.d/*
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="启动-containerd">启动 containerd&lt;/h2>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>systemctl daemon-reload
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>systemctl enable containerd --now
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h1 id="rootless-模式">rootless 模式&lt;/h1>
&lt;p>强烈推荐开启 cgroup v2，否则最好不要使用 rootless 模式，开启参考：https://rootlesscontaine.rs/getting-started/common/cgroup2/&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">[&lt;/span>INFO&lt;span style="color:#f92672">]&lt;/span> Checking RootlessKit functionality
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">[&lt;/span>INFO&lt;span style="color:#f92672">]&lt;/span> Checking cgroup v2
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">[&lt;/span>WARNING&lt;span style="color:#f92672">]&lt;/span> Enabling cgroup v2 is highly recommended, see https://rootlesscontaine.rs/getting-started/common/cgroup2/
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">[&lt;/span>INFO&lt;span style="color:#f92672">]&lt;/span> Checking overlayfs
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">[&lt;/span>INFO&lt;span style="color:#f92672">]&lt;/span> Requirements are satisfied
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">[&lt;/span>INFO&lt;span style="color:#f92672">]&lt;/span> Creating &lt;span style="color:#e6db74">&amp;#34;/home/lichenhao/.config/systemd/user/containerd.service&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">[&lt;/span>INFO&lt;span style="color:#f92672">]&lt;/span> Starting systemd unit &lt;span style="color:#e6db74">&amp;#34;containerd.service&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>+ systemctl --user start containerd.service
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>+ sleep &lt;span style="color:#ae81ff">3&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>+ systemctl --user --no-pager --full status containerd.service
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>● containerd.service - containerd &lt;span style="color:#f92672">(&lt;/span>Rootless&lt;span style="color:#f92672">)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Loaded: loaded &lt;span style="color:#f92672">(&lt;/span>/home/lichenhao/.config/systemd/user/containerd.service; disabled; vendor preset: enabled&lt;span style="color:#f92672">)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Active: active &lt;span style="color:#f92672">(&lt;/span>running&lt;span style="color:#f92672">)&lt;/span> since Mon 2021-09-13 21:48:44 CST; 3s ago
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Main PID: &lt;span style="color:#ae81ff">2625&lt;/span> &lt;span style="color:#f92672">(&lt;/span>rootlesskit&lt;span style="color:#f92672">)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> CGroup: /user.slice/user-1000.slice/user@1000.service/containerd.service
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ├─2625 rootlesskit --state-dir&lt;span style="color:#f92672">=&lt;/span>/run/user/1000/containerd-rootless --net&lt;span style="color:#f92672">=&lt;/span>slirp4netns --mtu&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">65520&lt;/span> --slirp4netns-sandbox&lt;span style="color:#f92672">=&lt;/span>auto --slirp4netns-seccomp&lt;span style="color:#f92672">=&lt;/span>auto --disable-host-loopback --port-driver&lt;span style="color:#f92672">=&lt;/span>builtin --copy-up&lt;span style="color:#f92672">=&lt;/span>/etc --copy-up&lt;span style="color:#f92672">=&lt;/span>/run --copy-up&lt;span style="color:#f92672">=&lt;/span>/var/lib --propagation&lt;span style="color:#f92672">=&lt;/span>rslave /usr/local/bin/containerd-rootless.sh
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ├─2635 /proc/self/exe --state-dir&lt;span style="color:#f92672">=&lt;/span>/run/user/1000/containerd-rootless --net&lt;span style="color:#f92672">=&lt;/span>slirp4netns --mtu&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">65520&lt;/span> --slirp4netns-sandbox&lt;span style="color:#f92672">=&lt;/span>auto --slirp4netns-seccomp&lt;span style="color:#f92672">=&lt;/span>auto --disable-host-loopback --port-driver&lt;span style="color:#f92672">=&lt;/span>builtin --copy-up&lt;span style="color:#f92672">=&lt;/span>/etc --copy-up&lt;span style="color:#f92672">=&lt;/span>/run --copy-up&lt;span style="color:#f92672">=&lt;/span>/var/lib --propagation&lt;span style="color:#f92672">=&lt;/span>rslave /usr/local/bin/containerd-rootless.sh
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ├─2651 slirp4netns --mtu &lt;span style="color:#ae81ff">65520&lt;/span> -r &lt;span style="color:#ae81ff">3&lt;/span> --disable-host-loopback --enable-sandbox --enable-seccomp &lt;span style="color:#ae81ff">2635&lt;/span> tap0
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> └─2659 containerd
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>9月 &lt;span style="color:#ae81ff">13&lt;/span> 21:48:44 hw-cloud-xngy-jump-server-linux-2 containerd-rootless.sh&lt;span style="color:#f92672">[&lt;/span>2659&lt;span style="color:#f92672">]&lt;/span>: time&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;2021-09-13T21:48:44.601967589+08:00&amp;#34;&lt;/span> level&lt;span style="color:#f92672">=&lt;/span>info msg&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;loading plugin \&amp;#34;io.containerd.grpc.v1.cri\&amp;#34;...&amp;#34;&lt;/span> type&lt;span style="color:#f92672">=&lt;/span>io.containerd.grpc.v1
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>9月 &lt;span style="color:#ae81ff">13&lt;/span> 21:48:44 hw-cloud-xngy-jump-server-linux-2 containerd-rootless.sh&lt;span style="color:#f92672">[&lt;/span>2659&lt;span style="color:#f92672">]&lt;/span>: time&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;2021-09-13T21:48:44.602049316+08:00&amp;#34;&lt;/span> level&lt;span style="color:#f92672">=&lt;/span>info msg&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;Start cri plugin with config {PluginConfig:{ContainerdConfig:{Snapshotter:overlayfs DefaultRuntimeName:runc DefaultRuntime:{Type: Engine: PodAnnotations:[] ContainerAnnotations:[] Root: Options:map[] PrivilegedWithoutHostDevices:false BaseRuntimeSpec:} UntrustedWorkloadRuntime:{Type: Engine: PodAnnotations:[] ContainerAnnotations:[] Root: Options:map[] PrivilegedWithoutHostDevices:false BaseRuntimeSpec:} Runtimes:map[runc:{Type:io.containerd.runc.v2 Engine: PodAnnotations:[] ContainerAnnotations:[] Root: Options:map[BinaryName: CriuImagePath: CriuPath: CriuWorkPath: IoGid:0 IoUid:0 NoNewKeyring:false NoPivotRoot:false Root: ShimCgroup: SystemdCgroup:false] PrivilegedWithoutHostDevices:false BaseRuntimeSpec:}] NoPivot:false DisableSnapshotAnnotations:true DiscardUnpackedLayers:false} CniConfig:{NetworkPluginBinDir:/opt/cni/bin NetworkPluginConfDir:/etc/cni/net.d NetworkPluginMaxConfNum:1 NetworkPluginConfTemplate:} Registry:{ConfigPath: Mirrors:map[] Configs:map[] Auths:map[] Headers:map[]} ImageDecryption:{KeyModel:node} DisableTCPService:true StreamServerAddress:127.0.0.1 StreamServerPort:0 StreamIdleTimeout:4h0m0s EnableSelinux:false SelinuxCategoryRange:1024 SandboxImage:k8s.gcr.io/pause:3.5 StatsCollectPeriod:10 SystemdCgroup:false EnableTLSStreaming:false X509KeyPairStreaming:{TLSCertFile: TLSKeyFile:} MaxContainerLogLineSize:16384 DisableCgroup:false DisableApparmor:false RestrictOOMScoreAdj:false MaxConcurrentDownloads:3 DisableProcMount:false UnsetSeccompProfile: TolerateMissingHugetlbController:true DisableHugetlbController:true IgnoreImageDefinedVolumes:false NetNSMountsUnderStateDir:false} ContainerdRootDir:/var/lib/containerd ContainerdEndpoint:/run/containerd/containerd.sock RootDir:/var/lib/containerd/io.containerd.grpc.v1.cri StateDir:/run/containerd/io.containerd.grpc.v1.cri}&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>9月 &lt;span style="color:#ae81ff">13&lt;/span> 21:48:44 hw-cloud-xngy-jump-server-linux-2 containerd-rootless.sh&lt;span style="color:#f92672">[&lt;/span>2659&lt;span style="color:#f92672">]&lt;/span>: time&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;2021-09-13T21:48:44.602101237+08:00&amp;#34;&lt;/span> level&lt;span style="color:#f92672">=&lt;/span>info msg&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;Connect containerd service&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>9月 &lt;span style="color:#ae81ff">13&lt;/span> 21:48:44 hw-cloud-xngy-jump-server-linux-2 containerd-rootless.sh&lt;span style="color:#f92672">[&lt;/span>2659&lt;span style="color:#f92672">]&lt;/span>: time&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;2021-09-13T21:48:44.602157949+08:00&amp;#34;&lt;/span> level&lt;span style="color:#f92672">=&lt;/span>info msg&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;Get image filesystem path \&amp;#34;/var/lib/containerd/io.containerd.snapshotter.v1.overlayfs\&amp;#34;&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>9月 &lt;span style="color:#ae81ff">13&lt;/span> 21:48:44 hw-cloud-xngy-jump-server-linux-2 containerd-rootless.sh&lt;span style="color:#f92672">[&lt;/span>2659&lt;span style="color:#f92672">]&lt;/span>: time&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;2021-09-13T21:48:44.602220361+08:00&amp;#34;&lt;/span> level&lt;span style="color:#f92672">=&lt;/span>warning msg&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;Running containerd in a user namespace typically requires disable_cgroup, disable_apparmor, restrict_oom_score_adj set to be true&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>9月 &lt;span style="color:#ae81ff">13&lt;/span> 21:48:44 hw-cloud-xngy-jump-server-linux-2 containerd-rootless.sh&lt;span style="color:#f92672">[&lt;/span>2659&lt;span style="color:#f92672">]&lt;/span>: time&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;2021-09-13T21:48:44.602782645+08:00&amp;#34;&lt;/span> level&lt;span style="color:#f92672">=&lt;/span>warning msg&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;failed to load plugin io.containerd.grpc.v1.cri&amp;#34;&lt;/span> error&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;failed to create CRI service: failed to create cni conf monitor: failed to create cni conf dir=/etc/cni/net.d for watch: mkdir /etc/cni/net.d: permission denied&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>9月 &lt;span style="color:#ae81ff">13&lt;/span> 21:48:44 hw-cloud-xngy-jump-server-linux-2 containerd-rootless.sh&lt;span style="color:#f92672">[&lt;/span>2659&lt;span style="color:#f92672">]&lt;/span>: time&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;2021-09-13T21:48:44.602807316+08:00&amp;#34;&lt;/span> level&lt;span style="color:#f92672">=&lt;/span>info msg&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;loading plugin \&amp;#34;io.containerd.grpc.v1.introspection\&amp;#34;...&amp;#34;&lt;/span> type&lt;span style="color:#f92672">=&lt;/span>io.containerd.grpc.v1
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>9月 &lt;span style="color:#ae81ff">13&lt;/span> 21:48:44 hw-cloud-xngy-jump-server-linux-2 containerd-rootless.sh&lt;span style="color:#f92672">[&lt;/span>2659&lt;span style="color:#f92672">]&lt;/span>: time&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;2021-09-13T21:48:44.603004589+08:00&amp;#34;&lt;/span> level&lt;span style="color:#f92672">=&lt;/span>info msg&lt;span style="color:#f92672">=&lt;/span>serving... address&lt;span style="color:#f92672">=&lt;/span>/run/containerd/containerd.sock.ttrpc
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>9月 &lt;span style="color:#ae81ff">13&lt;/span> 21:48:44 hw-cloud-xngy-jump-server-linux-2 containerd-rootless.sh&lt;span style="color:#f92672">[&lt;/span>2659&lt;span style="color:#f92672">]&lt;/span>: time&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;2021-09-13T21:48:44.603068510+08:00&amp;#34;&lt;/span> level&lt;span style="color:#f92672">=&lt;/span>info msg&lt;span style="color:#f92672">=&lt;/span>serving... address&lt;span style="color:#f92672">=&lt;/span>/run/containerd/containerd.sock
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>9月 &lt;span style="color:#ae81ff">13&lt;/span> 21:48:44 hw-cloud-xngy-jump-server-linux-2 containerd-rootless.sh&lt;span style="color:#f92672">[&lt;/span>2659&lt;span style="color:#f92672">]&lt;/span>: time&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;2021-09-13T21:48:44.603088751+08:00&amp;#34;&lt;/span> level&lt;span style="color:#f92672">=&lt;/span>info msg&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;containerd successfully booted in 0.056085s&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>+ systemctl --user enable containerd.service
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Created symlink /home/lichenhao/.config/systemd/user/default.target.wants/containerd.service → /home/lichenhao/.config/systemd/user/containerd.service.
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">[&lt;/span>INFO&lt;span style="color:#f92672">]&lt;/span> Installed &lt;span style="color:#e6db74">&amp;#34;containerd.service&amp;#34;&lt;/span> successfully.
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">[&lt;/span>INFO&lt;span style="color:#f92672">]&lt;/span> To control &lt;span style="color:#e6db74">&amp;#34;containerd.service&amp;#34;&lt;/span>, run: &lt;span style="color:#e6db74">`&lt;/span>systemctl --user &lt;span style="color:#f92672">(&lt;/span>start|stop|restart&lt;span style="color:#f92672">)&lt;/span> containerd.service&lt;span style="color:#e6db74">`&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">[&lt;/span>INFO&lt;span style="color:#f92672">]&lt;/span> To run &lt;span style="color:#e6db74">&amp;#34;containerd.service&amp;#34;&lt;/span> on system startup automatically, run: &lt;span style="color:#e6db74">`&lt;/span>sudo loginctl enable-linger lichenhao&lt;span style="color:#e6db74">`&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">[&lt;/span>INFO&lt;span style="color:#f92672">]&lt;/span> ------------------------------------------------------------------------------------------
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">[&lt;/span>INFO&lt;span style="color:#f92672">]&lt;/span> Use &lt;span style="color:#e6db74">`&lt;/span>nerdctl&lt;span style="color:#e6db74">`&lt;/span> to connect to the rootless containerd.
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">[&lt;/span>INFO&lt;span style="color:#f92672">]&lt;/span> You &lt;span style="color:#66d9ef">do&lt;/span> NOT need to specify $CONTAINERD_ADDRESS explicitly.
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>没法使用 host network 模式，找不到解决办法，好 TM 麻烦&lt;/p></description></item><item><title>Docs: Core</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/y.windows-%E7%AE%A1%E7%90%86/windows%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/powershell%E5%86%85%E7%BD%AE%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/core/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/y.windows-%E7%AE%A1%E7%90%86/windows%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/powershell%E5%86%85%E7%BD%AE%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/core/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://learn.microsoft.com/en-us/powershell/module/microsoft.powershell.core">官方文档-PowerShell，模块-Core&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>核心模块包含管理 PowerShell 基本功能的 cmdlet 和提供程序。&lt;/p>
&lt;h1 id="get-command">Get-Command&lt;/h1>
&lt;p>获取所有命令&lt;/p>
&lt;h2 id="syntax语法">Syntax(语法)&lt;/h2>
&lt;p>&lt;strong>Get-Command [OPTIONS]&lt;/strong>&lt;/p>
&lt;p>&lt;strong>OPTIONS&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>&lt;strong>-Name &amp;lt;PATTERN&amp;gt;&lt;/strong> # 列出匹配到名字的命令。支持通配符。&lt;code>默认值：None&lt;/code>&lt;/li>
&lt;li>&lt;strong>-CommandType &amp;lt;STRING&amp;gt;&lt;/strong> # 列出指定类型的命令。&lt;code>默认值：cmdlet,function,alias&lt;/code>。可用的类型有：Alias、All、Application、Cmdlet、ExternalScript、Filter、Function、Script&lt;/li>
&lt;/ul>
&lt;h2 id="example">EXAMPLE&lt;/h2></description></item><item><title>Docs: ECMAScript 模块与包</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/2.%E7%BC%96%E7%A8%8B/%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/ecmascript/ecmascript-%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8/ecmascript-%E6%A8%A1%E5%9D%97%E4%B8%8E%E5%8C%85/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/2.%E7%BC%96%E7%A8%8B/%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/ecmascript/ecmascript-%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8/ecmascript-%E6%A8%A1%E5%9D%97%E4%B8%8E%E5%8C%85/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Modules">MDN-参考，JavaScript-JavaScript 指南-JavaScript 模块&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://wangdoc.com/es6/module.html">网道，ES6 教程-Module 的语法&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.zhangxinxu.com/wordpress/2018/08/browser-native-es6-export-import-module/">https://www.zhangxinxu.com/wordpress/2018/08/browser-native-es6-export-import-module/&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>历史上，JavaScript 一直没有 Module(模块) 体系，无法将一个大程序拆分成互相依赖的小文件，再用简单的方法拼装起来。其他语言都有这项功能，比如 Ruby 的 require、Python 的 import，甚至就连 CSS 都有@import，但是 JavaScript 任何这方面的支持都没有，这对开发大型的、复杂的项目形成了巨大障碍。&lt;/p>
&lt;p>在 ES6 之前，社区制定了一些模块加载方案，最主要的有 2009 年 1 月发起的 CommonJS 和 AMD 两种，前者用于服务器，后者用于浏览器。&lt;/p>
&lt;blockquote>
&lt;p>2013 年 5 月，npm 的作者宣布 Node.js 已经废弃 CommonJS，详见 &lt;a href="https://github.com/nodejs/node-v0.x-archive/issues/5132#issuecomment-15432598">GitHub issue-5132，nodejs/node-v0.x-archive&lt;/a> &amp;gt; &lt;a href="https://en.wikipedia.org/wiki/Asynchronous_module_definition">Wiki,Asynchronous_module_definition&lt;/a>(异步模块定义，简称 AMD)&lt;/p>
&lt;/blockquote>
&lt;p>比如，CommonJS 模块就是对象，输入时必须查找对象属性。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-javascript" data-lang="javascript">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// CommonJS 标准
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">let&lt;/span> { &lt;span style="color:#a6e22e">stat&lt;/span>, &lt;span style="color:#a6e22e">exists&lt;/span>, &lt;span style="color:#a6e22e">readfile&lt;/span> } &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#a6e22e">require&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;fs&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 等同于 js 代码
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">let&lt;/span> &lt;span style="color:#a6e22e">_fs&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#a6e22e">require&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;fs&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">let&lt;/span> &lt;span style="color:#a6e22e">stat&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#a6e22e">_fs&lt;/span>.&lt;span style="color:#a6e22e">stat&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">let&lt;/span> &lt;span style="color:#a6e22e">exists&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#a6e22e">_fs&lt;/span>.&lt;span style="color:#a6e22e">exists&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">let&lt;/span> &lt;span style="color:#a6e22e">readfile&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#a6e22e">_fs&lt;/span>.&lt;span style="color:#a6e22e">readfile&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>上面代码的实质是整体加载 fs 模块（即加载 fs 的所有方法），生成一个对象（_fs），然后再从这个对象上面读取 3 个方法。这种加载称为“运行时加载”，因为只有运行时才能得到这个对象，导致完全没办法在编译时做“静态优化”。&lt;/p>
&lt;h2 id="es6-module">ES6 Module&lt;/h2>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://beginor.github.io/2021/08/16/using-es-modules-in-borwser-with-importmaps.html">https://beginor.github.io/2021/08/16/using-es-modules-in-borwser-with-importmaps.html&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>&lt;strong>ES6 Module(ES6 模块，简称 ESM)&lt;/strong>，ES6 在语言标准的层面上，实现了模块功能，而且实现得相当简单，完全可以取代 CommonJS 和 AMD 规范，成为浏览器和服务器通用的模块解决方案。这种模块功能与 ES6 一起发布于 2015 年&lt;/p>
&lt;p>ES6 模块的设计思想是尽量的静态化，使得编译时就能确定模块的依赖关系，以及输入和输出的变量。CommonJS 和 AMD 模块，都只能在运行时确定这些东西。&lt;/p>
&lt;p>通常来说，&lt;strong>一个模块指的一组文件的合集&lt;/strong>，只不过在通过编译工具编译后，将合并成一个文件。&lt;/p>
&lt;p>ES6 模块不是对象，而是通过 export 命令显式指定输出的代码，再通过 import 命令输入。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-javascript" data-lang="javascript">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// ES6 模块
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">import&lt;/span> { &lt;span style="color:#a6e22e">stat&lt;/span>, &lt;span style="color:#a6e22e">exists&lt;/span>, &lt;span style="color:#a6e22e">readFile&lt;/span> } &lt;span style="color:#a6e22e">from&lt;/span> &lt;span style="color:#e6db74">&amp;#34;fs&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>上面代码的实质是从 fs 模块加载 3 个方法，其他方法不加载。这种加载称为“编译时加载”或者静态加载，即 ES6 可以在编译时就完成模块加载，效率要比 CommonJS 模块的加载方式高。当然，这也导致了没法引用 ES6 模块本身，因为它不是对象。&lt;/p>
&lt;blockquote>
&lt;p>只支持相对路径或者绝对路径下的 ES 模块 (./, ../, /, http://, https://) ， 同时也受服务器跨域请求策略、 HTTPS 策略的约束。&lt;/p>
&lt;/blockquote>
&lt;p>由于 ES6 模块是编译时加载，使得静态分析成为可能。有了它，就能进一步拓宽 JavaScript 的语法，比如引入宏（macro）和类型检验（type system）这些只能靠静态分析实现的功能。&lt;/p>
&lt;p>除了静态加载带来的各种好处，ES6 模块还有以下好处。&lt;/p>
&lt;ul>
&lt;li>不再需要 UMD 模块格式了，将来服务器和浏览器都会支持 ES6 模块格式。目前，通过各种工具库，其实已经做到了这一点。&lt;/li>
&lt;li>将来浏览器的新 API 就能用模块格式提供，不再必须做成全局变量或者 navigator 对象的属性。&lt;/li>
&lt;li>不再需要对象作为命名空间（比如 Math 对象），未来这些功能可以通过模块提供。&lt;/li>
&lt;/ul>
&lt;h2 id="import-maps">Import maps&lt;/h2>
&lt;p>&lt;a href="https://beginor.github.io/2021/08/16/using-es-modules-in-borwser-with-importmaps.html">https://beginor.github.io/2021/08/16/using-es-modules-in-borwser-with-importmaps.html&lt;/a>&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-html" data-lang="html">&lt;span style="display:flex;">&lt;span>&amp;lt;&lt;span style="color:#f92672">script&lt;/span> &lt;span style="color:#a6e22e">type&lt;/span>&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;importmap&amp;#34;&lt;/span>&amp;gt;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#34;imports&amp;#34;&lt;/span>&lt;span style="color:#f92672">:&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#34;vue&amp;#34;&lt;/span>&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#e6db74">&amp;#34;https://unpkg.com/vue@3/dist/vue.esm-browser.js&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&amp;lt;/&lt;span style="color:#f92672">script&lt;/span>&amp;gt;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&amp;lt;&lt;span style="color:#f92672">script&lt;/span> &lt;span style="color:#a6e22e">type&lt;/span>&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;module&amp;#34;&lt;/span>&amp;gt;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">import&lt;/span> { &lt;span style="color:#a6e22e">createApp&lt;/span> } &lt;span style="color:#a6e22e">from&lt;/span> &lt;span style="color:#e6db74">&amp;#34;vue&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&amp;lt;/&lt;span style="color:#f92672">script&lt;/span>&amp;gt;
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h1 id="模块的加载方式">模块的加载方式&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://stackoverflow.com/questions/47403478/es6-modules-in-local-files-the-server-responded-with-a-non-javascript-mime-typ">https://stackoverflow.com/questions/47403478/es6-modules-in-local-files-the-server-responded-with-a-non-javascript-mime-typ&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://localcoder.org/es6-modules-in-local-files-the-server-responded-with-a-non-javascript-mime-typ">https://localcoder.org/es6-modules-in-local-files-the-server-responded-with-a-non-javascript-mime-typ&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://axellarsson.com/blog/expected-javascript-module-script-server-response-mimetype-text-html/">https://axellarsson.com/blog/expected-javascript-module-script-server-response-mimetype-text-html/&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>在 Node.js 环境和 Browser 环境中加载 ESM 的方式不太一样&lt;/p>
&lt;ul>
&lt;li>&lt;strong>Node.js&lt;/strong> # 可以使用模块名称。从根目录下的 node_modules/ 中查找模块&lt;/li>
&lt;li>&lt;strong>Browser&lt;/strong> # 不可以使用模块名称。必须通过编译工具将模块编译成单一文件，并修改 import 指向单一文件，以便可以发起请求获取这个静态资源&lt;/li>
&lt;/ul>
&lt;h2 id="浏览器中使用-esm-的常见问题">浏览器中使用 ESM 的常见问题&lt;/h2>
&lt;p>使用 &lt;code>import * as Vue from 'vue'&lt;/code> 将会产生如下报错：
&lt;code>Failed to resolve module specifier &amp;quot;vue&amp;quot;. Relative references must start with either &amp;quot;/&amp;quot;, &amp;quot;./&amp;quot;, or &amp;quot;../&amp;quot;.&lt;/code>
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/mm0ymr/1651724399014-d2052b6f-cd7c-4ec0-b6fc-b748bd5a11ed.png" alt="image.png">
接着修改为 &lt;code>import * as Vue from '../node_modules/vue'&lt;/code> 将会产生如下报错：
&lt;code>Failed to load module script: The server responded with a non-JavaScript MIME type of &amp;quot;text/html&amp;quot;. Strict MIME type checking is enforced for module scripts per HTML spec.&lt;/code>&lt;/p>
&lt;blockquote>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/mm0ymr/1651724430503-b62b86bd-4cc7-48b8-ac73-69fa62564ed5.png" alt="image.png" title="firefox">&lt;/p>
&lt;/blockquote>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/mm0ymr/1651724407422-526db251-775f-40d5-a25e-402791aa38cc.png" alt="image.png" title="chrome">
问题原因：
这个情况的原因是浏览器在处理 import 逻辑时导致的。浏览器在发现 import 语句时，将会请求 from 后面的静态文件，当 from 指定的是模块名称而不是模块文件的路径时时，浏览器无法发起请求，因为浏览器不知道如何获取到模块文件。&lt;/p>
&lt;p>解决方式：&lt;/p>
&lt;ul>
&lt;li>使用配置文件告诉 JavaScript 引擎如何从名为 XX 的模块中获取模块文件&lt;/li>
&lt;li>编译代码，js 代码被编译后，导入的模块的一组文件将会被打包、压缩为一个文件；并且 from 后面的模块名将被修改为模块文件的路径，即可在浏览器中运行&lt;/li>
&lt;/ul>
&lt;p>这几种解决方式通常都是通过编译工具实现的，比如 Webpack、Vite 等工具。&lt;/p></description></item><item><title>Docs: FFmpeg</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/11_%E5%A4%9A%E5%AA%92%E4%BD%93/%E5%A4%9A%E5%AA%92%E4%BD%93%E5%A4%84%E7%90%86%E5%B7%A5%E5%85%B7/ffmpeg/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/11_%E5%A4%9A%E5%AA%92%E4%BD%93/%E5%A4%9A%E5%AA%92%E4%BD%93%E5%A4%84%E7%90%86%E5%B7%A5%E5%85%B7/ffmpeg/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://github.com/FFmpeg/FFmpeg">GitHub 项目，FFmpge/FFmpge&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://ffmpeg.org/">官网&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>FFmpeg 是一个库和工具的集合，用于处理多媒体内容，比如 音频、视频、字幕、相关元数据 等。&lt;/p>
&lt;h1 id="ffmpeg-视频处理入门教程">FFmpeg 视频处理入门教程&lt;/h1>
&lt;p>作者： &lt;a href="https://www.ruanyifeng.com/">阮一峰&lt;/a>
日期： &lt;a href="https://www.ruanyifeng.com/blog/2020/01/">2020 年 1 月 14 日&lt;/a>
&lt;a href="https://www.ffmpeg.org/">FFmpeg&lt;/a> 是视频处理最常用的开源软件。
它功能强大，用途广泛，大量用于视频网站和商业软件（比如 Youtube 和 iTunes），也是许多音频和视频格式的标准编码/解码实现。&lt;/p>
&lt;p>FFmpeg 本身是一个庞大的项目，包含许多组件和库文件，最常用的是它的命令行工具。本文介绍 FFmpeg 命令行如何处理视频，比桌面视频处理软件更简洁高效。
如果你还没安装，可以根据&lt;a href="https://www.ffmpeg.org/download.html">官方文档&lt;/a> 先完成安装。&lt;/p>
&lt;h2 id="一概念">一、概念&lt;/h2>
&lt;p>介绍 FFmpeg 用法之前，需要了解一些视频处理的基本概念。&lt;/p>
&lt;h3 id="11-容器">1.1 容器&lt;/h3>
&lt;p>视频文件本身其实是一个容器（container），里面包括了视频和音频，也可能有字幕等其他内容。
常见的容器格式有以下几种。一般来说，视频文件的后缀名反映了它的容器格式。&lt;/p>
&lt;ul>
&lt;li>MP4&lt;/li>
&lt;li>MKV&lt;/li>
&lt;li>WebM&lt;/li>
&lt;li>AVI&lt;/li>
&lt;/ul>
&lt;p>下面的命令查看 FFmpeg 支持的容器。
$ ffmpeg -formats&lt;/p>
&lt;h3 id="12-编码格式">1.2 编码格式&lt;/h3>
&lt;p>视频和音频都需要经过编码，才能保存成文件。不同的编码格式（CODEC），有不同的压缩率，会导致文件大小和清晰度的差异。
常用的视频编码格式如下。&lt;/p>
&lt;ul>
&lt;li>H.262&lt;/li>
&lt;li>H.264&lt;/li>
&lt;li>H.265&lt;/li>
&lt;/ul>
&lt;p>上面的编码格式都是有版权的，但是可以免费使用。此外，还有几种无版权的视频编码格式。&lt;/p>
&lt;ul>
&lt;li>VP8&lt;/li>
&lt;li>VP9&lt;/li>
&lt;li>AV1&lt;/li>
&lt;/ul>
&lt;p>常用的音频编码格式如下。&lt;/p>
&lt;ul>
&lt;li>MP3&lt;/li>
&lt;li>AAC&lt;/li>
&lt;/ul>
&lt;p>上面所有这些都是有损的编码格式，编码后会损失一些细节，以换取压缩后较小的文件体积。无损的编码格式压缩出来的文件体积较大，这里就不介绍了。
下面的命令可以查看 FFmpeg 支持的编码格式，视频编码和音频编码都在内。
$ ffmpeg -codecs&lt;/p>
&lt;h3 id="13-编码器">1.3 编码器&lt;/h3>
&lt;p>编码器（encoders）是实现某种编码格式的库文件。只有安装了某种格式的编码器，才能实现该格式视频/音频的编码和解码。
以下是一些 FFmpeg 内置的视频编码器。&lt;/p>
&lt;ul>
&lt;li>libx264：最流行的开源 H.264 编码器&lt;/li>
&lt;li>NVENC：基于 NVIDIA GPU 的 H.264 编码器&lt;/li>
&lt;li>libx265：开源的 HEVC 编码器&lt;/li>
&lt;li>libvpx：谷歌的 VP8 和 VP9 编码器&lt;/li>
&lt;li>libaom：AV1 编码器&lt;/li>
&lt;/ul>
&lt;p>音频编码器如下。&lt;/p>
&lt;ul>
&lt;li>libfdk-aac&lt;/li>
&lt;li>aac&lt;/li>
&lt;/ul>
&lt;p>下面的命令可以查看 FFmpeg 已安装的编码器。
$ ffmpeg -encoders&lt;/p>
&lt;h2 id="二ffmpeg-的使用格式">二、FFmpeg 的使用格式&lt;/h2>
&lt;p>FFmpeg 的命令行参数非常多，可以分成五个部分。
$ ffmpeg {1} {2} -i {3} {4} {5}
上面命令中，五个部分的参数依次如下。&lt;/p>
&lt;ol>
&lt;li>全局参数&lt;/li>
&lt;li>输入文件参数&lt;/li>
&lt;li>输入文件&lt;/li>
&lt;li>输出文件参数&lt;/li>
&lt;li>输出文件&lt;/li>
&lt;/ol>
&lt;p>参数太多的时候，为了便于查看，ffmpeg 命令可以写成多行。
$ ffmpeg \ [全局参数] \ [输入文件参数] \ -i [输入文件] \ [输出文件参数] \ [输出文件]
下面是一个例子。
$ ffmpeg \ -y \ # 全局参数 -c:a libfdk_aac -c:v libx264 \ # 输入文件参数 -i input.mp4 \ # 输入文件 -c:v libvpx-vp9 -c:a libvorbis \ # 输出文件参数 output.webm # 输出文件
上面的命令将 mp4 文件转成 webm 文件，这两个都是容器格式。输入的 mp4 文件的音频编码格式是 aac，视频编码格式是 H.264；输出的 webm 文件的视频编码格式是 VP9，音频格式是 Vorbis。
如果不指明编码格式，FFmpeg 会自己判断输入文件的编码。因此，上面的命令可以简单写成下面的样子。
$ ffmpeg -i input.avi output.mp4&lt;/p>
&lt;h2 id="三常用命令行参数">三、常用命令行参数&lt;/h2>
&lt;p>FFmpeg 常用的命令行参数如下。&lt;/p>
&lt;ul>
&lt;li>-c：指定编码器&lt;/li>
&lt;li>-c copy：直接复制，不经过重新编码（这样比较快）&lt;/li>
&lt;li>-c:v：指定视频编码器&lt;/li>
&lt;li>-c:a：指定音频编码器&lt;/li>
&lt;li>-i：指定输入文件&lt;/li>
&lt;li>-an：去除音频流&lt;/li>
&lt;li>-vn： 去除视频流&lt;/li>
&lt;li>-preset：指定输出的视频质量，会影响文件的生成速度，有以下几个可用的值 ultrafast, superfast, veryfast, faster, fast, medium, slow, slower, veryslow。&lt;/li>
&lt;li>-y：不经过确认，输出时直接覆盖同名文件。&lt;/li>
&lt;/ul>
&lt;h2 id="四常见用法">四、常见用法&lt;/h2>
&lt;p>下面介绍 FFmpeg 几种常见用法。&lt;/p>
&lt;h3 id="41-查看文件信息">4.1 查看文件信息&lt;/h3>
&lt;p>查看视频文件的元信息，比如编码格式和比特率，可以只使用-i 参数。
$ ffmpeg -i input.mp4
上面命令会输出很多冗余信息，加上-hide_banner 参数，可以只显示元信息。
$ ffmpeg -i input.mp4 -hide_banner&lt;/p>
&lt;h3 id="42-转换编码格式">4.2 转换编码格式&lt;/h3>
&lt;p>转换编码格式（transcoding）指的是， 将视频文件从一种编码转成另一种编码。比如转成 H.264 编码，一般使用编码器 libx264，所以只需指定输出文件的视频编码器即可。
$ ffmpeg -i [input.file] -c:v libx264 output.mp4
下面是转成 H.265 编码的写法。
$ ffmpeg -i [input.file] -c:v libx265 output.mp4&lt;/p>
&lt;h3 id="43-转换容器格式">4.3 转换容器格式&lt;/h3>
&lt;p>转换容器格式（transmuxing）指的是，将视频文件从一种容器转到另一种容器。下面是 mp4 转 webm 的写法。
$ ffmpeg -i input.mp4 -c copy output.webm
上面例子中，只是转一下容器，内部的编码格式不变，所以使用-c copy 指定直接拷贝，不经过转码，这样比较快。&lt;/p>
&lt;h3 id="44-调整码率">4.4 调整码率&lt;/h3>
&lt;p>调整码率（transrating）指的是，改变编码的比特率，一般用来将视频文件的体积变小。下面的例子指定码率最小为 964K，最大为 3856K，缓冲区大小为 2000K。
$ ffmpeg \ -i input.mp4 \ -minrate 964K -maxrate 3856K -bufsize 2000K \ output.mp4&lt;/p>
&lt;h3 id="45-改变分辨率transsizing">4.5 改变分辨率（transsizing）&lt;/h3>
&lt;p>下面是改变视频分辨率（transsizing）的例子，从 1080p 转为 480p 。
$ ffmpeg \ -i input.mp4 \ -vf scale=480:-1 \ output.mp4&lt;/p>
&lt;h3 id="46-提取音频">4.6 提取音频&lt;/h3>
&lt;p>有时，需要从视频里面提取音频（demuxing），可以像下面这样写。
$ ffmpeg \ -i input.mp4 \ -vn -c:a copy \ output.aac
上面例子中，-vn 表示去掉视频，-c:a copy 表示不改变音频编码，直接拷贝。&lt;/p>
&lt;h3 id="47-添加音轨">4.7 添加音轨&lt;/h3>
&lt;p>添加音轨（muxing）指的是，将外部音频加入视频，比如添加背景音乐或旁白。
$ ffmpeg \ -i input.aac -i input.mp4 \ output.mp4
上面例子中，有音频和视频两个输入文件，FFmpeg 会将它们合成为一个文件。&lt;/p>
&lt;h3 id="48-截图">4.8 截图&lt;/h3>
&lt;p>下面的例子是从指定时间开始，连续对 1 秒钟的视频进行截图。
$ ffmpeg \ -y \ -i input.mp4 \ -ss 00:01:24 -t 00:00:01 \ output_%3d.jpg
如果只需要截一张图，可以指定只截取一帧。
$ ffmpeg \ -ss 01:23:45 \ -i input \ -vframes 1 -q:v 2 \ output.jpg
上面例子中，-vframes 1 指定只截取一帧，-q:v 2 表示输出的图片质量，一般是 1 到 5 之间（1 为质量最高）。&lt;/p>
&lt;h3 id="49-裁剪">4.9 裁剪&lt;/h3>
&lt;p>裁剪（cutting）指的是，截取原始视频里面的一个片段，输出为一个新视频。可以指定开始时间（start）和持续时间（duration），也可以指定结束时间（end）。
$ ffmpeg -ss [start] -i [input] -t [duration] -c copy [output] $ ffmpeg -ss [start] -i [input] -to [end] -c copy [output]
下面是实际的例子。
$ ffmpeg -ss 00:01:50 -i [input] -t 10.5 -c copy [output] $ ffmpeg -ss 2.5 -i [input] -to 10 -c copy [output]
上面例子中，-c copy 表示不改变音频和视频的编码格式，直接拷贝，这样会快很多。&lt;/p>
&lt;h3 id="410-为音频添加封面">4.10 为音频添加封面&lt;/h3>
&lt;p>有些视频网站只允许上传视频文件。如果要上传音频文件，必须为音频添加封面，将其转为视频，然后上传。
下面命令可以将音频文件，转为带封面的视频文件。
$ ffmpeg \ -loop 1 \ -i cover.jpg -i input.mp3 \ -c:v libx264 -c:a aac -b:a 192k -shortest \ output.mp4
上面命令中，有两个输入文件，一个是封面图片 cover.jpg，另一个是音频文件 input.mp3。-loop 1 参数表示图片无限循环，-shortest 参数表示音频文件结束，输出视频就结束。&lt;/p>
&lt;h2 id="五参考链接">五、参考链接&lt;/h2>
&lt;ul>
&lt;li>&lt;a href="https://github.com/leandromoreira/ffmpeg-libav-tutorial#chapter-3---transcoding">FFmpeg libav tutorial&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://github.com/leandromoreira/digital_video_introduction/blob/master/encoding_pratical_examples.md#split-and-merge-smoothly">Digital video introduction&lt;/a>&lt;/li>
&lt;li>&lt;a href="http://slhck.info/ffmpeg-encoding-course/">FFmpeg encoding and editing course&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://dragonquest64.blogspot.com/2019/10/making-slideshows-wffmpeg.html">Making Slideshows w/FFMpeg&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://itsfoss.com/ffmpeg/">The Complete Guide for Using ffmpeg in Linux&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://bernd.dev/2020/04/adding-subtitles/">Adding subtitles to your videos the easy way&lt;/a>&lt;/li>
&lt;/ul>
&lt;p>（完）&lt;/p></description></item><item><title>Docs: Go Module</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/2.%E7%BC%96%E7%A8%8B/%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/go/go-%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8/go-module/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/2.%E7%BC%96%E7%A8%8B/%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/go/go-%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8/go-module/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://go.dev/ref/mod">官方文档，参考-Go Modules 参考&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://mp.weixin.qq.com/s/6gJkSyGAFR0v6kow2uVklA">公众号，Go Modules 终极入门&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://blog.csdn.net/benben_2015/article/details/82227338">https://blog.csdn.net/benben_2015/article/details/82227338&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>&lt;strong>Go Moduel(Go 模块)&lt;/strong> 是实现 &lt;a href="https://en.wikipedia.org/wiki/Modular_programming">Modular Programming(模块化编程)&lt;/a> 的工具。是 Go 语言中正式官宣的项目依赖解决方案，Go modules（前身为 vgo）发布于 Go1.11，成长于 Go1.12，丰富于 Go1.13，正式于 Go1.14 已经准备好，并且可以用在生产上（ready for production）了，Go 官方也鼓励所有用户从其他依赖项管理工具迁移到 Go modules。&lt;/p>
&lt;p>module 是一个相关 Go 包的集合，它是源代码更替和版本控制的单元。模块由源文件形成的 go.mod 文件的根目录定义，包含 go.mod 文件的目录也被称为模块根。moudles 取代旧的的基于 GOPATH 方法来指定在工程中使用哪些源文件或导入包。模块路径是导入包的路径前缀，go.mod 文件定义模块路径，并且列出了在项目构建过程中使用的特定版本。&lt;/p>
&lt;p>使用 go module 时，GOPATH 不再用于解析导入。但是，它仍然用于存储下载的源代码（在$GOPATH/pkg/mod 中）和编译的命令（在 GOPATH / bin 中）。&lt;/p>
&lt;p>当程序编译时，会读取 go.mod 文件中的路径，来加载其编译所需的各种库&lt;/p>
&lt;p>Go moudles 目前集成在 Go 的工具链中，只要安装了 Go，自然而然也就可以使用 Go moudles 了，而 Go modules 的出现也解决了在 Go1.11 前的几个常见争议问题：&lt;/p>
&lt;ul>
&lt;li>Go 语言长久以来的依赖管理问题。&lt;/li>
&lt;li>“淘汰”现有的 &lt;a href="https://pkg.go.dev/cmd/go#hdr-GOPATH_environment_variable">GOPATH 的使用模式(即.解析导入能力)&lt;/a>。&lt;/li>
&lt;li>统一社区中的其它的依赖管理工具（提供迁移功能）。&lt;/li>
&lt;/ul>
&lt;h1 id="gopath">GOPATH&lt;/h1>
&lt;p>Go Module 出现后，GOPATH 路径变为纯粹的第三方依赖库的保存路径。目录结构通常如下：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>~&lt;span style="color:#f92672">]&lt;/span>&lt;span style="color:#75715e"># tree -L 3 $GOPATH&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>.
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>├── bin
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>│   ├── godef
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>│   ├── gomodifytags
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>│   ├── go-outline
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>│   ├── gopkgs
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>│   ├── goplay
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>│   ├── gopls
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>│   ├── gotests
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>│   └── staticcheck
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>└── pkg
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ├── mod
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> │   ├── 9fans.net
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> │   ├── cache
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> │   ├── fyne.io
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> │   ├── github.com
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> │   ├── gopkg.in
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> │   ├── gorm.io
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> │   └── mvdan.cc
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> └── sumdb
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> └── sum.golang.org
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>bin 下是安装的某些第三方依赖库后生成的二进制文件&lt;/p>
&lt;h2 id="早期-gopath-模式痛点">早期 GOPATH 模式痛点&lt;/h2>
&lt;p>我们先看看第一个问题，GOPATH 是什么，我们可以输入如下命令查看：&lt;/p>
&lt;pre>&lt;code>$ go env
GOPATH=&amp;quot;/root/go&amp;quot;
...
&lt;/code>&lt;/pre>
&lt;p>我们输入 go env 命令行后可以查看到 GOPATH 变量的结果，我们进入到该目录下进行查看，如下：&lt;/p>
&lt;pre>&lt;code>go
├── bin
├── pkg
└── src
├── github.com
├── golang.org
├── google.golang.org
├── gopkg.in
....
&lt;/code>&lt;/pre>
&lt;p>GOPATH 目录下一共包含了三个子目录，分别是：&lt;/p>
&lt;ul>
&lt;li>bin：存储所编译生成的二进制文件。&lt;/li>
&lt;li>pkg：存储预编译的目标文件，以加快程序的后续编译速度。&lt;/li>
&lt;li>src：存储所有项目的源代码。在编写 Go 应用程序，程序包和库时，一般会以$GOPATH/src/github.com/foo/bar 的路径进行存放。&lt;/li>
&lt;/ul>
&lt;p>因此在使用 GOPATH 模式下，我们需要将项目代码存放在固定的$GOPATH/src 目录下，并且如果执行 go get 来拉取外部依赖会自动下载并安装到 $GOPATH 目录下。&lt;/p>
&lt;p>为什么弃用 GOPATH 模式&lt;/p>
&lt;p>在 GOPATH 的 $GOPATH/src 下进行 .go 文件或源代码的存储，我们可以称其为 GOPATH 的模式，这个模式，看起来好像没有什么问题，那么为什么我们要弃用呢，参见如下原因：&lt;/p>
&lt;ul>
&lt;li>GOPATH 模式下没有版本控制的概念，具有致命的缺陷，至少会造成以下问题：
&lt;ul>
&lt;li>在执行 go get 的时候，你无法传达任何的版本信息的期望，也就是说你也无法知道自己当前更新的是哪一个版本，也无法通过指定来拉取自己所期望的具体版本。&lt;/li>
&lt;li>在运行 Go 应用程序的时候，你无法保证其它人与你所期望依赖的第三方库是相同的版本，也就是说在项目依赖库的管理上，你无法保证所有人的依赖版本都一致。&lt;/li>
&lt;li>你没办法处理 v1、v2、v3 等等不同版本的引用问题，因为 GOPATH 模式下的导入路径都是一样的，都是 github.com/foo/bar。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Go 语言官方从 Go1.11 起开始推进 Go modules（前身 vgo），Go1.13 起不再推荐使用 GOPATH 的使用模式，Go modules 也渐趋稳定，因此新项目也没有必要继续使用 GOPATH 模式。&lt;/li>
&lt;/ul>
&lt;p>在 GOPATH 模式下的产物&lt;/p>
&lt;p>Go1 在 2012 年 03 月 28 日发布，而 Go1.11 是在 2018 年 08 月 25 日才正式发布（数据来源：GitHub Tag），在这个空档的时间内，并没有 Go modules 这一个东西，最早期可能还好说，因为刚发布，用的人不多，所以没有明显暴露，但是后期 Go 语言使用的人越来越多了，那怎么办？&lt;/p>
&lt;p>这时候社区中逐渐的涌现出了大量的依赖解决方案，百花齐放，让人难以挑选，其中包括我们所熟知的 vendor 目录的模式，以及曾经一度被认为是“官宣”的 dep 的这类依赖管理工具。&lt;/p>
&lt;p>但为什么 dep 没有正在成为官宣呢，其实是因为随着 Russ Cox 与 Go 团队中的其他成员不断深入地讨论，发现 dep 的一些细节似乎越来越不适合 Go，因此官方采取了另起 proposal 的方式来推进，其方案的结果一开始先是释出 vgo（Go modules 的前身，知道即可，不需要深入了解），最终演变为我们现在所见到的 Go modules，也在 Go1.11 正式进入了 Go 的工具链。&lt;/p>
&lt;p>因此与其说是 “在 GOPATH 模式下的产物”，不如说是历史为当前提供了重要的教训，因此出现了 Go modules。&lt;/p>
&lt;h1 id="go-module-的使用和管理">Go Module 的使用和管理&lt;/h1>
&lt;p>可以这么说，一个自己新建的项目，就是一个模块，一个模块就是一个目录下的所有文件的集合。所以才说一个模块就是一个 Go Package 的合集。&lt;/p>
&lt;h2 id="go-module-相关环境变量">Go Module 相关环境变量&lt;/h2>
&lt;pre>&lt;code>$ go env
GO111MODULE=&amp;quot;auto&amp;quot; #使用module功能必须要让该变量变为on
GOPROXY=&amp;quot;https://proxy.golang.org,direct&amp;quot;
GONOPROXY=&amp;quot;&amp;quot;
GOSUMDB=&amp;quot;sum.golang.org&amp;quot;
GONOSUMDB=&amp;quot;&amp;quot;
GOPRIVATE=&amp;quot;&amp;quot;
...
&lt;/code>&lt;/pre>
&lt;h3 id="go111module">GO111MODULE&lt;/h3>
&lt;p>Go 语言提供了 GO111MODULE 这个环境变量来作为 Go modules 的开关，其允许设置以下参数：&lt;/p>
&lt;ul>
&lt;li>auto：只要项目包含了 go.mod 文件的话启用 Go modules，目前在 Go1.11 至 Go1.14 中仍然是默认值。&lt;/li>
&lt;li>on：启用 Go modules，推荐设置，将会是未来版本中的默认值。&lt;/li>
&lt;li>off：禁用 Go modules，不推荐设置。&lt;/li>
&lt;/ul>
&lt;p>GO111MODULE 的小历史&lt;/p>
&lt;p>你可能会留意到 GO111MODULE 这个名字比较 “奇特”，实际上在 Go 语言中经常会有这类阶段性的变量， GO111MODULE 这个命名代表着 Go 语言在 1.11 版本添加的，针对 Module 的变量。&lt;/p>
&lt;p>像是在 Go1.5 版本的时候，也发布了一个系统环境变量 GO15VENDOREXPERIMENT，作用是用于开启 vendor 目录的支持，当时其默认值也不是开启，仅仅作为 experimental。其随后在 Go1.6 版本时也将默认值改为了开启，并且最后作为了 official，GO15VENDOREXPERIMENT 系统变量就退出了历史舞台。&lt;/p>
&lt;p>而未来 GO111MODULE 这一个系统环境变量也会面临这个问题，也会先调整为默认值为 on（曾经在 Go1.13 想想改为 on，并且已经合并了 PR，但最后因为种种原因改回了 auto），然后再把 GO111MODULE 的支持给去掉，我们猜测应该会在 Go2 将 GO111MODULE 给去掉，因为如果直接去掉 GO111MODULE 的支持，会存在兼容性问题。&lt;/p>
&lt;h3 id="goproxy">GOPROXY&lt;/h3>
&lt;p>这个环境变量主要是用于设置 Go 模块代理（Go module proxy），其作用是用于使 Go 在后续拉取模块版本时能够脱离传统的 VCS 方式，直接通过镜像站点来快速拉取。&lt;/p>
&lt;p>GOPROXY 的默认值是：&lt;a href="https://proxy.golang.org,direct">https://proxy.golang.org,direct&lt;/a>，这有一个很严重的问题，就是 proxy.golang.org 在国内是无法访问的，因此这会直接卡住你的第一步，所以你必须在开启 Go modules 的时，同时设置国内的 Go 模块代理，执行如下命令：&lt;/p>
&lt;pre>&lt;code> $ go env -w GOPROXY=https://goproxy.cn,direct
&lt;/code>&lt;/pre>
&lt;p>GOPROXY 的值是一个以英文逗号 “,” 分割的 Go 模块代理列表，允许设置多个模块代理，假设你不想使用，也可以将其设置为 “off” ，这将会禁止 Go 在后续操作中使用任何 Go 模块代理。&lt;/p>
&lt;p>direct 是什么&lt;/p>
&lt;p>而在刚刚设置的值中，我们可以发现值列表中有 “direct” 标识，它又有什么作用呢？&lt;/p>
&lt;p>实际上 “direct” 是一个特殊指示符，用于指示 Go 回源到模块版本的源地址去抓取（比如 GitHub 等），场景如下：当值列表中上一个 Go 模块代理返回 404 或 410 错误时，Go 自动尝试列表中的下一个，遇见 “direct” 时回源，也就是回到源地址去抓取，而遇见 EOF 时终止并抛出类似 “invalid version: unknown revision&amp;hellip;” 的错误。&lt;/p>
&lt;h3 id="gosumdb">GOSUMDB&lt;/h3>
&lt;p>它的值是一个 Go checksum database，用于在拉取模块版本时（无论是从源站拉取还是通过 Go module proxy 拉取）保证拉取到的模块版本数据未经过篡改，若发现不一致，也就是可能存在篡改，将会立即中止。&lt;/p>
&lt;p>GOSUMDB 的默认值为：sum.golang.org，在国内也是无法访问的，但是 GOSUMDB 可以被 Go 模块代理所代理（详见：Proxying a Checksum Database）。&lt;/p>
&lt;p>因此我们可以通过设置 GOPROXY 来解决，而先前我们所设置的模块代理 goproxy.cn 就能支持代理 sum.golang.org，所以这一个问题在设置 GOPROXY 后，你可以不需要过度关心。&lt;/p>
&lt;p>另外若对 GOSUMDB 的值有自定义需求，其支持如下格式：&lt;/p>
&lt;ul>
&lt;li>格式 1：+。&lt;/li>
&lt;li>格式 2：+ 。&lt;/li>
&lt;/ul>
&lt;p>也可以将其设置为 “off”，也就是禁止 Go 在后续操作中校验模块版本。&lt;/p>
&lt;h3 id="gonoproxygonosumdbgoprivate">GONOPROXY/GONOSUMDB/GOPRIVATE&lt;/h3>
&lt;p>这三个环境变量都是用在当前项目依赖了私有模块，例如像是你公司的私有 git 仓库，又或是 github 中的私有库，都是属于私有模块，都是要进行设置的，否则会拉取失败。&lt;/p>
&lt;p>更细致来讲，就是依赖了由 GOPROXY 指定的 Go 模块代理或由 GOSUMDB 指定 Go checksum database 都无法访问到的模块时的场景。&lt;/p>
&lt;p>而一般建议直接设置 GOPRIVATE，它的值将作为 GONOPROXY 和 GONOSUMDB 的默认值，所以建议的最佳姿势是直接使用 GOPRIVATE。&lt;/p>
&lt;p>并且它们的值都是一个以英文逗号 “,” 分割的模块路径前缀，也就是可以设置多个，例如：&lt;/p>
&lt;pre>&lt;code> $ go env -w GOPRIVATE=&amp;quot;git.example.com,github.com/eddycjy/mquote&amp;quot;
&lt;/code>&lt;/pre>
&lt;p>设置后，前缀为 git.xxx.com 和 github.com/eddycjy/mquote 的模块都会被认为是私有模块。&lt;/p>
&lt;p>如果不想每次都重新设置，我们也可以利用通配符，例如：&lt;/p>
&lt;pre>&lt;code> $ go env -w GOPRIVATE=&amp;quot;*.example.com&amp;quot;
&lt;/code>&lt;/pre>
&lt;p>这样子设置的话，所有模块路径为 example.com 的子域名（例如：git.example.com）都将不经过 Go module proxy 和 Go checksum database，需要注意的是不包括 example.com 本身。&lt;/p>
&lt;p>具体使用步骤：&lt;/p>
&lt;ul>
&lt;li>通过 go 命令行，进入到你当前的工程目录下，在命令行设置临时环境变量 set GO111MODULE=on；&lt;/li>
&lt;li>执行命令 go mod init NAME 在当前目录下生成一个 go.mod 文件，执行这条命令时，当前目录不能存在 go.mod 文件。如果之前生成过，要先删除；&lt;/li>
&lt;li>如果你工程中存在一些不能确定版本的包，那么生成的 go.mod 文件可能就不完整，因此继续执行下面的命令；&lt;/li>
&lt;li>执行 go mod tidy 命令，它会添加缺失的模块以及移除不需要的模块。执行后会生成 go.sum 文件(模块下载条目)。添加参数-v，例如 go mod tidy -v 可以将执行的信息，即删除和添加的包打印到命令行；&lt;/li>
&lt;li>执行命令 go mod verify 来检查当前模块的依赖是否全部下载下来，是否下载下来被修改过。如果所有的模块都没有被修改过，那么执行这条命令之后，会打印 all modules verified。&lt;/li>
&lt;li>执行命令 go mod vendor 生成 vendor 文件夹，该文件夹下将会放置你 go.mod 文件描述的依赖包，文件夹下同时还有一个文件 modules.txt，它是你整个工程的所有模块。在执行这条命令之前，如果你工程之前有 vendor 目录，应该先进行删除。同理 go mod vendor -v 会将添加到 vendor 中的模块打印出来；&lt;/li>
&lt;/ul>
&lt;h2 id="gomod-文件">go.mod 文件&lt;/h2>
&lt;p>go.mod 文件定义 module 路径以及列出其他需要在 build 时引入的模块的特定的版本。例如下面的例子中，go.mod 声明 example.com/m 路径是 module 的根目录，同时也声明了 module 依赖特定版本的 golang.org/x/text 和 gopkg.in/yaml.v2。&lt;/p>
&lt;p>go.mod 文件中有如下几个关键字：&lt;/p>
&lt;ul>
&lt;li>&lt;strong>module&lt;/strong> # 定义 module 路径，该路径不用与当前路径相同，只是 module 所用的一个名称，可以代指当前目录。(比如/root/lichenhao/cobra/目录下，创建一个 go.mod 文件，可以定义 module 路径为 cobratest，这个 cobratest 模块路径名，就表示/root/lichenhao/cobra/这个目录)to define the module path;&lt;/li>
&lt;li>&lt;strong>go&lt;/strong> # to set the expected language version;&lt;/li>
&lt;li>&lt;strong>require&lt;/strong> # to require a particular module at a given version or later;&lt;/li>
&lt;li>&lt;strong>exclude&lt;/strong> # to exclude a particular module version from use; and&lt;/li>
&lt;li>&lt;strong>replace&lt;/strong> # to replace a module version with a different module version.&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">module&lt;/span> &lt;span style="color:#a6e22e">github&lt;/span>.&lt;span style="color:#a6e22e">com&lt;/span>&lt;span style="color:#f92672">/&lt;/span>&lt;span style="color:#a6e22e">eddycjy&lt;/span>&lt;span style="color:#f92672">/&lt;/span>&lt;span style="color:#a6e22e">module&lt;/span>&lt;span style="color:#f92672">-&lt;/span>&lt;span style="color:#a6e22e">repo&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">go&lt;/span> &lt;span style="color:#ae81ff">1.13&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">require&lt;/span> (
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">github&lt;/span>.&lt;span style="color:#a6e22e">com&lt;/span>&lt;span style="color:#f92672">/&lt;/span>&lt;span style="color:#a6e22e">eddycjy&lt;/span>&lt;span style="color:#f92672">/&lt;/span>&lt;span style="color:#a6e22e">mquote&lt;/span> &lt;span style="color:#a6e22e">v0&lt;/span>&lt;span style="color:#ae81ff">.0.0&lt;/span>&lt;span style="color:#f92672">-&lt;/span>&lt;span style="color:#ae81ff">20200220041913&lt;/span>&lt;span style="color:#f92672">-&lt;/span>&lt;span style="color:#a6e22e">e066a990ce6f&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>go.mod 文件还可以指定要替换和排除的版本，命令行会自动根据 go.mod 文件来维护需求声明中的版本。如果想获取更多的有关 go.mod 文件的介绍，可以使用命令 go help go.mod。&lt;/p>
&lt;p>go.mod 文件用 // 注释，而不用 /**/。文件的每行都有一条指令，由一个动作加上参数组成。例如：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">module&lt;/span> &lt;span style="color:#a6e22e">my&lt;/span>&lt;span style="color:#f92672">/&lt;/span>&lt;span style="color:#a6e22e">thing&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">require&lt;/span> &lt;span style="color:#a6e22e">other&lt;/span>&lt;span style="color:#f92672">/&lt;/span>&lt;span style="color:#a6e22e">thing&lt;/span> &lt;span style="color:#a6e22e">v1&lt;/span>&lt;span style="color:#ae81ff">.0.2&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">require&lt;/span> &lt;span style="color:#a6e22e">new&lt;/span>&lt;span style="color:#f92672">/&lt;/span>&lt;span style="color:#a6e22e">thing&lt;/span> &lt;span style="color:#a6e22e">v2&lt;/span>&lt;span style="color:#ae81ff">.3.4&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">exclude&lt;/span> &lt;span style="color:#a6e22e">old&lt;/span>&lt;span style="color:#f92672">/&lt;/span>&lt;span style="color:#a6e22e">thing&lt;/span> &lt;span style="color:#a6e22e">v1&lt;/span>&lt;span style="color:#ae81ff">.2.3&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">replace&lt;/span> &lt;span style="color:#a6e22e">bad&lt;/span>&lt;span style="color:#f92672">/&lt;/span>&lt;span style="color:#a6e22e">thing&lt;/span> &lt;span style="color:#a6e22e">v1&lt;/span>&lt;span style="color:#ae81ff">.4.5&lt;/span> =&amp;gt; &lt;span style="color:#a6e22e">good&lt;/span>&lt;span style="color:#f92672">/&lt;/span>&lt;span style="color:#a6e22e">thing&lt;/span> &lt;span style="color:#a6e22e">v1&lt;/span>&lt;span style="color:#ae81ff">.4.5&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>上面三个动词 require、exclude、replace 分别表示：项目需要的依赖包及版本、排除某些包的特别版本、取代当前项目中的某些依赖包。&lt;/p>
&lt;p>相同动作的命令可以放到一个动词+括号组成的结构中，例如：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">require&lt;/span> (
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">new&lt;/span>&lt;span style="color:#f92672">/&lt;/span>&lt;span style="color:#a6e22e">thing&lt;/span> &lt;span style="color:#a6e22e">v2&lt;/span>&lt;span style="color:#ae81ff">.3.4&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">old&lt;/span>&lt;span style="color:#f92672">/&lt;/span>&lt;span style="color:#a6e22e">thing&lt;/span> &lt;span style="color:#a6e22e">v1&lt;/span>&lt;span style="color:#ae81ff">.2.3&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="其他命令的支持">其他命令的支持&lt;/h3>
&lt;p>旧的版本，构建编译命令 &lt;code>go build&lt;/code> 中的参数没有 &lt;code>-mod&lt;/code> 参数，最新的版本现在多了这个，用来对 &lt;code>go.mod&lt;/code> 文件进行更新或其他使用控制。形式如：&lt;code>go build -mod [mode]&lt;/code>，其中 mode 有以下几种取值：readonly，release，vendor。当执行 &lt;code>go build -mod=vendor&lt;/code> 的时候，会在生成可执行文件的同时将项目的依赖包放到主模块的 &lt;code>vendor&lt;/code> 目录下。&lt;/p>
&lt;p>&lt;code>go get -m [packages]&lt;/code> 会将下载的依赖包放到 &lt;code>GOPATH/pkg/mod&lt;/code> 目录下，并且将依赖写入到 &lt;code>go.mod&lt;/code> 文件。&lt;code>go get -u=patch&lt;/code> 会更新主模块下的所有依赖包。&lt;/p>
&lt;p>如果遇到不熟悉的导入包，任何可以查找包含该引入包模块的 &lt;code>go&lt;/code> 命令，都会自动将该模块的最新版本添加到 &lt;code>go.mod&lt;/code> 文件中。同时也会添加缺失的模块，以及删除无用的 module。例如：go build, go test 或者 go list 命令。另外，有一个专门的命令 &lt;code>go mod tidy&lt;/code>，用来查看和添加缺失的 module 需求声明以及移除不必要的。&lt;/p>
&lt;p>&lt;code>go.mod&lt;/code> 文件是可读，也是可编辑的。&lt;code>go&lt;/code> 命令行会自动更新 &lt;code>go.mod&lt;/code> 文件来维持一个标准格式以及精确的引入声明。&lt;/p>
&lt;h2 id="gosum-文件">go.sum 文件&lt;/h2>
&lt;p>在第一次拉取模块依赖后，会发现多出了一个 go.sum 文件，其详细罗列了当前项目直接或间接依赖的所有模块版本，并写明了那些模块版本的 SHA-256 哈希值以备 Go 在今后的操作中保证项目所依赖的那些模块版本不会被篡改。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">github&lt;/span>.&lt;span style="color:#a6e22e">com&lt;/span>&lt;span style="color:#f92672">/&lt;/span>&lt;span style="color:#a6e22e">eddycjy&lt;/span>&lt;span style="color:#f92672">/&lt;/span>&lt;span style="color:#a6e22e">mquote&lt;/span> &lt;span style="color:#a6e22e">v0&lt;/span>&lt;span style="color:#ae81ff">.0.1&lt;/span> &lt;span style="color:#a6e22e">h1&lt;/span>:&lt;span style="color:#ae81ff">4&lt;/span>&lt;span style="color:#a6e22e">QHXKo7J8a6J&lt;/span>&lt;span style="color:#f92672">/&lt;/span>&lt;span style="color:#a6e22e">k8UA6CiHhswJQs0sm2foAQQUq8GFHM&lt;/span>=
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">github&lt;/span>.&lt;span style="color:#a6e22e">com&lt;/span>&lt;span style="color:#f92672">/&lt;/span>&lt;span style="color:#a6e22e">eddycjy&lt;/span>&lt;span style="color:#f92672">/&lt;/span>&lt;span style="color:#a6e22e">mquote&lt;/span> &lt;span style="color:#a6e22e">v0&lt;/span>&lt;span style="color:#ae81ff">.0.1&lt;/span>&lt;span style="color:#f92672">/&lt;/span>&lt;span style="color:#66d9ef">go&lt;/span>.&lt;span style="color:#a6e22e">mod&lt;/span> &lt;span style="color:#a6e22e">h1&lt;/span>:&lt;span style="color:#a6e22e">ZtlkDs7Mriynl7wsDQ4cU23okEtVYqHwl7F1eDh4qPg&lt;/span>=
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">github&lt;/span>.&lt;span style="color:#a6e22e">com&lt;/span>&lt;span style="color:#f92672">/&lt;/span>&lt;span style="color:#a6e22e">eddycjy&lt;/span>&lt;span style="color:#f92672">/&lt;/span>&lt;span style="color:#a6e22e">mquote&lt;/span>&lt;span style="color:#f92672">/&lt;/span>&lt;span style="color:#a6e22e">module&lt;/span>&lt;span style="color:#f92672">/&lt;/span>&lt;span style="color:#a6e22e">tour&lt;/span> &lt;span style="color:#a6e22e">v0&lt;/span>&lt;span style="color:#ae81ff">.0.1&lt;/span> &lt;span style="color:#a6e22e">h1&lt;/span>:&lt;span style="color:#a6e22e">cc&lt;/span>&lt;span style="color:#f92672">+&lt;/span>&lt;span style="color:#a6e22e">pgV0LnR8Fhou0zNHughT7IbSnLvfUZ&lt;/span>&lt;span style="color:#f92672">+&lt;/span>&lt;span style="color:#a6e22e">X3fvshrv8&lt;/span>=
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">github&lt;/span>.&lt;span style="color:#a6e22e">com&lt;/span>&lt;span style="color:#f92672">/&lt;/span>&lt;span style="color:#a6e22e">eddycjy&lt;/span>&lt;span style="color:#f92672">/&lt;/span>&lt;span style="color:#a6e22e">mquote&lt;/span>&lt;span style="color:#f92672">/&lt;/span>&lt;span style="color:#a6e22e">module&lt;/span>&lt;span style="color:#f92672">/&lt;/span>&lt;span style="color:#a6e22e">tour&lt;/span> &lt;span style="color:#a6e22e">v0&lt;/span>&lt;span style="color:#ae81ff">.0.1&lt;/span>&lt;span style="color:#f92672">/&lt;/span>&lt;span style="color:#66d9ef">go&lt;/span>.&lt;span style="color:#a6e22e">mod&lt;/span> &lt;span style="color:#a6e22e">h1&lt;/span>:&lt;span style="color:#ae81ff">8&lt;/span>&lt;span style="color:#a6e22e">uL1FOiQJZ4&lt;/span>&lt;span style="color:#f92672">/&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>&lt;span style="color:#a6e22e">hzqQ5mv4Sm7nJcwYu41F3nZmkiWx5I&lt;/span>=
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">...&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>我们可以看到一个模块路径可能有如下两种：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">github&lt;/span>.&lt;span style="color:#a6e22e">com&lt;/span>&lt;span style="color:#f92672">/&lt;/span>&lt;span style="color:#a6e22e">eddycjy&lt;/span>&lt;span style="color:#f92672">/&lt;/span>&lt;span style="color:#a6e22e">mquote&lt;/span> &lt;span style="color:#a6e22e">v0&lt;/span>&lt;span style="color:#ae81ff">.0.1&lt;/span> &lt;span style="color:#a6e22e">h1&lt;/span>:&lt;span style="color:#ae81ff">4&lt;/span>&lt;span style="color:#a6e22e">QHXKo7J8a6J&lt;/span>&lt;span style="color:#f92672">/&lt;/span>&lt;span style="color:#a6e22e">k8UA6CiHhswJQs0sm2foAQQUq8GFHM&lt;/span>=
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">github&lt;/span>.&lt;span style="color:#a6e22e">com&lt;/span>&lt;span style="color:#f92672">/&lt;/span>&lt;span style="color:#a6e22e">eddycjy&lt;/span>&lt;span style="color:#f92672">/&lt;/span>&lt;span style="color:#a6e22e">mquote&lt;/span> &lt;span style="color:#a6e22e">v0&lt;/span>&lt;span style="color:#ae81ff">.0.1&lt;/span>&lt;span style="color:#f92672">/&lt;/span>&lt;span style="color:#66d9ef">go&lt;/span>.&lt;span style="color:#a6e22e">mod&lt;/span> &lt;span style="color:#a6e22e">h1&lt;/span>:&lt;span style="color:#a6e22e">ZtlkDs7Mriynl7wsDQ4cU23okEtVYqHwl7F1eDh4qPg&lt;/span>=
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>h1 hash 是 Go modules 将目标模块版本的 zip 文件开包后，针对所有包内文件依次进行 hash，然后再把它们的 hash 结果按照固定格式和算法组成总的 hash 值。&lt;/p>
&lt;p>而 h1 hash 和 go.mod hash 两者，要不就是同时存在，要不就是只存在 go.mod hash。那什么情况下会不存在 h1 hash 呢，就是当 Go 认为肯定用不到某个模块版本的时候就会省略它的 h1 hash，就会出现不存在 h1 hash，只存在 go.mod hash 的情况。&lt;/p>
&lt;h1 id="go-mod-命令行工具">go mod 命令行工具&lt;/h1>
&lt;p>go mod 提供了一系列操作模块的命令，所有的 go 命令中现在已经内置了对 module 的支持，而不仅仅是 go mod 命令。例如使用 go get 时，会经常自动在后台添加、移除、升级、降级依赖包版本。&lt;/p>
&lt;h2 id="syntax语法">Syntax(语法)&lt;/h2>
&lt;p>&lt;strong>go mod [ARGUMENTS]&lt;/strong>&lt;/p>
&lt;p>COMMAND：&lt;/p>
&lt;ul>
&lt;li>&lt;strong>download&lt;/strong> # 下载模块到本地缓存，具体可以通过命令 go env 查看，其中环境变量 GOCACHE 就是缓存的地址，如果该文件夹的内容太大，可以通过命令 go clean -cache&lt;/li>
&lt;li>&lt;strong>edit&lt;/strong> # 从工具或脚本中编辑 go.mod 文件&lt;/li>
&lt;li>&lt;strong>graph&lt;/strong> # 打印模块需求图&lt;/li>
&lt;li>&lt;strong>init&lt;/strong> # 在当前目录下初始化新的模块&lt;/li>
&lt;li>&lt;strong>tidy&lt;/strong> # 添加缺失的模块以及移除无用的模块&lt;/li>
&lt;li>&lt;strong>vendor&lt;/strong> #导出项目所有的依赖到 vendor 目录&lt;/li>
&lt;li>**verify **#验证依赖项是否达到预期的目的&lt;/li>
&lt;li>&lt;strong>why&lt;/strong> #查看为什么需要包或模块&lt;/li>
&lt;/ul>
&lt;h2 id="go-mod-download">go mod download&lt;/h2>
&lt;p>&lt;strong>go mod download [-dir] [-json] [modules]&lt;/strong>&lt;/p>
&lt;p>使用此命令来下载指定的模块，模块的格式可以根据主模块依赖的形式或者 path@version 形式指定。如果没有指定参数，此命令会将主模块下的所有依赖下载下来。&lt;/p>
&lt;p>go mod download 命令非常有用，主要用来预填充本地缓存或者计算 Go 模块代理的回答。默认情况下，下载错误会输出到标准输出，正常情况下没有任何输出。-json 参数会以 JSON 的格式打印下载的模块对象，对应的 Go 对象结构是这样。&lt;/p>
&lt;p>type Module struct { Path string //module path Version string //module version Error string //error loading module Info string //absolute path to cached .info file GoMod string //absolute path to cached .mod file Zip string //absolute path to cached .zip file Dir string //absolute path to cached source root directory Sum string //checksum for path, version (as in go.sum) GoModSum string //checksum for go.mod (as in go.sum)}&lt;/p>
&lt;h2 id="go-mod-init">go mod init&lt;/h2>
&lt;p>&lt;strong>go mod init [ModuleName]&lt;/strong>
一般情况 ModuleName 是以后 import 时所使用的路径&lt;/p>
&lt;p>此命令会在当前目录中初始化和创建一个新的 go.mod 文件，当然你也可以手动创建一个 go.mod 文件，然后包含一些 module 声明，这样就比较麻烦。go mod init 命令可以帮助我们自动创建&lt;/p>
&lt;p>例如：&lt;code>go mod init example.com/m&lt;/code>&lt;/p>
&lt;p>使用这条命令时，go.mod 文件必须提前不能存在。初始化会根据引入包声明来推测模块的路径或者如果你工程中之前已经存在一些依赖包管理工具，例如 godep，glide 或者 dep。那么 go mod init 同样也会根据依赖包管理配置文件来推断。&lt;/p>
&lt;h2 id="go-mod-tidy">go mod tidy&lt;/h2>
&lt;p>&lt;strong>go mod tidy [-v]&lt;/strong>&lt;/p>
&lt;p>默认情况下，Go 不会移除 go.mod 文件中的无用依赖。所以当你的依赖中有些使用不到了，可以使用 go mod tidy 命令来清除它。&lt;/p>
&lt;p>它会添加缺失的模块以及移除不需要的模块。执行后会生成 go.sum 文件(模块下载条目)。添加参数-v，例如 go mod tidy -v 可以将执行的信息，即移除的模块打印到标准输出。&lt;/p>
&lt;h2 id="go-mod-vendor">go mod vendor&lt;/h2>
&lt;p>go mod vendor [-v]&lt;/p>
&lt;p>此命令会将 build 阶段需要的所有依赖包放到主模块所在的 vendor 目录中，并且测试所有主模块的包。同理 go mod vendor -v 会将添加到 vendor 中的模块打印到标准输出。&lt;/p>
&lt;h2 id="go-mod-verify">go mod verify&lt;/h2>
&lt;p>此命令会检查当前模块的依赖是否已经存储在本地下载的源代码缓存中，以及检查自从下载下来是否有修改。如果所有的模块都没有修改，那么会打印 all modules verified，否则会打印变化的内容。&lt;/p>
&lt;p>虚拟版本号&lt;/p>
&lt;p>go.mod 文件和 go 命令通常使用语义版本作为描述模块版本的标准形式，这样可以比较不同版本的先后顺序。例如模块的版本是 v1.2.3，那么通过重新对版本号进行标签处理，得到该版本的虚拟版本。形式如：v0.0.0-yyyymmddhhmmss-abcdefabcdef。其中时间是提交时的 UTC 时间，最后的后缀是提交的哈希值前缀。时间部分确保两个虚拟版本号可以进行比较，以确定两者顺序。&lt;/p>
&lt;p>下面有三种形式的虚拟版本号：&lt;/p>
&lt;ul>
&lt;li>vX.0.0-yyyymmddhhmmss-abcdefabcdef，这种情况适合用在在目标版本提交之前 ，没有更早的的版本。（这种形式本来是唯一的形式，所以一些老的 go.mod 文件使用这种形式）&lt;/li>
&lt;li>vX.Y.Z-pre.0.yyyymmddhhmmss-abcdefabcdef，这种情况被用在当目标版本提交之前的最新版本提交是 vX.Y.Z-pre。&lt;/li>
&lt;li>vX.Y.(Z+1)-0.yyyymmddhhmmss-abcdefabcdef，同理，这种情况是当目标版本提交之前的最新版本是 vX.Y.Z。&lt;/li>
&lt;/ul>
&lt;p>虚拟版本的生成不需要你去手动操作，go 命令会将接收的 commit 哈希值自动转化为虚拟版本号。&lt;/p></description></item><item><title>Docs: KVM/QEMU 部署</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/10.%E4%BA%91%E5%8E%9F%E7%94%9F/1.2.%E5%AE%9E%E7%8E%B0%E8%99%9A%E6%8B%9F%E5%8C%96%E7%9A%84%E5%B7%A5%E5%85%B7/kvm_qemu/kvm_qemu-%E9%83%A8%E7%BD%B2/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/10.%E4%BA%91%E5%8E%9F%E7%94%9F/1.2.%E5%AE%9E%E7%8E%B0%E8%99%9A%E6%8B%9F%E5%8C%96%E7%9A%84%E5%B7%A5%E5%85%B7/kvm_qemu/kvm_qemu-%E9%83%A8%E7%BD%B2/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/8/html-single/configuring_and_managing_virtualization/index#enabling-virtualization-in-rhel8_virt-getting-started">https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/8/html-single/configuring_and_managing_virtualization/index#enabling-virtualization-in-rhel8_virt-getting-started&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://ubuntu.com/server/docs/virtualization-introduction">Ubuntu 官方文档，虚拟化介绍&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;h1 id="前期准备">前期准备&lt;/h1>
&lt;p>查看 CPU 是否支持 KVM，筛选出来相关信息才可以正常使用 KVM&lt;/p>
&lt;ul>
&lt;li>egrep &amp;ldquo;(svm|vmx)&amp;rdquo; /proc/cpuinfo&lt;/li>
&lt;/ul>
&lt;h1 id="安装虚拟化组件">安装虚拟化组件&lt;/h1>
&lt;h2 id="centos">CentOS&lt;/h2>
&lt;ul>
&lt;li>yum group install -y &amp;lsquo;Virtualization Host&amp;rsquo; # 安装虚拟化组
&lt;ul>
&lt;li>若安装完成后，模块未装载，则手动装载 KVM 模块
&lt;ul>
&lt;li>modprobe kvm&lt;/li>
&lt;li>modprobe kvm-intel&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>验证系统是否已经准备好称为虚拟化主机
&lt;ul>
&lt;li>virt-host-validate&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>启动 libvirt 服务
&lt;ul>
&lt;li>systemctl enable libvirtd &amp;ndash;now&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>创建连接使用命令
&lt;ul>
&lt;li>ln -sv /usr/libexec/qemu-kvm /usr/bin/&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>安装 X 服务端程序
&lt;ul>
&lt;li>yum install -y xorg-x11-xauth xorg-x11-server-utils&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>安装图形管理工具
&lt;ul>
&lt;li>yum install virt-manager -y&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>安装 qemu 以模拟 I/O 设备
&lt;ul>
&lt;li>yum install qemu-system-x86 qemu-img -y&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>安装 virt 安装命令
&lt;ul>
&lt;li>yum install virt-install -y&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>安装虚拟机文件系统的管理工具
&lt;ul>
&lt;li>yum install libguestfs-tools -y&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h2 id="ubuntu">Ubuntu&lt;/h2>
&lt;p>检查环境&lt;/p>
&lt;ul>
&lt;li>sudo apt update&lt;/li>
&lt;li>sudo apt install -y cpu-checker&lt;/li>
&lt;li>kvm-ok&lt;/li>
&lt;/ul>
&lt;p>ln -sv /usr/bin/kvm /usr/bin/&lt;/p>
&lt;p>安装虚拟化环境&lt;/p>
&lt;ul>
&lt;li>sudo apt install -y qemu-kvm libvirt-daemon-system libvirt-daemon libvirt-clients&lt;/li>
&lt;/ul>
&lt;p>安装虚拟机文件系统的管理工具&lt;/p>
&lt;ul>
&lt;li>apt install libguestfs-tools -y&lt;/li>
&lt;li>apt install virt-manager -y&lt;/li>
&lt;/ul>
&lt;h1 id="安转-vpn-与桌面可选">安转 VPN 与桌面(可选)&lt;/h1>
&lt;h2 id="centos-1">CentOS&lt;/h2>
&lt;ul>
&lt;li>yum install -y tigervnc-server # 安装 vnc 服务端&lt;/li>
&lt;li>yum groups install -y &amp;lsquo;GNOME Desktop&amp;rsquo; #&lt;/li>
&lt;/ul>
&lt;h1 id="其他">其他&lt;/h1>
&lt;p>yum -y install mesa-libGLES-devel.x86_64 mesa-dri-drivers
若不安装这两个包，当使用 virt-mangaer 工具是，可能会出现如下报错：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>libGL error: unable to load driver: swrast_dri.so
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>libGL error: failed to load driver: swrast
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div></description></item><item><title>Docs: OpenStack 部署与清理</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/10.%E4%BA%91%E5%8E%9F%E7%94%9F/1.3.openstack-%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%BC%96%E6%8E%92%E7%B3%BB%E7%BB%9F/openstack%E9%83%A8%E7%BD%B2%E4%B8%8E%E6%B8%85%E7%90%86/openstack-%E9%83%A8%E7%BD%B2%E4%B8%8E%E6%B8%85%E7%90%86/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/10.%E4%BA%91%E5%8E%9F%E7%94%9F/1.3.openstack-%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%BC%96%E6%8E%92%E7%B3%BB%E7%BB%9F/openstack%E9%83%A8%E7%BD%B2%E4%B8%8E%E6%B8%85%E7%90%86/openstack-%E9%83%A8%E7%BD%B2%E4%B8%8E%E6%B8%85%E7%90%86/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;/blockquote>
&lt;p>&lt;a href="https://thoughts.teambition.com/workspaces/603b04c9f83f2a00428f7321/folders/5fa948644cc5830001751d72">https://thoughts.teambition.com/workspaces/603b04c9f83f2a00428f7321/folders/5fa948644cc5830001751d72&lt;/a>&lt;/p>
&lt;p>部署 OpenStack 有多种方式&lt;/p>
&lt;ul>
&lt;li>手动部署 OpenStack 中的每一个组件
&lt;ul>
&lt;li>&lt;a href="https://docs.openstack.org/xena/install/">https://docs.openstack.org/xena/install/&lt;/a>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>使用自动化部署工具，部署工具有多种类型可供选择
&lt;ul>
&lt;li>&lt;a href="https://docs.openstack.org/xena/deploy/">https://docs.openstack.org/xena/deploy/&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://docs.openstack.org/project-deploy-guide/charm-deployment-guide/latest/">OpenStack Charms&lt;/a> # 使用 MAAS 和 Juju 部署。
&lt;ul>
&lt;li>一种完善的部署方式，基于 Ubuntu 开发 MAAS。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;a href="https://docs.openstack.org/project-deploy-guide/kolla-ansible/latest/">OpenStack Kolla&lt;/a> # 在容器中使用 Ansible 部署
&lt;ul>
&lt;li>非常简单高效得部署一个用来 生产、开发、测试 的 OpenStack。支持 all-in-one 和 multinode 两种模式(即所有组件都在一个节点或分散在多个节点)&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>其他&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h2 id="支持的操作系统">支持的操作系统&lt;/h2>
&lt;p>Kolla Ansible 支持以下主机操作系统 (OS)：&lt;/p>
&lt;blockquote>
&lt;p>从 Ussuri 版本开始，OpenStack 不再支持 CentOS 7 作为主机操作系统。Train 版本同时支持 CentOS 7 和 8，并提供了迁移路径。有关迁移到 CentOS 8 的信息，请参阅 &lt;a href="https://docs.openstack.org/kolla-ansible/train/user/centos8.html">Kolla Ansible Train 文档&lt;/a>。
不再支持 CentOS Linux 8（相对于 CentOS Stream 8）作为主机操作系统。Victoria 版本将来会同时支持 CentOS Linux 8 和 CentOS Stream 8，并提供迁移途径。&lt;/p>
&lt;/blockquote>
&lt;ul>
&lt;li>CentOS Stream 8&lt;/li>
&lt;li>Debian Bullseye (11)&lt;/li>
&lt;li>RHEL 8（已弃用）&lt;/li>
&lt;li>Rocky Linux 8&lt;/li>
&lt;li>Ubuntu Focal (20.04)&lt;/li>
&lt;/ul>
&lt;h2 id="支持的容器镜像">支持的容器镜像&lt;/h2>
&lt;p>为获得最佳结果，基本容器映像分发应与主机操作系统分发匹配。支持以下值 kolla_base_distro：&lt;/p>
&lt;ul>
&lt;li>centos&lt;/li>
&lt;li>debian&lt;/li>
&lt;li>rhel（已弃用）&lt;/li>
&lt;li>ubuntu&lt;/li>
&lt;/ul>
&lt;p>有关哪些发行版支持哪些图像的详细信息，请参阅 &lt;a href="https://docs.openstack.org/kolla/latest/support_matrix">Kolla 支持矩阵&lt;/a>。&lt;/p>
&lt;h1 id="kolla-ansible">Kolla-ansible&lt;/h1>
&lt;p>注意：&lt;/p>
&lt;ul>
&lt;li>宿主机至少需要两个可用的网卡，在 &lt;code>/etc/kolla/globals.yml&lt;/code> 文件中，被描述为如下两个关键字
&lt;ul>
&lt;li>&lt;strong>network_interface&lt;/strong> # 管理网络、API 网络的网卡&lt;/li>
&lt;li>&lt;strong>neutron_external_interface&lt;/strong> # Neutron 外部接口就是指内网环境。该网络设备将会桥接到 &lt;code>ovs-switch&lt;/code> 这个桥设备上。虚拟机是通过这块网卡访问外网。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h2 id="安装依赖并使用虚拟环境">安装依赖并使用虚拟环境&lt;/h2>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>sudo apt update
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>sudo apt install python3-dev libffi-dev gcc libssl-dev
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>创建一个虚拟环境以安装部署工具&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>export KOLLA_DIR&lt;span style="color:#f92672">=&lt;/span>/root/kolla
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>mkdir -p &lt;span style="color:#e6db74">${&lt;/span>KOLLA_DIR&lt;span style="color:#e6db74">}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>sudo apt install python3-venv
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>python3 -m venv &lt;span style="color:#e6db74">${&lt;/span>KOLLA_DIR&lt;span style="color:#e6db74">}&lt;/span>/venv
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>source &lt;span style="color:#e6db74">${&lt;/span>KOLLA_DIR&lt;span style="color:#e6db74">}&lt;/span>/venv/bin/activate
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>pip install -U pip -i https://pypi.tuna.tsinghua.edu.cn/simple
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>pip install &lt;span style="color:#e6db74">&amp;#39;ansible&amp;lt;5.0&amp;#39;&lt;/span> -i https://pypi.tuna.tsinghua.edu.cn/simple
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="安装-kolla-ansible">安装 Kolla-ansible&lt;/h2>
&lt;p>这里说的 Kolla-ansible 主要指的是用于部署 Openstack 的 Ansible Playbook~~~~&lt;/p>
&lt;p>确定要安装的版本。Kolla-ansible 的版本号与 Openstack 的版本号保持一致，这里以 Openstack 的 &lt;code>xena&lt;/code> 版本为例&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>export KOLLA_BRANCH_NAME&lt;span style="color:#f92672">=&lt;/span>xena
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>使用 pip 安装 kolla-ansible 及其依赖项。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>pip install git+https://opendev.org/openstack/kolla-ansible@&lt;span style="color:#e6db74">${&lt;/span>KOLLA_BRANCH_NAME&lt;span style="color:#e6db74">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>创建配置目录&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>sudo mkdir -p /etc/kolla
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>sudo chown $USER:$USER /etc/kolla
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>cp -r &lt;span style="color:#e6db74">${&lt;/span>KOLLA_DIR&lt;span style="color:#e6db74">}&lt;/span>/venv/share/kolla-ansible/etc_examples/kolla/* /etc/kolla
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>将 Ansible Playbook 所需的 Inventory 拷贝到当前目录&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>cp &lt;span style="color:#e6db74">${&lt;/span>KOLLA_DIR&lt;span style="color:#e6db74">}&lt;/span>/venv/share/kolla-ansible/ansible/inventory/* .
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="配置-ansible">配置 Ansible&lt;/h2>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>mkdir -p /etc/ansible
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>tee /etc/ansible/ansible.cfg &amp;gt; /dev/null &lt;span style="color:#e6db74">&amp;lt;&amp;lt;EOF
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">[defaults]
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">host_key_checking=False
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">pipelining=True
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">forks=100
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">EOF&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="all-in-one-部署-openstack">All-in-one 部署 OpenStack&lt;/h2>
&lt;h3 id="配置-kolla">配置 Kolla&lt;/h3>
&lt;p>为 &lt;code>/etc/kolla/passwords.yml&lt;/code> 文件生成密码&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>kolla-genpwd
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>配置 &lt;code>/etc/kolla/globals.yml&lt;/code> 文件&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>kolla_base_distro: &lt;span style="color:#e6db74">&amp;#34;ubuntu&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>kolla_install_type: &lt;span style="color:#e6db74">&amp;#34;source&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>network_interface: &lt;span style="color:#e6db74">&amp;#34;eno3&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># neutron 外部接口就是指内网环境。该网络设备将会桥街道 ovs-switch 这个桥设备上。&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>neutron_external_interface: &lt;span style="color:#e6db74">&amp;#34;eno4&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>kolla_internal_vip_address: &lt;span style="color:#e6db74">&amp;#34;192.168.88.236&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>enable_cinder: &lt;span style="color:#e6db74">&amp;#34;yes&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>openstack_release: &lt;span style="color:#e6db74">&amp;#34;xena&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>enable_haproxy: &lt;span style="color:#e6db74">&amp;#34;no&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="配置-inventory">配置 Inventory&lt;/h3>
&lt;p>略，直接使用 localhost 即可&lt;/p>
&lt;h3 id="部署依赖并检查环境">部署依赖并检查环境&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>kolla-ansible -i ./all-in-one bootstrap-servers
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>kolla-ansible -i ./all-in-one prechecks
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="部署-openstack">部署 OpenStack&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>kolla-ansible -i ./all-in-one pull ？？？待验证
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>kolla-ansible -i ./all-in-one deploy
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="multinode-部署-openstack">Multinode 部署 OpenStack&lt;/h2></description></item><item><title>Docs: OpenTelemetry</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/6.%E5%8F%AF%E8%A7%82%E6%B5%8B%E6%80%A7/opentelemetry/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/6.%E5%8F%AF%E8%A7%82%E6%B5%8B%E6%80%A7/opentelemetry/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://github.com/open-telemetry">GitHub 组织，OpenTelemetry&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://opentelemetry.io/">官网&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://opentelemetry.io/docs/">官方文档&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://mp.weixin.qq.com/s/bcziZg8RhCrMGYgFeN76cw">公众号-OpenTelemetry，OpenTelemetry 核心原理篇 ：怎么理解分布式链路追踪技术？&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://mp.weixin.qq.com/s/3dD0hIuqpXdepLVC6V7aoA">公众号-OpenTelemetry，在生产环境如何选择靠谱的 APM 系统&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>&lt;strong>OpenTelemetry(开放式遥测技术，简称 OTel)&lt;/strong> 于 2019 年 5 月由 &lt;a href="https://opentracing.io/">OpenTracing&lt;/a> 与 OpenCensus 合并而成(&lt;a href="https://opensource.googleblog.com/2019/05/opentelemetry-merger-of-opencensus-and.html">Google Open Source&lt;/a>)，是一组 &lt;strong>API、SDK、工具、更是一种遥测标准&lt;/strong>，旨在创建和管理 **Telemetry Data(遥测数据)。**通过 OpenTelemetry 标准创建的程序，可以采集 OpenTelemetry 标准的遥测数据，并发送到我们指定的后端中。OpenTelemetry 支持各种流行的开源后端项目，比如 Prometheus、Jaeger 等。&lt;/p>
&lt;blockquote>
&lt;p>遥测数据包括：Traces(链路追踪数据)、Metrics(指标数据)、logs(日志数据)&lt;/p>
&lt;/blockquote>
&lt;p>注意：OpenTelemetry 不是像 Prometheus、Jaeger 那样的可观察性后端。相反，OpenTelemetry 支持将数据导出到各种开源和商业的后端产品中，它提供了一个可插拔的架构，因此可以轻松添加其他技术协议和格式。&lt;/p>
&lt;p>OTEL 之于可观测性，类似 OCI 之于容器。&lt;/p>
&lt;h2 id="opentelemetry-组件">OpenTelemetry 组件&lt;/h2>
&lt;p>目前，OpenTelemetry 由以下几个主要组件组成：&lt;/p>
&lt;ul>
&lt;li>&lt;strong>规范&lt;/strong> # 与编程语言无关的规范，规定了遥测数据格式等&lt;/li>
&lt;li>&lt;strong>工具&lt;/strong> # 用于采集、转换、导出遥测数据的工具&lt;/li>
&lt;li>&lt;strong>SDK&lt;/strong> # 用于为各种编程语言提供编写符合 OpenTelemetry 规范的工具&lt;/li>
&lt;li>&lt;strong>自动 instrumentation 和 贡献包&lt;/strong> # 没搞懂这是什么？&lt;/li>
&lt;/ul>
&lt;h2 id="opentelemetry-历史">OpenTelemetry 历史&lt;/h2>
&lt;h1 id="opentelemetry-实现">OpenTelemetry 实现&lt;/h1>
&lt;p>&lt;a href="https://github.com/grafana/agent">GitHub 项目，grafana/agent&lt;/a> #
&lt;a href="https://github.com/flashcatcloud/categraf">GitHub 项目，flashcatcloud/categraf&lt;/a> # 通过配置文件，采集所有数据，然后 Push 给 Prom(Prom 需要使用 &lt;code>--web.enable-remote-write-receiver&lt;/code> 为自身开启远程写功能)，暂时没有等待 pull 的功能(截止 2022.6.1 v0.1.0 版本)
&lt;a href="https://www.guance.com/">https://www.guance.com/&lt;/a> 观测云。。。。这个产品。。怎么说呢。。上来就让人各种注册才能体验的感觉很不好。。而且在云原生社区可观测性 SIG 群里，这家人的表达方式和处理事情的态度给人的感觉也不好~工作内部矛盾放在群里说。。还揭露个人隐私。。。。o(╯□╰)o&lt;/p>
&lt;h2 id="grafana-agent">Grafana Agent&lt;/h2>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://github.com/grafana/agent">GitHub 项目，grafana/agent&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://grafana.com/docs/agent/latest/">官方文档&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>Grafana Agent 收集遥测数据并将其转发到 Grafana Stack、Grafana Cloud 或 Grafana Enterprise 的开源部署，然后可以在其中分析您的数据。您可以在 Kubernetes 和 Docker 上安装 Grafana Agent，或者作为 Linux、macOS 和 Windows 机器的系统进程。&lt;/p>
&lt;p>Grafana Agent 是开源的，其源代码可在 GitHub 上的&lt;a href="https://github.com/grafana/agent">https://github.com/grafana/agent&lt;/a>上获得。&lt;/p>
&lt;p>Grafana Agent 适用于希望收集和转发遥测数据以进行分析和待命警报的工程师、操作员或管理员。那些运行 Grafana Agent 的人必须安装和配置 Grafana Agent 才能正确收集遥测数据并监控正在运行的代理的健康状况。&lt;/p>
&lt;h1 id="最佳实践">最佳实践&lt;/h1>
&lt;p>&lt;a href="https://mp.weixin.qq.com/s/wiAT4GHaeitn2o6Byr_kGA">公众号-云原生小白，Opentelemetry 实践分享 - Golang篇&lt;/a>&lt;/p></description></item><item><title>Docs: Percona Monitoring and Management</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/5.%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8/%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/percona/percona-monitoring-and-management/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/5.%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8/%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/percona/percona-monitoring-and-management/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://www.percona.com/software/database-tools/percona-monitoring-and-management">官网介绍&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.percona.com/doc/percona-monitoring-and-management/2.x/index.html">官方文档&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.cnblogs.com/okchy/p/13605701.html">原文链接&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>分析慢查询的:&lt;a href="https://www.percona.com/blog/2020/10/07/how-to-find-query-slowdowns-using-percona-monitoring-and-management/">https://www.percona.com/blog/2020/10/07/how-to-find-query-slowdowns-using-percona-monitoring-and-management/&lt;/a>&lt;/p>
&lt;p>基于 pmm2 去排查故障的官方文档:&lt;a href="https://www.percona.com/blog/2020/07/15/mysql-query-performance-troubleshooting-resource-based-approach/">https://www.percona.com/blog/2020/07/15/mysql-query-performance-troubleshooting-resource-based-approach/&lt;/a>&lt;/p>
&lt;p>&lt;strong>Percona Monitoring and Management(简称 PMM)&lt;/strong> 是一个用于管理和监控 MySQL、PostgreSQL、MongoDB 和 ProxySQL 性能的开源平台。它是由 Percona 与管理数据库服务、支助和咨询领域的专家合作开发的。&lt;/p>
&lt;p>PMM 是一种免费的开源解决方案，您可以在自己的环境中运行它，以获得最大的安全性和可靠性。它为 MySQL、PostgreSQL 和 MongoDB 服务器提供了全面的基于时间的分析，以确保您的数据尽可能高效地工作。&lt;/p>
&lt;p>PMM 平台基于支持可伸缩性的客户机-服务器模型。它包括以下模块:&lt;/p>
&lt;p>PMM 客户机安装在您想要监视的每个数据库主机上。它收集服务器指标、一般系统指标和查询分析数据，以获得完整的性能概述。&lt;/p>
&lt;p>PMM 服务器是 PMM 的中心部分，它聚合收集到的数据，并在 web 界面中以表格、仪表板和图形的形式显示这些数据。&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/hxu3v9/1616133512427-90c73526-d534-4d64-a402-c2c42373abb2.png" alt="">&lt;/p>
&lt;p>模块被打包以便于安装和使用。假设用户不需要了解组成每个模块的具体工具是什么，以及它们如何交互。然而，如果您想充分利用 PMM 的潜力，内部结构是重要的。&lt;/p>
&lt;p>PMM 是一种工具的集合，它被设计成可以无缝地协同工作。有些是由 Percona 开发的，有些是第三方开源工具。&lt;/p>
&lt;p>PMM Server&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/hxu3v9/1616133512441-02d3d028-1588-42fc-a8a4-4d1736674427.png" alt="">&lt;/p>
&lt;p>PMM 服务器在作为中央监视主机的机器上运行。它通过以下方式作为设备分发:&lt;/p>
&lt;p>*可用于运行容器的 Docker 映像&lt;/p>
&lt;p>*可以在 VirtualBox 或其他管理程序中运行的 OVA(打开虚拟设备)&lt;/p>
&lt;p>*您可以通过 Amazon Web 服务运行的 AMI (Amazon Machine Image)&lt;/p>
&lt;p>PMM 服务器包括以下工具:&lt;/p>
&lt;p>*查询分析(QAN)允许您在一段时间内分析 MySQL 查询性能。除客户端 QAN 代理外，还包括:&lt;/p>
&lt;p>QAN API 是存储和访问运行在 PMM 客户机上的 QAN 代理收集的查询数据的后端。&lt;/p>
&lt;p>QAN Web App 是一个可视化收集查询分析数据的 Web 应用程序。&lt;/p>
&lt;p>*Metrics Monitor 提供了对 MySQL 或 MongoDB 服务器实例至关重要的指标的历史视图。它包括以下内容:&lt;/p>
&lt;p>Prometheus 是一个第三方时间序列数据库，它连接到运行在 PMM 客户机上的出口商，并汇总出口商收集的指标。&lt;/p>
&lt;p>ClickHouse 是一个第三方的面向列的数据库，它促进了查询分析功能。有关更多信息，请参见 ClickHouse 文档。&lt;/p>
&lt;p>Grafana 是一个第三方的仪表盘和图形生成器，用于将普罗米修斯在直观的 web 界面中聚合的数据可视化。&lt;/p>
&lt;p>Percona 仪表板是由 Percona 为 Grafana 开发的一套仪表板。&lt;/p>
&lt;p>所有工具都可以从 PMM 服务器的 web 界面(登录页面)访问。&lt;/p>
&lt;p>PMM Client&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/hxu3v9/1616133512448-678fe0f9-6e67-49e3-bd57-f740c4f96042.png" alt="">&lt;/p>
&lt;p>每个 PMM 客户机收集关于一般系统和数据库性能的各种数据，并将这些数据发送到相应的 PMM 服务器。&lt;/p>
&lt;p>PMM 客户端包括以下内容:&lt;/p>
&lt;p>PMM -admin 是用于管理 PMM 客户机的命令行工具，例如，用于添加和删除您想要监视的数据库实例。&lt;/p>
&lt;p>PMM -agent 是一个客户端组件，一个最小的命令行接口，它是负责提供客户端功能的中心入口点:它进行客户端身份验证，获取存储在 PMM 服务器上的客户端配置，管理导出程序和其他代理。&lt;/p>
&lt;p>node_exporters 是一个收集一般系统指标的 Prometheus 端口。&lt;/p>
&lt;p>mysqld_exporters 是一个收集 MySQL 服务器指标的 Prometheus 端口。&lt;/p>
&lt;p>mongodb_exporters 是一个收集 MongoDB 服务器指标的 Prometheus 端口。&lt;/p>
&lt;p>postgres_端口是一个收集 PostgreSQL 性能指标的 Prometheus 端口。&lt;/p>
&lt;p>proxysql_exporters 是一个收集 ProxySQL 性能指标的 Prometheus 端口。&lt;/p>
&lt;p>为了使从 PMM 客户机到 PMM 服务器的数据传输更加安全，所有端口都能够使用 SSL/TLS 加密的连接，并且它们与 PMM 服务器的通信受到 HTTP 基本身份验证的保护。&lt;/p>
&lt;p>参考：&lt;/p>
&lt;p>端口：以下端口必须在 pmm server 和 client 之间开放;&lt;/p>
&lt;p>pmm server 需要开放 80 或 443 端口用于 pmm client 访问 pmm web。&lt;/p>
&lt;p>pmm client 端必须开放以下默认端口采集数据，可以通过 pmm-admin addc 命令进行修改。&lt;/p>
&lt;p>42000 For PMM to collect genenal system metrics.&lt;/p>
&lt;p>42001 This port is used by a service which collects query performance data and makes it available to QAN.&lt;/p>
&lt;p>42002 For PMM to collect MySQL server metrics.&lt;/p>
&lt;p>42003 For PMM to collect MongoDB server metrics.&lt;/p>
&lt;p>42004 For PMM to collect ProxySQL server metrics.&lt;/p>
&lt;h1 id="部署-pmm">部署 PMM&lt;/h1>
&lt;p>参考：官方文档&lt;/p>
&lt;p>安装步骤&lt;/p>
&lt;p>docker 部署 pmm 与 mysql 监控&lt;/p>
&lt;p>安装 docker&lt;/p>
&lt;p>yum install -y yum-utils device-mapper-persistent-data lvm2&lt;/p>
&lt;p>yum-config-manager &amp;ndash;add-repo &lt;a href="http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo">http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo&lt;/a>&lt;/p>
&lt;p>yum makecache fast&lt;/p>
&lt;p>yum -y install docker-ce&lt;/p>
&lt;p>systemctl start docker&lt;/p>
&lt;p>docker run hello-world&lt;/p>
&lt;p>PMM Server：192.168.24.90&lt;/p>
&lt;p>PMM Client：192.168.24.92&lt;/p>
&lt;p>1.Docker 安装 PMM Server&lt;/p>
&lt;p>这里使用的 Docker 标签适用于最新版本的 PMM 2(2.9.1)，但是您可以指定任何可用的标签来使用相应版本的 PMM 服务器。&lt;/p>
&lt;p>度量收集消耗磁盘空间。PMM 需要为每个被监视的数据库节点提供大约 1GB 的存储空间，数据保留时间设置为一周。(默认情况下，数据保留时间为 30 天。)要减小 Prometheus 数据库的大小，可以考虑禁用表统计信息。&lt;/p>
&lt;p>尽管一个受监控的数据库节点的最小内存量为 2 GB，但内存使用不会随着节点数量的增加而增加。例如，16GB 足够用于 20 个节点。&lt;/p>
&lt;p>#版本可自选&lt;/p>
&lt;p>docker create -v /opt/prometheus/data -v /opt/consul-data -v /var/lib/mysql -v /var/lib/grafana &amp;ndash;name pmm-data percona/pmm-server:2 /bin/true&lt;/p>
&lt;p>2.启动&lt;/p>
&lt;p>#必须开启防火墙&lt;/p>
&lt;p>docker run -d -p 80:80 -p 443:443 &amp;ndash;volumes-from pmm-data &amp;ndash;name pmm-server &amp;ndash;restart always percona/pmm-server:2&lt;/p>
&lt;p>端口默认是 80 ，如果 80 端口被占用，可改为其它端口号 比如 81&lt;/p>
&lt;p>3.查看 docker 运行状态&lt;/p>
&lt;p>docker ps -a&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/hxu3v9/1616133512459-b4a07422-0748-4be5-bbdd-db952ae5cad9.png" alt="">&lt;/p>
&lt;p>4.浏览器访问，地址一般是 http://ip 地址:端口，也可以直接输 ip 地址； 注意，一般端口默认为 80，默认用户名：admin，默认密码：admin&lt;/p>
&lt;p>例：&lt;a href="http://192.168.24.90:80">http://192.168.24.90:80&lt;/a>&lt;/p>
&lt;p>5.安装 pmm-client 客户端。&lt;/p>
&lt;p>yum install &lt;a href="https://repo.percona.com/yum/percona-release-latest.noarch.rpm">https://repo.percona.com/yum/percona-release-latest.noarch.rpm&lt;/a> -y&lt;/p>
&lt;p>yum install pmm2-client -y&lt;/p>
&lt;p>6.连接 PMM Server。&lt;/p>
&lt;p>pmm-admin config &amp;ndash;server-insecure-tls &amp;ndash;server-url=\https://admin:admin@&amp;lt;IP Address&amp;gt;:443&lt;/p>
&lt;p>例：pmm-admin config &amp;ndash;server-insecure-tls &amp;ndash;server-url=https://admin:admin@192.168.24.90:443&lt;/p>
&lt;p>注：PMM2 不需要像 PMM1 输入指定命令添加 Linux 主机监控&lt;/p>
&lt;p>当你使用 pmm-admin config 配置了要监控的节点时，PMM2 从那时自动开始收集 Linux 指标。&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/hxu3v9/1616133512457-0d30d8f9-e92b-4ea3-b25a-2b7da2d86621.png" alt="">&lt;/p>
&lt;p>7.登陆浏览器访问主机监控数据&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/hxu3v9/1616133512459-6f938df2-c730-4504-bf71-e101ced88649.png" alt="">&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/hxu3v9/1616133512488-8a3a80a1-199f-451b-a1ef-b8915f8d5e15.png" alt="">&lt;/p>
&lt;p>#pmm-admin 管理命令&lt;/p>
&lt;p>annotate [&amp;lt;flags&amp;gt;] &amp;lt;text&amp;gt;&lt;/p>
&lt;p>在 Grafana 图表中添加注释&lt;/p>
&lt;p>config [&amp;lt;flags&amp;gt;] [&amp;lt;node-address&amp;gt;] [&amp;lt;node-type&amp;gt;] [&amp;lt;node-name&amp;gt;]&lt;/p>
&lt;p>配置本地 pmm-agent&lt;/p>
&lt;p>list [&amp;lt;flags&amp;gt;]&lt;/p>
&lt;p>显示在此节点上运行的服务和代理&lt;/p>
&lt;p>status&lt;/p>
&lt;p>显示关于本地 pmm 代理的信息&lt;/p>
&lt;p>summary [&amp;lt;flags&amp;gt;]&lt;/p>
&lt;p>获取系统数据以进行诊断&lt;/p>
&lt;p>add external &amp;ndash;listen-port=LISTEN-PORT [&lt;!-- raw HTML omitted -->]&lt;/p>
&lt;p>将外部监视添加&lt;/p>
&lt;p>add mongodb [&lt;!-- raw HTML omitted -->] [&lt;!-- raw HTML omitted -->] [&lt;!-- raw HTML omitted -->]&lt;/p>
&lt;p>监控 MongoDB&lt;/p>
&lt;p>add mysql [&lt;!-- raw HTML omitted -->] [&lt;!-- raw HTML omitted -->] [&lt;!-- raw HTML omitted -->]&lt;/p>
&lt;p>监控 MySQL&lt;/p>
&lt;p>add postgresql [&lt;!-- raw HTML omitted -->] [&lt;!-- raw HTML omitted -->] [&lt;!-- raw HTML omitted -->]&lt;/p>
&lt;p>监控 PostgreSQL&lt;/p>
&lt;p>add proxysql [&lt;!-- raw HTML omitted -->] [&lt;!-- raw HTML omitted -->] [&lt;!-- raw HTML omitted -->]&lt;/p>
&lt;p>监控 ProxySQL&lt;/p>
&lt;p>register [&lt;!-- raw HTML omitted -->] [&lt;!-- raw HTML omitted -->] [&lt;!-- raw HTML omitted -->] [&lt;!-- raw HTML omitted -->]&lt;/p>
&lt;p>注册当前节点到 PMM 服务器&lt;/p>
&lt;p>remove [&lt;!-- raw HTML omitted -->] &lt;!-- raw HTML omitted --> [&lt;!-- raw HTML omitted -->]&lt;/p>
&lt;p>从监控中删除服务&lt;/p>
&lt;p>7.添加 mysql 监控。&lt;/p>
&lt;p>MySQL 服务器添加指定权限用户&lt;/p>
&lt;p>create user pmm@&amp;rsquo;%&amp;rsquo; identified by &amp;lsquo;pmmpassword&amp;rsquo;;&lt;/p>
&lt;p>grant select,process,super,replication client on &lt;em>.&lt;/em> to &amp;lsquo;pmm&amp;rsquo;@&amp;rsquo;%&amp;rsquo;;&lt;/p>
&lt;p>grant update,delete,drop on performance_schema.* to &amp;lsquo;pmm&amp;rsquo;@&amp;rsquo;%&amp;rsquo;;&lt;/p>
&lt;p>flush privileges;&lt;/p>
&lt;p>#授权密码如报错：Your password does not satisfy the current policy requirements&lt;/p>
&lt;p>set global validate_password_policy=LOW;&lt;/p>
&lt;p>MySQL8.0 版本设置：set global validate_password.policy=LOW;&lt;/p>
&lt;p>查询分析获得从 MySQL 中获取指标数据有两种可能的来源：慢查询日志和 Performance Schema&lt;/p>
&lt;p>添加 Performance Schema 数据字典监控&lt;/p>
&lt;p>pmm-admin add mysql &amp;ndash;query-source=perfschema &amp;ndash;username=pmm &amp;ndash;password=pmmpassword ps-mysql&lt;/p>
&lt;p>添加慢日志监控&lt;/p>
&lt;p>pmm-admin add mysql &amp;ndash;query-source=slowlog &amp;ndash;username=pmm &amp;ndash;password=pmmpassword sl-mysql&lt;/p>
&lt;p>查看运行的服务&lt;/p>
&lt;p>pmm-admin list&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/hxu3v9/1616133512489-86f410ae-d99d-49a2-a505-2a9826ff1172.png" alt="">&lt;/p>
&lt;p>9.pmm 服务器页面查看&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/hxu3v9/1616133512483-5837728e-5d7e-4102-b343-9935ee58ac83.png" alt="">&lt;/p>
&lt;p>点击 Query Analytics 进入 SQL 语句分析&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/hxu3v9/1616133512502-b408704d-70af-4efe-97b1-db073b551516.png" alt="">&lt;/p>
&lt;p>10.MySQL 最佳配置&lt;/p>
&lt;p>慢日志设置&lt;/p>
&lt;p>如果你使用 Percona 分支版本，正确的慢查询日志配置将以最小的开销提供最多的信息。否则，如果支持请使用 PerformanceSchema。&lt;/p>
&lt;p>按定义，慢查询日志应该只记录慢查询。这些查询的执行时间超过了特定的阈值。这个阈值由参数 long_query_time 指定。&lt;/p>
&lt;p>在高负载的应用中，频繁快速的查询比罕见的慢速查询对性能的影响要大的多。为全面分析你的查询流量，设置 long_query_time 为 0，这样所有的查询语句都将被记录。&lt;/p>
&lt;p>然而，记录所有的查询将消耗 I/O 带宽，并导致慢查询日志增长很快。为了限制记录到慢查询日志中的查询数量，使用 Percona 分支版本中的查询采样功能。&lt;/p>
&lt;p>查询采样可能导致一些罕见的慢查询无法被记录到慢查询日志中。为了避免这种情况，使用 slow_query_long_always_write_time 参数指定哪类查询应该被忽略采样。也就是说，长时间的慢查询应该始终记录到慢查询日志中。&lt;/p>
&lt;p>Performance Schema 设置&lt;/p>
&lt;p>PMM 查询数据的默认源是慢查询日志。这在 MySQL5.1 及以后的版本中可用。从 MySQL5.6 版本（包括 Percona 分支版本 5.6 及以后版本），你可以选择从 Performance Schema 中解析查询数据，而不是慢查询日志。从 MySQL5.6.6 开始，默认启用 Performance Schema。&lt;/p>
&lt;p>Performance Schema 不像慢查询日志那样有丰富的数据，但是它具有所有关键的数据，并且通常解析很快。如果您没有使用 Percona 分支版本（支持对慢查询日志采样），Performance Schema 是更好的选择。&lt;/p>
&lt;p>启用 Performance Schema ，要将 performance_schema 参数设置为 ON:&lt;/p>
&lt;p>SHOW VARIABLES LIKE &amp;lsquo;performance_schema&amp;rsquo;;&lt;/p>
&lt;p>+&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;ndash;+&amp;mdash;&amp;mdash;-+&lt;/p>
&lt;p>| Variable_name | Value |&lt;/p>
&lt;p>+&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;ndash;+&amp;mdash;&amp;mdash;-+&lt;/p>
&lt;p>| performance_schema | ON |&lt;/p>
&lt;p>+&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;ndash;+&amp;mdash;&amp;mdash;-+&lt;/p>
&lt;p>如果这个参数没有设置为 ON，在 my.cnf 配置文件中添加以下内容并重启 MySQL 服务。&lt;/p>
&lt;p>[mysql]&lt;/p>
&lt;p>performance_schema=ON&lt;/p>
&lt;p>如果您使用了自定义的 Performance Schema 配置，确认 statement_digest 消费者已经启用：&lt;/p>
&lt;p>select * from setup_consumers;&lt;/p>
&lt;p>+&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;-+&amp;mdash;&amp;mdash;&amp;mdash;+&lt;/p>
&lt;p>| NAME | ENABLED |&lt;/p>
&lt;p>+&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;-+&amp;mdash;&amp;mdash;&amp;mdash;+&lt;/p>
&lt;p>| events_stages_current | NO |&lt;/p>
&lt;p>| events_stages_history | NO |&lt;/p>
&lt;p>| events_stages_history_long | NO |&lt;/p>
&lt;p>| events_statements_current | YES |&lt;/p>
&lt;p>| events_statements_history | YES |&lt;/p>
&lt;p>| events_statements_history_long | NO |&lt;/p>
&lt;p>| events_transactions_current | NO |&lt;/p>
&lt;p>| events_transactions_history | NO |&lt;/p>
&lt;p>| events_transactions_history_long | NO |&lt;/p>
&lt;p>| events_waits_current | NO |&lt;/p>
&lt;p>| events_waits_history | NO |&lt;/p>
&lt;p>| events_waits_history_long | NO |&lt;/p>
&lt;p>| global_instrumentation | YES |&lt;/p>
&lt;p>| thread_instrumentation | YES |&lt;/p>
&lt;p>| statements_digest | YES |&lt;/p>
&lt;p>+&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;-+&amp;mdash;&amp;mdash;&amp;mdash;+&lt;/p>
&lt;p>15 rows in set (0.00 sec)&lt;/p>
&lt;p>重要&lt;/p>
&lt;p>Performance Schema 生产者在 MySQL5.6.6 及之后的版本中默认启用。它在 MySQL5.6 之前的版本中完全不可用。如果某些生产者没有被启用，您在 MySQLPerformanceSchemaDashboard 的 dashboard 中看不到相应的图。启用所有的生产者，在启动 MySQL 服务时设置 &amp;ndash;performance_schema_instrument 选项为 &amp;lsquo;%=on&amp;rsquo;。&lt;/p>
&lt;p>mysqld &amp;ndash;performance-schema-instrument=&amp;rsquo;%=on&amp;rsquo;&lt;/p>
&lt;p>这个选项会带来额外的负载，请小心使用。&lt;/p>
&lt;p>如果实例已经在运行，配置 QAN agent 从 Performance Schema 中收集数据：&lt;/p>
&lt;p>1.打开 PMM Query Analytics dashboard。&lt;/p>
&lt;p>2.点击 Settings 按钮。&lt;/p>
&lt;p>3.打开 Settings 部分。&lt;/p>
&lt;p>4.从收集下拉列表中选择 PerformanceSchema。&lt;/p>
&lt;p>5.点击 Apply 保存更改。&lt;/p>
&lt;p>如果您使用 pmm-admin 工具添加一个新的监控实例，使用 &amp;ndash;query-sourceperfschema 选项：&lt;/p>
&lt;p>使用 root 用户或者 sudo 命令执行以下命令&lt;/p>
&lt;p>pmm-admin add mysql &amp;ndash;username=pmm &amp;ndash;password=pmmpassword &amp;ndash;query-source=&amp;lsquo;perfschema&amp;rsquo; ps-mysql 127.0.0.1:3306&lt;/p>
&lt;p>更多信息，请执行 pmm-admin add mysql&amp;ndash;help。&lt;/p>
&lt;p>MySQL InnoDB 指标&lt;/p>
&lt;p>为图形收集指标和统计信息会增加开销。您可以使用收集和绘制低开销的指标，在故障排除时启用高开销的指标。&lt;/p>
&lt;p>InnoDB 指标提供了有关 InnoDB 操作的详细信息。尽管您可以选择捕获指定的计数器，但是即使始终启用它们，它们的开销也很低。启用所有的 InnoDB 指标，设置全局参数 innodb_monitor_enable 为 all:&lt;/p>
&lt;p>SET GLOBAL innodb_monitor_enable&lt;/p>
&lt;p>Percona 分支版本的特殊设置&lt;/p>
&lt;p>默认情况下，并非所有 Metrics Monitor 的 dashboard 都可以用于所有 MySQL 分支和配置：Oracle 版，Percona 版或者 MariaDB。一些图形适用于 Percona 版本和专有的插件和额外的配置。&lt;/p>
&lt;p>MySQL 用户统计信息（userstat）&lt;/p>
&lt;p>用户统计信息是 Percona 分支版本和 MariaDB 分支版本的功能。它提供了用户活动、单个表和索引访问的信息。在某些情况下，收集用户统计信息可能会带来高昂的开销，所以请谨慎使用此功能。&lt;/p>
&lt;p>启用收集用户统计信息，设置 userstat 参数为 1。&lt;/p>
&lt;p>查询相应时间插件&lt;/p>
&lt;p>查询响应时间分布是 Percona 分支版的可用功能。它提供了不同查询组的查询响应时间变化的信息，通常可以在导致严重问题之前发现性能问题。&lt;/p>
&lt;p>启用收集查询响应时间：&lt;/p>
&lt;p>1.安装 QUERY_RESPONSE_TIME 插件 mysql&amp;gt;INSTALL PLUGIN QUERY_RESPONSE_TIME_AUDIT SONAME&amp;rsquo;query_response_time.so&amp;rsquo;;mysql&amp;gt;INSTALL PLUGIN QUERY_RESPONSE_TIME SONAME&amp;rsquo;query_response_time.so&amp;rsquo;;mysql&amp;gt;INSTALL PLUGIN QUERY_RESPONSE_TIME_READ SONAME&amp;rsquo;query_response_time.so&amp;rsquo;;mysql&amp;gt;INSTALL PLUGIN QUERY_RESPONSE_TIME_WRITE SONAME&amp;rsquo;query_response_time.so&amp;rsquo;;&lt;/p>
&lt;p>2.设置全局参数 query_response_time_stats 为 ON。 mysql&amp;gt;SET GLOBAL query_response_time_stats=ON;&lt;/p>
&lt;p>相关信息：Percona 分支版官方文档&lt;/p>
&lt;p>query_response_time_stats: &lt;a href="https://www.percona.com/doc/percona-server/5.7/diagnostics/responsetimedistribution.html#queryresponsetime_stats">https://www.percona.com/doc/percona-server/5.7/diagnostics/responsetimedistribution.html#queryresponsetime_stats&lt;/a>&lt;/p>
&lt;p>Response time 介绍: &lt;a href="https://www.percona.com/doc/percona-server/5.7/diagnostics/responsetimedistribution.html#installing-the-plugins">https://www.percona.com/doc/percona-server/5.7/diagnostics/responsetimedistribution.html#installing-the-plugins&lt;/a>&lt;/p>
&lt;p>logslowrate_limit&lt;/p>
&lt;p>log_slow_rate_limit 参数定义了慢查询日志记录查询的比例。一个好的经验是每秒记录 100 个查询。例如如果您的 Percona 实例 QPS 为 10000，您应该设 log_slow_rate_limit 为 100,这样慢日志会记录每 100 个查询。&lt;/p>
&lt;p>注意&lt;/p>
&lt;p>当使用查询采样时，设置 log_slow_rate_type 为 query，以便它应用的是查询而不是会话。最好设置 log_slow_verbosity 为 full，以便在慢查询日志中记录每个记录的查询语句的最大的信息量。&lt;/p>
&lt;p>logslowverbosity&lt;/p>
&lt;ul>
&lt;li>log_slow_verbosity 参数指定了慢查询日志中包含多少信息。最好设置 log_slow_verbosity 为 full，以便存储有关每个记录的查询语句的最大信息量。&lt;/li>
&lt;/ul>
&lt;p>slowqueryloguseglobal_control&lt;/p>
&lt;p>默认情况下，慢查询日志只适用于新会话。如果希望调整慢查询日志设置并将这些设置应用于现有连接，请将 slow_query_log_use_global_control 设置为 all。&lt;/p>
&lt;p>为 PMM 配置 MySQL8.0&lt;/p>
&lt;p>MySQL8（在 8.0.4 版本中）改变了对客户端身份验证的方式。 default_authentication_pluging 参数设置为 caching_sha2_password。默认值的改变意味着 MySQL 的驱动需要支持 SHA-256 身份验证。另外，在使用 caching_sha2_password 时，必须对 MySQL8 的加密通道进行加密。&lt;/p>
&lt;p>PMM 使用的 MySQL 驱动还不支持 SHA-256 身份验证。&lt;/p>
&lt;p>为支持当前 MySQL 的版本，PMM 需要设置专有的 MySQL 用户。该 MySQL 用户应该使用 mysql_native_password 插件。虽然 MySQL 被配置支持 SSL 客户端，但是到 MySQL 服务器的连接没有加密。&lt;/p>
&lt;p>有两种解决方法监控 MySQL8.0.4 及以上版本&lt;/p>
&lt;p>1.更改你打算用于 PMM 的 MySQL 用户&lt;/p>
&lt;p>2.改变 MySQL 的全局配置&lt;/p>
&lt;p>更改 MySQL 用户&lt;/p>
&lt;p>假设你已经创建了你打算用于 PMM 的 MySQL 用户，请使用以下方法更改：&lt;/p>
&lt;p>然后，将此用户传递给 pmm-admin add 作为 &amp;ndash;username 的参数值&lt;/p>
&lt;p>这是首选的方法，因为这只会降低一个用户的安全性。&lt;/p>
&lt;p>更改全局 MySQL 的配置&lt;/p>
&lt;p>一种不太安全的方法是在添加监控前将 default_authentication_plugin 设置为 mysql_native_password。然后，重启 MySQL 服务，应用这个更改。&lt;/p></description></item></channel></rss>