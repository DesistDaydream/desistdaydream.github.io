<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>断念梦 – 文档</title><link>https://desistdaydream.github.io/docs/</link><description>Recent content in 文档 on 断念梦</description><generator>Hugo -- gohugo.io</generator><atom:link href="https://desistdaydream.github.io/docs/index.xml" rel="self" type="application/rss+xml"/><item><title>Docs: 1.Bootloader</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/1.bootloader/1.bootloader/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/1.bootloader/1.bootloader/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Bootloader">Wiki,Bootloader&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>&lt;strong>Bootloader(引导加载程序)&lt;/strong> 是负责 &lt;a href="https://en.wikipedia.org/wiki/Booting">booting(引导)&lt;/a> 计算器的软件。通常也被称为 Bootstrap Loader、Bootstrap。&lt;/p>
&lt;p>当计算机关闭时，操作系统、应用程序代码和数据 ‍‌ 仍存储在非易失性存储器中。当计算机开机时，它通常没有操作系统或其随机存取存储器 (RAM) 中的加载程序。计算机首先执行存储在只读存储器（ROM，以及后来的 EEPROM、NOR 闪存）中的相对较小的程序以及一些需要的数据，以初始化 RAM（特别是在 x86 系统上），访问非易失性设备（通常是块设备，例如 NAND 闪存）或可以将操作系统程序和数据加载到 RAM 中的设备。&lt;/p>
&lt;h1 id="配置">配置&lt;/h1>
&lt;p>&lt;strong>/boot/*&lt;/strong> # 所有关于系统引导启动的配置信息，都在该目录下
&lt;strong>/boot/grub2/*&lt;/strong> #
&lt;strong>/etc/default/grub&lt;/strong> #&lt;/p>
&lt;h1 id="引导管理命令行工具">引导管理命令行工具&lt;/h1>
&lt;p>grub2-*
grubby
grub2-mkconfig&lt;/p></description></item><item><title>Docs: 2.Kernel(内核)</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2.kernel%E5%86%85%E6%A0%B8/kernel%E5%86%85%E6%A0%B8/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2.kernel%E5%86%85%E6%A0%B8/kernel%E5%86%85%E6%A0%B8/</guid><description>
&lt;h2 id="操作系统-os-与内核-kernel-有什么区别">操作系统 OS 与内核 Kernel 有什么区别？&lt;/h2>
&lt;p>原文链接：&lt;a href="https://mp.weixin.qq.com/s/-5tDn2-IS6Xo6DwQJN4c3Q">https://mp.weixin.qq.com/s/-5tDn2-IS6Xo6DwQJN4c3Q&lt;/a>&lt;/p>
&lt;p>&lt;strong>通用底盘技术&lt;/strong>
Canoo 公司有一项核心技术专利，这就是它们的通用电动底盘技术，长得是这个样子，非常像一个滑板：
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/egzxwb/1624588718457-99ed8a8e-d53b-465e-8d99-4345935ad5a4.webp" alt="">
这个带轮子、有电池、能动的滑板已经包含了一辆车&lt;strong>最核心&lt;/strong>的组件，差的就是一个外壳。这个看起来像滑板的东西就是所谓的电池系统和底盘一体化技术，Canoo 公司在它们的通用底盘上加装不同的外壳就能制造出不同的车型。
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/egzxwb/1624588718511-01fe725d-cd0d-48d1-a4e8-1010d7d5a69b.png" alt="">&lt;/p>
&lt;h5 id="什么是内核">&lt;strong>什么是内核？&lt;/strong>&lt;/h5>
&lt;p>在上面这个示例中，&lt;strong>包含轮子以及电池系统的底盘就好比内核，而套上外壳加上椅子以及内饰后的整体成品就好比操作系统&lt;/strong>。内核仅仅是操作系统的一部分，是真正与硬件交互的那部分软件，与硬件交互包括读写硬盘、读写网盘、读写内存以及任何连接到系统中的硬件。除了与硬件交互外，内核还负责分配资源，分配什么资源呢？所谓资源就是硬件，比如 CPU 时间、内存、IO 等等，这些都是资源。&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/egzxwb/1624588718454-36e25783-bbc0-49ec-a620-26d8580cee9d.png" alt="">因此，内核的职责就是以进程的形式来分配 CPU 时间，以虚拟内存的形式来分配物理内存，以文件的形式来管理 IO 设备。&lt;/p>
&lt;h5 id="什么是操作系统">&lt;strong>什么是操作系统？&lt;/strong>&lt;/h5>
&lt;p>然而只有一个内核实际上是做不了什么真正有用的事情，就像上面示例中那个通用底盘一样，这个底盘确实能跑起来，但你没办法开着这样一个底盘出去浪，因为这个底盘很难用。因此，你不得不加装上方向盘、座椅以及车身外壳等，同样的道理，内核是给人用的，为了与内核交互，发明了命令行以及图形界面 GUI。&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/egzxwb/1624588718509-9945a71c-556e-4b5a-be9f-8a123c68473c.png" alt="">在 Windows 平台就是给程序员提供编程接口的是 Windows API，这层 API 包罗万象，不但包括上文提到对系统调用的封装，还包括其它功能，像创建带有图形界面的应用程序等等。&lt;strong>但在 Linux 世界你找不到一种类似 Windows API 的东西&lt;/strong>，毕竟 Windows 是微软自家产品，什么都可以打包起来，Linux 只是一个开源的内核，如果一定要找一个类似的东西话那就是 libc，也就是 C 标准库，这里同样包括了对系统调用的封装以及一些库函数，但 libc 不包含创建带有图形界面应用程序的功能。现在我们知道了，操作系统需要提供两种接口：&lt;/p>
&lt;ul>
&lt;li>给用户提供操作接口。&lt;/li>
&lt;li>给程序员提供编程接口。&lt;/li>
&lt;/ul>
&lt;p>这些就是好比汽车的外壳，我们(用户和程序员)看得见摸得着，外壳加上底盘——也就是内核，才是功能完善的操作系统。&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/egzxwb/1624588718491-8aabc98e-8938-4b52-95fd-265d5f7d95b8.webp" alt="">&lt;/p>
&lt;h5 id="各种各样的操作系统">&lt;strong>各种各样的操作系统&lt;/strong>&lt;/h5>
&lt;p>实际上我们熟悉的 Linux 只是内核而不能称得上是操作系统，Ubuntu 则可以认为是操作系统，其内核是 Linux；RedHat 也是操作系统，其内核同样是 Linux；我们可以看到，尽管 Ubuntu 和 RedHat 是不同的操作系统，但其内核可以是相同的。这就好比它们可以基于同样的底盘打造出不同的车型。而我们熟悉的 Windows 也是操作系统，其内核是 Windows NT 内核。&lt;/p>
&lt;h5 id="总结">&lt;strong>总结&lt;/strong>&lt;/h5>
&lt;p>内核就像本文开头提到的电动底盘，包含了一个汽车的最核心元素；但这样一个底盘并没有什么实际用处，当搭配上外壳以及座椅后才是一辆真正有用的车，这就好比操作系统。值得注意的是，不同的操作系统可以有相同的内核。&lt;/p>
&lt;h1 id="宏内核与微内核">宏内核与微内核&lt;/h1>
&lt;p>原文链接：&lt;a href="https://mp.weixin.qq.com/s/jIuLkapBssGnBn1IoIdWQQ">公众号-码农的荒岛求生，操作系统的实现：什么是宏内核、微内核&lt;/a>&lt;/p>
&lt;h2 id="大一统全部运行在内核态">大一统，全部运行在内核态&lt;/h2>
&lt;p>&lt;strong>最简单的划分就是没有划分&lt;/strong>，我们可以把所有内核代码放在内核态，内核中的任何代码都拥有控制硬件的全部特权，显然这种设计方法非常简单，因为操作系统设计者不用费心去想哪一部分该放在内核态。&lt;/p>
&lt;p>由于全部内核程序都运行在内核态，编译好的内核程序就是一个单独的二进制可执行文件，这时的操作系统运行起来后就是一个大进程，所有内核代码运行在一个单独的地址空间中，这和我们实现的稍微复杂的单进程应用程序类似，这种大一统的设计就是所谓的宏内核，monolithic kernel，个人认为叫“一体化内核”更形象些。&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/egzxwb/1650439475125-4fe94b34-90ba-43d8-8a9b-3c5860730e20.png" alt="">&lt;/p>
&lt;p>这种组织方式和 TCP/IP 协议栈的分层实现有点类似。&lt;/p>
&lt;p>现在内核代码已经组织好了，毕竟内核是为上层应用提供服务的，那么上层应用该怎样调用内核代码呢？这就是系统调用的作用，system call。&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/egzxwb/1650439474086-a1f789d1-05e4-4c7c-9c39-d6274ac2b0aa.png" alt="">&lt;/p>
&lt;p>上层应用程序通过系统调用与内核进行交互。&lt;/p>
&lt;p>由于内核代码唯一同一个地址空间中，因此内核中各部分的交互极为简单，就是普通的函数调用，文件系统中的某块 cache 可以非常容易的被虚拟内存系统共享使用。&lt;/p>
&lt;p>但宏内核也是有缺点的，由于内核代码位于同一个地址空间，代码趋于复杂化，复杂就容易出错，但内核和普通程序不同，一旦内核中某一模块出现 bug 将导致整个内核崩溃，底层的内核崩溃后上层的应用程序就无法继续正常推进，整个系统就下图一样。。crash&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/egzxwb/1650439474129-b3976f1b-3567-4d8a-b82d-2e5fd9e647cd.gif" alt="">&lt;/p>
&lt;p>当然也有人不在乎在这一点，Linus 认为内核中有 bug 正常，&lt;strong>有 bug 就找到它、修复它而不是用某种机制试图忽略它&lt;/strong>，没错，C++中的异常就是试图忽略 bug 的机制，这就是为什么很多公司的规范中禁止使用异常的原因。&lt;/p>
&lt;p>总之，内核崩溃后就必须重启计算机。&lt;/p>
&lt;h4 id="heading">&lt;/h4>
&lt;h2 id="保留核心非必要不留在内核">保留核心，非必要不留在内核&lt;/h2>
&lt;p>为减少内核崩溃的风险，一个简单的办法就是让内核尽量精简，只保留核心部分运行在内核态，其它代码以用户态进程的形式运行，就像这样：&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/egzxwb/1650439474079-a7429422-8348-4fe1-b423-79e30fe7763d.png" alt="">&lt;/p>
&lt;p>运行在用户态的操作系统程序被称为 server，像负责文件操作的 File Server 等，此时用户进程想要使用操作系统提供的服务的话就必须借助进程间通信，inter-process communication，即 IPC，借助内核，消息从一个进程发送到另一个进程然后等待返回。&lt;/p>
&lt;p>这样，内核只需要对上层应用提供一些简单的接口即可，像创建进程、发送消息等，这种实现方式可以让内核尽可能简单，因为大部分内核程序都运行在用户态，且运行在不同的地址空间中，此时设备驱动中的 bug 不会影响到内核，这种操作系统的实现方式就被称为微内核， micro kernel。&lt;/p>
&lt;p>就像宏内核那样，微内核也有自己的缺点，那就是性能。由于宏内核的代码都在同一个地址空间中，因此模块间的交互可以非常简单，简单的函数调用即可，但模块间交互对微内核来说则可能涉及进程间通信，看上图，如果某个应用程序需要请求使用 File Server，这条链路涉及到：&lt;/p>
&lt;pre>&lt;code>请求：应用程序 -&amp;gt; 内核 -&amp;gt; File server
返回：Filer server -&amp;gt; 内核 -&amp;gt; 应用程序
&lt;/code>&lt;/pre>
&lt;p>每一个&amp;quot;-&amp;gt;&amp;ldquo;都涉及上下文切换，而这对宏内核来说则简单很多。&lt;/p>
&lt;h4 id="heading-1">&lt;/h4>
&lt;p>&lt;strong>现实中是什么样子？&lt;/strong>&lt;/p>
&lt;p>现实的操作系统中两种实现方式都很常见，Linux 以及许多 Unix 就是典型的宏内核，而 Mac OS X 以及 Windows NT 则一般认为是微内核，华为的鸿蒙 Harmony OS 则宣传是微内核。&lt;/p></description></item><item><title>Docs: 4.CPU 管理</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2.kernel%E5%86%85%E6%A0%B8/4.cpu-%E7%AE%A1%E7%90%86/cpu-%E7%AE%A1%E7%90%86/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2.kernel%E5%86%85%E6%A0%B8/4.cpu-%E7%AE%A1%E7%90%86/cpu-%E7%AE%A1%E7%90%86/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://time.geekbang.org/column/article/69859">极客时间，Linux 性能优化实战-03 基础篇：经常说的 CPU 上下文切换是什么意思&lt;/a>&lt;/li>
&lt;li>&lt;a href="http://linuxperf.com/?p=209">LinuxPerformance 博客，进程切换：自愿与强制&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>在 Linux 中，CPU 的管理，绝大部分时间都是在进行任务的调度，所以很多时候也称为&lt;strong>调度管理&lt;/strong>。&lt;/p>
&lt;h2 id="cpu-多线程并发并行-概念">&lt;strong>CPU 多线程、并发、并行 概念&lt;/strong>&lt;/h2>
&lt;p>Node：在这里时间片只是一种描述，理解 CPU 的并行与并发概念就好&lt;/p>
&lt;p>1、CPU 时间分片、多线程？
如果线程数不多于 CPU 核心数，会把各个线程都分配一个核心，不需分片，而当线程数多于 CPU 核心数时才会分片。&lt;/p>
&lt;p>2、并发和并行的区别&lt;/p>
&lt;ul>
&lt;li>并发：当有多个线程在操作时,如果系统只有一个 CPU,把 CPU 运行时间划分成若干个时间片,分配给各个线程执行，在一个时间段的线程代码运行时，其它线程处于挂起状态。这种方式我们称之为_ _&lt;strong>Concurrent(并发)&lt;/strong>。并发=间隔发生&lt;/li>
&lt;li>并行：当系统有一个以上 CPU 时,则线程的操作有可能非并发。当一个 CPU 执行一个线程时，另一个 CPU 可以执行另一个线程，两个线程互不抢占 CPU 资源，可以同时进行，这种方式我们称之为 &lt;strong>Parallel(并行)&lt;/strong>。 并行=同时进行&lt;/li>
&lt;/ul>
&lt;p>区别：并行是指两个或者多个事件在同一时刻发生；而并发是指两个或多个事件在同一时间间隔内发生。&lt;/p>
&lt;p>并行是同时做多件事情。&lt;/p>
&lt;p>并发表示同时发生了多件事情，通过时间片切换，哪怕只有单一的核心，也可以实现“同时做多件事情”这个效果。&lt;/p>
&lt;p>根据底层是否有多处理器，并发与并行是可以等效的，这并不是两个互斥的概念。&lt;/p>
&lt;p>举个我们开发中会遇到的例子，我们说资源请求并发数达到了 1 万。这里的意思是有 1 万个请求同时过来了。但是这里很明显不可能真正的同时去处理这 1 万个请求的吧！&lt;/p>
&lt;p>如果这台机器的处理器有 4 个核心，不考虑超线程，那么我们认为同时会有 4 个线程在跑。也就是说，并发访问数是 1 万，而底层真实的并行处理的请求数是 4。如果并发数小一些只有 4 的话，又或者你的机器牛逼有 1 万个核心，那并发在这里和并行一个效果。也就是说，并发可以是虚拟的同时执行，也可以是真的同时执行。而并行的意思是真的同时执行。&lt;/p>
&lt;p>结论是：并行是我们物理时空观下的同时执行，而并发则是操作系统用线程这个模型抽象之后站在线程的视角上看到的“同时”执行。&lt;/p>
&lt;h3 id="time-slice时间片-概念">time slice(时间片) 概念&lt;/h3>
&lt;blockquote>
&lt;p>参考：&lt;a href="https://en.wikipedia.org/wiki/Preemption_(computing)#Time_slice">https://en.wikipedia.org/wiki/Preemption_(computing)#Time_slice&lt;/a>&lt;/p>
&lt;/blockquote>
&lt;p>The period of time for which a process is allowed to run in a preemptive multitasking system is generally called the &lt;em>time slice&lt;/em> or &lt;em>quantum&lt;/em>.&lt;/p>
&lt;p>&lt;strong>time slice(时间片)&lt;/strong> 是一个程序运行在&lt;a href="https://en.wikipedia.org/wiki/Preemption_(computing)">抢占式多任务系统&lt;/a>中的一段时间。也可以称为 quantum(量子)。&lt;/p>
&lt;h2 id="cpu-使用率概念">CPU 使用率概念&lt;/h2>
&lt;p>CPU 不像硬盘、内存，并不具备逻辑上数量、大小、空间之类的概念。只要使用 CPU，就是使用了这个 CPU 的全部，也就无法通过大小之类的概念来衡量一个 CPU，所以我们日常所说的 CPU 的使用率 ，实际上是指的在一段时间范围内，CPU 执行 &lt;strong>Tasks(任务)&lt;/strong> 花费时间的百分比。比如 60 分钟内，一颗 CPU 执行各种任务花费了 6 分钟，则 CPU 在这一小时时间内的使用率为 10%。&lt;/p>
&lt;blockquote>
&lt;p>上文说的 &lt;strong>Tasks(任务)&lt;/strong>，即会指系统中的进程、线程，也代表各种硬件去请求 CPU 执行的各种事情，比如网卡接收到数据，就会告诉 CPU 需要处理(i.e.中断)。&lt;/p>
&lt;/blockquote>
&lt;p>在 Linux 系统中，CPU 的使用率一般可分为 4 大类：&lt;/p>
&lt;ol>
&lt;li>User Time(用户进程运行时间)&lt;/li>
&lt;li>System Time(系统内核运行时间)&lt;/li>
&lt;li>Idle Time(空闲时间)&lt;/li>
&lt;li>Steal Time(被抢占时间)&lt;/li>
&lt;/ol>
&lt;p>除了 Idle Time 外，CPU 在其余时间都处于工作运行状态。
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/srucoz/1616168021555-68fba1de-f5d5-462d-bef6-a78b476521ad.png" alt="">&lt;/p>
&lt;p>通常而言，我们泛指的整体 CPU 使用率为 User Time 和 Systime 占比之和(例如 tsar 中 CPU util)，即：
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/srucoz/1616168021559-394ecaa6-59db-453a-b5b1-c5ab88193f49.png" alt="">&lt;/p>
&lt;p>为了便于定位问题，大多数性能统计工具都将这 4 类时间片进一步扩展成了 8 类，如下图，是在 top 命令的 man 手册中对 CPU 使用率的分类。
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/srucoz/1616168021546-ebe53556-f50b-49f2-8477-c10cf2b8f2f5.png" alt="">&lt;/p>
&lt;ul>
&lt;li>us：用户进程空间中未改变过优先级的进程占用 CPU 百分比&lt;/li>
&lt;li>sy：内核空间占用 CPU 百分比&lt;/li>
&lt;li>ni：用户进程空间内改变过优先级的进程占用 CPU 百分比&lt;/li>
&lt;li>id：空闲时间百分比&lt;/li>
&lt;li>wa：等待 I/O 的时间百分比&lt;/li>
&lt;li>hi：硬中断时间百分比&lt;/li>
&lt;li>si：软中断时间百分比&lt;/li>
&lt;li>st：虚拟化时被其余 VM 窃取时间百分比&lt;/li>
&lt;/ul>
&lt;p>这 8 类分片中，除 wa 和 id 外，其余分片 CPU 都处于工作态。&lt;/p>
&lt;h1 id="调度算法">调度算法&lt;/h1>
&lt;blockquote>
&lt;p>详见：&lt;a href="https://www.yuque.com/go/doc/33222924">CPU 调度算法&lt;/a>&lt;/p>
&lt;/blockquote>
&lt;p>首先明确一个概念：&lt;strong>Task(任务)&lt;/strong>，一个进程从处理到结束就算一个任务，处理网卡收到的数据包也算一个任务。一般来说，CPU 就是在处理一个个的 &lt;strong>Task(任务)&lt;/strong>，并度过其一生。&lt;/p>
&lt;p>在 Linux 内核中，进程和线程都是用 tark_struct 结构体表示的，区别在于线程的 tark_struct 结构体里部分资源是共享了进程已创建的资源，比如内存地址空间、代码段、文件描述符等，所以 Linux 中的线程也被称为轻量级进程，因为线程的 tark_struct 相比进程的 tark_struct 承载的 资源比较少，因此以「轻」得名。&lt;/p>
&lt;p>一般来说，没有创建线程的进程，是只有单个执行流，它被称为是主线程。如果想让进程处理更多的事情，可以创建多个线程分别去处理，但不管怎么样，它们对应到内核里都是 tark_struct。&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/srucoz/1616168021545-596ecf70-ac19-4620-8845-bfe72ef7bdce.jpeg" alt="">&lt;/p>
&lt;p>所以，Linux 内核里的调度器，调度的对象就是 tark_struct，接下来我们就把这个数据结构统称为任务。&lt;/p>
&lt;p>在 Linux 系统中，根据任务的优先级以及响应要求，主要分为两种，其中优先级的数值越小，优先级越高：&lt;/p>
&lt;ul>
&lt;li>实时任务，对系统的响应时间要求很高，也就是要尽可能快的执行实时任务，优先级在 0~99 范围内的就算实时任务；&lt;/li>
&lt;li>普通任务，响应时间没有很高的要求，优先级在 100~139 范围内都是普通任务级别；&lt;/li>
&lt;/ul>
&lt;p>也就是说，在 LInux 内核中，实时任务总是比普通任务的优先级要高。&lt;/p></description></item><item><title>Docs: 7.Process 管理</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2.kernel%E5%86%85%E6%A0%B8/7.process-%E7%AE%A1%E7%90%86/process-%E7%AE%A1%E7%90%86/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2.kernel%E5%86%85%E6%A0%B8/7.process-%E7%AE%A1%E7%90%86/process-%E7%AE%A1%E7%90%86/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://blog.csdn.net/ljianhui/article/details/46718835">原文连接&lt;/a>，本文为 IBM RedBook 的 &lt;a href="http://users.polytech.unice.fr/~bilavarn/fichier/elec5_linux/linux_perf_and_tuning_IBM.pdf">Linux Performanceand Tuning Guidelines&lt;/a> 的 1.1 节的翻译&lt;/li>
&lt;li>&lt;a href="https://mp.weixin.qq.com/s/fzLcAkYwKhj-9hgoVkTzaw">阿里技术，CPU 飙高，系统性能问题如何排查？&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>进程管理是操作系统的最重要的功能之一。有效率的进程管理能保证一个程序平稳而高效地运行。它包括进程调度、中断处理、信号、进程优先级、上下文切换、进程状态、进度内存等。&lt;/p>
&lt;p>&lt;strong>Process(进程)&lt;/strong> 实际是运行在 CPU 中的一个** Program(应用程序) 的实体**。在 Linux 系统中，能够同时运行多个进程，Linux 通过在短的时间间隔内轮流运行这些进程而实现“多任务”。这一短的时间间隔称为“时间片”，让进程轮流运行的方法称为“进程调度” ，完成调度的程序称为调度程序。&lt;/p>
&lt;p>进程调度控制进程对 CPU 的访问。当需要选择下一个进程运行时，由调度程序选择最值得运行的进程。可运行进程实际上是仅等待 CPU 资源的进程，如果某个进程在等待其它资源，则该进程是不可运行进程。Linux 使用了比较简单的基于优先级的进程调度算法选择新的进程。&lt;/p>
&lt;p>通过多任务机制，每个进程可认为只有自己独占计算机，从而简化程序的编写。每个进程有自己单独的地址空间，并且只能由这一进程访问，这样，操作系统避免了进程之间的互相干扰以及“坏”程序对系统可能造成的危害。 为了完成某特定任务，有时需要综合两个程序的功能，例如一个程序输出文本，而另一个程序对文本进行排序。为此，操作系统还提供进程间的通讯机制来帮助完成这样的任务。Linux 中常见的进程间通讯机制有信号、管道、共享内存、信号量和套接字等。&lt;/p>
&lt;p>内核通过 SCI 提供了一个 API 来创建一个新进程(fork、exec 或 Portable Operating System Interface [POSⅨ] 函数)、停止进程(kill、exit)、并在它们之间进行通信和同步(signal 或者 POSⅨ 机制)。&lt;/p>
&lt;p>计算机实际上可以做的事情实质上非常简单，比如计算两个数的和，再比如在内存中寻找到某个地址等等。这些最基础的计算机动作被称为指令(instruction)。所谓的程序(program)，就是这样一系列指令的所构成的集合。通过程序，我们可以让计算机完成复杂的操作。程序大多数时候被存储为可执行的文件。这样一个可执行文件就像是一个菜谱，计算机可以按照菜谱作出可口的饭菜。&lt;/p>
&lt;p>Program(程序) 和 Process(进程) 的区别是什么呢?&lt;/p>
&lt;ol>
&lt;li>在很久很久以前，计算机刚出现的时候，是没有操作系统的，那时候一台机器只是运行一个程序，得出数据，后来人们为了同时运行多个程序从而研究出了操作系统，在操作系统之上可以运行多个程序&lt;/li>
&lt;li>进程是程序的一个具体实现。类似于按照食谱，真正去做菜的过程。同一个程序可以执行多次，每次都可以在内存中开辟独立的空间来装载，从而产生多个进程。不同的进程还可以拥有各自独立的 IO 接口。&lt;/li>
&lt;/ol>
&lt;p>操作系统的一个重要功能就是为进程提供方便，比如说为进程分配内存空间，管理进程的相关信息等等，就好像是为我们准备好了一个精美的厨房。&lt;/p>
&lt;h2 id="进程的生命周期">进程的生命周期&lt;/h2>
&lt;p>每一个进程都有其生命周期，例如创建、运行、终止和消除。这些阶段会在系统启动和运行中重复无数次。因此，进程的生命周期对于其性能的分析是非常重要的。下图展示了经典的进程生命周期。
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/ld23ik/1616167507353-2f676d82-88da-483c-a939-399f284d6425.jpeg" alt="">
不会关闭的常驻进程可以称为 &lt;strong>Daemon Process(守护进程，简称 Daemon)&lt;/strong>&lt;/p>
&lt;blockquote>
&lt;p>一般 daemon 的名称都会在进程名后加一个字母 d 作为 daemon 的 process，比如 vsftp 的 daemon 就是 vsftpd。&lt;/p>
&lt;/blockquote>
&lt;p>当一个进程创建一个新的进程，创建进程(父进程)的进程调用 一个 fork() 系统调用。当 fork() 系统调用被调用，它得到该新创建进程（子进程）的进程描述并调用一个新的进程 id。它复制该值到父进程进程描述到子进程中。此时整个的父进程的地址空间是没有被复制的；父子进程共享相同的地址空间。&lt;/p>
&lt;p>exec() 系统调用复制新的程序到子进程的地址空间。因为父子进程共享地址空间，写入一个新的程序的数据会引起一个分页错误。在这种情况下，内存会分配新的物理内存页给子进程。&lt;/p>
&lt;p>这个推迟的操作叫作写时复制。子进程通常运行他们自己的程序而不是与父进程运行相同的程序。这个操作避免了不必要的开销，因为复制整个地址空间是一个非常缓慢和效率低下的操作，它需要使用大量的处理器时间和资源。&lt;/p>
&lt;p>当程序已经执行完成，子进程通过调用 exit()系统调用终止。exit()系统调用释放进程大部分的数据并通过发送一个信号通知其父进程。此时，子进程是一个被叫作僵尸进程的进程（参阅 page 7 的“Zombie processes”）。&lt;/p>
&lt;p>子进程不会被完全移除直到其父进程知道其子进程的调用 wait()系统调用而终止。当父进程被通知子进程终止，它移除子进程的所有数据结构并释放它的进程描述。&lt;/p>
&lt;h2 id="父进程与子进程">父进程与子进程&lt;/h2>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/ld23ik/1616167507409-d531245f-abbe-4a2a-b575-d2ae72c6949f.jpeg" alt="">&lt;/p>
&lt;ul>
&lt;li>用颜色的线标示的两列，左侧的为进程号(PID)右侧的为父进程号(PPID)&lt;/li>
&lt;li>子进程与父进程的环境变量相同&lt;/li>
&lt;li>老进程成为新进程的父进程(parent process)，而相应的，新进程就是老的进程的子进程(child process)。一个进程除了有一个 PID 之外，还会有一个 PPID(parent PID)来存储的父进程 PID。如果我们循着 PPID 不断向上追溯的话，总会发现其源头是 init 进程。所以说，所有的进程也构成一个以 init 为根的树状结构。&lt;/li>
&lt;li>如上图所示，我们查询当前 shell 下的进程：
&lt;ul>
&lt;li>我们可以看到，第二个进程 ps 是第一个进程 bash 的子进程。&lt;/li>
&lt;li>还可以用 &lt;code>pstree&lt;/code> 命令来显示整个进程树。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>fork() 通常作为一个函数被调用。这个函数会有两次返回，将子进程的 PID 返回给父进程，0 返回给子进程。实际上，子进程总可以查询自己的 PPID 来知道自己的父进程是谁，这样，一对父进程和子进程就可以随时查询对方。&lt;/li>
&lt;li>通常在调用 fork 函数之后，程序会设计一个 if 选择结构。当 PID 等于 0 时，说明该进程为子进程，那么让它执行某些指令,比如说使用 exec 库函数(library function)读取另一个程序文件，并在当前的进程空间执行 (这实际上是我们使用 fork 的一大目的: 为某一程序创建进程)；而当 PID 为一个正整数时，说明为父进程，则执行另外一些指令。由此，就可以在子进程建立之后，让它执行与父进程不同的功能。&lt;/li>
&lt;/ul>
&lt;h3 id="子进程的-termination终结">子进程的 termination(终结)&lt;/h3>
&lt;p>当子进程终结时，它会通知父进程，并清空自己所占据的内存，并在内核里留下自己的退出信息(exit code，如果顺利运行，为 0；如果有错误或异常状况，为&amp;gt;0 的整数)。在这个信息里，会解释该进程为什么退出。父进程在得知子进程终结时，有责任对该子进程使用 wait 系统调用。这个 wait 函数能从内核中取出子进程的退出信息，并清空该信息在内核中所占据的空间。但是，如果父进程早于子进程终结，子进程就会成为一个孤儿(orphand)进程。孤儿进程会被过继给 init 进程，init 进程也就成了该进程的父进程。init 进程负责该子进程终结时调用 wait 函数。&lt;/p>
&lt;p>当然，一个糟糕的程序也完全可能造成子进程的退出信息滞留在内核中的状况（父进程不对子进程调用 wait 函数），这样的情况下，子进程成为僵尸(zombie)进程。当大量僵尸进程积累时，内存空间会被挤占。&lt;/p>
&lt;h2 id="thread线程">Thread(线程)&lt;/h2>
&lt;p>一个线程是一个单独的进程生成的一个执行单元。它与其他的线程并行地运行在同一个进程中。各个线程可以共享进程的资源，例如内存、地址空间、打开的文件等等。它们能访问相同的程序数据集。线程也被叫作轻量级的进程（Light Weight Process，LWP）。因为它们共享资源，所以每个线程不应该在同一时间改变它们共享的资源。互斥的实现、锁、序列化等是用户程序的责任。&lt;/p>
&lt;p>从性能的角度来说，创建线程的开销比创建进程少，因数创建一个线程时不需要复制资源。另一方面，进程和线程拥在调度算法上有相似的特性。&lt;strong>内核以相似的方式处理它们&lt;/strong>。
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/ld23ik/1616167507380-b6ae3b1e-b47c-454c-b3c7-9942dde4f480.jpeg" alt="">
所以，一个进程创建的线程，也是可以运行在多个 CPU 上的。
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/ld23ik/1616645843002-c07df4a7-3d7a-4969-8203-4bc20169721a.png" alt="image.png">
在现在的 Linux 实现中，线程支持 UNIX 的可移植操作系统接口（POSIX）标准库。在 Linux 操作系统中有几种可用的线程实现。以下是广泛使用的线程库：&lt;/p>
&lt;p>Linux Threads 自从 Linux 内核 2.0 起就已经被作为默认的线程实现。Linux Threads 的一些实现并不符合 POSIX 标准。Native POSIX Thread Library（NPTL）正在取代 Linux Threads。Linux Threads 在将来的 Linux 企业发行版中将不被支持。&lt;/p>
&lt;p>Native POSIX Thread Libary（NPTL）&lt;/p>
&lt;p>NPTL 最初是由红帽公司开发的。NPTL 与 POSIX 更加兼容。通过 Linux 内核 2.6 的高级特性，例如，新的 clone()系统调用、信号处理的实现等等，它具有比 LinuxThreads 更高的性能和伸缩性。&lt;/p>
&lt;p>NPTL 与 LinuxThreads 有一些不兼容。一个依赖于 LinuxThreads 的应用可能不能在 NPTL 实现中工作。&lt;/p>
&lt;p>Next Generation POSIX Thread（NGPT）&lt;/p>
&lt;p>NGPT 是一个 IBM 开发的 POSIX 线程库。现在处于维护阶段并且在未来也没有开发计划。&lt;/p>
&lt;p>使用 LD_ASSUME_KERNEL 环境变量，你可以选择在应用中使用哪一个线程库。&lt;/p>
&lt;h2 id="linux-内核代码中的-process">Linux 内核代码中的 Process&lt;/h2>
&lt;p>在 Linux 中，&lt;strong>Process(进程) 属于&lt;/strong> &lt;strong>Task(任务)&lt;/strong> 的一种类型，都被 task_struct 结构管理，该结构同时被叫作进程描述。一个进程描述包含一个运行进程所有的必要信息，例如进程标识、进程属性和构建进程的资源。如果你了解该进程构造，你就能理解对于进程的运行和性能来说，什么是重要的。&lt;/p>
&lt;p>v5.14 代码：&lt;a href="https://github.com/torvalds/linux/blob/v5.14/include/linux/sched.h#L661">include/linux/sched.h&lt;/a>&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-c" data-lang="c">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">struct&lt;/span> task_struct {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#ifdef CONFIG_THREAD_INFO_IN_TASK
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#75715e">/*
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> * For reasons of header soup (see current_thread_info()), this
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> * must be the first element of task_struct.
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> */&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">struct&lt;/span> thread_info thread_info;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#endif
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> ......
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 进程状态
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">unsigned&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span> __state;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 进程唯一标识符
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">pid_t&lt;/span> pid;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">pid_t&lt;/span> tgid;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 进程名称，上限 16 字符
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">char&lt;/span> comm[TASK_COMM_LEN];
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 打开的文件
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">struct&lt;/span> files_struct &lt;span style="color:#f92672">*&lt;/span>files;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ......
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>下图展示了进程结构相关的进程信息概述。
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/ld23ik/1616167507336-aaeec645-b9df-41c3-99ab-6bf39aed4f42.jpeg" alt="">
其实从这里能看出来，从某种角度来看，**对于内核来说并没有线程这个概念。Linux 把所有的线程都当做进程来实现，内核也没有特别的调度算法来处理线程。**线程仅仅被视为一个与其他进程共享某些资源的进程，和进程一样，每个线程也都是有自己的 &lt;code>task_struct&lt;/code>，所以在内核中，线程看起来就是一个普通的进程。线程也被称作轻量级进程，一个进程可以有多个线程，线程拥有自己独立的栈，切换也由操作系统调度。在 Linux 上可以通过 &lt;code>pthread_create()&lt;/code> 方法或者 &lt;code>clone()&lt;/code> 系统调用创建；&lt;/p>
&lt;h1 id="进程优先级和-nice-值">进程优先级和 nice 值&lt;/h1>
&lt;p>进程优先级是一个数值，它通过动态的优先级和静态的优先级来决定进程被 CPU 处理的顺序。一个拥有更高进程优先级的进程拥有更大的机率得到处理器的处理。&lt;/p>
&lt;p>内核根据进程的行为和特性使用试探算法，动态地调整调高或调低动态优先级。一个用户进程可以通过使用进程的 nice 值间接改变静态优先级。一个拥有更高静态优先级的进程将会拥有更长的时间片（进程能在处理上运行多长时间）。&lt;/p>
&lt;p>Linux 支持从 19（最低优先级）到-20（最高优先级）的 nice 值。默认值为 0。把程序的 nice 值修改为负数（使进程的优先级更高），需要以 root 身份登陆或使用 su 命令以 root 身份执行。&lt;/p>
&lt;h1 id="上下文切换">上下文切换&lt;/h1>
&lt;p>在进程运行过程中，进程的运行信息被保存于处理器的寄存器和它的缓存中。正在执行的进程加载到寄存器中的数据集被称为上下文。为了切换进程，运行中进程的上下文将会被保存，接下来的运行进程的上下文将被被恢复到寄存器中。进程描述和内核模式堆栈的区域将会用来保存上下文。这个切换被称为上下文切换。过多的上下文切换是不受欢迎的，因为处理器每次都必须清空刷新寄存器和缓存，为新的进程制造空间。它可能会引起性能问题。&lt;/p>
&lt;p>下图说明了上下文切换如何工作。
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/ld23ik/1616167507475-6f5a9385-f033-4c00-8344-2953197b973c.jpeg" alt="">&lt;/p>
&lt;h1 id="中断处理">中断处理&lt;/h1>
&lt;p>中断处理是优先级最高的任务之一。中断通常由 I/O 设备产生，例如网络接口卡、键盘、磁盘控制器、串行适配器等等。中断处理器通过一个事件通知内核（例如，键盘输入、以太网帧到达等等）。它让内核中断进程的执行，并尽可能快地执行中断处理，因为一些设备需要快速的响应。它是系统稳定的关键。当一个中断信号到达内核，内核必须切换当前的进程到一个新的中断处理进程。这意味着中断引起了上下文切换，因此大量的中断将会引起性能的下降。&lt;/p>
&lt;p>在 Linux 的实现中，有两种类型的中断。硬中断是由请求响应的设备发出的（磁盘 I/O 中断、网络适配器中断、键盘中断、鼠标中断）。软中断被用于处理可以延迟的任务（TCP/IP 操作，SCSI 协议操作等等）。你可以在 &lt;code>/proc/interrupts&lt;/code> 文件中查看硬中断的相关信息。&lt;/p>
&lt;p>在多处理器的环境中，中断被每一个处理器处理。绑定中断到单个的物理处理中能提高系统的性能。更多的细节，请参阅 4.4.2，“CPU 的中断处理亲和力”。&lt;/p>
&lt;h1 id="进程的状态">进程的状态&lt;/h1>
&lt;p>每一个进程拥有自己的状态，状态表示了进程当前在发生什么。LINUX 2.6 以后的内核中，在进程的执行期间进程的状态会发生改变，进程一般存在 7 种基础状态：D-不可中断睡眠、R-可执行、S-可中断睡眠、T-暂停态、t-跟踪态、X-死亡态、Z-僵尸态，这几种状态在 ps 命令的 man 手册中有对应解释。&lt;/p>
&lt;ul>
&lt;li>**D **＃不间断的睡眠（通常是 IO）&lt;/li>
&lt;li>&lt;strong>R&lt;/strong> ＃正在运行或可运行（在运行队列上）&lt;/li>
&lt;li>&lt;strong>S&lt;/strong> ＃可中断的睡眠（等待事件完成）&lt;/li>
&lt;li>&lt;strong>T&lt;/strong> ＃被作业控制信号停止&lt;/li>
&lt;li>**t **＃在跟踪过程中被调试器停止&lt;/li>
&lt;li>&lt;strong>X&lt;/strong> ＃已死（永远都不会出现）&lt;/li>
&lt;li>&lt;strong>Z&lt;/strong> ＃已终止运行（“僵尸”）的进程，已终止但未由其父进程获得&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/ld23ik/1616167507456-ca89ed8d-d8a1-4cd6-96ab-c78372840f4a.jpeg" alt="">&lt;/p>
&lt;h2 id="d-task_uninterruptible不可中断睡眠态">D (TASK_UNINTERRUPTIBLE)，不可中断睡眠态。&lt;/h2>
&lt;p>顾名思义，位于这种状态的进程处于睡眠中，并且不允许被其他进程或中断(异步信号)打断。因此这种状态的进程，是无法使用 kill -9 杀死的(kill 也是一种信号)，除非重启系统(没错，就是这么头硬)。不过这种状态一般由 I/O 等待(比如磁盘 I/O、网络 I/O、外设 I/O 等)引起，出现时间非常短暂，大多很难被 PS 或者 TOP 命令捕获(除非 I/O HANG 死)。SLEEP 态进程不会占用任何 CPU 资源。&lt;/p>
&lt;h2 id="r-task_running可执行态">R (TASK_RUNNING)，可执行态。&lt;/h2>
&lt;p>这种状态的进程都位于 CPU 的可执行队列中，正在运行或者正在等待运行，即不是在上班就是在上班的路上。&lt;/p>
&lt;p>在此状态下，表示进程正在 CPU 中运行或在队列中等待运行（运行队列）。&lt;/p>
&lt;h2 id="s-task_interruptible可中断睡眠态">S (TASK_INTERRUPTIBLE)，可中断睡眠态。&lt;/h2>
&lt;p>不同于 D，这种状态的进程虽然也处于睡眠中，但是是允许被中断的。这种进程一般在等待某事件的发生（比如 socket 连接、信号量等），而被挂起。一旦这些时间完成，进程将被唤醒转为 R 态。如果不在高负载时期，系统中大部分进程都处于 S 态。SLEEP 态进程不会占用任何 CPU 资源。&lt;/p>
&lt;p>在此状态下，进程被暂停并等待一个某些条件状态的到达。如果一个进程处于 TASK_INTERRUPTIBLE 状态并接收到一个停止的信号，进程的状态将会被改变并中断操作。一个典型的 TASK_INTERRUPTIBLE 状态的进程的例子是一个进程等待键盘中断。&lt;/p>
&lt;h2 id="t--t-task_stopped--task_traced暂停-or-跟踪态">T &amp;amp; t (TASK_STOPPED &amp;amp; TASK_TRACED)，暂停 or 跟踪态。&lt;/h2>
&lt;p>这种两种状态的进程都处于运行停止的状态。不同之处是暂停态一般由于收到 SIGSTOP、SIGTSTP、SIGTTIN、SIGTTOUT 四种信号被停止，而跟踪态是由于进程被另一个进程跟踪引起(比如 gdb 断点）。暂停态进程会释放所有占用资源。&lt;/p>
&lt;p>TASK_STOPPED 在此状态下的进程被某些信号（如 SIGINT，SIGSTOP）暂停。进程正在等待通过一个信号恢复运行，例如 SIGCONT。&lt;/p>
&lt;h2 id="z-exit_zombietask_zombie-僵尸态">Z (EXIT_ZOMBIE/TASK_ZOMBIE), 僵尸态。&lt;/h2>
&lt;p>这种状态的进程实际上已经结束了，但是父进程还没有回收它的资源（比如进程的描述符、PID 等）。僵尸态进程会释放除进程入口之外的所有资源。&lt;/p>
&lt;p>当一个进程调用 exit()系统调用退出后，它的父进程应该知道该进程的终止。处于 TASK_ZOMBIE 状态的进程会等待其父进程通知其释放所有的数据结构。&lt;/p>
&lt;p>当一个进程接收到一个信号而终止，它在结束自己之前，通常需要一些时间来结束所有的任务（例如关闭打开的文件）。在这个通常非常短暂的时间内，该进程就是一个僵尸进程。&lt;/p>
&lt;p>进程已经完成所有的关闭任务后，它会向父进程报告其即将终止。有些时候，一个僵尸进程不能把自己终止，这将会引导它的状态显示为 z（zombie）。&lt;/p>
&lt;p>使用 kill 命令来关闭这样的一个进程是不可能的，因为该进程已经被认为已经死掉了。如果你不能清除僵尸进程，你可以结束其父进程，然后僵尸进程也随之消失。但是，如果父进程为 init 进程，你不能结束它。init 进程是一个非常重要的进程，因此可能需要重启系统来清除僵尸进程。&lt;/p>
&lt;h2 id="x-exit_dead-死亡态">X (EXIT_DEAD), 死亡态。&lt;/h2>
&lt;p>进程的真正结束态，这种状态一般在正常系统中捕获不到。&lt;/p>
&lt;h1 id="进程内存段">进程内存段&lt;/h1>
&lt;p>进程使用其自身的内存区域来执行工作。工作的变化根据情况和进程的使用而决定。进程可以拥有不同的工作量特性和不同的数据大小需求。进程必须处理各种数据大小。为了满足需求，Linux 内核为每个进程使用动态申请内存的机制。进程内存分配的数据结构如图 1-7 所示。&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/ld23ik/1616167507458-2bbc9553-910c-4d66-9ad1-8f45893277da.jpeg" alt="">&lt;/p>
&lt;p>图 1-7 进程地址空间&lt;/p>
&lt;p>进程内存区由以下几部分组成：&lt;/p>
&lt;p>Text 段&lt;/p>
&lt;p>该区域用于存储运行代码。&lt;/p>
&lt;p>Data 段&lt;/p>
&lt;p>数据段包括三个区域。&lt;/p>
&lt;p>– Data：该区域存储已被初始化的数据，如静态变量。&lt;/p>
&lt;p>– BSS：该区域存储初始化为 0 的数据。数据被初始化为 0。&lt;/p>
&lt;p>– Heap：该区域用于根据需求使用 malloc()动态申请的内存。堆向高地址方向增长。&lt;/p>
&lt;p>Stack 段&lt;/p>
&lt;p>该区域用于存储局部变量、函数参数和返回函数的地址。栈向低地址方向增长。&lt;/p>
&lt;p>用户进程的地址空间内存分布可以使用 pmap 命令来查看。你可以使用 ps 命令来查看内存段的大小。可以参阅 2.3.10 的“pmap”，“ps 和 pstree”。&lt;/p>
&lt;h1 id="进程的-exit-code退出码">进程的 exit code(退出码)&lt;/h1>
&lt;p>在 Linux 系统中，程序可以在执行终止后传递值给其父进程，这个值被称为 &lt;strong>exit code(退出码)&lt;/strong> 或 **exit status(退出状态)**或 &lt;strong>reture status(返回码)&lt;/strong>。在 POSIX 系统中，惯例做法是当程序成功执行时 **exit code 为 0 **，当程序执行失败时 **exit code 非 0 **。&lt;/p>
&lt;p>传递状态码为何重要？如果你在命令行脚本上下文中查看状态码，答案显而易见。任何有用的脚本，它将不可避免地要么被其他脚本所使用，要么被 bash 单行脚本包裹所使用。特别是脚本被用来与自动化工具 SaltStack 或者监测工具 Nagios 配合使用。这些工具会执行脚本并检查它的状态，来确定脚本是否执行成功。&lt;/p>
&lt;p>其中最重要的原因是，即使你不定义状态码，它仍然存在于你的脚本中。如果你不定义恰当的退出码，执行失败的脚本可能会返回成功的状态，这样会导致问题，问题大小取决于你的脚本做了什么。&lt;/p>
&lt;p>Linux 提供了一个专门的变量$?来保存上个已执行命令的退出状态码。&lt;/p>
&lt;p>对于需要进行检查的命令，必须在其运行完毕后立刻查看或使用$?变量，它的值会变成由 shell 所执行的最后一条命令的退出状态码。&lt;/p>
&lt;p>一个成功结束的命令的退出状态码是 0，如果一个命令结束时有错误，退出状态码就是一个正数值（1-255）。&lt;/p>
&lt;p>Linux 上执行 exit 可使 shell 以指定的状态值退出。若不设置状态值参数，则 shell 以预设值退出。状态值 0 代表执行成功，其他值代表执行失败。exit 也可用在 script，离开正在执行的 script，回到 shell。&lt;/p>
&lt;p>Linux 错误退出状态码没有什么标准可循，但有一些可用的参考。&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/ld23ik/1616167507500-9f1aab01-171b-4ece-a6fa-9f576852a403.webp" alt="">&lt;/p>
&lt;p>关于具体的服务，相应的退出码，由开发者代码决定。&lt;/p>
&lt;p>&lt;strong>Linux 进程退出码&lt;/strong>&lt;/p>
&lt;p>&lt;a href="https://jin-yang.github.io/post/linux-process-exit-code-introduce.html">https://jin-yang.github.io/post/linux-process-exit-code-introduce.html&lt;/a>&lt;/p>
&lt;p>&lt;strong>Linux 退出状态码及 exit 命令&lt;/strong>&lt;/p>
&lt;p>&lt;a href="https://www.cnblogs.com/01-single/p/7206664.html">https://www.cnblogs.com/01-single/p/7206664.html&lt;/a>&lt;/p>
&lt;p>&lt;strong>理解 Exit Code 并学会如何在 Bash 脚本中使用&lt;/strong>&lt;/p>
&lt;p>&lt;a href="http://blog.jayxhj.com/2016/02/understanding-exit-codes-and-how-to-use-them-in-bash-scripts">http://blog.jayxhj.com/2016/02/understanding-exit-codes-and-how-to-use-them-in-bash-scripts&lt;/a>&lt;/p>
&lt;p>&lt;strong>Appendix E. Exit Codes With Special Meanings&lt;/strong>&lt;/p>
&lt;p>&lt;a href="http://www.tldp.org/LDP/abs/html/exitcodes.html">http://www.tldp.org/LDP/abs/html/exitcodes.html&lt;/a>&lt;/p>
&lt;p>&lt;strong>What is the authoritative list of Docker Run exit codes?&lt;/strong>&lt;/p>
&lt;p>&lt;a href="https://stackoverflow.com/questions/31297616/what-is-the-authoritative-list-of-docker-run-exit-codes">https://stackoverflow.com/questions/31297616/what-is-the-authoritative-list-of-docker-run-exit-codes&lt;/a>&lt;/p>
&lt;p>&lt;strong>Identifying Exit Codes and their meanings&lt;/strong>&lt;/p>
&lt;p>&lt;a href="https://support.circleci.com/hc/en-us/articles/360002341673-Identifying-Exit-Codes-and-their-meanings">https://support.circleci.com/hc/en-us/articles/360002341673-Identifying-Exit-Codes-and-their-meanings&lt;/a>&lt;/p>
&lt;p>&lt;strong>OpenShift Exit Status Codes&lt;/strong>&lt;/p>
&lt;p>&lt;a href="https://access.redhat.com/documentation/en-US/OpenShift_Online/2.0/html/Cartridge_Specification_Guide/Exit_Status_Codes.html">https://access.redhat.com/documentation/en-US/OpenShift_Online/2.0/html/Cartridge_Specification_Guide/Exit_Status_Codes.html&lt;/a>&lt;/p></description></item><item><title>Docs: Containerd</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/10.%E4%BA%91%E5%8E%9F%E7%94%9F/2.2.%E5%AE%9E%E7%8E%B0%E5%AE%B9%E5%99%A8%E7%9A%84%E5%B7%A5%E5%85%B7/containerd/containerd/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/10.%E4%BA%91%E5%8E%9F%E7%94%9F/2.2.%E5%AE%9E%E7%8E%B0%E5%AE%B9%E5%99%A8%E7%9A%84%E5%B7%A5%E5%85%B7/containerd/containerd/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://containerd.io/">官网&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://github.com/containerd/containerd">GitHub 项目，containerd/containerd&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://github.com/containerd/containerd/blob/main/docs/PLUGINS.md">GitHub 项目文档，containerd/docs/PLUGINS.md&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://fuckcloudnative.io/posts/getting-started-with-containerd/">云原生实验室，Containerd 使用教程&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://blog.frognew.com/tags/containerd.html">架构小白，Containerd 标签&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://mp.weixin.qq.com/s/Dr6851XnkNLVFHaj1b13RQ">公众号-云原生实验室，容器中的 Shim 到底是个什么鬼&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>Containerd 是行业标准的容器运行时，着重于简单性，健壮性和可移植性。&lt;/p>
&lt;h2 id="containerd-的前世今生">Containerd 的前世今生&lt;/h2>
&lt;p>很久以前，Docker 强势崛起，以“镜像”这个大招席卷全球，对其他容器技术进行致命的降维打击，使其毫无招架之力，就连 Google 也不例外。Google 为了不被拍死在沙滩上，被迫拉下脸面（当然，跪舔是不可能的），希望 Docker 公司和自己联合推进一个开源的容器运行时作为 Docker 的核心依赖，不然就走着瞧。Docker 公司觉得自己的智商被侮辱了，走着瞧就走着瞧，谁怕谁啊！&lt;/p>
&lt;p>很明显，Docker 公司的这个决策断送了自己的大好前程，造成了今天的悲剧。&lt;/p>
&lt;p>紧接着，Google 联合 Red Hat、IBM 等几位巨佬连哄带骗忽悠 Docker 公司将 &lt;code>libcontainer&lt;/code> 捐给中立的社区（OCI，Open Container Intiative），并改名为 &lt;code>runc&lt;/code>，不留一点 Docker 公司的痕迹~~这还不够，为了彻底扭转 Docker 一家独大的局面，几位大佬又合伙成立了一个基金会叫 &lt;code>CNCF&lt;/code>（Cloud Native Computing Fundation），这个名字想必大家都很熟了，我就不详细介绍了。CNCF 的目标很明确，既然在当前的维度上干不过 Docker，干脆往上爬，升级到大规模容器编排的维度，以此来击败 Docker。Docker 公司当然不甘示弱，搬出了 Swarm 和 Kubernetes 进行 PK，最后的结局大家都知道了，Swarm 战败。然后 Docker 公司耍了个小聪明，将自己的核心依赖 &lt;code>Containerd&lt;/code> 捐给了 CNCF，以此来标榜 Docker 是一个 PaaS 平台。&lt;/p>
&lt;p>很明显，这个小聪明又大大加速了自己的灭亡。
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/ox2yd7/1616122481377-1a01b919-efe6-450a-a439-5493a17e6d70.png" alt="">
巨佬们心想，想当初想和你合作搞个中立的核心运行时，你死要面子活受罪，就是不同意，好家伙，现在自己搞了一个，还捐出来了，马老师，发生甚莫事了？&lt;/p>
&lt;p>这好吗？&lt;/p>
&lt;p>这不好&lt;/p>
&lt;p>也罢，这倒省事了，我就直接拿 &lt;code>Containerd&lt;/code> 来做文章吧。首先呢，为了表示 Kubernetes 的中立性，当然要搞个标准化的容器运行时接口，只要适配了这个接口的容器运行时，都可以和我一起玩耍哦，第一个支持这个接口的当然就是 &lt;code>Containerd&lt;/code> 啦。至于这个接口的名字，大家应该都知道了，它叫 CRI（Container Runntime Interface）。这样还不行，为了蛊惑 Docker 公司，Kubernetes 暂时先委屈自己，专门在自己的组件中集成了一个 &lt;code>shim&lt;/code>（你可以理解为垫片），用来将 CRI 的调用翻译成 Docker 的 API，让 Docker 也能和自己愉快地玩耍，温水煮青蛙，养肥了再杀。。。&lt;/p>
&lt;p>就这样，Kubernetes 一边假装和 Docker 愉快玩耍，一边背地里不断优化 Containerd 的健壮性以及和 CRI 对接的丝滑性。现在 Containerd 的翅膀已经完全硬了，是时候卸下我的伪装，和 Docker say bye bye 了。后面的事情大家也都知道了~~&lt;/p>
&lt;p>Docker 这门技术成功了，Docker 这个公司却失败了。&lt;/p>
&lt;h2 id="containerd-架构">&lt;strong>Containerd 架构&lt;/strong>&lt;/h2>
&lt;p>时至今日，Containerd 已经变成一个工业级的容器运行时了，连口号都有了：超简单！超健壮！可移植性超强！&lt;/p>
&lt;p>当然，为了让 Docker 以为自己不会抢饭碗，Containerd 声称自己的设计目的主要是为了嵌入到一个更大的系统中（暗指 Kubernetes），而不是直接由开发人员或终端用户使用。&lt;/p>
&lt;p>事实上呢，Containerd 现在基本上啥都能干了，开发人员或者终端用户可以在宿主机中管理完整的容器生命周期，包括容器镜像的传输和存储、容器的执行和管理、存储和网络等。大家可以考虑学起来了。&lt;/p>
&lt;p>先来看看 Containerd 的架构：
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/ox2yd7/1616122481393-e3bb2fce-f18d-40ec-ac46-4c6d6a664cd6.png" alt="">
可以看到 Containerd 仍然采用标准的 C/S 架构，服务端通过 &lt;code>GRPC&lt;/code> 协议提供稳定的 API，客户端通过调用服务端的 API 进行高级的操作。&lt;/p>
&lt;p>为了解耦，Containerd 将不同的职责划分给不同的组件，每个组件就相当于一个&lt;strong>子系统&lt;/strong>（subsystem）。连接不同子系统的组件被称为模块。&lt;/p>
&lt;p>总体上 Containerd 被划分为两个子系统：&lt;/p>
&lt;ul>
&lt;li>&lt;strong>Bundle&lt;/strong> : 在 Containerd 中，&lt;code>Bundle&lt;/code> 包含了配置、元数据和根文件系统数据，你可以理解为容器的文件系统。而 &lt;strong>Bundle 子系统&lt;/strong>允许用户从镜像中提取和打包 Bundles。&lt;/li>
&lt;li>&lt;strong>Runtime&lt;/strong> : Runtime 子系统用来执行 Bundles，比如创建容器。&lt;/li>
&lt;/ul>
&lt;p>其中，每一个子系统的行为都由一个或多个&lt;strong>模块&lt;/strong>协作完成（架构图中的 &lt;code>Core&lt;/code> 部分）。每一种类型的模块都以 **Plugin(插件) **的形式集成到 Containerd 中，而且插件之间是相互依赖的。例如，上图中的每一个长虚线的方框都表示一种类型的插件，包括 &lt;code>Service Plugin&lt;/code>、&lt;code>Metadata Plugin&lt;/code>、&lt;code>GC Plugin&lt;/code>、&lt;code>Runtime Plugin&lt;/code> 等，其中 &lt;code>Service Plugin&lt;/code> 又会依赖 Metadata Plugin、GC Plugin 和 Runtime Plugin。每一个小方框都表示一个细分的插件，例如 &lt;code>Metadata Plugin&lt;/code> 依赖 Containers Plugin、Content Plugin 等。总之，万物皆插件，插件就是模块，模块就是插件。
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/ox2yd7/1616122481388-5272b6c1-efb6-49f4-a180-5425bef8ed64.png" alt="">
这里介绍几个常用的插件：&lt;/p>
&lt;ul>
&lt;li>&lt;strong>Content Plugin&lt;/strong> : 提供对镜像中可寻址内容的访问，所有不可变的内容都被存储在这里。&lt;/li>
&lt;li>&lt;strong>Snapshot Plugin&lt;/strong> : 用来管理容器镜像的文件系统快照。镜像中的每一个 layer 都会被解压成文件系统快照，类似于 Docker 中的 &lt;code>graphdriver&lt;/code>。&lt;/li>
&lt;li>&lt;strong>Metrics&lt;/strong> : 暴露各个组件的监控指标。&lt;/li>
&lt;/ul>
&lt;p>从总体来看，Containerd 被分为三个大块：&lt;code>Storage&lt;/code>、&lt;code>Metadata&lt;/code> 和 &lt;code>Runtime&lt;/code>，可以将上面的架构图提炼一下：
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/ox2yd7/1616122481410-b77c18a6-2bcd-48be-b676-1b285bf1c862.png" alt="">
这是使用 &lt;strong>bucketbench[1]&lt;/strong> 对 &lt;code>Docker&lt;/code>、&lt;code>crio&lt;/code> 和 &lt;code>Containerd&lt;/code> 的性能测试结果，包括启动、停止和删除容器，以比较它们所耗的时间：
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/ox2yd7/1616122481422-8a56805f-3ef0-46a4-be19-a0a5b1eef44f.png" alt="">
可以看到 Containerd 在各个方面都表现良好，总体性能还是优越于 &lt;code>Docker&lt;/code> 和 &lt;code>crio&lt;/code> 的。&lt;/p>
&lt;h1 id="containerd-关联文件">Containerd 关联文件&lt;/h1>
&lt;p>&lt;strong>/etc/containerd/config.toml&lt;/strong> # Containerd 运行时配置文件。该文件可以通过 containerd config default 命令来生成一个默认的配置。
&lt;strong>/var/lib/containerd/*&lt;/strong> # Root(根) 文件夹。用于保存持久化数据，镜像、元数据 所在路径。包括 Snapshots, Content, Metadata 以及各种插件的数据。每一个插件都有自己单独的目录，Containerd 本身不存储任何数据，它的所有功能都来自于已加载的插件。&lt;/p>
&lt;ul>
&lt;li>.**/io.containerd.content.v1.content/* **# 镜像的上下文
&lt;ul>
&lt;li>.**/blobs/* **# 镜像文件系统布局中，blobs 目录数据的存放路径&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>./io.containerd.snapshotter.v1.overlayfs/*&lt;/strong> # 镜像的层信息所在目录。&lt;/li>
&lt;li>/var/lib/containerd 目录下的内容详解，见 [《Containerd Image 章节》](/docs/IT学习笔记/10.云原生/2.2.实现容器的工具/Containerd/Containerd%20Image.md Image.md)&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>/run/containerd/*&lt;/strong> # State(状态) 文件夹。用于保存运行时产生的临时数据，也就是容器启动后数据存放目录。包括 sockets、pid、挂载点、运行时状态以及不需要持久化保存的插件数据。&lt;/p>
&lt;ul>
&lt;li>&lt;strong>./io.containerd.runtime.VERSION.ID/*&lt;/strong> # Containerd 运行容器时所使用的 runtime 插件，该目录的名称就是插件的版本和名称。该目录下的目录以名称空间命名。
&lt;ul>
&lt;li>&lt;strong>./NAMESPACE/*&lt;/strong> # 指定名称空间下的容器启动后的数据(主要就是符合 OCI 标准的 一组 Bundle 文件)保存路径，其内目录名为 ContainerID。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h2 id="目录结构">目录结构&lt;/h2>
&lt;p>在 /var/lib/containerd 和 /run/containerd 目录下，保存了 Containerd 运行所需的所有数据。Containerd 本身不存储任何数据，所有数据都来源于插件的功能。
看一下目录下的层次结构就一目了然了：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>? → tree -L &lt;span style="color:#ae81ff">2&lt;/span> /var/lib/containerd/
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>/var/lib/containerd/
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>├── io.containerd.content.v1.content
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>│ ├── blobs
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>│ └── ingest
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>├── io.containerd.grpc.v1.cri
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>│ ├── containers
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>│ └── sandboxes
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>├── io.containerd.metadata.v1.bolt
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>│ └── meta.db
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>├── io.containerd.runtime.v1.linux
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>│ └── k8s.io
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>├── io.containerd.runtime.v2.task
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>├── io.containerd.snapshotter.v1.aufs
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>│ └── snapshots
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>├── io.containerd.snapshotter.v1.btrfs
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>├── io.containerd.snapshotter.v1.native
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>│ └── snapshots
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>├── io.containerd.snapshotter.v1.overlayfs
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>│ ├── metadata.db
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>│ └── snapshots
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>└── tmpmounts
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">18&lt;/span> directories, &lt;span style="color:#ae81ff">2&lt;/span> files
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>每个子目录，其实都表示的是一个插件名称。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>? → tree -L &lt;span style="color:#ae81ff">2&lt;/span> /run/containerd/
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>/run/containerd/
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>├── containerd.sock
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>├── containerd.sock.ttrpc
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>├── io.containerd.grpc.v1.cri
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>│ ├── containers
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>│ └── sandboxes
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>├── io.containerd.runtime.v1.linux
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>│ └── k8s.io
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>├── io.containerd.runtime.v2.task
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>└── runc
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> └── k8s.io
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">8&lt;/span> directories, &lt;span style="color:#ae81ff">2&lt;/span> files
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h1 id="containerd-插件">Containerd 插件&lt;/h1></description></item><item><title>Docs: Containerd 配置详解</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/10.%E4%BA%91%E5%8E%9F%E7%94%9F/2.2.%E5%AE%9E%E7%8E%B0%E5%AE%B9%E5%99%A8%E7%9A%84%E5%B7%A5%E5%85%B7/containerd/containerd-%E9%85%8D%E7%BD%AE%E8%AF%A6%E8%A7%A3/containerd-%E9%85%8D%E7%BD%AE%E8%AF%A6%E8%A7%A3/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/10.%E4%BA%91%E5%8E%9F%E7%94%9F/2.2.%E5%AE%9E%E7%8E%B0%E5%AE%B9%E5%99%A8%E7%9A%84%E5%B7%A5%E5%85%B7/containerd/containerd-%E9%85%8D%E7%BD%AE%E8%AF%A6%E8%A7%A3/containerd-%E9%85%8D%E7%BD%AE%E8%AF%A6%E8%A7%A3/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://github.com/containerd/containerd/blob/main/docs/man/containerd-config.toml.5.md">Manual(手册),containerd-config.toml(5)&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://manpages.debian.org/bullseye/containerd/containerd-config.toml.5.en.html">Debian Manual&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>Containerd 使用 &lt;a href="https://desistdaydream.github.io/docs/IT%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/2.%E7%BC%96%E7%A8%8B/%E6%97%A0%E6%B3%95%E5%88%86%E7%B1%BB%E7%9A%84%E8%AF%AD%E8%A8%80/TOML.md">TOML&lt;/a> 作为配置文件的格式，默认配置文件为 /etc/containerd/config.toml，我们可以通过命令来生成一个包含所有配置字段的默认配置文件&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>mkdir -p /etc/containerd
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>containerd config default &amp;gt; /etc/containerd/config.toml
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h1 id="配置文件详解">配置文件详解&lt;/h1>
&lt;h1 id="通用配置">[通用]配置&lt;/h1>
&lt;p>&lt;strong>version = 2&lt;/strong> #
&lt;strong>root = &amp;lt;STRING&amp;gt;&lt;/strong> # Containerd 持久化数据路径。&lt;code>默认值：/var/lib/containerd&lt;/code>。
&lt;strong>state = &amp;lt;STRING&amp;gt;&lt;/strong> # Containerd 临时数据路径。&lt;code>默认值：/run/containerd&lt;/code>。
&lt;strong>oom_score = 0&lt;/strong> # 设置 Containerd 的 OOM 权重。&lt;code>默认值：0&lt;/code>。
Containerd 是容器的守护者，一旦发生内存不足的情况，理想的情况应该是先杀死容器，而不是杀死 Containerd。所以需要调整 Containerd 的 &lt;code>OOM&lt;/code> 权重，减少其被 &lt;strong>OOM Kill&lt;/strong> 的几率。最好是将 &lt;code>oom_score&lt;/code> 的值调整为比其他守护进程略低的值。这里的 oom_socre 其实对应的是 &lt;code>/proc/&amp;lt;pid&amp;gt;/oom_socre_adj&lt;/code>，在早期的 Linux 内核版本里使用 &lt;code>oom_adj&lt;/code> 来调整权重, 后来改用 &lt;code>oom_socre_adj&lt;/code> 了。该文件描述如下：
在计算最终的 &lt;code>badness score&lt;/code> 时，会在计算结果是中加上 &lt;code>oom_score_adj&lt;/code> ,这样用户就可以通过该在值来保护某个进程不被杀死或者每次都杀某个进程。其取值范围为 &lt;code>-1000&lt;/code> 到 &lt;code>1000&lt;/code>。如果将该值设置为 &lt;code>-1000&lt;/code>，则进程永远不会被杀死，因为此时 &lt;code>badness score&lt;/code> 永远返回 0。建议 Containerd 将该值设置为 &lt;code>-999&lt;/code> 到 &lt;code>0&lt;/code> 之间。如果作为 Kubernetes 的 Worker 节点，可以考虑设置为 &lt;code>-999&lt;/code>。&lt;/p>
&lt;h1 id="cgroup-配置">[cgroup] 配置&lt;/h1>
&lt;h1 id="debug-配置">[debug] 配置&lt;/h1>
&lt;h1 id="grpc-配置表">[grpc] 配置表&lt;/h1>
&lt;p>&lt;strong>address = &lt;!-- raw HTML omitted -->&lt;/strong> # Containerd 监听的 GRPC 路径。&lt;code>默认值：/run/containerd/containerd.sock&lt;/code>&lt;/p>
&lt;h1 id="metrics-配置">[metrics] 配置&lt;/h1>
&lt;h1 id="plugins-配置">[plugins] 配置&lt;/h1>
&lt;p>详见 [《Plugin 配置》](/docs/IT学习笔记/10.云原生/2.2.实现容器的工具/Containerd/Containerd%20 配置详解/Plugin%20 配置.md 配置详解/Plugin 配置.md) 章节&lt;/p>
&lt;h1 id="timeouts-配置">[timeouts] 配置&lt;/h1>
&lt;h1 id="ttrpc-配置表">[ttrpc] 配置表&lt;/h1>
&lt;h1 id="配置文件示例">配置文件示例&lt;/h1>
&lt;h2 id="镜像加速配置示例">镜像加速配置示例&lt;/h2>
&lt;p>Containerd 的镜像仓库 mirror 与 Docker 相比有两个区别：&lt;/p>
&lt;ul>
&lt;li>Containerd 只支持通过 &lt;code>CRI&lt;/code> 拉取镜像的 mirror，也就是说，只有通过 &lt;code>crictl&lt;/code> 或者 Kubernetes 调用时 mirror 才会生效，通过 &lt;code>ctr&lt;/code> 拉取是不会生效的。&lt;/li>
&lt;li>&lt;code>Docker&lt;/code> 只支持为 &lt;code>Docker Hub&lt;/code> 配置 mirror，而 &lt;code>Containerd&lt;/code> 支持为任意镜像仓库配置 mirror。&lt;/li>
&lt;/ul>
&lt;p>所以需要修改的部分如下：&lt;/p>
&lt;pre>&lt;code>[plugins.&amp;quot;io.containerd.grpc.v1.cri&amp;quot;.registry]
[plugins.&amp;quot;io.containerd.grpc.v1.cri&amp;quot;.registry.mirrors]
[plugins.&amp;quot;io.containerd.grpc.v1.cri&amp;quot;.registry.mirrors.&amp;quot;docker.io&amp;quot;]
endpoint = [&amp;quot;https://dockerhub.mirrors.nwafu.edu.cn&amp;quot;]
[plugins.&amp;quot;io.containerd.grpc.v1.cri&amp;quot;.registry.mirrors.&amp;quot;k8s.gcr.io&amp;quot;]
endpoint = [&amp;quot;https://registry.aliyuncs.com/k8sxio&amp;quot;]
[plugins.&amp;quot;io.containerd.grpc.v1.cri&amp;quot;.registry.mirrors.&amp;quot;gcr.io&amp;quot;]
endpoint = [&amp;quot;xxx&amp;quot;]
&lt;/code>&lt;/pre>
&lt;h1 id="systemd-配置">Systemd 配置&lt;/h1>
&lt;p>建议通过 systemd 配置 Containerd 作为守护进程运行，配置文件在上文已经被解压出来了：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">[&lt;/span>Unit&lt;span style="color:#f92672">]&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Description&lt;span style="color:#f92672">=&lt;/span>containerd container runtime
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Documentation&lt;span style="color:#f92672">=&lt;/span>https://containerd.io
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>After&lt;span style="color:#f92672">=&lt;/span>network.target local-fs.target
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">[&lt;/span>Service&lt;span style="color:#f92672">]&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>ExecStartPre&lt;span style="color:#f92672">=&lt;/span>-/sbin/modprobe overlay
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>ExecStart&lt;span style="color:#f92672">=&lt;/span>/usr/local/bin/containerd
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Type&lt;span style="color:#f92672">=&lt;/span>notify
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Delegate&lt;span style="color:#f92672">=&lt;/span>yes
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>KillMode&lt;span style="color:#f92672">=&lt;/span>process
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Restart&lt;span style="color:#f92672">=&lt;/span>always
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>RestartSec&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">5&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># Having non-zero Limit*s causes performance problems due to accounting overhead&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># in the kernel. We recommend using cgroups to do container-local accounting.&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>LimitNPROC&lt;span style="color:#f92672">=&lt;/span>infinity
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>LimitCORE&lt;span style="color:#f92672">=&lt;/span>infinity
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>LimitNOFILE&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">1048576&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># Comment TasksMax if your systemd version does not supports it.&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># Only systemd 226 and above support this version.&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>TasksMax&lt;span style="color:#f92672">=&lt;/span>infinity
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>OOMScoreAdjust&lt;span style="color:#f92672">=&lt;/span>-999
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">[&lt;/span>Install&lt;span style="color:#f92672">]&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>WantedBy&lt;span style="color:#f92672">=&lt;/span>multi-user.target
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>这里有两个重要的参数：&lt;/p>
&lt;ul>
&lt;li>&lt;strong>Delegate&lt;/strong> : 这个选项允许 Containerd 以及运行时自己管理自己创建的容器的 &lt;code>cgroups&lt;/code>。如果不设置这个选项，systemd 就会将进程移到自己的 &lt;code>cgroups&lt;/code> 中，从而导致 Containerd 无法正确获取容器的资源使用情况。&lt;/li>
&lt;li>&lt;strong>KillMode&lt;/strong> : 这个选项用来处理 Containerd 进程被杀死的方式。默认情况下，systemd 会在进程的 cgroup 中查找并杀死 Containerd 的所有子进程，这肯定不是我们想要的。&lt;code>KillMode&lt;/code>字段可以设置的值如下。我们需要将 KillMode 的值设置为 &lt;code>process&lt;/code>，这样可以确保升级或重启 Containerd 时不杀死现有的容器。
&lt;ul>
&lt;li>&lt;strong>control-group&lt;/strong>（默认值）：当前控制组里面的所有子进程，都会被杀掉&lt;/li>
&lt;li>&lt;strong>process&lt;/strong>：只杀主进程&lt;/li>
&lt;li>&lt;strong>mixed&lt;/strong>：主进程将收到 SIGTERM 信号，子进程收到 SIGKILL 信号&lt;/li>
&lt;li>&lt;strong>none&lt;/strong>：没有进程会被杀掉，只是执行服务的 stop 命令。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul></description></item><item><title>Docs: ECMAScript 环境安装与使用</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/2.%E7%BC%96%E7%A8%8B/%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/ecmascript/ecmascript-%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8/ecmascript-%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/2.%E7%BC%96%E7%A8%8B/%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/ecmascript/ecmascript-%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8/ecmascript-%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;/blockquote>
&lt;p>有两种运行时环境可以运行 ECMAScript 代码(Javascript、Typescript)&lt;/p>
&lt;ul>
&lt;li>**Browser **# 浏览器就是 ECMAScript 的运行时环境。&lt;/li>
&lt;li>&lt;strong>Node.js&lt;/strong> # 在服务器或 PC 上安装 Node.js 环境以运行 ECMAScript 代码&lt;/li>
&lt;li>&lt;strong>Deno&lt;/strong> # &lt;a href="https://github.com/denoland/deno">GtiHub 项目，denoland/deno&lt;/a>。据说要替代 Node.js，很尴尬的是。。。早期 18 年的 issue 中被各种国人无意义灌水&lt;/li>
&lt;li>&lt;strong>Bun&lt;/strong> # &lt;a href="https://github.com/oven-sh/bun">GtiHub 项目，oven-sh/bun&lt;/a>&lt;/li>
&lt;/ul>
&lt;p>但是这两者可以提供的 API 能力各不相同&lt;/p>
&lt;ul>
&lt;li>Browser 可以提供的 dockument、window 和其他关于 DOM 或其他 Web 平台 API 的对象。&lt;/li>
&lt;li>Node.js 则可以提供很多操作系统相关的 API，比如文件的读写、进程管理、网络通信等等。&lt;/li>
&lt;/ul>
&lt;p>Node.js 与 Browser 都是基于 Chrome V8 引擎的 ECMAScript 运行时环境&lt;/p>
&lt;p>你也许会想，直接在我的硬盘上创建好 HTML 和 JavaScript 文件，然后用浏览器打开，不就可以看到效果了吗？&lt;/p>
&lt;p>这种方式运行部分 JavaScript 代码没有问题，但由于浏览器的安全限制，以 file:// 开头的地址无法执行如联网等 JavaScript 代码，最终，你还是需要架设一个 Web 服务器，然后以 http:// 开头的地址来正常执行所有 JavaScript 代码。&lt;/p>
&lt;p>所以，想要运行 JavaScript 编写的静态文件，通常都需要一个可以提供 HTTP 服务的程序，以便响应客户端的请求返回这些静态文件。通常在生产环境中，我们都会将静态资源文件放到 Nginx 的目录中，由 Nginx 为客户端提供 HTTP 服务。&lt;/p>
&lt;p>而本地测试时，我们通过 npm 与 yarn 工具即可安装一个简易的 HTTP 服务，这个 HTTP 服务都是由 JS 代码写的，必须要保证本地有 Node.js 环境，即可启动一个 HTTP 服务&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># Npm 安装 http-server&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>~&lt;span style="color:#f92672">]&lt;/span>&lt;span style="color:#75715e"># npm install http-server&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># Yarn 安装 http-server&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>~&lt;span style="color:#f92672">]&lt;/span>&lt;span style="color:#75715e"># yarn add http-server&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>http-server 来源于 &lt;a href="https://github.com/http-party/http-server">GitHub 项目，http-party/http-server&lt;/a>&lt;/p>
&lt;p>通过 &lt;code>npm exec serve&lt;/code> 命令将会安装另一个名为 serve 的库以运行 HTTP 服务，默认在 3000 端口上启动 HTTP 服务，通过浏览器访问 localhost:3000 即可获取到所有自己编写的静态文件，便于让开发人员在本地调试。&lt;/p>
&lt;h2 id="重点运行具有-module模块-功能的静态资源">(重点)运行具有 Module(模块) 功能的静态资源&lt;/h2>
&lt;p>从《ECMAScript 模块》章节可以看到，当我们使用 &lt;code>import name from './one.js'&lt;/code> 导入的模块是一个文件时，那么这个文件将会被响应给浏览器，如果使用 &lt;code>import name from 'one'&lt;/code> 导入的模块是一组文件时，此时浏览器无法直接识别，将会产生报错。因为浏览器想要执行这一组文件需要发起很多次的请求将所有文件都加载到本地，这其中的路由路径将是不可控的。&lt;/p>
&lt;p>所以，此时我们则需要想办法将这一组文件变为一个文件响应给浏览器以便加载代码。这个转换的操作，我们可以使用打包工具(i.e.Webpack、Vite 等等) 将源代码&lt;strong>打包编译&lt;/strong>成新的静态文件即可。&lt;/p>
&lt;p>后面的逻辑，与基本运行 ECMAScript 代码的行为就是一样的了。&lt;/p>
&lt;h2 id="使用-vite-运行-ecmascript-代码">使用 Vite 运行 ECMAScript 代码&lt;/h2>
&lt;p>npm、yarn 的打包后运行代码的速度非常缓慢，才是推荐使用 Vite 工具启动 HTTP 服务并运行 JS/TS 代码，详见：[《Vite》](/docs/IT学习笔记/2.编程/高级编程语言/ECMAScript/ECMAScript%20 工具/Vite.md 工具/Vite.md) 章节&lt;/p>
&lt;h2 id="运行-typesript">运行 TypeSript&lt;/h2>
&lt;p>Node.js 和 浏览器都无法直接运行 TypeScript 代码，这是因为 TS 的代码需要先转换为 JS 代码才可以运行。此时就需要一种工具，先转换再运行，或者直接转换运行一体。&lt;/p>
&lt;ul>
&lt;li>&lt;strong>tsc&lt;/strong> # 将 TS 代码转换为 JS 代码。&lt;code>npm install -g typescript&lt;/code>&lt;/li>
&lt;li>&lt;strong>ts-node&lt;/strong> # 可以直接转换并运行 TS 代码，&lt;code>npm install -g ts-node&lt;/code> 安装即可&lt;/li>
&lt;/ul>
&lt;h1 id="nodejs">Node.js&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://nodejs.org/en/">org 官网&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://nodejs.dev/">dev 官网&lt;/a>&lt;/li>
&lt;li>&lt;a href="http://nodejs.cn/">dev 官网中文翻译&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Node.js">Wiki,Node.js&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>Node.js 是基于 Chrome V8 引擎的 ECMAScript 运行时环境，由 RyanDahl 于 2009 年 5 月 27 日发布。转年(i.e.2010 年 1 月)，为 Node.js 环境引入了一个名为 npm 的包管理器。包管理器使程序员更容易发布和共享 Node.js 的源代码，旨在简化包的安装、更新、卸载。&lt;/p>
&lt;p>Browser 和 Node.js 都是 ECMAScript 的运行时环境，但是这两者可以提供的 API 能力各不相同&lt;/p>
&lt;ul>
&lt;li>Browser 可以提供的 dockument、window 和其他关于 DOM 或其他 Web 平台 API 的对象。&lt;/li>
&lt;li>Node.js 则可以提供很多操作系统相关的 API，比如文件的读写、进程管理、网络通信等等。&lt;/li>
&lt;/ul>
&lt;p>通过 Node.js，可以让我们使用一种语言编写前端与后端。我们甚至可以通过 npm 与 yarn 安装第三方库后，使用 Node.js 在本地监听端口并响应给客户端静态资源文件。&lt;/p>
&lt;h2 id="安装-nodejs">安装 Node.js&lt;/h2>
&lt;h3 id="linux">Linux&lt;/h3>
&lt;p>从&lt;a href="https://nodejs.org/zh-cn/download/">官网&lt;/a>下载 Linux 版的 &lt;code>.tar.xg&lt;/code> 包，并解压&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>export NodejsVersion&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;v16.15.0&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>wget https://nodejs.org/dist/&lt;span style="color:#e6db74">${&lt;/span>NodejsVersion&lt;span style="color:#e6db74">}&lt;/span>/node-&lt;span style="color:#e6db74">${&lt;/span>NodejsVersion&lt;span style="color:#e6db74">}&lt;/span>-linux-x64.tar.xz
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>tar -xvf node-&lt;span style="color:#e6db74">${&lt;/span>NodejsVersion&lt;span style="color:#e6db74">}&lt;/span>-linux-x64.tar.xz -C /usr/local/
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>mv /usr/local/node-&lt;span style="color:#e6db74">${&lt;/span>NodejsVersion&lt;span style="color:#e6db74">}&lt;/span>-linux-x64 /usr/local/nodejs
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>配置环境变量&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>sudo tee /etc/profile.d/nodejs.sh &amp;gt; /dev/null &amp;lt;&amp;lt;-&lt;span style="color:#e6db74">&amp;#34;EOF&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>export PATH&lt;span style="color:#f92672">=&lt;/span>$PATH:/usr/local/nodejs/bin
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>EOF
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="windows">Windows&lt;/h3>
&lt;p>警告！！！由于 msi 安装包会修改 %PREFIX% 为 &lt;code>%APPDATA%\npm&lt;/code> ，并将该目录到 $PATH。我个人推荐下载 zip，并自己解压到想要的位置后，手动配置环境变量。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-powershell" data-lang="powershell">&lt;span style="display:flex;">&lt;span>$NodejsVersion = &lt;span style="color:#e6db74">&amp;#34;18.14.1&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>$NodejsUrl = &lt;span style="color:#e6db74">&amp;#34;https://nodejs.org/dist/v&lt;/span>$NodejsVersion&lt;span style="color:#e6db74">/node-v&lt;/span>$NodejsVersion&lt;span style="color:#e6db74">-win-x64.zip&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>$TempZipFile = &lt;span style="color:#e6db74">&amp;#34;D:\tmp\nodejs.zip&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>$ExtractPath = &lt;span style="color:#e6db74">&amp;#34;D:\Tools&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># Download the zip file to a temporary location&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Invoke-WebRequest -Uri $NodejsUrl -OutFile $TempZipFile
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># Extract the contents of the zip file to the installation directory and rename the top-level directory to &amp;#34;nodejs&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Expand-Archive -Path $TempZipFile -DestinationPath $ExtractPath
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Rename-Item -Path &lt;span style="color:#e6db74">&amp;#34;&lt;/span>$ExtractPath&lt;span style="color:#e6db74">\node-v&lt;/span>$NodejsVersion&lt;span style="color:#e6db74">-win-x64&amp;#34;&lt;/span> -NewName &lt;span style="color:#e6db74">&amp;#34;nodejs&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>将 nodejs/ 目录添加到用户的 PATH 环境变量中&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-powershell" data-lang="powershell">&lt;span style="display:flex;">&lt;span>$path = [&lt;span style="color:#66d9ef">Environment&lt;/span>]::GetEnvironmentVariable(&lt;span style="color:#e6db74">&amp;#34;Path&amp;#34;&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;User&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>$newPath = &lt;span style="color:#e6db74">&amp;#34;D:\Tools\nodejs&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>[&lt;span style="color:#66d9ef">Environment&lt;/span>]::SetEnvironmentVariable(&lt;span style="color:#e6db74">&amp;#34;Path&amp;#34;&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;&lt;/span>$path&lt;span style="color:#e6db74">;&lt;/span>$newPath&lt;span style="color:#e6db74">&amp;#34;&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;User&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="目录结构">目录结构&lt;/h3>
&lt;p>Linux 目录结构，node_modules/ 目录在 lib/ 目录下，这点与 Windows 不同。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">]&lt;/span>&lt;span style="color:#75715e"># tree -L 2 -F&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>.
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>├── bin/
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>│   ├── corepack -&amp;gt; ../lib/node_modules/corepack/dist/corepack.js*
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>│   ├── node*
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>│   ├── npm -&amp;gt; ../lib/node_modules/npm/bin/npm-cli.js*
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>│   ├── npx -&amp;gt; ../lib/node_modules/npm/bin/npx-cli.js*
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>│   ├── pnpm -&amp;gt; ../lib/node_modules/corepack/dist/pnpm.js*
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>│   ├── pnpx -&amp;gt; ../lib/node_modules/corepack/dist/pnpx.js*
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>│   ├── yarn -&amp;gt; ../lib/node_modules/corepack/dist/yarn.js*
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>│   └── yarnpkg -&amp;gt; ../lib/node_modules/corepack/dist/yarnpkg.js*
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>├── CHANGELOG.md
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>├── include/
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>│   └── node/
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>├── lib/
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>│   └── node_modules/
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>├── LICENSE
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>├── README.md
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>└── share/
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ├── doc/
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ├── man/
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> └── systemtap/
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Windows 目录结构&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>$ tree -L &lt;span style="color:#ae81ff">2&lt;/span> -F
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>./
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>├── CHANGELOG.md*
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>├── LICENSE*
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>├── README.md*
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>├── corepack*
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>├── corepack.cmd*
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>├── install_tools.bat*
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>├── node.exe*
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>├── node_etw_provider.man*
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>├── node_modules/
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>│   ├── corepack/
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>│   └── npm/
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>├── nodevars.bat*
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>├── npm*
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>├── npm.cmd*
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>├── npx*
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>└── npx.cmd*
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="nvm">NVM&lt;/h2>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://github.com/nvm-sh/nvm">GitHub 项目，nvm-sh/nvm&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>&lt;strong>Node Version Manager(Node.js 版本管理器，简称 NVM)&lt;/strong>&lt;/p>
&lt;h2 id="nodejs-关联文件与配置">Node.js 关联文件与配置&lt;/h2>
&lt;p>详见：&lt;a href="docs/IT%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/2.%E7%BC%96%E7%A8%8B/%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/ECMAScript/ECMAScript%20%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8/ECMAScript%20%E6%A8%A1%E5%9D%97%E4%B8%8E%E5%8C%85%E7%9A%84%E4%BD%BF%E7%94%A8%E4%B8%8E%E7%AE%A1%E7%90%86.md#npm%20%E5%85%B3%E8%81%94%E6%96%87%E4%BB%B6%E4%B8%8E%E9%85%8D%E7%BD%AE">npm 关键文件与配置&lt;/a>&lt;/p>
&lt;h1 id="初始化项目">初始化项目&lt;/h1>
&lt;p>npm 等包管理工具下载完框架后，会自动生成项目目录，这些目录是已经初始化完成的项目，包含了很多必要的文件，比如 package.json 等。&lt;/p>
&lt;p>随着学习深入，会逐步总结一个前端项目如果不使用框架从头构建的话会需要什么。&lt;/p>
&lt;ul>
&lt;li>&lt;strong>public/&lt;/strong> 目录存放公共资源&lt;/li>
&lt;li>&lt;strong>src/&lt;/strong> # 所有代码都在 src/ 目录下&lt;/li>
&lt;li>&lt;strong>.eslintrc.cjs&lt;/strong> # ESLint 程序配置&lt;/li>
&lt;li>&lt;strong>.prettierc.json&lt;/strong> # Prettier 插件的配置&lt;/li>
&lt;li>&lt;strong>env.d.ts&lt;/strong> #&lt;/li>
&lt;li>&lt;strong>index.html&lt;/strong> # 程序入口&lt;/li>
&lt;li>[&lt;strong>package.json&lt;/strong>](/docs/IT学习笔记/2.编程/高级编程语言/ECMAScript/ECMAScript%20 环境安装与使用/package.json.md 环境安装与使用/package.json.md) # 包管理器配置文件，比如 npm、pnpm 等&lt;/li>
&lt;li>&lt;strong>vite.config.ts&lt;/strong> # Vite 程序给项目打包时使用的配置&lt;/li>
&lt;li>&lt;strong>tsconfig.json&lt;/strong> #&lt;/li>
&lt;li>&lt;strong>tsconfig.config.json&lt;/strong> # [TSConfig](/docs/IT学习笔记/2.编程/高级编程语言/ECMAScript/ECMAScript%20 环境安装与使用/TSConfig.md 环境安装与使用/TSConfig.md) 文件&lt;/li>
&lt;/ul>
&lt;h2 id="javascript-项目初始化">JavaScript 项目初始化&lt;/h2>
&lt;p>无&lt;/p>
&lt;h2 id="typescript-项目初始化">TypeScript 项目初始化&lt;/h2>
&lt;p>使用 &lt;code>npm install -g typescript&lt;/code> 安装 tsc 命令。&lt;/p>
&lt;p>使用 &lt;code>tsc init&lt;/code> 命令将会生成 [TSConfig](/docs/IT学习笔记/2.编程/高级编程语言/ECMAScript/ECMAScript%20 环境安装与使用/TSConfig.md 环境安装与使用/TSConfig.md) 文件。&lt;/p>
&lt;h1 id="编译与打包">编译与打包&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://github.com/webpack/webpack">GitHub 项目，webpack/webpack&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://github.com/rollup/rollup">GitHub 项目，rollup/rollup&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>大型项目通常都要打包，打包工具有很多：&lt;/p>
&lt;ul>
&lt;li>Webpack&lt;/li>
&lt;li>Rollup&lt;/li>
&lt;li>Vite&lt;/li>
&lt;li>&amp;hellip;&amp;hellip;等等&lt;/li>
&lt;/ul>
&lt;h1 id="常见问题">常见问题&lt;/h1>
&lt;h2 id="nodejs-无法使用-es6-语法问题">Node.js 无法使用 ES6 语法问题&lt;/h2>
&lt;p>无法使用 import 关键字导入模块。参考 &lt;a href="https://nodejs.org/docs/latest-v16.x/api/esm.html#enabling">https://nodejs.org/docs/latest-v16.x/api/esm.html#enabling&lt;/a>，在 package.json 文件中设置 &lt;code>&amp;quot;type&amp;quot;: &amp;quot;module&amp;quot;&lt;/code> 或者使用 &lt;code>--input-type=module&lt;/code> 命令行参数以告诉 Node.js 使用 ECMAScript 模块加载器。默认情况下，Node.js 使用 CommonJS 模块加载器。&lt;/p></description></item><item><title>Docs: File System 管理</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/y.windows-%E7%AE%A1%E7%90%86/file_system_%E7%AE%A1%E7%90%86/file_system_%E7%AE%A1%E7%90%86/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/y.windows-%E7%AE%A1%E7%90%86/file_system_%E7%AE%A1%E7%90%86/file_system_%E7%AE%A1%E7%90%86/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://www.howtogeek.com/318177/what-is-the-appdata-folder-in-windows/">https://www.howtogeek.com/318177/what-is-the-appdata-folder-in-windows/&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>&lt;strong>%USERPROFILE%/AppData/*&lt;/strong> #&lt;/p>
&lt;ul>
&lt;li>&lt;strong>./Local/*&lt;/strong> #&lt;/li>
&lt;li>&lt;strong>./LocalLow/*&lt;/strong> #&lt;/li>
&lt;li>&lt;strong>./Roaming/*&lt;/strong> #&lt;/li>
&lt;/ul>
&lt;p>刚装完的 win10 专业版，用户的 AppData 中将会有如下结构：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-powershell" data-lang="powershell">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">%&lt;/span>USERPROFILE%\appdata\Local
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">%&lt;/span>USERPROFILE%\appdata\LocalLow
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">%&lt;/span>USERPROFILE%\appdata\Roaming
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">%&lt;/span>USERPROFILE%\appdata\Local\Comms
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">%&lt;/span>USERPROFILE%\appdata\Local\ConnectedDevicesPlatform
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">%&lt;/span>USERPROFILE%\appdata\Local\D3DSCache
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">%&lt;/span>USERPROFILE%\appdata\Local\Microsoft
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">%&lt;/span>USERPROFILE%\appdata\Local\Packages
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">%&lt;/span>USERPROFILE%\appdata\Local\Temp
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">%&lt;/span>USERPROFILE%\appdata\LocalLow\Microsoft
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">%&lt;/span>USERPROFILE%\appdata\LocalLow\MSLiveStickerWhiteList
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">%&lt;/span>USERPROFILE%\appdata\Roaming\Adobe
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">%&lt;/span>USERPROFILE%\appdata\Roaming\Microsoft
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>最主要的是这三个目录下的 Microsfot 目录，还有 Packages 目录。在整理 AppData 时，不要误删了。&lt;/p>
&lt;h1 id="program-files">Program Files&lt;/h1>
&lt;p>该目录存储安装在计算机上的大多数应用程序的执行文件。&lt;/p>
&lt;h1 id="program-filesx86">Program Files(x86)&lt;/h1>
&lt;p>该目录存储在 64 位 Windows 系统上安装的 32 位应用程序的执行文件。&lt;/p>
&lt;h1 id="programdata">ProgramData&lt;/h1>
&lt;p>该目录存储全局数据，包括应用程序的配置文件，以及系统的安装和更新信息。&lt;/p>
&lt;h1 id="users">Users&lt;/h1>
&lt;p>该目录存储在 Windows 系统上创建的每个用户的个人文件夹，如桌面、文档和图片。&lt;/p>
&lt;h1 id="windows">Windows&lt;/h1>
&lt;p>Windows 操作系统的核心文件和 DLL 文件都存储在此目录中。&lt;/p>
&lt;p>&lt;strong>./System32/&lt;/strong> # 类似于 Linux 中的 /usr/sbin/ 目录，系统自带的命令、服务、msc 的可执行文件都在这里。&lt;/p></description></item><item><title>Docs: Go 环境安装与使用</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/2.%E7%BC%96%E7%A8%8B/%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/go/go-%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8/go-%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/2.%E7%BC%96%E7%A8%8B/%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/go/go-%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8/go-%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://golang.org/doc/install">官方文档，下载并安装 Go&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://golang.org/doc/manage-install">官方文档，安装多个版本的 Go&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://pkg.go.dev/cmd/go">Go 包，标准库-cmd-go&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://github.com/goproxy/goproxy.cn/issues/61">GitHub 项目-goproxy-goproxy.io 与 goproxy.cn 说明&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>我们可以通过一个名为 go 的二进制文件实现绝大部分日常的 编码、编译 等工作，只要安装好 Go 的环境即可。&lt;/p>
&lt;h1 id="安装-go">安装 Go&lt;/h1>
&lt;h2 id="linux-安装">Linux 安装&lt;/h2>
&lt;p>从&lt;a href="https://golang.org/dl/">官网&lt;/a>下载 linux 版的 &lt;code>.tar.gz&lt;/code> 包&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>export GoVersion&lt;span style="color:#f92672">=&lt;/span>1.18.5
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>wget https://go.dev/dl/go&lt;span style="color:#e6db74">${&lt;/span>GoVersion&lt;span style="color:#e6db74">}&lt;/span>.linux-amd64.tar.gz
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>tar -C /usr/local -xvzf go&lt;span style="color:#e6db74">${&lt;/span>GoVersion&lt;span style="color:#e6db74">}&lt;/span>.linux-amd64.tar.gz
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>配置环境变量，以便让 shell 可以执行 go 命令并立刻生效&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>sudo tee /etc/profile.d/go.sh &amp;gt; /dev/null &amp;lt;&amp;lt;-&lt;span style="color:#e6db74">&amp;#34;EOF&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># export GOPATH=/opt/gopath&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># export PATH=$PATH:\$GOPATH/bin:/usr/local/go/bin&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>export PATH&lt;span style="color:#f92672">=&lt;/span>$PATH:/usr/local/go/bin
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>export GO111MODULE&lt;span style="color:#f92672">=&lt;/span>on
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>export GOPROXY&lt;span style="color:#f92672">=&lt;/span>https://goproxy.cn,https://goproxy.io,https://mirrors.aliyun.com/goproxy/,direct
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>export CGO_ENABLED&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">0&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>EOF
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>source /etc/profile.d/go.sh
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;blockquote>
&lt;p>CGO_ENABLED 开启后 Go 代码最终编译的可执行文件都是要有外部依赖的。不过我们依然可以通过 disable CGO_ENABLED 来编译出纯静态的 Go 程序，常用于交叉编译
CGO_ENABLED 关闭即可编译出纯静态的 Go 程序，可以用于 alpine 镜像中。&lt;/p>
&lt;/blockquote>
&lt;h2 id="windows-安装">Windows 安装&lt;/h2>
&lt;p>从&lt;a href="https://golang.org/dl/">官网&lt;/a>下载 Windows 版的 msi 安装包&lt;/p>
&lt;p>双击安装 Golang&lt;/p>
&lt;p>配置环境变量，执行命令&lt;/p>
&lt;ul>
&lt;li>go env -w GOPATH=D:\Tools\GoPath&lt;/li>
&lt;li>go env -w GOPROXY=https://goproxy.cn,https://goproxy.io,direct&lt;/li>
&lt;li>go env -w GO111MODULE=on&lt;/li>
&lt;/ul>
&lt;h2 id="安装多个版本的-go">安装多个版本的 Go&lt;/h2>
&lt;p>获取其余版本的 golang&lt;/p>
&lt;ul>
&lt;li>go install golang.org/dl/goX.XX.X@latest&lt;/li>
&lt;li>goX.XX.X download&lt;/li>
&lt;/ul>
&lt;p>新下载的 golang 版本可以像这样使用，在 go 后面加上版本号&lt;/p>
&lt;ul>
&lt;li>goX.XX.X version&lt;/li>
&lt;/ul>
&lt;p>通过 goX.XX.X env 命令查看该 go 版本的变量，可以看到，默认的 GOROOT 是在 ~/sdk/goX.XX.X 目录下的&lt;/p>
&lt;p>所以如果想要切换默认的 go 版本(比如某个程序调用 go 命令时)，只需要将环境变量 GOROOT 指向该目录即可，之后使用 go 命令即可为当前指定的版本&lt;/p>
&lt;h1 id="初始化项目">初始化项目&lt;/h1>
&lt;p>Go 的项目通常由 &lt;a href="https://www.typescriptlang.org/">Go Module&lt;/a> 管理，项目目录中通常必须包含如下几个文件：&lt;/p>
&lt;ul>
&lt;li>go.mod&lt;/li>
&lt;li>go.sum&lt;/li>
&lt;/ul>
&lt;p>go 相关工具通过 &lt;code>go.mod&lt;/code> 与 &lt;code>go.sum&lt;/code> 两个文件管理项目及其依赖&lt;/p>
&lt;p>使用 &lt;code>go mod init &amp;lt;NAME&amp;gt;&lt;/code> 命令在当前目录会创建一个 go.mod 文件。有任何新的 import，都可以通过 &lt;code>go mod tidy&lt;/code> 生成依赖文件再生成 &lt;code>go.sum&lt;/code> 文件。&lt;/p>
&lt;h1 id="编译-go">编译 Go&lt;/h1>
&lt;p>若想在 Windows 中编译依赖 gcc 的项目，则需要安装 gcc 编译器（i.e.&lt;a href="https://sourceforge.net/projects/mingw-w64/">MinGW-w64&lt;/a>）在 file 标签中，下载 &lt;a href="https://sourceforge.net/projects/mingw-w64/files/Toolchains%20targetting%20Win64/Personal%20Builds/mingw-builds/8.1.0/threads-win32/seh/x86_64-8.1.0-release-win32-seh-rt_v6-rev0.7z">x86_64-win32-seh&lt;/a> 这个版本并安装即可。这是一个 tar 包，解压完成后，需要在 Windows 的 ${PATH} 环境变量中，添加解压出来的 bin 目录，通常都在 &lt;code>PATH\TO\x86_64-8.1.0-release-win32-seh-rt_v6-rev0\mingw64\bin&lt;/code> 这里&lt;/p>
&lt;h2 id="交叉编译">交叉编译&lt;/h2>
&lt;p>Linux 下编译出 Windows 的程序。需要安装 Windows 版的 gcc 工具（i.e.&lt;a href="https://www.mingw-w64.org/">MinGW-w64&lt;/a>）(有的环境还需要安装 gcc-multilib 包)&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>sudo apt-get install gcc-mingw-w64
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>GOOS&lt;span style="color:#f92672">=&lt;/span>windows GOARCH&lt;span style="color:#f92672">=&lt;/span>amd64 CGO_ENABLED&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span> CC&lt;span style="color:#f92672">=&lt;/span>x86_64-w64-mingw32-gcc go build
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="在容器中编译">在容器中编译&lt;/h2>
&lt;h3 id="golang-镜像">golang 镜像&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>docker run -it -v /&lt;span style="color:#e6db74">${&lt;/span>YourPackageSrc&lt;span style="color:#e6db74">}&lt;/span>:/go/work &lt;span style="color:#ae81ff">\
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">&lt;/span> -w /go/work &lt;span style="color:#ae81ff">\
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">&lt;/span> golang:1.17 go build
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>多次使用&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>docker run -it --network host --name golang &lt;span style="color:#ae81ff">\
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">&lt;/span> -v /root/projects:/root/projects &lt;span style="color:#ae81ff">\
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">&lt;/span> -v /root/go:/go &lt;span style="color:#ae81ff">\
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">&lt;/span> golang:1.17 /bin/bash
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>一次性构建&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>docker run -it -v /root/projects/&lt;span style="color:#e6db74">${&lt;/span>Project&lt;span style="color:#e6db74">}&lt;/span>:/go/work &lt;span style="color:#ae81ff">\
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">&lt;/span> -w /go/work &lt;span style="color:#ae81ff">\
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">&lt;/span> golang:1.17 go build cmd/XX.go
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="go-mingw-镜像">go-mingw 镜像&lt;/h3>
&lt;p>镜像，用于使用基于官方 Go Docker 镜像的 MinGW-w64 工具链为 Windows 构建 Go 二进制文件。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>docker run --rm -it -v /&lt;span style="color:#e6db74">${&lt;/span>YourPackageSrc&lt;span style="color:#e6db74">}&lt;/span>:/go/work &lt;span style="color:#ae81ff">\
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">&lt;/span> -w /go/work &lt;span style="color:#ae81ff">\
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">&lt;/span> -e GOPROXY&lt;span style="color:#f92672">=&lt;/span>https://goproxy.cn,https://goproxy.io,direct
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> x1unix/go-mingw go build
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h1 id="go-关联文件与配置">Go 关联文件与配置&lt;/h1>
&lt;p>Go 程序的很多关联文件都可以通过 Go 环境变量进行配置，所以绝大部分关联文件都以变量的形式记录。
&lt;strong>$GOPATH&lt;/strong> # GOPATH 环境变量列出了寻找 Go 代码的位置。&lt;strong>同时也是存储 Go 模块的目录，即 go mod 相关命令保存数据的目录&lt;/strong>。&lt;/p>
&lt;ul>
&lt;li>&lt;strong>./pkg/mod/&lt;/strong> # 存储下载的源代码。&lt;/li>
&lt;li>&lt;strong>./bin/&lt;/strong> # 存储编译的命令。下载的依赖包中若包含二进制文件，也会保存在这个目录中&lt;/li>
&lt;/ul>
&lt;h2 id="go-环境变量">Go 环境变量&lt;/h2>
&lt;p>Go 通过环境变量来配置其运行行为，通过 go env 命令可以看到当前使用的环境变量：
&lt;strong>GO111MODULE=&amp;ldquo;on|off&amp;rdquo;&lt;/strong> # 设置是否使用 go mod，该环境变量将于 1.17 版本删除，并从此开始仅支持 go mod
GOARCH=&amp;ldquo;amd64&amp;rdquo;
GOBIN=&amp;quot;&amp;quot;
GOCACHE=&amp;quot;/root/.cache/go-build&amp;quot;
GOENV=&amp;quot;/root/.config/go/env&amp;quot;
GOEXE=&amp;quot;&amp;quot;
GOFLAGS=&amp;quot;&amp;quot;
GOHOSTARCH=&amp;ldquo;amd64&amp;rdquo;
GOHOSTOS=&amp;ldquo;linux&amp;rdquo;
GOINSECURE=&amp;quot;&amp;quot;
GOMODCACHE=&amp;quot;/root/go/pkg/mod&amp;quot;
GONOPROXY=&amp;quot;&amp;quot;
GONOSUMDB=&amp;quot;&amp;quot;
GOOS=&amp;ldquo;linux&amp;rdquo;
&lt;strong>GOPATH=&lt;!-- raw HTML omitted -->&lt;/strong> # 设置 gopath 所在路径。默认值：&lt;code>~/go&lt;/code>
GOPRIVATE=&amp;quot;&amp;quot;
**GOPROXY=&lt;!-- raw HTML omitted --> **# 设置 go get、go install 命令时，所使用的代理服务器。可以加快获取第三方库的速度。
&lt;strong>GOROOT=&lt;!-- raw HTML omitted -->&lt;/strong> # Go 的安装路径。默认值：Go 的安装路径，Linux 中通常为 /usr/local/go
GOSUMDB=&amp;ldquo;sum.golang.org&amp;rdquo;
GOTMPDIR=&amp;quot;&amp;quot;
GOTOOLDIR=&amp;quot;/usr/local/go/pkg/tool/linux_amd64&amp;quot;
GOVCS=&amp;quot;&amp;quot;
GOVERSION=&amp;ldquo;go1.16.4&amp;rdquo;
GCCGO=&amp;ldquo;gccgo&amp;rdquo;
AR=&amp;ldquo;ar&amp;rdquo;
CC=&amp;ldquo;gcc&amp;rdquo;
CXX=&amp;ldquo;g++&amp;rdquo;
&lt;strong>CGO_ENABLED=&amp;ldquo;0&amp;rdquo;&lt;/strong> # CGO_ENABLED 开启后 Go 代码最终编译的可执行文件都是要有外部依赖的。不过我们依然可以通过 disable CGO_ENABLED 来编译出纯静态的 Go 程序，常用于交叉编译。CGO_ENABLED 关闭即可编译出纯静态的 Go 程序，可以用于 alpine 镜像中。
GOMOD=&amp;quot;/dev/null&amp;quot;
CGO_CFLAGS=&amp;quot;-g -O2&amp;quot;
CGO_CPPFLAGS=&amp;quot;&amp;quot;
CGO_CXXFLAGS=&amp;quot;-g -O2&amp;quot;
CGO_FFLAGS=&amp;quot;-g -O2&amp;quot;
CGO_LDFLAGS=&amp;quot;-g -O2&amp;quot;
PKG_CONFIG=&amp;ldquo;pkg-config&amp;rdquo;
GOGCCFLAGS=&amp;quot;-fPIC -m64 -fmessage-length=0 -fdebug-prefix-map=/tmp/go-build1775394647=/tmp/go-build -gno-record-gcc-switches&amp;quot;&lt;/p>
&lt;h2 id="goproxy-说明">goproxy 说明&lt;/h2>
&lt;p>我把老哥的 Issue 转移到这里来了哈，这个项目才是 &lt;a href="https://goproxy.cn/">goproxy.cn&lt;/a> 的源代码。&lt;a href="https://github.com/goproxy/goproxy">Goproxy&lt;/a> 是这个项目所基于的底层 Go module proxy 实现，它针对的不只是国内的开发者，所以既不建议用中文也不适合讨论 &lt;a href="https://goproxy.cn/">goproxy.cn&lt;/a>。这里讨论老哥你的问题才更为合适。
我先说一下 &lt;a href="https://goproxy.cn/">goproxy.cn&lt;/a> 和 &lt;a href="https://goproxy.io/">goproxy.io&lt;/a> 的背景。io 是由坤哥（&lt;a href="https://github.com/oiooj">@oiooj&lt;/a>）开发出来的，要早于 cn 出现几个月，目前由他跑在他所任职的公司腾讯云的香港区服务器上。cn 是由我发起的，现在完全属于七牛云，也备案在他们名下，自然所有的 CDN 资源和服务器资源都是由他们提供的，我目前跟 cn 的关系是属于它的维护者，并不是拥有者。
再说一下为什么会有两个这么相似的域名且功能类似的项目存在。我注册 cn 是去年二月底，当时是直接查询的 cn 后缀，因为我想的是这种项目肯定也就咱们中国是刚需要单独再来一套，所以并没有查询别的后缀，因为我认为 cn 实在是太合适了。并且由于当时我还在忙我的本科毕设和其他的一下事情，二月份我并没有开始开发 cn，等开发完了跟七牛云的 CEO 许叔（&lt;a href="https://github.com/xushiwei">@xushiwei&lt;/a>）谈交给他们运营时候，我才第一次听同学说到了 io。但当时我点进 io 的 GitHub 仓库一看发现并没有任何地方提到中国并且全是英文就下意识以为它是个国外项目，就没做过多研究，并且的 io 服务器当时也在美国我访问速度有些慢，就也没在意了。
最后再说一下为什么两个项目没有合并了一起发展。这个我和坤哥是有讨论过的，因为有人找上了我跟坤哥。并且坤哥也同意了最后我的提议合并了两个项目，将 cn 留作国内的公共代理，将 io 的代理类流量重定向到 cn 并后续将 io 用作一款搭代理的开源软件来面向全球提供给大家替换掉 JFrog 的一款商业产品，目前只有这一种解决方案才能保持两个功能独立且都能继续存活下去。坤哥之所以能同意我的这个提议一方面是坤哥所任职的公司加班过于严重，还有一方面是他自身没有精力维护了。然后之所以选择留 cn 做公共代理一方面是这两个域名里面只有 cn 能做备案能挂上 CDN 服务，因为这种类型的项目 CDN 服务是刚需，还有一方面是 io 这个域名后缀做全球化项目比 cn 更为合适，所以留 io 作国内代理把 cn 用作面向全球的搭代理的软件就显得很别扭了。
为什么两个项目现在没有合并呢？这个就不是因为我们两个作者了，因为我们两个作者已经达成了一致可以合并。这里面还有第三方地插足（为保其名誉我暂时不提具体是谁），其认为公共代理必须交由其所掌控的“社区”来运营，cn 已经过户给了一家商业公司无法再过户给其所掌控的“社区”，所以 cn 在其眼里就变成了一个其所描述的邪恶公司所拥有的商业产品，于是其要求我和七牛商谈放弃 cn 并全力投入为其做别的开发，于是被我拒绝。最后坤哥在中间处境比较尴尬，所以合并的事儿也就暂时搁置了。
最后，简单来总结一下就是，&lt;a href="https://goproxy.cn/">goproxy.cn&lt;/a> 和 &lt;a href="https://goproxy.io/">goproxy.io&lt;/a> 目前并无直接关系。或许之后没有了第三方地插足它们两个会合并变得有关系，但在那之前它们唯一能联系在一起的是它们都可以用作为 Go module proxy。至于哪个快、哪个稳、哪个香、用哪个，这个需要老哥你自己做判断了，我跟坤哥的关系并不差，所以我现在不会妄加评论。更何况现在 &lt;code>GOPROXY&lt;/code> 不是支持逗号列表嘛。❤️&lt;/p>
&lt;h2 id="gopath">GOPATH&lt;/h2>
&lt;p>注意：以下对 GOPATH 的理解是在 golang1.13 版本之前&lt;/p>
&lt;p>GOPATH 就是 go 项目的工作目录，是开发人员写代码的目录。&lt;/p>
&lt;p>GOPATH 里面一般包含 bin、pkg、src 这 3 个文件夹。&lt;/p>
&lt;p>项目文件夹一般是放在 src 目录中&lt;/p>
&lt;p>一般情况下，如果自己在开发多个项目，那么最好一个项目对应一个 GOPATH 路径。这时候只需要切换 GOPATH 环境变量的值，就可以编译运行对应的项目了。(比如我有两个项目目录/root/cobra 和/root/bee，这俩目录可以分别作为 GOPATH 变量的值，想开发哪个，就把 GOPATH 变量的值改为对应的目录路径)&lt;/p>
&lt;p>这样做的目的主要是为了让每个项目所依赖的库等东西，可以分开而不会冲突&lt;/p>
&lt;p>现在有 go module 之后，就可以不用把项目放在 GOPATH 路径下了。具体 go module 的作用详见 1.4.Go module 的介绍及使用.1 新功能 module 的介绍及使用&lt;/p></description></item><item><title>Docs: Linux 管理</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/x.linux-%E7%AE%A1%E7%90%86/linux%E7%AE%A1%E7%90%86/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/x.linux-%E7%AE%A1%E7%90%86/linux%E7%AE%A1%E7%90%86/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://www.gnu.org/manual/">GNU Manual(手册)&lt;/a> — Linux 中很多核心程序，都是 GNU 组织下的软件。&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>系统管理员可以通过 一系列用户空间的二进制应用程序来管理 Linux 操作系统。Linux 内核自带了一个名为 coreutils 包，包含了很多最基本的管理工具。&lt;/p>
&lt;p>除了 Coreutils 包，还有很多很多的应用程序，一起组成了一套工具栈，系统管理员可以根据自身的需求，有选择得安装并使用它们。&lt;/p>
&lt;h1 id="coreutils">Coreutils&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/GNU_Core_Utilities">Wiki,GNU Core Utilies&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.gnu.org/software/coreutils/manual/">官方文档&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>GNU Core Utilities 是 GNU 操作系统的基本文件、Shell、文本操作的实用程序。同时，也是现在绝大部分 Linux 发行版内置的实用程序。&lt;/p>
&lt;p>Coreutils 通常可以通过各种 Linux 发行版的包管理器直接安装。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>root@lichenhao:~/downloads# apt-cache show coreutils
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Package: coreutils
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Architecture: amd64
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Version: 8.30-3ubuntu2
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Multi-Arch: foreign
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Priority: required
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Essential: yes
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Section: utils
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Origin: Ubuntu
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Maintainer: Ubuntu Developers &amp;lt;ubuntu-devel-discuss@lists.ubuntu.com&amp;gt;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Original-Maintainer: Michael Stone &amp;lt;mstone@debian.org&amp;gt;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Bugs: https://bugs.launchpad.net/ubuntu/+filebug
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Installed-Size: &lt;span style="color:#ae81ff">7196&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Pre-Depends: libacl1 &lt;span style="color:#f92672">(&lt;/span>&amp;gt;&lt;span style="color:#f92672">=&lt;/span> 2.2.23&lt;span style="color:#f92672">)&lt;/span>, libattr1 &lt;span style="color:#f92672">(&lt;/span>&amp;gt;&lt;span style="color:#f92672">=&lt;/span> 1:2.4.44&lt;span style="color:#f92672">)&lt;/span>, libc6 &lt;span style="color:#f92672">(&lt;/span>&amp;gt;&lt;span style="color:#f92672">=&lt;/span> 2.28&lt;span style="color:#f92672">)&lt;/span>, libselinux1 &lt;span style="color:#f92672">(&lt;/span>&amp;gt;&lt;span style="color:#f92672">=&lt;/span> 2.1.13&lt;span style="color:#f92672">)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Filename: pool/main/c/coreutils/coreutils_8.30-3ubuntu2_amd64.deb
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Size: &lt;span style="color:#ae81ff">1249368&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>MD5sum: e8e201b6d1b7f39776da07f6713e1675
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>SHA1: 1d4ab60c729a361d46a90d92defaca518b2918d2
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>SHA256: 99aa50af84de1737735f2f51e570d60f5842aa1d4a3129527906e7ffda368853
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Homepage: http://gnu.org/software/coreutils
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Description-en: GNU core utilities
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> This package contains the basic file, shell and text manipulation
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> utilities which are expected to exist on every operating system.
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Specifically, this package includes:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> arch base64 basename cat chcon chgrp chmod chown chroot cksum comm cp
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> csplit cut date dd df dir dircolors dirname du echo env expand expr
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> factor false flock fmt fold groups head hostid id install join link ln
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> logname ls md5sum mkdir mkfifo mknod mktemp mv nice nl nohup nproc numfmt
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> od paste pathchk pinky pr printenv printf ptx pwd readlink realpath rm
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> rmdir runcon sha*sum seq shred sleep sort split stat stty sum sync tac
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> tail tee test timeout touch tr true truncate tsort tty uname unexpand
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> uniq unlink users vdir wc who whoami yes
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Description-md5: d0d975dec3625409d24be1238cede238
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Task: minimal
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>这个包中，通常包含如下应用程序&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>arch base64 basename cat chcon chgrp chmod chown chroot cksum comm cp csplit cut date dd df dir dircolors dirname du echo env expand expr factor false flock fmt fold groups head hostid id install join link ln logname ls md5sum mkdir mkfifo mknod mktemp mv nice nl nohup nproc numfmt od paste pathchk pinky pr printenv printf ptx pwd readlink realpath rm rmdir runcon sha*sum seq shred sleep sort split stat stty sum sync tac tail tee test timeout touch tr true truncate tsort tty uname unexpand uniq unlink users vdir wc who whoami yes
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>可以发现，这些命令就是我们日常经常使用那些~&lt;/p>
&lt;h1 id="util-linux">Util-linux&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://github.com/util-linux/util-linux">GitHub 项目，util-linux/util-linux&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Util-linux">Wiki,Util-linux&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>util-linux 是由 Linux 内核组织分发的标准软件包，用作 Linux 操作系统的一部分。一个分支 util-linux-ng（ng 的意思是“下一代”）是在开发停滞时创建的，但截至 2011 年 1 月，它已重命名为 util-linux，并且是该软件包的正式版本。&lt;/p>
&lt;p>Util-linux 包中通常包含如下程序：&lt;/p>
&lt;ul>
&lt;li>addpart&lt;/li>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Getty_(Unix)">agetty&lt;/a>&lt;/li>
&lt;li>blkdiscard&lt;/li>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Blkid">blkid&lt;/a>&lt;/li>
&lt;li>blkzone&lt;/li>
&lt;li>&lt;a href="https://en.wikipedia.org/w/index.php?title=Blockdev&amp;amp;action=edit&amp;amp;redlink=1">blockdev&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Cal_(command)">cal&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Cfdisk">cfdisk&lt;/a>&lt;/li>
&lt;li>chcpu&lt;/li>
&lt;li>chfn&lt;/li>
&lt;li>chmem&lt;/li>
&lt;li>choom&lt;/li>
&lt;li>chrt&lt;/li>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Chsh">chsh&lt;/a>&lt;/li>
&lt;li>col (legacy)&lt;/li>
&lt;li>colcrt&lt;/li>
&lt;li>colrm&lt;/li>
&lt;li>column&lt;/li>
&lt;li>ctrlaltdel&lt;/li>
&lt;li>delpart&lt;/li>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Dmesg">dmesg&lt;/a>&lt;/li>
&lt;li>eject&lt;/li>
&lt;li>fallocate&lt;/li>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Fdformat">fdformat&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Fdisk">fdisk&lt;/a>&lt;/li>
&lt;li>fincore&lt;/li>
&lt;li>findfs&lt;/li>
&lt;li>findmnt&lt;/li>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/File_locking">flock&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Fsck">fsck&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Fsck">fsck&lt;/a>.&lt;a href="https://en.wikipedia.org/wiki/Cramfs">cramfs&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Fsck">fsck&lt;/a>.&lt;a href="https://en.wikipedia.org/wiki/MINIX_file_system">minix&lt;/a>&lt;/li>
&lt;li>fsfreeze&lt;/li>
&lt;li>fstrim&lt;/li>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Getopt">getopt&lt;/a>&lt;/li>
&lt;li>hardlink&lt;/li>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Hex_dump#od_and_hexdump">hexdump&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://en.wikipedia.org/w/index.php?title=Hwclock&amp;amp;action=edit&amp;amp;redlink=1">hwclock&lt;/a> (query and set the hardware clock (RTC))&lt;/li>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Ionice">ionice&lt;/a>&lt;/li>
&lt;li>ipcmk&lt;/li>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Ipcrm">ipcrm&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Ipcs">ipcs&lt;/a>&lt;/li>
&lt;li>irqtop&lt;/li>
&lt;li>isosize&lt;/li>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Kill_(Unix)">kill&lt;/a>&lt;/li>
&lt;li>last&lt;/li>
&lt;li>ldattach&lt;/li>
&lt;li>line (legacy)&lt;/li>
&lt;li>logger&lt;/li>
&lt;li>login&lt;/li>
&lt;li>look&lt;/li>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Losetup">losetup&lt;/a>&lt;/li>
&lt;li>lsblk&lt;/li>
&lt;li>lscpu&lt;a href="https://en.wikipedia.org/wiki/Util-linux#cite_note-8">[8]&lt;/a>&lt;/li>
&lt;li>lsfd&lt;/li>
&lt;li>lsipc&lt;/li>
&lt;li>lsirq&lt;a href="https://en.wikipedia.org/wiki/Util-linux#cite_note-9">[9]&lt;/a>&lt;/li>
&lt;li>lslocks&lt;/li>
&lt;li>lslogins&lt;/li>
&lt;li>lsmem&lt;/li>
&lt;li>lsns&lt;/li>
&lt;li>mcookie&lt;/li>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Mesg">mesg&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Mkfs">mkfs&lt;/a> (legacy)&lt;/li>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Mkfs">mkfs&lt;/a>.&lt;a href="https://en.wikipedia.org/wiki/Boot_File_System">bfs&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Mkfs">mkfs&lt;/a>.&lt;a href="https://en.wikipedia.org/wiki/Cramfs">cramfs&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Mkfs">mkfs&lt;/a>.&lt;a href="https://en.wikipedia.org/wiki/MINIX_file_system">minix&lt;/a>&lt;/li>
&lt;li>mkswap&lt;/li>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/More_(command)">more&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Mount_(Unix)">mount&lt;/a>&lt;/li>
&lt;li>mountpoint&lt;/li>
&lt;li>namei&lt;/li>
&lt;li>newgrp&lt;/li>
&lt;li>nologin&lt;/li>
&lt;li>nsenter&lt;/li>
&lt;li>partx&lt;/li>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Pg_(Unix)">pg&lt;/a> (legacy)&lt;/li>
&lt;li>pivot_root&lt;/li>
&lt;li>prlimit&lt;a href="https://en.wikipedia.org/wiki/Util-linux#cite_note-10">[10]&lt;/a>&lt;/li>
&lt;li>raw&lt;/li>
&lt;li>readprofile&lt;/li>
&lt;li>rename&lt;/li>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Nice_(Unix)">renice&lt;/a>&lt;/li>
&lt;li>reset (legacy)&lt;/li>
&lt;li>resizepart&lt;/li>
&lt;li>rev&lt;/li>
&lt;li>rfkill&lt;/li>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/RTC_Alarm">rtcwake&lt;/a>&lt;/li>
&lt;li>runuser&lt;/li>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Script_(Unix)">script&lt;/a>&lt;/li>
&lt;li>scriptlive&lt;/li>
&lt;li>scriptreplay&lt;/li>
&lt;li>setarch (including architecture symlinks such as i386, linux32, linux64, x86_64, etc.)&lt;/li>
&lt;li>setpriv&lt;/li>
&lt;li>setsid&lt;/li>
&lt;li>setterm&lt;/li>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Sfdisk">sfdisk&lt;/a>&lt;/li>
&lt;li>su&lt;/li>
&lt;li>sulogin&lt;/li>
&lt;li>swaplabel&lt;/li>
&lt;li>swapoff&lt;/li>
&lt;li>swapon&lt;/li>
&lt;li>switch_root&lt;/li>
&lt;li>taskset&lt;/li>
&lt;li>tunelp (deprecated)&lt;a href="https://en.wikipedia.org/wiki/Util-linux#cite_note-11">[11]&lt;/a>&lt;/li>
&lt;li>ul&lt;/li>
&lt;li>umount&lt;/li>
&lt;li>unshare&lt;/li>
&lt;li>utmpdump&lt;/li>
&lt;li>uuidd&lt;/li>
&lt;li>uuidgen&lt;/li>
&lt;li>uuidparse&lt;/li>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Vipw">vipw&lt;/a> (including symlink to vigr)&lt;/li>
&lt;li>wall&lt;/li>
&lt;li>wdctl&lt;/li>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Whereis">whereis&lt;/a>&lt;/li>
&lt;li>wipefs&lt;/li>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Write_(Unix)">write&lt;/a>&lt;/li>
&lt;li>zramctl&lt;/li>
&lt;/ul>
&lt;h3 id="removed">Removed&lt;/h3>
&lt;p>Utilities formerly included, but removed as of 1 July 2015:&lt;/p>
&lt;ul>
&lt;li>arch&lt;a href="https://en.wikipedia.org/wiki/Util-linux#cite_note-12">[12]&lt;/a>&lt;/li>
&lt;li>chkdupexe&lt;a href="https://en.wikipedia.org/wiki/Util-linux#cite_note-13">[13]&lt;/a>&lt;/li>
&lt;li>clock&lt;a href="https://en.wikipedia.org/wiki/Util-linux#cite_note-14">[14]&lt;/a>&lt;/li>
&lt;li>cytune&lt;a href="https://en.wikipedia.org/wiki/Util-linux#cite_note-15">[15]&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Ddate">ddate&lt;/a> (removed from default build&lt;a href="https://en.wikipedia.org/wiki/Util-linux#cite_note-16">[16]&lt;/a> before being removed&lt;a href="https://en.wikipedia.org/wiki/Util-linux#cite_note-17">[17]&lt;/a> altogether)&lt;/li>
&lt;li>elvtune&lt;a href="https://en.wikipedia.org/wiki/Util-linux#cite_note-18">[18]&lt;/a>&lt;/li>
&lt;li>fastboot&lt;a href="https://en.wikipedia.org/wiki/Util-linux#cite_note-simpleinit-19">[19]&lt;/a>&lt;/li>
&lt;li>fasthalt&lt;a href="https://en.wikipedia.org/wiki/Util-linux#cite_note-simpleinit-19">[19]&lt;/a>&lt;/li>
&lt;li>halt&lt;a href="https://en.wikipedia.org/wiki/Util-linux#cite_note-simpleinit-19">[19]&lt;/a>&lt;/li>
&lt;li>initctl&lt;a href="https://en.wikipedia.org/wiki/Util-linux#cite_note-simpleinit-19">[19]&lt;/a>&lt;/li>
&lt;li>ramsize (formerly a symlink to rdev)&lt;a href="https://en.wikipedia.org/wiki/Util-linux#cite_note-rdev-20">[20]&lt;/a>&lt;/li>
&lt;li>rdev&lt;a href="https://en.wikipedia.org/wiki/Util-linux#cite_note-rdev-20">[20]&lt;/a>&lt;/li>
&lt;li>reboot&lt;a href="https://en.wikipedia.org/wiki/Util-linux#cite_note-simpleinit-19">[19]&lt;/a>&lt;/li>
&lt;li>rootflags (formerly a symlink to rdev)&lt;a href="https://en.wikipedia.org/wiki/Util-linux#cite_note-rdev-20">[20]&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Shutdown_(command)">shutdown&lt;/a>&lt;a href="https://en.wikipedia.org/wiki/Util-linux#cite_note-simpleinit-19">[19]&lt;/a>&lt;/li>
&lt;li>simpleinit&lt;a href="https://en.wikipedia.org/wiki/Util-linux#cite_note-simpleinit-19">[19]&lt;/a>&lt;/li>
&lt;li>tailf&lt;a href="https://en.wikipedia.org/wiki/Util-linux#cite_note-tailf-21">[21]&lt;/a>&lt;/li>
&lt;li>vidmode (formerly a symlink to rdev)&lt;a href="https://en.wikipedia.org/wiki/Util-linux#cite_note-rdev-20">[20]&lt;/a>&lt;/li>
&lt;/ul></description></item><item><title>Docs: Linux 管理案例</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/x.linux-%E7%AE%A1%E7%90%86/linux-%E7%AE%A1%E7%90%86%E6%A1%88%E4%BE%8B/linux-%E7%AE%A1%E7%90%86%E6%A1%88%E4%BE%8B/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/x.linux-%E7%AE%A1%E7%90%86/linux-%E7%AE%A1%E7%90%86%E6%A1%88%E4%BE%8B/linux-%E7%AE%A1%E7%90%86%E6%A1%88%E4%BE%8B/</guid><description>
&lt;h1 id="重置-linux-的-root-密码">重置 Linux 的 root 密码&lt;/h1>
&lt;h2 id="进入紧急模式">进入紧急模式&lt;/h2>
&lt;p>详见《[Linux 的紧急模式或救援模式](/docs/IT学习笔记/1.操作系统/X.Linux%20 管理/性能优化%20 与%20 故障处理/Linux%20 的紧急模式或救援模式.md 与 故障处理/Linux 的紧急模式或救援模式.md)》&lt;/p>
&lt;h2 id="修改密码">修改密码&lt;/h2>
&lt;ul>
&lt;li>切换到原系统执行：&lt;code>chroot /sysroot/&lt;/code>&lt;/li>
&lt;li>更改 root 密码：&lt;code>passwd root&lt;/code>&lt;/li>
&lt;li>在/目录下创建一个.autorelabel 文件，而有这个文件存在，系统在重启时就会对整个文件系统进行 relabeling
&lt;ul>
&lt;li>&lt;code>touch /.autorelabel&lt;/code>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;code>exit&lt;/code>&lt;/li>
&lt;li>&lt;code>reboot&lt;/code>&lt;/li>
&lt;/ul>
&lt;h1 id="修改网卡名">修改网卡名&lt;/h1>
&lt;p>centos 系统&lt;/p>
&lt;ul>
&lt;li>vi /etc/default/grub
&lt;ul>
&lt;li>GRUB_CMDLINE_LINUX=&amp;ldquo;net.ifnames=0 biosdevname=0 crashkernel=auto rd.lvm.lv=myvg/root rd.lvm.lv=myvg/swap rhgb quiet&amp;rdquo;&lt;/li>
&lt;li>注意，标红位置改为自己的 lvm 中 volume group 的名字&lt;/li>
&lt;li>主要就是添加紫色内容的字符串&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>grub2-mkconfig -o /boot/grub2/grub.cfg&lt;/li>
&lt;li>mv /etc/sysconfig/network-scripts/ifcfg-ens33 /etc/sysconfig/network-scripts/ifcfg-eth0&lt;/li>
&lt;li>sed -i &amp;ldquo;s/ens33/eth0/g&amp;rdquo; /etc/sysconfig/network-scripts/ifcfg-eth0&lt;/li>
&lt;/ul>
&lt;p>ubuntu 系统&lt;/p>
&lt;ul>
&lt;li>修改 grub 文件
&lt;ul>
&lt;li>vim /etc/default/grub&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>查找
&lt;ul>
&lt;li>GRUB_CMDLINE_LINUX=&amp;quot;&amp;quot;&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>修改为
&lt;ul>
&lt;li>GRUB_CMDLINE_LINUX=&amp;ldquo;net.ifnames=0 biosdevname=0&amp;rdquo;&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>重新生成 grub 引导配置文件
&lt;ul>
&lt;li>grub-mkconfig -o /boot/grub/grub.cfg&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>修改网络配置 ens32 为 eth0
&lt;ul>
&lt;li>vim /etc/netplan/01-netcfg.yaml&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/gvagsg/1616163849544-f4eac668-9a60-40ef-b291-c28f82e1e661.jpeg" alt="">&lt;/p></description></item><item><title>Docs: Microsoft Management Console</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/y.windows-%E7%AE%A1%E7%90%86/microsoft_management_console/microsoft_management_console/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/y.windows-%E7%AE%A1%E7%90%86/microsoft_management_console/microsoft_management_console/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Microsoft_Management_Console">Wiki，Microsoft Management Console&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>&lt;strong>Microsoft Management Console(微软管理控制台，简称 MMC)&lt;/strong> 是 Microsoft Windows 的一个组件，它为系统管理员和高级用户提供了一个用于配置和监控系统的界面。它于 1998 年首次与 Windows NT 4.0 的 Option Pack 一起推出，后来与 Windows 2000 及其后续版本预捆绑在一起。&lt;/p>
&lt;h1 id="msc">msc&lt;/h1>
&lt;p>MSC(Microsoft Snap-In Control)文件，是&lt;a href="https://baike.baidu.com/item/%E5%BE%AE%E8%BD%AF%E7%AE%A1%E7%90%86%E6%8E%A7%E5%88%B6%E5%8F%B0/267174?fromModule=lemma_inlink">微软管理控制台&lt;/a>MMC(Microsoft Management Console)用来添加/删除的嵌入式管理单元文件。通常通过MMC来管理，可点击“文件”菜单中的“添加/删除管理单元”操作来管理当前系统中已经安装的MSC文件。可以点击开始/运行，然后输入下列文件名就可以打开相应的控制窗口。&lt;/p></description></item><item><title>Docs: Netfilter 流量控制系统</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2.kernel%E5%86%85%E6%A0%B8/8.network-%E7%AE%A1%E7%90%86/linux-%E7%BD%91%E7%BB%9C%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6/netfilter-%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6%E7%B3%BB%E7%BB%9F/netfilter-%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6%E7%B3%BB%E7%BB%9F/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2.kernel%E5%86%85%E6%A0%B8/8.network-%E7%AE%A1%E7%90%86/linux-%E7%BD%91%E7%BB%9C%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6/netfilter-%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6%E7%B3%BB%E7%BB%9F/netfilter-%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6%E7%B3%BB%E7%BB%9F/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://www.netfilter.org/index.html">Netfilter 官网&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.netfilter.org/documentation/index.html">Netfilter 官方文档&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Netfilter">Wiki-Netfilter&lt;/a>&lt;/li>
&lt;li>&lt;a href="http://arthurchiao.art/index.html">arthurchiao.art 的文章&lt;/a>：
&lt;ul>
&lt;li>&lt;a href="http://arthurchiao.art/blog/deep-dive-into-iptables-and-netfilter-arch-zh/">[译] 深入理解 iptables 和 netfilter 架构&lt;/a>&lt;/li>
&lt;li>&lt;a href="http://arthurchiao.art/blog/conntrack-design-and-implementation-zh/">连接跟踪（conntrack）：原理、应用及 Linux 内核实现&lt;/a>&lt;/li>
&lt;li>&lt;a href="http://arthurchiao.art/blog/nat-zh/">[译] NAT - 网络地址转换（2016）&lt;/a>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;h2 id="netfilter">Netfilter&lt;/h2>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/gral7u/1616165512374-db897dd5-0704-42f2-a1d8-441af05f247c.jpeg" alt="">&lt;/p>
&lt;p>Netfilter 是 Linux 操作系统核心层内部的一个数据包处理模块集合的统称。一种网络筛选系统，对数据包进入以及出去本机进行的一些控制与管理。该功能的所有模块可以通过下图所示的目录进行查找，其中还包括 ipvs 等。
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/gral7u/1616165512330-720231f3-a4f2-4a51-96cf-137a36724b74.jpeg" alt="">
Netfilter 项目支持如下功能&lt;/p>
&lt;ul>
&lt;li>网络地址转换(Network Address Translate)&lt;/li>
&lt;li>数据包过滤&lt;/li>
&lt;li>数据包日志记录&lt;/li>
&lt;li>用户空间数据包队列&lt;/li>
&lt;li>其他数据包处理&lt;/li>
&lt;li>等等&lt;/li>
&lt;/ul>
&lt;p>Netfilter Hooks 是 Linux 内核中的一个框架，它会让 Netfilter 的模块在 Linux 网络堆栈的不同位置注册回调函数。然后，为遍历 Linux 网络堆栈中相应 Hook 的每个数据包调用已注册的回调函数。&lt;/p>
&lt;ul>
&lt;li>用白话说：内核加入了 Netfilter 模块后，每个数据包进来之后，都会经过五个 Hooks 点来处理，以便决定每个数据包的走向。&lt;/li>
&lt;/ul>
&lt;h2 id="hooks">Hooks&lt;/h2>
&lt;p>hooks function(钩子函数) 是 Linux 网络栈中的流量检查点。所有流量通过网卡进入内核或从内核出去都会调用 Hook 函数来进行检查，并根据其规则进行过滤。Netfilter 框架中一共有 5 个 Hook，就是下文定义的“五链”。&lt;/p>
&lt;ul>
&lt;li>当一个数据包在其中一个 Hooks 中匹配到自己的规则后，则会进入下一个 Hook 寻找匹配自身的规则，直到将 5 个 Hook 挨个匹配一遍。&lt;/li>
&lt;li>可以把 Hook 想象成地铁站的闸机，通过闸机的人，就是数据流量，这个能不能从闸机过去，则看闸机对这个人身份验证的结果，是放行还是阻止&lt;/li>
&lt;/ul>
&lt;h2 id="iptabelesnftables">iptabeles/nftables&lt;/h2>
&lt;p>工作于用户空间的管理工具，对 5 个 hook 进行规则管理，iptabels 或 nftables 进程，开机后，只是把设定好的规则写进 hook 中&lt;/p>
&lt;p>Netfilter 所设置的规则是存放在内核内存中的，Iptables 是一个应用层(Ring3)的应用程序，它通过 Netfilter 放出的接口来对存放在内核内存中的 Xtables(Netfilter 的配置表)进行修改(这是一个典型的 Ring3 和 Ring0 配合的架构)&lt;/p>
&lt;h1 id="五链chain">五链(Chain)&lt;/h1>
&lt;p>把每个 Hook 上的规则都串起来类似于一条链子，所以称为链，一共 5 个 Hook，所以有 5 个 Chain。每个规则都是由“源 IP、目标 IP、端口、目标”等信息组合起来的。(i.e 对从哪来的或者到哪去的 IP 的哪个端口，要执行什么动作或‘引用什么 Chain 来对这个数据包执行什么动作’)&lt;/p>
&lt;ol>
&lt;li>&lt;strong>PREROUTING 链&lt;/strong> # 路由前，处理刚到达本机并在路由转发前的数据包。它会转换数据包中的目标 IP 地址（destination ip address），通常用于 DNAT(destination NAT)。处理完成之后分成两种情况，目的 IP 为本机网口则 INPUT，目的 IP 非本机网口则 FORWARD&lt;/li>
&lt;li>&lt;strong>INPUT 链&lt;/strong> # 进入，处理来自外部的数据。&lt;/li>
&lt;li>&lt;strong>FORWARD 链&lt;/strong> # 转发，将数据转发到本机的其他网络设备上。(需要开启 linux 的 IP 转发功能 net.ipv4.ip_forward=1 才会进入该流程；就算 ping 的是本机的其余网络设备上的 IP，也是由接收该数据包的网络设备进行回应)，FORWARD 的行为类似于路由器，系统中每个网络设备就是路由器上的每个端口，只有打开转发功能，才可以把数据包路由到其余端口上。
&lt;ol>
&lt;li>虚拟化或容器技术中，如果一台设备中有多个网段，一般都会打开转发功能，以实现不同网段路由互通的效果。&lt;/li>
&lt;li>或者服务器作为 VPN 使用时，由于不同网络设备所属网段不同，也需要打开转发功能。&lt;/li>
&lt;li>等等&lt;/li>
&lt;/ol>
&lt;/li>
&lt;li>**OUTPUT 链 **# 出去，处理向外发送的数据。&lt;/li>
&lt;li>**POSTROUTING 链 **# 路由后，处理即将离开本机的数据包。它会转换数据包中的源 IP 地址（source ip address），通常用于 SNAT（source NAT）。(该路由是通过 Linux 中定义的 route 规则发送的，与内核的 ip_forward 无关)&lt;/li>
&lt;li>**自定义链 **# 用户自己定义的链，不会调用系统 Hook，而是由系统默认的 5 个链在 target 中定义引用&lt;/li>
&lt;/ol>
&lt;h2 id="规则rule匹配match规则的匹配条件匹配的用法详见iptables-框架工具介绍">规则(Rule)匹配(Match)：(规则的匹配条件)匹配的用法详见：iptables 框架工具介绍&lt;/h2>
&lt;p>规则，需要有具体的内容才能称为规则，所以 Match 就是规则中的具体内容。&lt;/p>
&lt;p>每条链上的规则，需要对流量进行匹配后才能对该流量进行相应的处理，匹配内容包括“数据包的源地址、目标地址、协议、目标等”，(e.g.这个数据使用哪个协议从哪来的到哪去的目标是什么)
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/gral7u/1616165512349-f2e6f4c5-d617-4b04-a432-f9a7389120df.jpeg" alt="">
Match 功能的实现依赖于模块(类似于内核的模块)，比如右图，可以使用命令 rpm -ql iptables | grep &amp;ldquo;.so&amp;quot;查看都有哪些模块，其中的 XXX.so 就是各个功能的模块，大写字母是 target 所用的模块，小写字母是基本匹配与扩展匹配所用的模块&lt;/p>
&lt;ol>
&lt;li>基本匹配：源地址、目标地址、协议、入流网卡、出流网卡&lt;/li>
&lt;li>扩展匹配：用于对基本匹配的内容扩充，包括两类，普通的扩展匹配和基于
&lt;ol>
&lt;li>通用扩展匹配，可以直接使用。&lt;/li>
&lt;li>基于基本匹配的扩展匹配。需要有基本匹配规则才可以使用。
&lt;ol>
&lt;li>e.g.需要匹配某些端口，这类匹配必须基于 tcp 匹配规则上使用，否则无效(e.g.-p tcp -m tcp -m multiport &amp;ndash;dport22,23,24)&lt;/li>
&lt;/ol>
&lt;/li>
&lt;/ol>
&lt;/li>
&lt;li>目标(target)：每个规则中的目标。即在每条链上对每个进出流量匹配上之后应该执行什么动作，Target 包括以下几种
&lt;ol>
&lt;li>ACCEPT #允许流量通过&lt;/li>
&lt;li>REJECT #拒绝流量通过&lt;/li>
&lt;li>DROP #丢弃，不响应，发送方无法判断是被拒绝&lt;/li>
&lt;li>RETURN #返回调用链&lt;/li>
&lt;li>MARK #做防火墙标记&lt;/li>
&lt;li>用于 nat 表的 target
&lt;ol>
&lt;li>DNAT|SNAT #{目的|源}地址转换&lt;/li>
&lt;li>REDIRECT #端口重定向&lt;/li>
&lt;li>MASQUERADE #地址伪装类似于 SNAT，但是不用指明要转换的地址，而是自动选择要转换的地址，用于外部地址不固定的情况&lt;/li>
&lt;/ol>
&lt;/li>
&lt;li>用于 raw 表的 target
&lt;ol>
&lt;li>NOTRACK #raw 表专用的 target，用于对匹配规则进行 notrack(不跟踪)处理&lt;/li>
&lt;/ol>
&lt;/li>
&lt;li>LOG #将数据包的相关信息记录日志，执行完该目标后，会继续匹配后面的规则&lt;/li>
&lt;li>引用自定义链 #直接使用“-j 自定义链的名称”即可，让基本 5 个 Chain 上匹配成功的数据包继续执行自定义链上的规则。&lt;/li>
&lt;/ol>
&lt;/li>
&lt;/ol>
&lt;p>注意，这里面的路由指数据包在 Linux 本机内部路由&lt;/p>
&lt;h2 id="linux-数据包路由原理iptablesnetfilter-入门学习">Linux 数据包路由原理、Iptables/netfilter 入门学习&lt;/h2>
&lt;p>数据流处理流程简介&lt;/p>
&lt;p>注意：每个数据包在 CHAIN 中匹配到适用于自己的规则之后，则直接进入下一个 CHAIN，而不会遍历 CHAIN 中每条规则去挨个匹配适用于自己的规则。比如下面两种情况&lt;/p>
&lt;p>INPUT 链默认 DROP，匹配第一条：目的端口是 9090 的数据 DROP，然后不再检查下一项，那么 9090 无法访问&lt;/p>
&lt;pre>&lt;code>-P INPUT DROP
-A INPUT -p tcp -m tcp --dport 9090 -j DROP
-A INPUT -p tcp -m tcp --dport 9090 -j ACCEPT
&lt;/code>&lt;/pre>
&lt;p>INPUT 链默认 DROP，匹配第一条目的端口是 9090 的数据 ACCEPT，然后不再检查下一条规则，则 9090 可以访问&lt;/p>
&lt;pre>&lt;code>-P INPUT DROP
-A INPUT -p tcp -m tcp --dport 9090 -j ACCEPT
-A INPUT -p tcp -m tcp --dport 9090 -j DROP
&lt;/code>&lt;/pre>
&lt;p>匹配条件：根据协议报文特征指定&lt;/p>
&lt;ol>
&lt;li>基本匹配条件&lt;/li>
&lt;li>扩展匹配条件&lt;/li>
&lt;/ol>
&lt;p>处理动作：&lt;/p>
&lt;ol>
&lt;li>内建处理机制&lt;/li>
&lt;li>自定义处理机制&lt;/li>
&lt;li>注意：自定义的链不会有流量经过，而是在主要的 5 链中引用自定义链上的规则，来实现对流量的处理&lt;/li>
&lt;/ol>
&lt;p>下图是从服务器外部进入网卡，再进入网络栈的数据流走向，如果直接是服务器内部服务生成的数据包进入网络栈，则不适用于该图
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/gral7u/1616165512341-aeeeff06-b602-4340-bc4f-cd582144f85f.jpeg" alt="">&lt;/p>
&lt;ol>
&lt;li>当一个数据包进入网卡时，数据包首先进入 PREROUTING 链，在 PREROUTING 链中我们有机会修改数据包的 DestIP(目的 IP)，然后内核的&amp;quot;路由模块&amp;quot;根据&amp;quot;数据包目的 IP&amp;quot;以及&amp;quot;内核中的路由表&amp;quot;判断是否需要转送出去(注意，这个时候数据包的 DestIP 有可能已经被我们修改过了)&lt;/li>
&lt;li>如果数据包就是进入本机的(即数据包的目的 IP 是本机的网口 IP)，数据包就会沿着图向下移动，到达 INPUT 链。数据包到达 INPUT 链后，任何进程都会收到它&lt;/li>
&lt;li>本机上运行的程序也可以发送数据包，这些数据包经过 OUTPUT 链，然后到达 POSTROTING 链输出(注意，这个时候数据包的 SrcIP 有可能已经被我们修改过了)&lt;/li>
&lt;li>如果数据包是要转发出去的(即目的 IP 地址不再当前子网中)，且内核允许转发，数据包就会向右移动，经过 FORWARD 链，然后到达 POSTROUTING 链输出(选择对应子网的网口发送出去)&lt;/li>
&lt;/ol>
&lt;p>出于安全考虑，Linux 系统默认是禁止数据包转发的。所谓转发即当主机拥有多于一块的网卡时，其中一块收到数据包，根据数据包的目的 ip 地址将包发往本机另一网卡，该网卡根据路由表继续发送数据包。这通常就是路由器所要实现的功能。&lt;/p>
&lt;p>配置 Linux 系统的 ip 转发功能，首先保证硬件连通，然后打开系统的转发功能，less /proc/sys/net/ipv4/ip_forward，该文件内容为 0，表示禁止数据包转发，1 表示允许，将其修改为 1。可使用命令 echo &amp;ldquo;1&amp;rdquo; &amp;gt; /proc/sys/net/ipv4/ip_forward 修改文件内容，重启网络服务或主机后效果不再。若要其自动执行，可将命令 echo &amp;ldquo;1&amp;rdquo; &amp;gt; /proc/sys/net/ipv4/ip_forward 写入脚本/etc/rc.d/rc.local 或者 在/etc/sysconfig/network 脚本中添加 FORWARD_IPV4=&amp;ldquo;YES&amp;rdquo;&lt;/p>
&lt;h1 id="natnetwork-address-translation网络地址转换">NAT(Network Address Translation)网络地址转换&lt;/h1>
&lt;p>NAT 为了安全性而产生的，主要用来隐藏本地主机的 IP 地址&lt;/p>
&lt;h2 id="snatsource-源地址转换针对请求报文的源地址而言">SNAT：Source 源地址转换，针对请求报文的源地址而言&lt;/h2>
&lt;p>当想访问外网的时候，把源地址转换，作用于 POSTROUTING 链&lt;/p>
&lt;p>常用于内网私网地址转换成公网地址，比如家用路由器&lt;/p>
&lt;h2 id="dnatdestination-目的地址转换针对请求报文的目标地址而言">DNAT：Destination 目的地址转换，针对请求报文的目标地址而言&lt;/h2>
&lt;p>当从外部访问某 IP 时，把目的 IP 转换，作用于 PREROUTING、FORWARD 链&lt;/p>
&lt;p>把内网中的服务器发布到外网中去，&lt;/p>
&lt;p>常用于公网访问一个公司的公网 IP，但是由私网 IP 来提供服务，比如 LVS 的 nat 模型&lt;/p>
&lt;p>比如在公司内网中提供一个 web 服务，但是由于是私网地址，来自互联网的任何请求无法送达这台 web 服务器，这时候我们可以对外宣称公司的 web 服务在一个公网的 IP 地址上，但是公网的 IP 地址所在服务器上又没有提供 web 服务，这时候，来自外网访问的请求，全部 DNAT 成私网 IP，即可对外提供请求。&lt;/p>
&lt;h2 id="注意">注意：&lt;/h2>
&lt;p>由于 SNAT 与 DNAT 在描述的时候主要是都是针对请求报文而言的，那么当地址转换以后，响应报文响应的是转换后的地址，这时候就无法把响应请求送还给发起请求的设备了，这怎么办呢？这时候，同样需要一个地址转换，只不过通过 NAT 机制自行完成的，如何自动完成呢？这里面会有一个连接追踪机制，跟踪每一个数据连接（详见：&lt;a href="https://www.yuque.com/go/doc/33221811">ConnTrack 连接跟踪机制&lt;/a>），当响应报文到来的时候，根据连接追踪表中的信息记录的请求报文是怎么转换的相关信息，来对响应报文进行 NAT 转换。&lt;/p></description></item><item><title>Docs: PowerShell</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/4.terminal-%E4%B8%8E-shell/windows_shell/powershell/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/4.terminal-%E4%B8%8E-shell/windows_shell/powershell/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://learn.microsoft.com/en-us/powershell">官方文档，PowerShell&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>PowerShell 是一种跨平台的任务自动化解决方案，由命令行 shell、脚本语言和配置管理框架组成。 PowerShell 在 Windows、Linux 和 macOS 上运行。&lt;/p>
&lt;p>PowerShell 的独特之处在于，它接受并返回 .NET 对象，而非纯文本。这个特点让 PowerShell 可以更轻松地在一个管道中串联不通的命令。&lt;/p>
&lt;blockquote>
&lt;p>这里面所说的对象，就是面向对象编程中常说的“对象”，就像 Go 语言中的 Struct 类似的东西，只不过是 .NET 语言中的对象。&lt;/p>
&lt;/blockquote>
&lt;p>这些对象在被接收后，再交给格式化函数处理，以人类可读的方式，输出出来。&lt;/p>
&lt;h2 id="powershell-命令">PowerShell 命令&lt;/h2>
&lt;p>PowerShell 中可以执行的命令分两类&lt;/p>
&lt;ul>
&lt;li>系统上的可执行命令。&lt;/li>
&lt;li>cmdlet&lt;/li>
&lt;/ul>
&lt;p>PowerShell 内置了一组 &lt;strong>cmdlet(全称 command-lets)&lt;/strong>，cmdlet 并不是一个独立的可执行文件，而是一种统称，cmdlet 被收集在 PowerShell 模块中，可以按需加载它们。可以用任何编译的 .NET 语言或 PowerShell 脚本语言来编写 cmdlet。&lt;/p>
&lt;p>cmdlet 中每个命令的名称都是由 &lt;strong>Verb-Noun(动词-名词)&lt;/strong> 组成，比如 Get-Command 命令用于获取在 CLI 中注册的所有 cmdlet。&lt;/p>
&lt;p>我们可以通过如下几个命令来搜索可用的 cmdlet&lt;/p>
&lt;ul>
&lt;li>&lt;code>Get-Verb&lt;/code> # 获取所有可用的动词&lt;/li>
&lt;li>&lt;code>Get-Command&lt;/code> # 此命令会检索计算机上安装的所有命令的列表。&lt;/li>
&lt;li>&lt;code>Get-Member&lt;/code> # 基于其他命令运行，可以获取 cmdlet 返回的对象信息，包括对象中的&lt;strong>属性、方法、等等&lt;/strong>&lt;/li>
&lt;li>&lt;code>Get-Help&lt;/code> # 以命令名称为参数调用此命令，将显示一个帮助页面，其中说明了命令的各个部分。&lt;/li>
&lt;/ul>
&lt;p>从本笔记的 &lt;a href="https://desistdaydream.github.io/docs/IT%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Y.Windows%20%E7%AE%A1%E7%90%86/Windows%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/_index.md">Windows 管理工具&lt;/a> 目录查找所有可用的命令，以及查看命令的用法&lt;/p>
&lt;p>我们可以通过 &lt;code>$psversiontable&lt;/code> 和 &lt;code>$host&lt;/code> 变量查看 PowerShell 版本信息&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-powershell" data-lang="powershell">&lt;span style="display:flex;">&lt;span>PS C:\&amp;gt; $psversiontable
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Name Value
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>---- -----
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>PSVersion &lt;span style="color:#ae81ff">7.3&lt;/span>.2
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>PSEdition Core
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>GitCommitId &lt;span style="color:#ae81ff">7.3&lt;/span>.2
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>OS Microsoft Windows &lt;span style="color:#ae81ff">10.0&lt;/span>.19045
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Platform Win32NT
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>PSCompatibleVersions {&lt;span style="color:#ae81ff">1.0&lt;/span>, &lt;span style="color:#ae81ff">2.0&lt;/span>, &lt;span style="color:#ae81ff">3.0&lt;/span>, &lt;span style="color:#ae81ff">4.0&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">…&lt;/span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>PSRemotingProtocolVersion &lt;span style="color:#ae81ff">2.3&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>SerializationVersion &lt;span style="color:#ae81ff">1.1&lt;/span>.0.1
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>WSManStackVersion &lt;span style="color:#ae81ff">3.0&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>PS C:\&amp;gt; $host
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Name &lt;span style="color:#960050;background-color:#1e0010">:&lt;/span> ConsoleHost
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Version &lt;span style="color:#960050;background-color:#1e0010">:&lt;/span> &lt;span style="color:#ae81ff">7.3&lt;/span>.2
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>InstanceId &lt;span style="color:#960050;background-color:#1e0010">:&lt;/span> 518ca4c4-e959-4d51-b3bb-cdcb3d5a1484
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>UI &lt;span style="color:#960050;background-color:#1e0010">:&lt;/span> System.Management.Automation.Internal.Host.InternalHostUserInterface
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>CurrentCulture &lt;span style="color:#960050;background-color:#1e0010">:&lt;/span> zh-CN
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>CurrentUICulture &lt;span style="color:#960050;background-color:#1e0010">:&lt;/span> zh-CN
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>PrivateData &lt;span style="color:#960050;background-color:#1e0010">:&lt;/span> Microsoft.PowerShell.ConsoleHost+ConsoleColorProxy
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>DebuggerEnabled &lt;span style="color:#960050;background-color:#1e0010">:&lt;/span> True
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>IsRunspacePushed &lt;span style="color:#960050;background-color:#1e0010">:&lt;/span> False
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Runspace &lt;span style="color:#960050;background-color:#1e0010">:&lt;/span> System.Management.Automation.Runspaces.LocalRunspace
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h1 id="安装与更新">安装与更新&lt;/h1>
&lt;h1 id="使用-powershell">使用 PowerShell&lt;/h1>
&lt;p>&lt;code>powershell&lt;/code> 和 &lt;code>pwsh&lt;/code> 这几个命令一般都是用来打开 PowerShell 的，同时也是执行 PowerShell 脚本的前置命令。就像执行 Bash 脚本前加个 &lt;code>bash&lt;/code> 命令一样&lt;/p>
&lt;h1 id="item">ITEM&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://learn.microsoft.com/en-us/powershell/scripting/lang-spec/chapter-03#33-items">官方文档-PowerShell，脚本-基本概念-Items&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>PowerShell 中会抽象出一个 &lt;strong>Item(项)&lt;/strong> 的概念，Item 可以一个 &lt;strong>Alias(别名)&lt;/strong>、&lt;strong>Variable(变量)&lt;/strong>、&lt;strong>Function(函数)&lt;/strong>、&lt;strong>EnvironmentVariable(环境变量)&lt;/strong>、甚至可以是文件系统中的 &lt;strong>File(文件)&lt;/strong> 或者 &lt;strong>Directory(目录)&lt;/strong>。&lt;/p>
&lt;p>我们常用的 &lt;code>ls&lt;/code> 命令，在 PowerShell 中其实就是调用了 &lt;code>Get-ChildItem&lt;/code> 命令&lt;/p>
&lt;h1 id="porviders提供器-和-drives驱动器">Porviders(提供器) 和 Drives(驱动器)&lt;/h1>
&lt;p>在 PowerShell 中，Providers 和 Drives 是提供对不同数据源（如文件系统、注册表、Certificate 等）的访问的特定接口。Drives 则是实际代表特定数据源的容器，比如本地磁盘驱动器、注册表驱动器等。使用 PowerShell 可以对这些数据源进行管理和操作。&lt;/p></description></item><item><title>Docs: Prometheus</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/6.%E5%8F%AF%E8%A7%82%E6%B5%8B%E6%80%A7/%E7%9B%91%E6%8E%A7%E7%B3%BB%E7%BB%9F/prometheus/prometheus-%E8%A1%8D%E7%94%9F%E5%93%81/prometheus-operator/cr-%E8%AF%A6%E8%A7%A3/prometheus/prometheus/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/6.%E5%8F%AF%E8%A7%82%E6%B5%8B%E6%80%A7/%E7%9B%91%E6%8E%A7%E7%B3%BB%E7%BB%9F/prometheus/prometheus-%E8%A1%8D%E7%94%9F%E5%93%81/prometheus-operator/cr-%E8%AF%A6%E8%A7%A3/prometheus/prometheus/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;p>参考 &lt;a href="https://desistdaydream.github.io/docs/IT%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/6.%E5%8F%AF%E8%A7%82%E6%B5%8B%E6%80%A7/%E7%9B%91%E6%8E%A7%E7%B3%BB%E7%BB%9F/Prometheus/Prometheus.md">Prometheus&lt;/a> 文中关于 Prometheus Server 的部署我们发现，手动来维护 Prometheus Server 是相当费力的，而在 kubernetes 中，可以借助 operater 帮助我们来完成 Prometheus Server 的创建与维护工作，甚至连自动发现配置都可以。&lt;/p>
&lt;h1 id="prometheus-crd-部署">Prometheus CRD 部署&lt;/h1>
&lt;p>当在 k8s 中部署了 operator 之后，部署 Prometheus Server 就变成了声明一个 Prometheus 资源。&lt;/p>
&lt;p>这是声明一个 Prometheus 类型的资源的 manifest 示例：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-yaml" data-lang="yaml">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">apiVersion&lt;/span>: &lt;span style="color:#ae81ff">monitoring.coreos.com/v1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">kind&lt;/span>: &lt;span style="color:#ae81ff">Prometheus&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">metadata&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">name&lt;/span>: &lt;span style="color:#ae81ff">test&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">namespace&lt;/span>: &lt;span style="color:#ae81ff">monitor&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">spec&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">replicas&lt;/span>: &lt;span style="color:#ae81ff">1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">serviceAccountName&lt;/span>: &lt;span style="color:#ae81ff">prometheus&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>注意：&lt;/p>
&lt;ul>
&lt;li>由于 Prometheus Server 容器需要读取集群内其他资源对象的数据，所以需要给 Prometheus 资源生成的 Pod 一个足够权限的 serviceAccount。&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>kubectl create -n monitor serviceaccount prometheus
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>kubectl create clusterrolebinding prometheus-admin --clusterrole&lt;span style="color:#f92672">=&lt;/span>cluster-admin --serviceaccount&lt;span style="color:#f92672">=&lt;/span>monitor:prometheus
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>声明好 Prometheus 资源，则会看到一个名为 test 的 Prometheus 对象；该对象会自动帮助我们创建一个名为 prometheus-test 的 Statefulsets 对象；这个 Statefulsets 中的 pod 包括 2 个容器，1 个 Prometheus Server 容器，和 1 个 sidecar container；还会有一个 service 来关联到这些 pod 上&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">[&lt;/span>root@master-1 prometheus-operator&lt;span style="color:#f92672">]&lt;/span>&lt;span style="color:#75715e"># kubectl get -n monitor prometheus&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>NAME VERSION REPLICAS AGE
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>test &lt;span style="color:#ae81ff">1&lt;/span> 2m17s
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">[&lt;/span>root@master-1 prometheus-operator&lt;span style="color:#f92672">]&lt;/span>&lt;span style="color:#75715e"># kubectl get -n monitor statefulsets.apps&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>NAME READY AGE
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>prometheus-test 1/1 2m20s
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">[&lt;/span>root@master-1 prometheus-operator&lt;span style="color:#f92672">]&lt;/span>&lt;span style="color:#75715e"># kubectl get -n monitor pod&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>NAME READY STATUS RESTARTS AGE
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>prometheus-operator-6cdb7d79fb-mgv97 1/1 Running &lt;span style="color:#ae81ff">0&lt;/span> 4m49s
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>prometheus-test-0 2/2 Running &lt;span style="color:#ae81ff">0&lt;/span> 73s
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">[&lt;/span>root@master-1 prometheus-operator&lt;span style="color:#f92672">]&lt;/span>&lt;span style="color:#75715e"># kubectl get -n monitor service&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>NAME TYPE CLUSTER-IP EXTERNAL-IP PORT&lt;span style="color:#f92672">(&lt;/span>S&lt;span style="color:#f92672">)&lt;/span> AGE
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>prometheus-operated ClusterIP None &amp;lt;none&amp;gt; 9090/TCP 2m57s
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>prometheus-operator ClusterIP None &amp;lt;none&amp;gt; 8080/TCP 5m12s
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">[&lt;/span>root@master-1 prometheus-operator&lt;span style="color:#f92672">]&lt;/span>&lt;span style="color:#75715e"># kubectl get -n monitor pod prometheus-test-0 -oyaml | neat | grep image&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> image: quay.io/prometheus/prometheus
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> image: quay.io/prometheus-operator/prometheus-config-reloader:v0.45.0
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ul>
&lt;li>quay.io/prometheus/prometheus # Prometheus Server 主程序&lt;/li>
&lt;li>quay.io/prometheus-operator/prometheus-config-reloader:v0.45.0 # 处理 ServiceMonitor、PodMonitor、PrometheusRule 获取到的配置信息，并传递给上面的 prometheus 容器&lt;/li>
&lt;/ul>
&lt;p>这时候一个 Prometheus Server 就部署完成了，可以使用 kubectl port-forward -n monitor service/prometheus-operated 9090:9090 &amp;ndash;address=0.0.0.0 命令来暴露服务的端口，然后访问 https://HostIP:9090，就可以看到 prometheus 的 web 界面了&lt;/p>
&lt;p>现在的 Prometheus 没有任何配置，如图所示。
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/chh1bv/1616068816344-2c704165-0427-47bd-99a8-706e6df77fb0.png" alt="">
如果想要给 prometheus 添加配置，则需要使用 ServiceMonitor、PodMonitor 这些 CRD，或者为 Prometheus 对象添加 additionalScrapeConfigs 字段来引用附加配置，不能直接手动修改配置文件，因为配置文件是通过 sidecar 容器 自动生成的，就算手动修改了也会被还原，因为 operator 会持续监测配置文件与其他方式获取的配置内容是否匹配。&lt;/p>
&lt;h1 id="prometheus-生成的-pod-资源的组成">Prometheus 生成的 Pod 资源的组成&lt;/h1>
&lt;p>&lt;strong>包含 2 个容器，共享部分 volume&lt;/strong>&lt;/p>
&lt;ol>
&lt;li>prometheus # Prometheus Server 主程序。&lt;/li>
&lt;li>config-reloader # 处理 ServiceMonitor、PodMonitor、PrometheusRule 获取到的配置信息，并传递给上面的 prometheus 容器&lt;/li>
&lt;/ol>
&lt;h2 id="prometheus-容器">Prometheus 容器&lt;/h2>
&lt;p>prometheus server 主程序，包括程序启动的一些参数也会提前设置好默认值，如下所示：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-yaml" data-lang="yaml">&lt;span style="display:flex;">&lt;span>- &lt;span style="color:#f92672">args&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - --&lt;span style="color:#ae81ff">web.console.templates=/etc/prometheus/consoles&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - --&lt;span style="color:#ae81ff">web.console.libraries=/etc/prometheus/console_libraries&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - --&lt;span style="color:#ae81ff">config.file=/etc/prometheus/config_out/prometheus.env.yaml&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - --&lt;span style="color:#ae81ff">storage.tsdb.path=/prometheus&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - --&lt;span style="color:#ae81ff">storage.tsdb.retention.time=24h&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - --&lt;span style="color:#ae81ff">web.enable-lifecycle&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - --&lt;span style="color:#ae81ff">storage.tsdb.no-lockfile&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - --&lt;span style="color:#ae81ff">web.route-prefix=/&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">image&lt;/span>: &lt;span style="color:#ae81ff">quay.io/prometheus/prometheus&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">name&lt;/span>: &lt;span style="color:#ae81ff">prometheus&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">ports&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#f92672">containerPort&lt;/span>: &lt;span style="color:#ae81ff">9090&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">name&lt;/span>: &lt;span style="color:#ae81ff">web&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">readinessProbe&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">failureThreshold&lt;/span>: &lt;span style="color:#ae81ff">120&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">httpGet&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">path&lt;/span>: &lt;span style="color:#ae81ff">/-/ready&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">port&lt;/span>: &lt;span style="color:#ae81ff">web&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">periodSeconds&lt;/span>: &lt;span style="color:#ae81ff">5&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">timeoutSeconds&lt;/span>: &lt;span style="color:#ae81ff">3&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">terminationMessagePolicy&lt;/span>: &lt;span style="color:#ae81ff">FallbackToLogsOnError&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">volumeMounts&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e"># 配置文件存储路径，与 config-reloader 挂载同一个名为 config-out 的卷。config-reloader 会将处理好的配置文件放在该卷中。&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#f92672">mountPath&lt;/span>: &lt;span style="color:#ae81ff">/etc/prometheus/config_out&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">name&lt;/span>: &lt;span style="color:#ae81ff">config-out&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">readOnly&lt;/span>: &lt;span style="color:#66d9ef">true&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#f92672">mountPath&lt;/span>: &lt;span style="color:#ae81ff">/etc/prometheus/certs&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">name&lt;/span>: &lt;span style="color:#ae81ff">tls-assets&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">readOnly&lt;/span>: &lt;span style="color:#66d9ef">true&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#f92672">mountPath&lt;/span>: &lt;span style="color:#ae81ff">/prometheus&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">name&lt;/span>: &lt;span style="color:#ae81ff">prometheus-test-db&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#f92672">mountPath&lt;/span>: &lt;span style="color:#ae81ff">/etc/prometheus/rules/prometheus-test-rulefiles-0&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">name&lt;/span>: &lt;span style="color:#ae81ff">prometheus-test-rulefiles-0&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>配置文件使用 config_out 目录，挂载该目录的卷与下面的一个名为 prometheus-config-reloader 的容器的卷相同，所以配置文件是通过 prometheus-config-reloader 容器来生成的。&lt;/p>
&lt;h2 id="config-reloader-容器">config-reloader 容器&lt;/h2>
&lt;p>该容器用于热更新 prometheus server 的主配置文件&lt;/p>
&lt;p>ServiceMonitor 资源会将生成的配置文件写到名为 config 的 secret 中，然后该 container 解压该文件并拷贝到 config-out 卷中。由于 config-out 卷会挂载到该 container 与 prometheus 容器中，所以该卷内的文件也是共享的。然后该程序会执行参数中 reload-url 的的值，对 prometheus 的配置进行热更新&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-yaml" data-lang="yaml">&lt;span style="display:flex;">&lt;span>- &lt;span style="color:#f92672">args&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - --&lt;span style="color:#ae81ff">listen-address=:8080&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - --&lt;span style="color:#ae81ff">reload-url=http://localhost:9090/-/reload&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - --&lt;span style="color:#ae81ff">config-file=/etc/prometheus/config/prometheus.yaml.gz&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - --&lt;span style="color:#ae81ff">config-envsubst-file=/etc/prometheus/config_out/prometheus.env.yaml&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - --&lt;span style="color:#ae81ff">watched-dir=/etc/prometheus/rules/prometheus-test-rulefiles-0&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">command&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#ae81ff">/bin/prometheus-config-reloader&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">env&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#f92672">name&lt;/span>: &lt;span style="color:#ae81ff">POD_NAME&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">valueFrom&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">fieldRef&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">fieldPath&lt;/span>: &lt;span style="color:#ae81ff">metadata.name&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#f92672">name&lt;/span>: &lt;span style="color:#ae81ff">SHARD&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">value&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;0&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">image&lt;/span>: &lt;span style="color:#ae81ff">quay.io/prometheus-operator/prometheus-config-reloader:v0.45.0&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">name&lt;/span>: &lt;span style="color:#ae81ff">config-reloader&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">ports&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#f92672">containerPort&lt;/span>: &lt;span style="color:#ae81ff">8080&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">name&lt;/span>: &lt;span style="color:#ae81ff">reloader-web&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">resources&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">limits&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">cpu&lt;/span>: &lt;span style="color:#ae81ff">100m&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">memory&lt;/span>: &lt;span style="color:#ae81ff">50Mi&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">terminationMessagePolicy&lt;/span>: &lt;span style="color:#ae81ff">FallbackToLogsOnError&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">volumeMounts&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">#&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#f92672">mountPath&lt;/span>: &lt;span style="color:#ae81ff">/etc/prometheus/config&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">name&lt;/span>: &lt;span style="color:#ae81ff">config&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e"># 处理 config 卷中的内容，并生成 Prometheus Server 可读的配置文件，放在 config-out 卷中。&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#f92672">mountPath&lt;/span>: &lt;span style="color:#ae81ff">/etc/prometheus/config_out&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">name&lt;/span>: &lt;span style="color:#ae81ff">config-out&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#f92672">mountPath&lt;/span>: &lt;span style="color:#ae81ff">/etc/prometheus/rules/prometheus-test-rulefiles-0&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">name&lt;/span>: &lt;span style="color:#ae81ff">prometheus-test-rulefiles-0&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="pod-中所使用的-volume">Pod 中所使用的 volume&lt;/h2>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-yaml" data-lang="yaml">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">volumes&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#f92672">name&lt;/span>: &lt;span style="color:#ae81ff">config&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">secret&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">secretName&lt;/span>: &lt;span style="color:#ae81ff">prometheus-test&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#f92672">name&lt;/span>: &lt;span style="color:#ae81ff">tls-assets&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">secret&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">secretName&lt;/span>: &lt;span style="color:#ae81ff">prometheus-test-tls-assets&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#f92672">emptyDir&lt;/span>: {}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">name&lt;/span>: &lt;span style="color:#ae81ff">config-out&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#f92672">configMap&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">name&lt;/span>: &lt;span style="color:#ae81ff">prometheus-test-rulefiles-0&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">name&lt;/span>: &lt;span style="color:#ae81ff">prometheus-test-rulefiles-0&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#f92672">emptyDir&lt;/span>: {}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">name&lt;/span>: &lt;span style="color:#ae81ff">prometheus-test-db&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ul>
&lt;li>&lt;strong>config&lt;/strong> # 通过 ServiceMonitor 等途径生成的配置文以 .gz 的压缩方式，保存在这个卷中
&lt;ul>
&lt;li>通过 ServiceMonitor 等途径获取的配置文件，放在这个卷中，经过 config-reloader 容器处理后，将生成的配置文件放到 config-out 卷中。&lt;/li>
&lt;li>这个 prometheus-test 的 Secret 对象中存储的是配置文件的 .gz 格式的内容。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-yaml" data-lang="yaml">&lt;span style="display:flex;">&lt;span>[&lt;span style="color:#ae81ff">root@master-1 prometheus-operator]# kubectl get secrets prometheus-test -oyaml | neat&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">apiVersion&lt;/span>: &lt;span style="color:#ae81ff">v1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">data&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">prometheus.yaml.gz&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">kind&lt;/span>: &lt;span style="color:#ae81ff">Secret&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">metadata&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">annotations&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">empty&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;true&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">labels&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">managed-by&lt;/span>: &lt;span style="color:#ae81ff">prometheus-operator&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">name&lt;/span>: &lt;span style="color:#ae81ff">prometheus-test&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">namespace&lt;/span>: &lt;span style="color:#ae81ff">default&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">type&lt;/span>: &lt;span style="color:#ae81ff">Opaque&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ul>
&lt;li>**config-out **# config 卷中的配置文件解压缩后保存在这个卷中。Prometheus Server 也挂载了这个卷，可以读取其中的配置文件。&lt;/li>
&lt;li>&lt;strong>prometheus-test-db&lt;/strong> # Prometheus Server 的数据存储卷。这里默认是 emptyDir 类型，可以通过 PV 等方式持久化&lt;/li>
&lt;/ul>
&lt;h1 id="prometheus-配置文件的变化">Prometheus 配置文件的变化&lt;/h1>
&lt;h2 id="servicemontiroselect">serviceMontiroSelect&lt;/h2>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-yaml" data-lang="yaml">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">apiVersion&lt;/span>: &lt;span style="color:#ae81ff">monitoring.coreos.com/v1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">kind&lt;/span>: &lt;span style="color:#ae81ff">Prometheus&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">metadata&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">name&lt;/span>: &lt;span style="color:#ae81ff">test&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">namespace&lt;/span>: &lt;span style="color:#ae81ff">monitor&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">spec&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">replicas&lt;/span>: &lt;span style="color:#ae81ff">1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">serviceAccountName&lt;/span>: &lt;span style="color:#ae81ff">prometheus&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">serviceMonitorSelector&lt;/span>: {}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>添加该字段后，配置文件会增加一些内容&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/chh1bv/1616068816303-8c92c25b-378d-4617-8d35-02e286c35e84.png" alt="">
这些内容可以在 prometheus-test 这个 secret 中看到，可以看到，secret 中的内容就是配置文件压缩后进行 base64 编码后的值。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-yaml" data-lang="yaml">&lt;span style="display:flex;">&lt;span>[&lt;span style="color:#ae81ff">root@master-1 prometheus-operator]# kubectl get secrets -n monitor prometheus-test -oyaml | neat&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">apiVersion&lt;/span>: &lt;span style="color:#ae81ff">v1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">data&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">prometheus.yaml.gz&lt;/span>: &lt;span style="color:#ae81ff">H4sIAAAAAAAA/2yQPUuEMRCE+/yKLSxUiDmwSydo6UcvEvbiXAzsm7xscsf57yXxE7VbZnZmHzZJ3bJ4Q4QDy557riXk0qEHFk+Xm2aIWlRe8UfGsUMLSxDeQtooIVq1Lugv2DdPSy25V3Udrf8yg2KVHNnTyenD/XW4u7q9OTO6F4RdFjRvLDn06L4jbrjth2BHrx3qjNiNO7945UXMB2+sZZdT8/T4ZFigPZc0IOccFBP7a8sQWeI4HuBpWs9a14mtSDj6f+g/yxYunKDvp94CAAD//wMwvnNTAQAA&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">kind&lt;/span>: &lt;span style="color:#ae81ff">Secret&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">metadata&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">annotations&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">generated&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;true&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">labels&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">managed-by&lt;/span>: &lt;span style="color:#ae81ff">prometheus-operator&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">name&lt;/span>: &lt;span style="color:#ae81ff">prometheus-test&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">namespace&lt;/span>: &lt;span style="color:#ae81ff">monitor&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">type&lt;/span>: &lt;span style="color:#ae81ff">Opaque&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>[&lt;span style="color:#ae81ff">root@master-1 prometheus-operator]# echo &amp;#34;H4sIAAAAAAAA/2yQPUuEMRCE+/yKLSxUiDmwSydo6UcvEvbiXAzsm7xscsf57yXxE7VbZnZmHzZJ3bJ4Q4QDy557riXk0qEHFk+Xm2aIWlRe8UfGsUMLSxDeQtooIVq1Lugv2DdPSy25V3Udrf8yg2KVHNnTyenD/XW4u7q9OTO6F4RdFjRvLDn06L4jbrjth2BHrx3qjNiNO7945UXMB2+sZZdT8/T4ZFigPZc0IOccFBP7a8sQWeI4HuBpWs9a14mtSDj6f+g/yxYunKDvp94CAAD//wMwvnNTAQAA&amp;#34; | base64 -d &amp;gt; 123.gz&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>[&lt;span style="color:#ae81ff">root@master-1 prometheus-operator]# gzip -d 123.gz&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>[&lt;span style="color:#ae81ff">root@master-1 prometheus-operator]# cat 123&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">global&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">evaluation_interval&lt;/span>: &lt;span style="color:#ae81ff">30s&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">scrape_interval&lt;/span>: &lt;span style="color:#ae81ff">30s&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">external_labels&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">prometheus&lt;/span>: &lt;span style="color:#ae81ff">monitor/test&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">prometheus_replica&lt;/span>: &lt;span style="color:#ae81ff">$(POD_NAME)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">rule_files&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>- &lt;span style="color:#ae81ff">/etc/prometheus/rules/prometheus-test-rulefiles-0/*.yaml&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">scrape_configs&lt;/span>: []
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">alerting&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">alert_relabel_configs&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#f92672">action&lt;/span>: &lt;span style="color:#ae81ff">labeldrop&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">regex&lt;/span>: &lt;span style="color:#ae81ff">prometheus_replica&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">alertmanagers&lt;/span>: []
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="additionalscrapeconfigs">additionalScrapeConfigs&lt;/h2>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://github.com/prometheus-operator/prometheus-operator/blob/master/Documentation/additional-scrape-config.md">官方文档&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>在使用 Prometheus Operator 时，会有一些很特殊的需求，无法通过 ServiceMonitor 或者 PodMonitor 来自动生成配置，这些配置，就可以通过 additionalScrapeConfigs 来添加到 Prometheus Server 的配置文件中。&lt;/p>
&lt;p>我们可以按照原始的 Prometheus 的 scrape_config 配置环境的格式，写到一个 &lt;code>文件A&lt;/code> 中，然后用 &lt;code>文件A&lt;/code> 创建一个 Secret 对象。并在 additionalScrapeConfigs 字段中，引用这个 Secret 对象中的指定数据，即可将 &lt;code>文件A&lt;/code> 的配置附加到 Prometheus Server 的配置文件中。&lt;/p>
&lt;p>种方式常用来为 Prometheus Server 创建静态的 Scrape 配置。就是 scrape_cofig 配置环境中的 static_configs&lt;/p>
&lt;p>比我，我们创建一个简单的抓取配置。假设命名为&lt;code>prometheus-additional.yaml&lt;/code>&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>cat &amp;gt; prometheus-additional.yaml &lt;span style="color:#e6db74">&amp;lt;&amp;lt;EOF
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">- job_name: &amp;#34;prometheus&amp;#34;
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74"> static_configs:
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74"> - targets: [&amp;#34;localhost:9090&amp;#34;]
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">EOF&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>然后，创建一个该文件的 Secret 对象。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>kubectl create -n monitor secret generic additional-scrape-configs --from-file&lt;span style="color:#f92672">=&lt;/span>prometheus-additional.yaml --dry-run -oyaml &amp;gt; additional-scrape-configs.yaml
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>这个 secret 应该是这个样子的&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-yaml" data-lang="yaml">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">apiVersion&lt;/span>: &lt;span style="color:#ae81ff">v1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">data&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">prometheus-additional.yaml&lt;/span>: &lt;span style="color:#ae81ff">LSBqb2JfbmFtZTogInByb21ldGhldXMiCiAgc3RhdGljX2NvbmZpZ3M6CiAgLSB0YXJnZXRzOiBbImxvY2FsaG9zdDo5MDkwIl0K&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">kind&lt;/span>: &lt;span style="color:#ae81ff">Secret&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">metadata&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">creationTimestamp&lt;/span>: &lt;span style="color:#66d9ef">null&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">name&lt;/span>: &lt;span style="color:#ae81ff">additional-scrape-configs&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">namespace&lt;/span>: &lt;span style="color:#ae81ff">monitor&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>创建这个 Secret 资源&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>kubectl apply -f additional-scrape-configs.yaml
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>最后，在 Prometheus 这个 CRD 中引用这个额外的配置&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-yaml" data-lang="yaml">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">apiVersion&lt;/span>: &lt;span style="color:#ae81ff">monitoring.coreos.com/v1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">kind&lt;/span>: &lt;span style="color:#ae81ff">Prometheus&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">metadata&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">name&lt;/span>: &lt;span style="color:#ae81ff">test&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">namespace&lt;/span>: &lt;span style="color:#ae81ff">monitor&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">spec&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">replicas&lt;/span>: &lt;span style="color:#ae81ff">1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">serviceAccountName&lt;/span>: &lt;span style="color:#ae81ff">prometheus&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">serviceMonitorSelector&lt;/span>: {}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e"># 在这里引用 additional-scrape-configs 这个 secret 对象下的 .data 字段中，名为 prometheus-additional.yaml 的值。&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">additionalScrapeConfigs&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">name&lt;/span>: &lt;span style="color:#ae81ff">additional-scrape-configs&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">key&lt;/span>: &lt;span style="color:#ae81ff">prometheus-additional.yaml&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>这时，在 Prometheus Server 中，就会多出一些 scrape_configs 里的配置：&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/chh1bv/1616068816288-3ce64fdc-877c-41cc-a4b1-c404caff295a.png" alt="">
注意：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>仅对所有的附加抓取配置使用一个 Secret。也就是说所有的附加配置都要写到一个文件里&lt;/p>
&lt;/li>
&lt;li>
&lt;p>现阶段 secret 与 prometheus 这俩资源必须在同一个名称空间下&lt;/p>
&lt;/li>
&lt;/ul></description></item><item><title>Docs: Prometheus</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/6.%E5%8F%AF%E8%A7%82%E6%B5%8B%E6%80%A7/%E7%9B%91%E6%8E%A7%E7%B3%BB%E7%BB%9F/prometheus/prometheus/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/6.%E5%8F%AF%E8%A7%82%E6%B5%8B%E6%80%A7/%E7%9B%91%E6%8E%A7%E7%B3%BB%E7%BB%9F/prometheus/prometheus/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://prometheus.io/docs/introduction/overview/">官方文档&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://yunlzheng.gitbook.io/prometheus-book/">yunlzheng 写的电子书&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://github.com/Tencent-Cloud-Native/tkedocs">GitHub 项目，Tencent-Cloud-Native/tkedocs&lt;/a>(我个人总结完绝大部分文档后发现的这个项目)&lt;/li>
&lt;li>Prometheus 纪录片
&lt;ul>
&lt;li>&lt;a href="https://www.youtube.com/watch?v=rT4fJNbfe14">YouTube&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.bilibili.com/video/BV1aW4y147GX">B 站翻译&lt;/a>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>Prometheus 是由 SoundCloud 开发的 开源监控报警系统 和 时间序列数据库(TSDB) 。&lt;strong>Time Series(时间序列)&lt;/strong> 概念详见：&lt;a href="https://www.yuque.com/go/doc/33147376">Prometheus 数据模型&lt;/a>。使用 Go 语言开发，是 Google BorgMon 监控系统的开源版本。&lt;/p>
&lt;blockquote>
&lt;p>题外话：Google 的 Borg 诞生了 kuberntes、Google 的 Borgmon 诞生了 Prometheus&lt;/p>
&lt;/blockquote>
&lt;p>2016 年由 Google 发起 Linux 基金会旗下的 Cloud Native Computing Foundation(云原生计算基金会), 将 Prometheus 纳入其下第二大开源项目。Prometheus 目前在开源社区相当活跃。&lt;/p>
&lt;h2 id="prometheus-架构概述">Prometheus 架构概述&lt;/h2>
&lt;p>Prometheus 的基本原理是通过 HTTP 协议周期性抓取被监控组件的状态，任意组件只要提供对应的 HTTP 接口就可以接入监控。不需要任何 SDK 或者其他的集成过程。这样做非常适合做虚拟化环境监控系统，比如 VM、Docker、Kubernetes 等。输出被监控组件信息的 HTTP 接口被叫做 exporter 。&lt;/p>
&lt;p>下面这张图说明了 Prometheus 的整体架构，以及生态中的一些组件作用：
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/usvgfl/1616041189523-5ca97287-5886-4ab9-a4f8-6c249117e314.jpeg" alt="">
Prometheus 生态圈中包含了多个组件，其中许多组件是可选的，多数 Prometheus 组件是 Go 语言写的，使得这些组件很容易编译和部署：&lt;/p>
&lt;ul>
&lt;li>&lt;strong>Prometheus Server&lt;/strong> # 主要负责数据抓取和存储，提供 PromQL 查询语言的支持。用于收集和存储时间序列数据。
&lt;ul>
&lt;li>定期从配置好的 Jobs 中&lt;strong>拉取 &lt;strong>Exporters 采集的&lt;/strong> Metrics(指标)&lt;/strong> 数据；或者&lt;strong>接收&lt;/strong>来自 &lt;strong>Pushgateway&lt;/strong>(类似 zabbix 的 proxy) 发过来的 Metrics；或者从其他的 Prometheus Server 中拉取 Metrics。&lt;/li>
&lt;li>Prometheus Server 在本地存储收集到的 Metrics，并通过一定 &lt;strong>RecordingRule(记录规则)&lt;/strong> 进行清理和整理数据，并把得到的结果存储到新的时间序列中。还会运行已定义好的 &lt;strong>AlertingRule(告警规则)&lt;/strong>，记录新的时间序列或者向 Alertmanager 推送警报。&lt;/li>
&lt;li>由于 Metrics 都是通过 HTTP 或者 HTTPS 协议提供的，所以 Prometheus Server 在抓取 Metrics 时，也就是发起一次 HTTP 或者 HTTPS 的 GET 请求&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>Instrumenting&lt;/strong> # 为 Prometheus 提供指标的工具或代码
&lt;ul>
&lt;li>**Exporters **# 导出器。Exporter 是 Prometheus 的一类数据采集组件的总称。它负责从设备上搜集数据，并将其转化为 Prometheus 支持的格式(一般情况下 exporter 是安装在需要采集数据的设备上的程序，并监听某个 port。但是如果想要收集 snmp 信息的话，则有专门的 snmp-exporter 安装在某个地方；再收集指定设备的 snmp 信息，然后 prometheus 再找 snmp-exporter 去收集数据)。与传统的数据采集组件不同的是，它并不向中央服务器发送数据，而是等待中央服务器主动前来抓取。Prometheus 提供多种类型的 Exporter 用于采集各种不同服务的运行状态。目前支持的有数据库、硬件、消息中间件、存储系统、HTTP 服务器、JMX 等。&lt;/li>
&lt;li>&lt;strong>Client Library&lt;/strong> # 客户端库(客户端 SDK)，官方提供的客户端类库有 go、java、scala、python、ruby，其他还有很多第三方开发的类库，支持 nodejs、php、erlang 等。为需要监控的服务生成相应的 Metrics 并暴露给 Prometheus server。当 Prometheus server 来 pull 时，直接返回实时状态的 Metrics。&lt;/li>
&lt;li>**Push Gateway **# 支持 Client 主动推送 Metrics 到 PushGateway，而 PrometheusServer 只是定时去 Gateway 上抓取数据。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>Alertmanager&lt;/strong> # 警告管理器，用来进行报警。从 Prometheus server 端接收到 alerts 后，会进行去除重复数据，分组，并路由到对收的接受方式，发出报警。常见的接收方式有：电子邮件，pagerduty，OpsGenie, webhook 等。&lt;/li>
&lt;li>&lt;strong>prometheus_cli&lt;/strong> # 命令行工具。&lt;/li>
&lt;li>&lt;strong>其他辅助性工具&lt;/strong>
&lt;ul>
&lt;li>Prometheus 通过 PromQL 和其他 API 可视化地展示收集的数据。Prometheus 支持很多方式的图表可视化，例如 Grafana、自带的 PrometheusDashboard 以及自身提供的模版引擎等等。Prometheus 还提供 HTTP API 的查询方式，自定义所需要的输出。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>Prometheus 适用的场景&lt;/p>
&lt;ul>
&lt;li>Prometheus 在记录纯数字时间序列方面表现非常好。它既适用于面向服务器等硬件指标的监控，也适用于高动态的面向服务架构的监控。对于现在流行的微服务，Prometheus 的多维度数据收集和数据筛选查询语言也是非常的强大。Prometheus 是为服务的可靠性而设计的，当服务出现故障时，它可以使你快速定位和诊断问题。它的搭建过程对硬件和服务没有很强的依赖关系。&lt;/li>
&lt;/ul>
&lt;p>Prometheus 不适用的场景&lt;/p>
&lt;ul>
&lt;li>Prometheus 它的价值在于可靠性，甚至在很恶劣的环境下，你都可以随时访问它和查看系统服务各种指标的统计信息。 如果你对统计数据需要 100%的精确，它并不适用，例如：它不适用于实时计费系统。&lt;/li>
&lt;/ul>
&lt;h3 id="总结prometheus-从-instrumenting-那里抓取监控数据储存完了哈哈哈哈哈">总结：prometheus 从 Instrumenting 那里抓取监控数据，储存。完了~~~~哈哈哈哈哈&lt;/h3>
&lt;h2 id="instrumenting检测仪表装置-的实现方式">Instrumenting(检测仪表装置) 的实现方式&lt;/h2>
&lt;p>Prometheus 可以通过 3 种方式从目标上 Scrape(抓取) 指标：&lt;/p>
&lt;ul>
&lt;li>&lt;strong>Exporters&lt;/strong> # 外部抓取程序&lt;/li>
&lt;li>&lt;strong>Instrumentation&lt;/strong> # 可以理解为内嵌的 Exporter，比如 Prometheus Server 的 9090 端口的 &lt;code>/metrics&lt;/code> 就属于此类。
&lt;ul>
&lt;li>说白了，就是目标自己就可以吐出符合 Prometheus 格式的指标数据&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>Pushgateway&lt;/strong> # 针对需要推送指标的应用&lt;/li>
&lt;/ul>
&lt;h2 id="label-与-relabeling">Label 与 Relabeling&lt;/h2>
&lt;p>详见 &lt;a href="https://desistdaydream.github.io/docs/IT%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/6.%E5%8F%AF%E8%A7%82%E6%B5%8B%E6%80%A7/%E7%9B%91%E6%8E%A7%E7%B3%BB%E7%BB%9F/Prometheus/Target(%E7%9B%AE%E6%A0%87)%20%E4%B8%8E%20Relabeling(%E9%87%8D%E6%96%B0%E6%A0%87%E8%AE%B0).md">Label 与 Relabeling 章节&lt;/a>&lt;/p>
&lt;h2 id="instrumenting-的安装与使用">Instrumenting 的安装与使用&lt;/h2>
&lt;p>详见 &lt;a href="https://desistdaydream.github.io/docs/IT%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/6.%E5%8F%AF%E8%A7%82%E6%B5%8B%E6%80%A7/%E7%9B%91%E6%8E%A7%E7%B3%BB%E7%BB%9F/Instrumenting/Instrumenting.md">Instrumenting 章节&lt;/a>&lt;/p>
&lt;h1 id="prometheus-部署">Prometheus 部署&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://prometheus.io/docs/prometheus/latest/installation/">官方文档，Prometheus-安装&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>官方系统版本可在这里下载：&lt;a href="https://prometheus.io/download/">https://prometheus.io/download/&lt;/a>&lt;/p>
&lt;p>Prometheus 官方有多种部署方案，比如：Docker 容器、Ansible、Chef、Puppet、Saltstack 等。Prometheus 用 Golang 实现，因此具有天然可移植性(支持 Linux、Windows、macOS 和 Freebsd)。&lt;/p>
&lt;h2 id="二进制文件运行-prometheus-server">二进制文件运行 Prometheus Server&lt;/h2>
&lt;ul>
&lt;li>&lt;a href="https://github.com/prometheus/prometheus/releases/">https://github.com/prometheus/prometheus/releases/&lt;/a> 在该页面下直接下载 prometheus 的进制文件 &lt;code>prometheus-版本号.linux-amd64.tar.gz&lt;/code> 并解压，其中包含 prometheus 的主程序还有 yaml 格式的配置文件以及运行所需要的依赖库&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>export PromVersion&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;2.25.1&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>wget https://github.com/prometheus/prometheus/releases/download/v&lt;span style="color:#e6db74">${&lt;/span>PromVersion&lt;span style="color:#e6db74">}&lt;/span>/prometheus-&lt;span style="color:#e6db74">${&lt;/span>PromVersion&lt;span style="color:#e6db74">}&lt;/span>.linux-amd64.tar.gz
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ul>
&lt;li>创建/usr/local/prometheus 目录，并将解压的所有文件移动到该目录下&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>mkdir /usr/local/prometheus
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>tar -zxvf prometheus-&lt;span style="color:#e6db74">${&lt;/span>PromVersion&lt;span style="color:#e6db74">}&lt;/span>.linux-amd64.tar.gz -C /usr/local/prometheus/ --strip-components&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ul>
&lt;li>创建 Systemd 服务,在 ExecStart 字段上，使用运行时标志来对 prometheus 进行基本运行配置，标志说明详见下文&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>cat &amp;gt; /usr/lib/systemd/system/prometheus.service &lt;span style="color:#e6db74">&amp;lt;&amp;lt; EOF
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">[Unit]
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">Description=prometheus
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">After=network.target
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">[Service]
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">Type=simple
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">User=root
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">ExecStart=/usr/local/prometheus/prometheus \
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74"> --web.console.templates=/usr/local/prometheus/consoles \
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74"> --web.console.libraries=/usr/local/prometheus/console_libraries \
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74"> --config.file=/usr/local/prometheus/prometheus.yml \
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74"> --storage.tsdb.path=/var/lib/prometheusData \
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74"> --web.enable-lifecycle
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">Restart=on-failure
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">[Install]
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">WantedBy=multi-user.target
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">EOF&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ul>
&lt;li>启动 Prometheus&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>systemctl start prometheus
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="容器运行-prometheus">容器运行 prometheus&lt;/h2>
&lt;p>获取配置文件.&lt;/p>
&lt;blockquote>
&lt;p>也可以不获取配置文件，去掉启动时的 -v /etc/monitoring/prometheus:/etc/prometheus/config_out 与 &amp;ndash;config.file=/etc/prometheus/config_out/prometheus.yml 这两行即可
获取配置文件主要是为了让后续测试可以更方便得修改文件&lt;/p>
&lt;/blockquote>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>mkdir -p /opt/monitoring/prometheus
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>docker run -d --name prometheus --rm prom/prometheus
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>docker cp prometheus:/etc/prometheus /opt/monitoring/prometheus
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>mv /opt/monitoring/prometheus/prometheus /opt/monitoring/prometheus/config
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>docker stop prometheus
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>运行 Prometheus Server&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>docker run -d --name prometheus --restart&lt;span style="color:#f92672">=&lt;/span>always &lt;span style="color:#ae81ff">\
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">&lt;/span> --network host &lt;span style="color:#ae81ff">\
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">&lt;/span> -v /etc/localtime:/etc/localtime &lt;span style="color:#ae81ff">\
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">&lt;/span> -v /opt/monitoring/prometheus/config:/etc/prometheus/config_out &lt;span style="color:#ae81ff">\
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">&lt;/span> prom/prometheus &lt;span style="color:#ae81ff">\
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">&lt;/span> --config.file&lt;span style="color:#f92672">=&lt;/span>/etc/prometheus/config_out/prometheus.yml
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h1 id="prometheus-关联文件与配置">Prometheus 关联文件与配置&lt;/h1>
&lt;p>**/etc/prometheus/prometheus.yml **# Prometheus Server 运行时的配置文件。可通过 &amp;ndash;config.file 标志指定其他文件。
&lt;strong>/etc/prometheus/rule.yml&lt;/strong> # Prometheus Rule 配置文件。该文件默认不存在，需手动创建。可以在 prometheus.yml 配置中指定其他文件。&lt;/p>
&lt;h2 id="prometheus-配置示例">Prometheus 配置示例&lt;/h2>
&lt;h3 id="默认配置文件">默认配置文件&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-yaml" data-lang="yaml">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># 全局配置&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">global&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">scrape_interval&lt;/span>: &lt;span style="color:#ae81ff">15s&lt;/span> &lt;span style="color:#75715e"># 默认抓取间隔, 15秒向目标抓取一次数据。&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">evaluation_interval&lt;/span>: &lt;span style="color:#ae81ff">15s&lt;/span> &lt;span style="color:#75715e"># 每15秒评估一次规则，默认为1分钟。&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e"># scrape_timeout is set to the global default (10s).&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e"># 告警报警配置，设置prometheus主程序对接alertmanager程序的&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">alerting&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">alertmanagers&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#f92672">static_configs&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#f92672">targets&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e"># - alertmanagerIP:9093&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># 指定要使用的规则文件位置，并加载一次，根据全局配置中的 evaluation_interval 来定期评估&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># 从所有匹配到的文件中读取配置内容。可以使用正则表达式匹配多个符合的文件。Prometheus支持两种规则&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># 其一是记录规则(recording rules)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># 其二是告警规则(alerting rules)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">rule_files&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e"># - &amp;#34;first.rules&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e"># - &amp;#34;second.rules&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># 抓取配置，prometheus抓取exporter上的数据时的配置，一个job就是一个抓取工作，其中可以包括1个或者多个目标&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># 目标指的是可以被 prometheus 采集的服务器、服务等。&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># 默认配置里，Prometheus Server 会抓取本地9090端口上数据。该端口上的 exporter 就是 PrometheusServer 自己的 exporter&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">scrape_configs&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># job_name 指定要 scrape(抓取) 的 job(工作) 名称，名称必须是唯一的&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># 并且在这个配置内的时间序例，每一条都会自动添加上这个{job_name:&amp;#34;prometheus&amp;#34;}的标签。&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>- &lt;span style="color:#f92672">job_name&lt;/span>: &lt;span style="color:#e6db74">&amp;#39;prometheus&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e"># 设定该job的抓取时间间隔&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">scrape_interval&lt;/span>: &lt;span style="color:#ae81ff">5s&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">static_configs&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#f92672">targets&lt;/span>: [&lt;span style="color:#e6db74">&amp;#39;localhost:9090&amp;#39;&lt;/span>]
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="具有-node_exporter-的配置简单文件">具有 node_exporter 的配置简单文件&lt;/h3>
&lt;p>抓取部署了 node_exporter 设备的监控数据的方式及 prometheus.yml 配置文件说明
prometheus 会从 Node Exporter 所在服务器的 http://IP:9100/metrics 这个地址里的内容来获取该设备的监控数据
所以需要给 prometheus 创建一个工作(i.e.job)。一个 job 就是一个抓取监控数据的工作，其中包括要抓取目标的 ip 和 port，还可以设置标签进行分类，还能进行抓取筛选等等，下面提供一个基本的配置
修改 prometheus.yml，加入下面的监控目标，以便让 prometheus 监控这个已经安装了 node_exporter 的设备&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-yaml" data-lang="yaml">&lt;span style="display:flex;">&lt;span>- &lt;span style="color:#f92672">job_name&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;linux&amp;#34;&lt;/span> &lt;span style="color:#75715e">#新增一个job，名为linux&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">static_configs&lt;/span>: &lt;span style="color:#75715e"># 使用静态配置&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#f92672">targets&lt;/span>: [&lt;span style="color:#e6db74">&amp;#34;10.10.100.101:9100&amp;#34;&lt;/span>] &lt;span style="color:#75715e">#添加一个要抓取数据的目标，指定IP与PORT 。node_exporter所安装的设备&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">labels&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">instance&lt;/span>: &lt;span style="color:#ae81ff">lchTest&lt;/span> &lt;span style="color:#75715e">#给该目标添加一个标签&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>现在，prometheus.yml 配置文件中中一共定义了两个监控：一个是默认自带监控 prometheus 自身服务，另一个是我们新增的 job，这个 job 就是要抓取目标是 10.10.100.101 这台服务器上的监控数据&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-yaml" data-lang="yaml">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">scrape_configs&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#f92672">job_name&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;prometheus&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">static_configs&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#f92672">targets&lt;/span>: [&lt;span style="color:#e6db74">&amp;#34;localhost:9090&amp;#34;&lt;/span>]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#f92672">job_name&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;linux&amp;#34;&lt;/span> &lt;span style="color:#75715e">#指定job名称&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">static_configs&lt;/span>: &lt;span style="color:#75715e">#设定静态配置&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#f92672">targets&lt;/span>: [&lt;span style="color:#e6db74">&amp;#34;10.10.100.101:9100&amp;#34;&lt;/span>] &lt;span style="color:#75715e">#指定node_exporter所安装设备的ip:port&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">labels&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">instance&lt;/span>: &lt;span style="color:#ae81ff">lchTest&lt;/span> &lt;span style="color:#75715e">#给该target一个label来分类，常用于在查询语句中的筛选条件&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>访问 Prometheus Web，在 Status-&amp;gt;Targets 页面下，我们可以看到我们配置的两个 Target，它们的 State 为 UP
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/usvgfl/1616041189541-1dfdddd7-ee74-4f32-8df6-8821cf415a14.jpeg" alt="">&lt;/p>
&lt;h1 id="prometheus-的基本使用方式">Prometheus 的基本使用方式&lt;/h1>
&lt;p>Prometheus 运行后默认会监听在 9090 端口，可以通过访问 9090 端口来打开 Prometheus 的 web 界面
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/usvgfl/1616041189523-861a164c-3f79-42af-bd88-44c4baf2e349.jpeg" alt="">
Prometheus 本身也是自带 exporter 的,我们通过请求 http://ip:9090/metrics 可以查看从 exporter 中能具体抓到哪些 metrics。
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/usvgfl/1616041189563-4125f137-160f-48dd-b4f6-dfd6af94aed0.jpeg" alt="">&lt;/p>
&lt;p>这里以 Prometheus 本身数据为例，简单演示下在 Web 中查询指定表达式及图形化显示查询结果。
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/usvgfl/1616041189526-ee545ef0-965e-499c-b80f-b6cdaf05c974.jpeg" alt="">
[&lt;/p>
&lt;h1 id="instrumentingmd">](Instrumenting.md)&lt;/h1></description></item><item><title>Docs: 安装操作系统</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%AE%9E%E7%94%A8%E5%B7%A5%E5%85%B7/%E5%AE%89%E8%A3%85%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E5%AE%89%E8%A3%85%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%AE%9E%E7%94%A8%E5%B7%A5%E5%85%B7/%E5%AE%89%E8%A3%85%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E5%AE%89%E8%A3%85%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Windows_Preinstallation_Environment">Wiki，Windows_Preinstallation_Environment&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>我们想要安装操作系统，通常都需要将一个 &lt;strong>Bootable Media(启动介质)&lt;/strong> 放到 &lt;strong>Operating System Installation Media(操作系统安装介质)&lt;/strong> 中，一般使用介质制作工具(UltraISO、Rufus 等)来实现。这个&lt;strong>操作系统的安装介质&lt;/strong>可以是 &lt;strong>U盘、光盘、网络存储等&lt;/strong>。&lt;/p>
&lt;p>之后，将需要安装系统的计算机与介质连接，这个介质将会被加载到内存中，从而提供一个临时的环境(这个环境有可能会类似操作系统)，人类在这个环境中可以访问计算机硬件资源和文件系统的环境，从而利用介质中的安装程序，将操作系统安装到计算机中。毕竟，只要能访问到硬件资源了了，剩下的就是将文件写入到硬盘中即可。&lt;/p>
&lt;p>除了最基本的启动介质，很多操作系统的发行商还会提供一个具有微型系统能力的启动介质，这种介质除了最基本的安装能力外，还提供了很多额外的工具，以便可以修复、管理计算机，或者修复操作系统。Windows 和 Linux 对这种启动介质有各自的称呼&lt;/p>
&lt;ul>
&lt;li>&lt;strong>Preinstallation Environment&lt;/strong> # Windows 微型系统的称呼。简称 WinPE&lt;/li>
&lt;li>&lt;strong>Live&lt;/strong> # Linux 微型系统的称呼。比如 Ubuntu Live&lt;/li>
&lt;/ul>
&lt;h1 id="ghost">Ghost&lt;/h1>
&lt;h2 id="概述-1">概述&lt;/h2>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Ghost_(disk_utility)">Wiki,Ghost(disk utility)&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote></description></item><item><title>Docs: 编程技术</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/2.%E7%BC%96%E7%A8%8B/%E7%BC%96%E7%A8%8B%E6%8A%80%E6%9C%AF/%E7%BC%96%E7%A8%8B%E6%8A%80%E6%9C%AF/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/2.%E7%BC%96%E7%A8%8B/%E7%BC%96%E7%A8%8B%E6%8A%80%E6%9C%AF/%E7%BC%96%E7%A8%8B%E6%8A%80%E6%9C%AF/</guid><description>
&lt;h1 id="crud增删改查">CRUD(增删改查)&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Create,_read,_update_and_delete">Wiki,CRUD&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>在计算机编程中，&lt;strong>Create、Read、Update、Delete(创建、读取、更新、删除，简称 增删改查(CRUD))&lt;/strong> 是持久性存储的四个基本操作。[1] CRUD 有时也用于描述用户界面约定，这些约定便于使用基于计算机的表单和报告查看、搜索和更改信息。这个词很可能是詹姆斯·马丁 (James Martin) 在他的 1983 著作《管理数据库环境》中首次推广的。
are the four basic operations of &lt;a href="https://en.wikipedia.org/wiki/Persistent_storage">persistent storage&lt;/a>.&lt;a href="https://en.wikipedia.org/wiki/Create,_read,_update_and_delete#cite_note-james-martin-1">[1]&lt;/a> CRUD is also sometimes used to describe &lt;a href="https://en.wikipedia.org/wiki/User_interface">user interface&lt;/a> conventions that facilitate viewing, searching, and changing information using computer-based &lt;a href="https://en.wikipedia.org/wiki/Form_(document)">forms&lt;/a> and &lt;a href="https://en.wikipedia.org/wiki/Report">reports&lt;/a>. The term was likely first popularized by &lt;a href="https://en.wikipedia.org/wiki/James_Martin_(author)">James Martin&lt;/a> in his 1983 book &lt;em>Managing the Data-base environment&lt;/em>.&lt;/p>
&lt;h1 id="projects项目">Projects(项目)&lt;/h1>
&lt;p>项目一般就是指开发一个程序。
从写代码的角度看，一个项目就是一个文件夹，该文件夹中包含该项目所需要依赖的第三方库，项目主体的代码，可执行文件等。&lt;/p>
&lt;h1 id="前端与后端">前端与后端&lt;/h1>
&lt;p>后端：一般是用来处理客户端发送的请求，并将前端写的 页面代码 文件，发送给客户端；或者从数据库获取数据，并填充到前端页面中；等等
前端：一般用来展示的，客户端收到的页面文件(比如输入用户名和密码的框，下拉框等等)，都是由前端工程师来写的，一般是 html 等。&lt;/p>
&lt;h2 id="前后端交互">前后端交互&lt;/h2>
&lt;p>前端与后端之间的交互取决于是前后端分离还不分离&lt;/p>
&lt;ul>
&lt;li>前后端不分离时，通常由后端代码渲染 html 等静态资源文件，&lt;strong>此时客户端访问的是由后端代码监听的端口&lt;/strong>&lt;/li>
&lt;li>前后端分离时，又分多种情况
&lt;ul>
&lt;li>将 html 等静态资源放在 Nginx 等可以提供 HTTP 服务的程序中，然后通过后端提供的 API 进行交互，&lt;strong>此时客户端访问的是由提供 HTTP 服务程序监听的端口&lt;/strong>&lt;/li>
&lt;li>将 html 等静态资源与后端代码放在一起，这种行为通常称为“XX 语言嵌入静态资源”，&lt;strong>此时客户端访问的是由后端程序监听的端口&lt;/strong>
&lt;ul>
&lt;li>比如 Go 语言在 1.16 版本中推出的 embed 库即可实现该效果&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h2 id="前端">前端&lt;/h2>
&lt;p>&lt;strong>htmx&lt;/strong> # 不使用 JavaScript 也可以和浏览器进行交互&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://mp.weixin.qq.com/s/oGk8QtvHwvPDDkOpR5dLzQ">https://mp.weixin.qq.com/s/oGk8QtvHwvPDDkOpR5dLzQ&lt;/a>&lt;/li>
&lt;/ul>
&lt;h1 id="库标准库第三方库与框架">库、标准库、第三方库与框架&lt;/h1>
&lt;p>每种编程语言都具有最基本的功能，比如输入、输出等，这些都属于基本库。比如我使用 print 想输出一些内容，则是调用输出所用的库来实现这个效果。这些基本库都是内置在各个编程语言当中的，可以直接调用。
但是有时候会有很复杂的需求， 比如对系统的某些程序进行操作、对数据库进行操作、写出来的程序如何设置子命令和参数等等等。这些复杂的需求，如果使用基本的编程语言来实现，是非常麻烦的，这时候如果有人可以提前使用编程语言的基本功能来创作一个可以实现某个具体功能的程序就好了。
这个创作出来的基本程序就可以称之为“库或者框架”
至于库和框架的区别：库的英语为 Library ( 简写 Lib )，框架的英语为 Framework。库和框架都是一种有别于软件、面向程序开发者的产品形式。正因为如此，也有很多人误以为库就是框架，或者认为指定语言的库就是框架。&lt;/p>
&lt;ul>
&lt;li>库：库是将代码集合成的一个产品，供程序员调用。面向对象的代码组织形式而成的库也叫类库。面向过程的代码组织形式而成的库也叫函数库。在函数库中的可直接使用的函数叫库函数。开发者在使用库的时候，只需要使用库的一部分类或函数，然后继续实现自己的功能。
&lt;ul>
&lt;li>标准库：就是各种语言自带的库，比如 go 里的 fmt 库，用来输出。这些标准库与语言的关键字构成了编程语言的基本功能。&lt;/li>
&lt;li>第三方库：是对编程语言的扩展，比如一种语言需要更多丰富的功能，而不仅有标准库的功能的时候，可以导入第三方库并使用它们。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>框架：框架则是为解决一个(一类)问题而开发的产品，框架用户一般只需要使用框架提供的类或函数，即可实现全部功能。可以说，框架是库的升级版。开发者在使用框架的时候，必须使用这个框架的全部代码。&lt;/li>
&lt;/ul>
&lt;p>库更像一个一个小的功能，比如使代码可以操作数据库这个功能，使代码可以监听在设备的某个端口上等等。
而框架则更像一个还没完成的程序，只有一些大体框架，其中具体的内容，可以根据自己的喜好去填充，说白了，就是一种规范，只要根据这个规范，就可以实现自己的某个程序。比如想开发一个 web 程序，就可以使用一个 web 框架，这个框架会给开发者直接提供一个基本的后端，至于其中的内容，开发者再去详细填写就好了
框架和库的比较可以想像为:
假如我们要买一台电脑：电脑内的每个部件就是编程语言的一个个关键字&lt;/p>
&lt;ol>
&lt;li>框架为我们提供了已经装好的电脑，我们只要买回来就能用，但你必须把整个电脑买回来。这样用户自然轻松许多，但会导致很多人用一样的电脑，或你想自定义某个部件将需要修改这个框架。&lt;/li>
&lt;li>库就如自己组装的电脑。库为我们提供了很多部件，我们需要自己组装，如果某个部件库未提供，我们也可以自己做。库的使用非常灵活，但没有框架方便。&lt;/li>
&lt;/ol>
&lt;p>然后通过对库和框架的使用，可以使该电脑实现我们自己想要的功能，比如玩游戏、办公、看电影等等。
程序开发中的框架(例如 1000 万+行的 Qt)往往是对常见功能的封装(类似于成语对常用含义的代指，不同点在于应用框架最终对 CPU 表达含义时候会把成语替换为原本含义-通过函数调用),抛开框架，程序会变得因缺少一些&amp;rsquo;固定成语&amp;rsquo;(函数)的&amp;rsquo;释义&amp;rsquo;(函数实现)而变得无法执行。
所以，程序框架理解为基础或者机械标准件(例如螺丝螺母这些有明确标准的机械部件)更为贴切。
这样理解，假如你要造一辆马车，在没有框架的情况下，你需要自己去伐木，去把木头做成木板，木棍，然后组成轮子，门，等部件，然后组装起来，但如果你用了框架，就相当于你有现成的轮子，门等部件，你只需要组装一下就可以了。
可以说，一个框架是一个可复用的设计构件，它规定了应用的体系结构，阐明了整个设计、协作构件之间的依赖关系、责任分配和控制流程，表现为一组抽象类以及其实例之间协作的方法，它为构件复用提供了上下文(Context)关系。因此构件库的大规模重用也需要框架。
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/cr7gm9/1616163790618-a4887423-a11b-4cfa-be93-a852be8c838f.jpeg" alt="">
拓展资料：
框架（Framework）是整个或部分系统的可重用设计，表现为一组抽象构件及构件实例间交互的方法;另一种定义认为，框架是可被应用开发者定制的应用骨架。前者是从应用方面而后者是从目的方面给出的定义。&lt;/p>
&lt;h2 id="例子">例子&lt;/h2>
&lt;p>拿 go 语言举例，当获取完一个第三方库之后(比如通过 go get 命令安装)，有时候会有一个命令行工具，比如 cobra，所以，也可以把库当做一个应用程序。而大部分时候，是不会出现一个命令行工具的，在获取完库之后，需要在 import 代码中进行引用，即可使用库中的相关函数。&lt;/p></description></item><item><title>Docs: 多媒体处理工具</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/11_%E5%A4%9A%E5%AA%92%E4%BD%93/%E5%A4%9A%E5%AA%92%E4%BD%93%E5%A4%84%E7%90%86%E5%B7%A5%E5%85%B7/%E5%A4%9A%E5%AA%92%E4%BD%93%E5%A4%84%E7%90%86%E5%B7%A5%E5%85%B7/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/11_%E5%A4%9A%E5%AA%92%E4%BD%93/%E5%A4%9A%E5%AA%92%E4%BD%93%E5%A4%84%E7%90%86%E5%B7%A5%E5%85%B7/%E5%A4%9A%E5%AA%92%E4%BD%93%E5%A4%84%E7%90%86%E5%B7%A5%E5%85%B7/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://zhuanlan.zhihu.com/p/138863913">知乎，视频录制、视频剪辑、字幕制作&amp;hellip;&amp;hellip;当一名 UP 主需要哪些软件&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>视频录制&lt;/p>
&lt;ul>
&lt;li>OBS Studio&lt;/li>
&lt;/ul>
&lt;p>视频剪辑&lt;/p>
&lt;ul>
&lt;li>Premiere&lt;/li>
&lt;li>Shotcut&lt;/li>
&lt;li>必剪 # B 站的&lt;/li>
&lt;/ul>
&lt;p>字幕制作&lt;/p>
&lt;ul>
&lt;li>听见字幕&lt;/li>
&lt;/ul>
&lt;h1 id="obs-studio">OBS Studio&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://github.com/obsproject/obs-studio">GitHub 项目，obsproject/obs-studio&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://obsproject.com/">官网&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>&lt;strong>Open Broadcaster Software(开放广播软件，简称 OBS)&lt;/strong> 是一款用于视频录制和直播的免费和开源软件&lt;/p>
&lt;h1 id="shotcut">Shotcut&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://github.com/mltframework/shotcut">GitHub 项目，mltframework/shotcut&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://shotcut.org/">官网&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>导出视频：https://jingyan.baidu.com/article/86f4a73e2716ee77d752695a.html&lt;/p>
&lt;h1 id="音频处理">音频处理&lt;/h1>
&lt;h2 id="buzz">Buzz&lt;/h2>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://github.com/chidiwilliams/buzz">GitHub 项目，chidiwilliams/buzz&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.bilibili.com/video/BV1sG411N7RS">B 站，真正的最强字幕神器，离线语音转文字，一键搞定！&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>Buzz 可以在我们的个人计算机上离线转录和翻译音频。由 OpenAI 的 Whisper 提供支持。&lt;/p>
&lt;h1 id="图片处理">图片处理&lt;/h1>
&lt;h2 id="photopea">Photopea&lt;/h2>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://github.com/photopea/photopea">GitHub 项目，photopea/photopea&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.photopea.com/">官网&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>在线图片编辑工具&lt;/p>
&lt;h2 id="photodemon">PhotoDemon&lt;/h2>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://github.com/tannerhelland/PhotoDemon">GitHub 项目，tannerhelland/PhotoDemon&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://photodemon.org/">官网&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>小巧玲珑的图片编辑工具&lt;/p>
&lt;p>图片处理工具&lt;/p>
&lt;h2 id="其他">其他&lt;/h2>
&lt;p>&lt;a href="https://github.com/Sanster/lama-cleaner">Lama Cleaner&lt;/a> # 基于 SOTA AI 模型构建的开源图片处理工具&lt;/p></description></item><item><title>Docs: 解谜计算机科学</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/2.%E7%BC%96%E7%A8%8B/%E8%A7%A3%E8%B0%9C%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E8%A7%A3%E8%B0%9C%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/2.%E7%BC%96%E7%A8%8B/%E8%A7%A3%E8%B0%9C%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E8%A7%A3%E8%B0%9C%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="http://www.yinwang.org/blog-cn/2018/04/13/computer-science">王垠博客，解谜计算机科学&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Category:Computer_science">Wiki 分类，Computer science(计算机科学)&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Category:Computer_programming">Wiki 分类，Computer programming(计算机编程)&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Category:Programming_language_concepts">Wiki 分类，Programming language concepts(编程语言概念)&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Category:Programming_constructs">Wiki 分类，Programming constructs(编程结构)&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Category:Programming_languages">Wiki 分类，Programming languages(编程语言)&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Category:Programming_paradigms">Wiki 分类，Programming paradigms(编程范式)&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Identifier_(computer_languages)">Wiki,Identifier(标识符)&lt;/a>
&lt;ul>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Symbol">Wiki,Symbol(符号)&lt;/a>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Data_type">Wiki,DataType&lt;/a>(数据类型)&lt;/li>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Variable_(computer_science)">Wiki,Variables&lt;/a>(变量)&lt;/li>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Assignment_(computer_science)">Wiki,Assignment&lt;/a>(赋值)&lt;/li>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Declaration_(computer_programming)">Wiki,Declaration(声明) 与 Definition(定义)&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>要掌握一个学科的精髓，不能从细枝末节开始。人脑的能力很大程度上受限于信念。一个人不相信自己的时候，他就做不到本来可能的事。信心是很重要的，信心却容易被挫败。如果只见树木不见森林，人会失去信心，以为要到猴年马月才能掌握一个学科。&lt;/p>
&lt;p>所以我们不从 “树木” 开始，而是引导读者一起来探索这背后的“森林”，把计算机科学最根本的概念用浅显的例子解释，让读者领会到它们的本质。把这些概念稍作发展，你就得到逐渐完整的把握。你一开头就掌握着整个学科，而且一直掌握着它，只不过增添更多细节而已。这就像画画，先勾勒出轮廓，一遍遍的增加细节，日臻完善，却不失去对大局的把握。&lt;/p>
&lt;p>一般计算机专业的学生学了很多课程，可是直到毕业都没能回答一个基础问题：什么是计算？这一章会引导你去发现这个问题的答案。不要小看这基础的问题，它经常是解决现实问题的重要线索。世界上有太多不理解它的人，他们走了很多的弯路，掉进很多的坑，制造出过度复杂或者有漏洞的理论和技术。&lt;/p>
&lt;p>接下来，我们就来理解几个关键的概念，由此接触到计算的本质。&lt;/p>
&lt;h2 id="手指算术">手指算术&lt;/h2>
&lt;p>每个人都做过计算，只是大部分人都没有理解自己在做什么。回想一下幼儿园（大概四岁）的时候，妈妈问你：“帮我算一下，4+3 等于几？” 你掰了一会手指，回答：7。当你掰手指的时候，你自己就是一台简单的计算机。&lt;/p>
&lt;p>不要小看了这手指算术，它蕴含着深刻的原理。计算机科学植根于这类非常简单的过程，而不是复杂的高等数学。&lt;/p>
&lt;p>现在我们来回忆一下这个过程。这里应该有一段动画，但现阶段还没有。请你对每一步发挥一下想象力，增加点 “画面感”。&lt;/p>
&lt;ol>
&lt;li>当妈妈问你 “4+3 等于几” 的时候，她是一个程序员，你是一台计算机。计算机得到程序员的输入：4，+，3。&lt;/li>
&lt;li>听到妈妈的问题之后，你拿出两只手，左手伸出四个指头，右手伸出三个指头。&lt;/li>
&lt;li>接着你开始自己的计算过程。一根根地数那些竖起来的手指，每数一根你就把它弯下去，表示它已经被数过了。你念道：“1，2，3，4，5，6，7。”&lt;/li>
&lt;li>现在已经没有手指伸着，所以你把最后数到的那个数作为答案：7！整个计算过程就结束了。&lt;/li>
&lt;/ol>
&lt;h2 id="identifier标识符-和-model模型">Identifier(标识符) 和 Model(模型)&lt;/h2>
&lt;p>这里的幼儿园手指算术包含着深刻的哲学问题，现在我们来初步体会一下这个问题。&lt;/p>
&lt;p>当妈妈说 “帮我算 4+3” 的时候，4，+，3，三个字符传到你耳朵里，它们都是 &lt;strong>Identifier(标识符)&lt;/strong>，有的时候也称为 &lt;strong>symbol(符号)&lt;/strong>。符号是 “表面” 的东西：光是盯着 “4” 和“3”这两个阿拉伯数字的曲线，一个像旗子，一个像耳朵，你是不能做什么的。你需要先用脑子把它们转换成对应的“模型”（model）。这就是为什么你伸出两只手，一只手表示 4，另一只表示 3。&lt;/p>
&lt;p>这两只手的手势是 “可操作” 的。比如，你把左手再多弯曲一个手指，它就变成 “3”。你再伸开一根手指，它就变成“5”。所以手指是一个相当好的机械模型，它是可以动，可操作的。把符号“4” 和“3”转换成手指模型之后，你就可以开始计算了。&lt;/p>
&lt;p>你怎么知道 “4” 和“3”对应什么样的手指模型呢？因为妈妈以前教过你。十根手指，对应着 1 到 10 十个数。这就是为什么人都用十进制数做算术。&lt;/p>
&lt;p>我们现在没必要深究这个问题。我只是提示你，分清 “符号” 和“模型”是重要的。&lt;/p>
&lt;h2 id="计算图">计算图&lt;/h2>
&lt;p>在计算机领域，我们经常用一些抽象的图示来表达计算的过程，这样就能直观地看到信息的流动和转换。这种图示看起来是一些形状用箭头连接起来。我在这里把它叫做 “计算图”。&lt;/p>
&lt;p>对于以上的手指算术 &lt;code>4 + 3&lt;/code>，我们可以用下图来表示它：&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/85e3436b-9762-45b3-b0bb-38c1f87e416d/adder.png" alt="">&lt;/p>
&lt;p>图中的箭头表示信息的流动方向。说到 “流动”，你可以想象一下水的流动。首先我们看到数字 4 和 3 流进了一个圆圈，圆圈里有一个“+” 号。这个圆圈就是你，一个会做手指加法的小孩。妈妈给你两个数 4 和 3，你现在把它们加起来，得到 7 作为结果。&lt;/p>
&lt;p>注意圆圈的输入和输出方向是由箭头决定的，我们可以根据需要调整那些箭头的位置，只要箭头的连接关系和方向不变就行。它们不一定都是从左到右，也可能从右到左或者从上到下，但 “出入关系” 都一样：4 和 3 进去，结果 7 出来。比如它还可以是这样：&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/85e3436b-9762-45b3-b0bb-38c1f87e416d/adder-topdown.png" alt="">&lt;/p>
&lt;p>我们用带加号的圆圈表示一个 “加法器”。顾名思义，加法器可以帮我们完成加法。在上个例子里，你就是一个加法器。我们也可以用其他装置作为加法器，比如一堆石头，一个算盘，某种电子线路…… 只要它能做加法就行。&lt;/p>
&lt;p>具体要怎么做加法，就像你具体如何掰手指，很多时候我们是不关心的，我们只需要知道这个东西能做加法就行。圆圈把具体的加法操作给 “抽象化” 了，这个蓝色的圆圈可以代表很多种东西。抽象（abstraction）是计算机科学至关重要的思维方法，它帮助我们进行高层面的思考，而不为细节所累。&lt;/p>
&lt;h2 id="expression表达式">Expression(表达式)&lt;/h2>
&lt;p>计算机科学当然不止 4 + 3 这么简单，但它的基本元素确实是如此简单。我们可以创造出很复杂的系统，然而归根结底，它们只是在按某种顺序计算像 4 + 3 这样的东西。&lt;/p>
&lt;p>4 + 3 是一个很简单的表达式（expression）。你也许没听说过 “表达式” 这个词，但我们先不去定义它。我们先来看一个稍微复杂一些的表达式：&lt;/p>
&lt;p>这个表达式比 &lt;code>4 + 3&lt;/code> 多了一个运算，我们把它叫做 “复合表达式”。这个表达式也可以用计算图来表示：&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/85e3436b-9762-45b3-b0bb-38c1f87e416d/add-mult.png" alt="">&lt;/p>
&lt;p>你知道它为什么是这个样子吗？它表示的意思是，先计算 &lt;code>4 + 3&lt;/code>，然后把结果（7）传送到一个 “乘法器”，跟 2 相乘，得到最后的结果。那正好就是 &lt;code>2 * (4 + 3)&lt;/code> 这个表达式的含义，它的结果应该是 14。&lt;/p>
&lt;p>为什么要先计算 &lt;code>4 + 3&lt;/code> 呢？因为当我们看到乘法器 &lt;code>2 * ...&lt;/code> 的时候，其中一个输入（2）是已知的，而另外一个输入必须通过加法器的输出得到。加法器的结果是由 4 和 3 相加得到的，所以我们必须先计算 &lt;code>4 + 3&lt;/code>，然后才能与 2 相乘。&lt;/p>
&lt;p>小学的时候，你也许学过：“括号内的内容要先计算”。其实括号只是 “符号层” 的东西，它并不存在于计算图里面。我这里讲的“计算图”，其实才是本质的东西。数学的括号一类的东西，都只是表象，它们是符号或者叫“语法”。从某种意义上讲，计算图才是表达式的本质或者“模型”，而“2 * (4 + 3)” 这串符号，只是对计算图的一种表示或者 “编码”（coding）。&lt;/p>
&lt;p>这里我们再次体会到了 “符号” 和“模型”的差别。符号是对模型的 “表示” 或者“编码”。我们必须从符号得到模型，才能进行操作。这种从符号到模型的转换过程，在计算机科学里叫做“语法分析”（parsing）。我们会在后面的章节理解这个过程。&lt;/p>
&lt;p>我们现在来给表达式做一个初步的定义。这并不是完整的定义，但你应该试着理解这种定义的方式。稍后我们会逐渐补充这个定义，逐渐完善。&lt;/p>
&lt;p>定义（表达式）：&lt;strong>表达式&lt;/strong>可以是如下几种东西。&lt;/p>
&lt;ol>
&lt;li>数字是一个表达式。比如 1，2，4，15，……&lt;/li>
&lt;li>表达式 + 表达式。两个表达式相加，也是表达式。&lt;/li>
&lt;li>表达式 - 表达式。两个表达式相减，也是表达式。&lt;/li>
&lt;li>表达式 * 表达式。两个表达式相乘，也是表达式。&lt;/li>
&lt;li>表达式 / 表达式。两个表达式相除，也是表达式。&lt;/li>
&lt;/ol>
&lt;p>注意，由于我们之前讲过的符号和模型的差别，为了完全忠于我们的本质认识，这里的 “表达式 + 表达式” 虽然看起来是一串符号，它必须被想象成它所对应的模型。当你看到 “表达式” 的时候，你的脑子里应该浮现出它对应的计算图，而不是一串符号。这个计算图的画面大概是这个样子，其中左边的大方框里可以是任意两个表达式。&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/85e3436b-9762-45b3-b0bb-38c1f87e416d/expression-graph.png" alt="">&lt;/p>
&lt;p>是不是感觉这个定义有点奇怪？因为在 “表达式” 的定义里，我们用到了 “表达式” 自己。这种定义叫做“递归定义”。所谓&lt;strong>递归&lt;/strong>（recursion），就是在一个东西的定义里引用这个东西自己。看上去很奇怪，好像绕回去了一样。递归是一个重要的概念，我们会在将来深入理解它。&lt;/p>
&lt;p>现在我们可以来验证一下，根据我们的定义，&lt;code>2 * (4 + 3)&lt;/code> 确实是一个表达式：&lt;/p>
&lt;ul>
&lt;li>首先根据第一种形式，我们知道 4 是表达式，因为它是一个数字。3 也是表达式，因为它是一个数字。&lt;/li>
&lt;li>所以 &lt;code>4 + 3&lt;/code> 是表达式，因为 &lt;code>+&lt;/code> 的左右都是表达式，它满足表达式定义的第二种形式。&lt;/li>
&lt;li>所以 &lt;code>2 * (4 + 3)&lt;/code> 是表达式，因为 &lt;code>*&lt;/code> 的左右都是表达式，它满足表达式定义的第四种形式。&lt;/li>
&lt;/ul>
&lt;h2 id="parallel-computing并行计算">Parallel Computing(并行计算)&lt;/h2>
&lt;p>考虑这样一个表达式：&lt;/p>
&lt;pre>&lt;code>(4 + 3) * (1 + 2)
&lt;/code>&lt;/pre>
&lt;p>它对应一个什么样的计算图呢？大概是这样：
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/85e3436b-9762-45b3-b0bb-38c1f87e416d/parallel.png" alt="">
如果妈妈只有你一个小孩，你应该如何用手指算出它的结果呢？你大概有两种办法。&lt;/p>
&lt;p>第一种办法：先算出 4+3，结果是 7。然后算出 1+2，结果是 3。然后算 7*3，结果是 21。&lt;/p>
&lt;p>第二种办法：先算出 1+2，结果是 3。然后算出 4+3，结果是 7。然后算 7*3，结果是 21。&lt;/p>
&lt;p>注意到没有，你要么先算 4+3，要么先算 1+2，你不能同时算 4+3 和 1+2。为什么呢？因为你只有两只手，所以算 4+3 的时候你就没法算 1+2，反之也是这样。总之，你妈妈只有你一个加法器，所以一次只能做一个加法。&lt;/p>
&lt;p>现在假设你还有一个妹妹，她跟你差不多年纪，她也会手指算术。妈妈现在就多了一些办法来计算这个表达式。她可以这样做：让你算 4+3，不等你算完，马上让妹妹算 1+2。等到你们的结果（7 和 3）都出来之后，让你或者妹妹算 7*3。&lt;/p>
&lt;p>发现没有，在某一段时间之内，你和妹妹_同时_在做加法计算。这种时间上重叠的计算，叫做&lt;strong>并行计算&lt;/strong>（parallel computing）。&lt;/p>
&lt;p>你和妹妹同时计算，得到结果的速度可能会比你一个人算更快。如果你妈妈还有其它几个孩子，计算复杂的式子就可能快很多，这就是并行计算潜在的好处。所谓 “潜在” 的意思是，这种好处不一定会实现。比如，如果你的妹妹做手指算数的速度比你慢很多，你做完了 4+3，只好等着她慢慢的算 1+2。这也许比你自己依次算 4+3 和 1+2 还要慢。&lt;/p>
&lt;p>即使妹妹做算术跟你一样快，这里还有个问题。你和妹妹算出结果 7 和 3 之后，得把结果传递给下一个计算 7*3 的那个人（也许是你，也许是你妹妹）。这种 “通信” 会带来时间的延迟，叫做“通信开销”。如果你们其中一个说话慢，这比起一个人来做计算可能还要慢。&lt;/p>
&lt;p>如何根据计算单元能力的不同和通信开销的差异，来最大化计算的效率，降低需要的时间，就成为了并行计算领域研究的内容。并行计算虽然看起来是一个 “博大精深” 的领域，可是你如果理解了我这里说的那点东西，就很容易理解其余的内容。&lt;/p>
&lt;h2 id="variable变量-和-assignment赋值">Variable(变量) 和 Assignment(赋值)&lt;/h2>
&lt;p>变量是与关联的&lt;strong>符号名称(变量的标识符)&lt;/strong> 配对的&lt;strong>存储位置(由内存地址标识)&lt;/strong>。这个&lt;strong>存储地址&lt;/strong>其包含称为&lt;strong>值&lt;/strong>的一些已知或未知数量的信息;变量的&lt;strong>存储地址&lt;/strong>是通过一个名叫&lt;strong>指针&lt;/strong>的东西来获取，也是&lt;strong>值&lt;/strong>的一种，指针的&lt;strong>值&lt;/strong>就是其所指向的变量的&lt;strong>存储地址&lt;/strong>；注意：变量的&lt;strong>存储地址的值&lt;/strong>与&lt;strong>存储地址中包含的值&lt;/strong>是两个不同的东西。指针与变量的代码示例&lt;/p>
&lt;p>变量是一个可以改变内容的固定标识符，比如我定义“这台电脑的名字”叫“XXX”，“这台电脑的名字”就是标识符(不变的内容)，存在于计算机的某个位置，“XXX”就是可以改变的内容 i.e.变量的值，给不变的内容定义不同的内容&lt;/p>
&lt;ul>
&lt;li>比如 X=1，X=2，X=3 等等，&lt;strong>X&lt;/strong> 就是不变的，1，2，3 等等都是可变的，X 就是一个变量，可以被赋予某些内容&lt;/li>
&lt;li>比如：&lt;strong>LANG&lt;/strong> 是一个语言的规定，你赋予他一个内容，就相当于定义了这个环境下所显示的语言，比如 LANG=US，LANG=CN 等等。LANG 这叫定义语言，这是不变的，可变的是后面的自定义内容，语言（不变）= 英语，汉语，日语（可变）。&lt;/li>
&lt;/ul>
&lt;p>如果你有一个复杂的表达式，比如&lt;/p>
&lt;pre>&lt;code>(5 - 3) * (4 + (2 * 3 - 5) * 6)
&lt;/code>&lt;/pre>
&lt;p>由于它有比较多的嵌套，人的眼睛是难以看清楚的，它要表达的意义也会难懂。这时候，你希望可以用一些 “名字” 来代表中间结果，这样表达式就更容易理解。&lt;/p>
&lt;p>打个比方，这就像你有一个亲戚，他是你妈妈的表姐的女儿的丈夫。你不想每次都称他 “我妈妈的表姐的女儿的丈夫”，所以你就用他的名字“叮当” 来指代他，一下子就简单了。&lt;/p>
&lt;p>我们来看一个例子。之前的复合表达式&lt;/p>
&lt;p>其实可以被转换为等价的，含有变量的代码：&lt;/p>
&lt;pre>&lt;code>{
a = 4 + 3 // 变量 a 得到 4+3 的值
2 * a // 代码块的值
}
&lt;/code>&lt;/pre>
&lt;p>其中 &lt;code>a&lt;/code> 是一个名字。&lt;code>a = 4 + 3&lt;/code> 是一个 “赋值语句”，它的意思是：用 a 来代表 4 + 3 的值。这种名字，计算机术语叫做 &lt;strong>variable(变量)&lt;/strong>。&lt;/p>
&lt;p>这段代码的意思可以简单地描述为：计算 &lt;code>4 + 3&lt;/code>，把它的结果表示为 &lt;code>a&lt;/code>，然后计算 &lt;code>2 * a&lt;/code> 作为最后的结果。&lt;/p>
&lt;p>有些东西可能扰乱了你的视线。两根斜杠 &lt;code>//&lt;/code> 后面一直到行末的文字叫做 “注释”，是给人看的说明文字。它们对代码的逻辑不产生作用，执行的时候可以忽略。许多语言都有类似这种注释，它们可以帮助阅读的人，但是会被机器忽略。&lt;/p>
&lt;p>这段代码执行过程会是这样：先计算 &lt;code>4 + 3&lt;/code> 得到 7，用 &lt;code>a&lt;/code> 记住这个中间结果 7。接着计算 &lt;code>2 * a&lt;/code> ，也就是计算 &lt;code>2 * 7&lt;/code>，所以最后结果是 14。很显然，这跟 &lt;code>2 * (4 + 3)&lt;/code> 的结果是一样的。&lt;/p>
&lt;p>&lt;code>a&lt;/code> 叫做一个变量，它是一个符号，可以用来代表任意的值。除了 &lt;code>a&lt;/code>，你还有许多的选择，比如 b, c, d, x, y, foo, bar, u21… 只要它不会被误解成其它东西就行。&lt;/p>
&lt;p>如果你觉得这里面的 “神奇” 成分太多，那我们现在来做更深一层的理解……&lt;/p>
&lt;p>再看一遍上面的代码。这整片代码叫做一个 “代码块”（block），或者叫一个 “序列”（sequence）。这个代码块包括两条语句，分别是 &lt;code>a = 4 + 3&lt;/code> 和 &lt;code>2 * a&lt;/code>。代码块里的语句会从上到下依次执行。所以我们先执行 &lt;code>a = 4 + 3&lt;/code>，然后执行 &lt;code>2 * a&lt;/code>。&lt;/p>
&lt;p>最后一条语句 &lt;code>2 * a&lt;/code> 比较特别，它是这个代码块的 “值”，也就是最后结果。之前的语句都是在为生成这个最后的值做准备。换句话说，这整个代码块的值就是 &lt;code>2 * a&lt;/code> 的值。不光这个例子是这样，这是一个通用的原理：代码块的最后一条语句，总是这个代码块的值。&lt;/p>
&lt;p>我们在代码块的前后加上花括号 &lt;code>{...}&lt;/code> 进行标注，这样里面的语句就不会跟外面的代码混在一起。这两个花括号叫做 “边界符”。我们今后会经常遇到代码块，它存在于几乎所有的程序语言里，只是语法稍有不同。比如有些语言可能用括号 &lt;code>(...)&lt;/code> 或者 &lt;code>BEGIN...END&lt;/code> 来表示边界，而不是用花括号。&lt;/p>
&lt;p>这片代码已经有点像常用的编程语言了，但我们暂时不把它具体化到某一种语言。我不想固化你的思维方式。在稍后的章节，我们会把这种抽象的表达法对应到几种常见的语言，这样一来你就能理解几乎所有的程序语言。&lt;/p>
&lt;p>另外还有一点需要注意，同一个变量可以被多次赋值。它的值会随着赋值语句而改变。举个例子：&lt;/p>
&lt;pre>&lt;code>{
a = 4 + 3
b = a
a = 2 * 5
c = a
}
&lt;/code>&lt;/pre>
&lt;p>这段代码执行之后，&lt;code>b&lt;/code> 的值是 7，而 &lt;code>c&lt;/code> 的值是 10。你知道为什么吗？因为 &lt;code>a = 4 + 3&lt;/code> 之后，a 的值是 7。&lt;code>b = a&lt;/code> 使得 &lt;code>b&lt;/code> 得到值 7。然后 &lt;code>a = 2 * 5&lt;/code> 把 &lt;code>a&lt;/code> 的值改变了，它现在是 10。所以 &lt;code>c = a&lt;/code> 使得 &lt;code>c&lt;/code> 得到 10。&lt;/p>
&lt;p>对同一个变量多次赋值虽然是可以的，但通常来说这不是一种好的写法，它可能引起程序的混淆，应该尽量避免。只有当变量表示的 “意义” 相同的时候，你才应该对它重复赋值。&lt;/p>
&lt;h2 id="data-type数据类型">Data type(数据类型)&lt;/h2>
&lt;p>**Data Type(数据类型) **用来对一组相关值进行分类，描述可对其执行的操作并定义它们的存储方式。通常也会称为 &lt;strong>Literal(字面量)&lt;/strong>&lt;/p>
&lt;h2 id="compile编译">Compile(编译)&lt;/h2>
&lt;p>一旦引入了变量，我们就可以不用复合表达式。因为你可以把任意复杂的复合表达式拆开成 “单操作算术表达式”（像 4 + 3 这样的），使用一些变量记住中间结果，一步一步算下去，得到最后的结果。&lt;/p>
&lt;p>举一个复杂点的例子，也就是这一节最开头的那个表达式：&lt;/p>
&lt;pre>&lt;code>(5 - 3) * (4 + (2 * 3 - 5) * 6)
&lt;/code>&lt;/pre>
&lt;p>它可以被转化为一串语句：&lt;/p>
&lt;pre>&lt;code>{
a = 2 * 3
b = a - 5
c = b * 6
d = 4 + c
e = 5 - 3
e * d
}
&lt;/code>&lt;/pre>
&lt;p>最后的表达式 &lt;code>e * d&lt;/code>，算出来就是原来的表达式的值。你观察一下，是不是每个操作都非常简单，不包含嵌套的复合表达式？你可以自己验算一下，它确实算出跟原表达式一样的结果。&lt;/p>
&lt;p>在这里，我们自己动手做了 &lt;strong>compiler(编译器)&lt;/strong> 的工作。通常来说，编译器是一种程序，它的任务是把一片代码“翻译” 成另外一种等价形式。这里我们没有写编译器，可是我们自己做了编译器的工作。我们手动地把一个嵌套的复合表达式，编译成了一系列的简单算术语句。&lt;/p>
&lt;p>这些语句的结果与原来的表达式完全一致。这种保留原来语义的翻译过程，叫做 &lt;strong>compile(编译)&lt;/strong>。&lt;/p>
&lt;p>我们为什么需要编译呢？原因有好几种。我不想在这里做完整的解释，但从这个例子我们可以看到，编译之后我们就不再需要复杂的嵌套表达式了。我们只需要设计很简单的，只会做单操作算术的机器，就可以算出复杂的嵌套的表达式。实际上最后这段代码已经非常接近现代处理器（CPU）的汇编代码（assembly）。我们只需要多加一些转换，它就可以变成机器指令。&lt;/p>
&lt;p>我们暂时不写编译器，因为你还缺少一些必要的知识。这当然也不是编译技术的所有内容，它还包含另外一些东西。但从这一开头，你就已经初步理解了编译器是什么，你只需要在将来加深这种理解。&lt;/p>
&lt;h2 id="function函数">Function(函数)&lt;/h2>
&lt;p>到目前为止，我们做的计算都是在已知的数字之上，而在现实的计算中我们往往有一些未知数。比如我们想要表达一个 “风扇控制器”，有了它之后，风扇的转速总是当前气温的两倍。这个“当前气温” 就是一个未知数。&lt;/p>
&lt;p>我们的 “风扇控制器” 必须要有一个“输入”（input），用于得到当前的温度 t，它是一个温度传感器的读数。它还要有一个输出，就是温度的两倍。&lt;/p>
&lt;p>那么我们可以用这样的方式来表达我们的风扇控制器：&lt;/p>
&lt;p>不要把这想成任何一种程序语言，这只是我们自己的表达法。箭头 &lt;code>-&amp;gt;&lt;/code> 的左边表示输入，右边表示输出，够简单吧。&lt;/p>
&lt;p>你可以把 &lt;code>t&lt;/code> 想象成从温度传感器出来的一根电线，它连接到风扇控制器上，风扇控制器会把它的输入（t）乘以 2。这个画面像这个样子：
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/85e3436b-9762-45b3-b0bb-38c1f87e416d/function1.png" alt="">
我们谈论风扇控制器的时候，其实不关心它的输入是哪里来的，输出到哪里去。如果我们把温度传感器和风扇从画面里拿掉，就变成这个样子：
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/85e3436b-9762-45b3-b0bb-38c1f87e416d/function2.jpg" alt="">
这幅图才是你需要认真理解的函数的计算图。你发现了吗，这幅图画正好对应了之前的风扇控制器的符号表示：&lt;code>t -&amp;gt; t*2&lt;/code>。看到符号就想象出画面，你就得到了符号背后的模型。&lt;/p>
&lt;p>像 &lt;code>t -&amp;gt; t*2&lt;/code> 这样具有未知数作为输入的构造，我们把它叫做 function(函数)。其中 &lt;code>t&lt;/code> 这个符号，叫做这个函数的参数。&lt;/p>
&lt;h2 id="parameter参数-与-variable变量">Parameter(参数) 与 Variable(变量)&lt;/h2>
&lt;p>你可能发现了，函数的参数和我们之前了解的 “变量” 是很类似的，它们都是一个符号。之前我们用了 &lt;code>a, b, c, d, e&lt;/code> 现在我们有一个 &lt;code>t&lt;/code>，这些名字我们都是随便起的，只要它们不要重复就好。如果名字重复的话，可能会带来混淆和干扰。&lt;/p>
&lt;p>其实参数和变量这两种概念不只是相似，它们的本质就是一样的。如果你深刻理解它们的相同本质，你的脑子就可以少记忆很多东西，而且它可能帮助你对代码做出一些有趣而有益的转化。在上一节你已经看到，我用 “电线” 作为比方来帮助你理解参数。你也可以用同样的方法来理解变量。&lt;/p>
&lt;p>比如我们之前的变量 &lt;code>a&lt;/code>：&lt;/p>
&lt;p>它可以被想象成什么样的画面呢？
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/85e3436b-9762-45b3-b0bb-38c1f87e416d/wire.png" alt="">
我故意把箭头方向画成从右往左，这样它就更像上面的代码。从这个图画里，你也许可以看到变量 &lt;code>a&lt;/code> 和风扇控制器图里的参数 &lt;code>t&lt;/code>，其实没有任何本质差别。它们都表示一根电线，那根电线进入乘法器，将会被乘以 2，然后输出。如果你把这些都看成是电路，那么变量 &lt;code>a&lt;/code> 和参数 &lt;code>t&lt;/code> 都代表一根电线而已。&lt;/p>
&lt;p>然后你还发现一个现象，那就是你可以把 &lt;code>a&lt;/code> 这个名字换成任何其它名字（比如 &lt;code>b&lt;/code>），而这幅图不会产生实质的改变。&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/85e3436b-9762-45b3-b0bb-38c1f87e416d/rename.png" alt="">&lt;/p>
&lt;p>这说明什么问题呢？这说明以下的代码（把 &lt;code>a&lt;/code> 换成了 &lt;code>b）&lt;/code>跟之前的是等价的：&lt;/p>
&lt;p>根据几乎一样的电线命名变化，你也可以对之前的函数得到一样的结论：&lt;code>t -&amp;gt; t*2&lt;/code> 和 &lt;code>u -&amp;gt; u*2&lt;/code>，和 &lt;code>x -&amp;gt; x*2&lt;/code> 都是一回事。&lt;/p>
&lt;p>名字是很重要的东西，但它们具体叫什么，对于机器并没有实质的意义，只要它们不要相互混淆就可以。但名字对于人是很重要的，因为人脑没有机器那么精确。不好的变量和参数名会导致代码难以理解，引起程序员的混乱和错误。所以通常说来，你需要给变量和参数起好的名字。&lt;/p>
&lt;p>什么样的名字好呢？我会在后面集中讲解。&lt;/p>
&lt;h2 id="named-function有名字的函数">Named function(有名字的函数)&lt;/h2>
&lt;p>既然变量可以代表 “值”，那么一个自然的想法，就是让变量代表函数。所以就像我们可以写&lt;/p>
&lt;p>我们似乎也应该可以写&lt;/p>
&lt;p>对的，你可以这么做。&lt;code>f = t-&amp;gt;t*2&lt;/code> 还有一个更加传统的写法，就像数学里的函数写法：&lt;/p>
&lt;p>请仔细观察 &lt;code>t&lt;/code> 的位置变化。我们在函数名字的右边写一对括号，在里面放上参数的名字。&lt;/p>
&lt;p>注意，你不可以只写&lt;/p>
&lt;p>你必须明确的指出函数的参数是什么，否则你就不会明白函数定义里的 &lt;code>t&lt;/code> 是什么东西。明确指出 &lt;code>t&lt;/code> 是一个 “输入”，你才会知道它是函数的输入，是一个未知数，&lt;strong>而不是在函数外面定义的其它变量&lt;/strong>。&lt;/p>
&lt;p>这个看似简单的道理，很多数学家都不明白，所以他们经常这样写书：&lt;/p>
&lt;blockquote>
&lt;p>有一个函数 y = x*2&lt;/p>
&lt;/blockquote>
&lt;p>这是错误的，因为他没有明确指出 “&lt;code>x&lt;/code> 是函数 y 的参数”。如果这句话之前他们又定义过 &lt;code>x&lt;/code>，你就会疑惑这是不是之前那个 &lt;code>x&lt;/code>。很多人就是因为这些糊里糊涂的写法而看不懂数学书。这不怪他们，只怪数学家自己对于语言不严谨。&lt;/p>
&lt;h2 id="function-call函数调用">Function call(函数调用)&lt;/h2>
&lt;p>有了函数，我们可以给它起名字，可是我们怎么使用它的值呢？&lt;/p>
&lt;p>由于函数里面有未知数（参数），所以你必须告诉它这些未知数，它里面的代码才会执行，给你结果。比如之前的风扇控制器函数&lt;/p>
&lt;p>它需要一个温度作为输入，才会给你一个输出。于是你就这样给它一个输入：&lt;/p>
&lt;p>你把输入写在函数名字后面的括号里。那么你就会得到输出：4。也就是说 &lt;code>f(2)&lt;/code> 的值是 4。&lt;/p>
&lt;p>如果你没有调用一个函数，函数体是不会被执行的。因为它不知道未知数是什么，所以什么事也做不了。那么我们定义函数的时候，比如&lt;/p>
&lt;p>当看到这个定义的时候，机器应该做什么呢？它只是记录下：有这么一个函数，它的参数是 &lt;code>t&lt;/code>，它需要计算 &lt;code>t*2&lt;/code>，它的名字叫 &lt;code>f&lt;/code>。但是机器不会立即计算 &lt;code>t*2&lt;/code>，因为它不知道 &lt;code>t&lt;/code> 是多少。&lt;/p>
&lt;h2 id="branch分支">Branch(分支)&lt;/h2>
&lt;p>直到现在，我们的代码都是从头到尾，闷头闷脑地执行，不问任何问题。我们缺少一种 “问问题” 的方法。比如，如果我想表达这样一个“食物选择器”：如果气温低于 22 度，就返回 “hotpot” 表示今天吃火锅，否则返回 “ice cream” 表示今天吃冰激凌。&lt;/p>
&lt;p>我们可以把它图示如下：
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/85e3436b-9762-45b3-b0bb-38c1f87e416d/branch.png" alt="">
中间这种判断结构叫做 “分支”（branching），它一般用菱形表示。为什么叫分支呢？你想象一下，代码就像一条小溪，平时它沿着一条路线流淌。当它遇到一个棱角分明的大石头，就分成两个支流，分开流淌。&lt;/p>
&lt;p>我们的判断条件 &lt;code>t &amp;lt; 22&lt;/code> 就像一块大石头，我们的 “代码流” 碰到它就会分开成两支，分别做不同的事情。跟溪流不同的是，这种分支不是随机的，而是根据条件来决定，而且分支之后只有一支继续执行，而另外一边不会被执行。&lt;/p>
&lt;p>我们现在看到的都是图形化表示的模型，为了书写方便，现在我们要从符号的层面来表示这个模型。我们需要一种符号表示法来表达分支，我们把它叫做 &lt;code>if&lt;/code>（如果）。我们的饮料选择器代码可以这样写：&lt;/p>
&lt;pre>&lt;code>t -&amp;gt; if (t &amp;lt; 22)
{
&amp;quot;hotpot&amp;quot;
}
else
{
&amp;quot;ice cream&amp;quot;
}
&lt;/code>&lt;/pre>
&lt;p>它是一个函数，输入是一个温度。&lt;code>if&lt;/code> 后面的括号里放我们的判断条件。后面接着条件成立时执行的代码块，然后是一个 &lt;code>else&lt;/code>，然后是条件不成立时执行的代码。它说：如果温度低于 22 度，我们就吃火锅，否则就吃冰激凌。&lt;/p>
&lt;p>其中的 &lt;code>else&lt;/code> 是一个特殊的符号，它表示 “否则”。看起来不知道为什么 &lt;code>else&lt;/code> 要在那里？对的，它只是一个装饰品。我们已经有足够的表达力来分辨两个分支，不过有了 &lt;code>else&lt;/code> 似乎更加好看一些。很多语言里面都有 else 这个标记词在那里，所以我也把它放在那里。&lt;/p>
&lt;p>这只是一个最简单的例子，其实那两个代码块里面不止可以写一条语句。你可以有任意多的语句，就像这样：&lt;/p>
&lt;pre>&lt;code>t -&amp;gt;
if (t &amp;lt; 22)
{
a = 4 + 3
b = a * 2
&amp;quot;hotpot&amp;quot;
}
else
{
x = &amp;quot;ice cream&amp;quot;
x
}
&lt;/code>&lt;/pre>
&lt;p>这段代码和之前是等价的，你知道为什么吗？&lt;/p>
&lt;h2 id="declaration声明-与-definition定义">Declaration(声明) 与 Definition(定义)&lt;/h2>
&lt;p>上面描述了很多计算机科学的基本要素，那么上面那么多字的描述，是如何定义的呢？~不定义一个东西，是没法使用它的~~~&lt;/p>
&lt;p>在计算机编程中，&lt;strong>Declaration(声明)&lt;/strong> 是一种语言结构，用以指定 Identifier(标识符) 的属性，i.e.声明一个词(标识符)代表什么，也就是说，将 Identifier(标识符) 绑定到某种概念上。&lt;/p>
&lt;blockquote>
&lt;p>比如，用白话说就是：我声明，A 表示一个函数、B 表示一个字符串类型的变量，等等&lt;/p>
&lt;/blockquote>
&lt;p>Declaration 最常用于函数、变量、常量、类型定义 等等。Declaration 用于向编译器宣布实体的存在，在某些强类型的编程语言中，使用 函数、变量、常量 等等要素之前需要先 Declaration 它们，再使用比如 为变量赋值、调用函数 等等)。&lt;/p>
&lt;p>在某些场景下，&lt;strong>Declaration(声明)&lt;/strong> 与 &lt;strong>Definition(定义)&lt;/strong> 这两个词比较容易混淆。&lt;/p>
&lt;ul>
&lt;li>在非正式用法中
&lt;ul>
&lt;li>Declaration 纯指声明(仅类型，无值或主体)&lt;/li>
&lt;li>Definition 指包含值或主体的声明。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>在正式使用中
&lt;ul>
&lt;li>Declaration 包含非正式用法中的两种含义。在 Declaration 的同时，有的时候我们会为标识符定义一个初始值。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>上面的描述，把定义当做了赋值的行为。实际上，Definition 还有另外一种行为含义，这种行为应该是在 Declaration 之前的。比如下面的例子：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>// 这里我们定义了一个类型与函数。定义时，指定了这些东西应该具有的属性
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>definition string XXXXX
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>definition func YYYYY
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>// 这里我们声明了一个类型与函数。
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>// 标识符A 绑定到了字符串
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>// 标识符B 绑定到了函数
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>var identifierA string
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>func iderntifierB&lt;span style="color:#f92672">(){&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Do Something
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>// 此时我们可以使用这些已经声明的标识符
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>stringType &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#34;Hello World&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>DefinitionFunc&lt;span style="color:#f92672">()&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>也就是说，Definition(定义) 这个词更符合人类的日常用于，定义一个事物，就是对这个事物进行总结，就好比科学，我们通过观察自然界的现象，来定义一个科学定律，然后通过定律推导出定理。总结一下就是：&lt;/p>
&lt;ul>
&lt;li>&lt;strong>Definition 用来指定 Type(类型)。不管是编程语言自带的基本类型，还是符合类型，甚至是自己自定义的类型，都称为“定义类型”&lt;/strong>&lt;/li>
&lt;li>&lt;strong>Declaration 用来指定 Identifier(标识符)，并将该 Identifier(标识符) 绑定到 Type(类型) 上。称为“声明标识符”&lt;/strong>&lt;/li>
&lt;/ul>
&lt;p>但是，在现代中，Declaration 与 Definition 经常会混用，经常会有人说：定义类型、声明类型、定义变量、声明变量、定义函数、声明函数 等等等等。&lt;/p>
&lt;p>比如，当我们使用一个未声明的变量时，某些编程语言经常会提示 undefined(未定义)~~~~o(╯□╰)o 其实，更准确的提示应该是 undeclared。&lt;/p>
&lt;blockquote>
&lt;p>说的就是你，Go 语言，Declaration 与 Definition 不分~~~
不过除了这个编译器的错误提示有歧义以外，其它描述基本都是准确的，绝大部分都是 Declaration(声明)，只有一个地方用到了 Definition(定义)，主要就是在 &lt;a href="https://go.dev/ref/spec#Type_declarations">Go 的参考&lt;/a>中，可以看到 Type Declaration 与 Type Definition 之间的区别。也就是说，只有在描述一个新的类型时，才称为“定义类型”&lt;/p>
&lt;ul>
&lt;li>比如 &lt;code>type XXXX struct&lt;/code>，我们就称为 &lt;strong>定义结构体&lt;/strong>，&lt;code>var structID XXXX&lt;/code>，我们就称为&lt;strong>声明 XXXX 类型结构体。&lt;/strong>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>后记：
其实，定义类型这个行为，再扩展一下，也可以称为建模，这是[面向对象编程](/docs/IT学习笔记/2.编程/解谜计算机科学/Object-oriented%20Programming(面向对象编程).md Programming(面向对象编程).md)的基本要素。人们通过对现实世界的观察、总结，定义了很多基本类型，比如 数字、字符串、布尔 等等。这些基本类型都是一个个已经建立好的模型，只不过是最基本的，而我们可以使用这些基本模型，建立更复杂的模型。所以，定义类型 这个行为，从某种角度来看，就是建立模型。&lt;/p>
&lt;h1 id="计算的要素">计算的要素&lt;/h1>
&lt;p>好了，现在你已经掌握了计算机科学的几乎所有基本要素。每一个编程语言都包括这些构造：&lt;/p>
&lt;ul>
&lt;li>基础的数值。比如整数，字符串，布尔值等。&lt;/li>
&lt;li>表达式。包括基本的算术表达式，嵌套的表达式。&lt;/li>
&lt;li>变量和赋值语句。&lt;/li>
&lt;li>分支语句。&lt;/li>
&lt;li>函数和函数调用。&lt;/li>
&lt;/ul>
&lt;p>你也许可以感觉到，我是把这些构造按照 “从小到大” 的顺序排列的。这也许可以帮助你的理解。&lt;/p>
&lt;p>现在你可以回想一下你对它们的印象。每当学习一种新的语言或者系统，你只需要在里面找到对应的构造，而不需要从头学习。这就是掌握所有程序语言的秘诀。这就像学开车一样，一旦你掌握了油门，刹车，换挡器，方向盘，速度表的功能和用法，你就学会了开所有的汽车，不管它是什么型号的汽车。&lt;/p>
&lt;p>我们在这一章不仅理解了这些要素，而且为它们定义了一种我们自己的 “语言”。显然这个语言只能在我们的头脑里运行，因为我们没有实现这个语言的系统。在后面的章节，我会逐渐的把我们这种语言映射到现有的多种语言里面，然后你就能掌握这些语言了。&lt;/p>
&lt;p>但是请不要以为掌握了语言就学会了编程或者学会了计算机科学。掌握语言就像学会了各种汽车部件的工作原理。几分钟之内，初学者就能让车子移动，转弯，停止。可是完了之后你还需要学习交通规则，你需要许许多多的实战练习和经验，掌握各种复杂情况下的策略，才能成为一个合格的驾驶员。如果你想成为赛车手，那就还需要很多倍的努力。&lt;/p>
&lt;p>但是请不要被我这些话吓到了，你没有那么多的竞争者。现在的情况是，世界上就没有很多合格的计算机科学驾驶员，更不要说把车开得流畅的赛车手。绝大部分的 “程序员” 连最基本的引擎，油门，刹车，方向盘的工作原理都不明白，思维方式就不对，所以根本没法独自上路，一上路就出车祸。很多人把过错归结在自己的车身上，以为换一辆车马上就能成为好的驾驶员。这是一种世界范围的计算机教育的失败。&lt;/p>
&lt;p>在后面的章节，我会引导你成为一个合格的驾驶员，随便拿一辆车就能开好。&lt;/p>
&lt;h1 id="什么是计算">什么是计算&lt;/h1>
&lt;p>现在你掌握了计算所需要的基本元素，可是什么是计算呢？我好像仍然没有告诉你。这是一个很哲学的问题，不同的人可能会告诉你不同的结果。我试图从最广义的角度来告诉你这个问题的答案。&lt;/p>
&lt;p>当你小时候用手指算 &lt;code>4+3&lt;/code>，那是计算。如果后来你学会了打算盘，你用算盘算 4+3，那也是计算。后来你从我这里学到了表达式，变量，函数，调用，分支语句…… 在每一新的构造加入的过程中，你都在了解不同的计算。&lt;/p>
&lt;p>所以从最广义来讲，计算就是 “机械化的信息处理”。所谓机械化，你可以用手指算，可以用算盘，可以用计算器，或者计算机。这些机器里面可以有代码，也可以没有代码，全是电子线路，甚至可以是生物活动或者化学反应。不同的机器也可以有不同的计算功能，不同的速度和性能……&lt;/p>
&lt;p>有这么多种计算的事实不免让人困惑，总害怕少了点什么，其实你可以安心。如果你掌握了上一节的 “计算要素”，那么你就掌握了几乎所有类型的计算系统所需要的东西。你在后面所需要做的只是加深这种理解，并且把它“对应” 到现实世界遇到的各种计算机器里面。&lt;/p>
&lt;p>为什么你可以相信计算机科学的精华就只有这些呢？因为计算就是处理信息，信息有它诞生的位置（输入设备，固定数值），它传输的方式（赋值，函数调用，返回值），它被查看的地方（分支）。你想不出对于信息还有什么其它的操作，所以你就很安心的相信了，这就是计算机科学这种 “棋类游戏” 的全部规则。&lt;/p>
&lt;p>（如果你觉得这篇文章有启发，可以点击这里&lt;a href="http://www.yinwang.org/blog-cn/2016/04/13/pay-blog">付费&lt;/a>）&lt;/p></description></item><item><title>Docs: 紧急模式或救援模式</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/x.linux-%E7%AE%A1%E7%90%86/%E6%80%A7%E8%83%BD%E8%AF%84%E4%BC%B0%E4%B8%8E%E6%95%85%E9%9A%9C%E5%A4%84%E7%90%86/%E6%95%85%E9%9A%9C%E5%A4%84%E7%90%86/%E7%B4%A7%E6%80%A5%E6%A8%A1%E5%BC%8F%E6%88%96%E6%95%91%E6%8F%B4%E6%A8%A1%E5%BC%8F/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/x.linux-%E7%AE%A1%E7%90%86/%E6%80%A7%E8%83%BD%E8%AF%84%E4%BC%B0%E4%B8%8E%E6%95%85%E9%9A%9C%E5%A4%84%E7%90%86/%E6%95%85%E9%9A%9C%E5%A4%84%E7%90%86/%E7%B4%A7%E6%80%A5%E6%A8%A1%E5%BC%8F%E6%88%96%E6%95%91%E6%8F%B4%E6%A8%A1%E5%BC%8F/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;p>Linux 系统难免出现问题，下面总结了一些在出现问题时，可以用到的修复方式。&lt;/p>
&lt;p>比如 单用户模式、GRUB 命令操作、Linux 救援模式 的故障修复案例。&lt;/p>
&lt;p>一般的故障修复，都是通过进入一个微型系统，并在微型系统中关联正常系统，来实现对正常系统进行修复操作的。常见的微型系统大体分为两类：&lt;/p>
&lt;ul>
&lt;li>&lt;strong>存在于内核中的微型系统，通过内核来启动&lt;/strong>&lt;/li>
&lt;li>&lt;strong>通过外部挂载(光盘、usb 等)的方式来启动&lt;/strong>
&lt;ul>
&lt;li>Preinstallation Environment 版本与 Live 版本是 Windows 和 Linux 的预安装系统的两种微型系统的称呼。&lt;/li>
&lt;li>部分 Linux 发行版的安装 iso 中也会自带一个微型系统（比如 CentOS），而没有专门的 Live 系统。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h1 id="emergency紧急-模式">Emergency(紧急) 模式&lt;/h1>
&lt;p>Linux 系统提供了紧急模式(类似 Windows 安全模式)，该模式镶嵌在内核中。可以在最小环境中(仅仅运行系统所需的必要程序)进行系统维护。在紧急模式中，Linux 引导进入根 shell，网络被禁用，只有少数进程运行。紧急模式可以用来修改文件系统损坏、还原配置文件、移动用户数据等。&lt;/p>
&lt;h2 id="启动紧急模式">启动紧急模式&lt;/h2>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/ewdpso/1616163959565-28b07db0-d297-4c04-bdf7-b31a43af0106.jpeg" alt="">&lt;/p>
&lt;p>在该界面选中想要使用的内核后，按 e 键 ，进入编辑启动参数界面&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/ewdpso/1616163959592-6d0be599-731a-4f6c-b6b1-9e195991cfb9.jpeg" alt="">&lt;/p>
&lt;p>在上图红框位置将 ro 改为 rw init=/sysroot/bin/sh 。然后按 ctrl+x 来启动。这时候，就进入了紧急模式，紧急模式的界面是像下图这样的&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/ewdpso/1616163959556-b1d3734e-d706-47fc-a83c-131c6f049baa.jpeg" alt="">&lt;/p>
&lt;p>这是一个 sh 的 shell(也可以启动其他 shell，比如 bash 等)，可以执行一些基本命令，目录结构如下&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>:/# ls
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>bin dev dracut-state.sh etc init lib lib64 proc root run sbin shutdown sys sysroot tmp usr var
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>其中 &lt;code>sysroot&lt;/code> 目录，就是我们正常启动系统时，所看到的 &lt;code>/&lt;/code> 目录&lt;/p>
&lt;p>在这种模式下，可以看到，仅有个别进程在运行，/init rhgb 是该系统模式下的第一个进程，与正常系统不同。&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/ewdpso/1616163959562-5047fe7d-4089-43e3-933c-0eb9ab6c80d4.jpeg" alt="">&lt;/p>
&lt;p>sh 进程是因为我们需要一个可以操作的 shell，所以在修改启动项时添加的。&lt;/p>
&lt;p>实际上，所谓的紧急模式，就是在安装 linux 系统时，内核中内置的一个微型系统，进入该微型系统后，咱正常系统的根目录，就被挂载到微型系统的/sysroot 下了，由于没有挂载其他物理磁盘，也没有任何多余进程运行，所以只要内核是好的，那么紧急模式是可以正常进入的。&lt;/p>
&lt;p>该模式可以用来修复一些与非内核错误的一些故障&lt;/p>
&lt;h1 id="rescue救援-模式">Rescue(救援) 模式&lt;/h1>
&lt;p>当紧急模式不可用时，说明内核或者内核相关出现问题，这时候，我们就需要使用救援模式了。&lt;/p>
&lt;p>救援模式并不在已经安装的系统或者内核上，而是通过外部挂载 linux 系统镜像来启动。相当于通过外挂的系统镜像来启动一个微型系统，来诊断并修复当前系统&lt;/p>
&lt;h2 id="启动救援模式">启动救援模式&lt;/h2>
&lt;p>首先需要将系统镜像挂载到设备上，物理机直接插入光盘或者 U 盘，并修改启动项；虚拟机的话同理，将 linux 系统镜像挂载进虚拟机然后通过该系统镜像启动系统。&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/ewdpso/1616163959557-c45d87ec-9d2c-4296-b14a-fdd3f7b710e1.jpeg" alt="">&lt;/p>
&lt;p>在上图选择 Troubleshooting 后，选择 Rescue a CentOS system（救援一个 centos 系统）&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/ewdpso/1616163959573-28e0e935-14ef-4a12-8d1f-20ad9d79a274.jpeg" alt="">&lt;/p>
&lt;p>在上图蓝线上半部分，选择 1 继续之后。将会启动一个微型系统，并进入一个 shell，其中会提示我们，设备上正常系统的 / 目录被挂载到 /mnt/sysimage ，该情况与 紧急模式 一样，只是正常系统的跟目录被挂载的路径不同罢了。&lt;/p>
&lt;p>通过光盘启动的微型系统，明显比紧急模式的微型系统 功能更加完善，可以看到有很多进程&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/ewdpso/1616163959579-0a7e5ff3-ae98-4560-8a00-c3b58808a04d.jpeg" alt="">&lt;/p>
&lt;p>同样也是一个 sh 的 shell。可以在该 shell 下，进入 /mnt/sysimage 目录来对正常的系统进行修复&lt;/p>
&lt;h2 id="这类模式常见使用方式">这类模式常见使用方式&lt;/h2>
&lt;p>由于进入这类救援模式后，原本系统的 &lt;code>/&lt;/code> 被挂载到微型系统的的其他目录，这之后直接使用 chroot /PATH/DIR 命令，即可将当前 / 目录转变到原本系统上，然后就可以更方便的定位问题了，如果不进行 chroot，那么操作目录的时候，其实挺不方便的~~~~&lt;/p>
&lt;h2 id="ubuntu-的-rescue-模式">Ubuntu 的 Rescue 模式&lt;/h2>
&lt;p>网上充斥着大量的垃圾信息，并没有明确指导如何通过挂盘来进入 Rescue 模式，实际上，Ubuntu Server 版的 ISO 并没有提供这个功能，那么有两种方式来实现：&lt;/p>
&lt;ul>
&lt;li>使用 Ubuntu Desktop 的 ISO，进入界面后选择 &lt;strong>Try Ubuntu&lt;/strong>，也就是网上常说的 &lt;strong>Live CD&lt;/strong> 模式。只不过这是图形界面，进入后配置好 root 密码，可以使用 &lt;code>ctrl + alt + f3&lt;/code> 来切换 TTY，并在 CLI 下进行修复工作&lt;/li>
&lt;li>使用 CentOS 的 ISO 进入 Rescue 模式，同样可以修复挂载 Ubuntu 的分区到指定的目录。&lt;/li>
&lt;/ul>
&lt;h1 id="如何在-centos-8-上启动到紧急模式">如何在 CentOS 8 上启动到紧急模式&lt;/h1>
&lt;p>原文链接：&lt;a href="https://linuxhint.com/boot-emergency-mode-centos-8/">https://linuxhint.com/boot-emergency-mode-centos-8/&lt;/a>
在最新的 CentOS 中，即 CentOS 8 紧急模式和救援模式已经取代了运行级别的概念。运行级别是用于各种任务的不同模式。在 CentOS 8 中，Rescue 模式相当于单用户模式，而紧急启动模式提供了一个最小的环境来修复您的系统。
今天我们将学习如何将 CentOS 8 启动到救援和紧急模式。&lt;/p>
&lt;h2 id="如何启动进入救援模式">如何启动进入救援模式&lt;/h2>
&lt;p>救援模式需要 root 密码进行身份验证，并允许您在正常启动过程不起作用时恢复系统。救援模式将尝试设置所有本地文件系统并启动一些基本系统服务。救援模式不启动网络接口，也不允许多个用户登录。
启动计算机并等待 GRUB 菜单出现。&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/ewdpso/1630379281707-861e3e5b-49c3-4721-9e4e-d2f0dd9239cc.png" alt="image.png">&lt;/p>
&lt;p>现在按“e”打开编辑菜单：&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/ewdpso/1630379281756-579ed222-fa5a-48c6-9182-5a19adc12983.png" alt="image.png">&lt;/p>
&lt;p>现在，找到以下面的屏幕截图所示的“Linux”关键字开头的行：&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/ewdpso/1630379280843-f87b7899-36d3-4049-8ba5-38f918926497.png" alt="image.png">&lt;/p>
&lt;p>使用键盘上的终点按钮转到线的末尾，并在行结束时添加以下参数：&lt;/p>
&lt;p>systemd.Unit = Rescue.target.&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/ewdpso/1630379280876-d0125040-66ac-4757-abde-e5089a4c1b4e.png" alt="image.png">&lt;/p>
&lt;p>按 Ctrl + X 启动系统，但此时使用新参数将让您输入救援模式。&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/ewdpso/1630379280860-c9be44a2-22e8-4fa5-a6c7-4dc77dffa729.png" alt="image.png">&lt;/p>
&lt;p>操作系统会要求 root 密码。在提供密码后，您将进入救援模式。&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/ewdpso/1630379281433-ed1c7906-6118-4f92-a7cc-1dc556b445a6.png" alt="image.png">&lt;/p>
&lt;p>现在，您可以在救援模式下修复系统。&lt;/p>
&lt;p>完成救援模式后，您可以通过运行“退出”命令来退出救援/紧急模式。&lt;/p>
&lt;h2 id="启动进入紧急模式">启动进入紧急模式&lt;/h2>
&lt;p>紧急模式甚至救援模式不起作用时，恢复系统的最小环境。紧急将根文件安装为只读，并不尝试挂载本地文件系统。紧急模式也没有启动网络接口。&lt;/p>
&lt;p>将系统启动到紧急模式的过程与救援模式相同。&lt;/p>
&lt;p>首先，启动计算机并等待 GRUB 菜单显示：&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/ewdpso/1630379281944-4f628d77-411e-4319-af8c-1a1557c7e8ce.png" alt="image.png">&lt;/p>
&lt;p>现在按“E”打开编辑菜单：&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/ewdpso/1630379282293-94e66990-034a-4b85-8cfa-7e9262ade0a8.png" alt="image.png">&lt;/p>
&lt;p>现在定位以“Linux”关键字开头的行，如下屏幕截图所示：&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/ewdpso/1630379282273-c76fcd43-02db-4a14-b7e3-52b4ca27cb3e.png" alt="image.png">&lt;/p>
&lt;p>使用键盘上的终点按钮转到线的末尾，并在行结束时添加以下参数：&lt;/p>
&lt;p>systemd.unit = Encrasst.target.&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/ewdpso/1630379283117-bf48ec7a-b48c-4d23-bd05-b284dce0dcb3.png" alt="image.png">&lt;/p>
&lt;p>按 Ctrl + X 启动系统，但此时使用新参数将让您输入紧急模式。&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/ewdpso/1630379283276-16043784-d87e-4a63-8c3b-95c4c030fd98.png" alt="image.png">&lt;/p>
&lt;p>提供密码后，您将进入紧急模式。&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/ewdpso/1630379283239-886da796-8374-441c-a133-2e28b376336d.png" alt="image.png">&lt;/p>
&lt;p>现在，即使救援模式不起作用，您也可以在紧急模式下修复系统。&lt;/p>
&lt;p>完成紧急模式后，您可以通过运行“退出”命令来退出救援/紧急模式。&lt;/p></description></item><item><title>Docs: 日志系统</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/6.%E5%8F%AF%E8%A7%82%E6%B5%8B%E6%80%A7/%E6%97%A5%E5%BF%97%E7%B3%BB%E7%BB%9F/%E6%97%A5%E5%BF%97%E7%B3%BB%E7%BB%9F/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/6.%E5%8F%AF%E8%A7%82%E6%B5%8B%E6%80%A7/%E6%97%A5%E5%BF%97%E7%B3%BB%E7%BB%9F/%E6%97%A5%E5%BF%97%E7%B3%BB%E7%BB%9F/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Syslog">Wiki,Syslog&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://datatracker.ietf.org/doc/html/rfc5424">RFC 5424&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;h2 id="背景">背景&lt;/h2>
&lt;p>在系统上，不管是系统本身还是外部程序，在开始、运行、结束的一整套过程中，都会产生信息，这些信息包括:何时、何地(来源 IP)、何人(什么程序)、发生了什么事情等。i.e.记录系统在什么时候由哪个程序做了什么样的行为时，发生了何种事件等等。而发生的事情又有等级的区别，哪些信息是危险的，哪些信息是标准可以不用关注的等。这些信息就统称为日志(Log)。随着时代发展，操作系统、程序、硬件设备等等都会产生日志，如此众多的日志需要一个标准来进行定义，这个日志标准就是 &lt;strong>Syslog Protocol&lt;/strong>，由 IETF 给定的 RFC 5424 规范来执行。而在 IT 行业，一般也把各个事务所生成的日志称为 syslog。&lt;/p>
&lt;h2 id="日志的生成">日志的生成&lt;/h2>
&lt;p>操作系统、进程和应用程序的编写者完全清楚他们将生成的事件。在某些情况下，生成消息用来说明状态。可以是一段时间一次，也可以由其他方式触发，例如在程序退出时。在其他情况下，消息是由遇到的条件产生的。在这些情况下，不管是状态消息或者包含一些类型的警告都可能被产生。操作系统、进程和应用程序的编写者可能会在详单中确定消息的数量。这些详单中通常包括发出消息的设备，同时包含消息的严重级别。这样，操作员可以有选择地筛选消息，可以更快的定位更加重要的和有处理时间限制的消息，同时可以将状态或消息信息放在文件中，将来阅读他们。其他显示和保存信息的方式也可以存在。&lt;/p>
&lt;p>必须在设备中配置一些规则，这些规则可以告诉设备显示还是转发事件消息。这些规则是十分灵活的。管理员可能希望所有的信息都保存在本地，同时所有高优先级的消息都会转发到另一台设备中。他们可能发现，将某些设备的信息发送到一些或所有用户的设备中，同时显示在系统控制台上是很合适的。然而，管理员决定将事件信息发送到 syslog 采集器中，在采集器中包含了组成设备的信息以及发送的严重级别，同时定义了远程接收器。例如，系统管理员可能想让所有由邮件设备发出的消息被转发到一个特定的事件信息采集器中。管理员还可以让所有内核生成的事件信息被发送到另一台 syslog 接收器中，同时，将内核产生的 critical 严重级别的消息发送到第三台设备中。同时，将显示在系统控制台中的信息 email 给部分用户，同时将他们保存在设备本地磁盘的文件中。反之，可以将本地进程产生的消息显示在控制台中，但不保存也不转发。所有事件的规则都在设备中生成。因为管理员知道 collector 会收集到哪种类型的事件，他们会在 syslog 服务器中配置相应的规则。&lt;/p>
&lt;p>消息的内容因创建者而异。建议将消息按照一定格式编写，这样人们就可以阅读他们。在消息中加入时间戳和发出消息的设备以及进程的标识符是一个很好的建议。但他们都不是必须的。&lt;/p>
&lt;p>假设任何进程和设备都有可能产生事件消息。可能包含没有任何本地存储空间的设备，例如打印机、路由器、集线器、交换机以及无盘工作站。在这种情况下，将事件消息传送到 collector 可能是必要的，以便操作者可以记录并希望看到它们。&lt;/p>
&lt;h2 id="日志的收集">日志的收集&lt;/h2>
&lt;p>日志收集起来，才能方便管理人员进行查看并进行故障排除。如此众多事物的日志如果想要统一管理，就需要一套程序来对所有事物的日志进行收集、处理、保存、过滤、分析等，可以实现该功能的程序有以下几个：&lt;/p>
&lt;ul>
&lt;li>sysLog 程序与 syslog 标准重名，是早期的 Linux 用于处理系统上所有事物日志的程序&lt;/li>
&lt;li>RsysLog 是 sysLog 的升级版&lt;/li>
&lt;li>ELK/EFK 是很重量级，功能很全的 3 款程序的统称
&lt;ul>
&lt;li>Eleasticsearch 是一个存储系统和搜索引擎&lt;/li>
&lt;li>logstash、Fluentd 日志收集&lt;/li>
&lt;li>kibana 日志的前端展示&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h2 id="日志的生成与收集的通用流程">日志的生成与收集的通用流程&lt;/h2>
&lt;p>当一个程序生成日志后，一般调用一个 output() 函数，把生成的日志输出到某处，e.g.文件、内存、STDOUT 等&lt;/p>
&lt;p>而日志采集程序一般会调用一个 input() 函数，来从某处获取日志，然后再调用 output() 函数来把日志转发或转存&lt;/p>
&lt;h1 id="the-syslog-protocol系统日志协议--即-syslog-规范">The Syslog Protocol(系统日志协议) # 即 syslog 规范&lt;/h1>
&lt;p>每个程序如果产生的日志格式都不一样，也不便于收集归档，更不便于分类查看，所以需要一个统的规范，这个规范包括可收集哪些程序的日志、日志的格式、级别的定义等&lt;/p>
&lt;h2 id="架构">架构&lt;/h2>
&lt;p>Syslog Protocol 采用分层架构设计，共分为 3 层&lt;/p>
&lt;ul>
&lt;li>&amp;ldquo;syslog content&amp;rdquo; syslog 内容层。is the management information contained in a syslog message.&lt;/li>
&lt;li>&amp;ldquo;syslog application&amp;quot;syslog 应用程序层。处理系统日志消息的生成、解释、路由、存储&lt;/li>
&lt;li>&amp;ldquo;syslog transport&amp;quot;syslog 传输层。将消息放到 puts messages on the wire and takes them off the wire.&lt;/li>
&lt;/ul>
&lt;p>每层架构中都会执行某些类型的功能&lt;/p>
&lt;ul>
&lt;li>originator：发起者。生成将要在消息中携带的 syslog 内容&lt;/li>
&lt;li>collector：采集器。收集 syslog 内容以供进一步分析&lt;/li>
&lt;li>relay：中继。转发消息，接收来自 originators 或其他 relaysd 的消息，并将其发送给 collectors 或其他 relays&lt;/li>
&lt;li>transport sender：传输发送器。将 syslog 消息传递给特定的传输协议&lt;/li>
&lt;li>transport receiver：传输接收器。从特定的传输协议获取 syslog 消息&lt;/li>
&lt;/ul>
&lt;h2 id="syslog-信息的构成格式">syslog 信息的构成格式&lt;/h2>
&lt;p>每个程序在编写的都时候都会定义日志格式，大部分都会遵循“syslog”标准。不同事物的日志格式不尽相同，详情请见相关事物的文档，不过一般情况下，日志内容都应该包含，时间，某物，在哪，做了什么。&lt;/p>
&lt;p>The Syslog Protocol 规定了每条 syslog 信息应该包含如下内容：&lt;/p>
&lt;p>HEADER Structured-Data [MSG] # 头部信息，结构化数据，消息主体&lt;/p>
&lt;ul>
&lt;li>HEADER=PRI VERSION TIMESTAMP HOSTNAME # 优先级、版本、时间出、主机名
&lt;ul>
&lt;li>PRI=Facility*8+Severity # Priority 优先级是一个值，计算方式通过两部分计算，“Facility 设施”与“Severity 严重性”。具体见本章下文具体描述&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Structured-Data= #&lt;/li>
&lt;/ul>
&lt;h3 id="facility设施">Facility(设施)&lt;/h3>
&lt;p>Facility 用来表示产生该信息的硬件设备、协议、系统软件、操作系统等可以产生日志消息的事物类别。由于世界上事物太多，所以最好以类别的方式来对各个事务进行分类，所以使用 &lt;strong>Facility(设施)&lt;/strong> 来描述。比如&lt;code>security/authorization&lt;/code>这个设施中就包含很多关于安全认证的应用程序产生的日志类别。&lt;/p>
&lt;p>每个 Facility 都对应一个值以便进行 PRI 的计算，以下是 RFC5424 中规定的几十类 Facility。其中括号中的数字表示 Facility 对应的 Numerical Code(数字码)。&lt;/p>
&lt;ul>
&lt;li>&lt;strong>kernel messages(0)&lt;/strong> # 内核信息类&lt;/li>
&lt;li>&lt;strong>user-level messages(1)&lt;/strong> # 用户层信息类，比如用户使用 logger 命令来记录日志功能&lt;/li>
&lt;li>&lt;strong>mail system(2)&lt;/strong> # 邮件系统类型&lt;/li>
&lt;li>&lt;strong>system daemons(3)&lt;/strong> # 系统守护进程类，比如 systemd 管理的服务的信息。&lt;/li>
&lt;li>&lt;strong>security/authorization messages(4)&lt;/strong> # 安全与认证信息类，比如 login、ssh、su 等需要账号密码的。&lt;/li>
&lt;li>&lt;strong>messages generated internally by syslogd(5)&lt;/strong> # 由 syslog 相关协议产生的信息类，就是 rsyslog 程序本身的日志信息。&lt;/li>
&lt;li>&lt;strong>line printer subsystem(6)&lt;/strong> # 打印子系统类&lt;/li>
&lt;li>&lt;strong>network news subsystem(7)&lt;/strong> #&lt;/li>
&lt;li>&lt;strong>UUCP subsystem(8)&lt;/strong> #&lt;/li>
&lt;li>&lt;strong>clock daemon(9)&lt;/strong> #&lt;/li>
&lt;li>&lt;strong>security/authorization messages(10)&lt;/strong> #&lt;/li>
&lt;li>&lt;strong>FTP daemon(11)&lt;/strong> # FTP&lt;/li>
&lt;li>&lt;strong>NTP subsystem(12)&lt;/strong> # NTP 子系统&lt;/li>
&lt;li>&lt;strong>log audit(13)&lt;/strong> # 日志审计&lt;/li>
&lt;li>&lt;strong>log alert(14)&lt;/strong> # 日志报警&lt;/li>
&lt;li>&lt;strong>clock daemon(note 2)(15)&lt;/strong> #&lt;/li>
&lt;li>&lt;strong>local use 0~7 (local0~7)(16~23)&lt;/strong> # 留给用户自定义的类别，比如可以把某些程序归为 Local0~7 中的某一类，然后来收集该类的日志&lt;/li>
&lt;/ul>
&lt;h3 id="severity">Severity&lt;/h3>
&lt;p>Severity 用来表示该日志信息的严重程度，也叫日志的级别 Level。为了便于日志管理，需要对日志的内容进行划分，哪些信息是正常的，哪些信息是错误的，哪些信息是警告等等。一般情况分为以下几类，其中第一列数字表示对应的 Severity 的值，第二列为 Severity 的名称以及其所描述的严重程度的具体概念。以下严重程度由高到底进行排列，debug 属于特殊的 Severity&lt;/p>
&lt;ul>
&lt;li>0 Emergency: 系统不可用 system is unusable&lt;/li>
&lt;li>1 Alert: 必须立即采取行动 action must be taken immediately&lt;/li>
&lt;li>2 Critical: 临界状态 critical conditions&lt;/li>
&lt;li>3 Error: 错误状态 error conditions&lt;/li>
&lt;li>4 Warning: 警告状态 warning conditions&lt;/li>
&lt;li>5 Notice: 正常但是值得注意的状态 normal but significant condition&lt;/li>
&lt;li>6 Informational: 信息 informational messages&lt;/li>
&lt;li>7 Debug: debug 级别的信息 debug-level messages&lt;/li>
&lt;/ul>
&lt;h1 id="常见日志级别">常见日志级别&lt;/h1>
&lt;p>Emergency ( 紧急 ): 关于 SYN 攻击、Tear Drop 攻击及 Ping of Death 攻击的消息。
Alert ( 警示 ): 关于需要立即引起注意的情况 ( 例如防火墙攻击和许可密钥到期 ) 的消息。
Critical (关键 ): 关于可能影响设备功能的情况 [例如高可用性 (HA) 状态更改 ]的消息。
Error (错误): 关于可能影响设备功能的错误情况 (例如反病毒扫描失败或与 SSH 服务器通信失败) 的消息。
Warning( 警告 ):关于可能影响设备功能的情况(例如连接到电子邮件服务器失败或认证失败、超时和成功)的消息。
Notification (通知 ): 关于常规事件 ( 包括由 admin 发起的配置更改 ) 的消息。
Information ( 信息 ): 可提供关于系统操作一般信息的消息。
Debugging ( 调试 ): 可提供调试时所用详细信息的消息。&lt;/p></description></item><item><title>Docs: 文件管理</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2.kernel%E5%86%85%E6%A0%B8/6.file_system_%E7%AE%A1%E7%90%86/%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86/%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2.kernel%E5%86%85%E6%A0%B8/6.file_system_%E7%AE%A1%E7%90%86/%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86/%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Computer_file">Wiki,Computer file&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Category:Computer_files">Wiki-Category,Computer files&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/End-of-file">Wiki,End of file&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://mp.weixin.qq.com/s/qJdoXTv_XS_4ts9YuzMNIw">公众号，小林 coding-一口气搞懂「文件系统」，就靠这 25 张图了&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://mp.weixin.qq.com/s/tXEfsLqdePjcPS6FKa-qzg">另一个公众号&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>从[文件系统](&amp;lt;/docs/IT学习笔记/1.操作系统/2.Kernel(内核)/6.File%20System%20 管理/6.File%20System%20 管理.md&amp;raquo;)文章可以看出来，File(文件) 是一个组织存储在计算机中数据的逻辑概念，以便让人们可以清楚得知道每一段数据的起始位置、结束位置，甚至可以通过为文件命名来立刻反应过来这段数据的作用。&lt;/p>
&lt;p>所谓的查看文件，其实是指找到一段数据的开头和结尾，并查看这段数据。对于程序员来说文件是一个很简单的概念，我们只需要将其理解为一个 N byte 的序列就可以了：**b1, b2, b3, b4, &amp;hellip;&amp;hellip;. bN。**程序员使用 I/O 最终都逃不过文件。&lt;/p>
&lt;p>所有的 I/O 设备都被抽象为了文件这个概念，&lt;strong>Everything is File(一切皆文件)&lt;/strong>，磁盘、网络数据、终端，甚至进程间通信工具管道等都被当做文件对待。
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/tudy8a/1616167656114-9b5d8779-6322-4740-aa6c-47ef53a1aef6.jpeg" alt="">
所有的 I/O 操作也都是通过文件读写来实现的，&lt;strong>这一非常优雅的抽象可以让程序员使用一套接口就能实现所有 I/O 操作&lt;/strong>。
常用的 I/O 操作接口一般有以下几类：&lt;/p>
&lt;ul>
&lt;li>打开文件，open&lt;/li>
&lt;li>改变读写位置，seek&lt;/li>
&lt;li>文件读写，read、write&lt;/li>
&lt;li>关闭文件，close&lt;/li>
&lt;/ul>
&lt;p>程序员通过这几个接口几乎可以实现所有 I/O 操作，这就是文件这个概念的强大之处。
在 Linux 中一切皆文件，目录也是文件的一种类型，就连块设备、套接字、终端、管道等等，都被当做 File(文件)来对待。
下面是一个在 Linux 中最常见的列出文件的命令 &lt;code>[ls -l](https://www.yuque.com/desistdaydream/learning/ynhtw7#bmqgU)&lt;/code> 所能查看的文件基本信息&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>~&lt;span style="color:#f92672">]&lt;/span>&lt;span style="color:#75715e"># ls -lh&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>total 20K
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>lrwxrwxrwx. &lt;span style="color:#ae81ff">1&lt;/span> root root &lt;span style="color:#ae81ff">7&lt;/span> May &lt;span style="color:#ae81ff">24&lt;/span> &lt;span style="color:#ae81ff">2019&lt;/span> bin -&amp;gt; usr/bin
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>dr-xr-xr-x. &lt;span style="color:#ae81ff">5&lt;/span> root root 4.0K May &lt;span style="color:#ae81ff">24&lt;/span> &lt;span style="color:#ae81ff">2019&lt;/span> boot
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>drwxr-xr-x &lt;span style="color:#ae81ff">20&lt;/span> root root 3.1K May &lt;span style="color:#ae81ff">14&lt;/span> 09:38 dev
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>drwxr-xr-x. &lt;span style="color:#ae81ff">82&lt;/span> root root 8.0K Jun &lt;span style="color:#ae81ff">21&lt;/span> 19:42 etc
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>......
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;table>
&lt;thead>
&lt;tr>
&lt;th>类型与权限&lt;/th>
&lt;th>硬连接数&lt;/th>
&lt;th>所属主&lt;/th>
&lt;th>所属组&lt;/th>
&lt;th>大小&lt;/th>
&lt;th>时间&lt;/th>
&lt;th>文件名&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>lrwxrwxrwx.&lt;/td>
&lt;td>1&lt;/td>
&lt;td>root&lt;/td>
&lt;td>root&lt;/td>
&lt;td>7&lt;/td>
&lt;td>May 24 2019&lt;/td>
&lt;td>bin -&amp;gt; usr/bin&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>dr-xr-xr-x.&lt;/td>
&lt;td>5&lt;/td>
&lt;td>root&lt;/td>
&lt;td>root&lt;/td>
&lt;td>4.0K&lt;/td>
&lt;td>May 24 2019&lt;/td>
&lt;td>boot&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>drwxr-xr-x&lt;/td>
&lt;td>20&lt;/td>
&lt;td>root&lt;/td>
&lt;td>root&lt;/td>
&lt;td>3.1K&lt;/td>
&lt;td>May 14 09:38&lt;/td>
&lt;td>dev&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>&lt;code>类型与权限&lt;/code>这一列一共 11 个字符，共分为 3 个部分：&lt;/p>
&lt;ul>
&lt;li>第一部分 # 第 1 个字符为 &lt;a href="#%E6%96%87%E4%BB%B6%E7%9A%84%E7%B1%BB%E5%9E%8B">文件的类型&lt;/a>，具体类型含义见下文&lt;/li>
&lt;li>第二部分 # 中间 9 个字符。用来表示文件的基本权限，详见&lt;a href="#%E6%96%87%E4%BB%B6%E7%9A%84%E6%9D%83%E9%99%90">文件的权限&lt;/a>部分。
&lt;ul>
&lt;li>第一组为文件拥有者的权限&lt;/li>
&lt;li>第二组是文件所属组的权限&lt;/li>
&lt;li>第三组是其他的权限。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>第三部分 # 最后 1 个字符。用来表示该文件是否有其他权限特殊权限管理该文件的访问。
&lt;ul>
&lt;li>&lt;code>+&lt;/code> # 具有 &lt;a href="https://desistdaydream.github.io/docs/IT%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/5.%E7%99%BB%E5%BD%95%20Linux%20%E4%B8%8E%20%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6/Access%20Control(%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6)/ACL.md">ACL&lt;/a> 的文件。&lt;/li>
&lt;li>&lt;code>.&lt;/code> # 具有 &lt;a href="https://desistdaydream.github.io/docs/IT%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/5.%E7%99%BB%E5%BD%95%20Linux%20%E4%B8%8E%20%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6/SELinux/SELinux.md">SELinux&lt;/a> 安全上下文的文件。若没有 &lt;code>.&lt;/code>，则该文件不受 SELinux 控制。&lt;/li>
&lt;li>注意：
&lt;ul>
&lt;li>当添加了 ACL 权限后，只显示 &lt;code>+&lt;/code>，&lt;code>.&lt;/code> 看不到了。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>简单示例：
&lt;ul>
&lt;li>比如上面例子中 boot 文件第一列属性为 &lt;code>dr-xr-xr-x.&lt;/code> 表示该文件是一个目录，文件的拥有者、属组、其他，都具有 r 和 x 权限(i.e.读和执行权限)，由 SELinux 管理。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>&lt;code>时间&lt;/code> 这一列中包含如下几种：&lt;/p>
&lt;ul>
&lt;li>&lt;strong>atime&lt;/strong> # 访问时间。读取文件或者执行文件时，该时间会变化&lt;/li>
&lt;li>&lt;strong>ctime&lt;/strong> # 在写入文件、更改所有者、权限或链接设置时随 Inode 的内容更改而更改的时间&lt;/li>
&lt;li>&lt;strong>mtime&lt;/strong> # 在写入文件时随文件内容的更改而更改的时间。&lt;code>默认限制这个时间&lt;/code>。&lt;/li>
&lt;/ul>
&lt;h2 id="文件的类型">文件的类型&lt;/h2>
&lt;p>Linux 中的文件有下面几种类型(左侧是该类型文件的标识符)：&lt;/p>
&lt;ul>
&lt;li>**- **# 普通文件&lt;/li>
&lt;li>&lt;strong>b&lt;/strong> # 块设备&lt;/li>
&lt;li>&lt;strong>c&lt;/strong> # 字符设备&lt;/li>
&lt;li>&lt;strong>d&lt;/strong> # 目录&lt;/li>
&lt;li>&lt;strong>D&lt;/strong> # door(Solaris) 这是啥？~&lt;/li>
&lt;li>&lt;strong>l&lt;/strong> # 符号链接&lt;/li>
&lt;li>&lt;strong>M&lt;/strong> # off-line(migrated) 文件（Cray DMF） 这是啥？~&lt;/li>
&lt;li>&lt;strong>n&lt;/strong> # 网络专用文件&lt;/li>
&lt;li>&lt;strong>p&lt;/strong> # FIFO(管道)&lt;/li>
&lt;li>&lt;strong>P&lt;/strong> # 端口&lt;/li>
&lt;li>**s **# 套接字&lt;/li>
&lt;li>&lt;strong>?&lt;/strong> # 其他文件类型&lt;/li>
&lt;/ul>
&lt;blockquote>
&lt;p>Note：占用存储空间的类型：文件、目录、符号链接(符号链接记录的是路径路径不长时存在 innode 里面)。其他四种：套接字、块设备、字符设备、管道是伪文件，不占用磁盘空间。&lt;/p>
&lt;/blockquote>
&lt;h2 id="文件的权限">文件的权限&lt;/h2>
&lt;p>文件最基本的权限详见 《&lt;a href="https://desistdaydream.github.io/docs/IT%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/5.%E7%99%BB%E5%BD%95%20Linux%20%E4%B8%8E%20%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6/Access%20Control(%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6)/Access%20Control(%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6).md">Access Control(访问控制)&lt;/a>》章节，Linux 中的所有文件都可以被三个拥有者拥有，每个拥有者又可以具有 3 个权限
除了上述基于角色的权限以外，文件还可以具有高级权限，比如 ACL、SUID、SGID、SBIT、chattr 命令添加的权限、SELinux 控制的权限，等等等。&lt;/p>
&lt;h1 id="文件的使用">文件的使用&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Hard_link">Wiki,Hard link&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Symbolic_link">WIki,Symbolic link&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>从&lt;a href="https://desistdaydream.github.io/docs/IT%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2.Kernel(%E5%86%85%E6%A0%B8)/6.File_System_%E7%AE%A1%E7%90%86/6.File_System_%E7%AE%A1%E7%90%86#%E6%96%87%E4%BB%B6%E7%BB%84%E7%BB%87%E7%BB%93%E6%9E%84">文件系统章节中的文件组织结构&lt;/a>可知，我们使用 &lt;a href="docs/IT%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2.Kernel(%E5%86%85%E6%A0%B8)/6.File_System_%E7%AE%A1%E7%90%86/%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86/Inode.md">Inode(索引节点)&lt;/a> 定位一个文件。而打开文件后，我们可以获取到文件的 [FileDesc(文件描述符)](/docs/IT学习笔记/1.操作系统/2.Kernel(内核)/6.File%20System%20管理/文件管理/File%20Descriptor(文件描述符).md Descriptor(文件描述符).md)，所有对文件的读写操作，都是基于文件描述符进行的。&lt;/p>
&lt;p>&lt;strong>我们平时看到的人类可读的文件名，实际上是一个指向 Inode 的硬连接&lt;/strong>。&lt;/p>
&lt;h2 id="symbolic-link符合链接-与-hard-link硬链接">Symbolic link(符合链接) 与 Hard link(硬链接)&lt;/h2>
&lt;p>在计算机中 **Symbolic link(符号链接，也称为 软连接) **与 &lt;strong>Hard link(硬连接)&lt;/strong> 都是用以指向一个目标的文件或路径。&lt;/p>
&lt;ul>
&lt;li>Hard link 是将名称与文件相关联的 directory entry(目录项)，目录项概念详见《&lt;a href="docs/IT%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2.Kernel(%E5%86%85%E6%A0%B8)/6.File_System_%E7%AE%A1%E7%90%86/_index.md">文件系统管理&lt;/a>》章节&lt;/li>
&lt;li>Symbolic link 是一个文件，通过指定路径指向一个目标(文件或目录)&lt;/li>
&lt;/ul>
&lt;p>在文件系统中，人类看到的每个文件都是一个 inode 的硬连接。为文件创建额外的硬链接使得该文件的内容可以通过额外的路径访问（即通过不同的名称或在不同的目录中）。但是并不一定需要软链接，软链接与目标文件本质上是两个完全不通的文件。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>~/tmp&lt;span style="color:#f92672">]&lt;/span>&lt;span style="color:#75715e"># ls -il&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>total &lt;span style="color:#ae81ff">0&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">917508&lt;/span> -rw-r--r-- &lt;span style="color:#ae81ff">2&lt;/span> root root &lt;span style="color:#ae81ff">0&lt;/span> Dec &lt;span style="color:#ae81ff">15&lt;/span> 13:15 hard
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">917509&lt;/span> lrwxrwxrwx &lt;span style="color:#ae81ff">1&lt;/span> root root &lt;span style="color:#ae81ff">4&lt;/span> Dec &lt;span style="color:#ae81ff">15&lt;/span> 13:15 hardln -&amp;gt; hard
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">917508&lt;/span> -rw-r--r-- &lt;span style="color:#ae81ff">2&lt;/span> root root &lt;span style="color:#ae81ff">0&lt;/span> Dec &lt;span style="color:#ae81ff">15&lt;/span> 13:15 hardln2
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>在这里 hard 是原始文件，inode 为 917508&lt;/p>
&lt;ul>
&lt;li>hardln 是一个软链接，inode 为 917509，hardln 指向的 hard 文件的 inode 则是 917508&lt;/li>
&lt;li>hardln2 与 hard 本质上都是 inode 为 917508 的文件
&lt;ul>
&lt;li>可以这么说， hard 与 hardln2 都是一个指向 inode 为 917508 的硬连接。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>硬链接是&lt;strong>多个目录项中的 inode(索引节点)指向一个文件&lt;/strong>，也就是指向同一个 inode，但是 inode 是不可能跨越文件系统的，每个文件系统都有各自的 inode 数据结构和列表，所以&lt;strong>硬链接是不可用于跨文件系统的&lt;/strong>。由于多个目录项都是指向一个 inode，那么&lt;strong>只有删除文件的所有硬链接以及源文件时，系统才会彻底删除该文件。&lt;/strong>
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/tudy8a/1616167677117-992b018e-1ff6-4d7e-88f2-5783e0d0dadc.png" alt="">
如何查看硬链接的文件都在哪：&lt;/p>
&lt;ul>
&lt;li>使用 &lt;code>ls -i&lt;/code>，查看该硬链接的索引节点号。&lt;/li>
&lt;li>使用 &lt;code>find / -inum XXXX&lt;/code>，查看具有该索引节点号的所有文件所在位置。&lt;/li>
&lt;/ul>
&lt;p>注：&lt;code>rm ${find ./ -inum 2310630}&lt;/code> 搜索节点 2310630 的文件，并删除。&lt;/p>
&lt;p>软链接相当于重新创建一个文件，这个文件有&lt;strong>独立的 inode&lt;/strong>，但是这个&lt;strong>文件的内容是另外一个文件的路径&lt;/strong>，所以访问软链接的时候，实际上相当于访问到了另外一个文件，所以&lt;strong>软链接是可以跨文件系统的&lt;/strong>，甚至&lt;strong>目标文件被删除了，链接文件还是在的，只不过指向的文件找不到了而已。&lt;/strong>
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/tudy8a/1616167677115-040a0c08-44ba-46b8-900a-db111dc7c93c.png" alt="">
软链接目标文件只能是一个文件，通过该文件指向源文件或者文件夹，类似于 windows 的快捷方式，软连接会创建一个单独的 inode。&lt;/p>
&lt;p>如何查看软连接的文件都在哪：&lt;/p>
&lt;ul>
&lt;li>find -type l # 查看当前目录下的所有软连接文件&lt;/li>
&lt;li>ls -l ${find -type l} # 通过反引号先执行查找命令，然后查找到的结果用 ls -l 显示详细信息&lt;/li>
&lt;li>find /etc -type l -exec ls -l {} ; | grep ifcfg-eth1 # 查找/etc 下的软链接文件，并且显示详细信息，然后筛选这些信息中包含 ifcfg-eth1 的条目&lt;/li>
&lt;/ul>
&lt;h2 id="文件的读写过程">文件的读写过程&lt;/h2>
&lt;p>我们从用户角度来看文件的话，就是我们要怎么使用文件？首先，我们得通过系统调用来打开一个文件。
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/tudy8a/1616167677045-043724c9-8f38-483d-b322-1e474f0568d1.png" alt="">&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-c" data-lang="c">&lt;span style="display:flex;">&lt;span>fd &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#a6e22e">open&lt;/span>(name, flag); &lt;span style="color:#960050;background-color:#1e0010">#&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">打开文件&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>...&lt;span style="color:#a6e22e">write&lt;/span>(fd,...); &lt;span style="color:#960050;background-color:#1e0010">#&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">写数据&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>...&lt;span style="color:#a6e22e">close&lt;/span>(fd); &lt;span style="color:#960050;background-color:#1e0010">#&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">关闭文件&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>上面简单的代码是读取一个文件的过程：&lt;/p>
&lt;ul>
&lt;li>首先用 &lt;code>open&lt;/code> 系统调用打开文件，&lt;code>open&lt;/code> 的参数中包含文件的路径名和文件名。&lt;/li>
&lt;li>使用 &lt;code>write&lt;/code> 写数据，其中 &lt;code>write&lt;/code> 使用 &lt;code>open&lt;/code> 所返回的&lt;strong>文件描述符&lt;/strong>，并不使用文件名作为参数。&lt;/li>
&lt;li>使用完文件后，要用 &lt;code>close&lt;/code> 系统调用关闭文件，避免资源的泄露。&lt;/li>
&lt;/ul>
&lt;p>我们打开了一个文件后，操作系统会跟踪进程打开的所有文件，所谓的跟踪呢，就是操作系统为每个进程维护一个打开文件表，文件表里的每一项代表「&lt;strong>文件描述符&lt;/strong>」，所以说文件描述符是打开文件的标识。
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/tudy8a/1616167677065-7a31a536-72df-48b0-adcf-06883b40ed19.png" alt="">
操作系统在打开文件表中维护着打开文件的状态和信息：&lt;/p>
&lt;ul>
&lt;li>文件指针：系统跟踪上次读写位置作为当前文件位置指针，这种指针对打开文件的某个进程来说是唯一的；&lt;/li>
&lt;li>文件打开计数器：文件关闭时，操作系统必须重用其打开文件表条目，否则表内空间不够用。因为多个进程可能打开同一个文件，所以系统在删除打开文件条目之前，必须等待最后一个进程关闭文件，该计数器跟踪打开和关闭的数量，当该计数为 0 时，系统关闭文件，删除该条目；&lt;/li>
&lt;li>文件磁盘位置：绝大多数文件操作都要求系统修改文件数据，该信息保存在内存中，以免每个操作都从磁盘中读取；&lt;/li>
&lt;li>访问权限：每个进程打开文件都需要有一个访问模式（创建、只读、读写、添加等），该信息保存在进程的打开文件表中，以便操作系统能允许或拒绝之后的 I/O 请求；&lt;/li>
&lt;/ul>
&lt;p>在用户视角里，文件就是一个持久化的数据结构，但操作系统并不会关心你想存在磁盘上的任何的数据结构，操作系统的视角是如何把文件数据和磁盘块对应起来。&lt;/p>
&lt;p>所以，用户和操作系统对文件的读写操作是有差异的，用户习惯以字节的方式读写文件，而操作系统则是以数据块来读写文件，那屏蔽掉这种差异的工作就是文件系统了。&lt;/p>
&lt;p>我们来分别看一下，读文件和写文件的过程：&lt;/p>
&lt;ul>
&lt;li>当用户进程从文件读取 1 个字节大小的数据时，文件系统则需要获取字节所在的数据块，再返回数据块对应的用户进程所需的数据部分。&lt;/li>
&lt;li>当用户进程把 1 个字节大小的数据写进文件时，文件系统则找到需要写入数据的数据块的位置，然后修改数据块中对应的部分，最后再把数据块写回磁盘。&lt;/li>
&lt;/ul>
&lt;p>所以说，&lt;strong>文件系统的基本操作单位是数据块&lt;/strong>。&lt;/p>
&lt;h1 id="目录的存储">目录的存储&lt;/h1>
&lt;p>基于 Linux 一切皆文件的设计思想，目录其实也是个文件，你甚至可以通过 &lt;code>vim&lt;/code> 打开它，它也有 inode，inode 里面也是指向一些块。&lt;/p>
&lt;p>和普通文件不同的是，&lt;strong>普通文件的块里面保存的是文件数据，而目录文件的块里面保存的是目录里面一项一项的文件信息。&lt;/strong>&lt;/p>
&lt;p>在目录文件的块中，最简单的保存格式就是&lt;strong>列表&lt;/strong>，就是一项一项地将目录下的文件信息（如文件名、文件 inode、文件类型等）列在表里。&lt;/p>
&lt;p>列表中每一项就代表该目录下的文件的文件名和对应的 inode，通过这个 inode，就可以找到真正的文件。
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/tudy8a/1616167677111-6682b310-2f92-4f63-b22a-9821ba99345c.png" alt="">
目录格式哈希表通常，第一项是「&lt;code>.&lt;/code>」，表示当前目录，第二项是「&lt;code>..&lt;/code>」，表示上一级目录，接下来就是一项一项的文件名和 inode。&lt;/p>
&lt;p>如果一个目录有超级多的文件，我们要想在这个目录下找文件，按照列表一项一项的找，效率就不高了。&lt;/p>
&lt;p>于是，保存目录的格式改成&lt;strong>哈希表&lt;/strong>，对文件名进行哈希计算，把哈希值保存起来，如果我们要查找一个目录下面的文件名，可以通过名称取哈希。如果哈希能够匹配上，就说明这个文件的信息在相应的块里面。&lt;/p>
&lt;p>Linux 系统的 ext 文件系统就是采用了哈希表，来保存目录的内容，这种方法的优点是查找非常迅速，插入和删除也较简单，不过需要一些预备措施来避免哈希冲突。&lt;/p>
&lt;p>目录查询是通过在磁盘上反复搜索完成，需要不断地进行 I/O 操作，开销较大。所以，为了减少 I/O 操作，把当前使用的文件目录缓存在内存，以后要使用该文件时只要在内存中操作，从而降低了磁盘操作次数，提高了文件系统的访问速度。&lt;/p></description></item><item><title>Docs: 系统审计</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E7%B3%BB%E7%BB%9F%E5%AE%A1%E8%AE%A1/%E7%B3%BB%E7%BB%9F%E5%AE%A1%E8%AE%A1/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E7%B3%BB%E7%BB%9F%E5%AE%A1%E8%AE%A1/%E7%B3%BB%E7%BB%9F%E5%AE%A1%E8%AE%A1/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/7/html/security_guide/chap-system_auditing">红帽产品文档，RedHat7-安全指南-第 7 章 系统审计&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>Linux 审计系统提供了一种方式来跟踪系统中的安全相关信息。根据预配置的规则，审计会生成日志条目，以记录有关系统上发生事件的尽可能多的信息。对于关键任务环境而言，此信息对于确定安全策略的违反者及其执行的操作至关重要。Audit 不会为您的系统提供额外的安全性，而是可用于发现系统上使用的安全策略违规。通过 SELinux 等其他安全措施可以进一步阻止这些冲突。&lt;/p>
&lt;p>以下列表总结了审计可以在其日志文件中记录的一些信息：&lt;/p>
&lt;ul>
&lt;li>事件的日期和时间、类型和结果.&lt;/li>
&lt;li>主题和对象的敏感度标签。&lt;/li>
&lt;li>事件与触发事件的用户的身份相关联。&lt;/li>
&lt;li>对 Audit 配置的所有修改，并尝试访问 Audit 日志文件。&lt;/li>
&lt;li>所有身份验证机制的使用，如 SSH 和 Kerberos 等。&lt;/li>
&lt;li>对任何受信任数据库的更改，如 /etc/passwd.&lt;/li>
&lt;li>尝试从系统导入或导出信息.&lt;/li>
&lt;li>根据用户身份、主题和对象标签以及其他属性，包含或排除事件。&lt;/li>
&lt;/ul>
&lt;p>使用审计系统也是许多安全相关认证的一项要求。审计旨在满足或超过以下认证或合规指南的要求：&lt;/p>
&lt;ul>
&lt;li>受控访问保护配置文件(CAPP)&lt;/li>
&lt;li>标记的安全保护配置文件(LSPP)&lt;/li>
&lt;li>规则集基本访问控制(RSBAC)&lt;/li>
&lt;li>国家工业安全计划操作手册(NISPOM)&lt;/li>
&lt;li>联邦信息安全管理法案(FISMA)&lt;/li>
&lt;li>支付卡行业 - 数据安全标准(PCI-DSS)&lt;/li>
&lt;li>安全技术实施指南(STIG)&lt;/li>
&lt;/ul>
&lt;p>审计还包括：&lt;/p>
&lt;ul>
&lt;li>由国家信息保障合作伙伴(NIAP)和最佳安全行业(BSI)评估。&lt;/li>
&lt;li>通过红帽企业 Linux 5 上的 LSPP/CAPP/RSBAC/EAL4+ 认证.&lt;/li>
&lt;li>红帽企业 Linux 6 上经过操作系统保护配置文件/评估保证级别 4+(OSPP/EAL4+)认证.&lt;/li>
&lt;/ul>
&lt;h3 id="使用案例">使用案例&lt;/h3>
&lt;p>&lt;strong>监视文件访问&lt;/strong> # 审计可以跟踪文件或目录是否已访问、修改、执行或文件属性是否已更改。例如，这可用于检测对重要文件的访问，并在其中一个文件损坏时提供审计跟踪。&lt;/p>
&lt;p>&lt;strong>监控系统调用&lt;/strong> # 可将审计配置为在每次使用特定系统调用时生成日志条目。例如，这可用于通过监控 settimeofday、clock_adjtime 和其他时间相关系统调用来跟踪系统时间的更改。&lt;/p>
&lt;p>&lt;strong>记录用户运行的命令&lt;/strong> # 审计可以跟踪文件是否已执行，因此可以定义规则以记录特定命令的每次执行。例如，可以为 /bin 目录中的每个可执行文件定义规则。然后，可以按用户 ID 搜索生成的日志条目，以生成每个用户所执行命令的审计跟踪。&lt;/p>
&lt;p>&lt;strong>记录系统路径名称的执行&lt;/strong> # 除了观察在规则调用时转换索引节点路径的文件访问之外，审计现在还可以观察路径的执行，即使路径在规则调用中不存在，或者在规则调用后替换了文件。这允许规则在升级程序可执行文件或甚至安装之前继续运行。&lt;/p>
&lt;p>&lt;strong>记录安全事件&lt;/strong> # pam_faillock 身份验证模块能够记录失败的登录尝试。也可以将审计设置为记录失败的登录尝试，并提供试图登录的用户的附加信息。&lt;/p>
&lt;p>&lt;strong>搜索事件&lt;/strong> # Audit 提供 ausearch 实用程序，可用于过滤日志条目并根据多个条件提供完整的审计跟踪。&lt;/p>
&lt;p>&lt;strong>运行摘要报告&lt;/strong> # aureport 实用程序可用于生成记录的事件的日常报告等。然后，系统管理员可以分析这些报告，并进一步调查可疑活动。&lt;/p>
&lt;p>&lt;strong>监控网络访问&lt;/strong> # iptables 和 ebtables 实用程序可以配置为触发审计事件，使系统管理员能够监控网络访问。&lt;/p></description></item><item><title>Docs: 性能评估与故障处理</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/x.linux-%E7%AE%A1%E7%90%86/%E6%80%A7%E8%83%BD%E8%AF%84%E4%BC%B0%E4%B8%8E%E6%95%85%E9%9A%9C%E5%A4%84%E7%90%86/%E6%80%A7%E8%83%BD%E8%AF%84%E4%BC%B0%E4%B8%8E%E6%95%85%E9%9A%9C%E5%A4%84%E7%90%86/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/x.linux-%E7%AE%A1%E7%90%86/%E6%80%A7%E8%83%BD%E8%AF%84%E4%BC%B0%E4%B8%8E%E6%95%85%E9%9A%9C%E5%A4%84%E7%90%86/%E6%80%A7%E8%83%BD%E8%AF%84%E4%BC%B0%E4%B8%8E%E6%95%85%E9%9A%9C%E5%A4%84%E7%90%86/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://time.geekbang.org/column/intro/100020901">极客时间,Linux 性能优化实战&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://mp.weixin.qq.com/s/Tnerf7M_a6HUC4ucaOWzeg">公众号,刘超的通俗云计算-读完这篇文章，就再也不怕遇到网络问题啦&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;h1 id="常见问题简述">常见问题简述&lt;/h1>
&lt;p>当你发现某台机器无论做什么都慢, 而 cpu 和内核却不是瓶颈的时候, 那有可能是内核慢了。机器上定时任务的执行过多, 内核缓存一直增加, 导致内核速度变慢了. 它一变慢, 引发了 tcp 握手时间变长, 最后造成用户体验下降. 既然发现了问题, 解决方案也比较容易搜索到了, 增加任务, 检查内核是否变慢, 慢了的话就清理一次：&lt;code>sync &amp;amp;&amp;amp; echo 3 &amp;gt; /proc/sys/vm/drop_caches&lt;/code>&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/behafi/1647529106727-4e5af00a-e6ee-4b86-9b82-cec9262f4601.png" alt="image.png">
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/behafi/1647529081502-9a4d7eae-e062-48bb-bdf7-24a6ffef8d67.png" alt="image.png">
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/behafi/1647529150105-9e34e168-1ad1-4896-a501-9cb77aa38661.png" alt="image.png">&lt;/p></description></item><item><title>Docs: 字符的编码与解码</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/8.%E9%80%9A%E7%94%A8%E6%8A%80%E6%9C%AF/%E7%BC%96%E7%A0%81%E8%A7%A3%E7%A0%81%E4%B8%8E%E5%8D%8F%E8%AE%AE/%E5%AD%97%E7%AC%A6%E7%9A%84%E7%BC%96%E7%A0%81%E4%B8%8E%E8%A7%A3%E7%A0%81/%E5%AD%97%E7%AC%A6%E7%9A%84%E7%BC%96%E7%A0%81%E4%B8%8E%E8%A7%A3%E7%A0%81/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/8.%E9%80%9A%E7%94%A8%E6%8A%80%E6%9C%AF/%E7%BC%96%E7%A0%81%E8%A7%A3%E7%A0%81%E4%B8%8E%E5%8D%8F%E8%AE%AE/%E5%AD%97%E7%AC%A6%E7%9A%84%E7%BC%96%E7%A0%81%E4%B8%8E%E8%A7%A3%E7%A0%81/%E5%AD%97%E7%AC%A6%E7%9A%84%E7%BC%96%E7%A0%81%E4%B8%8E%E8%A7%A3%E7%A0%81/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Character_encoding">Wiki,Character encoding&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/ASCII">Wiki-ASCII&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Unicode">Wiki-Unicode&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://home.unicode.org/">Unicode 官网&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://unicode.org/main.html">Unicode 技术网站&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.unicode.org/charts/unihan.html">Unicode 字符集汉子数据库&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Variable-length_code">Wiki,Variable-length code&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/UTF-8">Wiki-UTF-8&lt;/a>&lt;/li>
&lt;li>&lt;a href="http://www.ruanyifeng.com/blog/2007/10/ascii_unicode_and_utf-8.html">阮一峰博客&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://mp.weixin.qq.com/s/vTh4LP8_Qew-S8s-3KqwJA">公众号,k8s 技术圈-计算机字符编码的前世今生&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.bilibili.com/video/av246038798">B 站,Golang 合辑-P1 string(这个 P 讲的就是字符的编码与解码)&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>我们知道计算机只认识二进制数据，其他格式的数据都需要转换成二进制才能被计算机处理，也就是说我们在计算机上看到的文本、视频、可执行程序等格式的文件，最终都会转换成二进制数据交给计算机处理&lt;/p>
&lt;p>计算机中最小的数据单位是 &lt;strong>bit&lt;/strong>，也叫&lt;strong>二进制位(简称：位)&lt;/strong>，每一个 bit 都有 0 和 1 两种状态，最早的计算机在设计时采用了 &lt;strong>8 个 bit 作为一个 Byte(字节)&lt;/strong>，所以一个字节能表示的最大整数就是二进制的 11111111 等于十进制的 255，一共 256 个数字(即.0~255)，想要表示更大的整数就必须要用多个字节，例如两个字节可以表示最大的整数就是二进制的 1111111111111111，共 16 位，等于十进制的 65535。&lt;/p>
&lt;p>更多的字节，就可以表示更大的数值范围，比如 32 位，最大可以表示为 4,294,967,295，我们平时说的 32 位电脑、64 位电脑，也是同一个意思，所以就说 32 位电脑，没法传输 4 G 以上的文件，就是因为其最大可以表示的数字就是 4,294,967,295，更大的文件，已经无法识别了。整数可以这么表示，那么字符怎么办呢？一堆二进制的 0 和 1，任何计算都无法算出字母 A 吧？~o(╯□╰)o&lt;/p>
&lt;p>聪明的人类啊~~~如果无法通过计算得到，那么就中转一下，人为规定就好了~比如：&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>字符&lt;/th>
&lt;th>十进制编号&lt;/th>
&lt;th>二进制编号&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>A&lt;/td>
&lt;td>65&lt;/td>
&lt;td>0100 0001&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>B&lt;/td>
&lt;td>66&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&amp;hellip;&amp;hellip;&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>a&lt;/td>
&lt;td>97&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&amp;hellip;&amp;hellip;&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>要存储字符时，就存储这个数值；要读取字符时，按照映射关系，找到这个字符；就像这样，收录许多字符，然后给它们一一编号，得到一个字符与编号的对照表，这就是 &lt;strong>Character sets(字符集)&lt;/strong>，经过这么多年的发展，大家对这个术语有很多种叫法：Character encoding(字符编码)、Character map(字符映射)、Code page(代码页) 都可以表示同一个概念。&lt;/p>
&lt;h1 id="ascii">ASCII&lt;/h1>
&lt;p>由于计算机是由美国人发明的，在 1967 年美国人制订了一套&lt;strong>字符集&lt;/strong>，规定了包含大小写字母、数字和一些符号共计 128 个字符与二进制数字的对应关系，这一套字符编码被称为 &lt;strong>American Standard Code for Information Interchange(美国标准信息交换码，简称 ASCII)&lt;/strong>，ASCII 一直沿用至今。&lt;/p>
&lt;p>英文比较简单，用 128 个符号编码就够了，就算需要其他的对应关系，也只需要扩展一下 ASCII 即可，一个 Byte，一共可以表示 256 个字符。但是用来表示中文就不够了，单单汉字就有超过 8 万个，所以就有了针对中文的编码标准出现，例如我们经常见到的 GB2312 字符集，使用两个字节表示一个汉字，理论上最多可以表示 65535 个；没有繁体字也不行啊，所以出现了 BIG 5 字符集；但是依然有许多字符没被收录。&lt;/p>
&lt;p>世界上有上百种语言，每种语言都有自己的编码标准，例如韩文编码 EUC_KR，日文编码 Shift_JIS，俄文编码 KOI8-R，为了促进互联网的发展，本着全球化统一标准的目的，制作一个通用字符集，&lt;strong>Unicode 应运而生。&lt;/strong>&lt;/p>
&lt;h1 id="unicode">Unicode&lt;/h1>
&lt;p>**Universal Coded Character Set(通用编码的字符集，简称 Unicode)，&lt;strong>在汉语中又称为&lt;/strong> 万国码、国际码、统一码，**它于 1990 年开始研发，并于 1994 年正式公布。&lt;strong>Unicode&lt;/strong> 对世界上大部分的文字系统进行了整理，使每一个文字符号都用独一无二的编码表示，当前 Unicode 最新的版本为 2019 年 5 月公布的 12.1.0，已经收录超过 13 万个字符，很明显 2 个字节已经无法保证所有字符都独一无二了，实际上最新的 Unicode 规定可以占用 4 字节来表示一个字符，理论上最多能表示 231 共计 2147483648 个字符。&lt;/p>
&lt;p>Unicode 使用 16 进制格式来表示一个字符，比如：
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/gptlcx/1616470249845-a210b975-ff93-4945-ba7e-aa06332e2473.png" alt="image.png">
&lt;code>\u&lt;/code> 是一个用来表示 Unicode 的标记。当计算机识别到这个标记时，就会使用 Unicode 进行解码。&lt;code>4f60&lt;/code> 表示 &lt;code>你&lt;/code>，&lt;code>597d&lt;/code> 表示 &lt;code>好&lt;/code>。&lt;/p>
&lt;p>所以随着技术的发展，Unicode 慢慢成为了一种 &lt;strong>Unicode Standard(Unicode 标准)&lt;/strong>&lt;/p>
&lt;h2 id="unicode-的问题">Unicode 的问题&lt;/h2>
&lt;p>需要注意的是，Unicode 只是一个字符集，它只规定了符号的二进制代码，却没有规定这个二进制代码应该如何存储。&lt;/p>
&lt;p>比如，汉字 &lt;code>严&lt;/code> 的 Unicode 是十六进制数 &lt;code>4E25&lt;/code>，转换成二进制数足足有 15 个 bit 位(&lt;code>100111000100101&lt;/code>)，也就是说，这个符号的表示至少需要 2 个字节。表示其他更大的符号，可能需要 3 个字节或者 4 个字节，甚至更多。&lt;/p>
&lt;p>这里就有两个严重的问题，第一个问题是，如何才能区别 Unicode 和 ASCII ？计算机怎么知道三个字节表示一个符号，而不是分别表示三个符号呢？第二个问题是，我们已经知道，英文字母只用一个字节表示就够了，如果 Unicode 统一规定，每个符号用三个或四个字节表示，那么每个英文字母前都必然有二到三个字节是 0，这对于存储来说是极大的浪费，文本文件的大小会因此大出二三倍，这是无法接受的。&lt;/p>
&lt;p>它们造成的结果是：&lt;/p>
&lt;ul>
&lt;li>出现了 Unicode 的多种存储方式，也就是说有许多种不同的二进制格式，可以用来表示 Unicode。&lt;/li>
&lt;li>Unicode 在很长一段时间内无法推广，直到互联网的出现。&lt;/li>
&lt;/ul>
&lt;p>其中一种 Unicode 的存储方式如下：
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/gptlcx/1636861654037-a5bcf9bc-3a12-4958-b308-71955c77229d.png" alt="image.png">
上图左侧的几个字符，通过字符集找到对应的二进制编号之后，你怎么知道这一大串二进制内容，就是 &lt;code>eggo世界&lt;/code> 这几个字符呢？&lt;/p>
&lt;p>正常来说是这样的：
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/gptlcx/1636861731027-04bdc7aa-cedd-456a-abd9-e07793eff7ed.png" alt="image.png">
但是，也可以这样啊：
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/gptlcx/1636861748931-7e8aa489-51ae-4b25-bba2-efe7ec588bc7.png" alt="image.png">&lt;/p>
&lt;p>这里面的主要问题，就是 **划分字符边界。**所以，我们需要一种编码规则，通过字符集中的对照关系，对二进制进行编码。&lt;/p>
&lt;p>那么可以这样，不管编号多大多小，统一按照最长的来，位数不够，高位补零，效果如下：
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/gptlcx/1636861872939-a637432d-a70e-4606-b7e8-b9d50450b19b.png" alt="image.png">
这种方式，&lt;strong>Fixed-length codes(固定长度编码)&lt;/strong>。虽然字符边界的问题解决了，但是。。。。。这么存数据。。。非常浪费内存啊。。。。&lt;/p>
&lt;p>互联网的普及，强烈要求出现一种统一的编码方式。既然&lt;strong>固定长度编码&lt;/strong>不行，咱就来个 &lt;strong>Variable length code(可变长度编码)。&lt;/strong>&lt;/p>
&lt;p>**UTF-8 **就是在互联网上使用最广的一种 &lt;strong>Unicode 的编码规则&lt;/strong>。其他实现方式还包括 UTF-16（字符用两个字节或四个字节表示）和 UTF-32（字符用四个字节表示），不过在互联网上基本不用。&lt;/p>
&lt;h2 id="utf">UTF&lt;/h2>
&lt;p>&lt;strong>Unicode Transformation Formats(Unicode 转换格式，简称 UTF) 是&lt;/strong>根据 Unicode 实现的一种编码&lt;strong>规则&lt;/strong>。&lt;/p>
&lt;p>Unicode 标准定义了 &lt;strong>Unicode Transformation Formats(Unicode 转换格式，简称 UTF)&lt;/strong>。UTF-8、UTF-16、UTF-32 以及其他几种编码。最常用的编码是 UTF-8&lt;/p>
&lt;h3 id="utf-8">UTF-8&lt;/h3>
&lt;p>UTF-8 最大的一个特点，它是一种变长的编码方式。它可以使用 1~4 个 Bytes 表示一个字符(最多 32 个 bit)，根据不同的符号而变化字节长度。&lt;/p>
&lt;p>UTF-8 顾名思义，是一套以 8 位为一个编码单位的可变长编码。会&lt;strong>将一个 &amp;ldquo;Unicom 编号&amp;rdquo; 重新编码为 1 到 4 个字节&lt;/strong>&lt;/p>
&lt;p>既然是可变长度编码，那么小编号的字符就要少占字节，大编号的多占字节，但是，怎么划分字符的边界呢？有这么一种方案：&lt;/p>
&lt;p>UTF -8 首先定义一组模板，规范如下：&lt;/p>
&lt;ul>
&lt;li>首先获取到该字符的 Unicom 编号，然后根据该字符编号，决定对字符编码时所使用的模板，每个字符编码后存储时，所使用的 &amp;ldquo;Bytes 数&amp;rdquo; 不同&lt;/li>
&lt;li>如果字符需要存储 1 Bytes，则，字节的第一位设为 0。
&lt;ul>
&lt;li>后面 7 位为这个符号的 Unicode 码。因此对于英语字母，UTF-8 编码和 ASCII 码是相同的。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>如果字符需要存储 n Bytes(&lt;code>n &amp;gt; 1&lt;/code>)，则一个字节的前 n 个 bit 位都设为 1，第 n + 1 bit 位 设为 0，后面字节的前 两 bit 位 一律设为 10。
&lt;ul>
&lt;li>剩下的没有提及的二进制位，全部为这个符号的 Unicode 码。
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>Unicom 编号&lt;/th>
&lt;th>字节数&lt;/th>
&lt;th>最高位标识位&lt;/th>
&lt;th>模板(二进制)&lt;/th>
&lt;th>模板(十六进制)&lt;/th>
&lt;th>模板可以填充的 bit 数&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>0~127&lt;/td>
&lt;td>1 Bytes&lt;/td>
&lt;td>0&lt;/td>
&lt;td>0???????&lt;/td>
&lt;td>0000 0000-0000 007F&lt;/td>
&lt;td>7&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>128~2047&lt;/td>
&lt;td>2 Bytes&lt;/td>
&lt;td>110 和 10&lt;/td>
&lt;td>110????? 10??????&lt;/td>
&lt;td>0000 0080-0000 07FF&lt;/td>
&lt;td>5 + 6&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>2048~65535&lt;/td>
&lt;td>3 Bytes&lt;/td>
&lt;td>1110 和 10 和 10&lt;/td>
&lt;td>1110???? 10?????? 10??????&lt;/td>
&lt;td>0000 0800-0000 FFFF&lt;/td>
&lt;td>4 + 6 + 6&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>65536~4294967295&lt;/td>
&lt;td>4 Bytes&lt;/td>
&lt;td>11110 和 10 和 10 和 10&lt;/td>
&lt;td>11110??? 10?????? 10?????? 10??????&lt;/td>
&lt;td>0001 0000-0010 FFFF&lt;/td>
&lt;td>3 + 6 + 6 + 6&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>跟据上表，解读 UTF-8 编码非常简单。如果一个 Bytes 的第一个 bit 是 0，则这个字节单独就是一个字符；如果第一位是 1，则连续有多少个 1，就表示当前字符占用多少个字节。&lt;/p>
&lt;p>比如：&lt;/p>
&lt;ul>
&lt;li>&lt;code>01100101&lt;/code> 最高位为 0，则表示这是一个只占 1 Bytes 的字符，并且是在 0~127 编号范围内的字符。
&lt;ul>
&lt;li>除去标识 bit，剩下的 7 bit 就是该字符的二进制编号，即 &lt;code>1100101&lt;/code>，十进制是 &lt;code>101&lt;/code>，十六进制是 &lt;code>0065&lt;/code>，也就是字符 &lt;code>e&lt;/code>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;code>11100100 10111000 10010110&lt;/code> 最高位是 1110，则表示这是一个占用 3 bytes 的字符，并且要和后面两个以 10 开头的字节共同表示一个字符，并且是在 2048~65535 编号范围内的字符。
&lt;ul>
&lt;li>除去标识 bit，剩下的 bit 组合起来，即 &lt;code>01001110 00010110&lt;/code>，十进制是 &lt;code>19990&lt;/code>，十六进制是 &lt;code>4E16&lt;/code> ，也就是字符 &lt;code>世&lt;/code>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>字符 &lt;code>界&lt;/code> 在 Unicode 中的编号为 &lt;code>30028&lt;/code>，十六进制是 &lt;code>754C&lt;/code>，二进制是 &lt;code>01110101 01001100&lt;/code>，也就是说，如果想要使用 UTF-8 对字符编码后储存，则应该占用 3 Byes，所以应该使用 &lt;code>1110???? 10?????? 10??????&lt;/code> 模板。
&lt;ul>
&lt;li>将 &lt;code>界&lt;/code> 的二进制 bit 填入到模板中，得到 &lt;code>**1110**0111 **10**010101 **10**001100&lt;/code>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h3 id="总结">总结&lt;/h3>
&lt;p>虽然使用 UTF-8 对字符进行编码后，依然会浪费一部分 bit，但是对比&lt;a href="#DRcSC">定长编码&lt;/a>，已经极大得节省了存储空间。&lt;/p>
&lt;h2 id="unicode-与-utf-的区别">Unicode 与 UTF 的区别&lt;/h2>
&lt;p>简单来说：&lt;/p>
&lt;ul>
&lt;li>Unicode 是 字符集，即字符与编号的对应关系&lt;/li>
&lt;li>UTF 是 编码规则&lt;/li>
&lt;/ul>
&lt;p>其中：&lt;/p>
&lt;ul>
&lt;li>字符集：为每一个「字符」分配一个唯一的 ID（学名为码位 / 码点 / Code Point）&lt;/li>
&lt;li>编码规则：将「码位」转换为字节序列的规则&lt;/li>
&lt;/ul>
&lt;p>广义的 Unicode 是一个标准，定义了一个字符集以及一系列的编码规则，即 Unicode 字符集和 UTF-8、UTF-16、UTF-32 等等编码规则……&lt;/p>
&lt;p>Unicode 字符集为每一个字符分配一个编号，例如「知」的 Unicom 编号是 30693，记作 U+77E5（30693 的十六进制为 0x77E5）。&lt;/p>
&lt;p>UTF-8 顾名思义，是一套以 8 位为一个编码单位的可变长编码。会将一个编号重新编码为 1 到 4 个字节：&lt;/p>
&lt;pre>&lt;code>U+ 0000 ~ U+ 007F: 0XXXXXXX
U+ 0080 ~ U+ 07FF: 110XXXXX 10XXXXXX
U+ 0800 ~ U+ FFFF: 1110XXXX 10XXXXXX 10XXXXXX
U+10000 ~ U+10FFFF: 11110XXX 10XXXXXX 10XXXXXX 10XXXXXX
&lt;/code>&lt;/pre>
&lt;p>根据上表中的编码规则，之前的「知」字的码位 U+77E5 属于第三行的范围：&lt;/p>
&lt;pre>&lt;code>7 7 E 5
0111 0111 1110 0101 二进制的 77E5
--------------------------
0111 011111 100101 二进制的 77E5
1110XXXX 10XXXXXX 10XXXXXX 模版（上表第三行）
11100111 10011111 10100101 代入模版
E 7 9 F A 5
&lt;/code>&lt;/pre>
&lt;p>这就是将 U+77E5 按照 UTF-8 编码为字节序列 E79FA5 的过程。反之亦然。&lt;/p>
&lt;h1 id="乱码的出现">乱码的出现&lt;/h1>
&lt;p>从上边的编码介绍中我们已经知道了不同编码的存在，那么想要查看一个文件，就必须知道他的编码方式，用错误的编码方式打开文件就会出现乱码。
linux 下可以通过 file 命令查看文件的编码方式&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>root@lichenhao:~# touch encoding_file
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>root@lichenhao:~# file encoding_file
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>encoding_file: empty
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>root@lichenhao:~# echo &lt;span style="color:#e6db74">&amp;#34;hello world!&amp;#34;&lt;/span> &amp;gt; encoding_file
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>root@lichenhao:~# file encoding_file
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>encoding_file: ASCII text
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>root@lichenhao:~# echo &lt;span style="color:#e6db74">&amp;#34;你好，世界！&amp;#34;&lt;/span> &amp;gt;&amp;gt; encoding_file
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>root@lichenhao:~# file encoding_file
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>encoding_file: UTF-8 Unicode text
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>工作中我们在 XSHELL 之类的终端中查看文件时出现的乱码就是系统或文件保存的中文编码与终端设置的编码不一致，从而导致解码错误。这里涉及到三方编码：&lt;/p>
&lt;ol>
&lt;li>文件内容或文件名&lt;/li>
&lt;li>SHELL 环境的语言编码&lt;/li>
&lt;li>XSHELL 之类的终端编码&lt;/li>
&lt;/ol>
&lt;p>需要保持三方编码统一，才不会有乱码的出现，其中 SHELL 环境的语言编码指的是登陆服务器的 SHELL 环境时指定的语言编码，例如 LANG、LC_*这些变量设置的编码，XSHELL 之类终端编码就是这类终端软件设置的编码
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/gptlcx/1616053185837-0c93a28f-6155-47e3-9cf4-bbb563b402c1.jpeg" alt="">
所有遇到的乱码问题都仔细检查以上三方编码是否一致，就可以顺利解决了，同时也建议在工作中制定相应的规范，减少乱码的发生&lt;/p>
&lt;p>此时，我现在将 Xshell 中的编码规则变为其他的
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/gptlcx/1616475169200-5248e6d0-2b70-47f6-9a88-5f7c46a4758c.png" alt="image.png">
此时再看这个文件，就发现，已经无法正确解码了:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>root@lichenhao:~# cat encoding_file
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>hello world!
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>浣??ソ锛???????
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="乱码处理技巧">乱码处理技巧&lt;/h2>
&lt;ol>
&lt;li>临时切换命令输出语言
正常情况下命令的输出结果都遵循系统设置的语言编码，例如&lt;/li>
&lt;/ol>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>root@ops-coffee:~# echo $LANG
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>zh_CN.UTF-8
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>root@ops-coffee:~# date
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>2020年 03月 04日 星期三 19:00:55 HKT
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>root@ops-coffee:~# export LANG&lt;span style="color:#f92672">=&lt;/span>en_US.UTF-8
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>root@ops-coffee:~# echo $LANG
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>en_US.UTF-8
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>root@ops-coffee:~# date
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Wed Mar &lt;span style="color:#ae81ff">4&lt;/span> 19:01:21 HKT &lt;span style="color:#ae81ff">2020&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>运维脚本中，我们希望所有系统执行相同命令的时候输出的结果一致，不要因为字符集不同而产生不同的结果，那么如可处理呢？在命令前添加 LC_ALL=C&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>root@ops-coffee:~# date
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>2020年 03月 04日 星期三 19:05:58 HKT
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>root@ops-coffee:~# LC_ALL&lt;span style="color:#f92672">=&lt;/span>C date
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Wed Mar &lt;span style="color:#ae81ff">4&lt;/span> 19:06:05 HKT &lt;span style="color:#ae81ff">2020&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>这里之所以用 LC_ALL 是因为在 LOCALE 标准中，LC_ALL 优先级最高：LC_ALL&amp;gt;LC_*&amp;gt;LANG&lt;/p>
&lt;ol start="2">
&lt;li>批量转换文件名编码&lt;/li>
&lt;/ol>
&lt;p>有时候我们会遇到文件名或者目录名乱码的问题，尤其是在不同类型系统之间传输时，可以借助 rsync 实现批量转换文件名或目录名的编码
rsync -av &amp;ndash;iconv=GBK,UTF8 /www/ /nav/
iconv 模块在 rsync 的 3.0 以后版本中才支持，用法为&amp;ndash;iconv=,，需要注意的是，本地两个目录之间同步时 LOCAL 表示的是源目录的文件名编码，通过网络同步时 LOCAL 表示本地编码&lt;/p></description></item><item><title>Docs: Containerd 部署</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/10.%E4%BA%91%E5%8E%9F%E7%94%9F/2.2.%E5%AE%9E%E7%8E%B0%E5%AE%B9%E5%99%A8%E7%9A%84%E5%B7%A5%E5%85%B7/containerd/containerd-%E9%83%A8%E7%BD%B2/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/10.%E4%BA%91%E5%8E%9F%E7%94%9F/2.2.%E5%AE%9E%E7%8E%B0%E5%AE%B9%E5%99%A8%E7%9A%84%E5%B7%A5%E5%85%B7/containerd/containerd-%E9%83%A8%E7%BD%B2/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://github.com/containerd/containerd/blob/main/docs/getting-started.md">GitHub 文档，containerd/containerd/docs/getting-started.md&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;h1 id="安装-containerd">安装 Containerd&lt;/h1>
&lt;p>是否需要 libseccomp2 依赖？待验证&lt;/p>
&lt;h2 id="使用包管理器安装">使用包管理器安装&lt;/h2>
&lt;h3 id="centos">CentOS&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>yum install -y yum-utils device-mapper-persistent-data lvm2
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>yum-config-manager --add-repo http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>yum install -y containerd.io
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="ubuntu">Ubuntu&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>sudo apt-get -y install apt-transport-https ca-certificates curl gnupg-agent software-properties-common
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>curl -fsSL https://mirrors.aliyun.com/docker-ce/linux/ubuntu/gpg | sudo apt-key add -
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>sudo add-apt-repository &lt;span style="color:#e6db74">&amp;#34;deb [arch=amd64] https://mirrors.aliyun.com/docker-ce/linux/ubuntu &lt;/span>&lt;span style="color:#66d9ef">$(&lt;/span>lsb_release -cs&lt;span style="color:#66d9ef">)&lt;/span>&lt;span style="color:#e6db74"> stable&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>sudo apt-get -y update
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>sudo apt-get -y install containerd.io
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="配置-unit-文件">配置 unit 文件&lt;/h3>
&lt;p>略&lt;/p>
&lt;h2 id="使用二进制文件安装">使用二进制文件安装&lt;/h2>
&lt;p>通常，我们使用二进制安装 Containerd 时，除了 Containerd 的本体，还需要安装 runc 与 CNI。&lt;/p>
&lt;p>注意：在 1.6.0 版本的更新说明中，对 Releases 中的包进行一些调整，将在未来的 2.0 版本之后弃用一些东西&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/gg4dmt/1654268589875-dff18ee5-d643-489f-9c13-b8bc1dd4e99d.png" alt="image.png">&lt;/p>
&lt;p>这里说的主要是对那些整合包的弃用，让 containerd 的 realease 更纯粹，那些带着 cni 或 cri 的整合包，都没有了。并且，根据 1.6 版本的官方文档的安装说明，CRI 功能已经整合在 containerd 中，所以更无须下载整合包了。&lt;/p>
&lt;h3 id="安装-containerd-1">安装 Containerd&lt;/h3>
&lt;p>在 &lt;a href="https://github.com/containerd/containerd/releases">release&lt;/a> 页面下载二进制程序压缩包，解压并将二进制程序放到 $PATH 中&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>export ARCH&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;amd64&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>export CONTAINER_VERSION&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;1.6.16&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>export OS&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;linux&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>wget https://github.com/containerd/containerd/releases/download/v&lt;span style="color:#e6db74">${&lt;/span>CONTAINER_VERSION&lt;span style="color:#e6db74">}&lt;/span>/containerd-&lt;span style="color:#e6db74">${&lt;/span>CONTAINER_VERSION&lt;span style="color:#e6db74">}&lt;/span>-&lt;span style="color:#e6db74">${&lt;/span>OS&lt;span style="color:#e6db74">}&lt;/span>-&lt;span style="color:#e6db74">${&lt;/span>ARCH&lt;span style="color:#e6db74">}&lt;/span>.tar.gz
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>tar Cxzvf /usr/local containerd-&lt;span style="color:#e6db74">${&lt;/span>CONTAINER_VERSION&lt;span style="color:#e6db74">}&lt;/span>-&lt;span style="color:#e6db74">${&lt;/span>OS&lt;span style="color:#e6db74">}&lt;/span>-&lt;span style="color:#e6db74">${&lt;/span>ARCH&lt;span style="color:#e6db74">}&lt;/span>.tar.gz
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="安装-runc">安装 runc&lt;/h3>
&lt;p>从 &lt;a href="https://github.com/opencontainers/runc/releases">GitHub 项目，opencontainers/runc 的 Releases&lt;/a> 处下载 &lt;code>runc.&amp;lt;ARCH&amp;gt;&lt;/code> 二进制文件，拷贝到 &lt;code>/usr/local/sbin/runc&lt;/code> 处&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>export ARCH&lt;span style="color:#f92672">=&lt;/span>amd64
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>cp runc.&lt;span style="color:#e6db74">${&lt;/span>ARCH&lt;span style="color:#e6db74">}&lt;/span> /usr/local/sbin/runc &lt;span style="color:#f92672">&amp;amp;&amp;amp;&lt;/span> chmod &lt;span style="color:#ae81ff">755&lt;/span> /usr/local/sbin/runc
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="安装-cni-插件">安装 CNI 插件&lt;/h3>
&lt;p>从 &lt;a href="https://github.com/containernetworking/plugins/releases">GitHub 项目，containernetworking/plugins 的 Releases&lt;/a> 处下载 &lt;code>cni-plugins-&amp;lt;OS&amp;gt;-&amp;lt;ARCH&amp;gt;-&amp;lt;VERSION&amp;gt;.tgz&lt;/code> 文件，解压到 &lt;code>/opt/cni/bin/&lt;/code> 目录下&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>export OS&lt;span style="color:#f92672">=&lt;/span>linux
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>export ARCH&lt;span style="color:#f92672">=&lt;/span>amd64
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>export VERSION&lt;span style="color:#f92672">=&lt;/span>v1.1.1
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>mkdir -p /opt/cni/bin
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>tar Cxzvf /opt/cni/bin cni-plugins-&lt;span style="color:#e6db74">${&lt;/span>OS&lt;span style="color:#e6db74">}&lt;/span>-&lt;span style="color:#e6db74">${&lt;/span>ARCH&lt;span style="color:#e6db74">}&lt;/span>-&lt;span style="color:#e6db74">${&lt;/span>VERSION&lt;span style="color:#e6db74">}&lt;/span>.tgz
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="配置-unit-文件-1">配置 Unit 文件&lt;/h3>
&lt;p>从 &lt;a href="https://github.com/containerd/containerd/blob/main/containerd.service">GitHub 项目文件，containerd/containerd/containerd.service&lt;/a> 中下载用于 Systemd 的 Unit 文件。(对于 cri-containerd-&amp;hellip;. 类型的 release 压缩文件中包含 Unit 文件)&lt;/p>
&lt;p>这是一个 1.4.4 版本的 continerd.service 文件样例：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">[&lt;/span>Unit&lt;span style="color:#f92672">]&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Description&lt;span style="color:#f92672">=&lt;/span>containerd container runtime
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Documentation&lt;span style="color:#f92672">=&lt;/span>https://containerd.io
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>After&lt;span style="color:#f92672">=&lt;/span>network.target local-fs.target
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">[&lt;/span>Service&lt;span style="color:#f92672">]&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>ExecStartPre&lt;span style="color:#f92672">=&lt;/span>-/sbin/modprobe overlay
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>ExecStart&lt;span style="color:#f92672">=&lt;/span>/usr/local/bin/containerd
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Type&lt;span style="color:#f92672">=&lt;/span>notify
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Delegate&lt;span style="color:#f92672">=&lt;/span>yes
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>KillMode&lt;span style="color:#f92672">=&lt;/span>process
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Restart&lt;span style="color:#f92672">=&lt;/span>always
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>RestartSec&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">5&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># Having non-zero Limit*s causes performance problems due to accounting overhead&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># in the kernel. We recommend using cgroups to do container-local accounting.&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>LimitNPROC&lt;span style="color:#f92672">=&lt;/span>infinity
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>LimitCORE&lt;span style="color:#f92672">=&lt;/span>infinity
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>LimitNOFILE&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">1048576&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># Comment TasksMax if your systemd version does not supports it.&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># Only systemd 226 and above support this version.&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>TasksMax&lt;span style="color:#f92672">=&lt;/span>infinity
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>OOMScoreAdjust&lt;span style="color:#f92672">=&lt;/span>-999
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">[&lt;/span>Install&lt;span style="color:#f92672">]&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>WantedBy&lt;span style="color:#f92672">=&lt;/span>multi-user.target
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h1 id="配置并启动-containerd">配置并启动 Containerd&lt;/h1>
&lt;h2 id="添加-containerd-配置文件">添加 containerd 配置文件&lt;/h2>
&lt;p>通过命令生成配置文件&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>containerd config default &amp;gt; /etc/containerd/config.toml
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="修改内核参数">修改内核参数&lt;/h2>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>cat &amp;gt; /etc/sysctl.d/containerd.conf &lt;span style="color:#e6db74">&amp;lt;&amp;lt; EOF
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">net.ipv4.ip_forward = 1
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">EOF&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>sysctl -p /etc/sysctl.d/*
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="启动-containerd">启动 containerd&lt;/h2>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>systemctl daemon-reload
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>systemctl enable containerd --now
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h1 id="rootless-模式">rootless 模式&lt;/h1>
&lt;p>强烈推荐开启 cgroup v2，否则最好不要使用 rootless 模式，开启参考：https://rootlesscontaine.rs/getting-started/common/cgroup2/&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">[&lt;/span>INFO&lt;span style="color:#f92672">]&lt;/span> Checking RootlessKit functionality
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">[&lt;/span>INFO&lt;span style="color:#f92672">]&lt;/span> Checking cgroup v2
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">[&lt;/span>WARNING&lt;span style="color:#f92672">]&lt;/span> Enabling cgroup v2 is highly recommended, see https://rootlesscontaine.rs/getting-started/common/cgroup2/
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">[&lt;/span>INFO&lt;span style="color:#f92672">]&lt;/span> Checking overlayfs
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">[&lt;/span>INFO&lt;span style="color:#f92672">]&lt;/span> Requirements are satisfied
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">[&lt;/span>INFO&lt;span style="color:#f92672">]&lt;/span> Creating &lt;span style="color:#e6db74">&amp;#34;/home/lichenhao/.config/systemd/user/containerd.service&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">[&lt;/span>INFO&lt;span style="color:#f92672">]&lt;/span> Starting systemd unit &lt;span style="color:#e6db74">&amp;#34;containerd.service&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>+ systemctl --user start containerd.service
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>+ sleep &lt;span style="color:#ae81ff">3&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>+ systemctl --user --no-pager --full status containerd.service
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>● containerd.service - containerd &lt;span style="color:#f92672">(&lt;/span>Rootless&lt;span style="color:#f92672">)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Loaded: loaded &lt;span style="color:#f92672">(&lt;/span>/home/lichenhao/.config/systemd/user/containerd.service; disabled; vendor preset: enabled&lt;span style="color:#f92672">)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Active: active &lt;span style="color:#f92672">(&lt;/span>running&lt;span style="color:#f92672">)&lt;/span> since Mon 2021-09-13 21:48:44 CST; 3s ago
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Main PID: &lt;span style="color:#ae81ff">2625&lt;/span> &lt;span style="color:#f92672">(&lt;/span>rootlesskit&lt;span style="color:#f92672">)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> CGroup: /user.slice/user-1000.slice/user@1000.service/containerd.service
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ├─2625 rootlesskit --state-dir&lt;span style="color:#f92672">=&lt;/span>/run/user/1000/containerd-rootless --net&lt;span style="color:#f92672">=&lt;/span>slirp4netns --mtu&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">65520&lt;/span> --slirp4netns-sandbox&lt;span style="color:#f92672">=&lt;/span>auto --slirp4netns-seccomp&lt;span style="color:#f92672">=&lt;/span>auto --disable-host-loopback --port-driver&lt;span style="color:#f92672">=&lt;/span>builtin --copy-up&lt;span style="color:#f92672">=&lt;/span>/etc --copy-up&lt;span style="color:#f92672">=&lt;/span>/run --copy-up&lt;span style="color:#f92672">=&lt;/span>/var/lib --propagation&lt;span style="color:#f92672">=&lt;/span>rslave /usr/local/bin/containerd-rootless.sh
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ├─2635 /proc/self/exe --state-dir&lt;span style="color:#f92672">=&lt;/span>/run/user/1000/containerd-rootless --net&lt;span style="color:#f92672">=&lt;/span>slirp4netns --mtu&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">65520&lt;/span> --slirp4netns-sandbox&lt;span style="color:#f92672">=&lt;/span>auto --slirp4netns-seccomp&lt;span style="color:#f92672">=&lt;/span>auto --disable-host-loopback --port-driver&lt;span style="color:#f92672">=&lt;/span>builtin --copy-up&lt;span style="color:#f92672">=&lt;/span>/etc --copy-up&lt;span style="color:#f92672">=&lt;/span>/run --copy-up&lt;span style="color:#f92672">=&lt;/span>/var/lib --propagation&lt;span style="color:#f92672">=&lt;/span>rslave /usr/local/bin/containerd-rootless.sh
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ├─2651 slirp4netns --mtu &lt;span style="color:#ae81ff">65520&lt;/span> -r &lt;span style="color:#ae81ff">3&lt;/span> --disable-host-loopback --enable-sandbox --enable-seccomp &lt;span style="color:#ae81ff">2635&lt;/span> tap0
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> └─2659 containerd
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>9月 &lt;span style="color:#ae81ff">13&lt;/span> 21:48:44 hw-cloud-xngy-jump-server-linux-2 containerd-rootless.sh&lt;span style="color:#f92672">[&lt;/span>2659&lt;span style="color:#f92672">]&lt;/span>: time&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;2021-09-13T21:48:44.601967589+08:00&amp;#34;&lt;/span> level&lt;span style="color:#f92672">=&lt;/span>info msg&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;loading plugin \&amp;#34;io.containerd.grpc.v1.cri\&amp;#34;...&amp;#34;&lt;/span> type&lt;span style="color:#f92672">=&lt;/span>io.containerd.grpc.v1
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>9月 &lt;span style="color:#ae81ff">13&lt;/span> 21:48:44 hw-cloud-xngy-jump-server-linux-2 containerd-rootless.sh&lt;span style="color:#f92672">[&lt;/span>2659&lt;span style="color:#f92672">]&lt;/span>: time&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;2021-09-13T21:48:44.602049316+08:00&amp;#34;&lt;/span> level&lt;span style="color:#f92672">=&lt;/span>info msg&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;Start cri plugin with config {PluginConfig:{ContainerdConfig:{Snapshotter:overlayfs DefaultRuntimeName:runc DefaultRuntime:{Type: Engine: PodAnnotations:[] ContainerAnnotations:[] Root: Options:map[] PrivilegedWithoutHostDevices:false BaseRuntimeSpec:} UntrustedWorkloadRuntime:{Type: Engine: PodAnnotations:[] ContainerAnnotations:[] Root: Options:map[] PrivilegedWithoutHostDevices:false BaseRuntimeSpec:} Runtimes:map[runc:{Type:io.containerd.runc.v2 Engine: PodAnnotations:[] ContainerAnnotations:[] Root: Options:map[BinaryName: CriuImagePath: CriuPath: CriuWorkPath: IoGid:0 IoUid:0 NoNewKeyring:false NoPivotRoot:false Root: ShimCgroup: SystemdCgroup:false] PrivilegedWithoutHostDevices:false BaseRuntimeSpec:}] NoPivot:false DisableSnapshotAnnotations:true DiscardUnpackedLayers:false} CniConfig:{NetworkPluginBinDir:/opt/cni/bin NetworkPluginConfDir:/etc/cni/net.d NetworkPluginMaxConfNum:1 NetworkPluginConfTemplate:} Registry:{ConfigPath: Mirrors:map[] Configs:map[] Auths:map[] Headers:map[]} ImageDecryption:{KeyModel:node} DisableTCPService:true StreamServerAddress:127.0.0.1 StreamServerPort:0 StreamIdleTimeout:4h0m0s EnableSelinux:false SelinuxCategoryRange:1024 SandboxImage:k8s.gcr.io/pause:3.5 StatsCollectPeriod:10 SystemdCgroup:false EnableTLSStreaming:false X509KeyPairStreaming:{TLSCertFile: TLSKeyFile:} MaxContainerLogLineSize:16384 DisableCgroup:false DisableApparmor:false RestrictOOMScoreAdj:false MaxConcurrentDownloads:3 DisableProcMount:false UnsetSeccompProfile: TolerateMissingHugetlbController:true DisableHugetlbController:true IgnoreImageDefinedVolumes:false NetNSMountsUnderStateDir:false} ContainerdRootDir:/var/lib/containerd ContainerdEndpoint:/run/containerd/containerd.sock RootDir:/var/lib/containerd/io.containerd.grpc.v1.cri StateDir:/run/containerd/io.containerd.grpc.v1.cri}&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>9月 &lt;span style="color:#ae81ff">13&lt;/span> 21:48:44 hw-cloud-xngy-jump-server-linux-2 containerd-rootless.sh&lt;span style="color:#f92672">[&lt;/span>2659&lt;span style="color:#f92672">]&lt;/span>: time&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;2021-09-13T21:48:44.602101237+08:00&amp;#34;&lt;/span> level&lt;span style="color:#f92672">=&lt;/span>info msg&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;Connect containerd service&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>9月 &lt;span style="color:#ae81ff">13&lt;/span> 21:48:44 hw-cloud-xngy-jump-server-linux-2 containerd-rootless.sh&lt;span style="color:#f92672">[&lt;/span>2659&lt;span style="color:#f92672">]&lt;/span>: time&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;2021-09-13T21:48:44.602157949+08:00&amp;#34;&lt;/span> level&lt;span style="color:#f92672">=&lt;/span>info msg&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;Get image filesystem path \&amp;#34;/var/lib/containerd/io.containerd.snapshotter.v1.overlayfs\&amp;#34;&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>9月 &lt;span style="color:#ae81ff">13&lt;/span> 21:48:44 hw-cloud-xngy-jump-server-linux-2 containerd-rootless.sh&lt;span style="color:#f92672">[&lt;/span>2659&lt;span style="color:#f92672">]&lt;/span>: time&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;2021-09-13T21:48:44.602220361+08:00&amp;#34;&lt;/span> level&lt;span style="color:#f92672">=&lt;/span>warning msg&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;Running containerd in a user namespace typically requires disable_cgroup, disable_apparmor, restrict_oom_score_adj set to be true&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>9月 &lt;span style="color:#ae81ff">13&lt;/span> 21:48:44 hw-cloud-xngy-jump-server-linux-2 containerd-rootless.sh&lt;span style="color:#f92672">[&lt;/span>2659&lt;span style="color:#f92672">]&lt;/span>: time&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;2021-09-13T21:48:44.602782645+08:00&amp;#34;&lt;/span> level&lt;span style="color:#f92672">=&lt;/span>warning msg&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;failed to load plugin io.containerd.grpc.v1.cri&amp;#34;&lt;/span> error&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;failed to create CRI service: failed to create cni conf monitor: failed to create cni conf dir=/etc/cni/net.d for watch: mkdir /etc/cni/net.d: permission denied&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>9月 &lt;span style="color:#ae81ff">13&lt;/span> 21:48:44 hw-cloud-xngy-jump-server-linux-2 containerd-rootless.sh&lt;span style="color:#f92672">[&lt;/span>2659&lt;span style="color:#f92672">]&lt;/span>: time&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;2021-09-13T21:48:44.602807316+08:00&amp;#34;&lt;/span> level&lt;span style="color:#f92672">=&lt;/span>info msg&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;loading plugin \&amp;#34;io.containerd.grpc.v1.introspection\&amp;#34;...&amp;#34;&lt;/span> type&lt;span style="color:#f92672">=&lt;/span>io.containerd.grpc.v1
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>9月 &lt;span style="color:#ae81ff">13&lt;/span> 21:48:44 hw-cloud-xngy-jump-server-linux-2 containerd-rootless.sh&lt;span style="color:#f92672">[&lt;/span>2659&lt;span style="color:#f92672">]&lt;/span>: time&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;2021-09-13T21:48:44.603004589+08:00&amp;#34;&lt;/span> level&lt;span style="color:#f92672">=&lt;/span>info msg&lt;span style="color:#f92672">=&lt;/span>serving... address&lt;span style="color:#f92672">=&lt;/span>/run/containerd/containerd.sock.ttrpc
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>9月 &lt;span style="color:#ae81ff">13&lt;/span> 21:48:44 hw-cloud-xngy-jump-server-linux-2 containerd-rootless.sh&lt;span style="color:#f92672">[&lt;/span>2659&lt;span style="color:#f92672">]&lt;/span>: time&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;2021-09-13T21:48:44.603068510+08:00&amp;#34;&lt;/span> level&lt;span style="color:#f92672">=&lt;/span>info msg&lt;span style="color:#f92672">=&lt;/span>serving... address&lt;span style="color:#f92672">=&lt;/span>/run/containerd/containerd.sock
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>9月 &lt;span style="color:#ae81ff">13&lt;/span> 21:48:44 hw-cloud-xngy-jump-server-linux-2 containerd-rootless.sh&lt;span style="color:#f92672">[&lt;/span>2659&lt;span style="color:#f92672">]&lt;/span>: time&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;2021-09-13T21:48:44.603088751+08:00&amp;#34;&lt;/span> level&lt;span style="color:#f92672">=&lt;/span>info msg&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;containerd successfully booted in 0.056085s&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>+ systemctl --user enable containerd.service
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Created symlink /home/lichenhao/.config/systemd/user/default.target.wants/containerd.service → /home/lichenhao/.config/systemd/user/containerd.service.
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">[&lt;/span>INFO&lt;span style="color:#f92672">]&lt;/span> Installed &lt;span style="color:#e6db74">&amp;#34;containerd.service&amp;#34;&lt;/span> successfully.
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">[&lt;/span>INFO&lt;span style="color:#f92672">]&lt;/span> To control &lt;span style="color:#e6db74">&amp;#34;containerd.service&amp;#34;&lt;/span>, run: &lt;span style="color:#e6db74">`&lt;/span>systemctl --user &lt;span style="color:#f92672">(&lt;/span>start|stop|restart&lt;span style="color:#f92672">)&lt;/span> containerd.service&lt;span style="color:#e6db74">`&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">[&lt;/span>INFO&lt;span style="color:#f92672">]&lt;/span> To run &lt;span style="color:#e6db74">&amp;#34;containerd.service&amp;#34;&lt;/span> on system startup automatically, run: &lt;span style="color:#e6db74">`&lt;/span>sudo loginctl enable-linger lichenhao&lt;span style="color:#e6db74">`&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">[&lt;/span>INFO&lt;span style="color:#f92672">]&lt;/span> ------------------------------------------------------------------------------------------
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">[&lt;/span>INFO&lt;span style="color:#f92672">]&lt;/span> Use &lt;span style="color:#e6db74">`&lt;/span>nerdctl&lt;span style="color:#e6db74">`&lt;/span> to connect to the rootless containerd.
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">[&lt;/span>INFO&lt;span style="color:#f92672">]&lt;/span> You &lt;span style="color:#66d9ef">do&lt;/span> NOT need to specify $CONTAINERD_ADDRESS explicitly.
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>没法使用 host network 模式，找不到解决办法，好 TM 麻烦&lt;/p></description></item><item><title>Docs: Core</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/y.windows-%E7%AE%A1%E7%90%86/windows%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/powershell%E5%86%85%E7%BD%AE%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/core/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/y.windows-%E7%AE%A1%E7%90%86/windows%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/powershell%E5%86%85%E7%BD%AE%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/core/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://learn.microsoft.com/en-us/powershell/module/microsoft.powershell.core">官方文档-PowerShell，模块-Core&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>核心模块包含管理 PowerShell 基本功能的 cmdlet 和提供程序。&lt;/p>
&lt;h1 id="get-command">Get-Command&lt;/h1>
&lt;p>获取所有命令&lt;/p>
&lt;h2 id="syntax语法">Syntax(语法)&lt;/h2>
&lt;p>&lt;strong>Get-Command [OPTIONS]&lt;/strong>&lt;/p>
&lt;p>&lt;strong>OPTIONS&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>&lt;strong>-Name &amp;lt;PATTERN&amp;gt;&lt;/strong> # 列出匹配到名字的命令。支持通配符。&lt;code>默认值：None&lt;/code>&lt;/li>
&lt;li>&lt;strong>-CommandType &amp;lt;STRING&amp;gt;&lt;/strong> # 列出指定类型的命令。&lt;code>默认值：cmdlet,function,alias&lt;/code>。可用的类型有：Alias、All、Application、Cmdlet、ExternalScript、Filter、Function、Script&lt;/li>
&lt;/ul>
&lt;h2 id="example">EXAMPLE&lt;/h2></description></item><item><title>Docs: ECMAScript 模块与包</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/2.%E7%BC%96%E7%A8%8B/%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/ecmascript/ecmascript-%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8/ecmascript-%E6%A8%A1%E5%9D%97%E4%B8%8E%E5%8C%85/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/2.%E7%BC%96%E7%A8%8B/%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/ecmascript/ecmascript-%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8/ecmascript-%E6%A8%A1%E5%9D%97%E4%B8%8E%E5%8C%85/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Modules">MDN-参考，JavaScript-JavaScript 指南-JavaScript 模块&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://wangdoc.com/es6/module.html">网道，ES6 教程-Module 的语法&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.zhangxinxu.com/wordpress/2018/08/browser-native-es6-export-import-module/">https://www.zhangxinxu.com/wordpress/2018/08/browser-native-es6-export-import-module/&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>历史上，JavaScript 一直没有 Module(模块) 体系，无法将一个大程序拆分成互相依赖的小文件，再用简单的方法拼装起来。其他语言都有这项功能，比如 Ruby 的 require、Python 的 import，甚至就连 CSS 都有@import，但是 JavaScript 任何这方面的支持都没有，这对开发大型的、复杂的项目形成了巨大障碍。&lt;/p>
&lt;p>在 ES6 之前，社区制定了一些模块加载方案，最主要的有 2009 年 1 月发起的 CommonJS 和 AMD 两种，前者用于服务器，后者用于浏览器。&lt;/p>
&lt;blockquote>
&lt;p>2013 年 5 月，npm 的作者宣布 Node.js 已经废弃 CommonJS，详见 &lt;a href="https://github.com/nodejs/node-v0.x-archive/issues/5132#issuecomment-15432598">GitHub issue-5132，nodejs/node-v0.x-archive&lt;/a> &amp;gt; &lt;a href="https://en.wikipedia.org/wiki/Asynchronous_module_definition">Wiki,Asynchronous_module_definition&lt;/a>(异步模块定义，简称 AMD)&lt;/p>
&lt;/blockquote>
&lt;p>比如，CommonJS 模块就是对象，输入时必须查找对象属性。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-javascript" data-lang="javascript">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// CommonJS 标准
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">let&lt;/span> { &lt;span style="color:#a6e22e">stat&lt;/span>, &lt;span style="color:#a6e22e">exists&lt;/span>, &lt;span style="color:#a6e22e">readfile&lt;/span> } &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#a6e22e">require&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;fs&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 等同于 js 代码
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">let&lt;/span> &lt;span style="color:#a6e22e">_fs&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#a6e22e">require&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;fs&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">let&lt;/span> &lt;span style="color:#a6e22e">stat&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#a6e22e">_fs&lt;/span>.&lt;span style="color:#a6e22e">stat&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">let&lt;/span> &lt;span style="color:#a6e22e">exists&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#a6e22e">_fs&lt;/span>.&lt;span style="color:#a6e22e">exists&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">let&lt;/span> &lt;span style="color:#a6e22e">readfile&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#a6e22e">_fs&lt;/span>.&lt;span style="color:#a6e22e">readfile&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>上面代码的实质是整体加载 fs 模块（即加载 fs 的所有方法），生成一个对象（_fs），然后再从这个对象上面读取 3 个方法。这种加载称为“运行时加载”，因为只有运行时才能得到这个对象，导致完全没办法在编译时做“静态优化”。&lt;/p>
&lt;h2 id="es6-module">ES6 Module&lt;/h2>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://beginor.github.io/2021/08/16/using-es-modules-in-borwser-with-importmaps.html">https://beginor.github.io/2021/08/16/using-es-modules-in-borwser-with-importmaps.html&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>&lt;strong>ES6 Module(ES6 模块，简称 ESM)&lt;/strong>，ES6 在语言标准的层面上，实现了模块功能，而且实现得相当简单，完全可以取代 CommonJS 和 AMD 规范，成为浏览器和服务器通用的模块解决方案。这种模块功能与 ES6 一起发布于 2015 年&lt;/p>
&lt;p>ES6 模块的设计思想是尽量的静态化，使得编译时就能确定模块的依赖关系，以及输入和输出的变量。CommonJS 和 AMD 模块，都只能在运行时确定这些东西。&lt;/p>
&lt;p>通常来说，&lt;strong>一个模块指的一组文件的合集&lt;/strong>，只不过在通过编译工具编译后，将合并成一个文件。&lt;/p>
&lt;p>ES6 模块不是对象，而是通过 export 命令显式指定输出的代码，再通过 import 命令输入。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-javascript" data-lang="javascript">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// ES6 模块
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">import&lt;/span> { &lt;span style="color:#a6e22e">stat&lt;/span>, &lt;span style="color:#a6e22e">exists&lt;/span>, &lt;span style="color:#a6e22e">readFile&lt;/span> } &lt;span style="color:#a6e22e">from&lt;/span> &lt;span style="color:#e6db74">&amp;#34;fs&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>上面代码的实质是从 fs 模块加载 3 个方法，其他方法不加载。这种加载称为“编译时加载”或者静态加载，即 ES6 可以在编译时就完成模块加载，效率要比 CommonJS 模块的加载方式高。当然，这也导致了没法引用 ES6 模块本身，因为它不是对象。&lt;/p>
&lt;blockquote>
&lt;p>只支持相对路径或者绝对路径下的 ES 模块 (./, ../, /, http://, https://) ， 同时也受服务器跨域请求策略、 HTTPS 策略的约束。&lt;/p>
&lt;/blockquote>
&lt;p>由于 ES6 模块是编译时加载，使得静态分析成为可能。有了它，就能进一步拓宽 JavaScript 的语法，比如引入宏（macro）和类型检验（type system）这些只能靠静态分析实现的功能。&lt;/p>
&lt;p>除了静态加载带来的各种好处，ES6 模块还有以下好处。&lt;/p>
&lt;ul>
&lt;li>不再需要 UMD 模块格式了，将来服务器和浏览器都会支持 ES6 模块格式。目前，通过各种工具库，其实已经做到了这一点。&lt;/li>
&lt;li>将来浏览器的新 API 就能用模块格式提供，不再必须做成全局变量或者 navigator 对象的属性。&lt;/li>
&lt;li>不再需要对象作为命名空间（比如 Math 对象），未来这些功能可以通过模块提供。&lt;/li>
&lt;/ul>
&lt;h2 id="import-maps">Import maps&lt;/h2>
&lt;p>&lt;a href="https://beginor.github.io/2021/08/16/using-es-modules-in-borwser-with-importmaps.html">https://beginor.github.io/2021/08/16/using-es-modules-in-borwser-with-importmaps.html&lt;/a>&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-html" data-lang="html">&lt;span style="display:flex;">&lt;span>&amp;lt;&lt;span style="color:#f92672">script&lt;/span> &lt;span style="color:#a6e22e">type&lt;/span>&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;importmap&amp;#34;&lt;/span>&amp;gt;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#34;imports&amp;#34;&lt;/span>&lt;span style="color:#f92672">:&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#34;vue&amp;#34;&lt;/span>&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#e6db74">&amp;#34;https://unpkg.com/vue@3/dist/vue.esm-browser.js&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&amp;lt;/&lt;span style="color:#f92672">script&lt;/span>&amp;gt;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&amp;lt;&lt;span style="color:#f92672">script&lt;/span> &lt;span style="color:#a6e22e">type&lt;/span>&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;module&amp;#34;&lt;/span>&amp;gt;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">import&lt;/span> { &lt;span style="color:#a6e22e">createApp&lt;/span> } &lt;span style="color:#a6e22e">from&lt;/span> &lt;span style="color:#e6db74">&amp;#34;vue&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&amp;lt;/&lt;span style="color:#f92672">script&lt;/span>&amp;gt;
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h1 id="模块的加载方式">模块的加载方式&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://stackoverflow.com/questions/47403478/es6-modules-in-local-files-the-server-responded-with-a-non-javascript-mime-typ">https://stackoverflow.com/questions/47403478/es6-modules-in-local-files-the-server-responded-with-a-non-javascript-mime-typ&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://localcoder.org/es6-modules-in-local-files-the-server-responded-with-a-non-javascript-mime-typ">https://localcoder.org/es6-modules-in-local-files-the-server-responded-with-a-non-javascript-mime-typ&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://axellarsson.com/blog/expected-javascript-module-script-server-response-mimetype-text-html/">https://axellarsson.com/blog/expected-javascript-module-script-server-response-mimetype-text-html/&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>在 Node.js 环境和 Browser 环境中加载 ESM 的方式不太一样&lt;/p>
&lt;ul>
&lt;li>&lt;strong>Node.js&lt;/strong> # 可以使用模块名称。从根目录下的 node_modules/ 中查找模块&lt;/li>
&lt;li>&lt;strong>Browser&lt;/strong> # 不可以使用模块名称。必须通过编译工具将模块编译成单一文件，并修改 import 指向单一文件，以便可以发起请求获取这个静态资源&lt;/li>
&lt;/ul>
&lt;h2 id="浏览器中使用-esm-的常见问题">浏览器中使用 ESM 的常见问题&lt;/h2>
&lt;p>使用 &lt;code>import * as Vue from 'vue'&lt;/code> 将会产生如下报错：
&lt;code>Failed to resolve module specifier &amp;quot;vue&amp;quot;. Relative references must start with either &amp;quot;/&amp;quot;, &amp;quot;./&amp;quot;, or &amp;quot;../&amp;quot;.&lt;/code>
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/mm0ymr/1651724399014-d2052b6f-cd7c-4ec0-b6fc-b748bd5a11ed.png" alt="image.png">
接着修改为 &lt;code>import * as Vue from '../node_modules/vue'&lt;/code> 将会产生如下报错：
&lt;code>Failed to load module script: The server responded with a non-JavaScript MIME type of &amp;quot;text/html&amp;quot;. Strict MIME type checking is enforced for module scripts per HTML spec.&lt;/code>&lt;/p>
&lt;blockquote>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/mm0ymr/1651724430503-b62b86bd-4cc7-48b8-ac73-69fa62564ed5.png" alt="image.png" title="firefox">&lt;/p>
&lt;/blockquote>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/mm0ymr/1651724407422-526db251-775f-40d5-a25e-402791aa38cc.png" alt="image.png" title="chrome">
问题原因：
这个情况的原因是浏览器在处理 import 逻辑时导致的。浏览器在发现 import 语句时，将会请求 from 后面的静态文件，当 from 指定的是模块名称而不是模块文件的路径时时，浏览器无法发起请求，因为浏览器不知道如何获取到模块文件。&lt;/p>
&lt;p>解决方式：&lt;/p>
&lt;ul>
&lt;li>使用配置文件告诉 JavaScript 引擎如何从名为 XX 的模块中获取模块文件&lt;/li>
&lt;li>编译代码，js 代码被编译后，导入的模块的一组文件将会被打包、压缩为一个文件；并且 from 后面的模块名将被修改为模块文件的路径，即可在浏览器中运行&lt;/li>
&lt;/ul>
&lt;p>这几种解决方式通常都是通过编译工具实现的，比如 Webpack、Vite 等工具。&lt;/p></description></item><item><title>Docs: FFmpeg</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/11_%E5%A4%9A%E5%AA%92%E4%BD%93/%E5%A4%9A%E5%AA%92%E4%BD%93%E5%A4%84%E7%90%86%E5%B7%A5%E5%85%B7/ffmpeg/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/11_%E5%A4%9A%E5%AA%92%E4%BD%93/%E5%A4%9A%E5%AA%92%E4%BD%93%E5%A4%84%E7%90%86%E5%B7%A5%E5%85%B7/ffmpeg/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://github.com/FFmpeg/FFmpeg">GitHub 项目，FFmpge/FFmpge&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://ffmpeg.org/">官网&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>FFmpeg 是一个库和工具的集合，用于处理多媒体内容，比如 音频、视频、字幕、相关元数据 等。&lt;/p>
&lt;h1 id="ffmpeg-视频处理入门教程">FFmpeg 视频处理入门教程&lt;/h1>
&lt;p>作者： &lt;a href="https://www.ruanyifeng.com/">阮一峰&lt;/a>
日期： &lt;a href="https://www.ruanyifeng.com/blog/2020/01/">2020 年 1 月 14 日&lt;/a>
&lt;a href="https://www.ffmpeg.org/">FFmpeg&lt;/a> 是视频处理最常用的开源软件。
它功能强大，用途广泛，大量用于视频网站和商业软件（比如 Youtube 和 iTunes），也是许多音频和视频格式的标准编码/解码实现。&lt;/p>
&lt;p>FFmpeg 本身是一个庞大的项目，包含许多组件和库文件，最常用的是它的命令行工具。本文介绍 FFmpeg 命令行如何处理视频，比桌面视频处理软件更简洁高效。
如果你还没安装，可以根据&lt;a href="https://www.ffmpeg.org/download.html">官方文档&lt;/a> 先完成安装。&lt;/p>
&lt;h2 id="一概念">一、概念&lt;/h2>
&lt;p>介绍 FFmpeg 用法之前，需要了解一些视频处理的基本概念。&lt;/p>
&lt;h3 id="11-容器">1.1 容器&lt;/h3>
&lt;p>视频文件本身其实是一个容器（container），里面包括了视频和音频，也可能有字幕等其他内容。
常见的容器格式有以下几种。一般来说，视频文件的后缀名反映了它的容器格式。&lt;/p>
&lt;ul>
&lt;li>MP4&lt;/li>
&lt;li>MKV&lt;/li>
&lt;li>WebM&lt;/li>
&lt;li>AVI&lt;/li>
&lt;/ul>
&lt;p>下面的命令查看 FFmpeg 支持的容器。
$ ffmpeg -formats&lt;/p>
&lt;h3 id="12-编码格式">1.2 编码格式&lt;/h3>
&lt;p>视频和音频都需要经过编码，才能保存成文件。不同的编码格式（CODEC），有不同的压缩率，会导致文件大小和清晰度的差异。
常用的视频编码格式如下。&lt;/p>
&lt;ul>
&lt;li>H.262&lt;/li>
&lt;li>H.264&lt;/li>
&lt;li>H.265&lt;/li>
&lt;/ul>
&lt;p>上面的编码格式都是有版权的，但是可以免费使用。此外，还有几种无版权的视频编码格式。&lt;/p>
&lt;ul>
&lt;li>VP8&lt;/li>
&lt;li>VP9&lt;/li>
&lt;li>AV1&lt;/li>
&lt;/ul>
&lt;p>常用的音频编码格式如下。&lt;/p>
&lt;ul>
&lt;li>MP3&lt;/li>
&lt;li>AAC&lt;/li>
&lt;/ul>
&lt;p>上面所有这些都是有损的编码格式，编码后会损失一些细节，以换取压缩后较小的文件体积。无损的编码格式压缩出来的文件体积较大，这里就不介绍了。
下面的命令可以查看 FFmpeg 支持的编码格式，视频编码和音频编码都在内。
$ ffmpeg -codecs&lt;/p>
&lt;h3 id="13-编码器">1.3 编码器&lt;/h3>
&lt;p>编码器（encoders）是实现某种编码格式的库文件。只有安装了某种格式的编码器，才能实现该格式视频/音频的编码和解码。
以下是一些 FFmpeg 内置的视频编码器。&lt;/p>
&lt;ul>
&lt;li>libx264：最流行的开源 H.264 编码器&lt;/li>
&lt;li>NVENC：基于 NVIDIA GPU 的 H.264 编码器&lt;/li>
&lt;li>libx265：开源的 HEVC 编码器&lt;/li>
&lt;li>libvpx：谷歌的 VP8 和 VP9 编码器&lt;/li>
&lt;li>libaom：AV1 编码器&lt;/li>
&lt;/ul>
&lt;p>音频编码器如下。&lt;/p>
&lt;ul>
&lt;li>libfdk-aac&lt;/li>
&lt;li>aac&lt;/li>
&lt;/ul>
&lt;p>下面的命令可以查看 FFmpeg 已安装的编码器。
$ ffmpeg -encoders&lt;/p>
&lt;h2 id="二ffmpeg-的使用格式">二、FFmpeg 的使用格式&lt;/h2>
&lt;p>FFmpeg 的命令行参数非常多，可以分成五个部分。
$ ffmpeg {1} {2} -i {3} {4} {5}
上面命令中，五个部分的参数依次如下。&lt;/p>
&lt;ol>
&lt;li>全局参数&lt;/li>
&lt;li>输入文件参数&lt;/li>
&lt;li>输入文件&lt;/li>
&lt;li>输出文件参数&lt;/li>
&lt;li>输出文件&lt;/li>
&lt;/ol>
&lt;p>参数太多的时候，为了便于查看，ffmpeg 命令可以写成多行。
$ ffmpeg \ [全局参数] \ [输入文件参数] \ -i [输入文件] \ [输出文件参数] \ [输出文件]
下面是一个例子。
$ ffmpeg \ -y \ # 全局参数 -c:a libfdk_aac -c:v libx264 \ # 输入文件参数 -i input.mp4 \ # 输入文件 -c:v libvpx-vp9 -c:a libvorbis \ # 输出文件参数 output.webm # 输出文件
上面的命令将 mp4 文件转成 webm 文件，这两个都是容器格式。输入的 mp4 文件的音频编码格式是 aac，视频编码格式是 H.264；输出的 webm 文件的视频编码格式是 VP9，音频格式是 Vorbis。
如果不指明编码格式，FFmpeg 会自己判断输入文件的编码。因此，上面的命令可以简单写成下面的样子。
$ ffmpeg -i input.avi output.mp4&lt;/p>
&lt;h2 id="三常用命令行参数">三、常用命令行参数&lt;/h2>
&lt;p>FFmpeg 常用的命令行参数如下。&lt;/p>
&lt;ul>
&lt;li>-c：指定编码器&lt;/li>
&lt;li>-c copy：直接复制，不经过重新编码（这样比较快）&lt;/li>
&lt;li>-c:v：指定视频编码器&lt;/li>
&lt;li>-c:a：指定音频编码器&lt;/li>
&lt;li>-i：指定输入文件&lt;/li>
&lt;li>-an：去除音频流&lt;/li>
&lt;li>-vn： 去除视频流&lt;/li>
&lt;li>-preset：指定输出的视频质量，会影响文件的生成速度，有以下几个可用的值 ultrafast, superfast, veryfast, faster, fast, medium, slow, slower, veryslow。&lt;/li>
&lt;li>-y：不经过确认，输出时直接覆盖同名文件。&lt;/li>
&lt;/ul>
&lt;h2 id="四常见用法">四、常见用法&lt;/h2>
&lt;p>下面介绍 FFmpeg 几种常见用法。&lt;/p>
&lt;h3 id="41-查看文件信息">4.1 查看文件信息&lt;/h3>
&lt;p>查看视频文件的元信息，比如编码格式和比特率，可以只使用-i 参数。
$ ffmpeg -i input.mp4
上面命令会输出很多冗余信息，加上-hide_banner 参数，可以只显示元信息。
$ ffmpeg -i input.mp4 -hide_banner&lt;/p>
&lt;h3 id="42-转换编码格式">4.2 转换编码格式&lt;/h3>
&lt;p>转换编码格式（transcoding）指的是， 将视频文件从一种编码转成另一种编码。比如转成 H.264 编码，一般使用编码器 libx264，所以只需指定输出文件的视频编码器即可。
$ ffmpeg -i [input.file] -c:v libx264 output.mp4
下面是转成 H.265 编码的写法。
$ ffmpeg -i [input.file] -c:v libx265 output.mp4&lt;/p>
&lt;h3 id="43-转换容器格式">4.3 转换容器格式&lt;/h3>
&lt;p>转换容器格式（transmuxing）指的是，将视频文件从一种容器转到另一种容器。下面是 mp4 转 webm 的写法。
$ ffmpeg -i input.mp4 -c copy output.webm
上面例子中，只是转一下容器，内部的编码格式不变，所以使用-c copy 指定直接拷贝，不经过转码，这样比较快。&lt;/p>
&lt;h3 id="44-调整码率">4.4 调整码率&lt;/h3>
&lt;p>调整码率（transrating）指的是，改变编码的比特率，一般用来将视频文件的体积变小。下面的例子指定码率最小为 964K，最大为 3856K，缓冲区大小为 2000K。
$ ffmpeg \ -i input.mp4 \ -minrate 964K -maxrate 3856K -bufsize 2000K \ output.mp4&lt;/p>
&lt;h3 id="45-改变分辨率transsizing">4.5 改变分辨率（transsizing）&lt;/h3>
&lt;p>下面是改变视频分辨率（transsizing）的例子，从 1080p 转为 480p 。
$ ffmpeg \ -i input.mp4 \ -vf scale=480:-1 \ output.mp4&lt;/p>
&lt;h3 id="46-提取音频">4.6 提取音频&lt;/h3>
&lt;p>有时，需要从视频里面提取音频（demuxing），可以像下面这样写。
$ ffmpeg \ -i input.mp4 \ -vn -c:a copy \ output.aac
上面例子中，-vn 表示去掉视频，-c:a copy 表示不改变音频编码，直接拷贝。&lt;/p>
&lt;h3 id="47-添加音轨">4.7 添加音轨&lt;/h3>
&lt;p>添加音轨（muxing）指的是，将外部音频加入视频，比如添加背景音乐或旁白。
$ ffmpeg \ -i input.aac -i input.mp4 \ output.mp4
上面例子中，有音频和视频两个输入文件，FFmpeg 会将它们合成为一个文件。&lt;/p>
&lt;h3 id="48-截图">4.8 截图&lt;/h3>
&lt;p>下面的例子是从指定时间开始，连续对 1 秒钟的视频进行截图。
$ ffmpeg \ -y \ -i input.mp4 \ -ss 00:01:24 -t 00:00:01 \ output_%3d.jpg
如果只需要截一张图，可以指定只截取一帧。
$ ffmpeg \ -ss 01:23:45 \ -i input \ -vframes 1 -q:v 2 \ output.jpg
上面例子中，-vframes 1 指定只截取一帧，-q:v 2 表示输出的图片质量，一般是 1 到 5 之间（1 为质量最高）。&lt;/p>
&lt;h3 id="49-裁剪">4.9 裁剪&lt;/h3>
&lt;p>裁剪（cutting）指的是，截取原始视频里面的一个片段，输出为一个新视频。可以指定开始时间（start）和持续时间（duration），也可以指定结束时间（end）。
$ ffmpeg -ss [start] -i [input] -t [duration] -c copy [output] $ ffmpeg -ss [start] -i [input] -to [end] -c copy [output]
下面是实际的例子。
$ ffmpeg -ss 00:01:50 -i [input] -t 10.5 -c copy [output] $ ffmpeg -ss 2.5 -i [input] -to 10 -c copy [output]
上面例子中，-c copy 表示不改变音频和视频的编码格式，直接拷贝，这样会快很多。&lt;/p>
&lt;h3 id="410-为音频添加封面">4.10 为音频添加封面&lt;/h3>
&lt;p>有些视频网站只允许上传视频文件。如果要上传音频文件，必须为音频添加封面，将其转为视频，然后上传。
下面命令可以将音频文件，转为带封面的视频文件。
$ ffmpeg \ -loop 1 \ -i cover.jpg -i input.mp3 \ -c:v libx264 -c:a aac -b:a 192k -shortest \ output.mp4
上面命令中，有两个输入文件，一个是封面图片 cover.jpg，另一个是音频文件 input.mp3。-loop 1 参数表示图片无限循环，-shortest 参数表示音频文件结束，输出视频就结束。&lt;/p>
&lt;h2 id="五参考链接">五、参考链接&lt;/h2>
&lt;ul>
&lt;li>&lt;a href="https://github.com/leandromoreira/ffmpeg-libav-tutorial#chapter-3---transcoding">FFmpeg libav tutorial&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://github.com/leandromoreira/digital_video_introduction/blob/master/encoding_pratical_examples.md#split-and-merge-smoothly">Digital video introduction&lt;/a>&lt;/li>
&lt;li>&lt;a href="http://slhck.info/ffmpeg-encoding-course/">FFmpeg encoding and editing course&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://dragonquest64.blogspot.com/2019/10/making-slideshows-wffmpeg.html">Making Slideshows w/FFMpeg&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://itsfoss.com/ffmpeg/">The Complete Guide for Using ffmpeg in Linux&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://bernd.dev/2020/04/adding-subtitles/">Adding subtitles to your videos the easy way&lt;/a>&lt;/li>
&lt;/ul>
&lt;p>（完）&lt;/p></description></item><item><title>Docs: Go Module</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/2.%E7%BC%96%E7%A8%8B/%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/go/go-%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8/go-module/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/2.%E7%BC%96%E7%A8%8B/%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/go/go-%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8/go-module/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://go.dev/ref/mod">官方文档，参考-Go Modules 参考&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://mp.weixin.qq.com/s/6gJkSyGAFR0v6kow2uVklA">公众号，Go Modules 终极入门&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://blog.csdn.net/benben_2015/article/details/82227338">https://blog.csdn.net/benben_2015/article/details/82227338&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>&lt;strong>Go Moduel(Go 模块)&lt;/strong> 是实现 &lt;a href="https://en.wikipedia.org/wiki/Modular_programming">Modular Programming(模块化编程)&lt;/a> 的工具。是 Go 语言中正式官宣的项目依赖解决方案，Go modules（前身为 vgo）发布于 Go1.11，成长于 Go1.12，丰富于 Go1.13，正式于 Go1.14 已经准备好，并且可以用在生产上（ready for production）了，Go 官方也鼓励所有用户从其他依赖项管理工具迁移到 Go modules。&lt;/p>
&lt;p>module 是一个相关 Go 包的集合，它是源代码更替和版本控制的单元。模块由源文件形成的 go.mod 文件的根目录定义，包含 go.mod 文件的目录也被称为模块根。moudles 取代旧的的基于 GOPATH 方法来指定在工程中使用哪些源文件或导入包。模块路径是导入包的路径前缀，go.mod 文件定义模块路径，并且列出了在项目构建过程中使用的特定版本。&lt;/p>
&lt;p>使用 go module 时，GOPATH 不再用于解析导入。但是，它仍然用于存储下载的源代码（在$GOPATH/pkg/mod 中）和编译的命令（在 GOPATH / bin 中）。&lt;/p>
&lt;p>当程序编译时，会读取 go.mod 文件中的路径，来加载其编译所需的各种库&lt;/p>
&lt;p>Go moudles 目前集成在 Go 的工具链中，只要安装了 Go，自然而然也就可以使用 Go moudles 了，而 Go modules 的出现也解决了在 Go1.11 前的几个常见争议问题：&lt;/p>
&lt;ul>
&lt;li>Go 语言长久以来的依赖管理问题。&lt;/li>
&lt;li>“淘汰”现有的 &lt;a href="https://pkg.go.dev/cmd/go#hdr-GOPATH_environment_variable">GOPATH 的使用模式(即.解析导入能力)&lt;/a>。&lt;/li>
&lt;li>统一社区中的其它的依赖管理工具（提供迁移功能）。&lt;/li>
&lt;/ul>
&lt;h1 id="gopath">GOPATH&lt;/h1>
&lt;p>Go Module 出现后，GOPATH 路径变为纯粹的第三方依赖库的保存路径。目录结构通常如下：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>~&lt;span style="color:#f92672">]&lt;/span>&lt;span style="color:#75715e"># tree -L 3 $GOPATH&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>.
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>├── bin
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>│   ├── godef
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>│   ├── gomodifytags
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>│   ├── go-outline
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>│   ├── gopkgs
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>│   ├── goplay
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>│   ├── gopls
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>│   ├── gotests
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>│   └── staticcheck
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>└── pkg
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ├── mod
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> │   ├── 9fans.net
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> │   ├── cache
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> │   ├── fyne.io
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> │   ├── github.com
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> │   ├── gopkg.in
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> │   ├── gorm.io
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> │   └── mvdan.cc
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> └── sumdb
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> └── sum.golang.org
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>bin 下是安装的某些第三方依赖库后生成的二进制文件&lt;/p>
&lt;h2 id="早期-gopath-模式痛点">早期 GOPATH 模式痛点&lt;/h2>
&lt;p>我们先看看第一个问题，GOPATH 是什么，我们可以输入如下命令查看：&lt;/p>
&lt;pre>&lt;code>$ go env
GOPATH=&amp;quot;/root/go&amp;quot;
...
&lt;/code>&lt;/pre>
&lt;p>我们输入 go env 命令行后可以查看到 GOPATH 变量的结果，我们进入到该目录下进行查看，如下：&lt;/p>
&lt;pre>&lt;code>go
├── bin
├── pkg
└── src
├── github.com
├── golang.org
├── google.golang.org
├── gopkg.in
....
&lt;/code>&lt;/pre>
&lt;p>GOPATH 目录下一共包含了三个子目录，分别是：&lt;/p>
&lt;ul>
&lt;li>bin：存储所编译生成的二进制文件。&lt;/li>
&lt;li>pkg：存储预编译的目标文件，以加快程序的后续编译速度。&lt;/li>
&lt;li>src：存储所有项目的源代码。在编写 Go 应用程序，程序包和库时，一般会以$GOPATH/src/github.com/foo/bar 的路径进行存放。&lt;/li>
&lt;/ul>
&lt;p>因此在使用 GOPATH 模式下，我们需要将项目代码存放在固定的$GOPATH/src 目录下，并且如果执行 go get 来拉取外部依赖会自动下载并安装到 $GOPATH 目录下。&lt;/p>
&lt;p>为什么弃用 GOPATH 模式&lt;/p>
&lt;p>在 GOPATH 的 $GOPATH/src 下进行 .go 文件或源代码的存储，我们可以称其为 GOPATH 的模式，这个模式，看起来好像没有什么问题，那么为什么我们要弃用呢，参见如下原因：&lt;/p>
&lt;ul>
&lt;li>GOPATH 模式下没有版本控制的概念，具有致命的缺陷，至少会造成以下问题：
&lt;ul>
&lt;li>在执行 go get 的时候，你无法传达任何的版本信息的期望，也就是说你也无法知道自己当前更新的是哪一个版本，也无法通过指定来拉取自己所期望的具体版本。&lt;/li>
&lt;li>在运行 Go 应用程序的时候，你无法保证其它人与你所期望依赖的第三方库是相同的版本，也就是说在项目依赖库的管理上，你无法保证所有人的依赖版本都一致。&lt;/li>
&lt;li>你没办法处理 v1、v2、v3 等等不同版本的引用问题，因为 GOPATH 模式下的导入路径都是一样的，都是 github.com/foo/bar。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Go 语言官方从 Go1.11 起开始推进 Go modules（前身 vgo），Go1.13 起不再推荐使用 GOPATH 的使用模式，Go modules 也渐趋稳定，因此新项目也没有必要继续使用 GOPATH 模式。&lt;/li>
&lt;/ul>
&lt;p>在 GOPATH 模式下的产物&lt;/p>
&lt;p>Go1 在 2012 年 03 月 28 日发布，而 Go1.11 是在 2018 年 08 月 25 日才正式发布（数据来源：GitHub Tag），在这个空档的时间内，并没有 Go modules 这一个东西，最早期可能还好说，因为刚发布，用的人不多，所以没有明显暴露，但是后期 Go 语言使用的人越来越多了，那怎么办？&lt;/p>
&lt;p>这时候社区中逐渐的涌现出了大量的依赖解决方案，百花齐放，让人难以挑选，其中包括我们所熟知的 vendor 目录的模式，以及曾经一度被认为是“官宣”的 dep 的这类依赖管理工具。&lt;/p>
&lt;p>但为什么 dep 没有正在成为官宣呢，其实是因为随着 Russ Cox 与 Go 团队中的其他成员不断深入地讨论，发现 dep 的一些细节似乎越来越不适合 Go，因此官方采取了另起 proposal 的方式来推进，其方案的结果一开始先是释出 vgo（Go modules 的前身，知道即可，不需要深入了解），最终演变为我们现在所见到的 Go modules，也在 Go1.11 正式进入了 Go 的工具链。&lt;/p>
&lt;p>因此与其说是 “在 GOPATH 模式下的产物”，不如说是历史为当前提供了重要的教训，因此出现了 Go modules。&lt;/p>
&lt;h1 id="go-module-的使用和管理">Go Module 的使用和管理&lt;/h1>
&lt;p>可以这么说，一个自己新建的项目，就是一个模块，一个模块就是一个目录下的所有文件的集合。所以才说一个模块就是一个 Go Package 的合集。&lt;/p>
&lt;h2 id="go-module-相关环境变量">Go Module 相关环境变量&lt;/h2>
&lt;pre>&lt;code>$ go env
GO111MODULE=&amp;quot;auto&amp;quot; #使用module功能必须要让该变量变为on
GOPROXY=&amp;quot;https://proxy.golang.org,direct&amp;quot;
GONOPROXY=&amp;quot;&amp;quot;
GOSUMDB=&amp;quot;sum.golang.org&amp;quot;
GONOSUMDB=&amp;quot;&amp;quot;
GOPRIVATE=&amp;quot;&amp;quot;
...
&lt;/code>&lt;/pre>
&lt;h3 id="go111module">GO111MODULE&lt;/h3>
&lt;p>Go 语言提供了 GO111MODULE 这个环境变量来作为 Go modules 的开关，其允许设置以下参数：&lt;/p>
&lt;ul>
&lt;li>auto：只要项目包含了 go.mod 文件的话启用 Go modules，目前在 Go1.11 至 Go1.14 中仍然是默认值。&lt;/li>
&lt;li>on：启用 Go modules，推荐设置，将会是未来版本中的默认值。&lt;/li>
&lt;li>off：禁用 Go modules，不推荐设置。&lt;/li>
&lt;/ul>
&lt;p>GO111MODULE 的小历史&lt;/p>
&lt;p>你可能会留意到 GO111MODULE 这个名字比较 “奇特”，实际上在 Go 语言中经常会有这类阶段性的变量， GO111MODULE 这个命名代表着 Go 语言在 1.11 版本添加的，针对 Module 的变量。&lt;/p>
&lt;p>像是在 Go1.5 版本的时候，也发布了一个系统环境变量 GO15VENDOREXPERIMENT，作用是用于开启 vendor 目录的支持，当时其默认值也不是开启，仅仅作为 experimental。其随后在 Go1.6 版本时也将默认值改为了开启，并且最后作为了 official，GO15VENDOREXPERIMENT 系统变量就退出了历史舞台。&lt;/p>
&lt;p>而未来 GO111MODULE 这一个系统环境变量也会面临这个问题，也会先调整为默认值为 on（曾经在 Go1.13 想想改为 on，并且已经合并了 PR，但最后因为种种原因改回了 auto），然后再把 GO111MODULE 的支持给去掉，我们猜测应该会在 Go2 将 GO111MODULE 给去掉，因为如果直接去掉 GO111MODULE 的支持，会存在兼容性问题。&lt;/p>
&lt;h3 id="goproxy">GOPROXY&lt;/h3>
&lt;p>这个环境变量主要是用于设置 Go 模块代理（Go module proxy），其作用是用于使 Go 在后续拉取模块版本时能够脱离传统的 VCS 方式，直接通过镜像站点来快速拉取。&lt;/p>
&lt;p>GOPROXY 的默认值是：&lt;a href="https://proxy.golang.org,direct">https://proxy.golang.org,direct&lt;/a>，这有一个很严重的问题，就是 proxy.golang.org 在国内是无法访问的，因此这会直接卡住你的第一步，所以你必须在开启 Go modules 的时，同时设置国内的 Go 模块代理，执行如下命令：&lt;/p>
&lt;pre>&lt;code> $ go env -w GOPROXY=https://goproxy.cn,direct
&lt;/code>&lt;/pre>
&lt;p>GOPROXY 的值是一个以英文逗号 “,” 分割的 Go 模块代理列表，允许设置多个模块代理，假设你不想使用，也可以将其设置为 “off” ，这将会禁止 Go 在后续操作中使用任何 Go 模块代理。&lt;/p>
&lt;p>direct 是什么&lt;/p>
&lt;p>而在刚刚设置的值中，我们可以发现值列表中有 “direct” 标识，它又有什么作用呢？&lt;/p>
&lt;p>实际上 “direct” 是一个特殊指示符，用于指示 Go 回源到模块版本的源地址去抓取（比如 GitHub 等），场景如下：当值列表中上一个 Go 模块代理返回 404 或 410 错误时，Go 自动尝试列表中的下一个，遇见 “direct” 时回源，也就是回到源地址去抓取，而遇见 EOF 时终止并抛出类似 “invalid version: unknown revision&amp;hellip;” 的错误。&lt;/p>
&lt;h3 id="gosumdb">GOSUMDB&lt;/h3>
&lt;p>它的值是一个 Go checksum database，用于在拉取模块版本时（无论是从源站拉取还是通过 Go module proxy 拉取）保证拉取到的模块版本数据未经过篡改，若发现不一致，也就是可能存在篡改，将会立即中止。&lt;/p>
&lt;p>GOSUMDB 的默认值为：sum.golang.org，在国内也是无法访问的，但是 GOSUMDB 可以被 Go 模块代理所代理（详见：Proxying a Checksum Database）。&lt;/p>
&lt;p>因此我们可以通过设置 GOPROXY 来解决，而先前我们所设置的模块代理 goproxy.cn 就能支持代理 sum.golang.org，所以这一个问题在设置 GOPROXY 后，你可以不需要过度关心。&lt;/p>
&lt;p>另外若对 GOSUMDB 的值有自定义需求，其支持如下格式：&lt;/p>
&lt;ul>
&lt;li>格式 1：+。&lt;/li>
&lt;li>格式 2：+ 。&lt;/li>
&lt;/ul>
&lt;p>也可以将其设置为 “off”，也就是禁止 Go 在后续操作中校验模块版本。&lt;/p>
&lt;h3 id="gonoproxygonosumdbgoprivate">GONOPROXY/GONOSUMDB/GOPRIVATE&lt;/h3>
&lt;p>这三个环境变量都是用在当前项目依赖了私有模块，例如像是你公司的私有 git 仓库，又或是 github 中的私有库，都是属于私有模块，都是要进行设置的，否则会拉取失败。&lt;/p>
&lt;p>更细致来讲，就是依赖了由 GOPROXY 指定的 Go 模块代理或由 GOSUMDB 指定 Go checksum database 都无法访问到的模块时的场景。&lt;/p>
&lt;p>而一般建议直接设置 GOPRIVATE，它的值将作为 GONOPROXY 和 GONOSUMDB 的默认值，所以建议的最佳姿势是直接使用 GOPRIVATE。&lt;/p>
&lt;p>并且它们的值都是一个以英文逗号 “,” 分割的模块路径前缀，也就是可以设置多个，例如：&lt;/p>
&lt;pre>&lt;code> $ go env -w GOPRIVATE=&amp;quot;git.example.com,github.com/eddycjy/mquote&amp;quot;
&lt;/code>&lt;/pre>
&lt;p>设置后，前缀为 git.xxx.com 和 github.com/eddycjy/mquote 的模块都会被认为是私有模块。&lt;/p>
&lt;p>如果不想每次都重新设置，我们也可以利用通配符，例如：&lt;/p>
&lt;pre>&lt;code> $ go env -w GOPRIVATE=&amp;quot;*.example.com&amp;quot;
&lt;/code>&lt;/pre>
&lt;p>这样子设置的话，所有模块路径为 example.com 的子域名（例如：git.example.com）都将不经过 Go module proxy 和 Go checksum database，需要注意的是不包括 example.com 本身。&lt;/p>
&lt;p>具体使用步骤：&lt;/p>
&lt;ul>
&lt;li>通过 go 命令行，进入到你当前的工程目录下，在命令行设置临时环境变量 set GO111MODULE=on；&lt;/li>
&lt;li>执行命令 go mod init NAME 在当前目录下生成一个 go.mod 文件，执行这条命令时，当前目录不能存在 go.mod 文件。如果之前生成过，要先删除；&lt;/li>
&lt;li>如果你工程中存在一些不能确定版本的包，那么生成的 go.mod 文件可能就不完整，因此继续执行下面的命令；&lt;/li>
&lt;li>执行 go mod tidy 命令，它会添加缺失的模块以及移除不需要的模块。执行后会生成 go.sum 文件(模块下载条目)。添加参数-v，例如 go mod tidy -v 可以将执行的信息，即删除和添加的包打印到命令行；&lt;/li>
&lt;li>执行命令 go mod verify 来检查当前模块的依赖是否全部下载下来，是否下载下来被修改过。如果所有的模块都没有被修改过，那么执行这条命令之后，会打印 all modules verified。&lt;/li>
&lt;li>执行命令 go mod vendor 生成 vendor 文件夹，该文件夹下将会放置你 go.mod 文件描述的依赖包，文件夹下同时还有一个文件 modules.txt，它是你整个工程的所有模块。在执行这条命令之前，如果你工程之前有 vendor 目录，应该先进行删除。同理 go mod vendor -v 会将添加到 vendor 中的模块打印出来；&lt;/li>
&lt;/ul>
&lt;h2 id="gomod-文件">go.mod 文件&lt;/h2>
&lt;p>go.mod 文件定义 module 路径以及列出其他需要在 build 时引入的模块的特定的版本。例如下面的例子中，go.mod 声明 example.com/m 路径是 module 的根目录，同时也声明了 module 依赖特定版本的 golang.org/x/text 和 gopkg.in/yaml.v2。&lt;/p>
&lt;p>go.mod 文件中有如下几个关键字：&lt;/p>
&lt;ul>
&lt;li>&lt;strong>module&lt;/strong> # 定义 module 路径，该路径不用与当前路径相同，只是 module 所用的一个名称，可以代指当前目录。(比如/root/lichenhao/cobra/目录下，创建一个 go.mod 文件，可以定义 module 路径为 cobratest，这个 cobratest 模块路径名，就表示/root/lichenhao/cobra/这个目录)to define the module path;&lt;/li>
&lt;li>&lt;strong>go&lt;/strong> # to set the expected language version;&lt;/li>
&lt;li>&lt;strong>require&lt;/strong> # to require a particular module at a given version or later;&lt;/li>
&lt;li>&lt;strong>exclude&lt;/strong> # to exclude a particular module version from use; and&lt;/li>
&lt;li>&lt;strong>replace&lt;/strong> # to replace a module version with a different module version.&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">module&lt;/span> &lt;span style="color:#a6e22e">github&lt;/span>.&lt;span style="color:#a6e22e">com&lt;/span>&lt;span style="color:#f92672">/&lt;/span>&lt;span style="color:#a6e22e">eddycjy&lt;/span>&lt;span style="color:#f92672">/&lt;/span>&lt;span style="color:#a6e22e">module&lt;/span>&lt;span style="color:#f92672">-&lt;/span>&lt;span style="color:#a6e22e">repo&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">go&lt;/span> &lt;span style="color:#ae81ff">1.13&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">require&lt;/span> (
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">github&lt;/span>.&lt;span style="color:#a6e22e">com&lt;/span>&lt;span style="color:#f92672">/&lt;/span>&lt;span style="color:#a6e22e">eddycjy&lt;/span>&lt;span style="color:#f92672">/&lt;/span>&lt;span style="color:#a6e22e">mquote&lt;/span> &lt;span style="color:#a6e22e">v0&lt;/span>&lt;span style="color:#ae81ff">.0.0&lt;/span>&lt;span style="color:#f92672">-&lt;/span>&lt;span style="color:#ae81ff">20200220041913&lt;/span>&lt;span style="color:#f92672">-&lt;/span>&lt;span style="color:#a6e22e">e066a990ce6f&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>go.mod 文件还可以指定要替换和排除的版本，命令行会自动根据 go.mod 文件来维护需求声明中的版本。如果想获取更多的有关 go.mod 文件的介绍，可以使用命令 go help go.mod。&lt;/p>
&lt;p>go.mod 文件用 // 注释，而不用 /**/。文件的每行都有一条指令，由一个动作加上参数组成。例如：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">module&lt;/span> &lt;span style="color:#a6e22e">my&lt;/span>&lt;span style="color:#f92672">/&lt;/span>&lt;span style="color:#a6e22e">thing&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">require&lt;/span> &lt;span style="color:#a6e22e">other&lt;/span>&lt;span style="color:#f92672">/&lt;/span>&lt;span style="color:#a6e22e">thing&lt;/span> &lt;span style="color:#a6e22e">v1&lt;/span>&lt;span style="color:#ae81ff">.0.2&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">require&lt;/span> &lt;span style="color:#a6e22e">new&lt;/span>&lt;span style="color:#f92672">/&lt;/span>&lt;span style="color:#a6e22e">thing&lt;/span> &lt;span style="color:#a6e22e">v2&lt;/span>&lt;span style="color:#ae81ff">.3.4&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">exclude&lt;/span> &lt;span style="color:#a6e22e">old&lt;/span>&lt;span style="color:#f92672">/&lt;/span>&lt;span style="color:#a6e22e">thing&lt;/span> &lt;span style="color:#a6e22e">v1&lt;/span>&lt;span style="color:#ae81ff">.2.3&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">replace&lt;/span> &lt;span style="color:#a6e22e">bad&lt;/span>&lt;span style="color:#f92672">/&lt;/span>&lt;span style="color:#a6e22e">thing&lt;/span> &lt;span style="color:#a6e22e">v1&lt;/span>&lt;span style="color:#ae81ff">.4.5&lt;/span> =&amp;gt; &lt;span style="color:#a6e22e">good&lt;/span>&lt;span style="color:#f92672">/&lt;/span>&lt;span style="color:#a6e22e">thing&lt;/span> &lt;span style="color:#a6e22e">v1&lt;/span>&lt;span style="color:#ae81ff">.4.5&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>上面三个动词 require、exclude、replace 分别表示：项目需要的依赖包及版本、排除某些包的特别版本、取代当前项目中的某些依赖包。&lt;/p>
&lt;p>相同动作的命令可以放到一个动词+括号组成的结构中，例如：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">require&lt;/span> (
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">new&lt;/span>&lt;span style="color:#f92672">/&lt;/span>&lt;span style="color:#a6e22e">thing&lt;/span> &lt;span style="color:#a6e22e">v2&lt;/span>&lt;span style="color:#ae81ff">.3.4&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">old&lt;/span>&lt;span style="color:#f92672">/&lt;/span>&lt;span style="color:#a6e22e">thing&lt;/span> &lt;span style="color:#a6e22e">v1&lt;/span>&lt;span style="color:#ae81ff">.2.3&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="其他命令的支持">其他命令的支持&lt;/h3>
&lt;p>旧的版本，构建编译命令 &lt;code>go build&lt;/code> 中的参数没有 &lt;code>-mod&lt;/code> 参数，最新的版本现在多了这个，用来对 &lt;code>go.mod&lt;/code> 文件进行更新或其他使用控制。形式如：&lt;code>go build -mod [mode]&lt;/code>，其中 mode 有以下几种取值：readonly，release，vendor。当执行 &lt;code>go build -mod=vendor&lt;/code> 的时候，会在生成可执行文件的同时将项目的依赖包放到主模块的 &lt;code>vendor&lt;/code> 目录下。&lt;/p>
&lt;p>&lt;code>go get -m [packages]&lt;/code> 会将下载的依赖包放到 &lt;code>GOPATH/pkg/mod&lt;/code> 目录下，并且将依赖写入到 &lt;code>go.mod&lt;/code> 文件。&lt;code>go get -u=patch&lt;/code> 会更新主模块下的所有依赖包。&lt;/p>
&lt;p>如果遇到不熟悉的导入包，任何可以查找包含该引入包模块的 &lt;code>go&lt;/code> 命令，都会自动将该模块的最新版本添加到 &lt;code>go.mod&lt;/code> 文件中。同时也会添加缺失的模块，以及删除无用的 module。例如：go build, go test 或者 go list 命令。另外，有一个专门的命令 &lt;code>go mod tidy&lt;/code>，用来查看和添加缺失的 module 需求声明以及移除不必要的。&lt;/p>
&lt;p>&lt;code>go.mod&lt;/code> 文件是可读，也是可编辑的。&lt;code>go&lt;/code> 命令行会自动更新 &lt;code>go.mod&lt;/code> 文件来维持一个标准格式以及精确的引入声明。&lt;/p>
&lt;h2 id="gosum-文件">go.sum 文件&lt;/h2>
&lt;p>在第一次拉取模块依赖后，会发现多出了一个 go.sum 文件，其详细罗列了当前项目直接或间接依赖的所有模块版本，并写明了那些模块版本的 SHA-256 哈希值以备 Go 在今后的操作中保证项目所依赖的那些模块版本不会被篡改。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">github&lt;/span>.&lt;span style="color:#a6e22e">com&lt;/span>&lt;span style="color:#f92672">/&lt;/span>&lt;span style="color:#a6e22e">eddycjy&lt;/span>&lt;span style="color:#f92672">/&lt;/span>&lt;span style="color:#a6e22e">mquote&lt;/span> &lt;span style="color:#a6e22e">v0&lt;/span>&lt;span style="color:#ae81ff">.0.1&lt;/span> &lt;span style="color:#a6e22e">h1&lt;/span>:&lt;span style="color:#ae81ff">4&lt;/span>&lt;span style="color:#a6e22e">QHXKo7J8a6J&lt;/span>&lt;span style="color:#f92672">/&lt;/span>&lt;span style="color:#a6e22e">k8UA6CiHhswJQs0sm2foAQQUq8GFHM&lt;/span>=
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">github&lt;/span>.&lt;span style="color:#a6e22e">com&lt;/span>&lt;span style="color:#f92672">/&lt;/span>&lt;span style="color:#a6e22e">eddycjy&lt;/span>&lt;span style="color:#f92672">/&lt;/span>&lt;span style="color:#a6e22e">mquote&lt;/span> &lt;span style="color:#a6e22e">v0&lt;/span>&lt;span style="color:#ae81ff">.0.1&lt;/span>&lt;span style="color:#f92672">/&lt;/span>&lt;span style="color:#66d9ef">go&lt;/span>.&lt;span style="color:#a6e22e">mod&lt;/span> &lt;span style="color:#a6e22e">h1&lt;/span>:&lt;span style="color:#a6e22e">ZtlkDs7Mriynl7wsDQ4cU23okEtVYqHwl7F1eDh4qPg&lt;/span>=
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">github&lt;/span>.&lt;span style="color:#a6e22e">com&lt;/span>&lt;span style="color:#f92672">/&lt;/span>&lt;span style="color:#a6e22e">eddycjy&lt;/span>&lt;span style="color:#f92672">/&lt;/span>&lt;span style="color:#a6e22e">mquote&lt;/span>&lt;span style="color:#f92672">/&lt;/span>&lt;span style="color:#a6e22e">module&lt;/span>&lt;span style="color:#f92672">/&lt;/span>&lt;span style="color:#a6e22e">tour&lt;/span> &lt;span style="color:#a6e22e">v0&lt;/span>&lt;span style="color:#ae81ff">.0.1&lt;/span> &lt;span style="color:#a6e22e">h1&lt;/span>:&lt;span style="color:#a6e22e">cc&lt;/span>&lt;span style="color:#f92672">+&lt;/span>&lt;span style="color:#a6e22e">pgV0LnR8Fhou0zNHughT7IbSnLvfUZ&lt;/span>&lt;span style="color:#f92672">+&lt;/span>&lt;span style="color:#a6e22e">X3fvshrv8&lt;/span>=
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">github&lt;/span>.&lt;span style="color:#a6e22e">com&lt;/span>&lt;span style="color:#f92672">/&lt;/span>&lt;span style="color:#a6e22e">eddycjy&lt;/span>&lt;span style="color:#f92672">/&lt;/span>&lt;span style="color:#a6e22e">mquote&lt;/span>&lt;span style="color:#f92672">/&lt;/span>&lt;span style="color:#a6e22e">module&lt;/span>&lt;span style="color:#f92672">/&lt;/span>&lt;span style="color:#a6e22e">tour&lt;/span> &lt;span style="color:#a6e22e">v0&lt;/span>&lt;span style="color:#ae81ff">.0.1&lt;/span>&lt;span style="color:#f92672">/&lt;/span>&lt;span style="color:#66d9ef">go&lt;/span>.&lt;span style="color:#a6e22e">mod&lt;/span> &lt;span style="color:#a6e22e">h1&lt;/span>:&lt;span style="color:#ae81ff">8&lt;/span>&lt;span style="color:#a6e22e">uL1FOiQJZ4&lt;/span>&lt;span style="color:#f92672">/&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>&lt;span style="color:#a6e22e">hzqQ5mv4Sm7nJcwYu41F3nZmkiWx5I&lt;/span>=
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">...&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>我们可以看到一个模块路径可能有如下两种：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">github&lt;/span>.&lt;span style="color:#a6e22e">com&lt;/span>&lt;span style="color:#f92672">/&lt;/span>&lt;span style="color:#a6e22e">eddycjy&lt;/span>&lt;span style="color:#f92672">/&lt;/span>&lt;span style="color:#a6e22e">mquote&lt;/span> &lt;span style="color:#a6e22e">v0&lt;/span>&lt;span style="color:#ae81ff">.0.1&lt;/span> &lt;span style="color:#a6e22e">h1&lt;/span>:&lt;span style="color:#ae81ff">4&lt;/span>&lt;span style="color:#a6e22e">QHXKo7J8a6J&lt;/span>&lt;span style="color:#f92672">/&lt;/span>&lt;span style="color:#a6e22e">k8UA6CiHhswJQs0sm2foAQQUq8GFHM&lt;/span>=
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">github&lt;/span>.&lt;span style="color:#a6e22e">com&lt;/span>&lt;span style="color:#f92672">/&lt;/span>&lt;span style="color:#a6e22e">eddycjy&lt;/span>&lt;span style="color:#f92672">/&lt;/span>&lt;span style="color:#a6e22e">mquote&lt;/span> &lt;span style="color:#a6e22e">v0&lt;/span>&lt;span style="color:#ae81ff">.0.1&lt;/span>&lt;span style="color:#f92672">/&lt;/span>&lt;span style="color:#66d9ef">go&lt;/span>.&lt;span style="color:#a6e22e">mod&lt;/span> &lt;span style="color:#a6e22e">h1&lt;/span>:&lt;span style="color:#a6e22e">ZtlkDs7Mriynl7wsDQ4cU23okEtVYqHwl7F1eDh4qPg&lt;/span>=
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>h1 hash 是 Go modules 将目标模块版本的 zip 文件开包后，针对所有包内文件依次进行 hash，然后再把它们的 hash 结果按照固定格式和算法组成总的 hash 值。&lt;/p>
&lt;p>而 h1 hash 和 go.mod hash 两者，要不就是同时存在，要不就是只存在 go.mod hash。那什么情况下会不存在 h1 hash 呢，就是当 Go 认为肯定用不到某个模块版本的时候就会省略它的 h1 hash，就会出现不存在 h1 hash，只存在 go.mod hash 的情况。&lt;/p>
&lt;h1 id="go-mod-命令行工具">go mod 命令行工具&lt;/h1>
&lt;p>go mod 提供了一系列操作模块的命令，所有的 go 命令中现在已经内置了对 module 的支持，而不仅仅是 go mod 命令。例如使用 go get 时，会经常自动在后台添加、移除、升级、降级依赖包版本。&lt;/p>
&lt;h2 id="syntax语法">Syntax(语法)&lt;/h2>
&lt;p>&lt;strong>go mod [ARGUMENTS]&lt;/strong>&lt;/p>
&lt;p>COMMAND：&lt;/p>
&lt;ul>
&lt;li>&lt;strong>download&lt;/strong> # 下载模块到本地缓存，具体可以通过命令 go env 查看，其中环境变量 GOCACHE 就是缓存的地址，如果该文件夹的内容太大，可以通过命令 go clean -cache&lt;/li>
&lt;li>&lt;strong>edit&lt;/strong> # 从工具或脚本中编辑 go.mod 文件&lt;/li>
&lt;li>&lt;strong>graph&lt;/strong> # 打印模块需求图&lt;/li>
&lt;li>&lt;strong>init&lt;/strong> # 在当前目录下初始化新的模块&lt;/li>
&lt;li>&lt;strong>tidy&lt;/strong> # 添加缺失的模块以及移除无用的模块&lt;/li>
&lt;li>&lt;strong>vendor&lt;/strong> #导出项目所有的依赖到 vendor 目录&lt;/li>
&lt;li>**verify **#验证依赖项是否达到预期的目的&lt;/li>
&lt;li>&lt;strong>why&lt;/strong> #查看为什么需要包或模块&lt;/li>
&lt;/ul>
&lt;h2 id="go-mod-download">go mod download&lt;/h2>
&lt;p>&lt;strong>go mod download [-dir] [-json] [modules]&lt;/strong>&lt;/p>
&lt;p>使用此命令来下载指定的模块，模块的格式可以根据主模块依赖的形式或者 path@version 形式指定。如果没有指定参数，此命令会将主模块下的所有依赖下载下来。&lt;/p>
&lt;p>go mod download 命令非常有用，主要用来预填充本地缓存或者计算 Go 模块代理的回答。默认情况下，下载错误会输出到标准输出，正常情况下没有任何输出。-json 参数会以 JSON 的格式打印下载的模块对象，对应的 Go 对象结构是这样。&lt;/p>
&lt;p>type Module struct { Path string //module path Version string //module version Error string //error loading module Info string //absolute path to cached .info file GoMod string //absolute path to cached .mod file Zip string //absolute path to cached .zip file Dir string //absolute path to cached source root directory Sum string //checksum for path, version (as in go.sum) GoModSum string //checksum for go.mod (as in go.sum)}&lt;/p>
&lt;h2 id="go-mod-init">go mod init&lt;/h2>
&lt;p>&lt;strong>go mod init [ModuleName]&lt;/strong>
一般情况 ModuleName 是以后 import 时所使用的路径&lt;/p>
&lt;p>此命令会在当前目录中初始化和创建一个新的 go.mod 文件，当然你也可以手动创建一个 go.mod 文件，然后包含一些 module 声明，这样就比较麻烦。go mod init 命令可以帮助我们自动创建&lt;/p>
&lt;p>例如：&lt;code>go mod init example.com/m&lt;/code>&lt;/p>
&lt;p>使用这条命令时，go.mod 文件必须提前不能存在。初始化会根据引入包声明来推测模块的路径或者如果你工程中之前已经存在一些依赖包管理工具，例如 godep，glide 或者 dep。那么 go mod init 同样也会根据依赖包管理配置文件来推断。&lt;/p>
&lt;h2 id="go-mod-tidy">go mod tidy&lt;/h2>
&lt;p>&lt;strong>go mod tidy [-v]&lt;/strong>&lt;/p>
&lt;p>默认情况下，Go 不会移除 go.mod 文件中的无用依赖。所以当你的依赖中有些使用不到了，可以使用 go mod tidy 命令来清除它。&lt;/p>
&lt;p>它会添加缺失的模块以及移除不需要的模块。执行后会生成 go.sum 文件(模块下载条目)。添加参数-v，例如 go mod tidy -v 可以将执行的信息，即移除的模块打印到标准输出。&lt;/p>
&lt;h2 id="go-mod-vendor">go mod vendor&lt;/h2>
&lt;p>go mod vendor [-v]&lt;/p>
&lt;p>此命令会将 build 阶段需要的所有依赖包放到主模块所在的 vendor 目录中，并且测试所有主模块的包。同理 go mod vendor -v 会将添加到 vendor 中的模块打印到标准输出。&lt;/p>
&lt;h2 id="go-mod-verify">go mod verify&lt;/h2>
&lt;p>此命令会检查当前模块的依赖是否已经存储在本地下载的源代码缓存中，以及检查自从下载下来是否有修改。如果所有的模块都没有修改，那么会打印 all modules verified，否则会打印变化的内容。&lt;/p>
&lt;p>虚拟版本号&lt;/p>
&lt;p>go.mod 文件和 go 命令通常使用语义版本作为描述模块版本的标准形式，这样可以比较不同版本的先后顺序。例如模块的版本是 v1.2.3，那么通过重新对版本号进行标签处理，得到该版本的虚拟版本。形式如：v0.0.0-yyyymmddhhmmss-abcdefabcdef。其中时间是提交时的 UTC 时间，最后的后缀是提交的哈希值前缀。时间部分确保两个虚拟版本号可以进行比较，以确定两者顺序。&lt;/p>
&lt;p>下面有三种形式的虚拟版本号：&lt;/p>
&lt;ul>
&lt;li>vX.0.0-yyyymmddhhmmss-abcdefabcdef，这种情况适合用在在目标版本提交之前 ，没有更早的的版本。（这种形式本来是唯一的形式，所以一些老的 go.mod 文件使用这种形式）&lt;/li>
&lt;li>vX.Y.Z-pre.0.yyyymmddhhmmss-abcdefabcdef，这种情况被用在当目标版本提交之前的最新版本提交是 vX.Y.Z-pre。&lt;/li>
&lt;li>vX.Y.(Z+1)-0.yyyymmddhhmmss-abcdefabcdef，同理，这种情况是当目标版本提交之前的最新版本是 vX.Y.Z。&lt;/li>
&lt;/ul>
&lt;p>虚拟版本的生成不需要你去手动操作，go 命令会将接收的 commit 哈希值自动转化为虚拟版本号。&lt;/p></description></item><item><title>Docs: OpenStack 部署与清理</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/10.%E4%BA%91%E5%8E%9F%E7%94%9F/1.3.openstack-%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%BC%96%E6%8E%92%E7%B3%BB%E7%BB%9F/openstack%E9%83%A8%E7%BD%B2%E4%B8%8E%E6%B8%85%E7%90%86/openstack-%E9%83%A8%E7%BD%B2%E4%B8%8E%E6%B8%85%E7%90%86/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/10.%E4%BA%91%E5%8E%9F%E7%94%9F/1.3.openstack-%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%BC%96%E6%8E%92%E7%B3%BB%E7%BB%9F/openstack%E9%83%A8%E7%BD%B2%E4%B8%8E%E6%B8%85%E7%90%86/openstack-%E9%83%A8%E7%BD%B2%E4%B8%8E%E6%B8%85%E7%90%86/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;/blockquote>
&lt;p>&lt;a href="https://thoughts.teambition.com/workspaces/603b04c9f83f2a00428f7321/folders/5fa948644cc5830001751d72">https://thoughts.teambition.com/workspaces/603b04c9f83f2a00428f7321/folders/5fa948644cc5830001751d72&lt;/a>&lt;/p>
&lt;p>部署 OpenStack 有多种方式&lt;/p>
&lt;ul>
&lt;li>手动部署 OpenStack 中的每一个组件
&lt;ul>
&lt;li>&lt;a href="https://docs.openstack.org/xena/install/">https://docs.openstack.org/xena/install/&lt;/a>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>使用自动化部署工具，部署工具有多种类型可供选择
&lt;ul>
&lt;li>&lt;a href="https://docs.openstack.org/xena/deploy/">https://docs.openstack.org/xena/deploy/&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://docs.openstack.org/project-deploy-guide/charm-deployment-guide/latest/">OpenStack Charms&lt;/a> # 使用 MAAS 和 Juju 部署。
&lt;ul>
&lt;li>一种完善的部署方式，基于 Ubuntu 开发 MAAS。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;a href="https://docs.openstack.org/project-deploy-guide/kolla-ansible/latest/">OpenStack Kolla&lt;/a> # 在容器中使用 Ansible 部署
&lt;ul>
&lt;li>非常简单高效得部署一个用来 生产、开发、测试 的 OpenStack。支持 all-in-one 和 multinode 两种模式(即所有组件都在一个节点或分散在多个节点)&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>其他&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h2 id="支持的操作系统">支持的操作系统&lt;/h2>
&lt;p>Kolla Ansible 支持以下主机操作系统 (OS)：&lt;/p>
&lt;blockquote>
&lt;p>从 Ussuri 版本开始，OpenStack 不再支持 CentOS 7 作为主机操作系统。Train 版本同时支持 CentOS 7 和 8，并提供了迁移路径。有关迁移到 CentOS 8 的信息，请参阅 &lt;a href="https://docs.openstack.org/kolla-ansible/train/user/centos8.html">Kolla Ansible Train 文档&lt;/a>。
不再支持 CentOS Linux 8（相对于 CentOS Stream 8）作为主机操作系统。Victoria 版本将来会同时支持 CentOS Linux 8 和 CentOS Stream 8，并提供迁移途径。&lt;/p>
&lt;/blockquote>
&lt;ul>
&lt;li>CentOS Stream 8&lt;/li>
&lt;li>Debian Bullseye (11)&lt;/li>
&lt;li>RHEL 8（已弃用）&lt;/li>
&lt;li>Rocky Linux 8&lt;/li>
&lt;li>Ubuntu Focal (20.04)&lt;/li>
&lt;/ul>
&lt;h2 id="支持的容器镜像">支持的容器镜像&lt;/h2>
&lt;p>为获得最佳结果，基本容器映像分发应与主机操作系统分发匹配。支持以下值 kolla_base_distro：&lt;/p>
&lt;ul>
&lt;li>centos&lt;/li>
&lt;li>debian&lt;/li>
&lt;li>rhel（已弃用）&lt;/li>
&lt;li>ubuntu&lt;/li>
&lt;/ul>
&lt;p>有关哪些发行版支持哪些图像的详细信息，请参阅 &lt;a href="https://docs.openstack.org/kolla/latest/support_matrix">Kolla 支持矩阵&lt;/a>。&lt;/p>
&lt;h1 id="kolla-ansible">Kolla-ansible&lt;/h1>
&lt;p>注意：&lt;/p>
&lt;ul>
&lt;li>宿主机至少需要两个可用的网卡，在 &lt;code>/etc/kolla/globals.yml&lt;/code> 文件中，被描述为如下两个关键字
&lt;ul>
&lt;li>&lt;strong>network_interface&lt;/strong> # 管理网络、API 网络的网卡&lt;/li>
&lt;li>&lt;strong>neutron_external_interface&lt;/strong> # Neutron 外部接口就是指内网环境。该网络设备将会桥接到 &lt;code>ovs-switch&lt;/code> 这个桥设备上。虚拟机是通过这块网卡访问外网。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h2 id="安装依赖并使用虚拟环境">安装依赖并使用虚拟环境&lt;/h2>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>sudo apt update
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>sudo apt install python3-dev libffi-dev gcc libssl-dev
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>创建一个虚拟环境以安装部署工具&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>export KOLLA_DIR&lt;span style="color:#f92672">=&lt;/span>/root/kolla
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>mkdir -p &lt;span style="color:#e6db74">${&lt;/span>KOLLA_DIR&lt;span style="color:#e6db74">}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>sudo apt install python3-venv
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>python3 -m venv &lt;span style="color:#e6db74">${&lt;/span>KOLLA_DIR&lt;span style="color:#e6db74">}&lt;/span>/venv
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>source &lt;span style="color:#e6db74">${&lt;/span>KOLLA_DIR&lt;span style="color:#e6db74">}&lt;/span>/venv/bin/activate
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>pip install -U pip -i https://pypi.tuna.tsinghua.edu.cn/simple
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>pip install &lt;span style="color:#e6db74">&amp;#39;ansible&amp;lt;5.0&amp;#39;&lt;/span> -i https://pypi.tuna.tsinghua.edu.cn/simple
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="安装-kolla-ansible">安装 Kolla-ansible&lt;/h2>
&lt;p>这里说的 Kolla-ansible 主要指的是用于部署 Openstack 的 Ansible Playbook~~~~&lt;/p>
&lt;p>确定要安装的版本。Kolla-ansible 的版本号与 Openstack 的版本号保持一致，这里以 Openstack 的 &lt;code>xena&lt;/code> 版本为例&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>export KOLLA_BRANCH_NAME&lt;span style="color:#f92672">=&lt;/span>xena
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>使用 pip 安装 kolla-ansible 及其依赖项。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>pip install git+https://opendev.org/openstack/kolla-ansible@&lt;span style="color:#e6db74">${&lt;/span>KOLLA_BRANCH_NAME&lt;span style="color:#e6db74">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>创建配置目录&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>sudo mkdir -p /etc/kolla
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>sudo chown $USER:$USER /etc/kolla
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>cp -r &lt;span style="color:#e6db74">${&lt;/span>KOLLA_DIR&lt;span style="color:#e6db74">}&lt;/span>/venv/share/kolla-ansible/etc_examples/kolla/* /etc/kolla
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>将 Ansible Playbook 所需的 Inventory 拷贝到当前目录&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>cp &lt;span style="color:#e6db74">${&lt;/span>KOLLA_DIR&lt;span style="color:#e6db74">}&lt;/span>/venv/share/kolla-ansible/ansible/inventory/* .
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="配置-ansible">配置 Ansible&lt;/h2>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>mkdir -p /etc/ansible
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>tee /etc/ansible/ansible.cfg &amp;gt; /dev/null &lt;span style="color:#e6db74">&amp;lt;&amp;lt;EOF
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">[defaults]
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">host_key_checking=False
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">pipelining=True
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">forks=100
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">EOF&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="all-in-one-部署-openstack">All-in-one 部署 OpenStack&lt;/h2>
&lt;h3 id="配置-kolla">配置 Kolla&lt;/h3>
&lt;p>为 &lt;code>/etc/kolla/passwords.yml&lt;/code> 文件生成密码&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>kolla-genpwd
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>配置 &lt;code>/etc/kolla/globals.yml&lt;/code> 文件&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>kolla_base_distro: &lt;span style="color:#e6db74">&amp;#34;ubuntu&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>kolla_install_type: &lt;span style="color:#e6db74">&amp;#34;source&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>network_interface: &lt;span style="color:#e6db74">&amp;#34;eno3&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># neutron 外部接口就是指内网环境。该网络设备将会桥街道 ovs-switch 这个桥设备上。&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>neutron_external_interface: &lt;span style="color:#e6db74">&amp;#34;eno4&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>kolla_internal_vip_address: &lt;span style="color:#e6db74">&amp;#34;192.168.88.236&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>enable_cinder: &lt;span style="color:#e6db74">&amp;#34;yes&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>openstack_release: &lt;span style="color:#e6db74">&amp;#34;xena&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>enable_haproxy: &lt;span style="color:#e6db74">&amp;#34;no&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="配置-inventory">配置 Inventory&lt;/h3>
&lt;p>略，直接使用 localhost 即可&lt;/p>
&lt;h3 id="部署依赖并检查环境">部署依赖并检查环境&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>kolla-ansible -i ./all-in-one bootstrap-servers
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>kolla-ansible -i ./all-in-one prechecks
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="部署-openstack">部署 OpenStack&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>kolla-ansible -i ./all-in-one pull ？？？待验证
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>kolla-ansible -i ./all-in-one deploy
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="multinode-部署-openstack">Multinode 部署 OpenStack&lt;/h2></description></item><item><title>Docs: OpenTelemetry</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/6.%E5%8F%AF%E8%A7%82%E6%B5%8B%E6%80%A7/opentelemetry/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/6.%E5%8F%AF%E8%A7%82%E6%B5%8B%E6%80%A7/opentelemetry/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://github.com/open-telemetry">GitHub 组织，OpenTelemetry&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://opentelemetry.io/">官网&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://opentelemetry.io/docs/">官方文档&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://mp.weixin.qq.com/s/bcziZg8RhCrMGYgFeN76cw">公众号-OpenTelemetry，OpenTelemetry 核心原理篇 ：怎么理解分布式链路追踪技术？&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://mp.weixin.qq.com/s/3dD0hIuqpXdepLVC6V7aoA">公众号-OpenTelemetry，在生产环境如何选择靠谱的 APM 系统&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>&lt;strong>OpenTelemetry(开放式遥测技术，简称 OTel)&lt;/strong> 于 2019 年 5 月由 &lt;a href="https://opentracing.io/">OpenTracing&lt;/a> 与 OpenCensus 合并而成(&lt;a href="https://opensource.googleblog.com/2019/05/opentelemetry-merger-of-opencensus-and.html">Google Open Source&lt;/a>)，是一组 API、SDK、工具、更是一种遥测标准，旨在创建和管理 **Telemetry Data(遥测数据)。**通过 OpenTelemetry 标准创建的程序，可以采集 OpenTelemetry 标准的遥测数据，并发送到我们指定的后端中。OpenTelemetry 支持各种流行的开源后端项目，比如 Prometheus、Jaeger 等。&lt;/p>
&lt;blockquote>
&lt;p>遥测数据包括：Traces(链路追踪数据)、Metrics(指标数据)、logs(日志数据)&lt;/p>
&lt;/blockquote>
&lt;p>注意：OpenTelemetry 不是像 Prometheus、Jaeger 那样的可观察性后端。相反，OpenTelemetry 支持将数据导出到各种开源和商业的后端产品中，它提供了一个可插拔的架构，因此可以轻松添加其他技术协议和格式。&lt;/p>
&lt;p>OTEL 之于可观测性，类似 OCI 之于容器。&lt;/p>
&lt;h2 id="opentelemetry-组件">OpenTelemetry 组件&lt;/h2>
&lt;p>目前，OpenTelemetry 由以下几个主要组件组成：&lt;/p>
&lt;ul>
&lt;li>&lt;strong>规范&lt;/strong> # 与编程语言无关的规范，规定了遥测数据格式等&lt;/li>
&lt;li>&lt;strong>工具&lt;/strong> # 用于采集、转换、导出遥测数据的工具&lt;/li>
&lt;li>&lt;strong>SDK&lt;/strong> # 用于为各种编程语言提供编写符合 OpenTelemetry 规范的工具&lt;/li>
&lt;li>&lt;strong>自动 instrumentation 和 贡献包&lt;/strong> # 没搞懂这是什么？&lt;/li>
&lt;/ul>
&lt;h2 id="opentelemetry-历史">OpenTelemetry 历史&lt;/h2>
&lt;h1 id="opentelemetry-实现">OpenTelemetry 实现&lt;/h1>
&lt;p>&lt;a href="https://github.com/grafana/agent">GitHub 项目，grafana/agent&lt;/a> #
&lt;a href="https://github.com/flashcatcloud/categraf">GitHub 项目，flashcatcloud/categraf&lt;/a> # 通过配置文件，采集所有数据，然后 Push 给 Prom(Prom 需要使用 &lt;code>--web.enable-remote-write-receiver&lt;/code> 为自身开启远程写功能)，暂时没有等待 pull 的功能(截止 2022.6.1 v0.1.0 版本)
&lt;a href="https://www.guance.com/">https://www.guance.com/&lt;/a> 观测云。。。。这个产品。。怎么说呢。。上来就让人各种注册才能体验的感觉很不好。。而且在云原生社区可观测性 SIG 群里，这家人的表达方式和处理事情的态度给人的感觉也不好~~工作内部矛盾放在群里说。。还揭露个人隐私。。。。o(╯□╰)o~&lt;/p>
&lt;h2 id="grafana-agent">Grafana Agent&lt;/h2>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://github.com/grafana/agent">GitHub 项目，grafana/agent&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://grafana.com/docs/agent/latest/">官方文档&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>Grafana Agent 收集遥测数据并将其转发到 Grafana Stack、Grafana Cloud 或 Grafana Enterprise 的开源部署，然后可以在其中分析您的数据。您可以在 Kubernetes 和 Docker 上安装 Grafana Agent，或者作为 Linux、macOS 和 Windows 机器的系统进程。&lt;/p>
&lt;p>Grafana Agent 是开源的，其源代码可在 GitHub 上的&lt;a href="https://github.com/grafana/agent">https://github.com/grafana/agent&lt;/a>上获得。&lt;/p>
&lt;p>Grafana Agent 适用于希望收集和转发遥测数据以进行分析和待命警报的工程师、操作员或管理员。那些运行 Grafana Agent 的人必须安装和配置 Grafana Agent 才能正确收集遥测数据并监控正在运行的代理的健康状况。&lt;/p></description></item><item><title>Docs: ECMAScript 包管理器</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/2.%E7%BC%96%E7%A8%8B/%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/ecmascript/ecmascript-%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8/ecmascript-%E6%A8%A1%E5%9D%97%E4%B8%8E%E5%8C%85%E7%9A%84%E4%BD%BF%E7%94%A8%E4%B8%8E%E7%AE%A1%E7%90%86/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/2.%E7%BC%96%E7%A8%8B/%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/ecmascript/ecmascript-%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8/ecmascript-%E6%A8%A1%E5%9D%97%E4%B8%8E%E5%8C%85%E7%9A%84%E4%BD%BF%E7%94%A8%E4%B8%8E%E7%AE%A1%E7%90%86/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://docs.npmjs.com/cli/v8/configuring-npm/folders">官方文档，cli-配置 npm-文件夹&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>ECMAScript 的模块与包相关概念与工具是相当混乱的，最早期是由 Node.js 安装时自带的 NPM 工具集进行管理，并且 NPM 工具集中的工具除了模块与包的管理，还可以提供运行时环境等功能。&lt;/p>
&lt;p>在后期，出现了 yarn、pnpm 等新型的管理工具，可以通过 Node.js 自带的 &lt;code>corepack enable&lt;/code> 命令启用这些新的包管理工具。&lt;/p>
&lt;p>ECMAScript 的包管理器安装各种包、依赖时，早期都是分开的，可以安装在项目当前目录，或某一个统一目录。但是如果项目想要正常启动，一般都只能安装在项目的当前目录（历史原因已不可考，反正很恶心）。&lt;/p>
&lt;p>后来出现的 pnpm 工具，可以让我们将各种不同的项目的依赖放在同一个路径下进行统一管理。&lt;/p>
&lt;h2 id="模块与包的存储路径">模块与包的存储路径&lt;/h2>
&lt;p>npm 工具会通过 $PREFIX 与 node_modules 组合来决定其所管理的各种依赖包应该保存在什么位置。&lt;/p>
&lt;p>其他工具也基本都符合这两点最基本的定义。&lt;/p>
&lt;h3 id="prefix-配置">PREFIX 配置&lt;/h3>
&lt;p>npm 有一个自带的配置 PREFIX，PREFIX 用来定位目录前缀，以决定将文件放在文件系统的何处。可以通过 &lt;code>npm config get prefix&lt;/code> 命令查看 PREFIX 的值。&lt;/p>
&lt;p>&lt;strong>PREFIX 通常默认为 Node.js 的安装路径&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>Linux 中，我个人通常装在 &lt;code>/usr/local/nodejs/&lt;/code> 目录下。&lt;/li>
&lt;li>Windows 由于某些原因，使用 msi 安装包安装的 Node.js 会将该 PREFIX 改为 &lt;code>%APPDATA%/npm/&lt;/code>，而不是安装目录。
&lt;ul>
&lt;li>可以从 nodejs 安装路径下的 node_modules/npm/npmrc 文件中看到有这么一条配置：&lt;code>prefix=${APPDATA}\npm&lt;/code>&lt;/li>
&lt;li>但是我们可以使用 zip 包，手动安装 Node.js，详情见：&lt;a href="https://desistdaydream.github.io/docs/IT%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/2.%E7%BC%96%E7%A8%8B/%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/ECMAScript/ECMAScript%20%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8/ECMAScript%20%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8.md#Windows">ECMAScript 环境安装与使用&lt;/a>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h3 id="node_modules-目录">node_modules 目录&lt;/h3>
&lt;p>当我们使用包管理命令安装各种第三方库(依赖包)及其衍生物通常会保存在名为 &lt;code>node_modules/&lt;/code> 目录下，通常会有两个地方有 node_modules 目录：&lt;/p>
&lt;ul>
&lt;li>&lt;strong>Locally(本地)&lt;/strong> # 这是默认的行为，安装的东西放在当前目录的 &lt;code>./node_modules/&lt;/code> 目录中
&lt;ul>
&lt;li>当我们想要在代码中使用 require() 或 import 导入模块时，通常安装在本地&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>Globally(全局)&lt;/strong> # 使用 &lt;code>-g&lt;/code> 选项，将安装的东西放在 &lt;code>${PREFIX}/lib/node_modules/&lt;/code> 目录中
&lt;ul>
&lt;li>若安装的东西中具有可以在 CLI 执行的工具，则同时会在 &lt;code>${PREFIX}/bin/&lt;/code> 目录下生成指向原始文件的软链接，&lt;code>${PREFIX}/bin/&lt;/code> 目录通常都会加入到 &lt;code>${PATH}&lt;/code> 变量中。&lt;/li>
&lt;li>当我们安装的包可以在命令行执行时，通常安装在全局&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;blockquote>
&lt;p>注意：Windows 的全局 node_modules 目录与 Linux 不太一样，全局路径是 ${PREFIX}/node_modeuls。也就是说生成的链接文件就在 ${PREFIX} 下。&lt;/p>
&lt;/blockquote>
&lt;h1 id="npm">NPM&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://www.npmjs.com/">官网&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://docs.npmjs.com/cli/v8/using-npm/config">官方文档，cli-使用 npm-配置&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>&lt;strong>Node.js Package Manager(简称 NPM)&lt;/strong> 是 Node.js 自带的包管理工具，通常与 Node.js 一同安装，最初版本于 2010 年 1 月发行。NPM 本质是一个第三方模块，可以在 NodeJS 安装目录下的 &lt;strong>lib/node_modules/npm/&lt;/strong>* 目录下找到 npm 的所有文件。&lt;/p>
&lt;p>配置镜像源为淘宝的： &lt;code>npm config -g set registry=&amp;quot;https://registry.npmmirror.com&amp;quot;&lt;/code>&lt;/p>
&lt;h2 id="npm-关联文件与配置">npm 关联文件与配置&lt;/h2>
&lt;p>npm 从 命令行、环境变量、npmrc 文件 这些地方获取其配置信息：&lt;/p>
&lt;ul>
&lt;li>&lt;strong>命令行标志&lt;/strong>&lt;/li>
&lt;li>&lt;strong>环境变量&lt;/strong>&lt;/li>
&lt;li>&lt;strong>npmrc 文件&lt;/strong> # npm 从以下几个地方依次读取 npmrc 文件
&lt;ul>
&lt;li>&lt;strong>/PATH/TO/NPM/npmrc&lt;/strong> # npm 内置的配置文件。这内置的文件是不是不可见的？o(╯□╰)o&lt;/li>
&lt;li>&lt;strong>${PREFIX}/etc/npmrc&lt;/strong> # 全局配置文件，可以通过 &lt;code>--globalconfig&lt;/code> 命令行选项或 &lt;code>${NPM_CONFIG_GLOBALCONFIG}&lt;/code> 环境变量改变其值&lt;/li>
&lt;li>&lt;strong>~/.npmrc&lt;/strong> # 用户配置文件，可以通过 &lt;code>--userconfig&lt;/code> 命令行选项或 &lt;code>${NPM_CONFIG_USERCONFIG}&lt;/code> 环境变量改变其值&lt;/li>
&lt;li>&lt;strong>/PATH/TO/MY/PROJECT/.npmrc&lt;/strong> # 每个项目自己的配置&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>${PREFIX}/bin/&lt;/strong>* # npm 安装的各种依赖包中若包含命令行工具，则会在此目录创建软链接。该目录通常都会加入到 &lt;code>${PATH}&lt;/code> 变量中。&lt;/p>
&lt;h2 id="配置文件详解">配置文件详解&lt;/h2>
&lt;p>所有可供配置的信息可从 &lt;a href="https://docs.npmjs.com/cli/v8/using-npm/config#config-settings">https://docs.npmjs.com/cli/v8/using-npm/config#config-settings&lt;/a> 查看&lt;/p>
&lt;h1 id="pnpm">PNPM&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://github.com/pnpm/pnpm">GitHub 项目，pnpm/pnpm&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://pnpm.io/">官网&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://juejin.cn/post/7047556067877716004">稀土掘金，pnpm 对比 npm/yarn 好在哪里&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>当使用 npm 或 Yarn 时，如果你有 100 个项目使用了某个依赖（dependency），就会有 100 份该依赖的副本保存在硬盘上。 而在使用 pnpm 时，依赖会被存储在内容可寻址的存储中，所以：&lt;/p>
&lt;ol>
&lt;li>如果你用到了某依赖项的不同版本，只会将不同版本间有差异的文件添加到仓库。 例如，如果某个包有 100 个文件，而它的新版本只改变了其中 1 个文件。那么 pnpm update 时只会向存储中心额外添加 1 个新文件，而不会因为仅仅一个文件的改变复制整新版本包的内容。&lt;/li>
&lt;li>所有文件都会存储在硬盘上的某一位置。 当软件包被被安装时，包里的文件会硬链接到这一位置，而不会占用额外的磁盘空间。 这允许你跨项目地共享同一版本的依赖。&lt;/li>
&lt;/ol>
&lt;p>因此，您在磁盘上节省了大量空间，这与项目和依赖项的数量成正比，并且安装速度要快得多！&lt;/p>
&lt;p>store-dir 说明：&lt;/p>
&lt;ul>
&lt;li>&lt;strong>项目中的 node_models/ 应该使用与 store-dir 目录在同一个分区中&lt;/strong>&lt;/li>
&lt;/ul>
&lt;h2 id="安装-pnpm">安装 pnpm&lt;/h2>
&lt;p>使用 &lt;code>corepack enable&lt;/code> 指令启用 pnpm&lt;/p>
&lt;p>设置包的存储路径：&lt;/p>
&lt;ul>
&lt;li>Windows：&lt;code>pnpm config -g set store-dir D:\Projects\.pnpm-store&lt;/code>&lt;/li>
&lt;li>Linux：&lt;code>pnpm config -g set store-dir /mnt/d/Projects/.pnpm-store&lt;/code>&lt;/li>
&lt;/ul>
&lt;p>配置镜像源：&lt;/p>
&lt;ul>
&lt;li>&lt;code>pnpm config -g set registry=&amp;quot;https://registry.npmmirror.com&amp;quot;&lt;/code>&lt;/li>
&lt;/ul>
&lt;p>若 Windows 无法执行 pnpm，报错：&lt;code>pnpm : 无法加载文件 D:\Tools\nodejs\pnpm.ps1，因为在此系统上禁止运行脚本。有关详细信息，请参阅 https:/go.microsoft.com/fwlink/?LinkID=135170 中的 about_Execution_Policies。&lt;/code>&lt;/p>
&lt;ul>
&lt;li>此时需要在 PowerShell 中执行 &lt;code>Set-ExecutionPolicy -Scope CurrentUser RemoteSigned&lt;/code> 指令。详见&lt;a href="https://learn.microsoft.com/zh-cn/powershell/module/microsoft.powershell.core/about/about_execution_policies?view=powershell-7.2">微软官网解释&lt;/a>。
&lt;ul>
&lt;li>其中 &lt;code>-Scope CurrentUser&lt;/code> 是指针对当前用户的操作，若使用管理员运行 VSCode 或 PowerShell，则不用加这个选项。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h2 id="更新-pnpm">更新 pnpm&lt;/h2>
&lt;pre tabindex="0">&lt;code>corepack prepare pnpm@7.14.1 --activate
&lt;/code>&lt;/pre>&lt;h2 id="pnpm-关联文件与配置">pnpm 关联文件与配置&lt;/h2>
&lt;p>&lt;strong>/PATH/TO/.pnpm-store/&lt;/strong> # 存放各项目依赖的目录。默认为根目录下的 .pnpm-store/ 目录。可以通过 &lt;code>pnpm config -g set store-dir &amp;lt;DIR&amp;gt;&lt;/code> 修改&lt;/p>
&lt;h1 id="npm-与-pnpm-语法">npm 与 pnpm 语法&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://docs.npmjs.com/cli">官方文档，cli&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>通常，适用于 npm 的选项，也适用于 pnpm&lt;/p>
&lt;p>&lt;strong>npm [OPTIONS] COMMAND [OPTIONS]&lt;/strong>&lt;/p>
&lt;p>&lt;strong>OPTIONS&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>&lt;strong>-g, &amp;ndash;global&lt;/strong> # 指定命令作用范围为全局。默认情况下 npm 的所有子命令作用范围是当前目录&lt;/li>
&lt;/ul>
&lt;h2 id="npm-config">npm config&lt;/h2>
&lt;p>npm config 用来管理 npm 的配置文件，i.e.npmrc 文件。&lt;/p>
&lt;h3 id="syntax语法">Syntax(语法)&lt;/h3>
&lt;p>&lt;strong>npm config COMMAND [KEY=VALUE]&lt;/strong>&lt;/p>
&lt;p>&lt;strong>COMMAND&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>set&lt;/li>
&lt;li>get&lt;/li>
&lt;li>delete&lt;/li>
&lt;li>list&lt;/li>
&lt;li>edit&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>OPTIONS&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>&lt;strong>-g, &amp;ndash;global&lt;/strong> # 对全局配置文件(${PREFIX}/etc/npmrc) 执行操作&lt;/li>
&lt;/ul>
&lt;h3 id="example">EXAMPLE&lt;/h3>
&lt;p>列出所有已知配置&lt;/p>
&lt;ul>
&lt;li>npm config ls -l&lt;/li>
&lt;/ul>
&lt;p>获取 prefix 配置的值&lt;/p>
&lt;ul>
&lt;li>npm config get prefix&lt;/li>
&lt;/ul>
&lt;h2 id="npm-exec">npm exec&lt;/h2>
&lt;p>从本地或远程 npm 包运行命令&lt;/p>
&lt;h3 id="syntax语法-1">Syntax(语法)&lt;/h3>
&lt;p>&lt;strong>npm exec &amp;ndash; &amp;lt;pkg&amp;gt;[@&amp;lt;version&amp;gt;] [args&amp;hellip;]&lt;/strong>
&lt;strong>npm exec &amp;ndash;package=&amp;lt;pkg&amp;gt;[@&amp;lt;version&amp;gt;] &amp;ndash; &amp;lt;cmd&amp;gt; [args&amp;hellip;]&lt;/strong>
&lt;strong>npm exec -c &amp;lsquo;&amp;lt;cmd&amp;gt; [args&amp;hellip;]&amp;rsquo;&lt;/strong>
&lt;strong>npm exec &amp;ndash;package=foo -c &amp;lsquo;&amp;lt;cmd&amp;gt; [args&amp;hellip;]&amp;rsquo;&lt;/strong>&lt;/p>
&lt;p>&lt;strong>OPTIONS&lt;/strong>&lt;/p>
&lt;h2 id="npm-install">npm install&lt;/h2>
&lt;p>安装项目的所有依赖&lt;/p>
&lt;p>install 可以简写为 i。&lt;/p>
&lt;h3 id="syntax语法-2">Syntax(语法)&lt;/h3>
&lt;p>&lt;strong>OPTIONS&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>&lt;strong>-D, &amp;ndash;save-dev&lt;/strong> # 安装的包将会出现在 &lt;code>devDependencies&lt;/code> 中&lt;/li>
&lt;/ul>
&lt;h2 id="npm-init">npm init&lt;/h2>
&lt;p>创建一个 package.json 文件。用来初始化一个项目&lt;/p>
&lt;h3 id="syntax语法-3">Syntax(语法)&lt;/h3>
&lt;p>&lt;strong>npm init [&amp;ndash;force|-f|&amp;ndash;yes|-y|&amp;ndash;scope]&lt;/strong>
&lt;strong>npm init &amp;lt;@scope&amp;gt; (same as &lt;code>npx &amp;lt;@scope&amp;gt;/create&lt;/code>)&lt;/strong>
&lt;strong>npm init [&amp;lt;@scope&amp;gt;]&amp;lt;name&amp;gt; (same as &lt;code>npx [&amp;lt;@scope&amp;gt;/]create-&amp;lt;name&amp;gt;&lt;/code>)&lt;/strong>&lt;/p>
&lt;p>&lt;strong>OPTIONS&lt;/strong>&lt;/p>
&lt;h2 id="npm-list">npm list&lt;/h2>
&lt;p>列出所有已经安装的包。默认列出当前项目中已安装的包，通常检查如下目录：&lt;code>node_modules/&lt;/code>&lt;/p>
&lt;h2 id="npm-update">npm update&lt;/h2>
&lt;p>更新已安装的包&lt;/p>
&lt;h1 id="yarn">Yarn&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://yarnpkg.com/">官网&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>管理 Yarn 的首选方式是通过 &lt;a href="https://nodejs.org/dist/latest/docs/api/corepack.html">Corepack&lt;/a>，这是从 16.10 开始随所有 Node.js 版本一起提供的新二进制文件。它充当我们和 Yarn 之间的中介，让我们在多个项目中使用不同的包管理器版本，而无需再签入 Yarn 二进制文件。&lt;/p>
&lt;p>Node.js &amp;gt;=16.10
Corepack 默认包含在所有 Node.js 安装中，但目前是可选的。要启用它，请运行以下命令：
&lt;code>corepack enable&lt;/code>&lt;/p>
&lt;p>Node.js &amp;lt;16.10
在 16.10 之前的版本中，Node.js 不包含 Corepack；为了解决这个问题，运行：
&lt;code>npm i -g corepack&lt;/code>&lt;/p>
&lt;p>配置镜像源以加速下载各种依赖包&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>yarn config set registry https://registry.npmmirror.com -g
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>配置 $PATH 以便可以直接执行通过 yarn 安装的各种工具&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>export PATH&lt;span style="color:#f92672">=&lt;/span>$PATH:~/.config/yarn/global/node_modules/.bin
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="yarn-关联文件与配置">Yarn 关联文件与配置&lt;/h2>
&lt;p>&lt;strong>~/.yarnrc&lt;/strong> # 配置文件
&lt;strong>~/.config/yarn/&lt;/strong>* #&lt;/p>
&lt;h1 id="yarn-syntax语法">yarn Syntax(语法)&lt;/h1>
&lt;h1 id="实用工具">实用工具&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://www.ruanyifeng.com/blog/2019/02/npx.html">https://www.ruanyifeng.com/blog/2019/02/npx.html&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>npx 是 NPM 中自带的工具&lt;/p>
&lt;p>通过 &lt;code>npx serve&lt;/code> 命令(与 &lt;code>npm exec serve&lt;/code> 命令类似)可以启动一个 HTTP 服务，以访问当前目录下的所有静态资源文件。便于本地开发调试。&lt;/p></description></item><item><title>Docs: LogRotate(日志轮替)</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/6.%E5%8F%AF%E8%A7%82%E6%B5%8B%E6%80%A7/%E6%97%A5%E5%BF%97%E7%B3%BB%E7%BB%9F/logrotate%E6%97%A5%E5%BF%97%E8%BD%AE%E6%9B%BF/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/6.%E5%8F%AF%E8%A7%82%E6%B5%8B%E6%80%A7/%E6%97%A5%E5%BF%97%E7%B3%BB%E7%BB%9F/logrotate%E6%97%A5%E5%BF%97%E8%BD%AE%E6%9B%BF/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://mp.weixin.qq.com/s/b_CWt_ycvnbQG9TXPqRoCQ">公众号-马哥 Linux 运维，[译] 理解 logrotate 实用工具&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>为了防止日志文件持续被写入文件导致过于庞大，那么就需要对日志进行拆分，每隔一段时间就把日志文件保存(打包压缩)起来，然后再创建一个新的空文件继续接收日志，来回循环该过程直到通过配置规定的保留日期，来清除存在过久的日志。通过这种方式来进行日志的归档，分类，清理。这就是 LogRotate 所做的事情。是否进行轮替会有一系列的配置，比如文件的大小达到 N 会轮替一次，每隔多少天轮替一次等等。&lt;/p>
&lt;p>logrotate 只是一个命令行工具，不以守护进程的方式运行在后台，默认情况下，logrotate 命令作为放在 /etc/cron.daily 中的 cron 任务，每天运行一次，该任务会根据设置的策略进行日志文件的检查，其中达到设置中满足轮替配置的日志文件将被轮替。&lt;/p>
&lt;h1 id="关联文件与配置">关联文件与配置&lt;/h1>
&lt;p>/etc/logrotate.conf # logrotate 基本配置文件
/etc/logrotate.d/* # 对基本文件的扩展，该目录下的文件的配置会被包含在基本配置文件中。该目录下一般是一个程序一个文件，每个程序都有自己的日志轮替配置。
/etc/cron.daily/logrotate # 该文件定义了 cron 定时任务执行日志轮替工作的时间
/var/lib/logrotate.status # logrotate 的执行历史&lt;/p>
&lt;h2 id="logrotateconf-配置文件详解">logrotate.conf 配置文件详解&lt;/h2>
&lt;ul>
&lt;li>/PATH/TO/FILES {&amp;hellip;} #指定想要轮替的日志文件，可以通过＊通配指定多个文件名
&lt;ul>
&lt;li>&lt;strong>copytruncate&lt;/strong> # 把正在输出的日志拷(copy)一份出来，再清空(trucate)原来的日志。&lt;/li>
&lt;li>&lt;strong>compress&lt;/strong> # 压缩日志文件的所有非当前版本&lt;/li>
&lt;li>&lt;strong>dateext&lt;/strong> # 切换后的日志文件会附加上一个短横线和 YYYYMMDD 格式的日期,&lt;/li>
&lt;li>&lt;strong>daily&lt;/strong> # 日志文件将每天轮替一次。其它可用值为 monthly(每月)，weekly(每周)、yearly(每年)&lt;/li>
&lt;li>&lt;strong>delaycompress&lt;/strong> # 在轮替任务完成后，已轮替的归档将使用 gzip 进行压缩&lt;/li>
&lt;li>&lt;strong>errors &lt;!-- raw HTML omitted -->&lt;/strong> # 给指定邮箱发送错误通知&lt;/li>
&lt;li>&lt;strong>missingok&lt;/strong> # 如果日志文件丢失，不要显示错误&lt;/li>
&lt;li>&lt;strong>notifempty&lt;/strong> # 如果日志文件为空，则不轮换日志文件&lt;/li>
&lt;li>&lt;strong>olddir &lt;!-- raw HTML omitted -->&lt;/strong> # 指定日志文件的旧版本放在 “DIR”目录 中&lt;/li>
&lt;li>&lt;strong>postrotate 和 endscript&lt;/strong> # 在所有其它指令完成后，postrotate 和 endscript 里面指定的命令将被执行。在这种情况下，rsyslogd 进程将立即再次读取其配置并继续运行。&lt;/li>
&lt;li>&lt;strong>rotate N&lt;/strong> # 共存储 N 个轮替后日志。当产生第 N+1 个轮替后的日志，时间最久的日志将被删除&lt;/li>
&lt;li>&lt;strong>sharedscripts&lt;/strong> # 有多个日志需要轮替时，只执行一次脚本&lt;/li>
&lt;li>&lt;strong>size &lt;!-- raw HTML omitted -->&lt;/strong> # 在日志文件大小大于 LogSize（例如 100K，4M）时进行轮替&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>配置样例&lt;/p>
&lt;pre>&lt;code>/var/log/nginx/*log {
daily
rotate 10
missingok
notifempty
compress
dateext
sharedscripts
postrotate
/bin/kill -USR1 $(cat /var/run/ngnix/nginx.pid 2&amp;gt;/dev/null) 2&amp;gt;/dev/null
endscript
}
&lt;/code>&lt;/pre>
&lt;p>Note：关于 postrotate
postrotate 后面跟随的是一个命令行，一般是用来重新生成日志文件或者冲定义应用所指向的文件描述符（fd：file description），拿 nginx 和 uwsgi 为例：&lt;/p>
&lt;p>完成日志切割后创建新的 nginx 日志文件，此时该文件的 fd 发生改变&lt;/p>
&lt;p>nginx 中日志输出对应的文件 fd 未同步更新，nginx 会向原 fd 对应的日志文件写数据&lt;/p>
&lt;p>“/bin/kill -USR1 cat /var/run/nginx.pid || true”，更新 nginx 默认日志文件的 fd 到新建的日志文件（该效果等同于 reload）。&lt;/p>
&lt;p>关于/bin/kill -HUP&lt;/p>
&lt;p>&amp;ldquo;/bin/kill -USR1 &lt;code>cat /var/run/nginx.pid&lt;/code> || true&amp;rdquo;&lt;/p>
&lt;p>看到这条命令很容易想到：&lt;/p>
&lt;p>/bin/kill -HUP &lt;code>cat /var/run/nginx.pid 2&amp;gt; /dev/null&lt;/code> 2&amp;gt; /dev/null || true&lt;/p>
&lt;p>这两条命令的大概含义是重载 nginx 服务，目的是重新生成 nginx 的日志文件。&lt;/p>
&lt;h1 id="命令行工具">命令行工具&lt;/h1>
&lt;p>logrotate [OPTIONS&amp;hellip;]&lt;/p>
&lt;p>OPTIONS&lt;/p>
&lt;ul>
&lt;li>&lt;strong>-f&lt;/strong> # 告诉 logrotate 强制执行轮替，即使这不是必要的(i.e.测试轮替的配置文件是否可以正常运行)。 有时，在向 logrotate 配置文件添加新条目之后，或者如果已经手动删除旧的日志文件，这将是有用的，因为将创建新文件，并且日志记录将正常继续。&lt;/li>
&lt;/ul>
&lt;p>EXAMPLE&lt;/p>
&lt;ul>
&lt;li>logrotate -f /etc/logrotate.d/keepalived #使用/etc/logrotate.d/keepalived 配置文件执行轮替&lt;/li>
&lt;/ul>
&lt;p>PS:&lt;/p>
&lt;ul>
&lt;li>遇到不能记录日志的情况：kill -USR1 pid 重发信号量&lt;/li>
&lt;/ul></description></item><item><title>Docs: Journal</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/6.%E5%8F%AF%E8%A7%82%E6%B5%8B%E6%80%A7/%E6%97%A5%E5%BF%97%E7%B3%BB%E7%BB%9F/journal/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/6.%E5%8F%AF%E8%A7%82%E6%B5%8B%E6%80%A7/%E6%97%A5%E5%BF%97%E7%B3%BB%E7%BB%9F/journal/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://man7.org/linux/man-pages/man8/systemd-journald.service.8.html">Manual,systemd-journald.service(8)&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>相关服务说明&lt;/p>
&lt;ul>
&lt;li>systemd-Journald.service # 日志功能通过该 Unit 来实现，是一个用于收集和存储日志数据的系统服务，是系统启动前要启动的第一个进程，Journald 会把所有收集到的信息保存在内存中。&lt;/li>
&lt;li>rsyslog.service # 另一种日志数据持久化，Journald 会把日志信息转发给 rsyslog.service 进行处理和保存，如果没有 Journald，rsyslog 也可以自动生成日志而不用从 journald 去获取&lt;/li>
&lt;li>logrotate # logrotate 会对日志文件进行轮替操作，i.e.把已经非常大的日志文件改名后，创建一个新的日志文件，新产生的日志会保存在新文件中，老文件保留一定时期后会自动清除&lt;/li>
&lt;/ul>
&lt;h1 id="journald-关联文件与配置">Journald 关联文件与配置&lt;/h1>
&lt;p>&lt;strong>/etc/systemd/journal.conf&lt;/strong>&lt;/p>
&lt;h2 id="日志存放路径">日志存放路径&lt;/h2>
&lt;p>&lt;strong>/run/log/journal/${MACHINE-ID}/*&lt;/strong>
&lt;strong>/var/log/journal/${MACHINE-ID}/*&lt;/strong>&lt;/p>
&lt;p>默认情况下，journald 的日志保存在 /run/log/journal 中，系统重启就会清除。通过新建 /var/log/journal 目录，日志会自动记录到这个目录中，并永久存储。&lt;/p>
&lt;p>路径中的 MACHINE-ID 的值，可以通过 &lt;code>cat /etc/machine-id&lt;/code> 命令获取&lt;/p>
&lt;pre>&lt;code>root@lichenhao:/var/log/journal# ls
c14766a3e9ae49a3872fb9b7e2583710
root@lichenhao:/var/log/journal# cat /etc/machine-id
c14766a3e9ae49a3872fb9b7e2583710
&lt;/code>&lt;/pre>
&lt;p>所有 journal 程序生成的日志，都会存在 MACHIN-ID 目录下&lt;/p>
&lt;pre>&lt;code>root@lichenhao:/var/log/journal/c14766a3e9ae49a3872fb9b7e2583710# ll -h
total 153M
drwxr-sr-x+ 2 root systemd-journal 4.0K Feb 21 23:15 ./
drwxr-sr-x+ 3 root systemd-journal 46 Dec 9 17:19 ../
-rw-r-----+ 1 root systemd-journal 40M Dec 28 16:23 'system@aa6b2b3f8f9d46fdb169f9d8aaab56c3-0000000000000001-0005b6048d0b7824.journal'
-rw-r-----+ 1 root systemd-journal 32M Jan 22 12:39 'system@aa6b2b3f8f9d46fdb169f9d8aaab56c3-00000000000080e9-0005b781fc8c48d9.journal'
-rw-r-----+ 1 root systemd-journal 32M Feb 21 23:10 'system@aa6b2b3f8f9d46fdb169f9d8aaab56c3-000000000000df93-0005b975c74c3caf.journal'
-rw-r-----+ 1 root systemd-journal 40M Mar 12 15:25 system.journal
-rw-r-----+ 1 root systemd-journal 8.0M Dec 28 16:23 'user-1000@571778ddc0db463990a85592631fa5e8-0000000000000496-0005b6049323448d.journal'
&lt;/code>&lt;/pre>
&lt;h1 id="journalctl-命令行工具">journalctl 命令行工具&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://man7.org/linux/man-pages/man1/journalctl.1.html">Manual(手册)，journalctl(1)&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>Systemd 统一管理所有 Unit 的启动日志。带来的好处就是，可以只用 journalctl 一个命令，查看所有日志（内核日志和应用日志）。日志的配置文件是/etc/systemd/journald.conf。journalctl 功能强大，用法非常多。&lt;/p>
&lt;h2 id="syntax语法">Syntax(语法)&lt;/h2>
&lt;p>&lt;strong>journalctl [OPTIONS] [MATCHES]&lt;/strong>&lt;/p>
&lt;h3 id="options">OPTIONS&lt;/h3>
&lt;ul>
&lt;li>&lt;strong>&amp;ndash;disk-usage&lt;/strong> # 显示所有日志文件的磁盘使用情况，包括持久化和临时的日志。&lt;/li>
&lt;li>&lt;strong>-f, &amp;ndash;follow&lt;/strong> # 实时更新&lt;/li>
&lt;li>&lt;strong>&amp;ndash;file=FILE&lt;/strong> # 查看指定文件中的日志信息，FILE 可以使用&amp;quot;?&amp;ldquo;与&amp;rdquo;*&amp;ldquo;进行匹配。常用于查看从别的设备上拷贝过来的日志文件&lt;/li>
&lt;li>&lt;strong>-p UNM&lt;/strong> # 指定要显示的日志级别(NUM 为 0-7 级)&lt;/li>
&lt;li>&lt;strong>-u UNIT&lt;/strong> #显示指定的 unit 的日志信息&lt;/li>
&lt;/ul>
&lt;p>格式选项&lt;/p>
&lt;ul>
&lt;li>&lt;strong>&amp;ndash;no-pager&lt;/strong> # 在单一页面显示信息，不分页。默认情况下，若日志过长，需要使用 → 方向键翻页才能查看后面的日志内容。&lt;/li>
&lt;li>&lt;strong>-o, &amp;ndash;output=&lt;!-- raw HTML omitted -->&lt;/strong> # 指定输出格式。&lt;code>默认值：short&lt;/code>
&lt;ul>
&lt;li>可用的格式有：json、json-pretty、verbose、export、with-unit 等等&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>过滤选项&lt;/p>
&lt;ul>
&lt;li>&lt;strong>&amp;ndash;output-fields=FIELD&lt;/strong> # 显示指定字段的日志，多个字段以 &lt;code>,&lt;/code> 分割。
&lt;ul>
&lt;li>字段筛选仅对 -o 选项指定的 verbose、export、json、json-pretty、json-sse、json-seq 这几个输出格式有效&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>-S, &amp;ndash;since TIME&lt;/strong> 与** -U, &amp;ndash;unitl TIME** # 设置输出日志信息的开始与结束时间&lt;/li>
&lt;/ul>
&lt;h2 id="example">EXAMPLE&lt;/h2>
&lt;ul>
&lt;li>查看指定用户的日志
&lt;ul>
&lt;li>sudo journalctl _UID=33 &amp;ndash;since today&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>查看指定进程的日志
&lt;ul>
&lt;li>sudo journalctl _PID=1&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>以 JSON 格式仅输出 MESSAGE 与 _CMDLINE 字段的消息
&lt;ul>
&lt;li>journalctl -u docker -ojson-pretty &amp;ndash;output-fields=MESSAGE,_CMDLINE&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>查看指定时间的日志
&lt;ul>
&lt;li>sudo journalctl &amp;ndash;since=&amp;ldquo;2012-10-30 18:17:16&amp;rdquo;&lt;/li>
&lt;li>sudo journalctl &amp;ndash;since &amp;ldquo;20 min ago&amp;rdquo;&lt;/li>
&lt;li>sudo journalctl &amp;ndash;since yesterday&lt;/li>
&lt;li>sudo journalctl &amp;ndash;since 09:00 &amp;ndash;until &amp;ldquo;1 hour ago&amp;rdquo;&lt;/li>
&lt;li>journalctl &amp;ndash;since &amp;ldquo;2018-11-13&amp;rdquo; &amp;ndash;until &amp;ldquo;2018-11-14 03:00&amp;rdquo;&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h1 id="查看所有日志默认情况下-只保存本次启动的日志">查看所有日志（默认情况下 ，只保存本次启动的日志）&lt;/h1>
&lt;p>$ sudo journalctl&lt;/p>
&lt;h1 id="查看内核日志不显示应用日志">查看内核日志（不显示应用日志）&lt;/h1>
&lt;p>$ sudo journalctl -k&lt;/p>
&lt;h1 id="查看系统本次启动的日志">查看系统本次启动的日志&lt;/h1>
&lt;p>$ sudo journalctl -b&lt;/p>
&lt;p>$ sudo journalctl -b -0&lt;/p>
&lt;h1 id="查看上一次启动的日志需更改设置">查看上一次启动的日志（需更改设置）&lt;/h1>
&lt;p>$ sudo journalctl -b -1&lt;/p>
&lt;h1 id="显示尾部的最新-10-行日志">显示尾部的最新 10 行日志&lt;/h1>
&lt;p>$ sudo journalctl -n&lt;/p>
&lt;h1 id="显示尾部指定行数的日志">显示尾部指定行数的日志&lt;/h1>
&lt;p>$ sudo journalctl -n 20&lt;/p>
&lt;h1 id="查看指定服务的日志">查看指定服务的日志&lt;/h1>
&lt;p>$ sudo journalctl /usr/lib/systemd/systemd&lt;/p>
&lt;h1 id="查看某个路径的脚本的日志">查看某个路径的脚本的日志&lt;/h1>
&lt;p>$ sudo journalctl /usr/bin/bash&lt;/p>
&lt;h1 id="查看某个-unit-的日志">查看某个 Unit 的日志&lt;/h1>
&lt;p>$ sudo journalctl -u nginx.service&lt;/p>
&lt;p>$ sudo journalctl -u nginx.service &amp;ndash;since today&lt;/p>
&lt;h1 id="实时滚动显示某个-unit-的最新日志">实时滚动显示某个 Unit 的最新日志&lt;/h1>
&lt;p>$ sudo journalctl -u nginx.service -f&lt;/p>
&lt;h1 id="合并显示多个-unit-的日志">合并显示多个 Unit 的日志&lt;/h1>
&lt;p>$ journalctl -u nginx.service -u php-fpm.service &amp;ndash;since today&lt;/p>
&lt;h1 id="查看指定优先级及其以上级别的日志共有-8-级">查看指定优先级（及其以上级别）的日志，共有 8 级&lt;/h1>
&lt;h1 id="0-emerg">0: emerg&lt;/h1>
&lt;h1 id="1-alert">1: alert&lt;/h1>
&lt;h1 id="2-crit">2: crit&lt;/h1>
&lt;h1 id="3-err">3: err&lt;/h1>
&lt;h1 id="4-warning">4: warning&lt;/h1>
&lt;h1 id="5-notice">5: notice&lt;/h1>
&lt;h1 id="6-info">6: info&lt;/h1>
&lt;h1 id="7-debug">7: debug&lt;/h1>
&lt;p>$ sudo journalctl -p err -b&lt;/p>
&lt;h1 id="指定日志文件占据的最大空间">指定日志文件占据的最大空间&lt;/h1>
&lt;p>$ sudo journalctl &amp;ndash;vacuum-size=1G&lt;/p>
&lt;h1 id="指定日志文件保存多久">指定日志文件保存多久&lt;/h1>
&lt;p>$ sudo journalctl &amp;ndash;vacuum-time=1years&lt;/p></description></item><item><title>Docs: package.json</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/2.%E7%BC%96%E7%A8%8B/%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/ecmascript/ecmascript-%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8/package.json/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/2.%E7%BC%96%E7%A8%8B/%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/ecmascript/ecmascript-%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8/package.json/</guid><description>
&lt;h2 id="概述">概述&lt;/h2>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://nodejs.dev/learn/the-package-json-guide">dev 官网，学习-package.json 指南&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>package.json 文件是项目的清单。 它可以做很多完全互不相关的事情。 例如，它是用于工具的配置中心。 它也是 npm 和 yarn 等包管理工具管理依赖的地方。&lt;/p></description></item><item><title>Docs: Docsy</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%AE%9E%E7%94%A8%E5%B7%A5%E5%85%B7/%E7%BD%91%E7%AB%99%E6%90%AD%E5%BB%BA/hugo/%E4%B8%BB%E9%A2%98/docsy/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%AE%9E%E7%94%A8%E5%B7%A5%E5%85%B7/%E7%BD%91%E7%AB%99%E6%90%AD%E5%BB%BA/hugo/%E4%B8%BB%E9%A2%98/docsy/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://github.com/google/docsy">GitHub 项目，google/docsy&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.docsy.dev/">官网&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>Kubernetes 的官网就是 Docsy 主题。&lt;/p>
&lt;p>注意：Docsy 必须使用 扩展版 hugo，即 hugo_extended。&lt;/p>
&lt;h1 id="预览和部署-docsy-主题网站">预览和部署 Docsy 主题网站&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://www.docsy.dev/docs/deployment/">官方文档，预览和部署&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;h2 id="准备环境">准备环境&lt;/h2>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>npm install -D autoprefixer
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>npm install -D postcss-cli
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>npm install -D postcss
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;blockquote>
&lt;p>若不在本地安装，则使用 &lt;code>hugo&lt;/code> 命令构建静态文件时将会报错&lt;/p>
&lt;/blockquote>
&lt;h2 id="生成站点文件">生成站点文件&lt;/h2>
&lt;h3 id="生成模板站点">生成模板站点&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>export MY_SITE_DIR&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;docsy&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>git clone https://github.com/google/docsy-example.git &lt;span style="color:#e6db74">${&lt;/span>MY_SITE_DIR&lt;span style="color:#e6db74">}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>cd &lt;span style="color:#e6db74">${&lt;/span>MY_SITE_DIR&lt;span style="color:#e6db74">}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>hugo server
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="生成空白站点">生成空白站点&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-Bash" data-lang="Bash">&lt;span style="display:flex;">&lt;span>hugo new site .
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>hugo mod init github.com/me/my-new-site
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>hugo mod get github.com/google/docsy@v0.6.0
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>cat &amp;gt;&amp;gt; config.toml &lt;span style="color:#e6db74">&amp;lt;&amp;lt;EOL
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">[module]
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">proxy = &amp;#34;direct&amp;#34;
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">[[module.imports]]
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">path = &amp;#34;github.com/google/docsy&amp;#34;
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">[[module.imports]]
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">path = &amp;#34;github.com/google/docsy/dependencies&amp;#34;
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">EOL&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="预览">预览&lt;/h2>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>hugo server
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="部署">部署&lt;/h2>
&lt;p>&lt;a href="https://lucumt.info/post/hugo/using-github-action-to-auto-build-deploy/">https://lucumt.info/post/hugo/using-github-action-to-auto-build-deploy/&lt;/a>
&lt;a href="https://tomial.github.io/posts/hugo%E4%BD%BF%E7%94%A8github-action%E8%87%AA%E5%8A%A8%E9%83%A8%E7%BD%B2%E5%8D%9A%E5%AE%A2%E5%88%B0github-pages/">https://tomial.github.io/posts/hugo%E4%BD%BF%E7%94%A8github-action%E8%87%AA%E5%8A%A8%E9%83%A8%E7%BD%B2%E5%8D%9A%E5%AE%A2%E5%88%B0github-pages/&lt;/a>
&lt;a href="https://www.bloghome.com.cn/post/git-zi-mo-kuai-yi-ge-cang-ku-bao-han-ling-yi-ge-cang-ku.html">https://www.bloghome.com.cn/post/git-zi-mo-kuai-yi-ge-cang-ku-bao-han-ling-yi-ge-cang-ku.html&lt;/a>
使用 Hugo 搭建 GitHub Pages &lt;a href="https://zz2summer.github.io/github-pages-hugo-%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/#%E4%B8%83%E6%97%A5%E5%B8%B8%E6%93%8D%E4%BD%9C">https://zz2summer.github.io/github-pages-hugo-%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/#%E4%B8%83%E6%97%A5%E5%B8%B8%E6%93%8D%E4%BD%9C&lt;/a>&lt;/p>
&lt;h2 id="常见问题">常见问题&lt;/h2>
&lt;p>&lt;a href="https://github.com/google/docsy/issues/235">构建站点时出错：# POSTCSS: failed to transform &amp;ldquo;scss/main.css&amp;rdquo;&lt;/a>&lt;/p>
&lt;h1 id="docsy-配置与关联文件">Docsy 配置与关联文件&lt;/h1>
&lt;p>Docsy 也会使用 Hugo 的 CONFIG 文件来配置站点。参考&lt;a href="https://www.docsy.dev/docs/adding-content/">官网，内容和定制&lt;/a>章节来修改 CONFIG 文件，以改变主题样式。&lt;/p></description></item><item><title>Docs: Hyper-V</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/10.%E4%BA%91%E5%8E%9F%E7%94%9F/1.2.%E5%AE%9E%E7%8E%B0%E8%99%9A%E6%8B%9F%E5%8C%96%E7%9A%84%E5%B7%A5%E5%85%B7/%E8%99%9A%E6%8B%9F%E5%8C%96%E7%AE%A1%E7%90%86/hyper-v/hyper-v/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/10.%E4%BA%91%E5%8E%9F%E7%94%9F/1.2.%E5%AE%9E%E7%8E%B0%E8%99%9A%E6%8B%9F%E5%8C%96%E7%9A%84%E5%B7%A5%E5%85%B7/%E8%99%9A%E6%8B%9F%E5%8C%96%E7%AE%A1%E7%90%86/hyper-v/hyper-v/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;h2 id="参考">参考：&lt;/h2>
&lt;/blockquote>
&lt;p>virtmgmt 命令行工具打开图形化的 Hyper-V 图形界面&lt;/p>
&lt;h1 id="关联文件与配置">关联文件与配置&lt;/h1>
&lt;p>&lt;strong>编辑会话设置&lt;/strong> # 用以设置连接信息。基本都是 tsclient 的设置。&lt;/p>
&lt;h1 id="共享">共享&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://learn.microsoft.com/zh-cn/virtualization/hyper-v-on-windows/user-guide/enhanced-session-mode">官方文档-虚拟化，与你的虚拟机共享设备&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>增强会话模式可通过 RDP（远程桌面协议）将 Hyper-V 与虚拟机连接起来。 这不仅会改善你的整体虚拟机查看体验，而且使用 RDP 连接还可以使虚拟机与你的计算机共享设备。 由于 RDP 在 Windows 10 中默认打开，所以与 Windows 虚拟机连接时，你可能已经在使用 RDP。 本文着重介绍了一些好处和连接设置对话框中的隐藏选项。&lt;/p>
&lt;p>RDP/增强会话模式：&lt;/p>
&lt;ul>
&lt;li>使虚拟机实现可调整大小和高 DPI 感知。&lt;/li>
&lt;li>改进虚拟机集成
&lt;ul>
&lt;li>共享的剪贴板&lt;/li>
&lt;li>通过拖放和复制粘贴进行文件共享&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>允许设备共享
&lt;ul>
&lt;li>麦克风/扬声器&lt;/li>
&lt;li>USB 设备&lt;/li>
&lt;li>数据磁盘（包括 C:）&lt;/li>
&lt;li>打印机&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>想要共享宿主机的磁盘，最好的方法是使用 RDP 的 tsclient 功能，效果如下图：&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/0-picgo/20230209155050.png" alt="image.png">&lt;/p>
&lt;h1 id="使用-powershell-模块管理-hyper-v">使用 PowerShell 模块管理 Hyper-V&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://learn.microsoft.com/en-us/powershell/module/hyper-v/index">官方文档-PowerShell，模块-hyper-v&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://learn.microsoft.com/zh-cn/virtualization/hyper-v-on-windows/quick-start/try-hyper-v-powershell">https://learn.microsoft.com/zh-cn/virtualization/hyper-v-on-windows/quick-start/try-hyper-v-powershell&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;h2 id="new-vm">New-VM&lt;/h2>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://learn.microsoft.com/en-us/powershell/module/hyper-v/new-vm">https://learn.microsoft.com/en-us/powershell/module/hyper-v/new-vm&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>创建一个新的虚拟机&lt;/p>
&lt;h2 id="get-vm">Get-VM&lt;/h2>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://learn.microsoft.com/en-us/powershell/module/hyper-v/get-vm">https://learn.microsoft.com/en-us/powershell/module/hyper-v/get-vm&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>从一个或多个 Hyper-V 主机获取虚拟机&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-powershell" data-lang="powershell">&lt;span style="display:flex;">&lt;span>PS ~&amp;gt; get-vm
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Name State CPUUsage(%) MemoryAssigned(M) Uptime Status Version
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>---- ----- ----------- ----------------- ------ ------ -------
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>win10 Off &lt;span style="color:#ae81ff">0&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span> &lt;span style="color:#ae81ff">00&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">:&lt;/span>&lt;span style="color:#ae81ff">00&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">:&lt;/span>&lt;span style="color:#ae81ff">00&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">正常运行&lt;/span> &lt;span style="color:#ae81ff">11.0&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div></description></item><item><title>Docs: Java</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/2.%E7%BC%96%E7%A8%8B/%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/java/java/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/2.%E7%BC%96%E7%A8%8B/%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/java/java/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://www.java.com/">官网&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.liaoxuefeng.com/wiki/1252599548343744/1255876875896416#0">廖雪峰-Java教程，Java简介&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>Java 分三个版本：&lt;/p>
&lt;ul>
&lt;li>Java Standard Edition(标准版，简称 JSE)&lt;/li>
&lt;li>Java Enterprise Edition(企业版，简称 JEE)&lt;/li>
&lt;li>Java Micro Edition(微型版，简称 JME)&lt;/li>
&lt;/ul>
&lt;pre tabindex="0">&lt;code class="language-ascii" data-lang="ascii">┌───────────────────────────┐
│Java EE │
│ ┌────────────────────┐ │
│ │Java SE │ │
│ │ ┌─────────────┐ │ │
│ │ │ Java ME │ │ │
│ │ └─────────────┘ │ │
│ └────────────────────┘ │
└───────────────────────────┘
&lt;/code>&lt;/pre>&lt;h2 id="java-名词">Java 名词&lt;/h2>
&lt;p>JDK # Java Development Kit（Java 开发工具包）&lt;/p>
&lt;p>JRE # Java Runtime Environment（Java 运行时环境）&lt;/p>
&lt;p>JVM # Java Virtual Machin（Java 虚拟机）&lt;/p>
&lt;p>JSR # Java Specification Request（Java 规范）&lt;/p>
&lt;p>JCP # Java Community Process（Java 社区处理）&lt;/p>
&lt;p>JRE 中包含运行 &lt;strong>Java 字节码&lt;/strong> 的 JVM 和 库。但是，我们先要使用 JDK 将 Java 源码编译成 Java 字节码。因此 JDK 除了包含 JRE，还提供了编译器、调试器等开发工具。常说的安装 Java，其实就是指安装 JDK。&lt;/p>
&lt;pre tabindex="0">&lt;code class="language-ascii" data-lang="ascii"> ┌─ ┌──────────────────────────────────┐
│ │ Compiler, debugger, etc. │
│ └──────────────────────────────────┘
JDK ┌─ ┌──────────────────────────────────┐
│ │ │ │
│ JRE │ JVM + Runtime Library │
│ │ │ │
└─ └─ └──────────────────────────────────┘
┌───────┐┌───────┐┌───────┐┌───────┐
│Windows││ Linux ││ macOS ││others │
└───────┘└───────┘└───────┘└───────┘
&lt;/code>&lt;/pre>&lt;h2 id="学习资料">学习资料&lt;/h2>
&lt;p>&lt;a href="https://www.runoob.com/java/java-tutorial.html">菜鸟教程，Java&lt;/a>&lt;/p>
&lt;p>&lt;a href="https://www.liaoxuefeng.com/wiki/1252599548343744">廖雪峰，Java 教程&lt;/a>&lt;/p>
&lt;h2 id="andrioid">Andrioid&lt;/h2>
&lt;p>&lt;a href="https://zhuanlan.zhihu.com/p/340609888">Android与Java的关系&lt;/a>&lt;/p>
&lt;h1 id="hello-world">Hello World&lt;/h1>
&lt;h1 id="java-语言关键字">Java 语言关键字&lt;/h1>
&lt;h1 id="java-语言规范">Java 语言规范&lt;/h1></description></item><item><title>Docs: Java 工具</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/2.%E7%BC%96%E7%A8%8B/%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/java/java%E5%B7%A5%E5%85%B7/java-%E5%B7%A5%E5%85%B7/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/2.%E7%BC%96%E7%A8%8B/%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/java/java%E5%B7%A5%E5%85%B7/java-%E5%B7%A5%E5%85%B7/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;h2 id="参考">参考：&lt;/h2>
&lt;/blockquote>
&lt;h1 id="逆向工具">逆向工具&lt;/h1>
&lt;p>&lt;a href="https://www.jianshu.com/p/040d54a57e33">简书，某App接口逆向过程&lt;/a>&lt;/p>
&lt;h2 id="jadx">Jadx&lt;/h2>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://github.com/skylot/jadx">GitHub 项目，skylot/jadx&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>Jadx 是一个 Dex 到 Java 反编译器。用于从 Android Dex 和 Apk 文件生成 Java 源代码的 CLI 和 GUI 工具&lt;/p>
&lt;blockquote>
&lt;p>注意：请注意，在大多数情况下，jadx 无法100% 地反编译所有代码，因此会出现错误。检查&lt;a href="https://github.com/skylot/jadx/wiki/Troubleshooting-Q&amp;amp;A#decompilation-issues">故障排除指南&lt;/a>以了解解决方法&lt;/p>
&lt;/blockquote></description></item><item><title>Docs: Java 环境安装与使用</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/2.%E7%BC%96%E7%A8%8B/%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/java/java%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8/java%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/2.%E7%BC%96%E7%A8%8B/%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/java/java%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8/java%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://www.liaoxuefeng.com/wiki/1252599548343744/1280507291631649">廖雪峰-Java 教程，安装 JDK&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;h1 id="安装-java">安装 Java&lt;/h1>
&lt;p>安装好的 JavaSE 包含很多可执行程序&lt;/p>
&lt;ul>
&lt;li>java：这个可执行程序其实就是JVM，运行Java程序，就是启动JVM，然后让JVM执行指定的编译后的代码；&lt;/li>
&lt;li>javac：这是Java的编译器，它用于把Java源码文件（以&lt;code>.java&lt;/code>后缀结尾）编译为Java字节码文件（以&lt;code>.class&lt;/code>后缀结尾）；&lt;/li>
&lt;li>jar：用于把一组&lt;code>.class&lt;/code>文件打包成一个&lt;code>.jar&lt;/code>文件，便于发布；&lt;/li>
&lt;li>javadoc：用于从Java源码中自动提取注释并生成文档；&lt;/li>
&lt;li>jdb：Java调试器，用于开发阶段的运行调试。&lt;/li>
&lt;/ul>
&lt;h2 id="windows-安装">Windows 安装&lt;/h2>
&lt;p>从&lt;a href="https://www.oracle.com/java/technologies/downloads/">这里&lt;/a>下载 JavaSE&lt;/p>
&lt;p>解压到指定目录(我通常是在 &lt;code>D:/Tools/Java/jdk-${VERSION}&lt;/code>)，将该目录添加到 JAVA_HOME 环境变量&lt;/p>
&lt;p>将 &lt;code>%JAVA_HOME%/bin&lt;/code> 添加到 PATH 变量中。&lt;/p></description></item><item><title>Docs: Management</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/y.windows-%E7%AE%A1%E7%90%86/windows%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/powershell%E5%86%85%E7%BD%AE%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/management/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/y.windows-%E7%AE%A1%E7%90%86/windows%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/powershell%E5%86%85%E7%BD%AE%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/management/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://learn.microsoft.com/en-us/powershell/module/microsoft.powershell.management">官方文档-PowerShell，模块-Management&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>管理模块可以让我们在 PowerShell 中管理系统中的进程、服务等。&lt;/p>
&lt;h1 id="item-管理工具">Item 管理工具&lt;/h1>
&lt;h2 id="get-childitem">Get-ChildItem&lt;/h2>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://learn.microsoft.com/en-us/powershell/module/microsoft.powershell.management/get-childitem">官方文档-PowerShell，模块-管理-Get-ChildItem&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;h3 id="syntax语法">Syntax(语法)&lt;/h3>
&lt;p>&lt;strong>OPTIONS&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>&lt;strong>-Path &amp;lt;STRING&amp;gt;&lt;/strong> # 指定一个或多个位置的路径，可以使用通配符。&lt;code>默认值：.&lt;/code>&lt;/li>
&lt;/ul>
&lt;h3 id="example">EXAMPLE&lt;/h3>
&lt;p>实现类似 tree 命令的效果&lt;/p>
&lt;ul>
&lt;li>Get-ChildItem -Path D:/Tools -Recurse -Depth 2 | Select-Object FullName&lt;/li>
&lt;/ul>
&lt;h1 id="服务管理工具">服务管理工具&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://learn.microsoft.com/en-us/powershell/scripting/samples/managing-services">官方文档，PowerShell-脚本示例-管理进程和服务-管理服务&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://learn.microsoft.com/zh-cn/dotnet/framework/windows-services/">官方文档，.Net-开发 Windows 服务应用&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;h2 id="启动停止重启暂停服务">启动、停止、重启、暂停服务&lt;/h2>
&lt;ul>
&lt;li>Start-Service # 启动服务&lt;/li>
&lt;li>Stop-Service # 停止服务&lt;/li>
&lt;li>Suspend-Service # 暂停服务&lt;/li>
&lt;li>Resume-Service # 恢复服务&lt;/li>
&lt;li>Restart-Service # 重启服务&lt;/li>
&lt;/ul>
&lt;h2 id="get-service">Get-Service&lt;/h2>
&lt;p>列出服务。Get-Service 获取代表计算机上服务的对象，包括正在运行和已停止的服务。默认情况下，当不带参数运行 Get-Service 时，将返回本地计算机的所有服务。&lt;/p>
&lt;p>可以通过指定服务名称或服务的显示名称来指示此 cmdlet 仅获取特定服务，或者您可以将服务对象通过管道传递给此 cmdlet。&lt;/p>
&lt;p>默认显示三个字段&lt;/p>
&lt;ul>
&lt;li>Status # 服务状态&lt;/li>
&lt;li>Name # 服务名称&lt;/li>
&lt;li>DisplayName # 服务的显示名称&lt;/li>
&lt;/ul>
&lt;p>服务名称与显示名称可以在窗口页面看到效果，显示名称有点类似于简短的描述信息。&lt;/p>
&lt;h3 id="syntax语法-1">Syntax(语法)&lt;/h3>
&lt;p>Get-Service [OPTIONS] [-Name] &amp;lt;PATTERN&amp;gt;&lt;/p>
&lt;p>PATTERN 支持通配符，前面的 -Name 可以省略，该命令默认通过&lt;strong>服务名称&lt;/strong>进行匹配，将会列出所有匹配到的服务。&lt;/p>
&lt;p>OPTIONS&lt;/p>
&lt;ul>
&lt;li>&lt;strong>-DependentServices&lt;/strong> # 列出指定服务&lt;strong>被哪些服务依赖&lt;/strong>。&lt;/li>
&lt;li>&lt;strong>-RequiredServices&lt;/strong> # 列出指定服务&lt;strong>依赖于哪些服务&lt;/strong>。即.若想该服务正常运行则必须要提前运行的其他服务&lt;/li>
&lt;li>&lt;strong>-Include &amp;lt;String[]&amp;gt;&lt;/strong> #&lt;/li>
&lt;li>&lt;strong>-Exclude &amp;lt;String[]&amp;gt;&lt;/strong> #&lt;/li>
&lt;/ul>
&lt;h3 id="example-1">EXAMPLE&lt;/h3>
&lt;p>列出服务名 s 开头的所有服务并按照状态排序&lt;/p>
&lt;ul>
&lt;li>Get-Service &amp;ldquo;s*&amp;rdquo; | Sort-Object status&lt;/li>
&lt;/ul>
&lt;h2 id="new-service">New-Service&lt;/h2>
&lt;p>创建服务&lt;/p>
&lt;h2 id="remove-service">Remove-Service&lt;/h2>
&lt;p>移除服务&lt;/p>
&lt;h2 id="set-service">Set-Service&lt;/h2>
&lt;p>设置服务&lt;/p>
&lt;h1 id="进程管理工具">进程管理工具&lt;/h1>
&lt;p>&lt;a href="https://learn.microsoft.com/en-us/powershell/module/microsoft.powershell.management/get-process?view=powershell-7.3">Get-Process&lt;/a>
&lt;a href="https://learn.microsoft.com/en-us/powershell/module/microsoft.powershell.management/start-process?view=powershell-7.3">Start-Process&lt;/a>
&lt;a href="https://learn.microsoft.com/en-us/powershell/module/microsoft.powershell.management/stop-process?view=powershell-7.3">Stop-Process&lt;/a>
&lt;a href="https://learn.microsoft.com/en-us/powershell/module/microsoft.powershell.management/wait-process?view=powershell-7.3">Wait-Process&lt;/a>&lt;/p>
&lt;p>&lt;a href="https://learn.microsoft.com/en-us/powershell/module/microsoft.powershell.management/debug-process?view=powershell-7.3">Debug-Process&lt;/a>&lt;/p></description></item><item><title>Docs: Markdown</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%AE%9E%E7%94%A8%E5%B7%A5%E5%85%B7/%E5%86%99%E4%BD%9C/markdown/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%AE%9E%E7%94%A8%E5%B7%A5%E5%85%B7/%E5%86%99%E4%BD%9C/markdown/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;h2 id="参考">参考：&lt;/h2>
&lt;/blockquote>
&lt;h1 id="markdown-中的-latex-数学公式">Markdown 中的 LaTex 数学公式&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://blog.ypingcn.com/notes/Markdown/LaTex-math/">https://blog.ypingcn.com/notes/Markdown/LaTex-math/&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.jianshu.com/p/e74eb43960a1">简书，Markdown 数学公式语法&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>&lt;a href="https://blog.ypingcn.com/notes/Markdown/basic/">基础的 Markdown 语法&lt;/a> 中无法满足数学式子的表达需求，此时可以借助 Latex 语法完成。在 Markdown 中由前后两个 &lt;code>$$&lt;/code>包围的部分可以写 LaTex 源代码（最新版 Typora 已经支持）如下&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-markdown" data-lang="markdown">&lt;span style="display:flex;">&lt;span>$$
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>LaTex code
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>$$
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="速查">速查&lt;/h2>
&lt;p>Markdown 中 Latex 基本符号速查表&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>显示字符&lt;/th>
&lt;th>输入字符&lt;/th>
&lt;th>显示字符&lt;/th>
&lt;th>输入字符&lt;/th>
&lt;th>显示字符&lt;/th>
&lt;th>输入字符&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>&lt;code>#&lt;/code>&lt;/td>
&lt;td>&lt;code>\\#&lt;/code>&lt;/td>
&lt;td>&lt;code>$&lt;/code>&lt;/td>
&lt;td>&lt;code>\\$&lt;/code>&lt;/td>
&lt;td>&lt;code>%&lt;/code>&lt;/td>
&lt;td>&lt;code>\\%&lt;/code>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>&amp;amp;&lt;/code>&lt;/td>
&lt;td>&lt;code>\\&amp;amp;&lt;/code>&lt;/td>
&lt;td>&lt;code>~&lt;/code>&lt;/td>
&lt;td>&lt;code>\\~&lt;/code>&lt;/td>
&lt;td>&lt;code>_&lt;/code>&lt;/td>
&lt;td>&lt;code>\\_&lt;/code>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>^&lt;/code>&lt;/td>
&lt;td>&lt;code>\\^&lt;/code>&lt;/td>
&lt;td>&lt;code>\\&lt;/code>&lt;/td>
&lt;td>&lt;code>\\\\&lt;/code>&lt;/td>
&lt;td>&lt;code>{&lt;/code>&lt;/td>
&lt;td>&lt;code>\\{&lt;/code>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>}&lt;/code>&lt;/td>
&lt;td>&lt;code>\\}&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>≤&lt;/td>
&lt;td>&lt;code>\\le&lt;/code>&lt;/td>
&lt;td>≥&lt;/td>
&lt;td>&lt;code>\\ge&lt;/code>&lt;/td>
&lt;td>≡&lt;/td>
&lt;td>&lt;code>\\equiv&lt;/code>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>≠&lt;/td>
&lt;td>&lt;code>\\ne&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>文本底线对齐的省略号&lt;/td>
&lt;td>&lt;code>\\ldots&lt;/code>&lt;/td>
&lt;td>文本中对齐的省略号&lt;/td>
&lt;td>&lt;code>\\cdots&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>圆括号&lt;/td>
&lt;td>&lt;code>()&lt;/code>&lt;/td>
&lt;td>方括号&lt;/td>
&lt;td>&lt;code>[]&lt;/code>&lt;/td>
&lt;td>竖线&lt;/td>
&lt;td>&lt;code>&amp;amp;#124;&lt;/code>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>花括号&lt;/td>
&lt;td>&lt;code>\\{\\}&lt;/code>&lt;/td>
&lt;td>双竖线&lt;/td>
&lt;td>&lt;code>\\&amp;amp;#124;&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>长圆括号&lt;/td>
&lt;td>&lt;code>\\left( \\right)&lt;/code>&lt;/td>
&lt;td>长方括号&lt;/td>
&lt;td>&lt;code>\\left[ \\right]&lt;/code>&lt;/td>
&lt;td>长花括号&lt;/td>
&lt;td>&lt;code>\\left\\{ \\right\\}&lt;/code>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>换行&lt;/td>
&lt;td>&lt;code>\\\\&lt;/code>&lt;/td>
&lt;td>空格&lt;/td>
&lt;td>&lt;code>\\space&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>←&lt;/td>
&lt;td>&lt;code>\\leftarrow&lt;/code>&lt;/td>
&lt;td>→&lt;/td>
&lt;td>&lt;code>\\rightarrow&lt;/code>&lt;/td>
&lt;td>文字&lt;/td>
&lt;td>&lt;code>\\mbox{ }&lt;/code>&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;hr>
&lt;h2 id="字符相关">字符相关&lt;/h2>
&lt;h3 id="字符">&lt;strong>字符&lt;/strong>&lt;/h3>
&lt;p>插入 &lt;code># $ % &amp;amp; ~ _ ^ \ { }&lt;/code> 需多加 &lt;code>\&lt;/code> 符号（类似于 C 语言中的转义字符），其他可以直接插入。&lt;/p>
&lt;p>&lt;code>\\&lt;/code> 对应换行符 ，&lt;code>\space&lt;/code> 对应空格。&lt;/p>
&lt;p>小于等于、大于等于、恒等于、不等于分别为 &lt;code>\le \ge \equiv \ne&lt;/code> （ l 意为 less ，e 意为 equal ，g 意为 greater ）&lt;/p>
&lt;h3 id="省略号">&lt;strong>省略号&lt;/strong>&lt;/h3>
&lt;p>&lt;code>\ldots \cdots&lt;/code> 分别表示与文本底线对齐和与文本中对齐的省略号。（l 意为 line ，c 意为 center ）&lt;/p>
&lt;h3 id="括号">&lt;strong>括号&lt;/strong>&lt;/h3>
&lt;p>圆括号、方括号和竖线直接输入，花括号前需添加 &lt;code>\&lt;/code> ，双竖线对应&lt;code>\|&lt;/code> 。&lt;/p>
&lt;p>长圆括号、长方括号、长花括号对应&lt;code>\left( \right)&lt;/code> &lt;code>\left[ \right]&lt;/code> &lt;code>\left\{ \right\}&lt;/code>&lt;/p>
&lt;h3 id="箭头">&lt;strong>箭头&lt;/strong>&lt;/h3>
&lt;p>左右箭头对应 &lt;code>\leftarrow \rightarrow&lt;/code>&lt;/p>
&lt;h3 id="插入文字">&lt;strong>插入文字&lt;/strong>&lt;/h3>
&lt;p>&lt;code>\mbox{ }&lt;/code> 用于插入文字（显示效果不是斜体字） 。&lt;/p>
&lt;hr>
&lt;h2 id="数学式子">数学式子&lt;/h2>
&lt;h3 id="标准函数">&lt;strong>标准函数&lt;/strong>&lt;/h3>
&lt;p>欲输入 &lt;code>sin&lt;/code> 时，应用&lt;code>\sin(x)&lt;/code>。&lt;/p>
&lt;h3 id="分数">&lt;strong>分数&lt;/strong>&lt;/h3>
&lt;p>二分之一对于 &lt;code>\frac{1}{2}&lt;/code>&lt;/p>
&lt;h3 id="根号">&lt;strong>根号&lt;/strong>&lt;/h3>
&lt;p>根号二对应 &lt;code>\sqrt{2}&lt;/code> ，开 n 次方为&lt;code>\sqrt[n]{expression}&lt;/code>&lt;/p>
&lt;h3 id="导数-偏导数">&lt;strong>导数 偏导数&lt;/strong>&lt;/h3>
&lt;p>对 x 导数对应 &lt;code>\mathrm{d}x&lt;/code>&lt;/p>
&lt;p>对 x 的偏导数对应&lt;code>\partial x&lt;/code>&lt;/p>
&lt;h3 id="积分">&lt;strong>积分&lt;/strong>&lt;/h3>
&lt;p>f(x) 对 x 从 a 到 b 的积分 &lt;code>\int_a^b f(x) \mathrm{d}x&lt;/code> ， 多重积分则多次输入 &lt;code>\int&lt;/code> ，两个符号之间添加 &lt;code>\!\!\!&lt;/code> 调整正确的间隔。&lt;/p>
&lt;h3 id="极限">&lt;strong>极限&lt;/strong>&lt;/h3>
&lt;p>x 到正无穷的极限 &lt;code>\lim_{x\to+\infty}&lt;/code>&lt;/p>
&lt;h3 id="求和">&lt;strong>求和&lt;/strong>&lt;/h3>
&lt;p>1 到 n 的和对应 &lt;code>\sum_{1}^{n}&lt;/code>&lt;/p>
&lt;h3 id="向量">&lt;strong>向量&lt;/strong>&lt;/h3>
&lt;p>向量 ab 对应 &lt;code>\vec{ab}&lt;/code>&lt;/p>
&lt;h3 id="排列组合">&lt;strong>排列组合&lt;/strong>&lt;/h3>
&lt;p>从 n 中选 m 的组合数和排列数为 &lt;code>\mathrm{C}_n^m \mathrm{A}_n^m&lt;/code>&lt;/p>
&lt;p>&lt;a href="#1">具体内容参见文末参考资料&lt;/a>。&lt;/p>
&lt;hr>
&lt;h2 id="上下标与希腊字母">上下标与希腊字母&lt;/h2>
&lt;p>&lt;code>^&lt;/code> 表示上标 &lt;code>_&lt;/code>表示下标，同时出现上下标时，先上标后下标与先下标后上标的效果相同。&lt;/p>
&lt;p>用 &lt;code>\&lt;/code> 加相应的拼写即可，第一个字母大写则显示大写字母，小写则显示小写字母。&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>输入&lt;/th>
&lt;th>展示&lt;/th>
&lt;th>输入&lt;/th>
&lt;th>展示&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>\alpha&lt;/td>
&lt;td>α&lt;/td>
&lt;td>\beta&lt;/td>
&lt;td>β&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>\gamma&lt;/td>
&lt;td>γ&lt;/td>
&lt;td>\Gamma&lt;/td>
&lt;td>Γ&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>\theta&lt;/td>
&lt;td>θ&lt;/td>
&lt;td>\Theta&lt;/td>
&lt;td>Θ&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>\delta&lt;/td>
&lt;td>δ&lt;/td>
&lt;td>\Delta&lt;/td>
&lt;td>Δ&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>\triangledown&lt;/td>
&lt;td>▽&lt;/td>
&lt;td>\epsilon&lt;/td>
&lt;td>ϵ&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>\zeta&lt;/td>
&lt;td>ζ&lt;/td>
&lt;td>\eta&lt;/td>
&lt;td>η&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>\kappa&lt;/td>
&lt;td>κ&lt;/td>
&lt;td>\lambda&lt;/td>
&lt;td>λ&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>\mu&lt;/td>
&lt;td>μ&lt;/td>
&lt;td>\nu&lt;/td>
&lt;td>ν&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>\xi&lt;/td>
&lt;td>ξ&lt;/td>
&lt;td>\pi&lt;/td>
&lt;td>π&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>\sigma&lt;/td>
&lt;td>σ&lt;/td>
&lt;td>\tau&lt;/td>
&lt;td>τ&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>\upsilon&lt;/td>
&lt;td>υ&lt;/td>
&lt;td>\phi&lt;/td>
&lt;td>ϕ&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>\omega&lt;/td>
&lt;td>ω&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;hr>
&lt;h2 id="多行的数学公式">多行的数学公式&lt;/h2>
&lt;p>例子&lt;/p>
&lt;pre>&lt;code>\begin{eqnarray}
\cos 2\theta &amp;amp; = &amp;amp; \cos^2 \theta - \sin^2 \theta \\
&amp;amp; = &amp;amp; 2 \cos^2 \theta - 1.
\end{eqnarray}
&lt;/code>&lt;/pre>
&lt;p>&amp;amp; 是对齐点，具体例子中表示多行式子在等号之间对齐。&lt;/p>
&lt;pre>&lt;code>f(n) =
\begin{cases}
n+1, &amp;amp; \mbox{if }n \mbox{ is even} \\
n-1, &amp;amp; \mbox{if }n \mbox{ is odd}
\end{cases}
&lt;/code>&lt;/pre>
&lt;p>条件定义式。奇数加一，偶数减一。&lt;/p>
&lt;hr>
&lt;h2 id="矩阵">矩阵&lt;/h2>
&lt;p>例子&lt;/p>
&lt;pre>&lt;code>\begin{array}{ccc}
a &amp;amp; b &amp;amp; c \\
d &amp;amp; e &amp;amp; f \\
g &amp;amp; h &amp;amp; i
\end{array}
&lt;/code>&lt;/pre>
&lt;p>表示 3 x 3 的矩阵，c 表示居中对齐，l 是左对齐，r 是右对齐。&lt;/p>
&lt;hr>
&lt;p>参考资料 ：&lt;/p>
&lt;p>#1 &lt;a href="https://zh.wikipedia.org/wiki/Help:%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8F">帮助:数学公式 - 维基百科，自由的百科全书&lt;/a>&lt;/p>
&lt;p>#2 &lt;a href="https://zh.wikibooks.org/wiki/LaTeX/%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8F">LaTeX/数学公式 - 维基教科书，自由的教学读本&lt;/a>&lt;/p></description></item><item><title>Docs: MicrosoftVisualC++</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/y.windows-%E7%AE%A1%E7%90%86/%E4%BE%9D%E8%B5%96%E5%BA%93/microsoftvisualc++/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/y.windows-%E7%AE%A1%E7%90%86/%E4%BE%9D%E8%B5%96%E5%BA%93/microsoftvisualc++/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;h2 id="参考">参考：&lt;/h2>
&lt;/blockquote>
&lt;p>Microsoft Visual C++ Redistributable(简称 vsredist)，&lt;/p></description></item><item><title>Docs: OpenAI</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/12.%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/openai/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/12.%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/openai/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://openai.com/">官网&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;h1 id="api">API&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://platform.openai.com/docs/api-reference/introduction">官方文档，API 参考&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;h1 id="chatgpt">ChatGPT&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://github.com/wangrongding/wechat-bot">https://github.com/wangrongding/wechat-bot&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://github.com/fuergaosi233/wechat-chatgpt">https://github.com/fuergaosi233/wechat-chatgpt&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://zblogs.top/how-to-register-openai-chatgpt-in-china">https://zblogs.top/how-to-register-openai-chatgpt-in-china&lt;/a>
&lt;ul>
&lt;li>注册 ChatGPT 教程&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>使用虚拟号码接收短信验证码：https://sms-activate.org/&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>上下文联系功能说明&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/0-picgo/20230204001925.png" alt="image.png">&lt;/p>
&lt;h2 id="基于-chatgpt-的项目">基于 ChatGPT 的项目&lt;/h2>
&lt;p>Chrom 插件&lt;/p>
&lt;p>&lt;a href="https://github.com/wong2/chat-gpt-google-extension">https://github.com/wong2/chat-gpt-google-extension&lt;/a>&lt;/p>
&lt;p>&lt;a href="https://github.com/gragland/chatgpt-chrome-extension">https://github.com/gragland/chatgpt-chrome-extension&lt;/a>&lt;/p>
&lt;p>逆向&lt;/p>
&lt;p>&lt;a href="https://github.com/acheong08/ChatGPT">https://github.com/acheong08/ChatGPT&lt;/a>&lt;/p>
&lt;p>微信接入&lt;/p>
&lt;p>&lt;a href="https://github.com/fuergaosi233/wechat-chatgpt">https://github.com/fuergaosi233/wechat-chatgpt&lt;/a>&lt;/p>
&lt;ul>
&lt;li>用法：&lt;a href="https://mp.weixin.qq.com/s/dLzemMUcIfjvWd_AF_yDJw">https://mp.weixin.qq.com/s/dLzemMUcIfjvWd_AF_yDJw&lt;/a>&lt;/li>
&lt;/ul>
&lt;p>&lt;a href="https://github.com/AutumnWhj/ChatGPT-wechat-bot">https://github.com/AutumnWhj/ChatGPT-wechat-bot&lt;/a>&lt;/p>
&lt;p>接入 GitLab&lt;/p>
&lt;p>&lt;a href="https://mp.weixin.qq.com/s/y_ppQdKVXWZPNyP9BxGWpg">https://mp.weixin.qq.com/s/y_ppQdKVXWZPNyP9BxGWpg&lt;/a>&lt;/p></description></item><item><title>Docs: OpenCV</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/12.%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89/opencv/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/12.%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89/opencv/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://github.com/opencv/opencv">GitHub 项目，opencv/opencv&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://opencv.org/">官网&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://docs.opencv.org/">官方文档&lt;/a>，从左侧 Nightly 中选择想要查看的版本&lt;/li>
&lt;li>&lt;a href="https://zhuanlan.zhihu.com/p/115321759">https://zhuanlan.zhihu.com/p/115321759&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.jiqizhixin.com/articles/2019-03-22-10">手把手教你使用OpenCV库（附实例、Python代码解析）&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>&lt;strong>Open Source Computer Vision Library(开源计算机视觉库，简称 OpenCV)&lt;/strong> 是一个包含数百种计算机视觉算法的开源库。&lt;/p>
&lt;p>官方提供了 Python 语言的 OpenCV 接口~~~在官方这没找到其他语言的&lt;/p></description></item><item><title>Docs: Plugin 配置</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/10.%E4%BA%91%E5%8E%9F%E7%94%9F/2.2.%E5%AE%9E%E7%8E%B0%E5%AE%B9%E5%99%A8%E7%9A%84%E5%B7%A5%E5%85%B7/containerd/containerd-%E9%85%8D%E7%BD%AE%E8%AF%A6%E8%A7%A3/plugin-%E9%85%8D%E7%BD%AE/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/10.%E4%BA%91%E5%8E%9F%E7%94%9F/2.2.%E5%AE%9E%E7%8E%B0%E5%AE%B9%E5%99%A8%E7%9A%84%E5%B7%A5%E5%85%B7/containerd/containerd-%E9%85%8D%E7%BD%AE%E8%AF%A6%E8%A7%A3/plugin-%E9%85%8D%E7%BD%AE/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://github.com/containerd/containerd/blob/main/docs/PLUGINS.md">GitHub 项目文档，containerd/docs/PLUGINS.md&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;h2 id="本篇笔记的记录格式">本篇笔记的记录格式&lt;/h2>
&lt;p>Containerd 在 TOML 配置文件中，通过 TOML 表的方式来描述一个插件及其具有的功能，效果如下：&lt;/p>
&lt;ul>
&lt;li>&lt;code>[plugins.&amp;quot;PLUGIN&amp;quot;]&lt;/code>
&lt;ul>
&lt;li>PLUGIN = TYPE.ID&lt;/li>
&lt;li>TYPE = io.containerd.NAME.VERSION&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>所以，一个完整描述插件功能的的 TOML 表应该是这样的：&lt;/p>
&lt;ul>
&lt;li>&lt;code>[plugins.&amp;quot;io.containerd.NAME.VERSION.NAME&amp;quot;.NAME....]&lt;/code>&lt;/li>
&lt;/ul>
&lt;p>这篇笔记在记录时，则省略前面的通用字符串(&lt;code>plugins.&amp;quot;io.containerd.&lt;/code>)，只以最后的关键字来描述，以获得更好的阅读效果。&lt;/p>
&lt;p>比如下文中标题一的 &lt;code>[grpc.v1.cri]&lt;/code> 下的标题二的 &lt;code>[registry]&lt;/code> 下的标题三的 &lt;code>[mirrors]&lt;/code>下的 &lt;code>docker.io&lt;/code> 镜像仓库的镜像配置，反应到配置文件中，就是这样的：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-toml" data-lang="toml">&lt;span style="display:flex;">&lt;span>[&lt;span style="color:#a6e22e">plugins&lt;/span>]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> [&lt;span style="color:#a6e22e">plugins&lt;/span>.&lt;span style="color:#e6db74">&amp;#34;io.containerd.grpc.v1.cri&amp;#34;&lt;/span>]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> [&lt;span style="color:#a6e22e">plugins&lt;/span>.&lt;span style="color:#e6db74">&amp;#34;io.containerd.grpc.v1.cri&amp;#34;&lt;/span>.&lt;span style="color:#a6e22e">registry&lt;/span>]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> [&lt;span style="color:#a6e22e">plugins&lt;/span>.&lt;span style="color:#e6db74">&amp;#34;io.containerd.grpc.v1.cri&amp;#34;&lt;/span>.&lt;span style="color:#a6e22e">registry&lt;/span>.&lt;span style="color:#a6e22e">mirrors&lt;/span>]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> [&lt;span style="color:#a6e22e">plugins&lt;/span>.&lt;span style="color:#e6db74">&amp;#34;io.containerd.grpc.v1.cri&amp;#34;&lt;/span>.&lt;span style="color:#a6e22e">registry&lt;/span>.&lt;span style="color:#a6e22e">mirrors&lt;/span>.&lt;span style="color:#e6db74">&amp;#34;docker.io&amp;#34;&lt;/span>]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">endpoint&lt;/span> = [&lt;span style="color:#e6db74">&amp;#34;https://ac1rmo5p.mirror.aliyuncs.com&amp;#34;&lt;/span>]
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>带 &lt;code>[]&lt;/code> 的都是一个一个的表，表只是用来进行分组，表中的每一个 &lt;code>键值对&lt;/code> 才是真实的配置。&lt;/p>
&lt;h1 id="gcv1scheduler--调度器插件">[gc.v1.scheduler] # 调度器插件&lt;/h1>
&lt;h1 id="grpcv1cri--cri-插件">[grpc.v1.cri] # CRI 插件&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://github.com/containerd/containerd/tree/main/docs/cri">GitHub 项目文档，containerd/docs/cri&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://github.com/containerd/containerd/blob/main/docs/cri/config.md">GitHub 项目文档，containerd/docs/cri/config.md-CRI 插件配置指南&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>注意：&lt;/p>
&lt;blockquote>
&lt;ul>
&lt;li>CRI 插件是当 Containerd 作为 CRI 时所使用的配置，所以 ctr、nerdctl 工具在执行某些命令时，有可能不会调用这些配置，就比如其中的 registry 配置，就算配置了，ctr pull 和 nerdctl pull 命令也无法享受到效果。但是使用 crictl 命令是没问题的。&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>&lt;strong>sanbox_image = &lt;!-- raw HTML omitted -->&lt;/strong> # 启动 Pod 时要使用的 Infra 容器。&lt;code>默认值：k8s.gcr.io/pause:X.X&lt;/code>。这个默认值会根据当前 Containerd 的版本而改变。&lt;/p>
&lt;h2 id="cni--cni-配置">[cni] # CNI 配置&lt;/h2>
&lt;p>&lt;strong>bin_dir = &lt;!-- raw HTML omitted -->&lt;/strong> # CNI 二进制文件的目录 &lt;code>默认值：/opt/cni/bin&lt;/code>
**conf_dir = &lt;!-- raw HTML omitted --> **# CNI 配置文件的目录&lt;code>默认值：/etc/cni/net.d&lt;/code>&lt;/p>
&lt;h2 id="containerd--containerd-运行时配置">[containerd] # Containerd 运行时配置&lt;/h2>
&lt;p>&lt;strong>defautl_runtime_name = &lt;!-- raw HTML omitted -->&lt;/strong> # containerd 进程工作时所调用的 runtime。&lt;code>默认值：runc&lt;/code>&lt;/p>
&lt;h3 id="runtimesrunc--当-containerd-使用-runc-作为运行时生效的配置">[runtimes.runc] # 当 Containerd 使用 runc 作为运行时生效的配置&lt;/h3>
&lt;p>&lt;strong>cni_conf_dir = &lt;!-- raw HTML omitted -->&lt;/strong> # 特定于 runc 作为 runtime 时，所使用的 CNI 配置文件目录
&lt;strong>runtime_type = &lt;!-- raw HTML omitted -->&lt;/strong> # 在 containerd 中要使用的 runtime 类型 &lt;code>默认值：io.containerd.runc.v2&lt;/code>&lt;/p>
&lt;h4 id="options">[options]&lt;/h4>
&lt;p>&lt;strong>SystemdCgroup = &lt;!-- raw HTML omitted -->&lt;/strong> # 是否使用 systemd cgroup。&lt;code>默认值：false&lt;/code>&lt;/p>
&lt;h2 id="image_decryption">[image_decryption]&lt;/h2>
&lt;h2 id="registry--访问镜像注册中心时的配置">[registry] # 访问镜像注册中心时的配置&lt;/h2>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://github.com/containerd/containerd/blob/main/docs/hosts.md">GitHub 项目文档，containerd/docs/hosts.md&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>注意：从 Containerd 1.4 版本开始出现的 &lt;code>registry.configs&lt;/code> 与 &lt;code>registry.mirrors&lt;/code> 现在(2021 年 4 月)已弃用，只有在未指定 &lt;code>config_path&lt;/code> 时才会生效&lt;/p>
&lt;p>&lt;strong>config_path = &lt;!-- raw HTML omitted -->&lt;/strong> # 指定一个目录来引用镜像注册中心的配置&lt;code>默认值：空&lt;/code>
该目录的格式应该为：&lt;code>STRING/REGISTRY/hosts.toml&lt;/code>，也就是说，以镜像注册中心的域名作为目录的名称，且目录下的文件名为 &lt;code>hosts.toml&lt;/code>&lt;/p>
&lt;p>假如现在有如下配置：&lt;code>config_path = &amp;quot;/etc/containerd/registry.d&amp;quot;&lt;/code>，那么 registry.d 目录下的结构应该是下面这样的：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>$ tree /etc/containerd/registry.d
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>/etc/containerd/registry.d
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>└── docker.io
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> └── hosts.toml
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>$ cat /etc/containerd/registry.d/docker.io/hosts.toml
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>server &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#34;https://docker.io&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">[&lt;/span>host.&lt;span style="color:#e6db74">&amp;#34;https://registry-1.docker.io&amp;#34;&lt;/span>&lt;span style="color:#f92672">]&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> capabilities &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#f92672">[&lt;/span>&lt;span style="color:#e6db74">&amp;#34;pull&amp;#34;&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;resolve&amp;#34;&lt;/span>&lt;span style="color:#f92672">]&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="configs--镜像注册中心的通用配置">[configs] # 镜像注册中心的通用配置&lt;/h3>
&lt;p>&lt;strong>[REGISTRY]&lt;/strong> # 访问 REGISTRY 镜像仓库时的配置。说白了就是发起 HTTP 请求时要设置的那些东西。&lt;/p>
&lt;ul>
&lt;li>&lt;strong>[tls]&lt;/strong> # TLS 配置
&lt;ul>
&lt;li>&lt;strong>insecure_skip_verify = &lt;!-- raw HTML omitted -->&lt;/strong> # 访问镜像仓库时是否跳过证书验证。&lt;code>默认值：false&lt;/code>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>[auth]&lt;/strong> # 发起 HTTP 请求时要使用的认证方式
&lt;ul>
&lt;li>&lt;strong>username = &lt;!-- raw HTML omitted -->&lt;/strong> # 访问镜像仓库的用户名&lt;/li>
&lt;li>&lt;strong>password = &lt;!-- raw HTML omitted -->&lt;/strong> # 访问镜像仓库的密码&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h3 id="mirrors--镜像注册中心的-mirrors-配置">[mirrors] # 镜像注册中心的 mirrors 配置&lt;/h3>
&lt;p>&lt;strong>[REGISTRY]&lt;/strong> # 为指定的 REGISTRY 镜像仓库配置 mirrors。例如，&lt;code>[略.registry.mirrors.&amp;quot;docker.io&amp;quot;]&lt;/code> 表示配置 docker.io 的 mirror。&lt;/p>
&lt;ul>
&lt;li>&lt;strong>endpoint = &amp;lt;[]STRING&amp;gt;&lt;/strong> # 表示为 REGISTRY 提供 mirror 的镜像加速服务，是一个数组，可以使用多个镜像加速配置&lt;/li>
&lt;/ul>
&lt;h3 id="注册中心配置">注册中心配置&lt;/h3>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://github.com/containerd/containerd/blob/main/docs/hosts.md">GitHub 项目文档，containerd/containerd/docs/hosts.md&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;h3 id="配置示例">配置示例&lt;/h3>
&lt;p>配置镜像加速
原始&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-toml" data-lang="toml">&lt;span style="display:flex;">&lt;span> [&lt;span style="color:#a6e22e">plugins&lt;/span>.&lt;span style="color:#e6db74">&amp;#34;io.containerd.grpc.v1.cri&amp;#34;&lt;/span>.&lt;span style="color:#a6e22e">registry&lt;/span>]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> [&lt;span style="color:#a6e22e">plugins&lt;/span>.&lt;span style="color:#e6db74">&amp;#34;io.containerd.grpc.v1.cri&amp;#34;&lt;/span>.&lt;span style="color:#a6e22e">registry&lt;/span>.&lt;span style="color:#a6e22e">mirrors&lt;/span>]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> [&lt;span style="color:#a6e22e">plugins&lt;/span>.&lt;span style="color:#e6db74">&amp;#34;io.containerd.grpc.v1.cri&amp;#34;&lt;/span>.&lt;span style="color:#a6e22e">registry&lt;/span>.&lt;span style="color:#a6e22e">mirrors&lt;/span>.&lt;span style="color:#e6db74">&amp;#34;docker.io&amp;#34;&lt;/span>]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">endpoint&lt;/span> = [&lt;span style="color:#e6db74">&amp;#34;https://registry-1.docker.io&amp;#34;&lt;/span>]
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>hosts.toml 这种配置好像不生效，带验证&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>~&lt;span style="color:#f92672">]&lt;/span>&lt;span style="color:#75715e"># cat registry.d/docker.io/hosts.toml&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>server &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#34;https://docker.io&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">[&lt;/span>host.&lt;span style="color:#e6db74">&amp;#34;https://ac1rmo5p.mirror.aliyuncs.com&amp;#34;&lt;/span>&lt;span style="color:#f92672">]&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> capabilities &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#f92672">[&lt;/span>&lt;span style="color:#e6db74">&amp;#34;pull&amp;#34;&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;resolve&amp;#34;&lt;/span>&lt;span style="color:#f92672">]&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>配置私有镜像仓库
原始&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-toml" data-lang="toml">&lt;span style="display:flex;">&lt;span> [&lt;span style="color:#a6e22e">plugins&lt;/span>.&lt;span style="color:#e6db74">&amp;#34;io.containerd.grpc.v1.cri&amp;#34;&lt;/span>.&lt;span style="color:#a6e22e">registry&lt;/span>]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> [&lt;span style="color:#a6e22e">plugins&lt;/span>.&lt;span style="color:#e6db74">&amp;#34;io.containerd.grpc.v1.cri&amp;#34;&lt;/span>.&lt;span style="color:#a6e22e">registry&lt;/span>.&lt;span style="color:#a6e22e">mirrors&lt;/span>]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> [&lt;span style="color:#a6e22e">plugins&lt;/span>.&lt;span style="color:#e6db74">&amp;#34;io.containerd.grpc.v1.cri&amp;#34;&lt;/span>.&lt;span style="color:#a6e22e">registry&lt;/span>.&lt;span style="color:#a6e22e">mirrors&lt;/span>.&lt;span style="color:#e6db74">&amp;#34;192.168.0.250&amp;#34;&lt;/span>]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">endpoint&lt;/span> = [&lt;span style="color:#e6db74">&amp;#34;https://192.168.0.250&amp;#34;&lt;/span>]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> [&lt;span style="color:#a6e22e">plugins&lt;/span>.&lt;span style="color:#e6db74">&amp;#34;io.containerd.grpc.v1.cri&amp;#34;&lt;/span>.&lt;span style="color:#a6e22e">registry&lt;/span>.&lt;span style="color:#a6e22e">configs&lt;/span>]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> [&lt;span style="color:#a6e22e">plugins&lt;/span>.&lt;span style="color:#e6db74">&amp;#34;io.containerd.grpc.v1.cri&amp;#34;&lt;/span>.&lt;span style="color:#a6e22e">registry&lt;/span>.&lt;span style="color:#a6e22e">configs&lt;/span>.&lt;span style="color:#e6db74">&amp;#34;192.168.0.250&amp;#34;&lt;/span>.&lt;span style="color:#a6e22e">tls&lt;/span>]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">insecure_skip_verify&lt;/span> = &lt;span style="color:#66d9ef">true&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> [&lt;span style="color:#a6e22e">plugins&lt;/span>.&lt;span style="color:#e6db74">&amp;#34;io.containerd.grpc.v1.cri&amp;#34;&lt;/span>.&lt;span style="color:#a6e22e">registry&lt;/span>.&lt;span style="color:#a6e22e">configs&lt;/span>.&lt;span style="color:#e6db74">&amp;#34;192.168.0.250&amp;#34;&lt;/span>.&lt;span style="color:#a6e22e">auth&lt;/span>]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">username&lt;/span> = &lt;span style="color:#e6db74">&amp;#34;admin&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">password&lt;/span> = &lt;span style="color:#e6db74">&amp;#34;Harbor12345&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>hosts.toml&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>~&lt;span style="color:#f92672">]&lt;/span>&lt;span style="color:#75715e"># cat registry.d/reg.superstor.com/hosts.toml&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>server &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#34;https://reg.superstor.com&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">[&lt;/span>host.&lt;span style="color:#e6db74">&amp;#34;https://reg.superstor.com&amp;#34;&lt;/span>&lt;span style="color:#f92672">]&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> capabilities &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#f92672">[&lt;/span>&lt;span style="color:#e6db74">&amp;#34;pull&amp;#34;&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;resolve&amp;#34;&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;push&amp;#34;&lt;/span>&lt;span style="color:#f92672">]&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> skip_verify &lt;span style="color:#f92672">=&lt;/span> true
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="x509_key_pair_streaming">[x509_key_pair_streaming]&lt;/h2>
&lt;h1 id="internalv1opt">[internal.v1.opt]&lt;/h1>
&lt;p>&lt;strong>path = &lt;!-- raw HTML omitted -->&lt;/strong> # &lt;code>默认值：/opt/containerd&lt;/code>&lt;/p>
&lt;h1 id="internalv1restart">[internal.v1.restart]&lt;/h1>
&lt;p>&lt;strong>interval = &lt;!-- raw HTML omitted -->&lt;/strong> #&lt;/p>
&lt;h1 id="metadatav1bolt">[metadata.v1.bolt]&lt;/h1>
&lt;h1 id="monitorv1cgroups">[monitor.v1.cgroups]&lt;/h1>
&lt;h1 id="runtimev2task--运行时-v2-版本插件">[runtime.v2.task] # 运行时 v2 版本插件&lt;/h1>
&lt;p>&lt;strong>platforms = &amp;lt;[]STRING&amp;gt;&lt;/strong> # &lt;code>默认值：linux/amd64&lt;/code>&lt;/p></description></item><item><title>Docs: Security</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/y.windows-%E7%AE%A1%E7%90%86/windows%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/powershell%E5%86%85%E7%BD%AE%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/security/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/y.windows-%E7%AE%A1%E7%90%86/windows%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/powershell%E5%86%85%E7%BD%AE%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/security/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://learn.microsoft.com/en-us/powershell/module/microsoft.powershell.security">官方文档-PowerShell，模块-Security&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;h1 id="get-executionpolicy">Get-ExecutionPolicy&lt;/h1>
&lt;p>获取当前会话的执行策略。&lt;/p>
&lt;ul>
&lt;li>Restricted 执行策略不允许任何脚本运行。  &lt;/li>
&lt;li>AllSigned 和 RemoteSigned 执行策略可防止 Windows PowerShell 运行没有数字签名的脚本。&lt;/li>
&lt;/ul>
&lt;p>默认使用 Restricted 策略，此时当我们执行脚本时将会失败，并报错：&lt;/p>
&lt;pre tabindex="0">&lt;code>无法加载文件 XXXXX，因为在此系统上禁止运行脚本。有关详细信息，请参阅 https:/go.microsof
t.com/fwlink/?LinkID=135170 中的 about_Execution_Policies。
&lt;/code>&lt;/pre>&lt;h2 id="syntax语法">Syntax(语法)&lt;/h2>
&lt;h2 id="example">EXAMPLE&lt;/h2>
&lt;h1 id="set-executionpolicy">Set-ExecutionPolicy&lt;/h1>
&lt;p>为 Windows 计算机设置 PowerShell 执行策略&lt;/p>
&lt;h2 id="syntax语法-1">Syntax(语法)&lt;/h2>
&lt;p>Get-Command&lt;/p>
&lt;h2 id="example-1">EXAMPLE&lt;/h2>
&lt;p>设置策略为 RemoteSigned&lt;/p>
&lt;ul>
&lt;li>Set-ExecutionPolicy RemoteSigned&lt;/li>
&lt;/ul></description></item><item><title>Docs: TSConfig</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/2.%E7%BC%96%E7%A8%8B/%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/ecmascript/ecmascript-%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8/tsconfig/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/2.%E7%BC%96%E7%A8%8B/%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/ecmascript/ecmascript-%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8/tsconfig/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://www.typescriptlang.org/docs/handbook/tsconfig-json.html">官方文档，项目配置-tsconfig.json 是什么&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.typescriptlang.org/tsconfig">官方文档，TSConfig 参考&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>TSConfig 通常是名为 tsconfig.json 或 jsconfig.json 的文件，当目录中出现了 tsconfig.json 文件，则说明该目录是 TypeScript 项目的根目录。tsconfig.json 文件指定了编译项目所需的根目录下的文件以及编译选项。&lt;/p>
&lt;h2 id="简单示例">简单示例&lt;/h2>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-json" data-lang="json">&lt;span style="display:flex;">&lt;span>{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;extends&amp;#34;&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;@vue/tsconfig/tsconfig.web.json&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;include&amp;#34;&lt;/span>: [
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#34;env.d.ts&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 两个 * 表示任意层数的所有目录
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#e6db74">&amp;#34;src/**/*&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#34;src/**/*.vue&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 导出所有接口目录到全局
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#e6db74">&amp;#34;src/api/**/*&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ],
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;compilerOptions&amp;#34;&lt;/span>: {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;baseUrl&amp;#34;&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;.&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 配置路径别名。这样在使用 import 导入时，我们可以通过 @/xxx 来代替 /src/xxx
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#f92672">&amp;#34;paths&amp;#34;&lt;/span>: {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;@/*&amp;#34;&lt;/span>: [&lt;span style="color:#e6db74">&amp;#34;src/*&amp;#34;&lt;/span>]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> },
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;references&amp;#34;&lt;/span>: [
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;path&amp;#34;&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;./tsconfig.config.json&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;strong>include&lt;/strong> # 通过在 include 中指定文件或目录，我们可以将声明的 interface 等默认导出并在其他地方使用，而不用在每个需要使用的地方使用 import 关键字显式导入了。&lt;/p>
&lt;h1 id="compileroptions">compilerOptions&lt;/h1>
&lt;h2 id="baseurl">baseUrl&lt;/h2>
&lt;h2 id="paths">paths&lt;/h2>
&lt;p>配置路径别名。
若使用 Vite 打包代码，则需要在 vite.config.ts 文件中也同步配置 &lt;code>resolve.alias&lt;/code>：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-typescript" data-lang="typescript">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">export&lt;/span> &lt;span style="color:#66d9ef">default&lt;/span> &lt;span style="color:#a6e22e">defineConfig&lt;/span>({
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">resolve&lt;/span>&lt;span style="color:#f92672">:&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">alias&lt;/span>&lt;span style="color:#f92672">:&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 让我们在导入时使用可以使用 @ 符号作为 src 目录的别名，而不是相对路径，比如：
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#75715e">// import App from &amp;#39;@/App.vue&amp;#39;
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#75715e">// 而不是
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#75715e">// import App from &amp;#39;../../App.vue&amp;#39;
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#e6db74">&amp;#34;@&amp;#34;&lt;/span>&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#a6e22e">fileURLToPath&lt;/span>(&lt;span style="color:#66d9ef">new&lt;/span> &lt;span style="color:#a6e22e">URL&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;./src&amp;#34;&lt;/span>, &lt;span style="color:#66d9ef">import&lt;/span>.&lt;span style="color:#a6e22e">meta&lt;/span>.&lt;span style="color:#a6e22e">url&lt;/span>)),
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> },
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> },
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>})
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div></description></item></channel></rss>