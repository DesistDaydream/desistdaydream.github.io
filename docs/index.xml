<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>断念梦 – 文档</title><link>https://desistdaydream.github.io/docs/</link><description>Recent content in 文档 on 断念梦</description><generator>Hugo -- gohugo.io</generator><atom:link href="https://desistdaydream.github.io/docs/index.xml" rel="self" type="application/rss+xml"/><item><title>Docs: 1.Bootloader</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/1.bootloader/1.bootloader/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/1.bootloader/1.bootloader/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Bootloader">Wiki,Bootloader&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>&lt;strong>Bootloader(引导加载程序)&lt;/strong> 是负责 &lt;a href="https://en.wikipedia.org/wiki/Booting">booting(引导)&lt;/a> 计算器的软件。通常也被称为 Bootstrap Loader、Bootstrap。&lt;/p>
&lt;p>当计算机关闭时，操作系统、应用程序代码和数据 ‍‌ 仍存储在非易失性存储器中。当计算机开机时，它通常没有操作系统或其随机存取存储器 (RAM) 中的加载程序。计算机首先执行存储在只读存储器（ROM，以及后来的 EEPROM、NOR 闪存）中的相对较小的程序以及一些需要的数据，以初始化 RAM（特别是在 x86 系统上），访问非易失性设备（通常是块设备，例如 NAND 闪存）或可以将操作系统程序和数据加载到 RAM 中的设备。&lt;/p>
&lt;h1 id="配置">配置&lt;/h1>
&lt;p>&lt;strong>/boot/*&lt;/strong> # 所有关于系统引导启动的配置信息，都在该目录下
&lt;strong>/boot/grub2/*&lt;/strong> #
&lt;strong>/etc/default/grub&lt;/strong> #&lt;/p>
&lt;h1 id="引导管理命令行工具">引导管理命令行工具&lt;/h1>
&lt;p>grub2-*
grubby
grub2-mkconfig&lt;/p></description></item><item><title>Docs: Containerd</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/10.%E4%BA%91%E5%8E%9F%E7%94%9F/2.2.%E5%AE%9E%E7%8E%B0%E5%AE%B9%E5%99%A8%E7%9A%84%E5%B7%A5%E5%85%B7/containerd/containerd/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/10.%E4%BA%91%E5%8E%9F%E7%94%9F/2.2.%E5%AE%9E%E7%8E%B0%E5%AE%B9%E5%99%A8%E7%9A%84%E5%B7%A5%E5%85%B7/containerd/containerd/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://containerd.io/">官网&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://github.com/containerd/containerd">GitHub 项目，containerd/containerd&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://github.com/containerd/containerd/blob/main/docs/PLUGINS.md">GitHub 项目文档，containerd/docs/PLUGINS.md&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://fuckcloudnative.io/posts/getting-started-with-containerd/">云原生实验室，Containerd 使用教程&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://blog.frognew.com/tags/containerd.html">架构小白，Containerd 标签&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://mp.weixin.qq.com/s/Dr6851XnkNLVFHaj1b13RQ">公众号-云原生实验室，容器中的 Shim 到底是个什么鬼&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>Containerd 是行业标准的容器运行时，着重于简单性，健壮性和可移植性。&lt;/p>
&lt;h2 id="containerd-的前世今生">Containerd 的前世今生&lt;/h2>
&lt;p>很久以前，Docker 强势崛起，以“镜像”这个大招席卷全球，对其他容器技术进行致命的降维打击，使其毫无招架之力，就连 Google 也不例外。Google 为了不被拍死在沙滩上，被迫拉下脸面（当然，跪舔是不可能的），希望 Docker 公司和自己联合推进一个开源的容器运行时作为 Docker 的核心依赖，不然就走着瞧。Docker 公司觉得自己的智商被侮辱了，走着瞧就走着瞧，谁怕谁啊！&lt;/p>
&lt;p>很明显，Docker 公司的这个决策断送了自己的大好前程，造成了今天的悲剧。&lt;/p>
&lt;p>紧接着，Google 联合 Red Hat、IBM 等几位巨佬连哄带骗忽悠 Docker 公司将 &lt;code>libcontainer&lt;/code> 捐给中立的社区（OCI，Open Container Intiative），并改名为 &lt;code>runc&lt;/code>，不留一点 Docker 公司的痕迹~~这还不够，为了彻底扭转 Docker 一家独大的局面，几位大佬又合伙成立了一个基金会叫 &lt;code>CNCF&lt;/code>（Cloud Native Computing Fundation），这个名字想必大家都很熟了，我就不详细介绍了。CNCF 的目标很明确，既然在当前的维度上干不过 Docker，干脆往上爬，升级到大规模容器编排的维度，以此来击败 Docker。Docker 公司当然不甘示弱，搬出了 Swarm 和 Kubernetes 进行 PK，最后的结局大家都知道了，Swarm 战败。然后 Docker 公司耍了个小聪明，将自己的核心依赖 &lt;code>Containerd&lt;/code> 捐给了 CNCF，以此来标榜 Docker 是一个 PaaS 平台。&lt;/p>
&lt;p>很明显，这个小聪明又大大加速了自己的灭亡。
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/ox2yd7/1616122481377-1a01b919-efe6-450a-a439-5493a17e6d70.png" alt="">
巨佬们心想，想当初想和你合作搞个中立的核心运行时，你死要面子活受罪，就是不同意，好家伙，现在自己搞了一个，还捐出来了，马老师，发生甚莫事了？&lt;/p>
&lt;p>这好吗？&lt;/p>
&lt;p>这不好&lt;/p>
&lt;p>也罢，这倒省事了，我就直接拿 &lt;code>Containerd&lt;/code> 来做文章吧。首先呢，为了表示 Kubernetes 的中立性，当然要搞个标准化的容器运行时接口，只要适配了这个接口的容器运行时，都可以和我一起玩耍哦，第一个支持这个接口的当然就是 &lt;code>Containerd&lt;/code> 啦。至于这个接口的名字，大家应该都知道了，它叫 CRI（Container Runntime Interface）。这样还不行，为了蛊惑 Docker 公司，Kubernetes 暂时先委屈自己，专门在自己的组件中集成了一个 &lt;code>shim&lt;/code>（你可以理解为垫片），用来将 CRI 的调用翻译成 Docker 的 API，让 Docker 也能和自己愉快地玩耍，温水煮青蛙，养肥了再杀。。。&lt;/p>
&lt;p>就这样，Kubernetes 一边假装和 Docker 愉快玩耍，一边背地里不断优化 Containerd 的健壮性以及和 CRI 对接的丝滑性。现在 Containerd 的翅膀已经完全硬了，是时候卸下我的伪装，和 Docker say bye bye 了。后面的事情大家也都知道了~~&lt;/p>
&lt;p>Docker 这门技术成功了，Docker 这个公司却失败了。&lt;/p>
&lt;h2 id="containerd-架构">&lt;strong>Containerd 架构&lt;/strong>&lt;/h2>
&lt;p>时至今日，Containerd 已经变成一个工业级的容器运行时了，连口号都有了：超简单！超健壮！可移植性超强！&lt;/p>
&lt;p>当然，为了让 Docker 以为自己不会抢饭碗，Containerd 声称自己的设计目的主要是为了嵌入到一个更大的系统中（暗指 Kubernetes），而不是直接由开发人员或终端用户使用。&lt;/p>
&lt;p>事实上呢，Containerd 现在基本上啥都能干了，开发人员或者终端用户可以在宿主机中管理完整的容器生命周期，包括容器镜像的传输和存储、容器的执行和管理、存储和网络等。大家可以考虑学起来了。&lt;/p>
&lt;p>先来看看 Containerd 的架构：
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/ox2yd7/1616122481393-e3bb2fce-f18d-40ec-ac46-4c6d6a664cd6.png" alt="">
可以看到 Containerd 仍然采用标准的 C/S 架构，服务端通过 &lt;code>GRPC&lt;/code> 协议提供稳定的 API，客户端通过调用服务端的 API 进行高级的操作。&lt;/p>
&lt;p>为了解耦，Containerd 将不同的职责划分给不同的组件，每个组件就相当于一个&lt;strong>子系统&lt;/strong>（subsystem）。连接不同子系统的组件被称为模块。&lt;/p>
&lt;p>总体上 Containerd 被划分为两个子系统：&lt;/p>
&lt;ul>
&lt;li>&lt;strong>Bundle&lt;/strong> : 在 Containerd 中，&lt;code>Bundle&lt;/code> 包含了配置、元数据和根文件系统数据，你可以理解为容器的文件系统。而 &lt;strong>Bundle 子系统&lt;/strong>允许用户从镜像中提取和打包 Bundles。&lt;/li>
&lt;li>&lt;strong>Runtime&lt;/strong> : Runtime 子系统用来执行 Bundles，比如创建容器。&lt;/li>
&lt;/ul>
&lt;p>其中，每一个子系统的行为都由一个或多个&lt;strong>模块&lt;/strong>协作完成（架构图中的 &lt;code>Core&lt;/code> 部分）。每一种类型的模块都以 **Plugin(插件) **的形式集成到 Containerd 中，而且插件之间是相互依赖的。例如，上图中的每一个长虚线的方框都表示一种类型的插件，包括 &lt;code>Service Plugin&lt;/code>、&lt;code>Metadata Plugin&lt;/code>、&lt;code>GC Plugin&lt;/code>、&lt;code>Runtime Plugin&lt;/code> 等，其中 &lt;code>Service Plugin&lt;/code> 又会依赖 Metadata Plugin、GC Plugin 和 Runtime Plugin。每一个小方框都表示一个细分的插件，例如 &lt;code>Metadata Plugin&lt;/code> 依赖 Containers Plugin、Content Plugin 等。总之，万物皆插件，插件就是模块，模块就是插件。
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/ox2yd7/1616122481388-5272b6c1-efb6-49f4-a180-5425bef8ed64.png" alt="">
这里介绍几个常用的插件：&lt;/p>
&lt;ul>
&lt;li>&lt;strong>Content Plugin&lt;/strong> : 提供对镜像中可寻址内容的访问，所有不可变的内容都被存储在这里。&lt;/li>
&lt;li>&lt;strong>Snapshot Plugin&lt;/strong> : 用来管理容器镜像的文件系统快照。镜像中的每一个 layer 都会被解压成文件系统快照，类似于 Docker 中的 &lt;code>graphdriver&lt;/code>。&lt;/li>
&lt;li>&lt;strong>Metrics&lt;/strong> : 暴露各个组件的监控指标。&lt;/li>
&lt;/ul>
&lt;p>从总体来看，Containerd 被分为三个大块：&lt;code>Storage&lt;/code>、&lt;code>Metadata&lt;/code> 和 &lt;code>Runtime&lt;/code>，可以将上面的架构图提炼一下：
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/ox2yd7/1616122481410-b77c18a6-2bcd-48be-b676-1b285bf1c862.png" alt="">
这是使用 &lt;strong>bucketbench[1]&lt;/strong> 对 &lt;code>Docker&lt;/code>、&lt;code>crio&lt;/code> 和 &lt;code>Containerd&lt;/code> 的性能测试结果，包括启动、停止和删除容器，以比较它们所耗的时间：
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/ox2yd7/1616122481422-8a56805f-3ef0-46a4-be19-a0a5b1eef44f.png" alt="">
可以看到 Containerd 在各个方面都表现良好，总体性能还是优越于 &lt;code>Docker&lt;/code> 和 &lt;code>crio&lt;/code> 的。&lt;/p>
&lt;h1 id="containerd-关联文件">Containerd 关联文件&lt;/h1>
&lt;p>&lt;strong>/etc/containerd/config.toml&lt;/strong> # Containerd 运行时配置文件。该文件可以通过 containerd config default 命令来生成一个默认的配置。
&lt;strong>/var/lib/containerd/*&lt;/strong> # Root(根) 文件夹。用于保存持久化数据，镜像、元数据 所在路径。包括 Snapshots, Content, Metadata 以及各种插件的数据。每一个插件都有自己单独的目录，Containerd 本身不存储任何数据，它的所有功能都来自于已加载的插件。&lt;/p>
&lt;ul>
&lt;li>.**/io.containerd.content.v1.content/* **# 镜像的上下文
&lt;ul>
&lt;li>.**/blobs/* **# 镜像文件系统布局中，blobs 目录数据的存放路径&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>./io.containerd.snapshotter.v1.overlayfs/*&lt;/strong> # 镜像的层信息所在目录。&lt;/li>
&lt;li>/var/lib/containerd 目录下的内容详解，见 [《Containerd Image 章节》](/docs/IT学习笔记/10.云原生/2.2.实现容器的工具/Containerd/Containerd%20Image.md Image.md)&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>/run/containerd/*&lt;/strong> # State(状态) 文件夹。用于保存运行时产生的临时数据，也就是容器启动后数据存放目录。包括 sockets、pid、挂载点、运行时状态以及不需要持久化保存的插件数据。&lt;/p>
&lt;ul>
&lt;li>&lt;strong>./io.containerd.runtime.VERSION.ID/*&lt;/strong> # Containerd 运行容器时所使用的 runtime 插件，该目录的名称就是插件的版本和名称。该目录下的目录以名称空间命名。
&lt;ul>
&lt;li>&lt;strong>./NAMESPACE/*&lt;/strong> # 指定名称空间下的容器启动后的数据(主要就是符合 OCI 标准的 一组 Bundle 文件)保存路径，其内目录名为 ContainerID。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h2 id="目录结构">目录结构&lt;/h2>
&lt;p>在 /var/lib/containerd 和 /run/containerd 目录下，保存了 Containerd 运行所需的所有数据。Containerd 本身不存储任何数据，所有数据都来源于插件的功能。
看一下目录下的层次结构就一目了然了：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>? → tree -L &lt;span style="color:#ae81ff">2&lt;/span> /var/lib/containerd/
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>/var/lib/containerd/
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>├── io.containerd.content.v1.content
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>│ ├── blobs
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>│ └── ingest
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>├── io.containerd.grpc.v1.cri
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>│ ├── containers
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>│ └── sandboxes
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>├── io.containerd.metadata.v1.bolt
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>│ └── meta.db
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>├── io.containerd.runtime.v1.linux
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>│ └── k8s.io
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>├── io.containerd.runtime.v2.task
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>├── io.containerd.snapshotter.v1.aufs
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>│ └── snapshots
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>├── io.containerd.snapshotter.v1.btrfs
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>├── io.containerd.snapshotter.v1.native
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>│ └── snapshots
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>├── io.containerd.snapshotter.v1.overlayfs
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>│ ├── metadata.db
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>│ └── snapshots
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>└── tmpmounts
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">18&lt;/span> directories, &lt;span style="color:#ae81ff">2&lt;/span> files
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>每个子目录，其实都表示的是一个插件名称。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>? → tree -L &lt;span style="color:#ae81ff">2&lt;/span> /run/containerd/
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>/run/containerd/
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>├── containerd.sock
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>├── containerd.sock.ttrpc
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>├── io.containerd.grpc.v1.cri
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>│ ├── containers
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>│ └── sandboxes
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>├── io.containerd.runtime.v1.linux
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>│ └── k8s.io
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>├── io.containerd.runtime.v2.task
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>└── runc
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> └── k8s.io
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">8&lt;/span> directories, &lt;span style="color:#ae81ff">2&lt;/span> files
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h1 id="containerd-插件">Containerd 插件&lt;/h1></description></item><item><title>Docs: Containerd 配置详解</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/10.%E4%BA%91%E5%8E%9F%E7%94%9F/2.2.%E5%AE%9E%E7%8E%B0%E5%AE%B9%E5%99%A8%E7%9A%84%E5%B7%A5%E5%85%B7/containerd/containerd-%E9%85%8D%E7%BD%AE%E8%AF%A6%E8%A7%A3/containerd-%E9%85%8D%E7%BD%AE%E8%AF%A6%E8%A7%A3/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/10.%E4%BA%91%E5%8E%9F%E7%94%9F/2.2.%E5%AE%9E%E7%8E%B0%E5%AE%B9%E5%99%A8%E7%9A%84%E5%B7%A5%E5%85%B7/containerd/containerd-%E9%85%8D%E7%BD%AE%E8%AF%A6%E8%A7%A3/containerd-%E9%85%8D%E7%BD%AE%E8%AF%A6%E8%A7%A3/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://github.com/containerd/containerd/blob/main/docs/man/containerd-config.toml.5.md">Manual(手册),containerd-config.toml(5)&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://manpages.debian.org/bullseye/containerd/containerd-config.toml.5.en.html">Debian Manual&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>Containerd 使用 &lt;a href="https://desistdaydream.github.io/docs/IT%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/2.%E7%BC%96%E7%A8%8B/%E6%97%A0%E6%B3%95%E5%88%86%E7%B1%BB%E7%9A%84%E8%AF%AD%E8%A8%80/TOML.md">TOML&lt;/a> 作为配置文件的格式，默认配置文件为 /etc/containerd/config.toml，我们可以通过命令来生成一个包含所有配置字段的默认配置文件&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>mkdir -p /etc/containerd
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>containerd config default &amp;gt; /etc/containerd/config.toml
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h1 id="配置文件详解">配置文件详解&lt;/h1>
&lt;h1 id="通用配置">[通用]配置&lt;/h1>
&lt;p>&lt;strong>version = 2&lt;/strong> #
&lt;strong>root = &amp;lt;STRING&amp;gt;&lt;/strong> # Containerd 持久化数据路径。&lt;code>默认值：/var/lib/containerd&lt;/code>。
&lt;strong>state = &amp;lt;STRING&amp;gt;&lt;/strong> # Containerd 临时数据路径。&lt;code>默认值：/run/containerd&lt;/code>。
&lt;strong>oom_score = 0&lt;/strong> # 设置 Containerd 的 OOM 权重。&lt;code>默认值：0&lt;/code>。
Containerd 是容器的守护者，一旦发生内存不足的情况，理想的情况应该是先杀死容器，而不是杀死 Containerd。所以需要调整 Containerd 的 &lt;code>OOM&lt;/code> 权重，减少其被 &lt;strong>OOM Kill&lt;/strong> 的几率。最好是将 &lt;code>oom_score&lt;/code> 的值调整为比其他守护进程略低的值。这里的 oom_socre 其实对应的是 &lt;code>/proc/&amp;lt;pid&amp;gt;/oom_socre_adj&lt;/code>，在早期的 Linux 内核版本里使用 &lt;code>oom_adj&lt;/code> 来调整权重, 后来改用 &lt;code>oom_socre_adj&lt;/code> 了。该文件描述如下：
在计算最终的 &lt;code>badness score&lt;/code> 时，会在计算结果是中加上 &lt;code>oom_score_adj&lt;/code> ,这样用户就可以通过该在值来保护某个进程不被杀死或者每次都杀某个进程。其取值范围为 &lt;code>-1000&lt;/code> 到 &lt;code>1000&lt;/code>。如果将该值设置为 &lt;code>-1000&lt;/code>，则进程永远不会被杀死，因为此时 &lt;code>badness score&lt;/code> 永远返回 0。建议 Containerd 将该值设置为 &lt;code>-999&lt;/code> 到 &lt;code>0&lt;/code> 之间。如果作为 Kubernetes 的 Worker 节点，可以考虑设置为 &lt;code>-999&lt;/code>。&lt;/p>
&lt;h1 id="cgroup-配置">[cgroup] 配置&lt;/h1>
&lt;h1 id="debug-配置">[debug] 配置&lt;/h1>
&lt;h1 id="grpc-配置表">[grpc] 配置表&lt;/h1>
&lt;p>&lt;strong>address = &lt;!-- raw HTML omitted -->&lt;/strong> # Containerd 监听的 GRPC 路径。&lt;code>默认值：/run/containerd/containerd.sock&lt;/code>&lt;/p>
&lt;h1 id="metrics-配置">[metrics] 配置&lt;/h1>
&lt;h1 id="plugins-配置">[plugins] 配置&lt;/h1>
&lt;p>详见 [《Plugin 配置》](/docs/IT学习笔记/10.云原生/2.2.实现容器的工具/Containerd/Containerd%20 配置详解/Plugin%20 配置.md 配置详解/Plugin 配置.md) 章节&lt;/p>
&lt;h1 id="timeouts-配置">[timeouts] 配置&lt;/h1>
&lt;h1 id="ttrpc-配置表">[ttrpc] 配置表&lt;/h1>
&lt;h1 id="配置文件示例">配置文件示例&lt;/h1>
&lt;h2 id="镜像加速配置示例">镜像加速配置示例&lt;/h2>
&lt;p>Containerd 的镜像仓库 mirror 与 Docker 相比有两个区别：&lt;/p>
&lt;ul>
&lt;li>Containerd 只支持通过 &lt;code>CRI&lt;/code> 拉取镜像的 mirror，也就是说，只有通过 &lt;code>crictl&lt;/code> 或者 Kubernetes 调用时 mirror 才会生效，通过 &lt;code>ctr&lt;/code> 拉取是不会生效的。&lt;/li>
&lt;li>&lt;code>Docker&lt;/code> 只支持为 &lt;code>Docker Hub&lt;/code> 配置 mirror，而 &lt;code>Containerd&lt;/code> 支持为任意镜像仓库配置 mirror。&lt;/li>
&lt;/ul>
&lt;p>所以需要修改的部分如下：&lt;/p>
&lt;pre>&lt;code>[plugins.&amp;quot;io.containerd.grpc.v1.cri&amp;quot;.registry]
[plugins.&amp;quot;io.containerd.grpc.v1.cri&amp;quot;.registry.mirrors]
[plugins.&amp;quot;io.containerd.grpc.v1.cri&amp;quot;.registry.mirrors.&amp;quot;docker.io&amp;quot;]
endpoint = [&amp;quot;https://dockerhub.mirrors.nwafu.edu.cn&amp;quot;]
[plugins.&amp;quot;io.containerd.grpc.v1.cri&amp;quot;.registry.mirrors.&amp;quot;k8s.gcr.io&amp;quot;]
endpoint = [&amp;quot;https://registry.aliyuncs.com/k8sxio&amp;quot;]
[plugins.&amp;quot;io.containerd.grpc.v1.cri&amp;quot;.registry.mirrors.&amp;quot;gcr.io&amp;quot;]
endpoint = [&amp;quot;xxx&amp;quot;]
&lt;/code>&lt;/pre>
&lt;h1 id="systemd-配置">Systemd 配置&lt;/h1>
&lt;p>建议通过 systemd 配置 Containerd 作为守护进程运行，配置文件在上文已经被解压出来了：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">[&lt;/span>Unit&lt;span style="color:#f92672">]&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Description&lt;span style="color:#f92672">=&lt;/span>containerd container runtime
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Documentation&lt;span style="color:#f92672">=&lt;/span>https://containerd.io
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>After&lt;span style="color:#f92672">=&lt;/span>network.target local-fs.target
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">[&lt;/span>Service&lt;span style="color:#f92672">]&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>ExecStartPre&lt;span style="color:#f92672">=&lt;/span>-/sbin/modprobe overlay
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>ExecStart&lt;span style="color:#f92672">=&lt;/span>/usr/local/bin/containerd
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Type&lt;span style="color:#f92672">=&lt;/span>notify
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Delegate&lt;span style="color:#f92672">=&lt;/span>yes
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>KillMode&lt;span style="color:#f92672">=&lt;/span>process
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Restart&lt;span style="color:#f92672">=&lt;/span>always
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>RestartSec&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">5&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># Having non-zero Limit*s causes performance problems due to accounting overhead&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># in the kernel. We recommend using cgroups to do container-local accounting.&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>LimitNPROC&lt;span style="color:#f92672">=&lt;/span>infinity
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>LimitCORE&lt;span style="color:#f92672">=&lt;/span>infinity
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>LimitNOFILE&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">1048576&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># Comment TasksMax if your systemd version does not supports it.&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># Only systemd 226 and above support this version.&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>TasksMax&lt;span style="color:#f92672">=&lt;/span>infinity
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>OOMScoreAdjust&lt;span style="color:#f92672">=&lt;/span>-999
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">[&lt;/span>Install&lt;span style="color:#f92672">]&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>WantedBy&lt;span style="color:#f92672">=&lt;/span>multi-user.target
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>这里有两个重要的参数：&lt;/p>
&lt;ul>
&lt;li>&lt;strong>Delegate&lt;/strong> : 这个选项允许 Containerd 以及运行时自己管理自己创建的容器的 &lt;code>cgroups&lt;/code>。如果不设置这个选项，systemd 就会将进程移到自己的 &lt;code>cgroups&lt;/code> 中，从而导致 Containerd 无法正确获取容器的资源使用情况。&lt;/li>
&lt;li>&lt;strong>KillMode&lt;/strong> : 这个选项用来处理 Containerd 进程被杀死的方式。默认情况下，systemd 会在进程的 cgroup 中查找并杀死 Containerd 的所有子进程，这肯定不是我们想要的。&lt;code>KillMode&lt;/code>字段可以设置的值如下。我们需要将 KillMode 的值设置为 &lt;code>process&lt;/code>，这样可以确保升级或重启 Containerd 时不杀死现有的容器。
&lt;ul>
&lt;li>&lt;strong>control-group&lt;/strong>（默认值）：当前控制组里面的所有子进程，都会被杀掉&lt;/li>
&lt;li>&lt;strong>process&lt;/strong>：只杀主进程&lt;/li>
&lt;li>&lt;strong>mixed&lt;/strong>：主进程将收到 SIGTERM 信号，子进程收到 SIGKILL 信号&lt;/li>
&lt;li>&lt;strong>none&lt;/strong>：没有进程会被杀掉，只是执行服务的 stop 命令。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul></description></item><item><title>Docs: File System 管理</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/y.windows-%E7%AE%A1%E7%90%86/file_system_%E7%AE%A1%E7%90%86/file_system_%E7%AE%A1%E7%90%86/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/y.windows-%E7%AE%A1%E7%90%86/file_system_%E7%AE%A1%E7%90%86/file_system_%E7%AE%A1%E7%90%86/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://www.howtogeek.com/318177/what-is-the-appdata-folder-in-windows/">https://www.howtogeek.com/318177/what-is-the-appdata-folder-in-windows/&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>&lt;strong>%USERPROFILE%/AppData/*&lt;/strong> #&lt;/p>
&lt;ul>
&lt;li>&lt;strong>./Local/*&lt;/strong> #&lt;/li>
&lt;li>&lt;strong>./LocalLow/*&lt;/strong> #&lt;/li>
&lt;li>&lt;strong>./Roaming/*&lt;/strong> #&lt;/li>
&lt;/ul>
&lt;p>刚装完的 win10 专业版，用户的 AppData 中将会有如下结构：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-powershell" data-lang="powershell">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">%&lt;/span>USERPROFILE%\appdata\Local
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">%&lt;/span>USERPROFILE%\appdata\LocalLow
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">%&lt;/span>USERPROFILE%\appdata\Roaming
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">%&lt;/span>USERPROFILE%\appdata\Local\Comms
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">%&lt;/span>USERPROFILE%\appdata\Local\ConnectedDevicesPlatform
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">%&lt;/span>USERPROFILE%\appdata\Local\D3DSCache
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">%&lt;/span>USERPROFILE%\appdata\Local\Microsoft
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">%&lt;/span>USERPROFILE%\appdata\Local\Packages
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">%&lt;/span>USERPROFILE%\appdata\Local\Temp
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">%&lt;/span>USERPROFILE%\appdata\LocalLow\Microsoft
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">%&lt;/span>USERPROFILE%\appdata\LocalLow\MSLiveStickerWhiteList
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">%&lt;/span>USERPROFILE%\appdata\Roaming\Adobe
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">%&lt;/span>USERPROFILE%\appdata\Roaming\Microsoft
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>最主要的是这三个目录下的 Microsfot 目录，还有 Packages 目录。在整理 AppData 时，不要误删了。&lt;/p>
&lt;h1 id="program-files">Program Files&lt;/h1>
&lt;p>该目录存储安装在计算机上的大多数应用程序的执行文件。&lt;/p>
&lt;h1 id="program-filesx86">Program Files(x86)&lt;/h1>
&lt;p>该目录存储在 64 位 Windows 系统上安装的 32 位应用程序的执行文件。&lt;/p>
&lt;h1 id="programdata">ProgramData&lt;/h1>
&lt;p>该目录存储全局数据，包括应用程序的配置文件，以及系统的安装和更新信息。&lt;/p>
&lt;h1 id="users">Users&lt;/h1>
&lt;p>该目录存储在 Windows 系统上创建的每个用户的个人文件夹，如桌面、文档和图片。&lt;/p>
&lt;h1 id="windows">Windows&lt;/h1>
&lt;p>Windows 操作系统的核心文件和 DLL 文件都存储在此目录中。&lt;/p>
&lt;p>&lt;strong>./System32/&lt;/strong> # 类似于 Linux 中的 /usr/sbin/ 目录，系统自带的命令、服务、msc 的可执行文件都在这里。&lt;/p></description></item><item><title>Docs: Linux 管理</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/x.linux-%E7%AE%A1%E7%90%86/linux%E7%AE%A1%E7%90%86/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/x.linux-%E7%AE%A1%E7%90%86/linux%E7%AE%A1%E7%90%86/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://www.gnu.org/manual/">GNU Manual(手册)&lt;/a> — Linux 中很多核心程序，都是 GNU 组织下的软件。&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>系统管理员可以通过 一系列用户空间的二进制应用程序来管理 Linux 操作系统。Linux 内核自带了一个名为 coreutils 包，包含了很多最基本的管理工具。&lt;/p>
&lt;p>除了 Coreutils 包，还有很多很多的应用程序，一起组成了一套工具栈，系统管理员可以根据自身的需求，有选择得安装并使用它们。&lt;/p>
&lt;h1 id="coreutils">Coreutils&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/GNU_Core_Utilities">Wiki,GNU Core Utilies&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.gnu.org/software/coreutils/manual/">官方文档&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>GNU Core Utilities 是 GNU 操作系统的基本文件、Shell、文本操作的实用程序。同时，也是现在绝大部分 Linux 发行版内置的实用程序。&lt;/p>
&lt;p>Coreutils 通常可以通过各种 Linux 发行版的包管理器直接安装。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>root@lichenhao:~/downloads# apt-cache show coreutils
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Package: coreutils
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Architecture: amd64
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Version: 8.30-3ubuntu2
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Multi-Arch: foreign
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Priority: required
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Essential: yes
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Section: utils
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Origin: Ubuntu
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Maintainer: Ubuntu Developers &amp;lt;ubuntu-devel-discuss@lists.ubuntu.com&amp;gt;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Original-Maintainer: Michael Stone &amp;lt;mstone@debian.org&amp;gt;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Bugs: https://bugs.launchpad.net/ubuntu/+filebug
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Installed-Size: &lt;span style="color:#ae81ff">7196&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Pre-Depends: libacl1 &lt;span style="color:#f92672">(&lt;/span>&amp;gt;&lt;span style="color:#f92672">=&lt;/span> 2.2.23&lt;span style="color:#f92672">)&lt;/span>, libattr1 &lt;span style="color:#f92672">(&lt;/span>&amp;gt;&lt;span style="color:#f92672">=&lt;/span> 1:2.4.44&lt;span style="color:#f92672">)&lt;/span>, libc6 &lt;span style="color:#f92672">(&lt;/span>&amp;gt;&lt;span style="color:#f92672">=&lt;/span> 2.28&lt;span style="color:#f92672">)&lt;/span>, libselinux1 &lt;span style="color:#f92672">(&lt;/span>&amp;gt;&lt;span style="color:#f92672">=&lt;/span> 2.1.13&lt;span style="color:#f92672">)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Filename: pool/main/c/coreutils/coreutils_8.30-3ubuntu2_amd64.deb
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Size: &lt;span style="color:#ae81ff">1249368&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>MD5sum: e8e201b6d1b7f39776da07f6713e1675
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>SHA1: 1d4ab60c729a361d46a90d92defaca518b2918d2
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>SHA256: 99aa50af84de1737735f2f51e570d60f5842aa1d4a3129527906e7ffda368853
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Homepage: http://gnu.org/software/coreutils
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Description-en: GNU core utilities
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> This package contains the basic file, shell and text manipulation
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> utilities which are expected to exist on every operating system.
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Specifically, this package includes:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> arch base64 basename cat chcon chgrp chmod chown chroot cksum comm cp
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> csplit cut date dd df dir dircolors dirname du echo env expand expr
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> factor false flock fmt fold groups head hostid id install join link ln
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> logname ls md5sum mkdir mkfifo mknod mktemp mv nice nl nohup nproc numfmt
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> od paste pathchk pinky pr printenv printf ptx pwd readlink realpath rm
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> rmdir runcon sha*sum seq shred sleep sort split stat stty sum sync tac
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> tail tee test timeout touch tr true truncate tsort tty uname unexpand
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> uniq unlink users vdir wc who whoami yes
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Description-md5: d0d975dec3625409d24be1238cede238
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Task: minimal
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>这个包中，通常包含如下应用程序&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>arch base64 basename cat chcon chgrp chmod chown chroot cksum comm cp csplit cut date dd df dir dircolors dirname du echo env expand expr factor false flock fmt fold groups head hostid id install join link ln logname ls md5sum mkdir mkfifo mknod mktemp mv nice nl nohup nproc numfmt od paste pathchk pinky pr printenv printf ptx pwd readlink realpath rm rmdir runcon sha*sum seq shred sleep sort split stat stty sum sync tac tail tee test timeout touch tr true truncate tsort tty uname unexpand uniq unlink users vdir wc who whoami yes
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>可以发现，这些命令就是我们日常经常使用那些~&lt;/p>
&lt;h1 id="util-linux">Util-linux&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://github.com/util-linux/util-linux">GitHub 项目，util-linux/util-linux&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Util-linux">Wiki,Util-linux&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>util-linux 是由 Linux 内核组织分发的标准软件包，用作 Linux 操作系统的一部分。一个分支 util-linux-ng（ng 的意思是“下一代”）是在开发停滞时创建的，但截至 2011 年 1 月，它已重命名为 util-linux，并且是该软件包的正式版本。&lt;/p>
&lt;p>Util-linux 包中通常包含如下程序：&lt;/p>
&lt;ul>
&lt;li>addpart&lt;/li>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Getty_(Unix)">agetty&lt;/a>&lt;/li>
&lt;li>blkdiscard&lt;/li>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Blkid">blkid&lt;/a>&lt;/li>
&lt;li>blkzone&lt;/li>
&lt;li>&lt;a href="https://en.wikipedia.org/w/index.php?title=Blockdev&amp;amp;action=edit&amp;amp;redlink=1">blockdev&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Cal_(command)">cal&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Cfdisk">cfdisk&lt;/a>&lt;/li>
&lt;li>chcpu&lt;/li>
&lt;li>chfn&lt;/li>
&lt;li>chmem&lt;/li>
&lt;li>choom&lt;/li>
&lt;li>chrt&lt;/li>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Chsh">chsh&lt;/a>&lt;/li>
&lt;li>col (legacy)&lt;/li>
&lt;li>colcrt&lt;/li>
&lt;li>colrm&lt;/li>
&lt;li>column&lt;/li>
&lt;li>ctrlaltdel&lt;/li>
&lt;li>delpart&lt;/li>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Dmesg">dmesg&lt;/a>&lt;/li>
&lt;li>eject&lt;/li>
&lt;li>fallocate&lt;/li>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Fdformat">fdformat&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Fdisk">fdisk&lt;/a>&lt;/li>
&lt;li>fincore&lt;/li>
&lt;li>findfs&lt;/li>
&lt;li>findmnt&lt;/li>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/File_locking">flock&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Fsck">fsck&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Fsck">fsck&lt;/a>.&lt;a href="https://en.wikipedia.org/wiki/Cramfs">cramfs&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Fsck">fsck&lt;/a>.&lt;a href="https://en.wikipedia.org/wiki/MINIX_file_system">minix&lt;/a>&lt;/li>
&lt;li>fsfreeze&lt;/li>
&lt;li>fstrim&lt;/li>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Getopt">getopt&lt;/a>&lt;/li>
&lt;li>hardlink&lt;/li>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Hex_dump#od_and_hexdump">hexdump&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://en.wikipedia.org/w/index.php?title=Hwclock&amp;amp;action=edit&amp;amp;redlink=1">hwclock&lt;/a> (query and set the hardware clock (RTC))&lt;/li>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Ionice">ionice&lt;/a>&lt;/li>
&lt;li>ipcmk&lt;/li>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Ipcrm">ipcrm&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Ipcs">ipcs&lt;/a>&lt;/li>
&lt;li>irqtop&lt;/li>
&lt;li>isosize&lt;/li>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Kill_(Unix)">kill&lt;/a>&lt;/li>
&lt;li>last&lt;/li>
&lt;li>ldattach&lt;/li>
&lt;li>line (legacy)&lt;/li>
&lt;li>logger&lt;/li>
&lt;li>login&lt;/li>
&lt;li>look&lt;/li>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Losetup">losetup&lt;/a>&lt;/li>
&lt;li>lsblk&lt;/li>
&lt;li>lscpu&lt;a href="https://en.wikipedia.org/wiki/Util-linux#cite_note-8">[8]&lt;/a>&lt;/li>
&lt;li>lsfd&lt;/li>
&lt;li>lsipc&lt;/li>
&lt;li>lsirq&lt;a href="https://en.wikipedia.org/wiki/Util-linux#cite_note-9">[9]&lt;/a>&lt;/li>
&lt;li>lslocks&lt;/li>
&lt;li>lslogins&lt;/li>
&lt;li>lsmem&lt;/li>
&lt;li>lsns&lt;/li>
&lt;li>mcookie&lt;/li>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Mesg">mesg&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Mkfs">mkfs&lt;/a> (legacy)&lt;/li>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Mkfs">mkfs&lt;/a>.&lt;a href="https://en.wikipedia.org/wiki/Boot_File_System">bfs&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Mkfs">mkfs&lt;/a>.&lt;a href="https://en.wikipedia.org/wiki/Cramfs">cramfs&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Mkfs">mkfs&lt;/a>.&lt;a href="https://en.wikipedia.org/wiki/MINIX_file_system">minix&lt;/a>&lt;/li>
&lt;li>mkswap&lt;/li>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/More_(command)">more&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Mount_(Unix)">mount&lt;/a>&lt;/li>
&lt;li>mountpoint&lt;/li>
&lt;li>namei&lt;/li>
&lt;li>newgrp&lt;/li>
&lt;li>nologin&lt;/li>
&lt;li>nsenter&lt;/li>
&lt;li>partx&lt;/li>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Pg_(Unix)">pg&lt;/a> (legacy)&lt;/li>
&lt;li>pivot_root&lt;/li>
&lt;li>prlimit&lt;a href="https://en.wikipedia.org/wiki/Util-linux#cite_note-10">[10]&lt;/a>&lt;/li>
&lt;li>raw&lt;/li>
&lt;li>readprofile&lt;/li>
&lt;li>rename&lt;/li>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Nice_(Unix)">renice&lt;/a>&lt;/li>
&lt;li>reset (legacy)&lt;/li>
&lt;li>resizepart&lt;/li>
&lt;li>rev&lt;/li>
&lt;li>rfkill&lt;/li>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/RTC_Alarm">rtcwake&lt;/a>&lt;/li>
&lt;li>runuser&lt;/li>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Script_(Unix)">script&lt;/a>&lt;/li>
&lt;li>scriptlive&lt;/li>
&lt;li>scriptreplay&lt;/li>
&lt;li>setarch (including architecture symlinks such as i386, linux32, linux64, x86_64, etc.)&lt;/li>
&lt;li>setpriv&lt;/li>
&lt;li>setsid&lt;/li>
&lt;li>setterm&lt;/li>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Sfdisk">sfdisk&lt;/a>&lt;/li>
&lt;li>su&lt;/li>
&lt;li>sulogin&lt;/li>
&lt;li>swaplabel&lt;/li>
&lt;li>swapoff&lt;/li>
&lt;li>swapon&lt;/li>
&lt;li>switch_root&lt;/li>
&lt;li>taskset&lt;/li>
&lt;li>tunelp (deprecated)&lt;a href="https://en.wikipedia.org/wiki/Util-linux#cite_note-11">[11]&lt;/a>&lt;/li>
&lt;li>ul&lt;/li>
&lt;li>umount&lt;/li>
&lt;li>unshare&lt;/li>
&lt;li>utmpdump&lt;/li>
&lt;li>uuidd&lt;/li>
&lt;li>uuidgen&lt;/li>
&lt;li>uuidparse&lt;/li>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Vipw">vipw&lt;/a> (including symlink to vigr)&lt;/li>
&lt;li>wall&lt;/li>
&lt;li>wdctl&lt;/li>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Whereis">whereis&lt;/a>&lt;/li>
&lt;li>wipefs&lt;/li>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Write_(Unix)">write&lt;/a>&lt;/li>
&lt;li>zramctl&lt;/li>
&lt;/ul>
&lt;h3 id="removed">Removed&lt;/h3>
&lt;p>Utilities formerly included, but removed as of 1 July 2015:&lt;/p>
&lt;ul>
&lt;li>arch&lt;a href="https://en.wikipedia.org/wiki/Util-linux#cite_note-12">[12]&lt;/a>&lt;/li>
&lt;li>chkdupexe&lt;a href="https://en.wikipedia.org/wiki/Util-linux#cite_note-13">[13]&lt;/a>&lt;/li>
&lt;li>clock&lt;a href="https://en.wikipedia.org/wiki/Util-linux#cite_note-14">[14]&lt;/a>&lt;/li>
&lt;li>cytune&lt;a href="https://en.wikipedia.org/wiki/Util-linux#cite_note-15">[15]&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Ddate">ddate&lt;/a> (removed from default build&lt;a href="https://en.wikipedia.org/wiki/Util-linux#cite_note-16">[16]&lt;/a> before being removed&lt;a href="https://en.wikipedia.org/wiki/Util-linux#cite_note-17">[17]&lt;/a> altogether)&lt;/li>
&lt;li>elvtune&lt;a href="https://en.wikipedia.org/wiki/Util-linux#cite_note-18">[18]&lt;/a>&lt;/li>
&lt;li>fastboot&lt;a href="https://en.wikipedia.org/wiki/Util-linux#cite_note-simpleinit-19">[19]&lt;/a>&lt;/li>
&lt;li>fasthalt&lt;a href="https://en.wikipedia.org/wiki/Util-linux#cite_note-simpleinit-19">[19]&lt;/a>&lt;/li>
&lt;li>halt&lt;a href="https://en.wikipedia.org/wiki/Util-linux#cite_note-simpleinit-19">[19]&lt;/a>&lt;/li>
&lt;li>initctl&lt;a href="https://en.wikipedia.org/wiki/Util-linux#cite_note-simpleinit-19">[19]&lt;/a>&lt;/li>
&lt;li>ramsize (formerly a symlink to rdev)&lt;a href="https://en.wikipedia.org/wiki/Util-linux#cite_note-rdev-20">[20]&lt;/a>&lt;/li>
&lt;li>rdev&lt;a href="https://en.wikipedia.org/wiki/Util-linux#cite_note-rdev-20">[20]&lt;/a>&lt;/li>
&lt;li>reboot&lt;a href="https://en.wikipedia.org/wiki/Util-linux#cite_note-simpleinit-19">[19]&lt;/a>&lt;/li>
&lt;li>rootflags (formerly a symlink to rdev)&lt;a href="https://en.wikipedia.org/wiki/Util-linux#cite_note-rdev-20">[20]&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Shutdown_(command)">shutdown&lt;/a>&lt;a href="https://en.wikipedia.org/wiki/Util-linux#cite_note-simpleinit-19">[19]&lt;/a>&lt;/li>
&lt;li>simpleinit&lt;a href="https://en.wikipedia.org/wiki/Util-linux#cite_note-simpleinit-19">[19]&lt;/a>&lt;/li>
&lt;li>tailf&lt;a href="https://en.wikipedia.org/wiki/Util-linux#cite_note-tailf-21">[21]&lt;/a>&lt;/li>
&lt;li>vidmode (formerly a symlink to rdev)&lt;a href="https://en.wikipedia.org/wiki/Util-linux#cite_note-rdev-20">[20]&lt;/a>&lt;/li>
&lt;/ul></description></item><item><title>Docs: Microsoft Management Console</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/y.windows-%E7%AE%A1%E7%90%86/microsoft_management_console/microsoft_management_console/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/y.windows-%E7%AE%A1%E7%90%86/microsoft_management_console/microsoft_management_console/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Microsoft_Management_Console">Wiki，Microsoft Management Console&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>&lt;strong>Microsoft Management Console(微软管理控制台，简称 MMC)&lt;/strong> 是 Microsoft Windows 的一个组件，它为系统管理员和高级用户提供了一个用于配置和监控系统的界面。它于 1998 年首次与 Windows NT 4.0 的 Option Pack 一起推出，后来与 Windows 2000 及其后续版本预捆绑在一起。&lt;/p>
&lt;h1 id="msc">msc&lt;/h1>
&lt;p>MSC(Microsoft Snap-In Control)文件，是&lt;a href="https://baike.baidu.com/item/%E5%BE%AE%E8%BD%AF%E7%AE%A1%E7%90%86%E6%8E%A7%E5%88%B6%E5%8F%B0/267174?fromModule=lemma_inlink">微软管理控制台&lt;/a>MMC(Microsoft Management Console)用来添加/删除的嵌入式管理单元文件。通常通过MMC来管理，可点击“文件”菜单中的“添加/删除管理单元”操作来管理当前系统中已经安装的MSC文件。可以点击开始/运行，然后输入下列文件名就可以打开相应的控制窗口。&lt;/p></description></item><item><title>Docs: PowerShell</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/4.terminal-%E4%B8%8E-shell/windows_shell/powershell/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/4.terminal-%E4%B8%8E-shell/windows_shell/powershell/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://learn.microsoft.com/en-us/powershell">官方文档，PowerShell&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>PowerShell 是一种跨平台的任务自动化解决方案，由命令行 shell、脚本语言和配置管理框架组成。 PowerShell 在 Windows、Linux 和 macOS 上运行。&lt;/p>
&lt;p>PowerShell 的独特之处在于，它接受并返回 .NET 对象，而非纯文本。这个特点让 PowerShell 可以更轻松地在一个管道中串联不通的命令。&lt;/p>
&lt;blockquote>
&lt;p>这里面所说的对象，就是面向对象编程中常说的“对象”，就像 Go 语言中的 Struct 类似的东西，只不过是 .NET 语言中的对象。&lt;/p>
&lt;/blockquote>
&lt;p>这些对象在被接收后，再交给格式化函数处理，以人类可读的方式，输出出来。&lt;/p>
&lt;h2 id="powershell-命令">PowerShell 命令&lt;/h2>
&lt;p>PowerShell 中可以执行的命令分两类&lt;/p>
&lt;ul>
&lt;li>系统上的可执行命令。&lt;/li>
&lt;li>cmdlet&lt;/li>
&lt;/ul>
&lt;p>PowerShell 内置了一组 &lt;strong>cmdlet(全称 command-lets)&lt;/strong>，cmdlet 并不是一个独立的可执行文件，而是一种统称，cmdlet 被收集在 PowerShell 模块中，可以按需加载它们。可以用任何编译的 .NET 语言或 PowerShell 脚本语言来编写 cmdlet。&lt;/p>
&lt;p>cmdlet 中每个命令的名称都是由 &lt;strong>Verb-Noun(动词-名词)&lt;/strong> 组成，比如 Get-Command 命令用于获取在 CLI 中注册的所有 cmdlet。&lt;/p>
&lt;p>我们可以通过如下几个命令来搜索可用的 cmdlet&lt;/p>
&lt;ul>
&lt;li>&lt;code>Get-Verb&lt;/code> # 获取所有可用的动词&lt;/li>
&lt;li>&lt;code>Get-Command&lt;/code> # 此命令会检索计算机上安装的所有命令的列表。&lt;/li>
&lt;li>&lt;code>Get-Member&lt;/code> # 基于其他命令运行，可以获取 cmdlet 返回的对象信息，包括对象中的&lt;strong>属性、方法、等等&lt;/strong>&lt;/li>
&lt;li>&lt;code>Get-Help&lt;/code> # 以命令名称为参数调用此命令，将显示一个帮助页面，其中说明了命令的各个部分。&lt;/li>
&lt;/ul>
&lt;p>从本笔记的 &lt;a href="https://desistdaydream.github.io/docs/IT%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Y.Windows%20%E7%AE%A1%E7%90%86/Windows%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/_index.md">Windows 管理工具&lt;/a> 目录查找所有可用的命令，以及查看命令的用法&lt;/p>
&lt;p>我们可以通过 &lt;code>$psversiontable&lt;/code> 和 &lt;code>$host&lt;/code> 变量查看 PowerShell 版本信息&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-powershell" data-lang="powershell">&lt;span style="display:flex;">&lt;span>PS C:\&amp;gt; $psversiontable
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Name Value
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>---- -----
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>PSVersion &lt;span style="color:#ae81ff">7.3&lt;/span>.2
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>PSEdition Core
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>GitCommitId &lt;span style="color:#ae81ff">7.3&lt;/span>.2
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>OS Microsoft Windows &lt;span style="color:#ae81ff">10.0&lt;/span>.19045
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Platform Win32NT
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>PSCompatibleVersions {&lt;span style="color:#ae81ff">1.0&lt;/span>, &lt;span style="color:#ae81ff">2.0&lt;/span>, &lt;span style="color:#ae81ff">3.0&lt;/span>, &lt;span style="color:#ae81ff">4.0&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">…&lt;/span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>PSRemotingProtocolVersion &lt;span style="color:#ae81ff">2.3&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>SerializationVersion &lt;span style="color:#ae81ff">1.1&lt;/span>.0.1
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>WSManStackVersion &lt;span style="color:#ae81ff">3.0&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>PS C:\&amp;gt; $host
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Name &lt;span style="color:#960050;background-color:#1e0010">:&lt;/span> ConsoleHost
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Version &lt;span style="color:#960050;background-color:#1e0010">:&lt;/span> &lt;span style="color:#ae81ff">7.3&lt;/span>.2
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>InstanceId &lt;span style="color:#960050;background-color:#1e0010">:&lt;/span> 518ca4c4-e959-4d51-b3bb-cdcb3d5a1484
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>UI &lt;span style="color:#960050;background-color:#1e0010">:&lt;/span> System.Management.Automation.Internal.Host.InternalHostUserInterface
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>CurrentCulture &lt;span style="color:#960050;background-color:#1e0010">:&lt;/span> zh-CN
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>CurrentUICulture &lt;span style="color:#960050;background-color:#1e0010">:&lt;/span> zh-CN
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>PrivateData &lt;span style="color:#960050;background-color:#1e0010">:&lt;/span> Microsoft.PowerShell.ConsoleHost+ConsoleColorProxy
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>DebuggerEnabled &lt;span style="color:#960050;background-color:#1e0010">:&lt;/span> True
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>IsRunspacePushed &lt;span style="color:#960050;background-color:#1e0010">:&lt;/span> False
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Runspace &lt;span style="color:#960050;background-color:#1e0010">:&lt;/span> System.Management.Automation.Runspaces.LocalRunspace
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h1 id="安装与更新">安装与更新&lt;/h1>
&lt;h1 id="使用-powershell">使用 PowerShell&lt;/h1>
&lt;p>&lt;code>powershell&lt;/code> 和 &lt;code>pwsh&lt;/code> 这几个命令一般都是用来打开 PowerShell 的，同时也是执行 PowerShell 脚本的前置命令。就像执行 Bash 脚本前加个 &lt;code>bash&lt;/code> 命令一样&lt;/p>
&lt;h1 id="item">ITEM&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://learn.microsoft.com/en-us/powershell/scripting/lang-spec/chapter-03#33-items">官方文档-PowerShell，脚本-基本概念-Items&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>PowerShell 中会抽象出一个 &lt;strong>Item(项)&lt;/strong> 的概念，Item 可以一个 &lt;strong>Alias(别名)&lt;/strong>、&lt;strong>Variable(变量)&lt;/strong>、&lt;strong>Function(函数)&lt;/strong>、&lt;strong>EnvironmentVariable(环境变量)&lt;/strong>、甚至可以是文件系统中的 &lt;strong>File(文件)&lt;/strong> 或者 &lt;strong>Directory(目录)&lt;/strong>。&lt;/p>
&lt;p>我们常用的 &lt;code>ls&lt;/code> 命令，在 PowerShell 中其实就是调用了 &lt;code>Get-ChildItem&lt;/code> 命令&lt;/p>
&lt;h1 id="porviders提供器-和-drives驱动器">Porviders(提供器) 和 Drives(驱动器)&lt;/h1>
&lt;p>在 PowerShell 中，Providers 和 Drives 是提供对不同数据源（如文件系统、注册表、Certificate 等）的访问的特定接口。Drives 则是实际代表特定数据源的容器，比如本地磁盘驱动器、注册表驱动器等。使用 PowerShell 可以对这些数据源进行管理和操作。&lt;/p></description></item><item><title>Docs: Prometheus</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/6.%E5%8F%AF%E8%A7%82%E6%B5%8B%E6%80%A7/%E7%9B%91%E6%8E%A7%E7%B3%BB%E7%BB%9F/prometheus/prometheus/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/6.%E5%8F%AF%E8%A7%82%E6%B5%8B%E6%80%A7/%E7%9B%91%E6%8E%A7%E7%B3%BB%E7%BB%9F/prometheus/prometheus/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://prometheus.io/docs/introduction/overview/">官方文档&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://yunlzheng.gitbook.io/prometheus-book/">yunlzheng 写的电子书&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://github.com/Tencent-Cloud-Native/tkedocs">GitHub 项目，Tencent-Cloud-Native/tkedocs&lt;/a>(我个人总结完绝大部分文档后发现的这个项目)&lt;/li>
&lt;li>Prometheus 纪录片
&lt;ul>
&lt;li>&lt;a href="https://www.youtube.com/watch?v=rT4fJNbfe14">YouTube&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.bilibili.com/video/BV1aW4y147GX">B 站翻译&lt;/a>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>Prometheus 是由 SoundCloud 开发的 开源监控报警系统 和 时间序列数据库(TSDB) 。&lt;strong>Time Series(时间序列)&lt;/strong> 概念详见：&lt;a href="https://www.yuque.com/go/doc/33147376">Prometheus 数据模型&lt;/a>。使用 Go 语言开发，是 Google BorgMon 监控系统的开源版本。&lt;/p>
&lt;blockquote>
&lt;p>题外话：Google 的 Borg 诞生了 kuberntes、Google 的 Borgmon 诞生了 Prometheus&lt;/p>
&lt;/blockquote>
&lt;p>2016 年由 Google 发起 Linux 基金会旗下的 Cloud Native Computing Foundation(云原生计算基金会), 将 Prometheus 纳入其下第二大开源项目。Prometheus 目前在开源社区相当活跃。&lt;/p>
&lt;h2 id="prometheus-架构概述">Prometheus 架构概述&lt;/h2>
&lt;p>Prometheus 的基本原理是通过 HTTP 协议周期性抓取被监控组件的状态，任意组件只要提供对应的 HTTP 接口就可以接入监控。不需要任何 SDK 或者其他的集成过程。这样做非常适合做虚拟化环境监控系统，比如 VM、Docker、Kubernetes 等。输出被监控组件信息的 HTTP 接口被叫做 exporter 。&lt;/p>
&lt;p>下面这张图说明了 Prometheus 的整体架构，以及生态中的一些组件作用：
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/usvgfl/1616041189523-5ca97287-5886-4ab9-a4f8-6c249117e314.jpeg" alt="">
Prometheus 生态圈中包含了多个组件，其中许多组件是可选的，多数 Prometheus 组件是 Go 语言写的，使得这些组件很容易编译和部署：&lt;/p>
&lt;ul>
&lt;li>&lt;strong>Prometheus Server&lt;/strong> # 主要负责数据抓取和存储，提供 PromQL 查询语言的支持。用于收集和存储时间序列数据。
&lt;ul>
&lt;li>定期从配置好的 Jobs 中&lt;strong>拉取 &lt;strong>Exporters 采集的&lt;/strong> Metrics(指标)&lt;/strong> 数据；或者&lt;strong>接收&lt;/strong>来自 &lt;strong>Pushgateway&lt;/strong>(类似 zabbix 的 proxy) 发过来的 Metrics；或者从其他的 Prometheus Server 中拉取 Metrics。&lt;/li>
&lt;li>Prometheus Server 在本地存储收集到的 Metrics，并通过一定 &lt;strong>RecordingRule(记录规则)&lt;/strong> 进行清理和整理数据，并把得到的结果存储到新的时间序列中。还会运行已定义好的 &lt;strong>AlertingRule(告警规则)&lt;/strong>，记录新的时间序列或者向 Alertmanager 推送警报。&lt;/li>
&lt;li>由于 Metrics 都是通过 HTTP 或者 HTTPS 协议提供的，所以 Prometheus Server 在抓取 Metrics 时，也就是发起一次 HTTP 或者 HTTPS 的 GET 请求&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>Instrumenting&lt;/strong> # 为 Prometheus 提供指标的工具或代码
&lt;ul>
&lt;li>**Exporters **# 导出器。Exporter 是 Prometheus 的一类数据采集组件的总称。它负责从设备上搜集数据，并将其转化为 Prometheus 支持的格式(一般情况下 exporter 是安装在需要采集数据的设备上的程序，并监听某个 port。但是如果想要收集 snmp 信息的话，则有专门的 snmp-exporter 安装在某个地方；再收集指定设备的 snmp 信息，然后 prometheus 再找 snmp-exporter 去收集数据)。与传统的数据采集组件不同的是，它并不向中央服务器发送数据，而是等待中央服务器主动前来抓取。Prometheus 提供多种类型的 Exporter 用于采集各种不同服务的运行状态。目前支持的有数据库、硬件、消息中间件、存储系统、HTTP 服务器、JMX 等。&lt;/li>
&lt;li>&lt;strong>Client Library&lt;/strong> # 客户端库(客户端 SDK)，官方提供的客户端类库有 go、java、scala、python、ruby，其他还有很多第三方开发的类库，支持 nodejs、php、erlang 等。为需要监控的服务生成相应的 Metrics 并暴露给 Prometheus server。当 Prometheus server 来 pull 时，直接返回实时状态的 Metrics。&lt;/li>
&lt;li>**Push Gateway **# 支持 Client 主动推送 Metrics 到 PushGateway，而 PrometheusServer 只是定时去 Gateway 上抓取数据。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>Alertmanager&lt;/strong> # 警告管理器，用来进行报警。从 Prometheus server 端接收到 alerts 后，会进行去除重复数据，分组，并路由到对收的接受方式，发出报警。常见的接收方式有：电子邮件，pagerduty，OpsGenie, webhook 等。&lt;/li>
&lt;li>&lt;strong>prometheus_cli&lt;/strong> # 命令行工具。&lt;/li>
&lt;li>&lt;strong>其他辅助性工具&lt;/strong>
&lt;ul>
&lt;li>Prometheus 通过 PromQL 和其他 API 可视化地展示收集的数据。Prometheus 支持很多方式的图表可视化，例如 Grafana、自带的 PrometheusDashboard 以及自身提供的模版引擎等等。Prometheus 还提供 HTTP API 的查询方式，自定义所需要的输出。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>Prometheus 适用的场景&lt;/p>
&lt;ul>
&lt;li>Prometheus 在记录纯数字时间序列方面表现非常好。它既适用于面向服务器等硬件指标的监控，也适用于高动态的面向服务架构的监控。对于现在流行的微服务，Prometheus 的多维度数据收集和数据筛选查询语言也是非常的强大。Prometheus 是为服务的可靠性而设计的，当服务出现故障时，它可以使你快速定位和诊断问题。它的搭建过程对硬件和服务没有很强的依赖关系。&lt;/li>
&lt;/ul>
&lt;p>Prometheus 不适用的场景&lt;/p>
&lt;ul>
&lt;li>Prometheus 它的价值在于可靠性，甚至在很恶劣的环境下，你都可以随时访问它和查看系统服务各种指标的统计信息。 如果你对统计数据需要 100%的精确，它并不适用，例如：它不适用于实时计费系统。&lt;/li>
&lt;/ul>
&lt;h3 id="总结prometheus-从-instrumenting-那里抓取监控数据储存完了哈哈哈哈哈">总结：prometheus 从 Instrumenting 那里抓取监控数据，储存。完了~~~~哈哈哈哈哈&lt;/h3>
&lt;h2 id="instrumenting检测仪表装置-的实现方式">Instrumenting(检测仪表装置) 的实现方式&lt;/h2>
&lt;p>Prometheus 可以通过 3 种方式从目标上 Scrape(抓取) 指标：&lt;/p>
&lt;ul>
&lt;li>&lt;strong>Exporters&lt;/strong> # 外部抓取程序&lt;/li>
&lt;li>&lt;strong>Instrumentation&lt;/strong> # 可以理解为内嵌的 Exporter，比如 Prometheus Server 的 9090 端口的 &lt;code>/metrics&lt;/code> 就属于此类。
&lt;ul>
&lt;li>说白了，就是目标自己就可以吐出符合 Prometheus 格式的指标数据&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>Pushgateway&lt;/strong> # 针对需要推送指标的应用&lt;/li>
&lt;/ul>
&lt;h2 id="label-与-relabeling">Label 与 Relabeling&lt;/h2>
&lt;p>详见 &lt;a href="https://desistdaydream.github.io/docs/IT%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/6.%E5%8F%AF%E8%A7%82%E6%B5%8B%E6%80%A7/%E7%9B%91%E6%8E%A7%E7%B3%BB%E7%BB%9F/Prometheus/Target(%E7%9B%AE%E6%A0%87)%20%E4%B8%8E%20Relabeling(%E9%87%8D%E6%96%B0%E6%A0%87%E8%AE%B0).md">Label 与 Relabeling 章节&lt;/a>&lt;/p>
&lt;h2 id="instrumenting-的安装与使用">Instrumenting 的安装与使用&lt;/h2>
&lt;p>详见 &lt;a href="https://desistdaydream.github.io/docs/IT%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/6.%E5%8F%AF%E8%A7%82%E6%B5%8B%E6%80%A7/%E7%9B%91%E6%8E%A7%E7%B3%BB%E7%BB%9F/Instrumenting/Instrumenting.md">Instrumenting 章节&lt;/a>&lt;/p>
&lt;h1 id="prometheus-部署">Prometheus 部署&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://prometheus.io/docs/prometheus/latest/installation/">官方文档，Prometheus-安装&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>官方系统版本可在这里下载：&lt;a href="https://prometheus.io/download/">https://prometheus.io/download/&lt;/a>&lt;/p>
&lt;p>Prometheus 官方有多种部署方案，比如：Docker 容器、Ansible、Chef、Puppet、Saltstack 等。Prometheus 用 Golang 实现，因此具有天然可移植性(支持 Linux、Windows、macOS 和 Freebsd)。&lt;/p>
&lt;h2 id="二进制文件运行-prometheus-server">二进制文件运行 Prometheus Server&lt;/h2>
&lt;ul>
&lt;li>&lt;a href="https://github.com/prometheus/prometheus/releases/">https://github.com/prometheus/prometheus/releases/&lt;/a> 在该页面下直接下载 prometheus 的进制文件 &lt;code>prometheus-版本号.linux-amd64.tar.gz&lt;/code> 并解压，其中包含 prometheus 的主程序还有 yaml 格式的配置文件以及运行所需要的依赖库&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>export PromVersion&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;2.25.1&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>wget https://github.com/prometheus/prometheus/releases/download/v&lt;span style="color:#e6db74">${&lt;/span>PromVersion&lt;span style="color:#e6db74">}&lt;/span>/prometheus-&lt;span style="color:#e6db74">${&lt;/span>PromVersion&lt;span style="color:#e6db74">}&lt;/span>.linux-amd64.tar.gz
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ul>
&lt;li>创建/usr/local/prometheus 目录，并将解压的所有文件移动到该目录下&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>mkdir /usr/local/prometheus
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>tar -zxvf prometheus-&lt;span style="color:#e6db74">${&lt;/span>PromVersion&lt;span style="color:#e6db74">}&lt;/span>.linux-amd64.tar.gz -C /usr/local/prometheus/ --strip-components&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ul>
&lt;li>创建 Systemd 服务,在 ExecStart 字段上，使用运行时标志来对 prometheus 进行基本运行配置，标志说明详见下文&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>cat &amp;gt; /usr/lib/systemd/system/prometheus.service &lt;span style="color:#e6db74">&amp;lt;&amp;lt; EOF
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">[Unit]
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">Description=prometheus
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">After=network.target
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">[Service]
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">Type=simple
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">User=root
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">ExecStart=/usr/local/prometheus/prometheus \
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74"> --web.console.templates=/usr/local/prometheus/consoles \
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74"> --web.console.libraries=/usr/local/prometheus/console_libraries \
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74"> --config.file=/usr/local/prometheus/prometheus.yml \
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74"> --storage.tsdb.path=/var/lib/prometheusData \
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74"> --web.enable-lifecycle
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">Restart=on-failure
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">[Install]
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">WantedBy=multi-user.target
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">EOF&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ul>
&lt;li>启动 Prometheus&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>systemctl start prometheus
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="容器运行-prometheus">容器运行 prometheus&lt;/h2>
&lt;p>获取配置文件.&lt;/p>
&lt;blockquote>
&lt;p>也可以不获取配置文件，去掉启动时的 -v /etc/monitoring/prometheus:/etc/prometheus/config_out 与 &amp;ndash;config.file=/etc/prometheus/config_out/prometheus.yml 这两行即可
获取配置文件主要是为了让后续测试可以更方便得修改文件&lt;/p>
&lt;/blockquote>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>mkdir -p /opt/monitoring/prometheus
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>docker run -d --name prometheus --rm prom/prometheus
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>docker cp prometheus:/etc/prometheus /opt/monitoring/prometheus
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>mv /opt/monitoring/prometheus/prometheus /opt/monitoring/prometheus/config
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>docker stop prometheus
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>运行 Prometheus Server&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>docker run -d --name prometheus --restart&lt;span style="color:#f92672">=&lt;/span>always &lt;span style="color:#ae81ff">\
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">&lt;/span> --network host &lt;span style="color:#ae81ff">\
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">&lt;/span> -v /etc/localtime:/etc/localtime &lt;span style="color:#ae81ff">\
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">&lt;/span> -v /opt/monitoring/prometheus/config:/etc/prometheus/config_out &lt;span style="color:#ae81ff">\
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">&lt;/span> prom/prometheus &lt;span style="color:#ae81ff">\
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">&lt;/span> --config.file&lt;span style="color:#f92672">=&lt;/span>/etc/prometheus/config_out/prometheus.yml
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h1 id="prometheus-关联文件与配置">Prometheus 关联文件与配置&lt;/h1>
&lt;p>**/etc/prometheus/prometheus.yml **# Prometheus Server 运行时的配置文件。可通过 &amp;ndash;config.file 标志指定其他文件。
&lt;strong>/etc/prometheus/rule.yml&lt;/strong> # Prometheus Rule 配置文件。该文件默认不存在，需手动创建。可以在 prometheus.yml 配置中指定其他文件。&lt;/p>
&lt;h2 id="prometheus-配置示例">Prometheus 配置示例&lt;/h2>
&lt;h3 id="默认配置文件">默认配置文件&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-yaml" data-lang="yaml">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># 全局配置&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">global&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">scrape_interval&lt;/span>: &lt;span style="color:#ae81ff">15s&lt;/span> &lt;span style="color:#75715e"># 默认抓取间隔, 15秒向目标抓取一次数据。&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">evaluation_interval&lt;/span>: &lt;span style="color:#ae81ff">15s&lt;/span> &lt;span style="color:#75715e"># 每15秒评估一次规则，默认为1分钟。&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e"># scrape_timeout is set to the global default (10s).&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e"># 告警报警配置，设置prometheus主程序对接alertmanager程序的&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">alerting&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">alertmanagers&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#f92672">static_configs&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#f92672">targets&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e"># - alertmanagerIP:9093&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># 指定要使用的规则文件位置，并加载一次，根据全局配置中的 evaluation_interval 来定期评估&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># 从所有匹配到的文件中读取配置内容。可以使用正则表达式匹配多个符合的文件。Prometheus支持两种规则&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># 其一是记录规则(recording rules)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># 其二是告警规则(alerting rules)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">rule_files&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e"># - &amp;#34;first.rules&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e"># - &amp;#34;second.rules&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># 抓取配置，prometheus抓取exporter上的数据时的配置，一个job就是一个抓取工作，其中可以包括1个或者多个目标&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># 目标指的是可以被 prometheus 采集的服务器、服务等。&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># 默认配置里，Prometheus Server 会抓取本地9090端口上数据。该端口上的 exporter 就是 PrometheusServer 自己的 exporter&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">scrape_configs&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># job_name 指定要 scrape(抓取) 的 job(工作) 名称，名称必须是唯一的&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># 并且在这个配置内的时间序例，每一条都会自动添加上这个{job_name:&amp;#34;prometheus&amp;#34;}的标签。&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>- &lt;span style="color:#f92672">job_name&lt;/span>: &lt;span style="color:#e6db74">&amp;#39;prometheus&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e"># 设定该job的抓取时间间隔&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">scrape_interval&lt;/span>: &lt;span style="color:#ae81ff">5s&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">static_configs&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#f92672">targets&lt;/span>: [&lt;span style="color:#e6db74">&amp;#39;localhost:9090&amp;#39;&lt;/span>]
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="具有-node_exporter-的配置简单文件">具有 node_exporter 的配置简单文件&lt;/h3>
&lt;p>抓取部署了 node_exporter 设备的监控数据的方式及 prometheus.yml 配置文件说明
prometheus 会从 Node Exporter 所在服务器的 http://IP:9100/metrics 这个地址里的内容来获取该设备的监控数据
所以需要给 prometheus 创建一个工作(i.e.job)。一个 job 就是一个抓取监控数据的工作，其中包括要抓取目标的 ip 和 port，还可以设置标签进行分类，还能进行抓取筛选等等，下面提供一个基本的配置
修改 prometheus.yml，加入下面的监控目标，以便让 prometheus 监控这个已经安装了 node_exporter 的设备&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-yaml" data-lang="yaml">&lt;span style="display:flex;">&lt;span>- &lt;span style="color:#f92672">job_name&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;linux&amp;#34;&lt;/span> &lt;span style="color:#75715e">#新增一个job，名为linux&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">static_configs&lt;/span>: &lt;span style="color:#75715e"># 使用静态配置&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#f92672">targets&lt;/span>: [&lt;span style="color:#e6db74">&amp;#34;10.10.100.101:9100&amp;#34;&lt;/span>] &lt;span style="color:#75715e">#添加一个要抓取数据的目标，指定IP与PORT 。node_exporter所安装的设备&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">labels&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">instance&lt;/span>: &lt;span style="color:#ae81ff">lchTest&lt;/span> &lt;span style="color:#75715e">#给该目标添加一个标签&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>现在，prometheus.yml 配置文件中中一共定义了两个监控：一个是默认自带监控 prometheus 自身服务，另一个是我们新增的 job，这个 job 就是要抓取目标是 10.10.100.101 这台服务器上的监控数据&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-yaml" data-lang="yaml">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">scrape_configs&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#f92672">job_name&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;prometheus&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">static_configs&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#f92672">targets&lt;/span>: [&lt;span style="color:#e6db74">&amp;#34;localhost:9090&amp;#34;&lt;/span>]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#f92672">job_name&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;linux&amp;#34;&lt;/span> &lt;span style="color:#75715e">#指定job名称&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">static_configs&lt;/span>: &lt;span style="color:#75715e">#设定静态配置&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#f92672">targets&lt;/span>: [&lt;span style="color:#e6db74">&amp;#34;10.10.100.101:9100&amp;#34;&lt;/span>] &lt;span style="color:#75715e">#指定node_exporter所安装设备的ip:port&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">labels&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">instance&lt;/span>: &lt;span style="color:#ae81ff">lchTest&lt;/span> &lt;span style="color:#75715e">#给该target一个label来分类，常用于在查询语句中的筛选条件&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>访问 Prometheus Web，在 Status-&amp;gt;Targets 页面下，我们可以看到我们配置的两个 Target，它们的 State 为 UP
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/usvgfl/1616041189541-1dfdddd7-ee74-4f32-8df6-8821cf415a14.jpeg" alt="">&lt;/p>
&lt;h1 id="prometheus-的基本使用方式">Prometheus 的基本使用方式&lt;/h1>
&lt;p>Prometheus 运行后默认会监听在 9090 端口，可以通过访问 9090 端口来打开 Prometheus 的 web 界面
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/usvgfl/1616041189523-861a164c-3f79-42af-bd88-44c4baf2e349.jpeg" alt="">
Prometheus 本身也是自带 exporter 的,我们通过请求 http://ip:9090/metrics 可以查看从 exporter 中能具体抓到哪些 metrics。
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/usvgfl/1616041189563-4125f137-160f-48dd-b4f6-dfd6af94aed0.jpeg" alt="">&lt;/p>
&lt;p>这里以 Prometheus 本身数据为例，简单演示下在 Web 中查询指定表达式及图形化显示查询结果。
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/usvgfl/1616041189526-ee545ef0-965e-499c-b80f-b6cdaf05c974.jpeg" alt="">
[&lt;/p>
&lt;h1 id="instrumentingmd">](Instrumenting.md)&lt;/h1></description></item><item><title>Docs: 多媒体处理工具</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/11_%E5%A4%9A%E5%AA%92%E4%BD%93/%E5%A4%9A%E5%AA%92%E4%BD%93%E5%A4%84%E7%90%86%E5%B7%A5%E5%85%B7/%E5%A4%9A%E5%AA%92%E4%BD%93%E5%A4%84%E7%90%86%E5%B7%A5%E5%85%B7/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/11_%E5%A4%9A%E5%AA%92%E4%BD%93/%E5%A4%9A%E5%AA%92%E4%BD%93%E5%A4%84%E7%90%86%E5%B7%A5%E5%85%B7/%E5%A4%9A%E5%AA%92%E4%BD%93%E5%A4%84%E7%90%86%E5%B7%A5%E5%85%B7/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://zhuanlan.zhihu.com/p/138863913">知乎，视频录制、视频剪辑、字幕制作&amp;hellip;&amp;hellip;当一名 UP 主需要哪些软件&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>视频录制&lt;/p>
&lt;ul>
&lt;li>OBS Studio&lt;/li>
&lt;/ul>
&lt;p>视频剪辑&lt;/p>
&lt;ul>
&lt;li>Premiere&lt;/li>
&lt;li>Shotcut&lt;/li>
&lt;li>必剪 # B 站的&lt;/li>
&lt;/ul>
&lt;p>字幕制作&lt;/p>
&lt;ul>
&lt;li>听见字幕&lt;/li>
&lt;/ul>
&lt;h1 id="obs-studio">OBS Studio&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://github.com/obsproject/obs-studio">GitHub 项目，obsproject/obs-studio&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://obsproject.com/">官网&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>&lt;strong>Open Broadcaster Software(开放广播软件，简称 OBS)&lt;/strong> 是一款用于视频录制和直播的免费和开源软件&lt;/p>
&lt;h1 id="shotcut">Shotcut&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://github.com/mltframework/shotcut">GitHub 项目，mltframework/shotcut&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://shotcut.org/">官网&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>导出视频：https://jingyan.baidu.com/article/86f4a73e2716ee77d752695a.html&lt;/p>
&lt;h1 id="音频处理">音频处理&lt;/h1>
&lt;h2 id="buzz">Buzz&lt;/h2>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://github.com/chidiwilliams/buzz">GitHub 项目，chidiwilliams/buzz&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.bilibili.com/video/BV1sG411N7RS">B 站，真正的最强字幕神器，离线语音转文字，一键搞定！&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>Buzz 可以在我们的个人计算机上离线转录和翻译音频。由 OpenAI 的 Whisper 提供支持。&lt;/p>
&lt;h1 id="图片处理">图片处理&lt;/h1>
&lt;h2 id="photopea">Photopea&lt;/h2>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://github.com/photopea/photopea">GitHub 项目，photopea/photopea&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.photopea.com/">官网&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>在线图片编辑工具&lt;/p>
&lt;h2 id="photodemon">PhotoDemon&lt;/h2>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://github.com/tannerhelland/PhotoDemon">GitHub 项目，tannerhelland/PhotoDemon&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://photodemon.org/">官网&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>小巧玲珑的图片编辑工具&lt;/p>
&lt;p>图片处理工具&lt;/p>
&lt;h2 id="其他">其他&lt;/h2>
&lt;p>&lt;a href="https://github.com/Sanster/lama-cleaner">Lama Cleaner&lt;/a> # 基于 SOTA AI 模型构建的开源图片处理工具&lt;/p></description></item><item><title>Docs: 解谜计算机科学</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/2.%E7%BC%96%E7%A8%8B/%E8%A7%A3%E8%B0%9C%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E8%A7%A3%E8%B0%9C%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/2.%E7%BC%96%E7%A8%8B/%E8%A7%A3%E8%B0%9C%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E8%A7%A3%E8%B0%9C%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="http://www.yinwang.org/blog-cn/2018/04/13/computer-science">王垠博客，解谜计算机科学&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Category:Computer_science">Wiki 分类，Computer science(计算机科学)&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Category:Computer_programming">Wiki 分类，Computer programming(计算机编程)&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Category:Programming_language_concepts">Wiki 分类，Programming language concepts(编程语言概念)&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Category:Programming_constructs">Wiki 分类，Programming constructs(编程结构)&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Category:Programming_languages">Wiki 分类，Programming languages(编程语言)&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Category:Programming_paradigms">Wiki 分类，Programming paradigms(编程范式)&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Identifier_(computer_languages)">Wiki,Identifier(标识符)&lt;/a>
&lt;ul>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Symbol">Wiki,Symbol(符号)&lt;/a>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Data_type">Wiki,DataType&lt;/a>(数据类型)&lt;/li>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Variable_(computer_science)">Wiki,Variables&lt;/a>(变量)&lt;/li>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Assignment_(computer_science)">Wiki,Assignment&lt;/a>(赋值)&lt;/li>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Declaration_(computer_programming)">Wiki,Declaration(声明) 与 Definition(定义)&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>要掌握一个学科的精髓，不能从细枝末节开始。人脑的能力很大程度上受限于信念。一个人不相信自己的时候，他就做不到本来可能的事。信心是很重要的，信心却容易被挫败。如果只见树木不见森林，人会失去信心，以为要到猴年马月才能掌握一个学科。&lt;/p>
&lt;p>所以我们不从 “树木” 开始，而是引导读者一起来探索这背后的“森林”，把计算机科学最根本的概念用浅显的例子解释，让读者领会到它们的本质。把这些概念稍作发展，你就得到逐渐完整的把握。你一开头就掌握着整个学科，而且一直掌握着它，只不过增添更多细节而已。这就像画画，先勾勒出轮廓，一遍遍的增加细节，日臻完善，却不失去对大局的把握。&lt;/p>
&lt;p>一般计算机专业的学生学了很多课程，可是直到毕业都没能回答一个基础问题：什么是计算？这一章会引导你去发现这个问题的答案。不要小看这基础的问题，它经常是解决现实问题的重要线索。世界上有太多不理解它的人，他们走了很多的弯路，掉进很多的坑，制造出过度复杂或者有漏洞的理论和技术。&lt;/p>
&lt;p>接下来，我们就来理解几个关键的概念，由此接触到计算的本质。&lt;/p>
&lt;h2 id="手指算术">手指算术&lt;/h2>
&lt;p>每个人都做过计算，只是大部分人都没有理解自己在做什么。回想一下幼儿园（大概四岁）的时候，妈妈问你：“帮我算一下，4+3 等于几？” 你掰了一会手指，回答：7。当你掰手指的时候，你自己就是一台简单的计算机。&lt;/p>
&lt;p>不要小看了这手指算术，它蕴含着深刻的原理。计算机科学植根于这类非常简单的过程，而不是复杂的高等数学。&lt;/p>
&lt;p>现在我们来回忆一下这个过程。这里应该有一段动画，但现阶段还没有。请你对每一步发挥一下想象力，增加点 “画面感”。&lt;/p>
&lt;ol>
&lt;li>当妈妈问你 “4+3 等于几” 的时候，她是一个程序员，你是一台计算机。计算机得到程序员的输入：4，+，3。&lt;/li>
&lt;li>听到妈妈的问题之后，你拿出两只手，左手伸出四个指头，右手伸出三个指头。&lt;/li>
&lt;li>接着你开始自己的计算过程。一根根地数那些竖起来的手指，每数一根你就把它弯下去，表示它已经被数过了。你念道：“1，2，3，4，5，6，7。”&lt;/li>
&lt;li>现在已经没有手指伸着，所以你把最后数到的那个数作为答案：7！整个计算过程就结束了。&lt;/li>
&lt;/ol>
&lt;h2 id="identifier标识符-和-model模型">Identifier(标识符) 和 Model(模型)&lt;/h2>
&lt;p>这里的幼儿园手指算术包含着深刻的哲学问题，现在我们来初步体会一下这个问题。&lt;/p>
&lt;p>当妈妈说 “帮我算 4+3” 的时候，4，+，3，三个字符传到你耳朵里，它们都是 &lt;strong>Identifier(标识符)&lt;/strong>，有的时候也称为 &lt;strong>symbol(符号)&lt;/strong>。符号是 “表面” 的东西：光是盯着 “4” 和“3”这两个阿拉伯数字的曲线，一个像旗子，一个像耳朵，你是不能做什么的。你需要先用脑子把它们转换成对应的“模型”（model）。这就是为什么你伸出两只手，一只手表示 4，另一只表示 3。&lt;/p>
&lt;p>这两只手的手势是 “可操作” 的。比如，你把左手再多弯曲一个手指，它就变成 “3”。你再伸开一根手指，它就变成“5”。所以手指是一个相当好的机械模型，它是可以动，可操作的。把符号“4” 和“3”转换成手指模型之后，你就可以开始计算了。&lt;/p>
&lt;p>你怎么知道 “4” 和“3”对应什么样的手指模型呢？因为妈妈以前教过你。十根手指，对应着 1 到 10 十个数。这就是为什么人都用十进制数做算术。&lt;/p>
&lt;p>我们现在没必要深究这个问题。我只是提示你，分清 “符号” 和“模型”是重要的。&lt;/p>
&lt;h2 id="计算图">计算图&lt;/h2>
&lt;p>在计算机领域，我们经常用一些抽象的图示来表达计算的过程，这样就能直观地看到信息的流动和转换。这种图示看起来是一些形状用箭头连接起来。我在这里把它叫做 “计算图”。&lt;/p>
&lt;p>对于以上的手指算术 &lt;code>4 + 3&lt;/code>，我们可以用下图来表示它：&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/85e3436b-9762-45b3-b0bb-38c1f87e416d/adder.png" alt="">&lt;/p>
&lt;p>图中的箭头表示信息的流动方向。说到 “流动”，你可以想象一下水的流动。首先我们看到数字 4 和 3 流进了一个圆圈，圆圈里有一个“+” 号。这个圆圈就是你，一个会做手指加法的小孩。妈妈给你两个数 4 和 3，你现在把它们加起来，得到 7 作为结果。&lt;/p>
&lt;p>注意圆圈的输入和输出方向是由箭头决定的，我们可以根据需要调整那些箭头的位置，只要箭头的连接关系和方向不变就行。它们不一定都是从左到右，也可能从右到左或者从上到下，但 “出入关系” 都一样：4 和 3 进去，结果 7 出来。比如它还可以是这样：&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/85e3436b-9762-45b3-b0bb-38c1f87e416d/adder-topdown.png" alt="">&lt;/p>
&lt;p>我们用带加号的圆圈表示一个 “加法器”。顾名思义，加法器可以帮我们完成加法。在上个例子里，你就是一个加法器。我们也可以用其他装置作为加法器，比如一堆石头，一个算盘，某种电子线路…… 只要它能做加法就行。&lt;/p>
&lt;p>具体要怎么做加法，就像你具体如何掰手指，很多时候我们是不关心的，我们只需要知道这个东西能做加法就行。圆圈把具体的加法操作给 “抽象化” 了，这个蓝色的圆圈可以代表很多种东西。抽象（abstraction）是计算机科学至关重要的思维方法，它帮助我们进行高层面的思考，而不为细节所累。&lt;/p>
&lt;h2 id="expression表达式">Expression(表达式)&lt;/h2>
&lt;p>计算机科学当然不止 4 + 3 这么简单，但它的基本元素确实是如此简单。我们可以创造出很复杂的系统，然而归根结底，它们只是在按某种顺序计算像 4 + 3 这样的东西。&lt;/p>
&lt;p>4 + 3 是一个很简单的表达式（expression）。你也许没听说过 “表达式” 这个词，但我们先不去定义它。我们先来看一个稍微复杂一些的表达式：&lt;/p>
&lt;p>这个表达式比 &lt;code>4 + 3&lt;/code> 多了一个运算，我们把它叫做 “复合表达式”。这个表达式也可以用计算图来表示：&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/85e3436b-9762-45b3-b0bb-38c1f87e416d/add-mult.png" alt="">&lt;/p>
&lt;p>你知道它为什么是这个样子吗？它表示的意思是，先计算 &lt;code>4 + 3&lt;/code>，然后把结果（7）传送到一个 “乘法器”，跟 2 相乘，得到最后的结果。那正好就是 &lt;code>2 * (4 + 3)&lt;/code> 这个表达式的含义，它的结果应该是 14。&lt;/p>
&lt;p>为什么要先计算 &lt;code>4 + 3&lt;/code> 呢？因为当我们看到乘法器 &lt;code>2 * ...&lt;/code> 的时候，其中一个输入（2）是已知的，而另外一个输入必须通过加法器的输出得到。加法器的结果是由 4 和 3 相加得到的，所以我们必须先计算 &lt;code>4 + 3&lt;/code>，然后才能与 2 相乘。&lt;/p>
&lt;p>小学的时候，你也许学过：“括号内的内容要先计算”。其实括号只是 “符号层” 的东西，它并不存在于计算图里面。我这里讲的“计算图”，其实才是本质的东西。数学的括号一类的东西，都只是表象，它们是符号或者叫“语法”。从某种意义上讲，计算图才是表达式的本质或者“模型”，而“2 * (4 + 3)” 这串符号，只是对计算图的一种表示或者 “编码”（coding）。&lt;/p>
&lt;p>这里我们再次体会到了 “符号” 和“模型”的差别。符号是对模型的 “表示” 或者“编码”。我们必须从符号得到模型，才能进行操作。这种从符号到模型的转换过程，在计算机科学里叫做“语法分析”（parsing）。我们会在后面的章节理解这个过程。&lt;/p>
&lt;p>我们现在来给表达式做一个初步的定义。这并不是完整的定义，但你应该试着理解这种定义的方式。稍后我们会逐渐补充这个定义，逐渐完善。&lt;/p>
&lt;p>定义（表达式）：&lt;strong>表达式&lt;/strong>可以是如下几种东西。&lt;/p>
&lt;ol>
&lt;li>数字是一个表达式。比如 1，2，4，15，……&lt;/li>
&lt;li>表达式 + 表达式。两个表达式相加，也是表达式。&lt;/li>
&lt;li>表达式 - 表达式。两个表达式相减，也是表达式。&lt;/li>
&lt;li>表达式 * 表达式。两个表达式相乘，也是表达式。&lt;/li>
&lt;li>表达式 / 表达式。两个表达式相除，也是表达式。&lt;/li>
&lt;/ol>
&lt;p>注意，由于我们之前讲过的符号和模型的差别，为了完全忠于我们的本质认识，这里的 “表达式 + 表达式” 虽然看起来是一串符号，它必须被想象成它所对应的模型。当你看到 “表达式” 的时候，你的脑子里应该浮现出它对应的计算图，而不是一串符号。这个计算图的画面大概是这个样子，其中左边的大方框里可以是任意两个表达式。&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/85e3436b-9762-45b3-b0bb-38c1f87e416d/expression-graph.png" alt="">&lt;/p>
&lt;p>是不是感觉这个定义有点奇怪？因为在 “表达式” 的定义里，我们用到了 “表达式” 自己。这种定义叫做“递归定义”。所谓&lt;strong>递归&lt;/strong>（recursion），就是在一个东西的定义里引用这个东西自己。看上去很奇怪，好像绕回去了一样。递归是一个重要的概念，我们会在将来深入理解它。&lt;/p>
&lt;p>现在我们可以来验证一下，根据我们的定义，&lt;code>2 * (4 + 3)&lt;/code> 确实是一个表达式：&lt;/p>
&lt;ul>
&lt;li>首先根据第一种形式，我们知道 4 是表达式，因为它是一个数字。3 也是表达式，因为它是一个数字。&lt;/li>
&lt;li>所以 &lt;code>4 + 3&lt;/code> 是表达式，因为 &lt;code>+&lt;/code> 的左右都是表达式，它满足表达式定义的第二种形式。&lt;/li>
&lt;li>所以 &lt;code>2 * (4 + 3)&lt;/code> 是表达式，因为 &lt;code>*&lt;/code> 的左右都是表达式，它满足表达式定义的第四种形式。&lt;/li>
&lt;/ul>
&lt;h2 id="parallel-computing并行计算">Parallel Computing(并行计算)&lt;/h2>
&lt;p>考虑这样一个表达式：&lt;/p>
&lt;pre>&lt;code>(4 + 3) * (1 + 2)
&lt;/code>&lt;/pre>
&lt;p>它对应一个什么样的计算图呢？大概是这样：
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/85e3436b-9762-45b3-b0bb-38c1f87e416d/parallel.png" alt="">
如果妈妈只有你一个小孩，你应该如何用手指算出它的结果呢？你大概有两种办法。&lt;/p>
&lt;p>第一种办法：先算出 4+3，结果是 7。然后算出 1+2，结果是 3。然后算 7*3，结果是 21。&lt;/p>
&lt;p>第二种办法：先算出 1+2，结果是 3。然后算出 4+3，结果是 7。然后算 7*3，结果是 21。&lt;/p>
&lt;p>注意到没有，你要么先算 4+3，要么先算 1+2，你不能同时算 4+3 和 1+2。为什么呢？因为你只有两只手，所以算 4+3 的时候你就没法算 1+2，反之也是这样。总之，你妈妈只有你一个加法器，所以一次只能做一个加法。&lt;/p>
&lt;p>现在假设你还有一个妹妹，她跟你差不多年纪，她也会手指算术。妈妈现在就多了一些办法来计算这个表达式。她可以这样做：让你算 4+3，不等你算完，马上让妹妹算 1+2。等到你们的结果（7 和 3）都出来之后，让你或者妹妹算 7*3。&lt;/p>
&lt;p>发现没有，在某一段时间之内，你和妹妹_同时_在做加法计算。这种时间上重叠的计算，叫做&lt;strong>并行计算&lt;/strong>（parallel computing）。&lt;/p>
&lt;p>你和妹妹同时计算，得到结果的速度可能会比你一个人算更快。如果你妈妈还有其它几个孩子，计算复杂的式子就可能快很多，这就是并行计算潜在的好处。所谓 “潜在” 的意思是，这种好处不一定会实现。比如，如果你的妹妹做手指算数的速度比你慢很多，你做完了 4+3，只好等着她慢慢的算 1+2。这也许比你自己依次算 4+3 和 1+2 还要慢。&lt;/p>
&lt;p>即使妹妹做算术跟你一样快，这里还有个问题。你和妹妹算出结果 7 和 3 之后，得把结果传递给下一个计算 7*3 的那个人（也许是你，也许是你妹妹）。这种 “通信” 会带来时间的延迟，叫做“通信开销”。如果你们其中一个说话慢，这比起一个人来做计算可能还要慢。&lt;/p>
&lt;p>如何根据计算单元能力的不同和通信开销的差异，来最大化计算的效率，降低需要的时间，就成为了并行计算领域研究的内容。并行计算虽然看起来是一个 “博大精深” 的领域，可是你如果理解了我这里说的那点东西，就很容易理解其余的内容。&lt;/p>
&lt;h2 id="variable变量-和-assignment赋值">Variable(变量) 和 Assignment(赋值)&lt;/h2>
&lt;p>变量是与关联的&lt;strong>符号名称(变量的标识符)&lt;/strong> 配对的&lt;strong>存储位置(由内存地址标识)&lt;/strong>。这个&lt;strong>存储地址&lt;/strong>其包含称为&lt;strong>值&lt;/strong>的一些已知或未知数量的信息;变量的&lt;strong>存储地址&lt;/strong>是通过一个名叫&lt;strong>指针&lt;/strong>的东西来获取，也是&lt;strong>值&lt;/strong>的一种，指针的&lt;strong>值&lt;/strong>就是其所指向的变量的&lt;strong>存储地址&lt;/strong>；注意：变量的&lt;strong>存储地址的值&lt;/strong>与&lt;strong>存储地址中包含的值&lt;/strong>是两个不同的东西。指针与变量的代码示例&lt;/p>
&lt;p>变量是一个可以改变内容的固定标识符，比如我定义“这台电脑的名字”叫“XXX”，“这台电脑的名字”就是标识符(不变的内容)，存在于计算机的某个位置，“XXX”就是可以改变的内容 i.e.变量的值，给不变的内容定义不同的内容&lt;/p>
&lt;ul>
&lt;li>比如 X=1，X=2，X=3 等等，&lt;strong>X&lt;/strong> 就是不变的，1，2，3 等等都是可变的，X 就是一个变量，可以被赋予某些内容&lt;/li>
&lt;li>比如：&lt;strong>LANG&lt;/strong> 是一个语言的规定，你赋予他一个内容，就相当于定义了这个环境下所显示的语言，比如 LANG=US，LANG=CN 等等。LANG 这叫定义语言，这是不变的，可变的是后面的自定义内容，语言（不变）= 英语，汉语，日语（可变）。&lt;/li>
&lt;/ul>
&lt;p>如果你有一个复杂的表达式，比如&lt;/p>
&lt;pre>&lt;code>(5 - 3) * (4 + (2 * 3 - 5) * 6)
&lt;/code>&lt;/pre>
&lt;p>由于它有比较多的嵌套，人的眼睛是难以看清楚的，它要表达的意义也会难懂。这时候，你希望可以用一些 “名字” 来代表中间结果，这样表达式就更容易理解。&lt;/p>
&lt;p>打个比方，这就像你有一个亲戚，他是你妈妈的表姐的女儿的丈夫。你不想每次都称他 “我妈妈的表姐的女儿的丈夫”，所以你就用他的名字“叮当” 来指代他，一下子就简单了。&lt;/p>
&lt;p>我们来看一个例子。之前的复合表达式&lt;/p>
&lt;p>其实可以被转换为等价的，含有变量的代码：&lt;/p>
&lt;pre>&lt;code>{
a = 4 + 3 // 变量 a 得到 4+3 的值
2 * a // 代码块的值
}
&lt;/code>&lt;/pre>
&lt;p>其中 &lt;code>a&lt;/code> 是一个名字。&lt;code>a = 4 + 3&lt;/code> 是一个 “赋值语句”，它的意思是：用 a 来代表 4 + 3 的值。这种名字，计算机术语叫做 &lt;strong>variable(变量)&lt;/strong>。&lt;/p>
&lt;p>这段代码的意思可以简单地描述为：计算 &lt;code>4 + 3&lt;/code>，把它的结果表示为 &lt;code>a&lt;/code>，然后计算 &lt;code>2 * a&lt;/code> 作为最后的结果。&lt;/p>
&lt;p>有些东西可能扰乱了你的视线。两根斜杠 &lt;code>//&lt;/code> 后面一直到行末的文字叫做 “注释”，是给人看的说明文字。它们对代码的逻辑不产生作用，执行的时候可以忽略。许多语言都有类似这种注释，它们可以帮助阅读的人，但是会被机器忽略。&lt;/p>
&lt;p>这段代码执行过程会是这样：先计算 &lt;code>4 + 3&lt;/code> 得到 7，用 &lt;code>a&lt;/code> 记住这个中间结果 7。接着计算 &lt;code>2 * a&lt;/code> ，也就是计算 &lt;code>2 * 7&lt;/code>，所以最后结果是 14。很显然，这跟 &lt;code>2 * (4 + 3)&lt;/code> 的结果是一样的。&lt;/p>
&lt;p>&lt;code>a&lt;/code> 叫做一个变量，它是一个符号，可以用来代表任意的值。除了 &lt;code>a&lt;/code>，你还有许多的选择，比如 b, c, d, x, y, foo, bar, u21… 只要它不会被误解成其它东西就行。&lt;/p>
&lt;p>如果你觉得这里面的 “神奇” 成分太多，那我们现在来做更深一层的理解……&lt;/p>
&lt;p>再看一遍上面的代码。这整片代码叫做一个 “代码块”（block），或者叫一个 “序列”（sequence）。这个代码块包括两条语句，分别是 &lt;code>a = 4 + 3&lt;/code> 和 &lt;code>2 * a&lt;/code>。代码块里的语句会从上到下依次执行。所以我们先执行 &lt;code>a = 4 + 3&lt;/code>，然后执行 &lt;code>2 * a&lt;/code>。&lt;/p>
&lt;p>最后一条语句 &lt;code>2 * a&lt;/code> 比较特别，它是这个代码块的 “值”，也就是最后结果。之前的语句都是在为生成这个最后的值做准备。换句话说，这整个代码块的值就是 &lt;code>2 * a&lt;/code> 的值。不光这个例子是这样，这是一个通用的原理：代码块的最后一条语句，总是这个代码块的值。&lt;/p>
&lt;p>我们在代码块的前后加上花括号 &lt;code>{...}&lt;/code> 进行标注，这样里面的语句就不会跟外面的代码混在一起。这两个花括号叫做 “边界符”。我们今后会经常遇到代码块，它存在于几乎所有的程序语言里，只是语法稍有不同。比如有些语言可能用括号 &lt;code>(...)&lt;/code> 或者 &lt;code>BEGIN...END&lt;/code> 来表示边界，而不是用花括号。&lt;/p>
&lt;p>这片代码已经有点像常用的编程语言了，但我们暂时不把它具体化到某一种语言。我不想固化你的思维方式。在稍后的章节，我们会把这种抽象的表达法对应到几种常见的语言，这样一来你就能理解几乎所有的程序语言。&lt;/p>
&lt;p>另外还有一点需要注意，同一个变量可以被多次赋值。它的值会随着赋值语句而改变。举个例子：&lt;/p>
&lt;pre>&lt;code>{
a = 4 + 3
b = a
a = 2 * 5
c = a
}
&lt;/code>&lt;/pre>
&lt;p>这段代码执行之后，&lt;code>b&lt;/code> 的值是 7，而 &lt;code>c&lt;/code> 的值是 10。你知道为什么吗？因为 &lt;code>a = 4 + 3&lt;/code> 之后，a 的值是 7。&lt;code>b = a&lt;/code> 使得 &lt;code>b&lt;/code> 得到值 7。然后 &lt;code>a = 2 * 5&lt;/code> 把 &lt;code>a&lt;/code> 的值改变了，它现在是 10。所以 &lt;code>c = a&lt;/code> 使得 &lt;code>c&lt;/code> 得到 10。&lt;/p>
&lt;p>对同一个变量多次赋值虽然是可以的，但通常来说这不是一种好的写法，它可能引起程序的混淆，应该尽量避免。只有当变量表示的 “意义” 相同的时候，你才应该对它重复赋值。&lt;/p>
&lt;h2 id="data-type数据类型">Data type(数据类型)&lt;/h2>
&lt;p>**Data Type(数据类型) **用来对一组相关值进行分类，描述可对其执行的操作并定义它们的存储方式。通常也会称为 &lt;strong>Literal(字面量)&lt;/strong>&lt;/p>
&lt;h2 id="compile编译">Compile(编译)&lt;/h2>
&lt;p>一旦引入了变量，我们就可以不用复合表达式。因为你可以把任意复杂的复合表达式拆开成 “单操作算术表达式”（像 4 + 3 这样的），使用一些变量记住中间结果，一步一步算下去，得到最后的结果。&lt;/p>
&lt;p>举一个复杂点的例子，也就是这一节最开头的那个表达式：&lt;/p>
&lt;pre>&lt;code>(5 - 3) * (4 + (2 * 3 - 5) * 6)
&lt;/code>&lt;/pre>
&lt;p>它可以被转化为一串语句：&lt;/p>
&lt;pre>&lt;code>{
a = 2 * 3
b = a - 5
c = b * 6
d = 4 + c
e = 5 - 3
e * d
}
&lt;/code>&lt;/pre>
&lt;p>最后的表达式 &lt;code>e * d&lt;/code>，算出来就是原来的表达式的值。你观察一下，是不是每个操作都非常简单，不包含嵌套的复合表达式？你可以自己验算一下，它确实算出跟原表达式一样的结果。&lt;/p>
&lt;p>在这里，我们自己动手做了 &lt;strong>compiler(编译器)&lt;/strong> 的工作。通常来说，编译器是一种程序，它的任务是把一片代码“翻译” 成另外一种等价形式。这里我们没有写编译器，可是我们自己做了编译器的工作。我们手动地把一个嵌套的复合表达式，编译成了一系列的简单算术语句。&lt;/p>
&lt;p>这些语句的结果与原来的表达式完全一致。这种保留原来语义的翻译过程，叫做 &lt;strong>compile(编译)&lt;/strong>。&lt;/p>
&lt;p>我们为什么需要编译呢？原因有好几种。我不想在这里做完整的解释，但从这个例子我们可以看到，编译之后我们就不再需要复杂的嵌套表达式了。我们只需要设计很简单的，只会做单操作算术的机器，就可以算出复杂的嵌套的表达式。实际上最后这段代码已经非常接近现代处理器（CPU）的汇编代码（assembly）。我们只需要多加一些转换，它就可以变成机器指令。&lt;/p>
&lt;p>我们暂时不写编译器，因为你还缺少一些必要的知识。这当然也不是编译技术的所有内容，它还包含另外一些东西。但从这一开头，你就已经初步理解了编译器是什么，你只需要在将来加深这种理解。&lt;/p>
&lt;h2 id="function函数">Function(函数)&lt;/h2>
&lt;p>到目前为止，我们做的计算都是在已知的数字之上，而在现实的计算中我们往往有一些未知数。比如我们想要表达一个 “风扇控制器”，有了它之后，风扇的转速总是当前气温的两倍。这个“当前气温” 就是一个未知数。&lt;/p>
&lt;p>我们的 “风扇控制器” 必须要有一个“输入”（input），用于得到当前的温度 t，它是一个温度传感器的读数。它还要有一个输出，就是温度的两倍。&lt;/p>
&lt;p>那么我们可以用这样的方式来表达我们的风扇控制器：&lt;/p>
&lt;p>不要把这想成任何一种程序语言，这只是我们自己的表达法。箭头 &lt;code>-&amp;gt;&lt;/code> 的左边表示输入，右边表示输出，够简单吧。&lt;/p>
&lt;p>你可以把 &lt;code>t&lt;/code> 想象成从温度传感器出来的一根电线，它连接到风扇控制器上，风扇控制器会把它的输入（t）乘以 2。这个画面像这个样子：
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/85e3436b-9762-45b3-b0bb-38c1f87e416d/function1.png" alt="">
我们谈论风扇控制器的时候，其实不关心它的输入是哪里来的，输出到哪里去。如果我们把温度传感器和风扇从画面里拿掉，就变成这个样子：
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/85e3436b-9762-45b3-b0bb-38c1f87e416d/function2.jpg" alt="">
这幅图才是你需要认真理解的函数的计算图。你发现了吗，这幅图画正好对应了之前的风扇控制器的符号表示：&lt;code>t -&amp;gt; t*2&lt;/code>。看到符号就想象出画面，你就得到了符号背后的模型。&lt;/p>
&lt;p>像 &lt;code>t -&amp;gt; t*2&lt;/code> 这样具有未知数作为输入的构造，我们把它叫做 function(函数)。其中 &lt;code>t&lt;/code> 这个符号，叫做这个函数的参数。&lt;/p>
&lt;h2 id="parameter参数-与-variable变量">Parameter(参数) 与 Variable(变量)&lt;/h2>
&lt;p>你可能发现了，函数的参数和我们之前了解的 “变量” 是很类似的，它们都是一个符号。之前我们用了 &lt;code>a, b, c, d, e&lt;/code> 现在我们有一个 &lt;code>t&lt;/code>，这些名字我们都是随便起的，只要它们不要重复就好。如果名字重复的话，可能会带来混淆和干扰。&lt;/p>
&lt;p>其实参数和变量这两种概念不只是相似，它们的本质就是一样的。如果你深刻理解它们的相同本质，你的脑子就可以少记忆很多东西，而且它可能帮助你对代码做出一些有趣而有益的转化。在上一节你已经看到，我用 “电线” 作为比方来帮助你理解参数。你也可以用同样的方法来理解变量。&lt;/p>
&lt;p>比如我们之前的变量 &lt;code>a&lt;/code>：&lt;/p>
&lt;p>它可以被想象成什么样的画面呢？
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/85e3436b-9762-45b3-b0bb-38c1f87e416d/wire.png" alt="">
我故意把箭头方向画成从右往左，这样它就更像上面的代码。从这个图画里，你也许可以看到变量 &lt;code>a&lt;/code> 和风扇控制器图里的参数 &lt;code>t&lt;/code>，其实没有任何本质差别。它们都表示一根电线，那根电线进入乘法器，将会被乘以 2，然后输出。如果你把这些都看成是电路，那么变量 &lt;code>a&lt;/code> 和参数 &lt;code>t&lt;/code> 都代表一根电线而已。&lt;/p>
&lt;p>然后你还发现一个现象，那就是你可以把 &lt;code>a&lt;/code> 这个名字换成任何其它名字（比如 &lt;code>b&lt;/code>），而这幅图不会产生实质的改变。&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/85e3436b-9762-45b3-b0bb-38c1f87e416d/rename.png" alt="">&lt;/p>
&lt;p>这说明什么问题呢？这说明以下的代码（把 &lt;code>a&lt;/code> 换成了 &lt;code>b）&lt;/code>跟之前的是等价的：&lt;/p>
&lt;p>根据几乎一样的电线命名变化，你也可以对之前的函数得到一样的结论：&lt;code>t -&amp;gt; t*2&lt;/code> 和 &lt;code>u -&amp;gt; u*2&lt;/code>，和 &lt;code>x -&amp;gt; x*2&lt;/code> 都是一回事。&lt;/p>
&lt;p>名字是很重要的东西，但它们具体叫什么，对于机器并没有实质的意义，只要它们不要相互混淆就可以。但名字对于人是很重要的，因为人脑没有机器那么精确。不好的变量和参数名会导致代码难以理解，引起程序员的混乱和错误。所以通常说来，你需要给变量和参数起好的名字。&lt;/p>
&lt;p>什么样的名字好呢？我会在后面集中讲解。&lt;/p>
&lt;h2 id="named-function有名字的函数">Named function(有名字的函数)&lt;/h2>
&lt;p>既然变量可以代表 “值”，那么一个自然的想法，就是让变量代表函数。所以就像我们可以写&lt;/p>
&lt;p>我们似乎也应该可以写&lt;/p>
&lt;p>对的，你可以这么做。&lt;code>f = t-&amp;gt;t*2&lt;/code> 还有一个更加传统的写法，就像数学里的函数写法：&lt;/p>
&lt;p>请仔细观察 &lt;code>t&lt;/code> 的位置变化。我们在函数名字的右边写一对括号，在里面放上参数的名字。&lt;/p>
&lt;p>注意，你不可以只写&lt;/p>
&lt;p>你必须明确的指出函数的参数是什么，否则你就不会明白函数定义里的 &lt;code>t&lt;/code> 是什么东西。明确指出 &lt;code>t&lt;/code> 是一个 “输入”，你才会知道它是函数的输入，是一个未知数，&lt;strong>而不是在函数外面定义的其它变量&lt;/strong>。&lt;/p>
&lt;p>这个看似简单的道理，很多数学家都不明白，所以他们经常这样写书：&lt;/p>
&lt;blockquote>
&lt;p>有一个函数 y = x*2&lt;/p>
&lt;/blockquote>
&lt;p>这是错误的，因为他没有明确指出 “&lt;code>x&lt;/code> 是函数 y 的参数”。如果这句话之前他们又定义过 &lt;code>x&lt;/code>，你就会疑惑这是不是之前那个 &lt;code>x&lt;/code>。很多人就是因为这些糊里糊涂的写法而看不懂数学书。这不怪他们，只怪数学家自己对于语言不严谨。&lt;/p>
&lt;h2 id="function-call函数调用">Function call(函数调用)&lt;/h2>
&lt;p>有了函数，我们可以给它起名字，可是我们怎么使用它的值呢？&lt;/p>
&lt;p>由于函数里面有未知数（参数），所以你必须告诉它这些未知数，它里面的代码才会执行，给你结果。比如之前的风扇控制器函数&lt;/p>
&lt;p>它需要一个温度作为输入，才会给你一个输出。于是你就这样给它一个输入：&lt;/p>
&lt;p>你把输入写在函数名字后面的括号里。那么你就会得到输出：4。也就是说 &lt;code>f(2)&lt;/code> 的值是 4。&lt;/p>
&lt;p>如果你没有调用一个函数，函数体是不会被执行的。因为它不知道未知数是什么，所以什么事也做不了。那么我们定义函数的时候，比如&lt;/p>
&lt;p>当看到这个定义的时候，机器应该做什么呢？它只是记录下：有这么一个函数，它的参数是 &lt;code>t&lt;/code>，它需要计算 &lt;code>t*2&lt;/code>，它的名字叫 &lt;code>f&lt;/code>。但是机器不会立即计算 &lt;code>t*2&lt;/code>，因为它不知道 &lt;code>t&lt;/code> 是多少。&lt;/p>
&lt;h2 id="branch分支">Branch(分支)&lt;/h2>
&lt;p>直到现在，我们的代码都是从头到尾，闷头闷脑地执行，不问任何问题。我们缺少一种 “问问题” 的方法。比如，如果我想表达这样一个“食物选择器”：如果气温低于 22 度，就返回 “hotpot” 表示今天吃火锅，否则返回 “ice cream” 表示今天吃冰激凌。&lt;/p>
&lt;p>我们可以把它图示如下：
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/85e3436b-9762-45b3-b0bb-38c1f87e416d/branch.png" alt="">
中间这种判断结构叫做 “分支”（branching），它一般用菱形表示。为什么叫分支呢？你想象一下，代码就像一条小溪，平时它沿着一条路线流淌。当它遇到一个棱角分明的大石头，就分成两个支流，分开流淌。&lt;/p>
&lt;p>我们的判断条件 &lt;code>t &amp;lt; 22&lt;/code> 就像一块大石头，我们的 “代码流” 碰到它就会分开成两支，分别做不同的事情。跟溪流不同的是，这种分支不是随机的，而是根据条件来决定，而且分支之后只有一支继续执行，而另外一边不会被执行。&lt;/p>
&lt;p>我们现在看到的都是图形化表示的模型，为了书写方便，现在我们要从符号的层面来表示这个模型。我们需要一种符号表示法来表达分支，我们把它叫做 &lt;code>if&lt;/code>（如果）。我们的饮料选择器代码可以这样写：&lt;/p>
&lt;pre>&lt;code>t -&amp;gt; if (t &amp;lt; 22)
{
&amp;quot;hotpot&amp;quot;
}
else
{
&amp;quot;ice cream&amp;quot;
}
&lt;/code>&lt;/pre>
&lt;p>它是一个函数，输入是一个温度。&lt;code>if&lt;/code> 后面的括号里放我们的判断条件。后面接着条件成立时执行的代码块，然后是一个 &lt;code>else&lt;/code>，然后是条件不成立时执行的代码。它说：如果温度低于 22 度，我们就吃火锅，否则就吃冰激凌。&lt;/p>
&lt;p>其中的 &lt;code>else&lt;/code> 是一个特殊的符号，它表示 “否则”。看起来不知道为什么 &lt;code>else&lt;/code> 要在那里？对的，它只是一个装饰品。我们已经有足够的表达力来分辨两个分支，不过有了 &lt;code>else&lt;/code> 似乎更加好看一些。很多语言里面都有 else 这个标记词在那里，所以我也把它放在那里。&lt;/p>
&lt;p>这只是一个最简单的例子，其实那两个代码块里面不止可以写一条语句。你可以有任意多的语句，就像这样：&lt;/p>
&lt;pre>&lt;code>t -&amp;gt;
if (t &amp;lt; 22)
{
a = 4 + 3
b = a * 2
&amp;quot;hotpot&amp;quot;
}
else
{
x = &amp;quot;ice cream&amp;quot;
x
}
&lt;/code>&lt;/pre>
&lt;p>这段代码和之前是等价的，你知道为什么吗？&lt;/p>
&lt;h2 id="declaration声明-与-definition定义">Declaration(声明) 与 Definition(定义)&lt;/h2>
&lt;p>上面描述了很多计算机科学的基本要素，那么上面那么多字的描述，是如何定义的呢？~不定义一个东西，是没法使用它的~~~&lt;/p>
&lt;p>在计算机编程中，&lt;strong>Declaration(声明)&lt;/strong> 是一种语言结构，用以指定 Identifier(标识符) 的属性，i.e.声明一个词(标识符)代表什么，也就是说，将 Identifier(标识符) 绑定到某种概念上。&lt;/p>
&lt;blockquote>
&lt;p>比如，用白话说就是：我声明，A 表示一个函数、B 表示一个字符串类型的变量，等等&lt;/p>
&lt;/blockquote>
&lt;p>Declaration 最常用于函数、变量、常量、类型定义 等等。Declaration 用于向编译器宣布实体的存在，在某些强类型的编程语言中，使用 函数、变量、常量 等等要素之前需要先 Declaration 它们，再使用比如 为变量赋值、调用函数 等等)。&lt;/p>
&lt;p>在某些场景下，&lt;strong>Declaration(声明)&lt;/strong> 与 &lt;strong>Definition(定义)&lt;/strong> 这两个词比较容易混淆。&lt;/p>
&lt;ul>
&lt;li>在非正式用法中
&lt;ul>
&lt;li>Declaration 纯指声明(仅类型，无值或主体)&lt;/li>
&lt;li>Definition 指包含值或主体的声明。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>在正式使用中
&lt;ul>
&lt;li>Declaration 包含非正式用法中的两种含义。在 Declaration 的同时，有的时候我们会为标识符定义一个初始值。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>上面的描述，把定义当做了赋值的行为。实际上，Definition 还有另外一种行为含义，这种行为应该是在 Declaration 之前的。比如下面的例子：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>// 这里我们定义了一个类型与函数。定义时，指定了这些东西应该具有的属性
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>definition string XXXXX
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>definition func YYYYY
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>// 这里我们声明了一个类型与函数。
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>// 标识符A 绑定到了字符串
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>// 标识符B 绑定到了函数
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>var identifierA string
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>func iderntifierB&lt;span style="color:#f92672">(){&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Do Something
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>// 此时我们可以使用这些已经声明的标识符
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>stringType &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#34;Hello World&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>DefinitionFunc&lt;span style="color:#f92672">()&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>也就是说，Definition(定义) 这个词更符合人类的日常用于，定义一个事物，就是对这个事物进行总结，就好比科学，我们通过观察自然界的现象，来定义一个科学定律，然后通过定律推导出定理。总结一下就是：&lt;/p>
&lt;ul>
&lt;li>&lt;strong>Definition 用来指定 Type(类型)。不管是编程语言自带的基本类型，还是符合类型，甚至是自己自定义的类型，都称为“定义类型”&lt;/strong>&lt;/li>
&lt;li>&lt;strong>Declaration 用来指定 Identifier(标识符)，并将该 Identifier(标识符) 绑定到 Type(类型) 上。称为“声明标识符”&lt;/strong>&lt;/li>
&lt;/ul>
&lt;p>但是，在现代中，Declaration 与 Definition 经常会混用，经常会有人说：定义类型、声明类型、定义变量、声明变量、定义函数、声明函数 等等等等。&lt;/p>
&lt;p>比如，当我们使用一个未声明的变量时，某些编程语言经常会提示 undefined(未定义)~~~~o(╯□╰)o 其实，更准确的提示应该是 undeclared。&lt;/p>
&lt;blockquote>
&lt;p>说的就是你，Go 语言，Declaration 与 Definition 不分~~~
不过除了这个编译器的错误提示有歧义以外，其它描述基本都是准确的，绝大部分都是 Declaration(声明)，只有一个地方用到了 Definition(定义)，主要就是在 &lt;a href="https://go.dev/ref/spec#Type_declarations">Go 的参考&lt;/a>中，可以看到 Type Declaration 与 Type Definition 之间的区别。也就是说，只有在描述一个新的类型时，才称为“定义类型”&lt;/p>
&lt;ul>
&lt;li>比如 &lt;code>type XXXX struct&lt;/code>，我们就称为 &lt;strong>定义结构体&lt;/strong>，&lt;code>var structID XXXX&lt;/code>，我们就称为&lt;strong>声明 XXXX 类型结构体。&lt;/strong>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>后记：
其实，定义类型这个行为，再扩展一下，也可以称为建模，这是[面向对象编程](/docs/IT学习笔记/2.编程/解谜计算机科学/Object-oriented%20Programming(面向对象编程).md Programming(面向对象编程).md)的基本要素。人们通过对现实世界的观察、总结，定义了很多基本类型，比如 数字、字符串、布尔 等等。这些基本类型都是一个个已经建立好的模型，只不过是最基本的，而我们可以使用这些基本模型，建立更复杂的模型。所以，定义类型 这个行为，从某种角度来看，就是建立模型。&lt;/p>
&lt;h1 id="计算的要素">计算的要素&lt;/h1>
&lt;p>好了，现在你已经掌握了计算机科学的几乎所有基本要素。每一个编程语言都包括这些构造：&lt;/p>
&lt;ul>
&lt;li>基础的数值。比如整数，字符串，布尔值等。&lt;/li>
&lt;li>表达式。包括基本的算术表达式，嵌套的表达式。&lt;/li>
&lt;li>变量和赋值语句。&lt;/li>
&lt;li>分支语句。&lt;/li>
&lt;li>函数和函数调用。&lt;/li>
&lt;/ul>
&lt;p>你也许可以感觉到，我是把这些构造按照 “从小到大” 的顺序排列的。这也许可以帮助你的理解。&lt;/p>
&lt;p>现在你可以回想一下你对它们的印象。每当学习一种新的语言或者系统，你只需要在里面找到对应的构造，而不需要从头学习。这就是掌握所有程序语言的秘诀。这就像学开车一样，一旦你掌握了油门，刹车，换挡器，方向盘，速度表的功能和用法，你就学会了开所有的汽车，不管它是什么型号的汽车。&lt;/p>
&lt;p>我们在这一章不仅理解了这些要素，而且为它们定义了一种我们自己的 “语言”。显然这个语言只能在我们的头脑里运行，因为我们没有实现这个语言的系统。在后面的章节，我会逐渐的把我们这种语言映射到现有的多种语言里面，然后你就能掌握这些语言了。&lt;/p>
&lt;p>但是请不要以为掌握了语言就学会了编程或者学会了计算机科学。掌握语言就像学会了各种汽车部件的工作原理。几分钟之内，初学者就能让车子移动，转弯，停止。可是完了之后你还需要学习交通规则，你需要许许多多的实战练习和经验，掌握各种复杂情况下的策略，才能成为一个合格的驾驶员。如果你想成为赛车手，那就还需要很多倍的努力。&lt;/p>
&lt;p>但是请不要被我这些话吓到了，你没有那么多的竞争者。现在的情况是，世界上就没有很多合格的计算机科学驾驶员，更不要说把车开得流畅的赛车手。绝大部分的 “程序员” 连最基本的引擎，油门，刹车，方向盘的工作原理都不明白，思维方式就不对，所以根本没法独自上路，一上路就出车祸。很多人把过错归结在自己的车身上，以为换一辆车马上就能成为好的驾驶员。这是一种世界范围的计算机教育的失败。&lt;/p>
&lt;p>在后面的章节，我会引导你成为一个合格的驾驶员，随便拿一辆车就能开好。&lt;/p>
&lt;h1 id="什么是计算">什么是计算&lt;/h1>
&lt;p>现在你掌握了计算所需要的基本元素，可是什么是计算呢？我好像仍然没有告诉你。这是一个很哲学的问题，不同的人可能会告诉你不同的结果。我试图从最广义的角度来告诉你这个问题的答案。&lt;/p>
&lt;p>当你小时候用手指算 &lt;code>4+3&lt;/code>，那是计算。如果后来你学会了打算盘，你用算盘算 4+3，那也是计算。后来你从我这里学到了表达式，变量，函数，调用，分支语句…… 在每一新的构造加入的过程中，你都在了解不同的计算。&lt;/p>
&lt;p>所以从最广义来讲，计算就是 “机械化的信息处理”。所谓机械化，你可以用手指算，可以用算盘，可以用计算器，或者计算机。这些机器里面可以有代码，也可以没有代码，全是电子线路，甚至可以是生物活动或者化学反应。不同的机器也可以有不同的计算功能，不同的速度和性能……&lt;/p>
&lt;p>有这么多种计算的事实不免让人困惑，总害怕少了点什么，其实你可以安心。如果你掌握了上一节的 “计算要素”，那么你就掌握了几乎所有类型的计算系统所需要的东西。你在后面所需要做的只是加深这种理解，并且把它“对应” 到现实世界遇到的各种计算机器里面。&lt;/p>
&lt;p>为什么你可以相信计算机科学的精华就只有这些呢？因为计算就是处理信息，信息有它诞生的位置（输入设备，固定数值），它传输的方式（赋值，函数调用，返回值），它被查看的地方（分支）。你想不出对于信息还有什么其它的操作，所以你就很安心的相信了，这就是计算机科学这种 “棋类游戏” 的全部规则。&lt;/p>
&lt;p>（如果你觉得这篇文章有启发，可以点击这里&lt;a href="http://www.yinwang.org/blog-cn/2016/04/13/pay-blog">付费&lt;/a>）&lt;/p></description></item><item><title>Docs: 日志系统</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/6.%E5%8F%AF%E8%A7%82%E6%B5%8B%E6%80%A7/%E6%97%A5%E5%BF%97%E7%B3%BB%E7%BB%9F/%E6%97%A5%E5%BF%97%E7%B3%BB%E7%BB%9F/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/6.%E5%8F%AF%E8%A7%82%E6%B5%8B%E6%80%A7/%E6%97%A5%E5%BF%97%E7%B3%BB%E7%BB%9F/%E6%97%A5%E5%BF%97%E7%B3%BB%E7%BB%9F/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Syslog">Wiki,Syslog&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://datatracker.ietf.org/doc/html/rfc5424">RFC 5424&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;h2 id="背景">背景&lt;/h2>
&lt;p>在系统上，不管是系统本身还是外部程序，在开始、运行、结束的一整套过程中，都会产生信息，这些信息包括:何时、何地(来源 IP)、何人(什么程序)、发生了什么事情等。i.e.记录系统在什么时候由哪个程序做了什么样的行为时，发生了何种事件等等。而发生的事情又有等级的区别，哪些信息是危险的，哪些信息是标准可以不用关注的等。这些信息就统称为日志(Log)。随着时代发展，操作系统、程序、硬件设备等等都会产生日志，如此众多的日志需要一个标准来进行定义，这个日志标准就是 &lt;strong>Syslog Protocol&lt;/strong>，由 IETF 给定的 RFC 5424 规范来执行。而在 IT 行业，一般也把各个事务所生成的日志称为 syslog。&lt;/p>
&lt;h2 id="日志的生成">日志的生成&lt;/h2>
&lt;p>操作系统、进程和应用程序的编写者完全清楚他们将生成的事件。在某些情况下，生成消息用来说明状态。可以是一段时间一次，也可以由其他方式触发，例如在程序退出时。在其他情况下，消息是由遇到的条件产生的。在这些情况下，不管是状态消息或者包含一些类型的警告都可能被产生。操作系统、进程和应用程序的编写者可能会在详单中确定消息的数量。这些详单中通常包括发出消息的设备，同时包含消息的严重级别。这样，操作员可以有选择地筛选消息，可以更快的定位更加重要的和有处理时间限制的消息，同时可以将状态或消息信息放在文件中，将来阅读他们。其他显示和保存信息的方式也可以存在。&lt;/p>
&lt;p>必须在设备中配置一些规则，这些规则可以告诉设备显示还是转发事件消息。这些规则是十分灵活的。管理员可能希望所有的信息都保存在本地，同时所有高优先级的消息都会转发到另一台设备中。他们可能发现，将某些设备的信息发送到一些或所有用户的设备中，同时显示在系统控制台上是很合适的。然而，管理员决定将事件信息发送到 syslog 采集器中，在采集器中包含了组成设备的信息以及发送的严重级别，同时定义了远程接收器。例如，系统管理员可能想让所有由邮件设备发出的消息被转发到一个特定的事件信息采集器中。管理员还可以让所有内核生成的事件信息被发送到另一台 syslog 接收器中，同时，将内核产生的 critical 严重级别的消息发送到第三台设备中。同时，将显示在系统控制台中的信息 email 给部分用户，同时将他们保存在设备本地磁盘的文件中。反之，可以将本地进程产生的消息显示在控制台中，但不保存也不转发。所有事件的规则都在设备中生成。因为管理员知道 collector 会收集到哪种类型的事件，他们会在 syslog 服务器中配置相应的规则。&lt;/p>
&lt;p>消息的内容因创建者而异。建议将消息按照一定格式编写，这样人们就可以阅读他们。在消息中加入时间戳和发出消息的设备以及进程的标识符是一个很好的建议。但他们都不是必须的。&lt;/p>
&lt;p>假设任何进程和设备都有可能产生事件消息。可能包含没有任何本地存储空间的设备，例如打印机、路由器、集线器、交换机以及无盘工作站。在这种情况下，将事件消息传送到 collector 可能是必要的，以便操作者可以记录并希望看到它们。&lt;/p>
&lt;h2 id="日志的收集">日志的收集&lt;/h2>
&lt;p>日志收集起来，才能方便管理人员进行查看并进行故障排除。如此众多事物的日志如果想要统一管理，就需要一套程序来对所有事物的日志进行收集、处理、保存、过滤、分析等，可以实现该功能的程序有以下几个：&lt;/p>
&lt;ul>
&lt;li>sysLog 程序与 syslog 标准重名，是早期的 Linux 用于处理系统上所有事物日志的程序&lt;/li>
&lt;li>RsysLog 是 sysLog 的升级版&lt;/li>
&lt;li>ELK/EFK 是很重量级，功能很全的 3 款程序的统称
&lt;ul>
&lt;li>Eleasticsearch 是一个存储系统和搜索引擎&lt;/li>
&lt;li>logstash、Fluentd 日志收集&lt;/li>
&lt;li>kibana 日志的前端展示&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h2 id="日志的生成与收集的通用流程">日志的生成与收集的通用流程&lt;/h2>
&lt;p>当一个程序生成日志后，一般调用一个 output() 函数，把生成的日志输出到某处，e.g.文件、内存、STDOUT 等&lt;/p>
&lt;p>而日志采集程序一般会调用一个 input() 函数，来从某处获取日志，然后再调用 output() 函数来把日志转发或转存&lt;/p>
&lt;h1 id="the-syslog-protocol系统日志协议--即-syslog-规范">The Syslog Protocol(系统日志协议) # 即 syslog 规范&lt;/h1>
&lt;p>每个程序如果产生的日志格式都不一样，也不便于收集归档，更不便于分类查看，所以需要一个统的规范，这个规范包括可收集哪些程序的日志、日志的格式、级别的定义等&lt;/p>
&lt;h2 id="架构">架构&lt;/h2>
&lt;p>Syslog Protocol 采用分层架构设计，共分为 3 层&lt;/p>
&lt;ul>
&lt;li>&amp;ldquo;syslog content&amp;rdquo; syslog 内容层。is the management information contained in a syslog message.&lt;/li>
&lt;li>&amp;ldquo;syslog application&amp;quot;syslog 应用程序层。处理系统日志消息的生成、解释、路由、存储&lt;/li>
&lt;li>&amp;ldquo;syslog transport&amp;quot;syslog 传输层。将消息放到 puts messages on the wire and takes them off the wire.&lt;/li>
&lt;/ul>
&lt;p>每层架构中都会执行某些类型的功能&lt;/p>
&lt;ul>
&lt;li>originator：发起者。生成将要在消息中携带的 syslog 内容&lt;/li>
&lt;li>collector：采集器。收集 syslog 内容以供进一步分析&lt;/li>
&lt;li>relay：中继。转发消息，接收来自 originators 或其他 relaysd 的消息，并将其发送给 collectors 或其他 relays&lt;/li>
&lt;li>transport sender：传输发送器。将 syslog 消息传递给特定的传输协议&lt;/li>
&lt;li>transport receiver：传输接收器。从特定的传输协议获取 syslog 消息&lt;/li>
&lt;/ul>
&lt;h2 id="syslog-信息的构成格式">syslog 信息的构成格式&lt;/h2>
&lt;p>每个程序在编写的都时候都会定义日志格式，大部分都会遵循“syslog”标准。不同事物的日志格式不尽相同，详情请见相关事物的文档，不过一般情况下，日志内容都应该包含，时间，某物，在哪，做了什么。&lt;/p>
&lt;p>The Syslog Protocol 规定了每条 syslog 信息应该包含如下内容：&lt;/p>
&lt;p>HEADER Structured-Data [MSG] # 头部信息，结构化数据，消息主体&lt;/p>
&lt;ul>
&lt;li>HEADER=PRI VERSION TIMESTAMP HOSTNAME # 优先级、版本、时间出、主机名
&lt;ul>
&lt;li>PRI=Facility*8+Severity # Priority 优先级是一个值，计算方式通过两部分计算，“Facility 设施”与“Severity 严重性”。具体见本章下文具体描述&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Structured-Data= #&lt;/li>
&lt;/ul>
&lt;h3 id="facility设施">Facility(设施)&lt;/h3>
&lt;p>Facility 用来表示产生该信息的硬件设备、协议、系统软件、操作系统等可以产生日志消息的事物类别。由于世界上事物太多，所以最好以类别的方式来对各个事务进行分类，所以使用 &lt;strong>Facility(设施)&lt;/strong> 来描述。比如&lt;code>security/authorization&lt;/code>这个设施中就包含很多关于安全认证的应用程序产生的日志类别。&lt;/p>
&lt;p>每个 Facility 都对应一个值以便进行 PRI 的计算，以下是 RFC5424 中规定的几十类 Facility。其中括号中的数字表示 Facility 对应的 Numerical Code(数字码)。&lt;/p>
&lt;ul>
&lt;li>&lt;strong>kernel messages(0)&lt;/strong> # 内核信息类&lt;/li>
&lt;li>&lt;strong>user-level messages(1)&lt;/strong> # 用户层信息类，比如用户使用 logger 命令来记录日志功能&lt;/li>
&lt;li>&lt;strong>mail system(2)&lt;/strong> # 邮件系统类型&lt;/li>
&lt;li>&lt;strong>system daemons(3)&lt;/strong> # 系统守护进程类，比如 systemd 管理的服务的信息。&lt;/li>
&lt;li>&lt;strong>security/authorization messages(4)&lt;/strong> # 安全与认证信息类，比如 login、ssh、su 等需要账号密码的。&lt;/li>
&lt;li>&lt;strong>messages generated internally by syslogd(5)&lt;/strong> # 由 syslog 相关协议产生的信息类，就是 rsyslog 程序本身的日志信息。&lt;/li>
&lt;li>&lt;strong>line printer subsystem(6)&lt;/strong> # 打印子系统类&lt;/li>
&lt;li>&lt;strong>network news subsystem(7)&lt;/strong> #&lt;/li>
&lt;li>&lt;strong>UUCP subsystem(8)&lt;/strong> #&lt;/li>
&lt;li>&lt;strong>clock daemon(9)&lt;/strong> #&lt;/li>
&lt;li>&lt;strong>security/authorization messages(10)&lt;/strong> #&lt;/li>
&lt;li>&lt;strong>FTP daemon(11)&lt;/strong> # FTP&lt;/li>
&lt;li>&lt;strong>NTP subsystem(12)&lt;/strong> # NTP 子系统&lt;/li>
&lt;li>&lt;strong>log audit(13)&lt;/strong> # 日志审计&lt;/li>
&lt;li>&lt;strong>log alert(14)&lt;/strong> # 日志报警&lt;/li>
&lt;li>&lt;strong>clock daemon(note 2)(15)&lt;/strong> #&lt;/li>
&lt;li>&lt;strong>local use 0~7 (local0~7)(16~23)&lt;/strong> # 留给用户自定义的类别，比如可以把某些程序归为 Local0~7 中的某一类，然后来收集该类的日志&lt;/li>
&lt;/ul>
&lt;h3 id="severity">Severity&lt;/h3>
&lt;p>Severity 用来表示该日志信息的严重程度，也叫日志的级别 Level。为了便于日志管理，需要对日志的内容进行划分，哪些信息是正常的，哪些信息是错误的，哪些信息是警告等等。一般情况分为以下几类，其中第一列数字表示对应的 Severity 的值，第二列为 Severity 的名称以及其所描述的严重程度的具体概念。以下严重程度由高到底进行排列，debug 属于特殊的 Severity&lt;/p>
&lt;ul>
&lt;li>0 Emergency: 系统不可用 system is unusable&lt;/li>
&lt;li>1 Alert: 必须立即采取行动 action must be taken immediately&lt;/li>
&lt;li>2 Critical: 临界状态 critical conditions&lt;/li>
&lt;li>3 Error: 错误状态 error conditions&lt;/li>
&lt;li>4 Warning: 警告状态 warning conditions&lt;/li>
&lt;li>5 Notice: 正常但是值得注意的状态 normal but significant condition&lt;/li>
&lt;li>6 Informational: 信息 informational messages&lt;/li>
&lt;li>7 Debug: debug 级别的信息 debug-level messages&lt;/li>
&lt;/ul>
&lt;h1 id="常见日志级别">常见日志级别&lt;/h1>
&lt;p>Emergency ( 紧急 ): 关于 SYN 攻击、Tear Drop 攻击及 Ping of Death 攻击的消息。
Alert ( 警示 ): 关于需要立即引起注意的情况 ( 例如防火墙攻击和许可密钥到期 ) 的消息。
Critical (关键 ): 关于可能影响设备功能的情况 [例如高可用性 (HA) 状态更改 ]的消息。
Error (错误): 关于可能影响设备功能的错误情况 (例如反病毒扫描失败或与 SSH 服务器通信失败) 的消息。
Warning( 警告 ):关于可能影响设备功能的情况(例如连接到电子邮件服务器失败或认证失败、超时和成功)的消息。
Notification (通知 ): 关于常规事件 ( 包括由 admin 发起的配置更改 ) 的消息。
Information ( 信息 ): 可提供关于系统操作一般信息的消息。
Debugging ( 调试 ): 可提供调试时所用详细信息的消息。&lt;/p></description></item><item><title>Docs: 系统审计</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E7%B3%BB%E7%BB%9F%E5%AE%A1%E8%AE%A1/%E7%B3%BB%E7%BB%9F%E5%AE%A1%E8%AE%A1/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E7%B3%BB%E7%BB%9F%E5%AE%A1%E8%AE%A1/%E7%B3%BB%E7%BB%9F%E5%AE%A1%E8%AE%A1/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/7/html/security_guide/chap-system_auditing">红帽产品文档，RedHat7-安全指南-第 7 章 系统审计&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>Linux 审计系统提供了一种方式来跟踪系统中的安全相关信息。根据预配置的规则，审计会生成日志条目，以记录有关系统上发生事件的尽可能多的信息。对于关键任务环境而言，此信息对于确定安全策略的违反者及其执行的操作至关重要。Audit 不会为您的系统提供额外的安全性，而是可用于发现系统上使用的安全策略违规。通过 SELinux 等其他安全措施可以进一步阻止这些冲突。&lt;/p>
&lt;p>以下列表总结了审计可以在其日志文件中记录的一些信息：&lt;/p>
&lt;ul>
&lt;li>事件的日期和时间、类型和结果.&lt;/li>
&lt;li>主题和对象的敏感度标签。&lt;/li>
&lt;li>事件与触发事件的用户的身份相关联。&lt;/li>
&lt;li>对 Audit 配置的所有修改，并尝试访问 Audit 日志文件。&lt;/li>
&lt;li>所有身份验证机制的使用，如 SSH 和 Kerberos 等。&lt;/li>
&lt;li>对任何受信任数据库的更改，如 /etc/passwd.&lt;/li>
&lt;li>尝试从系统导入或导出信息.&lt;/li>
&lt;li>根据用户身份、主题和对象标签以及其他属性，包含或排除事件。&lt;/li>
&lt;/ul>
&lt;p>使用审计系统也是许多安全相关认证的一项要求。审计旨在满足或超过以下认证或合规指南的要求：&lt;/p>
&lt;ul>
&lt;li>受控访问保护配置文件(CAPP)&lt;/li>
&lt;li>标记的安全保护配置文件(LSPP)&lt;/li>
&lt;li>规则集基本访问控制(RSBAC)&lt;/li>
&lt;li>国家工业安全计划操作手册(NISPOM)&lt;/li>
&lt;li>联邦信息安全管理法案(FISMA)&lt;/li>
&lt;li>支付卡行业 - 数据安全标准(PCI-DSS)&lt;/li>
&lt;li>安全技术实施指南(STIG)&lt;/li>
&lt;/ul>
&lt;p>审计还包括：&lt;/p>
&lt;ul>
&lt;li>由国家信息保障合作伙伴(NIAP)和最佳安全行业(BSI)评估。&lt;/li>
&lt;li>通过红帽企业 Linux 5 上的 LSPP/CAPP/RSBAC/EAL4+ 认证.&lt;/li>
&lt;li>红帽企业 Linux 6 上经过操作系统保护配置文件/评估保证级别 4+(OSPP/EAL4+)认证.&lt;/li>
&lt;/ul>
&lt;h3 id="使用案例">使用案例&lt;/h3>
&lt;p>&lt;strong>监视文件访问&lt;/strong> # 审计可以跟踪文件或目录是否已访问、修改、执行或文件属性是否已更改。例如，这可用于检测对重要文件的访问，并在其中一个文件损坏时提供审计跟踪。&lt;/p>
&lt;p>&lt;strong>监控系统调用&lt;/strong> # 可将审计配置为在每次使用特定系统调用时生成日志条目。例如，这可用于通过监控 settimeofday、clock_adjtime 和其他时间相关系统调用来跟踪系统时间的更改。&lt;/p>
&lt;p>&lt;strong>记录用户运行的命令&lt;/strong> # 审计可以跟踪文件是否已执行，因此可以定义规则以记录特定命令的每次执行。例如，可以为 /bin 目录中的每个可执行文件定义规则。然后，可以按用户 ID 搜索生成的日志条目，以生成每个用户所执行命令的审计跟踪。&lt;/p>
&lt;p>&lt;strong>记录系统路径名称的执行&lt;/strong> # 除了观察在规则调用时转换索引节点路径的文件访问之外，审计现在还可以观察路径的执行，即使路径在规则调用中不存在，或者在规则调用后替换了文件。这允许规则在升级程序可执行文件或甚至安装之前继续运行。&lt;/p>
&lt;p>&lt;strong>记录安全事件&lt;/strong> # pam_faillock 身份验证模块能够记录失败的登录尝试。也可以将审计设置为记录失败的登录尝试，并提供试图登录的用户的附加信息。&lt;/p>
&lt;p>&lt;strong>搜索事件&lt;/strong> # Audit 提供 ausearch 实用程序，可用于过滤日志条目并根据多个条件提供完整的审计跟踪。&lt;/p>
&lt;p>&lt;strong>运行摘要报告&lt;/strong> # aureport 实用程序可用于生成记录的事件的日常报告等。然后，系统管理员可以分析这些报告，并进一步调查可疑活动。&lt;/p>
&lt;p>&lt;strong>监控网络访问&lt;/strong> # iptables 和 ebtables 实用程序可以配置为触发审计事件，使系统管理员能够监控网络访问。&lt;/p></description></item><item><title>Docs: 字符的编码与解码</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/8.%E9%80%9A%E7%94%A8%E6%8A%80%E6%9C%AF/%E7%BC%96%E7%A0%81%E8%A7%A3%E7%A0%81%E4%B8%8E%E5%8D%8F%E8%AE%AE/%E5%AD%97%E7%AC%A6%E7%9A%84%E7%BC%96%E7%A0%81%E4%B8%8E%E8%A7%A3%E7%A0%81/%E5%AD%97%E7%AC%A6%E7%9A%84%E7%BC%96%E7%A0%81%E4%B8%8E%E8%A7%A3%E7%A0%81/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/8.%E9%80%9A%E7%94%A8%E6%8A%80%E6%9C%AF/%E7%BC%96%E7%A0%81%E8%A7%A3%E7%A0%81%E4%B8%8E%E5%8D%8F%E8%AE%AE/%E5%AD%97%E7%AC%A6%E7%9A%84%E7%BC%96%E7%A0%81%E4%B8%8E%E8%A7%A3%E7%A0%81/%E5%AD%97%E7%AC%A6%E7%9A%84%E7%BC%96%E7%A0%81%E4%B8%8E%E8%A7%A3%E7%A0%81/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Character_encoding">Wiki,Character encoding&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/ASCII">Wiki-ASCII&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Unicode">Wiki-Unicode&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://home.unicode.org/">Unicode 官网&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://unicode.org/main.html">Unicode 技术网站&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.unicode.org/charts/unihan.html">Unicode 字符集汉子数据库&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Variable-length_code">Wiki,Variable-length code&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/UTF-8">Wiki-UTF-8&lt;/a>&lt;/li>
&lt;li>&lt;a href="http://www.ruanyifeng.com/blog/2007/10/ascii_unicode_and_utf-8.html">阮一峰博客&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://mp.weixin.qq.com/s/vTh4LP8_Qew-S8s-3KqwJA">公众号,k8s 技术圈-计算机字符编码的前世今生&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.bilibili.com/video/av246038798">B 站,Golang 合辑-P1 string(这个 P 讲的就是字符的编码与解码)&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>我们知道计算机只认识二进制数据，其他格式的数据都需要转换成二进制才能被计算机处理，也就是说我们在计算机上看到的文本、视频、可执行程序等格式的文件，最终都会转换成二进制数据交给计算机处理&lt;/p>
&lt;p>计算机中最小的数据单位是 &lt;strong>bit&lt;/strong>，也叫&lt;strong>二进制位(简称：位)&lt;/strong>，每一个 bit 都有 0 和 1 两种状态，最早的计算机在设计时采用了 &lt;strong>8 个 bit 作为一个 Byte(字节)&lt;/strong>，所以一个字节能表示的最大整数就是二进制的 11111111 等于十进制的 255，一共 256 个数字(即.0~255)，想要表示更大的整数就必须要用多个字节，例如两个字节可以表示最大的整数就是二进制的 1111111111111111，共 16 位，等于十进制的 65535。&lt;/p>
&lt;p>更多的字节，就可以表示更大的数值范围，比如 32 位，最大可以表示为 4,294,967,295，我们平时说的 32 位电脑、64 位电脑，也是同一个意思，所以就说 32 位电脑，没法传输 4 G 以上的文件，就是因为其最大可以表示的数字就是 4,294,967,295，更大的文件，已经无法识别了。整数可以这么表示，那么字符怎么办呢？一堆二进制的 0 和 1，任何计算都无法算出字母 A 吧？~o(╯□╰)o&lt;/p>
&lt;p>聪明的人类啊~~~如果无法通过计算得到，那么就中转一下，人为规定就好了~比如：&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>字符&lt;/th>
&lt;th>十进制编号&lt;/th>
&lt;th>二进制编号&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>A&lt;/td>
&lt;td>65&lt;/td>
&lt;td>0100 0001&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>B&lt;/td>
&lt;td>66&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&amp;hellip;&amp;hellip;&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>a&lt;/td>
&lt;td>97&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&amp;hellip;&amp;hellip;&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>要存储字符时，就存储这个数值；要读取字符时，按照映射关系，找到这个字符；就像这样，收录许多字符，然后给它们一一编号，得到一个字符与编号的对照表，这就是 &lt;strong>Character sets(字符集)&lt;/strong>，经过这么多年的发展，大家对这个术语有很多种叫法：Character encoding(字符编码)、Character map(字符映射)、Code page(代码页) 都可以表示同一个概念。&lt;/p>
&lt;h1 id="ascii">ASCII&lt;/h1>
&lt;p>由于计算机是由美国人发明的，在 1967 年美国人制订了一套&lt;strong>字符集&lt;/strong>，规定了包含大小写字母、数字和一些符号共计 128 个字符与二进制数字的对应关系，这一套字符编码被称为 &lt;strong>American Standard Code for Information Interchange(美国标准信息交换码，简称 ASCII)&lt;/strong>，ASCII 一直沿用至今。&lt;/p>
&lt;p>英文比较简单，用 128 个符号编码就够了，就算需要其他的对应关系，也只需要扩展一下 ASCII 即可，一个 Byte，一共可以表示 256 个字符。但是用来表示中文就不够了，单单汉字就有超过 8 万个，所以就有了针对中文的编码标准出现，例如我们经常见到的 GB2312 字符集，使用两个字节表示一个汉字，理论上最多可以表示 65535 个；没有繁体字也不行啊，所以出现了 BIG 5 字符集；但是依然有许多字符没被收录。&lt;/p>
&lt;p>世界上有上百种语言，每种语言都有自己的编码标准，例如韩文编码 EUC_KR，日文编码 Shift_JIS，俄文编码 KOI8-R，为了促进互联网的发展，本着全球化统一标准的目的，制作一个通用字符集，&lt;strong>Unicode 应运而生。&lt;/strong>&lt;/p>
&lt;h1 id="unicode">Unicode&lt;/h1>
&lt;p>**Universal Coded Character Set(通用编码的字符集，简称 Unicode)，&lt;strong>在汉语中又称为&lt;/strong> 万国码、国际码、统一码，**它于 1990 年开始研发，并于 1994 年正式公布。&lt;strong>Unicode&lt;/strong> 对世界上大部分的文字系统进行了整理，使每一个文字符号都用独一无二的编码表示，当前 Unicode 最新的版本为 2019 年 5 月公布的 12.1.0，已经收录超过 13 万个字符，很明显 2 个字节已经无法保证所有字符都独一无二了，实际上最新的 Unicode 规定可以占用 4 字节来表示一个字符，理论上最多能表示 231 共计 2147483648 个字符。&lt;/p>
&lt;p>Unicode 使用 16 进制格式来表示一个字符，比如：
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/gptlcx/1616470249845-a210b975-ff93-4945-ba7e-aa06332e2473.png" alt="image.png">
&lt;code>\u&lt;/code> 是一个用来表示 Unicode 的标记。当计算机识别到这个标记时，就会使用 Unicode 进行解码。&lt;code>4f60&lt;/code> 表示 &lt;code>你&lt;/code>，&lt;code>597d&lt;/code> 表示 &lt;code>好&lt;/code>。&lt;/p>
&lt;p>所以随着技术的发展，Unicode 慢慢成为了一种 &lt;strong>Unicode Standard(Unicode 标准)&lt;/strong>&lt;/p>
&lt;h2 id="unicode-的问题">Unicode 的问题&lt;/h2>
&lt;p>需要注意的是，Unicode 只是一个字符集，它只规定了符号的二进制代码，却没有规定这个二进制代码应该如何存储。&lt;/p>
&lt;p>比如，汉字 &lt;code>严&lt;/code> 的 Unicode 是十六进制数 &lt;code>4E25&lt;/code>，转换成二进制数足足有 15 个 bit 位(&lt;code>100111000100101&lt;/code>)，也就是说，这个符号的表示至少需要 2 个字节。表示其他更大的符号，可能需要 3 个字节或者 4 个字节，甚至更多。&lt;/p>
&lt;p>这里就有两个严重的问题，第一个问题是，如何才能区别 Unicode 和 ASCII ？计算机怎么知道三个字节表示一个符号，而不是分别表示三个符号呢？第二个问题是，我们已经知道，英文字母只用一个字节表示就够了，如果 Unicode 统一规定，每个符号用三个或四个字节表示，那么每个英文字母前都必然有二到三个字节是 0，这对于存储来说是极大的浪费，文本文件的大小会因此大出二三倍，这是无法接受的。&lt;/p>
&lt;p>它们造成的结果是：&lt;/p>
&lt;ul>
&lt;li>出现了 Unicode 的多种存储方式，也就是说有许多种不同的二进制格式，可以用来表示 Unicode。&lt;/li>
&lt;li>Unicode 在很长一段时间内无法推广，直到互联网的出现。&lt;/li>
&lt;/ul>
&lt;p>其中一种 Unicode 的存储方式如下：
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/gptlcx/1636861654037-a5bcf9bc-3a12-4958-b308-71955c77229d.png" alt="image.png">
上图左侧的几个字符，通过字符集找到对应的二进制编号之后，你怎么知道这一大串二进制内容，就是 &lt;code>eggo世界&lt;/code> 这几个字符呢？&lt;/p>
&lt;p>正常来说是这样的：
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/gptlcx/1636861731027-04bdc7aa-cedd-456a-abd9-e07793eff7ed.png" alt="image.png">
但是，也可以这样啊：
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/gptlcx/1636861748931-7e8aa489-51ae-4b25-bba2-efe7ec588bc7.png" alt="image.png">&lt;/p>
&lt;p>这里面的主要问题，就是 **划分字符边界。**所以，我们需要一种编码规则，通过字符集中的对照关系，对二进制进行编码。&lt;/p>
&lt;p>那么可以这样，不管编号多大多小，统一按照最长的来，位数不够，高位补零，效果如下：
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/gptlcx/1636861872939-a637432d-a70e-4606-b7e8-b9d50450b19b.png" alt="image.png">
这种方式，&lt;strong>Fixed-length codes(固定长度编码)&lt;/strong>。虽然字符边界的问题解决了，但是。。。。。这么存数据。。。非常浪费内存啊。。。。&lt;/p>
&lt;p>互联网的普及，强烈要求出现一种统一的编码方式。既然&lt;strong>固定长度编码&lt;/strong>不行，咱就来个 &lt;strong>Variable length code(可变长度编码)。&lt;/strong>&lt;/p>
&lt;p>**UTF-8 **就是在互联网上使用最广的一种 &lt;strong>Unicode 的编码规则&lt;/strong>。其他实现方式还包括 UTF-16（字符用两个字节或四个字节表示）和 UTF-32（字符用四个字节表示），不过在互联网上基本不用。&lt;/p>
&lt;h2 id="utf">UTF&lt;/h2>
&lt;p>&lt;strong>Unicode Transformation Formats(Unicode 转换格式，简称 UTF) 是&lt;/strong>根据 Unicode 实现的一种编码&lt;strong>规则&lt;/strong>。&lt;/p>
&lt;p>Unicode 标准定义了 &lt;strong>Unicode Transformation Formats(Unicode 转换格式，简称 UTF)&lt;/strong>。UTF-8、UTF-16、UTF-32 以及其他几种编码。最常用的编码是 UTF-8&lt;/p>
&lt;h3 id="utf-8">UTF-8&lt;/h3>
&lt;p>UTF-8 最大的一个特点，它是一种变长的编码方式。它可以使用 1~4 个 Bytes 表示一个字符(最多 32 个 bit)，根据不同的符号而变化字节长度。&lt;/p>
&lt;p>UTF-8 顾名思义，是一套以 8 位为一个编码单位的可变长编码。会&lt;strong>将一个 &amp;ldquo;Unicom 编号&amp;rdquo; 重新编码为 1 到 4 个字节&lt;/strong>&lt;/p>
&lt;p>既然是可变长度编码，那么小编号的字符就要少占字节，大编号的多占字节，但是，怎么划分字符的边界呢？有这么一种方案：&lt;/p>
&lt;p>UTF -8 首先定义一组模板，规范如下：&lt;/p>
&lt;ul>
&lt;li>首先获取到该字符的 Unicom 编号，然后根据该字符编号，决定对字符编码时所使用的模板，每个字符编码后存储时，所使用的 &amp;ldquo;Bytes 数&amp;rdquo; 不同&lt;/li>
&lt;li>如果字符需要存储 1 Bytes，则，字节的第一位设为 0。
&lt;ul>
&lt;li>后面 7 位为这个符号的 Unicode 码。因此对于英语字母，UTF-8 编码和 ASCII 码是相同的。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>如果字符需要存储 n Bytes(&lt;code>n &amp;gt; 1&lt;/code>)，则一个字节的前 n 个 bit 位都设为 1，第 n + 1 bit 位 设为 0，后面字节的前 两 bit 位 一律设为 10。
&lt;ul>
&lt;li>剩下的没有提及的二进制位，全部为这个符号的 Unicode 码。
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>Unicom 编号&lt;/th>
&lt;th>字节数&lt;/th>
&lt;th>最高位标识位&lt;/th>
&lt;th>模板(二进制)&lt;/th>
&lt;th>模板(十六进制)&lt;/th>
&lt;th>模板可以填充的 bit 数&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>0~127&lt;/td>
&lt;td>1 Bytes&lt;/td>
&lt;td>0&lt;/td>
&lt;td>0???????&lt;/td>
&lt;td>0000 0000-0000 007F&lt;/td>
&lt;td>7&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>128~2047&lt;/td>
&lt;td>2 Bytes&lt;/td>
&lt;td>110 和 10&lt;/td>
&lt;td>110????? 10??????&lt;/td>
&lt;td>0000 0080-0000 07FF&lt;/td>
&lt;td>5 + 6&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>2048~65535&lt;/td>
&lt;td>3 Bytes&lt;/td>
&lt;td>1110 和 10 和 10&lt;/td>
&lt;td>1110???? 10?????? 10??????&lt;/td>
&lt;td>0000 0800-0000 FFFF&lt;/td>
&lt;td>4 + 6 + 6&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>65536~4294967295&lt;/td>
&lt;td>4 Bytes&lt;/td>
&lt;td>11110 和 10 和 10 和 10&lt;/td>
&lt;td>11110??? 10?????? 10?????? 10??????&lt;/td>
&lt;td>0001 0000-0010 FFFF&lt;/td>
&lt;td>3 + 6 + 6 + 6&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>跟据上表，解读 UTF-8 编码非常简单。如果一个 Bytes 的第一个 bit 是 0，则这个字节单独就是一个字符；如果第一位是 1，则连续有多少个 1，就表示当前字符占用多少个字节。&lt;/p>
&lt;p>比如：&lt;/p>
&lt;ul>
&lt;li>&lt;code>01100101&lt;/code> 最高位为 0，则表示这是一个只占 1 Bytes 的字符，并且是在 0~127 编号范围内的字符。
&lt;ul>
&lt;li>除去标识 bit，剩下的 7 bit 就是该字符的二进制编号，即 &lt;code>1100101&lt;/code>，十进制是 &lt;code>101&lt;/code>，十六进制是 &lt;code>0065&lt;/code>，也就是字符 &lt;code>e&lt;/code>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;code>11100100 10111000 10010110&lt;/code> 最高位是 1110，则表示这是一个占用 3 bytes 的字符，并且要和后面两个以 10 开头的字节共同表示一个字符，并且是在 2048~65535 编号范围内的字符。
&lt;ul>
&lt;li>除去标识 bit，剩下的 bit 组合起来，即 &lt;code>01001110 00010110&lt;/code>，十进制是 &lt;code>19990&lt;/code>，十六进制是 &lt;code>4E16&lt;/code> ，也就是字符 &lt;code>世&lt;/code>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>字符 &lt;code>界&lt;/code> 在 Unicode 中的编号为 &lt;code>30028&lt;/code>，十六进制是 &lt;code>754C&lt;/code>，二进制是 &lt;code>01110101 01001100&lt;/code>，也就是说，如果想要使用 UTF-8 对字符编码后储存，则应该占用 3 Byes，所以应该使用 &lt;code>1110???? 10?????? 10??????&lt;/code> 模板。
&lt;ul>
&lt;li>将 &lt;code>界&lt;/code> 的二进制 bit 填入到模板中，得到 &lt;code>**1110**0111 **10**010101 **10**001100&lt;/code>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h3 id="总结">总结&lt;/h3>
&lt;p>虽然使用 UTF-8 对字符进行编码后，依然会浪费一部分 bit，但是对比&lt;a href="#DRcSC">定长编码&lt;/a>，已经极大得节省了存储空间。&lt;/p>
&lt;h2 id="unicode-与-utf-的区别">Unicode 与 UTF 的区别&lt;/h2>
&lt;p>简单来说：&lt;/p>
&lt;ul>
&lt;li>Unicode 是 字符集，即字符与编号的对应关系&lt;/li>
&lt;li>UTF 是 编码规则&lt;/li>
&lt;/ul>
&lt;p>其中：&lt;/p>
&lt;ul>
&lt;li>字符集：为每一个「字符」分配一个唯一的 ID（学名为码位 / 码点 / Code Point）&lt;/li>
&lt;li>编码规则：将「码位」转换为字节序列的规则&lt;/li>
&lt;/ul>
&lt;p>广义的 Unicode 是一个标准，定义了一个字符集以及一系列的编码规则，即 Unicode 字符集和 UTF-8、UTF-16、UTF-32 等等编码规则……&lt;/p>
&lt;p>Unicode 字符集为每一个字符分配一个编号，例如「知」的 Unicom 编号是 30693，记作 U+77E5（30693 的十六进制为 0x77E5）。&lt;/p>
&lt;p>UTF-8 顾名思义，是一套以 8 位为一个编码单位的可变长编码。会将一个编号重新编码为 1 到 4 个字节：&lt;/p>
&lt;pre>&lt;code>U+ 0000 ~ U+ 007F: 0XXXXXXX
U+ 0080 ~ U+ 07FF: 110XXXXX 10XXXXXX
U+ 0800 ~ U+ FFFF: 1110XXXX 10XXXXXX 10XXXXXX
U+10000 ~ U+10FFFF: 11110XXX 10XXXXXX 10XXXXXX 10XXXXXX
&lt;/code>&lt;/pre>
&lt;p>根据上表中的编码规则，之前的「知」字的码位 U+77E5 属于第三行的范围：&lt;/p>
&lt;pre>&lt;code>7 7 E 5
0111 0111 1110 0101 二进制的 77E5
--------------------------
0111 011111 100101 二进制的 77E5
1110XXXX 10XXXXXX 10XXXXXX 模版（上表第三行）
11100111 10011111 10100101 代入模版
E 7 9 F A 5
&lt;/code>&lt;/pre>
&lt;p>这就是将 U+77E5 按照 UTF-8 编码为字节序列 E79FA5 的过程。反之亦然。&lt;/p>
&lt;h1 id="乱码的出现">乱码的出现&lt;/h1>
&lt;p>从上边的编码介绍中我们已经知道了不同编码的存在，那么想要查看一个文件，就必须知道他的编码方式，用错误的编码方式打开文件就会出现乱码。
linux 下可以通过 file 命令查看文件的编码方式&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>root@lichenhao:~# touch encoding_file
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>root@lichenhao:~# file encoding_file
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>encoding_file: empty
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>root@lichenhao:~# echo &lt;span style="color:#e6db74">&amp;#34;hello world!&amp;#34;&lt;/span> &amp;gt; encoding_file
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>root@lichenhao:~# file encoding_file
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>encoding_file: ASCII text
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>root@lichenhao:~# echo &lt;span style="color:#e6db74">&amp;#34;你好，世界！&amp;#34;&lt;/span> &amp;gt;&amp;gt; encoding_file
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>root@lichenhao:~# file encoding_file
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>encoding_file: UTF-8 Unicode text
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>工作中我们在 XSHELL 之类的终端中查看文件时出现的乱码就是系统或文件保存的中文编码与终端设置的编码不一致，从而导致解码错误。这里涉及到三方编码：&lt;/p>
&lt;ol>
&lt;li>文件内容或文件名&lt;/li>
&lt;li>SHELL 环境的语言编码&lt;/li>
&lt;li>XSHELL 之类的终端编码&lt;/li>
&lt;/ol>
&lt;p>需要保持三方编码统一，才不会有乱码的出现，其中 SHELL 环境的语言编码指的是登陆服务器的 SHELL 环境时指定的语言编码，例如 LANG、LC_*这些变量设置的编码，XSHELL 之类终端编码就是这类终端软件设置的编码
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/gptlcx/1616053185837-0c93a28f-6155-47e3-9cf4-bbb563b402c1.jpeg" alt="">
所有遇到的乱码问题都仔细检查以上三方编码是否一致，就可以顺利解决了，同时也建议在工作中制定相应的规范，减少乱码的发生&lt;/p>
&lt;p>此时，我现在将 Xshell 中的编码规则变为其他的
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/gptlcx/1616475169200-5248e6d0-2b70-47f6-9a88-5f7c46a4758c.png" alt="image.png">
此时再看这个文件，就发现，已经无法正确解码了:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>root@lichenhao:~# cat encoding_file
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>hello world!
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>浣??ソ锛???????
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="乱码处理技巧">乱码处理技巧&lt;/h2>
&lt;ol>
&lt;li>临时切换命令输出语言
正常情况下命令的输出结果都遵循系统设置的语言编码，例如&lt;/li>
&lt;/ol>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>root@ops-coffee:~# echo $LANG
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>zh_CN.UTF-8
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>root@ops-coffee:~# date
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>2020年 03月 04日 星期三 19:00:55 HKT
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>root@ops-coffee:~# export LANG&lt;span style="color:#f92672">=&lt;/span>en_US.UTF-8
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>root@ops-coffee:~# echo $LANG
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>en_US.UTF-8
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>root@ops-coffee:~# date
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Wed Mar &lt;span style="color:#ae81ff">4&lt;/span> 19:01:21 HKT &lt;span style="color:#ae81ff">2020&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>运维脚本中，我们希望所有系统执行相同命令的时候输出的结果一致，不要因为字符集不同而产生不同的结果，那么如可处理呢？在命令前添加 LC_ALL=C&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>root@ops-coffee:~# date
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>2020年 03月 04日 星期三 19:05:58 HKT
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>root@ops-coffee:~# LC_ALL&lt;span style="color:#f92672">=&lt;/span>C date
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Wed Mar &lt;span style="color:#ae81ff">4&lt;/span> 19:06:05 HKT &lt;span style="color:#ae81ff">2020&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>这里之所以用 LC_ALL 是因为在 LOCALE 标准中，LC_ALL 优先级最高：LC_ALL&amp;gt;LC_*&amp;gt;LANG&lt;/p>
&lt;ol start="2">
&lt;li>批量转换文件名编码&lt;/li>
&lt;/ol>
&lt;p>有时候我们会遇到文件名或者目录名乱码的问题，尤其是在不同类型系统之间传输时，可以借助 rsync 实现批量转换文件名或目录名的编码
rsync -av &amp;ndash;iconv=GBK,UTF8 /www/ /nav/
iconv 模块在 rsync 的 3.0 以后版本中才支持，用法为&amp;ndash;iconv=,，需要注意的是，本地两个目录之间同步时 LOCAL 表示的是源目录的文件名编码，通过网络同步时 LOCAL 表示本地编码&lt;/p></description></item><item><title>Docs: Containerd 部署</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/10.%E4%BA%91%E5%8E%9F%E7%94%9F/2.2.%E5%AE%9E%E7%8E%B0%E5%AE%B9%E5%99%A8%E7%9A%84%E5%B7%A5%E5%85%B7/containerd/containerd-%E9%83%A8%E7%BD%B2/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/10.%E4%BA%91%E5%8E%9F%E7%94%9F/2.2.%E5%AE%9E%E7%8E%B0%E5%AE%B9%E5%99%A8%E7%9A%84%E5%B7%A5%E5%85%B7/containerd/containerd-%E9%83%A8%E7%BD%B2/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://github.com/containerd/containerd/blob/main/docs/getting-started.md">GitHub 文档，containerd/containerd/docs/getting-started.md&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;h1 id="安装-containerd">安装 Containerd&lt;/h1>
&lt;p>是否需要 libseccomp2 依赖？待验证&lt;/p>
&lt;h2 id="使用包管理器安装">使用包管理器安装&lt;/h2>
&lt;h3 id="centos">CentOS&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>yum install -y yum-utils device-mapper-persistent-data lvm2
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>yum-config-manager --add-repo http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>yum install -y containerd.io
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="ubuntu">Ubuntu&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>sudo apt-get -y install apt-transport-https ca-certificates curl gnupg-agent software-properties-common
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>curl -fsSL https://mirrors.aliyun.com/docker-ce/linux/ubuntu/gpg | sudo apt-key add -
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>sudo add-apt-repository &lt;span style="color:#e6db74">&amp;#34;deb [arch=amd64] https://mirrors.aliyun.com/docker-ce/linux/ubuntu &lt;/span>&lt;span style="color:#66d9ef">$(&lt;/span>lsb_release -cs&lt;span style="color:#66d9ef">)&lt;/span>&lt;span style="color:#e6db74"> stable&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>sudo apt-get -y update
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>sudo apt-get -y install containerd.io
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="配置-unit-文件">配置 unit 文件&lt;/h3>
&lt;p>略&lt;/p>
&lt;h2 id="使用二进制文件安装">使用二进制文件安装&lt;/h2>
&lt;p>通常，我们使用二进制安装 Containerd 时，除了 Containerd 的本体，还需要安装 runc 与 CNI。&lt;/p>
&lt;p>注意：在 1.6.0 版本的更新说明中，对 Releases 中的包进行一些调整，将在未来的 2.0 版本之后弃用一些东西&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/gg4dmt/1654268589875-dff18ee5-d643-489f-9c13-b8bc1dd4e99d.png" alt="image.png">&lt;/p>
&lt;p>这里说的主要是对那些整合包的弃用，让 containerd 的 realease 更纯粹，那些带着 cni 或 cri 的整合包，都没有了。并且，根据 1.6 版本的官方文档的安装说明，CRI 功能已经整合在 containerd 中，所以更无须下载整合包了。&lt;/p>
&lt;h3 id="安装-containerd-1">安装 Containerd&lt;/h3>
&lt;p>在 &lt;a href="https://github.com/containerd/containerd/releases">release&lt;/a> 页面下载二进制程序压缩包，解压并将二进制程序放到 $PATH 中&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>export ARCH&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;amd64&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>export CONTAINER_VERSION&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;1.6.16&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>export OS&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;linux&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>wget https://github.com/containerd/containerd/releases/download/v&lt;span style="color:#e6db74">${&lt;/span>CONTAINER_VERSION&lt;span style="color:#e6db74">}&lt;/span>/containerd-&lt;span style="color:#e6db74">${&lt;/span>CONTAINER_VERSION&lt;span style="color:#e6db74">}&lt;/span>-&lt;span style="color:#e6db74">${&lt;/span>OS&lt;span style="color:#e6db74">}&lt;/span>-&lt;span style="color:#e6db74">${&lt;/span>ARCH&lt;span style="color:#e6db74">}&lt;/span>.tar.gz
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>tar Cxzvf /usr/local containerd-&lt;span style="color:#e6db74">${&lt;/span>CONTAINER_VERSION&lt;span style="color:#e6db74">}&lt;/span>-&lt;span style="color:#e6db74">${&lt;/span>OS&lt;span style="color:#e6db74">}&lt;/span>-&lt;span style="color:#e6db74">${&lt;/span>ARCH&lt;span style="color:#e6db74">}&lt;/span>.tar.gz
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="安装-runc">安装 runc&lt;/h3>
&lt;p>从 &lt;a href="https://github.com/opencontainers/runc/releases">GitHub 项目，opencontainers/runc 的 Releases&lt;/a> 处下载 &lt;code>runc.&amp;lt;ARCH&amp;gt;&lt;/code> 二进制文件，拷贝到 &lt;code>/usr/local/sbin/runc&lt;/code> 处&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>export ARCH&lt;span style="color:#f92672">=&lt;/span>amd64
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>cp runc.&lt;span style="color:#e6db74">${&lt;/span>ARCH&lt;span style="color:#e6db74">}&lt;/span> /usr/local/sbin/runc &lt;span style="color:#f92672">&amp;amp;&amp;amp;&lt;/span> chmod &lt;span style="color:#ae81ff">755&lt;/span> /usr/local/sbin/runc
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="安装-cni-插件">安装 CNI 插件&lt;/h3>
&lt;p>从 &lt;a href="https://github.com/containernetworking/plugins/releases">GitHub 项目，containernetworking/plugins 的 Releases&lt;/a> 处下载 &lt;code>cni-plugins-&amp;lt;OS&amp;gt;-&amp;lt;ARCH&amp;gt;-&amp;lt;VERSION&amp;gt;.tgz&lt;/code> 文件，解压到 &lt;code>/opt/cni/bin/&lt;/code> 目录下&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>export OS&lt;span style="color:#f92672">=&lt;/span>linux
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>export ARCH&lt;span style="color:#f92672">=&lt;/span>amd64
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>export VERSION&lt;span style="color:#f92672">=&lt;/span>v1.1.1
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>mkdir -p /opt/cni/bin
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>tar Cxzvf /opt/cni/bin cni-plugins-&lt;span style="color:#e6db74">${&lt;/span>OS&lt;span style="color:#e6db74">}&lt;/span>-&lt;span style="color:#e6db74">${&lt;/span>ARCH&lt;span style="color:#e6db74">}&lt;/span>-&lt;span style="color:#e6db74">${&lt;/span>VERSION&lt;span style="color:#e6db74">}&lt;/span>.tgz
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="配置-unit-文件-1">配置 Unit 文件&lt;/h3>
&lt;p>从 &lt;a href="https://github.com/containerd/containerd/blob/main/containerd.service">GitHub 项目文件，containerd/containerd/containerd.service&lt;/a> 中下载用于 Systemd 的 Unit 文件。(对于 cri-containerd-&amp;hellip;. 类型的 release 压缩文件中包含 Unit 文件)&lt;/p>
&lt;p>这是一个 1.4.4 版本的 continerd.service 文件样例：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">[&lt;/span>Unit&lt;span style="color:#f92672">]&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Description&lt;span style="color:#f92672">=&lt;/span>containerd container runtime
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Documentation&lt;span style="color:#f92672">=&lt;/span>https://containerd.io
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>After&lt;span style="color:#f92672">=&lt;/span>network.target local-fs.target
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">[&lt;/span>Service&lt;span style="color:#f92672">]&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>ExecStartPre&lt;span style="color:#f92672">=&lt;/span>-/sbin/modprobe overlay
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>ExecStart&lt;span style="color:#f92672">=&lt;/span>/usr/local/bin/containerd
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Type&lt;span style="color:#f92672">=&lt;/span>notify
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Delegate&lt;span style="color:#f92672">=&lt;/span>yes
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>KillMode&lt;span style="color:#f92672">=&lt;/span>process
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Restart&lt;span style="color:#f92672">=&lt;/span>always
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>RestartSec&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">5&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># Having non-zero Limit*s causes performance problems due to accounting overhead&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># in the kernel. We recommend using cgroups to do container-local accounting.&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>LimitNPROC&lt;span style="color:#f92672">=&lt;/span>infinity
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>LimitCORE&lt;span style="color:#f92672">=&lt;/span>infinity
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>LimitNOFILE&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">1048576&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># Comment TasksMax if your systemd version does not supports it.&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># Only systemd 226 and above support this version.&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>TasksMax&lt;span style="color:#f92672">=&lt;/span>infinity
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>OOMScoreAdjust&lt;span style="color:#f92672">=&lt;/span>-999
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">[&lt;/span>Install&lt;span style="color:#f92672">]&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>WantedBy&lt;span style="color:#f92672">=&lt;/span>multi-user.target
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h1 id="配置并启动-containerd">配置并启动 Containerd&lt;/h1>
&lt;h2 id="添加-containerd-配置文件">添加 containerd 配置文件&lt;/h2>
&lt;p>通过命令生成配置文件&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>containerd config default &amp;gt; /etc/containerd/config.toml
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="修改内核参数">修改内核参数&lt;/h2>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>cat &amp;gt; /etc/sysctl.d/containerd.conf &lt;span style="color:#e6db74">&amp;lt;&amp;lt; EOF
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">net.ipv4.ip_forward = 1
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">EOF&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>sysctl -p /etc/sysctl.d/*
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="启动-containerd">启动 containerd&lt;/h2>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>systemctl daemon-reload
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>systemctl enable containerd --now
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h1 id="rootless-模式">rootless 模式&lt;/h1>
&lt;p>强烈推荐开启 cgroup v2，否则最好不要使用 rootless 模式，开启参考：https://rootlesscontaine.rs/getting-started/common/cgroup2/&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">[&lt;/span>INFO&lt;span style="color:#f92672">]&lt;/span> Checking RootlessKit functionality
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">[&lt;/span>INFO&lt;span style="color:#f92672">]&lt;/span> Checking cgroup v2
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">[&lt;/span>WARNING&lt;span style="color:#f92672">]&lt;/span> Enabling cgroup v2 is highly recommended, see https://rootlesscontaine.rs/getting-started/common/cgroup2/
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">[&lt;/span>INFO&lt;span style="color:#f92672">]&lt;/span> Checking overlayfs
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">[&lt;/span>INFO&lt;span style="color:#f92672">]&lt;/span> Requirements are satisfied
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">[&lt;/span>INFO&lt;span style="color:#f92672">]&lt;/span> Creating &lt;span style="color:#e6db74">&amp;#34;/home/lichenhao/.config/systemd/user/containerd.service&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">[&lt;/span>INFO&lt;span style="color:#f92672">]&lt;/span> Starting systemd unit &lt;span style="color:#e6db74">&amp;#34;containerd.service&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>+ systemctl --user start containerd.service
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>+ sleep &lt;span style="color:#ae81ff">3&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>+ systemctl --user --no-pager --full status containerd.service
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>● containerd.service - containerd &lt;span style="color:#f92672">(&lt;/span>Rootless&lt;span style="color:#f92672">)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Loaded: loaded &lt;span style="color:#f92672">(&lt;/span>/home/lichenhao/.config/systemd/user/containerd.service; disabled; vendor preset: enabled&lt;span style="color:#f92672">)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Active: active &lt;span style="color:#f92672">(&lt;/span>running&lt;span style="color:#f92672">)&lt;/span> since Mon 2021-09-13 21:48:44 CST; 3s ago
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Main PID: &lt;span style="color:#ae81ff">2625&lt;/span> &lt;span style="color:#f92672">(&lt;/span>rootlesskit&lt;span style="color:#f92672">)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> CGroup: /user.slice/user-1000.slice/user@1000.service/containerd.service
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ├─2625 rootlesskit --state-dir&lt;span style="color:#f92672">=&lt;/span>/run/user/1000/containerd-rootless --net&lt;span style="color:#f92672">=&lt;/span>slirp4netns --mtu&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">65520&lt;/span> --slirp4netns-sandbox&lt;span style="color:#f92672">=&lt;/span>auto --slirp4netns-seccomp&lt;span style="color:#f92672">=&lt;/span>auto --disable-host-loopback --port-driver&lt;span style="color:#f92672">=&lt;/span>builtin --copy-up&lt;span style="color:#f92672">=&lt;/span>/etc --copy-up&lt;span style="color:#f92672">=&lt;/span>/run --copy-up&lt;span style="color:#f92672">=&lt;/span>/var/lib --propagation&lt;span style="color:#f92672">=&lt;/span>rslave /usr/local/bin/containerd-rootless.sh
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ├─2635 /proc/self/exe --state-dir&lt;span style="color:#f92672">=&lt;/span>/run/user/1000/containerd-rootless --net&lt;span style="color:#f92672">=&lt;/span>slirp4netns --mtu&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">65520&lt;/span> --slirp4netns-sandbox&lt;span style="color:#f92672">=&lt;/span>auto --slirp4netns-seccomp&lt;span style="color:#f92672">=&lt;/span>auto --disable-host-loopback --port-driver&lt;span style="color:#f92672">=&lt;/span>builtin --copy-up&lt;span style="color:#f92672">=&lt;/span>/etc --copy-up&lt;span style="color:#f92672">=&lt;/span>/run --copy-up&lt;span style="color:#f92672">=&lt;/span>/var/lib --propagation&lt;span style="color:#f92672">=&lt;/span>rslave /usr/local/bin/containerd-rootless.sh
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ├─2651 slirp4netns --mtu &lt;span style="color:#ae81ff">65520&lt;/span> -r &lt;span style="color:#ae81ff">3&lt;/span> --disable-host-loopback --enable-sandbox --enable-seccomp &lt;span style="color:#ae81ff">2635&lt;/span> tap0
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> └─2659 containerd
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>9月 &lt;span style="color:#ae81ff">13&lt;/span> 21:48:44 hw-cloud-xngy-jump-server-linux-2 containerd-rootless.sh&lt;span style="color:#f92672">[&lt;/span>2659&lt;span style="color:#f92672">]&lt;/span>: time&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;2021-09-13T21:48:44.601967589+08:00&amp;#34;&lt;/span> level&lt;span style="color:#f92672">=&lt;/span>info msg&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;loading plugin \&amp;#34;io.containerd.grpc.v1.cri\&amp;#34;...&amp;#34;&lt;/span> type&lt;span style="color:#f92672">=&lt;/span>io.containerd.grpc.v1
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>9月 &lt;span style="color:#ae81ff">13&lt;/span> 21:48:44 hw-cloud-xngy-jump-server-linux-2 containerd-rootless.sh&lt;span style="color:#f92672">[&lt;/span>2659&lt;span style="color:#f92672">]&lt;/span>: time&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;2021-09-13T21:48:44.602049316+08:00&amp;#34;&lt;/span> level&lt;span style="color:#f92672">=&lt;/span>info msg&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;Start cri plugin with config {PluginConfig:{ContainerdConfig:{Snapshotter:overlayfs DefaultRuntimeName:runc DefaultRuntime:{Type: Engine: PodAnnotations:[] ContainerAnnotations:[] Root: Options:map[] PrivilegedWithoutHostDevices:false BaseRuntimeSpec:} UntrustedWorkloadRuntime:{Type: Engine: PodAnnotations:[] ContainerAnnotations:[] Root: Options:map[] PrivilegedWithoutHostDevices:false BaseRuntimeSpec:} Runtimes:map[runc:{Type:io.containerd.runc.v2 Engine: PodAnnotations:[] ContainerAnnotations:[] Root: Options:map[BinaryName: CriuImagePath: CriuPath: CriuWorkPath: IoGid:0 IoUid:0 NoNewKeyring:false NoPivotRoot:false Root: ShimCgroup: SystemdCgroup:false] PrivilegedWithoutHostDevices:false BaseRuntimeSpec:}] NoPivot:false DisableSnapshotAnnotations:true DiscardUnpackedLayers:false} CniConfig:{NetworkPluginBinDir:/opt/cni/bin NetworkPluginConfDir:/etc/cni/net.d NetworkPluginMaxConfNum:1 NetworkPluginConfTemplate:} Registry:{ConfigPath: Mirrors:map[] Configs:map[] Auths:map[] Headers:map[]} ImageDecryption:{KeyModel:node} DisableTCPService:true StreamServerAddress:127.0.0.1 StreamServerPort:0 StreamIdleTimeout:4h0m0s EnableSelinux:false SelinuxCategoryRange:1024 SandboxImage:k8s.gcr.io/pause:3.5 StatsCollectPeriod:10 SystemdCgroup:false EnableTLSStreaming:false X509KeyPairStreaming:{TLSCertFile: TLSKeyFile:} MaxContainerLogLineSize:16384 DisableCgroup:false DisableApparmor:false RestrictOOMScoreAdj:false MaxConcurrentDownloads:3 DisableProcMount:false UnsetSeccompProfile: TolerateMissingHugetlbController:true DisableHugetlbController:true IgnoreImageDefinedVolumes:false NetNSMountsUnderStateDir:false} ContainerdRootDir:/var/lib/containerd ContainerdEndpoint:/run/containerd/containerd.sock RootDir:/var/lib/containerd/io.containerd.grpc.v1.cri StateDir:/run/containerd/io.containerd.grpc.v1.cri}&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>9月 &lt;span style="color:#ae81ff">13&lt;/span> 21:48:44 hw-cloud-xngy-jump-server-linux-2 containerd-rootless.sh&lt;span style="color:#f92672">[&lt;/span>2659&lt;span style="color:#f92672">]&lt;/span>: time&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;2021-09-13T21:48:44.602101237+08:00&amp;#34;&lt;/span> level&lt;span style="color:#f92672">=&lt;/span>info msg&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;Connect containerd service&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>9月 &lt;span style="color:#ae81ff">13&lt;/span> 21:48:44 hw-cloud-xngy-jump-server-linux-2 containerd-rootless.sh&lt;span style="color:#f92672">[&lt;/span>2659&lt;span style="color:#f92672">]&lt;/span>: time&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;2021-09-13T21:48:44.602157949+08:00&amp;#34;&lt;/span> level&lt;span style="color:#f92672">=&lt;/span>info msg&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;Get image filesystem path \&amp;#34;/var/lib/containerd/io.containerd.snapshotter.v1.overlayfs\&amp;#34;&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>9月 &lt;span style="color:#ae81ff">13&lt;/span> 21:48:44 hw-cloud-xngy-jump-server-linux-2 containerd-rootless.sh&lt;span style="color:#f92672">[&lt;/span>2659&lt;span style="color:#f92672">]&lt;/span>: time&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;2021-09-13T21:48:44.602220361+08:00&amp;#34;&lt;/span> level&lt;span style="color:#f92672">=&lt;/span>warning msg&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;Running containerd in a user namespace typically requires disable_cgroup, disable_apparmor, restrict_oom_score_adj set to be true&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>9月 &lt;span style="color:#ae81ff">13&lt;/span> 21:48:44 hw-cloud-xngy-jump-server-linux-2 containerd-rootless.sh&lt;span style="color:#f92672">[&lt;/span>2659&lt;span style="color:#f92672">]&lt;/span>: time&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;2021-09-13T21:48:44.602782645+08:00&amp;#34;&lt;/span> level&lt;span style="color:#f92672">=&lt;/span>warning msg&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;failed to load plugin io.containerd.grpc.v1.cri&amp;#34;&lt;/span> error&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;failed to create CRI service: failed to create cni conf monitor: failed to create cni conf dir=/etc/cni/net.d for watch: mkdir /etc/cni/net.d: permission denied&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>9月 &lt;span style="color:#ae81ff">13&lt;/span> 21:48:44 hw-cloud-xngy-jump-server-linux-2 containerd-rootless.sh&lt;span style="color:#f92672">[&lt;/span>2659&lt;span style="color:#f92672">]&lt;/span>: time&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;2021-09-13T21:48:44.602807316+08:00&amp;#34;&lt;/span> level&lt;span style="color:#f92672">=&lt;/span>info msg&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;loading plugin \&amp;#34;io.containerd.grpc.v1.introspection\&amp;#34;...&amp;#34;&lt;/span> type&lt;span style="color:#f92672">=&lt;/span>io.containerd.grpc.v1
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>9月 &lt;span style="color:#ae81ff">13&lt;/span> 21:48:44 hw-cloud-xngy-jump-server-linux-2 containerd-rootless.sh&lt;span style="color:#f92672">[&lt;/span>2659&lt;span style="color:#f92672">]&lt;/span>: time&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;2021-09-13T21:48:44.603004589+08:00&amp;#34;&lt;/span> level&lt;span style="color:#f92672">=&lt;/span>info msg&lt;span style="color:#f92672">=&lt;/span>serving... address&lt;span style="color:#f92672">=&lt;/span>/run/containerd/containerd.sock.ttrpc
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>9月 &lt;span style="color:#ae81ff">13&lt;/span> 21:48:44 hw-cloud-xngy-jump-server-linux-2 containerd-rootless.sh&lt;span style="color:#f92672">[&lt;/span>2659&lt;span style="color:#f92672">]&lt;/span>: time&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;2021-09-13T21:48:44.603068510+08:00&amp;#34;&lt;/span> level&lt;span style="color:#f92672">=&lt;/span>info msg&lt;span style="color:#f92672">=&lt;/span>serving... address&lt;span style="color:#f92672">=&lt;/span>/run/containerd/containerd.sock
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>9月 &lt;span style="color:#ae81ff">13&lt;/span> 21:48:44 hw-cloud-xngy-jump-server-linux-2 containerd-rootless.sh&lt;span style="color:#f92672">[&lt;/span>2659&lt;span style="color:#f92672">]&lt;/span>: time&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;2021-09-13T21:48:44.603088751+08:00&amp;#34;&lt;/span> level&lt;span style="color:#f92672">=&lt;/span>info msg&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;containerd successfully booted in 0.056085s&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>+ systemctl --user enable containerd.service
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Created symlink /home/lichenhao/.config/systemd/user/default.target.wants/containerd.service → /home/lichenhao/.config/systemd/user/containerd.service.
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">[&lt;/span>INFO&lt;span style="color:#f92672">]&lt;/span> Installed &lt;span style="color:#e6db74">&amp;#34;containerd.service&amp;#34;&lt;/span> successfully.
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">[&lt;/span>INFO&lt;span style="color:#f92672">]&lt;/span> To control &lt;span style="color:#e6db74">&amp;#34;containerd.service&amp;#34;&lt;/span>, run: &lt;span style="color:#e6db74">`&lt;/span>systemctl --user &lt;span style="color:#f92672">(&lt;/span>start|stop|restart&lt;span style="color:#f92672">)&lt;/span> containerd.service&lt;span style="color:#e6db74">`&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">[&lt;/span>INFO&lt;span style="color:#f92672">]&lt;/span> To run &lt;span style="color:#e6db74">&amp;#34;containerd.service&amp;#34;&lt;/span> on system startup automatically, run: &lt;span style="color:#e6db74">`&lt;/span>sudo loginctl enable-linger lichenhao&lt;span style="color:#e6db74">`&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">[&lt;/span>INFO&lt;span style="color:#f92672">]&lt;/span> ------------------------------------------------------------------------------------------
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">[&lt;/span>INFO&lt;span style="color:#f92672">]&lt;/span> Use &lt;span style="color:#e6db74">`&lt;/span>nerdctl&lt;span style="color:#e6db74">`&lt;/span> to connect to the rootless containerd.
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">[&lt;/span>INFO&lt;span style="color:#f92672">]&lt;/span> You &lt;span style="color:#66d9ef">do&lt;/span> NOT need to specify $CONTAINERD_ADDRESS explicitly.
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>没法使用 host network 模式，找不到解决办法，好 TM 麻烦&lt;/p></description></item><item><title>Docs: Core</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/y.windows-%E7%AE%A1%E7%90%86/windows%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/powershell%E5%86%85%E7%BD%AE%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/core/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/y.windows-%E7%AE%A1%E7%90%86/windows%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/powershell%E5%86%85%E7%BD%AE%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/core/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://learn.microsoft.com/en-us/powershell/module/microsoft.powershell.core">官方文档-PowerShell，模块-Core&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>核心模块包含管理 PowerShell 基本功能的 cmdlet 和提供程序。&lt;/p>
&lt;h1 id="get-command">Get-Command&lt;/h1>
&lt;p>获取所有命令&lt;/p>
&lt;h2 id="syntax语法">Syntax(语法)&lt;/h2>
&lt;p>&lt;strong>Get-Command [OPTIONS]&lt;/strong>&lt;/p>
&lt;p>&lt;strong>OPTIONS&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>&lt;strong>-Name &amp;lt;PATTERN&amp;gt;&lt;/strong> # 列出匹配到名字的命令。支持通配符。&lt;code>默认值：None&lt;/code>&lt;/li>
&lt;li>&lt;strong>-CommandType &amp;lt;STRING&amp;gt;&lt;/strong> # 列出指定类型的命令。&lt;code>默认值：cmdlet,function,alias&lt;/code>。可用的类型有：Alias、All、Application、Cmdlet、ExternalScript、Filter、Function、Script&lt;/li>
&lt;/ul>
&lt;h2 id="example">EXAMPLE&lt;/h2></description></item><item><title>Docs: FFmpeg</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/11_%E5%A4%9A%E5%AA%92%E4%BD%93/%E5%A4%9A%E5%AA%92%E4%BD%93%E5%A4%84%E7%90%86%E5%B7%A5%E5%85%B7/ffmpeg/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/11_%E5%A4%9A%E5%AA%92%E4%BD%93/%E5%A4%9A%E5%AA%92%E4%BD%93%E5%A4%84%E7%90%86%E5%B7%A5%E5%85%B7/ffmpeg/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://github.com/FFmpeg/FFmpeg">GitHub 项目，FFmpge/FFmpge&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://ffmpeg.org/">官网&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>FFmpeg 是一个库和工具的集合，用于处理多媒体内容，比如 音频、视频、字幕、相关元数据 等。&lt;/p>
&lt;h1 id="ffmpeg-视频处理入门教程">FFmpeg 视频处理入门教程&lt;/h1>
&lt;p>作者： &lt;a href="https://www.ruanyifeng.com/">阮一峰&lt;/a>
日期： &lt;a href="https://www.ruanyifeng.com/blog/2020/01/">2020 年 1 月 14 日&lt;/a>
&lt;a href="https://www.ffmpeg.org/">FFmpeg&lt;/a> 是视频处理最常用的开源软件。
它功能强大，用途广泛，大量用于视频网站和商业软件（比如 Youtube 和 iTunes），也是许多音频和视频格式的标准编码/解码实现。&lt;/p>
&lt;p>FFmpeg 本身是一个庞大的项目，包含许多组件和库文件，最常用的是它的命令行工具。本文介绍 FFmpeg 命令行如何处理视频，比桌面视频处理软件更简洁高效。
如果你还没安装，可以根据&lt;a href="https://www.ffmpeg.org/download.html">官方文档&lt;/a> 先完成安装。&lt;/p>
&lt;h2 id="一概念">一、概念&lt;/h2>
&lt;p>介绍 FFmpeg 用法之前，需要了解一些视频处理的基本概念。&lt;/p>
&lt;h3 id="11-容器">1.1 容器&lt;/h3>
&lt;p>视频文件本身其实是一个容器（container），里面包括了视频和音频，也可能有字幕等其他内容。
常见的容器格式有以下几种。一般来说，视频文件的后缀名反映了它的容器格式。&lt;/p>
&lt;ul>
&lt;li>MP4&lt;/li>
&lt;li>MKV&lt;/li>
&lt;li>WebM&lt;/li>
&lt;li>AVI&lt;/li>
&lt;/ul>
&lt;p>下面的命令查看 FFmpeg 支持的容器。
$ ffmpeg -formats&lt;/p>
&lt;h3 id="12-编码格式">1.2 编码格式&lt;/h3>
&lt;p>视频和音频都需要经过编码，才能保存成文件。不同的编码格式（CODEC），有不同的压缩率，会导致文件大小和清晰度的差异。
常用的视频编码格式如下。&lt;/p>
&lt;ul>
&lt;li>H.262&lt;/li>
&lt;li>H.264&lt;/li>
&lt;li>H.265&lt;/li>
&lt;/ul>
&lt;p>上面的编码格式都是有版权的，但是可以免费使用。此外，还有几种无版权的视频编码格式。&lt;/p>
&lt;ul>
&lt;li>VP8&lt;/li>
&lt;li>VP9&lt;/li>
&lt;li>AV1&lt;/li>
&lt;/ul>
&lt;p>常用的音频编码格式如下。&lt;/p>
&lt;ul>
&lt;li>MP3&lt;/li>
&lt;li>AAC&lt;/li>
&lt;/ul>
&lt;p>上面所有这些都是有损的编码格式，编码后会损失一些细节，以换取压缩后较小的文件体积。无损的编码格式压缩出来的文件体积较大，这里就不介绍了。
下面的命令可以查看 FFmpeg 支持的编码格式，视频编码和音频编码都在内。
$ ffmpeg -codecs&lt;/p>
&lt;h3 id="13-编码器">1.3 编码器&lt;/h3>
&lt;p>编码器（encoders）是实现某种编码格式的库文件。只有安装了某种格式的编码器，才能实现该格式视频/音频的编码和解码。
以下是一些 FFmpeg 内置的视频编码器。&lt;/p>
&lt;ul>
&lt;li>libx264：最流行的开源 H.264 编码器&lt;/li>
&lt;li>NVENC：基于 NVIDIA GPU 的 H.264 编码器&lt;/li>
&lt;li>libx265：开源的 HEVC 编码器&lt;/li>
&lt;li>libvpx：谷歌的 VP8 和 VP9 编码器&lt;/li>
&lt;li>libaom：AV1 编码器&lt;/li>
&lt;/ul>
&lt;p>音频编码器如下。&lt;/p>
&lt;ul>
&lt;li>libfdk-aac&lt;/li>
&lt;li>aac&lt;/li>
&lt;/ul>
&lt;p>下面的命令可以查看 FFmpeg 已安装的编码器。
$ ffmpeg -encoders&lt;/p>
&lt;h2 id="二ffmpeg-的使用格式">二、FFmpeg 的使用格式&lt;/h2>
&lt;p>FFmpeg 的命令行参数非常多，可以分成五个部分。
$ ffmpeg {1} {2} -i {3} {4} {5}
上面命令中，五个部分的参数依次如下。&lt;/p>
&lt;ol>
&lt;li>全局参数&lt;/li>
&lt;li>输入文件参数&lt;/li>
&lt;li>输入文件&lt;/li>
&lt;li>输出文件参数&lt;/li>
&lt;li>输出文件&lt;/li>
&lt;/ol>
&lt;p>参数太多的时候，为了便于查看，ffmpeg 命令可以写成多行。
$ ffmpeg \ [全局参数] \ [输入文件参数] \ -i [输入文件] \ [输出文件参数] \ [输出文件]
下面是一个例子。
$ ffmpeg \ -y \ # 全局参数 -c:a libfdk_aac -c:v libx264 \ # 输入文件参数 -i input.mp4 \ # 输入文件 -c:v libvpx-vp9 -c:a libvorbis \ # 输出文件参数 output.webm # 输出文件
上面的命令将 mp4 文件转成 webm 文件，这两个都是容器格式。输入的 mp4 文件的音频编码格式是 aac，视频编码格式是 H.264；输出的 webm 文件的视频编码格式是 VP9，音频格式是 Vorbis。
如果不指明编码格式，FFmpeg 会自己判断输入文件的编码。因此，上面的命令可以简单写成下面的样子。
$ ffmpeg -i input.avi output.mp4&lt;/p>
&lt;h2 id="三常用命令行参数">三、常用命令行参数&lt;/h2>
&lt;p>FFmpeg 常用的命令行参数如下。&lt;/p>
&lt;ul>
&lt;li>-c：指定编码器&lt;/li>
&lt;li>-c copy：直接复制，不经过重新编码（这样比较快）&lt;/li>
&lt;li>-c:v：指定视频编码器&lt;/li>
&lt;li>-c:a：指定音频编码器&lt;/li>
&lt;li>-i：指定输入文件&lt;/li>
&lt;li>-an：去除音频流&lt;/li>
&lt;li>-vn： 去除视频流&lt;/li>
&lt;li>-preset：指定输出的视频质量，会影响文件的生成速度，有以下几个可用的值 ultrafast, superfast, veryfast, faster, fast, medium, slow, slower, veryslow。&lt;/li>
&lt;li>-y：不经过确认，输出时直接覆盖同名文件。&lt;/li>
&lt;/ul>
&lt;h2 id="四常见用法">四、常见用法&lt;/h2>
&lt;p>下面介绍 FFmpeg 几种常见用法。&lt;/p>
&lt;h3 id="41-查看文件信息">4.1 查看文件信息&lt;/h3>
&lt;p>查看视频文件的元信息，比如编码格式和比特率，可以只使用-i 参数。
$ ffmpeg -i input.mp4
上面命令会输出很多冗余信息，加上-hide_banner 参数，可以只显示元信息。
$ ffmpeg -i input.mp4 -hide_banner&lt;/p>
&lt;h3 id="42-转换编码格式">4.2 转换编码格式&lt;/h3>
&lt;p>转换编码格式（transcoding）指的是， 将视频文件从一种编码转成另一种编码。比如转成 H.264 编码，一般使用编码器 libx264，所以只需指定输出文件的视频编码器即可。
$ ffmpeg -i [input.file] -c:v libx264 output.mp4
下面是转成 H.265 编码的写法。
$ ffmpeg -i [input.file] -c:v libx265 output.mp4&lt;/p>
&lt;h3 id="43-转换容器格式">4.3 转换容器格式&lt;/h3>
&lt;p>转换容器格式（transmuxing）指的是，将视频文件从一种容器转到另一种容器。下面是 mp4 转 webm 的写法。
$ ffmpeg -i input.mp4 -c copy output.webm
上面例子中，只是转一下容器，内部的编码格式不变，所以使用-c copy 指定直接拷贝，不经过转码，这样比较快。&lt;/p>
&lt;h3 id="44-调整码率">4.4 调整码率&lt;/h3>
&lt;p>调整码率（transrating）指的是，改变编码的比特率，一般用来将视频文件的体积变小。下面的例子指定码率最小为 964K，最大为 3856K，缓冲区大小为 2000K。
$ ffmpeg \ -i input.mp4 \ -minrate 964K -maxrate 3856K -bufsize 2000K \ output.mp4&lt;/p>
&lt;h3 id="45-改变分辨率transsizing">4.5 改变分辨率（transsizing）&lt;/h3>
&lt;p>下面是改变视频分辨率（transsizing）的例子，从 1080p 转为 480p 。
$ ffmpeg \ -i input.mp4 \ -vf scale=480:-1 \ output.mp4&lt;/p>
&lt;h3 id="46-提取音频">4.6 提取音频&lt;/h3>
&lt;p>有时，需要从视频里面提取音频（demuxing），可以像下面这样写。
$ ffmpeg \ -i input.mp4 \ -vn -c:a copy \ output.aac
上面例子中，-vn 表示去掉视频，-c:a copy 表示不改变音频编码，直接拷贝。&lt;/p>
&lt;h3 id="47-添加音轨">4.7 添加音轨&lt;/h3>
&lt;p>添加音轨（muxing）指的是，将外部音频加入视频，比如添加背景音乐或旁白。
$ ffmpeg \ -i input.aac -i input.mp4 \ output.mp4
上面例子中，有音频和视频两个输入文件，FFmpeg 会将它们合成为一个文件。&lt;/p>
&lt;h3 id="48-截图">4.8 截图&lt;/h3>
&lt;p>下面的例子是从指定时间开始，连续对 1 秒钟的视频进行截图。
$ ffmpeg \ -y \ -i input.mp4 \ -ss 00:01:24 -t 00:00:01 \ output_%3d.jpg
如果只需要截一张图，可以指定只截取一帧。
$ ffmpeg \ -ss 01:23:45 \ -i input \ -vframes 1 -q:v 2 \ output.jpg
上面例子中，-vframes 1 指定只截取一帧，-q:v 2 表示输出的图片质量，一般是 1 到 5 之间（1 为质量最高）。&lt;/p>
&lt;h3 id="49-裁剪">4.9 裁剪&lt;/h3>
&lt;p>裁剪（cutting）指的是，截取原始视频里面的一个片段，输出为一个新视频。可以指定开始时间（start）和持续时间（duration），也可以指定结束时间（end）。
$ ffmpeg -ss [start] -i [input] -t [duration] -c copy [output] $ ffmpeg -ss [start] -i [input] -to [end] -c copy [output]
下面是实际的例子。
$ ffmpeg -ss 00:01:50 -i [input] -t 10.5 -c copy [output] $ ffmpeg -ss 2.5 -i [input] -to 10 -c copy [output]
上面例子中，-c copy 表示不改变音频和视频的编码格式，直接拷贝，这样会快很多。&lt;/p>
&lt;h3 id="410-为音频添加封面">4.10 为音频添加封面&lt;/h3>
&lt;p>有些视频网站只允许上传视频文件。如果要上传音频文件，必须为音频添加封面，将其转为视频，然后上传。
下面命令可以将音频文件，转为带封面的视频文件。
$ ffmpeg \ -loop 1 \ -i cover.jpg -i input.mp3 \ -c:v libx264 -c:a aac -b:a 192k -shortest \ output.mp4
上面命令中，有两个输入文件，一个是封面图片 cover.jpg，另一个是音频文件 input.mp3。-loop 1 参数表示图片无限循环，-shortest 参数表示音频文件结束，输出视频就结束。&lt;/p>
&lt;h2 id="五参考链接">五、参考链接&lt;/h2>
&lt;ul>
&lt;li>&lt;a href="https://github.com/leandromoreira/ffmpeg-libav-tutorial#chapter-3---transcoding">FFmpeg libav tutorial&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://github.com/leandromoreira/digital_video_introduction/blob/master/encoding_pratical_examples.md#split-and-merge-smoothly">Digital video introduction&lt;/a>&lt;/li>
&lt;li>&lt;a href="http://slhck.info/ffmpeg-encoding-course/">FFmpeg encoding and editing course&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://dragonquest64.blogspot.com/2019/10/making-slideshows-wffmpeg.html">Making Slideshows w/FFMpeg&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://itsfoss.com/ffmpeg/">The Complete Guide for Using ffmpeg in Linux&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://bernd.dev/2020/04/adding-subtitles/">Adding subtitles to your videos the easy way&lt;/a>&lt;/li>
&lt;/ul>
&lt;p>（完）&lt;/p></description></item><item><title>Docs: OpenStack 部署与清理</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/10.%E4%BA%91%E5%8E%9F%E7%94%9F/1.3.openstack-%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%BC%96%E6%8E%92%E7%B3%BB%E7%BB%9F/openstack%E9%83%A8%E7%BD%B2%E4%B8%8E%E6%B8%85%E7%90%86/openstack-%E9%83%A8%E7%BD%B2%E4%B8%8E%E6%B8%85%E7%90%86/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/10.%E4%BA%91%E5%8E%9F%E7%94%9F/1.3.openstack-%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%BC%96%E6%8E%92%E7%B3%BB%E7%BB%9F/openstack%E9%83%A8%E7%BD%B2%E4%B8%8E%E6%B8%85%E7%90%86/openstack-%E9%83%A8%E7%BD%B2%E4%B8%8E%E6%B8%85%E7%90%86/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;/blockquote>
&lt;p>&lt;a href="https://thoughts.teambition.com/workspaces/603b04c9f83f2a00428f7321/folders/5fa948644cc5830001751d72">https://thoughts.teambition.com/workspaces/603b04c9f83f2a00428f7321/folders/5fa948644cc5830001751d72&lt;/a>&lt;/p>
&lt;p>部署 OpenStack 有多种方式&lt;/p>
&lt;ul>
&lt;li>手动部署 OpenStack 中的每一个组件
&lt;ul>
&lt;li>&lt;a href="https://docs.openstack.org/xena/install/">https://docs.openstack.org/xena/install/&lt;/a>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>使用自动化部署工具，部署工具有多种类型可供选择
&lt;ul>
&lt;li>&lt;a href="https://docs.openstack.org/xena/deploy/">https://docs.openstack.org/xena/deploy/&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://docs.openstack.org/project-deploy-guide/charm-deployment-guide/latest/">OpenStack Charms&lt;/a> # 使用 MAAS 和 Juju 部署。
&lt;ul>
&lt;li>一种完善的部署方式，基于 Ubuntu 开发 MAAS。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;a href="https://docs.openstack.org/project-deploy-guide/kolla-ansible/latest/">OpenStack Kolla&lt;/a> # 在容器中使用 Ansible 部署
&lt;ul>
&lt;li>非常简单高效得部署一个用来 生产、开发、测试 的 OpenStack。支持 all-in-one 和 multinode 两种模式(即所有组件都在一个节点或分散在多个节点)&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>其他&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h2 id="支持的操作系统">支持的操作系统&lt;/h2>
&lt;p>Kolla Ansible 支持以下主机操作系统 (OS)：&lt;/p>
&lt;blockquote>
&lt;p>从 Ussuri 版本开始，OpenStack 不再支持 CentOS 7 作为主机操作系统。Train 版本同时支持 CentOS 7 和 8，并提供了迁移路径。有关迁移到 CentOS 8 的信息，请参阅 &lt;a href="https://docs.openstack.org/kolla-ansible/train/user/centos8.html">Kolla Ansible Train 文档&lt;/a>。
不再支持 CentOS Linux 8（相对于 CentOS Stream 8）作为主机操作系统。Victoria 版本将来会同时支持 CentOS Linux 8 和 CentOS Stream 8，并提供迁移途径。&lt;/p>
&lt;/blockquote>
&lt;ul>
&lt;li>CentOS Stream 8&lt;/li>
&lt;li>Debian Bullseye (11)&lt;/li>
&lt;li>RHEL 8（已弃用）&lt;/li>
&lt;li>Rocky Linux 8&lt;/li>
&lt;li>Ubuntu Focal (20.04)&lt;/li>
&lt;/ul>
&lt;h2 id="支持的容器镜像">支持的容器镜像&lt;/h2>
&lt;p>为获得最佳结果，基本容器映像分发应与主机操作系统分发匹配。支持以下值 kolla_base_distro：&lt;/p>
&lt;ul>
&lt;li>centos&lt;/li>
&lt;li>debian&lt;/li>
&lt;li>rhel（已弃用）&lt;/li>
&lt;li>ubuntu&lt;/li>
&lt;/ul>
&lt;p>有关哪些发行版支持哪些图像的详细信息，请参阅 &lt;a href="https://docs.openstack.org/kolla/latest/support_matrix">Kolla 支持矩阵&lt;/a>。&lt;/p>
&lt;h1 id="kolla-ansible">Kolla-ansible&lt;/h1>
&lt;p>注意：&lt;/p>
&lt;ul>
&lt;li>宿主机至少需要两个可用的网卡，在 &lt;code>/etc/kolla/globals.yml&lt;/code> 文件中，被描述为如下两个关键字
&lt;ul>
&lt;li>&lt;strong>network_interface&lt;/strong> # 管理网络、API 网络的网卡&lt;/li>
&lt;li>&lt;strong>neutron_external_interface&lt;/strong> # Neutron 外部接口就是指内网环境。该网络设备将会桥接到 &lt;code>ovs-switch&lt;/code> 这个桥设备上。虚拟机是通过这块网卡访问外网。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h2 id="安装依赖并使用虚拟环境">安装依赖并使用虚拟环境&lt;/h2>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>sudo apt update
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>sudo apt install python3-dev libffi-dev gcc libssl-dev
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>创建一个虚拟环境以安装部署工具&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>export KOLLA_DIR&lt;span style="color:#f92672">=&lt;/span>/root/kolla
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>mkdir -p &lt;span style="color:#e6db74">${&lt;/span>KOLLA_DIR&lt;span style="color:#e6db74">}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>sudo apt install python3-venv
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>python3 -m venv &lt;span style="color:#e6db74">${&lt;/span>KOLLA_DIR&lt;span style="color:#e6db74">}&lt;/span>/venv
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>source &lt;span style="color:#e6db74">${&lt;/span>KOLLA_DIR&lt;span style="color:#e6db74">}&lt;/span>/venv/bin/activate
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>pip install -U pip -i https://pypi.tuna.tsinghua.edu.cn/simple
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>pip install &lt;span style="color:#e6db74">&amp;#39;ansible&amp;lt;5.0&amp;#39;&lt;/span> -i https://pypi.tuna.tsinghua.edu.cn/simple
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="安装-kolla-ansible">安装 Kolla-ansible&lt;/h2>
&lt;p>这里说的 Kolla-ansible 主要指的是用于部署 Openstack 的 Ansible Playbook~~~~&lt;/p>
&lt;p>确定要安装的版本。Kolla-ansible 的版本号与 Openstack 的版本号保持一致，这里以 Openstack 的 &lt;code>xena&lt;/code> 版本为例&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>export KOLLA_BRANCH_NAME&lt;span style="color:#f92672">=&lt;/span>xena
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>使用 pip 安装 kolla-ansible 及其依赖项。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>pip install git+https://opendev.org/openstack/kolla-ansible@&lt;span style="color:#e6db74">${&lt;/span>KOLLA_BRANCH_NAME&lt;span style="color:#e6db74">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>创建配置目录&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>sudo mkdir -p /etc/kolla
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>sudo chown $USER:$USER /etc/kolla
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>cp -r &lt;span style="color:#e6db74">${&lt;/span>KOLLA_DIR&lt;span style="color:#e6db74">}&lt;/span>/venv/share/kolla-ansible/etc_examples/kolla/* /etc/kolla
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>将 Ansible Playbook 所需的 Inventory 拷贝到当前目录&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>cp &lt;span style="color:#e6db74">${&lt;/span>KOLLA_DIR&lt;span style="color:#e6db74">}&lt;/span>/venv/share/kolla-ansible/ansible/inventory/* .
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="配置-ansible">配置 Ansible&lt;/h2>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>mkdir -p /etc/ansible
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>tee /etc/ansible/ansible.cfg &amp;gt; /dev/null &lt;span style="color:#e6db74">&amp;lt;&amp;lt;EOF
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">[defaults]
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">host_key_checking=False
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">pipelining=True
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">forks=100
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">EOF&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="all-in-one-部署-openstack">All-in-one 部署 OpenStack&lt;/h2>
&lt;h3 id="配置-kolla">配置 Kolla&lt;/h3>
&lt;p>为 &lt;code>/etc/kolla/passwords.yml&lt;/code> 文件生成密码&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>kolla-genpwd
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>配置 &lt;code>/etc/kolla/globals.yml&lt;/code> 文件&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>kolla_base_distro: &lt;span style="color:#e6db74">&amp;#34;ubuntu&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>kolla_install_type: &lt;span style="color:#e6db74">&amp;#34;source&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>network_interface: &lt;span style="color:#e6db74">&amp;#34;eno3&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># neutron 外部接口就是指内网环境。该网络设备将会桥街道 ovs-switch 这个桥设备上。&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>neutron_external_interface: &lt;span style="color:#e6db74">&amp;#34;eno4&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>kolla_internal_vip_address: &lt;span style="color:#e6db74">&amp;#34;192.168.88.236&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>enable_cinder: &lt;span style="color:#e6db74">&amp;#34;yes&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>openstack_release: &lt;span style="color:#e6db74">&amp;#34;xena&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>enable_haproxy: &lt;span style="color:#e6db74">&amp;#34;no&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="配置-inventory">配置 Inventory&lt;/h3>
&lt;p>略，直接使用 localhost 即可&lt;/p>
&lt;h3 id="部署依赖并检查环境">部署依赖并检查环境&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>kolla-ansible -i ./all-in-one bootstrap-servers
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>kolla-ansible -i ./all-in-one prechecks
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="部署-openstack">部署 OpenStack&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>kolla-ansible -i ./all-in-one pull ？？？待验证
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>kolla-ansible -i ./all-in-one deploy
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="multinode-部署-openstack">Multinode 部署 OpenStack&lt;/h2></description></item><item><title>Docs: OpenTelemetry</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/6.%E5%8F%AF%E8%A7%82%E6%B5%8B%E6%80%A7/opentelemetry/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/6.%E5%8F%AF%E8%A7%82%E6%B5%8B%E6%80%A7/opentelemetry/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://github.com/open-telemetry">GitHub 组织，OpenTelemetry&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://opentelemetry.io/">官网&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://opentelemetry.io/docs/">官方文档&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://mp.weixin.qq.com/s/bcziZg8RhCrMGYgFeN76cw">公众号-OpenTelemetry，OpenTelemetry 核心原理篇 ：怎么理解分布式链路追踪技术？&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://mp.weixin.qq.com/s/3dD0hIuqpXdepLVC6V7aoA">公众号-OpenTelemetry，在生产环境如何选择靠谱的 APM 系统&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>&lt;strong>OpenTelemetry(开放式遥测技术，简称 OTel)&lt;/strong> 于 2019 年 5 月由 &lt;a href="https://opentracing.io/">OpenTracing&lt;/a> 与 OpenCensus 合并而成(&lt;a href="https://opensource.googleblog.com/2019/05/opentelemetry-merger-of-opencensus-and.html">Google Open Source&lt;/a>)，是一组 API、SDK、工具、更是一种遥测标准，旨在创建和管理 **Telemetry Data(遥测数据)。**通过 OpenTelemetry 标准创建的程序，可以采集 OpenTelemetry 标准的遥测数据，并发送到我们指定的后端中。OpenTelemetry 支持各种流行的开源后端项目，比如 Prometheus、Jaeger 等。&lt;/p>
&lt;blockquote>
&lt;p>遥测数据包括：Traces(链路追踪数据)、Metrics(指标数据)、logs(日志数据)&lt;/p>
&lt;/blockquote>
&lt;p>注意：OpenTelemetry 不是像 Prometheus、Jaeger 那样的可观察性后端。相反，OpenTelemetry 支持将数据导出到各种开源和商业的后端产品中，它提供了一个可插拔的架构，因此可以轻松添加其他技术协议和格式。&lt;/p>
&lt;p>OTEL 之于可观测性，类似 OCI 之于容器。&lt;/p>
&lt;h2 id="opentelemetry-组件">OpenTelemetry 组件&lt;/h2>
&lt;p>目前，OpenTelemetry 由以下几个主要组件组成：&lt;/p>
&lt;ul>
&lt;li>&lt;strong>规范&lt;/strong> # 与编程语言无关的规范，规定了遥测数据格式等&lt;/li>
&lt;li>&lt;strong>工具&lt;/strong> # 用于采集、转换、导出遥测数据的工具&lt;/li>
&lt;li>&lt;strong>SDK&lt;/strong> # 用于为各种编程语言提供编写符合 OpenTelemetry 规范的工具&lt;/li>
&lt;li>&lt;strong>自动 instrumentation 和 贡献包&lt;/strong> # 没搞懂这是什么？&lt;/li>
&lt;/ul>
&lt;h2 id="opentelemetry-历史">OpenTelemetry 历史&lt;/h2>
&lt;h1 id="opentelemetry-实现">OpenTelemetry 实现&lt;/h1>
&lt;p>&lt;a href="https://github.com/grafana/agent">GitHub 项目，grafana/agent&lt;/a> #
&lt;a href="https://github.com/flashcatcloud/categraf">GitHub 项目，flashcatcloud/categraf&lt;/a> # 通过配置文件，采集所有数据，然后 Push 给 Prom(Prom 需要使用 &lt;code>--web.enable-remote-write-receiver&lt;/code> 为自身开启远程写功能)，暂时没有等待 pull 的功能(截止 2022.6.1 v0.1.0 版本)
&lt;a href="https://www.guance.com/">https://www.guance.com/&lt;/a> 观测云。。。。这个产品。。怎么说呢。。上来就让人各种注册才能体验的感觉很不好。。而且在云原生社区可观测性 SIG 群里，这家人的表达方式和处理事情的态度给人的感觉也不好~~工作内部矛盾放在群里说。。还揭露个人隐私。。。。o(╯□╰)o~&lt;/p>
&lt;h2 id="grafana-agent">Grafana Agent&lt;/h2>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://github.com/grafana/agent">GitHub 项目，grafana/agent&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://grafana.com/docs/agent/latest/">官方文档&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>Grafana Agent 收集遥测数据并将其转发到 Grafana Stack、Grafana Cloud 或 Grafana Enterprise 的开源部署，然后可以在其中分析您的数据。您可以在 Kubernetes 和 Docker 上安装 Grafana Agent，或者作为 Linux、macOS 和 Windows 机器的系统进程。&lt;/p>
&lt;p>Grafana Agent 是开源的，其源代码可在 GitHub 上的&lt;a href="https://github.com/grafana/agent">https://github.com/grafana/agent&lt;/a>上获得。&lt;/p>
&lt;p>Grafana Agent 适用于希望收集和转发遥测数据以进行分析和待命警报的工程师、操作员或管理员。那些运行 Grafana Agent 的人必须安装和配置 Grafana Agent 才能正确收集遥测数据并监控正在运行的代理的健康状况。&lt;/p></description></item><item><title>Docs: LogRotate(日志轮替)</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/6.%E5%8F%AF%E8%A7%82%E6%B5%8B%E6%80%A7/%E6%97%A5%E5%BF%97%E7%B3%BB%E7%BB%9F/logrotate%E6%97%A5%E5%BF%97%E8%BD%AE%E6%9B%BF/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/6.%E5%8F%AF%E8%A7%82%E6%B5%8B%E6%80%A7/%E6%97%A5%E5%BF%97%E7%B3%BB%E7%BB%9F/logrotate%E6%97%A5%E5%BF%97%E8%BD%AE%E6%9B%BF/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://mp.weixin.qq.com/s/b_CWt_ycvnbQG9TXPqRoCQ">公众号-马哥 Linux 运维，[译] 理解 logrotate 实用工具&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>为了防止日志文件持续被写入文件导致过于庞大，那么就需要对日志进行拆分，每隔一段时间就把日志文件保存(打包压缩)起来，然后再创建一个新的空文件继续接收日志，来回循环该过程直到通过配置规定的保留日期，来清除存在过久的日志。通过这种方式来进行日志的归档，分类，清理。这就是 LogRotate 所做的事情。是否进行轮替会有一系列的配置，比如文件的大小达到 N 会轮替一次，每隔多少天轮替一次等等。&lt;/p>
&lt;p>logrotate 只是一个命令行工具，不以守护进程的方式运行在后台，默认情况下，logrotate 命令作为放在 /etc/cron.daily 中的 cron 任务，每天运行一次，该任务会根据设置的策略进行日志文件的检查，其中达到设置中满足轮替配置的日志文件将被轮替。&lt;/p>
&lt;h1 id="关联文件与配置">关联文件与配置&lt;/h1>
&lt;p>/etc/logrotate.conf # logrotate 基本配置文件
/etc/logrotate.d/* # 对基本文件的扩展，该目录下的文件的配置会被包含在基本配置文件中。该目录下一般是一个程序一个文件，每个程序都有自己的日志轮替配置。
/etc/cron.daily/logrotate # 该文件定义了 cron 定时任务执行日志轮替工作的时间
/var/lib/logrotate.status # logrotate 的执行历史&lt;/p>
&lt;h2 id="logrotateconf-配置文件详解">logrotate.conf 配置文件详解&lt;/h2>
&lt;ul>
&lt;li>/PATH/TO/FILES {&amp;hellip;} #指定想要轮替的日志文件，可以通过＊通配指定多个文件名
&lt;ul>
&lt;li>&lt;strong>copytruncate&lt;/strong> # 把正在输出的日志拷(copy)一份出来，再清空(trucate)原来的日志。&lt;/li>
&lt;li>&lt;strong>compress&lt;/strong> # 压缩日志文件的所有非当前版本&lt;/li>
&lt;li>&lt;strong>dateext&lt;/strong> # 切换后的日志文件会附加上一个短横线和 YYYYMMDD 格式的日期,&lt;/li>
&lt;li>&lt;strong>daily&lt;/strong> # 日志文件将每天轮替一次。其它可用值为 monthly(每月)，weekly(每周)、yearly(每年)&lt;/li>
&lt;li>&lt;strong>delaycompress&lt;/strong> # 在轮替任务完成后，已轮替的归档将使用 gzip 进行压缩&lt;/li>
&lt;li>&lt;strong>errors &lt;!-- raw HTML omitted -->&lt;/strong> # 给指定邮箱发送错误通知&lt;/li>
&lt;li>&lt;strong>missingok&lt;/strong> # 如果日志文件丢失，不要显示错误&lt;/li>
&lt;li>&lt;strong>notifempty&lt;/strong> # 如果日志文件为空，则不轮换日志文件&lt;/li>
&lt;li>&lt;strong>olddir &lt;!-- raw HTML omitted -->&lt;/strong> # 指定日志文件的旧版本放在 “DIR”目录 中&lt;/li>
&lt;li>&lt;strong>postrotate 和 endscript&lt;/strong> # 在所有其它指令完成后，postrotate 和 endscript 里面指定的命令将被执行。在这种情况下，rsyslogd 进程将立即再次读取其配置并继续运行。&lt;/li>
&lt;li>&lt;strong>rotate N&lt;/strong> # 共存储 N 个轮替后日志。当产生第 N+1 个轮替后的日志，时间最久的日志将被删除&lt;/li>
&lt;li>&lt;strong>sharedscripts&lt;/strong> # 有多个日志需要轮替时，只执行一次脚本&lt;/li>
&lt;li>&lt;strong>size &lt;!-- raw HTML omitted -->&lt;/strong> # 在日志文件大小大于 LogSize（例如 100K，4M）时进行轮替&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>配置样例&lt;/p>
&lt;pre>&lt;code>/var/log/nginx/*log {
daily
rotate 10
missingok
notifempty
compress
dateext
sharedscripts
postrotate
/bin/kill -USR1 $(cat /var/run/ngnix/nginx.pid 2&amp;gt;/dev/null) 2&amp;gt;/dev/null
endscript
}
&lt;/code>&lt;/pre>
&lt;p>Note：关于 postrotate
postrotate 后面跟随的是一个命令行，一般是用来重新生成日志文件或者冲定义应用所指向的文件描述符（fd：file description），拿 nginx 和 uwsgi 为例：&lt;/p>
&lt;p>完成日志切割后创建新的 nginx 日志文件，此时该文件的 fd 发生改变&lt;/p>
&lt;p>nginx 中日志输出对应的文件 fd 未同步更新，nginx 会向原 fd 对应的日志文件写数据&lt;/p>
&lt;p>“/bin/kill -USR1 cat /var/run/nginx.pid || true”，更新 nginx 默认日志文件的 fd 到新建的日志文件（该效果等同于 reload）。&lt;/p>
&lt;p>关于/bin/kill -HUP&lt;/p>
&lt;p>&amp;ldquo;/bin/kill -USR1 &lt;code>cat /var/run/nginx.pid&lt;/code> || true&amp;rdquo;&lt;/p>
&lt;p>看到这条命令很容易想到：&lt;/p>
&lt;p>/bin/kill -HUP &lt;code>cat /var/run/nginx.pid 2&amp;gt; /dev/null&lt;/code> 2&amp;gt; /dev/null || true&lt;/p>
&lt;p>这两条命令的大概含义是重载 nginx 服务，目的是重新生成 nginx 的日志文件。&lt;/p>
&lt;h1 id="命令行工具">命令行工具&lt;/h1>
&lt;p>logrotate [OPTIONS&amp;hellip;]&lt;/p>
&lt;p>OPTIONS&lt;/p>
&lt;ul>
&lt;li>&lt;strong>-f&lt;/strong> # 告诉 logrotate 强制执行轮替，即使这不是必要的(i.e.测试轮替的配置文件是否可以正常运行)。 有时，在向 logrotate 配置文件添加新条目之后，或者如果已经手动删除旧的日志文件，这将是有用的，因为将创建新文件，并且日志记录将正常继续。&lt;/li>
&lt;/ul>
&lt;p>EXAMPLE&lt;/p>
&lt;ul>
&lt;li>logrotate -f /etc/logrotate.d/keepalived #使用/etc/logrotate.d/keepalived 配置文件执行轮替&lt;/li>
&lt;/ul>
&lt;p>PS:&lt;/p>
&lt;ul>
&lt;li>遇到不能记录日志的情况：kill -USR1 pid 重发信号量&lt;/li>
&lt;/ul></description></item><item><title>Docs: Journal</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/6.%E5%8F%AF%E8%A7%82%E6%B5%8B%E6%80%A7/%E6%97%A5%E5%BF%97%E7%B3%BB%E7%BB%9F/journal/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/6.%E5%8F%AF%E8%A7%82%E6%B5%8B%E6%80%A7/%E6%97%A5%E5%BF%97%E7%B3%BB%E7%BB%9F/journal/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://man7.org/linux/man-pages/man8/systemd-journald.service.8.html">Manual,systemd-journald.service(8)&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>相关服务说明&lt;/p>
&lt;ul>
&lt;li>systemd-Journald.service # 日志功能通过该 Unit 来实现，是一个用于收集和存储日志数据的系统服务，是系统启动前要启动的第一个进程，Journald 会把所有收集到的信息保存在内存中。&lt;/li>
&lt;li>rsyslog.service # 另一种日志数据持久化，Journald 会把日志信息转发给 rsyslog.service 进行处理和保存，如果没有 Journald，rsyslog 也可以自动生成日志而不用从 journald 去获取&lt;/li>
&lt;li>logrotate # logrotate 会对日志文件进行轮替操作，i.e.把已经非常大的日志文件改名后，创建一个新的日志文件，新产生的日志会保存在新文件中，老文件保留一定时期后会自动清除&lt;/li>
&lt;/ul>
&lt;h1 id="journald-关联文件与配置">Journald 关联文件与配置&lt;/h1>
&lt;p>&lt;strong>/etc/systemd/journal.conf&lt;/strong>&lt;/p>
&lt;h2 id="日志存放路径">日志存放路径&lt;/h2>
&lt;p>&lt;strong>/run/log/journal/${MACHINE-ID}/*&lt;/strong>
&lt;strong>/var/log/journal/${MACHINE-ID}/*&lt;/strong>&lt;/p>
&lt;p>默认情况下，journald 的日志保存在 /run/log/journal 中，系统重启就会清除。通过新建 /var/log/journal 目录，日志会自动记录到这个目录中，并永久存储。&lt;/p>
&lt;p>路径中的 MACHINE-ID 的值，可以通过 &lt;code>cat /etc/machine-id&lt;/code> 命令获取&lt;/p>
&lt;pre>&lt;code>root@lichenhao:/var/log/journal# ls
c14766a3e9ae49a3872fb9b7e2583710
root@lichenhao:/var/log/journal# cat /etc/machine-id
c14766a3e9ae49a3872fb9b7e2583710
&lt;/code>&lt;/pre>
&lt;p>所有 journal 程序生成的日志，都会存在 MACHIN-ID 目录下&lt;/p>
&lt;pre>&lt;code>root@lichenhao:/var/log/journal/c14766a3e9ae49a3872fb9b7e2583710# ll -h
total 153M
drwxr-sr-x+ 2 root systemd-journal 4.0K Feb 21 23:15 ./
drwxr-sr-x+ 3 root systemd-journal 46 Dec 9 17:19 ../
-rw-r-----+ 1 root systemd-journal 40M Dec 28 16:23 'system@aa6b2b3f8f9d46fdb169f9d8aaab56c3-0000000000000001-0005b6048d0b7824.journal'
-rw-r-----+ 1 root systemd-journal 32M Jan 22 12:39 'system@aa6b2b3f8f9d46fdb169f9d8aaab56c3-00000000000080e9-0005b781fc8c48d9.journal'
-rw-r-----+ 1 root systemd-journal 32M Feb 21 23:10 'system@aa6b2b3f8f9d46fdb169f9d8aaab56c3-000000000000df93-0005b975c74c3caf.journal'
-rw-r-----+ 1 root systemd-journal 40M Mar 12 15:25 system.journal
-rw-r-----+ 1 root systemd-journal 8.0M Dec 28 16:23 'user-1000@571778ddc0db463990a85592631fa5e8-0000000000000496-0005b6049323448d.journal'
&lt;/code>&lt;/pre>
&lt;h1 id="journalctl-命令行工具">journalctl 命令行工具&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://man7.org/linux/man-pages/man1/journalctl.1.html">Manual(手册)，journalctl(1)&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>Systemd 统一管理所有 Unit 的启动日志。带来的好处就是，可以只用 journalctl 一个命令，查看所有日志（内核日志和应用日志）。日志的配置文件是/etc/systemd/journald.conf。journalctl 功能强大，用法非常多。&lt;/p>
&lt;h2 id="syntax语法">Syntax(语法)&lt;/h2>
&lt;p>&lt;strong>journalctl [OPTIONS] [MATCHES]&lt;/strong>&lt;/p>
&lt;h3 id="options">OPTIONS&lt;/h3>
&lt;ul>
&lt;li>&lt;strong>&amp;ndash;disk-usage&lt;/strong> # 显示所有日志文件的磁盘使用情况，包括持久化和临时的日志。&lt;/li>
&lt;li>&lt;strong>-f, &amp;ndash;follow&lt;/strong> # 实时更新&lt;/li>
&lt;li>&lt;strong>&amp;ndash;file=FILE&lt;/strong> # 查看指定文件中的日志信息，FILE 可以使用&amp;quot;?&amp;ldquo;与&amp;rdquo;*&amp;ldquo;进行匹配。常用于查看从别的设备上拷贝过来的日志文件&lt;/li>
&lt;li>&lt;strong>-p UNM&lt;/strong> # 指定要显示的日志级别(NUM 为 0-7 级)&lt;/li>
&lt;li>&lt;strong>-u UNIT&lt;/strong> #显示指定的 unit 的日志信息&lt;/li>
&lt;/ul>
&lt;p>格式选项&lt;/p>
&lt;ul>
&lt;li>&lt;strong>&amp;ndash;no-pager&lt;/strong> # 在单一页面显示信息，不分页。默认情况下，若日志过长，需要使用 → 方向键翻页才能查看后面的日志内容。&lt;/li>
&lt;li>&lt;strong>-o, &amp;ndash;output=&lt;!-- raw HTML omitted -->&lt;/strong> # 指定输出格式。&lt;code>默认值：short&lt;/code>
&lt;ul>
&lt;li>可用的格式有：json、json-pretty、verbose、export、with-unit 等等&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>过滤选项&lt;/p>
&lt;ul>
&lt;li>&lt;strong>&amp;ndash;output-fields=FIELD&lt;/strong> # 显示指定字段的日志，多个字段以 &lt;code>,&lt;/code> 分割。
&lt;ul>
&lt;li>字段筛选仅对 -o 选项指定的 verbose、export、json、json-pretty、json-sse、json-seq 这几个输出格式有效&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>-S, &amp;ndash;since TIME&lt;/strong> 与** -U, &amp;ndash;unitl TIME** # 设置输出日志信息的开始与结束时间&lt;/li>
&lt;/ul>
&lt;h2 id="example">EXAMPLE&lt;/h2>
&lt;ul>
&lt;li>查看指定用户的日志
&lt;ul>
&lt;li>sudo journalctl _UID=33 &amp;ndash;since today&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>查看指定进程的日志
&lt;ul>
&lt;li>sudo journalctl _PID=1&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>以 JSON 格式仅输出 MESSAGE 与 _CMDLINE 字段的消息
&lt;ul>
&lt;li>journalctl -u docker -ojson-pretty &amp;ndash;output-fields=MESSAGE,_CMDLINE&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>查看指定时间的日志
&lt;ul>
&lt;li>sudo journalctl &amp;ndash;since=&amp;ldquo;2012-10-30 18:17:16&amp;rdquo;&lt;/li>
&lt;li>sudo journalctl &amp;ndash;since &amp;ldquo;20 min ago&amp;rdquo;&lt;/li>
&lt;li>sudo journalctl &amp;ndash;since yesterday&lt;/li>
&lt;li>sudo journalctl &amp;ndash;since 09:00 &amp;ndash;until &amp;ldquo;1 hour ago&amp;rdquo;&lt;/li>
&lt;li>journalctl &amp;ndash;since &amp;ldquo;2018-11-13&amp;rdquo; &amp;ndash;until &amp;ldquo;2018-11-14 03:00&amp;rdquo;&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h1 id="查看所有日志默认情况下-只保存本次启动的日志">查看所有日志（默认情况下 ，只保存本次启动的日志）&lt;/h1>
&lt;p>$ sudo journalctl&lt;/p>
&lt;h1 id="查看内核日志不显示应用日志">查看内核日志（不显示应用日志）&lt;/h1>
&lt;p>$ sudo journalctl -k&lt;/p>
&lt;h1 id="查看系统本次启动的日志">查看系统本次启动的日志&lt;/h1>
&lt;p>$ sudo journalctl -b&lt;/p>
&lt;p>$ sudo journalctl -b -0&lt;/p>
&lt;h1 id="查看上一次启动的日志需更改设置">查看上一次启动的日志（需更改设置）&lt;/h1>
&lt;p>$ sudo journalctl -b -1&lt;/p>
&lt;h1 id="显示尾部的最新-10-行日志">显示尾部的最新 10 行日志&lt;/h1>
&lt;p>$ sudo journalctl -n&lt;/p>
&lt;h1 id="显示尾部指定行数的日志">显示尾部指定行数的日志&lt;/h1>
&lt;p>$ sudo journalctl -n 20&lt;/p>
&lt;h1 id="查看指定服务的日志">查看指定服务的日志&lt;/h1>
&lt;p>$ sudo journalctl /usr/lib/systemd/systemd&lt;/p>
&lt;h1 id="查看某个路径的脚本的日志">查看某个路径的脚本的日志&lt;/h1>
&lt;p>$ sudo journalctl /usr/bin/bash&lt;/p>
&lt;h1 id="查看某个-unit-的日志">查看某个 Unit 的日志&lt;/h1>
&lt;p>$ sudo journalctl -u nginx.service&lt;/p>
&lt;p>$ sudo journalctl -u nginx.service &amp;ndash;since today&lt;/p>
&lt;h1 id="实时滚动显示某个-unit-的最新日志">实时滚动显示某个 Unit 的最新日志&lt;/h1>
&lt;p>$ sudo journalctl -u nginx.service -f&lt;/p>
&lt;h1 id="合并显示多个-unit-的日志">合并显示多个 Unit 的日志&lt;/h1>
&lt;p>$ journalctl -u nginx.service -u php-fpm.service &amp;ndash;since today&lt;/p>
&lt;h1 id="查看指定优先级及其以上级别的日志共有-8-级">查看指定优先级（及其以上级别）的日志，共有 8 级&lt;/h1>
&lt;h1 id="0-emerg">0: emerg&lt;/h1>
&lt;h1 id="1-alert">1: alert&lt;/h1>
&lt;h1 id="2-crit">2: crit&lt;/h1>
&lt;h1 id="3-err">3: err&lt;/h1>
&lt;h1 id="4-warning">4: warning&lt;/h1>
&lt;h1 id="5-notice">5: notice&lt;/h1>
&lt;h1 id="6-info">6: info&lt;/h1>
&lt;h1 id="7-debug">7: debug&lt;/h1>
&lt;p>$ sudo journalctl -p err -b&lt;/p>
&lt;h1 id="指定日志文件占据的最大空间">指定日志文件占据的最大空间&lt;/h1>
&lt;p>$ sudo journalctl &amp;ndash;vacuum-size=1G&lt;/p>
&lt;h1 id="指定日志文件保存多久">指定日志文件保存多久&lt;/h1>
&lt;p>$ sudo journalctl &amp;ndash;vacuum-time=1years&lt;/p></description></item><item><title>Docs: Docsy</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%AE%9E%E7%94%A8%E5%B7%A5%E5%85%B7/%E7%BD%91%E7%AB%99%E6%90%AD%E5%BB%BA/hugo/%E4%B8%BB%E9%A2%98/docsy/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%AE%9E%E7%94%A8%E5%B7%A5%E5%85%B7/%E7%BD%91%E7%AB%99%E6%90%AD%E5%BB%BA/hugo/%E4%B8%BB%E9%A2%98/docsy/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://github.com/google/docsy">GitHub 项目，google/docsy&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.docsy.dev/">官网&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>Kubernetes 的官网就是 Docsy 主题。&lt;/p>
&lt;p>注意：Docsy 必须使用 扩展版 hugo，即 hugo_extended。&lt;/p>
&lt;h1 id="预览和部署-docsy-主题网站">预览和部署 Docsy 主题网站&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://www.docsy.dev/docs/deployment/">官方文档，预览和部署&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;h2 id="准备环境">准备环境&lt;/h2>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>npm install -D autoprefixer
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>npm install -D postcss-cli
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>npm install -D postcss
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;blockquote>
&lt;p>若不在本地安装，则使用 &lt;code>hugo&lt;/code> 命令构建静态文件时将会报错&lt;/p>
&lt;/blockquote>
&lt;h2 id="生成站点文件">生成站点文件&lt;/h2>
&lt;h3 id="生成模板站点">生成模板站点&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>export MY_SITE_DIR&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;docsy&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>git clone https://github.com/google/docsy-example.git &lt;span style="color:#e6db74">${&lt;/span>MY_SITE_DIR&lt;span style="color:#e6db74">}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>cd &lt;span style="color:#e6db74">${&lt;/span>MY_SITE_DIR&lt;span style="color:#e6db74">}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>hugo server
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="生成空白站点">生成空白站点&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-Bash" data-lang="Bash">&lt;span style="display:flex;">&lt;span>hugo new site .
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>hugo mod init github.com/me/my-new-site
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>hugo mod get github.com/google/docsy@v0.6.0
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>cat &amp;gt;&amp;gt; config.toml &lt;span style="color:#e6db74">&amp;lt;&amp;lt;EOL
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">[module]
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">proxy = &amp;#34;direct&amp;#34;
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">[[module.imports]]
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">path = &amp;#34;github.com/google/docsy&amp;#34;
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">[[module.imports]]
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">path = &amp;#34;github.com/google/docsy/dependencies&amp;#34;
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">EOL&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="预览">预览&lt;/h2>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>hugo server
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="部署">部署&lt;/h2>
&lt;p>&lt;a href="https://lucumt.info/post/hugo/using-github-action-to-auto-build-deploy/">https://lucumt.info/post/hugo/using-github-action-to-auto-build-deploy/&lt;/a>
&lt;a href="https://tomial.github.io/posts/hugo%E4%BD%BF%E7%94%A8github-action%E8%87%AA%E5%8A%A8%E9%83%A8%E7%BD%B2%E5%8D%9A%E5%AE%A2%E5%88%B0github-pages/">https://tomial.github.io/posts/hugo%E4%BD%BF%E7%94%A8github-action%E8%87%AA%E5%8A%A8%E9%83%A8%E7%BD%B2%E5%8D%9A%E5%AE%A2%E5%88%B0github-pages/&lt;/a>
&lt;a href="https://www.bloghome.com.cn/post/git-zi-mo-kuai-yi-ge-cang-ku-bao-han-ling-yi-ge-cang-ku.html">https://www.bloghome.com.cn/post/git-zi-mo-kuai-yi-ge-cang-ku-bao-han-ling-yi-ge-cang-ku.html&lt;/a>
使用 Hugo 搭建 GitHub Pages &lt;a href="https://zz2summer.github.io/github-pages-hugo-%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/#%E4%B8%83%E6%97%A5%E5%B8%B8%E6%93%8D%E4%BD%9C">https://zz2summer.github.io/github-pages-hugo-%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/#%E4%B8%83%E6%97%A5%E5%B8%B8%E6%93%8D%E4%BD%9C&lt;/a>&lt;/p>
&lt;h2 id="常见问题">常见问题&lt;/h2>
&lt;p>&lt;a href="https://github.com/google/docsy/issues/235">构建站点时出错：# POSTCSS: failed to transform &amp;ldquo;scss/main.css&amp;rdquo;&lt;/a>&lt;/p>
&lt;h1 id="docsy-配置与关联文件">Docsy 配置与关联文件&lt;/h1>
&lt;p>Docsy 也会使用 Hugo 的 CONFIG 文件来配置站点。参考&lt;a href="https://www.docsy.dev/docs/adding-content/">官网，内容和定制&lt;/a>章节来修改 CONFIG 文件，以改变主题样式。&lt;/p></description></item><item><title>Docs: Hyper-V</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/10.%E4%BA%91%E5%8E%9F%E7%94%9F/1.2.%E5%AE%9E%E7%8E%B0%E8%99%9A%E6%8B%9F%E5%8C%96%E7%9A%84%E5%B7%A5%E5%85%B7/%E8%99%9A%E6%8B%9F%E5%8C%96%E7%AE%A1%E7%90%86/hyper-v/hyper-v/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/10.%E4%BA%91%E5%8E%9F%E7%94%9F/1.2.%E5%AE%9E%E7%8E%B0%E8%99%9A%E6%8B%9F%E5%8C%96%E7%9A%84%E5%B7%A5%E5%85%B7/%E8%99%9A%E6%8B%9F%E5%8C%96%E7%AE%A1%E7%90%86/hyper-v/hyper-v/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;h2 id="参考">参考：&lt;/h2>
&lt;/blockquote>
&lt;p>virtmgmt 命令行工具打开图形化的 Hyper-V 图形界面&lt;/p>
&lt;h1 id="关联文件与配置">关联文件与配置&lt;/h1>
&lt;p>&lt;strong>编辑会话设置&lt;/strong> # 用以设置连接信息。基本都是 tsclient 的设置。&lt;/p>
&lt;h1 id="共享">共享&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://learn.microsoft.com/zh-cn/virtualization/hyper-v-on-windows/user-guide/enhanced-session-mode">官方文档-虚拟化，与你的虚拟机共享设备&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>增强会话模式可通过 RDP（远程桌面协议）将 Hyper-V 与虚拟机连接起来。 这不仅会改善你的整体虚拟机查看体验，而且使用 RDP 连接还可以使虚拟机与你的计算机共享设备。 由于 RDP 在 Windows 10 中默认打开，所以与 Windows 虚拟机连接时，你可能已经在使用 RDP。 本文着重介绍了一些好处和连接设置对话框中的隐藏选项。&lt;/p>
&lt;p>RDP/增强会话模式：&lt;/p>
&lt;ul>
&lt;li>使虚拟机实现可调整大小和高 DPI 感知。&lt;/li>
&lt;li>改进虚拟机集成
&lt;ul>
&lt;li>共享的剪贴板&lt;/li>
&lt;li>通过拖放和复制粘贴进行文件共享&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>允许设备共享
&lt;ul>
&lt;li>麦克风/扬声器&lt;/li>
&lt;li>USB 设备&lt;/li>
&lt;li>数据磁盘（包括 C:）&lt;/li>
&lt;li>打印机&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>想要共享宿主机的磁盘，最好的方法是使用 RDP 的 tsclient 功能，效果如下图：&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/0-picgo/20230209155050.png" alt="image.png">&lt;/p>
&lt;h1 id="使用-powershell-模块管理-hyper-v">使用 PowerShell 模块管理 Hyper-V&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://learn.microsoft.com/en-us/powershell/module/hyper-v/index">官方文档-PowerShell，模块-hyper-v&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://learn.microsoft.com/zh-cn/virtualization/hyper-v-on-windows/quick-start/try-hyper-v-powershell">https://learn.microsoft.com/zh-cn/virtualization/hyper-v-on-windows/quick-start/try-hyper-v-powershell&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;h2 id="new-vm">New-VM&lt;/h2>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://learn.microsoft.com/en-us/powershell/module/hyper-v/new-vm">https://learn.microsoft.com/en-us/powershell/module/hyper-v/new-vm&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>创建一个新的虚拟机&lt;/p>
&lt;h2 id="get-vm">Get-VM&lt;/h2>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://learn.microsoft.com/en-us/powershell/module/hyper-v/get-vm">https://learn.microsoft.com/en-us/powershell/module/hyper-v/get-vm&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>从一个或多个 Hyper-V 主机获取虚拟机&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-powershell" data-lang="powershell">&lt;span style="display:flex;">&lt;span>PS ~&amp;gt; get-vm
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Name State CPUUsage(%) MemoryAssigned(M) Uptime Status Version
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>---- ----- ----------- ----------------- ------ ------ -------
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>win10 Off &lt;span style="color:#ae81ff">0&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span> &lt;span style="color:#ae81ff">00&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">:&lt;/span>&lt;span style="color:#ae81ff">00&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">:&lt;/span>&lt;span style="color:#ae81ff">00&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">正常运行&lt;/span> &lt;span style="color:#ae81ff">11.0&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div></description></item><item><title>Docs: Java</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/2.%E7%BC%96%E7%A8%8B/%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/java/java/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/2.%E7%BC%96%E7%A8%8B/%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/java/java/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://www.java.com/">官网&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.liaoxuefeng.com/wiki/1252599548343744/1255876875896416#0">廖雪峰-Java教程，Java简介&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>Java 分三个版本：&lt;/p>
&lt;ul>
&lt;li>Java Standard Edition(标准版，简称 JSE)&lt;/li>
&lt;li>Java Enterprise Edition(企业版，简称 JEE)&lt;/li>
&lt;li>Java Micro Edition(微型版，简称 JME)&lt;/li>
&lt;/ul>
&lt;pre tabindex="0">&lt;code class="language-ascii" data-lang="ascii">┌───────────────────────────┐
│Java EE │
│ ┌────────────────────┐ │
│ │Java SE │ │
│ │ ┌─────────────┐ │ │
│ │ │ Java ME │ │ │
│ │ └─────────────┘ │ │
│ └────────────────────┘ │
└───────────────────────────┘
&lt;/code>&lt;/pre>&lt;h2 id="java-名词">Java 名词&lt;/h2>
&lt;p>JDK # Java Development Kit（Java 开发工具包）&lt;/p>
&lt;p>JRE # Java Runtime Environment（Java 运行时环境）&lt;/p>
&lt;p>JVM # Java Virtual Machin（Java 虚拟机）&lt;/p>
&lt;p>JSR # Java Specification Request（Java 规范）&lt;/p>
&lt;p>JCP # Java Community Process（Java 社区处理）&lt;/p>
&lt;p>JRE 中包含运行 &lt;strong>Java 字节码&lt;/strong> 的 JVM 和 库。但是，我们先要使用 JDK 将 Java 源码编译成 Java 字节码。因此 JDK 除了包含 JRE，还提供了编译器、调试器等开发工具。常说的安装 Java，其实就是指安装 JDK。&lt;/p>
&lt;pre tabindex="0">&lt;code class="language-ascii" data-lang="ascii"> ┌─ ┌──────────────────────────────────┐
│ │ Compiler, debugger, etc. │
│ └──────────────────────────────────┘
JDK ┌─ ┌──────────────────────────────────┐
│ │ │ │
│ JRE │ JVM + Runtime Library │
│ │ │ │
└─ └─ └──────────────────────────────────┘
┌───────┐┌───────┐┌───────┐┌───────┐
│Windows││ Linux ││ macOS ││others │
└───────┘└───────┘└───────┘└───────┘
&lt;/code>&lt;/pre>&lt;h2 id="学习资料">学习资料&lt;/h2>
&lt;p>&lt;a href="https://www.runoob.com/java/java-tutorial.html">菜鸟教程，Java&lt;/a>&lt;/p>
&lt;p>&lt;a href="https://www.liaoxuefeng.com/wiki/1252599548343744">廖雪峰，Java 教程&lt;/a>&lt;/p>
&lt;h2 id="andrioid">Andrioid&lt;/h2>
&lt;p>&lt;a href="https://zhuanlan.zhihu.com/p/340609888">Android与Java的关系&lt;/a>&lt;/p>
&lt;h1 id="hello-world">Hello World&lt;/h1>
&lt;h1 id="java-语言关键字">Java 语言关键字&lt;/h1>
&lt;h1 id="java-语言规范">Java 语言规范&lt;/h1></description></item><item><title>Docs: Java 工具</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/2.%E7%BC%96%E7%A8%8B/%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/java/java%E5%B7%A5%E5%85%B7/java-%E5%B7%A5%E5%85%B7/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/2.%E7%BC%96%E7%A8%8B/%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/java/java%E5%B7%A5%E5%85%B7/java-%E5%B7%A5%E5%85%B7/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;h2 id="参考">参考：&lt;/h2>
&lt;/blockquote>
&lt;h1 id="逆向工具">逆向工具&lt;/h1>
&lt;p>&lt;a href="https://www.jianshu.com/p/040d54a57e33">简书，某App接口逆向过程&lt;/a>&lt;/p>
&lt;h2 id="jadx">Jadx&lt;/h2>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://github.com/skylot/jadx">GitHub 项目，skylot/jadx&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>Jadx 是一个 Dex 到 Java 反编译器。用于从 Android Dex 和 Apk 文件生成 Java 源代码的 CLI 和 GUI 工具&lt;/p>
&lt;blockquote>
&lt;p>注意：请注意，在大多数情况下，jadx 无法100% 地反编译所有代码，因此会出现错误。检查&lt;a href="https://github.com/skylot/jadx/wiki/Troubleshooting-Q&amp;amp;A#decompilation-issues">故障排除指南&lt;/a>以了解解决方法&lt;/p>
&lt;/blockquote></description></item><item><title>Docs: Java 环境安装与使用</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/2.%E7%BC%96%E7%A8%8B/%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/java/java%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8/java%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/2.%E7%BC%96%E7%A8%8B/%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/java/java%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8/java%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://www.liaoxuefeng.com/wiki/1252599548343744/1280507291631649">廖雪峰-Java 教程，安装 JDK&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;h1 id="安装-java">安装 Java&lt;/h1>
&lt;p>安装好的 JavaSE 包含很多可执行程序&lt;/p>
&lt;ul>
&lt;li>java：这个可执行程序其实就是JVM，运行Java程序，就是启动JVM，然后让JVM执行指定的编译后的代码；&lt;/li>
&lt;li>javac：这是Java的编译器，它用于把Java源码文件（以&lt;code>.java&lt;/code>后缀结尾）编译为Java字节码文件（以&lt;code>.class&lt;/code>后缀结尾）；&lt;/li>
&lt;li>jar：用于把一组&lt;code>.class&lt;/code>文件打包成一个&lt;code>.jar&lt;/code>文件，便于发布；&lt;/li>
&lt;li>javadoc：用于从Java源码中自动提取注释并生成文档；&lt;/li>
&lt;li>jdb：Java调试器，用于开发阶段的运行调试。&lt;/li>
&lt;/ul>
&lt;h2 id="windows-安装">Windows 安装&lt;/h2>
&lt;p>从&lt;a href="https://www.oracle.com/java/technologies/downloads/">这里&lt;/a>下载 JavaSE&lt;/p>
&lt;p>解压到指定目录(我通常是在 &lt;code>D:/Tools/Java/jdk-${VERSION}&lt;/code>)，将该目录添加到 JAVA_HOME 环境变量&lt;/p>
&lt;p>将 &lt;code>%JAVA_HOME%/bin&lt;/code> 添加到 PATH 变量中。&lt;/p></description></item><item><title>Docs: Management</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/y.windows-%E7%AE%A1%E7%90%86/windows%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/powershell%E5%86%85%E7%BD%AE%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/management/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/y.windows-%E7%AE%A1%E7%90%86/windows%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/powershell%E5%86%85%E7%BD%AE%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/management/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://learn.microsoft.com/en-us/powershell/module/microsoft.powershell.management">官方文档-PowerShell，模块-Management&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>管理模块可以让我们在 PowerShell 中管理系统中的进程、服务等。&lt;/p>
&lt;h1 id="item-管理工具">Item 管理工具&lt;/h1>
&lt;h2 id="get-childitem">Get-ChildItem&lt;/h2>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://learn.microsoft.com/en-us/powershell/module/microsoft.powershell.management/get-childitem">官方文档-PowerShell，模块-管理-Get-ChildItem&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;h3 id="syntax语法">Syntax(语法)&lt;/h3>
&lt;p>&lt;strong>OPTIONS&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>&lt;strong>-Path &amp;lt;STRING&amp;gt;&lt;/strong> # 指定一个或多个位置的路径，可以使用通配符。&lt;code>默认值：.&lt;/code>&lt;/li>
&lt;/ul>
&lt;h3 id="example">EXAMPLE&lt;/h3>
&lt;p>实现类似 tree 命令的效果&lt;/p>
&lt;ul>
&lt;li>Get-ChildItem -Path D:/Tools -Recurse -Depth 2 | Select-Object FullName&lt;/li>
&lt;/ul>
&lt;h1 id="服务管理工具">服务管理工具&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://learn.microsoft.com/en-us/powershell/scripting/samples/managing-services">官方文档，PowerShell-脚本示例-管理进程和服务-管理服务&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://learn.microsoft.com/zh-cn/dotnet/framework/windows-services/">官方文档，.Net-开发 Windows 服务应用&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;h2 id="启动停止重启暂停服务">启动、停止、重启、暂停服务&lt;/h2>
&lt;ul>
&lt;li>Start-Service # 启动服务&lt;/li>
&lt;li>Stop-Service # 停止服务&lt;/li>
&lt;li>Suspend-Service # 暂停服务&lt;/li>
&lt;li>Resume-Service # 恢复服务&lt;/li>
&lt;li>Restart-Service # 重启服务&lt;/li>
&lt;/ul>
&lt;h2 id="get-service">Get-Service&lt;/h2>
&lt;p>列出服务。Get-Service 获取代表计算机上服务的对象，包括正在运行和已停止的服务。默认情况下，当不带参数运行 Get-Service 时，将返回本地计算机的所有服务。&lt;/p>
&lt;p>可以通过指定服务名称或服务的显示名称来指示此 cmdlet 仅获取特定服务，或者您可以将服务对象通过管道传递给此 cmdlet。&lt;/p>
&lt;p>默认显示三个字段&lt;/p>
&lt;ul>
&lt;li>Status # 服务状态&lt;/li>
&lt;li>Name # 服务名称&lt;/li>
&lt;li>DisplayName # 服务的显示名称&lt;/li>
&lt;/ul>
&lt;p>服务名称与显示名称可以在窗口页面看到效果，显示名称有点类似于简短的描述信息。&lt;/p>
&lt;h3 id="syntax语法-1">Syntax(语法)&lt;/h3>
&lt;p>Get-Service [OPTIONS] [-Name] &amp;lt;PATTERN&amp;gt;&lt;/p>
&lt;p>PATTERN 支持通配符，前面的 -Name 可以省略，该命令默认通过&lt;strong>服务名称&lt;/strong>进行匹配，将会列出所有匹配到的服务。&lt;/p>
&lt;p>OPTIONS&lt;/p>
&lt;ul>
&lt;li>&lt;strong>-DependentServices&lt;/strong> # 列出指定服务&lt;strong>被哪些服务依赖&lt;/strong>。&lt;/li>
&lt;li>&lt;strong>-RequiredServices&lt;/strong> # 列出指定服务&lt;strong>依赖于哪些服务&lt;/strong>。即.若想该服务正常运行则必须要提前运行的其他服务&lt;/li>
&lt;li>&lt;strong>-Include &amp;lt;String[]&amp;gt;&lt;/strong> #&lt;/li>
&lt;li>&lt;strong>-Exclude &amp;lt;String[]&amp;gt;&lt;/strong> #&lt;/li>
&lt;/ul>
&lt;h3 id="example-1">EXAMPLE&lt;/h3>
&lt;p>列出服务名 s 开头的所有服务并按照状态排序&lt;/p>
&lt;ul>
&lt;li>Get-Service &amp;ldquo;s*&amp;rdquo; | Sort-Object status&lt;/li>
&lt;/ul>
&lt;h2 id="new-service">New-Service&lt;/h2>
&lt;p>创建服务&lt;/p>
&lt;h2 id="remove-service">Remove-Service&lt;/h2>
&lt;p>移除服务&lt;/p>
&lt;h2 id="set-service">Set-Service&lt;/h2>
&lt;p>设置服务&lt;/p>
&lt;h1 id="进程管理工具">进程管理工具&lt;/h1>
&lt;p>&lt;a href="https://learn.microsoft.com/en-us/powershell/module/microsoft.powershell.management/get-process?view=powershell-7.3">Get-Process&lt;/a>
&lt;a href="https://learn.microsoft.com/en-us/powershell/module/microsoft.powershell.management/start-process?view=powershell-7.3">Start-Process&lt;/a>
&lt;a href="https://learn.microsoft.com/en-us/powershell/module/microsoft.powershell.management/stop-process?view=powershell-7.3">Stop-Process&lt;/a>
&lt;a href="https://learn.microsoft.com/en-us/powershell/module/microsoft.powershell.management/wait-process?view=powershell-7.3">Wait-Process&lt;/a>&lt;/p>
&lt;p>&lt;a href="https://learn.microsoft.com/en-us/powershell/module/microsoft.powershell.management/debug-process?view=powershell-7.3">Debug-Process&lt;/a>&lt;/p></description></item><item><title>Docs: Markdown</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%AE%9E%E7%94%A8%E5%B7%A5%E5%85%B7/%E5%86%99%E4%BD%9C/markdown/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%AE%9E%E7%94%A8%E5%B7%A5%E5%85%B7/%E5%86%99%E4%BD%9C/markdown/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;h2 id="参考">参考：&lt;/h2>
&lt;/blockquote>
&lt;h1 id="markdown-中的-latex-数学公式">Markdown 中的 LaTex 数学公式&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://blog.ypingcn.com/notes/Markdown/LaTex-math/">https://blog.ypingcn.com/notes/Markdown/LaTex-math/&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.jianshu.com/p/e74eb43960a1">简书，Markdown 数学公式语法&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>&lt;a href="https://blog.ypingcn.com/notes/Markdown/basic/">基础的 Markdown 语法&lt;/a> 中无法满足数学式子的表达需求，此时可以借助 Latex 语法完成。在 Markdown 中由前后两个 &lt;code>$$&lt;/code>包围的部分可以写 LaTex 源代码（最新版 Typora 已经支持）如下&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-markdown" data-lang="markdown">&lt;span style="display:flex;">&lt;span>$$
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>LaTex code
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>$$
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="速查">速查&lt;/h2>
&lt;p>Markdown 中 Latex 基本符号速查表&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>显示字符&lt;/th>
&lt;th>输入字符&lt;/th>
&lt;th>显示字符&lt;/th>
&lt;th>输入字符&lt;/th>
&lt;th>显示字符&lt;/th>
&lt;th>输入字符&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>&lt;code>#&lt;/code>&lt;/td>
&lt;td>&lt;code>\\#&lt;/code>&lt;/td>
&lt;td>&lt;code>$&lt;/code>&lt;/td>
&lt;td>&lt;code>\\$&lt;/code>&lt;/td>
&lt;td>&lt;code>%&lt;/code>&lt;/td>
&lt;td>&lt;code>\\%&lt;/code>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>&amp;amp;&lt;/code>&lt;/td>
&lt;td>&lt;code>\\&amp;amp;&lt;/code>&lt;/td>
&lt;td>&lt;code>~&lt;/code>&lt;/td>
&lt;td>&lt;code>\\~&lt;/code>&lt;/td>
&lt;td>&lt;code>_&lt;/code>&lt;/td>
&lt;td>&lt;code>\\_&lt;/code>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>^&lt;/code>&lt;/td>
&lt;td>&lt;code>\\^&lt;/code>&lt;/td>
&lt;td>&lt;code>\\&lt;/code>&lt;/td>
&lt;td>&lt;code>\\\\&lt;/code>&lt;/td>
&lt;td>&lt;code>{&lt;/code>&lt;/td>
&lt;td>&lt;code>\\{&lt;/code>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>}&lt;/code>&lt;/td>
&lt;td>&lt;code>\\}&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>≤&lt;/td>
&lt;td>&lt;code>\\le&lt;/code>&lt;/td>
&lt;td>≥&lt;/td>
&lt;td>&lt;code>\\ge&lt;/code>&lt;/td>
&lt;td>≡&lt;/td>
&lt;td>&lt;code>\\equiv&lt;/code>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>≠&lt;/td>
&lt;td>&lt;code>\\ne&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>文本底线对齐的省略号&lt;/td>
&lt;td>&lt;code>\\ldots&lt;/code>&lt;/td>
&lt;td>文本中对齐的省略号&lt;/td>
&lt;td>&lt;code>\\cdots&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>圆括号&lt;/td>
&lt;td>&lt;code>()&lt;/code>&lt;/td>
&lt;td>方括号&lt;/td>
&lt;td>&lt;code>[]&lt;/code>&lt;/td>
&lt;td>竖线&lt;/td>
&lt;td>&lt;code>&amp;amp;#124;&lt;/code>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>花括号&lt;/td>
&lt;td>&lt;code>\\{\\}&lt;/code>&lt;/td>
&lt;td>双竖线&lt;/td>
&lt;td>&lt;code>\\&amp;amp;#124;&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>长圆括号&lt;/td>
&lt;td>&lt;code>\\left( \\right)&lt;/code>&lt;/td>
&lt;td>长方括号&lt;/td>
&lt;td>&lt;code>\\left[ \\right]&lt;/code>&lt;/td>
&lt;td>长花括号&lt;/td>
&lt;td>&lt;code>\\left\\{ \\right\\}&lt;/code>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>换行&lt;/td>
&lt;td>&lt;code>\\\\&lt;/code>&lt;/td>
&lt;td>空格&lt;/td>
&lt;td>&lt;code>\\space&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>←&lt;/td>
&lt;td>&lt;code>\\leftarrow&lt;/code>&lt;/td>
&lt;td>→&lt;/td>
&lt;td>&lt;code>\\rightarrow&lt;/code>&lt;/td>
&lt;td>文字&lt;/td>
&lt;td>&lt;code>\\mbox{ }&lt;/code>&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;hr>
&lt;h2 id="字符相关">字符相关&lt;/h2>
&lt;h3 id="字符">&lt;strong>字符&lt;/strong>&lt;/h3>
&lt;p>插入 &lt;code># $ % &amp;amp; ~ _ ^ \ { }&lt;/code> 需多加 &lt;code>\&lt;/code> 符号（类似于 C 语言中的转义字符），其他可以直接插入。&lt;/p>
&lt;p>&lt;code>\\&lt;/code> 对应换行符 ，&lt;code>\space&lt;/code> 对应空格。&lt;/p>
&lt;p>小于等于、大于等于、恒等于、不等于分别为 &lt;code>\le \ge \equiv \ne&lt;/code> （ l 意为 less ，e 意为 equal ，g 意为 greater ）&lt;/p>
&lt;h3 id="省略号">&lt;strong>省略号&lt;/strong>&lt;/h3>
&lt;p>&lt;code>\ldots \cdots&lt;/code> 分别表示与文本底线对齐和与文本中对齐的省略号。（l 意为 line ，c 意为 center ）&lt;/p>
&lt;h3 id="括号">&lt;strong>括号&lt;/strong>&lt;/h3>
&lt;p>圆括号、方括号和竖线直接输入，花括号前需添加 &lt;code>\&lt;/code> ，双竖线对应&lt;code>\|&lt;/code> 。&lt;/p>
&lt;p>长圆括号、长方括号、长花括号对应&lt;code>\left( \right)&lt;/code> &lt;code>\left[ \right]&lt;/code> &lt;code>\left\{ \right\}&lt;/code>&lt;/p>
&lt;h3 id="箭头">&lt;strong>箭头&lt;/strong>&lt;/h3>
&lt;p>左右箭头对应 &lt;code>\leftarrow \rightarrow&lt;/code>&lt;/p>
&lt;h3 id="插入文字">&lt;strong>插入文字&lt;/strong>&lt;/h3>
&lt;p>&lt;code>\mbox{ }&lt;/code> 用于插入文字（显示效果不是斜体字） 。&lt;/p>
&lt;hr>
&lt;h2 id="数学式子">数学式子&lt;/h2>
&lt;h3 id="标准函数">&lt;strong>标准函数&lt;/strong>&lt;/h3>
&lt;p>欲输入 &lt;code>sin&lt;/code> 时，应用&lt;code>\sin(x)&lt;/code>。&lt;/p>
&lt;h3 id="分数">&lt;strong>分数&lt;/strong>&lt;/h3>
&lt;p>二分之一对于 &lt;code>\frac{1}{2}&lt;/code>&lt;/p>
&lt;h3 id="根号">&lt;strong>根号&lt;/strong>&lt;/h3>
&lt;p>根号二对应 &lt;code>\sqrt{2}&lt;/code> ，开 n 次方为&lt;code>\sqrt[n]{expression}&lt;/code>&lt;/p>
&lt;h3 id="导数-偏导数">&lt;strong>导数 偏导数&lt;/strong>&lt;/h3>
&lt;p>对 x 导数对应 &lt;code>\mathrm{d}x&lt;/code>&lt;/p>
&lt;p>对 x 的偏导数对应&lt;code>\partial x&lt;/code>&lt;/p>
&lt;h3 id="积分">&lt;strong>积分&lt;/strong>&lt;/h3>
&lt;p>f(x) 对 x 从 a 到 b 的积分 &lt;code>\int_a^b f(x) \mathrm{d}x&lt;/code> ， 多重积分则多次输入 &lt;code>\int&lt;/code> ，两个符号之间添加 &lt;code>\!\!\!&lt;/code> 调整正确的间隔。&lt;/p>
&lt;h3 id="极限">&lt;strong>极限&lt;/strong>&lt;/h3>
&lt;p>x 到正无穷的极限 &lt;code>\lim_{x\to+\infty}&lt;/code>&lt;/p>
&lt;h3 id="求和">&lt;strong>求和&lt;/strong>&lt;/h3>
&lt;p>1 到 n 的和对应 &lt;code>\sum_{1}^{n}&lt;/code>&lt;/p>
&lt;h3 id="向量">&lt;strong>向量&lt;/strong>&lt;/h3>
&lt;p>向量 ab 对应 &lt;code>\vec{ab}&lt;/code>&lt;/p>
&lt;h3 id="排列组合">&lt;strong>排列组合&lt;/strong>&lt;/h3>
&lt;p>从 n 中选 m 的组合数和排列数为 &lt;code>\mathrm{C}_n^m \mathrm{A}_n^m&lt;/code>&lt;/p>
&lt;p>&lt;a href="#1">具体内容参见文末参考资料&lt;/a>。&lt;/p>
&lt;hr>
&lt;h2 id="上下标与希腊字母">上下标与希腊字母&lt;/h2>
&lt;p>&lt;code>^&lt;/code> 表示上标 &lt;code>_&lt;/code>表示下标，同时出现上下标时，先上标后下标与先下标后上标的效果相同。&lt;/p>
&lt;p>用 &lt;code>\&lt;/code> 加相应的拼写即可，第一个字母大写则显示大写字母，小写则显示小写字母。&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>输入&lt;/th>
&lt;th>展示&lt;/th>
&lt;th>输入&lt;/th>
&lt;th>展示&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>\alpha&lt;/td>
&lt;td>α&lt;/td>
&lt;td>\beta&lt;/td>
&lt;td>β&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>\gamma&lt;/td>
&lt;td>γ&lt;/td>
&lt;td>\Gamma&lt;/td>
&lt;td>Γ&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>\theta&lt;/td>
&lt;td>θ&lt;/td>
&lt;td>\Theta&lt;/td>
&lt;td>Θ&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>\delta&lt;/td>
&lt;td>δ&lt;/td>
&lt;td>\Delta&lt;/td>
&lt;td>Δ&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>\triangledown&lt;/td>
&lt;td>▽&lt;/td>
&lt;td>\epsilon&lt;/td>
&lt;td>ϵ&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>\zeta&lt;/td>
&lt;td>ζ&lt;/td>
&lt;td>\eta&lt;/td>
&lt;td>η&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>\kappa&lt;/td>
&lt;td>κ&lt;/td>
&lt;td>\lambda&lt;/td>
&lt;td>λ&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>\mu&lt;/td>
&lt;td>μ&lt;/td>
&lt;td>\nu&lt;/td>
&lt;td>ν&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>\xi&lt;/td>
&lt;td>ξ&lt;/td>
&lt;td>\pi&lt;/td>
&lt;td>π&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>\sigma&lt;/td>
&lt;td>σ&lt;/td>
&lt;td>\tau&lt;/td>
&lt;td>τ&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>\upsilon&lt;/td>
&lt;td>υ&lt;/td>
&lt;td>\phi&lt;/td>
&lt;td>ϕ&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>\omega&lt;/td>
&lt;td>ω&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;hr>
&lt;h2 id="多行的数学公式">多行的数学公式&lt;/h2>
&lt;p>例子&lt;/p>
&lt;pre>&lt;code>\begin{eqnarray}
\cos 2\theta &amp;amp; = &amp;amp; \cos^2 \theta - \sin^2 \theta \\
&amp;amp; = &amp;amp; 2 \cos^2 \theta - 1.
\end{eqnarray}
&lt;/code>&lt;/pre>
&lt;p>&amp;amp; 是对齐点，具体例子中表示多行式子在等号之间对齐。&lt;/p>
&lt;pre>&lt;code>f(n) =
\begin{cases}
n+1, &amp;amp; \mbox{if }n \mbox{ is even} \\
n-1, &amp;amp; \mbox{if }n \mbox{ is odd}
\end{cases}
&lt;/code>&lt;/pre>
&lt;p>条件定义式。奇数加一，偶数减一。&lt;/p>
&lt;hr>
&lt;h2 id="矩阵">矩阵&lt;/h2>
&lt;p>例子&lt;/p>
&lt;pre>&lt;code>\begin{array}{ccc}
a &amp;amp; b &amp;amp; c \\
d &amp;amp; e &amp;amp; f \\
g &amp;amp; h &amp;amp; i
\end{array}
&lt;/code>&lt;/pre>
&lt;p>表示 3 x 3 的矩阵，c 表示居中对齐，l 是左对齐，r 是右对齐。&lt;/p>
&lt;hr>
&lt;p>参考资料 ：&lt;/p>
&lt;p>#1 &lt;a href="https://zh.wikipedia.org/wiki/Help:%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8F">帮助:数学公式 - 维基百科，自由的百科全书&lt;/a>&lt;/p>
&lt;p>#2 &lt;a href="https://zh.wikibooks.org/wiki/LaTeX/%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8F">LaTeX/数学公式 - 维基教科书，自由的教学读本&lt;/a>&lt;/p></description></item><item><title>Docs: OpenAI</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/12.%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/openai/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/12.%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/openai/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://openai.com/">官网&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;h1 id="api">API&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://platform.openai.com/docs/api-reference/introduction">官方文档，API 参考&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;h1 id="chatgpt">ChatGPT&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://github.com/wangrongding/wechat-bot">https://github.com/wangrongding/wechat-bot&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://github.com/fuergaosi233/wechat-chatgpt">https://github.com/fuergaosi233/wechat-chatgpt&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://zblogs.top/how-to-register-openai-chatgpt-in-china">https://zblogs.top/how-to-register-openai-chatgpt-in-china&lt;/a>
&lt;ul>
&lt;li>注册 ChatGPT 教程&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>使用虚拟号码接收短信验证码：https://sms-activate.org/&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>上下文联系功能说明&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/0-picgo/20230204001925.png" alt="image.png">&lt;/p>
&lt;h2 id="基于-chatgpt-的项目">基于 ChatGPT 的项目&lt;/h2>
&lt;p>Chrom 插件&lt;/p>
&lt;p>&lt;a href="https://github.com/wong2/chat-gpt-google-extension">https://github.com/wong2/chat-gpt-google-extension&lt;/a>&lt;/p>
&lt;p>&lt;a href="https://github.com/gragland/chatgpt-chrome-extension">https://github.com/gragland/chatgpt-chrome-extension&lt;/a>&lt;/p>
&lt;p>逆向&lt;/p>
&lt;p>&lt;a href="https://github.com/acheong08/ChatGPT">https://github.com/acheong08/ChatGPT&lt;/a>&lt;/p>
&lt;p>微信接入&lt;/p>
&lt;p>&lt;a href="https://github.com/fuergaosi233/wechat-chatgpt">https://github.com/fuergaosi233/wechat-chatgpt&lt;/a>&lt;/p>
&lt;ul>
&lt;li>用法：&lt;a href="https://mp.weixin.qq.com/s/dLzemMUcIfjvWd_AF_yDJw">https://mp.weixin.qq.com/s/dLzemMUcIfjvWd_AF_yDJw&lt;/a>&lt;/li>
&lt;/ul>
&lt;p>&lt;a href="https://github.com/AutumnWhj/ChatGPT-wechat-bot">https://github.com/AutumnWhj/ChatGPT-wechat-bot&lt;/a>&lt;/p>
&lt;p>接入 GitLab&lt;/p>
&lt;p>&lt;a href="https://mp.weixin.qq.com/s/y_ppQdKVXWZPNyP9BxGWpg">https://mp.weixin.qq.com/s/y_ppQdKVXWZPNyP9BxGWpg&lt;/a>&lt;/p></description></item><item><title>Docs: OpenCV</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/12.%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89/opencv/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/12.%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89/opencv/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://github.com/opencv/opencv">GitHub 项目，opencv/opencv&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://opencv.org/">官网&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://docs.opencv.org/">官方文档&lt;/a>，从左侧 Nightly 中选择想要查看的版本&lt;/li>
&lt;li>&lt;a href="https://zhuanlan.zhihu.com/p/115321759">https://zhuanlan.zhihu.com/p/115321759&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.jiqizhixin.com/articles/2019-03-22-10">手把手教你使用OpenCV库（附实例、Python代码解析）&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>&lt;strong>Open Source Computer Vision Library(开源计算机视觉库，简称 OpenCV)&lt;/strong> 是一个包含数百种计算机视觉算法的开源库。&lt;/p>
&lt;p>官方提供了 Python 语言的 OpenCV 接口~~~在官方这没找到其他语言的&lt;/p></description></item><item><title>Docs: Plugin 配置</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/10.%E4%BA%91%E5%8E%9F%E7%94%9F/2.2.%E5%AE%9E%E7%8E%B0%E5%AE%B9%E5%99%A8%E7%9A%84%E5%B7%A5%E5%85%B7/containerd/containerd-%E9%85%8D%E7%BD%AE%E8%AF%A6%E8%A7%A3/plugin-%E9%85%8D%E7%BD%AE/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/10.%E4%BA%91%E5%8E%9F%E7%94%9F/2.2.%E5%AE%9E%E7%8E%B0%E5%AE%B9%E5%99%A8%E7%9A%84%E5%B7%A5%E5%85%B7/containerd/containerd-%E9%85%8D%E7%BD%AE%E8%AF%A6%E8%A7%A3/plugin-%E9%85%8D%E7%BD%AE/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://github.com/containerd/containerd/blob/main/docs/PLUGINS.md">GitHub 项目文档，containerd/docs/PLUGINS.md&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;h2 id="本篇笔记的记录格式">本篇笔记的记录格式&lt;/h2>
&lt;p>Containerd 在 TOML 配置文件中，通过 TOML 表的方式来描述一个插件及其具有的功能，效果如下：&lt;/p>
&lt;ul>
&lt;li>&lt;code>[plugins.&amp;quot;PLUGIN&amp;quot;]&lt;/code>
&lt;ul>
&lt;li>PLUGIN = TYPE.ID&lt;/li>
&lt;li>TYPE = io.containerd.NAME.VERSION&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>所以，一个完整描述插件功能的的 TOML 表应该是这样的：&lt;/p>
&lt;ul>
&lt;li>&lt;code>[plugins.&amp;quot;io.containerd.NAME.VERSION.NAME&amp;quot;.NAME....]&lt;/code>&lt;/li>
&lt;/ul>
&lt;p>这篇笔记在记录时，则省略前面的通用字符串(&lt;code>plugins.&amp;quot;io.containerd.&lt;/code>)，只以最后的关键字来描述，以获得更好的阅读效果。&lt;/p>
&lt;p>比如下文中标题一的 &lt;code>[grpc.v1.cri]&lt;/code> 下的标题二的 &lt;code>[registry]&lt;/code> 下的标题三的 &lt;code>[mirrors]&lt;/code>下的 &lt;code>docker.io&lt;/code> 镜像仓库的镜像配置，反应到配置文件中，就是这样的：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-toml" data-lang="toml">&lt;span style="display:flex;">&lt;span>[&lt;span style="color:#a6e22e">plugins&lt;/span>]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> [&lt;span style="color:#a6e22e">plugins&lt;/span>.&lt;span style="color:#e6db74">&amp;#34;io.containerd.grpc.v1.cri&amp;#34;&lt;/span>]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> [&lt;span style="color:#a6e22e">plugins&lt;/span>.&lt;span style="color:#e6db74">&amp;#34;io.containerd.grpc.v1.cri&amp;#34;&lt;/span>.&lt;span style="color:#a6e22e">registry&lt;/span>]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> [&lt;span style="color:#a6e22e">plugins&lt;/span>.&lt;span style="color:#e6db74">&amp;#34;io.containerd.grpc.v1.cri&amp;#34;&lt;/span>.&lt;span style="color:#a6e22e">registry&lt;/span>.&lt;span style="color:#a6e22e">mirrors&lt;/span>]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> [&lt;span style="color:#a6e22e">plugins&lt;/span>.&lt;span style="color:#e6db74">&amp;#34;io.containerd.grpc.v1.cri&amp;#34;&lt;/span>.&lt;span style="color:#a6e22e">registry&lt;/span>.&lt;span style="color:#a6e22e">mirrors&lt;/span>.&lt;span style="color:#e6db74">&amp;#34;docker.io&amp;#34;&lt;/span>]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">endpoint&lt;/span> = [&lt;span style="color:#e6db74">&amp;#34;https://ac1rmo5p.mirror.aliyuncs.com&amp;#34;&lt;/span>]
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>带 &lt;code>[]&lt;/code> 的都是一个一个的表，表只是用来进行分组，表中的每一个 &lt;code>键值对&lt;/code> 才是真实的配置。&lt;/p>
&lt;h1 id="gcv1scheduler--调度器插件">[gc.v1.scheduler] # 调度器插件&lt;/h1>
&lt;h1 id="grpcv1cri--cri-插件">[grpc.v1.cri] # CRI 插件&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://github.com/containerd/containerd/tree/main/docs/cri">GitHub 项目文档，containerd/docs/cri&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://github.com/containerd/containerd/blob/main/docs/cri/config.md">GitHub 项目文档，containerd/docs/cri/config.md-CRI 插件配置指南&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>注意：&lt;/p>
&lt;blockquote>
&lt;ul>
&lt;li>CRI 插件是当 Containerd 作为 CRI 时所使用的配置，所以 ctr、nerdctl 工具在执行某些命令时，有可能不会调用这些配置，就比如其中的 registry 配置，就算配置了，ctr pull 和 nerdctl pull 命令也无法享受到效果。但是使用 crictl 命令是没问题的。&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>&lt;strong>sanbox_image = &lt;!-- raw HTML omitted -->&lt;/strong> # 启动 Pod 时要使用的 Infra 容器。&lt;code>默认值：k8s.gcr.io/pause:X.X&lt;/code>。这个默认值会根据当前 Containerd 的版本而改变。&lt;/p>
&lt;h2 id="cni--cni-配置">[cni] # CNI 配置&lt;/h2>
&lt;p>&lt;strong>bin_dir = &lt;!-- raw HTML omitted -->&lt;/strong> # CNI 二进制文件的目录 &lt;code>默认值：/opt/cni/bin&lt;/code>
**conf_dir = &lt;!-- raw HTML omitted --> **# CNI 配置文件的目录&lt;code>默认值：/etc/cni/net.d&lt;/code>&lt;/p>
&lt;h2 id="containerd--containerd-运行时配置">[containerd] # Containerd 运行时配置&lt;/h2>
&lt;p>&lt;strong>defautl_runtime_name = &lt;!-- raw HTML omitted -->&lt;/strong> # containerd 进程工作时所调用的 runtime。&lt;code>默认值：runc&lt;/code>&lt;/p>
&lt;h3 id="runtimesrunc--当-containerd-使用-runc-作为运行时生效的配置">[runtimes.runc] # 当 Containerd 使用 runc 作为运行时生效的配置&lt;/h3>
&lt;p>&lt;strong>cni_conf_dir = &lt;!-- raw HTML omitted -->&lt;/strong> # 特定于 runc 作为 runtime 时，所使用的 CNI 配置文件目录
&lt;strong>runtime_type = &lt;!-- raw HTML omitted -->&lt;/strong> # 在 containerd 中要使用的 runtime 类型 &lt;code>默认值：io.containerd.runc.v2&lt;/code>&lt;/p>
&lt;h4 id="options">[options]&lt;/h4>
&lt;p>&lt;strong>SystemdCgroup = &lt;!-- raw HTML omitted -->&lt;/strong> # 是否使用 systemd cgroup。&lt;code>默认值：false&lt;/code>&lt;/p>
&lt;h2 id="image_decryption">[image_decryption]&lt;/h2>
&lt;h2 id="registry--访问镜像注册中心时的配置">[registry] # 访问镜像注册中心时的配置&lt;/h2>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://github.com/containerd/containerd/blob/main/docs/hosts.md">GitHub 项目文档，containerd/docs/hosts.md&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>注意：从 Containerd 1.4 版本开始出现的 &lt;code>registry.configs&lt;/code> 与 &lt;code>registry.mirrors&lt;/code> 现在(2021 年 4 月)已弃用，只有在未指定 &lt;code>config_path&lt;/code> 时才会生效&lt;/p>
&lt;p>&lt;strong>config_path = &lt;!-- raw HTML omitted -->&lt;/strong> # 指定一个目录来引用镜像注册中心的配置&lt;code>默认值：空&lt;/code>
该目录的格式应该为：&lt;code>STRING/REGISTRY/hosts.toml&lt;/code>，也就是说，以镜像注册中心的域名作为目录的名称，且目录下的文件名为 &lt;code>hosts.toml&lt;/code>&lt;/p>
&lt;p>假如现在有如下配置：&lt;code>config_path = &amp;quot;/etc/containerd/registry.d&amp;quot;&lt;/code>，那么 registry.d 目录下的结构应该是下面这样的：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>$ tree /etc/containerd/registry.d
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>/etc/containerd/registry.d
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>└── docker.io
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> └── hosts.toml
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>$ cat /etc/containerd/registry.d/docker.io/hosts.toml
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>server &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#34;https://docker.io&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">[&lt;/span>host.&lt;span style="color:#e6db74">&amp;#34;https://registry-1.docker.io&amp;#34;&lt;/span>&lt;span style="color:#f92672">]&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> capabilities &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#f92672">[&lt;/span>&lt;span style="color:#e6db74">&amp;#34;pull&amp;#34;&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;resolve&amp;#34;&lt;/span>&lt;span style="color:#f92672">]&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="configs--镜像注册中心的通用配置">[configs] # 镜像注册中心的通用配置&lt;/h3>
&lt;p>&lt;strong>[REGISTRY]&lt;/strong> # 访问 REGISTRY 镜像仓库时的配置。说白了就是发起 HTTP 请求时要设置的那些东西。&lt;/p>
&lt;ul>
&lt;li>&lt;strong>[tls]&lt;/strong> # TLS 配置
&lt;ul>
&lt;li>&lt;strong>insecure_skip_verify = &lt;!-- raw HTML omitted -->&lt;/strong> # 访问镜像仓库时是否跳过证书验证。&lt;code>默认值：false&lt;/code>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>[auth]&lt;/strong> # 发起 HTTP 请求时要使用的认证方式
&lt;ul>
&lt;li>&lt;strong>username = &lt;!-- raw HTML omitted -->&lt;/strong> # 访问镜像仓库的用户名&lt;/li>
&lt;li>&lt;strong>password = &lt;!-- raw HTML omitted -->&lt;/strong> # 访问镜像仓库的密码&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h3 id="mirrors--镜像注册中心的-mirrors-配置">[mirrors] # 镜像注册中心的 mirrors 配置&lt;/h3>
&lt;p>&lt;strong>[REGISTRY]&lt;/strong> # 为指定的 REGISTRY 镜像仓库配置 mirrors。例如，&lt;code>[略.registry.mirrors.&amp;quot;docker.io&amp;quot;]&lt;/code> 表示配置 docker.io 的 mirror。&lt;/p>
&lt;ul>
&lt;li>&lt;strong>endpoint = &amp;lt;[]STRING&amp;gt;&lt;/strong> # 表示为 REGISTRY 提供 mirror 的镜像加速服务，是一个数组，可以使用多个镜像加速配置&lt;/li>
&lt;/ul>
&lt;h3 id="注册中心配置">注册中心配置&lt;/h3>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://github.com/containerd/containerd/blob/main/docs/hosts.md">GitHub 项目文档，containerd/containerd/docs/hosts.md&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;h3 id="配置示例">配置示例&lt;/h3>
&lt;p>配置镜像加速
原始&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-toml" data-lang="toml">&lt;span style="display:flex;">&lt;span> [&lt;span style="color:#a6e22e">plugins&lt;/span>.&lt;span style="color:#e6db74">&amp;#34;io.containerd.grpc.v1.cri&amp;#34;&lt;/span>.&lt;span style="color:#a6e22e">registry&lt;/span>]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> [&lt;span style="color:#a6e22e">plugins&lt;/span>.&lt;span style="color:#e6db74">&amp;#34;io.containerd.grpc.v1.cri&amp;#34;&lt;/span>.&lt;span style="color:#a6e22e">registry&lt;/span>.&lt;span style="color:#a6e22e">mirrors&lt;/span>]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> [&lt;span style="color:#a6e22e">plugins&lt;/span>.&lt;span style="color:#e6db74">&amp;#34;io.containerd.grpc.v1.cri&amp;#34;&lt;/span>.&lt;span style="color:#a6e22e">registry&lt;/span>.&lt;span style="color:#a6e22e">mirrors&lt;/span>.&lt;span style="color:#e6db74">&amp;#34;docker.io&amp;#34;&lt;/span>]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">endpoint&lt;/span> = [&lt;span style="color:#e6db74">&amp;#34;https://registry-1.docker.io&amp;#34;&lt;/span>]
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>hosts.toml 这种配置好像不生效，带验证&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>~&lt;span style="color:#f92672">]&lt;/span>&lt;span style="color:#75715e"># cat registry.d/docker.io/hosts.toml&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>server &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#34;https://docker.io&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">[&lt;/span>host.&lt;span style="color:#e6db74">&amp;#34;https://ac1rmo5p.mirror.aliyuncs.com&amp;#34;&lt;/span>&lt;span style="color:#f92672">]&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> capabilities &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#f92672">[&lt;/span>&lt;span style="color:#e6db74">&amp;#34;pull&amp;#34;&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;resolve&amp;#34;&lt;/span>&lt;span style="color:#f92672">]&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>配置私有镜像仓库
原始&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-toml" data-lang="toml">&lt;span style="display:flex;">&lt;span> [&lt;span style="color:#a6e22e">plugins&lt;/span>.&lt;span style="color:#e6db74">&amp;#34;io.containerd.grpc.v1.cri&amp;#34;&lt;/span>.&lt;span style="color:#a6e22e">registry&lt;/span>]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> [&lt;span style="color:#a6e22e">plugins&lt;/span>.&lt;span style="color:#e6db74">&amp;#34;io.containerd.grpc.v1.cri&amp;#34;&lt;/span>.&lt;span style="color:#a6e22e">registry&lt;/span>.&lt;span style="color:#a6e22e">mirrors&lt;/span>]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> [&lt;span style="color:#a6e22e">plugins&lt;/span>.&lt;span style="color:#e6db74">&amp;#34;io.containerd.grpc.v1.cri&amp;#34;&lt;/span>.&lt;span style="color:#a6e22e">registry&lt;/span>.&lt;span style="color:#a6e22e">mirrors&lt;/span>.&lt;span style="color:#e6db74">&amp;#34;192.168.0.250&amp;#34;&lt;/span>]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">endpoint&lt;/span> = [&lt;span style="color:#e6db74">&amp;#34;https://192.168.0.250&amp;#34;&lt;/span>]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> [&lt;span style="color:#a6e22e">plugins&lt;/span>.&lt;span style="color:#e6db74">&amp;#34;io.containerd.grpc.v1.cri&amp;#34;&lt;/span>.&lt;span style="color:#a6e22e">registry&lt;/span>.&lt;span style="color:#a6e22e">configs&lt;/span>]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> [&lt;span style="color:#a6e22e">plugins&lt;/span>.&lt;span style="color:#e6db74">&amp;#34;io.containerd.grpc.v1.cri&amp;#34;&lt;/span>.&lt;span style="color:#a6e22e">registry&lt;/span>.&lt;span style="color:#a6e22e">configs&lt;/span>.&lt;span style="color:#e6db74">&amp;#34;192.168.0.250&amp;#34;&lt;/span>.&lt;span style="color:#a6e22e">tls&lt;/span>]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">insecure_skip_verify&lt;/span> = &lt;span style="color:#66d9ef">true&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> [&lt;span style="color:#a6e22e">plugins&lt;/span>.&lt;span style="color:#e6db74">&amp;#34;io.containerd.grpc.v1.cri&amp;#34;&lt;/span>.&lt;span style="color:#a6e22e">registry&lt;/span>.&lt;span style="color:#a6e22e">configs&lt;/span>.&lt;span style="color:#e6db74">&amp;#34;192.168.0.250&amp;#34;&lt;/span>.&lt;span style="color:#a6e22e">auth&lt;/span>]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">username&lt;/span> = &lt;span style="color:#e6db74">&amp;#34;admin&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">password&lt;/span> = &lt;span style="color:#e6db74">&amp;#34;Harbor12345&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>hosts.toml&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>~&lt;span style="color:#f92672">]&lt;/span>&lt;span style="color:#75715e"># cat registry.d/reg.superstor.com/hosts.toml&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>server &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#34;https://reg.superstor.com&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">[&lt;/span>host.&lt;span style="color:#e6db74">&amp;#34;https://reg.superstor.com&amp;#34;&lt;/span>&lt;span style="color:#f92672">]&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> capabilities &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#f92672">[&lt;/span>&lt;span style="color:#e6db74">&amp;#34;pull&amp;#34;&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;resolve&amp;#34;&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;push&amp;#34;&lt;/span>&lt;span style="color:#f92672">]&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> skip_verify &lt;span style="color:#f92672">=&lt;/span> true
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="x509_key_pair_streaming">[x509_key_pair_streaming]&lt;/h2>
&lt;h1 id="internalv1opt">[internal.v1.opt]&lt;/h1>
&lt;p>&lt;strong>path = &lt;!-- raw HTML omitted -->&lt;/strong> # &lt;code>默认值：/opt/containerd&lt;/code>&lt;/p>
&lt;h1 id="internalv1restart">[internal.v1.restart]&lt;/h1>
&lt;p>&lt;strong>interval = &lt;!-- raw HTML omitted -->&lt;/strong> #&lt;/p>
&lt;h1 id="metadatav1bolt">[metadata.v1.bolt]&lt;/h1>
&lt;h1 id="monitorv1cgroups">[monitor.v1.cgroups]&lt;/h1>
&lt;h1 id="runtimev2task--运行时-v2-版本插件">[runtime.v2.task] # 运行时 v2 版本插件&lt;/h1>
&lt;p>&lt;strong>platforms = &amp;lt;[]STRING&amp;gt;&lt;/strong> # &lt;code>默认值：linux/amd64&lt;/code>&lt;/p></description></item><item><title>Docs: Security</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/y.windows-%E7%AE%A1%E7%90%86/windows%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/powershell%E5%86%85%E7%BD%AE%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/security/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/y.windows-%E7%AE%A1%E7%90%86/windows%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/powershell%E5%86%85%E7%BD%AE%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/security/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://learn.microsoft.com/en-us/powershell/module/microsoft.powershell.security">官方文档-PowerShell，模块-Security&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;h1 id="get-executionpolicy">Get-ExecutionPolicy&lt;/h1>
&lt;p>获取当前会话的执行策略。&lt;/p>
&lt;ul>
&lt;li>Restricted 执行策略不允许任何脚本运行。  &lt;/li>
&lt;li>AllSigned 和 RemoteSigned 执行策略可防止 Windows PowerShell 运行没有数字签名的脚本。&lt;/li>
&lt;/ul>
&lt;p>默认使用 Restricted 策略，此时当我们执行脚本时将会失败，并报错：&lt;/p>
&lt;pre tabindex="0">&lt;code>无法加载文件 XXXXX，因为在此系统上禁止运行脚本。有关详细信息，请参阅 https:/go.microsof
t.com/fwlink/?LinkID=135170 中的 about_Execution_Policies。
&lt;/code>&lt;/pre>&lt;h2 id="syntax语法">Syntax(语法)&lt;/h2>
&lt;h2 id="example">EXAMPLE&lt;/h2>
&lt;h1 id="set-executionpolicy">Set-ExecutionPolicy&lt;/h1>
&lt;p>为 Windows 计算机设置 PowerShell 执行策略&lt;/p>
&lt;h2 id="syntax语法-1">Syntax(语法)&lt;/h2>
&lt;p>Get-Command&lt;/p>
&lt;h2 id="example-1">EXAMPLE&lt;/h2>
&lt;p>设置策略为 RemoteSigned&lt;/p>
&lt;ul>
&lt;li>Set-ExecutionPolicy RemoteSigned&lt;/li>
&lt;/ul></description></item><item><title>Docs: UltraISO</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%AE%9E%E7%94%A8%E5%B7%A5%E5%85%B7/%E5%AE%89%E8%A3%85%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/ultraiso/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%AE%9E%E7%94%A8%E5%B7%A5%E5%85%B7/%E5%AE%89%E8%A3%85%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/ultraiso/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://www.ultraiso.com/">官网&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;h2 id="将-iso-文件写到-u-盘">将 ISO 文件写到 U 盘&lt;/h2>
&lt;p>写入硬盘映像&lt;/p></description></item><item><title>Docs: Windows Shell 变量</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/4.terminal-%E4%B8%8E-shell/windows_shell/windows_shell_%E5%8F%98%E9%87%8F/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/4.terminal-%E4%B8%8E-shell/windows_shell/windows_shell_%E5%8F%98%E9%87%8F/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://learn.microsoft.com/en-us/powershell/scripting/lang-spec/chapter-03?view=powershell-7.3#312-environment-variables">官方文档-PowerShell，脚本-基本概念-环境变量&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://sysin.org/blog/windows-env/">https://sysin.org/blog/windows-env/&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://ss64.com/nt/syntax-variables.html">https://ss64.com/nt/syntax-variables.html&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>赋值方式：&lt;/p>
&lt;ul>
&lt;li>在 CMD 中：&lt;/li>
&lt;li>在 PowerShell 中：&lt;code>$env:VAR=VALUE&lt;/code>&lt;/li>
&lt;/ul>
&lt;p>引用方式：&lt;/p>
&lt;ul>
&lt;li>在 CMD 和资源管理器中：&lt;code>%VAR%&lt;/code>&lt;/li>
&lt;li>在 PowerShell 中：&lt;code>$env:VAR&lt;/code>
&lt;ul>
&lt;li>&lt;code>(type env:path) -split ';'&lt;/code> # 切割字符串，将 ; 替换为换行符。方便查看&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>TODO: Windows 中的变量好像不区分大小写？&lt;/p>
&lt;h2 id="常用环境变量">常用环境变量&lt;/h2>
&lt;p>&lt;strong>COMPUTERNAME&lt;/strong> # 主机名&lt;/p>
&lt;p>&lt;strong>USERNAME&lt;/strong> # 用户名&lt;/p>
&lt;p>&lt;strong>USERPROFILE&lt;/strong> # 用户家目录。默认值：&lt;code>C:/Users/${USERNAME}/&lt;/code>&lt;/p>
&lt;p>&lt;strong>TMP&lt;/strong> # 临时目录。默认值：&lt;/p>
&lt;ul>
&lt;li>系统级 &lt;code>C:/WINDOWS/TEMP&lt;/code>&lt;/li>
&lt;li>用户级 &lt;code>%USERPROFILE%/AppData/Local/Temp&lt;/code>&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>APPDATA&lt;/strong> # 应用程序的数据保存路径。默认值：&lt;code>%USERPROFILE%/AppData/Roaming/&lt;/code>&lt;/p>
&lt;ul>
&lt;li>这个目录下的数据通常可以随着网络连接同步到其他电脑。比如用户的配置、插件等等。当然，很多时候，应用程序也会将这些可以在网络同步的数据保存到 文档、家目录 等等地方中。&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>LOCALAPPDATA&lt;/strong> # 应用程序的本地数据保存路径。默认值：&lt;code>%USERPROFILE%/AppData/Local/&lt;/code>&lt;/p>
&lt;p>&lt;strong>ProgramData&lt;/strong> # 指定程序数据文件夹的路径。与 Program Files 文件夹不同，应用程序可以使用此文件夹为标准用户存储数据，因为它不需要提升的权限。&lt;code>默认值：C:/ProgramData&lt;/code>&lt;/p>
&lt;p>&lt;strong>ProgramFiles&lt;/strong> # &lt;code>默认值：C:/Program Files&lt;/code>&lt;/p>
&lt;p>注意：&lt;/p>
&lt;ul>
&lt;li>Windows 中没有指向 “文档”、“视频” 等等目录的变量，可以在 PowerShell 中使用 &lt;code>[environment]::getfolderpath(&amp;quot;mydocuments&amp;quot;)&lt;/code> 获取。
&lt;ul>
&lt;li>参考：https://stackoverflow.com/questions/3492920/is-there-a-system-defined-environment-variable-for-documents-directory&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>想要获取变量，有几下几种方式：&lt;/p>
&lt;ul>
&lt;li>Get-Item Env:*&lt;/li>
&lt;li>ls env:&lt;/li>
&lt;li>Get-Variable&lt;/li>
&lt;/ul>
&lt;h1 id="变量管理工具">变量管理工具&lt;/h1>
&lt;p>在 PowerShell 中，变量也可以称为一个 Item，因此可以由大多数与 Item 相关的 cmdlet 命令控制。&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://learn.microsoft.com/en-us/powershell/module/microsoft.powershell.utility/new-variable?view=powershell-7.3">New-Variable&lt;/a>: Creates a variable&lt;/li>
&lt;li>&lt;a href="https://learn.microsoft.com/en-us/powershell/module/microsoft.powershell.utility/set-variable?view=powershell-7.3">Set-Variable&lt;/a>: Creates or changes the characteristics of one or more variables&lt;/li>
&lt;li>&lt;a href="https://learn.microsoft.com/en-us/powershell/module/microsoft.powershell.utility/get-variable?view=powershell-7.3">Get-Variable&lt;/a>: Gets information about one or more variables&lt;/li>
&lt;li>&lt;a href="https://learn.microsoft.com/en-us/powershell/module/microsoft.powershell.utility/clear-variable?view=powershell-7.3">Clear-Variable&lt;/a>: Deletes the value of one or more variables&lt;/li>
&lt;li>&lt;a href="https://learn.microsoft.com/en-us/powershell/module/microsoft.powershell.utility/remove-variable?view=powershell-7.3">Remove-Variable&lt;/a>: Deletes one or more variables&lt;/li>
&lt;/ul>
&lt;h1 id="最佳实践">最佳实践&lt;/h1>
&lt;p>设置代理&lt;/p>
&lt;ul>
&lt;li>&lt;code>$env:HTTPS_PROXY=&amp;quot;http://127.0.0.1:7890&amp;quot;&lt;/code>&lt;/li>
&lt;/ul></description></item><item><title>Docs: Windows Shell 命令</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/4.terminal-%E4%B8%8E-shell/windows_shell/windows_shell_%E5%91%BD%E4%BB%A4/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/4.terminal-%E4%B8%8E-shell/windows_shell/windows_shell_%E5%91%BD%E4%BB%A4/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://learn.microsoft.com/en-us/windows-server/administration/windows-commands/windows-commands">官方文档，Windows Server-命令&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://learn.microsoft.com/en-us/powershell/module">官方文档，PowerShell-模块参考&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>所有受支持的 Windows 和 Windows Server 版本都内置了一组 Win32 控制台命令。同时，&lt;a href="https://desistdaydream.github.io/docs/IT%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/4.Terminal%20%E4%B8%8E%20Shell/Windows_Shell/PowerShell.md">PowerShell&lt;/a> 也内置了一组 cmdlet&lt;/p>
&lt;p>这些命令可以用来管理 Windows，很多命令的详解可以参见 &lt;a href="https://desistdaydream.github.io/docs/IT%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Y.Windows%20%E7%AE%A1%E7%90%86/Windows%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/_index.md">Windows 管理工具&lt;/a> 目录。&lt;/p>
&lt;p>本质上，内置的命令就两类：&lt;/p>
&lt;ul>
&lt;li>Win32 控制台命令。一般在保存 &lt;code>C:/Windows/System32/&lt;/code> 目录中，就像 Unix 的 &lt;code>/usr/bin&lt;/code> 这种目录似的，都是一些可执行文件。&lt;/li>
&lt;li>PowerShell 中的 cmdlet。也就是 PowerShell 的各种模块。这些 cmdlet 虽然不是可见的可执行文件，但是也可以实现类似命令的效果。&lt;/li>
&lt;/ul></description></item><item><title>Docs: Windows 共享</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/y.windows-%E7%AE%A1%E7%90%86/windows-%E5%85%B1%E4%BA%AB/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/y.windows-%E7%AE%A1%E7%90%86/windows-%E5%85%B1%E4%BA%AB/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;h2 id="参考">参考：&lt;/h2>
&lt;/blockquote>
&lt;p>保证机器在“专用网络”，打开共享&lt;/p></description></item><item><title>Docs: Windows包管理</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/6.package-%E7%AE%A1%E7%90%86/windows%E5%8C%85%E7%AE%A1%E7%90%86/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/6.package-%E7%AE%A1%E7%90%86/windows%E5%8C%85%E7%AE%A1%E7%90%86/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>官方文档&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;h1 id="appx">AppX&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://learn.microsoft.com/en-us/powershell/module/appx/">官方文档&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>Get-AppxPackage&lt;/p>
&lt;p>Remove-AppxPackage&lt;/p>
&lt;h1 id="msix">MSIX&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>官方文档&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;h1 id="winget">winget&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://learn.microsoft.com/en-us/windows/package-manager/">官方文档-Windows，包管理器&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote></description></item><item><title>Docs: WPS</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%AE%9E%E7%94%A8%E5%B7%A5%E5%85%B7/%E5%86%99%E4%BD%9C/wps/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%AE%9E%E7%94%A8%E5%B7%A5%E5%85%B7/%E5%86%99%E4%BD%9C/wps/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;h2 id="参考">参考：&lt;/h2>
&lt;/blockquote>
&lt;p>垃圾软件&lt;/p>
&lt;p>安装时修改路径后提示没有权限，然后点继续就直接安装到 C 盘了，点取消才能安装到其他路径。&lt;/p>
&lt;h1 id="关联文件与配置">关联文件与配置&lt;/h1>
&lt;ul>
&lt;li>C:/ProgramData/kingsoft/ # 安装程序运行时下载的文件保存路径&lt;/li>
&lt;li>C:/rogram Files (x86)/Kingsoft/ # 不知道干啥用的&lt;/li>
&lt;li>C:/Users/DesistDaydream/AppData/Local/kingsoft/ # 不知道干啥用的&lt;/li>
&lt;li>C:/Users/DesistDaydream/AppData/Roaming/kingsoft/ # 不知道干啥用的&lt;/li>
&lt;li>%我的文档%/KingsoftData/ #
&lt;ul>
&lt;li>暂时不知道win中“我的文档”的变量是什么。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>%我的文档%/WPS Cloud Files/ #&lt;/li>
&lt;/ul></description></item><item><title>Docs: 复合数据类型</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/2.%E7%BC%96%E7%A8%8B/%E8%A7%A3%E8%B0%9C%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/data-type%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B-%E4%B8%8E-literal%E5%AD%97%E9%9D%A2%E9%87%8F/%E5%A4%8D%E5%90%88%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/%E5%A4%8D%E5%90%88%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/2.%E7%BC%96%E7%A8%8B/%E8%A7%A3%E8%B0%9C%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/data-type%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B-%E4%B8%8E-literal%E5%AD%97%E9%9D%A2%E9%87%8F/%E5%A4%8D%E5%90%88%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/%E5%A4%8D%E5%90%88%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Composite_data_type">Wiki，Composite_data_type&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>原子类型的值是不能分解为组成部分的单个数据项。复合类型 或 聚合类型 的值是可以单独访问的数据项的集合。例如，一个整数通常被认为是原子的，尽管它由一系列位组成，而整数数组肯定是复合的。&lt;/p>
&lt;h1 id="array数组">Array(数组)&lt;/h1>
&lt;p>&lt;strong>为什么很多编程语言要把 0 作为第一个下标索引，而不是直观的 1 呢？&lt;/strong>&lt;/p>
&lt;p>这个问题 Dijkstra 已经解答过了，没错，就是你知道的 Dijkstra，Dijkstra 最短路径算法，荷兰语全名是 Edsger Wybe Dijkstra，于 1972 年获得了图灵奖，除了上面说的最短路径算法，还有众所周知的信号量和 PV 原语、银行家算法等也是这位巨佬提出的。&lt;/p>
&lt;p>原文在这里：https://www.cs.utexas.edu/users/EWD/transcriptions/EWD08xx/EWD831.html，感兴趣的小伙伴可以去看下全文，下面我总结几段核心的观点：&lt;/p>
&lt;p>首先来看个案例，如何用一个不等式（或者说表达式）来表示 &lt;code>[2,3,4,5,6,7,8,9,10,11,12]&lt;/code> 这个连续的整数序列（一共 11 个数）？&lt;/p>
&lt;p>假设 &lt;code>i&lt;/code> 是一个整数，那么我们能够迅速的写出如下四个符合上述连续序列的不等式：&lt;/p>
&lt;p>1）&lt;code>2 &amp;lt;= i &amp;lt; 13&lt;/code>&lt;/p>
&lt;p>2）&lt;code>1 &amp;lt; i &amp;lt;= 12&lt;/code>&lt;/p>
&lt;p>3）&lt;code>2 &amp;lt;= i &amp;lt;= 12&lt;/code>&lt;/p>
&lt;p>4）&lt;code>1 &amp;lt; i &amp;lt; 13&lt;/code>&lt;/p>
&lt;p>以上四个不等式均满足要求，那是否有理由选择其中的一种而不是另一种？&lt;/p>
&lt;p>Dijkstra 说有的，选 1 和 2，因为这俩不等式有个很突出的有点，就是不等式边界的差（不等式右边 - 不等式左边）正好等于连续序列的长度&lt;/p>
&lt;p>这里可以排除掉 3 和 4，那么 1 和 2 该如何选出最优的表示？&lt;/p>
&lt;p>1 和 2 不等式的区别就在于：&lt;/p>
&lt;ul>
&lt;li>1 不等式左边（下界）等于序列中的最小值，不等式右边（上界）大于序列中的最大值&lt;/li>
&lt;li>2 不等式左边（下界）小于序列中的最小值，不等式右边（上界）等于序列中的最大值&lt;/li>
&lt;/ul>
&lt;p>对于第 2 个不等式来说，下界小于序列中的最小值，这会出现一个问题，比如我们的连续序列是 &lt;code>[0,1,2,3,4]&lt;/code>&lt;/p>
&lt;p>那么按照第 2 个不等式的写法，不等式的左边就是 -1，-1 是非自然数，而我们需要表示的连续序列是自然数序列，所以第 2 个不等式很不优雅：我们需要用一个 非自然数 来作为 全是自然数的序列 的下界&lt;/p>
&lt;p>因此，综上所述，不等式 1 是最优雅的选择。&lt;/p>
&lt;p>那么，选出一个看着非常顺眼的不等式来表达长度为 N 的连续序列之后，下一个令人烦恼的问题是该为起始元素分配什么下标值？&lt;/p>
&lt;p>遵循不等式 1 的规则：&lt;/p>
&lt;ul>
&lt;li>当从下标 1 开始时，下标范围 &lt;code>1 ≤ i &amp;lt; N+1&lt;/code>&lt;/li>
&lt;li>当从下标 0 开始时，下标范围 &lt;code>0 ≤ i &amp;lt; N&lt;/code>&lt;/li>
&lt;/ul>
&lt;p>哪个更优雅？&lt;/p>
&lt;p>Dijkstra 是这样解释的：从下标 0 开始能够给出更好的不等式，因为元素的下标就等于序列中它前面的元素数（或者说 “偏移量”）。&lt;/p></description></item><item><title>Docs: 计算机视觉</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/12.%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/12.%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;h2 id="参考">参考：&lt;/h2>
&lt;/blockquote>
&lt;h1 id="halcon">Halcon&lt;/h1></description></item><item><title>Docs: 命令行工具</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%AE%9E%E7%94%A8%E5%B7%A5%E5%85%B7/%E7%BD%91%E7%AB%99%E6%90%AD%E5%BB%BA/hugo/%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%B7%A5%E5%85%B7/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%AE%9E%E7%94%A8%E5%B7%A5%E5%85%B7/%E7%BD%91%E7%AB%99%E6%90%AD%E5%BB%BA/hugo/%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%B7%A5%E5%85%B7/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://gohugo.io/commands/hugo/">官方文档，命令-hugo&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>&lt;code>hugo&lt;/code> 是 Hugo 的命令行工具。&lt;/p>
&lt;p>在网站的根目录下使用 &lt;code>hugo&lt;/code> 命令，可以为网站构建静态文件，并保存到 &lt;code>publish/&lt;/code> 目录中。&lt;/p>
&lt;h2 id="sytnax语法">Sytnax(语法)&lt;/h2>
&lt;p>&lt;strong>hugo [COMMAND] [FLAGS]&lt;/strong>&lt;/p>
&lt;p>FLAGS&lt;/p>
&lt;ul>
&lt;li>&lt;strong>-D, &amp;ndash;buildDrafts&lt;/strong> # 包含标记为 draft 的内容&lt;/li>
&lt;/ul>
&lt;h1 id="hugo-server">hugo server&lt;/h1>
&lt;h2 id="syntax语法">Syntax(语法)&lt;/h2>
&lt;p>&lt;strong>hugo server [FLAGS]&lt;/strong>&lt;/p>
&lt;p>FLAGS&lt;/p>
&lt;ul>
&lt;li>&lt;strong>&amp;ndash;bind STRING&lt;/strong> # 监听地址。&lt;code>默认值: 127.0.0.1&lt;/code>&lt;/li>
&lt;li>&lt;strong>-p, &amp;ndash;port INT&lt;/strong> # 监听端口。&lt;code>默认值: 1313&lt;/code>&lt;/li>
&lt;li>&lt;strong>-w, &amp;ndash;watch&lt;/strong> # 监听文件的改变，文件改变时重新应用，以便结果可以实时显示。&lt;code>默认值: true&lt;/code>&lt;/li>
&lt;li>&lt;strong>&amp;ndash;cacheDir STRING&lt;/strong> # filesystem path to cache directory。&lt;code>默认值: $TMPDIR/hugo_cache/&lt;/code>&lt;/li>
&lt;/ul></description></item><item><title>Docs: 配置文件详解</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%AE%9E%E7%94%A8%E5%B7%A5%E5%85%B7/%E7%BD%91%E7%AB%99%E6%90%AD%E5%BB%BA/hugo/%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%AE%9E%E7%94%A8%E5%B7%A5%E5%85%B7/%E7%BD%91%E7%AB%99%E6%90%AD%E5%BB%BA/hugo/%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://gohugo.io/getting-started/configuration/">官方文档，入门-配置&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>Hugo 支持 toml、yaml、json 格式的配置文件，默认配置文件名为 &lt;strong>config.SUFFIX&lt;/strong>。所有的配置指令都可以写在 config.SUFFIX 文件中。&lt;/p>
&lt;p>我们可以拆分 config 文件，并将其保存在 &lt;code>${ConfigDir}&lt;/code> 目录下(默认为站点根目录下的 &lt;code>config/&lt;/code> 文件夹)。 ConfigDir 下的每个文件名代表配置中的根指令，比如：&lt;/p>
&lt;p>config.toml 文件中有如下指令&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-toml" data-lang="toml">&lt;span style="display:flex;">&lt;span>[&lt;span style="color:#a6e22e">Params&lt;/span>]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">foo&lt;/span> = &lt;span style="color:#e6db74">&amp;#39;bar&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>那么拆分到 ConfigDir 目录时，则使用 params.toml 文件，内容为：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-toml" data-lang="toml">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">foo&lt;/span> = &lt;span style="color:#e6db74">&amp;#39;bar&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>除了 Hugo 本身会用到 config 文件，有些主题也会使用 config 文件，并具有各自可以识别的配置指令。比如 Docsy 主题。&lt;/p>
&lt;h1 id="config-目录结构">config 目录结构&lt;/h1>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>├── config
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>│   ├── _default
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>│   │   ├── config.toml
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>│   │   ├── languages.toml
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>│   │   ├── menus.en.toml
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>│   │   ├── menus.zh.toml
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>│   │   └── params.toml
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>│   ├── production
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>│   │   ├── config.toml
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>│   │   └── params.toml
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>│   └── staging
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>│       ├── config.toml
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>│       └── params.toml
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>_default/ 目录是站点的默认配置，可以直接保存单个 config 文件。&lt;/p>
&lt;p>production 与 staging 文件夹用来区分运行时配置，比如使用 &lt;code>hugo --environment staging&lt;/code> 命令时，Hugo 将会使用 &lt;code>config/_default/&lt;/code> 和 &lt;code>config/staging&lt;/code> 这两个下的所有文件，将所有文件合并后生成一个单独的临时 config 文件，作为站点运行时的配置文件。&lt;/p>
&lt;p>这种目录结构，可以帮助我们区分不用环境(比如开发环境、生产环境等)下运行网站所需要使用的配置。&lt;/p>
&lt;blockquote>
&lt;p>Hugo 有个默认值，执行 &lt;code>hugo server&lt;/code> 命令时，是在本地运行网站，所以默认为开发环境，使用 &lt;code>config/development/&lt;/code> 目录；而执行 &lt;code>hugo&lt;/code> 命令时，是要构建静态文件，所以默认为生产环境，使用 &lt;code>config/production&lt;/code> 目录。&lt;/p>
&lt;/blockquote></description></item><item><title>Docs: 其他</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/y.windows-%E7%AE%A1%E7%90%86/windows%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/%E5%85%B6%E4%BB%96/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/y.windows-%E7%AE%A1%E7%90%86/windows%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/%E5%85%B6%E4%BB%96/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;h2 id="参考">参考：&lt;/h2>
&lt;/blockquote>
&lt;h1 id="链接文件管理">链接文件管理&lt;/h1>
&lt;h2 id="mklink">mklink&lt;/h2>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://learn.microsoft.com/en-us/windows-server/administration/windows-commands/mklink">官方文档&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;h3 id="syntax语法">Syntax(语法)&lt;/h3>
&lt;p>&lt;strong>mklink [[/d] | [/h] | [/j]] &amp;lt;link&amp;gt; &amp;lt;target&amp;gt;&lt;/strong>&lt;/p>
&lt;p>为 target 创建一个名为 link 的链接文件。即 link 是要创建的新文件&lt;/p>
&lt;h3 id="example">EXAMPLE&lt;/h3>
&lt;ul>
&lt;li>创建链接
&lt;ul>
&lt;li>mklink /D C:/Users/DesistDaydream/AppData/Roaming/yuzu E:/yuzu/user&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h1 id="电源管理">电源管理&lt;/h1>
&lt;h2 id="powercfg">powercfg&lt;/h2>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://learn.microsoft.com/en-us/windows-hardware/design/device-experiences/powercfg-command-line-options">官方文档-Windows硬件开发人员，学习-Windows-设计-设备体验-Powercfg 命令行选项&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>powercfg 工具可以控制电源计划（也称为电源方案）以使用可用的睡眠状态、控制单个设备的电源状态以及分析系统的常见能效和电池寿命问题。&lt;/p>
&lt;h3 id="syntax语法-1">Syntax(语法)&lt;/h3>
&lt;p>&lt;strong>powercfg OPTIONS [arguments] [/?]&lt;/strong>&lt;/p>
&lt;p>OPTIONS&lt;/p>
&lt;ul>
&lt;li>&lt;strong>/devicequery QueryFlag&lt;/strong> # 根据 QueryFlag(查询标志) 列出设备。可用的 QueryFlag 列表如下
&lt;ul>
&lt;li>&lt;strong>all_devices&lt;/strong> # 列出所有设备&lt;/li>
&lt;li>&lt;strong>wake_armed&lt;/strong> # 列出可以唤醒系统的设备&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>/deviceenablewake &amp;lt;DeviceName&amp;gt;&lt;/strong> # 指定设备启用唤醒系统功能&lt;/li>
&lt;li>&lt;strong>/devicedisablewake &amp;lt;DeviceName&amp;gt;&lt;/strong> # 指定设备禁用唤醒系统功能&lt;/li>
&lt;li>&lt;strong>/lastwake&lt;/strong> # 查看系统最后一次被唤醒的信息&lt;/li>
&lt;/ul>
&lt;h3 id="example-1">EXAMPLE&lt;/h3>
&lt;ul>
&lt;li>查找可以唤醒电脑的设备
&lt;ul>
&lt;li>powercfg /devicequery wake_armed&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>禁用 NVIDIA USB Type-C Port Policy Controller 这个设备唤醒系统
&lt;ul>
&lt;li>powercfg /devicedisablewake &amp;lsquo;NVIDIA USB Type-C Port Policy Controller&amp;rsquo;&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul></description></item><item><title>Docs: 任务计划程序与服务</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/y.windows-%E7%AE%A1%E7%90%86/microsoft_management_console/%E4%BB%BB%E5%8A%A1%E8%AE%A1%E5%88%92%E7%A8%8B%E5%BA%8F%E4%B8%8E%E6%9C%8D%E5%8A%A1/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/y.windows-%E7%AE%A1%E7%90%86/microsoft_management_console/%E4%BB%BB%E5%8A%A1%E8%AE%A1%E5%88%92%E7%A8%8B%E5%BA%8F%E4%B8%8E%E6%9C%8D%E5%8A%A1/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;h2 id="参考">参考：&lt;/h2>
&lt;/blockquote></description></item><item><title>Docs: 深度学习框架</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/12.%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E6%A1%86%E6%9E%B6/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/12.%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E6%A1%86%E6%9E%B6/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;h2 id="参考">参考：&lt;/h2>
&lt;/blockquote>
&lt;h1 id="深度学习开源框架">深度学习开源框架&lt;/h1>
&lt;p>PyTorch
百度 飞桨
谷歌 Tenter flow&lt;/p></description></item><item><title>Docs: 图形处理</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/11_%E5%A4%9A%E5%AA%92%E4%BD%93/%E5%9B%BE%E5%BD%A2%E5%A4%84%E7%90%86/%E5%9B%BE%E5%BD%A2%E5%A4%84%E7%90%86/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/11_%E5%A4%9A%E5%AA%92%E4%BD%93/%E5%9B%BE%E5%BD%A2%E5%A4%84%E7%90%86/%E5%9B%BE%E5%BD%A2%E5%A4%84%E7%90%86/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://www.jiqizhixin.com/articles/2019-03-22-10">手把手教你使用OpenCV库（附实例、Python代码解析）&lt;/a>&lt;/li>
&lt;li>公众号-差评，为了把游戏接口做进Windows，这位大佬干翻了微软的管理层。&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;h2 id="计算机如何读取图像">计算机如何读取图像？&lt;/h2>
&lt;p>思考以下图片：&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/fhwfe4/1658568420855-b25fc9bb-0d76-4e6f-a1b7-f77be1aff1da.png" alt="image.png">&lt;/p>
&lt;p>我们可以认出它是纽约天际线的图片。 但是计算机可以自己发现这一切吗？答案是不！&lt;/p>
&lt;p>计算机将任何图片都读取为一组 0 到 255 之间的值。&lt;/p>
&lt;p>对于任何一张彩色图片，有三个主通道——红色(R)，绿色(G)和蓝色(B)。它的工作原理非常简单。&lt;/p>
&lt;p>对每个原色创建一个矩阵，然后，组合这些矩阵以提供 R, G 和 B 各个颜色的像素值。&lt;/p>
&lt;p>每一个矩阵的元素提供与像素的亮度强度有关的数据。&lt;/p>
&lt;p>思考下图：
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/fhwfe4/1658568420764-dd8cadc1-402a-49a6-bdff-ccb3e61ba2eb.png" alt="image.png">&lt;/p>
&lt;p>如图所示，图像的大小被计算为 B x A x 3。&lt;/p>
&lt;p>注意：对于黑白图片，只有一个单一通道。&lt;/p>
&lt;h1 id="gpu">GPU&lt;/h1>
&lt;h1 id="图形接口">图形接口&lt;/h1>
&lt;p>有位叫 &lt;strong>Eric Engstrom&lt;/strong>微软大佬去世了。这位老哥没有比尔盖茨这么大的名气，但要是没他，我们现在想要在夜之城夜夜笙歌，估计没那么容易。甚至说 Windows 电脑，可能还只是一台主要的生产力工具，就像苹果 Mac 一样。&lt;/p>
&lt;p>Eric Engstrom 所创立的 DirectX 接口，&lt;strong>把 PC 个人电脑，拽进了电子游戏的世界。&lt;strong>让&lt;/strong>玩电脑游戏&lt;/strong>成为了一种游戏方式。&lt;/p>
&lt;p>先是辛辛苦苦从&lt;strong>3XM&lt;/strong>、&lt;strong>游 X Sky&lt;/strong>上找到资源，然后冒着被老妈发现的危险，电脑挂一晚上把游戏下下来。&lt;/p>
&lt;p>好不容易下完了解压好，兴奋的打开游戏的 exe 文件，正准备抄起鼠标大杀四方，系统却弹出了这么一个窗口。。。&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/scemn1/1616164698340-628dde5f-0dc1-40eb-a57c-7108250c0636.jpeg" alt="">&lt;/p>
&lt;p>这个文件其实是 DirectX 的驱动文件，重新装一下 DirectX 最新驱动就行了。&lt;/p>
&lt;p>正版游戏在运行之前会有一个自检的环节，来确认电脑中是否有相关的驱动文件。&lt;/p>
&lt;p>而上传盗版游戏的黑客，并不会把这部分自检程序放到压缩包里。&lt;/p>
&lt;p>这样一来，用户在解压完游戏之后就会发生文件缺失的情况，需要自己去网上找到对应的文件把它补上。&lt;/p>
&lt;p>&lt;strong>没有 .dll 文件，游戏就跑不起来。&lt;/strong>&lt;/p>
&lt;p>那个时候玩的单机游戏，从&lt;strong>CS 、红警、魔兽争霸 3&lt;/strong>到&lt;strong>GTA 罪恶都市、骑马与砍杀、文明 IV&lt;/strong>等等等等游戏，都是基于&lt;strong>DirectX&lt;/strong>接口开发的。&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/scemn1/1616164698318-16b5b71b-5d9a-4041-b07d-1ce6ac2969ec.png" alt="">&lt;/p>
&lt;p>&lt;strong>DirectX&lt;/strong>的存在，覆盖了整个电脑游戏发展史。&lt;/p>
&lt;p>&lt;strong>那问题来了，为什么在电脑上的游戏离不开 DirectX 呢？&lt;/strong>&lt;/p>
&lt;p>要解答这个问题，我们得先了解一下图形 API 的发展历史。&lt;/p>
&lt;p>早期的软件开发没有统一标准，往往是一个新的硬件出来，程序员就得为它定制开发一套软件来用。&lt;/p>
&lt;p>&lt;strong>这就造成了硬件与硬件，软件与软件之间并不互通。&lt;/strong>&lt;/p>
&lt;p>比如《仙剑奇侠传》，想要在不同的平台上玩，就需要程序员适配三次。&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/scemn1/1616164698352-49bfaa0e-3eff-4c9e-b3b2-c6e19b63fc23.png" alt="">&lt;/p>
&lt;p>基于此，在人类的原始生产力&lt;strong>懒&lt;/strong>的驱使下，程序员们发明出了 &lt;strong>Application Programming Interface(应用编程接口，简称 API)&lt;/strong> 。它的出现统一了所有的开发规范，解决了不同硬件需要适配的问题，大大节省了开发的成本。&lt;/p>
&lt;p>要是用统一的 API，就不需要重复开发了，直接适配。▼&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/scemn1/1616164698353-349c841a-d70a-4584-bc7c-f2c642bcfc94.png" alt="">&lt;/p>
&lt;h2 id="opengl">OpenGL&lt;/h2>
&lt;p>不过那时候率先登场的 API 的并不是 DirectX ，而是大名鼎鼎的 Glide 和 OpenGL ，还没微软什么事。&lt;/p>
&lt;p>Glide 的 API 标准是一家叫 3dfx 的显卡公司创立的，在英伟达崛起之前， 3dfx 的 Voodoo 系列显卡就是当初 3D 游戏的绝对标杆。&lt;/p>
&lt;p>不管是古早的《 DOOM 》、《古墓丽影》还是 FPS 始祖游戏《雷神之锤》，都体现出了 API 接口的巨大优势。原本分散的游戏开发者，都聚集到了统一的平台上来做游戏，人多力量大，无数的新技术和好游戏就源源不断的冒出来了。而微软这边一开始其实并不看好游戏领域，根本不想在游戏方面投资。&lt;/p>
&lt;p>一方面 Windows 95 系统做的也差不多了，随时准备发布，管理层觉得这时候再做一个游戏编程界面没有太大必要。另一方面从老的 MS-DOS 系统上转移到新的环境里开发，谁也不敢保证会怎么样。&lt;/p>
&lt;p>Eric Engstrom 看到了这上面的前景，自己偷偷拉了个三人的小团队，开发起了 DirectX ，顶着微软管理层的压力，把这个项目给做了下来。&lt;/p>
&lt;p>到了 1995 年 4 月， DirectX 正式发布，并在后面逐步融合进了 Windows 95 ，为微软打入游戏市场，立下了汗马功劳。&lt;/p>
&lt;p>有意思的是，在 Eric Engstrom 开发 DirectX 的过程中，不仅要面对技术上的难题，还要面临微软的上层百般阻挠，面对企业内斗。&lt;/p>
&lt;p>这个过程还被写成了一本名为《 Renegades of the Empire 》（《帝国叛逆者》）的书，记述下了那段时间微软内忧外患的处境。&lt;/p>
&lt;p>不过至少结果是好的， DirectX 在经过了几个版本的更新之后，已经稳坐了游戏图形 API 的头把交椅。&lt;/p>
&lt;p>而 Glide 和 OpenGL 却被命运开了玩笑，相继翻车，给 DirectX 占领市场提供了很大机会。&lt;/p>
&lt;p>Glide 翻车是因为 3dfx 的没落，支持 Glide 的游戏及设备越来越少，它不及 Windows 系统有这么多的开发者，又不开源，没多久就顶不住了。&lt;/p>
&lt;p>OpenGL 倒是开源的，不过因为内部意见不统一，它逐渐转向了专业图形领域的方向，渐渐弱化了游戏方面的更新。&lt;/p>
&lt;p>在更新到了 DirectX 9.0 之后，微软在图形 API 的领域，基本坐稳了龙头老大的位置。&lt;/p>
&lt;p>顺带一提，微软的 XBOX 主机用到的也是 DirectX ，这样一来，就形成了一个闭环，但凡厂商想要在主机平台和 PC 平台上开发游戏，就绕不过 DirectX 。&lt;/p>
&lt;p>随之而来的就是 N 卡和 A 卡长达 10 年的显卡大战，由于两边都要用到 DirectX 来优化，&lt;strong>微软的更新就成了制衡 N 、 A 两家发展的砝码。&lt;/strong>&lt;/p>
&lt;h2 id="vulkan">Vulkan&lt;/h2>
&lt;p>OpenGL 的母公司 Khronos 推出了自家的新图形 API &lt;strong>Vulkan&lt;/strong>，意欲动摇 DirectX 的传统优势地位。&lt;/p>
&lt;p>&lt;strong>Vulkan&lt;/strong> 作为一个搅局者，他的强势之处在于跨平台的兼容性，它能在 &lt;strong>Windows、Linux、Android&lt;/strong> 三个平台上开发，连接了电脑和手机端。&lt;/p>
&lt;p>在底层硬件的兼容方面，&lt;strong>Vulkan&lt;/strong> 会更好一些，游戏开发者能更彻底的榨干显卡的性能。&lt;/p>
&lt;p>&lt;strong>未来的竞争或许会更势均力敌一些。。。&lt;/strong>&lt;/p></description></item><item><title>Docs: 音箱</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/11_%E5%A4%9A%E5%AA%92%E4%BD%93/%E9%9F%B3%E9%A2%91%E5%A4%84%E7%90%86/%E9%9F%B3%E7%AE%B1/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/11_%E5%A4%9A%E5%AA%92%E4%BD%93/%E9%9F%B3%E9%A2%91%E5%A4%84%E7%90%86/%E9%9F%B3%E7%AE%B1/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;h2 id="参考">参考：&lt;/h2>
&lt;/blockquote>
&lt;p>USB # 声卡输入
AUX IN # (Auxiliary)是指&lt;strong>音频输入。线路输入&lt;/strong>
SUB OUT # 低音输出
DC IN # 电源输入&lt;/p>
&lt;h1 id="音箱品牌">音箱品牌&lt;/h1>
&lt;p>HECATE G2000&lt;/p></description></item><item><title>Docs: 注册表</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/y.windows-%E7%AE%A1%E7%90%86/%E6%B3%A8%E5%86%8C%E8%A1%A8/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/y.windows-%E7%AE%A1%E7%90%86/%E6%B3%A8%E5%86%8C%E8%A1%A8/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://mp.weixin.qq.com/s/5ZcvRNG7GvvopcQWWdXNaw">公众号-差评，所有电脑管家都叫你清理的注册表，竟然能偷偷控制你的电脑！&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;h2 id="注册表前身">注册表前身&lt;/h2>
&lt;p>其实，注册表也不是一开始就存在于 Windows 上。&lt;/p>
&lt;p>在 Windows 95 之前，微软通过一种叫 “ 配置文件 ” 的东西，来实现如今注册表的作用。&lt;/p>
&lt;p>这里面存储的，就是一些软件的&lt;strong>基本信息&lt;/strong>。比如说配置一些文件的打开路径在哪里，或者是软件要用哪些字体来读取。&lt;/p>
&lt;p>通常通过 ini 格式的文件，配置文件会趁着咱们安装各种软件的时候，把自己丢在系统的各种文件夹里。想修改一些配置的时候，咱们可以直接去这个软件的安装目录里找 ini 文件就行。&lt;/p>
&lt;p>看上去挺方便，不过这 ini 文件最大的问题吧，就是太容易修改了，甚至可以简单到直接用记事本给打开。&lt;/p>
&lt;p>到时候手一抖改几个字，可能一个软件就打不开了。&lt;/p>
&lt;p>比如把一个 5 行的行间距手一抖改成复数，软件当场就寻思我哪见过这个？不当场宕机就不错了。万一改的还是系统配置文件，电脑指不定也得抽两抽。&lt;/p>
&lt;p>而且，当年大家用的还都是机械硬盘。。。考虑到 ini 文件分散在系统的各种犄角旮旯，&lt;strong>读取起来太麻烦，打开也嫌慢，更不方便维护。&lt;/strong>&lt;/p>
&lt;p>微软后来就一寻思，干脆把这些乱的到处都是的 ini 文件功能给&lt;strong>整合了起来。&lt;/strong>&lt;/p>
&lt;p>通过一个统一的，系统级别的分层&lt;strong>数据库&lt;/strong>来起到过去 “ 配置文件 ” 做的事情。这个库里面装的呢，就是咱们电脑里哪些花里胡哨，乱七八糟的配置。&lt;/p>
&lt;p>举个例子，我们鼠标右键的每次点击，到底会弹出来哪些菜单选项，以及具体要弹的多长。&lt;strong>都得让注册表来告诉它才行。&lt;/strong>&lt;/p>
&lt;p>而且吧，比起过去各自为战，互相之间看不对眼的配置文件。注册表还能起到一个**系统级别的调度功能，**可以把这些软件之间的信息共享给其它软件，。&lt;/p>
&lt;p>当有新的软件安装的时候，也会优先把自己能干什么，自己需要什么的消息给写入注册表里。&lt;/p>
&lt;p>就像咱们现在能用 WPS 软件来打开 word 文档，中间还得靠注册表这个 “传话筒” 来沟通才行。想让系统能弄清楚，我们得把 &lt;strong>“ wps 可以打开 word ” 文档这件事情，写到注册表里。&lt;/strong>&lt;/p>
&lt;p>借助当时更为先进的数据库结构，注册表还能够实现**多用户配置和多线程读写等功能。**别看咱们现在嫌弃注册表长的丑，&lt;strong>要知道当年，这可是少有的图形可视化界面。&lt;/strong>&lt;/p>
&lt;h2 id="注册表小解">注册表小解&lt;/h2>
&lt;p>按 win + R，在对话框里输入 “ regedit ” 来打开注册表编辑器。
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/qnpbng/1660293598735-fcf30cc1-e1be-40a6-91da-e8cf808c68a0.png" alt="">
&lt;strong>HKEY_CLASSES_ROOT&lt;/strong> # 包含有关已注册应用程序的信息 ， 包括驱动 ， 文件拓展名等等 。
&lt;strong>HKEY_CURRENT_USER&lt;/strong> # 存储特定于当前登录用户的设置 ， 包括环境变量 ， 个人桌面的设置等等 。
&lt;strong>HKEY_LOCAL_MACHINE&lt;/strong> # 存储特定于本地计算机的设置 ， 由系统内核维护在内存中 ， 以便映射所有其他子键 。 这些信息可以其它用户使用 。
&lt;strong>HKEY_USERS&lt;/strong> # 和上面的第二个项目相对 ， 包含与机器上主动加载的每个用户配置文件的 HKEY_CURRENT_USER 键对应的子键
&lt;strong>HKEY_CURRENT_CONFIG&lt;/strong> # 该主键保存了计算机当前硬件的配置信息 ， 这些配置可以根据当前所连接的网络类型或硬件驱动软件安装的改变而改变 。&lt;/p>
&lt;h3 id="备份注册表">备份注册表&lt;/h3>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/qnpbng/1660294119487-0956a3de-ee96-4771-9584-b5e4e473ab0a.png" alt="image.png">&lt;/p>
&lt;h1 id="应用示例">应用示例&lt;/h1>
&lt;h3 id="在鼠标右键菜单上添加内容">在鼠标右键菜单上添加内容&lt;/h3>
&lt;p>打开注册表后，在表上的地址栏里输入这个：&lt;code>HKEY_CLASSES_ROOT\Directory\Background\shell&lt;/code>
在 shell 中“添加项”，添加的项名就是右键菜单中的功能名
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/qnpbng/1660293800817-e8b7c6ec-a7e6-4cdc-af1b-fba835707b2f.png" alt="image.png">
不过这回还没给它加上功能，直接点击的话会报错。
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/qnpbng/1660293861254-00b77fdd-b0d2-4f40-b5a1-59f215198b70.png" alt="">
在 “lichenhao”项下添加 “command”项；修改 command 项中的默认值为想要运行进程的绝对路径
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/qnpbng/1660294056508-703dab2f-1fad-4a5e-a9ec-3ae07245dd93.png" alt="image.png">
此时右键的 “lichenhao”就可以运行 Python 了。&lt;/p></description></item><item><title>Docs: dell硬件监控OMSA</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/6.%E5%8F%AF%E8%A7%82%E6%B5%8B%E6%80%A7/%E7%9B%91%E6%8E%A7%E7%B3%BB%E7%BB%9F/dell%E7%A1%AC%E4%BB%B6%E7%9B%91%E6%8E%A7omsa/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/6.%E5%8F%AF%E8%A7%82%E6%B5%8B%E6%80%A7/%E7%9B%91%E6%8E%A7%E7%B3%BB%E7%BB%9F/dell%E7%A1%AC%E4%BB%B6%E7%9B%91%E6%8E%A7omsa/</guid><description>
&lt;h1 id="omsa全称-openmanage-server-administrator是戴尔公司自主研发的-it-系统管理解决方案">OMSA（全称 Openmanage Server Administrator),是戴尔公司自主研发的 IT 系统管理解决方案。&lt;/h1>
&lt;p>&lt;a href="http://linux.dell.com/">http://linux.dell.com/&lt;/a>
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/gknv4x/1616067497715-90aa8503-f2c3-4436-ac53-560ef9f66d5f.jpeg" alt="">&lt;/p>
&lt;h2 id="omsa-的安装">OMSA 的安装&lt;/h2>
&lt;h3 id="自动安装">自动安装&lt;/h3>
&lt;p>&lt;a href="https://linux.dell.com/repo/hardware/dsu/">https://linux.dell.com/repo/hardware/dsu/&lt;/a>&lt;/p>
&lt;ol>
&lt;li>配置存储库
&lt;ol>
&lt;li>curl -O &lt;a href="https://linux.dell.com/repo/hardware/dsu/bootstrap.cgi">https://linux.dell.com/repo/hardware/dsu/bootstrap.cgi&lt;/a>&lt;/li>
&lt;li>bash bootstrap.cgi&lt;/li>
&lt;/ol>
&lt;/li>
&lt;li>yum install srvadmin-all.x86_64&lt;/li>
&lt;/ol>
&lt;p>Note：&lt;/p>
&lt;ol>
&lt;li>srvadmin-base #代理程序，可以生成 snmp 信息&lt;/li>
&lt;li>srvadmin-server-cli #命令行客户端，可以通过命令行查看硬件信息&lt;/li>
&lt;li>srvadmin-storage-cli #存储资源的命令行客户端，不安装这个则无法获取 raid 和硬盘的数据&lt;/li>
&lt;/ol>
&lt;p>下面是使用 yum 安装 OMSA 的 repo 文件&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>~&lt;span style="color:#f92672">]&lt;/span>&lt;span style="color:#75715e"># cat /etc/yum.repos.d/DELL-OMSA.repo&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">[&lt;/span>dell-system-update_independent&lt;span style="color:#f92672">]&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>name&lt;span style="color:#f92672">=&lt;/span>dell-system-update_independent
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>baseurl&lt;span style="color:#f92672">=&lt;/span>https://linux.dell.com/repo/hardware/dsu/os_independent/
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>gpgcheck&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>gpgkey&lt;span style="color:#f92672">=&lt;/span>https://linux.dell.com/repo/hardware/dsu/public.key
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> https://linux.dell.com/repo/hardware/dsu/public_gpg3.key
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>enabled&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>exclude&lt;span style="color:#f92672">=&lt;/span>dell-system-update*.i386
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">[&lt;/span>dell-system-update_dependent&lt;span style="color:#f92672">]&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>name&lt;span style="color:#f92672">=&lt;/span>dell-system-update_dependent
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>mirrorlist&lt;span style="color:#f92672">=&lt;/span>https://linux.dell.com/repo/hardware/dsu/mirrors.cgi?osname&lt;span style="color:#f92672">=&lt;/span>el$releasever&amp;amp;basearch&lt;span style="color:#f92672">=&lt;/span>$basearch&amp;amp;native&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>gpgcheck&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>gpgkey&lt;span style="color:#f92672">=&lt;/span>https://linux.dell.com/repo/hardware/dsu/public.key
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> https://linux.dell.com/repo/hardware/dsu/public_gpg3.key
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>enabled&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>参考文章：&lt;a href="http://www.madown.com/2017/05/23/81/">http://www.madown.com/2017/05/23/81/&lt;/a>&lt;/p>
&lt;h3 id="手动安装">手动安装&lt;/h3>
&lt;p>&lt;a href="https://www.dell.com/support/home/">https://www.dell.com/support/home/&lt;/a>去该网站输入主机号查询，然后根据关键字搜索 OMSA 并下载
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/gknv4x/1616067497724-a84a9901-d1a0-4c18-9198-303c071c9960.jpeg" alt="">&lt;/p>
&lt;ol>
&lt;li>解压已下载的安装包
&lt;ol>
&lt;li>mkdir dell-omsa&lt;/li>
&lt;li>tar -zxvf OM-SrvAdmin-Dell-Web-LX-9.3.0-3465_A00.tar -C dell-omsa #&lt;/li>
&lt;/ol>
&lt;/li>
&lt;li>安装 rpm 包
&lt;ol>
&lt;li>cd dell-omsa/linux/RPMS/supportRPMS/srvadmin/RHEL7/x86_64&lt;/li>
&lt;li>yum localinstall *.rpm&lt;/li>
&lt;/ol>
&lt;/li>
&lt;/ol>
&lt;p>将 dell-r740.tar.gz 拷贝到/root/Download 目录下并执行以下脚本&lt;/p>
&lt;h2 id="omsa-的配置与使用">OMSA 的配置与使用&lt;/h2>
&lt;p>安装 dell 监控 openManager 相关组件完成后，会在/opt/dell/*目录下生成配置文件与可执行文件&lt;/p>
&lt;ul>
&lt;li>配置 openManager&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/gknv4x/1616067497704-782c72fb-2dcf-4422-9654-b71a7c89d1eb.jpeg" alt="">&lt;/p>
&lt;ul>
&lt;li>/opt/dell/srvadmin/sbin/srvadmin-services.sh start #启动 openManger
&lt;ul>
&lt;li>该脚本会通过 systemd 启动三个服务&lt;/li>
&lt;li>instsvcdrv #&lt;/li>
&lt;li>dataeng #&lt;/li>
&lt;li>dsm_om_connsvc #web 控制台&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>/opt/dell/srvadmin/sbin/srvadmin-services.sh enable #设置开机自启 openManager&lt;/li>
&lt;li>systemctl stop dsm_om_connsvc #关闭 openManager 的 web 服务&lt;/li>
&lt;li>systemctl disable dsm_om_connsvc #将 openManager 的 web 服务开机自启关闭&lt;/li>
&lt;li>systemctl restart snmpd #重启 snmp 服务。由于安装 openManager 会在 snmpd 的配置文件中写入内容，所以需要重启 snmpd 服务使得该配置生效&lt;/li>
&lt;li>在 wiseman 上添加相关的 dell 硬件监控。效果如图，在主机的模板里添加 dell server 模板&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/gknv4x/1616067497780-3afd659e-d460-4c2b-8d66-1f9a3c67890a.jpeg" alt="">&lt;/p>
&lt;h1 id="命令行工具使用说明">命令行工具使用说明&lt;/h1>
&lt;h2 id="omreport-command">omreport COMMAND&lt;/h2>
&lt;p>在任何时候都可以使用 omreport -?来获取命令帮助以查看都有哪些可用的 COMMAND，例如：omreport -?、omreport chassis -?等
COMMAND&lt;/p>
&lt;ol>
&lt;li>about Product and version properties.&lt;/li>
&lt;li>licenses Displays the digital licenses of the installed hardware devices.&lt;/li>
&lt;li>preferences Report system preferences.&lt;/li>
&lt;li>system System component properties.&lt;/li>
&lt;li>chassis 机架组件的属性。i.e.基本硬件的信息。Chassis component properties.&lt;/li>
&lt;li>storage #显示存储组件的属性&lt;/li>
&lt;/ol>
&lt;h2 id="omreport-storage">omreport storage&lt;/h2>
&lt;p>EXAMPLE&lt;/p>
&lt;ol>
&lt;li>omreport storage pdisk controller=0 #&lt;/li>
&lt;/ol></description></item><item><title>Docs:</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/0_%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E7%B1%BB-unix-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/euleros-%E4%B8%8E-openeuler/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/0_%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E7%B1%BB-unix-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/euleros-%E4%B8%8E-openeuler/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://developer.huaweicloud.com/ict/cn/site-euleros/euleros">EulerOS 官网&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.openeuler.org/zh/">OpenEuler 官网&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>华为真是把造词玩明白了，乱七八糟的，本家私有化的产品就一堆重复早轮子的名字，连开源系统都整俩名字&lt;/p>
&lt;p>EulerOS 与 OpenEuler&lt;/p>
&lt;ul>
&lt;li>EulerOS # 企业&lt;/li>
&lt;li>OpenEuler # 开源&lt;/li>
&lt;/ul></description></item><item><title>Docs: (弃用)Graph 类型面板详解</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/6.%E5%8F%AF%E8%A7%82%E6%B5%8B%E6%80%A7/grafana/panel%E9%9D%A2%E6%9D%BF-%E4%B8%8E-dashboard%E4%BB%AA%E8%A1%A8%E7%9B%98/time-series-%E7%B1%BB%E5%9E%8B%E9%9D%A2%E6%9D%BF/%E5%BC%83%E7%94%A8graph-%E7%B1%BB%E5%9E%8B%E9%9D%A2%E6%9D%BF%E8%AF%A6%E8%A7%A3/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/6.%E5%8F%AF%E8%A7%82%E6%B5%8B%E6%80%A7/grafana/panel%E9%9D%A2%E6%9D%BF-%E4%B8%8E-dashboard%E4%BB%AA%E8%A1%A8%E7%9B%98/time-series-%E7%B1%BB%E5%9E%8B%E9%9D%A2%E6%9D%BF/%E5%BC%83%E7%94%A8graph-%E7%B1%BB%E5%9E%8B%E9%9D%A2%E6%9D%BF%E8%AF%A6%E8%A7%A3/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;/blockquote>
&lt;p>这是一个初始的 Graph 面板，有两条查询语句，更改了序列的名称。&lt;/p>
&lt;pre>&lt;code>sum(node_memory_MemTotal_bytes)
(sum(node_memory_MemTotal_bytes{} - node_memory_MemAvailable_bytes{}) / sum(node_memory_MemTotal_bytes{}))*100
&lt;/code>&lt;/pre>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/qzbd5e/1616067957167-730a2679-0ad0-488a-9c4c-8f3ba5ace79d.png" alt="">&lt;/p>
&lt;p>Graph 是一个二维的，具有 x/y Axes(轴) 的面板。x 轴(横轴) 以时间分布、y 轴(纵轴) 以样本值分布&lt;/p>
&lt;p>下面的文章将只介绍 Graph 面板的独有配置，有很多共有配置详见&lt;a href="https://www.yuque.com/go/doc/33145831">此处&lt;/a>&lt;/p>
&lt;h1 id="panel--面板配置">Panel # 面板配置&lt;/h1>
&lt;h2 id="display--显示设置值的显示样式柱状线条圆点三种">Display # 显示。设置值的显示样式(柱状、线条、圆点三种)&lt;/h2>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/qzbd5e/1616067957211-044eecd5-5b98-425a-8de8-3799545d50f6.png" alt="">&lt;/p>
&lt;p>在 Display 标签里，有 5 个开关，Bars、Lines、Staircase、Points 用于指定值的显示样式。Alert thresholds 用于指定是否显示告警阈值。&lt;/p>
&lt;blockquote>
&lt;p>其他的配置选项，都是在开启某个样式后，才会显示对应样式专用的选项。
Min step 设置时间长一点，Bars 与 Points 样式才可以看出来效果。否则都挤到一坨去了~&lt;/p>
&lt;/blockquote>
&lt;p>&lt;strong>Bars&lt;/strong> # 柱状图样式。当 X 轴的模式变为 Series、Historgram 时，自动开启
&lt;strong>Lines&lt;/strong> # 线条样式。默认样式&lt;/p>
&lt;ul>
&lt;li>&lt;strong>Staircase&lt;/strong> # 开启线条样式时，才可以使用这种样式。&lt;/li>
&lt;li>&lt;strong>Line width&lt;/strong> # 线条宽度。&lt;/li>
&lt;li>&lt;strong>Area fill&lt;/strong> # 线条到底部这一区域的填充度。默认 1。&lt;/li>
&lt;li>&lt;strong>Fill gradient&lt;/strong> # 填充渐变。默认 0。&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>Points&lt;/strong> # 圆点样式。
&lt;strong>Point radius&lt;/strong> # 每个圆点的半径
&lt;strong>Alert thresholds&lt;/strong> # 在面板上显示报警阈值和区域&lt;/p>
&lt;p>除了设置面板中值的显示样式，还可以设置一些其他的设置
&lt;strong>Stacking and null value(叠加与空值)&lt;/strong>
用于在面板上叠加所有 series 的值&lt;/p>
&lt;p>**Hover tooltip(悬停提示) # **开启后，鼠标悬停在面板上，会出现一些关于 series 的信息
Mode # 模式。&lt;/p>
&lt;ul>
&lt;li>All series # 鼠标悬停到面板时，显示所有 series 的信息&lt;/li>
&lt;li>Single # 鼠标选定到面板时，只显示鼠标所在的 series 的信息。&lt;/li>
&lt;/ul>
&lt;p>Sort order # 排序。有三种排序方式：None(不排序)、Increasing(由上到下逐渐增大)、Decreasing(由上到下逐渐减小)&lt;/p>
&lt;h2 id="series-overrides--序列替换用于个性化每个序列的配置">Series overrides # 序列替换。用于个性化每个序列的配置&lt;/h2>
&lt;p>顾名思义，就是用来替换序列样式的。当一个面板上，配置了多个查询语句，这时就会产生多条 Series。而右侧的配置，是统一的，所有 Series 的配置内容都一样，这样不利于数据展示。所以通过 Series overrides 可以个性化得配置每一条 Series，让不同的 Series 展示出不同的效果(比如多条 Series 可以具有不同的单位、不同的线条宽度不同、不同的显示方式)&lt;/p>
&lt;p>点击 &lt;code>+ Add series override&lt;/code> 即可为指定的 series 进行配置&lt;/p>
&lt;p>在 &lt;code>Alias or regex&lt;/code> 选择要配置的序列。这里也可以使用正则表达式进行多个 series 的匹配。然后点击 &lt;code>+&lt;/code> 符号，即可为选定的 series 进行单独的配置。&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/qzbd5e/1616067957244-03bc347c-faa5-4145-8a6b-fe3138242f0b.png" alt="">&lt;/p>
&lt;h3 id="应用实例">应用实例&lt;/h3>
&lt;p>上面的例子，一个语句是内存用量，一个语句是内存使用率，单位是不一样(一个 KiB、一个百分比)。这时候，就需要使用 Series overrides，为每个 Serie 单独配置。不但单位可以分别配置，还可以将 Serie 移动到右侧的 Y 轴。还可以为不同的 series 配置不用的显示方式(比如有的用圆点、有点用线条、有的用柱状图，都可以在同一个面板显示出来)&lt;/p>
&lt;p>比如我现在为 总平均使用率 序列进行单独配置，面板就会变成下面这种效果：
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/qzbd5e/1616067957204-1cae00cd-e82c-4042-9d6b-11daed4f9b8f.png" alt="">&lt;/p>
&lt;h2 id="axis--设定坐标轴的显示内容">Axis # 设定坐标轴的显示内容&lt;/h2>
&lt;p>在这里可以更改 x 轴 和 y 轴 的显示内容。常用于配置 metrics 值的 unit(单位)、Decimals(小数位数)。&lt;/p>
&lt;p>&lt;strong>Left Y/Right Y&lt;/strong> # 更改 Y-axes(Y 轴) 的信息&lt;/p>
&lt;ul>
&lt;li>Show # 是否显示这个轴&lt;/li>
&lt;li>Unit # 配置 Y 轴 的单位&lt;/li>
&lt;li>Decimals # 配置 Y 轴显示的小数位数。&lt;/li>
&lt;li>Label # 配置 Y 轴 的标签(标签会显示在 Y 轴 的旁边)&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>Y-Axes&lt;/strong> # Y 轴 配置。一些对齐方式
&lt;strong>X-Axis&lt;/strong> # X 轴 配置。可以更改 X 轴的 Mode(模式)&lt;/p>
&lt;ul>
&lt;li>Mode # 模式。用于改变 X 轴的 显示模式。
&lt;ul>
&lt;li>Time # 时间模式。默认模式。X 轴 表示 时间，数据按时间分组（例如，按小时或分钟）。&lt;/li>
&lt;li>Series # 序列模式。X 轴 表示 series，数据按照序列分组。Y 轴 仍然代表该序列的值
&lt;ul>
&lt;li>注意：当 X 轴 切换到 Series 模式时，Display 配置中的将自动使用柱状图的方式&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Histogram # 直方图模式。X 轴 表示 序列的值，Y 轴 表示 该值的计数。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h3 id="x-轴的-series-模式-示例">X 轴的 Series 模式 示例&lt;/h3>
&lt;p>当 X 轴 变为 series 模式 时，由于没有时间这种维度，所以一般都使用 当前值。
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/qzbd5e/1616067957169-8ff35969-aa1d-4259-8144-1a88bb33a486.png" alt="">&lt;/p>
&lt;h2 id="legend--用于配置面板内的-legenddocsit学习笔记6可观测性grafanapanel面板20-与20dashboard仪表盘panel面板20-配置详解md-配置详解md">Legend # 用于配置面板内的 [Legend](/docs/IT学习笔记/6.可观测性/Grafana/Panel(面板)%20 与%20Dashboard(仪表盘)/Panel(面板)%20 配置详解.md 配置详解.md)&lt;/h2>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/qzbd5e/1616067957204-998bd4db-f185-4f42-9138-9edb69081d84.png" alt="">&lt;/p>
&lt;h2 id="time-regions--时间区域graph-类型面板不常用">Time regions # 时间区域。Graph 类型面板不常用&lt;/h2>
&lt;h1 id="field--字段配置">Field # 字段配置&lt;/h1>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/qzbd5e/1616067957229-733ae428-0442-42e4-b76e-d36f89196a3d.png" alt="">&lt;/p>
&lt;h1 id="overrides--字段替换配置graph-类型面板不常用">Overrides # 字段替换配置，Graph 类型面板不常用&lt;/h1>
&lt;p>详见：[Overrides](/docs/IT学习笔记/6.可观测性/Grafana/Panel(面板)%20 与%20Dashboard(仪表盘)/Panel(面板)%20 配置详解.md 配置详解.md)&lt;/p></description></item></channel></rss>