<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>断念梦 – 文档</title><link>https://desistdaydream.github.io/docs/</link><description>Recent content in 文档 on 断念梦</description><generator>Hugo -- gohugo.io</generator><atom:link href="https://desistdaydream.github.io/docs/index.xml" rel="self" type="application/rss+xml"/><item><title>Docs: 1.Bootloader</title><link>https://desistdaydream.github.io/docs/IT%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/1.Bootloader/1.Bootloader/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/IT%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/1.Bootloader/1.Bootloader/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Bootloader">Wiki,Bootloader&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>&lt;strong>Bootloader(引导加载程序)&lt;/strong> 是负责 &lt;a href="https://en.wikipedia.org/wiki/Booting">booting(引导)&lt;/a> 计算器的软件。通常也被称为 Bootstrap Loader、Bootstrap。&lt;/p>
&lt;p>当计算机关闭时，操作系统、应用程序代码和数据 ‍‌ 仍存储在非易失性存储器中。当计算机开机时，它通常没有操作系统或其随机存取存储器 (RAM) 中的加载程序。计算机首先执行存储在只读存储器（ROM，以及后来的 EEPROM、NOR 闪存）中的相对较小的程序以及一些需要的数据，以初始化 RAM（特别是在 x86 系统上），访问非易失性设备（通常是块设备，例如 NAND 闪存）或可以将操作系统程序和数据加载到 RAM 中的设备。&lt;/p>
&lt;h1 id="配置">配置&lt;/h1>
&lt;p>&lt;strong>/boot/*&lt;/strong> # 所有关于系统引导启动的配置信息，都在该目录下
&lt;strong>/boot/grub2/&lt;/strong> #
&lt;strong>/etc/default/grub&lt;/strong> #&lt;/p>
&lt;h1 id="引导管理命令行工具">引导管理命令行工具&lt;/h1>
&lt;p>grub2-*
grubby
grub2-mkconfig&lt;/p></description></item><item><title>Docs: 1.Linux Kernel</title><link>https://desistdaydream.github.io/docs/IT%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2.Kernel%E5%86%85%E6%A0%B8/1.Linux-Kernel/1.Linux-Kernel/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/IT%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2.Kernel%E5%86%85%E6%A0%B8/1.Linux-Kernel/1.Linux-Kernel/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://github.com/torvalds">Linus Torvalds&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://github.com/torvalds/linux">GitHub,Linux 内核项目&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.kernel.org/">官网&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.kernel.org/doc/html/latest/">官方文档&lt;/a>
&lt;ul>
&lt;li>&lt;a href="https://www.infradead.org/~mchehab/kernel_docs/index.html">https://www.infradead.org/~mchehab/kernel_docs/index.html&lt;/a> 这是哪里的官方文档？&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;a href="https://www.kernel.org/doc/man-pages/index.html">官方 Manual(手册)&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Kernel_(operating_system)">Wiki,Kernel&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki//boot/">Wiki,/boot&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Vmlinux">Wiki,vmlinux&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Initial_ramdisk">Wiki,Initial ramdisk&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/System.map">Wiki,System.map&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://github.com/raspberrypi/linux">树莓派 Linux&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/8/html/managing_monitoring_and_updating_the_kernel/index">RedHat 官方文档,8-管理、监控和更新内核&lt;/a>&lt;/li>
&lt;li>&lt;a href="http://www.linfo.org/vmlinuz.html">http://www.linfo.org/vmlinuz.html&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.zhihu.com/question/22045825">知乎,initrd 和 initramfs 的区别&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>&lt;strong>Kernel(内核)&lt;/strong> 是一个作为操作系统核心的计算机程序，对系统中的一切具有完全控制权。它负责管理系统的进程、内存、设备驱动程序、文件和网络系统，决定着系统的性能和稳定性。&lt;/p>
&lt;p>Kernel 是计算器启动时首先加载程序之一(在 &lt;a href="https://desistdaydream.github.io/docs/IT%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/1.Bootloader/1.Bootloader.md">Bootloader&lt;/a>并处理硬件和软件之间的交互。并且处理启动过程的其余部分、以及内存、外设、和来自软件的输入/输出请求，将他们转换为 CPU 的数据处理指令。&lt;/p>
&lt;h2 id="kernel-组成及系统调用">Kernel 组成及系统调用&lt;/h2>
&lt;p>Linux 内核由如下几部分组成：内存管理、进程管理、设备驱动程序管理、文件系统管理、网络管理等。如图：
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/fkp6xi/1616168349819-c21dd43c-79b7-4ec2-abd4-c8bb0e3c7686.jpeg" alt="">
**System Call Interface(系统调用接口，简称 SCI) **层提供了某些机制执行从用户空间到内核的函数调用。这个接口依赖于体系结构，甚至在相同的处理器家族内也是如此。SCI 实际上是一个非常有用的函数调用多路复用和多路分解服务。&lt;/p>
&lt;p>系统调用介绍详见 &lt;a href="https://desistdaydream.github.io/docs/IT%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2.Kernel(%E5%86%85%E6%A0%B8)/3.System%20Call/System%20Call.md">System Call(系统调用)&lt;/a> 章节&lt;/p>
&lt;h2 id="linux-man-手册使用说明">Linux man 手册使用说明&lt;/h2>
&lt;p>在 Linux Kernel 的官方 man 手册中，记录了用户空间程序使用 Linux 内核 和 C 库的接口。对于 C 库，主要聚焦于 GUN C(glibc)，尽管在已知的情况下，还包括可用于 Linux 的其他 C 库中的变体文档。在这个 man 手册中，分为如下几部分&lt;/p>
&lt;ul>
&lt;li>&lt;strong>&lt;a href="https://man7.org/linux/man-pages/dir_section_1.html">User commands&lt;/a>(用户命令)&lt;/strong> # 介绍一些用户空间的应用程序。&lt;/li>
&lt;li>&lt;strong>&lt;a href="https://man7.org/linux/man-pages/dir_section_2.html">System calls&lt;/a>(系统调用)&lt;/strong> # Linux Kernel 可以提供的所有 System Calls(系统调用)&lt;/li>
&lt;li>&lt;strong>&lt;a href="https://man7.org/linux/man-pages/dir_section_3.html">Library functions&lt;/a>(库函数)&lt;/strong> # C 标准库可以提供的函数。&lt;/li>
&lt;li>&lt;strong>&lt;a href="https://man7.org/linux/man-pages/dir_section_4.html">Devices&lt;/a>(设备)&lt;/strong> # 各种设备的详细信息，这些设备大多都在 /dev 目录中。&lt;/li>
&lt;li>&lt;strong>&lt;a href="https://man7.org/linux/man-pages/dir_section_5.html">Files&lt;/a>(文件)&lt;/strong> # 各种文件格式和文件系统&lt;/li>
&lt;li>&lt;strong>&lt;a href="https://man7.org/linux/man-pages/dir_section_7.html">Overviews, conventions, and miscellaneous&lt;/a>(概述、约定 和 其他)&lt;/strong> #&lt;/li>
&lt;li>&lt;strong>&lt;a href="https://man7.org/linux/man-pages/dir_section_8.html">Superuser and system administration commands&lt;/a>(超级用户和系统管理员命令)&lt;/strong> # 介绍一些 GUN C 库提供的程序。&lt;/li>
&lt;/ul>
&lt;p>在 Linux man 手册中，可以找到 Linux 系统中的一切使用说明。Linux 操作系统围绕 Linux Kernel 构建了一套高效、健壮的应用程序运行环境&lt;/p>
&lt;h1 id="intirdimgvmlinuzsystemmap-文件">intird.img、vmlinuz、System.map 文件&lt;/h1>
&lt;p>Kernel 会被安装到 /boot 目录中，并生成 &lt;strong>config、initrd.img、System.map、vmlinuz&lt;/strong> 这几个文件&lt;/p>
&lt;h2 id="vmlinuz">vmlinuz&lt;/h2>
&lt;p>vmlinuz 是 &lt;a href="http://www.linfo.org/linuxdef.html">Linux&lt;/a> &lt;a href="http://www.linfo.org/kernel.html">&lt;em>内核&lt;/em>&lt;/a> 可执行文件的名称。&lt;/p>
&lt;p>vmlinuz 是一个压缩的 Linux 内核，它是_可引导的_。可引导意味着它能够将操作系统加载到内存中，以便计算机变得可用并且可以运行应用程序。&lt;/p>
&lt;p>vmlinuz 不应与_vmlinux_混淆，后者是非压缩和不可引导形式的内核。vmlinux 通常只是生成 vmlinuz 的中间步骤。&lt;/p>
&lt;p>vmlinuz 位于 /boot 目录中，该目录包含开始引导系统所需的文件。名为 vmlinuz 的文件可能是实际的内核可执行文件本身，也可能是内核可执行文件的链接，该链接可能带有诸如 &lt;code>/boot/vmlinuz-2.4.18-19.8.0&lt;/code> 之类的名称（即特定内核的名称）内核版本）。这可以通过使用 ls &lt;a href="http://www.linfo.org/command.html">命令&lt;/a>（其目的是列出指定目录的内容）及其 -l 选项（它告诉 ls 提供有关指定目录中每个对象的详细信息）来轻松确定，如下所示：&lt;/p>
&lt;blockquote>
&lt;p>&lt;code>ls -l /boot&lt;/code>&lt;/p>
&lt;/blockquote>
&lt;p>如果 vmlinuz 是一个普通文件（包括可执行文件），则第一列中有关它的信息将以连字符开头。如果是链接，它将以字母_l_开头。
通过发出以下命令   来_编译_Linux 内核：&lt;/p>
&lt;blockquote>
&lt;p>&lt;code>make bzImage&lt;/code>&lt;/p>
&lt;/blockquote>
&lt;p>这会在 /usr/src/linux/arch/i386/linux/boot/ 等目录中创建名为_bzImage_的文件。&lt;/p>
&lt;p>编译是将内核的&lt;a href="http://www.linfo.org/source_code.html">&lt;em>源代码&lt;/em>&lt;/a>（即内核由人类编写的原始形式）转换为_目标代码_（计算机处理器可以直接理解）。它由称为&lt;a href="http://www.linfo.org/compiler.html">&lt;em>编译器&lt;/em>&lt;/a>的专门程序执行，通常是&lt;a href="http://www.linfo.org/gcc.html">&lt;em>GCC&lt;/em>&lt;/a>（&lt;a href="http://www.linfo.org/gnu.html">GNU&lt;/a>编译器集合）中的一个。&lt;/p>
&lt;p>然后使用 _cp &lt;em>命令将 bzImage 复制到 /boot 目录，同时使用诸如以下命令   重命名_vmlinuz&lt;/em>&lt;/p>
&lt;blockquote>
&lt;p>&lt;code>cp /usr/src/linux/arch/i386/linux/boot/bzImage /boot/vmlinuz&lt;/code>&lt;/p>
&lt;/blockquote>
&lt;p>vmlinuz 不仅仅是一个压缩图像。它还内置了_gzip_解压缩器代码。gzip 是&lt;a href="http://www.linfo.org/unix-like.html">类 Unix&lt;/a>操作系统上最流行的压缩实用程序之一。&lt;/p>
&lt;p>一个名为_zImage_文件的编译内核是在一些较旧的系统上创建的，并保留在较新的系统上以实现向后兼容性。zImage 和 bzImage 都是用 gzip 压缩的。区别在于 zImage 解压到_低内存_（即前 640kB），bzImage 解压到_高内存_（1MB 以上）。有一个常见的误解，认为 bzImage 是使用_bzip2_实用程序压缩的。实际上，&lt;em>b_只代表_big&lt;/em>。&lt;/p>
&lt;p>&lt;em>vmlinuz&lt;/em> 这个名字很大程度上是历史的偶然。在贝尔实验室开发的原始 UNIX 上的内核二进制文件称为_unix_。当后来在加州大学伯克利分校 (UCB) 编写包含支持&lt;a href="http://www.linfo.org/virtual_memory.html">&lt;em>虚拟内存&lt;/em>&lt;/a>的新内核时，内核二进制文件更名为_vmunix_。&lt;/p>
&lt;p>虚拟内存是使用硬盘驱动器 (HDD) 上的空间来模拟额外的 RAM（随机存取内存）容量。与当时使用的其他一些流行操作系统（例如&lt;a href="http://www.linfo.org/ms-dos.html">MS-DOS）&lt;/a>相比，Linux 内核几乎从 Linux 一开始就支持它。&lt;/p>
&lt;p>因此，Linux 内核很自然地被称为_vmlinux_。由于 Linux 内核可执行文件被制作成压缩文件，并且压缩文件在类 Unix 系统上通常具有_z_或_gz_扩展名，因此压缩内核可执行文件的名称变为_vmlinuz_。&lt;/p>
&lt;h2 id="initrd">initrd&lt;/h2>
&lt;p>&lt;strong>Initial RAM Disk(初始内存磁盘，简称 initrd)&lt;/strong> 是一种将临时根文件系统加载到内存中的方案，可以作为 Linux 启动过程的一部分。有两种方法来实现这种方案：&lt;/p>
&lt;ul>
&lt;li>&lt;strong>initrd # Initial RAM Disk。&lt;/strong> 就是把一块内存（ram）当做磁盘（disk）去挂载，然后找到 ram 里的 init 执行。&lt;/li>
&lt;li>&lt;strong>initramfs # Initial RAM Filesystem。&lt;/strong> 直接在 ram 上挂载文件系统，执行文件系统中的 init。&lt;/li>
&lt;/ul>
&lt;p>这两者通常用于在挂载真正的根文件系统之前执行一些准备工作。&lt;/p>
&lt;blockquote>
&lt;p>不要被文件名迷惑，kernel 2.6 以来都是 initramfs 了，只是很多还沿袭传统使用 initrd 的名字
initramfs 的工作方式更加简单直接一些，启动的时候加载内核和 initramfs 到内存执行，内核初始化之后，切换到用户态执行 initramfs 的程序/脚本，加载需要的驱动模块、必要配置等，然后加载 rootfs 切换到真正的 rootfs 上去执行后续的 init 过程。&lt;/p>
&lt;/blockquote>
&lt;blockquote>
&lt;p>initrd 是 2.4 及更早的用法（现在你能见到的 initrd 文件实际差不多都是 initramfs 了），运行过程大概是内核启动，执行一些 initrd 的内容，加载模块啥的，然后交回控制权给内核，最后再切到用户态去运行用户态的启动流程。&lt;/p>
&lt;/blockquote>
&lt;blockquote>
&lt;p>从格式看，老的 initrd 是一个压缩的内存文件系统，具体是啥忘了，年月太久了。现在的 initramfs 是一个 gzip 压缩的 cpio 文件系统打包，如果遇到什么紧急情况需要处理的时候，你可以建立一个临时目录，把 initramfs 解压之后，直接 cpio -idv 解压出来，改之后再用 cpio 和 gzip 封上即可。虽然大家都喜欢用 tar 打包，但掌握点 cpio 在关键时刻还是可以救命的。&lt;/p>
&lt;/blockquote>
&lt;p>在早期的 Linux 系统中，一般就只有软盘或者硬盘被用来作为 Linux 的根文件系统，因此很容易把这些设备的驱动程序集成到内核中。但是现在根文件系统可能保存在各种存储设备上，包括 SCSI、SATA、U 盘等等。总不能每出一个，就要重新编译一遍内核吧？~这样不但麻烦，也不实用，所以后来 Linux 就提供了一个灵活的方法来解决这些问题。就是 &lt;strong>initrd&lt;/strong>。&lt;/p>
&lt;blockquote>
&lt;p>可以把 initrd 当做 WinPE。当使用 WinPE 启动后会发现你的计算机就算没有硬盘也能在正常运行，其中有个文件系统 B:/ 分区，这个分区就是内存模拟的磁盘。&lt;/p>
&lt;/blockquote>
&lt;p>initrd.img 文件就是个 ram disk 的映像文件。ramdisk 是用一部分内存模拟成磁盘，让操作系统访问。ram disk 是标准内核文件认识的设备(/dev/ram0)文件系统也是标准内核认识的文件系统。内核加载这个 ram disk 作为根文件系统并开始执行其中的&amp;quot;某个文件&amp;quot;（2.6 内核是 init 文件）来加载各种模块，服务等。经过一些配置和运行后，就可以去物理磁盘加载真正的 root 分区了，然后又是一些配置等，最后启动成功。&lt;/p>
&lt;p>也就是你只需要定制适合自己的 initrd.img 文件就可以了。这要比重编内核简单多了，省时省事低风险。&lt;/p>
&lt;h3 id="查看-initrd-文件">查看 initrd 文件&lt;/h3>
&lt;p>我们可以通过如下方式，解压出 initrd.img 文件，下面分别以 Ubuntu 20.04 TLS 系统和 CentOS Stream 8 系统为例：&lt;/p>
&lt;blockquote>
&lt;p>解压方法来源：&lt;a href="https://unix.stackexchange.com/questions/163346/why-is-it-that-my-initrd-only-has-one-directory-namely-kernel">https://unix.stackexchange.com/questions/163346/why-is-it-that-my-initrd-only-has-one-directory-namely-kernel&lt;/a>&lt;/p>
&lt;/blockquote>
&lt;p>Ubuntu 20.04 TLS&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>root@lichenhao:~/test_dir# mkdir -p /root/test_dir/root
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>root@lichenhao:~/test_dir# cp /boot/initrd.img /root/test_dir/
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>root@lichenhao:~/test_dir/root# &lt;span style="color:#f92672">(&lt;/span>cpio -id; cpio -i; unlz4 | cpio -id&lt;span style="color:#f92672">)&lt;/span> &amp;lt; ../initrd.img
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">62&lt;/span> blocks
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">9004&lt;/span> blocks
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">450060&lt;/span> blocks
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>root@lichenhao:~/test_dir/root# ls
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>bin conf cryptroot etc init kernel lib lib32 lib64 libx32 run sbin scripts usr var
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>CentOS Stream 8&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">[&lt;/span>root@master-2 root&lt;span style="color:#f92672">]&lt;/span>&lt;span style="color:#75715e"># mkdir -p /root/test_dir/root&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">[&lt;/span>root@master-2 root&lt;span style="color:#f92672">]&lt;/span>&lt;span style="color:#75715e"># cp /boot/initramfs-4.18.0-294.el8.x86_64.img /root/test_dir&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">[&lt;/span>root@master-2 root&lt;span style="color:#f92672">]&lt;/span>&lt;span style="color:#75715e"># cd /root/test_dir/root&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">[&lt;/span>root@master-2 root&lt;span style="color:#f92672">]&lt;/span>&lt;span style="color:#75715e"># (cpio -id; zcat | cpio -id) &amp;lt; ../initramfs-4.18.0-294.el8.x86_64.img&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">[&lt;/span>root@master-2 root&lt;span style="color:#f92672">]&lt;/span>&lt;span style="color:#75715e"># ls&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>bin dev early_cpio etc init kernel lib lib64 proc root run sbin shutdown sys sysroot tmp usr var
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>可以看到，initrd.img 中包含了一个系统最基本的目录结构&lt;/p>
&lt;h1 id="kernel-关联文件">Kernel 关联文件&lt;/h1>
&lt;p>&lt;strong>/boot/*&lt;/strong> #&lt;/p>
&lt;ul>
&lt;li>&lt;strong>./config-$(uname -r)&lt;/strong> # Kernel 的扩展配置文件。Kernel 文档中，将该文件称为 &lt;strong>Boot Configuration&lt;/strong>。&lt;/li>
&lt;li>&lt;strong>./initrd.img&lt;/strong> # 在内核挂载真正的根文件系统前使用的临时文件系统&lt;/li>
&lt;li>&lt;strong>./vmlinuz&lt;/strong> # Linux 内核&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>/etc/sysctl.conf&lt;/strong> # 系统启动时读取的内核参数文件&lt;/p>
&lt;ul>
&lt;li>&lt;strong>/etc/sysctl.d/*&lt;/strong> # 系统启动时时读取的内核参数目录&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>/usr/lib/sysctl.d/*&lt;/strong> #&lt;/p>
&lt;p>&lt;strong>/proc/sys/*&lt;/strong> # 内核参数(也称为内核变量)所在路径。该目录(从 1.3.57 版本开始)包含许多与内核变量相对应的文件和子目录。 可以使用 &lt;a href="https://www.yuque.com/go/doc/33222789">proc 文件系统&lt;/a> 以及 sysctl(2) 系统读取或加载这些变量，有时可以对其进行修改。&lt;/p></description></item><item><title>Docs: 2.Kernel(内核)</title><link>https://desistdaydream.github.io/docs/IT%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2.Kernel%E5%86%85%E6%A0%B8/Kernel%E5%86%85%E6%A0%B8/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/IT%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2.Kernel%E5%86%85%E6%A0%B8/Kernel%E5%86%85%E6%A0%B8/</guid><description>
&lt;h2 id="操作系统-os-与内核-kernel-有什么区别">操作系统 OS 与内核 Kernel 有什么区别？&lt;/h2>
&lt;p>原文链接：&lt;a href="https://mp.weixin.qq.com/s/-5tDn2-IS6Xo6DwQJN4c3Q">https://mp.weixin.qq.com/s/-5tDn2-IS6Xo6DwQJN4c3Q&lt;/a>&lt;/p>
&lt;p>&lt;strong>通用底盘技术&lt;/strong>&lt;/p>
&lt;p>Canoo 公司有一项核心技术专利，这就是它们的通用电动底盘技术，长得是这个样子，非常像一个滑板：&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/egzxwb/1624588718457-99ed8a8e-d53b-465e-8d99-4345935ad5a4.webp" alt="">&lt;/p>
&lt;p>这个带轮子、有电池、能动的滑板已经包含了一辆车&lt;strong>最核心&lt;/strong>的组件，差的就是一个外壳。这个看起来像滑板的东西就是所谓的电池系统和底盘一体化技术，Canoo 公司在它们的通用底盘上加装不同的外壳就能制造出不同的车型。&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/egzxwb/1624588718511-01fe725d-cd0d-48d1-a4e8-1010d7d5a69b.png" alt="">&lt;/p>
&lt;h5 id="什么是内核">&lt;strong>什么是内核？&lt;/strong>&lt;/h5>
&lt;p>在上面这个示例中，&lt;strong>包含轮子以及电池系统的底盘就好比内核，而套上外壳加上椅子以及内饰后的整体成品就好比操作系统&lt;/strong>。内核仅仅是操作系统的一部分，是真正与硬件交互的那部分软件，与硬件交互包括读写硬盘、读写网盘、读写内存以及任何连接到系统中的硬件。除了与硬件交互外，内核还负责分配资源，分配什么资源呢？所谓资源就是硬件，比如 CPU 时间、内存、IO 等等，这些都是资源。&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/egzxwb/1624588718454-36e25783-bbc0-49ec-a620-26d8580cee9d.png" alt="">&lt;/p>
&lt;p>因此，内核的职责就是以进程的形式来分配 CPU 时间，以虚拟内存的形式来分配物理内存，以文件的形式来管理 IO 设备。&lt;/p>
&lt;h5 id="什么是操作系统">&lt;strong>什么是操作系统？&lt;/strong>&lt;/h5>
&lt;p>然而只有一个内核实际上是做不了什么真正有用的事情，就像上面示例中那个通用底盘一样，这个底盘确实能跑起来，但你没办法开着这样一个底盘出去浪，因为这个底盘很难用。因此，你不得不加装上方向盘、座椅以及车身外壳等，同样的道理，内核是给人用的，为了与内核交互，发明了命令行以及图形界面 GUI。&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/egzxwb/1624588718509-9945a71c-556e-4b5a-be9f-8a123c68473c.png" alt="">&lt;/p>
&lt;p>在 Windows 平台就是给程序员提供编程接口的是 Windows API，这层 API 包罗万象，不但包括上文提到对系统调用的封装，还包括其它功能，像创建带有图形界面的应用程序等等。&lt;strong>但在 Linux 世界你找不到一种类似 Windows API 的东西&lt;/strong>，毕竟 Windows 是微软自家产品，什么都可以打包起来，Linux 只是一个开源的内核，如果一定要找一个类似的东西话那就是 libc，也就是 C 标准库，这里同样包括了对系统调用的封装以及一些库函数，但 libc 不包含创建带有图形界面应用程序的功能。现在我们知道了，操作系统需要提供两种接口：&lt;/p>
&lt;ul>
&lt;li>给用户提供操作接口。&lt;/li>
&lt;li>给程序员提供编程接口。&lt;/li>
&lt;/ul>
&lt;p>这些就是好比汽车的外壳，我们(用户和程序员)看得见摸得着，外壳加上底盘——也就是内核，才是功能完善的操作系统。&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/egzxwb/1624588718491-8aabc98e-8938-4b52-95fd-265d5f7d95b8.webp" alt="">&lt;/p>
&lt;h5 id="各种各样的操作系统">&lt;strong>各种各样的操作系统&lt;/strong>&lt;/h5>
&lt;p>实际上我们熟悉的 Linux 只是内核而不能称得上是操作系统，Ubuntu 则可以认为是操作系统，其内核是 Linux；RedHat 也是操作系统，其内核同样是 Linux；我们可以看到，尽管 Ubuntu 和 RedHat 是不同的操作系统，但其内核可以是相同的。这就好比它们可以基于同样的底盘打造出不同的车型。而我们熟悉的 Windows 也是操作系统，其内核是 Windows NT 内核。&lt;/p>
&lt;h5 id="总结">&lt;strong>总结&lt;/strong>&lt;/h5>
&lt;p>内核就像本文开头提到的电动底盘，包含了一个汽车的最核心元素；但这样一个底盘并没有什么实际用处，当搭配上外壳以及座椅后才是一辆真正有用的车，这就好比操作系统。值得注意的是，不同的操作系统可以有相同的内核。&lt;/p>
&lt;h1 id="宏内核与微内核">宏内核与微内核&lt;/h1>
&lt;p>原文链接：&lt;a href="https://mp.weixin.qq.com/s/jIuLkapBssGnBn1IoIdWQQ">公众号-码农的荒岛求生，操作系统的实现：什么是宏内核、微内核&lt;/a>&lt;/p>
&lt;h2 id="大一统全部运行在内核态">大一统，全部运行在内核态&lt;/h2>
&lt;p>&lt;strong>最简单的划分就是没有划分&lt;/strong>，我们可以把所有内核代码放在内核态，内核中的任何代码都拥有控制硬件的全部特权，显然这种设计方法非常简单，因为操作系统设计者不用费心去想哪一部分该放在内核态。&lt;/p>
&lt;p>由于全部内核程序都运行在内核态，编译好的内核程序就是一个单独的二进制可执行文件，这时的操作系统运行起来后就是一个大进程，所有内核代码运行在一个单独的地址空间中，这和我们实现的稍微复杂的单进程应用程序类似，这种大一统的设计就是所谓的宏内核，monolithic kernel，个人认为叫“一体化内核”更形象些。&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/egzxwb/1650439475125-4fe94b34-90ba-43d8-8a9b-3c5860730e20.png" alt="">&lt;/p>
&lt;p>这种组织方式和 TCP/IP 协议栈的分层实现有点类似。&lt;/p>
&lt;p>现在内核代码已经组织好了，毕竟内核是为上层应用提供服务的，那么上层应用该怎样调用内核代码呢？这就是系统调用的作用，system call。&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/egzxwb/1650439474086-a1f789d1-05e4-4c7c-9c39-d6274ac2b0aa.png" alt="">&lt;/p>
&lt;p>上层应用程序通过系统调用与内核进行交互。&lt;/p>
&lt;p>由于内核代码唯一同一个地址空间中，因此内核中各部分的交互极为简单，就是普通的函数调用，文件系统中的某块 cache 可以非常容易的被虚拟内存系统共享使用。&lt;/p>
&lt;p>但宏内核也是有缺点的，由于内核代码位于同一个地址空间，代码趋于复杂化，复杂就容易出错，但内核和普通程序不同，一旦内核中某一模块出现 bug 将导致整个内核崩溃，底层的内核崩溃后上层的应用程序就无法继续正常推进，整个系统就下图一样。。crash&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/egzxwb/1650439474129-b3976f1b-3567-4d8a-b82d-2e5fd9e647cd.gif" alt="">&lt;/p>
&lt;p>当然也有人不在乎在这一点，Linus 认为内核中有 bug 正常，&lt;strong>有 bug 就找到它、修复它而不是用某种机制试图忽略它&lt;/strong>，没错，C++中的异常就是试图忽略 bug 的机制，这就是为什么很多公司的规范中禁止使用异常的原因。&lt;/p>
&lt;p>总之，内核崩溃后就必须重启计算机。&lt;/p>
&lt;h4 id="heading">&lt;/h4>
&lt;h2 id="保留核心非必要不留在内核">保留核心，非必要不留在内核&lt;/h2>
&lt;p>为减少内核崩溃的风险，一个简单的办法就是让内核尽量精简，只保留核心部分运行在内核态，其它代码以用户态进程的形式运行，就像这样：&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/egzxwb/1650439474079-a7429422-8348-4fe1-b423-79e30fe7763d.png" alt="">&lt;/p>
&lt;p>运行在用户态的操作系统程序被称为 server，像负责文件操作的 File Server 等，此时用户进程想要使用操作系统提供的服务的话就必须借助进程间通信，inter-process communication，即 IPC，借助内核，消息从一个进程发送到另一个进程然后等待返回。&lt;/p>
&lt;p>这样，内核只需要对上层应用提供一些简单的接口即可，像创建进程、发送消息等，这种实现方式可以让内核尽可能简单，因为大部分内核程序都运行在用户态，且运行在不同的地址空间中，此时设备驱动中的 bug 不会影响到内核，这种操作系统的实现方式就被称为微内核， micro kernel。&lt;/p>
&lt;p>就像宏内核那样，微内核也有自己的缺点，那就是性能。由于宏内核的代码都在同一个地址空间中，因此模块间的交互可以非常简单，简单的函数调用即可，但模块间交互对微内核来说则可能涉及进程间通信，看上图，如果某个应用程序需要请求使用 File Server，这条链路涉及到：&lt;/p>
&lt;pre>&lt;code>请求：应用程序 -&amp;gt; 内核 -&amp;gt; File server
返回：Filer server -&amp;gt; 内核 -&amp;gt; 应用程序
&lt;/code>&lt;/pre>
&lt;p>每一个&amp;quot;-&amp;gt;&amp;ldquo;都涉及上下文切换，而这对宏内核来说则简单很多。&lt;/p>
&lt;h4 id="heading-1">&lt;/h4>
&lt;p>&lt;strong>现实中是什么样子？&lt;/strong>&lt;/p>
&lt;p>现实的操作系统中两种实现方式都很常见，Linux 以及许多 Unix 就是典型的宏内核，而 Mac OS X 以及 Windows NT 则一般认为是微内核，华为的鸿蒙 Harmony OS 则宣传是微内核。&lt;/p></description></item><item><title>Docs: 3.System Call</title><link>https://desistdaydream.github.io/docs/IT%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2.Kernel%E5%86%85%E6%A0%B8/3.System-Call/System-Call/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/IT%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2.Kernel%E5%86%85%E6%A0%B8/3.System-Call/System-Call/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://man7.org/linux/man-pages/man2/syscalls.2.html">Manual(手册)，syscalls(2)&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/System_call">Wiki,System_call&lt;/a>&lt;/li>
&lt;li>&lt;a href="http://arthurchiao.art/blog/system-call-definitive-guide-zh/">http://arthurchiao.art/blog/system-call-definitive-guide-zh/&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>&lt;strong>System Call(系统调用，简称 syscall)&lt;/strong> 是 Application(应用程序) 和 Linux Kernel(内核) 之间的基本接口。是操作内核的唯一入口。其实，所谓 syscall 就是各种编程语言中的 &lt;strong>Function(函数)&lt;/strong> 概念。一个 syscall 也有名称、参数、返回值。syscall 即可以是名词，用来描述一个具体的 syscall；也可以是动词，用来表示某物调用了某个 syscall。当用户进程需要发生系统调用时，CPU 通过软中断切换到内核态开始执行内核系统调用函数。&lt;/p>
&lt;blockquote>
&lt;p>syscall 还有另一种意思，是一种编程方式，比如我们常说的 API，就是 syscall 的一种实现。但是通常意义的 API 不包含权限的转变，而普通程序进行系统调用时，会涉及到权限的转变。&lt;/p>
&lt;/blockquote>
&lt;p>在 &lt;a href="https://man7.org/linux/man-pages/man2/syscalls.2.html#DESCRIPTION">syscalls(2) 手册中的 System call list 章节&lt;/a>可以看到 Linux 可用的完整的 syscall 列表。也就是说所有 Kernel 暴露出来的可供用户调用的 Function。&lt;/p>
&lt;h2 id="用户程序内核和-cpu-特权级别">用户程序、内核和 CPU 特权级别&lt;/h2>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/bbar3l/1616168230254-e3c38b73-8092-41bd-a17d-d3c4768de743.jpeg" alt="">&lt;/p>
&lt;p>用户程序（例如编辑器、终端、ssh daemon 等）需要和 Linux 内核交互，内核代替它们完 成一些它们自身无法完成的操作。&lt;/p>
&lt;p>例如，如果用户程序需要做 IO 操作（open、read、write 等），或者需要修改它的 内存地址（mmpa、sbrk 等），那它必须触发内核替它完成。&lt;/p>
&lt;p>为什么禁止用户程序做这些操作呢？&lt;/p>
&lt;p>因为 x86-64 CPU 有一个特权级别 （privilege levels）的概念。这个概念很复杂，完全可以单独写一篇博客。 出于本文讨论目的，我们将其（大大地）简化为如下：&lt;/p>
&lt;ol>
&lt;li>特权级别是权限控制的一种方式。当前的特权级别决定了允许执行哪些 CPU 指令和操作&lt;/li>
&lt;li>内核运行在最高级别，称为 “Ring 0”；用户程序运行在稍低的一个级别，一般称作 “Ring 3”&lt;/li>
&lt;/ol>
&lt;ul>
&lt;li>内核空间（Ring 0）具有最高权限，可以直接访问所有资源；&lt;/li>
&lt;li>用户空间（Ring 3）只能访问受限资源，不能直接访问内存等硬件设备，必须通过系统调用陷入到内核中，才能访问这些特权资源。&lt;/li>
&lt;/ul>
&lt;p>用户程序要进行特权操作必须触发一次特权级别切换（从 “Ring 3” 到 “Ring 0”）， 由内核（替它）执行。触发特权级别切换有多种方式，我们先从最常见的方式开始：中断。&lt;/p>
&lt;h1 id="interrupts中断">Interrupts(中断)&lt;/h1>
&lt;p>详见：[Interrupts(中断) 概念详解](/docs/IT学习笔记/1.操作系统/2.Kernel(内核)/4.CPU%20 管理/Interrupts(中断).md 管理/Interrupts(中断).md)&lt;/p>
&lt;h1 id="syscall-的方式">syscall 的方式&lt;/h1>
&lt;p>通过 glibc 提供的库函数&lt;/p>
&lt;p>glibc 是 Linux 下使用的开源的标准 C 库，它是 GNU 发布的 libc 库，即运行时库。glibc 为程序员提供丰富的 API，除了例如字符串处理、数学运算等用户态服务之外，最重要的是封装了操作系统提供的系统服务，即系统调用的封装。那么 glibc 提供的系统调用 API 与内核特定的系统调用之间的关系是什么呢？&lt;/p>
&lt;ul>
&lt;li>通常情况，每个特定的系统调用对应了至少一个 glibc 封装的库函数，如系统提供的打开文件系统调用 sys_open 对应的是 glibc 中的 open 函数；&lt;/li>
&lt;li>其次，glibc 一个单独的 API 可能调用多个系统调用，如 glibc 提供的 printf 函数就会调用如 sys_open、sys_mmap、sys_write、sys_close 等等系统调用；&lt;/li>
&lt;li>另外，多个 API 也可能只对应同一个系统调用，如 glibc 下实现的 malloc、calloc、free 等函数用来分配和释放内存，都利用了内核的 sys_brk 的系统调用。&lt;/li>
&lt;/ul>
&lt;p>举例来说，我们通过 glibc 提供的 chmod 函数来改变文件 etc/passwd 的属性为 444&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-c" data-lang="c">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#include&lt;/span> &lt;span style="color:#75715e">&amp;lt;sys/types.h&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#include&lt;/span> &lt;span style="color:#75715e">&amp;lt;sys/stat.h&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#include&lt;/span> &lt;span style="color:#75715e">&amp;lt;errno.h&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#include&lt;/span> &lt;span style="color:#75715e">&amp;lt;stdio.h&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> rc;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> rc &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#a6e22e">chmod&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;/etc/passwd&amp;#34;&lt;/span>, &lt;span style="color:#ae81ff">0444&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (rc &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#f92672">-&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">fprintf&lt;/span>(stderr, &lt;span style="color:#e6db74">&amp;#34;chmod failed, errno = %d&lt;/span>&lt;span style="color:#ae81ff">\n&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>, errno);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">else&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">printf&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;chmod success!&lt;/span>&lt;span style="color:#ae81ff">\n&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>在普通用户下编译运用，输出结果为：&lt;/p>
&lt;pre>&lt;code>chmod failed, errno = 1
&lt;/code>&lt;/pre>
&lt;p>上面系统调用返回的值为-1，说明系统调用失败，错误码为 1，在 /usr/include/asm-generic/errno-base.h 文件中有如下错误代码说明：&lt;/p>
&lt;pre>&lt;code>#define EPERM 1 /* Operation not permitted */
&lt;/code>&lt;/pre>
&lt;p>即无权限进行该操作，我们以普通用户权限是无法修改 /etc/passwd 文件的属性的，结果正确。&lt;/p>
&lt;h2 id="使用指定的-syscallname-直接调用">使用指定的 SyscallName 直接调用&lt;/h2>
&lt;p>使用上面的方法有很多好处，首先你无须知道更多的细节，如 chmod 系统调用号，你只需了解 glibc 提供的 API 的原型；其次，该方法具有更好的移植性，你可以很轻松将该程序移植到其他平台，或者将 glibc 库换成其它库，程序只需做少量改动。&lt;/p>
&lt;p>但有点不足是，如果 glibc 没有封装某个内核提供的系统调用时，我就没办法通过上面的方法来调用该系统调用。如我自己通过编译内核增加了一个系统调用，这时 glibc 不可能有你新增系统调用的封装 API，此时我们可以利用 glibc 提供的 syscall 函数直接调用。该函数定义在 unistd.h 头文件中，函数原型如下：&lt;/p>
&lt;p>long int syscall (long int sysno, &amp;hellip;)&lt;/p>
&lt;ul>
&lt;li>sysno 是系统调用号，每个系统调用都有唯一的系统调用号来标识。在 sys/syscall.h 中有所有可能的系统调用号的宏定义。&lt;/li>
&lt;li>&amp;hellip; 为剩余可变长的参数，为系统调用所带的参数，根据系统调用的不同，可带 0~5 个不等的参数，如果超过特定系统调用能带的参数，多余的参数被忽略。&lt;/li>
&lt;li>返回值 该函数返回值为特定系统调用的返回值，在系统调用成功之后你可以将该返回值转化为特定的类型，如果系统调用失败则返回 -1，错误代码存放在 errno 中。&lt;/li>
&lt;/ul>
&lt;p>还以上面修改 /etc/passwd 文件的属性为例，这次使用 syscall 直接调用：&lt;/p>
&lt;pre>&lt;code>#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;unistd.h&amp;gt;
#include &amp;lt;sys/syscall.h&amp;gt;
#include &amp;lt;errno.h&amp;gt;
int main()
{
int rc;
rc = syscall(SYS_chmod, &amp;quot;/etc/passwd&amp;quot;, 0444);
if (rc == -1)
fprintf(stderr, &amp;quot;chmod failed, errno = %d\n&amp;quot;, errno);
else
printf(&amp;quot;chmod succeess!\n&amp;quot;);
return 0;
}
&lt;/code>&lt;/pre>
&lt;p>在普通用户下编译执行，输出的结果与上例相同。&lt;/p>
&lt;h2 id="通过-syscall-间接调用">通过 syscall() 间接调用&lt;/h2>
&lt;h2 id="通过-int-指令陷入">通过 int 指令陷入&lt;/h2>
&lt;p>如果我们知道系统调用的整个过程的话，应该就能知道用户态程序通过软中断指令 int 0x80 来陷入内核态（在 Intel Pentium II 又引入了 sysenter 指令），参数的传递是通过寄存器，eax 传递的是系统调用号，ebx、ecx、edx、esi 和 edi 来依次传递最多五个参数，当系统调用返回时，返回值存放在 eax 中。&lt;/p>
&lt;p>仍然以上面的修改文件属性为例，将调用系统调用那段写成内联汇编代码：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-c" data-lang="c">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#include&lt;/span> &lt;span style="color:#75715e">&amp;lt;stdio.h&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#include&lt;/span> &lt;span style="color:#75715e">&amp;lt;sys/types.h&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#include&lt;/span> &lt;span style="color:#75715e">&amp;lt;sys/syscall.h&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#include&lt;/span> &lt;span style="color:#75715e">&amp;lt;errno.h&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">long&lt;/span> rc;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">char&lt;/span> &lt;span style="color:#f92672">*&lt;/span>file_name &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#34;/etc/passwd&amp;#34;&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">unsigned&lt;/span> &lt;span style="color:#66d9ef">short&lt;/span> mode &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0444&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">asm&lt;/span>(
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">&amp;#34;int $0x80&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#e6db74">&amp;#34;=a&amp;#34;&lt;/span> (rc)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#e6db74">&amp;#34;0&amp;#34;&lt;/span> (SYS_chmod), &lt;span style="color:#e6db74">&amp;#34;b&amp;#34;&lt;/span> ((&lt;span style="color:#66d9ef">long&lt;/span>)file_name), &lt;span style="color:#e6db74">&amp;#34;c&amp;#34;&lt;/span> ((&lt;span style="color:#66d9ef">long&lt;/span>)mode)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">if&lt;/span> ((&lt;span style="color:#66d9ef">unsigned&lt;/span> &lt;span style="color:#66d9ef">long&lt;/span>)rc &lt;span style="color:#f92672">&amp;gt;=&lt;/span> (&lt;span style="color:#66d9ef">unsigned&lt;/span> &lt;span style="color:#66d9ef">long&lt;/span>)&lt;span style="color:#f92672">-&lt;/span>&lt;span style="color:#ae81ff">132&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> errno &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#f92672">-&lt;/span>rc;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> rc &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#f92672">-&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">if&lt;/span> (rc &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#f92672">-&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">fprintf&lt;/span>(stderr, &lt;span style="color:#e6db74">&amp;#34;chmode failed, errno = %d&lt;/span>&lt;span style="color:#ae81ff">\n&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>, errno);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">else&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">printf&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;success!&lt;/span>&lt;span style="color:#ae81ff">\n&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>如果 eax 寄存器存放的返回值（存放在变量 rc 中）在 -1~-132 之间，就必须要解释为出错码（在/usr/include/asm-generic/errno.h 文件中定义的最大出错码为 132），这时，将错误码写入 errno 中，置系统调用返回值为 -1；否则返回的是 eax 中的值。&lt;/p>
&lt;p>上面程序在 32 位 Linux 下以普通用户权限编译运行结果与前面两个相同！&lt;/p>
&lt;h1 id="系统调用与-api-和函数调用之间的区别">系统调用与 API 和函数调用之间的区别&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://mp.weixin.qq.com/s/2rzzQTuZKSW0O4zM1DlAWQ">公众号，系统调用与函数调用有什么区别？&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://mp.weixin.qq.com/s/q7CDAlwUB7bFstYZ1nOVvA">公众号，系统调用和API有什么区别？&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote></description></item><item><title>Docs: 4.CPU 管理</title><link>https://desistdaydream.github.io/docs/IT%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2.Kernel%E5%86%85%E6%A0%B8/4.CPU-%E7%AE%A1%E7%90%86/CPU-%E7%AE%A1%E7%90%86/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/IT%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2.Kernel%E5%86%85%E6%A0%B8/4.CPU-%E7%AE%A1%E7%90%86/CPU-%E7%AE%A1%E7%90%86/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://time.geekbang.org/column/article/69859">极客时间，Linux 性能优化实战-03 基础篇：经常说的 CPU 上下文切换是什么意思&lt;/a>&lt;/li>
&lt;li>&lt;a href="http://linuxperf.com/?p=209">LinuxPerformance 博客，进程切换：自愿与强制&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>在 Linux 中，CPU 的管理，绝大部分时间都是在进行任务的调度，所以很多时候也称为&lt;strong>调度管理&lt;/strong>。&lt;/p>
&lt;h2 id="cpu-多线程并发并行-概念">&lt;strong>CPU 多线程、并发、并行 概念&lt;/strong>&lt;/h2>
&lt;p>Node：在这里时间片只是一种描述，理解 CPU 的并行与并发概念就好&lt;/p>
&lt;p>1、CPU 时间分片、多线程？
如果线程数不多于 CPU 核心数，会把各个线程都分配一个核心，不需分片，而当线程数多于 CPU 核心数时才会分片。&lt;/p>
&lt;p>2、并发和并行的区别&lt;/p>
&lt;ul>
&lt;li>并发：当有多个线程在操作时,如果系统只有一个 CPU,把 CPU 运行时间划分成若干个时间片,分配给各个线程执行，在一个时间段的线程代码运行时，其它线程处于挂起状态。这种方式我们称之为_ _&lt;strong>Concurrent(并发)&lt;/strong>。并发=间隔发生&lt;/li>
&lt;li>并行：当系统有一个以上 CPU 时,则线程的操作有可能非并发。当一个 CPU 执行一个线程时，另一个 CPU 可以执行另一个线程，两个线程互不抢占 CPU 资源，可以同时进行，这种方式我们称之为 &lt;strong>Parallel(并行)&lt;/strong>。 并行=同时进行&lt;/li>
&lt;/ul>
&lt;p>区别：并行是指两个或者多个事件在同一时刻发生；而并发是指两个或多个事件在同一时间间隔内发生。&lt;/p>
&lt;p>并行是同时做多件事情。&lt;/p>
&lt;p>并发表示同时发生了多件事情，通过时间片切换，哪怕只有单一的核心，也可以实现“同时做多件事情”这个效果。&lt;/p>
&lt;p>根据底层是否有多处理器，并发与并行是可以等效的，这并不是两个互斥的概念。&lt;/p>
&lt;p>举个我们开发中会遇到的例子，我们说资源请求并发数达到了 1 万。这里的意思是有 1 万个请求同时过来了。但是这里很明显不可能真正的同时去处理这 1 万个请求的吧！&lt;/p>
&lt;p>如果这台机器的处理器有 4 个核心，不考虑超线程，那么我们认为同时会有 4 个线程在跑。也就是说，并发访问数是 1 万，而底层真实的并行处理的请求数是 4。如果并发数小一些只有 4 的话，又或者你的机器牛逼有 1 万个核心，那并发在这里和并行一个效果。也就是说，并发可以是虚拟的同时执行，也可以是真的同时执行。而并行的意思是真的同时执行。&lt;/p>
&lt;p>结论是：并行是我们物理时空观下的同时执行，而并发则是操作系统用线程这个模型抽象之后站在线程的视角上看到的“同时”执行。&lt;/p>
&lt;h3 id="time-slice时间片-概念">time slice(时间片) 概念&lt;/h3>
&lt;blockquote>
&lt;p>参考：&lt;a href="https://en.wikipedia.org/wiki/Preemption_(computing)#Time_slice">https://en.wikipedia.org/wiki/Preemption_(computing)#Time_slice&lt;/a>&lt;/p>
&lt;/blockquote>
&lt;p>The period of time for which a process is allowed to run in a preemptive multitasking system is generally called the &lt;em>time slice&lt;/em> or &lt;em>quantum&lt;/em>.&lt;/p>
&lt;p>&lt;strong>time slice(时间片)&lt;/strong> 是一个程序运行在&lt;a href="https://en.wikipedia.org/wiki/Preemption_(computing)">抢占式多任务系统&lt;/a>中的一段时间。也可以称为 quantum(量子)。&lt;/p>
&lt;h2 id="cpu-使用率概念">CPU 使用率概念&lt;/h2>
&lt;p>CPU 不像硬盘、内存，并不具备逻辑上数量、大小、空间之类的概念。只要使用 CPU，就是使用了这个 CPU 的全部，也就无法通过大小之类的概念来衡量一个 CPU，所以我们日常所说的 CPU 的使用率 ，实际上是指的在一段时间范围内，CPU 执行 &lt;strong>Tasks(任务)&lt;/strong> 花费时间的百分比。比如 60 分钟内，一颗 CPU 执行各种任务花费了 6 分钟，则 CPU 在这一小时时间内的使用率为 10%。&lt;/p>
&lt;blockquote>
&lt;p>上文说的 &lt;strong>Tasks(任务)&lt;/strong>，即会指系统中的进程、线程，也代表各种硬件去请求 CPU 执行的各种事情，比如网卡接收到数据，就会告诉 CPU 需要处理(i.e.中断)。&lt;/p>
&lt;/blockquote>
&lt;p>在 Linux 系统中，CPU 的使用率一般可分为 4 大类：&lt;/p>
&lt;ol>
&lt;li>User Time(用户进程运行时间)&lt;/li>
&lt;li>System Time(系统内核运行时间)&lt;/li>
&lt;li>Idle Time(空闲时间)&lt;/li>
&lt;li>Steal Time(被抢占时间)&lt;/li>
&lt;/ol>
&lt;p>除了 Idle Time 外，CPU 在其余时间都处于工作运行状态。
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/srucoz/1616168021555-68fba1de-f5d5-462d-bef6-a78b476521ad.png" alt="">&lt;/p>
&lt;p>通常而言，我们泛指的整体 CPU 使用率为 User Time 和 Systime 占比之和(例如 tsar 中 CPU util)，即：
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/srucoz/1616168021559-394ecaa6-59db-453a-b5b1-c5ab88193f49.png" alt="">&lt;/p>
&lt;p>为了便于定位问题，大多数性能统计工具都将这 4 类时间片进一步扩展成了 8 类，如下图，是在 top 命令的 man 手册中对 CPU 使用率的分类。
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/srucoz/1616168021546-ebe53556-f50b-49f2-8477-c10cf2b8f2f5.png" alt="">&lt;/p>
&lt;ul>
&lt;li>us：用户进程空间中未改变过优先级的进程占用 CPU 百分比&lt;/li>
&lt;li>sy：内核空间占用 CPU 百分比&lt;/li>
&lt;li>ni：用户进程空间内改变过优先级的进程占用 CPU 百分比&lt;/li>
&lt;li>id：空闲时间百分比&lt;/li>
&lt;li>wa：等待 I/O 的时间百分比&lt;/li>
&lt;li>hi：硬中断时间百分比&lt;/li>
&lt;li>si：软中断时间百分比&lt;/li>
&lt;li>st：虚拟化时被其余 VM 窃取时间百分比&lt;/li>
&lt;/ul>
&lt;p>这 8 类分片中，除 wa 和 id 外，其余分片 CPU 都处于工作态。&lt;/p>
&lt;h1 id="调度算法">调度算法&lt;/h1>
&lt;blockquote>
&lt;p>详见：&lt;a href="https://www.yuque.com/go/doc/33222924">CPU 调度算法&lt;/a>&lt;/p>
&lt;/blockquote>
&lt;p>首先明确一个概念：&lt;strong>Task(任务)&lt;/strong>，一个进程从处理到结束就算一个任务，处理网卡收到的数据包也算一个任务。一般来说，CPU 就是在处理一个个的 &lt;strong>Task(任务)&lt;/strong>，并度过其一生。&lt;/p>
&lt;p>在 Linux 内核中，进程和线程都是用 tark_struct 结构体表示的，区别在于线程的 tark_struct 结构体里部分资源是共享了进程已创建的资源，比如内存地址空间、代码段、文件描述符等，所以 Linux 中的线程也被称为轻量级进程，因为线程的 tark_struct 相比进程的 tark_struct 承载的 资源比较少，因此以「轻」得名。&lt;/p>
&lt;p>一般来说，没有创建线程的进程，是只有单个执行流，它被称为是主线程。如果想让进程处理更多的事情，可以创建多个线程分别去处理，但不管怎么样，它们对应到内核里都是 tark_struct。&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/srucoz/1616168021545-596ecf70-ac19-4620-8845-bfe72ef7bdce.jpeg" alt="">&lt;/p>
&lt;p>所以，Linux 内核里的调度器，调度的对象就是 tark_struct，接下来我们就把这个数据结构统称为任务。&lt;/p>
&lt;p>在 Linux 系统中，根据任务的优先级以及响应要求，主要分为两种，其中优先级的数值越小，优先级越高：&lt;/p>
&lt;ul>
&lt;li>实时任务，对系统的响应时间要求很高，也就是要尽可能快的执行实时任务，优先级在 0~99 范围内的就算实时任务；&lt;/li>
&lt;li>普通任务，响应时间没有很高的要求，优先级在 100~139 范围内都是普通任务级别；&lt;/li>
&lt;/ul>
&lt;p>也就是说，在 LInux 内核中，实时任务总是比普通任务的优先级要高。&lt;/p></description></item><item><title>Docs: 5.Memory 管理</title><link>https://desistdaydream.github.io/docs/IT%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2.Kernel%E5%86%85%E6%A0%B8/5.Memory-%E7%AE%A1%E7%90%86/5.Memory-%E7%AE%A1%E7%90%86/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/IT%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2.Kernel%E5%86%85%E6%A0%B8/5.Memory-%E7%AE%A1%E7%90%86/5.Memory-%E7%AE%A1%E7%90%86/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://mp.weixin.qq.com/s/HJB_ATQFNqG82YBCRr97CA">公众号,小林 coding-真棒！ 20 张图揭开内存管理的迷雾，瞬间豁然开朗&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://mp.weixin.qq.com/s/0g3sS63yM2qbBja-blw5Dw">公众号，码农的荒岛求生-神秘！申请内存时底层发生了什么？&lt;/a>(malloc 简介)&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>对任何一台计算机而言，其内存以及其它资源都是有限的。为了让有限的&lt;strong>物理内存&lt;/strong>满足应用程序对内存的大需求量，Linux 采用了称为 **虚拟内存 **的内存管理方式。Linux 将内存划分为容易处理的“内存页”（对于大部分体系结构来说都是 4KB）。Linux 包括了管理可用内存的方式，以及物理和虚拟映射所使用的硬件机制。&lt;/p>
&lt;p>不过内存管理要管理的可不止 4KB 缓冲区。Linux 提供了对 4KB 缓冲区的抽象，例如 slab 分配器。这种内存管理模式使用 4KB 缓冲区为基数，然后从中分配结构，并跟踪内存页使用情况，比如哪些内存页是满的，哪些页面没有完全使用，哪些页面为空。这样就允许该模式根据系统需要来动态调整内存使用。&lt;/p>
&lt;p>为了支持多个用户使用内存，有时会出现可用内存被消耗光的情况。由于这个原因，页面可以移出内存并放入磁盘中。这个过程称为交换，因为页面会被从内存交换到硬盘上。内存管理的源代码可以在 ./linux/mm 中找到。&lt;/p>
&lt;h1 id="虚拟内存">虚拟内存&lt;/h1>
&lt;p>如果你是电子相关专业的，肯定在大学里捣鼓过单片机。&lt;/p>
&lt;p>单片机是没有操作系统的，所以每次写完代码，都需要借助工具把程序烧录进去，这样程序才能跑起来。&lt;/p>
&lt;p>另外，单片机的 CPU 是直接操作内存的「物理地址」。&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/odexpg/1616167919093-db60b152-2475-49e7-8a9d-813007e27b8d.jpeg" alt="">&lt;/p>
&lt;p>在这种情况下，要想在内存中同时运行两个程序是不可能的。如果第一个程序在 2000 的位置写入一个新的值，将会擦掉第二个程序存放在相同位置上的所有内容，所以同时运行两个程序是根本行不通的，这两个程序会立刻崩溃。&lt;/p>
&lt;p>操作系统是如何解决这个问题呢？&lt;/p>
&lt;p>这里关键的问题是这两个程序都引用了绝对物理地址，而这正是我们最需要避免的。&lt;/p>
&lt;p>我们可以把进程所使用的地址「隔离」开来，即让操作系统为每个进程分配独立的一套「虚拟地址」，人人都有，大家自己玩自己的地址就行，互不干涉。但是有个前提每个进程都不能访问物理地址，至于虚拟地址最终怎么落到物理内存里，对进程来说是透明的，操作系统已经把这些都安排的明明白白了。&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/odexpg/1616167919100-24627511-d5f5-4663-9a2c-76b4b3b75664.jpeg" alt="">&lt;/p>
&lt;p>进程的中间层&lt;/p>
&lt;p>操作系统会提供一种机制，将不同进程的虚拟地址和不同内存的物理地址映射起来。&lt;/p>
&lt;p>如果程序要访问虚拟地址的时候，由操作系统转换成不同的物理地址，这样不同的进程运行的时候，写入的是不同的物理地址，这样就不会冲突了。&lt;/p>
&lt;p>于是，这里就引出了两种地址的概念：&lt;/p>
&lt;ul>
&lt;li>我们程序所使用的内存地址叫做虚拟内存地址（Virtual Memory Address）&lt;/li>
&lt;li>实际存在硬件里面的空间地址叫物理内存地址（Physical Memory Address）。&lt;/li>
&lt;/ul>
&lt;p>操作系统引入了虚拟内存，进程持有的虚拟地址会通过 CPU 芯片中的内存管理单元（MMU）的映射关系，来转换变成物理地址，然后再通过物理地址访问内存，如下图所示：&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/odexpg/1616167919111-7b5c26a3-f885-4ae8-bb6b-2bfab9cef4c9.jpeg" alt="">&lt;/p>
&lt;p>操作系统是如何管理虚拟地址与物理地址之间的关系？&lt;/p>
&lt;p>主要有两种方式，分别是内存分段和内存分页，分段是比较早提出的，我们先来看看内存分段。&lt;/p>
&lt;h2 id="内存分段">内存分段&lt;/h2>
&lt;p>程序是由若干个逻辑分段组成的，如可由代码分段、数据分段、栈段、堆段组成。不同的段是有不同的属性的，所以就用分段（Segmentation）的形式把这些段分离出来。&lt;/p>
&lt;p>分段机制下，虚拟地址和物理地址是如何映射的？&lt;/p>
&lt;p>分段机制下的虚拟地址由两部分组成，段选择子和段内偏移量。&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/odexpg/1616167919128-c7568177-0bee-4534-84c6-694d268dd85d.jpeg" alt="">&lt;/p>
&lt;p>内存分段-寻址的方式&lt;/p>
&lt;ul>
&lt;li>段选择子就保存在段寄存器里面。段选择子里面最重要的是段号，用作段表的索引。段表里面保存的是这个段的基地址、段的界限和特权等级等。&lt;/li>
&lt;li>虚拟地址中的段内偏移量应该位于 0 和段界限之间，如果段内偏移量是合法的，就将段基地址加上段内偏移量得到物理内存地址。&lt;/li>
&lt;/ul>
&lt;p>在上面了，知道了虚拟地址是通过段表与物理地址进行映射的，分段机制会把程序的虚拟地址分成 4 个段，每个段在段表中有一个项，在这一项找到段的基地址，再加上偏移量，于是就能找到物理内存中的地址，如下图：&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/odexpg/1616167919115-2be6810a-fa1d-41f1-92f8-b6390209f15a.jpeg" alt="">&lt;/p>
&lt;p>内存分段-虚拟地址与物理地址&lt;/p>
&lt;p>如果要访问段 3 中偏移量 500 的虚拟地址，我们可以计算出物理地址为，段 3 基地址 7000 + 偏移量 500 = 7500。&lt;/p>
&lt;p>分段的办法很好，解决了程序本身不需要关心具体的物理内存地址的问题，但它也有一些不足之处：&lt;/p>
&lt;ul>
&lt;li>第一个就是内存碎片的问题。&lt;/li>
&lt;li>第二个就是内存交换的效率低的问题。&lt;/li>
&lt;/ul>
&lt;p>接下来，说说为什么会有这两个问题。&lt;/p>
&lt;p>我们先来看看，分段为什么会产生内存碎片的问题？&lt;/p>
&lt;p>我们来看看这样一个例子。假设有 1G 的物理内存，用户执行了多个程序，其中：&lt;/p>
&lt;ul>
&lt;li>游戏占用了 512MB 内存&lt;/li>
&lt;li>浏览器占用了 128MB 内存&lt;/li>
&lt;li>音乐占用了 256 MB 内存。&lt;/li>
&lt;/ul>
&lt;p>这个时候，如果我们关闭了浏览器，则空闲内存还有 1024 - 512 - 256 = 256MB。&lt;/p>
&lt;p>如果这个 256MB 不是连续的，被分成了两段 128 MB 内存，这就会导致没有空间再打开一个 200MB 的程序。&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/odexpg/1616167919115-056b2c69-14f1-48d7-8162-7915c80cd090.jpeg" alt="">&lt;/p>
&lt;p>内存碎片的问题&lt;/p>
&lt;p>这里的内存碎片的问题共有两处地方：&lt;/p>
&lt;ul>
&lt;li>外部内存碎片，也就是产生了多个不连续的小物理内存，导致新的程序无法被装载；&lt;/li>
&lt;li>内部内存碎片，程序所有的内存都被装载到了物理内存，但是这个程序有部分的内存可能并不是很常使用，这也会导致内存的浪费；&lt;/li>
&lt;/ul>
&lt;p>针对上面两种内存碎片的问题，解决的方式会有所不同。&lt;/p>
&lt;p>解决外部内存碎片的问题就是内存交换。&lt;/p>
&lt;p>可以把音乐程序占用的那 256MB 内存写到硬盘上，然后再从硬盘上读回来到内存里。不过再读回的时候，我们不能装载回原来的位置，而是紧紧跟着那已经被占用了的 512MB 内存后面。这样就能空缺出连续的 256MB 空间，于是新的 200MB 程序就可以装载进来。&lt;/p>
&lt;p>这个内存交换空间，在 Linux 系统里，也就是我们常看到的 Swap 空间，这块空间是从硬盘划分出来的，用于内存与硬盘的空间交换。&lt;/p>
&lt;p>再来看看，分段为什么会导致内存交换效率低的问题？&lt;/p>
&lt;p>对于多进程的系统来说，用分段的方式，内存碎片是很容易产生的，产生了内存碎片，那不得不重新 Swap 内存区域，这个过程会产生性能瓶颈。&lt;/p>
&lt;p>因为硬盘的访问速度要比内存慢太多了，每一次内存交换，我们都需要把一大段连续的内存数据写到硬盘上。&lt;/p>
&lt;p>所以，如果内存交换的时候，交换的是一个占内存空间很大的程序，这样整个机器都会显得卡顿。&lt;/p>
&lt;p>为了解决内存分段的内存碎片和内存交换效率低的问题，就出现了内存分页。&lt;/p>
&lt;h2 id="内存分页">内存分页&lt;/h2>
&lt;p>分段的好处就是能产生连续的内存空间，但是会出现内存碎片和内存交换的空间太大的问题。&lt;/p>
&lt;p>要解决这些问题，那么就要想出能少出现一些内存碎片的办法。另外，当需要进行内存交换的时候，让需要交换写入或者从磁盘装载的数据更少一点，这样就可以解决问题了。这个办法，也就是内存分页（Paging）。&lt;/p>
&lt;p>分页是把整个虚拟和物理内存空间切成一段段固定尺寸的大小。这样一个连续并且尺寸固定的内存空间，我们叫页（Page）。在 Linux 下，每一页的大小为 4KB。&lt;/p>
&lt;p>虚拟地址与物理地址之间通过页表来映射，如下图：&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/odexpg/1616167919131-ca0a6877-5b8c-49fc-8982-ff9bd4f247a2.jpeg" alt="">&lt;/p>
&lt;p>内存映射&lt;/p>
&lt;p>页表实际上存储在 CPU 的内存管理单元 （MMU） 中，于是 CPU 就可以直接通过 MMU，找出要实际要访问的物理内存地址。&lt;/p>
&lt;p>而当进程访问的虚拟地址在页表中查不到时，系统会产生一个缺页异常，进入系统内核空间分配物理内存、更新进程页表，最后再返回用户空间，恢复进程的运行。&lt;/p>
&lt;p>分页是怎么解决分段的内存碎片、内存交换效率低的问题？&lt;/p>
&lt;p>由于内存空间都是预先划分好的，也就不会像分段会产生间隙非常小的内存，这正是分段会产生内存碎片的原因。而采用了分页，那么释放的内存都是以页为单位释放的，也就不会产生无法给进程使用的小内存。&lt;/p>
&lt;p>如果内存空间不够，操作系统会把其他正在运行的进程中的「最近没被使用」的内存页面给释放掉，也就是暂时写在硬盘上，称为换出（Swap Out）。一旦需要的时候，再加载进来，称为换入（Swap In）。所以，一次性写入磁盘的也只有少数的一个页或者几个页，不会花太多时间，内存交换的效率就相对比较高。&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/odexpg/1616167919157-7b5cfce7-6d02-4a53-8193-49982f06399f.jpeg" alt="">&lt;/p>
&lt;p>换入换出&lt;/p>
&lt;p>更进一步地，分页的方式使得我们在加载程序的时候，不再需要一次性都把程序加载到物理内存中。我们完全可以在进行虚拟内存和物理内存的页之间的映射之后，并不真的把页加载到物理内存里，而是只有在程序运行中，需要用到对应虚拟内存页里面的指令和数据时，再加载到物理内存里面去。&lt;/p>
&lt;p>分页机制下，虚拟地址和物理地址是如何映射的？&lt;/p>
&lt;p>在分页机制下，虚拟地址分为两部分，页号和页内偏移。页号作为页表的索引，页表包含物理页每页所在物理内存的基地址，这个基地址与页内偏移的组合就形成了物理内存地址，见下图。&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/odexpg/1616167919140-c0d128d7-0238-450c-981a-8477221071a4.jpeg" alt="">&lt;/p>
&lt;p>内存分页寻址&lt;/p>
&lt;p>总结一下，对于一个内存地址转换，其实就是这样三个步骤：&lt;/p>
&lt;ul>
&lt;li>把虚拟内存地址，切分成页号和偏移量；&lt;/li>
&lt;li>根据页号，从页表里面，查询对应的物理页号；&lt;/li>
&lt;li>直接拿物理页号，加上前面的偏移量，就得到了物理内存地址。&lt;/li>
&lt;/ul>
&lt;p>下面举个例子，虚拟内存中的页通过页表映射为了物理内存中的页，如下图：&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/odexpg/1616167919128-24ebe4f8-b4c8-407b-8dc5-98da804e5e0c.jpeg" alt="">&lt;/p>
&lt;p>虚拟页与物理页的映射&lt;/p>
&lt;p>这看起来似乎没什么毛病，但是放到实际中操作系统，这种简单的分页是肯定是会有问题的。&lt;/p>
&lt;p>简单的分页有什么缺陷吗？&lt;/p>
&lt;p>有空间上的缺陷。&lt;/p>
&lt;p>因为操作系统是可以同时运行非常多的进程的，那这不就意味着页表会非常的庞大。&lt;/p>
&lt;p>在 32 位的环境下，虚拟地址空间共有 4GB，假设一个页的大小是 4KB（2^12），那么就需要大约 100 万 （2^20） 个页，每个「页表项」需要 4 个字节大小来存储，那么整个 4GB 空间的映射就需要有 4MB 的内存来存储页表。&lt;/p>
&lt;p>这 4MB 大小的页表，看起来也不是很大。但是要知道每个进程都是有自己的虚拟地址空间的，也就说都有自己的页表。&lt;/p>
&lt;p>那么，100 个进程的话，就需要 400MB 的内存来存储页表，这是非常大的内存了，更别说 64 位的环境了。&lt;/p>
&lt;h3 id="多级页表">多级页表&lt;/h3>
&lt;p>要解决上面的问题，就需要采用的是一种叫作多级页表（Multi-Level Page Table）的解决方案。&lt;/p>
&lt;p>在前面我们知道了，对于单页表的实现方式，在 32 位和页大小 4KB 的环境下，一个进程的页表需要装下 100 多万个「页表项」，并且每个页表项是占用 4 字节大小的，于是相当于每个页表需占用 4MB 大小的空间。&lt;/p>
&lt;p>我们把这个 100 多万个「页表项」的单级页表再分页，将页表（一级页表）分为 1024 个页表（二级页表），每个表（二级页表）中包含 1024 个「页表项」，形成二级分页。如下图所示：&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/odexpg/1616167919185-cc42b53c-b247-413b-b8ea-9545012c17a3.jpeg" alt="">&lt;/p>
&lt;p>二级分页&lt;/p>
&lt;p>你可能会问，分了二级表，映射 4GB 地址空间就需要 4KB（一级页表）+ 4MB（二级页表）的内存，这样占用空间不是更大了吗？&lt;/p>
&lt;p>当然如果 4GB 的虚拟地址全部都映射到了物理内上的，二级分页占用空间确实是更大了，但是，我们往往不会为一个进程分配那么多内存。&lt;/p>
&lt;p>其实我们应该换个角度来看问题，还记得计算机组成原理里面无处不在的局部性原理么？&lt;/p>
&lt;p>每个进程都有 4GB 的虚拟地址空间，而显然对于大多数程序来说，其使用到的空间远未达到 4GB，因为会存在部分对应的页表项都是空的，根本没有分配，对于已分配的页表项，如果存在最近一定时间未访问的页表，在物理内存紧张的情况下，操作系统会将页面换出到硬盘，也就是说不会占用物理内存。&lt;/p>
&lt;p>如果使用了二级分页，一级页表就可以覆盖整个 4GB 虚拟地址空间，但如果某个一级页表的页表项没有被用到，也就不需要创建这个页表项对应的二级页表了，即可以在需要时才创建二级页表。做个简单的计算，假设只有 20% 的一级页表项被用到了，那么页表占用的内存空间就只有 4KB（一级页表） + 20% * 4MB（二级页表）= 0.804MB&lt;/p>
&lt;p>，这对比单级页表的 4MB 是不是一个巨大的节约？&lt;/p>
&lt;p>那么为什么不分级的页表就做不到这样节约内存呢？我们从页表的性质来看，保存在内存中的页表承担的职责是将虚拟地址翻译成物理地址。假如虚拟地址在页表中找不到对应的页表项，计算机系统就不能工作了。所以页表一定要覆盖全部虚拟地址空间，不分级的页表就需要有 100 多万个页表项来映射，而二级分页则只需要 1024 个页表项（此时一级页表覆盖到了全部虚拟地址空间，二级页表在需要时创建）。&lt;/p>
&lt;p>我们把二级分页再推广到多级页表，就会发现页表占用的内存空间更少了，这一切都要归功于对局部性原理的充分应用。&lt;/p>
&lt;p>对于 64 位的系统，两级分页肯定不够了，就变成了四级目录，分别是：&lt;/p>
&lt;ul>
&lt;li>全局页目录项 PGD（Page Global Directory）；&lt;/li>
&lt;li>上层页目录项 PUD（Page Upper Directory）；&lt;/li>
&lt;li>中间页目录项 PMD（Page Middle Directory）；&lt;/li>
&lt;li>页表项 PTE（Page Table Entry）；&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/odexpg/1616167919165-47fbe1d8-e5a2-421b-9215-5152f9f6d457.jpeg" alt="">&lt;/p>
&lt;p>四级目录&lt;/p>
&lt;h3 id="tlb">TLB&lt;/h3>
&lt;p>多级页表虽然解决了空间上的问题，但是虚拟地址到物理地址的转换就多了几道转换的工序，这显然就降低了这俩地址转换的速度，也就是带来了时间上的开销。&lt;/p>
&lt;p>程序是有局部性的，即在一段时间内，整个程序的执行仅限于程序中的某一部分。相应地，执行所访问的存储空间也局限于某个内存区域。&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/odexpg/1616167919150-0d7ed5fb-19de-4398-84ca-e77a4c67ab46.jpeg" alt="">&lt;/p>
&lt;p>程序的局部性&lt;/p>
&lt;p>我们就可以利用这一特性，把最常访问的几个页表项存储到访问速度更快的硬件，于是计算机科学家们，就在 CPU 芯片中，加入了一个专门存放程序最常访问的页表项的 Cache，这个 Cache 就是 Translation Lookaside Buffer(转译后备缓冲器，简称 TLB、缓存、快表)等。&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/odexpg/1616167919151-684032a9-151a-4c86-be9a-7535abfc6444.jpeg" alt="">&lt;/p>
&lt;p>地址转换&lt;/p>
&lt;p>在 CPU 芯片里面，封装了内存管理单元（Memory Management Unit）芯片，它用来完成地址转换和 TLB 的访问与交互。&lt;/p>
&lt;p>有了 TLB 后，那么 CPU 在寻址时，会先查 TLB，如果没找到，才会继续查常规的页表。&lt;/p>
&lt;p>TLB 的命中率其实是很高的，因为程序最常访问的页就那么几个。&lt;/p>
&lt;h2 id="段页式内存管理">段页式内存管理&lt;/h2>
&lt;p>内存分段和内存分页并不是对立的，它们是可以组合起来在同一个系统中使用的，那么组合起来后，通常称为段页式内存管理。&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/odexpg/1616167919147-0a7f2b14-9364-4a8e-ba60-c48e8cdf65d0.jpeg" alt="">&lt;/p>
&lt;p>段页式地址空间&lt;/p>
&lt;p>段页式内存管理实现的方式：&lt;/p>
&lt;ul>
&lt;li>先将程序划分为多个有逻辑意义的段，也就是前面提到的分段机制；&lt;/li>
&lt;li>接着再把每个段划分为多个页，也就是对分段划分出来的连续空间，再划分固定大小的页；&lt;/li>
&lt;/ul>
&lt;p>这样，地址结构就由段号、段内页号和页内位移三部分组成。&lt;/p>
&lt;p>用于段页式地址变换的数据结构是每一个程序一张段表，每个段又建立一张页表，段表中的地址是页表的起始地址，而页表中的地址则为某页的物理页号，如图所示：&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/odexpg/1616167919172-07b25f4c-02c8-47f2-a784-d89ba249e13e.jpeg" alt="">&lt;/p>
&lt;p>段页式管理中的段表、页表与内存的关系&lt;/p>
&lt;p>段页式地址变换中要得到物理地址须经过三次内存访问：&lt;/p>
&lt;ul>
&lt;li>第一次访问段表，得到页表起始地址；&lt;/li>
&lt;li>第二次访问页表，得到物理页号；&lt;/li>
&lt;li>第三次将物理页号与页内位移组合，得到物理地址。&lt;/li>
&lt;/ul>
&lt;p>可用软、硬件相结合的方法实现段页式地址变换，这样虽然增加了硬件成本和系统开销，但提高了内存的利用率。&lt;/p>
&lt;h1 id="linux-内存管理">Linux 内存管理&lt;/h1>
&lt;p>那么，Linux 操作系统采用了哪种方式来管理内存呢？&lt;/p>
&lt;p>在回答这个问题前，我们得先看看 Intel 处理器的发展历史。&lt;/p>
&lt;p>早期 Intel 的处理器从 80286 开始使用的是段式内存管理。但是很快发现，光有段式内存管理而没有页式内存管理是不够的，这会使它的 X86 系列会失去市场的竞争力。因此，在不久以后的 80386 中就实现了对页式内存管理。也就是说，80386 除了完成并完善从 80286 开始的段式内存管理的同时还实现了页式内存管理。&lt;/p>
&lt;p>但是这个 80386 的页式内存管理设计时，没有绕开段式内存管理，而是建立在段式内存管理的基础上，这就意味着，页式内存管理的作用是在由段式内存管理所映射而成的的地址上再加上一层地址映射。&lt;/p>
&lt;p>由于此时段式内存管理映射而成的地址不再是“物理地址”了，Intel 就称之为“线性地址”（也称虚拟地址）。于是，段式内存管理先将逻辑地址映射成线性地址，然后再由页式内存管理将线性地址映射成物理地址。&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/odexpg/1616167919178-17fb261b-55fa-44ac-a553-ed8a842e9080.jpeg" alt="">&lt;/p>
&lt;p>Intel X86 逻辑地址解析过程&lt;/p>
&lt;p>这里说明下逻辑地址和线性地址：&lt;/p>
&lt;ul>
&lt;li>程序所使用的地址，通常是没被段式内存管理映射的地址，称为逻辑地址；&lt;/li>
&lt;li>通过段式内存管理映射的地址，称为线性地址，也叫虚拟地址；&lt;/li>
&lt;/ul>
&lt;p>逻辑地址是「段式内存管理」转换前的地址，线性地址则是「页式内存管理」转换前的地址。&lt;/p>
&lt;p>了解完 Intel 处理器的发展历史后，我们再来说说 Linux 采用了什么方式管理内存？&lt;/p>
&lt;p>Linux 内存主要采用的是页式内存管理，但同时也不可避免地涉及了段机制。&lt;/p>
&lt;p>这主要是上面 Intel 处理器发展历史导致的，因为 Intel X86 CPU 一律对程序中使用的地址先进行段式映射，然后才能进行页式映射。既然 CPU 的硬件结构是这样，Linux 内核也只好服从 Intel 的选择。&lt;/p>
&lt;p>但是事实上，Linux 内核所采取的办法是使段式映射的过程实际上不起什么作用。也就是说，“上有政策，下有对策”，若惹不起就躲着走。&lt;/p>
&lt;p>Linux 系统中的每个段都是从 0 地址开始的整个 4GB 虚拟空间（32 位环境下），也就是所有的段的起始地址都是一样的。这意味着，Linux 系统中的代码，包括操作系统本身的代码和应用程序代码，所面对的地址空间都是线性地址空间（虚拟地址），这种做法相当于屏蔽了处理器中的逻辑地址概念，段只被用于访问控制和内存保护。&lt;/p>
&lt;p>我们再来瞧一瞧，Linux 的虚拟地址空间是如何分布的？&lt;/p>
&lt;p>在 Linux 操作系统中，虚拟地址空间的内部又被分为内核空间和用户空间两部分，不同位数的系统，地址空间的范围也不同。比如最常见的 32 位和 64 位系统，如下所示：&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/odexpg/1616167919191-4099f869-9dbe-462c-90f6-ff02cec5a9a6.jpeg" alt="">&lt;/p>
&lt;p>用户空间与内存空间&lt;/p>
&lt;p>通过这里可以看出：&lt;/p>
&lt;ul>
&lt;li>32 位系统的内核空间占用 1G，位于最高处，剩下的 3G 是用户空间；&lt;/li>
&lt;li>64 位系统的内核空间和用户空间都是 128T，分别占据整个内存空间的最高和最低处，剩下的中间部分是未定义的。&lt;/li>
&lt;/ul>
&lt;p>再来说说，内核空间与用户空间的区别：&lt;/p>
&lt;ul>
&lt;li>进程在用户态时，只能访问用户空间内存；&lt;/li>
&lt;li>只有进入内核态后，才可以访问内核空间的内存；&lt;/li>
&lt;/ul>
&lt;p>虽然每个进程都各自有独立的虚拟内存，但是每个虚拟内存中的内核地址，其实关联的都是相同的物理内存。这样，进程切换到内核态后，就可以很方便地访问内核空间内存。&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/odexpg/1616167919223-81c46952-4cf1-4b83-a9a5-2bdd118168b6.jpeg" alt="">&lt;/p>
&lt;p>每个进程的内核空间都是一致的&lt;/p>
&lt;p>接下来，进一步了解虚拟空间的划分情况，用户空间和内核空间划分的方式是不同的，内核空间的分布情况就不多说了。&lt;/p>
&lt;p>我们看看用户空间分布的情况，以 32 位系统为例，我画了一张图来表示它们的关系：&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/odexpg/1616167919192-30c3ec2b-724a-4146-9bc4-3c630ea69e13.jpeg" alt="">&lt;/p>
&lt;p>虚拟内存空间划分&lt;/p>
&lt;p>通过这张图你可以看到，用户空间内存，从低到高分别是 7 种不同的内存段：&lt;/p>
&lt;ul>
&lt;li>程序文件段，包括二进制可执行代码；&lt;/li>
&lt;li>已初始化数据段，包括静态常量；&lt;/li>
&lt;li>未初始化数据段，包括未初始化的静态变量；&lt;/li>
&lt;li>堆段，包括动态分配的内存，从低地址开始向上增长；&lt;/li>
&lt;li>文件映射段，包括动态库、共享内存等，从低地址开始向上增长（跟硬件和内核版本有关）&lt;/li>
&lt;li>栈段，包括局部变量和函数调用的上下文等。栈的大小是固定的，一般是 8 MB。当然系统也提供了参数，以便我们自定义大小；&lt;/li>
&lt;/ul>
&lt;p>在这 7 个内存段中，堆和文件映射段的内存是动态分配的。比如说，使用 C 标准库的 malloc() 或者 mmap() ，就可以分别在堆和文件映射段动态分配内存。&lt;/p>
&lt;h1 id="总结">总结&lt;/h1>
&lt;p>为了在多进程环境下，使得进程之间的内存地址不受影响，相互隔离，于是操作系统就为每个进程独立分配一套的虚拟地址空间，每个程序只关心自己的虚拟地址就可以，实际上大家的虚拟地址都是一样的，但分布到物理地址内存是不一样的。作为程序，也不用关心物理地址的事情。&lt;/p>
&lt;p>每个进程都有自己的虚拟空间，而物理内存只有一个，所以当启用了大量的进程，物理内存必然会很紧张，于是操作系统会通过内存交换技术，把不常使用的内存暂时存放到硬盘（换出），在需要的时候再装载回物理内存（换入）。&lt;/p>
&lt;p>那既然有了虚拟地址空间，那必然要把虚拟地址「映射」到物理地址，这个事情通常由操作系统来维护。&lt;/p>
&lt;p>那么对于虚拟地址与物理地址的映射关系，可以有分段和分页的方式，同时两者结合都是可以的。&lt;/p>
&lt;p>内存分段是根据程序的逻辑角度，分成了栈段、堆段、数据段、代码段等，这样可以分离出不同属性的段，同时是一块连续的空间。但是每个段的大小都不是统一的，这就会导致内存碎片和内存交换效率低的问题。&lt;/p>
&lt;p>于是，就出现了内存分页，把虚拟空间和物理空间分成大小固定的页，如在 Linux 系统中，每一页的大小为 4KB。由于分了页后，就不会产生细小的内存碎片。同时在内存交换的时候，写入硬盘也就一个页或几个页，这就大大提高了内存交换的效率。&lt;/p>
&lt;p>再来，为了解决简单分页产生的页表过大的问题，就有了多级页表，它解决了空间上的问题，但这就会导致 CPU 在寻址的过程中，需要有很多层表参与，加大了时间上的开销。于是根据程序的局部性原理，在 CPU 芯片中加入了 TLB，负责缓存最近常被访问的页表项，大大提高了地址的转换速度。&lt;/p>
&lt;p>Linux 系统主要采用了分页管理，但是由于 Intel 处理器的发展史，Linux 系统无法避免分段管理。于是 Linux 就把所有段的基地址设为 0，也就意味着所有程序的地址空间都是线性地址空间（虚拟地址），相当于屏蔽了 CPU 逻辑地址的概念，所以段只被用于访问控制和内存保护。&lt;/p>
&lt;p>另外，Linxu 系统中虚拟空间分布可分为用户态和内核态两部分，其中用户态的分布：代码段、全局变量、BSS、函数栈、堆内存、映射区。&lt;/p></description></item><item><title>Docs: 5.登录 Linux 与 访问控制</title><link>https://desistdaydream.github.io/docs/IT%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/5.%E7%99%BB%E5%BD%95-Linux-%E4%B8%8E-%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6/5.%E7%99%BB%E5%BD%95-Linux-%E4%B8%8E-%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/IT%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/5.%E7%99%BB%E5%BD%95-Linux-%E4%B8%8E-%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6/5.%E7%99%BB%E5%BD%95-Linux-%E4%B8%8E-%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;/blockquote>
&lt;p>想要登录 Linux，必须通过 [&lt;strong>Terminal(终端)&lt;/strong>](/docs/IT学习笔记/1.操作系统/4.Terminal%20 与%20Shell/4.Terminal%20 与%20Shell.md 与 Shell.md)，我们才可以与操作系统进行交互。&lt;/p>
&lt;p>本质上，想要登录 Linux，必然需要调用某些程序(比如 Shell)，以便分配一个终端。通常，我们有多种方式可供选择：&lt;/p>
&lt;ul>
&lt;li>本地命令行登录&lt;/li>
&lt;li>远程命令行登录&lt;/li>
&lt;li>图形界面登录&lt;/li>
&lt;/ul>
&lt;p>Linux 操作系统是一个多用户操作系统，所以除了 &lt;strong>Terminal(终端)&lt;/strong> 以外，还需 &lt;strong>Account(账户)&lt;/strong> 才可以登录上去，Linux 操作系统允许多个用户访问安装在一台机器上的单个系统。每个 &lt;strong>User(用户)&lt;/strong> 都在自己的 &lt;strong>Account(账户)&lt;/strong> 下操作。因此，Account Manager 代表了 Linux 系统管理的核心要素。&lt;/p>
&lt;h1 id="登录-linux">登录 Linux&lt;/h1>
&lt;p>我们可以通过多种方式登录 Linux&lt;/p>
&lt;ul>
&lt;li>本地登录&lt;/li>
&lt;li>远程登录&lt;/li>
&lt;/ul>
&lt;h2 id="通过本地-tty-登陆-linux-系统">通过本地 TTY 登陆 Linux 系统&lt;/h2>
&lt;p>登录 Linux 最基本的方式，就是使用 &lt;code>login&lt;/code> 程序。&lt;/p>
&lt;h3 id="login-程序">login 程序&lt;/h3>
&lt;p>由于历史原因，&lt;code>login&lt;/code> 可能被包含在两个包中：&lt;/p>
&lt;ul>
&lt;li>util-linux&lt;/li>
&lt;li>shadow-utils&lt;/li>
&lt;/ul>
&lt;h4 id="login-的登录行为">login 的登录行为&lt;/h4>
&lt;p>当我们刚刚安装完操作系统，systemd-logind.service 服务会让我们看到这样的画面&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/gwpmr6/1634785246289-3a353c73-2899-4b6c-8341-ffc4a02008ef.png" alt="image.png">&lt;/p>
&lt;p>想要在服务器本地登录系统，则需要进行认证，在输入用户名之后，实际上是调用了 &lt;code>login&lt;/code> 这个二进制程序，看到：&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/gwpmr6/1634785206973-885fa7fb-3dfb-4fb1-80c8-1c56cb903974.png" alt="image.png">&lt;/p>
&lt;p>此时我们通过远程方式(如果可以的话)登录服务器，查看进程，将会看到名为 login 的进程&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>~&lt;span style="color:#f92672">]&lt;/span>$ pgrep login -alf
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">600&lt;/span> /lib/systemd/systemd-logind
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">1476&lt;/span> /bin/login -p --
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>当我们输入完密码，经过 &lt;a href="https://desistdaydream.github.io/docs/IT%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/5.%E7%99%BB%E5%BD%95%20Linux%20%E4%B8%8E%20%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6/Access%20Control(%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6)/Access%20Control(%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6).md">Access Control(访问控制)&lt;/a> 相关程序的认证之后，login 工具会为我们分配一个 ttyX 的终端设备，然后我们就可以通过 tty 所关联的 Shell(通常是 bash)，与系统进行交互&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/gwpmr6/1634785329507-0cb1fcec-8c6e-4fd0-a99f-005a2b19807e.png" alt="image.png">&lt;/p>
&lt;h4 id="login-关联文件与配置">login 关联文件与配置&lt;/h4>
&lt;p>&lt;strong>/etc/login.defs&lt;/strong> # shadow 与 password 套件的配置文件。
&lt;strong>/etc/pam.d/login&lt;/strong> #&lt;/p>
&lt;h2 id="通过远程的方式来登陆-linux-系统">通过远程的方式来登陆 Linux 系统&lt;/h2>
&lt;h3 id="ssh-程序">ssh 程序&lt;/h3>
&lt;p>详见：&lt;a href="https://desistdaydream.github.io/docs/IT%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/5.%E7%99%BB%E5%BD%95%20Linux%20%E4%B8%8E%20%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6/Secure%20Shell(SSH)%20%E5%AE%89%E5%85%A8%E5%A4%96%E5%A3%B3%E5%8D%8F%E8%AE%AE/Secure%20Shell(SSH)%20%E5%AE%89%E5%85%A8%E5%A4%96%E5%A3%B3%E5%8D%8F%E8%AE%AE.md">Secure Shell(SSH) 安全外壳协议&lt;/a>&lt;/p>
&lt;pre>&lt;code>root 981 1 0 Jul08 ? Ss 0:00 /usr/sbin/sshd -D
root 1947 981 0 09:05 ? Ss 0:00 \_ sshd: root@pts/0
root 1949 1947 1 09:05 pts/0 Ss 0:00 \_ -bash
root 1970 1949 0 09:05 pts/0 R+ 0:00 \_ ps -ef f
&lt;/code>&lt;/pre>
&lt;p>OpenSSH 会为用户分配一个 Pseudoterminal(伪终端，即 pts) 以便用户可以与操作系统进行交互。&lt;/p>
&lt;h1 id="登录提示信息">登录提示信息&lt;/h1>
&lt;p>通过 &lt;code>touch ~/.hushlogin&lt;/code> 命令可以为当前用户禁用欢迎信息。&lt;/p>
&lt;h2 id="motd">MOTD&lt;/h2>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Motd_(Unix)">Wiki:MOTD&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://man7.org/linux/man-pages/man5/motd.5.html">Manual(手册)，MOTD&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>&lt;strong>Message of the day(每日消息，简称 MOTD)&lt;/strong> 是一种比向所有用户发送一个邮件更有效的发送共同的信息的方式&lt;/p>
&lt;h4 id="motd-关联文件">MOTD 关联文件&lt;/h4>
&lt;p>&lt;strong>/etc/default/motd-news&lt;/strong> # 动态 MOTD 新闻信息配置，新闻信息主要是互联网相关的
&lt;strong>/etc/update-motd.d/*&lt;/strong> # MOTD 执行脚本保存路径
&lt;strong>~/.hushlogin&lt;/strong> # 该文件存在时，将为当前用户禁用 MOTD 消息
&lt;strong>/etc/pam.d/sshd&lt;/strong> # PAM 模块中可以为 sshd 配置 MOTD。&lt;/p>
&lt;h1 id="访问控制">访问控制&lt;/h1>
&lt;p>Linux 的登录与访问控制是相辅相成的，一个用户想要登录 Linux，通常来说都需要经过访问控制系统对其所使用的账户进行认证，只有认证通过后，才可以正常登录。&lt;/p>
&lt;p>一个正常的 Linux 发行版操作系统，通常都提供了多种方式&lt;/p>
&lt;ul>
&lt;li>密码&lt;/li>
&lt;li>会话&lt;/li>
&lt;li>账户锁定&lt;/li>
&lt;li>等等&amp;hellip;&amp;hellip;&lt;/li>
&lt;/ul>
&lt;h2 id="account-manager账户管理">Account Manager(账户管理)&lt;/h2>
&lt;p>详见 &lt;a href="https://desistdaydream.github.io/docs/IT%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/5.%E7%99%BB%E5%BD%95%20Linux%20%E4%B8%8E%20%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6/Account%20Manager(%E8%B4%A6%E6%88%B7%E7%AE%A1%E7%90%86)/Account%20Manager(%E8%B4%A6%E6%88%B7%E7%AE%A1%E7%90%86).md">Account Manager(账户管理)&lt;/a>&lt;/p>
&lt;h1 id="多窗口操作">多窗口操作&lt;/h1>
&lt;p>登录服务器后，我们可以重复登录，以便在多个窗口执行不同的操作以观察服务器状态或排查问题。&lt;/p>
&lt;p>但是当我们在机房通过显示器连接到服务器时，是不像使用 ssh 命令一样方便的，但是依然可以实现多窗口操作。&lt;/p>
&lt;p>使用 &lt;code>Ctrl + Alt + F&amp;lt;X&amp;gt;&lt;/code> 快捷键，即可打开其他窗口，&lt;code>Ctrl + Alt + F2&lt;/code> 切换到第二个窗口，F1 可以切回第一个默认窗口。&lt;/p></description></item><item><title>Docs: 6.File System 管理</title><link>https://desistdaydream.github.io/docs/IT%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2.Kernel%E5%86%85%E6%A0%B8/6.File_System_%E7%AE%A1%E7%90%86/6.File_System_%E7%AE%A1%E7%90%86/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/IT%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2.Kernel%E5%86%85%E6%A0%B8/6.File_System_%E7%AE%A1%E7%90%86/6.File_System_%E7%AE%A1%E7%90%86/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Category:Computer_file_systems">Wiki-Category,Computer file systemd&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://time.geekbang.org/column/article/76876">Linux 性能优化实践-文件系统&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://mp.weixin.qq.com/s/qJdoXTv_XS_4ts9YuzMNIw">公众号，小林 coding-一口气搞懂「文件系统」，就靠这 25 张图了&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/op2fw9/1616167805545-2b948cff-7e56-4eb8-8c12-3851fd6c2e36.png" alt="">&lt;/p>
&lt;blockquote>
&lt;p>图片来源：&lt;a href="https://www.thomas-krenn.com/en/wiki/Linux_Storage_Stack_Diagram">https://www.thomas-krenn.com/en/wiki/Linux_Storage_Stack_Diagram&lt;/a>
从上面的结构可以看到，文件系统的作用就是用来接收用户的操作，并将数据保存到物理硬盘的。可以想见，如果没有文件系统帮助用户操作，那么人们又怎么能将数据保存到存储设备上呢~&lt;/p>
&lt;/blockquote>
&lt;p>&lt;strong>File System(文件系统，简称 FS)&lt;/strong> 是一种对存储设备上的数据，进行组织管理的机制。组织方式的不同，就会形成不同的文件系统。&lt;/p>
&lt;p>如果没有文件系统，放置在存储介质中的数据将是一个庞大的数据主体，无法分辨一个数据在哪里停止以及下一个数据在哪里开始。通过将数据分成多个部分并给每个部分命名，可以轻松地隔离和识别数据。每组数据称为 &lt;strong>File(文件)&lt;/strong>。所以，用于管理这些文件及其名称的&lt;strong>结构和逻辑规则&lt;/strong>，称为 &lt;strong>File System(文件系统)&lt;/strong>。&lt;/p>
&lt;h2 id="什么是-file文件">什么是 File(文件)&lt;/h2>
&lt;p>详见《&lt;a href="https://desistdaydream.github.io/docs/IT%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2.Kernel(%E5%86%85%E6%A0%B8)/6.File_System_%E7%AE%A1%E7%90%86/%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86/%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86.md">文件管理&lt;/a>》章节&lt;/p>
&lt;h1 id="文件组织结构">文件组织结构&lt;/h1>
&lt;blockquote>
&lt;p>文件管理详解见&lt;a href="https://desistdaydream.github.io/docs/IT%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2.Kernel(%E5%86%85%E6%A0%B8)/6.File_System_%E7%AE%A1%E7%90%86/%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86/%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86.md">单独章节&lt;/a>&lt;/p>
&lt;/blockquote>
&lt;p>为了方便管理，Linux 的文件系统为每个文件都分配了两个数据结构。&lt;/p>
&lt;ul>
&lt;li>&lt;strong>index node(索引节点，简称 inode)&lt;/strong> # 记录文件的元数据。inode 编号、文件大小、访问权限、修改日期、数据的位置等。
&lt;ul>
&lt;li>inode 和文件一一对应，它跟文件内容一样，都会被持久化到存储的磁盘中。所以** inode 同样占用磁盘空间**。&lt;/li>
&lt;li>inode 包含文件的元数据，具体来说有以下内容：
&lt;ul>
&lt;li>文件的字节数&lt;/li>
&lt;li>文件拥有者的 User ID&lt;/li>
&lt;li>文件的 Group ID&lt;/li>
&lt;li>文件的读、写、执行权限&lt;/li>
&lt;li>文件的时间戳，共有三个：ctime 指 inode 上一次变动的时间，mtime 指文件内容上一次变动的时间，atime 指文件上一次打开的时间。&lt;/li>
&lt;li>链接数，即有多少文件名指向这个 inode&lt;/li>
&lt;li>文件数据 block 的位置&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>directory entry(目录项，简称 dentry)&lt;/strong> # 记录文件的名字、inode 指针、与其他目录项的关联关系。
&lt;ul>
&lt;li>多个关联的目录项，就构成了文件系统的目录结构(&lt;strong>一个层次化的树形结构&lt;/strong>)。不过，不同于 inode，目录项是由内核维护的一个内存数据结构，所以通常也被叫做 &lt;strong>dentries(目录项缓存)。&lt;/strong>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>这个层次化的树形结构就像下图一样：
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/op2fw9/1617088781476-3d7a9ccc-e8df-4680-acc5-26f4f82aa8b5.png" alt="image.png">
&lt;strong>注意：目录项缓存记录在 slab 中，当我们使用 find 命令时，slab 中的 dentry 缓存就会增大；打开文件过多，slab 中的 dentry 缓存也会增大。&lt;/strong>&lt;/p>
&lt;p>inode 是每个文件的唯一标志，而 dentry 维护的正是文件系统的树状结构。dentry 与 inode 的关系是多对一(可以简单理解为一个文件可以有多个别名)&lt;/p>
&lt;p>下面用一个形象点的白话来描述这些概念，假如现在系统中有如下目录结构&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>~&lt;span style="color:#f92672">]&lt;/span>&lt;span style="color:#75715e"># tree --inodes&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>.
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>├── &lt;span style="color:#f92672">[&lt;/span> 2218&lt;span style="color:#f92672">]&lt;/span> dir_1 &lt;span style="color:#75715e"># 这是目录类型的文件&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>│ ├── &lt;span style="color:#f92672">[&lt;/span> 2235&lt;span style="color:#f92672">]&lt;/span> file_1 &lt;span style="color:#75715e"># 这是普通类型的文件&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>│ └── &lt;span style="color:#f92672">[&lt;/span> 2236&lt;span style="color:#f92672">]&lt;/span> file_2
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>├── &lt;span style="color:#f92672">[&lt;/span>269167463&lt;span style="color:#f92672">]&lt;/span> dir_2
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>│ └── &lt;span style="color:#f92672">[&lt;/span>269167464&lt;span style="color:#f92672">]&lt;/span> file_3
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>└── &lt;span style="color:#f92672">[&lt;/span>537384536&lt;span style="color:#f92672">]&lt;/span> dir_3
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ├── &lt;span style="color:#f92672">[&lt;/span> 2235&lt;span style="color:#f92672">]&lt;/span> fie_1_ln
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> └── &lt;span style="color:#f92672">[&lt;/span>537384537&lt;span style="color:#f92672">]&lt;/span> file_4
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">3&lt;/span> directories, &lt;span style="color:#ae81ff">5&lt;/span> files
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>可以这么描述上述看到的内容：dir_1、file_1、dir_2 这些名称都是 dentry 中的文件名，&lt;code>[]&lt;/code> 中的数字是 inode 号，每个 dentry 都会与 inode 关联。其中 file_1 和 file_1_ln 的 inode 相同，但是 dentry 不同，这就对应了 dentry 与 inode 是多对一的关系。而哪些文件在哪个目录中，则是由每个文件的 dentry 中的关联关系来决定。比如 dir_1 目录中，包含了 file_1 和 file_2 文件。&lt;/p>
&lt;blockquote>
&lt;p>索引节点和目录项记录了文件的元数据，以及文件间的目录关系，那么具体来说，文件数据到底是怎么存储的呢？是不是直接写到磁盘中就好了呢？
实际上，磁盘读写的最小单位是扇区，然而扇区只有 512B 大小，如果每次都读写这么小的单位，效率一定很低。所以，文件系统又把连续的扇区组成了逻辑块，然后每次都以逻辑块为最小单元，来管理数据。常见的逻辑块大小为 4KB，也就是由连续的 8 个扇区组成。&lt;/p>
&lt;/blockquote>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/op2fw9/1616167805558-180916c2-cc19-40a0-b8f4-3ff805929883.png" alt="">&lt;/p>
&lt;p>注意：&lt;/p>
&lt;ul>
&lt;li>dentry 本身只是一个存储在内存中的缓存，而 inode 则是存储在磁盘中的数据。由于内存的 Buffer 和 Cache 原理，所以 inode 也会缓存到内存中，以便加速文件的访问。&lt;/li>
&lt;li>磁盘在执行文件系统格式化时，会被分成三个存储区域，超级快、索引节点区、数据区块
&lt;ul>
&lt;li>超级块 # 存储整个文件系统的状态&lt;/li>
&lt;li>索引节点区 # 存储 inode&lt;/li>
&lt;li>数据区块 # 存储文件数据&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>我们不可能把超级块和索引节点区全部加载到内存，这样内存肯定撑不住，所以只有当需要使用的时候，才将其加载进内存，它们加载进内存的时机是不同的：
&lt;ul>
&lt;li>超级块 # 当文件系统挂载时进入内存；&lt;/li>
&lt;li>索引节点区 # 当文件被访问时进入内存&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>dentry、inode、逻辑块以及超级块构成了 Linux 文件系统的四大基本要素。&lt;/p>
&lt;h2 id="小结">小结&lt;/h2>
&lt;p>通过上面的描述，文件在文件系统中，也就可以归纳为两个部分&lt;/p>
&lt;ul>
&lt;li>指针部分 # 指针位于文件系统的元数据中，在将数据删除后，这个指针就从元数据中清除了(元数据其实就是上文的 inode 与 dentry)。&lt;/li>
&lt;li>数据部分 # 文件的具体内容，存储在磁盘中。&lt;/li>
&lt;/ul>
&lt;p>平时我们在删除数据时，其实仅仅从元数据中删除了数据对应的指针。当指针被删除时，其原本占用的空间就可以被覆盖并写入新内容。&lt;/p>
&lt;h2 id="常见问题">常见问题&lt;/h2>
&lt;ul>
&lt;li>这也是为什么我们可以恢复数据的原因，只要旧数据还没被覆盖，就依然可以获取到。&lt;/li>
&lt;li>有时候在删除文件时，会发现并没有释放空间，也是同样的道理，当某个进程持续写入内容时，如果强制删除了文件，由于进程锁定文件对应的指针部分并不会从元数据中清除，而由于指针并未删除，系统内核就默认文件并未删除，因此查询文件系统空间时，显示空间并未释放。可以通过 lsof 命令筛选 deleted 查找这些有问题的文件。&lt;/li>
&lt;/ul>
&lt;h1 id="virtual-file-system虚拟文件系统">Virtual File System(虚拟文件系统)&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Virtual_file_system">Wiki,，Virtual file system&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://zhuanlan.zhihu.com/p/69289429">知乎&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://time.geekbang.org/column/article/76876">极客-Linux 性能优化实践&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>&lt;strong>Virtual File System(虚拟文件系统，简称 VFS)&lt;/strong> 是 Linux 为了支持多种多样的文件系统，在用户空间进程和文件系统中间，引入的一个抽象层。VFS 的目的是运行客户端应用程序以统一的方式访问不同类型的文件系统。VFS &lt;strong>定义了&lt;/strong>一组所有文件系统都支持的&lt;strong>数据结构和标准 API&lt;/strong>。这样，用户进程和内核中的其他子系统，只需要跟 VFS 提供的统一接口进行交互即可，而不需要关系底层各种文件系统的实现细节。&lt;/p>
&lt;blockquote>
&lt;p>比如不同文件系统的调用函数不一样，如果没有 VFS ，那么在使用的时候，就需要为特定的文件系统，编写不同的调用方式，非常繁琐复杂。&lt;/p>
&lt;p>比如 VFS 可以用来弥合 Windows、MacOS、Unix 文件系统中的差异，以便应用程序可以访问那些类型的本地文件系统上的文件，而不必知道它们正在访问哪种文件系统。&lt;/p>
&lt;/blockquote>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/op2fw9/1616167805621-09dbf293-4f9a-4892-8e30-8d33f32031c4.png" alt="">&lt;/p>
&lt;p>举个例子，Linux 用户程序可以通过&lt;code>read()&lt;/code> 来读取&lt;code>ext4&lt;/code>、&lt;code>NFS&lt;/code>、&lt;code>XFS&lt;/code>等文件系统的文件，也可以读取存储在&lt;code>SSD&lt;/code>、&lt;code>HDD&lt;/code>等不同存储介质的文件，无须考虑不同文件系统或者不同存储介质的差异。&lt;/p>
&lt;p>通过 VFS 系统，Linux 提供了通用的系统调用，可以跨越不同文件系统和介质之间执行，极大简化了用户访问不同文件系统的过程。另一方面，新的文件系统、新类型的存储介质，可以无须编译的情况下，动态加载到 Linux 中。&lt;/p>
&lt;p>&amp;ldquo;一切皆文件&amp;quot;是 Linux 的基本哲学之一，不仅是普通的文件，包括目录、字符设备、块设备、套接字等，都可以以文件的方式被对待。实现这一行为的基础，正是 Linux 的虚拟文件系统机制。&lt;/p>
&lt;p>VFS 之所以能够衔接各种各样的文件系统，是因为它抽象了一个通用的文件系统模型，定义了通用文件系统都支持的、概念上的接口。新的文件系统只要支持并实现这些接口，并注册到 Linux 内核中，即可安装和使用。&lt;/p>
&lt;p>再举个例子，比如 Linux 写一个文件：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>int ret &lt;span style="color:#f92672">=&lt;/span> write&lt;span style="color:#f92672">(&lt;/span>fd, buf, len&lt;span style="color:#f92672">)&lt;/span>;
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>调用了 &lt;code>write()&lt;/code> 系统调用，它的过程简要如下：&lt;/p>
&lt;ul>
&lt;li>首先，勾起 VFS 通用系统调用&lt;code>sys_write()&lt;/code>处理。&lt;/li>
&lt;li>接着，&lt;code>sys_write()&lt;/code> 根据&lt;code>fd&lt;/code>找到所在的文件系统提供的写操作函数，比如 &lt;code>op_write()&lt;/code>。&lt;/li>
&lt;li>最后，调用 &lt;code>op_write()&lt;/code> 实际的把数据写入到文件中。&lt;/li>
&lt;/ul>
&lt;p>操作示意图如下：
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/op2fw9/1616167805551-1b23e389-6142-4e11-8ef1-b1b1c1722cbe.jpeg" alt="">&lt;/p>
&lt;h1 id="文件系统类型">文件系统类型&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/File_system#Types_of_file_systems">Wiki，File system-Types_of_file_systems&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>可以通过 &lt;strong>/proc/filesystems&lt;/strong> 文件查看当前内核所支持的文件系统类型&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>~&lt;span style="color:#f92672">]&lt;/span>&lt;span style="color:#75715e"># cat /proc/filesystems&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>nodev sysfs
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>...
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>nodev proc
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>...
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>nodev cgroup2
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>nodev tmpfs
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>nodev devtmpfs
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>nodev configfs
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>...
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> xfs
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>...
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ext4
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>...
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ul>
&lt;li>第一列说明文件系统是否需要挂载在一个块设备上
&lt;ul>
&lt;li>nodev 表明本行的文件系统类型不需要挂接在块设备上。凡是没有 nodev 的类型，通常来说都是磁盘文件系统。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>第二列是内核支持的文件系统类型。&lt;/li>
&lt;/ul>
&lt;p>当系统中安装了某个文件系统的驱动，则该文件内容也会有增加，比如我安装了 nfs-utils 包，则该文件还会增加 nfs 行。&lt;/p>
&lt;h2 id="按照存储位置分类">按照存储位置分类&lt;/h2>
&lt;ul>
&lt;li>&lt;strong>Disk file systems(磁盘文件系统)&lt;/strong>
&lt;ul>
&lt;li>基于磁盘的文件系统，也就是把数据直接存储到计算机本地挂载磁盘中。常见的 &lt;strong>ext4、xfs&lt;/strong> 等，都是这类文件系统&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>Network File Systems(网络文件系统)&lt;/strong>
&lt;ul>
&lt;li>网络文件系统是充当远程文件访问协议的客户端的文件系统，提供对服务器上文件的访问。 使用本地接口的程序可以透明地创建，管理和访问远程网络连接计算机中的分层目录和文件。 网络文件系统的示例包括 NFS，AFS，SMB 协议的客户端，以及 FTP 和 WebDAV 的类似于文件系统的客户端。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>Distributed File System(分布式文件系统)&lt;/strong> # 使用网络协议的分布式文件系统也属于网络文件系统的一种。&lt;/li>
&lt;li>&lt;strong>Special-purpose File Systems(特殊目的文件系统)&lt;/strong> # 特殊的文件系统将操作系统的非文件元素显示为文件，以便可以使用文件系统 API 对其进行操作。 这种文件系统一般都是基于内存的，不需要任何磁盘为其分配存储空间，但会占用内存。
&lt;ul>
&lt;li>&lt;strong>device file system(设备文件系统)&lt;/strong> # 简称 devfs，设备文件系统将 I/O 设备和伪设备表示为文件，称为设备文件。 默认挂载到&lt;code>/dev&lt;/code>目录下。&lt;/li>
&lt;li>&lt;strong>Proc File System(进程文件系统)&lt;/strong> # 简称_ _procfs，将进程以及 Linux 上的其他操作系统结构映射到文件空间。默认挂载到&lt;code>/proc&lt;/code>目录下。&lt;/li>
&lt;li>&lt;strong>configfs&lt;/strong> 和 &lt;strong>sysfs&lt;/strong> 提供了可用于向内核查询信息并在内核中配置实体的文件。&lt;/li>
&lt;li>等等&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h1 id="文件系统的使用">文件系统的使用&lt;/h1>
&lt;blockquote>
&lt;p>和 DOS 等操作系统不同，Linux 操作系统中文件系统并不是由驱动器号或驱动器名称（如 A: 或 C: 等）来标识的。Linux 操作系统将独立的文件系统组合成了一个层次化的树形结构，并且由一个单独的实体代表这一文件系统。&lt;/p>
&lt;/blockquote>
&lt;p>Linux 将新的文件系统通过 &lt;a href="https://desistdaydream.github.io/docs/IT%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2.Kernel(%E5%86%85%E6%A0%B8)/6.File_System_%E7%AE%A1%E7%90%86/Mount(%E6%8C%82%E8%BD%BD).md">&lt;strong>Mount(挂载)&lt;/strong>&lt;/a> 操作将其挂载到某个目录上，从而让不同的文件系统结合成为一个整体。&lt;/p>
&lt;p>这些文件系统，要先挂载到 VFS 目录树中的某个子目录（称为挂载点），然后才能访问其中的文件。拿第一类，也就是基于磁盘的文件系统为例，在安装系统时，要先挂载一个根目录&lt;code>/&lt;/code>，在根目录下再把其他文件系统（比如其他的磁盘分区、/proc 文件系统、/sys 文件系统、NFS 等）挂载进来。&lt;/p>
&lt;h1 id="文件系统-io">文件系统 I/O&lt;/h1>
&lt;p>把文件系统挂载到挂载点后，就可以通过挂载点访问它管理的文件了。 VFS 提供了一组标准的文件访问接口。这些接口以系统调用的方式，提供给应用程序使用。&lt;/p>
&lt;p>就比如 cat 命令，首先调用 &lt;code>openat()&lt;/code> 打开一个文件，然后调用 &lt;code>read()&lt;/code> 读取文件内容，最后调用 &lt;code>write()&lt;/code> 将内容输出到控制台的标准输出中&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>~&lt;span style="color:#f92672">]&lt;/span>&lt;span style="color:#75715e"># strace -e openat,read,write cat /root/test&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>......
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>openat&lt;span style="color:#f92672">(&lt;/span>AT_FDCWD, &lt;span style="color:#e6db74">&amp;#34;/root/test&amp;#34;&lt;/span>, O_RDONLY&lt;span style="color:#f92672">)&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">3&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>read&lt;span style="color:#f92672">(&lt;/span>3, &lt;span style="color:#e6db74">&amp;#34;Test I/O for File System&amp;#34;&lt;/span>, 131072&lt;span style="color:#f92672">)&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">24&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>write&lt;span style="color:#f92672">(&lt;/span>1, &lt;span style="color:#e6db74">&amp;#34;Test I/O for File System&amp;#34;&lt;/span>, 24Test I/O &lt;span style="color:#66d9ef">for&lt;/span> File System&lt;span style="color:#f92672">)&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">24&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>......
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># 代码中的方法如下：open() 与 openat() 这两个调用效果一样。&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>int open&lt;span style="color:#f92672">(&lt;/span>const char *pathname, int flags, mode_t mode&lt;span style="color:#f92672">)&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>ssize_t read&lt;span style="color:#f92672">(&lt;/span>int fd, void *buf, size_t count&lt;span style="color:#f92672">)&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>ssize_t write&lt;span style="color:#f92672">(&lt;/span>int fd, const void *buf, size_t count&lt;span style="color:#f92672">)&lt;/span>;
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>文件读写方式的各种差异，导致 I/O 的分类多种多样。最常见的有，缓冲与非缓冲 I/O、直接与非直接 I/O、阻塞与非阻塞 I/O、同步与异步 I/O 等。&lt;/p>
&lt;h2 id="缓冲与非缓冲-io">缓冲与非缓冲 I/O&lt;/h2>
&lt;p>根据是否利用标准库缓存&lt;/p>
&lt;ul>
&lt;li>缓冲 I/O # 利用标准库缓存来加速文件的访问，而标准库内部再通过系统调用访问文件&lt;/li>
&lt;li>非缓冲 I/O # 直接通过系统调用来访问文件，不再经过标准库缓存。&lt;/li>
&lt;/ul>
&lt;p>注意，这里所说的“缓冲”，是指标准库内部实现的缓存。比方说，你可能见到过，很多程序遇到换行时才真正输出，而换行前的内容，其实就是被标准库暂时缓存了起来。
无论缓冲 I/O 还是非缓冲 I/O，它们最终还是要经过系统调用来访问文件。而根据上一节内容，我们知道，系统调用后，还会通过页缓存，来减少磁盘的 I/O 操作。&lt;/p>
&lt;h2 id="直接与非直接-io">直接与非直接 I/O&lt;/h2>
&lt;p>根据是否利用操作系统的页缓存&lt;/p>
&lt;ol>
&lt;li>直接 I/O，是指跳过操作系统的页缓存，直接跟文件系统交互来访问文件。&lt;/li>
&lt;li>非直接 I/O 正好相反，文件读写时，先要经过系统的页缓存，然后再由内核或额外的系统调用，真正写入磁盘。&lt;/li>
&lt;/ol>
&lt;p>想要实现直接 I/O，需要你在系统调用中，指定 O_DIRECT 标志。如果没有设置过，默认的是非直接 I/O。
不过要注意，直接 I/O、非直接 I/O，本质上还是和文件系统交互。如果是在数据库等场景中，你还会看到，跳过文件系统读写磁盘的情况，也就是我们通常所说的裸 I/O。&lt;/p>
&lt;h2 id="阻塞与非阻塞-io">阻塞与非阻塞 I/O&lt;/h2>
&lt;p>根据应用程序是否阻塞自身运行&lt;/p>
&lt;ol>
&lt;li>所谓阻塞 I/O，是指应用程序执行 I/O 操作后，如果没有获得响应，就会阻塞当前线程，自然就不能执行其他任务。&lt;/li>
&lt;li>所谓非阻塞 I/O，是指应用程序执行 I/O 操作后，不会阻塞当前的线程，可以继续执行其他的任务，随后再通过轮询或者事件通知的形式，获取调用的结果。&lt;/li>
&lt;/ol>
&lt;p>比方说，访问管道或者网络套接字时，设置 O_NONBLOCK 标志，就表示用非阻塞方式访问；而如果不做任何设置，默认的就是阻塞访问。&lt;/p>
&lt;h2 id="同步与异步-io">同步与异步 I/O&lt;/h2>
&lt;p>根据是否等待响应结果&lt;/p>
&lt;ol>
&lt;li>所谓同步 I/O，是指应用程序执行 I/O 操作后，要一直等到整个 I/O 完成后，才能获得 I/O 响应。&lt;/li>
&lt;li>所谓异步 I/O，是指应用程序执行 I/O 操作后，不用等待完成和完成后的响应，而是继续执行就可以。等到这次 I/O 完成后，响应会用事件通知的方式，告诉应用程序。&lt;/li>
&lt;/ol>
&lt;p>举个例子，在操作文件时，如果你设置了 O_SYNC 或者 O_DSYNC 标志，就代表同步 I/O。如果设置了 O_DSYNC，就要等文件数据写入磁盘后，才能返回；而 O_SYNC，则是在 O_DSYNC 基础上，要求文件元数据也要写入磁盘后，才能返回。
再比如，在访问管道或者网络套接字时，设置了 O_ASYNC 选项后，相应的 I/O 就是异步 I/O。这样，内核会再通过 SIGIO 或者 SIGPOLL，来通知进程文件是否可读写。
你可能发现了，这里的好多概念也经常出现在网络编程中。比如非阻塞 I/O，通常会跟 select/poll 配合，用在网络套接字的 I/O 中。
你也应该可以理解，“Linux 一切皆文件”的深刻含义。无论是普通文件和块设备、还是网络套接字和管道等，它们都通过统一的 VFS 接口来访问。&lt;/p>
&lt;h2 id="总结">总结&lt;/h2>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/op2fw9/1616167677139-656d34bf-0195-4576-919f-2eedc4f4ba5a.png" alt="">
在前面我们知道了，I/O 是分为两个过程的：&lt;/p>
&lt;ol>
&lt;li>数据准备的过程&lt;/li>
&lt;li>数据从内核空间拷贝到用户进程缓冲区的过程&lt;/li>
&lt;/ol>
&lt;p>阻塞 I/O 会阻塞在「过程 1 」和「过程 2」，而非阻塞 I/O 和基于非阻塞 I/O 的多路复用只会阻塞在「过程 2」，所以这三个都可以认为是同步 I/O。
异步 I/O 则不同，「过程 1 」和「过程 2 」都不会阻塞。&lt;/p>
&lt;h2 id="用故事去理解这几种-io-模型">用故事去理解这几种 I/O 模型&lt;/h2>
&lt;p>举个你去饭堂吃饭的例子，你好比用户程序，饭堂好比操作系统。&lt;/p>
&lt;p>阻塞 I/O 好比，你去饭堂吃饭，但是饭堂的菜还没做好，然后你就一直在那里等啊等，等了好长一段时间终于等到饭堂阿姨把菜端了出来（数据准备的过程），但是你还得继续等阿姨把菜（内核空间）打到你的饭盒里（用户空间），经历完这两个过程，你才可以离开。&lt;/p>
&lt;p>非阻塞 I/O 好比，你去了饭堂，问阿姨菜做好了没有，阿姨告诉你没，你就离开了，过几十分钟，你又来饭堂问阿姨，阿姨说做好了，于是阿姨帮你把菜打到你的饭盒里，这个过程你是得等待的。&lt;/p>
&lt;p>基于非阻塞的 I/O 多路复用好比，你去饭堂吃饭，发现有一排窗口，饭堂阿姨告诉你这些窗口都还没做好菜，等做好了再通知你，于是等啊等（&lt;code>select&lt;/code> 调用中），过了一会阿姨通知你菜做好了，但是不知道哪个窗口的菜做好了，你自己看吧。于是你只能一个一个窗口去确认，后面发现 5 号窗口菜做好了，于是你让 5 号窗口的阿姨帮你打菜到饭盒里，这个打菜的过程你是要等待的，虽然时间不长。打完菜后，你自然就可以离开了。&lt;/p>
&lt;p>异步 I/O 好比，你让饭堂阿姨将菜做好并把菜打到饭盒里后，把饭盒送到你面前，整个过程你都不需要任何等待。&lt;/p></description></item><item><title>Docs: 6.Package 管理</title><link>https://desistdaydream.github.io/docs/IT%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/6.Package-%E7%AE%A1%E7%90%86/Package-%E7%AE%A1%E7%90%86/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/IT%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/6.Package-%E7%AE%A1%E7%90%86/Package-%E7%AE%A1%E7%90%86/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;/blockquote>
&lt;p>在 Linux 操作系统中，Package 就是指应用程序的安装包。保存 Package 的地方(网站、ISO 等)称为 &lt;strong>Repository(简称 Repo)&lt;/strong>，我们可以从各种 Linux 发行版的官方 Repo 中下载对应的可用的 Package，以安装到这些发行版的 Linux 系统中。&lt;/p>
&lt;blockquote>
&lt;p>注意：哪怕两个发行版的包管理器相同，也不代表他们的 Package 是可以公用的，比如 CentOS 和 OpenEuler 都用 yum，但是 CentOS 的 Package 是无法装在 OpenEuler 上的，安装时将会报错(比如包与包之间 &lt;strong>conflict(冲突)&lt;/strong>)&lt;/p>
&lt;/blockquote>
&lt;h1 id="linux-各发行版的官方-repo-站点">Linux 各发行版的官方 Repo 站点&lt;/h1>
&lt;ul>
&lt;li>包含很多发行版的 Repo 站点: &lt;a href="https://pkgs.org/">https://pkgs.org/&lt;/a>&lt;/li>
&lt;li>OpenEuler: &lt;a href="https://repo.openeuler.org/">https://repo.openeuler.org/&lt;/a>&lt;/li>
&lt;li>CentOS: &lt;a href="https://centos.pkgs.org/">https://centos.pkgs.org/&lt;/a>&lt;/li>
&lt;li>Ubuntu: &lt;a href="https://packages.ubuntu.com/">https://packages.ubuntu.com/&lt;/a>
&lt;ul>
&lt;li>在这里可以找到 jammy 版本(20.04 TLS)的所有软件包列表: &lt;a href="https://packages.ubuntu.com/jammy/allpackages">https://packages.ubuntu.com/jammy/allpackages&lt;/a>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul></description></item><item><title>Docs: 7.Process 管理</title><link>https://desistdaydream.github.io/docs/IT%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2.Kernel%E5%86%85%E6%A0%B8/7.Process-%E7%AE%A1%E7%90%86/Process-%E7%AE%A1%E7%90%86/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/IT%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2.Kernel%E5%86%85%E6%A0%B8/7.Process-%E7%AE%A1%E7%90%86/Process-%E7%AE%A1%E7%90%86/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://blog.csdn.net/ljianhui/article/details/46718835">原文连接&lt;/a>，本文为 IBM RedBook 的 &lt;a href="http://users.polytech.unice.fr/~bilavarn/fichier/elec5_linux/linux_perf_and_tuning_IBM.pdf">Linux Performanceand Tuning Guidelines&lt;/a> 的 1.1 节的翻译&lt;/li>
&lt;li>&lt;a href="https://mp.weixin.qq.com/s/fzLcAkYwKhj-9hgoVkTzaw">阿里技术，CPU 飙高，系统性能问题如何排查？&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>进程管理是操作系统的最重要的功能之一。有效率的进程管理能保证一个程序平稳而高效地运行。它包括进程调度、中断处理、信号、进程优先级、上下文切换、进程状态、进度内存等。&lt;/p>
&lt;p>&lt;strong>Process(进程)&lt;/strong> 实际是运行在 CPU 中的一个&lt;strong>Program(应用程序) 的实体&lt;/strong>。在 Linux 系统中，能够同时运行多个进程，Linux 通过在短的时间间隔内轮流运行这些进程而实现“多任务”。这一短的时间间隔称为“时间片”，让进程轮流运行的方法称为“进程调度” ，完成调度的程序称为调度程序。&lt;/p>
&lt;p>进程调度控制进程对 CPU 的访问。当需要选择下一个进程运行时，由调度程序选择最值得运行的进程。可运行进程实际上是仅等待 CPU 资源的进程，如果某个进程在等待其它资源，则该进程是不可运行进程。Linux 使用了比较简单的基于优先级的进程调度算法选择新的进程。&lt;/p>
&lt;p>通过多任务机制，每个进程可认为只有自己独占计算机，从而简化程序的编写。每个进程有自己单独的地址空间，并且只能由这一进程访问，这样，操作系统避免了进程之间的互相干扰以及“坏”程序对系统可能造成的危害。 为了完成某特定任务，有时需要综合两个程序的功能，例如一个程序输出文本，而另一个程序对文本进行排序。为此，操作系统还提供进程间的通讯机制来帮助完成这样的任务。Linux 中常见的进程间通讯机制有信号、管道、共享内存、信号量和套接字等。&lt;/p>
&lt;p>内核通过 SCI 提供了一个 API 来创建一个新进程(fork、exec 或 Portable Operating System Interface [POSⅨ] 函数)、停止进程(kill、exit)、并在它们之间进行通信和同步(signal 或者 POSⅨ 机制)。&lt;/p>
&lt;p>计算机实际上可以做的事情实质上非常简单，比如计算两个数的和，再比如在内存中寻找到某个地址等等。这些最基础的计算机动作被称为指令(instruction)。所谓的程序(program)，就是这样一系列指令的所构成的集合。通过程序，我们可以让计算机完成复杂的操作。程序大多数时候被存储为可执行的文件。这样一个可执行文件就像是一个菜谱，计算机可以按照菜谱作出可口的饭菜。&lt;/p>
&lt;p>Program(程序) 和 Process(进程) 的区别是什么呢?&lt;/p>
&lt;ol>
&lt;li>在很久很久以前，计算机刚出现的时候，是没有操作系统的，那时候一台机器只是运行一个程序，得出数据，后来人们为了同时运行多个程序从而研究出了操作系统，在操作系统之上可以运行多个程序&lt;/li>
&lt;li>进程是程序的一个具体实现。类似于按照食谱，真正去做菜的过程。同一个程序可以执行多次，每次都可以在内存中开辟独立的空间来装载，从而产生多个进程。不同的进程还可以拥有各自独立的 IO 接口。&lt;/li>
&lt;/ol>
&lt;p>操作系统的一个重要功能就是为进程提供方便，比如说为进程分配内存空间，管理进程的相关信息等等，就好像是为我们准备好了一个精美的厨房。&lt;/p>
&lt;h2 id="进程的生命周期">进程的生命周期&lt;/h2>
&lt;p>每一个进程都有其生命周期，例如创建、运行、终止和消除。这些阶段会在系统启动和运行中重复无数次。因此，进程的生命周期对于其性能的分析是非常重要的。下图展示了经典的进程生命周期。
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/ld23ik/1616167507353-2f676d82-88da-483c-a939-399f284d6425.jpeg" alt="">
不会关闭的常驻进程可以称为 &lt;strong>Daemon Process(守护进程，简称 Daemon)&lt;/strong>&lt;/p>
&lt;blockquote>
&lt;p>一般 daemon 的名称都会在进程名后加一个字母 d 作为 daemon 的 process，比如 vsftp 的 daemon 就是 vsftpd。&lt;/p>
&lt;/blockquote>
&lt;p>当一个进程创建一个新的进程，创建进程(父进程)的进程调用 一个 fork() 系统调用。当 fork() 系统调用被调用，它得到该新创建进程（子进程）的进程描述并调用一个新的进程 id。它复制该值到父进程进程描述到子进程中。此时整个的父进程的地址空间是没有被复制的；父子进程共享相同的地址空间。&lt;/p>
&lt;p>exec() 系统调用复制新的程序到子进程的地址空间。因为父子进程共享地址空间，写入一个新的程序的数据会引起一个分页错误。在这种情况下，内存会分配新的物理内存页给子进程。&lt;/p>
&lt;p>这个推迟的操作叫作写时复制。子进程通常运行他们自己的程序而不是与父进程运行相同的程序。这个操作避免了不必要的开销，因为复制整个地址空间是一个非常缓慢和效率低下的操作，它需要使用大量的处理器时间和资源。&lt;/p>
&lt;p>当程序已经执行完成，子进程通过调用 exit()系统调用终止。exit()系统调用释放进程大部分的数据并通过发送一个信号通知其父进程。此时，子进程是一个被叫作僵尸进程的进程（参阅 page 7 的“Zombie processes”）。&lt;/p>
&lt;p>子进程不会被完全移除直到其父进程知道其子进程的调用 wait()系统调用而终止。当父进程被通知子进程终止，它移除子进程的所有数据结构并释放它的进程描述。&lt;/p>
&lt;h2 id="父进程与子进程">父进程与子进程&lt;/h2>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/ld23ik/1616167507409-d531245f-abbe-4a2a-b575-d2ae72c6949f.jpeg" alt="">&lt;/p>
&lt;ul>
&lt;li>用颜色的线标示的两列，左侧的为进程号(PID)右侧的为父进程号(PPID)&lt;/li>
&lt;li>子进程与父进程的环境变量相同&lt;/li>
&lt;li>老进程成为新进程的父进程(parent process)，而相应的，新进程就是老的进程的子进程(child process)。一个进程除了有一个 PID 之外，还会有一个 PPID(parent PID)来存储的父进程 PID。如果我们循着 PPID 不断向上追溯的话，总会发现其源头是 init 进程。所以说，所有的进程也构成一个以 init 为根的树状结构。&lt;/li>
&lt;li>如上图所示，我们查询当前 shell 下的进程：
&lt;ul>
&lt;li>我们可以看到，第二个进程 ps 是第一个进程 bash 的子进程。&lt;/li>
&lt;li>还可以用 &lt;code>pstree&lt;/code> 命令来显示整个进程树。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>fork() 通常作为一个函数被调用。这个函数会有两次返回，将子进程的 PID 返回给父进程，0 返回给子进程。实际上，子进程总可以查询自己的 PPID 来知道自己的父进程是谁，这样，一对父进程和子进程就可以随时查询对方。&lt;/li>
&lt;li>通常在调用 fork 函数之后，程序会设计一个 if 选择结构。当 PID 等于 0 时，说明该进程为子进程，那么让它执行某些指令,比如说使用 exec 库函数(library function)读取另一个程序文件，并在当前的进程空间执行 (这实际上是我们使用 fork 的一大目的: 为某一程序创建进程)；而当 PID 为一个正整数时，说明为父进程，则执行另外一些指令。由此，就可以在子进程建立之后，让它执行与父进程不同的功能。&lt;/li>
&lt;/ul>
&lt;h3 id="子进程的-termination终结">子进程的 termination(终结)&lt;/h3>
&lt;p>当子进程终结时，它会通知父进程，并清空自己所占据的内存，并在内核里留下自己的退出信息(exit code，如果顺利运行，为 0；如果有错误或异常状况，为&amp;gt;0 的整数)。在这个信息里，会解释该进程为什么退出。父进程在得知子进程终结时，有责任对该子进程使用 wait 系统调用。这个 wait 函数能从内核中取出子进程的退出信息，并清空该信息在内核中所占据的空间。但是，如果父进程早于子进程终结，子进程就会成为一个孤儿(orphand)进程。孤儿进程会被过继给 init 进程，init 进程也就成了该进程的父进程。init 进程负责该子进程终结时调用 wait 函数。&lt;/p>
&lt;p>当然，一个糟糕的程序也完全可能造成子进程的退出信息滞留在内核中的状况（父进程不对子进程调用 wait 函数），这样的情况下，子进程成为僵尸(zombie)进程。当大量僵尸进程积累时，内存空间会被挤占。&lt;/p>
&lt;h2 id="thread线程">Thread(线程)&lt;/h2>
&lt;p>一个线程是一个单独的进程生成的一个执行单元。它与其他的线程并行地运行在同一个进程中。各个线程可以共享进程的资源，例如内存、地址空间、打开的文件等等。它们能访问相同的程序数据集。线程也被叫作轻量级的进程（Light Weight Process，LWP）。因为它们共享资源，所以每个线程不应该在同一时间改变它们共享的资源。互斥的实现、锁、序列化等是用户程序的责任。&lt;/p>
&lt;p>从性能的角度来说，创建线程的开销比创建进程少，因数创建一个线程时不需要复制资源。另一方面，进程和线程拥在调度算法上有相似的特性。&lt;strong>内核以相似的方式处理它们&lt;/strong>。
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/ld23ik/1616167507380-b6ae3b1e-b47c-454c-b3c7-9942dde4f480.jpeg" alt="">
所以，一个进程创建的线程，也是可以运行在多个 CPU 上的。
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/ld23ik/1616645843002-c07df4a7-3d7a-4969-8203-4bc20169721a.png" alt="image.png">
在现在的 Linux 实现中，线程支持 UNIX 的可移植操作系统接口（POSIX）标准库。在 Linux 操作系统中有几种可用的线程实现。以下是广泛使用的线程库：&lt;/p>
&lt;p>Linux Threads 自从 Linux 内核 2.0 起就已经被作为默认的线程实现。Linux Threads 的一些实现并不符合 POSIX 标准。Native POSIX Thread Library（NPTL）正在取代 Linux Threads。Linux Threads 在将来的 Linux 企业发行版中将不被支持。&lt;/p>
&lt;p>Native POSIX Thread Libary（NPTL）&lt;/p>
&lt;p>NPTL 最初是由红帽公司开发的。NPTL 与 POSIX 更加兼容。通过 Linux 内核 2.6 的高级特性，例如，新的 clone()系统调用、信号处理的实现等等，它具有比 LinuxThreads 更高的性能和伸缩性。&lt;/p>
&lt;p>NPTL 与 LinuxThreads 有一些不兼容。一个依赖于 LinuxThreads 的应用可能不能在 NPTL 实现中工作。&lt;/p>
&lt;p>Next Generation POSIX Thread（NGPT）&lt;/p>
&lt;p>NGPT 是一个 IBM 开发的 POSIX 线程库。现在处于维护阶段并且在未来也没有开发计划。&lt;/p>
&lt;p>使用 LD_ASSUME_KERNEL 环境变量，你可以选择在应用中使用哪一个线程库。&lt;/p>
&lt;h2 id="linux-内核代码中的-process">Linux 内核代码中的 Process&lt;/h2>
&lt;p>在 Linux 中，&lt;strong>Process(进程) 属于&lt;/strong> &lt;strong>Task(任务)&lt;/strong> 的一种类型，都被 task_struct 结构管理，该结构同时被叫作进程描述。一个进程描述包含一个运行进程所有的必要信息，例如进程标识、进程属性和构建进程的资源。如果你了解该进程构造，你就能理解对于进程的运行和性能来说，什么是重要的。&lt;/p>
&lt;p>v5.14 代码：&lt;a href="https://github.com/torvalds/linux/blob/v5.14/include/linux/sched.h#L661">include/linux/sched.h&lt;/a>&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-c" data-lang="c">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">struct&lt;/span> task_struct {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#ifdef CONFIG_THREAD_INFO_IN_TASK
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#75715e">/*
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> * For reasons of header soup (see current_thread_info()), this
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> * must be the first element of task_struct.
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> */&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">struct&lt;/span> thread_info thread_info;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#endif
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> ......
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 进程状态
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">unsigned&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span> __state;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 进程唯一标识符
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">pid_t&lt;/span> pid;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">pid_t&lt;/span> tgid;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 进程名称，上限 16 字符
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">char&lt;/span> comm[TASK_COMM_LEN];
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 打开的文件
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">struct&lt;/span> files_struct &lt;span style="color:#f92672">*&lt;/span>files;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ......
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>下图展示了进程结构相关的进程信息概述。
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/ld23ik/1616167507336-aaeec645-b9df-41c3-99ab-6bf39aed4f42.jpeg" alt="">
其实从这里能看出来，从某种角度来看，**对于内核来说并没有线程这个概念。Linux 把所有的线程都当做进程来实现，内核也没有特别的调度算法来处理线程。**线程仅仅被视为一个与其他进程共享某些资源的进程，和进程一样，每个线程也都是有自己的 &lt;code>task_struct&lt;/code>，所以在内核中，线程看起来就是一个普通的进程。线程也被称作轻量级进程，一个进程可以有多个线程，线程拥有自己独立的栈，切换也由操作系统调度。在 Linux 上可以通过 &lt;code>pthread_create()&lt;/code> 方法或者 &lt;code>clone()&lt;/code> 系统调用创建；&lt;/p>
&lt;h1 id="进程优先级和-nice-值">进程优先级和 nice 值&lt;/h1>
&lt;p>进程优先级是一个数值，它通过动态的优先级和静态的优先级来决定进程被 CPU 处理的顺序。一个拥有更高进程优先级的进程拥有更大的机率得到处理器的处理。&lt;/p>
&lt;p>内核根据进程的行为和特性使用试探算法，动态地调整调高或调低动态优先级。一个用户进程可以通过使用进程的 nice 值间接改变静态优先级。一个拥有更高静态优先级的进程将会拥有更长的时间片（进程能在处理上运行多长时间）。&lt;/p>
&lt;p>Linux 支持从 19（最低优先级）到-20（最高优先级）的 nice 值。默认值为 0。把程序的 nice 值修改为负数（使进程的优先级更高），需要以 root 身份登陆或使用 su 命令以 root 身份执行。&lt;/p>
&lt;h1 id="上下文切换">上下文切换&lt;/h1>
&lt;p>在进程运行过程中，进程的运行信息被保存于处理器的寄存器和它的缓存中。正在执行的进程加载到寄存器中的数据集被称为上下文。为了切换进程，运行中进程的上下文将会被保存，接下来的运行进程的上下文将被被恢复到寄存器中。进程描述和内核模式堆栈的区域将会用来保存上下文。这个切换被称为上下文切换。过多的上下文切换是不受欢迎的，因为处理器每次都必须清空刷新寄存器和缓存，为新的进程制造空间。它可能会引起性能问题。&lt;/p>
&lt;p>下图说明了上下文切换如何工作。
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/ld23ik/1616167507475-6f5a9385-f033-4c00-8344-2953197b973c.jpeg" alt="">&lt;/p>
&lt;h1 id="中断处理">中断处理&lt;/h1>
&lt;p>中断处理是优先级最高的任务之一。中断通常由 I/O 设备产生，例如网络接口卡、键盘、磁盘控制器、串行适配器等等。中断处理器通过一个事件通知内核（例如，键盘输入、以太网帧到达等等）。它让内核中断进程的执行，并尽可能快地执行中断处理，因为一些设备需要快速的响应。它是系统稳定的关键。当一个中断信号到达内核，内核必须切换当前的进程到一个新的中断处理进程。这意味着中断引起了上下文切换，因此大量的中断将会引起性能的下降。&lt;/p>
&lt;p>在 Linux 的实现中，有两种类型的中断。硬中断是由请求响应的设备发出的（磁盘 I/O 中断、网络适配器中断、键盘中断、鼠标中断）。软中断被用于处理可以延迟的任务（TCP/IP 操作，SCSI 协议操作等等）。你可以在 &lt;code>/proc/interrupts&lt;/code> 文件中查看硬中断的相关信息。&lt;/p>
&lt;p>在多处理器的环境中，中断被每一个处理器处理。绑定中断到单个的物理处理中能提高系统的性能。更多的细节，请参阅 4.4.2，“CPU 的中断处理亲和力”。&lt;/p>
&lt;h1 id="进程的状态">进程的状态&lt;/h1>
&lt;p>每一个进程拥有自己的状态，状态表示了进程当前在发生什么。LINUX 2.6 以后的内核中，在进程的执行期间进程的状态会发生改变，进程一般存在 7 种基础状态：D-不可中断睡眠、R-可执行、S-可中断睡眠、T-暂停态、t-跟踪态、X-死亡态、Z-僵尸态，这几种状态在 ps 命令的 man 手册中有对应解释。&lt;/p>
&lt;ul>
&lt;li>&lt;strong>D&lt;/strong>＃不间断的睡眠（通常是 IO）&lt;/li>
&lt;li>&lt;strong>R&lt;/strong> ＃正在运行或可运行（在运行队列上）&lt;/li>
&lt;li>&lt;strong>S&lt;/strong> ＃可中断的睡眠（等待事件完成）&lt;/li>
&lt;li>&lt;strong>T&lt;/strong> ＃被作业控制信号停止&lt;/li>
&lt;li>&lt;strong>t&lt;/strong>＃在跟踪过程中被调试器停止&lt;/li>
&lt;li>&lt;strong>X&lt;/strong> ＃已死（永远都不会出现）&lt;/li>
&lt;li>&lt;strong>Z&lt;/strong> ＃已终止运行（“僵尸”）的进程，已终止但未由其父进程获得&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/ld23ik/1616167507456-ca89ed8d-d8a1-4cd6-96ab-c78372840f4a.jpeg" alt="">&lt;/p>
&lt;h2 id="d-task_uninterruptible不可中断睡眠态">D (TASK_UNINTERRUPTIBLE)，不可中断睡眠态&lt;/h2>
&lt;p>顾名思义，位于这种状态的进程处于睡眠中，并且不允许被其他进程或中断(异步信号)打断。因此这种状态的进程，是无法使用 kill -9 杀死的(kill 也是一种信号)，除非重启系统(没错，就是这么头硬)。不过这种状态一般由 I/O 等待(比如磁盘 I/O、网络 I/O、外设 I/O 等)引起，出现时间非常短暂，大多很难被 PS 或者 TOP 命令捕获(除非 I/O HANG 死)。SLEEP 态进程不会占用任何 CPU 资源。&lt;/p>
&lt;h2 id="r-task_running可执行态">R (TASK_RUNNING)，可执行态&lt;/h2>
&lt;p>这种状态的进程都位于 CPU 的可执行队列中，正在运行或者正在等待运行，即不是在上班就是在上班的路上。&lt;/p>
&lt;p>在此状态下，表示进程正在 CPU 中运行或在队列中等待运行（运行队列）。&lt;/p>
&lt;h2 id="s-task_interruptible可中断睡眠态">S (TASK_INTERRUPTIBLE)，可中断睡眠态&lt;/h2>
&lt;p>不同于 D，这种状态的进程虽然也处于睡眠中，但是是允许被中断的。这种进程一般在等待某事件的发生（比如 socket 连接、信号量等），而被挂起。一旦这些时间完成，进程将被唤醒转为 R 态。如果不在高负载时期，系统中大部分进程都处于 S 态。SLEEP 态进程不会占用任何 CPU 资源。&lt;/p>
&lt;p>在此状态下，进程被暂停并等待一个某些条件状态的到达。如果一个进程处于 TASK_INTERRUPTIBLE 状态并接收到一个停止的信号，进程的状态将会被改变并中断操作。一个典型的 TASK_INTERRUPTIBLE 状态的进程的例子是一个进程等待键盘中断。&lt;/p>
&lt;h2 id="t--t-task_stopped--task_traced暂停-or-跟踪态">T &amp;amp; t (TASK_STOPPED &amp;amp; TASK_TRACED)，暂停 or 跟踪态&lt;/h2>
&lt;p>这种两种状态的进程都处于运行停止的状态。不同之处是暂停态一般由于收到 SIGSTOP、SIGTSTP、SIGTTIN、SIGTTOUT 四种信号被停止，而跟踪态是由于进程被另一个进程跟踪引起(比如 gdb 断点）。暂停态进程会释放所有占用资源。&lt;/p>
&lt;p>TASK_STOPPED 在此状态下的进程被某些信号（如 SIGINT，SIGSTOP）暂停。进程正在等待通过一个信号恢复运行，例如 SIGCONT。&lt;/p>
&lt;h2 id="z-exit_zombietask_zombie-僵尸态">Z (EXIT_ZOMBIE/TASK_ZOMBIE), 僵尸态&lt;/h2>
&lt;p>这种状态的进程实际上已经结束了，但是父进程还没有回收它的资源（比如进程的描述符、PID 等）。僵尸态进程会释放除进程入口之外的所有资源。&lt;/p>
&lt;p>当一个进程调用 exit()系统调用退出后，它的父进程应该知道该进程的终止。处于 TASK_ZOMBIE 状态的进程会等待其父进程通知其释放所有的数据结构。&lt;/p>
&lt;p>当一个进程接收到一个信号而终止，它在结束自己之前，通常需要一些时间来结束所有的任务（例如关闭打开的文件）。在这个通常非常短暂的时间内，该进程就是一个僵尸进程。&lt;/p>
&lt;p>进程已经完成所有的关闭任务后，它会向父进程报告其即将终止。有些时候，一个僵尸进程不能把自己终止，这将会引导它的状态显示为 z（zombie）。&lt;/p>
&lt;p>使用 kill 命令来关闭这样的一个进程是不可能的，因为该进程已经被认为已经死掉了。如果你不能清除僵尸进程，你可以结束其父进程，然后僵尸进程也随之消失。但是，如果父进程为 init 进程，你不能结束它。init 进程是一个非常重要的进程，因此可能需要重启系统来清除僵尸进程。&lt;/p>
&lt;h2 id="x-exit_dead-死亡态">X (EXIT_DEAD), 死亡态&lt;/h2>
&lt;p>进程的真正结束态，这种状态一般在正常系统中捕获不到。&lt;/p>
&lt;h1 id="进程内存段">进程内存段&lt;/h1>
&lt;p>进程使用其自身的内存区域来执行工作。工作的变化根据情况和进程的使用而决定。进程可以拥有不同的工作量特性和不同的数据大小需求。进程必须处理各种数据大小。为了满足需求，Linux 内核为每个进程使用动态申请内存的机制。进程内存分配的数据结构如图 1-7 所示。&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/ld23ik/1616167507458-2bbc9553-910c-4d66-9ad1-8f45893277da.jpeg" alt="">&lt;/p>
&lt;p>图 1-7 进程地址空间&lt;/p>
&lt;p>进程内存区由以下几部分组成：&lt;/p>
&lt;p>Text 段&lt;/p>
&lt;p>该区域用于存储运行代码。&lt;/p>
&lt;p>Data 段&lt;/p>
&lt;p>数据段包括三个区域。&lt;/p>
&lt;p>– Data：该区域存储已被初始化的数据，如静态变量。&lt;/p>
&lt;p>– BSS：该区域存储初始化为 0 的数据。数据被初始化为 0。&lt;/p>
&lt;p>– Heap：该区域用于根据需求使用 malloc()动态申请的内存。堆向高地址方向增长。&lt;/p>
&lt;p>Stack 段&lt;/p>
&lt;p>该区域用于存储局部变量、函数参数和返回函数的地址。栈向低地址方向增长。&lt;/p>
&lt;p>用户进程的地址空间内存分布可以使用 pmap 命令来查看。你可以使用 ps 命令来查看内存段的大小。可以参阅 2.3.10 的“pmap”，“ps 和 pstree”。&lt;/p>
&lt;h1 id="进程的-exit-code退出码">进程的 exit code(退出码)&lt;/h1>
&lt;p>在 Linux 系统中，程序可以在执行终止后传递值给其父进程，这个值被称为 &lt;strong>exit code(退出码)&lt;/strong> 或 **exit status(退出状态)**或 &lt;strong>reture status(返回码)&lt;/strong>。在 POSIX 系统中，惯例做法是当程序成功执行时 &lt;strong>exit code 为 0&lt;/strong>，当程序执行失败时 &lt;strong>exit code 非 0&lt;/strong>。&lt;/p>
&lt;p>传递状态码为何重要？如果你在命令行脚本上下文中查看状态码，答案显而易见。任何有用的脚本，它将不可避免地要么被其他脚本所使用，要么被 bash 单行脚本包裹所使用。特别是脚本被用来与自动化工具 SaltStack 或者监测工具 Nagios 配合使用。这些工具会执行脚本并检查它的状态，来确定脚本是否执行成功。&lt;/p>
&lt;p>其中最重要的原因是，即使你不定义状态码，它仍然存在于你的脚本中。如果你不定义恰当的退出码，执行失败的脚本可能会返回成功的状态，这样会导致问题，问题大小取决于你的脚本做了什么。&lt;/p>
&lt;p>Linux 提供了一个专门的变量$?来保存上个已执行命令的退出状态码。&lt;/p>
&lt;p>对于需要进行检查的命令，必须在其运行完毕后立刻查看或使用$?变量，它的值会变成由 shell 所执行的最后一条命令的退出状态码。&lt;/p>
&lt;p>一个成功结束的命令的退出状态码是 0，如果一个命令结束时有错误，退出状态码就是一个正数值（1-255）。&lt;/p>
&lt;p>Linux 上执行 exit 可使 shell 以指定的状态值退出。若不设置状态值参数，则 shell 以预设值退出。状态值 0 代表执行成功，其他值代表执行失败。exit 也可用在 script，离开正在执行的 script，回到 shell。&lt;/p>
&lt;p>Linux 错误退出状态码没有什么标准可循，但有一些可用的参考。&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/ld23ik/1616167507500-9f1aab01-171b-4ece-a6fa-9f576852a403.webp" alt="">&lt;/p>
&lt;p>关于具体的服务，相应的退出码，由开发者代码决定。&lt;/p>
&lt;p>&lt;strong>Linux 进程退出码&lt;/strong>&lt;/p>
&lt;p>&lt;a href="https://jin-yang.github.io/post/linux-process-exit-code-introduce.html">https://jin-yang.github.io/post/linux-process-exit-code-introduce.html&lt;/a>&lt;/p>
&lt;p>&lt;strong>Linux 退出状态码及 exit 命令&lt;/strong>&lt;/p>
&lt;p>&lt;a href="https://www.cnblogs.com/01-single/p/7206664.html">https://www.cnblogs.com/01-single/p/7206664.html&lt;/a>&lt;/p>
&lt;p>&lt;strong>理解 Exit Code 并学会如何在 Bash 脚本中使用&lt;/strong>&lt;/p>
&lt;p>&lt;a href="http://blog.jayxhj.com/2016/02/understanding-exit-codes-and-how-to-use-them-in-bash-scripts">http://blog.jayxhj.com/2016/02/understanding-exit-codes-and-how-to-use-them-in-bash-scripts&lt;/a>&lt;/p>
&lt;p>&lt;strong>Appendix E. Exit Codes With Special Meanings&lt;/strong>&lt;/p>
&lt;p>&lt;a href="http://www.tldp.org/LDP/abs/html/exitcodes.html">http://www.tldp.org/LDP/abs/html/exitcodes.html&lt;/a>&lt;/p>
&lt;p>&lt;strong>What is the authoritative list of Docker Run exit codes?&lt;/strong>&lt;/p>
&lt;p>&lt;a href="https://stackoverflow.com/questions/31297616/what-is-the-authoritative-list-of-docker-run-exit-codes">https://stackoverflow.com/questions/31297616/what-is-the-authoritative-list-of-docker-run-exit-codes&lt;/a>&lt;/p>
&lt;p>&lt;strong>Identifying Exit Codes and their meanings&lt;/strong>&lt;/p>
&lt;p>&lt;a href="https://support.circleci.com/hc/en-us/articles/360002341673-Identifying-Exit-Codes-and-their-meanings">https://support.circleci.com/hc/en-us/articles/360002341673-Identifying-Exit-Codes-and-their-meanings&lt;/a>&lt;/p>
&lt;p>&lt;strong>OpenShift Exit Status Codes&lt;/strong>&lt;/p>
&lt;p>&lt;a href="https://access.redhat.com/documentation/en-US/OpenShift_Online/2.0/html/Cartridge_Specification_Guide/Exit_Status_Codes.html">https://access.redhat.com/documentation/en-US/OpenShift_Online/2.0/html/Cartridge_Specification_Guide/Exit_Status_Codes.html&lt;/a>&lt;/p></description></item><item><title>Docs: 7.时间管理</title><link>https://desistdaydream.github.io/docs/IT%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/7.%E6%97%B6%E9%97%B4%E7%AE%A1%E7%90%86/7.%E6%97%B6%E9%97%B4%E7%AE%A1%E7%90%86/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/IT%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/7.%E6%97%B6%E9%97%B4%E7%AE%A1%E7%90%86/7.%E6%97%B6%E9%97%B4%E7%AE%A1%E7%90%86/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://www.nim.ac.cn/520/node/4.html">中国计量科学研究院,SI 基本单位&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>1983 年，国际计量打会讨论决定，把 1 米的定义修改为光在 1/299792458 秒内走过的距离
1967 年，国际计量大会定义：1 秒是铯 133 原子基态的两个超精细能量间跃迁对应辐射的 9192631770 个周期的持续时间。&lt;/p>
&lt;h1 id="实现-ntp-协议的工具">实现 NTP 协议的工具&lt;/h1>
&lt;p>ntpd # 在 centos8 中已不再支持，推荐使用新工具 chrony 来实现 ntp 协议
chrony #&lt;/p>
&lt;h1 id="其他管理系统时间工具">其他管理系统时间工具&lt;/h1>
&lt;h2 id="date--打印或设置系统日期和时间">date # 打印或设置系统日期和时间&lt;/h2>
&lt;h3 id="syntax语法">Syntax(语法)&lt;/h3>
&lt;p>&lt;strong>date [OPTIONS]&amp;hellip; [+FORMAT]&lt;/strong>
可以通过 FORMAT 设置显示时间的格式&lt;/p>
&lt;p>OPTIONS&lt;/p>
&lt;ul>
&lt;li>-&lt;strong>s&lt;/strong> # 从给定的字符串中设定时间。i.e.设置时间&lt;/li>
&lt;li>&lt;strong>-d&lt;/strong> # 从给定的字符串中显示时间，而不是显示现在的时间。常用于判断给定的数字是否符合时间日期的格式 e.g.date -d 9999 +%H%M 不合法，date -d 1011 +%H%M 合法&lt;/li>
&lt;/ul>
&lt;p>FORMAT:&lt;/p>
&lt;ul>
&lt;li>&lt;code>%F&lt;/code> 年月日(年-月-日)&lt;/li>
&lt;li>&lt;code>%Y&lt;/code> 年&lt;/li>
&lt;li>&lt;code>%m&lt;/code> 月&lt;/li>
&lt;li>&lt;code>%d&lt;/code> 日&lt;/li>
&lt;li>&lt;code>%H&lt;/code> 小时&lt;/li>
&lt;li>&lt;code>%M&lt;/code> 分钟&lt;/li>
&lt;li>&lt;code>%S&lt;/code> 秒&lt;/li>
&lt;li>%s # 从 1970-01-01 00:00:00 UTC 时间开始经过的秒。&lt;/li>
&lt;/ul>
&lt;p>EXAMPLE&lt;/p>
&lt;ul>
&lt;li>&lt;strong>date -s 2008/05/06&lt;/strong> #&lt;/li>
&lt;li>&lt;strong>date -s 18:40:00&lt;/strong>&lt;/li>
&lt;li>**date +%H:%M **# 显示当前小时与分钟&lt;/li>
&lt;li>&lt;strong>date -d 1011 +%H%M&lt;/strong> # 显示给定的小时与分钟&lt;/li>
&lt;li>&lt;strong>date +%x &amp;ndash;&amp;gt; 10/21/2009&lt;/strong> #&lt;/li>
&lt;li>&lt;strong>date +%m/%d/%Y&lt;/strong> # 10/21/2009&lt;/li>
&lt;li>2009-10-21 15:18:17
&lt;ul>
&lt;li>**date &amp;ldquo;+%Y-%m-%d %H:%M:%S&amp;rdquo; **#&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>2021-12-20_15:41
&lt;ul>
&lt;li>&lt;strong>date +%F_%H:%M&lt;/strong>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h2 id="timedatectl-options-command--控制系统时间和日期">timedatectl [OPTIONS] [COMMAND] # 控制系统时间和日期&lt;/h2>
&lt;p>若不加任何子命令和选项，则显示日期与时间相关信息
&lt;strong>COMMAND：&lt;/strong>
&lt;strong>status # 显示当前时间设定。(默认 COMMAND)&lt;/strong>&lt;/p>
&lt;p>&lt;strong>set-time TIME # 设置系统时间。&lt;/strong>&lt;/p>
&lt;p>这也将相应地更新 RTC 时间。时间可以以 “2012-10-30 18:17:16” 格式指定。&lt;/p>
&lt;ul>
&lt;li>EXAMPLE
&lt;ul>
&lt;li>&lt;strong>timedatectl set-time &amp;ldquo;2020-11-5 18:17:16&amp;rdquo;&lt;/strong> # 将系统时间设置为 2020 年 11 月 5 日 18 点 17 分 16 秒&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>set-timezone ZONE # 设置系统的时区&lt;/strong>&lt;/p>
&lt;p>&lt;strong>list-timezones Show known time zones&lt;/strong>&lt;/p>
&lt;p>&lt;strong>set-local-rtc &amp;lt;true|false&amp;gt; # Control whether RTC is in local tim&lt;/strong>e&lt;/p>
&lt;p>&lt;strong>set-ntp &amp;lt;true|false&amp;gt; # 控制是否启用 NTP。&lt;/strong>&lt;/p>
&lt;h2 id="hwclock--rw--查看硬件时间bios-的">hwclock [-rw] # 查看硬件时间(BIOS 的)&lt;/h2>
&lt;p>OPTIONS&lt;/p>
&lt;ul>
&lt;li>&lt;strong>-r&lt;/strong> # 查看现有 BIOS 时间，默认为－r 参数&lt;/li>
&lt;li>&lt;strong>-w&lt;/strong> # 将现在的 linux 系统时间写入 BIOS 中&lt;/li>
&lt;/ul>
&lt;p>当我们进行完 Linux 时间的校时后，还需要以 hwclock -w 来更新 BIOS 的时间，因为每次开机的时候，系统会重新由 BIOS 将时间读出来，所以， BIOS 才是重要的时间依据。&lt;/p>
&lt;h1 id="linux-校时">Linux 校时&lt;/h1>
&lt;p>调整 linux 系统时间和时区与 Internet 时间同步&lt;/p>
&lt;p>一、修改时区：&lt;/p>
&lt;p>rm -f /etc/localtime&lt;/p>
&lt;p>ln -s /usr/share/zoneinfo/Asia/Shanghai /etc/localtime&lt;/p>
&lt;p>修改为中国的东八区&lt;/p>
&lt;h1 id="vi-etcsysconfigclock">vi /etc/sysconfig/clock&lt;/h1>
&lt;p>ZONE=&amp;ldquo;Asia/Shanghai&amp;rdquo;&lt;/p>
&lt;p>UTC=false&lt;/p>
&lt;p>ARC=false&lt;/p>
&lt;p>同步 BIOS 时钟，强制把系统时间写入 CMOS：&lt;/p>
&lt;h1 id="clock--w">clock -w&lt;/h1>
&lt;p>三、实现 Internet 时间同步（这里可以忽略上面两步）&lt;/p>
&lt;p>方法 1. 开机的时候自动网络校时：&lt;/p>
&lt;p>vi /etc/rc.d/rc.local&lt;/p>
&lt;p>/usr/sbin/ntpdate -u 192.168.0.2 192.168.0.3 192.168.0.4; /sbin/hwclock -w&lt;/p>
&lt;p>方法 2. 设定计划任务&lt;/p>
&lt;p>crontab 格式如下：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># For details see man 4 crontabs&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># Example of job definition:&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># .---------------- minute (0 - 59)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># | .------------- hour (0 - 23)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># | | .---------- day of month (1 - 31)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># | | | .------- month (1 - 12) OR jan,feb,mar,apr ...&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># | | | | .---- day of week (0 - 6) (Sunday=0 or 7) OR sun,mon,tue,wed,thu,fri,sat&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># | | | | |&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># \* \* \* \* \* command to be executed&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>设定 crontab 计划任务也有两种方式：&lt;/p>
&lt;p>1、写在/etc/crontab 里&lt;/p>
&lt;p>代码:&lt;/p>
&lt;p>00 11 * * * root ntpdate 210.72.145.44&lt;/p>
&lt;p>每天 11 点与中国国家授时中心同步时间&lt;/p>
&lt;p>每天 11 点与中国国家授时中心同步时间&lt;/p>
&lt;p>当然前提是&lt;/p>
&lt;p>apt-get install ntpdate&lt;/p>
&lt;p>代码也可是&lt;/p>
&lt;p>00 11 * * * root ntpdate us.pool.ntp.org&lt;/p>
&lt;p>2、使用命令 crontab -e&lt;/p>
&lt;p>crontab -e&lt;/p>
&lt;p>10 5 * * * root ntpdate us.pool.ntp.org;hwclock -w&lt;/p>
&lt;p>这样每天 5:10 自动进行网络校时，并同时更新 BIOS 的时间&lt;/p>
&lt;p>################################&lt;/p>
&lt;p>同步网络时间：输入 ntpdate time.nist.gov 同步网络时间&lt;/p>
&lt;p>[root@localhost ~]# ntpdate time.nist.gov&lt;/p>
&lt;p>12 Oct 17:25:01 ntpdate[2784]: step time server 132.163.4.103 offset 1147751.472254 sec&lt;/p>
&lt;p>## 出现以上信息说明同步成功 ##&lt;/p>
&lt;p>注：如提示命令不存在，直接输入：yum install ntp -y 安装 ntp 软件包&lt;/p></description></item><item><title>Docs: Account Manager(账户管理)</title><link>https://desistdaydream.github.io/docs/IT%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/5.%E7%99%BB%E5%BD%95-Linux-%E4%B8%8E-%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6/Account-Manager%E8%B4%A6%E6%88%B7%E7%AE%A1%E7%90%86/Account-Manager%E8%B4%A6%E6%88%B7%E7%AE%A1%E7%90%86/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/IT%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/5.%E7%99%BB%E5%BD%95-Linux-%E4%B8%8E-%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6/Account-Manager%E8%B4%A6%E6%88%B7%E7%AE%A1%E7%90%86/Account-Manager%E8%B4%A6%E6%88%B7%E7%AE%A1%E7%90%86/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/7/html/system_administrators_guide/ch-getting_started#sec-Managing_User_Accounts">红帽官方文档,RedHat7-管理用户账户的基础知识&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/7/html/system_administrators_guide/ch-managing_users_and_groups">红帽官方文档,RedHat7-系统管理员指南-第四章-管理用户和组&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/7/html/security_guide/index">红帽官方文档,RedHat7-安全指南&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>Linux 操作系统是一个多用户操作系统，所以除了 &lt;strong>Terminal(终端)&lt;/strong> 以外，还需 &lt;strong>Account(账户)&lt;/strong> 才可以登录上去，Linux 操作系统允许多个用户访问安装在一台机器上的单个系统。每个 User(用户) 都在自己的 Account(账户) 下操作。因此，Account Manager 代表了 Linux 系统管理的核心要素。&lt;/p>
&lt;blockquote>
&lt;p>User 与 Account 傻傻分不清楚，在 Linux 操作系统中，通常都会将 Account 称为 User，但是，这个称呼实际上并不准确。因为一个 User，比如 root，可以被多个现实世界中多个人使用，那么 root 这个 User 就会对应多个真实的 User~这种描述是非常矛盾的~~~~
只不过，随着时间的推移，人们慢慢叫习惯了，各种文档和源码也都一直使用 UID 这种名称，也就不再特别区分 Account 和 User 了。只需要知道，UID 更准确的描述应该是 AID。&lt;/p>
&lt;/blockquote>
&lt;p>同时，一个 Linux Account 也可以不代表一个真实的 User，这样的 Account 只被应用程序使用，一个应用程序使用某个 Account 运行，以便让系统更方便得对程序进行精细化控制。这种控制方式称为 &lt;strong>Access Control(访问控制)&lt;/strong>，所以，从这种角度看，Account 也可以称为 &lt;strong>Role(角色)&lt;/strong>，详见 [访问控制](/docs/IT学习笔记/1.操作系统/5.登录%20Linux%20 与%20 访问控制/Access%20Control(访问控制).md Control(访问控制).md) 章节。&lt;/p>
&lt;p>为了方便得对多个 Account 管理，可以将多个 Account 组合起来，称为 &lt;strong>Group(组)&lt;/strong>，一个 Group 就是一个或多个 Account 的集合。&lt;/p>
&lt;p>通常，Linux 将账户分为两类&lt;/p>
&lt;ul>
&lt;li>Normal Accounts(普通账户)&lt;/li>
&lt;li>System Accounts(系统账户)&lt;/li>
&lt;/ul>
&lt;p>每个账户都有一个对应的 UID 作为其唯一标识符(纯数字)。同样，每个组也有一个对应的 GID 作为其唯一标识符(纯数字)。通常来说：&lt;/p>
&lt;ul>
&lt;li>1000 以下是系统账户与保留账户 和 系统组与保留组&lt;/li>
&lt;li>1000 以上是普通账户和组&lt;/li>
&lt;/ul>
&lt;p>每当我们使用 useradd 命令新建一个普通用户时，用户的 UID 都是 1000 之后的数字，这种行为可以通过修改 /etc/login.defs 文件中的 UID_MIN、GID_MIN 等参数来改变。&lt;/p>
&lt;h2 id="password密码">Password(密码)&lt;/h2>
&lt;p>&lt;strong>Password(密码)&lt;/strong> 是用来验证用户身份的最主要方法。当用户使用一个账户登录 Linux 操作系统时，密码是用来证明账户属于该用户的一种非常高效的方式。&lt;/p>
&lt;p>Linux 系统使用 **Secure Hash Algorithm 512(SHA512)**和 &lt;strong>shadow passwords&lt;/strong>。默认情况下，账户信息保存在 /etc/passwd 文件中，对应的密码信息经过哈希后保存在 /etc/shadow 文件中。&lt;/p>
&lt;h1 id="关联文件">关联文件&lt;/h1>
&lt;p>&lt;strong>/etc/group&lt;/strong> # 账户组信息
&lt;strong>/etc/passwd&lt;/strong> # 账户信息
&lt;strong>/etc/shadow&lt;/strong> # 安全账户信息
&lt;strong>/etc/login.defs&lt;/strong> # login 工具包中的配置文件，部分账户管理工具会读取该文件中的参数
&lt;strong>/etc/pam.d/&lt;/strong> #&lt;/p>
&lt;ul>
&lt;li>./chfn&lt;/li>
&lt;li>./chpasswd&lt;/li>
&lt;li>./chsh&lt;/li>
&lt;li>./newusers&lt;/li>
&lt;li>./passwd&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>/etc/skel/&lt;/strong> # 该目录为账户目录模板。该目录下包含多个隐藏的文件，当创建用户时，会拷贝该目录下的所有文件到所创建用户的家目录中
&lt;strong>/home/AccountName/&lt;/strong> # UserName 为该账户同名的家目录
&lt;strong>/var/spool/mail/AccountName&lt;/strong># 该文件为该账户的邮件池
注意：&lt;/p>
&lt;ul>
&lt;li>若 /etc/shadow 被 selinux 所管理，有的时候密码修改将会失败，报错 &lt;code>passwd: Authentication token manipulation error&lt;/code>&lt;/li>
&lt;/ul>
&lt;h1 id="账户管理工具">账户管理工具&lt;/h1>
&lt;p>Linux 系统的账户管理功能，通常由 &lt;strong>shadow-utils 包&lt;/strong> 或 &lt;strong>passwd 包&lt;/strong> 中的各种工具和库提供。&lt;/p>
&lt;blockquote>
&lt;p>在有的发行版中(比如 CentOS)，只会将 passwd 包中的 passwd 程序保留，而将其余的程序，放在名为 &lt;strong>shadow-utils&lt;/strong> 的包中。&lt;/p>
&lt;/blockquote>
&lt;p>不同的 Linux 发型，还会用到某些个别的包与主包配合提供完整的账户管理功能：&lt;/p>
&lt;ul>
&lt;li>&lt;strong>base-passwd&lt;/strong> # 这是 Ubuntu 发型版中独有的包。这个包中包含一个 &lt;code>update-passwd&lt;/code> 的程序，将会根据 /var/lib/dpkg/info/base-passwd.preinst 脚本生成 /etc/passwd 和 /etc/group 文件
&lt;ul>
&lt;li>参考：&lt;a href="https://unix.stackexchange.com/questions/470126/how-is-the-etc-passwd-file-instantiated">https://unix.stackexchange.com/questions/470126/how-is-the-etc-passwd-file-instantiated&lt;/a>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>setup&lt;/strong> # 这是 CentOS 发行版中独有的包。包含了一组重要的系统配置文件和安装文件，例如 /etc/passwd、/etc/group、/etc/shadow、/etc/profile 等等&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/oib9pm/1635476577308-bd0e79ab-ffc9-41f8-ba65-471f0a3e2918.png" alt="image.png">&lt;/p>
&lt;h2 id="useradd--添加用户">useradd # 添加用户&lt;/h2>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://man7.org/linux/man-pages/man8/useradd.8.html">Manual(手册),useradd(8)&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>useradd 程序在添加用户时，会读取 /etc/login.defs 文件中的 PASS_MAX_DAYS、PASS_MIN_DAYS、PASS_WARN_AGE 等参数，并将参数的值写入到 /etc/shadow 文件中的对应字段&lt;/p>
&lt;h3 id="syntax语法">Syntax(语法)&lt;/h3>
&lt;p>&lt;strong>useradd [OPTIONS] NAME&lt;/strong>&lt;/p>
&lt;p>OPTIONS：&lt;/p>
&lt;ul>
&lt;li>&lt;strong>-m&lt;/strong> # 自动建立用户的登入目录。&lt;/li>
&lt;li>&lt;strong>-u&lt;/strong> # 指定用户 ID 号。该值在系统中必须是唯一的。0~499 默认是保留给系统用户账号使用的，所以该值必须大于 499。&lt;/li>
&lt;li>&lt;strong>-g GID&lt;/strong> # 指定该用户的基本组 ID&lt;/li>
&lt;li>&lt;strong>-c&lt;/strong> # 加上备注文字，备注文字保存在 passwd 的备注栏中。&lt;/li>
&lt;li>-&lt;strong>d&lt;/strong> # 指定该用户的家目录，默认为 /home 目录下的与用户名同名的文件夹&lt;/li>
&lt;li>&lt;strong>-e&lt;/strong> # 指定账号的失效日期，日期格式为 MM/DD/YY，例如 06/30/12。缺省表示永久有效。&lt;/li>
&lt;li>-f # 指定在密码过期后多少天即关闭该账号。如果为 0 账号立即被停用；如果为-1 则账号一直可用。默认值为-1.&lt;/li>
&lt;li>&lt;strong>-G, &amp;ndash;groups &amp;lt;GROUPS&amp;gt;&lt;/strong> # 指定用户所属的附加群组。&lt;/li>
&lt;li>-l # 不要把用户添加到 lastlog 和 failog 中, 这个用户的登录记录不需要记载&lt;/li>
&lt;li>-M # 不要自动建立用户的登入目录。&lt;/li>
&lt;li>-n # 取消建立以用户名称为名的群组。&lt;/li>
&lt;li>-p # PASSWORD 指定新用户的密码&lt;/li>
&lt;li>-r # 建立一个系统帐号&lt;/li>
&lt;li>-s # 指定用户登入后所使用的 shell。默认值为/bin/bash。&lt;/li>
&lt;/ul>
&lt;p>EXAMPLE：&lt;/p>
&lt;ul>
&lt;li>创建一个名为 lichenhao 的用户，并设置该用户密码为 lch@password
&lt;ul>
&lt;li>useradd -m lichenhao &amp;amp;&amp;amp; echo &amp;rsquo;lch@password&amp;rsquo; | passwd lichenhao &amp;ndash;stdin&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>新增一个用户 user，并指定用户组 ftp
&lt;ul>
&lt;li>useradd -g ftp user&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>新增一个用户：user 并指定家目录为/mnt/bak/。如果没有此目录，则报错，就需要手动创建目录
&lt;ul>
&lt;li>useradd -d /mnt/back/ user&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>新增一个用户：user 并设置密码为 123456
&lt;ul>
&lt;li>useradd -p 123456 user&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>新增一个 FTP 用户：ftp2018 （无需登录系统）
&lt;ul>
&lt;li>useradd -g ftp -s /sbin/nologin ftp2018&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h2 id="userdel--删除用户">userdel # 删除用户&lt;/h2>
&lt;h3 id="syntax语法-1">Syntax(语法)&lt;/h3>
&lt;p>&lt;strong>userdel [OPTIONS] NAME&lt;/strong>&lt;/p>
&lt;p>OPTIONS：&lt;/p>
&lt;ul>
&lt;li>&lt;strong>-f, &amp;ndash;force&lt;/strong> # 强制删除&lt;/li>
&lt;li>&lt;strong>-r, &amp;ndash;remove&lt;/strong> # 删除用户的时候同时移除该用户的家目录和邮件池。不加参数的话，只会删除用户，但是不会删除在/home 目录中的用户家目录。如果你想要连此用户的家目录也一并删除，可以加上 –remove-home 这个参数&lt;/li>
&lt;li>-&lt;strong>R, &amp;ndash;root CHROOT_DIR&lt;/strong> # chroot 到的目录&lt;/li>
&lt;li>&lt;strong>-Z, &amp;ndash;selinux-user&lt;/strong> # 为用户删除所有的 SELinux 用户映射&lt;/li>
&lt;/ul>
&lt;p>EXAMPLE&lt;/p>
&lt;ul>
&lt;li>userdel -r user # 删除名为 user 的用户，同时删除该用户的家目录和邮件池文件&lt;/li>
&lt;/ul>
&lt;h2 id="usermod--修改用户">usermod # 修改用户&lt;/h2>
&lt;h3 id="syntax语法-2">Syntax(语法)&lt;/h3>
&lt;p>&lt;strong>usermod [OPTIONS] NAME&lt;/strong>&lt;/p>
&lt;p>OPTIONS：&lt;/p>
&lt;ul>
&lt;li>&lt;strong>-a, &amp;ndash;append GROUP&lt;/strong> # 将用户追加至上边 -G 中指定附加组中，并不从其它组中删除此用户&lt;/li>
&lt;li>&lt;strong>-c, &amp;ndash;comment &amp;lt;STRING&amp;gt;&lt;/strong> # GECOS 字段的新值&lt;/li>
&lt;li>&lt;strong>-d, &amp;ndash;home &amp;lt;HOME_DIR&amp;gt;&lt;/strong> # 用户的新主目录&lt;/li>
&lt;li>&lt;strong>-e, &amp;ndash;expiredate &amp;lt;EXPIRE_DATE&amp;gt;&lt;/strong> # 设定帐户过期的日期为 EXPIRE_DATE&lt;/li>
&lt;li>&lt;strong>-f, &amp;ndash;inactive INACTIVE&lt;/strong> # 过期 INACTIVE 天数后，设定密码为失效状态&lt;/li>
&lt;li>&lt;strong>-g, &amp;ndash;gid GROUP&lt;/strong> # 强制使用 GROUP 为新主组&lt;/li>
&lt;li>&lt;strong>-G, &amp;ndash;groups GROUPS&lt;/strong> # 新的附加组列表 GROUPS。将用户从该选项指定的组列表以外的组中删除。可以与 -a 选项配合，变更此行为。-a 会将用户附加到指定的组中而不删除。&lt;/li>
&lt;li>&lt;strong>-l, &amp;ndash;login LOGIN&lt;/strong> # 新的登录名称&lt;/li>
&lt;li>&lt;strong>-L, &amp;ndash;lock&lt;/strong> # 锁定用户帐号&lt;/li>
&lt;li>&lt;strong>-m, &amp;ndash;move-home&lt;/strong> # 将家目录内容移至新位置 (仅于 -d 一起使用)&lt;/li>
&lt;li>&lt;strong>-o, &amp;ndash;non-unique&lt;/strong> # 允许使用重复的(非唯一的) UID&lt;/li>
&lt;li>&lt;strong>-p, &amp;ndash;password PASSWORD&lt;/strong> # 将加密过的密码 (PASSWORD) 设为新密码&lt;/li>
&lt;li>-&lt;strong>R, &amp;ndash;root CHROOT_DIR&lt;/strong> # chroot 到的目录&lt;/li>
&lt;li>&lt;strong>-s, &amp;ndash;shell SHELL&lt;/strong> # 该用户帐号的新登录 shell&lt;/li>
&lt;li>&lt;strong>-u, &amp;ndash;uid UID&lt;/strong> # 用户帐号的新 UID&lt;/li>
&lt;li>&lt;strong>-U, &amp;ndash;unlock&lt;/strong> # 解锁用户帐号&lt;/li>
&lt;li>&lt;strong>-Z, &amp;ndash;selinux-user SEUSER&lt;/strong> # 用户账户的新 SELinux 用户映射&lt;/li>
&lt;/ul>
&lt;p>EXAMPLE&lt;/p>
&lt;ul>
&lt;li>修改 newname 用户所在群组为 test
&lt;ul>
&lt;li>usermod -g test newname&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>一次将一个用户添加到多个群组
&lt;ul>
&lt;li>usermod -G friends,happy,funny newname&lt;/li>
&lt;li>注意：使用 usermod 时要小心，因为配合-g 或-G 参数时，它会把用户从原先的群组里剔除，加入到新的群组。如果你不想离开原先的群组，又想加入新的群组，可以在-G 参数的基础上加上-a 参数，a 是英语 append 的缩写，表示“追加”。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>-a 追加用户到新的用户组，保留原来的组
&lt;ul>
&lt;li>usermod -aG happy newname&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h2 id="groupaddgroupdelgroupmodgpasswd--用户组管理相关命令">groupadd、groupdel、groupmod、gpasswd # 用户组管理相关命令&lt;/h2>
&lt;p>OPTIONS：&lt;/p>
&lt;ul>
&lt;li>-f, &amp;ndash;force 如果组已经存在则成功退出，并且如果 GID 已经存在则取消 -g&lt;/li>
&lt;li>-g, &amp;ndash;gid GID # 为新组使用 GID&lt;/li>
&lt;li>-K, &amp;ndash;key KEY=VALUE # 不使用 /etc/login.defs 中的默认值&lt;/li>
&lt;li>-o, &amp;ndash;non-unique # 允许创建有重复 GID 的组&lt;/li>
&lt;li>-p, &amp;ndash;password PASSWORD # 为新组使用此加密过的密码&lt;/li>
&lt;li>-r, &amp;ndash;system # 创建一个系统账户&lt;/li>
&lt;li>-R, &amp;ndash;root CHROOT_DIR # chroot 到的目录&lt;/li>
&lt;/ul>
&lt;p>EXAMPLE&lt;/p>
&lt;ul>
&lt;li>创建一个名为 newname 的组
&lt;ul>
&lt;li>groupadd newname&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>修改组
&lt;ul>
&lt;li>groupmod -n test2group testgroup&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>删除名为 test2group 的组
&lt;ul>
&lt;li>groupdel test2group&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>查看当前登陆用户所在的组
&lt;ul>
&lt;li>groups&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>查看 testnewuser 所在的组
&lt;ul>
&lt;li>groups testnewuser&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h2 id="who--显示当前登录用户的相关信息">who # 显示当前登录用户的相关信息&lt;/h2>
&lt;h3 id="syntax语法-3">Syntax(语法)&lt;/h3>
&lt;p>&lt;strong>who [OPTION]&amp;hellip; [ FILE | ARG1 ARG2 ]&lt;/strong>&lt;/p>
&lt;p>OPTIONS&lt;/p>
&lt;ul>
&lt;li>-a 打印能打印的全部&lt;/li>
&lt;li>-d 打印死掉的进程&lt;/li>
&lt;li>-m 同 am i,mom likes&lt;/li>
&lt;li>-q 打印当前登录用户数及用户名&lt;/li>
&lt;li>-u 打印当前登录用户登录信息&lt;/li>
&lt;li>-r 打印运行等级&lt;/li>
&lt;/ul>
&lt;p>EXAMPLE&lt;/p>
&lt;ul>
&lt;li>whoami # 要查看当前登录用户的用户名&lt;/li>
&lt;li>who am i # 表示打开当前伪终端的用户的用户名，可以简写为 who&lt;/li>
&lt;/ul>
&lt;p>who&lt;/p>
&lt;h1 id="密码管理工具">密码管理工具&lt;/h1>
&lt;h2 id="passwd--改变用户的密码">passwd # 改变用户的密码&lt;/h2>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://man7.org/linux/man-pages/man1/passwd.1.html">Manual(手册),passwd(1)&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;h3 id="syntax语法-4">Syntax(语法)&lt;/h3>
&lt;h2 id="chage--控制用户的密码到期信息">chage # 控制用户的密码到期信息&lt;/h2>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://man7.org/linux/man-pages/man1/chage.1.html">Manual(手册),chage(1)&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>passwd 软件包将会记录用户上次更改密码的时间、应该间隔多久更改一次密码 等等，chage 工具就可以对上述信息进行管理&lt;/p>
&lt;p>&lt;code>chage&lt;/code> 工具仅控制 /etc/shadow 文件中的信息，/etc/passwd 文件并不会影响到 &lt;code>chage&lt;/code> 程序的实现。并且，&lt;code>chage&lt;/code> 程序也不会报告 /etc/passwd 和 /etc/shaodw 文件的不一致情况，&lt;code>pwck&lt;/code> 工具可用于检测两个文件的不一致处。&lt;/p>
&lt;p>&lt;code>chage&lt;/code> 工具仅限于 root 用户，但是 -l 选项除外，非特权用户可以使用 -l 选项来确定自身的密码或账户合适到期。chage 可以修改 /etc/shadow 文件中多个字段的配置。&lt;/p>
&lt;h3 id="syntax语法-5">Syntax(语法)&lt;/h3>
&lt;p>&lt;strong>chage [OPTIONS] LOGIN&lt;/strong>&lt;/p>
&lt;p>&lt;strong>OPTIONS&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>&lt;strong>-d, &amp;ndash;lastday &amp;lt;INT&amp;gt;&lt;/strong> # 设置上次更改密码的日期。值是从 1970 年 1 月 1 日开始到某年某月某日的天数。
&lt;ul>
&lt;li>若指定空值，则表示从没修改过密码，即 -l 选项查看的第一行的值为 never。&lt;/li>
&lt;li>若指定 0，则用户再次登录时，则会被强制要求立刻修改密码，否则无法登录&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>-l, &amp;ndash;list&lt;/strong> # 显示账户的老化信息&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">[&lt;/span>root@hw-cloud-xngy-jump-server-linux-2 ~&lt;span style="color:#f92672">]&lt;/span>&lt;span style="color:#75715e"># chage -l root&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Last password change : Oct 01, &lt;span style="color:#ae81ff">2021&lt;/span> &lt;span style="color:#75715e"># 最后一次修改密码的时间&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Password expires : never
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Password inactive : never
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Account expires : never
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Minimum number of days between password change : &lt;span style="color:#ae81ff">0&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Maximum number of days between password change : &lt;span style="color:#ae81ff">99999&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Number of days of warning before password expires : &lt;span style="color:#ae81ff">7&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ul>
&lt;li>&lt;strong>-m, &amp;ndash;mindays &amp;lt;INT&amp;gt;&lt;/strong> # 密码可以修改的最小间隔天数。如果 INT 为 0，则表示不用等待，任何时候都可以修改密码
&lt;ul>
&lt;li>对应 shadow 文件中的第 4 个字段 minimum password age&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>-M, &amp;ndash;maxdays &amp;lt;INT&amp;gt;&lt;/strong> #
&lt;ul>
&lt;li>对应 shadow 文件中的第 5 个字段 maximum password age&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>-W, &amp;ndash;warndays &amp;lt;INT&amp;gt;&lt;/strong> #
&lt;ul>
&lt;li>对应 shadow 文件中的第 6 个字段 password warning period&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h2 id="pwck">pwck&lt;/h2></description></item><item><title>Docs: Alertmanager</title><link>https://desistdaydream.github.io/docs/IT%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/6.%E5%8F%AF%E8%A7%82%E6%B5%8B%E6%80%A7/%E7%9B%91%E6%8E%A7%E7%B3%BB%E7%BB%9F/Alertmanager/Alertmanager/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/IT%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/6.%E5%8F%AF%E8%A7%82%E6%B5%8B%E6%80%A7/%E7%9B%91%E6%8E%A7%E7%B3%BB%E7%BB%9F/Alertmanager/Alertmanager/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://prometheus.io/docs/alerting/latest/alertmanager/">官方文档&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>Prometheus Alert 介绍详见 Prometheus Server Alert 说明&lt;/p>
&lt;p>Alertmanager 处理由客户端应用程序（例如 Prometheus 服务器）发送的警报。它负责将重复数据删除，分组和路由到正确的接收者集成，例如电子邮件，PagerDuty 或 OpsGenie。它还负责沉默和禁止警报。&lt;/p>
&lt;p>&lt;strong>Alertmanager 特性&lt;/strong>&lt;/p>
&lt;p>Prometheus 发送过来的每一个告警，都会由 Alertmanager 进行重复数据删除、分组、路由到正确的接收者(e.g.邮件、钉钉等)上。&lt;/p>
&lt;p>Alertmanager 除了提供基本的告警通知能力以外，还主要提供了如：分组、抑制以及静默等告警特性：
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/fesx4v/1616068406984-251af31d-3e59-4621-bb62-d5228da42408.jpeg" alt="">
&lt;strong>分组&lt;/strong>
分组机制可以将详细的告警信息合并成一个通知。在某些情况下，比如由于系统宕机导致大量的告警被同时触发，在这种情况下分组机制可以将这些被触发的告警合并为一个告警通知，避免一次性接受大量的告警通知，而无法对问题进行快速定位。&lt;/p>
&lt;p>例如，当集群中有数百个正在运行的服务实例，并且为每一个实例设置了告警规则。假如此时发生了网络故障，可能导致大量的服务实例无法连接到数据库，结果就会有数百个告警被发送到 Alertmanager。&lt;/p>
&lt;p>而作为用户，可能只希望能够在一个通知中中就能查看哪些服务实例收到影响。这时可以按照服务所在集群或者告警名称对告警进行分组，而将这些告警内聚在一起成为一个通知。&lt;/p>
&lt;p>告警分组，告警时间，以及告警的接受方式可以通过 Alertmanager 的配置文件进行配置。&lt;/p>
&lt;p>&lt;strong>抑制&lt;/strong>
抑制是指当某一告警发出后，可以停止重复发送由此告警引发的其它告警的机制。&lt;/p>
&lt;p>例如，当集群不可访问时触发了一次告警，通过配置 Alertmanager 可以忽略与该集群有关的其它所有告警。这样可以避免接收到大量与实际问题无关的告警通知。&lt;/p>
&lt;p>抑制机制同样通过 Alertmanager 的配置文件进行设置。&lt;/p>
&lt;p>&lt;strong>静默&lt;/strong>
静默提供了一个简单的机制可以快速根据标签对告警进行静默处理。如果接收到的告警符合静默的配置，Alertmanager 则不会发送告警通知。&lt;/p>
&lt;p>静默设置需要在 Alertmanager 的 Werb 页面上进行设置。&lt;/p>
&lt;h2 id="alertmanager-告警分组">Alertmanager 告警分组&lt;/h2>
&lt;p>每一个告警进入 Alertmanager 后，都会进行分组处理，可以根据规则将多条告警合并为一个通知。这是为了可以让相关的告警可以合并在一起，一次性收集和发送，以便运维人员的故障排查。&lt;/p>
&lt;h2 id="alertmanager-告警路由">Alertmanager 告警路由&lt;/h2>
&lt;p>告警路由，顾名思义，路由就是根据“目的接收者”将每个告警发送到指定的接收者上的过程。&lt;/p>
&lt;p>每一个告警进入到 Alertmanager 都会由顶级的 route 进入路由树，需要注意的是顶级的 route 必须匹配所有告警(即不能有任何的匹配设置 match 和 match_re)，在一个路由树中，将每个被路由的目标称为 &lt;strong>Node(节点)。&lt;/strong>&lt;/p>
&lt;p>每一个路由都可以定义自己的接受人以及匹配规则。默认情况下，告警进入到顶级 route 后会遍历所有的子节点，直到找到最深的匹配 route，并将告警发送到该 route 定义的 receiver 中。但如果 route 中设置 continue 的值为 false，那么告警在匹配到第一个子节点之后就直接停止。如果 continue 为 true，报警则会继续进行后续子节点的匹配。如果当前告警匹配不到任何的子节点，那该告警将会基于当前路由节点的接收器配置方式进行处理。&lt;/p>
&lt;p>其中告警的匹配有两种方式可以选择。一种方式基于字符串验证，通过设置 match 规则判断当前告警中是否存在标签 labelname 并且其值等于 labelvalue。第二种方式则基于正则表达式，通过设置 match_re 验证当前告警标签的值是否满足正则表达式的内容。&lt;/p>
&lt;p>如果警报已经成功发送通知, 如果想设置发送告警通知之前要等待时间，则可以通过 repeat_interval 参数进行设置。&lt;/p>
&lt;h2 id="alertmanager-告警模板">Alertmanager 告警模板&lt;/h2>
&lt;p>告警模板的使用方式详见：告警模板详解&lt;/p>
&lt;p>默认情况下 Alertmanager 使用了系统自带的默认通知模板，模板源码可以从 &lt;a href="https://github.com/prometheus/alertmanager/blob/master/template/default.tmpl">https://github.com/prometheus/alertmanager/blob/master/template/default.tmpl&lt;/a> 获得。Alertmanager 的通知模板基于 Go 的模板系统。Alertmanager 也支持用户定义和使用自己的模板，一般来说有两种方式可以选择。&lt;/p>
&lt;p>第一种，基于模板字符串。用户可以直接在 Alertmanager 的配置文件中使用模板字符串，例如:&lt;/p>
&lt;pre>&lt;code>receivers:
- name: 'slack-notifications'
slack_configs:
- channel: '#alerts'
text: 'https://internal.myorg.net/wiki/alerts/{{ .GroupLabels.app }}/{{ .GroupLabels.alertname }}'
&lt;/code>&lt;/pre>
&lt;p>第二种方式，自定义可复用的模板文件。例如，可以创建自定义模板文件 custom-template.tmpl，如下所示：&lt;/p>
&lt;pre>&lt;code>{{ define &amp;quot;slack.myorg.text&amp;quot; }}https://internal.myorg.net/wiki/alerts/{{ .GroupLabels.app }}/{{ .GroupLabels.alertname }}{{ end}}
&lt;/code>&lt;/pre>
&lt;p>通过在 Alertmanager 的全局设置中定义 templates 配置来指定自定义模板的访问路径:&lt;/p>
&lt;pre>&lt;code># Files from which custom notification template definitions are read.
# The last component may use a wildcard matcher, e.g. 'templates/*.tmpl'.
templates:
[ - &amp;lt;filepath&amp;gt; ... ]
&lt;/code>&lt;/pre>
&lt;p>在设置了自定义模板的访问路径后，用户则可以直接在配置中使用该模板：&lt;/p>
&lt;pre>&lt;code>receivers:
- name: 'slack-notifications'
slack_configs:
- channel: '#alerts'
text: '{{ template &amp;quot;slack.myorg.text&amp;quot; . }}'
templates:
- '/etc/alertmanager/templates/myorg.tmpl'
&lt;/code>&lt;/pre>
&lt;h1 id="alertmanager-部署">Alertmanager 部署&lt;/h1>
&lt;p>与 prometheus 一样，可以通过二进制安装或者 docker 启动&lt;/p>
&lt;h2 id="使用-docker-的方式运行-alertmanager">使用 docker 的方式运行 Alertmanager&lt;/h2>
&lt;p>获取配置文件&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>mkdir -p /etc/monitoring
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>docker run -d --name alertmanager --rm prom/alertmanager
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>docker cp alertmanager:/etc/alertmanager /etc/monitoring
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>docker stop alertmanager
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>运行 Alertmanager&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>docker run -d --name alertmanager &lt;span style="color:#ae81ff">\
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">&lt;/span> --network host &lt;span style="color:#ae81ff">\
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">&lt;/span> -v /etc/localtime:/etc/localtime &lt;span style="color:#ae81ff">\
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">&lt;/span> -v /etc/monitoring/alertmanager:/etc/alertmanager/config_out &lt;span style="color:#ae81ff">\
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">&lt;/span> prom/alertmanager &lt;span style="color:#ae81ff">\
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">&lt;/span> --config.file&lt;span style="color:#f92672">=&lt;/span>/etc/alertmanager/config_out/alertmanager.yml
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>部署完成后，Alertmanager 默认监听在 9093 端口上，通过浏览器打开 http://localhost:9093 可以看到如下示例的画面
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/fesx4v/1616068406956-f10fe3df-d57f-4602-a6ab-e4aab90c89f1.jpeg" alt="">
首页 Alerts 标签上显示了从 Prometheus Server 推送过来的每一条告警，可以通过点击告警信息中的 Silence 来让该告警静音(i.e.不再发送告警邮件)&lt;/p>
&lt;h2 id="alertmanager-运行时的标志flags说明">Alertmanager 运行时的标志(Flags)说明&lt;/h2>
&lt;p>alertmanager 程序在启动时，可以使用一些标志来对程序进行一些基本设定，比如数据存储路径、存储时间等等&lt;/p>
&lt;ul>
&lt;li>&lt;strong>&amp;ndash;config.file=&amp;quot;/PATH/TO/FILE&amp;quot;&lt;/strong># 指定 alertmanager 基本配置文件。 默认 /etc/alertmanager/alertmanager.yml&lt;/li>
&lt;li>&lt;strong>&amp;ndash;storage.path=&amp;quot;/PATH&amp;quot;&lt;/strong># 指定存储数据的基础路径。该路径包括告警信息、已经 silences 的告警等信息。&lt;/li>
&lt;li>&lt;strong>&amp;ndash;data.retention=120h&lt;/strong> # 数据保存时长。&lt;/li>
&lt;li>&amp;ndash;alerts.gc-interval=30m # Interval between alert GC.&lt;/li>
&lt;li>&amp;ndash;web.external-url=WEB.EXTERNAL-URL zThe URL under which Alertmanager is externally reachable (for example, if Alertmanager is served via a reverse proxy). Used for generating relative and absolute links back to Alertmanagerzitself. If the URL has a path portion, it will be used to prefix all HTTP endpoints served by Alertmanager. If omitted, relevant URL components will be derived automatically.&lt;/li>
&lt;li>&amp;ndash;web.route-prefix=WEB.ROUTE-PREFIX zPrefix for the internal routes of web endpoints. Defaults to path of &amp;ndash;web.external-url.&lt;/li>
&lt;li>&amp;ndash;web.listen-address=&amp;quot;:9093&amp;quot; zAddress to listen on for the web interface and API.&lt;/li>
&lt;li>&amp;ndash;web.get-concurrency=0 Maximum number of GET requests processed concurrently. If negative or zero, the limit is GOMAXPROC or 8, whichever is larger.&lt;/li>
&lt;li>&amp;ndash;web.timeout=0 Timeout for HTTP requests. If negative or zero, no timeout is set.&lt;/li>
&lt;li>&amp;ndash;cluster.listen-address=&amp;ldquo;0.0.0.0:9094&amp;rdquo; zListen address for cluster. Set to empty string to disable HA mode.&lt;/li>
&lt;li>&amp;ndash;cluster.advertise-address=CLUSTER.ADVERTISE-ADDRESS zExplicit address to advertise in cluster.&lt;/li>
&lt;li>&amp;ndash;cluster.peer=CLUSTER.PEER &amp;hellip; zInitial peers (may be repeated).&lt;/li>
&lt;li>&amp;ndash;cluster.peer-timeout=15s zTime to wait between peers to send notifications.&lt;/li>
&lt;li>&amp;ndash;cluster.gossip-interval=200ms zInterval between sending gossip messages. By lowering this value (more frequent) gossip messages are propagated across the cluster more quickly at the expense of increased bandwidth.&lt;/li>
&lt;li>&amp;ndash;cluster.pushpull-interval=1m0s zInterval for gossip state syncs. Setting this interval lower (more frequent) will increase convergence speeds across larger clusters at the expense of increased bandwidth usage.&lt;/li>
&lt;li>&amp;ndash;cluster.tcp-timeout=10s Timeout for establishing a stream connection with a remote node for a full state sync, and for stream read and write operations.&lt;/li>
&lt;li>&amp;ndash;cluster.probe-timeout=500ms zTimeout to wait for an ack from a probed node before assuming it is unhealthy. This should be set to 99-percentile of RTT (round-trip time) on your network.&lt;/li>
&lt;li>&amp;ndash;cluster.probe-interval=1s zInterval between random node probes. Setting this lower (more frequent) will cause the cluster to detect failed nodes more quickly at the expense of increased bandwidth usage.&lt;/li>
&lt;li>&amp;ndash;cluster.settle-timeout=1m0s zMaximum time to wait for cluster connections to settle before evaluating notifications.&lt;/li>
&lt;li>&amp;ndash;cluster.reconnect-interval=10s zInterval between attempting to reconnect to lost peers.&lt;/li>
&lt;li>&amp;ndash;cluster.reconnect-timeout=6h0m0s zLength of time to attempt to reconnect to a lost peer.&lt;/li>
&lt;li>&amp;ndash;log.level=info Only log messages with the given severity or above. One of: [debug, info, warn, error]&lt;/li>
&lt;li>&amp;ndash;log.format=logfmt Output format of log messages. One of: [logfmt, json]&lt;/li>
&lt;li>&amp;ndash;version Show application version.&lt;/li>
&lt;/ul>
&lt;h1 id="alertmanager-配置">Alertmanager 配置&lt;/h1>
&lt;p>/etc/alertmanager/alertmanager.conf # alertmanager 基本配置文件默认位置。可以通过 &amp;ndash;config.file 标志指定其他配置文件&lt;/p>
&lt;p>下面是一个基本的 alertmanager.conf 配置文件示例：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-yaml" data-lang="yaml">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># 全局配置环境&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">global&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">resolve_timeout&lt;/span>: &lt;span style="color:#ae81ff">5m&lt;/span> &lt;span style="color:#75715e"># 该参数定义了当Alertmanager持续多长时间未接收到告警后标记告警状态为resolved（已解决）&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e"># 配置邮件发送信息&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">smtp_smarthost&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;smtp.163.com:25&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">smtp_from&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;ych_1024@163.com&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">smtp_auth_username&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;ych_1024@163.com&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">smtp_auth_password&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;&amp;lt;邮箱密码&amp;gt;&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">smtp_hello&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;163.com&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">smtp_require_tls&lt;/span>: &lt;span style="color:#66d9ef">false&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># 路由配置环境。所有报警信息进入后的根路由，用来设置报警的分发策略&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">route&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">group_by&lt;/span>: [&lt;span style="color:#e6db74">&amp;#34;alertname&amp;#34;&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;cluster&amp;#34;&lt;/span>] &lt;span style="color:#75715e"># 这里的标签列表是接收到报警信息后的重新分组标签，例如，接收到的报警信息里面有许多具有 cluster=A 和 alertname=LatncyHigh 这样的标签的报警信息将会批量被聚合到一个分组里面&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">group_wait&lt;/span>: &lt;span style="color:#ae81ff">TIME&lt;/span> &lt;span style="color:#75715e"># 当一个新的报警分组被创建后，需要等待至少TIME时间来初始化通知，这种方式可以确保您能有足够的时间为同一分组来获取多个警报，然后一起触发这个报警信息。&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">group_interval&lt;/span>: &lt;span style="color:#ae81ff">TIME&lt;/span> &lt;span style="color:#75715e"># 重复发送报警的设置(报警未消除的重复报警)。当一个组里的报警有变化时，等待&amp;#39;group_interval&amp;#39;时间来发送新的一组报警信息。默认5分钟。&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">repeat_interval&lt;/span>: &lt;span style="color:#ae81ff">TIME&lt;/span> &lt;span style="color:#75715e"># 重复发送报警的设置(报警未消除的重复报警)。一个组里的报警一直没有变化的话，等待&amp;#39;repeat_interval&amp;#39;时间来重新发送他们。默认4小时。&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">receiver&lt;/span>: &lt;span style="color:#ae81ff">STRING&lt;/span> &lt;span style="color:#75715e"># 指定默认的receiver名，如果一个报警没有任何一个routes匹配，则发送给默认的receiver&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">routes&lt;/span>: &lt;span style="color:#75715e"># 上面所有的配置参数都由所有子路由继承，并且可以在每个子路由上进行覆盖。&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#f92672">receiver&lt;/span>: &lt;span style="color:#ae81ff">STRING&lt;/span> &lt;span style="color:#75715e"># 指定该子路由要使用的receiver&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">group_wait&lt;/span>: &lt;span style="color:#ae81ff">TIME&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">match&lt;/span>: &lt;span style="color:#75715e"># 指定标签名和值，凡是具有该标签名和值的告警由将路由到指定的receiver上&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e"># 也可以使用 match_re 关键字，来进行正则表达式匹配。LabelValue 可以使用正则来表示&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">LabelName&lt;/span>: &lt;span style="color:#ae81ff">LabelValue&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># 接收者配置环境。用于定义分配好路由的告警信息将由谁来接收。&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">receivers&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#f92672">name&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;default&amp;#34;&lt;/span> &lt;span style="color:#75715e"># 指定receiver的名字&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">email_configs&lt;/span>: &lt;span style="color:#75715e"># 指定该receiver使用哪种配置&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#f92672">to&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;lichenhao@wisetv.com.cn&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">send_resolved&lt;/span>: &lt;span style="color:#66d9ef">true&lt;/span> &lt;span style="color:#75715e"># 指定是否发送告警已解决的信息。默认为false,i.e.不发送&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="配置样例">配置样例&lt;/h2>
&lt;h3 id="默认配置文件">默认配置文件&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-yaml" data-lang="yaml">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">global&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">resolve_timeout&lt;/span>: &lt;span style="color:#ae81ff">5m&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">route&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">group_by&lt;/span>: [&lt;span style="color:#e6db74">&amp;#34;alertname&amp;#34;&lt;/span>]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">group_wait&lt;/span>: &lt;span style="color:#ae81ff">10s&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">group_interval&lt;/span>: &lt;span style="color:#ae81ff">10s&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">repeat_interval&lt;/span>: &lt;span style="color:#ae81ff">1h&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">receiver&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;web.hook&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">receivers&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#f92672">name&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;web.hook&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">webhook_configs&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#f92672">url&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;http://127.0.0.1:5001/&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">inhibit_rules&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#f92672">source_match&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">severity&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;critical&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">target_match&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">severity&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;warning&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">equal&lt;/span>: [&lt;span style="color:#e6db74">&amp;#34;alertname&amp;#34;&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;dev&amp;#34;&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;instance&amp;#34;&lt;/span>]
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="使用腾讯企业邮箱的配置样例">使用腾讯企业邮箱的配置样例&lt;/h3>
&lt;p>Note：如果要使用腾讯企业邮箱，则需要生成客户端密码，位置如下图
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/fesx4v/1616068406969-84d8a216-cd2b-4438-a0e6-a6a85c64318a.jpeg" alt="">
下面的配置默认会将所有告警都发送给lichenhao@wisetv.com.cn。其中具有 network_device: interface-state 标签名和值的告警会发送给wangpeng@wisetv.com.cn&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-yaml" data-lang="yaml">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">global&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">resolve_timeout&lt;/span>: &lt;span style="color:#ae81ff">5m&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">smtp_smarthost&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;smtp.exmail.qq.com:587&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">smtp_from&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;lichenhao@wisetv.com.cn&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">smtp_auth_username&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;lichenhao@wisetv.com.cn&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">smtp_auth_password&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;bVcyqAh4jnz2hkVg&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">smtp_hello&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;qq.com&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">smtp_require_tls&lt;/span>: &lt;span style="color:#66d9ef">true&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">route&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">group_by&lt;/span>: [&lt;span style="color:#e6db74">&amp;#34;alertname&amp;#34;&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;cluster&amp;#34;&lt;/span>]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">group_wait&lt;/span>: &lt;span style="color:#ae81ff">30s&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">group_interval&lt;/span>: &lt;span style="color:#ae81ff">5m&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">repeat_interval&lt;/span>: &lt;span style="color:#ae81ff">5m&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">receiver&lt;/span>: &lt;span style="color:#ae81ff">default&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">routes&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#f92672">receiver&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;network-group&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">group_wait&lt;/span>: &lt;span style="color:#ae81ff">10s&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">match&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">network_device&lt;/span>: &lt;span style="color:#ae81ff">interface-state&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">receivers&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#f92672">name&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;default&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">email_configs&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#f92672">to&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;lichenhao@wisetv.com.cn&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">send_resolved&lt;/span>: &lt;span style="color:#66d9ef">true&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#f92672">name&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;network-group&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">email_configs&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#f92672">to&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;wangpeng@wisetv.com.cn&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">send_resolved&lt;/span>: &lt;span style="color:#66d9ef">true&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#f92672">to&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;lichenhao@wisetv.com.cn&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">send_resolved&lt;/span>: &lt;span style="color:#66d9ef">true&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h1 id="alertmanager-api">Alertmanager API&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://github.com/prometheus/alertmanager/blob/main/api/v2/openapi.yaml">GitHub 项目文件，prometheus/alertmanager/api/v2/openapi.yaml&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote></description></item><item><title>Docs: Ansible Modules</title><link>https://desistdaydream.github.io/docs/IT%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/9.%E8%BF%90%E7%BB%B4/Ansible/Ansible-Modules/Ansible-Modules/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/IT%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/9.%E8%BF%90%E7%BB%B4/Ansible/Ansible-Modules/Ansible-Modules/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://docs.ansible.com/ansible/latest/module_plugin_guide/modules_intro.html">官方文档，使用 Ansible 模块和插件-模块介绍&lt;/a>
&lt;ul>
&lt;li>&lt;a href="https://docs.ansible.com/ansible/2.10/user_guide/modules.html">2.10 版本&lt;/a>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>&lt;strong>Modules(模块)&lt;/strong> 也被称为 &lt;strong>Task Plugins(任务插件)&lt;/strong> 或 &lt;strong>Library Plugins(插件库)&lt;/strong>，Modules 是可以从 Ansible 的命令行或 Playbook 的任务中使用的代码块。Ansible 通常在受管理节点上执行每个模块以完成任务，并收集返回值。&lt;/p>
&lt;blockquote>
&lt;p>注意：在 Ansible 2.10 及以上的版本中，大多数模块都被托管到 &lt;strong>Collections(集合)&lt;/strong> 中。&lt;/p>
&lt;/blockquote>
&lt;p>我们可以通过命令行使用模块执行任务，比如&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>ansible webservers -m service -a &lt;span style="color:#e6db74">&amp;#34;name=httpd state=started&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>ansible webservers -m ping
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>ansible webservers -m command -a &lt;span style="color:#e6db74">&amp;#34;/sbin/reboot -t now&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>也可以在 Playbooks 中使用模块执行任务，比如&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-yaml" data-lang="yaml">&lt;span style="display:flex;">&lt;span>- &lt;span style="color:#f92672">name&lt;/span>: &lt;span style="color:#ae81ff">restart webserver&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">service&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">name&lt;/span>: &lt;span style="color:#ae81ff">httpd&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">state&lt;/span>: &lt;span style="color:#ae81ff">restarted&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>等效于&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>ansible webservers -m service -a &lt;span style="color:#e6db74">&amp;#34;name=httpd state=started&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>每个模块都可以接受参数，以空格分割的 &lt;code>KEY=VALUE&lt;/code> 格式。&lt;/p>
&lt;blockquote>
&lt;p>注意：在命令行中使用模块与在 Playbooks 中使用模块时，可以传递的参数不太一样，比如 command 或 shell 模块，只需要传递需要运行的命令这个参数即可，但是在 Playbooks 中使用这两个模块，还可以传递其他参数。&lt;/p>
&lt;/blockquote>
&lt;p>所有模块执行完成后，都会有返回一个 JSON 格式的数据，这意味着可以使用任何编程语言编写模块。模块应该是幂等的，如果检测到当前状态与所需要的最终状态匹配，则应该避免再进行任何更改。&lt;/p>
&lt;p>下面我们拿一个最简单的模块举例，ansible.builtin.command 模块，当我们使用 command 模块时，可以为其传递参数，在其执行完任务之后，还会有返回值。&lt;/p>
&lt;h2 id="简单示例">简单示例&lt;/h2>
&lt;p>假如现在有这么一个 Playbooks&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-yaml" data-lang="yaml">&lt;span style="display:flex;">&lt;span>- &lt;span style="color:#f92672">name&lt;/span>: &lt;span style="color:#ae81ff">test&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">command&lt;/span>: &lt;span style="color:#ae81ff">whoami&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">register&lt;/span>: &lt;span style="color:#ae81ff">info&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>- &lt;span style="color:#f92672">name&lt;/span>: &lt;span style="color:#ae81ff">debug&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">debug&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">msg&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;{{info}}&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>这个 Playbooks 的意思就是在受管理节点上执行 &lt;code>whoami&lt;/code> 命令，并将返回值保存到 info 变量中，通过 debug 模块，将 info 变量中的内容输出出来，效果如下：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-json" data-lang="json">&lt;span style="display:flex;">&lt;span>[&lt;span style="color:#960050;background-color:#1e0010">lichenhao@hw-cloud-xngy-jump-server-linux&lt;/span>&lt;span style="color:#ae81ff">-2&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">~/projects/DesistDaydream/ehualu/ansible/playbook&lt;/span>]&lt;span style="color:#960050;background-color:#1e0010">$&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">ansible-playbook&lt;/span> &lt;span style="color:#ae81ff">90&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">-test.yaml&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#960050;background-color:#1e0010">PLAY&lt;/span> [&lt;span style="color:#960050;background-color:#1e0010">test&lt;/span>] &lt;span style="color:#960050;background-color:#1e0010">*******************************************************************************************************************************************************************&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#960050;background-color:#1e0010">TASK&lt;/span> [&lt;span style="color:#ae81ff">90&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">-test&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">:&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">test&lt;/span>] &lt;span style="color:#960050;background-color:#1e0010">*********************************************************************************************************************************************************&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#960050;background-color:#1e0010">changed:&lt;/span> [&lt;span style="color:#960050;background-color:#1e0010">hw-cloud-xngy-jump-server-linux&lt;/span>&lt;span style="color:#ae81ff">-2&lt;/span>]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#960050;background-color:#1e0010">TASK&lt;/span> [&lt;span style="color:#ae81ff">90&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">-test&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">:&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">debug&lt;/span>] &lt;span style="color:#960050;background-color:#1e0010">********************************************************************************************************************************************************&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#960050;background-color:#1e0010">ok:&lt;/span> [&lt;span style="color:#960050;background-color:#1e0010">hw-cloud-xngy-jump-server-linux&lt;/span>&lt;span style="color:#ae81ff">-2&lt;/span>] &lt;span style="color:#960050;background-color:#1e0010">=&amp;gt;&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;info&amp;#34;&lt;/span>: {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;ansible_facts&amp;#34;&lt;/span>: {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;discovered_interpreter_python&amp;#34;&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;/usr/bin/python3&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> },
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;changed&amp;#34;&lt;/span>: &lt;span style="color:#66d9ef">true&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;cmd&amp;#34;&lt;/span>: [
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#34;whoami&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ],
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;delta&amp;#34;&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;0:00:00.002447&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;end&amp;#34;&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;2021-10-09 23:05:10.491190&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;failed&amp;#34;&lt;/span>: &lt;span style="color:#66d9ef">false&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;rc&amp;#34;&lt;/span>: &lt;span style="color:#ae81ff">0&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;start&amp;#34;&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;2021-10-09 23:05:10.488743&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;stderr&amp;#34;&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;stderr_lines&amp;#34;&lt;/span>: [],
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;stdout&amp;#34;&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;root&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;stdout_lines&amp;#34;&lt;/span>: [
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#34;root&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#960050;background-color:#1e0010">PLAY&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">RECAP&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">********************************************************************************************************************************************************************&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#960050;background-color:#1e0010">hw-cloud-xngy-jump-server-linux&lt;/span>&lt;span style="color:#ae81ff">-2&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">:&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">ok=&lt;/span>&lt;span style="color:#ae81ff">2&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">changed=&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">unreachable=&lt;/span>&lt;span style="color:#ae81ff">0&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">failed=&lt;/span>&lt;span style="color:#ae81ff">0&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">skipped=&lt;/span>&lt;span style="color:#ae81ff">0&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">rescued=&lt;/span>&lt;span style="color:#ae81ff">0&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">ignored=&lt;/span>&lt;span style="color:#ae81ff">0&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>我们对比&lt;a href="https://docs.ansible.com/ansible/latest/collections/ansible/builtin/command_module.html#return-values">官方文档中 command 模块的返回值&lt;/a>，可以看到，与文档中的返回值保持一致。
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/shqrrv/1633792369531-e531b4d1-5c2b-427c-ade8-6207d5d6020b.png" alt="image.png">&lt;/p>
&lt;h2 id="总结">总结&lt;/h2>
&lt;p>所以，这也是为什么将 Moduels 称为代码的原因，&lt;strong>所谓的 Modules，本质上就是代码写出来的程序，就像 Functions&lt;/strong>，具有形参，可以接受实参，执行完成后，还会有返回值。Ansible 通过模块执行完一个任务之后，就会处理这些返回值，将其 或保存、或展示、或丢弃 等等。同时，在 Playbooks 中，还可以通过判断语句，根据返回值的内容，决定下一个任务的运行模式。&lt;/p>
&lt;p>我们可以通过 &lt;code>ansible-doc -l&lt;/code> 命令查看所有可用的模块，或者从&lt;a href="https://docs.ansible.com/ansible/latest/collections/index.html#list-of-collections">官方文档-Collections 文档&lt;/a>中查看所有模块
还可以使用&lt;code> ansible-doc MODULE&lt;/code> 命令查看指定模块的文档&lt;/p>
&lt;h1 id="模块分类">模块分类&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://docs.ansible.com/ansible/2.9/modules/modules_by_category.html">官方文档 2.9，用户指南-使用模块-模块索引&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://docs.ansible.com/ansible/latest/collections/index_module.html">官方文档 2.10+，所有模块和插件的索引-所有模块的索引&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>在 2.10 版本之前，模块的分类非常清晰；2.10 版本之后，由于模块被合并到集合中，所以很多已经分类的模块被合并到 &lt;a href="https://docs.ansible.com/ansible/latest/collections/index_module.html#ansible-builtin">builtin(内置) 模块&lt;/a>这个类别中，在这里则不再进行细致划分，非常乱。。。。&lt;/p>
&lt;p>模块的保存位置（ansible python module location）也产生了变化：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>~&lt;span style="color:#f92672">]&lt;/span>&lt;span style="color:#75715e"># ansible --version&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>ansible 2.9.6
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> config file &lt;span style="color:#f92672">=&lt;/span> /etc/ansible/ansible.cfg
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> configured module search path &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#f92672">[&lt;/span>&lt;span style="color:#e6db74">&amp;#39;/home/lichenhao/.ansible/plugins/modules&amp;#39;&lt;/span>, &lt;span style="color:#e6db74">&amp;#39;/usr/share/ansible/plugins/modules&amp;#39;&lt;/span>&lt;span style="color:#f92672">]&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ansible python module location &lt;span style="color:#f92672">=&lt;/span> /usr/lib/python3/dist-packages/ansible
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> executable location &lt;span style="color:#f92672">=&lt;/span> /usr/bin/ansible
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> python version &lt;span style="color:#f92672">=&lt;/span> 3.8.10 &lt;span style="color:#f92672">(&lt;/span>default, Jun &lt;span style="color:#ae81ff">22&lt;/span> 2022, 20:18:18&lt;span style="color:#f92672">)&lt;/span> &lt;span style="color:#f92672">[&lt;/span>GCC 9.4.0&lt;span style="color:#f92672">]&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/shqrrv/1669781692961-2dda8a1f-3eec-4687-beb3-fa3d141c1b5e.png" alt="image.png">&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>~&lt;span style="color:#f92672">]&lt;/span>&lt;span style="color:#75715e"># ansible --version&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>ansible &lt;span style="color:#f92672">[&lt;/span>core 2.13.6&lt;span style="color:#f92672">]&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> config file &lt;span style="color:#f92672">=&lt;/span> /etc/ansible/ansible.cfg
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> configured module search path &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#f92672">[&lt;/span>&lt;span style="color:#e6db74">&amp;#39;/root/.ansible/plugins/modules&amp;#39;&lt;/span>, &lt;span style="color:#e6db74">&amp;#39;/usr/share/ansible/plugins/modules&amp;#39;&lt;/span>&lt;span style="color:#f92672">]&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ansible python module location &lt;span style="color:#f92672">=&lt;/span> /root/.local/lib/python3.8/site-packages/ansible
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ansible collection location &lt;span style="color:#f92672">=&lt;/span> /root/.ansible/collections:/usr/share/ansible/collections
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> executable location &lt;span style="color:#f92672">=&lt;/span> /usr/bin/ansible
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> python version &lt;span style="color:#f92672">=&lt;/span> 3.8.10 &lt;span style="color:#f92672">(&lt;/span>default, Jun &lt;span style="color:#ae81ff">22&lt;/span> 2022, 20:18:18&lt;span style="color:#f92672">)&lt;/span> &lt;span style="color:#f92672">[&lt;/span>GCC 9.4.0&lt;span style="color:#f92672">]&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> jinja version &lt;span style="color:#f92672">=&lt;/span> 3.1.2
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> libyaml &lt;span style="color:#f92672">=&lt;/span> True
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/shqrrv/1669781684010-2cc9f6a7-cb1e-4e93-bf81-e41ef417c23c.png" alt="image.png">&lt;/p></description></item><item><title>Docs: AnsiblePlugins</title><link>https://desistdaydream.github.io/docs/IT%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/9.%E8%BF%90%E7%BB%B4/Ansible/Ansible-Plugins/Ansible-Plugins/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/IT%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/9.%E8%BF%90%E7%BB%B4/Ansible/Ansible-Plugins/Ansible-Plugins/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://docs.ansible.com/ansible/latest/plugins/plugins.html">官方文档，使用插件&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>插件是增强 Ansible 核心功能的代码段。Ansible 使用插件架构来启用丰富，灵活和可扩展的功能集。&lt;/p>
&lt;p>朗读 Ansible 附带了许多方便的插件，您可以轻松编写自己的插件。&lt;/p>
&lt;p>本节介绍 Ansible 随附的各种类型的插件：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://docs.ansible.com/ansible/latest/plugins/action.html">Action Plugins&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://docs.ansible.com/ansible/latest/plugins/become.html">Become Plugins&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://docs.ansible.com/ansible/latest/plugins/cache.html">Cache Plugins&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://docs.ansible.com/ansible/latest/plugins/callback.html">Callback Plugins&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://docs.ansible.com/ansible/latest/plugins/cliconf.html">Cliconf Plugins&lt;/a>&lt;/li>
&lt;li>&lt;a href="docs/IT%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/9.%E8%BF%90%E7%BB%B4/Ansible/Ansible%20Plugins/Connection%20%E6%8F%92%E4%BB%B6.md">Connection 插件&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://docs.ansible.com/ansible/latest/plugins/httpapi.html">Httpapi Plugins&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://docs.ansible.com/ansible/latest/plugins/inventory.html">Inventory Plugins&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://docs.ansible.com/ansible/latest/plugins/lookup.html">Lookup Plugins&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://docs.ansible.com/ansible/latest/plugins/netconf.html">Netconf Plugins&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://docs.ansible.com/ansible/latest/plugins/shell.html">Shell Plugins&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://docs.ansible.com/ansible/latest/plugins/strategy.html">Strategy Plugins&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://docs.ansible.com/ansible/latest/plugins/vars.html">Vars Plugins&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://docs.ansible.com/ansible/latest/user_guide/playbooks_filters.html">Filters&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://docs.ansible.com/ansible/latest/user_guide/playbooks_tests.html">Tests&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://docs.ansible.com/ansible/latest/user_guide/plugin_filtering_config.html">Plugin Filter Configuration&lt;/a>&lt;/li>
&lt;/ul></description></item><item><title>Docs: API</title><link>https://desistdaydream.github.io/docs/IT%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/2.%E7%BC%96%E7%A8%8B/API/API/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/IT%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/2.%E7%BC%96%E7%A8%8B/API/API/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;a href="https://en.wikipedia.org/wiki/API">wiki，API&lt;/a>&lt;/p>
&lt;/blockquote>
&lt;p>&lt;strong>Application Programming Interface(应用程序接口，简称 API)&lt;/strong>。它定义了可以进行的调用或请求的类型，如何进行调用，应使用的数据格式，遵循的约定等。它还可以提供扩展机制，以便用户可以通过各种方式扩展现有功能。在不同程度上。[1] API 可以是完全自定义的，特定于组件的，也可以基于行业标准设计以确保互操作性。通过&lt;a href="https://en.wikipedia.org/wiki/Information_hiding">信息隐藏&lt;/a>，API 支持&lt;a href="https://en.wikipedia.org/wiki/Modular_programming">模块化编程&lt;/a>，从而使用户可以独立于实现使用接口。&lt;/p>
&lt;h2 id="目的">目的&lt;/h2>
&lt;p>在构建应用程序时，API（应用程序编程接口）通过抽象化底层实现并仅公开开发人员需要的对象或动作来简化编程。电子邮件客户端的图形界面可能会为用户提供执行获取和突出显示新电子邮件的所有步骤的按钮，而用于文件输入/输出的 API 可能会为开发人员提供一种将文件从一个位置复制到另一个位置的功能，而无需要求开发人员了解幕后发生的文件系统操作。[2]&lt;/p>
&lt;h2 id="术语的历史">术语的历史&lt;/h2>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/folw44/1616163705351-3d45137b-c5db-4656-839f-5fa583e353e3.png" alt="">&lt;/p>
&lt;p>1978 年的一张图建议将 API 的概念扩展为一个通用的编程接口，而不仅仅是应用程序。[3]&lt;/p>
&lt;p>“ &lt;em>API&lt;/em> ”一词的含义已经扩展了其历史。首先，它仅描述了面向面向最终用户的程序（称为应用程序）的接口。此起源仍反映在名称“应用程序编程接口”中。如今，术语 API 的范围更广，不仅包括实用程序软件，甚至包括硬件接口。[4]&lt;/p>
&lt;p>API 的概念比该术语要古老得多。英国计算机科学家 Wilkes 和 Wheeler 在 1940 年代为 EDSAC 计算机开发了模块化软件库。约书亚·布洛赫（Joshua Bloch）声称威尔克斯和惠勒（Wilker and Wheeler）“潜在地发明”了该 API，因为它更多地是被发现而不是被发明的概念。[4]&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/folw44/1616163705346-76236d7f-ccd5-42d5-81dd-04fdda266f7a.jpeg" alt="">&lt;/p>
&lt;p>尽管创造 API 一词的人是在 Univac 1108 上实现软件，但他们的 API 的目标是使独立于硬件的程序成为可能。[5]&lt;/p>
&lt;p>术语“应用程序接口”（没有_-ing_后缀）首先被记录在称为纸张_数据结构和技术对于远程计算机图形_在呈现 AFIPS 在 1968 年会议[6] [4]所述的本文使用的作者该术语描述应用程序（在这种情况下为图形程序）与计算机系统其余部分的交互。一致的应用程序接口（包括 Fortran 子例程调用）旨在使程序员摆脱处理图形显示设备的特性，并在更换计算机或显示器时提供硬件独立性。[5]&lt;/p>
&lt;p>术语被引入到的场数据库由 CJ 日期[7]中称为 1974 纸_的关系和网络途径：应用程序编程接口的比较_。[8] API 成为用于数据库管理系统的 ANSI / SPARC 框架的一部分。该框架将应用程序编程接口与其他接口（例如查询接口）分开对待。1970 年代的数据库专业人员发现，这些不同的接口可以组合在一起。一个足够丰富的应用程序接口也可以支持其他接口。[3]&lt;/p>
&lt;p>这种观察导致 API 支持所有类型的编程，而不仅是应用程序编程。到 1990 年，API 被技术专家 Carl Malamud 定义为“程序员可以用来执行某些任务的一组服务” 。[9]&lt;/p>
&lt;p>随着 Web API 的出现，API 的概念再次得到扩展。罗伊·菲尔丁（Roy Fielding）的论文《_建筑风格》和_2000 年在加州大学欧文分校（UC Irvine）_的基于网络的软件体系结构设计_概述了代表性状态转移（REST），并描述了“菲林丁”与传统的“图书馆应用程序接口”的“基于网络的应用程序编程接口”的概念。基于”的 API。[10] XML 和 JSON Web API 于 2000 年开始得到广泛的商业采用，并一直持续到 2020 年。&lt;/p>
&lt;p>现在，Web API 是术语 API 的最常见含义。[11]以这种方式使用时，术语“ API”与术语“通信协议”和“远程过程调用”在含义上有一些重叠。&lt;/p>
&lt;h2 id="用法">用法&lt;/h2>
&lt;h3 id="库和框架">库和框架&lt;/h3>
&lt;p>API 通常与软件库有关。当库是这套规则的“实际实现”时，API 描述并规定了“预期行为”（一种规范）。&lt;/p>
&lt;p>单个 API 可以采用共享同一编程接口的不同库的形式进行多种实现（或者没有一种实现是抽象的）。&lt;/p>
&lt;p>将 API 与实现分开，可以允许以一种语言编写的程序使用以另一种语言编写的库。例如，由于 Scala 和 Java 可以编译为兼容的字节码，因此 Scala 开发人员可以利用任何 Java API。[12]&lt;/p>
&lt;p>API 的使用取决于所涉及的编程语言的类型。诸如 Lua 之类的过程语言的 API 可以主要由执行代码，操纵数据或处理错误的基本例程组成，而诸如 Java 之类的面向对象语言的 API 则可以提供类及其类方法的规范。[13] [14]&lt;/p>
&lt;p>语言绑定也是 API。通过将一种语言的特性和功能映射到以另一种语言实现的接口，语言绑定允许在以另一种语言进行开发时使用以一种语言编写的库或服务。[15]诸如 SWIG 和 F2PY（一种从 Fortran 到 Python 的接口生成器）之类的工具有助于创建此类接口。[16]&lt;/p>
&lt;p>API 也可以与软件框架相关：框架可以基于实现了多个 API 的多个库，但是与 API 的正常使用不同，对框架内建行为的访问是通过使用新类扩展其内容来实现的插入框架本身。&lt;/p>
&lt;p>而且，整个控制程序流程可以通过控制反转或类似的机制而不受调用者的控制，而不受框架的控制。[17] [18]&lt;/p>
&lt;h3 id="操作系统">操作系统&lt;/h3>
&lt;p>API 可以指定应用程序和操作系统之间的接口。[19] 例如，POSIX 指定一组通用 API，这些 API 旨在使为 POSIX 兼容操作系统编写的应用程序能够为另一个 POSIX 兼容操作系统编译。&lt;/p>
&lt;p>Linux 和 Berkeley 软件发行版是实现 POSIX API 的操作系统的示例。[20]&lt;/p>
&lt;p>Microsoft 已显示出对向后兼容 API 的坚定承诺，尤其是在其 Windows API（Win32）库中，因此较旧的应用程序可以使用称为“兼容模式”的可执行程序特定设置在新版 Windows 上运行。[21]&lt;/p>
&lt;p>API 与应用程序二进制接口（ABI）的不同之处在于，API 是基于源代码的，而 ABI 是基于二进制的。例如，POSIX 提供 API，而 Linux Standard Base 提供 ABI。&lt;/p>
&lt;h3 id="远程-api">远程 API&lt;/h3>
&lt;p>远程 API 允许开发人员通过协议（特定于通信的标准）来操纵远程资源，该协议允许不同的技术一起工作，而不论语言或平台如何。例如，Java 数据库连接 API 允许开发人员使用相同的功能集查询许多不同类型的数据库，而 Java 远程方法调用 API 使用 Java 远程方法协议来允许调用可远程操作但在本地运行的功能开发人员。[24] [25]&lt;/p>
&lt;p>因此，远程 API 对于维护面向对象程序设计中的对象抽象很有用。在代理对象上本地执行的方法调用，使用远程协议在远程对象上调用相应的方法，并获取要在本地用作返回值的结果。&lt;/p>
&lt;p>代理对象的修改也将导致远程对象的相应修改。[26]&lt;/p>
&lt;h3 id="web-api">Web API&lt;/h3>
&lt;p>主要文章：Web API&lt;/p>
&lt;p>Web API 是企业和使用其资产的应用程序之间进行交互的已定义接口，这也是服务水平协议（SLA），用于指定功能提供者并为其 API 用户公开服务路径或 URL。API 方法是一种体系结构方法，它围绕为服务于不同类型消费者的不同应用程序提供一组服务的程序接口而发展。[27]&lt;/p>
&lt;p>当在 Web 开发的上下文中使用 API 时，通常将其定义为一组规范，例如超文本传输协议（HTTP）请求消息以及响应消息的结构定义，通常以可扩展标记语言（XML））或 JavaScript 对象符号（JSON）格式。例如运输公司的 API，可以将其添加到以电子商务为中心的网站上，以方便订购运输服务，并自动包括当前的运输价格，而站点开发人员不必在网络数据库中输入运输者的价格表。尽管“ Web API”在历史上实际上是 Web 服务的代名词，但最近的趋势（所谓的 Web 2.0）已从基于简单对象访问协议（SOAP）的 Web 服务和面向服务的体系结构（SOA）转向更直接的表示状态转移（REST）样式的 Web 资源和面向资源的体系结构（ROA）。[28]这种趋势的一部分与语义 Web 向资源描述框架（RDF）的发展有关，RDF 是一种促进基于 Web 的本体工程技术的概念。Web API 允许将多个 API 组合到称为 mashup 的新应用程序中。[29] 在社交媒体领域，Web API 使 Web 社区可以促进在社区和应用程序之间共享内容和数据。这样，可以将在一个地方动态创建的内容发布并更新到 Web 上的多个位置。[30]例如，Twitter 的 REST API 允许开发人员访问 Twitter 的核心数据，而 Search API 为开发人员提供了与 Twitter 搜索和趋势数据进行交互的方法。[31]&lt;/p>
&lt;h2 id="设计">设计&lt;/h2>
&lt;p>API 的设计对其使用有重大影响。[2]信息隐藏的原理将编程接口的作用描述为通过隐藏模块的实现细节来实现模块化编程，从而使模块用户无需了解模块内部的复杂性。[32]因此，API 的设计试图仅提供用户期望的工具。[2]编程接口的设计是软件体系结构的重要组成部分，是复杂软件的组织。[33]&lt;/p>
&lt;h2 id="发布政策">发布政策&lt;/h2>
&lt;p>API 是技术公司更常见的集成方式之一。提供和使用 API 的组件被视为业务生态系统的成员。[34]&lt;/p>
&lt;p>发布 API 的主要策略是：[35]&lt;/p>
&lt;ul>
&lt;li>
&lt;p>私有：该 API 仅供内部公司使用。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>合作伙伴：只有特定的业务合作伙伴可以使用 API。例如，Uber 和 Lyft 等租用公司的车辆允许经过批准的第三方开发人员直接在其应用程序内订购游乐设施。这使公司可以通过选择哪些应用程序可以访问 API 来进行质量控制，并为其提供额外的收入来源。[36]&lt;/p>
&lt;/li>
&lt;li>
&lt;p>公开：该 API 供公众使用。例如，Microsoft 公开了 Windows API，Apple 发行了其 API Cocoa，因此可以为其平台编写软件。通常，并非所有人都能访问所有公共 API。例如，Cloudflare 或 Voxility 等 Internet 服务提供商使用 RESTful API，以允许客户和转售商访问其基础结构信息，DDoS 统计信息，网络性能或仪表板控件。[37]可以通过“ API 令牌”或客户身份验证来授予对此类 API 的访问权限。[38]&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h3 id="公共-api-的含义">公共 API 的含义&lt;/h3>
&lt;p>API 公开时的重要因素是其“接口稳定性”。对 API 的更改（例如，向函数调用添加新参数）可能会破坏与依赖该 API 的客户端的兼容性。[39]&lt;/p>
&lt;p>当公开展示的 API 的某些部分可能发生更改并因此不稳定时，应将特定 API 的这些部分明确记录为“不稳定”。例如，在 Google Guava 库中，被视为不稳定的部分或可能即将更改的部分都标有 Java 注释 &lt;code>@Beta&lt;/code>。[40]&lt;/p>
&lt;p>公共 API 有时可以声明其自身的某些部分_已弃用_或废除。这通常意味着应将 API 的一部分视为要删除或以向后不兼容的方式进行修改的候选对象。因此，这些更改使开发人员可以脱离 API 的某些部分，这些部分将来将被删除或不再受支持。[41]&lt;/p>
&lt;p>客户端代码可能包含 API 设计人员不打算使用的创新用法或机会用法。换句话说，对于具有大量用户基础的库，当元素成为公共 API 的一部分时，可以多种方式使用它。[42] 2020 年 2 月 19 日，Akamai 发布了他们的年度“互联网状况”报告，展示了针对全球金融服务中针对公共 API 平台的网络犯罪分子的增长趋势。从 2017 年 12 月到 2019 年 11 月，Akamai 见证了 854.2 亿次凭证违规攻击。大约 20％（即 165.5 亿）与定义为 API 端点的主机名相对。其中，4.735 亿针对金融服务部门组织。[43]&lt;/p>
&lt;h2 id="文档">文档&lt;/h2>
&lt;p>API 文档描述了 API 提供的服务以及如何使用这些服务，旨在涵盖客户出于实际目的需要了解的所有内容。&lt;/p>
&lt;p>文档对于使用 API 开发和维护应用程序至关重要。[44] API 文档通常在文档文件中找到，但也可以在社交媒体（例如博客，论坛和问答网站）中找到。[45]&lt;/p>
&lt;p>传统的文档文件通常通过具有一致外观和结构的文档系统（例如 Javadoc 或 Pydoc）来呈现。但是，文档中包含的内容类型因 API 而异。[46]&lt;/p>
&lt;p>为了清楚起见，API 文档可能包括对 API 中的类和方法的描述以及“典型的使用场景，代码段，设计原理，性能讨论和合同”，但是 API 服务本身的实现细节通常是省略。&lt;/p>
&lt;p>该文档还涵盖了如何使用 API 的限制和限制。例如，对于一个 API 函数文档可以注意到，它的参数不能为 null，该函数本身没有线程安全的，[47]因为 API 文档往往是全面的，它是作家保持更新文档和挑战用户仔细阅读它，可能会产生错误。[39]&lt;/p>
&lt;p>API 文档可以使用 Java 注释之类的元数据信息来丰富。编译器，工具和_运行时_环境可以使用此元数据来实现自定义行为或自定义处理。[48]&lt;/p>
&lt;p>可以以数据驱动的方式生成 API 文档。通过观察使用给定 API 的许多程序，可以推断出典型用法以及所需的合同和指令。[49]然后，可以使用模板从挖掘的数据生成自然语言。&lt;/p></description></item><item><title>Docs: API Server</title><link>https://desistdaydream.github.io/docs/IT%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/10.%E4%BA%91%E5%8E%9F%E7%94%9F/2.3.Kubernetes-%E5%AE%B9%E5%99%A8%E7%BC%96%E6%8E%92%E7%B3%BB%E7%BB%9F/1.API-Resource-%E4%B8%8E-Object/API-Server/API-Server/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/IT%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/10.%E4%BA%91%E5%8E%9F%E7%94%9F/2.3.Kubernetes-%E5%AE%B9%E5%99%A8%E7%BC%96%E6%8E%92%E7%B3%BB%E7%BB%9F/1.API-Resource-%E4%B8%8E-Object/API-Server/API-Server/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://kubernetes.io/docs/concepts/overview/components/#kube-apiserver">官方文档，概念-概述-Kubernetes 组件-kube-apiserver&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://kubernetes.io/docs/reference/command-line-tools-reference/kube-apiserver/">官方文档，参考-通用组件-kube-apiserver&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>&lt;strong>API Server 是实现 kubernetes API 的应用程序，它是 Kubernetes 控制平面的一个组件，用以对外暴露 Kubernetes API&lt;/strong>。Kubernetes API Server 验证和配置 API 对象的数据，包括 pod、service、replicationcontroller 等。 API Server 为 REST 操作提供服务，并为集群的共享状态提供前端，所有其他组件通过该前端进行交互。&lt;/p>
&lt;p>如果是通过 kubeadm 安装的 k8s 集群，那么 API Server 的表现形式就是一个名为 &lt;strong>kube-apiserver 的静态 pod&lt;/strong>。kube-apiserver 可以水平扩展，i.e.部署多个 kube-apiserver 以实现高可用，应对高并发请求，到达 kube-apiserver 的流量可以在这些实例之间平衡。&lt;/p>
&lt;p>API Server 启动后，默认监听在 6443 端口(http 默认监听在 8080 上)。API Server 是 Kubernetes 集群的前端接口 ，各种客户端工具（CLI 或 UI）以及 Kubernetes 其他组件可以通过它管理集群的各种资源。kubectl 就是 API Server 的客户端程序，实现对 k8s 各种资源的增删改查的功能。各个 node 节点的 kubelet 也通过 master 节点的 API Server 来上报本节点的 Pod 状态。&lt;/p>
&lt;ul>
&lt;li>提供集群管理的 REST 风格 API 接口，包括认证授权、数据校验以及集群状态变更等&lt;/li>
&lt;li>提供其他模块之间的数据交互和通信的枢纽（其他模块通过 API Server 查询或修改数据，只有 API Server 才可以直接操作 etcd）&lt;/li>
&lt;/ul>
&lt;h1 id="api-server-的访问方式">API Server 的访问方式&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://kubernetes.io/docs/tasks/administer-cluster/access-cluster-api/">官方文档，任务-管理集群-使用 Kubernetes API 访问集群&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>注意：&lt;/p>
&lt;ol>
&lt;li>API Server 默认是安全的，在访问时，应使用 https 协议来操作。&lt;/li>
&lt;li>参考 [K8S 认证与授权介绍](7.API%20 访问控制.md 访问控制.md) 文章，学习在访问 API Server 时所遇到的验证问题。&lt;/li>
&lt;/ol>
&lt;h2 id="使用-kubectl-访问-api">使用 kubectl 访问 API&lt;/h2>
&lt;p>现阶段有 kubectl 工具可以实现对 API Server 的访问&lt;/p>
&lt;p>使用 kubectl get &amp;ndash;raw / 命令让 kubectl 不再输出标准格式的数据，而是直接向 api server 请求原始数据&lt;/p>
&lt;h2 id="直接访问-rest-apieg使用-curl浏览器-等方式访问-api">直接访问 REST API(e.g.使用 curl、浏览器 等方式访问 API)&lt;/h2>
&lt;p>kubectl 处理对 API 服务器的定位和身份验证。如果你想通过 http 客户端（如 curl 或 wget，或浏览器）直接访问 REST API，你可以通过多种方式对 API 服务器进行定位和身份验证：&lt;/p>
&lt;ol>
&lt;li>以代理模式运行 kubectl(推荐)。 推荐使用此方法，因为它用存储的 apiserver 位置并使用自签名证书验证 API 服务器的标识。 使用这种方法无法进行中间人（MITM）攻击。&lt;/li>
&lt;li>另外，你可以直接为 HTTP 客户端提供位置和身份认证。 这适用于被代理混淆的客户端代码。 为防止中间人攻击，你需要将根证书导入浏览器。&lt;/li>
&lt;/ol>
&lt;p>比如 curl &amp;ndash;request DELETE -cacert ${CAPATH} -H &amp;ldquo;Authorization: Bearer ${TOKEN}&amp;rdquo; https://${IP}:6443/api/v1/namespaces/monitoring/pods/prometheus-k8s-0 -k 这样一个请求就可以将集群内 monitoring 空间下的 prometheus-k8s-0 这个 pod 删除&lt;/p>
&lt;h3 id="获取认证所需信息">获取认证所需信息&lt;/h3>
&lt;p>&lt;strong>方法一：使用 kubectl 的配置文件中的证书与私钥&lt;/strong>
想要访问 https 下的内容，首先需要准备证书与私钥或者 ca 与 token 等等。&lt;/p>
&lt;ol>
&lt;li>首先获取 kubeclt 工具配置文件中的证书与私钥
&lt;ol>
&lt;li>cat /etc/kubernetes/admin.conf | grep client-certificate-data | awk &amp;lsquo;{print $2}&amp;rsquo; | base64 -d &amp;gt; /root/certs/admin.crt&lt;/li>
&lt;li>cat /etc/kubernetes/admin.conf | grep client-key-data | awk &amp;lsquo;{print $2}&amp;rsquo; | base64 -d &amp;gt; /root/certs/admin.key&lt;/li>
&lt;/ol>
&lt;/li>
&lt;li>确定 CA 文件位置(文件一般在 /etc/kubernetes/pki/ca.crt)
&lt;ol>
&lt;li>CAPATH=/etc/kubernetes/pki/ca.crt&lt;/li>
&lt;/ol>
&lt;/li>
&lt;li>确定要访问组件的的 IP
&lt;ol>
&lt;li>IP=172.38.40.212&lt;/li>
&lt;/ol>
&lt;/li>
&lt;/ol>
&lt;p>&lt;strong>方法二：使用拥有最高权限 ServiceAccount 的 Token 访问 https&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>(可选)创建一个专门存放 SA 的名称空间
&lt;ul>
&lt;li>kubectl create namespace user-sa-manage&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>创建一个 ServiceAccount
&lt;ul>
&lt;li>kubectl create -n user-sa-manage serviceaccount test-admin&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>将该 ServiceAccount 绑定到 cluster-admin 这个 clusterrole，以赋予最高权限
&lt;ul>
&lt;li>kubectl create clusterrolebinding test-admin &amp;ndash;clusterrole=cluster-admin &amp;ndash;serviceaccount=user-sa-manage:test-admin&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>将该 ServiceAccount 的 Token 的值注册到变量中
&lt;ul>
&lt;li>TOKEN=$(kubectl get -n user-sa-manage secrets -o jsonpath=&amp;quot;{.items[?(@.metadata.annotations[&amp;lsquo;kubernetes.io/service-account.name&amp;rsquo;]==&amp;lsquo;test-admin&amp;rsquo;)].data.token}&amp;quot;|base64 -d)&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>确定 CA 文件位置(文件一般在 /etc/kubernetes/pki/ca.crt)
&lt;ul>
&lt;li>CAPATH=/etc/kubernetes/pki/ca.crt&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>确定要访问组件的的 IP
&lt;ul>
&lt;li>IP=172.38.40.212&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>使用令牌玩转 API
&lt;ul>
&lt;li>curl -k $IP/api -H &amp;ldquo;Authorization: Bearer $TOKEN&amp;rdquo;&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>Note：也可以从一个具有权限的 ServiceAccount 下的 secret 获取，可以使用现成的，也可以手动创建。比如下面用 promtheus 自带的 token。&lt;/p>
&lt;ol>
&lt;li>如果权限不足，那么访问的时候会报错，比如权限不够，或者认证不通过等等。报错信息有如下几种
&lt;ol>
&lt;li>no kind is registered for the type v1.Status in scheme &amp;ldquo;k8s.io/kubernetes/pkg/api/legacyscheme/scheme.go:30&amp;rdquo;&lt;/li>
&lt;li>Unauthorized&lt;/li>
&lt;/ol>
&lt;/li>
&lt;li>TOKEN=$(kubectl get secrets -n monitoring prometheus-k8s-token-q5hm4 &amp;ndash;template={{.data.token}} | base64 -d)&lt;/li>
&lt;/ol>
&lt;p>&lt;strong>方法三：官方推荐，类似方法二&lt;/strong>
官方文档：&lt;a href="https://kubernetes.io/docs/tasks/administer-cluster/access-cluster-api/">https://kubernetes.io/docs/tasks/administer-cluster/access-cluster-api/&lt;/a>&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># 查看所有的集群，因为你的 .kubeconfig 文件中可能包含多个上下文&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>kubectl config view -o jsonpath&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#39;{&amp;#34;Cluster name\tServer\n&amp;#34;}{range .clusters[*]}{.name}{&amp;#34;\t&amp;#34;}{.cluster.server}{&amp;#34;\n&amp;#34;}{end}&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># 从上述命令输出中选择你要与之交互的集群的名称&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>export CLUSTER_NAME&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;some_server_name&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># 指向引用该集群名称的 API 服务器&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>APISERVER&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#66d9ef">$(&lt;/span>kubectl config view -o jsonpath&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;{.clusters[?(@.name==\&amp;#34;&lt;/span>&lt;span style="color:#e6db74">${&lt;/span>CLUSTER_NAME&lt;span style="color:#e6db74">}&lt;/span>&lt;span style="color:#e6db74">\&amp;#34;)].cluster.server}&amp;#34;&lt;/span>&lt;span style="color:#66d9ef">)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># 获得令牌&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>TOKEN&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#66d9ef">$(&lt;/span>kubectl get secrets -o jsonpath&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;{.items[?(@.metadata.annotations[&amp;#39;kubernetes\.io/service-account\.name&amp;#39;]==&amp;#39;default&amp;#39;)].data.token}&amp;#34;&lt;/span>|base64 -d&lt;span style="color:#66d9ef">)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># 使用令牌玩转 API&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>curl -X GET $APISERVER/api --header &lt;span style="color:#e6db74">&amp;#34;Authorization: Bearer &lt;/span>$TOKEN&lt;span style="color:#e6db74">&amp;#34;&lt;/span> --insecure
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="访问-api-server">访问 API Server&lt;/h3>
&lt;ol>
&lt;li>执行访问 https 前准备方法一
&lt;ol>
&lt;li>通过证书与私钥访问
&lt;ol>
&lt;li>curl &amp;ndash;cacert ${CAPATH} &amp;ndash;cert /root/certs/admin.crt &amp;ndash;key /root/certs/admin.key https://${IP}:6443/&lt;/li>
&lt;/ol>
&lt;/li>
&lt;/ol>
&lt;/li>
&lt;li>执行访问 https 前准备方法二
&lt;ol>
&lt;li>通过 https 的方式访问 API
&lt;ol>
&lt;li>curl &amp;ndash;cacert ${CAPATH} -H &amp;ldquo;Authorization: Bearer ${TOKEN}&amp;rdquo; https://${IP}:6443/&lt;/li>
&lt;/ol>
&lt;/li>
&lt;/ol>
&lt;/li>
&lt;li>kubeclt
&lt;ol>
&lt;li>kubectl get &amp;ndash;raw / # 让 kubectl 不再输出标准格式的数据，而是直接向 api server 请求原始数据&lt;/li>
&lt;/ol>
&lt;/li>
&lt;li>kubectl proxy，一般监听在 6443 端口的 api server 使用该方式，监听在 8080 上的为 http，可直接访问
&lt;ol>
&lt;li>kubectl proxy &amp;ndash;port=8080 &amp;ndash;accept-hosts=&amp;rsquo;^localhost$,^127.0.0.1$,^[::1]$,10.10.100.151&amp;rsquo; &amp;ndash;address=&amp;lsquo;0.0.0.0&amp;rsquo; # 在本地 8080 端口上启动 API Server 的一个代理网关，以便使用 curl 直接访问 api server 并使用命令 curl localhost:8080/获取数据
&lt;ol>
&lt;li>直接访问本地 8080 端口，即可通过 API Server 获取集群所有数据&lt;/li>
&lt;/ol>
&lt;/li>
&lt;/ol>
&lt;/li>
&lt;/ol>
&lt;h2 id="编程方式访问-api">编程方式访问 API&lt;/h2>
&lt;p>Kubernetes 官方支持  &lt;a href="https://kubernetes.io/zh/docs/tasks/administer-cluster/access-cluster-api/#go-client">Go&lt;/a>、&lt;a href="https://kubernetes.io/zh/docs/tasks/administer-cluster/access-cluster-api/#python-client">Python&lt;/a>、&lt;a href="https://kubernetes.io/zh/docs/tasks/administer-cluster/access-cluster-api/#java-client">Java&lt;/a>、 &lt;a href="https://kubernetes.io/zh/docs/tasks/administer-cluster/access-cluster-api/#dotnet-client">dotnet&lt;/a>、&lt;a href="https://kubernetes.io/zh/docs/tasks/administer-cluster/access-cluster-api/#javascript-client">Javascript&lt;/a>  和  &lt;a href="https://kubernetes.io/zh/docs/tasks/administer-cluster/access-cluster-api/#haskell-client">Haskell&lt;/a>  语言的客户端库。还有一些其他客户端库由对应作者而非 Kubernetes 团队提供并维护。 参考&lt;a href="https://kubernetes.io/zh/docs/reference/using-api/client-libraries/">客户端库&lt;/a>了解如何使用其他语言 来访问 API 以及如何执行身份认证。&lt;/p>
&lt;h3 id="go-客户端介绍">Go 客户端介绍&lt;/h3>
&lt;blockquote>
&lt;p>参考：官方文档：&lt;a href="https://github.com/kubernetes/client-go/#compatibility-matrix">https://github.com/kubernetes/client-go/#compatibility-matrix&lt;/a>
详见 &lt;a href="https://www.yuque.com/go/doc/33161293">Client Libraries&lt;/a>&lt;/p>
&lt;/blockquote>
&lt;p>版本控制策略：k8s 版本 1.18.8 对应 client-go 版本 0.18.8，其他版本以此类推。&lt;/p>
&lt;p>使用前注意事项：
使用 client-go 之前，需要手动获取对应版本的的 client-go 库。根据版本控制策略，使用如下命令进行初始化&lt;/p>
&lt;pre>&lt;code>go mod init client-go-test
go get k8s.io/client-go@kubernetes-1.19.2
&lt;/code>&lt;/pre>
&lt;p>这是一个使用 client-go 访问 API 的基本示例&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">package&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">import&lt;/span> (
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#34;context&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#34;fmt&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">v1&lt;/span> &lt;span style="color:#e6db74">&amp;#34;k8s.io/apimachinery/pkg/apis/meta/v1&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#34;k8s.io/client-go/kubernetes&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#34;k8s.io/client-go/tools/clientcmd&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">func&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 根据指定的 kubeconfig 创建一个用于连接集群的配置，/root/.kube/config 为 kubectl 命令所用的 config 文件
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#a6e22e">config&lt;/span>, &lt;span style="color:#a6e22e">_&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">clientcmd&lt;/span>.&lt;span style="color:#a6e22e">BuildConfigFromFlags&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;&amp;#34;&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;/root/.kube/config&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 根据 BuildConfigFromFlags 创建的配置，返回一个可以连接集群的指针
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#a6e22e">clientset&lt;/span>, &lt;span style="color:#a6e22e">_&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">kubernetes&lt;/span>.&lt;span style="color:#a6e22e">NewForConfig&lt;/span>(&lt;span style="color:#a6e22e">config&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 根据 NewForConfig 所创建的连接集群的指针，来访问 API，并对集群进行操作
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#a6e22e">pods&lt;/span>, &lt;span style="color:#a6e22e">_&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">clientset&lt;/span>.&lt;span style="color:#a6e22e">CoreV1&lt;/span>().&lt;span style="color:#a6e22e">Pods&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;&amp;#34;&lt;/span>).&lt;span style="color:#a6e22e">List&lt;/span>(&lt;span style="color:#a6e22e">context&lt;/span>.&lt;span style="color:#a6e22e">TODO&lt;/span>(), &lt;span style="color:#a6e22e">v1&lt;/span>.&lt;span style="color:#a6e22e">ListOptions&lt;/span>{})
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">fmt&lt;/span>.&lt;span style="color:#a6e22e">Printf&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;There are %d pods in the cluster\n&amp;#34;&lt;/span>, len(&lt;span style="color:#a6e22e">pods&lt;/span>.&lt;span style="color:#a6e22e">Items&lt;/span>))
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="从-pod-中访问-api">从 Pod 中访问 API&lt;/h2>
&lt;p>从 Pod 内部访问 API 时，定位 API 服务器和向服务器认证身份的操作 与上面描述的外部客户场景不同。&lt;/p>
&lt;p>从 Pod 使用 Kubernetes API 的最简单的方法就是使用官方的 客户端库。 这些库可以自动发现 API 服务器并进行身份验证。&lt;/p>
&lt;h3 id="使用官方客户端库">使用官方客户端库&lt;/h3>
&lt;p>从一个 Pod 内部连接到 Kubernetes API 的推荐方式为：&lt;/p>
&lt;ul>
&lt;li>对于 Go 语言客户端，使用官方的 Go 客户端库。 函数 &lt;code>rest.InClusterConfig()&lt;/code> 自动处理 API 主机发现和身份认证。 参见这里的一个例子。&lt;/li>
&lt;li>对于 Python 客户端，使用官方的 Python 客户端库。 函数 &lt;code>config.load_incluster_config()&lt;/code> 自动处理 API 主机的发现和身份认证。 参见这里的一个例子。&lt;/li>
&lt;li>还有一些其他可用的客户端库，请参阅客户端库页面。&lt;/li>
&lt;/ul>
&lt;p>在以上场景中，客户端库都使用 Pod 的服务账号凭据来与 API 服务器安全地通信。&lt;/p>
&lt;h3 id="直接访问-rest-api">直接访问 REST API&lt;/h3>
&lt;p>在运行在 Pod 中时，可以通过 &lt;code>default&lt;/code> 命名空间中的名为 &lt;code>kubernetes&lt;/code> 的服务访问 Kubernetes API 服务器。也就是说，Pod 可以使用 &lt;code>kubernetes.default.svc&lt;/code> 主机名 来查询 API 服务器。官方客户端库自动完成这个工作。&lt;/p>
&lt;p>向 API 服务器进行身份认证的推荐做法是使用 &lt;a href="https://kubernetes.io/zh/docs/tasks/configure-pod-container/configure-service-account/">服务账号&lt;/a> 凭据。 默认情况下，每个 Pod 与一个服务账号关联，该服务账户的凭证（令牌）放置在此 Pod 中 每个容器的文件系统树中的 &lt;code>/var/run/secrets/kubernetes.io/serviceaccount/token&lt;/code> 处。&lt;/p>
&lt;p>如果由证书包可用，则凭证包被放入每个容器的文件系统树中的 &lt;code>/var/run/secrets/kubernetes.io/serviceaccount/ca.crt&lt;/code> 处， 且将被用于验证 API 服务器的服务证书。&lt;/p>
&lt;p>最后，用于命名空间域 API 操作的默认命名空间放置在每个容器中的 &lt;code>/var/run/secrets/kubernetes.io/serviceaccount/namespace&lt;/code> 文件中。&lt;/p>
&lt;h3 id="使用-kubectl-proxy">使用 kubectl proxy&lt;/h3>
&lt;p>如果你希望不实用官方客户端库就完成 API 查询，可以将 &lt;code>kubectl proxy&lt;/code> 作为 command 在 Pod 启动一个边车（Sidecar）容器。&lt;/p>
&lt;p>这样，&lt;code>kubectl proxy&lt;/code> 自动完成对 API 的身份认证，并将其暴露到 Pod 的 &lt;code>localhost&lt;/code> 接口，从而 Pod 中的其他容器可以 直接使用 API。&lt;/p>
&lt;h3 id="不使用代理">不使用代理&lt;/h3>
&lt;p>通过将认证令牌直接发送到 API 服务器，也可以避免运行 kubectl proxy 命令。 内部的证书机制能够为链接提供保护。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># 指向内部 API 服务器的主机名&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>APISERVER&lt;span style="color:#f92672">=&lt;/span>https://kubernetes.default.svc
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># 服务账号令牌的路径&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>SERVICEACCOUNT&lt;span style="color:#f92672">=&lt;/span>/var/run/secrets/kubernetes.io/serviceaccount
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># 读取 Pod 的名字空间&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>NAMESPACE&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#66d9ef">$(&lt;/span>cat &lt;span style="color:#e6db74">${&lt;/span>SERVICEACCOUNT&lt;span style="color:#e6db74">}&lt;/span>/namespace&lt;span style="color:#66d9ef">)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># 读取服务账号的持有者令牌&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>TOKEN&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#66d9ef">$(&lt;/span>cat &lt;span style="color:#e6db74">${&lt;/span>SERVICEACCOUNT&lt;span style="color:#e6db74">}&lt;/span>/token&lt;span style="color:#66d9ef">)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># 引用内部整数机构（CA）&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>CACERT&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">${&lt;/span>SERVICEACCOUNT&lt;span style="color:#e6db74">}&lt;/span>/ca.crt
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># 使用令牌访问 API&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>curl --cacert &lt;span style="color:#e6db74">${&lt;/span>CACERT&lt;span style="color:#e6db74">}&lt;/span> --header &lt;span style="color:#e6db74">&amp;#34;Authorization: Bearer &lt;/span>&lt;span style="color:#e6db74">${&lt;/span>TOKEN&lt;span style="color:#e6db74">}&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span> -X GET &lt;span style="color:#e6db74">${&lt;/span>APISERVER&lt;span style="color:#e6db74">}&lt;/span>/api
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>输出类似于：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-json" data-lang="json">&lt;span style="display:flex;">&lt;span>{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;kind&amp;#34;&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;APIVersions&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;versions&amp;#34;&lt;/span>: [&lt;span style="color:#e6db74">&amp;#34;v1&amp;#34;&lt;/span>],
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;serverAddressByClientCIDRs&amp;#34;&lt;/span>: [
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;clientCIDR&amp;#34;&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;0.0.0.0/0&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;serverAddress&amp;#34;&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;10.0.1.149:443&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h1 id="api-server-健康检查点">API Server 健康检查点&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;a href="https://kubernetes.io/docs/reference/using-api/health-checks/">官方文档&lt;/a>&lt;/p>
&lt;/blockquote>
&lt;p>Kubernetes API 服务器 提供 API 端点以指示 API 服务器的当前状态。 本文描述了这些 API 端点，并说明如何使用。&lt;/p>
&lt;h3 id="api-健康检查点">API 健康检查点&lt;/h3>
&lt;p>Kubernetes API 服务器提供 3 个 API 端点（&lt;code>healthz&lt;/code>、&lt;code>livez&lt;/code> 和 &lt;code>readyz&lt;/code>）来表明 API 服务器的当前状态。 &lt;code>healthz&lt;/code> 端点已被弃用（自 Kubernetes v1.16 起），你应该使用更为明确的 &lt;code>livez&lt;/code> 和 &lt;code>readyz&lt;/code> 端点。 &lt;code>livez&lt;/code> 端点可与 &lt;code>--livez-grace-period&lt;/code> 标志一起使用，来指定启动持续时间。 为了正常关机，你可以使用 &lt;code>/readyz&lt;/code> 端点并指定 &lt;code>--shutdown-delay-duration&lt;/code> 标志。 检查 API 服务器的 &lt;code>health&lt;/code>/&lt;code>livez&lt;/code>/&lt;code>readyz&lt;/code> 端点的机器应依赖于 HTTP 状态代码。 状态码 &lt;code>200&lt;/code> 表示 API 服务器是 &lt;code>healthy&lt;/code>、&lt;code>live&lt;/code> 还是 &lt;code>ready&lt;/code>，具体取决于所调用的端点。 以下更详细的选项供操作人员使用，用来调试其集群或专门调试 API 服务器的状态。&lt;/p>
&lt;p>以下示例将显示如何与运行状况 API 端点进行交互。&lt;/p>
&lt;p>对于所有端点，都可以使用 &lt;code>verbose&lt;/code> 参数来打印检查项以及检查状态。 这对于操作人员调试 API 服务器的当前状态很有用，这些不打算给机器使用：&lt;/p>
&lt;pre>&lt;code>curl -k https://localhost:6443/livez?verbose
&lt;/code>&lt;/pre>
&lt;p>或从具有身份验证的远程主机：&lt;/p>
&lt;pre>&lt;code>kubectl get --raw='/readyz?verbose'
&lt;/code>&lt;/pre>
&lt;p>输出将如下所示：&lt;/p>
&lt;pre>&lt;code>[+]ping ok
[+]log ok
[+]etcd ok
[+]poststarthook/start-kube-apiserver-admission-initializer ok
[+]poststarthook/generic-apiserver-start-informers ok
[+]poststarthook/start-apiextensions-informers ok
[+]poststarthook/start-apiextensions-controllers ok
[+]poststarthook/crd-informer-synced ok
[+]poststarthook/bootstrap-controller ok
[+]poststarthook/rbac/bootstrap-roles ok
[+]poststarthook/scheduling/bootstrap-system-priority-classes ok
[+]poststarthook/start-cluster-authentication-info-controller ok
[+]poststarthook/start-kube-aggregator-informers ok
[+]poststarthook/apiservice-registration-controller ok
[+]poststarthook/apiservice-status-available-controller ok
[+]poststarthook/kube-apiserver-autoregistration ok
[+]autoregister-completion ok
[+]poststarthook/apiservice-openapi-controller ok
healthz check passed
&lt;/code>&lt;/pre>
&lt;p>Kubernetes API 服务器也支持排除特定的检查项。 查询参数也可以像以下示例一样进行组合：&lt;/p>
&lt;pre>&lt;code>curl -k 'https://localhost:6443/readyz?verbose&amp;amp;exclude=etcd'
&lt;/code>&lt;/pre>
&lt;p>输出显示排除了 &lt;code>etcd&lt;/code> 检查：&lt;/p>
&lt;pre>&lt;code>[+]ping ok
[+]log ok
[+]etcd excluded: ok
[+]poststarthook/start-kube-apiserver-admission-initializer ok
[+]poststarthook/generic-apiserver-start-informers ok
[+]poststarthook/start-apiextensions-informers ok
[+]poststarthook/start-apiextensions-controllers ok
[+]poststarthook/crd-informer-synced ok
[+]poststarthook/bootstrap-controller ok
[+]poststarthook/rbac/bootstrap-roles ok
[+]poststarthook/scheduling/bootstrap-system-priority-classes ok
[+]poststarthook/start-cluster-authentication-info-controller ok
[+]poststarthook/start-kube-aggregator-informers ok
[+]poststarthook/apiservice-registration-controller ok
[+]poststarthook/apiservice-status-available-controller ok
[+]poststarthook/kube-apiserver-autoregistration ok
[+]autoregister-completion ok
[+]poststarthook/apiservice-openapi-controller ok
[+]shutdown ok
healthz check passed
&lt;/code>&lt;/pre>
&lt;h3 id="独立健康检查">独立健康检查&lt;/h3>
&lt;p>&lt;strong>FEATURE STATE:&lt;/strong> &lt;code>Kubernetes v1.19 [alpha]&lt;/code>每个单独的健康检查都会公开一个 http 端点，并且可以单独检查。 单个运行状况检查的模式为 &lt;code>/livez/&amp;lt;healthcheck-name&amp;gt;&lt;/code>，其中 &lt;code>livez&lt;/code> 和 &lt;code>readyz&lt;/code> 表明你要检查的是 API 服务器是否存活或就绪。 &lt;code>&amp;lt;healthcheck-name&amp;gt;&lt;/code> 的路径可以通过上面的 &lt;code>verbose&lt;/code> 参数发现 ，并采用 &lt;code>[+]&lt;/code> 和 &lt;code>ok&lt;/code> 之间的路径。 这些单独的健康检查不应由机器使用，但对于操作人员调试系统而言，是有帮助的：&lt;/p>
&lt;pre>&lt;code>curl -k https://localhost:6443/livez/etcd
&lt;/code>&lt;/pre>
&lt;h1 id="api-server-与-etcd-的交互方式">API Server 与 Etcd 的交互方式&lt;/h1>
&lt;p>数据通过 API Server 时，一般是进行序列化后保存到 etcd 中的，可以使用参数 &amp;ndash;etcd-prefix 来指定数据保存在 etcd 中后的地址前缀，默认为 &lt;code>/registry&lt;/code>&lt;/p>
&lt;p>一般情况，保存到 etcd 中后，会省略 Group 与 Version，直接使用 Resource 来作为 etcd 中的路径。比如：URI 为 /api/v1/namespaces/kube-system/pods/kube-apiserver-master1 的 pod 资源，在 etcd 中的存储路径为 /registry/pods/kube-system/kube-apiserver-master1。&lt;/p>
&lt;p>而序列化的方式可以通过 &amp;ndash;storage-media-type 来指定，默认为 protobuf 。使用这种方式将数据序列化之后，得出来的将会有很多乱码，详见 &lt;a href="https://www.yuque.com/go/doc/33166015">Etcd 数据探秘章节&lt;/a> 中的说明&lt;/p>
&lt;h1 id="kube-apiserver-manifests-示例">kube-apiserver Manifests 示例&lt;/h1>
&lt;pre>&lt;code>apiVersion: v1
kind: Pod
metadata:
annotations:
kubeadm.kubernetes.io/kube-apiserver.advertise-address.endpoint: 172.19.42.231:6443
creationTimestamp: null
labels:
component: kube-apiserver
tier: control-plane
name: kube-apiserver
namespace: kube-system
spec:
containers:
- command:
- kube-apiserver
- --advertise-address=172.19.42.231
- --allow-privileged=true
- --authorization-mode=Node,RBAC
- --client-ca-file=/etc/kubernetes/pki/ca.crt
- --enable-admission-plugins=NodeRestriction
- --enable-bootstrap-token-auth=true
- --etcd-cafile=/etc/kubernetes/pki/etcd/ca.crt
- --etcd-certfile=/etc/kubernetes/pki/apiserver-etcd-client.crt
- --etcd-keyfile=/etc/kubernetes/pki/apiserver-etcd-client.key
- --etcd-servers=https://127.0.0.1:2379
- --insecure-port=0
- --kubelet-client-certificate=/etc/kubernetes/pki/apiserver-kubelet-client.crt
- --kubelet-client-key=/etc/kubernetes/pki/apiserver-kubelet-client.key
- --kubelet-preferred-address-types=InternalIP,ExternalIP,Hostname
- --proxy-client-cert-file=/etc/kubernetes/pki/front-proxy-client.crt
- --proxy-client-key-file=/etc/kubernetes/pki/front-proxy-client.key
- --requestheader-allowed-names=front-proxy-client
- --requestheader-client-ca-file=/etc/kubernetes/pki/front-proxy-ca.crt
- --requestheader-extra-headers-prefix=X-Remote-Extra-
- --requestheader-group-headers=X-Remote-Group
- --requestheader-username-headers=X-Remote-User
- --secure-port=6443
- --service-account-key-file=/etc/kubernetes/pki/sa.pub
- --service-cluster-ip-range=10.96.0.0/12
- --service-node-port-range=30000-60000
- --tls-cert-file=/etc/kubernetes/pki/apiserver.crt
- --tls-private-key-file=/etc/kubernetes/pki/apiserver.key
image: registry.aliyuncs.com/k8sxio/kube-apiserver:v1.19.2
imagePullPolicy: IfNotPresent
livenessProbe:
failureThreshold: 8
httpGet:
host: 172.19.42.231
path: /livez
port: 6443
scheme: HTTPS
initialDelaySeconds: 10
periodSeconds: 10
timeoutSeconds: 15
name: kube-apiserver
readinessProbe:
failureThreshold: 3
httpGet:
host: 172.19.42.231
path: /readyz
port: 6443
scheme: HTTPS
periodSeconds: 1
timeoutSeconds: 15
resources:
requests:
cpu: 250m
startupProbe:
failureThreshold: 24
httpGet:
host: 172.19.42.231
path: /livez
port: 6443
scheme: HTTPS
initialDelaySeconds: 10
periodSeconds: 10
timeoutSeconds: 15
volumeMounts:
- mountPath: /etc/ssl/certs
name: ca-certs
readOnly: true
- mountPath: /etc/pki
name: etc-pki
readOnly: true
- mountPath: /etc/localtime
name: host-time
readOnly: true
- mountPath: /etc/kubernetes/pki
name: k8s-certs
readOnly: true
hostNetwork: true
priorityClassName: system-node-critical
volumes:
- hostPath:
path: /etc/ssl/certs
type: DirectoryOrCreate
name: ca-certs
- hostPath:
path: /etc/pki
type: DirectoryOrCreate
name: etc-pki
- hostPath:
path: /etc/localtime
type: &amp;quot;&amp;quot;
name: host-time
- hostPath:
path: /etc/kubernetes/pki
type: DirectoryOrCreate
name: k8s-certs
&lt;/code>&lt;/pre></description></item><item><title>Docs: API 参考</title><link>https://desistdaydream.github.io/docs/IT%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/10.%E4%BA%91%E5%8E%9F%E7%94%9F/2.3.Kubernetes-%E5%AE%B9%E5%99%A8%E7%BC%96%E6%8E%92%E7%B3%BB%E7%BB%9F/1.API-Resource-%E4%B8%8E-Object/API-%E5%8F%82%E8%80%83/API-%E5%8F%82%E8%80%83/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/IT%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/10.%E4%BA%91%E5%8E%9F%E7%94%9F/2.3.Kubernetes-%E5%AE%B9%E5%99%A8%E7%BC%96%E6%8E%92%E7%B3%BB%E7%BB%9F/1.API-Resource-%E4%B8%8E-Object/API-%E5%8F%82%E8%80%83/API-%E5%8F%82%E8%80%83/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.23">官方文档，参考-API 概述-API&lt;/a>(这里是通过单一页面显示 API 资源各字段详解)
&lt;ul>
&lt;li>链接里是 1.23 的，想查看其他版本 API，改变 URL 中的版本即可。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;a href="https://kubernetes.io/docs/reference/kubernetes-api/">官方文档，参考-KubernetesAPI&lt;/a>(这里是通过多级页面显示 API 资源各字段详解)
&lt;ul>
&lt;li>这些连接的内容，其实是 &lt;code>kubectl explain&lt;/code> 命令的内容显示在浏览器中了。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;a href="https://github.com/kubernetes/kubernetes/blob/master/api/openapi-spec/swagger.json">OpeaAPI 格式文档&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>在 &lt;a href="https://www.yuque.com/go/doc/33168662">Kubernetes API&lt;/a> 章节，已经可以看到单一页面的详解中对 API 的分类，在本笔记后面的部分对各资源 Manifest 详解中，其实已经描述了 API 中各个字段的含义。所以本篇文章不会详解每个 API，而是记录一下如何通过 Kubernetes 官网来查找 API 详解，以及如何使用官方文档查看 API 详解。&lt;/p>
&lt;p>如果笔记中记录得不够详细，&lt;code>kubectl explain&lt;/code> 命令也看着不方便，那么通过这篇文章中介绍的官方文档中的 API 详解来查看，将会更加直观。&lt;/p>
&lt;p>&lt;strong>Kubernetes API 参考中将会描述每种资源的 Manifests 中每个字段(即.YAML 中的节点)的含义。&lt;/strong>&lt;/p>
&lt;p>下面是文档中占位符说明：
&lt;strong>[]TYPE&lt;/strong> # 表示该字段由数组组成，数组元素类型为 TYPE，比如 []STRING 格式应该就是下面这样&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-yaml" data-lang="yaml">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">args&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#ae81ff">deletecr&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - --&lt;span style="color:#ae81ff">ns&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - --&lt;span style="color:#ae81ff">name&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;strong>map[STRING]STRING&lt;/strong> # 表示多个键/值对。键 和 值 的数据类型都是 STRING。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-yaml" data-lang="yaml">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">labels&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">key1&lt;/span>: &lt;span style="color:#ae81ff">value1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">key2&lt;/span>: &lt;span style="color:#ae81ff">value2&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;strong>OBJECT&lt;/strong> # 表示复合结构的 map。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-yaml" data-lang="yaml">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">resources&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">limits&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">cpu&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;2&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">memory&lt;/span>: &lt;span style="color:#ae81ff">2Gi&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">requests&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">cpu&lt;/span>: &lt;span style="color:#ae81ff">500m&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">memory&lt;/span>: &lt;span style="color:#ae81ff">400Mi&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;strong>[]OBJECT&lt;/strong> # 表示该字段由数组组成，并且数组中的元素都是一个 OBJECT，比如格式应该像下面这样&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-yaml" data-lang="yaml">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">containers&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#f92672">args&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#ae81ff">AAA&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#ae81ff">BBB&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">name&lt;/span>: &lt;span style="color:#ae81ff">XXX&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">image&lt;/span>: &lt;span style="color:#ae81ff">XXX&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#f92672">name&lt;/span>: &lt;span style="color:#ae81ff">YYY&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">image&lt;/span>: &lt;span style="color:#ae81ff">YYY&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;strong>在每种资源的 Manifests 中，会有一些共用的部分称为&lt;/strong>[&lt;strong>通用定义&lt;/strong>](/docs/IT学习笔记/10.云原生/2.3.Kubernetes%20 容器编排系统/1.API、Resource(资源)、Object(对象)/API%20 参考/Common%20Definitions(通用定义).md 参考/Common Definitions(通用定义).md)&lt;strong>（也可以说是功能定义），比如常见的 &lt;strong>[&lt;strong>LabelSelector&lt;/strong>](/docs/IT学习笔记/10.云原生/2.3.Kubernetes%20 容器编排系统/1.API、Resource(资源)、Object(对象)/API%20 参考/Common%20Definitions(通用定义)/LabelSelector%20 详解.md 参考/Common Definitions(通用定义)/LabelSelector 详解.md)&lt;/strong>，这属于资源的 Manifests 的一部分。很多组件在解析 Manifests 中的通用定义时，都会遵循相同的规则。除了通用定义以外的，都属于 K8S 的资源定义，比如定义 &lt;strong>[&lt;strong>Pod&lt;/strong>](/docs/IT学习笔记/10.云原生/2.3.Kubernetes%20 容器编排系统/1.API、Resource(资源)、Object(对象)/API%20 参考/工作负载资源/Pod%20Manifest%20 详解.md 参考/工作负载资源/Pod Manifest 详解.md)&lt;/strong> 的 API 参考、定义 &lt;strong>[&lt;strong>Service&lt;/strong>](/docs/IT学习笔记/10.云原生/2.3.Kubernetes%20 容器编排系统/1.API、Resource(资源)、Object(对象)/API%20 参考/服务资源/Service%20Manifests%20 详解.md 参考/服务资源/Service Manifests 详解.md)&lt;/strong> 的 API 参考等等。&lt;/strong>&lt;/p>
&lt;p>这是单一页面的样子。左侧是根据对资源的分类而形成的目录，右侧是完整的页面
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/dkxdpv/1616120193938-a171af16-575d-4de6-951a-99cdca271a50.png" alt="">
这是多级页面的样子，该 API 详解是内含在官方文档中的，并且对 API 进行了细致的分类
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/dkxdpv/1616120193972-2c538ed5-7a6f-4aca-bf11-732240aa84d6.png" alt="">&lt;/p>
&lt;h2 id="kubernetes-api-删除和弃用流程">Kubernetes API 删除和弃用流程&lt;/h2>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://kubernetes.io/docs/reference/using-api/deprecation-policy/">官方文档，参考-API 概述-Kubernetes 弃用策略&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>Kubernetes 项目有一个记录良好的特性弃用策略[1]。该策略规定，只有当同一 API 的更新的、稳定的版本可用时，才可以弃用稳定的 API，并且 API 对于每个稳定性级别都有一个最短的生存期。给弃用的 API，是在未来的 Kubernetes 版本中被标记为删除的 API；它将继续运行，直到给删除（从弃用至少一年），但使用将导致显示警告。删除的 API 在当前版本中不再可用，此时你必须迁移到使用替换的 API。&lt;/p>
&lt;ul>
&lt;li>GA（Generally available，普遍可用）或稳定的 API 版本可能会被标记为弃用，但不得在 Kubernetes 的主要版本中删除。&lt;/li>
&lt;li>测试版或预发布 API 版本弃用后，必须支持 3 个版本。&lt;/li>
&lt;li>Alpha 或实验 API 版本可能会在任何版本中被删除，恕不另行通知。&lt;/li>
&lt;/ul>
&lt;p>无论某个 API 是因为某个功能从测试版升级到稳定版而被删除，还是因为该 API 没有成功，所有的删除都遵循这个弃用策略。每当删除一个 API 时，迁移选项都会在文档中提供说明。&lt;/p>
&lt;h1 id="api-分类">API 分类&lt;/h1>
&lt;ul>
&lt;li>[Workloads Resources](/docs/IT学习笔记/10.云原生/2.3.Kubernetes%20 容器编排系统/1.API、Resource(资源)、Object(对象)/API%20 参考/工作负载资源.md 参考/工作负载资源.md)(工作负载资源)&lt;/li>
&lt;li>&lt;a href="https://kubernetes.io/docs/reference/kubernetes-api/service-resources/">Services Resources&lt;/a>(服务资源)&lt;/li>
&lt;li>&lt;a href="https://kubernetes.io/docs/reference/kubernetes-api/config-and-storage-resources/">Config and Storage Resources&lt;/a>(配置与存储资源)&lt;/li>
&lt;li>&lt;a href="https://kubernetes.io/docs/reference/kubernetes-api/authentication-resources/">Authentication Resources&lt;/a>(认证资源)&lt;/li>
&lt;li>&lt;a href="https://kubernetes.io/docs/reference/kubernetes-api/authorization-resources/">Authorization Resources&lt;/a>(授权资源)&lt;/li>
&lt;li>&lt;a href="https://kubernetes.io/docs/reference/kubernetes-api/policies-resources/">Policies Resources&lt;/a>(策略资源)&lt;/li>
&lt;li>&lt;a href="https://kubernetes.io/docs/reference/kubernetes-api/extend-resources/">Extend Resources&lt;/a>(扩展资源)&lt;/li>
&lt;li>&lt;a href="https://kubernetes.io/docs/reference/kubernetes-api/cluster-resources/">Cluster Resources&lt;/a>(集群资源)&lt;/li>
&lt;li>&lt;a href="https://kubernetes.io/docs/reference/kubernetes-api/common-definitions/">Common Definitions&lt;/a>(通用定义) # 在多种资源 API 中，可以使用的 API。比如 节点选择器、meta 字段 等等&lt;/li>
&lt;li>&lt;a href="https://kubernetes.io/docs/reference/kubernetes-api/common-parameters/common-parameters/">Common Parameters&lt;/a>&lt;/li>
&lt;/ul>
&lt;h2 id="config-and-storage-resources">Config and Storage Resources&lt;/h2>
&lt;h5 id="configmaphttpskubernetesiodocsreferencekubernetes-apiconfig-and-storage-resourcesconfig-map-v1">&lt;a href="https://kubernetes.io/docs/reference/kubernetes-api/config-and-storage-resources/config-map-v1/">ConfigMap&lt;/a>&lt;/h5>
&lt;p>ConfigMap holds configuration data for pods to consume.&lt;/p>
&lt;h5 id="secrethttpskubernetesiodocsreferencekubernetes-apiconfig-and-storage-resourcessecret-v1">&lt;a href="https://kubernetes.io/docs/reference/kubernetes-api/config-and-storage-resources/secret-v1/">Secret&lt;/a>&lt;/h5>
&lt;p>Secret holds secret data of a certain type.&lt;/p>
&lt;h5 id="volumehttpskubernetesiodocsreferencekubernetes-apiconfig-and-storage-resourcesvolume">&lt;a href="https://kubernetes.io/docs/reference/kubernetes-api/config-and-storage-resources/volume/">Volume&lt;/a>&lt;/h5>
&lt;p>Volume represents a named volume in a pod that may be accessed by any container in the pod.&lt;/p>
&lt;h5 id="persistentvolumeclaimhttpskubernetesiodocsreferencekubernetes-apiconfig-and-storage-resourcespersistent-volume-claim-v1">&lt;a href="https://kubernetes.io/docs/reference/kubernetes-api/config-and-storage-resources/persistent-volume-claim-v1/">PersistentVolumeClaim&lt;/a>&lt;/h5>
&lt;p>PersistentVolumeClaim is a user&amp;rsquo;s request for and claim to a persistent volume.&lt;/p>
&lt;h5 id="persistentvolumehttpskubernetesiodocsreferencekubernetes-apiconfig-and-storage-resourcespersistent-volume-v1">&lt;a href="https://kubernetes.io/docs/reference/kubernetes-api/config-and-storage-resources/persistent-volume-v1/">PersistentVolume&lt;/a>&lt;/h5>
&lt;p>PersistentVolume (PV) is a storage resource provisioned by an administrator.&lt;/p>
&lt;h5 id="storageclasshttpskubernetesiodocsreferencekubernetes-apiconfig-and-storage-resourcesstorage-class-v1">&lt;a href="https://kubernetes.io/docs/reference/kubernetes-api/config-and-storage-resources/storage-class-v1/">StorageClass&lt;/a>&lt;/h5>
&lt;p>StorageClass describes the parameters for a class of storage for which PersistentVolumes can be dynamically provisioned.&lt;/p>
&lt;h5 id="volumeattachmenthttpskubernetesiodocsreferencekubernetes-apiconfig-and-storage-resourcesvolume-attachment-v1">&lt;a href="https://kubernetes.io/docs/reference/kubernetes-api/config-and-storage-resources/volume-attachment-v1/">VolumeAttachment&lt;/a>&lt;/h5>
&lt;p>VolumeAttachment captures the intent to attach or detach the specified volume to/from the specified node.&lt;/p>
&lt;h5 id="csidriverhttpskubernetesiodocsreferencekubernetes-apiconfig-and-storage-resourcescsi-driver-v1">&lt;a href="https://kubernetes.io/docs/reference/kubernetes-api/config-and-storage-resources/csi-driver-v1/">CSIDriver&lt;/a>&lt;/h5>
&lt;p>CSIDriver captures information about a Container Storage Interface (CSI) volume driver deployed on the cluster.&lt;/p>
&lt;h5 id="csinodehttpskubernetesiodocsreferencekubernetes-apiconfig-and-storage-resourcescsi-node-v1">&lt;a href="https://kubernetes.io/docs/reference/kubernetes-api/config-and-storage-resources/csi-node-v1/">CSINode&lt;/a>&lt;/h5>
&lt;p>CSINode holds information about all CSI drivers installed on a node.&lt;/p>
&lt;h5 id="csistoragecapacity-v1beta1httpskubernetesiodocsreferencekubernetes-apiconfig-and-storage-resourcescsi-storage-capacity-v1beta1">&lt;a href="https://kubernetes.io/docs/reference/kubernetes-api/config-and-storage-resources/csi-storage-capacity-v1beta1/">CSIStorageCapacity v1beta1&lt;/a>&lt;/h5>
&lt;p>CSIStorageCapacity stores the result of one CSI GetCapacity call.&lt;/p>
&lt;h2 id="authentication-resources">Authentication Resources&lt;/h2>
&lt;h5 id="serviceaccounthttpskubernetesiodocsreferencekubernetes-apiauthentication-resourcesservice-account-v1">&lt;a href="https://kubernetes.io/docs/reference/kubernetes-api/authentication-resources/service-account-v1/">ServiceAccount&lt;/a>&lt;/h5>
&lt;p>ServiceAccount binds together: _ a name, understood by users, and perhaps by peripheral systems, for an identity _ a principal that can be authenticated and authorized * a set of secrets.&lt;/p>
&lt;h5 id="tokenrequesthttpskubernetesiodocsreferencekubernetes-apiauthentication-resourcestoken-request-v1">&lt;a href="https://kubernetes.io/docs/reference/kubernetes-api/authentication-resources/token-request-v1/">TokenRequest&lt;/a>&lt;/h5>
&lt;p>TokenRequest requests a token for a given service account.&lt;/p>
&lt;h5 id="tokenreviewhttpskubernetesiodocsreferencekubernetes-apiauthentication-resourcestoken-review-v1">&lt;a href="https://kubernetes.io/docs/reference/kubernetes-api/authentication-resources/token-review-v1/">TokenReview&lt;/a>&lt;/h5>
&lt;p>TokenReview attempts to authenticate a token to a known user.&lt;/p>
&lt;h5 id="certificatesigningrequesthttpskubernetesiodocsreferencekubernetes-apiauthentication-resourcescertificate-signing-request-v1">&lt;a href="https://kubernetes.io/docs/reference/kubernetes-api/authentication-resources/certificate-signing-request-v1/">CertificateSigningRequest&lt;/a>&lt;/h5>
&lt;p>CertificateSigningRequest objects provide a mechanism to obtain x509 certificates by submitting a certificate signing request, and having it asynchronously approved and issued.&lt;/p>
&lt;h2 id="authorization-resources">Authorization Resources&lt;/h2>
&lt;h5 id="localsubjectaccessreviewhttpskubernetesiodocsreferencekubernetes-apiauthorization-resourceslocal-subject-access-review-v1">&lt;a href="https://kubernetes.io/docs/reference/kubernetes-api/authorization-resources/local-subject-access-review-v1/">LocalSubjectAccessReview&lt;/a>&lt;/h5>
&lt;p>LocalSubjectAccessReview checks whether or not a user or group can perform an action in a given namespace.&lt;/p>
&lt;h5 id="selfsubjectaccessreviewhttpskubernetesiodocsreferencekubernetes-apiauthorization-resourcesself-subject-access-review-v1">&lt;a href="https://kubernetes.io/docs/reference/kubernetes-api/authorization-resources/self-subject-access-review-v1/">SelfSubjectAccessReview&lt;/a>&lt;/h5>
&lt;p>SelfSubjectAccessReview checks whether or the current user can perform an action.&lt;/p>
&lt;h5 id="selfsubjectrulesreviewhttpskubernetesiodocsreferencekubernetes-apiauthorization-resourcesself-subject-rules-review-v1">&lt;a href="https://kubernetes.io/docs/reference/kubernetes-api/authorization-resources/self-subject-rules-review-v1/">SelfSubjectRulesReview&lt;/a>&lt;/h5>
&lt;p>SelfSubjectRulesReview enumerates the set of actions the current user can perform within a namespace.&lt;/p>
&lt;h5 id="subjectaccessreviewhttpskubernetesiodocsreferencekubernetes-apiauthorization-resourcessubject-access-review-v1">&lt;a href="https://kubernetes.io/docs/reference/kubernetes-api/authorization-resources/subject-access-review-v1/">SubjectAccessReview&lt;/a>&lt;/h5>
&lt;p>SubjectAccessReview checks whether or not a user or group can perform an action.&lt;/p>
&lt;h5 id="clusterrolehttpskubernetesiodocsreferencekubernetes-apiauthorization-resourcescluster-role-v1">&lt;a href="https://kubernetes.io/docs/reference/kubernetes-api/authorization-resources/cluster-role-v1/">ClusterRole&lt;/a>&lt;/h5>
&lt;p>ClusterRole is a cluster level, logical grouping of PolicyRules that can be referenced as a unit by a RoleBinding or ClusterRoleBinding.&lt;/p>
&lt;h5 id="clusterrolebindinghttpskubernetesiodocsreferencekubernetes-apiauthorization-resourcescluster-role-binding-v1">&lt;a href="https://kubernetes.io/docs/reference/kubernetes-api/authorization-resources/cluster-role-binding-v1/">ClusterRoleBinding&lt;/a>&lt;/h5>
&lt;p>ClusterRoleBinding references a ClusterRole, but not contain it.&lt;/p>
&lt;h5 id="rolehttpskubernetesiodocsreferencekubernetes-apiauthorization-resourcesrole-v1">&lt;a href="https://kubernetes.io/docs/reference/kubernetes-api/authorization-resources/role-v1/">Role&lt;/a>&lt;/h5>
&lt;p>Role is a namespaced, logical grouping of PolicyRules that can be referenced as a unit by a RoleBinding.&lt;/p>
&lt;h5 id="rolebindinghttpskubernetesiodocsreferencekubernetes-apiauthorization-resourcesrole-binding-v1">&lt;a href="https://kubernetes.io/docs/reference/kubernetes-api/authorization-resources/role-binding-v1/">RoleBinding&lt;/a>&lt;/h5>
&lt;p>RoleBinding references a role, but does not contain it.&lt;/p>
&lt;h2 id="policies-resources">Policies Resources&lt;/h2>
&lt;h5 id="limitrangehttpskubernetesiodocsreferencekubernetes-apipolicy-resourceslimit-range-v1">&lt;a href="https://kubernetes.io/docs/reference/kubernetes-api/policy-resources/limit-range-v1/">LimitRange&lt;/a>&lt;/h5>
&lt;p>LimitRange sets resource usage limits for each kind of resource in a Namespace.&lt;/p>
&lt;h5 id="resourcequotahttpskubernetesiodocsreferencekubernetes-apipolicy-resourcesresource-quota-v1">&lt;a href="https://kubernetes.io/docs/reference/kubernetes-api/policy-resources/resource-quota-v1/">ResourceQuota&lt;/a>&lt;/h5>
&lt;p>ResourceQuota sets aggregate quota restrictions enforced per namespace.&lt;/p>
&lt;h5 id="networkpolicyhttpskubernetesiodocsreferencekubernetes-apipolicy-resourcesnetwork-policy-v1">&lt;a href="https://kubernetes.io/docs/reference/kubernetes-api/policy-resources/network-policy-v1/">NetworkPolicy&lt;/a>&lt;/h5>
&lt;p>NetworkPolicy describes what network traffic is allowed for a set of Pods.&lt;/p>
&lt;h5 id="poddisruptionbudgethttpskubernetesiodocsreferencekubernetes-apipolicy-resourcespod-disruption-budget-v1">&lt;a href="https://kubernetes.io/docs/reference/kubernetes-api/policy-resources/pod-disruption-budget-v1/">PodDisruptionBudget&lt;/a>&lt;/h5>
&lt;p>PodDisruptionBudget is an object to define the max disruption that can be caused to a collection of pods.&lt;/p>
&lt;h5 id="podsecuritypolicy-v1beta1httpskubernetesiodocsreferencekubernetes-apipolicy-resourcespod-security-policy-v1beta1">&lt;a href="https://kubernetes.io/docs/reference/kubernetes-api/policy-resources/pod-security-policy-v1beta1/">PodSecurityPolicy v1beta1&lt;/a>&lt;/h5>
&lt;p>PodSecurityPolicy governs the ability to make requests that affect the Security Context that will be applied to a pod and container.&lt;/p>
&lt;h2 id="extend-resources">Extend Resources&lt;/h2>
&lt;h5 id="customresourcedefinitionhttpskubernetesiodocsreferencekubernetes-apiextend-resourcescustom-resource-definition-v1">&lt;a href="https://kubernetes.io/docs/reference/kubernetes-api/extend-resources/custom-resource-definition-v1/">CustomResourceDefinition&lt;/a>&lt;/h5>
&lt;p>CustomResourceDefinition represents a resource that should be exposed on the API server.&lt;/p>
&lt;h5 id="mutatingwebhookconfigurationhttpskubernetesiodocsreferencekubernetes-apiextend-resourcesmutating-webhook-configuration-v1">&lt;a href="https://kubernetes.io/docs/reference/kubernetes-api/extend-resources/mutating-webhook-configuration-v1/">MutatingWebhookConfiguration&lt;/a>&lt;/h5>
&lt;p>MutatingWebhookConfiguration describes the configuration of and admission webhook that accept or reject and may change the object.&lt;/p>
&lt;h5 id="validatingwebhookconfigurationhttpskubernetesiodocsreferencekubernetes-apiextend-resourcesvalidating-webhook-configuration-v1">&lt;a href="https://kubernetes.io/docs/reference/kubernetes-api/extend-resources/validating-webhook-configuration-v1/">ValidatingWebhookConfiguration&lt;/a>&lt;/h5>
&lt;p>ValidatingWebhookConfiguration describes the configuration of and admission webhook that accept or reject and object without changing it.&lt;/p>
&lt;h2 id="cluster-resources">Cluster Resources&lt;/h2>
&lt;h5 id="nodehttpskubernetesiodocsreferencekubernetes-apicluster-resourcesnode-v1">&lt;a href="https://kubernetes.io/docs/reference/kubernetes-api/cluster-resources/node-v1/">Node&lt;/a>&lt;/h5>
&lt;p>Node is a worker node in Kubernetes.&lt;/p>
&lt;h5 id="namespacehttpskubernetesiodocsreferencekubernetes-apicluster-resourcesnamespace-v1">&lt;a href="https://kubernetes.io/docs/reference/kubernetes-api/cluster-resources/namespace-v1/">Namespace&lt;/a>&lt;/h5>
&lt;p>Namespace provides a scope for Names.&lt;/p>
&lt;h5 id="eventhttpskubernetesiodocsreferencekubernetes-apicluster-resourcesevent-v1">&lt;a href="https://kubernetes.io/docs/reference/kubernetes-api/cluster-resources/event-v1/">Event&lt;/a>&lt;/h5>
&lt;p>Event is a report of an event somewhere in the cluster.&lt;/p>
&lt;h5 id="apiservicehttpskubernetesiodocsreferencekubernetes-apicluster-resourcesapi-service-v1">&lt;a href="https://kubernetes.io/docs/reference/kubernetes-api/cluster-resources/api-service-v1/">APIService&lt;/a>&lt;/h5>
&lt;p>APIService represents a server for a particular GroupVersion.&lt;/p>
&lt;h5 id="leasehttpskubernetesiodocsreferencekubernetes-apicluster-resourceslease-v1">&lt;a href="https://kubernetes.io/docs/reference/kubernetes-api/cluster-resources/lease-v1/">Lease&lt;/a>&lt;/h5>
&lt;p>Lease defines a lease concept.&lt;/p>
&lt;h5 id="runtimeclasshttpskubernetesiodocsreferencekubernetes-apicluster-resourcesruntime-class-v1">&lt;a href="https://kubernetes.io/docs/reference/kubernetes-api/cluster-resources/runtime-class-v1/">RuntimeClass&lt;/a>&lt;/h5>
&lt;p>RuntimeClass defines a class of container runtime supported in the cluster.&lt;/p>
&lt;h5 id="flowschema-v1beta1httpskubernetesiodocsreferencekubernetes-apicluster-resourcesflow-schema-v1beta1">&lt;a href="https://kubernetes.io/docs/reference/kubernetes-api/cluster-resources/flow-schema-v1beta1/">FlowSchema v1beta1&lt;/a>&lt;/h5>
&lt;p>FlowSchema defines the schema of a group of flows.&lt;/p>
&lt;h5 id="prioritylevelconfiguration-v1beta1httpskubernetesiodocsreferencekubernetes-apicluster-resourcespriority-level-configuration-v1beta1">&lt;a href="https://kubernetes.io/docs/reference/kubernetes-api/cluster-resources/priority-level-configuration-v1beta1/">PriorityLevelConfiguration v1beta1&lt;/a>&lt;/h5>
&lt;p>PriorityLevelConfiguration represents the configuration of a priority level.&lt;/p>
&lt;h5 id="bindinghttpskubernetesiodocsreferencekubernetes-apicluster-resourcesbinding-v1">&lt;a href="https://kubernetes.io/docs/reference/kubernetes-api/cluster-resources/binding-v1/">Binding&lt;/a>&lt;/h5>
&lt;p>Binding ties one object to another; for example, a pod is bound to a node by a scheduler.&lt;/p>
&lt;h5 id="componentstatushttpskubernetesiodocsreferencekubernetes-apicluster-resourcescomponent-status-v1">&lt;a href="https://kubernetes.io/docs/reference/kubernetes-api/cluster-resources/component-status-v1/">ComponentStatus&lt;/a>&lt;/h5>
&lt;p>ComponentStatus (and ComponentStatusList) holds the cluster validation info.&lt;/p></description></item><item><title>Docs: API 与 Resource</title><link>https://desistdaydream.github.io/docs/IT%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/10.%E4%BA%91%E5%8E%9F%E7%94%9F/2.3.Kubernetes-%E5%AE%B9%E5%99%A8%E7%BC%96%E6%8E%92%E7%B3%BB%E7%BB%9F/1.API-Resource-%E4%B8%8E-Object/API-%E4%B8%8E-Resource/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/IT%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/10.%E4%BA%91%E5%8E%9F%E7%94%9F/2.3.Kubernetes-%E5%AE%B9%E5%99%A8%E7%BC%96%E6%8E%92%E7%B3%BB%E7%BB%9F/1.API-Resource-%E4%B8%8E-Object/API-%E4%B8%8E-Resource/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://kubernetes.io/docs/concepts/overview/kubernetes-api/">官方文档，概念-概述-Kubernetes API&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://kubernetes.io/docs/reference/using-api/">官方文档，参考-API 概述&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>Kubernetes API 使我们可以查询和操纵 Kubernetes API 中资源的状态。Kubernetes API 符合 &lt;a href="https://www.yuque.com/go/doc/33220383">RESTful 规范&lt;/a>。&lt;/p>
&lt;p>Kubernetes 把自身一切抽象理解为 &lt;strong>Resource(资源)&lt;/strong>，也叫 &lt;strong>API Resource&lt;/strong>(有地方也叫 Group Resource)。对集群的所有操作都是通过对 Kubernetes API 的 HTTP(s) 请求来实现的。可以使用命令 kubectl api-resources 命令查看所有支持的资源。&lt;/p>
&lt;p>kubernetes 控制平面的核心是 &lt;strong>API Server&lt;/strong>。API Server 是实现了 Kubernets API 的应用程序，并为 Kubernetes 公开了一个 HTTP(s) 的 API，以供用户、集群中的不同部分和集群外部组件相互通信。&lt;/p>
&lt;p>Kubernetes 中各种资源(对象)的数据都通过 API 接口被提交到后端的持久化存储（etcd）中，Kubernetes 集群中的各部件之间通过该 API 接口实现解耦合，同时 Kubernetes 集群中一个重要且便捷的管理工具 kubectl 也是通过访问该 API 接口实现其强大的管理功能的。&lt;/p>
&lt;blockquote>
&lt;p>Note：kubectl 就是代替用户执行各种 http 请求的工具&lt;/p>
&lt;/blockquote>
&lt;p>在 Kubernetes 系统中，在大多数情况下，API 定义和实现都符合标准的 HTTP REST 格式，比如通过标准的 HTTP 动词（POST、PUT、GET、DELETE）来完成对相关资源对象的查询、创建、修改、删除等操作。但同时，Kubernetes 也为某些非标准的 REST 行为实现了附加的 API 接口，例如 Watch 某个资源的变化、进入容器执行某个操作等。另外，某些 API 接口可能违背严格的 REST 模式，因为接口返回的不是单一的 JSON 对象，而是其他类型的数据，比如 JSON 对象流或非结构化的文本日志数据等。&lt;/p>
&lt;p>另外，从另一个角度看，其实 kubernetes 就是提供了一个 web 服务，只是这个 web 服务不像传统的 B/S 架构那样，可以通过浏览器直接操作~kubernetes API 就是这个 web 服务的入口。&lt;/p>
&lt;blockquote>
&lt;p>注意：Kubernetes 的 API 与传统意义上的 API 不太一样。传统 API，一个 API 就是一个功能；而 Kubernetes API 中，一个 API 实际上又可以当作功能，也可以当作一个资源。对 API 的操作，就是对 Kubernets 资源进行操作&lt;/p>
&lt;/blockquote>
&lt;h2 id="api-resource资源-分类">API Resource(资源) 分类&lt;/h2>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://kubernetes.io/docs/reference/kubernetes-api/">官方文档，参考-kubernetes API&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.19/">1.19 版本 API 参考(一页模式)&lt;/a>(要查看其他版本，修改 URL 最后的版本号即可)。&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>资源大体可以分为下面几类：&lt;/p>
&lt;ul>
&lt;li>&lt;strong>workload(工作负载)&lt;/strong> # 用于在集群上管理和运行容器
&lt;ul>
&lt;li>Pod，Deployment，StatefuSet，DaemonSet，Job 等&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>Discovery &amp;amp; LB(服务发现及均衡)&lt;/strong> # 可以使用这些资源类型的对象将工作负载“缝合”到一个外部可访问的、负载均衡的服务中。
&lt;ul>
&lt;li>Service，Ingress 等&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>Config &amp;amp; Storage(配置与存储)&lt;/strong> # 这种类型的资源是用于将初始化数据注入到应用程序中并保留容器外部数据的对象。
&lt;ul>
&lt;li>Volume，ConifgMap，secret 等&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>Cluster(集群级资源)&lt;/strong> # 这种类型的资源对象定义了群集本身的配置方式。这些通常仅由集群运营商使用。
&lt;ul>
&lt;li>Namesapces,Node,Role,ClusterRole,RoleBinding,ClusterRoleBinding 等&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>Metadata(元数据型资源)&lt;/strong> # 这种类型的资源是用于配置集群中其他资源行为的对象。
&lt;ul>
&lt;li>HPA，PodTemplate，LimitRange 等&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>各种资源所用的 manifest 文件中的各个字段的含义就可以参考该页面找到详解。&lt;/p>
&lt;h2 id="api-resource资源-的-url-结构">API Resource(资源) 的 URL 结构&lt;/h2>
&lt;p>在 Kubernetes 中，资源的 URL 结构是由：Group（组）、Version（版本）和 Resource（资源种类）三个部分组成的。(还有一种 /metrics，/healthz 之类的结构，这里面的资源是系统自带的，不在任何组里)&lt;/p>
&lt;p>通过这样的结构，整个 Kubernetes 里的所有资源，实际上就可以用如下图的树形结构表示出来：&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/sz9hgm/1616120310758-dc53a2df-2a39-45e9-92e3-9beb5d9101f0.png" alt="">&lt;/p>
&lt;p>比如，如果要创建一个 CronJob 资源&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-yaml" data-lang="yaml">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">apiVersion&lt;/span>: &lt;span style="color:#ae81ff">batch/v2alpha1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">kind&lt;/span>: &lt;span style="color:#ae81ff">CronJob&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>在这个 YAML 文件中，“CronJob”就是资源的种类(Resource)，“batch”就是它的组(Group)，v2alpha1 就是它的版本(Version)。&lt;/p>
&lt;p>现阶段，有两个 API Groups 正在使用&lt;/p>
&lt;ul>
&lt;li>&lt;strong>core group(核心组)&lt;/strong> # 在/api/v1 路径下(由于某些历史原因而并没有在 &lt;code>/apis/core/v1&lt;/code> 路径下)。核心组是不需要 Group 的（即：它们 Group 是 &lt;code>&amp;quot;&amp;quot;&lt;/code>）。URI 路径为 &lt;code>/api/v1&lt;/code>，并且在定义资源的 manifest 文件中 apiVersion 字段的值不用包含组名，直接使用 v1 即可&lt;/li>
&lt;li>&lt;strong>named groups(已命名组)&lt;/strong> # URI 路径为 &lt;code>/apis/$GROUP_NAME/$VERSION&lt;/code>，在定义资源的 manifest 文件中 apiVersion 中省略 apis，使用 GroupName/Version&lt;/li>
&lt;/ul>
&lt;p>Notes:&lt;/p>
&lt;ul>
&lt;li>有的资源是 cluster 级别的(比如 node)，有的资源是 namespace 级别的(比如 pod)，对于 namespace 级别的资源，可以在 Version 和 Resource 中间添加 namespace 字段以获取指定 namespace 下的资源。i.e.&lt;code>/api/v1/namespaces/$NAMESPACE/pods/&lt;/code> (&lt;code>${NAMESPACE}&lt;/code> 就是具体的 namesapce 的名称)。&lt;/li>
&lt;li>所以 namesapce 级别资源的对象的 URI 应该像这样：&lt;code>/api/v1/namespaces/kube-system/pods/coredns-5644d7b6d9-tw4rh&lt;/code>&lt;/li>
&lt;li>而 cluster 级别资源的对象的 URI 则是：&lt;code>/api/v1/nodes/master1&lt;/code>&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>所有资源类型要么受集群范围限制（&lt;code>/apis/GROUP/VERSION/_&lt;/code>），要么受命名空间限制（&lt;code>/apis/GROUP/VERSION/namespaces/NAMESPACE/_&lt;/code>）&lt;/strong>&lt;/p>
&lt;p>集群范围的资源：&lt;/p>
&lt;ul>
&lt;li>GET /apis/GROUP/VERSION/RESOURCETYPE # 返回指定资源类型的资源集合(返回的是一个 list 列表，比如 NodeList 等)&lt;/li>
&lt;li>GET /apis/GROUP/VERSION/RESOURCETYPE/NAME # 返回指定资源类型下名为 NAME 的的资源&lt;/li>
&lt;/ul>
&lt;p>名称空间范围的资源：&lt;/p>
&lt;ul>
&lt;li>GET /apis/GROUP/VERSION/RESOURCETYPE # 返回所有名称空间指定资源类型的实例集合(返回的是一个 list 列表，比如 podList、serviceList 等)&lt;/li>
&lt;li>GET /apis/GROUP/VERSION/namespaces/NAMESPACE/RESOURCETYPE # 返回 NAMESPACE 下指定 ResourceType 的所有实例集合(返回的是一个 list 列表，比如 podList、serviceList 等)&lt;/li>
&lt;li>GET /apis/GROUP/VERSION/namespaces/NAMESPACE/RESOURCETYPE/NAME # 返回 NAMESPACE 下指定 ResourceType，名为 NAME 的实例&lt;/li>
&lt;/ul>
&lt;h1 id="declarative-api声明式-api-的特点">Declarative API(声明式 API) 的特点：&lt;/h1>
&lt;ul>
&lt;li>首先，所谓 &lt;strong>Declarative(声明式)&lt;/strong>，指的就是我只需要提交一个定义好的 API 对象来 &lt;strong>Declarative(声明)&lt;/strong> 我所期望的状态是什么样子。&lt;/li>
&lt;li>其次，“声明式 API”允许有多个 API 写端，以 PATCH 的方式对 API 对象进行修改，而无需关心本地原始 YAML 文件的内容。&lt;/li>
&lt;li>最后，也是最重要的，有了上述两个能力，Kubernetes 项目才可以基于对 API 对象的增、删、改、查，在完全无需外界干预的情况下，完成对“实际状态”和“期望状态”的调谐（Reconcile）过程。&lt;/li>
&lt;/ul>
&lt;p>所以说，声明式 API，才是 Kubernetes 项目编排能力“赖以生存”的核心所在。而想要实现 声明式 API，离不开 Controller 控制器，K8S 的大脑 的工作。&lt;/p>
&lt;h1 id="api-url-使用示例">API URL 使用示例&lt;/h1>
&lt;p>下面是在 1.18.8 版本下获取到的 api 路径结构&lt;/p>
&lt;p>根路径将列出所有可用路径&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-json" data-lang="json">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#960050;background-color:#1e0010">~]#&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">curl&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">--cacert&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">/etc/kubernetes/pki/ca.crt&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">-H&lt;/span> &lt;span style="color:#e6db74">&amp;#34;Authorization: Bearer ${TOKEN}&amp;#34;&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">https:&lt;/span>&lt;span style="color:#75715e">//172.38.40.215:6443/ -s
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;paths&amp;#34;&lt;/span>: [
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#34;/api&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#34;/api/v1&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#34;/apis&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#34;/apis/&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#34;/apis/admissionregistration.k8s.io&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#34;/apis/admissionregistration.k8s.io/v1&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#34;/apis/admissionregistration.k8s.io/v1beta1&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#34;/apis/apiextensions.k8s.io&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#34;/apis/apiextensions.k8s.io/v1&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#34;/apis/apiextensions.k8s.io/v1beta1&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#34;/apis/apiregistration.k8s.io&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#960050;background-color:#1e0010">......&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#960050;background-color:#1e0010">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>如果访问到错误的资源，还会返回 404 的响应码&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-json" data-lang="json">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#960050;background-color:#1e0010">~]#&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">curl&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">-s&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">--cacert&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">/etc/kubernetes/pki/ca.crt&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">-H&lt;/span> &lt;span style="color:#e6db74">&amp;#34;Authorization: Bearer ${TOKEN}&amp;#34;&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">https:&lt;/span>&lt;span style="color:#75715e">//172.38.40.215:6443/api/v1/service
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;kind&amp;#34;&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;Status&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;apiVersion&amp;#34;&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;v1&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;metadata&amp;#34;&lt;/span>: {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> },
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;status&amp;#34;&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;Failure&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;message&amp;#34;&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;the server could not find the requested resource&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;reason&amp;#34;&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;NotFound&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;details&amp;#34;&lt;/span>: {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> },
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;code&amp;#34;&lt;/span>: &lt;span style="color:#ae81ff">404&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>在“组/版本”下面可以看到该“组/版本”下所包含的 API 资源列表&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-json" data-lang="json">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#960050;background-color:#1e0010">~]#&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">curl&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">-s&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">--cacert&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">/etc/kubernetes/pki/ca.crt&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">-H&lt;/span> &lt;span style="color:#e6db74">&amp;#34;Authorization: Bearer ${TOKEN}&amp;#34;&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">https:&lt;/span>&lt;span style="color:#75715e">//172.38.40.215:6443/api/v1/
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;kind&amp;#34;&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;APIResourceList&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;groupVersion&amp;#34;&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;v1&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;resources&amp;#34;&lt;/span>: [
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#960050;background-color:#1e0010">.......&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;name&amp;#34;&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;configmaps&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;singularName&amp;#34;&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;namespaced&amp;#34;&lt;/span>: &lt;span style="color:#66d9ef">true&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;kind&amp;#34;&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;ConfigMap&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;verbs&amp;#34;&lt;/span>: [
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#34;create&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#34;delete&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#34;deletecollection&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#34;get&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#34;list&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#34;patch&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#34;update&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#34;watch&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ],
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;shortNames&amp;#34;&lt;/span>: [
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#34;cm&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ],
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;storageVersionHash&amp;#34;&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;qFsyl6wFWjQ=&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> },
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;name&amp;#34;&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;endpoints&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;singularName&amp;#34;&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;namespaced&amp;#34;&lt;/span>: &lt;span style="color:#66d9ef">true&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;kind&amp;#34;&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;Endpoints&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;verbs&amp;#34;&lt;/span>: [
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#34;create&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#34;delete&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#34;deletecollection&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#34;get&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#34;list&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#34;patch&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#34;update&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#34;watch&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ],
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;shortNames&amp;#34;&lt;/span>: [
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#34;ep&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ],
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;storageVersionHash&amp;#34;&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;fWeeMqaN/OA=&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> },
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#960050;background-color:#1e0010">......&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#960050;background-color:#1e0010">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>在“资源”下可以看到该“资源”下所包含的所有对象，下图是 pod 资源的列表，包含所有 pod 对象及其信息&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-json" data-lang="json">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#960050;background-color:#1e0010">~]#&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">curl&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">-s&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">--cacert&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">/etc/kubernetes/pki/ca.crt&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">-H&lt;/span> &lt;span style="color:#e6db74">&amp;#34;Authorization: Bearer ${TOKEN}&amp;#34;&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">https:&lt;/span>&lt;span style="color:#75715e">//172.38.40.215:6443/api/v1/pods | more
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;kind&amp;#34;&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;PodList&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;apiVersion&amp;#34;&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;v1&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;metadata&amp;#34;&lt;/span>: {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;selfLink&amp;#34;&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;/api/v1/pods&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;resourceVersion&amp;#34;&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;618871&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> },
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;items&amp;#34;&lt;/span>: [
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;metadata&amp;#34;&lt;/span>: {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;name&amp;#34;&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;cattle-cluster-agent-cc6ddc6dc-7f89l&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;generateName&amp;#34;&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;cattle-cluster-agent-cc6ddc6dc-&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;namespace&amp;#34;&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;cattle-system&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;selfLink&amp;#34;&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;/api/v1/namespaces/cattle-system/pods/cattle-cluster-agent-cc6ddc6dc-7f89l&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;uid&amp;#34;&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;72f4a825-feb2-416a-900d-d8401acc9a18&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;resourceVersion&amp;#34;&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;452264&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;creationTimestamp&amp;#34;&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;2020-09-13T09:59:49Z&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;labels&amp;#34;&lt;/span>: {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;app&amp;#34;&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;cattle-cluster-agent&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;pod-template-hash&amp;#34;&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;cc6ddc6dc&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> },
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;ownerReferences&amp;#34;&lt;/span>: [
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;apiVersion&amp;#34;&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;apps/v1&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;kind&amp;#34;&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;ReplicaSet&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;name&amp;#34;&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;cattle-cluster-agent-cc6ddc6dc&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;uid&amp;#34;&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;7d4b6cbe-d6d1-46e3-99e5-8410095880c7&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;controller&amp;#34;&lt;/span>: &lt;span style="color:#66d9ef">true&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;blockOwnerDeletion&amp;#34;&lt;/span>: &lt;span style="color:#66d9ef">true&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ],
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;managedFields&amp;#34;&lt;/span>: [
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#960050;background-color:#1e0010">......&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div></description></item><item><title>Docs: BPF 流量控制机制</title><link>https://desistdaydream.github.io/docs/IT%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2.Kernel%E5%86%85%E6%A0%B8/BPF/BPF-%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6%E6%9C%BA%E5%88%B6/BPF-%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6%E6%9C%BA%E5%88%B6/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/IT%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2.Kernel%E5%86%85%E6%A0%B8/BPF/BPF-%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6%E6%9C%BA%E5%88%B6/BPF-%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6%E6%9C%BA%E5%88%B6/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>Kernel 网络官方文档：&lt;a href="https://www.kernel.org/doc/html/latest/networking/filter.html#">LInux Socket Filtering aka Berkeley Packet Filter&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote></description></item><item><title>Docs: Ceph</title><link>https://desistdaydream.github.io/docs/IT%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/5.%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8/1.%E5%AD%98%E5%82%A8/%E5%AD%98%E5%82%A8%E7%9A%84%E5%9F%BA%E7%A1%80%E8%AE%BE%E6%96%BD%E6%9E%B6%E6%9E%84/Distributed-Storage%E5%88%86%E5%B8%83%E5%BC%8F%E5%AD%98%E5%82%A8/Ceph/Ceph/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/IT%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/5.%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8/1.%E5%AD%98%E5%82%A8/%E5%AD%98%E5%82%A8%E7%9A%84%E5%9F%BA%E7%A1%80%E8%AE%BE%E6%96%BD%E6%9E%B6%E6%9E%84/Distributed-Storage%E5%88%86%E5%B8%83%E5%BC%8F%E5%AD%98%E5%82%A8/Ceph/Ceph/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://ceph.io/">官网&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://docs.ceph.com/en/latest/">官方文档&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Ceph_(software)">Wiki,Ceph&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://blog.csdn.net/younger_china/article/details/73410727">https://blog.csdn.net/younger_china/article/details/73410727&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>Ceph 是一个开源的分布式存储系统，可以提供 对象存储、快存储、文件存储 能力。是一个 Software Defined Storage(软件定义存储) 的代表性产品。&lt;/p>
&lt;p>一个 Ceph 存储集群至少需要 Ceph Monitor、Ceph Manager、Ceph OSD 这三个组件；如果要运行 Ceph 文件系统客户端，则也需要 Ceph MDS。&lt;/p>
&lt;ul>
&lt;li>&lt;strong>Monitor&lt;/strong> # &lt;strong>Ceph Monitor(Ceph 监视器，简称 ceph-mon)&lt;/strong> 负责维护集群状态的映射关系。通常至少需要 3 个 ceph-mon 以实现高可用，多节点使用 Paxos 算法达成共识。
&lt;ul>
&lt;li>可以这么说，Ceph 集群就是指 ceph-mon 集群。ceph-mon 负责维护的集群状态，就是用来提供存储服务的。&lt;/li>
&lt;li>ceph-mon 映射、ceph-mgr 映射、ceph-osd 映射、ceph-mds 映射、ceph-crush 映射。这些映射是 Ceph 守护进程相互协调所需的关键集群状态，说白了，就是&lt;strong>映射关系&lt;/strong>。
&lt;ul>
&lt;li>这里的映射，英文用的是 Map，其实也有地图的意思，就是表示这个集群有多少个 ceph-mon、有多少个 ceph-mgr 等等，还有底层对象属于哪个 PG，等等等等，这些东西构成了一副 Ceph 的运行图。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>ceph-mon 还负责管理守护进程和客户端之间的身份验证。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>Manager&lt;/strong> # &lt;strong>Ceph Manager(Ceph 管理器，简称 ceph-mgr)&lt;/strong> 负责跟踪运行时指标和 Ceph 集群的当前状态，包括存储利用率、性能、系统负载等。通常至少需要 2 个 ceph-mgr 以实现高可用。
&lt;ul>
&lt;li>ceph-mgr 可以提供 Web 管理页面、关于 Ceph 集群的 Prometheus 格式的监控指标&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>OSD Daemon&lt;/strong> # &lt;strong>Ceph OSD Daemon(Ceph OSD 守护进程，简称 ceph-osd)&lt;/strong> 负责向 OSD 读写数据、处理数据复制、恢复、重新平衡，并通过检查其他 ceph-osd 的心跳向 ceph-mon 和 ceph-mgr 提供一些监控信息。通常至少需要 3 个 ceph-osd 以实现高科用。
&lt;ul>
&lt;li>&lt;strong>Object Storage Device(对象存储设备，简称 OSD)&lt;/strong> 是一个物理或逻辑上的存储单元(比如一块硬盘)，这是 Ceph 得以运行的最基本的存储单元。
&lt;ul>
&lt;li>有的时候，人们容易把 OSD 理解为 Ceph OSD Daemon，这俩是有本质区别的。因为在最早的时候，OSD 有两种含义，一种是 &lt;code>Object Storage Device&lt;/code> 另一种是 &lt;code>Object Storage Daemon&lt;/code>。由于这种称呼的模糊性，后来就将 Object Storage daemon 扩展为 OSD Daemon。OSD 则仅仅代表 Object Storage Device。只不过运行 OSD Daemon 的程序名称，依然沿用了 osd 的名字。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>注意，为了让每一个 OSD 都可以被单独使用并管理，所以每个 OSD 都有一个对应的 ceph-osd 进程来管理。一般情况，Ceph 集群中每个节点，除了系统盘做 Raid 以外，其他硬盘都会单独作为 OSD 使用，且一个节点会有大量磁盘来对应 OSD。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>MDS&lt;/strong> # &lt;strong>Ceph Metadata Server(Ceph 元数据服务器，简称 ceph-mds)&lt;/strong> 代表 Ceph 文件系统元数据。ceph-mds 允许 POSIX 文件系统用户执行基本命令(比如 ls、find 等)，而不会给 Ceph 集群带来巨大负担。
&lt;ul>
&lt;li>注意，Ceph 提供的 块存储 和 对象存储 功能并不使用 ceph-mds。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h2 id="架构">架构&lt;/h2>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://docs.ceph.com/en/latest/architecture/">官方文档，架构&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/sakrws/1630769971104-82bcc0c6-1dbd-4c47-b986-3e5b8321aac0.png" alt="image.png">&lt;/p>
&lt;p>&lt;strong>其实 Ceph 本身就是一个对象存储&lt;/strong>，基于&lt;strong>RADOS&lt;/strong> 实现，并通过 Ceph Client 为上层应用提供了通用的 块存储、文件存储、对象存储 的调用接口。&lt;/p>
&lt;ul>
&lt;li>&lt;strong>RADOS&lt;/strong> # &lt;strong>Reliable Autonomic Distributed Object Store(可靠的、自动化的分布式对象存储，简称 RADOS)&lt;/strong> 是一种由多个主机组成、由 CRUSH 算法实现数据路由的，分布式对象存储系统。是 Ceph 的底层存储系统。
&lt;ul>
&lt;li>OSD 是组成 RADOS 的基本存储单元。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>Ceph Client&lt;/strong> # &lt;strong>Ceph 客户端&lt;/strong>。是可以访问 Ceph 存储集群(即 RADOS) 的 Ceph 组件的集合。
&lt;ul>
&lt;li>&lt;strong>LIBRADOS&lt;/strong> # &lt;strong>Library RADOS(RADOS 库，简称 librados)&lt;/strong>。应用程序可以调用 librados 以直接访问 RADOS。当我们使用 Ceph 时，Ceph 实际上是调用 librados 的 API(这是一个 rpc 接口)，将提交的文件切分为固定大小的数据，存放到 RADOS 中。
&lt;ul>
&lt;li>同时，我们自己也可以使用 librados 开发出类似 ceph-rgw、ceph-rbd 这种应用程序以实现个性化需求。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>RADOSGW&lt;/strong> # &lt;strong>RADOS Gateway(RADOS 网关，简称 radosgw)&lt;/strong>。使用 librados 实现的应用程序，可以提供兼容 S3 和 Swift 对象存储的接口&lt;/li>
&lt;li>&lt;strong>RBD&lt;/strong> # &lt;strong>RADOS Block Device(RADOS 块设备，简称 RBD)&lt;/strong>。使用 librados 实现的应用程序，为 Linux 内核 和 QEMU/KVM 提供一个可靠且完全分布式的块存储设备。&lt;/li>
&lt;li>&lt;strong>CEPH FS&lt;/strong> # &lt;strong>Ceph File System(Ceph 文件系统，简称 CFS)&lt;/strong>。直接使用 RADOS 实现一个符合 POSIX 的分布式文件系统，带有 Linux 内核客户端并支持 FUSE，可以直接挂载使用。甚至可以进一步抽象，实现 NFS 功能。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h2 id="ceph-数据写入流程">Ceph 数据写入流程&lt;/h2>
&lt;p>Ceph 集群从 Ceph 的客户端接收到的数据后，将会切分为一个或多个固定大小的 &lt;strong>RADOS Object(RADOS 对象)&lt;/strong>。Ceph 使用 &lt;strong>Controlled Replication Under Scalable Hashing(简称 CRUSH)&lt;/strong> 算法计算出 RADOS 对象应该放在哪个 &lt;strong>Placement Group(归置组，简称 PG)&lt;/strong>，并进一步计算出，应该由哪个 ceph-osd 来处理这个 PG 并将 PG 存储到指定的 OSD 中。ceph-osd 会通过存储驱动器处理 RADOS 对象的 读、写 和 复制操作。&lt;/p>
&lt;blockquote>
&lt;p>注意：当创建完 Ceph 集群后，会有一个默认的 Pool，Pool 是用来对 PG 进行分组的，且 PG 必须属于一个组，不可独立存在。&lt;/p>
&lt;/blockquote>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/sakrws/1630834243384-b650e1e5-1c84-4846-bdc5-9180a361fb09.png" alt="image.png">&lt;/p>
&lt;p>RADOS 对象有如下几个部分组成&lt;/p>
&lt;ul>
&lt;li>&lt;strong>Object Identify(对象标识符，简称 OID)&lt;/strong> # OID 在整个 Ceph 集群中是唯一。&lt;/li>
&lt;li>&lt;strong>Binary Data(二进制数据数据)&lt;/strong> # 对象的数据&lt;/li>
&lt;li>&lt;strong>Metadata(元数据)&lt;/strong> # 元数据的语义完全取决于 Ceph 客户端。例如，CephFS 使用元数据来存储文件属性，如文件所有者、创建日期、上次修改日期等。&lt;/li>
&lt;/ul>
&lt;p>ceph-osd 将数据作为对象存储在平坦的命名空间中 (例如，没有目录层次结构)。对象具有标识符，二进制数据和由一组名称/值对组成的元数据。&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/sakrws/1630808425695-75766062-7570-47f0-9ae4-916c7819d113.png" alt="image.png">&lt;/p>
&lt;h1 id="rados">RADOS&lt;/h1>
&lt;p>与传统分布式存储不同，传统分布式存储中的 NameNode 极易形成性能瓶颈。基于此，RADOS 设计了一种新的方式来快速找到对象数据。RADOS 中并不需要 NameNode 来存储每个对象的元数据，RADOS 中的对象，都是通过 &lt;strong>Controlled Replication Under Scalable Hashing(简称 CRUSH)&lt;/strong> 算法来快速定位的。&lt;/p>
&lt;h2 id="bluestore">bluestore&lt;/h2>
&lt;p>这是 Ceph 所管理的 OSD 的文件系统类型&lt;/p>
&lt;h1 id="ceph-的存储能力">Ceph 的存储能力&lt;/h1>
&lt;h2 id="块存储">块存储&lt;/h2>
&lt;p>Ceph 通过 RDB 提供块存储能力&lt;/p>
&lt;h2 id="文件存储">文件存储&lt;/h2>
&lt;p>Ceph 通过 CEPHFS 提供文件存储能力&lt;/p>
&lt;h2 id="对象存储">对象存储&lt;/h2>
&lt;p>RADOS Gateway 简称 radosgw，Ceph 通过 radosgw 程序，可以对外提供标准的 S3 或 swift 接口，以实现主流对象存储功能。很多时候，radosgw 程序运行的进程称为 ceph-rgw&lt;/p>
&lt;h1 id="ceph-manager">Ceph Manager&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://docs.ceph.com/en/latest/mgr/">官方文档,Ceph 管理器&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>Ceph Manager 是通过一个名为 ceph-mgr 的二进制程序以守护进程运行的管理器。ceph-mgr 可以向外部监控和管理系统提供额外的监控和接口。&lt;/p>
&lt;p>ceph-mgr 曾经是 ceph-mon 的一部分，自 luinous(12.x) 版本依赖，ceph-mgr 独立出来，成为 Ceph 集群的必选组件。&lt;/p>
&lt;h2 id="dashboard-模块">Dashboard 模块&lt;/h2>
&lt;p>Dashboard 模块是一个内置的基于 Web 的 Ceph 管理和监控程序，通过它可以检查和管理 Ceph 集群中的各个方面和资源。默认监听 &lt;code>8443&lt;/code> 端口&lt;/p>
&lt;p>在 Dashboard 模块中，提供了一组用于管理集群的 RESTful 风格的 API 接口。这组 API 位于 &lt;code>/api&lt;/code> 路径下。详见《[API](&amp;lt;/docs/IT学习笔记/5.数据存储/1.存储/存储的基础设施架构/Distributed%20Storage(分布式存储)/Ceph/API.md&amp;raquo;)》章节&lt;/p>
&lt;h2 id="prometheus-模块">Prometheus 模块&lt;/h2>
&lt;p>启动 Prometheus 模块后，ceph-mgr 默认在 &lt;code>9283&lt;/code> 端口上暴露 Prometheus 格式的监控指标。&lt;/p>
&lt;h1 id="ceph-radosgw">Ceph RADOSGW&lt;/h1>
&lt;p>默认监听 &lt;code>7480&lt;/code> 端口&lt;/p></description></item><item><title>Docs: Common Definitions(通用定义)</title><link>https://desistdaydream.github.io/docs/IT%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/10.%E4%BA%91%E5%8E%9F%E7%94%9F/2.3.Kubernetes-%E5%AE%B9%E5%99%A8%E7%BC%96%E6%8E%92%E7%B3%BB%E7%BB%9F/1.API-Resource-%E4%B8%8E-Object/API-%E5%8F%82%E8%80%83/Common-Definitions%E9%80%9A%E7%94%A8%E5%AE%9A%E4%B9%89/Common-Definitions%E9%80%9A%E7%94%A8%E5%AE%9A%E4%B9%89/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/IT%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/10.%E4%BA%91%E5%8E%9F%E7%94%9F/2.3.Kubernetes-%E5%AE%B9%E5%99%A8%E7%BC%96%E6%8E%92%E7%B3%BB%E7%BB%9F/1.API-Resource-%E4%B8%8E-Object/API-%E5%8F%82%E8%80%83/Common-Definitions%E9%80%9A%E7%94%A8%E5%AE%9A%E4%B9%89/Common-Definitions%E9%80%9A%E7%94%A8%E5%AE%9A%E4%B9%89/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://kubernetes.io/docs/reference/kubernetes-api/common-definitions/">官方文档，参考-KubernetesAPI-通用定义&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;h1 id="common-definitions">Common Definitions&lt;/h1>
&lt;h5 id="deleteoptionshttpskubernetesiodocsreferencekubernetes-apicommon-definitionsdelete-options">&lt;a href="https://kubernetes.io/docs/reference/kubernetes-api/common-definitions/delete-options/">DeleteOptions&lt;/a>&lt;/h5>
&lt;p>DeleteOptions may be provided when deleting an API object.&lt;/p>
&lt;h5 id="labelselectordocsit学习笔记10云原生23kubernetes20容器编排系统1api20resource20与20objectapi20参考common20definitions通用定义labelselectormd">&lt;a href="docs/IT%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/10.%E4%BA%91%E5%8E%9F%E7%94%9F/2.3.Kubernetes%20%E5%AE%B9%E5%99%A8%E7%BC%96%E6%8E%92%E7%B3%BB%E7%BB%9F/1.API%20Resource%20%E4%B8%8E%20Object/API%20%E5%8F%82%E8%80%83/Common%20Definitions(%E9%80%9A%E7%94%A8%E5%AE%9A%E4%B9%89)/LabelSelector.md">LabelSelector&lt;/a>&lt;/h5>
&lt;p>A label selector is a label query over a set of resources.&lt;/p>
&lt;h5 id="listmetahttpskubernetesiodocsreferencekubernetes-apicommon-definitionslist-meta">&lt;a href="https://kubernetes.io/docs/reference/kubernetes-api/common-definitions/list-meta/">ListMeta&lt;/a>&lt;/h5>
&lt;p>ListMeta describes metadata that synthetic resources must have, including lists and various status objects.&lt;/p>
&lt;h5 id="localobjectreferencehttpskubernetesiodocsreferencekubernetes-apicommon-definitionslocal-object-reference">&lt;a href="https://kubernetes.io/docs/reference/kubernetes-api/common-definitions/local-object-reference/">LocalObjectReference&lt;/a>&lt;/h5>
&lt;p>LocalObjectReference contains enough information to let you locate the referenced object inside the same namespace.&lt;/p>
&lt;h5 id="nodeselectorrequirementhttpskubernetesiodocsreferencekubernetes-apicommon-definitionsnode-selector-requirement">&lt;a href="https://kubernetes.io/docs/reference/kubernetes-api/common-definitions/node-selector-requirement/">NodeSelectorRequirement&lt;/a>&lt;/h5>
&lt;p>A node selector requirement is a selector that contains values, a key, and an operator that relates the key and values.&lt;/p>
&lt;h5 id="objectfieldselectorhttpskubernetesiodocsreferencekubernetes-apicommon-definitionsobject-field-selector">&lt;a href="https://kubernetes.io/docs/reference/kubernetes-api/common-definitions/object-field-selector/">ObjectFieldSelector&lt;/a>&lt;/h5>
&lt;p>ObjectFieldSelector selects an APIVersioned field of an object.&lt;/p>
&lt;h5 id="objectmetadocsit学习笔记10云原生23kubernetes20容器编排系统1api20resource20与20objectapi20参考common20definitions通用定义objectmetamd">&lt;a href="docs/IT%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/10.%E4%BA%91%E5%8E%9F%E7%94%9F/2.3.Kubernetes%20%E5%AE%B9%E5%99%A8%E7%BC%96%E6%8E%92%E7%B3%BB%E7%BB%9F/1.API%20Resource%20%E4%B8%8E%20Object/API%20%E5%8F%82%E8%80%83/Common%20Definitions(%E9%80%9A%E7%94%A8%E5%AE%9A%E4%B9%89)/ObjectMeta.md">ObjectMeta&lt;/a>&lt;/h5>
&lt;p>ObjectMeta 是所有资源持久化成对象后必须要具有的元数据，其中包括对象的 名称、所在名称空间 等等。对应的 yaml 字段为 &lt;code>.metadata&lt;/code>&lt;/p>
&lt;h5 id="objectreferencehttpskubernetesiodocsreferencekubernetes-apicommon-definitionsobject-reference">&lt;a href="https://kubernetes.io/docs/reference/kubernetes-api/common-definitions/object-reference/">ObjectReference&lt;/a>&lt;/h5>
&lt;p>ObjectReference contains enough information to let you inspect or modify the referred object.&lt;/p>
&lt;h5 id="patchhttpskubernetesiodocsreferencekubernetes-apicommon-definitionspatch">&lt;a href="https://kubernetes.io/docs/reference/kubernetes-api/common-definitions/patch/">Patch&lt;/a>&lt;/h5>
&lt;p>Patch is provided to give a concrete name and type to the Kubernetes PATCH request body.&lt;/p>
&lt;h5 id="quantityhttpskubernetesiodocsreferencekubernetes-apicommon-definitionsquantity">&lt;a href="https://kubernetes.io/docs/reference/kubernetes-api/common-definitions/quantity/">Quantity&lt;/a>&lt;/h5>
&lt;p>Quantity is a fixed-point representation of a number.&lt;/p>
&lt;h5 id="resourcefieldselectorhttpskubernetesiodocsreferencekubernetes-apicommon-definitionsresource-field-selector">&lt;a href="https://kubernetes.io/docs/reference/kubernetes-api/common-definitions/resource-field-selector/">ResourceFieldSelector&lt;/a>&lt;/h5>
&lt;p>ResourceFieldSelector represents container resources (cpu, memory) and their output format.&lt;/p>
&lt;h5 id="statusdocsit学习笔记10云原生23kubernetes20容器编排系统1api20resource20与20objectapi20参考common20definitions通用定义statusmd">&lt;a href="docs/IT%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/10.%E4%BA%91%E5%8E%9F%E7%94%9F/2.3.Kubernetes%20%E5%AE%B9%E5%99%A8%E7%BC%96%E6%8E%92%E7%B3%BB%E7%BB%9F/1.API%20Resource%20%E4%B8%8E%20Object/API%20%E5%8F%82%E8%80%83/Common%20Definitions(%E9%80%9A%E7%94%A8%E5%AE%9A%E4%B9%89)/Status.md">Status&lt;/a>&lt;/h5>
&lt;p>Status 字段是不返回其他对象的调用的返回值。&lt;/p>
&lt;h5 id="typedlocalobjectreferencehttpskubernetesiodocsreferencekubernetes-apicommon-definitionstyped-local-object-reference">&lt;a href="https://kubernetes.io/docs/reference/kubernetes-api/common-definitions/typed-local-object-reference/">TypedLocalObjectReference&lt;/a>&lt;/h5>
&lt;p>TypedLocalObjectReference contains enough information to let you locate the typed referenced object inside the same namespace.&lt;/p></description></item><item><title>Docs: Containerd</title><link>https://desistdaydream.github.io/docs/IT%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/10.%E4%BA%91%E5%8E%9F%E7%94%9F/2.2.%E5%AE%9E%E7%8E%B0%E5%AE%B9%E5%99%A8%E7%9A%84%E5%B7%A5%E5%85%B7/Containerd/Containerd/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/IT%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/10.%E4%BA%91%E5%8E%9F%E7%94%9F/2.2.%E5%AE%9E%E7%8E%B0%E5%AE%B9%E5%99%A8%E7%9A%84%E5%B7%A5%E5%85%B7/Containerd/Containerd/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://containerd.io/">官网&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://github.com/containerd/containerd">GitHub 项目，containerd/containerd&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://github.com/containerd/containerd/blob/main/docs/PLUGINS.md">GitHub 项目文档，containerd/docs/PLUGINS.md&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://fuckcloudnative.io/posts/getting-started-with-containerd/">云原生实验室，Containerd 使用教程&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://blog.frognew.com/tags/containerd.html">架构小白，Containerd 标签&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://mp.weixin.qq.com/s/Dr6851XnkNLVFHaj1b13RQ">公众号-云原生实验室，容器中的 Shim 到底是个什么鬼&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>Containerd 是行业标准的容器运行时，着重于简单性，健壮性和可移植性。&lt;/p>
&lt;h2 id="containerd-的前世今生">Containerd 的前世今生&lt;/h2>
&lt;p>很久以前，Docker 强势崛起，以“镜像”这个大招席卷全球，对其他容器技术进行致命的降维打击，使其毫无招架之力，就连 Google 也不例外。Google 为了不被拍死在沙滩上，被迫拉下脸面（当然，跪舔是不可能的），希望 Docker 公司和自己联合推进一个开源的容器运行时作为 Docker 的核心依赖，不然就走着瞧。Docker 公司觉得自己的智商被侮辱了，走着瞧就走着瞧，谁怕谁啊！&lt;/p>
&lt;p>很明显，Docker 公司的这个决策断送了自己的大好前程，造成了今天的悲剧。&lt;/p>
&lt;p>紧接着，Google 联合 Red Hat、IBM 等几位巨佬连哄带骗忽悠 Docker 公司将 &lt;code>libcontainer&lt;/code> 捐给中立的社区（OCI，Open Container Intiative），并改名为 &lt;code>runc&lt;/code>，不留一点 Docker 公司的痕迹~~这还不够，为了彻底扭转 Docker 一家独大的局面，几位大佬又合伙成立了一个基金会叫 &lt;code>CNCF&lt;/code>（Cloud Native Computing Fundation），这个名字想必大家都很熟了，我就不详细介绍了。CNCF 的目标很明确，既然在当前的维度上干不过 Docker，干脆往上爬，升级到大规模容器编排的维度，以此来击败 Docker。Docker 公司当然不甘示弱，搬出了 Swarm 和 Kubernetes 进行 PK，最后的结局大家都知道了，Swarm 战败。然后 Docker 公司耍了个小聪明，将自己的核心依赖 &lt;code>Containerd&lt;/code> 捐给了 CNCF，以此来标榜 Docker 是一个 PaaS 平台。&lt;/p>
&lt;p>很明显，这个小聪明又大大加速了自己的灭亡。
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/ox2yd7/1616122481377-1a01b919-efe6-450a-a439-5493a17e6d70.png" alt="">
巨佬们心想，想当初想和你合作搞个中立的核心运行时，你死要面子活受罪，就是不同意，好家伙，现在自己搞了一个，还捐出来了，马老师，发生甚莫事了？&lt;/p>
&lt;p>这好吗？&lt;/p>
&lt;p>这不好&lt;/p>
&lt;p>也罢，这倒省事了，我就直接拿 &lt;code>Containerd&lt;/code> 来做文章吧。首先呢，为了表示 Kubernetes 的中立性，当然要搞个标准化的容器运行时接口，只要适配了这个接口的容器运行时，都可以和我一起玩耍哦，第一个支持这个接口的当然就是 &lt;code>Containerd&lt;/code> 啦。至于这个接口的名字，大家应该都知道了，它叫 CRI（Container Runntime Interface）。这样还不行，为了蛊惑 Docker 公司，Kubernetes 暂时先委屈自己，专门在自己的组件中集成了一个 &lt;code>shim&lt;/code>（你可以理解为垫片），用来将 CRI 的调用翻译成 Docker 的 API，让 Docker 也能和自己愉快地玩耍，温水煮青蛙，养肥了再杀。。。&lt;/p>
&lt;p>就这样，Kubernetes 一边假装和 Docker 愉快玩耍，一边背地里不断优化 Containerd 的健壮性以及和 CRI 对接的丝滑性。现在 Containerd 的翅膀已经完全硬了，是时候卸下我的伪装，和 Docker say bye bye 了。后面的事情大家也都知道了~~&lt;/p>
&lt;p>Docker 这门技术成功了，Docker 这个公司却失败了。&lt;/p>
&lt;h2 id="containerd-架构">Containerd 架构&lt;/h2>
&lt;p>时至今日，Containerd 已经变成一个工业级的容器运行时了，连口号都有了：超简单！超健壮！可移植性超强！&lt;/p>
&lt;p>当然，为了让 Docker 以为自己不会抢饭碗，Containerd 声称自己的设计目的主要是为了嵌入到一个更大的系统中（暗指 Kubernetes），而不是直接由开发人员或终端用户使用。&lt;/p>
&lt;p>事实上呢，Containerd 现在基本上啥都能干了，开发人员或者终端用户可以在宿主机中管理完整的容器生命周期，包括容器镜像的传输和存储、容器的执行和管理、存储和网络等。大家可以考虑学起来了。&lt;/p>
&lt;p>先来看看 Containerd 的架构：&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/ox2yd7/1616122481393-e3bb2fce-f18d-40ec-ac46-4c6d6a664cd6.png" alt="">&lt;/p>
&lt;p>可以看到 Containerd 仍然采用标准的 C/S 架构，服务端通过 &lt;code>GRPC&lt;/code> 协议提供稳定的 API，客户端通过调用服务端的 API 进行高级的操作。&lt;/p>
&lt;p>为了解耦，Containerd 将不同的职责划分给不同的组件，每个组件就相当于一个&lt;strong>子系统&lt;/strong>（subsystem）。连接不同子系统的组件被称为模块。&lt;/p>
&lt;p>总体上 Containerd 被划分为两个子系统：&lt;/p>
&lt;ul>
&lt;li>&lt;strong>Bundle&lt;/strong> : 在 Containerd 中，&lt;code>Bundle&lt;/code> 包含了配置、元数据和根文件系统数据，你可以理解为容器的文件系统。而 &lt;strong>Bundle 子系统&lt;/strong>允许用户从镜像中提取和打包 Bundles。&lt;/li>
&lt;li>&lt;strong>Runtime&lt;/strong> : Runtime 子系统用来执行 Bundles，比如创建容器。&lt;/li>
&lt;/ul>
&lt;p>其中，每一个子系统的行为都由一个或多个&lt;strong>模块&lt;/strong>协作完成（架构图中的 &lt;code>Core&lt;/code> 部分）。每一种类型的模块都以 &lt;strong>Plugin(插件)&lt;/strong> 的形式集成到 Containerd 中，而且插件之间是相互依赖的。例如，上图中的每一个长虚线的方框都表示一种类型的插件，包括 &lt;code>Service Plugin&lt;/code>、&lt;code>Metadata Plugin&lt;/code>、&lt;code>GC Plugin&lt;/code>、&lt;code>Runtime Plugin&lt;/code> 等，其中 &lt;code>Service Plugin&lt;/code> 又会依赖 Metadata Plugin、GC Plugin 和 Runtime Plugin。每一个小方框都表示一个细分的插件，例如 &lt;code>Metadata Plugin&lt;/code> 依赖 Containers Plugin、Content Plugin 等。总之，万物皆插件，插件就是模块，模块就是插件。&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/ox2yd7/1616122481388-5272b6c1-efb6-49f4-a180-5425bef8ed64.png" alt="">&lt;/p>
&lt;p>这里介绍几个常用的插件：&lt;/p>
&lt;ul>
&lt;li>&lt;strong>Content Plugin&lt;/strong> : 提供对镜像中可寻址内容的访问，所有不可变的内容都被存储在这里。&lt;/li>
&lt;li>&lt;strong>Snapshot Plugin&lt;/strong> : 用来管理容器镜像的文件系统快照。镜像中的每一个 layer 都会被解压成文件系统快照，类似于 Docker 中的 &lt;code>graphdriver&lt;/code>。&lt;/li>
&lt;li>&lt;strong>Metrics&lt;/strong> : 暴露各个组件的监控指标。&lt;/li>
&lt;/ul>
&lt;p>从总体来看，Containerd 被分为三个大块：&lt;code>Storage&lt;/code>、&lt;code>Metadata&lt;/code> 和 &lt;code>Runtime&lt;/code>，可以将上面的架构图提炼一下
：
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/ox2yd7/1616122481410-b77c18a6-2bcd-48be-b676-1b285bf1c862.png" alt="">&lt;/p>
&lt;p>这是使用 &lt;strong>bucketbench[1]&lt;/strong> 对 &lt;code>Docker&lt;/code>、&lt;code>crio&lt;/code> 和 &lt;code>Containerd&lt;/code> 的性能测试结果，包括启动、停止和删除容器，以比较它们所耗的时间：&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/ox2yd7/1616122481422-8a56805f-3ef0-46a4-be19-a0a5b1eef44f.png" alt="">&lt;/p>
&lt;p>可以看到 Containerd 在各个方面都表现良好，总体性能还是优越于 &lt;code>Docker&lt;/code> 和 &lt;code>crio&lt;/code> 的。&lt;/p>
&lt;h1 id="containerd-关联文件与配置">Containerd 关联文件与配置&lt;/h1>
&lt;p>&lt;strong>/etc/containerd/config.toml&lt;/strong> # Containerd 运行时配置文件。该文件可以通过 containerd config default 命令来生成一个默认的配置。&lt;/p>
&lt;p>&lt;strong>/var/lib/containerd/*&lt;/strong> # Root(根) 文件夹。用于保存持久化数据，镜像、元数据 所在路径。包括 Snapshots, Content, Metadata 以及各种插件的数据。每一个插件都有自己单独的目录，Containerd 本身不存储任何数据，它的所有功能都来自于已加载的插件。目录下的内容详解，见 &lt;a href="https://desistdaydream.github.io/docs/IT%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/10.%E4%BA%91%E5%8E%9F%E7%94%9F/2.2.%E5%AE%9E%E7%8E%B0%E5%AE%B9%E5%99%A8%E7%9A%84%E5%B7%A5%E5%85%B7/Containerd/Containerd%20Image.md">《Containerd Image 章节》&lt;/a>&lt;/p>
&lt;ul>
&lt;li>.&lt;strong>/io.containerd.content.v1.content/&lt;/strong> # 镜像的上下文保存目录
&lt;ul>
&lt;li>.&lt;strong>/blobs/&lt;/strong> # 镜像文件系统布局中。blobs 目录数据的存放路径&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>./io.containerd.snapshotter.v1.overlayfs/&lt;/strong> # 镜像的层信息所在目录。&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>/run/containerd/&lt;/strong> # State(状态) 文件夹。用于保存运行时产生的临时数据，也就是容器启动后数据存放目录。包括 sockets、pid、挂载点、运行时状态以及不需要持久化保存的插件数据。&lt;/p>
&lt;ul>
&lt;li>&lt;strong>./io.containerd.runtime.VERSION.ID/&lt;/strong> # Containerd 运行容器时所使用的 runtime 插件，该目录的名称就是插件的版本和名称。该目录下的目录以名称空间命名。
&lt;ul>
&lt;li>&lt;strong>./NAMESPACE/&lt;/strong> # 指定名称空间下的容器启动后的数据(主要就是符合 OCI 标准的 一组 Bundle 文件)保存路径，其内目录名为 ContainerID。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>/var/lib/containerd/ 与 /run/containerd/ 是 Containerd 最常用的两个目录，一个存镜像数据，一个存容器数据。&lt;/p>
&lt;h2 id="目录结构">目录结构&lt;/h2>
&lt;p>在 /var/lib/containerd 和 /run/containerd 目录下，保存了 Containerd 运行所需的所有数据。Containerd 本身不存储任何数据，所有数据都来源于插件的功能。
看一下目录下的层次结构就一目了然了：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>? → tree -L &lt;span style="color:#ae81ff">2&lt;/span> /var/lib/containerd/
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>/var/lib/containerd/
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>├── io.containerd.content.v1.content
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>│ ├── blobs
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>│ └── ingest
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>├── io.containerd.grpc.v1.cri
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>│ ├── containers
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>│ └── sandboxes
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>├── io.containerd.metadata.v1.bolt
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>│ └── meta.db
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>├── io.containerd.runtime.v1.linux
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>│ └── k8s.io
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>├── io.containerd.runtime.v2.task
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>├── io.containerd.snapshotter.v1.aufs
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>│ └── snapshots
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>├── io.containerd.snapshotter.v1.btrfs
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>├── io.containerd.snapshotter.v1.native
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>│ └── snapshots
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>├── io.containerd.snapshotter.v1.overlayfs
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>│ ├── metadata.db
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>│ └── snapshots
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>└── tmpmounts
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">18&lt;/span> directories, &lt;span style="color:#ae81ff">2&lt;/span> files
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>每个子目录，其实都表示的是一个插件名称。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>? → tree -L &lt;span style="color:#ae81ff">2&lt;/span> /run/containerd/
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>/run/containerd/
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>├── containerd.sock
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>├── containerd.sock.ttrpc
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>├── io.containerd.grpc.v1.cri
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>│ ├── containers
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>│ └── sandboxes
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>├── io.containerd.runtime.v1.linux
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>│ └── k8s.io
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>├── io.containerd.runtime.v2.task
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>└── runc
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> └── k8s.io
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">8&lt;/span> directories, &lt;span style="color:#ae81ff">2&lt;/span> files
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h1 id="containerd-插件">Containerd 插件&lt;/h1></description></item><item><title>Docs: Containerd 配置详解</title><link>https://desistdaydream.github.io/docs/IT%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/10.%E4%BA%91%E5%8E%9F%E7%94%9F/2.2.%E5%AE%9E%E7%8E%B0%E5%AE%B9%E5%99%A8%E7%9A%84%E5%B7%A5%E5%85%B7/Containerd/Containerd-%E9%85%8D%E7%BD%AE%E8%AF%A6%E8%A7%A3/Containerd-%E9%85%8D%E7%BD%AE%E8%AF%A6%E8%A7%A3/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/IT%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/10.%E4%BA%91%E5%8E%9F%E7%94%9F/2.2.%E5%AE%9E%E7%8E%B0%E5%AE%B9%E5%99%A8%E7%9A%84%E5%B7%A5%E5%85%B7/Containerd/Containerd-%E9%85%8D%E7%BD%AE%E8%AF%A6%E8%A7%A3/Containerd-%E9%85%8D%E7%BD%AE%E8%AF%A6%E8%A7%A3/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://github.com/containerd/containerd/blob/main/docs/man/containerd-config.toml.5.md">Manual(手册),containerd-config.toml(5)&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://manpages.debian.org/bullseye/containerd/containerd-config.toml.5.en.html">Debian Manual&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>Containerd 使用 &lt;a href="https://desistdaydream.github.io/docs/IT%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/2.%E7%BC%96%E7%A8%8B/%E6%97%A0%E6%B3%95%E5%88%86%E7%B1%BB%E7%9A%84%E8%AF%AD%E8%A8%80/TOML.md">TOML&lt;/a> 作为配置文件的格式，默认配置文件为 /etc/containerd/config.toml，我们可以通过命令来生成一个包含所有配置字段的默认配置文件&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>mkdir -p /etc/containerd
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>containerd config default &amp;gt; /etc/containerd/config.toml
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h1 id="配置文件详解">配置文件详解&lt;/h1>
&lt;h1 id="通用配置">[通用]配置&lt;/h1>
&lt;p>&lt;strong>version = 2&lt;/strong> #
&lt;strong>root = &amp;lt;STRING&amp;gt;&lt;/strong> # Containerd 持久化数据路径。&lt;code>默认值：/var/lib/containerd&lt;/code>。
&lt;strong>state = &amp;lt;STRING&amp;gt;&lt;/strong> # Containerd 临时数据路径。&lt;code>默认值：/run/containerd&lt;/code>。
&lt;strong>oom_score = 0&lt;/strong> # 设置 Containerd 的 OOM 权重。&lt;code>默认值：0&lt;/code>。
Containerd 是容器的守护者，一旦发生内存不足的情况，理想的情况应该是先杀死容器，而不是杀死 Containerd。所以需要调整 Containerd 的 &lt;code>OOM&lt;/code> 权重，减少其被 &lt;strong>OOM Kill&lt;/strong> 的几率。最好是将 &lt;code>oom_score&lt;/code> 的值调整为比其他守护进程略低的值。这里的 oom_socre 其实对应的是 &lt;code>/proc/&amp;lt;pid&amp;gt;/oom_socre_adj&lt;/code>，在早期的 Linux 内核版本里使用 &lt;code>oom_adj&lt;/code> 来调整权重, 后来改用 &lt;code>oom_socre_adj&lt;/code> 了。该文件描述如下：
在计算最终的 &lt;code>badness score&lt;/code> 时，会在计算结果是中加上 &lt;code>oom_score_adj&lt;/code> ,这样用户就可以通过该在值来保护某个进程不被杀死或者每次都杀某个进程。其取值范围为 &lt;code>-1000&lt;/code> 到 &lt;code>1000&lt;/code>。如果将该值设置为 &lt;code>-1000&lt;/code>，则进程永远不会被杀死，因为此时 &lt;code>badness score&lt;/code> 永远返回 0。建议 Containerd 将该值设置为 &lt;code>-999&lt;/code> 到 &lt;code>0&lt;/code> 之间。如果作为 Kubernetes 的 Worker 节点，可以考虑设置为 &lt;code>-999&lt;/code>。&lt;/p>
&lt;h1 id="cgroup-配置">[cgroup] 配置&lt;/h1>
&lt;h1 id="debug-配置">[debug] 配置&lt;/h1>
&lt;h1 id="grpc-配置表">[grpc] 配置表&lt;/h1>
&lt;p>&lt;strong>address = &amp;lt;STRING&amp;gt;&lt;/strong> # Containerd 监听的 GRPC 路径。&lt;code>默认值：/run/containerd/containerd.sock&lt;/code>&lt;/p>
&lt;h1 id="metrics-配置">[metrics] 配置&lt;/h1>
&lt;h1 id="plugins-配置">[plugins] 配置&lt;/h1>
&lt;p>详见 [《Plugin 配置》](/docs/IT学习笔记/10.云原生/2.2.实现容器的工具/Containerd/Containerd%20 配置详解/Plugin%20 配置.md 配置详解/Plugin 配置.md) 章节&lt;/p>
&lt;h1 id="timeouts-配置">[timeouts] 配置&lt;/h1>
&lt;h1 id="ttrpc-配置表">[ttrpc] 配置表&lt;/h1>
&lt;h1 id="配置文件示例">配置文件示例&lt;/h1>
&lt;h2 id="镜像加速配置示例">镜像加速配置示例&lt;/h2>
&lt;p>Containerd 的镜像仓库 mirror 与 Docker 相比有两个区别：&lt;/p>
&lt;ul>
&lt;li>Containerd 只支持通过 &lt;code>CRI&lt;/code> 拉取镜像的 mirror，也就是说，只有通过 &lt;code>crictl&lt;/code> 或者 Kubernetes 调用时 mirror 才会生效，通过 &lt;code>ctr&lt;/code> 拉取是不会生效的。&lt;/li>
&lt;li>&lt;code>Docker&lt;/code> 只支持为 &lt;code>Docker Hub&lt;/code> 配置 mirror，而 &lt;code>Containerd&lt;/code> 支持为任意镜像仓库配置 mirror。&lt;/li>
&lt;/ul>
&lt;p>所以需要修改的部分如下：&lt;/p>
&lt;pre>&lt;code>[plugins.&amp;quot;io.containerd.grpc.v1.cri&amp;quot;.registry]
[plugins.&amp;quot;io.containerd.grpc.v1.cri&amp;quot;.registry.mirrors]
[plugins.&amp;quot;io.containerd.grpc.v1.cri&amp;quot;.registry.mirrors.&amp;quot;docker.io&amp;quot;]
endpoint = [&amp;quot;https://dockerhub.mirrors.nwafu.edu.cn&amp;quot;]
[plugins.&amp;quot;io.containerd.grpc.v1.cri&amp;quot;.registry.mirrors.&amp;quot;k8s.gcr.io&amp;quot;]
endpoint = [&amp;quot;https://registry.aliyuncs.com/k8sxio&amp;quot;]
[plugins.&amp;quot;io.containerd.grpc.v1.cri&amp;quot;.registry.mirrors.&amp;quot;gcr.io&amp;quot;]
endpoint = [&amp;quot;xxx&amp;quot;]
&lt;/code>&lt;/pre>
&lt;h1 id="systemd-配置">Systemd 配置&lt;/h1>
&lt;p>建议通过 systemd 配置 Containerd 作为守护进程运行，配置文件在上文已经被解压出来了：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">[&lt;/span>Unit&lt;span style="color:#f92672">]&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Description&lt;span style="color:#f92672">=&lt;/span>containerd container runtime
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Documentation&lt;span style="color:#f92672">=&lt;/span>https://containerd.io
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>After&lt;span style="color:#f92672">=&lt;/span>network.target local-fs.target
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">[&lt;/span>Service&lt;span style="color:#f92672">]&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>ExecStartPre&lt;span style="color:#f92672">=&lt;/span>-/sbin/modprobe overlay
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>ExecStart&lt;span style="color:#f92672">=&lt;/span>/usr/local/bin/containerd
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Type&lt;span style="color:#f92672">=&lt;/span>notify
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Delegate&lt;span style="color:#f92672">=&lt;/span>yes
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>KillMode&lt;span style="color:#f92672">=&lt;/span>process
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Restart&lt;span style="color:#f92672">=&lt;/span>always
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>RestartSec&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">5&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># Having non-zero Limit*s causes performance problems due to accounting overhead&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># in the kernel. We recommend using cgroups to do container-local accounting.&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>LimitNPROC&lt;span style="color:#f92672">=&lt;/span>infinity
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>LimitCORE&lt;span style="color:#f92672">=&lt;/span>infinity
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>LimitNOFILE&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">1048576&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># Comment TasksMax if your systemd version does not supports it.&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># Only systemd 226 and above support this version.&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>TasksMax&lt;span style="color:#f92672">=&lt;/span>infinity
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>OOMScoreAdjust&lt;span style="color:#f92672">=&lt;/span>-999
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">[&lt;/span>Install&lt;span style="color:#f92672">]&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>WantedBy&lt;span style="color:#f92672">=&lt;/span>multi-user.target
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>这里有两个重要的参数：&lt;/p>
&lt;ul>
&lt;li>&lt;strong>Delegate&lt;/strong> : 这个选项允许 Containerd 以及运行时自己管理自己创建的容器的 &lt;code>cgroups&lt;/code>。如果不设置这个选项，systemd 就会将进程移到自己的 &lt;code>cgroups&lt;/code> 中，从而导致 Containerd 无法正确获取容器的资源使用情况。&lt;/li>
&lt;li>&lt;strong>KillMode&lt;/strong> : 这个选项用来处理 Containerd 进程被杀死的方式。默认情况下，systemd 会在进程的 cgroup 中查找并杀死 Containerd 的所有子进程，这肯定不是我们想要的。&lt;code>KillMode&lt;/code>字段可以设置的值如下。我们需要将 KillMode 的值设置为 &lt;code>process&lt;/code>，这样可以确保升级或重启 Containerd 时不杀死现有的容器。
&lt;ul>
&lt;li>&lt;strong>control-group&lt;/strong>（默认值）：当前控制组里面的所有子进程，都会被杀掉&lt;/li>
&lt;li>&lt;strong>process&lt;/strong>：只杀主进程&lt;/li>
&lt;li>&lt;strong>mixed&lt;/strong>：主进程将收到 SIGTERM 信号，子进程收到 SIGKILL 信号&lt;/li>
&lt;li>&lt;strong>none&lt;/strong>：没有进程会被杀掉，只是执行服务的 stop 命令。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul></description></item><item><title>Docs: CPU</title><link>https://desistdaydream.github.io/docs/IT%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/0.%E8%AE%A1%E7%AE%97%E6%9C%BA/CPU/CPU/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/IT%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/0.%E8%AE%A1%E7%AE%97%E6%9C%BA/CPU/CPU/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;p>&lt;strong>Central Processing Unit(中央处理器，简称 CPU)&lt;/strong>。
如同华硕主板示意图上半部的中央部分，那就是 CPU 插槽。由于 CPU 负责大量运算，因此 CPU 通常是具有相当高发热量的元件。所以如果你曾经拆开过主板，应该就会看到 CPU 上头通常会安插一颗风扇来主动散热的。&lt;/p>
&lt;p>x86 个人电脑的 CPU 主要供应商为 Intel 与 AMD，目前（2015）主流的 CPU 都是双核以上的架构了！原本的单核心 CPU 仅有一个运算单元，所谓的多核心则是在一颗 CPU 封装当中嵌入了两个以上的运算核心， 简单的说，就是一个实体的 CPU 外壳中，含有两个以上的 CPU 单元就是了。&lt;/p>
&lt;p>不同的 CPU 型号大多具有不同的脚位（CPU 上面的插脚），能够搭配的主板芯片组也不同， 所以当你想要将你的主机升级时，不能只考虑 CPU，你还得要留意你的主板上面所支持的 CPU 型号喔！不然买了最新的 CPU 也不能够安插在你的旧主板上头的！目前主流的 CPU 有 Intel 的 i3/i5/i7 系列产品中，甚至先后期出厂的类似型号的脚位也不同， 例如 i7-2600 使用 LGA1155 脚位而 i7-4790 则使用 FCLGA1150 脚位，挑选时必须要很小心喔！&lt;/p>
&lt;p>我们前面谈到 CPU 内部含有微指令集，不同的微指令集会导致 CPU 工作效率的优劣。除了这点之外， CPU 性能的比较还有什么呢？那就是 CPU 的频率了！什么是频率呢？简单的说， 频率就是 CPU 每秒钟可以进行的工作次数。所以频率越高表示这颗 CPU 单位时间内可以作更多的事情。举例来说，Intel 的 i7-4790 CPU 频率为 3.6GHz， 表示这颗 CPU 在一秒内可以进行 3.6x109 次工作，每次工作都可以进行少数的指令运行之意。&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/lgtxxk/1616168680795-7c145400-1473-4cdc-b525-3a106f810f80.gif" alt="">&lt;/p>
&lt;p>&lt;strong>Tips&lt;/strong>注意，不同的 CPU 之间不能单纯的以频率来判断运算性能喔！这是因为每颗 CPU 的微指令集不相同，架构也不见得一样，可使用的第二层高速缓存及其计算机制可能也不同，加上每次频率能够进行的工作指令数也不同！所以，频率目前仅能用来比较同款 CPU 的速度！&lt;/p>
&lt;p>CPU 的工作频率：外频与倍频&lt;/p>
&lt;p>早期的 CPU 架构主要通过北桥来链接系统最重要的 CPU、内存与显卡设备。因为所有的设备都得通过北桥来链接，因此每个设备的工作频率应该要相同。于是就有所谓的前端总线（FSB） 这个东西的产生。但因为 CPU 的运算速度比其他的设备都要来的快，又为了要满足 FSB 的频率，因此厂商就在 CPU 内部再进行加速， 于是就有所谓的外频与倍频了。&lt;/p>
&lt;p>总结来说，在早期的 CPU 设计中，所谓的外频指的是 CPU 与外部元件进行数据传输时的速度，倍频则是 CPU 内部用来加速工作性能的一个倍数， 两者相乘才是 CPU 的频率速度。例如 Intel Core 2 E8400 的内频为 3.0GHz，而外频是 333MHz，因此倍频就是 9 倍啰！（3.0G=333Mx9, 其中 1G=1000M）&lt;/p>
&lt;h2 id="超频">超频&lt;/h2>
&lt;p>&lt;strong>Tips&lt;/strong>很多计算机硬件玩家很喜欢玩“超频”，所谓的超频指的是：将 CPU 的倍频或者是外频通过主板的设置功能更改成较高频率的一种方式。但因为 CPU 的倍频通常在出厂时已经被锁定而无法修改，因此较常被超频的为外频。举例来说，像上述 3.0GHz 的 CPU 如果想要超频，可以将他的外频 333MHz 调整成为 400MHz，但如此一来整个主板的各个元件的运行频率可能都会被增加成原本的 1.333 倍(4/ 3)，虽然 CPU 可能可以到达 3.6GHz，但却因为频率并非正常速度，故可能会造成死机等问题。&lt;/p>
&lt;p>但如此一来所有的数据都被北桥卡死了，北桥又不可能比 CPU 更快，因此这家伙常常是系统性能的瓶颈。为了解决这个问题，新的 CPU 设计中， 已经将内存控制器整合到 CPU 内部，而链接 CPU 与内存、显卡的控制器的设计，在 Intel 部份使用 QPI （Quick Path Interconnect） 与 DMI 技术，而 AMD 部份则使用 Hyper Transport 了，这些技术都可以让 CPU 直接与内存、显卡等设备分别进行沟通，而不需要通过外部的链接芯片了。&lt;/p>
&lt;p>因为现在没有所谓的北桥了（整合到 CPU 内），因此，CPU 的频率设计就无须考虑得要同步的外频，只需要考虑整体的频率即可。所以，如果你经常有查阅自己 CPU 频率的习惯，当使用 cpu-z [9]这个软件时，应该会很惊讶的发现到，怎么外频变成 100MHz 而倍频可以到达 30 以上！相当有趣呢！&lt;/p>
&lt;p>&lt;strong>Tips&lt;/strong> 现在 Intel 的 CPU 会主动帮你超频喔！例如 i7-4790 这颗 CPU 的规格[10]中，基本频率为 3.6GHz，但是最高可自动超频到 4GHz 喔！通过的是 Intel 的 turbo 技术。同时，如果你没有大量的运算需求，该 CPU 频率会降到 1.xGHz 而已，借此达到节能省电的目的！所以，各位好朋友，不需要自己手动超频了！Intel 已经自动帮你进行超频了&amp;hellip;所以，如果你用 cpu-z 观察 CPU 频率，发现该频率会一直自动变动，很正常！你的系统没坏掉！&lt;/p>
&lt;p>32 位与 64 位的 CPU 与总线“宽度”&lt;/p>
&lt;p>从前面的简易说明中，我们知道 CPU 的各项数据通通得要来自于内存。因此，如果内存能提供给 CPU 的数据量越大的话，当然整体系统的性能应该也会比较快！那如何知道内存能提供的数据量呢？此时还是得要借由 CPU 内的内存控制芯片与内存间的传输速度“前端总线速度（Front Side Bus, FSB） 来说明。&lt;/p>
&lt;p>与 CPU 的频率类似的，内存也是有其工作的频率，这个频率限制还是来自于 CPU 内的内存控制器所决定的。以图 0.2.1 为例， CPU 内置的内存控制芯片对内存的工作频率最高可达到 1600MHz。这只是工作频率（每秒几次）。一般来说，每次频率能够传输的数据量，大多为 64 位，这个 64 位就是所谓的“宽度”了！因此，在图 0.2.1 这个系统中，CPU 可以从内存中取得的最快带宽就是 1600MHz &lt;em>64bit = 1600MHz&lt;/em> 8 Bytes = 12.8GByte/s。&lt;/p>
&lt;p>与总线宽度相似的，CPU 每次能够处理的数据量称为字组大小（word size）， 字组大小依据 CPU 的设计而有 32 位与 64 位。我们现在所称的电脑是 32 或 64 位主要是依据这个 CPU 解析的字组大小而来的！早期的 32 位 CPU 中，因为 CPU 每次能够解析的数据量有限， 因此由内存传来的数据量就有所限制了。这也导致 32 位的 CPU 最多只能支持最大到 4GBytes 的内存。&lt;/p>
&lt;p>&lt;strong>Tips&lt;/strong> 得利于北桥整合到 CPU 内部的设计，CPU 得以“个别”跟各个元件进行沟通！因此，每种元件与 CPU 的沟通具有很多不同的方式！例如内存使用系统总线带宽来与 CPU 沟通。而显卡则通过 PCI-E 的序列信道设计来与 CPU 沟通喔！详细说明我们在本章稍后的主板部份再来谈谈。&lt;/p>
&lt;p>CPU 等级&lt;/p>
&lt;p>由于 x86 架构的 CPU 在 Intel 的 Pentium 系列（1993 年）后就有不统一的脚位与设计，为了将不同种类的 CPU 规范等级， 所以就有 i386,i586,i686 等名词出现了。基本上，在 Intel Pentium MMX 与 AMD K6 年代的 CPU 称为 i586 等级， 而 Intel Celeron 与 AMD Athlon（K7）年代之后的 32 位 CPU 就称为 i686 等级。至于目前的 64 位 CPU 则统称为 x86_64 等级。&lt;/p>
&lt;p>目前很多的程序都有对 CPU 做最优化的设计，万一哪天你发现一些程序是注明给 x86_64 的 CPU 使用时， 就不要将他安装在 686 以下等级的电脑中，否则可是会无法执行该软件的！不过，在 x86_64 的硬件下倒是可以安装 386 的软件喔！也就是说，这些东西具有向下相容的能力啦！&lt;/p>
&lt;h2 id="超线程hyper-threading-ht">超线程（Hyper-Threading, HT）&lt;/h2>
&lt;p>我们知道现在的 CPU 至少都是两个核心以上的多核心 CPU 了，但是 Intel 还有个很怪的东西，叫做 CPU 的超线程（Hyper-Threading） 功能！那个是啥鬼东西？我们知道现在的 CPU 运算速度都太快了，因此运算核心经常处于闲置状态下。而我们也知道现在的系统大多都是多任务的系统， 同时间有很多的程序会让 CPU 来执行。因此，若 CPU 可以假象的同时执行两个程序，不就可以让系统性能增加了吗？反正 CPU 的运算能力还是没有用完啊！&lt;/p>
&lt;p>那是怎么达成的啊这个 HT 功能？强者鸟哥的同事蔡董大大用个简单的说明来解释。在每一个 CPU 内部将重要的寄存器（register） 分成两群， 而让程序分别使用这两群寄存器。也就是说，可以有两个程序“同时竞争 CPU 的运算单元”，而非通过操作系统的多任务切换！这一过程就会让 CPU 好像“同时有两个核心”的模样！因此，虽然大部分 i7 等级的 CPU 其实只有四个实体核心，但通过 HT 的机制， 则操作系统可以抓到八个核心！并且让每个核心逻辑上分离，就可以同时运行八个程序了。&lt;/p>
&lt;p>虽然很多研究与测试中，大多发现 HT 虽然可以提升性能，不过，有些情况下却可能导致性能降低喔！因为，实际上明明就仅有一个运算单元嘛！不过在鸟哥使用数值模式的情况下，因为鸟哥操作的数值模式主要为平行运算功能，且运算通常无法达到 100% 的 CPU 使用率，通常仅有大约 60%运算量而已。因此在鸟哥的实作过程中，这个 HT 确实提升相当多的性能！至少应该可以节省鸟哥大约 30%~50%的等待时间喔！不过网络上大家的研究中， 大多说这个是 case by case，而且使用的软件影响很大！所以，在鸟哥的例子是启用 HT 帮助很大！您的案例就得要自行研究啰！&lt;/p></description></item><item><title>Docs: CPU 管理工具</title><link>https://desistdaydream.github.io/docs/IT%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/X.Linux-%E7%AE%A1%E7%90%86/Linux-%E7%B3%BB%E7%BB%9F%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/CPU-%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/IT%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/X.Linux-%E7%AE%A1%E7%90%86/Linux-%E7%B3%BB%E7%BB%9F%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/CPU-%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;/blockquote></description></item><item><title>Docs: Cryptography(密码学)</title><link>https://desistdaydream.github.io/docs/IT%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/7.%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8/Cryptography%E5%AF%86%E7%A0%81%E5%AD%A6/Cryptography%E5%AF%86%E7%A0%81%E5%AD%A6/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/IT%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/7.%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8/Cryptography%E5%AF%86%E7%A0%81%E5%AD%A6/Cryptography%E5%AF%86%E7%A0%81%E5%AD%A6/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Cryptography">Wiki,Cryptography&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;h1 id="密码学背景">密码学背景&lt;/h1>
&lt;p>在现代时代之前，密码学着眼于消息的机密性（即加密），即将消息从一种可理解的形式转换为一种难以理解的形式，然后又在另一端再次转换，从而使拦截器或窃听者在没有秘密知识（即所需的密钥）的情况下无法读取该消息。用于解密该消息）。加密试图确保保密的通信，如那些间谍，军事领导人和外交官。在最近的几十年中，该领域已经超出了对机密性的关注范围，包括消息完整性检查，发送者/接收者身份验证，数字签名，交互式证明和安全计算等。&lt;/p>
&lt;h2 id="经典密码学">经典密码学&lt;/h2>
&lt;h2 id="现代密码学">现代密码学&lt;/h2>
&lt;p>现在我们谈论的密码学，都是现代密码学的范畴&lt;/p>
&lt;p>Public-key cryptography(公开密钥加密、非对称密钥加密)，以及根据公开密钥加密方式而衍生出的其他认证授权等基础设施，是当代最常见，也是最常用的方式.&lt;/p>
&lt;h1 id="现代加密方式">现代加密方式&lt;/h1>
&lt;h2 id="symmetric-key-algorithm对称密钥算法">Symmetric Key Algorithm(对称密钥算法)&lt;/h2>
&lt;blockquote>
&lt;p>参考： &lt;a href="https://en.wikipedia.org/wiki/Symmetric-key_algorithm">Wiki-Symmetir Key Algorithm&lt;/a>&lt;/p>
&lt;/blockquote>
&lt;p>使用相同的密钥来加密明文和解密密文&lt;/p>
&lt;p>算法：&lt;/p>
&lt;ol>
&lt;li>DES：Data Encryption Standard 数据加密标准。已被破解&lt;/li>
&lt;li>3DES：3 倍的 DES。最常用&lt;/li>
&lt;li>AES：Advanced Encryption Standard 高级加密标准。最常用&lt;/li>
&lt;li>Blowfish&lt;/li>
&lt;li>Twofish&lt;/li>
&lt;li>IDEA：商业加密算法&lt;/li>
&lt;/ol>
&lt;h3 id="ska-特点">SKA 特点&lt;/h3>
&lt;p>特性：&lt;/p>
&lt;ul>
&lt;li>加密和解密使用同一个密钥，效率高。&lt;/li>
&lt;li>将原始数据分割成固定大小的块，逐个进行加密；&lt;/li>
&lt;/ul>
&lt;p>缺点：&lt;/p>
&lt;ul>
&lt;li>密钥过多；&lt;/li>
&lt;li>密钥分发(分发密钥过程无法保证),为了解决对称加密算法每个人需要保存密钥过多的问题，可以使用公钥加密&lt;/li>
&lt;li>数据来源无法确认&lt;/li>
&lt;/ul>
&lt;h2 id="public-key-cryptography公开密钥密码学">Public Key Cryptography(公开密钥密码学)&lt;/h2>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Public-key_cryptography">Wiki,PKC 英文&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Digital_signature">Wiki,数字签名&lt;/a>&lt;/li>
&lt;li>&lt;a href="http://www.ruanyifeng.com/blog/2013/06/rsa_algorithm_part_one.html">阮一峰&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.zhihu.com/question/25912483">知乎,RSA 的公钥和私钥到底那个才是用来加密和哪个用来解密&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://zh.wikipedia.org/wiki/%E5%85%AC%E5%BC%80%E5%AF%86%E9%92%A5%E5%8A%A0%E5%AF%86">Wiki, 公开密钥加密 中文&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>**Public Key Cryptography(公开密钥密码学) &lt;strong>也称为&lt;/strong> Asymmetric Key Algorithm(非对称密钥算法)，**它是计算机通信安全的基石，保证了加密数据不会被破解。1976 年以前，所有的加密方法都是同一种模式：&lt;/p>
&lt;ul>
&lt;li>甲方选择某种加密规则，对信息进行加密&lt;/li>
&lt;li>乙方使用同一种规则，对信息进行解密&lt;/li>
&lt;/ul>
&lt;p>由于加密和解密使用同样规则（简称&amp;quot;密钥&amp;quot;），这被称为 Symmetric-key algorithm(对称密钥算法)。这种加密模式有一个最大弱点：甲方必须把加密规则告诉乙方，否则无法解密。保存和传递密钥，就成了最头疼的问题。因为大多数情况下，其实两方之间的通信，只有一方是需要加密的，另一方只需要知道信息内容。&lt;/p>
&lt;p>1976 年，两位美国计算机学家 Whitfield Diffie 和 Martin Hellman，提出了一种崭新构思，可以在不直接传递密钥的情况下，完成解密。这被称为&amp;quot;Diffie-Hellman 密钥交换算法&amp;quot;。这个算法启发了其他科学家。人们认识到，加密和解密可以使用不同的规则，只要这两种规则之间存在某种对应关系即可，这样就避免了直接传递密钥。&lt;/p>
&lt;p>这种新的加密模式就被称为&amp;quot;非对称密钥算法&amp;quot;。&lt;/p>
&lt;blockquote>
&lt;p>（1）乙方生成两把密钥（公钥和私钥）。公钥是公开的，任何人都可以获得，私钥则是保密的。
（2）甲方获取乙方的公钥，然后用它对信息加密。
（3）乙方得到加密后的信息，用私钥解密。&lt;/p>
&lt;/blockquote>
&lt;p>如果公钥加密的信息只有私钥解得开，那么只要私钥不泄漏，通信就是安全的。&lt;/p>
&lt;p>1977 年，三位数学家 Rivest、Shamir 和 Adleman 设计了一种算法，可以实现非对称加密。这种算法用他们三个人的名字命名，叫做 RSA 算法。从那时直到现在，RSA 算法一直是最广为使用的&amp;quot;非对称加密算法&amp;quot;。毫不夸张地说，只要有计算机网络的地方，就有 RSA 算法。&lt;/p>
&lt;p>这种算法非常可靠，密钥越长，它就越难破解。根据已经披露的文献，目前被破解的最长 RSA 密钥是 768 个二进制位。也就是说，长度超过 768 位的密钥，还无法破解（至少没人公开宣布）。因此可以认为，1024 位的 RSA 密钥基本安全，2048 位的密钥极其安全。&lt;/p>
&lt;h3 id="pkc-特点">PKC 特点&lt;/h3>
&lt;ul>
&lt;li>这种加密方式，需要一对密钥。只有公钥可以加密，私钥不能用来加密数据。&lt;/li>
&lt;li>&lt;strong>Public key(公钥)&lt;/strong> # 公开给所有人。用来加密数据、验证签名。使用公钥把明文加密后所得的密文，只能使用对应的私钥才能解密并得到原本的密文。反之不行。&lt;/li>
&lt;li>&lt;strong>Secret key(私钥)&lt;/strong> # 自己留存，必须保证其私密性。用来解密数据、签名。使用私钥创建数字签名，只能使用公钥才能验证该数字签名的有效性。反之不行。
&lt;ul>
&lt;li>一般情况，密钥对是通过程序自动生成的。首先生成私钥后，公钥包含在私钥当中&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>Digital signature(数字签名)&lt;/strong>。签名提供的是真实性，而不是保密性。
&lt;ul>
&lt;li>所谓的数字签名，就像人们日常生活中在文件上签字一样，都是签名的一种。&lt;/li>
&lt;li>而所谓的验证签名，其实就像日常生活中，看看签名的人的笔记与签名是否一致，等等类似的行为&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>总结一下：既然是加密，那肯定是不希望别人知道发送给我的消息，所以只有我才能解密，所以可得出&lt;strong>公钥负责加密，私钥负责解密&lt;/strong>；同理，既然是签名，那肯定是不希望有人冒充我发消息，只有我才能发布这个签名，所以可得出&lt;strong>私钥负责签名，公钥负责验证&lt;/strong>。&lt;/p>
&lt;ul>
&lt;li>这种加密方式由于是单向加密、单向解密，所以如果双方都想要加密，则需要两对密钥，双方各自用对方的公钥加密信息发送给对方，然后双方再用自己的私钥解密阅读信息。&lt;/li>
&lt;/ul>
&lt;h3 id="应用场景">应用场景&lt;/h3>
&lt;ul>
&lt;li>如果 A 持有私钥，B 持有对应公钥。那么此时 B 用对方的公钥加密一个对称密钥并发送给 A，A 使用私钥解密，以获得 B 发送的对称密钥，这时再发送的数据可以使用对称加密。&lt;/li>
&lt;li>在互联网的 C/S 架构场景中。Server 公开公钥，Client 使用公钥加密信息发送给 Server(发送密码等敏感信息)，Server 使用私钥解密后响应时，使用私钥签名，以便 Client 可以用公钥验证 Server 的真实性(防止钓鱼网站)。&lt;/li>
&lt;li>如图所示，Alice 在一条消息的末尾签了名，消息内容是 &lt;code>Hello Bob!&lt;/code>，这段签署的内容一般是对消息内容进行 hash 计算后，使用 Alice 的私钥的出来的。鲍勃同时收到消息和签名。他使用 Alice 的公钥来验证消息的真实性，即，如果使用公钥计算得出来的消息与原始消息完全匹配，那就证明，这条消息确实是 Alice 发送的。&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/as985c/1616125981836-028fe2ce-77f2-4929-91cc-559c4ce9cda1.png" alt="">&lt;/p>
&lt;p>算法：&lt;/p>
&lt;ol>
&lt;li>RSA&lt;/li>
&lt;li>DSA&lt;/li>
&lt;li>ELGamal&lt;/li>
&lt;/ol>
&lt;p>缺点&lt;/p>
&lt;ol>
&lt;li>公钥加密可能出现的问题：当两者需要通信的时候，需要把公钥发送给对方，但是公钥是谁都可以获取的，那么在二者通信过程中，公钥就有可能被劫持，当公钥被劫持，劫持者把自己的公钥再发送给对方，那么双发再收到的信息，就是被劫持者篡改过的信息了。
&lt;ol>
&lt;li>&lt;a href="https://www.yuque.com/go/doc/33177961">&lt;strong>Public Key Certificate(公钥证书)&lt;/strong>&lt;/a> 可以解决以上问题&lt;/li>
&lt;/ol>
&lt;/li>
&lt;/ol>
&lt;h2 id="cryptographic-hash-function单向加密加密散列函数">Cryptographic hash function(单向加密、加密散列函数)&lt;/h2>
&lt;p>只能加密，不能解密，提取数据特征码，用来保证数据的完成性，实现数据的完整性校验&lt;/p>
&lt;p>通常用来做数字证书的数字签名，提取数据的特征码后进行加密并放到数据后端，用来校验证书的完整性，所以证书的内容是被认可的&lt;/p>
&lt;p>特点：定长输出、雪崩效应(原始数据的微小改变会导致计算结果的完全不同)&lt;/p>
&lt;p>算法：&lt;/p>
&lt;ol>
&lt;li>md5&lt;/li>
&lt;li>sha1&lt;/li>
&lt;li>sha256&lt;/li>
&lt;li>sha384&lt;/li>
&lt;li>sha512&amp;hellip;.等&lt;/li>
&lt;/ol>
&lt;p>MAC:Message Authentication Code(消息认证码)，单向加密的一种延伸应用，用于实现在网络通信中保证所传输的数据的完整性&lt;/p></description></item><item><title>Docs: Data Type(数据类型) 与 Literal(字面量)</title><link>https://desistdaydream.github.io/docs/IT%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/2.%E7%BC%96%E7%A8%8B/%E8%A7%A3%E8%B0%9C%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/Data-Type%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B-%E4%B8%8E-Literal%E5%AD%97%E9%9D%A2%E9%87%8F/Data-Type%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B-%E4%B8%8E-Literal%E5%AD%97%E9%9D%A2%E9%87%8F/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/IT%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/2.%E7%BC%96%E7%A8%8B/%E8%A7%A3%E8%B0%9C%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/Data-Type%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B-%E4%B8%8E-Literal%E5%AD%97%E9%9D%A2%E9%87%8F/Data-Type%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B-%E4%B8%8E-Literal%E5%AD%97%E9%9D%A2%E9%87%8F/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Data_type">Wiki,DataType&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Abstract_data_type">Wiki,Abstract Data Type&lt;/a>(抽象数据类型)&lt;/li>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Literal_(computer_programming)">Wiki,Literal(字面量)&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>在计算机科学和计算机编程中，&lt;strong>Data Type(数据类型，有时也简称 Type)&lt;/strong> 是数据的一个属性，这些属性将会让编译器知道程序员想要如何使用数据。&lt;/p>
&lt;p>在计算机科学中，&lt;strong>Literal(字面量)&lt;/strong> 是表示源代码中固定值的 snotation(表示法)。几乎所有计算机编程语言都具有对基本值的字面量表示，诸如：整数、浮点数以及字符串；而有很多也对布尔类型和字符类型的值也支持字面量表示；还有一些甚至对枚举类型的元素以及像数组、记录和对象等复合类型的值也支持字面量表示法。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// b 为常量，10为字面量,数据类型为整数
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">const&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#a6e22e">b&lt;/span> = &lt;span style="color:#ae81ff">10&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// str 为变量，hello world！为字面量，数据类型为字符串
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">string&lt;/span> &lt;span style="color:#a6e22e">str&lt;/span> = &lt;span style="color:#e6db74">&amp;#34;hello world！&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h1 id="数据类型的分类">数据类型的分类&lt;/h1>
&lt;ul>
&lt;li>原始数据类型&lt;/li>
&lt;li>复合类型&lt;/li>
&lt;li>抽象数据类型&lt;/li>
&lt;li>其他类型&lt;/li>
&lt;/ul>
&lt;h2 id="primitive-data-types原始数据类型">Primitive Data Types(原始数据类型)&lt;/h2>
&lt;p>&lt;a href="https://en.wikipedia.org/wiki/Primitive_data_type">原始数据类型&lt;/a>通常是语言实现的内置或基础类型。&lt;/p>
&lt;h3 id="machine-data-type机器数据类型">Machine Data Type(机器数据类型)&lt;/h3>
&lt;p>基于数字电子的计算机中的所有数据都表示为最低级别的&lt;a href="https://en.wikipedia.org/wiki/Bit">位&lt;/a>（替代 0 和 1）。数据的最小可寻址单元通常是一组称为&lt;a href="https://en.wikipedia.org/wiki/Byte">字节&lt;/a>的位（通常是一个&lt;a href="https://en.wikipedia.org/wiki/Octet_(computing)">八位组&lt;/a>，即 8 位）。由&lt;a href="https://en.wikipedia.org/wiki/Machine_code">机器代码&lt;/a>指令处理的单元称为&lt;a href="https://en.wikipedia.org/wiki/Word_(data_type)">字&lt;/a>（截至 2011 年，通常为 32 或 64 位）。大多数指令将字解释为&lt;a href="https://en.wikipedia.org/wiki/Binary_number">二进制数&lt;/a>，因此 32 位字可以表示从 0 到 232 - 1 或有符号整数值来自 -231 到 231 - 1 由于&lt;a href="https://en.wikipedia.org/wiki/Two%27s_complement">二进制补码&lt;/a>，机器语言和机器在大多数情况下不需要区分这些无符号和有符号数据类型。&lt;/p>
&lt;p>用于浮点算术的浮点数对字中的位使用不同的解释。有关详细信息，请参阅&lt;a href="https://en.wikipedia.org/wiki/Floating-point_arithmetic">浮点运算&lt;/a>。&lt;/p>
&lt;p>机器数据类型需要在&lt;a href="https://en.wikipedia.org/wiki/Systems_programming">系统&lt;/a>或&lt;a href="https://en.wikipedia.org/wiki/Low-level_programming_language">低级编程语言中&lt;/a>公开或可用，允许对硬件进行细粒度控制。的&lt;a href="https://en.wikipedia.org/wiki/C_programming_language">C 编程语言&lt;/a>，例如，建筑材料整数类型不同的宽度，如和。如果目标平台上不存在相应的本机类型，编译器将使用确实存在的类型将它们分解为代码。例如，如果在 16 位平台上请求一个 32 位整数，编译器会默认将其视为两个 16 位整数的数组。 shortlong&lt;/p>
&lt;p>在更高级别的编程中，机器数据类型通常被隐藏或_抽象_为一个实现细节，如果暴露，会使代码的可移植性降低。例如，numeric 可以提供泛型类型而不是某些特定位宽的整数。&lt;/p>
&lt;h3 id="boolean-type布尔类型">Boolean Type(布尔类型)&lt;/h3>
&lt;p>&lt;a href="https://en.wikipedia.org/wiki/Boolean_type">Boolean(布尔)&lt;/a> 类型表示值 &lt;a href="https://en.wikipedia.org/wiki/Logical_truth">true(真)&lt;/a> 和 &lt;a href="https://en.wikipedia.org/wiki/Logical_truth">false(假)&lt;/a>。尽管只有两个值是可能的，但出于效率原因，它们很少被实现为单个二进制数字。许多编程语言没有明确的布尔类型，&lt;strong>而是将 0 解释为 false，将其他值解释为 true&lt;/strong>。布尔数据是指如何将语言解释为机器语言的逻辑结构。在这种情况下，布尔值 0 指的是逻辑 False。True 总是非零，尤其是被称为布尔值 1 的一。&lt;/p>
&lt;h3 id="numeric-type数字类型">Numeric Type(数字类型)&lt;/h3>
&lt;ul>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Integer_(computing)">Integer(整数，简写 int)&lt;/a> 数据类型，或“非分数”。可以根据它们包含负值的能力进行子类型化（例如 unsigned 在 C 和 C++ 中）。也可具有小的预定义数目的亚型（如 short 和 long 在 C / C ++）; 或允许用户自由定义子范围，例如 1..12（例如&lt;a href="https://en.wikipedia.org/wiki/Pascal_(programming_language)">Pascal&lt;/a> / &lt;a href="https://en.wikipedia.org/wiki/Ada_(programming_language)">Ada&lt;/a>）。&lt;/li>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Floating_point">Floating Point(浮点)&lt;/a> 数据类型通常将值表示为高精度分数值（&lt;a href="https://en.wikipedia.org/wiki/Rational_numbers">有理数&lt;/a>，数学上），但有时会误导性地称为实数（令人联想到数学&lt;a href="https://en.wikipedia.org/wiki/Real_numbers">实数&lt;/a>）。它们通常对最大值和精度都有预定义的限制。通常以 a × 2 b 的形式在内部存储（其中 a 和 b 是整数），但以熟悉的&lt;a href="https://en.wikipedia.org/wiki/Decimal">十进制&lt;/a>形式显示。&lt;/li>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Fixed_point_(computing)">Fixed Point(定点)&lt;/a> 数据类型便于表示货币值。它们通常在内部实现为整数，从而导致预定义的限制。&lt;/li>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Bignum">Bignum&lt;/a>或&lt;a href="https://en.wikipedia.org/wiki/Arbitrary_precision">任意精度&lt;/a>数字类型缺乏预定义的限制。它们不是原始类型，出于效率原因很少使用。&lt;/li>
&lt;/ul>
&lt;h3 id="enumerations枚举">Enumerations(枚举)&lt;/h3>
&lt;p>&lt;a href="https://en.wikipedia.org/wiki/Enumerated_type">枚举类型&lt;/a>具有不同的值，其可以被比较和分配，但不一定必须在计算机的存储器中的任何特定的具体表示; 编译器和解释器可以任意表示它们。例如，一副扑克牌中的四个花色可能是名为 CLUB、DIAMOND、HEART、SPADE 的四个枚举数，属于一个名为 suit 的枚举类型。如果变量 V 被声明为具有花色作为它的数据类型，可以为它分配这四个值中的任何一个。一些实现允许程序员为枚举值分配整数值，甚至将它们视为与整数类型等效的。&lt;/p>
&lt;h2 id="composite-types复合类型">Composite Types(复合类型)&lt;/h2>
&lt;p>&lt;a href="https://en.wikipedia.org/wiki/Composite_type">复合类型&lt;/a>派生自多个原始类型。这可以通过多种方式完成。它们组合的方式称为&lt;a href="https://en.wikipedia.org/wiki/Data_structure">数据结构&lt;/a>。构成一个基本类型为化合物类型通常导致新类型，例如阵列的整数是一个不同类型的整数。&lt;/p>
&lt;ul>
&lt;li>&lt;strong>&lt;a href="https://en.wikipedia.org/wiki/Array_data_type">Array(数组)&lt;/a>&lt;/strong>，也称为载体，&lt;strong>&lt;a href="https://en.wikipedia.org/wiki/List_(abstract_data_type)">列表或序列&lt;/a>&lt;/strong> 的存储数量的元件，并提供&lt;a href="https://en.wikipedia.org/wiki/Random_access">随机接入&lt;/a>到单个元件。数组的元素通常（但并非在所有上下文中）需要具有相同的类型。数组可以是固定长度的或可扩展的。数组中的索引通常需要是来自特定范围的整数（如果不是，可以通过谈论&lt;a href="https://en.wikipedia.org/wiki/Associative_array">关联数组&lt;/a>来强调这种放松）（如果不是该范围内的所有索引都对应于元素，则它可能是一个&lt;a href="https://en.wikipedia.org/wiki/Sparse_array">稀疏数组&lt;/a>）。&lt;/li>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Record_(computer_science)">&lt;strong>Record(记录)，也称为 tuple(元组) 或 struct(结构)&lt;/strong>&lt;/a> 是最简单的&lt;a href="https://en.wikipedia.org/wiki/Data_structure">数据结构之一&lt;/a>。记录是包含其他值的值，通常采用固定数量和顺序，通常按 1 名称索引。记录的元素通常称为 &lt;strong>Fields(字段)&lt;/strong> 或 &lt;strong>Members(成员)&lt;/strong>。&lt;/li>
&lt;li>&lt;strong>&lt;a href="https://en.wikipedia.org/wiki/Union_type">Union(联合)&lt;/a>&lt;/strong> 类型定义将指定许多允许的原始类型中的哪一个可以存储在其实例中，例如“浮点数或长整数”。与&lt;a href="https://en.wikipedia.org/wiki/Record_(computer_science)">记录&lt;/a>相反，&lt;a href="https://en.wikipedia.org/wiki/Record_(computer_science)">记录&lt;/a>可以定义为包含一个浮点数和一个整数；而在联合中，一次只允许一种类型。
&lt;ul>
&lt;li>甲&lt;a href="https://en.wikipedia.org/wiki/Tagged_union">标签联合&lt;/a>（也称为&lt;a href="https://en.wikipedia.org/wiki/Variant_type">变体&lt;/a>，变体记录，识别联合，或不相交并）包含一个附加的字段，指示其当前型增强型安全性。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Set_(abstract_data_type)">&lt;strong>Set(集)&lt;/strong>&lt;/a> 是一个&lt;a href="https://en.wikipedia.org/wiki/Abstract_data_structure">抽象的数据结构&lt;/a>可以存储某些值，没有任何特别的&lt;a href="https://en.wikipedia.org/wiki/Sequence">顺序&lt;/a>，并且不重复的值。值本身不是从集合中检索的，而是测试成员资格的值以获得布尔值“in”或“not in”。&lt;/li>
&lt;li>&lt;strong>&lt;a href="https://en.wikipedia.org/wiki/Object_(computer_science)">Object(对象)&lt;/a>&lt;/strong> 包含许多数据字段，如 Record，以及许多用于访问或修改它们的子程序，称为 &lt;a href="https://en.wikipedia.org/wiki/Method_(computer_programming)">Methods(方法)&lt;/a>。&lt;/li>
&lt;/ul>
&lt;p>许多其他的都是可能的，但它们往往是上述的进一步变体和化合物。例如，&lt;a href="https://en.wikipedia.org/wiki/Linked_list">链表&lt;/a>可以存储与数组相同的数据，但提供&lt;a href="https://en.wikipedia.org/wiki/Sequential_access">顺序访问&lt;/a>而不是随机&lt;a href="https://en.wikipedia.org/wiki/Sequential_access">访问&lt;/a>，并且由&lt;a href="https://en.wikipedia.org/wiki/Dynamic_memory">动态内存中&lt;/a>的记录组成；虽然可以说是一种数据结构而不是类型本身，但它也很常见且足够独特，因此将其包含在复合类型的讨论中是合理的。&lt;/p>
&lt;h3 id="string字符串-和-text文本-类型">String(字符串) 和 Text(文本) 类型&lt;/h3>
&lt;ul>
&lt;li>一个&lt;a href="https://en.wikipedia.org/wiki/Character_(computing)">字符&lt;/a>，可能是某个&lt;a href="https://en.wikipedia.org/wiki/Alphabet">字母表&lt;/a>中的一个&lt;a href="https://en.wikipedia.org/wiki/Alphabet">字母&lt;/a>、一个数字、一个空格、一个标点符号等。&lt;/li>
&lt;li>一个&lt;a href="https://en.wikipedia.org/wiki/String_(computer_science)">字符串&lt;/a>，它是一个字符序列。字符串通常用于表示单词和文本，尽管除了最琐碎的情况外，所有文本都不仅仅涉及字符序列。&lt;/li>
&lt;/ul>
&lt;p>字符和字符串类型可以存储字符集（例如&lt;a href="https://en.wikipedia.org/wiki/ASCII">ASCII ）中&lt;/a>的字符序列。由于大多数字符集都包含&lt;a href="https://en.wikipedia.org/wiki/Numerical_digit">数字&lt;/a>，因此可以使用数字字符串，例如&amp;quot;1234&amp;quot;. 但是，许多语言将它们视为属于与数值不同的类型 1234。&lt;/p>
&lt;p>根据所需的字符“宽度”，字符和字符串类型可以有不同的子类型。最初的 7 位宽 ASCII 被发现是有限的，并被 8 位和 16 位集取代，它们可以编码各种各样的非拉丁字母（如&lt;a href="https://en.wikipedia.org/wiki/Hebrew">希伯来语&lt;/a>和&lt;a href="https://en.wikipedia.org/wiki/Chinese_language">中文&lt;/a>）和其他符号。字符串可以是适合拉伸的，也可以是固定大小的，即使是在相同的编程语言中。它们也可以按其最大大小进行子类型化。&lt;/p>
&lt;p>注意：字符串不是所有语言中的原始数据类型。例如，在 &lt;a href="https://en.wikipedia.org/wiki/C_(programming_language)">C 语言&lt;/a> 中，它们由字符数组组成。&lt;/p>
&lt;h2 id="abstract-data-types抽象数据类型">Abstract Data Types(抽象数据类型)&lt;/h2>
&lt;p>任何未指定数据具体表示的&lt;a href="https://en.wikipedia.org/wiki/Abstract_data_type">数据类型&lt;/a> 都是 &lt;strong>Abstract Data Type(抽象数据类型，简称 ADT)&lt;/strong>。相反，使用基于数据类型操作的正式规范来描述它。规范的任何实现都必须满足给定的规则。抽象数据类型用于形式&lt;a href="https://en.wikipedia.org/wiki/Semantics_(computer_science)">语义&lt;/a>和程序&lt;a href="https://en.wikipedia.org/wiki/Formal_verification">验证，&lt;/a>并且不太严格地用于&lt;a href="https://en.wikipedia.org/wiki/Design">设计&lt;/a>。&lt;/p>
&lt;p>除了验证之外，规范可能会立即转变为实现。例如，&lt;a href="https://en.wikipedia.org/wiki/OBJ_(programming_language)">OBJ&lt;/a>系列编程语言基于此选项，使用&lt;a href="https://en.wikipedia.org/wiki/Equation">等式&lt;/a>进行规范并&lt;a href="https://en.wikipedia.org/wiki/Rewriting">重写&lt;/a>以运行它们。&lt;a href="https://en.wikipedia.org/wiki/Algebraic_specification">代数规范&lt;/a>&lt;a href="https://en.wikipedia.org/wiki/Data_type#cite_note-3">[3]&lt;/a>是 1980 年左右 CS 的一个重要研究课题，几乎是当时抽象数据类型的同义词。它具有&lt;a href="https://en.wikipedia.org/wiki/Universal_algebra">通用代数&lt;/a>的数学基础。&lt;a href="https://en.wikipedia.org/wiki/Data_type#cite_note-4">[4]&lt;/a>通过允许其他公式而不仅仅是方程，可以使规范语言更具表现力。&lt;/p>
&lt;p>一个典型的例子是&lt;a href="https://en.wikipedia.org/wiki/List_(abstract_data_type)">list&lt;/a>、&lt;a href="https://en.wikipedia.org/wiki/Set_(abstract_data_type)#Multiset">bag&lt;/a>和&lt;a href="https://en.wikipedia.org/wiki/Set_(computer_science)">set&lt;/a>数据类型的层次结构。所有这些数据类型都可以通过三个操作声明：null，它构造空容器，single，它从单个元素构造一个容器，append，它组合了两个相同类型的容器。然后，可以通过对这些操作的以下规则来给出三种数据类型的完整规范：&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>- null 是左右中性：&lt;/th>
&lt;th>追加（空，A）= A，追加（A，空）= A。&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>- 对于列表，append 是关联的：&lt;/td>
&lt;td>追加（追加（A，B），C）=追加（A，追加（B，C））。&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>- 袋子增加交换性：&lt;/td>
&lt;td>追加（B，A）=追加（A，B）。&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>- 最后，集合也是幂等的：&lt;/td>
&lt;td>追加（A，A）= A。&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>可以通过以下方式指定对数据的访问，例如这些容器的成员函数：&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>- 成员（X，单（Y））= eq（X，Y）&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>- 成员（X，空）= 假&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>- 成员(X,append(A,B)) = or(member(X,A), member(X,B))&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="associative-array关联数组也称为-map">Associative array(关联数组，也称为 map)&lt;/h3>
&lt;h2 id="其他类型">其他类型&lt;/h2>
&lt;p>类型可以基于或派生自上述基本类型。在某些语言（例如 C）中，&lt;a href="https://en.wikipedia.org/wiki/Function_(computer_science)">函数&lt;/a>具有从其&lt;a href="https://en.wikipedia.org/wiki/Return_value">返回值&lt;/a>的类型派生的类型。&lt;/p>
&lt;h3 id="pointer指针-和-reference引用">Pointer(指针) 和 Reference(引用)&lt;/h3>
&lt;p>主条目：&lt;a href="https://en.wikipedia.org/wiki/Reference_(computer_science)">引用(计算机科学）&lt;/a>
主要的非复合派生类型是&lt;a href="https://en.wikipedia.org/wiki/Pointer_(computer_programming)">指针&lt;/a>，这是一种数据类型，其值直接引用（或“指向”）使用其&lt;a href="https://en.wikipedia.org/wiki/Memory_address">地址&lt;/a>存储在&lt;a href="https://en.wikipedia.org/wiki/Computer_memory">计算机内存中&lt;/a>其他位置的另一个值。它是一种原始的&lt;a href="https://en.wikipedia.org/wiki/Reference_(computer_science)">参考&lt;/a>。（在日常生活中，一本书的页码可以被认为是引用另一本书的一段数据）。指针通常以类似于整数的格式存储；但是，尝试取消引用或“查找”其值永远不是有效内存地址的指针会导致程序崩溃。为了改善这个潜在问题，指针被认为是指向它们指向的数据类型的单独类型，即使底层表示相同。&lt;/p>
&lt;h3 id="function函数-类型">Function(函数) 类型&lt;/h3>
&lt;p>主条目：&lt;a href="https://en.wikipedia.org/wiki/Function_type">函数类型&lt;/a>
虽然也可以为函数分配类型，但在本文的设置中，它们的类型不被视为数据类型。在这里，数据被视为不同于&lt;a href="https://en.wikipedia.org/wiki/Algorithm">算法&lt;/a>。在编程中，函数与后者密切相关。但是，因为&lt;a href="https://en.wikipedia.org/wiki/Universal_Turing_machine">通用数据处理的&lt;/a>一个中心原则是算法可以&lt;a href="https://en.wikipedia.org/wiki/G%C3%B6del_numbering#Generalizations">表示为数据&lt;/a>，例如文本描述和二进制程序，数据和函数之间的对比是有限的。其实函数不仅可以用数据来表示，函数也可以用来&lt;a href="https://en.wikipedia.org/wiki/Lambda_calculus#Encoding_datatypes">对数据&lt;/a>进行&lt;a href="https://en.wikipedia.org/wiki/Lambda_calculus#Encoding_datatypes">编码&lt;/a>。许多当代&lt;a href="https://en.wikipedia.org/wiki/Type_systems">类型系统&lt;/a>强烈关注函数类型，许多现代语言允许函数作为&lt;a href="https://en.wikipedia.org/wiki/First-class_citizen">一等公民运行&lt;/a>。
将函数从被视为数据类型的对象中排除在相关领域中并不少见。[&lt;a href="https://en.wikipedia.org/wiki/Wikipedia:Citation_needed">需要引用&lt;/a>] 例如，&lt;a href="https://en.wikipedia.org/wiki/Predicate_logic">谓词逻辑&lt;/a>不允许在函数或谓词名称上应用&lt;a href="https://en.wikipedia.org/wiki/Quantifier_(logic)">量词&lt;/a>。&lt;/p>
&lt;h3 id="meta元-类型">Meta(元) 类型&lt;/h3>
&lt;p>主条目：&lt;a href="https://en.wikipedia.org/wiki/Metaclass">元类&lt;/a>
一些编程语言将类型信息表示为数据，从而实现&lt;a href="https://en.wikipedia.org/wiki/Type_introspection">类型自省&lt;/a>和&lt;a href="https://en.wikipedia.org/wiki/Reflection_(computer_programming)">反射&lt;/a>。相比之下，&lt;a href="https://en.wikipedia.org/wiki/Type_constructor">高阶&lt;/a> &lt;a href="https://en.wikipedia.org/wiki/Type_systems">类型系统&lt;/a>虽然允许从其他类型构造类型并作为值传递给函数，但通常避免基于它们进行&lt;a href="https://en.wikipedia.org/wiki/Computational">计算&lt;/a>决策。[&lt;a href="https://en.wikipedia.org/wiki/Wikipedia:Citation_needed">需要引用&lt;/a>]&lt;/p>
&lt;h3 id="utility实用程序-类型">Utility(实用程序) 类型&lt;/h3>
&lt;p>为方便起见，高级语言可能提供现成的“现实世界”数据类型，例如时间、日期、货币值和内存，即使该语言允许从原始类型构建它们。&lt;/p></description></item><item><title>Docs: Domains</title><link>https://desistdaydream.github.io/docs/IT%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/10.%E4%BA%91%E5%8E%9F%E7%94%9F/1.2.%E5%AE%9E%E7%8E%B0%E8%99%9A%E6%8B%9F%E5%8C%96%E7%9A%84%E5%B7%A5%E5%85%B7/%E8%99%9A%E6%8B%9F%E5%8C%96%E7%AE%A1%E7%90%86/Libvirt/XML-%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3/Domain-XML/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/IT%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/10.%E4%BA%91%E5%8E%9F%E7%94%9F/1.2.%E5%AE%9E%E7%8E%B0%E8%99%9A%E6%8B%9F%E5%8C%96%E7%9A%84%E5%B7%A5%E5%85%B7/%E8%99%9A%E6%8B%9F%E5%8C%96%E7%AE%A1%E7%90%86/Libvirt/XML-%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3/Domain-XML/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://libvirt.org/formatdomain.html">官方文档，Domain XML 格式&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>Domain 元素中有如下属性：&lt;/p>
&lt;ul>
&lt;li>&lt;strong>type&lt;/strong> # 指定用于运行域的管理程序。允许的值是特定于驱动程序的，但包括“xen”、“kvm”、“hvf”（自 8.1.0 和 QEMU 2.12 起）、“qemu”和“lxc”。&lt;/li>
&lt;li>&lt;strong>id&lt;/strong> # 它是正在运行的客户机的唯一整数标识符。非活动机器没有 id 值。&lt;/li>
&lt;/ul>
&lt;p>下列元素都属于 &lt;code>&amp;lt;domain&amp;gt;&lt;/code> 这个根元素的子元素&lt;/p>
&lt;ul>
&lt;li>TODO:&lt;/li>
&lt;li>&amp;hellip;&amp;hellip;&lt;/li>
&lt;li>&lt;a href="#devices">devices&lt;/a>&lt;/li>
&lt;li>&amp;hellip;&amp;hellip;&lt;/li>
&lt;/ul>
&lt;h1 id="graphical-framebuffers">Graphical framebuffers&lt;/h1>
&lt;p>&lt;a href="https://libvirt.org/formatdomain.html#graphical-framebuffers">https://libvirt.org/formatdomain.html#graphical-framebuffers&lt;/a>&lt;/p>
&lt;h1 id="devices">Devices&lt;/h1>
&lt;p>&lt;a href="https://libvirt.org/formatdomain.html#devices">https://libvirt.org/formatdomain.html#devices&lt;/a>&lt;/p>
&lt;h2 id="network-interfaces">Network interfaces&lt;/h2>
&lt;p>&lt;a href="https://libvirt.org/formatdomain.html#network-interfaces">https://libvirt.org/formatdomain.html#network-interfaces&lt;/a>&lt;/p></description></item><item><title>Docs: ECMAScript 环境安装与使用</title><link>https://desistdaydream.github.io/docs/IT%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/2.%E7%BC%96%E7%A8%8B/%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/ECMAScript/ECMAScript-%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8/ECMAScript-%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/IT%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/2.%E7%BC%96%E7%A8%8B/%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/ECMAScript/ECMAScript-%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8/ECMAScript-%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;/blockquote>
&lt;p>有两种运行时环境可以运行 ECMAScript 代码(Javascript、Typescript)&lt;/p>
&lt;ul>
&lt;li>**Browser **# 浏览器就是 ECMAScript 的运行时环境。&lt;/li>
&lt;li>&lt;strong>Node.js&lt;/strong> # 在服务器或 PC 上安装 Node.js 环境以运行 ECMAScript 代码&lt;/li>
&lt;li>&lt;strong>Deno&lt;/strong> # &lt;a href="https://github.com/denoland/deno">GtiHub 项目，denoland/deno&lt;/a>。据说要替代 Node.js，很尴尬的是。。。早期 18 年的 issue 中被各种国人无意义灌水&lt;/li>
&lt;li>&lt;strong>Bun&lt;/strong> # &lt;a href="https://github.com/oven-sh/bun">GtiHub 项目，oven-sh/bun&lt;/a>&lt;/li>
&lt;/ul>
&lt;p>但是这两者可以提供的 API 能力各不相同&lt;/p>
&lt;ul>
&lt;li>Browser 可以提供的 dockument、window 和其他关于 DOM 或其他 Web 平台 API 的对象。&lt;/li>
&lt;li>Node.js 则可以提供很多操作系统相关的 API，比如文件的读写、进程管理、网络通信等等。&lt;/li>
&lt;/ul>
&lt;p>Node.js 与 Browser 都是基于 Chrome V8 引擎的 ECMAScript 运行时环境&lt;/p>
&lt;p>你也许会想，直接在我的硬盘上创建好 HTML 和 JavaScript 文件，然后用浏览器打开，不就可以看到效果了吗？&lt;/p>
&lt;p>这种方式运行部分 JavaScript 代码没有问题，但由于浏览器的安全限制，以 file:// 开头的地址无法执行如联网等 JavaScript 代码，最终，你还是需要架设一个 Web 服务器，然后以 http:// 开头的地址来正常执行所有 JavaScript 代码。&lt;/p>
&lt;p>所以，想要运行 JavaScript 编写的静态文件，通常都需要一个可以提供 HTTP 服务的程序，以便响应客户端的请求返回这些静态文件。通常在生产环境中，我们都会将静态资源文件放到 Nginx 的目录中，由 Nginx 为客户端提供 HTTP 服务。&lt;/p>
&lt;p>而本地测试时，我们通过 npm 与 yarn 工具即可安装一个简易的 HTTP 服务，这个 HTTP 服务都是由 JS 代码写的，必须要保证本地有 Node.js 环境，即可启动一个 HTTP 服务&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># Npm 安装 http-server&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>~&lt;span style="color:#f92672">]&lt;/span>&lt;span style="color:#75715e"># npm install http-server&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># Yarn 安装 http-server&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>~&lt;span style="color:#f92672">]&lt;/span>&lt;span style="color:#75715e"># yarn add http-server&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>http-server 来源于 &lt;a href="https://github.com/http-party/http-server">GitHub 项目，http-party/http-server&lt;/a>&lt;/p>
&lt;p>通过 &lt;code>npm exec serve&lt;/code> 命令将会安装另一个名为 serve 的库以运行 HTTP 服务，默认在 3000 端口上启动 HTTP 服务，通过浏览器访问 localhost:3000 即可获取到所有自己编写的静态文件，便于让开发人员在本地调试。&lt;/p>
&lt;h2 id="重点运行具有-module模块-功能的静态资源">(重点)运行具有 Module(模块) 功能的静态资源&lt;/h2>
&lt;p>从《ECMAScript 模块》章节可以看到，当我们使用 &lt;code>import name from './one.js'&lt;/code> 导入的模块是一个文件时，那么这个文件将会被响应给浏览器，如果使用 &lt;code>import name from 'one'&lt;/code> 导入的模块是一组文件时，此时浏览器无法直接识别，将会产生报错。因为浏览器想要执行这一组文件需要发起很多次的请求将所有文件都加载到本地，这其中的路由路径将是不可控的。&lt;/p>
&lt;p>所以，此时我们则需要想办法将这一组文件变为一个文件响应给浏览器以便加载代码。这个转换的操作，我们可以使用打包工具(i.e.Webpack、Vite 等等) 将源代码&lt;strong>打包编译&lt;/strong>成新的静态文件即可。&lt;/p>
&lt;p>后面的逻辑，与基本运行 ECMAScript 代码的行为就是一样的了。&lt;/p>
&lt;h2 id="使用-vite-运行-ecmascript-代码">使用 Vite 运行 ECMAScript 代码&lt;/h2>
&lt;p>npm、yarn 的打包后运行代码的速度非常缓慢，才是推荐使用 Vite 工具启动 HTTP 服务并运行 JS/TS 代码，详见：[《Vite》](/docs/IT学习笔记/2.编程/高级编程语言/ECMAScript/ECMAScript%20 工具/Vite.md 工具/Vite.md) 章节&lt;/p>
&lt;h2 id="运行-typesript">运行 TypeSript&lt;/h2>
&lt;p>Node.js 和 浏览器都无法直接运行 TypeScript 代码，这是因为 TS 的代码需要先转换为 JS 代码才可以运行。此时就需要一种工具，先转换再运行，或者直接转换运行一体。&lt;/p>
&lt;ul>
&lt;li>&lt;strong>tsc&lt;/strong> # 将 TS 代码转换为 JS 代码。&lt;code>npm install -g typescript&lt;/code>&lt;/li>
&lt;li>&lt;strong>ts-node&lt;/strong> # 可以直接转换并运行 TS 代码，&lt;code>npm install -g ts-node&lt;/code> 安装即可&lt;/li>
&lt;/ul>
&lt;h1 id="nodejs">Node.js&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://nodejs.org/en/">org 官网&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://nodejs.dev/">dev 官网&lt;/a>&lt;/li>
&lt;li>&lt;a href="http://nodejs.cn/">dev 官网中文翻译&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Node.js">Wiki,Node.js&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>Node.js 是基于 Chrome V8 引擎的 ECMAScript 运行时环境，由 RyanDahl 于 2009 年 5 月 27 日发布。转年(i.e.2010 年 1 月)，为 Node.js 环境引入了一个名为 npm 的包管理器。包管理器使程序员更容易发布和共享 Node.js 的源代码，旨在简化包的安装、更新、卸载。&lt;/p>
&lt;p>Browser 和 Node.js 都是 ECMAScript 的运行时环境，但是这两者可以提供的 API 能力各不相同&lt;/p>
&lt;ul>
&lt;li>Browser 可以提供的 dockument、window 和其他关于 DOM 或其他 Web 平台 API 的对象。&lt;/li>
&lt;li>Node.js 则可以提供很多操作系统相关的 API，比如文件的读写、进程管理、网络通信等等。&lt;/li>
&lt;/ul>
&lt;p>通过 Node.js，可以让我们使用一种语言编写前端与后端。我们甚至可以通过 npm 与 yarn 安装第三方库后，使用 Node.js 在本地监听端口并响应给客户端静态资源文件。&lt;/p>
&lt;h2 id="安装-nodejs">安装 Node.js&lt;/h2>
&lt;h3 id="linux">Linux&lt;/h3>
&lt;p>从&lt;a href="https://nodejs.org/zh-cn/download/">官网&lt;/a>下载 Linux 版的 &lt;code>.tar.xg&lt;/code> 包，并解压&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>export NodejsVersion&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;v16.15.0&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>wget https://nodejs.org/dist/&lt;span style="color:#e6db74">${&lt;/span>NodejsVersion&lt;span style="color:#e6db74">}&lt;/span>/node-&lt;span style="color:#e6db74">${&lt;/span>NodejsVersion&lt;span style="color:#e6db74">}&lt;/span>-linux-x64.tar.xz
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>tar -xvf node-&lt;span style="color:#e6db74">${&lt;/span>NodejsVersion&lt;span style="color:#e6db74">}&lt;/span>-linux-x64.tar.xz -C /usr/local/
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>mv /usr/local/node-&lt;span style="color:#e6db74">${&lt;/span>NodejsVersion&lt;span style="color:#e6db74">}&lt;/span>-linux-x64 /usr/local/nodejs
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>配置环境变量&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>sudo tee /etc/profile.d/nodejs.sh &amp;gt; /dev/null &amp;lt;&amp;lt;-&lt;span style="color:#e6db74">&amp;#34;EOF&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>export PATH&lt;span style="color:#f92672">=&lt;/span>$PATH:/usr/local/nodejs/bin
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>EOF
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="windows">Windows&lt;/h3>
&lt;p>警告！！！由于 msi 安装包会修改 %PREFIX% 为 &lt;code>%APPDATA%\npm&lt;/code> ，并将该目录到 $PATH。我个人推荐下载 zip，并自己解压到想要的位置后，手动配置环境变量。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-powershell" data-lang="powershell">&lt;span style="display:flex;">&lt;span>$NodejsVersion = &lt;span style="color:#e6db74">&amp;#34;18.14.1&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>$NodejsUrl = &lt;span style="color:#e6db74">&amp;#34;https://nodejs.org/dist/v&lt;/span>$NodejsVersion&lt;span style="color:#e6db74">/node-v&lt;/span>$NodejsVersion&lt;span style="color:#e6db74">-win-x64.zip&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>$TempZipFile = &lt;span style="color:#e6db74">&amp;#34;D:\tmp\nodejs.zip&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>$ExtractPath = &lt;span style="color:#e6db74">&amp;#34;D:\Tools&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># Download the zip file to a temporary location&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Invoke-WebRequest -Uri $NodejsUrl -OutFile $TempZipFile
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># Extract the contents of the zip file to the installation directory and rename the top-level directory to &amp;#34;nodejs&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Expand-Archive -Path $TempZipFile -DestinationPath $ExtractPath
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Rename-Item -Path &lt;span style="color:#e6db74">&amp;#34;&lt;/span>$ExtractPath&lt;span style="color:#e6db74">\node-v&lt;/span>$NodejsVersion&lt;span style="color:#e6db74">-win-x64&amp;#34;&lt;/span> -NewName &lt;span style="color:#e6db74">&amp;#34;nodejs&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>将 nodejs/ 目录添加到用户的 PATH 环境变量中&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-powershell" data-lang="powershell">&lt;span style="display:flex;">&lt;span>$path = [&lt;span style="color:#66d9ef">Environment&lt;/span>]::GetEnvironmentVariable(&lt;span style="color:#e6db74">&amp;#34;Path&amp;#34;&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;User&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>$newPath = &lt;span style="color:#e6db74">&amp;#34;D:\Tools\nodejs&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>[&lt;span style="color:#66d9ef">Environment&lt;/span>]::SetEnvironmentVariable(&lt;span style="color:#e6db74">&amp;#34;Path&amp;#34;&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;&lt;/span>$path&lt;span style="color:#e6db74">;&lt;/span>$newPath&lt;span style="color:#e6db74">&amp;#34;&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;User&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="目录结构">目录结构&lt;/h3>
&lt;p>Linux 目录结构，node_modules/ 目录在 lib/ 目录下，这点与 Windows 不同。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">]&lt;/span>&lt;span style="color:#75715e"># tree -L 2 -F&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>.
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>├── bin/
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>│   ├── corepack -&amp;gt; ../lib/node_modules/corepack/dist/corepack.js*
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>│   ├── node*
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>│   ├── npm -&amp;gt; ../lib/node_modules/npm/bin/npm-cli.js*
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>│   ├── npx -&amp;gt; ../lib/node_modules/npm/bin/npx-cli.js*
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>│   ├── pnpm -&amp;gt; ../lib/node_modules/corepack/dist/pnpm.js*
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>│   ├── pnpx -&amp;gt; ../lib/node_modules/corepack/dist/pnpx.js*
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>│   ├── yarn -&amp;gt; ../lib/node_modules/corepack/dist/yarn.js*
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>│   └── yarnpkg -&amp;gt; ../lib/node_modules/corepack/dist/yarnpkg.js*
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>├── CHANGELOG.md
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>├── include/
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>│   └── node/
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>├── lib/
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>│   └── node_modules/
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>├── LICENSE
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>├── README.md
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>└── share/
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ├── doc/
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ├── man/
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> └── systemtap/
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Windows 目录结构&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>$ tree -L &lt;span style="color:#ae81ff">2&lt;/span> -F
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>./
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>├── CHANGELOG.md*
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>├── LICENSE*
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>├── README.md*
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>├── corepack*
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>├── corepack.cmd*
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>├── install_tools.bat*
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>├── node.exe*
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>├── node_etw_provider.man*
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>├── node_modules/
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>│   ├── corepack/
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>│   └── npm/
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>├── nodevars.bat*
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>├── npm*
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>├── npm.cmd*
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>├── npx*
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>└── npx.cmd*
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="nvm">NVM&lt;/h2>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://github.com/nvm-sh/nvm">GitHub 项目，nvm-sh/nvm&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>&lt;strong>Node Version Manager(Node.js 版本管理器，简称 NVM)&lt;/strong>&lt;/p>
&lt;h2 id="nodejs-关联文件与配置">Node.js 关联文件与配置&lt;/h2>
&lt;p>详见：&lt;a href="docs/IT%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/2.%E7%BC%96%E7%A8%8B/%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/ECMAScript/ECMAScript%20%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8/ECMAScript%20%E6%A8%A1%E5%9D%97%E4%B8%8E%E5%8C%85%E7%9A%84%E4%BD%BF%E7%94%A8%E4%B8%8E%E7%AE%A1%E7%90%86.md#npm%20%E5%85%B3%E8%81%94%E6%96%87%E4%BB%B6%E4%B8%8E%E9%85%8D%E7%BD%AE">npm 关键文件与配置&lt;/a>&lt;/p>
&lt;h1 id="初始化项目">初始化项目&lt;/h1>
&lt;p>npm 等包管理工具下载完框架后，会自动生成项目目录，这些目录是已经初始化完成的项目，包含了很多必要的文件，比如 package.json 等。&lt;/p>
&lt;p>随着学习深入，会逐步总结一个前端项目如果不使用框架从头构建的话会需要什么。&lt;/p>
&lt;ul>
&lt;li>&lt;strong>public/&lt;/strong> 目录存放公共资源&lt;/li>
&lt;li>&lt;strong>src/&lt;/strong> # 所有代码都在 src/ 目录下&lt;/li>
&lt;li>&lt;strong>.eslintrc.cjs&lt;/strong> # ESLint 程序配置&lt;/li>
&lt;li>&lt;strong>.prettierc.json&lt;/strong> # Prettier 插件的配置&lt;/li>
&lt;li>&lt;strong>env.d.ts&lt;/strong> #&lt;/li>
&lt;li>&lt;strong>index.html&lt;/strong> # 程序入口&lt;/li>
&lt;li>[&lt;strong>package.json&lt;/strong>](/docs/IT学习笔记/2.编程/高级编程语言/ECMAScript/ECMAScript%20 环境安装与使用/package.json.md 环境安装与使用/package.json.md) # 包管理器配置文件，比如 npm、pnpm 等&lt;/li>
&lt;li>&lt;strong>vite.config.ts&lt;/strong> # Vite 程序给项目打包时使用的配置&lt;/li>
&lt;li>&lt;strong>tsconfig.json&lt;/strong> #&lt;/li>
&lt;li>&lt;strong>tsconfig.config.json&lt;/strong> # [TSConfig](/docs/IT学习笔记/2.编程/高级编程语言/ECMAScript/ECMAScript%20 环境安装与使用/TSConfig.md 环境安装与使用/TSConfig.md) 文件&lt;/li>
&lt;/ul>
&lt;h2 id="javascript-项目初始化">JavaScript 项目初始化&lt;/h2>
&lt;p>无&lt;/p>
&lt;h2 id="typescript-项目初始化">TypeScript 项目初始化&lt;/h2>
&lt;p>使用 &lt;code>npm install -g typescript&lt;/code> 安装 tsc 命令。&lt;/p>
&lt;p>使用 &lt;code>tsc init&lt;/code> 命令将会生成 [TSConfig](/docs/IT学习笔记/2.编程/高级编程语言/ECMAScript/ECMAScript%20 环境安装与使用/TSConfig.md 环境安装与使用/TSConfig.md) 文件。&lt;/p>
&lt;h1 id="编译与打包">编译与打包&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://github.com/webpack/webpack">GitHub 项目，webpack/webpack&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://github.com/rollup/rollup">GitHub 项目，rollup/rollup&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>大型项目通常都要打包，打包工具有很多：&lt;/p>
&lt;ul>
&lt;li>Webpack&lt;/li>
&lt;li>Rollup&lt;/li>
&lt;li>Vite&lt;/li>
&lt;li>&amp;hellip;&amp;hellip;等等&lt;/li>
&lt;/ul>
&lt;h1 id="常见问题">常见问题&lt;/h1>
&lt;h2 id="nodejs-无法使用-es6-语法问题">Node.js 无法使用 ES6 语法问题&lt;/h2>
&lt;p>无法使用 import 关键字导入模块。参考 &lt;a href="https://nodejs.org/docs/latest-v16.x/api/esm.html#enabling">https://nodejs.org/docs/latest-v16.x/api/esm.html#enabling&lt;/a>，在 package.json 文件中设置 &lt;code>&amp;quot;type&amp;quot;: &amp;quot;module&amp;quot;&lt;/code> 或者使用 &lt;code>--input-type=module&lt;/code> 命令行参数以告诉 Node.js 使用 ECMAScript 模块加载器。默认情况下，Node.js 使用 CommonJS 模块加载器。&lt;/p></description></item><item><title>Docs: EXT FileSystem</title><link>https://desistdaydream.github.io/docs/IT%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2.Kernel%E5%86%85%E6%A0%B8/6.File_System_%E7%AE%A1%E7%90%86/%E7%A3%81%E7%9B%98%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/EXT-FileSystem/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/IT%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2.Kernel%E5%86%85%E6%A0%B8/6.File_System_%E7%AE%A1%E7%90%86/%E7%A3%81%E7%9B%98%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/EXT-FileSystem/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://mp.weixin.qq.com/s/qJdoXTv_XS_4ts9YuzMNIw">公众号，小林 coding-一口气搞懂「文件系统」，就靠这 25 张图了&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.junmajinlong.com/linux/ext_filesystem/">骏马金龙，第4章 ext文件系统机制原理剖析&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>硬盘最底层的读写 IO 一次是一个扇区 512 字节，如果要读写大量文件，以扇区为单位肯定很慢很消耗性能，所以硬盘使用了一个称作逻辑块的概念。逻辑块是逻辑的，由磁盘驱动器负责维护和操作，它并非是像扇区一样物理划分的。一个逻辑块的大小可能包含一个或多个扇区，每个逻辑块都有唯一的地址，称为 LBA。有了逻辑块之后，磁盘控制器对数据的操作就以逻辑块为单位，一次读写一个逻辑块，磁盘控制器知道如何将逻辑块翻译成对应的扇区并读写数据。&lt;/p>
&lt;p>到了 Linux 操作系统层次，通过文件系统提供了一个也称为块的读写单元，文件系统数据块的大小一般为 1024bytes (1KiB) 或 2048bytes (2KiB) 或 4096bytes (4KiB)。文件系统数据块也是逻辑概念，是文件系统层次维护的，而磁盘上的逻辑数据块是由磁盘控制器维护的，文件系统的 IO 管理器知道如何将它的数据块翻译成磁盘维护的数据块地址 LBA。&lt;/p>
&lt;p>对于使用文件系统的 IO 操作来说，比如读写文件，这些 &lt;strong>IO 的基本单元&lt;/strong>是&lt;strong>文件系统上的数据块&lt;/strong>，一次读写一个文件系统数据块。比如需要读一个或多个块时，文件系统的 IO 管理器首先计算这些文件系统块对应在哪些磁盘数据块，也就是计算出 LBA，然后通知磁盘控制器要读取哪些块的数据，硬盘控制器将这些块翻译成扇区地址，然后从扇区中读取数据，再通过硬盘控制器将这些扇区数据重组写入到内存中去。&lt;/p>
&lt;p>&lt;strong>Block(块)&lt;/strong>，存放数据的最小单位，假如每个块为 4KiB，那大于 5KiB 的块就需要两个块，并且逻辑上占用了 8KiB 的空间。&lt;/p>
&lt;p>&lt;strong>Block Group(块组)&lt;/strong>，多个 Block 的集合&lt;/p>
&lt;p>Ext 预留了一些 Inode 做特殊特性使用，如下：某些可能并非总是准确，具体的 inode 号对应什么文件可以使用 &lt;code>find /-inum NUM&lt;/code> 查看&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>Ext4的特殊inode
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Inode号 用途
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">0&lt;/span> 不存在0号inode，可用于标识目录data block中已删除的文件
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">1&lt;/span> 虚拟文件系统，如/proc和/sys
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">2&lt;/span> 根目录 &lt;span style="color:#75715e"># 注意此行&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">3&lt;/span> ACL索引
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">4&lt;/span> ACL数据
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">5&lt;/span> Boot loader
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">6&lt;/span> 未删除的目录
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">7&lt;/span> 预留的块组描述符inode
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">8&lt;/span> 日志inode
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">11&lt;/span> 第一个非预留的inode，通常是 lost+found 目录
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>所以在 ext4 文件系统的 dumpe2fs 信息中，能观察到 fisrt inode 号可能为 11 也可能为 12。&lt;/p>
&lt;h2 id="块块组inode-计算">块、块组、Inode 计算&lt;/h2>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>参考哪里？我也想知道真实的计算逻辑。。。&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>这些计算的结果通常与下列设置有关&lt;/p>
&lt;ul>
&lt;li>&lt;strong>DiskSize&lt;/strong> # 磁盘空间&lt;/li>
&lt;li>&lt;strong>BlockSize&lt;/strong> # 通常为 4096 Bytes
&lt;ul>
&lt;li>可使用 mke2fs -b 手动指定&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>BlocksPerGroup&lt;/strong> # 通常为 32768。每个块组中块的数量。
&lt;ul>
&lt;li>可使用 mke2fs -g 手动指定&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>BytesPerInode&lt;/strong> # 通常为 16384 Bytes。创建文件系统时，为每块 BytesPerInode 大小的空间创建一个 Inode。
&lt;ul>
&lt;li>BytesPerInode 也称为 inode_ratio，即.Inode 比率，全称应该是 Inode 分配比率，即每多少空间分配一个 Inode。&lt;/li>
&lt;li>可使用 mke2fs -i 手动指定&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>InodeSize&lt;/strong> # 通常为 256 Bytes。大小是 128 的倍数，最小为 128 Bytes。&lt;/li>
&lt;/ul>
&lt;p>其中 BlocksPerGroup(每个块组中块的数量)、BytesPerInode(每个Inode负责的空间大小) 这种值是后续计算的基础。固定下来这些，就算分区空间自动扩容/缩容，也可以根据这种数据自动增加/删除块的数量和 Inode 的数量。&lt;/p>
&lt;p>其中块大小为 4K，Inode 比率为 16K，也就是说，至少每 4 个块分配一个 Inode。当然分配的这些 inode 号只是预分配，并不真的代表会全部使用，毕竟每个文件才会分配一个 inode 号。&lt;/p>
&lt;p>这些数据将会计算出：&lt;/p>
&lt;ul>
&lt;li>&lt;strong>BlockCount&lt;/strong> # 块总数&lt;/li>
&lt;li>&lt;strong>BlockGroup&lt;/strong> # 块组总数&lt;/li>
&lt;li>&lt;strong>InodeCount&lt;/strong> # Inode 总数&lt;/li>
&lt;li>&lt;strong>InodePreGroup&lt;/strong> # 每个块组中包含的 Inode 数量&lt;/li>
&lt;li>&lt;strong>InodeUseage&lt;/strong> # 所有 Inode 占用的空间&lt;/li>
&lt;/ul>
&lt;p>假如现在有一块 35GiB 的磁盘，需要先转为 Bytes。然后根据给定的 BlockSize(块大小) 和 BlocksPerGroup(块组中块的数量)，计算出需要创建创建的&lt;strong>块数量&lt;/strong>和&lt;strong>块组数量&lt;/strong>。&lt;/p>
&lt;p>&lt;strong>Block 与 BlockGroup 的计算&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>BlockCount = DiskSize / BlockSize = 37580963840 / 4096 = 9175040&lt;/li>
&lt;li>BlockGroupCount = BlockCount / BlocksPerGroup = 9175040 / 32768 = 280&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>Inode 的计算&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>InodeCount = DiskSize / BytesPerInode = 37580963840 / 16384 = 2293760&lt;/li>
&lt;/ul>
&lt;blockquote>
&lt;p>由于之前已经知道了“每4个块分配一个Inode”，那么用“总块数/4”也是可以得到这个 Inode 总数的。&lt;/p>
&lt;/blockquote>
&lt;p>计算出的 Inode 数量将会平均分配到每个块组中&lt;/p>
&lt;ul>
&lt;li>InodePreGroup = InodeCount / BlockGroupCount = 2293760 / 280 = 8192&lt;/li>
&lt;/ul>
&lt;blockquote>
&lt;p>由于之前已经知道了“每4个块分配一个Inode”，那么用“每个块组中块的数量/4”也是可以得到每个块组中 Inode 的数量。&lt;/p>
&lt;/blockquote>
&lt;p>计算所有 Inode 需要占用的磁盘空间&lt;/p>
&lt;ul>
&lt;li>InodeUseage = InodeCount * InodeSize = 2293760 * 256 = 587202560 Bytes = 560 MiB&lt;/li>
&lt;/ul>
&lt;p>也就是说，一块 35 G 的硬盘，需要拿出来至少 560 MiB 的空间来存放 Inode 数据。&lt;/p>
&lt;p>&lt;strong>TODO:&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>&lt;strong>Inode 还有一个最低数量？就算执行 &lt;code>mke2fs -N 1&lt;/code> 命令，最后也不会只有一个 Inode，而是有 4480 个 Inode，这个数是怎么来的？&lt;/strong>&lt;/li>
&lt;li>**试了下 &lt;code>mke2fs -N 1000000&lt;/code> 最后生成的 Inode 数为 1003520，正好是 4480 的倍数&lt;/li>
&lt;li>&lt;strong>如果是 &lt;code>mke2fs -N 4481&lt;/code>，则生成的 Inode 数为 8960，也是 4480 的倍数。。。这个值到底咋来的。。。o(╯□╰)o&lt;/strong>**&lt;/li>
&lt;li>好像是根据 Inodes per group 的值来的，这个值好像必须要是 16 的倍数，并且最低值是 16，可是这个说法的来源是在哪呢？&lt;/li>
&lt;/ul>
&lt;p>上述计算的结果可以通过 dumpe2fs 命令查看&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>~&lt;span style="color:#f92672">]&lt;/span>&lt;span style="color:#75715e"># dumpe2fs -h ${DEVICE} | egrep -i &amp;#34;block|inode&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>dumpe2fs 1.45.5 &lt;span style="color:#f92672">(&lt;/span>07-Jan-2020&lt;span style="color:#f92672">)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Filesystem features: ext_attr resize_inode dir_index filetype sparse_super large_file
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Inode count: &lt;span style="color:#ae81ff">2293760&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Block count: &lt;span style="color:#ae81ff">9175040&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Reserved block count: &lt;span style="color:#ae81ff">458752&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Free blocks: &lt;span style="color:#ae81ff">9018814&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Free inodes: &lt;span style="color:#ae81ff">2293749&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>First block: &lt;span style="color:#ae81ff">0&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Block size: &lt;span style="color:#ae81ff">4096&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Reserved GDT blocks: &lt;span style="color:#ae81ff">1021&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Blocks per group: &lt;span style="color:#ae81ff">32768&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Inodes per group: &lt;span style="color:#ae81ff">8192&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Inode blocks per group: &lt;span style="color:#ae81ff">512&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Reserved blocks uid: &lt;span style="color:#ae81ff">0&lt;/span> &lt;span style="color:#f92672">(&lt;/span>user root&lt;span style="color:#f92672">)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Reserved blocks gid: &lt;span style="color:#ae81ff">0&lt;/span> &lt;span style="color:#f92672">(&lt;/span>group root&lt;span style="color:#f92672">)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>First inode: &lt;span style="color:#ae81ff">11&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Inode size: &lt;span style="color:#ae81ff">256&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="todo-最低的-inode">TODO: 最低的 Inode&lt;/h3>
&lt;p>假如我们需要最少 1 个 Inode&lt;/p>
&lt;p>此时已知&lt;/p>
&lt;ul>
&lt;li>BlockCount = 9175040&lt;/li>
&lt;li>BlockGroupCount = 280&lt;/li>
&lt;li>BlockSize = 4096 Bytes&lt;/li>
&lt;li>InodeSize = 256 Bytes&lt;/li>
&lt;li>InodeRatio = 16384 Bytes&lt;/li>
&lt;/ul>
&lt;p>每 4 个块给 1 个 Inode，但肯定不是这个思路，因为照着这种算法，那就是有 2293760 个。所以肯定不是每 4 个块给 1 个 Inode。&lt;/p>
&lt;p>真实场景：&lt;/p>
&lt;ul>
&lt;li>现在是每 2048 个块给 一个 Inode&lt;/li>
&lt;li>280 个块组&lt;/li>
&lt;li>&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>~&lt;span style="color:#f92672">]&lt;/span>&lt;span style="color:#75715e"># mke2fs -N 1 /dev/vdb&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>mke2fs 1.45.5 &lt;span style="color:#f92672">(&lt;/span>07-Jan-2020&lt;span style="color:#f92672">)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>/dev/vdb contains a ext2 file system
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> last mounted on Sat Mar &lt;span style="color:#ae81ff">11&lt;/span> 16:14:14 &lt;span style="color:#ae81ff">2023&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Proceed anyway? &lt;span style="color:#f92672">(&lt;/span>y,N&lt;span style="color:#f92672">)&lt;/span> y
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Creating filesystem with &lt;span style="color:#ae81ff">9175040&lt;/span> 4k blocks and &lt;span style="color:#ae81ff">4480&lt;/span> inodes
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Filesystem UUID: acebc9ab-c53e-4f74-bd6b-443343a76bab
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Superblock backups stored on blocks:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> 32768, 98304, 163840, 229376, 294912, 819200, 884736, 1605632, 2654208,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> 4096000, &lt;span style="color:#ae81ff">7962624&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Allocating group tables: &lt;span style="color:#66d9ef">done&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Writing inode tables: &lt;span style="color:#66d9ef">done&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Writing superblocks and filesystem accounting information: &lt;span style="color:#66d9ef">done&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>~&lt;span style="color:#f92672">]&lt;/span>&lt;span style="color:#75715e"># dumpe2fs -h ${DEVICE} | egrep -i &amp;#34;block|inode&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>dumpe2fs 1.45.5 &lt;span style="color:#f92672">(&lt;/span>07-Jan-2020&lt;span style="color:#f92672">)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Filesystem features: ext_attr resize_inode dir_index filetype sparse_super large_file
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Inode count: &lt;span style="color:#ae81ff">4480&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Block count: &lt;span style="color:#ae81ff">9175040&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Reserved block count: &lt;span style="color:#ae81ff">458752&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Free blocks: &lt;span style="color:#ae81ff">9161894&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Free inodes: &lt;span style="color:#ae81ff">4469&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>First block: &lt;span style="color:#ae81ff">0&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Block size: &lt;span style="color:#ae81ff">4096&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Reserved GDT blocks: &lt;span style="color:#ae81ff">1021&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Blocks per group: &lt;span style="color:#ae81ff">32768&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Inodes per group: &lt;span style="color:#ae81ff">16&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Inode blocks per group: &lt;span style="color:#ae81ff">1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Reserved blocks uid: &lt;span style="color:#ae81ff">0&lt;/span> &lt;span style="color:#f92672">(&lt;/span>user root&lt;span style="color:#f92672">)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Reserved blocks gid: &lt;span style="color:#ae81ff">0&lt;/span> &lt;span style="color:#f92672">(&lt;/span>group root&lt;span style="color:#f92672">)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>First inode: &lt;span style="color:#ae81ff">11&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Inode size: &lt;span style="color:#ae81ff">256&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h1 id="文件的存储">文件的存储&lt;/h1>
&lt;p>文件的数据是要存储在硬盘上面的，数据在磁盘上的存放方式，就像程序在内存中存放的方式那样，有以下两种：&lt;/p>
&lt;ul>
&lt;li>连续空间存放方式&lt;/li>
&lt;li>非连续空间存放方式&lt;/li>
&lt;/ul>
&lt;p>其中，非连续空间存放方式又可以分为「链表方式」和「索引方式」。
不同的存储方式，有各自的特点，重点是要分析它们的存储效率和读写性能，接下来分别对每种存储方式说一下。&lt;/p>
&lt;h2 id="连续空间存放方式">连续空间存放方式&lt;/h2>
&lt;blockquote>
&lt;p>注意：这里只针对机械硬盘，固态硬盘并没有磁道等概念&lt;/p>
&lt;/blockquote>
&lt;p>连续空间存放方式顾名思义，&lt;strong>文件存放在磁盘「连续的」物理空间中&lt;/strong>。这种模式下，文件的数据都是紧密相连，&lt;strong>读写效率很高&lt;/strong>，因为一次磁盘寻道就可以读出整个文件。&lt;/p>
&lt;p>使用连续存放的方式有一个前提，必须先知道一个文件的大小，这样文件系统才会根据文件的大小在磁盘上找到一块连续的空间分配给文件。&lt;/p>
&lt;p>所以，&lt;strong>文件头里需要指定「起始块的位置」和「长度」&lt;/strong>，有了这两个信息就可以很好的表示文件存放方式是一块连续的磁盘空间。&lt;/p>
&lt;p>注意，此处说的文件头，就类似于 Linux 的 inode。&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/op2fw9/1616167677049-26c7ae42-9e37-426a-99f9-6e59df62e691.png" alt="">&lt;/p>
&lt;p>连续空间存放的方式虽然读写效率高，&lt;strong>但是有「磁盘空间碎片」和「文件长度不易扩展」的缺陷。&lt;/strong>&lt;/p>
&lt;p>如下图，如果文件 B 被删除，磁盘上就留下一块空缺，这时，如果新来的文件小于其中的一个空缺，我们就可以将其放在相应空缺里。但如果该文件的大小大于所有的空缺，但却小于空缺大小之和，则虽然磁盘上有足够的空缺，但该文件还是不能存放。当然了，我们可以通过将现有文件进行挪动来腾出空间以容纳新的文件，但是这个在磁盘挪动文件是非常耗时，所以这种方式不太现实。&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/op2fw9/1616167677046-4fd1191e-4e74-4653-8ef4-24ba781c4f57.png" alt="">&lt;/p>
&lt;p>另外一个缺陷是文件长度扩展不方便，例如上图中的文件 A 要想扩大一下，需要更多的磁盘空间，唯一的办法就只能是挪动的方式，前面也说了，这种方式效率是非常低的。
那么有没有更好的方式来解决上面的问题呢？答案当然有，既然连续空间存放的方式不太行，那么我们就改变存放的方式，使用非连续空间存放方式来解决这些缺陷。&lt;/p>
&lt;h2 id="非连续空间存放方式">非连续空间存放方式&lt;/h2>
&lt;p>非连续空间存放方式分为「链表方式」和「索引方式」。&lt;/p>
&lt;blockquote>
&lt;p>我们先来看看链表的方式。&lt;/p>
&lt;/blockquote>
&lt;p>链表的方式存放是&lt;strong>离散的，不用连续的&lt;/strong>，于是就可以&lt;strong>消除磁盘碎片&lt;/strong>，可大大提高磁盘空间的利用率，同时&lt;strong>文件的长度可以动态扩展&lt;/strong>。根据实现的方式的不同，链表可分为「&lt;strong>隐式链表&lt;/strong>」和「&lt;strong>显式链接&lt;/strong>」两种形式。&lt;/p>
&lt;p>文件要以「&lt;strong>隐式链表&lt;/strong>」的方式存放的话，&lt;strong>实现的方式是文件头要包含「第一块」和「最后一块」的位置，并且每个数据块里面留出一个指针空间，用来存放下一个数据块的位置&lt;/strong>，这样一个数据块连着一个数据块，从链头开是就可以顺着指针找到所有的数据块，所以存放的方式可以是不连续的。
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/op2fw9/1616167677039-c71df217-651d-42ac-8cf6-444dedae8c1c.png" alt="">
隐式链表的存放方式的&lt;strong>缺点在于无法直接访问数据块，只能通过指针顺序访问文件，以及数据块指针消耗了一定的存储空间&lt;/strong>。隐式链接分配的&lt;strong>稳定性较差&lt;/strong>，系统在运行过程中由于软件或者硬件错误&lt;strong>导致链表中的指针丢失或损坏，会导致文件数据的丢失。&lt;/strong>&lt;/p>
&lt;p>如果取出每个磁盘块的指针，把它放在内存的一个表中，就可以解决上述隐式链表的两个不足。那么，这种实现方式是「&lt;strong>显式链接&lt;/strong>」，它指&lt;strong>把用于链接文件各数据块的指针，显式地存放在内存的一张链接表中&lt;/strong>，该表在整个磁盘仅设置一张，&lt;strong>每个表项中存放链接指针，指向下一个数据块号&lt;/strong>。&lt;/p>
&lt;p>对于显式链接的工作方式，我们举个例子，文件 A 依次使用了磁盘块 4、7、2、10 和 12 ，文件 B 依次使用了磁盘块 6、3、11 和 14 。利用下图中的表，可以从第 4 块开始，顺着链走到最后，找到文件 A 的全部磁盘块。同样，从第 6 块开始，顺着链走到最后，也能够找出文件 B 的全部磁盘块。最后，这两个链都以一个不属于有效磁盘编号的特殊标记（如 -1 ）结束。内存中的这样一个表格称为&lt;strong>文件分配表（File Allocation Table，FAT）&lt;/strong>。&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/op2fw9/1616167677063-b7bb2a32-dde6-4c17-9119-096413902ae8.png" alt="">&lt;/p>
&lt;p>由于查找记录的过程是在内存中进行的，因而不仅显著地&lt;strong>提高了检索速度&lt;/strong>，而且&lt;strong>大大减少了访问磁盘的次数&lt;/strong>。但也正是整个表都存放在内存中的关系，它的主要的缺点是**不适用于大磁盘**。&lt;/p>
&lt;p>比如，对于 200GB 的磁盘和 1KB 大小的块，这张表需要有 2 亿项，每一项对应于这 2 亿个磁盘块中的一个块，每项如果需要 4 个字节，那这张表要占用 800MB 内存，很显然 FAT 方案对于大磁盘而言不太合适。&lt;/p>
&lt;blockquote>
&lt;p>接下来，我们来看看索引的方式。&lt;/p>
&lt;/blockquote>
&lt;p>链表的方式解决了连续分配的磁盘碎片和文件动态扩展的问题，但是不能有效支持直接访问（FAT 除外），索引的方式可以解决这个问题。
索引的实现是为每个文件创建一个「&lt;strong>索引数据块&lt;/strong>」，里面存放的是&lt;strong>指向文件数据块的指针列表&lt;/strong>，说白了就像书的目录一样，要找哪个章节的内容，看目录查就可以。&lt;/p>
&lt;p>另外，&lt;strong>文件头需要包含指向「索引数据块」的指针&lt;/strong>，这样就可以通过文件头知道索引数据块的位置，再通过索引数据块里的索引信息找到对应的数据块。
创建文件时，索引块的所有指针都设为空。当首次写入第 i 块时，先从空闲空间中取得一个块，再将其地址写到索引块的第 i 个条目。&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/op2fw9/1616167677054-825db739-3c6c-4fec-bb21-1dd52effb539.png" alt="">&lt;/p>
&lt;p>索引的方式优点在于：&lt;/p>
&lt;ul>
&lt;li>文件的创建、增大、缩小很方便；&lt;/li>
&lt;li>不会有碎片的问题；&lt;/li>
&lt;li>支持顺序读写和随机读写；&lt;/li>
&lt;/ul>
&lt;p>由于索引数据也是存放在磁盘块的，如果文件很小，明明只需一块就可以存放的下，但还是需要额外分配一块来存放索引数据，所以缺陷之一就是存储索引带来的开销。&lt;/p>
&lt;p>如果文件很大，大到一个索引数据块放不下索引信息，这时又要如何处理大文件的存放呢？我们可以通过组合的方式，来处理大文件的存。&lt;/p>
&lt;p>先来看看链表 + 索引的组合，这种组合称为「&lt;strong>链式索引块&lt;/strong>」，它的实现方式是&lt;strong>在索引数据块留出一个存放下一个索引数据块的指针&lt;/strong>，于是当一个索引数据块的索引信息用完了，就可以通过指针的方式，找到下一个索引数据块的信息。那这种方式也会出现前面提到的链表方式的问题，万一某个指针损坏了，后面的数据也就会无法读取了。&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/op2fw9/1616167677072-417dcaa4-348d-4a45-b9b0-aa170d0f3bd7.png" alt="">&lt;/p>
&lt;p>还有另外一种组合方式是索引 + 索引的方式，这种组合称为「&lt;strong>多级索引块&lt;/strong>」，实现方式是&lt;strong>通过一个索引块来存放多个索引数据块&lt;/strong>，一层套一层索引，像极了俄罗斯套娃是吧。&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/op2fw9/1616167677056-ecb3b996-c14c-455d-82aa-7ca16aeb7feb.png" alt="">&lt;/p>
&lt;h2 id="unix-文件的实现方式">Unix 文件的实现方式&lt;/h2>
&lt;p>我们先把前面提到的文件实现方式，做个比较：&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/op2fw9/1671074085764-374b9218-86e8-412d-85c7-9d051b9340b2.png" alt="image.png">&lt;/p>
&lt;p>那早期 Unix 文件系统是组合了前面的文件存放方式的优点，如下图：&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/op2fw9/1616167677095-e05fe455-c302-43bb-a9d8-dd43cd4551e1.png" alt="">&lt;/p>
&lt;p>它是根据文件的大小，存放的方式会有所变化：&lt;/p>
&lt;ul>
&lt;li>如果存放文件所需的数据块小于 10 块，则采用直接查找的方式；&lt;/li>
&lt;li>如果存放文件所需的数据块超过 10 块，则采用一级间接索引方式；&lt;/li>
&lt;li>如果前面两种方式都不够存放大文件，则采用二级间接索引方式；&lt;/li>
&lt;li>如果二级间接索引也不够存放大文件，这采用三级间接索引方式；&lt;/li>
&lt;/ul>
&lt;p>那么，文件头（&lt;em>Inode&lt;/em>）就需要包含 13 个指针：&lt;/p>
&lt;ul>
&lt;li>第 10 个指向数据块的指针；&lt;/li>
&lt;li>第 11 个指向索引块的指针；&lt;/li>
&lt;li>第 12 个指向二级索引块的指针；&lt;/li>
&lt;li>第 13 个指向三级索引块的指针；&lt;/li>
&lt;/ul>
&lt;p>所以，这种方式能很灵活地支持小文件和大文件的存放：&lt;/p>
&lt;ul>
&lt;li>对于小文件使用直接查找的方式可减少索引数据块的开销；&lt;/li>
&lt;li>对于大文件则以多级索引的方式来支持，所以大文件在访问数据块时需要大量查询；&lt;/li>
&lt;/ul>
&lt;p>这个方案就用在了 Linux Ext 2/3 文件系统里，虽然解决大文件的存储，但是对于大文件的访问，需要大量的查询，效率比较低。&lt;/p>
&lt;p>为了解决这个问题，Ext 4 做了一定的改变，具体怎么解决的，本文就不展开了。&lt;/p>
&lt;h1 id="空闲空间管理">空闲空间管理&lt;/h1>
&lt;p>前面说到的文件的存储是针对已经被占用的数据块组织和管理，接下来的问题是，如果我要保存一个数据块，我应该放在硬盘上的哪个位置呢？难道需要将所有的块扫描一遍，找个空的地方随便放吗？&lt;/p>
&lt;p>那这种方式效率就太低了，所以针对磁盘的空闲空间也是要引入管理的机制，接下来介绍几种常见的方法：&lt;/p>
&lt;ul>
&lt;li>空闲表法&lt;/li>
&lt;li>空闲链表法&lt;/li>
&lt;li>位图法&lt;/li>
&lt;/ul>
&lt;h2 id="空闲表法">空闲表法&lt;/h2>
&lt;p>空闲表法就是为所有空闲空间建立一张表，表内容包括空闲区的第一个块号和该空闲区的块个数，注意，这个方式是连续分配的。如下图：
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/op2fw9/1616167677079-9e2989d6-2cda-4460-80ca-f3c0f28783f1.png" alt="">
当请求分配磁盘空间时，系统依次扫描空闲表里的内容，直到找到一个合适的空闲区域为止。当用户撤销一个文件时，系统回收文件空间。这时，也需顺序扫描空闲表，寻找一个空闲表条目并将释放空间的第一个物理块号及它占用的块数填到这个条目中。
这种方法仅当有少量的空闲区时才有较好的效果。因为，如果存储空间中有着大量的小的空闲区，则空闲表变得很大，这样查询效率会很低。另外，这种分配技术适用于建立连续文件。&lt;/p>
&lt;h2 id="空闲链表法">空闲链表法&lt;/h2>
&lt;p>我们也可以使用「链表」的方式来管理空闲空间，每一个空闲块里有一个指针指向下一个空闲块，这样也能很方便的找到空闲块并管理起来。如下图：
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/op2fw9/1616167677070-be98384a-ad4f-4a20-b5da-1d969816b938.png" alt="">
当创建文件需要一块或几块时，就从链头上依次取下一块或几块。反之，当回收空间时，把这些空闲块依次接到链头上。&lt;/p>
&lt;p>这种技术只要在主存中保存一个指针，令它指向第一个空闲块。其特点是简单，但不能随机访问，工作效率低，因为每当在链上增加或移动空闲块时需要做很多 I/O 操作，同时数据块的指针消耗了一定的存储空间。&lt;/p>
&lt;p>空闲表法和空闲链表法都不适合用于大型文件系统，因为这会使空闲表或空闲链表太大。&lt;/p>
&lt;h2 id="位图法">位图法&lt;/h2>
&lt;p>位图是利用二进制的一位来表示磁盘中一个盘块的使用情况，磁盘上所有的盘块都有一个二进制位与之对应。&lt;/p>
&lt;p>当值为 0 时，表示对应的盘块空闲，值为 1 时，表示对应的盘块已分配。它形式如下：&lt;/p>
&lt;pre>&lt;code>1111110011111110001110110111111100111 ...
&lt;/code>&lt;/pre>
&lt;p>在 Linux 文件系统就采用了位图的方式来管理空闲空间，不仅用于数据空闲块的管理，还用于 inode 空闲块的管理，因为 inode 也是存储在磁盘的，自然也要有对其管理。&lt;/p>
&lt;h1 id="文件系统的结构">文件系统的结构&lt;/h1>
&lt;p>前面提到 Linux 是用位图的方式管理空闲空间，用户在创建一个新文件时，Linux 内核会通过 inode 的位图找到空闲可用的 inode，并进行分配。要存储数据时，会通过块的位图找到空闲的块，并分配，但仔细计算一下还是有问题的。&lt;/p>
&lt;p>数据块的位图是放在磁盘块里的，假设是放在一个块里，一个块 4K，每位表示一个数据块，共可以表示 &lt;code>4 * 1024 * 8 = 2^15&lt;/code> 个空闲块，由于 1 个数据块是 4K 大小，那么最大可以表示的空间为 &lt;code>2^15 * 4 * 1024 = 2^27&lt;/code> 个 byte，也就是 128M。&lt;/p>
&lt;p>也就是说按照上面的结构，如果采用「一个块的位图 + 一系列的块」，外加「一个块的 inode 的位图 + 一系列的 inode 的结构」能表示的最大空间也就 128M，这太少了，现在很多文件都比这个大。&lt;/p>
&lt;p>在 Linux 文件系统，把这个结构称为一个&lt;strong>块组&lt;/strong>，那么有 N 多的块组，就能够表示 N 大的文件。&lt;/p>
&lt;p>下图给出了 Linux Ext2 整个文件系统的结构和块组的内容，文件系统都由大量块组组成，在硬盘上相继排布：&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/op2fw9/1616167677099-7ffa20c4-57d9-4c49-9e02-24afef066cfb.png" alt="">&lt;/p>
&lt;p>最前面的第一个块是引导块，在系统启动时用于启用引导，接着后面就是一个一个连续的块组了，块组的内容如下：&lt;/p>
&lt;ul>
&lt;li>&lt;strong>超级块&lt;/strong> # 包含的是文件系统的重要信息，比如 inode 总个数、块总个数、每个块组的 inode 个数、每个块组的块个数等等。&lt;/li>
&lt;li>&lt;strong>块组描述符&lt;/strong> # 包含文件系统中各个块组的状态，比如块组中空闲块和 inode 的数目等，每个块组都包含了文件系统中「所有块组的组描述符信息」。&lt;/li>
&lt;li>&lt;strong>数据位图和 inode 位图&lt;/strong> # 用于表示对应的数据块或 inode 是空闲的，还是被使用中。&lt;/li>
&lt;li>&lt;strong>inode 列表&lt;/strong> # 包含了块组中所有的 inode，inode 用于保存文件系统中与各个文件和目录相关的所有元数据。&lt;/li>
&lt;li>&lt;strong>数据块&lt;/strong> # 包含文件的有用数据。&lt;/li>
&lt;/ul>
&lt;p>你可以会发现每个块组里有很多重复的信息，比如&lt;strong>超级块和块组描述符表，这两个都是全局信息，而且非常的重要&lt;/strong>，这么做是有两个原因：&lt;/p>
&lt;ul>
&lt;li>如果系统崩溃破坏了超级块或块组描述符，有关文件系统结构和内容的所有信息都会丢失。如果有冗余的副本，该信息是可能恢复的。&lt;/li>
&lt;li>通过使文件和管理数据尽可能接近，减少了磁头寻道和旋转，这可以提高文件系统的性能。&lt;/li>
&lt;/ul>
&lt;p>不过，Ext2 的后续版本采用了&lt;strong>稀疏技术&lt;/strong>。该做法是，超级块和块组描述符表不再存储到文件系统的每个块组中，而是只写入到块组 0、块组 1 和其他 ID 可以表示为 3、 5、7 的幂的块组中。&lt;/p>
&lt;p>在创建文件系统时，也可以看到 &lt;code>Superblock backups stored on blocks&lt;/code> 这种描述，这记录了超级块的备份存在哪些块中&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>~&lt;span style="color:#f92672">]&lt;/span>&lt;span style="color:#75715e"># mke2fs -N 10000000 /dev/vdb&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>mke2fs 1.45.5 &lt;span style="color:#f92672">(&lt;/span>07-Jan-2020&lt;span style="color:#f92672">)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>/dev/vdb contains a ext2 file system
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> created on Sat Mar &lt;span style="color:#ae81ff">11&lt;/span> 12:25:22 &lt;span style="color:#ae81ff">2023&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Proceed anyway? &lt;span style="color:#f92672">(&lt;/span>y,N&lt;span style="color:#f92672">)&lt;/span> y
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Creating filesystem with &lt;span style="color:#ae81ff">9175040&lt;/span> 4k blocks and &lt;span style="color:#ae81ff">10002528&lt;/span> inodes
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Filesystem UUID: 8acc177c-5f26-4bb9-a0ee-01ceb61d4eaa
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Superblock backups stored on blocks:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> 30072, 90216, 150360, 210504, 270648, 751800, 811944, 1473528, 2435832,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> 3759000, &lt;span style="color:#ae81ff">7307496&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Allocating group tables: &lt;span style="color:#66d9ef">done&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Writing inode tables: &lt;span style="color:#66d9ef">done&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Writing superblocks and filesystem accounting information: &lt;span style="color:#66d9ef">done&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div></description></item><item><title>Docs: File System 管理</title><link>https://desistdaydream.github.io/docs/IT%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Y.Windows-%E7%AE%A1%E7%90%86/File_System_%E7%AE%A1%E7%90%86/File_System_%E7%AE%A1%E7%90%86/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/IT%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Y.Windows-%E7%AE%A1%E7%90%86/File_System_%E7%AE%A1%E7%90%86/File_System_%E7%AE%A1%E7%90%86/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://www.howtogeek.com/318177/what-is-the-appdata-folder-in-windows/">https://www.howtogeek.com/318177/what-is-the-appdata-folder-in-windows/&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>&lt;strong>%USERPROFILE%/AppData/*&lt;/strong> #&lt;/p>
&lt;ul>
&lt;li>&lt;strong>./Local/*&lt;/strong> #&lt;/li>
&lt;li>&lt;strong>./LocalLow/*&lt;/strong> #&lt;/li>
&lt;li>&lt;strong>./Roaming/*&lt;/strong> #&lt;/li>
&lt;/ul>
&lt;p>刚装完的 win10 专业版，用户的 AppData 中将会有如下结构：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-powershell" data-lang="powershell">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">%&lt;/span>USERPROFILE%\appdata\Local
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">%&lt;/span>USERPROFILE%\appdata\LocalLow
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">%&lt;/span>USERPROFILE%\appdata\Roaming
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">%&lt;/span>USERPROFILE%\appdata\Local\Comms
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">%&lt;/span>USERPROFILE%\appdata\Local\ConnectedDevicesPlatform
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">%&lt;/span>USERPROFILE%\appdata\Local\D3DSCache
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">%&lt;/span>USERPROFILE%\appdata\Local\Microsoft
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">%&lt;/span>USERPROFILE%\appdata\Local\Packages
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">%&lt;/span>USERPROFILE%\appdata\Local\Temp
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">%&lt;/span>USERPROFILE%\appdata\LocalLow\Microsoft
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">%&lt;/span>USERPROFILE%\appdata\LocalLow\MSLiveStickerWhiteList
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">%&lt;/span>USERPROFILE%\appdata\Roaming\Adobe
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">%&lt;/span>USERPROFILE%\appdata\Roaming\Microsoft
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>最主要的是这三个目录下的 Microsfot 目录，还有 Packages 目录。在整理 AppData 时，不要误删了。&lt;/p>
&lt;h1 id="program-files">Program Files&lt;/h1>
&lt;p>该目录存储安装在计算机上的大多数应用程序的执行文件。&lt;/p>
&lt;h1 id="program-filesx86">Program Files(x86)&lt;/h1>
&lt;p>该目录存储在 64 位 Windows 系统上安装的 32 位应用程序的执行文件。&lt;/p>
&lt;h1 id="programdata">ProgramData&lt;/h1>
&lt;p>该目录存储全局数据，包括应用程序的配置文件，以及系统的安装和更新信息。&lt;/p>
&lt;h1 id="users">Users&lt;/h1>
&lt;p>该目录存储在 Windows 系统上创建的每个用户的个人文件夹，如桌面、文档和图片。&lt;/p>
&lt;h1 id="windows">Windows&lt;/h1>
&lt;p>Windows 操作系统的核心文件和 DLL 文件都存储在此目录中。&lt;/p>
&lt;p>&lt;strong>./System32/&lt;/strong> # 类似于 Linux 中的 /usr/sbin/ 目录，系统自带的命令、服务、msc 的可执行文件都在这里。&lt;/p></description></item><item><title>Docs: Function(函数)</title><link>https://desistdaydream.github.io/docs/IT%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/2.%E7%BC%96%E7%A8%8B/%E8%A7%A3%E8%B0%9C%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/Function%E5%87%BD%E6%95%B0/Function%E5%87%BD%E6%95%B0/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/IT%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/2.%E7%BC%96%E7%A8%8B/%E8%A7%A3%E8%B0%9C%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/Function%E5%87%BD%E6%95%B0/Function%E5%87%BD%E6%95%B0/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Subroutine">Wiki,Subroutine(子程序)&lt;/a>
&lt;ul>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Function_(computer_science)">Wiki,Function&lt;/a> 概念被合并到 Subroutine 中&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Parameter_(computer_programming)">Wiki,Parameter(参数)&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Evaluation_strategy">Wiki,Evaluation strategy(评估策略)&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://mp.weixin.qq.com/s/33__rGbvEHUB7nXWPSvz8Q">公众号，码农的荒岛求生-函数调用时底层发生了什么？&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>在计算机编程中，&lt;strong>Subroutine(子程序)&lt;/strong> 是执行特定任务的程序指令序列，打包为一个单元。然后，该单元可用于应执行特定任务的程序中。&lt;/p>
&lt;p>子程序可以在程序中定义，也可以在可以被许多程序使用的库中单独定义。在不同的编程语言中，子例程可以称为 &lt;strong>Routine(例程)&lt;/strong>、&lt;strong>Subprogram(子程序)&lt;/strong>、&lt;strong>Function(函数)&lt;/strong>、&lt;strong>Method(方法)&lt;/strong> 或 &lt;strong>Procedure(过程)&lt;/strong>。从技术上讲，这些术语都有不同的定义。有时会使用通用的总称 &lt;strong>Callable Unit(可调用单元)&lt;/strong>。&lt;/p>
&lt;h1 id="function-call函数调用">Function call(函数调用)&lt;/h1>
&lt;h2 id="parameter参数">Parameter(参数)&lt;/h2>
&lt;p>在计算机编程中，&lt;strong>Parameter(参数)&lt;/strong> 是函数中使用的一种&lt;strong>特殊变量&lt;/strong>，用于在引用函数时，提供给函数的输入数据。&lt;/p>
&lt;ul>
&lt;li>&lt;strong>actual parameter(实际参数，简称 实参)&lt;/strong> # 一般用 arguments 表示，在调用函数时使用实参&lt;/li>
&lt;li>&lt;strong>formal parameter(形式参数，简称 形参)&lt;/strong> # 一般用 parameter 表示，在定义函数时使用形参&lt;/li>
&lt;/ul>
&lt;p>如何将 Arguments 的值传递给子程序的 Parameters 是由编程语言的 &lt;strong>Evaluation strategy(评估策略)&lt;/strong> 决定的。每次调用子程序时，都会评估本次调用的 Arguments，并将评估结果分配给相应的 Parameters。这种分配机制，称为 &lt;strong>Argument passing(参数传递)&lt;/strong>。&lt;/p>
&lt;p>例如：
现在定义一个名为 &lt;code>add&lt;/code> 的子程序：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-c" data-lang="c">&lt;span style="display:flex;">&lt;span>def &lt;span style="color:#a6e22e">add&lt;/span>(x, y){
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> x &lt;span style="color:#f92672">+&lt;/span> y
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>这里的 x 和 y 是 &lt;strong>形式参数&lt;/strong>&lt;/p>
&lt;p>如果要引用这个子程序：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-c" data-lang="c">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">add&lt;/span>(&lt;span style="color:#ae81ff">2&lt;/span>, &lt;span style="color:#ae81ff">3&lt;/span>)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>这里的 2 和 3 是&lt;strong>实际参数&lt;/strong>。&lt;/p>
&lt;p>所以，就跟参数的名字一样，形式参数就是形式上的，没有一个具体的数据，而实际参数之所以称为实际，就是因为这些参数有具体的数据。&lt;/p>
&lt;blockquote>
&lt;p>注意：根据评估策略的不同，所谓的实际参数和形式参数也是相对来说的，比如在很多时候，我们传递的实际参数还可以是 另一个 Function、Pointer(指针) 等等类型的数据。&lt;/p>
&lt;/blockquote>
&lt;h2 id="evaluation-strategy评估策略">Evaluation strategy(评估策略)&lt;/h2>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>Convention&lt;/th>
&lt;th>Description&lt;/th>
&lt;th>Common use&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;/table>
&lt;p>| Call by value(值调用)
值传递 | 将参数的值的副本传递给子程序。
(子程序内修改它们不会影响原始参数) | Default in most Algol-like languages after &lt;a href="https://en.wikipedia.org/wiki/Algol_60">Algol 60&lt;/a>
, such as Pascal, Delphi, Simula, CPL, PL/M, Modula, Oberon, Ada, and many others. C, C++, Java (References to objects and arrays are also passed by value) |
| Call by reference(引用调用)
引用传递 | 将参数的引用地址传递给子程序
(子程序内修改它们会影响原始参数) | Selectable in most Algol-like languages after &lt;a href="https://en.wikipedia.org/wiki/Algol_60">Algol 60&lt;/a>
, such as Algol 68, Pascal, Delphi, Simula, CPL, PL/M, Modula, Oberon, Ada, and many others. C++, Fortran, &lt;a href="https://en.wikipedia.org/wiki/PL/I">PL/I&lt;/a> |
| Call by result | Parameter value is copied back to argument on return from the subroutine | Ada OUT parameters |
| Call by value-result | Parameter value is copied back on entry to the subroutine and again on return | Algol, &lt;a href="https://en.wikipedia.org/wiki/Swift_(programming_language)">Swift&lt;/a>
in-out parameters |
| Call by name | Like a macro – replace the parameters with the unevaluated argument expressions | Algol, &lt;a href="https://en.wikipedia.org/wiki/Scala_(programming_language)">Scala&lt;/a> |
| Call by constant value | Like call by value except that the parameter is treated as a constant | PL/I NONASSIGNABLE parameters, Ada IN parameters |&lt;/p>
&lt;h3 id="call-by-reference通过引用调用-与-call-by-value通过值调用">Call by Reference(通过引用调用) 与 Call by Value(通过值调用)&lt;/h3>
&lt;ul>
&lt;li>通过值调用(Call by value) 意味着，在函数体内修改参数值，不会影响到函数外部。&lt;/li>
&lt;li>通过引用调用(Call by reference) 意味着，传入函数的原始值的地址，因此在函数内部修改参数，将会影响到原始值。&lt;/li>
&lt;/ul>
&lt;h1 id="函数调用时底层逻辑">函数调用时底层逻辑&lt;/h1>
&lt;p>有读者问题函数调用是如何实现的，今天就来聊聊这个比较简单的问题。&lt;/p>
&lt;p>大家都应该打包过东西吧，搬家之类的，通常都是找几个箱子一股脑装进去，为了不让箱子占地方，你通常会把它们摞好，就像这样：&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/qu324i/1648437687225-6414f1c8-2f44-4c24-978d-8a4cc6a65ba5.jpeg" alt="">&lt;/p>
&lt;p>注意看上面的箱子，最先被打包好的箱子被摞在最下方，刚打包好的箱子总是放在最上方，这就形成了一种 first in last out 的结构，也就是我们所说的栈，stack，上面的这些箱子就形成了栈。&lt;/p>
&lt;p>如果你懂得用箱子打包东西，你就能明白函数调用是怎么一回事。&lt;/p>
&lt;p>原来，在程序运行时每个被调用的函数都有自己的一个箱子，假设这段代码是这样写的：&lt;/p>
&lt;p>void D() {}
void C() {
  D();
}
void B() {
    C();
}
void A() {
  B();
}&lt;/p>
&lt;p>函数 A 调用函数 B、B 调用 C、C 调用 D，那么当函数 D 在运行时内存中就会有四个箱子，每个函数一个：&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/qu324i/1648437687180-74941560-51a7-421b-8cc8-793c48703b11.png" alt="">&lt;/p>
&lt;p>每个函数占据的这个箱子——也就是这块内存，就被称为栈帧，stack frame，只不过由于引力的作用，我们摞箱子时是从下往上增长，而出于内存布局的需要，函数调用时的栈是从高地址向低地址增长。&lt;/p>
&lt;p>这些箱子中都装有什么呢？你在函数中定义的局部变量就装在这里，关于栈帧内容更详细的讲解你可以参考这里《&lt;a href="http://mp.weixin.qq.com/s?__biz=Mzg4OTYzODM4Mw==&amp;amp;mid=2247485714&amp;amp;idx=1&amp;amp;sn=1a315fe4da87fde2758fc9dd5366ba01&amp;amp;chksm=cfe99592f89e1c84b87ebfbfbbbd9868ddf3e945666168122f57aa793e87787528b513e46e5d&amp;amp;scene=21#wechat_redirect">函数调用是在内存中是什么样子&lt;/a>》，这些不是本文的重点，这里更关心的是这些栈帧是怎样增长以及减少的。&lt;/p>
&lt;p>仔细观察上面这张图，每个箱子最重要的信息有两个，&lt;strong>你至少需要知道箱子的底部以及箱子的顶部在哪里&lt;/strong>！&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/qu324i/1648437687271-bdc684c3-a08f-4654-be59-0bd20b8a9630.png" alt="">&lt;/p>
&lt;p>在计算机中，每个函数栈帧的“底部”和“顶部”的信息——也就是内存地址，分别存放在两个寄存器中：BasePointer(BP)寄存器以及 StackPointer(SP)寄存器，即我们熟悉的 rbp 以及 rsp，32 位下为 ebp 以及 esp，注意本文以 x86_64 为例。&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/qu324i/1648437687166-7105bbca-8df4-4044-894f-11e5b13fa005.png" alt="">&lt;/p>
&lt;p>只要确定了 rbp 和 rsp 你就能得到一块栈区，在这块栈区上就可以进行函数调用：&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/qu324i/1648437687303-279472cc-ed4a-4525-b4f5-6994ef566265.png" alt="">&lt;/p>
&lt;p>读到这里肯定有的同学可能会问，CPU 中的寄存器不是有限的吗？从这里的讲解看每个栈帧都需要维护一个“栈顶”与“栈底”的信息，每个核心中的 rbp 以及 rsp 寄存器就一个，我们该怎样确保函数运行时相应栈帧使用的 rbp 以及 rsp 是正确的呢？&lt;/p>
&lt;p>方法非常简单，调用函数时会创建新的栈帧，此时需要将原有 rbp 寄存器中的值保存在新的栈帧上，就像这样：&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/qu324i/1648437687582-ed1046b1-c111-4c30-bf2e-310c2bc3c6ac.png" alt="">&lt;/p>
&lt;p>上图就是函数调用时第一件要完成的事情，把 rbp 的值 push 到栈上，rsp 下移，然后呢？然后也很简单，只需要把 rsp 指向的地址也赋值给 rbp 即可，这样就开启了一个新的栈帧：&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/qu324i/1648437687685-0e112e19-781f-48d1-8afb-fe172ce5f2a8.png" alt="">&lt;/p>
&lt;p>完成上述操作的有两条机器指令(gcc 编译器)：&lt;/p>
&lt;p>push   %rbp
mov    %rsp,%rbp&lt;/p>
&lt;p>如果你去看编译器为每个函数生成的机器指令，那么开头几乎都是这两条指令，现在你应该明白这两条指令的作用了吧。&lt;/p>
&lt;p>这两条指令就把上一个栈帧的 rbp 的保存到了新的栈帧，由于此时 rsp 已经指向了新的栈帧栈顶，由于此时栈为空，因此栈顶和栈底的地址是一样的，可以直接把 rsp 赋给 rbp，这样一个全新的栈帧就创建出来了。&lt;/p>
&lt;p>如果我们在被调函数内部创建一些局部变量：&lt;/p>
&lt;p>void funcB() {
    int a = 1;
    int b = 2;
    int c = 3;
    &amp;hellip;
}&lt;/p>
&lt;p>那么此时栈会进一步扩大，并把局部变量存放在该函数的栈帧中：&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/qu324i/1648437687701-456ca282-1ecb-420c-b487-4702fbb25770.png" alt="">&lt;/p>
&lt;p>现在我们的栈可以随着函数调用而增长，可以看到，栈帧和你搬家时用的纸箱子还是不太一样的，函数栈帧不会一开始就大小固定好，而是随着指令的执行动态增加，也就是如果你往栈上 push 一些数据，栈帧就会相应的增大一点。&lt;/p>
&lt;p>那么函数调用完成时该怎么办呢？这也非常简单，只需要一条机器指令：&lt;/p>
&lt;p>leave&lt;/p>
&lt;p>我们在上一篇《&lt;a href="http://mp.weixin.qq.com/s?__biz=Mzg4OTYzODM4Mw==&amp;amp;mid=2247486951&amp;amp;idx=1&amp;amp;sn=9ed9294b2248b3287e60d38ac0b7fca4&amp;amp;chksm=cfe99167f89e1871915861369c3f39bf1850754e974da1f9f7367fdb37c64d22fc3425a65c9e&amp;amp;scene=21#wechat_redirect">栈区分配内存快还是堆区分配内存快&lt;/a>》中讲解了一部分，leave 指令的作用是将栈基址赋值给 rsp，这样栈指针指向上一个栈帧的栈顶，然后 pop 出 rbp，这样 rbp 就指向上一个栈帧的栈底：&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/qu324i/1648437687723-01062541-9dd2-493f-aaaa-3fe4811c3212.png" alt="">&lt;/p>
&lt;p>看到了吧，执行完 leave 指令后 rbp 以及 rsp 就指向了上一个栈帧，这就相当于栈帧的弹出，这样 stack 1 占用的内存就无效了，没有任何用处了，显然这就是我们常说的内存回收，因此简单的一条 leave 指令即可把栈区中的内存回收掉。&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/qu324i/1648437687846-701d7bbb-5cb3-429c-a9b2-72441062dea5.png" alt="">&lt;/p>
&lt;p>而在 x86 平台，leave 指令后往往跟上一条 ret 指令：&lt;/p>
&lt;p>leave
ret&lt;/p>
&lt;p>我们已经了解了 leave 指令的作用，这条指令让 rbp 以及 rsp 指向上一个栈帧，然后呢？显然 CPU 应该从 funcA 调用函数 funcB 之后的一行代码处继续运行，那么这行代码的地址在哪里呢？显然就在 funcA 栈帧的栈顶：&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/qu324i/1648437688059-b40c97fe-0a35-4cee-8590-f072fad8be69.png" alt="">&lt;/p>
&lt;p>当 CPU 执行 call 指令时会把该函数的返回地址 push 到栈中，而 ret 指令的作用正是将栈顶弹出(pop)到 rip 寄存器，rip 寄存器告诉 CPU 接下来该从哪里执行机器指令，这个返回地址是 funcA 调用 funcB 时 push 到栈上的，这样当从函数 funcB()返回后我们就知道该从哪里继续执行机器指令了，这就是 ret 指令的作用，当然这里也是函数调用实现的基本原理。&lt;/p>
&lt;p>关于栈帧更详细的讲解可以参考我写的这篇《&lt;a href="http://mp.weixin.qq.com/s?__biz=Mzg4OTYzODM4Mw==&amp;amp;mid=2247485714&amp;amp;idx=1&amp;amp;sn=1a315fe4da87fde2758fc9dd5366ba01&amp;amp;chksm=cfe99592f89e1c84b87ebfbfbbbd9868ddf3e945666168122f57aa793e87787528b513e46e5d&amp;amp;scene=21#wechat_redirect">函数调用在内存中是什么样子&lt;/a>》。&lt;/p></description></item><item><title>Docs: Go 环境安装与使用</title><link>https://desistdaydream.github.io/docs/IT%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/2.%E7%BC%96%E7%A8%8B/%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Go/Go-%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8/Go-%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/IT%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/2.%E7%BC%96%E7%A8%8B/%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Go/Go-%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8/Go-%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://golang.org/doc/install">官方文档，下载并安装 Go&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://golang.org/doc/manage-install">官方文档，安装多个版本的 Go&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://pkg.go.dev/cmd/go">Go 包，标准库-cmd-go&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://github.com/goproxy/goproxy.cn/issues/61">GitHub 项目-goproxy-goproxy.io 与 goproxy.cn 说明&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>我们可以通过一个名为 go 的二进制文件实现绝大部分日常的 编码、编译 等工作，只要安装好 Go 的环境即可。&lt;/p>
&lt;h1 id="安装-go">安装 Go&lt;/h1>
&lt;h2 id="linux-安装">Linux 安装&lt;/h2>
&lt;p>从&lt;a href="https://golang.org/dl/">官网&lt;/a>下载 linux 版的 &lt;code>.tar.gz&lt;/code> 包&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>export GoVersion&lt;span style="color:#f92672">=&lt;/span>1.18.5
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>wget https://go.dev/dl/go&lt;span style="color:#e6db74">${&lt;/span>GoVersion&lt;span style="color:#e6db74">}&lt;/span>.linux-amd64.tar.gz
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>tar -C /usr/local -xvzf go&lt;span style="color:#e6db74">${&lt;/span>GoVersion&lt;span style="color:#e6db74">}&lt;/span>.linux-amd64.tar.gz
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>配置环境变量，以便让 shell 可以执行 go 命令并立刻生效&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>sudo tee /etc/profile.d/go.sh &amp;gt; /dev/null &amp;lt;&amp;lt;-&lt;span style="color:#e6db74">&amp;#34;EOF&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># export GOPATH=/opt/gopath&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># export PATH=$PATH:\$GOPATH/bin:/usr/local/go/bin&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>export PATH&lt;span style="color:#f92672">=&lt;/span>$PATH:/usr/local/go/bin
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>export GO111MODULE&lt;span style="color:#f92672">=&lt;/span>on
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>export GOPROXY&lt;span style="color:#f92672">=&lt;/span>https://goproxy.cn,https://goproxy.io,https://mirrors.aliyun.com/goproxy/,direct
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>export CGO_ENABLED&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">0&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>EOF
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>source /etc/profile.d/go.sh
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;blockquote>
&lt;p>CGO_ENABLED 开启后 Go 代码最终编译的可执行文件都是要有外部依赖的。不过我们依然可以通过 disable CGO_ENABLED 来编译出纯静态的 Go 程序，常用于交叉编译
CGO_ENABLED 关闭即可编译出纯静态的 Go 程序，可以用于 alpine 镜像中。&lt;/p>
&lt;/blockquote>
&lt;h2 id="windows-安装">Windows 安装&lt;/h2>
&lt;p>从&lt;a href="https://golang.org/dl/">官网&lt;/a>下载 Windows 版的 msi 安装包&lt;/p>
&lt;p>双击安装 Golang&lt;/p>
&lt;p>配置环境变量，执行命令&lt;/p>
&lt;ul>
&lt;li>go env -w GOPATH=D:\Tools\GoPath&lt;/li>
&lt;li>go env -w GOPROXY=https://goproxy.cn,https://goproxy.io,direct&lt;/li>
&lt;li>go env -w GO111MODULE=on&lt;/li>
&lt;/ul>
&lt;h2 id="安装多个版本的-go">安装多个版本的 Go&lt;/h2>
&lt;p>获取其余版本的 golang&lt;/p>
&lt;ul>
&lt;li>go install golang.org/dl/goX.XX.X@latest&lt;/li>
&lt;li>goX.XX.X download&lt;/li>
&lt;/ul>
&lt;p>新下载的 golang 版本可以像这样使用，在 go 后面加上版本号&lt;/p>
&lt;ul>
&lt;li>goX.XX.X version&lt;/li>
&lt;/ul>
&lt;p>通过 goX.XX.X env 命令查看该 go 版本的变量，可以看到，默认的 GOROOT 是在 ~/sdk/goX.XX.X 目录下的&lt;/p>
&lt;p>所以如果想要切换默认的 go 版本(比如某个程序调用 go 命令时)，只需要将环境变量 GOROOT 指向该目录即可，之后使用 go 命令即可为当前指定的版本&lt;/p>
&lt;h1 id="初始化项目">初始化项目&lt;/h1>
&lt;p>Go 的项目通常由 &lt;a href="https://www.typescriptlang.org/">Go Module&lt;/a> 管理，项目目录中通常必须包含如下几个文件：&lt;/p>
&lt;ul>
&lt;li>go.mod&lt;/li>
&lt;li>go.sum&lt;/li>
&lt;/ul>
&lt;p>go 相关工具通过 &lt;code>go.mod&lt;/code> 与 &lt;code>go.sum&lt;/code> 两个文件管理项目及其依赖&lt;/p>
&lt;p>使用 &lt;code>go mod init &amp;lt;NAME&amp;gt;&lt;/code> 命令在当前目录会创建一个 go.mod 文件。有任何新的 import，都可以通过 &lt;code>go mod tidy&lt;/code> 生成依赖文件再生成 &lt;code>go.sum&lt;/code> 文件。&lt;/p>
&lt;h1 id="编译-go">编译 Go&lt;/h1>
&lt;p>若想在 Windows 中编译依赖 gcc 的项目，则需要安装 gcc 编译器（i.e.&lt;a href="https://sourceforge.net/projects/mingw-w64/">MinGW-w64&lt;/a>）在 file 标签中，下载 &lt;a href="https://sourceforge.net/projects/mingw-w64/files/Toolchains%20targetting%20Win64/Personal%20Builds/mingw-builds/8.1.0/threads-win32/seh/x86_64-8.1.0-release-win32-seh-rt_v6-rev0.7z">x86_64-win32-seh&lt;/a> 这个版本并安装即可。这是一个 tar 包，解压完成后，需要在 Windows 的 ${PATH} 环境变量中，添加解压出来的 bin 目录，通常都在 &lt;code>PATH\TO\x86_64-8.1.0-release-win32-seh-rt_v6-rev0\mingw64\bin&lt;/code> 这里&lt;/p>
&lt;h2 id="交叉编译">交叉编译&lt;/h2>
&lt;p>Linux 下编译出 Windows 的程序。需要安装 Windows 版的 gcc 工具（i.e.&lt;a href="https://www.mingw-w64.org/">MinGW-w64&lt;/a>）(有的环境还需要安装 gcc-multilib 包)&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>sudo apt-get install gcc-mingw-w64
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>GOOS&lt;span style="color:#f92672">=&lt;/span>windows GOARCH&lt;span style="color:#f92672">=&lt;/span>amd64 CGO_ENABLED&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span> CC&lt;span style="color:#f92672">=&lt;/span>x86_64-w64-mingw32-gcc go build
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="在容器中编译">在容器中编译&lt;/h2>
&lt;h3 id="golang-镜像">golang 镜像&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>docker run -it -v /&lt;span style="color:#e6db74">${&lt;/span>YourPackageSrc&lt;span style="color:#e6db74">}&lt;/span>:/go/work &lt;span style="color:#ae81ff">\
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">&lt;/span> -w /go/work &lt;span style="color:#ae81ff">\
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">&lt;/span> golang:1.17 go build
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>多次使用&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>docker run -it --network host --name golang &lt;span style="color:#ae81ff">\
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">&lt;/span> -v /root/projects:/root/projects &lt;span style="color:#ae81ff">\
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">&lt;/span> -v /root/go:/go &lt;span style="color:#ae81ff">\
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">&lt;/span> golang:1.17 /bin/bash
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>一次性构建&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>docker run -it -v /root/projects/&lt;span style="color:#e6db74">${&lt;/span>Project&lt;span style="color:#e6db74">}&lt;/span>:/go/work &lt;span style="color:#ae81ff">\
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">&lt;/span> -w /go/work &lt;span style="color:#ae81ff">\
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">&lt;/span> golang:1.17 go build cmd/XX.go
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="go-mingw-镜像">go-mingw 镜像&lt;/h3>
&lt;p>镜像，用于使用基于官方 Go Docker 镜像的 MinGW-w64 工具链为 Windows 构建 Go 二进制文件。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>docker run --rm -it -v /&lt;span style="color:#e6db74">${&lt;/span>YourPackageSrc&lt;span style="color:#e6db74">}&lt;/span>:/go/work &lt;span style="color:#ae81ff">\
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">&lt;/span> -w /go/work &lt;span style="color:#ae81ff">\
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">&lt;/span> -e GOPROXY&lt;span style="color:#f92672">=&lt;/span>https://goproxy.cn,https://goproxy.io,direct
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> x1unix/go-mingw go build
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h1 id="go-关联文件与配置">Go 关联文件与配置&lt;/h1>
&lt;p>Go 程序的很多关联文件都可以通过 Go 环境变量进行配置，所以绝大部分关联文件都以变量的形式记录。
&lt;strong>$GOPATH&lt;/strong> # GOPATH 环境变量列出了寻找 Go 代码的位置。&lt;strong>同时也是存储 Go 模块的目录，即 go mod 相关命令保存数据的目录&lt;/strong>。&lt;/p>
&lt;ul>
&lt;li>&lt;strong>./pkg/mod/&lt;/strong> # 存储下载的源代码。&lt;/li>
&lt;li>&lt;strong>./bin/&lt;/strong> # 存储编译的命令。下载的依赖包中若包含二进制文件，也会保存在这个目录中&lt;/li>
&lt;/ul>
&lt;h2 id="go-环境变量">Go 环境变量&lt;/h2>
&lt;p>Go 通过环境变量来配置其运行行为，通过 go env 命令可以看到当前使用的环境变量：
&lt;strong>GO111MODULE=&amp;ldquo;on|off&amp;rdquo;&lt;/strong> # 设置是否使用 go mod，该环境变量将于 1.17 版本删除，并从此开始仅支持 go mod
GOARCH=&amp;ldquo;amd64&amp;rdquo;
GOBIN=&amp;quot;&amp;quot;
GOCACHE=&amp;quot;/root/.cache/go-build&amp;quot;
GOENV=&amp;quot;/root/.config/go/env&amp;quot;
GOEXE=&amp;quot;&amp;quot;
GOFLAGS=&amp;quot;&amp;quot;
GOHOSTARCH=&amp;ldquo;amd64&amp;rdquo;
GOHOSTOS=&amp;ldquo;linux&amp;rdquo;
GOINSECURE=&amp;quot;&amp;quot;
GOMODCACHE=&amp;quot;/root/go/pkg/mod&amp;quot;
GONOPROXY=&amp;quot;&amp;quot;
GONOSUMDB=&amp;quot;&amp;quot;
GOOS=&amp;ldquo;linux&amp;rdquo;
&lt;strong>GOPATH=&lt;!-- raw HTML omitted -->&lt;/strong> # 设置 gopath 所在路径。默认值：&lt;code>~/go&lt;/code>
GOPRIVATE=&amp;quot;&amp;quot;
**GOPROXY=&lt;!-- raw HTML omitted --> **# 设置 go get、go install 命令时，所使用的代理服务器。可以加快获取第三方库的速度。
&lt;strong>GOROOT=&lt;!-- raw HTML omitted -->&lt;/strong> # Go 的安装路径。默认值：Go 的安装路径，Linux 中通常为 /usr/local/go
GOSUMDB=&amp;ldquo;sum.golang.org&amp;rdquo;
GOTMPDIR=&amp;quot;&amp;quot;
GOTOOLDIR=&amp;quot;/usr/local/go/pkg/tool/linux_amd64&amp;quot;
GOVCS=&amp;quot;&amp;quot;
GOVERSION=&amp;ldquo;go1.16.4&amp;rdquo;
GCCGO=&amp;ldquo;gccgo&amp;rdquo;
AR=&amp;ldquo;ar&amp;rdquo;
CC=&amp;ldquo;gcc&amp;rdquo;
CXX=&amp;ldquo;g++&amp;rdquo;
&lt;strong>CGO_ENABLED=&amp;ldquo;0&amp;rdquo;&lt;/strong> # CGO_ENABLED 开启后 Go 代码最终编译的可执行文件都是要有外部依赖的。不过我们依然可以通过 disable CGO_ENABLED 来编译出纯静态的 Go 程序，常用于交叉编译。CGO_ENABLED 关闭即可编译出纯静态的 Go 程序，可以用于 alpine 镜像中。
GOMOD=&amp;quot;/dev/null&amp;quot;
CGO_CFLAGS=&amp;quot;-g -O2&amp;quot;
CGO_CPPFLAGS=&amp;quot;&amp;quot;
CGO_CXXFLAGS=&amp;quot;-g -O2&amp;quot;
CGO_FFLAGS=&amp;quot;-g -O2&amp;quot;
CGO_LDFLAGS=&amp;quot;-g -O2&amp;quot;
PKG_CONFIG=&amp;ldquo;pkg-config&amp;rdquo;
GOGCCFLAGS=&amp;quot;-fPIC -m64 -fmessage-length=0 -fdebug-prefix-map=/tmp/go-build1775394647=/tmp/go-build -gno-record-gcc-switches&amp;quot;&lt;/p>
&lt;h2 id="goproxy-说明">goproxy 说明&lt;/h2>
&lt;p>我把老哥的 Issue 转移到这里来了哈，这个项目才是 &lt;a href="https://goproxy.cn/">goproxy.cn&lt;/a> 的源代码。&lt;a href="https://github.com/goproxy/goproxy">Goproxy&lt;/a> 是这个项目所基于的底层 Go module proxy 实现，它针对的不只是国内的开发者，所以既不建议用中文也不适合讨论 &lt;a href="https://goproxy.cn/">goproxy.cn&lt;/a>。这里讨论老哥你的问题才更为合适。
我先说一下 &lt;a href="https://goproxy.cn/">goproxy.cn&lt;/a> 和 &lt;a href="https://goproxy.io/">goproxy.io&lt;/a> 的背景。io 是由坤哥（&lt;a href="https://github.com/oiooj">@oiooj&lt;/a>）开发出来的，要早于 cn 出现几个月，目前由他跑在他所任职的公司腾讯云的香港区服务器上。cn 是由我发起的，现在完全属于七牛云，也备案在他们名下，自然所有的 CDN 资源和服务器资源都是由他们提供的，我目前跟 cn 的关系是属于它的维护者，并不是拥有者。
再说一下为什么会有两个这么相似的域名且功能类似的项目存在。我注册 cn 是去年二月底，当时是直接查询的 cn 后缀，因为我想的是这种项目肯定也就咱们中国是刚需要单独再来一套，所以并没有查询别的后缀，因为我认为 cn 实在是太合适了。并且由于当时我还在忙我的本科毕设和其他的一下事情，二月份我并没有开始开发 cn，等开发完了跟七牛云的 CEO 许叔（&lt;a href="https://github.com/xushiwei">@xushiwei&lt;/a>）谈交给他们运营时候，我才第一次听同学说到了 io。但当时我点进 io 的 GitHub 仓库一看发现并没有任何地方提到中国并且全是英文就下意识以为它是个国外项目，就没做过多研究，并且的 io 服务器当时也在美国我访问速度有些慢，就也没在意了。
最后再说一下为什么两个项目没有合并了一起发展。这个我和坤哥是有讨论过的，因为有人找上了我跟坤哥。并且坤哥也同意了最后我的提议合并了两个项目，将 cn 留作国内的公共代理，将 io 的代理类流量重定向到 cn 并后续将 io 用作一款搭代理的开源软件来面向全球提供给大家替换掉 JFrog 的一款商业产品，目前只有这一种解决方案才能保持两个功能独立且都能继续存活下去。坤哥之所以能同意我的这个提议一方面是坤哥所任职的公司加班过于严重，还有一方面是他自身没有精力维护了。然后之所以选择留 cn 做公共代理一方面是这两个域名里面只有 cn 能做备案能挂上 CDN 服务，因为这种类型的项目 CDN 服务是刚需，还有一方面是 io 这个域名后缀做全球化项目比 cn 更为合适，所以留 io 作国内代理把 cn 用作面向全球的搭代理的软件就显得很别扭了。
为什么两个项目现在没有合并呢？这个就不是因为我们两个作者了，因为我们两个作者已经达成了一致可以合并。这里面还有第三方地插足（为保其名誉我暂时不提具体是谁），其认为公共代理必须交由其所掌控的“社区”来运营，cn 已经过户给了一家商业公司无法再过户给其所掌控的“社区”，所以 cn 在其眼里就变成了一个其所描述的邪恶公司所拥有的商业产品，于是其要求我和七牛商谈放弃 cn 并全力投入为其做别的开发，于是被我拒绝。最后坤哥在中间处境比较尴尬，所以合并的事儿也就暂时搁置了。
最后，简单来总结一下就是，&lt;a href="https://goproxy.cn/">goproxy.cn&lt;/a> 和 &lt;a href="https://goproxy.io/">goproxy.io&lt;/a> 目前并无直接关系。或许之后没有了第三方地插足它们两个会合并变得有关系，但在那之前它们唯一能联系在一起的是它们都可以用作为 Go module proxy。至于哪个快、哪个稳、哪个香、用哪个，这个需要老哥你自己做判断了，我跟坤哥的关系并不差，所以我现在不会妄加评论。更何况现在 &lt;code>GOPROXY&lt;/code> 不是支持逗号列表嘛。❤️&lt;/p>
&lt;h2 id="gopath">GOPATH&lt;/h2>
&lt;p>注意：以下对 GOPATH 的理解是在 golang1.13 版本之前&lt;/p>
&lt;p>GOPATH 就是 go 项目的工作目录，是开发人员写代码的目录。&lt;/p>
&lt;p>GOPATH 里面一般包含 bin、pkg、src 这 3 个文件夹。&lt;/p>
&lt;p>项目文件夹一般是放在 src 目录中&lt;/p>
&lt;p>一般情况下，如果自己在开发多个项目，那么最好一个项目对应一个 GOPATH 路径。这时候只需要切换 GOPATH 环境变量的值，就可以编译运行对应的项目了。(比如我有两个项目目录/root/cobra 和/root/bee，这俩目录可以分别作为 GOPATH 变量的值，想开发哪个，就把 GOPATH 变量的值改为对应的目录路径)&lt;/p>
&lt;p>这样做的目的主要是为了让每个项目所依赖的库等东西，可以分开而不会冲突&lt;/p>
&lt;p>现在有 go module 之后，就可以不用把项目放在 GOPATH 路径下了。具体 go module 的作用详见 1.4.Go module 的介绍及使用.1 新功能 module 的介绍及使用&lt;/p></description></item><item><title>Docs: Grafana</title><link>https://desistdaydream.github.io/docs/IT%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/6.%E5%8F%AF%E8%A7%82%E6%B5%8B%E6%80%A7/Grafana/Grafana/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/IT%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/6.%E5%8F%AF%E8%A7%82%E6%B5%8B%E6%80%A7/Grafana/Grafana/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://grafana.com/">官网&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://github.com/grafana/grafana">GitHub 项目，grafana/grafana&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>Grafana 是开源的可视化和分析软件。它使我们可以查询，可视化，警报和浏览指标，无论它们存储在哪里。用简单的英语，它为您提供了将时间序列数据库（TSDB）数据转换为精美的图形和可视化效果的工具。&lt;/p>
&lt;h1 id="grafana-部署">Grafana 部署&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://grafana.com/docs/grafana/latest/setup-grafana/installation/">官方文档，安装-安装 Grafana&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;h2 id="docker-方式运行-grafana">docker 方式运行 grafana&lt;/h2>
&lt;p>获取配置文件&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>mkdir -p /opt/monitoring/server/config/grafana
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>mkdir -p /opt/monitoring/server/data/grafana
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>chown -R &lt;span style="color:#ae81ff">472&lt;/span> /opt/monitoring/server/data/grafana
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>docker run -d --name grafana --rm grafana/grafana
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>docker cp grafana:/etc/grafana /opt/monitoring/server/config
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>docker stop grafana
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>运行 Grafana&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>docker run -d --name grafana &lt;span style="color:#ae81ff">\
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">&lt;/span> --network host &lt;span style="color:#ae81ff">\
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">&lt;/span> -v /opt/monitoring/server/config/grafana:/etc/grafana &lt;span style="color:#ae81ff">\
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">&lt;/span> -v /opt/monitoring/server/data/grafana:/var/lib/grafana &lt;span style="color:#ae81ff">\
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">&lt;/span> -v /etc/localtime:/etc/localtime &lt;span style="color:#ae81ff">\
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">&lt;/span> grafana/grafana
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h1 id="grafana-关联文件">Grafana 关联文件&lt;/h1>
&lt;p>**/etc/grafana/* **# grafana 配置文件保存路径&lt;/p>
&lt;ul>
&lt;li>&lt;strong>./grafana.ini&lt;/strong> # grafana 运行所需配置文件&lt;/li>
&lt;li>&lt;strong>./provisioning/*&lt;/strong> # Grafana 的 Provisioning 功能要读取的路径。该功能详见 &lt;a href="https://www.yuque.com/go/doc/33145852">Provisioning 配置&lt;/a>
&lt;ul>
&lt;li>&lt;strong>./dashboards/*.yaml&lt;/strong> # Grafana 启动时，会根据该路径下配置文件内的 .providers.options.path 字段的路径配置，去对应路径加载 grafana 的 dashboard 的 json 文件。&lt;/li>
&lt;li>&lt;strong>./datasources/*.yaml&lt;/strong> # Grafana 启动时，会根据该路径下配置文件，自动加载数据源信息。&lt;/li>
&lt;li>&lt;strong>./notifiers/*.yaml&lt;/strong> # Grafana 启动时，加载的告警配置文件。&lt;/li>
&lt;li>&lt;strong>./plugins/*.yaml&lt;/strong> # Grafana 启动时，加载的插件的配置文件。用来管理 Grafana 插件&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>/var/lib/grafana/*&lt;/strong> # grafana 数据保存路径&lt;/p>
&lt;ul>
&lt;li>&lt;strong>./grafana.db&lt;/strong> # grafana 数据文件，包括 用户信息、dashboard、datasource 等等。这是一个 SQLite3 数据库文件。&lt;/li>
&lt;li>&lt;strong>./plugins/*&lt;/strong> # grafana 安装的插件保存在该目录下&lt;/li>
&lt;/ul></description></item><item><title>Docs: Hugo</title><link>https://desistdaydream.github.io/docs/IT%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%AE%9E%E7%94%A8%E5%B7%A5%E5%85%B7/%E7%BD%91%E7%AB%99%E6%90%AD%E5%BB%BA/Hugo/Hugo/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/IT%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%AE%9E%E7%94%A8%E5%B7%A5%E5%85%B7/%E7%BD%91%E7%AB%99%E6%90%AD%E5%BB%BA/Hugo/Hugo/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://github.com/gohugoio/hugo">GitHub 项目，gohugoio/hugo&lt;/a>
&lt;ul>
&lt;li>&lt;a href="https://github.com/coderzh/gohugo.org">GitHub 项目，coderzh/gohugo.org&lt;/a>（一个从19年停更的 Hugo 中文网）&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;a href="https://gohugo.io/">官网&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Hugo_(software)">Wiki,Hugo(软件)&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>Hugo 是用 Go 语言编写的静态站点生成器。Steve Francia 最初于 2013 年将 Hugo 创建为开源项目。&lt;/p>
&lt;h1 id="hugo-的基本使用">Hugo 的基本使用&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://hugo.aiaide.com/post/%E8%87%AA%E5%AE%9A%E4%B9%89hugo%E4%B8%BB%E9%A2%98-%E4%BB%8E%E5%86%85%E5%AE%B9%E9%A1%B5%E5%BC%80%E5%A7%8B/">自定义hugo主题&amp;ndash;从内容开始&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>&lt;code>hugo new site hello_world&lt;/code> 命令将会创建一个包含以下元素的目录结构，这些目录的作用可以在&lt;a href="#%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84">下文&lt;/a>找到：&lt;/p>
&lt;pre tabindex="0">&lt;code>hello_world/
├── archetypes/
│ └── default.md
├── assets/
├── content/
├── data/
├── layouts/
├── public/
├── static/
├── themes/
└── config.toml
&lt;/code>&lt;/pre>&lt;p>进入到这个目录之后，执行 &lt;code>hugo server&lt;/code> 将会启动一个 HTTP 服务端&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>~&lt;span style="color:#f92672">]&lt;/span>&lt;span style="color:#75715e"># hugo server --buildDrafts&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Start building sites …
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>hugo v0.109.0-47b12b83e636224e5e601813ff3e6790c191e371+extended windows/amd64 BuildDate&lt;span style="color:#f92672">=&lt;/span>2022-12-23T10:38:11Z VendorInfo&lt;span style="color:#f92672">=&lt;/span>gohugoio
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>WARN 2023/01/22 16:15:45 found no layout file &lt;span style="color:#66d9ef">for&lt;/span> &lt;span style="color:#e6db74">&amp;#34;HTML&amp;#34;&lt;/span> &lt;span style="color:#66d9ef">for&lt;/span> kind &lt;span style="color:#e6db74">&amp;#34;home&amp;#34;&lt;/span>: You should create a template file which matches Hugo Layouts Lookup Rules &lt;span style="color:#66d9ef">for&lt;/span> this combination.
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>WARN 2023/01/22 16:15:45 found no layout file &lt;span style="color:#66d9ef">for&lt;/span> &lt;span style="color:#e6db74">&amp;#34;HTML&amp;#34;&lt;/span> &lt;span style="color:#66d9ef">for&lt;/span> kind &lt;span style="color:#e6db74">&amp;#34;taxonomy&amp;#34;&lt;/span>: You should create a template file which matches Hugo Layouts Lookup Rules &lt;span style="color:#66d9ef">for&lt;/span> this combination.
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>WARN 2023/01/22 16:15:45 found no layout file &lt;span style="color:#66d9ef">for&lt;/span> &lt;span style="color:#e6db74">&amp;#34;HTML&amp;#34;&lt;/span> &lt;span style="color:#66d9ef">for&lt;/span> kind &lt;span style="color:#e6db74">&amp;#34;taxonomy&amp;#34;&lt;/span>: You should create a template file which matches Hugo Layouts Lookup Rules &lt;span style="color:#66d9ef">for&lt;/span> this combination.
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> | EN
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>-------------------+-----
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Pages | &lt;span style="color:#ae81ff">3&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Paginator pages | &lt;span style="color:#ae81ff">0&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Non-page files | &lt;span style="color:#ae81ff">0&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Static files | &lt;span style="color:#ae81ff">0&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Processed images | &lt;span style="color:#ae81ff">0&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Aliases | &lt;span style="color:#ae81ff">0&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Sitemaps | &lt;span style="color:#ae81ff">1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Cleaned | &lt;span style="color:#ae81ff">0&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Built in &lt;span style="color:#ae81ff">44&lt;/span> ms
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Watching &lt;span style="color:#66d9ef">for&lt;/span> changes in D:&lt;span style="color:#ae81ff">\P&lt;/span>rojects&lt;span style="color:#ae81ff">\D&lt;/span>esistDaydream&lt;span style="color:#ae81ff">\h&lt;/span>ugo-learning&lt;span style="color:#ae81ff">\h&lt;/span>ello_world&lt;span style="color:#ae81ff">\{&lt;/span>archetypes,assets,content,data,layouts,static&lt;span style="color:#f92672">}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Watching &lt;span style="color:#66d9ef">for&lt;/span> config changes in D:&lt;span style="color:#ae81ff">\P&lt;/span>rojects&lt;span style="color:#ae81ff">\D&lt;/span>esistDaydream&lt;span style="color:#ae81ff">\h&lt;/span>ugo-learning&lt;span style="color:#ae81ff">\h&lt;/span>ello_world&lt;span style="color:#ae81ff">\c&lt;/span>onfig.toml
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Environment: &lt;span style="color:#e6db74">&amp;#34;development&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Serving pages from memory
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Running in Fast Render Mode. For full rebuilds on change: hugo server --disableFastRender
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Web Server is available at http://localhost:1313/ &lt;span style="color:#f92672">(&lt;/span>bind address 127.0.0.1&lt;span style="color:#f92672">)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Press Ctrl+C to stop
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>我们可以通过浏览器，访问默认的 1313 端口浏览我们的网站，但是此时我们只能看到一个 Hugo 默认的 &lt;code>Page Not Found&lt;/code>，因为我们还没有为网站设置、添加任何内容。&lt;/p>
&lt;p>Hugo 从 &lt;code>content/&lt;/code> 目录中渲染内容到页面，我们使用 &lt;code>hugo new posts/my-first-post.md&lt;/code> 命令将会创建 &lt;code>content/posts/my-first-post.md&lt;/code> 文件，我们可以自行在该文件中添加 markdown 格式的内容。&lt;/p>
&lt;p>但是我们依然无法看到任何东西，因为 Hugo 提供了非常大的自由度，并不会限制 HTML 的样式，所以我们需要先自己创建一个 HTML 页面(就像写前端一样)。&lt;/p>
&lt;p>在 layouts/ 目录下新建 _default 目录，并创建一个名为 single.html 文件，写下如下内容：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-html" data-lang="html">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&amp;lt;!DOCTYPE html&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&amp;lt;&lt;span style="color:#f92672">html&lt;/span> &lt;span style="color:#a6e22e">lang&lt;/span>&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;zh&amp;#34;&lt;/span>&amp;gt;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&amp;lt;&lt;span style="color:#f92672">head&lt;/span>&amp;gt;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>    &amp;lt;&lt;span style="color:#f92672">meta&lt;/span> &lt;span style="color:#a6e22e">charset&lt;/span>&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;UTF-8&amp;#34;&lt;/span>&amp;gt;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>    &amp;lt;&lt;span style="color:#f92672">meta&lt;/span> &lt;span style="color:#a6e22e">name&lt;/span>&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;viewport&amp;#34;&lt;/span> &lt;span style="color:#a6e22e">content&lt;/span>&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;width=device-width, initial-scale=1.0&amp;#34;&lt;/span>&amp;gt;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>    &amp;lt;&lt;span style="color:#f92672">meta&lt;/span> &lt;span style="color:#a6e22e">http-equiv&lt;/span>&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;X-UA-Compatible&amp;#34;&lt;/span> &lt;span style="color:#a6e22e">content&lt;/span>&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;ie=edge&amp;#34;&lt;/span>&amp;gt;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>    &amp;lt;&lt;span style="color:#f92672">title&lt;/span>&amp;gt;{{.Title}}&amp;lt;/&lt;span style="color:#f92672">title&lt;/span>&amp;gt;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&amp;lt;/&lt;span style="color:#f92672">head&lt;/span>&amp;gt;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&amp;lt;&lt;span style="color:#f92672">body&lt;/span>&amp;gt;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>    &amp;lt;&lt;span style="color:#f92672">div&lt;/span> &lt;span style="color:#a6e22e">id&lt;/span>&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;post&amp;#34;&lt;/span> &lt;span style="color:#a6e22e">class&lt;/span>&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;post&amp;#34;&lt;/span>&amp;gt;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>        &amp;lt;&lt;span style="color:#f92672">article&lt;/span>&amp;gt;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>            &amp;lt;&lt;span style="color:#f92672">header&lt;/span>&amp;gt;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>                &amp;lt;&lt;span style="color:#f92672">h1&lt;/span> &lt;span style="color:#a6e22e">class&lt;/span>&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;post-title&amp;#34;&lt;/span>&amp;gt;{{ .Title }}&amp;lt;/&lt;span style="color:#f92672">h1&lt;/span>&amp;gt;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>            &amp;lt;/&lt;span style="color:#f92672">header&lt;/span>&amp;gt;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>            {{.Content}}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>        &amp;lt;/&lt;span style="color:#f92672">article&lt;/span>&amp;gt;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>    &amp;lt;/&lt;span style="color:#f92672">div&lt;/span>&amp;gt;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&amp;lt;/&lt;span style="color:#f92672">body&lt;/span>&amp;gt;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&amp;lt;/&lt;span style="color:#f92672">html&lt;/span>&amp;gt;
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>此时我们直接访问 &lt;code>http://localhost:1313/posts/my-first-post/&lt;/code> 即可看到我们刚才添加的 markdown 的内容。只不过没有任何样式，光秃秃的~&lt;/p>
&lt;p>&lt;img src="https://notes-picgo.oss-cn-beijing.aliyuncs.com/20230122175219.png" alt="image.png">&lt;/p>
&lt;h2 id="使用主题">使用主题&lt;/h2>
&lt;p>我们自己编写 HTML 是非常复杂的，咱是要内容管理。。又不是写前端页面~~~o(╯□╰)o&lt;/p>
&lt;p>Hugo 贴心得提供了主题功能，可以让我们专注于内容的产出，在 Hugo 官方的主题页面中，我们可以挑选我们喜欢的主题并放在 themes/ 目录下，以便使用时供 Hugo 加载&lt;/p>
&lt;blockquote>
&lt;p>除了将主题放在 themes/ 目录下，还可以使用 Hugo 模块功能，将主题当做 Go 模块一样的东西，统一管理。这样在我们创建多个 Hugo 站点并使用同一个主题时，不用重复下载了。&lt;/p>
&lt;/blockquote>
&lt;p>我们使用官方示例中的基本主题：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>git submodule add https://github.com/theNewDynamic/gohugo-theme-ananke themes/ananke
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>echo &lt;span style="color:#e6db74">&amp;#34;theme = &amp;#39;ananke&amp;#39;&amp;#34;&lt;/span> &amp;gt;&amp;gt; config.toml
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>主题将会被下载到 thems/ 目录中，并且我们在 config.toml 文件中指定要使用的主题名称。&lt;/p>
&lt;p>此时再打开 1313 端口，我们就可以看到我们的站点了，第一篇文章以标题和概要的形式被展现在首页中。&lt;/p>
&lt;p>&lt;img src="https://notes-picgo.oss-cn-beijing.aliyuncs.com/20230122164828.png" alt="image.png">&lt;/p>
&lt;h3 id="通过-hugo-模块使用主题">通过 Hugo 模块使用主题&lt;/h3>
&lt;p>想要使用 Hugo 模块，我们需要 Go 环境&lt;/p>
&lt;p>执行如下命令&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>hugo mod init github.com/DesistDaydream/hugo-learning/hello_world
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>hugo mod get github.com/theNewDynamic/gohugo-theme-ananke
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>此时主题将会被下载到 &lt;code>%TMP%/hugo_cache/modules/filecache/modules/pkg/mod/github.com&lt;/code> 目录下，然后我们可以删掉项目目录中 themes/ 目录下的主题文件了~o(∩_∩)o&lt;/p>
&lt;p>修改 config.toml 文件&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-toml" data-lang="toml">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">theme&lt;/span> = [&lt;span style="color:#e6db74">&amp;#34;github.com/theNewDynamic/gohugo-theme-ananke&amp;#34;&lt;/span>]
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="发布我们的网站">发布我们的网站&lt;/h2>
&lt;p>在基本示例中，我们只是在本地调试，如果想要将网站运行在服务器上，那么肯定需要像前端代码一样，将这些文件打包才可以。&lt;/p>
&lt;p>Hugo 打包非常简单，执行 &lt;code>hugo&lt;/code> 命令即可在 public/ 目录中生成我们网站的静态页面，将这个目录下的所有文件，统统放到 Nginx 中响应页面的目录，就可以访问我们自己的网站了~&lt;/p>
&lt;h3 id="最佳实践">最佳实践&lt;/h3>
&lt;p>很多时候，我们通过工作流（GitHub Action 等）将 &lt;code>public/&lt;/code> 目录下的文件转存到新项目中，并不会将原始内容与打包好的前端代码放在一起。&lt;/p>
&lt;h2 id="目录结构">目录结构&lt;/h2>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://gohugo.io/getting-started/directory-structure/">官方文档，入门-目录结构&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;h3 id="archetypes">archetypes&lt;/h3>
&lt;h3 id="assets">assets&lt;/h3>
&lt;p>存放所有需要由 Hugo Pipes 处理的文件。&lt;/p>
&lt;h3 id="config">config&lt;/h3>
&lt;blockquote>
&lt;p>注意：config 目录并不会随着 &lt;code>hugo new site example&lt;/code> 命令自动创建出来。而是在我们需要将单一配置文件拆分时，手动创建并使用的。&lt;/p>
&lt;/blockquote>
&lt;p>Hugo 附带了大量的配置指令。config 目录是将这些指令存储为 JSON、YAML 或 TOML 文件的地方。每个根设置对象都可以作为自己的文件并按环境构建。设置最少且不需要环境的项目可以在其根目录下使用单个 config.toml 文件。&lt;/p>
&lt;p>许多站点可能几乎不需要配置，但 Hugo 附带了大量 &lt;a href="https://gohugo.io/getting-started/configuration/#all-configuration-settings">configuration directives(配置指令)&lt;/a>，用于更详细地指导我们希望 Hugo 如何构建网站。注意：默认情况下不创建 config 目录。&lt;/p>
&lt;h3 id="content">content/&lt;/h3>
&lt;p>我们使用 Hugo 创建的网站的所有内容通常都要放在 content 目录中。content 目录下的每个顶级文件夹称为 &lt;a href="https://gohugo.io/content-management/sections/">content section(内容部分)&lt;/a>。&lt;/p>
&lt;p>比如，如果我的网站有三大块，分别是 blog、articles、tuorials，那么我们需要创建如下的目录结构&lt;/p>
&lt;pre tabindex="0">&lt;code>example/
├── content/
│ ├── blog/
│ ├── articles/
│ └── tuorials/
&lt;/code>&lt;/pre>&lt;p>Hugo 使用 section 的名称作为默认的 &lt;a href="https://gohugo.io/content-management/types/">content types(内容类型)&lt;/a>。假如有这么一个文件 content/blog/my-first-event.md，则这篇文章的内容类型就是 blog 类型。&lt;/p>
&lt;p>通过这种对网站内容的分类方式，更利于搜索、整理等。&lt;/p>
&lt;h3 id="data">data/&lt;/h3>
&lt;p>该目录用于存放 Hugo 在生成我的网站时可以使用的配置文件。可以用 YAML、JSON 或 TOML 格式编写这些文件。除了添加到此文件夹的文件外，还可以创建从动态内容中提取的数据模板。&lt;/p>
&lt;h3 id="layouts">layouts/&lt;/h3>
&lt;p>以 &lt;code>.html&lt;/code> 文件的形式存储模板，这些文件指定如何将您的内容视图呈现到静态网站中。模板包括 &lt;a href="https://gohugo.io/templates/list/">list pages&lt;/a>, your &lt;a href="https://gohugo.io/templates/homepage/">homepage&lt;/a>, &lt;a href="https://gohugo.io/templates/taxonomy-templates/">taxonomy templates&lt;/a>, &lt;a href="https://gohugo.io/templates/partials/">partials&lt;/a>, &lt;a href="https://gohugo.io/templates/single-page-templates/">single page templates&lt;/a>,等&lt;/p>
&lt;p>如果我们不使用主题，则 Hugo 会从 &lt;code>layouts&lt;/code> 目录中读取前端代码并渲染页面。&lt;/p>
&lt;h3 id="public">public/&lt;/h3>
&lt;p>使用 &lt;code>hugo&lt;/code> 命令生成网站的静态文件后，将会保存到 public 目录。public 目录生成的静态文件，可以直接通过 web 服务访问到。&lt;/p>
&lt;h3 id="static">static/&lt;/h3>
&lt;p>存储所有静态内容：图像、CSS、JavaScript 等。当 Hugo 构建您的站点时，静态目录中的所有资产都会按原样复制。使用静态文件夹的一个很好的例子是在 Google Search Console 上验证网站所有权，您希望 Hugo 在不修改其内容的情况下复制完整的 HTML 文件。&lt;/p>
&lt;h3 id="themes">themes/&lt;/h3>
&lt;blockquote>
&lt;p>更推荐的是使用 Hugo 模块使用主题，该目录不推荐使用。&lt;/p>
&lt;/blockquote>
&lt;p>Hugo 主题可以安装到该目录，使用 &lt;code>hugo server --themes&lt;/code> 指定使用的主题时，将会从该目录出寻找。&lt;/p>
&lt;h3 id="configtoml">config.toml&lt;/h3>
&lt;p>Hugo 运行站点时所使用的配置文件。&lt;/p>
&lt;p>推荐使用 config/ 目录，以便拆分 config.toml 文件。可以将 config.tom 文件移动到在 config/_default/config.toml 处作为默认配置。&lt;/p>
&lt;h1 id="hugo-modules模块">Hugo Modules(模块)&lt;/h1>
&lt;p>Hugo 模块是一个类似 Go 模块一样的存在。模块可以是我们的主项目或其他较小的模块，提供 Hugo 的 7 种组件类型中的一种或多种：&lt;/p>
&lt;ul>
&lt;li>&lt;strong>static&lt;/strong>&lt;/li>
&lt;li>&lt;strong>content&lt;/strong>&lt;/li>
&lt;li>&lt;strong>layouts&lt;/strong>&lt;/li>
&lt;li>&lt;strong>data&lt;/strong>&lt;/li>
&lt;li>&lt;strong>assets&lt;/strong>&lt;/li>
&lt;li>&lt;strong>i18n&lt;/strong>&lt;/li>
&lt;li>&lt;strong>archetypes&lt;/strong>&lt;/li>
&lt;/ul>
&lt;p>在 config.toml 文件中的 module 字段添加配置，即可为站点设置引用的模块，我们可以将主题当做一个模块。&lt;/p>
&lt;p>&lt;strong>注意：Hugo 模块与 Go 模块一样，也需要一个代理服务器，我们只需要在 module 部分配置 proxy 指令，值与 go proxy 一样即可&lt;/strong>&lt;/p>
&lt;h1 id="安装-hugo">安装 Hugo&lt;/h1>
&lt;p>安装 &lt;code>hogo&lt;/code> 命令行工具，即可开始使用 Hugo。推荐下载扩展版 hugo，即名字带有 extended 的文件。&lt;/p>
&lt;p>从 &lt;a href="https://github.com/gohugoio/hugo/releases">release&lt;/a> 页面下载带 &lt;strong>extended&lt;/strong> 后缀的文件。&lt;/p>
&lt;h1 id="关联文件与配置">关联文件与配置&lt;/h1>
&lt;p>&lt;strong>hugo.toml | hugo.yaml | hugo.json&lt;/strong> # 站点的配置文件，通常在站点的根目录。在 0.110.0 版本之前，默认的文件名是 config.toml 之类的。&lt;/p>
&lt;p>&lt;strong>${Site_Root_dir}/config&lt;/strong> # 可以将站点根目录下的 config.toml | config.yaml | config.json 拆分后保存到该目录。&lt;/p>
&lt;p>Hugo 运行时所需的缓存目录。包括需要使用的模块等：&lt;/p>
&lt;ul>
&lt;li>Windows:
&lt;ul>
&lt;li>&lt;strong>%TMP%/hugo_cache/&lt;/strong>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Linux:
&lt;ul>
&lt;li>&lt;strong>${TMP}/hugo_cache/&lt;/strong>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h1 id="hugo-与-obsidian">Hugo 与 Obsidian&lt;/h1>
&lt;h2 id="url-与-markdown-链接问题">URL 与 markdown 链接问题&lt;/h2>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://cloud.tencent.com/developer/article/1688894">https://cloud.tencent.com/developer/article/1688894&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>Obsidian 内部链接是这种格式 &lt;code>[B cd](/A/b/B%20cd.md)&lt;/code>&lt;/p>
&lt;p>Hugo 生成的内容资源的 URL 是 &lt;a href="https://demo.org/a/b/b-cd">https://demo.org/a/b/b-cd&lt;/a>&lt;/p>
&lt;p>此时，如果我们从页面点击 B cd，将会跳转到 &lt;a href="https://demo.org/A/b/B-cd">https://demo.org/A/b/B-cd&lt;/a> 页面，此时将会看到 404。。。。&lt;/p>
&lt;p>解决方式：&lt;/p>
&lt;p>在 hugo.config 中添加 &lt;code>disablePathToLower = true&lt;/code> 配置，以关闭转换为小写的功能。&lt;/p>
&lt;p>在 layouts/404.html 中添加如下脚本：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-js" data-lang="js">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">&amp;lt;&lt;/span>&lt;span style="color:#a6e22e">script&lt;/span>&lt;span style="color:#f92672">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">var&lt;/span> &lt;span style="color:#a6e22e">currenturl&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#a6e22e">location&lt;/span>.&lt;span style="color:#a6e22e">href&lt;/span>.&lt;span style="color:#a6e22e">replace&lt;/span>(&lt;span style="color:#e6db74">/%20/g&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;-&amp;#34;&lt;/span>).&lt;span style="color:#a6e22e">replace&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;.md&amp;#34;&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (&lt;span style="color:#a6e22e">currenturl&lt;/span> &lt;span style="color:#f92672">!=&lt;/span> &lt;span style="color:#a6e22e">location&lt;/span>.&lt;span style="color:#a6e22e">href&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">location&lt;/span>.&lt;span style="color:#a6e22e">href&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#a6e22e">currenturl&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">&amp;lt;&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">/script&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>此时跳转到 404 时，将会去掉 &lt;code>.md&lt;/code> 后缀，以及将所有的 &lt;code>%20&lt;/code> 替换成 &lt;code>-&lt;/code>&lt;/p></description></item><item><title>Docs: Instrumenting</title><link>https://desistdaydream.github.io/docs/IT%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/6.%E5%8F%AF%E8%A7%82%E6%B5%8B%E6%80%A7/%E7%9B%91%E6%8E%A7%E7%B3%BB%E7%BB%9F/Instrumenting/Instrumenting/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/IT%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/6.%E5%8F%AF%E8%A7%82%E6%B5%8B%E6%80%A7/%E7%9B%91%E6%8E%A7%E7%B3%BB%E7%BB%9F/Instrumenting/Instrumenting/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://prometheus.io/docs/instrumenting/exporters/">官方文档,Instrumenting-Exporter&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://prometheus.io/docs/practices/instrumentation/">官方文档,最佳实践-Instrumentation&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>Prometheus 可以通过 3 种方式从目标上 Scrape(抓取) 指标：&lt;/p>
&lt;ol>
&lt;li>&lt;strong>Instrumentation(检测仪)&lt;/strong> # 内部代码。将 Prometheus 的 Client Libraries(客户端库) 添加到程序代码中，以此暴露一个 endpoint，Prometheus Server 可以通过该 Endpoiint 抓取到指标。
&lt;ol>
&lt;li>可以理解为内嵌的 Exporter，比如 Prometheus Server 的 9090 端口的 &lt;code>/metrics&lt;/code> 就属于此类。&lt;/li>
&lt;li>说白了，就是被监控目标自己就可以吐出符合 Prometheus 格式的指标数据&lt;/li>
&lt;/ol>
&lt;/li>
&lt;li>**Exporters **# 外部程序。&lt;/li>
&lt;li>&lt;strong>Pushgateway&lt;/strong> # 针对需要推送指标的应用&lt;/li>
&lt;/ol>
&lt;h1 id="instrumentation">Instrumentation&lt;/h1>
&lt;h1 id="exporter">Exporter&lt;/h1>
&lt;p>在&lt;a href="https://github.com/prometheus/prometheus/wiki/Default-port-allocations">这里&lt;/a>可以看到经过 Prometheus 官方注册的各类 Exporter 所默认使用的端口号。&lt;/p>
&lt;h1 id="push-gateway">Push Gateway&lt;/h1></description></item><item><title>Docs: Inter Process Communication(进程间通信)</title><link>https://desistdaydream.github.io/docs/IT%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2.Kernel%E5%86%85%E6%A0%B8/7.Process-%E7%AE%A1%E7%90%86/Inter-Process-Communication%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1/Inter-Process-Communication%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/IT%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2.Kernel%E5%86%85%E6%A0%B8/7.Process-%E7%AE%A1%E7%90%86/Inter-Process-Communication%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1/Inter-Process-Communication%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Inter-process_communication">Wiki,IPC&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Local_Inter-Process_Communication">Wiki,LPC&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://mp.weixin.qq.com/s/MnIcTR0KKpgnSoA3xaPUSA">公众号,小林 Coding-进程间通信&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>&lt;strong>Inter Process Communication(进程间通信，简称 IPC)&lt;/strong> 是一种允许多个进程共享数据的机制。IPC 的两个应用可以被分为客户端和服务端，客户端进程请求数据，服务端响应客户端的数据请求。有一些应用本身既是服务器又是客户端，这在分布式计算中，时常可以见到。这些进程可以运行在同一计算机上或网络连接的不同计算机上。&lt;/p>
&lt;p>IPC 对微内核和 nano 内核的设计过程非常重要。 微内核减少了内核提供的功能数量。 然后通过 IPC 与服务器通信获得这些功能，与普通的宏内核相比，IPC 的数量大幅增加。&lt;/p>
&lt;p>IPC 可以分为如下两类：&lt;/p>
&lt;ul>
&lt;li>&lt;strong>Local Procedure Call(本地过程调用，简称 LPC)&lt;/strong> #&lt;/li>
&lt;li>&lt;strong>Remote Procedure Call(远程过程调用，简称 RPC)&lt;/strong> #&lt;/li>
&lt;/ul>
&lt;p>IPC 可以通过多种方式实现：&lt;/p>
&lt;ul>
&lt;li>&lt;strong>file(文件)&lt;/strong> # 多个进程可以通过磁盘上的文件共享数据。&lt;/li>
&lt;li>&lt;strong>Signal(信号)&lt;/strong># 从一个进程发送到另一个进程的系统消息，通常不用于传输数据，而是用于远程命令伙伴进程。&lt;a href="https://www.yuque.com/go/doc/33222681">详见此处&lt;/a>&lt;/li>
&lt;li>&lt;strong>pipe(管道)&lt;/strong># 使用标准输入和输出的单向数据通道。写入管道的写入端的数据由操作系统进行缓冲，直到从管道的读取端读取数据为止。通过使用相反“方向”上的两个管道可以实现过程之间的双向通信。详见 &lt;a href="https://desistdaydream.github.io/docs/IT%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/4.Terminal%20%E4%B8%8E%20Shell/bash/exec,xargs,%E7%AE%A1%E9%81%93%E7%AC%A6%E7%AD%89%E7%BB%84%E5%90%88%E5%91%BD%E4%BB%A4.md">exec、xargs、管道等命令&lt;/a>&lt;/li>
&lt;li>&lt;strong>Socket(套接字)&lt;/strong> # 计算机领域中数据通信的一种约定，或者说是一种方法，《&lt;a href="https://desistdaydream.github.io/docs/IT%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2.Kernel(%E5%86%85%E6%A0%B8)/7.Process%20%E7%AE%A1%E7%90%86/Inter%20Process%20Communication(%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1)/Socket(%E5%A5%97%E6%8E%A5%E5%AD%97)/Socket(%E5%A5%97%E6%8E%A5%E5%AD%97).md">Socket(套接字)&lt;/a>》。Socket 又分为两种
&lt;ul>
&lt;li>Unix Domain Socket&lt;/li>
&lt;li>Network Socket&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>Shared Memory(共享内存)&lt;/strong> #&lt;/li>
&lt;li>&lt;strong>Message Queue(消息队列)&lt;/strong> # 类似于 Socket 的数据流，但这通常保留了信息的边界。通常由操作系统实现，它们允许多个进程读写消息队列，而不需要彼此直接连接。&lt;/li>
&lt;li>&lt;strong>Mesage Passing(消息传递)&lt;/strong> # 允许多个程序使用消息队列和/或非 OS 托管通道进行通信。常用于并发模型。比如 LPC、RPC 等等。&lt;/li>
&lt;li>&lt;strong>等等&lt;/strong>&lt;/li>
&lt;/ul>
&lt;h1 id="ipc-实现方式概述">IPC 实现方式概述&lt;/h1>
&lt;p>每个进程的用户地址空间都是独立的，一般而言是不能互相访问的，但内核空间是每个进程都共享的，所以进程之间要通信必须通过内核。&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/iuxfg7/1619421762395-81aa05bc-0c16-4377-9584-9381c9433c63.png" alt="">&lt;/p>
&lt;p>Linux 内核提供了不少进程间通信的机制，我们来一起瞧瞧有哪些？&lt;/p>
&lt;h3 id="管道">管道&lt;/h3>
&lt;p>如果你学过 Linux 命令，那你肯定很熟悉 &lt;code>|&lt;/code> 这个竖线。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#960050;background-color:#1e0010">$ &lt;/span>&lt;span style="color:#a6e22e">ps&lt;/span>&lt;span style="color:#960050;background-color:#1e0010"> &lt;/span>&lt;span style="color:#a6e22e">auxf&lt;/span>&lt;span style="color:#960050;background-color:#1e0010"> &lt;/span>|&lt;span style="color:#960050;background-color:#1e0010"> &lt;/span>&lt;span style="color:#a6e22e">grep&lt;/span>&lt;span style="color:#960050;background-color:#1e0010"> &lt;/span>&lt;span style="color:#a6e22e">mysql&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>上面命令行里的 &lt;code>|&lt;/code> 竖线就是一个&lt;strong>管道&lt;/strong>，它的功能是将前一个命令 &lt;code>ps auxf&lt;/code> 的输出，作为后一个命令 &lt;code>grep mysql&lt;/code> 的输入，从这功能描述，可以看出&lt;strong>管道传输数据是单向的&lt;/strong>，如果想相互通信，我们需要创建两个管道才行。&lt;/p>
&lt;p>同时，我们得知上面这种管道是没有名字，所以 &lt;code>|&lt;/code> 表示的管道称为&lt;strong>匿名管道&lt;/strong>，用完了就销毁。&lt;/p>
&lt;p>管道还有另外一个类型是&lt;strong>命名管道&lt;/strong>，也被叫做 &lt;code>FIFO&lt;/code>，因为数据是先进先出的传输方式。&lt;/p>
&lt;p>在使用命名管道前，先需要通过 &lt;code>mkfifo&lt;/code> 命令来创建，并且指定管道名字：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#960050;background-color:#1e0010">$ &lt;/span>&lt;span style="color:#a6e22e">mkfifo&lt;/span>&lt;span style="color:#960050;background-color:#1e0010"> &lt;/span>&lt;span style="color:#a6e22e">myPipe&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>myPipe 就是这个管道的名称，基于 Linux 一切皆文件的理念，所以管道也是以文件的方式存在，我们可以用 ls 看一下，这个文件的类型是 p，也就是 pipe（管道） 的意思：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>$ ls
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>-lprw-r--r--. 1 root    root         0 Jul 17 02:45 myPipe
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>接下来，我们往 myPipe 这个管道写入数据：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>$ echo &lt;span style="color:#e6db74">&amp;#34;hello&amp;#34;&lt;/span> &amp;gt; myPipe  // 将数据写进管道
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> // 停住了 ...
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>你操作了后，你会发现命令执行后就停在这了，这是因为管道里的内容没有被读取，只有当管道里的数据被读完后，命令才可以正常退出。&lt;/p>
&lt;p>于是，我们执行另外一个命令来读取这个管道里的数据：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>$ cat &amp;lt; myPipe  // 读取管道里的数据hello
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>可以看到，管道里的内容被读取出来了，并打印在了终端上，另外一方面，echo 那个命令也正常退出了。&lt;/p>
&lt;p>我们可以看出，&lt;strong>管道这种通信方式效率低，不适合进程间频繁地交换数据&lt;/strong>。当然，它的好处，自然就是简单，同时也我们很容易得知管道里的数据已经被另一个进程读取了。&lt;/p>
&lt;blockquote>
&lt;p>那管道如何创建呢，背后原理是什么？&lt;/p>
&lt;/blockquote>
&lt;p>匿名管道的创建，需要通过下面这个系统调用：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>int pipe&lt;span style="color:#f92672">(&lt;/span>int fd&lt;span style="color:#f92672">[&lt;/span>2&lt;span style="color:#f92672">])&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>这里表示创建一个匿名管道，并返回了两个描述符，一个是管道的读取端描述符 &lt;code>fd[0]&lt;/code>，另一个是管道的写入端描述符 &lt;code>fd[1]&lt;/code>。注意，这个匿名管道是特殊的文件，只存在于内存，不存于文件系统中。
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/iuxfg7/1619421762470-c218e6b2-110b-454f-b314-057383247469.png" alt="">
其实，&lt;strong>所谓的管道，就是内核里面的一串缓存&lt;/strong>。从管道的一段写入的数据，实际上是缓存在内核中的，另一端读取，也就是从内核中读取这段数据。另外，管道传输的数据是无格式的流且大小受限。&lt;/p>
&lt;p>看到这，你可能会有疑问了，这两个描述符都是在一个进程里面，并没有起到进程间通信的作用，怎么样才能使得管道是跨过两个进程的呢？&lt;/p>
&lt;p>我们可以使用 &lt;code>fork&lt;/code> 创建子进程，&lt;strong>创建的子进程会复制父进程的文件描述符&lt;/strong>，这样就做到了两个进程各有两个「 &lt;code>fd[0]&lt;/code> 与 &lt;code>fd[1]&lt;/code>」，两个进程就可以通过各自的 fd 写入和读取同一个管道文件实现跨进程通信了。
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/iuxfg7/1619421762310-ab6819a4-d922-4393-9591-590864172c59.png" alt="">
管道只能一端写入，另一端读出，所以上面这种模式容易造成混乱，因为父进程和子进程都可以同时写入，也都可以读出。那么，为了避免这种情况，通常的做法是：&lt;/p>
&lt;ul>
&lt;li>父进程关闭读取的 fd[0]，只保留写入的 fd[1]；&lt;/li>
&lt;li>子进程关闭写入的 fd[1]，只保留读取的 fd[0]；&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/iuxfg7/1619421762492-d45b7c24-a90b-4fda-aea1-feb733f155bf.png" alt="">
所以说如果需要双向通信，则应该创建两个管道。&lt;/p>
&lt;p>到这里，我们仅仅解析了使用管道进行父进程与子进程之间的通信，但是在我们 shell 里面并不是这样的。&lt;/p>
&lt;p>在 shell 里面执行 &lt;code>A | B&lt;/code> 命令的时候，A 进程和 B 进程都是 shell 创建出来的子进程，A 和 B 之间不存在父子关系，它俩的父进程都是 shell。&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/iuxfg7/1619421762314-89d01b2d-6ffd-4cd8-9b56-6c6e9e6ffa03.png" alt="">&lt;/p>
&lt;p>所以说，在 shell 里通过「&lt;code>|&lt;/code>」匿名管道将多个命令连接在一起，实际上也就是创建了多个子进程，那么在我们编写 shell 脚本时，能使用一个管道搞定的事情，就不要多用一个管道，这样可以减少创建子进程的系统开销。&lt;/p>
&lt;p>我们可以得知，&lt;strong>对于匿名管道，它的通信范围是存在父子关系的进程&lt;/strong>。因为管道没有实体，也就是没有管道文件，只能通过 fork 来复制父进程 fd 文件描述符，来达到通信的目的。&lt;/p>
&lt;p>另外，&lt;strong>对于命名管道，它可以在不相关的进程间也能相互通信&lt;/strong>。因为命令管道，提前创建了一个类型为管道的设备文件，在进程里只要使用这个设备文件，就可以相互通信。&lt;/p>
&lt;p>不管是匿名管道还是命名管道，进程写入的数据都是缓存在内核中，另一个进程读取数据时候自然也是从内核中获取，同时通信数据都遵循&lt;strong>先进先出&lt;/strong>原则，不支持 lseek 之类的文件定位操作。&lt;/p>
&lt;h3 id="消息队列">消息队列&lt;/h3>
&lt;p>前面说到管道的通信方式是效率低的，因此管道不适合进程间频繁地交换数据。&lt;/p>
&lt;p>对于这个问题，&lt;strong>消息队列&lt;/strong>的通信模式就可以解决。比如，A 进程要给 B 进程发送消息，A 进程把数据放在对应的消息队列后就可以正常返回了，B 进程需要的时候再去读取数据就可以了。同理，B 进程要给 A 进程发送消息也是如此。&lt;/p>
&lt;p>再来，&lt;strong>消息队列是保存在内核中的消息链表&lt;/strong>，在发送数据时，会分成一个一个独立的数据单元，也就是消息体（数据块），消息体是用户自定义的数据类型，消息的发送方和接收方要约定好消息体的数据类型，所以每个消息体都是固定大小的存储块，不像管道是无格式的字节流数据。如果进程从消息队列中读取了消息体，内核就会把这个消息体删除。&lt;/p>
&lt;p>消息队列生命周期随内核，如果没有释放消息队列或者没有关闭操作系统，消息队列会一直存在，而前面提到的匿名管道的生命周期，是随进程的创建而建立，随进程的结束而销毁。&lt;/p>
&lt;p>消息这种模型，两个进程之间的通信就像平时发邮件一样，你来一封，我回一封，可以频繁沟通了。&lt;/p>
&lt;p>但邮件的通信方式存在不足的地方有两点，&lt;strong>一是通信不及时，二是附件也有大小限制&lt;/strong>，这同样也是消息队列通信不足的点。&lt;/p>
&lt;p>&lt;strong>消息队列不适合比较大数据的传输&lt;/strong>，因为在内核中每个消息体都有一个最大长度的限制，同时所有队列所包含的全部消息体的总长度也是有上限。在 Linux 内核中，会有两个宏定义 &lt;code>MSGMAX&lt;/code> 和 &lt;code>MSGMNB&lt;/code>，它们以字节为单位，分别定义了一条消息的最大长度和一个队列的最大长度。&lt;/p>
&lt;p>&lt;strong>消息队列通信过程中，存在用户态与内核态之间的数据拷贝开销&lt;/strong>，因为进程写入数据到内核中的消息队列时，会发生从用户态拷贝数据到内核态的过程，同理另一进程读取内核中的消息数据时，会发生从内核态拷贝数据到用户态的过程。&lt;/p>
&lt;h3 id="共享内存">共享内存&lt;/h3>
&lt;p>消息队列的读取和写入的过程，都会有发生用户态与内核态之间的消息拷贝过程。那&lt;strong>共享内存&lt;/strong>的方式，就很好的解决了这一问题。&lt;/p>
&lt;p>现代操作系统，对于内存管理，采用的是虚拟内存技术，也就是每个进程都有自己独立的虚拟内存空间，不同进程的虚拟内存映射到不同的物理内存中。所以，即使进程 A 和 进程 B 的虚拟地址是一样的，其实访问的是不同的物理内存地址，对于数据的增删查改互不影响。&lt;/p>
&lt;p>&lt;strong>共享内存的机制，就是拿出一块虚拟地址空间来，映射到相同的物理内存中&lt;/strong>。这样这个进程写入的东西，另外一个进程马上就能看到了，都不需要拷贝来拷贝去，传来传去，大大提高了进程间通信的速度。&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/iuxfg7/1619421762492-966784b1-cbd4-4545-bdae-300663d06a0b.png" alt="">&lt;/p>
&lt;h3 id="信号量">信号量&lt;/h3>
&lt;p>用了共享内存通信方式，带来新的问题，那就是如果多个进程同时修改同一个共享内存，很有可能就冲突了。例如两个进程都同时写一个地址，那先写的那个进程会发现内容被别人覆盖了。&lt;/p>
&lt;p>为了防止多进程竞争共享资源，而造成的数据错乱，所以需要保护机制，使得共享的资源，在任意时刻只能被一个进程访问。正好，&lt;strong>信号量&lt;/strong>就实现了这一保护机制。&lt;/p>
&lt;p>&lt;strong>信号量其实是一个整型的计数器，主要用于实现进程间的互斥与同步，而不是用于缓存进程间通信的数据&lt;/strong>。&lt;/p>
&lt;p>信号量表示资源的数量，控制信号量的方式有两种原子操作：&lt;/p>
&lt;ul>
&lt;li>一个是 &lt;strong>P 操作&lt;/strong>，这个操作会把信号量减去 -1，相减后如果信号量 &amp;lt;0，则表明资源已被占用，进程需阻塞等待；相减后如果信号量&amp;gt;= 0，则表明还有资源可使用，进程可正常继续执行。&lt;/li>
&lt;li>另一个是 &lt;strong>V 操作&lt;/strong>，这个操作会把信号量加上 1，相加后如果信号量 &amp;lt;= 0，则表明当前有阻塞中的进程，于是会将该进程唤醒运行；相加后如果信号量&amp;gt; 0，则表明当前没有阻塞中的进程；&lt;/li>
&lt;/ul>
&lt;p>P 操作是用在进入共享资源之前，V 操作是用在离开共享资源之后，这两个操作是必须成对出现的。&lt;/p>
&lt;p>接下来，举个例子，如果要使得两个进程互斥访问共享内存，我们可以初始化信号量为 &lt;code>1&lt;/code>。&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/iuxfg7/1619421762415-e1c7a414-1ecb-4d66-a920-881ebf3e3e85.png" alt="">&lt;/p>
&lt;p>具体的过程如下：&lt;/p>
&lt;ul>
&lt;li>进程 A 在访问共享内存前，先执行了 P 操作，由于信号量的初始值为 1，故在进程 A 执行 P 操作后信号量变为 0，表示共享资源可用，于是进程 A 就可以访问共享内存。&lt;/li>
&lt;li>若此时，进程 B 也想访问共享内存，执行了 P 操作，结果信号量变为了 -1，这就意味着临界资源已被占用，因此进程 B 被阻塞。&lt;/li>
&lt;li>直到进程 A 访问完共享内存，才会执行 V 操作，使得信号量恢复为 0，接着就会唤醒阻塞中的线程 B，使得进程 B 可以访问共享内存，最后完成共享内存的访问后，执行 V 操作，使信号量恢复到初始值 1。&lt;/li>
&lt;/ul>
&lt;p>可以发现，信号初始化为 &lt;code>1&lt;/code>，就代表着是&lt;strong>互斥信号量&lt;/strong>，它可以保证共享内存在任何时刻只有一个进程在访问，这就很好的保护了共享内存。&lt;/p>
&lt;p>另外，在多进程里，每个进程并不一定是顺序执行的，它们基本是以各自独立的、不可预知的速度向前推进，但有时候我们又希望多个进程能密切合作，以实现一个共同的任务。&lt;/p>
&lt;p>例如，进程 A 是负责生产数据，而进程 B 是负责读取数据，这两个进程是相互合作、相互依赖的，进程 A 必须先生产了数据，进程 B 才能读取到数据，所以执行是有前后顺序的。&lt;/p>
&lt;p>那么这时候，就可以用信号量来实现多进程同步的方式，我们可以初始化信号量为 &lt;code>0&lt;/code>。&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/iuxfg7/1619421762560-5bd9c203-120b-4f19-8bd1-4cf3bd2433d3.png" alt="">&lt;/p>
&lt;p>具体过程：&lt;/p>
&lt;ul>
&lt;li>如果进程 B 比进程 A 先执行了，那么执行到 P 操作时，由于信号量初始值为 0，故信号量会变为 -1，表示进程 A 还没生产数据，于是进程 B 就阻塞等待；&lt;/li>
&lt;li>接着，当进程 A 生产完数据后，执行了 V 操作，就会使得信号量变为 0，于是就会唤醒阻塞在 P 操作的进程 B；&lt;/li>
&lt;li>最后，进程 B 被唤醒后，意味着进程 A 已经生产了数据，于是进程 B 就可以正常读取数据了。&lt;/li>
&lt;/ul>
&lt;p>可以发现，信号初始化为 &lt;code>0&lt;/code>，就代表着是&lt;strong>同步信号量&lt;/strong>，它可以保证进程 A 应在进程 B 之前执行。&lt;/p>
&lt;h3 id="信号">信号&lt;/h3>
&lt;p>上面说的进程间通信，都是常规状态下的工作模式。&lt;strong>对于异常情况下的工作模式，就需要用「信号」的方式来通知进程。&lt;/strong>&lt;/p>
&lt;p>信号跟信号量虽然名字相似度 66.66%，但两者用途完全不一样，就好像 Java 和 JavaScript 的区别。&lt;/p>
&lt;p>在 Linux 操作系统中， 为了响应各种各样的事件，提供了几十种信号，分别代表不同的意义。我们可以通过 &lt;code>kill -l&lt;/code> 命令，查看所有的信号：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>root@lichenhao:~# kill -l
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> 1&lt;span style="color:#f92672">)&lt;/span> SIGHUP 2&lt;span style="color:#f92672">)&lt;/span> SIGINT 3&lt;span style="color:#f92672">)&lt;/span> SIGQUIT 4&lt;span style="color:#f92672">)&lt;/span> SIGILL 5&lt;span style="color:#f92672">)&lt;/span> SIGTRAP
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> 6&lt;span style="color:#f92672">)&lt;/span> SIGABRT 7&lt;span style="color:#f92672">)&lt;/span> SIGBUS 8&lt;span style="color:#f92672">)&lt;/span> SIGFPE 9&lt;span style="color:#f92672">)&lt;/span> SIGKILL 10&lt;span style="color:#f92672">)&lt;/span> SIGUSR1
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>11&lt;span style="color:#f92672">)&lt;/span> SIGSEGV 12&lt;span style="color:#f92672">)&lt;/span> SIGUSR2 13&lt;span style="color:#f92672">)&lt;/span> SIGPIPE 14&lt;span style="color:#f92672">)&lt;/span> SIGALRM 15&lt;span style="color:#f92672">)&lt;/span> SIGTERM
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>16&lt;span style="color:#f92672">)&lt;/span> SIGSTKFLT 17&lt;span style="color:#f92672">)&lt;/span> SIGCHLD 18&lt;span style="color:#f92672">)&lt;/span> SIGCONT 19&lt;span style="color:#f92672">)&lt;/span> SIGSTOP 20&lt;span style="color:#f92672">)&lt;/span> SIGTSTP
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>21&lt;span style="color:#f92672">)&lt;/span> SIGTTIN 22&lt;span style="color:#f92672">)&lt;/span> SIGTTOU 23&lt;span style="color:#f92672">)&lt;/span> SIGURG 24&lt;span style="color:#f92672">)&lt;/span> SIGXCPU 25&lt;span style="color:#f92672">)&lt;/span> SIGXFSZ
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>26&lt;span style="color:#f92672">)&lt;/span> SIGVTALRM 27&lt;span style="color:#f92672">)&lt;/span> SIGPROF 28&lt;span style="color:#f92672">)&lt;/span> SIGWINCH 29&lt;span style="color:#f92672">)&lt;/span> SIGIO 30&lt;span style="color:#f92672">)&lt;/span> SIGPWR
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>31&lt;span style="color:#f92672">)&lt;/span> SIGSYS 34&lt;span style="color:#f92672">)&lt;/span> SIGRTMIN 35&lt;span style="color:#f92672">)&lt;/span> SIGRTMIN+1 36&lt;span style="color:#f92672">)&lt;/span> SIGRTMIN+2 37&lt;span style="color:#f92672">)&lt;/span> SIGRTMIN+3
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>38&lt;span style="color:#f92672">)&lt;/span> SIGRTMIN+4 39&lt;span style="color:#f92672">)&lt;/span> SIGRTMIN+5 40&lt;span style="color:#f92672">)&lt;/span> SIGRTMIN+6 41&lt;span style="color:#f92672">)&lt;/span> SIGRTMIN+7 42&lt;span style="color:#f92672">)&lt;/span> SIGRTMIN+8
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>43&lt;span style="color:#f92672">)&lt;/span> SIGRTMIN+9 44&lt;span style="color:#f92672">)&lt;/span> SIGRTMIN+10 45&lt;span style="color:#f92672">)&lt;/span> SIGRTMIN+11 46&lt;span style="color:#f92672">)&lt;/span> SIGRTMIN+12 47&lt;span style="color:#f92672">)&lt;/span> SIGRTMIN+13
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>48&lt;span style="color:#f92672">)&lt;/span> SIGRTMIN+14 49&lt;span style="color:#f92672">)&lt;/span> SIGRTMIN+15 50&lt;span style="color:#f92672">)&lt;/span> SIGRTMAX-14 51&lt;span style="color:#f92672">)&lt;/span> SIGRTMAX-13 52&lt;span style="color:#f92672">)&lt;/span> SIGRTMAX-12
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>53&lt;span style="color:#f92672">)&lt;/span> SIGRTMAX-11 54&lt;span style="color:#f92672">)&lt;/span> SIGRTMAX-10 55&lt;span style="color:#f92672">)&lt;/span> SIGRTMAX-9 56&lt;span style="color:#f92672">)&lt;/span> SIGRTMAX-8 57&lt;span style="color:#f92672">)&lt;/span> SIGRTMAX-7
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>58&lt;span style="color:#f92672">)&lt;/span> SIGRTMAX-6 59&lt;span style="color:#f92672">)&lt;/span> SIGRTMAX-5 60&lt;span style="color:#f92672">)&lt;/span> SIGRTMAX-4 61&lt;span style="color:#f92672">)&lt;/span> SIGRTMAX-3 62&lt;span style="color:#f92672">)&lt;/span> SIGRTMAX-2
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>63&lt;span style="color:#f92672">)&lt;/span> SIGRTMAX-1 64&lt;span style="color:#f92672">)&lt;/span> SIGRTMAX
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>运行在 shell 终端的进程，我们可以通过键盘输入某些组合键的时候，给进程发送信号。例如&lt;/p>
&lt;ul>
&lt;li>Ctrl+C 产生 &lt;code>SIGINT&lt;/code> 信号，表示终止该进程；&lt;/li>
&lt;li>Ctrl+Z 产生 &lt;code>SIGTSTP&lt;/code> 信号，表示停止该进程，但还未结束；&lt;/li>
&lt;/ul>
&lt;p>如果进程在后台运行，可以通过 &lt;code>kill&lt;/code> 命令的方式给进程发送信号，但前提需要知道运行中的进程 PID 号，例如：&lt;/p>
&lt;ul>
&lt;li>kill -9 1050 ，表示给 PID 为 1050 的进程发送 &lt;code>SIGKILL&lt;/code> 信号，用来立即结束该进程；&lt;/li>
&lt;/ul>
&lt;p>所以，信号事件的来源主要有硬件来源（如键盘 Cltr+C ）和软件来源（如 kill 命令）。&lt;/p>
&lt;p>信号是进程间通信机制中&lt;strong>唯一的异步通信机制&lt;/strong>，因为可以在任何时候发送信号给某一进程，一旦有信号产生，我们就有下面这几种，用户进程对信号的处理方式。&lt;/p>
&lt;p>&lt;strong>1. 执行默认操作&lt;/strong>。Linux 对每种信号都规定了默认操作，例如，上面列表中的 SIGTERM 信号，就是终止进程的意思。Core 的意思是 Core Dump，也即终止进程后，通过 Core Dump 将当前进程的运行状态保存在文件里面，方便程序员事后进行分析问题在哪里。&lt;/p>
&lt;p>&lt;strong>2. 捕捉信号&lt;/strong>。我们可以为信号定义一个信号处理函数。当信号发生时，我们就执行相应的信号处理函数。&lt;/p>
&lt;p>&lt;strong>3. 忽略信号&lt;/strong>。当我们不希望处理某些信号的时候，就可以忽略该信号，不做任何处理。有两个信号是应用进程无法捕捉和忽略的，即 &lt;code>SIGKILL&lt;/code> 和 &lt;code>SEGSTOP&lt;/code>，它们用于在任何时候中断或结束某一进程。&lt;/p>
&lt;h3 id="socket">Socket&lt;/h3>
&lt;p>前面提到的管道、消息队列、共享内存、信号量和信号都是在同一台主机上进行进程间通信，那要想&lt;strong>跨网络与不同主机上的进程之间通信，就需要 Socket 通信了。&lt;/strong>&lt;/p>
&lt;p>实际上，Socket 通信不仅可以跨网络与不同主机的进程间通信，还可以在同主机上进程间通信。&lt;/p>
&lt;p>我们来看看创建 socket 的系统调用：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">int&lt;/span>&lt;span style="color:#960050;background-color:#1e0010"> &lt;/span>&lt;span style="color:#a6e22e">socket&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span>&lt;span style="color:#960050;background-color:#1e0010"> &lt;/span>&lt;span style="color:#a6e22e">domain&lt;/span>,&lt;span style="color:#960050;background-color:#1e0010"> &lt;/span>&lt;span style="color:#66d9ef">int&lt;/span>&lt;span style="color:#960050;background-color:#1e0010"> &lt;/span>&lt;span style="color:#66d9ef">type&lt;/span>,&lt;span style="color:#960050;background-color:#1e0010"> &lt;/span>&lt;span style="color:#66d9ef">int&lt;/span>&lt;span style="color:#960050;background-color:#1e0010"> &lt;/span>&lt;span style="color:#a6e22e">protocal&lt;/span>)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>三个参数分别代表：&lt;/p>
&lt;ul>
&lt;li>domain 参数用来指定协议族，比如 AF_INET 用于 IPV4、AF_INET6 用于 IPV6、AF_LOCAL/AF_UNIX 用于本机；&lt;/li>
&lt;li>type 参数用来指定通信特性，比如 SOCK_STREAM 表示的是字节流，对应 TCP、SOCK_DGRAM   表示的是数据报，对应 UDP、SOCK_RAW 表示的是原始套接字；&lt;/li>
&lt;li>protocal 参数原本是用来指定通信协议的，但现在基本废弃。因为协议已经通过前面两个参数指定完成，protocol 目前一般写成 0 即可；&lt;/li>
&lt;/ul>
&lt;p>根据创建 socket 类型的不同，通信的方式也就不同：&lt;/p>
&lt;ul>
&lt;li>实现 TCP 字节流通信：socket 类型是 AF_INET 和 SOCK_STREAM；&lt;/li>
&lt;li>实现 UDP 数据报通信：socket 类型是 AF_INET 和 SOCK_DGRAM；&lt;/li>
&lt;li>实现本地进程间通信：
&lt;ul>
&lt;li>「本地字节流 socket 」类型是 AF_LOCAL 和 SOCK_STREAM&lt;/li>
&lt;li>「本地数据报 socket 」类型是 AF_LOCAL 和 SOCK_DGRAM。另外，AF_UNIX 和 AF_LOCAL 是等价的，所以 AF_UNIX 也属于本地 socket；&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>接下来，简单说一下这三种通信的编程模式。&lt;/p>
&lt;blockquote>
&lt;p>针对 TCP 协议通信的 socket 编程模型&lt;/p>
&lt;/blockquote>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/iuxfg7/1619421762556-953130dd-bbfe-4a7d-ac0a-31c69ef31771.png" alt="">&lt;/p>
&lt;ul>
&lt;li>服务端和客户端初始化 &lt;code>socket&lt;/code>，得到文件描述符；&lt;/li>
&lt;li>服务端调用 &lt;code>bind&lt;/code>，将绑定在 IP 地址和端口;&lt;/li>
&lt;li>服务端调用 &lt;code>listen&lt;/code>，进行监听；&lt;/li>
&lt;li>服务端调用 &lt;code>accept&lt;/code>，等待客户端连接；&lt;/li>
&lt;li>客户端调用 &lt;code>connect&lt;/code>，向服务器端的地址和端口发起连接请求；&lt;/li>
&lt;li>服务端 &lt;code>accept&lt;/code> 返回用于传输的 &lt;code>socket&lt;/code> 的文件描述符；&lt;/li>
&lt;li>客户端调用 &lt;code>write&lt;/code> 写入数据；服务端调用 &lt;code>read&lt;/code> 读取数据；&lt;/li>
&lt;li>客户端断开连接时，会调用 &lt;code>close&lt;/code>，那么服务端 &lt;code>read&lt;/code> 读取数据的时候，就会读取到了 &lt;code>EOF&lt;/code>，待处理完数据后，服务端调用 &lt;code>close&lt;/code>，表示连接关闭。&lt;/li>
&lt;/ul>
&lt;p>这里需要注意的是，服务端调用 &lt;code>accept&lt;/code> 时，连接成功了会返回一个已完成连接的 socket，后续用来传输数据。&lt;/p>
&lt;p>所以，监听的 socket 和真正用来传送数据的 socket，是「&lt;strong>两个&lt;/strong>」 socket，一个叫作&lt;strong>监听 socket&lt;/strong>，一个叫作&lt;strong>已完成连接 socket&lt;/strong>。&lt;/p>
&lt;p>成功连接建立之后，双方开始通过 read 和 write 函数来读写数据，就像往一个文件流里面写东西一样。&lt;/p>
&lt;blockquote>
&lt;p>针对 UDP 协议通信的 socket 编程模型&lt;/p>
&lt;/blockquote>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/iuxfg7/1619421762345-95e531c1-8f0d-42d3-80d2-e8981177ed74.png" alt="">&lt;/p>
&lt;p>UDP 是没有连接的，所以不需要三次握手，也就不需要像 TCP 调用 listen 和 connect，但是 UDP 的交互仍然需要 IP 地址和端口号，因此也需要 bind。&lt;/p>
&lt;p>对于 UDP 来说，不需要要维护连接，那么也就没有所谓的发送方和接收方，甚至都不存在客户端和服务端的概念，只要有一个 socket 多台机器就可以任意通信，因此每一个 UDP 的 socket 都需要 bind。&lt;/p>
&lt;p>另外，每次通信时，调用 sendto 和 recvfrom，都要传入目标主机的 IP 地址和端口。&lt;/p>
&lt;blockquote>
&lt;p>针对本地进程间通信的 socket 编程模型&lt;/p>
&lt;/blockquote>
&lt;p>本地 socket   被用于在&lt;strong>同一台主机上进程间通信&lt;/strong>的场景：&lt;/p>
&lt;ul>
&lt;li>本地 socket 的编程接口和 IPv4 、IPv6 套接字编程接口是一致的，可以支持「字节流」和「数据报」两种协议；&lt;/li>
&lt;li>本地 socket 的实现效率大大高于 IPv4 和 IPv6 的字节流、数据报 socket 实现；&lt;/li>
&lt;/ul>
&lt;p>对于本地字节流 socket，其 socket 类型是 AF_LOCAL 和 SOCK_STREAM。&lt;/p>
&lt;p>对于本地数据报 socket，其 socket 类型是 AF_LOCAL 和 SOCK_DGRAM。&lt;/p>
&lt;p>本地字节流 socket 和 本地数据报 socket 在 bind 的时候，不像 TCP 和 UDP 要绑定 IP 地址和端口，而是&lt;strong>绑定一个本地文件&lt;/strong>，这也就是它们之间的最大区别。&lt;/p>
&lt;h3 id="总结">总结&lt;/h3>
&lt;p>由于每个进程的用户空间都是独立的，不能相互访问，这时就需要借助内核空间来实现进程间通信，原因很简单，每个进程都是共享一个内核空间。&lt;/p>
&lt;p>Linux 内核提供了不少进程间通信的方式，其中最简单的方式就是管道，管道分为「匿名管道」和「命名管道」。&lt;/p>
&lt;p>&lt;strong>匿名管道&lt;/strong>顾名思义，它没有名字标识，匿名管道是特殊文件只存在于内存，没有存在于文件系统中，shell 命令中的 &lt;code>|&lt;/code> 竖线就是匿名管道，通信的数据是&lt;strong>无格式的流并且大小受限&lt;/strong>，通信的方式是&lt;strong>单向&lt;/strong>的，数据只能在一个方向上流动，如果要双向通信，需要创建两个管道，再来&lt;strong>匿名管道是只能用于存在父子关系的进程间通信&lt;/strong>，匿名管道的生命周期随着进程创建而建立，随着进程终止而消失。&lt;/p>
&lt;p>&lt;strong>命名管道&lt;/strong>突破了匿名管道只能在亲缘关系进程间的通信限制，因为使用命名管道的前提，需要在文件系统创建一个类型为 p 的设备文件，那么毫无关系的进程就可以通过这个设备文件进行通信。另外，不管是匿名管道还是命名管道，进程写入的数据都是&lt;strong>缓存在内核&lt;/strong>中，另一个进程读取数据时候自然也是从内核中获取，同时通信数据都遵循&lt;strong>先进先出&lt;/strong>原则，不支持 lseek 之类的文件定位操作。&lt;/p>
&lt;p>&lt;strong>消息队列&lt;/strong>克服了管道通信的数据是无格式的字节流的问题，消息队列实际上是保存在内核的「消息链表」，消息队列的消息体是可以用户自定义的数据类型，发送数据时，会被分成一个一个独立的消息体，当然接收数据时，也要与发送方发送的消息体的数据类型保持一致，这样才能保证读取的数据是正确的。消息队列通信的速度不是最及时的，毕竟&lt;strong>每次数据的写入和读取都需要经过用户态与内核态之间的拷贝过程。&lt;/strong>&lt;/p>
&lt;p>&lt;strong>共享内存&lt;/strong>可以解决消息队列通信中用户态与内核态之间数据拷贝过程带来的开销，&lt;strong>它直接分配一个共享空间，每个进程都可以直接访问&lt;/strong>，就像访问进程自己的空间一样快捷方便，不需要陷入内核态或者系统调用，大大提高了通信的速度，享有&lt;strong>最快&lt;/strong>的进程间通信方式之名。但是便捷高效的共享内存通信，&lt;strong>带来新的问题，多进程竞争同个共享资源会造成数据的错乱。&lt;/strong>&lt;/p>
&lt;p>那么，就需要&lt;strong>信号量&lt;/strong>来保护共享资源，以确保任何时刻只能有一个进程访问共享资源，这种方式就是互斥访问。&lt;strong>信号量不仅可以实现访问的互斥性，还可以实现进程间的同步&lt;/strong>，信号量其实是一个计数器，表示的是资源个数，其值可以通过两个原子操作来控制，分别是 &lt;strong>P 操作和 V 操作&lt;/strong>。&lt;/p>
&lt;p>与信号量名字很相似的叫&lt;strong>信号&lt;/strong>，它俩名字虽然相似，但功能一点儿都不一样。信号是进程间通信机制中&lt;strong>唯一的异步通信机制&lt;/strong>，信号可以在应用进程和内核之间直接交互，内核也可以利用信号来通知用户空间的进程发生了哪些系统事件，信号事件的来源主要有硬件来源（如键盘 Cltr+C ）和软件来源（如 kill 命令），一旦有信号发生，&lt;strong>进程有三种方式响应信号 1. 执行默认操作、2. 捕捉信号、3. 忽略信号&lt;/strong>。有两个信号是应用进程无法捕捉和忽略的，即 &lt;code>SIGKILL&lt;/code> 和 &lt;code>SEGSTOP&lt;/code>，这是为了方便我们能在任何时候结束或停止某个进程。&lt;/p>
&lt;p>前面说到的通信机制，都是工作于同一台主机，如果&lt;strong>要与不同主机的进程间通信，那么就需要 Socket 通信了&lt;/strong>。Socket 实际上不仅用于不同的主机进程间通信，还可以用于本地主机进程间通信，可根据创建 Socket 的类型不同，分为三种常见的通信方式，一个是基于 TCP 协议的通信方式，一个是基于 UDP 协议的通信方式，一个是本地进程间通信方式。&lt;/p>
&lt;p>以上，就是进程间通信的主要机制了。你可能会问了，那线程通信间的方式呢？&lt;/p>
&lt;p>同个进程下的线程之间都是共享进程的资源，只要是共享变量都可以做到线程间通信，比如全局变量，所以对于线程间关注的不是通信方式，而是关注多线程竞争共享资源的问题，信号量也同样可以在线程间实现互斥与同步：&lt;/p>
&lt;ul>
&lt;li>互斥的方式，可保证任意时刻只有一个线程访问共享资源；&lt;/li>
&lt;li>同步的方式，可保证线程 A 应在线程 B 之前执行；&lt;/li>
&lt;/ul></description></item><item><title>Docs: IPVS</title><link>https://desistdaydream.github.io/docs/IT%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/3.%E9%9B%86%E7%BE%A4%E4%B8%8E%E5%88%86%E5%B8%83%E5%BC%8F/LVS/IPVS/IPVS/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/IT%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/3.%E9%9B%86%E7%BE%A4%E4%B8%8E%E5%88%86%E5%B8%83%E5%BC%8F/LVS/IPVS/IPVS/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/IP_Virtual_Server">Wiki,IPVS&lt;/a>&lt;/li>
&lt;li>&lt;a href="http://www.linuxvirtualserver.org/software/ipvs.html">官方文档&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>&lt;strong>IP Virtual Service(IP 虚拟服务，简称 IPVS)&lt;/strong> 是基于 &lt;a href="https://desistdaydream.github.io/docs/IT%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2.Kernel(%E5%86%85%E6%A0%B8)/8.Network%20%E7%AE%A1%E7%90%86/Linux%20%E7%BD%91%E7%BB%9C%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6/Netfilter%20%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6%E7%B3%BB%E7%BB%9F/Netfilter%20%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6%E7%B3%BB%E7%BB%9F.md">Netfilter&lt;/a> 的 Linux 内核模块，用来实现 &lt;a href="docs/IT%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/3.%E9%9B%86%E7%BE%A4%E4%B8%8E%E5%88%86%E5%B8%83%E5%BC%8F/LVS/LVS.md">LVS&lt;/a> 集群中的 &lt;strong>Scheduler(调度器)&lt;/strong> 功能。启动这个模块的 Linux 服务器就变成了 LVS 系统中的 &lt;strong>Director&lt;/strong>，此时，这个服务器可以看作是一种高效的 Layer-4(四层) 交换机。在 Director 上运行 IPVS 代码是 LVS 的基本要素。&lt;/p>
&lt;p>IPVS 在服务器上运行，并充当 RS 集群前面的负载均衡器。IPVS 可以将基于 TCP 和 UDP 的服务请求定向到真实服务器，并使真实服务器的服务在单个 IP 地址上表现为虚拟服务。当一个 TCP 连接的初始 SYN 报文到达时，IPVS 就选择一台服务器，将报文转发给它。此后通过查发报文的 IP 和 TCP 报文头地址，保证此连接的后继报文被转发到相同的服务器。这样，IPVS 无法检查到请求的内容再选择服务器，这就要求后端的服务器组是提供相同的服务，不管请求被送到哪一台服务器，返回结果都应该是一样的。但是在有一些应用中后端的服务器可能功能不一，有的是提供 HTML 文档的 Web 服务器，有的是提供图片的 Web 服务器，有的是提供 CGI 的 Web 服务器。这时，就需要基于内容请求分发 (Content-Based Request Distribution)，同时基于内容请求分发可以提高后端服务器上访问的局部性。&lt;/p>
&lt;ul>
&lt;li>一个 ipvs 主机可以同时定义多个 cluster service&lt;/li>
&lt;li>一个 cluster service 上至少应该定义一个 real server，定义时指明 lvs-type，以及 lvs scheduler&lt;/li>
&lt;/ul>
&lt;p>用白话理解 IPVS：
IPVS 就是包括 Director 和 RS 在内的所有设备上的 IP，统一虚拟成一个 IP，这个 IP 就是面向用户的唯一 IP，用户通过这个 IP，就可以访问集群，让集群为其提供服务，这也是负载均衡的体现，也是集群的体现，把很多设备当做一个整体来看。&lt;/p>
&lt;h2 id="ipvs-与-lvs-的关系">IPVS 与 LVS 的关系&lt;/h2>
&lt;p>LVS 更偏向于描述一个概念，而 IPVS 程序则是实现 LVS 的最核心部分。通过 IPVS 以及其管理工具 ipvsadm，可以实现 LVS 中的 Director(指挥器)。而 RS，本质上并不需要 LVS 或者 IPVS 代码支持，只需要在 DR 模式下，配置一些内核参数即可。&lt;/p>
&lt;p>而随着发展，IPVS 已经存单独的程序，被包含在 Linux 内核中，成了了默认自带的模块。&lt;/p>
&lt;p>可以这么说，IPVS 就是 LVS；也可以说，LVS 包含 ipvs 与 ipvsadm。&lt;/p>
&lt;h1 id="ipvs-配置">IPVS 配置&lt;/h1>
&lt;p>ipvs 可以通过两种方式进行配置：&lt;/p>
&lt;ul>
&lt;li>ipvsadm 命令&lt;/li>
&lt;li>ipvs 模块参数&lt;/li>
&lt;/ul>
&lt;p>ipvs 是一个内核模块，所以，想要配置 ipvs 则需要以&lt;a href="https://desistdaydream.github.io/docs/IT%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2.Kernel(%E5%86%85%E6%A0%B8)/1.Linux%20Kernel/Module(%E6%A8%A1%E5%9D%97).md">内核模块&lt;/a>的配置方式来进行配置。可以通过 modinfo -p ip_vs 命令查看该模块可以配置的参数&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>~&lt;span style="color:#f92672">]&lt;/span>&lt;span style="color:#75715e"># modinfo -p ip_vs&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>conn_tab_bits:Set connections&lt;span style="color:#960050;background-color:#1e0010">&amp;#39;&lt;/span> hash size &lt;span style="color:#f92672">(&lt;/span>int&lt;span style="color:#f92672">)&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>现阶段，可用的参数只有一个：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>&lt;strong>conn_tab_bits&lt;/strong> # 设置连接表的大小。&lt;code>默认值：12&lt;/code>。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>该参数控制下面示例中 size 的大小，2 的 12 次方，4096&lt;/p>
&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>root@lichenhao:~# ipvsadm -ln
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>IP Virtual Server version 1.2.1 &lt;span style="color:#f92672">(&lt;/span>size&lt;span style="color:#f92672">=&lt;/span>4096&lt;span style="color:#f92672">)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Prot LocalAddress:Port Scheduler Flags
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> -&amp;gt; RemoteAddress:Port Forward Weight ActiveConn InActConn
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>IPVS connection hash table size，该表用于记录每个进来的连接及路由去向的信息（这个和 iptables 跟踪表类似）。连接的 Hash 表要容纳几百万个并发连接，任何一个报文到达都需要查找连接 Hash 表。Hash 表的查找复杂度为 O(n/m)，其中 n 为 Hash 表中对象的个数，m 为 Hash 表的桶个数。当对象在 Hash 表中均匀分布和 Hash 表的桶个数与对象个数一样多时，Hash 表的查找复杂度可以接近 O(1)&lt;/p>
&lt;p>连接跟踪表中，每行称为一个 hash bucket（hash 桶），桶的个数是一个固定的值 CONFIG_IP_VS_TAB_BITS，默认为 12（2 的 12 次方，4096）。这个值可以调整，该值的大小应该在 8 到 20 之间。&lt;/p>
&lt;p>LVS 的调优建议将 hash table 的值设置为不低于并发连接数。例如，并发连接数为 200，Persistent 时间为 200S，那么 hash 桶的个数应设置为尽可能接近 200x200=40000，2 的 15 次方为 32768 就可以了。当 ip_vs_conn_tab_bits=20 时，哈希表的的大小（条目）为 pow(2,20)，即 1048576。&lt;/p>
&lt;p>这里的 hash 桶的个数，并不是 LVS 最大连接数限制。LVS 使用哈希链表解决“哈希冲突”，当连接数大于这个值时，必然会出现哈稀冲突，会（稍微）降低性能，但是并不对在功能上对 LVS 造成影响。&lt;/p>
&lt;p>修改模块参数：echo &amp;ldquo;options ip_vs conn_tab_bits=22&amp;rdquo; &amp;gt; /etc/modprobe.d/ip_vs.conf，效果如下：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>IP Virtual Server version 1.2.1 &lt;span style="color:#f92672">(&lt;/span>size&lt;span style="color:#f92672">=&lt;/span>4194304&lt;span style="color:#f92672">)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Prot LocalAddress:Port Scheduler Flags
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> -&amp;gt; RemoteAddress:Port Forward Weight ActiveConn InActConn
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>TCP 10.10.9.60:30000 rr persistent &lt;span style="color:#ae81ff">30&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> -&amp;gt; 10.10.9.69:30000 Route &lt;span style="color:#ae81ff">1&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> -&amp;gt; 10.10.9.70:30000 Route &lt;span style="color:#ae81ff">1&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div></description></item><item><title>Docs: KVM/QEMU</title><link>https://desistdaydream.github.io/docs/IT%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/10.%E4%BA%91%E5%8E%9F%E7%94%9F/1.2.%E5%AE%9E%E7%8E%B0%E8%99%9A%E6%8B%9F%E5%8C%96%E7%9A%84%E5%B7%A5%E5%85%B7/KVM_QEMU/KVM_QEMU/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/IT%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/10.%E4%BA%91%E5%8E%9F%E7%94%9F/1.2.%E5%AE%9E%E7%8E%B0%E8%99%9A%E6%8B%9F%E5%8C%96%E7%9A%84%E5%B7%A5%E5%85%B7/KVM_QEMU/KVM_QEMU/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://www.linux-kvm.org/page/Main_Page">KVM 官网&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://ubuntu.com/server/docs/virtualization-qemu">Ubuntu 官方文档，虚拟化-qemu&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;h2 id="kvm-背景">KVM 背景&lt;/h2>
&lt;p>&lt;strong>Kernel-based Virtual Machine(基于内核的虚拟化机器，简称 KVM)&lt;/strong>， 是 Linux 的一个内核模块，就叫 &lt;strong>kvm&lt;/strong>，只用于管理虚拟 CPU 和内存。该内核模块使得 Linux 变成了一个 Hypervisor。&lt;/p>
&lt;ul>
&lt;li>它由 Quramnet 开发，该公司于 2008 年&lt;strong>被 Red Hat 收购&lt;/strong>。&lt;/li>
&lt;li>它支持 x86 (32 and 64 位), s390, Powerpc 等 CPU。&lt;/li>
&lt;li>它从 Linux 2.6.20 起就作为一模块被包含在 Linux 内核中。&lt;/li>
&lt;li>它需要支持虚拟化扩展的 CPU。&lt;/li>
&lt;li>它是完全开源的。&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/zuowkm/1616124035086-2c826a6e-2fd2-402b-babd-06bfe2380e3d.png" alt="">&lt;/p>
&lt;p>KVM 实际是 Linux 内核提供的虚拟化架构，可将内核直接充当 Hypervisor 来使用。KVM 需要宿主机的 CPU 本身支持虚拟化扩展，如 intel VT 和 AMD AMD-V 技术。KVM 自 2.6.20 版本后已合入主干并发行。除了支持 x86 的处理器，同时也支持 S/390,PowerPC,IA-61 以及 ARM 等平台。&lt;/p>
&lt;p>KVM 包含包含两个内核模块&lt;/p>
&lt;ol>
&lt;li>kvm 用来实现核心虚拟化功能&lt;/li>
&lt;li>kvm-intel # 与处理器强相关的模块&lt;/li>
&lt;/ol>
&lt;p>KVM 本身只提供了 CPU 和 Memory 的虚拟化，并暴露了一个 &lt;strong>&lt;code>/dev/kvm&lt;/code>&lt;/strong> 设备，以供宿主机上的用户空间的程序访问(比如 下文提到的 QEMU)。用户空间的程序通过 &lt;strong>/dev/kvm&lt;/strong> 接口可以实现多种功能&lt;/p>
&lt;h2 id="qemu-背景">QEMU 背景&lt;/h2>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://www.qemu.org/">QEMU 官网&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>QEMU 是一个通过软件实现的完全虚拟化程序，通过动态二进制转换来模拟 CPU，并模拟一系列的硬件，使虚拟机认为自己和硬件直接打交道，其实是同 QEMU 模拟出来的硬件打交道，QEMU 再将这些指令翻译给真正硬件进行操作。通过这种模式，虚拟机可以和主机上的硬盘，网卡，CPU，CD-ROM，音频设备和 USB 设备进行交互。但由于所有指令都需要经过 QEMU 来翻译，因而性能会比较差&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/zuowkm/1616124035102-78899618-45f3-4dcc-9de1-9c80ecd532cb.jpeg" alt="">&lt;/p>
&lt;h2 id="kvmqemu-诞生">KVM/QEMU 诞生&lt;/h2>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/zuowkm/1616124035098-45602829-f8bc-4f49-b65d-56b8dba6c466.png" alt="图片来源：RedHat8 Virtualization Architecture 在 KVM/QEMU Storage Stack Performance Discussion 这篇文章中，作者还画了一个非常形象的图，可以作为参考，下面缩小的图就是" title="图片来源：RedHat8 Virtualization Architecture 在 KVM/QEMU Storage Stack Performance Discussion 这篇文章中，作者还画了一个非常形象的图，可以作为参考，下面缩小的图就是">&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/zuowkm/1616124035057-cdeb1319-ee83-4674-99c3-70a16da96211.jpeg" alt="">&lt;/p>
&lt;p>从前面的背景介绍可知，KVM 实现了 CPU 和 Memory 的虚拟化，但 KVM 并不能模拟其他设备，所以需要其他东西来支持其他设备的模拟；而 QEMU 是通过纯软件实现的一套完整的虚拟化，但是性能非常低下。所以 KVM 与 QEMU 天然得相辅相成，KVM 的开发者选择了比较成熟的开源虚拟化软件 QEMU 来模拟 I/O 设备(网卡，磁盘等)，最后形成了 KVM/QEMU。&lt;/p>
&lt;p>在 KVM/QEMU 中，KVM 运行在内核空间，QEMU 运行在用户空间，实际模拟创建、管理各种虚拟硬件，QEMU 将 KVM 整合了进来，通过 ioctl() 系统调用来调用 /dev/kvm 设备，从而将 CPU 指令的部分交给内核模块来做，KVM 实现了 CPU 和 Memory 的虚拟化，QEMU 模拟 IO 设备(磁盘，网卡，显卡等)，KVM 加上 QEMU 后就是完整意义上的服务器虚拟化。&lt;/p>
&lt;p>综上所述，QEMU-KVM 具有两大作用：&lt;/p>
&lt;ul>
&lt;li>KVM 负责 cpu，内存 的虚拟&lt;/li>
&lt;li>QEMU 负责 I/O 设备 的模拟。比如显卡、PCI、USB、声卡、网卡、存储设备等等。&lt;/li>
&lt;/ul>
&lt;h2 id="结语">结语&lt;/h2>
&lt;p>QEMU-KVM，是 QEMU 的一个特定于 KVM 加速模块的分支，里面包含了很多关于 KVM 的特定代码，与 KVM 模块一起配合使用。&lt;/p>
&lt;p>目前 QEMU-KVM 已经与 QEMU 合二为一，所有特定于 KVM 的代码也都合入了 QEMU，当需要与 KVM 模块配合使用的时候，只需要在 QEMU 命令行加上 &amp;ndash;enable-kvm 就可以。&lt;/p>
&lt;h1 id="kvmqeum-虚拟化实现原理">KVM/QEUM 虚拟化实现原理&lt;/h1>
&lt;p>KVM/QEMU 主要通过以下组件来实现完整的虚拟化功能&lt;/p>
&lt;ul>
&lt;li>&lt;strong>kvm.ko.xz&lt;/strong> # kvm 内核模块。用来模拟 CPU 与 RAM。&lt;/li>
&lt;li>&lt;strong>/dev/kvm&lt;/strong> # 一个字符设备(也是一个接口)。供用户空间的程序使用 &lt;code>ioctl()&lt;/code> 系统调用来访问 kvm 模块&lt;/li>
&lt;li>&lt;strong>qemu-system&lt;/strong> # 一个二进制文件。用来调用 &lt;code>/dev/kvm&lt;/code> 设备，并为虚拟机模拟各种 I/O 设备。qemu-system 也是最基本的用于创建虚拟机的命令行工具。&lt;/li>
&lt;/ul>
&lt;p>KVM/QEMU 通过 &lt;a href="docs/IT%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/10.%E4%BA%91%E5%8E%9F%E7%94%9F/1.2.%E5%AE%9E%E7%8E%B0%E8%99%9A%E6%8B%9F%E5%8C%96%E7%9A%84%E5%B7%A5%E5%85%B7/KVM_QEMU/KVM_QEMU%20%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%B7%A5%E5%85%B7/qemu-img.md">qemu-img 命令行工具&lt;/a>来创建 VM 文件。&lt;a href="docs/IT%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/10.%E4%BA%91%E5%8E%9F%E7%94%9F/1.2.%E5%AE%9E%E7%8E%B0%E8%99%9A%E6%8B%9F%E5%8C%96%E7%9A%84%E5%B7%A5%E5%85%B7/KVM_QEMU/KVM_QEMU%20%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%B7%A5%E5%85%B7/qemu-system.md">qemu-system&lt;/a> 程序使用 /dev/kvm 接口来调用 kvm 模块，以运行 VM。qemu-kvm 和 qemu-system 两个工具也是创建与运行 VM 的最基础工具。&lt;/p>
&lt;p>使用 /dev/kvm 接口的 qemu-system 程序可以提供如下能力：&lt;/p>
&lt;ul>
&lt;li>设置 VM 的地址空间。宿主机必须提供固件镜像(通常为模拟出来的 BIOS)以便让 VM 可以引导到 操作系统中&lt;/li>
&lt;li>为 VM 模拟 I/O 设备。&lt;/li>
&lt;li>将 VM 的视频显示映射回宿主机上。&lt;/li>
&lt;/ul>
&lt;h2 id="virtualization-cpu--memory">Virtualization CPU &amp;amp;&amp;amp; Memory&lt;/h2>
&lt;h3 id="cpu-虚拟化">CPU 虚拟化&lt;/h3>
&lt;p>QEMU 创建 CPU 线程，在初始化的时候设置好相应的虚拟 CPU 寄存器的值，然后调用 KVM 的接口，运行虚拟机，在物理 CPU 上执行虚拟机代码。&lt;/p>
&lt;p>在虚拟机运行时，KVM 会截获虚拟机中的敏感指令，当虚拟机中的代码是敏感指令或者满足了一定的退出条件时，CPU 会从 VMX non-root 模式退出到 KVM，这就是下图的 VM exit。虚拟机的退出首先陷入到 KVM 进行处理，但是如果遇到 KVM 无法处理的事件，比如虚拟机写了设备的寄存器地址，那么 KVM 就会将这个操作交给 QEMU 处理。当 QEMU/KVM 处理好了退出事件后，又会将 CPU 置于 VMX non-root 模式，也就是下图的 VM Entry。&lt;/p>
&lt;p>KVM 使用 VMCS 结构来保存 VM Exit 和 VM Entry
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/zuowkm/1616124035076-0336490e-7922-482c-91be-ee6b0a2ba562.png" alt="">&lt;/p>
&lt;h3 id="memory-虚拟化">Memory 虚拟化&lt;/h3>
&lt;p>QEMU 初始化时调用 KVM 接口告知 KVM，虚拟机所需要的物理内存，通过 mmap 分配宿主机的虚拟内存空间作为虚拟机的物理内存，QEMU 在更新内存布局时会持续调用 KVM 通知内核 KVM 模块虚拟机的内存分布。&lt;/p>
&lt;p>在 CPU 支持 EPT（拓展页表）后，CPU 会自动完成&lt;strong>虚拟机物理地址&lt;/strong>到&lt;strong>宿主机物理地址&lt;/strong>的转换。虚拟机第一次访问内存的时候会陷入 KVM，KVM 逐渐建立起 EPT 页面。这样后续的虚拟机的虚拟 CPU 访问虚拟机&lt;strong>虚拟内存地址&lt;/strong>时，会先被转换为&lt;strong>虚拟机物理地址&lt;/strong>，接着查找 EPT 表，获取宿主机物理地址
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/zuowkm/1616124035074-4de2d638-b8fb-499c-a1de-92ce5e6a10b3.png" alt="">&lt;/p>
&lt;h2 id="paravirtualized-devices半虚拟化设备">Paravirtualized Devices(半虚拟化设备)&lt;/h2>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://www.qemu.org/docs/master/system/device-emulation.html">官方文档，系统模拟-设备模拟&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/7/html/virtualization_getting_started_guide/sec-virtualization_getting_started-products-virtualized-hardware-devices#sec-Virtualization_Getting_Started-Products-paravirtdevices">RedHat7 虚拟化硬件设备章节中的半虚拟化章节&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>半虚拟化设备，就是 Qemu 模拟的各种 I/O 设备&lt;/p>
&lt;p>在 QEMU/KVM 早期模拟其他的硬件(如存储、网络设备)性能不足。为了提高 IO 设备性能，所以产生了 &lt;strong>Paravirtualized Devices(半虚拟化设备)&lt;/strong>，Paravirtualized(半虚拟化) 为 VM 使用宿主机上的设备提供了&lt;strong>快速且高效的通讯方式&lt;/strong>。KVM/QEMU 使用 &lt;strong>Virtio API&lt;/strong> 作为 VM 与 Hypervisor 的中间层，以便为 VM 提供 Paravirtualized Devices(半虚拟化设备)。&lt;/p>
&lt;blockquote>
&lt;p>一些半虚拟化设备可以有效减少 I/O 的延迟，并把 I/O 的吞吐量提高至接近裸机的水平。&lt;/p>
&lt;/blockquote>
&lt;p>所有 &lt;strong>Virtio&lt;/strong> 设备都&lt;strong>由两部分组成&lt;/strong>：&lt;/p>
&lt;ul>
&lt;li>&lt;strong>Host Device&lt;/strong> # 宿主机设备
&lt;ul>
&lt;li>也称为 &lt;strong>Device Back End(后端设备)&lt;/strong>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>Guest Device&lt;/strong> # 虚拟机设备
&lt;ul>
&lt;li>也称为 &lt;strong>Device Front End(前端设备)&lt;/strong>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>Paravirtualizd device driver(半虚拟化设备驱动) 可以让 VM 直接访问宿主机上的物理硬件设备。
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/zuowkm/1616124035106-08438d88-b937-43b9-af1c-01ddb6771941.jpeg" alt="">
现阶段有多种半虚拟化设备可供使用&lt;/p>
&lt;ul>
&lt;li>virtio-net(半虚拟化网络设备) # 半虚拟化网络设备是一种虚拟网络设备，可通过增加的 I/O 性能和较低的延迟为虚拟机提供网络访问。&lt;/li>
&lt;li>virtio-blk(半虚拟化块设备) # 半虚拟化块设备是一种高性能的虚拟存储设备，可为虚拟机提供更高的 I / O 性能和更低的延迟。 虚拟机管理程序支持半虚拟化的块设备，该设备已连接到虚拟机（必须仿真的软盘驱动器除外）。&lt;/li>
&lt;li>virtio-scsi(半虚拟化控制器设备) # 半虚拟化 SCSI 控制器设备是一种更为灵活且可扩展的 virtio-blk 替代品。virtio-scsi 客机能继承目标设备的各种特征，并且能操作几百个设备，相比之下，virtio-blk 仅能处理 28 台设备。&lt;/li>
&lt;li>半虚拟化时钟&lt;/li>
&lt;li>virtio-serial(半虚拟化串口设备) #&lt;/li>
&lt;li>virtio-ballon(气球设备) # 气球（ballon）设备可以指定虚拟机的部分内存为没有被使用（这个过程被称为气球“&lt;em>充气&lt;/em> ” — inflation），从而使这部分内存可以被主机（或主机上的其它虚拟机）使用。当虚拟机这部分内存时，气球可以进行“&lt;em>放气&lt;/em> ”（deflated），主机就会把这部分内存重新分配给虚拟机。&lt;/li>
&lt;li>virtio-rng(半虚拟化随机数生成器)&lt;/li>
&lt;li>QXL(半虚拟化显卡) # 半虚拟化显卡与 QXL 驱动一同提供了一个有效地显示来自远程主机的虚拟机图形界面。SPICE 需要 QXL 驱动。&lt;/li>
&lt;/ul>
&lt;h3 id="创建虚拟机示例">创建虚拟机示例&lt;/h3>
&lt;p>qemu-kvm 命令中的 &lt;code>-device&lt;/code> 选项用于指定前端设备，比如 网卡、磁盘、usb 等等。而 &lt;code>-XXXXdev&lt;/code>等选项则是为了指定宿后端设备。比如宿主机上的文件、socket 等等&lt;/p>
&lt;p>qemu-kvm 使用 &lt;code>-device&lt;/code> 选项指定的参数将这些模拟出来的硬件设备，通过 ID 关联到&lt;code>-XXXdev&lt;/code>定的宿主机文件上。&lt;/p>
&lt;p>而在新版，则使用了更简单的方式，通过一个选项，来直接指定半虚拟化的两端设备，比如使用 &lt;code>-drive&lt;/code> 代替 &lt;code>-device&lt;/code> 和 &lt;code>-blockdev&lt;/code>、使用 &lt;code>-nic&lt;/code> 代替 &lt;code>-device&lt;/code> 和 &lt;code>-netdev&lt;/code> 等等。&lt;/p>
&lt;p>比如下面的示例：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>qemu-system-x86_64 -m &lt;span style="color:#ae81ff">4096&lt;/span> -smp &lt;span style="color:#ae81ff">2&lt;/span> -name test &lt;span style="color:#ae81ff">\
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">&lt;/span>&lt;span style="color:#75715e"># 模拟块设备&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># -drive 使新版选项，是 -blockdev 和 -device 两个参数的集合，可以模拟一个块设备&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># Host Device 为 /var/lib/libvirt/images/test-2.bj-net.qcow2&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># Guest Device 为 virtio-blk 设备&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>-drive file&lt;span style="color:#f92672">=&lt;/span>/var/lib/libvirt/images/test-2.bj-net.qcow2,format&lt;span style="color:#f92672">=&lt;/span>qcow2,if&lt;span style="color:#f92672">=&lt;/span>virtio &lt;span style="color:#ae81ff">\
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">&lt;/span>-vnc :3 &lt;span style="color:#ae81ff">\
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">&lt;/span>&lt;span style="color:#75715e"># 模拟网卡&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># -netdev 指定 Host Device(宿主机设备) 为 tap 类型的网络设备&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># -device 指定 Guest Device(虚拟机设备) 为 virtio-net 设备&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>-netdev tap,id&lt;span style="color:#f92672">=&lt;/span>n1 &lt;span style="color:#ae81ff">\
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">&lt;/span>-device virtio-net,netdev&lt;span style="color:#f92672">=&lt;/span>n1 &lt;span style="color:#ae81ff">\
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">&lt;/span>&lt;span style="color:#75715e"># 模拟串口&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># -chardev 指定 Host Device(宿主机设备)为 socket&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># -device 指定 Guest Device(虚拟机设备)为 virtio-serial&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># virtserialport 是 virtio-serial-port 的意思&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>-chardev socket,path&lt;span style="color:#f92672">=&lt;/span>/tmp/qga.sock,server,nowait,id&lt;span style="color:#f92672">=&lt;/span>qga0 &lt;span style="color:#ae81ff">\
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">&lt;/span>-device virtio-serial &lt;span style="color:#ae81ff">\
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">&lt;/span>-device virtserialport,chardev&lt;span style="color:#f92672">=&lt;/span>qga0,name&lt;span style="color:#f92672">=&lt;/span>org.qemu.guest_agent.0
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>可以看到，所有通过 -device 选项在 VM 中模拟的硬件设备，都会根据 ID 关联到宿主机的某个文件或者设备上。&lt;/p>
&lt;p>而且还有一个 -drive 选项这种更简单的使用方式，来免去设定 ID 的困扰，并且输入的字符更少。&lt;/p>
&lt;h2 id="总结一下">总结一下&lt;/h2>
&lt;p>KVM/QEMU 虚拟化环境中，除了 CPU 与 Memory 是通过 KVM 虚拟化的，其他所有硬件设备，都是通过 QEMU 模拟出来，并且，要想让模拟出来的硬件设备能正常工作(模拟的硬件与宿主机交互)，则还需要在宿主机上创建与之关联的文件。所以，一共两部分来实现 QEMU 的模拟功能。&lt;/p>
&lt;ol>
&lt;li>&lt;strong>一部分是 QEMU 在 VM 中模拟出来的各种硬件&lt;/strong>&lt;/li>
&lt;li>&lt;strong>另一部分是在宿主机中与 VM 中模拟出来的硬件对应的各种文件或设备&lt;/strong>。&lt;/li>
&lt;/ol>
&lt;p>这两部分共同实现了 VM 中模拟的硬件与宿主机交互的能力。如果 VM 中的硬件与宿主机无法交互，那么是无法使用滴~~~&lt;/p>
&lt;h1 id="不同-cpu-架构的模拟">不同 CPU 架构的模拟&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://www.qemu.org/docs/master/system/targets.html">官方文档，系统模拟-QEMU 系统模拟目标&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>QEMU 是一个通用的模拟器，它可以模拟很多机器。qemu-system 工具的大多数选项对于所有机器都是相似的。以下各节将提及有关各种目标的具体信息。&lt;/p>
&lt;p>&lt;a href="https://www.qemu.org/docs/master/system/target-arm.html">Arm 系统模拟&lt;/a>&lt;/p>
&lt;h2 id="todo-不同-cpu-架构之间的互相模拟">TODO: 不同 CPU 架构之间的互相模拟&lt;/h2>
&lt;p>这个可以实现吗？amd 机器上开 arm 的虚拟机，或者 arm 机器上开 amd 的虚拟机&lt;/p></description></item><item><title>Docs: Label and Selector(标签和选择器)</title><link>https://desistdaydream.github.io/docs/IT%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/10.%E4%BA%91%E5%8E%9F%E7%94%9F/2.3.Kubernetes-%E5%AE%B9%E5%99%A8%E7%BC%96%E6%8E%92%E7%B3%BB%E7%BB%9F/1.API-Resource-%E4%B8%8E-Object/Object-%E7%AE%A1%E7%90%86/Label-and-Selector%E6%A0%87%E7%AD%BE%E5%92%8C%E9%80%89%E6%8B%A9%E5%99%A8/Label-and-Selector%E6%A0%87%E7%AD%BE%E5%92%8C%E9%80%89%E6%8B%A9%E5%99%A8/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/IT%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/10.%E4%BA%91%E5%8E%9F%E7%94%9F/2.3.Kubernetes-%E5%AE%B9%E5%99%A8%E7%BC%96%E6%8E%92%E7%B3%BB%E7%BB%9F/1.API-Resource-%E4%B8%8E-Object/Object-%E7%AE%A1%E7%90%86/Label-and-Selector%E6%A0%87%E7%AD%BE%E5%92%8C%E9%80%89%E6%8B%A9%E5%99%A8/Label-and-Selector%E6%A0%87%E7%AD%BE%E5%92%8C%E9%80%89%E6%8B%A9%E5%99%A8/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/">官方文档,概念-使用 Kubernetes 对象-标签和选择器&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://kubernetes.io/docs/concepts/overview/working-with-objects/common-labels/">官方文档,概念-使用 Kubernetes 对象-推荐的标签&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://kubernetes.io/docs/reference/labels-annotations-taints/">官方文档,参考-常见的内置标签、注释、污点&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://kubernetes.io/docs/reference/kubernetes-api/common-definitions/label-selector/">官方文档,参考-Kubernets API-通用定义-标签选择器&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://kubernetes.io/docs/reference/kubernetes-api/common-definitions/node-selector-requirement/">官方文档,参考-Kubernets API-通用定义-节点选择器请求&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>&lt;strong>Label(标签)&lt;/strong> 是 &lt;code>键/值对&lt;/code> 的集合，在 Kubernetes 中，每一个对象都可以具有一个或多个 &lt;strong>Label(标签)&lt;/strong>。Label 主要用来让用户定义对象的属性，以便为所有对象进行分类，并且还可以组织和选择对象的子集。标签可以在创建对象的同时添加，也可以随时修改对象上的标签。&lt;/p>
&lt;p>Kubernetes 中的 Label 功能与 时间序列数据 中标签功能有异曲同工之妙，说白了，就是用来描述一个东西的。而且通过 Label，我们可以以松耦合的方式将我们自己想要的组织方式组织集群中的 Pod，而并不需要自己维护这些。&lt;/p>
&lt;p>&lt;strong>Kubernetes 中标签概念的重要性不亚于 API 资源和对象的概念。Pod 要运行在哪个 Node 上、下文将会提到的标签选择器，以及 Kubernetes 的调度系统等等等等，想要实现这些功能，都要依赖于标签。&lt;/strong>&lt;/p>
&lt;p>&lt;em>标签&lt;/em> 是键值对。有效的标签键有两个段：可选的前缀和名称，用斜杠 &lt;code>/&lt;/code> 分隔。 名称段是必需的，必须小于等于 63 个字符，以字母数字字符（&lt;code>[a-z0-9A-Z]&lt;/code>）开头和结尾， 带有破折号 &lt;code>-&lt;/code>，下划线 &lt;code>_&lt;/code>，点 &lt;code>.&lt;/code> 和之间的字母数字。 前缀是可选的。如果指定，前缀必须是 DNS 子域：由点 &lt;code>.&lt;/code> 分隔的一系列 DNS 标签，总共不超过 253 个字符， 后跟斜杠 &lt;code>/&lt;/code>。&lt;/p>
&lt;p>如果省略前缀，则假定标签键对用户是私有的。 向最终用户对象添加标签的自动系统组件（例如 &lt;code>kube-scheduler&lt;/code>、&lt;code>kube-controller-manager&lt;/code>、 &lt;code>kube-apiserver&lt;/code>、&lt;code>kubectl&lt;/code> 或其他第三方自动化工具）必须指定前缀。&lt;/p>
&lt;p>有效标签值：&lt;/p>
&lt;ul>
&lt;li>必须为 63 个字符或更少（可以为空）&lt;/li>
&lt;li>除非标签值为空，必须以字母数字字符（&lt;code>[a-z0-9A-Z]&lt;/code>）开头和结尾&lt;/li>
&lt;li>包含破折号 &lt;code>-&lt;/code>、下划线 &lt;code>_&lt;/code>、点 &lt;code>.&lt;/code> 和字母或数字。&lt;/li>
&lt;/ul>
&lt;h2 id="集群中特殊的标签">集群中特殊的标签&lt;/h2>
&lt;p>&lt;code>kubernetes.io/&lt;/code>  和 &lt;code>k8s.io/&lt;/code> 前缀是为 Kubernetes 核心组件保留的。&lt;/p>
&lt;p>在每个 master 上都会有这么一个标签 node-role.kubernetes.io/XXXXX=，在使用 kubeclt get nodes 命令时， ROLES 列的值，就是根据该标签的 key 来决定的，key 中 XXXX 的值，会填写到 ROLES 列中。&lt;/p>
&lt;h2 id="一个对象中标签示例">一个对象中标签示例&lt;/h2>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-yaml" data-lang="yaml">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">apiVersion&lt;/span>: &lt;span style="color:#ae81ff">v1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">kind&lt;/span>: &lt;span style="color:#ae81ff">Pod&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">metadata&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">name&lt;/span>: &lt;span style="color:#ae81ff">label-demo&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">labels&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">environment&lt;/span>: &lt;span style="color:#ae81ff">production&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">app&lt;/span>: &lt;span style="color:#ae81ff">nginx&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">spec&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">containers&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#f92672">name&lt;/span>: &lt;span style="color:#ae81ff">nginx&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">image&lt;/span>: &lt;span style="color:#ae81ff">nginx:1.14.2&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">ports&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#f92672">containerPort&lt;/span>: &lt;span style="color:#ae81ff">80&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h1 id="label-selector标签选择器简称-selector">Label Selector(标签选择器，简称 Selector)&lt;/h1>
&lt;p>可以给 kubernetes 中的对象打上标签，然后让某个对象使用 Selector 来选择具有相同标签的对象成为同一组来协调工作或者进行各种限定&lt;/p>
&lt;p>比如具有相同标签的 Pod 和 Node，该 Pod 会使用 Selector 选择在该 Node 上运行，该 Pod 对该 Node 具有倾向性；或者把具有相同标签的 Service 和 Pod 关联起来，使 Service 使用 Selector 知道可以选择哪些 Pod 来进行调度&lt;/p>
&lt;p>说白了，所谓的 Selector 就是根据给定的规则对标签进行匹配，凡是带有匹配到的标签的资源，都会被选择器选中。&lt;/p>
&lt;p>标签选择器可以用在下面这些资源的字段中：&lt;/p>
&lt;ul>
&lt;li>各种控制器
&lt;ul>
&lt;li>.spec.selector&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>pod
&lt;ul>
&lt;li>.spec.affinity.所有亲和类型.软/硬规则.nodeSelectorTerms&lt;/li>
&lt;li>.spec.nodeSelector&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>service
&lt;ul>
&lt;li>.spec.selector&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>等等&lt;/li>
&lt;/ul>
&lt;h2 id="selector-manifest">Selector Manifest&lt;/h2>
&lt;p>选择器的 Manifest 字段及其写法详见 &lt;a href="https://desistdaydream.github.io/docs/IT%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/10.%E4%BA%91%E5%8E%9F%E7%94%9F/2.3.Kubernetes%20%E5%AE%B9%E5%99%A8%E7%BC%96%E6%8E%92%E7%B3%BB%E7%BB%9F/1.API%20Resource%20%E4%B8%8E%20Object/API%20%E5%8F%82%E8%80%83/Common%20Definitions(%E9%80%9A%E7%94%A8%E5%AE%9A%E4%B9%89)/LabelSelector.md">API 参考-LabelSelector&lt;/a>&lt;/p>
&lt;h1 id="label-的使用方式">Label 的使用方式&lt;/h1>
&lt;h2 id="api">API&lt;/h2>
&lt;h3 id="list-和-watch-过滤">LIST 和 WATCH 过滤&lt;/h3>
&lt;p>LIST 和 WATCH 操作可以使用查询参数指定标签选择算符过滤一组对象。 两种需求都是允许的。（这里显示的是它们出现在 URL 查询字符串中）&lt;/p>
&lt;ul>
&lt;li>&lt;em>基于等值&lt;/em> 的需求: &lt;code>?labelSelector=environment%3Dproduction,tier%3Dfrontend&lt;/code>&lt;/li>
&lt;li>&lt;em>基于集合&lt;/em> 的需求: &lt;code>?labelSelector=environment+in+%28production%2Cqa%29%2Ctier+in+%28frontend%29&lt;/code>&lt;/li>
&lt;/ul>
&lt;p>两种标签选择算符都可以通过 REST 客户端用于 list 或者 watch 资源。 例如，使用 &lt;code>kubectl&lt;/code> 定位 &lt;code>apiserver&lt;/code>，可以使用 &lt;em>基于等值&lt;/em> 的标签选择算符可以这么写：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>kubectl get pods -l environment&lt;span style="color:#f92672">=&lt;/span>production,tier&lt;span style="color:#f92672">=&lt;/span>frontend
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>或者使用 &lt;em>基于集合的&lt;/em> 需求：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>kubectl get pods -l &lt;span style="color:#e6db74">&amp;#39;environment in (production),tier in (frontend)&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>正如刚才提到的，&lt;em>基于集合&lt;/em> 的需求更具有表达力。例如，它们可以实现值的 &lt;em>或&lt;/em> 操作：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>kubectl get pods -l &lt;span style="color:#e6db74">&amp;#39;environment in (production, qa)&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>或者通过 &lt;em>exists&lt;/em> 运算符限制不匹配：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>kubectl get pods -l &lt;span style="color:#e6db74">&amp;#39;environment,environment notin (frontend)&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="在-api-对象中设置引用">在 API 对象中设置引用&lt;/h3>
&lt;p>一些 Kubernetes 对象，例如 &lt;code>[services](https://kubernetes.io/zh/docs/concepts/services-networking/service/)&lt;/code> 和 &lt;code>[replicationcontrollers](https://kubernetes.io/zh/docs/concepts/workloads/controllers/replicationcontroller/)&lt;/code> ， 也使用了标签选择算符去指定了其他资源的集合，例如 &lt;a href="https://kubernetes.io/zh/docs/concepts/workloads/pods/">pods&lt;/a>。&lt;/p>
&lt;h4 id="service-和-replicationcontroller">Service 和 ReplicationController&lt;/h4>
&lt;p>一个 &lt;code>Service&lt;/code> 指向的一组 Pods 是由标签选择算符定义的。同样，一个 &lt;code>ReplicationController&lt;/code> 应该管理的 pods 的数量也是由标签选择算符定义的。
两个对象的标签选择算符都是在 &lt;code>json&lt;/code> 或者 &lt;code>yaml&lt;/code> 文件中使用映射定义的，并且只支持 &lt;em>基于等值&lt;/em> 需求的选择算符：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-json" data-lang="json">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">&amp;#34;selector&amp;#34;&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">:&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;component&amp;#34;&lt;/span> : &lt;span style="color:#e6db74">&amp;#34;redis&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>或者&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-yaml" data-lang="yaml">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">selector&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">component&lt;/span>: &lt;span style="color:#ae81ff">redis&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>这个选择算符(分别在 &lt;code>json&lt;/code> 或者 &lt;code>yaml&lt;/code> 格式中) 等价于 &lt;code>component=redis&lt;/code> 或 &lt;code>component in (redis)&lt;/code> 。&lt;/p>
&lt;h4 id="支持基于集合需求的资源">支持基于集合需求的资源&lt;/h4>
&lt;p>比较新的资源，例如 &lt;code>[Job](https://kubernetes.io/zh/docs/concepts/workloads/controllers/job/)&lt;/code>、 &lt;code>[Deployment](https://kubernetes.io/zh/docs/concepts/workloads/controllers/deployment/)&lt;/code>、 &lt;code>[Replica Set](https://kubernetes.io/zh/docs/concepts/workloads/controllers/replicaset/)&lt;/code> 和 &lt;code>[DaemonSet](https://kubernetes.io/zh/docs/concepts/workloads/controllers/daemonset/)&lt;/code> ， 也支持 &lt;em>基于集合的&lt;/em> 需求。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-yaml" data-lang="yaml">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">selector&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">matchLabels&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">component&lt;/span>: &lt;span style="color:#ae81ff">redis&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">matchExpressions&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - { &lt;span style="color:#f92672">key: tier, operator: In, values&lt;/span>: [&lt;span style="color:#ae81ff">cache] }&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - { &lt;span style="color:#f92672">key: environment, operator: NotIn, values&lt;/span>: [&lt;span style="color:#ae81ff">dev] }&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;code>matchLabels&lt;/code> 是由 &lt;code>{key,value}&lt;/code> 对组成的映射。 &lt;code>matchLabels&lt;/code> 映射中的单个 &lt;code>{key,value }&lt;/code> 等同于 &lt;code>matchExpressions&lt;/code> 的元素， 其 &lt;code>key&lt;/code> 字段为 &amp;ldquo;key&amp;rdquo;，&lt;code>operator&lt;/code> 为 &amp;ldquo;In&amp;rdquo;，而 &lt;code>values&lt;/code> 数组仅包含 &amp;ldquo;value&amp;rdquo;。 &lt;code>matchExpressions&lt;/code> 是 Pod 选择算符需求的列表。 有效的运算符包括 &lt;code>In&lt;/code>、&lt;code>NotIn&lt;/code>、&lt;code>Exists&lt;/code> 和 &lt;code>DoesNotExist&lt;/code>。 在 &lt;code>In&lt;/code> 和 &lt;code>NotIn&lt;/code> 的情况下，设置的值必须是非空的。 来自 &lt;code>matchLabels&lt;/code> 和 &lt;code>matchExpressions&lt;/code> 的所有要求都按逻辑与的关系组合到一起 &amp;ndash; 它们必须都满足才能匹配。&lt;/p>
&lt;h4 id="选择节点集">选择节点集&lt;/h4>
&lt;p>通过标签进行选择的一个用例是确定节点集，方便 Pod 调度。 有关更多信息，详见 &lt;a href="https://www.yuque.com/go/doc/33166071">让 Pod 运行在指定 Node&lt;/a> 章节。&lt;/p>
&lt;h1 id="使用-kubectl-命令控制标签">使用 kubectl 命令控制标签&lt;/h1>
&lt;h2 id="syntax语法">Syntax(语法)&lt;/h2>
&lt;p>&lt;strong>kubectl label [&amp;ndash;overwrite] (-f FILENAME | TYPE NAME) KEY_1=VAL_1 &amp;hellip; KEY_N=VAL_N [&amp;ndash;resource-version=version] [options]&lt;/strong>&lt;/p>
&lt;p>在 get 子命令中，&lt;code>--show-label&lt;/code> 标志还可以显示获取到的对象的所有标签；&lt;code>-l&lt;/code> 标签可以根据表达式来过滤想要获取的对象&lt;/p>
&lt;h2 id="example">EXAMPLE&lt;/h2>
&lt;ul>
&lt;li>获取所有 node 的标签
&lt;ul>
&lt;li>&lt;strong>kubectl get node &amp;ndash;show-labels&lt;/strong>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>为 node-1.bj-test 节点添加名为 &lt;code>node-role.kubernetes.io/proxy&lt;/code> 的标签，标签值为 &lt;code>ingress-controller&lt;/code>
&lt;ul>
&lt;li>&lt;strong>kubectl label nodes test-node-4 node-role.kubernetes.io/proxy=ingress-controller&lt;/strong>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>将 node-1.bj-test 节点上的 &lt;code>node-role.kubernetes.io/proxy&lt;/code> 标签删除
&lt;ul>
&lt;li>&lt;strong>kubectl label nodes node-1.bj-test node-role.kubernetes.io/proxy-&lt;/strong>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>给 k8s-node1 节点添加 disktype=ssd 这个标签
&lt;ul>
&lt;li>&lt;strong>kubectl label node k8s-node1 disktype=ssd&lt;/strong>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>删除 k8s-node1 节点上的 disktype 标签
&lt;ul>
&lt;li>&lt;strong>kubectl label node k8s-node1 disktype-&lt;/strong>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul></description></item><item><title>Docs: Libvirt</title><link>https://desistdaydream.github.io/docs/IT%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/10.%E4%BA%91%E5%8E%9F%E7%94%9F/1.2.%E5%AE%9E%E7%8E%B0%E8%99%9A%E6%8B%9F%E5%8C%96%E7%9A%84%E5%B7%A5%E5%85%B7/%E8%99%9A%E6%8B%9F%E5%8C%96%E7%AE%A1%E7%90%86/Libvirt/Libvirt/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/IT%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/10.%E4%BA%91%E5%8E%9F%E7%94%9F/1.2.%E5%AE%9E%E7%8E%B0%E8%99%9A%E6%8B%9F%E5%8C%96%E7%9A%84%E5%B7%A5%E5%85%B7/%E8%99%9A%E6%8B%9F%E5%8C%96%E7%AE%A1%E7%90%86/Libvirt/Libvirt/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://github.com/libvirt">GitHub 组织，libvirt&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://libvirt.org/">官网&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>Libvirt 是用于管理虚拟化平台的开源的 API，后台程序和管理工具。它可以用于管理 KVM、Xen、VMware ESX，QEMU 和其他虚拟化技术。Libvirt 将虚拟机统一称为 &lt;strong>Domain&lt;/strong>。&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/gglb2f/1616123800173-58542239-2205-4586-bcc0-4edde6579a3f.png" alt="">&lt;/p>
&lt;p>Libvirt 提供了管理虚拟机和其它虚拟化功能（如：存储和网络接口等）的便利途径。这些软件包括：一个长期稳定的 C 语言 API、一个守护进程（libvirtd）和一个命令行工具（virsh）。Libvirt 的主要目标是提供一个单一途径以管理不同类型的虚拟化环境(也称为 drivers 或者 hypervisors )，包括：KVM/QEMU，Xen，VMware， VirtualBox hypervisors，LXC，OpenVZ&lt;/p>
&lt;p>Libvirt 包含 3 个东西：libvirtd、API、virsh&lt;/p>
&lt;ul>
&lt;li>libvirtd # 是守护进程，服务程序，接收和处理 API 请求&lt;/li>
&lt;li>API # 库使得其他人可以开发基于 Libvirt 的高级工具，比如 virt-manager、virt-install、virt-viewer 等。&lt;/li>
&lt;li>virsh # 是我们经常要用的命令行工具&lt;/li>
&lt;/ul>
&lt;p>Note：其实 libvirtd 在绝大部分情况下是与 qemu/kvm 相搭配来使用，都是开源的，并且 redhat 官方推荐的也是使用 libvirt 管理 kvm 虚拟机&lt;/p>
&lt;h2 id="libvirt-原理">Libvirt 原理&lt;/h2>
&lt;p>libvirt 支持不同的虚拟化类型，所以需要一种方法来指定所要连接的虚拟化驱动。&lt;/p>
&lt;p>libvirt 使用 URI 来与各种类型的虚拟化程序连接。官方文档：&lt;a href="https://libvirt.org/uri.html">https://libvirt.org/uri.html&lt;/a>&lt;/p>
&lt;p>libvirt 将使用以下逻辑来确定要使用的 URI。&lt;/p>
&lt;ul>
&lt;li>环境变量 LIBVIRT_DEFAULT_URI&lt;/li>
&lt;li>客户端配置文件 uri_default 参数&lt;/li>
&lt;li>依次探查每个虚拟机监控程序，直到找到有效的虚拟机监控程序&lt;/li>
&lt;/ul>
&lt;h1 id="libvirt-关联文件与配置">Libvirt 关联文件与配置&lt;/h1>
&lt;p>&lt;strong>/etc/libvirt/*&lt;/strong> #&lt;/p>
&lt;ul>
&lt;li>&lt;strong>./libvirt.conf&lt;/strong> # 用于配置用于与虚拟化程序连接的 URI 别名，以及默认 URI&lt;/li>
&lt;li>.&lt;strong>/libvirtd.conf&lt;/strong> # libvirtd 守护进程的配置文件&lt;/li>
&lt;li>.&lt;strong>/qemu/&lt;/strong> # xml 格式的配置文件存放路径，配置文件包括该 VM 的元数据(名字，uuid，内存，cpu 等)，设备配置(包括使用的硬盘文件的路径，网络类型等)，配置文件为 xml 格式。创建完一台 VM 后，会在该目录下生成对应 VM 名字的 xml 文件&lt;/li>
&lt;li>&lt;strong>./network/&lt;/strong> #&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>/etc/sysconfig/&lt;/strong> #&lt;/p>
&lt;ul>
&lt;li>&lt;strong>./libvirtd&lt;/strong> #&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>/var/lib/libvirt/&lt;/strong> #&lt;/p>
&lt;ul>
&lt;li>&lt;strong>./images/&lt;/strong> # 所有通过 libvirt 创建的虚拟机所生成的 images 都保存在该目录下&lt;/li>
&lt;li>&lt;strong>./qemu/snapshot/&lt;/strong> # 创建快照 xml 文件都保存在该目录下&lt;/li>
&lt;/ul>
&lt;h1 id="xml-文件">XML 文件&lt;/h1>
&lt;p>Libvirt 管理的虚拟机都可以通过 XML 文件来描述其所应该模拟的硬件设备、状态等等。详见 &lt;a href="https://desistdaydream.github.io/docs/IT%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/10.%E4%BA%91%E5%8E%9F%E7%94%9F/1.2.%E5%AE%9E%E7%8E%B0%E8%99%9A%E6%8B%9F%E5%8C%96%E7%9A%84%E5%B7%A5%E5%85%B7/%E8%99%9A%E6%8B%9F%E5%8C%96%E7%AE%A1%E7%90%86/Libvirt/XML%20%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3/XML%20%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3.md">XML 文件详解&lt;/a>&lt;/p>
&lt;p>我们甚至可以通过直接编写 XML 文件，以便 Libvirt 相关工具直接读取 XML 并启动 VM。&lt;/p>
&lt;h1 id="nvram-文件">nvram 文件&lt;/h1>
&lt;p>TODO: 这是什么文件？？？？&lt;/p></description></item><item><title>Docs: Linux 管理</title><link>https://desistdaydream.github.io/docs/IT%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/X.Linux-%E7%AE%A1%E7%90%86/Linux%E7%AE%A1%E7%90%86/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/IT%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/X.Linux-%E7%AE%A1%E7%90%86/Linux%E7%AE%A1%E7%90%86/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://www.gnu.org/manual/">GNU Manual(手册)&lt;/a> — Linux 中很多核心程序，都是 GNU 组织下的软件。&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>系统管理员可以通过 一系列用户空间的二进制应用程序来管理 Linux 操作系统。Linux 内核自带了一个名为 coreutils 包，包含了很多最基本的管理工具。&lt;/p>
&lt;p>除了 Coreutils 包，还有很多很多的应用程序，一起组成了一套工具栈，系统管理员可以根据自身的需求，有选择得安装并使用它们。&lt;/p>
&lt;h1 id="coreutils">Coreutils&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/GNU_Core_Utilities">Wiki,GNU Core Utilies&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.gnu.org/software/coreutils/manual/">官方文档&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>GNU Core Utilities 是 GNU 操作系统的基本文件、Shell、文本操作的实用程序。同时，也是现在绝大部分 Linux 发行版内置的实用程序。&lt;/p>
&lt;p>Coreutils 通常可以通过各种 Linux 发行版的包管理器直接安装。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>root@lichenhao:~/downloads# apt-cache show coreutils
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Package: coreutils
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Architecture: amd64
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Version: 8.30-3ubuntu2
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Multi-Arch: foreign
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Priority: required
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Essential: yes
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Section: utils
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Origin: Ubuntu
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Maintainer: Ubuntu Developers &amp;lt;ubuntu-devel-discuss@lists.ubuntu.com&amp;gt;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Original-Maintainer: Michael Stone &amp;lt;mstone@debian.org&amp;gt;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Bugs: https://bugs.launchpad.net/ubuntu/+filebug
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Installed-Size: &lt;span style="color:#ae81ff">7196&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Pre-Depends: libacl1 &lt;span style="color:#f92672">(&lt;/span>&amp;gt;&lt;span style="color:#f92672">=&lt;/span> 2.2.23&lt;span style="color:#f92672">)&lt;/span>, libattr1 &lt;span style="color:#f92672">(&lt;/span>&amp;gt;&lt;span style="color:#f92672">=&lt;/span> 1:2.4.44&lt;span style="color:#f92672">)&lt;/span>, libc6 &lt;span style="color:#f92672">(&lt;/span>&amp;gt;&lt;span style="color:#f92672">=&lt;/span> 2.28&lt;span style="color:#f92672">)&lt;/span>, libselinux1 &lt;span style="color:#f92672">(&lt;/span>&amp;gt;&lt;span style="color:#f92672">=&lt;/span> 2.1.13&lt;span style="color:#f92672">)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Filename: pool/main/c/coreutils/coreutils_8.30-3ubuntu2_amd64.deb
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Size: &lt;span style="color:#ae81ff">1249368&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>MD5sum: e8e201b6d1b7f39776da07f6713e1675
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>SHA1: 1d4ab60c729a361d46a90d92defaca518b2918d2
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>SHA256: 99aa50af84de1737735f2f51e570d60f5842aa1d4a3129527906e7ffda368853
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Homepage: http://gnu.org/software/coreutils
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Description-en: GNU core utilities
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> This package contains the basic file, shell and text manipulation
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> utilities which are expected to exist on every operating system.
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Specifically, this package includes:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> arch base64 basename cat chcon chgrp chmod chown chroot cksum comm cp
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> csplit cut date dd df dir dircolors dirname du echo env expand expr
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> factor false flock fmt fold groups head hostid id install join link ln
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> logname ls md5sum mkdir mkfifo mknod mktemp mv nice nl nohup nproc numfmt
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> od paste pathchk pinky pr printenv printf ptx pwd readlink realpath rm
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> rmdir runcon sha*sum seq shred sleep sort split stat stty sum sync tac
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> tail tee test timeout touch tr true truncate tsort tty uname unexpand
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> uniq unlink users vdir wc who whoami yes
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Description-md5: d0d975dec3625409d24be1238cede238
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Task: minimal
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>这个包中，通常包含如下应用程序&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>arch base64 basename cat chcon chgrp chmod chown chroot cksum comm cp csplit cut date dd df dir dircolors dirname du echo env expand expr factor false flock fmt fold groups head hostid id install join link ln logname ls md5sum mkdir mkfifo mknod mktemp mv nice nl nohup nproc numfmt od paste pathchk pinky pr printenv printf ptx pwd readlink realpath rm rmdir runcon sha*sum seq shred sleep sort split stat stty sum sync tac tail tee test timeout touch tr true truncate tsort tty uname unexpand uniq unlink users vdir wc who whoami yes
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>可以发现，这些命令就是我们日常经常使用那些~&lt;/p>
&lt;h1 id="util-linux">Util-linux&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://github.com/util-linux/util-linux">GitHub 项目，util-linux/util-linux&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Util-linux">Wiki,Util-linux&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>util-linux 是由 Linux 内核组织分发的标准软件包，用作 Linux 操作系统的一部分。一个分支 util-linux-ng（ng 的意思是“下一代”）是在开发停滞时创建的，但截至 2011 年 1 月，它已重命名为 util-linux，并且是该软件包的正式版本。&lt;/p>
&lt;p>Util-linux 包中通常包含如下程序：&lt;/p>
&lt;ul>
&lt;li>addpart&lt;/li>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Getty_(Unix)">agetty&lt;/a>&lt;/li>
&lt;li>blkdiscard&lt;/li>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Blkid">blkid&lt;/a>&lt;/li>
&lt;li>blkzone&lt;/li>
&lt;li>&lt;a href="https://en.wikipedia.org/w/index.php?title=Blockdev&amp;amp;action=edit&amp;amp;redlink=1">blockdev&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Cal_(command)">cal&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Cfdisk">cfdisk&lt;/a>&lt;/li>
&lt;li>chcpu&lt;/li>
&lt;li>chfn&lt;/li>
&lt;li>chmem&lt;/li>
&lt;li>choom&lt;/li>
&lt;li>chrt&lt;/li>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Chsh">chsh&lt;/a>&lt;/li>
&lt;li>col (legacy)&lt;/li>
&lt;li>colcrt&lt;/li>
&lt;li>colrm&lt;/li>
&lt;li>column&lt;/li>
&lt;li>ctrlaltdel&lt;/li>
&lt;li>delpart&lt;/li>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Dmesg">dmesg&lt;/a>&lt;/li>
&lt;li>eject&lt;/li>
&lt;li>fallocate&lt;/li>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Fdformat">fdformat&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Fdisk">fdisk&lt;/a>&lt;/li>
&lt;li>fincore&lt;/li>
&lt;li>findfs&lt;/li>
&lt;li>findmnt&lt;/li>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/File_locking">flock&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Fsck">fsck&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Fsck">fsck&lt;/a>.&lt;a href="https://en.wikipedia.org/wiki/Cramfs">cramfs&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Fsck">fsck&lt;/a>.&lt;a href="https://en.wikipedia.org/wiki/MINIX_file_system">minix&lt;/a>&lt;/li>
&lt;li>fsfreeze&lt;/li>
&lt;li>fstrim&lt;/li>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Getopt">getopt&lt;/a>&lt;/li>
&lt;li>hardlink&lt;/li>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Hex_dump#od_and_hexdump">hexdump&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://en.wikipedia.org/w/index.php?title=Hwclock&amp;amp;action=edit&amp;amp;redlink=1">hwclock&lt;/a> (query and set the hardware clock (RTC))&lt;/li>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Ionice">ionice&lt;/a>&lt;/li>
&lt;li>ipcmk&lt;/li>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Ipcrm">ipcrm&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Ipcs">ipcs&lt;/a>&lt;/li>
&lt;li>irqtop&lt;/li>
&lt;li>isosize&lt;/li>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Kill_(Unix)">kill&lt;/a>&lt;/li>
&lt;li>last&lt;/li>
&lt;li>ldattach&lt;/li>
&lt;li>line (legacy)&lt;/li>
&lt;li>logger&lt;/li>
&lt;li>login&lt;/li>
&lt;li>look&lt;/li>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Losetup">losetup&lt;/a>&lt;/li>
&lt;li>lsblk&lt;/li>
&lt;li>lscpu&lt;a href="https://en.wikipedia.org/wiki/Util-linux#cite_note-8">[8]&lt;/a>&lt;/li>
&lt;li>lsfd&lt;/li>
&lt;li>lsipc&lt;/li>
&lt;li>lsirq&lt;a href="https://en.wikipedia.org/wiki/Util-linux#cite_note-9">[9]&lt;/a>&lt;/li>
&lt;li>lslocks&lt;/li>
&lt;li>lslogins&lt;/li>
&lt;li>lsmem&lt;/li>
&lt;li>lsns&lt;/li>
&lt;li>mcookie&lt;/li>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Mesg">mesg&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Mkfs">mkfs&lt;/a> (legacy)&lt;/li>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Mkfs">mkfs&lt;/a>.&lt;a href="https://en.wikipedia.org/wiki/Boot_File_System">bfs&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Mkfs">mkfs&lt;/a>.&lt;a href="https://en.wikipedia.org/wiki/Cramfs">cramfs&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Mkfs">mkfs&lt;/a>.&lt;a href="https://en.wikipedia.org/wiki/MINIX_file_system">minix&lt;/a>&lt;/li>
&lt;li>mkswap&lt;/li>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/More_(command)">more&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Mount_(Unix)">mount&lt;/a>&lt;/li>
&lt;li>mountpoint&lt;/li>
&lt;li>namei&lt;/li>
&lt;li>newgrp&lt;/li>
&lt;li>nologin&lt;/li>
&lt;li>nsenter&lt;/li>
&lt;li>partx&lt;/li>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Pg_(Unix)">pg&lt;/a> (legacy)&lt;/li>
&lt;li>pivot_root&lt;/li>
&lt;li>prlimit&lt;a href="https://en.wikipedia.org/wiki/Util-linux#cite_note-10">[10]&lt;/a>&lt;/li>
&lt;li>raw&lt;/li>
&lt;li>readprofile&lt;/li>
&lt;li>rename&lt;/li>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Nice_(Unix)">renice&lt;/a>&lt;/li>
&lt;li>reset (legacy)&lt;/li>
&lt;li>resizepart&lt;/li>
&lt;li>rev&lt;/li>
&lt;li>rfkill&lt;/li>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/RTC_Alarm">rtcwake&lt;/a>&lt;/li>
&lt;li>runuser&lt;/li>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Script_(Unix)">script&lt;/a>&lt;/li>
&lt;li>scriptlive&lt;/li>
&lt;li>scriptreplay&lt;/li>
&lt;li>setarch (including architecture symlinks such as i386, linux32, linux64, x86_64, etc.)&lt;/li>
&lt;li>setpriv&lt;/li>
&lt;li>setsid&lt;/li>
&lt;li>setterm&lt;/li>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Sfdisk">sfdisk&lt;/a>&lt;/li>
&lt;li>su&lt;/li>
&lt;li>sulogin&lt;/li>
&lt;li>swaplabel&lt;/li>
&lt;li>swapoff&lt;/li>
&lt;li>swapon&lt;/li>
&lt;li>switch_root&lt;/li>
&lt;li>taskset&lt;/li>
&lt;li>tunelp (deprecated)&lt;a href="https://en.wikipedia.org/wiki/Util-linux#cite_note-11">[11]&lt;/a>&lt;/li>
&lt;li>ul&lt;/li>
&lt;li>umount&lt;/li>
&lt;li>unshare&lt;/li>
&lt;li>utmpdump&lt;/li>
&lt;li>uuidd&lt;/li>
&lt;li>uuidgen&lt;/li>
&lt;li>uuidparse&lt;/li>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Vipw">vipw&lt;/a> (including symlink to vigr)&lt;/li>
&lt;li>wall&lt;/li>
&lt;li>wdctl&lt;/li>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Whereis">whereis&lt;/a>&lt;/li>
&lt;li>wipefs&lt;/li>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Write_(Unix)">write&lt;/a>&lt;/li>
&lt;li>zramctl&lt;/li>
&lt;/ul>
&lt;h2 id="removed">Removed&lt;/h2>
&lt;p>Utilities formerly included, but removed as of 1 July 2015:&lt;/p>
&lt;ul>
&lt;li>arch&lt;a href="https://en.wikipedia.org/wiki/Util-linux#cite_note-12">[12]&lt;/a>&lt;/li>
&lt;li>chkdupexe&lt;a href="https://en.wikipedia.org/wiki/Util-linux#cite_note-13">[13]&lt;/a>&lt;/li>
&lt;li>clock&lt;a href="https://en.wikipedia.org/wiki/Util-linux#cite_note-14">[14]&lt;/a>&lt;/li>
&lt;li>cytune&lt;a href="https://en.wikipedia.org/wiki/Util-linux#cite_note-15">[15]&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Ddate">ddate&lt;/a> (removed from default build&lt;a href="https://en.wikipedia.org/wiki/Util-linux#cite_note-16">[16]&lt;/a> before being removed&lt;a href="https://en.wikipedia.org/wiki/Util-linux#cite_note-17">[17]&lt;/a> altogether)&lt;/li>
&lt;li>elvtune&lt;a href="https://en.wikipedia.org/wiki/Util-linux#cite_note-18">[18]&lt;/a>&lt;/li>
&lt;li>fastboot&lt;a href="https://en.wikipedia.org/wiki/Util-linux#cite_note-simpleinit-19">[19]&lt;/a>&lt;/li>
&lt;li>fasthalt&lt;a href="https://en.wikipedia.org/wiki/Util-linux#cite_note-simpleinit-19">[19]&lt;/a>&lt;/li>
&lt;li>halt&lt;a href="https://en.wikipedia.org/wiki/Util-linux#cite_note-simpleinit-19">[19]&lt;/a>&lt;/li>
&lt;li>initctl&lt;a href="https://en.wikipedia.org/wiki/Util-linux#cite_note-simpleinit-19">[19]&lt;/a>&lt;/li>
&lt;li>ramsize (formerly a symlink to rdev)&lt;a href="https://en.wikipedia.org/wiki/Util-linux#cite_note-rdev-20">[20]&lt;/a>&lt;/li>
&lt;li>rdev&lt;a href="https://en.wikipedia.org/wiki/Util-linux#cite_note-rdev-20">[20]&lt;/a>&lt;/li>
&lt;li>reboot&lt;a href="https://en.wikipedia.org/wiki/Util-linux#cite_note-simpleinit-19">[19]&lt;/a>&lt;/li>
&lt;li>rootflags (formerly a symlink to rdev)&lt;a href="https://en.wikipedia.org/wiki/Util-linux#cite_note-rdev-20">[20]&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Shutdown_(command)">shutdown&lt;/a>&lt;a href="https://en.wikipedia.org/wiki/Util-linux#cite_note-simpleinit-19">[19]&lt;/a>&lt;/li>
&lt;li>simpleinit&lt;a href="https://en.wikipedia.org/wiki/Util-linux#cite_note-simpleinit-19">[19]&lt;/a>&lt;/li>
&lt;li>tailf&lt;a href="https://en.wikipedia.org/wiki/Util-linux#cite_note-tailf-21">[21]&lt;/a>&lt;/li>
&lt;li>vidmode (formerly a symlink to rdev)&lt;a href="https://en.wikipedia.org/wiki/Util-linux#cite_note-rdev-20">[20]&lt;/a>&lt;/li>
&lt;/ul></description></item><item><title>Docs: Linux 管理案例</title><link>https://desistdaydream.github.io/docs/IT%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/X.Linux-%E7%AE%A1%E7%90%86/Linux-%E7%AE%A1%E7%90%86%E6%A1%88%E4%BE%8B/Linux-%E7%AE%A1%E7%90%86%E6%A1%88%E4%BE%8B/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/IT%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/X.Linux-%E7%AE%A1%E7%90%86/Linux-%E7%AE%A1%E7%90%86%E6%A1%88%E4%BE%8B/Linux-%E7%AE%A1%E7%90%86%E6%A1%88%E4%BE%8B/</guid><description>
&lt;h1 id="重置-linux-的-root-密码">重置 Linux 的 root 密码&lt;/h1>
&lt;h2 id="进入紧急模式">进入紧急模式&lt;/h2>
&lt;p>详见《[Linux 的紧急模式或救援模式](/docs/IT学习笔记/1.操作系统/X.Linux%20 管理/性能优化%20 与%20 故障处理/Linux%20 的紧急模式或救援模式.md 与 故障处理/Linux 的紧急模式或救援模式.md)》&lt;/p>
&lt;h2 id="修改密码">修改密码&lt;/h2>
&lt;ul>
&lt;li>切换到原系统执行：&lt;code>chroot /sysroot/&lt;/code>&lt;/li>
&lt;li>更改 root 密码：&lt;code>passwd root&lt;/code>&lt;/li>
&lt;li>在/目录下创建一个.autorelabel 文件，而有这个文件存在，系统在重启时就会对整个文件系统进行 relabeling
&lt;ul>
&lt;li>&lt;code>touch /.autorelabel&lt;/code>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;code>exit&lt;/code>&lt;/li>
&lt;li>&lt;code>reboot&lt;/code>&lt;/li>
&lt;/ul>
&lt;h1 id="修改网卡名">修改网卡名&lt;/h1>
&lt;p>centos 系统&lt;/p>
&lt;ul>
&lt;li>vi /etc/default/grub
&lt;ul>
&lt;li>GRUB_CMDLINE_LINUX=&amp;ldquo;net.ifnames=0 biosdevname=0 crashkernel=auto rd.lvm.lv=myvg/root rd.lvm.lv=myvg/swap rhgb quiet&amp;rdquo;&lt;/li>
&lt;li>注意，标红位置改为自己的 lvm 中 volume group 的名字&lt;/li>
&lt;li>主要就是添加紫色内容的字符串&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>grub2-mkconfig -o /boot/grub2/grub.cfg&lt;/li>
&lt;li>mv /etc/sysconfig/network-scripts/ifcfg-ens33 /etc/sysconfig/network-scripts/ifcfg-eth0&lt;/li>
&lt;li>sed -i &amp;ldquo;s/ens33/eth0/g&amp;rdquo; /etc/sysconfig/network-scripts/ifcfg-eth0&lt;/li>
&lt;/ul>
&lt;p>ubuntu 系统&lt;/p>
&lt;ul>
&lt;li>修改 grub 文件
&lt;ul>
&lt;li>vim /etc/default/grub&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>查找
&lt;ul>
&lt;li>GRUB_CMDLINE_LINUX=&amp;quot;&amp;quot;&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>修改为
&lt;ul>
&lt;li>GRUB_CMDLINE_LINUX=&amp;ldquo;net.ifnames=0 biosdevname=0&amp;rdquo;&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>重新生成 grub 引导配置文件
&lt;ul>
&lt;li>grub-mkconfig -o /boot/grub/grub.cfg&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>修改网络配置 ens32 为 eth0
&lt;ul>
&lt;li>vim /etc/netplan/01-netcfg.yaml&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/gvagsg/1616163849544-f4eac668-9a60-40ef-b291-c28f82e1e661.jpeg" alt="">&lt;/p></description></item><item><title>Docs: Linux 网络栈管理</title><link>https://desistdaydream.github.io/docs/IT%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2.Kernel%E5%86%85%E6%A0%B8/8.Network-%E7%AE%A1%E7%90%86/Linux-%E7%BD%91%E7%BB%9C%E6%A0%88%E7%AE%A1%E7%90%86/Linux-%E7%BD%91%E7%BB%9C%E6%A0%88%E7%AE%A1%E7%90%86/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/IT%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2.Kernel%E5%86%85%E6%A0%B8/8.Network-%E7%AE%A1%E7%90%86/Linux-%E7%BD%91%E7%BB%9C%E6%A0%88%E7%AE%A1%E7%90%86/Linux-%E7%BD%91%E7%BB%9C%E6%A0%88%E7%AE%A1%E7%90%86/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://www.kernel.org/doc/html/latest/networking/index.html">Kernel 文档-Linux Networkiing Documentation&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.kernel.org/doc/html/latest/networking/kapi.html">Kernel 文档-Linux Networking and Network Devices APIs&lt;/a>&lt;/li>
&lt;li>&lt;a href="http://arthurchiao.art/index.html">arthurchiao.art 的文章&lt;/a>
&lt;ul>
&lt;li>&lt;a href="http://arthurchiao.art/blog/tuning-stack-rx-zh/">[译] Linux 网络栈监控和调优：接收数据（2016）&lt;/a>&lt;/li>
&lt;li>&lt;a href="http://arthurchiao.art/blog/tuning-stack-tx-zh/">[译] Linux 网络栈监控和调优：发送数据（2017）&lt;/a>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>和磁盘设备类似，Linux 用户想要使用网络功能，不能通过直接操作硬件完成，而需要直接或间接的操作一个 Linux 为我们抽象出来的设备，即通用的 &lt;strong>Linux 网络设备&lt;/strong>来完成。一个常见的情况是，系统里装有一个硬件网卡，Linux 会在系统里为其生成一个网络设备实例，如 eth0，用户需要对 eth0 发出命令以配置或使用它了。更多的硬件会带来更多的设备实例，虚拟的硬件也会带来更多的设备实例。&lt;/p>
&lt;p>网卡本身并不会连接连接任何网络，网卡需要相应的配置文件来告诉他们如何实现网络连接。而让网卡与配置文件关联的过程，就是 network.service 这类服务来实现的&lt;/p>
&lt;p>在 Linux 系统中，一般使用“网络设备”这种称呼，来描述硬件物理网卡设备在系统中的实例。在不同的语境中，有时也简称为 “设备”、“DEV” 等等。网络设备可以是一块真实机器上的网卡，也可以是创建的虚拟的网卡。&lt;/p>
&lt;p>而网络设备与网卡之间如何建立关系，就是网卡驱动程序的工作了，不同的网卡，驱动不一样，可以实现的功能也各有千秋。所以，想要系统出现 eth0 这种网络设备，网卡驱动程序是必须存在的，否则，没有驱动，也就无法识别硬件，无法识别硬件，在系统中也就不知道如何操作这个硬件。&lt;/p>
&lt;h2 id="常见术语">常见术语&lt;/h2>
&lt;h3 id="datapath数据路径">DataPath(数据路径)&lt;/h3>
&lt;p>网络数据在内核中进行网络传输时，所经过的所有点组合起来，称为数据路径。&lt;/p>
&lt;h3 id="socket-buffer简称-sk_buff-或-skb">Socket Buffer(简称 sk_buff 或 skb)&lt;/h3>
&lt;p>在内核代码中是一个名为 &lt;a href="https://www.kernel.org/doc/html/latest/networking/kapi.html#c.sk_buff">&lt;strong>sk_buff&lt;/strong>&lt;/a>** **的结构体。内核显然需要一个数据结构来储存报文的信息。这就是 skb 的作用。
sk_buff 结构自身并不存储报文内容，它通过多个指针指向真正的报文内存空间:
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/efrsi8/1617849698535-471768e0-dcf8-4471-8dd2-605a1bc4e020.png" alt="image.png">
sk_buff 是一个贯穿整个协议栈层次的结构，在各层间传递时，内核只需要调整 sk_buff 中的指针位置就行。
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/efrsi8/1617849692989-54095177-b85c-449e-8c66-3b026e4925da.png" alt="image.png">&lt;/p>
&lt;h3 id="device设备">DEVICE(设备)&lt;/h3>
&lt;p>在内核代码中，是一个名为 &lt;a href="https://www.kernel.org/doc/html/latest/networking/kapi.html#c.net_device">&lt;strong>net_device&lt;/strong>&lt;/a> 的结构体。一个巨大的数据结构，描述一个网络设备的所有 属性、数据 等信息。&lt;/p>
&lt;h1 id="linux-网络功能的实现">Linux 网络功能的实现&lt;/h1>
&lt;h1 id="数据包的-transmit发送-与-receive接收-过程概览">数据包的 Transmit(发送) 与 Receive(接收) 过程概览&lt;/h1>
&lt;h2 id="receive接收-过程">Receive(接收) 过程&lt;/h2>
&lt;p>本文将拿 &lt;strong>Intel I350&lt;/strong> 网卡的 &lt;code>igb&lt;/code> 驱动作为参考，网卡的 data sheet 这里可以下 载 &lt;a href="http://www.intel.com/content/dam/www/public/us/en/documents/datasheets/ethernet-controller-i350-datasheet.pdf">PDF&lt;/a> （警告：文件很大）。
从比较高的层次看，一个数据包从被网卡接收到进入 socket 接收队列的整个过程如下：&lt;/p>
&lt;ol>
&lt;li>加载网卡驱动，初始化&lt;/li>
&lt;li>包从外部网络进入网卡&lt;/li>
&lt;li>网卡（通过 DMA）将包 copy 到内核内存中的 ring buffer&lt;/li>
&lt;li>产生硬件中断，通知系统收到了一个包&lt;/li>
&lt;li>驱动调用 NAPI，如果轮询（poll）还没开始，就开始轮询&lt;/li>
&lt;li>&lt;code>ksoftirqd&lt;/code> 进程调用 NAPI 的 &lt;code>poll&lt;/code> 函数从 ring buffer 收包（&lt;code>poll&lt;/code> 函数是网卡 驱动在初始化阶段注册的；每个 CPU 上都运行着一个 &lt;code>ksoftirqd&lt;/code> 进程，在系统启动期 间就注册了）&lt;/li>
&lt;li>ring buffer 里包对应的内存区域解除映射（unmapped）&lt;/li>
&lt;li>（通过 DMA 进入）内存的数据包以 &lt;code>skb&lt;/code> 的形式被送至更上层处理&lt;/li>
&lt;li>如果 packet steering 功能打开，或者网卡有多队列，网卡收到的包会被分发到多个 CPU&lt;/li>
&lt;li>包从队列进入协议层&lt;/li>
&lt;li>协议层处理包&lt;/li>
&lt;li>包从协议层进入相应 socket 的接收队列&lt;/li>
&lt;/ol>
&lt;p>接下来会详细介绍这个过程。&lt;/p>
&lt;h2 id="transmit发送-过程">Transmit(发送) 过程&lt;/h2>
&lt;p>本文将拿&lt;strong>Intel I350&lt;/strong>网卡的 &lt;code>igb&lt;/code> 驱动作为参考，网卡的 data sheet 这里可以下载 &lt;a href="http://www.intel.com/content/dam/www/public/us/en/documents/datasheets/ethernet-controller-i350-datasheet.pdf">PDF&lt;/a> （警告：文件很大）。
从比较高的层次看，一个数据包从用户程序到达硬件网卡的整个过程如下：&lt;/p>
&lt;ol>
&lt;li>使用&lt;strong>系统调用&lt;/strong>（如 &lt;code>sendto&lt;/code>，&lt;code>sendmsg&lt;/code> 等）写数据&lt;/li>
&lt;li>数据穿过&lt;strong>socket 子系统&lt;/strong>，进入&lt;strong>socket 协议族&lt;/strong>（protocol family）系统（在我们的例子中为 &lt;code>AF_INET&lt;/code>）&lt;/li>
&lt;li>协议族处理：数据穿过&lt;strong>协议层&lt;/strong>，这一过程（在许多情况下）会将&lt;strong>数据&lt;/strong>（data）转换成&lt;strong>数据包&lt;/strong>（packet）&lt;/li>
&lt;li>数据穿过&lt;strong>路由层&lt;/strong>，这会涉及路由缓存和 ARP 缓存的更新；如果目的 MAC 不在 ARP 缓存表中，将触发一次 ARP 广播来查找 MAC 地址&lt;/li>
&lt;li>穿过协议层，packet 到达&lt;strong>设备无关层&lt;/strong>（device agnostic layer）&lt;/li>
&lt;li>使用 XPS（如果启用）或散列函数&lt;strong>选择发送队列&lt;/strong>&lt;/li>
&lt;li>调用网卡驱动的&lt;strong>发送函数&lt;/strong>&lt;/li>
&lt;li>数据传送到网卡的 &lt;code>qdisc&lt;/code>（queue discipline，排队规则）&lt;/li>
&lt;li>qdisc 会直接&lt;strong>发送数据&lt;/strong>（如果可以），或者将其放到队列，下次触发&lt;code>**NET_TX**&lt;/code>** 类型软中断**（softirq）的时候再发送&lt;/li>
&lt;li>数据从 qdisc 传送给驱动程序&lt;/li>
&lt;li>驱动程序创建所需的&lt;strong>DMA 映射&lt;/strong>，以便网卡从 RAM 读取数据&lt;/li>
&lt;li>驱动向网卡发送信号，通知&lt;strong>数据可以发送了&lt;/strong>&lt;/li>
&lt;li>&lt;strong>网卡从 RAM 中获取数据并发送&lt;/strong>&lt;/li>
&lt;li>发送完成后，设备触发一个&lt;strong>硬中断&lt;/strong>（IRQ），表示发送完成&lt;/li>
&lt;li>&lt;strong>硬中断处理函数&lt;/strong>被唤醒执行。对许多设备来说，这会&lt;strong>触发 &lt;strong>&lt;code>**NET_RX**&lt;/code>&lt;/strong> 类型的软中断&lt;/strong>，然后 NAPI poll 循环开始收包&lt;/li>
&lt;li>poll 函数会调用驱动程序的相应函数，&lt;strong>解除 DMA 映射&lt;/strong>，释放数据&lt;/li>
&lt;/ol>
&lt;h1 id="网络栈关联文件">网络栈关联文件&lt;/h1>
&lt;p>不同的 Linux 发行版，所使用的上层网络配置程序各不相同，各种程序所读取的配置文件也各不相同。&lt;/p>
&lt;ul>
&lt;li>对于 RedHat 相关的发行版，网络配置在 /etc/sysconfig/network-scripts/ 目录中&lt;/li>
&lt;li>对于 Debian 相关的发行版，网络配置在 /etc/network/ 目录中&lt;/li>
&lt;/ul>
&lt;p>在这些目录中，其实都是通过脚本来实现的&lt;/p>
&lt;p>后来随着时代的发展，涌现出很多通用的网络管理程序，比如 Netplan、NetworkManager、systemd-networkd 等等，这样就可以让各个发行版使用相同的程序来管理网络了，减少切换发行版而需要学习对应配置的成本，并且也更利于发展。&lt;/p></description></item><item><title>Docs: Linux 硬件管理工具</title><link>https://desistdaydream.github.io/docs/IT%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/X.Linux-%E7%AE%A1%E7%90%86/Linux-%E7%A1%AC%E4%BB%B6%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/Linux-%E7%A1%AC%E4%BB%B6%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/IT%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/X.Linux-%E7%AE%A1%E7%90%86/Linux-%E7%A1%AC%E4%BB%B6%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/Linux-%E7%A1%AC%E4%BB%B6%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;h1 id="lshw">lshw&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://github.com/lyonel/lshw">GitHub 项目，lyonel/lshw&lt;/a>&lt;/li>
&lt;li>&lt;a href="http://lshw.ezix.org/">官网&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>TODO: 这命令哪来的？看的信息还挺全乎&lt;/p>
&lt;h1 id="lspci">lspci&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://man7.org/linux/man-pages/man8/lspci.8.html">Manual(手册)，lspci(8)&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://github.com/pciutils/pciutils">GitHub 项目，pciutils/pciutils&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://mj.ucw.cz/sw/pciutils/">官网&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>列出所有 PCI 设备。&lt;/p>
&lt;p>CentOS 包：pciutils&lt;/p>
&lt;p>Ubuntu 包：pciutils&lt;/p>
&lt;p>其中还有 setpci 工具用来配置 PCI 设备。&lt;/p>
&lt;h2 id="syntax语法">Syntax(语法)&lt;/h2>
&lt;p>&lt;strong>lspci [OPTIONS]&lt;/strong>&lt;/p>
&lt;h3 id="options">OPTIONS&lt;/h3>
&lt;p>展示内容相关选项&lt;/p>
&lt;ul>
&lt;li>&lt;strong>-k&lt;/strong> # 显示处理每个设备的内核驱动程序以及能够处理它的内核模块。在正常输出模式下给出 -v 时默认打开。 （目前仅适用于内核为 2.6 或更新版本的 Linux。）&lt;/li>
&lt;/ul>
&lt;p>选择指定设备选项&lt;/p>
&lt;ul>
&lt;li>&lt;strong>&lt;code>-s [[[[&amp;lt;DOMAIN&amp;gt;]:]&amp;lt;BUS&amp;gt;]:][&amp;lt;DEVICE&amp;gt;][.[&amp;lt;FUNC&amp;gt;]]&lt;/code>&lt;/strong> # 仅显示指定域中的设备（如果您的机器有多个主机桥，它们可以共享一个公共总线编号空间，或者它们中的每一个都可以寻址自己的 PCI 域；域编号从 0 到 ffff），bus （0 到 ff）、设备（0 到 1f）和功能（0 到 7）。设备地址的每个组成部分都可以省略或设置为“*”，均表示“任意值”。所有数字都是十六进制的。例如，“0：”表示总线 0 上的所有设备，“0”表示任何总线上设备 0 的所有功能，“0.3”选择所有总线上设备 0 的第三个功能，“.4”仅显示每个总线上的第四个功能设备。
&lt;ul>
&lt;li>注意：-s 的值可以通过 uevent 文件中的 PCI_SLOT_NAME 字段的值获取&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h1 id="smartctl">smartctl&lt;/h1>
&lt;p>smartctl -a /dev/sda&lt;/p>
&lt;h1 id="网卡">网卡&lt;/h1>
&lt;h2 id="mii-tool">mii-tool&lt;/h2>
&lt;h1 id="usb-管理工具">USB 管理工具&lt;/h1>
&lt;h2 id="usbutils">usbutils&lt;/h2>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://github.com/gregkh/usbutils">GitHub 项目，gregkh/usbutils&lt;/a>&lt;/li>
&lt;li>&lt;a href="http://www.linux-usb.org/">官网&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://man7.org/linux/man-pages/man8/lsusb.8.html">Manual(手册)，lsusb(8)&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>适用于 Linux 的 USB 实用程序，包括 lsusb。这是在 Linux 和 BSD 系统上使用的 USB 工具的集合，用于查询连接到系统的 USB 设备类型。这将在 USB 主机 (即您插入USB设备的机器) 上运行，而不是在 USB 设备 (即您插入USB主机的设备) 上运行。&lt;/p>
&lt;p>包括如下几个工具&lt;/p>
&lt;ul>
&lt;li>lsusb&lt;/li>
&lt;li>usb-devices&lt;/li>
&lt;li>usbhid-dump&lt;/li>
&lt;li>usbreset&lt;/li>
&lt;/ul>
&lt;h3 id="lsusb-syntax语法">lsusb Syntax(语法)&lt;/h3>
&lt;p>列出系统上的USB总线和USB设备的详细信息。在输出中，您将看到USB控制器的制造商、型号和当前的状态。&lt;/p>
&lt;ul>
&lt;li>&lt;code>sudo lshw -class bus -class usb&lt;/code>&lt;/li>
&lt;/ul>
&lt;p>只查看有关USB设备的更详细信息&lt;/p>
&lt;ul>
&lt;li>&lt;code>lshw -class usb&lt;/code>&lt;/li>
&lt;/ul></description></item><item><title>Docs: LVS</title><link>https://desistdaydream.github.io/docs/IT%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/3.%E9%9B%86%E7%BE%A4%E4%B8%8E%E5%88%86%E5%B8%83%E5%BC%8F/LVS/LVS/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/IT%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/3.%E9%9B%86%E7%BE%A4%E4%B8%8E%E5%88%86%E5%B8%83%E5%BC%8F/LVS/LVS/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Linux_Virtual_Server">Wiki,LVS&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/IP_Virtual_Server">Wiki,IPVS&lt;/a>&lt;/li>
&lt;li>&lt;a href="http://www.linuxvirtualserver.org/">官网&lt;/a>&lt;/li>
&lt;li>&lt;a href="http://www.linuxvirtualserver.org/zh/">官网,中文&lt;/a>&lt;/li>
&lt;li>&lt;a href="http://www.austintek.com/LVS/LVS-HOWTO/HOWTO/">官方文档,HOWTO&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>&lt;strong>Linux Virtual Server(Linux 虚拟服务器，简称 LVC)&lt;/strong> 是一个可以实现虚拟的服务器集群功能的项目，用于实现负载均衡的软件技术。一般情况下，LVS 代之一组服务器，对于外部客户端来说，这似乎是一台服务器，所以，也称为 &lt;strong>。&lt;/strong>&lt;/p>
&lt;p>目前，LVS 项目已经被集成到 Linux 内核中，并通过 &lt;a href="docs/IT%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/3.%E9%9B%86%E7%BE%A4%E4%B8%8E%E5%88%86%E5%B8%83%E5%BC%8F/LVS/IPVS/IPVS.md">IPVS&lt;/a>模块实现。LVS 具有良好的可靠性、可扩展性和可操作性，加上其实现最优的集群服务性能所需的低廉成本， LVS 的负载均衡功能经常被用于高性能、高可用的服务器群集中。&lt;/p>
&lt;p>LVS 项目在 1998 年 5 月由&lt;a href="https://baike.baidu.com/item/%E7%AB%A0%E6%96%87%E5%B5%A9/6689425">章文嵩&lt;/a>博士成立，是中国国内最早出现的自由软件项目之一。在 linux2.2 内核时，IPVS 就已经以内核补丁的形式出现。从 2.4 版本以后 IPVS 已经成为 Linux 内核官方标准内核的一部分&lt;/p>
&lt;h2 id="名词解释">名词解释&lt;/h2>
&lt;p>调度器的称呼：scheduler，director，dispatcher，balancer&lt;/p>
&lt;ul>
&lt;li>
&lt;p>&lt;strong>Director(指挥器)&lt;/strong> # 运行 IPVS 的节点。&lt;/p>
&lt;ul>
&lt;li>&lt;strong>IPVS(IP 虚拟服务)&lt;/strong> # 实现调度功能的程序。是一个 Linux 内核模块。实际上，IPVS 就是一个 &lt;strong>Schedulers(调度器)&lt;/strong>。
&lt;ul>
&lt;li>&lt;strong>Forwarding Method(转发方法)&lt;/strong> # Forwarding Method 用来确定 Director 如何将数据包从客户端转发到 Real Servers。如果把 Director 比做路由器，其转发数据包的规则与普通路由器有所不同。
&lt;ul>
&lt;li>Forwarding Method 其实就是指 LVS 的工作模式，当前有 LVS-NAT、LVS-DR、LVS-TUN 这几种。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>ipvsadm&lt;/strong> # 为 IPVS 程序配置调度规则的用户端应用程序。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>Real Server(真实服务器，简称 RS)&lt;/strong> # 处理来自客户端请求的节点&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>Linux Virtual Server(简称 LVS)&lt;/strong> # Director 与 Real Server 共同组成 LVS 集群。这些机器一起构成虚拟服务器，对于客户端来说，它表现为一台机器。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>Client IP&lt;/strong> # CIP,客户端 IP，用户发送请求报文的 IP&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>Director IP&lt;/strong> # DIP,调度器 IP&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>Virual IP&lt;/strong> # VIP,虚拟 IP，用于提供提供虚拟服务的 IP,该 IP 存在于 Director 和 RS 上&lt;/p>
&lt;ul>
&lt;li>为什么叫虚拟的 IP，因为这个 IP 可以代表 Director，也可以代表很多 RS，把 Director 和 RS 的很多 IP 合成 一个 IP，就称为虚拟的 IP。&lt;/li>
&lt;li>为什么需要虚拟 IP 呢，这就涉及到为什么要有 LVS 了，VIP 就是集群服务的一种体现，1.Cluster 集群，LB 负载均衡，HA 高可用.note 在这篇文章中第一段就是说明了集群的作用，为了让用户不用直接找 RS，而把所有的设备当做一个整体，用户看到的只有一个 IP，而不是那么多 RS 的 IP。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>Real Server IP&lt;/strong> # RIP,调度 IP，真实服务器 IP&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h2 id="lvs-architecture架构">LVS Architecture(架构)&lt;/h2>
&lt;p>典型的 LVS 集群架构如图 所示。在 LVS 负载均衡集群架构中，尽管整个集群内部有多个物理节点在处理用户发出的请求，但是在用户看来，所有的内部应用都是透明的，用户只是在使用一个虚拟服务器提供的高性能服务，这也是 Linux 虚拟服务器项目，即 LVS 项目的主要名称来源，如下是对 LVS 集群架构中各个层次的功能描述。
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/zzd89g/1622466145377-4664be5a-f6bd-4537-94eb-72054d13d096.png" alt="">&lt;/p>
&lt;p>在基于 LVS 项目架构的服务器集群系统中，通常包含三个功能层次：&lt;/p>
&lt;ul>
&lt;li>&lt;strong>Load Balancer(负载均衡)&lt;/strong> # 是整个集群系统的前端机器，在一组服务器之间均衡来自客户端的请求，让客户端认为所有服务都来自同一个 IP。
&lt;ul>
&lt;li>Director(调度器) 就是在该层工作&lt;/li>
&lt;li>负载均衡层位于整个集群系统的最前端，由一台或者多台 Director 组成， IPVS 模块就安装在 Director Server 的系统上，而 Director Server 的主要功能类似路由器，其包含了完成 LVS 负载转发功能所设定的路由表， Director 利用这些路由表信息把用户的请求分发到 Sever Cluster 层的物理服务器(Real Server) 上。此外，为了监测各个 Real Server 服务器的健康状况，在 Director Server 上还要安装监控模块 Ldirectord，当监控到某个 Real Server 不可用时，该服务器会被从 LVS 路由表中剔除，恢复时又会重新加入。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>Server Cluster(服务器集群)&lt;/strong> # 这是一组运行实际网络服务的服务器，如 Web、邮件、FTP、DNS 和媒体服务。
&lt;ul>
&lt;li>Real Server(真实服务器) 就是在该层工作&lt;/li>
&lt;li>服务器阵列或服务器池由一组实际运行应用服务的物理机器组成，Real Server 可以是 Web 服务器、Mail 服务器、FTP 服务器、DNS 服务器以及视频服务器中的一个或者多个的组合。每个 Real Server 之间通过高速的 LAN 或分布在各地的 WAN 相连接。在实际应用中，为了减少资源浪费， Director Server 也可以同时兼任 Real Server 的角色，即在 Real Server 同时部署 IPVS 模块。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>Shared Storage(共享存储)&lt;/strong> # 为服务器提供共享的存储空间，便于提供相同的服务。
&lt;ul>
&lt;li>共享存储可以是数据库系统、网络文件系统或分布式文件系统。服务器节点需要动态更新的数据应该存储在基于数据的系统中，当服务器节点在数据库系统中并行读写数据时，数据库系统可以保证并发数据访问的一致性。静态数据通常保存在 NFS、CIFS 等网络文件系统中，以便所有服务器节点共享数据。但是，单个网络文件系统的可扩展性是有限的，例如单个 NFS/CIFS 只能支持 4 到 8 个服务器的数据访问。对于大型集群系统，分布式/集群文件系统可以用于共享存储，例如 GPFS，Coda 和 GFS，然后共享存储也可以根据系统需求进行扩展。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>通常情况下，一个 LVS 集群由两类节点组成：&lt;/p>
&lt;ul>
&lt;li>&lt;strong>Director(指挥器)&lt;/strong> # 前端接收客户端请求的节点，并将请求转发给后端 Real Server。Director 通过 IPVS 与 ipvsadm 来实现。&lt;/li>
&lt;li>&lt;strong>Real Server(真实服务器)&lt;/strong># 处理客户端请求的节点。&lt;/li>
&lt;/ul>
&lt;p>这些服务器一起组成了一个虚拟服务器，对于访问他们的客户端来说，它表现为一台机器。&lt;/p>
&lt;p>LVS 的工作模式&lt;/p>
&lt;p>LVS 的 IP 负载均衡技术是通过 IPVS 模块来实现的， IPVS 是 LVS 集群系统的核心软件，其主要安装在集群的 Director Server 上，并在 Director Server 上虚拟出一个 IP 地址，用户对服务的访问只能通过该虚拟 IP 地址实现。这个虚拟 IP 通常称为 LVS 的 VIP(Virtual IP)，用户的访问请求首先经过 VIP 到达 Director，然后由 Director 从 Real Server 列表中按照一定的负载均衡算法选取一个服务节点响应用户的请求。在这个过程中，当用户的请求到达 Director Server 后， Director Server 如何将请求转发到提供服务的 Real Server 节点，而 Real Server 节点又如何将数据返回给用户， 这是 IPVS 实现负载均衡的核心技术。&lt;/p>
&lt;p>IPVS 实现数据路由转发的机制如下几种：&lt;/p>
&lt;ol>
&lt;li>&lt;strong>NAT&lt;/strong> # 支持端口映射但是 DIP 与 RIP 必须要在同一网段&lt;/li>
&lt;li>&lt;strong>DR&lt;/strong> # 不支持端口影响且调度与 RS 必须在同一网络&lt;/li>
&lt;li>&lt;strong>TUN&lt;/strong> # 各 RS 可以放在不同的地域且都在公网上被人直接访问&lt;/li>
&lt;li>&lt;strong>FullNAT&lt;/strong> # 可以在内部构建复杂网络，比如不同 RS 可以跨机房跨网络，而且可以隐藏 RS 不被公网直接访问)&lt;/li>
&lt;/ol>
&lt;p>NAT(Network Address Translation)&lt;/p>
&lt;p>即通过网络地址转换的虚拟服务器技术。在这种负载转发方案中，当用户的请求到达调度器时，调度器自动将请求报文的目标 IP 地址（ VIP ）替换成 LVS 选中的后端 Real Server 地址，同时报文的目标端口也替换为选中的 Real Server 对应端口， 最后将报文请求发送给选中的 Real Server 进行处理。当 Real Server 处理完请求并将结果数据返回给用户时，需要再次经过负载调度器，此时调度器进行相反的地址替换操作，即将报文的源地址和源端口改成 VIP 地址和相应端口，然后把数据发送给用户，完成整个负载调度过程。可以看出，在这种方式下，用户请求和响应报文都必须经过 Director Server 进行地址转换，请求时进行目的地址转换（ Destination Network Address Translation, DNAT ），响应时进行源地址转换（ Source Network Address Translation, SNAT ）。在这种情况下，如果用户请求越来越多，调度器的处理能力就会成为集群服务快速响应的瓶颈。&lt;/p>
&lt;p>LVS-NAT(Network Address Translation)实测可调度 10 台以内的 RS&lt;/p>
&lt;p>多目标 IP 的 DNAT,通过将请求报文中的目标地址和目标端口改为某挑出的 RS 的 RIP 和 PORT 实现转发&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/zzd89g/1616132542821-5af6ee6a-a6d2-4e55-808d-cc00112912f7.jpeg" alt="">
lvs-nat 的特性&lt;/p>
&lt;ol>
&lt;li>
&lt;p>RS 应该使用私有地址&lt;/p>
&lt;/li>
&lt;li>
&lt;p>RS 的网关必须指向 DIP&lt;/p>
&lt;/li>
&lt;li>
&lt;p>RIP 和 DIP 必须在同一网段内&lt;/p>
&lt;/li>
&lt;li>
&lt;p>请求和响应的报文都得经过 Director，在高负载场景中，Director 很可能成为性能瓶颈(因为既要处理请求报文也要处理响应服方的转发,请求报文一般很小,但响应报文一般都比较大)&lt;/p>
&lt;/li>
&lt;li>
&lt;p>支持端口映射,即可修改请求报文的目标端口.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Director 必须是 Linux 系统，RS 可以是任意支持集群服务的操作系统.&lt;/p>
&lt;/li>
&lt;/ol>
&lt;p>lvs-nat 修改请求报文的目的 IP&lt;/p>
&lt;ol>
&lt;li>注意：该类型中 DIP 与 RIP 必须在同一网段且 RS 的网关为 DIP2，所以 Director 需要有两块网卡，DIP1 与 CIP 想通，DIP2 与 RS 想通。所有请求都经过调度器，包括请求报文和响应报文,调度器压力很大&lt;/li>
&lt;li>数据包到达 Director 时，做 dnat(将 VIP 改为 RIP)，然后发送给 RS。&lt;/li>
&lt;li>RS 处理完数据包返回响应给 Director，源 IP 是 RIP，目标 IP 是 CIP&lt;/li>
&lt;li>这时候 Director 收到响应包后，做 snat(将源 IP 改为 VIP)&lt;/li>
&lt;/ol>
&lt;p>DR(Direct Routing)&lt;/p>
&lt;p>即直接路由技术实现的虚拟服务器。这种技术在调度连接和管理上与 VSNAT 和 VSTUN 技术是一样的，不过它的报文转发方式与前两种均不同， VSDR 通过改写请求报文的 MAC 地址，将请求直接发送到选中的 Real Server ，而 Real Server 则将响应直接返回给客户端。因此，这种技术不仅避免了 VSNAT 中的 IP 地址转换，同时也避免了 VS TUN 中的 IP 隧道开销，所以 VSDR 是三种负载调度机制中性能最高的实现方案。但是，在这种方案下， Director Server 与 Real Sever 必须在同一物理网段上存在互联。&lt;/p>
&lt;p>LVS/DR(Direct Routing 直接路由) 实测可以调度 7、8 十台 RS&lt;/p>
&lt;p>通过为请求报文重新封装一个 MAC 首部进行转发,源 MAC 是 DIP 所在的接口的 MAC,目标 MAC 是某挑选出的 RS 的 RIP 所在接口的 MAC 地址;源 IP/PORT,以及目标 IP/PORT 均保持不变,请求报文经过 Dirctor 但响应报文不再经过 Dirctor
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/zzd89g/1616132542832-728aa1cf-07b1-47b3-8cdf-d8918c6789e6.jpeg" alt="">&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/zzd89g/1616132542795-f5e7f61e-e8c9-4b6e-bcd5-6c038fb30f7f.jpeg" alt="">&lt;/p>
&lt;h3 id="dr-类型工作流程">DR 类型工作流程&lt;/h3>
&lt;p>如上图所示：当客户端请求 VIP 时，通过互联网到达前端路由 Route1，再通过交换机到达 Dirctor 上；而 Dirctor 在收到请求报文后，通过定义在 ipvs 规则中的各 rip 去获得各 RS 的 MAC 地址，并在此报文外再封装一个 MAC 地址,源 MAC 为 Dirctor 的 DIP 端口的 MAC 而目标 MAC 改为其中被调度算法选中一个 RS 的 MAC，但该报文的目标 ip(VIP)不变，最后通过 DIP 接口发送给 RS；为了 RS 能接收 Dirctor 发来的报文，需要在各 RS 上也配置 VIP，但 RS 上的 VIP 是需要隔离前端 arp 广播的，所以需要将各 RS 上的 VIP 隐藏（RS 上的 VIP 通常配置到 lo 网卡接口的别名上，并配合修改 Linux 内核参数来实现隔离 arp 广播）；而 RS 封装响应报文时，源 IP 为 VIP，目标 ip 为 CIP，并通过 RIP 的网络接口直接向外发送响应，不再经过 Dirctor。&lt;/p>
&lt;p>需要注意的是：因为 Route1 的 A 点的 IP 和 Dirctor 的 VIP 在同一网段内，VIP 通常是公网 IP；而 DIP、RIP 通常是私有 IP，且这两个 IP 通常也应在同一物理网络内；假设 RIP 与 Route1 的 A 接口(同 Director 的 VIP DIP)在同一网段，则这时可将 RS 的网关指向 Route1，否则，Route2 只能其它路由器(如 Route2)接口访问互联网，且 Route2 的 C 点的 IP 需要与 RIP 在同一网段内，此时 RIP 响应的报文就通过 Route2 发送。&lt;/p>
&lt;ul>
&lt;li>1.RIP 与 DIP 在同一 IP 网络，RS 可以使用私有地址，也可以使用公网地址，此时可以直接通过互联网连入 RS，以实现配置、监控等&lt;/li>
&lt;li>2.RS 的网关一定不能指向 DIP&lt;/li>
&lt;li>3.RS 跟 Director 要在同一物理网络内（不能有路由器分隔,因为要将报文封装 MAC 首部进行报文转发）&lt;/li>
&lt;li>4.请求报文必须经过 Director，但响应报文不能经过 Director 而是由 RS 直接发往 Client 以释放 Directory 的压力。&lt;/li>
&lt;li>5.不支持端口映射(因为响应报文不经过 Director)&lt;/li>
&lt;li>6.RS 可以使用大多数的操作系统&lt;/li>
&lt;li>7.Director 的 VIP 对外可见，RS 的 VIP 对外不可见&lt;/li>
&lt;li>8.RS 跟 Director 都得配置使用 VIP&lt;/li>
&lt;li>9.确保前端路由器将目标 IP 为 VIP 的请求报文发往 Director(上文的设置)&lt;/li>
&lt;/ul>
&lt;p>lvs-dr(direct routing) # 操纵新的 MAC 地址，直接路由，默认的 LVS 类型，通过请求报文的目标 MAC 地址进行转发，即需要 ARP 的 IP 与 MAC 映射表才能转发，由于调度器是基于二层 MAC 来调度的，所以调度器与 RS 必须要在同一个 VLAN 中
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/zzd89g/1616132542782-786ee136-62a7-4fb6-8faf-2a43c660d620.jpeg" alt="">&lt;/p>
&lt;ol>
&lt;li>如图所示，请求报文直接到调度器，然后调度器选择一台 RS，让这台 RS 来响应该请求，RS 与用户直接交互，不再经过调度器，只有请求报文经过调度器，响应报文是不经过调度器的(RS 的网关不能指定到 DIP)所以用户访问的业务 IP 都是该业务的调度器的浮动 IP，通过调度器来给用户选择一台提供服务的主机，这样调度器没有压力。&lt;/li>
&lt;li>RS 构建响应报文响应用户请求的时候，需要使用 VIP 来进行响应，因为用户请求的是 VIP，RS 只能用 VIP 来进行响应。每台 RS 都有一个 VIP，但是用户请求的 VIP 必须要到调度器上，那么这时候在 VIP 上就需要绑定 mac 地址了，以 mac 地址来区分调度器与 RS。&lt;/li>
&lt;li>所以 Director 在调度主机的时候，会把选择的 RS 的物理网卡的 MAC 地址加进请求报文中作为目的 mac 地址，然后转发给 RS。（用户依然会通过 VIP 来访问，但是数据到交换机的时候，是根据 MAC 地址来转发该数据到 RS，这样就实现了 RS 与用户的直接交互；所以当用户断开连接再次请求后，由于请求报文目的 MAC 地址没了，所以交换机会根据本身的 arp 表把，找到 mac 地址，这时候依然是 Director，则数据包到 Director 的时候需要重新配分新的 RS）&lt;/li>
&lt;li>由于 Linux 从哪网卡收的就要从哪个网卡发，为了解决响应报文中的源地址不能是 RS 的 IP 的问题，那么每台 RS 的 VIP 则不配置在物理网卡上，而是配置在这台机器 lo(loopback)接口上，给 lo 起一个别名用作 VIP，具体原因如下
&lt;ol>
&lt;li>由于路由器一般是动态学习 ARP 包的（一般动态配置 DHCP 的话），当内网的机器要发送一个到外部的 ip 包，那么它就会请求 路由器的 Mac 地址，发送一个 arp 请求，这个 arp 请求里面包括了自己的 ip 地址和 Mac 地址，而 linux 默认是使用 ip 的源 ip 地址作为 arp 里面 的源 ip 地址，而不是使用发送设备上面的 ，这样在 lvs 这样的架构下，所有 RS 发送包都是同一个 VIP 地址，那么 arp 请求就会包括 VIP 地址和设备 Mac，而路由器收到这个 arp 请求就会更新自己的 arp 缓存，这样就会造成 ip 欺骗了，VIP 被抢夺，这样调度器的 VIP 就被被 RS 抢走，这样就会出现问题，下一个数据包就无法正确发送给调度器了。所以需要给每台 RS 都要配置 arp 的通告以及响应规则以实现该功能&lt;/li>
&lt;li>&lt;strong>arp_ignore&lt;/strong> # arp 忽略，响应 arp 请求时的动作，由该项参数决定
&lt;ol>
&lt;li>参数 0：默认参数，只要收到 arp 请求，无论是哪个地址，都做出响应&lt;/li>
&lt;li>参数 1：推荐设置，只响应目的 IP 地址为接收网卡上的本地地址的 arp 请求。(如果外面有人询问 VIP，由于 VIP 在 lo 上，不在接收网卡上，所以不会响应询问 VIP 的 arp 通告。这样防止 VIP 的 arp 被抢夺)。&lt;/li>
&lt;li>参数 2：只响应目标 IP 地址是来访网络接口本地地址的 ARP 查询请求,且来访 IP 必须在该网络接口的子网段内&lt;/li>
&lt;li>参数 3：不回应该网络界面的 arp 请求，而只对设置的唯一和连接地址做出回应&lt;/li>
&lt;li>参数 4-7：保留未使用&lt;/li>
&lt;li>参数 8：不回应所有（本地地址）的 arp 查询&lt;/li>
&lt;/ol>
&lt;/li>
&lt;li>&lt;strong>arp_announce&lt;/strong># arp 宣告，通告 arp 给别人时的动作；以及是否接收 arp 通告，并记录；由该项参数决定
&lt;ol>
&lt;li>参数 0：默认参数，把本机所有网卡上的所有地址通告给网络中（不管任何情况，使用发送或者转发的数据包的源 IP 作为发送 ARP 请求的 Sender IP）(与参数 1 的区别：不管目的 IP 与本地接口的 IP 在不在同一个网段，都是用发送源 IP 作为 Sender IP）&lt;/li>
&lt;li>参数 1：尽量避免从本网络的外部接口向非本网络中的网络,通告非本网络中的接口的地址（只有当数据包的目的 IP 与本地某个接口的网段相同时，才使用发送或者转发的数据包的源 IP 作为发送 ARP 请求的 Sender IP，不属于则按参数 2 处理）
&lt;ol>
&lt;li>本网络的意思就是：比如 192.168.0.0/24 是一个网络，192.168.1.0/24 是另一个网络，0.0 网络中的地址尽量不通告给 1.0 网络中的地址，但是当需要发送数据的时候，还是需要进行通告&lt;/li>
&lt;/ol>
&lt;/li>
&lt;li>参数 2：推荐设置，在发送 arp 宣告的时候不使用数据包的源 IP，使用能与目标主机通信的最佳地址来作为发送 ARP 的 Sender IP，优先选择对外接口的主 IP；（loopback 不是对外接口）(e.g.在 RS 给 client 发送响应数据包的时候，默认情况下，会先给发送 arp 通告，询问网关在哪。由于数据包的源 IP 是 VIP，MAC 是发送数据包的物理网卡的 MAC；目的 IP 是 client 的 ip，目的 mac 未知，所以 arp 通告的源 IP 也是 VIP，那么这时候，交换机就会更新 VIP 与 MAC 的对应关系，此时产生问题，因为 VIP 应该与 director 的 MAC 绑定才对，但是现在收到的这个 arp 通告说是 VIP 应该与 RS 绑定，这明显是不应该发生的。所以在发送数据包之前的 arp 通告，不能使用 VIP，而是使用本机的物理网卡来进行 arp 通告。不过这个从 RS 发出的数据包的封包其实源 IP 还是 VIP、源 MAC 是物理网卡的 MAC，这样在 client 收到 RS 的响应包之后与 RS 交互发送数据包，目的 IP 则是 VIP，目的 MAC 则是 RS 物理网卡的 MAC，当交换机收到 client 发的包时，解开封包看到目的 mac 地址是 RS 的，则直接就把数据包交给对应的网口了，至于 IP 则是在三层路由的时候才用的，当交换机已经收到这个包时，就会把 IP 拆开直接使用 MAC 来传输数据包。而当 RS 与 client 断开连接后，client 再次主动发的数据包到交换机时，目的 MAC 是未知的，交换机就会把数据包交给 director 来进行处理，因为交换机的 arp 表里已经把 VIP 与 director 的 mac 绑定了)。arp 原理详见 ARP.note
&lt;ol>
&lt;li>三者 ARP 的通告规则区别：参数 0 是不管什么时候把所有 IP 都通告，参数 1 是不同网段需要通信的时候才通告，有死亡时间，过一段时间，该 ARP 表自动消失，参数 2 是使用最优的 IP 进行 ARP 通告，不是对外接口(比如 loopback)的永不通告&lt;/li>
&lt;/ol>
&lt;/li>
&lt;/ol>
&lt;/li>
&lt;/ol>
&lt;/li>
&lt;li>所以，为了满足 dr 类型的需要，arp_ignore 设置为 1（RS 响应 arp 通告的时候 VIP 不在接收 arp 请求这个接口上就不会响应），arp_announce 需要设置为 2(RS 在发送 arp 通告的时候不使用 VIP 作为源 IP)，该配置为内核参数配置，在/proc/sys/net/ipv4/conf/all 目录和/proc/sys/net/ipv4/conf/lo 目录下的两个文件进行配置&lt;/li>
&lt;li>再次注意：进行 RS 配置的时候，需要先修改 arp 的配置，再配置 lo 的 VIP。否则如果直接配置 VIP，则会使用 lo 的 VIP 来响应询问 VIP 在哪的 arp 通告，这时候 VIP 与 MAC 的对应关系就会一直变化，这样立刻就会发生 arp 抢夺&lt;/li>
&lt;/ol>
&lt;h2 id="tunip-tunneling">TUN(IP Tunneling)&lt;/h2>
&lt;p>即 IP 隧道技术实现的虚拟服务器。VS TUN 与 VSNAT 技术的报文转发方法不同，在 VS TUN 方式中，调度器采用 IP 隧道技术将用户请求转发到某个选中的 Real Server 上，而这个 Real Server 将直接响应用户的请求，不再经过前端调度器。此外， IP TUN 技术对 RealServer 的地域位置没有要求，其既可以与 Director Server 位于同一个网段，也可位于独立网络中。因此，在 VS TUN 方式中，调度器将只处理用户的报文请求，而无需进行转发， 故集群系统的响应速率相对而言得到极大提高。&lt;/p>
&lt;p>LVS/TUN
模型：在原请求 IP 报文之外新加一个 IP 首部(这个新添加的 IP 首部其源 IP 是 DIP,目标 IP 是 RIP),将报文发往挑选出的目标 RS.
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/zzd89g/1616132542822-64d36467-fa78-48c8-af3c-ea93ccfeea8b.jpeg" alt="">
TUN
TUN 类型工作流程(主要是为了容灾,因为 Director 与各 RS 是在不同网段中,所以可以存在于不同的物理空间)&lt;/p>
&lt;p>LVS TUN 类型特性&lt;/p>
&lt;p>1.RIP，DIP，VIP 都得是公网地址&lt;/p>
&lt;p>2.RS 的网关不会指向也不可能指向 DIP&lt;/p>
&lt;p>3.请求报文经过 Directory，但响应报文一定不经过 Director&lt;/p>
&lt;p>4.不支持端口映射&lt;/p>
&lt;p>5.RS 的 OS 必须得支持隧道功能 ??&lt;/p>
&lt;p>2.4 LVS/FULLNAT (LVS 默认不支持此类型)&lt;/p>
&lt;p>通过同时修改请求报文的源 IP 地址和目标 IP 地址进行转发&lt;/p>
&lt;p>报文件从客户端到调度器时的源 目标 IP : CIP&amp;ndash;&amp;gt;VIP&lt;/p>
&lt;p>报文从 Director 到 RS 时的源 目标 IP 分别是: DIP&amp;ndash;&amp;gt;RIP&lt;/p>
&lt;p>特点&lt;/p>
&lt;ol>
&lt;li>VIP 是公网地址,RIP 和 DIP 是私网地址,且通常不在同一 IP 网络,因此,RIP 的网关一般不会指向 DIP&lt;/li>
&lt;li>RS 收到的请求报文源地址是 DIP,因此只需响应给 DIP, 但 Dirctor 还要将其发往 Client&lt;/li>
&lt;li>请求和响应报文都经由 Dirctor&lt;/li>
&lt;li>支持端口映射.&lt;/li>
&lt;/ol>
&lt;p>lvs-tun(ip tunneling) # 在原请求 IP 报文之外新加一个 IP 首部，IP 隧道技术&lt;/p>
&lt;ol>
&lt;li>不修改请求报文的 IP 首部，通过在原有的 IP 首部之外，再封装一个 IP 首部(比如为了运送一袋米，我扛着米运相当于 IP 首部，我骑着驴送，驴相当于新封装的 IP 首部)&lt;/li>
&lt;li>调度器收到请求报文时，再封装一层 IP 首部，把源 IP 至目标 IP 中的的 CIP 至 VIP 放在 DIP 至 RIP 的报文里面，DIP 至 RIP 相当于路由，所以可以不在同一网段,并且 RS 必须支持隧道技术，在解封装的时候，必须明白为什么在拆开 IP 首部之后还有一层 IP 首部&lt;/li>
&lt;li>不支持端口映射，且 RS 的网关不能指向 DIP。&lt;/li>
&lt;/ol>
&lt;p>lvs-fullnat # 修改请求报文的源和目标 IP&lt;/p>
&lt;ol>
&lt;li>调度器同时修改请求报文的目标地址和源地址进行转发。把源 IP 和目标 IP 从 CIP—VIP 改成 DIP—RIP&lt;/li>
&lt;li>VIP 是公网地址，RIP 和 DIP 是私网地址，二者无须在同一网络中&lt;/li>
&lt;li>RS 接收到的请求报文的源地址为 DIP，因为要响应给 DIP&lt;/li>
&lt;li>调度器一样要承担很大压力&lt;/li>
&lt;/ol>
&lt;h2 id="note">Note&lt;/h2>
&lt;ol>
&lt;li>为什么在 Director 上除了 DIP 本身还需要一个单独的 VIP，而不可以把 DIP 当做 VIP 来用
&lt;ol>
&lt;li>如果 DIP 与 VIP 一样，那么在 Director 发送 arp 广播的时候，RS 在收到 arp 广播后，回应的报文会回给自己(因为 RS 设备上 lo 网卡上的 VIP 就是 DIP)，这样调度器上的 arp 表里就无法获得后端 RS 的 MAC 地址。如果多了一个 VIP，那么 RS 在回应 Director 的 arp 广播时，就不会回应到自己身上，因为 RS 的 lo 网卡上的 IP 为单独的 VIP，而不同于 DIP。&lt;/li>
&lt;li>结论：在调度器上，除了本身的 DIP 以外，必须要一个 VIP&lt;/li>
&lt;/ol>
&lt;/li>
&lt;li>http 本身是 stateless 无状态的，无法追踪目标来源
&lt;ol>
&lt;li>session 保持机制：会话保持机制，保证 http 协议可以在用户终端连接再次连接后还能存有之前的操作记录
&lt;ol>
&lt;li>session 绑定：将来自于同一个 client 的请求始终绑定在一个 RS 上，不会被调度到别的 RS 上&lt;/li>
&lt;li>session 集群:&lt;/li>
&lt;li>session 服务器&lt;/li>
&lt;/ol>
&lt;/li>
&lt;/ol>
&lt;/li>
&lt;/ol>
&lt;h1 id="scheduling调度-方法">Scheduling(调度) 方法&lt;/h1>
&lt;p>LVS 的调度方法分为两类(静态算法、动态算法)，共 10 种&lt;/p>
&lt;p>在转发方式选定的情况下，采用哪种调度算法将决定整个负载均衡的性能表现。不同的算法适用于不同的生产环境，有时可能需要针对特殊需求自行设计调度算法。&lt;/p>
&lt;ol>
&lt;li>静态方法：仅根据算法本身进行调度（注重起点公平）
&lt;ol>
&lt;li>RR(Round Robin) # 轮询，论调，轮流调度，第一个请求给 RS1，第二个请求给 RS2，第 n 个请求给 RSn，第 n+1 个请求给 RS1。。。。。&lt;/li>
&lt;li>WRR(Weighted RR) # 加权(Weight)轮询，能者多劳，给 RS1 一个请求，就给 RS2 几倍的请求&lt;/li>
&lt;li>SH(Source hash) # 源地址哈希，实现 session 保持的机制,来自同一个 IP 的请求将始终调度到同一个 RS&lt;/li>
&lt;li>DH(Destination Hash) # 目标地址哈希，只要请求的是同一个资源，则将请求调度到同一个 RS,比如 CDN 中所有用户都请求一个资源被调度到一台 RS 上&lt;/li>
&lt;/ol>
&lt;/li>
&lt;li>动态方法：根据算法以及各 RS 的当前负载状态进行调度 Overhead
&lt;ol>
&lt;li>LC(Least Connection) # 最小连接数，新来的请求报文调度给连接数最小的 RS
&lt;ol>
&lt;li>Overhead=Active*256+Inactive&lt;/li>
&lt;/ol>
&lt;/li>
&lt;li>WLC(Weighted LC) # 加权(Weight)最小连接数 默认的调度器类型
&lt;ol>
&lt;li>Overhead=(Active*256+Inactive)/weight&lt;/li>
&lt;/ol>
&lt;/li>
&lt;li>SED(Shortest Expection Delay) # 最短期望延迟
&lt;ol>
&lt;li>Overhead=(Active+1)*256/weight&lt;/li>
&lt;/ol>
&lt;/li>
&lt;li>NQ(Never Queue) # SED 算法的改进&lt;/li>
&lt;li>LBLC(Locality-Based LC) # 基于本地的最小连接数，动态的 DH 算法，正向代理情形下的 cache server 调度&lt;/li>
&lt;li>LBLCR(Locality-Based LC with Replication) # 带复制功能的 LBLC，相当于几台 RS(HCS)中的资源可以互相共享&lt;/li>
&lt;/ol>
&lt;/li>
&lt;/ol>
&lt;h1 id="ldirectord-技术介绍以及产生的原因">LDirectorD 技术介绍，以及产生的原因&lt;/h1>
&lt;p>IPVS 有一个缺陷，无法检查后端 Real Server 的健康状态，就是使用 HA 给 LVS 中的 Director 实现了高可用，也不一定能保证后端的各 RS 可以正常响应用户的请求，当其中一台 RS 不能使用时，访问 vip，还会去调度 down 掉的这台 RS，并返回一个错误的页面。这种情况是不合理的，所以我们需要一个 LVS 的健康检查机制，以便当 RS 无法响应时，可以及时通知给 Director，让其不再把请求调度给这台坏掉的 RS 上。为了实现这个功能，就用到了 heartbea 中的 ldirectord，ldirectord 以守护进程运行在后台，提供生成规则以及 Health check 健康检查
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/zzd89g/1616132542796-003ca683-5cd4-4f31-85ec-6b92628f2017.jpeg" alt="">
该程序依赖于自己的配置文件生成 ipvs 规则，因此，定义集群服务、添加 RS、调度方法等都在配置文件中指定，而无须手动用 ipvsadm 命令更改&lt;/p>
&lt;h2 id="配置">配置&lt;/h2>
&lt;p>/etc/ha.d/ldirectord.cf&lt;/p>
&lt;h2 id="ldirectordcf-文件说明">ldirectord.cf 文件说明&lt;/h2>
&lt;p>&lt;strong>Global Directives&lt;/strong> # 全局指令，对所有的 Virtual Services 都有效&lt;/p>
&lt;ul>
&lt;li>checktimeout=3 # 检查的超时时间，当对 RS 的健康检查时间超过 3 秒的时候的则认为该 RS 不可用&lt;/li>
&lt;li>checkinterval=1 # 检查时间间隔，即每 1 秒都对后端 RS 进行一次健康检查&lt;/li>
&lt;li>#fallback=127.0.0.1:80 #&lt;/li>
&lt;li>autoreload=yes # 该配置文件是否自动装载&lt;/li>
&lt;li>#logfile=&amp;quot;/var/log/ldirectord.log&amp;quot; # 指明日志文件的 PATH&lt;/li>
&lt;li>#logfile=&amp;ldquo;local0&amp;rdquo; #&lt;/li>
&lt;li>#emailalert=&amp;ldquo;&lt;a href="mailto:admin@x.y.z">admin@x.y.z&lt;/a>&amp;rdquo; # 警告信息发送的邮箱地址&lt;/li>
&lt;li>#emailalertfreq=3600 # 每隔多久发送一次警告信息到邮箱&lt;/li>
&lt;li>#emailalertstatus=all # 通知的 email 信息是全部&lt;/li>
&lt;li>quiescent=no # 静默工作模式&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>Sample for an XXXXX&lt;/strong> # 对于多种虚拟服务的配置样例，直接修改这一部分内容，可以实现健康检查的基本模式，其中前三行为必须要定义的 LVS 的定义以及调度规则，剩下的所有行定义的都是为 ldirectord 对后端 RS 的健康检查方式，当这些健康检查方式失败的时候，则说明该 RS 不可用&lt;/p>
&lt;ul>
&lt;li>virtual=IP:PORT # 定义 VIP 的地址和端口&lt;/li>
&lt;li>real=IP[[-&amp;gt;IP]:[PORT]] TYPE # 定义 RS 的 IP 地址和 LVS 类型，类型名介绍详见 LB 的 Packet-Forwarding-Method(LVS Type)内容，其中-&amp;gt;IP 可以实现从哪个 IP 至哪个 IP 的地址段的定义
&lt;ul>
&lt;li>gate # TYPE 为 DR 类型&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>fallback=IP:PORT TYPE # 定义当 RS 全部失效时，使用的 server 的地址，端口，LVS 类型。&lt;/li>
&lt;li>scheduler=SCHEDULER # 定义 LB 集群中的调度规则，规则类型详见 LB 中的 Director 调度方法&lt;/li>
&lt;li>service=TYPE # 定义健康检查的应用层 Protocol，注意：只有当 checktype 指定为 negotiate 的时候，该定义才有意义
&lt;ul>
&lt;li>TYPE 类型包括：ftp|http|stmp|mysql 等&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>protocol=tcp # 定义健康检查的传输层 Protocol&lt;/li>
&lt;li>checktype=negotiate # 定义健康检查的方法
&lt;ul>
&lt;li>connect # 传输层检查，向对方端口尝试发送连接请求&lt;/li>
&lt;li>negotiate # 应用层检查协商方法&lt;/li>
&lt;li>ping # 网络层检查，ICMP 协议&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>checkport=80 # 定义健康检查的端口号&lt;/li>
&lt;li>request=&amp;ldquo;index.html&amp;rdquo; # 定义健康检查请求目标 server 的哪个页面&lt;/li>
&lt;li>receive=&amp;ldquo;Test Page&amp;rdquo; # 定义健康检查中 request 中所定义的页面请求后回复的内容包含什么信息&lt;/li>
&lt;li>virtualhost=www.x.y.z # 定义健康检查虚拟主机的主机名&lt;/li>
&lt;/ul></description></item><item><title>Docs: Microsoft Management Console</title><link>https://desistdaydream.github.io/docs/IT%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Y.Windows-%E7%AE%A1%E7%90%86/Microsoft_Management_Console/Microsoft_Management_Console/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/IT%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Y.Windows-%E7%AE%A1%E7%90%86/Microsoft_Management_Console/Microsoft_Management_Console/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Microsoft_Management_Console">Wiki，Microsoft Management Console&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>&lt;strong>Microsoft Management Console(微软管理控制台，简称 MMC)&lt;/strong> 是 Microsoft Windows 的一个组件，它为系统管理员和高级用户提供了一个用于配置和监控系统的界面。它于 1998 年首次与 Windows NT 4.0 的 Option Pack 一起推出，后来与 Windows 2000 及其后续版本预捆绑在一起。&lt;/p>
&lt;h1 id="msc">msc&lt;/h1>
&lt;p>MSC(Microsoft Snap-In Control)文件，是&lt;a href="https://baike.baidu.com/item/%E5%BE%AE%E8%BD%AF%E7%AE%A1%E7%90%86%E6%8E%A7%E5%88%B6%E5%8F%B0/267174?fromModule=lemma_inlink">微软管理控制台&lt;/a>MMC(Microsoft Management Console)用来添加/删除的嵌入式管理单元文件。通常通过MMC来管理，可点击“文件”菜单中的“添加/删除管理单元”操作来管理当前系统中已经安装的MSC文件。可以点击开始/运行，然后输入下列文件名就可以打开相应的控制窗口。&lt;/p></description></item><item><title>Docs: Motherboard</title><link>https://desistdaydream.github.io/docs/IT%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/0.%E8%AE%A1%E7%AE%97%E6%9C%BA/Motherboard/Motherboard/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/IT%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/0.%E8%AE%A1%E7%AE%97%E6%9C%BA/Motherboard/Motherboard/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Motherboard">Wiki，Motherboard&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>&lt;strong>Motherboard(主板)&lt;/strong> 是通用计算机和其他可扩展系统中的 &lt;strong>&lt;a href="https://en.wikipedia.org/wiki/Printed_circuit_board">Printed circuit board&lt;/a>(印刷电路板，简称 PCB)&lt;/strong>。主板用于承载一套系统中许多关键电子组件之间的通信，例如 &lt;a href="https://desistdaydream.github.io/docs/IT%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/0.%E8%AE%A1%E7%AE%97%E6%9C%BA/CPU/CPU.md">CPU&lt;/a>、&lt;a href="https://desistdaydream.github.io/docs/IT%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/0.%E8%AE%A1%E7%AE%97%E6%9C%BA/Memory/Memory.md">Memory&lt;/a>，并为其他外围设备提供连接器。与 &lt;strong>&lt;a href="https://en.wikipedia.org/wiki/Backplane">Backplane&lt;/a>(背板)&lt;/strong> 不同，主板通常包含重要的子系统，例如中央处理器、芯片组的输入/输出和内存控制器、接口连接器以及其他为通用应用集成的组件。&lt;/p>
&lt;blockquote>
&lt;p>主板还有很多其他英文单词：&lt;strong>mainboard&lt;/strong>, &lt;strong>main&lt;/strong> &lt;strong>circuit board&lt;/strong>, &lt;strong>mb&lt;/strong>, &lt;strong>mboard&lt;/strong>, &lt;strong>backplane board&lt;/strong>, &lt;strong>base board&lt;/strong>, &lt;strong>system board&lt;/strong>, &lt;strong>logic board&lt;/strong> (only in Apple computers) or &lt;strong>mobo&lt;/strong>&lt;/p>
&lt;/blockquote>
&lt;p>主板特指具有扩展能力的 PCB。顾名思义，这块板通常被称为连接到它的所有组件的“母板”，通常包括外围设备、接口卡和子板：声卡、视频卡、网卡、主机总线适配器、电视调谐器卡, IEEE 1394 卡；以及各种其他自定义组件。&lt;/p>
&lt;p>类似地，术语主板是指具有单板且没有额外扩展或能力的设备，例如激光打印机、电视机、洗衣机、手机和其他扩展能力有限的嵌入式系统中的控制板。&lt;/p>
&lt;h1 id="usb">USB&lt;/h1>
&lt;p>&lt;strong>Universal Serial Bus(通用串行总线，简称 USB)&lt;/strong> 是一种用于连接计算机和外部设备的通用接口标准。USB 接口已经成为现代电子设备中最为常用的接口之一，可用于连接键盘、鼠标、打印机、扫描仪、移动硬盘、闪存驱动器、智能手机等各种设备。&lt;/p></description></item><item><title>Docs: Netfilter 流量控制系统</title><link>https://desistdaydream.github.io/docs/IT%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2.Kernel%E5%86%85%E6%A0%B8/8.Network-%E7%AE%A1%E7%90%86/Linux-%E7%BD%91%E7%BB%9C%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6/Netfilter-%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6%E7%B3%BB%E7%BB%9F/Netfilter-%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6%E7%B3%BB%E7%BB%9F/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/IT%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2.Kernel%E5%86%85%E6%A0%B8/8.Network-%E7%AE%A1%E7%90%86/Linux-%E7%BD%91%E7%BB%9C%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6/Netfilter-%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6%E7%B3%BB%E7%BB%9F/Netfilter-%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6%E7%B3%BB%E7%BB%9F/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://www.netfilter.org/index.html">Netfilter 官网&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.netfilter.org/documentation/index.html">Netfilter 官方文档&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Netfilter">Wiki-Netfilter&lt;/a>&lt;/li>
&lt;li>&lt;a href="http://arthurchiao.art/index.html">arthurchiao.art 的文章&lt;/a>：
&lt;ul>
&lt;li>&lt;a href="http://arthurchiao.art/blog/deep-dive-into-iptables-and-netfilter-arch-zh/">[译] 深入理解 iptables 和 netfilter 架构&lt;/a>&lt;/li>
&lt;li>&lt;a href="http://arthurchiao.art/blog/conntrack-design-and-implementation-zh/">连接跟踪（conntrack）：原理、应用及 Linux 内核实现&lt;/a>&lt;/li>
&lt;li>&lt;a href="http://arthurchiao.art/blog/nat-zh/">[译] NAT - 网络地址转换（2016）&lt;/a>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;h2 id="netfilter">Netfilter&lt;/h2>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/gral7u/1616165512374-db897dd5-0704-42f2-a1d8-441af05f247c.jpeg" alt="">&lt;/p>
&lt;p>Netfilter 是 Linux 操作系统核心层内部的一个数据包处理模块集合的统称。一种网络筛选系统，对数据包进入以及出去本机进行的一些控制与管理。该功能的所有模块可以通过下图所示的目录进行查找，其中还包括 ipvs 等。
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/gral7u/1616165512330-720231f3-a4f2-4a51-96cf-137a36724b74.jpeg" alt="">
Netfilter 项目支持如下功能&lt;/p>
&lt;ul>
&lt;li>网络地址转换(Network Address Translate)&lt;/li>
&lt;li>数据包过滤&lt;/li>
&lt;li>数据包日志记录&lt;/li>
&lt;li>用户空间数据包队列&lt;/li>
&lt;li>其他数据包处理&lt;/li>
&lt;li>等等&lt;/li>
&lt;/ul>
&lt;p>Netfilter Hooks 是 Linux 内核中的一个框架，它会让 Netfilter 的模块在 Linux 网络堆栈的不同位置注册回调函数。然后，为遍历 Linux 网络堆栈中相应 Hook 的每个数据包调用已注册的回调函数。&lt;/p>
&lt;ul>
&lt;li>用白话说：内核加入了 Netfilter 模块后，每个数据包进来之后，都会经过五个 Hooks 点来处理，以便决定每个数据包的走向。&lt;/li>
&lt;/ul>
&lt;h2 id="hooks">Hooks&lt;/h2>
&lt;p>hooks function(钩子函数) 是 Linux 网络栈中的流量检查点。所有流量通过网卡进入内核或从内核出去都会调用 Hook 函数来进行检查，并根据其规则进行过滤。Netfilter 框架中一共有 5 个 Hook，就是下文定义的“五链”。&lt;/p>
&lt;ul>
&lt;li>当一个数据包在其中一个 Hooks 中匹配到自己的规则后，则会进入下一个 Hook 寻找匹配自身的规则，直到将 5 个 Hook 挨个匹配一遍。&lt;/li>
&lt;li>可以把 Hook 想象成地铁站的闸机，通过闸机的人，就是数据流量，这个能不能从闸机过去，则看闸机对这个人身份验证的结果，是放行还是阻止&lt;/li>
&lt;/ul>
&lt;h2 id="iptabelesnftables">iptabeles/nftables&lt;/h2>
&lt;p>工作于用户空间的管理工具，对 5 个 hook 进行规则管理，iptabels 或 nftables 进程，开机后，只是把设定好的规则写进 hook 中&lt;/p>
&lt;p>Netfilter 所设置的规则是存放在内核内存中的，Iptables 是一个应用层(Ring3)的应用程序，它通过 Netfilter 放出的接口来对存放在内核内存中的 Xtables(Netfilter 的配置表)进行修改(这是一个典型的 Ring3 和 Ring0 配合的架构)&lt;/p>
&lt;h1 id="五链chain">五链(Chain)&lt;/h1>
&lt;p>把每个 Hook 上的规则都串起来类似于一条链子，所以称为链，一共 5 个 Hook，所以有 5 个 Chain。每个规则都是由“源 IP、目标 IP、端口、目标”等信息组合起来的。(i.e 对从哪来的或者到哪去的 IP 的哪个端口，要执行什么动作或‘引用什么 Chain 来对这个数据包执行什么动作’)&lt;/p>
&lt;ol>
&lt;li>&lt;strong>PREROUTING 链&lt;/strong> # 路由前，处理刚到达本机并在路由转发前的数据包。它会转换数据包中的目标 IP 地址（destination ip address），通常用于 DNAT(destination NAT)。处理完成之后分成两种情况，目的 IP 为本机网口则 INPUT，目的 IP 非本机网口则 FORWARD&lt;/li>
&lt;li>&lt;strong>INPUT 链&lt;/strong> # 进入，处理来自外部的数据。&lt;/li>
&lt;li>&lt;strong>FORWARD 链&lt;/strong> # 转发，将数据转发到本机的其他网络设备上。(需要开启 linux 的 IP 转发功能 net.ipv4.ip_forward=1 才会进入该流程；就算 ping 的是本机的其余网络设备上的 IP，也是由接收该数据包的网络设备进行回应)，FORWARD 的行为类似于路由器，系统中每个网络设备就是路由器上的每个端口，只有打开转发功能，才可以把数据包路由到其余端口上。
&lt;ol>
&lt;li>虚拟化或容器技术中，如果一台设备中有多个网段，一般都会打开转发功能，以实现不同网段路由互通的效果。&lt;/li>
&lt;li>或者服务器作为 VPN 使用时，由于不同网络设备所属网段不同，也需要打开转发功能。&lt;/li>
&lt;li>等等&lt;/li>
&lt;/ol>
&lt;/li>
&lt;li>&lt;strong>OUTPUT 链&lt;/strong># 出去，处理向外发送的数据。&lt;/li>
&lt;li>&lt;strong>POSTROUTING 链&lt;/strong># 路由后，处理即将离开本机的数据包。它会转换数据包中的源 IP 地址（source ip address），通常用于 SNAT（source NAT）。(该路由是通过 Linux 中定义的 route 规则发送的，与内核的 ip_forward 无关)&lt;/li>
&lt;li>&lt;strong>自定义链&lt;/strong># 用户自己定义的链，不会调用系统 Hook，而是由系统默认的 5 个链在 target 中定义引用&lt;/li>
&lt;/ol>
&lt;h2 id="规则rule匹配match规则的匹配条件匹配的用法详见iptables-框架工具介绍">规则(Rule)匹配(Match)：(规则的匹配条件)匹配的用法详见：iptables 框架工具介绍&lt;/h2>
&lt;p>规则，需要有具体的内容才能称为规则，所以 Match 就是规则中的具体内容。&lt;/p>
&lt;p>每条链上的规则，需要对流量进行匹配后才能对该流量进行相应的处理，匹配内容包括“数据包的源地址、目标地址、协议、目标等”，(e.g.这个数据使用哪个协议从哪来的到哪去的目标是什么)
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/gral7u/1616165512349-f2e6f4c5-d617-4b04-a432-f9a7389120df.jpeg" alt="">
Match 功能的实现依赖于模块(类似于内核的模块)，比如右图，可以使用命令 rpm -ql iptables | grep &amp;ldquo;.so&amp;quot;查看都有哪些模块，其中的 XXX.so 就是各个功能的模块，大写字母是 target 所用的模块，小写字母是基本匹配与扩展匹配所用的模块&lt;/p>
&lt;ol>
&lt;li>基本匹配：源地址、目标地址、协议、入流网卡、出流网卡&lt;/li>
&lt;li>扩展匹配：用于对基本匹配的内容扩充，包括两类，普通的扩展匹配和基于
&lt;ol>
&lt;li>通用扩展匹配，可以直接使用。&lt;/li>
&lt;li>基于基本匹配的扩展匹配。需要有基本匹配规则才可以使用。
&lt;ol>
&lt;li>e.g.需要匹配某些端口，这类匹配必须基于 tcp 匹配规则上使用，否则无效(e.g.-p tcp -m tcp -m multiport &amp;ndash;dport22,23,24)&lt;/li>
&lt;/ol>
&lt;/li>
&lt;/ol>
&lt;/li>
&lt;li>目标(target)：每个规则中的目标。即在每条链上对每个进出流量匹配上之后应该执行什么动作，Target 包括以下几种
&lt;ol>
&lt;li>ACCEPT # 允许流量通过&lt;/li>
&lt;li>REJECT # 拒绝流量通过&lt;/li>
&lt;li>DROP # 丢弃，不响应，发送方无法判断是被拒绝&lt;/li>
&lt;li>RETURN # 返回调用链&lt;/li>
&lt;li>MARK # 做防火墙标记&lt;/li>
&lt;li>用于 nat 表的 target
&lt;ol>
&lt;li>DNAT|SNAT #{目的|源}地址转换&lt;/li>
&lt;li>REDIRECT # 端口重定向&lt;/li>
&lt;li>MASQUERADE # 地址伪装类似于 SNAT，但是不用指明要转换的地址，而是自动选择要转换的地址，用于外部地址不固定的情况&lt;/li>
&lt;/ol>
&lt;/li>
&lt;li>用于 raw 表的 target
&lt;ol>
&lt;li>NOTRACK # raw 表专用的 target，用于对匹配规则进行 notrack(不跟踪)处理&lt;/li>
&lt;/ol>
&lt;/li>
&lt;li>LOG # 将数据包的相关信息记录日志，执行完该目标后，会继续匹配后面的规则&lt;/li>
&lt;li>引用自定义链 # 直接使用“-j 自定义链的名称”即可，让基本 5 个 Chain 上匹配成功的数据包继续执行自定义链上的规则。&lt;/li>
&lt;/ol>
&lt;/li>
&lt;/ol>
&lt;p>注意，这里面的路由指数据包在 Linux 本机内部路由&lt;/p>
&lt;h2 id="linux-数据包路由原理iptablesnetfilter-入门学习">Linux 数据包路由原理、Iptables/netfilter 入门学习&lt;/h2>
&lt;p>数据流处理流程简介&lt;/p>
&lt;p>注意：每个数据包在 CHAIN 中匹配到适用于自己的规则之后，则直接进入下一个 CHAIN，而不会遍历 CHAIN 中每条规则去挨个匹配适用于自己的规则。比如下面两种情况&lt;/p>
&lt;p>INPUT 链默认 DROP，匹配第一条：目的端口是 9090 的数据 DROP，然后不再检查下一项，那么 9090 无法访问&lt;/p>
&lt;pre>&lt;code>-P INPUT DROP
-A INPUT -p tcp -m tcp --dport 9090 -j DROP
-A INPUT -p tcp -m tcp --dport 9090 -j ACCEPT
&lt;/code>&lt;/pre>
&lt;p>INPUT 链默认 DROP，匹配第一条目的端口是 9090 的数据 ACCEPT，然后不再检查下一条规则，则 9090 可以访问&lt;/p>
&lt;pre>&lt;code>-P INPUT DROP
-A INPUT -p tcp -m tcp --dport 9090 -j ACCEPT
-A INPUT -p tcp -m tcp --dport 9090 -j DROP
&lt;/code>&lt;/pre>
&lt;p>匹配条件：根据协议报文特征指定&lt;/p>
&lt;ol>
&lt;li>基本匹配条件&lt;/li>
&lt;li>扩展匹配条件&lt;/li>
&lt;/ol>
&lt;p>处理动作：&lt;/p>
&lt;ol>
&lt;li>内建处理机制&lt;/li>
&lt;li>自定义处理机制&lt;/li>
&lt;li>注意：自定义的链不会有流量经过，而是在主要的 5 链中引用自定义链上的规则，来实现对流量的处理&lt;/li>
&lt;/ol>
&lt;p>下图是从服务器外部进入网卡，再进入网络栈的数据流走向，如果直接是服务器内部服务生成的数据包进入网络栈，则不适用于该图
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/gral7u/1616165512341-aeeeff06-b602-4340-bc4f-cd582144f85f.jpeg" alt="">&lt;/p>
&lt;ol>
&lt;li>当一个数据包进入网卡时，数据包首先进入 PREROUTING 链，在 PREROUTING 链中我们有机会修改数据包的 DestIP(目的 IP)，然后内核的&amp;quot;路由模块&amp;quot;根据&amp;quot;数据包目的 IP&amp;quot;以及&amp;quot;内核中的路由表&amp;quot;判断是否需要转送出去(注意，这个时候数据包的 DestIP 有可能已经被我们修改过了)&lt;/li>
&lt;li>如果数据包就是进入本机的(即数据包的目的 IP 是本机的网口 IP)，数据包就会沿着图向下移动，到达 INPUT 链。数据包到达 INPUT 链后，任何进程都会收到它&lt;/li>
&lt;li>本机上运行的程序也可以发送数据包，这些数据包经过 OUTPUT 链，然后到达 POSTROTING 链输出(注意，这个时候数据包的 SrcIP 有可能已经被我们修改过了)&lt;/li>
&lt;li>如果数据包是要转发出去的(即目的 IP 地址不再当前子网中)，且内核允许转发，数据包就会向右移动，经过 FORWARD 链，然后到达 POSTROUTING 链输出(选择对应子网的网口发送出去)&lt;/li>
&lt;/ol>
&lt;p>出于安全考虑，Linux 系统默认是禁止数据包转发的。所谓转发即当主机拥有多于一块的网卡时，其中一块收到数据包，根据数据包的目的 ip 地址将包发往本机另一网卡，该网卡根据路由表继续发送数据包。这通常就是路由器所要实现的功能。&lt;/p>
&lt;p>配置 Linux 系统的 ip 转发功能，首先保证硬件连通，然后打开系统的转发功能，less /proc/sys/net/ipv4/ip_forward，该文件内容为 0，表示禁止数据包转发，1 表示允许，将其修改为 1。可使用命令 echo &amp;ldquo;1&amp;rdquo; &amp;gt; /proc/sys/net/ipv4/ip_forward 修改文件内容，重启网络服务或主机后效果不再。若要其自动执行，可将命令 echo &amp;ldquo;1&amp;rdquo; &amp;gt; /proc/sys/net/ipv4/ip_forward 写入脚本/etc/rc.d/rc.local 或者 在/etc/sysconfig/network 脚本中添加 FORWARD_IPV4=&amp;ldquo;YES&amp;rdquo;&lt;/p>
&lt;h1 id="natnetwork-address-translation网络地址转换">NAT(Network Address Translation)网络地址转换&lt;/h1>
&lt;p>NAT 为了安全性而产生的，主要用来隐藏本地主机的 IP 地址&lt;/p>
&lt;h2 id="snatsource-源地址转换针对请求报文的源地址而言">SNAT：Source 源地址转换，针对请求报文的源地址而言&lt;/h2>
&lt;p>当想访问外网的时候，把源地址转换，作用于 POSTROUTING 链&lt;/p>
&lt;p>常用于内网私网地址转换成公网地址，比如家用路由器&lt;/p>
&lt;h2 id="dnatdestination-目的地址转换针对请求报文的目标地址而言">DNAT：Destination 目的地址转换，针对请求报文的目标地址而言&lt;/h2>
&lt;p>当从外部访问某 IP 时，把目的 IP 转换，作用于 PREROUTING、FORWARD 链&lt;/p>
&lt;p>把内网中的服务器发布到外网中去，&lt;/p>
&lt;p>常用于公网访问一个公司的公网 IP，但是由私网 IP 来提供服务，比如 LVS 的 nat 模型&lt;/p>
&lt;p>比如在公司内网中提供一个 web 服务，但是由于是私网地址，来自互联网的任何请求无法送达这台 web 服务器，这时候我们可以对外宣称公司的 web 服务在一个公网的 IP 地址上，但是公网的 IP 地址所在服务器上又没有提供 web 服务，这时候，来自外网访问的请求，全部 DNAT 成私网 IP，即可对外提供请求。&lt;/p>
&lt;h2 id="注意">注意&lt;/h2>
&lt;p>由于 SNAT 与 DNAT 在描述的时候主要是都是针对请求报文而言的，那么当地址转换以后，响应报文响应的是转换后的地址，这时候就无法把响应请求送还给发起请求的设备了，这怎么办呢？这时候，同样需要一个地址转换，只不过通过 NAT 机制自行完成的，如何自动完成呢？这里面会有一个连接追踪机制，跟踪每一个数据连接（详见：&lt;a href="docs/IT%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2.Kernel(%E5%86%85%E6%A0%B8)/8.Network%20%E7%AE%A1%E7%90%86/Linux%20%E7%BD%91%E7%BB%9C%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6/Connnection%20Tracking(%E8%BF%9E%E6%8E%A5%E8%B7%9F%E8%B8%AA).md">Connnection Tracking(连接跟踪)&lt;/a>），当响应报文到来的时候，根据连接追踪表中的信息记录的请求报文是怎么转换的相关信息，来对响应报文进行 NAT 转换。&lt;/p></description></item></channel></rss>