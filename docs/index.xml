<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>断念梦 – 文档</title><link>https://desistdaydream.github.io/docs/</link><description>Recent content in 文档 on 断念梦</description><generator>Hugo -- gohugo.io</generator><atom:link href="https://desistdaydream.github.io/docs/index.xml" rel="self" type="application/rss+xml"/><item><title>Docs: 📹11.多媒体</title><link>https://desistdaydream.github.io/docs/11.%E5%A4%9A%E5%AA%92%E4%BD%93/11.%E5%A4%9A%E5%AA%92%E4%BD%93/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/11.%E5%A4%9A%E5%AA%92%E4%BD%93/11.%E5%A4%9A%E5%AA%92%E4%BD%93/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Multimedia">Multimedia&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>&lt;strong>Multimedia(多媒体)&lt;/strong> 是一种通信形式，它使用不同的内容形式（例如&lt;a href="https://en.wikipedia.org/wiki/Text_(literary_theory)" title="文本（文学理论）">文本&lt;/a>、&lt;a href="https://en.wikipedia.org/wiki/Sound" title="声音">音频&lt;/a>、&lt;a href="https://en.wikipedia.org/wiki/Image" title="图像">图像&lt;/a>、&lt;a href="https://en.wikipedia.org/wiki/Animation" title="动画片">动画&lt;/a>或&lt;a href="https://en.wikipedia.org/wiki/Video" title="视频">视频）&lt;/a>组合成一个单一的交互式演示，这与传统的大众媒体（例如印刷材料或录音）不同，后者的功能很少用户之间没有交互。流行的多媒体示例包括视频播客、音频幻灯片和动画视频。多媒体还包含有效交互通信的原理和应用，例如软件、硬件和其他技术的构建块。多媒体的五个主要组成部分是文本、图像、音频、视频和动画。&lt;/p>
&lt;h1 id="名词解释">名词解释&lt;/h1>
&lt;p>帧&lt;/p>
&lt;p>帧宽度&lt;/p>
&lt;p>帧高度&lt;/p>
&lt;p>帧率&lt;/p>
&lt;p>编解码器&lt;/p>
&lt;p>帧总数&lt;/p>
&lt;p>格式&lt;/p>
&lt;p>模式&lt;/p>
&lt;p>亮度&lt;/p>
&lt;p>对比度&lt;/p>
&lt;p>饱和度&lt;/p>
&lt;p>色调&lt;/p>
&lt;p>增益&lt;/p>
&lt;p>曝光&lt;/p>
&lt;p>RGB&lt;/p>
&lt;p>白平衡&lt;/p>
&lt;p>矫正&lt;/p></description></item><item><title>Docs: 1.Bootloader</title><link>https://desistdaydream.github.io/docs/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/1.Bootloader/1.Bootloader/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/1.Bootloader/1.Bootloader/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Bootloader">Wiki,Bootloader&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>&lt;strong>Bootloader(引导加载程序)&lt;/strong> 是负责 &lt;a href="https://en.wikipedia.org/wiki/Booting">booting(引导)&lt;/a> 计算器的软件。通常也被称为 Bootstrap Loader、Bootstrap。&lt;/p>
&lt;p>当计算机关闭时，操作系统、应用程序代码和数据 ‍‌ 仍存储在非易失性存储器中。当计算机开机时，它通常没有操作系统或其随机存取存储器 (RAM) 中的加载程序。计算机首先执行存储在只读存储器（ROM，以及后来的 EEPROM、NOR 闪存）中的相对较小的程序以及一些需要的数据，以初始化 RAM（特别是在 x86 系统上），访问非易失性设备（通常是块设备，例如 NAND 闪存）或可以将操作系统程序和数据加载到 RAM 中的设备。&lt;/p>
&lt;h1 id="配置">配置&lt;/h1>
&lt;p>&lt;strong>/boot/*&lt;/strong> # 所有关于系统引导启动的配置信息，都在该目录下
&lt;strong>/boot/grub2/&lt;/strong> #
&lt;strong>/etc/default/grub&lt;/strong> #&lt;/p>
&lt;h1 id="引导管理命令行工具">引导管理命令行工具&lt;/h1>
&lt;p>grub2-*
grubby
grub2-mkconfig&lt;/p></description></item><item><title>Docs: 1.Linux Kernel</title><link>https://desistdaydream.github.io/docs/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2.Kernel%E5%86%85%E6%A0%B8/1.Linux-Kernel/1.Linux-Kernel/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2.Kernel%E5%86%85%E6%A0%B8/1.Linux-Kernel/1.Linux-Kernel/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://github.com/torvalds">Linus Torvalds&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://github.com/torvalds/linux">GitHub,Linux 内核项目&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.kernel.org/">官网&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.kernel.org/doc/html/latest/">官方文档&lt;/a>
&lt;ul>
&lt;li>&lt;a href="https://www.infradead.org/~mchehab/kernel_docs/index.html">https://www.infradead.org/~mchehab/kernel_docs/index.html&lt;/a> 这是哪里的官方文档？&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;a href="https://www.kernel.org/doc/man-pages/index.html">官方 Manual(手册)&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Kernel_(operating_system)">Wiki,Kernel&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki//boot/">Wiki,/boot&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Vmlinux">Wiki,vmlinux&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Initial_ramdisk">Wiki,Initial ramdisk&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/System.map">Wiki,System.map&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://github.com/raspberrypi/linux">树莓派 Linux&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/8/html/managing_monitoring_and_updating_the_kernel/index">RedHat 官方文档,8-管理、监控和更新内核&lt;/a>&lt;/li>
&lt;li>&lt;a href="http://www.linfo.org/vmlinuz.html">http://www.linfo.org/vmlinuz.html&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.zhihu.com/question/22045825">知乎,initrd 和 initramfs 的区别&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>&lt;strong>Kernel(内核)&lt;/strong> 是一个作为操作系统核心的计算机程序，对系统中的一切具有完全控制权。它负责管理系统的进程、内存、设备驱动程序、文件和网络系统，决定着系统的性能和稳定性。&lt;/p>
&lt;p>Kernel 是计算器启动时首先加载程序之一，在 &lt;a href="https://desistdaydream.github.io/docs/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/1.Bootloader/1.Bootloader.md">Bootloader&lt;/a>并处理硬件和软件之间的交互。并且处理启动过程的其余部分、以及内存、外设、和来自软件的输入/输出请求，将他们转换为 CPU 的数据处理指令。&lt;/p>
&lt;h2 id="kernel-组成及系统调用">Kernel 组成及系统调用&lt;/h2>
&lt;p>Linux 内核由如下几部分组成：内存管理、进程管理、设备驱动程序管理、文件系统管理、网络管理等。如图：
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/fkp6xi/1616168349819-c21dd43c-79b7-4ec2-abd4-c8bb0e3c7686.jpeg" alt="">
**System Call Interface(系统调用接口，简称 SCI)**层提供了某些机制执行从用户空间到内核的函数调用。这个接口依赖于体系结构，甚至在相同的处理器家族内也是如此。SCI 实际上是一个非常有用的函数调用多路复用和多路分解服务。&lt;/p>
&lt;p>系统调用介绍详见 &lt;a href="https://desistdaydream.github.io/docs/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2.Kernel(%E5%86%85%E6%A0%B8)/3.System%20Call/System%20Call.md">System Call(系统调用)&lt;/a> 章节&lt;/p>
&lt;h2 id="linux-man-手册使用说明">Linux man 手册使用说明&lt;/h2>
&lt;p>在 Linux Kernel 的官方 man 手册中，记录了用户空间程序使用 Linux 内核 和 C 库的接口。对于 C 库，主要聚焦于 GUN C(glibc)，尽管在已知的情况下，还包括可用于 Linux 的其他 C 库中的变体文档。在这个 man 手册中，分为如下几部分&lt;/p>
&lt;ul>
&lt;li>&lt;strong>&lt;a href="https://man7.org/linux/man-pages/dir_section_1.html">User commands&lt;/a>(用户命令)&lt;/strong> # 介绍一些用户空间的应用程序。&lt;/li>
&lt;li>&lt;strong>&lt;a href="https://man7.org/linux/man-pages/dir_section_2.html">System calls&lt;/a>(系统调用)&lt;/strong> # Linux Kernel 可以提供的所有 System Calls(系统调用)&lt;/li>
&lt;li>&lt;strong>&lt;a href="https://man7.org/linux/man-pages/dir_section_3.html">Library functions&lt;/a>(库函数)&lt;/strong> # C 标准库可以提供的函数。&lt;/li>
&lt;li>&lt;strong>&lt;a href="https://man7.org/linux/man-pages/dir_section_4.html">Devices&lt;/a>(设备)&lt;/strong> # 各种设备的详细信息，这些设备大多都在 /dev 目录中。&lt;/li>
&lt;li>&lt;strong>&lt;a href="https://man7.org/linux/man-pages/dir_section_5.html">Files&lt;/a>(文件)&lt;/strong> # 各种文件格式和文件系统&lt;/li>
&lt;li>&lt;strong>&lt;a href="https://man7.org/linux/man-pages/dir_section_7.html">Overviews, conventions, and miscellaneous&lt;/a>(概述、约定 和 其他)&lt;/strong> #&lt;/li>
&lt;li>&lt;strong>&lt;a href="https://man7.org/linux/man-pages/dir_section_8.html">Superuser and system administration commands&lt;/a>(超级用户和系统管理员命令)&lt;/strong> # 介绍一些 GUN C 库提供的程序。&lt;/li>
&lt;/ul>
&lt;p>在 Linux man 手册中，可以找到 Linux 系统中的一切使用说明。Linux 操作系统围绕 Linux Kernel 构建了一套高效、健壮的应用程序运行环境&lt;/p>
&lt;h1 id="intirdimgvmlinuzsystemmap-文件">intird.img、vmlinuz、System.map 文件&lt;/h1>
&lt;p>Kernel 会被安装到 /boot 目录中，并生成 &lt;strong>config、initrd.img、System.map、vmlinuz&lt;/strong> 这几个文件&lt;/p>
&lt;h2 id="vmlinuz">vmlinuz&lt;/h2>
&lt;p>vmlinuz 是 &lt;a href="http://www.linfo.org/linuxdef.html">Linux&lt;/a> &lt;a href="http://www.linfo.org/kernel.html">内核&lt;/a> 可执行文件的名称。&lt;/p>
&lt;p>vmlinuz 是一个压缩的 Linux 内核，它是_可引导的_。可引导意味着它能够将操作系统加载到内存中，以便计算机变得可用并且可以运行应用程序。&lt;/p>
&lt;p>vmlinuz 不应与_vmlinux_混淆，后者是非压缩和不可引导形式的内核。vmlinux 通常只是生成 vmlinuz 的中间步骤。&lt;/p>
&lt;p>vmlinuz 位于 /boot 目录中，该目录包含开始引导系统所需的文件。名为 vmlinuz 的文件可能是实际的内核可执行文件本身，也可能是内核可执行文件的链接，该链接可能带有诸如 &lt;code>/boot/vmlinuz-2.4.18-19.8.0&lt;/code> 之类的名称（即特定内核的名称）内核版本）。这可以通过使用 ls &lt;a href="http://www.linfo.org/command.html">命令&lt;/a>（其目的是列出指定目录的内容）及其 -l 选项（它告诉 ls 提供有关指定目录中每个对象的详细信息）来轻松确定，如下所示：&lt;/p>
&lt;blockquote>
&lt;p>&lt;code>ls -l /boot&lt;/code>&lt;/p>
&lt;/blockquote>
&lt;p>如果 vmlinuz 是一个普通文件（包括可执行文件），则第一列中有关它的信息将以连字符开头。如果是链接，它将以字母_l_开头。
通过发出以下命令   来_编译_Linux 内核：&lt;/p>
&lt;blockquote>
&lt;p>&lt;code>make bzImage&lt;/code>&lt;/p>
&lt;/blockquote>
&lt;p>这会在 /usr/src/linux/arch/i386/linux/boot/ 等目录中创建名为_bzImage_的文件。&lt;/p>
&lt;p>编译是将内核的&lt;a href="http://www.linfo.org/source_code.html">&lt;em>源代码&lt;/em>&lt;/a>（即内核由人类编写的原始形式）转换为_目标代码_（计算机处理器可以直接理解）。它由称为&lt;a href="http://www.linfo.org/compiler.html">&lt;em>编译器&lt;/em>&lt;/a>的专门程序执行，通常是&lt;a href="http://www.linfo.org/gcc.html">&lt;em>GCC&lt;/em>&lt;/a>（&lt;a href="http://www.linfo.org/gnu.html">GNU&lt;/a>编译器集合）中的一个。&lt;/p>
&lt;p>然后使用 _cp &lt;em>命令将 bzImage 复制到 /boot 目录，同时使用诸如以下命令   重命名_vmlinuz&lt;/em>&lt;/p>
&lt;blockquote>
&lt;p>&lt;code>cp /usr/src/linux/arch/i386/linux/boot/bzImage /boot/vmlinuz&lt;/code>&lt;/p>
&lt;/blockquote>
&lt;p>vmlinuz 不仅仅是一个压缩图像。它还内置了_gzip_解压缩器代码。gzip 是&lt;a href="http://www.linfo.org/unix-like.html">类 Unix&lt;/a>操作系统上最流行的压缩实用程序之一。&lt;/p>
&lt;p>一个名为_zImage_文件的编译内核是在一些较旧的系统上创建的，并保留在较新的系统上以实现向后兼容性。zImage 和 bzImage 都是用 gzip 压缩的。区别在于 zImage 解压到_低内存_（即前 640kB），bzImage 解压到_高内存_（1MB 以上）。有一个常见的误解，认为 bzImage 是使用_bzip2_实用程序压缩的。实际上，&lt;em>b_只代表_big&lt;/em>。&lt;/p>
&lt;p>&lt;em>vmlinuz&lt;/em> 这个名字很大程度上是历史的偶然。在贝尔实验室开发的原始 UNIX 上的内核二进制文件称为_unix_。当后来在加州大学伯克利分校 (UCB) 编写包含支持&lt;a href="http://www.linfo.org/virtual_memory.html">&lt;em>虚拟内存&lt;/em>&lt;/a>的新内核时，内核二进制文件更名为_vmunix_。&lt;/p>
&lt;p>虚拟内存是使用硬盘驱动器 (HDD) 上的空间来模拟额外的 RAM（随机存取内存）容量。与当时使用的其他一些流行操作系统（例如&lt;a href="http://www.linfo.org/ms-dos.html">MS-DOS）&lt;/a>相比，Linux 内核几乎从 Linux 一开始就支持它。&lt;/p>
&lt;p>因此，Linux 内核很自然地被称为_vmlinux_。由于 Linux 内核可执行文件被制作成压缩文件，并且压缩文件在类 Unix 系统上通常具有_z_或_gz_扩展名，因此压缩内核可执行文件的名称变为_vmlinuz_。&lt;/p>
&lt;h2 id="initrd">initrd&lt;/h2>
&lt;p>&lt;strong>Initial RAM Disk(初始内存磁盘，简称 initrd)&lt;/strong> 是一种将临时根文件系统加载到内存中的方案，可以作为 Linux 启动过程的一部分。有两种方法来实现这种方案：&lt;/p>
&lt;ul>
&lt;li>&lt;strong>initrd # Initial RAM Disk。&lt;/strong> 就是把一块内存（ram）当做磁盘（disk）去挂载，然后找到 ram 里的 init 执行。&lt;/li>
&lt;li>&lt;strong>initramfs # Initial RAM Filesystem。&lt;/strong> 直接在 ram 上挂载文件系统，执行文件系统中的 init。&lt;/li>
&lt;/ul>
&lt;p>这两者通常用于在挂载真正的根文件系统之前执行一些准备工作。&lt;/p>
&lt;blockquote>
&lt;p>不要被文件名迷惑，kernel 2.6 以来都是 initramfs 了，只是很多还沿袭传统使用 initrd 的名字
initramfs 的工作方式更加简单直接一些，启动的时候加载内核和 initramfs 到内存执行，内核初始化之后，切换到用户态执行 initramfs 的程序/脚本，加载需要的驱动模块、必要配置等，然后加载 rootfs 切换到真正的 rootfs 上去执行后续的 init 过程。
initrd 是 2.4 及更早的用法（现在你能见到的 initrd 文件实际差不多都是 initramfs 了），运行过程大概是内核启动，执行一些 initrd 的内容，加载模块啥的，然后交回控制权给内核，最后再切到用户态去运行用户态的启动流程。
从格式看，老的 initrd 是一个压缩的内存文件系统，具体是啥忘了，年月太久了。现在的 initramfs 是一个 gzip 压缩的 cpio 文件系统打包，如果遇到什么紧急情况需要处理的时候，你可以建立一个临时目录，把 initramfs 解压之后，直接 cpio -idv 解压出来，改之后再用 cpio 和 gzip 封上即可。虽然大家都喜欢用 tar 打包，但掌握点 cpio 在关键时刻还是可以救命的。&lt;/p>
&lt;/blockquote>
&lt;p>在早期的 Linux 系统中，一般就只有软盘或者硬盘被用来作为 Linux 的根文件系统，因此很容易把这些设备的驱动程序集成到内核中。但是现在根文件系统可能保存在各种存储设备上，包括 SCSI、SATA、U 盘等等。总不能每出一个，就要重新编译一遍内核吧？~这样不但麻烦，也不实用，所以后来 Linux 就提供了一个灵活的方法来解决这些问题。就是 &lt;strong>initrd&lt;/strong>。&lt;/p>
&lt;blockquote>
&lt;p>可以把 initrd 当做 WinPE。当使用 WinPE 启动后会发现你的计算机就算没有硬盘也能在正常运行，其中有个文件系统 B:/ 分区，这个分区就是内存模拟的磁盘。&lt;/p>
&lt;/blockquote>
&lt;p>initrd.img 文件就是个 ram disk 的映像文件。ramdisk 是用一部分内存模拟成磁盘，让操作系统访问。ram disk 是标准内核文件认识的设备(/dev/ram0)文件系统也是标准内核认识的文件系统。内核加载这个 ram disk 作为根文件系统并开始执行其中的&amp;quot;某个文件&amp;quot;（2.6 内核是 init 文件）来加载各种模块，服务等。经过一些配置和运行后，就可以去物理磁盘加载真正的 root 分区了，然后又是一些配置等，最后启动成功。&lt;/p>
&lt;p>也就是你只需要定制适合自己的 initrd.img 文件就可以了。这要比重编内核简单多了，省时省事低风险。&lt;/p>
&lt;h3 id="查看-initrd-文件">查看 initrd 文件&lt;/h3>
&lt;p>我们可以通过如下方式，解压出 initrd.img 文件，下面分别以 Ubuntu 20.04 TLS 系统和 CentOS Stream 8 系统为例：&lt;/p>
&lt;blockquote>
&lt;p>解压方法来源：&lt;a href="https://unix.stackexchange.com/questions/163346/why-is-it-that-my-initrd-only-has-one-directory-namely-kernel">https://unix.stackexchange.com/questions/163346/why-is-it-that-my-initrd-only-has-one-directory-namely-kernel&lt;/a>&lt;/p>
&lt;/blockquote>
&lt;p>Ubuntu 20.04 TLS&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>root@lichenhao:~/test_dir# mkdir -p /root/test_dir/root
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>root@lichenhao:~/test_dir# cp /boot/initrd.img /root/test_dir/
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>root@lichenhao:~/test_dir/root# &lt;span style="color:#f92672">(&lt;/span>cpio -id; cpio -i; unlz4 | cpio -id&lt;span style="color:#f92672">)&lt;/span> &amp;lt; ../initrd.img
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">62&lt;/span> blocks
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">9004&lt;/span> blocks
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">450060&lt;/span> blocks
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>root@lichenhao:~/test_dir/root# ls
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>bin conf cryptroot etc init kernel lib lib32 lib64 libx32 run sbin scripts usr var
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>CentOS Stream 8&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">[&lt;/span>root@master-2 root&lt;span style="color:#f92672">]&lt;/span>&lt;span style="color:#75715e"># mkdir -p /root/test_dir/root&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">[&lt;/span>root@master-2 root&lt;span style="color:#f92672">]&lt;/span>&lt;span style="color:#75715e"># cp /boot/initramfs-4.18.0-294.el8.x86_64.img /root/test_dir&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">[&lt;/span>root@master-2 root&lt;span style="color:#f92672">]&lt;/span>&lt;span style="color:#75715e"># cd /root/test_dir/root&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">[&lt;/span>root@master-2 root&lt;span style="color:#f92672">]&lt;/span>&lt;span style="color:#75715e"># (cpio -id; zcat | cpio -id) &amp;lt; ../initramfs-4.18.0-294.el8.x86_64.img&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">[&lt;/span>root@master-2 root&lt;span style="color:#f92672">]&lt;/span>&lt;span style="color:#75715e"># ls&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>bin dev early_cpio etc init kernel lib lib64 proc root run sbin shutdown sys sysroot tmp usr var
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>可以看到，initrd.img 中包含了一个系统最基本的目录结构&lt;/p>
&lt;h1 id="kernel-关联文件">Kernel 关联文件&lt;/h1>
&lt;p>&lt;strong>/boot/*&lt;/strong> #&lt;/p>
&lt;ul>
&lt;li>&lt;strong>./config-$(uname -r)&lt;/strong> # Kernel 的扩展配置文件。Kernel 文档中，将该文件称为 &lt;strong>Boot Configuration&lt;/strong>。&lt;/li>
&lt;li>&lt;strong>./initrd.img&lt;/strong> # 在内核挂载真正的根文件系统前使用的临时文件系统&lt;/li>
&lt;li>&lt;strong>./vmlinuz&lt;/strong> # Linux 内核&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>/etc/sysctl.conf&lt;/strong> # 系统启动时读取的内核参数文件&lt;/p>
&lt;ul>
&lt;li>&lt;strong>/etc/sysctl.d/*&lt;/strong> # 系统启动时时读取的内核参数目录&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>/usr/lib/sysctl.d/*&lt;/strong> #&lt;/p>
&lt;p>&lt;strong>/proc/sys/*&lt;/strong> # 内核参数(也称为内核变量)所在路径。该目录(从 1.3.57 版本开始)包含许多与内核变量相对应的文件和子目录。 可以使用 &lt;a href="https://www.yuque.com/go/doc/33222789">proc 文件系统&lt;/a> 以及 sysctl(2) 系统读取或加载这些变量，有时可以对其进行修改。&lt;/p></description></item><item><title>Docs: 12.人工智能</title><link>https://desistdaydream.github.io/docs/12.%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/12.%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/12.%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/12.%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Artificial_intelligence">Wiki，Artificial_intelligence&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>&lt;strong>Artificial intelligence(人工智能，简称 AI)&lt;/strong> 是机器所展示的只能，与人类和其他动物的智能相对应。AI 通常包含语音识别、&lt;a href="https://desistdaydream.github.io/docs/12.%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89.md">计算机视觉&lt;/a>、&lt;a href="https://desistdaydream.github.io/docs/12.%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/%E8%87%AA%E7%84%B6%E8%AF%AD%E8%A8%80%E5%A4%84%E7%90%86/%E8%87%AA%E7%84%B6%E8%AF%AD%E8%A8%80%E5%A4%84%E7%90%86.md">自然语言处理&lt;/a>、以及其他输入的映射&lt;/p>
&lt;p>随着机器的能力越来越强，被认为需要“智能”的任务通常从 AI 的定义中删除，这种现象被称为 AI 效应。例如，&lt;a href="https://desistdaydream.github.io/docs/12.%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89/OCR.md">OCR&lt;/a>经常被排除在被认为是人工智能的事物之外，已成为一项常规技术。&lt;/p>
&lt;h1 id="agi">AGI&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Artificial_general_intelligence">WIki，Artificial_general_intelligence&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>&lt;strong>Artificial General Intelligence(通用人工智能，简称 AGI)&lt;/strong> 是一种假设的&lt;a href="https://en.wikipedia.org/wiki/Intelligent_agent" title="智能代理">智能体&lt;/a>，它可以理解或学习&lt;a href="https://en.wikipedia.org/wiki/Human_intelligence" title="人类智慧">人类&lt;/a>或&lt;a href="https://en.wikipedia.org/wiki/Animal_cognition" title="动物认知">其他动物&lt;/a>可以完成的任何智力任务。&lt;/p>
&lt;h1 id="ai-公司">AI 公司&lt;/h1>
&lt;p>Runway &lt;a href="https://runwayml.com/">https://runwayml.com/&lt;/a>&lt;/p>
&lt;ul>
&lt;li>Gen-2 多模态 AI 模型，支持文本生成视频、图像生成视频、视频生成视频&lt;/li>
&lt;/ul>
&lt;h1 id="ai-项目">AI 项目&lt;/h1>
&lt;p>NovelAI # &lt;a href="https://novelai.net/">https://novelai.net/&lt;/a> 写故事、作图&lt;/p>
&lt;h2 id="chatgpt">ChatGPT&lt;/h2>
&lt;p>类 ChatGPT 项目&lt;/p>
&lt;ul>
&lt;li>Bard，google&lt;/li>
&lt;li>文心一言，百度&lt;/li>
&lt;li>通义千问，阿里&lt;/li>
&lt;/ul></description></item><item><title>Docs: 2.Kernel(内核)</title><link>https://desistdaydream.github.io/docs/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2.Kernel%E5%86%85%E6%A0%B8/Kernel%E5%86%85%E6%A0%B8/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2.Kernel%E5%86%85%E6%A0%B8/Kernel%E5%86%85%E6%A0%B8/</guid><description>
&lt;h2 id="操作系统-os-与内核-kernel-有什么区别">操作系统 OS 与内核 Kernel 有什么区别？&lt;/h2>
&lt;p>原文链接：&lt;a href="https://mp.weixin.qq.com/s/-5tDn2-IS6Xo6DwQJN4c3Q">https://mp.weixin.qq.com/s/-5tDn2-IS6Xo6DwQJN4c3Q&lt;/a>&lt;/p>
&lt;p>&lt;strong>通用底盘技术&lt;/strong>&lt;/p>
&lt;p>Canoo 公司有一项核心技术专利，这就是它们的通用电动底盘技术，长得是这个样子，非常像一个滑板：&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/egzxwb/1624588718457-99ed8a8e-d53b-465e-8d99-4345935ad5a4.webp" alt="">&lt;/p>
&lt;p>这个带轮子、有电池、能动的滑板已经包含了一辆车&lt;strong>最核心&lt;/strong>的组件，差的就是一个外壳。这个看起来像滑板的东西就是所谓的电池系统和底盘一体化技术，Canoo 公司在它们的通用底盘上加装不同的外壳就能制造出不同的车型。&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/egzxwb/1624588718511-01fe725d-cd0d-48d1-a4e8-1010d7d5a69b.png" alt="">&lt;/p>
&lt;h5 id="什么是内核">&lt;strong>什么是内核？&lt;/strong>&lt;/h5>
&lt;p>在上面这个示例中，&lt;strong>包含轮子以及电池系统的底盘就好比内核，而套上外壳加上椅子以及内饰后的整体成品就好比操作系统&lt;/strong>。内核仅仅是操作系统的一部分，是真正与硬件交互的那部分软件，与硬件交互包括读写硬盘、读写网盘、读写内存以及任何连接到系统中的硬件。除了与硬件交互外，内核还负责分配资源，分配什么资源呢？所谓资源就是硬件，比如 CPU 时间、内存、IO 等等，这些都是资源。&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/egzxwb/1624588718454-36e25783-bbc0-49ec-a620-26d8580cee9d.png" alt="">&lt;/p>
&lt;p>因此，内核的职责就是以进程的形式来分配 CPU 时间，以虚拟内存的形式来分配物理内存，以文件的形式来管理 IO 设备。&lt;/p>
&lt;h5 id="什么是操作系统">&lt;strong>什么是操作系统？&lt;/strong>&lt;/h5>
&lt;p>然而只有一个内核实际上是做不了什么真正有用的事情，就像上面示例中那个通用底盘一样，这个底盘确实能跑起来，但你没办法开着这样一个底盘出去浪，因为这个底盘很难用。因此，你不得不加装上方向盘、座椅以及车身外壳等，同样的道理，内核是给人用的，为了与内核交互，发明了命令行以及图形界面 GUI。&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/egzxwb/1624588718509-9945a71c-556e-4b5a-be9f-8a123c68473c.png" alt="">&lt;/p>
&lt;p>在 Windows 平台就是给程序员提供编程接口的是 Windows API，这层 API 包罗万象，不但包括上文提到对系统调用的封装，还包括其它功能，像创建带有图形界面的应用程序等等。&lt;strong>但在 Linux 世界你找不到一种类似 Windows API 的东西&lt;/strong>，毕竟 Windows 是微软自家产品，什么都可以打包起来，Linux 只是一个开源的内核，如果一定要找一个类似的东西话那就是 libc，也就是 C 标准库，这里同样包括了对系统调用的封装以及一些库函数，但 libc 不包含创建带有图形界面应用程序的功能。现在我们知道了，操作系统需要提供两种接口：&lt;/p>
&lt;ul>
&lt;li>给用户提供操作接口。&lt;/li>
&lt;li>给程序员提供编程接口。&lt;/li>
&lt;/ul>
&lt;p>这些就是好比汽车的外壳，我们(用户和程序员)看得见摸得着，外壳加上底盘——也就是内核，才是功能完善的操作系统。&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/egzxwb/1624588718491-8aabc98e-8938-4b52-95fd-265d5f7d95b8.webp" alt="">&lt;/p>
&lt;h5 id="各种各样的操作系统">&lt;strong>各种各样的操作系统&lt;/strong>&lt;/h5>
&lt;p>实际上我们熟悉的 Linux 只是内核而不能称得上是操作系统，Ubuntu 则可以认为是操作系统，其内核是 Linux；RedHat 也是操作系统，其内核同样是 Linux；我们可以看到，尽管 Ubuntu 和 RedHat 是不同的操作系统，但其内核可以是相同的。这就好比它们可以基于同样的底盘打造出不同的车型。而我们熟悉的 Windows 也是操作系统，其内核是 Windows NT 内核。&lt;/p>
&lt;h5 id="总结">&lt;strong>总结&lt;/strong>&lt;/h5>
&lt;p>内核就像本文开头提到的电动底盘，包含了一个汽车的最核心元素；但这样一个底盘并没有什么实际用处，当搭配上外壳以及座椅后才是一辆真正有用的车，这就好比操作系统。值得注意的是，不同的操作系统可以有相同的内核。&lt;/p>
&lt;h1 id="宏内核与微内核">宏内核与微内核&lt;/h1>
&lt;p>原文链接：&lt;a href="https://mp.weixin.qq.com/s/jIuLkapBssGnBn1IoIdWQQ">公众号-码农的荒岛求生，操作系统的实现：什么是宏内核、微内核&lt;/a>&lt;/p>
&lt;h2 id="大一统全部运行在内核态">大一统，全部运行在内核态&lt;/h2>
&lt;p>&lt;strong>最简单的划分就是没有划分&lt;/strong>，我们可以把所有内核代码放在内核态，内核中的任何代码都拥有控制硬件的全部特权，显然这种设计方法非常简单，因为操作系统设计者不用费心去想哪一部分该放在内核态。&lt;/p>
&lt;p>由于全部内核程序都运行在内核态，编译好的内核程序就是一个单独的二进制可执行文件，这时的操作系统运行起来后就是一个大进程，所有内核代码运行在一个单独的地址空间中，这和我们实现的稍微复杂的单进程应用程序类似，这种大一统的设计就是所谓的宏内核，monolithic kernel，个人认为叫“一体化内核”更形象些。&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/egzxwb/1650439475125-4fe94b34-90ba-43d8-8a9b-3c5860730e20.png" alt="">&lt;/p>
&lt;p>这种组织方式和 TCP/IP 协议栈的分层实现有点类似。&lt;/p>
&lt;p>现在内核代码已经组织好了，毕竟内核是为上层应用提供服务的，那么上层应用该怎样调用内核代码呢？这就是系统调用的作用，system call。&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/egzxwb/1650439474086-a1f789d1-05e4-4c7c-9c39-d6274ac2b0aa.png" alt="">&lt;/p>
&lt;p>上层应用程序通过系统调用与内核进行交互。&lt;/p>
&lt;p>由于内核代码唯一同一个地址空间中，因此内核中各部分的交互极为简单，就是普通的函数调用，文件系统中的某块 cache 可以非常容易的被虚拟内存系统共享使用。&lt;/p>
&lt;p>但宏内核也是有缺点的，由于内核代码位于同一个地址空间，代码趋于复杂化，复杂就容易出错，但内核和普通程序不同，一旦内核中某一模块出现 bug 将导致整个内核崩溃，底层的内核崩溃后上层的应用程序就无法继续正常推进，整个系统就下图一样。。crash&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/egzxwb/1650439474129-b3976f1b-3567-4d8a-b82d-2e5fd9e647cd.gif" alt="">&lt;/p>
&lt;p>当然也有人不在乎在这一点，Linus 认为内核中有 bug 正常，&lt;strong>有 bug 就找到它、修复它而不是用某种机制试图忽略它&lt;/strong>，没错，C++中的异常就是试图忽略 bug 的机制，这就是为什么很多公司的规范中禁止使用异常的原因。&lt;/p>
&lt;p>总之，内核崩溃后就必须重启计算机。&lt;/p>
&lt;h4 id="heading">&lt;/h4>
&lt;h2 id="保留核心非必要不留在内核">保留核心，非必要不留在内核&lt;/h2>
&lt;p>为减少内核崩溃的风险，一个简单的办法就是让内核尽量精简，只保留核心部分运行在内核态，其它代码以用户态进程的形式运行，就像这样：&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/egzxwb/1650439474079-a7429422-8348-4fe1-b423-79e30fe7763d.png" alt="">&lt;/p>
&lt;p>运行在用户态的操作系统程序被称为 server，像负责文件操作的 File Server 等，此时用户进程想要使用操作系统提供的服务的话就必须借助进程间通信，inter-process communication，即 IPC，借助内核，消息从一个进程发送到另一个进程然后等待返回。&lt;/p>
&lt;p>这样，内核只需要对上层应用提供一些简单的接口即可，像创建进程、发送消息等，这种实现方式可以让内核尽可能简单，因为大部分内核程序都运行在用户态，且运行在不同的地址空间中，此时设备驱动中的 bug 不会影响到内核，这种操作系统的实现方式就被称为微内核， micro kernel。&lt;/p>
&lt;p>就像宏内核那样，微内核也有自己的缺点，那就是性能。由于宏内核的代码都在同一个地址空间中，因此模块间的交互可以非常简单，简单的函数调用即可，但模块间交互对微内核来说则可能涉及进程间通信，看上图，如果某个应用程序需要请求使用 File Server，这条链路涉及到：&lt;/p>
&lt;pre>&lt;code>请求：应用程序 -&amp;gt; 内核 -&amp;gt; File server
返回：Filer server -&amp;gt; 内核 -&amp;gt; 应用程序
&lt;/code>&lt;/pre>
&lt;p>每一个&amp;quot;-&amp;gt;&amp;ldquo;都涉及上下文切换，而这对宏内核来说则简单很多。&lt;/p>
&lt;h4 id="heading-1">&lt;/h4>
&lt;p>&lt;strong>现实中是什么样子？&lt;/strong>&lt;/p>
&lt;p>现实的操作系统中两种实现方式都很常见，Linux 以及许多 Unix 就是典型的宏内核，而 Mac OS X 以及 Windows NT 则一般认为是微内核，华为的鸿蒙 Harmony OS 则宣传是微内核。&lt;/p></description></item><item><title>Docs: 3.System Call</title><link>https://desistdaydream.github.io/docs/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2.Kernel%E5%86%85%E6%A0%B8/3.System-Call/System-Call/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2.Kernel%E5%86%85%E6%A0%B8/3.System-Call/System-Call/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://man7.org/linux/man-pages/man2/syscalls.2.html">Manual(手册)，syscalls(2)&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/System_call">Wiki,System_call&lt;/a>&lt;/li>
&lt;li>&lt;a href="http://arthurchiao.art/blog/system-call-definitive-guide-zh/">http://arthurchiao.art/blog/system-call-definitive-guide-zh/&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>&lt;strong>System Call(系统调用，简称 syscall)&lt;/strong> 是 Application(应用程序) 和 Linux Kernel(内核) 之间的基本接口。是操作内核的唯一入口。其实，所谓 syscall 就是各种编程语言中的 &lt;strong>Function(函数)&lt;/strong> 概念。一个 syscall 也有名称、参数、返回值。syscall 即可以是名词，用来描述一个具体的 syscall；也可以是动词，用来表示某物调用了某个 syscall。当用户进程需要发生系统调用时，CPU 通过软中断切换到内核态开始执行内核系统调用函数。&lt;/p>
&lt;blockquote>
&lt;p>syscall 还有另一种意思，是一种编程方式，比如我们常说的 API，就是 syscall 的一种实现。但是通常意义的 API 不包含权限的转变，而普通程序进行系统调用时，会涉及到权限的转变。&lt;/p>
&lt;/blockquote>
&lt;p>在 &lt;a href="https://man7.org/linux/man-pages/man2/syscalls.2.html#DESCRIPTION">syscalls(2) 手册中的 System call list 章节&lt;/a>可以看到 Linux 可用的完整的 syscall 列表。也就是说所有 Kernel 暴露出来的可供用户调用的 Function。&lt;/p>
&lt;h2 id="用户程序内核和-cpu-特权级别">用户程序、内核和 CPU 特权级别&lt;/h2>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/bbar3l/1616168230254-e3c38b73-8092-41bd-a17d-d3c4768de743.jpeg" alt="">&lt;/p>
&lt;p>用户程序（例如编辑器、终端、ssh daemon 等）需要和 Linux 内核交互，内核代替它们完 成一些它们自身无法完成的操作。&lt;/p>
&lt;p>例如，如果用户程序需要做 IO 操作（open、read、write 等），或者需要修改它的 内存地址（mmpa、sbrk 等），那它必须触发内核替它完成。&lt;/p>
&lt;p>为什么禁止用户程序做这些操作呢？&lt;/p>
&lt;p>因为 x86-64 CPU 有一个特权级别 （privilege levels）的概念。这个概念很复杂，完全可以单独写一篇博客。 出于本文讨论目的，我们将其（大大地）简化为如下：&lt;/p>
&lt;ol>
&lt;li>特权级别是权限控制的一种方式。当前的特权级别决定了允许执行哪些 CPU 指令和操作&lt;/li>
&lt;li>内核运行在最高级别，称为 “Ring 0”；用户程序运行在稍低的一个级别，一般称作 “Ring 3”&lt;/li>
&lt;/ol>
&lt;ul>
&lt;li>内核空间（Ring 0）具有最高权限，可以直接访问所有资源；&lt;/li>
&lt;li>用户空间（Ring 3）只能访问受限资源，不能直接访问内存等硬件设备，必须通过系统调用陷入到内核中，才能访问这些特权资源。&lt;/li>
&lt;/ul>
&lt;p>用户程序要进行特权操作必须触发一次特权级别切换（从 “Ring 3” 到 “Ring 0”）， 由内核（替它）执行。触发特权级别切换有多种方式，我们先从最常见的方式开始：中断。&lt;/p>
&lt;h1 id="interrupts中断">Interrupts(中断)&lt;/h1>
&lt;p>详见：[Interrupts(中断) 概念详解](/docs/1.操作系统/2.Kernel(内核)/4.CPU%20 管理/Interrupts(中断).md 管理/Interrupts(中断).md)&lt;/p>
&lt;h1 id="syscall-的方式">syscall 的方式&lt;/h1>
&lt;p>通过 glibc 提供的库函数&lt;/p>
&lt;p>glibc 是 Linux 下使用的开源的标准 C 库，它是 GNU 发布的 libc 库，即运行时库。glibc 为程序员提供丰富的 API，除了例如字符串处理、数学运算等用户态服务之外，最重要的是封装了操作系统提供的系统服务，即系统调用的封装。那么 glibc 提供的系统调用 API 与内核特定的系统调用之间的关系是什么呢？&lt;/p>
&lt;ul>
&lt;li>通常情况，每个特定的系统调用对应了至少一个 glibc 封装的库函数，如系统提供的打开文件系统调用 sys_open 对应的是 glibc 中的 open 函数；&lt;/li>
&lt;li>其次，glibc 一个单独的 API 可能调用多个系统调用，如 glibc 提供的 printf 函数就会调用如 sys_open、sys_mmap、sys_write、sys_close 等等系统调用；&lt;/li>
&lt;li>另外，多个 API 也可能只对应同一个系统调用，如 glibc 下实现的 malloc、calloc、free 等函数用来分配和释放内存，都利用了内核的 sys_brk 的系统调用。&lt;/li>
&lt;/ul>
&lt;p>举例来说，我们通过 glibc 提供的 chmod 函数来改变文件 etc/passwd 的属性为 444&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-c" data-lang="c">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#include&lt;/span> &lt;span style="color:#75715e">&amp;lt;sys/types.h&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#include&lt;/span> &lt;span style="color:#75715e">&amp;lt;sys/stat.h&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#include&lt;/span> &lt;span style="color:#75715e">&amp;lt;errno.h&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#include&lt;/span> &lt;span style="color:#75715e">&amp;lt;stdio.h&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> rc;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> rc &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#a6e22e">chmod&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;/etc/passwd&amp;#34;&lt;/span>, &lt;span style="color:#ae81ff">0444&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (rc &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#f92672">-&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">fprintf&lt;/span>(stderr, &lt;span style="color:#e6db74">&amp;#34;chmod failed, errno = %d&lt;/span>&lt;span style="color:#ae81ff">\n&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>, errno);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">else&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">printf&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;chmod success!&lt;/span>&lt;span style="color:#ae81ff">\n&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>在普通用户下编译运用，输出结果为：&lt;/p>
&lt;p>&lt;code>chmod failed, errno = 1&lt;/code>&lt;/p>
&lt;p>上面系统调用返回的值为-1，说明系统调用失败，错误码为 1，在 /usr/include/asm-generic/errno-base.h 文件中有如下错误代码说明：&lt;/p>
&lt;p>&lt;code>#define EPERM 1 /* Operation not permitted */&lt;/code>&lt;/p>
&lt;p>即无权限进行该操作，我们以普通用户权限是无法修改 /etc/passwd 文件的属性的，结果正确。&lt;/p>
&lt;h2 id="使用指定的-syscallname-直接调用">使用指定的 SyscallName 直接调用&lt;/h2>
&lt;p>使用上面的方法有很多好处，首先你无须知道更多的细节，如 chmod 系统调用号，你只需了解 glibc 提供的 API 的原型；其次，该方法具有更好的移植性，你可以很轻松将该程序移植到其他平台，或者将 glibc 库换成其它库，程序只需做少量改动。&lt;/p>
&lt;p>但有点不足是，如果 glibc 没有封装某个内核提供的系统调用时，我就没办法通过上面的方法来调用该系统调用。如我自己通过编译内核增加了一个系统调用，这时 glibc 不可能有你新增系统调用的封装 API，此时我们可以利用 glibc 提供的 syscall 函数直接调用。该函数定义在 unistd.h 头文件中，函数原型如下：&lt;/p>
&lt;p>long int syscall (long int sysno, &amp;hellip;)&lt;/p>
&lt;ul>
&lt;li>sysno 是系统调用号，每个系统调用都有唯一的系统调用号来标识。在 sys/syscall.h 中有所有可能的系统调用号的宏定义。&lt;/li>
&lt;li>&amp;hellip; 为剩余可变长的参数，为系统调用所带的参数，根据系统调用的不同，可带 0~5 个不等的参数，如果超过特定系统调用能带的参数，多余的参数被忽略。&lt;/li>
&lt;li>返回值 该函数返回值为特定系统调用的返回值，在系统调用成功之后你可以将该返回值转化为特定的类型，如果系统调用失败则返回 -1，错误代码存放在 errno 中。&lt;/li>
&lt;/ul>
&lt;p>还以上面修改 /etc/passwd 文件的属性为例，这次使用 syscall 直接调用：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-c" data-lang="c">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#include&lt;/span> &lt;span style="color:#75715e">&amp;lt;stdio.h&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#include&lt;/span> &lt;span style="color:#75715e">&amp;lt;unistd.h&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#include&lt;/span> &lt;span style="color:#75715e">&amp;lt;sys/syscall.h&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#include&lt;/span> &lt;span style="color:#75715e">&amp;lt;errno.h&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">int&lt;/span> rc;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> rc &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#a6e22e">syscall&lt;/span>(SYS_chmod, &lt;span style="color:#e6db74">&amp;#34;/etc/passwd&amp;#34;&lt;/span>, &lt;span style="color:#ae81ff">0444&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">if&lt;/span> (rc &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#f92672">-&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">fprintf&lt;/span>(stderr, &lt;span style="color:#e6db74">&amp;#34;chmod failed, errno = %d&lt;/span>&lt;span style="color:#ae81ff">\n&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>, errno);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">else&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">printf&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;chmod succeess!&lt;/span>&lt;span style="color:#ae81ff">\n&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>在普通用户下编译执行，输出的结果与上例相同。&lt;/p>
&lt;h2 id="通过-syscall-间接调用">通过 syscall() 间接调用&lt;/h2>
&lt;h2 id="通过-int-指令陷入">通过 int 指令陷入&lt;/h2>
&lt;p>如果我们知道系统调用的整个过程的话，应该就能知道用户态程序通过软中断指令 int 0x80 来陷入内核态（在 Intel Pentium II 又引入了 sysenter 指令），参数的传递是通过寄存器，eax 传递的是系统调用号，ebx、ecx、edx、esi 和 edi 来依次传递最多五个参数，当系统调用返回时，返回值存放在 eax 中。&lt;/p>
&lt;p>仍然以上面的修改文件属性为例，将调用系统调用那段写成内联汇编代码：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-c" data-lang="c">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#include&lt;/span> &lt;span style="color:#75715e">&amp;lt;stdio.h&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#include&lt;/span> &lt;span style="color:#75715e">&amp;lt;sys/types.h&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#include&lt;/span> &lt;span style="color:#75715e">&amp;lt;sys/syscall.h&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#include&lt;/span> &lt;span style="color:#75715e">&amp;lt;errno.h&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">long&lt;/span> rc;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">char&lt;/span> &lt;span style="color:#f92672">*&lt;/span>file_name &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#34;/etc/passwd&amp;#34;&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">unsigned&lt;/span> &lt;span style="color:#66d9ef">short&lt;/span> mode &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0444&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">asm&lt;/span>(
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">&amp;#34;int $0x80&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#e6db74">&amp;#34;=a&amp;#34;&lt;/span> (rc)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#e6db74">&amp;#34;0&amp;#34;&lt;/span> (SYS_chmod), &lt;span style="color:#e6db74">&amp;#34;b&amp;#34;&lt;/span> ((&lt;span style="color:#66d9ef">long&lt;/span>)file_name), &lt;span style="color:#e6db74">&amp;#34;c&amp;#34;&lt;/span> ((&lt;span style="color:#66d9ef">long&lt;/span>)mode)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">if&lt;/span> ((&lt;span style="color:#66d9ef">unsigned&lt;/span> &lt;span style="color:#66d9ef">long&lt;/span>)rc &lt;span style="color:#f92672">&amp;gt;=&lt;/span> (&lt;span style="color:#66d9ef">unsigned&lt;/span> &lt;span style="color:#66d9ef">long&lt;/span>)&lt;span style="color:#f92672">-&lt;/span>&lt;span style="color:#ae81ff">132&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> errno &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#f92672">-&lt;/span>rc;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> rc &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#f92672">-&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">if&lt;/span> (rc &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#f92672">-&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">fprintf&lt;/span>(stderr, &lt;span style="color:#e6db74">&amp;#34;chmode failed, errno = %d&lt;/span>&lt;span style="color:#ae81ff">\n&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>, errno);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">else&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">printf&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;success!&lt;/span>&lt;span style="color:#ae81ff">\n&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>如果 eax 寄存器存放的返回值（存放在变量 rc 中）在 -1~-132 之间，就必须要解释为出错码（在/usr/include/asm-generic/errno.h 文件中定义的最大出错码为 132），这时，将错误码写入 errno 中，置系统调用返回值为 -1；否则返回的是 eax 中的值。&lt;/p>
&lt;p>上面程序在 32 位 Linux 下以普通用户权限编译运行结果与前面两个相同！&lt;/p>
&lt;h1 id="系统调用与-api-和函数调用之间的区别">系统调用与 API 和函数调用之间的区别&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://mp.weixin.qq.com/s/2rzzQTuZKSW0O4zM1DlAWQ">公众号，系统调用与函数调用有什么区别？&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://mp.weixin.qq.com/s/q7CDAlwUB7bFstYZ1nOVvA">公众号，系统调用和API有什么区别？&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote></description></item><item><title>Docs: 3.Systemd 系统守护程序</title><link>https://desistdaydream.github.io/docs/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/3.Systemd-%E7%B3%BB%E7%BB%9F%E5%AE%88%E6%8A%A4%E7%A8%8B%E5%BA%8F/3.Systemd-%E7%B3%BB%E7%BB%9F%E5%AE%88%E6%8A%A4%E7%A8%8B%E5%BA%8F/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/3.Systemd-%E7%B3%BB%E7%BB%9F%E5%AE%88%E6%8A%A4%E7%A8%8B%E5%BA%8F/3.Systemd-%E7%B3%BB%E7%BB%9F%E5%AE%88%E6%8A%A4%E7%A8%8B%E5%BA%8F/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://github.com/systemd/systemd">GitHub 项目&lt;/a>&lt;/li>
&lt;li>&lt;a href="http://www.jinbuguo.com/systemd/systemd.index.html">Systemd 中文手册,金步国&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://man.cx/systemd">Manual(手册),systemd&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>&lt;strong>System daemon(系统守护进程，简称 systemd)&lt;/strong> 实质上：启动一个服务，就是启动一个程序，可以给该程序添加一些参数，也可以不添加，该程序的可执行文件一般是放在 /usr/lib/systemd/system/ 目录下的&lt;/p>
&lt;p>历史上，Linux 的启动一直采用 init 进程。这种命令 &lt;code>/etc/init.d/apache2 start 或者 service apache2 start&lt;/code>，就是用来启动服务。&lt;/p>
&lt;p>这种方法有两个缺点。&lt;/p>
&lt;ol>
&lt;li>启动时间长。init 进程是串行启动，只有前一个进程启动完，才会启动下一个进程。&lt;/li>
&lt;li>启动脚本复杂。init 进程只是执行启动脚本，不管其他事情。脚本需要自己处理各种情况，这往往使得脚本变得很长。&lt;/li>
&lt;/ol>
&lt;p>Systemd 就是为了解决这些问题而诞生的。它的设计目标是，为系统的启动和管理提供一套完整的解决方案。&lt;/p>
&lt;p>根据 Linux 惯例，字母 d 是 daemon(守护进程) 的缩写。 Systemd 这个名字的含义，就是它要守护整个系统。&lt;/p>
&lt;p>使用了 Systemd，就不需要再用 init 了。Systemd 取代了 initd，成为系统的第一个进程(PID 等于 1)，其他进程都是它的子进程。&lt;/p>
&lt;p>Systemd 的优点是功能强大，使用方便，缺点是体系庞大，非常复杂。事实上，现在还有很多人反对使用 Systemd，理由就是它过于复杂，与操作系统的其他部分强耦合，违反&amp;quot;keep simple, keep stupid&amp;quot;的 Unix 哲学。&lt;/p>
&lt;p>注意：Systemd 启动的程序无法获取 shell 中的变量，需要通过在 Unit 的配置文件中设置环境变量。&lt;/p>
&lt;h2 id="unit单元">Unit(单元)&lt;/h2>
&lt;p>Systemd 将各种操作系统启动和运行的相关对象，抽象多种类型的 &lt;strong>Units(单元)&lt;/strong>，并且提供了 Units 之间的依赖关系。&lt;strong>大多数 Units 是通过 Unit File(单元文件) 创建的&lt;/strong>，没有 Unit File，也就不会存在所谓的 Units。&lt;strong>可以这么说，在特定目录创建了一个符合 Unit File 格式的文件，也就创建了一个 Unit&lt;/strong>。&lt;/p>
&lt;blockquote>
&lt;p>单元：比如以前上学总说：第一单元、第二单元，这种理解&lt;/p>
&lt;/blockquote>
&lt;p>现阶段有如下几种 Units：&lt;/p>
&lt;ol>
&lt;li>&lt;strong>Automoount unit&lt;/strong> # 自动挂载点&lt;/li>
&lt;li>&lt;strong>Device unit&lt;/strong> # 硬件设备&lt;/li>
&lt;li>&lt;strong>Mount unit&lt;/strong> # 文件系统挂载点&lt;/li>
&lt;li>&lt;strong>Path unit&lt;/strong> # 文件或路径&lt;/li>
&lt;li>&lt;strong>Scope unit&lt;/strong> # 与 Service unit 类似，但是由 systemd 根据 D-bus 接口接收到的信息自动创建， 可用于管理外部创建的进程。&lt;/li>
&lt;li>&lt;strong>Service unit&lt;/strong> # 用于启动和控制守护进程以及他们所包含的进程&lt;/li>
&lt;li>&lt;strong>Slice unit&lt;/strong> # 用于控制特定 CGroup 内(例如一组 service 与 scope 单元)所有进程的总体资源占用。&lt;/li>
&lt;li>&lt;strong>Socket nuit&lt;/strong> # 进程间通信的 socket&lt;/li>
&lt;li>&lt;strong>Swap unit&lt;/strong> # 关于 swap 文件&lt;/li>
&lt;li>&lt;strong>Target nuit&lt;/strong> # 是一群 Unit 的集合&lt;/li>
&lt;li>&lt;strong>Timer unit&lt;/strong> # 定时器&lt;/li>
&lt;/ol>
&lt;p>&lt;strong>Unit 的名称&lt;/strong>。Unit 的名称由 Unit File 的名称决定。比如一个 crond.service 文件，将会创建出来一个类型为 Service，名为 crond.service 的 Unit。
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/glcff3/1616167393721-79076d3b-2c04-48e9-a4a0-8ee4bfb69284.jpeg" alt="">
&lt;strong>Unit 的依赖&lt;/strong>。Systemd 能够处理 Units 之间的依赖关系，通过依赖关系，我们可以确定 Unit 之间启动的先后顺序、以及 Unit 之间是否可以同时运行。
&lt;strong>Unit 的状态&lt;/strong>。 Unit 既可以处于活动(active)状态也可以处于停止(inactive)状态， 当然也可以处于启动中(activating)或停止中(deactivating)的状态。 还有一个特殊的失败(failed)状态， 意思是单元以某种方式失败了 (退出时返回了错误代码、进程崩溃、操作超时、触碰启动频率限制)。 当进入失败(failed)状态时， 导致故障的原因 将被记录到日志中以方便日后排查。 需要注意的是， 不同的单元可能还会有各自不同的&amp;quot;子状态&amp;quot;， 但它们都被映射到上述五种状态之一。通过 &lt;code>systemctl list-units --all&lt;/code> 命令可以查看每个 Unit 的状态。&lt;/p>
&lt;h1 id="systemd-配置">Systemd 配置&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>man 手册：&lt;a href="https://man7.org/linux/man-pages/man5/systemd-system.conf.5.html">https://man7.org/linux/man-pages/man5/systemd-system.conf.5.html&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>&lt;strong>/etc/systemd/*&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>**./system.conf **# Systemd 程序运行时配置文件&lt;/li>
&lt;li>**./system.conf.d/*.conf **# Systemd 程序运行时配置文件&lt;/li>
&lt;li>&lt;strong>./user.conf&lt;/strong> # Systemd 以普通用户身份运行时的配置文件&lt;/li>
&lt;li>&lt;strong>./user.conf.d/*.conf&lt;/strong> # Systemd 以普通用户身份运行时的配置文件&lt;/li>
&lt;/ul>
&lt;p>**/run/systemd/* **#&lt;/p>
&lt;ul>
&lt;li>&lt;strong>./system.conf.d/*.conf&lt;/strong> # Systemd 程序运行时配置文件&lt;/li>
&lt;li>&lt;strong>./user.conf.d/*.conf&lt;/strong> # Systemd 以普通用户身份运行时的配置文件&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>/usr/lib/systemd/*&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>&lt;strong>./system.conf.d/*.conf&lt;/strong> # Systemd 程序运行时配置文件&lt;/li>
&lt;li>&lt;strong>./user.conf.d/*.conf&lt;/strong> # Systemd 以普通用户身份运行时的配置文件&lt;/li>
&lt;/ul>
&lt;p>/etc、/run、/usr/lib 这三个目录的优先级从左至右由高到低。Systemd 会从最低优先级的目录 /usr/lib/_ 下开始加载配置，注意加载其中的文件，直到最高优先级的目录 /etc/systemd/_ 为止。&lt;/p>
&lt;h2 id="units-配置">Units 配置&lt;/h2>
&lt;p>Units 配置就是指 Unit File。Systemd 会从多个目录中加载 Unit File，以生成 Unit。下面列出的路径，优先级从上往下越来越低。也就是说，高优先级目录中的文件，将会覆盖低优先级目录中的同名文件。不同的 Systemd 运行方式，加载 Unit File 的路径不同。&lt;/p>
&lt;h3 id="使用---system-参数以系统实例运行-systemd">使用 &amp;ndash;system 参数，以系统实例运行 systemd&lt;/h3>
&lt;p>通过 pkg-config systemd &amp;ndash;variable=systemdsystemunitdir** &lt;strong>命令可以查看包管理器安装完程序后，生成 Unit File 的目录
通过 pkg-config systemd &amp;ndash;variable=systemdsystemconfdir&lt;/strong> **命令可以查看优先级最高的存放 Unit File 的目录&lt;/p>
&lt;ul>
&lt;li>&lt;strong>/etc/systemd/system.control&lt;/strong> # 通过 dbus API 创建的永久系统单元&lt;/li>
&lt;li>&lt;strong>/run/systemd/system.control&lt;/strong> # 通过 dbus API 创建的临时系统单元&lt;/li>
&lt;li>&lt;strong>/run/systemd/transient&lt;/strong> # 动态配置的临时单元(系统与全局用户共用)&lt;/li>
&lt;li>&lt;strong>/run/systemd/generator.early&lt;/strong> # 生成的高优先级单元(系统与全局用户共用)(参见 systemd.generator(7) 手册中对 early-dir 的说明)&lt;/li>
&lt;li>&lt;strong>/etc/systemd/system/*&lt;/strong> # 人类根据需求，手动创建的 Unit File 所在路径。且当使用 systemctl enable UNIT 命令的时候，会自动在该目录中创建软连接到 /usr/lib/systemd/system/ 目录中的 Unit File
&lt;ul>
&lt;li>./UnitFileName.d/*.conf # 嵌入式单元文件 存放路径&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>/run/systemd/system/*&lt;/strong> # 程序运行时自动生成的 Unit File 所在路径。
&lt;ul>
&lt;li>./UnitFileName.d/*.conf # 嵌入式单元文件 存放路径&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>/run/systemd/generator&lt;/strong> # 生成的中优先级系统单元(参见 systemd.generator(7) 手册中对 normal-dir 的说明)&lt;/li>
&lt;li>&lt;strong>/usr/local/lib/systemd/system&lt;/strong> # 本地软件包安装的系统单元&lt;/li>
&lt;li>&lt;strong>/usr/lib/systemd/system/*&lt;/strong> # 通过系统的包管理器安装程序时，生成的 Unit File 所在路径。
&lt;ul>
&lt;li>./UnitFileName.d/*.conf # 嵌入式单元文件 存放路径&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>/run/systemd/generator.late&lt;/strong> # 生成的低优先级系统单元(参见 systemd.generator(7) 手册中对 late-dir 的说明)&lt;/li>
&lt;/ul>
&lt;h3 id="使用---user-参数以用户实例运行-systemd">使用 &amp;ndash;user 参数，以用户实例运行 systemd&lt;/h3>
&lt;ul>
&lt;li>&lt;strong>$XDG_CONFIG_HOME/systemd/user.control 或 ~/.config/systemd/user.control&lt;/strong> # 通过 dbus API 创建的永久私有用户单元(仅在未设置 $XDG_CONFIG_HOME 时才使用 ~/.config 来替代)&lt;/li>
&lt;li>$XDG_RUNTIME_DIR/systemd/user.control # 通过 dbus API 创建的临时私有用户单元&lt;/li>
&lt;li>/run/systemd/transient 动态配置的临时单元(系统与全局用户共用)&lt;/li>
&lt;li>/run/systemd/generator.early 生成的高优先级单元(系统与全局用户共用)(参见 systemd.generator(7) 手册中对 early-dir 的说明)&lt;/li>
&lt;li>$XDG_CONFIG_HOME/systemd/user 或 $HOME/.config/systemd/user 用户配置的私有用户单元(仅在未设置 $XDG_CONFIG_HOME 时才使用 ~/.config 来替代)&lt;/li>
&lt;li>/etc/systemd/user 本地配置的全局用户单元&lt;/li>
&lt;li>$XDG_RUNTIME_DIR/systemd/user 运行时配置的私有用户单元(仅当 $XDG_RUNTIME_DIR 已被设置时有效)&lt;/li>
&lt;li>/run/systemd/user 运行时配置的全局用户单元&lt;/li>
&lt;li>$XDG_RUNTIME_DIR/systemd/generator 生成的中优先级私有用户单元(参见 systemd.generator(7) 手册中对 normal-dir 的说明)&lt;/li>
&lt;li>$XDG_DATA_HOME/systemd/user 或 $HOME/.local/share/systemd/user 软件包安装在用户家目录中的私有用户单元(仅在未设置 $XDG_DATA_HOME 时才使用 ~/.local/share 来替代)&lt;/li>
&lt;li>$dir/systemd/user(对应 $XDG_DATA_DIRS 中的每一个目录($dir)) 额外安装的全局用户单元，对应 $XDG_DATA_DIRS(默认值=&amp;quot;/usr/local/share/:/usr/share/&amp;quot;) 中的每一个目录。&lt;/li>
&lt;li>/usr/local/lib/systemd/user 本地软件包安装的全局用户单元&lt;/li>
&lt;li>/usr/lib/systemd/user 发行版软件包安装的全局用户单元&lt;/li>
&lt;li>$XDG_RUNTIME_DIR/systemd/generator.late 生成的低优先级私有用户单元(参见 systemd.generator(7) 手册中对 late-dir 的说明)&lt;/li>
&lt;/ul>
&lt;p>可以使用环境变量来 扩充或更改 systemd 用户实例(&lt;code>--user&lt;/code>)的单元文件加载路径。 环境变量可以通过环境变量生成器(详见 &lt;a href="http://www.jinbuguo.com/systemd/systemd.environment-generator.html#">systemd.environment-generator(7)&lt;/a> 手册)来设置。特别地， &lt;code>$XDG_DATA_HOME&lt;/code> 与 &lt;code>$XDG_DATA_DIRS&lt;/code> 可以方便的通过 &lt;a href="http://www.jinbuguo.com/systemd/systemd-environment-d-generator.html#">systemd-environment-d-generator(8)&lt;/a> 来设置。这样，上表中列出的单元目录正好就是默认值。 要查看实际使用的、基于编译选项与当前环境变量的单元目录列表，可以使用 &lt;code>systemd-analyze --user unit-paths&lt;/code>&lt;/p>
&lt;p>此外，还可以通过 &lt;a href="http://www.jinbuguo.com/systemd/systemctl.html#">systemctl(1)&lt;/a> 的 &lt;strong>link&lt;/strong> 命令 向上述单元目录中添加额外的单元(不在上述常规单元目录中的单元)。&lt;/p></description></item><item><title>Docs: 4.CPU 管理</title><link>https://desistdaydream.github.io/docs/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2.Kernel%E5%86%85%E6%A0%B8/4.CPU-%E7%AE%A1%E7%90%86/CPU-%E7%AE%A1%E7%90%86/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2.Kernel%E5%86%85%E6%A0%B8/4.CPU-%E7%AE%A1%E7%90%86/CPU-%E7%AE%A1%E7%90%86/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://time.geekbang.org/column/article/69859">极客时间，Linux 性能优化实战-03 基础篇：经常说的 CPU 上下文切换是什么意思&lt;/a>&lt;/li>
&lt;li>&lt;a href="http://linuxperf.com/?p=209">LinuxPerformance 博客，进程切换：自愿与强制&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>在 Linux 中，CPU 的管理，绝大部分时间都是在进行任务的调度，所以很多时候也称为&lt;strong>调度管理&lt;/strong>。&lt;/p>
&lt;h2 id="cpu-多线程并发并行-概念">&lt;strong>CPU 多线程、并发、并行 概念&lt;/strong>&lt;/h2>
&lt;p>Node：在这里时间片只是一种描述，理解 CPU 的并行与并发概念就好&lt;/p>
&lt;p>1、CPU 时间分片、多线程？
如果线程数不多于 CPU 核心数，会把各个线程都分配一个核心，不需分片，而当线程数多于 CPU 核心数时才会分片。&lt;/p>
&lt;p>2、并发和并行的区别&lt;/p>
&lt;ul>
&lt;li>并发：当有多个线程在操作时,如果系统只有一个 CPU,把 CPU 运行时间划分成若干个时间片,分配给各个线程执行，在一个时间段的线程代码运行时，其它线程处于挂起状态。这种方式我们称之为_ _&lt;strong>Concurrent(并发)&lt;/strong>。并发=间隔发生&lt;/li>
&lt;li>并行：当系统有一个以上 CPU 时,则线程的操作有可能非并发。当一个 CPU 执行一个线程时，另一个 CPU 可以执行另一个线程，两个线程互不抢占 CPU 资源，可以同时进行，这种方式我们称之为 &lt;strong>Parallel(并行)&lt;/strong>。 并行=同时进行&lt;/li>
&lt;/ul>
&lt;p>区别：并行是指两个或者多个事件在同一时刻发生；而并发是指两个或多个事件在同一时间间隔内发生。&lt;/p>
&lt;p>并行是同时做多件事情。&lt;/p>
&lt;p>并发表示同时发生了多件事情，通过时间片切换，哪怕只有单一的核心，也可以实现“同时做多件事情”这个效果。&lt;/p>
&lt;p>根据底层是否有多处理器，并发与并行是可以等效的，这并不是两个互斥的概念。&lt;/p>
&lt;p>举个我们开发中会遇到的例子，我们说资源请求并发数达到了 1 万。这里的意思是有 1 万个请求同时过来了。但是这里很明显不可能真正的同时去处理这 1 万个请求的吧！&lt;/p>
&lt;p>如果这台机器的处理器有 4 个核心，不考虑超线程，那么我们认为同时会有 4 个线程在跑。也就是说，并发访问数是 1 万，而底层真实的并行处理的请求数是 4。如果并发数小一些只有 4 的话，又或者你的机器牛逼有 1 万个核心，那并发在这里和并行一个效果。也就是说，并发可以是虚拟的同时执行，也可以是真的同时执行。而并行的意思是真的同时执行。&lt;/p>
&lt;p>结论是：并行是我们物理时空观下的同时执行，而并发则是操作系统用线程这个模型抽象之后站在线程的视角上看到的“同时”执行。&lt;/p>
&lt;h3 id="time-slice时间片-概念">time slice(时间片) 概念&lt;/h3>
&lt;blockquote>
&lt;p>参考：&lt;a href="https://en.wikipedia.org/wiki/Preemption_(computing)#Time_slice">https://en.wikipedia.org/wiki/Preemption_(computing)#Time_slice&lt;/a>&lt;/p>
&lt;/blockquote>
&lt;p>The period of time for which a process is allowed to run in a preemptive multitasking system is generally called the &lt;em>time slice&lt;/em> or &lt;em>quantum&lt;/em>.&lt;/p>
&lt;p>&lt;strong>time slice(时间片)&lt;/strong> 是一个程序运行在&lt;a href="https://en.wikipedia.org/wiki/Preemption_(computing)">抢占式多任务系统&lt;/a>中的一段时间。也可以称为 quantum(量子)。&lt;/p>
&lt;h2 id="cpu-使用率概念">CPU 使用率概念&lt;/h2>
&lt;p>CPU 不像硬盘、内存，并不具备逻辑上数量、大小、空间之类的概念。只要使用 CPU，就是使用了这个 CPU 的全部，也就无法通过大小之类的概念来衡量一个 CPU，所以我们日常所说的 CPU 的使用率 ，实际上是指的在一段时间范围内，CPU 执行 &lt;strong>Tasks(任务)&lt;/strong> 花费时间的百分比。比如 60 分钟内，一颗 CPU 执行各种任务花费了 6 分钟，则 CPU 在这一小时时间内的使用率为 10%。&lt;/p>
&lt;blockquote>
&lt;p>上文说的 &lt;strong>Tasks(任务)&lt;/strong>，即会指系统中的进程、线程，也代表各种硬件去请求 CPU 执行的各种事情，比如网卡接收到数据，就会告诉 CPU 需要处理(i.e.中断)。&lt;/p>
&lt;/blockquote>
&lt;p>在 Linux 系统中，CPU 的使用率一般可分为 4 大类：&lt;/p>
&lt;ol>
&lt;li>User Time(用户进程运行时间)&lt;/li>
&lt;li>System Time(系统内核运行时间)&lt;/li>
&lt;li>Idle Time(空闲时间)&lt;/li>
&lt;li>Steal Time(被抢占时间)&lt;/li>
&lt;/ol>
&lt;p>除了 Idle Time 外，CPU 在其余时间都处于工作运行状态。
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/srucoz/1616168021555-68fba1de-f5d5-462d-bef6-a78b476521ad.png" alt="">&lt;/p>
&lt;p>通常而言，我们泛指的整体 CPU 使用率为 User Time 和 Systime 占比之和(例如 tsar 中 CPU util)，即：
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/srucoz/1616168021559-394ecaa6-59db-453a-b5b1-c5ab88193f49.png" alt="">&lt;/p>
&lt;p>为了便于定位问题，大多数性能统计工具都将这 4 类时间片进一步扩展成了 8 类，如下图，是在 top 命令的 man 手册中对 CPU 使用率的分类。
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/srucoz/1616168021546-ebe53556-f50b-49f2-8477-c10cf2b8f2f5.png" alt="">&lt;/p>
&lt;ul>
&lt;li>us：用户进程空间中未改变过优先级的进程占用 CPU 百分比&lt;/li>
&lt;li>sy：内核空间占用 CPU 百分比&lt;/li>
&lt;li>ni：用户进程空间内改变过优先级的进程占用 CPU 百分比&lt;/li>
&lt;li>id：空闲时间百分比&lt;/li>
&lt;li>wa：等待 I/O 的时间百分比&lt;/li>
&lt;li>hi：硬中断时间百分比&lt;/li>
&lt;li>si：软中断时间百分比&lt;/li>
&lt;li>st：虚拟化时被其余 VM 窃取时间百分比&lt;/li>
&lt;/ul>
&lt;p>这 8 类分片中，除 wa 和 id 外，其余分片 CPU 都处于工作态。&lt;/p>
&lt;h1 id="调度算法">调度算法&lt;/h1>
&lt;blockquote>
&lt;p>详见：&lt;a href="https://www.yuque.com/go/doc/33222924">CPU 调度算法&lt;/a>&lt;/p>
&lt;/blockquote>
&lt;p>首先明确一个概念：&lt;strong>Task(任务)&lt;/strong>，一个进程从处理到结束就算一个任务，处理网卡收到的数据包也算一个任务。一般来说，CPU 就是在处理一个个的 &lt;strong>Task(任务)&lt;/strong>，并度过其一生。&lt;/p>
&lt;p>在 Linux 内核中，进程和线程都是用 tark_struct 结构体表示的，区别在于线程的 tark_struct 结构体里部分资源是共享了进程已创建的资源，比如内存地址空间、代码段、文件描述符等，所以 Linux 中的线程也被称为轻量级进程，因为线程的 tark_struct 相比进程的 tark_struct 承载的 资源比较少，因此以「轻」得名。&lt;/p>
&lt;p>一般来说，没有创建线程的进程，是只有单个执行流，它被称为是主线程。如果想让进程处理更多的事情，可以创建多个线程分别去处理，但不管怎么样，它们对应到内核里都是 tark_struct。&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/srucoz/1616168021545-596ecf70-ac19-4620-8845-bfe72ef7bdce.jpeg" alt="">&lt;/p>
&lt;p>所以，Linux 内核里的调度器，调度的对象就是 tark_struct，接下来我们就把这个数据结构统称为任务。&lt;/p>
&lt;p>在 Linux 系统中，根据任务的优先级以及响应要求，主要分为两种，其中优先级的数值越小，优先级越高：&lt;/p>
&lt;ul>
&lt;li>实时任务，对系统的响应时间要求很高，也就是要尽可能快的执行实时任务，优先级在 0~99 范围内的就算实时任务；&lt;/li>
&lt;li>普通任务，响应时间没有很高的要求，优先级在 100~139 范围内都是普通任务级别；&lt;/li>
&lt;/ul>
&lt;p>也就是说，在 LInux 内核中，实时任务总是比普通任务的优先级要高。&lt;/p></description></item><item><title>Docs: 5.Memory 管理</title><link>https://desistdaydream.github.io/docs/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2.Kernel%E5%86%85%E6%A0%B8/5.Memory-%E7%AE%A1%E7%90%86/5.Memory-%E7%AE%A1%E7%90%86/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2.Kernel%E5%86%85%E6%A0%B8/5.Memory-%E7%AE%A1%E7%90%86/5.Memory-%E7%AE%A1%E7%90%86/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://mp.weixin.qq.com/s/HJB_ATQFNqG82YBCRr97CA">公众号,小林 coding-真棒！ 20 张图揭开内存管理的迷雾，瞬间豁然开朗&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://mp.weixin.qq.com/s/0g3sS63yM2qbBja-blw5Dw">公众号，码农的荒岛求生-神秘！申请内存时底层发生了什么？&lt;/a>(malloc 简介)&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>对任何一台计算机而言，其内存以及其它资源都是有限的。为了让有限的&lt;strong>物理内存&lt;/strong>满足应用程序对内存的大需求量，Linux 采用了称为 **虚拟内存 **的内存管理方式。Linux 将内存划分为容易处理的“内存页”（对于大部分体系结构来说都是 4KB）。Linux 包括了管理可用内存的方式，以及物理和虚拟映射所使用的硬件机制。&lt;/p>
&lt;p>不过内存管理要管理的可不止 4KB 缓冲区。Linux 提供了对 4KB 缓冲区的抽象，例如 slab 分配器。这种内存管理模式使用 4KB 缓冲区为基数，然后从中分配结构，并跟踪内存页使用情况，比如哪些内存页是满的，哪些页面没有完全使用，哪些页面为空。这样就允许该模式根据系统需要来动态调整内存使用。&lt;/p>
&lt;p>为了支持多个用户使用内存，有时会出现可用内存被消耗光的情况。由于这个原因，页面可以移出内存并放入磁盘中。这个过程称为交换，因为页面会被从内存交换到硬盘上。内存管理的源代码可以在 ./linux/mm 中找到。&lt;/p>
&lt;h1 id="虚拟内存">虚拟内存&lt;/h1>
&lt;p>如果你是电子相关专业的，肯定在大学里捣鼓过单片机。&lt;/p>
&lt;p>单片机是没有操作系统的，所以每次写完代码，都需要借助工具把程序烧录进去，这样程序才能跑起来。&lt;/p>
&lt;p>另外，单片机的 CPU 是直接操作内存的「物理地址」。&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/odexpg/1616167919093-db60b152-2475-49e7-8a9d-813007e27b8d.jpeg" alt="">&lt;/p>
&lt;p>在这种情况下，要想在内存中同时运行两个程序是不可能的。如果第一个程序在 2000 的位置写入一个新的值，将会擦掉第二个程序存放在相同位置上的所有内容，所以同时运行两个程序是根本行不通的，这两个程序会立刻崩溃。&lt;/p>
&lt;p>操作系统是如何解决这个问题呢？&lt;/p>
&lt;p>这里关键的问题是这两个程序都引用了绝对物理地址，而这正是我们最需要避免的。&lt;/p>
&lt;p>我们可以把进程所使用的地址「隔离」开来，即让操作系统为每个进程分配独立的一套「虚拟地址」，人人都有，大家自己玩自己的地址就行，互不干涉。但是有个前提每个进程都不能访问物理地址，至于虚拟地址最终怎么落到物理内存里，对进程来说是透明的，操作系统已经把这些都安排的明明白白了。&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/odexpg/1616167919100-24627511-d5f5-4663-9a2c-76b4b3b75664.jpeg" alt="">&lt;/p>
&lt;p>进程的中间层&lt;/p>
&lt;p>操作系统会提供一种机制，将不同进程的虚拟地址和不同内存的物理地址映射起来。&lt;/p>
&lt;p>如果程序要访问虚拟地址的时候，由操作系统转换成不同的物理地址，这样不同的进程运行的时候，写入的是不同的物理地址，这样就不会冲突了。&lt;/p>
&lt;p>于是，这里就引出了两种地址的概念：&lt;/p>
&lt;ul>
&lt;li>我们程序所使用的内存地址叫做虚拟内存地址（Virtual Memory Address）&lt;/li>
&lt;li>实际存在硬件里面的空间地址叫物理内存地址（Physical Memory Address）。&lt;/li>
&lt;/ul>
&lt;p>操作系统引入了虚拟内存，进程持有的虚拟地址会通过 CPU 芯片中的内存管理单元（MMU）的映射关系，来转换变成物理地址，然后再通过物理地址访问内存，如下图所示：&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/odexpg/1616167919111-7b5c26a3-f885-4ae8-bb6b-2bfab9cef4c9.jpeg" alt="">&lt;/p>
&lt;p>操作系统是如何管理虚拟地址与物理地址之间的关系？&lt;/p>
&lt;p>主要有两种方式，分别是内存分段和内存分页，分段是比较早提出的，我们先来看看内存分段。&lt;/p>
&lt;h2 id="内存分段">内存分段&lt;/h2>
&lt;p>程序是由若干个逻辑分段组成的，如可由代码分段、数据分段、栈段、堆段组成。不同的段是有不同的属性的，所以就用分段（Segmentation）的形式把这些段分离出来。&lt;/p>
&lt;p>分段机制下，虚拟地址和物理地址是如何映射的？&lt;/p>
&lt;p>分段机制下的虚拟地址由两部分组成，段选择子和段内偏移量。&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/odexpg/1616167919128-c7568177-0bee-4534-84c6-694d268dd85d.jpeg" alt="">&lt;/p>
&lt;p>内存分段-寻址的方式&lt;/p>
&lt;ul>
&lt;li>段选择子就保存在段寄存器里面。段选择子里面最重要的是段号，用作段表的索引。段表里面保存的是这个段的基地址、段的界限和特权等级等。&lt;/li>
&lt;li>虚拟地址中的段内偏移量应该位于 0 和段界限之间，如果段内偏移量是合法的，就将段基地址加上段内偏移量得到物理内存地址。&lt;/li>
&lt;/ul>
&lt;p>在上面了，知道了虚拟地址是通过段表与物理地址进行映射的，分段机制会把程序的虚拟地址分成 4 个段，每个段在段表中有一个项，在这一项找到段的基地址，再加上偏移量，于是就能找到物理内存中的地址，如下图：&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/odexpg/1616167919115-2be6810a-fa1d-41f1-92f8-b6390209f15a.jpeg" alt="">&lt;/p>
&lt;p>内存分段-虚拟地址与物理地址&lt;/p>
&lt;p>如果要访问段 3 中偏移量 500 的虚拟地址，我们可以计算出物理地址为，段 3 基地址 7000 + 偏移量 500 = 7500。&lt;/p>
&lt;p>分段的办法很好，解决了程序本身不需要关心具体的物理内存地址的问题，但它也有一些不足之处：&lt;/p>
&lt;ul>
&lt;li>第一个就是内存碎片的问题。&lt;/li>
&lt;li>第二个就是内存交换的效率低的问题。&lt;/li>
&lt;/ul>
&lt;p>接下来，说说为什么会有这两个问题。&lt;/p>
&lt;p>我们先来看看，分段为什么会产生内存碎片的问题？&lt;/p>
&lt;p>我们来看看这样一个例子。假设有 1G 的物理内存，用户执行了多个程序，其中：&lt;/p>
&lt;ul>
&lt;li>游戏占用了 512MB 内存&lt;/li>
&lt;li>浏览器占用了 128MB 内存&lt;/li>
&lt;li>音乐占用了 256 MB 内存。&lt;/li>
&lt;/ul>
&lt;p>这个时候，如果我们关闭了浏览器，则空闲内存还有 1024 - 512 - 256 = 256MB。&lt;/p>
&lt;p>如果这个 256MB 不是连续的，被分成了两段 128 MB 内存，这就会导致没有空间再打开一个 200MB 的程序。&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/odexpg/1616167919115-056b2c69-14f1-48d7-8162-7915c80cd090.jpeg" alt="">&lt;/p>
&lt;p>内存碎片的问题&lt;/p>
&lt;p>这里的内存碎片的问题共有两处地方：&lt;/p>
&lt;ul>
&lt;li>外部内存碎片，也就是产生了多个不连续的小物理内存，导致新的程序无法被装载；&lt;/li>
&lt;li>内部内存碎片，程序所有的内存都被装载到了物理内存，但是这个程序有部分的内存可能并不是很常使用，这也会导致内存的浪费；&lt;/li>
&lt;/ul>
&lt;p>针对上面两种内存碎片的问题，解决的方式会有所不同。&lt;/p>
&lt;p>解决外部内存碎片的问题就是内存交换。&lt;/p>
&lt;p>可以把音乐程序占用的那 256MB 内存写到硬盘上，然后再从硬盘上读回来到内存里。不过再读回的时候，我们不能装载回原来的位置，而是紧紧跟着那已经被占用了的 512MB 内存后面。这样就能空缺出连续的 256MB 空间，于是新的 200MB 程序就可以装载进来。&lt;/p>
&lt;p>这个内存交换空间，在 Linux 系统里，也就是我们常看到的 Swap 空间，这块空间是从硬盘划分出来的，用于内存与硬盘的空间交换。&lt;/p>
&lt;p>再来看看，分段为什么会导致内存交换效率低的问题？&lt;/p>
&lt;p>对于多进程的系统来说，用分段的方式，内存碎片是很容易产生的，产生了内存碎片，那不得不重新 Swap 内存区域，这个过程会产生性能瓶颈。&lt;/p>
&lt;p>因为硬盘的访问速度要比内存慢太多了，每一次内存交换，我们都需要把一大段连续的内存数据写到硬盘上。&lt;/p>
&lt;p>所以，如果内存交换的时候，交换的是一个占内存空间很大的程序，这样整个机器都会显得卡顿。&lt;/p>
&lt;p>为了解决内存分段的内存碎片和内存交换效率低的问题，就出现了内存分页。&lt;/p>
&lt;h2 id="内存分页">内存分页&lt;/h2>
&lt;p>分段的好处就是能产生连续的内存空间，但是会出现内存碎片和内存交换的空间太大的问题。&lt;/p>
&lt;p>要解决这些问题，那么就要想出能少出现一些内存碎片的办法。另外，当需要进行内存交换的时候，让需要交换写入或者从磁盘装载的数据更少一点，这样就可以解决问题了。这个办法，也就是内存分页（Paging）。&lt;/p>
&lt;p>分页是把整个虚拟和物理内存空间切成一段段固定尺寸的大小。这样一个连续并且尺寸固定的内存空间，我们叫页（Page）。在 Linux 下，每一页的大小为 4KB。&lt;/p>
&lt;p>虚拟地址与物理地址之间通过页表来映射，如下图：&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/odexpg/1616167919131-ca0a6877-5b8c-49fc-8982-ff9bd4f247a2.jpeg" alt="">&lt;/p>
&lt;p>内存映射&lt;/p>
&lt;p>页表实际上存储在 CPU 的内存管理单元 （MMU） 中，于是 CPU 就可以直接通过 MMU，找出要实际要访问的物理内存地址。&lt;/p>
&lt;p>而当进程访问的虚拟地址在页表中查不到时，系统会产生一个缺页异常，进入系统内核空间分配物理内存、更新进程页表，最后再返回用户空间，恢复进程的运行。&lt;/p>
&lt;p>分页是怎么解决分段的内存碎片、内存交换效率低的问题？&lt;/p>
&lt;p>由于内存空间都是预先划分好的，也就不会像分段会产生间隙非常小的内存，这正是分段会产生内存碎片的原因。而采用了分页，那么释放的内存都是以页为单位释放的，也就不会产生无法给进程使用的小内存。&lt;/p>
&lt;p>如果内存空间不够，操作系统会把其他正在运行的进程中的「最近没被使用」的内存页面给释放掉，也就是暂时写在硬盘上，称为换出（Swap Out）。一旦需要的时候，再加载进来，称为换入（Swap In）。所以，一次性写入磁盘的也只有少数的一个页或者几个页，不会花太多时间，内存交换的效率就相对比较高。&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/odexpg/1616167919157-7b5cfce7-6d02-4a53-8193-49982f06399f.jpeg" alt="">&lt;/p>
&lt;p>换入换出&lt;/p>
&lt;p>更进一步地，分页的方式使得我们在加载程序的时候，不再需要一次性都把程序加载到物理内存中。我们完全可以在进行虚拟内存和物理内存的页之间的映射之后，并不真的把页加载到物理内存里，而是只有在程序运行中，需要用到对应虚拟内存页里面的指令和数据时，再加载到物理内存里面去。&lt;/p>
&lt;p>分页机制下，虚拟地址和物理地址是如何映射的？&lt;/p>
&lt;p>在分页机制下，虚拟地址分为两部分，页号和页内偏移。页号作为页表的索引，页表包含物理页每页所在物理内存的基地址，这个基地址与页内偏移的组合就形成了物理内存地址，见下图。&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/odexpg/1616167919140-c0d128d7-0238-450c-981a-8477221071a4.jpeg" alt="">&lt;/p>
&lt;p>内存分页寻址&lt;/p>
&lt;p>总结一下，对于一个内存地址转换，其实就是这样三个步骤：&lt;/p>
&lt;ul>
&lt;li>把虚拟内存地址，切分成页号和偏移量；&lt;/li>
&lt;li>根据页号，从页表里面，查询对应的物理页号；&lt;/li>
&lt;li>直接拿物理页号，加上前面的偏移量，就得到了物理内存地址。&lt;/li>
&lt;/ul>
&lt;p>下面举个例子，虚拟内存中的页通过页表映射为了物理内存中的页，如下图：&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/odexpg/1616167919128-24ebe4f8-b4c8-407b-8dc5-98da804e5e0c.jpeg" alt="">&lt;/p>
&lt;p>虚拟页与物理页的映射&lt;/p>
&lt;p>这看起来似乎没什么毛病，但是放到实际中操作系统，这种简单的分页是肯定是会有问题的。&lt;/p>
&lt;p>简单的分页有什么缺陷吗？&lt;/p>
&lt;p>有空间上的缺陷。&lt;/p>
&lt;p>因为操作系统是可以同时运行非常多的进程的，那这不就意味着页表会非常的庞大。&lt;/p>
&lt;p>在 32 位的环境下，虚拟地址空间共有 4GB，假设一个页的大小是 4KB（2^12），那么就需要大约 100 万 （2^20） 个页，每个「页表项」需要 4 个字节大小来存储，那么整个 4GB 空间的映射就需要有 4MB 的内存来存储页表。&lt;/p>
&lt;p>这 4MB 大小的页表，看起来也不是很大。但是要知道每个进程都是有自己的虚拟地址空间的，也就说都有自己的页表。&lt;/p>
&lt;p>那么，100 个进程的话，就需要 400MB 的内存来存储页表，这是非常大的内存了，更别说 64 位的环境了。&lt;/p>
&lt;h3 id="多级页表">多级页表&lt;/h3>
&lt;p>要解决上面的问题，就需要采用的是一种叫作多级页表（Multi-Level Page Table）的解决方案。&lt;/p>
&lt;p>在前面我们知道了，对于单页表的实现方式，在 32 位和页大小 4KB 的环境下，一个进程的页表需要装下 100 多万个「页表项」，并且每个页表项是占用 4 字节大小的，于是相当于每个页表需占用 4MB 大小的空间。&lt;/p>
&lt;p>我们把这个 100 多万个「页表项」的单级页表再分页，将页表（一级页表）分为 1024 个页表（二级页表），每个表（二级页表）中包含 1024 个「页表项」，形成二级分页。如下图所示：&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/odexpg/1616167919185-cc42b53c-b247-413b-b8ea-9545012c17a3.jpeg" alt="">&lt;/p>
&lt;p>二级分页&lt;/p>
&lt;p>你可能会问，分了二级表，映射 4GB 地址空间就需要 4KB（一级页表）+ 4MB（二级页表）的内存，这样占用空间不是更大了吗？&lt;/p>
&lt;p>当然如果 4GB 的虚拟地址全部都映射到了物理内上的，二级分页占用空间确实是更大了，但是，我们往往不会为一个进程分配那么多内存。&lt;/p>
&lt;p>其实我们应该换个角度来看问题，还记得计算机组成原理里面无处不在的局部性原理么？&lt;/p>
&lt;p>每个进程都有 4GB 的虚拟地址空间，而显然对于大多数程序来说，其使用到的空间远未达到 4GB，因为会存在部分对应的页表项都是空的，根本没有分配，对于已分配的页表项，如果存在最近一定时间未访问的页表，在物理内存紧张的情况下，操作系统会将页面换出到硬盘，也就是说不会占用物理内存。&lt;/p>
&lt;p>如果使用了二级分页，一级页表就可以覆盖整个 4GB 虚拟地址空间，但如果某个一级页表的页表项没有被用到，也就不需要创建这个页表项对应的二级页表了，即可以在需要时才创建二级页表。做个简单的计算，假设只有 20% 的一级页表项被用到了，那么页表占用的内存空间就只有 4KB（一级页表） + 20% * 4MB（二级页表）= 0.804MB&lt;/p>
&lt;p>，这对比单级页表的 4MB 是不是一个巨大的节约？&lt;/p>
&lt;p>那么为什么不分级的页表就做不到这样节约内存呢？我们从页表的性质来看，保存在内存中的页表承担的职责是将虚拟地址翻译成物理地址。假如虚拟地址在页表中找不到对应的页表项，计算机系统就不能工作了。所以页表一定要覆盖全部虚拟地址空间，不分级的页表就需要有 100 多万个页表项来映射，而二级分页则只需要 1024 个页表项（此时一级页表覆盖到了全部虚拟地址空间，二级页表在需要时创建）。&lt;/p>
&lt;p>我们把二级分页再推广到多级页表，就会发现页表占用的内存空间更少了，这一切都要归功于对局部性原理的充分应用。&lt;/p>
&lt;p>对于 64 位的系统，两级分页肯定不够了，就变成了四级目录，分别是：&lt;/p>
&lt;ul>
&lt;li>全局页目录项 PGD（Page Global Directory）；&lt;/li>
&lt;li>上层页目录项 PUD（Page Upper Directory）；&lt;/li>
&lt;li>中间页目录项 PMD（Page Middle Directory）；&lt;/li>
&lt;li>页表项 PTE（Page Table Entry）；&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/odexpg/1616167919165-47fbe1d8-e5a2-421b-9215-5152f9f6d457.jpeg" alt="">&lt;/p>
&lt;p>四级目录&lt;/p>
&lt;h3 id="tlb">TLB&lt;/h3>
&lt;p>多级页表虽然解决了空间上的问题，但是虚拟地址到物理地址的转换就多了几道转换的工序，这显然就降低了这俩地址转换的速度，也就是带来了时间上的开销。&lt;/p>
&lt;p>程序是有局部性的，即在一段时间内，整个程序的执行仅限于程序中的某一部分。相应地，执行所访问的存储空间也局限于某个内存区域。&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/odexpg/1616167919150-0d7ed5fb-19de-4398-84ca-e77a4c67ab46.jpeg" alt="">&lt;/p>
&lt;p>程序的局部性&lt;/p>
&lt;p>我们就可以利用这一特性，把最常访问的几个页表项存储到访问速度更快的硬件，于是计算机科学家们，就在 CPU 芯片中，加入了一个专门存放程序最常访问的页表项的 Cache，这个 Cache 就是 Translation Lookaside Buffer(转译后备缓冲器，简称 TLB、缓存、快表)等。&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/odexpg/1616167919151-684032a9-151a-4c86-be9a-7535abfc6444.jpeg" alt="">&lt;/p>
&lt;p>地址转换&lt;/p>
&lt;p>在 CPU 芯片里面，封装了内存管理单元（Memory Management Unit）芯片，它用来完成地址转换和 TLB 的访问与交互。&lt;/p>
&lt;p>有了 TLB 后，那么 CPU 在寻址时，会先查 TLB，如果没找到，才会继续查常规的页表。&lt;/p>
&lt;p>TLB 的命中率其实是很高的，因为程序最常访问的页就那么几个。&lt;/p>
&lt;h2 id="段页式内存管理">段页式内存管理&lt;/h2>
&lt;p>内存分段和内存分页并不是对立的，它们是可以组合起来在同一个系统中使用的，那么组合起来后，通常称为段页式内存管理。&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/odexpg/1616167919147-0a7f2b14-9364-4a8e-ba60-c48e8cdf65d0.jpeg" alt="">&lt;/p>
&lt;p>段页式地址空间&lt;/p>
&lt;p>段页式内存管理实现的方式：&lt;/p>
&lt;ul>
&lt;li>先将程序划分为多个有逻辑意义的段，也就是前面提到的分段机制；&lt;/li>
&lt;li>接着再把每个段划分为多个页，也就是对分段划分出来的连续空间，再划分固定大小的页；&lt;/li>
&lt;/ul>
&lt;p>这样，地址结构就由段号、段内页号和页内位移三部分组成。&lt;/p>
&lt;p>用于段页式地址变换的数据结构是每一个程序一张段表，每个段又建立一张页表，段表中的地址是页表的起始地址，而页表中的地址则为某页的物理页号，如图所示：&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/odexpg/1616167919172-07b25f4c-02c8-47f2-a784-d89ba249e13e.jpeg" alt="">&lt;/p>
&lt;p>段页式管理中的段表、页表与内存的关系&lt;/p>
&lt;p>段页式地址变换中要得到物理地址须经过三次内存访问：&lt;/p>
&lt;ul>
&lt;li>第一次访问段表，得到页表起始地址；&lt;/li>
&lt;li>第二次访问页表，得到物理页号；&lt;/li>
&lt;li>第三次将物理页号与页内位移组合，得到物理地址。&lt;/li>
&lt;/ul>
&lt;p>可用软、硬件相结合的方法实现段页式地址变换，这样虽然增加了硬件成本和系统开销，但提高了内存的利用率。&lt;/p>
&lt;h1 id="linux-内存管理">Linux 内存管理&lt;/h1>
&lt;p>那么，Linux 操作系统采用了哪种方式来管理内存呢？&lt;/p>
&lt;p>在回答这个问题前，我们得先看看 Intel 处理器的发展历史。&lt;/p>
&lt;p>早期 Intel 的处理器从 80286 开始使用的是段式内存管理。但是很快发现，光有段式内存管理而没有页式内存管理是不够的，这会使它的 X86 系列会失去市场的竞争力。因此，在不久以后的 80386 中就实现了对页式内存管理。也就是说，80386 除了完成并完善从 80286 开始的段式内存管理的同时还实现了页式内存管理。&lt;/p>
&lt;p>但是这个 80386 的页式内存管理设计时，没有绕开段式内存管理，而是建立在段式内存管理的基础上，这就意味着，页式内存管理的作用是在由段式内存管理所映射而成的的地址上再加上一层地址映射。&lt;/p>
&lt;p>由于此时段式内存管理映射而成的地址不再是“物理地址”了，Intel 就称之为“线性地址”（也称虚拟地址）。于是，段式内存管理先将逻辑地址映射成线性地址，然后再由页式内存管理将线性地址映射成物理地址。&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/odexpg/1616167919178-17fb261b-55fa-44ac-a553-ed8a842e9080.jpeg" alt="">&lt;/p>
&lt;p>Intel X86 逻辑地址解析过程&lt;/p>
&lt;p>这里说明下逻辑地址和线性地址：&lt;/p>
&lt;ul>
&lt;li>程序所使用的地址，通常是没被段式内存管理映射的地址，称为逻辑地址；&lt;/li>
&lt;li>通过段式内存管理映射的地址，称为线性地址，也叫虚拟地址；&lt;/li>
&lt;/ul>
&lt;p>逻辑地址是「段式内存管理」转换前的地址，线性地址则是「页式内存管理」转换前的地址。&lt;/p>
&lt;p>了解完 Intel 处理器的发展历史后，我们再来说说 Linux 采用了什么方式管理内存？&lt;/p>
&lt;p>Linux 内存主要采用的是页式内存管理，但同时也不可避免地涉及了段机制。&lt;/p>
&lt;p>这主要是上面 Intel 处理器发展历史导致的，因为 Intel X86 CPU 一律对程序中使用的地址先进行段式映射，然后才能进行页式映射。既然 CPU 的硬件结构是这样，Linux 内核也只好服从 Intel 的选择。&lt;/p>
&lt;p>但是事实上，Linux 内核所采取的办法是使段式映射的过程实际上不起什么作用。也就是说，“上有政策，下有对策”，若惹不起就躲着走。&lt;/p>
&lt;p>Linux 系统中的每个段都是从 0 地址开始的整个 4GB 虚拟空间（32 位环境下），也就是所有的段的起始地址都是一样的。这意味着，Linux 系统中的代码，包括操作系统本身的代码和应用程序代码，所面对的地址空间都是线性地址空间（虚拟地址），这种做法相当于屏蔽了处理器中的逻辑地址概念，段只被用于访问控制和内存保护。&lt;/p>
&lt;p>我们再来瞧一瞧，Linux 的虚拟地址空间是如何分布的？&lt;/p>
&lt;p>在 Linux 操作系统中，虚拟地址空间的内部又被分为内核空间和用户空间两部分，不同位数的系统，地址空间的范围也不同。比如最常见的 32 位和 64 位系统，如下所示：&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/odexpg/1616167919191-4099f869-9dbe-462c-90f6-ff02cec5a9a6.jpeg" alt="">&lt;/p>
&lt;p>用户空间与内存空间&lt;/p>
&lt;p>通过这里可以看出：&lt;/p>
&lt;ul>
&lt;li>32 位系统的内核空间占用 1G，位于最高处，剩下的 3G 是用户空间；&lt;/li>
&lt;li>64 位系统的内核空间和用户空间都是 128T，分别占据整个内存空间的最高和最低处，剩下的中间部分是未定义的。&lt;/li>
&lt;/ul>
&lt;p>再来说说，内核空间与用户空间的区别：&lt;/p>
&lt;ul>
&lt;li>进程在用户态时，只能访问用户空间内存；&lt;/li>
&lt;li>只有进入内核态后，才可以访问内核空间的内存；&lt;/li>
&lt;/ul>
&lt;p>虽然每个进程都各自有独立的虚拟内存，但是每个虚拟内存中的内核地址，其实关联的都是相同的物理内存。这样，进程切换到内核态后，就可以很方便地访问内核空间内存。&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/odexpg/1616167919223-81c46952-4cf1-4b83-a9a5-2bdd118168b6.jpeg" alt="">&lt;/p>
&lt;p>每个进程的内核空间都是一致的&lt;/p>
&lt;p>接下来，进一步了解虚拟空间的划分情况，用户空间和内核空间划分的方式是不同的，内核空间的分布情况就不多说了。&lt;/p>
&lt;p>我们看看用户空间分布的情况，以 32 位系统为例，我画了一张图来表示它们的关系：&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/odexpg/1616167919192-30c3ec2b-724a-4146-9bc4-3c630ea69e13.jpeg" alt="">&lt;/p>
&lt;p>虚拟内存空间划分&lt;/p>
&lt;p>通过这张图你可以看到，用户空间内存，从低到高分别是 7 种不同的内存段：&lt;/p>
&lt;ul>
&lt;li>程序文件段，包括二进制可执行代码；&lt;/li>
&lt;li>已初始化数据段，包括静态常量；&lt;/li>
&lt;li>未初始化数据段，包括未初始化的静态变量；&lt;/li>
&lt;li>堆段，包括动态分配的内存，从低地址开始向上增长；&lt;/li>
&lt;li>文件映射段，包括动态库、共享内存等，从低地址开始向上增长（跟硬件和内核版本有关）&lt;/li>
&lt;li>栈段，包括局部变量和函数调用的上下文等。栈的大小是固定的，一般是 8 MB。当然系统也提供了参数，以便我们自定义大小；&lt;/li>
&lt;/ul>
&lt;p>在这 7 个内存段中，堆和文件映射段的内存是动态分配的。比如说，使用 C 标准库的 malloc() 或者 mmap() ，就可以分别在堆和文件映射段动态分配内存。&lt;/p>
&lt;h1 id="总结">总结&lt;/h1>
&lt;p>为了在多进程环境下，使得进程之间的内存地址不受影响，相互隔离，于是操作系统就为每个进程独立分配一套的虚拟地址空间，每个程序只关心自己的虚拟地址就可以，实际上大家的虚拟地址都是一样的，但分布到物理地址内存是不一样的。作为程序，也不用关心物理地址的事情。&lt;/p>
&lt;p>每个进程都有自己的虚拟空间，而物理内存只有一个，所以当启用了大量的进程，物理内存必然会很紧张，于是操作系统会通过内存交换技术，把不常使用的内存暂时存放到硬盘（换出），在需要的时候再装载回物理内存（换入）。&lt;/p>
&lt;p>那既然有了虚拟地址空间，那必然要把虚拟地址「映射」到物理地址，这个事情通常由操作系统来维护。&lt;/p>
&lt;p>那么对于虚拟地址与物理地址的映射关系，可以有分段和分页的方式，同时两者结合都是可以的。&lt;/p>
&lt;p>内存分段是根据程序的逻辑角度，分成了栈段、堆段、数据段、代码段等，这样可以分离出不同属性的段，同时是一块连续的空间。但是每个段的大小都不是统一的，这就会导致内存碎片和内存交换效率低的问题。&lt;/p>
&lt;p>于是，就出现了内存分页，把虚拟空间和物理空间分成大小固定的页，如在 Linux 系统中，每一页的大小为 4KB。由于分了页后，就不会产生细小的内存碎片。同时在内存交换的时候，写入硬盘也就一个页或几个页，这就大大提高了内存交换的效率。&lt;/p>
&lt;p>再来，为了解决简单分页产生的页表过大的问题，就有了多级页表，它解决了空间上的问题，但这就会导致 CPU 在寻址的过程中，需要有很多层表参与，加大了时间上的开销。于是根据程序的局部性原理，在 CPU 芯片中加入了 TLB，负责缓存最近常被访问的页表项，大大提高了地址的转换速度。&lt;/p>
&lt;p>Linux 系统主要采用了分页管理，但是由于 Intel 处理器的发展史，Linux 系统无法避免分段管理。于是 Linux 就把所有段的基地址设为 0，也就意味着所有程序的地址空间都是线性地址空间（虚拟地址），相当于屏蔽了 CPU 逻辑地址的概念，所以段只被用于访问控制和内存保护。&lt;/p>
&lt;p>另外，Linxu 系统中虚拟空间分布可分为用户态和内核态两部分，其中用户态的分布：代码段、全局变量、BSS、函数栈、堆内存、映射区。&lt;/p></description></item><item><title>Docs: 5.登录 Linux 与 访问控制</title><link>https://desistdaydream.github.io/docs/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/5.%E7%99%BB%E5%BD%95-Linux-%E4%B8%8E-%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6/5.%E7%99%BB%E5%BD%95-Linux-%E4%B8%8E-%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/5.%E7%99%BB%E5%BD%95-Linux-%E4%B8%8E-%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6/5.%E7%99%BB%E5%BD%95-Linux-%E4%B8%8E-%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;/blockquote>
&lt;p>想要登录 Linux，必须通过 [&lt;strong>Terminal(终端)&lt;/strong>](/docs/1.操作系统/4.Terminal%20 与%20Shell/4.Terminal%20 与%20Shell.md 与 Shell.md)，我们才可以与操作系统进行交互。&lt;/p>
&lt;p>本质上，想要登录 Linux，必然需要调用某些程序(比如 Shell)，以便分配一个终端。通常，我们有多种方式可供选择：&lt;/p>
&lt;ul>
&lt;li>本地命令行登录&lt;/li>
&lt;li>远程命令行登录&lt;/li>
&lt;li>图形界面登录&lt;/li>
&lt;/ul>
&lt;p>Linux 操作系统是一个多用户操作系统，所以除了 &lt;strong>Terminal(终端)&lt;/strong> 以外，还需 &lt;strong>Account(账户)&lt;/strong> 才可以登录上去，Linux 操作系统允许多个用户访问安装在一台机器上的单个系统。每个 &lt;strong>User(用户)&lt;/strong> 都在自己的 &lt;strong>Account(账户)&lt;/strong> 下操作。因此，Account Manager 代表了 Linux 系统管理的核心要素。&lt;/p>
&lt;h1 id="登录-linux">登录 Linux&lt;/h1>
&lt;p>我们可以通过多种方式登录 Linux&lt;/p>
&lt;ul>
&lt;li>本地登录&lt;/li>
&lt;li>远程登录&lt;/li>
&lt;/ul>
&lt;h2 id="通过本地-tty-登陆-linux-系统">通过本地 TTY 登陆 Linux 系统&lt;/h2>
&lt;p>登录 Linux 最基本的方式，就是使用 &lt;code>login&lt;/code> 程序。&lt;/p>
&lt;h3 id="login-程序">login 程序&lt;/h3>
&lt;p>由于历史原因，&lt;code>login&lt;/code> 可能被包含在两个包中：&lt;/p>
&lt;ul>
&lt;li>util-linux&lt;/li>
&lt;li>shadow-utils&lt;/li>
&lt;/ul>
&lt;h4 id="login-的登录行为">login 的登录行为&lt;/h4>
&lt;p>当我们刚刚安装完操作系统，systemd-logind.service 服务会让我们看到这样的画面&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/gwpmr6/1634785246289-3a353c73-2899-4b6c-8341-ffc4a02008ef.png" alt="image.png">&lt;/p>
&lt;p>想要在服务器本地登录系统，则需要进行认证，在输入用户名之后，实际上是调用了 &lt;code>login&lt;/code> 这个二进制程序，看到：&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/gwpmr6/1634785206973-885fa7fb-3dfb-4fb1-80c8-1c56cb903974.png" alt="image.png">&lt;/p>
&lt;p>此时我们通过远程方式(如果可以的话)登录服务器，查看进程，将会看到名为 login 的进程&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>~&lt;span style="color:#f92672">]&lt;/span>$ pgrep login -alf
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">600&lt;/span> /lib/systemd/systemd-logind
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">1476&lt;/span> /bin/login -p --
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>当我们输入完密码，经过 &lt;a href="https://desistdaydream.github.io/docs/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/5.%E7%99%BB%E5%BD%95%20Linux%20%E4%B8%8E%20%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6/Access%20Control(%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6)/Access%20Control(%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6).md">Access Control(访问控制)&lt;/a> 相关程序的认证之后，login 工具会为我们分配一个 ttyX 的终端设备，然后我们就可以通过 tty 所关联的 Shell(通常是 bash)，与系统进行交互&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/gwpmr6/1634785329507-0cb1fcec-8c6e-4fd0-a99f-005a2b19807e.png" alt="image.png">&lt;/p>
&lt;h4 id="login-关联文件与配置">login 关联文件与配置&lt;/h4>
&lt;p>&lt;strong>/etc/login.defs&lt;/strong> # shadow 与 password 套件的配置文件。
&lt;strong>/etc/pam.d/login&lt;/strong> #&lt;/p>
&lt;h2 id="通过远程的方式来登陆-linux-系统">通过远程的方式来登陆 Linux 系统&lt;/h2>
&lt;h3 id="ssh-程序">ssh 程序&lt;/h3>
&lt;p>详见：&lt;a href="https://desistdaydream.github.io/docs/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/5.%E7%99%BB%E5%BD%95%20Linux%20%E4%B8%8E%20%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6/Secure%20Shell(SSH)%20%E5%AE%89%E5%85%A8%E5%A4%96%E5%A3%B3%E5%8D%8F%E8%AE%AE/Secure%20Shell(SSH)%20%E5%AE%89%E5%85%A8%E5%A4%96%E5%A3%B3%E5%8D%8F%E8%AE%AE.md">Secure Shell(SSH) 安全外壳协议&lt;/a>&lt;/p>
&lt;pre>&lt;code>root 981 1 0 Jul08 ? Ss 0:00 /usr/sbin/sshd -D
root 1947 981 0 09:05 ? Ss 0:00 \_ sshd: root@pts/0
root 1949 1947 1 09:05 pts/0 Ss 0:00 \_ -bash
root 1970 1949 0 09:05 pts/0 R+ 0:00 \_ ps -ef f
&lt;/code>&lt;/pre>
&lt;p>OpenSSH 会为用户分配一个 Pseudoterminal(伪终端，即 pts) 以便用户可以与操作系统进行交互。&lt;/p>
&lt;h1 id="登录提示信息">登录提示信息&lt;/h1>
&lt;p>通过 &lt;code>touch ~/.hushlogin&lt;/code> 命令可以为当前用户禁用欢迎信息。&lt;/p>
&lt;h2 id="motd">MOTD&lt;/h2>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Motd_(Unix)">Wiki:MOTD&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://man7.org/linux/man-pages/man5/motd.5.html">Manual(手册)，MOTD&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>&lt;strong>Message of the day(每日消息，简称 MOTD)&lt;/strong> 是一种比向所有用户发送一个邮件更有效的发送共同的信息的方式&lt;/p>
&lt;h4 id="motd-关联文件">MOTD 关联文件&lt;/h4>
&lt;p>&lt;strong>/etc/default/motd-news&lt;/strong> # 动态 MOTD 新闻信息配置，新闻信息主要是互联网相关的
&lt;strong>/etc/update-motd.d/*&lt;/strong> # MOTD 执行脚本保存路径
&lt;strong>~/.hushlogin&lt;/strong> # 该文件存在时，将为当前用户禁用 MOTD 消息
&lt;strong>/etc/pam.d/sshd&lt;/strong> # PAM 模块中可以为 sshd 配置 MOTD。&lt;/p>
&lt;h1 id="访问控制">访问控制&lt;/h1>
&lt;p>Linux 的登录与访问控制是相辅相成的，一个用户想要登录 Linux，通常来说都需要经过访问控制系统对其所使用的账户进行认证，只有认证通过后，才可以正常登录。&lt;/p>
&lt;p>一个正常的 Linux 发行版操作系统，通常都提供了多种方式&lt;/p>
&lt;ul>
&lt;li>密码&lt;/li>
&lt;li>会话&lt;/li>
&lt;li>账户锁定&lt;/li>
&lt;li>等等&amp;hellip;&amp;hellip;&lt;/li>
&lt;/ul>
&lt;h2 id="account-manager账户管理">Account Manager(账户管理)&lt;/h2>
&lt;p>详见 &lt;a href="https://desistdaydream.github.io/docs/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/5.%E7%99%BB%E5%BD%95%20Linux%20%E4%B8%8E%20%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6/Account%20Manager(%E8%B4%A6%E6%88%B7%E7%AE%A1%E7%90%86)/Account%20Manager(%E8%B4%A6%E6%88%B7%E7%AE%A1%E7%90%86).md">Account Manager(账户管理)&lt;/a>&lt;/p>
&lt;h1 id="多窗口操作">多窗口操作&lt;/h1>
&lt;p>登录服务器后，我们可以重复登录，以便在多个窗口执行不同的操作以观察服务器状态或排查问题。&lt;/p>
&lt;p>但是当我们在机房通过显示器连接到服务器时，是不像使用 ssh 命令一样方便的，但是依然可以实现多窗口操作。&lt;/p>
&lt;p>使用 &lt;code>Ctrl + Alt + F&amp;lt;X&amp;gt;&lt;/code> 快捷键，即可打开其他窗口，&lt;code>Ctrl + Alt + F2&lt;/code> 切换到第二个窗口，F1 可以切回第一个默认窗口。&lt;/p></description></item><item><title>Docs: 6.File System 管理</title><link>https://desistdaydream.github.io/docs/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2.Kernel%E5%86%85%E6%A0%B8/6.File_System_%E7%AE%A1%E7%90%86/6.File_System_%E7%AE%A1%E7%90%86/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2.Kernel%E5%86%85%E6%A0%B8/6.File_System_%E7%AE%A1%E7%90%86/6.File_System_%E7%AE%A1%E7%90%86/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Category:Computer_file_systems">Wiki-Category,Computer file systemd&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://time.geekbang.org/column/article/76876">Linux 性能优化实践-文件系统&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://mp.weixin.qq.com/s/qJdoXTv_XS_4ts9YuzMNIw">公众号，小林 coding-一口气搞懂「文件系统」，就靠这 25 张图了&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/op2fw9/1616167805545-2b948cff-7e56-4eb8-8c12-3851fd6c2e36.png" alt="">&lt;/p>
&lt;blockquote>
&lt;p>图片来源：&lt;a href="https://www.thomas-krenn.com/en/wiki/Linux_Storage_Stack_Diagram">https://www.thomas-krenn.com/en/wiki/Linux_Storage_Stack_Diagram&lt;/a>
从上面的结构可以看到，文件系统的作用就是用来接收用户的操作，并将数据保存到物理硬盘的。可以想见，如果没有文件系统帮助用户操作，那么人们又怎么能将数据保存到存储设备上呢~&lt;/p>
&lt;/blockquote>
&lt;p>&lt;strong>File System(文件系统，简称 FS)&lt;/strong> 是一种对存储设备上的数据，进行组织管理的机制。组织方式的不同，就会形成不同的文件系统。&lt;/p>
&lt;p>如果没有文件系统，放置在存储介质中的数据将是一个庞大的数据主体，无法分辨一个数据在哪里停止以及下一个数据在哪里开始。通过将数据分成多个部分并给每个部分命名，可以轻松地隔离和识别数据。每组数据称为 &lt;strong>File(文件)&lt;/strong>。所以，用于管理这些文件及其名称的&lt;strong>结构和逻辑规则&lt;/strong>，称为 &lt;strong>File System(文件系统)&lt;/strong>。&lt;/p>
&lt;h2 id="什么是-file文件">什么是 File(文件)&lt;/h2>
&lt;p>详见《&lt;a href="https://desistdaydream.github.io/docs/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2.Kernel(%E5%86%85%E6%A0%B8)/6.File_System_%E7%AE%A1%E7%90%86/%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86/%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86.md">文件管理&lt;/a>》章节&lt;/p>
&lt;h1 id="文件组织结构">文件组织结构&lt;/h1>
&lt;blockquote>
&lt;p>文件管理详解见&lt;a href="https://desistdaydream.github.io/docs/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2.Kernel(%E5%86%85%E6%A0%B8)/6.File_System_%E7%AE%A1%E7%90%86/%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86/%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86.md">单独章节&lt;/a>&lt;/p>
&lt;/blockquote>
&lt;p>为了方便管理，Linux 的文件系统为每个文件都分配了两个数据结构。&lt;/p>
&lt;ul>
&lt;li>&lt;strong>index node(索引节点，简称 inode)&lt;/strong> # 记录文件的元数据。inode 编号、文件大小、访问权限、修改日期、数据的位置等。
&lt;ul>
&lt;li>inode 和文件一一对应，它跟文件内容一样，都会被持久化到存储的磁盘中。所以&lt;strong>inode 同样占用磁盘空间&lt;/strong>。&lt;/li>
&lt;li>inode 包含文件的元数据，具体来说有以下内容：
&lt;ul>
&lt;li>文件的字节数&lt;/li>
&lt;li>文件拥有者的 User ID&lt;/li>
&lt;li>文件的 Group ID&lt;/li>
&lt;li>文件的读、写、执行权限&lt;/li>
&lt;li>文件的时间戳，共有三个：ctime 指 inode 上一次变动的时间，mtime 指文件内容上一次变动的时间，atime 指文件上一次打开的时间。&lt;/li>
&lt;li>链接数，即有多少文件名指向这个 inode&lt;/li>
&lt;li>文件数据 block 的位置&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>directory entry(目录项，简称 dentry)&lt;/strong> # 记录文件的名字、inode 指针、与其他目录项的关联关系。
&lt;ul>
&lt;li>多个关联的目录项，就构成了文件系统的目录结构(&lt;strong>一个层次化的树形结构&lt;/strong>)。不过，不同于 inode，目录项是由内核维护的一个内存数据结构，所以通常也被叫做 &lt;strong>dentries(目录项缓存)。&lt;/strong>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>这个层次化的树形结构就像下图一样：
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/op2fw9/1617088781476-3d7a9ccc-e8df-4680-acc5-26f4f82aa8b5.png" alt="image.png">
&lt;strong>注意：目录项缓存记录在 slab 中，当我们使用 find 命令时，slab 中的 dentry 缓存就会增大；打开文件过多，slab 中的 dentry 缓存也会增大。&lt;/strong>&lt;/p>
&lt;p>inode 是每个文件的唯一标志，而 dentry 维护的正是文件系统的树状结构。dentry 与 inode 的关系是多对一(可以简单理解为一个文件可以有多个别名)&lt;/p>
&lt;p>下面用一个形象点的白话来描述这些概念，假如现在系统中有如下目录结构&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>~&lt;span style="color:#f92672">]&lt;/span>&lt;span style="color:#75715e"># tree --inodes&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>.
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>├── &lt;span style="color:#f92672">[&lt;/span> 2218&lt;span style="color:#f92672">]&lt;/span> dir_1 &lt;span style="color:#75715e"># 这是目录类型的文件&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>│ ├── &lt;span style="color:#f92672">[&lt;/span> 2235&lt;span style="color:#f92672">]&lt;/span> file_1 &lt;span style="color:#75715e"># 这是普通类型的文件&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>│ └── &lt;span style="color:#f92672">[&lt;/span> 2236&lt;span style="color:#f92672">]&lt;/span> file_2
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>├── &lt;span style="color:#f92672">[&lt;/span>269167463&lt;span style="color:#f92672">]&lt;/span> dir_2
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>│ └── &lt;span style="color:#f92672">[&lt;/span>269167464&lt;span style="color:#f92672">]&lt;/span> file_3
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>└── &lt;span style="color:#f92672">[&lt;/span>537384536&lt;span style="color:#f92672">]&lt;/span> dir_3
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ├── &lt;span style="color:#f92672">[&lt;/span> 2235&lt;span style="color:#f92672">]&lt;/span> fie_1_ln
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> └── &lt;span style="color:#f92672">[&lt;/span>537384537&lt;span style="color:#f92672">]&lt;/span> file_4
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">3&lt;/span> directories, &lt;span style="color:#ae81ff">5&lt;/span> files
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>可以这么描述上述看到的内容：dir_1、file_1、dir_2 这些名称都是 dentry 中的文件名，&lt;code>[]&lt;/code> 中的数字是 inode 号，每个 dentry 都会与 inode 关联。其中 file_1 和 file_1_ln 的 inode 相同，但是 dentry 不同，这就对应了 dentry 与 inode 是多对一的关系。而哪些文件在哪个目录中，则是由每个文件的 dentry 中的关联关系来决定。比如 dir_1 目录中，包含了 file_1 和 file_2 文件。&lt;/p>
&lt;blockquote>
&lt;p>索引节点和目录项记录了文件的元数据，以及文件间的目录关系，那么具体来说，文件数据到底是怎么存储的呢？是不是直接写到磁盘中就好了呢？
实际上，磁盘读写的最小单位是扇区，然而扇区只有 512B 大小，如果每次都读写这么小的单位，效率一定很低。所以，文件系统又把连续的扇区组成了逻辑块，然后每次都以逻辑块为最小单元，来管理数据。常见的逻辑块大小为 4KB，也就是由连续的 8 个扇区组成。&lt;/p>
&lt;/blockquote>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/op2fw9/1616167805558-180916c2-cc19-40a0-b8f4-3ff805929883.png" alt="">&lt;/p>
&lt;p>注意：&lt;/p>
&lt;ul>
&lt;li>dentry 本身只是一个存储在内存中的缓存，而 inode 则是存储在磁盘中的数据。由于内存的 Buffer 和 Cache 原理，所以 inode 也会缓存到内存中，以便加速文件的访问。&lt;/li>
&lt;li>磁盘在执行文件系统格式化时，会被分成三个存储区域，超级快、索引节点区、数据区块
&lt;ul>
&lt;li>超级块 # 存储整个文件系统的状态&lt;/li>
&lt;li>索引节点区 # 存储 inode&lt;/li>
&lt;li>数据区块 # 存储文件数据&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>我们不可能把超级块和索引节点区全部加载到内存，这样内存肯定撑不住，所以只有当需要使用的时候，才将其加载进内存，它们加载进内存的时机是不同的：
&lt;ul>
&lt;li>超级块 # 当文件系统挂载时进入内存；&lt;/li>
&lt;li>索引节点区 # 当文件被访问时进入内存&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>dentry、inode、逻辑块以及超级块构成了 Linux 文件系统的四大基本要素。&lt;/p>
&lt;h2 id="小结">小结&lt;/h2>
&lt;p>通过上面的描述，文件在文件系统中，也就可以归纳为两个部分&lt;/p>
&lt;ul>
&lt;li>指针部分 # 指针位于文件系统的元数据中，在将数据删除后，这个指针就从元数据中清除了(元数据其实就是上文的 inode 与 dentry)。&lt;/li>
&lt;li>数据部分 # 文件的具体内容，存储在磁盘中。&lt;/li>
&lt;/ul>
&lt;p>平时我们在删除数据时，其实仅仅从元数据中删除了数据对应的指针。当指针被删除时，其原本占用的空间就可以被覆盖并写入新内容。&lt;/p>
&lt;h2 id="常见问题">常见问题&lt;/h2>
&lt;ul>
&lt;li>这也是为什么我们可以恢复数据的原因，只要旧数据还没被覆盖，就依然可以获取到。&lt;/li>
&lt;li>有时候在删除文件时，会发现并没有释放空间，也是同样的道理，当某个进程持续写入内容时，如果强制删除了文件，由于进程锁定文件对应的指针部分并不会从元数据中清除，而由于指针并未删除，系统内核就默认文件并未删除，因此查询文件系统空间时，显示空间并未释放。可以通过 lsof 命令筛选 deleted 查找这些有问题的文件。&lt;/li>
&lt;/ul>
&lt;h1 id="virtual-file-system虚拟文件系统">Virtual File System(虚拟文件系统)&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Virtual_file_system">Wiki,，Virtual file system&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://zhuanlan.zhihu.com/p/69289429">知乎&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://time.geekbang.org/column/article/76876">极客-Linux 性能优化实践&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>&lt;strong>Virtual File System(虚拟文件系统，简称 VFS)&lt;/strong> 是 Linux 为了支持多种多样的文件系统，在用户空间进程和文件系统中间，引入的一个抽象层。VFS 的目的是运行客户端应用程序以统一的方式访问不同类型的文件系统。VFS &lt;strong>定义了&lt;/strong>一组所有文件系统都支持的&lt;strong>数据结构和标准 API&lt;/strong>。这样，用户进程和内核中的其他子系统，只需要跟 VFS 提供的统一接口进行交互即可，而不需要关系底层各种文件系统的实现细节。&lt;/p>
&lt;blockquote>
&lt;p>比如不同文件系统的调用函数不一样，如果没有 VFS ，那么在使用的时候，就需要为特定的文件系统，编写不同的调用方式，非常繁琐复杂。&lt;/p>
&lt;p>比如 VFS 可以用来弥合 Windows、MacOS、Unix 文件系统中的差异，以便应用程序可以访问那些类型的本地文件系统上的文件，而不必知道它们正在访问哪种文件系统。&lt;/p>
&lt;/blockquote>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/op2fw9/1616167805621-09dbf293-4f9a-4892-8e30-8d33f32031c4.png" alt="">&lt;/p>
&lt;p>举个例子，Linux 用户程序可以通过&lt;code>read()&lt;/code> 来读取&lt;code>ext4&lt;/code>、&lt;code>NFS&lt;/code>、&lt;code>XFS&lt;/code>等文件系统的文件，也可以读取存储在&lt;code>SSD&lt;/code>、&lt;code>HDD&lt;/code>等不同存储介质的文件，无须考虑不同文件系统或者不同存储介质的差异。&lt;/p>
&lt;p>通过 VFS 系统，Linux 提供了通用的系统调用，可以跨越不同文件系统和介质之间执行，极大简化了用户访问不同文件系统的过程。另一方面，新的文件系统、新类型的存储介质，可以无须编译的情况下，动态加载到 Linux 中。&lt;/p>
&lt;p>&amp;ldquo;一切皆文件&amp;quot;是 Linux 的基本哲学之一，不仅是普通的文件，包括目录、字符设备、块设备、套接字等，都可以以文件的方式被对待。实现这一行为的基础，正是 Linux 的虚拟文件系统机制。&lt;/p>
&lt;p>VFS 之所以能够衔接各种各样的文件系统，是因为它抽象了一个通用的文件系统模型，定义了通用文件系统都支持的、概念上的接口。新的文件系统只要支持并实现这些接口，并注册到 Linux 内核中，即可安装和使用。&lt;/p>
&lt;p>再举个例子，比如 Linux 写一个文件：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>int ret &lt;span style="color:#f92672">=&lt;/span> write&lt;span style="color:#f92672">(&lt;/span>fd, buf, len&lt;span style="color:#f92672">)&lt;/span>;
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>调用了 &lt;code>write()&lt;/code> 系统调用，它的过程简要如下：&lt;/p>
&lt;ul>
&lt;li>首先，勾起 VFS 通用系统调用&lt;code>sys_write()&lt;/code>处理。&lt;/li>
&lt;li>接着，&lt;code>sys_write()&lt;/code> 根据&lt;code>fd&lt;/code>找到所在的文件系统提供的写操作函数，比如 &lt;code>op_write()&lt;/code>。&lt;/li>
&lt;li>最后，调用 &lt;code>op_write()&lt;/code> 实际的把数据写入到文件中。&lt;/li>
&lt;/ul>
&lt;p>操作示意图如下：
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/op2fw9/1616167805551-1b23e389-6142-4e11-8ef1-b1b1c1722cbe.jpeg" alt="">&lt;/p>
&lt;h1 id="文件系统类型">文件系统类型&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/File_system#Types_of_file_systems">Wiki，File system-Types_of_file_systems&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>可以通过 &lt;strong>/proc/filesystems&lt;/strong> 文件查看当前内核所支持的文件系统类型&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>~&lt;span style="color:#f92672">]&lt;/span>&lt;span style="color:#75715e"># cat /proc/filesystems&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>nodev sysfs
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>...
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>nodev proc
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>...
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>nodev cgroup2
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>nodev tmpfs
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>nodev devtmpfs
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>nodev configfs
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>...
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> xfs
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>...
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ext4
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>...
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ul>
&lt;li>第一列说明文件系统是否需要挂载在一个块设备上
&lt;ul>
&lt;li>nodev 表明本行的文件系统类型不需要挂接在块设备上。凡是没有 nodev 的类型，通常来说都是磁盘文件系统。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>第二列是内核支持的文件系统类型。&lt;/li>
&lt;/ul>
&lt;p>当系统中安装了某个文件系统的驱动，则该文件内容也会有增加，比如我安装了 nfs-utils 包，则该文件还会增加 nfs 行。&lt;/p>
&lt;h2 id="按照存储位置分类">按照存储位置分类&lt;/h2>
&lt;ul>
&lt;li>&lt;strong>Disk file systems(磁盘文件系统)&lt;/strong>
&lt;ul>
&lt;li>基于磁盘的文件系统，也就是把数据直接存储到计算机本地挂载磁盘中。常见的 &lt;strong>ext4、xfs&lt;/strong> 等，都是这类文件系统&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>Network File Systems(网络文件系统)&lt;/strong>
&lt;ul>
&lt;li>网络文件系统是充当远程文件访问协议的客户端的文件系统，提供对服务器上文件的访问。 使用本地接口的程序可以透明地创建，管理和访问远程网络连接计算机中的分层目录和文件。 网络文件系统的示例包括 NFS，AFS，SMB 协议的客户端，以及 FTP 和 WebDAV 的类似于文件系统的客户端。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>Distributed File System(分布式文件系统)&lt;/strong> # 使用网络协议的分布式文件系统也属于网络文件系统的一种。&lt;/li>
&lt;li>&lt;strong>Special-purpose File Systems(特殊目的文件系统)&lt;/strong> # 特殊的文件系统将操作系统的非文件元素显示为文件，以便可以使用文件系统 API 对其进行操作。 这种文件系统一般都是基于内存的，不需要任何磁盘为其分配存储空间，但会占用内存。
&lt;ul>
&lt;li>&lt;strong>device file system(设备文件系统)&lt;/strong> # 简称 devfs，设备文件系统将 I/O 设备和伪设备表示为文件，称为设备文件。 默认挂载到&lt;code>/dev&lt;/code>目录下。&lt;/li>
&lt;li>&lt;strong>Proc File System(进程文件系统)&lt;/strong> # 简称_ _procfs，将进程以及 Linux 上的其他操作系统结构映射到文件空间。默认挂载到&lt;code>/proc&lt;/code>目录下。&lt;/li>
&lt;li>&lt;strong>configfs&lt;/strong> 和 &lt;strong>sysfs&lt;/strong> 提供了可用于向内核查询信息并在内核中配置实体的文件。&lt;/li>
&lt;li>等等&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h1 id="文件系统的使用">文件系统的使用&lt;/h1>
&lt;blockquote>
&lt;p>和 DOS 等操作系统不同，Linux 操作系统中文件系统并不是由驱动器号或驱动器名称（如 A: 或 C: 等）来标识的。Linux 操作系统将独立的文件系统组合成了一个层次化的树形结构，并且由一个单独的实体代表这一文件系统。&lt;/p>
&lt;/blockquote>
&lt;p>Linux 将新的文件系统通过 &lt;a href="https://desistdaydream.github.io/docs/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2.Kernel(%E5%86%85%E6%A0%B8)/6.File_System_%E7%AE%A1%E7%90%86/Mount(%E6%8C%82%E8%BD%BD).md">&lt;strong>Mount(挂载)&lt;/strong>&lt;/a> 操作将其挂载到某个目录上，从而让不同的文件系统结合成为一个整体。&lt;/p>
&lt;p>这些文件系统，要先挂载到 VFS 目录树中的某个子目录（称为挂载点），然后才能访问其中的文件。拿第一类，也就是基于磁盘的文件系统为例，在安装系统时，要先挂载一个根目录&lt;code>/&lt;/code>，在根目录下再把其他文件系统（比如其他的磁盘分区、/proc 文件系统、/sys 文件系统、NFS 等）挂载进来。&lt;/p>
&lt;h1 id="文件系统-io">文件系统 I/O&lt;/h1>
&lt;p>把文件系统挂载到挂载点后，就可以通过挂载点访问它管理的文件了。 VFS 提供了一组标准的文件访问接口。这些接口以系统调用的方式，提供给应用程序使用。&lt;/p>
&lt;p>就比如 cat 命令，首先调用 &lt;code>openat()&lt;/code> 打开一个文件，然后调用 &lt;code>read()&lt;/code> 读取文件内容，最后调用 &lt;code>write()&lt;/code> 将内容输出到控制台的标准输出中&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>~&lt;span style="color:#f92672">]&lt;/span>&lt;span style="color:#75715e"># strace -e openat,read,write cat /root/test&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>......
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>openat&lt;span style="color:#f92672">(&lt;/span>AT_FDCWD, &lt;span style="color:#e6db74">&amp;#34;/root/test&amp;#34;&lt;/span>, O_RDONLY&lt;span style="color:#f92672">)&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">3&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>read&lt;span style="color:#f92672">(&lt;/span>3, &lt;span style="color:#e6db74">&amp;#34;Test I/O for File System&amp;#34;&lt;/span>, 131072&lt;span style="color:#f92672">)&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">24&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>write&lt;span style="color:#f92672">(&lt;/span>1, &lt;span style="color:#e6db74">&amp;#34;Test I/O for File System&amp;#34;&lt;/span>, 24Test I/O &lt;span style="color:#66d9ef">for&lt;/span> File System&lt;span style="color:#f92672">)&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">24&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>......
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># 代码中的方法如下：open() 与 openat() 这两个调用效果一样。&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>int open&lt;span style="color:#f92672">(&lt;/span>const char *pathname, int flags, mode_t mode&lt;span style="color:#f92672">)&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>ssize_t read&lt;span style="color:#f92672">(&lt;/span>int fd, void *buf, size_t count&lt;span style="color:#f92672">)&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>ssize_t write&lt;span style="color:#f92672">(&lt;/span>int fd, const void *buf, size_t count&lt;span style="color:#f92672">)&lt;/span>;
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>文件读写方式的各种差异，导致 I/O 的分类多种多样。最常见的有，缓冲与非缓冲 I/O、直接与非直接 I/O、阻塞与非阻塞 I/O、同步与异步 I/O 等。&lt;/p>
&lt;h2 id="缓冲与非缓冲-io">缓冲与非缓冲 I/O&lt;/h2>
&lt;p>根据是否利用标准库缓存&lt;/p>
&lt;ul>
&lt;li>缓冲 I/O # 利用标准库缓存来加速文件的访问，而标准库内部再通过系统调用访问文件&lt;/li>
&lt;li>非缓冲 I/O # 直接通过系统调用来访问文件，不再经过标准库缓存。&lt;/li>
&lt;/ul>
&lt;p>注意，这里所说的“缓冲”，是指标准库内部实现的缓存。比方说，你可能见到过，很多程序遇到换行时才真正输出，而换行前的内容，其实就是被标准库暂时缓存了起来。
无论缓冲 I/O 还是非缓冲 I/O，它们最终还是要经过系统调用来访问文件。而根据上一节内容，我们知道，系统调用后，还会通过页缓存，来减少磁盘的 I/O 操作。&lt;/p>
&lt;h2 id="直接与非直接-io">直接与非直接 I/O&lt;/h2>
&lt;p>根据是否利用操作系统的页缓存&lt;/p>
&lt;ol>
&lt;li>直接 I/O，是指跳过操作系统的页缓存，直接跟文件系统交互来访问文件。&lt;/li>
&lt;li>非直接 I/O 正好相反，文件读写时，先要经过系统的页缓存，然后再由内核或额外的系统调用，真正写入磁盘。&lt;/li>
&lt;/ol>
&lt;p>想要实现直接 I/O，需要你在系统调用中，指定 O_DIRECT 标志。如果没有设置过，默认的是非直接 I/O。
不过要注意，直接 I/O、非直接 I/O，本质上还是和文件系统交互。如果是在数据库等场景中，你还会看到，跳过文件系统读写磁盘的情况，也就是我们通常所说的裸 I/O。&lt;/p>
&lt;h2 id="阻塞与非阻塞-io">阻塞与非阻塞 I/O&lt;/h2>
&lt;p>根据应用程序是否阻塞自身运行&lt;/p>
&lt;ol>
&lt;li>所谓阻塞 I/O，是指应用程序执行 I/O 操作后，如果没有获得响应，就会阻塞当前线程，自然就不能执行其他任务。&lt;/li>
&lt;li>所谓非阻塞 I/O，是指应用程序执行 I/O 操作后，不会阻塞当前的线程，可以继续执行其他的任务，随后再通过轮询或者事件通知的形式，获取调用的结果。&lt;/li>
&lt;/ol>
&lt;p>比方说，访问管道或者网络套接字时，设置 O_NONBLOCK 标志，就表示用非阻塞方式访问；而如果不做任何设置，默认的就是阻塞访问。&lt;/p>
&lt;h2 id="同步与异步-io">同步与异步 I/O&lt;/h2>
&lt;p>根据是否等待响应结果&lt;/p>
&lt;ol>
&lt;li>所谓同步 I/O，是指应用程序执行 I/O 操作后，要一直等到整个 I/O 完成后，才能获得 I/O 响应。&lt;/li>
&lt;li>所谓异步 I/O，是指应用程序执行 I/O 操作后，不用等待完成和完成后的响应，而是继续执行就可以。等到这次 I/O 完成后，响应会用事件通知的方式，告诉应用程序。&lt;/li>
&lt;/ol>
&lt;p>举个例子，在操作文件时，如果你设置了 O_SYNC 或者 O_DSYNC 标志，就代表同步 I/O。如果设置了 O_DSYNC，就要等文件数据写入磁盘后，才能返回；而 O_SYNC，则是在 O_DSYNC 基础上，要求文件元数据也要写入磁盘后，才能返回。
再比如，在访问管道或者网络套接字时，设置了 O_ASYNC 选项后，相应的 I/O 就是异步 I/O。这样，内核会再通过 SIGIO 或者 SIGPOLL，来通知进程文件是否可读写。
你可能发现了，这里的好多概念也经常出现在网络编程中。比如非阻塞 I/O，通常会跟 select/poll 配合，用在网络套接字的 I/O 中。
你也应该可以理解，“Linux 一切皆文件”的深刻含义。无论是普通文件和块设备、还是网络套接字和管道等，它们都通过统一的 VFS 接口来访问。&lt;/p>
&lt;h2 id="总结">总结&lt;/h2>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/op2fw9/1616167677139-656d34bf-0195-4576-919f-2eedc4f4ba5a.png" alt="">
在前面我们知道了，I/O 是分为两个过程的：&lt;/p>
&lt;ol>
&lt;li>数据准备的过程&lt;/li>
&lt;li>数据从内核空间拷贝到用户进程缓冲区的过程&lt;/li>
&lt;/ol>
&lt;p>阻塞 I/O 会阻塞在「过程 1 」和「过程 2」，而非阻塞 I/O 和基于非阻塞 I/O 的多路复用只会阻塞在「过程 2」，所以这三个都可以认为是同步 I/O。
异步 I/O 则不同，「过程 1 」和「过程 2 」都不会阻塞。&lt;/p>
&lt;h2 id="用故事去理解这几种-io-模型">用故事去理解这几种 I/O 模型&lt;/h2>
&lt;p>举个你去饭堂吃饭的例子，你好比用户程序，饭堂好比操作系统。&lt;/p>
&lt;p>阻塞 I/O 好比，你去饭堂吃饭，但是饭堂的菜还没做好，然后你就一直在那里等啊等，等了好长一段时间终于等到饭堂阿姨把菜端了出来（数据准备的过程），但是你还得继续等阿姨把菜（内核空间）打到你的饭盒里（用户空间），经历完这两个过程，你才可以离开。&lt;/p>
&lt;p>非阻塞 I/O 好比，你去了饭堂，问阿姨菜做好了没有，阿姨告诉你没，你就离开了，过几十分钟，你又来饭堂问阿姨，阿姨说做好了，于是阿姨帮你把菜打到你的饭盒里，这个过程你是得等待的。&lt;/p>
&lt;p>基于非阻塞的 I/O 多路复用好比，你去饭堂吃饭，发现有一排窗口，饭堂阿姨告诉你这些窗口都还没做好菜，等做好了再通知你，于是等啊等（&lt;code>select&lt;/code> 调用中），过了一会阿姨通知你菜做好了，但是不知道哪个窗口的菜做好了，你自己看吧。于是你只能一个一个窗口去确认，后面发现 5 号窗口菜做好了，于是你让 5 号窗口的阿姨帮你打菜到饭盒里，这个打菜的过程你是要等待的，虽然时间不长。打完菜后，你自然就可以离开了。&lt;/p>
&lt;p>异步 I/O 好比，你让饭堂阿姨将菜做好并把菜打到饭盒里后，把饭盒送到你面前，整个过程你都不需要任何等待。&lt;/p></description></item><item><title>Docs: 6.Package 管理</title><link>https://desistdaydream.github.io/docs/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/6.Package-%E7%AE%A1%E7%90%86/Package-%E7%AE%A1%E7%90%86/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/6.Package-%E7%AE%A1%E7%90%86/Package-%E7%AE%A1%E7%90%86/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;/blockquote>
&lt;p>在 Linux 操作系统中，Package 就是指应用程序的安装包。保存 Package 的地方(网站、ISO 等)称为 &lt;strong>Repository(简称 Repo)&lt;/strong>，我们可以从各种 Linux 发行版的官方 Repo 中下载对应的可用的 Package，以安装到这些发行版的 Linux 系统中。&lt;/p>
&lt;blockquote>
&lt;p>注意：哪怕两个发行版的包管理器相同，也不代表他们的 Package 是可以公用的，比如 CentOS 和 OpenEuler 都用 yum，但是 CentOS 的 Package 是无法装在 OpenEuler 上的，安装时将会报错(比如包与包之间 &lt;strong>conflict(冲突)&lt;/strong>)&lt;/p>
&lt;/blockquote>
&lt;h1 id="linux-各发行版的官方-repo-站点">Linux 各发行版的官方 Repo 站点&lt;/h1>
&lt;ul>
&lt;li>包含很多发行版的 Repo 站点: &lt;a href="https://pkgs.org/">https://pkgs.org/&lt;/a>&lt;/li>
&lt;li>OpenEuler: &lt;a href="https://repo.openeuler.org/">https://repo.openeuler.org/&lt;/a>&lt;/li>
&lt;li>CentOS: &lt;a href="https://centos.pkgs.org/">https://centos.pkgs.org/&lt;/a>&lt;/li>
&lt;li>Ubuntu: &lt;a href="https://packages.ubuntu.com/">https://packages.ubuntu.com/&lt;/a>
&lt;ul>
&lt;li>在这里可以找到 jammy 版本(20.04 TLS)的所有软件包列表: &lt;a href="https://packages.ubuntu.com/jammy/allpackages">https://packages.ubuntu.com/jammy/allpackages&lt;/a>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul></description></item><item><title>Docs: 7.Process 管理</title><link>https://desistdaydream.github.io/docs/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2.Kernel%E5%86%85%E6%A0%B8/7.Process-%E7%AE%A1%E7%90%86/Process-%E7%AE%A1%E7%90%86/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2.Kernel%E5%86%85%E6%A0%B8/7.Process-%E7%AE%A1%E7%90%86/Process-%E7%AE%A1%E7%90%86/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://blog.csdn.net/ljianhui/article/details/46718835">原文连接&lt;/a>，本文为 IBM RedBook 的 &lt;a href="http://users.polytech.unice.fr/~bilavarn/fichier/elec5_linux/linux_perf_and_tuning_IBM.pdf">Linux Performanceand Tuning Guidelines&lt;/a> 的 1.1 节的翻译&lt;/li>
&lt;li>&lt;a href="https://mp.weixin.qq.com/s/fzLcAkYwKhj-9hgoVkTzaw">阿里技术，CPU 飙高，系统性能问题如何排查？&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>进程管理是操作系统的最重要的功能之一。有效率的进程管理能保证一个程序平稳而高效地运行。它包括进程调度、中断处理、信号、进程优先级、上下文切换、进程状态、进度内存等。&lt;/p>
&lt;p>&lt;strong>Process(进程)&lt;/strong> 实际是运行在 CPU 中的一个&lt;strong>Program(应用程序) 的实体&lt;/strong>。在 Linux 系统中，能够同时运行多个进程，Linux 通过在短的时间间隔内轮流运行这些进程而实现“多任务”。这一短的时间间隔称为“时间片”，让进程轮流运行的方法称为“进程调度” ，完成调度的程序称为调度程序。&lt;/p>
&lt;p>进程调度控制进程对 CPU 的访问。当需要选择下一个进程运行时，由调度程序选择最值得运行的进程。可运行进程实际上是仅等待 CPU 资源的进程，如果某个进程在等待其它资源，则该进程是不可运行进程。Linux 使用了比较简单的基于优先级的进程调度算法选择新的进程。&lt;/p>
&lt;p>通过多任务机制，每个进程可认为只有自己独占计算机，从而简化程序的编写。每个进程有自己单独的地址空间，并且只能由这一进程访问，这样，操作系统避免了进程之间的互相干扰以及“坏”程序对系统可能造成的危害。 为了完成某特定任务，有时需要综合两个程序的功能，例如一个程序输出文本，而另一个程序对文本进行排序。为此，操作系统还提供进程间的通讯机制来帮助完成这样的任务。Linux 中常见的进程间通讯机制有信号、管道、共享内存、信号量和套接字等。&lt;/p>
&lt;p>内核通过 SCI 提供了一个 API 来创建一个新进程(fork、exec 或 Portable Operating System Interface [POSⅨ] 函数)、停止进程(kill、exit)、并在它们之间进行通信和同步(signal 或者 POSⅨ 机制)。&lt;/p>
&lt;p>计算机实际上可以做的事情实质上非常简单，比如计算两个数的和，再比如在内存中寻找到某个地址等等。这些最基础的计算机动作被称为指令(instruction)。所谓的程序(program)，就是这样一系列指令的所构成的集合。通过程序，我们可以让计算机完成复杂的操作。程序大多数时候被存储为可执行的文件。这样一个可执行文件就像是一个菜谱，计算机可以按照菜谱作出可口的饭菜。&lt;/p>
&lt;p>Program(程序) 和 Process(进程) 的区别是什么呢?&lt;/p>
&lt;ol>
&lt;li>在很久很久以前，计算机刚出现的时候，是没有操作系统的，那时候一台机器只是运行一个程序，得出数据，后来人们为了同时运行多个程序从而研究出了操作系统，在操作系统之上可以运行多个程序&lt;/li>
&lt;li>进程是程序的一个具体实现。类似于按照食谱，真正去做菜的过程。同一个程序可以执行多次，每次都可以在内存中开辟独立的空间来装载，从而产生多个进程。不同的进程还可以拥有各自独立的 IO 接口。&lt;/li>
&lt;/ol>
&lt;p>操作系统的一个重要功能就是为进程提供方便，比如说为进程分配内存空间，管理进程的相关信息等等，就好像是为我们准备好了一个精美的厨房。&lt;/p>
&lt;h2 id="进程的生命周期">进程的生命周期&lt;/h2>
&lt;p>每一个进程都有其生命周期，例如创建、运行、终止和消除。这些阶段会在系统启动和运行中重复无数次。因此，进程的生命周期对于其性能的分析是非常重要的。下图展示了经典的进程生命周期。
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/ld23ik/1616167507353-2f676d82-88da-483c-a939-399f284d6425.jpeg" alt="">
不会关闭的常驻进程可以称为 &lt;strong>Daemon Process(守护进程，简称 Daemon)&lt;/strong>&lt;/p>
&lt;blockquote>
&lt;p>一般 daemon 的名称都会在进程名后加一个字母 d 作为 daemon 的 process，比如 vsftp 的 daemon 就是 vsftpd。&lt;/p>
&lt;/blockquote>
&lt;p>当一个进程创建一个新的进程，创建进程(父进程)的进程调用 一个 fork() 系统调用。当 fork() 系统调用被调用，它得到该新创建进程（子进程）的进程描述并调用一个新的进程 id。它复制该值到父进程进程描述到子进程中。此时整个的父进程的地址空间是没有被复制的；父子进程共享相同的地址空间。&lt;/p>
&lt;p>exec() 系统调用复制新的程序到子进程的地址空间。因为父子进程共享地址空间，写入一个新的程序的数据会引起一个分页错误。在这种情况下，内存会分配新的物理内存页给子进程。&lt;/p>
&lt;p>这个推迟的操作叫作写时复制。子进程通常运行他们自己的程序而不是与父进程运行相同的程序。这个操作避免了不必要的开销，因为复制整个地址空间是一个非常缓慢和效率低下的操作，它需要使用大量的处理器时间和资源。&lt;/p>
&lt;p>当程序已经执行完成，子进程通过调用 exit()系统调用终止。exit()系统调用释放进程大部分的数据并通过发送一个信号通知其父进程。此时，子进程是一个被叫作僵尸进程的进程（参阅 page 7 的“Zombie processes”）。&lt;/p>
&lt;p>子进程不会被完全移除直到其父进程知道其子进程的调用 wait()系统调用而终止。当父进程被通知子进程终止，它移除子进程的所有数据结构并释放它的进程描述。&lt;/p>
&lt;h2 id="父进程与子进程">父进程与子进程&lt;/h2>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/ld23ik/1616167507409-d531245f-abbe-4a2a-b575-d2ae72c6949f.jpeg" alt="">&lt;/p>
&lt;ul>
&lt;li>用颜色的线标示的两列，左侧的为进程号(PID)右侧的为父进程号(PPID)&lt;/li>
&lt;li>子进程与父进程的环境变量相同&lt;/li>
&lt;li>老进程成为新进程的父进程(parent process)，而相应的，新进程就是老的进程的子进程(child process)。一个进程除了有一个 PID 之外，还会有一个 PPID(parent PID)来存储的父进程 PID。如果我们循着 PPID 不断向上追溯的话，总会发现其源头是 init 进程。所以说，所有的进程也构成一个以 init 为根的树状结构。&lt;/li>
&lt;li>如上图所示，我们查询当前 shell 下的进程：
&lt;ul>
&lt;li>我们可以看到，第二个进程 ps 是第一个进程 bash 的子进程。&lt;/li>
&lt;li>还可以用 &lt;code>pstree&lt;/code> 命令来显示整个进程树。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>fork() 通常作为一个函数被调用。这个函数会有两次返回，将子进程的 PID 返回给父进程，0 返回给子进程。实际上，子进程总可以查询自己的 PPID 来知道自己的父进程是谁，这样，一对父进程和子进程就可以随时查询对方。&lt;/li>
&lt;li>通常在调用 fork 函数之后，程序会设计一个 if 选择结构。当 PID 等于 0 时，说明该进程为子进程，那么让它执行某些指令,比如说使用 exec 库函数(library function)读取另一个程序文件，并在当前的进程空间执行 (这实际上是我们使用 fork 的一大目的: 为某一程序创建进程)；而当 PID 为一个正整数时，说明为父进程，则执行另外一些指令。由此，就可以在子进程建立之后，让它执行与父进程不同的功能。&lt;/li>
&lt;/ul>
&lt;h3 id="子进程的-termination终结">子进程的 termination(终结)&lt;/h3>
&lt;p>当子进程终结时，它会通知父进程，并清空自己所占据的内存，并在内核里留下自己的退出信息(exit code，如果顺利运行，为 0；如果有错误或异常状况，为&amp;gt;0 的整数)。在这个信息里，会解释该进程为什么退出。父进程在得知子进程终结时，有责任对该子进程使用 wait 系统调用。这个 wait 函数能从内核中取出子进程的退出信息，并清空该信息在内核中所占据的空间。但是，如果父进程早于子进程终结，子进程就会成为一个孤儿(orphand)进程。孤儿进程会被过继给 init 进程，init 进程也就成了该进程的父进程。init 进程负责该子进程终结时调用 wait 函数。&lt;/p>
&lt;p>当然，一个糟糕的程序也完全可能造成子进程的退出信息滞留在内核中的状况（父进程不对子进程调用 wait 函数），这样的情况下，子进程成为僵尸(zombie)进程。当大量僵尸进程积累时，内存空间会被挤占。&lt;/p>
&lt;h2 id="thread线程">Thread(线程)&lt;/h2>
&lt;p>一个线程是一个单独的进程生成的一个执行单元。它与其他的线程并行地运行在同一个进程中。各个线程可以共享进程的资源，例如内存、地址空间、打开的文件等等。它们能访问相同的程序数据集。线程也被叫作轻量级的进程（Light Weight Process，LWP）。因为它们共享资源，所以每个线程不应该在同一时间改变它们共享的资源。互斥的实现、锁、序列化等是用户程序的责任。&lt;/p>
&lt;p>从性能的角度来说，创建线程的开销比创建进程少，因数创建一个线程时不需要复制资源。另一方面，进程和线程拥在调度算法上有相似的特性。&lt;strong>内核以相似的方式处理它们&lt;/strong>。
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/ld23ik/1616167507380-b6ae3b1e-b47c-454c-b3c7-9942dde4f480.jpeg" alt="">
所以，一个进程创建的线程，也是可以运行在多个 CPU 上的。
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/ld23ik/1616645843002-c07df4a7-3d7a-4969-8203-4bc20169721a.png" alt="image.png">
在现在的 Linux 实现中，线程支持 UNIX 的可移植操作系统接口（POSIX）标准库。在 Linux 操作系统中有几种可用的线程实现。以下是广泛使用的线程库：&lt;/p>
&lt;p>Linux Threads 自从 Linux 内核 2.0 起就已经被作为默认的线程实现。Linux Threads 的一些实现并不符合 POSIX 标准。Native POSIX Thread Library（NPTL）正在取代 Linux Threads。Linux Threads 在将来的 Linux 企业发行版中将不被支持。&lt;/p>
&lt;p>Native POSIX Thread Libary（NPTL）&lt;/p>
&lt;p>NPTL 最初是由红帽公司开发的。NPTL 与 POSIX 更加兼容。通过 Linux 内核 2.6 的高级特性，例如，新的 clone()系统调用、信号处理的实现等等，它具有比 LinuxThreads 更高的性能和伸缩性。&lt;/p>
&lt;p>NPTL 与 LinuxThreads 有一些不兼容。一个依赖于 LinuxThreads 的应用可能不能在 NPTL 实现中工作。&lt;/p>
&lt;p>Next Generation POSIX Thread（NGPT）&lt;/p>
&lt;p>NGPT 是一个 IBM 开发的 POSIX 线程库。现在处于维护阶段并且在未来也没有开发计划。&lt;/p>
&lt;p>使用 LD_ASSUME_KERNEL 环境变量，你可以选择在应用中使用哪一个线程库。&lt;/p>
&lt;h2 id="linux-内核代码中的-process">Linux 内核代码中的 Process&lt;/h2>
&lt;p>在 Linux 中，&lt;strong>Process(进程) 属于&lt;/strong> &lt;strong>Task(任务)&lt;/strong> 的一种类型，都被 task_struct 结构管理，该结构同时被叫作进程描述。一个进程描述包含一个运行进程所有的必要信息，例如进程标识、进程属性和构建进程的资源。如果你了解该进程构造，你就能理解对于进程的运行和性能来说，什么是重要的。&lt;/p>
&lt;p>v5.14 代码：&lt;a href="https://github.com/torvalds/linux/blob/v5.14/include/linux/sched.h#L661">include/linux/sched.h&lt;/a>&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-c" data-lang="c">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">struct&lt;/span> task_struct {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#ifdef CONFIG_THREAD_INFO_IN_TASK
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#75715e">/*
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> * For reasons of header soup (see current_thread_info()), this
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> * must be the first element of task_struct.
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> */&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">struct&lt;/span> thread_info thread_info;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#endif
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> ......
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 进程状态
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">unsigned&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span> __state;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 进程唯一标识符
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">pid_t&lt;/span> pid;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">pid_t&lt;/span> tgid;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 进程名称，上限 16 字符
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">char&lt;/span> comm[TASK_COMM_LEN];
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 打开的文件
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">struct&lt;/span> files_struct &lt;span style="color:#f92672">*&lt;/span>files;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ......
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>下图展示了进程结构相关的进程信息概述。
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/ld23ik/1616167507336-aaeec645-b9df-41c3-99ab-6bf39aed4f42.jpeg" alt="">
其实从这里能看出来，从某种角度来看，**对于内核来说并没有线程这个概念。Linux 把所有的线程都当做进程来实现，内核也没有特别的调度算法来处理线程。**线程仅仅被视为一个与其他进程共享某些资源的进程，和进程一样，每个线程也都是有自己的 &lt;code>task_struct&lt;/code>，所以在内核中，线程看起来就是一个普通的进程。线程也被称作轻量级进程，一个进程可以有多个线程，线程拥有自己独立的栈，切换也由操作系统调度。在 Linux 上可以通过 &lt;code>pthread_create()&lt;/code> 方法或者 &lt;code>clone()&lt;/code> 系统调用创建；&lt;/p>
&lt;h1 id="进程优先级和-nice-值">进程优先级和 nice 值&lt;/h1>
&lt;p>进程优先级是一个数值，它通过动态的优先级和静态的优先级来决定进程被 CPU 处理的顺序。一个拥有更高进程优先级的进程拥有更大的机率得到处理器的处理。&lt;/p>
&lt;p>内核根据进程的行为和特性使用试探算法，动态地调整调高或调低动态优先级。一个用户进程可以通过使用进程的 nice 值间接改变静态优先级。一个拥有更高静态优先级的进程将会拥有更长的时间片（进程能在处理上运行多长时间）。&lt;/p>
&lt;p>Linux 支持从 19（最低优先级）到-20（最高优先级）的 nice 值。默认值为 0。把程序的 nice 值修改为负数（使进程的优先级更高），需要以 root 身份登陆或使用 su 命令以 root 身份执行。&lt;/p>
&lt;h1 id="上下文切换">上下文切换&lt;/h1>
&lt;p>在进程运行过程中，进程的运行信息被保存于处理器的寄存器和它的缓存中。正在执行的进程加载到寄存器中的数据集被称为上下文。为了切换进程，运行中进程的上下文将会被保存，接下来的运行进程的上下文将被被恢复到寄存器中。进程描述和内核模式堆栈的区域将会用来保存上下文。这个切换被称为上下文切换。过多的上下文切换是不受欢迎的，因为处理器每次都必须清空刷新寄存器和缓存，为新的进程制造空间。它可能会引起性能问题。&lt;/p>
&lt;p>下图说明了上下文切换如何工作。
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/ld23ik/1616167507475-6f5a9385-f033-4c00-8344-2953197b973c.jpeg" alt="">&lt;/p>
&lt;h1 id="中断处理">中断处理&lt;/h1>
&lt;p>中断处理是优先级最高的任务之一。中断通常由 I/O 设备产生，例如网络接口卡、键盘、磁盘控制器、串行适配器等等。中断处理器通过一个事件通知内核（例如，键盘输入、以太网帧到达等等）。它让内核中断进程的执行，并尽可能快地执行中断处理，因为一些设备需要快速的响应。它是系统稳定的关键。当一个中断信号到达内核，内核必须切换当前的进程到一个新的中断处理进程。这意味着中断引起了上下文切换，因此大量的中断将会引起性能的下降。&lt;/p>
&lt;p>在 Linux 的实现中，有两种类型的中断。硬中断是由请求响应的设备发出的（磁盘 I/O 中断、网络适配器中断、键盘中断、鼠标中断）。软中断被用于处理可以延迟的任务（TCP/IP 操作，SCSI 协议操作等等）。你可以在 &lt;code>/proc/interrupts&lt;/code> 文件中查看硬中断的相关信息。&lt;/p>
&lt;p>在多处理器的环境中，中断被每一个处理器处理。绑定中断到单个的物理处理中能提高系统的性能。更多的细节，请参阅 4.4.2，“CPU 的中断处理亲和力”。&lt;/p>
&lt;h1 id="进程的状态">进程的状态&lt;/h1>
&lt;p>每一个进程拥有自己的状态，状态表示了进程当前在发生什么。LINUX 2.6 以后的内核中，在进程的执行期间进程的状态会发生改变，进程一般存在 7 种基础状态：D-不可中断睡眠、R-可执行、S-可中断睡眠、T-暂停态、t-跟踪态、X-死亡态、Z-僵尸态，这几种状态在 ps 命令的 man 手册中有对应解释。&lt;/p>
&lt;ul>
&lt;li>&lt;strong>D&lt;/strong>＃不间断的睡眠（通常是 IO）&lt;/li>
&lt;li>&lt;strong>R&lt;/strong> ＃正在运行或可运行（在运行队列上）&lt;/li>
&lt;li>&lt;strong>S&lt;/strong> ＃可中断的睡眠（等待事件完成）&lt;/li>
&lt;li>&lt;strong>T&lt;/strong> ＃被作业控制信号停止&lt;/li>
&lt;li>&lt;strong>t&lt;/strong>＃在跟踪过程中被调试器停止&lt;/li>
&lt;li>&lt;strong>X&lt;/strong> ＃已死（永远都不会出现）&lt;/li>
&lt;li>&lt;strong>Z&lt;/strong> ＃已终止运行（“僵尸”）的进程，已终止但未由其父进程获得&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/ld23ik/1616167507456-ca89ed8d-d8a1-4cd6-96ab-c78372840f4a.jpeg" alt="">&lt;/p>
&lt;h2 id="d-task_uninterruptible不可中断睡眠态">D (TASK_UNINTERRUPTIBLE)，不可中断睡眠态&lt;/h2>
&lt;p>顾名思义，位于这种状态的进程处于睡眠中，并且不允许被其他进程或中断(异步信号)打断。因此这种状态的进程，是无法使用 kill -9 杀死的(kill 也是一种信号)，除非重启系统(没错，就是这么头硬)。不过这种状态一般由 I/O 等待(比如磁盘 I/O、网络 I/O、外设 I/O 等)引起，出现时间非常短暂，大多很难被 PS 或者 TOP 命令捕获(除非 I/O HANG 死)。SLEEP 态进程不会占用任何 CPU 资源。&lt;/p>
&lt;h2 id="r-task_running可执行态">R (TASK_RUNNING)，可执行态&lt;/h2>
&lt;p>这种状态的进程都位于 CPU 的可执行队列中，正在运行或者正在等待运行，即不是在上班就是在上班的路上。&lt;/p>
&lt;p>在此状态下，表示进程正在 CPU 中运行或在队列中等待运行（运行队列）。&lt;/p>
&lt;h2 id="s-task_interruptible可中断睡眠态">S (TASK_INTERRUPTIBLE)，可中断睡眠态&lt;/h2>
&lt;p>不同于 D，这种状态的进程虽然也处于睡眠中，但是是允许被中断的。这种进程一般在等待某事件的发生（比如 socket 连接、信号量等），而被挂起。一旦这些时间完成，进程将被唤醒转为 R 态。如果不在高负载时期，系统中大部分进程都处于 S 态。SLEEP 态进程不会占用任何 CPU 资源。&lt;/p>
&lt;p>在此状态下，进程被暂停并等待一个某些条件状态的到达。如果一个进程处于 TASK_INTERRUPTIBLE 状态并接收到一个停止的信号，进程的状态将会被改变并中断操作。一个典型的 TASK_INTERRUPTIBLE 状态的进程的例子是一个进程等待键盘中断。&lt;/p>
&lt;h2 id="t--t-task_stopped--task_traced暂停-or-跟踪态">T &amp;amp; t (TASK_STOPPED &amp;amp; TASK_TRACED)，暂停 or 跟踪态&lt;/h2>
&lt;p>这种两种状态的进程都处于运行停止的状态。不同之处是暂停态一般由于收到 SIGSTOP、SIGTSTP、SIGTTIN、SIGTTOUT 四种信号被停止，而跟踪态是由于进程被另一个进程跟踪引起(比如 gdb 断点）。暂停态进程会释放所有占用资源。&lt;/p>
&lt;p>TASK_STOPPED 在此状态下的进程被某些信号（如 SIGINT，SIGSTOP）暂停。进程正在等待通过一个信号恢复运行，例如 SIGCONT。&lt;/p>
&lt;h2 id="z-exit_zombietask_zombie-僵尸态">Z (EXIT_ZOMBIE/TASK_ZOMBIE), 僵尸态&lt;/h2>
&lt;p>这种状态的进程实际上已经结束了，但是父进程还没有回收它的资源（比如进程的描述符、PID 等）。僵尸态进程会释放除进程入口之外的所有资源。&lt;/p>
&lt;p>当一个进程调用 exit()系统调用退出后，它的父进程应该知道该进程的终止。处于 TASK_ZOMBIE 状态的进程会等待其父进程通知其释放所有的数据结构。&lt;/p>
&lt;p>当一个进程接收到一个信号而终止，它在结束自己之前，通常需要一些时间来结束所有的任务（例如关闭打开的文件）。在这个通常非常短暂的时间内，该进程就是一个僵尸进程。&lt;/p>
&lt;p>进程已经完成所有的关闭任务后，它会向父进程报告其即将终止。有些时候，一个僵尸进程不能把自己终止，这将会引导它的状态显示为 z（zombie）。&lt;/p>
&lt;p>使用 kill 命令来关闭这样的一个进程是不可能的，因为该进程已经被认为已经死掉了。如果你不能清除僵尸进程，你可以结束其父进程，然后僵尸进程也随之消失。但是，如果父进程为 init 进程，你不能结束它。init 进程是一个非常重要的进程，因此可能需要重启系统来清除僵尸进程。&lt;/p>
&lt;h2 id="x-exit_dead-死亡态">X (EXIT_DEAD), 死亡态&lt;/h2>
&lt;p>进程的真正结束态，这种状态一般在正常系统中捕获不到。&lt;/p>
&lt;h1 id="进程内存段">进程内存段&lt;/h1>
&lt;p>进程使用其自身的内存区域来执行工作。工作的变化根据情况和进程的使用而决定。进程可以拥有不同的工作量特性和不同的数据大小需求。进程必须处理各种数据大小。为了满足需求，Linux 内核为每个进程使用动态申请内存的机制。进程内存分配的数据结构如图 1-7 所示。&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/ld23ik/1616167507458-2bbc9553-910c-4d66-9ad1-8f45893277da.jpeg" alt="">&lt;/p>
&lt;p>图 1-7 进程地址空间&lt;/p>
&lt;p>进程内存区由以下几部分组成：&lt;/p>
&lt;p>Text 段&lt;/p>
&lt;p>该区域用于存储运行代码。&lt;/p>
&lt;p>Data 段&lt;/p>
&lt;p>数据段包括三个区域。&lt;/p>
&lt;p>– Data：该区域存储已被初始化的数据，如静态变量。&lt;/p>
&lt;p>– BSS：该区域存储初始化为 0 的数据。数据被初始化为 0。&lt;/p>
&lt;p>– Heap：该区域用于根据需求使用 malloc()动态申请的内存。堆向高地址方向增长。&lt;/p>
&lt;p>Stack 段&lt;/p>
&lt;p>该区域用于存储局部变量、函数参数和返回函数的地址。栈向低地址方向增长。&lt;/p>
&lt;p>用户进程的地址空间内存分布可以使用 pmap 命令来查看。你可以使用 ps 命令来查看内存段的大小。可以参阅 2.3.10 的“pmap”，“ps 和 pstree”。&lt;/p>
&lt;h1 id="进程的-exit-code退出码">进程的 exit code(退出码)&lt;/h1>
&lt;p>在 Linux 系统中，程序可以在执行终止后传递值给其父进程，这个值被称为 &lt;strong>exit code(退出码)&lt;/strong> 或 **exit status(退出状态)**或 &lt;strong>reture status(返回码)&lt;/strong>。在 POSIX 系统中，惯例做法是当程序成功执行时 &lt;strong>exit code 为 0&lt;/strong>，当程序执行失败时 &lt;strong>exit code 非 0&lt;/strong>。&lt;/p>
&lt;p>传递状态码为何重要？如果你在命令行脚本上下文中查看状态码，答案显而易见。任何有用的脚本，它将不可避免地要么被其他脚本所使用，要么被 bash 单行脚本包裹所使用。特别是脚本被用来与自动化工具 SaltStack 或者监测工具 Nagios 配合使用。这些工具会执行脚本并检查它的状态，来确定脚本是否执行成功。&lt;/p>
&lt;p>其中最重要的原因是，即使你不定义状态码，它仍然存在于你的脚本中。如果你不定义恰当的退出码，执行失败的脚本可能会返回成功的状态，这样会导致问题，问题大小取决于你的脚本做了什么。&lt;/p>
&lt;p>Linux 提供了一个专门的变量$?来保存上个已执行命令的退出状态码。&lt;/p>
&lt;p>对于需要进行检查的命令，必须在其运行完毕后立刻查看或使用$?变量，它的值会变成由 shell 所执行的最后一条命令的退出状态码。&lt;/p>
&lt;p>一个成功结束的命令的退出状态码是 0，如果一个命令结束时有错误，退出状态码就是一个正数值（1-255）。&lt;/p>
&lt;p>Linux 上执行 exit 可使 shell 以指定的状态值退出。若不设置状态值参数，则 shell 以预设值退出。状态值 0 代表执行成功，其他值代表执行失败。exit 也可用在 script，离开正在执行的 script，回到 shell。&lt;/p>
&lt;p>Linux 错误退出状态码没有什么标准可循，但有一些可用的参考。&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/ld23ik/1616167507500-9f1aab01-171b-4ece-a6fa-9f576852a403.webp" alt="">&lt;/p>
&lt;p>关于具体的服务，相应的退出码，由开发者代码决定。&lt;/p>
&lt;p>&lt;strong>Linux 进程退出码&lt;/strong>&lt;/p>
&lt;p>&lt;a href="https://jin-yang.github.io/post/linux-process-exit-code-introduce.html">https://jin-yang.github.io/post/linux-process-exit-code-introduce.html&lt;/a>&lt;/p>
&lt;p>&lt;strong>Linux 退出状态码及 exit 命令&lt;/strong>&lt;/p>
&lt;p>&lt;a href="https://www.cnblogs.com/01-single/p/7206664.html">https://www.cnblogs.com/01-single/p/7206664.html&lt;/a>&lt;/p>
&lt;p>&lt;strong>理解 Exit Code 并学会如何在 Bash 脚本中使用&lt;/strong>&lt;/p>
&lt;p>&lt;a href="http://blog.jayxhj.com/2016/02/understanding-exit-codes-and-how-to-use-them-in-bash-scripts">http://blog.jayxhj.com/2016/02/understanding-exit-codes-and-how-to-use-them-in-bash-scripts&lt;/a>&lt;/p>
&lt;p>&lt;strong>Appendix E. Exit Codes With Special Meanings&lt;/strong>&lt;/p>
&lt;p>&lt;a href="http://www.tldp.org/LDP/abs/html/exitcodes.html">http://www.tldp.org/LDP/abs/html/exitcodes.html&lt;/a>&lt;/p>
&lt;p>&lt;strong>What is the authoritative list of Docker Run exit codes?&lt;/strong>&lt;/p>
&lt;p>&lt;a href="https://stackoverflow.com/questions/31297616/what-is-the-authoritative-list-of-docker-run-exit-codes">https://stackoverflow.com/questions/31297616/what-is-the-authoritative-list-of-docker-run-exit-codes&lt;/a>&lt;/p>
&lt;p>&lt;strong>Identifying Exit Codes and their meanings&lt;/strong>&lt;/p>
&lt;p>&lt;a href="https://support.circleci.com/hc/en-us/articles/360002341673-Identifying-Exit-Codes-and-their-meanings">https://support.circleci.com/hc/en-us/articles/360002341673-Identifying-Exit-Codes-and-their-meanings&lt;/a>&lt;/p>
&lt;p>&lt;strong>OpenShift Exit Status Codes&lt;/strong>&lt;/p>
&lt;p>&lt;a href="https://access.redhat.com/documentation/en-US/OpenShift_Online/2.0/html/Cartridge_Specification_Guide/Exit_Status_Codes.html">https://access.redhat.com/documentation/en-US/OpenShift_Online/2.0/html/Cartridge_Specification_Guide/Exit_Status_Codes.html&lt;/a>&lt;/p></description></item><item><title>Docs: 7.时间管理</title><link>https://desistdaydream.github.io/docs/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/7.%E6%97%B6%E9%97%B4%E7%AE%A1%E7%90%86/7.%E6%97%B6%E9%97%B4%E7%AE%A1%E7%90%86/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/7.%E6%97%B6%E9%97%B4%E7%AE%A1%E7%90%86/7.%E6%97%B6%E9%97%B4%E7%AE%A1%E7%90%86/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://www.nim.ac.cn/520/node/4.html">中国计量科学研究院,SI 基本单位&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>1983 年，国际计量打会讨论决定，把 1 米的定义修改为光在 1/299792458 秒内走过的距离
1967 年，国际计量大会定义：1 秒是铯 133 原子基态的两个超精细能量间跃迁对应辐射的 9192631770 个周期的持续时间。&lt;/p>
&lt;h1 id="实现-ntp-协议的工具">实现 NTP 协议的工具&lt;/h1>
&lt;p>ntpd # 在 centos8 中已不再支持，推荐使用新工具 chrony 来实现 ntp 协议
chrony #&lt;/p>
&lt;h1 id="其他管理系统时间工具">其他管理系统时间工具&lt;/h1>
&lt;h2 id="date--打印或设置系统日期和时间">date # 打印或设置系统日期和时间&lt;/h2>
&lt;h3 id="syntax语法">Syntax(语法)&lt;/h3>
&lt;p>&lt;strong>date [OPTIONS]&amp;hellip; [+FORMAT]&lt;/strong>
可以通过 FORMAT 设置显示时间的格式&lt;/p>
&lt;p>OPTIONS&lt;/p>
&lt;ul>
&lt;li>-&lt;strong>s&lt;/strong> # 从给定的字符串中设定时间。i.e.设置时间&lt;/li>
&lt;li>&lt;strong>-d&lt;/strong> # 从给定的字符串中显示时间，而不是显示现在的时间。常用于判断给定的数字是否符合时间日期的格式 e.g.date -d 9999 +%H%M 不合法，date -d 1011 +%H%M 合法&lt;/li>
&lt;/ul>
&lt;p>FORMAT:&lt;/p>
&lt;ul>
&lt;li>&lt;code>%F&lt;/code> 年月日(年-月-日)&lt;/li>
&lt;li>&lt;code>%Y&lt;/code> 年&lt;/li>
&lt;li>&lt;code>%m&lt;/code> 月&lt;/li>
&lt;li>&lt;code>%d&lt;/code> 日&lt;/li>
&lt;li>&lt;code>%H&lt;/code> 小时&lt;/li>
&lt;li>&lt;code>%M&lt;/code> 分钟&lt;/li>
&lt;li>&lt;code>%S&lt;/code> 秒&lt;/li>
&lt;li>%s # 从 1970-01-01 00:00:00 UTC 时间开始经过的秒。&lt;/li>
&lt;/ul>
&lt;p>EXAMPLE&lt;/p>
&lt;ul>
&lt;li>&lt;strong>date -s 2008/05/06&lt;/strong> #&lt;/li>
&lt;li>&lt;strong>date -s 18:40:00&lt;/strong>&lt;/li>
&lt;li>**date +%H:%M **# 显示当前小时与分钟&lt;/li>
&lt;li>&lt;strong>date -d 1011 +%H%M&lt;/strong> # 显示给定的小时与分钟&lt;/li>
&lt;li>&lt;strong>date +%x &amp;ndash;&amp;gt; 10/21/2009&lt;/strong> #&lt;/li>
&lt;li>&lt;strong>date +%m/%d/%Y&lt;/strong> # 10/21/2009&lt;/li>
&lt;li>2009-10-21 15:18:17
&lt;ul>
&lt;li>**date &amp;ldquo;+%Y-%m-%d %H:%M:%S&amp;rdquo; **#&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>2021-12-20_15:41
&lt;ul>
&lt;li>&lt;strong>date +%F_%H:%M&lt;/strong>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h2 id="timedatectl-options-command--控制系统时间和日期">timedatectl [OPTIONS] [COMMAND] # 控制系统时间和日期&lt;/h2>
&lt;p>若不加任何子命令和选项，则显示日期与时间相关信息
&lt;strong>COMMAND：&lt;/strong>
&lt;strong>status # 显示当前时间设定。(默认 COMMAND)&lt;/strong>&lt;/p>
&lt;p>&lt;strong>set-time TIME # 设置系统时间。&lt;/strong>&lt;/p>
&lt;p>这也将相应地更新 RTC 时间。时间可以以 “2012-10-30 18:17:16” 格式指定。&lt;/p>
&lt;ul>
&lt;li>EXAMPLE
&lt;ul>
&lt;li>&lt;strong>timedatectl set-time &amp;ldquo;2020-11-5 18:17:16&amp;rdquo;&lt;/strong> # 将系统时间设置为 2020 年 11 月 5 日 18 点 17 分 16 秒&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>set-timezone ZONE # 设置系统的时区&lt;/strong>&lt;/p>
&lt;p>&lt;strong>list-timezones Show known time zones&lt;/strong>&lt;/p>
&lt;p>&lt;strong>set-local-rtc &amp;lt;true|false&amp;gt; # Control whether RTC is in local tim&lt;/strong>e&lt;/p>
&lt;p>&lt;strong>set-ntp &amp;lt;true|false&amp;gt; # 控制是否启用 NTP。&lt;/strong>&lt;/p>
&lt;h2 id="hwclock--rw--查看硬件时间bios-的">hwclock [-rw] # 查看硬件时间(BIOS 的)&lt;/h2>
&lt;p>OPTIONS&lt;/p>
&lt;ul>
&lt;li>&lt;strong>-r&lt;/strong> # 查看现有 BIOS 时间，默认为－r 参数&lt;/li>
&lt;li>&lt;strong>-w&lt;/strong> # 将现在的 linux 系统时间写入 BIOS 中&lt;/li>
&lt;/ul>
&lt;p>当我们进行完 Linux 时间的校时后，还需要以 hwclock -w 来更新 BIOS 的时间，因为每次开机的时候，系统会重新由 BIOS 将时间读出来，所以， BIOS 才是重要的时间依据。&lt;/p>
&lt;h1 id="linux-校时">Linux 校时&lt;/h1>
&lt;p>调整 linux 系统时间和时区与 Internet 时间同步&lt;/p>
&lt;p>一、修改时区：&lt;/p>
&lt;p>rm -f /etc/localtime&lt;/p>
&lt;p>ln -s /usr/share/zoneinfo/Asia/Shanghai /etc/localtime&lt;/p>
&lt;p>修改为中国的东八区&lt;/p>
&lt;h1 id="vi-etcsysconfigclock">vi /etc/sysconfig/clock&lt;/h1>
&lt;p>ZONE=&amp;ldquo;Asia/Shanghai&amp;rdquo;&lt;/p>
&lt;p>UTC=false&lt;/p>
&lt;p>ARC=false&lt;/p>
&lt;p>同步 BIOS 时钟，强制把系统时间写入 CMOS：&lt;/p>
&lt;h1 id="clock--w">clock -w&lt;/h1>
&lt;p>三、实现 Internet 时间同步（这里可以忽略上面两步）&lt;/p>
&lt;p>方法 1. 开机的时候自动网络校时：&lt;/p>
&lt;p>vi /etc/rc.d/rc.local&lt;/p>
&lt;p>/usr/sbin/ntpdate -u 192.168.0.2 192.168.0.3 192.168.0.4; /sbin/hwclock -w&lt;/p>
&lt;p>方法 2. 设定计划任务&lt;/p>
&lt;p>crontab 格式如下：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># For details see man 4 crontabs&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># Example of job definition:&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># .---------------- minute (0 - 59)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># | .------------- hour (0 - 23)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># | | .---------- day of month (1 - 31)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># | | | .------- month (1 - 12) OR jan,feb,mar,apr ...&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># | | | | .---- day of week (0 - 6) (Sunday=0 or 7) OR sun,mon,tue,wed,thu,fri,sat&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># | | | | |&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># \* \* \* \* \* command to be executed&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>设定 crontab 计划任务也有两种方式：&lt;/p>
&lt;p>1、写在/etc/crontab 里&lt;/p>
&lt;p>代码:&lt;/p>
&lt;p>00 11 * * * root ntpdate 210.72.145.44&lt;/p>
&lt;p>每天 11 点与中国国家授时中心同步时间&lt;/p>
&lt;p>每天 11 点与中国国家授时中心同步时间&lt;/p>
&lt;p>当然前提是&lt;/p>
&lt;p>apt-get install ntpdate&lt;/p>
&lt;p>代码也可是&lt;/p>
&lt;p>00 11 * * * root ntpdate us.pool.ntp.org&lt;/p>
&lt;p>2、使用命令 crontab -e&lt;/p>
&lt;p>crontab -e&lt;/p>
&lt;p>10 5 * * * root ntpdate us.pool.ntp.org;hwclock -w&lt;/p>
&lt;p>这样每天 5:10 自动进行网络校时，并同时更新 BIOS 的时间&lt;/p>
&lt;p>################################&lt;/p>
&lt;p>同步网络时间：输入 ntpdate time.nist.gov 同步网络时间&lt;/p>
&lt;p>[root@localhost ~]# ntpdate time.nist.gov&lt;/p>
&lt;p>12 Oct 17:25:01 ntpdate[2784]: step time server 132.163.4.103 offset 1147751.472254 sec&lt;/p>
&lt;p>## 出现以上信息说明同步成功 ##&lt;/p>
&lt;p>注：如提示命令不存在，直接输入：yum install ntp -y 安装 ntp 软件包&lt;/p></description></item><item><title>Docs: Account Manager(账户管理)</title><link>https://desistdaydream.github.io/docs/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/5.%E7%99%BB%E5%BD%95-Linux-%E4%B8%8E-%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6/Account-Manager%E8%B4%A6%E6%88%B7%E7%AE%A1%E7%90%86/Account-Manager%E8%B4%A6%E6%88%B7%E7%AE%A1%E7%90%86/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/5.%E7%99%BB%E5%BD%95-Linux-%E4%B8%8E-%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6/Account-Manager%E8%B4%A6%E6%88%B7%E7%AE%A1%E7%90%86/Account-Manager%E8%B4%A6%E6%88%B7%E7%AE%A1%E7%90%86/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/7/html/system_administrators_guide/ch-getting_started#sec-Managing_User_Accounts">红帽官方文档,RedHat7-管理用户账户的基础知识&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/7/html/system_administrators_guide/ch-managing_users_and_groups">红帽官方文档,RedHat7-系统管理员指南-第四章-管理用户和组&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/7/html/security_guide/index">红帽官方文档,RedHat7-安全指南&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>Linux 操作系统是一个多用户操作系统，所以除了 &lt;strong>Terminal(终端)&lt;/strong> 以外，还需 &lt;strong>Account(账户)&lt;/strong> 才可以登录上去，Linux 操作系统允许多个用户访问安装在一台机器上的单个系统。每个 User(用户) 都在自己的 Account(账户) 下操作。因此，Account Manager 代表了 Linux 系统管理的核心要素。&lt;/p>
&lt;blockquote>
&lt;p>User 与 Account 傻傻分不清楚，在 Linux 操作系统中，通常都会将 Account 称为 User，但是，这个称呼实际上并不准确。因为一个 User，比如 root，可以被多个现实世界中多个人使用，那么 root 这个 User 就会对应多个真实的 User~这种描述是非常矛盾的~~~~
只不过，随着时间的推移，人们慢慢叫习惯了，各种文档和源码也都一直使用 UID 这种名称，也就不再特别区分 Account 和 User 了。只需要知道，UID 更准确的描述应该是 AID。&lt;/p>
&lt;/blockquote>
&lt;p>同时，一个 Linux Account 也可以不代表一个真实的 User，这样的 Account 只被应用程序使用，一个应用程序使用某个 Account 运行，以便让系统更方便得对程序进行精细化控制。这种控制方式称为 &lt;strong>Access Control(访问控制)&lt;/strong>，所以，从这种角度看，Account 也可以称为 &lt;strong>Role(角色)&lt;/strong>，详见 [访问控制](/docs/1.操作系统/5.登录%20Linux%20 与%20 访问控制/Access%20Control(访问控制).md Control(访问控制).md) 章节。&lt;/p>
&lt;p>为了方便得对多个 Account 管理，可以将多个 Account 组合起来，称为 &lt;strong>Group(组)&lt;/strong>，一个 Group 就是一个或多个 Account 的集合。&lt;/p>
&lt;p>通常，Linux 将账户分为两类&lt;/p>
&lt;ul>
&lt;li>Normal Accounts(普通账户)&lt;/li>
&lt;li>System Accounts(系统账户)&lt;/li>
&lt;/ul>
&lt;p>每个账户都有一个对应的 UID 作为其唯一标识符(纯数字)。同样，每个组也有一个对应的 GID 作为其唯一标识符(纯数字)。通常来说：&lt;/p>
&lt;ul>
&lt;li>1000 以下是系统账户与保留账户 和 系统组与保留组&lt;/li>
&lt;li>1000 以上是普通账户和组&lt;/li>
&lt;/ul>
&lt;p>每当我们使用 useradd 命令新建一个普通用户时，用户的 UID 都是 1000 之后的数字，这种行为可以通过修改 /etc/login.defs 文件中的 UID_MIN、GID_MIN 等参数来改变。&lt;/p>
&lt;h2 id="password密码">Password(密码)&lt;/h2>
&lt;p>&lt;strong>Password(密码)&lt;/strong> 是用来验证用户身份的最主要方法。当用户使用一个账户登录 Linux 操作系统时，密码是用来证明账户属于该用户的一种非常高效的方式。&lt;/p>
&lt;p>Linux 系统使用 **Secure Hash Algorithm 512(SHA512)**和 &lt;strong>shadow passwords&lt;/strong>。默认情况下，账户信息保存在 /etc/passwd 文件中，对应的密码信息经过哈希后保存在 /etc/shadow 文件中。&lt;/p>
&lt;h1 id="关联文件">关联文件&lt;/h1>
&lt;p>&lt;strong>/etc/group&lt;/strong> # 账户组信息
&lt;strong>/etc/passwd&lt;/strong> # 账户信息
&lt;strong>/etc/shadow&lt;/strong> # 安全账户信息
&lt;strong>/etc/login.defs&lt;/strong> # login 工具包中的配置文件，部分账户管理工具会读取该文件中的参数
&lt;strong>/etc/pam.d/&lt;/strong> #&lt;/p>
&lt;ul>
&lt;li>./chfn&lt;/li>
&lt;li>./chpasswd&lt;/li>
&lt;li>./chsh&lt;/li>
&lt;li>./newusers&lt;/li>
&lt;li>./passwd&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>/etc/skel/&lt;/strong> # 该目录为账户目录模板。该目录下包含多个隐藏的文件，当创建用户时，会拷贝该目录下的所有文件到所创建用户的家目录中
&lt;strong>/home/AccountName/&lt;/strong> # UserName 为该账户同名的家目录
&lt;strong>/var/spool/mail/AccountName&lt;/strong># 该文件为该账户的邮件池
注意：&lt;/p>
&lt;ul>
&lt;li>若 /etc/shadow 被 selinux 所管理，有的时候密码修改将会失败，报错 &lt;code>passwd: Authentication token manipulation error&lt;/code>&lt;/li>
&lt;/ul>
&lt;h1 id="账户管理工具">账户管理工具&lt;/h1>
&lt;p>Linux 系统的账户管理功能，通常由 &lt;strong>shadow-utils 包&lt;/strong> 或 &lt;strong>passwd 包&lt;/strong> 中的各种工具和库提供。&lt;/p>
&lt;blockquote>
&lt;p>在有的发行版中(比如 CentOS)，只会将 passwd 包中的 passwd 程序保留，而将其余的程序，放在名为 &lt;strong>shadow-utils&lt;/strong> 的包中。&lt;/p>
&lt;/blockquote>
&lt;p>不同的 Linux 发型，还会用到某些个别的包与主包配合提供完整的账户管理功能：&lt;/p>
&lt;ul>
&lt;li>&lt;strong>base-passwd&lt;/strong> # 这是 Ubuntu 发型版中独有的包。这个包中包含一个 &lt;code>update-passwd&lt;/code> 的程序，将会根据 /var/lib/dpkg/info/base-passwd.preinst 脚本生成 /etc/passwd 和 /etc/group 文件
&lt;ul>
&lt;li>参考：&lt;a href="https://unix.stackexchange.com/questions/470126/how-is-the-etc-passwd-file-instantiated">https://unix.stackexchange.com/questions/470126/how-is-the-etc-passwd-file-instantiated&lt;/a>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>setup&lt;/strong> # 这是 CentOS 发行版中独有的包。包含了一组重要的系统配置文件和安装文件，例如 /etc/passwd、/etc/group、/etc/shadow、/etc/profile 等等&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/oib9pm/1635476577308-bd0e79ab-ffc9-41f8-ba65-471f0a3e2918.png" alt="image.png">&lt;/p>
&lt;h2 id="useradd--添加用户">useradd # 添加用户&lt;/h2>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://man7.org/linux/man-pages/man8/useradd.8.html">Manual(手册),useradd(8)&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>useradd 程序在添加用户时，会读取 /etc/login.defs 文件中的 PASS_MAX_DAYS、PASS_MIN_DAYS、PASS_WARN_AGE 等参数，并将参数的值写入到 /etc/shadow 文件中的对应字段&lt;/p>
&lt;h3 id="syntax语法">Syntax(语法)&lt;/h3>
&lt;p>&lt;strong>useradd [OPTIONS] NAME&lt;/strong>&lt;/p>
&lt;p>OPTIONS：&lt;/p>
&lt;ul>
&lt;li>&lt;strong>-m&lt;/strong> # 自动建立用户的登入目录。&lt;/li>
&lt;li>&lt;strong>-u&lt;/strong> # 指定用户 ID 号。该值在系统中必须是唯一的。0~499 默认是保留给系统用户账号使用的，所以该值必须大于 499。&lt;/li>
&lt;li>&lt;strong>-g GID&lt;/strong> # 指定该用户的基本组 ID&lt;/li>
&lt;li>&lt;strong>-c&lt;/strong> # 加上备注文字，备注文字保存在 passwd 的备注栏中。&lt;/li>
&lt;li>-&lt;strong>d&lt;/strong> # 指定该用户的家目录，默认为 /home 目录下的与用户名同名的文件夹&lt;/li>
&lt;li>&lt;strong>-e&lt;/strong> # 指定账号的失效日期，日期格式为 MM/DD/YY，例如 06/30/12。缺省表示永久有效。&lt;/li>
&lt;li>-f # 指定在密码过期后多少天即关闭该账号。如果为 0 账号立即被停用；如果为-1 则账号一直可用。默认值为-1.&lt;/li>
&lt;li>&lt;strong>-G, &amp;ndash;groups &amp;lt;GROUPS&amp;gt;&lt;/strong> # 指定用户所属的附加群组。&lt;/li>
&lt;li>-l # 不要把用户添加到 lastlog 和 failog 中, 这个用户的登录记录不需要记载&lt;/li>
&lt;li>-M # 不要自动建立用户的登入目录。&lt;/li>
&lt;li>-n # 取消建立以用户名称为名的群组。&lt;/li>
&lt;li>-p # PASSWORD 指定新用户的密码&lt;/li>
&lt;li>-r # 建立一个系统帐号&lt;/li>
&lt;li>-s # 指定用户登入后所使用的 shell。默认值为/bin/bash。&lt;/li>
&lt;/ul>
&lt;p>EXAMPLE：&lt;/p>
&lt;ul>
&lt;li>创建一个名为 lichenhao 的用户，并设置该用户密码为 lch@password
&lt;ul>
&lt;li>useradd -m lichenhao &amp;amp;&amp;amp; echo &amp;rsquo;lch@password&amp;rsquo; | passwd lichenhao &amp;ndash;stdin&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>新增一个用户 user，并指定用户组 ftp
&lt;ul>
&lt;li>useradd -g ftp user&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>新增一个用户：user 并指定家目录为/mnt/bak/。如果没有此目录，则报错，就需要手动创建目录
&lt;ul>
&lt;li>useradd -d /mnt/back/ user&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>新增一个用户：user 并设置密码为 123456
&lt;ul>
&lt;li>useradd -p 123456 user&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>新增一个 FTP 用户：ftp2018 （无需登录系统）
&lt;ul>
&lt;li>useradd -g ftp -s /sbin/nologin ftp2018&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h2 id="userdel--删除用户">userdel # 删除用户&lt;/h2>
&lt;h3 id="syntax语法-1">Syntax(语法)&lt;/h3>
&lt;p>&lt;strong>userdel [OPTIONS] NAME&lt;/strong>&lt;/p>
&lt;p>OPTIONS：&lt;/p>
&lt;ul>
&lt;li>&lt;strong>-f, &amp;ndash;force&lt;/strong> # 强制删除&lt;/li>
&lt;li>&lt;strong>-r, &amp;ndash;remove&lt;/strong> # 删除用户的时候同时移除该用户的家目录和邮件池。不加参数的话，只会删除用户，但是不会删除在/home 目录中的用户家目录。如果你想要连此用户的家目录也一并删除，可以加上 –remove-home 这个参数&lt;/li>
&lt;li>-&lt;strong>R, &amp;ndash;root CHROOT_DIR&lt;/strong> # chroot 到的目录&lt;/li>
&lt;li>&lt;strong>-Z, &amp;ndash;selinux-user&lt;/strong> # 为用户删除所有的 SELinux 用户映射&lt;/li>
&lt;/ul>
&lt;p>EXAMPLE&lt;/p>
&lt;ul>
&lt;li>userdel -r user # 删除名为 user 的用户，同时删除该用户的家目录和邮件池文件&lt;/li>
&lt;/ul>
&lt;h2 id="usermod--修改用户">usermod # 修改用户&lt;/h2>
&lt;h3 id="syntax语法-2">Syntax(语法)&lt;/h3>
&lt;p>&lt;strong>usermod [OPTIONS] NAME&lt;/strong>&lt;/p>
&lt;p>OPTIONS：&lt;/p>
&lt;ul>
&lt;li>&lt;strong>-a, &amp;ndash;append GROUP&lt;/strong> # 将用户追加至上边 -G 中指定附加组中，并不从其它组中删除此用户&lt;/li>
&lt;li>&lt;strong>-c, &amp;ndash;comment &amp;lt;STRING&amp;gt;&lt;/strong> # GECOS 字段的新值&lt;/li>
&lt;li>&lt;strong>-d, &amp;ndash;home &amp;lt;HOME_DIR&amp;gt;&lt;/strong> # 用户的新主目录&lt;/li>
&lt;li>&lt;strong>-e, &amp;ndash;expiredate &amp;lt;EXPIRE_DATE&amp;gt;&lt;/strong> # 设定帐户过期的日期为 EXPIRE_DATE&lt;/li>
&lt;li>&lt;strong>-f, &amp;ndash;inactive INACTIVE&lt;/strong> # 过期 INACTIVE 天数后，设定密码为失效状态&lt;/li>
&lt;li>&lt;strong>-g, &amp;ndash;gid GROUP&lt;/strong> # 强制使用 GROUP 为新主组&lt;/li>
&lt;li>&lt;strong>-G, &amp;ndash;groups GROUPS&lt;/strong> # 新的附加组列表 GROUPS。将用户从该选项指定的组列表以外的组中删除。可以与 -a 选项配合，变更此行为。-a 会将用户附加到指定的组中而不删除。&lt;/li>
&lt;li>&lt;strong>-l, &amp;ndash;login LOGIN&lt;/strong> # 新的登录名称&lt;/li>
&lt;li>&lt;strong>-L, &amp;ndash;lock&lt;/strong> # 锁定用户帐号&lt;/li>
&lt;li>&lt;strong>-m, &amp;ndash;move-home&lt;/strong> # 将家目录内容移至新位置 (仅于 -d 一起使用)&lt;/li>
&lt;li>&lt;strong>-o, &amp;ndash;non-unique&lt;/strong> # 允许使用重复的(非唯一的) UID&lt;/li>
&lt;li>&lt;strong>-p, &amp;ndash;password PASSWORD&lt;/strong> # 将加密过的密码 (PASSWORD) 设为新密码&lt;/li>
&lt;li>-&lt;strong>R, &amp;ndash;root CHROOT_DIR&lt;/strong> # chroot 到的目录&lt;/li>
&lt;li>&lt;strong>-s, &amp;ndash;shell SHELL&lt;/strong> # 该用户帐号的新登录 shell&lt;/li>
&lt;li>&lt;strong>-u, &amp;ndash;uid UID&lt;/strong> # 用户帐号的新 UID&lt;/li>
&lt;li>&lt;strong>-U, &amp;ndash;unlock&lt;/strong> # 解锁用户帐号&lt;/li>
&lt;li>&lt;strong>-Z, &amp;ndash;selinux-user SEUSER&lt;/strong> # 用户账户的新 SELinux 用户映射&lt;/li>
&lt;/ul>
&lt;p>EXAMPLE&lt;/p>
&lt;ul>
&lt;li>修改 newname 用户所在群组为 test
&lt;ul>
&lt;li>usermod -g test newname&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>一次将一个用户添加到多个群组
&lt;ul>
&lt;li>usermod -G friends,happy,funny newname&lt;/li>
&lt;li>注意：使用 usermod 时要小心，因为配合-g 或-G 参数时，它会把用户从原先的群组里剔除，加入到新的群组。如果你不想离开原先的群组，又想加入新的群组，可以在-G 参数的基础上加上-a 参数，a 是英语 append 的缩写，表示“追加”。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>-a 追加用户到新的用户组，保留原来的组
&lt;ul>
&lt;li>usermod -aG happy newname&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h2 id="groupaddgroupdelgroupmodgpasswd--用户组管理相关命令">groupadd、groupdel、groupmod、gpasswd # 用户组管理相关命令&lt;/h2>
&lt;p>OPTIONS：&lt;/p>
&lt;ul>
&lt;li>-f, &amp;ndash;force 如果组已经存在则成功退出，并且如果 GID 已经存在则取消 -g&lt;/li>
&lt;li>-g, &amp;ndash;gid GID # 为新组使用 GID&lt;/li>
&lt;li>-K, &amp;ndash;key KEY=VALUE # 不使用 /etc/login.defs 中的默认值&lt;/li>
&lt;li>-o, &amp;ndash;non-unique # 允许创建有重复 GID 的组&lt;/li>
&lt;li>-p, &amp;ndash;password PASSWORD # 为新组使用此加密过的密码&lt;/li>
&lt;li>-r, &amp;ndash;system # 创建一个系统账户&lt;/li>
&lt;li>-R, &amp;ndash;root CHROOT_DIR # chroot 到的目录&lt;/li>
&lt;/ul>
&lt;p>EXAMPLE&lt;/p>
&lt;ul>
&lt;li>创建一个名为 newname 的组
&lt;ul>
&lt;li>groupadd newname&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>修改组
&lt;ul>
&lt;li>groupmod -n test2group testgroup&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>删除名为 test2group 的组
&lt;ul>
&lt;li>groupdel test2group&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>查看当前登陆用户所在的组
&lt;ul>
&lt;li>groups&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>查看 testnewuser 所在的组
&lt;ul>
&lt;li>groups testnewuser&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h2 id="who--显示当前登录用户的相关信息">who # 显示当前登录用户的相关信息&lt;/h2>
&lt;h3 id="syntax语法-3">Syntax(语法)&lt;/h3>
&lt;p>&lt;strong>who [OPTION]&amp;hellip; [ FILE | ARG1 ARG2 ]&lt;/strong>&lt;/p>
&lt;p>OPTIONS&lt;/p>
&lt;ul>
&lt;li>-a 打印能打印的全部&lt;/li>
&lt;li>-d 打印死掉的进程&lt;/li>
&lt;li>-m 同 am i,mom likes&lt;/li>
&lt;li>-q 打印当前登录用户数及用户名&lt;/li>
&lt;li>-u 打印当前登录用户登录信息&lt;/li>
&lt;li>-r 打印运行等级&lt;/li>
&lt;/ul>
&lt;p>EXAMPLE&lt;/p>
&lt;ul>
&lt;li>whoami # 要查看当前登录用户的用户名&lt;/li>
&lt;li>who am i # 表示打开当前伪终端的用户的用户名，可以简写为 who&lt;/li>
&lt;/ul>
&lt;p>who&lt;/p>
&lt;h1 id="密码管理工具">密码管理工具&lt;/h1>
&lt;h2 id="passwd--改变用户的密码">passwd # 改变用户的密码&lt;/h2>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://man7.org/linux/man-pages/man1/passwd.1.html">Manual(手册),passwd(1)&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;h3 id="syntax语法-4">Syntax(语法)&lt;/h3>
&lt;h2 id="chage--控制用户的密码到期信息">chage # 控制用户的密码到期信息&lt;/h2>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://man7.org/linux/man-pages/man1/chage.1.html">Manual(手册),chage(1)&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>passwd 软件包将会记录用户上次更改密码的时间、应该间隔多久更改一次密码 等等，chage 工具就可以对上述信息进行管理&lt;/p>
&lt;p>&lt;code>chage&lt;/code> 工具仅控制 /etc/shadow 文件中的信息，/etc/passwd 文件并不会影响到 &lt;code>chage&lt;/code> 程序的实现。并且，&lt;code>chage&lt;/code> 程序也不会报告 /etc/passwd 和 /etc/shaodw 文件的不一致情况，&lt;code>pwck&lt;/code> 工具可用于检测两个文件的不一致处。&lt;/p>
&lt;p>&lt;code>chage&lt;/code> 工具仅限于 root 用户，但是 -l 选项除外，非特权用户可以使用 -l 选项来确定自身的密码或账户合适到期。chage 可以修改 /etc/shadow 文件中多个字段的配置。&lt;/p>
&lt;h3 id="syntax语法-5">Syntax(语法)&lt;/h3>
&lt;p>&lt;strong>chage [OPTIONS] LOGIN&lt;/strong>&lt;/p>
&lt;p>&lt;strong>OPTIONS&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>&lt;strong>-d, &amp;ndash;lastday &amp;lt;INT&amp;gt;&lt;/strong> # 设置上次更改密码的日期。值是从 1970 年 1 月 1 日开始到某年某月某日的天数。
&lt;ul>
&lt;li>若指定空值，则表示从没修改过密码，即 -l 选项查看的第一行的值为 never。&lt;/li>
&lt;li>若指定 0，则用户再次登录时，则会被强制要求立刻修改密码，否则无法登录&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>-l, &amp;ndash;list&lt;/strong> # 显示账户的老化信息&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">[&lt;/span>root@hw-cloud-xngy-jump-server-linux-2 ~&lt;span style="color:#f92672">]&lt;/span>&lt;span style="color:#75715e"># chage -l root&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Last password change : Oct 01, &lt;span style="color:#ae81ff">2021&lt;/span> &lt;span style="color:#75715e"># 最后一次修改密码的时间&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Password expires : never
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Password inactive : never
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Account expires : never
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Minimum number of days between password change : &lt;span style="color:#ae81ff">0&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Maximum number of days between password change : &lt;span style="color:#ae81ff">99999&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Number of days of warning before password expires : &lt;span style="color:#ae81ff">7&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ul>
&lt;li>&lt;strong>-m, &amp;ndash;mindays &amp;lt;INT&amp;gt;&lt;/strong> # 密码可以修改的最小间隔天数。如果 INT 为 0，则表示不用等待，任何时候都可以修改密码
&lt;ul>
&lt;li>对应 shadow 文件中的第 4 个字段 minimum password age&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>-M, &amp;ndash;maxdays &amp;lt;INT&amp;gt;&lt;/strong> #
&lt;ul>
&lt;li>对应 shadow 文件中的第 5 个字段 maximum password age&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>-W, &amp;ndash;warndays &amp;lt;INT&amp;gt;&lt;/strong> #
&lt;ul>
&lt;li>对应 shadow 文件中的第 6 个字段 password warning period&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h2 id="pwck">pwck&lt;/h2></description></item><item><title>Docs: Alertmanager</title><link>https://desistdaydream.github.io/docs/6.%E5%8F%AF%E8%A7%82%E6%B5%8B%E6%80%A7/%E7%9B%91%E6%8E%A7%E7%B3%BB%E7%BB%9F/Alertmanager/Alertmanager/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/6.%E5%8F%AF%E8%A7%82%E6%B5%8B%E6%80%A7/%E7%9B%91%E6%8E%A7%E7%B3%BB%E7%BB%9F/Alertmanager/Alertmanager/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://prometheus.io/docs/alerting/latest/alertmanager/">官方文档&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>Prometheus Alert 介绍详见 Prometheus Server Alert 说明&lt;/p>
&lt;p>Alertmanager 处理由客户端应用程序（例如 Prometheus 服务器）发送的警报。它负责将重复数据删除，分组和路由到正确的接收者集成，例如电子邮件，PagerDuty 或 OpsGenie。它还负责沉默和禁止警报。&lt;/p>
&lt;p>&lt;strong>Alertmanager 特性&lt;/strong>&lt;/p>
&lt;p>Prometheus 发送过来的每一个告警，都会由 Alertmanager 进行重复数据删除、分组、路由到正确的接收者(e.g.邮件、钉钉等)上。&lt;/p>
&lt;p>Alertmanager 除了提供基本的告警通知能力以外，还主要提供了如：分组、抑制以及静默等告警特性：
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/fesx4v/1616068406984-251af31d-3e59-4621-bb62-d5228da42408.jpeg" alt="">
&lt;strong>分组&lt;/strong>
分组机制可以将详细的告警信息合并成一个通知。在某些情况下，比如由于系统宕机导致大量的告警被同时触发，在这种情况下分组机制可以将这些被触发的告警合并为一个告警通知，避免一次性接受大量的告警通知，而无法对问题进行快速定位。&lt;/p>
&lt;p>例如，当集群中有数百个正在运行的服务实例，并且为每一个实例设置了告警规则。假如此时发生了网络故障，可能导致大量的服务实例无法连接到数据库，结果就会有数百个告警被发送到 Alertmanager。&lt;/p>
&lt;p>而作为用户，可能只希望能够在一个通知中中就能查看哪些服务实例收到影响。这时可以按照服务所在集群或者告警名称对告警进行分组，而将这些告警内聚在一起成为一个通知。&lt;/p>
&lt;p>告警分组，告警时间，以及告警的接受方式可以通过 Alertmanager 的配置文件进行配置。&lt;/p>
&lt;p>&lt;strong>抑制&lt;/strong>
抑制是指当某一告警发出后，可以停止重复发送由此告警引发的其它告警的机制。&lt;/p>
&lt;p>例如，当集群不可访问时触发了一次告警，通过配置 Alertmanager 可以忽略与该集群有关的其它所有告警。这样可以避免接收到大量与实际问题无关的告警通知。&lt;/p>
&lt;p>抑制机制同样通过 Alertmanager 的配置文件进行设置。&lt;/p>
&lt;p>&lt;strong>静默&lt;/strong>
静默提供了一个简单的机制可以快速根据标签对告警进行静默处理。如果接收到的告警符合静默的配置，Alertmanager 则不会发送告警通知。&lt;/p>
&lt;p>静默设置需要在 Alertmanager 的 Werb 页面上进行设置。&lt;/p>
&lt;h2 id="alertmanager-告警分组">Alertmanager 告警分组&lt;/h2>
&lt;p>每一个告警进入 Alertmanager 后，都会进行分组处理，可以根据规则将多条告警合并为一个通知。这是为了可以让相关的告警可以合并在一起，一次性收集和发送，以便运维人员的故障排查。&lt;/p>
&lt;h2 id="alertmanager-告警路由">Alertmanager 告警路由&lt;/h2>
&lt;p>告警路由，顾名思义，路由就是根据“目的接收者”将每个告警发送到指定的接收者上的过程。&lt;/p>
&lt;p>每一个告警进入到 Alertmanager 都会由顶级的 route 进入路由树，需要注意的是顶级的 route 必须匹配所有告警(即不能有任何的匹配设置 match 和 match_re)，在一个路由树中，将每个被路由的目标称为 &lt;strong>Node(节点)。&lt;/strong>&lt;/p>
&lt;p>每一个路由都可以定义自己的接受人以及匹配规则。默认情况下，告警进入到顶级 route 后会遍历所有的子节点，直到找到最深的匹配 route，并将告警发送到该 route 定义的 receiver 中。但如果 route 中设置 continue 的值为 false，那么告警在匹配到第一个子节点之后就直接停止。如果 continue 为 true，报警则会继续进行后续子节点的匹配。如果当前告警匹配不到任何的子节点，那该告警将会基于当前路由节点的接收器配置方式进行处理。&lt;/p>
&lt;p>其中告警的匹配有两种方式可以选择。一种方式基于字符串验证，通过设置 match 规则判断当前告警中是否存在标签 labelname 并且其值等于 labelvalue。第二种方式则基于正则表达式，通过设置 match_re 验证当前告警标签的值是否满足正则表达式的内容。&lt;/p>
&lt;p>如果警报已经成功发送通知, 如果想设置发送告警通知之前要等待时间，则可以通过 repeat_interval 参数进行设置。&lt;/p>
&lt;h2 id="alertmanager-告警模板">Alertmanager 告警模板&lt;/h2>
&lt;p>告警模板的使用方式详见：告警模板详解&lt;/p>
&lt;p>默认情况下 Alertmanager 使用了系统自带的默认通知模板，模板源码可以从 &lt;a href="https://github.com/prometheus/alertmanager/blob/master/template/default.tmpl">https://github.com/prometheus/alertmanager/blob/master/template/default.tmpl&lt;/a> 获得。Alertmanager 的通知模板基于 Go 的模板系统。Alertmanager 也支持用户定义和使用自己的模板，一般来说有两种方式可以选择。&lt;/p>
&lt;p>第一种，基于模板字符串。用户可以直接在 Alertmanager 的配置文件中使用模板字符串，例如:&lt;/p>
&lt;pre>&lt;code>receivers:
- name: 'slack-notifications'
slack_configs:
- channel: '#alerts'
text: 'https://internal.myorg.net/wiki/alerts/{{ .GroupLabels.app }}/{{ .GroupLabels.alertname }}'
&lt;/code>&lt;/pre>
&lt;p>第二种方式，自定义可复用的模板文件。例如，可以创建自定义模板文件 custom-template.tmpl，如下所示：&lt;/p>
&lt;pre>&lt;code>{{ define &amp;quot;slack.myorg.text&amp;quot; }}https://internal.myorg.net/wiki/alerts/{{ .GroupLabels.app }}/{{ .GroupLabels.alertname }}{{ end}}
&lt;/code>&lt;/pre>
&lt;p>通过在 Alertmanager 的全局设置中定义 templates 配置来指定自定义模板的访问路径:&lt;/p>
&lt;pre>&lt;code># Files from which custom notification template definitions are read.
# The last component may use a wildcard matcher, e.g. 'templates/*.tmpl'.
templates:
[ - &amp;lt;filepath&amp;gt; ... ]
&lt;/code>&lt;/pre>
&lt;p>在设置了自定义模板的访问路径后，用户则可以直接在配置中使用该模板：&lt;/p>
&lt;pre>&lt;code>receivers:
- name: 'slack-notifications'
slack_configs:
- channel: '#alerts'
text: '{{ template &amp;quot;slack.myorg.text&amp;quot; . }}'
templates:
- '/etc/alertmanager/templates/myorg.tmpl'
&lt;/code>&lt;/pre>
&lt;h1 id="alertmanager-部署">Alertmanager 部署&lt;/h1>
&lt;p>与 prometheus 一样，可以通过二进制安装或者 docker 启动&lt;/p>
&lt;h2 id="使用-docker-的方式运行-alertmanager">使用 docker 的方式运行 Alertmanager&lt;/h2>
&lt;p>获取配置文件&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>mkdir -p /etc/monitoring
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>docker run -d --name alertmanager --rm prom/alertmanager
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>docker cp alertmanager:/etc/alertmanager /etc/monitoring
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>docker stop alertmanager
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>运行 Alertmanager&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>docker run -d --name alertmanager &lt;span style="color:#ae81ff">\
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">&lt;/span> --network host &lt;span style="color:#ae81ff">\
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">&lt;/span> -v /etc/localtime:/etc/localtime &lt;span style="color:#ae81ff">\
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">&lt;/span> -v /etc/monitoring/alertmanager:/etc/alertmanager/config_out &lt;span style="color:#ae81ff">\
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">&lt;/span> prom/alertmanager &lt;span style="color:#ae81ff">\
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">&lt;/span> --config.file&lt;span style="color:#f92672">=&lt;/span>/etc/alertmanager/config_out/alertmanager.yml
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>部署完成后，Alertmanager 默认监听在 9093 端口上，通过浏览器打开 http://localhost:9093 可以看到如下示例的画面
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/fesx4v/1616068406956-f10fe3df-d57f-4602-a6ab-e4aab90c89f1.jpeg" alt="">
首页 Alerts 标签上显示了从 Prometheus Server 推送过来的每一条告警，可以通过点击告警信息中的 Silence 来让该告警静音(i.e.不再发送告警邮件)&lt;/p>
&lt;h2 id="alertmanager-运行时的标志flags说明">Alertmanager 运行时的标志(Flags)说明&lt;/h2>
&lt;p>alertmanager 程序在启动时，可以使用一些标志来对程序进行一些基本设定，比如数据存储路径、存储时间等等&lt;/p>
&lt;ul>
&lt;li>&lt;strong>&amp;ndash;config.file=&amp;quot;/PATH/TO/FILE&amp;quot;&lt;/strong># 指定 alertmanager 基本配置文件。 默认 /etc/alertmanager/alertmanager.yml&lt;/li>
&lt;li>&lt;strong>&amp;ndash;storage.path=&amp;quot;/PATH&amp;quot;&lt;/strong># 指定存储数据的基础路径。该路径包括告警信息、已经 silences 的告警等信息。&lt;/li>
&lt;li>&lt;strong>&amp;ndash;data.retention=120h&lt;/strong> # 数据保存时长。&lt;/li>
&lt;li>&amp;ndash;alerts.gc-interval=30m # Interval between alert GC.&lt;/li>
&lt;li>&amp;ndash;web.external-url=WEB.EXTERNAL-URL zThe URL under which Alertmanager is externally reachable (for example, if Alertmanager is served via a reverse proxy). Used for generating relative and absolute links back to Alertmanagerzitself. If the URL has a path portion, it will be used to prefix all HTTP endpoints served by Alertmanager. If omitted, relevant URL components will be derived automatically.&lt;/li>
&lt;li>&amp;ndash;web.route-prefix=WEB.ROUTE-PREFIX zPrefix for the internal routes of web endpoints. Defaults to path of &amp;ndash;web.external-url.&lt;/li>
&lt;li>&amp;ndash;web.listen-address=&amp;quot;:9093&amp;quot; zAddress to listen on for the web interface and API.&lt;/li>
&lt;li>&amp;ndash;web.get-concurrency=0 Maximum number of GET requests processed concurrently. If negative or zero, the limit is GOMAXPROC or 8, whichever is larger.&lt;/li>
&lt;li>&amp;ndash;web.timeout=0 Timeout for HTTP requests. If negative or zero, no timeout is set.&lt;/li>
&lt;li>&amp;ndash;cluster.listen-address=&amp;ldquo;0.0.0.0:9094&amp;rdquo; zListen address for cluster. Set to empty string to disable HA mode.&lt;/li>
&lt;li>&amp;ndash;cluster.advertise-address=CLUSTER.ADVERTISE-ADDRESS zExplicit address to advertise in cluster.&lt;/li>
&lt;li>&amp;ndash;cluster.peer=CLUSTER.PEER &amp;hellip; zInitial peers (may be repeated).&lt;/li>
&lt;li>&amp;ndash;cluster.peer-timeout=15s zTime to wait between peers to send notifications.&lt;/li>
&lt;li>&amp;ndash;cluster.gossip-interval=200ms zInterval between sending gossip messages. By lowering this value (more frequent) gossip messages are propagated across the cluster more quickly at the expense of increased bandwidth.&lt;/li>
&lt;li>&amp;ndash;cluster.pushpull-interval=1m0s zInterval for gossip state syncs. Setting this interval lower (more frequent) will increase convergence speeds across larger clusters at the expense of increased bandwidth usage.&lt;/li>
&lt;li>&amp;ndash;cluster.tcp-timeout=10s Timeout for establishing a stream connection with a remote node for a full state sync, and for stream read and write operations.&lt;/li>
&lt;li>&amp;ndash;cluster.probe-timeout=500ms zTimeout to wait for an ack from a probed node before assuming it is unhealthy. This should be set to 99-percentile of RTT (round-trip time) on your network.&lt;/li>
&lt;li>&amp;ndash;cluster.probe-interval=1s zInterval between random node probes. Setting this lower (more frequent) will cause the cluster to detect failed nodes more quickly at the expense of increased bandwidth usage.&lt;/li>
&lt;li>&amp;ndash;cluster.settle-timeout=1m0s zMaximum time to wait for cluster connections to settle before evaluating notifications.&lt;/li>
&lt;li>&amp;ndash;cluster.reconnect-interval=10s zInterval between attempting to reconnect to lost peers.&lt;/li>
&lt;li>&amp;ndash;cluster.reconnect-timeout=6h0m0s zLength of time to attempt to reconnect to a lost peer.&lt;/li>
&lt;li>&amp;ndash;log.level=info Only log messages with the given severity or above. One of: [debug, info, warn, error]&lt;/li>
&lt;li>&amp;ndash;log.format=logfmt Output format of log messages. One of: [logfmt, json]&lt;/li>
&lt;li>&amp;ndash;version Show application version.&lt;/li>
&lt;/ul>
&lt;h1 id="alertmanager-配置">Alertmanager 配置&lt;/h1>
&lt;p>/etc/alertmanager/alertmanager.conf # alertmanager 基本配置文件默认位置。可以通过 &amp;ndash;config.file 标志指定其他配置文件&lt;/p>
&lt;p>下面是一个基本的 alertmanager.conf 配置文件示例：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-yaml" data-lang="yaml">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># 全局配置环境&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">global&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">resolve_timeout&lt;/span>: &lt;span style="color:#ae81ff">5m&lt;/span> &lt;span style="color:#75715e"># 该参数定义了当Alertmanager持续多长时间未接收到告警后标记告警状态为resolved（已解决）&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e"># 配置邮件发送信息&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">smtp_smarthost&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;smtp.163.com:25&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">smtp_from&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;ych_1024@163.com&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">smtp_auth_username&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;ych_1024@163.com&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">smtp_auth_password&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;&amp;lt;邮箱密码&amp;gt;&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">smtp_hello&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;163.com&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">smtp_require_tls&lt;/span>: &lt;span style="color:#66d9ef">false&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># 路由配置环境。所有报警信息进入后的根路由，用来设置报警的分发策略&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">route&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">group_by&lt;/span>: [&lt;span style="color:#e6db74">&amp;#34;alertname&amp;#34;&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;cluster&amp;#34;&lt;/span>] &lt;span style="color:#75715e"># 这里的标签列表是接收到报警信息后的重新分组标签，例如，接收到的报警信息里面有许多具有 cluster=A 和 alertname=LatncyHigh 这样的标签的报警信息将会批量被聚合到一个分组里面&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">group_wait&lt;/span>: &lt;span style="color:#ae81ff">TIME&lt;/span> &lt;span style="color:#75715e"># 当一个新的报警分组被创建后，需要等待至少TIME时间来初始化通知，这种方式可以确保您能有足够的时间为同一分组来获取多个警报，然后一起触发这个报警信息。&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">group_interval&lt;/span>: &lt;span style="color:#ae81ff">TIME&lt;/span> &lt;span style="color:#75715e"># 重复发送报警的设置(报警未消除的重复报警)。当一个组里的报警有变化时，等待&amp;#39;group_interval&amp;#39;时间来发送新的一组报警信息。默认5分钟。&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">repeat_interval&lt;/span>: &lt;span style="color:#ae81ff">TIME&lt;/span> &lt;span style="color:#75715e"># 重复发送报警的设置(报警未消除的重复报警)。一个组里的报警一直没有变化的话，等待&amp;#39;repeat_interval&amp;#39;时间来重新发送他们。默认4小时。&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">receiver&lt;/span>: &lt;span style="color:#ae81ff">STRING&lt;/span> &lt;span style="color:#75715e"># 指定默认的receiver名，如果一个报警没有任何一个routes匹配，则发送给默认的receiver&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">routes&lt;/span>: &lt;span style="color:#75715e"># 上面所有的配置参数都由所有子路由继承，并且可以在每个子路由上进行覆盖。&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#f92672">receiver&lt;/span>: &lt;span style="color:#ae81ff">STRING&lt;/span> &lt;span style="color:#75715e"># 指定该子路由要使用的receiver&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">group_wait&lt;/span>: &lt;span style="color:#ae81ff">TIME&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">match&lt;/span>: &lt;span style="color:#75715e"># 指定标签名和值，凡是具有该标签名和值的告警由将路由到指定的receiver上&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e"># 也可以使用 match_re 关键字，来进行正则表达式匹配。LabelValue 可以使用正则来表示&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">LabelName&lt;/span>: &lt;span style="color:#ae81ff">LabelValue&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># 接收者配置环境。用于定义分配好路由的告警信息将由谁来接收。&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">receivers&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#f92672">name&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;default&amp;#34;&lt;/span> &lt;span style="color:#75715e"># 指定receiver的名字&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">email_configs&lt;/span>: &lt;span style="color:#75715e"># 指定该receiver使用哪种配置&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#f92672">to&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;lichenhao@wisetv.com.cn&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">send_resolved&lt;/span>: &lt;span style="color:#66d9ef">true&lt;/span> &lt;span style="color:#75715e"># 指定是否发送告警已解决的信息。默认为false,i.e.不发送&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="配置样例">配置样例&lt;/h2>
&lt;h3 id="默认配置文件">默认配置文件&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-yaml" data-lang="yaml">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">global&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">resolve_timeout&lt;/span>: &lt;span style="color:#ae81ff">5m&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">route&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">group_by&lt;/span>: [&lt;span style="color:#e6db74">&amp;#34;alertname&amp;#34;&lt;/span>]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">group_wait&lt;/span>: &lt;span style="color:#ae81ff">10s&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">group_interval&lt;/span>: &lt;span style="color:#ae81ff">10s&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">repeat_interval&lt;/span>: &lt;span style="color:#ae81ff">1h&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">receiver&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;web.hook&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">receivers&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#f92672">name&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;web.hook&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">webhook_configs&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#f92672">url&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;http://127.0.0.1:5001/&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">inhibit_rules&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#f92672">source_match&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">severity&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;critical&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">target_match&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">severity&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;warning&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">equal&lt;/span>: [&lt;span style="color:#e6db74">&amp;#34;alertname&amp;#34;&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;dev&amp;#34;&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;instance&amp;#34;&lt;/span>]
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="使用腾讯企业邮箱的配置样例">使用腾讯企业邮箱的配置样例&lt;/h3>
&lt;p>Note：如果要使用腾讯企业邮箱，则需要生成客户端密码，位置如下图
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/fesx4v/1616068406969-84d8a216-cd2b-4438-a0e6-a6a85c64318a.jpeg" alt="">
下面的配置默认会将所有告警都发送给lichenhao@wisetv.com.cn。其中具有 network_device: interface-state 标签名和值的告警会发送给wangpeng@wisetv.com.cn&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-yaml" data-lang="yaml">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">global&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">resolve_timeout&lt;/span>: &lt;span style="color:#ae81ff">5m&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">smtp_smarthost&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;smtp.exmail.qq.com:587&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">smtp_from&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;lichenhao@wisetv.com.cn&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">smtp_auth_username&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;lichenhao@wisetv.com.cn&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">smtp_auth_password&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;bVcyqAh4jnz2hkVg&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">smtp_hello&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;qq.com&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">smtp_require_tls&lt;/span>: &lt;span style="color:#66d9ef">true&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">route&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">group_by&lt;/span>: [&lt;span style="color:#e6db74">&amp;#34;alertname&amp;#34;&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;cluster&amp;#34;&lt;/span>]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">group_wait&lt;/span>: &lt;span style="color:#ae81ff">30s&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">group_interval&lt;/span>: &lt;span style="color:#ae81ff">5m&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">repeat_interval&lt;/span>: &lt;span style="color:#ae81ff">5m&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">receiver&lt;/span>: &lt;span style="color:#ae81ff">default&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">routes&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#f92672">receiver&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;network-group&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">group_wait&lt;/span>: &lt;span style="color:#ae81ff">10s&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">match&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">network_device&lt;/span>: &lt;span style="color:#ae81ff">interface-state&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">receivers&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#f92672">name&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;default&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">email_configs&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#f92672">to&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;lichenhao@wisetv.com.cn&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">send_resolved&lt;/span>: &lt;span style="color:#66d9ef">true&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#f92672">name&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;network-group&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">email_configs&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#f92672">to&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;wangpeng@wisetv.com.cn&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">send_resolved&lt;/span>: &lt;span style="color:#66d9ef">true&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#f92672">to&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;lichenhao@wisetv.com.cn&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">send_resolved&lt;/span>: &lt;span style="color:#66d9ef">true&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h1 id="alertmanager-api">Alertmanager API&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://github.com/prometheus/alertmanager/blob/main/api/v2/openapi.yaml">GitHub 项目文件，prometheus/alertmanager/api/v2/openapi.yaml&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote></description></item><item><title>Docs: Ansible</title><link>https://desistdaydream.github.io/docs/9.%E8%BF%90%E7%BB%B4/Ansible/Ansible/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/9.%E8%BF%90%E7%BB%B4/Ansible/Ansible/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://www.ansible.com/">官网&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://github.com/ansible/ansible">GitHub 项目，ansible/ansible&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://docs.ansible.com/ansible/latest/index.html">官方文档&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://mp.weixin.qq.com/s/qu0vPgyNBbRlTtf1pMtq7Q">公众号,程序员面试吧-快速入门 Ansible 自动化运维工具&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.zsythink.net/archives/tag/ansible/">https://www.zsythink.net/archives/tag/ansible/&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>Ansible is a radically simple IT automation platform that makes your applications and systems easier to deploy and maintain. Automate everything from code deployment to network configuration to cloud management, in a language that approaches plain English, using SSH, with no agents to install on remote systems&lt;/p>
&lt;p>Ansible 是一个非常简单的 IT 自动化系统。它处理配置管理、应用程序部署、云供应、临时任务执行、网络自动化和多节点编排。Ansible 可以轻松得批量进行复杂的更改，例如使用负载均衡器进行零停机滚动更新。而这一过程使用 SSH 实现，无需在远程系统上安装代理程序。&lt;/p>
&lt;p>Ansible 的主要目标是简单易用。它还非常注重安全性和可靠性，具有最少的移动部件，使用 OpenSSH 进行传输（使用其他传输和拉模式作为替代），以及一种围绕人类可审计性设计的语言 - 即使是那些不熟悉的人该程序。&lt;/p>
&lt;h2 id="概念">概念&lt;/h2>
&lt;p>&lt;strong>Control node(控制节点)&lt;/strong> # 任何安装了 Ansible 的机器都可以称为控制节点。在控制节点中可以通过调用 &lt;code>ansible&lt;/code> 或 &lt;code>ansible-playbook&lt;/code> 命令来运行 Ansible 相关命令和 Playbooks。&lt;/p>
&lt;p>&lt;strong>Managed nodes(受管理节点)&lt;/strong> # 使用 Ansible 管理的 网络设备 或 服务器。受管理节点有时候也称为 &lt;strong>hosts&lt;/strong>。&lt;/p>
&lt;p>&lt;strong>Inventory(库存)&lt;/strong> # 库存是一个受管理节点的列表。库存有时候也称为 &lt;strong>hostfile&lt;/strong>。Inventory 还可以用来组织受管理节点，将每个节点进行分组，以便于扩展&lt;/p>
&lt;p>&lt;strong>Collections&lt;/strong> # 2.10 版本之后的新概念。Collections 是 Ansible 内容的分发格式，可以包括 Playbooks、Role、Modules、Plugins。新版中，Modules 和 Plugins 就被托管于 Collections 中。&lt;/p>
&lt;ul>
&lt;li>随着 Ansible 的发展，越来越多的模块、插件被开发并加入到 Ansible 的大家庭，这时候难免会出现命名上的冲突，或者调用上的重复。所以，从 2.10 版本之后，提出了 Collections 的概念。
&lt;ul>
&lt;li>Collections 最大的一个功能就是将模块分类，比如以前 核心模块 command，现在的全名就叫 ansible.builtin.command，前面的 ansible.builtin 就是 command 的 Collections。这种全名称为 &lt;strong>Full Qualified Class Name(完全限定类名，简称 FQCN)&lt;/strong>。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>Tasks(任务)&lt;/strong> # Ansible 工作的最小单元，Ansible 对受管理节点执行的操作，称为任务。&lt;/p>
&lt;p>&lt;strong>Modules(模块)&lt;/strong> # 模块就是 Ansible 用来执行 Tasks 的代码。&lt;/p>
&lt;p>&lt;strong>Playbooks(剧本)&lt;/strong> # 一个被保存起来的有序的 Tasks 列表，通过重复运行 Playbooks，可以方便得重复一组任务。Playbooks 中还可以包含变量、模板、条件语句、控制循环，从本质上来说，编写一个 Playbooks，就好像编写一个脚本代码一样。&lt;/p>
&lt;p>Playbooks 是 Ansible 的精髓，如果把 Ansible 当做一门语言，那么就成可以称为 Playbooks 脚本编程语言。&lt;/p>
&lt;h1 id="ansible-的核心组件">Ansible 的核心组件&lt;/h1>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/ot4g6f/1616125280904-828340be-8634-4a3f-a97b-d4600818bd6e.jpeg" alt="">&lt;/p>
&lt;ul>
&lt;li>&lt;strong>ansible core&lt;/strong> # 核心组件，ansible 本身&lt;/li>
&lt;li>&lt;strong>host inventory&lt;/strong> # 主机库存，Ansible 所管理的主机清单，一个文本文件&lt;/li>
&lt;li>&lt;strong>Modules&lt;/strong> # 模块。ansible 的 modules 是实现 ansible 的核心，
&lt;ul>
&lt;li>&lt;strong>core modules&lt;/strong> # 核心模块
&lt;ul>
&lt;li>ansible 执行任何命令，都是通过 module 来完成；比如 ansible 让被管理机创建一个用户，那么就会去 core modules 中调用一个能实现创建用户功能的模块，来执行这个操作。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>custom modules&lt;/strong> # 自定义模块
&lt;ul>
&lt;li>可以使用任何编程语言来编写模块，只要符合 ansible 的标准即可，可以实现 ansible 本身不具备的功能&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h1 id="ansible-模块与插件">Ansible 模块与插件&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://docs.ansible.com/ansible/latest/module_plugin_guide/index.html">官方文档，使用 Ansible 模块与插件&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>&lt;a href="https://desistdaydream.github.io/docs/9.%E8%BF%90%E7%BB%B4/Ansible/Ansible%20Modules/Ansible%20Modules.md">Ansible Modules(模块)&lt;/a> 是可以控制系统资源或执行系统命令的代码单元。 Ansible 提供了一个模块库，您可以直接在远程主机上或通过剧本执行。您还可以编写自定义模块。&lt;/p>
&lt;p>&lt;a href="https://desistdaydream.github.io/docs/9.%E8%BF%90%E7%BB%B4/Ansible/Ansible%20Plugins/Ansible%20Plugins.md">Ansible Plugins(插件)&lt;/a> 与模块类似，它们是扩展核心 Ansible 功能的代码片段。 Ansible 使用插件架构来实现丰富、灵活和可扩展的功能集。 Ansible 附带了几个插件，让您可以轻松使用自己的插件。&lt;/p>
&lt;p>比如，&lt;strong>Ansible 的控制节点连接到被管理节点时所使用的连接方式，就是通过 Connection 插件来实现的&lt;/strong>。而连接到目标节点后要执行的任务，则是由模块来实现的。&lt;/p>
&lt;p>再比如，我们在写 Playbook 时，会遇上处理需要文本的情况，比如大写转小写、获取第一个或最后一个字符等等，这些都是使用一种 Filters 的插件实现的。&lt;/p>
&lt;h1 id="ansible-关联文件与配置">Ansible 关联文件与配置&lt;/h1>
&lt;p>&lt;strong>/etc/ansible/ansible.cfg&lt;/strong> # ansible 使用时调用的配置文件&lt;/p>
&lt;p>&lt;strong>/etc/ansible/hosts&lt;/strong> # Inventory 的默认配置文件。该文件可以定义被管理主机的 IP，port 等，都可以定义在该文件中，具体格式如下&lt;/p>
&lt;ul>
&lt;li>单独 host，任何未分组的主机，需要在定义主机组之前定义各单独的 host，可以是 IP 地址或者主机名&lt;/li>
&lt;li>主机组，定义一个主机组，组名用[]括起来，可以定义多个主机组；当使用 ansible 命令的时候，可以使用组名来对该组内所有主机进行操作&lt;/li>
&lt;li>配置文件说明：详见：&lt;a href="https://desistdaydream.github.io/docs/9.%E8%BF%90%E7%BB%B4/Ansible/Inventory%20%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3.md">inventory 配置文件详解&lt;/a>&lt;/li>
&lt;/ul></description></item><item><title>Docs: Ansible Modules</title><link>https://desistdaydream.github.io/docs/9.%E8%BF%90%E7%BB%B4/Ansible/Ansible-Modules/Ansible-Modules/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/9.%E8%BF%90%E7%BB%B4/Ansible/Ansible-Modules/Ansible-Modules/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://docs.ansible.com/ansible/latest/module_plugin_guide/modules_intro.html">官方文档，使用 Ansible 模块和插件-模块介绍&lt;/a>
&lt;ul>
&lt;li>&lt;a href="https://docs.ansible.com/ansible/2.10/user_guide/modules.html">2.10 版本&lt;/a>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>&lt;strong>Modules(模块)&lt;/strong> 也被称为 &lt;strong>Task Plugins(任务插件)&lt;/strong> 或 &lt;strong>Library Plugins(插件库)&lt;/strong>，Modules 是可以从 Ansible 的命令行或 Playbook 的任务中使用的代码块。Ansible 通常在受管理节点上执行每个模块以完成任务，并收集返回值。&lt;/p>
&lt;blockquote>
&lt;p>注意：在 Ansible 2.10 及以上的版本中，大多数模块都被托管到 &lt;strong>Collections(集合)&lt;/strong> 中。&lt;/p>
&lt;/blockquote>
&lt;p>我们可以通过命令行使用模块执行任务，比如&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>ansible webservers -m service -a &lt;span style="color:#e6db74">&amp;#34;name=httpd state=started&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>ansible webservers -m ping
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>ansible webservers -m command -a &lt;span style="color:#e6db74">&amp;#34;/sbin/reboot -t now&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>也可以在 Playbooks 中使用模块执行任务，比如&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-yaml" data-lang="yaml">&lt;span style="display:flex;">&lt;span>- &lt;span style="color:#f92672">name&lt;/span>: &lt;span style="color:#ae81ff">restart webserver&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">service&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">name&lt;/span>: &lt;span style="color:#ae81ff">httpd&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">state&lt;/span>: &lt;span style="color:#ae81ff">restarted&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>等效于&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>ansible webservers -m service -a &lt;span style="color:#e6db74">&amp;#34;name=httpd state=started&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>每个模块都可以接受参数，以空格分割的 &lt;code>KEY=VALUE&lt;/code> 格式。&lt;/p>
&lt;blockquote>
&lt;p>注意：在命令行中使用模块与在 Playbooks 中使用模块时，可以传递的参数不太一样，比如 command 或 shell 模块，只需要传递需要运行的命令这个参数即可，但是在 Playbooks 中使用这两个模块，还可以传递其他参数。&lt;/p>
&lt;/blockquote>
&lt;p>所有模块执行完成后，都会有返回一个 JSON 格式的数据，这意味着可以使用任何编程语言编写模块。模块应该是幂等的，如果检测到当前状态与所需要的最终状态匹配，则应该避免再进行任何更改。&lt;/p>
&lt;p>下面我们拿一个最简单的模块举例，ansible.builtin.command 模块，当我们使用 command 模块时，可以为其传递参数，在其执行完任务之后，还会有返回值。&lt;/p>
&lt;h2 id="简单示例">简单示例&lt;/h2>
&lt;p>假如现在有这么一个 Playbooks&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-yaml" data-lang="yaml">&lt;span style="display:flex;">&lt;span>- &lt;span style="color:#f92672">name&lt;/span>: &lt;span style="color:#ae81ff">test&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">command&lt;/span>: &lt;span style="color:#ae81ff">whoami&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">register&lt;/span>: &lt;span style="color:#ae81ff">info&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>- &lt;span style="color:#f92672">name&lt;/span>: &lt;span style="color:#ae81ff">debug&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">debug&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">msg&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;{{info}}&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>这个 Playbooks 的意思就是在受管理节点上执行 &lt;code>whoami&lt;/code> 命令，并将返回值保存到 info 变量中，通过 debug 模块，将 info 变量中的内容输出出来，效果如下：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-json" data-lang="json">&lt;span style="display:flex;">&lt;span>[&lt;span style="color:#960050;background-color:#1e0010">lichenhao@hw-cloud-xngy-jump-server-linux&lt;/span>&lt;span style="color:#ae81ff">-2&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">~/projects/DesistDaydream/ehualu/ansible/playbook&lt;/span>]&lt;span style="color:#960050;background-color:#1e0010">$&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">ansible-playbook&lt;/span> &lt;span style="color:#ae81ff">90&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">-test.yaml&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#960050;background-color:#1e0010">PLAY&lt;/span> [&lt;span style="color:#960050;background-color:#1e0010">test&lt;/span>] &lt;span style="color:#960050;background-color:#1e0010">*******************************************************************************************************************************************************************&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#960050;background-color:#1e0010">TASK&lt;/span> [&lt;span style="color:#ae81ff">90&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">-test&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">:&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">test&lt;/span>] &lt;span style="color:#960050;background-color:#1e0010">*********************************************************************************************************************************************************&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#960050;background-color:#1e0010">changed:&lt;/span> [&lt;span style="color:#960050;background-color:#1e0010">hw-cloud-xngy-jump-server-linux&lt;/span>&lt;span style="color:#ae81ff">-2&lt;/span>]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#960050;background-color:#1e0010">TASK&lt;/span> [&lt;span style="color:#ae81ff">90&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">-test&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">:&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">debug&lt;/span>] &lt;span style="color:#960050;background-color:#1e0010">********************************************************************************************************************************************************&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#960050;background-color:#1e0010">ok:&lt;/span> [&lt;span style="color:#960050;background-color:#1e0010">hw-cloud-xngy-jump-server-linux&lt;/span>&lt;span style="color:#ae81ff">-2&lt;/span>] &lt;span style="color:#960050;background-color:#1e0010">=&amp;gt;&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;info&amp;#34;&lt;/span>: {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;ansible_facts&amp;#34;&lt;/span>: {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;discovered_interpreter_python&amp;#34;&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;/usr/bin/python3&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> },
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;changed&amp;#34;&lt;/span>: &lt;span style="color:#66d9ef">true&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;cmd&amp;#34;&lt;/span>: [
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#34;whoami&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ],
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;delta&amp;#34;&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;0:00:00.002447&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;end&amp;#34;&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;2021-10-09 23:05:10.491190&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;failed&amp;#34;&lt;/span>: &lt;span style="color:#66d9ef">false&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;rc&amp;#34;&lt;/span>: &lt;span style="color:#ae81ff">0&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;start&amp;#34;&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;2021-10-09 23:05:10.488743&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;stderr&amp;#34;&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;stderr_lines&amp;#34;&lt;/span>: [],
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;stdout&amp;#34;&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;root&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;stdout_lines&amp;#34;&lt;/span>: [
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#34;root&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#960050;background-color:#1e0010">PLAY&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">RECAP&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">********************************************************************************************************************************************************************&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#960050;background-color:#1e0010">hw-cloud-xngy-jump-server-linux&lt;/span>&lt;span style="color:#ae81ff">-2&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">:&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">ok=&lt;/span>&lt;span style="color:#ae81ff">2&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">changed=&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">unreachable=&lt;/span>&lt;span style="color:#ae81ff">0&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">failed=&lt;/span>&lt;span style="color:#ae81ff">0&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">skipped=&lt;/span>&lt;span style="color:#ae81ff">0&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">rescued=&lt;/span>&lt;span style="color:#ae81ff">0&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">ignored=&lt;/span>&lt;span style="color:#ae81ff">0&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>我们对比&lt;a href="https://docs.ansible.com/ansible/latest/collections/ansible/builtin/command_module.html#return-values">官方文档中 command 模块的返回值&lt;/a>，可以看到，与文档中的返回值保持一致。
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/shqrrv/1633792369531-e531b4d1-5c2b-427c-ade8-6207d5d6020b.png" alt="image.png">&lt;/p>
&lt;h2 id="总结">总结&lt;/h2>
&lt;p>所以，这也是为什么将 Moduels 称为代码的原因，&lt;strong>所谓的 Modules，本质上就是代码写出来的程序，就像 Functions&lt;/strong>，具有形参，可以接受实参，执行完成后，还会有返回值。Ansible 通过模块执行完一个任务之后，就会处理这些返回值，将其 或保存、或展示、或丢弃 等等。同时，在 Playbooks 中，还可以通过判断语句，根据返回值的内容，决定下一个任务的运行模式。&lt;/p>
&lt;p>我们可以通过 &lt;code>ansible-doc -l&lt;/code> 命令查看所有可用的模块，或者从&lt;a href="https://docs.ansible.com/ansible/latest/collections/index.html#list-of-collections">官方文档-Collections 文档&lt;/a>中查看所有模块
还可以使用&lt;code> ansible-doc MODULE&lt;/code> 命令查看指定模块的文档&lt;/p>
&lt;h1 id="模块分类">模块分类&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://docs.ansible.com/ansible/2.9/modules/modules_by_category.html">官方文档 2.9，用户指南-使用模块-模块索引&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://docs.ansible.com/ansible/latest/collections/index_module.html">官方文档 2.10+，所有模块和插件的索引-所有模块的索引&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>在 2.10 版本之前，模块的分类非常清晰；2.10 版本之后，由于模块被合并到集合中，所以很多已经分类的模块被合并到 &lt;a href="https://docs.ansible.com/ansible/latest/collections/index_module.html#ansible-builtin">builtin(内置) 模块&lt;/a>这个类别中，在这里则不再进行细致划分，非常乱。。。。&lt;/p>
&lt;p>模块的保存位置（ansible python module location）也产生了变化：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>~&lt;span style="color:#f92672">]&lt;/span>&lt;span style="color:#75715e"># ansible --version&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>ansible 2.9.6
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> config file &lt;span style="color:#f92672">=&lt;/span> /etc/ansible/ansible.cfg
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> configured module search path &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#f92672">[&lt;/span>&lt;span style="color:#e6db74">&amp;#39;/home/lichenhao/.ansible/plugins/modules&amp;#39;&lt;/span>, &lt;span style="color:#e6db74">&amp;#39;/usr/share/ansible/plugins/modules&amp;#39;&lt;/span>&lt;span style="color:#f92672">]&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ansible python module location &lt;span style="color:#f92672">=&lt;/span> /usr/lib/python3/dist-packages/ansible
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> executable location &lt;span style="color:#f92672">=&lt;/span> /usr/bin/ansible
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> python version &lt;span style="color:#f92672">=&lt;/span> 3.8.10 &lt;span style="color:#f92672">(&lt;/span>default, Jun &lt;span style="color:#ae81ff">22&lt;/span> 2022, 20:18:18&lt;span style="color:#f92672">)&lt;/span> &lt;span style="color:#f92672">[&lt;/span>GCC 9.4.0&lt;span style="color:#f92672">]&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/shqrrv/1669781692961-2dda8a1f-3eec-4687-beb3-fa3d141c1b5e.png" alt="image.png">&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>~&lt;span style="color:#f92672">]&lt;/span>&lt;span style="color:#75715e"># ansible --version&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>ansible &lt;span style="color:#f92672">[&lt;/span>core 2.13.6&lt;span style="color:#f92672">]&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> config file &lt;span style="color:#f92672">=&lt;/span> /etc/ansible/ansible.cfg
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> configured module search path &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#f92672">[&lt;/span>&lt;span style="color:#e6db74">&amp;#39;/root/.ansible/plugins/modules&amp;#39;&lt;/span>, &lt;span style="color:#e6db74">&amp;#39;/usr/share/ansible/plugins/modules&amp;#39;&lt;/span>&lt;span style="color:#f92672">]&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ansible python module location &lt;span style="color:#f92672">=&lt;/span> /root/.local/lib/python3.8/site-packages/ansible
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ansible collection location &lt;span style="color:#f92672">=&lt;/span> /root/.ansible/collections:/usr/share/ansible/collections
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> executable location &lt;span style="color:#f92672">=&lt;/span> /usr/bin/ansible
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> python version &lt;span style="color:#f92672">=&lt;/span> 3.8.10 &lt;span style="color:#f92672">(&lt;/span>default, Jun &lt;span style="color:#ae81ff">22&lt;/span> 2022, 20:18:18&lt;span style="color:#f92672">)&lt;/span> &lt;span style="color:#f92672">[&lt;/span>GCC 9.4.0&lt;span style="color:#f92672">]&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> jinja version &lt;span style="color:#f92672">=&lt;/span> 3.1.2
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> libyaml &lt;span style="color:#f92672">=&lt;/span> True
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/shqrrv/1669781684010-2cc9f6a7-cb1e-4e93-bf81-e41ef417c23c.png" alt="image.png">&lt;/p></description></item><item><title>Docs: Ansible 管理</title><link>https://desistdaydream.github.io/docs/9.%E8%BF%90%E7%BB%B4/Ansible/Ansible-%E7%AE%A1%E7%90%86/Ansible-%E7%AE%A1%E7%90%86/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/9.%E8%BF%90%E7%BB%B4/Ansible/Ansible-%E7%AE%A1%E7%90%86/Ansible-%E7%AE%A1%E7%90%86/</guid><description>
&lt;h1 id="实际案例">实际案例：&lt;/h1>
&lt;h2 id="批量关闭开启虚拟机">批量关闭/开启虚拟机&lt;/h2>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-yaml" data-lang="yaml">&lt;span style="display:flex;">&lt;span>- &lt;span style="color:#f92672">name&lt;/span>: &lt;span style="color:#ae81ff">获取虚拟机列表&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">virt&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">command&lt;/span>: &lt;span style="color:#ae81ff">list_vms&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">register&lt;/span>: &lt;span style="color:#ae81ff">info&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>- &lt;span style="color:#f92672">name&lt;/span>: &lt;span style="color:#ae81ff">循环开启虚拟机&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">virt&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">name&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;{{ item }}&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">command&lt;/span>: &lt;span style="color:#ae81ff">start&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">loop&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;{{ info.list_vms }}&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div></description></item><item><title>Docs: AnsiblePlugins</title><link>https://desistdaydream.github.io/docs/9.%E8%BF%90%E7%BB%B4/Ansible/Ansible-Plugins/Ansible-Plugins/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/9.%E8%BF%90%E7%BB%B4/Ansible/Ansible-Plugins/Ansible-Plugins/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://docs.ansible.com/ansible/latest/plugins/plugins.html">官方文档，使用插件&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>插件是增强 Ansible 核心功能的代码段。Ansible 使用插件架构来启用丰富，灵活和可扩展的功能集。&lt;/p>
&lt;p>朗读 Ansible 附带了许多方便的插件，您可以轻松编写自己的插件。&lt;/p>
&lt;p>本节介绍 Ansible 随附的各种类型的插件：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://docs.ansible.com/ansible/latest/plugins/action.html">Action Plugins&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://docs.ansible.com/ansible/latest/plugins/become.html">Become Plugins&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://docs.ansible.com/ansible/latest/plugins/cache.html">Cache Plugins&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://docs.ansible.com/ansible/latest/plugins/callback.html">Callback Plugins&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://docs.ansible.com/ansible/latest/plugins/cliconf.html">Cliconf Plugins&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://desistdaydream.github.io/docs/9.%E8%BF%90%E7%BB%B4/Ansible/Ansible%20Plugins/Connection%20%E6%8F%92%E4%BB%B6.md">Connection 插件&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://docs.ansible.com/ansible/latest/plugins/httpapi.html">Httpapi Plugins&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://docs.ansible.com/ansible/latest/plugins/inventory.html">Inventory Plugins&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://docs.ansible.com/ansible/latest/plugins/lookup.html">Lookup Plugins&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://docs.ansible.com/ansible/latest/plugins/netconf.html">Netconf Plugins&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://docs.ansible.com/ansible/latest/plugins/shell.html">Shell Plugins&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://docs.ansible.com/ansible/latest/plugins/strategy.html">Strategy Plugins&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://docs.ansible.com/ansible/latest/plugins/vars.html">Vars Plugins&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://docs.ansible.com/ansible/latest/user_guide/playbooks_filters.html">Filters&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://docs.ansible.com/ansible/latest/user_guide/playbooks_tests.html">Tests&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://docs.ansible.com/ansible/latest/user_guide/plugin_filtering_config.html">Plugin Filter Configuration&lt;/a>&lt;/li>
&lt;/ul></description></item><item><title>Docs: API</title><link>https://desistdaydream.github.io/docs/2.%E7%BC%96%E7%A8%8B/API/API/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/2.%E7%BC%96%E7%A8%8B/API/API/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;a href="https://en.wikipedia.org/wiki/API">wiki，API&lt;/a>&lt;/p>
&lt;/blockquote>
&lt;p>&lt;strong>Application Programming Interface(应用程序接口，简称 API)&lt;/strong>。它定义了可以进行的调用或请求的类型，如何进行调用，应使用的数据格式，遵循的约定等。它还可以提供扩展机制，以便用户可以通过各种方式扩展现有功能。在不同程度上。[1] API 可以是完全自定义的，特定于组件的，也可以基于行业标准设计以确保互操作性。通过&lt;a href="https://en.wikipedia.org/wiki/Information_hiding">信息隐藏&lt;/a>，API 支持&lt;a href="https://en.wikipedia.org/wiki/Modular_programming">模块化编程&lt;/a>，从而使用户可以独立于实现使用接口。&lt;/p>
&lt;h2 id="目的">目的&lt;/h2>
&lt;p>在构建应用程序时，API（应用程序编程接口）通过抽象化底层实现并仅公开开发人员需要的对象或动作来简化编程。电子邮件客户端的图形界面可能会为用户提供执行获取和突出显示新电子邮件的所有步骤的按钮，而用于文件输入/输出的 API 可能会为开发人员提供一种将文件从一个位置复制到另一个位置的功能，而无需要求开发人员了解幕后发生的文件系统操作。[2]&lt;/p>
&lt;h2 id="术语的历史">术语的历史&lt;/h2>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/folw44/1616163705351-3d45137b-c5db-4656-839f-5fa583e353e3.png" alt="">&lt;/p>
&lt;p>1978 年的一张图建议将 API 的概念扩展为一个通用的编程接口，而不仅仅是应用程序。[3]&lt;/p>
&lt;p>“ &lt;em>API&lt;/em> ”一词的含义已经扩展了其历史。首先，它仅描述了面向面向最终用户的程序（称为应用程序）的接口。此起源仍反映在名称“应用程序编程接口”中。如今，术语 API 的范围更广，不仅包括实用程序软件，甚至包括硬件接口。[4]&lt;/p>
&lt;p>API 的概念比该术语要古老得多。英国计算机科学家 Wilkes 和 Wheeler 在 1940 年代为 EDSAC 计算机开发了模块化软件库。约书亚·布洛赫（Joshua Bloch）声称威尔克斯和惠勒（Wilker and Wheeler）“潜在地发明”了该 API，因为它更多地是被发现而不是被发明的概念。[4]&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/folw44/1616163705346-76236d7f-ccd5-42d5-81dd-04fdda266f7a.jpeg" alt="">&lt;/p>
&lt;p>尽管创造 API 一词的人是在 Univac 1108 上实现软件，但他们的 API 的目标是使独立于硬件的程序成为可能。[5]&lt;/p>
&lt;p>术语“应用程序接口”（没有_-ing_后缀）首先被记录在称为纸张_数据结构和技术对于远程计算机图形_在呈现 AFIPS 在 1968 年会议[6] [4]所述的本文使用的作者该术语描述应用程序（在这种情况下为图形程序）与计算机系统其余部分的交互。一致的应用程序接口（包括 Fortran 子例程调用）旨在使程序员摆脱处理图形显示设备的特性，并在更换计算机或显示器时提供硬件独立性。[5]&lt;/p>
&lt;p>术语被引入到的场数据库由 CJ 日期[7]中称为 1974 纸_的关系和网络途径：应用程序编程接口的比较_。[8] API 成为用于数据库管理系统的 ANSI / SPARC 框架的一部分。该框架将应用程序编程接口与其他接口（例如查询接口）分开对待。1970 年代的数据库专业人员发现，这些不同的接口可以组合在一起。一个足够丰富的应用程序接口也可以支持其他接口。[3]&lt;/p>
&lt;p>这种观察导致 API 支持所有类型的编程，而不仅是应用程序编程。到 1990 年，API 被技术专家 Carl Malamud 定义为“程序员可以用来执行某些任务的一组服务” 。[9]&lt;/p>
&lt;p>随着 Web API 的出现，API 的概念再次得到扩展。罗伊·菲尔丁（Roy Fielding）的论文《_建筑风格》和_2000 年在加州大学欧文分校（UC Irvine）_的基于网络的软件体系结构设计_概述了代表性状态转移（REST），并描述了“菲林丁”与传统的“图书馆应用程序接口”的“基于网络的应用程序编程接口”的概念。基于”的 API。[10] XML 和 JSON Web API 于 2000 年开始得到广泛的商业采用，并一直持续到 2020 年。&lt;/p>
&lt;p>现在，Web API 是术语 API 的最常见含义。[11]以这种方式使用时，术语“ API”与术语“通信协议”和“远程过程调用”在含义上有一些重叠。&lt;/p>
&lt;h2 id="用法">用法&lt;/h2>
&lt;h3 id="库和框架">库和框架&lt;/h3>
&lt;p>API 通常与软件库有关。当库是这套规则的“实际实现”时，API 描述并规定了“预期行为”（一种规范）。&lt;/p>
&lt;p>单个 API 可以采用共享同一编程接口的不同库的形式进行多种实现（或者没有一种实现是抽象的）。&lt;/p>
&lt;p>将 API 与实现分开，可以允许以一种语言编写的程序使用以另一种语言编写的库。例如，由于 Scala 和 Java 可以编译为兼容的字节码，因此 Scala 开发人员可以利用任何 Java API。[12]&lt;/p>
&lt;p>API 的使用取决于所涉及的编程语言的类型。诸如 Lua 之类的过程语言的 API 可以主要由执行代码，操纵数据或处理错误的基本例程组成，而诸如 Java 之类的面向对象语言的 API 则可以提供类及其类方法的规范。[13] [14]&lt;/p>
&lt;p>语言绑定也是 API。通过将一种语言的特性和功能映射到以另一种语言实现的接口，语言绑定允许在以另一种语言进行开发时使用以一种语言编写的库或服务。[15]诸如 SWIG 和 F2PY（一种从 Fortran 到 Python 的接口生成器）之类的工具有助于创建此类接口。[16]&lt;/p>
&lt;p>API 也可以与软件框架相关：框架可以基于实现了多个 API 的多个库，但是与 API 的正常使用不同，对框架内建行为的访问是通过使用新类扩展其内容来实现的插入框架本身。&lt;/p>
&lt;p>而且，整个控制程序流程可以通过控制反转或类似的机制而不受调用者的控制，而不受框架的控制。[17] [18]&lt;/p>
&lt;h3 id="操作系统">操作系统&lt;/h3>
&lt;p>API 可以指定应用程序和操作系统之间的接口。[19] 例如，POSIX 指定一组通用 API，这些 API 旨在使为 POSIX 兼容操作系统编写的应用程序能够为另一个 POSIX 兼容操作系统编译。&lt;/p>
&lt;p>Linux 和 Berkeley 软件发行版是实现 POSIX API 的操作系统的示例。[20]&lt;/p>
&lt;p>Microsoft 已显示出对向后兼容 API 的坚定承诺，尤其是在其 Windows API（Win32）库中，因此较旧的应用程序可以使用称为“兼容模式”的可执行程序特定设置在新版 Windows 上运行。[21]&lt;/p>
&lt;p>API 与应用程序二进制接口（ABI）的不同之处在于，API 是基于源代码的，而 ABI 是基于二进制的。例如，POSIX 提供 API，而 Linux Standard Base 提供 ABI。&lt;/p>
&lt;h3 id="远程-api">远程 API&lt;/h3>
&lt;p>远程 API 允许开发人员通过协议（特定于通信的标准）来操纵远程资源，该协议允许不同的技术一起工作，而不论语言或平台如何。例如，Java 数据库连接 API 允许开发人员使用相同的功能集查询许多不同类型的数据库，而 Java 远程方法调用 API 使用 Java 远程方法协议来允许调用可远程操作但在本地运行的功能开发人员。[24] [25]&lt;/p>
&lt;p>因此，远程 API 对于维护面向对象程序设计中的对象抽象很有用。在代理对象上本地执行的方法调用，使用远程协议在远程对象上调用相应的方法，并获取要在本地用作返回值的结果。&lt;/p>
&lt;p>代理对象的修改也将导致远程对象的相应修改。[26]&lt;/p>
&lt;h3 id="web-api">Web API&lt;/h3>
&lt;p>主要文章：Web API&lt;/p>
&lt;p>Web API 是企业和使用其资产的应用程序之间进行交互的已定义接口，这也是服务水平协议（SLA），用于指定功能提供者并为其 API 用户公开服务路径或 URL。API 方法是一种体系结构方法，它围绕为服务于不同类型消费者的不同应用程序提供一组服务的程序接口而发展。[27]&lt;/p>
&lt;p>当在 Web 开发的上下文中使用 API 时，通常将其定义为一组规范，例如超文本传输协议（HTTP）请求消息以及响应消息的结构定义，通常以可扩展标记语言（XML））或 JavaScript 对象符号（JSON）格式。例如运输公司的 API，可以将其添加到以电子商务为中心的网站上，以方便订购运输服务，并自动包括当前的运输价格，而站点开发人员不必在网络数据库中输入运输者的价格表。尽管“ Web API”在历史上实际上是 Web 服务的代名词，但最近的趋势（所谓的 Web 2.0）已从基于简单对象访问协议（SOAP）的 Web 服务和面向服务的体系结构（SOA）转向更直接的表示状态转移（REST）样式的 Web 资源和面向资源的体系结构（ROA）。[28]这种趋势的一部分与语义 Web 向资源描述框架（RDF）的发展有关，RDF 是一种促进基于 Web 的本体工程技术的概念。Web API 允许将多个 API 组合到称为 mashup 的新应用程序中。[29] 在社交媒体领域，Web API 使 Web 社区可以促进在社区和应用程序之间共享内容和数据。这样，可以将在一个地方动态创建的内容发布并更新到 Web 上的多个位置。[30]例如，Twitter 的 REST API 允许开发人员访问 Twitter 的核心数据，而 Search API 为开发人员提供了与 Twitter 搜索和趋势数据进行交互的方法。[31]&lt;/p>
&lt;h2 id="设计">设计&lt;/h2>
&lt;p>API 的设计对其使用有重大影响。[2]信息隐藏的原理将编程接口的作用描述为通过隐藏模块的实现细节来实现模块化编程，从而使模块用户无需了解模块内部的复杂性。[32]因此，API 的设计试图仅提供用户期望的工具。[2]编程接口的设计是软件体系结构的重要组成部分，是复杂软件的组织。[33]&lt;/p>
&lt;h2 id="发布政策">发布政策&lt;/h2>
&lt;p>API 是技术公司更常见的集成方式之一。提供和使用 API 的组件被视为业务生态系统的成员。[34]&lt;/p>
&lt;p>发布 API 的主要策略是：[35]&lt;/p>
&lt;ul>
&lt;li>
&lt;p>私有：该 API 仅供内部公司使用。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>合作伙伴：只有特定的业务合作伙伴可以使用 API。例如，Uber 和 Lyft 等租用公司的车辆允许经过批准的第三方开发人员直接在其应用程序内订购游乐设施。这使公司可以通过选择哪些应用程序可以访问 API 来进行质量控制，并为其提供额外的收入来源。[36]&lt;/p>
&lt;/li>
&lt;li>
&lt;p>公开：该 API 供公众使用。例如，Microsoft 公开了 Windows API，Apple 发行了其 API Cocoa，因此可以为其平台编写软件。通常，并非所有人都能访问所有公共 API。例如，Cloudflare 或 Voxility 等 Internet 服务提供商使用 RESTful API，以允许客户和转售商访问其基础结构信息，DDoS 统计信息，网络性能或仪表板控件。[37]可以通过“ API 令牌”或客户身份验证来授予对此类 API 的访问权限。[38]&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h3 id="公共-api-的含义">公共 API 的含义&lt;/h3>
&lt;p>API 公开时的重要因素是其“接口稳定性”。对 API 的更改（例如，向函数调用添加新参数）可能会破坏与依赖该 API 的客户端的兼容性。[39]&lt;/p>
&lt;p>当公开展示的 API 的某些部分可能发生更改并因此不稳定时，应将特定 API 的这些部分明确记录为“不稳定”。例如，在 Google Guava 库中，被视为不稳定的部分或可能即将更改的部分都标有 Java 注释 &lt;code>@Beta&lt;/code>。[40]&lt;/p>
&lt;p>公共 API 有时可以声明其自身的某些部分_已弃用_或废除。这通常意味着应将 API 的一部分视为要删除或以向后不兼容的方式进行修改的候选对象。因此，这些更改使开发人员可以脱离 API 的某些部分，这些部分将来将被删除或不再受支持。[41]&lt;/p>
&lt;p>客户端代码可能包含 API 设计人员不打算使用的创新用法或机会用法。换句话说，对于具有大量用户基础的库，当元素成为公共 API 的一部分时，可以多种方式使用它。[42] 2020 年 2 月 19 日，Akamai 发布了他们的年度“互联网状况”报告，展示了针对全球金融服务中针对公共 API 平台的网络犯罪分子的增长趋势。从 2017 年 12 月到 2019 年 11 月，Akamai 见证了 854.2 亿次凭证违规攻击。大约 20％（即 165.5 亿）与定义为 API 端点的主机名相对。其中，4.735 亿针对金融服务部门组织。[43]&lt;/p>
&lt;h2 id="文档">文档&lt;/h2>
&lt;p>API 文档描述了 API 提供的服务以及如何使用这些服务，旨在涵盖客户出于实际目的需要了解的所有内容。&lt;/p>
&lt;p>文档对于使用 API 开发和维护应用程序至关重要。[44] API 文档通常在文档文件中找到，但也可以在社交媒体（例如博客，论坛和问答网站）中找到。[45]&lt;/p>
&lt;p>传统的文档文件通常通过具有一致外观和结构的文档系统（例如 Javadoc 或 Pydoc）来呈现。但是，文档中包含的内容类型因 API 而异。[46]&lt;/p>
&lt;p>为了清楚起见，API 文档可能包括对 API 中的类和方法的描述以及“典型的使用场景，代码段，设计原理，性能讨论和合同”，但是 API 服务本身的实现细节通常是省略。&lt;/p>
&lt;p>该文档还涵盖了如何使用 API 的限制和限制。例如，对于一个 API 函数文档可以注意到，它的参数不能为 null，该函数本身没有线程安全的，[47]因为 API 文档往往是全面的，它是作家保持更新文档和挑战用户仔细阅读它，可能会产生错误。[39]&lt;/p>
&lt;p>API 文档可以使用 Java 注释之类的元数据信息来丰富。编译器，工具和_运行时_环境可以使用此元数据来实现自定义行为或自定义处理。[48]&lt;/p>
&lt;p>可以以数据驱动的方式生成 API 文档。通过观察使用给定 API 的许多程序，可以推断出典型用法以及所需的合同和指令。[49]然后，可以使用模板从挖掘的数据生成自然语言。&lt;/p></description></item><item><title>Docs: API Server</title><link>https://desistdaydream.github.io/docs/10.%E4%BA%91%E5%8E%9F%E7%94%9F/2.3.Kubernetes-%E5%AE%B9%E5%99%A8%E7%BC%96%E6%8E%92%E7%B3%BB%E7%BB%9F/1.API-Resource-%E4%B8%8E-Object/API-Server/API-Server/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/10.%E4%BA%91%E5%8E%9F%E7%94%9F/2.3.Kubernetes-%E5%AE%B9%E5%99%A8%E7%BC%96%E6%8E%92%E7%B3%BB%E7%BB%9F/1.API-Resource-%E4%B8%8E-Object/API-Server/API-Server/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://kubernetes.io/docs/concepts/overview/components/#kube-apiserver">官方文档，概念-概述-Kubernetes 组件-kube-apiserver&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://kubernetes.io/docs/reference/command-line-tools-reference/kube-apiserver/">官方文档，参考-通用组件-kube-apiserver&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>&lt;strong>API Server 是实现 kubernetes API 的应用程序，它是 Kubernetes 控制平面的一个组件，用以对外暴露 Kubernetes API&lt;/strong>。Kubernetes API Server 验证和配置 API 对象的数据，包括 pod、service、replicationcontroller 等。 API Server 为 REST 操作提供服务，并为集群的共享状态提供前端，所有其他组件通过该前端进行交互。&lt;/p>
&lt;p>如果是通过 kubeadm 安装的 k8s 集群，那么 API Server 的表现形式就是一个名为 &lt;strong>kube-apiserver 的静态 pod&lt;/strong>。kube-apiserver 可以水平扩展，i.e.部署多个 kube-apiserver 以实现高可用，应对高并发请求，到达 kube-apiserver 的流量可以在这些实例之间平衡。&lt;/p>
&lt;p>API Server 启动后，默认监听在 6443 端口(http 默认监听在 8080 上)。API Server 是 Kubernetes 集群的前端接口 ，各种客户端工具（CLI 或 UI）以及 Kubernetes 其他组件可以通过它管理集群的各种资源。kubectl 就是 API Server 的客户端程序，实现对 k8s 各种资源的增删改查的功能。各个 node 节点的 kubelet 也通过 master 节点的 API Server 来上报本节点的 Pod 状态。&lt;/p>
&lt;ul>
&lt;li>提供集群管理的 REST 风格 API 接口，包括认证授权、数据校验以及集群状态变更等&lt;/li>
&lt;li>提供其他模块之间的数据交互和通信的枢纽（其他模块通过 API Server 查询或修改数据，只有 API Server 才可以直接操作 etcd）&lt;/li>
&lt;/ul>
&lt;h1 id="api-server-的访问方式">API Server 的访问方式&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://kubernetes.io/docs/tasks/administer-cluster/access-cluster-api/">官方文档，任务-管理集群-使用 Kubernetes API 访问集群&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>注意：&lt;/p>
&lt;ol>
&lt;li>API Server 默认是安全的，在访问时，应使用 https 协议来操作。&lt;/li>
&lt;li>参考 [K8S 认证与授权介绍](7.API%20 访问控制.md 访问控制.md) 文章，学习在访问 API Server 时所遇到的验证问题。&lt;/li>
&lt;/ol>
&lt;h2 id="使用-kubectl-访问-api">使用 kubectl 访问 API&lt;/h2>
&lt;p>现阶段有 kubectl 工具可以实现对 API Server 的访问&lt;/p>
&lt;p>使用 kubectl get &amp;ndash;raw / 命令让 kubectl 不再输出标准格式的数据，而是直接向 api server 请求原始数据&lt;/p>
&lt;h2 id="直接访问-rest-apieg使用-curl浏览器-等方式访问-api">直接访问 REST API(e.g.使用 curl、浏览器 等方式访问 API)&lt;/h2>
&lt;p>kubectl 处理对 API 服务器的定位和身份验证。如果你想通过 http 客户端（如 curl 或 wget，或浏览器）直接访问 REST API，你可以通过多种方式对 API 服务器进行定位和身份验证：&lt;/p>
&lt;ol>
&lt;li>以代理模式运行 kubectl(推荐)。 推荐使用此方法，因为它用存储的 apiserver 位置并使用自签名证书验证 API 服务器的标识。 使用这种方法无法进行中间人（MITM）攻击。&lt;/li>
&lt;li>另外，你可以直接为 HTTP 客户端提供位置和身份认证。 这适用于被代理混淆的客户端代码。 为防止中间人攻击，你需要将根证书导入浏览器。&lt;/li>
&lt;/ol>
&lt;p>比如 curl &amp;ndash;request DELETE -cacert ${CAPATH} -H &amp;ldquo;Authorization: Bearer ${TOKEN}&amp;rdquo; https://${IP}:6443/api/v1/namespaces/monitoring/pods/prometheus-k8s-0 -k 这样一个请求就可以将集群内 monitoring 空间下的 prometheus-k8s-0 这个 pod 删除&lt;/p>
&lt;h3 id="获取认证所需信息">获取认证所需信息&lt;/h3>
&lt;p>&lt;strong>方法一：使用 kubectl 的配置文件中的证书与私钥&lt;/strong>
想要访问 https 下的内容，首先需要准备证书与私钥或者 ca 与 token 等等。&lt;/p>
&lt;ol>
&lt;li>首先获取 kubeclt 工具配置文件中的证书与私钥
&lt;ol>
&lt;li>cat /etc/kubernetes/admin.conf | grep client-certificate-data | awk &amp;lsquo;{print $2}&amp;rsquo; | base64 -d &amp;gt; /root/certs/admin.crt&lt;/li>
&lt;li>cat /etc/kubernetes/admin.conf | grep client-key-data | awk &amp;lsquo;{print $2}&amp;rsquo; | base64 -d &amp;gt; /root/certs/admin.key&lt;/li>
&lt;/ol>
&lt;/li>
&lt;li>确定 CA 文件位置(文件一般在 /etc/kubernetes/pki/ca.crt)
&lt;ol>
&lt;li>CAPATH=/etc/kubernetes/pki/ca.crt&lt;/li>
&lt;/ol>
&lt;/li>
&lt;li>确定要访问组件的的 IP
&lt;ol>
&lt;li>IP=172.38.40.212&lt;/li>
&lt;/ol>
&lt;/li>
&lt;/ol>
&lt;p>&lt;strong>方法二：使用拥有最高权限 ServiceAccount 的 Token 访问 https&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>(可选)创建一个专门存放 SA 的名称空间
&lt;ul>
&lt;li>kubectl create namespace user-sa-manage&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>创建一个 ServiceAccount
&lt;ul>
&lt;li>kubectl create -n user-sa-manage serviceaccount test-admin&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>将该 ServiceAccount 绑定到 cluster-admin 这个 clusterrole，以赋予最高权限
&lt;ul>
&lt;li>kubectl create clusterrolebinding test-admin &amp;ndash;clusterrole=cluster-admin &amp;ndash;serviceaccount=user-sa-manage:test-admin&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>将该 ServiceAccount 的 Token 的值注册到变量中
&lt;ul>
&lt;li>TOKEN=$(kubectl get -n user-sa-manage secrets -o jsonpath=&amp;quot;{.items[?(@.metadata.annotations[&amp;lsquo;kubernetes.io/service-account.name&amp;rsquo;]==&amp;lsquo;test-admin&amp;rsquo;)].data.token}&amp;quot;|base64 -d)&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>确定 CA 文件位置(文件一般在 /etc/kubernetes/pki/ca.crt)
&lt;ul>
&lt;li>CAPATH=/etc/kubernetes/pki/ca.crt&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>确定要访问组件的的 IP
&lt;ul>
&lt;li>IP=172.38.40.212&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>使用令牌玩转 API
&lt;ul>
&lt;li>curl -k $IP/api -H &amp;ldquo;Authorization: Bearer $TOKEN&amp;rdquo;&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>Note：也可以从一个具有权限的 ServiceAccount 下的 secret 获取，可以使用现成的，也可以手动创建。比如下面用 promtheus 自带的 token。&lt;/p>
&lt;ol>
&lt;li>如果权限不足，那么访问的时候会报错，比如权限不够，或者认证不通过等等。报错信息有如下几种
&lt;ol>
&lt;li>no kind is registered for the type v1.Status in scheme &amp;ldquo;k8s.io/kubernetes/pkg/api/legacyscheme/scheme.go:30&amp;rdquo;&lt;/li>
&lt;li>Unauthorized&lt;/li>
&lt;/ol>
&lt;/li>
&lt;li>TOKEN=$(kubectl get secrets -n monitoring prometheus-k8s-token-q5hm4 &amp;ndash;template={{.data.token}} | base64 -d)&lt;/li>
&lt;/ol>
&lt;p>&lt;strong>方法三：官方推荐，类似方法二&lt;/strong>
官方文档：&lt;a href="https://kubernetes.io/docs/tasks/administer-cluster/access-cluster-api/">https://kubernetes.io/docs/tasks/administer-cluster/access-cluster-api/&lt;/a>&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># 查看所有的集群，因为你的 .kubeconfig 文件中可能包含多个上下文&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>kubectl config view -o jsonpath&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#39;{&amp;#34;Cluster name\tServer\n&amp;#34;}{range .clusters[*]}{.name}{&amp;#34;\t&amp;#34;}{.cluster.server}{&amp;#34;\n&amp;#34;}{end}&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># 从上述命令输出中选择你要与之交互的集群的名称&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>export CLUSTER_NAME&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;some_server_name&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># 指向引用该集群名称的 API 服务器&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>APISERVER&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#66d9ef">$(&lt;/span>kubectl config view -o jsonpath&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;{.clusters[?(@.name==\&amp;#34;&lt;/span>&lt;span style="color:#e6db74">${&lt;/span>CLUSTER_NAME&lt;span style="color:#e6db74">}&lt;/span>&lt;span style="color:#e6db74">\&amp;#34;)].cluster.server}&amp;#34;&lt;/span>&lt;span style="color:#66d9ef">)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># 获得令牌&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>TOKEN&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#66d9ef">$(&lt;/span>kubectl get secrets -o jsonpath&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;{.items[?(@.metadata.annotations[&amp;#39;kubernetes\.io/service-account\.name&amp;#39;]==&amp;#39;default&amp;#39;)].data.token}&amp;#34;&lt;/span>|base64 -d&lt;span style="color:#66d9ef">)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># 使用令牌玩转 API&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>curl -X GET $APISERVER/api --header &lt;span style="color:#e6db74">&amp;#34;Authorization: Bearer &lt;/span>$TOKEN&lt;span style="color:#e6db74">&amp;#34;&lt;/span> --insecure
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="访问-api-server">访问 API Server&lt;/h3>
&lt;ol>
&lt;li>执行访问 https 前准备方法一
&lt;ol>
&lt;li>通过证书与私钥访问
&lt;ol>
&lt;li>curl &amp;ndash;cacert ${CAPATH} &amp;ndash;cert /root/certs/admin.crt &amp;ndash;key /root/certs/admin.key https://${IP}:6443/&lt;/li>
&lt;/ol>
&lt;/li>
&lt;/ol>
&lt;/li>
&lt;li>执行访问 https 前准备方法二
&lt;ol>
&lt;li>通过 https 的方式访问 API
&lt;ol>
&lt;li>curl &amp;ndash;cacert ${CAPATH} -H &amp;ldquo;Authorization: Bearer ${TOKEN}&amp;rdquo; https://${IP}:6443/&lt;/li>
&lt;/ol>
&lt;/li>
&lt;/ol>
&lt;/li>
&lt;li>kubeclt
&lt;ol>
&lt;li>kubectl get &amp;ndash;raw / # 让 kubectl 不再输出标准格式的数据，而是直接向 api server 请求原始数据&lt;/li>
&lt;/ol>
&lt;/li>
&lt;li>kubectl proxy，一般监听在 6443 端口的 api server 使用该方式，监听在 8080 上的为 http，可直接访问
&lt;ol>
&lt;li>kubectl proxy &amp;ndash;port=8080 &amp;ndash;accept-hosts=&amp;rsquo;^localhost$,^127.0.0.1$,^[::1]$,10.10.100.151&amp;rsquo; &amp;ndash;address=&amp;lsquo;0.0.0.0&amp;rsquo; # 在本地 8080 端口上启动 API Server 的一个代理网关，以便使用 curl 直接访问 api server 并使用命令 curl localhost:8080/获取数据
&lt;ol>
&lt;li>直接访问本地 8080 端口，即可通过 API Server 获取集群所有数据&lt;/li>
&lt;/ol>
&lt;/li>
&lt;/ol>
&lt;/li>
&lt;/ol>
&lt;h2 id="编程方式访问-api">编程方式访问 API&lt;/h2>
&lt;p>Kubernetes 官方支持  &lt;a href="https://kubernetes.io/zh/docs/tasks/administer-cluster/access-cluster-api/#go-client">Go&lt;/a>、&lt;a href="https://kubernetes.io/zh/docs/tasks/administer-cluster/access-cluster-api/#python-client">Python&lt;/a>、&lt;a href="https://kubernetes.io/zh/docs/tasks/administer-cluster/access-cluster-api/#java-client">Java&lt;/a>、 &lt;a href="https://kubernetes.io/zh/docs/tasks/administer-cluster/access-cluster-api/#dotnet-client">dotnet&lt;/a>、&lt;a href="https://kubernetes.io/zh/docs/tasks/administer-cluster/access-cluster-api/#javascript-client">Javascript&lt;/a>  和  &lt;a href="https://kubernetes.io/zh/docs/tasks/administer-cluster/access-cluster-api/#haskell-client">Haskell&lt;/a>  语言的客户端库。还有一些其他客户端库由对应作者而非 Kubernetes 团队提供并维护。 参考&lt;a href="https://kubernetes.io/zh/docs/reference/using-api/client-libraries/">客户端库&lt;/a>了解如何使用其他语言 来访问 API 以及如何执行身份认证。&lt;/p>
&lt;h3 id="go-客户端介绍">Go 客户端介绍&lt;/h3>
&lt;blockquote>
&lt;p>参考：官方文档：&lt;a href="https://github.com/kubernetes/client-go/#compatibility-matrix">https://github.com/kubernetes/client-go/#compatibility-matrix&lt;/a>
详见 &lt;a href="https://www.yuque.com/go/doc/33161293">Client Libraries&lt;/a>&lt;/p>
&lt;/blockquote>
&lt;p>版本控制策略：k8s 版本 1.18.8 对应 client-go 版本 0.18.8，其他版本以此类推。&lt;/p>
&lt;p>使用前注意事项：
使用 client-go 之前，需要手动获取对应版本的的 client-go 库。根据版本控制策略，使用如下命令进行初始化&lt;/p>
&lt;pre>&lt;code>go mod init client-go-test
go get k8s.io/client-go@kubernetes-1.19.2
&lt;/code>&lt;/pre>
&lt;p>这是一个使用 client-go 访问 API 的基本示例&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">package&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">import&lt;/span> (
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#34;context&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#34;fmt&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">v1&lt;/span> &lt;span style="color:#e6db74">&amp;#34;k8s.io/apimachinery/pkg/apis/meta/v1&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#34;k8s.io/client-go/kubernetes&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#34;k8s.io/client-go/tools/clientcmd&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">func&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 根据指定的 kubeconfig 创建一个用于连接集群的配置，/root/.kube/config 为 kubectl 命令所用的 config 文件
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#a6e22e">config&lt;/span>, &lt;span style="color:#a6e22e">_&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">clientcmd&lt;/span>.&lt;span style="color:#a6e22e">BuildConfigFromFlags&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;&amp;#34;&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;/root/.kube/config&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 根据 BuildConfigFromFlags 创建的配置，返回一个可以连接集群的指针
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#a6e22e">clientset&lt;/span>, &lt;span style="color:#a6e22e">_&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">kubernetes&lt;/span>.&lt;span style="color:#a6e22e">NewForConfig&lt;/span>(&lt;span style="color:#a6e22e">config&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 根据 NewForConfig 所创建的连接集群的指针，来访问 API，并对集群进行操作
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#a6e22e">pods&lt;/span>, &lt;span style="color:#a6e22e">_&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">clientset&lt;/span>.&lt;span style="color:#a6e22e">CoreV1&lt;/span>().&lt;span style="color:#a6e22e">Pods&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;&amp;#34;&lt;/span>).&lt;span style="color:#a6e22e">List&lt;/span>(&lt;span style="color:#a6e22e">context&lt;/span>.&lt;span style="color:#a6e22e">TODO&lt;/span>(), &lt;span style="color:#a6e22e">v1&lt;/span>.&lt;span style="color:#a6e22e">ListOptions&lt;/span>{})
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">fmt&lt;/span>.&lt;span style="color:#a6e22e">Printf&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;There are %d pods in the cluster\n&amp;#34;&lt;/span>, len(&lt;span style="color:#a6e22e">pods&lt;/span>.&lt;span style="color:#a6e22e">Items&lt;/span>))
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="从-pod-中访问-api">从 Pod 中访问 API&lt;/h2>
&lt;p>从 Pod 内部访问 API 时，定位 API 服务器和向服务器认证身份的操作 与上面描述的外部客户场景不同。&lt;/p>
&lt;p>从 Pod 使用 Kubernetes API 的最简单的方法就是使用官方的 客户端库。 这些库可以自动发现 API 服务器并进行身份验证。&lt;/p>
&lt;h3 id="使用官方客户端库">使用官方客户端库&lt;/h3>
&lt;p>从一个 Pod 内部连接到 Kubernetes API 的推荐方式为：&lt;/p>
&lt;ul>
&lt;li>对于 Go 语言客户端，使用官方的 Go 客户端库。 函数 &lt;code>rest.InClusterConfig()&lt;/code> 自动处理 API 主机发现和身份认证。 参见这里的一个例子。&lt;/li>
&lt;li>对于 Python 客户端，使用官方的 Python 客户端库。 函数 &lt;code>config.load_incluster_config()&lt;/code> 自动处理 API 主机的发现和身份认证。 参见这里的一个例子。&lt;/li>
&lt;li>还有一些其他可用的客户端库，请参阅客户端库页面。&lt;/li>
&lt;/ul>
&lt;p>在以上场景中，客户端库都使用 Pod 的服务账号凭据来与 API 服务器安全地通信。&lt;/p>
&lt;h3 id="直接访问-rest-api">直接访问 REST API&lt;/h3>
&lt;p>在运行在 Pod 中时，可以通过 &lt;code>default&lt;/code> 命名空间中的名为 &lt;code>kubernetes&lt;/code> 的服务访问 Kubernetes API 服务器。也就是说，Pod 可以使用 &lt;code>kubernetes.default.svc&lt;/code> 主机名 来查询 API 服务器。官方客户端库自动完成这个工作。&lt;/p>
&lt;p>向 API 服务器进行身份认证的推荐做法是使用 &lt;a href="https://kubernetes.io/zh/docs/tasks/configure-pod-container/configure-service-account/">服务账号&lt;/a> 凭据。 默认情况下，每个 Pod 与一个服务账号关联，该服务账户的凭证（令牌）放置在此 Pod 中 每个容器的文件系统树中的 &lt;code>/var/run/secrets/kubernetes.io/serviceaccount/token&lt;/code> 处。&lt;/p>
&lt;p>如果由证书包可用，则凭证包被放入每个容器的文件系统树中的 &lt;code>/var/run/secrets/kubernetes.io/serviceaccount/ca.crt&lt;/code> 处， 且将被用于验证 API 服务器的服务证书。&lt;/p>
&lt;p>最后，用于命名空间域 API 操作的默认命名空间放置在每个容器中的 &lt;code>/var/run/secrets/kubernetes.io/serviceaccount/namespace&lt;/code> 文件中。&lt;/p>
&lt;h3 id="使用-kubectl-proxy">使用 kubectl proxy&lt;/h3>
&lt;p>如果你希望不实用官方客户端库就完成 API 查询，可以将 &lt;code>kubectl proxy&lt;/code> 作为 command 在 Pod 启动一个边车（Sidecar）容器。&lt;/p>
&lt;p>这样，&lt;code>kubectl proxy&lt;/code> 自动完成对 API 的身份认证，并将其暴露到 Pod 的 &lt;code>localhost&lt;/code> 接口，从而 Pod 中的其他容器可以 直接使用 API。&lt;/p>
&lt;h3 id="不使用代理">不使用代理&lt;/h3>
&lt;p>通过将认证令牌直接发送到 API 服务器，也可以避免运行 kubectl proxy 命令。 内部的证书机制能够为链接提供保护。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># 指向内部 API 服务器的主机名&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>APISERVER&lt;span style="color:#f92672">=&lt;/span>https://kubernetes.default.svc
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># 服务账号令牌的路径&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>SERVICEACCOUNT&lt;span style="color:#f92672">=&lt;/span>/var/run/secrets/kubernetes.io/serviceaccount
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># 读取 Pod 的名字空间&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>NAMESPACE&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#66d9ef">$(&lt;/span>cat &lt;span style="color:#e6db74">${&lt;/span>SERVICEACCOUNT&lt;span style="color:#e6db74">}&lt;/span>/namespace&lt;span style="color:#66d9ef">)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># 读取服务账号的持有者令牌&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>TOKEN&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#66d9ef">$(&lt;/span>cat &lt;span style="color:#e6db74">${&lt;/span>SERVICEACCOUNT&lt;span style="color:#e6db74">}&lt;/span>/token&lt;span style="color:#66d9ef">)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># 引用内部整数机构（CA）&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>CACERT&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">${&lt;/span>SERVICEACCOUNT&lt;span style="color:#e6db74">}&lt;/span>/ca.crt
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># 使用令牌访问 API&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>curl --cacert &lt;span style="color:#e6db74">${&lt;/span>CACERT&lt;span style="color:#e6db74">}&lt;/span> --header &lt;span style="color:#e6db74">&amp;#34;Authorization: Bearer &lt;/span>&lt;span style="color:#e6db74">${&lt;/span>TOKEN&lt;span style="color:#e6db74">}&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span> -X GET &lt;span style="color:#e6db74">${&lt;/span>APISERVER&lt;span style="color:#e6db74">}&lt;/span>/api
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>输出类似于：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-json" data-lang="json">&lt;span style="display:flex;">&lt;span>{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;kind&amp;#34;&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;APIVersions&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;versions&amp;#34;&lt;/span>: [&lt;span style="color:#e6db74">&amp;#34;v1&amp;#34;&lt;/span>],
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;serverAddressByClientCIDRs&amp;#34;&lt;/span>: [
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;clientCIDR&amp;#34;&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;0.0.0.0/0&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;serverAddress&amp;#34;&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;10.0.1.149:443&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h1 id="api-server-健康检查点">API Server 健康检查点&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;a href="https://kubernetes.io/docs/reference/using-api/health-checks/">官方文档&lt;/a>&lt;/p>
&lt;/blockquote>
&lt;p>Kubernetes API 服务器 提供 API 端点以指示 API 服务器的当前状态。 本文描述了这些 API 端点，并说明如何使用。&lt;/p>
&lt;h3 id="api-健康检查点">API 健康检查点&lt;/h3>
&lt;p>Kubernetes API 服务器提供 3 个 API 端点（&lt;code>healthz&lt;/code>、&lt;code>livez&lt;/code> 和 &lt;code>readyz&lt;/code>）来表明 API 服务器的当前状态。 &lt;code>healthz&lt;/code> 端点已被弃用（自 Kubernetes v1.16 起），你应该使用更为明确的 &lt;code>livez&lt;/code> 和 &lt;code>readyz&lt;/code> 端点。 &lt;code>livez&lt;/code> 端点可与 &lt;code>--livez-grace-period&lt;/code> 标志一起使用，来指定启动持续时间。 为了正常关机，你可以使用 &lt;code>/readyz&lt;/code> 端点并指定 &lt;code>--shutdown-delay-duration&lt;/code> 标志。 检查 API 服务器的 &lt;code>health&lt;/code>/&lt;code>livez&lt;/code>/&lt;code>readyz&lt;/code> 端点的机器应依赖于 HTTP 状态代码。 状态码 &lt;code>200&lt;/code> 表示 API 服务器是 &lt;code>healthy&lt;/code>、&lt;code>live&lt;/code> 还是 &lt;code>ready&lt;/code>，具体取决于所调用的端点。 以下更详细的选项供操作人员使用，用来调试其集群或专门调试 API 服务器的状态。&lt;/p>
&lt;p>以下示例将显示如何与运行状况 API 端点进行交互。&lt;/p>
&lt;p>对于所有端点，都可以使用 &lt;code>verbose&lt;/code> 参数来打印检查项以及检查状态。 这对于操作人员调试 API 服务器的当前状态很有用，这些不打算给机器使用：&lt;/p>
&lt;pre>&lt;code>curl -k https://localhost:6443/livez?verbose
&lt;/code>&lt;/pre>
&lt;p>或从具有身份验证的远程主机：&lt;/p>
&lt;pre>&lt;code>kubectl get --raw='/readyz?verbose'
&lt;/code>&lt;/pre>
&lt;p>输出将如下所示：&lt;/p>
&lt;pre>&lt;code>[+]ping ok
[+]log ok
[+]etcd ok
[+]poststarthook/start-kube-apiserver-admission-initializer ok
[+]poststarthook/generic-apiserver-start-informers ok
[+]poststarthook/start-apiextensions-informers ok
[+]poststarthook/start-apiextensions-controllers ok
[+]poststarthook/crd-informer-synced ok
[+]poststarthook/bootstrap-controller ok
[+]poststarthook/rbac/bootstrap-roles ok
[+]poststarthook/scheduling/bootstrap-system-priority-classes ok
[+]poststarthook/start-cluster-authentication-info-controller ok
[+]poststarthook/start-kube-aggregator-informers ok
[+]poststarthook/apiservice-registration-controller ok
[+]poststarthook/apiservice-status-available-controller ok
[+]poststarthook/kube-apiserver-autoregistration ok
[+]autoregister-completion ok
[+]poststarthook/apiservice-openapi-controller ok
healthz check passed
&lt;/code>&lt;/pre>
&lt;p>Kubernetes API 服务器也支持排除特定的检查项。 查询参数也可以像以下示例一样进行组合：&lt;/p>
&lt;pre>&lt;code>curl -k 'https://localhost:6443/readyz?verbose&amp;amp;exclude=etcd'
&lt;/code>&lt;/pre>
&lt;p>输出显示排除了 &lt;code>etcd&lt;/code> 检查：&lt;/p>
&lt;pre>&lt;code>[+]ping ok
[+]log ok
[+]etcd excluded: ok
[+]poststarthook/start-kube-apiserver-admission-initializer ok
[+]poststarthook/generic-apiserver-start-informers ok
[+]poststarthook/start-apiextensions-informers ok
[+]poststarthook/start-apiextensions-controllers ok
[+]poststarthook/crd-informer-synced ok
[+]poststarthook/bootstrap-controller ok
[+]poststarthook/rbac/bootstrap-roles ok
[+]poststarthook/scheduling/bootstrap-system-priority-classes ok
[+]poststarthook/start-cluster-authentication-info-controller ok
[+]poststarthook/start-kube-aggregator-informers ok
[+]poststarthook/apiservice-registration-controller ok
[+]poststarthook/apiservice-status-available-controller ok
[+]poststarthook/kube-apiserver-autoregistration ok
[+]autoregister-completion ok
[+]poststarthook/apiservice-openapi-controller ok
[+]shutdown ok
healthz check passed
&lt;/code>&lt;/pre>
&lt;h3 id="独立健康检查">独立健康检查&lt;/h3>
&lt;p>&lt;strong>FEATURE STATE:&lt;/strong> &lt;code>Kubernetes v1.19 [alpha]&lt;/code>每个单独的健康检查都会公开一个 http 端点，并且可以单独检查。 单个运行状况检查的模式为 &lt;code>/livez/&amp;lt;healthcheck-name&amp;gt;&lt;/code>，其中 &lt;code>livez&lt;/code> 和 &lt;code>readyz&lt;/code> 表明你要检查的是 API 服务器是否存活或就绪。 &lt;code>&amp;lt;healthcheck-name&amp;gt;&lt;/code> 的路径可以通过上面的 &lt;code>verbose&lt;/code> 参数发现 ，并采用 &lt;code>[+]&lt;/code> 和 &lt;code>ok&lt;/code> 之间的路径。 这些单独的健康检查不应由机器使用，但对于操作人员调试系统而言，是有帮助的：&lt;/p>
&lt;pre>&lt;code>curl -k https://localhost:6443/livez/etcd
&lt;/code>&lt;/pre>
&lt;h1 id="api-server-与-etcd-的交互方式">API Server 与 Etcd 的交互方式&lt;/h1>
&lt;p>数据通过 API Server 时，一般是进行序列化后保存到 etcd 中的，可以使用参数 &amp;ndash;etcd-prefix 来指定数据保存在 etcd 中后的地址前缀，默认为 &lt;code>/registry&lt;/code>&lt;/p>
&lt;p>一般情况，保存到 etcd 中后，会省略 Group 与 Version，直接使用 Resource 来作为 etcd 中的路径。比如：URI 为 /api/v1/namespaces/kube-system/pods/kube-apiserver-master1 的 pod 资源，在 etcd 中的存储路径为 /registry/pods/kube-system/kube-apiserver-master1。&lt;/p>
&lt;p>而序列化的方式可以通过 &amp;ndash;storage-media-type 来指定，默认为 protobuf 。使用这种方式将数据序列化之后，得出来的将会有很多乱码，详见 &lt;a href="https://www.yuque.com/go/doc/33166015">Etcd 数据探秘章节&lt;/a> 中的说明&lt;/p>
&lt;h1 id="kube-apiserver-manifests-示例">kube-apiserver Manifests 示例&lt;/h1>
&lt;pre>&lt;code>apiVersion: v1
kind: Pod
metadata:
annotations:
kubeadm.kubernetes.io/kube-apiserver.advertise-address.endpoint: 172.19.42.231:6443
creationTimestamp: null
labels:
component: kube-apiserver
tier: control-plane
name: kube-apiserver
namespace: kube-system
spec:
containers:
- command:
- kube-apiserver
- --advertise-address=172.19.42.231
- --allow-privileged=true
- --authorization-mode=Node,RBAC
- --client-ca-file=/etc/kubernetes/pki/ca.crt
- --enable-admission-plugins=NodeRestriction
- --enable-bootstrap-token-auth=true
- --etcd-cafile=/etc/kubernetes/pki/etcd/ca.crt
- --etcd-certfile=/etc/kubernetes/pki/apiserver-etcd-client.crt
- --etcd-keyfile=/etc/kubernetes/pki/apiserver-etcd-client.key
- --etcd-servers=https://127.0.0.1:2379
- --insecure-port=0
- --kubelet-client-certificate=/etc/kubernetes/pki/apiserver-kubelet-client.crt
- --kubelet-client-key=/etc/kubernetes/pki/apiserver-kubelet-client.key
- --kubelet-preferred-address-types=InternalIP,ExternalIP,Hostname
- --proxy-client-cert-file=/etc/kubernetes/pki/front-proxy-client.crt
- --proxy-client-key-file=/etc/kubernetes/pki/front-proxy-client.key
- --requestheader-allowed-names=front-proxy-client
- --requestheader-client-ca-file=/etc/kubernetes/pki/front-proxy-ca.crt
- --requestheader-extra-headers-prefix=X-Remote-Extra-
- --requestheader-group-headers=X-Remote-Group
- --requestheader-username-headers=X-Remote-User
- --secure-port=6443
- --service-account-key-file=/etc/kubernetes/pki/sa.pub
- --service-cluster-ip-range=10.96.0.0/12
- --service-node-port-range=30000-60000
- --tls-cert-file=/etc/kubernetes/pki/apiserver.crt
- --tls-private-key-file=/etc/kubernetes/pki/apiserver.key
image: registry.aliyuncs.com/k8sxio/kube-apiserver:v1.19.2
imagePullPolicy: IfNotPresent
livenessProbe:
failureThreshold: 8
httpGet:
host: 172.19.42.231
path: /livez
port: 6443
scheme: HTTPS
initialDelaySeconds: 10
periodSeconds: 10
timeoutSeconds: 15
name: kube-apiserver
readinessProbe:
failureThreshold: 3
httpGet:
host: 172.19.42.231
path: /readyz
port: 6443
scheme: HTTPS
periodSeconds: 1
timeoutSeconds: 15
resources:
requests:
cpu: 250m
startupProbe:
failureThreshold: 24
httpGet:
host: 172.19.42.231
path: /livez
port: 6443
scheme: HTTPS
initialDelaySeconds: 10
periodSeconds: 10
timeoutSeconds: 15
volumeMounts:
- mountPath: /etc/ssl/certs
name: ca-certs
readOnly: true
- mountPath: /etc/pki
name: etc-pki
readOnly: true
- mountPath: /etc/localtime
name: host-time
readOnly: true
- mountPath: /etc/kubernetes/pki
name: k8s-certs
readOnly: true
hostNetwork: true
priorityClassName: system-node-critical
volumes:
- hostPath:
path: /etc/ssl/certs
type: DirectoryOrCreate
name: ca-certs
- hostPath:
path: /etc/pki
type: DirectoryOrCreate
name: etc-pki
- hostPath:
path: /etc/localtime
type: &amp;quot;&amp;quot;
name: host-time
- hostPath:
path: /etc/kubernetes/pki
type: DirectoryOrCreate
name: k8s-certs
&lt;/code>&lt;/pre></description></item><item><title>Docs: API 参考</title><link>https://desistdaydream.github.io/docs/10.%E4%BA%91%E5%8E%9F%E7%94%9F/2.3.Kubernetes-%E5%AE%B9%E5%99%A8%E7%BC%96%E6%8E%92%E7%B3%BB%E7%BB%9F/1.API-Resource-%E4%B8%8E-Object/API-%E5%8F%82%E8%80%83/API-%E5%8F%82%E8%80%83/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/10.%E4%BA%91%E5%8E%9F%E7%94%9F/2.3.Kubernetes-%E5%AE%B9%E5%99%A8%E7%BC%96%E6%8E%92%E7%B3%BB%E7%BB%9F/1.API-Resource-%E4%B8%8E-Object/API-%E5%8F%82%E8%80%83/API-%E5%8F%82%E8%80%83/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.23">官方文档，参考-API 概述-API&lt;/a>(这里是通过单一页面显示 API 资源各字段详解)
&lt;ul>
&lt;li>链接里是 1.23 的，想查看其他版本 API，改变 URL 中的版本即可。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;a href="https://kubernetes.io/docs/reference/kubernetes-api/">官方文档，参考-KubernetesAPI&lt;/a>(这里是通过多级页面显示 API 资源各字段详解)
&lt;ul>
&lt;li>这些连接的内容，其实是 &lt;code>kubectl explain&lt;/code> 命令的内容显示在浏览器中了。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;a href="https://github.com/kubernetes/kubernetes/blob/master/api/openapi-spec/swagger.json">OpeaAPI 格式文档&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>在 &lt;a href="https://www.yuque.com/go/doc/33168662">Kubernetes API&lt;/a> 章节，已经可以看到单一页面的详解中对 API 的分类，在本笔记后面的部分对各资源 Manifest 详解中，其实已经描述了 API 中各个字段的含义。所以本篇文章不会详解每个 API，而是记录一下如何通过 Kubernetes 官网来查找 API 详解，以及如何使用官方文档查看 API 详解。&lt;/p>
&lt;p>如果笔记中记录得不够详细，&lt;code>kubectl explain&lt;/code> 命令也看着不方便，那么通过这篇文章中介绍的官方文档中的 API 详解来查看，将会更加直观。&lt;/p>
&lt;p>&lt;strong>Kubernetes API 参考中将会描述每种资源的 Manifests 中每个字段(即.YAML 中的节点)的含义。&lt;/strong>&lt;/p>
&lt;p>下面是文档中占位符说明：&lt;/p>
&lt;p>&lt;strong>[]TYPE&lt;/strong> # 表示该字段由数组组成，数组元素类型为 TYPE，比如 []STRING 格式应该就是下面这样&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-yaml" data-lang="yaml">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">args&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#ae81ff">deletecr&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - --&lt;span style="color:#ae81ff">ns&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - --&lt;span style="color:#ae81ff">name&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;strong>map[STRING]STRING&lt;/strong> # 表示多个键/值对。键 和 值 的数据类型都是 STRING。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-yaml" data-lang="yaml">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">labels&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">key1&lt;/span>: &lt;span style="color:#ae81ff">value1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">key2&lt;/span>: &lt;span style="color:#ae81ff">value2&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;strong>OBJECT&lt;/strong> # 表示复合结构的 map。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-yaml" data-lang="yaml">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">resources&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">limits&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">cpu&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;2&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">memory&lt;/span>: &lt;span style="color:#ae81ff">2Gi&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">requests&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">cpu&lt;/span>: &lt;span style="color:#ae81ff">500m&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">memory&lt;/span>: &lt;span style="color:#ae81ff">400Mi&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;strong>[]OBJECT&lt;/strong> # 表示该字段由数组组成，并且数组中的元素都是一个 OBJECT，比如格式应该像下面这样&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-yaml" data-lang="yaml">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">containers&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#f92672">args&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#ae81ff">AAA&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#ae81ff">BBB&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">name&lt;/span>: &lt;span style="color:#ae81ff">XXX&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">image&lt;/span>: &lt;span style="color:#ae81ff">XXX&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#f92672">name&lt;/span>: &lt;span style="color:#ae81ff">YYY&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">image&lt;/span>: &lt;span style="color:#ae81ff">YYY&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;strong>在每种资源的 Manifests 中，会有一些共用的部分称为 &lt;a href="https://desistdaydream.github.io/docs/10.%E4%BA%91%E5%8E%9F%E7%94%9F/2.3.Kubernetes%20%E5%AE%B9%E5%99%A8%E7%BC%96%E6%8E%92%E7%B3%BB%E7%BB%9F/1.API%20Resource%20%E4%B8%8E%20Object/API%20%E5%8F%82%E8%80%83/Common%20Definitions(%E9%80%9A%E7%94%A8%E5%AE%9A%E4%B9%89)/Common%20Definitions(%E9%80%9A%E7%94%A8%E5%AE%9A%E4%B9%89).md">Common Definitions(通用定义)&lt;/a>（也可以说是功能定义），比如常见的 &lt;a href="https://desistdaydream.github.io/docs/10.%E4%BA%91%E5%8E%9F%E7%94%9F/2.3.Kubernetes%20%E5%AE%B9%E5%99%A8%E7%BC%96%E6%8E%92%E7%B3%BB%E7%BB%9F/1.API%20Resource%20%E4%B8%8E%20Object/API%20%E5%8F%82%E8%80%83/Common%20Definitions(%E9%80%9A%E7%94%A8%E5%AE%9A%E4%B9%89)/LabelSelector.md">LabelSelector&lt;/a>，这属于资源的 Manifests 的一部分。很多组件在解析 Manifests 中的通用定义时，都会遵循相同的规则。除了通用定义以外的，都属于 K8S 的资源定义，比如定义 &lt;a href="https://desistdaydream.github.io/docs/10.%E4%BA%91%E5%8E%9F%E7%94%9F/2.3.Kubernetes%20%E5%AE%B9%E5%99%A8%E7%BC%96%E6%8E%92%E7%B3%BB%E7%BB%9F/1.API%20Resource%20%E4%B8%8E%20Object/API%20%E5%8F%82%E8%80%83/%E5%B7%A5%E4%BD%9C%E8%B4%9F%E8%BD%BD%E8%B5%84%E6%BA%90/Pod%20Manifest%20%E8%AF%A6%E8%A7%A3.md">Pod&lt;/a> 的 API 参考、定义 &lt;a href="https://desistdaydream.github.io/docs/10.%E4%BA%91%E5%8E%9F%E7%94%9F/2.3.Kubernetes%20%E5%AE%B9%E5%99%A8%E7%BC%96%E6%8E%92%E7%B3%BB%E7%BB%9F/1.API%20Resource%20%E4%B8%8E%20Object/API%20%E5%8F%82%E8%80%83/%E6%9C%8D%E5%8A%A1%E8%B5%84%E6%BA%90/Service%20Manifests%20%E8%AF%A6%E8%A7%A3.md">Service&lt;/a> 的 API 参考等等。&lt;/strong>&lt;/p>
&lt;p>这是单一页面的样子。左侧是根据对资源的分类而形成的目录，右侧是完整的页面
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/dkxdpv/1616120193938-a171af16-575d-4de6-951a-99cdca271a50.png" alt="">
这是多级页面的样子，该 API 详解是内含在官方文档中的，并且对 API 进行了细致的分类
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/dkxdpv/1616120193972-2c538ed5-7a6f-4aca-bf11-732240aa84d6.png" alt="">&lt;/p>
&lt;h2 id="kubernetes-api-删除和弃用流程">Kubernetes API 删除和弃用流程&lt;/h2>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://kubernetes.io/docs/reference/using-api/deprecation-policy/">官方文档，参考-API 概述-Kubernetes 弃用策略&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>Kubernetes 项目有一个记录良好的特性弃用策略[1]。该策略规定，只有当同一 API 的更新的、稳定的版本可用时，才可以弃用稳定的 API，并且 API 对于每个稳定性级别都有一个最短的生存期。给弃用的 API，是在未来的 Kubernetes 版本中被标记为删除的 API；它将继续运行，直到给删除（从弃用至少一年），但使用将导致显示警告。删除的 API 在当前版本中不再可用，此时你必须迁移到使用替换的 API。&lt;/p>
&lt;ul>
&lt;li>GA（Generally available，普遍可用）或稳定的 API 版本可能会被标记为弃用，但不得在 Kubernetes 的主要版本中删除。&lt;/li>
&lt;li>测试版或预发布 API 版本弃用后，必须支持 3 个版本。&lt;/li>
&lt;li>Alpha 或实验 API 版本可能会在任何版本中被删除，恕不另行通知。&lt;/li>
&lt;/ul>
&lt;p>无论某个 API 是因为某个功能从测试版升级到稳定版而被删除，还是因为该 API 没有成功，所有的删除都遵循这个弃用策略。每当删除一个 API 时，迁移选项都会在文档中提供说明。&lt;/p>
&lt;h1 id="api-分类">API 分类&lt;/h1>
&lt;ul>
&lt;li>[Workloads Resources](/docs/10.云原生/2.3.Kubernetes%20 容器编排系统/1.API、Resource(资源)、Object(对象)/API%20 参考/工作负载资源.md 参考/工作负载资源.md)(工作负载资源)&lt;/li>
&lt;li>&lt;a href="https://kubernetes.io/docs/reference/kubernetes-api/service-resources/">Services Resources&lt;/a>(服务资源)&lt;/li>
&lt;li>&lt;a href="https://kubernetes.io/docs/reference/kubernetes-api/config-and-storage-resources/">Config and Storage Resources&lt;/a>(配置与存储资源)&lt;/li>
&lt;li>&lt;a href="https://kubernetes.io/docs/reference/kubernetes-api/authentication-resources/">Authentication Resources&lt;/a>(认证资源)&lt;/li>
&lt;li>&lt;a href="https://kubernetes.io/docs/reference/kubernetes-api/authorization-resources/">Authorization Resources&lt;/a>(授权资源)&lt;/li>
&lt;li>&lt;a href="https://kubernetes.io/docs/reference/kubernetes-api/policies-resources/">Policies Resources&lt;/a>(策略资源)&lt;/li>
&lt;li>&lt;a href="https://kubernetes.io/docs/reference/kubernetes-api/extend-resources/">Extend Resources&lt;/a>(扩展资源)&lt;/li>
&lt;li>&lt;a href="https://kubernetes.io/docs/reference/kubernetes-api/cluster-resources/">Cluster Resources&lt;/a>(集群资源)&lt;/li>
&lt;li>&lt;a href="https://kubernetes.io/docs/reference/kubernetes-api/common-definitions/">Common Definitions&lt;/a>(通用定义) # 在多种资源 API 中，可以使用的 API。比如 节点选择器、meta 字段 等等&lt;/li>
&lt;li>&lt;a href="https://kubernetes.io/docs/reference/kubernetes-api/common-parameters/common-parameters/">Common Parameters&lt;/a>&lt;/li>
&lt;/ul>
&lt;h2 id="config-and-storage-resources">Config and Storage Resources&lt;/h2>
&lt;h5 id="configmaphttpskubernetesiodocsreferencekubernetes-apiconfig-and-storage-resourcesconfig-map-v1">&lt;a href="https://kubernetes.io/docs/reference/kubernetes-api/config-and-storage-resources/config-map-v1/">ConfigMap&lt;/a>&lt;/h5>
&lt;p>ConfigMap holds configuration data for pods to consume.&lt;/p>
&lt;h5 id="secrethttpskubernetesiodocsreferencekubernetes-apiconfig-and-storage-resourcessecret-v1">&lt;a href="https://kubernetes.io/docs/reference/kubernetes-api/config-and-storage-resources/secret-v1/">Secret&lt;/a>&lt;/h5>
&lt;p>Secret holds secret data of a certain type.&lt;/p>
&lt;h5 id="volumehttpskubernetesiodocsreferencekubernetes-apiconfig-and-storage-resourcesvolume">&lt;a href="https://kubernetes.io/docs/reference/kubernetes-api/config-and-storage-resources/volume/">Volume&lt;/a>&lt;/h5>
&lt;p>Volume represents a named volume in a pod that may be accessed by any container in the pod.&lt;/p>
&lt;h5 id="persistentvolumeclaimhttpskubernetesiodocsreferencekubernetes-apiconfig-and-storage-resourcespersistent-volume-claim-v1">&lt;a href="https://kubernetes.io/docs/reference/kubernetes-api/config-and-storage-resources/persistent-volume-claim-v1/">PersistentVolumeClaim&lt;/a>&lt;/h5>
&lt;p>PersistentVolumeClaim is a user&amp;rsquo;s request for and claim to a persistent volume.&lt;/p>
&lt;h5 id="persistentvolumehttpskubernetesiodocsreferencekubernetes-apiconfig-and-storage-resourcespersistent-volume-v1">&lt;a href="https://kubernetes.io/docs/reference/kubernetes-api/config-and-storage-resources/persistent-volume-v1/">PersistentVolume&lt;/a>&lt;/h5>
&lt;p>PersistentVolume (PV) is a storage resource provisioned by an administrator.&lt;/p>
&lt;h5 id="storageclasshttpskubernetesiodocsreferencekubernetes-apiconfig-and-storage-resourcesstorage-class-v1">&lt;a href="https://kubernetes.io/docs/reference/kubernetes-api/config-and-storage-resources/storage-class-v1/">StorageClass&lt;/a>&lt;/h5>
&lt;p>StorageClass describes the parameters for a class of storage for which PersistentVolumes can be dynamically provisioned.&lt;/p>
&lt;h5 id="volumeattachmenthttpskubernetesiodocsreferencekubernetes-apiconfig-and-storage-resourcesvolume-attachment-v1">&lt;a href="https://kubernetes.io/docs/reference/kubernetes-api/config-and-storage-resources/volume-attachment-v1/">VolumeAttachment&lt;/a>&lt;/h5>
&lt;p>VolumeAttachment captures the intent to attach or detach the specified volume to/from the specified node.&lt;/p>
&lt;h5 id="csidriverhttpskubernetesiodocsreferencekubernetes-apiconfig-and-storage-resourcescsi-driver-v1">&lt;a href="https://kubernetes.io/docs/reference/kubernetes-api/config-and-storage-resources/csi-driver-v1/">CSIDriver&lt;/a>&lt;/h5>
&lt;p>CSIDriver captures information about a Container Storage Interface (CSI) volume driver deployed on the cluster.&lt;/p>
&lt;h5 id="csinodehttpskubernetesiodocsreferencekubernetes-apiconfig-and-storage-resourcescsi-node-v1">&lt;a href="https://kubernetes.io/docs/reference/kubernetes-api/config-and-storage-resources/csi-node-v1/">CSINode&lt;/a>&lt;/h5>
&lt;p>CSINode holds information about all CSI drivers installed on a node.&lt;/p>
&lt;h5 id="csistoragecapacity-v1beta1httpskubernetesiodocsreferencekubernetes-apiconfig-and-storage-resourcescsi-storage-capacity-v1beta1">&lt;a href="https://kubernetes.io/docs/reference/kubernetes-api/config-and-storage-resources/csi-storage-capacity-v1beta1/">CSIStorageCapacity v1beta1&lt;/a>&lt;/h5>
&lt;p>CSIStorageCapacity stores the result of one CSI GetCapacity call.&lt;/p>
&lt;h2 id="authentication-resources">Authentication Resources&lt;/h2>
&lt;h5 id="serviceaccounthttpskubernetesiodocsreferencekubernetes-apiauthentication-resourcesservice-account-v1">&lt;a href="https://kubernetes.io/docs/reference/kubernetes-api/authentication-resources/service-account-v1/">ServiceAccount&lt;/a>&lt;/h5>
&lt;p>ServiceAccount binds together: &lt;em>a name, understood by users, and perhaps by peripheral systems, for an identity&lt;/em> a principal that can be authenticated and authorized * a set of secrets.&lt;/p>
&lt;h5 id="tokenrequesthttpskubernetesiodocsreferencekubernetes-apiauthentication-resourcestoken-request-v1">&lt;a href="https://kubernetes.io/docs/reference/kubernetes-api/authentication-resources/token-request-v1/">TokenRequest&lt;/a>&lt;/h5>
&lt;p>TokenRequest requests a token for a given service account.&lt;/p>
&lt;h5 id="tokenreviewhttpskubernetesiodocsreferencekubernetes-apiauthentication-resourcestoken-review-v1">&lt;a href="https://kubernetes.io/docs/reference/kubernetes-api/authentication-resources/token-review-v1/">TokenReview&lt;/a>&lt;/h5>
&lt;p>TokenReview attempts to authenticate a token to a known user.&lt;/p>
&lt;h5 id="certificatesigningrequesthttpskubernetesiodocsreferencekubernetes-apiauthentication-resourcescertificate-signing-request-v1">&lt;a href="https://kubernetes.io/docs/reference/kubernetes-api/authentication-resources/certificate-signing-request-v1/">CertificateSigningRequest&lt;/a>&lt;/h5>
&lt;p>CertificateSigningRequest objects provide a mechanism to obtain x509 certificates by submitting a certificate signing request, and having it asynchronously approved and issued.&lt;/p>
&lt;h2 id="authorization-resources">Authorization Resources&lt;/h2>
&lt;h5 id="localsubjectaccessreviewhttpskubernetesiodocsreferencekubernetes-apiauthorization-resourceslocal-subject-access-review-v1">&lt;a href="https://kubernetes.io/docs/reference/kubernetes-api/authorization-resources/local-subject-access-review-v1/">LocalSubjectAccessReview&lt;/a>&lt;/h5>
&lt;p>LocalSubjectAccessReview checks whether or not a user or group can perform an action in a given namespace.&lt;/p>
&lt;h5 id="selfsubjectaccessreviewhttpskubernetesiodocsreferencekubernetes-apiauthorization-resourcesself-subject-access-review-v1">&lt;a href="https://kubernetes.io/docs/reference/kubernetes-api/authorization-resources/self-subject-access-review-v1/">SelfSubjectAccessReview&lt;/a>&lt;/h5>
&lt;p>SelfSubjectAccessReview checks whether or the current user can perform an action.&lt;/p>
&lt;h5 id="selfsubjectrulesreviewhttpskubernetesiodocsreferencekubernetes-apiauthorization-resourcesself-subject-rules-review-v1">&lt;a href="https://kubernetes.io/docs/reference/kubernetes-api/authorization-resources/self-subject-rules-review-v1/">SelfSubjectRulesReview&lt;/a>&lt;/h5>
&lt;p>SelfSubjectRulesReview enumerates the set of actions the current user can perform within a namespace.&lt;/p>
&lt;h5 id="subjectaccessreviewhttpskubernetesiodocsreferencekubernetes-apiauthorization-resourcessubject-access-review-v1">&lt;a href="https://kubernetes.io/docs/reference/kubernetes-api/authorization-resources/subject-access-review-v1/">SubjectAccessReview&lt;/a>&lt;/h5>
&lt;p>SubjectAccessReview checks whether or not a user or group can perform an action.&lt;/p>
&lt;h5 id="clusterrolehttpskubernetesiodocsreferencekubernetes-apiauthorization-resourcescluster-role-v1">&lt;a href="https://kubernetes.io/docs/reference/kubernetes-api/authorization-resources/cluster-role-v1/">ClusterRole&lt;/a>&lt;/h5>
&lt;p>ClusterRole is a cluster level, logical grouping of PolicyRules that can be referenced as a unit by a RoleBinding or ClusterRoleBinding.&lt;/p>
&lt;h5 id="clusterrolebindinghttpskubernetesiodocsreferencekubernetes-apiauthorization-resourcescluster-role-binding-v1">&lt;a href="https://kubernetes.io/docs/reference/kubernetes-api/authorization-resources/cluster-role-binding-v1/">ClusterRoleBinding&lt;/a>&lt;/h5>
&lt;p>ClusterRoleBinding references a ClusterRole, but not contain it.&lt;/p>
&lt;h5 id="rolehttpskubernetesiodocsreferencekubernetes-apiauthorization-resourcesrole-v1">&lt;a href="https://kubernetes.io/docs/reference/kubernetes-api/authorization-resources/role-v1/">Role&lt;/a>&lt;/h5>
&lt;p>Role is a namespaced, logical grouping of PolicyRules that can be referenced as a unit by a RoleBinding.&lt;/p>
&lt;h5 id="rolebindinghttpskubernetesiodocsreferencekubernetes-apiauthorization-resourcesrole-binding-v1">&lt;a href="https://kubernetes.io/docs/reference/kubernetes-api/authorization-resources/role-binding-v1/">RoleBinding&lt;/a>&lt;/h5>
&lt;p>RoleBinding references a role, but does not contain it.&lt;/p>
&lt;h2 id="policies-resources">Policies Resources&lt;/h2>
&lt;h5 id="limitrangehttpskubernetesiodocsreferencekubernetes-apipolicy-resourceslimit-range-v1">&lt;a href="https://kubernetes.io/docs/reference/kubernetes-api/policy-resources/limit-range-v1/">LimitRange&lt;/a>&lt;/h5>
&lt;p>LimitRange sets resource usage limits for each kind of resource in a Namespace.&lt;/p>
&lt;h5 id="resourcequotahttpskubernetesiodocsreferencekubernetes-apipolicy-resourcesresource-quota-v1">&lt;a href="https://kubernetes.io/docs/reference/kubernetes-api/policy-resources/resource-quota-v1/">ResourceQuota&lt;/a>&lt;/h5>
&lt;p>ResourceQuota sets aggregate quota restrictions enforced per namespace.&lt;/p>
&lt;h5 id="networkpolicyhttpskubernetesiodocsreferencekubernetes-apipolicy-resourcesnetwork-policy-v1">&lt;a href="https://kubernetes.io/docs/reference/kubernetes-api/policy-resources/network-policy-v1/">NetworkPolicy&lt;/a>&lt;/h5>
&lt;p>NetworkPolicy describes what network traffic is allowed for a set of Pods.&lt;/p>
&lt;h5 id="poddisruptionbudgethttpskubernetesiodocsreferencekubernetes-apipolicy-resourcespod-disruption-budget-v1">&lt;a href="https://kubernetes.io/docs/reference/kubernetes-api/policy-resources/pod-disruption-budget-v1/">PodDisruptionBudget&lt;/a>&lt;/h5>
&lt;p>PodDisruptionBudget is an object to define the max disruption that can be caused to a collection of pods.&lt;/p>
&lt;h5 id="podsecuritypolicy-v1beta1httpskubernetesiodocsreferencekubernetes-apipolicy-resourcespod-security-policy-v1beta1">&lt;a href="https://kubernetes.io/docs/reference/kubernetes-api/policy-resources/pod-security-policy-v1beta1/">PodSecurityPolicy v1beta1&lt;/a>&lt;/h5>
&lt;p>PodSecurityPolicy governs the ability to make requests that affect the Security Context that will be applied to a pod and container.&lt;/p>
&lt;h2 id="extend-resources">Extend Resources&lt;/h2>
&lt;h5 id="customresourcedefinitionhttpskubernetesiodocsreferencekubernetes-apiextend-resourcescustom-resource-definition-v1">&lt;a href="https://kubernetes.io/docs/reference/kubernetes-api/extend-resources/custom-resource-definition-v1/">CustomResourceDefinition&lt;/a>&lt;/h5>
&lt;p>CustomResourceDefinition represents a resource that should be exposed on the API server.&lt;/p>
&lt;h5 id="mutatingwebhookconfigurationhttpskubernetesiodocsreferencekubernetes-apiextend-resourcesmutating-webhook-configuration-v1">&lt;a href="https://kubernetes.io/docs/reference/kubernetes-api/extend-resources/mutating-webhook-configuration-v1/">MutatingWebhookConfiguration&lt;/a>&lt;/h5>
&lt;p>MutatingWebhookConfiguration describes the configuration of and admission webhook that accept or reject and may change the object.&lt;/p>
&lt;h5 id="validatingwebhookconfigurationhttpskubernetesiodocsreferencekubernetes-apiextend-resourcesvalidating-webhook-configuration-v1">&lt;a href="https://kubernetes.io/docs/reference/kubernetes-api/extend-resources/validating-webhook-configuration-v1/">ValidatingWebhookConfiguration&lt;/a>&lt;/h5>
&lt;p>ValidatingWebhookConfiguration describes the configuration of and admission webhook that accept or reject and object without changing it.&lt;/p>
&lt;h2 id="cluster-resources">Cluster Resources&lt;/h2>
&lt;h5 id="nodehttpskubernetesiodocsreferencekubernetes-apicluster-resourcesnode-v1">&lt;a href="https://kubernetes.io/docs/reference/kubernetes-api/cluster-resources/node-v1/">Node&lt;/a>&lt;/h5>
&lt;p>Node is a worker node in Kubernetes.&lt;/p>
&lt;h5 id="namespacehttpskubernetesiodocsreferencekubernetes-apicluster-resourcesnamespace-v1">&lt;a href="https://kubernetes.io/docs/reference/kubernetes-api/cluster-resources/namespace-v1/">Namespace&lt;/a>&lt;/h5>
&lt;p>Namespace provides a scope for Names.&lt;/p>
&lt;h5 id="eventhttpskubernetesiodocsreferencekubernetes-apicluster-resourcesevent-v1">&lt;a href="https://kubernetes.io/docs/reference/kubernetes-api/cluster-resources/event-v1/">Event&lt;/a>&lt;/h5>
&lt;p>Event is a report of an event somewhere in the cluster.&lt;/p>
&lt;h5 id="apiservicehttpskubernetesiodocsreferencekubernetes-apicluster-resourcesapi-service-v1">&lt;a href="https://kubernetes.io/docs/reference/kubernetes-api/cluster-resources/api-service-v1/">APIService&lt;/a>&lt;/h5>
&lt;p>APIService represents a server for a particular GroupVersion.&lt;/p>
&lt;h5 id="leasehttpskubernetesiodocsreferencekubernetes-apicluster-resourceslease-v1">&lt;a href="https://kubernetes.io/docs/reference/kubernetes-api/cluster-resources/lease-v1/">Lease&lt;/a>&lt;/h5>
&lt;p>Lease defines a lease concept.&lt;/p>
&lt;h5 id="runtimeclasshttpskubernetesiodocsreferencekubernetes-apicluster-resourcesruntime-class-v1">&lt;a href="https://kubernetes.io/docs/reference/kubernetes-api/cluster-resources/runtime-class-v1/">RuntimeClass&lt;/a>&lt;/h5>
&lt;p>RuntimeClass defines a class of container runtime supported in the cluster.&lt;/p>
&lt;h5 id="flowschema-v1beta1httpskubernetesiodocsreferencekubernetes-apicluster-resourcesflow-schema-v1beta1">&lt;a href="https://kubernetes.io/docs/reference/kubernetes-api/cluster-resources/flow-schema-v1beta1/">FlowSchema v1beta1&lt;/a>&lt;/h5>
&lt;p>FlowSchema defines the schema of a group of flows.&lt;/p>
&lt;h5 id="prioritylevelconfiguration-v1beta1httpskubernetesiodocsreferencekubernetes-apicluster-resourcespriority-level-configuration-v1beta1">&lt;a href="https://kubernetes.io/docs/reference/kubernetes-api/cluster-resources/priority-level-configuration-v1beta1/">PriorityLevelConfiguration v1beta1&lt;/a>&lt;/h5>
&lt;p>PriorityLevelConfiguration represents the configuration of a priority level.&lt;/p>
&lt;h5 id="bindinghttpskubernetesiodocsreferencekubernetes-apicluster-resourcesbinding-v1">&lt;a href="https://kubernetes.io/docs/reference/kubernetes-api/cluster-resources/binding-v1/">Binding&lt;/a>&lt;/h5>
&lt;p>Binding ties one object to another; for example, a pod is bound to a node by a scheduler.&lt;/p>
&lt;h5 id="componentstatushttpskubernetesiodocsreferencekubernetes-apicluster-resourcescomponent-status-v1">&lt;a href="https://kubernetes.io/docs/reference/kubernetes-api/cluster-resources/component-status-v1/">ComponentStatus&lt;/a>&lt;/h5>
&lt;p>ComponentStatus (and ComponentStatusList) holds the cluster validation info.&lt;/p></description></item><item><title>Docs: API 与 Resource</title><link>https://desistdaydream.github.io/docs/10.%E4%BA%91%E5%8E%9F%E7%94%9F/2.3.Kubernetes-%E5%AE%B9%E5%99%A8%E7%BC%96%E6%8E%92%E7%B3%BB%E7%BB%9F/1.API-Resource-%E4%B8%8E-Object/API-%E4%B8%8E-Resource/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/10.%E4%BA%91%E5%8E%9F%E7%94%9F/2.3.Kubernetes-%E5%AE%B9%E5%99%A8%E7%BC%96%E6%8E%92%E7%B3%BB%E7%BB%9F/1.API-Resource-%E4%B8%8E-Object/API-%E4%B8%8E-Resource/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://kubernetes.io/docs/concepts/overview/kubernetes-api/">官方文档，概念-概述-Kubernetes API&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://kubernetes.io/docs/reference/using-api/">官方文档，参考-API 概述&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>Kubernetes API 使我们可以查询和操纵 Kubernetes API 中资源的状态。Kubernetes API 符合 &lt;a href="https://www.yuque.com/go/doc/33220383">RESTful 规范&lt;/a>。&lt;/p>
&lt;p>Kubernetes 把自身一切抽象理解为 &lt;strong>Resource(资源)&lt;/strong>，也叫 &lt;strong>API Resource&lt;/strong>(有地方也叫 Group Resource)。对集群的所有操作都是通过对 Kubernetes API 的 HTTP(s) 请求来实现的。可以使用命令 kubectl api-resources 命令查看所有支持的资源。&lt;/p>
&lt;p>kubernetes 控制平面的核心是 &lt;strong>API Server&lt;/strong>。API Server 是实现了 Kubernets API 的应用程序，并为 Kubernetes 公开了一个 HTTP(s) 的 API，以供用户、集群中的不同部分和集群外部组件相互通信。&lt;/p>
&lt;p>Kubernetes 中各种资源(对象)的数据都通过 API 接口被提交到后端的持久化存储（etcd）中，Kubernetes 集群中的各部件之间通过该 API 接口实现解耦合，同时 Kubernetes 集群中一个重要且便捷的管理工具 kubectl 也是通过访问该 API 接口实现其强大的管理功能的。&lt;/p>
&lt;blockquote>
&lt;p>Note：kubectl 就是代替用户执行各种 http 请求的工具&lt;/p>
&lt;/blockquote>
&lt;p>在 Kubernetes 系统中，在大多数情况下，API 定义和实现都符合标准的 HTTP REST 格式，比如通过标准的 HTTP 动词（POST、PUT、GET、DELETE）来完成对相关资源对象的查询、创建、修改、删除等操作。但同时，Kubernetes 也为某些非标准的 REST 行为实现了附加的 API 接口，例如 Watch 某个资源的变化、进入容器执行某个操作等。另外，某些 API 接口可能违背严格的 REST 模式，因为接口返回的不是单一的 JSON 对象，而是其他类型的数据，比如 JSON 对象流或非结构化的文本日志数据等。&lt;/p>
&lt;p>另外，从另一个角度看，其实 kubernetes 就是提供了一个 web 服务，只是这个 web 服务不像传统的 B/S 架构那样，可以通过浏览器直接操作~kubernetes API 就是这个 web 服务的入口。&lt;/p>
&lt;blockquote>
&lt;p>注意：Kubernetes 的 API 与传统意义上的 API 不太一样。传统 API，一个 API 就是一个功能；而 Kubernetes API 中，一个 API 实际上又可以当作功能，也可以当作一个资源。对 API 的操作，就是对 Kubernets 资源进行操作&lt;/p>
&lt;/blockquote>
&lt;h2 id="api-resource资源-分类">API Resource(资源) 分类&lt;/h2>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://kubernetes.io/docs/reference/kubernetes-api/">官方文档，参考-kubernetes API&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.19/">1.19 版本 API 参考(一页模式)&lt;/a>(要查看其他版本，修改 URL 最后的版本号即可)。&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>资源大体可以分为下面几类：&lt;/p>
&lt;ul>
&lt;li>&lt;strong>workload(工作负载)&lt;/strong> # 用于在集群上管理和运行容器
&lt;ul>
&lt;li>Pod，Deployment，StatefuSet，DaemonSet，Job 等&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>Discovery &amp;amp; LB(服务发现及均衡)&lt;/strong> # 可以使用这些资源类型的对象将工作负载“缝合”到一个外部可访问的、负载均衡的服务中。
&lt;ul>
&lt;li>Service，Ingress 等&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>Config &amp;amp; Storage(配置与存储)&lt;/strong> # 这种类型的资源是用于将初始化数据注入到应用程序中并保留容器外部数据的对象。
&lt;ul>
&lt;li>Volume，ConifgMap，secret 等&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>Cluster(集群级资源)&lt;/strong> # 这种类型的资源对象定义了群集本身的配置方式。这些通常仅由集群运营商使用。
&lt;ul>
&lt;li>Namesapces,Node,Role,ClusterRole,RoleBinding,ClusterRoleBinding 等&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>Metadata(元数据型资源)&lt;/strong> # 这种类型的资源是用于配置集群中其他资源行为的对象。
&lt;ul>
&lt;li>HPA，PodTemplate，LimitRange 等&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>各种资源所用的 manifest 文件中的各个字段的含义就可以参考该页面找到详解。&lt;/p>
&lt;h2 id="api-resource资源-的-url-结构">API Resource(资源) 的 URL 结构&lt;/h2>
&lt;p>在 Kubernetes 中，资源的 URL 结构是由：Group（组）、Version（版本）和 Resource（资源种类）三个部分组成的。(还有一种 /metrics，/healthz 之类的结构，这里面的资源是系统自带的，不在任何组里)&lt;/p>
&lt;p>通过这样的结构，整个 Kubernetes 里的所有资源，实际上就可以用如下图的树形结构表示出来：&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/sz9hgm/1616120310758-dc53a2df-2a39-45e9-92e3-9beb5d9101f0.png" alt="">&lt;/p>
&lt;p>比如，如果要创建一个 CronJob 资源&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-yaml" data-lang="yaml">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">apiVersion&lt;/span>: &lt;span style="color:#ae81ff">batch/v2alpha1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">kind&lt;/span>: &lt;span style="color:#ae81ff">CronJob&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>在这个 YAML 文件中，“CronJob”就是资源的种类(Resource)，“batch”就是它的组(Group)，v2alpha1 就是它的版本(Version)。&lt;/p>
&lt;p>现阶段，有两个 API Groups 正在使用&lt;/p>
&lt;ul>
&lt;li>&lt;strong>core group(核心组)&lt;/strong> # 在/api/v1 路径下(由于某些历史原因而并没有在 &lt;code>/apis/core/v1&lt;/code> 路径下)。核心组是不需要 Group 的（即：它们 Group 是 &lt;code>&amp;quot;&amp;quot;&lt;/code>）。URI 路径为 &lt;code>/api/v1&lt;/code>，并且在定义资源的 manifest 文件中 apiVersion 字段的值不用包含组名，直接使用 v1 即可&lt;/li>
&lt;li>&lt;strong>named groups(已命名组)&lt;/strong> # URI 路径为 &lt;code>/apis/$GROUP_NAME/$VERSION&lt;/code>，在定义资源的 manifest 文件中 apiVersion 中省略 apis，使用 GroupName/Version&lt;/li>
&lt;/ul>
&lt;p>Notes:&lt;/p>
&lt;ul>
&lt;li>有的资源是 cluster 级别的(比如 node)，有的资源是 namespace 级别的(比如 pod)，对于 namespace 级别的资源，可以在 Version 和 Resource 中间添加 namespace 字段以获取指定 namespace 下的资源。i.e.&lt;code>/api/v1/namespaces/$NAMESPACE/pods/&lt;/code> (&lt;code>${NAMESPACE}&lt;/code> 就是具体的 namesapce 的名称)。&lt;/li>
&lt;li>所以 namesapce 级别资源的对象的 URI 应该像这样：&lt;code>/api/v1/namespaces/kube-system/pods/coredns-5644d7b6d9-tw4rh&lt;/code>&lt;/li>
&lt;li>而 cluster 级别资源的对象的 URI 则是：&lt;code>/api/v1/nodes/master1&lt;/code>&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>所有资源类型要么受集群范围限制（&lt;code>/apis/GROUP/VERSION/_&lt;/code>），要么受命名空间限制（&lt;code>/apis/GROUP/VERSION/namespaces/NAMESPACE/_&lt;/code>）&lt;/strong>&lt;/p>
&lt;p>集群范围的资源：&lt;/p>
&lt;ul>
&lt;li>GET /apis/GROUP/VERSION/RESOURCETYPE # 返回指定资源类型的资源集合(返回的是一个 list 列表，比如 NodeList 等)&lt;/li>
&lt;li>GET /apis/GROUP/VERSION/RESOURCETYPE/NAME # 返回指定资源类型下名为 NAME 的的资源&lt;/li>
&lt;/ul>
&lt;p>名称空间范围的资源：&lt;/p>
&lt;ul>
&lt;li>GET /apis/GROUP/VERSION/RESOURCETYPE # 返回所有名称空间指定资源类型的实例集合(返回的是一个 list 列表，比如 podList、serviceList 等)&lt;/li>
&lt;li>GET /apis/GROUP/VERSION/namespaces/NAMESPACE/RESOURCETYPE # 返回 NAMESPACE 下指定 ResourceType 的所有实例集合(返回的是一个 list 列表，比如 podList、serviceList 等)&lt;/li>
&lt;li>GET /apis/GROUP/VERSION/namespaces/NAMESPACE/RESOURCETYPE/NAME # 返回 NAMESPACE 下指定 ResourceType，名为 NAME 的实例&lt;/li>
&lt;/ul>
&lt;h1 id="declarative-api声明式-api-的特点">Declarative API(声明式 API) 的特点：&lt;/h1>
&lt;ul>
&lt;li>首先，所谓 &lt;strong>Declarative(声明式)&lt;/strong>，指的就是我只需要提交一个定义好的 API 对象来 &lt;strong>Declarative(声明)&lt;/strong> 我所期望的状态是什么样子。&lt;/li>
&lt;li>其次，“声明式 API”允许有多个 API 写端，以 PATCH 的方式对 API 对象进行修改，而无需关心本地原始 YAML 文件的内容。&lt;/li>
&lt;li>最后，也是最重要的，有了上述两个能力，Kubernetes 项目才可以基于对 API 对象的增、删、改、查，在完全无需外界干预的情况下，完成对“实际状态”和“期望状态”的调谐（Reconcile）过程。&lt;/li>
&lt;/ul>
&lt;p>所以说，声明式 API，才是 Kubernetes 项目编排能力“赖以生存”的核心所在。而想要实现 声明式 API，离不开 Controller 控制器，K8S 的大脑 的工作。&lt;/p>
&lt;h1 id="api-url-使用示例">API URL 使用示例&lt;/h1>
&lt;p>下面是在 1.18.8 版本下获取到的 api 路径结构&lt;/p>
&lt;p>根路径将列出所有可用路径&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-json" data-lang="json">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#960050;background-color:#1e0010">~]#&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">curl&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">--cacert&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">/etc/kubernetes/pki/ca.crt&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">-H&lt;/span> &lt;span style="color:#e6db74">&amp;#34;Authorization: Bearer ${TOKEN}&amp;#34;&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">https:&lt;/span>&lt;span style="color:#75715e">//172.38.40.215:6443/ -s
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;paths&amp;#34;&lt;/span>: [
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#34;/api&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#34;/api/v1&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#34;/apis&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#34;/apis/&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#34;/apis/admissionregistration.k8s.io&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#34;/apis/admissionregistration.k8s.io/v1&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#34;/apis/admissionregistration.k8s.io/v1beta1&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#34;/apis/apiextensions.k8s.io&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#34;/apis/apiextensions.k8s.io/v1&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#34;/apis/apiextensions.k8s.io/v1beta1&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#34;/apis/apiregistration.k8s.io&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#960050;background-color:#1e0010">......&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#960050;background-color:#1e0010">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>如果访问到错误的资源，还会返回 404 的响应码&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-json" data-lang="json">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#960050;background-color:#1e0010">~]#&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">curl&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">-s&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">--cacert&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">/etc/kubernetes/pki/ca.crt&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">-H&lt;/span> &lt;span style="color:#e6db74">&amp;#34;Authorization: Bearer ${TOKEN}&amp;#34;&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">https:&lt;/span>&lt;span style="color:#75715e">//172.38.40.215:6443/api/v1/service
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;kind&amp;#34;&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;Status&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;apiVersion&amp;#34;&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;v1&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;metadata&amp;#34;&lt;/span>: {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> },
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;status&amp;#34;&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;Failure&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;message&amp;#34;&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;the server could not find the requested resource&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;reason&amp;#34;&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;NotFound&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;details&amp;#34;&lt;/span>: {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> },
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;code&amp;#34;&lt;/span>: &lt;span style="color:#ae81ff">404&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>在“组/版本”下面可以看到该“组/版本”下所包含的 API 资源列表&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-json" data-lang="json">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#960050;background-color:#1e0010">~]#&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">curl&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">-s&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">--cacert&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">/etc/kubernetes/pki/ca.crt&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">-H&lt;/span> &lt;span style="color:#e6db74">&amp;#34;Authorization: Bearer ${TOKEN}&amp;#34;&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">https:&lt;/span>&lt;span style="color:#75715e">//172.38.40.215:6443/api/v1/
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;kind&amp;#34;&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;APIResourceList&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;groupVersion&amp;#34;&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;v1&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;resources&amp;#34;&lt;/span>: [
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#960050;background-color:#1e0010">.......&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;name&amp;#34;&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;configmaps&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;singularName&amp;#34;&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;namespaced&amp;#34;&lt;/span>: &lt;span style="color:#66d9ef">true&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;kind&amp;#34;&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;ConfigMap&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;verbs&amp;#34;&lt;/span>: [
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#34;create&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#34;delete&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#34;deletecollection&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#34;get&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#34;list&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#34;patch&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#34;update&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#34;watch&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ],
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;shortNames&amp;#34;&lt;/span>: [
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#34;cm&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ],
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;storageVersionHash&amp;#34;&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;qFsyl6wFWjQ=&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> },
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;name&amp;#34;&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;endpoints&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;singularName&amp;#34;&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;namespaced&amp;#34;&lt;/span>: &lt;span style="color:#66d9ef">true&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;kind&amp;#34;&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;Endpoints&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;verbs&amp;#34;&lt;/span>: [
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#34;create&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#34;delete&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#34;deletecollection&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#34;get&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#34;list&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#34;patch&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#34;update&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#34;watch&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ],
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;shortNames&amp;#34;&lt;/span>: [
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#34;ep&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ],
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;storageVersionHash&amp;#34;&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;fWeeMqaN/OA=&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> },
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#960050;background-color:#1e0010">......&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#960050;background-color:#1e0010">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>在“资源”下可以看到该“资源”下所包含的所有对象，下图是 pod 资源的列表，包含所有 pod 对象及其信息&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-json" data-lang="json">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#960050;background-color:#1e0010">~]#&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">curl&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">-s&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">--cacert&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">/etc/kubernetes/pki/ca.crt&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">-H&lt;/span> &lt;span style="color:#e6db74">&amp;#34;Authorization: Bearer ${TOKEN}&amp;#34;&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">https:&lt;/span>&lt;span style="color:#75715e">//172.38.40.215:6443/api/v1/pods | more
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;kind&amp;#34;&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;PodList&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;apiVersion&amp;#34;&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;v1&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;metadata&amp;#34;&lt;/span>: {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;selfLink&amp;#34;&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;/api/v1/pods&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;resourceVersion&amp;#34;&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;618871&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> },
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;items&amp;#34;&lt;/span>: [
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;metadata&amp;#34;&lt;/span>: {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;name&amp;#34;&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;cattle-cluster-agent-cc6ddc6dc-7f89l&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;generateName&amp;#34;&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;cattle-cluster-agent-cc6ddc6dc-&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;namespace&amp;#34;&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;cattle-system&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;selfLink&amp;#34;&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;/api/v1/namespaces/cattle-system/pods/cattle-cluster-agent-cc6ddc6dc-7f89l&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;uid&amp;#34;&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;72f4a825-feb2-416a-900d-d8401acc9a18&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;resourceVersion&amp;#34;&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;452264&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;creationTimestamp&amp;#34;&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;2020-09-13T09:59:49Z&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;labels&amp;#34;&lt;/span>: {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;app&amp;#34;&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;cattle-cluster-agent&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;pod-template-hash&amp;#34;&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;cc6ddc6dc&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> },
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;ownerReferences&amp;#34;&lt;/span>: [
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;apiVersion&amp;#34;&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;apps/v1&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;kind&amp;#34;&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;ReplicaSet&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;name&amp;#34;&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;cattle-cluster-agent-cc6ddc6dc&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;uid&amp;#34;&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;7d4b6cbe-d6d1-46e3-99e5-8410095880c7&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;controller&amp;#34;&lt;/span>: &lt;span style="color:#66d9ef">true&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;blockOwnerDeletion&amp;#34;&lt;/span>: &lt;span style="color:#66d9ef">true&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ],
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;managedFields&amp;#34;&lt;/span>: [
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#960050;background-color:#1e0010">......&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div></description></item><item><title>Docs: Bash</title><link>https://desistdaydream.github.io/docs/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/4.Terminal-%E4%B8%8E-Shell/Bash/Bash/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/4.Terminal-%E4%B8%8E-Shell/Bash/Bash/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://www.man7.org/linux/man-pages/man1/bash.1.html#SHELL_BUILTIN_COMMANDS">Manual(手册)，bash(1)-Shell 内置命令&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;h1 id="在-bash-中执行命令">在 Bash 中执行命令&lt;/h1>
&lt;h2 id="source-程序">source 程序&lt;/h2>
&lt;p>source 程序可以在当前 Shell 环境中从指定文件中读取并执行命令&lt;/p>
&lt;p>注意：该命令可以使当前环境的配置文件在此环境中立刻生效而不用重启机器&lt;/p>
&lt;p>作用：&lt;/p>
&lt;ul>
&lt;li>这个命令其实只是简单地读取脚本里面的语句依次在当前 shell 里面执行，没有建立新的子 shell。那么脚本里面所有新建、改变变量的语句都会保存在当前 shell 里面&lt;/li>
&lt;li>source 命令(从 C Shell 而来)是 bash shell 的内置命令。&lt;/li>
&lt;li>source(或点)命令通常用于重新执行刚修改的初始化文档。&lt;/li>
&lt;/ul>
&lt;p>应用实例：一般用于写在 shell 脚本中，通过 source 执行外部文件中是变量赋值，这样不建立子 shell 的话，外部文件中的变量就可以在该脚本启动的 shell 中引用&lt;/p>
&lt;p>&lt;strong>source [选项] FILENAME&lt;/strong> # 使环境变量立刻生效&lt;/p>
&lt;p>在当前 bash 环境下读取并执行 FileName 中的命令。该 filename 文件可以“无执行权限”&lt;/p>
&lt;p>EXAMPLE：&lt;/p>
&lt;ul>
&lt;li>source openrc admin admin # 运行 openrc 这个配置文件，把第一个参数 admin 和第二个参数 admin 送给 openrc 文件中的$1 和$2&lt;/li>
&lt;li>source .bash_profile #&lt;/li>
&lt;/ul>
&lt;p>sh 和 bash 程序：&lt;/p>
&lt;p>实际上，执行 sh 或者 bash 就是相当于打开新的子 shell，并在新的 shell 中执行后续的命令。只不过 bash 与 sh 是不同的 shell，内置的功能有一些细微的区别。&lt;/p>
&lt;p>作用:&lt;/p>
&lt;ul>
&lt;li>开启一个新的 shell，读取并执行 File 中的命令。该 file 可以“无执行权限”&lt;/li>
&lt;li>注：两者在执行文件时的不同，是分别用自己的 shell 来跑文件。
&lt;ul>
&lt;li>sh 使用“-n”选项进行 shell 脚本的语法检查，使用“-x”选项实现 shell 脚本逐条语句的跟踪&lt;/li>
&lt;li>可以巧妙地利用 shell 的内置变量增强“-x”选项的输出信息等。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>bash [OPTIONS] [File]&lt;/strong> #&lt;/p>
&lt;p>OPTIONS&lt;/p>
&lt;ul>
&lt;li>-n # 对指定文件进行语法检查&lt;/li>
&lt;li>-x # 打印出执行脚本的过程&lt;/li>
&lt;/ul>
&lt;h2 id="-的命令用法">./ 的命令用法&lt;/h2>
&lt;p>作用:&lt;/p>
&lt;ul>
&lt;li>打开一个子 shell 来读取并执行 FileName 中命令。&lt;/li>
&lt;li>注：运行一个 shell 脚本时会启动另一个命令解释器.&lt;/li>
&lt;li>每个 shell 脚本有效地运行在父 shell(parent shell)的一个子进程里. 这个父 shell 是指在一个控制终端或在一个 xterm 窗口中给你命令指示符的进程.shell 脚本也可以启动他自已的子进程. 这些子 shell(即子进程)使脚本并行地，有效率地地同时运行脚本内的多个子任务.&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>Syntax(语法)&lt;/strong>&lt;/p>
&lt;p>&lt;strong>./FileName&lt;/strong>&lt;/p>
&lt;h1 id="命令行补全">命令行补全&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Command-line_completion">Wiki,CommandLineCompletion&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>&lt;strong>Command Line Completion(命令行补全)&lt;/strong> 也称为 &lt;strong>tab completion&lt;/strong>，是命令行解释器的常见功能，在命令行中的程序，可以自动填充部分需要手动输入的命令。&lt;/p>
&lt;p>由 bash-completion 程序实现&lt;/p>
&lt;h2 id="关联文件与配置">关联文件与配置&lt;/h2>
&lt;p>&lt;strong>/etc/bash_completion.d/&lt;/strong> #
&lt;strong>/usr/share/bash-completion/completions/&lt;/strong> # 各种程序补全功能所需文件的保存目录。&lt;/p></description></item><item><title>Docs: BPF 流量控制机制</title><link>https://desistdaydream.github.io/docs/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2.Kernel%E5%86%85%E6%A0%B8/BPF/BPF-%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6%E6%9C%BA%E5%88%B6/BPF-%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6%E6%9C%BA%E5%88%B6/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2.Kernel%E5%86%85%E6%A0%B8/BPF/BPF-%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6%E6%9C%BA%E5%88%B6/BPF-%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6%E6%9C%BA%E5%88%B6/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>Kernel 网络官方文档：&lt;a href="https://www.kernel.org/doc/html/latest/networking/filter.html#">LInux Socket Filtering aka Berkeley Packet Filter&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote></description></item><item><title>Docs: Ceph</title><link>https://desistdaydream.github.io/docs/5.%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8/1.%E5%AD%98%E5%82%A8/%E5%AD%98%E5%82%A8%E7%9A%84%E5%9F%BA%E7%A1%80%E8%AE%BE%E6%96%BD%E6%9E%B6%E6%9E%84/Distributed-Storage%E5%88%86%E5%B8%83%E5%BC%8F%E5%AD%98%E5%82%A8/Ceph/Ceph/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/5.%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8/1.%E5%AD%98%E5%82%A8/%E5%AD%98%E5%82%A8%E7%9A%84%E5%9F%BA%E7%A1%80%E8%AE%BE%E6%96%BD%E6%9E%B6%E6%9E%84/Distributed-Storage%E5%88%86%E5%B8%83%E5%BC%8F%E5%AD%98%E5%82%A8/Ceph/Ceph/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://ceph.io/">官网&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://docs.ceph.com/en/latest/">官方文档&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Ceph_(software)">Wiki,Ceph&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://blog.csdn.net/younger_china/article/details/73410727">https://blog.csdn.net/younger_china/article/details/73410727&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>Ceph 是一个开源的分布式存储系统，可以提供 对象存储、快存储、文件存储 能力。是一个 Software Defined Storage(软件定义存储) 的代表性产品。&lt;/p>
&lt;p>一个 Ceph 存储集群至少需要 Ceph Monitor、Ceph Manager、Ceph OSD 这三个组件；如果要运行 Ceph 文件系统客户端，则也需要 Ceph MDS。&lt;/p>
&lt;ul>
&lt;li>&lt;strong>Monitor&lt;/strong> # &lt;strong>Ceph Monitor(Ceph 监视器，简称 ceph-mon)&lt;/strong> 负责维护集群状态的映射关系。通常至少需要 3 个 ceph-mon 以实现高可用，多节点使用 Paxos 算法达成共识。
&lt;ul>
&lt;li>可以这么说，Ceph 集群就是指 ceph-mon 集群。ceph-mon 负责维护的集群状态，就是用来提供存储服务的。&lt;/li>
&lt;li>ceph-mon 映射、ceph-mgr 映射、ceph-osd 映射、ceph-mds 映射、ceph-crush 映射。这些映射是 Ceph 守护进程相互协调所需的关键集群状态，说白了，就是&lt;strong>映射关系&lt;/strong>。
&lt;ul>
&lt;li>这里的映射，英文用的是 Map，其实也有地图的意思，就是表示这个集群有多少个 ceph-mon、有多少个 ceph-mgr 等等，还有底层对象属于哪个 PG，等等等等，这些东西构成了一副 Ceph 的运行图。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>ceph-mon 还负责管理守护进程和客户端之间的身份验证。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>Manager&lt;/strong> # &lt;strong>Ceph Manager(Ceph 管理器，简称 ceph-mgr)&lt;/strong> 负责跟踪运行时指标和 Ceph 集群的当前状态，包括存储利用率、性能、系统负载等。通常至少需要 2 个 ceph-mgr 以实现高可用。
&lt;ul>
&lt;li>ceph-mgr 可以提供 Web 管理页面、关于 Ceph 集群的 Prometheus 格式的监控指标&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>OSD Daemon&lt;/strong> # &lt;strong>Ceph OSD Daemon(Ceph OSD 守护进程，简称 ceph-osd)&lt;/strong> 负责向 OSD 读写数据、处理数据复制、恢复、重新平衡，并通过检查其他 ceph-osd 的心跳向 ceph-mon 和 ceph-mgr 提供一些监控信息。通常至少需要 3 个 ceph-osd 以实现高科用。
&lt;ul>
&lt;li>&lt;strong>Object Storage Device(对象存储设备，简称 OSD)&lt;/strong> 是一个物理或逻辑上的存储单元(比如一块硬盘)，这是 Ceph 得以运行的最基本的存储单元。
&lt;ul>
&lt;li>有的时候，人们容易把 OSD 理解为 Ceph OSD Daemon，这俩是有本质区别的。因为在最早的时候，OSD 有两种含义，一种是 &lt;code>Object Storage Device&lt;/code> 另一种是 &lt;code>Object Storage Daemon&lt;/code>。由于这种称呼的模糊性，后来就将 Object Storage daemon 扩展为 OSD Daemon。OSD 则仅仅代表 Object Storage Device。只不过运行 OSD Daemon 的程序名称，依然沿用了 osd 的名字。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>注意，为了让每一个 OSD 都可以被单独使用并管理，所以每个 OSD 都有一个对应的 ceph-osd 进程来管理。一般情况，Ceph 集群中每个节点，除了系统盘做 Raid 以外，其他硬盘都会单独作为 OSD 使用，且一个节点会有大量磁盘来对应 OSD。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>MDS&lt;/strong> # &lt;strong>Ceph Metadata Server(Ceph 元数据服务器，简称 ceph-mds)&lt;/strong> 代表 Ceph 文件系统元数据。ceph-mds 允许 POSIX 文件系统用户执行基本命令(比如 ls、find 等)，而不会给 Ceph 集群带来巨大负担。
&lt;ul>
&lt;li>注意，Ceph 提供的 块存储 和 对象存储 功能并不使用 ceph-mds。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h2 id="架构">架构&lt;/h2>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://docs.ceph.com/en/latest/architecture/">官方文档，架构&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/sakrws/1630769971104-82bcc0c6-1dbd-4c47-b986-3e5b8321aac0.png" alt="image.png">&lt;/p>
&lt;p>&lt;strong>其实 Ceph 本身就是一个对象存储&lt;/strong>，基于&lt;strong>RADOS&lt;/strong> 实现，并通过 Ceph Client 为上层应用提供了通用的 块存储、文件存储、对象存储 的调用接口。&lt;/p>
&lt;ul>
&lt;li>&lt;strong>RADOS&lt;/strong> # &lt;strong>Reliable Autonomic Distributed Object Store(可靠的、自动化的分布式对象存储，简称 RADOS)&lt;/strong> 是一种由多个主机组成、由 CRUSH 算法实现数据路由的，分布式对象存储系统。是 Ceph 的底层存储系统。
&lt;ul>
&lt;li>OSD 是组成 RADOS 的基本存储单元。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>Ceph Client&lt;/strong> # &lt;strong>Ceph 客户端&lt;/strong>。是可以访问 Ceph 存储集群(即 RADOS) 的 Ceph 组件的集合。
&lt;ul>
&lt;li>&lt;strong>LIBRADOS&lt;/strong> # &lt;strong>Library RADOS(RADOS 库，简称 librados)&lt;/strong>。应用程序可以调用 librados 以直接访问 RADOS。当我们使用 Ceph 时，Ceph 实际上是调用 librados 的 API(这是一个 rpc 接口)，将提交的文件切分为固定大小的数据，存放到 RADOS 中。
&lt;ul>
&lt;li>同时，我们自己也可以使用 librados 开发出类似 ceph-rgw、ceph-rbd 这种应用程序以实现个性化需求。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>RADOSGW&lt;/strong> # &lt;strong>RADOS Gateway(RADOS 网关，简称 radosgw)&lt;/strong>。使用 librados 实现的应用程序，可以提供兼容 S3 和 Swift 对象存储的接口&lt;/li>
&lt;li>&lt;strong>RBD&lt;/strong> # &lt;strong>RADOS Block Device(RADOS 块设备，简称 RBD)&lt;/strong>。使用 librados 实现的应用程序，为 Linux 内核 和 QEMU/KVM 提供一个可靠且完全分布式的块存储设备。&lt;/li>
&lt;li>&lt;strong>CEPH FS&lt;/strong> # &lt;strong>Ceph File System(Ceph 文件系统，简称 CFS)&lt;/strong>。直接使用 RADOS 实现一个符合 POSIX 的分布式文件系统，带有 Linux 内核客户端并支持 FUSE，可以直接挂载使用。甚至可以进一步抽象，实现 NFS 功能。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h2 id="ceph-数据写入流程">Ceph 数据写入流程&lt;/h2>
&lt;p>Ceph 集群从 Ceph 的客户端接收到的数据后，将会切分为一个或多个固定大小的 &lt;strong>RADOS Object(RADOS 对象)&lt;/strong>。Ceph 使用 &lt;strong>Controlled Replication Under Scalable Hashing(简称 CRUSH)&lt;/strong> 算法计算出 RADOS 对象应该放在哪个 &lt;strong>Placement Group(归置组，简称 PG)&lt;/strong>，并进一步计算出，应该由哪个 ceph-osd 来处理这个 PG 并将 PG 存储到指定的 OSD 中。ceph-osd 会通过存储驱动器处理 RADOS 对象的 读、写 和 复制操作。&lt;/p>
&lt;blockquote>
&lt;p>注意：当创建完 Ceph 集群后，会有一个默认的 Pool，Pool 是用来对 PG 进行分组的，且 PG 必须属于一个组，不可独立存在。&lt;/p>
&lt;/blockquote>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/sakrws/1630834243384-b650e1e5-1c84-4846-bdc5-9180a361fb09.png" alt="image.png">&lt;/p>
&lt;p>RADOS 对象有如下几个部分组成&lt;/p>
&lt;ul>
&lt;li>&lt;strong>Object Identify(对象标识符，简称 OID)&lt;/strong> # OID 在整个 Ceph 集群中是唯一。&lt;/li>
&lt;li>&lt;strong>Binary Data(二进制数据数据)&lt;/strong> # 对象的数据&lt;/li>
&lt;li>&lt;strong>Metadata(元数据)&lt;/strong> # 元数据的语义完全取决于 Ceph 客户端。例如，CephFS 使用元数据来存储文件属性，如文件所有者、创建日期、上次修改日期等。&lt;/li>
&lt;/ul>
&lt;p>ceph-osd 将数据作为对象存储在平坦的命名空间中 (例如，没有目录层次结构)。对象具有标识符，二进制数据和由一组名称/值对组成的元数据。&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/sakrws/1630808425695-75766062-7570-47f0-9ae4-916c7819d113.png" alt="image.png">&lt;/p>
&lt;h1 id="rados">RADOS&lt;/h1>
&lt;p>与传统分布式存储不同，传统分布式存储中的 NameNode 极易形成性能瓶颈。基于此，RADOS 设计了一种新的方式来快速找到对象数据。RADOS 中并不需要 NameNode 来存储每个对象的元数据，RADOS 中的对象，都是通过 &lt;strong>Controlled Replication Under Scalable Hashing(简称 CRUSH)&lt;/strong> 算法来快速定位的。&lt;/p>
&lt;h2 id="bluestore">bluestore&lt;/h2>
&lt;p>这是 Ceph 所管理的 OSD 的文件系统类型&lt;/p>
&lt;h1 id="ceph-的存储能力">Ceph 的存储能力&lt;/h1>
&lt;h2 id="块存储">块存储&lt;/h2>
&lt;p>Ceph 通过 RDB 提供块存储能力&lt;/p>
&lt;h2 id="文件存储">文件存储&lt;/h2>
&lt;p>Ceph 通过 CEPHFS 提供文件存储能力&lt;/p>
&lt;h2 id="对象存储">对象存储&lt;/h2>
&lt;p>RADOS Gateway 简称 radosgw，Ceph 通过 radosgw 程序，可以对外提供标准的 S3 或 swift 接口，以实现主流对象存储功能。很多时候，radosgw 程序运行的进程称为 ceph-rgw&lt;/p>
&lt;h1 id="ceph-manager">Ceph Manager&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://docs.ceph.com/en/latest/mgr/">官方文档,Ceph 管理器&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>Ceph Manager 是通过一个名为 ceph-mgr 的二进制程序以守护进程运行的管理器。ceph-mgr 可以向外部监控和管理系统提供额外的监控和接口。&lt;/p>
&lt;p>ceph-mgr 曾经是 ceph-mon 的一部分，自 luinous(12.x) 版本依赖，ceph-mgr 独立出来，成为 Ceph 集群的必选组件。&lt;/p>
&lt;h2 id="dashboard-模块">Dashboard 模块&lt;/h2>
&lt;p>Dashboard 模块是一个内置的基于 Web 的 Ceph 管理和监控程序，通过它可以检查和管理 Ceph 集群中的各个方面和资源。默认监听 &lt;code>8443&lt;/code> 端口&lt;/p>
&lt;p>在 Dashboard 模块中，提供了一组用于管理集群的 RESTful 风格的 API 接口。这组 API 位于 &lt;code>/api&lt;/code> 路径下。详见《[API](&amp;lt;/docs/5.数据存储/1.存储/存储的基础设施架构/Distributed%20Storage(分布式存储)/Ceph/API.md&amp;raquo;)》章节&lt;/p>
&lt;h2 id="prometheus-模块">Prometheus 模块&lt;/h2>
&lt;p>启动 Prometheus 模块后，ceph-mgr 默认在 &lt;code>9283&lt;/code> 端口上暴露 Prometheus 格式的监控指标。&lt;/p>
&lt;h1 id="ceph-radosgw">Ceph RADOSGW&lt;/h1>
&lt;p>默认监听 &lt;code>7480&lt;/code> 端口&lt;/p></description></item><item><title>Docs: Common Definitions(通用定义)</title><link>https://desistdaydream.github.io/docs/10.%E4%BA%91%E5%8E%9F%E7%94%9F/2.3.Kubernetes-%E5%AE%B9%E5%99%A8%E7%BC%96%E6%8E%92%E7%B3%BB%E7%BB%9F/1.API-Resource-%E4%B8%8E-Object/API-%E5%8F%82%E8%80%83/Common-Definitions%E9%80%9A%E7%94%A8%E5%AE%9A%E4%B9%89/Common-Definitions%E9%80%9A%E7%94%A8%E5%AE%9A%E4%B9%89/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/10.%E4%BA%91%E5%8E%9F%E7%94%9F/2.3.Kubernetes-%E5%AE%B9%E5%99%A8%E7%BC%96%E6%8E%92%E7%B3%BB%E7%BB%9F/1.API-Resource-%E4%B8%8E-Object/API-%E5%8F%82%E8%80%83/Common-Definitions%E9%80%9A%E7%94%A8%E5%AE%9A%E4%B9%89/Common-Definitions%E9%80%9A%E7%94%A8%E5%AE%9A%E4%B9%89/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://kubernetes.io/docs/reference/kubernetes-api/common-definitions/">官方文档，参考-KubernetesAPI-通用定义&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;h1 id="common-definitions">Common Definitions&lt;/h1>
&lt;h2 id="deleteoptionshttpskubernetesiodocsreferencekubernetes-apicommon-definitionsdelete-options">&lt;a href="https://kubernetes.io/docs/reference/kubernetes-api/common-definitions/delete-options/">DeleteOptions&lt;/a>&lt;/h2>
&lt;p>DeleteOptions may be provided when deleting an API object.&lt;/p>
&lt;h2 id="labelselectordocs10云原生23kubernetes20容器编排系统1api20resource20与20objectapi20参考common20definitions通用定义labelselectormd">&lt;a href="https://desistdaydream.github.io/docs/10.%E4%BA%91%E5%8E%9F%E7%94%9F/2.3.Kubernetes%20%E5%AE%B9%E5%99%A8%E7%BC%96%E6%8E%92%E7%B3%BB%E7%BB%9F/1.API%20Resource%20%E4%B8%8E%20Object/API%20%E5%8F%82%E8%80%83/Common%20Definitions(%E9%80%9A%E7%94%A8%E5%AE%9A%E4%B9%89)/LabelSelector.md">LabelSelector&lt;/a>&lt;/h2>
&lt;p>A label selector is a label query over a set of resources.&lt;/p>
&lt;h2 id="listmetahttpskubernetesiodocsreferencekubernetes-apicommon-definitionslist-meta">&lt;a href="https://kubernetes.io/docs/reference/kubernetes-api/common-definitions/list-meta/">ListMeta&lt;/a>&lt;/h2>
&lt;p>ListMeta describes metadata that synthetic resources must have, including lists and various status objects.&lt;/p>
&lt;h2 id="localobjectreferencehttpskubernetesiodocsreferencekubernetes-apicommon-definitionslocal-object-reference">&lt;a href="https://kubernetes.io/docs/reference/kubernetes-api/common-definitions/local-object-reference/">LocalObjectReference&lt;/a>&lt;/h2>
&lt;p>LocalObjectReference contains enough information to let you locate the referenced object inside the same namespace.&lt;/p>
&lt;h2 id="nodeselectorrequirementhttpskubernetesiodocsreferencekubernetes-apicommon-definitionsnode-selector-requirement">&lt;a href="https://kubernetes.io/docs/reference/kubernetes-api/common-definitions/node-selector-requirement/">NodeSelectorRequirement&lt;/a>&lt;/h2>
&lt;p>A node selector requirement is a selector that contains values, a key, and an operator that relates the key and values.&lt;/p>
&lt;h2 id="objectfieldselectorhttpskubernetesiodocsreferencekubernetes-apicommon-definitionsobject-field-selector">&lt;a href="https://kubernetes.io/docs/reference/kubernetes-api/common-definitions/object-field-selector/">ObjectFieldSelector&lt;/a>&lt;/h2>
&lt;p>ObjectFieldSelector selects an APIVersioned field of an object.&lt;/p>
&lt;h2 id="objectmetadocs10云原生23kubernetes20容器编排系统1api20resource20与20objectapi20参考common20definitions通用定义objectmetamd">&lt;a href="https://desistdaydream.github.io/docs/10.%E4%BA%91%E5%8E%9F%E7%94%9F/2.3.Kubernetes%20%E5%AE%B9%E5%99%A8%E7%BC%96%E6%8E%92%E7%B3%BB%E7%BB%9F/1.API%20Resource%20%E4%B8%8E%20Object/API%20%E5%8F%82%E8%80%83/Common%20Definitions(%E9%80%9A%E7%94%A8%E5%AE%9A%E4%B9%89)/ObjectMeta.md">ObjectMeta&lt;/a>&lt;/h2>
&lt;p>ObjectMeta 是所有资源持久化成对象后必须要具有的元数据，其中包括对象的 名称、所在名称空间 等等。对应的 yaml 字段为 &lt;code>.metadata&lt;/code>&lt;/p>
&lt;h2 id="objectreferencehttpskubernetesiodocsreferencekubernetes-apicommon-definitionsobject-reference">&lt;a href="https://kubernetes.io/docs/reference/kubernetes-api/common-definitions/object-reference/">ObjectReference&lt;/a>&lt;/h2>
&lt;p>ObjectReference contains enough information to let you inspect or modify the referred object.&lt;/p>
&lt;h2 id="patchhttpskubernetesiodocsreferencekubernetes-apicommon-definitionspatch">&lt;a href="https://kubernetes.io/docs/reference/kubernetes-api/common-definitions/patch/">Patch&lt;/a>&lt;/h2>
&lt;p>Patch is provided to give a concrete name and type to the Kubernetes PATCH request body.&lt;/p>
&lt;h2 id="quantityhttpskubernetesiodocsreferencekubernetes-apicommon-definitionsquantity">&lt;a href="https://kubernetes.io/docs/reference/kubernetes-api/common-definitions/quantity/">Quantity&lt;/a>&lt;/h2>
&lt;p>Quantity is a fixed-point representation of a number.&lt;/p>
&lt;h2 id="resourcefieldselectorhttpskubernetesiodocsreferencekubernetes-apicommon-definitionsresource-field-selector">&lt;a href="https://kubernetes.io/docs/reference/kubernetes-api/common-definitions/resource-field-selector/">ResourceFieldSelector&lt;/a>&lt;/h2>
&lt;p>ResourceFieldSelector represents container resources (cpu, memory) and their output format.&lt;/p>
&lt;h2 id="statusdocs10云原生23kubernetes20容器编排系统1api20resource20与20objectapi20参考common20definitions通用定义statusmd">&lt;a href="https://desistdaydream.github.io/docs/10.%E4%BA%91%E5%8E%9F%E7%94%9F/2.3.Kubernetes%20%E5%AE%B9%E5%99%A8%E7%BC%96%E6%8E%92%E7%B3%BB%E7%BB%9F/1.API%20Resource%20%E4%B8%8E%20Object/API%20%E5%8F%82%E8%80%83/Common%20Definitions(%E9%80%9A%E7%94%A8%E5%AE%9A%E4%B9%89)/Status.md">Status&lt;/a>&lt;/h2>
&lt;p>Status 字段是不返回其他对象的调用的返回值。&lt;/p>
&lt;h2 id="typedlocalobjectreferencehttpskubernetesiodocsreferencekubernetes-apicommon-definitionstyped-local-object-reference">&lt;a href="https://kubernetes.io/docs/reference/kubernetes-api/common-definitions/typed-local-object-reference/">TypedLocalObjectReference&lt;/a>&lt;/h2>
&lt;p>TypedLocalObjectReference contains enough information to let you locate the typed referenced object inside the same namespace.&lt;/p></description></item><item><title>Docs: Containerd</title><link>https://desistdaydream.github.io/docs/10.%E4%BA%91%E5%8E%9F%E7%94%9F/2.2.%E5%AE%9E%E7%8E%B0%E5%AE%B9%E5%99%A8%E7%9A%84%E5%B7%A5%E5%85%B7/Containerd/Containerd/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/10.%E4%BA%91%E5%8E%9F%E7%94%9F/2.2.%E5%AE%9E%E7%8E%B0%E5%AE%B9%E5%99%A8%E7%9A%84%E5%B7%A5%E5%85%B7/Containerd/Containerd/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://containerd.io/">官网&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://github.com/containerd/containerd">GitHub 项目，containerd/containerd&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://github.com/containerd/containerd/blob/main/docs/PLUGINS.md">GitHub 项目文档，containerd/docs/PLUGINS.md&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://fuckcloudnative.io/posts/getting-started-with-containerd/">云原生实验室，Containerd 使用教程&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://blog.frognew.com/tags/containerd.html">架构小白，Containerd 标签&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://mp.weixin.qq.com/s/Dr6851XnkNLVFHaj1b13RQ">公众号-云原生实验室，容器中的 Shim 到底是个什么鬼&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>Containerd 是行业标准的容器运行时，着重于简单性，健壮性和可移植性。&lt;/p>
&lt;h2 id="containerd-的前世今生">Containerd 的前世今生&lt;/h2>
&lt;p>很久以前，Docker 强势崛起，以“镜像”这个大招席卷全球，对其他容器技术进行致命的降维打击，使其毫无招架之力，就连 Google 也不例外。Google 为了不被拍死在沙滩上，被迫拉下脸面（当然，跪舔是不可能的），希望 Docker 公司和自己联合推进一个开源的容器运行时作为 Docker 的核心依赖，不然就走着瞧。Docker 公司觉得自己的智商被侮辱了，走着瞧就走着瞧，谁怕谁啊！&lt;/p>
&lt;p>很明显，Docker 公司的这个决策断送了自己的大好前程，造成了今天的悲剧。&lt;/p>
&lt;p>紧接着，Google 联合 Red Hat、IBM 等几位巨佬连哄带骗忽悠 Docker 公司将 &lt;code>libcontainer&lt;/code> 捐给中立的社区（OCI，Open Container Intiative），并改名为 &lt;code>runc&lt;/code>，不留一点 Docker 公司的痕迹~~这还不够，为了彻底扭转 Docker 一家独大的局面，几位大佬又合伙成立了一个基金会叫 &lt;code>CNCF&lt;/code>（Cloud Native Computing Fundation），这个名字想必大家都很熟了，我就不详细介绍了。CNCF 的目标很明确，既然在当前的维度上干不过 Docker，干脆往上爬，升级到大规模容器编排的维度，以此来击败 Docker。Docker 公司当然不甘示弱，搬出了 Swarm 和 Kubernetes 进行 PK，最后的结局大家都知道了，Swarm 战败。然后 Docker 公司耍了个小聪明，将自己的核心依赖 &lt;code>Containerd&lt;/code> 捐给了 CNCF，以此来标榜 Docker 是一个 PaaS 平台。&lt;/p>
&lt;p>很明显，这个小聪明又大大加速了自己的灭亡。&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/ox2yd7/1616122481377-1a01b919-efe6-450a-a439-5493a17e6d70.png" alt="">&lt;/p>
&lt;p>巨佬们心想，想当初想和你合作搞个中立的核心运行时，你死要面子活受罪，就是不同意，好家伙，现在自己搞了一个，还捐出来了，马老师，发生甚莫事了？&lt;/p>
&lt;p>这好吗？&lt;/p>
&lt;p>这不好&lt;/p>
&lt;p>也罢，这倒省事了，我就直接拿 Containerd 来做文章吧。首先呢，为了表示 Kubernetes 的中立性，当然要搞个标准化的容器运行时接口，只要适配了这个接口的容器运行时，都可以和我一起玩耍哦，第一个支持这个接口的当然就是 Containerd 啦。至于这个接口的名字，大家应该都知道了，它叫 CRI（Container Runntime Interface）。这样还不行，为了蛊惑 Docker 公司，Kubernetes 暂时先委屈自己，专门在自己的组件中集成了一个 &lt;code>shim&lt;/code>（你可以理解为垫片），用来将 CRI 的调用翻译成 Docker 的 API，让 Docker 也能和自己愉快地玩耍，温水煮青蛙，养肥了再杀。。。&lt;/p>
&lt;p>就这样，Kubernetes 一边假装和 Docker 愉快玩耍，一边背地里不断优化 Containerd 的健壮性以及和 CRI 对接的丝滑性。现在 Containerd 的翅膀已经完全硬了，是时候卸下我的伪装，和 Docker say bye bye 了。后面的事情大家也都知道了~~&lt;/p>
&lt;p>Docker 这门技术成功了，Docker 这个公司却失败了。&lt;/p>
&lt;h2 id="containerd-架构">Containerd 架构&lt;/h2>
&lt;p>时至今日，Containerd 已经变成一个工业级的容器运行时了，连口号都有了：超简单！超健壮！可移植性超强！&lt;/p>
&lt;p>当然，为了让 Docker 以为自己不会抢饭碗，Containerd 声称自己的设计目的主要是为了嵌入到一个更大的系统中（暗指 Kubernetes），而不是直接由开发人员或终端用户使用。&lt;/p>
&lt;p>事实上呢，Containerd 现在基本上啥都能干了，开发人员或者终端用户可以在宿主机中管理完整的容器生命周期，包括容器镜像的传输和存储、容器的执行和管理、存储和网络等。大家可以考虑学起来了。&lt;/p>
&lt;p>先来看看 Containerd 的架构：&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/ox2yd7/1616122481393-e3bb2fce-f18d-40ec-ac46-4c6d6a664cd6.png" alt="">&lt;/p>
&lt;p>可以看到 Containerd 仍然采用标准的 C/S 架构，服务端通过 &lt;code>GRPC&lt;/code> 协议提供稳定的 API，客户端通过调用服务端的 API 进行高级的操作。&lt;/p>
&lt;p>为了解耦，Containerd 将不同的职责划分给不同的组件，每个组件就相当于一个&lt;strong>子系统&lt;/strong>（subsystem）。连接不同子系统的组件被称为模块。&lt;/p>
&lt;p>总体上 Containerd 被划分为两个子系统：&lt;/p>
&lt;ul>
&lt;li>&lt;strong>Bundle&lt;/strong> : 在 Containerd 中，&lt;code>Bundle&lt;/code> 包含了配置、元数据和根文件系统数据，你可以理解为容器的文件系统。而 &lt;strong>Bundle 子系统&lt;/strong>允许用户从镜像中提取和打包 Bundles。&lt;/li>
&lt;li>&lt;strong>Runtime&lt;/strong> : Runtime 子系统用来执行 Bundles，比如创建容器。&lt;/li>
&lt;/ul>
&lt;p>其中，每一个子系统的行为都由一个或多个&lt;strong>模块&lt;/strong>协作完成（架构图中的 &lt;code>Core&lt;/code> 部分）。每一种类型的模块都以 &lt;strong>Plugin(插件)&lt;/strong> 的形式集成到 Containerd 中，而且插件之间是相互依赖的。例如，上图中的每一个长虚线的方框都表示一种类型的插件，包括 &lt;code>Service Plugin&lt;/code>、&lt;code>Metadata Plugin&lt;/code>、&lt;code>GC Plugin&lt;/code>、&lt;code>Runtime Plugin&lt;/code> 等，其中 &lt;code>Service Plugin&lt;/code> 又会依赖 Metadata Plugin、GC Plugin 和 Runtime Plugin。每一个小方框都表示一个细分的插件，例如 &lt;code>Metadata Plugin&lt;/code> 依赖 Containers Plugin、Content Plugin 等。总之，万物皆插件，插件就是模块，模块就是插件。&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/ox2yd7/1616122481388-5272b6c1-efb6-49f4-a180-5425bef8ed64.png" alt="">&lt;/p>
&lt;p>这里介绍几个常用的插件：&lt;/p>
&lt;ul>
&lt;li>&lt;strong>Content Plugin&lt;/strong> : 提供对镜像中可寻址内容的访问，所有不可变的内容都被存储在这里。&lt;/li>
&lt;li>&lt;strong>Snapshot Plugin&lt;/strong> : 用来管理容器镜像的文件系统快照。镜像中的每一个 layer 都会被解压成文件系统快照，类似于 Docker 中的 &lt;code>graphdriver&lt;/code>。&lt;/li>
&lt;li>&lt;strong>Metrics&lt;/strong> : 暴露各个组件的监控指标。&lt;/li>
&lt;/ul>
&lt;p>从总体来看，Containerd 被分为三个大块：&lt;code>Storage&lt;/code>、&lt;code>Metadata&lt;/code> 和 &lt;code>Runtime&lt;/code>，可以将上面的架构图提炼一下
：
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/ox2yd7/1616122481410-b77c18a6-2bcd-48be-b676-1b285bf1c862.png" alt="">&lt;/p>
&lt;p>这是使用 &lt;strong>bucketbench[1]&lt;/strong> 对 &lt;code>Docker&lt;/code>、&lt;code>crio&lt;/code> 和 &lt;code>Containerd&lt;/code> 的性能测试结果，包括启动、停止和删除容器，以比较它们所耗的时间：&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/ox2yd7/1616122481422-8a56805f-3ef0-46a4-be19-a0a5b1eef44f.png" alt="">&lt;/p>
&lt;p>可以看到 Containerd 在各个方面都表现良好，总体性能还是优越于 &lt;code>Docker&lt;/code> 和 &lt;code>crio&lt;/code> 的。&lt;/p>
&lt;h1 id="containerd-关联文件与配置">Containerd 关联文件与配置&lt;/h1>
&lt;p>&lt;strong>/etc/containerd/config.toml&lt;/strong> # Containerd 运行时配置文件。该文件可以通过 containerd config default 命令来生成一个默认的配置。&lt;/p>
&lt;p>&lt;strong>/var/lib/containerd/*&lt;/strong> # Root(根) 文件夹。用于保存持久化数据，镜像、元数据 所在路径。包括 Snapshots, Content, Metadata 以及各种插件的数据。每一个插件都有自己单独的目录，Containerd 本身不存储任何数据，它的所有功能都来自于已加载的插件。目录下的内容详解，见 &lt;a href="https://desistdaydream.github.io/docs/10.%E4%BA%91%E5%8E%9F%E7%94%9F/2.2.%E5%AE%9E%E7%8E%B0%E5%AE%B9%E5%99%A8%E7%9A%84%E5%B7%A5%E5%85%B7/Containerd/Containerd%20Image.md">《Containerd Image 章节》&lt;/a>&lt;/p>
&lt;ul>
&lt;li>.&lt;strong>/io.containerd.content.v1.content/&lt;/strong> # 镜像的上下文保存目录
&lt;ul>
&lt;li>.&lt;strong>/blobs/&lt;/strong> # 镜像文件系统布局中。blobs 目录数据的存放路径&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>./io.containerd.snapshotter.v1.overlayfs/&lt;/strong> # 镜像的层信息所在目录。&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>/run/containerd/&lt;/strong> # State(状态) 文件夹。用于保存运行时产生的临时数据，也就是容器启动后数据存放目录。包括 sockets、pid、挂载点、运行时状态以及不需要持久化保存的插件数据。&lt;/p>
&lt;ul>
&lt;li>&lt;strong>./io.containerd.runtime.VERSION.ID/&lt;/strong> # Containerd 运行容器时所使用的 runtime 插件，该目录的名称就是插件的版本和名称。该目录下的目录以名称空间命名。
&lt;ul>
&lt;li>&lt;strong>./NAMESPACE/&lt;/strong> # 指定名称空间下的容器启动后的数据(主要就是符合 OCI 标准的 一组 Bundle 文件)保存路径，其内目录名为 ContainerID。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>/var/lib/containerd/ 与 /run/containerd/ 是 Containerd 最常用的两个目录，一个存镜像数据，一个存容器数据。&lt;/p>
&lt;h2 id="目录结构">目录结构&lt;/h2>
&lt;p>在 /var/lib/containerd 和 /run/containerd 目录下，保存了 Containerd 运行所需的所有数据。Containerd 本身不存储任何数据，所有数据都来源于插件的功能。
看一下目录下的层次结构就一目了然了：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>? → tree -L &lt;span style="color:#ae81ff">2&lt;/span> /var/lib/containerd/
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>/var/lib/containerd/
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>├── io.containerd.content.v1.content
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>│ ├── blobs
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>│ └── ingest
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>├── io.containerd.grpc.v1.cri
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>│ ├── containers
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>│ └── sandboxes
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>├── io.containerd.metadata.v1.bolt
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>│ └── meta.db
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>├── io.containerd.runtime.v1.linux
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>│ └── k8s.io
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>├── io.containerd.runtime.v2.task
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>├── io.containerd.snapshotter.v1.aufs
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>│ └── snapshots
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>├── io.containerd.snapshotter.v1.btrfs
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>├── io.containerd.snapshotter.v1.native
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>│ └── snapshots
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>├── io.containerd.snapshotter.v1.overlayfs
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>│ ├── metadata.db
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>│ └── snapshots
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>└── tmpmounts
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">18&lt;/span> directories, &lt;span style="color:#ae81ff">2&lt;/span> files
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>每个子目录，其实都表示的是一个插件名称。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>? → tree -L &lt;span style="color:#ae81ff">2&lt;/span> /run/containerd/
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>/run/containerd/
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>├── containerd.sock
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>├── containerd.sock.ttrpc
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>├── io.containerd.grpc.v1.cri
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>│ ├── containers
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>│ └── sandboxes
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>├── io.containerd.runtime.v1.linux
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>│ └── k8s.io
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>├── io.containerd.runtime.v2.task
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>└── runc
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> └── k8s.io
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">8&lt;/span> directories, &lt;span style="color:#ae81ff">2&lt;/span> files
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h1 id="containerd-插件">Containerd 插件&lt;/h1></description></item><item><title>Docs: Containerd 配置详解</title><link>https://desistdaydream.github.io/docs/10.%E4%BA%91%E5%8E%9F%E7%94%9F/2.2.%E5%AE%9E%E7%8E%B0%E5%AE%B9%E5%99%A8%E7%9A%84%E5%B7%A5%E5%85%B7/Containerd/Containerd-%E9%85%8D%E7%BD%AE%E8%AF%A6%E8%A7%A3/Containerd-%E9%85%8D%E7%BD%AE%E8%AF%A6%E8%A7%A3/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/10.%E4%BA%91%E5%8E%9F%E7%94%9F/2.2.%E5%AE%9E%E7%8E%B0%E5%AE%B9%E5%99%A8%E7%9A%84%E5%B7%A5%E5%85%B7/Containerd/Containerd-%E9%85%8D%E7%BD%AE%E8%AF%A6%E8%A7%A3/Containerd-%E9%85%8D%E7%BD%AE%E8%AF%A6%E8%A7%A3/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://github.com/containerd/containerd/blob/main/docs/man/containerd-config.toml.5.md">Manual(手册),containerd-config.toml(5)&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://manpages.debian.org/bullseye/containerd/containerd-config.toml.5.en.html">Debian Manual&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>Containerd 使用 &lt;a href="https://desistdaydream.github.io/docs/2.%E7%BC%96%E7%A8%8B/%E6%97%A0%E6%B3%95%E5%88%86%E7%B1%BB%E7%9A%84%E8%AF%AD%E8%A8%80/TOML.md">TOML&lt;/a> 作为配置文件的格式，默认配置文件为 /etc/containerd/config.toml，我们可以通过命令来生成一个包含所有配置字段的默认配置文件&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>mkdir -p /etc/containerd
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>containerd config default &amp;gt; /etc/containerd/config.toml
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h1 id="配置文件详解">配置文件详解&lt;/h1>
&lt;h1 id="通用配置">[通用]配置&lt;/h1>
&lt;p>&lt;strong>version = 2&lt;/strong> #
&lt;strong>root = &amp;lt;STRING&amp;gt;&lt;/strong> # Containerd 持久化数据路径。&lt;code>默认值：/var/lib/containerd&lt;/code>。
&lt;strong>state = &amp;lt;STRING&amp;gt;&lt;/strong> # Containerd 临时数据路径。&lt;code>默认值：/run/containerd&lt;/code>。
&lt;strong>oom_score = 0&lt;/strong> # 设置 Containerd 的 OOM 权重。&lt;code>默认值：0&lt;/code>。
Containerd 是容器的守护者，一旦发生内存不足的情况，理想的情况应该是先杀死容器，而不是杀死 Containerd。所以需要调整 Containerd 的 &lt;code>OOM&lt;/code> 权重，减少其被 &lt;strong>OOM Kill&lt;/strong> 的几率。最好是将 &lt;code>oom_score&lt;/code> 的值调整为比其他守护进程略低的值。这里的 oom_socre 其实对应的是 &lt;code>/proc/&amp;lt;pid&amp;gt;/oom_socre_adj&lt;/code>，在早期的 Linux 内核版本里使用 &lt;code>oom_adj&lt;/code> 来调整权重, 后来改用 &lt;code>oom_socre_adj&lt;/code> 了。该文件描述如下：
在计算最终的 &lt;code>badness score&lt;/code> 时，会在计算结果是中加上 &lt;code>oom_score_adj&lt;/code> ,这样用户就可以通过该在值来保护某个进程不被杀死或者每次都杀某个进程。其取值范围为 &lt;code>-1000&lt;/code> 到 &lt;code>1000&lt;/code>。如果将该值设置为 &lt;code>-1000&lt;/code>，则进程永远不会被杀死，因为此时 &lt;code>badness score&lt;/code> 永远返回 0。建议 Containerd 将该值设置为 &lt;code>-999&lt;/code> 到 &lt;code>0&lt;/code> 之间。如果作为 Kubernetes 的 Worker 节点，可以考虑设置为 &lt;code>-999&lt;/code>。&lt;/p>
&lt;h1 id="cgroup-配置">[cgroup] 配置&lt;/h1>
&lt;h1 id="debug-配置">[debug] 配置&lt;/h1>
&lt;h1 id="grpc-配置表">[grpc] 配置表&lt;/h1>
&lt;p>&lt;strong>address = &amp;lt;STRING&amp;gt;&lt;/strong> # Containerd 监听的 GRPC 路径。&lt;code>默认值：/run/containerd/containerd.sock&lt;/code>&lt;/p>
&lt;h1 id="metrics-配置">[metrics] 配置&lt;/h1>
&lt;h1 id="plugins-配置">[plugins] 配置&lt;/h1>
&lt;p>详见 [《Plugin 配置》](/docs/10.云原生/2.2.实现容器的工具/Containerd/Containerd%20 配置详解/Plugin%20 配置.md 配置详解/Plugin 配置.md) 章节&lt;/p>
&lt;h1 id="timeouts-配置">[timeouts] 配置&lt;/h1>
&lt;h1 id="ttrpc-配置表">[ttrpc] 配置表&lt;/h1>
&lt;h1 id="配置文件示例">配置文件示例&lt;/h1>
&lt;h2 id="镜像加速配置示例">镜像加速配置示例&lt;/h2>
&lt;p>Containerd 的镜像仓库 mirror 与 Docker 相比有两个区别：&lt;/p>
&lt;ul>
&lt;li>Containerd 只支持通过 &lt;code>CRI&lt;/code> 拉取镜像的 mirror，也就是说，只有通过 &lt;code>crictl&lt;/code> 或者 Kubernetes 调用时 mirror 才会生效，通过 &lt;code>ctr&lt;/code> 拉取是不会生效的。&lt;/li>
&lt;li>&lt;code>Docker&lt;/code> 只支持为 &lt;code>Docker Hub&lt;/code> 配置 mirror，而 &lt;code>Containerd&lt;/code> 支持为任意镜像仓库配置 mirror。&lt;/li>
&lt;/ul>
&lt;p>所以需要修改的部分如下：&lt;/p>
&lt;pre>&lt;code>[plugins.&amp;quot;io.containerd.grpc.v1.cri&amp;quot;.registry]
[plugins.&amp;quot;io.containerd.grpc.v1.cri&amp;quot;.registry.mirrors]
[plugins.&amp;quot;io.containerd.grpc.v1.cri&amp;quot;.registry.mirrors.&amp;quot;docker.io&amp;quot;]
endpoint = [&amp;quot;https://dockerhub.mirrors.nwafu.edu.cn&amp;quot;]
[plugins.&amp;quot;io.containerd.grpc.v1.cri&amp;quot;.registry.mirrors.&amp;quot;k8s.gcr.io&amp;quot;]
endpoint = [&amp;quot;https://registry.aliyuncs.com/k8sxio&amp;quot;]
[plugins.&amp;quot;io.containerd.grpc.v1.cri&amp;quot;.registry.mirrors.&amp;quot;gcr.io&amp;quot;]
endpoint = [&amp;quot;xxx&amp;quot;]
&lt;/code>&lt;/pre>
&lt;h1 id="systemd-配置">Systemd 配置&lt;/h1>
&lt;p>建议通过 systemd 配置 Containerd 作为守护进程运行，配置文件在上文已经被解压出来了：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">[&lt;/span>Unit&lt;span style="color:#f92672">]&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Description&lt;span style="color:#f92672">=&lt;/span>containerd container runtime
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Documentation&lt;span style="color:#f92672">=&lt;/span>https://containerd.io
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>After&lt;span style="color:#f92672">=&lt;/span>network.target local-fs.target
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">[&lt;/span>Service&lt;span style="color:#f92672">]&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>ExecStartPre&lt;span style="color:#f92672">=&lt;/span>-/sbin/modprobe overlay
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>ExecStart&lt;span style="color:#f92672">=&lt;/span>/usr/local/bin/containerd
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Type&lt;span style="color:#f92672">=&lt;/span>notify
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Delegate&lt;span style="color:#f92672">=&lt;/span>yes
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>KillMode&lt;span style="color:#f92672">=&lt;/span>process
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Restart&lt;span style="color:#f92672">=&lt;/span>always
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>RestartSec&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">5&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># Having non-zero Limit*s causes performance problems due to accounting overhead&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># in the kernel. We recommend using cgroups to do container-local accounting.&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>LimitNPROC&lt;span style="color:#f92672">=&lt;/span>infinity
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>LimitCORE&lt;span style="color:#f92672">=&lt;/span>infinity
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>LimitNOFILE&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">1048576&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># Comment TasksMax if your systemd version does not supports it.&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># Only systemd 226 and above support this version.&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>TasksMax&lt;span style="color:#f92672">=&lt;/span>infinity
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>OOMScoreAdjust&lt;span style="color:#f92672">=&lt;/span>-999
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">[&lt;/span>Install&lt;span style="color:#f92672">]&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>WantedBy&lt;span style="color:#f92672">=&lt;/span>multi-user.target
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>这里有两个重要的参数：&lt;/p>
&lt;ul>
&lt;li>&lt;strong>Delegate&lt;/strong> : 这个选项允许 Containerd 以及运行时自己管理自己创建的容器的 &lt;code>cgroups&lt;/code>。如果不设置这个选项，systemd 就会将进程移到自己的 &lt;code>cgroups&lt;/code> 中，从而导致 Containerd 无法正确获取容器的资源使用情况。&lt;/li>
&lt;li>&lt;strong>KillMode&lt;/strong> : 这个选项用来处理 Containerd 进程被杀死的方式。默认情况下，systemd 会在进程的 cgroup 中查找并杀死 Containerd 的所有子进程，这肯定不是我们想要的。&lt;code>KillMode&lt;/code>字段可以设置的值如下。我们需要将 KillMode 的值设置为 &lt;code>process&lt;/code>，这样可以确保升级或重启 Containerd 时不杀死现有的容器。
&lt;ul>
&lt;li>&lt;strong>control-group&lt;/strong>（默认值）：当前控制组里面的所有子进程，都会被杀掉&lt;/li>
&lt;li>&lt;strong>process&lt;/strong>：只杀主进程&lt;/li>
&lt;li>&lt;strong>mixed&lt;/strong>：主进程将收到 SIGTERM 信号，子进程收到 SIGKILL 信号&lt;/li>
&lt;li>&lt;strong>none&lt;/strong>：没有进程会被杀掉，只是执行服务的 stop 命令。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul></description></item><item><title>Docs: CPU</title><link>https://desistdaydream.github.io/docs/0.%E8%AE%A1%E7%AE%97%E6%9C%BA/CPU/CPU/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/0.%E8%AE%A1%E7%AE%97%E6%9C%BA/CPU/CPU/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;p>&lt;strong>Central Processing Unit(中央处理器，简称 CPU)&lt;/strong>。
如同华硕主板示意图上半部的中央部分，那就是 CPU 插槽。由于 CPU 负责大量运算，因此 CPU 通常是具有相当高发热量的元件。所以如果你曾经拆开过主板，应该就会看到 CPU 上头通常会安插一颗风扇来主动散热的。&lt;/p>
&lt;p>x86 个人电脑的 CPU 主要供应商为 Intel 与 AMD，目前（2015）主流的 CPU 都是双核以上的架构了！原本的单核心 CPU 仅有一个运算单元，所谓的多核心则是在一颗 CPU 封装当中嵌入了两个以上的运算核心， 简单的说，就是一个实体的 CPU 外壳中，含有两个以上的 CPU 单元就是了。&lt;/p>
&lt;p>不同的 CPU 型号大多具有不同的脚位（CPU 上面的插脚），能够搭配的主板芯片组也不同， 所以当你想要将你的主机升级时，不能只考虑 CPU，你还得要留意你的主板上面所支持的 CPU 型号喔！不然买了最新的 CPU 也不能够安插在你的旧主板上头的！目前主流的 CPU 有 Intel 的 i3/i5/i7 系列产品中，甚至先后期出厂的类似型号的脚位也不同， 例如 i7-2600 使用 LGA1155 脚位而 i7-4790 则使用 FCLGA1150 脚位，挑选时必须要很小心喔！&lt;/p>
&lt;p>我们前面谈到 CPU 内部含有微指令集，不同的微指令集会导致 CPU 工作效率的优劣。除了这点之外， CPU 性能的比较还有什么呢？那就是 CPU 的频率了！什么是频率呢？简单的说， 频率就是 CPU 每秒钟可以进行的工作次数。所以频率越高表示这颗 CPU 单位时间内可以作更多的事情。举例来说，Intel 的 i7-4790 CPU 频率为 3.6GHz， 表示这颗 CPU 在一秒内可以进行 3.6x109 次工作，每次工作都可以进行少数的指令运行之意。&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/lgtxxk/1616168680795-7c145400-1473-4cdc-b525-3a106f810f80.gif" alt="">&lt;/p>
&lt;p>&lt;strong>Tips&lt;/strong>注意，不同的 CPU 之间不能单纯的以频率来判断运算性能喔！这是因为每颗 CPU 的微指令集不相同，架构也不见得一样，可使用的第二层高速缓存及其计算机制可能也不同，加上每次频率能够进行的工作指令数也不同！所以，频率目前仅能用来比较同款 CPU 的速度！&lt;/p>
&lt;p>CPU 的工作频率：外频与倍频&lt;/p>
&lt;p>早期的 CPU 架构主要通过北桥来链接系统最重要的 CPU、内存与显卡设备。因为所有的设备都得通过北桥来链接，因此每个设备的工作频率应该要相同。于是就有所谓的前端总线（FSB） 这个东西的产生。但因为 CPU 的运算速度比其他的设备都要来的快，又为了要满足 FSB 的频率，因此厂商就在 CPU 内部再进行加速， 于是就有所谓的外频与倍频了。&lt;/p>
&lt;p>总结来说，在早期的 CPU 设计中，所谓的外频指的是 CPU 与外部元件进行数据传输时的速度，倍频则是 CPU 内部用来加速工作性能的一个倍数， 两者相乘才是 CPU 的频率速度。例如 Intel Core 2 E8400 的内频为 3.0GHz，而外频是 333MHz，因此倍频就是 9 倍啰！（3.0G=333Mx9, 其中 1G=1000M）&lt;/p>
&lt;h2 id="超频">超频&lt;/h2>
&lt;p>&lt;strong>Tips&lt;/strong>很多计算机硬件玩家很喜欢玩“超频”，所谓的超频指的是：将 CPU 的倍频或者是外频通过主板的设置功能更改成较高频率的一种方式。但因为 CPU 的倍频通常在出厂时已经被锁定而无法修改，因此较常被超频的为外频。举例来说，像上述 3.0GHz 的 CPU 如果想要超频，可以将他的外频 333MHz 调整成为 400MHz，但如此一来整个主板的各个元件的运行频率可能都会被增加成原本的 1.333 倍(4/ 3)，虽然 CPU 可能可以到达 3.6GHz，但却因为频率并非正常速度，故可能会造成死机等问题。&lt;/p>
&lt;p>但如此一来所有的数据都被北桥卡死了，北桥又不可能比 CPU 更快，因此这家伙常常是系统性能的瓶颈。为了解决这个问题，新的 CPU 设计中， 已经将内存控制器整合到 CPU 内部，而链接 CPU 与内存、显卡的控制器的设计，在 Intel 部份使用 QPI （Quick Path Interconnect） 与 DMI 技术，而 AMD 部份则使用 Hyper Transport 了，这些技术都可以让 CPU 直接与内存、显卡等设备分别进行沟通，而不需要通过外部的链接芯片了。&lt;/p>
&lt;p>因为现在没有所谓的北桥了（整合到 CPU 内），因此，CPU 的频率设计就无须考虑得要同步的外频，只需要考虑整体的频率即可。所以，如果你经常有查阅自己 CPU 频率的习惯，当使用 cpu-z [9]这个软件时，应该会很惊讶的发现到，怎么外频变成 100MHz 而倍频可以到达 30 以上！相当有趣呢！&lt;/p>
&lt;p>&lt;strong>Tips&lt;/strong> 现在 Intel 的 CPU 会主动帮你超频喔！例如 i7-4790 这颗 CPU 的规格[10]中，基本频率为 3.6GHz，但是最高可自动超频到 4GHz 喔！通过的是 Intel 的 turbo 技术。同时，如果你没有大量的运算需求，该 CPU 频率会降到 1.xGHz 而已，借此达到节能省电的目的！所以，各位好朋友，不需要自己手动超频了！Intel 已经自动帮你进行超频了&amp;hellip;所以，如果你用 cpu-z 观察 CPU 频率，发现该频率会一直自动变动，很正常！你的系统没坏掉！&lt;/p>
&lt;p>32 位与 64 位的 CPU 与总线“宽度”&lt;/p>
&lt;p>从前面的简易说明中，我们知道 CPU 的各项数据通通得要来自于内存。因此，如果内存能提供给 CPU 的数据量越大的话，当然整体系统的性能应该也会比较快！那如何知道内存能提供的数据量呢？此时还是得要借由 CPU 内的内存控制芯片与内存间的传输速度“前端总线速度（Front Side Bus, FSB） 来说明。&lt;/p>
&lt;p>与 CPU 的频率类似的，内存也是有其工作的频率，这个频率限制还是来自于 CPU 内的内存控制器所决定的。以图 0.2.1 为例， CPU 内置的内存控制芯片对内存的工作频率最高可达到 1600MHz。这只是工作频率（每秒几次）。一般来说，每次频率能够传输的数据量，大多为 64 位，这个 64 位就是所谓的“宽度”了！因此，在图 0.2.1 这个系统中，CPU 可以从内存中取得的最快带宽就是 1600MHz &lt;em>64bit = 1600MHz&lt;/em> 8 Bytes = 12.8GByte/s。&lt;/p>
&lt;p>与总线宽度相似的，CPU 每次能够处理的数据量称为字组大小（word size）， 字组大小依据 CPU 的设计而有 32 位与 64 位。我们现在所称的电脑是 32 或 64 位主要是依据这个 CPU 解析的字组大小而来的！早期的 32 位 CPU 中，因为 CPU 每次能够解析的数据量有限， 因此由内存传来的数据量就有所限制了。这也导致 32 位的 CPU 最多只能支持最大到 4GBytes 的内存。&lt;/p>
&lt;p>&lt;strong>Tips&lt;/strong> 得利于北桥整合到 CPU 内部的设计，CPU 得以“个别”跟各个元件进行沟通！因此，每种元件与 CPU 的沟通具有很多不同的方式！例如内存使用系统总线带宽来与 CPU 沟通。而显卡则通过 PCI-E 的序列信道设计来与 CPU 沟通喔！详细说明我们在本章稍后的主板部份再来谈谈。&lt;/p>
&lt;p>CPU 等级&lt;/p>
&lt;p>由于 x86 架构的 CPU 在 Intel 的 Pentium 系列（1993 年）后就有不统一的脚位与设计，为了将不同种类的 CPU 规范等级， 所以就有 i386,i586,i686 等名词出现了。基本上，在 Intel Pentium MMX 与 AMD K6 年代的 CPU 称为 i586 等级， 而 Intel Celeron 与 AMD Athlon（K7）年代之后的 32 位 CPU 就称为 i686 等级。至于目前的 64 位 CPU 则统称为 x86_64 等级。&lt;/p>
&lt;p>目前很多的程序都有对 CPU 做最优化的设计，万一哪天你发现一些程序是注明给 x86_64 的 CPU 使用时， 就不要将他安装在 686 以下等级的电脑中，否则可是会无法执行该软件的！不过，在 x86_64 的硬件下倒是可以安装 386 的软件喔！也就是说，这些东西具有向下相容的能力啦！&lt;/p>
&lt;h2 id="超线程hyper-threading-ht">超线程（Hyper-Threading, HT）&lt;/h2>
&lt;p>我们知道现在的 CPU 至少都是两个核心以上的多核心 CPU 了，但是 Intel 还有个很怪的东西，叫做 CPU 的超线程（Hyper-Threading） 功能！那个是啥鬼东西？我们知道现在的 CPU 运算速度都太快了，因此运算核心经常处于闲置状态下。而我们也知道现在的系统大多都是多任务的系统， 同时间有很多的程序会让 CPU 来执行。因此，若 CPU 可以假象的同时执行两个程序，不就可以让系统性能增加了吗？反正 CPU 的运算能力还是没有用完啊！&lt;/p>
&lt;p>那是怎么达成的啊这个 HT 功能？强者鸟哥的同事蔡董大大用个简单的说明来解释。在每一个 CPU 内部将重要的寄存器（register） 分成两群， 而让程序分别使用这两群寄存器。也就是说，可以有两个程序“同时竞争 CPU 的运算单元”，而非通过操作系统的多任务切换！这一过程就会让 CPU 好像“同时有两个核心”的模样！因此，虽然大部分 i7 等级的 CPU 其实只有四个实体核心，但通过 HT 的机制， 则操作系统可以抓到八个核心！并且让每个核心逻辑上分离，就可以同时运行八个程序了。&lt;/p>
&lt;p>虽然很多研究与测试中，大多发现 HT 虽然可以提升性能，不过，有些情况下却可能导致性能降低喔！因为，实际上明明就仅有一个运算单元嘛！不过在鸟哥使用数值模式的情况下，因为鸟哥操作的数值模式主要为平行运算功能，且运算通常无法达到 100% 的 CPU 使用率，通常仅有大约 60%运算量而已。因此在鸟哥的实作过程中，这个 HT 确实提升相当多的性能！至少应该可以节省鸟哥大约 30%~50%的等待时间喔！不过网络上大家的研究中， 大多说这个是 case by case，而且使用的软件影响很大！所以，在鸟哥的例子是启用 HT 帮助很大！您的案例就得要自行研究啰！&lt;/p></description></item><item><title>Docs: CPU 管理工具</title><link>https://desistdaydream.github.io/docs/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/X.Linux-%E7%AE%A1%E7%90%86/Linux-%E7%B3%BB%E7%BB%9F%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/CPU-%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/X.Linux-%E7%AE%A1%E7%90%86/Linux-%E7%B3%BB%E7%BB%9F%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/CPU-%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;/blockquote></description></item><item><title>Docs: Cryptography(密码学)</title><link>https://desistdaydream.github.io/docs/7.%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8/Cryptography%E5%AF%86%E7%A0%81%E5%AD%A6/Cryptography%E5%AF%86%E7%A0%81%E5%AD%A6/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/7.%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8/Cryptography%E5%AF%86%E7%A0%81%E5%AD%A6/Cryptography%E5%AF%86%E7%A0%81%E5%AD%A6/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Cryptography">Wiki,Cryptography&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;h1 id="密码学背景">密码学背景&lt;/h1>
&lt;p>在现代时代之前，密码学着眼于消息的机密性（即加密），即将消息从一种可理解的形式转换为一种难以理解的形式，然后又在另一端再次转换，从而使拦截器或窃听者在没有秘密知识（即所需的密钥）的情况下无法读取该消息。用于解密该消息）。加密试图确保保密的通信，如那些间谍，军事领导人和外交官。在最近的几十年中，该领域已经超出了对机密性的关注范围，包括消息完整性检查，发送者/接收者身份验证，数字签名，交互式证明和安全计算等。&lt;/p>
&lt;h2 id="经典密码学">经典密码学&lt;/h2>
&lt;h2 id="现代密码学">现代密码学&lt;/h2>
&lt;p>现在我们谈论的密码学，都是现代密码学的范畴&lt;/p>
&lt;p>Public-key cryptography(公开密钥加密、非对称密钥加密)，以及根据公开密钥加密方式而衍生出的其他认证授权等基础设施，是当代最常见，也是最常用的方式.&lt;/p>
&lt;h1 id="现代加密方式">现代加密方式&lt;/h1>
&lt;h2 id="symmetric-key-algorithm对称密钥算法">Symmetric Key Algorithm(对称密钥算法)&lt;/h2>
&lt;blockquote>
&lt;p>参考： &lt;a href="https://en.wikipedia.org/wiki/Symmetric-key_algorithm">Wiki-Symmetir Key Algorithm&lt;/a>&lt;/p>
&lt;/blockquote>
&lt;p>使用相同的密钥来加密明文和解密密文&lt;/p>
&lt;p>算法：&lt;/p>
&lt;ol>
&lt;li>DES：Data Encryption Standard 数据加密标准。已被破解&lt;/li>
&lt;li>3DES：3 倍的 DES。最常用&lt;/li>
&lt;li>AES：Advanced Encryption Standard 高级加密标准。最常用&lt;/li>
&lt;li>Blowfish&lt;/li>
&lt;li>Twofish&lt;/li>
&lt;li>IDEA：商业加密算法&lt;/li>
&lt;/ol>
&lt;h3 id="ska-特点">SKA 特点&lt;/h3>
&lt;p>特性：&lt;/p>
&lt;ul>
&lt;li>加密和解密使用同一个密钥，效率高。&lt;/li>
&lt;li>将原始数据分割成固定大小的块，逐个进行加密；&lt;/li>
&lt;/ul>
&lt;p>缺点：&lt;/p>
&lt;ul>
&lt;li>密钥过多；&lt;/li>
&lt;li>密钥分发(分发密钥过程无法保证),为了解决对称加密算法每个人需要保存密钥过多的问题，可以使用公钥加密&lt;/li>
&lt;li>数据来源无法确认&lt;/li>
&lt;/ul>
&lt;h2 id="public-key-cryptography公开密钥密码学">Public Key Cryptography(公开密钥密码学)&lt;/h2>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Public-key_cryptography">Wiki,PKC 英文&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Digital_signature">Wiki,数字签名&lt;/a>&lt;/li>
&lt;li>&lt;a href="http://www.ruanyifeng.com/blog/2013/06/rsa_algorithm_part_one.html">阮一峰&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.zhihu.com/question/25912483">知乎,RSA 的公钥和私钥到底那个才是用来加密和哪个用来解密&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://zh.wikipedia.org/wiki/%E5%85%AC%E5%BC%80%E5%AF%86%E9%92%A5%E5%8A%A0%E5%AF%86">Wiki, 公开密钥加密 中文&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>**Public Key Cryptography(公开密钥密码学) &lt;strong>也称为&lt;/strong> Asymmetric Key Algorithm(非对称密钥算法)，**它是计算机通信安全的基石，保证了加密数据不会被破解。1976 年以前，所有的加密方法都是同一种模式：&lt;/p>
&lt;ul>
&lt;li>甲方选择某种加密规则，对信息进行加密&lt;/li>
&lt;li>乙方使用同一种规则，对信息进行解密&lt;/li>
&lt;/ul>
&lt;p>由于加密和解密使用同样规则（简称&amp;quot;密钥&amp;quot;），这被称为 Symmetric-key algorithm(对称密钥算法)。这种加密模式有一个最大弱点：甲方必须把加密规则告诉乙方，否则无法解密。保存和传递密钥，就成了最头疼的问题。因为大多数情况下，其实两方之间的通信，只有一方是需要加密的，另一方只需要知道信息内容。&lt;/p>
&lt;p>1976 年，两位美国计算机学家 Whitfield Diffie 和 Martin Hellman，提出了一种崭新构思，可以在不直接传递密钥的情况下，完成解密。这被称为&amp;quot;Diffie-Hellman 密钥交换算法&amp;quot;。这个算法启发了其他科学家。人们认识到，加密和解密可以使用不同的规则，只要这两种规则之间存在某种对应关系即可，这样就避免了直接传递密钥。&lt;/p>
&lt;p>这种新的加密模式就被称为&amp;quot;非对称密钥算法&amp;quot;。&lt;/p>
&lt;blockquote>
&lt;p>（1）乙方生成两把密钥（公钥和私钥）。公钥是公开的，任何人都可以获得，私钥则是保密的。
（2）甲方获取乙方的公钥，然后用它对信息加密。
（3）乙方得到加密后的信息，用私钥解密。&lt;/p>
&lt;/blockquote>
&lt;p>如果公钥加密的信息只有私钥解得开，那么只要私钥不泄漏，通信就是安全的。&lt;/p>
&lt;p>1977 年，三位数学家 Rivest、Shamir 和 Adleman 设计了一种算法，可以实现非对称加密。这种算法用他们三个人的名字命名，叫做 RSA 算法。从那时直到现在，RSA 算法一直是最广为使用的&amp;quot;非对称加密算法&amp;quot;。毫不夸张地说，只要有计算机网络的地方，就有 RSA 算法。&lt;/p>
&lt;p>这种算法非常可靠，密钥越长，它就越难破解。根据已经披露的文献，目前被破解的最长 RSA 密钥是 768 个二进制位。也就是说，长度超过 768 位的密钥，还无法破解（至少没人公开宣布）。因此可以认为，1024 位的 RSA 密钥基本安全，2048 位的密钥极其安全。&lt;/p>
&lt;h3 id="pkc-特点">PKC 特点&lt;/h3>
&lt;ul>
&lt;li>这种加密方式，需要一对密钥。只有公钥可以加密，私钥不能用来加密数据。&lt;/li>
&lt;li>&lt;strong>Public key(公钥)&lt;/strong> # 公开给所有人。用来加密数据、验证签名。使用公钥把明文加密后所得的密文，只能使用对应的私钥才能解密并得到原本的密文。反之不行。&lt;/li>
&lt;li>&lt;strong>Secret key(私钥)&lt;/strong> # 自己留存，必须保证其私密性。用来解密数据、签名。使用私钥创建数字签名，只能使用公钥才能验证该数字签名的有效性。反之不行。
&lt;ul>
&lt;li>一般情况，密钥对是通过程序自动生成的。首先生成私钥后，公钥包含在私钥当中&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>Digital signature(数字签名)&lt;/strong>。签名提供的是真实性，而不是保密性。
&lt;ul>
&lt;li>所谓的数字签名，就像人们日常生活中在文件上签字一样，都是签名的一种。&lt;/li>
&lt;li>而所谓的验证签名，其实就像日常生活中，看看签名的人的笔记与签名是否一致，等等类似的行为&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>总结一下：既然是加密，那肯定是不希望别人知道发送给我的消息，所以只有我才能解密，所以可得出&lt;strong>公钥负责加密，私钥负责解密&lt;/strong>；同理，既然是签名，那肯定是不希望有人冒充我发消息，只有我才能发布这个签名，所以可得出&lt;strong>私钥负责签名，公钥负责验证&lt;/strong>。&lt;/p>
&lt;ul>
&lt;li>这种加密方式由于是单向加密、单向解密，所以如果双方都想要加密，则需要两对密钥，双方各自用对方的公钥加密信息发送给对方，然后双方再用自己的私钥解密阅读信息。&lt;/li>
&lt;/ul>
&lt;h3 id="应用场景">应用场景&lt;/h3>
&lt;ul>
&lt;li>如果 A 持有私钥，B 持有对应公钥。那么此时 B 用对方的公钥加密一个对称密钥并发送给 A，A 使用私钥解密，以获得 B 发送的对称密钥，这时再发送的数据可以使用对称加密。&lt;/li>
&lt;li>在互联网的 C/S 架构场景中。Server 公开公钥，Client 使用公钥加密信息发送给 Server(发送密码等敏感信息)，Server 使用私钥解密后响应时，使用私钥签名，以便 Client 可以用公钥验证 Server 的真实性(防止钓鱼网站)。&lt;/li>
&lt;li>如图所示，Alice 在一条消息的末尾签了名，消息内容是 &lt;code>Hello Bob!&lt;/code>，这段签署的内容一般是对消息内容进行 hash 计算后，使用 Alice 的私钥的出来的。鲍勃同时收到消息和签名。他使用 Alice 的公钥来验证消息的真实性，即，如果使用公钥计算得出来的消息与原始消息完全匹配，那就证明，这条消息确实是 Alice 发送的。&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/as985c/1616125981836-028fe2ce-77f2-4929-91cc-559c4ce9cda1.png" alt="">&lt;/p>
&lt;p>算法：&lt;/p>
&lt;ol>
&lt;li>RSA&lt;/li>
&lt;li>DSA&lt;/li>
&lt;li>ELGamal&lt;/li>
&lt;/ol>
&lt;p>缺点&lt;/p>
&lt;ol>
&lt;li>公钥加密可能出现的问题：当两者需要通信的时候，需要把公钥发送给对方，但是公钥是谁都可以获取的，那么在二者通信过程中，公钥就有可能被劫持，当公钥被劫持，劫持者把自己的公钥再发送给对方，那么双发再收到的信息，就是被劫持者篡改过的信息了。
&lt;ol>
&lt;li>&lt;a href="https://www.yuque.com/go/doc/33177961">&lt;strong>Public Key Certificate(公钥证书)&lt;/strong>&lt;/a> 可以解决以上问题&lt;/li>
&lt;/ol>
&lt;/li>
&lt;/ol>
&lt;h2 id="cryptographic-hash-function单向加密加密散列函数">Cryptographic hash function(单向加密、加密散列函数)&lt;/h2>
&lt;p>只能加密，不能解密，提取数据特征码，用来保证数据的完成性，实现数据的完整性校验&lt;/p>
&lt;p>通常用来做数字证书的数字签名，提取数据的特征码后进行加密并放到数据后端，用来校验证书的完整性，所以证书的内容是被认可的&lt;/p>
&lt;p>特点：定长输出、雪崩效应(原始数据的微小改变会导致计算结果的完全不同)&lt;/p>
&lt;p>算法：&lt;/p>
&lt;ol>
&lt;li>md5&lt;/li>
&lt;li>sha1&lt;/li>
&lt;li>sha256&lt;/li>
&lt;li>sha384&lt;/li>
&lt;li>sha512&amp;hellip;.等&lt;/li>
&lt;/ol>
&lt;p>MAC:Message Authentication Code(消息认证码)，单向加密的一种延伸应用，用于实现在网络通信中保证所传输的数据的完整性&lt;/p></description></item><item><title>Docs: Data Type(数据类型) 与 Literal(字面量)</title><link>https://desistdaydream.github.io/docs/2.%E7%BC%96%E7%A8%8B/%E8%A7%A3%E8%B0%9C%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/Data-Type%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B-%E4%B8%8E-Literal%E5%AD%97%E9%9D%A2%E9%87%8F/Data-Type%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B-%E4%B8%8E-Literal%E5%AD%97%E9%9D%A2%E9%87%8F/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/2.%E7%BC%96%E7%A8%8B/%E8%A7%A3%E8%B0%9C%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/Data-Type%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B-%E4%B8%8E-Literal%E5%AD%97%E9%9D%A2%E9%87%8F/Data-Type%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B-%E4%B8%8E-Literal%E5%AD%97%E9%9D%A2%E9%87%8F/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Data_type">Wiki,DataType&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Abstract_data_type">Wiki,Abstract Data Type&lt;/a>(抽象数据类型)&lt;/li>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Literal_(computer_programming)">Wiki,Literal(字面量)&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>在计算机科学和计算机编程中，&lt;strong>Data Type(数据类型，有时也简称 Type)&lt;/strong> 是数据的一个属性，这些属性将会让编译器知道程序员想要如何使用数据。&lt;/p>
&lt;p>在计算机科学中，&lt;strong>Literal(字面量)&lt;/strong> 是表示源代码中固定值的 snotation(表示法)。几乎所有计算机编程语言都具有对基本值的字面量表示，诸如：整数、浮点数以及字符串；而有很多也对布尔类型和字符类型的值也支持字面量表示；还有一些甚至对枚举类型的元素以及像数组、记录和对象等复合类型的值也支持字面量表示法。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// b 为常量，10为字面量,数据类型为整数
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">const&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#a6e22e">b&lt;/span> = &lt;span style="color:#ae81ff">10&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// str 为变量，hello world！为字面量，数据类型为字符串
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">string&lt;/span> &lt;span style="color:#a6e22e">str&lt;/span> = &lt;span style="color:#e6db74">&amp;#34;hello world！&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h1 id="数据类型的分类">数据类型的分类&lt;/h1>
&lt;ul>
&lt;li>原始数据类型&lt;/li>
&lt;li>复合类型&lt;/li>
&lt;li>抽象数据类型&lt;/li>
&lt;li>其他类型&lt;/li>
&lt;/ul>
&lt;h2 id="primitive-data-types原始数据类型">Primitive Data Types(原始数据类型)&lt;/h2>
&lt;p>&lt;a href="https://en.wikipedia.org/wiki/Primitive_data_type">原始数据类型&lt;/a>通常是语言实现的内置或基础类型。&lt;/p>
&lt;h3 id="machine-data-type机器数据类型">Machine Data Type(机器数据类型)&lt;/h3>
&lt;p>基于数字电子的计算机中的所有数据都表示为最低级别的&lt;a href="https://en.wikipedia.org/wiki/Bit">位&lt;/a>（替代 0 和 1）。数据的最小可寻址单元通常是一组称为&lt;a href="https://en.wikipedia.org/wiki/Byte">字节&lt;/a>的位（通常是一个&lt;a href="https://en.wikipedia.org/wiki/Octet_(computing)">八位组&lt;/a>，即 8 位）。由&lt;a href="https://en.wikipedia.org/wiki/Machine_code">机器代码&lt;/a>指令处理的单元称为&lt;a href="https://en.wikipedia.org/wiki/Word_(data_type)">字&lt;/a>（截至 2011 年，通常为 32 或 64 位）。大多数指令将字解释为&lt;a href="https://en.wikipedia.org/wiki/Binary_number">二进制数&lt;/a>，因此 32 位字可以表示从 0 到 232 - 1 或有符号整数值来自 -231 到 231 - 1 由于&lt;a href="https://en.wikipedia.org/wiki/Two%27s_complement">二进制补码&lt;/a>，机器语言和机器在大多数情况下不需要区分这些无符号和有符号数据类型。&lt;/p>
&lt;p>用于浮点算术的浮点数对字中的位使用不同的解释。有关详细信息，请参阅&lt;a href="https://en.wikipedia.org/wiki/Floating-point_arithmetic">浮点运算&lt;/a>。&lt;/p>
&lt;p>机器数据类型需要在&lt;a href="https://en.wikipedia.org/wiki/Systems_programming">系统&lt;/a>或&lt;a href="https://en.wikipedia.org/wiki/Low-level_programming_language">低级编程语言中&lt;/a>公开或可用，允许对硬件进行细粒度控制。的&lt;a href="https://en.wikipedia.org/wiki/C_programming_language">C 编程语言&lt;/a>，例如，建筑材料整数类型不同的宽度，如和。如果目标平台上不存在相应的本机类型，编译器将使用确实存在的类型将它们分解为代码。例如，如果在 16 位平台上请求一个 32 位整数，编译器会默认将其视为两个 16 位整数的数组。 shortlong&lt;/p>
&lt;p>在更高级别的编程中，机器数据类型通常被隐藏或_抽象_为一个实现细节，如果暴露，会使代码的可移植性降低。例如，numeric 可以提供泛型类型而不是某些特定位宽的整数。&lt;/p>
&lt;h3 id="boolean-type布尔类型">Boolean Type(布尔类型)&lt;/h3>
&lt;p>&lt;a href="https://en.wikipedia.org/wiki/Boolean_type">Boolean(布尔)&lt;/a> 类型表示值 &lt;a href="https://en.wikipedia.org/wiki/Logical_truth">true(真)&lt;/a> 和 &lt;a href="https://en.wikipedia.org/wiki/Logical_truth">false(假)&lt;/a>。尽管只有两个值是可能的，但出于效率原因，它们很少被实现为单个二进制数字。许多编程语言没有明确的布尔类型，&lt;strong>而是将 0 解释为 false，将其他值解释为 true&lt;/strong>。布尔数据是指如何将语言解释为机器语言的逻辑结构。在这种情况下，布尔值 0 指的是逻辑 False。True 总是非零，尤其是被称为布尔值 1 的一。&lt;/p>
&lt;h3 id="numeric-type数字类型">Numeric Type(数字类型)&lt;/h3>
&lt;ul>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Integer_(computing)">Integer(整数，简写 int)&lt;/a> 数据类型，或“非分数”。可以根据它们包含负值的能力进行子类型化（例如 unsigned 在 C 和 C++ 中）。也可具有小的预定义数目的亚型（如 short 和 long 在 C / C ++）; 或允许用户自由定义子范围，例如 1..12（例如&lt;a href="https://en.wikipedia.org/wiki/Pascal_(programming_language)">Pascal&lt;/a> / &lt;a href="https://en.wikipedia.org/wiki/Ada_(programming_language)">Ada&lt;/a>）。&lt;/li>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Floating_point">Floating Point(浮点)&lt;/a> 数据类型通常将值表示为高精度分数值（&lt;a href="https://en.wikipedia.org/wiki/Rational_numbers">有理数&lt;/a>，数学上），但有时会误导性地称为实数（令人联想到数学&lt;a href="https://en.wikipedia.org/wiki/Real_numbers">实数&lt;/a>）。它们通常对最大值和精度都有预定义的限制。通常以 a × 2 b 的形式在内部存储（其中 a 和 b 是整数），但以熟悉的&lt;a href="https://en.wikipedia.org/wiki/Decimal">十进制&lt;/a>形式显示。&lt;/li>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Fixed_point_(computing)">Fixed Point(定点)&lt;/a> 数据类型便于表示货币值。它们通常在内部实现为整数，从而导致预定义的限制。&lt;/li>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Bignum">Bignum&lt;/a>或&lt;a href="https://en.wikipedia.org/wiki/Arbitrary_precision">任意精度&lt;/a>数字类型缺乏预定义的限制。它们不是原始类型，出于效率原因很少使用。&lt;/li>
&lt;/ul>
&lt;h3 id="enumerations枚举">Enumerations(枚举)&lt;/h3>
&lt;p>&lt;a href="https://en.wikipedia.org/wiki/Enumerated_type">枚举类型&lt;/a>具有不同的值，其可以被比较和分配，但不一定必须在计算机的存储器中的任何特定的具体表示; 编译器和解释器可以任意表示它们。例如，一副扑克牌中的四个花色可能是名为 CLUB、DIAMOND、HEART、SPADE 的四个枚举数，属于一个名为 suit 的枚举类型。如果变量 V 被声明为具有花色作为它的数据类型，可以为它分配这四个值中的任何一个。一些实现允许程序员为枚举值分配整数值，甚至将它们视为与整数类型等效的。&lt;/p>
&lt;h2 id="composite-types复合类型">Composite Types(复合类型)&lt;/h2>
&lt;p>&lt;a href="https://en.wikipedia.org/wiki/Composite_type">复合类型&lt;/a>派生自多个原始类型。这可以通过多种方式完成。它们组合的方式称为&lt;a href="https://en.wikipedia.org/wiki/Data_structure">数据结构&lt;/a>。构成一个基本类型为化合物类型通常导致新类型，例如阵列的整数是一个不同类型的整数。&lt;/p>
&lt;ul>
&lt;li>&lt;strong>&lt;a href="https://en.wikipedia.org/wiki/Array_data_type">Array(数组)&lt;/a>&lt;/strong>，也称为载体，&lt;strong>&lt;a href="https://en.wikipedia.org/wiki/List_(abstract_data_type)">列表或序列&lt;/a>&lt;/strong> 的存储数量的元件，并提供&lt;a href="https://en.wikipedia.org/wiki/Random_access">随机接入&lt;/a>到单个元件。数组的元素通常（但并非在所有上下文中）需要具有相同的类型。数组可以是固定长度的或可扩展的。数组中的索引通常需要是来自特定范围的整数（如果不是，可以通过谈论&lt;a href="https://en.wikipedia.org/wiki/Associative_array">关联数组&lt;/a>来强调这种放松）（如果不是该范围内的所有索引都对应于元素，则它可能是一个&lt;a href="https://en.wikipedia.org/wiki/Sparse_array">稀疏数组&lt;/a>）。&lt;/li>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Record_(computer_science)">&lt;strong>Record(记录)，也称为 tuple(元组) 或 struct(结构)&lt;/strong>&lt;/a> 是最简单的&lt;a href="https://en.wikipedia.org/wiki/Data_structure">数据结构之一&lt;/a>。记录是包含其他值的值，通常采用固定数量和顺序，通常按 1 名称索引。记录的元素通常称为 &lt;strong>Fields(字段)&lt;/strong> 或 &lt;strong>Members(成员)&lt;/strong>。&lt;/li>
&lt;li>&lt;strong>&lt;a href="https://en.wikipedia.org/wiki/Union_type">Union(联合)&lt;/a>&lt;/strong> 类型定义将指定许多允许的原始类型中的哪一个可以存储在其实例中，例如“浮点数或长整数”。与&lt;a href="https://en.wikipedia.org/wiki/Record_(computer_science)">记录&lt;/a>相反，&lt;a href="https://en.wikipedia.org/wiki/Record_(computer_science)">记录&lt;/a>可以定义为包含一个浮点数和一个整数；而在联合中，一次只允许一种类型。
&lt;ul>
&lt;li>甲&lt;a href="https://en.wikipedia.org/wiki/Tagged_union">标签联合&lt;/a>（也称为&lt;a href="https://en.wikipedia.org/wiki/Variant_type">变体&lt;/a>，变体记录，识别联合，或不相交并）包含一个附加的字段，指示其当前型增强型安全性。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Set_(abstract_data_type)">&lt;strong>Set(集)&lt;/strong>&lt;/a> 是一个&lt;a href="https://en.wikipedia.org/wiki/Abstract_data_structure">抽象的数据结构&lt;/a>可以存储某些值，没有任何特别的&lt;a href="https://en.wikipedia.org/wiki/Sequence">顺序&lt;/a>，并且不重复的值。值本身不是从集合中检索的，而是测试成员资格的值以获得布尔值“in”或“not in”。&lt;/li>
&lt;li>&lt;strong>&lt;a href="https://en.wikipedia.org/wiki/Object_(computer_science)">Object(对象)&lt;/a>&lt;/strong> 包含许多数据字段，如 Record，以及许多用于访问或修改它们的子程序，称为 &lt;a href="https://en.wikipedia.org/wiki/Method_(computer_programming)">Methods(方法)&lt;/a>。&lt;/li>
&lt;/ul>
&lt;p>许多其他的都是可能的，但它们往往是上述的进一步变体和化合物。例如，&lt;a href="https://en.wikipedia.org/wiki/Linked_list">链表&lt;/a>可以存储与数组相同的数据，但提供&lt;a href="https://en.wikipedia.org/wiki/Sequential_access">顺序访问&lt;/a>而不是随机&lt;a href="https://en.wikipedia.org/wiki/Sequential_access">访问&lt;/a>，并且由&lt;a href="https://en.wikipedia.org/wiki/Dynamic_memory">动态内存中&lt;/a>的记录组成；虽然可以说是一种数据结构而不是类型本身，但它也很常见且足够独特，因此将其包含在复合类型的讨论中是合理的。&lt;/p>
&lt;h3 id="string字符串-和-text文本-类型">String(字符串) 和 Text(文本) 类型&lt;/h3>
&lt;ul>
&lt;li>一个&lt;a href="https://en.wikipedia.org/wiki/Character_(computing)">字符&lt;/a>，可能是某个&lt;a href="https://en.wikipedia.org/wiki/Alphabet">字母表&lt;/a>中的一个&lt;a href="https://en.wikipedia.org/wiki/Alphabet">字母&lt;/a>、一个数字、一个空格、一个标点符号等。&lt;/li>
&lt;li>一个&lt;a href="https://en.wikipedia.org/wiki/String_(computer_science)">字符串&lt;/a>，它是一个字符序列。字符串通常用于表示单词和文本，尽管除了最琐碎的情况外，所有文本都不仅仅涉及字符序列。&lt;/li>
&lt;/ul>
&lt;p>字符和字符串类型可以存储字符集（例如&lt;a href="https://en.wikipedia.org/wiki/ASCII">ASCII ）中&lt;/a>的字符序列。由于大多数字符集都包含&lt;a href="https://en.wikipedia.org/wiki/Numerical_digit">数字&lt;/a>，因此可以使用数字字符串，例如&amp;quot;1234&amp;quot;. 但是，许多语言将它们视为属于与数值不同的类型 1234。&lt;/p>
&lt;p>根据所需的字符“宽度”，字符和字符串类型可以有不同的子类型。最初的 7 位宽 ASCII 被发现是有限的，并被 8 位和 16 位集取代，它们可以编码各种各样的非拉丁字母（如&lt;a href="https://en.wikipedia.org/wiki/Hebrew">希伯来语&lt;/a>和&lt;a href="https://en.wikipedia.org/wiki/Chinese_language">中文&lt;/a>）和其他符号。字符串可以是适合拉伸的，也可以是固定大小的，即使是在相同的编程语言中。它们也可以按其最大大小进行子类型化。&lt;/p>
&lt;p>注意：字符串不是所有语言中的原始数据类型。例如，在 &lt;a href="https://en.wikipedia.org/wiki/C_(programming_language)">C 语言&lt;/a> 中，它们由字符数组组成。&lt;/p>
&lt;h2 id="abstract-data-types抽象数据类型">Abstract Data Types(抽象数据类型)&lt;/h2>
&lt;p>任何未指定数据具体表示的&lt;a href="https://en.wikipedia.org/wiki/Abstract_data_type">数据类型&lt;/a> 都是 &lt;strong>Abstract Data Type(抽象数据类型，简称 ADT)&lt;/strong>。相反，使用基于数据类型操作的正式规范来描述它。规范的任何实现都必须满足给定的规则。抽象数据类型用于形式&lt;a href="https://en.wikipedia.org/wiki/Semantics_(computer_science)">语义&lt;/a>和程序&lt;a href="https://en.wikipedia.org/wiki/Formal_verification">验证，&lt;/a>并且不太严格地用于&lt;a href="https://en.wikipedia.org/wiki/Design">设计&lt;/a>。&lt;/p>
&lt;p>除了验证之外，规范可能会立即转变为实现。例如，&lt;a href="https://en.wikipedia.org/wiki/OBJ_(programming_language)">OBJ&lt;/a>系列编程语言基于此选项，使用&lt;a href="https://en.wikipedia.org/wiki/Equation">等式&lt;/a>进行规范并&lt;a href="https://en.wikipedia.org/wiki/Rewriting">重写&lt;/a>以运行它们。&lt;a href="https://en.wikipedia.org/wiki/Algebraic_specification">代数规范&lt;/a>&lt;a href="https://en.wikipedia.org/wiki/Data_type#cite_note-3">[3]&lt;/a>是 1980 年左右 CS 的一个重要研究课题，几乎是当时抽象数据类型的同义词。它具有&lt;a href="https://en.wikipedia.org/wiki/Universal_algebra">通用代数&lt;/a>的数学基础。&lt;a href="https://en.wikipedia.org/wiki/Data_type#cite_note-4">[4]&lt;/a>通过允许其他公式而不仅仅是方程，可以使规范语言更具表现力。&lt;/p>
&lt;p>一个典型的例子是&lt;a href="https://en.wikipedia.org/wiki/List_(abstract_data_type)">list&lt;/a>、&lt;a href="https://en.wikipedia.org/wiki/Set_(abstract_data_type)#Multiset">bag&lt;/a>和&lt;a href="https://en.wikipedia.org/wiki/Set_(computer_science)">set&lt;/a>数据类型的层次结构。所有这些数据类型都可以通过三个操作声明：null，它构造空容器，single，它从单个元素构造一个容器，append，它组合了两个相同类型的容器。然后，可以通过对这些操作的以下规则来给出三种数据类型的完整规范：&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>- null 是左右中性：&lt;/th>
&lt;th>追加（空，A）= A，追加（A，空）= A。&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>- 对于列表，append 是关联的：&lt;/td>
&lt;td>追加（追加（A，B），C）=追加（A，追加（B，C））。&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>- 袋子增加交换性：&lt;/td>
&lt;td>追加（B，A）=追加（A，B）。&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>- 最后，集合也是幂等的：&lt;/td>
&lt;td>追加（A，A）= A。&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>可以通过以下方式指定对数据的访问，例如这些容器的成员函数：&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>- 成员（X，单（Y））= eq（X，Y）&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>- 成员（X，空）= 假&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>- 成员(X,append(A,B)) = or(member(X,A), member(X,B))&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="associative-array关联数组也称为-map">Associative array(关联数组，也称为 map)&lt;/h3>
&lt;h2 id="其他类型">其他类型&lt;/h2>
&lt;p>类型可以基于或派生自上述基本类型。在某些语言（例如 C）中，&lt;a href="https://en.wikipedia.org/wiki/Function_(computer_science)">函数&lt;/a>具有从其&lt;a href="https://en.wikipedia.org/wiki/Return_value">返回值&lt;/a>的类型派生的类型。&lt;/p>
&lt;h3 id="pointer指针-和-reference引用">Pointer(指针) 和 Reference(引用)&lt;/h3>
&lt;p>主条目：&lt;a href="https://en.wikipedia.org/wiki/Reference_(computer_science)">引用(计算机科学）&lt;/a>
主要的非复合派生类型是&lt;a href="https://en.wikipedia.org/wiki/Pointer_(computer_programming)">指针&lt;/a>，这是一种数据类型，其值直接引用（或“指向”）使用其&lt;a href="https://en.wikipedia.org/wiki/Memory_address">地址&lt;/a>存储在&lt;a href="https://en.wikipedia.org/wiki/Computer_memory">计算机内存中&lt;/a>其他位置的另一个值。它是一种原始的&lt;a href="https://en.wikipedia.org/wiki/Reference_(computer_science)">参考&lt;/a>。（在日常生活中，一本书的页码可以被认为是引用另一本书的一段数据）。指针通常以类似于整数的格式存储；但是，尝试取消引用或“查找”其值永远不是有效内存地址的指针会导致程序崩溃。为了改善这个潜在问题，指针被认为是指向它们指向的数据类型的单独类型，即使底层表示相同。&lt;/p>
&lt;h3 id="function函数-类型">Function(函数) 类型&lt;/h3>
&lt;p>主条目：&lt;a href="https://en.wikipedia.org/wiki/Function_type">函数类型&lt;/a>
虽然也可以为函数分配类型，但在本文的设置中，它们的类型不被视为数据类型。在这里，数据被视为不同于&lt;a href="https://en.wikipedia.org/wiki/Algorithm">算法&lt;/a>。在编程中，函数与后者密切相关。但是，因为&lt;a href="https://en.wikipedia.org/wiki/Universal_Turing_machine">通用数据处理的&lt;/a>一个中心原则是算法可以&lt;a href="https://en.wikipedia.org/wiki/G%C3%B6del_numbering#Generalizations">表示为数据&lt;/a>，例如文本描述和二进制程序，数据和函数之间的对比是有限的。其实函数不仅可以用数据来表示，函数也可以用来&lt;a href="https://en.wikipedia.org/wiki/Lambda_calculus#Encoding_datatypes">对数据&lt;/a>进行&lt;a href="https://en.wikipedia.org/wiki/Lambda_calculus#Encoding_datatypes">编码&lt;/a>。许多当代&lt;a href="https://en.wikipedia.org/wiki/Type_systems">类型系统&lt;/a>强烈关注函数类型，许多现代语言允许函数作为&lt;a href="https://en.wikipedia.org/wiki/First-class_citizen">一等公民运行&lt;/a>。
将函数从被视为数据类型的对象中排除在相关领域中并不少见。[&lt;a href="https://en.wikipedia.org/wiki/Wikipedia:Citation_needed">需要引用&lt;/a>] 例如，&lt;a href="https://en.wikipedia.org/wiki/Predicate_logic">谓词逻辑&lt;/a>不允许在函数或谓词名称上应用&lt;a href="https://en.wikipedia.org/wiki/Quantifier_(logic)">量词&lt;/a>。&lt;/p>
&lt;h3 id="meta元-类型">Meta(元) 类型&lt;/h3>
&lt;p>主条目：&lt;a href="https://en.wikipedia.org/wiki/Metaclass">元类&lt;/a>
一些编程语言将类型信息表示为数据，从而实现&lt;a href="https://en.wikipedia.org/wiki/Type_introspection">类型自省&lt;/a>和&lt;a href="https://en.wikipedia.org/wiki/Reflection_(computer_programming)">反射&lt;/a>。相比之下，&lt;a href="https://en.wikipedia.org/wiki/Type_constructor">高阶&lt;/a> &lt;a href="https://en.wikipedia.org/wiki/Type_systems">类型系统&lt;/a>虽然允许从其他类型构造类型并作为值传递给函数，但通常避免基于它们进行&lt;a href="https://en.wikipedia.org/wiki/Computational">计算&lt;/a>决策。[&lt;a href="https://en.wikipedia.org/wiki/Wikipedia:Citation_needed">需要引用&lt;/a>]&lt;/p>
&lt;h3 id="utility实用程序-类型">Utility(实用程序) 类型&lt;/h3>
&lt;p>为方便起见，高级语言可能提供现成的“现实世界”数据类型，例如时间、日期、货币值和内存，即使该语言允许从原始类型构建它们。&lt;/p></description></item><item><title>Docs: Domains</title><link>https://desistdaydream.github.io/docs/10.%E4%BA%91%E5%8E%9F%E7%94%9F/1.2.%E5%AE%9E%E7%8E%B0%E8%99%9A%E6%8B%9F%E5%8C%96%E7%9A%84%E5%B7%A5%E5%85%B7/%E8%99%9A%E6%8B%9F%E5%8C%96%E7%AE%A1%E7%90%86/Libvirt/XML-%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3/Domain-XML/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/10.%E4%BA%91%E5%8E%9F%E7%94%9F/1.2.%E5%AE%9E%E7%8E%B0%E8%99%9A%E6%8B%9F%E5%8C%96%E7%9A%84%E5%B7%A5%E5%85%B7/%E8%99%9A%E6%8B%9F%E5%8C%96%E7%AE%A1%E7%90%86/Libvirt/XML-%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3/Domain-XML/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://libvirt.org/formatdomain.html">官方文档，Domain XML 格式&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>Domain 元素中有如下属性：&lt;/p>
&lt;ul>
&lt;li>&lt;strong>type&lt;/strong> # 指定用于运行域的管理程序。允许的值是特定于驱动程序的，但包括“xen”、“kvm”、“hvf”（自 8.1.0 和 QEMU 2.12 起）、“qemu”和“lxc”。&lt;/li>
&lt;li>&lt;strong>id&lt;/strong> # 它是正在运行的客户机的唯一整数标识符。非活动机器没有 id 值。&lt;/li>
&lt;/ul>
&lt;p>下列元素都属于 &lt;code>&amp;lt;domain&amp;gt;&lt;/code> 这个根元素的子元素&lt;/p>
&lt;ul>
&lt;li>TODO:&lt;/li>
&lt;li>&amp;hellip;&amp;hellip;&lt;/li>
&lt;li>&lt;a href="#devices">devices&lt;/a>&lt;/li>
&lt;li>&amp;hellip;&amp;hellip;&lt;/li>
&lt;/ul>
&lt;h1 id="graphical-framebuffers">Graphical framebuffers&lt;/h1>
&lt;p>&lt;a href="https://libvirt.org/formatdomain.html#graphical-framebuffers">https://libvirt.org/formatdomain.html#graphical-framebuffers&lt;/a>&lt;/p>
&lt;h1 id="devices">Devices&lt;/h1>
&lt;p>&lt;a href="https://libvirt.org/formatdomain.html#devices">https://libvirt.org/formatdomain.html#devices&lt;/a>&lt;/p>
&lt;h2 id="network-interfaces">Network interfaces&lt;/h2>
&lt;p>&lt;a href="https://libvirt.org/formatdomain.html#network-interfaces">https://libvirt.org/formatdomain.html#network-interfaces&lt;/a>&lt;/p></description></item><item><title>Docs: ECMAScript 第三方库</title><link>https://desistdaydream.github.io/docs/2.%E7%BC%96%E7%A8%8B/%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/ECMAScript/ECMAScript-%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/ECMAScript-%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/2.%E7%BC%96%E7%A8%8B/%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/ECMAScript/ECMAScript-%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/ECMAScript-%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/</guid><description>
&lt;h1 id="postman">Postman&lt;/h1>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-javascript" data-lang="javascript">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 将响应体解析为 JSON 格式
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#a6e22e">respBodyJSON&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#a6e22e">JSON&lt;/span>.&lt;span style="color:#a6e22e">parse&lt;/span>(&lt;span style="color:#a6e22e">responseBody&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">respBodyJSON&lt;/span>.&lt;span style="color:#a6e22e">data&lt;/span>.&lt;span style="color:#a6e22e">forEach&lt;/span>(&lt;span style="color:#66d9ef">function&lt;/span> (&lt;span style="color:#a6e22e">item&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">console&lt;/span>.&lt;span style="color:#a6e22e">log&lt;/span>(&lt;span style="color:#a6e22e">item&lt;/span>.&lt;span style="color:#a6e22e">title&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>})
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h1 id="axios">Axios&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://github.com/axios/axios">GitHub 项目，axios/axios&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://axios-http.com/">官网&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>Axios 是用于浏览器和 node.js 的基于 Promise 的 HTTP 客户端&lt;/p></description></item><item><title>Docs: ECMAScript 环境安装与使用</title><link>https://desistdaydream.github.io/docs/2.%E7%BC%96%E7%A8%8B/%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/ECMAScript/ECMAScript-%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8/ECMAScript-%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/2.%E7%BC%96%E7%A8%8B/%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/ECMAScript/ECMAScript-%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8/ECMAScript-%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;/blockquote>
&lt;p>有两种运行时环境可以运行 ECMAScript 代码(Javascript、Typescript)&lt;/p>
&lt;ul>
&lt;li>&lt;strong>Browser&lt;/strong># 浏览器就是 ECMAScript 的运行时环境。&lt;/li>
&lt;li>&lt;strong>Node.js&lt;/strong> # 在服务器或 PC 上安装 Node.js 环境以运行 ECMAScript 代码&lt;/li>
&lt;li>&lt;strong>Deno&lt;/strong> # &lt;a href="https://github.com/denoland/deno">GtiHub 项目，denoland/deno&lt;/a>。据说要替代 Node.js，很尴尬的是。。。早期 18 年的 issue 中被各种国人无意义灌水&lt;/li>
&lt;li>&lt;strong>Bun&lt;/strong> # &lt;a href="https://github.com/oven-sh/bun">GtiHub 项目，oven-sh/bun&lt;/a>&lt;/li>
&lt;/ul>
&lt;p>但是这两者可以提供的 API 能力各不相同&lt;/p>
&lt;ul>
&lt;li>Browser 可以提供的 dockument、window 和其他关于 DOM 或其他 Web 平台 API 的对象。&lt;/li>
&lt;li>Node.js 则可以提供很多操作系统相关的 API，比如文件的读写、进程管理、网络通信等等。&lt;/li>
&lt;/ul>
&lt;p>Node.js 与 Browser 都是基于 Chrome V8 引擎的 ECMAScript 运行时环境&lt;/p>
&lt;p>你也许会想，直接在我的硬盘上创建好 HTML 和 JavaScript 文件，然后用浏览器打开，不就可以看到效果了吗？&lt;/p>
&lt;p>这种方式运行部分 JavaScript 代码没有问题，但由于浏览器的安全限制，以 file:// 开头的地址无法执行如联网等 JavaScript 代码，最终，你还是需要架设一个 Web 服务器，然后以 http:// 开头的地址来正常执行所有 JavaScript 代码。&lt;/p>
&lt;p>所以，想要运行 JavaScript 编写的静态文件，通常都需要一个可以提供 HTTP 服务的程序，以便响应客户端的请求返回这些静态文件。通常在生产环境中，我们都会将静态资源文件放到 Nginx 的目录中，由 Nginx 为客户端提供 HTTP 服务。&lt;/p>
&lt;p>而本地测试时，我们通过 npm 与 yarn 工具即可安装一个简易的 HTTP 服务，这个 HTTP 服务都是由 JS 代码写的，必须要保证本地有 Node.js 环境，即可启动一个 HTTP 服务&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># Npm 安装 http-server&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>~&lt;span style="color:#f92672">]&lt;/span>&lt;span style="color:#75715e"># npm install http-server&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># Yarn 安装 http-server&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>~&lt;span style="color:#f92672">]&lt;/span>&lt;span style="color:#75715e"># yarn add http-server&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>http-server 来源于 &lt;a href="https://github.com/http-party/http-server">GitHub 项目，http-party/http-server&lt;/a>&lt;/p>
&lt;p>通过 &lt;code>npm exec serve&lt;/code> 命令将会安装另一个名为 serve 的库以运行 HTTP 服务，默认在 3000 端口上启动 HTTP 服务，通过浏览器访问 localhost:3000 即可获取到所有自己编写的静态文件，便于让开发人员在本地调试。&lt;/p>
&lt;h2 id="重点运行具有-module模块-功能的静态资源">(重点)运行具有 Module(模块) 功能的静态资源&lt;/h2>
&lt;p>从《ECMAScript 模块》章节可以看到，当我们使用 &lt;code>import name from './one.js'&lt;/code> 导入的模块是一个文件时，那么这个文件将会被响应给浏览器，如果使用 &lt;code>import name from 'one'&lt;/code> 导入的模块是一组文件时，此时浏览器无法直接识别，将会产生报错。因为浏览器想要执行这一组文件需要发起很多次的请求将所有文件都加载到本地，这其中的路由路径将是不可控的。&lt;/p>
&lt;p>所以，此时我们则需要想办法将这一组文件变为一个文件响应给浏览器以便加载代码。这个转换的操作，我们可以使用打包工具(i.e.Webpack、Vite 等等) 将源代码&lt;strong>打包编译&lt;/strong>成新的静态文件即可。&lt;/p>
&lt;p>后面的逻辑，与基本运行 ECMAScript 代码的行为就是一样的了。&lt;/p>
&lt;h2 id="使用-vite-运行-ecmascript-代码">使用 Vite 运行 ECMAScript 代码&lt;/h2>
&lt;p>npm、yarn 的打包后运行代码的速度非常缓慢，才是推荐使用 Vite 工具启动 HTTP 服务并运行 JS/TS 代码，详见：[《Vite》](/docs/2.编程/高级编程语言/ECMAScript/ECMAScript%20 工具/Vite.md 工具/Vite.md) 章节&lt;/p>
&lt;h2 id="运行-typesript">运行 TypeSript&lt;/h2>
&lt;p>Node.js 和 浏览器都无法直接运行 TypeScript 代码，这是因为 TS 的代码需要先转换为 JS 代码才可以运行。此时就需要一种工具，先转换再运行，或者直接转换运行一体。&lt;/p>
&lt;ul>
&lt;li>&lt;strong>tsc&lt;/strong> # 将 TS 代码转换为 JS 代码。&lt;code>npm install -g typescript&lt;/code>&lt;/li>
&lt;li>&lt;strong>ts-node&lt;/strong> # 可以直接转换并运行 TS 代码，&lt;code>npm install -g ts-node&lt;/code> 安装即可&lt;/li>
&lt;/ul>
&lt;h1 id="nodejs">Node.js&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://nodejs.org/en/">org 官网&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://nodejs.dev/">dev 官网&lt;/a>&lt;/li>
&lt;li>&lt;a href="http://nodejs.cn/">dev 官网中文翻译&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Node.js">Wiki,Node.js&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>Node.js 是基于 Chrome V8 引擎的 ECMAScript 运行时环境，由 RyanDahl 于 2009 年 5 月 27 日发布。转年(i.e.2010 年 1 月)，为 Node.js 环境引入了一个名为 npm 的包管理器。包管理器使程序员更容易发布和共享 Node.js 的源代码，旨在简化包的安装、更新、卸载。&lt;/p>
&lt;p>Browser 和 Node.js 都是 ECMAScript 的运行时环境，但是这两者可以提供的 API 能力各不相同&lt;/p>
&lt;ul>
&lt;li>Browser 可以提供的 dockument、window 和其他关于 DOM 或其他 Web 平台 API 的对象。&lt;/li>
&lt;li>Node.js 则可以提供很多操作系统相关的 API，比如文件的读写、进程管理、网络通信等等。&lt;/li>
&lt;/ul>
&lt;p>通过 Node.js，可以让我们使用一种语言编写前端与后端。我们甚至可以通过 npm 与 yarn 安装第三方库后，使用 Node.js 在本地监听端口并响应给客户端静态资源文件。&lt;/p>
&lt;h2 id="安装-nodejs">安装 Node.js&lt;/h2>
&lt;h3 id="linux">Linux&lt;/h3>
&lt;p>从&lt;a href="https://nodejs.org/zh-cn/download/">官网&lt;/a>下载 Linux 版的 &lt;code>.tar.xg&lt;/code> 包，并解压&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>export NodejsVersion&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;v18.15.0&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>wget https://nodejs.org/dist/&lt;span style="color:#e6db74">${&lt;/span>NodejsVersion&lt;span style="color:#e6db74">}&lt;/span>/node-&lt;span style="color:#e6db74">${&lt;/span>NodejsVersion&lt;span style="color:#e6db74">}&lt;/span>-linux-x64.tar.xz
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>sudo tar -xvf node-&lt;span style="color:#e6db74">${&lt;/span>NodejsVersion&lt;span style="color:#e6db74">}&lt;/span>-linux-x64.tar.xz -C /usr/local/
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>sudo mv /usr/local/node-&lt;span style="color:#e6db74">${&lt;/span>NodejsVersion&lt;span style="color:#e6db74">}&lt;/span>-linux-x64 /usr/local/nodejs
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>配置环境变量&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>sudo tee /etc/profile.d/nodejs.sh &amp;gt; /dev/null &amp;lt;&amp;lt;-&lt;span style="color:#e6db74">&amp;#34;EOF&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>export PATH&lt;span style="color:#f92672">=&lt;/span>$PATH:/usr/local/nodejs/bin
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>EOF
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>source /etc/profile.d/nodejs.sh
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="windows">Windows&lt;/h3>
&lt;p>警告！！！由于 msi 安装包会修改 %PREFIX% 为 &lt;code>%APPDATA%\npm&lt;/code> ，并将该目录到 $PATH。我个人推荐下载 zip，并自己解压到想要的位置后，手动配置环境变量。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-powershell" data-lang="powershell">&lt;span style="display:flex;">&lt;span>$NodejsVersion = &lt;span style="color:#e6db74">&amp;#34;18.14.1&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>$NodejsUrl = &lt;span style="color:#e6db74">&amp;#34;https://nodejs.org/dist/v&lt;/span>$NodejsVersion&lt;span style="color:#e6db74">/node-v&lt;/span>$NodejsVersion&lt;span style="color:#e6db74">-win-x64.zip&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>$TempZipFile = &lt;span style="color:#e6db74">&amp;#34;D:\tmp\nodejs.zip&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>$ExtractPath = &lt;span style="color:#e6db74">&amp;#34;D:\Tools&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># Download the zip file to a temporary location&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Invoke-WebRequest -Uri $NodejsUrl -OutFile $TempZipFile
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># Extract the contents of the zip file to the installation directory and rename the top-level directory to &amp;#34;nodejs&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Expand-Archive -Path $TempZipFile -DestinationPath $ExtractPath
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Rename-Item -Path &lt;span style="color:#e6db74">&amp;#34;&lt;/span>$ExtractPath&lt;span style="color:#e6db74">\node-v&lt;/span>$NodejsVersion&lt;span style="color:#e6db74">-win-x64&amp;#34;&lt;/span> -NewName &lt;span style="color:#e6db74">&amp;#34;nodejs&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>将 nodejs/ 目录添加到用户的 PATH 环境变量中&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-powershell" data-lang="powershell">&lt;span style="display:flex;">&lt;span>$path = [&lt;span style="color:#66d9ef">Environment&lt;/span>]::GetEnvironmentVariable(&lt;span style="color:#e6db74">&amp;#34;Path&amp;#34;&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;User&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>$newPath = &lt;span style="color:#e6db74">&amp;#34;D:\Tools\nodejs&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>[&lt;span style="color:#66d9ef">Environment&lt;/span>]::SetEnvironmentVariable(&lt;span style="color:#e6db74">&amp;#34;Path&amp;#34;&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;&lt;/span>$path&lt;span style="color:#e6db74">;&lt;/span>$newPath&lt;span style="color:#e6db74">&amp;#34;&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;User&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="目录结构">目录结构&lt;/h3>
&lt;p>Linux 目录结构，node_modules/ 目录在 lib/ 目录下，这点与 Windows 不同。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">]&lt;/span>&lt;span style="color:#75715e"># tree -L 2 -F&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>.
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>├── bin/
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>│   ├── corepack -&amp;gt; ../lib/node_modules/corepack/dist/corepack.js*
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>│   ├── node*
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>│   ├── npm -&amp;gt; ../lib/node_modules/npm/bin/npm-cli.js*
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>│   ├── npx -&amp;gt; ../lib/node_modules/npm/bin/npx-cli.js*
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>│   ├── pnpm -&amp;gt; ../lib/node_modules/corepack/dist/pnpm.js*
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>│   ├── pnpx -&amp;gt; ../lib/node_modules/corepack/dist/pnpx.js*
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>│   ├── yarn -&amp;gt; ../lib/node_modules/corepack/dist/yarn.js*
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>│   └── yarnpkg -&amp;gt; ../lib/node_modules/corepack/dist/yarnpkg.js*
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>├── CHANGELOG.md
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>├── include/
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>│   └── node/
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>├── lib/
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>│   └── node_modules/
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>├── LICENSE
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>├── README.md
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>└── share/
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ├── doc/
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ├── man/
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> └── systemtap/
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Windows 目录结构&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>$ tree -L &lt;span style="color:#ae81ff">2&lt;/span> -F
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>./
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>├── CHANGELOG.md*
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>├── LICENSE*
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>├── README.md*
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>├── corepack*
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>├── corepack.cmd*
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>├── install_tools.bat*
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>├── node.exe*
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>├── node_etw_provider.man*
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>├── node_modules/
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>│   ├── corepack/
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>│   └── npm/
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>├── nodevars.bat*
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>├── npm*
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>├── npm.cmd*
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>├── npx*
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>└── npx.cmd*
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="nvm">NVM&lt;/h2>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://github.com/nvm-sh/nvm">GitHub 项目，nvm-sh/nvm&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>&lt;strong>Node Version Manager(Node.js 版本管理器，简称 NVM)&lt;/strong>&lt;/p>
&lt;h2 id="nodejs-关联文件与配置">Node.js 关联文件与配置&lt;/h2>
&lt;p>详见：&lt;a href="https://desistdaydream.github.io/docs/2.%E7%BC%96%E7%A8%8B/%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/ECMAScript/ECMAScript%20%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8/ECMAScript%20%E6%A8%A1%E5%9D%97%E4%B8%8E%E5%8C%85%E7%9A%84%E4%BD%BF%E7%94%A8%E4%B8%8E%E7%AE%A1%E7%90%86.md#npm%20%E5%85%B3%E8%81%94%E6%96%87%E4%BB%B6%E4%B8%8E%E9%85%8D%E7%BD%AE">npm 关键文件与配置&lt;/a>&lt;/p>
&lt;h1 id="初始化项目">初始化项目&lt;/h1>
&lt;p>npm 等包管理工具下载完框架后，会自动生成项目目录，这些目录是已经初始化完成的项目，包含了很多必要的文件，比如 package.json 等。&lt;/p>
&lt;p>随着学习深入，会逐步总结一个前端项目如果不使用框架从头构建的话会需要什么。&lt;/p>
&lt;ul>
&lt;li>&lt;strong>public/&lt;/strong> 目录存放公共资源&lt;/li>
&lt;li>&lt;strong>src/&lt;/strong> # 所有代码都在 src/ 目录下&lt;/li>
&lt;li>&lt;strong>.eslintrc.cjs&lt;/strong> # ESLint 程序配置&lt;/li>
&lt;li>&lt;strong>.prettierc.json&lt;/strong> # Prettier 插件的配置&lt;/li>
&lt;li>&lt;strong>env.d.ts&lt;/strong> #&lt;/li>
&lt;li>&lt;strong>index.html&lt;/strong> # 程序入口&lt;/li>
&lt;li>[&lt;strong>package.json&lt;/strong>](/docs/2.编程/高级编程语言/ECMAScript/ECMAScript%20 环境安装与使用/package.json.md 环境安装与使用/package.json.md) # 包管理器配置文件，比如 npm、pnpm 等&lt;/li>
&lt;li>&lt;strong>vite.config.ts&lt;/strong> # Vite 程序给项目打包时使用的配置&lt;/li>
&lt;li>&lt;strong>tsconfig.json&lt;/strong> #&lt;/li>
&lt;li>&lt;strong>tsconfig.config.json&lt;/strong> # [TSConfig](/docs/2.编程/高级编程语言/ECMAScript/ECMAScript%20 环境安装与使用/TSConfig.md 环境安装与使用/TSConfig.md) 文件&lt;/li>
&lt;/ul>
&lt;h2 id="javascript-项目初始化">JavaScript 项目初始化&lt;/h2>
&lt;p>无&lt;/p>
&lt;h2 id="typescript-项目初始化">TypeScript 项目初始化&lt;/h2>
&lt;p>使用 &lt;code>npm install -g typescript&lt;/code> 安装 tsc 命令。&lt;/p>
&lt;p>使用 &lt;code>tsc init&lt;/code> 命令将会生成 [TSConfig](/docs/2.编程/高级编程语言/ECMAScript/ECMAScript%20 环境安装与使用/TSConfig.md 环境安装与使用/TSConfig.md) 文件。&lt;/p>
&lt;h1 id="编译与打包">编译与打包&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://github.com/webpack/webpack">GitHub 项目，webpack/webpack&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://github.com/rollup/rollup">GitHub 项目，rollup/rollup&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>大型项目通常都要打包，打包工具有很多：&lt;/p>
&lt;ul>
&lt;li>Webpack&lt;/li>
&lt;li>Rollup&lt;/li>
&lt;li>Vite&lt;/li>
&lt;li>&amp;hellip;&amp;hellip;等等&lt;/li>
&lt;/ul>
&lt;h1 id="常见问题">常见问题&lt;/h1>
&lt;h2 id="nodejs-无法使用-es6-语法问题">Node.js 无法使用 ES6 语法问题&lt;/h2>
&lt;p>无法使用 import 关键字导入模块。参考 &lt;a href="https://nodejs.org/docs/latest-v16.x/api/esm.html#enabling">https://nodejs.org/docs/latest-v16.x/api/esm.html#enabling&lt;/a>，在 package.json 文件中设置 &lt;code>&amp;quot;type&amp;quot;: &amp;quot;module&amp;quot;&lt;/code> 或者使用 &lt;code>--input-type=module&lt;/code> 命令行参数以告诉 Node.js 使用 ECMAScript 模块加载器。默认情况下，Node.js 使用 CommonJS 模块加载器。&lt;/p></description></item><item><title>Docs: etcdctl</title><link>https://desistdaydream.github.io/docs/5.%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8/2.%E6%95%B0%E6%8D%AE%E5%BA%93/%E9%94%AE%E5%80%BC%E6%95%B0%E6%8D%AE/Etcd/Etcd-%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%B7%A5%E5%85%B7/etcdctl/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/5.%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8/2.%E6%95%B0%E6%8D%AE%E5%BA%93/%E9%94%AE%E5%80%BC%E6%95%B0%E6%8D%AE/Etcd/Etcd-%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%B7%A5%E5%85%B7/etcdctl/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>官方文档：&lt;a href="https://github.com/etcd-io/etcd/tree/master/etcdctl">https://github.com/etcd-io/etcd/tree/master/etcdctl&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://etcd.io/docs/latest/integrations/">etcd 可用的库和客户端&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;h1 id="syntax语法">Syntax(语法)&lt;/h1>
&lt;p>&lt;strong>etcdctl [GlobalOptions] COMMAND [CommandOptions] [Arguments&amp;hellip;]&lt;/strong>&lt;/p>
&lt;p>使用说明：&lt;/p>
&lt;ul>
&lt;li>export ETCDCTL_API=3 使用该命令使得 etcdctl 通过 v3 版本来进行操作&lt;/li>
&lt;li>如果在 etcd 的配置文件中的 Security 段落，开启了验证证书，则在使用命令时，需要使用&amp;ndash;cert、&amp;ndash;key、&amp;ndash;cacert 选项来指定验证所需证书，否则无法操纵服务器
&lt;ul>
&lt;li>v2 版本中使用如下方式 etcdctl &amp;ndash;key-file=/etc/kubernetes/pki/etcd/peer.key &amp;ndash;cert-file=/etc/kubernetes/pki/etcd/peer.crt &amp;ndash;ca-file=/etc/kubernetes/pki/etcd/ca.crt &amp;ndash;endpoints=&amp;ldquo;https://IP:PORT&amp;rdquo; COMMAND&lt;/li>
&lt;li>v3 版本中使用如下方式 etcdctl &amp;ndash;key=/etc/kubernetes/pki/etcd/peer.key &amp;ndash;cert=/etc/kubernetes/pki/etcd/peer.crt &amp;ndash;cacert=/etc/kubernetes/pki/etcd/ca.crt &amp;ndash;endpoints=&amp;ldquo;https://IP:PORT&amp;rdquo; COMMAND&lt;/li>
&lt;li>在下面的 EXAMPLE 则不再输入认证相关参数，以便查阅方便。但是实际使用中需要使用，否则无法连接 etcd 服务端&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h2 id="global-options">GLOBAL OPTIONS&lt;/h2>
&lt;ul>
&lt;li>&lt;strong>&amp;ndash;cacert=/PATH/FILE&lt;/strong> # 使用此 CA 包验证启用 TLS 的安全服务器的证书。即 etcd 的 ca，用该 ca 来验证 cert 选项中提供的证书是否正确&lt;/li>
&lt;li>&lt;strong>&amp;ndash;cert=/PATH/FILE&lt;/strong># 使用指定的 TLS 证书文件鉴定客户端是否安全。即 etcd 的 peer 证书，peer 证书对于 etcdctl 来说就是与它交互的服务端的证书&lt;/li>
&lt;li>&lt;strong>&amp;ndash;key=/PATH/FILE&lt;/strong> # 使用指定的 TLS 证书的密钥文件鉴定客户端是否安全。即 etcd 的 peer 证书的私钥&lt;/li>
&lt;li>&lt;strong>&amp;ndash;endpoints=[IP1:PORT1,IP2:PORT2,&amp;hellip;..]&lt;/strong> # 指定后端服务器的 IP 和 Port&lt;/li>
&lt;li>&amp;ndash;command-timeout=5s # timeout for short running command (excluding dial timeout)&lt;/li>
&lt;li>&amp;ndash;debug[=false] # enable client-side debug logging&lt;/li>
&lt;li>&amp;ndash;dial-timeout=2s # dial timeout for client connections&lt;/li>
&lt;li>&amp;ndash;hex[=false] # print byte strings as hex encoded strings&lt;/li>
&lt;li>&amp;ndash;insecure-skip-tls-verify[=false # skip server certificate verification&lt;/li>
&lt;li>&amp;ndash;insecure-transport[=true] # disable transport security for client connections&lt;/li>
&lt;li>&amp;ndash;user=&amp;quot;&amp;quot; # username[:password] for authentication (prompt if password is not supplied)&lt;/li>
&lt;li>-w, &amp;ndash;write-out=&amp;ldquo;simple&amp;rdquo; # 指定输出内容的格式，格式可有有这么几个 (fields, json, protobuf, simple, table)(一般常用 json)
&lt;ul>
&lt;li>Note：输出的 json 格式只有一行，可以使用 jq 程序来对 json 进行格式化，可以把每个{}分行，以便人类阅读，下图为样例&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/miobxe/1616136392283-c0b50823-df6d-49d3-8d85-2aed1c7de3e0.jpeg" alt="">&lt;/p>
&lt;h1 id="基本命令">基本命令&lt;/h1>
&lt;h2 id="get---获取键或者键的范围gets-the-key-or-a-range-of-keys">get - 获取键或者键的范围。Gets the key or a range of keys&lt;/h2>
&lt;p>&lt;strong>etcdctl get [OPTIONS] [Range-End]&lt;/strong>&lt;/p>
&lt;p>OPTIONS&lt;/p>
&lt;ul>
&lt;li>&amp;ndash;consistency=&amp;ldquo;l&amp;rdquo; Linearizable(l) or Serializable(s)&lt;/li>
&lt;li>&amp;ndash;from-key[=false] Get keys that are greater than or equal to the given key using byte compare&lt;/li>
&lt;li>&lt;strong>&amp;ndash;keys-only[=false]&lt;/strong> # 仅获取键而不显示该键所对应的值&lt;/li>
&lt;li>&amp;ndash;limit=0 # Maximum number of results&lt;/li>
&lt;li>&amp;ndash;order=&amp;quot;&amp;quot; # Order of results; ASCEND or DESCEND (ASCEND by default)&lt;/li>
&lt;li>&lt;strong>&amp;ndash;prefix[=false]&lt;/strong> # 获取 KEY 前缀匹配到的所有的键。前缀就是键名的从开头开始的的字符串。可以指定&lt;code>''&lt;/code>匹配所有 KEY&lt;/li>
&lt;li>&amp;ndash;print-value-only[=false] Only write values when using the &amp;ldquo;simple&amp;rdquo; output format&lt;/li>
&lt;li>&amp;ndash;rev=0 Specify the kv revision&lt;/li>
&lt;li>&amp;ndash;sort-by=&amp;quot;&amp;quot; Sort target; CREATE, KEY, MODIFY, VALUE, or VERSION&lt;/li>
&lt;/ul>
&lt;p>EXAMPLE&lt;/p>
&lt;ul>
&lt;li>etcdctl get &amp;ndash;prefix &amp;ndash;keys-only &amp;rsquo;&amp;rsquo; # 获取所有键，并且只显示键名。&lt;/li>
&lt;li>etcdctl get &amp;ndash;prefix &amp;ndash;keys-only / # 获取以&lt;code>/&lt;/code>开头的所有键，并且只显示键名。&lt;/li>
&lt;li>etcdv3 get /registry/events/kube-system/kube-flannel-ds-amd64-47cnw.15966b23d2027e45 -w=json | jq . # 以 json 格式输出指定键的值，并使用 jq 命令对 json 内容进行格式化输出以便人类阅读&lt;/li>
&lt;/ul>
&lt;p>put # 写入一个 key/value 到 etcd 存储中。&lt;/p>
&lt;p>del # 删除指定的 key 或一个范围的 keys&lt;/p>
&lt;p>txn Txn processes all the requests in one transaction&lt;/p>
&lt;p>compaction Compacts the event history in etcd&lt;/p>
&lt;h1 id="alarm---告警相关命令">alarm - 告警相关命令&lt;/h1>
&lt;h2 id="alerm-disarm---解除所有告警">alerm disarm - 解除所有告警&lt;/h2>
&lt;h2 id="alarm-list---列出-etcd-中所有的告警">alarm list - 列出 etcd 中所有的告警&lt;/h2>
&lt;h1 id="check---检查-etcd-的性能">check - 检查 etcd 的性能&lt;/h1>
&lt;h2 id="check-datascale">check datascale&lt;/h2>
&lt;p>检查在给定的 endpoint 上为不同工作负载保持数据时的内存使用情况。&lt;/p>
&lt;h2 id="check-perf---检查-etcd-的性能">check perf - 检查 etcd 的性能&lt;/h2>
&lt;p>检查 60 秒的 etcd 群集性能。经常运行检查性能可以创建一个较大的键空间历史记录，可以使用&amp;ndash;auto-compact 和&amp;ndash;auto-defrag 选项（如下所述）对其进行自动压缩和碎片整理。&lt;/p>
&lt;p>&lt;strong>注意：性能检查会产生碎片，推荐性能测试后，执行 &lt;code>etcdctl defrag&lt;/code> 命令清理碎片&lt;/strong>&lt;/p>
&lt;p>OPTIONS&lt;/p>
&lt;ul>
&lt;li>&lt;strong>&amp;ndash;load&lt;/strong> # 性能检查的工作负载模型。可接受的工作负载：s(small 小)，m(medium 中)，l(large 大)，xl(x 大)&lt;/li>
&lt;/ul>
&lt;h1 id="defrag">defrag&lt;/h1>
&lt;p>defrag 命令可以对 etcd 成员的存储空间进行碎片整理，etcd 成员目标可以是正在运行，也可以是未运行的，当处理未运行的数据库碎片时，指定存储路径即可。&lt;/p>
&lt;h2 id="example">EXAMPLE&lt;/h2>
&lt;p>在 Etcd 当前节点成员运行碎片整理操作&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-sh" data-lang="sh">&lt;span style="display:flex;">&lt;span>$ etcdctl defrag
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Finished defragmenting etcd member&lt;span style="color:#f92672">[&lt;/span>127.0.0.1:2379&lt;span style="color:#f92672">]&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>在集群中的所有成员运行碎片整理操作：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>$ etcdctl defrag --cluster
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Finished defragmenting etcd member&lt;span style="color:#f92672">[&lt;/span>http://127.0.0.1:2379&lt;span style="color:#f92672">]&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Finished defragmenting etcd member&lt;span style="color:#f92672">[&lt;/span>http://127.0.0.1:22379&lt;span style="color:#f92672">]&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Finished defragmenting etcd member&lt;span style="color:#f92672">[&lt;/span>http://127.0.0.1:32379&lt;span style="color:#f92672">]&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>在 Etcd 未运行时，对数据存储目录执行碎片整理操作：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-sh" data-lang="sh">&lt;span style="display:flex;">&lt;span>$ etcdctl defrag --data-dir &amp;lt;PathToEtcdDataDir&amp;gt;
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h1 id="endpoint---用于查询-etcd-中各个端点的信息">endpoint - 用于查询 etcd 中各个端点的信息&lt;/h1>
&lt;p>endpoint health # Checks the healthiness of endpoints specified in &lt;code>--endpoints&lt;/code> flag&lt;/p>
&lt;p>endpoint status # 打印出 &amp;ndash;endpoints 标志中指定的 endpoints 状态&lt;/p>
&lt;p>endpoint hashkv # Prints the KV history hash for each endpoint in &amp;ndash;endpoints&lt;/p>
&lt;h1 id="lease---相关命令">lease - 相关命令&lt;/h1>
&lt;p>lease grant Creates leases&lt;/p>
&lt;p>lease revoke Revokes leases&lt;/p>
&lt;p>lease timetolive Get lease information&lt;/p>
&lt;p>lease keep-alive Keeps leases alive (renew)&lt;/p>
&lt;h1 id="member---管理-etcd-集群中的成员">member - 管理 etcd 集群中的成员&lt;/h1>
&lt;p>member add # 将新成员作为新对等方引入 etcd 集群中。&lt;/p>
&lt;p>member remove # 从参与集群共识的成员中删除 etcd 集群的成员。&lt;/p>
&lt;p>member update # 为 etcd 集群中现有成员设置对等 URL。&lt;/p>
&lt;p>member list # 列出集群中的所有成员&lt;/p>
&lt;p>EXAMPLE&lt;/p>
&lt;ul>
&lt;li>etcdctl member list # 列出 etcd 集群中的成员&lt;/li>
&lt;li>etcdctl member list &amp;ndash;write-out=json | jq . # 通过 json 可以看到 etcd 集群中，哪个是节点是 leader&lt;/li>
&lt;/ul>
&lt;h1 id="snapshot---快照相关命令">snapshot - 快照相关命令。&lt;/h1>
&lt;p>snapshot 相关的命令可以让将 etcd 的数据进行备份与恢复&lt;/p>
&lt;p>&lt;strong>etcdctl snapshot save&lt;/strong> # 存储一个 etcd 节点后端快照到指定文件。Stores an etcd node backend snapshot to a given file
EXAMPLE&lt;/p>
&lt;ul>
&lt;li>etcdctl snapshot save snapshot.db # 备份指定后端节点的 etcd 数据到 snapshot.db 文件&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>etcdctl snapshot restore [OPTIONS]&lt;/strong> # 恢复一个 etcd 成员的快照到一个 etcd 的文件夹中。
OPTIONS&lt;/p>
&lt;ul>
&lt;li>&lt;strong>&amp;ndash;data-dir=/PATH/FILE&lt;/strong># 把指定的路径作为 snapshot 文件的恢复目录，会把数据写到指定的目录下。Path to the data directory&lt;/li>
&lt;/ul>
&lt;p>EXAMPLE&lt;/p>
&lt;ul>
&lt;li>etcdctl snapshot restore snapshot.db &amp;ndash;data-dir=/var/lib/etcd/ # 从 snapshot.db 文件中恢复数据到/var/lib/etcd/目录下&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>etcdctl snapshot status&lt;/strong> # 取指定文件的后端快照状态。Gets backend snapshot status of a given file
EXAMPLE&lt;/p>
&lt;ul>
&lt;li>etcdv3 snapshot status snapshot.db # 获取 snapshot.db 的状态，包括键/值对有多少，占多少空间&lt;/li>
&lt;/ul>
&lt;h1 id="其他">其他&lt;/h1>
&lt;p>make-mirror Makes a mirror at the destination etcd cluster&lt;/p>
&lt;p>migrate Migrates keys in a v2 store to a mvcc store&lt;/p>
&lt;p>lock Acquires a named lock&lt;/p>
&lt;p>elect Observes and participates in leader election&lt;/p>
&lt;p>auth enable Enables authentication&lt;/p>
&lt;p>auth disable Disables authentication&lt;/p>
&lt;h2 id="user--etcd-用户相关的命令">user # etcd 用户相关的命令&lt;/h2>
&lt;p>详见：&lt;a href="https://desistdaydream.github.io/docs/5.%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8/2.%E6%95%B0%E6%8D%AE%E5%BA%93/%E9%94%AE%E5%80%BC%E6%95%B0%E6%8D%AE/Etcd/Etcd%20%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%B7%A5%E5%85%B7/etcdctl%20user%20%E5%91%BD%E4%BB%A4.md">etcdctl user 命令&lt;/a>&lt;/p>
&lt;h2 id="role--etcd-的-role-相关的命令">role # etcd 的 role 相关的命令&lt;/h2>
&lt;p>role add # Adds a new role&lt;/p>
&lt;p>role delete # Deletes a role&lt;/p>
&lt;p>role get # Gets detailed information of a role&lt;/p>
&lt;p>role list # Lists all roles&lt;/p>
&lt;p>role grant-permission # Grants a key to a role&lt;/p>
&lt;p>role revoke-permission # Revokes a key from a role&lt;/p>
&lt;p>watch Watches events stream on keys or prefixes&lt;/p></description></item><item><title>Docs: EXT FileSystem</title><link>https://desistdaydream.github.io/docs/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2.Kernel%E5%86%85%E6%A0%B8/6.File_System_%E7%AE%A1%E7%90%86/%E7%A3%81%E7%9B%98%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/EXT-FileSystem/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2.Kernel%E5%86%85%E6%A0%B8/6.File_System_%E7%AE%A1%E7%90%86/%E7%A3%81%E7%9B%98%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/EXT-FileSystem/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://mp.weixin.qq.com/s/qJdoXTv_XS_4ts9YuzMNIw">公众号，小林 coding-一口气搞懂「文件系统」，就靠这 25 张图了&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.junmajinlong.com/linux/ext_filesystem/">骏马金龙，第4章 ext文件系统机制原理剖析&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>硬盘最底层的读写 IO 一次是一个扇区 512 字节，如果要读写大量文件，以扇区为单位肯定很慢很消耗性能，所以硬盘使用了一个称作逻辑块的概念。逻辑块是逻辑的，由磁盘驱动器负责维护和操作，它并非是像扇区一样物理划分的。一个逻辑块的大小可能包含一个或多个扇区，每个逻辑块都有唯一的地址，称为 LBA。有了逻辑块之后，磁盘控制器对数据的操作就以逻辑块为单位，一次读写一个逻辑块，磁盘控制器知道如何将逻辑块翻译成对应的扇区并读写数据。&lt;/p>
&lt;p>到了 Linux 操作系统层次，通过文件系统提供了一个也称为块的读写单元，文件系统数据块的大小一般为 1024bytes (1KiB) 或 2048bytes (2KiB) 或 4096bytes (4KiB)。文件系统数据块也是逻辑概念，是文件系统层次维护的，而磁盘上的逻辑数据块是由磁盘控制器维护的，文件系统的 IO 管理器知道如何将它的数据块翻译成磁盘维护的数据块地址 LBA。&lt;/p>
&lt;p>对于使用文件系统的 IO 操作来说，比如读写文件，这些 &lt;strong>IO 的基本单元&lt;/strong>是&lt;strong>文件系统上的数据块&lt;/strong>，一次读写一个文件系统数据块。比如需要读一个或多个块时，文件系统的 IO 管理器首先计算这些文件系统块对应在哪些磁盘数据块，也就是计算出 LBA，然后通知磁盘控制器要读取哪些块的数据，硬盘控制器将这些块翻译成扇区地址，然后从扇区中读取数据，再通过硬盘控制器将这些扇区数据重组写入到内存中去。&lt;/p>
&lt;p>&lt;strong>Block(块)&lt;/strong>，存放数据的最小单位，假如每个块为 4KiB，那大于 5KiB 的块就需要两个块，并且逻辑上占用了 8KiB 的空间。&lt;/p>
&lt;p>&lt;strong>Block Group(块组)&lt;/strong>，多个 Block 的集合&lt;/p>
&lt;p>Ext 预留了一些 Inode 做特殊特性使用，如下：某些可能并非总是准确，具体的 inode 号对应什么文件可以使用 &lt;code>find /-inum NUM&lt;/code> 查看&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>Ext4的特殊inode
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Inode号 用途
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">0&lt;/span> 不存在0号inode，可用于标识目录data block中已删除的文件
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">1&lt;/span> 虚拟文件系统，如/proc和/sys
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">2&lt;/span> 根目录 &lt;span style="color:#75715e"># 注意此行&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">3&lt;/span> ACL索引
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">4&lt;/span> ACL数据
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">5&lt;/span> Boot loader
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">6&lt;/span> 未删除的目录
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">7&lt;/span> 预留的块组描述符inode
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">8&lt;/span> 日志inode
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">11&lt;/span> 第一个非预留的inode，通常是 lost+found 目录
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>所以在 ext4 文件系统的 dumpe2fs 信息中，能观察到 fisrt inode 号可能为 11 也可能为 12。&lt;/p>
&lt;h2 id="块块组inode-计算">块、块组、Inode 计算&lt;/h2>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>参考哪里？我也想知道真实的计算逻辑。。。&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>这些计算的结果通常与下列设置有关&lt;/p>
&lt;ul>
&lt;li>&lt;strong>DiskSize&lt;/strong> # 磁盘空间&lt;/li>
&lt;li>&lt;strong>BlockSize&lt;/strong> # 通常为 4096 Bytes
&lt;ul>
&lt;li>可使用 mke2fs -b 手动指定&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>BlocksPerGroup&lt;/strong> # 通常为 32768。每个块组中块的数量。
&lt;ul>
&lt;li>可使用 mke2fs -g 手动指定&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>BytesPerInode&lt;/strong> # 通常为 16384 Bytes。创建文件系统时，为每块 BytesPerInode 大小的空间创建一个 Inode。
&lt;ul>
&lt;li>BytesPerInode 也称为 inode_ratio，即.Inode 比率，全称应该是 Inode 分配比率，即每多少空间分配一个 Inode。&lt;/li>
&lt;li>可使用 mke2fs -i 手动指定&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>InodeSize&lt;/strong> # 通常为 256 Bytes。大小是 128 的倍数，最小为 128 Bytes。&lt;/li>
&lt;/ul>
&lt;p>其中 BlocksPerGroup(每个块组中块的数量)、BytesPerInode(每个Inode负责的空间大小) 这种值是后续计算的基础。固定下来这些，就算分区空间自动扩容/缩容，也可以根据这种数据自动增加/删除块的数量和 Inode 的数量。&lt;/p>
&lt;p>其中块大小为 4K，Inode 比率为 16K，也就是说，至少每 4 个块分配一个 Inode。当然分配的这些 inode 号只是预分配，并不真的代表会全部使用，毕竟每个文件才会分配一个 inode 号。&lt;/p>
&lt;p>这些数据将会计算出：&lt;/p>
&lt;ul>
&lt;li>&lt;strong>BlockCount&lt;/strong> # 块总数&lt;/li>
&lt;li>&lt;strong>BlockGroup&lt;/strong> # 块组总数&lt;/li>
&lt;li>&lt;strong>InodeCount&lt;/strong> # Inode 总数&lt;/li>
&lt;li>&lt;strong>InodePreGroup&lt;/strong> # 每个块组中包含的 Inode 数量&lt;/li>
&lt;li>&lt;strong>InodeUseage&lt;/strong> # 所有 Inode 占用的空间&lt;/li>
&lt;/ul>
&lt;p>假如现在有一块 35GiB 的磁盘，需要先转为 Bytes。然后根据给定的 BlockSize(块大小) 和 BlocksPerGroup(块组中块的数量)，计算出需要创建创建的&lt;strong>块数量&lt;/strong>和&lt;strong>块组数量&lt;/strong>。&lt;/p>
&lt;p>&lt;strong>Block 与 BlockGroup 的计算&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>BlockCount = DiskSize / BlockSize = 37580963840 / 4096 = 9175040&lt;/li>
&lt;li>BlockGroupCount = BlockCount / BlocksPerGroup = 9175040 / 32768 = 280&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>Inode 的计算&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>InodeCount = DiskSize / BytesPerInode = 37580963840 / 16384 = 2293760&lt;/li>
&lt;/ul>
&lt;blockquote>
&lt;p>由于之前已经知道了“每4个块分配一个Inode”，那么用“总块数/4”也是可以得到这个 Inode 总数的。&lt;/p>
&lt;/blockquote>
&lt;p>计算出的 Inode 数量将会平均分配到每个块组中&lt;/p>
&lt;ul>
&lt;li>InodePreGroup = InodeCount / BlockGroupCount = 2293760 / 280 = 8192&lt;/li>
&lt;/ul>
&lt;blockquote>
&lt;p>由于之前已经知道了“每4个块分配一个Inode”，那么用“每个块组中块的数量/4”也是可以得到每个块组中 Inode 的数量。&lt;/p>
&lt;/blockquote>
&lt;p>计算所有 Inode 需要占用的磁盘空间&lt;/p>
&lt;ul>
&lt;li>InodeUseage = InodeCount * InodeSize = 2293760 * 256 = 587202560 Bytes = 560 MiB&lt;/li>
&lt;/ul>
&lt;p>也就是说，一块 35 G 的硬盘，需要拿出来至少 560 MiB 的空间来存放 Inode 数据。&lt;/p>
&lt;p>&lt;strong>TODO:&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>&lt;strong>Inode 还有一个最低数量？就算执行 &lt;code>mke2fs -N 1&lt;/code> 命令，最后也不会只有一个 Inode，而是有 4480 个 Inode，这个数是怎么来的？&lt;/strong>&lt;/li>
&lt;li>**试了下 &lt;code>mke2fs -N 1000000&lt;/code> 最后生成的 Inode 数为 1003520，正好是 4480 的倍数&lt;/li>
&lt;li>&lt;strong>如果是 &lt;code>mke2fs -N 4481&lt;/code>，则生成的 Inode 数为 8960，也是 4480 的倍数。。。这个值到底咋来的。。。o(╯□╰)o&lt;/strong>**&lt;/li>
&lt;li>好像是根据 Inodes per group 的值来的，这个值好像必须要是 16 的倍数，并且最低值是 16，可是这个说法的来源是在哪呢？&lt;/li>
&lt;/ul>
&lt;p>上述计算的结果可以通过 dumpe2fs 命令查看&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>~&lt;span style="color:#f92672">]&lt;/span>&lt;span style="color:#75715e"># dumpe2fs -h ${DEVICE} | egrep -i &amp;#34;block|inode&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>dumpe2fs 1.45.5 &lt;span style="color:#f92672">(&lt;/span>07-Jan-2020&lt;span style="color:#f92672">)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Filesystem features: ext_attr resize_inode dir_index filetype sparse_super large_file
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Inode count: &lt;span style="color:#ae81ff">2293760&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Block count: &lt;span style="color:#ae81ff">9175040&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Reserved block count: &lt;span style="color:#ae81ff">458752&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Free blocks: &lt;span style="color:#ae81ff">9018814&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Free inodes: &lt;span style="color:#ae81ff">2293749&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>First block: &lt;span style="color:#ae81ff">0&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Block size: &lt;span style="color:#ae81ff">4096&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Reserved GDT blocks: &lt;span style="color:#ae81ff">1021&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Blocks per group: &lt;span style="color:#ae81ff">32768&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Inodes per group: &lt;span style="color:#ae81ff">8192&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Inode blocks per group: &lt;span style="color:#ae81ff">512&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Reserved blocks uid: &lt;span style="color:#ae81ff">0&lt;/span> &lt;span style="color:#f92672">(&lt;/span>user root&lt;span style="color:#f92672">)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Reserved blocks gid: &lt;span style="color:#ae81ff">0&lt;/span> &lt;span style="color:#f92672">(&lt;/span>group root&lt;span style="color:#f92672">)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>First inode: &lt;span style="color:#ae81ff">11&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Inode size: &lt;span style="color:#ae81ff">256&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="todo-最低的-inode">TODO: 最低的 Inode&lt;/h3>
&lt;p>假如我们需要最少 1 个 Inode&lt;/p>
&lt;p>此时已知&lt;/p>
&lt;ul>
&lt;li>BlockCount = 9175040&lt;/li>
&lt;li>BlockGroupCount = 280&lt;/li>
&lt;li>BlockSize = 4096 Bytes&lt;/li>
&lt;li>InodeSize = 256 Bytes&lt;/li>
&lt;li>InodeRatio = 16384 Bytes&lt;/li>
&lt;/ul>
&lt;p>每 4 个块给 1 个 Inode，但肯定不是这个思路，因为照着这种算法，那就是有 2293760 个。所以肯定不是每 4 个块给 1 个 Inode。&lt;/p>
&lt;p>真实场景：&lt;/p>
&lt;ul>
&lt;li>现在是每 2048 个块给 一个 Inode&lt;/li>
&lt;li>280 个块组&lt;/li>
&lt;li>&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>~&lt;span style="color:#f92672">]&lt;/span>&lt;span style="color:#75715e"># mke2fs -N 1 /dev/vdb&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>mke2fs 1.45.5 &lt;span style="color:#f92672">(&lt;/span>07-Jan-2020&lt;span style="color:#f92672">)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>/dev/vdb contains a ext2 file system
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> last mounted on Sat Mar &lt;span style="color:#ae81ff">11&lt;/span> 16:14:14 &lt;span style="color:#ae81ff">2023&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Proceed anyway? &lt;span style="color:#f92672">(&lt;/span>y,N&lt;span style="color:#f92672">)&lt;/span> y
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Creating filesystem with &lt;span style="color:#ae81ff">9175040&lt;/span> 4k blocks and &lt;span style="color:#ae81ff">4480&lt;/span> inodes
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Filesystem UUID: acebc9ab-c53e-4f74-bd6b-443343a76bab
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Superblock backups stored on blocks:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> 32768, 98304, 163840, 229376, 294912, 819200, 884736, 1605632, 2654208,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> 4096000, &lt;span style="color:#ae81ff">7962624&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Allocating group tables: &lt;span style="color:#66d9ef">done&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Writing inode tables: &lt;span style="color:#66d9ef">done&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Writing superblocks and filesystem accounting information: &lt;span style="color:#66d9ef">done&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>~&lt;span style="color:#f92672">]&lt;/span>&lt;span style="color:#75715e"># dumpe2fs -h ${DEVICE} | egrep -i &amp;#34;block|inode&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>dumpe2fs 1.45.5 &lt;span style="color:#f92672">(&lt;/span>07-Jan-2020&lt;span style="color:#f92672">)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Filesystem features: ext_attr resize_inode dir_index filetype sparse_super large_file
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Inode count: &lt;span style="color:#ae81ff">4480&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Block count: &lt;span style="color:#ae81ff">9175040&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Reserved block count: &lt;span style="color:#ae81ff">458752&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Free blocks: &lt;span style="color:#ae81ff">9161894&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Free inodes: &lt;span style="color:#ae81ff">4469&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>First block: &lt;span style="color:#ae81ff">0&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Block size: &lt;span style="color:#ae81ff">4096&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Reserved GDT blocks: &lt;span style="color:#ae81ff">1021&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Blocks per group: &lt;span style="color:#ae81ff">32768&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Inodes per group: &lt;span style="color:#ae81ff">16&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Inode blocks per group: &lt;span style="color:#ae81ff">1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Reserved blocks uid: &lt;span style="color:#ae81ff">0&lt;/span> &lt;span style="color:#f92672">(&lt;/span>user root&lt;span style="color:#f92672">)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Reserved blocks gid: &lt;span style="color:#ae81ff">0&lt;/span> &lt;span style="color:#f92672">(&lt;/span>group root&lt;span style="color:#f92672">)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>First inode: &lt;span style="color:#ae81ff">11&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Inode size: &lt;span style="color:#ae81ff">256&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h1 id="文件的存储">文件的存储&lt;/h1>
&lt;p>文件的数据是要存储在硬盘上面的，数据在磁盘上的存放方式，就像程序在内存中存放的方式那样，有以下两种：&lt;/p>
&lt;ul>
&lt;li>连续空间存放方式&lt;/li>
&lt;li>非连续空间存放方式&lt;/li>
&lt;/ul>
&lt;p>其中，非连续空间存放方式又可以分为「链表方式」和「索引方式」。
不同的存储方式，有各自的特点，重点是要分析它们的存储效率和读写性能，接下来分别对每种存储方式说一下。&lt;/p>
&lt;h2 id="连续空间存放方式">连续空间存放方式&lt;/h2>
&lt;blockquote>
&lt;p>注意：这里只针对机械硬盘，固态硬盘并没有磁道等概念&lt;/p>
&lt;/blockquote>
&lt;p>连续空间存放方式顾名思义，&lt;strong>文件存放在磁盘「连续的」物理空间中&lt;/strong>。这种模式下，文件的数据都是紧密相连，&lt;strong>读写效率很高&lt;/strong>，因为一次磁盘寻道就可以读出整个文件。&lt;/p>
&lt;p>使用连续存放的方式有一个前提，必须先知道一个文件的大小，这样文件系统才会根据文件的大小在磁盘上找到一块连续的空间分配给文件。&lt;/p>
&lt;p>所以，&lt;strong>文件头里需要指定「起始块的位置」和「长度」&lt;/strong>，有了这两个信息就可以很好的表示文件存放方式是一块连续的磁盘空间。&lt;/p>
&lt;p>注意，此处说的文件头，就类似于 Linux 的 inode。&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/op2fw9/1616167677049-26c7ae42-9e37-426a-99f9-6e59df62e691.png" alt="">&lt;/p>
&lt;p>连续空间存放的方式虽然读写效率高，&lt;strong>但是有「磁盘空间碎片」和「文件长度不易扩展」的缺陷。&lt;/strong>&lt;/p>
&lt;p>如下图，如果文件 B 被删除，磁盘上就留下一块空缺，这时，如果新来的文件小于其中的一个空缺，我们就可以将其放在相应空缺里。但如果该文件的大小大于所有的空缺，但却小于空缺大小之和，则虽然磁盘上有足够的空缺，但该文件还是不能存放。当然了，我们可以通过将现有文件进行挪动来腾出空间以容纳新的文件，但是这个在磁盘挪动文件是非常耗时，所以这种方式不太现实。&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/op2fw9/1616167677046-4fd1191e-4e74-4653-8ef4-24ba781c4f57.png" alt="">&lt;/p>
&lt;p>另外一个缺陷是文件长度扩展不方便，例如上图中的文件 A 要想扩大一下，需要更多的磁盘空间，唯一的办法就只能是挪动的方式，前面也说了，这种方式效率是非常低的。
那么有没有更好的方式来解决上面的问题呢？答案当然有，既然连续空间存放的方式不太行，那么我们就改变存放的方式，使用非连续空间存放方式来解决这些缺陷。&lt;/p>
&lt;h2 id="非连续空间存放方式">非连续空间存放方式&lt;/h2>
&lt;p>非连续空间存放方式分为「链表方式」和「索引方式」。&lt;/p>
&lt;blockquote>
&lt;p>我们先来看看链表的方式。&lt;/p>
&lt;/blockquote>
&lt;p>链表的方式存放是&lt;strong>离散的，不用连续的&lt;/strong>，于是就可以&lt;strong>消除磁盘碎片&lt;/strong>，可大大提高磁盘空间的利用率，同时&lt;strong>文件的长度可以动态扩展&lt;/strong>。根据实现的方式的不同，链表可分为「&lt;strong>隐式链表&lt;/strong>」和「&lt;strong>显式链接&lt;/strong>」两种形式。&lt;/p>
&lt;p>文件要以「&lt;strong>隐式链表&lt;/strong>」的方式存放的话，&lt;strong>实现的方式是文件头要包含「第一块」和「最后一块」的位置，并且每个数据块里面留出一个指针空间，用来存放下一个数据块的位置&lt;/strong>，这样一个数据块连着一个数据块，从链头开是就可以顺着指针找到所有的数据块，所以存放的方式可以是不连续的。
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/op2fw9/1616167677039-c71df217-651d-42ac-8cf6-444dedae8c1c.png" alt="">
隐式链表的存放方式的&lt;strong>缺点在于无法直接访问数据块，只能通过指针顺序访问文件，以及数据块指针消耗了一定的存储空间&lt;/strong>。隐式链接分配的&lt;strong>稳定性较差&lt;/strong>，系统在运行过程中由于软件或者硬件错误&lt;strong>导致链表中的指针丢失或损坏，会导致文件数据的丢失。&lt;/strong>&lt;/p>
&lt;p>如果取出每个磁盘块的指针，把它放在内存的一个表中，就可以解决上述隐式链表的两个不足。那么，这种实现方式是「&lt;strong>显式链接&lt;/strong>」，它指&lt;strong>把用于链接文件各数据块的指针，显式地存放在内存的一张链接表中&lt;/strong>，该表在整个磁盘仅设置一张，&lt;strong>每个表项中存放链接指针，指向下一个数据块号&lt;/strong>。&lt;/p>
&lt;p>对于显式链接的工作方式，我们举个例子，文件 A 依次使用了磁盘块 4、7、2、10 和 12 ，文件 B 依次使用了磁盘块 6、3、11 和 14 。利用下图中的表，可以从第 4 块开始，顺着链走到最后，找到文件 A 的全部磁盘块。同样，从第 6 块开始，顺着链走到最后，也能够找出文件 B 的全部磁盘块。最后，这两个链都以一个不属于有效磁盘编号的特殊标记（如 -1 ）结束。内存中的这样一个表格称为&lt;strong>文件分配表（File Allocation Table，FAT）&lt;/strong>。&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/op2fw9/1616167677063-b7bb2a32-dde6-4c17-9119-096413902ae8.png" alt="">&lt;/p>
&lt;p>由于查找记录的过程是在内存中进行的，因而不仅显著地&lt;strong>提高了检索速度&lt;/strong>，而且&lt;strong>大大减少了访问磁盘的次数&lt;/strong>。但也正是整个表都存放在内存中的关系，它的主要的缺点是**不适用于大磁盘**。&lt;/p>
&lt;p>比如，对于 200GB 的磁盘和 1KB 大小的块，这张表需要有 2 亿项，每一项对应于这 2 亿个磁盘块中的一个块，每项如果需要 4 个字节，那这张表要占用 800MB 内存，很显然 FAT 方案对于大磁盘而言不太合适。&lt;/p>
&lt;blockquote>
&lt;p>接下来，我们来看看索引的方式。&lt;/p>
&lt;/blockquote>
&lt;p>链表的方式解决了连续分配的磁盘碎片和文件动态扩展的问题，但是不能有效支持直接访问（FAT 除外），索引的方式可以解决这个问题。
索引的实现是为每个文件创建一个「&lt;strong>索引数据块&lt;/strong>」，里面存放的是&lt;strong>指向文件数据块的指针列表&lt;/strong>，说白了就像书的目录一样，要找哪个章节的内容，看目录查就可以。&lt;/p>
&lt;p>另外，&lt;strong>文件头需要包含指向「索引数据块」的指针&lt;/strong>，这样就可以通过文件头知道索引数据块的位置，再通过索引数据块里的索引信息找到对应的数据块。
创建文件时，索引块的所有指针都设为空。当首次写入第 i 块时，先从空闲空间中取得一个块，再将其地址写到索引块的第 i 个条目。&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/op2fw9/1616167677054-825db739-3c6c-4fec-bb21-1dd52effb539.png" alt="">&lt;/p>
&lt;p>索引的方式优点在于：&lt;/p>
&lt;ul>
&lt;li>文件的创建、增大、缩小很方便；&lt;/li>
&lt;li>不会有碎片的问题；&lt;/li>
&lt;li>支持顺序读写和随机读写；&lt;/li>
&lt;/ul>
&lt;p>由于索引数据也是存放在磁盘块的，如果文件很小，明明只需一块就可以存放的下，但还是需要额外分配一块来存放索引数据，所以缺陷之一就是存储索引带来的开销。&lt;/p>
&lt;p>如果文件很大，大到一个索引数据块放不下索引信息，这时又要如何处理大文件的存放呢？我们可以通过组合的方式，来处理大文件的存。&lt;/p>
&lt;p>先来看看链表 + 索引的组合，这种组合称为「&lt;strong>链式索引块&lt;/strong>」，它的实现方式是&lt;strong>在索引数据块留出一个存放下一个索引数据块的指针&lt;/strong>，于是当一个索引数据块的索引信息用完了，就可以通过指针的方式，找到下一个索引数据块的信息。那这种方式也会出现前面提到的链表方式的问题，万一某个指针损坏了，后面的数据也就会无法读取了。&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/op2fw9/1616167677072-417dcaa4-348d-4a45-b9b0-aa170d0f3bd7.png" alt="">&lt;/p>
&lt;p>还有另外一种组合方式是索引 + 索引的方式，这种组合称为「&lt;strong>多级索引块&lt;/strong>」，实现方式是&lt;strong>通过一个索引块来存放多个索引数据块&lt;/strong>，一层套一层索引，像极了俄罗斯套娃是吧。&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/op2fw9/1616167677056-ecb3b996-c14c-455d-82aa-7ca16aeb7feb.png" alt="">&lt;/p>
&lt;h2 id="unix-文件的实现方式">Unix 文件的实现方式&lt;/h2>
&lt;p>我们先把前面提到的文件实现方式，做个比较：&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/op2fw9/1671074085764-374b9218-86e8-412d-85c7-9d051b9340b2.png" alt="image.png">&lt;/p>
&lt;p>那早期 Unix 文件系统是组合了前面的文件存放方式的优点，如下图：&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/op2fw9/1616167677095-e05fe455-c302-43bb-a9d8-dd43cd4551e1.png" alt="">&lt;/p>
&lt;p>它是根据文件的大小，存放的方式会有所变化：&lt;/p>
&lt;ul>
&lt;li>如果存放文件所需的数据块小于 10 块，则采用直接查找的方式；&lt;/li>
&lt;li>如果存放文件所需的数据块超过 10 块，则采用一级间接索引方式；&lt;/li>
&lt;li>如果前面两种方式都不够存放大文件，则采用二级间接索引方式；&lt;/li>
&lt;li>如果二级间接索引也不够存放大文件，这采用三级间接索引方式；&lt;/li>
&lt;/ul>
&lt;p>那么，文件头（&lt;em>Inode&lt;/em>）就需要包含 13 个指针：&lt;/p>
&lt;ul>
&lt;li>第 10 个指向数据块的指针；&lt;/li>
&lt;li>第 11 个指向索引块的指针；&lt;/li>
&lt;li>第 12 个指向二级索引块的指针；&lt;/li>
&lt;li>第 13 个指向三级索引块的指针；&lt;/li>
&lt;/ul>
&lt;p>所以，这种方式能很灵活地支持小文件和大文件的存放：&lt;/p>
&lt;ul>
&lt;li>对于小文件使用直接查找的方式可减少索引数据块的开销；&lt;/li>
&lt;li>对于大文件则以多级索引的方式来支持，所以大文件在访问数据块时需要大量查询；&lt;/li>
&lt;/ul>
&lt;p>这个方案就用在了 Linux Ext 2/3 文件系统里，虽然解决大文件的存储，但是对于大文件的访问，需要大量的查询，效率比较低。&lt;/p>
&lt;p>为了解决这个问题，Ext 4 做了一定的改变，具体怎么解决的，本文就不展开了。&lt;/p>
&lt;h1 id="空闲空间管理">空闲空间管理&lt;/h1>
&lt;p>前面说到的文件的存储是针对已经被占用的数据块组织和管理，接下来的问题是，如果我要保存一个数据块，我应该放在硬盘上的哪个位置呢？难道需要将所有的块扫描一遍，找个空的地方随便放吗？&lt;/p>
&lt;p>那这种方式效率就太低了，所以针对磁盘的空闲空间也是要引入管理的机制，接下来介绍几种常见的方法：&lt;/p>
&lt;ul>
&lt;li>空闲表法&lt;/li>
&lt;li>空闲链表法&lt;/li>
&lt;li>位图法&lt;/li>
&lt;/ul>
&lt;h2 id="空闲表法">空闲表法&lt;/h2>
&lt;p>空闲表法就是为所有空闲空间建立一张表，表内容包括空闲区的第一个块号和该空闲区的块个数，注意，这个方式是连续分配的。如下图：
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/op2fw9/1616167677079-9e2989d6-2cda-4460-80ca-f3c0f28783f1.png" alt="">
当请求分配磁盘空间时，系统依次扫描空闲表里的内容，直到找到一个合适的空闲区域为止。当用户撤销一个文件时，系统回收文件空间。这时，也需顺序扫描空闲表，寻找一个空闲表条目并将释放空间的第一个物理块号及它占用的块数填到这个条目中。
这种方法仅当有少量的空闲区时才有较好的效果。因为，如果存储空间中有着大量的小的空闲区，则空闲表变得很大，这样查询效率会很低。另外，这种分配技术适用于建立连续文件。&lt;/p>
&lt;h2 id="空闲链表法">空闲链表法&lt;/h2>
&lt;p>我们也可以使用「链表」的方式来管理空闲空间，每一个空闲块里有一个指针指向下一个空闲块，这样也能很方便的找到空闲块并管理起来。如下图：
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/op2fw9/1616167677070-be98384a-ad4f-4a20-b5da-1d969816b938.png" alt="">
当创建文件需要一块或几块时，就从链头上依次取下一块或几块。反之，当回收空间时，把这些空闲块依次接到链头上。&lt;/p>
&lt;p>这种技术只要在主存中保存一个指针，令它指向第一个空闲块。其特点是简单，但不能随机访问，工作效率低，因为每当在链上增加或移动空闲块时需要做很多 I/O 操作，同时数据块的指针消耗了一定的存储空间。&lt;/p>
&lt;p>空闲表法和空闲链表法都不适合用于大型文件系统，因为这会使空闲表或空闲链表太大。&lt;/p>
&lt;h2 id="位图法">位图法&lt;/h2>
&lt;p>位图是利用二进制的一位来表示磁盘中一个盘块的使用情况，磁盘上所有的盘块都有一个二进制位与之对应。&lt;/p>
&lt;p>当值为 0 时，表示对应的盘块空闲，值为 1 时，表示对应的盘块已分配。它形式如下：&lt;/p>
&lt;pre>&lt;code>1111110011111110001110110111111100111 ...
&lt;/code>&lt;/pre>
&lt;p>在 Linux 文件系统就采用了位图的方式来管理空闲空间，不仅用于数据空闲块的管理，还用于 inode 空闲块的管理，因为 inode 也是存储在磁盘的，自然也要有对其管理。&lt;/p>
&lt;h1 id="文件系统的结构">文件系统的结构&lt;/h1>
&lt;p>前面提到 Linux 是用位图的方式管理空闲空间，用户在创建一个新文件时，Linux 内核会通过 inode 的位图找到空闲可用的 inode，并进行分配。要存储数据时，会通过块的位图找到空闲的块，并分配，但仔细计算一下还是有问题的。&lt;/p>
&lt;p>数据块的位图是放在磁盘块里的，假设是放在一个块里，一个块 4K，每位表示一个数据块，共可以表示 &lt;code>4 * 1024 * 8 = 2^15&lt;/code> 个空闲块，由于 1 个数据块是 4K 大小，那么最大可以表示的空间为 &lt;code>2^15 * 4 * 1024 = 2^27&lt;/code> 个 byte，也就是 128M。&lt;/p>
&lt;p>也就是说按照上面的结构，如果采用「一个块的位图 + 一系列的块」，外加「一个块的 inode 的位图 + 一系列的 inode 的结构」能表示的最大空间也就 128M，这太少了，现在很多文件都比这个大。&lt;/p>
&lt;p>在 Linux 文件系统，把这个结构称为一个&lt;strong>块组&lt;/strong>，那么有 N 多的块组，就能够表示 N 大的文件。&lt;/p>
&lt;p>下图给出了 Linux Ext2 整个文件系统的结构和块组的内容，文件系统都由大量块组组成，在硬盘上相继排布：&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/op2fw9/1616167677099-7ffa20c4-57d9-4c49-9e02-24afef066cfb.png" alt="">&lt;/p>
&lt;p>最前面的第一个块是引导块，在系统启动时用于启用引导，接着后面就是一个一个连续的块组了，块组的内容如下：&lt;/p>
&lt;ul>
&lt;li>&lt;strong>超级块&lt;/strong> # 包含的是文件系统的重要信息，比如 inode 总个数、块总个数、每个块组的 inode 个数、每个块组的块个数等等。&lt;/li>
&lt;li>&lt;strong>块组描述符&lt;/strong> # 包含文件系统中各个块组的状态，比如块组中空闲块和 inode 的数目等，每个块组都包含了文件系统中「所有块组的组描述符信息」。&lt;/li>
&lt;li>&lt;strong>数据位图和 inode 位图&lt;/strong> # 用于表示对应的数据块或 inode 是空闲的，还是被使用中。&lt;/li>
&lt;li>&lt;strong>inode 列表&lt;/strong> # 包含了块组中所有的 inode，inode 用于保存文件系统中与各个文件和目录相关的所有元数据。&lt;/li>
&lt;li>&lt;strong>数据块&lt;/strong> # 包含文件的有用数据。&lt;/li>
&lt;/ul>
&lt;p>你可以会发现每个块组里有很多重复的信息，比如&lt;strong>超级块和块组描述符表，这两个都是全局信息，而且非常的重要&lt;/strong>，这么做是有两个原因：&lt;/p>
&lt;ul>
&lt;li>如果系统崩溃破坏了超级块或块组描述符，有关文件系统结构和内容的所有信息都会丢失。如果有冗余的副本，该信息是可能恢复的。&lt;/li>
&lt;li>通过使文件和管理数据尽可能接近，减少了磁头寻道和旋转，这可以提高文件系统的性能。&lt;/li>
&lt;/ul>
&lt;p>不过，Ext2 的后续版本采用了&lt;strong>稀疏技术&lt;/strong>。该做法是，超级块和块组描述符表不再存储到文件系统的每个块组中，而是只写入到块组 0、块组 1 和其他 ID 可以表示为 3、 5、7 的幂的块组中。&lt;/p>
&lt;p>在创建文件系统时，也可以看到 &lt;code>Superblock backups stored on blocks&lt;/code> 这种描述，这记录了超级块的备份存在哪些块中&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>~&lt;span style="color:#f92672">]&lt;/span>&lt;span style="color:#75715e"># mke2fs -N 10000000 /dev/vdb&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>mke2fs 1.45.5 &lt;span style="color:#f92672">(&lt;/span>07-Jan-2020&lt;span style="color:#f92672">)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>/dev/vdb contains a ext2 file system
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> created on Sat Mar &lt;span style="color:#ae81ff">11&lt;/span> 12:25:22 &lt;span style="color:#ae81ff">2023&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Proceed anyway? &lt;span style="color:#f92672">(&lt;/span>y,N&lt;span style="color:#f92672">)&lt;/span> y
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Creating filesystem with &lt;span style="color:#ae81ff">9175040&lt;/span> 4k blocks and &lt;span style="color:#ae81ff">10002528&lt;/span> inodes
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Filesystem UUID: 8acc177c-5f26-4bb9-a0ee-01ceb61d4eaa
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Superblock backups stored on blocks:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> 30072, 90216, 150360, 210504, 270648, 751800, 811944, 1473528, 2435832,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> 3759000, &lt;span style="color:#ae81ff">7307496&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Allocating group tables: &lt;span style="color:#66d9ef">done&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Writing inode tables: &lt;span style="color:#66d9ef">done&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Writing superblocks and filesystem accounting information: &lt;span style="color:#66d9ef">done&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div></description></item><item><title>Docs: File System 管理</title><link>https://desistdaydream.github.io/docs/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Y.Windows-%E7%AE%A1%E7%90%86/File_System_%E7%AE%A1%E7%90%86/File_System_%E7%AE%A1%E7%90%86/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Y.Windows-%E7%AE%A1%E7%90%86/File_System_%E7%AE%A1%E7%90%86/File_System_%E7%AE%A1%E7%90%86/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://www.howtogeek.com/318177/what-is-the-appdata-folder-in-windows/">https://www.howtogeek.com/318177/what-is-the-appdata-folder-in-windows/&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>&lt;strong>%USERPROFILE%/AppData/*&lt;/strong> #&lt;/p>
&lt;ul>
&lt;li>&lt;strong>./Local/*&lt;/strong> #&lt;/li>
&lt;li>&lt;strong>./LocalLow/*&lt;/strong> #&lt;/li>
&lt;li>&lt;strong>./Roaming/*&lt;/strong> #&lt;/li>
&lt;/ul>
&lt;p>刚装完的 win10 专业版，用户的 AppData 中将会有如下结构：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-powershell" data-lang="powershell">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">%&lt;/span>USERPROFILE%\appdata\Local
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">%&lt;/span>USERPROFILE%\appdata\LocalLow
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">%&lt;/span>USERPROFILE%\appdata\Roaming
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">%&lt;/span>USERPROFILE%\appdata\Local\Comms
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">%&lt;/span>USERPROFILE%\appdata\Local\ConnectedDevicesPlatform
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">%&lt;/span>USERPROFILE%\appdata\Local\D3DSCache
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">%&lt;/span>USERPROFILE%\appdata\Local\Microsoft
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">%&lt;/span>USERPROFILE%\appdata\Local\Packages
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">%&lt;/span>USERPROFILE%\appdata\Local\Temp
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">%&lt;/span>USERPROFILE%\appdata\LocalLow\Microsoft
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">%&lt;/span>USERPROFILE%\appdata\LocalLow\MSLiveStickerWhiteList
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">%&lt;/span>USERPROFILE%\appdata\Roaming\Adobe
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">%&lt;/span>USERPROFILE%\appdata\Roaming\Microsoft
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>最主要的是这三个目录下的 Microsfot 目录，还有 Packages 目录。在整理 AppData 时，不要误删了。&lt;/p>
&lt;h1 id="program-files">Program Files&lt;/h1>
&lt;p>该目录存储安装在计算机上的大多数应用程序的执行文件。&lt;/p>
&lt;h1 id="program-filesx86">Program Files(x86)&lt;/h1>
&lt;p>该目录存储在 64 位 Windows 系统上安装的 32 位应用程序的执行文件。&lt;/p>
&lt;h1 id="programdata">ProgramData&lt;/h1>
&lt;p>该目录存储全局数据，包括应用程序的配置文件，以及系统的安装和更新信息。&lt;/p>
&lt;h1 id="users">Users&lt;/h1>
&lt;p>该目录存储在 Windows 系统上创建的每个用户的个人文件夹，如桌面、文档和图片。&lt;/p>
&lt;h1 id="windows">Windows&lt;/h1>
&lt;p>Windows 操作系统的核心文件和 DLL 文件都存储在此目录中。&lt;/p>
&lt;p>&lt;strong>./System32/&lt;/strong> # 类似于 Linux 中的 /usr/sbin/ 目录，系统自带的命令、服务、msc 的可执行文件都在这里。&lt;/p></description></item><item><title>Docs: Function(函数)</title><link>https://desistdaydream.github.io/docs/2.%E7%BC%96%E7%A8%8B/%E8%A7%A3%E8%B0%9C%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/Function%E5%87%BD%E6%95%B0/Function%E5%87%BD%E6%95%B0/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/2.%E7%BC%96%E7%A8%8B/%E8%A7%A3%E8%B0%9C%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/Function%E5%87%BD%E6%95%B0/Function%E5%87%BD%E6%95%B0/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Subroutine">Wiki,Subroutine(子程序)&lt;/a>
&lt;ul>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Function_(computer_science)">Wiki,Function&lt;/a> 概念被合并到 Subroutine 中&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Parameter_(computer_programming)">Wiki,Parameter(参数)&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Evaluation_strategy">Wiki,Evaluation strategy(评估策略)&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://mp.weixin.qq.com/s/33__rGbvEHUB7nXWPSvz8Q">公众号，码农的荒岛求生-函数调用时底层发生了什么？&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>在计算机编程中，&lt;strong>Subroutine(子程序)&lt;/strong> 是执行特定任务的程序指令序列，打包为一个单元。然后，该单元可用于应执行特定任务的程序中。&lt;/p>
&lt;p>子程序可以在程序中定义，也可以在可以被许多程序使用的库中单独定义。在不同的编程语言中，子例程可以称为 &lt;strong>Routine(例程)&lt;/strong>、&lt;strong>Subprogram(子程序)&lt;/strong>、&lt;strong>Function(函数)&lt;/strong>、&lt;strong>Method(方法)&lt;/strong> 或 &lt;strong>Procedure(过程)&lt;/strong>。从技术上讲，这些术语都有不同的定义。有时会使用通用的总称 &lt;strong>Callable Unit(可调用单元)&lt;/strong>。&lt;/p>
&lt;h1 id="function-call函数调用">Function call(函数调用)&lt;/h1>
&lt;h2 id="parameter参数">Parameter(参数)&lt;/h2>
&lt;p>在计算机编程中，&lt;strong>Parameter(参数)&lt;/strong> 是函数中使用的一种&lt;strong>特殊变量&lt;/strong>，用于在引用函数时，提供给函数的输入数据。&lt;/p>
&lt;ul>
&lt;li>&lt;strong>actual parameter(实际参数，简称 实参)&lt;/strong> # 一般用 arguments 表示，在调用函数时使用实参&lt;/li>
&lt;li>&lt;strong>formal parameter(形式参数，简称 形参)&lt;/strong> # 一般用 parameter 表示，在定义函数时使用形参&lt;/li>
&lt;/ul>
&lt;p>如何将 Arguments 的值传递给子程序的 Parameters 是由编程语言的 &lt;strong>Evaluation strategy(评估策略)&lt;/strong> 决定的。每次调用子程序时，都会评估本次调用的 Arguments，并将评估结果分配给相应的 Parameters。这种分配机制，称为 &lt;strong>Argument passing(参数传递)&lt;/strong>。&lt;/p>
&lt;p>例如：
现在定义一个名为 &lt;code>add&lt;/code> 的子程序：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-c" data-lang="c">&lt;span style="display:flex;">&lt;span>def &lt;span style="color:#a6e22e">add&lt;/span>(x, y){
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> x &lt;span style="color:#f92672">+&lt;/span> y
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>这里的 x 和 y 是 &lt;strong>形式参数&lt;/strong>&lt;/p>
&lt;p>如果要引用这个子程序：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-c" data-lang="c">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">add&lt;/span>(&lt;span style="color:#ae81ff">2&lt;/span>, &lt;span style="color:#ae81ff">3&lt;/span>)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>这里的 2 和 3 是&lt;strong>实际参数&lt;/strong>。&lt;/p>
&lt;p>所以，就跟参数的名字一样，形式参数就是形式上的，没有一个具体的数据，而实际参数之所以称为实际，就是因为这些参数有具体的数据。&lt;/p>
&lt;blockquote>
&lt;p>注意：根据评估策略的不同，所谓的实际参数和形式参数也是相对来说的，比如在很多时候，我们传递的实际参数还可以是 另一个 Function、Pointer(指针) 等等类型的数据。&lt;/p>
&lt;/blockquote>
&lt;h2 id="evaluation-strategy评估策略">Evaluation strategy(评估策略)&lt;/h2>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>Convention&lt;/th>
&lt;th>Description&lt;/th>
&lt;th>Common use&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>Call by value(值调用)值传递&lt;/td>
&lt;td>将参数的值的副本传递给子程序。(子程序内修改它们不会影响原始参数)&lt;/td>
&lt;td>Default in most Algol-like languages after &lt;a href="https://en.wikipedia.org/wiki/Algol_60">Algol 60&lt;/a>, such as Pascal, Delphi, Simula, CPL, PL/M, Modula, Oberon, Ada, and many others. C, C++, Java (References to objects and arrays are also passed by value)&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Call by reference(引用调用)引用传递&lt;/td>
&lt;td>将参数的引用地址传递给子程序(子程序内修改它们会影响原始参数)&lt;/td>
&lt;td>Selectable in most Algol-like languages after &lt;a href="https://en.wikipedia.org/wiki/Algol_60">Algol 60&lt;/a>, such as Algol 68, Pascal, Delphi, Simula, CPL, PL/M, Modula, Oberon, Ada, and many others. C++, Fortran, &lt;a href="https://en.wikipedia.org/wiki/PL/I">PL/I&lt;/a>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Call by result&lt;/td>
&lt;td>Parameter value is copied back to argument on return from the subroutine&lt;/td>
&lt;td>Ada OUT parameters&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Call by value-result&lt;/td>
&lt;td>Parameter value is copied back on entry to the subroutine and again on return&lt;/td>
&lt;td>Algol, &lt;a href="https://en.wikipedia.org/wiki/Swift_(programming_language)">Swift&lt;/a>in-out parameters&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Call by name&lt;/td>
&lt;td>Like a macro – replace the parameters with the unevaluated argument expressions&lt;/td>
&lt;td>Algol, &lt;a href="https://en.wikipedia.org/wiki/Scala_(programming_language)">Scala&lt;/a>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Call by constant value&lt;/td>
&lt;td>Like call by value except that the parameter is treated as a constant&lt;/td>
&lt;td>PL/I NONASSIGNABLE parameters, Ada IN parameters&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="call-by-reference通过引用调用-与-call-by-value通过值调用">Call by Reference(通过引用调用) 与 Call by Value(通过值调用)&lt;/h3>
&lt;ul>
&lt;li>通过值调用(Call by value) 意味着，在函数体内修改参数值，不会影响到函数外部。&lt;/li>
&lt;li>通过引用调用(Call by reference) 意味着，传入函数的原始值的地址，因此在函数内部修改参数，将会影响到原始值。&lt;/li>
&lt;/ul>
&lt;h1 id="函数调用时底层逻辑">函数调用时底层逻辑&lt;/h1>
&lt;p>有读者问题函数调用是如何实现的，今天就来聊聊这个比较简单的问题。&lt;/p>
&lt;p>大家都应该打包过东西吧，搬家之类的，通常都是找几个箱子一股脑装进去，为了不让箱子占地方，你通常会把它们摞好，就像这样：&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/qu324i/1648437687225-6414f1c8-2f44-4c24-978d-8a4cc6a65ba5.jpeg" alt="">&lt;/p>
&lt;p>注意看上面的箱子，最先被打包好的箱子被摞在最下方，刚打包好的箱子总是放在最上方，这就形成了一种 first in last out 的结构，也就是我们所说的栈，stack，上面的这些箱子就形成了栈。&lt;/p>
&lt;p>如果你懂得用箱子打包东西，你就能明白函数调用是怎么一回事。&lt;/p>
&lt;p>原来，在程序运行时每个被调用的函数都有自己的一个箱子，假设这段代码是这样写的：&lt;/p>
&lt;p>void D() {}
void C() {
  D();
}
void B() {
    C();
}
void A() {
  B();
}&lt;/p>
&lt;p>函数 A 调用函数 B、B 调用 C、C 调用 D，那么当函数 D 在运行时内存中就会有四个箱子，每个函数一个：&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/qu324i/1648437687180-74941560-51a7-421b-8cc8-793c48703b11.png" alt="">&lt;/p>
&lt;p>每个函数占据的这个箱子——也就是这块内存，就被称为栈帧，stack frame，只不过由于引力的作用，我们摞箱子时是从下往上增长，而出于内存布局的需要，函数调用时的栈是从高地址向低地址增长。&lt;/p>
&lt;p>这些箱子中都装有什么呢？你在函数中定义的局部变量就装在这里，关于栈帧内容更详细的讲解你可以参考这里《&lt;a href="http://mp.weixin.qq.com/s?__biz=Mzg4OTYzODM4Mw==&amp;amp;mid=2247485714&amp;amp;idx=1&amp;amp;sn=1a315fe4da87fde2758fc9dd5366ba01&amp;amp;chksm=cfe99592f89e1c84b87ebfbfbbbd9868ddf3e945666168122f57aa793e87787528b513e46e5d&amp;amp;scene=21#wechat_redirect">函数调用是在内存中是什么样子&lt;/a>》，这些不是本文的重点，这里更关心的是这些栈帧是怎样增长以及减少的。&lt;/p>
&lt;p>仔细观察上面这张图，每个箱子最重要的信息有两个，&lt;strong>你至少需要知道箱子的底部以及箱子的顶部在哪里&lt;/strong>！&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/qu324i/1648437687271-bdc684c3-a08f-4654-be59-0bd20b8a9630.png" alt="">&lt;/p>
&lt;p>在计算机中，每个函数栈帧的“底部”和“顶部”的信息——也就是内存地址，分别存放在两个寄存器中：BasePointer(BP)寄存器以及 StackPointer(SP)寄存器，即我们熟悉的 rbp 以及 rsp，32 位下为 ebp 以及 esp，注意本文以 x86_64 为例。&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/qu324i/1648437687166-7105bbca-8df4-4044-894f-11e5b13fa005.png" alt="">&lt;/p>
&lt;p>只要确定了 rbp 和 rsp 你就能得到一块栈区，在这块栈区上就可以进行函数调用：&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/qu324i/1648437687303-279472cc-ed4a-4525-b4f5-6994ef566265.png" alt="">&lt;/p>
&lt;p>读到这里肯定有的同学可能会问，CPU 中的寄存器不是有限的吗？从这里的讲解看每个栈帧都需要维护一个“栈顶”与“栈底”的信息，每个核心中的 rbp 以及 rsp 寄存器就一个，我们该怎样确保函数运行时相应栈帧使用的 rbp 以及 rsp 是正确的呢？&lt;/p>
&lt;p>方法非常简单，调用函数时会创建新的栈帧，此时需要将原有 rbp 寄存器中的值保存在新的栈帧上，就像这样：&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/qu324i/1648437687582-ed1046b1-c111-4c30-bf2e-310c2bc3c6ac.png" alt="">&lt;/p>
&lt;p>上图就是函数调用时第一件要完成的事情，把 rbp 的值 push 到栈上，rsp 下移，然后呢？然后也很简单，只需要把 rsp 指向的地址也赋值给 rbp 即可，这样就开启了一个新的栈帧：&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/qu324i/1648437687685-0e112e19-781f-48d1-8afb-fe172ce5f2a8.png" alt="">&lt;/p>
&lt;p>完成上述操作的有两条机器指令(gcc 编译器)：&lt;/p>
&lt;p>push   %rbp
mov    %rsp,%rbp&lt;/p>
&lt;p>如果你去看编译器为每个函数生成的机器指令，那么开头几乎都是这两条指令，现在你应该明白这两条指令的作用了吧。&lt;/p>
&lt;p>这两条指令就把上一个栈帧的 rbp 的保存到了新的栈帧，由于此时 rsp 已经指向了新的栈帧栈顶，由于此时栈为空，因此栈顶和栈底的地址是一样的，可以直接把 rsp 赋给 rbp，这样一个全新的栈帧就创建出来了。&lt;/p>
&lt;p>如果我们在被调函数内部创建一些局部变量：&lt;/p>
&lt;p>void funcB() {
    int a = 1;
    int b = 2;
    int c = 3;
    &amp;hellip;
}&lt;/p>
&lt;p>那么此时栈会进一步扩大，并把局部变量存放在该函数的栈帧中：&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/qu324i/1648437687701-456ca282-1ecb-420c-b487-4702fbb25770.png" alt="">&lt;/p>
&lt;p>现在我们的栈可以随着函数调用而增长，可以看到，栈帧和你搬家时用的纸箱子还是不太一样的，函数栈帧不会一开始就大小固定好，而是随着指令的执行动态增加，也就是如果你往栈上 push 一些数据，栈帧就会相应的增大一点。&lt;/p>
&lt;p>那么函数调用完成时该怎么办呢？这也非常简单，只需要一条机器指令：&lt;/p>
&lt;p>leave&lt;/p>
&lt;p>我们在上一篇《&lt;a href="http://mp.weixin.qq.com/s?__biz=Mzg4OTYzODM4Mw==&amp;amp;mid=2247486951&amp;amp;idx=1&amp;amp;sn=9ed9294b2248b3287e60d38ac0b7fca4&amp;amp;chksm=cfe99167f89e1871915861369c3f39bf1850754e974da1f9f7367fdb37c64d22fc3425a65c9e&amp;amp;scene=21#wechat_redirect">栈区分配内存快还是堆区分配内存快&lt;/a>》中讲解了一部分，leave 指令的作用是将栈基址赋值给 rsp，这样栈指针指向上一个栈帧的栈顶，然后 pop 出 rbp，这样 rbp 就指向上一个栈帧的栈底：&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/qu324i/1648437687723-01062541-9dd2-493f-aaaa-3fe4811c3212.png" alt="">&lt;/p>
&lt;p>看到了吧，执行完 leave 指令后 rbp 以及 rsp 就指向了上一个栈帧，这就相当于栈帧的弹出，这样 stack 1 占用的内存就无效了，没有任何用处了，显然这就是我们常说的内存回收，因此简单的一条 leave 指令即可把栈区中的内存回收掉。&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/qu324i/1648437687846-701d7bbb-5cb3-429c-a9b2-72441062dea5.png" alt="">&lt;/p>
&lt;p>而在 x86 平台，leave 指令后往往跟上一条 ret 指令：&lt;/p>
&lt;p>leave
ret&lt;/p>
&lt;p>我们已经了解了 leave 指令的作用，这条指令让 rbp 以及 rsp 指向上一个栈帧，然后呢？显然 CPU 应该从 funcA 调用函数 funcB 之后的一行代码处继续运行，那么这行代码的地址在哪里呢？显然就在 funcA 栈帧的栈顶：&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/qu324i/1648437688059-b40c97fe-0a35-4cee-8590-f072fad8be69.png" alt="">&lt;/p>
&lt;p>当 CPU 执行 call 指令时会把该函数的返回地址 push 到栈中，而 ret 指令的作用正是将栈顶弹出(pop)到 rip 寄存器，rip 寄存器告诉 CPU 接下来该从哪里执行机器指令，这个返回地址是 funcA 调用 funcB 时 push 到栈上的，这样当从函数 funcB()返回后我们就知道该从哪里继续执行机器指令了，这就是 ret 指令的作用，当然这里也是函数调用实现的基本原理。&lt;/p>
&lt;p>关于栈帧更详细的讲解可以参考我写的这篇《&lt;a href="http://mp.weixin.qq.com/s?__biz=Mzg4OTYzODM4Mw==&amp;amp;mid=2247485714&amp;amp;idx=1&amp;amp;sn=1a315fe4da87fde2758fc9dd5366ba01&amp;amp;chksm=cfe99592f89e1c84b87ebfbfbbbd9868ddf3e945666168122f57aa793e87787528b513e46e5d&amp;amp;scene=21#wechat_redirect">函数调用在内存中是什么样子&lt;/a>》。&lt;/p></description></item><item><title>Docs: Go</title><link>https://desistdaydream.github.io/docs/2.%E7%BC%96%E7%A8%8B/%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Go/Go/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/2.%E7%BC%96%E7%A8%8B/%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Go/Go/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://github.com/golang/go">GitHub 项目，golang/go&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://golang.org/">官网&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://cs.opensource.google/go">Google 开放源代码&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://github.com/avelino/awesome-go">GitHub 项目，avelino/awesome-go&lt;/a>(收录了优秀的 Go 框架、库、软件)
&lt;ul>
&lt;li>&lt;a href="https://github.com/yinggaozhen/awesome-go-cn">中文版，GitHub 项目，yinggaozhen/awesome-go-cn&lt;/a>&lt;/li>
&lt;li>另一个 go awesome: &lt;a href="https://github.com/shockerli/go-awesome">https://github.com/shockerli/go-awesome&lt;/a>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>Go 是一种开源编程语言，可以轻松构建 &lt;strong>simple(简单)&lt;/strong>、**reliable(可靠) **和 **efficient(高效) **的软件。&lt;/p>
&lt;h2 id="学习资料">学习资料&lt;/h2>
&lt;p>&lt;a href="https://go.dev/tour">Go 语言之旅&lt;/a>(官方在线教程)&lt;/p>
&lt;p>&lt;a href="https://go.dev/doc/faq">Go 官方 FAQ&lt;/a>&lt;/p>
&lt;p>&lt;a href="https://gobyexample.com/?tdsourcetag=s_pctim_aiomsg">Go by Example&lt;/a>&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://gobyexample-cn.github.io/">中文 Go by Example&lt;/a>&lt;/li>
&lt;/ul>
&lt;p>&lt;a href="https://github.com/golang-china">GitHub 组织，golang-china&lt;/a>(Go 语言中国)&lt;/p>
&lt;p>&lt;a href="https://mp.weixin.qq.com/s/pAkjxK6N4shTEtHXQbxChg">公众号-HelloGitHub，适合 Go 新手学习的开源项目&lt;/a>&lt;/p>
&lt;p>&lt;a href="https://www.topgoer.cn/">地鼠文档&lt;/a>系列文章&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://coolshell.cn/articles/series/go%e7%bc%96%e7%a8%8b%e6%a8%a1%e5%bc%8f">Go 编程模式&lt;/a>&lt;/li>
&lt;/ul>
&lt;p>电子书&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://github.com/unknwon/the-way-to-go_ZH_CN">GitHub 项目，unknowon/the-way-to-go&lt;/a>(Go 入门指南)&lt;/li>
&lt;li>&lt;a href="https://github.com/gopl-zh/gopl-zh.github.com">GitHub 项目，gopl-zh/gopl-zh.github.com&lt;/a>(Go 语言圣经)
&lt;ul>
&lt;li>&lt;a href="https://www.k8stech.net/gopl/chapter0/">The Go Programming Language&lt;/a>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>视频&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://www.bilibili.com/video/BV1hv411x7we?spm_id_from=333.999.0.0&amp;amp;vd_source=708696360de7266de8f3911eef0f7448">B 站-幼麟实验室-Golang 合辑&lt;/a>&lt;/li>
&lt;/ul>
&lt;p>&lt;a href="https://github.com/avelino/awesome-go">https://github.com/avelino/awesome-go&lt;/a>&lt;/p>
&lt;h1 id="hello-world">Hello World&lt;/h1>
&lt;p>代码：&lt;code>hello_world.go&lt;/code>&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">package&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">import&lt;/span> &lt;span style="color:#e6db74">&amp;#34;fmt&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">func&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">fmt&lt;/span>.&lt;span style="color:#a6e22e">Println&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;Hello World&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>运行&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># go run hello_world.go&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Hello World
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h1 id="go-范儿">Go 范儿&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://github.com/golang/go/wiki/CodeReviewComments">GitHub 项目 Wiki，golang/go-Wiki-Go 代码审查&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://go.dev/doc/effective_go#names">官方文档，有效的 Go-名称&lt;/a>
&lt;ul>
&lt;li>&lt;a href="https://makeoptim.com/golang/effective-go">MakeOptim 博客，Effective Go 中文&lt;/a>(官方文档的中文翻译)&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;a href="https://go.dev/blog/package-names">Go 博客，Package names&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.cnblogs.com/laud/p/gopher.html">博客园，不一样的 go 语言-gopher&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>gopher 原意地鼠，在 go 语言的世界里解释为地道的 go 程序员。在其他语言的世界里也有 PHPer，Pythonic 的说法，反而 Java 是个例外。虽然也有 Javaer 之类的说法，但似乎并不被认可。而地道或者说道地，说的是 gopher 写的代码无不透露出 go 的独特气息，比如项目结构、命名方式、代码格式、编码风格、构建方式等等。用 gopher 的话说，用 go 编写代码就像是在画一幅中国山水画，成品美不胜收，心旷神怡。&lt;/p>
&lt;h2 id="环境变量">环境变量&lt;/h2>
&lt;p>gopher 第一条：把东西放对地方。&lt;/p>
&lt;p>go 程序的运行，需要依赖于两个基础的环境变量，GOROOT 与 GOPATH。环境变量几乎在各类编程语言中都存在，比如 java 的 JAVA_HOME，其实也就是编译器及相关工具或标准库所在目录。但 go 除了 GOROOT 之外，还增加了 GOPATH，它指的是 go 程序依赖的第三方库或自有库所在目录，以指示编译器从这些地方找到依赖。GOPATH 支持多个目录，通常一个目录就是一个项目，并且 GOPATH 目录按约定由 src、pkg、bin 三个目录组成。gopher 们的做法是定义 Global GOPATH、Project GOPATH，而更大的项目还会定义 Module GOPATH。当使用 go get 下载依赖时，会选择 GOPATH 环境变量中的第一个目录存放依赖包。&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>变量&lt;/th>
&lt;th>含义&lt;/th>
&lt;th>说明&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>GOROOT&lt;/td>
&lt;td>go 运行环境根目录&lt;/td>
&lt;td>通常指 go sdk 安装目录，包含编译器、官方工具及标准库&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>GOPATH&lt;/td>
&lt;td>工作环境目录列表&lt;/td>
&lt;td>通常指第三方库&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h2 id="项目结构">项目结构&lt;/h2>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://github.com/golang-standards/project-layout">GitHub 项目，golang-standards/project-layout&lt;/a>
&lt;ul>
&lt;li>&lt;a href="https://makeoptim.com/golang/standards/project-layout">MakeOptim 博客，golang 编程规范-项目目录结构&lt;/a>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;a href="https://zhuanlan.zhihu.com/p/346573562">知乎，该如何组织 Go 项目结构？&lt;/a>
&lt;ul>
&lt;li>&lt;a href="https://www.ardanlabs.com/blog/2017/02/package-oriented-design.html">Package Oriented Design&lt;/a>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>gopher 第二条：按东西放在约定的地方。&lt;/p>
&lt;p>不论采用何种编程语言，良好的项目组织结构都至关重要，因为这将直接影响项目内部依赖的复杂程度以及项目对外提供 API 等服务的灵活性等。最好在项目初期便制定好项目结构约定，甚至可以为其开发脚手架之类的工具来生成项目模板，让开发者尽量按照统一的规范参与项目。&lt;/p>
&lt;p>一个常见的 Go 应用项目布局，通常有如下结构：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-latex" data-lang="latex">&lt;span style="display:flex;">&lt;span>- my-go-project
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - cmd
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - pkg
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - internal
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - go.mod &amp;amp;&amp;amp; go.sum
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - Makefile
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>其中 cmd 与 pkg 目录是最常见的。一个项目如果具有多个功能，比如 &lt;a href="https://github.com/kubernetes/kubernetes">kubernetes&lt;/a> 项目，具有多个组件，所有组件的入口都在 cmd 目录中，并以组件名命名其下的目录名。而每个组件所调用的各种功能，通常都是放在 pkg 目录下，一个功能一个目录，通常来说，pkg 目录是一个项目中代码量最多的地方。&lt;/p>
&lt;h3 id="cmd">cmd&lt;/h3>
&lt;p>cmd 包是项目的主干，是编译构建的入口，&lt;code>main()&lt;/code> 所在文件通常放置在此处。一个典型的 cmd 包的目录结构如下所示：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-latex" data-lang="latex">&lt;span style="display:flex;">&lt;span>- cmd
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - app1
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - main.go
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - app2
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - main.go
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>从上述例子可以看出，cmd 下可以允许挂载多个需要编译的应用，只需要在不同的包下编写 main 文件即可。需要注意的是，cmd 中的代码应该尽量「保持简洁」，&lt;code>main()&lt;/code> 函数中可能仅仅是参数初始化、配置加载、服务启动的操作。&lt;/p>
&lt;h3 id="pkg">pkg&lt;/h3>
&lt;p>pkg 中存放的是可供项目内部/外部所使用的公共性代码，例如：用来连接第三方服务的 client 代码等。也有部分项目将该包命名为 lib，例如：&lt;a href="https://link.zhihu.com/?target=https%3A//github.com/hashicorp/consul">consul 项目&lt;/a> ，所表示的含义其实相同。&lt;/p>
&lt;h3 id="internal">internal&lt;/h3>
&lt;p>internal 包主要用处在于提供一个项目级别的代码保护方式，存放在其中的代码仅供项目内部使用。具体使用的规则是：&amp;hellip;/a/b/c/internal/d/e/f 仅仅可以被&amp;hellip;/a/b/c 下的目录导入，&amp;hellip;/a/b/g 则不允许。internal 是 Go 1.4 版本中引入的特性，更多信息可以参考&lt;a href="https://link.zhihu.com/?target=https%3A//golang.org/doc/go1.4%23internalpackages">这里&lt;/a>。
在 internal 内部可以继续通过命名对目录的共享范围做区分，例如 internal/myapp 表示该目录下的代码是供 myapp 应用使用的；internal/pkg 表示该目录下的代码是可以供项目内多个应用使用的。&lt;/p>
&lt;h3 id="gomod--gosum">go.mod &amp;amp;&amp;amp; go.sum&lt;/h3>
&lt;p>go.mod 与 go.sum 是采用 go modules 进行依赖管理所生成的配置文件。go modules 是 Go 1.11 版本中引入的版本管理功能，目前已经是 go 依赖管理的主流方式，所以此处不再讨论 vendor，dep 等依赖管理方式所生成的目录。&lt;/p>
&lt;h3 id="makefile">Makefile&lt;/h3>
&lt;p>Makefile 文件通常存放项目的编译部署脚本。Go 的编译命令虽然简单，但总是手写命令还是效率低下，因此使用 Makefile 写编译部署脚本是工程实践中常见的方式。&lt;/p>
&lt;h3 id="服务端应用程序目录">服务端应用程序目录&lt;/h3>
&lt;h4 id="api">api&lt;/h4>
&lt;p>项目对外提供和依赖的 API 文件。比如：OpenAPI/Swagger specs, JSON schema 文件, protocol 定义文件等。
比如，&lt;a href="https://github.com/kubernetes/kubernetes/tree/master/api">Kubernetes&lt;/a> 项目的 api 目录结构如下：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>api
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>├── api-rules
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> └── xxx.plist
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>├── openapi-spec
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> └── swagger.json
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>因此，在 go 中用的比较多的 gRPC proto 文件，也比较适合放在 api 目录下。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>api
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>└── protobuf-spec
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> └── test
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ├── test.pb.go
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> └── test.proto
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="web-应用程序目录">Web 应用程序目录&lt;/h3>
&lt;h4 id="web">web&lt;/h4>
&lt;p>Web 应用程序特定的组件，比如 静态资源、服务器端模板和单页应用&lt;/p>
&lt;h3 id="通用应用程序目录">通用应用程序目录&lt;/h3>
&lt;h4 id="build">build&lt;/h4>
&lt;p>打包和持续集成所需的文件。&lt;/p>
&lt;ul>
&lt;li>build/ci：存放持续集成的配置和脚本，如果持续集成平台对配置文件有路径要求，则可将其 link 到指定位置。&lt;/li>
&lt;li>build/package：存放 AMI、Docker、系统包（deb、rpm、pkg）的配置和脚本等。&lt;/li>
&lt;/ul>
&lt;p>例子：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://github.com/cockroachdb/cockroach/tree/master/build">https://github.com/cockroachdb/cockroach/tree/master/build&lt;/a>&lt;/li>
&lt;/ul>
&lt;h4 id="configs">configs&lt;/h4>
&lt;p>配置文件模板或默认配置。&lt;/p>
&lt;h4 id="deployments">deployments&lt;/h4>
&lt;p>IaaS，PaaS，系统和容器编排部署配置和模板（docker-compose，kubernetes/helm，mesos，terraform，bosh）。请注意，在某些存储库中（尤其是使用 kubernetes 部署的应用程序），该目录的名字是 /deploy。&lt;/p>
&lt;h4 id="init">init&lt;/h4>
&lt;p>系统初始化（systemd、upstart、sysv）和进程管理（runit、supervisord）配置。&lt;/p>
&lt;h4 id="scripts">scripts&lt;/h4>
&lt;p>用于执行各种构建，安装，分析等操作的脚本。
这些脚本使根级别的 Makefile 变得更小更简单，例如：&lt;a href="https://github.com/hashicorp/terraform/blob/master/Makefile">https://github.com/hashicorp/terraform/blob/master/Makefile&lt;/a>。&lt;/p>
&lt;h4 id="test">test&lt;/h4>
&lt;p>外部测试应用程序和测试数据。随时根据需要构建 /test 目录。对于较大的项目，有一个数据子目录更好一些。例如，如果需要 Go 忽略目录中的内容，则可以使用 /test/data 或 /test/testdata 这样的目录名字。请注意，Go 还将忽略以“.”或“_”开头的目录或文件，因此可以更具灵活性的来命名测试数据目录。&lt;/p>
&lt;h3 id="其他目录">其他目录&lt;/h3>
&lt;h4 id="assets">assets&lt;/h4>
&lt;p>项目中使用的其他资源（图像、logo 等）。&lt;/p>
&lt;h4 id="docs">docs&lt;/h4>
&lt;p>设计和用户文档（除了 godoc 生成的文档）。&lt;/p>
&lt;h4 id="examples">examples&lt;/h4>
&lt;p>应用程序或公共库的示例程序。&lt;/p>
&lt;h4 id="githooks">githooks&lt;/h4>
&lt;p>Git 钩子。&lt;/p>
&lt;h4 id="third_party">third_party&lt;/h4>
&lt;p>外部辅助工具，fork 的代码和其他第三方工具（例如：Swagger UI）。&lt;/p>
&lt;h4 id="tools">tools&lt;/h4>
&lt;p>此项目的支持工具。请注意，这些工具可以从 /pkg 和 /internal 目录导入代码。
例子：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://github.com/istio/istio/tree/master/tools">https://github.com/istio/istio/tree/master/tools&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://github.com/openshift/origin/tree/master/tools">https://github.com/openshift/origin/tree/master/tools&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://github.com/dapr/dapr/tree/master/tools">https://github.com/dapr/dapr/tree/master/tools&lt;/a>&lt;/li>
&lt;/ul>
&lt;h4 id="website">website&lt;/h4>
&lt;p>如果不使用 Github pages，则在这里放置项目的网站数据。
例子：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://github.com/hashicorp/vault/tree/master/website">https://github.com/hashicorp/vault/tree/master/website&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://github.com/perkeep/perkeep/tree/master/website">https://github.com/perkeep/perkeep/tree/master/website&lt;/a>&lt;/li>
&lt;/ul>
&lt;h3 id="不应该包含的目录">不应该包含的目录&lt;/h3>
&lt;p>项目中不应该包含 src 目录&lt;/p>
&lt;p>在 Java 项目中，会常见 src 目录，但在 Go 项目中，并不推荐这么做。在 Go 1.11 之前，Go 项目是放在 $GOPATH/src 下，如果项目中再包含 src 目录，那么代码结构就会类似： &lt;code>$GOPATH/src/my-project/src/app.go&lt;/code>的结构，容易造成混淆。在 Go 引入 modules 之后，项目可以不用写在 $GOPATH 下，但是依然不推荐项目中采用&lt;code>src&lt;/code> 来命名目录。&lt;/p>
&lt;h2 id="命名规范">命名规范&lt;/h2>
&lt;p>gopher 第三条：把名字起得 go 一点。&lt;/p>
&lt;p>go 语言的命名与其他语言最大的不同在于首字母的大小写。&lt;/p>
&lt;ul>
&lt;li>大写代表公开（导出，可以在其他包内访问）&lt;/li>
&lt;li>小写代表私有（不导出，只能在包内访问）。&lt;/li>
&lt;/ul>
&lt;p>除此之外，与其他语言并无二致，比如不能以数字开头。而由于关键字、保留字的减少，因而减少了一些命名上的忌讳。更为突出的是，go 语言有一些建议性的命名规范，这也是 gophers 的圣经，理应严格遵守。&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>约定&lt;/th>
&lt;th>范围&lt;/th>
&lt;th>说明&lt;/th>
&lt;th>示例&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>驼峰命名法&lt;/td>
&lt;td>全局&lt;/td>
&lt;td>统一使用驼峰命名法&lt;/td>
&lt;td>var isLive = false&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>大小写一致&lt;/td>
&lt;td>缩写短语，惯用词&lt;/td>
&lt;td>如 HTML，CSS, HTTP 等&lt;/td>
&lt;td>htmlEscape，HTMLEscape&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>简短命名法&lt;/td>
&lt;td>局部变量&lt;/td>
&lt;td>方法内、循环等使用的局部变量可以使用简短命名&lt;/td>
&lt;td>比如 for 循环中的 i，buf 代表 buffer 等&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>参数命名法&lt;/td>
&lt;td>函数参数、返回值、方法接收者&lt;/td>
&lt;td>如果参数类型能说明含义，则参数名可以简短，否则应该采用有文档说明能力的命名&lt;/td>
&lt;td>比如 d Duration，t Time&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>通用命名法&lt;/td>
&lt;td>作用域越大或者使用的地方离声明的地方太远，则应采用清晰有意义的命名&lt;/td>
&lt;td>-&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>导出命名法&lt;/td>
&lt;td>导出变量、函数、结构等&lt;/td>
&lt;td>包名与导出名意义不要重复，同时包的命名要与导出的内容相关，不要使用宽泛的名字，如 common，util&lt;/td>
&lt;td>bytes.Buffer 比 bytes.ByteBuffer 要好&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>文件命名&lt;/td>
&lt;td>go 文件，单元测试文件&lt;/td>
&lt;td>go 文件名尽量以一个单词来命名，多个单词使用下线划分隔，单元测试文件以对应 go 文件名加_test 结尾&lt;/td>
&lt;td>proto_test&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>包命名&lt;/td>
&lt;td>包&lt;/td>
&lt;td>包的一级名称应是顶级域名，二级名称则应是项目名称，项目名称单词间以-分隔&lt;/td>
&lt;td>github.com/mysql&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h2 id="代码格式">代码格式&lt;/h2>
&lt;p>gopher 第四条：按统一的格式来。&lt;/p>
&lt;p>在多人协作团队中，统一的代码格式化模板是第一要义。在 Java 语言中，检验新人经验的一大法宝就是他有没有主动索要代码模板。而在 go 语言中，则没有这个必要了。因为 go 已经有默认的代码格式化工具了，而且代码格式化在 go 语言中是强制规范。所以这使得所有 go 程序员写出来的代码格式都是一样的。&lt;/p>
&lt;p>go 默认的代码格式化工具是 gofmt。另外还有一个增强工具 goimport，在 gofmt 的基础上增加了自动删除和引入依赖包。而行长则以不超过 80 个字符为佳，超过请主动以多行展示。&lt;/p>
&lt;h2 id="编码风格">编码风格&lt;/h2>
&lt;p>gopher 第五条：请学会约定&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>项&lt;/th>
&lt;th>约定&lt;/th>
&lt;th>说明&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>import&lt;/td>
&lt;td>按标准库、内部包、第三方包的顺序导入包&lt;/td>
&lt;td>只引一个包时使用单行模式，否则使用多行模式&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>变量声明&lt;/td>
&lt;td>如果连续声明多个变量，应放在一起&lt;/td>
&lt;td>参见例子&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>错误处理&lt;/td>
&lt;td>不要忽略每一个 error，即使只是打一行日志&lt;/td>
&lt;td>go 的 error 处理方式与 C 同出一辙，通过返回值来标明错误或异常，引来的争议也很多，甚至官方已经开始酝酿在 go2 解决这个问题&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>长语句打印&lt;/td>
&lt;td>使用格式化方式打印&lt;/td>
&lt;td>-&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>注释规范&lt;/td>
&lt;td>变量、方法、结构等的注释直接加上声明前，并且不要加空行。废弃方法加 Deprecated:即可&lt;/td>
&lt;td>其中的第一行注释会被 godoc 识别为简短介绍，第二行开始则被认为是注释详情。注释对 godoc 的生成至关重要，因此关于注释会有一些技巧，我将在后面用专门的章节探讨&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>多变量声明&lt;/p>
&lt;pre>&lt;code>var (
name string
age int
)
&lt;/code>&lt;/pre>
&lt;p>注释规范&lt;/p>
&lt;pre>&lt;code>// Add 两数相加
// 两个整数相加，并返回和。
func Add(n1, n2 int)int{
return n1 + n2
}
&lt;/code>&lt;/pre>
&lt;h2 id="依赖管理">依赖管理&lt;/h2>
&lt;p>gopher 第六条：使用依赖管理工具管理自有依赖与第三方依赖&lt;/p>
&lt;p>一个语言的生态是否完善甚至是否强大，除了 github 上面的开源项目数量之外，还有一大特征就是是否有优秀的依赖管理工具。依赖管理工具在业界已经是无处不在，yum、maven、gradle、pip、npm、cargo 这些工具的大名如雷贯耳。那么 go 有什么呢？&lt;/p>
&lt;p>早期 go 的依赖是混乱的，因为没有一个工具能得到普遍认可，而官方又迟迟不出来解决问题。历数存在的工具包括 godep、glide、govender 等等。甚至早期还需要使用 GOPATH 来管理依赖，即项目的所有依赖都通过 go get 下载到指定的 GOPATH 中去。当然这种方案还可以撑大多数时间，但随着时间的流逝，随着开发人员的变动，这种管理依赖的弊端就慢慢显现出来。其实这些老路早期的 java 也走过，曾几何时，每个 java 项目里面都会有一个叫 lib 或 libs 的目录，这里放的就是当前项目依赖的包。当 GO 采用 GOPATH 来管理依赖时，开发人员只能被倒逼着用 java 的方式在源码库中自行管理依赖。这样相当于给依赖包做了隔离，同时又具备了版本管理（因为放在源码库）。&lt;/p>
&lt;p>后来在 go1.5 的时候，官方引入了 vender 的概念，其实这也没改变多少，只是官方让大家存放依赖包的目录名称不要乱起了，统一叫 vender 吧。这个方案我觉得比依赖 GOPATH 还糟糕，因为 vendor 目录脱离了版本管理，导致更换依赖包版本很困难，在当前项目对依赖包的版本更新可能会影响其他项目的使用（如果新版本的依赖包有较大变动的话），同时如何将依赖包放到 vendor 下呢？等等。当然官方做出的这些变动可能是想像 maven 那样，推动社区来完成这件事，因而直接推动了上文提到的基于 vendor 的依赖管理工具的诞生。直至后来官方默认的社区做出来 dep，这下安静了，尽管刚开始时也不怎么好用，但有总比没有好。&lt;/p>
&lt;p>go1.11 在 vgo 的基础上，官方推出了 go module。在发布前，官方与社区的大神们还为此开吵，认为官方太不厚道且独断专行。完全忽视 dep 社区的存在，无视 dep 在 go 语言中的地位与贡献。喜欢八卦的朋友们，可搜索《关于 Go Module 的争吵》一览大神是怎么吵架的，也可从中学习他们的思想。&lt;/p>
&lt;p>相对于 java 的依赖管理工具 maven 或 gradle 来说，gradle 是 maven 的升级版，同时带来了 DSL 与元编程的特性，这无疑使得 gradle 异常地强大。但 gradle.io 在国内的可达情况也不尽如人意，好就好在其与 maven 仓库标准的兼容，使得从 maven 转到 gradle 几乎没有额外的成本及阻力。&lt;/p>
&lt;p>扯了这么多，依赖管理对于一门语言是必不可少的。c 有 cmake，java 有 maven、gradle，rust 有 cargo，那么 go 的 dep 或者 module 就用起来吧，看完大神吵架之后，喜欢哪个就选哪个。是不可能产生一个能满足所有人要求的依赖管理工具的，就连号称最牛逼的 cargo 也不例外。在一般的项目中，能用到的依赖管理功能也就那常用的几个而已，对大多数项目来说，适用好用就行。&lt;/p>
&lt;h2 id="构建方式">构建方式&lt;/h2>
&lt;p>gopher 第七条：按需构建&lt;/p>
&lt;p>构建的目标是让代码成为可运行程序。构建的过程应该是低成本并且让人愉悦的，显然 C 在这一方面让人抓狂，而 go 确实做得不错。并且能在任何平台下编译出另外一个平台的可执行程序。不管你的 go 程序是 CLI、GUI、WEB 或者其他形式的网络通讯程序，在 go 的世界里都只需要一个命令构建成可执行程序（依赖也一并被打包），即可在目标系统上运行。在这一点上，java 是望尘莫及了。
下面是用来构建 go 程序常用的参数，其他参数可通过 go help environment 命令查看。&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>参数&lt;/th>
&lt;th>值&lt;/th>
&lt;th>说明&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>CGO_ENABLED&lt;/td>
&lt;td>0 or 1&lt;/td>
&lt;td>是否支持 cgo 命令，如果 go 代码中有 c 代码，需要设置为 1&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>GOOS&lt;/td>
&lt;td>darwin, freebsd, linux, windows&lt;/td>
&lt;td>可执行程序运行的目标操作系统&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>GOARCH&lt;/td>
&lt;td>386, amd64, arm&lt;/td>
&lt;td>可执行程序运行的目标操作系统架构&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># Linux下编译Mac 64位可执行程序&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>CGO_ENABLED&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">0&lt;/span> GOOS&lt;span style="color:#f92672">=&lt;/span>darwin GOARCH&lt;span style="color:#f92672">=&lt;/span>amd64 go build main.go
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># Linux下编译windows 64位可执行程序&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>CGO_ENABLED&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">0&lt;/span> GOOS&lt;span style="color:#f92672">=&lt;/span>windows GOARCH&lt;span style="color:#f92672">=&lt;/span>amd64 go build main.go
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># 如果想减少二进制程序的大小，可以加上-ldflags &amp;#34;-s -w&amp;#34;，但同时会丢掉调试信息，即不能用gdb调试了。&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># 如果想更进一步减少程序大小，可以使用加壳工具，比如upx&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h1 id="版本变化">版本变化&lt;/h1>
&lt;p>Go 1.16 将会弃用 io/ioutil 包，ioutil 包中的功能将会由 io 及 os 包所替代。详见：&lt;a href="https://github.com/golang/go/issues/40025">#40025&lt;/a>、&lt;a href="https://golang.org/doc/go1.16#ioutil">Go 1.16 Release Notes&lt;/a>&lt;/p></description></item><item><title>Docs: Go 规范与标准库</title><link>https://desistdaydream.github.io/docs/2.%E7%BC%96%E7%A8%8B/%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Go/Go-%E8%A7%84%E8%8C%83%E4%B8%8E%E6%A0%87%E5%87%86%E5%BA%93/Go-%E8%A7%84%E8%8C%83%E4%B8%8E%E6%A0%87%E5%87%86%E5%BA%93/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/2.%E7%BC%96%E7%A8%8B/%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Go/Go-%E8%A7%84%E8%8C%83%E4%B8%8E%E6%A0%87%E5%87%86%E5%BA%93/Go-%E8%A7%84%E8%8C%83%E4%B8%8E%E6%A0%87%E5%87%86%E5%BA%93/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://go.dev/ref/spec">Go 官方文档，参考-语言规范&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://pkg.go.dev/std">Go 包，标准库&lt;/a>
&lt;ul>
&lt;li>&lt;a href="https://studygolang.com/pkgdoc">中文文档&lt;/a>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;a href="https://go.dev/tour/list">go.dev,Tour(Go 语言之旅，通过在线解析器体验 Go 语言的各种特性)&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://github.com/DesistDaydream/go-learning">GitHub,DesistDaydream/go-learning&lt;/a>(学习代码)&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>Go 是一种通用语言，专为系统编程而设计。它是一种强类型且自带垃圾回收功能的语言，并具有显式支持并发编程的能力(称为 goroutine)。Go 程序由 Packages(包) 构建，其属性允许有效得管理依赖关系。&lt;/p>
&lt;ul>
&lt;li>&lt;strong>Go 语言参考&lt;/strong>描述了 Go 语言的具体语法和语义&lt;/li>
&lt;li>&lt;strong>Go 标准库则&lt;/strong>是与 Go 语言一起发行的一些可选功能，以便人们可以从一开始就轻松得使用 Go 进行编程。&lt;/li>
&lt;/ul>
&lt;h1 id="go-语言关键字">Go 语言关键字&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://go.dev/ref/spec#Keywords">官方文档，参考-规范-关键字&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>Go 语言非常简单，只有 25 个&lt;code>关键字(Keywords)&lt;/code>可以使用，记住这 25 个关键字，就掌握了最基本的 Go 语言用法。这些关键字是 go 语言保留的，不能用作标识符&lt;/p>
&lt;p>&lt;code>关键字&lt;/code>在编程语言中是指该语言的一个功能，比如下文面的 &lt;code>var&lt;/code>，就是指声明一个变量，&lt;code>func&lt;/code> 就是定义一个函数等等。&lt;/p>
&lt;blockquote>
&lt;p>Note: if-else 算两个关键字所以在这里一共只写了 24 个。&lt;/p>
&lt;/blockquote>
&lt;ol>
&lt;li>&lt;strong>break&lt;/strong> # 控制结构&lt;/li>
&lt;li>&lt;strong>case&lt;/strong> # 控制结构&lt;/li>
&lt;li>&lt;strong>chan&lt;/strong> # 用于 channel 通讯&lt;/li>
&lt;li>&lt;strong>const&lt;/strong> # 语言基础里面的常量申明&lt;/li>
&lt;li>&lt;strong>continue&lt;/strong> # 用在 for 控制结构中，用以忽略本次循环的后续所有逻辑，执行下一次循环&lt;/li>
&lt;li>&lt;strong>default&lt;/strong> # 控制结构&lt;/li>
&lt;li>&lt;strong>defer&lt;/strong> # 用于在函数退出之前执行某语句的功能&lt;/li>
&lt;li>&lt;strong>fallthrough&lt;/strong> # 控制结构&lt;/li>
&lt;li>&lt;strong>for&lt;/strong> # 控制结构&lt;/li>
&lt;li>&lt;strong>func&lt;/strong> # 用于定义函数和方法&lt;/li>
&lt;li>&lt;strong>go&lt;/strong> # 用于并发&lt;/li>
&lt;li>&lt;strong>goto&lt;/strong> 控制结构&lt;/li>
&lt;li>&lt;strong>if-else&lt;/strong> # 控制结构&lt;/li>
&lt;li>&lt;strong>import&lt;/strong> 用于定义该文件引用某个包&lt;/li>
&lt;li>&lt;strong>interface&lt;/strong> # 用于定义接口&lt;/li>
&lt;li>&lt;strong>map&lt;/strong> # 用于声明 map 类型数据&lt;/li>
&lt;li>&lt;strong>package&lt;/strong> # 用于定义该文件所属的包&lt;/li>
&lt;li>&lt;strong>range&lt;/strong> # 用于读取 slice、map、channel 数据&lt;/li>
&lt;li>&lt;strong>return&lt;/strong> # 用于从函数返回。有时候也用来直接跳出当前函数，回到主程序继续执行&lt;/li>
&lt;li>&lt;strong>select&lt;/strong> # 用于选择不同类型的通讯&lt;/li>
&lt;li>&lt;strong>struct&lt;/strong> # 用于定义抽象数据类型&lt;/li>
&lt;li>&lt;strong>switch&lt;/strong> # 控制结构&lt;/li>
&lt;li>&lt;strong>type&lt;/strong> # 用于 Type Declarations(类型声明)，有两种形式：&lt;/li>
&lt;li>Definitions(定义) 自定义类型&lt;/li>
&lt;li>Declarations(声明) 一个类型的别名。
&lt;ol>
&lt;li>其实所谓的类型的别名，也可以当作一种自定义的类型。&lt;/li>
&lt;/ol>
&lt;/li>
&lt;li>&lt;strong>var&lt;/strong> # 用于 Declarations(声明) 变量&lt;/li>
&lt;/ol>
&lt;h1 id="go-语言规范">Go 语言规范&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://go.dev/ref/spec">官方文档，参考-规范&lt;/a>
&lt;ul>
&lt;li>&lt;a href="https://github.com/bekcpear/mypelicanconfandarticles/blob/master/content/Tech/gospec.rst">官方文档，参考-规范 的翻译&lt;/a>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;h2 id="notation表示法">Notation(表示法)&lt;/h2>
&lt;p>Go 语言的语法遵从 &lt;a href="https://en.wikipedia.org/wiki/Extended_Backus%E2%80%93Naur_form">EBNF&lt;/a> 表示法&lt;/p>
&lt;h1 id="go-标准库">Go 标准库&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://pkg.go.dev/std">Go 包，标准库&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>&lt;strong>Go Standard Library(Go 标准库)&lt;/strong> 是 Go 内置 &lt;strong>Package(包)&lt;/strong> 的集合，每个 package 都可以实现一类功能。每个 package 里有他们对应的常量、变量、函数、方法等。每个库就是一类功能，比如 bufio 库，这里面就是关于实现读写功能的各种内容；而 fmt 库则是关于实现格式化输入输出等功能。在&lt;a href="https://pkg.go.dev/std?tab=packages">这里&lt;/a>可以看到 go 语言 原生支持的所有标准库。&lt;/p>
&lt;p>与 标准库 相对应的就是 &lt;a href="https://www.teambition.com/project/5f90e312755d8a00446050eb/app/5eba5fba6a92214d420a3219/workspaces/5f90e312c800160016ea22fb/folders/5f9d3b0f4cc5830001c21a7c">第三方库&lt;/a> ，第三方库一般属于由个人开发，实现更多丰富功能的库。在 &lt;a href="https://pkg.go.dev/">Go.dev &lt;/a>可以搜索自己想要使用的所有库。&lt;/p>
&lt;p>&lt;a href="https://pkg.go.dev/">Go.dev&lt;/a> 是 golang.org 的配套网站。 Golang.org 是开源项目和发行版的所在地，而 go.dev 是 Go 用户的中心，可从整个 Go 生态系统中提供集中和精选的资源。还可以在专门的&lt;a href="https://pkg.go.dev/std">标准库&lt;/a>页面看到所有标准库下的 Go 内置包。&lt;/p>
&lt;p>Go.dev 提供：&lt;/p>
&lt;ul>
&lt;li>在 index.golang.org 上发布的 Go 软件包和模块的集中信息。&lt;/li>
&lt;li>基本学习资源&lt;/li>
&lt;li>关键用例和案例研究&lt;/li>
&lt;/ul>
&lt;p>Go.dev 当前处于 MVP 状态。我们为自己的建设感到自豪，并很高兴与社区分享。我们希望您能在使用 go.dev 的过程中找到价值和乐趣。 Go.dev 只有一小部分我们打算构建的功能，我们正在积极寻求反馈。如果您有任何想法，建议或问题，请告诉我们.&lt;/p></description></item><item><title>Docs: Grafana</title><link>https://desistdaydream.github.io/docs/6.%E5%8F%AF%E8%A7%82%E6%B5%8B%E6%80%A7/Grafana/Grafana/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/6.%E5%8F%AF%E8%A7%82%E6%B5%8B%E6%80%A7/Grafana/Grafana/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://grafana.com/">官网&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://github.com/grafana/grafana">GitHub 项目，grafana/grafana&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>Grafana 是开源的可视化和分析软件。它使我们可以查询，可视化，警报和浏览指标，无论它们存储在哪里。用简单的英语，它为您提供了将时间序列数据库（TSDB）数据转换为精美的图形和可视化效果的工具。&lt;/p>
&lt;h1 id="grafana-部署">Grafana 部署&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://grafana.com/docs/grafana/latest/setup-grafana/installation/">官方文档，安装-安装 Grafana&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;h2 id="docker-方式运行-grafana">docker 方式运行 grafana&lt;/h2>
&lt;p>获取配置文件&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>mkdir -p /opt/monitoring/server/config/grafana
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>mkdir -p /opt/monitoring/server/data/grafana
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>chown -R &lt;span style="color:#ae81ff">472&lt;/span> /opt/monitoring/server/data/grafana
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>docker run -d --name grafana --rm grafana/grafana
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>docker cp grafana:/etc/grafana /opt/monitoring/server/config
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>docker stop grafana
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>运行 Grafana&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>docker run -d --name grafana &lt;span style="color:#ae81ff">\
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">&lt;/span> --network host &lt;span style="color:#ae81ff">\
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">&lt;/span> -v /opt/monitoring/server/config/grafana:/etc/grafana &lt;span style="color:#ae81ff">\
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">&lt;/span> -v /opt/monitoring/server/data/grafana:/var/lib/grafana &lt;span style="color:#ae81ff">\
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">&lt;/span> -v /etc/localtime:/etc/localtime &lt;span style="color:#ae81ff">\
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">&lt;/span> grafana/grafana
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h1 id="grafana-关联文件与配置">Grafana 关联文件与配置&lt;/h1>
&lt;p>&lt;strong>/etc/grafana/&lt;/strong> # grafana 配置文件保存路径&lt;/p>
&lt;ul>
&lt;li>&lt;strong>./grafana.ini&lt;/strong> # grafana 运行所需配置文件&lt;/li>
&lt;li>&lt;strong>./provisioning/&lt;/strong> # Grafana 的 Provisioning 功能要读取的路径。该功能详见 &lt;a href="https://desistdaydream.github.io/docs/6.%E5%8F%AF%E8%A7%82%E6%B5%8B%E6%80%A7/Grafana/Grafana%20%E9%85%8D%E7%BD%AE%E8%AF%A6%E8%A7%A3/Provisioning%20%E9%85%8D%E7%BD%AE.md">Provisioning 配置&lt;/a>
&lt;ul>
&lt;li>&lt;strong>./dashboards/*.yaml&lt;/strong> # Grafana 启动时，会根据该路径下配置文件内的 .providers.options.path 字段的路径配置，去对应路径加载 grafana 的 dashboard 的 json 文件。&lt;/li>
&lt;li>&lt;strong>./datasources/*.yaml&lt;/strong> # Grafana 启动时，会根据该路径下配置文件，自动加载数据源信息。&lt;/li>
&lt;li>&lt;strong>./notifiers/*.yaml&lt;/strong> # Grafana 启动时，加载的告警配置文件。&lt;/li>
&lt;li>&lt;strong>./plugins/*.yaml&lt;/strong> # Grafana 启动时，加载的插件的配置文件。用来管理 Grafana 插件&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>/var/lib/grafana/&lt;/strong> # grafana 数据保存路径&lt;/p>
&lt;ul>
&lt;li>&lt;strong>./grafana.db&lt;/strong> # grafana 数据文件，包括 用户信息、dashboard、datasource 等等。这是一个 SQLite3 数据库文件。&lt;/li>
&lt;li>&lt;strong>./plugins/&lt;/strong> # grafana 安装的插件保存在该目录下&lt;/li>
&lt;/ul></description></item><item><title>Docs: Grafana 配置详解</title><link>https://desistdaydream.github.io/docs/6.%E5%8F%AF%E8%A7%82%E6%B5%8B%E6%80%A7/Grafana/Grafana-%E9%85%8D%E7%BD%AE%E8%AF%A6%E8%A7%A3/Grafana-%E9%85%8D%E7%BD%AE%E8%AF%A6%E8%A7%A3/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/6.%E5%8F%AF%E8%A7%82%E6%B5%8B%E6%80%A7/Grafana/Grafana-%E9%85%8D%E7%BD%AE%E8%AF%A6%E8%A7%A3/Grafana-%E9%85%8D%E7%BD%AE%E8%AF%A6%E8%A7%A3/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://grafana.com/docs/grafana/latest/administration/configuration/">官方文档，管理-配置&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>Grafna 可以通过 ini 格式的配置文件、命令行标志、环境变量来配置运行时行为。&lt;/p>
&lt;p>环境变量 与 配置文件 中的配置具有一一对应的关系。环境变量可以覆盖配置文件中的配置(即.环境变量的优先级更高，如果有相通配置，以环境变量的配置为主)。&lt;/p>
&lt;p>环境变量格式：&lt;code>GF_&amp;lt;SectionName&amp;gt;_&amp;lt;KeyName&amp;gt;&lt;/code>&lt;/p>
&lt;ul>
&lt;li>SectionName 对应配置文件中 &lt;code>[ ]&lt;/code> 中的内容&lt;/li>
&lt;li>KeyName 对应配置文件中的关键字。&lt;/li>
&lt;li>配置文件中的 &lt;code>.&lt;/code> 和 &lt;code>-&lt;/code> 两个符号，到环境变量中则变为 &lt;code>_&lt;/code> 符号。环境变量的文本全是大写的&lt;/li>
&lt;/ul>
&lt;p>假如现在的配置文件内容如下：&lt;/p>
&lt;pre tabindex="0">&lt;code class="language-git" data-lang="git"># default section
instance_name = ${HOSTNAME}
[security]
admin_user = admin
[auth.google]
client_secret = 0ldS3cretKey
[plugin.grafana-image-renderer]
rendering_ignore_https_errors = true
&lt;/code>&lt;/pre>&lt;p>对应环境变量，则是：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>GF_DEFAULT_INSTANCE_NAME&lt;span style="color:#f92672">=&lt;/span>my-instance
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>GF_SECURITY_ADMIN_USER&lt;span style="color:#f92672">=&lt;/span>owner
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>GF_AUTH_GOOGLE_CLIENT_SECRET&lt;span style="color:#f92672">=&lt;/span>newS3cretKey
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>GF_PLUGIN_GRAFANA_IMAGE_RENDERER_RENDERING_IGNORE_HTTPS_ERRORS&lt;span style="color:#f92672">=&lt;/span>true
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>可以看到，Grafana 的配置具有层次感，配置文件中 &lt;code>[ ]&lt;/code> 表示一套配置环境，配置环境下方，有具体的配置关键字。&lt;/p>
&lt;h2 id="备注">备注&lt;/h2>
&lt;p>Grafana 容器镜像会默认配置一些环境变量，以指定一些基本的配置路径。&lt;a href="https://grafana.com/docs/grafana/latest/administration/configure-docker/">此处&lt;/a>是官方对镜像的解释&lt;/p>
&lt;h1 id="grafanaini-配置文件详解">grafana.ini 配置文件详解&lt;/h1>
&lt;blockquote>
&lt;p>Grafana 的配置文件开头 &lt;code>;&lt;/code> 表示注释&lt;/p>
&lt;/blockquote>
&lt;h2 id="paths">[paths]&lt;/h2>
&lt;p>&lt;strong>data = &amp;lt;STRING&amp;gt;&lt;/strong> # Grafana 数据存储路径。&lt;code>默认值：/var/lib/grafana/data&lt;/code>
&lt;strong>logs = &amp;lt;STRING&amp;gt;&lt;/strong> # Grafana 日志模式为 file 时，记录日志的路径。&lt;code>默认值：/var/log/grafana&lt;/code>
&lt;strong>plugins = &amp;lt;STRING&amp;gt;&lt;/strong> # Grafana 插件的安装路径。&lt;code>默认值：/var/lib/grafana/plugins&lt;/code>
&lt;strong>provisioning = &amp;lt;STRING&amp;gt;&lt;/strong> # Grafana 的 provisioning 功能加载配置文件的路径。&lt;code>默认值：/etc/grafana/provisioning&lt;/code>&lt;/p>
&lt;h2 id="server">[server]&lt;/h2>
&lt;p>&lt;strong>http_port = &amp;lt;INT&amp;gt;&lt;/strong> # Grafana 监听的端口。&lt;code>默认值：3000&lt;/code>。
**root_url = &amp;lt;STRING&amp;gt; **# 通过 Web 浏览器访问 Grafana 的完整 URL。&lt;code>默认值：%(protocol)://%(domain)s:%(http_port)s/&lt;/code>&lt;/p>
&lt;ul>
&lt;li>%(protocol)、%(domain)、%(http_port) 对应配置文件中 [server] 部分的 protocol、domain、http_port 字段&lt;/li>
&lt;li>root_url 常用于重定向和发送电子邮件时填写 URL&lt;/li>
&lt;/ul>
&lt;h2 id="security">[security]&lt;/h2>
&lt;p>&lt;strong>admin_user = &amp;lt;STRING&amp;gt;&lt;/strong> # Grafana Web UI 的管理员账号的用户命。默认值：admin
&lt;strong>admin_password = &amp;lt;STRING&amp;gt;&lt;/strong> # Grafana Web UI 的管理员账号的密码。默认值：admin&lt;/p>
&lt;h2 id="auth">[auth]&lt;/h2>
&lt;h2 id="authanonymous">[auth.anonymous]&lt;/h2>
&lt;p>匿名访问的配置，配置匿名访问，可以使无需任何登录操作即可访问 Grafana
&lt;strong>enabled = &amp;lt;BOOL&amp;gt;&lt;/strong> # 是否开启匿名访问，开启后，可以匿名访问指定的 Organization(组织) 的仪表盘。&lt;code>默认值：false&lt;/code>。
**org_name = &amp;lt;STRING&amp;gt; **# 匿名用户可以访问的组织名称。&lt;code>默认值：Main Org.&lt;/code>。
&lt;strong>org_role = &amp;lt;STRING&amp;gt;&lt;/strong> # 通过匿名访问的组织应该具有的权限。&lt;code>默认值：Viewer&lt;/code>。&lt;/p>
&lt;ul>
&lt;li>可用的值有 Editor 和 Admin。&lt;/li>
&lt;/ul>
&lt;h2 id="log">[log]&lt;/h2>
&lt;p>Grafana 日志配置
&lt;strong>mode = &amp;lt;console | file | syslog&amp;gt;&lt;/strong> # Grafana 记录日志的模式，多种模式以空格分隔。&lt;code>默认值： console file&lt;/code>
&lt;strong>level = &amp;lt;debug | info | warn | error | critical&amp;gt;&lt;/strong> # 日志级别。&lt;code>默认值：info&lt;/code>&lt;/p>
&lt;h2 id="smtp">[smtp]&lt;/h2>
&lt;p>&lt;a href="https://grafana.com/docs/grafana/latest/administration/configuration/#smtp">https://grafana.com/docs/grafana/latest/administration/configuration/#smtp&lt;/a>&lt;/p>
&lt;p>Grafana 的 Email 服务端配置。通过 smtp 部分的配置，Grafana 可以通过邮件 发送告警、重置密码 等。&lt;/p>
&lt;p>注意，当我们使用邮箱重置密码时，会发现 Grafana 发送的重置连接的域名是 &lt;code>http://localhost:3000&lt;/code>&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/shgqef/1639992484686-2a5d4b08-6d1e-412c-a557-a82ade2ea984.png" alt="image.png">&lt;/p>
&lt;p>这个域名是从过配置文件中 &lt;code>[server]&lt;/code> 部分的 &lt;code>root_rul&lt;/code> 字段获取的。&lt;/p>
&lt;h3 id="配置示例">配置示例&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-yaml" data-lang="yaml">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">smtp&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">enabled&lt;/span>: &lt;span style="color:#66d9ef">true&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">host&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;smtp.263.net:25&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">user&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;lich_wb@ehualu.com&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">password&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;邮箱密码&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">from_address&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;lich_wb@ehualu.com&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">from_name&lt;/span>: &lt;span style="color:#ae81ff">Grafana&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-nginx" data-lang="nginx">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">[smtp]&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">enabled&lt;/span> = &lt;span style="color:#e6db74">true&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">from_address&lt;/span> = &lt;span style="color:#e6db74">lich_wb@ehualu.com&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">from_name&lt;/span> = &lt;span style="color:#e6db74">Grafana&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">host&lt;/span> = smtp.263.net:&lt;span style="color:#ae81ff">25&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">password&lt;/span> = &lt;span style="color:#e6db74">邮箱密码&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">user&lt;/span> = &lt;span style="color:#e6db74">lich_wb@ehualu.com&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h1 id="grafanaini-配置示例">grafana.ini 配置示例&lt;/h1>
&lt;pre tabindex="0">&lt;code class="language-git" data-lang="git">[server]
http_port = 3000
[analytics]
check_for_updates = true
[log]
mode = console
level = info
[paths]
data = /var/lib/grafana/data
logs = /var/log/grafana
plugins = /var/lib/grafana/plugins
provisioning = /etc/grafana/provisioning
&lt;/code>&lt;/pre></description></item><item><title>Docs: Hugo</title><link>https://desistdaydream.github.io/docs/%E5%AE%9E%E7%94%A8%E5%B7%A5%E5%85%B7/%E7%BD%91%E7%AB%99%E6%90%AD%E5%BB%BA/Hugo/Hugo/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/%E5%AE%9E%E7%94%A8%E5%B7%A5%E5%85%B7/%E7%BD%91%E7%AB%99%E6%90%AD%E5%BB%BA/Hugo/Hugo/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://github.com/gohugoio/hugo">GitHub 项目，gohugoio/hugo&lt;/a>
&lt;ul>
&lt;li>&lt;a href="https://github.com/coderzh/gohugo.org">GitHub 项目，coderzh/gohugo.org&lt;/a>（一个从19年停更的 Hugo 中文网）&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;a href="https://gohugo.io/">官网&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Hugo_(software)">Wiki,Hugo(软件)&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>Hugo 是用 Go 语言编写的静态站点生成器。Steve Francia 最初于 2013 年将 Hugo 创建为开源项目。&lt;/p>
&lt;h1 id="hugo-的基本使用">Hugo 的基本使用&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://hugo.aiaide.com/post/%E8%87%AA%E5%AE%9A%E4%B9%89hugo%E4%B8%BB%E9%A2%98-%E4%BB%8E%E5%86%85%E5%AE%B9%E9%A1%B5%E5%BC%80%E5%A7%8B/">自定义hugo主题&amp;ndash;从内容开始&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>&lt;code>hugo new site hello_world&lt;/code> 命令将会创建一个包含以下元素的目录结构，这些目录的作用可以在&lt;a href="#%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84">下文&lt;/a>找到：&lt;/p>
&lt;pre tabindex="0">&lt;code>hello_world/
├── archetypes/
│ └── default.md
├── assets/
├── content/
├── data/
├── layouts/
├── public/
├── static/
├── themes/
└── config.toml
&lt;/code>&lt;/pre>&lt;p>进入到这个目录之后，执行 &lt;code>hugo server&lt;/code> 将会启动一个 HTTP 服务端&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>~&lt;span style="color:#f92672">]&lt;/span>&lt;span style="color:#75715e"># hugo server --buildDrafts&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Start building sites …
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>hugo v0.109.0-47b12b83e636224e5e601813ff3e6790c191e371+extended windows/amd64 BuildDate&lt;span style="color:#f92672">=&lt;/span>2022-12-23T10:38:11Z VendorInfo&lt;span style="color:#f92672">=&lt;/span>gohugoio
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>WARN 2023/01/22 16:15:45 found no layout file &lt;span style="color:#66d9ef">for&lt;/span> &lt;span style="color:#e6db74">&amp;#34;HTML&amp;#34;&lt;/span> &lt;span style="color:#66d9ef">for&lt;/span> kind &lt;span style="color:#e6db74">&amp;#34;home&amp;#34;&lt;/span>: You should create a template file which matches Hugo Layouts Lookup Rules &lt;span style="color:#66d9ef">for&lt;/span> this combination.
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>WARN 2023/01/22 16:15:45 found no layout file &lt;span style="color:#66d9ef">for&lt;/span> &lt;span style="color:#e6db74">&amp;#34;HTML&amp;#34;&lt;/span> &lt;span style="color:#66d9ef">for&lt;/span> kind &lt;span style="color:#e6db74">&amp;#34;taxonomy&amp;#34;&lt;/span>: You should create a template file which matches Hugo Layouts Lookup Rules &lt;span style="color:#66d9ef">for&lt;/span> this combination.
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>WARN 2023/01/22 16:15:45 found no layout file &lt;span style="color:#66d9ef">for&lt;/span> &lt;span style="color:#e6db74">&amp;#34;HTML&amp;#34;&lt;/span> &lt;span style="color:#66d9ef">for&lt;/span> kind &lt;span style="color:#e6db74">&amp;#34;taxonomy&amp;#34;&lt;/span>: You should create a template file which matches Hugo Layouts Lookup Rules &lt;span style="color:#66d9ef">for&lt;/span> this combination.
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> | EN
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>-------------------+-----
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Pages | &lt;span style="color:#ae81ff">3&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Paginator pages | &lt;span style="color:#ae81ff">0&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Non-page files | &lt;span style="color:#ae81ff">0&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Static files | &lt;span style="color:#ae81ff">0&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Processed images | &lt;span style="color:#ae81ff">0&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Aliases | &lt;span style="color:#ae81ff">0&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Sitemaps | &lt;span style="color:#ae81ff">1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Cleaned | &lt;span style="color:#ae81ff">0&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Built in &lt;span style="color:#ae81ff">44&lt;/span> ms
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Watching &lt;span style="color:#66d9ef">for&lt;/span> changes in D:&lt;span style="color:#ae81ff">\P&lt;/span>rojects&lt;span style="color:#ae81ff">\D&lt;/span>esistDaydream&lt;span style="color:#ae81ff">\h&lt;/span>ugo-learning&lt;span style="color:#ae81ff">\h&lt;/span>ello_world&lt;span style="color:#ae81ff">\{&lt;/span>archetypes,assets,content,data,layouts,static&lt;span style="color:#f92672">}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Watching &lt;span style="color:#66d9ef">for&lt;/span> config changes in D:&lt;span style="color:#ae81ff">\P&lt;/span>rojects&lt;span style="color:#ae81ff">\D&lt;/span>esistDaydream&lt;span style="color:#ae81ff">\h&lt;/span>ugo-learning&lt;span style="color:#ae81ff">\h&lt;/span>ello_world&lt;span style="color:#ae81ff">\c&lt;/span>onfig.toml
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Environment: &lt;span style="color:#e6db74">&amp;#34;development&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Serving pages from memory
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Running in Fast Render Mode. For full rebuilds on change: hugo server --disableFastRender
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Web Server is available at http://localhost:1313/ &lt;span style="color:#f92672">(&lt;/span>bind address 127.0.0.1&lt;span style="color:#f92672">)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Press Ctrl+C to stop
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>我们可以通过浏览器，访问默认的 1313 端口浏览我们的网站，但是此时我们只能看到一个 Hugo 默认的 &lt;code>Page Not Found&lt;/code>，因为我们还没有为网站设置、添加任何内容。&lt;/p>
&lt;p>Hugo 从 &lt;code>content/&lt;/code> 目录中渲染内容到页面，我们使用 &lt;code>hugo new posts/my-first-post.md&lt;/code> 命令将会创建 &lt;code>content/posts/my-first-post.md&lt;/code> 文件，我们可以自行在该文件中添加 markdown 格式的内容。&lt;/p>
&lt;p>但是我们依然无法看到任何东西，因为 Hugo 提供了非常大的自由度，并不会限制 HTML 的样式，所以我们需要先自己创建一个 HTML 页面(就像写前端一样)。&lt;/p>
&lt;p>在 layouts/ 目录下新建 _default 目录，并创建一个名为 single.html 文件，写下如下内容：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-html" data-lang="html">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&amp;lt;!DOCTYPE html&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&amp;lt;&lt;span style="color:#f92672">html&lt;/span> &lt;span style="color:#a6e22e">lang&lt;/span>&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;zh&amp;#34;&lt;/span>&amp;gt;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&amp;lt;&lt;span style="color:#f92672">head&lt;/span>&amp;gt;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>    &amp;lt;&lt;span style="color:#f92672">meta&lt;/span> &lt;span style="color:#a6e22e">charset&lt;/span>&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;UTF-8&amp;#34;&lt;/span>&amp;gt;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>    &amp;lt;&lt;span style="color:#f92672">meta&lt;/span> &lt;span style="color:#a6e22e">name&lt;/span>&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;viewport&amp;#34;&lt;/span> &lt;span style="color:#a6e22e">content&lt;/span>&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;width=device-width, initial-scale=1.0&amp;#34;&lt;/span>&amp;gt;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>    &amp;lt;&lt;span style="color:#f92672">meta&lt;/span> &lt;span style="color:#a6e22e">http-equiv&lt;/span>&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;X-UA-Compatible&amp;#34;&lt;/span> &lt;span style="color:#a6e22e">content&lt;/span>&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;ie=edge&amp;#34;&lt;/span>&amp;gt;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>    &amp;lt;&lt;span style="color:#f92672">title&lt;/span>&amp;gt;{{.Title}}&amp;lt;/&lt;span style="color:#f92672">title&lt;/span>&amp;gt;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&amp;lt;/&lt;span style="color:#f92672">head&lt;/span>&amp;gt;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&amp;lt;&lt;span style="color:#f92672">body&lt;/span>&amp;gt;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>    &amp;lt;&lt;span style="color:#f92672">div&lt;/span> &lt;span style="color:#a6e22e">id&lt;/span>&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;post&amp;#34;&lt;/span> &lt;span style="color:#a6e22e">class&lt;/span>&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;post&amp;#34;&lt;/span>&amp;gt;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>        &amp;lt;&lt;span style="color:#f92672">article&lt;/span>&amp;gt;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>            &amp;lt;&lt;span style="color:#f92672">header&lt;/span>&amp;gt;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>                &amp;lt;&lt;span style="color:#f92672">h1&lt;/span> &lt;span style="color:#a6e22e">class&lt;/span>&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;post-title&amp;#34;&lt;/span>&amp;gt;{{ .Title }}&amp;lt;/&lt;span style="color:#f92672">h1&lt;/span>&amp;gt;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>            &amp;lt;/&lt;span style="color:#f92672">header&lt;/span>&amp;gt;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>            {{.Content}}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>        &amp;lt;/&lt;span style="color:#f92672">article&lt;/span>&amp;gt;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>    &amp;lt;/&lt;span style="color:#f92672">div&lt;/span>&amp;gt;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&amp;lt;/&lt;span style="color:#f92672">body&lt;/span>&amp;gt;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&amp;lt;/&lt;span style="color:#f92672">html&lt;/span>&amp;gt;
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>此时我们直接访问 &lt;code>http://localhost:1313/posts/my-first-post/&lt;/code> 即可看到我们刚才添加的 markdown 的内容。只不过没有任何样式，光秃秃的~&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/hugo/20230122175219.png" alt="image.png">&lt;/p>
&lt;h2 id="使用主题">使用主题&lt;/h2>
&lt;p>我们自己编写 HTML 是非常复杂的，咱是要内容管理。。又不是写前端页面~~~o(╯□╰)o&lt;/p>
&lt;p>Hugo 贴心得提供了主题功能，可以让我们专注于内容的产出，在 Hugo 官方的主题页面中，我们可以挑选我们喜欢的主题并放在 themes/ 目录下，以便使用时供 Hugo 加载&lt;/p>
&lt;blockquote>
&lt;p>除了将主题放在 themes/ 目录下，还可以使用 Hugo 模块功能，将主题当做 Go 模块一样的东西，统一管理。这样在我们创建多个 Hugo 站点并使用同一个主题时，不用重复下载了。&lt;/p>
&lt;/blockquote>
&lt;p>我们使用官方示例中的基本主题：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>git submodule add https://github.com/theNewDynamic/gohugo-theme-ananke themes/ananke
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>echo &lt;span style="color:#e6db74">&amp;#34;theme = &amp;#39;ananke&amp;#39;&amp;#34;&lt;/span> &amp;gt;&amp;gt; config.toml
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>主题将会被下载到 thems/ 目录中，并且我们在 config.toml 文件中指定要使用的主题名称。&lt;/p>
&lt;p>此时再打开 1313 端口，我们就可以看到我们的站点了，第一篇文章以标题和概要的形式被展现在首页中。&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/hugo/20230122164828.png" alt="image.png">&lt;/p>
&lt;h3 id="通过-hugo-模块使用主题">通过 Hugo 模块使用主题&lt;/h3>
&lt;p>想要使用 Hugo 模块，我们需要 Go 环境&lt;/p>
&lt;p>执行如下命令&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>hugo mod init github.com/DesistDaydream/hugo-learning/hello_world
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>hugo mod get github.com/theNewDynamic/gohugo-theme-ananke
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>此时主题将会被下载到 &lt;code>%TMP%/hugo_cache/modules/filecache/modules/pkg/mod/github.com&lt;/code> 目录下，然后我们可以删掉项目目录中 themes/ 目录下的主题文件了~o(∩_∩)o&lt;/p>
&lt;p>修改 config.toml 文件&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-toml" data-lang="toml">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">theme&lt;/span> = [&lt;span style="color:#e6db74">&amp;#34;github.com/theNewDynamic/gohugo-theme-ananke&amp;#34;&lt;/span>]
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="发布我们的网站">发布我们的网站&lt;/h2>
&lt;p>在基本示例中，我们只是在本地调试，如果想要将网站运行在服务器上，那么肯定需要像前端代码一样，将这些文件打包才可以。&lt;/p>
&lt;p>Hugo 打包非常简单，执行 &lt;code>hugo&lt;/code> 命令即可在 public/ 目录中生成我们网站的静态页面，将这个目录下的所有文件，统统放到 Nginx 中响应页面的目录，就可以访问我们自己的网站了~&lt;/p>
&lt;h3 id="最佳实践">最佳实践&lt;/h3>
&lt;p>很多时候，我们通过工作流（GitHub Action 等）将 &lt;code>public/&lt;/code> 目录下的文件转存到新项目中，并不会将原始内容与打包好的前端代码放在一起。&lt;/p>
&lt;h2 id="目录结构">目录结构&lt;/h2>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://gohugo.io/getting-started/directory-structure/">官方文档，入门-目录结构&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;h3 id="archetypes">archetypes&lt;/h3>
&lt;h3 id="assets">assets&lt;/h3>
&lt;p>存放所有需要由 Hugo Pipes 处理的文件。&lt;/p>
&lt;h3 id="config">config&lt;/h3>
&lt;blockquote>
&lt;p>注意：config 目录并不会随着 &lt;code>hugo new site example&lt;/code> 命令自动创建出来。而是在我们需要将单一配置文件拆分时，手动创建并使用的。&lt;/p>
&lt;/blockquote>
&lt;p>Hugo 附带了大量的配置指令。config 目录是将这些指令存储为 JSON、YAML 或 TOML 文件的地方。每个根设置对象都可以作为自己的文件并按环境构建。设置最少且不需要环境的项目可以在其根目录下使用单个 config.toml 文件。&lt;/p>
&lt;p>许多站点可能几乎不需要配置，但 Hugo 附带了大量 &lt;a href="https://gohugo.io/getting-started/configuration/#all-configuration-settings">configuration directives(配置指令)&lt;/a>，用于更详细地指导我们希望 Hugo 如何构建网站。注意：默认情况下不创建 config 目录。&lt;/p>
&lt;h3 id="content">content/&lt;/h3>
&lt;p>我们使用 Hugo 创建的网站的所有内容通常都要放在 content 目录中。content 目录下的每个顶级文件夹称为 &lt;a href="https://gohugo.io/content-management/sections/">content section(内容部分)&lt;/a>。&lt;/p>
&lt;p>比如，如果我的网站有三大块，分别是 blog、articles、tuorials，那么我们需要创建如下的目录结构&lt;/p>
&lt;pre tabindex="0">&lt;code>example/
├── content/
│ ├── blog/
│ ├── articles/
│ └── tuorials/
&lt;/code>&lt;/pre>&lt;p>Hugo 使用 section 的名称作为默认的 &lt;a href="https://gohugo.io/content-management/types/">content types(内容类型)&lt;/a>。假如有这么一个文件 content/blog/my-first-event.md，则这篇文章的内容类型就是 blog 类型。&lt;/p>
&lt;p>通过这种对网站内容的分类方式，更利于搜索、整理等。&lt;/p>
&lt;h3 id="data">data/&lt;/h3>
&lt;p>该目录用于存放 Hugo 在生成我的网站时可以使用的配置文件。可以用 YAML、JSON 或 TOML 格式编写这些文件。除了添加到此文件夹的文件外，还可以创建从动态内容中提取的数据模板。&lt;/p>
&lt;h3 id="layouts">layouts/&lt;/h3>
&lt;p>以 &lt;code>.html&lt;/code> 文件的形式存储模板，这些文件指定如何将您的内容视图呈现到静态网站中。模板包括 &lt;a href="https://gohugo.io/templates/list/">list pages&lt;/a>, your &lt;a href="https://gohugo.io/templates/homepage/">homepage&lt;/a>, &lt;a href="https://gohugo.io/templates/taxonomy-templates/">taxonomy templates&lt;/a>, &lt;a href="https://gohugo.io/templates/partials/">partials&lt;/a>, &lt;a href="https://gohugo.io/templates/single-page-templates/">single page templates&lt;/a>,等&lt;/p>
&lt;p>如果我们不使用主题，则 Hugo 会从 &lt;code>layouts&lt;/code> 目录中读取前端代码并渲染页面。&lt;/p>
&lt;h3 id="public">public/&lt;/h3>
&lt;p>使用 &lt;code>hugo&lt;/code> 命令生成网站的静态文件后，将会保存到 public 目录。public 目录生成的静态文件，可以直接通过 web 服务访问到。&lt;/p>
&lt;h3 id="static">static/&lt;/h3>
&lt;p>存储所有静态内容：图像、CSS、JavaScript 等。当 Hugo 构建您的站点时，静态目录中的所有资产都会按原样复制。使用静态文件夹的一个很好的例子是在 Google Search Console 上验证网站所有权，您希望 Hugo 在不修改其内容的情况下复制完整的 HTML 文件。&lt;/p>
&lt;h3 id="themes">themes/&lt;/h3>
&lt;blockquote>
&lt;p>更推荐的是使用 Hugo 模块使用主题，该目录不推荐使用。&lt;/p>
&lt;/blockquote>
&lt;p>Hugo 主题可以安装到该目录，使用 &lt;code>hugo server --themes&lt;/code> 指定使用的主题时，将会从该目录出寻找。&lt;/p>
&lt;h3 id="configtoml">config.toml&lt;/h3>
&lt;p>Hugo 运行站点时所使用的配置文件。&lt;/p>
&lt;p>推荐使用 config/ 目录，以便拆分 config.toml 文件。可以将 config.tom 文件移动到在 config/_default/config.toml 处作为默认配置。&lt;/p>
&lt;h1 id="hugo-modules模块">Hugo Modules(模块)&lt;/h1>
&lt;p>Hugo 模块是一个类似 Go 模块一样的存在。模块可以是我们的主项目或其他较小的模块，提供 Hugo 的 7 种组件类型中的一种或多种：&lt;/p>
&lt;ul>
&lt;li>&lt;strong>static&lt;/strong>&lt;/li>
&lt;li>&lt;strong>content&lt;/strong>&lt;/li>
&lt;li>&lt;strong>layouts&lt;/strong>&lt;/li>
&lt;li>&lt;strong>data&lt;/strong>&lt;/li>
&lt;li>&lt;strong>assets&lt;/strong>&lt;/li>
&lt;li>&lt;strong>i18n&lt;/strong>&lt;/li>
&lt;li>&lt;strong>archetypes&lt;/strong>&lt;/li>
&lt;/ul>
&lt;p>在 config.toml 文件中的 module 字段添加配置，即可为站点设置引用的模块，我们可以将主题当做一个模块。&lt;/p>
&lt;p>&lt;strong>注意：Hugo 模块与 Go 模块一样，也需要一个代理服务器，我们只需要在 module 部分配置 proxy 指令，值与 go proxy 一样即可&lt;/strong>&lt;/p>
&lt;h1 id="安装-hugo">安装 Hugo&lt;/h1>
&lt;p>安装 &lt;code>hogo&lt;/code> 命令行工具，即可开始使用 Hugo。推荐下载扩展版 hugo，即名字带有 extended 的文件。&lt;/p>
&lt;p>从 &lt;a href="https://github.com/gohugoio/hugo/releases">release&lt;/a> 页面下载带 &lt;strong>extended&lt;/strong> 后缀的文件。&lt;/p>
&lt;h1 id="关联文件与配置">关联文件与配置&lt;/h1>
&lt;p>&lt;strong>hugo.toml | hugo.yaml | hugo.json&lt;/strong> # 站点的配置文件，通常在站点的根目录。在 0.110.0 版本之前，默认的文件名是 config.toml 之类的。&lt;/p>
&lt;p>&lt;strong>${Site_Root_dir}/config&lt;/strong> # 可以将站点根目录下的 config.toml | config.yaml | config.json 拆分后保存到该目录。&lt;/p>
&lt;p>Hugo 运行时所需的缓存目录。包括需要使用的模块等：&lt;/p>
&lt;ul>
&lt;li>Windows:
&lt;ul>
&lt;li>&lt;strong>%TMP%/hugo_cache/&lt;/strong>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Linux:
&lt;ul>
&lt;li>&lt;strong>${TMP}/hugo_cache/&lt;/strong>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h1 id="hugo-与-obsidian">Hugo 与 Obsidian&lt;/h1>
&lt;h2 id="url-与-markdown-链接问题">URL 与 markdown 链接问题&lt;/h2>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://cloud.tencent.com/developer/article/1688894">https://cloud.tencent.com/developer/article/1688894&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>Obsidian 内部链接是这种格式 &lt;code>[B cd](/A/b/B%20cd.md)&lt;/code>&lt;/p>
&lt;p>Hugo 生成的内容资源的 URL 是 &lt;a href="https://demo.org/a/b/b-cd">https://demo.org/a/b/b-cd&lt;/a>&lt;/p>
&lt;p>此时，如果我们从页面点击 B cd，将会跳转到 &lt;a href="https://demo.org/A/b/B-cd">https://demo.org/A/b/B-cd&lt;/a> 页面，此时将会看到 404。。。。&lt;/p>
&lt;p>解决方式：&lt;/p>
&lt;p>在 hugo.config 中添加 &lt;code>disablePathToLower = true&lt;/code> 配置，以关闭转换为小写的功能。&lt;/p>
&lt;p>在 layouts/404.html 中添加如下脚本：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-js" data-lang="js">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">&amp;lt;&lt;/span>&lt;span style="color:#a6e22e">script&lt;/span>&lt;span style="color:#f92672">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">var&lt;/span> &lt;span style="color:#a6e22e">currenturl&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#a6e22e">location&lt;/span>.&lt;span style="color:#a6e22e">href&lt;/span>.&lt;span style="color:#a6e22e">replace&lt;/span>(&lt;span style="color:#e6db74">/%20/g&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;-&amp;#34;&lt;/span>).&lt;span style="color:#a6e22e">replace&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;.md&amp;#34;&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (&lt;span style="color:#a6e22e">currenturl&lt;/span> &lt;span style="color:#f92672">!=&lt;/span> &lt;span style="color:#a6e22e">location&lt;/span>.&lt;span style="color:#a6e22e">href&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">location&lt;/span>.&lt;span style="color:#a6e22e">href&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#a6e22e">currenturl&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">&amp;lt;&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">/script&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>此时跳转到 404 时，将会去掉 &lt;code>.md&lt;/code> 后缀，以及将所有的 &lt;code>%20&lt;/code> 替换成 &lt;code>-&lt;/code>&lt;/p></description></item><item><title>Docs: Instrumenting</title><link>https://desistdaydream.github.io/docs/6.%E5%8F%AF%E8%A7%82%E6%B5%8B%E6%80%A7/%E7%9B%91%E6%8E%A7%E7%B3%BB%E7%BB%9F/Instrumenting/Instrumenting/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/6.%E5%8F%AF%E8%A7%82%E6%B5%8B%E6%80%A7/%E7%9B%91%E6%8E%A7%E7%B3%BB%E7%BB%9F/Instrumenting/Instrumenting/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://prometheus.io/docs/instrumenting/exporters/">官方文档,Instrumenting-Exporter&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://prometheus.io/docs/practices/instrumentation/">官方文档,最佳实践-Instrumentation&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>Prometheus 可以通过 3 种方式从目标上 Scrape(抓取) 指标：&lt;/p>
&lt;ol>
&lt;li>&lt;strong>Instrumentation(检测仪)&lt;/strong> # 内部代码。将 Prometheus 的 Client Libraries(客户端库) 添加到程序代码中，以此暴露一个 endpoint，Prometheus Server 可以通过该 Endpoiint 抓取到指标。
&lt;ol>
&lt;li>可以理解为内嵌的 Exporter，比如 Prometheus Server 的 9090 端口的 &lt;code>/metrics&lt;/code> 就属于此类。&lt;/li>
&lt;li>说白了，就是被监控目标自己就可以吐出符合 Prometheus 格式的指标数据&lt;/li>
&lt;/ol>
&lt;/li>
&lt;li>**Exporters **# 外部程序。&lt;/li>
&lt;li>&lt;strong>Pushgateway&lt;/strong> # 针对需要推送指标的应用&lt;/li>
&lt;/ol>
&lt;h1 id="instrumentation">Instrumentation&lt;/h1>
&lt;h1 id="exporter">Exporter&lt;/h1>
&lt;p>在&lt;a href="https://github.com/prometheus/prometheus/wiki/Default-port-allocations">这里&lt;/a>可以看到经过 Prometheus 官方注册的各类 Exporter 所默认使用的端口号。&lt;/p>
&lt;h1 id="push-gateway">Push Gateway&lt;/h1></description></item><item><title>Docs: Inter Process Communication(进程间通信)</title><link>https://desistdaydream.github.io/docs/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2.Kernel%E5%86%85%E6%A0%B8/7.Process-%E7%AE%A1%E7%90%86/Inter-Process-Communication%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1/Inter-Process-Communication%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2.Kernel%E5%86%85%E6%A0%B8/7.Process-%E7%AE%A1%E7%90%86/Inter-Process-Communication%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1/Inter-Process-Communication%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Inter-process_communication">Wiki,IPC&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Local_Inter-Process_Communication">Wiki,LPC&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://mp.weixin.qq.com/s/MnIcTR0KKpgnSoA3xaPUSA">公众号,小林 Coding-进程间通信&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>&lt;strong>Inter Process Communication(进程间通信，简称 IPC)&lt;/strong> 是一种允许多个进程共享数据的机制。IPC 的两个应用可以被分为客户端和服务端，客户端进程请求数据，服务端响应客户端的数据请求。有一些应用本身既是服务器又是客户端，这在分布式计算中，时常可以见到。这些进程可以运行在同一计算机上或网络连接的不同计算机上。&lt;/p>
&lt;p>IPC 对微内核和 nano 内核的设计过程非常重要。 微内核减少了内核提供的功能数量。 然后通过 IPC 与服务器通信获得这些功能，与普通的宏内核相比，IPC 的数量大幅增加。&lt;/p>
&lt;p>IPC 可以分为如下两类：&lt;/p>
&lt;ul>
&lt;li>&lt;strong>Local Procedure Call(本地过程调用，简称 LPC)&lt;/strong> #&lt;/li>
&lt;li>&lt;strong>Remote Procedure Call(远程过程调用，简称 RPC)&lt;/strong> #&lt;/li>
&lt;/ul>
&lt;p>IPC 可以通过多种方式实现：&lt;/p>
&lt;ul>
&lt;li>&lt;strong>file(文件)&lt;/strong> # 多个进程可以通过磁盘上的文件共享数据。&lt;/li>
&lt;li>&lt;strong>Signal(信号)&lt;/strong># 从一个进程发送到另一个进程的系统消息，通常不用于传输数据，而是用于远程命令伙伴进程。&lt;a href="https://www.yuque.com/go/doc/33222681">详见此处&lt;/a>&lt;/li>
&lt;li>&lt;strong>pipe(管道)&lt;/strong># 使用标准输入和输出的单向数据通道。写入管道的写入端的数据由操作系统进行缓冲，直到从管道的读取端读取数据为止。通过使用相反“方向”上的两个管道可以实现过程之间的双向通信。详见 &lt;a href="https://desistdaydream.github.io/docs/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/4.Terminal%20%E4%B8%8E%20Shell/Bash/exec,xargs,%E7%AE%A1%E9%81%93%E7%AC%A6%E7%AD%89%E7%BB%84%E5%90%88%E5%91%BD%E4%BB%A4.md">exec、xargs、管道等命令&lt;/a>&lt;/li>
&lt;li>&lt;strong>Socket(套接字)&lt;/strong> # 计算机领域中数据通信的一种约定，或者说是一种方法，《&lt;a href="https://desistdaydream.github.io/docs/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2.Kernel(%E5%86%85%E6%A0%B8)/7.Process%20%E7%AE%A1%E7%90%86/Inter%20Process%20Communication(%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1)/Socket(%E5%A5%97%E6%8E%A5%E5%AD%97)/Socket(%E5%A5%97%E6%8E%A5%E5%AD%97).md">Socket(套接字)&lt;/a>》。Socket 又分为两种
&lt;ul>
&lt;li>Unix Domain Socket&lt;/li>
&lt;li>Network Socket&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>Shared Memory(共享内存)&lt;/strong> #&lt;/li>
&lt;li>&lt;strong>Message Queue(消息队列)&lt;/strong> # 类似于 Socket 的数据流，但这通常保留了信息的边界。通常由操作系统实现，它们允许多个进程读写消息队列，而不需要彼此直接连接。&lt;/li>
&lt;li>&lt;strong>Mesage Passing(消息传递)&lt;/strong> # 允许多个程序使用消息队列和/或非 OS 托管通道进行通信。常用于并发模型。比如 LPC、RPC 等等。&lt;/li>
&lt;li>&lt;strong>等等&lt;/strong>&lt;/li>
&lt;/ul>
&lt;h1 id="ipc-实现方式概述">IPC 实现方式概述&lt;/h1>
&lt;p>每个进程的用户地址空间都是独立的，一般而言是不能互相访问的，但内核空间是每个进程都共享的，所以进程之间要通信必须通过内核。&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/iuxfg7/1619421762395-81aa05bc-0c16-4377-9584-9381c9433c63.png" alt="">&lt;/p>
&lt;p>Linux 内核提供了不少进程间通信的机制，我们来一起瞧瞧有哪些？&lt;/p>
&lt;h3 id="管道">管道&lt;/h3>
&lt;p>如果你学过 Linux 命令，那你肯定很熟悉 &lt;code>|&lt;/code> 这个竖线。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">ps&lt;/span>&lt;span style="color:#960050;background-color:#1e0010"> &lt;/span>&lt;span style="color:#a6e22e">auxf&lt;/span>&lt;span style="color:#960050;background-color:#1e0010"> &lt;/span>|&lt;span style="color:#960050;background-color:#1e0010"> &lt;/span>&lt;span style="color:#a6e22e">grep&lt;/span>&lt;span style="color:#960050;background-color:#1e0010"> &lt;/span>&lt;span style="color:#a6e22e">mysql&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>上面命令行里的 &lt;code>|&lt;/code> 竖线就是一个&lt;strong>管道&lt;/strong>，它的功能是将前一个命令 &lt;code>ps auxf&lt;/code> 的输出，作为后一个命令 &lt;code>grep mysql&lt;/code> 的输入，从这功能描述，可以看出&lt;strong>管道传输数据是单向的&lt;/strong>，如果想相互通信，我们需要创建两个管道才行。&lt;/p>
&lt;p>同时，我们得知上面这种管道是没有名字，所以 &lt;code>|&lt;/code> 表示的管道称为&lt;strong>匿名管道&lt;/strong>，用完了就销毁。&lt;/p>
&lt;p>管道还有另外一个类型是&lt;strong>命名管道&lt;/strong>，也被叫做 &lt;code>FIFO&lt;/code>，因为数据是先进先出的传输方式。&lt;/p>
&lt;p>在使用命名管道前，先需要通过 &lt;code>mkfifo&lt;/code> 命令来创建，并且指定管道名字：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">mkfifo&lt;/span>&lt;span style="color:#960050;background-color:#1e0010"> &lt;/span>&lt;span style="color:#a6e22e">myPipe&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>myPipe 就是这个管道的名称，基于 Linux 一切皆文件的理念，所以管道也是以文件的方式存在，我们可以用 ls 看一下，这个文件的类型是 p，也就是 pipe（管道） 的意思：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>$ ls
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>-lprw-r--r--. 1 root    root         0 Jul 17 02:45 myPipe
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>接下来，我们往 myPipe 这个管道写入数据：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>$ echo &lt;span style="color:#e6db74">&amp;#34;hello&amp;#34;&lt;/span> &amp;gt; myPipe  // 将数据写进管道
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> // 停住了 ...
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>你操作了后，你会发现命令执行后就停在这了，这是因为管道里的内容没有被读取，只有当管道里的数据被读完后，命令才可以正常退出。&lt;/p>
&lt;p>于是，我们执行另外一个命令来读取这个管道里的数据：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>cat &amp;lt; myPipe  // 读取管道里的数据hello
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>可以看到，管道里的内容被读取出来了，并打印在了终端上，另外一方面，echo 那个命令也正常退出了。&lt;/p>
&lt;p>我们可以看出，&lt;strong>管道这种通信方式效率低，不适合进程间频繁地交换数据&lt;/strong>。当然，它的好处，自然就是简单，同时也我们很容易得知管道里的数据已经被另一个进程读取了。&lt;/p>
&lt;blockquote>
&lt;p>那管道如何创建呢，背后原理是什么？&lt;/p>
&lt;/blockquote>
&lt;p>匿名管道的创建，需要通过下面这个系统调用：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>int pipe&lt;span style="color:#f92672">(&lt;/span>int fd&lt;span style="color:#f92672">[&lt;/span>2&lt;span style="color:#f92672">])&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>这里表示创建一个匿名管道，并返回了两个描述符，一个是管道的读取端描述符 &lt;code>fd[0]&lt;/code>，另一个是管道的写入端描述符 &lt;code>fd[1]&lt;/code>。注意，这个匿名管道是特殊的文件，只存在于内存，不存于文件系统中。
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/iuxfg7/1619421762470-c218e6b2-110b-454f-b314-057383247469.png" alt="">
其实，&lt;strong>所谓的管道，就是内核里面的一串缓存&lt;/strong>。从管道的一段写入的数据，实际上是缓存在内核中的，另一端读取，也就是从内核中读取这段数据。另外，管道传输的数据是无格式的流且大小受限。&lt;/p>
&lt;p>看到这，你可能会有疑问了，这两个描述符都是在一个进程里面，并没有起到进程间通信的作用，怎么样才能使得管道是跨过两个进程的呢？&lt;/p>
&lt;p>我们可以使用 &lt;code>fork&lt;/code> 创建子进程，&lt;strong>创建的子进程会复制父进程的文件描述符&lt;/strong>，这样就做到了两个进程各有两个「 &lt;code>fd[0]&lt;/code> 与 &lt;code>fd[1]&lt;/code>」，两个进程就可以通过各自的 fd 写入和读取同一个管道文件实现跨进程通信了。
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/iuxfg7/1619421762310-ab6819a4-d922-4393-9591-590864172c59.png" alt="">
管道只能一端写入，另一端读出，所以上面这种模式容易造成混乱，因为父进程和子进程都可以同时写入，也都可以读出。那么，为了避免这种情况，通常的做法是：&lt;/p>
&lt;ul>
&lt;li>父进程关闭读取的 fd[0]，只保留写入的 fd[1]；&lt;/li>
&lt;li>子进程关闭写入的 fd[1]，只保留读取的 fd[0]；&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/iuxfg7/1619421762492-d45b7c24-a90b-4fda-aea1-feb733f155bf.png" alt="">
所以说如果需要双向通信，则应该创建两个管道。&lt;/p>
&lt;p>到这里，我们仅仅解析了使用管道进行父进程与子进程之间的通信，但是在我们 shell 里面并不是这样的。&lt;/p>
&lt;p>在 shell 里面执行 &lt;code>A | B&lt;/code> 命令的时候，A 进程和 B 进程都是 shell 创建出来的子进程，A 和 B 之间不存在父子关系，它俩的父进程都是 shell。&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/iuxfg7/1619421762314-89d01b2d-6ffd-4cd8-9b56-6c6e9e6ffa03.png" alt="">&lt;/p>
&lt;p>所以说，在 shell 里通过「&lt;code>|&lt;/code>」匿名管道将多个命令连接在一起，实际上也就是创建了多个子进程，那么在我们编写 shell 脚本时，能使用一个管道搞定的事情，就不要多用一个管道，这样可以减少创建子进程的系统开销。&lt;/p>
&lt;p>我们可以得知，&lt;strong>对于匿名管道，它的通信范围是存在父子关系的进程&lt;/strong>。因为管道没有实体，也就是没有管道文件，只能通过 fork 来复制父进程 fd 文件描述符，来达到通信的目的。&lt;/p>
&lt;p>另外，&lt;strong>对于命名管道，它可以在不相关的进程间也能相互通信&lt;/strong>。因为命令管道，提前创建了一个类型为管道的设备文件，在进程里只要使用这个设备文件，就可以相互通信。&lt;/p>
&lt;p>不管是匿名管道还是命名管道，进程写入的数据都是缓存在内核中，另一个进程读取数据时候自然也是从内核中获取，同时通信数据都遵循&lt;strong>先进先出&lt;/strong>原则，不支持 lseek 之类的文件定位操作。&lt;/p>
&lt;h3 id="消息队列">消息队列&lt;/h3>
&lt;p>前面说到管道的通信方式是效率低的，因此管道不适合进程间频繁地交换数据。&lt;/p>
&lt;p>对于这个问题，&lt;strong>消息队列&lt;/strong>的通信模式就可以解决。比如，A 进程要给 B 进程发送消息，A 进程把数据放在对应的消息队列后就可以正常返回了，B 进程需要的时候再去读取数据就可以了。同理，B 进程要给 A 进程发送消息也是如此。&lt;/p>
&lt;p>再来，&lt;strong>消息队列是保存在内核中的消息链表&lt;/strong>，在发送数据时，会分成一个一个独立的数据单元，也就是消息体（数据块），消息体是用户自定义的数据类型，消息的发送方和接收方要约定好消息体的数据类型，所以每个消息体都是固定大小的存储块，不像管道是无格式的字节流数据。如果进程从消息队列中读取了消息体，内核就会把这个消息体删除。&lt;/p>
&lt;p>消息队列生命周期随内核，如果没有释放消息队列或者没有关闭操作系统，消息队列会一直存在，而前面提到的匿名管道的生命周期，是随进程的创建而建立，随进程的结束而销毁。&lt;/p>
&lt;p>消息这种模型，两个进程之间的通信就像平时发邮件一样，你来一封，我回一封，可以频繁沟通了。&lt;/p>
&lt;p>但邮件的通信方式存在不足的地方有两点，&lt;strong>一是通信不及时，二是附件也有大小限制&lt;/strong>，这同样也是消息队列通信不足的点。&lt;/p>
&lt;p>&lt;strong>消息队列不适合比较大数据的传输&lt;/strong>，因为在内核中每个消息体都有一个最大长度的限制，同时所有队列所包含的全部消息体的总长度也是有上限。在 Linux 内核中，会有两个宏定义 &lt;code>MSGMAX&lt;/code> 和 &lt;code>MSGMNB&lt;/code>，它们以字节为单位，分别定义了一条消息的最大长度和一个队列的最大长度。&lt;/p>
&lt;p>&lt;strong>消息队列通信过程中，存在用户态与内核态之间的数据拷贝开销&lt;/strong>，因为进程写入数据到内核中的消息队列时，会发生从用户态拷贝数据到内核态的过程，同理另一进程读取内核中的消息数据时，会发生从内核态拷贝数据到用户态的过程。&lt;/p>
&lt;h3 id="共享内存">共享内存&lt;/h3>
&lt;p>消息队列的读取和写入的过程，都会有发生用户态与内核态之间的消息拷贝过程。那&lt;strong>共享内存&lt;/strong>的方式，就很好的解决了这一问题。&lt;/p>
&lt;p>现代操作系统，对于内存管理，采用的是虚拟内存技术，也就是每个进程都有自己独立的虚拟内存空间，不同进程的虚拟内存映射到不同的物理内存中。所以，即使进程 A 和 进程 B 的虚拟地址是一样的，其实访问的是不同的物理内存地址，对于数据的增删查改互不影响。&lt;/p>
&lt;p>&lt;strong>共享内存的机制，就是拿出一块虚拟地址空间来，映射到相同的物理内存中&lt;/strong>。这样这个进程写入的东西，另外一个进程马上就能看到了，都不需要拷贝来拷贝去，传来传去，大大提高了进程间通信的速度。&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/iuxfg7/1619421762492-966784b1-cbd4-4545-bdae-300663d06a0b.png" alt="">&lt;/p>
&lt;h3 id="信号量">信号量&lt;/h3>
&lt;p>用了共享内存通信方式，带来新的问题，那就是如果多个进程同时修改同一个共享内存，很有可能就冲突了。例如两个进程都同时写一个地址，那先写的那个进程会发现内容被别人覆盖了。&lt;/p>
&lt;p>为了防止多进程竞争共享资源，而造成的数据错乱，所以需要保护机制，使得共享的资源，在任意时刻只能被一个进程访问。正好，&lt;strong>信号量&lt;/strong>就实现了这一保护机制。&lt;/p>
&lt;p>&lt;strong>信号量其实是一个整型的计数器，主要用于实现进程间的互斥与同步，而不是用于缓存进程间通信的数据&lt;/strong>。&lt;/p>
&lt;p>信号量表示资源的数量，控制信号量的方式有两种原子操作：&lt;/p>
&lt;ul>
&lt;li>一个是 &lt;strong>P 操作&lt;/strong>，这个操作会把信号量减去 -1，相减后如果信号量 &amp;lt;0，则表明资源已被占用，进程需阻塞等待；相减后如果信号量&amp;gt;= 0，则表明还有资源可使用，进程可正常继续执行。&lt;/li>
&lt;li>另一个是 &lt;strong>V 操作&lt;/strong>，这个操作会把信号量加上 1，相加后如果信号量 &amp;lt;= 0，则表明当前有阻塞中的进程，于是会将该进程唤醒运行；相加后如果信号量&amp;gt; 0，则表明当前没有阻塞中的进程；&lt;/li>
&lt;/ul>
&lt;p>P 操作是用在进入共享资源之前，V 操作是用在离开共享资源之后，这两个操作是必须成对出现的。&lt;/p>
&lt;p>接下来，举个例子，如果要使得两个进程互斥访问共享内存，我们可以初始化信号量为 &lt;code>1&lt;/code>。&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/iuxfg7/1619421762415-e1c7a414-1ecb-4d66-a920-881ebf3e3e85.png" alt="">&lt;/p>
&lt;p>具体的过程如下：&lt;/p>
&lt;ul>
&lt;li>进程 A 在访问共享内存前，先执行了 P 操作，由于信号量的初始值为 1，故在进程 A 执行 P 操作后信号量变为 0，表示共享资源可用，于是进程 A 就可以访问共享内存。&lt;/li>
&lt;li>若此时，进程 B 也想访问共享内存，执行了 P 操作，结果信号量变为了 -1，这就意味着临界资源已被占用，因此进程 B 被阻塞。&lt;/li>
&lt;li>直到进程 A 访问完共享内存，才会执行 V 操作，使得信号量恢复为 0，接着就会唤醒阻塞中的线程 B，使得进程 B 可以访问共享内存，最后完成共享内存的访问后，执行 V 操作，使信号量恢复到初始值 1。&lt;/li>
&lt;/ul>
&lt;p>可以发现，信号初始化为 &lt;code>1&lt;/code>，就代表着是&lt;strong>互斥信号量&lt;/strong>，它可以保证共享内存在任何时刻只有一个进程在访问，这就很好的保护了共享内存。&lt;/p>
&lt;p>另外，在多进程里，每个进程并不一定是顺序执行的，它们基本是以各自独立的、不可预知的速度向前推进，但有时候我们又希望多个进程能密切合作，以实现一个共同的任务。&lt;/p>
&lt;p>例如，进程 A 是负责生产数据，而进程 B 是负责读取数据，这两个进程是相互合作、相互依赖的，进程 A 必须先生产了数据，进程 B 才能读取到数据，所以执行是有前后顺序的。&lt;/p>
&lt;p>那么这时候，就可以用信号量来实现多进程同步的方式，我们可以初始化信号量为 &lt;code>0&lt;/code>。&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/iuxfg7/1619421762560-5bd9c203-120b-4f19-8bd1-4cf3bd2433d3.png" alt="">&lt;/p>
&lt;p>具体过程：&lt;/p>
&lt;ul>
&lt;li>如果进程 B 比进程 A 先执行了，那么执行到 P 操作时，由于信号量初始值为 0，故信号量会变为 -1，表示进程 A 还没生产数据，于是进程 B 就阻塞等待；&lt;/li>
&lt;li>接着，当进程 A 生产完数据后，执行了 V 操作，就会使得信号量变为 0，于是就会唤醒阻塞在 P 操作的进程 B；&lt;/li>
&lt;li>最后，进程 B 被唤醒后，意味着进程 A 已经生产了数据，于是进程 B 就可以正常读取数据了。&lt;/li>
&lt;/ul>
&lt;p>可以发现，信号初始化为 &lt;code>0&lt;/code>，就代表着是&lt;strong>同步信号量&lt;/strong>，它可以保证进程 A 应在进程 B 之前执行。&lt;/p>
&lt;h3 id="信号">信号&lt;/h3>
&lt;p>上面说的进程间通信，都是常规状态下的工作模式。&lt;strong>对于异常情况下的工作模式，就需要用「信号」的方式来通知进程。&lt;/strong>&lt;/p>
&lt;p>信号跟信号量虽然名字相似度 66.66%，但两者用途完全不一样，就好像 Java 和 JavaScript 的区别。&lt;/p>
&lt;p>在 Linux 操作系统中， 为了响应各种各样的事件，提供了几十种信号，分别代表不同的意义。我们可以通过 &lt;code>kill -l&lt;/code> 命令，查看所有的信号：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>root@lichenhao:~# kill -l
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> 1&lt;span style="color:#f92672">)&lt;/span> SIGHUP 2&lt;span style="color:#f92672">)&lt;/span> SIGINT 3&lt;span style="color:#f92672">)&lt;/span> SIGQUIT 4&lt;span style="color:#f92672">)&lt;/span> SIGILL 5&lt;span style="color:#f92672">)&lt;/span> SIGTRAP
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> 6&lt;span style="color:#f92672">)&lt;/span> SIGABRT 7&lt;span style="color:#f92672">)&lt;/span> SIGBUS 8&lt;span style="color:#f92672">)&lt;/span> SIGFPE 9&lt;span style="color:#f92672">)&lt;/span> SIGKILL 10&lt;span style="color:#f92672">)&lt;/span> SIGUSR1
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>11&lt;span style="color:#f92672">)&lt;/span> SIGSEGV 12&lt;span style="color:#f92672">)&lt;/span> SIGUSR2 13&lt;span style="color:#f92672">)&lt;/span> SIGPIPE 14&lt;span style="color:#f92672">)&lt;/span> SIGALRM 15&lt;span style="color:#f92672">)&lt;/span> SIGTERM
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>16&lt;span style="color:#f92672">)&lt;/span> SIGSTKFLT 17&lt;span style="color:#f92672">)&lt;/span> SIGCHLD 18&lt;span style="color:#f92672">)&lt;/span> SIGCONT 19&lt;span style="color:#f92672">)&lt;/span> SIGSTOP 20&lt;span style="color:#f92672">)&lt;/span> SIGTSTP
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>21&lt;span style="color:#f92672">)&lt;/span> SIGTTIN 22&lt;span style="color:#f92672">)&lt;/span> SIGTTOU 23&lt;span style="color:#f92672">)&lt;/span> SIGURG 24&lt;span style="color:#f92672">)&lt;/span> SIGXCPU 25&lt;span style="color:#f92672">)&lt;/span> SIGXFSZ
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>26&lt;span style="color:#f92672">)&lt;/span> SIGVTALRM 27&lt;span style="color:#f92672">)&lt;/span> SIGPROF 28&lt;span style="color:#f92672">)&lt;/span> SIGWINCH 29&lt;span style="color:#f92672">)&lt;/span> SIGIO 30&lt;span style="color:#f92672">)&lt;/span> SIGPWR
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>31&lt;span style="color:#f92672">)&lt;/span> SIGSYS 34&lt;span style="color:#f92672">)&lt;/span> SIGRTMIN 35&lt;span style="color:#f92672">)&lt;/span> SIGRTMIN+1 36&lt;span style="color:#f92672">)&lt;/span> SIGRTMIN+2 37&lt;span style="color:#f92672">)&lt;/span> SIGRTMIN+3
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>38&lt;span style="color:#f92672">)&lt;/span> SIGRTMIN+4 39&lt;span style="color:#f92672">)&lt;/span> SIGRTMIN+5 40&lt;span style="color:#f92672">)&lt;/span> SIGRTMIN+6 41&lt;span style="color:#f92672">)&lt;/span> SIGRTMIN+7 42&lt;span style="color:#f92672">)&lt;/span> SIGRTMIN+8
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>43&lt;span style="color:#f92672">)&lt;/span> SIGRTMIN+9 44&lt;span style="color:#f92672">)&lt;/span> SIGRTMIN+10 45&lt;span style="color:#f92672">)&lt;/span> SIGRTMIN+11 46&lt;span style="color:#f92672">)&lt;/span> SIGRTMIN+12 47&lt;span style="color:#f92672">)&lt;/span> SIGRTMIN+13
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>48&lt;span style="color:#f92672">)&lt;/span> SIGRTMIN+14 49&lt;span style="color:#f92672">)&lt;/span> SIGRTMIN+15 50&lt;span style="color:#f92672">)&lt;/span> SIGRTMAX-14 51&lt;span style="color:#f92672">)&lt;/span> SIGRTMAX-13 52&lt;span style="color:#f92672">)&lt;/span> SIGRTMAX-12
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>53&lt;span style="color:#f92672">)&lt;/span> SIGRTMAX-11 54&lt;span style="color:#f92672">)&lt;/span> SIGRTMAX-10 55&lt;span style="color:#f92672">)&lt;/span> SIGRTMAX-9 56&lt;span style="color:#f92672">)&lt;/span> SIGRTMAX-8 57&lt;span style="color:#f92672">)&lt;/span> SIGRTMAX-7
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>58&lt;span style="color:#f92672">)&lt;/span> SIGRTMAX-6 59&lt;span style="color:#f92672">)&lt;/span> SIGRTMAX-5 60&lt;span style="color:#f92672">)&lt;/span> SIGRTMAX-4 61&lt;span style="color:#f92672">)&lt;/span> SIGRTMAX-3 62&lt;span style="color:#f92672">)&lt;/span> SIGRTMAX-2
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>63&lt;span style="color:#f92672">)&lt;/span> SIGRTMAX-1 64&lt;span style="color:#f92672">)&lt;/span> SIGRTMAX
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>运行在 shell 终端的进程，我们可以通过键盘输入某些组合键的时候，给进程发送信号。例如&lt;/p>
&lt;ul>
&lt;li>Ctrl+C 产生 &lt;code>SIGINT&lt;/code> 信号，表示终止该进程；&lt;/li>
&lt;li>Ctrl+Z 产生 &lt;code>SIGTSTP&lt;/code> 信号，表示停止该进程，但还未结束；&lt;/li>
&lt;/ul>
&lt;p>如果进程在后台运行，可以通过 &lt;code>kill&lt;/code> 命令的方式给进程发送信号，但前提需要知道运行中的进程 PID 号，例如：&lt;/p>
&lt;ul>
&lt;li>kill -9 1050 ，表示给 PID 为 1050 的进程发送 &lt;code>SIGKILL&lt;/code> 信号，用来立即结束该进程；&lt;/li>
&lt;/ul>
&lt;p>所以，信号事件的来源主要有硬件来源（如键盘 Cltr+C ）和软件来源（如 kill 命令）。&lt;/p>
&lt;p>信号是进程间通信机制中&lt;strong>唯一的异步通信机制&lt;/strong>，因为可以在任何时候发送信号给某一进程，一旦有信号产生，我们就有下面这几种，用户进程对信号的处理方式。&lt;/p>
&lt;p>&lt;strong>1. 执行默认操作&lt;/strong>。Linux 对每种信号都规定了默认操作，例如，上面列表中的 SIGTERM 信号，就是终止进程的意思。Core 的意思是 Core Dump，也即终止进程后，通过 Core Dump 将当前进程的运行状态保存在文件里面，方便程序员事后进行分析问题在哪里。&lt;/p>
&lt;p>&lt;strong>2. 捕捉信号&lt;/strong>。我们可以为信号定义一个信号处理函数。当信号发生时，我们就执行相应的信号处理函数。&lt;/p>
&lt;p>&lt;strong>3. 忽略信号&lt;/strong>。当我们不希望处理某些信号的时候，就可以忽略该信号，不做任何处理。有两个信号是应用进程无法捕捉和忽略的，即 &lt;code>SIGKILL&lt;/code> 和 &lt;code>SEGSTOP&lt;/code>，它们用于在任何时候中断或结束某一进程。&lt;/p>
&lt;h3 id="socket">Socket&lt;/h3>
&lt;p>前面提到的管道、消息队列、共享内存、信号量和信号都是在同一台主机上进行进程间通信，那要想&lt;strong>跨网络与不同主机上的进程之间通信，就需要 Socket 通信了。&lt;/strong>&lt;/p>
&lt;p>实际上，Socket 通信不仅可以跨网络与不同主机的进程间通信，还可以在同主机上进程间通信。&lt;/p>
&lt;p>我们来看看创建 socket 的系统调用：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">int&lt;/span>&lt;span style="color:#960050;background-color:#1e0010"> &lt;/span>&lt;span style="color:#a6e22e">socket&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span>&lt;span style="color:#960050;background-color:#1e0010"> &lt;/span>&lt;span style="color:#a6e22e">domain&lt;/span>,&lt;span style="color:#960050;background-color:#1e0010"> &lt;/span>&lt;span style="color:#66d9ef">int&lt;/span>&lt;span style="color:#960050;background-color:#1e0010"> &lt;/span>&lt;span style="color:#66d9ef">type&lt;/span>,&lt;span style="color:#960050;background-color:#1e0010"> &lt;/span>&lt;span style="color:#66d9ef">int&lt;/span>&lt;span style="color:#960050;background-color:#1e0010"> &lt;/span>&lt;span style="color:#a6e22e">protocal&lt;/span>)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>三个参数分别代表：&lt;/p>
&lt;ul>
&lt;li>domain 参数用来指定协议族，比如 AF_INET 用于 IPV4、AF_INET6 用于 IPV6、AF_LOCAL/AF_UNIX 用于本机；&lt;/li>
&lt;li>type 参数用来指定通信特性，比如 SOCK_STREAM 表示的是字节流，对应 TCP、SOCK_DGRAM   表示的是数据报，对应 UDP、SOCK_RAW 表示的是原始套接字；&lt;/li>
&lt;li>protocal 参数原本是用来指定通信协议的，但现在基本废弃。因为协议已经通过前面两个参数指定完成，protocol 目前一般写成 0 即可；&lt;/li>
&lt;/ul>
&lt;p>根据创建 socket 类型的不同，通信的方式也就不同：&lt;/p>
&lt;ul>
&lt;li>实现 TCP 字节流通信：socket 类型是 AF_INET 和 SOCK_STREAM；&lt;/li>
&lt;li>实现 UDP 数据报通信：socket 类型是 AF_INET 和 SOCK_DGRAM；&lt;/li>
&lt;li>实现本地进程间通信：
&lt;ul>
&lt;li>「本地字节流 socket 」类型是 AF_LOCAL 和 SOCK_STREAM&lt;/li>
&lt;li>「本地数据报 socket 」类型是 AF_LOCAL 和 SOCK_DGRAM。另外，AF_UNIX 和 AF_LOCAL 是等价的，所以 AF_UNIX 也属于本地 socket；&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>接下来，简单说一下这三种通信的编程模式。&lt;/p>
&lt;blockquote>
&lt;p>针对 TCP 协议通信的 socket 编程模型&lt;/p>
&lt;/blockquote>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/iuxfg7/1619421762556-953130dd-bbfe-4a7d-ac0a-31c69ef31771.png" alt="">&lt;/p>
&lt;ul>
&lt;li>服务端和客户端初始化 &lt;code>socket&lt;/code>，得到文件描述符；&lt;/li>
&lt;li>服务端调用 &lt;code>bind&lt;/code>，将绑定在 IP 地址和端口;&lt;/li>
&lt;li>服务端调用 &lt;code>listen&lt;/code>，进行监听；&lt;/li>
&lt;li>服务端调用 &lt;code>accept&lt;/code>，等待客户端连接；&lt;/li>
&lt;li>客户端调用 &lt;code>connect&lt;/code>，向服务器端的地址和端口发起连接请求；&lt;/li>
&lt;li>服务端 &lt;code>accept&lt;/code> 返回用于传输的 &lt;code>socket&lt;/code> 的文件描述符；&lt;/li>
&lt;li>客户端调用 &lt;code>write&lt;/code> 写入数据；服务端调用 &lt;code>read&lt;/code> 读取数据；&lt;/li>
&lt;li>客户端断开连接时，会调用 &lt;code>close&lt;/code>，那么服务端 &lt;code>read&lt;/code> 读取数据的时候，就会读取到了 &lt;code>EOF&lt;/code>，待处理完数据后，服务端调用 &lt;code>close&lt;/code>，表示连接关闭。&lt;/li>
&lt;/ul>
&lt;p>这里需要注意的是，服务端调用 &lt;code>accept&lt;/code> 时，连接成功了会返回一个已完成连接的 socket，后续用来传输数据。&lt;/p>
&lt;p>所以，监听的 socket 和真正用来传送数据的 socket，是「&lt;strong>两个&lt;/strong>」 socket，一个叫作&lt;strong>监听 socket&lt;/strong>，一个叫作&lt;strong>已完成连接 socket&lt;/strong>。&lt;/p>
&lt;p>成功连接建立之后，双方开始通过 read 和 write 函数来读写数据，就像往一个文件流里面写东西一样。&lt;/p>
&lt;blockquote>
&lt;p>针对 UDP 协议通信的 socket 编程模型&lt;/p>
&lt;/blockquote>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/iuxfg7/1619421762345-95e531c1-8f0d-42d3-80d2-e8981177ed74.png" alt="">&lt;/p>
&lt;p>UDP 是没有连接的，所以不需要三次握手，也就不需要像 TCP 调用 listen 和 connect，但是 UDP 的交互仍然需要 IP 地址和端口号，因此也需要 bind。&lt;/p>
&lt;p>对于 UDP 来说，不需要要维护连接，那么也就没有所谓的发送方和接收方，甚至都不存在客户端和服务端的概念，只要有一个 socket 多台机器就可以任意通信，因此每一个 UDP 的 socket 都需要 bind。&lt;/p>
&lt;p>另外，每次通信时，调用 sendto 和 recvfrom，都要传入目标主机的 IP 地址和端口。&lt;/p>
&lt;blockquote>
&lt;p>针对本地进程间通信的 socket 编程模型&lt;/p>
&lt;/blockquote>
&lt;p>本地 socket   被用于在&lt;strong>同一台主机上进程间通信&lt;/strong>的场景：&lt;/p>
&lt;ul>
&lt;li>本地 socket 的编程接口和 IPv4 、IPv6 套接字编程接口是一致的，可以支持「字节流」和「数据报」两种协议；&lt;/li>
&lt;li>本地 socket 的实现效率大大高于 IPv4 和 IPv6 的字节流、数据报 socket 实现；&lt;/li>
&lt;/ul>
&lt;p>对于本地字节流 socket，其 socket 类型是 AF_LOCAL 和 SOCK_STREAM。&lt;/p>
&lt;p>对于本地数据报 socket，其 socket 类型是 AF_LOCAL 和 SOCK_DGRAM。&lt;/p>
&lt;p>本地字节流 socket 和 本地数据报 socket 在 bind 的时候，不像 TCP 和 UDP 要绑定 IP 地址和端口，而是&lt;strong>绑定一个本地文件&lt;/strong>，这也就是它们之间的最大区别。&lt;/p>
&lt;h3 id="总结">总结&lt;/h3>
&lt;p>由于每个进程的用户空间都是独立的，不能相互访问，这时就需要借助内核空间来实现进程间通信，原因很简单，每个进程都是共享一个内核空间。&lt;/p>
&lt;p>Linux 内核提供了不少进程间通信的方式，其中最简单的方式就是管道，管道分为「匿名管道」和「命名管道」。&lt;/p>
&lt;p>&lt;strong>匿名管道&lt;/strong>顾名思义，它没有名字标识，匿名管道是特殊文件只存在于内存，没有存在于文件系统中，shell 命令中的 &lt;code>|&lt;/code> 竖线就是匿名管道，通信的数据是&lt;strong>无格式的流并且大小受限&lt;/strong>，通信的方式是&lt;strong>单向&lt;/strong>的，数据只能在一个方向上流动，如果要双向通信，需要创建两个管道，再来&lt;strong>匿名管道是只能用于存在父子关系的进程间通信&lt;/strong>，匿名管道的生命周期随着进程创建而建立，随着进程终止而消失。&lt;/p>
&lt;p>&lt;strong>命名管道&lt;/strong>突破了匿名管道只能在亲缘关系进程间的通信限制，因为使用命名管道的前提，需要在文件系统创建一个类型为 p 的设备文件，那么毫无关系的进程就可以通过这个设备文件进行通信。另外，不管是匿名管道还是命名管道，进程写入的数据都是&lt;strong>缓存在内核&lt;/strong>中，另一个进程读取数据时候自然也是从内核中获取，同时通信数据都遵循&lt;strong>先进先出&lt;/strong>原则，不支持 lseek 之类的文件定位操作。&lt;/p>
&lt;p>&lt;strong>消息队列&lt;/strong>克服了管道通信的数据是无格式的字节流的问题，消息队列实际上是保存在内核的「消息链表」，消息队列的消息体是可以用户自定义的数据类型，发送数据时，会被分成一个一个独立的消息体，当然接收数据时，也要与发送方发送的消息体的数据类型保持一致，这样才能保证读取的数据是正确的。消息队列通信的速度不是最及时的，毕竟&lt;strong>每次数据的写入和读取都需要经过用户态与内核态之间的拷贝过程。&lt;/strong>&lt;/p>
&lt;p>&lt;strong>共享内存&lt;/strong>可以解决消息队列通信中用户态与内核态之间数据拷贝过程带来的开销，&lt;strong>它直接分配一个共享空间，每个进程都可以直接访问&lt;/strong>，就像访问进程自己的空间一样快捷方便，不需要陷入内核态或者系统调用，大大提高了通信的速度，享有&lt;strong>最快&lt;/strong>的进程间通信方式之名。但是便捷高效的共享内存通信，&lt;strong>带来新的问题，多进程竞争同个共享资源会造成数据的错乱。&lt;/strong>&lt;/p>
&lt;p>那么，就需要&lt;strong>信号量&lt;/strong>来保护共享资源，以确保任何时刻只能有一个进程访问共享资源，这种方式就是互斥访问。&lt;strong>信号量不仅可以实现访问的互斥性，还可以实现进程间的同步&lt;/strong>，信号量其实是一个计数器，表示的是资源个数，其值可以通过两个原子操作来控制，分别是 &lt;strong>P 操作和 V 操作&lt;/strong>。&lt;/p>
&lt;p>与信号量名字很相似的叫&lt;strong>信号&lt;/strong>，它俩名字虽然相似，但功能一点儿都不一样。信号是进程间通信机制中&lt;strong>唯一的异步通信机制&lt;/strong>，信号可以在应用进程和内核之间直接交互，内核也可以利用信号来通知用户空间的进程发生了哪些系统事件，信号事件的来源主要有硬件来源（如键盘 Cltr+C ）和软件来源（如 kill 命令），一旦有信号发生，&lt;strong>进程有三种方式响应信号 1. 执行默认操作、2. 捕捉信号、3. 忽略信号&lt;/strong>。有两个信号是应用进程无法捕捉和忽略的，即 &lt;code>SIGKILL&lt;/code> 和 &lt;code>SEGSTOP&lt;/code>，这是为了方便我们能在任何时候结束或停止某个进程。&lt;/p>
&lt;p>前面说到的通信机制，都是工作于同一台主机，如果&lt;strong>要与不同主机的进程间通信，那么就需要 Socket 通信了&lt;/strong>。Socket 实际上不仅用于不同的主机进程间通信，还可以用于本地主机进程间通信，可根据创建 Socket 的类型不同，分为三种常见的通信方式，一个是基于 TCP 协议的通信方式，一个是基于 UDP 协议的通信方式，一个是本地进程间通信方式。&lt;/p>
&lt;p>以上，就是进程间通信的主要机制了。你可能会问了，那线程通信间的方式呢？&lt;/p>
&lt;p>同个进程下的线程之间都是共享进程的资源，只要是共享变量都可以做到线程间通信，比如全局变量，所以对于线程间关注的不是通信方式，而是关注多线程竞争共享资源的问题，信号量也同样可以在线程间实现互斥与同步：&lt;/p>
&lt;ul>
&lt;li>互斥的方式，可保证任意时刻只有一个线程访问共享资源；&lt;/li>
&lt;li>同步的方式，可保证线程 A 应在线程 B 之前执行；&lt;/li>
&lt;/ul></description></item><item><title>Docs: IPVS</title><link>https://desistdaydream.github.io/docs/3.%E9%9B%86%E7%BE%A4%E4%B8%8E%E5%88%86%E5%B8%83%E5%BC%8F/LVS/IPVS/IPVS/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/3.%E9%9B%86%E7%BE%A4%E4%B8%8E%E5%88%86%E5%B8%83%E5%BC%8F/LVS/IPVS/IPVS/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/IP_Virtual_Server">Wiki,IPVS&lt;/a>&lt;/li>
&lt;li>&lt;a href="http://www.linuxvirtualserver.org/software/ipvs.html">官方文档&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>&lt;strong>IP Virtual Service(IP 虚拟服务，简称 IPVS)&lt;/strong> 是基于 &lt;a href="https://desistdaydream.github.io/docs/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2.Kernel(%E5%86%85%E6%A0%B8)/8.Network%20%E7%AE%A1%E7%90%86/Linux%20%E7%BD%91%E7%BB%9C%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6/Netfilter%20%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6%E7%B3%BB%E7%BB%9F/Netfilter%20%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6%E7%B3%BB%E7%BB%9F.md">Netfilter&lt;/a> 的 Linux 内核模块，用来实现 &lt;a href="https://desistdaydream.github.io/docs/3.%E9%9B%86%E7%BE%A4%E4%B8%8E%E5%88%86%E5%B8%83%E5%BC%8F/LVS/LVS.md">LVS&lt;/a> 集群中的 &lt;strong>Scheduler(调度器)&lt;/strong> 功能。启动这个模块的 Linux 服务器就变成了 LVS 系统中的 &lt;strong>Director&lt;/strong>，此时，这个服务器可以看作是一种高效的 Layer-4(四层) 交换机。在 Director 上运行 IPVS 代码是 LVS 的基本要素。&lt;/p>
&lt;p>IPVS 在服务器上运行，并充当 RS 集群前面的负载均衡器。IPVS 可以将基于 TCP 和 UDP 的服务请求定向到真实服务器，并使真实服务器的服务在单个 IP 地址上表现为虚拟服务。当一个 TCP 连接的初始 SYN 报文到达时，IPVS 就选择一台服务器，将报文转发给它。此后通过查发报文的 IP 和 TCP 报文头地址，保证此连接的后继报文被转发到相同的服务器。这样，IPVS 无法检查到请求的内容再选择服务器，这就要求后端的服务器组是提供相同的服务，不管请求被送到哪一台服务器，返回结果都应该是一样的。但是在有一些应用中后端的服务器可能功能不一，有的是提供 HTML 文档的 Web 服务器，有的是提供图片的 Web 服务器，有的是提供 CGI 的 Web 服务器。这时，就需要基于内容请求分发 (Content-Based Request Distribution)，同时基于内容请求分发可以提高后端服务器上访问的局部性。&lt;/p>
&lt;ul>
&lt;li>一个 ipvs 主机可以同时定义多个 cluster service&lt;/li>
&lt;li>一个 cluster service 上至少应该定义一个 real server，定义时指明 lvs-type，以及 lvs scheduler&lt;/li>
&lt;/ul>
&lt;p>用白话理解 IPVS：
IPVS 就是包括 Director 和 RS 在内的所有设备上的 IP，统一虚拟成一个 IP，这个 IP 就是面向用户的唯一 IP，用户通过这个 IP，就可以访问集群，让集群为其提供服务，这也是负载均衡的体现，也是集群的体现，把很多设备当做一个整体来看。&lt;/p>
&lt;h2 id="ipvs-与-lvs-的关系">IPVS 与 LVS 的关系&lt;/h2>
&lt;p>LVS 更偏向于描述一个概念，而 IPVS 程序则是实现 LVS 的最核心部分。通过 IPVS 以及其管理工具 ipvsadm，可以实现 LVS 中的 Director(指挥器)。而 RS，本质上并不需要 LVS 或者 IPVS 代码支持，只需要在 DR 模式下，配置一些内核参数即可。&lt;/p>
&lt;p>而随着发展，IPVS 已经存单独的程序，被包含在 Linux 内核中，成了了默认自带的模块。&lt;/p>
&lt;p>可以这么说，IPVS 就是 LVS；也可以说，LVS 包含 ipvs 与 ipvsadm。&lt;/p>
&lt;h1 id="ipvs-配置">IPVS 配置&lt;/h1>
&lt;p>ipvs 可以通过两种方式进行配置：&lt;/p>
&lt;ul>
&lt;li>ipvsadm 命令&lt;/li>
&lt;li>ipvs 模块参数&lt;/li>
&lt;/ul>
&lt;p>ipvs 是一个内核模块，所以，想要配置 ipvs 则需要以&lt;a href="https://desistdaydream.github.io/docs/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2.Kernel(%E5%86%85%E6%A0%B8)/1.Linux%20Kernel/Module(%E6%A8%A1%E5%9D%97).md">内核模块&lt;/a>的配置方式来进行配置。可以通过 modinfo -p ip_vs 命令查看该模块可以配置的参数&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>~&lt;span style="color:#f92672">]&lt;/span>&lt;span style="color:#75715e"># modinfo -p ip_vs&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>conn_tab_bits:Set connections&lt;span style="color:#960050;background-color:#1e0010">&amp;#39;&lt;/span> hash size &lt;span style="color:#f92672">(&lt;/span>int&lt;span style="color:#f92672">)&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>现阶段，可用的参数只有一个：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>&lt;strong>conn_tab_bits&lt;/strong> # 设置连接表的大小。&lt;code>默认值：12&lt;/code>。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>该参数控制下面示例中 size 的大小，2 的 12 次方，4096&lt;/p>
&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>root@lichenhao:~# ipvsadm -ln
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>IP Virtual Server version 1.2.1 &lt;span style="color:#f92672">(&lt;/span>size&lt;span style="color:#f92672">=&lt;/span>4096&lt;span style="color:#f92672">)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Prot LocalAddress:Port Scheduler Flags
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> -&amp;gt; RemoteAddress:Port Forward Weight ActiveConn InActConn
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>IPVS connection hash table size，该表用于记录每个进来的连接及路由去向的信息（这个和 iptables 跟踪表类似）。连接的 Hash 表要容纳几百万个并发连接，任何一个报文到达都需要查找连接 Hash 表。Hash 表的查找复杂度为 O(n/m)，其中 n 为 Hash 表中对象的个数，m 为 Hash 表的桶个数。当对象在 Hash 表中均匀分布和 Hash 表的桶个数与对象个数一样多时，Hash 表的查找复杂度可以接近 O(1)&lt;/p>
&lt;p>连接跟踪表中，每行称为一个 hash bucket（hash 桶），桶的个数是一个固定的值 CONFIG_IP_VS_TAB_BITS，默认为 12（2 的 12 次方，4096）。这个值可以调整，该值的大小应该在 8 到 20 之间。&lt;/p>
&lt;p>LVS 的调优建议将 hash table 的值设置为不低于并发连接数。例如，并发连接数为 200，Persistent 时间为 200S，那么 hash 桶的个数应设置为尽可能接近 200x200=40000，2 的 15 次方为 32768 就可以了。当 ip_vs_conn_tab_bits=20 时，哈希表的的大小（条目）为 pow(2,20)，即 1048576。&lt;/p>
&lt;p>这里的 hash 桶的个数，并不是 LVS 最大连接数限制。LVS 使用哈希链表解决“哈希冲突”，当连接数大于这个值时，必然会出现哈稀冲突，会（稍微）降低性能，但是并不对在功能上对 LVS 造成影响。&lt;/p>
&lt;p>修改模块参数：echo &amp;ldquo;options ip_vs conn_tab_bits=22&amp;rdquo; &amp;gt; /etc/modprobe.d/ip_vs.conf，效果如下：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>IP Virtual Server version 1.2.1 &lt;span style="color:#f92672">(&lt;/span>size&lt;span style="color:#f92672">=&lt;/span>4194304&lt;span style="color:#f92672">)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Prot LocalAddress:Port Scheduler Flags
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> -&amp;gt; RemoteAddress:Port Forward Weight ActiveConn InActConn
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>TCP 10.10.9.60:30000 rr persistent &lt;span style="color:#ae81ff">30&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> -&amp;gt; 10.10.9.69:30000 Route &lt;span style="color:#ae81ff">1&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> -&amp;gt; 10.10.9.70:30000 Route &lt;span style="color:#ae81ff">1&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div></description></item><item><title>Docs: K3S</title><link>https://desistdaydream.github.io/docs/10.%E4%BA%91%E5%8E%9F%E7%94%9F/2.3.Kubernetes-%E5%AE%B9%E5%99%A8%E7%BC%96%E6%8E%92%E7%B3%BB%E7%BB%9F/Kubernetes-%E8%A1%8D%E7%94%9F%E5%93%81/K3S/K3S/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/10.%E4%BA%91%E5%8E%9F%E7%94%9F/2.3.Kubernetes-%E5%AE%B9%E5%99%A8%E7%BC%96%E6%8E%92%E7%B3%BB%E7%BB%9F/Kubernetes-%E8%A1%8D%E7%94%9F%E5%93%81/K3S/K3S/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://github.com/k3s-io/k3s">GitHub 项目，k3s-io/k3s&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://rancher.com/docs/k3s/latest/en/">官方文档&lt;/a>
&lt;ul>
&lt;li>&lt;a href="https://docs.rancher.cn/k3s/">中文官方文档&lt;/a>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;a href="https://mp.weixin.qq.com/s/ARhxWGypG0wepMqwTLH0mQ">公众号-云原生实验室，K3S 工具进阶完全指南&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>K3S 是一个轻量的 Kubernetes，具有基本的 kubernetes 功能，将 kubernetes 的主要组件都集成在一个二进制文件中(apiserver、kubelet 等)，这个二进制文件只有不到 100m。内嵌 Containerd，可以通过 Containerd 来启动 coredns 等 kubernetes 的 addone。直接使用 k3s 的二进制文件，即可启动一个 kubernetes 的节点。&lt;/p>
&lt;p>Note：K3S 的 kubelet 不支持 systemd 作为 cgroup-driver，原因详见 &lt;a href="https://github.com/rancher/k3s/issues/797">https://github.com/rancher/k3s/issues/797&lt;/a>，说是 systemd 的类型无法放进二进制文件里。&lt;/p>
&lt;p>k3s 二进制文件包含 kubelet、api-server、kube-controller-manager、kube-scheduler，然后会通过 containerd 拉起 coredns 与 flannel。&lt;/p>
&lt;h1 id="k3s-关联文件与配置">k3s 关联文件与配置&lt;/h1>
&lt;p>&lt;strong>/etc/rancher/k3s/&lt;/strong> #&lt;/p>
&lt;ul>
&lt;li>&lt;strong>./k3s.yaml&lt;/strong> # kubeconfig 文件&lt;/li>
&lt;li>&lt;strong>./config.yaml&lt;/strong> # 运行时配置文件，与环境变量和 CLI 等效。&lt;/li>
&lt;li>&lt;strong>./registries.yaml&lt;/strong> #&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>/run/k3s/&lt;/strong> # K3S 所使用的容器 Runtime 的数据保存路径。&lt;/p>
&lt;ul>
&lt;li>&lt;strong>./containerd/&lt;/strong> # 与 &lt;a href="https://desistdaydream.github.io/docs/10.%E4%BA%91%E5%8E%9F%E7%94%9F/2.2.%E5%AE%9E%E7%8E%B0%E5%AE%B9%E5%99%A8%E7%9A%84%E5%B7%A5%E5%85%B7/Containerd/Containerd.md#Containerd%20%E5%85%B3%E8%81%94%E6%96%87%E4%BB%B6%E4%B8%8E%E9%85%8D%E7%BD%AE">Containerd&lt;/a> 中的 /run/containerd/ 目录功能一致。&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>/run/flannel/&lt;/strong> # 与 &lt;a href="https://desistdaydream.github.io/docs/10.%E4%BA%91%E5%8E%9F%E7%94%9F/2.3.Kubernetes%20%E5%AE%B9%E5%99%A8%E7%BC%96%E6%8E%92%E7%B3%BB%E7%BB%9F/8.Kubernetes%20%E7%BD%91%E7%BB%9C/CNI/Flannel.md#Flannel%20%E5%85%B3%E8%81%94%E6%96%87%E4%BB%B6%E4%B8%8E%E9%85%8D%E7%BD%AE%20%E5%AE%B9%E5%99%A8%E7%BC%96%E6%8E%92%E7%B3%BB%E7%BB%9F/8.Kubernetes%20%E7%BD%91%E7%BB%9C/CNI/Flannel#Flannel%20%E5%85%B3%E8%81%94%E6%96%87%E4%BB%B6%E4%B8%8E%E9%85%8D%E7%BD%AE">Flannel&lt;/a> 中 /run/flannel/ 目录功能一致。&lt;/p>
&lt;p>&lt;strong>/var/lib/rancher/k3s/&lt;/strong> # k3s 运行时数据存储保存路径&lt;/p>
&lt;ul>
&lt;li>&lt;strong>./agent/&lt;/strong> # 作为 k8s 的 node 节点所需要的信息保存路径。
&lt;ul>
&lt;li>包括证书、containerd 数据目录、cni，containerd 的配置文件 等等都在此处&lt;/li>
&lt;li>&lt;strong>./containerd/&lt;/strong> # 与 &lt;a href="https://desistdaydream.github.io/docs/10.%E4%BA%91%E5%8E%9F%E7%94%9F/2.2.%E5%AE%9E%E7%8E%B0%E5%AE%B9%E5%99%A8%E7%9A%84%E5%B7%A5%E5%85%B7/Containerd/Containerd.md#Containerd%20%E5%85%B3%E8%81%94%E6%96%87%E4%BB%B6%E4%B8%8E%E9%85%8D%E7%BD%AE">Containerd&lt;/a> 中的 /var/lib/containerd/ 目录功能一致。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>./data/&lt;/strong> #&lt;/li>
&lt;li>&lt;strong>./server/&lt;/strong> # 作为 k8s 的 master 节点所需要的信息保存路径
&lt;ul>
&lt;li>包括证书、kube-system 名称空间中的 manifests 文件、etcd 数据 等等都在此处&lt;/li>
&lt;li>&lt;strong>./db/&lt;/strong> # 内嵌 Etcd 数据保存路径&lt;/li>
&lt;li>&lt;strong>./manifests/&lt;/strong> # k3s 集群启动后，kube-system 名称空间中 pod 的 manifests 文件&lt;/li>
&lt;li>&lt;strong>./tls/&lt;/strong> # Kubernetes 主要组件运行所需证书保存路径&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>/var/lib/kubelet/&lt;/strong> #&lt;/p>
&lt;p>K3S 所有可能使用的目录可以参考 &lt;a href="https://desistdaydream.github.io/docs/10.%E4%BA%91%E5%8E%9F%E7%94%9F/2.3.Kubernetes%20%E5%AE%B9%E5%99%A8%E7%BC%96%E6%8E%92%E7%B3%BB%E7%BB%9F/Kubernetes%20%E8%A1%8D%E7%94%9F%E5%93%81/K3S/K3S%20%E9%83%A8%E7%BD%B2%E4%B8%8E%E6%B8%85%E7%90%86.md#%E6%B8%85%E7%90%86%20K3S">清理 K3S&lt;/a>&lt;/p>
&lt;h1 id="进入容器的文件系统">进入容器的文件系统&lt;/h1>
&lt;p>详见 &lt;a href="https://desistdaydream.github.io/docs/10.%E4%BA%91%E5%8E%9F%E7%94%9F/2.2.%E5%AE%9E%E7%8E%B0%E5%AE%B9%E5%99%A8%E7%9A%84%E5%B7%A5%E5%85%B7/%E5%AE%B9%E5%99%A8%E7%AE%A1%E7%90%86/%E5%AE%B9%E5%99%A8%E8%BF%90%E8%A1%8C%E6%97%B6%E7%AE%A1%E7%90%86/%E8%BF%9B%E5%85%A5%E5%AE%B9%E5%99%A8%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F.md">进入容器文件系统&lt;/a>。在 k3s 中，如果是 containerd 的话，则是在 /run/k3s/containerd/ 目录代替 /run/containerd/ 目录&lt;/p>
&lt;p>/run/k3s/containerd/io.containerd.runtime.v2.task/k8s.io/${ContainerID}/rootfs/&lt;/p></description></item></channel></rss>