<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>断念梦 – 文档</title><link>https://desistdaydream.github.io/docs/</link><description>Recent content in 文档 on 断念梦</description><generator>Hugo -- gohugo.io</generator><atom:link href="https://desistdaydream.github.io/docs/index.xml" rel="self" type="application/rss+xml"/><item><title>Docs: 1.Bootloader</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/1.bootloader/1.bootloader/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/1.bootloader/1.bootloader/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Bootloader">Wiki,Bootloader&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>&lt;strong>Bootloader(引导加载程序)&lt;/strong> 是负责 &lt;a href="https://en.wikipedia.org/wiki/Booting">booting(引导)&lt;/a> 计算器的软件。通常也被称为 Bootstrap Loader、Bootstrap。&lt;/p>
&lt;p>当计算机关闭时，操作系统、应用程序代码和数据 ‍‌ 仍存储在非易失性存储器中。当计算机开机时，它通常没有操作系统或其随机存取存储器 (RAM) 中的加载程序。计算机首先执行存储在只读存储器（ROM，以及后来的 EEPROM、NOR 闪存）中的相对较小的程序以及一些需要的数据，以初始化 RAM（特别是在 x86 系统上），访问非易失性设备（通常是块设备，例如 NAND 闪存）或可以将操作系统程序和数据加载到 RAM 中的设备。&lt;/p>
&lt;h1 id="配置">配置&lt;/h1>
&lt;p>&lt;strong>/boot/*&lt;/strong> # 所有关于系统引导启动的配置信息，都在该目录下
&lt;strong>/boot/grub2/*&lt;/strong> #
&lt;strong>/etc/default/grub&lt;/strong> #&lt;/p>
&lt;h1 id="引导管理命令行工具">引导管理命令行工具&lt;/h1>
&lt;p>grub2-*
grubby
grub2-mkconfig&lt;/p></description></item><item><title>Docs: Linux 管理</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/x.linux-%E7%AE%A1%E7%90%86/linux%E7%AE%A1%E7%90%86/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/x.linux-%E7%AE%A1%E7%90%86/linux%E7%AE%A1%E7%90%86/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://www.gnu.org/manual/">GNU Manual(手册)&lt;/a> — Linux 中很多核心程序，都是 GNU 组织下的软件。&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>系统管理员可以通过 一系列用户空间的二进制应用程序来管理 Linux 操作系统。Linux 内核自带了一个名为 coreutils 包，包含了很多最基本的管理工具。&lt;/p>
&lt;p>除了 Coreutils 包，还有很多很多的应用程序，一起组成了一套工具栈，系统管理员可以根据自身的需求，有选择得安装并使用它们。&lt;/p>
&lt;h1 id="coreutils">Coreutils&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/GNU_Core_Utilities">Wiki,GNU Core Utilies&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.gnu.org/software/coreutils/manual/">官方文档&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>GNU Core Utilities 是 GNU 操作系统的基本文件、Shell、文本操作的实用程序。同时，也是现在绝大部分 Linux 发行版内置的实用程序。&lt;/p>
&lt;p>Coreutils 通常可以通过各种 Linux 发行版的包管理器直接安装。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>root@lichenhao:~/downloads# apt-cache show coreutils
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Package: coreutils
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Architecture: amd64
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Version: 8.30-3ubuntu2
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Multi-Arch: foreign
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Priority: required
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Essential: yes
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Section: utils
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Origin: Ubuntu
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Maintainer: Ubuntu Developers &amp;lt;ubuntu-devel-discuss@lists.ubuntu.com&amp;gt;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Original-Maintainer: Michael Stone &amp;lt;mstone@debian.org&amp;gt;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Bugs: https://bugs.launchpad.net/ubuntu/+filebug
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Installed-Size: &lt;span style="color:#ae81ff">7196&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Pre-Depends: libacl1 &lt;span style="color:#f92672">(&lt;/span>&amp;gt;&lt;span style="color:#f92672">=&lt;/span> 2.2.23&lt;span style="color:#f92672">)&lt;/span>, libattr1 &lt;span style="color:#f92672">(&lt;/span>&amp;gt;&lt;span style="color:#f92672">=&lt;/span> 1:2.4.44&lt;span style="color:#f92672">)&lt;/span>, libc6 &lt;span style="color:#f92672">(&lt;/span>&amp;gt;&lt;span style="color:#f92672">=&lt;/span> 2.28&lt;span style="color:#f92672">)&lt;/span>, libselinux1 &lt;span style="color:#f92672">(&lt;/span>&amp;gt;&lt;span style="color:#f92672">=&lt;/span> 2.1.13&lt;span style="color:#f92672">)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Filename: pool/main/c/coreutils/coreutils_8.30-3ubuntu2_amd64.deb
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Size: &lt;span style="color:#ae81ff">1249368&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>MD5sum: e8e201b6d1b7f39776da07f6713e1675
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>SHA1: 1d4ab60c729a361d46a90d92defaca518b2918d2
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>SHA256: 99aa50af84de1737735f2f51e570d60f5842aa1d4a3129527906e7ffda368853
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Homepage: http://gnu.org/software/coreutils
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Description-en: GNU core utilities
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> This package contains the basic file, shell and text manipulation
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> utilities which are expected to exist on every operating system.
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Specifically, this package includes:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> arch base64 basename cat chcon chgrp chmod chown chroot cksum comm cp
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> csplit cut date dd df dir dircolors dirname du echo env expand expr
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> factor false flock fmt fold groups head hostid id install join link ln
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> logname ls md5sum mkdir mkfifo mknod mktemp mv nice nl nohup nproc numfmt
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> od paste pathchk pinky pr printenv printf ptx pwd readlink realpath rm
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> rmdir runcon sha*sum seq shred sleep sort split stat stty sum sync tac
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> tail tee test timeout touch tr true truncate tsort tty uname unexpand
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> uniq unlink users vdir wc who whoami yes
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Description-md5: d0d975dec3625409d24be1238cede238
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Task: minimal
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>这个包中，通常包含如下应用程序&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>arch base64 basename cat chcon chgrp chmod chown chroot cksum comm cp csplit cut date dd df dir dircolors dirname du echo env expand expr factor false flock fmt fold groups head hostid id install join link ln logname ls md5sum mkdir mkfifo mknod mktemp mv nice nl nohup nproc numfmt od paste pathchk pinky pr printenv printf ptx pwd readlink realpath rm rmdir runcon sha*sum seq shred sleep sort split stat stty sum sync tac tail tee test timeout touch tr true truncate tsort tty uname unexpand uniq unlink users vdir wc who whoami yes
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>可以发现，这些命令就是我们日常经常使用那些~&lt;/p>
&lt;h1 id="util-linux">Util-linux&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://github.com/util-linux/util-linux">GitHub 项目，util-linux/util-linux&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Util-linux">Wiki,Util-linux&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>util-linux 是由 Linux 内核组织分发的标准软件包，用作 Linux 操作系统的一部分。一个分支 util-linux-ng（ng 的意思是“下一代”）是在开发停滞时创建的，但截至 2011 年 1 月，它已重命名为 util-linux，并且是该软件包的正式版本。&lt;/p>
&lt;p>Util-linux 包中通常包含如下程序：&lt;/p>
&lt;ul>
&lt;li>addpart&lt;/li>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Getty_(Unix)">agetty&lt;/a>&lt;/li>
&lt;li>blkdiscard&lt;/li>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Blkid">blkid&lt;/a>&lt;/li>
&lt;li>blkzone&lt;/li>
&lt;li>&lt;a href="https://en.wikipedia.org/w/index.php?title=Blockdev&amp;amp;action=edit&amp;amp;redlink=1">blockdev&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Cal_(command)">cal&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Cfdisk">cfdisk&lt;/a>&lt;/li>
&lt;li>chcpu&lt;/li>
&lt;li>chfn&lt;/li>
&lt;li>chmem&lt;/li>
&lt;li>choom&lt;/li>
&lt;li>chrt&lt;/li>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Chsh">chsh&lt;/a>&lt;/li>
&lt;li>col (legacy)&lt;/li>
&lt;li>colcrt&lt;/li>
&lt;li>colrm&lt;/li>
&lt;li>column&lt;/li>
&lt;li>ctrlaltdel&lt;/li>
&lt;li>delpart&lt;/li>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Dmesg">dmesg&lt;/a>&lt;/li>
&lt;li>eject&lt;/li>
&lt;li>fallocate&lt;/li>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Fdformat">fdformat&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Fdisk">fdisk&lt;/a>&lt;/li>
&lt;li>fincore&lt;/li>
&lt;li>findfs&lt;/li>
&lt;li>findmnt&lt;/li>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/File_locking">flock&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Fsck">fsck&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Fsck">fsck&lt;/a>.&lt;a href="https://en.wikipedia.org/wiki/Cramfs">cramfs&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Fsck">fsck&lt;/a>.&lt;a href="https://en.wikipedia.org/wiki/MINIX_file_system">minix&lt;/a>&lt;/li>
&lt;li>fsfreeze&lt;/li>
&lt;li>fstrim&lt;/li>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Getopt">getopt&lt;/a>&lt;/li>
&lt;li>hardlink&lt;/li>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Hex_dump#od_and_hexdump">hexdump&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://en.wikipedia.org/w/index.php?title=Hwclock&amp;amp;action=edit&amp;amp;redlink=1">hwclock&lt;/a> (query and set the hardware clock (RTC))&lt;/li>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Ionice">ionice&lt;/a>&lt;/li>
&lt;li>ipcmk&lt;/li>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Ipcrm">ipcrm&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Ipcs">ipcs&lt;/a>&lt;/li>
&lt;li>irqtop&lt;/li>
&lt;li>isosize&lt;/li>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Kill_(Unix)">kill&lt;/a>&lt;/li>
&lt;li>last&lt;/li>
&lt;li>ldattach&lt;/li>
&lt;li>line (legacy)&lt;/li>
&lt;li>logger&lt;/li>
&lt;li>login&lt;/li>
&lt;li>look&lt;/li>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Losetup">losetup&lt;/a>&lt;/li>
&lt;li>lsblk&lt;/li>
&lt;li>lscpu&lt;a href="https://en.wikipedia.org/wiki/Util-linux#cite_note-8">[8]&lt;/a>&lt;/li>
&lt;li>lsfd&lt;/li>
&lt;li>lsipc&lt;/li>
&lt;li>lsirq&lt;a href="https://en.wikipedia.org/wiki/Util-linux#cite_note-9">[9]&lt;/a>&lt;/li>
&lt;li>lslocks&lt;/li>
&lt;li>lslogins&lt;/li>
&lt;li>lsmem&lt;/li>
&lt;li>lsns&lt;/li>
&lt;li>mcookie&lt;/li>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Mesg">mesg&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Mkfs">mkfs&lt;/a> (legacy)&lt;/li>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Mkfs">mkfs&lt;/a>.&lt;a href="https://en.wikipedia.org/wiki/Boot_File_System">bfs&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Mkfs">mkfs&lt;/a>.&lt;a href="https://en.wikipedia.org/wiki/Cramfs">cramfs&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Mkfs">mkfs&lt;/a>.&lt;a href="https://en.wikipedia.org/wiki/MINIX_file_system">minix&lt;/a>&lt;/li>
&lt;li>mkswap&lt;/li>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/More_(command)">more&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Mount_(Unix)">mount&lt;/a>&lt;/li>
&lt;li>mountpoint&lt;/li>
&lt;li>namei&lt;/li>
&lt;li>newgrp&lt;/li>
&lt;li>nologin&lt;/li>
&lt;li>nsenter&lt;/li>
&lt;li>partx&lt;/li>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Pg_(Unix)">pg&lt;/a> (legacy)&lt;/li>
&lt;li>pivot_root&lt;/li>
&lt;li>prlimit&lt;a href="https://en.wikipedia.org/wiki/Util-linux#cite_note-10">[10]&lt;/a>&lt;/li>
&lt;li>raw&lt;/li>
&lt;li>readprofile&lt;/li>
&lt;li>rename&lt;/li>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Nice_(Unix)">renice&lt;/a>&lt;/li>
&lt;li>reset (legacy)&lt;/li>
&lt;li>resizepart&lt;/li>
&lt;li>rev&lt;/li>
&lt;li>rfkill&lt;/li>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/RTC_Alarm">rtcwake&lt;/a>&lt;/li>
&lt;li>runuser&lt;/li>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Script_(Unix)">script&lt;/a>&lt;/li>
&lt;li>scriptlive&lt;/li>
&lt;li>scriptreplay&lt;/li>
&lt;li>setarch (including architecture symlinks such as i386, linux32, linux64, x86_64, etc.)&lt;/li>
&lt;li>setpriv&lt;/li>
&lt;li>setsid&lt;/li>
&lt;li>setterm&lt;/li>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Sfdisk">sfdisk&lt;/a>&lt;/li>
&lt;li>su&lt;/li>
&lt;li>sulogin&lt;/li>
&lt;li>swaplabel&lt;/li>
&lt;li>swapoff&lt;/li>
&lt;li>swapon&lt;/li>
&lt;li>switch_root&lt;/li>
&lt;li>taskset&lt;/li>
&lt;li>tunelp (deprecated)&lt;a href="https://en.wikipedia.org/wiki/Util-linux#cite_note-11">[11]&lt;/a>&lt;/li>
&lt;li>ul&lt;/li>
&lt;li>umount&lt;/li>
&lt;li>unshare&lt;/li>
&lt;li>utmpdump&lt;/li>
&lt;li>uuidd&lt;/li>
&lt;li>uuidgen&lt;/li>
&lt;li>uuidparse&lt;/li>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Vipw">vipw&lt;/a> (including symlink to vigr)&lt;/li>
&lt;li>wall&lt;/li>
&lt;li>wdctl&lt;/li>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Whereis">whereis&lt;/a>&lt;/li>
&lt;li>wipefs&lt;/li>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Write_(Unix)">write&lt;/a>&lt;/li>
&lt;li>zramctl&lt;/li>
&lt;/ul>
&lt;h3 id="removed">Removed&lt;/h3>
&lt;p>Utilities formerly included, but removed as of 1 July 2015:&lt;/p>
&lt;ul>
&lt;li>arch&lt;a href="https://en.wikipedia.org/wiki/Util-linux#cite_note-12">[12]&lt;/a>&lt;/li>
&lt;li>chkdupexe&lt;a href="https://en.wikipedia.org/wiki/Util-linux#cite_note-13">[13]&lt;/a>&lt;/li>
&lt;li>clock&lt;a href="https://en.wikipedia.org/wiki/Util-linux#cite_note-14">[14]&lt;/a>&lt;/li>
&lt;li>cytune&lt;a href="https://en.wikipedia.org/wiki/Util-linux#cite_note-15">[15]&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Ddate">ddate&lt;/a> (removed from default build&lt;a href="https://en.wikipedia.org/wiki/Util-linux#cite_note-16">[16]&lt;/a> before being removed&lt;a href="https://en.wikipedia.org/wiki/Util-linux#cite_note-17">[17]&lt;/a> altogether)&lt;/li>
&lt;li>elvtune&lt;a href="https://en.wikipedia.org/wiki/Util-linux#cite_note-18">[18]&lt;/a>&lt;/li>
&lt;li>fastboot&lt;a href="https://en.wikipedia.org/wiki/Util-linux#cite_note-simpleinit-19">[19]&lt;/a>&lt;/li>
&lt;li>fasthalt&lt;a href="https://en.wikipedia.org/wiki/Util-linux#cite_note-simpleinit-19">[19]&lt;/a>&lt;/li>
&lt;li>halt&lt;a href="https://en.wikipedia.org/wiki/Util-linux#cite_note-simpleinit-19">[19]&lt;/a>&lt;/li>
&lt;li>initctl&lt;a href="https://en.wikipedia.org/wiki/Util-linux#cite_note-simpleinit-19">[19]&lt;/a>&lt;/li>
&lt;li>ramsize (formerly a symlink to rdev)&lt;a href="https://en.wikipedia.org/wiki/Util-linux#cite_note-rdev-20">[20]&lt;/a>&lt;/li>
&lt;li>rdev&lt;a href="https://en.wikipedia.org/wiki/Util-linux#cite_note-rdev-20">[20]&lt;/a>&lt;/li>
&lt;li>reboot&lt;a href="https://en.wikipedia.org/wiki/Util-linux#cite_note-simpleinit-19">[19]&lt;/a>&lt;/li>
&lt;li>rootflags (formerly a symlink to rdev)&lt;a href="https://en.wikipedia.org/wiki/Util-linux#cite_note-rdev-20">[20]&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Shutdown_(command)">shutdown&lt;/a>&lt;a href="https://en.wikipedia.org/wiki/Util-linux#cite_note-simpleinit-19">[19]&lt;/a>&lt;/li>
&lt;li>simpleinit&lt;a href="https://en.wikipedia.org/wiki/Util-linux#cite_note-simpleinit-19">[19]&lt;/a>&lt;/li>
&lt;li>tailf&lt;a href="https://en.wikipedia.org/wiki/Util-linux#cite_note-tailf-21">[21]&lt;/a>&lt;/li>
&lt;li>vidmode (formerly a symlink to rdev)&lt;a href="https://en.wikipedia.org/wiki/Util-linux#cite_note-rdev-20">[20]&lt;/a>&lt;/li>
&lt;/ul></description></item><item><title>Docs: PowerShell</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/4.terminal-%E4%B8%8E-shell/windows_shell/powershell/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/4.terminal-%E4%B8%8E-shell/windows_shell/powershell/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://learn.microsoft.com/en-us/powershell">官方文档，PowerShell&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>PowerShell 是一种跨平台的任务自动化解决方案，由命令行 shell、脚本语言和配置管理框架组成。 PowerShell 在 Windows、Linux 和 macOS 上运行。&lt;/p>
&lt;p>PowerShell 的独特之处在于，它接受并返回 .NET 对象，而非纯文本。这个特点让 PowerShell 可以更轻松地在一个管道中串联不通的命令。&lt;/p>
&lt;blockquote>
&lt;p>这里面所说的对象，就是面向对象编程中常说的“对象”，就像 Go 语言中的 Struct 类似的东西，只不过是 .NET 语言中的对象。&lt;/p>
&lt;/blockquote>
&lt;p>这些对象在被接收后，再交给格式化函数处理，以人类可读的方式，输出出来。&lt;/p>
&lt;h2 id="powershell-命令">PowerShell 命令&lt;/h2>
&lt;p>PowerShell 中可以执行的命令分两类&lt;/p>
&lt;ul>
&lt;li>系统上的可执行命令。&lt;/li>
&lt;li>cmdlet&lt;/li>
&lt;/ul>
&lt;p>PowerShell 内置了一组 &lt;strong>cmdlet(全称 command-lets)&lt;/strong>，cmdlet 并不是一个独立的可执行文件，而是一种统称，cmdlet 被收集在 PowerShell 模块中，可以按需加载它们。可以用任何编译的 .NET 语言或 PowerShell 脚本语言来编写 cmdlet。&lt;/p>
&lt;p>cmdlet 中每个命令的名称都是由 &lt;strong>Verb-Noun(动词-名词)&lt;/strong> 组成，比如 Get-Command 命令用于获取在 CLI 中注册的所有 cmdlet。&lt;/p>
&lt;p>我们可以通过如下几个命令来搜索可用的 cmdlet&lt;/p>
&lt;ul>
&lt;li>&lt;code>Get-Verb&lt;/code> # 获取所有可用的动词&lt;/li>
&lt;li>&lt;code>Get-Command&lt;/code> # 此命令会检索计算机上安装的所有命令的列表。&lt;/li>
&lt;li>&lt;code>Get-Member&lt;/code> # 基于其他命令运行，可以获取 cmdlet 返回的对象信息，包括对象中的&lt;strong>属性、方法、等等&lt;/strong>&lt;/li>
&lt;li>&lt;code>Get-Help&lt;/code> # 以命令名称为参数调用此命令，将显示一个帮助页面，其中说明了命令的各个部分。&lt;/li>
&lt;/ul>
&lt;p>从本笔记的 &lt;a href="https://desistdaydream.github.io/docs/IT%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Y.Windows%20%E7%AE%A1%E7%90%86/Windows%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/_index.md">Windows 管理工具&lt;/a> 目录查找所有可用的命令，以及查看命令的用法&lt;/p>
&lt;p>我们可以通过 &lt;code>$psversiontable&lt;/code> 和 &lt;code>$host&lt;/code> 变量查看 PowerShell 版本信息&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-powershell" data-lang="powershell">&lt;span style="display:flex;">&lt;span>PS C:\&amp;gt; $psversiontable
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Name Value
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>---- -----
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>PSVersion &lt;span style="color:#ae81ff">7.3&lt;/span>.2
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>PSEdition Core
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>GitCommitId &lt;span style="color:#ae81ff">7.3&lt;/span>.2
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>OS Microsoft Windows &lt;span style="color:#ae81ff">10.0&lt;/span>.19045
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Platform Win32NT
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>PSCompatibleVersions {&lt;span style="color:#ae81ff">1.0&lt;/span>, &lt;span style="color:#ae81ff">2.0&lt;/span>, &lt;span style="color:#ae81ff">3.0&lt;/span>, &lt;span style="color:#ae81ff">4.0&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">…&lt;/span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>PSRemotingProtocolVersion &lt;span style="color:#ae81ff">2.3&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>SerializationVersion &lt;span style="color:#ae81ff">1.1&lt;/span>.0.1
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>WSManStackVersion &lt;span style="color:#ae81ff">3.0&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>PS C:\&amp;gt; $host
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Name &lt;span style="color:#960050;background-color:#1e0010">:&lt;/span> ConsoleHost
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Version &lt;span style="color:#960050;background-color:#1e0010">:&lt;/span> &lt;span style="color:#ae81ff">7.3&lt;/span>.2
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>InstanceId &lt;span style="color:#960050;background-color:#1e0010">:&lt;/span> 518ca4c4-e959-4d51-b3bb-cdcb3d5a1484
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>UI &lt;span style="color:#960050;background-color:#1e0010">:&lt;/span> System.Management.Automation.Internal.Host.InternalHostUserInterface
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>CurrentCulture &lt;span style="color:#960050;background-color:#1e0010">:&lt;/span> zh-CN
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>CurrentUICulture &lt;span style="color:#960050;background-color:#1e0010">:&lt;/span> zh-CN
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>PrivateData &lt;span style="color:#960050;background-color:#1e0010">:&lt;/span> Microsoft.PowerShell.ConsoleHost+ConsoleColorProxy
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>DebuggerEnabled &lt;span style="color:#960050;background-color:#1e0010">:&lt;/span> True
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>IsRunspacePushed &lt;span style="color:#960050;background-color:#1e0010">:&lt;/span> False
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Runspace &lt;span style="color:#960050;background-color:#1e0010">:&lt;/span> System.Management.Automation.Runspaces.LocalRunspace
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h1 id="item">ITEM&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://learn.microsoft.com/en-us/powershell/scripting/lang-spec/chapter-03#33-items">官方文档-PowerShell，脚本-基本概念-Items&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>PowerShell 中会抽象出一个 &lt;strong>Item(项)&lt;/strong> 的概念，Item 可以一个 &lt;strong>Alias(别名)&lt;/strong>、&lt;strong>Variable(变量)&lt;/strong>、&lt;strong>Function(函数)&lt;/strong>、&lt;strong>EnvironmentVariable(环境变量)&lt;/strong>、甚至可以是文件系统中的 &lt;strong>File(文件)&lt;/strong> 或者 &lt;strong>Directory(目录)&lt;/strong>。&lt;/p>
&lt;p>我们常用的 &lt;code>ls&lt;/code> 命令，在 PowerShell 中其实就是调用了 &lt;code>Get-ChildItem&lt;/code> 命令&lt;/p>
&lt;h1 id="porviders提供器-和-drives驱动器">Porviders(提供器) 和 Drives(驱动器)&lt;/h1>
&lt;p>在 PowerShell 中，Providers 和 Drives 是提供对不同数据源（如文件系统、注册表、Certificate 等）的访问的特定接口。Drives 则是实际代表特定数据源的容器，比如本地磁盘驱动器、注册表驱动器等。使用 PowerShell 可以对这些数据源进行管理和操作。&lt;/p></description></item><item><title>Docs: Prometheus</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/6.%E5%8F%AF%E8%A7%82%E6%B5%8B%E6%80%A7/%E7%9B%91%E6%8E%A7%E7%B3%BB%E7%BB%9F/prometheus/prometheus/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/6.%E5%8F%AF%E8%A7%82%E6%B5%8B%E6%80%A7/%E7%9B%91%E6%8E%A7%E7%B3%BB%E7%BB%9F/prometheus/prometheus/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://prometheus.io/docs/introduction/overview/">官方文档&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://yunlzheng.gitbook.io/prometheus-book/">yunlzheng 写的电子书&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://github.com/Tencent-Cloud-Native/tkedocs">GitHub 项目，Tencent-Cloud-Native/tkedocs&lt;/a>(我个人总结完绝大部分文档后发现的这个项目)&lt;/li>
&lt;li>Prometheus 纪录片
&lt;ul>
&lt;li>&lt;a href="https://www.youtube.com/watch?v=rT4fJNbfe14">YouTube&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.bilibili.com/video/BV1aW4y147GX">B 站翻译&lt;/a>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>Prometheus 是由 SoundCloud 开发的 开源监控报警系统 和 时间序列数据库(TSDB) 。&lt;strong>Time Series(时间序列)&lt;/strong> 概念详见：&lt;a href="https://www.yuque.com/go/doc/33147376">Prometheus 数据模型&lt;/a>。使用 Go 语言开发，是 Google BorgMon 监控系统的开源版本。&lt;/p>
&lt;blockquote>
&lt;p>题外话：Google 的 Borg 诞生了 kuberntes、Google 的 Borgmon 诞生了 Prometheus&lt;/p>
&lt;/blockquote>
&lt;p>2016 年由 Google 发起 Linux 基金会旗下的 Cloud Native Computing Foundation(云原生计算基金会), 将 Prometheus 纳入其下第二大开源项目。Prometheus 目前在开源社区相当活跃。&lt;/p>
&lt;h2 id="prometheus-架构概述">Prometheus 架构概述&lt;/h2>
&lt;p>Prometheus 的基本原理是通过 HTTP 协议周期性抓取被监控组件的状态，任意组件只要提供对应的 HTTP 接口就可以接入监控。不需要任何 SDK 或者其他的集成过程。这样做非常适合做虚拟化环境监控系统，比如 VM、Docker、Kubernetes 等。输出被监控组件信息的 HTTP 接口被叫做 exporter 。&lt;/p>
&lt;p>下面这张图说明了 Prometheus 的整体架构，以及生态中的一些组件作用：
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/usvgfl/1616041189523-5ca97287-5886-4ab9-a4f8-6c249117e314.jpeg" alt="">
Prometheus 生态圈中包含了多个组件，其中许多组件是可选的，多数 Prometheus 组件是 Go 语言写的，使得这些组件很容易编译和部署：&lt;/p>
&lt;ul>
&lt;li>&lt;strong>Prometheus Server&lt;/strong> # 主要负责数据抓取和存储，提供 PromQL 查询语言的支持。用于收集和存储时间序列数据。
&lt;ul>
&lt;li>定期从配置好的 Jobs 中&lt;strong>拉取 &lt;strong>Exporters 采集的&lt;/strong> Metrics(指标)&lt;/strong> 数据；或者&lt;strong>接收&lt;/strong>来自 &lt;strong>Pushgateway&lt;/strong>(类似 zabbix 的 proxy) 发过来的 Metrics；或者从其他的 Prometheus Server 中拉取 Metrics。&lt;/li>
&lt;li>Prometheus Server 在本地存储收集到的 Metrics，并通过一定 &lt;strong>RecordingRule(记录规则)&lt;/strong> 进行清理和整理数据，并把得到的结果存储到新的时间序列中。还会运行已定义好的 &lt;strong>AlertingRule(告警规则)&lt;/strong>，记录新的时间序列或者向 Alertmanager 推送警报。&lt;/li>
&lt;li>由于 Metrics 都是通过 HTTP 或者 HTTPS 协议提供的，所以 Prometheus Server 在抓取 Metrics 时，也就是发起一次 HTTP 或者 HTTPS 的 GET 请求&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>Instrumenting&lt;/strong> # 为 Prometheus 提供指标的工具或代码
&lt;ul>
&lt;li>**Exporters **# 导出器。Exporter 是 Prometheus 的一类数据采集组件的总称。它负责从设备上搜集数据，并将其转化为 Prometheus 支持的格式(一般情况下 exporter 是安装在需要采集数据的设备上的程序，并监听某个 port。但是如果想要收集 snmp 信息的话，则有专门的 snmp-exporter 安装在某个地方；再收集指定设备的 snmp 信息，然后 prometheus 再找 snmp-exporter 去收集数据)。与传统的数据采集组件不同的是，它并不向中央服务器发送数据，而是等待中央服务器主动前来抓取。Prometheus 提供多种类型的 Exporter 用于采集各种不同服务的运行状态。目前支持的有数据库、硬件、消息中间件、存储系统、HTTP 服务器、JMX 等。&lt;/li>
&lt;li>&lt;strong>Client Library&lt;/strong> # 客户端库(客户端 SDK)，官方提供的客户端类库有 go、java、scala、python、ruby，其他还有很多第三方开发的类库，支持 nodejs、php、erlang 等。为需要监控的服务生成相应的 Metrics 并暴露给 Prometheus server。当 Prometheus server 来 pull 时，直接返回实时状态的 Metrics。&lt;/li>
&lt;li>**Push Gateway **# 支持 Client 主动推送 Metrics 到 PushGateway，而 PrometheusServer 只是定时去 Gateway 上抓取数据。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>Alertmanager&lt;/strong> # 警告管理器，用来进行报警。从 Prometheus server 端接收到 alerts 后，会进行去除重复数据，分组，并路由到对收的接受方式，发出报警。常见的接收方式有：电子邮件，pagerduty，OpsGenie, webhook 等。&lt;/li>
&lt;li>&lt;strong>prometheus_cli&lt;/strong> # 命令行工具。&lt;/li>
&lt;li>&lt;strong>其他辅助性工具&lt;/strong>
&lt;ul>
&lt;li>Prometheus 通过 PromQL 和其他 API 可视化地展示收集的数据。Prometheus 支持很多方式的图表可视化，例如 Grafana、自带的 PrometheusDashboard 以及自身提供的模版引擎等等。Prometheus 还提供 HTTP API 的查询方式，自定义所需要的输出。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>Prometheus 适用的场景&lt;/p>
&lt;ul>
&lt;li>Prometheus 在记录纯数字时间序列方面表现非常好。它既适用于面向服务器等硬件指标的监控，也适用于高动态的面向服务架构的监控。对于现在流行的微服务，Prometheus 的多维度数据收集和数据筛选查询语言也是非常的强大。Prometheus 是为服务的可靠性而设计的，当服务出现故障时，它可以使你快速定位和诊断问题。它的搭建过程对硬件和服务没有很强的依赖关系。&lt;/li>
&lt;/ul>
&lt;p>Prometheus 不适用的场景&lt;/p>
&lt;ul>
&lt;li>Prometheus 它的价值在于可靠性，甚至在很恶劣的环境下，你都可以随时访问它和查看系统服务各种指标的统计信息。 如果你对统计数据需要 100%的精确，它并不适用，例如：它不适用于实时计费系统。&lt;/li>
&lt;/ul>
&lt;h3 id="总结prometheus-从-instrumenting-那里抓取监控数据储存完了哈哈哈哈哈">总结：prometheus 从 Instrumenting 那里抓取监控数据，储存。完了~~~~哈哈哈哈哈&lt;/h3>
&lt;h2 id="instrumenting检测仪表装置-的实现方式">Instrumenting(检测仪表装置) 的实现方式&lt;/h2>
&lt;p>Prometheus 可以通过 3 种方式从目标上 Scrape(抓取) 指标：&lt;/p>
&lt;ul>
&lt;li>&lt;strong>Exporters&lt;/strong> # 外部抓取程序&lt;/li>
&lt;li>&lt;strong>Instrumentation&lt;/strong> # 可以理解为内嵌的 Exporter，比如 Prometheus Server 的 9090 端口的 &lt;code>/metrics&lt;/code> 就属于此类。
&lt;ul>
&lt;li>说白了，就是目标自己就可以吐出符合 Prometheus 格式的指标数据&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>Pushgateway&lt;/strong> # 针对需要推送指标的应用&lt;/li>
&lt;/ul>
&lt;h2 id="label-与-relabeling">Label 与 Relabeling&lt;/h2>
&lt;p>详见 &lt;a href="https://desistdaydream.github.io/docs/IT%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/6.%E5%8F%AF%E8%A7%82%E6%B5%8B%E6%80%A7/%E7%9B%91%E6%8E%A7%E7%B3%BB%E7%BB%9F/Prometheus/Target(%E7%9B%AE%E6%A0%87)%20%E4%B8%8E%20Relabeling(%E9%87%8D%E6%96%B0%E6%A0%87%E8%AE%B0).md">Label 与 Relabeling 章节&lt;/a>&lt;/p>
&lt;h2 id="instrumenting-的安装与使用">Instrumenting 的安装与使用&lt;/h2>
&lt;p>详见 &lt;a href="https://desistdaydream.github.io/docs/IT%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/6.%E5%8F%AF%E8%A7%82%E6%B5%8B%E6%80%A7/%E7%9B%91%E6%8E%A7%E7%B3%BB%E7%BB%9F/Instrumenting/Instrumenting.md">Instrumenting 章节&lt;/a>&lt;/p>
&lt;h1 id="prometheus-部署">Prometheus 部署&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://prometheus.io/docs/prometheus/latest/installation/">官方文档，Prometheus-安装&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>官方系统版本可在这里下载：&lt;a href="https://prometheus.io/download/">https://prometheus.io/download/&lt;/a>&lt;/p>
&lt;p>Prometheus 官方有多种部署方案，比如：Docker 容器、Ansible、Chef、Puppet、Saltstack 等。Prometheus 用 Golang 实现，因此具有天然可移植性(支持 Linux、Windows、macOS 和 Freebsd)。&lt;/p>
&lt;h2 id="二进制文件运行-prometheus-server">二进制文件运行 Prometheus Server&lt;/h2>
&lt;ul>
&lt;li>&lt;a href="https://github.com/prometheus/prometheus/releases/">https://github.com/prometheus/prometheus/releases/&lt;/a> 在该页面下直接下载 prometheus 的进制文件 &lt;code>prometheus-版本号.linux-amd64.tar.gz&lt;/code> 并解压，其中包含 prometheus 的主程序还有 yaml 格式的配置文件以及运行所需要的依赖库&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>export PromVersion&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;2.25.1&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>wget https://github.com/prometheus/prometheus/releases/download/v&lt;span style="color:#e6db74">${&lt;/span>PromVersion&lt;span style="color:#e6db74">}&lt;/span>/prometheus-&lt;span style="color:#e6db74">${&lt;/span>PromVersion&lt;span style="color:#e6db74">}&lt;/span>.linux-amd64.tar.gz
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ul>
&lt;li>创建/usr/local/prometheus 目录，并将解压的所有文件移动到该目录下&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>mkdir /usr/local/prometheus
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>tar -zxvf prometheus-&lt;span style="color:#e6db74">${&lt;/span>PromVersion&lt;span style="color:#e6db74">}&lt;/span>.linux-amd64.tar.gz -C /usr/local/prometheus/ --strip-components&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ul>
&lt;li>创建 Systemd 服务,在 ExecStart 字段上，使用运行时标志来对 prometheus 进行基本运行配置，标志说明详见下文&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>cat &amp;gt; /usr/lib/systemd/system/prometheus.service &lt;span style="color:#e6db74">&amp;lt;&amp;lt; EOF
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">[Unit]
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">Description=prometheus
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">After=network.target
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">[Service]
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">Type=simple
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">User=root
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">ExecStart=/usr/local/prometheus/prometheus \
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74"> --web.console.templates=/usr/local/prometheus/consoles \
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74"> --web.console.libraries=/usr/local/prometheus/console_libraries \
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74"> --config.file=/usr/local/prometheus/prometheus.yml \
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74"> --storage.tsdb.path=/var/lib/prometheusData \
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74"> --web.enable-lifecycle
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">Restart=on-failure
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">[Install]
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">WantedBy=multi-user.target
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">EOF&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ul>
&lt;li>启动 Prometheus&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>systemctl start prometheus
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="容器运行-prometheus">容器运行 prometheus&lt;/h2>
&lt;p>获取配置文件.&lt;/p>
&lt;blockquote>
&lt;p>也可以不获取配置文件，去掉启动时的 -v /etc/monitoring/prometheus:/etc/prometheus/config_out 与 &amp;ndash;config.file=/etc/prometheus/config_out/prometheus.yml 这两行即可
获取配置文件主要是为了让后续测试可以更方便得修改文件&lt;/p>
&lt;/blockquote>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>mkdir -p /opt/monitoring/prometheus
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>docker run -d --name prometheus --rm prom/prometheus
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>docker cp prometheus:/etc/prometheus /opt/monitoring/prometheus
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>mv /opt/monitoring/prometheus/prometheus /opt/monitoring/prometheus/config
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>docker stop prometheus
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>运行 Prometheus Server&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>docker run -d --name prometheus --restart&lt;span style="color:#f92672">=&lt;/span>always &lt;span style="color:#ae81ff">\
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">&lt;/span> --network host &lt;span style="color:#ae81ff">\
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">&lt;/span> -v /etc/localtime:/etc/localtime &lt;span style="color:#ae81ff">\
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">&lt;/span> -v /opt/monitoring/prometheus/config:/etc/prometheus/config_out &lt;span style="color:#ae81ff">\
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">&lt;/span> prom/prometheus &lt;span style="color:#ae81ff">\
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">&lt;/span> --config.file&lt;span style="color:#f92672">=&lt;/span>/etc/prometheus/config_out/prometheus.yml
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h1 id="prometheus-关联文件与配置">Prometheus 关联文件与配置&lt;/h1>
&lt;p>**/etc/prometheus/prometheus.yml **# Prometheus Server 运行时的配置文件。可通过 &amp;ndash;config.file 标志指定其他文件。
&lt;strong>/etc/prometheus/rule.yml&lt;/strong> # Prometheus Rule 配置文件。该文件默认不存在，需手动创建。可以在 prometheus.yml 配置中指定其他文件。&lt;/p>
&lt;h2 id="prometheus-配置示例">Prometheus 配置示例&lt;/h2>
&lt;h3 id="默认配置文件">默认配置文件&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-yaml" data-lang="yaml">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># 全局配置&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">global&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">scrape_interval&lt;/span>: &lt;span style="color:#ae81ff">15s&lt;/span> &lt;span style="color:#75715e"># 默认抓取间隔, 15秒向目标抓取一次数据。&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">evaluation_interval&lt;/span>: &lt;span style="color:#ae81ff">15s&lt;/span> &lt;span style="color:#75715e"># 每15秒评估一次规则，默认为1分钟。&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e"># scrape_timeout is set to the global default (10s).&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e"># 告警报警配置，设置prometheus主程序对接alertmanager程序的&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">alerting&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">alertmanagers&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#f92672">static_configs&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#f92672">targets&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e"># - alertmanagerIP:9093&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># 指定要使用的规则文件位置，并加载一次，根据全局配置中的 evaluation_interval 来定期评估&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># 从所有匹配到的文件中读取配置内容。可以使用正则表达式匹配多个符合的文件。Prometheus支持两种规则&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># 其一是记录规则(recording rules)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># 其二是告警规则(alerting rules)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">rule_files&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e"># - &amp;#34;first.rules&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e"># - &amp;#34;second.rules&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># 抓取配置，prometheus抓取exporter上的数据时的配置，一个job就是一个抓取工作，其中可以包括1个或者多个目标&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># 目标指的是可以被 prometheus 采集的服务器、服务等。&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># 默认配置里，Prometheus Server 会抓取本地9090端口上数据。该端口上的 exporter 就是 PrometheusServer 自己的 exporter&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">scrape_configs&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># job_name 指定要 scrape(抓取) 的 job(工作) 名称，名称必须是唯一的&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># 并且在这个配置内的时间序例，每一条都会自动添加上这个{job_name:&amp;#34;prometheus&amp;#34;}的标签。&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>- &lt;span style="color:#f92672">job_name&lt;/span>: &lt;span style="color:#e6db74">&amp;#39;prometheus&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e"># 设定该job的抓取时间间隔&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">scrape_interval&lt;/span>: &lt;span style="color:#ae81ff">5s&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">static_configs&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#f92672">targets&lt;/span>: [&lt;span style="color:#e6db74">&amp;#39;localhost:9090&amp;#39;&lt;/span>]
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="具有-node_exporter-的配置简单文件">具有 node_exporter 的配置简单文件&lt;/h3>
&lt;p>抓取部署了 node_exporter 设备的监控数据的方式及 prometheus.yml 配置文件说明
prometheus 会从 Node Exporter 所在服务器的 http://IP:9100/metrics 这个地址里的内容来获取该设备的监控数据
所以需要给 prometheus 创建一个工作(i.e.job)。一个 job 就是一个抓取监控数据的工作，其中包括要抓取目标的 ip 和 port，还可以设置标签进行分类，还能进行抓取筛选等等，下面提供一个基本的配置
修改 prometheus.yml，加入下面的监控目标，以便让 prometheus 监控这个已经安装了 node_exporter 的设备&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-yaml" data-lang="yaml">&lt;span style="display:flex;">&lt;span>- &lt;span style="color:#f92672">job_name&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;linux&amp;#34;&lt;/span> &lt;span style="color:#75715e">#新增一个job，名为linux&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">static_configs&lt;/span>: &lt;span style="color:#75715e"># 使用静态配置&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#f92672">targets&lt;/span>: [&lt;span style="color:#e6db74">&amp;#34;10.10.100.101:9100&amp;#34;&lt;/span>] &lt;span style="color:#75715e">#添加一个要抓取数据的目标，指定IP与PORT 。node_exporter所安装的设备&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">labels&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">instance&lt;/span>: &lt;span style="color:#ae81ff">lchTest&lt;/span> &lt;span style="color:#75715e">#给该目标添加一个标签&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>现在，prometheus.yml 配置文件中中一共定义了两个监控：一个是默认自带监控 prometheus 自身服务，另一个是我们新增的 job，这个 job 就是要抓取目标是 10.10.100.101 这台服务器上的监控数据&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-yaml" data-lang="yaml">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">scrape_configs&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#f92672">job_name&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;prometheus&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">static_configs&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#f92672">targets&lt;/span>: [&lt;span style="color:#e6db74">&amp;#34;localhost:9090&amp;#34;&lt;/span>]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#f92672">job_name&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;linux&amp;#34;&lt;/span> &lt;span style="color:#75715e">#指定job名称&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">static_configs&lt;/span>: &lt;span style="color:#75715e">#设定静态配置&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#f92672">targets&lt;/span>: [&lt;span style="color:#e6db74">&amp;#34;10.10.100.101:9100&amp;#34;&lt;/span>] &lt;span style="color:#75715e">#指定node_exporter所安装设备的ip:port&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">labels&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">instance&lt;/span>: &lt;span style="color:#ae81ff">lchTest&lt;/span> &lt;span style="color:#75715e">#给该target一个label来分类，常用于在查询语句中的筛选条件&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>访问 Prometheus Web，在 Status-&amp;gt;Targets 页面下，我们可以看到我们配置的两个 Target，它们的 State 为 UP
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/usvgfl/1616041189541-1dfdddd7-ee74-4f32-8df6-8821cf415a14.jpeg" alt="">&lt;/p>
&lt;h1 id="prometheus-的基本使用方式">Prometheus 的基本使用方式&lt;/h1>
&lt;p>Prometheus 运行后默认会监听在 9090 端口，可以通过访问 9090 端口来打开 Prometheus 的 web 界面
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/usvgfl/1616041189523-861a164c-3f79-42af-bd88-44c4baf2e349.jpeg" alt="">
Prometheus 本身也是自带 exporter 的,我们通过请求 http://ip:9090/metrics 可以查看从 exporter 中能具体抓到哪些 metrics。
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/usvgfl/1616041189563-4125f137-160f-48dd-b4f6-dfd6af94aed0.jpeg" alt="">&lt;/p>
&lt;p>这里以 Prometheus 本身数据为例，简单演示下在 Web 中查询指定表达式及图形化显示查询结果。
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/usvgfl/1616041189526-ee545ef0-965e-499c-b80f-b6cdaf05c974.jpeg" alt="">
[&lt;/p>
&lt;h1 id="instrumentingmd">](Instrumenting.md)&lt;/h1></description></item><item><title>Docs: 多媒体处理工具</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/11_%E5%A4%9A%E5%AA%92%E4%BD%93/%E5%A4%9A%E5%AA%92%E4%BD%93%E5%A4%84%E7%90%86%E5%B7%A5%E5%85%B7/%E5%A4%9A%E5%AA%92%E4%BD%93%E5%A4%84%E7%90%86%E5%B7%A5%E5%85%B7/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/11_%E5%A4%9A%E5%AA%92%E4%BD%93/%E5%A4%9A%E5%AA%92%E4%BD%93%E5%A4%84%E7%90%86%E5%B7%A5%E5%85%B7/%E5%A4%9A%E5%AA%92%E4%BD%93%E5%A4%84%E7%90%86%E5%B7%A5%E5%85%B7/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://zhuanlan.zhihu.com/p/138863913">知乎，视频录制、视频剪辑、字幕制作&amp;hellip;&amp;hellip;当一名 UP 主需要哪些软件&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>视频录制&lt;/p>
&lt;ul>
&lt;li>OBS Studio&lt;/li>
&lt;/ul>
&lt;p>视频剪辑&lt;/p>
&lt;ul>
&lt;li>Premiere&lt;/li>
&lt;li>Shotcut&lt;/li>
&lt;li>必剪 # B 站的&lt;/li>
&lt;/ul>
&lt;p>字幕制作&lt;/p>
&lt;ul>
&lt;li>听见字幕&lt;/li>
&lt;/ul>
&lt;h1 id="obs-studio">OBS Studio&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://github.com/obsproject/obs-studio">GitHub 项目，obsproject/obs-studio&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://obsproject.com/">官网&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>&lt;strong>Open Broadcaster Software(开放广播软件，简称 OBS)&lt;/strong> 是一款用于视频录制和直播的免费和开源软件&lt;/p>
&lt;h1 id="shotcut">Shotcut&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://github.com/mltframework/shotcut">GitHub 项目，mltframework/shotcut&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://shotcut.org/">官网&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>导出视频：https://jingyan.baidu.com/article/86f4a73e2716ee77d752695a.html&lt;/p>
&lt;h1 id="音频处理">音频处理&lt;/h1>
&lt;h2 id="buzz">Buzz&lt;/h2>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://github.com/chidiwilliams/buzz">GitHub 项目，chidiwilliams/buzz&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.bilibili.com/video/BV1sG411N7RS">B 站，真正的最强字幕神器，离线语音转文字，一键搞定！&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>Buzz 可以在我们的个人计算机上离线转录和翻译音频。由 OpenAI 的 Whisper 提供支持。&lt;/p>
&lt;h1 id="图片处理">图片处理&lt;/h1>
&lt;h2 id="photopea">Photopea&lt;/h2>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://github.com/photopea/photopea">GitHub 项目，photopea/photopea&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.photopea.com/">官网&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>在线图片编辑工具&lt;/p>
&lt;h2 id="photodemon">PhotoDemon&lt;/h2>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://github.com/tannerhelland/PhotoDemon">GitHub 项目，tannerhelland/PhotoDemon&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://photodemon.org/">官网&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>小巧玲珑的图片编辑工具&lt;/p>
&lt;p>图片处理工具&lt;/p>
&lt;h2 id="其他">其他&lt;/h2>
&lt;p>&lt;a href="https://github.com/Sanster/lama-cleaner">Lama Cleaner&lt;/a> # 基于 SOTA AI 模型构建的开源图片处理工具&lt;/p></description></item><item><title>Docs: 解谜计算机科学</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/2.%E7%BC%96%E7%A8%8B/%E8%A7%A3%E8%B0%9C%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E8%A7%A3%E8%B0%9C%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/2.%E7%BC%96%E7%A8%8B/%E8%A7%A3%E8%B0%9C%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E8%A7%A3%E8%B0%9C%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="http://www.yinwang.org/blog-cn/2018/04/13/computer-science">王垠博客，解谜计算机科学&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Category:Computer_science">Wiki 分类，Computer science(计算机科学)&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Category:Computer_programming">Wiki 分类，Computer programming(计算机编程)&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Category:Programming_language_concepts">Wiki 分类，Programming language concepts(编程语言概念)&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Category:Programming_constructs">Wiki 分类，Programming constructs(编程结构)&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Category:Programming_languages">Wiki 分类，Programming languages(编程语言)&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Category:Programming_paradigms">Wiki 分类，Programming paradigms(编程范式)&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Identifier_(computer_languages)">Wiki,Identifier(标识符)&lt;/a>
&lt;ul>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Symbol">Wiki,Symbol(符号)&lt;/a>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Data_type">Wiki,DataType&lt;/a>(数据类型)&lt;/li>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Variable_(computer_science)">Wiki,Variables&lt;/a>(变量)&lt;/li>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Assignment_(computer_science)">Wiki,Assignment&lt;/a>(赋值)&lt;/li>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Declaration_(computer_programming)">Wiki,Declaration(声明) 与 Definition(定义)&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>要掌握一个学科的精髓，不能从细枝末节开始。人脑的能力很大程度上受限于信念。一个人不相信自己的时候，他就做不到本来可能的事。信心是很重要的，信心却容易被挫败。如果只见树木不见森林，人会失去信心，以为要到猴年马月才能掌握一个学科。&lt;/p>
&lt;p>所以我们不从 “树木” 开始，而是引导读者一起来探索这背后的“森林”，把计算机科学最根本的概念用浅显的例子解释，让读者领会到它们的本质。把这些概念稍作发展，你就得到逐渐完整的把握。你一开头就掌握着整个学科，而且一直掌握着它，只不过增添更多细节而已。这就像画画，先勾勒出轮廓，一遍遍的增加细节，日臻完善，却不失去对大局的把握。&lt;/p>
&lt;p>一般计算机专业的学生学了很多课程，可是直到毕业都没能回答一个基础问题：什么是计算？这一章会引导你去发现这个问题的答案。不要小看这基础的问题，它经常是解决现实问题的重要线索。世界上有太多不理解它的人，他们走了很多的弯路，掉进很多的坑，制造出过度复杂或者有漏洞的理论和技术。&lt;/p>
&lt;p>接下来，我们就来理解几个关键的概念，由此接触到计算的本质。&lt;/p>
&lt;h2 id="手指算术">手指算术&lt;/h2>
&lt;p>每个人都做过计算，只是大部分人都没有理解自己在做什么。回想一下幼儿园（大概四岁）的时候，妈妈问你：“帮我算一下，4+3 等于几？” 你掰了一会手指，回答：7。当你掰手指的时候，你自己就是一台简单的计算机。&lt;/p>
&lt;p>不要小看了这手指算术，它蕴含着深刻的原理。计算机科学植根于这类非常简单的过程，而不是复杂的高等数学。&lt;/p>
&lt;p>现在我们来回忆一下这个过程。这里应该有一段动画，但现阶段还没有。请你对每一步发挥一下想象力，增加点 “画面感”。&lt;/p>
&lt;ol>
&lt;li>当妈妈问你 “4+3 等于几” 的时候，她是一个程序员，你是一台计算机。计算机得到程序员的输入：4，+，3。&lt;/li>
&lt;li>听到妈妈的问题之后，你拿出两只手，左手伸出四个指头，右手伸出三个指头。&lt;/li>
&lt;li>接着你开始自己的计算过程。一根根地数那些竖起来的手指，每数一根你就把它弯下去，表示它已经被数过了。你念道：“1，2，3，4，5，6，7。”&lt;/li>
&lt;li>现在已经没有手指伸着，所以你把最后数到的那个数作为答案：7！整个计算过程就结束了。&lt;/li>
&lt;/ol>
&lt;h2 id="identifier标识符-和-model模型">Identifier(标识符) 和 Model(模型)&lt;/h2>
&lt;p>这里的幼儿园手指算术包含着深刻的哲学问题，现在我们来初步体会一下这个问题。&lt;/p>
&lt;p>当妈妈说 “帮我算 4+3” 的时候，4，+，3，三个字符传到你耳朵里，它们都是 &lt;strong>Identifier(标识符)&lt;/strong>，有的时候也称为 &lt;strong>symbol(符号)&lt;/strong>。符号是 “表面” 的东西：光是盯着 “4” 和“3”这两个阿拉伯数字的曲线，一个像旗子，一个像耳朵，你是不能做什么的。你需要先用脑子把它们转换成对应的“模型”（model）。这就是为什么你伸出两只手，一只手表示 4，另一只表示 3。&lt;/p>
&lt;p>这两只手的手势是 “可操作” 的。比如，你把左手再多弯曲一个手指，它就变成 “3”。你再伸开一根手指，它就变成“5”。所以手指是一个相当好的机械模型，它是可以动，可操作的。把符号“4” 和“3”转换成手指模型之后，你就可以开始计算了。&lt;/p>
&lt;p>你怎么知道 “4” 和“3”对应什么样的手指模型呢？因为妈妈以前教过你。十根手指，对应着 1 到 10 十个数。这就是为什么人都用十进制数做算术。&lt;/p>
&lt;p>我们现在没必要深究这个问题。我只是提示你，分清 “符号” 和“模型”是重要的。&lt;/p>
&lt;h2 id="计算图">计算图&lt;/h2>
&lt;p>在计算机领域，我们经常用一些抽象的图示来表达计算的过程，这样就能直观地看到信息的流动和转换。这种图示看起来是一些形状用箭头连接起来。我在这里把它叫做 “计算图”。&lt;/p>
&lt;p>对于以上的手指算术 &lt;code>4 + 3&lt;/code>，我们可以用下图来表示它：&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/85e3436b-9762-45b3-b0bb-38c1f87e416d/adder.png" alt="">&lt;/p>
&lt;p>图中的箭头表示信息的流动方向。说到 “流动”，你可以想象一下水的流动。首先我们看到数字 4 和 3 流进了一个圆圈，圆圈里有一个“+” 号。这个圆圈就是你，一个会做手指加法的小孩。妈妈给你两个数 4 和 3，你现在把它们加起来，得到 7 作为结果。&lt;/p>
&lt;p>注意圆圈的输入和输出方向是由箭头决定的，我们可以根据需要调整那些箭头的位置，只要箭头的连接关系和方向不变就行。它们不一定都是从左到右，也可能从右到左或者从上到下，但 “出入关系” 都一样：4 和 3 进去，结果 7 出来。比如它还可以是这样：&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/85e3436b-9762-45b3-b0bb-38c1f87e416d/adder-topdown.png" alt="">&lt;/p>
&lt;p>我们用带加号的圆圈表示一个 “加法器”。顾名思义，加法器可以帮我们完成加法。在上个例子里，你就是一个加法器。我们也可以用其他装置作为加法器，比如一堆石头，一个算盘，某种电子线路…… 只要它能做加法就行。&lt;/p>
&lt;p>具体要怎么做加法，就像你具体如何掰手指，很多时候我们是不关心的，我们只需要知道这个东西能做加法就行。圆圈把具体的加法操作给 “抽象化” 了，这个蓝色的圆圈可以代表很多种东西。抽象（abstraction）是计算机科学至关重要的思维方法，它帮助我们进行高层面的思考，而不为细节所累。&lt;/p>
&lt;h2 id="expression表达式">Expression(表达式)&lt;/h2>
&lt;p>计算机科学当然不止 4 + 3 这么简单，但它的基本元素确实是如此简单。我们可以创造出很复杂的系统，然而归根结底，它们只是在按某种顺序计算像 4 + 3 这样的东西。&lt;/p>
&lt;p>4 + 3 是一个很简单的表达式（expression）。你也许没听说过 “表达式” 这个词，但我们先不去定义它。我们先来看一个稍微复杂一些的表达式：&lt;/p>
&lt;p>这个表达式比 &lt;code>4 + 3&lt;/code> 多了一个运算，我们把它叫做 “复合表达式”。这个表达式也可以用计算图来表示：&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/85e3436b-9762-45b3-b0bb-38c1f87e416d/add-mult.png" alt="">&lt;/p>
&lt;p>你知道它为什么是这个样子吗？它表示的意思是，先计算 &lt;code>4 + 3&lt;/code>，然后把结果（7）传送到一个 “乘法器”，跟 2 相乘，得到最后的结果。那正好就是 &lt;code>2 * (4 + 3)&lt;/code> 这个表达式的含义，它的结果应该是 14。&lt;/p>
&lt;p>为什么要先计算 &lt;code>4 + 3&lt;/code> 呢？因为当我们看到乘法器 &lt;code>2 * ...&lt;/code> 的时候，其中一个输入（2）是已知的，而另外一个输入必须通过加法器的输出得到。加法器的结果是由 4 和 3 相加得到的，所以我们必须先计算 &lt;code>4 + 3&lt;/code>，然后才能与 2 相乘。&lt;/p>
&lt;p>小学的时候，你也许学过：“括号内的内容要先计算”。其实括号只是 “符号层” 的东西，它并不存在于计算图里面。我这里讲的“计算图”，其实才是本质的东西。数学的括号一类的东西，都只是表象，它们是符号或者叫“语法”。从某种意义上讲，计算图才是表达式的本质或者“模型”，而“2 * (4 + 3)” 这串符号，只是对计算图的一种表示或者 “编码”（coding）。&lt;/p>
&lt;p>这里我们再次体会到了 “符号” 和“模型”的差别。符号是对模型的 “表示” 或者“编码”。我们必须从符号得到模型，才能进行操作。这种从符号到模型的转换过程，在计算机科学里叫做“语法分析”（parsing）。我们会在后面的章节理解这个过程。&lt;/p>
&lt;p>我们现在来给表达式做一个初步的定义。这并不是完整的定义，但你应该试着理解这种定义的方式。稍后我们会逐渐补充这个定义，逐渐完善。&lt;/p>
&lt;p>定义（表达式）：&lt;strong>表达式&lt;/strong>可以是如下几种东西。&lt;/p>
&lt;ol>
&lt;li>数字是一个表达式。比如 1，2，4，15，……&lt;/li>
&lt;li>表达式 + 表达式。两个表达式相加，也是表达式。&lt;/li>
&lt;li>表达式 - 表达式。两个表达式相减，也是表达式。&lt;/li>
&lt;li>表达式 * 表达式。两个表达式相乘，也是表达式。&lt;/li>
&lt;li>表达式 / 表达式。两个表达式相除，也是表达式。&lt;/li>
&lt;/ol>
&lt;p>注意，由于我们之前讲过的符号和模型的差别，为了完全忠于我们的本质认识，这里的 “表达式 + 表达式” 虽然看起来是一串符号，它必须被想象成它所对应的模型。当你看到 “表达式” 的时候，你的脑子里应该浮现出它对应的计算图，而不是一串符号。这个计算图的画面大概是这个样子，其中左边的大方框里可以是任意两个表达式。&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/85e3436b-9762-45b3-b0bb-38c1f87e416d/expression-graph.png" alt="">&lt;/p>
&lt;p>是不是感觉这个定义有点奇怪？因为在 “表达式” 的定义里，我们用到了 “表达式” 自己。这种定义叫做“递归定义”。所谓&lt;strong>递归&lt;/strong>（recursion），就是在一个东西的定义里引用这个东西自己。看上去很奇怪，好像绕回去了一样。递归是一个重要的概念，我们会在将来深入理解它。&lt;/p>
&lt;p>现在我们可以来验证一下，根据我们的定义，&lt;code>2 * (4 + 3)&lt;/code> 确实是一个表达式：&lt;/p>
&lt;ul>
&lt;li>首先根据第一种形式，我们知道 4 是表达式，因为它是一个数字。3 也是表达式，因为它是一个数字。&lt;/li>
&lt;li>所以 &lt;code>4 + 3&lt;/code> 是表达式，因为 &lt;code>+&lt;/code> 的左右都是表达式，它满足表达式定义的第二种形式。&lt;/li>
&lt;li>所以 &lt;code>2 * (4 + 3)&lt;/code> 是表达式，因为 &lt;code>*&lt;/code> 的左右都是表达式，它满足表达式定义的第四种形式。&lt;/li>
&lt;/ul>
&lt;h2 id="parallel-computing并行计算">Parallel Computing(并行计算)&lt;/h2>
&lt;p>考虑这样一个表达式：&lt;/p>
&lt;pre>&lt;code>(4 + 3) * (1 + 2)
&lt;/code>&lt;/pre>
&lt;p>它对应一个什么样的计算图呢？大概是这样：
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/85e3436b-9762-45b3-b0bb-38c1f87e416d/parallel.png" alt="">
如果妈妈只有你一个小孩，你应该如何用手指算出它的结果呢？你大概有两种办法。&lt;/p>
&lt;p>第一种办法：先算出 4+3，结果是 7。然后算出 1+2，结果是 3。然后算 7*3，结果是 21。&lt;/p>
&lt;p>第二种办法：先算出 1+2，结果是 3。然后算出 4+3，结果是 7。然后算 7*3，结果是 21。&lt;/p>
&lt;p>注意到没有，你要么先算 4+3，要么先算 1+2，你不能同时算 4+3 和 1+2。为什么呢？因为你只有两只手，所以算 4+3 的时候你就没法算 1+2，反之也是这样。总之，你妈妈只有你一个加法器，所以一次只能做一个加法。&lt;/p>
&lt;p>现在假设你还有一个妹妹，她跟你差不多年纪，她也会手指算术。妈妈现在就多了一些办法来计算这个表达式。她可以这样做：让你算 4+3，不等你算完，马上让妹妹算 1+2。等到你们的结果（7 和 3）都出来之后，让你或者妹妹算 7*3。&lt;/p>
&lt;p>发现没有，在某一段时间之内，你和妹妹_同时_在做加法计算。这种时间上重叠的计算，叫做&lt;strong>并行计算&lt;/strong>（parallel computing）。&lt;/p>
&lt;p>你和妹妹同时计算，得到结果的速度可能会比你一个人算更快。如果你妈妈还有其它几个孩子，计算复杂的式子就可能快很多，这就是并行计算潜在的好处。所谓 “潜在” 的意思是，这种好处不一定会实现。比如，如果你的妹妹做手指算数的速度比你慢很多，你做完了 4+3，只好等着她慢慢的算 1+2。这也许比你自己依次算 4+3 和 1+2 还要慢。&lt;/p>
&lt;p>即使妹妹做算术跟你一样快，这里还有个问题。你和妹妹算出结果 7 和 3 之后，得把结果传递给下一个计算 7*3 的那个人（也许是你，也许是你妹妹）。这种 “通信” 会带来时间的延迟，叫做“通信开销”。如果你们其中一个说话慢，这比起一个人来做计算可能还要慢。&lt;/p>
&lt;p>如何根据计算单元能力的不同和通信开销的差异，来最大化计算的效率，降低需要的时间，就成为了并行计算领域研究的内容。并行计算虽然看起来是一个 “博大精深” 的领域，可是你如果理解了我这里说的那点东西，就很容易理解其余的内容。&lt;/p>
&lt;h2 id="variable变量-和-assignment赋值">Variable(变量) 和 Assignment(赋值)&lt;/h2>
&lt;p>变量是与关联的&lt;strong>符号名称(变量的标识符)&lt;/strong> 配对的&lt;strong>存储位置(由内存地址标识)&lt;/strong>。这个&lt;strong>存储地址&lt;/strong>其包含称为&lt;strong>值&lt;/strong>的一些已知或未知数量的信息;变量的&lt;strong>存储地址&lt;/strong>是通过一个名叫&lt;strong>指针&lt;/strong>的东西来获取，也是&lt;strong>值&lt;/strong>的一种，指针的&lt;strong>值&lt;/strong>就是其所指向的变量的&lt;strong>存储地址&lt;/strong>；注意：变量的&lt;strong>存储地址的值&lt;/strong>与&lt;strong>存储地址中包含的值&lt;/strong>是两个不同的东西。指针与变量的代码示例&lt;/p>
&lt;p>变量是一个可以改变内容的固定标识符，比如我定义“这台电脑的名字”叫“XXX”，“这台电脑的名字”就是标识符(不变的内容)，存在于计算机的某个位置，“XXX”就是可以改变的内容 i.e.变量的值，给不变的内容定义不同的内容&lt;/p>
&lt;ul>
&lt;li>比如 X=1，X=2，X=3 等等，&lt;strong>X&lt;/strong> 就是不变的，1，2，3 等等都是可变的，X 就是一个变量，可以被赋予某些内容&lt;/li>
&lt;li>比如：&lt;strong>LANG&lt;/strong> 是一个语言的规定，你赋予他一个内容，就相当于定义了这个环境下所显示的语言，比如 LANG=US，LANG=CN 等等。LANG 这叫定义语言，这是不变的，可变的是后面的自定义内容，语言（不变）= 英语，汉语，日语（可变）。&lt;/li>
&lt;/ul>
&lt;p>如果你有一个复杂的表达式，比如&lt;/p>
&lt;pre>&lt;code>(5 - 3) * (4 + (2 * 3 - 5) * 6)
&lt;/code>&lt;/pre>
&lt;p>由于它有比较多的嵌套，人的眼睛是难以看清楚的，它要表达的意义也会难懂。这时候，你希望可以用一些 “名字” 来代表中间结果，这样表达式就更容易理解。&lt;/p>
&lt;p>打个比方，这就像你有一个亲戚，他是你妈妈的表姐的女儿的丈夫。你不想每次都称他 “我妈妈的表姐的女儿的丈夫”，所以你就用他的名字“叮当” 来指代他，一下子就简单了。&lt;/p>
&lt;p>我们来看一个例子。之前的复合表达式&lt;/p>
&lt;p>其实可以被转换为等价的，含有变量的代码：&lt;/p>
&lt;pre>&lt;code>{
a = 4 + 3 // 变量 a 得到 4+3 的值
2 * a // 代码块的值
}
&lt;/code>&lt;/pre>
&lt;p>其中 &lt;code>a&lt;/code> 是一个名字。&lt;code>a = 4 + 3&lt;/code> 是一个 “赋值语句”，它的意思是：用 a 来代表 4 + 3 的值。这种名字，计算机术语叫做 &lt;strong>variable(变量)&lt;/strong>。&lt;/p>
&lt;p>这段代码的意思可以简单地描述为：计算 &lt;code>4 + 3&lt;/code>，把它的结果表示为 &lt;code>a&lt;/code>，然后计算 &lt;code>2 * a&lt;/code> 作为最后的结果。&lt;/p>
&lt;p>有些东西可能扰乱了你的视线。两根斜杠 &lt;code>//&lt;/code> 后面一直到行末的文字叫做 “注释”，是给人看的说明文字。它们对代码的逻辑不产生作用，执行的时候可以忽略。许多语言都有类似这种注释，它们可以帮助阅读的人，但是会被机器忽略。&lt;/p>
&lt;p>这段代码执行过程会是这样：先计算 &lt;code>4 + 3&lt;/code> 得到 7，用 &lt;code>a&lt;/code> 记住这个中间结果 7。接着计算 &lt;code>2 * a&lt;/code> ，也就是计算 &lt;code>2 * 7&lt;/code>，所以最后结果是 14。很显然，这跟 &lt;code>2 * (4 + 3)&lt;/code> 的结果是一样的。&lt;/p>
&lt;p>&lt;code>a&lt;/code> 叫做一个变量，它是一个符号，可以用来代表任意的值。除了 &lt;code>a&lt;/code>，你还有许多的选择，比如 b, c, d, x, y, foo, bar, u21… 只要它不会被误解成其它东西就行。&lt;/p>
&lt;p>如果你觉得这里面的 “神奇” 成分太多，那我们现在来做更深一层的理解……&lt;/p>
&lt;p>再看一遍上面的代码。这整片代码叫做一个 “代码块”（block），或者叫一个 “序列”（sequence）。这个代码块包括两条语句，分别是 &lt;code>a = 4 + 3&lt;/code> 和 &lt;code>2 * a&lt;/code>。代码块里的语句会从上到下依次执行。所以我们先执行 &lt;code>a = 4 + 3&lt;/code>，然后执行 &lt;code>2 * a&lt;/code>。&lt;/p>
&lt;p>最后一条语句 &lt;code>2 * a&lt;/code> 比较特别，它是这个代码块的 “值”，也就是最后结果。之前的语句都是在为生成这个最后的值做准备。换句话说，这整个代码块的值就是 &lt;code>2 * a&lt;/code> 的值。不光这个例子是这样，这是一个通用的原理：代码块的最后一条语句，总是这个代码块的值。&lt;/p>
&lt;p>我们在代码块的前后加上花括号 &lt;code>{...}&lt;/code> 进行标注，这样里面的语句就不会跟外面的代码混在一起。这两个花括号叫做 “边界符”。我们今后会经常遇到代码块，它存在于几乎所有的程序语言里，只是语法稍有不同。比如有些语言可能用括号 &lt;code>(...)&lt;/code> 或者 &lt;code>BEGIN...END&lt;/code> 来表示边界，而不是用花括号。&lt;/p>
&lt;p>这片代码已经有点像常用的编程语言了，但我们暂时不把它具体化到某一种语言。我不想固化你的思维方式。在稍后的章节，我们会把这种抽象的表达法对应到几种常见的语言，这样一来你就能理解几乎所有的程序语言。&lt;/p>
&lt;p>另外还有一点需要注意，同一个变量可以被多次赋值。它的值会随着赋值语句而改变。举个例子：&lt;/p>
&lt;pre>&lt;code>{
a = 4 + 3
b = a
a = 2 * 5
c = a
}
&lt;/code>&lt;/pre>
&lt;p>这段代码执行之后，&lt;code>b&lt;/code> 的值是 7，而 &lt;code>c&lt;/code> 的值是 10。你知道为什么吗？因为 &lt;code>a = 4 + 3&lt;/code> 之后，a 的值是 7。&lt;code>b = a&lt;/code> 使得 &lt;code>b&lt;/code> 得到值 7。然后 &lt;code>a = 2 * 5&lt;/code> 把 &lt;code>a&lt;/code> 的值改变了，它现在是 10。所以 &lt;code>c = a&lt;/code> 使得 &lt;code>c&lt;/code> 得到 10。&lt;/p>
&lt;p>对同一个变量多次赋值虽然是可以的，但通常来说这不是一种好的写法，它可能引起程序的混淆，应该尽量避免。只有当变量表示的 “意义” 相同的时候，你才应该对它重复赋值。&lt;/p>
&lt;h2 id="data-type数据类型">Data type(数据类型)&lt;/h2>
&lt;p>**Data Type(数据类型) **用来对一组相关值进行分类，描述可对其执行的操作并定义它们的存储方式。通常也会称为 &lt;strong>Literal(字面量)&lt;/strong>&lt;/p>
&lt;h2 id="compile编译">Compile(编译)&lt;/h2>
&lt;p>一旦引入了变量，我们就可以不用复合表达式。因为你可以把任意复杂的复合表达式拆开成 “单操作算术表达式”（像 4 + 3 这样的），使用一些变量记住中间结果，一步一步算下去，得到最后的结果。&lt;/p>
&lt;p>举一个复杂点的例子，也就是这一节最开头的那个表达式：&lt;/p>
&lt;pre>&lt;code>(5 - 3) * (4 + (2 * 3 - 5) * 6)
&lt;/code>&lt;/pre>
&lt;p>它可以被转化为一串语句：&lt;/p>
&lt;pre>&lt;code>{
a = 2 * 3
b = a - 5
c = b * 6
d = 4 + c
e = 5 - 3
e * d
}
&lt;/code>&lt;/pre>
&lt;p>最后的表达式 &lt;code>e * d&lt;/code>，算出来就是原来的表达式的值。你观察一下，是不是每个操作都非常简单，不包含嵌套的复合表达式？你可以自己验算一下，它确实算出跟原表达式一样的结果。&lt;/p>
&lt;p>在这里，我们自己动手做了 &lt;strong>compiler(编译器)&lt;/strong> 的工作。通常来说，编译器是一种程序，它的任务是把一片代码“翻译” 成另外一种等价形式。这里我们没有写编译器，可是我们自己做了编译器的工作。我们手动地把一个嵌套的复合表达式，编译成了一系列的简单算术语句。&lt;/p>
&lt;p>这些语句的结果与原来的表达式完全一致。这种保留原来语义的翻译过程，叫做 &lt;strong>compile(编译)&lt;/strong>。&lt;/p>
&lt;p>我们为什么需要编译呢？原因有好几种。我不想在这里做完整的解释，但从这个例子我们可以看到，编译之后我们就不再需要复杂的嵌套表达式了。我们只需要设计很简单的，只会做单操作算术的机器，就可以算出复杂的嵌套的表达式。实际上最后这段代码已经非常接近现代处理器（CPU）的汇编代码（assembly）。我们只需要多加一些转换，它就可以变成机器指令。&lt;/p>
&lt;p>我们暂时不写编译器，因为你还缺少一些必要的知识。这当然也不是编译技术的所有内容，它还包含另外一些东西。但从这一开头，你就已经初步理解了编译器是什么，你只需要在将来加深这种理解。&lt;/p>
&lt;h2 id="function函数">Function(函数)&lt;/h2>
&lt;p>到目前为止，我们做的计算都是在已知的数字之上，而在现实的计算中我们往往有一些未知数。比如我们想要表达一个 “风扇控制器”，有了它之后，风扇的转速总是当前气温的两倍。这个“当前气温” 就是一个未知数。&lt;/p>
&lt;p>我们的 “风扇控制器” 必须要有一个“输入”（input），用于得到当前的温度 t，它是一个温度传感器的读数。它还要有一个输出，就是温度的两倍。&lt;/p>
&lt;p>那么我们可以用这样的方式来表达我们的风扇控制器：&lt;/p>
&lt;p>不要把这想成任何一种程序语言，这只是我们自己的表达法。箭头 &lt;code>-&amp;gt;&lt;/code> 的左边表示输入，右边表示输出，够简单吧。&lt;/p>
&lt;p>你可以把 &lt;code>t&lt;/code> 想象成从温度传感器出来的一根电线，它连接到风扇控制器上，风扇控制器会把它的输入（t）乘以 2。这个画面像这个样子：
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/85e3436b-9762-45b3-b0bb-38c1f87e416d/function1.png" alt="">
我们谈论风扇控制器的时候，其实不关心它的输入是哪里来的，输出到哪里去。如果我们把温度传感器和风扇从画面里拿掉，就变成这个样子：
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/85e3436b-9762-45b3-b0bb-38c1f87e416d/function2.jpg" alt="">
这幅图才是你需要认真理解的函数的计算图。你发现了吗，这幅图画正好对应了之前的风扇控制器的符号表示：&lt;code>t -&amp;gt; t*2&lt;/code>。看到符号就想象出画面，你就得到了符号背后的模型。&lt;/p>
&lt;p>像 &lt;code>t -&amp;gt; t*2&lt;/code> 这样具有未知数作为输入的构造，我们把它叫做 function(函数)。其中 &lt;code>t&lt;/code> 这个符号，叫做这个函数的参数。&lt;/p>
&lt;h2 id="parameter参数-与-variable变量">Parameter(参数) 与 Variable(变量)&lt;/h2>
&lt;p>你可能发现了，函数的参数和我们之前了解的 “变量” 是很类似的，它们都是一个符号。之前我们用了 &lt;code>a, b, c, d, e&lt;/code> 现在我们有一个 &lt;code>t&lt;/code>，这些名字我们都是随便起的，只要它们不要重复就好。如果名字重复的话，可能会带来混淆和干扰。&lt;/p>
&lt;p>其实参数和变量这两种概念不只是相似，它们的本质就是一样的。如果你深刻理解它们的相同本质，你的脑子就可以少记忆很多东西，而且它可能帮助你对代码做出一些有趣而有益的转化。在上一节你已经看到，我用 “电线” 作为比方来帮助你理解参数。你也可以用同样的方法来理解变量。&lt;/p>
&lt;p>比如我们之前的变量 &lt;code>a&lt;/code>：&lt;/p>
&lt;p>它可以被想象成什么样的画面呢？
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/85e3436b-9762-45b3-b0bb-38c1f87e416d/wire.png" alt="">
我故意把箭头方向画成从右往左，这样它就更像上面的代码。从这个图画里，你也许可以看到变量 &lt;code>a&lt;/code> 和风扇控制器图里的参数 &lt;code>t&lt;/code>，其实没有任何本质差别。它们都表示一根电线，那根电线进入乘法器，将会被乘以 2，然后输出。如果你把这些都看成是电路，那么变量 &lt;code>a&lt;/code> 和参数 &lt;code>t&lt;/code> 都代表一根电线而已。&lt;/p>
&lt;p>然后你还发现一个现象，那就是你可以把 &lt;code>a&lt;/code> 这个名字换成任何其它名字（比如 &lt;code>b&lt;/code>），而这幅图不会产生实质的改变。&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/85e3436b-9762-45b3-b0bb-38c1f87e416d/rename.png" alt="">&lt;/p>
&lt;p>这说明什么问题呢？这说明以下的代码（把 &lt;code>a&lt;/code> 换成了 &lt;code>b）&lt;/code>跟之前的是等价的：&lt;/p>
&lt;p>根据几乎一样的电线命名变化，你也可以对之前的函数得到一样的结论：&lt;code>t -&amp;gt; t*2&lt;/code> 和 &lt;code>u -&amp;gt; u*2&lt;/code>，和 &lt;code>x -&amp;gt; x*2&lt;/code> 都是一回事。&lt;/p>
&lt;p>名字是很重要的东西，但它们具体叫什么，对于机器并没有实质的意义，只要它们不要相互混淆就可以。但名字对于人是很重要的，因为人脑没有机器那么精确。不好的变量和参数名会导致代码难以理解，引起程序员的混乱和错误。所以通常说来，你需要给变量和参数起好的名字。&lt;/p>
&lt;p>什么样的名字好呢？我会在后面集中讲解。&lt;/p>
&lt;h2 id="named-function有名字的函数">Named function(有名字的函数)&lt;/h2>
&lt;p>既然变量可以代表 “值”，那么一个自然的想法，就是让变量代表函数。所以就像我们可以写&lt;/p>
&lt;p>我们似乎也应该可以写&lt;/p>
&lt;p>对的，你可以这么做。&lt;code>f = t-&amp;gt;t*2&lt;/code> 还有一个更加传统的写法，就像数学里的函数写法：&lt;/p>
&lt;p>请仔细观察 &lt;code>t&lt;/code> 的位置变化。我们在函数名字的右边写一对括号，在里面放上参数的名字。&lt;/p>
&lt;p>注意，你不可以只写&lt;/p>
&lt;p>你必须明确的指出函数的参数是什么，否则你就不会明白函数定义里的 &lt;code>t&lt;/code> 是什么东西。明确指出 &lt;code>t&lt;/code> 是一个 “输入”，你才会知道它是函数的输入，是一个未知数，&lt;strong>而不是在函数外面定义的其它变量&lt;/strong>。&lt;/p>
&lt;p>这个看似简单的道理，很多数学家都不明白，所以他们经常这样写书：&lt;/p>
&lt;blockquote>
&lt;p>有一个函数 y = x*2&lt;/p>
&lt;/blockquote>
&lt;p>这是错误的，因为他没有明确指出 “&lt;code>x&lt;/code> 是函数 y 的参数”。如果这句话之前他们又定义过 &lt;code>x&lt;/code>，你就会疑惑这是不是之前那个 &lt;code>x&lt;/code>。很多人就是因为这些糊里糊涂的写法而看不懂数学书。这不怪他们，只怪数学家自己对于语言不严谨。&lt;/p>
&lt;h2 id="function-call函数调用">Function call(函数调用)&lt;/h2>
&lt;p>有了函数，我们可以给它起名字，可是我们怎么使用它的值呢？&lt;/p>
&lt;p>由于函数里面有未知数（参数），所以你必须告诉它这些未知数，它里面的代码才会执行，给你结果。比如之前的风扇控制器函数&lt;/p>
&lt;p>它需要一个温度作为输入，才会给你一个输出。于是你就这样给它一个输入：&lt;/p>
&lt;p>你把输入写在函数名字后面的括号里。那么你就会得到输出：4。也就是说 &lt;code>f(2)&lt;/code> 的值是 4。&lt;/p>
&lt;p>如果你没有调用一个函数，函数体是不会被执行的。因为它不知道未知数是什么，所以什么事也做不了。那么我们定义函数的时候，比如&lt;/p>
&lt;p>当看到这个定义的时候，机器应该做什么呢？它只是记录下：有这么一个函数，它的参数是 &lt;code>t&lt;/code>，它需要计算 &lt;code>t*2&lt;/code>，它的名字叫 &lt;code>f&lt;/code>。但是机器不会立即计算 &lt;code>t*2&lt;/code>，因为它不知道 &lt;code>t&lt;/code> 是多少。&lt;/p>
&lt;h2 id="branch分支">Branch(分支)&lt;/h2>
&lt;p>直到现在，我们的代码都是从头到尾，闷头闷脑地执行，不问任何问题。我们缺少一种 “问问题” 的方法。比如，如果我想表达这样一个“食物选择器”：如果气温低于 22 度，就返回 “hotpot” 表示今天吃火锅，否则返回 “ice cream” 表示今天吃冰激凌。&lt;/p>
&lt;p>我们可以把它图示如下：
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/85e3436b-9762-45b3-b0bb-38c1f87e416d/branch.png" alt="">
中间这种判断结构叫做 “分支”（branching），它一般用菱形表示。为什么叫分支呢？你想象一下，代码就像一条小溪，平时它沿着一条路线流淌。当它遇到一个棱角分明的大石头，就分成两个支流，分开流淌。&lt;/p>
&lt;p>我们的判断条件 &lt;code>t &amp;lt; 22&lt;/code> 就像一块大石头，我们的 “代码流” 碰到它就会分开成两支，分别做不同的事情。跟溪流不同的是，这种分支不是随机的，而是根据条件来决定，而且分支之后只有一支继续执行，而另外一边不会被执行。&lt;/p>
&lt;p>我们现在看到的都是图形化表示的模型，为了书写方便，现在我们要从符号的层面来表示这个模型。我们需要一种符号表示法来表达分支，我们把它叫做 &lt;code>if&lt;/code>（如果）。我们的饮料选择器代码可以这样写：&lt;/p>
&lt;pre>&lt;code>t -&amp;gt; if (t &amp;lt; 22)
{
&amp;quot;hotpot&amp;quot;
}
else
{
&amp;quot;ice cream&amp;quot;
}
&lt;/code>&lt;/pre>
&lt;p>它是一个函数，输入是一个温度。&lt;code>if&lt;/code> 后面的括号里放我们的判断条件。后面接着条件成立时执行的代码块，然后是一个 &lt;code>else&lt;/code>，然后是条件不成立时执行的代码。它说：如果温度低于 22 度，我们就吃火锅，否则就吃冰激凌。&lt;/p>
&lt;p>其中的 &lt;code>else&lt;/code> 是一个特殊的符号，它表示 “否则”。看起来不知道为什么 &lt;code>else&lt;/code> 要在那里？对的，它只是一个装饰品。我们已经有足够的表达力来分辨两个分支，不过有了 &lt;code>else&lt;/code> 似乎更加好看一些。很多语言里面都有 else 这个标记词在那里，所以我也把它放在那里。&lt;/p>
&lt;p>这只是一个最简单的例子，其实那两个代码块里面不止可以写一条语句。你可以有任意多的语句，就像这样：&lt;/p>
&lt;pre>&lt;code>t -&amp;gt;
if (t &amp;lt; 22)
{
a = 4 + 3
b = a * 2
&amp;quot;hotpot&amp;quot;
}
else
{
x = &amp;quot;ice cream&amp;quot;
x
}
&lt;/code>&lt;/pre>
&lt;p>这段代码和之前是等价的，你知道为什么吗？&lt;/p>
&lt;h2 id="declaration声明-与-definition定义">Declaration(声明) 与 Definition(定义)&lt;/h2>
&lt;p>上面描述了很多计算机科学的基本要素，那么上面那么多字的描述，是如何定义的呢？~不定义一个东西，是没法使用它的~~~&lt;/p>
&lt;p>在计算机编程中，&lt;strong>Declaration(声明)&lt;/strong> 是一种语言结构，用以指定 Identifier(标识符) 的属性，i.e.声明一个词(标识符)代表什么，也就是说，将 Identifier(标识符) 绑定到某种概念上。&lt;/p>
&lt;blockquote>
&lt;p>比如，用白话说就是：我声明，A 表示一个函数、B 表示一个字符串类型的变量，等等&lt;/p>
&lt;/blockquote>
&lt;p>Declaration 最常用于函数、变量、常量、类型定义 等等。Declaration 用于向编译器宣布实体的存在，在某些强类型的编程语言中，使用 函数、变量、常量 等等要素之前需要先 Declaration 它们，再使用比如 为变量赋值、调用函数 等等)。&lt;/p>
&lt;p>在某些场景下，&lt;strong>Declaration(声明)&lt;/strong> 与 &lt;strong>Definition(定义)&lt;/strong> 这两个词比较容易混淆。&lt;/p>
&lt;ul>
&lt;li>在非正式用法中
&lt;ul>
&lt;li>Declaration 纯指声明(仅类型，无值或主体)&lt;/li>
&lt;li>Definition 指包含值或主体的声明。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>在正式使用中
&lt;ul>
&lt;li>Declaration 包含非正式用法中的两种含义。在 Declaration 的同时，有的时候我们会为标识符定义一个初始值。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>上面的描述，把定义当做了赋值的行为。实际上，Definition 还有另外一种行为含义，这种行为应该是在 Declaration 之前的。比如下面的例子：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>// 这里我们定义了一个类型与函数。定义时，指定了这些东西应该具有的属性
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>definition string XXXXX
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>definition func YYYYY
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>// 这里我们声明了一个类型与函数。
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>// 标识符A 绑定到了字符串
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>// 标识符B 绑定到了函数
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>var identifierA string
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>func iderntifierB&lt;span style="color:#f92672">(){&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Do Something
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>// 此时我们可以使用这些已经声明的标识符
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>stringType &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#34;Hello World&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>DefinitionFunc&lt;span style="color:#f92672">()&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>也就是说，Definition(定义) 这个词更符合人类的日常用于，定义一个事物，就是对这个事物进行总结，就好比科学，我们通过观察自然界的现象，来定义一个科学定律，然后通过定律推导出定理。总结一下就是：&lt;/p>
&lt;ul>
&lt;li>&lt;strong>Definition 用来指定 Type(类型)。不管是编程语言自带的基本类型，还是符合类型，甚至是自己自定义的类型，都称为“定义类型”&lt;/strong>&lt;/li>
&lt;li>&lt;strong>Declaration 用来指定 Identifier(标识符)，并将该 Identifier(标识符) 绑定到 Type(类型) 上。称为“声明标识符”&lt;/strong>&lt;/li>
&lt;/ul>
&lt;p>但是，在现代中，Declaration 与 Definition 经常会混用，经常会有人说：定义类型、声明类型、定义变量、声明变量、定义函数、声明函数 等等等等。&lt;/p>
&lt;p>比如，当我们使用一个未声明的变量时，某些编程语言经常会提示 undefined(未定义)~~~~o(╯□╰)o 其实，更准确的提示应该是 undeclared。&lt;/p>
&lt;blockquote>
&lt;p>说的就是你，Go 语言，Declaration 与 Definition 不分~~~
不过除了这个编译器的错误提示有歧义以外，其它描述基本都是准确的，绝大部分都是 Declaration(声明)，只有一个地方用到了 Definition(定义)，主要就是在 &lt;a href="https://go.dev/ref/spec#Type_declarations">Go 的参考&lt;/a>中，可以看到 Type Declaration 与 Type Definition 之间的区别。也就是说，只有在描述一个新的类型时，才称为“定义类型”&lt;/p>
&lt;ul>
&lt;li>比如 &lt;code>type XXXX struct&lt;/code>，我们就称为 &lt;strong>定义结构体&lt;/strong>，&lt;code>var structID XXXX&lt;/code>，我们就称为&lt;strong>声明 XXXX 类型结构体。&lt;/strong>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>后记：
其实，定义类型这个行为，再扩展一下，也可以称为建模，这是[面向对象编程](/docs/IT学习笔记/2.编程/解谜计算机科学/Object-oriented%20Programming(面向对象编程).md Programming(面向对象编程).md)的基本要素。人们通过对现实世界的观察、总结，定义了很多基本类型，比如 数字、字符串、布尔 等等。这些基本类型都是一个个已经建立好的模型，只不过是最基本的，而我们可以使用这些基本模型，建立更复杂的模型。所以，定义类型 这个行为，从某种角度来看，就是建立模型。&lt;/p>
&lt;h1 id="计算的要素">计算的要素&lt;/h1>
&lt;p>好了，现在你已经掌握了计算机科学的几乎所有基本要素。每一个编程语言都包括这些构造：&lt;/p>
&lt;ul>
&lt;li>基础的数值。比如整数，字符串，布尔值等。&lt;/li>
&lt;li>表达式。包括基本的算术表达式，嵌套的表达式。&lt;/li>
&lt;li>变量和赋值语句。&lt;/li>
&lt;li>分支语句。&lt;/li>
&lt;li>函数和函数调用。&lt;/li>
&lt;/ul>
&lt;p>你也许可以感觉到，我是把这些构造按照 “从小到大” 的顺序排列的。这也许可以帮助你的理解。&lt;/p>
&lt;p>现在你可以回想一下你对它们的印象。每当学习一种新的语言或者系统，你只需要在里面找到对应的构造，而不需要从头学习。这就是掌握所有程序语言的秘诀。这就像学开车一样，一旦你掌握了油门，刹车，换挡器，方向盘，速度表的功能和用法，你就学会了开所有的汽车，不管它是什么型号的汽车。&lt;/p>
&lt;p>我们在这一章不仅理解了这些要素，而且为它们定义了一种我们自己的 “语言”。显然这个语言只能在我们的头脑里运行，因为我们没有实现这个语言的系统。在后面的章节，我会逐渐的把我们这种语言映射到现有的多种语言里面，然后你就能掌握这些语言了。&lt;/p>
&lt;p>但是请不要以为掌握了语言就学会了编程或者学会了计算机科学。掌握语言就像学会了各种汽车部件的工作原理。几分钟之内，初学者就能让车子移动，转弯，停止。可是完了之后你还需要学习交通规则，你需要许许多多的实战练习和经验，掌握各种复杂情况下的策略，才能成为一个合格的驾驶员。如果你想成为赛车手，那就还需要很多倍的努力。&lt;/p>
&lt;p>但是请不要被我这些话吓到了，你没有那么多的竞争者。现在的情况是，世界上就没有很多合格的计算机科学驾驶员，更不要说把车开得流畅的赛车手。绝大部分的 “程序员” 连最基本的引擎，油门，刹车，方向盘的工作原理都不明白，思维方式就不对，所以根本没法独自上路，一上路就出车祸。很多人把过错归结在自己的车身上，以为换一辆车马上就能成为好的驾驶员。这是一种世界范围的计算机教育的失败。&lt;/p>
&lt;p>在后面的章节，我会引导你成为一个合格的驾驶员，随便拿一辆车就能开好。&lt;/p>
&lt;h1 id="什么是计算">什么是计算&lt;/h1>
&lt;p>现在你掌握了计算所需要的基本元素，可是什么是计算呢？我好像仍然没有告诉你。这是一个很哲学的问题，不同的人可能会告诉你不同的结果。我试图从最广义的角度来告诉你这个问题的答案。&lt;/p>
&lt;p>当你小时候用手指算 &lt;code>4+3&lt;/code>，那是计算。如果后来你学会了打算盘，你用算盘算 4+3，那也是计算。后来你从我这里学到了表达式，变量，函数，调用，分支语句…… 在每一新的构造加入的过程中，你都在了解不同的计算。&lt;/p>
&lt;p>所以从最广义来讲，计算就是 “机械化的信息处理”。所谓机械化，你可以用手指算，可以用算盘，可以用计算器，或者计算机。这些机器里面可以有代码，也可以没有代码，全是电子线路，甚至可以是生物活动或者化学反应。不同的机器也可以有不同的计算功能，不同的速度和性能……&lt;/p>
&lt;p>有这么多种计算的事实不免让人困惑，总害怕少了点什么，其实你可以安心。如果你掌握了上一节的 “计算要素”，那么你就掌握了几乎所有类型的计算系统所需要的东西。你在后面所需要做的只是加深这种理解，并且把它“对应” 到现实世界遇到的各种计算机器里面。&lt;/p>
&lt;p>为什么你可以相信计算机科学的精华就只有这些呢？因为计算就是处理信息，信息有它诞生的位置（输入设备，固定数值），它传输的方式（赋值，函数调用，返回值），它被查看的地方（分支）。你想不出对于信息还有什么其它的操作，所以你就很安心的相信了，这就是计算机科学这种 “棋类游戏” 的全部规则。&lt;/p>
&lt;p>（如果你觉得这篇文章有启发，可以点击这里&lt;a href="http://www.yinwang.org/blog-cn/2016/04/13/pay-blog">付费&lt;/a>）&lt;/p></description></item><item><title>Docs: 日志系统</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/6.%E5%8F%AF%E8%A7%82%E6%B5%8B%E6%80%A7/%E6%97%A5%E5%BF%97%E7%B3%BB%E7%BB%9F/%E6%97%A5%E5%BF%97%E7%B3%BB%E7%BB%9F/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/6.%E5%8F%AF%E8%A7%82%E6%B5%8B%E6%80%A7/%E6%97%A5%E5%BF%97%E7%B3%BB%E7%BB%9F/%E6%97%A5%E5%BF%97%E7%B3%BB%E7%BB%9F/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Syslog">Wiki,Syslog&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://datatracker.ietf.org/doc/html/rfc5424">RFC 5424&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;h2 id="背景">背景&lt;/h2>
&lt;p>在系统上，不管是系统本身还是外部程序，在开始、运行、结束的一整套过程中，都会产生信息，这些信息包括:何时、何地(来源 IP)、何人(什么程序)、发生了什么事情等。i.e.记录系统在什么时候由哪个程序做了什么样的行为时，发生了何种事件等等。而发生的事情又有等级的区别，哪些信息是危险的，哪些信息是标准可以不用关注的等。这些信息就统称为日志(Log)。随着时代发展，操作系统、程序、硬件设备等等都会产生日志，如此众多的日志需要一个标准来进行定义，这个日志标准就是 &lt;strong>Syslog Protocol&lt;/strong>，由 IETF 给定的 RFC 5424 规范来执行。而在 IT 行业，一般也把各个事务所生成的日志称为 syslog。&lt;/p>
&lt;h2 id="日志的生成">日志的生成&lt;/h2>
&lt;p>操作系统、进程和应用程序的编写者完全清楚他们将生成的事件。在某些情况下，生成消息用来说明状态。可以是一段时间一次，也可以由其他方式触发，例如在程序退出时。在其他情况下，消息是由遇到的条件产生的。在这些情况下，不管是状态消息或者包含一些类型的警告都可能被产生。操作系统、进程和应用程序的编写者可能会在详单中确定消息的数量。这些详单中通常包括发出消息的设备，同时包含消息的严重级别。这样，操作员可以有选择地筛选消息，可以更快的定位更加重要的和有处理时间限制的消息，同时可以将状态或消息信息放在文件中，将来阅读他们。其他显示和保存信息的方式也可以存在。&lt;/p>
&lt;p>必须在设备中配置一些规则，这些规则可以告诉设备显示还是转发事件消息。这些规则是十分灵活的。管理员可能希望所有的信息都保存在本地，同时所有高优先级的消息都会转发到另一台设备中。他们可能发现，将某些设备的信息发送到一些或所有用户的设备中，同时显示在系统控制台上是很合适的。然而，管理员决定将事件信息发送到 syslog 采集器中，在采集器中包含了组成设备的信息以及发送的严重级别，同时定义了远程接收器。例如，系统管理员可能想让所有由邮件设备发出的消息被转发到一个特定的事件信息采集器中。管理员还可以让所有内核生成的事件信息被发送到另一台 syslog 接收器中，同时，将内核产生的 critical 严重级别的消息发送到第三台设备中。同时，将显示在系统控制台中的信息 email 给部分用户，同时将他们保存在设备本地磁盘的文件中。反之，可以将本地进程产生的消息显示在控制台中，但不保存也不转发。所有事件的规则都在设备中生成。因为管理员知道 collector 会收集到哪种类型的事件，他们会在 syslog 服务器中配置相应的规则。&lt;/p>
&lt;p>消息的内容因创建者而异。建议将消息按照一定格式编写，这样人们就可以阅读他们。在消息中加入时间戳和发出消息的设备以及进程的标识符是一个很好的建议。但他们都不是必须的。&lt;/p>
&lt;p>假设任何进程和设备都有可能产生事件消息。可能包含没有任何本地存储空间的设备，例如打印机、路由器、集线器、交换机以及无盘工作站。在这种情况下，将事件消息传送到 collector 可能是必要的，以便操作者可以记录并希望看到它们。&lt;/p>
&lt;h2 id="日志的收集">日志的收集&lt;/h2>
&lt;p>日志收集起来，才能方便管理人员进行查看并进行故障排除。如此众多事物的日志如果想要统一管理，就需要一套程序来对所有事物的日志进行收集、处理、保存、过滤、分析等，可以实现该功能的程序有以下几个：&lt;/p>
&lt;ul>
&lt;li>sysLog 程序与 syslog 标准重名，是早期的 Linux 用于处理系统上所有事物日志的程序&lt;/li>
&lt;li>RsysLog 是 sysLog 的升级版&lt;/li>
&lt;li>ELK/EFK 是很重量级，功能很全的 3 款程序的统称
&lt;ul>
&lt;li>Eleasticsearch 是一个存储系统和搜索引擎&lt;/li>
&lt;li>logstash、Fluentd 日志收集&lt;/li>
&lt;li>kibana 日志的前端展示&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h2 id="日志的生成与收集的通用流程">日志的生成与收集的通用流程&lt;/h2>
&lt;p>当一个程序生成日志后，一般调用一个 output() 函数，把生成的日志输出到某处，e.g.文件、内存、STDOUT 等&lt;/p>
&lt;p>而日志采集程序一般会调用一个 input() 函数，来从某处获取日志，然后再调用 output() 函数来把日志转发或转存&lt;/p>
&lt;h1 id="the-syslog-protocol系统日志协议--即-syslog-规范">The Syslog Protocol(系统日志协议) # 即 syslog 规范&lt;/h1>
&lt;p>每个程序如果产生的日志格式都不一样，也不便于收集归档，更不便于分类查看，所以需要一个统的规范，这个规范包括可收集哪些程序的日志、日志的格式、级别的定义等&lt;/p>
&lt;h2 id="架构">架构&lt;/h2>
&lt;p>Syslog Protocol 采用分层架构设计，共分为 3 层&lt;/p>
&lt;ul>
&lt;li>&amp;ldquo;syslog content&amp;rdquo; syslog 内容层。is the management information contained in a syslog message.&lt;/li>
&lt;li>&amp;ldquo;syslog application&amp;quot;syslog 应用程序层。处理系统日志消息的生成、解释、路由、存储&lt;/li>
&lt;li>&amp;ldquo;syslog transport&amp;quot;syslog 传输层。将消息放到 puts messages on the wire and takes them off the wire.&lt;/li>
&lt;/ul>
&lt;p>每层架构中都会执行某些类型的功能&lt;/p>
&lt;ul>
&lt;li>originator：发起者。生成将要在消息中携带的 syslog 内容&lt;/li>
&lt;li>collector：采集器。收集 syslog 内容以供进一步分析&lt;/li>
&lt;li>relay：中继。转发消息，接收来自 originators 或其他 relaysd 的消息，并将其发送给 collectors 或其他 relays&lt;/li>
&lt;li>transport sender：传输发送器。将 syslog 消息传递给特定的传输协议&lt;/li>
&lt;li>transport receiver：传输接收器。从特定的传输协议获取 syslog 消息&lt;/li>
&lt;/ul>
&lt;h2 id="syslog-信息的构成格式">syslog 信息的构成格式&lt;/h2>
&lt;p>每个程序在编写的都时候都会定义日志格式，大部分都会遵循“syslog”标准。不同事物的日志格式不尽相同，详情请见相关事物的文档，不过一般情况下，日志内容都应该包含，时间，某物，在哪，做了什么。&lt;/p>
&lt;p>The Syslog Protocol 规定了每条 syslog 信息应该包含如下内容：&lt;/p>
&lt;p>HEADER Structured-Data [MSG] # 头部信息，结构化数据，消息主体&lt;/p>
&lt;ul>
&lt;li>HEADER=PRI VERSION TIMESTAMP HOSTNAME # 优先级、版本、时间出、主机名
&lt;ul>
&lt;li>PRI=Facility*8+Severity # Priority 优先级是一个值，计算方式通过两部分计算，“Facility 设施”与“Severity 严重性”。具体见本章下文具体描述&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Structured-Data= #&lt;/li>
&lt;/ul>
&lt;h3 id="facility设施">Facility(设施)&lt;/h3>
&lt;p>Facility 用来表示产生该信息的硬件设备、协议、系统软件、操作系统等可以产生日志消息的事物类别。由于世界上事物太多，所以最好以类别的方式来对各个事务进行分类，所以使用 &lt;strong>Facility(设施)&lt;/strong> 来描述。比如&lt;code>security/authorization&lt;/code>这个设施中就包含很多关于安全认证的应用程序产生的日志类别。&lt;/p>
&lt;p>每个 Facility 都对应一个值以便进行 PRI 的计算，以下是 RFC5424 中规定的几十类 Facility。其中括号中的数字表示 Facility 对应的 Numerical Code(数字码)。&lt;/p>
&lt;ul>
&lt;li>&lt;strong>kernel messages(0)&lt;/strong> # 内核信息类&lt;/li>
&lt;li>&lt;strong>user-level messages(1)&lt;/strong> # 用户层信息类，比如用户使用 logger 命令来记录日志功能&lt;/li>
&lt;li>&lt;strong>mail system(2)&lt;/strong> # 邮件系统类型&lt;/li>
&lt;li>&lt;strong>system daemons(3)&lt;/strong> # 系统守护进程类，比如 systemd 管理的服务的信息。&lt;/li>
&lt;li>&lt;strong>security/authorization messages(4)&lt;/strong> # 安全与认证信息类，比如 login、ssh、su 等需要账号密码的。&lt;/li>
&lt;li>&lt;strong>messages generated internally by syslogd(5)&lt;/strong> # 由 syslog 相关协议产生的信息类，就是 rsyslog 程序本身的日志信息。&lt;/li>
&lt;li>&lt;strong>line printer subsystem(6)&lt;/strong> # 打印子系统类&lt;/li>
&lt;li>&lt;strong>network news subsystem(7)&lt;/strong> #&lt;/li>
&lt;li>&lt;strong>UUCP subsystem(8)&lt;/strong> #&lt;/li>
&lt;li>&lt;strong>clock daemon(9)&lt;/strong> #&lt;/li>
&lt;li>&lt;strong>security/authorization messages(10)&lt;/strong> #&lt;/li>
&lt;li>&lt;strong>FTP daemon(11)&lt;/strong> # FTP&lt;/li>
&lt;li>&lt;strong>NTP subsystem(12)&lt;/strong> # NTP 子系统&lt;/li>
&lt;li>&lt;strong>log audit(13)&lt;/strong> # 日志审计&lt;/li>
&lt;li>&lt;strong>log alert(14)&lt;/strong> # 日志报警&lt;/li>
&lt;li>&lt;strong>clock daemon(note 2)(15)&lt;/strong> #&lt;/li>
&lt;li>&lt;strong>local use 0~7 (local0~7)(16~23)&lt;/strong> # 留给用户自定义的类别，比如可以把某些程序归为 Local0~7 中的某一类，然后来收集该类的日志&lt;/li>
&lt;/ul>
&lt;h3 id="severity">Severity&lt;/h3>
&lt;p>Severity 用来表示该日志信息的严重程度，也叫日志的级别 Level。为了便于日志管理，需要对日志的内容进行划分，哪些信息是正常的，哪些信息是错误的，哪些信息是警告等等。一般情况分为以下几类，其中第一列数字表示对应的 Severity 的值，第二列为 Severity 的名称以及其所描述的严重程度的具体概念。以下严重程度由高到底进行排列，debug 属于特殊的 Severity&lt;/p>
&lt;ul>
&lt;li>0 Emergency: 系统不可用 system is unusable&lt;/li>
&lt;li>1 Alert: 必须立即采取行动 action must be taken immediately&lt;/li>
&lt;li>2 Critical: 临界状态 critical conditions&lt;/li>
&lt;li>3 Error: 错误状态 error conditions&lt;/li>
&lt;li>4 Warning: 警告状态 warning conditions&lt;/li>
&lt;li>5 Notice: 正常但是值得注意的状态 normal but significant condition&lt;/li>
&lt;li>6 Informational: 信息 informational messages&lt;/li>
&lt;li>7 Debug: debug 级别的信息 debug-level messages&lt;/li>
&lt;/ul>
&lt;h1 id="常见日志级别">常见日志级别&lt;/h1>
&lt;p>Emergency ( 紧急 ): 关于 SYN 攻击、Tear Drop 攻击及 Ping of Death 攻击的消息。
Alert ( 警示 ): 关于需要立即引起注意的情况 ( 例如防火墙攻击和许可密钥到期 ) 的消息。
Critical (关键 ): 关于可能影响设备功能的情况 [例如高可用性 (HA) 状态更改 ]的消息。
Error (错误): 关于可能影响设备功能的错误情况 (例如反病毒扫描失败或与 SSH 服务器通信失败) 的消息。
Warning( 警告 ):关于可能影响设备功能的情况(例如连接到电子邮件服务器失败或认证失败、超时和成功)的消息。
Notification (通知 ): 关于常规事件 ( 包括由 admin 发起的配置更改 ) 的消息。
Information ( 信息 ): 可提供关于系统操作一般信息的消息。
Debugging ( 调试 ): 可提供调试时所用详细信息的消息。&lt;/p></description></item><item><title>Docs: 系统审计</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E7%B3%BB%E7%BB%9F%E5%AE%A1%E8%AE%A1/%E7%B3%BB%E7%BB%9F%E5%AE%A1%E8%AE%A1/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E7%B3%BB%E7%BB%9F%E5%AE%A1%E8%AE%A1/%E7%B3%BB%E7%BB%9F%E5%AE%A1%E8%AE%A1/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/7/html/security_guide/chap-system_auditing">红帽产品文档，RedHat7-安全指南-第 7 章 系统审计&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>Linux 审计系统提供了一种方式来跟踪系统中的安全相关信息。根据预配置的规则，审计会生成日志条目，以记录有关系统上发生事件的尽可能多的信息。对于关键任务环境而言，此信息对于确定安全策略的违反者及其执行的操作至关重要。Audit 不会为您的系统提供额外的安全性，而是可用于发现系统上使用的安全策略违规。通过 SELinux 等其他安全措施可以进一步阻止这些冲突。&lt;/p>
&lt;p>以下列表总结了审计可以在其日志文件中记录的一些信息：&lt;/p>
&lt;ul>
&lt;li>事件的日期和时间、类型和结果.&lt;/li>
&lt;li>主题和对象的敏感度标签。&lt;/li>
&lt;li>事件与触发事件的用户的身份相关联。&lt;/li>
&lt;li>对 Audit 配置的所有修改，并尝试访问 Audit 日志文件。&lt;/li>
&lt;li>所有身份验证机制的使用，如 SSH 和 Kerberos 等。&lt;/li>
&lt;li>对任何受信任数据库的更改，如 /etc/passwd.&lt;/li>
&lt;li>尝试从系统导入或导出信息.&lt;/li>
&lt;li>根据用户身份、主题和对象标签以及其他属性，包含或排除事件。&lt;/li>
&lt;/ul>
&lt;p>使用审计系统也是许多安全相关认证的一项要求。审计旨在满足或超过以下认证或合规指南的要求：&lt;/p>
&lt;ul>
&lt;li>受控访问保护配置文件(CAPP)&lt;/li>
&lt;li>标记的安全保护配置文件(LSPP)&lt;/li>
&lt;li>规则集基本访问控制(RSBAC)&lt;/li>
&lt;li>国家工业安全计划操作手册(NISPOM)&lt;/li>
&lt;li>联邦信息安全管理法案(FISMA)&lt;/li>
&lt;li>支付卡行业 - 数据安全标准(PCI-DSS)&lt;/li>
&lt;li>安全技术实施指南(STIG)&lt;/li>
&lt;/ul>
&lt;p>审计还包括：&lt;/p>
&lt;ul>
&lt;li>由国家信息保障合作伙伴(NIAP)和最佳安全行业(BSI)评估。&lt;/li>
&lt;li>通过红帽企业 Linux 5 上的 LSPP/CAPP/RSBAC/EAL4+ 认证.&lt;/li>
&lt;li>红帽企业 Linux 6 上经过操作系统保护配置文件/评估保证级别 4+(OSPP/EAL4+)认证.&lt;/li>
&lt;/ul>
&lt;h3 id="使用案例">使用案例&lt;/h3>
&lt;p>&lt;strong>监视文件访问&lt;/strong> # 审计可以跟踪文件或目录是否已访问、修改、执行或文件属性是否已更改。例如，这可用于检测对重要文件的访问，并在其中一个文件损坏时提供审计跟踪。&lt;/p>
&lt;p>&lt;strong>监控系统调用&lt;/strong> # 可将审计配置为在每次使用特定系统调用时生成日志条目。例如，这可用于通过监控 settimeofday、clock_adjtime 和其他时间相关系统调用来跟踪系统时间的更改。&lt;/p>
&lt;p>&lt;strong>记录用户运行的命令&lt;/strong> # 审计可以跟踪文件是否已执行，因此可以定义规则以记录特定命令的每次执行。例如，可以为 /bin 目录中的每个可执行文件定义规则。然后，可以按用户 ID 搜索生成的日志条目，以生成每个用户所执行命令的审计跟踪。&lt;/p>
&lt;p>&lt;strong>记录系统路径名称的执行&lt;/strong> # 除了观察在规则调用时转换索引节点路径的文件访问之外，审计现在还可以观察路径的执行，即使路径在规则调用中不存在，或者在规则调用后替换了文件。这允许规则在升级程序可执行文件或甚至安装之前继续运行。&lt;/p>
&lt;p>&lt;strong>记录安全事件&lt;/strong> # pam_faillock 身份验证模块能够记录失败的登录尝试。也可以将审计设置为记录失败的登录尝试，并提供试图登录的用户的附加信息。&lt;/p>
&lt;p>&lt;strong>搜索事件&lt;/strong> # Audit 提供 ausearch 实用程序，可用于过滤日志条目并根据多个条件提供完整的审计跟踪。&lt;/p>
&lt;p>&lt;strong>运行摘要报告&lt;/strong> # aureport 实用程序可用于生成记录的事件的日常报告等。然后，系统管理员可以分析这些报告，并进一步调查可疑活动。&lt;/p>
&lt;p>&lt;strong>监控网络访问&lt;/strong> # iptables 和 ebtables 实用程序可以配置为触发审计事件，使系统管理员能够监控网络访问。&lt;/p></description></item><item><title>Docs: Core</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/y.windows-%E7%AE%A1%E7%90%86/windows%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/powershell%E5%86%85%E7%BD%AE%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/core/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/y.windows-%E7%AE%A1%E7%90%86/windows%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/powershell%E5%86%85%E7%BD%AE%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/core/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://learn.microsoft.com/en-us/powershell/module/microsoft.powershell.core">官方文档，PowerShell-参考-Core 模块&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>核心模块包含管理 PowerShell 基本功能的 cmdlet 和提供程序。&lt;/p>
&lt;h1 id="get-command">Get-Command&lt;/h1>
&lt;p>获取所有命令&lt;/p>
&lt;h2 id="syntax语法">Syntax(语法)&lt;/h2>
&lt;p>&lt;strong>Get-Command [OPTIONS]&lt;/strong>&lt;/p>
&lt;p>&lt;strong>OPTIONS&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>&lt;strong>-Name &amp;lt;PATTERN&amp;gt;&lt;/strong> # 列出匹配到名字的命令。支持通配符。&lt;code>默认值：None&lt;/code>&lt;/li>
&lt;/ul>
&lt;h2 id="example">EXAMPLE&lt;/h2></description></item><item><title>Docs: FFmpeg</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/11_%E5%A4%9A%E5%AA%92%E4%BD%93/%E5%A4%9A%E5%AA%92%E4%BD%93%E5%A4%84%E7%90%86%E5%B7%A5%E5%85%B7/ffmpeg/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/11_%E5%A4%9A%E5%AA%92%E4%BD%93/%E5%A4%9A%E5%AA%92%E4%BD%93%E5%A4%84%E7%90%86%E5%B7%A5%E5%85%B7/ffmpeg/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://github.com/FFmpeg/FFmpeg">GitHub 项目，FFmpge/FFmpge&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://ffmpeg.org/">官网&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>FFmpeg 是一个库和工具的集合，用于处理多媒体内容，比如 音频、视频、字幕、相关元数据 等。&lt;/p>
&lt;h1 id="ffmpeg-视频处理入门教程">FFmpeg 视频处理入门教程&lt;/h1>
&lt;p>作者： &lt;a href="https://www.ruanyifeng.com/">阮一峰&lt;/a>
日期： &lt;a href="https://www.ruanyifeng.com/blog/2020/01/">2020 年 1 月 14 日&lt;/a>
&lt;a href="https://www.ffmpeg.org/">FFmpeg&lt;/a> 是视频处理最常用的开源软件。
它功能强大，用途广泛，大量用于视频网站和商业软件（比如 Youtube 和 iTunes），也是许多音频和视频格式的标准编码/解码实现。&lt;/p>
&lt;p>FFmpeg 本身是一个庞大的项目，包含许多组件和库文件，最常用的是它的命令行工具。本文介绍 FFmpeg 命令行如何处理视频，比桌面视频处理软件更简洁高效。
如果你还没安装，可以根据&lt;a href="https://www.ffmpeg.org/download.html">官方文档&lt;/a> 先完成安装。&lt;/p>
&lt;h2 id="一概念">一、概念&lt;/h2>
&lt;p>介绍 FFmpeg 用法之前，需要了解一些视频处理的基本概念。&lt;/p>
&lt;h3 id="11-容器">1.1 容器&lt;/h3>
&lt;p>视频文件本身其实是一个容器（container），里面包括了视频和音频，也可能有字幕等其他内容。
常见的容器格式有以下几种。一般来说，视频文件的后缀名反映了它的容器格式。&lt;/p>
&lt;ul>
&lt;li>MP4&lt;/li>
&lt;li>MKV&lt;/li>
&lt;li>WebM&lt;/li>
&lt;li>AVI&lt;/li>
&lt;/ul>
&lt;p>下面的命令查看 FFmpeg 支持的容器。
$ ffmpeg -formats&lt;/p>
&lt;h3 id="12-编码格式">1.2 编码格式&lt;/h3>
&lt;p>视频和音频都需要经过编码，才能保存成文件。不同的编码格式（CODEC），有不同的压缩率，会导致文件大小和清晰度的差异。
常用的视频编码格式如下。&lt;/p>
&lt;ul>
&lt;li>H.262&lt;/li>
&lt;li>H.264&lt;/li>
&lt;li>H.265&lt;/li>
&lt;/ul>
&lt;p>上面的编码格式都是有版权的，但是可以免费使用。此外，还有几种无版权的视频编码格式。&lt;/p>
&lt;ul>
&lt;li>VP8&lt;/li>
&lt;li>VP9&lt;/li>
&lt;li>AV1&lt;/li>
&lt;/ul>
&lt;p>常用的音频编码格式如下。&lt;/p>
&lt;ul>
&lt;li>MP3&lt;/li>
&lt;li>AAC&lt;/li>
&lt;/ul>
&lt;p>上面所有这些都是有损的编码格式，编码后会损失一些细节，以换取压缩后较小的文件体积。无损的编码格式压缩出来的文件体积较大，这里就不介绍了。
下面的命令可以查看 FFmpeg 支持的编码格式，视频编码和音频编码都在内。
$ ffmpeg -codecs&lt;/p>
&lt;h3 id="13-编码器">1.3 编码器&lt;/h3>
&lt;p>编码器（encoders）是实现某种编码格式的库文件。只有安装了某种格式的编码器，才能实现该格式视频/音频的编码和解码。
以下是一些 FFmpeg 内置的视频编码器。&lt;/p>
&lt;ul>
&lt;li>libx264：最流行的开源 H.264 编码器&lt;/li>
&lt;li>NVENC：基于 NVIDIA GPU 的 H.264 编码器&lt;/li>
&lt;li>libx265：开源的 HEVC 编码器&lt;/li>
&lt;li>libvpx：谷歌的 VP8 和 VP9 编码器&lt;/li>
&lt;li>libaom：AV1 编码器&lt;/li>
&lt;/ul>
&lt;p>音频编码器如下。&lt;/p>
&lt;ul>
&lt;li>libfdk-aac&lt;/li>
&lt;li>aac&lt;/li>
&lt;/ul>
&lt;p>下面的命令可以查看 FFmpeg 已安装的编码器。
$ ffmpeg -encoders&lt;/p>
&lt;h2 id="二ffmpeg-的使用格式">二、FFmpeg 的使用格式&lt;/h2>
&lt;p>FFmpeg 的命令行参数非常多，可以分成五个部分。
$ ffmpeg {1} {2} -i {3} {4} {5}
上面命令中，五个部分的参数依次如下。&lt;/p>
&lt;ol>
&lt;li>全局参数&lt;/li>
&lt;li>输入文件参数&lt;/li>
&lt;li>输入文件&lt;/li>
&lt;li>输出文件参数&lt;/li>
&lt;li>输出文件&lt;/li>
&lt;/ol>
&lt;p>参数太多的时候，为了便于查看，ffmpeg 命令可以写成多行。
$ ffmpeg \ [全局参数] \ [输入文件参数] \ -i [输入文件] \ [输出文件参数] \ [输出文件]
下面是一个例子。
$ ffmpeg \ -y \ # 全局参数 -c:a libfdk_aac -c:v libx264 \ # 输入文件参数 -i input.mp4 \ # 输入文件 -c:v libvpx-vp9 -c:a libvorbis \ # 输出文件参数 output.webm # 输出文件
上面的命令将 mp4 文件转成 webm 文件，这两个都是容器格式。输入的 mp4 文件的音频编码格式是 aac，视频编码格式是 H.264；输出的 webm 文件的视频编码格式是 VP9，音频格式是 Vorbis。
如果不指明编码格式，FFmpeg 会自己判断输入文件的编码。因此，上面的命令可以简单写成下面的样子。
$ ffmpeg -i input.avi output.mp4&lt;/p>
&lt;h2 id="三常用命令行参数">三、常用命令行参数&lt;/h2>
&lt;p>FFmpeg 常用的命令行参数如下。&lt;/p>
&lt;ul>
&lt;li>-c：指定编码器&lt;/li>
&lt;li>-c copy：直接复制，不经过重新编码（这样比较快）&lt;/li>
&lt;li>-c:v：指定视频编码器&lt;/li>
&lt;li>-c:a：指定音频编码器&lt;/li>
&lt;li>-i：指定输入文件&lt;/li>
&lt;li>-an：去除音频流&lt;/li>
&lt;li>-vn： 去除视频流&lt;/li>
&lt;li>-preset：指定输出的视频质量，会影响文件的生成速度，有以下几个可用的值 ultrafast, superfast, veryfast, faster, fast, medium, slow, slower, veryslow。&lt;/li>
&lt;li>-y：不经过确认，输出时直接覆盖同名文件。&lt;/li>
&lt;/ul>
&lt;h2 id="四常见用法">四、常见用法&lt;/h2>
&lt;p>下面介绍 FFmpeg 几种常见用法。&lt;/p>
&lt;h3 id="41-查看文件信息">4.1 查看文件信息&lt;/h3>
&lt;p>查看视频文件的元信息，比如编码格式和比特率，可以只使用-i 参数。
$ ffmpeg -i input.mp4
上面命令会输出很多冗余信息，加上-hide_banner 参数，可以只显示元信息。
$ ffmpeg -i input.mp4 -hide_banner&lt;/p>
&lt;h3 id="42-转换编码格式">4.2 转换编码格式&lt;/h3>
&lt;p>转换编码格式（transcoding）指的是， 将视频文件从一种编码转成另一种编码。比如转成 H.264 编码，一般使用编码器 libx264，所以只需指定输出文件的视频编码器即可。
$ ffmpeg -i [input.file] -c:v libx264 output.mp4
下面是转成 H.265 编码的写法。
$ ffmpeg -i [input.file] -c:v libx265 output.mp4&lt;/p>
&lt;h3 id="43-转换容器格式">4.3 转换容器格式&lt;/h3>
&lt;p>转换容器格式（transmuxing）指的是，将视频文件从一种容器转到另一种容器。下面是 mp4 转 webm 的写法。
$ ffmpeg -i input.mp4 -c copy output.webm
上面例子中，只是转一下容器，内部的编码格式不变，所以使用-c copy 指定直接拷贝，不经过转码，这样比较快。&lt;/p>
&lt;h3 id="44-调整码率">4.4 调整码率&lt;/h3>
&lt;p>调整码率（transrating）指的是，改变编码的比特率，一般用来将视频文件的体积变小。下面的例子指定码率最小为 964K，最大为 3856K，缓冲区大小为 2000K。
$ ffmpeg \ -i input.mp4 \ -minrate 964K -maxrate 3856K -bufsize 2000K \ output.mp4&lt;/p>
&lt;h3 id="45-改变分辨率transsizing">4.5 改变分辨率（transsizing）&lt;/h3>
&lt;p>下面是改变视频分辨率（transsizing）的例子，从 1080p 转为 480p 。
$ ffmpeg \ -i input.mp4 \ -vf scale=480:-1 \ output.mp4&lt;/p>
&lt;h3 id="46-提取音频">4.6 提取音频&lt;/h3>
&lt;p>有时，需要从视频里面提取音频（demuxing），可以像下面这样写。
$ ffmpeg \ -i input.mp4 \ -vn -c:a copy \ output.aac
上面例子中，-vn 表示去掉视频，-c:a copy 表示不改变音频编码，直接拷贝。&lt;/p>
&lt;h3 id="47-添加音轨">4.7 添加音轨&lt;/h3>
&lt;p>添加音轨（muxing）指的是，将外部音频加入视频，比如添加背景音乐或旁白。
$ ffmpeg \ -i input.aac -i input.mp4 \ output.mp4
上面例子中，有音频和视频两个输入文件，FFmpeg 会将它们合成为一个文件。&lt;/p>
&lt;h3 id="48-截图">4.8 截图&lt;/h3>
&lt;p>下面的例子是从指定时间开始，连续对 1 秒钟的视频进行截图。
$ ffmpeg \ -y \ -i input.mp4 \ -ss 00:01:24 -t 00:00:01 \ output_%3d.jpg
如果只需要截一张图，可以指定只截取一帧。
$ ffmpeg \ -ss 01:23:45 \ -i input \ -vframes 1 -q:v 2 \ output.jpg
上面例子中，-vframes 1 指定只截取一帧，-q:v 2 表示输出的图片质量，一般是 1 到 5 之间（1 为质量最高）。&lt;/p>
&lt;h3 id="49-裁剪">4.9 裁剪&lt;/h3>
&lt;p>裁剪（cutting）指的是，截取原始视频里面的一个片段，输出为一个新视频。可以指定开始时间（start）和持续时间（duration），也可以指定结束时间（end）。
$ ffmpeg -ss [start] -i [input] -t [duration] -c copy [output] $ ffmpeg -ss [start] -i [input] -to [end] -c copy [output]
下面是实际的例子。
$ ffmpeg -ss 00:01:50 -i [input] -t 10.5 -c copy [output] $ ffmpeg -ss 2.5 -i [input] -to 10 -c copy [output]
上面例子中，-c copy 表示不改变音频和视频的编码格式，直接拷贝，这样会快很多。&lt;/p>
&lt;h3 id="410-为音频添加封面">4.10 为音频添加封面&lt;/h3>
&lt;p>有些视频网站只允许上传视频文件。如果要上传音频文件，必须为音频添加封面，将其转为视频，然后上传。
下面命令可以将音频文件，转为带封面的视频文件。
$ ffmpeg \ -loop 1 \ -i cover.jpg -i input.mp3 \ -c:v libx264 -c:a aac -b:a 192k -shortest \ output.mp4
上面命令中，有两个输入文件，一个是封面图片 cover.jpg，另一个是音频文件 input.mp3。-loop 1 参数表示图片无限循环，-shortest 参数表示音频文件结束，输出视频就结束。&lt;/p>
&lt;h2 id="五参考链接">五、参考链接&lt;/h2>
&lt;ul>
&lt;li>&lt;a href="https://github.com/leandromoreira/ffmpeg-libav-tutorial#chapter-3---transcoding">FFmpeg libav tutorial&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://github.com/leandromoreira/digital_video_introduction/blob/master/encoding_pratical_examples.md#split-and-merge-smoothly">Digital video introduction&lt;/a>&lt;/li>
&lt;li>&lt;a href="http://slhck.info/ffmpeg-encoding-course/">FFmpeg encoding and editing course&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://dragonquest64.blogspot.com/2019/10/making-slideshows-wffmpeg.html">Making Slideshows w/FFMpeg&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://itsfoss.com/ffmpeg/">The Complete Guide for Using ffmpeg in Linux&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://bernd.dev/2020/04/adding-subtitles/">Adding subtitles to your videos the easy way&lt;/a>&lt;/li>
&lt;/ul>
&lt;p>（完）&lt;/p></description></item><item><title>Docs: OpenStack 部署与清理</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/10.%E4%BA%91%E5%8E%9F%E7%94%9F/1.3.openstack-%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%BC%96%E6%8E%92%E7%B3%BB%E7%BB%9F/openstack%E9%83%A8%E7%BD%B2%E4%B8%8E%E6%B8%85%E7%90%86/openstack-%E9%83%A8%E7%BD%B2%E4%B8%8E%E6%B8%85%E7%90%86/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/10.%E4%BA%91%E5%8E%9F%E7%94%9F/1.3.openstack-%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%BC%96%E6%8E%92%E7%B3%BB%E7%BB%9F/openstack%E9%83%A8%E7%BD%B2%E4%B8%8E%E6%B8%85%E7%90%86/openstack-%E9%83%A8%E7%BD%B2%E4%B8%8E%E6%B8%85%E7%90%86/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;/blockquote>
&lt;p>&lt;a href="https://thoughts.teambition.com/workspaces/603b04c9f83f2a00428f7321/folders/5fa948644cc5830001751d72">https://thoughts.teambition.com/workspaces/603b04c9f83f2a00428f7321/folders/5fa948644cc5830001751d72&lt;/a>&lt;/p>
&lt;p>部署 OpenStack 有多种方式&lt;/p>
&lt;ul>
&lt;li>手动部署 OpenStack 中的每一个组件
&lt;ul>
&lt;li>&lt;a href="https://docs.openstack.org/xena/install/">https://docs.openstack.org/xena/install/&lt;/a>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>使用自动化部署工具，部署工具有多种类型可供选择
&lt;ul>
&lt;li>&lt;a href="https://docs.openstack.org/xena/deploy/">https://docs.openstack.org/xena/deploy/&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://docs.openstack.org/project-deploy-guide/charm-deployment-guide/latest/">OpenStack Charms&lt;/a> # 使用 MAAS 和 Juju 部署。
&lt;ul>
&lt;li>一种完善的部署方式，基于 Ubuntu 开发 MAAS。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;a href="https://docs.openstack.org/project-deploy-guide/kolla-ansible/latest/">OpenStack Kolla&lt;/a> # 在容器中使用 Ansible 部署
&lt;ul>
&lt;li>非常简单高效得部署一个用来 生产、开发、测试 的 OpenStack。支持 all-in-one 和 multinode 两种模式(即所有组件都在一个节点或分散在多个节点)&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>其他&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h2 id="支持的操作系统">支持的操作系统&lt;/h2>
&lt;p>Kolla Ansible 支持以下主机操作系统 (OS)：&lt;/p>
&lt;blockquote>
&lt;p>从 Ussuri 版本开始，OpenStack 不再支持 CentOS 7 作为主机操作系统。Train 版本同时支持 CentOS 7 和 8，并提供了迁移路径。有关迁移到 CentOS 8 的信息，请参阅 &lt;a href="https://docs.openstack.org/kolla-ansible/train/user/centos8.html">Kolla Ansible Train 文档&lt;/a>。
不再支持 CentOS Linux 8（相对于 CentOS Stream 8）作为主机操作系统。Victoria 版本将来会同时支持 CentOS Linux 8 和 CentOS Stream 8，并提供迁移途径。&lt;/p>
&lt;/blockquote>
&lt;ul>
&lt;li>CentOS Stream 8&lt;/li>
&lt;li>Debian Bullseye (11)&lt;/li>
&lt;li>RHEL 8（已弃用）&lt;/li>
&lt;li>Rocky Linux 8&lt;/li>
&lt;li>Ubuntu Focal (20.04)&lt;/li>
&lt;/ul>
&lt;h2 id="支持的容器镜像">支持的容器镜像&lt;/h2>
&lt;p>为获得最佳结果，基本容器映像分发应与主机操作系统分发匹配。支持以下值 kolla_base_distro：&lt;/p>
&lt;ul>
&lt;li>centos&lt;/li>
&lt;li>debian&lt;/li>
&lt;li>rhel（已弃用）&lt;/li>
&lt;li>ubuntu&lt;/li>
&lt;/ul>
&lt;p>有关哪些发行版支持哪些图像的详细信息，请参阅 &lt;a href="https://docs.openstack.org/kolla/latest/support_matrix">Kolla 支持矩阵&lt;/a>。&lt;/p>
&lt;h1 id="kolla-ansible">Kolla-ansible&lt;/h1>
&lt;p>注意：&lt;/p>
&lt;ul>
&lt;li>宿主机至少需要两个可用的网卡，在 &lt;code>/etc/kolla/globals.yml&lt;/code> 文件中，被描述为如下两个关键字
&lt;ul>
&lt;li>&lt;strong>network_interface&lt;/strong> # 管理网络、API 网络的网卡&lt;/li>
&lt;li>&lt;strong>neutron_external_interface&lt;/strong> # Neutron 外部接口就是指内网环境。该网络设备将会桥接到 &lt;code>ovs-switch&lt;/code> 这个桥设备上。虚拟机是通过这块网卡访问外网。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h2 id="安装依赖并使用虚拟环境">安装依赖并使用虚拟环境&lt;/h2>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>sudo apt update
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>sudo apt install python3-dev libffi-dev gcc libssl-dev
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>创建一个虚拟环境以安装部署工具&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>export KOLLA_DIR&lt;span style="color:#f92672">=&lt;/span>/root/kolla
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>mkdir -p &lt;span style="color:#e6db74">${&lt;/span>KOLLA_DIR&lt;span style="color:#e6db74">}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>sudo apt install python3-venv
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>python3 -m venv &lt;span style="color:#e6db74">${&lt;/span>KOLLA_DIR&lt;span style="color:#e6db74">}&lt;/span>/venv
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>source &lt;span style="color:#e6db74">${&lt;/span>KOLLA_DIR&lt;span style="color:#e6db74">}&lt;/span>/venv/bin/activate
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>pip install -U pip -i https://pypi.tuna.tsinghua.edu.cn/simple
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>pip install &lt;span style="color:#e6db74">&amp;#39;ansible&amp;lt;5.0&amp;#39;&lt;/span> -i https://pypi.tuna.tsinghua.edu.cn/simple
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="安装-kolla-ansible">安装 Kolla-ansible&lt;/h2>
&lt;p>这里说的 Kolla-ansible 主要指的是用于部署 Openstack 的 Ansible Playbook~~~~&lt;/p>
&lt;p>确定要安装的版本。Kolla-ansible 的版本号与 Openstack 的版本号保持一致，这里以 Openstack 的 &lt;code>xena&lt;/code> 版本为例&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>export KOLLA_BRANCH_NAME&lt;span style="color:#f92672">=&lt;/span>xena
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>使用 pip 安装 kolla-ansible 及其依赖项。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>pip install git+https://opendev.org/openstack/kolla-ansible@&lt;span style="color:#e6db74">${&lt;/span>KOLLA_BRANCH_NAME&lt;span style="color:#e6db74">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>创建配置目录&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>sudo mkdir -p /etc/kolla
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>sudo chown $USER:$USER /etc/kolla
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>cp -r &lt;span style="color:#e6db74">${&lt;/span>KOLLA_DIR&lt;span style="color:#e6db74">}&lt;/span>/venv/share/kolla-ansible/etc_examples/kolla/* /etc/kolla
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>将 Ansible Playbook 所需的 Inventory 拷贝到当前目录&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>cp &lt;span style="color:#e6db74">${&lt;/span>KOLLA_DIR&lt;span style="color:#e6db74">}&lt;/span>/venv/share/kolla-ansible/ansible/inventory/* .
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="配置-ansible">配置 Ansible&lt;/h2>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>mkdir -p /etc/ansible
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>tee /etc/ansible/ansible.cfg &amp;gt; /dev/null &lt;span style="color:#e6db74">&amp;lt;&amp;lt;EOF
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">[defaults]
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">host_key_checking=False
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">pipelining=True
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">forks=100
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">EOF&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="all-in-one-部署-openstack">All-in-one 部署 OpenStack&lt;/h2>
&lt;h3 id="配置-kolla">配置 Kolla&lt;/h3>
&lt;p>为 &lt;code>/etc/kolla/passwords.yml&lt;/code> 文件生成密码&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>kolla-genpwd
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>配置 &lt;code>/etc/kolla/globals.yml&lt;/code> 文件&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>kolla_base_distro: &lt;span style="color:#e6db74">&amp;#34;ubuntu&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>kolla_install_type: &lt;span style="color:#e6db74">&amp;#34;source&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>network_interface: &lt;span style="color:#e6db74">&amp;#34;eno3&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># neutron 外部接口就是指内网环境。该网络设备将会桥街道 ovs-switch 这个桥设备上。&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>neutron_external_interface: &lt;span style="color:#e6db74">&amp;#34;eno4&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>kolla_internal_vip_address: &lt;span style="color:#e6db74">&amp;#34;192.168.88.236&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>enable_cinder: &lt;span style="color:#e6db74">&amp;#34;yes&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>openstack_release: &lt;span style="color:#e6db74">&amp;#34;xena&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>enable_haproxy: &lt;span style="color:#e6db74">&amp;#34;no&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="配置-inventory">配置 Inventory&lt;/h3>
&lt;p>略，直接使用 localhost 即可&lt;/p>
&lt;h3 id="部署依赖并检查环境">部署依赖并检查环境&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>kolla-ansible -i ./all-in-one bootstrap-servers
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>kolla-ansible -i ./all-in-one prechecks
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="部署-openstack">部署 OpenStack&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>kolla-ansible -i ./all-in-one pull ？？？待验证
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>kolla-ansible -i ./all-in-one deploy
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="multinode-部署-openstack">Multinode 部署 OpenStack&lt;/h2></description></item><item><title>Docs: OpenTelemetry</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/6.%E5%8F%AF%E8%A7%82%E6%B5%8B%E6%80%A7/opentelemetry/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/6.%E5%8F%AF%E8%A7%82%E6%B5%8B%E6%80%A7/opentelemetry/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://github.com/open-telemetry">GitHub 组织，OpenTelemetry&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://opentelemetry.io/">官网&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://opentelemetry.io/docs/">官方文档&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://mp.weixin.qq.com/s/bcziZg8RhCrMGYgFeN76cw">公众号-OpenTelemetry，OpenTelemetry 核心原理篇 ：怎么理解分布式链路追踪技术？&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://mp.weixin.qq.com/s/3dD0hIuqpXdepLVC6V7aoA">公众号-OpenTelemetry，在生产环境如何选择靠谱的 APM 系统&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>&lt;strong>OpenTelemetry(开放式遥测技术，简称 OTel)&lt;/strong> 于 2019 年 5 月由 &lt;a href="https://opentracing.io/">OpenTracing&lt;/a> 与 OpenCensus 合并而成(&lt;a href="https://opensource.googleblog.com/2019/05/opentelemetry-merger-of-opencensus-and.html">Google Open Source&lt;/a>)，是一组 API、SDK、工具、更是一种遥测标准，旨在创建和管理 **Telemetry Data(遥测数据)。**通过 OpenTelemetry 标准创建的程序，可以采集 OpenTelemetry 标准的遥测数据，并发送到我们指定的后端中。OpenTelemetry 支持各种流行的开源后端项目，比如 Prometheus、Jaeger 等。&lt;/p>
&lt;blockquote>
&lt;p>遥测数据包括：Traces(链路追踪数据)、Metrics(指标数据)、logs(日志数据)&lt;/p>
&lt;/blockquote>
&lt;p>注意：OpenTelemetry 不是像 Prometheus、Jaeger 那样的可观察性后端。相反，OpenTelemetry 支持将数据导出到各种开源和商业的后端产品中，它提供了一个可插拔的架构，因此可以轻松添加其他技术协议和格式。&lt;/p>
&lt;p>OTEL 之于可观测性，类似 OCI 之于容器。&lt;/p>
&lt;h2 id="opentelemetry-组件">OpenTelemetry 组件&lt;/h2>
&lt;p>目前，OpenTelemetry 由以下几个主要组件组成：&lt;/p>
&lt;ul>
&lt;li>&lt;strong>规范&lt;/strong> # 与编程语言无关的规范，规定了遥测数据格式等&lt;/li>
&lt;li>&lt;strong>工具&lt;/strong> # 用于采集、转换、导出遥测数据的工具&lt;/li>
&lt;li>&lt;strong>SDK&lt;/strong> # 用于为各种编程语言提供编写符合 OpenTelemetry 规范的工具&lt;/li>
&lt;li>&lt;strong>自动 instrumentation 和 贡献包&lt;/strong> # 没搞懂这是什么？&lt;/li>
&lt;/ul>
&lt;h2 id="opentelemetry-历史">OpenTelemetry 历史&lt;/h2>
&lt;h1 id="opentelemetry-实现">OpenTelemetry 实现&lt;/h1>
&lt;p>&lt;a href="https://github.com/grafana/agent">GitHub 项目，grafana/agent&lt;/a> #
&lt;a href="https://github.com/flashcatcloud/categraf">GitHub 项目，flashcatcloud/categraf&lt;/a> # 通过配置文件，采集所有数据，然后 Push 给 Prom(Prom 需要使用 &lt;code>--web.enable-remote-write-receiver&lt;/code> 为自身开启远程写功能)，暂时没有等待 pull 的功能(截止 2022.6.1 v0.1.0 版本)
&lt;a href="https://www.guance.com/">https://www.guance.com/&lt;/a> 观测云。。。。这个产品。。怎么说呢。。上来就让人各种注册才能体验的感觉很不好。。而且在云原生社区可观测性 SIG 群里，这家人的表达方式和处理事情的态度给人的感觉也不好~~工作内部矛盾放在群里说。。还揭露个人隐私。。。。o(╯□╰)o~&lt;/p>
&lt;h2 id="grafana-agent">Grafana Agent&lt;/h2>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://github.com/grafana/agent">GitHub 项目，grafana/agent&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://grafana.com/docs/agent/latest/">官方文档&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>Grafana Agent 收集遥测数据并将其转发到 Grafana Stack、Grafana Cloud 或 Grafana Enterprise 的开源部署，然后可以在其中分析您的数据。您可以在 Kubernetes 和 Docker 上安装 Grafana Agent，或者作为 Linux、macOS 和 Windows 机器的系统进程。&lt;/p>
&lt;p>Grafana Agent 是开源的，其源代码可在 GitHub 上的&lt;a href="https://github.com/grafana/agent">https://github.com/grafana/agent&lt;/a>上获得。&lt;/p>
&lt;p>Grafana Agent 适用于希望收集和转发遥测数据以进行分析和待命警报的工程师、操作员或管理员。那些运行 Grafana Agent 的人必须安装和配置 Grafana Agent 才能正确收集遥测数据并监控正在运行的代理的健康状况。&lt;/p></description></item><item><title>Docs: LogRotate(日志轮替)</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/6.%E5%8F%AF%E8%A7%82%E6%B5%8B%E6%80%A7/%E6%97%A5%E5%BF%97%E7%B3%BB%E7%BB%9F/logrotate%E6%97%A5%E5%BF%97%E8%BD%AE%E6%9B%BF/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/6.%E5%8F%AF%E8%A7%82%E6%B5%8B%E6%80%A7/%E6%97%A5%E5%BF%97%E7%B3%BB%E7%BB%9F/logrotate%E6%97%A5%E5%BF%97%E8%BD%AE%E6%9B%BF/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://mp.weixin.qq.com/s/b_CWt_ycvnbQG9TXPqRoCQ">公众号-马哥 Linux 运维，[译] 理解 logrotate 实用工具&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>为了防止日志文件持续被写入文件导致过于庞大，那么就需要对日志进行拆分，每隔一段时间就把日志文件保存(打包压缩)起来，然后再创建一个新的空文件继续接收日志，来回循环该过程直到通过配置规定的保留日期，来清除存在过久的日志。通过这种方式来进行日志的归档，分类，清理。这就是 LogRotate 所做的事情。是否进行轮替会有一系列的配置，比如文件的大小达到 N 会轮替一次，每隔多少天轮替一次等等。&lt;/p>
&lt;p>logrotate 只是一个命令行工具，不以守护进程的方式运行在后台，默认情况下，logrotate 命令作为放在 /etc/cron.daily 中的 cron 任务，每天运行一次，该任务会根据设置的策略进行日志文件的检查，其中达到设置中满足轮替配置的日志文件将被轮替。&lt;/p>
&lt;h1 id="关联文件与配置">关联文件与配置&lt;/h1>
&lt;p>/etc/logrotate.conf # logrotate 基本配置文件
/etc/logrotate.d/* # 对基本文件的扩展，该目录下的文件的配置会被包含在基本配置文件中。该目录下一般是一个程序一个文件，每个程序都有自己的日志轮替配置。
/etc/cron.daily/logrotate # 该文件定义了 cron 定时任务执行日志轮替工作的时间
/var/lib/logrotate.status # logrotate 的执行历史&lt;/p>
&lt;h2 id="logrotateconf-配置文件详解">logrotate.conf 配置文件详解&lt;/h2>
&lt;ul>
&lt;li>/PATH/TO/FILES {&amp;hellip;} #指定想要轮替的日志文件，可以通过＊通配指定多个文件名
&lt;ul>
&lt;li>&lt;strong>copytruncate&lt;/strong> # 把正在输出的日志拷(copy)一份出来，再清空(trucate)原来的日志。&lt;/li>
&lt;li>&lt;strong>compress&lt;/strong> # 压缩日志文件的所有非当前版本&lt;/li>
&lt;li>&lt;strong>dateext&lt;/strong> # 切换后的日志文件会附加上一个短横线和 YYYYMMDD 格式的日期,&lt;/li>
&lt;li>&lt;strong>daily&lt;/strong> # 日志文件将每天轮替一次。其它可用值为 monthly(每月)，weekly(每周)、yearly(每年)&lt;/li>
&lt;li>&lt;strong>delaycompress&lt;/strong> # 在轮替任务完成后，已轮替的归档将使用 gzip 进行压缩&lt;/li>
&lt;li>&lt;strong>errors &lt;!-- raw HTML omitted -->&lt;/strong> # 给指定邮箱发送错误通知&lt;/li>
&lt;li>&lt;strong>missingok&lt;/strong> # 如果日志文件丢失，不要显示错误&lt;/li>
&lt;li>&lt;strong>notifempty&lt;/strong> # 如果日志文件为空，则不轮换日志文件&lt;/li>
&lt;li>&lt;strong>olddir &lt;!-- raw HTML omitted -->&lt;/strong> # 指定日志文件的旧版本放在 “DIR”目录 中&lt;/li>
&lt;li>&lt;strong>postrotate 和 endscript&lt;/strong> # 在所有其它指令完成后，postrotate 和 endscript 里面指定的命令将被执行。在这种情况下，rsyslogd 进程将立即再次读取其配置并继续运行。&lt;/li>
&lt;li>&lt;strong>rotate N&lt;/strong> # 共存储 N 个轮替后日志。当产生第 N+1 个轮替后的日志，时间最久的日志将被删除&lt;/li>
&lt;li>&lt;strong>sharedscripts&lt;/strong> # 有多个日志需要轮替时，只执行一次脚本&lt;/li>
&lt;li>&lt;strong>size &lt;!-- raw HTML omitted -->&lt;/strong> # 在日志文件大小大于 LogSize（例如 100K，4M）时进行轮替&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>配置样例&lt;/p>
&lt;pre>&lt;code>/var/log/nginx/*log {
daily
rotate 10
missingok
notifempty
compress
dateext
sharedscripts
postrotate
/bin/kill -USR1 $(cat /var/run/ngnix/nginx.pid 2&amp;gt;/dev/null) 2&amp;gt;/dev/null
endscript
}
&lt;/code>&lt;/pre>
&lt;p>Note：关于 postrotate
postrotate 后面跟随的是一个命令行，一般是用来重新生成日志文件或者冲定义应用所指向的文件描述符（fd：file description），拿 nginx 和 uwsgi 为例：&lt;/p>
&lt;p>完成日志切割后创建新的 nginx 日志文件，此时该文件的 fd 发生改变&lt;/p>
&lt;p>nginx 中日志输出对应的文件 fd 未同步更新，nginx 会向原 fd 对应的日志文件写数据&lt;/p>
&lt;p>“/bin/kill -USR1 cat /var/run/nginx.pid || true”，更新 nginx 默认日志文件的 fd 到新建的日志文件（该效果等同于 reload）。&lt;/p>
&lt;p>关于/bin/kill -HUP&lt;/p>
&lt;p>&amp;ldquo;/bin/kill -USR1 &lt;code>cat /var/run/nginx.pid&lt;/code> || true&amp;rdquo;&lt;/p>
&lt;p>看到这条命令很容易想到：&lt;/p>
&lt;p>/bin/kill -HUP &lt;code>cat /var/run/nginx.pid 2&amp;gt; /dev/null&lt;/code> 2&amp;gt; /dev/null || true&lt;/p>
&lt;p>这两条命令的大概含义是重载 nginx 服务，目的是重新生成 nginx 的日志文件。&lt;/p>
&lt;h1 id="命令行工具">命令行工具&lt;/h1>
&lt;p>logrotate [OPTIONS&amp;hellip;]&lt;/p>
&lt;p>OPTIONS&lt;/p>
&lt;ul>
&lt;li>&lt;strong>-f&lt;/strong> # 告诉 logrotate 强制执行轮替，即使这不是必要的(i.e.测试轮替的配置文件是否可以正常运行)。 有时，在向 logrotate 配置文件添加新条目之后，或者如果已经手动删除旧的日志文件，这将是有用的，因为将创建新文件，并且日志记录将正常继续。&lt;/li>
&lt;/ul>
&lt;p>EXAMPLE&lt;/p>
&lt;ul>
&lt;li>logrotate -f /etc/logrotate.d/keepalived #使用/etc/logrotate.d/keepalived 配置文件执行轮替&lt;/li>
&lt;/ul>
&lt;p>PS:&lt;/p>
&lt;ul>
&lt;li>遇到不能记录日志的情况：kill -USR1 pid 重发信号量&lt;/li>
&lt;/ul></description></item><item><title>Docs: Journal</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/6.%E5%8F%AF%E8%A7%82%E6%B5%8B%E6%80%A7/%E6%97%A5%E5%BF%97%E7%B3%BB%E7%BB%9F/journal/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/6.%E5%8F%AF%E8%A7%82%E6%B5%8B%E6%80%A7/%E6%97%A5%E5%BF%97%E7%B3%BB%E7%BB%9F/journal/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://man7.org/linux/man-pages/man8/systemd-journald.service.8.html">Manual,systemd-journald.service(8)&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>相关服务说明&lt;/p>
&lt;ul>
&lt;li>systemd-Journald.service # 日志功能通过该 Unit 来实现，是一个用于收集和存储日志数据的系统服务，是系统启动前要启动的第一个进程，Journald 会把所有收集到的信息保存在内存中。&lt;/li>
&lt;li>rsyslog.service # 另一种日志数据持久化，Journald 会把日志信息转发给 rsyslog.service 进行处理和保存，如果没有 Journald，rsyslog 也可以自动生成日志而不用从 journald 去获取&lt;/li>
&lt;li>logrotate # logrotate 会对日志文件进行轮替操作，i.e.把已经非常大的日志文件改名后，创建一个新的日志文件，新产生的日志会保存在新文件中，老文件保留一定时期后会自动清除&lt;/li>
&lt;/ul>
&lt;h1 id="journald-关联文件与配置">Journald 关联文件与配置&lt;/h1>
&lt;p>&lt;strong>/etc/systemd/journal.conf&lt;/strong>&lt;/p>
&lt;h2 id="日志存放路径">日志存放路径&lt;/h2>
&lt;p>&lt;strong>/run/log/journal/${MACHINE-ID}/*&lt;/strong>
&lt;strong>/var/log/journal/${MACHINE-ID}/*&lt;/strong>&lt;/p>
&lt;p>默认情况下，journald 的日志保存在 /run/log/journal 中，系统重启就会清除。通过新建 /var/log/journal 目录，日志会自动记录到这个目录中，并永久存储。&lt;/p>
&lt;p>路径中的 MACHINE-ID 的值，可以通过 &lt;code>cat /etc/machine-id&lt;/code> 命令获取&lt;/p>
&lt;pre>&lt;code>root@lichenhao:/var/log/journal# ls
c14766a3e9ae49a3872fb9b7e2583710
root@lichenhao:/var/log/journal# cat /etc/machine-id
c14766a3e9ae49a3872fb9b7e2583710
&lt;/code>&lt;/pre>
&lt;p>所有 journal 程序生成的日志，都会存在 MACHIN-ID 目录下&lt;/p>
&lt;pre>&lt;code>root@lichenhao:/var/log/journal/c14766a3e9ae49a3872fb9b7e2583710# ll -h
total 153M
drwxr-sr-x+ 2 root systemd-journal 4.0K Feb 21 23:15 ./
drwxr-sr-x+ 3 root systemd-journal 46 Dec 9 17:19 ../
-rw-r-----+ 1 root systemd-journal 40M Dec 28 16:23 'system@aa6b2b3f8f9d46fdb169f9d8aaab56c3-0000000000000001-0005b6048d0b7824.journal'
-rw-r-----+ 1 root systemd-journal 32M Jan 22 12:39 'system@aa6b2b3f8f9d46fdb169f9d8aaab56c3-00000000000080e9-0005b781fc8c48d9.journal'
-rw-r-----+ 1 root systemd-journal 32M Feb 21 23:10 'system@aa6b2b3f8f9d46fdb169f9d8aaab56c3-000000000000df93-0005b975c74c3caf.journal'
-rw-r-----+ 1 root systemd-journal 40M Mar 12 15:25 system.journal
-rw-r-----+ 1 root systemd-journal 8.0M Dec 28 16:23 'user-1000@571778ddc0db463990a85592631fa5e8-0000000000000496-0005b6049323448d.journal'
&lt;/code>&lt;/pre>
&lt;h1 id="journalctl-命令行工具">journalctl 命令行工具&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://man7.org/linux/man-pages/man1/journalctl.1.html">Manual(手册)，journalctl(1)&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>Systemd 统一管理所有 Unit 的启动日志。带来的好处就是，可以只用 journalctl 一个命令，查看所有日志（内核日志和应用日志）。日志的配置文件是/etc/systemd/journald.conf。journalctl 功能强大，用法非常多。&lt;/p>
&lt;h2 id="syntax语法">Syntax(语法)&lt;/h2>
&lt;p>&lt;strong>journalctl [OPTIONS] [MATCHES]&lt;/strong>&lt;/p>
&lt;h3 id="options">OPTIONS&lt;/h3>
&lt;ul>
&lt;li>&lt;strong>&amp;ndash;disk-usage&lt;/strong> # 显示所有日志文件的磁盘使用情况，包括持久化和临时的日志。&lt;/li>
&lt;li>&lt;strong>-f, &amp;ndash;follow&lt;/strong> # 实时更新&lt;/li>
&lt;li>&lt;strong>&amp;ndash;file=FILE&lt;/strong> # 查看指定文件中的日志信息，FILE 可以使用&amp;quot;?&amp;ldquo;与&amp;rdquo;*&amp;ldquo;进行匹配。常用于查看从别的设备上拷贝过来的日志文件&lt;/li>
&lt;li>&lt;strong>-p UNM&lt;/strong> # 指定要显示的日志级别(NUM 为 0-7 级)&lt;/li>
&lt;li>&lt;strong>-u UNIT&lt;/strong> #显示指定的 unit 的日志信息&lt;/li>
&lt;/ul>
&lt;p>格式选项&lt;/p>
&lt;ul>
&lt;li>&lt;strong>&amp;ndash;no-pager&lt;/strong> # 在单一页面显示信息，不分页。默认情况下，若日志过长，需要使用 → 方向键翻页才能查看后面的日志内容。&lt;/li>
&lt;li>&lt;strong>-o, &amp;ndash;output=&lt;!-- raw HTML omitted -->&lt;/strong> # 指定输出格式。&lt;code>默认值：short&lt;/code>
&lt;ul>
&lt;li>可用的格式有：json、json-pretty、verbose、export、with-unit 等等&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>过滤选项&lt;/p>
&lt;ul>
&lt;li>&lt;strong>&amp;ndash;output-fields=FIELD&lt;/strong> # 显示指定字段的日志，多个字段以 &lt;code>,&lt;/code> 分割。
&lt;ul>
&lt;li>字段筛选仅对 -o 选项指定的 verbose、export、json、json-pretty、json-sse、json-seq 这几个输出格式有效&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>-S, &amp;ndash;since TIME&lt;/strong> 与** -U, &amp;ndash;unitl TIME** # 设置输出日志信息的开始与结束时间&lt;/li>
&lt;/ul>
&lt;h2 id="example">EXAMPLE&lt;/h2>
&lt;ul>
&lt;li>查看指定用户的日志
&lt;ul>
&lt;li>sudo journalctl _UID=33 &amp;ndash;since today&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>查看指定进程的日志
&lt;ul>
&lt;li>sudo journalctl _PID=1&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>以 JSON 格式仅输出 MESSAGE 与 _CMDLINE 字段的消息
&lt;ul>
&lt;li>journalctl -u docker -ojson-pretty &amp;ndash;output-fields=MESSAGE,_CMDLINE&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>查看指定时间的日志
&lt;ul>
&lt;li>sudo journalctl &amp;ndash;since=&amp;ldquo;2012-10-30 18:17:16&amp;rdquo;&lt;/li>
&lt;li>sudo journalctl &amp;ndash;since &amp;ldquo;20 min ago&amp;rdquo;&lt;/li>
&lt;li>sudo journalctl &amp;ndash;since yesterday&lt;/li>
&lt;li>sudo journalctl &amp;ndash;since 09:00 &amp;ndash;until &amp;ldquo;1 hour ago&amp;rdquo;&lt;/li>
&lt;li>journalctl &amp;ndash;since &amp;ldquo;2018-11-13&amp;rdquo; &amp;ndash;until &amp;ldquo;2018-11-14 03:00&amp;rdquo;&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h1 id="查看所有日志默认情况下-只保存本次启动的日志">查看所有日志（默认情况下 ，只保存本次启动的日志）&lt;/h1>
&lt;p>$ sudo journalctl&lt;/p>
&lt;h1 id="查看内核日志不显示应用日志">查看内核日志（不显示应用日志）&lt;/h1>
&lt;p>$ sudo journalctl -k&lt;/p>
&lt;h1 id="查看系统本次启动的日志">查看系统本次启动的日志&lt;/h1>
&lt;p>$ sudo journalctl -b&lt;/p>
&lt;p>$ sudo journalctl -b -0&lt;/p>
&lt;h1 id="查看上一次启动的日志需更改设置">查看上一次启动的日志（需更改设置）&lt;/h1>
&lt;p>$ sudo journalctl -b -1&lt;/p>
&lt;h1 id="显示尾部的最新-10-行日志">显示尾部的最新 10 行日志&lt;/h1>
&lt;p>$ sudo journalctl -n&lt;/p>
&lt;h1 id="显示尾部指定行数的日志">显示尾部指定行数的日志&lt;/h1>
&lt;p>$ sudo journalctl -n 20&lt;/p>
&lt;h1 id="查看指定服务的日志">查看指定服务的日志&lt;/h1>
&lt;p>$ sudo journalctl /usr/lib/systemd/systemd&lt;/p>
&lt;h1 id="查看某个路径的脚本的日志">查看某个路径的脚本的日志&lt;/h1>
&lt;p>$ sudo journalctl /usr/bin/bash&lt;/p>
&lt;h1 id="查看某个-unit-的日志">查看某个 Unit 的日志&lt;/h1>
&lt;p>$ sudo journalctl -u nginx.service&lt;/p>
&lt;p>$ sudo journalctl -u nginx.service &amp;ndash;since today&lt;/p>
&lt;h1 id="实时滚动显示某个-unit-的最新日志">实时滚动显示某个 Unit 的最新日志&lt;/h1>
&lt;p>$ sudo journalctl -u nginx.service -f&lt;/p>
&lt;h1 id="合并显示多个-unit-的日志">合并显示多个 Unit 的日志&lt;/h1>
&lt;p>$ journalctl -u nginx.service -u php-fpm.service &amp;ndash;since today&lt;/p>
&lt;h1 id="查看指定优先级及其以上级别的日志共有-8-级">查看指定优先级（及其以上级别）的日志，共有 8 级&lt;/h1>
&lt;h1 id="0-emerg">0: emerg&lt;/h1>
&lt;h1 id="1-alert">1: alert&lt;/h1>
&lt;h1 id="2-crit">2: crit&lt;/h1>
&lt;h1 id="3-err">3: err&lt;/h1>
&lt;h1 id="4-warning">4: warning&lt;/h1>
&lt;h1 id="5-notice">5: notice&lt;/h1>
&lt;h1 id="6-info">6: info&lt;/h1>
&lt;h1 id="7-debug">7: debug&lt;/h1>
&lt;p>$ sudo journalctl -p err -b&lt;/p>
&lt;h1 id="指定日志文件占据的最大空间">指定日志文件占据的最大空间&lt;/h1>
&lt;p>$ sudo journalctl &amp;ndash;vacuum-size=1G&lt;/p>
&lt;h1 id="指定日志文件保存多久">指定日志文件保存多久&lt;/h1>
&lt;p>$ sudo journalctl &amp;ndash;vacuum-time=1years&lt;/p></description></item><item><title>Docs: Docsy</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%AE%9E%E7%94%A8%E5%B7%A5%E5%85%B7/%E7%BD%91%E7%AB%99%E6%90%AD%E5%BB%BA/hugo/%E4%B8%BB%E9%A2%98/docsy/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%AE%9E%E7%94%A8%E5%B7%A5%E5%85%B7/%E7%BD%91%E7%AB%99%E6%90%AD%E5%BB%BA/hugo/%E4%B8%BB%E9%A2%98/docsy/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://github.com/google/docsy">GitHub 项目，google/docsy&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.docsy.dev/">官网&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>Kubernetes 的官网就是 Docsy 主题。&lt;/p>
&lt;p>注意：Docsy 必须使用 扩展版 hugo，即 hugo_extended。&lt;/p>
&lt;h1 id="预览和部署-docsy-主题网站">预览和部署 Docsy 主题网站&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://www.docsy.dev/docs/deployment/">官方文档，预览和部署&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;h2 id="准备环境">准备环境&lt;/h2>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>npm install -D autoprefixer
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>npm install -D postcss-cli
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>npm install -D postcss
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;blockquote>
&lt;p>若不在本地安装，则使用 &lt;code>hugo&lt;/code> 命令构建静态文件时将会报错&lt;/p>
&lt;/blockquote>
&lt;h2 id="生成站点文件">生成站点文件&lt;/h2>
&lt;h3 id="生成模板站点">生成模板站点&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>export MY_SITE_DIR&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;docsy&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>git clone https://github.com/google/docsy-example.git &lt;span style="color:#e6db74">${&lt;/span>MY_SITE_DIR&lt;span style="color:#e6db74">}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>cd &lt;span style="color:#e6db74">${&lt;/span>MY_SITE_DIR&lt;span style="color:#e6db74">}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>hugo server
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="生成空白站点">生成空白站点&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-Bash" data-lang="Bash">&lt;span style="display:flex;">&lt;span>hugo new site .
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>hugo mod init github.com/me/my-new-site
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>hugo mod get github.com/google/docsy@v0.6.0
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>cat &amp;gt;&amp;gt; config.toml &lt;span style="color:#e6db74">&amp;lt;&amp;lt;EOL
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">[module]
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">proxy = &amp;#34;direct&amp;#34;
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">[[module.imports]]
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">path = &amp;#34;github.com/google/docsy&amp;#34;
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">[[module.imports]]
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">path = &amp;#34;github.com/google/docsy/dependencies&amp;#34;
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">EOL&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="预览">预览&lt;/h2>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>hugo server
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="部署">部署&lt;/h2>
&lt;p>&lt;a href="https://lucumt.info/post/hugo/using-github-action-to-auto-build-deploy/">https://lucumt.info/post/hugo/using-github-action-to-auto-build-deploy/&lt;/a>
&lt;a href="https://tomial.github.io/posts/hugo%E4%BD%BF%E7%94%A8github-action%E8%87%AA%E5%8A%A8%E9%83%A8%E7%BD%B2%E5%8D%9A%E5%AE%A2%E5%88%B0github-pages/">https://tomial.github.io/posts/hugo%E4%BD%BF%E7%94%A8github-action%E8%87%AA%E5%8A%A8%E9%83%A8%E7%BD%B2%E5%8D%9A%E5%AE%A2%E5%88%B0github-pages/&lt;/a>
&lt;a href="https://www.bloghome.com.cn/post/git-zi-mo-kuai-yi-ge-cang-ku-bao-han-ling-yi-ge-cang-ku.html">https://www.bloghome.com.cn/post/git-zi-mo-kuai-yi-ge-cang-ku-bao-han-ling-yi-ge-cang-ku.html&lt;/a>
使用 Hugo 搭建 GitHub Pages &lt;a href="https://zz2summer.github.io/github-pages-hugo-%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/#%E4%B8%83%E6%97%A5%E5%B8%B8%E6%93%8D%E4%BD%9C">https://zz2summer.github.io/github-pages-hugo-%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/#%E4%B8%83%E6%97%A5%E5%B8%B8%E6%93%8D%E4%BD%9C&lt;/a>&lt;/p>
&lt;h2 id="常见问题">常见问题&lt;/h2>
&lt;p>&lt;a href="https://github.com/google/docsy/issues/235">构建站点时出错：# POSTCSS: failed to transform &amp;ldquo;scss/main.css&amp;rdquo;&lt;/a>&lt;/p>
&lt;h1 id="docsy-配置与关联文件">Docsy 配置与关联文件&lt;/h1>
&lt;p>Docsy 也会使用 Hugo 的 CONFIG 文件来配置站点。参考&lt;a href="https://www.docsy.dev/docs/adding-content/">官网，内容和定制&lt;/a>章节来修改 CONFIG 文件，以改变主题样式。&lt;/p></description></item><item><title>Docs: Java</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/2.%E7%BC%96%E7%A8%8B/%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/java/java/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/2.%E7%BC%96%E7%A8%8B/%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/java/java/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://www.java.com/">官网&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.liaoxuefeng.com/wiki/1252599548343744/1255876875896416#0">廖雪峰-Java教程，Java简介&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>Java 分三个版本：&lt;/p>
&lt;ul>
&lt;li>Java Standard Edition(标准版，简称 JSE)&lt;/li>
&lt;li>Java Enterprise Edition(企业版，简称 JEE)&lt;/li>
&lt;li>Java Micro Edition(微型版，简称 JME)&lt;/li>
&lt;/ul>
&lt;pre tabindex="0">&lt;code class="language-ascii" data-lang="ascii">┌───────────────────────────┐
│Java EE │
│ ┌────────────────────┐ │
│ │Java SE │ │
│ │ ┌─────────────┐ │ │
│ │ │ Java ME │ │ │
│ │ └─────────────┘ │ │
│ └────────────────────┘ │
└───────────────────────────┘
&lt;/code>&lt;/pre>&lt;h2 id="java-名词">Java 名词&lt;/h2>
&lt;p>JDK # Java Development Kit（Java 开发工具包）&lt;/p>
&lt;p>JRE # Java Runtime Environment（Java 运行时环境）&lt;/p>
&lt;p>JVM # Java Virtual Machin（Java 虚拟机）&lt;/p>
&lt;p>JSR # Java Specification Request（Java 规范）&lt;/p>
&lt;p>JCP # Java Community Process（Java 社区处理）&lt;/p>
&lt;p>JRE 中包含运行 &lt;strong>Java 字节码&lt;/strong> 的 JVM 和 库。但是，我们先要使用 JDK 将 Java 源码编译成 Java 字节码。因此 JDK 除了包含 JRE，还提供了编译器、调试器等开发工具。常说的安装 Java，其实就是指安装 JDK。&lt;/p>
&lt;pre tabindex="0">&lt;code class="language-ascii" data-lang="ascii"> ┌─ ┌──────────────────────────────────┐
│ │ Compiler, debugger, etc. │
│ └──────────────────────────────────┘
JDK ┌─ ┌──────────────────────────────────┐
│ │ │ │
│ JRE │ JVM + Runtime Library │
│ │ │ │
└─ └─ └──────────────────────────────────┘
┌───────┐┌───────┐┌───────┐┌───────┐
│Windows││ Linux ││ macOS ││others │
└───────┘└───────┘└───────┘└───────┘
&lt;/code>&lt;/pre>&lt;h2 id="学习资料">学习资料&lt;/h2>
&lt;p>&lt;a href="https://www.runoob.com/java/java-tutorial.html">菜鸟教程，Java&lt;/a>&lt;/p>
&lt;p>&lt;a href="https://www.liaoxuefeng.com/wiki/1252599548343744">廖雪峰，Java 教程&lt;/a>&lt;/p>
&lt;h2 id="andrioid">Andrioid&lt;/h2>
&lt;p>&lt;a href="https://zhuanlan.zhihu.com/p/340609888">Android与Java的关系&lt;/a>&lt;/p>
&lt;h1 id="hello-world">Hello World&lt;/h1>
&lt;h1 id="java-语言关键字">Java 语言关键字&lt;/h1>
&lt;h1 id="java-语言规范">Java 语言规范&lt;/h1></description></item><item><title>Docs: Java 工具</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/2.%E7%BC%96%E7%A8%8B/%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/java/java%E5%B7%A5%E5%85%B7/java-%E5%B7%A5%E5%85%B7/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/2.%E7%BC%96%E7%A8%8B/%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/java/java%E5%B7%A5%E5%85%B7/java-%E5%B7%A5%E5%85%B7/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;h2 id="参考">参考：&lt;/h2>
&lt;/blockquote>
&lt;h1 id="逆向工具">逆向工具&lt;/h1>
&lt;p>&lt;a href="https://www.jianshu.com/p/040d54a57e33">简书，某App接口逆向过程&lt;/a>&lt;/p>
&lt;h2 id="jadx">Jadx&lt;/h2>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://github.com/skylot/jadx">GitHub 项目，skylot/jadx&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>Jadx 是一个 Dex 到 Java 反编译器。用于从 Android Dex 和 Apk 文件生成 Java 源代码的 CLI 和 GUI 工具&lt;/p>
&lt;blockquote>
&lt;p>注意：请注意，在大多数情况下，jadx 无法100% 地反编译所有代码，因此会出现错误。检查&lt;a href="https://github.com/skylot/jadx/wiki/Troubleshooting-Q&amp;amp;A#decompilation-issues">故障排除指南&lt;/a>以了解解决方法&lt;/p>
&lt;/blockquote></description></item><item><title>Docs: Java 环境安装与使用</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/2.%E7%BC%96%E7%A8%8B/%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/java/java%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8/java%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/2.%E7%BC%96%E7%A8%8B/%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/java/java%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8/java%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://www.liaoxuefeng.com/wiki/1252599548343744/1280507291631649">廖雪峰-Java 教程，安装 JDK&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;h1 id="安装-java">安装 Java&lt;/h1>
&lt;p>安装好的 JavaSE 包含很多可执行程序&lt;/p>
&lt;ul>
&lt;li>java：这个可执行程序其实就是JVM，运行Java程序，就是启动JVM，然后让JVM执行指定的编译后的代码；&lt;/li>
&lt;li>javac：这是Java的编译器，它用于把Java源码文件（以&lt;code>.java&lt;/code>后缀结尾）编译为Java字节码文件（以&lt;code>.class&lt;/code>后缀结尾）；&lt;/li>
&lt;li>jar：用于把一组&lt;code>.class&lt;/code>文件打包成一个&lt;code>.jar&lt;/code>文件，便于发布；&lt;/li>
&lt;li>javadoc：用于从Java源码中自动提取注释并生成文档；&lt;/li>
&lt;li>jdb：Java调试器，用于开发阶段的运行调试。&lt;/li>
&lt;/ul>
&lt;h2 id="windows-安装">Windows 安装&lt;/h2>
&lt;p>从&lt;a href="https://www.oracle.com/java/technologies/downloads/">这里&lt;/a>下载 JavaSE&lt;/p>
&lt;p>解压到指定目录(我通常是在 &lt;code>D:/Tools/Java/jdk-${VERSION}&lt;/code>)，将该目录添加到 JAVA_HOME 环境变量&lt;/p>
&lt;p>将 &lt;code>%JAVA_HOME%/bin&lt;/code> 添加到 PATH 变量中。&lt;/p></description></item><item><title>Docs: Management</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/y.windows-%E7%AE%A1%E7%90%86/windows%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/powershell%E5%86%85%E7%BD%AE%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/management/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/y.windows-%E7%AE%A1%E7%90%86/windows%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/powershell%E5%86%85%E7%BD%AE%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/management/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://learn.microsoft.com/en-us/powershell/module/microsoft.powershell.management">官方文档，PowerShell-参考-Management 模块&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>管理模块可以让我们在 PowerShell 中管理系统中的进程、服务等。&lt;/p>
&lt;h1 id="服务管理工具">服务管理工具&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://learn.microsoft.com/en-us/powershell/scripting/samples/managing-services">官方文档，学习PowerShell-脚本示例-管理进程和服务-管理服务&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://docs.microsoft.com/zh-cn/dotnet/framework/windows-services/">https://docs.microsoft.com/zh-cn/dotnet/framework/windows-services/&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;h2 id="启动停止重启暂停服务">启动、停止、重启、暂停服务&lt;/h2>
&lt;ul>
&lt;li>Start-Service # 启动服务&lt;/li>
&lt;li>Stop-Service # 停止服务&lt;/li>
&lt;li>Suspend-Service # 暂停服务&lt;/li>
&lt;li>Resume-Service # 恢复服务&lt;/li>
&lt;li>Restart-Service # 重启服务&lt;/li>
&lt;/ul>
&lt;h2 id="get-service">Get-Service&lt;/h2>
&lt;p>列出服务。Get-Service 获取代表计算机上服务的对象，包括正在运行和已停止的服务。默认情况下，当不带参数运行 Get-Service 时，将返回本地计算机的所有服务。&lt;/p>
&lt;p>可以通过指定服务名称或服务的显示名称来指示此 cmdlet 仅获取特定服务，或者您可以将服务对象通过管道传递给此 cmdlet。&lt;/p>
&lt;p>默认显示三个字段&lt;/p>
&lt;ul>
&lt;li>Status # 服务状态&lt;/li>
&lt;li>Name # 服务名称&lt;/li>
&lt;li>DisplayName # 服务的显示名称&lt;/li>
&lt;/ul>
&lt;p>服务名称与显示名称可以在窗口页面看到效果，显示名称有点类似于简短的描述信息。&lt;/p>
&lt;h3 id="syntax语法">Syntax(语法)&lt;/h3>
&lt;p>Get-Service [OPTIONS] [-Name] &amp;lt;PATTERN&amp;gt;&lt;/p>
&lt;p>PATTERN 支持通配符，前面的 -Name 可以省略，该命令默认通过&lt;strong>服务名称&lt;/strong>进行匹配，将会列出所有匹配到的服务。&lt;/p>
&lt;p>OPTIONS&lt;/p>
&lt;ul>
&lt;li>&lt;strong>-DependentServices&lt;/strong> # 列出指定服务&lt;strong>被哪些服务依赖&lt;/strong>。&lt;/li>
&lt;li>&lt;strong>-RequiredServices&lt;/strong> # 列出指定服务&lt;strong>依赖于哪些服务&lt;/strong>。即.若想该服务正常运行则必须要提前运行的其他服务&lt;/li>
&lt;li>&lt;strong>-Include &amp;lt;String[]&amp;gt;&lt;/strong> #&lt;/li>
&lt;li>&lt;strong>-Exclude &amp;lt;String[]&amp;gt;&lt;/strong> #&lt;/li>
&lt;/ul>
&lt;h3 id="example">EXAMPLE&lt;/h3>
&lt;p>列出服务名 s 开头的所有服务并按照状态排序&lt;/p>
&lt;ul>
&lt;li>Get-Service &amp;ldquo;s*&amp;rdquo; | Sort-Object status&lt;/li>
&lt;/ul>
&lt;h2 id="new-service">New-Service&lt;/h2>
&lt;p>创建服务&lt;/p>
&lt;h2 id="remove-service">Remove-Service&lt;/h2>
&lt;p>移除服务&lt;/p>
&lt;h2 id="set-service">Set-Service&lt;/h2>
&lt;p>设置服务&lt;/p>
&lt;h1 id="进程管理工具">进程管理工具&lt;/h1>
&lt;p>&lt;a href="https://learn.microsoft.com/en-us/powershell/module/microsoft.powershell.management/get-process?view=powershell-7.3">Get-Process&lt;/a>
&lt;a href="https://learn.microsoft.com/en-us/powershell/module/microsoft.powershell.management/start-process?view=powershell-7.3">Start-Process&lt;/a>
&lt;a href="https://learn.microsoft.com/en-us/powershell/module/microsoft.powershell.management/stop-process?view=powershell-7.3">Stop-Process&lt;/a>
&lt;a href="https://learn.microsoft.com/en-us/powershell/module/microsoft.powershell.management/wait-process?view=powershell-7.3">Wait-Process&lt;/a>&lt;/p>
&lt;p>&lt;a href="https://learn.microsoft.com/en-us/powershell/module/microsoft.powershell.management/debug-process?view=powershell-7.3">Debug-Process&lt;/a>&lt;/p></description></item><item><title>Docs: Markdown</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%AE%9E%E7%94%A8%E5%B7%A5%E5%85%B7/%E5%86%99%E4%BD%9C/markdown/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%AE%9E%E7%94%A8%E5%B7%A5%E5%85%B7/%E5%86%99%E4%BD%9C/markdown/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;h2 id="参考">参考：&lt;/h2>
&lt;/blockquote>
&lt;h1 id="markdown-中的-latex-数学公式">Markdown 中的 LaTex 数学公式&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://blog.ypingcn.com/notes/Markdown/LaTex-math/">https://blog.ypingcn.com/notes/Markdown/LaTex-math/&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.jianshu.com/p/e74eb43960a1">简书，Markdown 数学公式语法&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>&lt;a href="https://blog.ypingcn.com/notes/Markdown/basic/">基础的 Markdown 语法&lt;/a> 中无法满足数学式子的表达需求，此时可以借助 Latex 语法完成。在 Markdown 中由前后两个 &lt;code>$$&lt;/code>包围的部分可以写 LaTex 源代码（最新版 Typora 已经支持）如下&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-markdown" data-lang="markdown">&lt;span style="display:flex;">&lt;span>$$
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>LaTex code
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>$$
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="速查">速查&lt;/h2>
&lt;p>Markdown 中 Latex 基本符号速查表&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>显示字符&lt;/th>
&lt;th>输入字符&lt;/th>
&lt;th>显示字符&lt;/th>
&lt;th>输入字符&lt;/th>
&lt;th>显示字符&lt;/th>
&lt;th>输入字符&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>&lt;code>#&lt;/code>&lt;/td>
&lt;td>&lt;code>\\#&lt;/code>&lt;/td>
&lt;td>&lt;code>$&lt;/code>&lt;/td>
&lt;td>&lt;code>\\$&lt;/code>&lt;/td>
&lt;td>&lt;code>%&lt;/code>&lt;/td>
&lt;td>&lt;code>\\%&lt;/code>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>&amp;amp;&lt;/code>&lt;/td>
&lt;td>&lt;code>\\&amp;amp;&lt;/code>&lt;/td>
&lt;td>&lt;code>~&lt;/code>&lt;/td>
&lt;td>&lt;code>\\~&lt;/code>&lt;/td>
&lt;td>&lt;code>_&lt;/code>&lt;/td>
&lt;td>&lt;code>\\_&lt;/code>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>^&lt;/code>&lt;/td>
&lt;td>&lt;code>\\^&lt;/code>&lt;/td>
&lt;td>&lt;code>\\&lt;/code>&lt;/td>
&lt;td>&lt;code>\\\\&lt;/code>&lt;/td>
&lt;td>&lt;code>{&lt;/code>&lt;/td>
&lt;td>&lt;code>\\{&lt;/code>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>}&lt;/code>&lt;/td>
&lt;td>&lt;code>\\}&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>≤&lt;/td>
&lt;td>&lt;code>\\le&lt;/code>&lt;/td>
&lt;td>≥&lt;/td>
&lt;td>&lt;code>\\ge&lt;/code>&lt;/td>
&lt;td>≡&lt;/td>
&lt;td>&lt;code>\\equiv&lt;/code>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>≠&lt;/td>
&lt;td>&lt;code>\\ne&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>文本底线对齐的省略号&lt;/td>
&lt;td>&lt;code>\\ldots&lt;/code>&lt;/td>
&lt;td>文本中对齐的省略号&lt;/td>
&lt;td>&lt;code>\\cdots&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>圆括号&lt;/td>
&lt;td>&lt;code>()&lt;/code>&lt;/td>
&lt;td>方括号&lt;/td>
&lt;td>&lt;code>[]&lt;/code>&lt;/td>
&lt;td>竖线&lt;/td>
&lt;td>&lt;code>&amp;amp;#124;&lt;/code>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>花括号&lt;/td>
&lt;td>&lt;code>\\{\\}&lt;/code>&lt;/td>
&lt;td>双竖线&lt;/td>
&lt;td>&lt;code>\\&amp;amp;#124;&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>长圆括号&lt;/td>
&lt;td>&lt;code>\\left( \\right)&lt;/code>&lt;/td>
&lt;td>长方括号&lt;/td>
&lt;td>&lt;code>\\left[ \\right]&lt;/code>&lt;/td>
&lt;td>长花括号&lt;/td>
&lt;td>&lt;code>\\left\\{ \\right\\}&lt;/code>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>换行&lt;/td>
&lt;td>&lt;code>\\\\&lt;/code>&lt;/td>
&lt;td>空格&lt;/td>
&lt;td>&lt;code>\\space&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>←&lt;/td>
&lt;td>&lt;code>\\leftarrow&lt;/code>&lt;/td>
&lt;td>→&lt;/td>
&lt;td>&lt;code>\\rightarrow&lt;/code>&lt;/td>
&lt;td>文字&lt;/td>
&lt;td>&lt;code>\\mbox{ }&lt;/code>&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;hr>
&lt;h2 id="字符相关">字符相关&lt;/h2>
&lt;h3 id="字符">&lt;strong>字符&lt;/strong>&lt;/h3>
&lt;p>插入 &lt;code># $ % &amp;amp; ~ _ ^ \ { }&lt;/code> 需多加 &lt;code>\&lt;/code> 符号（类似于 C 语言中的转义字符），其他可以直接插入。&lt;/p>
&lt;p>&lt;code>\\&lt;/code> 对应换行符 ，&lt;code>\space&lt;/code> 对应空格。&lt;/p>
&lt;p>小于等于、大于等于、恒等于、不等于分别为 &lt;code>\le \ge \equiv \ne&lt;/code> （ l 意为 less ，e 意为 equal ，g 意为 greater ）&lt;/p>
&lt;h3 id="省略号">&lt;strong>省略号&lt;/strong>&lt;/h3>
&lt;p>&lt;code>\ldots \cdots&lt;/code> 分别表示与文本底线对齐和与文本中对齐的省略号。（l 意为 line ，c 意为 center ）&lt;/p>
&lt;h3 id="括号">&lt;strong>括号&lt;/strong>&lt;/h3>
&lt;p>圆括号、方括号和竖线直接输入，花括号前需添加 &lt;code>\&lt;/code> ，双竖线对应&lt;code>\|&lt;/code> 。&lt;/p>
&lt;p>长圆括号、长方括号、长花括号对应&lt;code>\left( \right)&lt;/code> &lt;code>\left[ \right]&lt;/code> &lt;code>\left\{ \right\}&lt;/code>&lt;/p>
&lt;h3 id="箭头">&lt;strong>箭头&lt;/strong>&lt;/h3>
&lt;p>左右箭头对应 &lt;code>\leftarrow \rightarrow&lt;/code>&lt;/p>
&lt;h3 id="插入文字">&lt;strong>插入文字&lt;/strong>&lt;/h3>
&lt;p>&lt;code>\mbox{ }&lt;/code> 用于插入文字（显示效果不是斜体字） 。&lt;/p>
&lt;hr>
&lt;h2 id="数学式子">数学式子&lt;/h2>
&lt;h3 id="标准函数">&lt;strong>标准函数&lt;/strong>&lt;/h3>
&lt;p>欲输入 &lt;code>sin&lt;/code> 时，应用&lt;code>\sin(x)&lt;/code>。&lt;/p>
&lt;h3 id="分数">&lt;strong>分数&lt;/strong>&lt;/h3>
&lt;p>二分之一对于 &lt;code>\frac{1}{2}&lt;/code>&lt;/p>
&lt;h3 id="根号">&lt;strong>根号&lt;/strong>&lt;/h3>
&lt;p>根号二对应 &lt;code>\sqrt{2}&lt;/code> ，开 n 次方为&lt;code>\sqrt[n]{expression}&lt;/code>&lt;/p>
&lt;h3 id="导数-偏导数">&lt;strong>导数 偏导数&lt;/strong>&lt;/h3>
&lt;p>对 x 导数对应 &lt;code>\mathrm{d}x&lt;/code>&lt;/p>
&lt;p>对 x 的偏导数对应&lt;code>\partial x&lt;/code>&lt;/p>
&lt;h3 id="积分">&lt;strong>积分&lt;/strong>&lt;/h3>
&lt;p>f(x) 对 x 从 a 到 b 的积分 &lt;code>\int_a^b f(x) \mathrm{d}x&lt;/code> ， 多重积分则多次输入 &lt;code>\int&lt;/code> ，两个符号之间添加 &lt;code>\!\!\!&lt;/code> 调整正确的间隔。&lt;/p>
&lt;h3 id="极限">&lt;strong>极限&lt;/strong>&lt;/h3>
&lt;p>x 到正无穷的极限 &lt;code>\lim_{x\to+\infty}&lt;/code>&lt;/p>
&lt;h3 id="求和">&lt;strong>求和&lt;/strong>&lt;/h3>
&lt;p>1 到 n 的和对应 &lt;code>\sum_{1}^{n}&lt;/code>&lt;/p>
&lt;h3 id="向量">&lt;strong>向量&lt;/strong>&lt;/h3>
&lt;p>向量 ab 对应 &lt;code>\vec{ab}&lt;/code>&lt;/p>
&lt;h3 id="排列组合">&lt;strong>排列组合&lt;/strong>&lt;/h3>
&lt;p>从 n 中选 m 的组合数和排列数为 &lt;code>\mathrm{C}_n^m \mathrm{A}_n^m&lt;/code>&lt;/p>
&lt;p>&lt;a href="#1">具体内容参见文末参考资料&lt;/a>。&lt;/p>
&lt;hr>
&lt;h2 id="上下标与希腊字母">上下标与希腊字母&lt;/h2>
&lt;p>&lt;code>^&lt;/code> 表示上标 &lt;code>_&lt;/code>表示下标，同时出现上下标时，先上标后下标与先下标后上标的效果相同。&lt;/p>
&lt;p>用 &lt;code>\&lt;/code> 加相应的拼写即可，第一个字母大写则显示大写字母，小写则显示小写字母。&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>输入&lt;/th>
&lt;th>展示&lt;/th>
&lt;th>输入&lt;/th>
&lt;th>展示&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>\alpha&lt;/td>
&lt;td>α&lt;/td>
&lt;td>\beta&lt;/td>
&lt;td>β&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>\gamma&lt;/td>
&lt;td>γ&lt;/td>
&lt;td>\Gamma&lt;/td>
&lt;td>Γ&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>\theta&lt;/td>
&lt;td>θ&lt;/td>
&lt;td>\Theta&lt;/td>
&lt;td>Θ&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>\delta&lt;/td>
&lt;td>δ&lt;/td>
&lt;td>\Delta&lt;/td>
&lt;td>Δ&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>\triangledown&lt;/td>
&lt;td>▽&lt;/td>
&lt;td>\epsilon&lt;/td>
&lt;td>ϵ&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>\zeta&lt;/td>
&lt;td>ζ&lt;/td>
&lt;td>\eta&lt;/td>
&lt;td>η&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>\kappa&lt;/td>
&lt;td>κ&lt;/td>
&lt;td>\lambda&lt;/td>
&lt;td>λ&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>\mu&lt;/td>
&lt;td>μ&lt;/td>
&lt;td>\nu&lt;/td>
&lt;td>ν&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>\xi&lt;/td>
&lt;td>ξ&lt;/td>
&lt;td>\pi&lt;/td>
&lt;td>π&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>\sigma&lt;/td>
&lt;td>σ&lt;/td>
&lt;td>\tau&lt;/td>
&lt;td>τ&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>\upsilon&lt;/td>
&lt;td>υ&lt;/td>
&lt;td>\phi&lt;/td>
&lt;td>ϕ&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>\omega&lt;/td>
&lt;td>ω&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;hr>
&lt;h2 id="多行的数学公式">多行的数学公式&lt;/h2>
&lt;p>例子&lt;/p>
&lt;pre>&lt;code>\begin{eqnarray}
\cos 2\theta &amp;amp; = &amp;amp; \cos^2 \theta - \sin^2 \theta \\
&amp;amp; = &amp;amp; 2 \cos^2 \theta - 1.
\end{eqnarray}
&lt;/code>&lt;/pre>
&lt;p>&amp;amp; 是对齐点，具体例子中表示多行式子在等号之间对齐。&lt;/p>
&lt;pre>&lt;code>f(n) =
\begin{cases}
n+1, &amp;amp; \mbox{if }n \mbox{ is even} \\
n-1, &amp;amp; \mbox{if }n \mbox{ is odd}
\end{cases}
&lt;/code>&lt;/pre>
&lt;p>条件定义式。奇数加一，偶数减一。&lt;/p>
&lt;hr>
&lt;h2 id="矩阵">矩阵&lt;/h2>
&lt;p>例子&lt;/p>
&lt;pre>&lt;code>\begin{array}{ccc}
a &amp;amp; b &amp;amp; c \\
d &amp;amp; e &amp;amp; f \\
g &amp;amp; h &amp;amp; i
\end{array}
&lt;/code>&lt;/pre>
&lt;p>表示 3 x 3 的矩阵，c 表示居中对齐，l 是左对齐，r 是右对齐。&lt;/p>
&lt;hr>
&lt;p>参考资料 ：&lt;/p>
&lt;p>#1 &lt;a href="https://zh.wikipedia.org/wiki/Help:%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8F">帮助:数学公式 - 维基百科，自由的百科全书&lt;/a>&lt;/p>
&lt;p>#2 &lt;a href="https://zh.wikibooks.org/wiki/LaTeX/%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8F">LaTeX/数学公式 - 维基教科书，自由的教学读本&lt;/a>&lt;/p></description></item><item><title>Docs: OpenAI</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/12.%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/openai/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/12.%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/openai/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://openai.com/">官网&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;h1 id="api">API&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://platform.openai.com/docs/api-reference/introduction">官方文档，API 参考&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;h1 id="chatgpt">ChatGPT&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://github.com/wangrongding/wechat-bot">https://github.com/wangrongding/wechat-bot&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://github.com/fuergaosi233/wechat-chatgpt">https://github.com/fuergaosi233/wechat-chatgpt&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://zblogs.top/how-to-register-openai-chatgpt-in-china">https://zblogs.top/how-to-register-openai-chatgpt-in-china&lt;/a>
&lt;ul>
&lt;li>注册 ChatGPT 教程&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>使用虚拟号码接收短信验证码：https://sms-activate.org/&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>上下文联系功能说明&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/0-picgo/20230204001925.png" alt="image.png">&lt;/p>
&lt;h2 id="基于-chatgpt-的项目">基于 ChatGPT 的项目&lt;/h2>
&lt;p>Chrom 插件&lt;/p>
&lt;p>&lt;a href="https://github.com/wong2/chat-gpt-google-extension">https://github.com/wong2/chat-gpt-google-extension&lt;/a>&lt;/p>
&lt;p>&lt;a href="https://github.com/gragland/chatgpt-chrome-extension">https://github.com/gragland/chatgpt-chrome-extension&lt;/a>&lt;/p>
&lt;p>逆向&lt;/p>
&lt;p>&lt;a href="https://github.com/acheong08/ChatGPT">https://github.com/acheong08/ChatGPT&lt;/a>&lt;/p>
&lt;p>微信接入&lt;/p>
&lt;p>&lt;a href="https://github.com/fuergaosi233/wechat-chatgpt">https://github.com/fuergaosi233/wechat-chatgpt&lt;/a>&lt;/p>
&lt;ul>
&lt;li>用法：&lt;a href="https://mp.weixin.qq.com/s/dLzemMUcIfjvWd_AF_yDJw">https://mp.weixin.qq.com/s/dLzemMUcIfjvWd_AF_yDJw&lt;/a>&lt;/li>
&lt;/ul>
&lt;p>&lt;a href="https://github.com/AutumnWhj/ChatGPT-wechat-bot">https://github.com/AutumnWhj/ChatGPT-wechat-bot&lt;/a>&lt;/p>
&lt;p>接入 GitLab&lt;/p>
&lt;p>&lt;a href="https://mp.weixin.qq.com/s/y_ppQdKVXWZPNyP9BxGWpg">https://mp.weixin.qq.com/s/y_ppQdKVXWZPNyP9BxGWpg&lt;/a>&lt;/p></description></item><item><title>Docs: OpenCV</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/12.%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89/opencv/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/12.%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89/opencv/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://github.com/opencv/opencv">GitHub 项目，opencv/opencv&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://opencv.org/">官网&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://docs.opencv.org/">官方文档&lt;/a>，从左侧 Nightly 中选择想要查看的版本&lt;/li>
&lt;li>&lt;a href="https://zhuanlan.zhihu.com/p/115321759">https://zhuanlan.zhihu.com/p/115321759&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.jiqizhixin.com/articles/2019-03-22-10">手把手教你使用OpenCV库（附实例、Python代码解析）&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>&lt;strong>Open Source Computer Vision Library(开源计算机视觉库，简称 OpenCV)&lt;/strong> 是一个包含数百种计算机视觉算法的开源库。&lt;/p>
&lt;p>官方提供了 Python 语言的 OpenCV 接口~~~在官方这没找到其他语言的&lt;/p></description></item><item><title>Docs: Security</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/y.windows-%E7%AE%A1%E7%90%86/windows%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/powershell%E5%86%85%E7%BD%AE%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/security/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/y.windows-%E7%AE%A1%E7%90%86/windows%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/powershell%E5%86%85%E7%BD%AE%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/security/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://learn.microsoft.com/en-us/powershell/module/microsoft.powershell.security">官方文档，PowerShell-参考-Security 模块&lt;/a>&lt;/li>
&lt;li>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;h1 id="get-executionpolicy">Get-ExecutionPolicy&lt;/h1>
&lt;p>获取当前会话的执行策略。&lt;/p>
&lt;ul>
&lt;li>Restricted 执行策略不允许任何脚本运行。  &lt;/li>
&lt;li>AllSigned 和 RemoteSigned 执行策略可防止 Windows PowerShell 运行没有数字签名的脚本。&lt;/li>
&lt;/ul>
&lt;p>默认使用 Restricted 策略，此时当我们执行脚本时将会失败，并报错：&lt;/p>
&lt;pre tabindex="0">&lt;code>无法加载文件 XXXXX，因为在此系统上禁止运行脚本。有关详细信息，请参阅 https:/go.microsof
t.com/fwlink/?LinkID=135170 中的 about_Execution_Policies。
&lt;/code>&lt;/pre>&lt;h2 id="syntax语法">Syntax(语法)&lt;/h2>
&lt;h2 id="example">EXAMPLE&lt;/h2>
&lt;h1 id="set-executionpolicy">Set-ExecutionPolicy&lt;/h1>
&lt;p>为 Windows 计算机设置 PowerShell 执行策略&lt;/p>
&lt;h2 id="syntax语法-1">Syntax(语法)&lt;/h2>
&lt;p>Get-Command&lt;/p>
&lt;h2 id="example-1">EXAMPLE&lt;/h2>
&lt;p>设置策略为 RemoteSigned&lt;/p>
&lt;ul>
&lt;li>Set-ExecutionPolicy RemoteSigned&lt;/li>
&lt;/ul></description></item><item><title>Docs: UltraISO</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%AE%9E%E7%94%A8%E5%B7%A5%E5%85%B7/%E5%AE%89%E8%A3%85%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/ultraiso/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%AE%9E%E7%94%A8%E5%B7%A5%E5%85%B7/%E5%AE%89%E8%A3%85%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/ultraiso/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://www.ultraiso.com/">官网&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;h2 id="将-iso-文件写到-u-盘">将 ISO 文件写到 U 盘&lt;/h2>
&lt;p>写入硬盘映像&lt;/p></description></item><item><title>Docs: Windows Shell 变量</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/4.terminal-%E4%B8%8E-shell/windows_shell/windows_shell_%E5%8F%98%E9%87%8F/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/4.terminal-%E4%B8%8E-shell/windows_shell/windows_shell_%E5%8F%98%E9%87%8F/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://learn.microsoft.com/en-us/powershell/scripting/lang-spec/chapter-03?view=powershell-7.3#312-environment-variables">官方文档-PowerShell，脚本-基本概念-环境变量&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://learn.microsoft.com/en-us/windows/deployment/usmt/usmt-recognized-environment-variables">官方文档-Windows，部署-公认的环境变量&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://sysin.org/blog/windows-env/">https://sysin.org/blog/windows-env/&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://ss64.com/nt/syntax-variables.html">https://ss64.com/nt/syntax-variables.html&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>赋值方式：&lt;/p>
&lt;ul>
&lt;li>在 CMD 中：&lt;/li>
&lt;li>在 PowerShell 中：&lt;code>$env:VAR=VALUE&lt;/code>&lt;/li>
&lt;/ul>
&lt;p>引用方式：&lt;/p>
&lt;ul>
&lt;li>在 CMD 和资源管理器中：&lt;code>%VAR%&lt;/code>&lt;/li>
&lt;li>在 PowerShell 中：&lt;code>$env:VAR&lt;/code>
&lt;ul>
&lt;li>&lt;code>(type env:path) -split ';'&lt;/code> # 切割字符串，将 ; 替换为换行符。方便查看&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>TODO: Windows 中的变量好像不区分大小写？&lt;/p>
&lt;h2 id="常用环境变量">常用环境变量&lt;/h2>
&lt;p>&lt;strong>COMPUTERNAME&lt;/strong> # 主机名&lt;/p>
&lt;p>&lt;strong>USERNAME&lt;/strong> # 用户名&lt;/p>
&lt;p>&lt;strong>USERPROFILE&lt;/strong> # 用户家目录。默认值：&lt;code>C:/Users/${USERNAME}/&lt;/code>&lt;/p>
&lt;p>&lt;strong>TMP&lt;/strong> # 临时目录。默认值：&lt;/p>
&lt;ul>
&lt;li>系统级 &lt;code>C:/WINDOWS/TEMP&lt;/code>&lt;/li>
&lt;li>用户级 &lt;code>%USERPROFILE%/AppData/Local/Temp&lt;/code>&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>APPDATA&lt;/strong> # 应用程序的数据保存路径。默认值：&lt;code>%USERPROFILE%/AppData/Roaming/&lt;/code>&lt;/p>
&lt;ul>
&lt;li>这个目录下的数据通常可以随着网络连接同步到其他电脑。比如用户的配置、插件等等。当然，很多时候，应用程序也会将这些可以在网络同步的数据保存到 文档、家目录 等等地方中。&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>LOCALAPPDATA&lt;/strong> # 应用程序的本地数据保存路径。默认值：&lt;code>%USERPROFILE%/AppData/Local/&lt;/code>&lt;/p>
&lt;p>注意：&lt;/p>
&lt;ul>
&lt;li>Windows 中没有指向 “文档”、“视频” 等等目录的变量，可以在 PowerShell 中使用 &lt;code>[environment]::getfolderpath(&amp;quot;mydocuments&amp;quot;)&lt;/code> 获取。
&lt;ul>
&lt;li>参考：https://stackoverflow.com/questions/3492920/is-there-a-system-defined-environment-variable-for-documents-directory&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>想要获取变量，有几下几种方式：&lt;/p>
&lt;ul>
&lt;li>Get-Item Env:*&lt;/li>
&lt;li>Get-Variable&lt;/li>
&lt;/ul>
&lt;h1 id="变量管理工具">变量管理工具&lt;/h1>
&lt;p>在 PowerShell 中，变量也可以称为一个 Item，因此可以由大多数与 Item 相关的 cmdlet 命令控制。&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://learn.microsoft.com/en-us/powershell/module/microsoft.powershell.utility/new-variable?view=powershell-7.3">New-Variable&lt;/a>: Creates a variable&lt;/li>
&lt;li>&lt;a href="https://learn.microsoft.com/en-us/powershell/module/microsoft.powershell.utility/set-variable?view=powershell-7.3">Set-Variable&lt;/a>: Creates or changes the characteristics of one or more variables&lt;/li>
&lt;li>&lt;a href="https://learn.microsoft.com/en-us/powershell/module/microsoft.powershell.utility/get-variable?view=powershell-7.3">Get-Variable&lt;/a>: Gets information about one or more variables&lt;/li>
&lt;li>&lt;a href="https://learn.microsoft.com/en-us/powershell/module/microsoft.powershell.utility/clear-variable?view=powershell-7.3">Clear-Variable&lt;/a>: Deletes the value of one or more variables&lt;/li>
&lt;li>&lt;a href="https://learn.microsoft.com/en-us/powershell/module/microsoft.powershell.utility/remove-variable?view=powershell-7.3">Remove-Variable&lt;/a>: Deletes one or more variables&lt;/li>
&lt;/ul>
&lt;h1 id="最佳实践">最佳实践&lt;/h1>
&lt;p>设置代理&lt;/p>
&lt;ul>
&lt;li>&lt;code>$env:HTTPS_PROXY=&amp;quot;http://127.0.0.1:7890&amp;quot;&lt;/code>&lt;/li>
&lt;/ul></description></item><item><title>Docs: Windows Shell 命令</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/4.terminal-%E4%B8%8E-shell/windows_shell/windows_shell_%E5%91%BD%E4%BB%A4/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/4.terminal-%E4%B8%8E-shell/windows_shell/windows_shell_%E5%91%BD%E4%BB%A4/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://learn.microsoft.com/en-us/windows-server/administration/windows-commands/windows-commands">官方文档，Windows 命令&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://learn.microsoft.com/en-us/powershell/module">官方文档，PowerShell 模块参考&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>所有受支持的 Windows 和 Windows Server 版本都内置了一组 Win32 控制台命令。同时，&lt;a href="https://desistdaydream.github.io/docs/IT%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/4.Terminal%20%E4%B8%8E%20Shell/Windows_Shell/PowerShell.md">PowerShell&lt;/a> 也内置了一组 cmdlet&lt;/p>
&lt;p>这些命令可以用来管理 Windows，很多命令的详解可以参见 &lt;a href="https://desistdaydream.github.io/docs/IT%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Y.Windows%20%E7%AE%A1%E7%90%86/Windows%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/_index.md">Windows 管理工具&lt;/a> 目录。&lt;/p>
&lt;p>本质上，内置的命令就两类：&lt;/p>
&lt;ul>
&lt;li>Win32 控制台命令。一般在 C:/Windows/System32 目录中&lt;/li>
&lt;li>PowerShell 中的 cmdlet。也就是 PowerShell 的各种模块&lt;/li>
&lt;/ul></description></item><item><title>Docs: Windows包管理</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/6.package-%E7%AE%A1%E7%90%86/windows%E5%8C%85%E7%AE%A1%E7%90%86/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/6.package-%E7%AE%A1%E7%90%86/windows%E5%8C%85%E7%AE%A1%E7%90%86/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>官方文档&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;h1 id="appx">AppX&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://learn.microsoft.com/en-us/powershell/module/appx/">官方文档&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>Get-AppxPackage&lt;/p>
&lt;p>Remove-AppxPackage&lt;/p>
&lt;h1 id="msix">MSIX&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>官方文档&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;h1 id="winget">winget&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://learn.microsoft.com/en-us/windows/package-manager/">官方文档-Windows，包管理器&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote></description></item><item><title>Docs: WPS</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%AE%9E%E7%94%A8%E5%B7%A5%E5%85%B7/%E5%86%99%E4%BD%9C/wps/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%AE%9E%E7%94%A8%E5%B7%A5%E5%85%B7/%E5%86%99%E4%BD%9C/wps/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;h2 id="参考">参考：&lt;/h2>
&lt;/blockquote>
&lt;p>垃圾软件&lt;/p>
&lt;p>安装时修改路径后提示没有权限，然后点继续就直接安装到 C 盘了，点取消才能安装到其他路径。&lt;/p>
&lt;h1 id="关联文件与配置">关联文件与配置&lt;/h1>
&lt;ul>
&lt;li>C:/ProgramData/kingsoft/ # 安装程序运行时下载的文件保存路径&lt;/li>
&lt;li>C:/rogram Files (x86)/Kingsoft/ # 不知道干啥用的&lt;/li>
&lt;li>C:/Users/DesistDaydream/AppData/Local/kingsoft/ # 不知道干啥用的&lt;/li>
&lt;li>C:/Users/DesistDaydream/AppData/Roaming/kingsoft/ # 不知道干啥用的&lt;/li>
&lt;li>%我的文档%/KingsoftData/ #
&lt;ul>
&lt;li>暂时不知道win中“我的文档”的变量是什么。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>%我的文档%/WPS Cloud Files/ #&lt;/li>
&lt;/ul></description></item><item><title>Docs: 复合数据类型</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/2.%E7%BC%96%E7%A8%8B/%E8%A7%A3%E8%B0%9C%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/data-type%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B-%E4%B8%8E-literal%E5%AD%97%E9%9D%A2%E9%87%8F/%E5%A4%8D%E5%90%88%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/%E5%A4%8D%E5%90%88%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/2.%E7%BC%96%E7%A8%8B/%E8%A7%A3%E8%B0%9C%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/data-type%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B-%E4%B8%8E-literal%E5%AD%97%E9%9D%A2%E9%87%8F/%E5%A4%8D%E5%90%88%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/%E5%A4%8D%E5%90%88%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Composite_data_type">Wiki，Composite_data_type&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>原子类型的值是不能分解为组成部分的单个数据项。复合类型 或 聚合类型 的值是可以单独访问的数据项的集合。例如，一个整数通常被认为是原子的，尽管它由一系列位组成，而整数数组肯定是复合的。&lt;/p>
&lt;h1 id="array数组">Array(数组)&lt;/h1>
&lt;p>&lt;strong>为什么很多编程语言要把 0 作为第一个下标索引，而不是直观的 1 呢？&lt;/strong>&lt;/p>
&lt;p>这个问题 Dijkstra 已经解答过了，没错，就是你知道的 Dijkstra，Dijkstra 最短路径算法，荷兰语全名是 Edsger Wybe Dijkstra，于 1972 年获得了图灵奖，除了上面说的最短路径算法，还有众所周知的信号量和 PV 原语、银行家算法等也是这位巨佬提出的。&lt;/p>
&lt;p>原文在这里：https://www.cs.utexas.edu/users/EWD/transcriptions/EWD08xx/EWD831.html，感兴趣的小伙伴可以去看下全文，下面我总结几段核心的观点：&lt;/p>
&lt;p>首先来看个案例，如何用一个不等式（或者说表达式）来表示 &lt;code>[2,3,4,5,6,7,8,9,10,11,12]&lt;/code> 这个连续的整数序列（一共 11 个数）？&lt;/p>
&lt;p>假设 &lt;code>i&lt;/code> 是一个整数，那么我们能够迅速的写出如下四个符合上述连续序列的不等式：&lt;/p>
&lt;p>1）&lt;code>2 &amp;lt;= i &amp;lt; 13&lt;/code>&lt;/p>
&lt;p>2）&lt;code>1 &amp;lt; i &amp;lt;= 12&lt;/code>&lt;/p>
&lt;p>3）&lt;code>2 &amp;lt;= i &amp;lt;= 12&lt;/code>&lt;/p>
&lt;p>4）&lt;code>1 &amp;lt; i &amp;lt; 13&lt;/code>&lt;/p>
&lt;p>以上四个不等式均满足要求，那是否有理由选择其中的一种而不是另一种？&lt;/p>
&lt;p>Dijkstra 说有的，选 1 和 2，因为这俩不等式有个很突出的有点，就是不等式边界的差（不等式右边 - 不等式左边）正好等于连续序列的长度&lt;/p>
&lt;p>这里可以排除掉 3 和 4，那么 1 和 2 该如何选出最优的表示？&lt;/p>
&lt;p>1 和 2 不等式的区别就在于：&lt;/p>
&lt;ul>
&lt;li>1 不等式左边（下界）等于序列中的最小值，不等式右边（上界）大于序列中的最大值&lt;/li>
&lt;li>2 不等式左边（下界）小于序列中的最小值，不等式右边（上界）等于序列中的最大值&lt;/li>
&lt;/ul>
&lt;p>对于第 2 个不等式来说，下界小于序列中的最小值，这会出现一个问题，比如我们的连续序列是 &lt;code>[0,1,2,3,4]&lt;/code>&lt;/p>
&lt;p>那么按照第 2 个不等式的写法，不等式的左边就是 -1，-1 是非自然数，而我们需要表示的连续序列是自然数序列，所以第 2 个不等式很不优雅：我们需要用一个 非自然数 来作为 全是自然数的序列 的下界&lt;/p>
&lt;p>因此，综上所述，不等式 1 是最优雅的选择。&lt;/p>
&lt;p>那么，选出一个看着非常顺眼的不等式来表达长度为 N 的连续序列之后，下一个令人烦恼的问题是该为起始元素分配什么下标值？&lt;/p>
&lt;p>遵循不等式 1 的规则：&lt;/p>
&lt;ul>
&lt;li>当从下标 1 开始时，下标范围 &lt;code>1 ≤ i &amp;lt; N+1&lt;/code>&lt;/li>
&lt;li>当从下标 0 开始时，下标范围 &lt;code>0 ≤ i &amp;lt; N&lt;/code>&lt;/li>
&lt;/ul>
&lt;p>哪个更优雅？&lt;/p>
&lt;p>Dijkstra 是这样解释的：从下标 0 开始能够给出更好的不等式，因为元素的下标就等于序列中它前面的元素数（或者说 “偏移量”）。&lt;/p></description></item><item><title>Docs: 计算机视觉</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/12.%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/12.%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;h2 id="参考">参考：&lt;/h2>
&lt;/blockquote>
&lt;h1 id="halcon">Halcon&lt;/h1></description></item><item><title>Docs: 命令行工具</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%AE%9E%E7%94%A8%E5%B7%A5%E5%85%B7/%E7%BD%91%E7%AB%99%E6%90%AD%E5%BB%BA/hugo/%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%B7%A5%E5%85%B7/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%AE%9E%E7%94%A8%E5%B7%A5%E5%85%B7/%E7%BD%91%E7%AB%99%E6%90%AD%E5%BB%BA/hugo/%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%B7%A5%E5%85%B7/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://gohugo.io/commands/hugo/">官方文档，命令-hugo&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>&lt;code>hugo&lt;/code> 是 Hugo 的命令行工具。&lt;/p>
&lt;p>在网站的根目录下使用 &lt;code>hugo&lt;/code> 命令，可以为网站构建静态文件，并保存到 &lt;code>publish/&lt;/code> 目录中。&lt;/p>
&lt;h2 id="sytnax语法">Sytnax(语法)&lt;/h2>
&lt;p>&lt;strong>hugo [COMMAND] [FLAGS]&lt;/strong>&lt;/p>
&lt;p>FLAGS&lt;/p>
&lt;ul>
&lt;li>&lt;strong>-D, &amp;ndash;buildDrafts&lt;/strong> # 包含标记为 draft 的内容&lt;/li>
&lt;/ul>
&lt;h1 id="hugo-server">hugo server&lt;/h1>
&lt;h2 id="syntax语法">Syntax(语法)&lt;/h2>
&lt;p>&lt;strong>hugo server [FLAGS]&lt;/strong>&lt;/p>
&lt;p>FLAGS&lt;/p>
&lt;ul>
&lt;li>&lt;strong>&amp;ndash;bind STRING&lt;/strong> # 监听地址。&lt;code>默认值: 127.0.0.1&lt;/code>&lt;/li>
&lt;li>&lt;strong>-p, &amp;ndash;port INT&lt;/strong> # 监听端口。&lt;code>默认值: 1313&lt;/code>&lt;/li>
&lt;li>&lt;strong>-w, &amp;ndash;watch&lt;/strong> # 监听文件的改变，文件改变时重新应用，以便结果可以实时显示。&lt;code>默认值: true&lt;/code>&lt;/li>
&lt;li>&lt;strong>&amp;ndash;cacheDir STRING&lt;/strong> # filesystem path to cache directory。&lt;code>默认值: $TMPDIR/hugo_cache/&lt;/code>&lt;/li>
&lt;/ul></description></item><item><title>Docs: 配置文件详解</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%AE%9E%E7%94%A8%E5%B7%A5%E5%85%B7/%E7%BD%91%E7%AB%99%E6%90%AD%E5%BB%BA/hugo/%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%AE%9E%E7%94%A8%E5%B7%A5%E5%85%B7/%E7%BD%91%E7%AB%99%E6%90%AD%E5%BB%BA/hugo/%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://gohugo.io/getting-started/configuration/">官方文档，入门-配置&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>Hugo 支持 toml、yaml、json 格式的配置文件，默认配置文件名为 &lt;strong>config.SUFFIX&lt;/strong>。所有的配置指令都可以写在 config.SUFFIX 文件中。&lt;/p>
&lt;p>我们可以拆分 config 文件，并将其保存在 &lt;code>${ConfigDir}&lt;/code> 目录下(默认为站点根目录下的 &lt;code>config/&lt;/code> 文件夹)。 ConfigDir 下的每个文件名代表配置中的根指令，比如：&lt;/p>
&lt;p>config.toml 文件中有如下指令&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-toml" data-lang="toml">&lt;span style="display:flex;">&lt;span>[&lt;span style="color:#a6e22e">Params&lt;/span>]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">foo&lt;/span> = &lt;span style="color:#e6db74">&amp;#39;bar&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>那么拆分到 ConfigDir 目录时，则使用 params.toml 文件，内容为：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-toml" data-lang="toml">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">foo&lt;/span> = &lt;span style="color:#e6db74">&amp;#39;bar&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>除了 Hugo 本身会用到 config 文件，有些主题也会使用 config 文件，并具有各自可以识别的配置指令。比如 Docsy 主题。&lt;/p>
&lt;h1 id="config-目录结构">config 目录结构&lt;/h1>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>├── config
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>│   ├── _default
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>│   │   ├── config.toml
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>│   │   ├── languages.toml
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>│   │   ├── menus.en.toml
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>│   │   ├── menus.zh.toml
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>│   │   └── params.toml
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>│   ├── production
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>│   │   ├── config.toml
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>│   │   └── params.toml
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>│   └── staging
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>│       ├── config.toml
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>│       └── params.toml
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>_default/ 目录是站点的默认配置，可以直接保存单个 config 文件。&lt;/p>
&lt;p>production 与 staging 文件夹用来区分运行时配置，比如使用 &lt;code>hugo --environment staging&lt;/code> 命令时，Hugo 将会使用 &lt;code>config/_default/&lt;/code> 和 &lt;code>config/staging&lt;/code> 这两个下的所有文件，将所有文件合并后生成一个单独的临时 config 文件，作为站点运行时的配置文件。&lt;/p>
&lt;p>这种目录结构，可以帮助我们区分不用环境(比如开发环境、生产环境等)下运行网站所需要使用的配置。&lt;/p>
&lt;blockquote>
&lt;p>Hugo 有个默认值，执行 &lt;code>hugo server&lt;/code> 命令时，是在本地运行网站，所以默认为开发环境，使用 &lt;code>config/development/&lt;/code> 目录；而执行 &lt;code>hugo&lt;/code> 命令时，是要构建静态文件，所以默认为生产环境，使用 &lt;code>config/production&lt;/code> 目录。&lt;/p>
&lt;/blockquote></description></item><item><title>Docs: 其他</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/y.windows-%E7%AE%A1%E7%90%86/windows%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/%E5%85%B6%E4%BB%96/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/y.windows-%E7%AE%A1%E7%90%86/windows%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/%E5%85%B6%E4%BB%96/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;h2 id="参考">参考：&lt;/h2>
&lt;/blockquote>
&lt;h1 id="链接文件管理">链接文件管理&lt;/h1>
&lt;h2 id="mklink">mklink&lt;/h2>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://learn.microsoft.com/en-us/windows-server/administration/windows-commands/mklink">官方文档&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;h3 id="syntax语法">Syntax(语法)&lt;/h3>
&lt;p>&lt;strong>mklink [[/d] | [/h] | [/j]] &amp;lt;link&amp;gt; &amp;lt;target&amp;gt;&lt;/strong>&lt;/p>
&lt;p>为 target 创建一个名为 link 的链接文件。即 link 是要创建的新文件&lt;/p>
&lt;h3 id="example">EXAMPLE&lt;/h3>
&lt;ul>
&lt;li>创建链接
&lt;ul>
&lt;li>mklink /D C:/Users/DesistDaydream/AppData/Roaming/yuzu E:/yuzu/user&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h1 id="电源管理">电源管理&lt;/h1>
&lt;h2 id="powercfg">powercfg&lt;/h2>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://learn.microsoft.com/en-us/windows-hardware/design/device-experiences/powercfg-command-line-options">官方文档-Windows硬件开发人员，学习-Windows-设计-设备体验-Powercfg 命令行选项&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>powercfg 工具可以控制电源计划（也称为电源方案）以使用可用的睡眠状态、控制单个设备的电源状态以及分析系统的常见能效和电池寿命问题。&lt;/p>
&lt;h3 id="syntax语法-1">Syntax(语法)&lt;/h3>
&lt;p>&lt;strong>powercfg OPTIONS [arguments] [/?]&lt;/strong>&lt;/p>
&lt;p>OPTIONS&lt;/p>
&lt;ul>
&lt;li>&lt;strong>/devicequery QueryFlag&lt;/strong> # 根据 QueryFlag(查询标志) 列出设备。可用的 QueryFlag 列表如下
&lt;ul>
&lt;li>&lt;strong>all_devices&lt;/strong> # 列出所有设备&lt;/li>
&lt;li>&lt;strong>wake_armed&lt;/strong> # 列出可以唤醒系统的设备&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>/deviceenablewake &amp;lt;DeviceName&amp;gt;&lt;/strong> # 指定设备启用唤醒系统功能&lt;/li>
&lt;li>&lt;strong>/devicedisablewake &amp;lt;DeviceName&amp;gt;&lt;/strong> # 指定设备禁用唤醒系统功能&lt;/li>
&lt;li>&lt;strong>/lastwake&lt;/strong> # 查看系统最后一次被唤醒的信息&lt;/li>
&lt;/ul>
&lt;h3 id="example-1">EXAMPLE&lt;/h3>
&lt;ul>
&lt;li>查找可以唤醒电脑的设备
&lt;ul>
&lt;li>powercfg /devicequery wake_armed&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>禁用 NVIDIA USB Type-C Port Policy Controller 这个设备唤醒系统
&lt;ul>
&lt;li>powercfg /devicedisablewake &amp;lsquo;NVIDIA USB Type-C Port Policy Controller&amp;rsquo;&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul></description></item><item><title>Docs: 深度学习框架</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/12.%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E6%A1%86%E6%9E%B6/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/12.%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E6%A1%86%E6%9E%B6/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;h2 id="参考">参考：&lt;/h2>
&lt;/blockquote>
&lt;h1 id="深度学习开源框架">深度学习开源框架&lt;/h1>
&lt;p>PyTorch
百度 飞桨
谷歌 Tenter flow&lt;/p></description></item><item><title>Docs: 图形处理</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/11_%E5%A4%9A%E5%AA%92%E4%BD%93/%E5%9B%BE%E5%BD%A2%E5%A4%84%E7%90%86/%E5%9B%BE%E5%BD%A2%E5%A4%84%E7%90%86/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/11_%E5%A4%9A%E5%AA%92%E4%BD%93/%E5%9B%BE%E5%BD%A2%E5%A4%84%E7%90%86/%E5%9B%BE%E5%BD%A2%E5%A4%84%E7%90%86/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://www.jiqizhixin.com/articles/2019-03-22-10">手把手教你使用OpenCV库（附实例、Python代码解析）&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;h2 id="计算机如何读取图像">计算机如何读取图像？&lt;/h2>
&lt;p>思考以下图片：&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/fhwfe4/1658568420855-b25fc9bb-0d76-4e6f-a1b7-f77be1aff1da.png" alt="image.png">&lt;/p>
&lt;p>我们可以认出它是纽约天际线的图片。 但是计算机可以自己发现这一切吗？答案是不！&lt;/p>
&lt;p>计算机将任何图片都读取为一组 0 到 255 之间的值。&lt;/p>
&lt;p>对于任何一张彩色图片，有三个主通道——红色(R)，绿色(G)和蓝色(B)。它的工作原理非常简单。&lt;/p>
&lt;p>对每个原色创建一个矩阵，然后，组合这些矩阵以提供 R, G 和 B 各个颜色的像素值。&lt;/p>
&lt;p>每一个矩阵的元素提供与像素的亮度强度有关的数据。&lt;/p>
&lt;p>思考下图：
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/fhwfe4/1658568420764-dd8cadc1-402a-49a6-bdff-ccb3e61ba2eb.png" alt="image.png">&lt;/p>
&lt;p>如图所示，图像的大小被计算为 B x A x 3。&lt;/p>
&lt;p>注意：对于黑白图片，只有一个单一通道。&lt;/p>
&lt;h1 id="gpu">GPU&lt;/h1>
&lt;h1 id="图形接口">图形接口&lt;/h1>
&lt;p>有位叫 &lt;strong>Eric Engstrom&lt;/strong>微软大佬去世了。这位老哥没有比尔盖茨这么大的名气，但要是没他，我们现在想要在夜之城夜夜笙歌，估计没那么容易。甚至说 Windows 电脑，可能还只是一台主要的生产力工具，就像苹果 Mac 一样。&lt;/p>
&lt;p>Eric Engstrom 所创立的 DirectX 接口，&lt;strong>把 PC 个人电脑，拽进了电子游戏的世界。&lt;strong>让&lt;/strong>玩电脑游戏&lt;/strong>成为了一种游戏方式。&lt;/p>
&lt;p>先是辛辛苦苦从&lt;strong>3XM&lt;/strong>、&lt;strong>游 X Sky&lt;/strong>上找到资源，然后冒着被老妈发现的危险，电脑挂一晚上把游戏下下来。&lt;/p>
&lt;p>好不容易下完了解压好，兴奋的打开游戏的 exe 文件，正准备抄起鼠标大杀四方，系统却弹出了这么一个窗口。。。&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/scemn1/1616164698340-628dde5f-0dc1-40eb-a57c-7108250c0636.jpeg" alt="">&lt;/p>
&lt;p>这个文件其实是 DirectX 的驱动文件，重新装一下 DirectX 最新驱动就行了。&lt;/p>
&lt;p>正版游戏在运行之前会有一个自检的环节，来确认电脑中是否有相关的驱动文件。&lt;/p>
&lt;p>而上传盗版游戏的黑客，并不会把这部分自检程序放到压缩包里。&lt;/p>
&lt;p>这样一来，用户在解压完游戏之后就会发生文件缺失的情况，需要自己去网上找到对应的文件把它补上。&lt;/p>
&lt;p>&lt;strong>没有 .dll 文件，游戏就跑不起来。&lt;/strong>&lt;/p>
&lt;p>那个时候玩的单机游戏，从&lt;strong>CS 、红警、魔兽争霸 3&lt;/strong>到&lt;strong>GTA 罪恶都市、骑马与砍杀、文明 IV&lt;/strong>等等等等游戏，都是基于&lt;strong>DirectX&lt;/strong>接口开发的。&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/scemn1/1616164698318-16b5b71b-5d9a-4041-b07d-1ce6ac2969ec.png" alt="">&lt;/p>
&lt;p>&lt;strong>DirectX&lt;/strong>的存在，覆盖了整个电脑游戏发展史。&lt;/p>
&lt;p>&lt;strong>那问题来了，为什么在电脑上的游戏离不开 DirectX 呢？&lt;/strong>&lt;/p>
&lt;p>要解答这个问题，我们得先了解一下图形 API 的发展历史。&lt;/p>
&lt;p>早期的软件开发没有统一标准，往往是一个新的硬件出来，程序员就得为它定制开发一套软件来用。&lt;/p>
&lt;p>&lt;strong>这就造成了硬件与硬件，软件与软件之间并不互通。&lt;/strong>&lt;/p>
&lt;p>比如《仙剑奇侠传》，想要在不同的平台上玩，就需要程序员适配三次。&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/scemn1/1616164698352-49bfaa0e-3eff-4c9e-b3b2-c6e19b63fc23.png" alt="">&lt;/p>
&lt;p>基于此，在人类的原始生产力&lt;strong>懒&lt;/strong>的驱使下，程序员们发明出了 &lt;strong>Application Programming Interface(应用编程接口，简称 API)&lt;/strong> 。它的出现统一了所有的开发规范，解决了不同硬件需要适配的问题，大大节省了开发的成本。&lt;/p>
&lt;p>要是用统一的 API，就不需要重复开发了，直接适配。▼&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/scemn1/1616164698353-349c841a-d70a-4584-bc7c-f2c642bcfc94.png" alt="">&lt;/p>
&lt;h2 id="opengl">OpenGL&lt;/h2>
&lt;p>不过那时候率先登场的 API 的并不是 DirectX ，而是大名鼎鼎的 Glide 和 OpenGL ，还没微软什么事。&lt;/p>
&lt;p>Glide 的 API 标准是一家叫 3dfx 的显卡公司创立的，在英伟达崛起之前， 3dfx 的 Voodoo 系列显卡就是当初 3D 游戏的绝对标杆。&lt;/p>
&lt;p>不管是古早的《 DOOM 》、《古墓丽影》还是 FPS 始祖游戏《雷神之锤》，都体现出了 API 接口的巨大优势。原本分散的游戏开发者，都聚集到了统一的平台上来做游戏，人多力量大，无数的新技术和好游戏就源源不断的冒出来了。而微软这边一开始其实并不看好游戏领域，根本不想在游戏方面投资。&lt;/p>
&lt;p>一方面 Windows 95 系统做的也差不多了，随时准备发布，管理层觉得这时候再做一个游戏编程界面没有太大必要。另一方面从老的 MS-DOS 系统上转移到新的环境里开发，谁也不敢保证会怎么样。&lt;/p>
&lt;p>Eric Engstrom 看到了这上面的前景，自己偷偷拉了个三人的小团队，开发起了 DirectX ，顶着微软管理层的压力，把这个项目给做了下来。&lt;/p>
&lt;p>到了 1995 年 4 月， DirectX 正式发布，并在后面逐步融合进了 Windows 95 ，为微软打入游戏市场，立下了汗马功劳。&lt;/p>
&lt;p>有意思的是，在 Eric Engstrom 开发 DirectX 的过程中，不仅要面对技术上的难题，还要面临微软的上层百般阻挠，面对企业内斗。&lt;/p>
&lt;p>这个过程还被写成了一本名为《 Renegades of the Empire 》（《帝国叛逆者》）的书，记述下了那段时间微软内忧外患的处境。&lt;/p>
&lt;p>不过至少结果是好的， DirectX 在经过了几个版本的更新之后，已经稳坐了游戏图形 API 的头把交椅。&lt;/p>
&lt;p>而 Glide 和 OpenGL 却被命运开了玩笑，相继翻车，给 DirectX 占领市场提供了很大机会。&lt;/p>
&lt;p>Glide 翻车是因为 3dfx 的没落，支持 Glide 的游戏及设备越来越少，它不及 Windows 系统有这么多的开发者，又不开源，没多久就顶不住了。&lt;/p>
&lt;p>OpenGL 倒是开源的，不过因为内部意见不统一，它逐渐转向了专业图形领域的方向，渐渐弱化了游戏方面的更新。&lt;/p>
&lt;p>在更新到了 DirectX 9.0 之后，微软在图形 API 的领域，基本坐稳了龙头老大的位置。&lt;/p>
&lt;p>顺带一提，微软的 XBOX 主机用到的也是 DirectX ，这样一来，就形成了一个闭环，但凡厂商想要在主机平台和 PC 平台上开发游戏，就绕不过 DirectX 。&lt;/p>
&lt;p>随之而来的就是 N 卡和 A 卡长达 10 年的显卡大战，由于两边都要用到 DirectX 来优化，&lt;strong>微软的更新就成了制衡 N 、 A 两家发展的砝码。&lt;/strong>&lt;/p>
&lt;h2 id="vulkan">Vulkan&lt;/h2>
&lt;p>OpenGL 的母公司 Khronos 推出了自家的新图形 API &lt;strong>Vulkan&lt;/strong>，意欲动摇 DirectX 的传统优势地位。&lt;/p>
&lt;p>&lt;strong>Vulkan&lt;/strong> 作为一个搅局者，他的强势之处在于跨平台的兼容性，它能在 &lt;strong>Windows、Linux、Android&lt;/strong> 三个平台上开发，连接了电脑和手机端。&lt;/p>
&lt;p>在底层硬件的兼容方面，&lt;strong>Vulkan&lt;/strong> 会更好一些，游戏开发者能更彻底的榨干显卡的性能。&lt;/p>
&lt;p>&lt;strong>未来的竞争或许会更势均力敌一些。。。&lt;/strong>&lt;/p></description></item><item><title>Docs: 文件系统管理</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/y.windows-%E7%AE%A1%E7%90%86/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%AE%A1%E7%90%86/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/y.windows-%E7%AE%A1%E7%90%86/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%AE%A1%E7%90%86/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;h2 id="参考">参考：&lt;/h2>
&lt;/blockquote>
&lt;h1 id="文件系统管理">文件系统管理&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://www.howtogeek.com/318177/what-is-the-appdata-folder-in-windows/">https://www.howtogeek.com/318177/what-is-the-appdata-folder-in-windows/&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>&lt;strong>%USERPROFILE%/AppData/*&lt;/strong> #&lt;/p>
&lt;ul>
&lt;li>&lt;strong>./Local/*&lt;/strong> #&lt;/li>
&lt;li>&lt;strong>./LocalLow/*&lt;/strong> #&lt;/li>
&lt;li>&lt;strong>./Roaming/*&lt;/strong> #&lt;/li>
&lt;/ul></description></item><item><title>Docs: 音箱</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/11_%E5%A4%9A%E5%AA%92%E4%BD%93/%E9%9F%B3%E9%A2%91%E5%A4%84%E7%90%86/%E9%9F%B3%E7%AE%B1/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/11_%E5%A4%9A%E5%AA%92%E4%BD%93/%E9%9F%B3%E9%A2%91%E5%A4%84%E7%90%86/%E9%9F%B3%E7%AE%B1/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;h2 id="参考">参考：&lt;/h2>
&lt;/blockquote>
&lt;p>USB # 声卡输入
AUX IN # (Auxiliary)是指&lt;strong>音频输入。线路输入&lt;/strong>
SUB OUT # 低音输出
DC IN # 电源输入&lt;/p>
&lt;h1 id="音箱品牌">音箱品牌&lt;/h1>
&lt;p>HECATE G2000&lt;/p></description></item><item><title>Docs: 注册表</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/y.windows-%E7%AE%A1%E7%90%86/%E6%B3%A8%E5%86%8C%E8%A1%A8/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/y.windows-%E7%AE%A1%E7%90%86/%E6%B3%A8%E5%86%8C%E8%A1%A8/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://mp.weixin.qq.com/s/5ZcvRNG7GvvopcQWWdXNaw">公众号-差评，所有电脑管家都叫你清理的注册表，竟然能偷偷控制你的电脑！&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;h2 id="注册表前身">注册表前身&lt;/h2>
&lt;p>其实，注册表也不是一开始就存在于 Windows 上。&lt;/p>
&lt;p>在 Windows 95 之前，微软通过一种叫 “ 配置文件 ” 的东西，来实现如今注册表的作用。&lt;/p>
&lt;p>这里面存储的，就是一些软件的&lt;strong>基本信息&lt;/strong>。比如说配置一些文件的打开路径在哪里，或者是软件要用哪些字体来读取。&lt;/p>
&lt;p>通常通过 ini 格式的文件，配置文件会趁着咱们安装各种软件的时候，把自己丢在系统的各种文件夹里。想修改一些配置的时候，咱们可以直接去这个软件的安装目录里找 ini 文件就行。&lt;/p>
&lt;p>看上去挺方便，不过这 ini 文件最大的问题吧，就是太容易修改了，甚至可以简单到直接用记事本给打开。&lt;/p>
&lt;p>到时候手一抖改几个字，可能一个软件就打不开了。&lt;/p>
&lt;p>比如把一个 5 行的行间距手一抖改成复数，软件当场就寻思我哪见过这个？不当场宕机就不错了。万一改的还是系统配置文件，电脑指不定也得抽两抽。&lt;/p>
&lt;p>而且，当年大家用的还都是机械硬盘。。。考虑到 ini 文件分散在系统的各种犄角旮旯，&lt;strong>读取起来太麻烦，打开也嫌慢，更不方便维护。&lt;/strong>&lt;/p>
&lt;p>微软后来就一寻思，干脆把这些乱的到处都是的 ini 文件功能给&lt;strong>整合了起来。&lt;/strong>&lt;/p>
&lt;p>通过一个统一的，系统级别的分层&lt;strong>数据库&lt;/strong>来起到过去 “ 配置文件 ” 做的事情。这个库里面装的呢，就是咱们电脑里哪些花里胡哨，乱七八糟的配置。&lt;/p>
&lt;p>举个例子，我们鼠标右键的每次点击，到底会弹出来哪些菜单选项，以及具体要弹的多长。&lt;strong>都得让注册表来告诉它才行。&lt;/strong>&lt;/p>
&lt;p>而且吧，比起过去各自为战，互相之间看不对眼的配置文件。注册表还能起到一个**系统级别的调度功能，**可以把这些软件之间的信息共享给其它软件，。&lt;/p>
&lt;p>当有新的软件安装的时候，也会优先把自己能干什么，自己需要什么的消息给写入注册表里。&lt;/p>
&lt;p>就像咱们现在能用 WPS 软件来打开 word 文档，中间还得靠注册表这个 “传话筒” 来沟通才行。想让系统能弄清楚，我们得把 &lt;strong>“ wps 可以打开 word ” 文档这件事情，写到注册表里。&lt;/strong>&lt;/p>
&lt;p>借助当时更为先进的数据库结构，注册表还能够实现**多用户配置和多线程读写等功能。**别看咱们现在嫌弃注册表长的丑，&lt;strong>要知道当年，这可是少有的图形可视化界面。&lt;/strong>&lt;/p>
&lt;h2 id="注册表小解">注册表小解&lt;/h2>
&lt;p>按 win + R，在对话框里输入 “ regedit ” 来打开注册表编辑器。
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/qnpbng/1660293598735-fcf30cc1-e1be-40a6-91da-e8cf808c68a0.png" alt="">
&lt;strong>HKEY_CLASSES_ROOT&lt;/strong> # 包含有关已注册应用程序的信息 ， 包括驱动 ， 文件拓展名等等 。
&lt;strong>HKEY_CURRENT_USER&lt;/strong> # 存储特定于当前登录用户的设置 ， 包括环境变量 ， 个人桌面的设置等等 。
&lt;strong>HKEY_LOCAL_MACHINE&lt;/strong> # 存储特定于本地计算机的设置 ， 由系统内核维护在内存中 ， 以便映射所有其他子键 。 这些信息可以其它用户使用 。
&lt;strong>HKEY_USERS&lt;/strong> # 和上面的第二个项目相对 ， 包含与机器上主动加载的每个用户配置文件的 HKEY_CURRENT_USER 键对应的子键
&lt;strong>HKEY_CURRENT_CONFIG&lt;/strong> # 该主键保存了计算机当前硬件的配置信息 ， 这些配置可以根据当前所连接的网络类型或硬件驱动软件安装的改变而改变 。&lt;/p>
&lt;h3 id="备份注册表">备份注册表&lt;/h3>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/qnpbng/1660294119487-0956a3de-ee96-4771-9584-b5e4e473ab0a.png" alt="image.png">&lt;/p>
&lt;h1 id="应用示例">应用示例&lt;/h1>
&lt;h3 id="在鼠标右键菜单上添加内容">在鼠标右键菜单上添加内容&lt;/h3>
&lt;p>打开注册表后，在表上的地址栏里输入这个：&lt;code>HKEY_CLASSES_ROOT\Directory\Background\shell&lt;/code>
在 shell 中“添加项”，添加的项名就是右键菜单中的功能名
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/qnpbng/1660293800817-e8b7c6ec-a7e6-4cdc-af1b-fba835707b2f.png" alt="image.png">
不过这回还没给它加上功能，直接点击的话会报错。
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/qnpbng/1660293861254-00b77fdd-b0d2-4f40-b5a1-59f215198b70.png" alt="">
在 “lichenhao”项下添加 “command”项；修改 command 项中的默认值为想要运行进程的绝对路径
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/qnpbng/1660294056508-703dab2f-1fad-4a5e-a9ec-3ae07245dd93.png" alt="image.png">
此时右键的 “lichenhao”就可以运行 Python 了。&lt;/p></description></item><item><title>Docs: dell硬件监控OMSA</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/6.%E5%8F%AF%E8%A7%82%E6%B5%8B%E6%80%A7/%E7%9B%91%E6%8E%A7%E7%B3%BB%E7%BB%9F/dell%E7%A1%AC%E4%BB%B6%E7%9B%91%E6%8E%A7omsa/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/6.%E5%8F%AF%E8%A7%82%E6%B5%8B%E6%80%A7/%E7%9B%91%E6%8E%A7%E7%B3%BB%E7%BB%9F/dell%E7%A1%AC%E4%BB%B6%E7%9B%91%E6%8E%A7omsa/</guid><description>
&lt;h1 id="omsa全称-openmanage-server-administrator是戴尔公司自主研发的-it-系统管理解决方案">OMSA（全称 Openmanage Server Administrator),是戴尔公司自主研发的 IT 系统管理解决方案。&lt;/h1>
&lt;p>&lt;a href="http://linux.dell.com/">http://linux.dell.com/&lt;/a>
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/gknv4x/1616067497715-90aa8503-f2c3-4436-ac53-560ef9f66d5f.jpeg" alt="">&lt;/p>
&lt;h2 id="omsa-的安装">OMSA 的安装&lt;/h2>
&lt;h3 id="自动安装">自动安装&lt;/h3>
&lt;p>&lt;a href="https://linux.dell.com/repo/hardware/dsu/">https://linux.dell.com/repo/hardware/dsu/&lt;/a>&lt;/p>
&lt;ol>
&lt;li>配置存储库
&lt;ol>
&lt;li>curl -O &lt;a href="https://linux.dell.com/repo/hardware/dsu/bootstrap.cgi">https://linux.dell.com/repo/hardware/dsu/bootstrap.cgi&lt;/a>&lt;/li>
&lt;li>bash bootstrap.cgi&lt;/li>
&lt;/ol>
&lt;/li>
&lt;li>yum install srvadmin-all.x86_64&lt;/li>
&lt;/ol>
&lt;p>Note：&lt;/p>
&lt;ol>
&lt;li>srvadmin-base #代理程序，可以生成 snmp 信息&lt;/li>
&lt;li>srvadmin-server-cli #命令行客户端，可以通过命令行查看硬件信息&lt;/li>
&lt;li>srvadmin-storage-cli #存储资源的命令行客户端，不安装这个则无法获取 raid 和硬盘的数据&lt;/li>
&lt;/ol>
&lt;p>下面是使用 yum 安装 OMSA 的 repo 文件&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>~&lt;span style="color:#f92672">]&lt;/span>&lt;span style="color:#75715e"># cat /etc/yum.repos.d/DELL-OMSA.repo&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">[&lt;/span>dell-system-update_independent&lt;span style="color:#f92672">]&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>name&lt;span style="color:#f92672">=&lt;/span>dell-system-update_independent
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>baseurl&lt;span style="color:#f92672">=&lt;/span>https://linux.dell.com/repo/hardware/dsu/os_independent/
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>gpgcheck&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>gpgkey&lt;span style="color:#f92672">=&lt;/span>https://linux.dell.com/repo/hardware/dsu/public.key
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> https://linux.dell.com/repo/hardware/dsu/public_gpg3.key
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>enabled&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>exclude&lt;span style="color:#f92672">=&lt;/span>dell-system-update*.i386
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">[&lt;/span>dell-system-update_dependent&lt;span style="color:#f92672">]&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>name&lt;span style="color:#f92672">=&lt;/span>dell-system-update_dependent
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>mirrorlist&lt;span style="color:#f92672">=&lt;/span>https://linux.dell.com/repo/hardware/dsu/mirrors.cgi?osname&lt;span style="color:#f92672">=&lt;/span>el$releasever&amp;amp;basearch&lt;span style="color:#f92672">=&lt;/span>$basearch&amp;amp;native&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>gpgcheck&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>gpgkey&lt;span style="color:#f92672">=&lt;/span>https://linux.dell.com/repo/hardware/dsu/public.key
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> https://linux.dell.com/repo/hardware/dsu/public_gpg3.key
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>enabled&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>参考文章：&lt;a href="http://www.madown.com/2017/05/23/81/">http://www.madown.com/2017/05/23/81/&lt;/a>&lt;/p>
&lt;h3 id="手动安装">手动安装&lt;/h3>
&lt;p>&lt;a href="https://www.dell.com/support/home/">https://www.dell.com/support/home/&lt;/a>去该网站输入主机号查询，然后根据关键字搜索 OMSA 并下载
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/gknv4x/1616067497724-a84a9901-d1a0-4c18-9198-303c071c9960.jpeg" alt="">&lt;/p>
&lt;ol>
&lt;li>解压已下载的安装包
&lt;ol>
&lt;li>mkdir dell-omsa&lt;/li>
&lt;li>tar -zxvf OM-SrvAdmin-Dell-Web-LX-9.3.0-3465_A00.tar -C dell-omsa #&lt;/li>
&lt;/ol>
&lt;/li>
&lt;li>安装 rpm 包
&lt;ol>
&lt;li>cd dell-omsa/linux/RPMS/supportRPMS/srvadmin/RHEL7/x86_64&lt;/li>
&lt;li>yum localinstall *.rpm&lt;/li>
&lt;/ol>
&lt;/li>
&lt;/ol>
&lt;p>将 dell-r740.tar.gz 拷贝到/root/Download 目录下并执行以下脚本&lt;/p>
&lt;h2 id="omsa-的配置与使用">OMSA 的配置与使用&lt;/h2>
&lt;p>安装 dell 监控 openManager 相关组件完成后，会在/opt/dell/*目录下生成配置文件与可执行文件&lt;/p>
&lt;ul>
&lt;li>配置 openManager&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/gknv4x/1616067497704-782c72fb-2dcf-4422-9654-b71a7c89d1eb.jpeg" alt="">&lt;/p>
&lt;ul>
&lt;li>/opt/dell/srvadmin/sbin/srvadmin-services.sh start #启动 openManger
&lt;ul>
&lt;li>该脚本会通过 systemd 启动三个服务&lt;/li>
&lt;li>instsvcdrv #&lt;/li>
&lt;li>dataeng #&lt;/li>
&lt;li>dsm_om_connsvc #web 控制台&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>/opt/dell/srvadmin/sbin/srvadmin-services.sh enable #设置开机自启 openManager&lt;/li>
&lt;li>systemctl stop dsm_om_connsvc #关闭 openManager 的 web 服务&lt;/li>
&lt;li>systemctl disable dsm_om_connsvc #将 openManager 的 web 服务开机自启关闭&lt;/li>
&lt;li>systemctl restart snmpd #重启 snmp 服务。由于安装 openManager 会在 snmpd 的配置文件中写入内容，所以需要重启 snmpd 服务使得该配置生效&lt;/li>
&lt;li>在 wiseman 上添加相关的 dell 硬件监控。效果如图，在主机的模板里添加 dell server 模板&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/gknv4x/1616067497780-3afd659e-d460-4c2b-8d66-1f9a3c67890a.jpeg" alt="">&lt;/p>
&lt;h1 id="命令行工具使用说明">命令行工具使用说明&lt;/h1>
&lt;h2 id="omreport-command">omreport COMMAND&lt;/h2>
&lt;p>在任何时候都可以使用 omreport -?来获取命令帮助以查看都有哪些可用的 COMMAND，例如：omreport -?、omreport chassis -?等
COMMAND&lt;/p>
&lt;ol>
&lt;li>about Product and version properties.&lt;/li>
&lt;li>licenses Displays the digital licenses of the installed hardware devices.&lt;/li>
&lt;li>preferences Report system preferences.&lt;/li>
&lt;li>system System component properties.&lt;/li>
&lt;li>chassis 机架组件的属性。i.e.基本硬件的信息。Chassis component properties.&lt;/li>
&lt;li>storage #显示存储组件的属性&lt;/li>
&lt;/ol>
&lt;h2 id="omreport-storage">omreport storage&lt;/h2>
&lt;p>EXAMPLE&lt;/p>
&lt;ol>
&lt;li>omreport storage pdisk controller=0 #&lt;/li>
&lt;/ol></description></item><item><title>Docs:</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/0_%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E7%B1%BB-unix-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/euleros-%E4%B8%8E-openeuler/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/0_%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E7%B1%BB-unix-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/euleros-%E4%B8%8E-openeuler/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://developer.huaweicloud.com/ict/cn/site-euleros/euleros">EulerOS 官网&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.openeuler.org/zh/">OpenEuler 官网&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>华为真是把造词玩明白了，乱七八糟的，本家私有化的产品就一堆重复早轮子的名字，连开源系统都整俩名字&lt;/p>
&lt;p>EulerOS 与 OpenEuler&lt;/p>
&lt;ul>
&lt;li>EulerOS # 企业&lt;/li>
&lt;li>OpenEuler # 开源&lt;/li>
&lt;/ul></description></item><item><title>Docs: (弃用)Graph 类型面板详解</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/6.%E5%8F%AF%E8%A7%82%E6%B5%8B%E6%80%A7/grafana/panel%E9%9D%A2%E6%9D%BF-%E4%B8%8E-dashboard%E4%BB%AA%E8%A1%A8%E7%9B%98/time-series-%E7%B1%BB%E5%9E%8B%E9%9D%A2%E6%9D%BF/%E5%BC%83%E7%94%A8graph-%E7%B1%BB%E5%9E%8B%E9%9D%A2%E6%9D%BF%E8%AF%A6%E8%A7%A3/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/6.%E5%8F%AF%E8%A7%82%E6%B5%8B%E6%80%A7/grafana/panel%E9%9D%A2%E6%9D%BF-%E4%B8%8E-dashboard%E4%BB%AA%E8%A1%A8%E7%9B%98/time-series-%E7%B1%BB%E5%9E%8B%E9%9D%A2%E6%9D%BF/%E5%BC%83%E7%94%A8graph-%E7%B1%BB%E5%9E%8B%E9%9D%A2%E6%9D%BF%E8%AF%A6%E8%A7%A3/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;/blockquote>
&lt;p>这是一个初始的 Graph 面板，有两条查询语句，更改了序列的名称。&lt;/p>
&lt;pre>&lt;code>sum(node_memory_MemTotal_bytes)
(sum(node_memory_MemTotal_bytes{} - node_memory_MemAvailable_bytes{}) / sum(node_memory_MemTotal_bytes{}))*100
&lt;/code>&lt;/pre>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/qzbd5e/1616067957167-730a2679-0ad0-488a-9c4c-8f3ba5ace79d.png" alt="">&lt;/p>
&lt;p>Graph 是一个二维的，具有 x/y Axes(轴) 的面板。x 轴(横轴) 以时间分布、y 轴(纵轴) 以样本值分布&lt;/p>
&lt;p>下面的文章将只介绍 Graph 面板的独有配置，有很多共有配置详见&lt;a href="https://www.yuque.com/go/doc/33145831">此处&lt;/a>&lt;/p>
&lt;h1 id="panel--面板配置">Panel # 面板配置&lt;/h1>
&lt;h2 id="display--显示设置值的显示样式柱状线条圆点三种">Display # 显示。设置值的显示样式(柱状、线条、圆点三种)&lt;/h2>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/qzbd5e/1616067957211-044eecd5-5b98-425a-8de8-3799545d50f6.png" alt="">&lt;/p>
&lt;p>在 Display 标签里，有 5 个开关，Bars、Lines、Staircase、Points 用于指定值的显示样式。Alert thresholds 用于指定是否显示告警阈值。&lt;/p>
&lt;blockquote>
&lt;p>其他的配置选项，都是在开启某个样式后，才会显示对应样式专用的选项。
Min step 设置时间长一点，Bars 与 Points 样式才可以看出来效果。否则都挤到一坨去了~&lt;/p>
&lt;/blockquote>
&lt;p>&lt;strong>Bars&lt;/strong> # 柱状图样式。当 X 轴的模式变为 Series、Historgram 时，自动开启
&lt;strong>Lines&lt;/strong> # 线条样式。默认样式&lt;/p>
&lt;ul>
&lt;li>&lt;strong>Staircase&lt;/strong> # 开启线条样式时，才可以使用这种样式。&lt;/li>
&lt;li>&lt;strong>Line width&lt;/strong> # 线条宽度。&lt;/li>
&lt;li>&lt;strong>Area fill&lt;/strong> # 线条到底部这一区域的填充度。默认 1。&lt;/li>
&lt;li>&lt;strong>Fill gradient&lt;/strong> # 填充渐变。默认 0。&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>Points&lt;/strong> # 圆点样式。
&lt;strong>Point radius&lt;/strong> # 每个圆点的半径
&lt;strong>Alert thresholds&lt;/strong> # 在面板上显示报警阈值和区域&lt;/p>
&lt;p>除了设置面板中值的显示样式，还可以设置一些其他的设置
&lt;strong>Stacking and null value(叠加与空值)&lt;/strong>
用于在面板上叠加所有 series 的值&lt;/p>
&lt;p>**Hover tooltip(悬停提示) # **开启后，鼠标悬停在面板上，会出现一些关于 series 的信息
Mode # 模式。&lt;/p>
&lt;ul>
&lt;li>All series # 鼠标悬停到面板时，显示所有 series 的信息&lt;/li>
&lt;li>Single # 鼠标选定到面板时，只显示鼠标所在的 series 的信息。&lt;/li>
&lt;/ul>
&lt;p>Sort order # 排序。有三种排序方式：None(不排序)、Increasing(由上到下逐渐增大)、Decreasing(由上到下逐渐减小)&lt;/p>
&lt;h2 id="series-overrides--序列替换用于个性化每个序列的配置">Series overrides # 序列替换。用于个性化每个序列的配置&lt;/h2>
&lt;p>顾名思义，就是用来替换序列样式的。当一个面板上，配置了多个查询语句，这时就会产生多条 Series。而右侧的配置，是统一的，所有 Series 的配置内容都一样，这样不利于数据展示。所以通过 Series overrides 可以个性化得配置每一条 Series，让不同的 Series 展示出不同的效果(比如多条 Series 可以具有不同的单位、不同的线条宽度不同、不同的显示方式)&lt;/p>
&lt;p>点击 &lt;code>+ Add series override&lt;/code> 即可为指定的 series 进行配置&lt;/p>
&lt;p>在 &lt;code>Alias or regex&lt;/code> 选择要配置的序列。这里也可以使用正则表达式进行多个 series 的匹配。然后点击 &lt;code>+&lt;/code> 符号，即可为选定的 series 进行单独的配置。&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/qzbd5e/1616067957244-03bc347c-faa5-4145-8a6b-fe3138242f0b.png" alt="">&lt;/p>
&lt;h3 id="应用实例">应用实例&lt;/h3>
&lt;p>上面的例子，一个语句是内存用量，一个语句是内存使用率，单位是不一样(一个 KiB、一个百分比)。这时候，就需要使用 Series overrides，为每个 Serie 单独配置。不但单位可以分别配置，还可以将 Serie 移动到右侧的 Y 轴。还可以为不同的 series 配置不用的显示方式(比如有的用圆点、有点用线条、有的用柱状图，都可以在同一个面板显示出来)&lt;/p>
&lt;p>比如我现在为 总平均使用率 序列进行单独配置，面板就会变成下面这种效果：
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/qzbd5e/1616067957204-1cae00cd-e82c-4042-9d6b-11daed4f9b8f.png" alt="">&lt;/p>
&lt;h2 id="axis--设定坐标轴的显示内容">Axis # 设定坐标轴的显示内容&lt;/h2>
&lt;p>在这里可以更改 x 轴 和 y 轴 的显示内容。常用于配置 metrics 值的 unit(单位)、Decimals(小数位数)。&lt;/p>
&lt;p>&lt;strong>Left Y/Right Y&lt;/strong> # 更改 Y-axes(Y 轴) 的信息&lt;/p>
&lt;ul>
&lt;li>Show # 是否显示这个轴&lt;/li>
&lt;li>Unit # 配置 Y 轴 的单位&lt;/li>
&lt;li>Decimals # 配置 Y 轴显示的小数位数。&lt;/li>
&lt;li>Label # 配置 Y 轴 的标签(标签会显示在 Y 轴 的旁边)&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>Y-Axes&lt;/strong> # Y 轴 配置。一些对齐方式
&lt;strong>X-Axis&lt;/strong> # X 轴 配置。可以更改 X 轴的 Mode(模式)&lt;/p>
&lt;ul>
&lt;li>Mode # 模式。用于改变 X 轴的 显示模式。
&lt;ul>
&lt;li>Time # 时间模式。默认模式。X 轴 表示 时间，数据按时间分组（例如，按小时或分钟）。&lt;/li>
&lt;li>Series # 序列模式。X 轴 表示 series，数据按照序列分组。Y 轴 仍然代表该序列的值
&lt;ul>
&lt;li>注意：当 X 轴 切换到 Series 模式时，Display 配置中的将自动使用柱状图的方式&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Histogram # 直方图模式。X 轴 表示 序列的值，Y 轴 表示 该值的计数。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h3 id="x-轴的-series-模式-示例">X 轴的 Series 模式 示例&lt;/h3>
&lt;p>当 X 轴 变为 series 模式 时，由于没有时间这种维度，所以一般都使用 当前值。
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/qzbd5e/1616067957169-8ff35969-aa1d-4259-8144-1a88bb33a486.png" alt="">&lt;/p>
&lt;h2 id="legend--用于配置面板内的-legenddocsit学习笔记6可观测性grafanapanel面板20-与20dashboard仪表盘panel面板20-配置详解md-配置详解md">Legend # 用于配置面板内的 [Legend](/docs/IT学习笔记/6.可观测性/Grafana/Panel(面板)%20 与%20Dashboard(仪表盘)/Panel(面板)%20 配置详解.md 配置详解.md)&lt;/h2>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/qzbd5e/1616067957204-998bd4db-f185-4f42-9138-9edb69081d84.png" alt="">&lt;/p>
&lt;h2 id="time-regions--时间区域graph-类型面板不常用">Time regions # 时间区域。Graph 类型面板不常用&lt;/h2>
&lt;h1 id="field--字段配置">Field # 字段配置&lt;/h1>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/qzbd5e/1616067957229-733ae428-0442-42e4-b76e-d36f89196a3d.png" alt="">&lt;/p>
&lt;h1 id="overrides--字段替换配置graph-类型面板不常用">Overrides # 字段替换配置，Graph 类型面板不常用&lt;/h1>
&lt;p>详见：[Overrides](/docs/IT学习笔记/6.可观测性/Grafana/Panel(面板)%20 与%20Dashboard(仪表盘)/Panel(面板)%20 配置详解.md 配置详解.md)&lt;/p></description></item><item><title>Docs: 「你天天关注这些新闻有什么用？」</title><link>https://desistdaydream.github.io/docs/%E7%A5%9E%E5%A5%87/%E8%AF%AD%E8%A8%80/%E4%BD%A0%E5%A4%A9%E5%A4%A9%E5%85%B3%E6%B3%A8%E8%BF%99%E4%BA%9B%E6%96%B0%E9%97%BB%E6%9C%89%E4%BB%80%E4%B9%88%E7%94%A8/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/%E7%A5%9E%E5%A5%87/%E8%AF%AD%E8%A8%80/%E4%BD%A0%E5%A4%A9%E5%A4%A9%E5%85%B3%E6%B3%A8%E8%BF%99%E4%BA%9B%E6%96%B0%E9%97%BB%E6%9C%89%E4%BB%80%E4%B9%88%E7%94%A8/</guid><description>
&lt;p>原文：&lt;a href="https://mp.weixin.qq.com/s/Lnw3wdJ0CQ88QV8bHsvWzw">公众号-唐一水&lt;/a>
这是我前段时间，后台收到的一句质问。
具体信息我已翻找不到，只记得发这句质问的，是个从头像到昵称，都在彰显岁月静好正能量的中年网友。
我看到这个质问的那一刻，内心那个埋藏许久的声音也瞬间响起：是啊，我关注那么多新闻，我和读者们愤怒、发声、传播了那么多次，其实，又有什么用？
惨剧依旧在重复，不公依旧在上演，疫情、战争、自然灾害、性别暴力，无数不可抗拒的力量依旧将我们碾压，我们关注的唯一用处，似乎就是让自己和社会，更加陷入到「政治性抑郁」。
我们其实完全有另外一个选择——
不听不看，不烦不忧。
我也可以岁月静好，拍拍抖音卡点，发发情感文案，去做一个更稳当美好的自媒体人。各位也可以积极向上，看看正能量，转转暖心事，去做一个每天等待「反转」的理性网友。
但为什么不愿意呢？为什么做不到呢？
明明「政治性抑郁」已令你痛苦疲惫，需要通过停止阅读社交媒体来自我修复，可为什么第二天当再看到那些不公和惨剧，你依然会关注、会愤怒、会发声、会传播？
这个世界少一个「政治性抑郁」的人，多一个「政治性冷漠」的人，又能怎么样，可为什么，你就是不愿意快乐地冷漠着？
也许是因为我们明白，此刻的冷漠，只会换来未来更大的抑郁及荒谬，而那些使我们抑郁的存在，最乐于看到我们的冷漠，好成全一切使其获利的荒谬。
也许是因为我们明白，世界的本质就是荒谬——正义能被轻易打破、善恶并不遵循因果、法律和道德随时准备双标，人只能以「作为」抵抗荒谬。本身就因「无作为」而暴露的荒谬，如果我们仍以「无作为」对待，世界所剩下的，也就只有荒谬叠加荒谬。
当我们向「政治性抑郁」投降时，我们也就只配输给荒谬。
也许是因为我们明白，「政治性抑郁」本质就是一种妄自菲薄，我们以为面对坏消息，自己只能「无作为」。
可是「抑郁」本身就是一种「作为」。情绪，就是改变的开始。
社会历史的改变、进步、对灾难的预防，恰恰发源于一代又一代人的政治性抑郁，先哲前辈们自封建时代一路演进，正是依托一次次情绪的浪潮，而此刻的抑郁，不过是时代责任落于双肩，必然产生的痛楚。
也许是因为我们明白，正如徐贲所说，知识分子没有沉默的权利。当我们的学识，能够让我们理解什么是「政治性冷漠」时，我们就已没有资格去选择「政治性冷漠」。
当下观点市场中，大谈所谓消除或缓解「政治性抑郁」，太容易落入犬儒主义的圈套。当避免共情和社会责任变成一种理所当然的选择，冷漠必将成为主流。
你所受的教育和所学的知识，既是你发声的能力所在，更是你发声的义务所在。如果连能理解这一切荒谬的你都不再发声，你还能指望谁来替你发声，你又凭什么指望谁来替你发声。
这个社会最不缺「政治性冷漠」的人，不关心公共议题，更无视道德自律，他们蒙住双眼，他们面朝大海，甚至会嫌弃发声者聒噪：
「你天天关注这些新闻有什么用？」
「我也不知道。我只是不想成为你们。」&lt;/p></description></item><item><title>Docs: 【BPF网络篇系列-2】容器网络延时之 ipvs 定时器篇 | 深入浅出 eBPF</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2.kernel%E5%86%85%E6%A0%B8/bpf/bpf-%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6%E6%9C%BA%E5%88%B6/bpf%E7%BD%91%E7%BB%9C%E7%AF%87%E7%B3%BB%E5%88%97-2%E5%AE%B9%E5%99%A8%E7%BD%91%E7%BB%9C%E5%BB%B6%E6%97%B6%E4%B9%8B-ipvs-%E5%AE%9A%E6%97%B6%E5%99%A8%E7%AF%87-_-%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA-ebpf/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2.kernel%E5%86%85%E6%A0%B8/bpf/bpf-%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6%E6%9C%BA%E5%88%B6/bpf%E7%BD%91%E7%BB%9C%E7%AF%87%E7%B3%BB%E5%88%97-2%E5%AE%B9%E5%99%A8%E7%BD%91%E7%BB%9C%E5%BB%B6%E6%97%B6%E4%B9%8B-ipvs-%E5%AE%9A%E6%97%B6%E5%99%A8%E7%AF%87-_-%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA-ebpf/</guid><description>
&lt;h2 id="1-前言">1. 前言&lt;/h2>
&lt;p>趣头条的容器化已经开展了一年有余，累计完成了近 1000 个服务的容器化工作，微服务集群的规模也达到了千台以上的规模。随着容器化服务数量和集群规模的不断增大，除了常规的 API Server 参数优化、Scheduler 优化等常规优化外，近期我们还碰到了 kubernetes 底层负载均衡 ipvs 模块导致的网络抖动问题，在此把整个问题的分析、排查和解决的思路进行总结，希望能为有类似问题场景解决提供一种思路。&lt;/p>
&lt;p>涉及到的 k8s 集群和机器操作系统版本如下：&lt;/p>
&lt;ul>
&lt;li>k8s 阿里云 ACK 14.8 版本，网络模型为 CNI 插件 &lt;a href="https://github.com/AliyunContainerService/terway">terway&lt;/a> 中的 terway-eniip 模式；&lt;/li>
&lt;li>操作系统为 CentOS 7.7.1908，内核版本为 3.10.0-1062.9.1.el7.x86_64；&lt;/li>
&lt;/ul>
&lt;h2 id="2-网络抖动问题">2. 网络抖动问题&lt;/h2>
&lt;p>在容器集群中新部署的服务 A，在测试初期发现通过服务注册发现访问下游服务 B（在同一个容器集群） 调用延时 999 线偶发抖动，测试 QPS 比较小，从业务监控上看起来比较明显，最大的延时可以达到 200 ms。&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/a705eb8d-74c1-4b40-bb71-60999d58cfc8/service_latency_high.png" alt="">&lt;/p>
&lt;p>图 2-1 服务调用延时&lt;/p>
&lt;p>服务间的访问通过 gRPC 接口访问，节点发现基于 consul 的服务注册发现。通过在服务 A 容器内的抓包分析和排查，经过了以下分析和排查：&lt;/p>
&lt;ul>
&lt;li>服务 B 部分异常注册节点，排除异常节点后抖动情况依然存在；&lt;/li>
&lt;li>HTTP 接口延时测试， 抖动情况没有改善；&lt;/li>
&lt;li>服务 A 在 VM（ECS）上部署测试，抖动情况没有改善；&lt;/li>
&lt;/ul>
&lt;p>经过上述的对比测试，我们逐步把范围缩小至服务 B 所在的主机上的底层网络抖动。&lt;/p>
&lt;p>经过多次 ping 包测试，我们寻找到了某台主机 A 与 主机 B 两者之间的 ping 延时抖动与服务调用延时抖动规律比较一致，由于 ping 包 的分析比 gRPC 的分析更加简单直接，因此我们将目标转移至底层网络的 ping 包测试的轨道上。&lt;/p>
&lt;p>能够稳定复现的主机环境如下图，通过主机 A ping 主机 B 中的容器实例 172.23.14.144 实例存在 ping 延时抖动。&lt;/p>
&lt;p>|&lt;/p>
&lt;pre>&lt;code>1
2
3
&lt;/code>&lt;/pre>
&lt;p>|&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># 主机 B 中的 Pod IP 地址&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># ip route|grep 172.23.14.144&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>172.23.14.144 dev cali95f3fd83a87 scope link
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>|&lt;/p>
&lt;p>![ping_host_container] (imgs/ping_host_container.png)&lt;/p>
&lt;p>图 2-2 ping 测试涉及到的主机和容器拓扑图&lt;/p>
&lt;p>基于主机 B 网络 eth1 和容器网络 cali-xxx 进行 ping 的对比结果如图：&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/a705eb8d-74c1-4b40-bb71-60999d58cfc8/ping_host_container_detail.png" alt="">&lt;/p>
&lt;p>图 2-3 ping 主机与容器网络详情&lt;/p>
&lt;p>通过多次测试我们发现至 Node 主机 B 主机网络的 ping 未有抖动，容器网络 cali-xx 存在比较大的抖动，最高达到 133 ms。&lt;/p>
&lt;p>在 ping 测试过程中分别在主机 A 和主机 B 上使用 tcpdump 抓包分析，发现在主机 B 上的 eth1 与网卡 cali95f3fd83a87 之间的延时达 133 ms。&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/a705eb8d-74c1-4b40-bb71-60999d58cfc8/ping_server_pcap.png" alt="">&lt;/p>
&lt;p>图 2-4 主机 B 上的 ping 包延时&lt;/p>
&lt;p>到此为止问题已经逐步明确，在主机 B 上接收到 ping 包在转发过程中有 100 多 ms 的延时，那么是什么原因导致的 ping 数据包在主机 B 转发的延时呢？&lt;/p>
&lt;h2 id="3-问题分析">3. 问题分析&lt;/h2>
&lt;p>在分析 ping 数据包转发延时的情况之前，我们首先简单回顾一下网络数据包在内核中工作机制和数据流转路径。&lt;/p>
&lt;h3 id="31-网络数据包内核中的处理流程">3.1 网络数据包内核中的处理流程&lt;/h3>
&lt;p>在内核中，网络设备驱动是通过中断的方式来接受和处理数据包。当网卡设备上有数据到达的时候，会触发一个硬件中断来通知 CPU 来处理数据，此类处理中断的程序一般称作 ISR (Interrupt Service Routines)。ISR 程序不宜处理过多逻辑，否则会它设备的中断处理无法及时响应。因此 Linux 中将中断处理函数分为上半部和下半部。上半部是只进行最简单的工作，快速处理然后释放 CPU。剩下将绝大部分的工作都放到下半部中，下半部中逻辑有内核线程选择合适时机进行处理。&lt;/p>
&lt;p>Linux 2.4 以后内核版本采用的下半部实现方式是软中断，由 ksoftirqd 内核线程全权处理， 正常情况下每个 CPU 核上都有自己的软中断处理数队列和 &lt;code>ksoftirqd&lt;/code> 内核线程。软中断实现只是通过给内存中设置一个对应的二进制值来标识，软中断处理的时机主要为以下 2 种：&lt;/p>
&lt;ul>
&lt;li>硬件中断 &lt;code>irq_exit&lt;/code>退出时；&lt;/li>
&lt;li>被唤醒 &lt;code>ksoftirqd&lt;/code> 内核线程进行处理软中断；&lt;/li>
&lt;/ul>
&lt;p>常见的软中断类型如下：&lt;/p>
&lt;p>|&lt;/p>
&lt;pre>&lt;code>1
2
3
4
5
6
7
&lt;/code>&lt;/pre>
&lt;p>|&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-c" data-lang="c">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">enum&lt;/span>{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> HI_SOFTIRQ&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">0&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> TIMER_SOFTIRQ,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> NET_TX_SOFTIRQ, &lt;span style="color:#75715e">// 网络数据包发送软中断
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> NET_RX_SOFTIRQ, &lt;span style="color:#75715e">// 网络数据包接受软中断
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#75715e">//...
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>};
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>|&lt;/p>
&lt;p>代码 3-1 Linux 软中断类型&lt;/p>
&lt;p>优先级自上而下，HI_SOFTIRQ 的优先级最高。其中 &lt;code>NET_TX_SOFTIRQ&lt;/code> 对应于网络数据包的发送， &lt;code>NET_RX_SOFTIRQ&lt;/code> 对应于网络数据包接受，两者共同完成网络数据包的发送和接收。&lt;/p>
&lt;p>网络相关的中断程序在网络子系统初始化的时候进行注册， &lt;code>NET_RX_SOFTIRQ&lt;/code> 的对应函数为 &lt;code>net_rx_action()&lt;/code> ，在 &lt;code>net_rx_action()&lt;/code> 函数中会调用网卡设备设置的 &lt;code>poll&lt;/code> 函数，批量收取网络数据包并调用上层注册的协议函数进行处理，如果是为 ip 协议，则会调用 &lt;code>ip_rcv&lt;/code>，上层协议为 icmp 的话，继续调用 &lt;code>icmp_rcv&lt;/code> 函数进行后续的处理。&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/a705eb8d-74c1-4b40-bb71-60999d58cfc8/netcard_dev_softirq.png" alt="">&lt;/p>
&lt;p>图 3-1 网卡设备数据包接收示意图&lt;/p>
&lt;p>|&lt;/p>
&lt;pre>&lt;code> 1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
&lt;/code>&lt;/pre>
&lt;p>|&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-c" data-lang="c">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">//net/core/dev.c
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">static&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span> __init &lt;span style="color:#a6e22e">net_dev_init&lt;/span>(&lt;span style="color:#66d9ef">void&lt;/span>){
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ......
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">for_each_possible_cpu&lt;/span>(i) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">struct&lt;/span> softnet_data &lt;span style="color:#f92672">*&lt;/span>sd &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#f92672">&amp;amp;&lt;/span>&lt;span style="color:#a6e22e">per_cpu&lt;/span>(softnet_data, i);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">memset&lt;/span>(sd, &lt;span style="color:#ae81ff">0&lt;/span>, &lt;span style="color:#66d9ef">sizeof&lt;/span>(&lt;span style="color:#f92672">*&lt;/span>sd));
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">skb_queue_head_init&lt;/span>(&lt;span style="color:#f92672">&amp;amp;&lt;/span>sd&lt;span style="color:#f92672">-&amp;gt;&lt;/span>input_pkt_queue);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">skb_queue_head_init&lt;/span>(&lt;span style="color:#f92672">&amp;amp;&lt;/span>sd&lt;span style="color:#f92672">-&amp;gt;&lt;/span>process_queue);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> sd&lt;span style="color:#f92672">-&amp;gt;&lt;/span>completion_queue &lt;span style="color:#f92672">=&lt;/span> NULL;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">INIT_LIST_HEAD&lt;/span>(&lt;span style="color:#f92672">&amp;amp;&lt;/span>sd&lt;span style="color:#f92672">-&amp;gt;&lt;/span>poll_list); &lt;span style="color:#75715e">// 软中断的处理中的 poll 函数列表
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#75715e">// ......
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ......
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">open_softirq&lt;/span>(NET_TX_SOFTIRQ, net_tx_action); &lt;span style="color:#75715e">// 注册网络数据包发送的软中断
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#a6e22e">open_softirq&lt;/span>(NET_RX_SOFTIRQ, net_rx_action); &lt;span style="color:#75715e">// 注册网络数据包接受的软中断
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">subsys_initcall&lt;/span>(net_dev_init);
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>|&lt;/p>
&lt;p>代码 3-2 软中断数据及网络软中断注册&lt;/p>
&lt;p>网络数据的收发的延时，多数场景下都会和系统软中断处理相关，这里我们将重点分析 ping 包抖动时的软中断情况。这里我们采用基于 &lt;a href="https://github.com/iovisor/bcc">BCC&lt;/a> 的 &lt;a href="https://gist.github.com/DavadDi/62ee75228f03631c845c51af292c2b17">&lt;strong>traceicmpsoftirq.py&lt;/strong>&lt;/a> 来协助定位 ping 包处理的内核情况。&lt;/p>
&lt;blockquote>
&lt;p>BCC 为 Linux 内核 BPF 技术的前端程序，主要提供 Python 语言的绑定，&lt;code>traceicmpsoftirq.py&lt;/code> 脚本依赖于 BCC 库，需要先安装 BCC 项目，各操作系统安装参见 &lt;a href="https://github.com/iovisor/bcc/blob/master/INSTALL.md">INSTALL.md&lt;/a>。
&lt;code>traceicmpsoftirq.py&lt;/code> 脚本在 Linux 3.10 内核与 Linux 4.x 内核上的读写方式有差异，需要根据内核略有调整。&lt;/p>
&lt;/blockquote>
&lt;p>使用 &lt;code>traceicmpsoftirq.py&lt;/code> 在主机 B 上运行，我们发现出现抖动延时的时内核运行的内核线程都为 &lt;code>ksoftirqd/0&lt;/code>。&lt;/p>
&lt;p>|&lt;/p>
&lt;pre>&lt;code> 1
2
3
4
5
6
7
8
9
10
11
&lt;/code>&lt;/pre>
&lt;p>|&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#主机 主机 A#A&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># ping -c 150 -i 0.01 172.23.14.144 |grep -E &amp;#34;[0-9]{2,}[\.0-9]+ ms&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># 主机 B&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># ./traceicmpsoftirq.py&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>tgid pid comm icmp_seq
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>...
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">0&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span> swapper/0 &lt;span style="color:#ae81ff">128&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">6&lt;/span> &lt;span style="color:#ae81ff">6&lt;/span> ksoftirqd/0 &lt;span style="color:#ae81ff">129&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">6&lt;/span> &lt;span style="color:#ae81ff">6&lt;/span> ksoftirqd/0 &lt;span style="color:#ae81ff">130&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>...
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>|&lt;/p>
&lt;p>代码 3-3 &lt;code>traceicmpsoftirq.py&lt;/code> ping 主机 B 容器 IP 抖动时的详情&lt;/p>
&lt;p>&lt;code>[ksoftirqd/0]&lt;/code> 这个给了我们两个重要的信息：&lt;/p>
&lt;ul>
&lt;li>从主机 A ping 主机 B 中容器 IP 的地址，每次处理包的处理都会固定落到 CPU#0 上；&lt;/li>
&lt;li>出现延时的时候该 CPU#0 都在运行软中断处理内核线程 &lt;code>ksoftirqd/0&lt;/code>，即在处理软中断的过程中调用的数据包处理，软中断另外一种处理时机如上所述 &lt;code>irq_exit&lt;/code> 硬中断退出时；&lt;/li>
&lt;/ul>
&lt;p>如果 ping 主机 B 中的容器 IP 地址落在 CPU#0 核上，那么按照我们的测试过程， ping 主机 B 的宿主机 IP 地址没有抖动，那么处理的 CPU 一定不在 #0 号上，才能符合测试场景，我们继续使用主机 B 主机 IP 地址进行测试：&lt;/p>
&lt;p>|&lt;/p>
&lt;pre>&lt;code> 1
2
3
4
5
6
7
8
9
10
11
&lt;/code>&lt;/pre>
&lt;p>|&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># 主机 A&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># ping -c 150 -i 0.01 172.23.14.144 |grep -E &amp;#34;[0-9]{2,}[\.0-9]+ ms&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># 主机 B&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># ./traceicmpsoftirq.py&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>tgid pid comm icmp_seq
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>...
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">0&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span> swapper/19 &lt;span style="color:#ae81ff">55&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">0&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span> swapper/19 &lt;span style="color:#ae81ff">56&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">0&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span> swapper/19 &lt;span style="color:#ae81ff">57&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>...
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>|&lt;/p>
&lt;p>代码 3-4 &lt;code>traceicmpsoftirq.py&lt;/code> ping 主机 B 主机 IP 详情&lt;/p>
&lt;p>通过实际的测试验证，ping 主机 B 宿主机 IP 地址时候，全部都落在了 CPU#19 上。问题排查至此处，我们可以断定是 CPU#0 与 CPU#19 在软中断处理的负载上存在差异，但是此处我们有带来另外一个疑问，为什么我们的 ping 包的处理总是固定落到同一个 CPU 核上呢？ 通过查询资料和主机配置确认，主机上默认启用了 RPS 的技术。RPS 全称是 Receive Packet Steering，这是 Google 工程师 Tom Herbert 提交的内核补丁, 在 2.6.35 进入 Linux 内核，采用软件模拟的方式，实现了多队列网卡所提供的功能，分散了在多 CPU 系统上数据接收时的负载，把软中断分到各个 CPU 处理，而不需要硬件支持，大大提高了网络性能。简单点讲，就是在软中断的处理函数 &lt;code>net_rx_action()&lt;/code> 中依据 RPS 的配置，使用接收到的数据包头部（比如源 IP 地址端口等信息）信息进行作为 key 进行 Hash 到对应的 CPU 核上去处理，算法具体参见 &lt;a href="https://elixir.bootlin.com/linux/v5.8/source/net/core/dev.c#L4305">get_rps_cpu&lt;/a> 函数。&lt;/p>
&lt;p>Linux 环境下的 RPS 配置，可以通过下面的命令检查：&lt;/p>
&lt;p>|&lt;/p>
&lt;pre>&lt;code>1
&lt;/code>&lt;/pre>
&lt;p>|&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># cat /sys/class/net/*/queues/rx-*/rps_cpus&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>|&lt;/p>
&lt;p>通过对上述情况的综合分析，我们把问题定位在 CPU#0 在内核线程中对于软中断处理的问题上。&lt;/p>
&lt;h3 id="32-cpu-软中断处理排查">3.2 CPU 软中断处理排查&lt;/h3>
&lt;p>问题排查到这里，我们将重点开始排查 CPU#0 上的 CPU 内核态的性能指标，看看是否有运行的函数导致了软中断处理的延期。&lt;/p>
&lt;p>首先我们使用 &lt;code>perf&lt;/code> 命令对于 CPU#0 进行内核态使用情况进行分析。&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/a705eb8d-74c1-4b40-bb71-60999d58cfc8/perf_kernel_cpu0.png" alt="">&lt;/p>
&lt;p>图 3-2 perf top CPU#0 内核性能数据&lt;/p>
&lt;p>通过 &lt;code>perf top&lt;/code> 命令我们注意到 CPU#0 的内核态中，&lt;code>estimation_timer&lt;/code> 这个函数的使用率一直占用比较高，同样我们通过对于 CPU#0 上的火焰图分析，也基本与 &lt;code>perf top&lt;/code> 的结果一致。&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/a705eb8d-74c1-4b40-bb71-60999d58cfc8/estimation_timer_flamgraph.png" alt="">&lt;/p>
&lt;p>图 3-3 &lt;code>estimation_timer&lt;/code> 在内核 CPU#0 上的火焰图&lt;/p>
&lt;p>为了弄清楚 &lt;code>estimation_timer&lt;/code> 的内核占用情况，我们继续使用 开源项目 &lt;a href="https://github.com/brendangregg/perf-tools">perf-tools&lt;/a>（作者为 Brendan Gregg）中的 &lt;a href="https://github.com/brendangregg/perf-tools/blob/master/bin/funcgraph">funcgraph&lt;/a> 工具分析函数 &lt;code>estimation_timer&lt;/code> 在内核中的调用关系图和占用延时。&lt;/p>
&lt;p>|&lt;/p>
&lt;pre>&lt;code>1
2
&lt;/code>&lt;/pre>
&lt;p>|&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># -m 1最大堆栈为 1 层，-a 显示全部信息 -d 6 跟踪 6秒&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#./funcgraph -m 1 -a -d 6 estimation_timer&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>|&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/a705eb8d-74c1-4b40-bb71-60999d58cfc8/estimation_timer_funcgraph.png" alt="">&lt;/p>
&lt;p>图 3-4 &lt;code>estimation_timer&lt;/code> 函数在内核函数调用&lt;/p>
&lt;p>同时我们注意到 &lt;code>estimation_timer&lt;/code> 函数在 CPU#0 内核中的遍历一次遍历时间为 119 ms，在内核处理软中断的情况中占用过长的时间，这一定会影响到其他软中断的处理。&lt;/p>
&lt;p>为了进一步确认 CPU#0 上的软中断处理情况，我们基于 BCC 项目中的 &lt;a href="https://github.com/iovisor/bcc/blob/master/tools/softirqs.py">softirqs.py&lt;/a> 脚本（本地略有修改），观察 CPU#0 上的软中断数量变化和整体耗时分布，发现 CPU#0 上的软中断数量增长并不是太快，但是 timer 的直方图却又异常点数据， 通过 timer 在持续 10s 内的 timer 数据分析，我们发现执行的时长分布在 [65 - 130] ms 区间的记录有 5 条。这个结论完全与通过 &lt;code>funcgraph&lt;/code> 工具抓取到的 &lt;code>estimation_timer&lt;/code> 在 CPU#0 上的延时一致。。&lt;/p>
&lt;p>|&lt;/p>
&lt;pre>&lt;code>1
2
&lt;/code>&lt;/pre>
&lt;p>|&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># -d 采用直方图 10 表示 10s 做一次聚合， 1 显示一次 -C 0 为我们自己修改的功能，用于过滤 CPU#0&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># /usr/share/bcc/tools/softirqs -d 10 1 -C 0&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>|&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/a705eb8d-74c1-4b40-bb71-60999d58cfc8/timer_softirq_hist.png" alt="">&lt;/p>
&lt;p>图 3-5 CPU#0 软中断之 timer 的执行时长直方图&lt;/p>
&lt;p>通过上述分析我们得知 &lt;code>estimation_timer&lt;/code> 来自于 ipvs 模块（参见图 3-4），kubernets 中 kube-proxy 组件负载均衡器正是基于 ipvs 模块，那么问题基本上出现在 kube-proxy 进程上。&lt;/p>
&lt;p>我们在主机 B 上仅保留测试的容器实例，在停止 kubelet 服务后，手工停止 kube-proxy 容器进程，经过重新测试，ping 延时抖动的问题果然消失了。&lt;/p>
&lt;p>到此问题的根源我们可以确定是 kube-proxy 中使用的 ipvs 内核模块中的 &lt;code>estimation_timer&lt;/code> 函数执行时间过长，导致网络软中断处理延迟，从而使 ping 包的出现抖动，那么 &lt;code>estimation_timer[ipvs]&lt;/code> 的作用是什么？ 什么情况下导致的该函数执行如此之长呢？&lt;/p>
&lt;h3 id="33-ipvs-estimation_timer-定时器">3.3 ipvs estimation_timer 定时器&lt;/h3>
&lt;p>谜底终将揭晓！&lt;/p>
&lt;p>我们通过阅读 ipvs 相关的源码，发现 &lt;code>estimation_timer()[ipvs]&lt;/code> 函数针对每个 Network Namespace 创建时候的通过 &lt;a href="https://elixir.bootlin.com/linux/v5.8/source/net/netfilter/ipvs/ip_vs_core.c#L2469">ip_vs_core.c&lt;/a> 中的 &lt;code>__ip_vs_init&lt;/code> 初始化的，&lt;/p>
&lt;p>|&lt;/p>
&lt;pre>&lt;code> 1
2
3
4
5
6
7
8
9
10
&lt;/code>&lt;/pre>
&lt;p>|&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-c" data-lang="c">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">/*
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> * Initialize IP Virtual Server netns mem.
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> */&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">static&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span> __net_init &lt;span style="color:#a6e22e">__ip_vs_init&lt;/span>(&lt;span style="color:#66d9ef">struct&lt;/span> net &lt;span style="color:#f92672">*&lt;/span>net)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">struct&lt;/span> netns_ipvs &lt;span style="color:#f92672">*&lt;/span>ipvs;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// ...
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">if&lt;/span> (&lt;span style="color:#a6e22e">ip_vs_estimator_net_init&lt;/span>(ipvs) &lt;span style="color:#f92672">&amp;lt;&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>) &lt;span style="color:#75715e">// 初始化
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">goto&lt;/span> estimator_fail;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>|&lt;/p>
&lt;p>代码 3-5 ipvs 初始化函数&lt;/p>
&lt;p>&lt;code>ip_vs_estimator_net_init&lt;/code> 函数在文件 &lt;a href="https://elixir.bootlin.com/linux/v5.8/source/net/netfilter/ipvs/ip_vs_est.c#L187">ip_vs_est.c&lt;/a> 中，定义如下：&lt;/p>
&lt;p>|&lt;/p>
&lt;pre>&lt;code>1
2
3
4
5
6
7
8
&lt;/code>&lt;/pre>
&lt;p>|&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-c" data-lang="c">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">int&lt;/span> __net_init &lt;span style="color:#a6e22e">ip_vs_estimator_net_init&lt;/span>(&lt;span style="color:#66d9ef">struct&lt;/span> netns_ipvs &lt;span style="color:#f92672">*&lt;/span>ipvs)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">INIT_LIST_HEAD&lt;/span>(&lt;span style="color:#f92672">&amp;amp;&lt;/span>ipvs&lt;span style="color:#f92672">-&amp;gt;&lt;/span>est_list);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">spin_lock_init&lt;/span>(&lt;span style="color:#f92672">&amp;amp;&lt;/span>ipvs&lt;span style="color:#f92672">-&amp;gt;&lt;/span>est_lock);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">timer_setup&lt;/span>(&lt;span style="color:#f92672">&amp;amp;&lt;/span>ipvs&lt;span style="color:#f92672">-&amp;gt;&lt;/span>est_timer, estimation_timer, &lt;span style="color:#ae81ff">0&lt;/span>); &lt;span style="color:#75715e">// 设置定时器函数 estimation_timer
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#a6e22e">mod_timer&lt;/span>(&lt;span style="color:#f92672">&amp;amp;&lt;/span>ipvs&lt;span style="color:#f92672">-&amp;gt;&lt;/span>est_timer, jiffies &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#ae81ff">2&lt;/span> &lt;span style="color:#f92672">*&lt;/span> HZ); &lt;span style="color:#75715e">// 启动第一次计时器，2秒启动
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>|&lt;/p>
&lt;p>代码 3-6 ipvs estimator 初始化函数&lt;/p>
&lt;p>&lt;code>estimation_timer&lt;/code> 也定义在 &lt;a href="https://elixir.bootlin.com/linux/v5.8/source/net/netfilter/ipvs/ip_vs_est.c#L96">ip_vs_est.c&lt;/a> 文件中。&lt;/p>
&lt;p>|&lt;/p>
&lt;pre>&lt;code> 1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
&lt;/code>&lt;/pre>
&lt;p>|&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-c" data-lang="c">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">static&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">estimation_timer&lt;/span>(&lt;span style="color:#66d9ef">struct&lt;/span> timer_list &lt;span style="color:#f92672">*&lt;/span>t)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// ...
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#a6e22e">spin_lock&lt;/span>(&lt;span style="color:#f92672">&amp;amp;&lt;/span>ipvs&lt;span style="color:#f92672">-&amp;gt;&lt;/span>est_lock);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">list_for_each_entry&lt;/span>(e, &lt;span style="color:#f92672">&amp;amp;&lt;/span>ipvs&lt;span style="color:#f92672">-&amp;gt;&lt;/span>est_list, list) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> s &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#a6e22e">container_of&lt;/span>(e, &lt;span style="color:#66d9ef">struct&lt;/span> ip_vs_stats, est);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">spin_lock&lt;/span>(&lt;span style="color:#f92672">&amp;amp;&lt;/span>s&lt;span style="color:#f92672">-&amp;gt;&lt;/span>lock);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">ip_vs_read_cpu_stats&lt;/span>(&lt;span style="color:#f92672">&amp;amp;&lt;/span>s&lt;span style="color:#f92672">-&amp;gt;&lt;/span>kstats, s&lt;span style="color:#f92672">-&amp;gt;&lt;/span>cpustats);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">/* scaled by 2^10, but divided 2 seconds */&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> rate &lt;span style="color:#f92672">=&lt;/span> (s&lt;span style="color:#f92672">-&amp;gt;&lt;/span>kstats.conns &lt;span style="color:#f92672">-&lt;/span> e&lt;span style="color:#f92672">-&amp;gt;&lt;/span>last_conns) &lt;span style="color:#f92672">&amp;lt;&amp;lt;&lt;/span> &lt;span style="color:#ae81ff">9&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> e&lt;span style="color:#f92672">-&amp;gt;&lt;/span>last_conns &lt;span style="color:#f92672">=&lt;/span> s&lt;span style="color:#f92672">-&amp;gt;&lt;/span>kstats.conns;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> e&lt;span style="color:#f92672">-&amp;gt;&lt;/span>cps &lt;span style="color:#f92672">+=&lt;/span> ((s64)rate &lt;span style="color:#f92672">-&lt;/span> (s64)e&lt;span style="color:#f92672">-&amp;gt;&lt;/span>cps) &lt;span style="color:#f92672">&amp;gt;&amp;gt;&lt;/span> &lt;span style="color:#ae81ff">2&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// ...
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">spin_unlock&lt;/span>(&lt;span style="color:#f92672">&amp;amp;&lt;/span>ipvs&lt;span style="color:#f92672">-&amp;gt;&lt;/span>est_lock);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">mod_timer&lt;/span>(&lt;span style="color:#f92672">&amp;amp;&lt;/span>ipvs&lt;span style="color:#f92672">-&amp;gt;&lt;/span>est_timer, jiffies &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#ae81ff">2&lt;/span>&lt;span style="color:#f92672">*&lt;/span>HZ); &lt;span style="color:#75715e">// 2 秒后启动新的一轮统计
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>|&lt;/p>
&lt;p>代码 3-7 ipvs estimation_timer 函数&lt;/p>
&lt;p>从 &lt;code>estimation_timer&lt;/code> 的函数实现来看，会首先调用 spin_lock 进行锁的操作，然后遍历当前 Network Namespace 下的全部 ipvs 规则。由于我们集群的某些历史原因导致生产集群中的 Service 比较多，因此导致一次遍历的时候会占用比较长的时间。&lt;/p>
&lt;p>该函数的统计最终体现在 &lt;code>ipvsadm --stat&lt;/code> 的结果中（Conns InPkts OutPkts InBytes OutBytes）：&lt;/p>
&lt;p>|&lt;/p>
&lt;pre>&lt;code>1
2
3
4
5
6
&lt;/code>&lt;/pre>
&lt;p>|&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># ipvsadm -Ln --stats&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>IP Virtual Server version 1.2.1 &lt;span style="color:#f92672">(&lt;/span>size&lt;span style="color:#f92672">=&lt;/span>4096&lt;span style="color:#f92672">)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Prot LocalAddress:Port Conns InPkts OutPkts InBytes OutBytes &lt;span style="color:#75715e"># 相关统计&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> -&amp;gt; RemoteAddress:Port
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>TCP 10.85.0.10:9153 &lt;span style="color:#ae81ff">0&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> -&amp;gt; 172.22.34.187:9153 &lt;span style="color:#ae81ff">0&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>|&lt;/p>
&lt;p>对于我们集群中的 &lt;code>ipvs&lt;/code> 规则进行统计，我们发现大概在 30000 左右。&lt;/p>
&lt;p>|&lt;/p>
&lt;pre>&lt;code>1
&lt;/code>&lt;/pre>
&lt;p>|&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># ipvsadm -Ln --stats|wc -l&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>|&lt;/p>
&lt;p>既然每个 Network Namespace 下都会有 &lt;code>estimation_timer&lt;/code> 的遍历，为什么只有 CPU#0 上的规则如此多呢？&lt;/p>
&lt;p>这是因为只有主机的 Host Network Namespace 中才会有全部的 ipvs 规则，这个我们也可以通过 &lt;code>ipvsadm -Ln&lt;/code> (执行在 Host Network Namespace 下) 验证。从现象来看，CPU#0 是 ipvs 模块加载的时候用于处理宿主机 Host Network Namespace 中的 ipvs 规则，当然这个核的加载完全是随机的。&lt;/p>
&lt;h2 id="4-问题解决">4. 问题解决&lt;/h2>
&lt;h3 id="41-解决方案">4.1 解决方案&lt;/h3>
&lt;p>到此，问题已经彻底定位，由于我们服务早期部署的历史原因，短期内调整 Service 的数目会导致大量的迁移工作，中间还有云厂商 SLB 产生的大量规则，也没有办法彻底根除，单从技术上解决的话，我们可以采用的方式有以下 3 种：&lt;/p>
&lt;ol>
&lt;li>动态感知到宿主机 Network Namespace 中 ipvs &lt;code>estimation_timer&lt;/code> 函数的函数，在 RPS 中设置关闭该 CPU 映射；
该方式需要调整 RPS 的配置，而且 ipvs 处理主机 Network Namespace 的核数不固定，需要识别并调整配置，还需要处理重启时候的 ipvs 主机 Network Namespace 的变动；&lt;/li>
&lt;li>由于我们不需要 ipvs 这种统计的功能，可以通过修改 ipvs 驱动的方式来规避该问题；
修改 ipvs 的驱动模块，需要重新加载该内核模块，也会导致主机服务上的短暂中断；&lt;/li>
&lt;li>ipvs 模块将内核遍历统计调整成一个独立的内核线程进行统计；&lt;/li>
&lt;/ol>
&lt;p>ipvs 规则在内核 timer 中遍历是 ipvs 移植到 k8s 上场景未适配的问题，社区应该需要把在 timer 中的遍历独立出去，但是这个方案需要社区的推动解决，远水解不了近渴。&lt;/p>
&lt;p>通过上述 3 种方案的对比，解决我们当前抖动的问题都不太容易实施，为了保证生产环境的稳定和实施的难易程度，最终我们把眼光定位在 Linux Kernel 热修的 &lt;a href="https://github.com/dynup/kpatch">kpatch&lt;/a> 方案上， kpath 实现的 livepatch 功能可以实时为正在运行的内核提供功能增强，无需重新启动系统。&lt;/p>
&lt;h3 id="42-kpatch-livepatch">4.2 kpatch livepatch&lt;/h3>
&lt;p>Kpatch 是给 Linux 内核 livepatch 的工具，由 Redhat 公司出品。最早出现的打热补丁工具是 Ksplice。但是 Ksplice 被 Oracle 收购后，一些发行版生产商就不得不开发自己的热补丁工具，分别是 Redhat 的 Kpatch 和 Suse 的 KGraft。同时，在这两家厂商的推进下，kernel 4.0 开始，开始集成了 livepatch 技术。 Kpatch 虽然是 Redhat 研发，但其也支持 Ubuntu、Debian、Oracle Linux 等的发行版。&lt;/p>
&lt;p>这里我们简单同步一下实施的步骤，更多的文档可以从 kpath 项目中获取。&lt;/p>
&lt;h4 id="421-获取-kpath-编译和安装">4.2.1 获取 kpath 编译和安装&lt;/h4>
&lt;p>|&lt;/p>
&lt;pre>&lt;code> 1
2
3
4
5
6
7
8
9
10
11
&lt;/code>&lt;/pre>
&lt;p>|&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>$ git clone https://github.com/dynup/kpatch.git
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>$ source test/integration/lib.sh
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># 中间会使用 yum 安装相关的依赖包，安装时间视网络情况而定，在阿里云的环境下需要的时间比较长&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>$ sudo kpatch_dependencies
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>$ cd kpatch
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># 进行编译&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>$ make
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># 默认安装到 /usr/local，需要注意 kpatch-build 在目录 /usr/local/bin/ 下，而 kpatch 在 /usr/local/sbin/ 目录&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>$ sudo make install
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>|&lt;/p>
&lt;h4 id="422-生成内核源码-patch">4.2.2 生成内核源码 patch&lt;/h4>
&lt;p>在 kpatch 的使用过程中，需要使用到内核的源码，源码拉取的方式可以参考这里&lt;a href="https://wiki.centos.org/zh/HowTos/I_need_the_Kernel_Source?highlight=(kernel)%7C(src)">我需要内核的源代码&lt;/a>。&lt;/p>
&lt;p>|&lt;/p>
&lt;pre>&lt;code>1
2
3
4
&lt;/code>&lt;/pre>
&lt;p>|&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>$ rpm2cpio kernel-3.10.0-1062.9.1.el7.src.rpm |cpio -div
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>$ xz -d linux-3.10.0-1062.9.1.el7.tar.xz
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>$ tar -xvf linux-3.10.0-1062.9.1.el7.tar
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>$ cp -ra linux-3.10.0-1062.9.1.el7/ linux-3.10.0-1062.9.1.el7-patch
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>|&lt;/p>
&lt;p>此处我们将 &lt;code>estimation_timer&lt;/code> 函数的实现设置为空&lt;/p>
&lt;p>|&lt;/p>
&lt;pre>&lt;code>1
2
3
4
5
&lt;/code>&lt;/pre>
&lt;p>|&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-c" data-lang="c">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">static&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">estimation_timer&lt;/span>(&lt;span style="color:#66d9ef">unsigned&lt;/span> &lt;span style="color:#66d9ef">long&lt;/span> arg)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">printk&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;hotfix estimation_timer patched&lt;/span>&lt;span style="color:#ae81ff">\n&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>|&lt;/p>
&lt;p>并生成对应的 patch 文件&lt;/p>
&lt;p>|&lt;/p>
&lt;pre>&lt;code>1
&lt;/code>&lt;/pre>
&lt;p>|&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># diff -u linux-3.10.0-1062.9.1.el7/net/netfilter/ipvs/ip_vs_est.c linux-3.10.0-1062.9.1.el7-patch/net/netfilter/ipvs/ip_vs_est.c &amp;gt; ip_vs_timer_v1.patch&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>|&lt;/p>
&lt;h4 id="423-生产内核补丁并-livepatch">4.2.3 生产内核补丁并 livepatch&lt;/h4>
&lt;p>然后生成相关的 patch ko 文件并应用到内核：&lt;/p>
&lt;p>|&lt;/p>
&lt;pre>&lt;code>1
2
3
4
5
6
&lt;/code>&lt;/pre>
&lt;p>|&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># /usr/local/bin/kpatch-build ip_vs_timer_v1.patch --skip-gcc-check --skip-cleanup -r /root/kernel-3.10.0-1062.9.1.el7.src.rpm&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># 编译成功后会在当前目录生成 livepatch-ip_vs_timer_v1.ko 文件&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># 应用到内核中.&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># /usr/local/sbin/kpatch load livepatch-ip_vs_timer_v1.ko&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>|&lt;/p>
&lt;p>通过内核日志查看确认&lt;/p>
&lt;p>|&lt;/p>
&lt;pre>&lt;code>1
2
3
4
&lt;/code>&lt;/pre>
&lt;p>|&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>$ dmesg -T
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">[&lt;/span>Thu Dec &lt;span style="color:#ae81ff">3&lt;/span> 19:50:50 2020&lt;span style="color:#f92672">]&lt;/span> livepatch: enabling patch &lt;span style="color:#e6db74">&amp;#39;livepatch_ip_vs_timer_v1&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">[&lt;/span>Thu Dec &lt;span style="color:#ae81ff">3&lt;/span> 19:50:50 2020&lt;span style="color:#f92672">]&lt;/span> livepatch: &lt;span style="color:#e6db74">&amp;#39;livepatch_ip_vs_timer_v1&amp;#39;&lt;/span>: starting patching transition
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">[&lt;/span>Thu Dec &lt;span style="color:#ae81ff">3&lt;/span> 19:50:50 2020&lt;span style="color:#f92672">]&lt;/span> hotfix estimation_timer patched
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>|&lt;/p>
&lt;p>至此通过我们的 livepatch 成功修订了 &lt;code>estimation_timer&lt;/code> 的调用，一切看起来很成功。然后通过 &lt;code>funcgraph&lt;/code> 工具查看 &lt;code>estimation_timer&lt;/code> 函数不再出现在调用关系中。&lt;/p>
&lt;blockquote>
&lt;p>如果仅仅把函数设置为空的实现，等于是关闭了 &lt;code>estimation_timer&lt;/code> 的调用，即使通过命令 unload 掉 livepatch，该函数的也不会恢复，因此在生产环境中建议将函数的 2s 调用设置成个可以接受的时间范围内，比如 5 分钟，这样在 unload 以后，可以在 5 分钟以后恢复 &lt;code>estimation_timer&lt;/code> 的继续调用。&lt;/p>
&lt;/blockquote>
&lt;h3 id="43-使用-kpatch-注意事项">4.3 使用 kpatch 注意事项&lt;/h3>
&lt;ul>
&lt;li>kpatch 是基于内核版本生成的 ko 内核模块，必须保证后续 livepatch 的内核版本与编译机器的内核完全一致。&lt;/li>
&lt;li>通过手工 livepatch 的方式修复，如果保证机器在重启以后仍然生效需要通过 &lt;code>install&lt;/code> 来启用 kpathc 服务进行保证。&lt;/li>
&lt;/ul>
&lt;p>|&lt;/p>
&lt;pre>&lt;code>1
2
&lt;/code>&lt;/pre>
&lt;p>|&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># /usr/local/sbin/kpatch install livepatch-ip_vs_timer_v1.ko&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># systemctl start kpatch&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>|&lt;/p>
&lt;ul>
&lt;li>在其他的机器上进行 livepatch 需要文件&lt;code>kpatch&lt;/code>、&lt;code>livepatch-ip_vs_timer_v1.ko&lt;/code> 和 &lt;code>kpatch.service&lt;/code>（用于 install 后重启生效） 3 个文件即可。&lt;/li>
&lt;/ul>
&lt;h2 id="5-总结">5. 总结&lt;/h2>
&lt;p>网络抖动问题的排查，涉及应用层、网络协议栈和内核中运作机制等多方面的协调，排查过程中需要逐层排查、逐步缩小范围，在整个过程中，合适的工具至关重要，在我们本次问题的排查过程中， BPF 技术为我们排查的方向起到了至关重要的作用。BPF 技术的出现为我们观测和跟踪内核中的事件，提供了更加灵活的数据采集和数据分析的能力，在生产环境中我们已经将其广泛用于了监控网络底层的重传和抖动等维度，极大提升提升我们在偶发场景下的问题排查效率，希望更多的人能够从 BPF 技术中受益。
&lt;a href="https://www.ebpf.top/post/ebpf_network_kpath_ipvs/">https://www.ebpf.top/post/ebpf_network_kpath_ipvs/&lt;/a>&lt;/p></description></item><item><title>Docs: /boot目录被清空下物理机无法开机的一次救援 · zhangguanzhang's Blog</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/x.linux-%E7%AE%A1%E7%90%86/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96-%E4%B8%8E-%E6%95%85%E9%9A%9C%E5%A4%84%E7%90%86/%E6%95%85%E9%9A%9C%E5%A4%84%E7%90%86%E6%A1%88%E4%BE%8B/boot%E7%9B%AE%E5%BD%95%E8%A2%AB%E6%B8%85%E7%A9%BA%E4%B8%8B%E7%89%A9%E7%90%86%E6%9C%BA%E6%97%A0%E6%B3%95%E5%BC%80%E6%9C%BA%E7%9A%84%E4%B8%80%E6%AC%A1%E6%95%91%E6%8F%B4-zhangguanzhangs-blog/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/x.linux-%E7%AE%A1%E7%90%86/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96-%E4%B8%8E-%E6%95%85%E9%9A%9C%E5%A4%84%E7%90%86/%E6%95%85%E9%9A%9C%E5%A4%84%E7%90%86%E6%A1%88%E4%BE%8B/boot%E7%9B%AE%E5%BD%95%E8%A2%AB%E6%B8%85%E7%A9%BA%E4%B8%8B%E7%89%A9%E7%90%86%E6%9C%BA%E6%97%A0%E6%B3%95%E5%BC%80%E6%9C%BA%E7%9A%84%E4%B8%80%E6%AC%A1%E6%95%91%E6%8F%B4-zhangguanzhangs-blog/</guid><description>
&lt;p>今天下午到公司被通知苏州一个节点的客户的裸金属无法开机，14:00 上去到 16:50 终于给整好了，这里记录下笔记分享下&lt;/p>
&lt;h2 id="故障现象">故障现象&lt;/h2>
&lt;p>物理机裸金属，连上跳板机通过带外连上去 (等同于现场接了一个显示屏 + 键盘一样) 错误为&lt;/p>
&lt;pre>&lt;code>errorL file `/grub2/i386-pc/normal.mod' not found.
Entering rescue mode...
grub rescue&amp;gt;
&lt;/code>&lt;/pre>
&lt;p>这个物理机是 grub2，这个错误和类似的&lt;code>/grub/i386-pc/normal.mod&lt;/code>本质上都是文件丢失，但是也分情况，网上的一些恢复步骤都是在丢失部分文件的情况下恢复的
查看分区&lt;/p>
&lt;pre>&lt;code>grub rescue&amp;gt;ls
(hd0) (hd0,msdos2) (hd0,msdos1)
grub rescue&amp;gt;ls (hd0,msdos1)/
./ ../
grub rescue&amp;gt;ls (hd0,msdos2)/
error: unknown filesystem
&lt;/code>&lt;/pre>
&lt;p>这里是等同于你实际的分区，我们这基本是一个 / boot 和一个根，看到&lt;code>(hd0,msdos1)&lt;/code>是 / boot 分区，文件是完全丢失的，&lt;code>(hd0,msdos2)/&lt;/code>报错未知文件系统是因为这个是 lvm，正常乐观下来讲只是丢失部分文件的话，可以参考下面步骤去恢复&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://www.youtube.com/watch?v=RqRm1bEXO9M">https://www.youtube.com/watch?v=RqRm1bEXO9M&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://blog.csdn.net/qq_20545159/article/details/50810089">https://blog.csdn.net/qq_20545159/article/details/50810089&lt;/a>&lt;/li>
&lt;/ul>
&lt;h2 id="救援">救援&lt;/h2>
&lt;h3 id="livecd-进入-rescue-救援">livecd 进入 rescue 救援&lt;/h3>
&lt;p>这里我是完全丢失，我利用带外远程挂载了一个 centos7.6 的 iso(最好和目标系统版本一样)，重启物理机进入 cdrom，选择&lt;code>Troubleshooting&lt;/code> –&amp;gt; &lt;code>Rescue a CentOS Linux system&lt;/code>&lt;/p>
&lt;p>下面我引用下别人的图，如果图被拦截了请看文字吧
&lt;a href="https://notes-learning.oss-cn-beijing.aliyuncs.com/dd979e87-2201-4df4-890e-d122c4681296/troubleshooting-option-boot-RHEL-CentOS-7-into-rescue-mode.png">
&lt;/a>
&lt;a href="https://notes-learning.oss-cn-beijing.aliyuncs.com/dd979e87-2201-4df4-890e-d122c4681296/rescue-CentOS-RHEL-7-system.png">
&lt;/a>
&lt;a href="https://notes-learning.oss-cn-beijing.aliyuncs.com/dd979e87-2201-4df4-890e-d122c4681296/find-linux-installation-for-rescue-mode-RHEL-7-reinstall-GRUB2.png">
&lt;/a>
选择 1 后然后回车会得到一个交互式 shell，查看下分区信息&lt;/p>
&lt;pre>&lt;code>sh-4.2# lsblk
NAME MAJ:MIN RM SIZE RO TYPE MOUNTPOINT
sda 8:0 1 558G 0 disk
├─sda1 8:1 1 1G 0 part /mnt/sysimage/boot
└─sda2 8:2 1 557G 0 part
├─centos-root 253:0 0 550G 0 lvm /mnt/sysimage
└─centos-swap 253:1 0 4G 0 lvm [SWAP]
sr0 11:0 1 4.3G 0 rom /run/install/repo
sr1 11:1 1 107.2M 0 rom
loop0 7:1 0 432.4M 1 loop
loop1 7:1 0 2G 1 loop
├─live-rw 253:0 0 2G 0 dm /
└─live-base 253:1 0 2G 1 dm
loop2 7:2 0 512M 1 loop
└─live-rw 253:0 0 2G 0 dm /
&lt;/code>&lt;/pre>
&lt;p>根被挂载到&lt;code>/mnt/sysimage&lt;/code>,boot 被挂载到&lt;code>/mnt/sysimage/boot&lt;/code>，iso 被挂载到&lt;code>/run/install/repo&lt;/code>
最开始我是 chroot /mnt/sysimage 后 grub2-install /dev/sda，然后重启后进入&lt;/p>
&lt;pre>&lt;code> Minimal BASH_like line editing is supported. For the first word,
...
..
grub&amp;gt;
&lt;/code>&lt;/pre>
&lt;p>出现这个一般是缺少&lt;code>grub.cfg&lt;/code>，然后再进去光盘的 rescue 里去 chroot 进去&lt;code>grub2-mkconfig -o /boot/grub2/grub.cfg&lt;/code>还是不行。因为实际上 / boot 都被清空了，grub2-install 和 mkconfig 只是生成了&lt;code>/boot/grub2&lt;/code>下面一些文件，因为开机需要的 vmlinuz 和 kernel 都没有.&lt;/p>
&lt;h3 id="复制同样机器同样系统的--boot">复制同样机器同样系统的 / boot&lt;/h3>
&lt;p>正确姿势来整的话，考虑到 / boot 下面的相关文件被清理了，叫同事找同样物理机和系统的裸金属上去看看&lt;code>/boot/&lt;/code>目录，然后叫他把 / boot 打包成 iso，我在带外挂载上去。
         中间他直接复制到 windows 的，权限信息丢失了。我叫他直接 Linux 上 tar 打包了后再在 win 上打包 iso。
可以先在 rescue 模式里看&lt;code>/mnt/sysimage/etc/redhat-release&lt;/code>查看系统信息，然后正常物理机的同样系统上的 / boot 信息为&lt;/p>
&lt;pre>&lt;code>$ ll
total 110920
-rw-r--r--. 1 root root 151918 Nov 9 2018 config-3.10.0-957.el7.x86_64
drwxr-xr-x. 3 root root 17 Feb 26 2019 efi
drwxr-xr-x. 2 root root 27 Feb 26 2019 grub
drwx------. 5 root root 97 Feb 26 2019 grub2
-rw-------. 1 root root 59891363 Feb 26 2019 initramfs-0-rescue-cd270b115cc741328f7812c0be97041d.img
-rw-------. 1 root root 22834950 Feb 26 2019 initramfs-3.10.0-957.el7.x86_64.img
-rw-------. 1 root root 13548147 Oct 11 16:32 initramfs-3.10.0-957.el7.x86_64kdump.img
-rw-r--r--. 1 root root 314036 Nov 9 2018 symvers-3.10.0-957.el7.x86_64.gz
-rw-------. 1 root root 3543471 Nov 9 2018 System.map-3.10.0-957.el7.x86_64
-rwxr-xr-x. 1 root root 6639904 Feb 26 2019 vmlinuz-0-rescue-cd270b115cc741328f7812c0be97041d
-rwxr-xr-x. 1 root root 6639904 Nov 9 2018 vmlinuz-3.10.0-957.el7.x86_64
&lt;/code>&lt;/pre>
&lt;p>现在步骤开始是实际有效的步骤，前提是挂载了 centos 的 iso 和 boot 文件的 iso
下面我第一个光驱是 iso，第二个是 boot，所以是&lt;code>/dev/sr1&lt;/code>&lt;/p>
&lt;pre>&lt;code>sh-4.2# chroot /mnt/sysimage
bash-4.2# alias ll='ls -l'
bash-4.2# mkdir -p /media/tmp
bash-4.2# mount /dev/sr1 /media/tmp/
mount: /dev/sr1 is write-protected, mounting read-only
bash-4.2# cd /media
bash-4.2# tar zxf /media/tmp/boot.tar.gz
bash-4.2# cp -a boot/* /boot/
&lt;/code>&lt;/pre>
&lt;p>这里有一个点不确定，但是为了保险起见我是操作了，有条件的人可以自己去测下看看下面步骤不执行有影响不, 删除 uuid 文件 (我对比了下实际上 MD5 是一样的，有条件可以测下下面这几个步骤不执行看看正常不)&lt;/p>
&lt;pre>&lt;code>bash-4.2# cd /boot
bash-4.2# ll /media/boot/*cd270b11*
-rw-------. 1 root root 59891363 Feb 26 2019 /media/boot/initramfs-0-rescue-cd270b115cc741328f7812c0be97041d.img
-rwxr-xr-x. 1 root root 6639904 Feb 26 2019 /media/boot/vmlinuz-0-rescue-cd270b115cc741328f7812c0be97041d
bash-4.2# rm -f *cd270b11*
bash-4.2# /etc/kernel/postinst.d/51-dracut-rescue-postinst.sh $(uname -r) /boot/vmlinuz-$(uname -r)
&lt;/code>&lt;/pre>
&lt;p>grub 配置文件里有硬盘分区的 uuid，这里需要重新生成&lt;code>grub.cfg&lt;/code>&lt;/p>
&lt;pre>&lt;code>bash-4.2# mv /boot/grub2/grub.cfg{,.bak}
bash-4.2# grub2-mkconfig -o /boot/grub2/grub.cfg
&lt;/code>&lt;/pre>
&lt;p>如果报错&lt;code>grub-probe: error: cannot find a device for / (is /dev mounted?)&lt;/code>
则在 chroot 之前用 bind mount 相关目录&lt;/p>
&lt;pre>&lt;code>mount -o bind /dev /mnt/sysimage/dev
mount -o bind /proc /mnt/sysimage/proc
mount -o bind /run /mnt/sysimage/run
mount -o bind /sys /mnt/sysimage/sys
&lt;/code>&lt;/pre>
&lt;h3 id="重启">重启&lt;/h3>
&lt;p>重启测试&lt;/p>
&lt;pre>&lt;code>bash-4.2# exit
sh-4.2# init 6
&lt;/code>&lt;/pre>
&lt;p>结果是进入了&lt;code>emergency mode&lt;/code>
&lt;a href="https://notes-learning.oss-cn-beijing.aliyuncs.com/dd979e87-2201-4df4-890e-d122c4681296/emergencyMode.png">
&lt;/a>
这个模式进来了大多数原因是有个非系统的分区无法挂载，输入 root 密码进去后，先查看下&lt;code>systemctl failed&lt;/code>发现&lt;code>/home&lt;/code>无法被挂载&lt;/p>
&lt;pre>&lt;code>[root@cn19 ~]# systemctl --failed
UNIT LOAD ACTIVE SUB DESCRIPTION
● home.mount loaded failed failed /home
● auditd.service loaded failed failed Security Auditing Service
LOAD = Reflects whether the unit definition was properly loaded.
ACTIVE = The high-level unit activation state, i.e. generalization of SUB.
SUB = The low-level unit activation state, values depend on unit type.
2 loaded units listed. Pass --all to see loaded but inactive units, too.
To show all installed unit files use 'systemctl list-unit-files'.
[root@cn19 ~]# grep -Pv '^#|^$' /etc/fstab
/dev/mapper/centos-root / xfs defaults 0 0
UUID=71b43bbc-819c-4420-9ba8-9c85110999dd /boot xfs defaults 0 0
/dev/mapper/centos-swap swap swap defaults 0 0
[root@cn19 ~]# lvs
LV VG Attr LSize Pool Origin Data% Meta% Move Log Cpy%Sync Convert
home centos -wi-a----- 2.00g
root centos -wi-ao---- 550.00g
swap centos -wi-ao---- 4.00g
&lt;/code>&lt;/pre>
&lt;p>尝试修复无果&lt;/p>
&lt;pre>&lt;code>[root@cn19 ~]# xfs_repair /dev/mapper/centos-home
Phase 1 - find and verify superblock...
bad primary superblock - bad magic number !!!
attempting to find secondary superblock...
......................Sorry, could not find valid secondary superblock
Exiting now.
&lt;/code>&lt;/pre>
&lt;p>询问了用户&lt;code>/home&lt;/code>目录不重要，直接取消 fstab 取消 / home 的挂载然后 reboot 恢复正常
&lt;a href="https://notes-learning.oss-cn-beijing.aliyuncs.com/dd979e87-2201-4df4-890e-d122c4681296/right.png">
&lt;/a>&lt;/p>
&lt;h2 id="参考">参考：&lt;/h2>
&lt;p>&lt;a href="https://www.tecmint.com/recover-or-rescue-corrupted-grub-boot-loader-in-centos-7/">https://www.tecmint.com/recover-or-rescue-corrupted-grub-boot-loader-in-centos-7/&lt;/a>
rescue mode 安装 kernel: &lt;a href="https://www.thegeekdiary.com/centos-rhel-7-how-to-install-kernel-from-rescue-mode/">https://www.thegeekdiary.com/centos-rhel-7-how-to-install-kernel-from-rescue-mode/&lt;/a>
rescue mode 生成 vmlinuz 和 initramfs: &lt;a href="https://www.thegeekdiary.com/how-to-re-generate-initramfs-and-vmlinuz-for-rescue-kernel-with-current-kernel-in-centos-rhel-7/">https://www.thegeekdiary.com/how-to-re-generate-initramfs-and-vmlinuz-for-rescue-kernel-with-current-kernel-in-centos-rhel-7/&lt;/a>
&lt;a href="https://zhangguanzhang.github.io/2019/10/12/boot-grub-rescue/">https://zhangguanzhang.github.io/2019/10/12/boot-grub-rescue/&lt;/a>&lt;/p></description></item><item><title>Docs: /etc/kubernetes 目录误删恢复</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/10.%E4%BA%91%E5%8E%9F%E7%94%9F/2.3.kubernetes-%E5%AE%B9%E5%99%A8%E7%BC%96%E6%8E%92%E7%B3%BB%E7%BB%9F/kubernetes-%E7%AE%A1%E7%90%86/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96-%E4%B8%8E-%E6%95%85%E9%9A%9C%E5%A4%84%E7%90%86/%E6%95%85%E9%9A%9C%E5%A4%84%E7%90%86%E6%8A%80%E5%B7%A7/etc_kubernetes-%E7%9B%AE%E5%BD%95%E8%AF%AF%E5%88%A0%E6%81%A2%E5%A4%8D/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/10.%E4%BA%91%E5%8E%9F%E7%94%9F/2.3.kubernetes-%E5%AE%B9%E5%99%A8%E7%BC%96%E6%8E%92%E7%B3%BB%E7%BB%9F/kubernetes-%E7%AE%A1%E7%90%86/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96-%E4%B8%8E-%E6%95%85%E9%9A%9C%E5%A4%84%E7%90%86/%E6%95%85%E9%9A%9C%E5%A4%84%E7%90%86%E6%8A%80%E5%B7%A7/etc_kubernetes-%E7%9B%AE%E5%BD%95%E8%AF%AF%E5%88%A0%E6%81%A2%E5%A4%8D/</guid><description>
&lt;h1 id="故障现象">故障现象&lt;/h1>
&lt;p>参考：&lt;a href="https://mp.weixin.qq.com/s/O3fJF5aZuxPOKa7lIjrHnQ">阳明公众号原文&lt;/a>&lt;/p>
&lt;p>Kubernetes 是一个很牛很牛的平台，Kubernetes 的架构可以让你轻松应对各种故障，今天我们将来破坏我们的集群、删除证书，然后再想办法恢复我们的集群，进行这些危险的操作而不会对已经运行的服务造成宕机。&lt;/p>
&lt;blockquote>
&lt;p>如果你真的想要执行接下来的操作，还是建议别在生产环境去折腾，虽然理论上不会造成服务宕机，但是如果出现了问题，&lt;strong>可千万别骂我~~~&lt;/strong>&lt;/p>
&lt;/blockquote>
&lt;p>我们知道 Kubernetes 的控制平面是由几个组件组成的：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>etcd：作为整个集群的数据库使用&lt;/p>
&lt;/li>
&lt;li>
&lt;p>kube-apiserver：集群的 API 服务&lt;/p>
&lt;/li>
&lt;li>
&lt;p>kube-controller-manager：整个集群资源的控制操作&lt;/p>
&lt;/li>
&lt;li>
&lt;p>kube-scheduler：核心调度器&lt;/p>
&lt;/li>
&lt;li>
&lt;p>kubelet：是运行在节点上用来真正管理容器的组件&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>这些组件都由一套针对客户端和服务端的 TLS 证书保护，用于组件之间的认证和授权，大部分情况下它们并不是直接存储在 Kubernetes 的数据库中的，而是以普通文件的形式存在。&lt;/p>
&lt;pre>&lt;code># tree /etc/kubernetes/pki/
/etc/kubernetes/pki/
├── apiserver.crt
├── apiserver-etcd-client.crt
├── apiserver-etcd-client.key
├── apiserver.key
├── apiserver-kubelet-client.crt
├── apiserver-kubelet-client.key
├── ca.crt
├── ca.key
├── CTNCA.pem
├── etcd
│ ├── ca.crt
│ ├── ca.key
│ ├── healthcheck-client.crt
│ ├── healthcheck-client.key
│ ├── peer.crt
│ ├── peer.key
│ ├── server.crt
│ └── server.key
├── front-proxy-ca.crt
├── front-proxy-ca.key
├── front-proxy-client.crt
├── front-proxy-client.key
├── sa.key
└── sa.pub
&lt;/code>&lt;/pre>
&lt;p>控制面板的组件以静态 Pod (我这里用 kubeadm 搭建的集群)的形式运行在 master 节点上，默认资源清单位于 &lt;code>/etc/kubernetes/manifests&lt;/code> 目录下。通常来说这些组件之间会进行互相通信，基本流程如下所示：&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/ghm4g3/1616115588241-7c7f556a-1526-43e4-847a-d78a70821f6b.png" alt="">&lt;/p>
&lt;p>组件之间为了通信，他们需要使用到 TLS 证书。假设我们已经有了一个部署好的集群，接下来让我们开始我们的破坏行为。&lt;/p>
&lt;pre>&lt;code>rm -rf /etc/kubernetes/
&lt;/code>&lt;/pre>
&lt;p>在 master 节点上，这个目录包含：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>etcd 的一组证书和 CA（在 &lt;code>/etc/kubernetes/pki/etcd&lt;/code> 目录下）&lt;/p>
&lt;/li>
&lt;li>
&lt;p>一组 kubernetes 的证书和 CA（在 &lt;code>/etc/kubernetes/pki&lt;/code> 目录下）&lt;/p>
&lt;/li>
&lt;li>
&lt;p>还有 kube-controller-manager、kube-scheduler、cluster-admin 以及 kubelet 这些使用的 kubeconfig 文件&lt;/p>
&lt;/li>
&lt;li>
&lt;p>etcd、kube-apiserver、kube-scheduler 和 kube-controller-manager 的静态 Pod 资源清单文件（位于 &lt;code>/etc/kubernetes/manifests&lt;/code> 目录）&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>现在我们就上面这些全都删除了，如果是在生产环境做了这样的操作，可能你现在正瑟瑟发抖吧~&lt;/p>
&lt;p>修复控制平面&lt;/p>
&lt;p>首先我也确保下我们的所有控制平面 Pod 已经停止了。&lt;/p>
&lt;pre>&lt;code># 如果你用 docker 也是可以的
crictl rm `crictl ps -aq`
&lt;/code>&lt;/pre>
&lt;blockquote>
&lt;p>注意：kubeadm 默认不会覆盖现有的证书和 kubeconfigs，为了重新颁发证书，你必须先手动删除旧的证书。&lt;/p>
&lt;/blockquote>
&lt;p>接下来我们首先恢复 etcd，在**一个 master **节点上执行下面的命令生成 etcd 集群的证书：&lt;/p>
&lt;pre>&lt;code>kubeadm init phase certs etcd-ca --config=kubeadm-config.yaml
&lt;/code>&lt;/pre>
&lt;p>上面的命令将为我们的 etcd 集群生成一个新的 CA，由于所有其他证书都必须由它来签署，我们也将把它和私钥复制到其他 master 节点(如果你是多 master)。&lt;/p>
&lt;pre>&lt;code>/etc/kubernetes/pki/etcd/ca.{key,crt}
&lt;/code>&lt;/pre>
&lt;p>接下来让我们在&lt;strong>所有 master&lt;/strong> 节点上为它重新生成其余的 etcd 证书和静态资源清单。&lt;/p>
&lt;pre>&lt;code>kubeadm init phase certs etcd-healthcheck-client --config=kubeadm-config.yaml
kubeadm init phase certs etcd-peer --config=kubeadm-config.yaml
kubeadm init phase certs etcd-server --config=kubeadm-config.yaml
kubeadm init phase etcd local --config=kubeadm-config.yaml
&lt;/code>&lt;/pre>
&lt;p>上面的命令执行后，你应该已经有了一个正常工作的 etcd 集群了。&lt;/p>
&lt;pre>&lt;code># crictl ps
CONTAINER ID IMAGE CREATED STATE NAME ATTEMPT POD ID
ac82b4ed5d83a 0369cf4303ffd 2 seconds ago Running etcd 0 bc8b4d568751b
&lt;/code>&lt;/pre>
&lt;p>接下来我们对 Kubernetes 服务做同样的操作，在其中&lt;strong>一个 master&lt;/strong> 节点上执行如下的命令：&lt;/p>
&lt;pre>&lt;code>kubeadm init phase certs all --config=kubeadm-config.yaml
kubeadm init phase kubeconfig all --config=kubeadm-config.yaml
kubeadm init phase control-plane all --config=kubeadm-config.yaml
rm -rf /root/.kube/*
cp -f /etc/kubernetes/admin.conf ~/.kube/config
&lt;/code>&lt;/pre>
&lt;p>上面的命令将生成 Kubernetes 的所有 SSL 证书，以及 Kubernetes 服务的静态 Pods 清单和 kubeconfigs 文件。&lt;/p>
&lt;p>如果你使用 kubeadm 加入 kubelet，你还需要更新 &lt;code>kube-public&lt;/code> 命名空间中的 cluster-info 配置，因为它仍然包含你的旧 CA 的哈希值。&lt;/p>
&lt;pre>&lt;code>kubeadm init phase bootstrap-token --config=kubeadm-config.yaml
&lt;/code>&lt;/pre>
&lt;p>由于其他 master 节点上的所有证书也必须由单一 CA 签署，所以我们将其复制到其他控制面节点，并在每个节点上重复上述命令。&lt;/p>
&lt;pre>&lt;code>/etc/kubernetes/pki/{ca,front-proxy-ca}.{key,crt}
/etc/kubernetes/pki/sa.{key,pub}
&lt;/code>&lt;/pre>
&lt;p>顺便说一下，作为手动复制证书的替代方法，你也可以使用 Kubernetes API，如下所示的命令：&lt;/p>
&lt;pre>&lt;code>kubeadm init phase upload-certs --upload-certs --config=kubeadm-config.yaml
# 上一条命令输出的 certificate-key 替换 ${MasterJoinKey}
kubeadm token create --ttl=2h --certificate-key=${MasterJoinKey} --print-join-command
&lt;/code>&lt;/pre>
&lt;p>该命令将加密并上传证书到 Kubernetes，时间为 2 小时，所以你可以按以下方式注册 master 节点：&lt;/p>
&lt;pre>&lt;code># 注意替换上面命令输出的 join 命令的内容
kubeadm join phase control-plane-prepare all kubernetes-apiserver:6443 --control-plane --token cs0etm.ua7fbmwuf1jz946l --discovery-token-ca-cert-hash sha256:555f6ececd4721fed0269d27a5c7f1c6d7ef4614157a18e56ed9a1fd031a3ab8 --certificate-key 385655ee0ab98d2441ba8038b4e8d03184df1806733eac131511891d1096be73
kubeadm join phase control-plane-join all
&lt;/code>&lt;/pre>
&lt;p>需要注意的是，Kubernetes API 还有一个配置，它为 &lt;code>front-proxy&lt;/code> 客户端持有 CA 证书，它用于验证从 apiserver 到 webhooks 和聚合层服务的请求。不过 kube-apiserver 会自动更新它。到在这个阶段，我们已经有了一个完整的控制平面了。&lt;/p>
&lt;h2 id="修复-kubelet">修复 kubelet&lt;/h2>
&lt;pre>&lt;code>systemctl stop kubelet
rm -rf /var/lib/kubelet/pki/
kubeadm init phase kubeconfig kubelet --config=kubeadm-config.yaml
kubeadm init phase kubelet-start --config=kubeadm-config.yaml
&lt;/code>&lt;/pre>
&lt;h2 id="修复工作节点">修复工作节点&lt;/h2>
&lt;p>现在我们可以使用下面的命令列出集群的所有节点：&lt;/p>
&lt;pre>&lt;code>kubectl get nodes
&lt;/code>&lt;/pre>
&lt;blockquote>
&lt;p>若报错：Unable to connect to the server: x509: certificate signed by unknown authority
删除 /root/.kube/config 文件，并重新拷贝一遍&lt;/p>
&lt;/blockquote>
&lt;p>当然正常现在所有节点的状态都是 NotReady，这是因为他们仍然还使用的是旧的证书，为了解决这个问题，我们将使用 kubeadm 来执行重新加入集群节点。&lt;/p>
&lt;pre>&lt;code>systemctl stop kubelet
rm -rf /var/lib/kubelet/pki/ /etc/kubernetes/kubelet.conf
kubeadm init phase kubeconfig kubelet --config=kubeadm-config.yaml
kubeadm init phase kubelet-start --config=kubeadm-config.yaml
&lt;/code>&lt;/pre>
&lt;p>但要加入工作节点，我们必须生成一个新的 token。&lt;/p>
&lt;pre>&lt;code>kubeadm token create --print-join-command
&lt;/code>&lt;/pre>
&lt;p>然后在工作节点分别执行下面的命令：&lt;/p>
&lt;pre>&lt;code>systemctl stop kubelet
rm -rf /var/lib/kubelet/pki/ /etc/kubernetes/pki/ /etc/kubernetes/kubelet.conf
kubeadm join phase kubelet-start kubernetes-apiserver:6443 --token cs0etm.ua7fbmwuf1jz946l --discovery-token-ca-cert-hash sha256:555f6ececd4721fed0269d27a5c7f1c6d7ef4614157a18e56ed9a1fd031a3ab8
&lt;/code>&lt;/pre>
&lt;p>上面的操作会把你所有的 kubelet 重新加入到集群中，它并不会影响任何已经运行在上面的容器，但是，如果集群中有多个节点并且不同时进行，则可能会遇到一种情况，即 kube-controller-mananger 开始从 NotReady 节点重新创建容器，并尝试在活动节点上重新调度它们。&lt;/p>
&lt;p>为了防止这种情况，我们可以暂时停掉 master 节点上的 controller-manager。&lt;/p>
&lt;pre>&lt;code>rm /etc/kubernetes/manifests/kube-controller-manager.yaml
crictl rmp `crictl ps --name kube-controller-manager -q`
&lt;/code>&lt;/pre>
&lt;p>一旦集群中的所有节点都被加入，你就可以为 controller-manager 生成一个静态资源清单，在所有 master 节点上运行下面的命令。&lt;/p>
&lt;pre>&lt;code>kubeadm init phase control-plane controller-manager
&lt;/code>&lt;/pre>
&lt;p>如果 kubelet 被配置为请求由你的 CA 签署的证书(选项 serverTLSBootstrap: true)，你还需要批准来自 kubelet 的 CSR：&lt;/p>
&lt;pre>&lt;code>kubectl get csrkubectl certificate approve &amp;lt;csr&amp;gt;
&lt;/code>&lt;/pre>
&lt;h2 id="修复-serviceaccounts">修复 ServiceAccounts&lt;/h2>
&lt;p>因为我们丢失了 &lt;code>/etc/kubernetes/pki/sa.key&lt;/code> ，这个 key 用于为集群中所有 &lt;code>ServiceAccounts&lt;/code> 签署 &lt;code>jwt tokens&lt;/code>，因此，我们必须为每个 sa 重新创建 tokens。这可以通过类型为 &lt;code>kubernetes.io/service-account-token&lt;/code> 的 Secret 中删除 token 字段来完成。&lt;/p>
&lt;pre>&lt;code>kubectl get secret --all-namespaces | awk '/kubernetes.io\/service-account-token/ { print &amp;quot;kubectl patch secret -n &amp;quot; $1 &amp;quot; &amp;quot; $2 &amp;quot; -p {\\\&amp;quot;data\\\&amp;quot;:{\\\&amp;quot;token\\\&amp;quot;:null}}&amp;quot;}' | sh -x
&lt;/code>&lt;/pre>
&lt;p>删除之后，kube-controller-manager 会自动生成用新密钥签名的新令牌。不过需要注意的是并非所有的微服务都能即时更新 tokens，因此很可能需要手动重新启动使用 tokens 的容器。&lt;/p>
&lt;pre>&lt;code>kubectl get pod --field-selector 'spec.serviceAccountName!=default' --no-headers --all-namespaces | awk '{print &amp;quot;kubectl delete pod -n &amp;quot; $1 &amp;quot; &amp;quot; $2 &amp;quot; --wait=false --grace-period=0&amp;quot;}'
&lt;/code>&lt;/pre>
&lt;p>例如，这个命令会生成一个命令列表，会将所有使用非默认的 serviceAccount 的 Pod 删除，我建议从 kube-system 命名空间执行，因为 kube-proxy 和 CNI 插件都安装在这个命名空间中，它们对于处理你的微服务之间的通信至关重要。&lt;/p>
&lt;p>到这里我们的集群就恢复完成了。&lt;/p>
&lt;blockquote>
&lt;p>参考链接：&lt;a href="https://itnext.io/breaking-down-and-fixing-kubernetes-4df2f22f87c3">https://itnext.io/breaking-down-and-fixing-kubernetes-4df2f22f87c3&lt;/a>&lt;/p>
&lt;/blockquote></description></item><item><title>Docs: 1.1.Keepalived 介绍</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/3.%E9%9B%86%E7%BE%A4%E4%B8%8E%E5%88%86%E5%B8%83%E5%BC%8F/keepalived/1.1.keepalived-%E4%BB%8B%E7%BB%8D/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/3.%E9%9B%86%E7%BE%A4%E4%B8%8E%E5%88%86%E5%B8%83%E5%BC%8F/keepalived/1.1.keepalived-%E4%BB%8B%E7%BB%8D/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>官网：&lt;a href="http://www.keepalived.org/">http://www.keepalived.org/&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;ol>
&lt;li>Active/passive 模式&lt;/li>
&lt;li>Keepalived 是 vrrp 协议在 Linux 主机上以守护进程方式的实现&lt;/li>
&lt;li>能够根据配置文件自动生成 ipvs 规则&lt;/li>
&lt;li>对各 RS 做健康状态检测&lt;/li>
&lt;/ol>
&lt;h1 id="万字长文带你从-0-学习-keepalived">万字长文带你从 0 学习 Keepalived&lt;/h1>
&lt;p>负载均衡器（Load Balancer, LB ）是一组能够将 IP 数据流以负载均衡形式转发到多台物理服务器的集成软件。有硬件负载均衡器和软件负载均衡器之分，硬件负载均衡器主要是在访问网络和服务器之间配置物理负载均衡设备，客户端对物理服务器的访问请求首先会抵达负载均衡设备，然后再由负载均衡设备根据一定的负载算法转发到后端服务器。相比而言，软件负载均衡器不需要特定的物理设备，只需在相应的操作系统上部署具有负载均衡功能的软件即可。&lt;/p>
&lt;p>在 Openstack 高可用集群部署中，服务的负载均衡和高可用主要有两种主流的实现方案，即 HAProxy+ Keepalived 和 Pacemaker+HAProxy 方案。由于 OpenStack 服务组件多样，不同服务均需要进行特定的高可用设计，并且从集群资源统一调度和集群稳定性的角度考虑，后一种方案是多数 OpenStack 厂商的高可用部署方案首选，但是选用后一方案并不意味着 Keepalived 在 OpenStack 高可用集群部署中不被使用。由于 Keepalived 的主要作用之一是进行虚拟路由的故障切换，其在 Neutron 的 L3 高可用设计与实现中起着举足轻重的作用。&lt;/p>
&lt;h1 id="11-keepalived-及-lvs-概述">1.1 keepalived 及 LVS 概述&lt;/h1>
&lt;p>Keepalived 的项目实现的主要目标是简化 LVS 项目的配置并增强其稳定性，即 Keepalived 是对 LVS 项目的扩展增强。&lt;/p>
&lt;p>Keepalived 为 Linux 系统和基于 Linux 的架构提供了负载均衡和高可用能力，其负载均衡功能主要源自集成在 Linux 内核中的 LVS 项目模块 IPVS( IP Virtual Server ），基于 IPVS 提供的 4 层 TCP/IP 协议负载均衡， Keepalived 也具备负载均衡的功能，此外， Keepalived 还实现了基于多层 TCP/IP 协议（ 3 层、4 层、5/7 层）的健康检查机制，因此， Keepalived 在 LVS 负载均衡功能的基础上，还提供了 LVS 集群物理服务器池健康检查和故障节点隔离的功能。&lt;/p>
&lt;p>除了扩展 LVS 的负载均衡服务器健康检查能力， Keepalived 还基于虚拟路由冗余协议（ Virtual Route Redundancy Protocol, VRRP )实现了 LVS 负载均衡服务器的故障切换转移，即 Keepalived 还实现了 LVS 负载均衡器的高可用性。Keepalived 就是为 LVS 集群节点提供健康检查和为 LVS 负载均衡服务器提供故障切换的用户空间进程。&lt;/p>
&lt;p>图为 Keepalived 的原理架构图，从图中可以看到， Keepalived 的多数核心功能模块均位于用户空间，而仅有 IPVS 和 NETLINK 模块位于内核空间，但是这两个内核模块正是 Keepalived 实现负载均衡和路由高可用的核心模块，其中的 NETLINK 主要用于提供高级路由及其相关的网络功能。Keepalived 的大部分功能模块位于用户空间，其中几个核心功能模块的介绍如下。&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/watgs2/1616132514380-d0730061-c06c-433e-8b33-8868d6966373.jpeg" alt="">&lt;/p>
&lt;ul>
&lt;li>WatchDog ：其主要负责监控 Checkers 和 VRRP 子进程的运行状况。&lt;/li>
&lt;li>Checkers ：此功能模块主要负责真实服务器的健康检查（ HealthChecking )，是 Keepalived 最主要的功能之一，因为 HealthChecking 是负载均衡功能稳定运行的基础， LVS 集群节点的故障隔离和重新加入均依赖于 HealthChecking 的结果。&lt;/li>
&lt;li>VRRPStack ：此功能模块主要负责负载均衡器之间的故障切换，如果集群架构中仅使用一个 LVS 负载均衡器，由于本身不具备故障切换的条件，则 VRRPStack 不是必须的。&lt;/li>
&lt;li>IPVS Wrapper ：此模块主要用来发送设定的规则到内核 IPVS 代码。Keepalived 的设计目标是构建高可用的 LVS 负载均衡群集， Keepalived 在运行中将会通过 IPVSWrapper 模块调用 IPVSAdmin 工具来创建虚拟服务器，检查和管理 LVS 集群物理服务器池。&lt;/li>
&lt;li>Netlink Reflector ：此功能模块主要用来设定 VRRP 的 VIP 地址并提供相关的网络功能，该模块通过与内核中的 NETLINK 模块交互，从而为 Keepalived 提供路由高可用功能。&lt;/li>
&lt;/ul>
&lt;p>从 Keepalived 的实现原理和功能来看， Keepalived 是开源负载均衡项目 LVS 的增强和虚拟路由协议 VRRP 实现的集合，即 Keepalived 通过整合和增强 LVS 与 VRRP 来提供高可用的负载均衡系统架构。&lt;/p>
&lt;h1 id="12-keepalived-工作原理">1.2 KeepAlived 工作原理&lt;/h1>
&lt;p>Keepalived 本质上是提供数据流转发与服务器健康检查并具备故障切换的高可用路由，而数据转发与健康检查是对 LVS 功能的扩展和增强，因此也可以认为 Keepalived 是运行在用户空间的 LVS 路由（LVS Router) 进程。在实际应用中， Keepalived 通常部署在两台主备或一主多备的服务器上，即 Keepalived 进程既运行在 Active/Master 状态的 LVS Router 中，也运行在 Passive/Slave 状态的 LVS Router 中，而所有运行 Keepalived 进程的 LVS Router 都遵循虚拟路由冗余协议 VRRP。在 VRRP 的协议框架下，作为 Master 的 Router 将会处理两个主要任务，即转发客户端访问请求到后端物理服务器以进行负载均衡和周期性的发送 VRRP 协议报文，而作为 Slave 的 Routers 则负责接收 VRRP 报文，如果某一时刻作为 Slave 的 Routers 接收 VRRP 报文失败，则认为 Master Router 故障， 并从 Slave Routers 中重新选举产生一个新的 Master Router 。&lt;/p>
&lt;p>Keepalived 是一个与 LVS Router 相关的控制进程，在 RHEL7 /Centos7 系统中，Keepalived 由 Systemctl 命令通过读取/etc/keepalived/keepalived.conf 配置文件来启动。在遵循 VRRP 协议的 Master Router 中， Keepalived 进程会启动内核中的 LVS 服务以创建虚拟服务器，并根据配置拓扑对服务运行状况进行监控。此外，Master Router 还会向 Slave Routers 发送周期性的 VRRP 广播报文，而 Master Router 运行状态的正常与否是由 Slave Routers 上的 VRRP 实例决定的。如果在用户预置的时间段内 Slave Router 不能接收到 VRRP 报文，则 Keepalived 认为 Master Router 故障，同时触发 LVS Router 的 Failover 操作。&lt;/p>
&lt;p>在 Failover 的过程中， Keepalived 创建的虚拟服务器会被清除，新的 Master Router 将接管 VIP 发送 ARP 信息、设置 IPVS Table 记录条目（Virtual Server）以及物理服务器的健康检查和发送 VRRP 广播报文。Keepalived 的 Failover 操作针对的是四层 TCP/ IP 协议，即传输层，因为 TCP 在传输层上进行的是基于链路连接的数据传输。所以，当服务器在响应 TCP 请求时，如果出现设置时间段的 Timeout，则 Keepalived 的健康检查机制将会监测到该情况并认为该服务器故障，然后将其从服务器池中移除（故障服务器隔离） 。图 3-4 是基于 Keepalived 设计的具有二层拓扑的负载均衡架构，该架构分为两个层次。第一层为负载均衡层，由一个 Active 和多个 Backup 的 LVS Routers 组成，其中，每个 LVS Router 都配置有两个网络接口，一个接入 Internet 网络，另一个接入内部私有网络， Active 的 LVS Router 在这两个网络接口间进行数据转发。在图 3-4 的负载均衡架构中，位于第一层的 LVS Routers 和第二层的物理服务器通过私网接口接人相同的局域网中， Active 的 LVSRouter 通过 NAT 技术将 Internet 数据流转发到私网物理服务器上，而这些位于第二层的物理服务器运行着最终响应请求的服务。&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/watgs2/1616132514345-97aedaa2-8dd5-40fa-a7bb-79f9c9fa0ac6.jpeg" alt="">&lt;/p>
&lt;p>位于二层私网中的服务器在与 Internet 交互时必须经过主 LVS Router 的 NAT 转发， 并且对于外部网络中的客户端而言，访问二层私网中的物理服务器就如访问同处 Internet 网络中的服务，因为从客户端的角度来看，访问请求的目的地址正是位于主 LVS Router 上的 VIP 地址，而该 VIP 与客户端地址处于相同网络中， VIP 还可以是管理员指定的互联网域名，如www.example.com 。VIP 在 Keepalived 的配置中通常被指定到一个或者多个虚拟服务器上，而虚拟服务器的主要任务便是监昕 VIP 及相应端口上的请求，当主 LVS Router 进行 Failover 操作的时候， VIP 会从一个 LVS Router 转移到另一个 LVS（因此 VIP 也称为浮动 IP)。&lt;/p>
&lt;p>在 Keepalived 负载均衡架构的 VIP 配置中，每个将 LVS Router 连接到 Internet 的物理网卡接口均可配置多个 VIP ，并且每个 VIP 对应着不同的 Virtual Server ，即多个 VirtualServers 可以同时监听相同物理网卡上的不同 VIP ，其中每个 VIP 都对应着不同的服务。例如， Linux 系统中的接口 eth0 将 LVS Router 连接到 Internet 中，则可以在 eth0 上配置一个地址为 192.168.115.100 的 VIP 以用于响应 HTTP 服务请求，同时还可以在 eth0 上配置另一个地址为 192.168.115.200 的 VIP 以用于响应 FTP 服务请求。在这里， HTTP 服务和 FTP 服务均对应着监听不同 VIP 的 Virtual Server 。在由一个 Active Router 和一个 Backup Router 组成的 Keepalived 负载均衡架构中， Active Router 的主要任务就是将 VIP 上的请求转发到选中的某个后端服务器上，具体服务器的选举机制则由 Keepalived 所支持的负载均衡算法来决定。&lt;/p>
&lt;p>此外， Active Router 还负责动态监控后端服务器上特定服务的健康状况，监控方式主要是 Keepalived 自带的三种健康检测机制，即简单 TCP 连接、HTTP 和 HTTPS。就简单 TCP 连接检测方式， Active Router 会周期性地对服务器上某个特定端口进行 TCP 连接，如果 TCP 连接超时或者中断则认为服务不可用，而对于 HTTP 和 HTTPS 检测方式， ActiveRouter 通过周期性地抓取（ Fetch ）请求 URL 并验证其内容来判断服务的可用性。与此同时， Backup Router 一直处于 Standby 状态， LVS router 的 Failover 由 VRRP 来处理。&lt;/p>
&lt;p>在 Keepalived 进程启动的时候，所有 LVS Routers 会加人一个用来接收和发送 VRRP 广播的多播组， 由于 VRRP 是一种基于优先级的协议，因此在启动之初优先级高的 LVS Router 会被选举为 Master Router ，而 Master Router 将会周期性地向多播组中的成员发送 VRRP 广播。如果多播组中的 Backup Routers 在一定时间内接收 VRRP 广播失败，则重新选举新的 Master Router ，新的 Master Router 将会接管 VIP 并广播地址解析协议（ Address ResolutionProtocol, ARP ）信息。而当故障 Router 重新恢复后，根据该 Router 的优先级情况，其可能恢复到 Master 状态也可能保持为 Backup 状态。&lt;/p>
&lt;p>图中的两层负载均衡架构是最常见的部署环境，主要用于很多数据源变化不是很频繁的数据请求服务中，如静态 Web 页面站点，因为后端独立服务器（Real Severs ）之间不会自动进行数据同步。图 3-5 为基于 Keepalived 的三层负载均衡架构，在三层负载均衡架构中，前端的 LVS Router 负责将访问请求转发到物理服务器（ Real Servers ）中，然后 Real Server 再通过网络形式访问可共享的数据源。&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/watgs2/1616132514381-c261d4f3-8895-48fb-b4c8-ea8a73ab2882.jpeg" alt="">&lt;/p>
&lt;p>对于数据请求比较繁忙的 FTP 站点，三层架构是最为理想的负载均衡架构，在这种架构下，可供访问的数据源集中存储在高可用的集群服务器上， Real Servers 通过 NFS 共享目录或者 Samba 文件共享等网络文件系统形式来访问数据。此外，类似的三层负载均衡架构在需要提供中心化及数据库事务处理高可用的 Web 站点中也被普遍使用，如果将 Keepalived 负载均衡器配置为 Active/Active 双活模式，则还可以将三层负载均衡架构同时用于提供 FTP 和 Web 数据库服务。&lt;/p>
&lt;h1 id="13-keepalived-的负载均衡算法">1.3 KeepAlived 的负载均衡算法&lt;/h1>
&lt;p>Keepalived 所使用的负载均调度机制由集成到内核中的 IPVS 模块提供， IPVS 是 LVS 项目的核心功能模块，其设计的主要目的之一就是解决单 IP 多服务器的工作环境，IPVS 模块使得基于 TCP/IP 传输层（ 第 4 层）的数据交换成为可能。在实际使用中， IPVS 会在内核中创建一个名为 IPVS Table 的表，该表记录了后端服务器的地址及服务运行状态，通过 IPVS Table, Keepalived 便可跟踪并将请求路由到后端物理服务器中， 即 LVS Router 利用此表将来自 Keepalived 虚拟服务器地址的请求转发到后端服务器池中，同时将后端服务器的处理结果转发给客户端。此外， IPVS table 的表结构主要取决于管理员对指定的虚拟服务器所设置的负载均衡算法， Keepalived 支持以下几种负载均衡算法。&lt;/p>
&lt;p>( 1 ) Round-Robin&lt;/p>
&lt;p>即所谓的轮询负载均衡，在这种算法中，服务请求会被依次转发到服务器池中的每一个服务器上，而不去评估服务器的当前负载或者处理能力，服务器池中的每一个服务器都被平等对待。如果使用 Round-Robin 负载均衡算法，每台后端服务器会轮询依次处理服务请求。&lt;/p>
&lt;p>( 2 ) Weighted Round-Robin&lt;/p>
&lt;p>即加权 Round-Robin 算法，是对 Round-Robin 算法的一种扩展。在这种算法中，请求被依次转发到每一台服务器上，但是当前负载较轻或者计算能力较大的服务器会被转发更多的请求，服务器的处理能力通过用户指定的权重因子来决定，权重因子可以根据负载信息动态上调或者下调。如果服务器的配置差别较大，导致不同服务器的处理能力相差较大，则加权的 Round-Robin 算法会是不错的选择，但是如果请求负载频繁变动，则权重较大的服务器可能会超负荷工作。&lt;/p>
&lt;p>( 3 ) Least-Connection&lt;/p>
&lt;p>即最少连接算法，在这种算法中，请求被转发到活动连接较少的服务器上。在 Keepalived 的实际使用中， LVS Router 一直在利用内核中的 IPVS Table 来记录后端服务器的活动连接，从而动态跟踪每个服务器的活动连接数。最少连接数算法是一种动态决策算法，它比较适合服务器池中每个成员的处理能力都大致相当，同时负载请求又频繁变化的场景， 如果不同服务器有不同的处理能力，则下面的加权最少连接数算法较为合适。&lt;/p>
&lt;p>( 4 ) Weighted Least-Connections&lt;/p>
&lt;p>即加权最少连接数算法，在这种算法中，路由会根据服务器的权重，转发更多的请求到连接数较少的服务器上。服务器的处理能力通过用户指定的权重因子来决定，权重因子可以根据负载信息动态上调或者下调。一般来说，服务器加权算法主要用于集群存在不同类型服务器，而服务器配置和处理能力相差较大的场景中。&lt;/p>
&lt;p>( 5) Destination Hash ScheduIing&lt;/p>
&lt;p>即目标地址哈希算法，通过在静态 Hash 表中查询目的 IP 地址来确定请求要转发的服务器，这类算法主要用于缓存代理服务器集群中。&lt;/p>
&lt;p>( 6 ) Source Hash Scheduling&lt;/p>
&lt;p>即源地址哈希算法，通过在静态 Hash 表中查询源 IP 地址来确定请求要转发的服务器，这类算法主要应用于存在多防火墙的 LVS Router 中。&lt;/p>
&lt;p>( 7 ) Shortest Expected Delay&lt;/p>
&lt;p>即最小延时算法，在这种算法中，请求被转发到具有最小连接响应延时的服务器上。&lt;/p>
&lt;h1 id="14-keepalived-路由方式">1.4 Keepalived 路由方式&lt;/h1>
&lt;p>（1） NAT&lt;/p>
&lt;p>图 3-6 为基于 NAT 路由实现的 Keepalived 负载均衡器，在 NAT 机制下，每个 LVS Router 需要两个网络接口。假设 eth0 为接人 Internet 的网络接口，则 eth0 上配置有一个真实的 IP 地址，同时还配置了一个浮动 IP 地址（Floating IP ）假设 eth1 为接入后端私有网络的接口， 则 eth1 上也配置有一个真实 IP 地址和一个浮动 IP 地址。在出现故障切换 Failover 的时候， 接人 Internet 的虚拟接口和接入私有网络的虚拟接口会同时切换到 Backup 的 LVSRouter 上，而为了不影响对 Internet 客户端的请求响应，位于私有网络中的后端服务器均使用 NAT 路由的浮动 IP 作为与主 LVS Router 通信的默认路由。&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/watgs2/1616132514427-959ff4e7-b87e-4b5f-a914-d6b110653af9.jpeg" alt="">&lt;/p>
&lt;p>对外提供服务的公有 VIP(Public Virtual IP Address ）和私有 NAT VIP(NAT Virtual IP Address）均被配置在物理网卡上而最佳的配置方式是将两个 VIP 各自配置到不同的物理网卡上，即在这种配置下，每个 LVS Router 节点最多只需两个物理网卡。在 NAT 路由转发中，主 LVS Router 负责接收请求，并将请求的目的地址替换成 LVS Router 的 NAT Virtual IP 地址，再将其转发到选中的后端服务器上，同时服务器处理后的应答数据也通过 LVS Router 将其地址替换成 LVS Router 的 Public Virtual IP 地址，然后再转发给 Internet 客户端，这个过程也称为 IP 伪装，因为对客户端而言，服务器的真实 IP 地址已被隐藏。&lt;/p>
&lt;p>在 NAT 路由实现的负载均衡中，后端服务器上可以运行各种操作系统，即后端服务器上的操作系统类型并不影响 LVS Router 的 NAT 路由功能，但是，使用 NAT 路由方式存在的一个缺点是， LVS Router 在大规模集群部署中可能会是一个瓶颈，因为 LVS Router 要同时负责进出双向数据流的 IP 地址替换。&lt;/p>
&lt;p>（2） DR&lt;/p>
&lt;p>相对于其他的负载均衡网络拓扑， DR(Direct Routing）路由方式为基于 Keepalived 的负载均衡系统提供了更高的网络性能， DR 路由方式允许后端服务器直接将处理后的应答数据返回给客户端，而无需经过 LVS Router 的处理操作，DR 路由方案极大降低了 LVS Router 造成网络瓶颈的可能性。如图 3-7 所示。在基于 Keepalived 的负载均衡架构中， Keepalived 的最佳路由方式是 DR 路由，即在配置 Keepalived 的路由方式时，优先将其设置为 DR 。&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/watgs2/1616132514433-6d061a2c-ec2a-43ea-a749-4acef265787f.jpeg" alt="">&lt;/p></description></item><item><title>Docs: 1.1.Rancher 介绍</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/10.%E4%BA%91%E5%8E%9F%E7%94%9F/2.3.kubernetes-%E5%AE%B9%E5%99%A8%E7%BC%96%E6%8E%92%E7%B3%BB%E7%BB%9F/kubernetes-%E8%A1%8D%E7%94%9F%E5%93%81/rancher/1.1.rancher-%E4%BB%8B%E7%BB%8D/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/10.%E4%BA%91%E5%8E%9F%E7%94%9F/2.3.kubernetes-%E5%AE%B9%E5%99%A8%E7%BC%96%E6%8E%92%E7%B3%BB%E7%BB%9F/kubernetes-%E8%A1%8D%E7%94%9F%E5%93%81/rancher/1.1.rancher-%E4%BB%8B%E7%BB%8D/</guid><description>
&lt;h1 id="rancher-介绍">Rancher 介绍&lt;/h1>
&lt;p>官方文档：&lt;a href="https://rancher.com/">https://rancher.com/&lt;/a>&lt;/p>
&lt;p>Rancher 是为使用容器的公司打造的容器管理平台。Rancher 简化了使用 Kubernetes 的流程，开发者可以随处运行 Kubernetes（Run Kubernetes Everywhere），满足 IT 需求规范，赋能 DevOps 团队。&lt;/p>
&lt;p>Rancher 在现阶段可以看作是一个解决方案，是一套产品的统称，这套产品包括如下几个：&lt;/p>
&lt;ol>
&lt;li>
&lt;p>K3S # 用于运行高可用 Rancher 的底层平台。是一个轻量的 kubernetes，一个 k3s 二进制文件即可包含所有 kubernetes 的主要组件。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Rancher Server # Rancher 管理程序，常部署于 k3s 之上，用来管理其下游 k8s 集群。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>RKE # Rancher 创建的 kubernetes 集群。是一个可以通过名为 rke 的二进制文件以及一个 yaml 文件，即可启动 kubernetes 集群的引擎。RKE 与 kubernetes 的关系，类似于 docker 与 containerd 的关系。&lt;/p>
&lt;/li>
&lt;/ol>
&lt;h2 id="rancher-server-介绍">Rancher Server 介绍&lt;/h2>
&lt;p>Rancher Server 由认证代理(Authentication Proxy)、Rancher API Server、集群控制器(Cluster Controller)、数据存储(比如 etcd、mysql 等)和集群代理(Cluster Agent) 组成。除了 Cluster Agent 以外，其他组件都部署在 Rancher Server 中。(这些组件都集中在一起，一般可以通过 docker 直接启动一个 Rancher Server。)&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/kxmsmg/1616114814016-9de5267d-0813-4790-826c-7c4448e40861.png" alt="">&lt;/p>
&lt;p>Rancher Server 可以管理多种 k8s 集群&lt;/p>
&lt;ol>
&lt;li>
&lt;p>通过 Rancher Server 来创建一个 RKE 集群&lt;/p>
&lt;/li>
&lt;li>
&lt;p>托管的 kubernetes 集群。e.g.Amazon EKS、Azure AKS、Google GKE 等等&lt;/p>
&lt;/li>
&lt;li>
&lt;p>导入已有的 kubernetes 集群。&lt;/p>
&lt;/li>
&lt;/ol>
&lt;h2 id="rancher-与下游集群交互的方式">Rancher 与下游集群交互的方式&lt;/h2>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/kxmsmg/1616114813966-db373999-6c8f-4541-a09f-5f20eaa656ce.png" alt="">&lt;/p>
&lt;p>通过 Rancher 管理的 kubernetes 集群(不管是导入的还是通过 Rancher 创建的)，都会在集群中部署两种 agent，来与 Rancher 进行交互。&lt;/p>
&lt;ol>
&lt;li>
&lt;p>cattle-cluster-agent # 上图中的 Cluster Agent。用于本集群与 Rancher Server 的 Cluster Controller(集群控制器)的通信&lt;/p>
&lt;/li>
&lt;li>
&lt;p>连接 Rancher 与本集群的 API Server&lt;/p>
&lt;/li>
&lt;li>
&lt;p>管理集群内的工作负载，比如 Rancher Server 下发一个部署 pod 的任务，集群代理就会与本集群 API 交互来处理任务&lt;/p>
&lt;/li>
&lt;li>
&lt;p>根据每个集群的设置，配置 Role 和 RoleBindings&lt;/p>
&lt;/li>
&lt;li>
&lt;p>实现集群和 Rancher Server 之间的消息传输，包括事件，指标，健康状况和节点信息等。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>cattle-node-agent # 上图中的 Node Agent。用于处理本节点的任务，比如升级 kubernetes 版本以及创建或者还原 etcd 快照等等。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Note：如果 Cluster Agent 不可用，下游集群中的其中一个 Node Agent 会创建一个通信管道，由节点 Agent 连接到集群控制器，实现下游集群和 Rancher 之间的通信。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>一般使用 DaemonSet 的方式部署到集群中，以保证每个节点都有一个代理可以执行 Rancher Server 下发的任务。&lt;/p>
&lt;/li>
&lt;/ol>
&lt;h1 id="rancher-配置">Rancher 配置&lt;/h1>
&lt;p>Rancher 套件中的各组件配置详见各自组件配置详解&lt;/p>
&lt;h2 id="k3s-配置">K3S 配置&lt;/h2>
&lt;h2 id="rancher-server-配置">Rancher Server 配置&lt;/h2>
&lt;h2 id="rancher-创建的集群配置">Rancher 创建的集群配置&lt;/h2>
&lt;p>Rancher 创建的集群是为 RKE 集群，配置详见：RKE 配置详解&lt;/p></description></item><item><title>Docs: 1.1.Redis 高可用概述</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/5.%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8/2.%E6%95%B0%E6%8D%AE%E5%BA%93/%E9%94%AE%E5%80%BC%E6%95%B0%E6%8D%AE/redis/redis-%E9%AB%98%E5%8F%AF%E7%94%A8/1.1.redis-%E9%AB%98%E5%8F%AF%E7%94%A8%E6%A6%82%E8%BF%B0/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/5.%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8/2.%E6%95%B0%E6%8D%AE%E5%BA%93/%E9%94%AE%E5%80%BC%E6%95%B0%E6%8D%AE/redis/redis-%E9%AB%98%E5%8F%AF%E7%94%A8/1.1.redis-%E9%AB%98%E5%8F%AF%E7%94%A8%E6%A6%82%E8%BF%B0/</guid><description>
&lt;p>参考：&lt;a href="http://blog.jboost.cn/redis-cluster.html">原文&lt;/a>、&lt;a href="https://zhuanlan.zhihu.com/p/129640817">知乎&lt;/a>、&lt;a href="https://mp.weixin.qq.com/s?__biz=MzI3MTI2NzkxMA==&amp;amp;mid=2247492218&amp;amp;idx=1&amp;amp;sn=8e233cf3c3abd0e6821262d1c78b03d1&amp;amp;chksm=eac6c353ddb14a4535ae92f911ae846592066bf9250b9aca4d91287015de8b23347cb56838ce&amp;amp;mpshare=1&amp;amp;scene=1&amp;amp;srcid=1123S90JeR1nwKagOdJBlQTz&amp;amp;sharer_sharetime=1606090661231&amp;amp;sharer_shareid=09464b4a0389b967659ba78076a1ef58&amp;amp;key=48765414c6ece973eab40bd813ac84f36f02f86a2b622e5efcf4fb98864fdb95a49286689ce7513bf3642cc2a2b6d4bd4235c0de418caee7320bf928f76e57b65a7c762b34b8e80ed88a847524e64e1d6e08271ee31db62eb4ff0bce50cdc03f2b4161ba26993d58b1f19972154a004ce4cadfca3a79f41936616473cacfeff7&amp;amp;ascene=1&amp;amp;uin=MTI5NTMzMzA0MQ%3D%3D&amp;amp;devicetype=Windows+10+x64&amp;amp;version=6300002f&amp;amp;lang=zh_CN&amp;amp;exportkey=AanBDsftQoVwZuEgK1A5lo8%3D&amp;amp;pass_ticket=S1%2BMQ7vYsbZSNuJMJOqmLPRlt4Y3dQwyWaD%2FAmp3sq1Yd7omWT6hEhxkL9s%2BaMxR&amp;amp;wx_header=0">微信公众号&lt;/a>&lt;/p>
&lt;p>&lt;strong>Redis 支持三种高可用方案&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://www.yuque.com/go/doc/33187771">Replication(复制) 模式&lt;/a>。
&lt;ul>
&lt;li>实际上，该模式并不是绝对的高可用，仅仅保证了数据的不丢失&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;a href="https://www.yuque.com/go/doc/33187731">Sentinel(哨兵) 模式&lt;/a>&lt;/li>
&lt;li>Cluster(集群) 模式&lt;/li>
&lt;/ul>
&lt;h1 id="cluster集群">Cluster(集群)&lt;/h1>
&lt;p>&lt;a href="http://www.redis.cn/topics/cluster-tutorial.html">http://www.redis.cn/topics/cluster-tutorial.html&lt;/a>&lt;/p>
&lt;p>&lt;a href="https://redis.io/topics/cluster-tutorial">https://redis.io/topics/cluster-tutorial&lt;/a>&lt;/p>
&lt;h2 id="客户端操作原理请求路由原理">客户端操作原理(请求路由原理)&lt;/h2>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/gnlint/1616134822977-6bf24d85-a95a-4729-8807-b5c63d74e9a7.jpeg" alt="">&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/gnlint/1616134822986-56d8d02c-0433-4df5-a829-8e7fb0435fb0.jpeg" alt="">&lt;/p>
&lt;ol>
&lt;li>请求重定向&lt;/li>
&lt;/ol>
&lt;p>在集群模式下，Redis 接收任何键相关命令时首先计算键对应的槽，再根据槽找出所对应的节点，如果节点是自身，则处理键命令；否则回复 MOVED 重定向错误，通知客户端请求正确的节点。这个过程称为 MOVED 重定向。&lt;/p>
&lt;pre>&lt;code># 如果key经过计算后，其分配的slot就在当前节点，那么可以请求成功，否则，回复重定向消息
[root@node01 redis]# redis-cli -h 10.0.0.100 -p 6379
10.0.0.100:6379&amp;gt; set name tom
OK
10.0.0.100:6379&amp;gt; set age 20
(error) MOVED 741 10.0.0.101:6379
&lt;/code>&lt;/pre>
&lt;p>重定向信息包含了键所对应的槽以及负责该槽的节点地址，根据这些信息客户端就可以向正确的节点发起请求。在 10.0.0.101:6379 节点上成功执行之前的命令：&lt;/p>
&lt;pre>&lt;code>[root@node02 redis]# redis-cli -h 10.0.0.101 -p 6379
10.0.0.101:6379&amp;gt; set age 20
OK
&lt;/code>&lt;/pre>
&lt;p>使用 redis-cli 命令时，可以加入-c 参数支持自动重定向，简化手动发起重定向的操作：&lt;/p>
&lt;pre>&lt;code>[root@node01 redis]# redis-cli -c -h 10.0.0.100 -p 6379
10.0.0.100:6379&amp;gt; set age 30
-&amp;gt; Redirected to slot [741] located at 10.0.0.101:6379
OK
&lt;/code>&lt;/pre>
&lt;p>redis-cli 自动帮我们连接到正确的节点执行命令，这个过程是在 redis-cli 内部维护，实质上是 client 端接到 MOVED 信息指定的节点之后再次发起请求，并不是在当前 Redis 节点中完成请求转发，节点对于不属于它的键命令只回复重定向响应，并不负责转发。&lt;/p>
&lt;p>键命令执行步骤主要分两步：&lt;/p>
&lt;ol>
&lt;li>计算槽&lt;/li>
&lt;/ol>
&lt;p>Redis 首先需要计算键所对应的槽，根据键的有效部分使用 CRC16 函数计算出散列值，再取对 16383 的余数，得到槽的编号，这样每个键都可以映射到 0~16383 槽范围内&lt;/p>
&lt;pre>&lt;code>10.0.0.101:6379&amp;gt; cluster keyslot age
(integer) 741
&lt;/code>&lt;/pre>
&lt;p>Redis 集群相对单机在功能上存在一些限制，限制如下：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>key 批量操作支持有限，如 mset、mget，目前只支持具有相同 slot 值的 key 执行批量操作。对于映射为不同 slot 值的 key 由于执行 mget、mget 等操作可能存在于多个节点上因此不被支持&lt;/p>
&lt;/li>
&lt;li>
&lt;p>key 事务操作支持有限，同理只支持多 key 在同一节点上的事务操作，当多个 key 分布在不同的节点上时无法使用事务功能&lt;/p>
&lt;/li>
&lt;li>
&lt;p>key 作为数据分区的最小粒度，因此不能将一个大的键值对象如 hash、list 等映射到不同的节点&lt;/p>
&lt;/li>
&lt;li>
&lt;p>不支持多数据库空间，单机下的 Redis 可以支持 16 个数据库，集群模式下只能使用一个数据库空间，即 db0&lt;/p>
&lt;/li>
&lt;li>
&lt;p>复制结构只支持一层，从节点只能复制主节点，不支持嵌套树状复制结构&lt;/p>
&lt;p>10.0.0.102:6379&amp;gt; mget name age
(error) CROSSSLOT Keys in request don&amp;rsquo;t hash to the same slot&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>但通常会有这样的需求，例如把一个用户的信息存入到一个 slot 中，这是可以这样设置：&lt;/p>
&lt;pre>&lt;code>10.0.0.102:6379&amp;gt; set user:{user1}:name tony
-&amp;gt; Redirected to slot [8106] located at 10.0.0.100:6379
OK
10.0.0.100:6379&amp;gt; set user:{user1}:age 20
OK
10.0.0.100:6379&amp;gt; cluster keyslot user:{user1}:name
(integer) 8106
10.0.0.100:6379&amp;gt; cluster keyslot user:{user1}:age
(integer) 8106
10.0.0.100:6379&amp;gt; mget user:{user1}:name user:{user1}:age
1) &amp;quot;tony&amp;quot;
2) &amp;quot;20&amp;quot;
&lt;/code>&lt;/pre>
&lt;p>这样，这两个 key 在计算 hash 值的时候，不会根据整个 key 来计算，而是只是拿{}中的内容的来计算，这样它们的 hash 值一定是相同的，就可以分配到同一个 slot 中，{}中的内容称为 hash_tag&lt;/p>
&lt;ol>
&lt;li>查找槽所对应的节点&lt;/li>
&lt;/ol>
&lt;p>Redis 计算得到键对应的槽后，需要查找槽所对应的节点。集群内通过消息交换每个节点都会知道所有节点的槽信息。&lt;/p>
&lt;p>根据 MOVED 重定向机制，客户端可以随机连接集群内任一 Redis 获取键所在节点，这种客户端又叫 Dummy(傀 儡)客户端，它优点是代码实现简单，对客户端协议影响较小，只需要根据重定向信息再次发送请求即可。但是它的弊端很明显，每次执行键命令前都要到 Redis 上进行重定向才能找到要执行命令的节点，额外增加了 IO 开销，这不是 Redis 集群高效的使用方式。正因为如此通常集群客户端都采用另一种实现：Smart 客户端&lt;/p>
&lt;h2 id="cluster-模式的优缺点">Cluster 模式的优缺点&lt;/h2>
&lt;p>优点：&lt;/p>
&lt;ol>
&lt;li>
&lt;p>无中心架构，数据按照 slot 分布在多个节点。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>集群中的每个节点都是平等的关系，每个节点都保存各自的数据和整个集群的状态。每个节点都和其他所有节点连接，而且这些连接保持活跃，这样就保证了我们只需要连接集群中的任意一个节点，就可以获取到其他节点的数据。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>可线性扩展到 1000 多个节点，节点可动态添加或删除&lt;/p>
&lt;/li>
&lt;li>
&lt;p>能够实现自动故障转移，节点之间通过 gossip 协议交换状态信息，用投票机制完成 slave 到 master 的角色转换&lt;/p>
&lt;/li>
&lt;/ol>
&lt;p>缺点：&lt;/p>
&lt;ol>
&lt;li>
&lt;p>客户端实现复杂，驱动要求实现 Smart Client，缓存 slots mapping 信息并及时更新，提高了开发难度。目前仅 JedisCluster 相对成熟，异常处理还不完善，比如常见的“max redirect exception”&lt;/p>
&lt;/li>
&lt;li>
&lt;p>节点会因为某些原因发生阻塞（阻塞时间大于 cluster-node-timeout）被判断下线，这种 failover 是没有必要的&lt;/p>
&lt;/li>
&lt;li>
&lt;p>数据通过异步复制，不保证数据的强一致性&lt;/p>
&lt;/li>
&lt;li>
&lt;p>slave 充当“冷备”，不能缓解读压力&lt;/p>
&lt;/li>
&lt;li>
&lt;p>批量操作限制，目前只支持具有相同 slot 值的 key 执行批量操作，对 mset、mget、sunion 等操作支持不友好&lt;/p>
&lt;/li>
&lt;li>
&lt;p>key 事务操作支持有线，只支持多 key 在同一节点的事务操作，多 key 分布不同节点时无法使用事务功能&lt;/p>
&lt;/li>
&lt;li>
&lt;p>不支持多数据库空间，单机 redis 可以支持 16 个 db，集群模式下只能使用一个，即 db 0&lt;/p>
&lt;/li>
&lt;/ol>
&lt;p>Redis Cluster 模式不建议使用 pipeline 和 multi-keys 操作，减少 max redirect 产生的场景。&lt;/p>
&lt;h1 id="sentinel-与-cluster-的区别">Sentinel 与 Cluster 的区别&lt;/h1>
&lt;p>……我感觉楼主自己对 redis 的理解是有一定问题的，但提的问题其实是个好问题，而回帖的大部分人没有回应准确楼主的疑问，少部分评论我看一眼就明白，但楼主可能是想不到的。&lt;/p>
&lt;p>那咱们把集群和哨兵能解决的问题列出来，就比较清楚了。&lt;/p>
&lt;p>哨兵： 哨兵仅仅提供故障切换能力，在这之上，对使用方来说，和单机的 redis 是完全一样的。&lt;/p>
&lt;p>集群： 集群最主要的，解决的是一个“数据分片”的问题，它能把 redis 的数据分散到不同的 slot 里，而不是都集中在一台机器的内存里。这样也就给单进程单线程、纯内存的 redis 提供了水平扩容的能力。&lt;/p>
&lt;p>但是这是有代价的， 一部分命令无法跨节点执行，比如 zunionstore 等一些命令，它涉及多个 key，因此在集群状态下，需要自行保证这些 key 都在一个 slot 上；&lt;/p>
&lt;p>再比如 watch exec， 在单节点或哨兵场景下可以用，但集群模式下是不能使用的。&lt;/p>
&lt;p>还有一些命令，在集群状态下虽能执行或有替代方案，但会丧失原子性。 比如 mget 等。&lt;/p>
&lt;p>所以楼主的疑问是为什么集群模式没有取代哨兵模式，是因为哨兵模式作为单节点+高可用的方案而言，确实有集群模式实现不了的功能。&lt;/p>
&lt;p>……想换行不小心发出去了。&lt;/p>
&lt;p>除了功能上的区别以外，集群模式显然比哨兵模式更重、需要更多的资源去运行；再就是部署运维复杂度也是更高的。&lt;/p>
&lt;p>而哨兵和单节点，一般来说除了配置稍有区别以外，绝大部分业务代码是可以相容的，无需特地修改。&lt;/p>
&lt;p>而现有的代码如果使用了集群模式不支持的那些命令，那么集群模式下是无法正常工作的。&lt;/p>
&lt;p>所以目前哨兵模式仍然被广泛使用，没有被集群模式彻底替代。&lt;/p>
&lt;p>我们公司就是用哨兵了。为什么不用 Cluster 。因为费钱。集群需要机器太多了。本身数据量就不大。分片功能不需要。 就只是想要一个高可用的 redis 。 用哨兵符合需求了。 只需要三台机器。而且三台机器还部署了 3 个 zookeeper 和 kafka 。都是数据量不大。 节约机器钱&lt;/p></description></item><item><title>Docs: 1.1.虚拟化</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/10.%E4%BA%91%E5%8E%9F%E7%94%9F/1.1.%E8%99%9A%E6%8B%9F%E5%8C%96/1.1.%E8%99%9A%E6%8B%9F%E5%8C%96/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/10.%E4%BA%91%E5%8E%9F%E7%94%9F/1.1.%E8%99%9A%E6%8B%9F%E5%8C%96/1.1.%E8%99%9A%E6%8B%9F%E5%8C%96/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/7/html/virtualization_getting_started_guide/index">RedHat 7 虚拟化入门指南&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/8/html/configuring_and_managing_virtualization/virtualization-in-rhel-8-an-overview_configuring-and-managing-virtualization#what-is-virtualization-in-rhel-8-virt-overview">Redhat 8 官方对虚拟化的定义&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/7/html/virtualization_getting_started_guide/index">RedHat 7 对“虚拟化性能不行”这个误区的辟谣&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://ubuntu.com/server/docs/virtualization-introduction">Ubuntu 官方文档，虚拟化-介绍&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>&lt;strong>Virtualization(虚拟化)&lt;/strong> 是用于运行软件的广义的计算机术语。通常情况下，&lt;strong>Virtualization(虚拟化)&lt;/strong> 体现在让单个可以运行多个操作系统，这些操作系统同时运行，而又是互相独立的。&lt;/p>
&lt;p>虚拟化是云计算的基础。简单的说，虚拟化使得在一台物理的服务器上可以跑多台虚拟机，虚拟机共享物理机的 CPU、内存、IO 硬件资源，但逻辑上虚拟机之间是相互隔离的。物理机我们一般称为 &lt;strong>Host(宿主机)&lt;/strong>，宿主机上面的虚拟机称为 &lt;strong>Guest(客户机)&lt;/strong>。那么 Host 是如何将自己的硬件资源虚拟化，并提供给 Guest 使用的呢？这个主要是通过一个叫做 Hypervisor 的程序实现的。&lt;/p>
&lt;h2 id="hypervisor">Hypervisor&lt;/h2>
&lt;p>参考：&lt;a href="https://www.redhat.com/zh/topics/virtualization/what-is-a-hypervisor">https://www.redhat.com/zh/topics/virtualization/what-is-a-hypervisor&lt;/a>&lt;/p>
&lt;p>Hypervisor 是用来创建与运行虚拟机的软件、固件或硬件。被 Hypervisor 用来运行一个或多个虚拟机的设备称为 Host Machine(宿主机)，这些虚拟机则称为 Guest Machine(客户机)。&lt;strong>Hypervisor 有时也被称为 Virtual Machine Monitor (虚拟机监视器，简称 VMM)&lt;/strong>&lt;/p>
&lt;h1 id="虚拟化技术的分类">虚拟化技术的分类&lt;/h1>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/ihdpea/1616124416735-5e89f29f-21cd-4fed-af5e-194227de3048.png" alt="">
根据 Hypervisor 的实现方式和所处的位置，虚拟化又分为两种：1 型虚拟化和 2 型虚拟化&lt;/p>
&lt;ol>
&lt;li>半虚拟化（para-virtualization）：TYPE1，也叫裸金属虚拟化比如 Vmware ESXi、Xen 等是一款类似于操作系统的 Hypervisor，直接运行在硬件之上，需要修改 Guest OS 的内核，让 VM 知道自己是虚拟机&lt;/li>
&lt;li>完全虚拟化（full-virtualization）：TYPE2，物理机上首先安装常规的操作系统，比如 Redhat、Ubuntu 和 Windows。Hypervisor 作为 OS 上的一个程序模块运行，并对管理虚拟机进行管理。比如 Vmware Workstation、KVM 等是一款类似于软件的 Hypervisor，运行于操作系统之上，VM 不知道自己是虚拟机
&lt;ol>
&lt;li>BT：软件，二进制翻译。性能很差&lt;/li>
&lt;li>HVM：硬件，硬件辅助的虚拟化。性能很好。现阶段 KVM 主要基于硬件辅助进行虚拟化
&lt;ol>
&lt;li>&lt;strong>硬件辅助全虚拟化主要使用了支持虚拟化功能的 CPU 进行支撑，CPU 可以明确的分辨出来自 GuestOS 的特权指令，并针对 GuestOS 进行特权操作，而不会影响到 HostOS。&lt;/strong>&lt;/li>
&lt;li>从更深入的层次来说，虚拟化 CPU 形成了新的 CPU 执行状态 —— _ Non-Root Mode&amp;amp; Root Mode_ 。从上图中可以看见，GuestOS 运行在 Non-Root Mode 的 Ring 0 核心态中，这表明 GuestOS 能够直接执行特却指令而不再需要 &lt;em>特权解除&lt;/em> 和 &lt;em>陷入模拟&lt;/em> 机制。并且在硬件层上面紧接的就是虚拟化层的 VMM，而不需要 HostOS。这是因为在硬件辅助全虚拟化的 VMM 会以一种更具协作性的方式来实现虚拟化 —— &lt;em>将虚拟化模块加载到 HostOS 的内核中&lt;/em>，例如：KVM，KVM 通过在 HostOS 内核中加载&lt;strong>KVM Kernel Module&lt;/strong>来将 HostOS 转换成为一个 VMM。所以此时 VMM 可以看作是 HostOS，反之亦然。这种虚拟化方式创建的 GuestOS 知道自己是正在虚拟化模式中运行的 GuestOS，KVM 就是这样的一种虚拟化实现解决方案。&lt;/li>
&lt;/ol>
&lt;/li>
&lt;/ol>
&lt;/li>
&lt;li>OS 级别虚拟化：容器级虚拟化，准确来说不能叫虚拟化了，只能叫容器技术无 Hypervisor，将用户空间分隔为多个，彼此互相隔离，每个 VM 中没有独立内核，OpenVZ、LXC(Linux container)、libcontainer 等，比如 Docker，Docker 的基础是 LXC。&lt;/li>
&lt;li>模拟(Emulation)：比如 QEMU，PearPC，Bochs&lt;/li>
&lt;li>库虚拟化：WINE&lt;/li>
&lt;li>应用程序虚拟化：JVM&lt;/li>
&lt;li>理论上 Type1 和 Typ2 之间的区别
&lt;ol>
&lt;li>1 型虚拟化一般对硬件虚拟化功能进行了特别优化，性能上比 2 型要高；&lt;/li>
&lt;li>2 型虚拟化因为基于普通的操作系统，会比较灵活，比如支持虚拟机嵌套。嵌套意味着可以在 KVM 虚拟机中再运行 KVM。&lt;/li>
&lt;/ol>
&lt;/li>
&lt;/ol>
&lt;h1 id="虚拟化总结云计算基础实现云功能的灵活调度">虚拟化总结(云计算基础，实现云功能的灵活调度)&lt;/h1>
&lt;p>所谓的云计算：当一台虚拟机需要跨越多个物理机进行数据交互，比如拿来运行 VM 的物理主机不止一台，在每台物理机上按需启动既定数量的 VM，每个 VM 有多少 CPU 和 MEM，每个 VM 启动在哪个物理机上，启动 VM 需要的存储设备在什么地方，存储设备中的系统是临时安装，还是通过一个已经装好的系统模板直接使用，还有多个 VM 跨物理主机进行网络通信等等一系列工作，可以使用一个虚拟化管理工具(VM Manager)来实现，这个管理器的功能即可称为云计算。在没有这个管理器的时候，人们只能人为手工从把 VM 从一台物理机移动到另一台物理机，非常不灵活。&lt;/p>
&lt;p>计算机五大部件：运算器(cpu)，控制器(cpu)，存储器(memory)，输入与输出设备(磁盘 I/O，网络 I/O)。&lt;/p>
&lt;p>一般情况，VM 的 CPU 与 Memory 无法跨主机使用；但是磁盘 I/O 与网络 I/O 则可以跨主机使用。云计算的灵活性（即 VM 或者单个云计算节点挂了但是不影响数据，可以重新启动在任一一个节点等类似的功能）&lt;/p>
&lt;p>磁盘 I/O 的灵活调度&lt;/p>
&lt;p>所以，在启动一个 VM 的时候，分为这么几个启动步骤，模拟 CPU 和内存，模拟存储，模拟网络。当在多个 node 的虚拟化集群中创建完一个 VM 并想启动的时候，又分为两种情况：&lt;/p>
&lt;ol>
&lt;li>当该 VM 的虚拟存储放在某个节点上的时候，则该 VM 只能启动在该节点上，因为没有存储就没法加载系统镜像，何谈启动呢&lt;/li>
&lt;li>当该 VM 的虚拟存储放在虚拟化集群的后端存储服务器或者共享存储空间的时候，则该 VM 可以根据调度策略在任一节点启动,然后把该 VM 对应的虚拟存储挂载或下载到需要启动的节点上即可（这个所谓的虚拟存储，可以称为模板，每次 VM 启动的时候，都可以通过这个模板直接启动而不用重新安装系统了）&lt;/li>
&lt;/ol>
&lt;p>这种可以灵活调度 VM，而不让 VM 固定启动在一个虚拟机上的机制，这就是云功能的基础，用户不用关心具体运行在哪个节点上，都是由系统自动调度的。&lt;/p>
&lt;p>网络 I/O 的灵活调度&lt;/p>
&lt;p>同样的，在一个 VM 从 node1 移动到 node2 的时候，除了存储需要跟随移动外，还需要网络也跟随移动，移动的前提是所有 node 的网络配置是一样的，不管是隔离模型，还是路由模型，还是 nat 模型，还是桥接模型，都需要给每个 node 进行配置，但是，会有这么几个情况，&lt;/p>
&lt;ol>
&lt;li>一个公司，有 2 个部门，有两台物理 server，node1 最多有 4 个 VM，node2 最多有 4 个 VM，其中一个部门需要 5 台 VM，另一个部门需要 3 台 VM，而两个部门又要完全隔离，这时候可以通过对 vSwitch 进行 vlan 划分来进行隔离，。这时候就一个开源的软件应运而生，就是 Open vSwtich，简称为 OVS。&lt;/li>
&lt;li>普通 VLAN 只有 4096 个，对于公有云来说，该 vlan 数量远远不够，这时候，vxlan 技术应运而生&lt;/li>
&lt;li>每个公司有多个部门,每个部门有的需要连接公网，有的不需要连接公网,如果想隔离开两个公司，仅仅依靠虚拟交换机从二层隔离，无法隔离全面，这时候 vRouter 虚拟路由器技术应运而生，通过路由来隔离，并通过路由来访问，而这台 vRouter 就是由 linux 的 net namespace 功能来创建的&lt;/li>
&lt;/ol>
&lt;p>Openstack 中创建的每个 network 就相当于一个 vSwitch，创建的每个 route 就相当于一个 vRoute 即 net namespace，然后把 network 绑定到 route 上，就相当于把 vSwitch 连接到了 vRoute，所以，在绑定完成之后，会在 route 列表中看到个端口的 IP，这个 IP 就是 vSwitch 子网(在创建 vSwitch 的时候会设置一个可用的网段)中的一个 IP，就相当于交换机连到路由器后，路由器上这个端口的 IP&lt;/p>
&lt;h1 id="实际上一个虚拟机就是宿主机上的一个文件虚拟化程序可以通过这个文件来运行虚拟机">实际上，一个虚拟机就是宿主机上的一个文件，虚拟化程序可以通过这个文件来运行虚拟机&lt;/h1></description></item><item><title>Docs: 1.2.Keepalived 配置详解</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/3.%E9%9B%86%E7%BE%A4%E4%B8%8E%E5%88%86%E5%B8%83%E5%BC%8F/keepalived/1.2.keepalived-%E9%85%8D%E7%BD%AE%E8%AF%A6%E8%A7%A3/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/3.%E9%9B%86%E7%BE%A4%E4%B8%8E%E5%88%86%E5%B8%83%E5%BC%8F/keepalived/1.2.keepalived-%E9%85%8D%E7%BD%AE%E8%AF%A6%E8%A7%A3/</guid><description>
&lt;h1 id="keepalived-使用">Keepalived 使用&lt;/h1>
&lt;p>keepalived 启动流程：&lt;/p>
&lt;ol>
&lt;li>
&lt;p>启动三个进程（主进程、healthcheck 进程、vrrp 进程）之后，先进入 backup 状态，运行一次 vrrp_script 成功后发现没有主，这时候会进入 master 状态，拉起 VIP，完成启动。 &lt;/p>
&lt;/li>
&lt;li>
&lt;p>切换的流程：&lt;/p>
&lt;/li>
&lt;li>
&lt;p>原 keepalived master 节点，运行检查脚本异常，则 keepalived 进入 FAULT 状态，释放 vip，原 backup 的 keepalived 会接管 VIP。 &lt;/p>
&lt;/li>
&lt;li>
&lt;p>注意事项：VIP 必须在 master 上。为了这个要求，需要在主库上先启动 keepalived。&lt;/p>
&lt;/li>
&lt;/ol>
&lt;h1 id="keepalived-配置">Keepalived 配置&lt;/h1>
&lt;p>/etc/sysconfig/keepalived #keepalived 运行时参数配置&lt;/p>
&lt;p>/etc/keepalived/keepalived.conf #keepalived 基本配置文件&lt;/p>
&lt;ol>
&lt;li>Note：keepalived 配置文件的运行时加载功能，可以通过命令 kill -HUP $(cat /var/run/keepalived.pid) 实现。该功能需要在 1.2.20 及以上版本才能实现&lt;/li>
&lt;/ol>
&lt;p>下面是一个基本的 keepalived.conf 文件的配置示例&lt;/p>
&lt;pre>&lt;code>! Configuration File for keepalived
global_defs { #全局配置段
notification_email {
admin@example. com
}
notification_email_from noreply@example.com
smtp_server 127.0.0.1
smtp_connect_timeout 60
router_id LVS_DEVEL
script_user root
}
vrrp_script chk_haproxy {
script &amp;quot;killall -0 haproxy&amp;quot;
interval 1
weight 2
}
vrrp_sync_group VG1 { #VRRP组配置段
group {
VI_1
VI_2
}
}
vrrp_instance VI_1 { #VRRP 实例VI_1配置段
state MASTER
interface eth0
virtual_router_id 50
priority 100
advert_int 1
authentication {
auth_type PASS
auth_pass password123
}
virtual_ipaddress {
10.0.0.1
}
track_script {
chk_haproxy
}
}
vrrp_instance VI_2 { #VRRP 实例VI_2配置段
state MASTER
interface eth1
virtual_router_id 2
priority 100
advert_int 1
authentication{
auth_type PASS
auth_pass password123
}
virtual_ipaddress {
192.168.1.1
}
notify_master &amp;quot;/etc/keepalived/notify.sh master&amp;quot; #定义该节点变为master后执行的脚本
notify_backup &amp;quot;/etc/keepalived/notify.sh backup&amp;quot; #定义该节点变为backup后执行的脚本
notify_fault &amp;quot;/etc/keepalived/notify.sh fault&amp;quot; #定义该节点变为fault后执行的脚本
}
virtual_server 10.0.0.1 80 { #虚拟服务器LVS 配置段
delay_loop 6
lvs_sched rr
lvs_method DR
protocol TCP
sorry_server 127.0.0.1 80
real_server 192.168.1.20 80 { #定义后端服务器1
XXX_CHECK {
connect timeout 10
}
}
real_server 192.168.1.21 80 { #定义后端服务器2
XXX_CHECK {
connect timeout 10
}
}
}
&lt;/code>&lt;/pre>
&lt;p>从 Keepalived 配置文件/etc/keepalived/keepalived.conf 中的内容可以看到， Keepalived 的配置主要分为三个模块， 即全局配置段、VRRP 定义段、虚拟服务器 LVS 配置段。&lt;/p>
&lt;p>配置文件 keywords(关键字) 详解&lt;/p>
&lt;p>注意：各个大版本之间的 keyword 有很大区别，名称以及所在位置都有区别，千万注意！！！！&lt;/p>
&lt;p>1.全局配置段&lt;/p>
&lt;p>全局配置段（ global_defs ）的主要作用之一就是 Keepalived 出现故障时的邮件通知管理员，让管理员以邮件形式知道 Keepalived 的运行情况。通常情况下，邮件通知不是必须的，用户可以选择其他监控方式来对 Keepalived 进行监控，如 Nagios。需要说明的是，全局配置段对 Keepalived 来说是可选的，其内容并不是 Keepalived 配置所必须的。全局配置段的几个主要配置参数说明如下：&lt;/p>
&lt;p>&lt;strong>global_defs&lt;/strong> #&lt;/p>
&lt;ul>
&lt;li>
&lt;p>Notification_email # 用于配置接收邮件的负载均衡器的管理员群组邮箱。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Notification_email_from # 自定义发出邮件的邮箱地址，即管理员邮件显示的发件人。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>SMTP # 指定简单邮件参数协议服务器地址，一般为本机。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>LVS_ID # LVS 负载均衡器标志，同一网络中其值唯一。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>script_user &lt;!-- raw HTML omitted -->&lt;/strong> # 指定 vrrp_script 定义的脚本&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>enable_script_security&lt;/strong> # 开启脚本安全&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>vrrp_script ScriptName { &amp;hellip; }&lt;/strong> # 定义检查脚本以便后面的 track_script 关键字来引用，若检查状态码为非 0 失败，则引用该脚本的 VRRP 变成 Fault 状态，若定义了 weight 字段且优先级比其余节点都低，则变为 Backup 状态&lt;/p>
&lt;ul>
&lt;li>
&lt;p>&lt;strong>script &amp;ldquo;/PATH/FILE&amp;rdquo;&lt;/strong> #定义需要执行的脚本或者需要执行的脚本的路径&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>interval&lt;/strong> #脚本调用间隔的秒数，默认 1 秒&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>timeout&lt;/strong> #定义调用失败多少秒后，确认该脚本失败&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>weight&lt;/strong> #脚本执行失败后，调整调用了该脚本的 vrrp 的优先级(priority)。i.e.降低或者提高优先级的数值，INTEGER 值为-254 到 254 之间&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>rise&lt;/strong> # 判断服务正常的检查次数，正常多少次，会进行状态转变&lt;/p>
&lt;/li>
&lt;li>
&lt;p>**fall **# 判断服务异常的检查次数，异常多少次，会进行状态转转变&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>user USERNAME [GROUPNAME]&lt;/strong> # 运行该脚本的用户&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>init_fail&lt;/strong> # 定义该脚本默认为失败状态&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>2. VRRP 配置段&lt;/p>
&lt;p>VRRP 配置段主要用于定义 VRRP 组，在 Keepalived 发生任何状态变化时，被定义在 VRRP 组中的 VRRP 实例作为逻辑整体一致行动，如在发生 LVS Router 故障切换 Failover 的过程中， VRRP 组中的实例会作为一致整体同时切换。在本节的演示配置中，同一个 VRRP 组内配置了两个 VRRP 实例，分别是针对外部网络的 VRRP_EXT 实例和针对内部私有网络的 VRRP_INT 实例。VRRP 配置段中的关键参数说明如下。&lt;/p>
&lt;p>&lt;strong>vrrp_sync_group {&amp;hellip;}&lt;/strong> # VRRP 实例一致组，用于定义 VRRP 一致组中的成员，组内的 VRRP 实例行为是一致的，如在 Failover 的时候， 一致组内的 VRRP 实例将同时迁移。在本机示例中，当 LBl 出现故障时， VRRP INT 和 VRRP EXT 实例将同时切换到 LB2 上。如果 不定义组，那么如果一台设备上有俩网卡的时候，只有一块网卡坏了的话，定义在另一块网卡上的 VRRP 则还在原来的设备上运行，无法自动切换到备用设备上。&lt;/p>
&lt;p>&lt;strong>vrrp_instance {&amp;hellip;}&lt;/strong> # VRRP 实例，用于配置一个 VRRP 服务进程实例，其中的 state 设定了当前节点 VRRP 实例的主备状态，在主 LVS Router 中，该值应该为 MASTER,在备 LVS Router 中，其值为 BACKUP 。正常情况下只有 Master 的 LVS Router 在工作， Backup 的 LVS Router 处于 Standby 状态。&lt;/p>
&lt;ul>
&lt;li>
&lt;p>&lt;strong>state&lt;/strong> # 当前节点的初始状态&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>interface&lt;/strong> # 对外提供服务的网络接口，如 eth0 和 eth1，选择服务接口时，一定要核实清楚，LV Router 的 VIP 将会配置到这个物理接口上。也可以配置多个实例在同一个网卡上，然后每个实例配置不同优先级，HOST1 上的实例 1 是主实例 2 是备，HOST2 上的实例 1 是备实例 2 是主，这样可以实现两台 HOST 双主模式负载均衡流量&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>virtual_Router_id&lt;/strong> # VRID，虚拟路由标志，同一个 VRRP 实例使用唯一的标识。即同一个 VRRP 实例中，MASTER 和 BACKUP 状态的 VRRP 实例中，VRID 值是相同的，同时在全部 VRRP 组内是唯一的。&lt;/p>
&lt;ul>
&lt;li>Note：如果在同网段有相同的 vrid 号，则 keepalived 会无限输出报错日志。使用 tcpdump -nn -i any net 224.0.0.0/8 |grep vrid 命令可以查到该网段都有哪些 vrid 号正在使用&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>priority&lt;/strong> # 此参数指明了该 VRRP 实例的优先级，数字越大说明优先级越高，取值范围为 0-255 ，在同一个 VRRP 实例里， MASTER 的优先级高于 BACKUP。若 MASTER 的 Priority 值为 100 ，那 BACKUP 的 Priority 只能是 99 或更小的数值。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>nopreempt&lt;/strong> # 开启非抢占模式。允许低优先级的节点保持 MASTER 角色，即使高优先级的节点从故障中恢复也是如此。i.e.不会触发选举过程。只有当前 BACKUP 节点 认为 MASTER 不存在时，才会重新选举。&lt;/p>
&lt;ul>
&lt;li>
&lt;p>Note：该模式会引发这个问题 Keepalived 非抢占模式 VIP 不漂移问题&lt;/p>
&lt;ul>
&lt;li>如果想要使用非抢占模式，主备的 keepalived 的 state 都不能是 MASTER。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>advert_int&lt;/strong> # Master 路由发送 VRRP 广播的时间间隔，单位为秒。默认为 1 秒&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>authentication {&amp;hellip;}&lt;/strong> # 包含验证类型和验证密码，类型主要有 PASS 和 AH 两种，通常使用的类型为 PASS 验证密码为明文，同一 VRRP 实例 MASTER 与 BACKUP 使用相同的密码才能正常通信。&lt;/p>
&lt;ul>
&lt;li>
&lt;p>&lt;strong>auth_type PASS|AH&lt;/strong> #认证类型。Note：只能是 PASS 或 AH 选项，不能写别的，否则报错：unknown authentication type &amp;rsquo;lvs'&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>auth_pass PASSWORD&lt;/strong> #认证的密码&lt;/p>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>virtual_ipaddress {IP}&lt;/strong> # 虚拟 IP 地址，即 VIP，可以有多个虚拟 IP 、地址，每个地址占一行，不需要指定子网掩码。作为 Standby 的负载均衡器，LB2 的 keepalived.conf 配置文件与 LB1 类似，其不同之处在于 VRRP 实例配置段中的的 VRRP 实例 State 和 Priority 参数的设置，如 LB1 中的 State 为 Master, LB2 中的 State 为 BACKUP ，并且 LB2 中 VRRP 实例的 Priority 必须小于 LB1 中的优先级。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>track_script {ScriptName}&lt;/strong> # 引用全局配置段中 vrrp_script 关键字的名为 ScriptName 的脚本&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>notify_master &amp;ldquo;/PATH/ScriptName ARGS&amp;rdquo;&lt;/strong> # 定义该节点变为 master 后执行的脚本&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>notify_backup &amp;ldquo;/PATH/ScriptName ARGS&amp;rdquo;&lt;/strong> # 定义该节点变为 backup 后执行的脚本&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>notify_fault &amp;ldquo;/PATH/ScriptName ARGS&amp;rdquo;&lt;/strong> # 定义该节点变为 fault 后执行的脚本&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>3. 虚拟服务器 LVS 配置段&lt;/p>
&lt;p>虚拟服务器（ Virtual Server ）配置段主要定义 LVS 的监昕虚拟 IP 地址和对应的后端服务器及其健康检测机制，虚拟服务器的定义段是 Keepalived 框架最重要的部分。此部分的定义主要分为一个 Virtual Server 的定义和多个 Real Servers 的定义， Virtual Server 由 VRRP 中定义的 VIP 加上端口号构成，而 Real Server 由后端服务器节点 IP 和端口号构成，相关的配置参数说明如下。&lt;/p>
&lt;p>&lt;strong>virtual_server {&amp;hellip;}&lt;/strong> # lvs 中调度器的配置&lt;/p>
&lt;ul>
&lt;li>
&lt;p>&lt;strong>delay_Loop NUM&lt;/strong> # 健康检查的时间间隔，单位为秒。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>lvs_sched&lt;/strong> # 指定负载均衡算法，示例中的 rr 表示 Round-Robin 轮询算法。(老版本的 keyword 为 lb_algo)&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>lvs_method&lt;/strong> # 采用的路由方法，示例中采用的是 DR 路由，还可以采用 NAT 和 TUN 路由。(老版本的 keyword 为 lb_kind)&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>persistence_timeout&lt;/strong> # 指定连接持久的超时时间。默认 6 分钟。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>**protocol **# 转发协议，一般有 TCP 和 UDP 两种。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>connect_timeout #连接超时时间。默认 5 秒。当 RS 检查失败 5 秒后，即判断该 RS 无响应，从 ipvs 组中踢出&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>retry&lt;/strong> # 重试次数。默认 1 次。当 RS 检查失败后，再次检查的次数。(老版本的 keyword 为 nb_get_retry)&lt;/p>
&lt;/li>
&lt;li>
&lt;p>delay_before_retry #失败后，让 RS 重新加回 ipvs 组重试的次数。默认 1 次。当 rs 检查 1 次成功后，就将该 RS 重新加入 ipvs 组&lt;/p>
&lt;/li>
&lt;li>
&lt;p>sorry_server :用于定义当后端所有 real server 挂掉后，使用哪台设备进行回应&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>real_server IP PORT {&amp;hellip;}&lt;/strong> # 后端服务器配置，i.e.lvs 中 RS 的配置&lt;/p>
&lt;ul>
&lt;li>
&lt;p>&lt;strong>CHECK {&amp;hellip;}&lt;/strong> # 指定健康检查的方式。TCP 就是测试目标端口通不通。HTTP 则是测试指定资源的响应码&lt;/p>
&lt;ul>
&lt;li>
&lt;p>可用的 CHECK 有如下几个，常用的标黄&lt;/p>
&lt;/li>
&lt;li>
&lt;p>HTTP_GET|SSL_GET|TCP_CHECK|SMTP_CHECK|DNS_CHECK|MISC_CHECK|BFD_CHECK|UDP_CHECK|PING_CHECK|FILE_CHECK&lt;/p>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h2 id="4-其他配置">4. 其他配置&lt;/h2>
&lt;p>&lt;strong>include &lt;!-- raw HTML omitted -->&lt;/strong> # 指定要包含的其他配置文件。FILE 可以用绝对路径，也可以使用通配符。指定的 FILE 中的内容将作为 keepalived 配置内容附加到主配置后面&lt;/p>
&lt;h2 id="检查脚本配置示例">检查脚本配置示例&lt;/h2>
&lt;ol>
&lt;li>定义脚本用于把 MASTER 节点的优先值降低 20，以实现主备切换，在指定目录中创建一个 down 文件，也可以使用别的判断方式&lt;/li>
&lt;/ol>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>vrrp_script chk_mantaince_down &lt;span style="color:#f92672">{&lt;/span> &lt;span style="color:#75715e">#配置一个名为chk_mantaince_down的脚本&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e"># 当某个文件存在时，权重减20&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> script &lt;span style="color:#e6db74">&amp;#34;[[ -f /etc/keepalived/down ]] &amp;amp;&amp;amp; exit 1 || exit 0&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> interval &lt;span style="color:#ae81ff">1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> weight -20
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ol>
&lt;li>
&lt;p>判断 nginx 进程是否存在，如果不存在则权重-2 使之变为 BACKUP&lt;/p>
&lt;p>vrrp_script chk_haproxy {&lt;/p>
&lt;h1 id="判断haproxy进程是否存在如果不存在则权重-2使之变为backup">判断haproxy进程是否存在，如果不存在则权重-2使之变为BACKUP&lt;/h1>
&lt;p>script &amp;ldquo;killall -0 haproxy&amp;rdquo; # 可以使用这个语句判断nginx，script &amp;ldquo;killall -0 nginx &amp;amp;&amp;gt; /dev/null&amp;rdquo;
interval 1 # 运行脚本的时间间隔
weight -2
}&lt;/p>
&lt;/li>
&lt;li>
&lt;p>引用脚本&lt;/p>
&lt;p>vrrp_instance VI_1 {
&amp;hellip;
track_script { # 在VRRP实例中引用哪些keepalived.conf中定义的脚本
chk_mantaince_down
}
notify_master &amp;ldquo;/etc/keepalived/notify.sh master&amp;rdquo; # 定义该节点变为master后执行的脚本
notify_backup &amp;ldquo;/etc/keepalived/notify.sh backup&amp;rdquo; # 定义该节点变为backup后执行的脚本
notify_fault &amp;ldquo;/etc/keepalived/notify.sh fault&amp;rdquo; # 定义该节点变为fault后执行的脚本
}&lt;/p>
&lt;/li>
&lt;/ol></description></item></channel></rss>