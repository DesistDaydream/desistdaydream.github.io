<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>断念梦 – 文档</title><link>https://desistdaydream.github.io/docs/</link><description>Recent content in 文档 on 断念梦</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><atom:link href="https://desistdaydream.github.io/docs/index.xml" rel="self" type="application/rss+xml"/><item><title>Docs: 📹11.多媒体</title><link>https://desistdaydream.github.io/docs/11.%E5%A4%9A%E5%AA%92%E4%BD%93/11.%E5%A4%9A%E5%AA%92%E4%BD%93/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/11.%E5%A4%9A%E5%AA%92%E4%BD%93/11.%E5%A4%9A%E5%AA%92%E4%BD%93/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Multimedia">Multimedia&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>&lt;strong>Multimedia(多媒体)&lt;/strong> 是一种通信形式，它使用不同的内容形式（例如&lt;a href="https://en.wikipedia.org/wiki/Text_(literary_theory)" title="文本（文学理论）">文本&lt;/a>、&lt;a href="https://en.wikipedia.org/wiki/Sound" title="声音">音频&lt;/a>、&lt;a href="https://en.wikipedia.org/wiki/Image" title="图像">图像&lt;/a>、&lt;a href="https://en.wikipedia.org/wiki/Animation" title="动画片">动画&lt;/a>或&lt;a href="https://en.wikipedia.org/wiki/Video" title="视频">视频）&lt;/a>组合成一个单一的交互式演示，这与传统的大众媒体（例如印刷材料或录音）不同，后者的功能很少用户之间没有交互。流行的多媒体示例包括视频播客、音频幻灯片和动画视频。多媒体还包含有效交互通信的原理和应用，例如软件、硬件和其他技术的构建块。多媒体的五个主要组成部分是文本、图像、音频、视频和动画。&lt;/p>
&lt;h1 id="名词解释">名词解释&lt;/h1>
&lt;p>帧&lt;/p>
&lt;p>帧宽度&lt;/p>
&lt;p>帧高度&lt;/p>
&lt;p>帧率&lt;/p>
&lt;p>编解码器&lt;/p>
&lt;p>帧总数&lt;/p>
&lt;p>格式&lt;/p>
&lt;p>模式&lt;/p>
&lt;p>亮度&lt;/p>
&lt;p>对比度&lt;/p>
&lt;p>饱和度&lt;/p>
&lt;p>色调&lt;/p>
&lt;p>增益&lt;/p>
&lt;p>曝光&lt;/p>
&lt;p>RGB&lt;/p>
&lt;p>白平衡&lt;/p>
&lt;p>矫正&lt;/p></description></item><item><title>Docs: 1.Bootloader</title><link>https://desistdaydream.github.io/docs/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/1.Bootloader/1.Bootloader/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/1.Bootloader/1.Bootloader/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Bootloader">Wiki,Bootloader&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>&lt;strong>Bootloader(引导加载程序)&lt;/strong> 是负责 &lt;a href="https://en.wikipedia.org/wiki/Booting">booting(引导)&lt;/a> 计算器的软件。通常也被称为 Bootstrap Loader、Bootstrap。&lt;/p>
&lt;p>当计算机关闭时，操作系统、应用程序代码和数据 ‍‌ 仍存储在非易失性存储器中。当计算机开机时，它通常没有操作系统或其随机存取存储器 (RAM) 中的加载程序。计算机首先执行存储在只读存储器（ROM，以及后来的 EEPROM、NOR 闪存）中的相对较小的程序以及一些需要的数据，以初始化 RAM（特别是在 x86 系统上），访问非易失性设备（通常是块设备，例如 NAND 闪存）或可以将操作系统程序和数据加载到 RAM 中的设备。&lt;/p>
&lt;h1 id="配置">配置&lt;/h1>
&lt;p>&lt;strong>/boot/*&lt;/strong> # 所有关于系统引导启动的配置信息，都在该目录下
&lt;strong>/boot/grub2/&lt;/strong> #
&lt;strong>/etc/default/grub&lt;/strong> #&lt;/p>
&lt;h1 id="引导管理命令行工具">引导管理命令行工具&lt;/h1>
&lt;p>grub2-*
grubby
grub2-mkconfig&lt;/p></description></item><item><title>Docs: 1.Linux Kernel</title><link>https://desistdaydream.github.io/docs/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2.Kernel%E5%86%85%E6%A0%B8/1.Linux-Kernel/1.Linux-Kernel/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2.Kernel%E5%86%85%E6%A0%B8/1.Linux-Kernel/1.Linux-Kernel/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://github.com/torvalds">Linus Torvalds&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://github.com/torvalds/linux">GitHub,Linux 内核项目&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.kernel.org/">官网&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.kernel.org/doc/html/latest/">官方文档&lt;/a>
&lt;ul>
&lt;li>&lt;a href="https://www.infradead.org/~mchehab/kernel_docs/index.html">https://www.infradead.org/~mchehab/kernel_docs/index.html&lt;/a> 这是哪里的官方文档？&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;a href="https://www.kernel.org/doc/man-pages/index.html">官方 Manual(手册)&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Kernel_(operating_system)">Wiki,Kernel&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki//boot/">Wiki,/boot&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Vmlinux">Wiki,vmlinux&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Initial_ramdisk">Wiki,Initial ramdisk&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/System.map">Wiki,System.map&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://github.com/raspberrypi/linux">树莓派 Linux&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/8/html/managing_monitoring_and_updating_the_kernel/index">RedHat 官方文档,8-管理、监控和更新内核&lt;/a>&lt;/li>
&lt;li>&lt;a href="http://www.linfo.org/vmlinuz.html">http://www.linfo.org/vmlinuz.html&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.zhihu.com/question/22045825">知乎,initrd 和 initramfs 的区别&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>&lt;strong>Kernel(内核)&lt;/strong> 是一个作为操作系统核心的计算机程序，对系统中的一切具有完全控制权。它负责管理系统的进程、内存、设备驱动程序、文件和网络系统，决定着系统的性能和稳定性。&lt;/p>
&lt;p>Kernel 是计算器启动时首先加载程序之一，在 &lt;a href="https://desistdaydream.github.io/docs/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/1.Bootloader/1.Bootloader.md">Bootloader&lt;/a>并处理硬件和软件之间的交互。并且处理启动过程的其余部分、以及内存、外设、和来自软件的输入/输出请求，将他们转换为 CPU 的数据处理指令。&lt;/p>
&lt;h2 id="kernel-组成及系统调用">Kernel 组成及系统调用&lt;/h2>
&lt;p>Linux 内核由如下几部分组成：内存管理、进程管理、设备驱动程序管理、文件系统管理、网络管理等。如图：
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/fkp6xi/1616168349819-c21dd43c-79b7-4ec2-abd4-c8bb0e3c7686.jpeg" alt="">
**System Call Interface(系统调用接口，简称 SCI)**层提供了某些机制执行从用户空间到内核的函数调用。这个接口依赖于体系结构，甚至在相同的处理器家族内也是如此。SCI 实际上是一个非常有用的函数调用多路复用和多路分解服务。&lt;/p>
&lt;p>系统调用介绍详见 &lt;a href="https://desistdaydream.github.io/docs/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2.Kernel(%E5%86%85%E6%A0%B8)/3.System%20Call/System%20Call.md">System Call(系统调用)&lt;/a> 章节&lt;/p>
&lt;h2 id="linux-man-手册使用说明">Linux man 手册使用说明&lt;/h2>
&lt;p>在 Linux Kernel 的官方 man 手册中，记录了用户空间程序使用 Linux 内核 和 C 库的接口。对于 C 库，主要聚焦于 GUN C(glibc)，尽管在已知的情况下，还包括可用于 Linux 的其他 C 库中的变体文档。在这个 man 手册中，分为如下几部分&lt;/p>
&lt;ul>
&lt;li>&lt;strong>&lt;a href="https://man7.org/linux/man-pages/dir_section_1.html">User commands&lt;/a>(用户命令)&lt;/strong> # 介绍一些用户空间的应用程序。&lt;/li>
&lt;li>&lt;strong>&lt;a href="https://man7.org/linux/man-pages/dir_section_2.html">System calls&lt;/a>(系统调用)&lt;/strong> # Linux Kernel 可以提供的所有 System Calls(系统调用)&lt;/li>
&lt;li>&lt;strong>&lt;a href="https://man7.org/linux/man-pages/dir_section_3.html">Library functions&lt;/a>(库函数)&lt;/strong> # C 标准库可以提供的函数。&lt;/li>
&lt;li>&lt;strong>&lt;a href="https://man7.org/linux/man-pages/dir_section_4.html">Devices&lt;/a>(设备)&lt;/strong> # 各种设备的详细信息，这些设备大多都在 /dev 目录中。&lt;/li>
&lt;li>&lt;strong>&lt;a href="https://man7.org/linux/man-pages/dir_section_5.html">Files&lt;/a>(文件)&lt;/strong> # 各种文件格式和文件系统&lt;/li>
&lt;li>&lt;strong>&lt;a href="https://man7.org/linux/man-pages/dir_section_7.html">Overviews, conventions, and miscellaneous&lt;/a>(概述、约定 和 其他)&lt;/strong> #&lt;/li>
&lt;li>&lt;strong>&lt;a href="https://man7.org/linux/man-pages/dir_section_8.html">Superuser and system administration commands&lt;/a>(超级用户和系统管理员命令)&lt;/strong> # 介绍一些 GUN C 库提供的程序。&lt;/li>
&lt;/ul>
&lt;p>在 Linux man 手册中，可以找到 Linux 系统中的一切使用说明。Linux 操作系统围绕 Linux Kernel 构建了一套高效、健壮的应用程序运行环境&lt;/p>
&lt;h1 id="intirdimgvmlinuzsystemmap-文件">intird.img、vmlinuz、System.map 文件&lt;/h1>
&lt;p>Kernel 会被安装到 /boot 目录中，并生成 &lt;strong>config、initrd.img、System.map、vmlinuz&lt;/strong> 这几个文件&lt;/p>
&lt;h2 id="vmlinuz">vmlinuz&lt;/h2>
&lt;p>vmlinuz 是 &lt;a href="http://www.linfo.org/linuxdef.html">Linux&lt;/a> &lt;a href="http://www.linfo.org/kernel.html">内核&lt;/a> 可执行文件的名称。&lt;/p>
&lt;p>vmlinuz 是一个压缩的 Linux 内核，它是_可引导的_。可引导意味着它能够将操作系统加载到内存中，以便计算机变得可用并且可以运行应用程序。&lt;/p>
&lt;p>vmlinuz 不应与_vmlinux_混淆，后者是非压缩和不可引导形式的内核。vmlinux 通常只是生成 vmlinuz 的中间步骤。&lt;/p>
&lt;p>vmlinuz 位于 /boot 目录中，该目录包含开始引导系统所需的文件。名为 vmlinuz 的文件可能是实际的内核可执行文件本身，也可能是内核可执行文件的链接，该链接可能带有诸如 &lt;code>/boot/vmlinuz-2.4.18-19.8.0&lt;/code> 之类的名称（即特定内核的名称）内核版本）。这可以通过使用 ls &lt;a href="http://www.linfo.org/command.html">命令&lt;/a>（其目的是列出指定目录的内容）及其 -l 选项（它告诉 ls 提供有关指定目录中每个对象的详细信息）来轻松确定，如下所示：&lt;/p>
&lt;blockquote>
&lt;p>&lt;code>ls -l /boot&lt;/code>&lt;/p>
&lt;/blockquote>
&lt;p>如果 vmlinuz 是一个普通文件（包括可执行文件），则第一列中有关它的信息将以连字符开头。如果是链接，它将以字母_l_开头。
通过发出以下命令   来_编译_Linux 内核：&lt;/p>
&lt;blockquote>
&lt;p>&lt;code>make bzImage&lt;/code>&lt;/p>
&lt;/blockquote>
&lt;p>这会在 /usr/src/linux/arch/i386/linux/boot/ 等目录中创建名为_bzImage_的文件。&lt;/p>
&lt;p>编译是将内核的&lt;a href="http://www.linfo.org/source_code.html">&lt;em>源代码&lt;/em>&lt;/a>（即内核由人类编写的原始形式）转换为_目标代码_（计算机处理器可以直接理解）。它由称为&lt;a href="http://www.linfo.org/compiler.html">&lt;em>编译器&lt;/em>&lt;/a>的专门程序执行，通常是&lt;a href="http://www.linfo.org/gcc.html">&lt;em>GCC&lt;/em>&lt;/a>（&lt;a href="http://www.linfo.org/gnu.html">GNU&lt;/a>编译器集合）中的一个。&lt;/p>
&lt;p>然后使用 _cp &lt;em>命令将 bzImage 复制到 /boot 目录，同时使用诸如以下命令   重命名_vmlinuz&lt;/em>&lt;/p>
&lt;blockquote>
&lt;p>&lt;code>cp /usr/src/linux/arch/i386/linux/boot/bzImage /boot/vmlinuz&lt;/code>&lt;/p>
&lt;/blockquote>
&lt;p>vmlinuz 不仅仅是一个压缩图像。它还内置了_gzip_解压缩器代码。gzip 是&lt;a href="http://www.linfo.org/unix-like.html">类 Unix&lt;/a>操作系统上最流行的压缩实用程序之一。&lt;/p>
&lt;p>一个名为_zImage_文件的编译内核是在一些较旧的系统上创建的，并保留在较新的系统上以实现向后兼容性。zImage 和 bzImage 都是用 gzip 压缩的。区别在于 zImage 解压到_低内存_（即前 640kB），bzImage 解压到_高内存_（1MB 以上）。有一个常见的误解，认为 bzImage 是使用_bzip2_实用程序压缩的。实际上，&lt;em>b_只代表_big&lt;/em>。&lt;/p>
&lt;p>&lt;em>vmlinuz&lt;/em> 这个名字很大程度上是历史的偶然。在贝尔实验室开发的原始 UNIX 上的内核二进制文件称为_unix_。当后来在加州大学伯克利分校 (UCB) 编写包含支持&lt;a href="http://www.linfo.org/virtual_memory.html">&lt;em>虚拟内存&lt;/em>&lt;/a>的新内核时，内核二进制文件更名为_vmunix_。&lt;/p>
&lt;p>虚拟内存是使用硬盘驱动器 (HDD) 上的空间来模拟额外的 RAM（随机存取内存）容量。与当时使用的其他一些流行操作系统（例如&lt;a href="http://www.linfo.org/ms-dos.html">MS-DOS）&lt;/a>相比，Linux 内核几乎从 Linux 一开始就支持它。&lt;/p>
&lt;p>因此，Linux 内核很自然地被称为_vmlinux_。由于 Linux 内核可执行文件被制作成压缩文件，并且压缩文件在类 Unix 系统上通常具有_z_或_gz_扩展名，因此压缩内核可执行文件的名称变为_vmlinuz_。&lt;/p>
&lt;h2 id="initrd">initrd&lt;/h2>
&lt;p>&lt;strong>Initial RAM Disk(初始内存磁盘，简称 initrd)&lt;/strong> 是一种将临时根文件系统加载到内存中的方案，可以作为 Linux 启动过程的一部分。有两种方法来实现这种方案：&lt;/p>
&lt;ul>
&lt;li>&lt;strong>initrd # Initial RAM Disk。&lt;/strong> 就是把一块内存（ram）当做磁盘（disk）去挂载，然后找到 ram 里的 init 执行。&lt;/li>
&lt;li>&lt;strong>initramfs # Initial RAM Filesystem。&lt;/strong> 直接在 ram 上挂载文件系统，执行文件系统中的 init。&lt;/li>
&lt;/ul>
&lt;p>这两者通常用于在挂载真正的根文件系统之前执行一些准备工作。&lt;/p>
&lt;blockquote>
&lt;p>不要被文件名迷惑，kernel 2.6 以来都是 initramfs 了，只是很多还沿袭传统使用 initrd 的名字
initramfs 的工作方式更加简单直接一些，启动的时候加载内核和 initramfs 到内存执行，内核初始化之后，切换到用户态执行 initramfs 的程序/脚本，加载需要的驱动模块、必要配置等，然后加载 rootfs 切换到真正的 rootfs 上去执行后续的 init 过程。
initrd 是 2.4 及更早的用法（现在你能见到的 initrd 文件实际差不多都是 initramfs 了），运行过程大概是内核启动，执行一些 initrd 的内容，加载模块啥的，然后交回控制权给内核，最后再切到用户态去运行用户态的启动流程。
从格式看，老的 initrd 是一个压缩的内存文件系统，具体是啥忘了，年月太久了。现在的 initramfs 是一个 gzip 压缩的 cpio 文件系统打包，如果遇到什么紧急情况需要处理的时候，你可以建立一个临时目录，把 initramfs 解压之后，直接 cpio -idv 解压出来，改之后再用 cpio 和 gzip 封上即可。虽然大家都喜欢用 tar 打包，但掌握点 cpio 在关键时刻还是可以救命的。&lt;/p>
&lt;/blockquote>
&lt;p>在早期的 Linux 系统中，一般就只有软盘或者硬盘被用来作为 Linux 的根文件系统，因此很容易把这些设备的驱动程序集成到内核中。但是现在根文件系统可能保存在各种存储设备上，包括 SCSI、SATA、U 盘等等。总不能每出一个，就要重新编译一遍内核吧？~这样不但麻烦，也不实用，所以后来 Linux 就提供了一个灵活的方法来解决这些问题。就是 &lt;strong>initrd&lt;/strong>。&lt;/p>
&lt;blockquote>
&lt;p>可以把 initrd 当做 WinPE。当使用 WinPE 启动后会发现你的计算机就算没有硬盘也能在正常运行，其中有个文件系统 B:/ 分区，这个分区就是内存模拟的磁盘。&lt;/p>
&lt;/blockquote>
&lt;p>initrd.img 文件就是个 ram disk 的映像文件。ramdisk 是用一部分内存模拟成磁盘，让操作系统访问。ram disk 是标准内核文件认识的设备(/dev/ram0)文件系统也是标准内核认识的文件系统。内核加载这个 ram disk 作为根文件系统并开始执行其中的&amp;quot;某个文件&amp;quot;（2.6 内核是 init 文件）来加载各种模块，服务等。经过一些配置和运行后，就可以去物理磁盘加载真正的 root 分区了，然后又是一些配置等，最后启动成功。&lt;/p>
&lt;p>也就是你只需要定制适合自己的 initrd.img 文件就可以了。这要比重编内核简单多了，省时省事低风险。&lt;/p>
&lt;h3 id="查看-initrd-文件">查看 initrd 文件&lt;/h3>
&lt;p>我们可以通过如下方式，解压出 initrd.img 文件，下面分别以 Ubuntu 20.04 TLS 系统和 CentOS Stream 8 系统为例：&lt;/p>
&lt;blockquote>
&lt;p>解压方法来源：&lt;a href="https://unix.stackexchange.com/questions/163346/why-is-it-that-my-initrd-only-has-one-directory-namely-kernel">https://unix.stackexchange.com/questions/163346/why-is-it-that-my-initrd-only-has-one-directory-namely-kernel&lt;/a>&lt;/p>
&lt;/blockquote>
&lt;p>Ubuntu 20.04 TLS&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>root@lichenhao:~/test_dir# mkdir -p /root/test_dir/root
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>root@lichenhao:~/test_dir# cp /boot/initrd.img /root/test_dir/
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>root@lichenhao:~/test_dir/root# &lt;span style="color:#f92672">(&lt;/span>cpio -id; cpio -i; unlz4 | cpio -id&lt;span style="color:#f92672">)&lt;/span> &amp;lt; ../initrd.img
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">62&lt;/span> blocks
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">9004&lt;/span> blocks
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">450060&lt;/span> blocks
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>root@lichenhao:~/test_dir/root# ls
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>bin conf cryptroot etc init kernel lib lib32 lib64 libx32 run sbin scripts usr var
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>CentOS Stream 8&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">[&lt;/span>root@master-2 root&lt;span style="color:#f92672">]&lt;/span>&lt;span style="color:#75715e"># mkdir -p /root/test_dir/root&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">[&lt;/span>root@master-2 root&lt;span style="color:#f92672">]&lt;/span>&lt;span style="color:#75715e"># cp /boot/initramfs-4.18.0-294.el8.x86_64.img /root/test_dir&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">[&lt;/span>root@master-2 root&lt;span style="color:#f92672">]&lt;/span>&lt;span style="color:#75715e"># cd /root/test_dir/root&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">[&lt;/span>root@master-2 root&lt;span style="color:#f92672">]&lt;/span>&lt;span style="color:#75715e"># (cpio -id; zcat | cpio -id) &amp;lt; ../initramfs-4.18.0-294.el8.x86_64.img&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">[&lt;/span>root@master-2 root&lt;span style="color:#f92672">]&lt;/span>&lt;span style="color:#75715e"># ls&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>bin dev early_cpio etc init kernel lib lib64 proc root run sbin shutdown sys sysroot tmp usr var
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>可以看到，initrd.img 中包含了一个系统最基本的目录结构&lt;/p>
&lt;h1 id="kernel-关联文件">Kernel 关联文件&lt;/h1>
&lt;p>&lt;strong>/boot/*&lt;/strong> #&lt;/p>
&lt;ul>
&lt;li>&lt;strong>./config-$(uname -r)&lt;/strong> # Kernel 的扩展配置文件。Kernel 文档中，将该文件称为 &lt;strong>Boot Configuration&lt;/strong>。&lt;/li>
&lt;li>&lt;strong>./initrd.img&lt;/strong> # 在内核挂载真正的根文件系统前使用的临时文件系统&lt;/li>
&lt;li>&lt;strong>./vmlinuz&lt;/strong> # Linux 内核&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>/etc/sysctl.conf&lt;/strong> # 系统启动时读取的内核参数文件&lt;/p>
&lt;ul>
&lt;li>&lt;strong>/etc/sysctl.d/*&lt;/strong> # 系统启动时时读取的内核参数目录&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>/usr/lib/sysctl.d/*&lt;/strong> #&lt;/p>
&lt;p>&lt;strong>/proc/sys/*&lt;/strong> # 内核参数(也称为内核变量)所在路径。该目录(从 1.3.57 版本开始)包含许多与内核变量相对应的文件和子目录。 可以使用 &lt;a href="https://www.yuque.com/go/doc/33222789">proc 文件系统&lt;/a> 以及 sysctl(2) 系统读取或加载这些变量，有时可以对其进行修改。&lt;/p></description></item><item><title>Docs: 12.人工智能</title><link>https://desistdaydream.github.io/docs/12.%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/12.%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/12.%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/12.%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Artificial_intelligence">Wiki，Artificial_intelligence&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>&lt;strong>Artificial intelligence(人工智能，简称 AI)&lt;/strong> 是机器所展示的智能，与人类和其他动物的智能相对应。AI 通常包含语音识别、&lt;a href="https://desistdaydream.github.io/docs/12.%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89.md">计算机视觉&lt;/a>、&lt;a href="https://desistdaydream.github.io/docs/12.%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/%E8%87%AA%E7%84%B6%E8%AF%AD%E8%A8%80%E5%A4%84%E7%90%86/%E8%87%AA%E7%84%B6%E8%AF%AD%E8%A8%80%E5%A4%84%E7%90%86.md">自然语言处理&lt;/a>、以及其他输入的映射&lt;/p>
&lt;p>随着机器的能力越来越强，被认为需要“智能”的任务通常从 AI 的定义中删除，这种现象被称为 AI 效应。例如，&lt;a href="https://desistdaydream.github.io/docs/12.%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89/OCR.md">OCR&lt;/a> 经常被排除在被认为是人工智能的事物之外，已成为一项常规技术。&lt;/p>
&lt;p>TODO,名词解释：&lt;/p>
&lt;ul>
&lt;li>拟合&lt;/li>
&lt;li>回归&lt;/li>
&lt;li>Embedding&lt;/li>
&lt;/ul>
&lt;p>AI 好像不等于机器。。不像机器精确执行 01 指令。。AI 的本质好像是数学，并且是数学中的统计学，AI 的每一次判断都是一次概率统计然后输出概率大的内容。&lt;/p>
&lt;h2 id="人工智能发展阶段">人工智能发展阶段&lt;/h2>
&lt;p>&lt;a href="https://zhuanlan.zhihu.com/p/24811027">https://zhuanlan.zhihu.com/p/24811027&lt;/a>&lt;/p>
&lt;p>&lt;strong>运算智能、感知智能、认知智能&lt;/strong>&lt;/p>
&lt;p>&lt;strong>一是运算智能&lt;/strong>，即快速计算和记忆存储能力。人工智能所涉及的各项技术的发展是不均衡的。现阶段计算机比较具有优势的是运算能力和存储能力。1996年IBM的深蓝计算机战胜了当时的国际象棋冠军卡斯帕罗夫，从此，人类在这样的强运算型的比赛方面就不能战胜机器了。&lt;/p>
&lt;p>&lt;strong>二是感知智能&lt;/strong>，即视觉、听觉、触觉等感知能力。人和动物都具备，能够通过各种智能感知能力与自然界进行交互。自动驾驶汽车，就是通过激光雷达等感知设备和人工智能算法，实现这样的感知智能的。机器在感知世界方面，比人类还有优势。人类都是被动感知的，但是机器可以主动感知，如：激光雷达、微波雷达和红外雷达。不管是Big Dog这样的感知机器人，还是自动驾驶汽车，因为充分利用了DNN和大数据的成果，机器在感知智能方面已越来越接近于人类。&lt;/p>
&lt;ul>
&lt;li>早期的计算机视觉属于感知智能，只能认识图片，而无法知道图片中所表达的意思。&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>三是认知智能&lt;/strong>。通俗讲是“能理解会思考”。人类有语言，才有概念，才有推理，所以概念、意识、观念等都是人类认知智能的表现。典型的自然语言处理，就需要认知智能。&lt;/p>
&lt;ul>
&lt;li>第一层是语言理解&lt;/li>
&lt;li>第二层是分析、推理&lt;/li>
&lt;li>第三层是人格和情感&lt;/li>
&lt;/ul>
&lt;h2 id="技术脉络关系">技术脉络关系&lt;/h2>
&lt;p>个人总结：&lt;/p>
&lt;p>如果人工智能的本质是数学计算，那么首先出现的是辅助计算的工具，比如 NumPy、Torch，然后利用这些计算能力，发展出让机器学习的工具，TensorFlow、PyTorch 等，最后通过机器学习，训练出来可用的各种基本模型，比如 Transformer。&lt;/p>
&lt;ul>
&lt;li>NumPy、Torch 提供计算能力&lt;/li>
&lt;li>TensorFlow、PyTorch 依赖计算能力实现的用于机器学习的框架&lt;/li>
&lt;li>Transformer 使用学习框架生成模型，Transformer 一般是指一个过程、工具集，而不是单指一种模型，很多模型是通过 Transformer 工具使用或训练。&lt;/li>
&lt;/ul>
&lt;h1 id="机器学习">机器学习&lt;/h1>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/ai/20230524101934.png" alt="image.png">&lt;/p>
&lt;p>&lt;a href="https://desistdaydream.github.io/docs/12.%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0.md">机器学习&lt;/a>源于对 AI 的探索。在人工智能作为一门学科的早期，一些研究人员对让机器从数据中学习很感兴趣。他们试图用各种符号方法以及当时称为“神经网络”的方法来解决这个问题。&lt;/p>
&lt;p>后来，机器学习更多的依赖&lt;a href="https://desistdaydream.github.io/docs/12.%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E6%A8%A1%E5%9E%8B.md">&lt;strong>模型&lt;/strong>&lt;/a>。&lt;/p>
&lt;h1 id="agi">AGI&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Artificial_general_intelligence">WIki，Artificial_general_intelligence&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>&lt;strong>Artificial General Intelligence(通用人工智能，简称 AGI)&lt;/strong> 是一种假设的&lt;a href="https://en.wikipedia.org/wiki/Intelligent_agent" title="智能代理">智能体&lt;/a>，它可以理解或学习&lt;a href="https://en.wikipedia.org/wiki/Human_intelligence" title="人类智慧">人类&lt;/a>或&lt;a href="https://en.wikipedia.org/wiki/Animal_cognition" title="动物认知">其他动物&lt;/a>可以完成的任何智力任务。&lt;/p>
&lt;h1 id="aigc">AIGC&lt;/h1>
&lt;p>&lt;strong>Artificial Inteligence Generated Content(人工智能生产内容，简称 AIGC)&lt;/strong>&lt;/p>
&lt;p>&lt;strong>NovelAI&lt;/strong> # &lt;a href="https://novelai.net/">https://novelai.net/&lt;/a> 写故事、作图&lt;/p>
&lt;p>&lt;strong>ChatGPT&lt;/strong> # &lt;a href="https://chat.openai.com/">https://chat.openai.com/&lt;/a>&lt;/p>
&lt;p>&lt;strong>Bard&lt;/strong>，google # &lt;a href="https://bard.google.com/">https://bard.google.com/&lt;/a>&lt;/p>
&lt;p>&lt;strong>Claude&lt;/strong>，Anthropic # 在 Slack 中创建名为 Claude 的应用。&lt;/p>
&lt;p>&lt;strong>文心一言&lt;/strong>，百度 # &lt;a href="https://yiyan.baidu.com/">https://yiyan.baidu.com/&lt;/a>&lt;/p>
&lt;p>&lt;strong>通义千问&lt;/strong>，阿里 # &lt;a href="https://tongyi.aliyun.com/">https://tongyi.aliyun.com/&lt;/a>&lt;/p>
&lt;h1 id="ai-公司">AI 公司&lt;/h1>
&lt;p>OpenAI&lt;/p>
&lt;p>Anthropic&lt;/p>
&lt;p>MiniMax # 北京稀宇科技有限公司。官网神秘未知。WPS AI 使用该公司的模型&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://www.glowapp.tech/">https://www.glowapp.tech/&lt;/a>&lt;/li>
&lt;/ul>
&lt;p>Runway &lt;a href="https://runwayml.com/">https://runwayml.com/&lt;/a>&lt;/p>
&lt;ul>
&lt;li>Gen-2 多模态 AI 模型，支持文本生成视频、图像生成视频、视频生成视频&lt;/li>
&lt;/ul>
&lt;h1 id="学习资料">学习资料&lt;/h1>
&lt;h2 id="b-站">B 站&lt;/h2>
&lt;p>&lt;a href="https://www.bilibili.com/list/group/210003/421004">科技区官方账号，AIGC 合集&lt;/a>&lt;/p>
&lt;p>NLP 入门的，不知道谁录的课，有多个 UP 投稿&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://www.bilibili.com/video/BV1WG411G7mr">https://www.bilibili.com/video/BV1WG411G7mr&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.bilibili.com/video/BV1RY4y1P7Lc">https://www.bilibili.com/video/BV1RY4y1P7Lc&lt;/a>&lt;/li>
&lt;/ul>
&lt;p>唐宇迪&lt;/p>
&lt;ul>
&lt;li>这哥们在 B 站一堆账号。。。o(╯□╰)o&lt;/li>
&lt;li>&lt;a href="https://space.bilibili.com/1232212952">https://space.bilibili.com/1232212952&lt;/a>&lt;/li>
&lt;li>好像没一个真的，知乎好像是有说明： &lt;a href="https://www.zhihu.com/question/277554784/answer/2253481966">https://www.zhihu.com/question/277554784/answer/2253481966&lt;/a>
&lt;ul>
&lt;li>知乎这个看着像真的，他说自己不在 B 站发视频 &lt;a href="https://www.zhihu.com/people/tangyudi/answers">https://www.zhihu.com/people/tangyudi/answers&lt;/a>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h1 id="待总结名词">待总结名词&lt;/h1>
&lt;p>Embedding&lt;/p>
&lt;h1 id="分类">分类&lt;/h1>
&lt;p>#人工智能&lt;/p></description></item><item><title>Docs: 2.Kernel(内核)</title><link>https://desistdaydream.github.io/docs/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2.Kernel%E5%86%85%E6%A0%B8/Kernel%E5%86%85%E6%A0%B8/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2.Kernel%E5%86%85%E6%A0%B8/Kernel%E5%86%85%E6%A0%B8/</guid><description>
&lt;h2 id="操作系统-os-与内核-kernel-有什么区别">操作系统 OS 与内核 Kernel 有什么区别？&lt;/h2>
&lt;p>原文链接：&lt;a href="https://mp.weixin.qq.com/s/-5tDn2-IS6Xo6DwQJN4c3Q">https://mp.weixin.qq.com/s/-5tDn2-IS6Xo6DwQJN4c3Q&lt;/a>&lt;/p>
&lt;p>&lt;strong>通用底盘技术&lt;/strong>&lt;/p>
&lt;p>Canoo 公司有一项核心技术专利，这就是它们的通用电动底盘技术，长得是这个样子，非常像一个滑板：&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/egzxwb/1624588718457-99ed8a8e-d53b-465e-8d99-4345935ad5a4.webp" alt="">&lt;/p>
&lt;p>这个带轮子、有电池、能动的滑板已经包含了一辆车&lt;strong>最核心&lt;/strong>的组件，差的就是一个外壳。这个看起来像滑板的东西就是所谓的电池系统和底盘一体化技术，Canoo 公司在它们的通用底盘上加装不同的外壳就能制造出不同的车型。&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/egzxwb/1624588718511-01fe725d-cd0d-48d1-a4e8-1010d7d5a69b.png" alt="">&lt;/p>
&lt;h5 id="什么是内核">&lt;strong>什么是内核？&lt;/strong>&lt;/h5>
&lt;p>在上面这个示例中，&lt;strong>包含轮子以及电池系统的底盘就好比内核，而套上外壳加上椅子以及内饰后的整体成品就好比操作系统&lt;/strong>。内核仅仅是操作系统的一部分，是真正与硬件交互的那部分软件，与硬件交互包括读写硬盘、读写网盘、读写内存以及任何连接到系统中的硬件。除了与硬件交互外，内核还负责分配资源，分配什么资源呢？所谓资源就是硬件，比如 CPU 时间、内存、IO 等等，这些都是资源。&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/egzxwb/1624588718454-36e25783-bbc0-49ec-a620-26d8580cee9d.png" alt="">&lt;/p>
&lt;p>因此，内核的职责就是以进程的形式来分配 CPU 时间，以虚拟内存的形式来分配物理内存，以文件的形式来管理 IO 设备。&lt;/p>
&lt;h5 id="什么是操作系统">&lt;strong>什么是操作系统？&lt;/strong>&lt;/h5>
&lt;p>然而只有一个内核实际上是做不了什么真正有用的事情，就像上面示例中那个通用底盘一样，这个底盘确实能跑起来，但你没办法开着这样一个底盘出去浪，因为这个底盘很难用。因此，你不得不加装上方向盘、座椅以及车身外壳等，同样的道理，内核是给人用的，为了与内核交互，发明了命令行以及图形界面 GUI。&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/egzxwb/1624588718509-9945a71c-556e-4b5a-be9f-8a123c68473c.png" alt="">&lt;/p>
&lt;p>在 Windows 平台就是给程序员提供编程接口的是 Windows API，这层 API 包罗万象，不但包括上文提到对系统调用的封装，还包括其它功能，像创建带有图形界面的应用程序等等。&lt;strong>但在 Linux 世界你找不到一种类似 Windows API 的东西&lt;/strong>，毕竟 Windows 是微软自家产品，什么都可以打包起来，Linux 只是一个开源的内核，如果一定要找一个类似的东西话那就是 libc，也就是 C 标准库，这里同样包括了对系统调用的封装以及一些库函数，但 libc 不包含创建带有图形界面应用程序的功能。现在我们知道了，操作系统需要提供两种接口：&lt;/p>
&lt;ul>
&lt;li>给用户提供操作接口。&lt;/li>
&lt;li>给程序员提供编程接口。&lt;/li>
&lt;/ul>
&lt;p>这些就是好比汽车的外壳，我们(用户和程序员)看得见摸得着，外壳加上底盘——也就是内核，才是功能完善的操作系统。&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/egzxwb/1624588718491-8aabc98e-8938-4b52-95fd-265d5f7d95b8.webp" alt="">&lt;/p>
&lt;h5 id="各种各样的操作系统">&lt;strong>各种各样的操作系统&lt;/strong>&lt;/h5>
&lt;p>实际上我们熟悉的 Linux 只是内核而不能称得上是操作系统，Ubuntu 则可以认为是操作系统，其内核是 Linux；RedHat 也是操作系统，其内核同样是 Linux；我们可以看到，尽管 Ubuntu 和 RedHat 是不同的操作系统，但其内核可以是相同的。这就好比它们可以基于同样的底盘打造出不同的车型。而我们熟悉的 Windows 也是操作系统，其内核是 Windows NT 内核。&lt;/p>
&lt;h5 id="总结">&lt;strong>总结&lt;/strong>&lt;/h5>
&lt;p>内核就像本文开头提到的电动底盘，包含了一个汽车的最核心元素；但这样一个底盘并没有什么实际用处，当搭配上外壳以及座椅后才是一辆真正有用的车，这就好比操作系统。值得注意的是，不同的操作系统可以有相同的内核。&lt;/p>
&lt;h1 id="宏内核与微内核">宏内核与微内核&lt;/h1>
&lt;p>原文链接：&lt;a href="https://mp.weixin.qq.com/s/jIuLkapBssGnBn1IoIdWQQ">公众号-码农的荒岛求生，操作系统的实现：什么是宏内核、微内核&lt;/a>&lt;/p>
&lt;h2 id="大一统全部运行在内核态">大一统，全部运行在内核态&lt;/h2>
&lt;p>&lt;strong>最简单的划分就是没有划分&lt;/strong>，我们可以把所有内核代码放在内核态，内核中的任何代码都拥有控制硬件的全部特权，显然这种设计方法非常简单，因为操作系统设计者不用费心去想哪一部分该放在内核态。&lt;/p>
&lt;p>由于全部内核程序都运行在内核态，编译好的内核程序就是一个单独的二进制可执行文件，这时的操作系统运行起来后就是一个大进程，所有内核代码运行在一个单独的地址空间中，这和我们实现的稍微复杂的单进程应用程序类似，这种大一统的设计就是所谓的宏内核，monolithic kernel，个人认为叫“一体化内核”更形象些。&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/egzxwb/1650439475125-4fe94b34-90ba-43d8-8a9b-3c5860730e20.png" alt="">&lt;/p>
&lt;p>这种组织方式和 TCP/IP 协议栈的分层实现有点类似。&lt;/p>
&lt;p>现在内核代码已经组织好了，毕竟内核是为上层应用提供服务的，那么上层应用该怎样调用内核代码呢？这就是系统调用的作用，system call。&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/egzxwb/1650439474086-a1f789d1-05e4-4c7c-9c39-d6274ac2b0aa.png" alt="">&lt;/p>
&lt;p>上层应用程序通过系统调用与内核进行交互。&lt;/p>
&lt;p>由于内核代码唯一同一个地址空间中，因此内核中各部分的交互极为简单，就是普通的函数调用，文件系统中的某块 cache 可以非常容易的被虚拟内存系统共享使用。&lt;/p>
&lt;p>但宏内核也是有缺点的，由于内核代码位于同一个地址空间，代码趋于复杂化，复杂就容易出错，但内核和普通程序不同，一旦内核中某一模块出现 bug 将导致整个内核崩溃，底层的内核崩溃后上层的应用程序就无法继续正常推进，整个系统就下图一样。。crash&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/egzxwb/1650439474129-b3976f1b-3567-4d8a-b82d-2e5fd9e647cd.gif" alt="">&lt;/p>
&lt;p>当然也有人不在乎在这一点，Linus 认为内核中有 bug 正常，&lt;strong>有 bug 就找到它、修复它而不是用某种机制试图忽略它&lt;/strong>，没错，C++中的异常就是试图忽略 bug 的机制，这就是为什么很多公司的规范中禁止使用异常的原因。&lt;/p>
&lt;p>总之，内核崩溃后就必须重启计算机。&lt;/p>
&lt;h4 id="heading">&lt;/h4>
&lt;h2 id="保留核心非必要不留在内核">保留核心，非必要不留在内核&lt;/h2>
&lt;p>为减少内核崩溃的风险，一个简单的办法就是让内核尽量精简，只保留核心部分运行在内核态，其它代码以用户态进程的形式运行，就像这样：&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/egzxwb/1650439474079-a7429422-8348-4fe1-b423-79e30fe7763d.png" alt="">&lt;/p>
&lt;p>运行在用户态的操作系统程序被称为 server，像负责文件操作的 File Server 等，此时用户进程想要使用操作系统提供的服务的话就必须借助进程间通信，inter-process communication，即 IPC，借助内核，消息从一个进程发送到另一个进程然后等待返回。&lt;/p>
&lt;p>这样，内核只需要对上层应用提供一些简单的接口即可，像创建进程、发送消息等，这种实现方式可以让内核尽可能简单，因为大部分内核程序都运行在用户态，且运行在不同的地址空间中，此时设备驱动中的 bug 不会影响到内核，这种操作系统的实现方式就被称为微内核， micro kernel。&lt;/p>
&lt;p>就像宏内核那样，微内核也有自己的缺点，那就是性能。由于宏内核的代码都在同一个地址空间中，因此模块间的交互可以非常简单，简单的函数调用即可，但模块间交互对微内核来说则可能涉及进程间通信，看上图，如果某个应用程序需要请求使用 File Server，这条链路涉及到：&lt;/p>
&lt;pre>&lt;code>请求：应用程序 -&amp;gt; 内核 -&amp;gt; File server
返回：Filer server -&amp;gt; 内核 -&amp;gt; 应用程序
&lt;/code>&lt;/pre>
&lt;p>每一个&amp;quot;-&amp;gt;&amp;ldquo;都涉及上下文切换，而这对宏内核来说则简单很多。&lt;/p>
&lt;h4 id="heading-1">&lt;/h4>
&lt;p>&lt;strong>现实中是什么样子？&lt;/strong>&lt;/p>
&lt;p>现实的操作系统中两种实现方式都很常见，Linux 以及许多 Unix 就是典型的宏内核，而 Mac OS X 以及 Windows NT 则一般认为是微内核，华为的鸿蒙 Harmony OS 则宣传是微内核。&lt;/p></description></item><item><title>Docs: 3.Pod 集群最小的工作单元</title><link>https://desistdaydream.github.io/docs/10.%E4%BA%91%E5%8E%9F%E7%94%9F/2.3.Kubernetes-%E5%AE%B9%E5%99%A8%E7%BC%96%E6%8E%92%E7%B3%BB%E7%BB%9F/3.Pod-%E9%9B%86%E7%BE%A4%E6%9C%80%E5%B0%8F%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8D%95%E5%85%83/3.Pod-%E9%9B%86%E7%BE%A4%E6%9C%80%E5%B0%8F%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8D%95%E5%85%83/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/10.%E4%BA%91%E5%8E%9F%E7%94%9F/2.3.Kubernetes-%E5%AE%B9%E5%99%A8%E7%BC%96%E6%8E%92%E7%B3%BB%E7%BB%9F/3.Pod-%E9%9B%86%E7%BE%A4%E6%9C%80%E5%B0%8F%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8D%95%E5%85%83/3.Pod-%E9%9B%86%E7%BE%A4%E6%9C%80%E5%B0%8F%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8D%95%E5%85%83/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://kubernetes.io/docs/concepts/workloads/pods/">官方文档,概念-工作负载-Pods&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>Pod 是 Kubernetes 的&lt;strong>最小工作单元&lt;/strong>，是一个逻辑概念。Kubernetes 真正处理的，还是通过 CRI 在 HostOS 上的 Namespace 和 Cgroups。所谓的 Pod 只是一组共享了某些资源的 Container，这一组 Container 共享同一个 NetworkNamespace 并且可以声明共享同一个 Volume。&lt;/p>
&lt;p>&lt;strong>Infrastructure(基础设施，简称 Infra) 容器&lt;/strong>：为了保证多个 Container 在共享的时候是对等关系(一般情况可以先启动 ContainerA，再启动 ContainerB 并共享 ContainerA 的资源，但是这样 A 与 B 不对等，A 是必须先启动才能启动 B)，需要一个中间 Container，即 &lt;strong>Infra 容器&lt;/strong>，Infra 容器 永远是第一个被创建的 Container，想要共享某些资源的 Container 则通过加入 NetworkNamespce 的方式，与 Infra 容器 关联在一起。效果如图&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/iogldt/1616119861463-06b2877d-519d-43a9-a6e4-6fc743d6ee30.jpeg" alt="">&lt;/p>
&lt;ul>
&lt;li>Infra 类型的 Container 使用一个名为 pause 的镜像，就像它的名字一样，永远处于&amp;quot;暂停&amp;quot;状态&lt;/li>
&lt;li>Kubernetes 为每个 Pod 都附属了 k8s.gcr.ip/pause，这个 Container 只接管 Pod 的网络信息，业务 Container 通过加入网络 Container 的网络来实现网络共享。此容器随着 pod 创建而创建，随着 Pod 删除而删除。该容器是对业务 pod 的命名空间的解析。Note：如果想要更改该容器，则需要在 kubelet 中使用&amp;ndash;pod-infra-container-image 参数进行配置&lt;/li>
&lt;li>与 Infra 关联的 Container 的所有 NetworkNamespace 必然是完全一样的。&lt;/li>
&lt;li>该链接有一种详细的解释&lt;/li>
&lt;li>Note：对于 kubelet 来说，这种容器称为 Sandbox。每次 kubelet 创建 pod 时，首先创建的也是 sandbox(i.e.pause)容器&lt;/li>
&lt;/ul>
&lt;p>一组 Container 共享 Infra 的 NetworkNamespace 意味着：&lt;/p>
&lt;ul>
&lt;li>它们可以直接使用 localhost 进行通信&lt;/li>
&lt;li>它们看到的网络设备跟 Infra 容器中看到的完全一样&lt;/li>
&lt;li>一个 Pod 只能有有一个 IP 地址，就是这个 Pod 的 NetworkNamespace 对应的 IP 地址&lt;/li>
&lt;li>Pod 的生命周期只跟 Infra 容器一致，同与 Infra 关联的所有 Container 无关&lt;/li>
&lt;li>Pod 中的所有 Container 的进出流量都是通过 Infra 容器完成的，所以网络插件不必关心除 Infra 以外的容器的启动与否，只需关注如何配置 Pod(也就是 Infra 容器的 NetworkNamespace)即可&lt;/li>
&lt;/ul>
&lt;p>每个 Pod 包含一个或多个容器。Pod 中的容器会作为一个整体被 Master 调度到一个 Node 上运行。&lt;/p>
&lt;p>如果把 Pod 想象成一台&amp;quot;服务器&amp;quot;，把 Container 想象成运行在这台服务器中的&amp;quot;用户程序&amp;quot;&lt;/p>
&lt;ul>
&lt;li>凡是调度、网络、存储、以及安全相关的字段，基本都是 Pod 级别的，比如：&lt;/li>
&lt;li>配置这台&amp;quot;服务器&amp;quot;的网卡(Pod 的网络)、配置这台“服务器”的磁盘(Pod 的存储，Volume)、配置这台”服务器“的防火墙(Pod 中的安全)、配置这台”服务器“运行在哪个机房(Pod 的调度)&lt;/li>
&lt;li>凡是资源配额、所要使用的 port、探测该进程是否存活或就绪、需要使用&amp;quot;服务器&amp;quot;上的哪块 Volume 等等字段，都是 Container 级别的&lt;/li>
&lt;/ul>
&lt;h2 id="kubernetes-引入-pod-主要基于下面两个目的">Kubernetes 引入 Pod 主要基于下面两个目的&lt;/h2>
&lt;ul>
&lt;li>可管理性。
&lt;ul>
&lt;li>有些 Container 天生就是需要紧密联系，一起工作。Pod 提供了比容器更高层次的抽象，将它们封装到一个部署单元中。Kubernetes 以 Pod 为最小单位进行调度、扩展、共享资源、管理生命周期。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>通信和资源共享。
&lt;ul>
&lt;li>Pod 中的所有 Container 使用同一个网络 namespace，即相同的 IP 地址和 Port 空间。它们可以直接用 localhost 通信。同样的，这些 Container 可以共享存储，当 Kubernetes 挂载 volume 到 Pod，本质上是将 volume 挂载到 Pod 中的每一个 Container。user,mnt,pnt。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>使用户从传统虚拟机环境向容器环境迁移更加平滑，可以把 Pod 想象成 VM，Pod 中的 Container 是 VM 中的进程，甚至可以启动一个 systemd 的 Container&lt;/li>
&lt;li>还可以把 Pod 理解为传统环境中的物理主机&lt;/li>
&lt;/ul>
&lt;h2 id="container-设计模式">Container 设计模式&lt;/h2>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/iogldt/1616119861478-cf678269-344a-4932-8448-c9eee14a8438.png" alt="">&lt;/p>
&lt;ul>
&lt;li>&lt;strong>sidecar&lt;/strong> #(该英文的解释“跨斗”：一辆小而低的车辆，安装在摩托车旁边，用于载客，就像右图中的样子)，所以该模式就类似于这个，指可以再一个 Pod 中启动一个辅助 Container，来完成一些独立于主进程(主 Container)之外的工作。
&lt;ul>
&lt;li>比如 Container 的日志收集：现在有一个 APP，需要不断把日志文件输出到 Container 的/var/log 目录中。这时，把一个 Pod 里的 Volume 挂载到应用 Container 的/var/log 目录上，然后在 Pod 中同时运行一个 sidecar 的 Container 也声明挂载同一个 Volume 到自己的/var/log 目录上，然后 sidecar 只需要不断得从自己的/var/log 目录里读取日志文件，转发到 MongoDB 或者 Elasticsearch 中存储起来即可。&lt;/li>
&lt;li>Istio 项目也是使用 sidecar 模式的 Container 完成微服务治理的原理。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h2 id="pod-的类型">Pod 的类型&lt;/h2>
&lt;ul>
&lt;li>动态 Pod：由 k8s 管理，网络组件，监控，等等，这些在 使用 kubeadm 初始化集群后才创建的 Pod 为动态 Pod&lt;/li>
&lt;li>静态 Pod：由 kubelet 直接管理的，在 /etc/kubernetes/manifest/ 目录下的 yaml 文件&lt;/li>
&lt;/ul>
&lt;h1 id="pod-使用方式">Pod 使用方式&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://kubernetes.io/docs/concepts/workloads/pods/init-containers/">官方文档，概念-工作敷在-Pod-初始化容器&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://kubernetes.io/docs/concepts/workloads/pods/ephemeral-containers/">官方文档，概念-工作负载-Pod-临时容器&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;ul>
&lt;li>运行单一 Container。
&lt;ul>
&lt;li>one-container-per-Pod 是 Kubernetes 最常见的模型，这种情况下，只是将单个 Container 简单封装成 Pod。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>运行多个 Container。
&lt;ul>
&lt;li>这些 Container 联系必须非常紧密，而且需要直接共享资源的应该放到一个 Pod 中(注意：当使用多 Container 的时候，其中一个 Container 要加上 command 的参数，否则其中一个起不来。因为 container 如果不执行某些命令，则启动后会自动结束，详见 docker 说明 1.LXC 与 Docker 入门最佳实践.note 里《Dokcer 的工作模式》章节)&lt;/li>
&lt;li>比如：File Puller 会定期从外部的 Content Manager 中拉取最新的文件，将其存放在共享的 volume 中。Web Server 从 volume 读取文件，响应 Consumer 的请求。这两个容器是紧密协作的，它们一起为 Consumer 提供最新的数据；同时它们也通过 volume 共享数据。所以放到一个 Pod 是合适的。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>在 Pod 中，可运行的容器分为三类：&lt;/p>
&lt;ul>
&lt;li>&lt;strong>ephemeral_container(临时容器)&lt;/strong> # 与 1.23 版本进入 beta，用来调试集群&lt;/li>
&lt;li>&lt;strong>init_container(初始化容器)&lt;/strong> # 在应用容器启动前运行一次就结束的，常用来为容器运行初始化运行环境，比如设置权限等等&lt;/li>
&lt;li>&lt;strong>application_container(应用容器)&lt;/strong> # 真正运行业务的容器。&lt;/li>
&lt;/ul>
&lt;p>这三类容器，可以在 kubelet 代码中找到运行逻辑，详见 [《kubelet 源码解析-PodWorker 模块》](/docs/10.云原生/2.3.Kubernetes%20 容器编排系统/Kubernetes%20 开发/源码解析/Kubelet%20 源码/PodWorker%20 模块.md 开发/源码解析/Kubelet 源码/PodWorker 模块.md)&lt;/p>
&lt;h2 id="ephemeral_container临时容器">ephemeral_container(临时容器)&lt;/h2>
&lt;h2 id="init_container初始化容器">init_container(初始化容器)&lt;/h2>
&lt;p>Pod 能够具有多个容器，应用运行在容器里面，但是它也可能有一个或多个先于应用容器启动的 Init 容器。Init 容器在所有容器运行之前执行（run-to-completion），常用来初始化配置。&lt;/p>
&lt;p>如果为一个 Pod 指定了多个 Init 容器，那些容器会按顺序一次运行一个。 每个 Init 容器必须运行成功，下一个才能够运行。 当所有的 Init 容器运行完成时，Kubernetes 初始化 Pod 并像平常一样运行应用容器。&lt;/p>
&lt;p>下面是一个 Init 容器的示例：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-yaml" data-lang="yaml">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">apiVersion&lt;/span>: &lt;span style="color:#ae81ff">v1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">kind&lt;/span>: &lt;span style="color:#ae81ff">Pod&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">metadata&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">name&lt;/span>: &lt;span style="color:#ae81ff">init-demo&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">spec&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">containers&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#f92672">name&lt;/span>: &lt;span style="color:#ae81ff">nginx&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">image&lt;/span>: &lt;span style="color:#ae81ff">nginx&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">ports&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#f92672">containerPort&lt;/span>: &lt;span style="color:#ae81ff">80&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">volumeMounts&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#f92672">name&lt;/span>: &lt;span style="color:#ae81ff">workdir&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">mountPath&lt;/span>: &lt;span style="color:#ae81ff">/usr/share/nginx/html&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e"># These containers are run during pod initialization&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">initContainers&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#f92672">name&lt;/span>: &lt;span style="color:#ae81ff">install&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">image&lt;/span>: &lt;span style="color:#ae81ff">busybox&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">command&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#ae81ff">wget&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#e6db74">&amp;#34;-O&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#e6db74">&amp;#34;/work-dir/index.html&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#ae81ff">http://kubernetes.io&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">volumeMounts&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#f92672">name&lt;/span>: &lt;span style="color:#ae81ff">workdir&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">mountPath&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;/work-dir&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">dnsPolicy&lt;/span>: &lt;span style="color:#ae81ff">Default&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">volumes&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#f92672">name&lt;/span>: &lt;span style="color:#ae81ff">workdir&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">emptyDir&lt;/span>: {}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>因为 Init 容器具有与应用容器分离的单独镜像，使用 init 容器启动相关代码具有如下优势：&lt;/p>
&lt;ul>
&lt;li>它们可以包含并运行实用工具，出于安全考虑，是不建议在应用容器镜像中包含这些实用工具的。&lt;/li>
&lt;li>它们可以包含使用工具和定制化代码来安装，但是不能出现在应用镜像中。例如，创建镜像没必要 FROM 另一个镜像，只需要在安装过程中使用类似 sed、 awk、 python 或 dig 这样的工具。&lt;/li>
&lt;li>应用镜像可以分离出创建和部署的角色，而没有必要联合它们构建一个单独的镜像。&lt;/li>
&lt;li>它们使用 Linux Namespace，所以对应用容器具有不同的文件系统视图。因此，它们能够具有访问 Secret 的权限，而应用容器不能够访问。&lt;/li>
&lt;li>它们在应用容器启动之前运行完成，然而应用容器并行运行，所以 Init 容器提供了一种简单的方式来阻塞或延迟应用容器的启动，直到满足了一组先决条件。&lt;/li>
&lt;/ul>
&lt;p>Init 容器的资源计算，选择一下两者的较大值：&lt;/p>
&lt;ul>
&lt;li>所有 Init 容器中的资源使用的最大值&lt;/li>
&lt;li>Pod 中所有容器资源使用的总和&lt;/li>
&lt;/ul>
&lt;p>Init 容器的重启策略：&lt;/p>
&lt;ul>
&lt;li>如果 Init 容器执行失败，Pod 设置的 restartPolicy 为 Never，则 pod 将处于 fail 状态。否则 Pod 将一直重新执行每一个 Init 容器直到所有的 Init 容器都成功。&lt;/li>
&lt;li>如果 Pod 异常退出，重新拉取 Pod 后，Init 容器也会被重新执行。所以在 Init 容器中执行的任务，需要保证是幂等的。&lt;/li>
&lt;/ul>
&lt;h2 id="container容器--也称为-application_container应用容器">container(容器) # 也称为 application_container(应用容器)&lt;/h2>
&lt;h1 id="pod-名字的命名规范">Pod 名字的命名规范&lt;/h1>
&lt;p>一般情况都不会直接使用 Pod，而是通过 &lt;a href="https://desistdaydream.github.io/docs/10.%E4%BA%91%E5%8E%9F%E7%94%9F/2.3.Kubernetes%20%E5%AE%B9%E5%99%A8%E7%BC%96%E6%8E%92%E7%B3%BB%E7%BB%9F/4.Controller(%E6%8E%A7%E5%88%B6%E5%99%A8)/4.Controller(%E6%8E%A7%E5%88%B6%E5%99%A8).md">Controller(控制器)&lt;/a> 来创建。通过 Controller 创建一个 POD 的流程为，以及 POD 名字的命名方式每个对象的命名方式是：子对象的名字 = 父对象名字 + 随机字符串或数字。如图所示&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/iogldt/1616119861434-f2c4735b-c549-40a4-ab70-67217755ed3f.png" alt="">&lt;/p>
&lt;ul>
&lt;li>用户通过 kubectl 创建 Deployment。&lt;/li>
&lt;li>Deployment 创建 ReplicaSet。&lt;/li>
&lt;li>ReplicaSet 创建 Pod。&lt;/li>
&lt;/ul></description></item><item><title>Docs: 3.System Call</title><link>https://desistdaydream.github.io/docs/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2.Kernel%E5%86%85%E6%A0%B8/3.System-Call/System-Call/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2.Kernel%E5%86%85%E6%A0%B8/3.System-Call/System-Call/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://man7.org/linux/man-pages/man2/syscalls.2.html">Manual(手册)，syscalls(2)&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/System_call">Wiki,System_call&lt;/a>&lt;/li>
&lt;li>&lt;a href="http://arthurchiao.art/blog/system-call-definitive-guide-zh/">http://arthurchiao.art/blog/system-call-definitive-guide-zh/&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>&lt;strong>System Call(系统调用，简称 syscall)&lt;/strong> 是 Application(应用程序) 和 Linux Kernel(内核) 之间的基本接口。是操作内核的唯一入口。其实，所谓 syscall 就是各种编程语言中的 &lt;strong>Function(函数)&lt;/strong> 概念。一个 syscall 也有名称、参数、返回值。syscall 即可以是名词，用来描述一个具体的 syscall；也可以是动词，用来表示某物调用了某个 syscall。当用户进程需要发生系统调用时，CPU 通过软中断切换到内核态开始执行内核系统调用函数。&lt;/p>
&lt;blockquote>
&lt;p>syscall 还有另一种意思，是一种编程方式，比如我们常说的 API，就是 syscall 的一种实现。但是通常意义的 API 不包含权限的转变，而普通程序进行系统调用时，会涉及到权限的转变。&lt;/p>
&lt;/blockquote>
&lt;p>在 &lt;a href="https://man7.org/linux/man-pages/man2/syscalls.2.html#DESCRIPTION">syscalls(2) 手册中的 System call list 章节&lt;/a>可以看到 Linux 可用的完整的 syscall 列表。也就是说所有 Kernel 暴露出来的可供用户调用的 Function。&lt;/p>
&lt;h2 id="用户程序内核和-cpu-特权级别">用户程序、内核和 CPU 特权级别&lt;/h2>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/bbar3l/1616168230254-e3c38b73-8092-41bd-a17d-d3c4768de743.jpeg" alt="">&lt;/p>
&lt;p>用户程序（例如编辑器、终端、ssh daemon 等）需要和 Linux 内核交互，内核代替它们完 成一些它们自身无法完成的操作。&lt;/p>
&lt;p>例如，如果用户程序需要做 IO 操作（open、read、write 等），或者需要修改它的 内存地址（mmpa、sbrk 等），那它必须触发内核替它完成。&lt;/p>
&lt;p>为什么禁止用户程序做这些操作呢？&lt;/p>
&lt;p>因为 x86-64 CPU 有一个特权级别 （privilege levels）的概念。这个概念很复杂，完全可以单独写一篇博客。 出于本文讨论目的，我们将其（大大地）简化为如下：&lt;/p>
&lt;ol>
&lt;li>特权级别是权限控制的一种方式。当前的特权级别决定了允许执行哪些 CPU 指令和操作&lt;/li>
&lt;li>内核运行在最高级别，称为 “Ring 0”；用户程序运行在稍低的一个级别，一般称作 “Ring 3”&lt;/li>
&lt;/ol>
&lt;ul>
&lt;li>内核空间（Ring 0）具有最高权限，可以直接访问所有资源；&lt;/li>
&lt;li>用户空间（Ring 3）只能访问受限资源，不能直接访问内存等硬件设备，必须通过系统调用陷入到内核中，才能访问这些特权资源。&lt;/li>
&lt;/ul>
&lt;p>用户程序要进行特权操作必须触发一次特权级别切换（从 “Ring 3” 到 “Ring 0”）， 由内核（替它）执行。触发特权级别切换有多种方式，我们先从最常见的方式开始：中断。&lt;/p>
&lt;h1 id="interrupts中断">Interrupts(中断)&lt;/h1>
&lt;p>详见：[Interrupts(中断) 概念详解](/docs/1.操作系统/2.Kernel(内核)/4.CPU%20 管理/Interrupts(中断).md 管理/Interrupts(中断).md)&lt;/p>
&lt;h1 id="syscall-的方式">syscall 的方式&lt;/h1>
&lt;p>通过 glibc 提供的库函数&lt;/p>
&lt;p>glibc 是 Linux 下使用的开源的标准 C 库，它是 GNU 发布的 libc 库，即运行时库。glibc 为程序员提供丰富的 API，除了例如字符串处理、数学运算等用户态服务之外，最重要的是封装了操作系统提供的系统服务，即系统调用的封装。那么 glibc 提供的系统调用 API 与内核特定的系统调用之间的关系是什么呢？&lt;/p>
&lt;ul>
&lt;li>通常情况，每个特定的系统调用对应了至少一个 glibc 封装的库函数，如系统提供的打开文件系统调用 sys_open 对应的是 glibc 中的 open 函数；&lt;/li>
&lt;li>其次，glibc 一个单独的 API 可能调用多个系统调用，如 glibc 提供的 printf 函数就会调用如 sys_open、sys_mmap、sys_write、sys_close 等等系统调用；&lt;/li>
&lt;li>另外，多个 API 也可能只对应同一个系统调用，如 glibc 下实现的 malloc、calloc、free 等函数用来分配和释放内存，都利用了内核的 sys_brk 的系统调用。&lt;/li>
&lt;/ul>
&lt;p>举例来说，我们通过 glibc 提供的 chmod 函数来改变文件 etc/passwd 的属性为 444&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-c" data-lang="c">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#include&lt;/span> &lt;span style="color:#75715e">&amp;lt;sys/types.h&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#include&lt;/span> &lt;span style="color:#75715e">&amp;lt;sys/stat.h&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#include&lt;/span> &lt;span style="color:#75715e">&amp;lt;errno.h&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#include&lt;/span> &lt;span style="color:#75715e">&amp;lt;stdio.h&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> rc;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> rc &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#a6e22e">chmod&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;/etc/passwd&amp;#34;&lt;/span>, &lt;span style="color:#ae81ff">0444&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (rc &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#f92672">-&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">fprintf&lt;/span>(stderr, &lt;span style="color:#e6db74">&amp;#34;chmod failed, errno = %d&lt;/span>&lt;span style="color:#ae81ff">\n&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>, errno);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">else&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">printf&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;chmod success!&lt;/span>&lt;span style="color:#ae81ff">\n&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>在普通用户下编译运用，输出结果为：&lt;/p>
&lt;p>&lt;code>chmod failed, errno = 1&lt;/code>&lt;/p>
&lt;p>上面系统调用返回的值为-1，说明系统调用失败，错误码为 1，在 /usr/include/asm-generic/errno-base.h 文件中有如下错误代码说明：&lt;/p>
&lt;p>&lt;code>#define EPERM 1 /* Operation not permitted */&lt;/code>&lt;/p>
&lt;p>即无权限进行该操作，我们以普通用户权限是无法修改 /etc/passwd 文件的属性的，结果正确。&lt;/p>
&lt;h2 id="使用指定的-syscallname-直接调用">使用指定的 SyscallName 直接调用&lt;/h2>
&lt;p>使用上面的方法有很多好处，首先你无须知道更多的细节，如 chmod 系统调用号，你只需了解 glibc 提供的 API 的原型；其次，该方法具有更好的移植性，你可以很轻松将该程序移植到其他平台，或者将 glibc 库换成其它库，程序只需做少量改动。&lt;/p>
&lt;p>但有点不足是，如果 glibc 没有封装某个内核提供的系统调用时，我就没办法通过上面的方法来调用该系统调用。如我自己通过编译内核增加了一个系统调用，这时 glibc 不可能有你新增系统调用的封装 API，此时我们可以利用 glibc 提供的 syscall 函数直接调用。该函数定义在 unistd.h 头文件中，函数原型如下：&lt;/p>
&lt;p>long int syscall (long int sysno, &amp;hellip;)&lt;/p>
&lt;ul>
&lt;li>sysno 是系统调用号，每个系统调用都有唯一的系统调用号来标识。在 sys/syscall.h 中有所有可能的系统调用号的宏定义。&lt;/li>
&lt;li>&amp;hellip; 为剩余可变长的参数，为系统调用所带的参数，根据系统调用的不同，可带 0~5 个不等的参数，如果超过特定系统调用能带的参数，多余的参数被忽略。&lt;/li>
&lt;li>返回值 该函数返回值为特定系统调用的返回值，在系统调用成功之后你可以将该返回值转化为特定的类型，如果系统调用失败则返回 -1，错误代码存放在 errno 中。&lt;/li>
&lt;/ul>
&lt;p>还以上面修改 /etc/passwd 文件的属性为例，这次使用 syscall 直接调用：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-c" data-lang="c">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#include&lt;/span> &lt;span style="color:#75715e">&amp;lt;stdio.h&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#include&lt;/span> &lt;span style="color:#75715e">&amp;lt;unistd.h&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#include&lt;/span> &lt;span style="color:#75715e">&amp;lt;sys/syscall.h&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#include&lt;/span> &lt;span style="color:#75715e">&amp;lt;errno.h&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">int&lt;/span> rc;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> rc &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#a6e22e">syscall&lt;/span>(SYS_chmod, &lt;span style="color:#e6db74">&amp;#34;/etc/passwd&amp;#34;&lt;/span>, &lt;span style="color:#ae81ff">0444&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">if&lt;/span> (rc &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#f92672">-&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">fprintf&lt;/span>(stderr, &lt;span style="color:#e6db74">&amp;#34;chmod failed, errno = %d&lt;/span>&lt;span style="color:#ae81ff">\n&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>, errno);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">else&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">printf&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;chmod succeess!&lt;/span>&lt;span style="color:#ae81ff">\n&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>在普通用户下编译执行，输出的结果与上例相同。&lt;/p>
&lt;h2 id="通过-syscall-间接调用">通过 syscall() 间接调用&lt;/h2>
&lt;h2 id="通过-int-指令陷入">通过 int 指令陷入&lt;/h2>
&lt;p>如果我们知道系统调用的整个过程的话，应该就能知道用户态程序通过软中断指令 int 0x80 来陷入内核态（在 Intel Pentium II 又引入了 sysenter 指令），参数的传递是通过寄存器，eax 传递的是系统调用号，ebx、ecx、edx、esi 和 edi 来依次传递最多五个参数，当系统调用返回时，返回值存放在 eax 中。&lt;/p>
&lt;p>仍然以上面的修改文件属性为例，将调用系统调用那段写成内联汇编代码：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-c" data-lang="c">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#include&lt;/span> &lt;span style="color:#75715e">&amp;lt;stdio.h&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#include&lt;/span> &lt;span style="color:#75715e">&amp;lt;sys/types.h&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#include&lt;/span> &lt;span style="color:#75715e">&amp;lt;sys/syscall.h&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#include&lt;/span> &lt;span style="color:#75715e">&amp;lt;errno.h&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">long&lt;/span> rc;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">char&lt;/span> &lt;span style="color:#f92672">*&lt;/span>file_name &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#34;/etc/passwd&amp;#34;&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">unsigned&lt;/span> &lt;span style="color:#66d9ef">short&lt;/span> mode &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0444&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">asm&lt;/span>(
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">&amp;#34;int $0x80&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#e6db74">&amp;#34;=a&amp;#34;&lt;/span> (rc)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#e6db74">&amp;#34;0&amp;#34;&lt;/span> (SYS_chmod), &lt;span style="color:#e6db74">&amp;#34;b&amp;#34;&lt;/span> ((&lt;span style="color:#66d9ef">long&lt;/span>)file_name), &lt;span style="color:#e6db74">&amp;#34;c&amp;#34;&lt;/span> ((&lt;span style="color:#66d9ef">long&lt;/span>)mode)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">if&lt;/span> ((&lt;span style="color:#66d9ef">unsigned&lt;/span> &lt;span style="color:#66d9ef">long&lt;/span>)rc &lt;span style="color:#f92672">&amp;gt;=&lt;/span> (&lt;span style="color:#66d9ef">unsigned&lt;/span> &lt;span style="color:#66d9ef">long&lt;/span>)&lt;span style="color:#f92672">-&lt;/span>&lt;span style="color:#ae81ff">132&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> errno &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#f92672">-&lt;/span>rc;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> rc &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#f92672">-&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">if&lt;/span> (rc &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#f92672">-&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">fprintf&lt;/span>(stderr, &lt;span style="color:#e6db74">&amp;#34;chmode failed, errno = %d&lt;/span>&lt;span style="color:#ae81ff">\n&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>, errno);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">else&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">printf&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;success!&lt;/span>&lt;span style="color:#ae81ff">\n&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>如果 eax 寄存器存放的返回值（存放在变量 rc 中）在 -1~-132 之间，就必须要解释为出错码（在/usr/include/asm-generic/errno.h 文件中定义的最大出错码为 132），这时，将错误码写入 errno 中，置系统调用返回值为 -1；否则返回的是 eax 中的值。&lt;/p>
&lt;p>上面程序在 32 位 Linux 下以普通用户权限编译运行结果与前面两个相同！&lt;/p>
&lt;h1 id="系统调用与-api-和函数调用之间的区别">系统调用与 API 和函数调用之间的区别&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://mp.weixin.qq.com/s/2rzzQTuZKSW0O4zM1DlAWQ">公众号，系统调用与函数调用有什么区别？&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://mp.weixin.qq.com/s/q7CDAlwUB7bFstYZ1nOVvA">公众号，系统调用和API有什么区别？&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote></description></item><item><title>Docs: 3.Systemd 系统守护程序</title><link>https://desistdaydream.github.io/docs/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/3.Systemd-%E7%B3%BB%E7%BB%9F%E5%AE%88%E6%8A%A4%E7%A8%8B%E5%BA%8F/3.Systemd-%E7%B3%BB%E7%BB%9F%E5%AE%88%E6%8A%A4%E7%A8%8B%E5%BA%8F/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/3.Systemd-%E7%B3%BB%E7%BB%9F%E5%AE%88%E6%8A%A4%E7%A8%8B%E5%BA%8F/3.Systemd-%E7%B3%BB%E7%BB%9F%E5%AE%88%E6%8A%A4%E7%A8%8B%E5%BA%8F/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://github.com/systemd/systemd">GitHub 项目&lt;/a>&lt;/li>
&lt;li>&lt;a href="http://www.jinbuguo.com/systemd/systemd.index.html">Systemd 中文手册,金步国&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://man.cx/systemd">Manual(手册),systemd&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>&lt;strong>System daemon(系统守护进程，简称 systemd)&lt;/strong> 实质上：启动一个服务，就是启动一个程序，可以给该程序添加一些参数，也可以不添加，该程序的可执行文件一般是放在 /usr/lib/systemd/system/ 目录下的&lt;/p>
&lt;p>历史上，Linux 的启动一直采用 init 进程。这种命令 &lt;code>/etc/init.d/apache2 start 或者 service apache2 start&lt;/code>，就是用来启动服务。&lt;/p>
&lt;p>这种方法有两个缺点。&lt;/p>
&lt;ol>
&lt;li>启动时间长。init 进程是串行启动，只有前一个进程启动完，才会启动下一个进程。&lt;/li>
&lt;li>启动脚本复杂。init 进程只是执行启动脚本，不管其他事情。脚本需要自己处理各种情况，这往往使得脚本变得很长。&lt;/li>
&lt;/ol>
&lt;p>Systemd 就是为了解决这些问题而诞生的。它的设计目标是，为系统的启动和管理提供一套完整的解决方案。&lt;/p>
&lt;p>根据 Linux 惯例，字母 d 是 daemon(守护进程) 的缩写。 Systemd 这个名字的含义，就是它要守护整个系统。&lt;/p>
&lt;p>使用了 Systemd，就不需要再用 init 了。Systemd 取代了 initd，成为系统的第一个进程(PID 等于 1)，其他进程都是它的子进程。&lt;/p>
&lt;p>Systemd 的优点是功能强大，使用方便，缺点是体系庞大，非常复杂。事实上，现在还有很多人反对使用 Systemd，理由就是它过于复杂，与操作系统的其他部分强耦合，违反&amp;quot;keep simple, keep stupid&amp;quot;的 Unix 哲学。&lt;/p>
&lt;p>注意：Systemd 启动的程序无法获取 shell 中的变量，需要通过在 Unit 的配置文件中设置环境变量。&lt;/p>
&lt;h2 id="unit单元">Unit(单元)&lt;/h2>
&lt;p>Systemd 将各种操作系统启动和运行的相关对象，抽象多种类型的 &lt;strong>Units(单元)&lt;/strong>，并且提供了 Units 之间的依赖关系。&lt;strong>大多数 Units 是通过 Unit File(单元文件) 创建的&lt;/strong>，没有 Unit File，也就不会存在所谓的 Units。&lt;strong>可以这么说，在特定目录创建了一个符合 Unit File 格式的文件，也就创建了一个 Unit&lt;/strong>。&lt;/p>
&lt;blockquote>
&lt;p>单元：比如以前上学总说：第一单元、第二单元，这种理解&lt;/p>
&lt;/blockquote>
&lt;p>现阶段有如下几种 Units：&lt;/p>
&lt;ol>
&lt;li>&lt;strong>Automoount unit&lt;/strong> # 自动挂载点&lt;/li>
&lt;li>&lt;strong>Device unit&lt;/strong> # 硬件设备&lt;/li>
&lt;li>&lt;strong>Mount unit&lt;/strong> # 文件系统挂载点&lt;/li>
&lt;li>&lt;strong>Path unit&lt;/strong> # 文件或路径&lt;/li>
&lt;li>&lt;strong>Scope unit&lt;/strong> # 与 Service unit 类似，但是由 systemd 根据 D-bus 接口接收到的信息自动创建， 可用于管理外部创建的进程。&lt;/li>
&lt;li>&lt;strong>Service unit&lt;/strong> # 用于启动和控制守护进程以及他们所包含的进程&lt;/li>
&lt;li>&lt;strong>Slice unit&lt;/strong> # 用于控制特定 CGroup 内(例如一组 service 与 scope 单元)所有进程的总体资源占用。&lt;/li>
&lt;li>&lt;strong>Socket nuit&lt;/strong> # 进程间通信的 socket&lt;/li>
&lt;li>&lt;strong>Swap unit&lt;/strong> # 关于 swap 文件&lt;/li>
&lt;li>&lt;strong>Target nuit&lt;/strong> # 是一群 Unit 的集合&lt;/li>
&lt;li>&lt;strong>Timer unit&lt;/strong> # 定时器&lt;/li>
&lt;/ol>
&lt;p>&lt;strong>Unit 的名称&lt;/strong>。Unit 的名称由 Unit File 的名称决定。比如一个 crond.service 文件，将会创建出来一个类型为 Service，名为 crond.service 的 Unit。
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/glcff3/1616167393721-79076d3b-2c04-48e9-a4a0-8ee4bfb69284.jpeg" alt="">
&lt;strong>Unit 的依赖&lt;/strong>。Systemd 能够处理 Units 之间的依赖关系，通过依赖关系，我们可以确定 Unit 之间启动的先后顺序、以及 Unit 之间是否可以同时运行。
&lt;strong>Unit 的状态&lt;/strong>。 Unit 既可以处于活动(active)状态也可以处于停止(inactive)状态， 当然也可以处于启动中(activating)或停止中(deactivating)的状态。 还有一个特殊的失败(failed)状态， 意思是单元以某种方式失败了 (退出时返回了错误代码、进程崩溃、操作超时、触碰启动频率限制)。 当进入失败(failed)状态时， 导致故障的原因 将被记录到日志中以方便日后排查。 需要注意的是， 不同的单元可能还会有各自不同的&amp;quot;子状态&amp;quot;， 但它们都被映射到上述五种状态之一。通过 &lt;code>systemctl list-units --all&lt;/code> 命令可以查看每个 Unit 的状态。&lt;/p>
&lt;h1 id="systemd-配置">Systemd 配置&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>man 手册：&lt;a href="https://man7.org/linux/man-pages/man5/systemd-system.conf.5.html">https://man7.org/linux/man-pages/man5/systemd-system.conf.5.html&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>&lt;strong>/etc/systemd/*&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>**./system.conf **# Systemd 程序运行时配置文件&lt;/li>
&lt;li>**./system.conf.d/*.conf **# Systemd 程序运行时配置文件&lt;/li>
&lt;li>&lt;strong>./user.conf&lt;/strong> # Systemd 以普通用户身份运行时的配置文件&lt;/li>
&lt;li>&lt;strong>./user.conf.d/*.conf&lt;/strong> # Systemd 以普通用户身份运行时的配置文件&lt;/li>
&lt;/ul>
&lt;p>**/run/systemd/* **#&lt;/p>
&lt;ul>
&lt;li>&lt;strong>./system.conf.d/*.conf&lt;/strong> # Systemd 程序运行时配置文件&lt;/li>
&lt;li>&lt;strong>./user.conf.d/*.conf&lt;/strong> # Systemd 以普通用户身份运行时的配置文件&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>/usr/lib/systemd/*&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>&lt;strong>./system.conf.d/*.conf&lt;/strong> # Systemd 程序运行时配置文件&lt;/li>
&lt;li>&lt;strong>./user.conf.d/*.conf&lt;/strong> # Systemd 以普通用户身份运行时的配置文件&lt;/li>
&lt;/ul>
&lt;p>/etc、/run、/usr/lib 这三个目录的优先级从左至右由高到低。Systemd 会从最低优先级的目录 /usr/lib/_ 下开始加载配置，注意加载其中的文件，直到最高优先级的目录 /etc/systemd/_ 为止。&lt;/p>
&lt;h2 id="units-配置">Units 配置&lt;/h2>
&lt;p>Units 配置就是指 Unit File。Systemd 会从多个目录中加载 Unit File，以生成 Unit。下面列出的路径，优先级从上往下越来越低。也就是说，高优先级目录中的文件，将会覆盖低优先级目录中的同名文件。不同的 Systemd 运行方式，加载 Unit File 的路径不同。&lt;/p>
&lt;h3 id="使用---system-参数以系统实例运行-systemd">使用 &amp;ndash;system 参数，以系统实例运行 systemd&lt;/h3>
&lt;p>通过 pkg-config systemd &amp;ndash;variable=systemdsystemunitdir** &lt;strong>命令可以查看包管理器安装完程序后，生成 Unit File 的目录
通过 pkg-config systemd &amp;ndash;variable=systemdsystemconfdir&lt;/strong> **命令可以查看优先级最高的存放 Unit File 的目录&lt;/p>
&lt;ul>
&lt;li>&lt;strong>/etc/systemd/system.control&lt;/strong> # 通过 dbus API 创建的永久系统单元&lt;/li>
&lt;li>&lt;strong>/run/systemd/system.control&lt;/strong> # 通过 dbus API 创建的临时系统单元&lt;/li>
&lt;li>&lt;strong>/run/systemd/transient&lt;/strong> # 动态配置的临时单元(系统与全局用户共用)&lt;/li>
&lt;li>&lt;strong>/run/systemd/generator.early&lt;/strong> # 生成的高优先级单元(系统与全局用户共用)(参见 systemd.generator(7) 手册中对 early-dir 的说明)&lt;/li>
&lt;li>&lt;strong>/etc/systemd/system/*&lt;/strong> # 人类根据需求，手动创建的 Unit File 所在路径。且当使用 systemctl enable UNIT 命令的时候，会自动在该目录中创建软连接到 /usr/lib/systemd/system/ 目录中的 Unit File
&lt;ul>
&lt;li>./UnitFileName.d/*.conf # 嵌入式单元文件 存放路径&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>/run/systemd/system/*&lt;/strong> # 程序运行时自动生成的 Unit File 所在路径。
&lt;ul>
&lt;li>./UnitFileName.d/*.conf # 嵌入式单元文件 存放路径&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>/run/systemd/generator&lt;/strong> # 生成的中优先级系统单元(参见 systemd.generator(7) 手册中对 normal-dir 的说明)&lt;/li>
&lt;li>&lt;strong>/usr/local/lib/systemd/system&lt;/strong> # 本地软件包安装的系统单元&lt;/li>
&lt;li>&lt;strong>/usr/lib/systemd/system/*&lt;/strong> # 通过系统的包管理器安装程序时，生成的 Unit File 所在路径。
&lt;ul>
&lt;li>./UnitFileName.d/*.conf # 嵌入式单元文件 存放路径&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>/run/systemd/generator.late&lt;/strong> # 生成的低优先级系统单元(参见 systemd.generator(7) 手册中对 late-dir 的说明)&lt;/li>
&lt;/ul>
&lt;h3 id="使用---user-参数以用户实例运行-systemd">使用 &amp;ndash;user 参数，以用户实例运行 systemd&lt;/h3>
&lt;ul>
&lt;li>&lt;strong>$XDG_CONFIG_HOME/systemd/user.control 或 ~/.config/systemd/user.control&lt;/strong> # 通过 dbus API 创建的永久私有用户单元(仅在未设置 $XDG_CONFIG_HOME 时才使用 ~/.config 来替代)&lt;/li>
&lt;li>$XDG_RUNTIME_DIR/systemd/user.control # 通过 dbus API 创建的临时私有用户单元&lt;/li>
&lt;li>/run/systemd/transient 动态配置的临时单元(系统与全局用户共用)&lt;/li>
&lt;li>/run/systemd/generator.early 生成的高优先级单元(系统与全局用户共用)(参见 systemd.generator(7) 手册中对 early-dir 的说明)&lt;/li>
&lt;li>$XDG_CONFIG_HOME/systemd/user 或 $HOME/.config/systemd/user 用户配置的私有用户单元(仅在未设置 $XDG_CONFIG_HOME 时才使用 ~/.config 来替代)&lt;/li>
&lt;li>/etc/systemd/user 本地配置的全局用户单元&lt;/li>
&lt;li>$XDG_RUNTIME_DIR/systemd/user 运行时配置的私有用户单元(仅当 $XDG_RUNTIME_DIR 已被设置时有效)&lt;/li>
&lt;li>/run/systemd/user 运行时配置的全局用户单元&lt;/li>
&lt;li>$XDG_RUNTIME_DIR/systemd/generator 生成的中优先级私有用户单元(参见 systemd.generator(7) 手册中对 normal-dir 的说明)&lt;/li>
&lt;li>$XDG_DATA_HOME/systemd/user 或 $HOME/.local/share/systemd/user 软件包安装在用户家目录中的私有用户单元(仅在未设置 $XDG_DATA_HOME 时才使用 ~/.local/share 来替代)&lt;/li>
&lt;li>$dir/systemd/user(对应 $XDG_DATA_DIRS 中的每一个目录($dir)) 额外安装的全局用户单元，对应 $XDG_DATA_DIRS(默认值=&amp;quot;/usr/local/share/:/usr/share/&amp;quot;) 中的每一个目录。&lt;/li>
&lt;li>/usr/local/lib/systemd/user 本地软件包安装的全局用户单元&lt;/li>
&lt;li>/usr/lib/systemd/user 发行版软件包安装的全局用户单元&lt;/li>
&lt;li>$XDG_RUNTIME_DIR/systemd/generator.late 生成的低优先级私有用户单元(参见 systemd.generator(7) 手册中对 late-dir 的说明)&lt;/li>
&lt;/ul>
&lt;p>可以使用环境变量来 扩充或更改 systemd 用户实例(&lt;code>--user&lt;/code>)的单元文件加载路径。 环境变量可以通过环境变量生成器(详见 &lt;a href="http://www.jinbuguo.com/systemd/systemd.environment-generator.html#">systemd.environment-generator(7)&lt;/a> 手册)来设置。特别地， &lt;code>$XDG_DATA_HOME&lt;/code> 与 &lt;code>$XDG_DATA_DIRS&lt;/code> 可以方便的通过 &lt;a href="http://www.jinbuguo.com/systemd/systemd-environment-d-generator.html#">systemd-environment-d-generator(8)&lt;/a> 来设置。这样，上表中列出的单元目录正好就是默认值。 要查看实际使用的、基于编译选项与当前环境变量的单元目录列表，可以使用 &lt;code>systemd-analyze --user unit-paths&lt;/code>&lt;/p>
&lt;p>此外，还可以通过 &lt;a href="http://www.jinbuguo.com/systemd/systemctl.html#">systemctl(1)&lt;/a> 的 &lt;strong>link&lt;/strong> 命令 向上述单元目录中添加额外的单元(不在上述常规单元目录中的单元)。&lt;/p></description></item><item><title>Docs: 4.CPU 管理</title><link>https://desistdaydream.github.io/docs/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2.Kernel%E5%86%85%E6%A0%B8/4.CPU-%E7%AE%A1%E7%90%86/CPU-%E7%AE%A1%E7%90%86/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2.Kernel%E5%86%85%E6%A0%B8/4.CPU-%E7%AE%A1%E7%90%86/CPU-%E7%AE%A1%E7%90%86/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://time.geekbang.org/column/article/69859">极客时间，Linux 性能优化实战-03 基础篇：经常说的 CPU 上下文切换是什么意思&lt;/a>&lt;/li>
&lt;li>&lt;a href="http://linuxperf.com/?p=209">LinuxPerformance 博客，进程切换：自愿与强制&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>在 Linux 中，CPU 的管理，绝大部分时间都是在进行任务的调度，所以很多时候也称为&lt;strong>调度管理&lt;/strong>。&lt;/p>
&lt;h2 id="cpu-多线程并发并行-概念">CPU 多线程、并发、并行 概念&lt;/h2>
&lt;p>Node：在这里时间片只是一种描述，理解 CPU 的并行与并发概念就好&lt;/p>
&lt;p>1、CPU 时间分片、多线程？
如果线程数不多于 CPU 核心数，会把各个线程都分配一个核心，不需分片，而当线程数多于 CPU 核心数时才会分片。&lt;/p>
&lt;p>2、并发和并行的区别&lt;/p>
&lt;ul>
&lt;li>并发：当有多个线程在操作时,如果系统只有一个 CPU,把 CPU 运行时间划分成若干个时间片,分配给各个线程执行，在一个时间段的线程代码运行时，其它线程处于挂起状态。这种方式我们称之为_ _&lt;strong>Concurrent(并发)&lt;/strong>。并发=间隔发生&lt;/li>
&lt;li>并行：当系统有一个以上 CPU 时,则线程的操作有可能非并发。当一个 CPU 执行一个线程时，另一个 CPU 可以执行另一个线程，两个线程互不抢占 CPU 资源，可以同时进行，这种方式我们称之为 &lt;strong>Parallel(并行)&lt;/strong>。 并行=同时进行&lt;/li>
&lt;/ul>
&lt;p>区别：并行是指两个或者多个事件在同一时刻发生；而并发是指两个或多个事件在同一时间间隔内发生。&lt;/p>
&lt;p>并行是同时做多件事情。&lt;/p>
&lt;p>并发表示同时发生了多件事情，通过时间片切换，哪怕只有单一的核心，也可以实现“同时做多件事情”这个效果。&lt;/p>
&lt;p>根据底层是否有多处理器，并发与并行是可以等效的，这并不是两个互斥的概念。&lt;/p>
&lt;p>举个我们开发中会遇到的例子，我们说资源请求并发数达到了 1 万。这里的意思是有 1 万个请求同时过来了。但是这里很明显不可能真正的同时去处理这 1 万个请求的吧！&lt;/p>
&lt;p>如果这台机器的处理器有 4 个核心，不考虑超线程，那么我们认为同时会有 4 个线程在跑。也就是说，并发访问数是 1 万，而底层真实的并行处理的请求数是 4。如果并发数小一些只有 4 的话，又或者你的机器牛逼有 1 万个核心，那并发在这里和并行一个效果。也就是说，并发可以是虚拟的同时执行，也可以是真的同时执行。而并行的意思是真的同时执行。&lt;/p>
&lt;p>结论是：并行是我们物理时空观下的同时执行，而并发则是操作系统用线程这个模型抽象之后站在线程的视角上看到的“同时”执行。&lt;/p>
&lt;h3 id="time-slice时间片-概念">time slice(时间片) 概念&lt;/h3>
&lt;blockquote>
&lt;p>参考：&lt;a href="https://en.wikipedia.org/wiki/Preemption_(computing)#Time_slice">https://en.wikipedia.org/wiki/Preemption_(computing)#Time_slice&lt;/a>&lt;/p>
&lt;/blockquote>
&lt;p>The period of time for which a process is allowed to run in a preemptive multitasking system is generally called the &lt;em>time slice&lt;/em> or &lt;em>quantum&lt;/em>.&lt;/p>
&lt;p>&lt;strong>time slice(时间片)&lt;/strong> 是一个程序运行在&lt;a href="https://en.wikipedia.org/wiki/Preemption_(computing)">抢占式多任务系统&lt;/a>中的一段时间。也可以称为 quantum(量子)。&lt;/p>
&lt;h2 id="cpu-使用率概念">CPU 使用率概念&lt;/h2>
&lt;p>CPU 不像硬盘、内存，并不具备逻辑上数量、大小、空间之类的概念。只要使用 CPU，就是使用了这个 CPU 的全部，也就无法通过大小之类的概念来衡量一个 CPU，所以我们日常所说的 CPU 的使用率 ，实际上是指的在一段时间范围内，CPU 执行 &lt;strong>Tasks(任务)&lt;/strong> 花费时间的百分比。比如 60 分钟内，一颗 CPU 执行各种任务花费了 6 分钟，则 CPU 在这一小时时间内的使用率为 10%。&lt;/p>
&lt;blockquote>
&lt;p>上文说的 &lt;strong>Tasks(任务)&lt;/strong>，即会指系统中的进程、线程，也代表各种硬件去请求 CPU 执行的各种事情，比如网卡接收到数据，就会告诉 CPU 需要处理(i.e.中断)。&lt;/p>
&lt;/blockquote>
&lt;p>在 Linux 系统中，CPU 的使用率一般可分为 4 大类：&lt;/p>
&lt;ol>
&lt;li>User Time(用户进程运行时间)&lt;/li>
&lt;li>System Time(系统内核运行时间)&lt;/li>
&lt;li>Idle Time(空闲时间)&lt;/li>
&lt;li>Steal Time(被抢占时间)&lt;/li>
&lt;/ol>
&lt;p>除了 Idle Time 外，CPU 在其余时间都处于工作运行状态。
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/srucoz/1616168021555-68fba1de-f5d5-462d-bef6-a78b476521ad.png" alt="">&lt;/p>
&lt;p>通常而言，我们泛指的整体 CPU 使用率为 User Time 和 Systime 占比之和(例如 tsar 中 CPU util)，即：
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/srucoz/1616168021559-394ecaa6-59db-453a-b5b1-c5ab88193f49.png" alt="">&lt;/p>
&lt;p>为了便于定位问题，大多数性能统计工具都将这 4 类时间片进一步扩展成了 8 类，如下图，是在 top 命令的 man 手册中对 CPU 使用率的分类。
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/srucoz/1616168021546-ebe53556-f50b-49f2-8477-c10cf2b8f2f5.png" alt="">&lt;/p>
&lt;ul>
&lt;li>us：用户进程空间中未改变过优先级的进程占用 CPU 百分比&lt;/li>
&lt;li>sy：内核空间占用 CPU 百分比&lt;/li>
&lt;li>ni：用户进程空间内改变过优先级的进程占用 CPU 百分比&lt;/li>
&lt;li>id：空闲时间百分比&lt;/li>
&lt;li>wa：等待 I/O 的时间百分比&lt;/li>
&lt;li>hi：硬中断时间百分比&lt;/li>
&lt;li>si：软中断时间百分比&lt;/li>
&lt;li>st：虚拟化时被其余 VM 窃取时间百分比&lt;/li>
&lt;/ul>
&lt;p>这 8 类分片中，除 wa 和 id 外，其余分片 CPU 都处于工作态。&lt;/p>
&lt;h1 id="调度算法">调度算法&lt;/h1>
&lt;blockquote>
&lt;p>详见：&lt;a href="https://www.yuque.com/go/doc/33222924">CPU 调度算法&lt;/a>&lt;/p>
&lt;/blockquote>
&lt;p>首先明确一个概念：&lt;strong>Task(任务)&lt;/strong>，一个进程从处理到结束就算一个任务，处理网卡收到的数据包也算一个任务。一般来说，CPU 就是在处理一个个的 &lt;strong>Task(任务)&lt;/strong>，并度过其一生。&lt;/p>
&lt;p>在 Linux 内核中，进程和线程都是用 tark_struct 结构体表示的，区别在于线程的 tark_struct 结构体里部分资源是共享了进程已创建的资源，比如内存地址空间、代码段、文件描述符等，所以 Linux 中的线程也被称为轻量级进程，因为线程的 tark_struct 相比进程的 tark_struct 承载的 资源比较少，因此以「轻」得名。&lt;/p>
&lt;p>一般来说，没有创建线程的进程，是只有单个执行流，它被称为是主线程。如果想让进程处理更多的事情，可以创建多个线程分别去处理，但不管怎么样，它们对应到内核里都是 tark_struct。&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/srucoz/1616168021545-596ecf70-ac19-4620-8845-bfe72ef7bdce.jpeg" alt="">&lt;/p>
&lt;p>所以，Linux 内核里的调度器，调度的对象就是 tark_struct，接下来我们就把这个数据结构统称为任务。&lt;/p>
&lt;p>在 Linux 系统中，根据任务的优先级以及响应要求，主要分为两种，其中优先级的数值越小，优先级越高：&lt;/p>
&lt;ul>
&lt;li>实时任务，对系统的响应时间要求很高，也就是要尽可能快的执行实时任务，优先级在 0~99 范围内的就算实时任务；&lt;/li>
&lt;li>普通任务，响应时间没有很高的要求，优先级在 100~139 范围内都是普通任务级别；&lt;/li>
&lt;/ul>
&lt;p>也就是说，在 LInux 内核中，实时任务总是比普通任务的优先级要高。&lt;/p></description></item><item><title>Docs: 5.Memory 管理</title><link>https://desistdaydream.github.io/docs/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2.Kernel%E5%86%85%E6%A0%B8/5.Memory-%E7%AE%A1%E7%90%86/5.Memory-%E7%AE%A1%E7%90%86/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2.Kernel%E5%86%85%E6%A0%B8/5.Memory-%E7%AE%A1%E7%90%86/5.Memory-%E7%AE%A1%E7%90%86/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://mp.weixin.qq.com/s/HJB_ATQFNqG82YBCRr97CA">公众号,小林 coding-真棒！ 20 张图揭开内存管理的迷雾，瞬间豁然开朗&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://mp.weixin.qq.com/s/0g3sS63yM2qbBja-blw5Dw">公众号，码农的荒岛求生-神秘！申请内存时底层发生了什么？&lt;/a>(malloc 简介)&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>对任何一台计算机而言，其内存以及其它资源都是有限的。为了让有限的&lt;strong>物理内存&lt;/strong>满足应用程序对内存的大需求量，Linux 采用了称为 &lt;strong>虚拟内存&lt;/strong>的内存管理方式。Linux 将内存划分为容易处理的“内存页”（对于大部分体系结构来说都是 4KB）。Linux 包括了管理可用内存的方式，以及物理和虚拟映射所使用的硬件机制。&lt;/p>
&lt;p>不过内存管理要管理的可不止 4KB 缓冲区。Linux 提供了对 4KB 缓冲区的抽象，例如 slab 分配器。这种内存管理模式使用 4KB 缓冲区为基数，然后从中分配结构，并跟踪内存页使用情况，比如哪些内存页是满的，哪些页面没有完全使用，哪些页面为空。这样就允许该模式根据系统需要来动态调整内存使用。&lt;/p>
&lt;p>为了支持多个用户使用内存，有时会出现可用内存被消耗光的情况。由于这个原因，页面可以移出内存并放入磁盘中。这个过程称为交换，因为页面会被从内存交换到硬盘上。内存管理的源代码可以在 ./linux/mm 中找到。&lt;/p>
&lt;h1 id="虚拟内存">虚拟内存&lt;/h1>
&lt;p>如果你是电子相关专业的，肯定在大学里捣鼓过单片机。&lt;/p>
&lt;p>单片机是没有操作系统的，所以每次写完代码，都需要借助工具把程序烧录进去，这样程序才能跑起来。&lt;/p>
&lt;p>另外，单片机的 CPU 是直接操作内存的「物理地址」。&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/odexpg/1616167919093-db60b152-2475-49e7-8a9d-813007e27b8d.jpeg" alt="">&lt;/p>
&lt;p>在这种情况下，要想在内存中同时运行两个程序是不可能的。如果第一个程序在 2000 的位置写入一个新的值，将会擦掉第二个程序存放在相同位置上的所有内容，所以同时运行两个程序是根本行不通的，这两个程序会立刻崩溃。&lt;/p>
&lt;p>操作系统是如何解决这个问题呢？&lt;/p>
&lt;p>这里关键的问题是这两个程序都引用了绝对物理地址，而这正是我们最需要避免的。&lt;/p>
&lt;p>我们可以把进程所使用的地址「隔离」开来，即让操作系统为每个进程分配独立的一套「虚拟地址」，人人都有，大家自己玩自己的地址就行，互不干涉。但是有个前提每个进程都不能访问物理地址，至于虚拟地址最终怎么落到物理内存里，对进程来说是透明的，操作系统已经把这些都安排的明明白白了。&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/odexpg/1616167919100-24627511-d5f5-4663-9a2c-76b4b3b75664.jpeg" alt="">&lt;/p>
&lt;p>进程的中间层&lt;/p>
&lt;p>操作系统会提供一种机制，将不同进程的虚拟地址和不同内存的物理地址映射起来。&lt;/p>
&lt;p>如果程序要访问虚拟地址的时候，由操作系统转换成不同的物理地址，这样不同的进程运行的时候，写入的是不同的物理地址，这样就不会冲突了。&lt;/p>
&lt;p>于是，这里就引出了两种地址的概念：&lt;/p>
&lt;ul>
&lt;li>我们程序所使用的内存地址叫做虚拟内存地址（Virtual Memory Address）&lt;/li>
&lt;li>实际存在硬件里面的空间地址叫物理内存地址（Physical Memory Address）。&lt;/li>
&lt;/ul>
&lt;p>操作系统引入了虚拟内存，进程持有的虚拟地址会通过 CPU 芯片中的内存管理单元（MMU）的映射关系，来转换变成物理地址，然后再通过物理地址访问内存，如下图所示：&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/odexpg/1616167919111-7b5c26a3-f885-4ae8-bb6b-2bfab9cef4c9.jpeg" alt="">&lt;/p>
&lt;p>操作系统是如何管理虚拟地址与物理地址之间的关系？&lt;/p>
&lt;p>主要有两种方式，分别是内存分段和内存分页，分段是比较早提出的，我们先来看看内存分段。&lt;/p>
&lt;h2 id="内存分段">内存分段&lt;/h2>
&lt;p>程序是由若干个逻辑分段组成的，如可由代码分段、数据分段、栈段、堆段组成。不同的段是有不同的属性的，所以就用分段（Segmentation）的形式把这些段分离出来。&lt;/p>
&lt;p>分段机制下，虚拟地址和物理地址是如何映射的？&lt;/p>
&lt;p>分段机制下的虚拟地址由两部分组成，段选择子和段内偏移量。&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/odexpg/1616167919128-c7568177-0bee-4534-84c6-694d268dd85d.jpeg" alt="">&lt;/p>
&lt;p>内存分段-寻址的方式&lt;/p>
&lt;ul>
&lt;li>段选择子就保存在段寄存器里面。段选择子里面最重要的是段号，用作段表的索引。段表里面保存的是这个段的基地址、段的界限和特权等级等。&lt;/li>
&lt;li>虚拟地址中的段内偏移量应该位于 0 和段界限之间，如果段内偏移量是合法的，就将段基地址加上段内偏移量得到物理内存地址。&lt;/li>
&lt;/ul>
&lt;p>在上面了，知道了虚拟地址是通过段表与物理地址进行映射的，分段机制会把程序的虚拟地址分成 4 个段，每个段在段表中有一个项，在这一项找到段的基地址，再加上偏移量，于是就能找到物理内存中的地址，如下图：&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/odexpg/1616167919115-2be6810a-fa1d-41f1-92f8-b6390209f15a.jpeg" alt="">&lt;/p>
&lt;p>内存分段-虚拟地址与物理地址&lt;/p>
&lt;p>如果要访问段 3 中偏移量 500 的虚拟地址，我们可以计算出物理地址为，段 3 基地址 7000 + 偏移量 500 = 7500。&lt;/p>
&lt;p>分段的办法很好，解决了程序本身不需要关心具体的物理内存地址的问题，但它也有一些不足之处：&lt;/p>
&lt;ul>
&lt;li>第一个就是内存碎片的问题。&lt;/li>
&lt;li>第二个就是内存交换的效率低的问题。&lt;/li>
&lt;/ul>
&lt;p>接下来，说说为什么会有这两个问题。&lt;/p>
&lt;p>我们先来看看，分段为什么会产生内存碎片的问题？&lt;/p>
&lt;p>我们来看看这样一个例子。假设有 1G 的物理内存，用户执行了多个程序，其中：&lt;/p>
&lt;ul>
&lt;li>游戏占用了 512MB 内存&lt;/li>
&lt;li>浏览器占用了 128MB 内存&lt;/li>
&lt;li>音乐占用了 256 MB 内存。&lt;/li>
&lt;/ul>
&lt;p>这个时候，如果我们关闭了浏览器，则空闲内存还有 1024 - 512 - 256 = 256MB。&lt;/p>
&lt;p>如果这个 256MB 不是连续的，被分成了两段 128 MB 内存，这就会导致没有空间再打开一个 200MB 的程序。&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/odexpg/1616167919115-056b2c69-14f1-48d7-8162-7915c80cd090.jpeg" alt="">&lt;/p>
&lt;p>内存碎片的问题&lt;/p>
&lt;p>这里的内存碎片的问题共有两处地方：&lt;/p>
&lt;ul>
&lt;li>外部内存碎片，也就是产生了多个不连续的小物理内存，导致新的程序无法被装载；&lt;/li>
&lt;li>内部内存碎片，程序所有的内存都被装载到了物理内存，但是这个程序有部分的内存可能并不是很常使用，这也会导致内存的浪费；&lt;/li>
&lt;/ul>
&lt;p>针对上面两种内存碎片的问题，解决的方式会有所不同。&lt;/p>
&lt;p>解决外部内存碎片的问题就是内存交换。&lt;/p>
&lt;p>可以把音乐程序占用的那 256MB 内存写到硬盘上，然后再从硬盘上读回来到内存里。不过再读回的时候，我们不能装载回原来的位置，而是紧紧跟着那已经被占用了的 512MB 内存后面。这样就能空缺出连续的 256MB 空间，于是新的 200MB 程序就可以装载进来。&lt;/p>
&lt;p>这个内存交换空间，在 Linux 系统里，也就是我们常看到的 Swap 空间，这块空间是从硬盘划分出来的，用于内存与硬盘的空间交换。&lt;/p>
&lt;p>再来看看，分段为什么会导致内存交换效率低的问题？&lt;/p>
&lt;p>对于多进程的系统来说，用分段的方式，内存碎片是很容易产生的，产生了内存碎片，那不得不重新 Swap 内存区域，这个过程会产生性能瓶颈。&lt;/p>
&lt;p>因为硬盘的访问速度要比内存慢太多了，每一次内存交换，我们都需要把一大段连续的内存数据写到硬盘上。&lt;/p>
&lt;p>所以，如果内存交换的时候，交换的是一个占内存空间很大的程序，这样整个机器都会显得卡顿。&lt;/p>
&lt;p>为了解决内存分段的内存碎片和内存交换效率低的问题，就出现了内存分页。&lt;/p>
&lt;h2 id="内存分页">内存分页&lt;/h2>
&lt;p>分段的好处就是能产生连续的内存空间，但是会出现内存碎片和内存交换的空间太大的问题。&lt;/p>
&lt;p>要解决这些问题，那么就要想出能少出现一些内存碎片的办法。另外，当需要进行内存交换的时候，让需要交换写入或者从磁盘装载的数据更少一点，这样就可以解决问题了。这个办法，也就是内存分页（Paging）。&lt;/p>
&lt;p>分页是把整个虚拟和物理内存空间切成一段段固定尺寸的大小。这样一个连续并且尺寸固定的内存空间，我们叫页（Page）。在 Linux 下，每一页的大小为 4KB。&lt;/p>
&lt;p>虚拟地址与物理地址之间通过页表来映射，如下图：&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/odexpg/1616167919131-ca0a6877-5b8c-49fc-8982-ff9bd4f247a2.jpeg" alt="">&lt;/p>
&lt;p>内存映射&lt;/p>
&lt;p>页表实际上存储在 CPU 的内存管理单元 （MMU） 中，于是 CPU 就可以直接通过 MMU，找出要实际要访问的物理内存地址。&lt;/p>
&lt;p>而当进程访问的虚拟地址在页表中查不到时，系统会产生一个缺页异常，进入系统内核空间分配物理内存、更新进程页表，最后再返回用户空间，恢复进程的运行。&lt;/p>
&lt;p>分页是怎么解决分段的内存碎片、内存交换效率低的问题？&lt;/p>
&lt;p>由于内存空间都是预先划分好的，也就不会像分段会产生间隙非常小的内存，这正是分段会产生内存碎片的原因。而采用了分页，那么释放的内存都是以页为单位释放的，也就不会产生无法给进程使用的小内存。&lt;/p>
&lt;p>如果内存空间不够，操作系统会把其他正在运行的进程中的「最近没被使用」的内存页面给释放掉，也就是暂时写在硬盘上，称为换出（Swap Out）。一旦需要的时候，再加载进来，称为换入（Swap In）。所以，一次性写入磁盘的也只有少数的一个页或者几个页，不会花太多时间，内存交换的效率就相对比较高。&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/odexpg/1616167919157-7b5cfce7-6d02-4a53-8193-49982f06399f.jpeg" alt="">&lt;/p>
&lt;p>换入换出&lt;/p>
&lt;p>更进一步地，分页的方式使得我们在加载程序的时候，不再需要一次性都把程序加载到物理内存中。我们完全可以在进行虚拟内存和物理内存的页之间的映射之后，并不真的把页加载到物理内存里，而是只有在程序运行中，需要用到对应虚拟内存页里面的指令和数据时，再加载到物理内存里面去。&lt;/p>
&lt;p>分页机制下，虚拟地址和物理地址是如何映射的？&lt;/p>
&lt;p>在分页机制下，虚拟地址分为两部分，页号和页内偏移。页号作为页表的索引，页表包含物理页每页所在物理内存的基地址，这个基地址与页内偏移的组合就形成了物理内存地址，见下图。&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/odexpg/1616167919140-c0d128d7-0238-450c-981a-8477221071a4.jpeg" alt="">&lt;/p>
&lt;p>内存分页寻址&lt;/p>
&lt;p>总结一下，对于一个内存地址转换，其实就是这样三个步骤：&lt;/p>
&lt;ul>
&lt;li>把虚拟内存地址，切分成页号和偏移量；&lt;/li>
&lt;li>根据页号，从页表里面，查询对应的物理页号；&lt;/li>
&lt;li>直接拿物理页号，加上前面的偏移量，就得到了物理内存地址。&lt;/li>
&lt;/ul>
&lt;p>下面举个例子，虚拟内存中的页通过页表映射为了物理内存中的页，如下图：&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/odexpg/1616167919128-24ebe4f8-b4c8-407b-8dc5-98da804e5e0c.jpeg" alt="">&lt;/p>
&lt;p>虚拟页与物理页的映射&lt;/p>
&lt;p>这看起来似乎没什么毛病，但是放到实际中操作系统，这种简单的分页是肯定是会有问题的。&lt;/p>
&lt;p>简单的分页有什么缺陷吗？&lt;/p>
&lt;p>有空间上的缺陷。&lt;/p>
&lt;p>因为操作系统是可以同时运行非常多的进程的，那这不就意味着页表会非常的庞大。&lt;/p>
&lt;p>在 32 位的环境下，虚拟地址空间共有 4GB，假设一个页的大小是 4KB（2^12），那么就需要大约 100 万 （2^20） 个页，每个「页表项」需要 4 个字节大小来存储，那么整个 4GB 空间的映射就需要有 4MB 的内存来存储页表。&lt;/p>
&lt;p>这 4MB 大小的页表，看起来也不是很大。但是要知道每个进程都是有自己的虚拟地址空间的，也就说都有自己的页表。&lt;/p>
&lt;p>那么，100 个进程的话，就需要 400MB 的内存来存储页表，这是非常大的内存了，更别说 64 位的环境了。&lt;/p>
&lt;h3 id="多级页表">多级页表&lt;/h3>
&lt;p>要解决上面的问题，就需要采用的是一种叫作多级页表（Multi-Level Page Table）的解决方案。&lt;/p>
&lt;p>在前面我们知道了，对于单页表的实现方式，在 32 位和页大小 4KB 的环境下，一个进程的页表需要装下 100 多万个「页表项」，并且每个页表项是占用 4 字节大小的，于是相当于每个页表需占用 4MB 大小的空间。&lt;/p>
&lt;p>我们把这个 100 多万个「页表项」的单级页表再分页，将页表（一级页表）分为 1024 个页表（二级页表），每个表（二级页表）中包含 1024 个「页表项」，形成二级分页。如下图所示：&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/odexpg/1616167919185-cc42b53c-b247-413b-b8ea-9545012c17a3.jpeg" alt="">&lt;/p>
&lt;p>二级分页&lt;/p>
&lt;p>你可能会问，分了二级表，映射 4GB 地址空间就需要 4KB（一级页表）+ 4MB（二级页表）的内存，这样占用空间不是更大了吗？&lt;/p>
&lt;p>当然如果 4GB 的虚拟地址全部都映射到了物理内上的，二级分页占用空间确实是更大了，但是，我们往往不会为一个进程分配那么多内存。&lt;/p>
&lt;p>其实我们应该换个角度来看问题，还记得计算机组成原理里面无处不在的局部性原理么？&lt;/p>
&lt;p>每个进程都有 4GB 的虚拟地址空间，而显然对于大多数程序来说，其使用到的空间远未达到 4GB，因为会存在部分对应的页表项都是空的，根本没有分配，对于已分配的页表项，如果存在最近一定时间未访问的页表，在物理内存紧张的情况下，操作系统会将页面换出到硬盘，也就是说不会占用物理内存。&lt;/p>
&lt;p>如果使用了二级分页，一级页表就可以覆盖整个 4GB 虚拟地址空间，但如果某个一级页表的页表项没有被用到，也就不需要创建这个页表项对应的二级页表了，即可以在需要时才创建二级页表。做个简单的计算，假设只有 20% 的一级页表项被用到了，那么页表占用的内存空间就只有 4KB（一级页表） + 20% * 4MB（二级页表）= 0.804MB&lt;/p>
&lt;p>，这对比单级页表的 4MB 是不是一个巨大的节约？&lt;/p>
&lt;p>那么为什么不分级的页表就做不到这样节约内存呢？我们从页表的性质来看，保存在内存中的页表承担的职责是将虚拟地址翻译成物理地址。假如虚拟地址在页表中找不到对应的页表项，计算机系统就不能工作了。所以页表一定要覆盖全部虚拟地址空间，不分级的页表就需要有 100 多万个页表项来映射，而二级分页则只需要 1024 个页表项（此时一级页表覆盖到了全部虚拟地址空间，二级页表在需要时创建）。&lt;/p>
&lt;p>我们把二级分页再推广到多级页表，就会发现页表占用的内存空间更少了，这一切都要归功于对局部性原理的充分应用。&lt;/p>
&lt;p>对于 64 位的系统，两级分页肯定不够了，就变成了四级目录，分别是：&lt;/p>
&lt;ul>
&lt;li>全局页目录项 PGD（Page Global Directory）；&lt;/li>
&lt;li>上层页目录项 PUD（Page Upper Directory）；&lt;/li>
&lt;li>中间页目录项 PMD（Page Middle Directory）；&lt;/li>
&lt;li>页表项 PTE（Page Table Entry）；&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/odexpg/1616167919165-47fbe1d8-e5a2-421b-9215-5152f9f6d457.jpeg" alt="">&lt;/p>
&lt;p>四级目录&lt;/p>
&lt;h3 id="tlb">TLB&lt;/h3>
&lt;p>多级页表虽然解决了空间上的问题，但是虚拟地址到物理地址的转换就多了几道转换的工序，这显然就降低了这俩地址转换的速度，也就是带来了时间上的开销。&lt;/p>
&lt;p>程序是有局部性的，即在一段时间内，整个程序的执行仅限于程序中的某一部分。相应地，执行所访问的存储空间也局限于某个内存区域。&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/odexpg/1616167919150-0d7ed5fb-19de-4398-84ca-e77a4c67ab46.jpeg" alt="">&lt;/p>
&lt;p>程序的局部性&lt;/p>
&lt;p>我们就可以利用这一特性，把最常访问的几个页表项存储到访问速度更快的硬件，于是计算机科学家们，就在 CPU 芯片中，加入了一个专门存放程序最常访问的页表项的 Cache，这个 Cache 就是 Translation Lookaside Buffer(转译后备缓冲器，简称 TLB、缓存、快表)等。&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/odexpg/1616167919151-684032a9-151a-4c86-be9a-7535abfc6444.jpeg" alt="">&lt;/p>
&lt;p>地址转换&lt;/p>
&lt;p>在 CPU 芯片里面，封装了内存管理单元（Memory Management Unit）芯片，它用来完成地址转换和 TLB 的访问与交互。&lt;/p>
&lt;p>有了 TLB 后，那么 CPU 在寻址时，会先查 TLB，如果没找到，才会继续查常规的页表。&lt;/p>
&lt;p>TLB 的命中率其实是很高的，因为程序最常访问的页就那么几个。&lt;/p>
&lt;h2 id="段页式内存管理">段页式内存管理&lt;/h2>
&lt;p>内存分段和内存分页并不是对立的，它们是可以组合起来在同一个系统中使用的，那么组合起来后，通常称为段页式内存管理。&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/odexpg/1616167919147-0a7f2b14-9364-4a8e-ba60-c48e8cdf65d0.jpeg" alt="">&lt;/p>
&lt;p>段页式地址空间&lt;/p>
&lt;p>段页式内存管理实现的方式：&lt;/p>
&lt;ul>
&lt;li>先将程序划分为多个有逻辑意义的段，也就是前面提到的分段机制；&lt;/li>
&lt;li>接着再把每个段划分为多个页，也就是对分段划分出来的连续空间，再划分固定大小的页；&lt;/li>
&lt;/ul>
&lt;p>这样，地址结构就由段号、段内页号和页内位移三部分组成。&lt;/p>
&lt;p>用于段页式地址变换的数据结构是每一个程序一张段表，每个段又建立一张页表，段表中的地址是页表的起始地址，而页表中的地址则为某页的物理页号，如图所示：&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/odexpg/1616167919172-07b25f4c-02c8-47f2-a784-d89ba249e13e.jpeg" alt="">&lt;/p>
&lt;p>段页式管理中的段表、页表与内存的关系&lt;/p>
&lt;p>段页式地址变换中要得到物理地址须经过三次内存访问：&lt;/p>
&lt;ul>
&lt;li>第一次访问段表，得到页表起始地址；&lt;/li>
&lt;li>第二次访问页表，得到物理页号；&lt;/li>
&lt;li>第三次将物理页号与页内位移组合，得到物理地址。&lt;/li>
&lt;/ul>
&lt;p>可用软、硬件相结合的方法实现段页式地址变换，这样虽然增加了硬件成本和系统开销，但提高了内存的利用率。&lt;/p>
&lt;h1 id="linux-内存管理">Linux 内存管理&lt;/h1>
&lt;p>那么，Linux 操作系统采用了哪种方式来管理内存呢？&lt;/p>
&lt;p>在回答这个问题前，我们得先看看 Intel 处理器的发展历史。&lt;/p>
&lt;p>早期 Intel 的处理器从 80286 开始使用的是段式内存管理。但是很快发现，光有段式内存管理而没有页式内存管理是不够的，这会使它的 X86 系列会失去市场的竞争力。因此，在不久以后的 80386 中就实现了对页式内存管理。也就是说，80386 除了完成并完善从 80286 开始的段式内存管理的同时还实现了页式内存管理。&lt;/p>
&lt;p>但是这个 80386 的页式内存管理设计时，没有绕开段式内存管理，而是建立在段式内存管理的基础上，这就意味着，页式内存管理的作用是在由段式内存管理所映射而成的的地址上再加上一层地址映射。&lt;/p>
&lt;p>由于此时段式内存管理映射而成的地址不再是“物理地址”了，Intel 就称之为“线性地址”（也称虚拟地址）。于是，段式内存管理先将逻辑地址映射成线性地址，然后再由页式内存管理将线性地址映射成物理地址。&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/odexpg/1616167919178-17fb261b-55fa-44ac-a553-ed8a842e9080.jpeg" alt="">&lt;/p>
&lt;p>Intel X86 逻辑地址解析过程&lt;/p>
&lt;p>这里说明下逻辑地址和线性地址：&lt;/p>
&lt;ul>
&lt;li>程序所使用的地址，通常是没被段式内存管理映射的地址，称为逻辑地址；&lt;/li>
&lt;li>通过段式内存管理映射的地址，称为线性地址，也叫虚拟地址；&lt;/li>
&lt;/ul>
&lt;p>逻辑地址是「段式内存管理」转换前的地址，线性地址则是「页式内存管理」转换前的地址。&lt;/p>
&lt;p>了解完 Intel 处理器的发展历史后，我们再来说说 Linux 采用了什么方式管理内存？&lt;/p>
&lt;p>Linux 内存主要采用的是页式内存管理，但同时也不可避免地涉及了段机制。&lt;/p>
&lt;p>这主要是上面 Intel 处理器发展历史导致的，因为 Intel X86 CPU 一律对程序中使用的地址先进行段式映射，然后才能进行页式映射。既然 CPU 的硬件结构是这样，Linux 内核也只好服从 Intel 的选择。&lt;/p>
&lt;p>但是事实上，Linux 内核所采取的办法是使段式映射的过程实际上不起什么作用。也就是说，“上有政策，下有对策”，若惹不起就躲着走。&lt;/p>
&lt;p>Linux 系统中的每个段都是从 0 地址开始的整个 4GB 虚拟空间（32 位环境下），也就是所有的段的起始地址都是一样的。这意味着，Linux 系统中的代码，包括操作系统本身的代码和应用程序代码，所面对的地址空间都是线性地址空间（虚拟地址），这种做法相当于屏蔽了处理器中的逻辑地址概念，段只被用于访问控制和内存保护。&lt;/p>
&lt;p>我们再来瞧一瞧，Linux 的虚拟地址空间是如何分布的？&lt;/p>
&lt;p>在 Linux 操作系统中，虚拟地址空间的内部又被分为内核空间和用户空间两部分，不同位数的系统，地址空间的范围也不同。比如最常见的 32 位和 64 位系统，如下所示：&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/odexpg/1616167919191-4099f869-9dbe-462c-90f6-ff02cec5a9a6.jpeg" alt="">&lt;/p>
&lt;p>用户空间与内存空间&lt;/p>
&lt;p>通过这里可以看出：&lt;/p>
&lt;ul>
&lt;li>32 位系统的内核空间占用 1G，位于最高处，剩下的 3G 是用户空间；&lt;/li>
&lt;li>64 位系统的内核空间和用户空间都是 128T，分别占据整个内存空间的最高和最低处，剩下的中间部分是未定义的。&lt;/li>
&lt;/ul>
&lt;p>再来说说，内核空间与用户空间的区别：&lt;/p>
&lt;ul>
&lt;li>进程在用户态时，只能访问用户空间内存；&lt;/li>
&lt;li>只有进入内核态后，才可以访问内核空间的内存；&lt;/li>
&lt;/ul>
&lt;p>虽然每个进程都各自有独立的虚拟内存，但是每个虚拟内存中的内核地址，其实关联的都是相同的物理内存。这样，进程切换到内核态后，就可以很方便地访问内核空间内存。&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/odexpg/1616167919223-81c46952-4cf1-4b83-a9a5-2bdd118168b6.jpeg" alt="">&lt;/p>
&lt;p>每个进程的内核空间都是一致的&lt;/p>
&lt;p>接下来，进一步了解虚拟空间的划分情况，用户空间和内核空间划分的方式是不同的，内核空间的分布情况就不多说了。&lt;/p>
&lt;p>我们看看用户空间分布的情况，以 32 位系统为例，我画了一张图来表示它们的关系：&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/odexpg/1616167919192-30c3ec2b-724a-4146-9bc4-3c630ea69e13.jpeg" alt="">&lt;/p>
&lt;p>虚拟内存空间划分&lt;/p>
&lt;p>通过这张图你可以看到，用户空间内存，从低到高分别是 7 种不同的内存段：&lt;/p>
&lt;ul>
&lt;li>程序文件段，包括二进制可执行代码；&lt;/li>
&lt;li>已初始化数据段，包括静态常量；&lt;/li>
&lt;li>未初始化数据段，包括未初始化的静态变量；&lt;/li>
&lt;li>堆段，包括动态分配的内存，从低地址开始向上增长；&lt;/li>
&lt;li>文件映射段，包括动态库、共享内存等，从低地址开始向上增长（跟硬件和内核版本有关）&lt;/li>
&lt;li>栈段，包括局部变量和函数调用的上下文等。栈的大小是固定的，一般是 8 MB。当然系统也提供了参数，以便我们自定义大小；&lt;/li>
&lt;/ul>
&lt;p>在这 7 个内存段中，堆和文件映射段的内存是动态分配的。比如说，使用 C 标准库的 malloc() 或者 mmap() ，就可以分别在堆和文件映射段动态分配内存。&lt;/p>
&lt;h1 id="总结">总结&lt;/h1>
&lt;p>为了在多进程环境下，使得进程之间的内存地址不受影响，相互隔离，于是操作系统就为每个进程独立分配一套的虚拟地址空间，每个程序只关心自己的虚拟地址就可以，实际上大家的虚拟地址都是一样的，但分布到物理地址内存是不一样的。作为程序，也不用关心物理地址的事情。&lt;/p>
&lt;p>每个进程都有自己的虚拟空间，而物理内存只有一个，所以当启用了大量的进程，物理内存必然会很紧张，于是操作系统会通过内存交换技术，把不常使用的内存暂时存放到硬盘（换出），在需要的时候再装载回物理内存（换入）。&lt;/p>
&lt;p>那既然有了虚拟地址空间，那必然要把虚拟地址「映射」到物理地址，这个事情通常由操作系统来维护。&lt;/p>
&lt;p>那么对于虚拟地址与物理地址的映射关系，可以有分段和分页的方式，同时两者结合都是可以的。&lt;/p>
&lt;p>内存分段是根据程序的逻辑角度，分成了栈段、堆段、数据段、代码段等，这样可以分离出不同属性的段，同时是一块连续的空间。但是每个段的大小都不是统一的，这就会导致内存碎片和内存交换效率低的问题。&lt;/p>
&lt;p>于是，就出现了内存分页，把虚拟空间和物理空间分成大小固定的页，如在 Linux 系统中，每一页的大小为 4KB。由于分了页后，就不会产生细小的内存碎片。同时在内存交换的时候，写入硬盘也就一个页或几个页，这就大大提高了内存交换的效率。&lt;/p>
&lt;p>再来，为了解决简单分页产生的页表过大的问题，就有了多级页表，它解决了空间上的问题，但这就会导致 CPU 在寻址的过程中，需要有很多层表参与，加大了时间上的开销。于是根据程序的局部性原理，在 CPU 芯片中加入了 TLB，负责缓存最近常被访问的页表项，大大提高了地址的转换速度。&lt;/p>
&lt;p>Linux 系统主要采用了分页管理，但是由于 Intel 处理器的发展史，Linux 系统无法避免分段管理。于是 Linux 就把所有段的基地址设为 0，也就意味着所有程序的地址空间都是线性地址空间（虚拟地址），相当于屏蔽了 CPU 逻辑地址的概念，所以段只被用于访问控制和内存保护。&lt;/p>
&lt;p>另外，Linxu 系统中虚拟空间分布可分为用户态和内核态两部分，其中用户态的分布：代码段、全局变量、BSS、函数栈、堆内存、映射区。&lt;/p></description></item><item><title>Docs: 5.登录 Linux 与 访问控制</title><link>https://desistdaydream.github.io/docs/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/5.%E7%99%BB%E5%BD%95-Linux-%E4%B8%8E-%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6/5.%E7%99%BB%E5%BD%95-Linux-%E4%B8%8E-%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/5.%E7%99%BB%E5%BD%95-Linux-%E4%B8%8E-%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6/5.%E7%99%BB%E5%BD%95-Linux-%E4%B8%8E-%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;/blockquote>
&lt;p>想要登录 Linux，必须通过 [&lt;strong>Terminal(终端)&lt;/strong>](/docs/1.操作系统/4.Terminal%20 与%20Shell/4.Terminal%20 与%20Shell.md 与 Shell.md)，我们才可以与操作系统进行交互。&lt;/p>
&lt;p>本质上，想要登录 Linux，必然需要调用某些程序(比如 Shell)，以便分配一个终端。通常，我们有多种方式可供选择：&lt;/p>
&lt;ul>
&lt;li>本地命令行登录&lt;/li>
&lt;li>远程命令行登录&lt;/li>
&lt;li>图形界面登录&lt;/li>
&lt;/ul>
&lt;p>Linux 操作系统是一个多用户操作系统，所以除了 &lt;strong>Terminal(终端)&lt;/strong> 以外，还需 &lt;strong>Account(账户)&lt;/strong> 才可以登录上去，Linux 操作系统允许多个用户访问安装在一台机器上的单个系统。每个 &lt;strong>User(用户)&lt;/strong> 都在自己的 &lt;strong>Account(账户)&lt;/strong> 下操作。因此，Account Manager 代表了 Linux 系统管理的核心要素。&lt;/p>
&lt;h1 id="登录-linux">登录 Linux&lt;/h1>
&lt;p>我们可以通过多种方式登录 Linux&lt;/p>
&lt;ul>
&lt;li>本地登录&lt;/li>
&lt;li>远程登录&lt;/li>
&lt;/ul>
&lt;h2 id="通过本地-tty-登陆-linux-系统">通过本地 TTY 登陆 Linux 系统&lt;/h2>
&lt;p>登录 Linux 最基本的方式，就是使用 &lt;code>login&lt;/code> 程序。&lt;/p>
&lt;h3 id="login-程序">login 程序&lt;/h3>
&lt;p>由于历史原因，&lt;code>login&lt;/code> 可能被包含在两个包中：&lt;/p>
&lt;ul>
&lt;li>util-linux&lt;/li>
&lt;li>shadow-utils&lt;/li>
&lt;/ul>
&lt;h4 id="login-的登录行为">login 的登录行为&lt;/h4>
&lt;p>当我们刚刚安装完操作系统，systemd-logind.service 服务会让我们看到这样的画面&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/gwpmr6/1634785246289-3a353c73-2899-4b6c-8341-ffc4a02008ef.png" alt="image.png">&lt;/p>
&lt;p>想要在服务器本地登录系统，则需要进行认证，在输入用户名之后，实际上是调用了 &lt;code>login&lt;/code> 这个二进制程序，看到：&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/gwpmr6/1634785206973-885fa7fb-3dfb-4fb1-80c8-1c56cb903974.png" alt="image.png">&lt;/p>
&lt;p>此时我们通过远程方式(如果可以的话)登录服务器，查看进程，将会看到名为 login 的进程&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>~&lt;span style="color:#f92672">]&lt;/span>$ pgrep login -alf
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">600&lt;/span> /lib/systemd/systemd-logind
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">1476&lt;/span> /bin/login -p --
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>当我们输入完密码，经过 &lt;a href="https://desistdaydream.github.io/docs/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/5.%E7%99%BB%E5%BD%95%20Linux%20%E4%B8%8E%20%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6/Access%20Control(%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6)/Access%20Control(%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6).md">Access Control(访问控制)&lt;/a> 相关程序的认证之后，login 工具会为我们分配一个 ttyX 的终端设备，然后我们就可以通过 tty 所关联的 Shell(通常是 bash)，与系统进行交互&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/gwpmr6/1634785329507-0cb1fcec-8c6e-4fd0-a99f-005a2b19807e.png" alt="image.png">&lt;/p>
&lt;h4 id="login-关联文件与配置">login 关联文件与配置&lt;/h4>
&lt;p>&lt;strong>/etc/login.defs&lt;/strong> # shadow 与 password 套件的配置文件。
&lt;strong>/etc/pam.d/login&lt;/strong> #&lt;/p>
&lt;h2 id="通过远程的方式来登陆-linux-系统">通过远程的方式来登陆 Linux 系统&lt;/h2>
&lt;h3 id="ssh-程序">ssh 程序&lt;/h3>
&lt;p>详见：&lt;a href="https://desistdaydream.github.io/docs/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/5.%E7%99%BB%E5%BD%95%20Linux%20%E4%B8%8E%20%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6/Secure%20Shell(SSH)%20%E5%AE%89%E5%85%A8%E5%A4%96%E5%A3%B3%E5%8D%8F%E8%AE%AE/Secure%20Shell(SSH)%20%E5%AE%89%E5%85%A8%E5%A4%96%E5%A3%B3%E5%8D%8F%E8%AE%AE.md">Secure Shell(SSH) 安全外壳协议&lt;/a>&lt;/p>
&lt;pre>&lt;code>root 981 1 0 Jul08 ? Ss 0:00 /usr/sbin/sshd -D
root 1947 981 0 09:05 ? Ss 0:00 \_ sshd: root@pts/0
root 1949 1947 1 09:05 pts/0 Ss 0:00 \_ -bash
root 1970 1949 0 09:05 pts/0 R+ 0:00 \_ ps -ef f
&lt;/code>&lt;/pre>
&lt;p>OpenSSH 会为用户分配一个 Pseudoterminal(伪终端，即 pts) 以便用户可以与操作系统进行交互。&lt;/p>
&lt;h1 id="登录提示信息">登录提示信息&lt;/h1>
&lt;p>通过 &lt;code>touch ~/.hushlogin&lt;/code> 命令可以为当前用户禁用欢迎信息。&lt;/p>
&lt;h2 id="motd">MOTD&lt;/h2>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Motd_(Unix)">Wiki:MOTD&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://man7.org/linux/man-pages/man5/motd.5.html">Manual(手册)，MOTD&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>&lt;strong>Message of the day(每日消息，简称 MOTD)&lt;/strong> 是一种比向所有用户发送一个邮件更有效的发送共同的信息的方式&lt;/p>
&lt;h4 id="motd-关联文件">MOTD 关联文件&lt;/h4>
&lt;p>&lt;strong>/etc/default/motd-news&lt;/strong> # 动态 MOTD 新闻信息配置，新闻信息主要是互联网相关的
&lt;strong>/etc/update-motd.d/*&lt;/strong> # MOTD 执行脚本保存路径
&lt;strong>~/.hushlogin&lt;/strong> # 该文件存在时，将为当前用户禁用 MOTD 消息
&lt;strong>/etc/pam.d/sshd&lt;/strong> # PAM 模块中可以为 sshd 配置 MOTD。&lt;/p>
&lt;h1 id="访问控制">访问控制&lt;/h1>
&lt;p>Linux 的登录与访问控制是相辅相成的，一个用户想要登录 Linux，通常来说都需要经过访问控制系统对其所使用的账户进行认证，只有认证通过后，才可以正常登录。&lt;/p>
&lt;p>一个正常的 Linux 发行版操作系统，通常都提供了多种方式&lt;/p>
&lt;ul>
&lt;li>密码&lt;/li>
&lt;li>会话&lt;/li>
&lt;li>账户锁定&lt;/li>
&lt;li>等等&amp;hellip;&amp;hellip;&lt;/li>
&lt;/ul>
&lt;h2 id="account-manager账户管理">Account Manager(账户管理)&lt;/h2>
&lt;p>详见 &lt;a href="https://desistdaydream.github.io/docs/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/5.%E7%99%BB%E5%BD%95%20Linux%20%E4%B8%8E%20%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6/Account%20Manager(%E8%B4%A6%E6%88%B7%E7%AE%A1%E7%90%86)/Account%20Manager(%E8%B4%A6%E6%88%B7%E7%AE%A1%E7%90%86).md">Account Manager(账户管理)&lt;/a>&lt;/p>
&lt;h1 id="多窗口操作">多窗口操作&lt;/h1>
&lt;p>登录服务器后，我们可以重复登录，以便在多个窗口执行不同的操作以观察服务器状态或排查问题。&lt;/p>
&lt;p>但是当我们在机房通过显示器连接到服务器时，是不像使用 ssh 命令一样方便的，但是依然可以实现多窗口操作。&lt;/p>
&lt;p>使用 &lt;code>Ctrl + Alt + F&amp;lt;X&amp;gt;&lt;/code> 快捷键，即可打开其他窗口，&lt;code>Ctrl + Alt + F2&lt;/code> 切换到第二个窗口，F1 可以切回第一个默认窗口。&lt;/p></description></item><item><title>Docs: 6.File System 管理</title><link>https://desistdaydream.github.io/docs/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2.Kernel%E5%86%85%E6%A0%B8/6.File-System-%E7%AE%A1%E7%90%86/6.File-System-%E7%AE%A1%E7%90%86/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2.Kernel%E5%86%85%E6%A0%B8/6.File-System-%E7%AE%A1%E7%90%86/6.File-System-%E7%AE%A1%E7%90%86/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Category:Computer_file_systems">Wiki-Category,Computer file systemd&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://time.geekbang.org/column/article/76876">Linux 性能优化实践-文件系统&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://mp.weixin.qq.com/s/qJdoXTv_XS_4ts9YuzMNIw">公众号，小林 coding-一口气搞懂「文件系统」，就靠这 25 张图了&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/op2fw9/1616167805545-2b948cff-7e56-4eb8-8c12-3851fd6c2e36.png" alt="">&lt;/p>
&lt;blockquote>
&lt;p>图片来源：&lt;a href="https://www.thomas-krenn.com/en/wiki/Linux_Storage_Stack_Diagram">https://www.thomas-krenn.com/en/wiki/Linux_Storage_Stack_Diagram&lt;/a>
从上面的结构可以看到，文件系统的作用就是用来接收用户的操作，并将数据保存到物理硬盘的。可以想见，如果没有文件系统帮助用户操作，那么人们又怎么能将数据保存到存储设备上呢~&lt;/p>
&lt;/blockquote>
&lt;p>&lt;strong>File System(文件系统，简称 FS)&lt;/strong> 是一种对存储设备上的数据，进行组织管理的机制。组织方式的不同，就会形成不同的文件系统。&lt;/p>
&lt;p>如果没有文件系统，放置在存储介质中的数据将是一个庞大的数据主体，无法分辨一个数据在哪里停止以及下一个数据在哪里开始。通过将数据分成多个部分并给每个部分命名，可以轻松地隔离和识别数据。每组数据称为 &lt;strong>File(文件)&lt;/strong>。所以，用于管理这些文件及其名称的&lt;strong>结构和逻辑规则&lt;/strong>，称为 &lt;strong>File System(文件系统)&lt;/strong>。&lt;/p>
&lt;h2 id="什么是-file文件">什么是 File(文件)&lt;/h2>
&lt;p>详见《&lt;a href="https://desistdaydream.github.io/docs/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2.Kernel(%E5%86%85%E6%A0%B8)/6.File%20System%20%E7%AE%A1%E7%90%86/%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86/%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86.md">文件管理&lt;/a>》章节&lt;/p>
&lt;h1 id="文件组织结构">文件组织结构&lt;/h1>
&lt;blockquote>
&lt;p>文件管理详解见&lt;a href="https://desistdaydream.github.io/docs/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2.Kernel(%E5%86%85%E6%A0%B8)/6.File%20System%20%E7%AE%A1%E7%90%86/%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86/%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86.md">单独章节&lt;/a>&lt;/p>
&lt;/blockquote>
&lt;p>为了方便管理，Linux 的文件系统为每个文件都分配了两个数据结构。&lt;/p>
&lt;ul>
&lt;li>&lt;strong>index node(索引节点，简称 inode)&lt;/strong> # 记录文件的元数据。inode 编号、文件大小、访问权限、修改日期、数据的位置等。
&lt;ul>
&lt;li>inode 和文件一一对应，它跟文件内容一样，都会被持久化到存储的磁盘中。所以&lt;strong>inode 同样占用磁盘空间&lt;/strong>。&lt;/li>
&lt;li>inode 包含文件的元数据，具体来说有以下内容：
&lt;ul>
&lt;li>文件的字节数&lt;/li>
&lt;li>文件拥有者的 User ID&lt;/li>
&lt;li>文件的 Group ID&lt;/li>
&lt;li>文件的读、写、执行权限&lt;/li>
&lt;li>文件的时间戳，共有三个：ctime 指 inode 上一次变动的时间，mtime 指文件内容上一次变动的时间，atime 指文件上一次打开的时间。&lt;/li>
&lt;li>链接数，即有多少文件名指向这个 inode&lt;/li>
&lt;li>文件数据 block 的位置&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>directory entry(目录项，简称 dentry)&lt;/strong> # 记录文件的名字、inode 指针、与其他目录项的关联关系。
&lt;ul>
&lt;li>多个关联的目录项，就构成了文件系统的目录结构(&lt;strong>一个层次化的树形结构&lt;/strong>)。不过，不同于 inode，目录项是由内核维护的一个内存数据结构，所以通常也被叫做 &lt;strong>dentries(目录项缓存)。&lt;/strong>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>这个层次化的树形结构就像下图一样：
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/op2fw9/1617088781476-3d7a9ccc-e8df-4680-acc5-26f4f82aa8b5.png" alt="image.png">
&lt;strong>注意：目录项缓存记录在 slab 中，当我们使用 find 命令时，slab 中的 dentry 缓存就会增大；打开文件过多，slab 中的 dentry 缓存也会增大。&lt;/strong>&lt;/p>
&lt;p>inode 是每个文件的唯一标志，而 dentry 维护的正是文件系统的树状结构。dentry 与 inode 的关系是多对一(可以简单理解为一个文件可以有多个别名)&lt;/p>
&lt;p>下面用一个形象点的白话来描述这些概念，假如现在系统中有如下目录结构&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>~&lt;span style="color:#f92672">]&lt;/span>&lt;span style="color:#75715e"># tree --inodes&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>.
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>├── &lt;span style="color:#f92672">[&lt;/span> 2218&lt;span style="color:#f92672">]&lt;/span> dir_1 &lt;span style="color:#75715e"># 这是目录类型的文件&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>│ ├── &lt;span style="color:#f92672">[&lt;/span> 2235&lt;span style="color:#f92672">]&lt;/span> file_1 &lt;span style="color:#75715e"># 这是普通类型的文件&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>│ └── &lt;span style="color:#f92672">[&lt;/span> 2236&lt;span style="color:#f92672">]&lt;/span> file_2
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>├── &lt;span style="color:#f92672">[&lt;/span>269167463&lt;span style="color:#f92672">]&lt;/span> dir_2
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>│ └── &lt;span style="color:#f92672">[&lt;/span>269167464&lt;span style="color:#f92672">]&lt;/span> file_3
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>└── &lt;span style="color:#f92672">[&lt;/span>537384536&lt;span style="color:#f92672">]&lt;/span> dir_3
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ├── &lt;span style="color:#f92672">[&lt;/span> 2235&lt;span style="color:#f92672">]&lt;/span> fie_1_ln
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> └── &lt;span style="color:#f92672">[&lt;/span>537384537&lt;span style="color:#f92672">]&lt;/span> file_4
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">3&lt;/span> directories, &lt;span style="color:#ae81ff">5&lt;/span> files
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>可以这么描述上述看到的内容：dir_1、file_1、dir_2 这些名称都是 dentry 中的文件名，&lt;code>[]&lt;/code> 中的数字是 inode 号，每个 dentry 都会与 inode 关联。其中 file_1 和 file_1_ln 的 inode 相同，但是 dentry 不同，这就对应了 dentry 与 inode 是多对一的关系。而哪些文件在哪个目录中，则是由每个文件的 dentry 中的关联关系来决定。比如 dir_1 目录中，包含了 file_1 和 file_2 文件。&lt;/p>
&lt;blockquote>
&lt;p>索引节点和目录项记录了文件的元数据，以及文件间的目录关系，那么具体来说，文件数据到底是怎么存储的呢？是不是直接写到磁盘中就好了呢？
实际上，磁盘读写的最小单位是扇区，然而扇区只有 512B 大小，如果每次都读写这么小的单位，效率一定很低。所以，文件系统又把连续的扇区组成了逻辑块，然后每次都以逻辑块为最小单元，来管理数据。常见的逻辑块大小为 4KB，也就是由连续的 8 个扇区组成。&lt;/p>
&lt;/blockquote>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/op2fw9/1616167805558-180916c2-cc19-40a0-b8f4-3ff805929883.png" alt="">&lt;/p>
&lt;p>注意：&lt;/p>
&lt;ul>
&lt;li>dentry 本身只是一个存储在内存中的缓存，而 inode 则是存储在磁盘中的数据。由于内存的 Buffer 和 Cache 原理，所以 inode 也会缓存到内存中，以便加速文件的访问。&lt;/li>
&lt;li>磁盘在执行文件系统格式化时，会被分成三个存储区域，超级快、索引节点区、数据区块
&lt;ul>
&lt;li>超级块 # 存储整个文件系统的状态&lt;/li>
&lt;li>索引节点区 # 存储 inode&lt;/li>
&lt;li>数据区块 # 存储文件数据&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>我们不可能把超级块和索引节点区全部加载到内存，这样内存肯定撑不住，所以只有当需要使用的时候，才将其加载进内存，它们加载进内存的时机是不同的：
&lt;ul>
&lt;li>超级块 # 当文件系统挂载时进入内存；&lt;/li>
&lt;li>索引节点区 # 当文件被访问时进入内存&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>dentry、inode、逻辑块以及超级块构成了 Linux 文件系统的四大基本要素。&lt;/p>
&lt;h2 id="小结">小结&lt;/h2>
&lt;p>通过上面的描述，文件在文件系统中，也就可以归纳为两个部分&lt;/p>
&lt;ul>
&lt;li>指针部分 # 指针位于文件系统的元数据中，在将数据删除后，这个指针就从元数据中清除了(元数据其实就是上文的 inode 与 dentry)。&lt;/li>
&lt;li>数据部分 # 文件的具体内容，存储在磁盘中。&lt;/li>
&lt;/ul>
&lt;p>平时我们在删除数据时，其实仅仅从元数据中删除了数据对应的指针。当指针被删除时，其原本占用的空间就可以被覆盖并写入新内容。&lt;/p>
&lt;h2 id="常见问题">常见问题&lt;/h2>
&lt;ul>
&lt;li>这也是为什么我们可以恢复数据的原因，只要旧数据还没被覆盖，就依然可以获取到。&lt;/li>
&lt;li>有时候在删除文件时，会发现并没有释放空间，也是同样的道理，当某个进程持续写入内容时，如果强制删除了文件，由于进程锁定文件对应的指针部分并不会从元数据中清除，而由于指针并未删除，系统内核就默认文件并未删除，因此查询文件系统空间时，显示空间并未释放。可以通过 lsof 命令筛选 deleted 查找这些有问题的文件。&lt;/li>
&lt;/ul>
&lt;h1 id="virtual-file-system虚拟文件系统">Virtual File System(虚拟文件系统)&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Virtual_file_system">Wiki,，Virtual file system&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://zhuanlan.zhihu.com/p/69289429">知乎&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://time.geekbang.org/column/article/76876">极客-Linux 性能优化实践&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>&lt;strong>Virtual File System(虚拟文件系统，简称 VFS)&lt;/strong> 是 Linux 为了支持多种多样的文件系统，在用户空间进程和文件系统中间，引入的一个抽象层。VFS 的目的是运行客户端应用程序以统一的方式访问不同类型的文件系统。VFS &lt;strong>定义了&lt;/strong>一组所有文件系统都支持的&lt;strong>数据结构和标准 API&lt;/strong>。这样，用户进程和内核中的其他子系统，只需要跟 VFS 提供的统一接口进行交互即可，而不需要关系底层各种文件系统的实现细节。&lt;/p>
&lt;blockquote>
&lt;p>比如不同文件系统的调用函数不一样，如果没有 VFS ，那么在使用的时候，就需要为特定的文件系统，编写不同的调用方式，非常繁琐复杂。&lt;/p>
&lt;p>比如 VFS 可以用来弥合 Windows、MacOS、Unix 文件系统中的差异，以便应用程序可以访问那些类型的本地文件系统上的文件，而不必知道它们正在访问哪种文件系统。&lt;/p>
&lt;/blockquote>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/op2fw9/1616167805621-09dbf293-4f9a-4892-8e30-8d33f32031c4.png" alt="">&lt;/p>
&lt;p>举个例子，Linux 用户程序可以通过&lt;code>read()&lt;/code> 来读取&lt;code>ext4&lt;/code>、&lt;code>NFS&lt;/code>、&lt;code>XFS&lt;/code>等文件系统的文件，也可以读取存储在&lt;code>SSD&lt;/code>、&lt;code>HDD&lt;/code>等不同存储介质的文件，无须考虑不同文件系统或者不同存储介质的差异。&lt;/p>
&lt;p>通过 VFS 系统，Linux 提供了通用的系统调用，可以跨越不同文件系统和介质之间执行，极大简化了用户访问不同文件系统的过程。另一方面，新的文件系统、新类型的存储介质，可以无须编译的情况下，动态加载到 Linux 中。&lt;/p>
&lt;p>&amp;ldquo;一切皆文件&amp;quot;是 Linux 的基本哲学之一，不仅是普通的文件，包括目录、字符设备、块设备、套接字等，都可以以文件的方式被对待。实现这一行为的基础，正是 Linux 的虚拟文件系统机制。&lt;/p>
&lt;p>VFS 之所以能够衔接各种各样的文件系统，是因为它抽象了一个通用的文件系统模型，定义了通用文件系统都支持的、概念上的接口。新的文件系统只要支持并实现这些接口，并注册到 Linux 内核中，即可安装和使用。&lt;/p>
&lt;p>再举个例子，比如 Linux 写一个文件：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>int ret &lt;span style="color:#f92672">=&lt;/span> write&lt;span style="color:#f92672">(&lt;/span>fd, buf, len&lt;span style="color:#f92672">)&lt;/span>;
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>调用了 &lt;code>write()&lt;/code> 系统调用，它的过程简要如下：&lt;/p>
&lt;ul>
&lt;li>首先，勾起 VFS 通用系统调用&lt;code>sys_write()&lt;/code>处理。&lt;/li>
&lt;li>接着，&lt;code>sys_write()&lt;/code> 根据&lt;code>fd&lt;/code>找到所在的文件系统提供的写操作函数，比如 &lt;code>op_write()&lt;/code>。&lt;/li>
&lt;li>最后，调用 &lt;code>op_write()&lt;/code> 实际的把数据写入到文件中。&lt;/li>
&lt;/ul>
&lt;p>操作示意图如下：
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/op2fw9/1616167805551-1b23e389-6142-4e11-8ef1-b1b1c1722cbe.jpeg" alt="">&lt;/p>
&lt;h1 id="文件系统类型">文件系统类型&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/File_system#Types_of_file_systems">Wiki，File system-Types_of_file_systems&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>可以通过 &lt;strong>/proc/filesystems&lt;/strong> 文件查看当前内核所支持的文件系统类型&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>~&lt;span style="color:#f92672">]&lt;/span>&lt;span style="color:#75715e"># cat /proc/filesystems&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>nodev sysfs
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>...
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>nodev proc
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>...
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>nodev cgroup2
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>nodev tmpfs
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>nodev devtmpfs
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>nodev configfs
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>...
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> xfs
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>...
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ext4
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>...
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ul>
&lt;li>第一列说明文件系统是否需要挂载在一个块设备上
&lt;ul>
&lt;li>nodev 表明本行的文件系统类型不需要挂接在块设备上。凡是没有 nodev 的类型，通常来说都是磁盘文件系统。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>第二列是内核支持的文件系统类型。&lt;/li>
&lt;/ul>
&lt;p>当系统中安装了某个文件系统的驱动，则该文件内容也会有增加，比如我安装了 nfs-utils 包，则该文件还会增加 nfs 行。&lt;/p>
&lt;h2 id="按照存储位置分类">按照存储位置分类&lt;/h2>
&lt;ul>
&lt;li>&lt;strong>Disk file systems(磁盘文件系统)&lt;/strong>
&lt;ul>
&lt;li>基于磁盘的文件系统，也就是把数据直接存储到计算机本地挂载磁盘中。常见的 &lt;strong>ext4、xfs&lt;/strong> 等，都是这类文件系统&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>Network File Systems(网络文件系统)&lt;/strong>
&lt;ul>
&lt;li>网络文件系统是充当远程文件访问协议的客户端的文件系统，提供对服务器上文件的访问。 使用本地接口的程序可以透明地创建，管理和访问远程网络连接计算机中的分层目录和文件。 网络文件系统的示例包括 NFS，AFS，SMB 协议的客户端，以及 FTP 和 WebDAV 的类似于文件系统的客户端。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>Distributed File System(分布式文件系统)&lt;/strong> # 使用网络协议的分布式文件系统也属于网络文件系统的一种。&lt;/li>
&lt;li>&lt;strong>Special-purpose File Systems(特殊目的文件系统)&lt;/strong> # 特殊的文件系统将操作系统的非文件元素显示为文件，以便可以使用文件系统 API 对其进行操作。 这种文件系统一般都是基于内存的，不需要任何磁盘为其分配存储空间，但会占用内存。
&lt;ul>
&lt;li>&lt;strong>device file system(设备文件系统)&lt;/strong> # 简称 devfs，设备文件系统将 I/O 设备和伪设备表示为文件，称为设备文件。 默认挂载到&lt;code>/dev&lt;/code>目录下。&lt;/li>
&lt;li>&lt;strong>Proc File System(进程文件系统)&lt;/strong> # 简称_ _procfs，将进程以及 Linux 上的其他操作系统结构映射到文件空间。默认挂载到&lt;code>/proc&lt;/code>目录下。&lt;/li>
&lt;li>&lt;strong>configfs&lt;/strong> 和 &lt;strong>sysfs&lt;/strong> 提供了可用于向内核查询信息并在内核中配置实体的文件。&lt;/li>
&lt;li>等等&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h1 id="文件系统的使用">文件系统的使用&lt;/h1>
&lt;blockquote>
&lt;p>和 DOS 等操作系统不同，Linux 操作系统中文件系统并不是由驱动器号或驱动器名称（如 A: 或 C: 等）来标识的。Linux 操作系统将独立的文件系统组合成了一个层次化的树形结构，并且由一个单独的实体代表这一文件系统。&lt;/p>
&lt;/blockquote>
&lt;p>Linux 将新的文件系统通过 &lt;a href="https://desistdaydream.github.io/docs/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2.Kernel(%E5%86%85%E6%A0%B8)/6.File%20System%20%E7%AE%A1%E7%90%86/Mount(%E6%8C%82%E8%BD%BD).md">&lt;strong>Mount(挂载)&lt;/strong>&lt;/a> 操作将其挂载到某个目录上，从而让不同的文件系统结合成为一个整体。&lt;/p>
&lt;p>这些文件系统，要先挂载到 VFS 目录树中的某个子目录（称为挂载点），然后才能访问其中的文件。拿第一类，也就是基于磁盘的文件系统为例，在安装系统时，要先挂载一个根目录&lt;code>/&lt;/code>，在根目录下再把其他文件系统（比如其他的磁盘分区、/proc 文件系统、/sys 文件系统、NFS 等）挂载进来。&lt;/p>
&lt;h1 id="文件系统-io">文件系统 I/O&lt;/h1>
&lt;p>把文件系统挂载到挂载点后，就可以通过挂载点访问它管理的文件了。 VFS 提供了一组标准的文件访问接口。这些接口以系统调用的方式，提供给应用程序使用。&lt;/p>
&lt;p>就比如 cat 命令，首先调用 &lt;code>openat()&lt;/code> 打开一个文件，然后调用 &lt;code>read()&lt;/code> 读取文件内容，最后调用 &lt;code>write()&lt;/code> 将内容输出到控制台的标准输出中&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>~&lt;span style="color:#f92672">]&lt;/span>&lt;span style="color:#75715e"># strace -e openat,read,write cat /root/test&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>......
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>openat&lt;span style="color:#f92672">(&lt;/span>AT_FDCWD, &lt;span style="color:#e6db74">&amp;#34;/root/test&amp;#34;&lt;/span>, O_RDONLY&lt;span style="color:#f92672">)&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">3&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>read&lt;span style="color:#f92672">(&lt;/span>3, &lt;span style="color:#e6db74">&amp;#34;Test I/O for File System&amp;#34;&lt;/span>, 131072&lt;span style="color:#f92672">)&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">24&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>write&lt;span style="color:#f92672">(&lt;/span>1, &lt;span style="color:#e6db74">&amp;#34;Test I/O for File System&amp;#34;&lt;/span>, 24Test I/O &lt;span style="color:#66d9ef">for&lt;/span> File System&lt;span style="color:#f92672">)&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">24&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>......
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># 代码中的方法如下：open() 与 openat() 这两个调用效果一样。&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>int open&lt;span style="color:#f92672">(&lt;/span>const char *pathname, int flags, mode_t mode&lt;span style="color:#f92672">)&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>ssize_t read&lt;span style="color:#f92672">(&lt;/span>int fd, void *buf, size_t count&lt;span style="color:#f92672">)&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>ssize_t write&lt;span style="color:#f92672">(&lt;/span>int fd, const void *buf, size_t count&lt;span style="color:#f92672">)&lt;/span>;
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>文件读写方式的各种差异，导致 I/O 的分类多种多样。最常见的有，缓冲与非缓冲 I/O、直接与非直接 I/O、阻塞与非阻塞 I/O、同步与异步 I/O 等。&lt;/p>
&lt;h2 id="缓冲与非缓冲-io">缓冲与非缓冲 I/O&lt;/h2>
&lt;p>根据是否利用标准库缓存&lt;/p>
&lt;ul>
&lt;li>缓冲 I/O # 利用标准库缓存来加速文件的访问，而标准库内部再通过系统调用访问文件&lt;/li>
&lt;li>非缓冲 I/O # 直接通过系统调用来访问文件，不再经过标准库缓存。&lt;/li>
&lt;/ul>
&lt;p>注意，这里所说的“缓冲”，是指标准库内部实现的缓存。比方说，你可能见到过，很多程序遇到换行时才真正输出，而换行前的内容，其实就是被标准库暂时缓存了起来。
无论缓冲 I/O 还是非缓冲 I/O，它们最终还是要经过系统调用来访问文件。而根据上一节内容，我们知道，系统调用后，还会通过页缓存，来减少磁盘的 I/O 操作。&lt;/p>
&lt;h2 id="直接与非直接-io">直接与非直接 I/O&lt;/h2>
&lt;p>根据是否利用操作系统的页缓存&lt;/p>
&lt;ol>
&lt;li>直接 I/O，是指跳过操作系统的页缓存，直接跟文件系统交互来访问文件。&lt;/li>
&lt;li>非直接 I/O 正好相反，文件读写时，先要经过系统的页缓存，然后再由内核或额外的系统调用，真正写入磁盘。&lt;/li>
&lt;/ol>
&lt;p>想要实现直接 I/O，需要你在系统调用中，指定 O_DIRECT 标志。如果没有设置过，默认的是非直接 I/O。
不过要注意，直接 I/O、非直接 I/O，本质上还是和文件系统交互。如果是在数据库等场景中，你还会看到，跳过文件系统读写磁盘的情况，也就是我们通常所说的裸 I/O。&lt;/p>
&lt;h2 id="阻塞与非阻塞-io">阻塞与非阻塞 I/O&lt;/h2>
&lt;p>根据应用程序是否阻塞自身运行&lt;/p>
&lt;ol>
&lt;li>所谓阻塞 I/O，是指应用程序执行 I/O 操作后，如果没有获得响应，就会阻塞当前线程，自然就不能执行其他任务。&lt;/li>
&lt;li>所谓非阻塞 I/O，是指应用程序执行 I/O 操作后，不会阻塞当前的线程，可以继续执行其他的任务，随后再通过轮询或者事件通知的形式，获取调用的结果。&lt;/li>
&lt;/ol>
&lt;p>比方说，访问管道或者网络套接字时，设置 O_NONBLOCK 标志，就表示用非阻塞方式访问；而如果不做任何设置，默认的就是阻塞访问。&lt;/p>
&lt;h2 id="同步与异步-io">同步与异步 I/O&lt;/h2>
&lt;p>根据是否等待响应结果&lt;/p>
&lt;ol>
&lt;li>所谓同步 I/O，是指应用程序执行 I/O 操作后，要一直等到整个 I/O 完成后，才能获得 I/O 响应。&lt;/li>
&lt;li>所谓异步 I/O，是指应用程序执行 I/O 操作后，不用等待完成和完成后的响应，而是继续执行就可以。等到这次 I/O 完成后，响应会用事件通知的方式，告诉应用程序。&lt;/li>
&lt;/ol>
&lt;p>举个例子，在操作文件时，如果你设置了 O_SYNC 或者 O_DSYNC 标志，就代表同步 I/O。如果设置了 O_DSYNC，就要等文件数据写入磁盘后，才能返回；而 O_SYNC，则是在 O_DSYNC 基础上，要求文件元数据也要写入磁盘后，才能返回。
再比如，在访问管道或者网络套接字时，设置了 O_ASYNC 选项后，相应的 I/O 就是异步 I/O。这样，内核会再通过 SIGIO 或者 SIGPOLL，来通知进程文件是否可读写。
你可能发现了，这里的好多概念也经常出现在网络编程中。比如非阻塞 I/O，通常会跟 select/poll 配合，用在网络套接字的 I/O 中。
你也应该可以理解，“Linux 一切皆文件”的深刻含义。无论是普通文件和块设备、还是网络套接字和管道等，它们都通过统一的 VFS 接口来访问。&lt;/p>
&lt;h2 id="总结">总结&lt;/h2>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/op2fw9/1616167677139-656d34bf-0195-4576-919f-2eedc4f4ba5a.png" alt="">
在前面我们知道了，I/O 是分为两个过程的：&lt;/p>
&lt;ol>
&lt;li>数据准备的过程&lt;/li>
&lt;li>数据从内核空间拷贝到用户进程缓冲区的过程&lt;/li>
&lt;/ol>
&lt;p>阻塞 I/O 会阻塞在「过程 1 」和「过程 2」，而非阻塞 I/O 和基于非阻塞 I/O 的多路复用只会阻塞在「过程 2」，所以这三个都可以认为是同步 I/O。
异步 I/O 则不同，「过程 1 」和「过程 2 」都不会阻塞。&lt;/p>
&lt;h2 id="用故事去理解这几种-io-模型">用故事去理解这几种 I/O 模型&lt;/h2>
&lt;p>举个你去饭堂吃饭的例子，你好比用户程序，饭堂好比操作系统。&lt;/p>
&lt;p>阻塞 I/O 好比，你去饭堂吃饭，但是饭堂的菜还没做好，然后你就一直在那里等啊等，等了好长一段时间终于等到饭堂阿姨把菜端了出来（数据准备的过程），但是你还得继续等阿姨把菜（内核空间）打到你的饭盒里（用户空间），经历完这两个过程，你才可以离开。&lt;/p>
&lt;p>非阻塞 I/O 好比，你去了饭堂，问阿姨菜做好了没有，阿姨告诉你没，你就离开了，过几十分钟，你又来饭堂问阿姨，阿姨说做好了，于是阿姨帮你把菜打到你的饭盒里，这个过程你是得等待的。&lt;/p>
&lt;p>基于非阻塞的 I/O 多路复用好比，你去饭堂吃饭，发现有一排窗口，饭堂阿姨告诉你这些窗口都还没做好菜，等做好了再通知你，于是等啊等（&lt;code>select&lt;/code> 调用中），过了一会阿姨通知你菜做好了，但是不知道哪个窗口的菜做好了，你自己看吧。于是你只能一个一个窗口去确认，后面发现 5 号窗口菜做好了，于是你让 5 号窗口的阿姨帮你打菜到饭盒里，这个打菜的过程你是要等待的，虽然时间不长。打完菜后，你自然就可以离开了。&lt;/p>
&lt;p>异步 I/O 好比，你让饭堂阿姨将菜做好并把菜打到饭盒里后，把饭盒送到你面前，整个过程你都不需要任何等待。&lt;/p></description></item><item><title>Docs: 6.Package 管理</title><link>https://desistdaydream.github.io/docs/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/6.Package-%E7%AE%A1%E7%90%86/Package-%E7%AE%A1%E7%90%86/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/6.Package-%E7%AE%A1%E7%90%86/Package-%E7%AE%A1%E7%90%86/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;/blockquote>
&lt;p>在 Linux 操作系统中，Package 就是指应用程序的安装包。保存 Package 的地方(网站、ISO 等)称为 &lt;strong>Repository(简称 Repo)&lt;/strong>，我们可以从各种 Linux 发行版的官方 Repo 中下载对应的可用的 Package，以安装到这些发行版的 Linux 系统中。&lt;/p>
&lt;blockquote>
&lt;p>注意：哪怕两个发行版的包管理器相同，也不代表他们的 Package 是可以公用的，比如 CentOS 和 OpenEuler 都用 yum，但是 CentOS 的 Package 是无法装在 OpenEuler 上的，安装时将会报错(比如包与包之间 &lt;strong>conflict(冲突)&lt;/strong>)&lt;/p>
&lt;/blockquote>
&lt;h1 id="linux-各发行版的官方-repo-站点">Linux 各发行版的官方 Repo 站点&lt;/h1>
&lt;ul>
&lt;li>包含很多发行版的 Repo 站点: &lt;a href="https://pkgs.org/">https://pkgs.org/&lt;/a>&lt;/li>
&lt;li>OpenEuler: &lt;a href="https://repo.openeuler.org/">https://repo.openeuler.org/&lt;/a>&lt;/li>
&lt;li>CentOS: &lt;a href="https://centos.pkgs.org/">https://centos.pkgs.org/&lt;/a>&lt;/li>
&lt;li>Ubuntu: &lt;a href="https://packages.ubuntu.com/">https://packages.ubuntu.com/&lt;/a>
&lt;ul>
&lt;li>在这里可以找到 jammy 版本(20.04 TLS)的所有软件包列表: &lt;a href="https://packages.ubuntu.com/jammy/allpackages">https://packages.ubuntu.com/jammy/allpackages&lt;/a>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul></description></item><item><title>Docs: 7.HTTP</title><link>https://desistdaydream.github.io/docs/4.%E6%95%B0%E6%8D%AE%E9%80%9A%E4%BF%A1/%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/7.HTTP/7.HTTP/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/4.%E6%95%B0%E6%8D%AE%E9%80%9A%E4%BF%A1/%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/7.HTTP/7.HTTP/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://tools.ietf.org/html/rfc2616">RFC 2616&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://developer.mozilla.org/en-US/docs/Web/HTTP">Mozilla 官方 HTTP 开发文档&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://mp.weixin.qq.com/s/bUy220-ect00N4gnO0697A">公众号-小林 coding，硬核！30 张图解 HTTP 常见的面试题&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://mp.weixin.qq.com/s/WQpxfwLArltKEjEAdOO2Pw">公众号-码海，51 张图助你彻底掌握 HTTP 协议&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>&lt;strong>HyperText Transfer Protocol(超文本传输协议，简称 HTTP)&lt;/strong>。是基于 TCP 的用于分布式、协作式、超媒体的信息系统的应用层协议。HTTP 是 &lt;a href="https://en.wikipedia.org/wiki/World_Wide_Web">World Wide Web(万维网,简称 WWW.就是我们俗称的 Web)&lt;/a> 的数据通信基础。&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/rlkp9t/1616161240441-f2958719-b738-4698-9fca-64d90f3471ba.png" alt="">&lt;/p>
&lt;h2 id="http-标准的演化">HTTP 标准的演化&lt;/h2>
&lt;blockquote>
&lt;p>参考：&lt;a href="https://www.infoq.cn/article/2014/06/http-11-updated">InfoQ 中的消息&lt;/a>&lt;/p>
&lt;/blockquote>
&lt;p>在 2014 年之前，HTTP/1.1 版本的标准为 &lt;a href="https://tools.ietf.org/html/rfc2616">RFC 2616&lt;/a>，但由于&lt;a href="https://tools.ietf.org/html/rfc7230#appendix-A.2">某些原因&lt;/a>，为了让标准更规范，HTTP/1.1 被拆分成了 6 个部分：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://tools.ietf.org/html/rfc7230">RFC7230 - HTTP/1.1&lt;/a>: Message Syntax and Routing(消息语法和路由)。这里包含 低级的消息解析 和 链接管理。&lt;/li>
&lt;li>&lt;a href="https://tools.ietf.org/html/rfc7231">RFC7231 - HTTP/1.1&lt;/a>: Semantics and Content(语意和内容)。这里面包含了 Methods、Status Codes、Headers&lt;/li>
&lt;li>RFC7232 - HTTP/1.1: Conditional Requests - e.g., If-Modified-Since&lt;/li>
&lt;li>RFC7233 - HTTP/1.1: Range Requests - getting partial content&lt;/li>
&lt;li>RFC7234 - HTTP/1.1: Caching - browser and intermediary caches&lt;/li>
&lt;li>RFC7235 - HTTP/1.1: Authentication - a framework for HTTP authentication&lt;/li>
&lt;/ul>
&lt;h2 id="http-三个部分">HTTP 三个部分&lt;/h2>
&lt;h3 id="1-协议">1. 「协议」&lt;/h3>
&lt;p>在生活中，我们也能随处可见「协议」，例如：&lt;/p>
&lt;ul>
&lt;li>刚毕业时会签一个「三方协议」；&lt;/li>
&lt;li>找房子时会签一个「租房协议」；&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/rlkp9t/1616161240448-b1263f75-a700-4431-9d6b-a99b36a58214.png" alt="">
三方协议和租房协议&lt;/p>
&lt;p>生活中的协议，本质上与计算机中的协议是相同的，协议的特点:&lt;/p>
&lt;ul>
&lt;li>「&lt;strong>协&lt;/strong>」字，代表的意思是必须有&lt;strong>两个以上的参与者&lt;/strong>。例如三方协议里的参与者有三个：你、公司、学校三个；租房协议里的参与者有两个：你和房东。&lt;/li>
&lt;li>「&lt;strong>议&lt;/strong>」字，代表的意思是对参与者的一种&lt;strong>行为约定和规范&lt;/strong>。例如三方协议里规定试用期期限、毁约金等；租房协议里规定租期期限、每月租金金额、违约如何处理等。&lt;/li>
&lt;/ul>
&lt;p>针对 HTTP &lt;strong>协议&lt;/strong>，我们可以这么理解。&lt;/p>
&lt;p>HTTP 是一个用在计算机世界里的&lt;strong>协议&lt;/strong>。它使用计算机能够理解的语言确立了一种计算机之间交流通信的规范（&lt;strong>两个以上的参与者&lt;/strong>），以及相关的各种控制和错误处理方式（&lt;strong>行为约定和规范&lt;/strong>）。&lt;/p>
&lt;h3 id="2-传输">2. 「传输」&lt;/h3>
&lt;p>所谓的「传输」，很好理解，就是把一堆东西从 A 点搬到 B 点，或者从 B 点 搬到 A 点。&lt;/p>
&lt;p>别轻视了这个简单的动作，它至少包含两项重要的信息。&lt;/p>
&lt;p>HTTP 协议是一个&lt;strong>双向协议&lt;/strong>。&lt;/p>
&lt;p>我们在上网冲浪时，浏览器是请求方 A ，百度网站就是应答方 B。双方约定用 HTTP 协议来通信，于是浏览器把请求数据发送给网站，网站再把一些数据返回给浏览器，最后由浏览器渲染在屏幕，就可以看到图片、视频了。
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/rlkp9t/1616161240434-514ef4d5-6830-46f1-9674-7c6564798dfd.png" alt="">
Request(请求) - (Response)应答&lt;/p>
&lt;p>数据虽然是在 A 和 B 之间传输，但允许中间有&lt;strong>中转或接力&lt;/strong>。&lt;/p>
&lt;p>就好像第一排的同学想传递纸条给最后一排的同学，那么传递的过程中就需要经过好多个同学（中间人），这样的传输方式就从「A &amp;lt; &amp;mdash; &amp;gt; B」，变成了「A &amp;lt;-&amp;gt; N &amp;lt;-&amp;gt; M &amp;lt;-&amp;gt; B」。&lt;/p>
&lt;p>而在 HTTP 里，需要中间人遵从 HTTP 协议，只要不打扰基本的数据传输，就可以添加任意额外的东西。&lt;/p>
&lt;p>针对&lt;strong>传输&lt;/strong>，我们可以进一步理解了 HTTP。&lt;/p>
&lt;p>HTTP 是一个在计算机世界里专门用来在&lt;strong>两点之间传输数据&lt;/strong>的约定和规范。&lt;/p>
&lt;h3 id="3-超文本">3. 「超文本」&lt;/h3>
&lt;p>HTTP 传输的内容是「超文本」。&lt;/p>
&lt;p>我们先来理解「文本」，在互联网早期的时候只是简单的字符文字，但现在「文本」的涵义已经可以扩展为图片、视频、压缩包等，在 HTTP 眼里这些都算作「文本」。&lt;/p>
&lt;p>再来理解「超文本」，它就是&lt;strong>超越了普通文本的文本&lt;/strong>，它是文字、图片、视频等的混合体，最关键有超链接，能从一个超文本跳转到另外一个超文本。&lt;/p>
&lt;p>HTML 格式的文件就是最常见的超文本了，它本身只是纯文字文件，但内部用很多标签定义了图片、视频等的链接，再经过浏览器的解释，呈现给我们的就是一个文字、有画面的网页了。&lt;/p>
&lt;h2 id="总结">总结&lt;/h2>
&lt;p>OK，经过了对 HTTP 里这三个名词的详细解释，就可以给出比「超文本传输协议」这七个字更准确更有技术含量的答案：&lt;/p>
&lt;p>&lt;strong>HTTP 是一个在计算机世界里专门在「两点」之间「传输」文字、图片、音频、视频等「超文本」数据的「约定和规范」。&lt;/strong>&lt;/p>
&lt;blockquote>
&lt;p>这里的两点可以是服务器到本地电脑，本地电脑到服务器、服务器到服务器、电脑到电脑，等等。&lt;/p>
&lt;/blockquote>
&lt;h1 id="http-请求过程概述">HTTP 请求过程概述&lt;/h1>
&lt;p>HTTP 事务由一次 &lt;strong>Client 的 Request(请求)&lt;/strong> 和 &lt;strong>Server 的 Response(响应)&lt;/strong> 组成。即 HTTP 协议是 Stateless(无状态)。(因为连接一次后就断开了，不会持久化存储任何数据)&lt;/p>
&lt;p>比如一个用户(Client 客户端)向服务器发起了一个请求，请求一个页面，在该页面输入完用户名和密码后进行登录后，如果刷新页面，那么就需要重新输入用户名和密码，因为 client 向 server 只请求了一个页面，请求完成后，连接就断开了，后续的请求是新的，没法再用以前的信息。这时候为了解决该问题，引用了 Cookie 和 Session 保持 的概念。&lt;/p>
&lt;p>相关技术&lt;/p>
&lt;ol>
&lt;li>Cookie：类似于 Token，相当于一个令牌，当访问一个 web server 的时候，server 发给 client 一个 Cookie，让 client 保存在本地，再次访问的时候，即可通过该 Cookie 识别身份&lt;/li>
&lt;li>Session(会话)保持：关联至 Cookie：当你在动态网页上访问了一些信息，比如购物车，在购物车添加一件物品，即通过 Session 功能来保存该信息，以便下次登录还能使用。否则下次登录购物车中的东西就没了&lt;/li>
&lt;/ol>
&lt;h2 id="流程简述">流程简述&lt;/h2>
&lt;ul>
&lt;li>建立或处理连接，接收请求或拒绝请求
&lt;ul>
&lt;li>建立 TCP 连接，WEB 浏览器向 Web 服务器发送请求&lt;/li>
&lt;li>web 浏览器发送请求头部信息
&lt;ul>
&lt;li>建立连接后，客户机发送一个请求给服务器，请求方式的格式为：URL、协议版本号、后面是 MIME 信息包括请求修饰符、客户机信息和可能得内容&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Server 接收请求，并应答
&lt;ul>
&lt;li>WEB 服务器接收到请求后，给予相应的响应信息，其格式为一个状态行，包括信息的协议版本号、一个成功或错误的代码，后边是 MIME 信息包括服务器信息、实体信息和可能得内容&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Server 处理请求
&lt;ul>
&lt;li>Web 服务器发送应答头信息&lt;/li>
&lt;li>Web 服务器向浏览器发送数据&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Client 访问资源
&lt;ul>
&lt;li>WEB 服务器关闭 TCP 连接&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>构建响应报文&lt;/li>
&lt;li>发送响应报文&lt;/li>
&lt;li>记录日志&lt;/li>
&lt;/ul>
&lt;h1 id="http-报文格式">HTTP 报文格式&lt;/h1>
&lt;h2 id="request-与-response-报文">Request 与 Response 报文&lt;/h2>
&lt;h3 id="request-请求报文">Request 请求报文&lt;/h3>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/rlkp9t/1616161240468-d9f13310-3f67-43b8-b5b7-b48dde683170.png" alt="">&lt;/p>
&lt;ul>
&lt;li>&lt;strong>Method&lt;/strong> # 请求方法，用于表明 Client 希望 Server 对 Resource 执行的动作。常用：GET、POST、DELETE&lt;/li>
&lt;li>&lt;strong>URL&lt;/strong> # HTTP 请求的 URL。
&lt;ul>
&lt;li>&lt;strong>Params&lt;/strong> # URL 参数。就是 URL 中的 Query 部分&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>Version&lt;/strong> # 发送给 Server 的请求的 HTTP 协议版本。&lt;/li>
&lt;li>**Headers **# 请求头。&lt;/li>
&lt;li>**Body **# 请求体。&lt;/li>
&lt;/ul>
&lt;blockquote>
&lt;p>这里面有一个要注意的地方，就是 Params 与 Headers，&lt;strong>Params 是 URL 的一部分&lt;/strong>，但是 Headers 不是。虽然两者的作用类似，都是用来定义这个请求中应该发送给对方的一些基本信息、认证信息 等等。但是在一个 HTTP 的请求中，两者所处的位置是不一样，用于不同场景。&lt;/p>
&lt;/blockquote>
&lt;p>&lt;strong>Authorization&lt;/strong> # 认证信息。这是一个比较特殊的东西，可以存在于 URL 的 Params 中、Headers 中、Body 中。请求报文的各个部分，都可以填写认证信息。&lt;/p>
&lt;ul>
&lt;li>当 Server 需要一个认证信息时，就需要在 HTTP 请求中加入认证相关的信息。&lt;/li>
&lt;/ul>
&lt;h4 id="example">EXAMPLE&lt;/h4>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/rlkp9t/1616161240442-63d3fc7f-80c2-43e4-bec5-50061f2e02f2.png" alt="">&lt;/p>
&lt;h3 id="response-响应报文">Response 响应报文&lt;/h3>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/rlkp9t/1616161240462-a29c9d65-119a-4b70-993f-bd1a4cfbbd7e.png" alt="">&lt;/p>
&lt;ul>
&lt;li>&lt;strong>Version&lt;/strong> # 响应给 Client 的 HTTP 版本。&lt;/li>
&lt;li>&lt;strong>Status&lt;/strong> # HTTP 响应状态。用来标记请求过程中发生的情况，由 server 告诉 client。响应状态由两部分组成&lt;/li>
&lt;li>&lt;strong>StatusCode&lt;/strong> # 状态码。统一为 3 位的数字。
&lt;ul>
&lt;li>各个状态码的含义，见&lt;a href="https://www.yuque.com/go/doc/33218939">状态码详解章节&lt;/a>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>**ReasonPhrase **# 原因短语。用来表示产生该状态的原因的简要说明&lt;/li>
&lt;li>&lt;strong>Headers&lt;/strong> # 响应头。&lt;/li>
&lt;li>&lt;strong>Body&lt;/strong> # 响应体。实体部分，请求时附加的数据或响应时附加的数据&lt;/li>
&lt;/ul>
&lt;h4 id="example-1">EXAMPLE&lt;/h4>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/rlkp9t/1616161240440-85fac56c-d3ed-44dc-94f3-20d60017e622.png" alt="">&lt;/p>
&lt;h2 id="http-header">HTTP Header&lt;/h2>
&lt;blockquote>
&lt;p>参考：&lt;a href="https://tools.ietf.org/html/rfc2616">RFC 2616&lt;/a>&lt;/p>
&lt;/blockquote>
&lt;p>HTTP 请求和响应报文的 Header(头) 基本都是 Key/Value(键值) 格式，Key 与 Value 以冒号分隔，此外，除了标准的头部字段之外，还可以添加自定义头，这就给 HTTP 带来了无限的扩展可能。注意，Value 不区分大小写。&lt;/p>
&lt;p>HTTP 协议规定了非常多的 Header 字段，可以实现各种各样的功能，但基本上可以分为以下四类&lt;/p>
&lt;ol>
&lt;li>&lt;strong>General Header(通用头)&lt;/strong> # 在请求头和响应头里都可以出现；&lt;/li>
&lt;li>&lt;strong>Request Header(请求头)&lt;/strong> # 仅能出现在请求头里，进一步说明请求信息或者额外的附加条件；&lt;/li>
&lt;li>&lt;strong>Response Header(响应头)&lt;/strong> # 仅能出现在响应头里，补充说明响应报文的信息；&lt;/li>
&lt;li>&lt;strong>Entity Header(实体头)&lt;/strong> # 它实际上属于通用字段，但专门描述 body 的额外信息。&lt;/li>
&lt;li>&lt;strong>Extension Header(扩展头)&lt;/strong> # 不在标准规范中，可以通过自定义头实现更多定制化需求的 Header 信息。&lt;/li>
&lt;/ol>
&lt;p>&lt;strong>对 HTTP 报文的解析和处理其实本质上就是对头字段的处理&lt;/strong>，HTTP 的连接管理，缓存控制，内容协商等都是通过头字段来处理的，&lt;strong>理解了头字段，基本上也就理解了 HTTP&lt;/strong>，所以理解头字段非常重要。&lt;/p>
&lt;p>详见：&lt;a href="https://www.yuque.com/go/doc/33218949">HTTP 协议头部字段详解&lt;/a>&lt;/p>
&lt;p>注意：这种分类是在 RFC 2616 标准中定义的，在新的 RFC 7231 中，已经看不到这种分类了&lt;/p>
&lt;h2 id="http-的请求-method方法">HTTP 的请求 Method(方法)&lt;/h2>
&lt;p>根据 HTTP 标准，HTTP 请求可以使用多种请求方法。 HTTP 的 1.0 版本中只有三种请求方法： GET, POST 和 HEAD 方法。到了 1.1 版本时，新增加了五种请求方法：OPTIONS, PUT, DELETE, TRACE 和 CONNECT 方法。&lt;/p>
&lt;ul>
&lt;li>&lt;strong>GET&lt;/strong> # 从服务器获取了资源
&lt;ul>
&lt;li>请求指定的页面信息，并返回实体主体。&lt;/li>
&lt;li>GET 请求请提交的数据放置在 HTTP 请求协议头中，GET 方法通过 URL 请求来传递用户的输入，GET 方式的提交你需要用 Request.QueryString 来取得变量的值。&lt;/li>
&lt;li>GET 方法提交数据，可能会带来安全性的问题，数据被浏览器缓存。&lt;/li>
&lt;li>GET 请求有长度限制。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>HEAD&lt;/strong> # 只从 server 获取文档的响应首部（报文中的 Headers）
&lt;ul>
&lt;li>类似于 get 请求，只不过返回的响应中没有具体的内容，用于获取报头。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>POST&lt;/strong> # 向 server 发送要处理的数据
&lt;ul>
&lt;li>向指定资源提交数据进行处理请求（例如提交表单或者上传文件）。&lt;/li>
&lt;li>POST 请求可能会导致新的资源的建立和/或已有资源的修改。&lt;/li>
&lt;li>POST 方式提交时，你必须通过 Request.Form 来访问提交的内容&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>PUT&lt;/strong> # 将请求的主体存储在 server 上
&lt;ul>
&lt;li>从客户端向服务器传送的数据取代指定的文档的内容。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>DELETE&lt;/strong> # 请求删除 server 上通过 URL 指定的文档，DELETE 请求一般返回 3 种码
&lt;ul>
&lt;li>200（OK）——删除成功，同时返回已经删除的资源。&lt;/li>
&lt;li>202（Accepted）——删除请求已经接受，但没有被立即执行（资源也许已经被转移到了待删除区域）。&lt;/li>
&lt;li>204（No Content）——删除请求已经被执行，但是没有返回资源（也许是请求删除不存在的资源造成的）。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>OPTIONS&lt;/strong> #** **请求服务器返回对指定资源支持使用的请求方法
&lt;ul>
&lt;li>允许客户端查看服务器的性能。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>TRACE&lt;/strong> # 追踪请求到达 server 中间经过的 server agent
&lt;ul>
&lt;li>回显服务器收到的请求，主要用于测试或诊断。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h3 id="get-与-post">GET 与 POST&lt;/h3>
&lt;p>&lt;code>Get&lt;/code> 方法的含义是请求&lt;strong>从服务器获取资源&lt;/strong>，这个资源可以是静态的文本、页面、图片视频等。&lt;/p>
&lt;p>比如，你打开我的文章，浏览器就会发送 GET 请求给服务器，服务器就会返回文章的所有文字及资源。
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/rlkp9t/1649668233003-6c01ab91-90f8-4ea8-8095-5448302146e8.jpeg" alt="">
而&lt;code>POST&lt;/code> 方法则是相反操作，它向 &lt;code>URI&lt;/code> 指定的资源提交数据，数据就放在报文的 body 里。&lt;/p>
&lt;p>比如，你在我文章底部，敲入了留言后点击「提交」（&lt;strong>暗示你们留言&lt;/strong>），浏览器就会执行一次 POST 请求，把你的留言文字放进了报文 body 里，然后拼接好 POST 请求头，通过 TCP 协议发送给服务器。
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/rlkp9t/1649668232954-1a090cec-1a9c-4c11-a370-d49b4156cac3.jpeg" alt="">
GET 和 POST 方法都是安全和幂等的吗？&lt;/p>
&lt;p>先说明下安全和幂等的概念：&lt;/p>
&lt;ul>
&lt;li>在 HTTP 协议里，所谓的「安全」是指请求方法不会「破坏」服务器上的资源。&lt;/li>
&lt;li>所谓的「幂等」，意思是多次执行相同的操作，结果都是「相同」的。&lt;/li>
&lt;/ul>
&lt;p>那么很明显 &lt;strong>GET 方法就是安全且幂等的&lt;/strong>，因为它是「只读」操作，无论操作多少次，服务器上的数据都是安全的，且每次的结果都是相同的。&lt;/p>
&lt;p>&lt;strong>POST&lt;/strong> 因为是「新增或提交数据」的操作，会修改服务器上的资源，所以是&lt;strong>不安全&lt;/strong>的，且多次提交数据就会创建多个资源，所以&lt;strong>不是幂等&lt;/strong>的。&lt;/p></description></item><item><title>Docs: 7.Process 管理</title><link>https://desistdaydream.github.io/docs/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2.Kernel%E5%86%85%E6%A0%B8/7.Process-%E7%AE%A1%E7%90%86/Process-%E7%AE%A1%E7%90%86/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2.Kernel%E5%86%85%E6%A0%B8/7.Process-%E7%AE%A1%E7%90%86/Process-%E7%AE%A1%E7%90%86/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://blog.csdn.net/ljianhui/article/details/46718835">原文连接&lt;/a>，本文为 IBM RedBook 的 &lt;a href="http://users.polytech.unice.fr/~bilavarn/fichier/elec5_linux/linux_perf_and_tuning_IBM.pdf">Linux Performanceand Tuning Guidelines&lt;/a> 的 1.1 节的翻译&lt;/li>
&lt;li>&lt;a href="https://mp.weixin.qq.com/s/fzLcAkYwKhj-9hgoVkTzaw">阿里技术，CPU 飙高，系统性能问题如何排查？&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>进程管理是操作系统的最重要的功能之一。有效率的进程管理能保证一个程序平稳而高效地运行。它包括进程调度、中断处理、信号、进程优先级、上下文切换、进程状态、进度内存等。&lt;/p>
&lt;p>&lt;strong>Process(进程)&lt;/strong> 实际是运行在 CPU 中的一个&lt;strong>Program(应用程序) 的实体&lt;/strong>。在 Linux 系统中，能够同时运行多个进程，Linux 通过在短的时间间隔内轮流运行这些进程而实现“多任务”。这一短的时间间隔称为“时间片”，让进程轮流运行的方法称为“进程调度” ，完成调度的程序称为调度程序。&lt;/p>
&lt;p>进程调度控制进程对 CPU 的访问。当需要选择下一个进程运行时，由调度程序选择最值得运行的进程。可运行进程实际上是仅等待 CPU 资源的进程，如果某个进程在等待其它资源，则该进程是不可运行进程。Linux 使用了比较简单的基于优先级的进程调度算法选择新的进程。&lt;/p>
&lt;p>通过多任务机制，每个进程可认为只有自己独占计算机，从而简化程序的编写。每个进程有自己单独的地址空间，并且只能由这一进程访问，这样，操作系统避免了进程之间的互相干扰以及“坏”程序对系统可能造成的危害。 为了完成某特定任务，有时需要综合两个程序的功能，例如一个程序输出文本，而另一个程序对文本进行排序。为此，操作系统还提供进程间的通讯机制来帮助完成这样的任务。Linux 中常见的进程间通讯机制有信号、管道、共享内存、信号量和套接字等。&lt;/p>
&lt;p>内核通过 SCI 提供了一个 API 来创建一个新进程(fork、exec 或 Portable Operating System Interface [POSⅨ] 函数)、停止进程(kill、exit)、并在它们之间进行通信和同步(signal 或者 POSⅨ 机制)。&lt;/p>
&lt;p>计算机实际上可以做的事情实质上非常简单，比如计算两个数的和，再比如在内存中寻找到某个地址等等。这些最基础的计算机动作被称为指令(instruction)。所谓的程序(program)，就是这样一系列指令的所构成的集合。通过程序，我们可以让计算机完成复杂的操作。程序大多数时候被存储为可执行的文件。这样一个可执行文件就像是一个菜谱，计算机可以按照菜谱作出可口的饭菜。&lt;/p>
&lt;p>Program(程序) 和 Process(进程) 的区别是什么呢?&lt;/p>
&lt;ol>
&lt;li>在很久很久以前，计算机刚出现的时候，是没有操作系统的，那时候一台机器只是运行一个程序，得出数据，后来人们为了同时运行多个程序从而研究出了操作系统，在操作系统之上可以运行多个程序&lt;/li>
&lt;li>进程是程序的一个具体实现。类似于按照食谱，真正去做菜的过程。同一个程序可以执行多次，每次都可以在内存中开辟独立的空间来装载，从而产生多个进程。不同的进程还可以拥有各自独立的 IO 接口。&lt;/li>
&lt;/ol>
&lt;p>操作系统的一个重要功能就是为进程提供方便，比如说为进程分配内存空间，管理进程的相关信息等等，就好像是为我们准备好了一个精美的厨房。&lt;/p>
&lt;h2 id="进程的生命周期">进程的生命周期&lt;/h2>
&lt;p>每一个进程都有其生命周期，例如创建、运行、终止和消除。这些阶段会在系统启动和运行中重复无数次。因此，进程的生命周期对于其性能的分析是非常重要的。下图展示了经典的进程生命周期。
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/ld23ik/1616167507353-2f676d82-88da-483c-a939-399f284d6425.jpeg" alt="">
不会关闭的常驻进程可以称为 &lt;strong>Daemon Process(守护进程，简称 Daemon)&lt;/strong>&lt;/p>
&lt;blockquote>
&lt;p>一般 daemon 的名称都会在进程名后加一个字母 d 作为 daemon 的 process，比如 vsftp 的 daemon 就是 vsftpd。&lt;/p>
&lt;/blockquote>
&lt;p>当一个进程创建一个新的进程，创建进程(父进程)的进程调用 一个 fork() 系统调用。当 fork() 系统调用被调用，它得到该新创建进程（子进程）的进程描述并调用一个新的进程 id。它复制该值到父进程进程描述到子进程中。此时整个的父进程的地址空间是没有被复制的；父子进程共享相同的地址空间。&lt;/p>
&lt;p>exec() 系统调用复制新的程序到子进程的地址空间。因为父子进程共享地址空间，写入一个新的程序的数据会引起一个分页错误。在这种情况下，内存会分配新的物理内存页给子进程。&lt;/p>
&lt;p>这个推迟的操作叫作写时复制。子进程通常运行他们自己的程序而不是与父进程运行相同的程序。这个操作避免了不必要的开销，因为复制整个地址空间是一个非常缓慢和效率低下的操作，它需要使用大量的处理器时间和资源。&lt;/p>
&lt;p>当程序已经执行完成，子进程通过调用 exit()系统调用终止。exit()系统调用释放进程大部分的数据并通过发送一个信号通知其父进程。此时，子进程是一个被叫作僵尸进程的进程（参阅 page 7 的“Zombie processes”）。&lt;/p>
&lt;p>子进程不会被完全移除直到其父进程知道其子进程的调用 wait()系统调用而终止。当父进程被通知子进程终止，它移除子进程的所有数据结构并释放它的进程描述。&lt;/p>
&lt;h2 id="父进程与子进程">父进程与子进程&lt;/h2>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/ld23ik/1616167507409-d531245f-abbe-4a2a-b575-d2ae72c6949f.jpeg" alt="">&lt;/p>
&lt;ul>
&lt;li>用颜色的线标示的两列，左侧的为进程号(PID)右侧的为父进程号(PPID)&lt;/li>
&lt;li>子进程与父进程的环境变量相同&lt;/li>
&lt;li>老进程成为新进程的父进程(parent process)，而相应的，新进程就是老的进程的子进程(child process)。一个进程除了有一个 PID 之外，还会有一个 PPID(parent PID)来存储的父进程 PID。如果我们循着 PPID 不断向上追溯的话，总会发现其源头是 init 进程。所以说，所有的进程也构成一个以 init 为根的树状结构。&lt;/li>
&lt;li>如上图所示，我们查询当前 shell 下的进程：
&lt;ul>
&lt;li>我们可以看到，第二个进程 ps 是第一个进程 bash 的子进程。&lt;/li>
&lt;li>还可以用 &lt;code>pstree&lt;/code> 命令来显示整个进程树。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>fork() 通常作为一个函数被调用。这个函数会有两次返回，将子进程的 PID 返回给父进程，0 返回给子进程。实际上，子进程总可以查询自己的 PPID 来知道自己的父进程是谁，这样，一对父进程和子进程就可以随时查询对方。&lt;/li>
&lt;li>通常在调用 fork 函数之后，程序会设计一个 if 选择结构。当 PID 等于 0 时，说明该进程为子进程，那么让它执行某些指令,比如说使用 exec 库函数(library function)读取另一个程序文件，并在当前的进程空间执行 (这实际上是我们使用 fork 的一大目的: 为某一程序创建进程)；而当 PID 为一个正整数时，说明为父进程，则执行另外一些指令。由此，就可以在子进程建立之后，让它执行与父进程不同的功能。&lt;/li>
&lt;/ul>
&lt;h3 id="子进程的-termination终结">子进程的 termination(终结)&lt;/h3>
&lt;p>当子进程终结时，它会通知父进程，并清空自己所占据的内存，并在内核里留下自己的退出信息(exit code，如果顺利运行，为 0；如果有错误或异常状况，为&amp;gt;0 的整数)。在这个信息里，会解释该进程为什么退出。父进程在得知子进程终结时，有责任对该子进程使用 wait 系统调用。这个 wait 函数能从内核中取出子进程的退出信息，并清空该信息在内核中所占据的空间。但是，如果父进程早于子进程终结，子进程就会成为一个孤儿(orphand)进程。孤儿进程会被过继给 init 进程，init 进程也就成了该进程的父进程。init 进程负责该子进程终结时调用 wait 函数。&lt;/p>
&lt;p>当然，一个糟糕的程序也完全可能造成子进程的退出信息滞留在内核中的状况（父进程不对子进程调用 wait 函数），这样的情况下，子进程成为僵尸(zombie)进程。当大量僵尸进程积累时，内存空间会被挤占。&lt;/p>
&lt;h2 id="thread线程">Thread(线程)&lt;/h2>
&lt;p>一个线程是一个单独的进程生成的一个执行单元。它与其他的线程并行地运行在同一个进程中。各个线程可以共享进程的资源，例如内存、地址空间、打开的文件等等。它们能访问相同的程序数据集。线程也被叫作轻量级的进程（Light Weight Process，LWP）。因为它们共享资源，所以每个线程不应该在同一时间改变它们共享的资源。互斥的实现、锁、序列化等是用户程序的责任。&lt;/p>
&lt;p>从性能的角度来说，创建线程的开销比创建进程少，因数创建一个线程时不需要复制资源。另一方面，进程和线程拥在调度算法上有相似的特性。&lt;strong>内核以相似的方式处理它们&lt;/strong>。
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/ld23ik/1616167507380-b6ae3b1e-b47c-454c-b3c7-9942dde4f480.jpeg" alt="">
所以，一个进程创建的线程，也是可以运行在多个 CPU 上的。
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/ld23ik/1616645843002-c07df4a7-3d7a-4969-8203-4bc20169721a.png" alt="image.png">
在现在的 Linux 实现中，线程支持 UNIX 的可移植操作系统接口（POSIX）标准库。在 Linux 操作系统中有几种可用的线程实现。以下是广泛使用的线程库：&lt;/p>
&lt;p>Linux Threads 自从 Linux 内核 2.0 起就已经被作为默认的线程实现。Linux Threads 的一些实现并不符合 POSIX 标准。Native POSIX Thread Library（NPTL）正在取代 Linux Threads。Linux Threads 在将来的 Linux 企业发行版中将不被支持。&lt;/p>
&lt;p>Native POSIX Thread Libary（NPTL）&lt;/p>
&lt;p>NPTL 最初是由红帽公司开发的。NPTL 与 POSIX 更加兼容。通过 Linux 内核 2.6 的高级特性，例如，新的 clone()系统调用、信号处理的实现等等，它具有比 LinuxThreads 更高的性能和伸缩性。&lt;/p>
&lt;p>NPTL 与 LinuxThreads 有一些不兼容。一个依赖于 LinuxThreads 的应用可能不能在 NPTL 实现中工作。&lt;/p>
&lt;p>Next Generation POSIX Thread（NGPT）&lt;/p>
&lt;p>NGPT 是一个 IBM 开发的 POSIX 线程库。现在处于维护阶段并且在未来也没有开发计划。&lt;/p>
&lt;p>使用 LD_ASSUME_KERNEL 环境变量，你可以选择在应用中使用哪一个线程库。&lt;/p>
&lt;h2 id="linux-内核代码中的-process">Linux 内核代码中的 Process&lt;/h2>
&lt;p>在 Linux 中，&lt;strong>Process(进程) 属于&lt;/strong> &lt;strong>Task(任务)&lt;/strong> 的一种类型，都被 task_struct 结构管理，该结构同时被叫作进程描述。一个进程描述包含一个运行进程所有的必要信息，例如进程标识、进程属性和构建进程的资源。如果你了解该进程构造，你就能理解对于进程的运行和性能来说，什么是重要的。&lt;/p>
&lt;p>v5.14 代码：&lt;a href="https://github.com/torvalds/linux/blob/v5.14/include/linux/sched.h#L661">include/linux/sched.h&lt;/a>&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-c" data-lang="c">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">struct&lt;/span> task_struct {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#ifdef CONFIG_THREAD_INFO_IN_TASK
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#75715e">/*
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> * For reasons of header soup (see current_thread_info()), this
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> * must be the first element of task_struct.
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> */&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">struct&lt;/span> thread_info thread_info;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#endif
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> ......
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 进程状态
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">unsigned&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span> __state;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 进程唯一标识符
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">pid_t&lt;/span> pid;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">pid_t&lt;/span> tgid;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 进程名称，上限 16 字符
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">char&lt;/span> comm[TASK_COMM_LEN];
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 打开的文件
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">struct&lt;/span> files_struct &lt;span style="color:#f92672">*&lt;/span>files;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ......
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>下图展示了进程结构相关的进程信息概述。
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/ld23ik/1616167507336-aaeec645-b9df-41c3-99ab-6bf39aed4f42.jpeg" alt="">
其实从这里能看出来，从某种角度来看，**对于内核来说并没有线程这个概念。Linux 把所有的线程都当做进程来实现，内核也没有特别的调度算法来处理线程。**线程仅仅被视为一个与其他进程共享某些资源的进程，和进程一样，每个线程也都是有自己的 &lt;code>task_struct&lt;/code>，所以在内核中，线程看起来就是一个普通的进程。线程也被称作轻量级进程，一个进程可以有多个线程，线程拥有自己独立的栈，切换也由操作系统调度。在 Linux 上可以通过 &lt;code>pthread_create()&lt;/code> 方法或者 &lt;code>clone()&lt;/code> 系统调用创建；&lt;/p>
&lt;h1 id="进程优先级和-nice-值">进程优先级和 nice 值&lt;/h1>
&lt;p>进程优先级是一个数值，它通过动态的优先级和静态的优先级来决定进程被 CPU 处理的顺序。一个拥有更高进程优先级的进程拥有更大的机率得到处理器的处理。&lt;/p>
&lt;p>内核根据进程的行为和特性使用试探算法，动态地调整调高或调低动态优先级。一个用户进程可以通过使用进程的 nice 值间接改变静态优先级。一个拥有更高静态优先级的进程将会拥有更长的时间片（进程能在处理上运行多长时间）。&lt;/p>
&lt;p>Linux 支持从 19（最低优先级）到-20（最高优先级）的 nice 值。默认值为 0。把程序的 nice 值修改为负数（使进程的优先级更高），需要以 root 身份登陆或使用 su 命令以 root 身份执行。&lt;/p>
&lt;h1 id="上下文切换">上下文切换&lt;/h1>
&lt;p>在进程运行过程中，进程的运行信息被保存于处理器的寄存器和它的缓存中。正在执行的进程加载到寄存器中的数据集被称为上下文。为了切换进程，运行中进程的上下文将会被保存，接下来的运行进程的上下文将被被恢复到寄存器中。进程描述和内核模式堆栈的区域将会用来保存上下文。这个切换被称为上下文切换。过多的上下文切换是不受欢迎的，因为处理器每次都必须清空刷新寄存器和缓存，为新的进程制造空间。它可能会引起性能问题。&lt;/p>
&lt;p>下图说明了上下文切换如何工作。
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/ld23ik/1616167507475-6f5a9385-f033-4c00-8344-2953197b973c.jpeg" alt="">&lt;/p>
&lt;h1 id="中断处理">中断处理&lt;/h1>
&lt;p>中断处理是优先级最高的任务之一。中断通常由 I/O 设备产生，例如网络接口卡、键盘、磁盘控制器、串行适配器等等。中断处理器通过一个事件通知内核（例如，键盘输入、以太网帧到达等等）。它让内核中断进程的执行，并尽可能快地执行中断处理，因为一些设备需要快速的响应。它是系统稳定的关键。当一个中断信号到达内核，内核必须切换当前的进程到一个新的中断处理进程。这意味着中断引起了上下文切换，因此大量的中断将会引起性能的下降。&lt;/p>
&lt;p>在 Linux 的实现中，有两种类型的中断。硬中断是由请求响应的设备发出的（磁盘 I/O 中断、网络适配器中断、键盘中断、鼠标中断）。软中断被用于处理可以延迟的任务（TCP/IP 操作，SCSI 协议操作等等）。你可以在 &lt;code>/proc/interrupts&lt;/code> 文件中查看硬中断的相关信息。&lt;/p>
&lt;p>在多处理器的环境中，中断被每一个处理器处理。绑定中断到单个的物理处理中能提高系统的性能。更多的细节，请参阅 4.4.2，“CPU 的中断处理亲和力”。&lt;/p>
&lt;h1 id="进程的状态">进程的状态&lt;/h1>
&lt;p>每一个进程拥有自己的状态，状态表示了进程当前在发生什么。LINUX 2.6 以后的内核中，在进程的执行期间进程的状态会发生改变，进程一般存在 7 种基础状态：D-不可中断睡眠、R-可执行、S-可中断睡眠、T-暂停态、t-跟踪态、X-死亡态、Z-僵尸态，这几种状态在 ps 命令的 man 手册中有对应解释。&lt;/p>
&lt;ul>
&lt;li>&lt;strong>D&lt;/strong>＃不间断的睡眠（通常是 IO）&lt;/li>
&lt;li>&lt;strong>R&lt;/strong> ＃正在运行或可运行（在运行队列上）&lt;/li>
&lt;li>&lt;strong>S&lt;/strong> ＃可中断的睡眠（等待事件完成）&lt;/li>
&lt;li>&lt;strong>T&lt;/strong> ＃被作业控制信号停止&lt;/li>
&lt;li>&lt;strong>t&lt;/strong>＃在跟踪过程中被调试器停止&lt;/li>
&lt;li>&lt;strong>X&lt;/strong> ＃已死（永远都不会出现）&lt;/li>
&lt;li>&lt;strong>Z&lt;/strong> ＃已终止运行（“僵尸”）的进程，已终止但未由其父进程获得&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/ld23ik/1616167507456-ca89ed8d-d8a1-4cd6-96ab-c78372840f4a.jpeg" alt="">&lt;/p>
&lt;h2 id="d-task_uninterruptible不可中断睡眠态">D (TASK_UNINTERRUPTIBLE)，不可中断睡眠态&lt;/h2>
&lt;p>顾名思义，位于这种状态的进程处于睡眠中，并且不允许被其他进程或中断(异步信号)打断。因此这种状态的进程，是无法使用 kill -9 杀死的(kill 也是一种信号)，除非重启系统(没错，就是这么头硬)。不过这种状态一般由 I/O 等待(比如磁盘 I/O、网络 I/O、外设 I/O 等)引起，出现时间非常短暂，大多很难被 PS 或者 TOP 命令捕获(除非 I/O HANG 死)。SLEEP 态进程不会占用任何 CPU 资源。&lt;/p>
&lt;h2 id="r-task_running可执行态">R (TASK_RUNNING)，可执行态&lt;/h2>
&lt;p>这种状态的进程都位于 CPU 的可执行队列中，正在运行或者正在等待运行，即不是在上班就是在上班的路上。&lt;/p>
&lt;p>在此状态下，表示进程正在 CPU 中运行或在队列中等待运行（运行队列）。&lt;/p>
&lt;h2 id="s-task_interruptible可中断睡眠态">S (TASK_INTERRUPTIBLE)，可中断睡眠态&lt;/h2>
&lt;p>不同于 D，这种状态的进程虽然也处于睡眠中，但是是允许被中断的。这种进程一般在等待某事件的发生（比如 socket 连接、信号量等），而被挂起。一旦这些时间完成，进程将被唤醒转为 R 态。如果不在高负载时期，系统中大部分进程都处于 S 态。SLEEP 态进程不会占用任何 CPU 资源。&lt;/p>
&lt;p>在此状态下，进程被暂停并等待一个某些条件状态的到达。如果一个进程处于 TASK_INTERRUPTIBLE 状态并接收到一个停止的信号，进程的状态将会被改变并中断操作。一个典型的 TASK_INTERRUPTIBLE 状态的进程的例子是一个进程等待键盘中断。&lt;/p>
&lt;h2 id="t--t-task_stopped--task_traced暂停-or-跟踪态">T &amp;amp; t (TASK_STOPPED &amp;amp; TASK_TRACED)，暂停 or 跟踪态&lt;/h2>
&lt;p>这种两种状态的进程都处于运行停止的状态。不同之处是暂停态一般由于收到 SIGSTOP、SIGTSTP、SIGTTIN、SIGTTOUT 四种信号被停止，而跟踪态是由于进程被另一个进程跟踪引起(比如 gdb 断点）。暂停态进程会释放所有占用资源。&lt;/p>
&lt;p>TASK_STOPPED 在此状态下的进程被某些信号（如 SIGINT，SIGSTOP）暂停。进程正在等待通过一个信号恢复运行，例如 SIGCONT。&lt;/p>
&lt;h2 id="z-exit_zombietask_zombie-僵尸态">Z (EXIT_ZOMBIE/TASK_ZOMBIE), 僵尸态&lt;/h2>
&lt;p>这种状态的进程实际上已经结束了，但是父进程还没有回收它的资源（比如进程的描述符、PID 等）。僵尸态进程会释放除进程入口之外的所有资源。&lt;/p>
&lt;p>当一个进程调用 exit()系统调用退出后，它的父进程应该知道该进程的终止。处于 TASK_ZOMBIE 状态的进程会等待其父进程通知其释放所有的数据结构。&lt;/p>
&lt;p>当一个进程接收到一个信号而终止，它在结束自己之前，通常需要一些时间来结束所有的任务（例如关闭打开的文件）。在这个通常非常短暂的时间内，该进程就是一个僵尸进程。&lt;/p>
&lt;p>进程已经完成所有的关闭任务后，它会向父进程报告其即将终止。有些时候，一个僵尸进程不能把自己终止，这将会引导它的状态显示为 z（zombie）。&lt;/p>
&lt;p>使用 kill 命令来关闭这样的一个进程是不可能的，因为该进程已经被认为已经死掉了。如果你不能清除僵尸进程，你可以结束其父进程，然后僵尸进程也随之消失。但是，如果父进程为 init 进程，你不能结束它。init 进程是一个非常重要的进程，因此可能需要重启系统来清除僵尸进程。&lt;/p>
&lt;h2 id="x-exit_dead-死亡态">X (EXIT_DEAD), 死亡态&lt;/h2>
&lt;p>进程的真正结束态，这种状态一般在正常系统中捕获不到。&lt;/p>
&lt;h1 id="进程内存段">进程内存段&lt;/h1>
&lt;p>进程使用其自身的内存区域来执行工作。工作的变化根据情况和进程的使用而决定。进程可以拥有不同的工作量特性和不同的数据大小需求。进程必须处理各种数据大小。为了满足需求，Linux 内核为每个进程使用动态申请内存的机制。进程内存分配的数据结构如图 1-7 所示。&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/ld23ik/1616167507458-2bbc9553-910c-4d66-9ad1-8f45893277da.jpeg" alt="">&lt;/p>
&lt;p>图 1-7 进程地址空间&lt;/p>
&lt;p>进程内存区由以下几部分组成：&lt;/p>
&lt;p>Text 段&lt;/p>
&lt;p>该区域用于存储运行代码。&lt;/p>
&lt;p>Data 段&lt;/p>
&lt;p>数据段包括三个区域。&lt;/p>
&lt;p>– Data：该区域存储已被初始化的数据，如静态变量。&lt;/p>
&lt;p>– BSS：该区域存储初始化为 0 的数据。数据被初始化为 0。&lt;/p>
&lt;p>– Heap：该区域用于根据需求使用 malloc()动态申请的内存。堆向高地址方向增长。&lt;/p>
&lt;p>Stack 段&lt;/p>
&lt;p>该区域用于存储局部变量、函数参数和返回函数的地址。栈向低地址方向增长。&lt;/p>
&lt;p>用户进程的地址空间内存分布可以使用 pmap 命令来查看。你可以使用 ps 命令来查看内存段的大小。可以参阅 2.3.10 的“pmap”，“ps 和 pstree”。&lt;/p>
&lt;h1 id="进程的-exit-code退出码">进程的 exit code(退出码)&lt;/h1>
&lt;p>在 Linux 系统中，程序可以在执行终止后传递值给其父进程，这个值被称为 &lt;strong>exit code(退出码)&lt;/strong> 或 **exit status(退出状态)**或 &lt;strong>reture status(返回码)&lt;/strong>。在 POSIX 系统中，惯例做法是当程序成功执行时 &lt;strong>exit code 为 0&lt;/strong>，当程序执行失败时 &lt;strong>exit code 非 0&lt;/strong>。&lt;/p>
&lt;p>传递状态码为何重要？如果你在命令行脚本上下文中查看状态码，答案显而易见。任何有用的脚本，它将不可避免地要么被其他脚本所使用，要么被 bash 单行脚本包裹所使用。特别是脚本被用来与自动化工具 SaltStack 或者监测工具 Nagios 配合使用。这些工具会执行脚本并检查它的状态，来确定脚本是否执行成功。&lt;/p>
&lt;p>其中最重要的原因是，即使你不定义状态码，它仍然存在于你的脚本中。如果你不定义恰当的退出码，执行失败的脚本可能会返回成功的状态，这样会导致问题，问题大小取决于你的脚本做了什么。&lt;/p>
&lt;p>Linux 提供了一个专门的变量$?来保存上个已执行命令的退出状态码。&lt;/p>
&lt;p>对于需要进行检查的命令，必须在其运行完毕后立刻查看或使用$?变量，它的值会变成由 shell 所执行的最后一条命令的退出状态码。&lt;/p>
&lt;p>一个成功结束的命令的退出状态码是 0，如果一个命令结束时有错误，退出状态码就是一个正数值（1-255）。&lt;/p>
&lt;p>Linux 上执行 exit 可使 shell 以指定的状态值退出。若不设置状态值参数，则 shell 以预设值退出。状态值 0 代表执行成功，其他值代表执行失败。exit 也可用在 script，离开正在执行的 script，回到 shell。&lt;/p>
&lt;p>Linux 错误退出状态码没有什么标准可循，但有一些可用的参考。&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/ld23ik/1616167507500-9f1aab01-171b-4ece-a6fa-9f576852a403.webp" alt="">&lt;/p>
&lt;p>关于具体的服务，相应的退出码，由开发者代码决定。&lt;/p>
&lt;p>&lt;strong>Linux 进程退出码&lt;/strong>&lt;/p>
&lt;p>&lt;a href="https://jin-yang.github.io/post/linux-process-exit-code-introduce.html">https://jin-yang.github.io/post/linux-process-exit-code-introduce.html&lt;/a>&lt;/p>
&lt;p>&lt;strong>Linux 退出状态码及 exit 命令&lt;/strong>&lt;/p>
&lt;p>&lt;a href="https://www.cnblogs.com/01-single/p/7206664.html">https://www.cnblogs.com/01-single/p/7206664.html&lt;/a>&lt;/p>
&lt;p>&lt;strong>理解 Exit Code 并学会如何在 Bash 脚本中使用&lt;/strong>&lt;/p>
&lt;p>&lt;a href="http://blog.jayxhj.com/2016/02/understanding-exit-codes-and-how-to-use-them-in-bash-scripts">http://blog.jayxhj.com/2016/02/understanding-exit-codes-and-how-to-use-them-in-bash-scripts&lt;/a>&lt;/p>
&lt;p>&lt;strong>Appendix E. Exit Codes With Special Meanings&lt;/strong>&lt;/p>
&lt;p>&lt;a href="http://www.tldp.org/LDP/abs/html/exitcodes.html">http://www.tldp.org/LDP/abs/html/exitcodes.html&lt;/a>&lt;/p>
&lt;p>&lt;strong>What is the authoritative list of Docker Run exit codes?&lt;/strong>&lt;/p>
&lt;p>&lt;a href="https://stackoverflow.com/questions/31297616/what-is-the-authoritative-list-of-docker-run-exit-codes">https://stackoverflow.com/questions/31297616/what-is-the-authoritative-list-of-docker-run-exit-codes&lt;/a>&lt;/p>
&lt;p>&lt;strong>Identifying Exit Codes and their meanings&lt;/strong>&lt;/p>
&lt;p>&lt;a href="https://support.circleci.com/hc/en-us/articles/360002341673-Identifying-Exit-Codes-and-their-meanings">https://support.circleci.com/hc/en-us/articles/360002341673-Identifying-Exit-Codes-and-their-meanings&lt;/a>&lt;/p>
&lt;p>&lt;strong>OpenShift Exit Status Codes&lt;/strong>&lt;/p>
&lt;p>&lt;a href="https://access.redhat.com/documentation/en-US/OpenShift_Online/2.0/html/Cartridge_Specification_Guide/Exit_Status_Codes.html">https://access.redhat.com/documentation/en-US/OpenShift_Online/2.0/html/Cartridge_Specification_Guide/Exit_Status_Codes.html&lt;/a>&lt;/p></description></item><item><title>Docs: 7.时间管理</title><link>https://desistdaydream.github.io/docs/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/7.%E6%97%B6%E9%97%B4%E7%AE%A1%E7%90%86/7.%E6%97%B6%E9%97%B4%E7%AE%A1%E7%90%86/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/7.%E6%97%B6%E9%97%B4%E7%AE%A1%E7%90%86/7.%E6%97%B6%E9%97%B4%E7%AE%A1%E7%90%86/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://www.nim.ac.cn/520/node/4.html">中国计量科学研究院,SI 基本单位&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>1983 年，国际计量打会讨论决定，把 1 米的定义修改为光在 1/299792458 秒内走过的距离
1967 年，国际计量大会定义：1 秒是铯 133 原子基态的两个超精细能量间跃迁对应辐射的 9192631770 个周期的持续时间。&lt;/p>
&lt;h1 id="实现-ntp-协议的工具">实现 NTP 协议的工具&lt;/h1>
&lt;p>ntpd # 在 centos8 中已不再支持，推荐使用新工具 chrony 来实现 ntp 协议
chrony #&lt;/p>
&lt;h1 id="其他管理系统时间工具">其他管理系统时间工具&lt;/h1>
&lt;h2 id="date--打印或设置系统日期和时间">date # 打印或设置系统日期和时间&lt;/h2>
&lt;h3 id="syntax语法">Syntax(语法)&lt;/h3>
&lt;p>&lt;strong>date [OPTIONS]&amp;hellip; [+FORMAT]&lt;/strong>&lt;/p>
&lt;p>可以通过 FORMAT 设置显示时间的格式&lt;/p>
&lt;p>OPTIONS&lt;/p>
&lt;ul>
&lt;li>-&lt;strong>s&lt;/strong> # 从给定的字符串中设定时间。i.e.设置时间&lt;/li>
&lt;li>&lt;strong>-d&lt;/strong> # 从给定的字符串中显示时间，而不是显示现在的时间。常用于判断给定的数字是否符合时间日期的格式 e.g.date -d 9999 +%H%M 不合法，date -d 1011 +%H%M 合法&lt;/li>
&lt;/ul>
&lt;p>FORMAT:&lt;/p>
&lt;ul>
&lt;li>&lt;code>%F&lt;/code> 年月日(年-月-日)&lt;/li>
&lt;li>&lt;code>%Y&lt;/code> 年&lt;/li>
&lt;li>&lt;code>%m&lt;/code> 月&lt;/li>
&lt;li>&lt;code>%d&lt;/code> 日&lt;/li>
&lt;li>&lt;code>%H&lt;/code> 小时&lt;/li>
&lt;li>&lt;code>%M&lt;/code> 分钟&lt;/li>
&lt;li>&lt;code>%S&lt;/code> 秒&lt;/li>
&lt;li>&lt;code>%s&lt;/code> # 从 1970-01-01 00:00:00 UTC 时间开始经过的秒。i.e. 时间戳&lt;/li>
&lt;/ul>
&lt;p>EXAMPLE&lt;/p>
&lt;ul>
&lt;li>&lt;strong>date -s 2008/05/06&lt;/strong> #&lt;/li>
&lt;li>&lt;strong>date -s 18:40:00&lt;/strong>&lt;/li>
&lt;li>**date +%H:%M **# 显示当前小时与分钟&lt;/li>
&lt;li>&lt;strong>date -d 1011 +%H%M&lt;/strong> # 显示给定的小时与分钟&lt;/li>
&lt;li>&lt;strong>date +%x &amp;ndash;&amp;gt; 10/21/2009&lt;/strong> #&lt;/li>
&lt;li>&lt;strong>date +%m/%d/%Y&lt;/strong> # 10/21/2009&lt;/li>
&lt;li>2009-10-21 15:18:17
&lt;ul>
&lt;li>**date &amp;ldquo;+%Y-%m-%d %H:%M:%S&amp;rdquo; **#&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>2021-12-20_15:41
&lt;ul>
&lt;li>&lt;strong>date +%F_%H:%M&lt;/strong>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h2 id="timedatectl-options-command--控制系统时间和日期">timedatectl [OPTIONS] [COMMAND] # 控制系统时间和日期&lt;/h2>
&lt;p>若不加任何子命令和选项，则显示日期与时间相关信息&lt;/p>
&lt;p>&lt;strong>COMMAND：&lt;/strong>&lt;/p>
&lt;p>&lt;strong>status # 显示当前时间设定。(默认 COMMAND)&lt;/strong>&lt;/p>
&lt;p>&lt;strong>set-time TIME # 设置系统时间。&lt;/strong>&lt;/p>
&lt;p>这也将相应地更新 RTC 时间。时间可以以 “2012-10-30 18:17:16” 格式指定。&lt;/p>
&lt;ul>
&lt;li>EXAMPLE
&lt;ul>
&lt;li>&lt;strong>timedatectl set-time &amp;ldquo;2020-11-5 18:17:16&amp;rdquo;&lt;/strong> # 将系统时间设置为 2020 年 11 月 5 日 18 点 17 分 16 秒&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>set-timezone ZONE # 设置系统的时区&lt;/strong>&lt;/p>
&lt;p>&lt;strong>list-timezones Show known time zones&lt;/strong>&lt;/p>
&lt;p>&lt;strong>set-local-rtc &amp;lt;true|false&amp;gt; # Control whether RTC is in local tim&lt;/strong>e&lt;/p>
&lt;p>&lt;strong>set-ntp &amp;lt;true|false&amp;gt; # 控制是否启用 NTP。&lt;/strong>&lt;/p>
&lt;h2 id="hwclock--rw--查看硬件时间bios-的">hwclock [-rw] # 查看硬件时间(BIOS 的)&lt;/h2>
&lt;p>OPTIONS&lt;/p>
&lt;ul>
&lt;li>&lt;strong>-r&lt;/strong> # 查看现有 BIOS 时间，默认为－r 参数&lt;/li>
&lt;li>&lt;strong>-w&lt;/strong> # 将现在的 linux 系统时间写入 BIOS 中&lt;/li>
&lt;/ul>
&lt;p>当我们进行完 Linux 时间的校时后，还需要以 hwclock -w 来更新 BIOS 的时间，因为每次开机的时候，系统会重新由 BIOS 将时间读出来，所以， BIOS 才是重要的时间依据。&lt;/p>
&lt;h1 id="linux-校时">Linux 校时&lt;/h1>
&lt;p>调整 linux 系统时间和时区与 Internet 时间同步&lt;/p>
&lt;p>一、修改时区：&lt;/p>
&lt;p>rm -f /etc/localtime&lt;/p>
&lt;p>ln -s /usr/share/zoneinfo/Asia/Shanghai /etc/localtime&lt;/p>
&lt;p>修改为中国的东八区&lt;/p>
&lt;h1 id="vi-etcsysconfigclock">vi /etc/sysconfig/clock&lt;/h1>
&lt;p>ZONE=&amp;ldquo;Asia/Shanghai&amp;rdquo;&lt;/p>
&lt;p>UTC=false&lt;/p>
&lt;p>ARC=false&lt;/p>
&lt;p>同步 BIOS 时钟，强制把系统时间写入 CMOS：&lt;/p>
&lt;h1 id="clock--w">clock -w&lt;/h1>
&lt;p>三、实现 Internet 时间同步（这里可以忽略上面两步）&lt;/p>
&lt;p>方法 1. 开机的时候自动网络校时：&lt;/p>
&lt;p>vi /etc/rc.d/rc.local&lt;/p>
&lt;p>/usr/sbin/ntpdate -u 192.168.0.2 192.168.0.3 192.168.0.4; /sbin/hwclock -w&lt;/p>
&lt;p>方法 2. 设定计划任务&lt;/p>
&lt;p>crontab 格式如下：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># For details see man 4 crontabs&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># Example of job definition:&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># .---------------- minute (0 - 59)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># | .------------- hour (0 - 23)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># | | .---------- day of month (1 - 31)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># | | | .------- month (1 - 12) OR jan,feb,mar,apr ...&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># | | | | .---- day of week (0 - 6) (Sunday=0 or 7) OR sun,mon,tue,wed,thu,fri,sat&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># | | | | |&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># \* \* \* \* \* command to be executed&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>设定 crontab 计划任务也有两种方式：&lt;/p>
&lt;p>1、写在/etc/crontab 里&lt;/p>
&lt;p>代码:&lt;/p>
&lt;p>00 11 * * * root ntpdate 210.72.145.44&lt;/p>
&lt;p>每天 11 点与中国国家授时中心同步时间&lt;/p>
&lt;p>每天 11 点与中国国家授时中心同步时间&lt;/p>
&lt;p>当然前提是&lt;/p>
&lt;p>apt-get install ntpdate&lt;/p>
&lt;p>代码也可是&lt;/p>
&lt;p>00 11 * * * root ntpdate us.pool.ntp.org&lt;/p>
&lt;p>2、使用命令 crontab -e&lt;/p>
&lt;p>crontab -e&lt;/p>
&lt;p>10 5 * * * root ntpdate us.pool.ntp.org;hwclock -w&lt;/p>
&lt;p>这样每天 5:10 自动进行网络校时，并同时更新 BIOS 的时间&lt;/p>
&lt;p>################################&lt;/p>
&lt;p>同步网络时间：输入 ntpdate time.nist.gov 同步网络时间&lt;/p>
&lt;p>[root@localhost ~]# ntpdate time.nist.gov&lt;/p>
&lt;p>12 Oct 17:25:01 ntpdate[2784]: step time server 132.163.4.103 offset 1147751.472254 sec&lt;/p>
&lt;p>## 出现以上信息说明同步成功 ##&lt;/p>
&lt;p>注：如提示命令不存在，直接输入：yum install ntp -y 安装 ntp 软件包&lt;/p></description></item><item><title>Docs: Account Manager(账户管理)</title><link>https://desistdaydream.github.io/docs/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/5.%E7%99%BB%E5%BD%95-Linux-%E4%B8%8E-%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6/Account-Manager%E8%B4%A6%E6%88%B7%E7%AE%A1%E7%90%86/Account-Manager%E8%B4%A6%E6%88%B7%E7%AE%A1%E7%90%86/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/5.%E7%99%BB%E5%BD%95-Linux-%E4%B8%8E-%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6/Account-Manager%E8%B4%A6%E6%88%B7%E7%AE%A1%E7%90%86/Account-Manager%E8%B4%A6%E6%88%B7%E7%AE%A1%E7%90%86/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/7/html/system_administrators_guide/ch-getting_started#sec-Managing_User_Accounts">红帽官方文档,RedHat7-管理用户账户的基础知识&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/7/html/system_administrators_guide/ch-managing_users_and_groups">红帽官方文档,RedHat7-系统管理员指南-第四章-管理用户和组&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/7/html/security_guide/index">红帽官方文档,RedHat7-安全指南&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>Linux 操作系统是一个多用户操作系统，所以除了 &lt;strong>Terminal(终端)&lt;/strong> 以外，还需 &lt;strong>Account(账户)&lt;/strong> 才可以登录上去，Linux 操作系统允许多个用户访问安装在一台机器上的单个系统。每个 User(用户) 都在自己的 Account(账户) 下操作。因此，Account Manager 代表了 Linux 系统管理的核心要素。&lt;/p>
&lt;blockquote>
&lt;p>User 与 Account 傻傻分不清楚，在 Linux 操作系统中，通常都会将 Account 称为 User，但是，这个称呼实际上并不准确。因为一个 User，比如 root，可以被多个现实世界中多个人使用，那么 root 这个 User 就会对应多个真实的 User~这种描述是非常矛盾的~~~~
只不过，随着时间的推移，人们慢慢叫习惯了，各种文档和源码也都一直使用 UID 这种名称，也就不再特别区分 Account 和 User 了。只需要知道，UID 更准确的描述应该是 AID。&lt;/p>
&lt;/blockquote>
&lt;p>同时，一个 Linux Account 也可以不代表一个真实的 User，这样的 Account 只被应用程序使用，一个应用程序使用某个 Account 运行，以便让系统更方便得对程序进行精细化控制。这种控制方式称为 &lt;strong>Access Control(访问控制)&lt;/strong>，所以，从这种角度看，Account 也可以称为 &lt;strong>Role(角色)&lt;/strong>，详见 [访问控制](/docs/1.操作系统/5.登录%20Linux%20 与%20 访问控制/Access%20Control(访问控制).md Control(访问控制).md) 章节。&lt;/p>
&lt;p>为了方便得对多个 Account 管理，可以将多个 Account 组合起来，称为 &lt;strong>Group(组)&lt;/strong>，一个 Group 就是一个或多个 Account 的集合。&lt;/p>
&lt;p>通常，Linux 将账户分为两类&lt;/p>
&lt;ul>
&lt;li>Normal Accounts(普通账户)&lt;/li>
&lt;li>System Accounts(系统账户)&lt;/li>
&lt;/ul>
&lt;p>每个账户都有一个对应的 UID 作为其唯一标识符(纯数字)。同样，每个组也有一个对应的 GID 作为其唯一标识符(纯数字)。通常来说：&lt;/p>
&lt;ul>
&lt;li>1000 以下是系统账户与保留账户 和 系统组与保留组&lt;/li>
&lt;li>1000 以上是普通账户和组&lt;/li>
&lt;/ul>
&lt;p>每当我们使用 useradd 命令新建一个普通用户时，用户的 UID 都是 1000 之后的数字，这种行为可以通过修改 /etc/login.defs 文件中的 UID_MIN、GID_MIN 等参数来改变。&lt;/p>
&lt;h2 id="password密码">Password(密码)&lt;/h2>
&lt;p>&lt;strong>Password(密码)&lt;/strong> 是用来验证用户身份的最主要方法。当用户使用一个账户登录 Linux 操作系统时，密码是用来证明账户属于该用户的一种非常高效的方式。&lt;/p>
&lt;p>Linux 系统使用 **Secure Hash Algorithm 512(SHA512)**和 &lt;strong>shadow passwords&lt;/strong>。默认情况下，账户信息保存在 /etc/passwd 文件中，对应的密码信息经过哈希后保存在 /etc/shadow 文件中。&lt;/p>
&lt;h1 id="关联文件">关联文件&lt;/h1>
&lt;p>&lt;strong>/etc/group&lt;/strong> # 账户组信息&lt;/p>
&lt;p>&lt;strong>/etc/passwd&lt;/strong> # 账户信息&lt;/p>
&lt;p>&lt;strong>/etc/shadow&lt;/strong> # 安全账户信息&lt;/p>
&lt;p>&lt;strong>/etc/login.defs&lt;/strong> # login 工具包中的配置文件，部分账户管理工具会读取该文件中的参数&lt;/p>
&lt;p>&lt;strong>/etc/pam.d/&lt;/strong> #&lt;/p>
&lt;ul>
&lt;li>./chfn&lt;/li>
&lt;li>./chpasswd&lt;/li>
&lt;li>./chsh&lt;/li>
&lt;li>./newusers&lt;/li>
&lt;li>./passwd&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>/etc/skel/&lt;/strong> # 该目录为账户目录模板。该目录下包含多个隐藏的文件，当创建用户时，会拷贝该目录下的所有文件到所创建用户的家目录中&lt;/p>
&lt;p>&lt;strong>/home/AccountName/&lt;/strong> # UserName 为该账户同名的家目录&lt;/p>
&lt;p>&lt;strong>/var/spool/mail/AccountName&lt;/strong># 该文件为该账户的邮件池&lt;/p>
&lt;p>注意：&lt;/p>
&lt;ul>
&lt;li>若 /etc/shadow 被 selinux 所管理，有的时候密码修改将会失败，报错 &lt;code>passwd: Authentication token manipulation error&lt;/code>&lt;/li>
&lt;/ul>
&lt;h1 id="账户管理工具">账户管理工具&lt;/h1>
&lt;p>Linux 系统的账户管理功能，通常由 &lt;strong>shadow-utils 包&lt;/strong> 或 &lt;strong>passwd 包&lt;/strong> 中的各种工具和库提供。&lt;/p>
&lt;blockquote>
&lt;p>在有的发行版中(比如 CentOS)，只会将 passwd 包中的 passwd 程序保留，而将其余的程序，放在名为 &lt;strong>shadow-utils&lt;/strong> 的包中。&lt;/p>
&lt;/blockquote>
&lt;p>不同的 Linux 发型，还会用到某些个别的包与主包配合提供完整的账户管理功能：&lt;/p>
&lt;ul>
&lt;li>&lt;strong>base-passwd&lt;/strong> # 这是 Ubuntu 发型版中独有的包。这个包中包含一个 &lt;code>update-passwd&lt;/code> 的程序，将会根据 /var/lib/dpkg/info/base-passwd.preinst 脚本生成 /etc/passwd 和 /etc/group 文件
&lt;ul>
&lt;li>参考：&lt;a href="https://unix.stackexchange.com/questions/470126/how-is-the-etc-passwd-file-instantiated">https://unix.stackexchange.com/questions/470126/how-is-the-etc-passwd-file-instantiated&lt;/a>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>setup&lt;/strong> # 这是 CentOS 发行版中独有的包。包含了一组重要的系统配置文件和安装文件，例如 /etc/passwd、/etc/group、/etc/shadow、/etc/profile 等等&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/oib9pm/1635476577308-bd0e79ab-ffc9-41f8-ba65-471f0a3e2918.png" alt="image.png">&lt;/p>
&lt;h2 id="useradd--添加用户">useradd # 添加用户&lt;/h2>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://man7.org/linux/man-pages/man8/useradd.8.html">Manual(手册),useradd(8)&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>useradd 程序在添加用户时，会读取 /etc/login.defs 文件中的 PASS_MAX_DAYS、PASS_MIN_DAYS、PASS_WARN_AGE 等参数，并将参数的值写入到 /etc/shadow 文件中的对应字段&lt;/p>
&lt;h3 id="syntax语法">Syntax(语法)&lt;/h3>
&lt;p>&lt;strong>useradd [OPTIONS] NAME&lt;/strong>&lt;/p>
&lt;p>OPTIONS：&lt;/p>
&lt;ul>
&lt;li>&lt;strong>-m&lt;/strong> # 自动建立用户的登入目录。&lt;/li>
&lt;li>&lt;strong>-u&lt;/strong> # 指定用户 ID 号。该值在系统中必须是唯一的。0~499 默认是保留给系统用户账号使用的，所以该值必须大于 499。&lt;/li>
&lt;li>&lt;strong>-g GID&lt;/strong> # 指定该用户的基本组 ID&lt;/li>
&lt;li>&lt;strong>-c&lt;/strong> # 加上备注文字，备注文字保存在 passwd 的备注栏中。&lt;/li>
&lt;li>-&lt;strong>d&lt;/strong> # 指定该用户的家目录，默认为 /home 目录下的与用户名同名的文件夹&lt;/li>
&lt;li>&lt;strong>-e&lt;/strong> # 指定账号的失效日期，日期格式为 MM/DD/YY，例如 06/30/12。缺省表示永久有效。&lt;/li>
&lt;li>-f # 指定在密码过期后多少天即关闭该账号。如果为 0 账号立即被停用；如果为-1 则账号一直可用。默认值为-1.&lt;/li>
&lt;li>&lt;strong>-G, &amp;ndash;groups &amp;lt;GROUPS&amp;gt;&lt;/strong> # 指定用户所属的附加群组。&lt;/li>
&lt;li>-l # 不要把用户添加到 lastlog 和 failog 中, 这个用户的登录记录不需要记载&lt;/li>
&lt;li>-M # 不要自动建立用户的登入目录。&lt;/li>
&lt;li>-n # 取消建立以用户名称为名的群组。&lt;/li>
&lt;li>-p # PASSWORD 指定新用户的密码&lt;/li>
&lt;li>-r # 建立一个系统帐号&lt;/li>
&lt;li>-s # 指定用户登入后所使用的 shell。默认值为/bin/bash。&lt;/li>
&lt;/ul>
&lt;p>EXAMPLE：&lt;/p>
&lt;ul>
&lt;li>创建一个名为 lichenhao 的用户，并设置该用户密码为 lch@password
&lt;ul>
&lt;li>useradd -m lichenhao &amp;amp;&amp;amp; echo &amp;rsquo;lch@password&amp;rsquo; | passwd lichenhao &amp;ndash;stdin&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>新增一个用户 user，并指定用户组 ftp
&lt;ul>
&lt;li>useradd -g ftp user&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>新增一个用户：user 并指定家目录为/mnt/bak/。如果没有此目录，则报错，就需要手动创建目录
&lt;ul>
&lt;li>useradd -d /mnt/back/ user&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>新增一个用户：user 并设置密码为 123456
&lt;ul>
&lt;li>useradd -p 123456 user&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>新增一个 FTP 用户：ftp2018 （无需登录系统）
&lt;ul>
&lt;li>useradd -g ftp -s /sbin/nologin ftp2018&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h2 id="userdel--删除用户">userdel # 删除用户&lt;/h2>
&lt;h3 id="syntax语法-1">Syntax(语法)&lt;/h3>
&lt;p>&lt;strong>userdel [OPTIONS] NAME&lt;/strong>&lt;/p>
&lt;p>OPTIONS：&lt;/p>
&lt;ul>
&lt;li>&lt;strong>-f, &amp;ndash;force&lt;/strong> # 强制删除&lt;/li>
&lt;li>&lt;strong>-r, &amp;ndash;remove&lt;/strong> # 删除用户的时候同时移除该用户的家目录和邮件池。不加参数的话，只会删除用户，但是不会删除在/home 目录中的用户家目录。如果你想要连此用户的家目录也一并删除，可以加上 –remove-home 这个参数&lt;/li>
&lt;li>-&lt;strong>R, &amp;ndash;root CHROOT_DIR&lt;/strong> # chroot 到的目录&lt;/li>
&lt;li>&lt;strong>-Z, &amp;ndash;selinux-user&lt;/strong> # 为用户删除所有的 SELinux 用户映射&lt;/li>
&lt;/ul>
&lt;p>EXAMPLE&lt;/p>
&lt;ul>
&lt;li>userdel -r user # 删除名为 user 的用户，同时删除该用户的家目录和邮件池文件&lt;/li>
&lt;/ul>
&lt;h2 id="usermod--修改用户">usermod # 修改用户&lt;/h2>
&lt;h3 id="syntax语法-2">Syntax(语法)&lt;/h3>
&lt;p>&lt;strong>usermod [OPTIONS] NAME&lt;/strong>&lt;/p>
&lt;p>OPTIONS：&lt;/p>
&lt;ul>
&lt;li>&lt;strong>-a, &amp;ndash;append GROUP&lt;/strong> # 将用户追加至上边 -G 中指定附加组中，并不从其它组中删除此用户&lt;/li>
&lt;li>&lt;strong>-c, &amp;ndash;comment &amp;lt;STRING&amp;gt;&lt;/strong> # GECOS 字段的新值&lt;/li>
&lt;li>&lt;strong>-d, &amp;ndash;home &amp;lt;HOME_DIR&amp;gt;&lt;/strong> # 用户的新主目录&lt;/li>
&lt;li>&lt;strong>-e, &amp;ndash;expiredate &amp;lt;EXPIRE_DATE&amp;gt;&lt;/strong> # 设定帐户过期的日期为 EXPIRE_DATE&lt;/li>
&lt;li>&lt;strong>-f, &amp;ndash;inactive INACTIVE&lt;/strong> # 过期 INACTIVE 天数后，设定密码为失效状态&lt;/li>
&lt;li>&lt;strong>-g, &amp;ndash;gid GROUP&lt;/strong> # 强制使用 GROUP 为新主组&lt;/li>
&lt;li>&lt;strong>-G, &amp;ndash;groups GROUPS&lt;/strong> # 新的附加组列表 GROUPS。将用户从该选项指定的组列表以外的组中删除。可以与 -a 选项配合，变更此行为。-a 会将用户附加到指定的组中而不删除。&lt;/li>
&lt;li>&lt;strong>-l, &amp;ndash;login LOGIN&lt;/strong> # 新的登录名称&lt;/li>
&lt;li>&lt;strong>-L, &amp;ndash;lock&lt;/strong> # 锁定用户帐号&lt;/li>
&lt;li>&lt;strong>-m, &amp;ndash;move-home&lt;/strong> # 将家目录内容移至新位置 (仅于 -d 一起使用)&lt;/li>
&lt;li>&lt;strong>-o, &amp;ndash;non-unique&lt;/strong> # 允许使用重复的(非唯一的) UID&lt;/li>
&lt;li>&lt;strong>-p, &amp;ndash;password PASSWORD&lt;/strong> # 将加密过的密码 (PASSWORD) 设为新密码&lt;/li>
&lt;li>-&lt;strong>R, &amp;ndash;root CHROOT_DIR&lt;/strong> # chroot 到的目录&lt;/li>
&lt;li>&lt;strong>-s, &amp;ndash;shell SHELL&lt;/strong> # 该用户帐号的新登录 shell&lt;/li>
&lt;li>&lt;strong>-u, &amp;ndash;uid UID&lt;/strong> # 用户帐号的新 UID&lt;/li>
&lt;li>&lt;strong>-U, &amp;ndash;unlock&lt;/strong> # 解锁用户帐号&lt;/li>
&lt;li>&lt;strong>-Z, &amp;ndash;selinux-user SEUSER&lt;/strong> # 用户账户的新 SELinux 用户映射&lt;/li>
&lt;/ul>
&lt;p>EXAMPLE&lt;/p>
&lt;ul>
&lt;li>修改 newname 用户所在群组为 test
&lt;ul>
&lt;li>usermod -g test newname&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>一次将一个用户添加到多个群组
&lt;ul>
&lt;li>usermod -G friends,happy,funny newname&lt;/li>
&lt;li>注意：使用 usermod 时要小心，因为配合-g 或-G 参数时，它会把用户从原先的群组里剔除，加入到新的群组。如果你不想离开原先的群组，又想加入新的群组，可以在-G 参数的基础上加上-a 参数，a 是英语 append 的缩写，表示“追加”。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>-a 追加用户到新的用户组，保留原来的组
&lt;ul>
&lt;li>usermod -aG happy newname&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h2 id="groupaddgroupdelgroupmodgpasswd--用户组管理相关命令">groupadd、groupdel、groupmod、gpasswd # 用户组管理相关命令&lt;/h2>
&lt;p>OPTIONS：&lt;/p>
&lt;ul>
&lt;li>-f, &amp;ndash;force 如果组已经存在则成功退出，并且如果 GID 已经存在则取消 -g&lt;/li>
&lt;li>-g, &amp;ndash;gid GID # 为新组使用 GID&lt;/li>
&lt;li>-K, &amp;ndash;key KEY=VALUE # 不使用 /etc/login.defs 中的默认值&lt;/li>
&lt;li>-o, &amp;ndash;non-unique # 允许创建有重复 GID 的组&lt;/li>
&lt;li>-p, &amp;ndash;password PASSWORD # 为新组使用此加密过的密码&lt;/li>
&lt;li>-r, &amp;ndash;system # 创建一个系统账户&lt;/li>
&lt;li>-R, &amp;ndash;root CHROOT_DIR # chroot 到的目录&lt;/li>
&lt;/ul>
&lt;p>EXAMPLE&lt;/p>
&lt;ul>
&lt;li>创建一个名为 newname 的组
&lt;ul>
&lt;li>groupadd newname&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>修改组
&lt;ul>
&lt;li>groupmod -n test2group testgroup&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>删除名为 test2group 的组
&lt;ul>
&lt;li>groupdel test2group&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>查看当前登陆用户所在的组
&lt;ul>
&lt;li>groups&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>查看 testnewuser 所在的组
&lt;ul>
&lt;li>groups testnewuser&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h2 id="who--显示当前登录用户的相关信息">who # 显示当前登录用户的相关信息&lt;/h2>
&lt;h3 id="syntax语法-3">Syntax(语法)&lt;/h3>
&lt;p>&lt;strong>who [OPTION]&amp;hellip; [ FILE | ARG1 ARG2 ]&lt;/strong>&lt;/p>
&lt;p>OPTIONS&lt;/p>
&lt;ul>
&lt;li>-a 打印能打印的全部&lt;/li>
&lt;li>-d 打印死掉的进程&lt;/li>
&lt;li>-m 同 am i,mom likes&lt;/li>
&lt;li>-q 打印当前登录用户数及用户名&lt;/li>
&lt;li>-u 打印当前登录用户登录信息&lt;/li>
&lt;li>-r 打印运行等级&lt;/li>
&lt;/ul>
&lt;p>EXAMPLE&lt;/p>
&lt;ul>
&lt;li>whoami # 要查看当前登录用户的用户名&lt;/li>
&lt;li>who am i # 表示打开当前伪终端的用户的用户名，可以简写为 who&lt;/li>
&lt;/ul>
&lt;p>who&lt;/p>
&lt;h1 id="密码管理工具">密码管理工具&lt;/h1>
&lt;h2 id="passwd--改变用户的密码">passwd # 改变用户的密码&lt;/h2>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://man7.org/linux/man-pages/man1/passwd.1.html">Manual(手册),passwd(1)&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;h3 id="syntax语法-4">Syntax(语法)&lt;/h3>
&lt;h2 id="chage--控制用户的密码到期信息">chage # 控制用户的密码到期信息&lt;/h2>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://man7.org/linux/man-pages/man1/chage.1.html">Manual(手册),chage(1)&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>passwd 软件包将会记录用户上次更改密码的时间、应该间隔多久更改一次密码 等等，chage 工具就可以对上述信息进行管理&lt;/p>
&lt;p>&lt;code>chage&lt;/code> 工具仅控制 /etc/shadow 文件中的信息，/etc/passwd 文件并不会影响到 &lt;code>chage&lt;/code> 程序的实现。并且，&lt;code>chage&lt;/code> 程序也不会报告 /etc/passwd 和 /etc/shaodw 文件的不一致情况，&lt;code>pwck&lt;/code> 工具可用于检测两个文件的不一致处。&lt;/p>
&lt;p>&lt;code>chage&lt;/code> 工具仅限于 root 用户，但是 -l 选项除外，非特权用户可以使用 -l 选项来确定自身的密码或账户合适到期。chage 可以修改 /etc/shadow 文件中多个字段的配置。&lt;/p>
&lt;h3 id="syntax语法-5">Syntax(语法)&lt;/h3>
&lt;p>&lt;strong>chage [OPTIONS] LOGIN&lt;/strong>&lt;/p>
&lt;p>&lt;strong>OPTIONS&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>&lt;strong>-d, &amp;ndash;lastday &amp;lt;INT&amp;gt;&lt;/strong> # 设置上次更改密码的日期。值是从 1970 年 1 月 1 日开始到某年某月某日的天数。
&lt;ul>
&lt;li>若指定空值，则表示从没修改过密码，即 -l 选项查看的第一行的值为 never。&lt;/li>
&lt;li>若指定 0，则用户再次登录时，则会被强制要求立刻修改密码，否则无法登录&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>-l, &amp;ndash;list&lt;/strong> # 显示账户的老化信息&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>~&lt;span style="color:#f92672">]&lt;/span>&lt;span style="color:#75715e"># chage -l root&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Last password change : Oct 01, &lt;span style="color:#ae81ff">2021&lt;/span> &lt;span style="color:#75715e"># 最后一次修改密码的时间&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Password expires : never
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Password inactive : never
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Account expires : never
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Minimum number of days between password change : &lt;span style="color:#ae81ff">0&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Maximum number of days between password change : &lt;span style="color:#ae81ff">99999&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Number of days of warning before password expires : &lt;span style="color:#ae81ff">7&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ul>
&lt;li>&lt;strong>-m, &amp;ndash;mindays &amp;lt;INT&amp;gt;&lt;/strong> # 密码可以修改的最小间隔天数。如果 INT 为 0，则表示不用等待，任何时候都可以修改密码
&lt;ul>
&lt;li>对应 shadow 文件中的第 4 个字段 minimum password age&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>-M, &amp;ndash;maxdays &amp;lt;INT&amp;gt;&lt;/strong> #
&lt;ul>
&lt;li>对应 shadow 文件中的第 5 个字段 maximum password age&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>-W, &amp;ndash;warndays &amp;lt;INT&amp;gt;&lt;/strong> #
&lt;ul>
&lt;li>对应 shadow 文件中的第 6 个字段 password warning period&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h2 id="pwck">pwck&lt;/h2></description></item><item><title>Docs: Alertmanager</title><link>https://desistdaydream.github.io/docs/6.%E5%8F%AF%E8%A7%82%E6%B5%8B%E6%80%A7/%E7%9B%91%E6%8E%A7%E7%B3%BB%E7%BB%9F/Alertmanager/Alertmanager/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/6.%E5%8F%AF%E8%A7%82%E6%B5%8B%E6%80%A7/%E7%9B%91%E6%8E%A7%E7%B3%BB%E7%BB%9F/Alertmanager/Alertmanager/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://prometheus.io/docs/alerting/latest/alertmanager/">官方文档&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>Prometheus Alert 介绍详见 Prometheus Server Alert 说明&lt;/p>
&lt;p>Alertmanager 处理由客户端应用程序（例如 Prometheus 服务器）发送的警报。它负责将重复数据删除，分组和路由到正确的接收者集成，例如电子邮件，PagerDuty 或 OpsGenie。它还负责沉默和禁止警报。&lt;/p>
&lt;p>&lt;strong>Alertmanager 特性&lt;/strong>&lt;/p>
&lt;p>Prometheus 发送过来的每一个告警，都会由 Alertmanager 进行重复数据删除、分组、路由到正确的接收者(e.g.邮件、钉钉等)上。&lt;/p>
&lt;p>Alertmanager 除了提供基本的告警通知能力以外，还主要提供了如：分组、抑制以及静默等告警特性：
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/fesx4v/1616068406984-251af31d-3e59-4621-bb62-d5228da42408.jpeg" alt="">
&lt;strong>分组&lt;/strong>
分组机制可以将详细的告警信息合并成一个通知。在某些情况下，比如由于系统宕机导致大量的告警被同时触发，在这种情况下分组机制可以将这些被触发的告警合并为一个告警通知，避免一次性接受大量的告警通知，而无法对问题进行快速定位。&lt;/p>
&lt;p>例如，当集群中有数百个正在运行的服务实例，并且为每一个实例设置了告警规则。假如此时发生了网络故障，可能导致大量的服务实例无法连接到数据库，结果就会有数百个告警被发送到 Alertmanager。&lt;/p>
&lt;p>而作为用户，可能只希望能够在一个通知中中就能查看哪些服务实例收到影响。这时可以按照服务所在集群或者告警名称对告警进行分组，而将这些告警内聚在一起成为一个通知。&lt;/p>
&lt;p>告警分组，告警时间，以及告警的接受方式可以通过 Alertmanager 的配置文件进行配置。&lt;/p>
&lt;p>&lt;strong>抑制&lt;/strong>
抑制是指当某一告警发出后，可以停止重复发送由此告警引发的其它告警的机制。&lt;/p>
&lt;p>例如，当集群不可访问时触发了一次告警，通过配置 Alertmanager 可以忽略与该集群有关的其它所有告警。这样可以避免接收到大量与实际问题无关的告警通知。&lt;/p>
&lt;p>抑制机制同样通过 Alertmanager 的配置文件进行设置。&lt;/p>
&lt;p>&lt;strong>静默&lt;/strong>
静默提供了一个简单的机制可以快速根据标签对告警进行静默处理。如果接收到的告警符合静默的配置，Alertmanager 则不会发送告警通知。&lt;/p>
&lt;p>静默设置需要在 Alertmanager 的 Werb 页面上进行设置。&lt;/p>
&lt;h2 id="alertmanager-告警分组">Alertmanager 告警分组&lt;/h2>
&lt;p>每一个告警进入 Alertmanager 后，都会进行分组处理，可以根据规则将多条告警合并为一个通知。这是为了可以让相关的告警可以合并在一起，一次性收集和发送，以便运维人员的故障排查。&lt;/p>
&lt;h2 id="alertmanager-告警路由">Alertmanager 告警路由&lt;/h2>
&lt;p>告警路由，顾名思义，路由就是根据“目的接收者”将每个告警发送到指定的接收者上的过程。&lt;/p>
&lt;p>每一个告警进入到 Alertmanager 都会由顶级的 route 进入路由树，需要注意的是顶级的 route 必须匹配所有告警(即不能有任何的匹配设置 match 和 match_re)，在一个路由树中，将每个被路由的目标称为 &lt;strong>Node(节点)。&lt;/strong>&lt;/p>
&lt;p>每一个路由都可以定义自己的接受人以及匹配规则。默认情况下，告警进入到顶级 route 后会遍历所有的子节点，直到找到最深的匹配 route，并将告警发送到该 route 定义的 receiver 中。但如果 route 中设置 continue 的值为 false，那么告警在匹配到第一个子节点之后就直接停止。如果 continue 为 true，报警则会继续进行后续子节点的匹配。如果当前告警匹配不到任何的子节点，那该告警将会基于当前路由节点的接收器配置方式进行处理。&lt;/p>
&lt;p>其中告警的匹配有两种方式可以选择。一种方式基于字符串验证，通过设置 match 规则判断当前告警中是否存在标签 labelname 并且其值等于 labelvalue。第二种方式则基于正则表达式，通过设置 match_re 验证当前告警标签的值是否满足正则表达式的内容。&lt;/p>
&lt;p>如果警报已经成功发送通知, 如果想设置发送告警通知之前要等待时间，则可以通过 repeat_interval 参数进行设置。&lt;/p>
&lt;h2 id="alertmanager-告警模板">Alertmanager 告警模板&lt;/h2>
&lt;p>告警模板的使用方式详见：告警模板详解&lt;/p>
&lt;p>默认情况下 Alertmanager 使用了系统自带的默认通知模板，模板源码可以从 &lt;a href="https://github.com/prometheus/alertmanager/blob/master/template/default.tmpl">https://github.com/prometheus/alertmanager/blob/master/template/default.tmpl&lt;/a> 获得。Alertmanager 的通知模板基于 Go 的模板系统。Alertmanager 也支持用户定义和使用自己的模板，一般来说有两种方式可以选择。&lt;/p>
&lt;p>第一种，基于模板字符串。用户可以直接在 Alertmanager 的配置文件中使用模板字符串，例如:&lt;/p>
&lt;pre>&lt;code>receivers:
- name: 'slack-notifications'
slack_configs:
- channel: '#alerts'
text: 'https://internal.myorg.net/wiki/alerts/{{ .GroupLabels.app }}/{{ .GroupLabels.alertname }}'
&lt;/code>&lt;/pre>
&lt;p>第二种方式，自定义可复用的模板文件。例如，可以创建自定义模板文件 custom-template.tmpl，如下所示：&lt;/p>
&lt;pre>&lt;code>{{ define &amp;quot;slack.myorg.text&amp;quot; }}https://internal.myorg.net/wiki/alerts/{{ .GroupLabels.app }}/{{ .GroupLabels.alertname }}{{ end}}
&lt;/code>&lt;/pre>
&lt;p>通过在 Alertmanager 的全局设置中定义 templates 配置来指定自定义模板的访问路径:&lt;/p>
&lt;pre>&lt;code># Files from which custom notification template definitions are read.
# The last component may use a wildcard matcher, e.g. 'templates/*.tmpl'.
templates:
[ - &amp;lt;filepath&amp;gt; ... ]
&lt;/code>&lt;/pre>
&lt;p>在设置了自定义模板的访问路径后，用户则可以直接在配置中使用该模板：&lt;/p>
&lt;pre>&lt;code>receivers:
- name: 'slack-notifications'
slack_configs:
- channel: '#alerts'
text: '{{ template &amp;quot;slack.myorg.text&amp;quot; . }}'
templates:
- '/etc/alertmanager/templates/myorg.tmpl'
&lt;/code>&lt;/pre>
&lt;h1 id="alertmanager-部署">Alertmanager 部署&lt;/h1>
&lt;p>与 prometheus 一样，可以通过二进制安装或者 docker 启动&lt;/p>
&lt;h2 id="使用-docker-的方式运行-alertmanager">使用 docker 的方式运行 Alertmanager&lt;/h2>
&lt;p>获取配置文件&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>mkdir -p /etc/monitoring
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>docker run -d --name alertmanager --rm prom/alertmanager
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>docker cp alertmanager:/etc/alertmanager /etc/monitoring
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>docker stop alertmanager
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>运行 Alertmanager&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>docker run -d --name alertmanager &lt;span style="color:#ae81ff">\
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">&lt;/span> --network host &lt;span style="color:#ae81ff">\
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">&lt;/span> -v /etc/localtime:/etc/localtime &lt;span style="color:#ae81ff">\
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">&lt;/span> -v /etc/monitoring/alertmanager:/etc/alertmanager/config_out &lt;span style="color:#ae81ff">\
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">&lt;/span> prom/alertmanager &lt;span style="color:#ae81ff">\
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">&lt;/span> --config.file&lt;span style="color:#f92672">=&lt;/span>/etc/alertmanager/config_out/alertmanager.yml
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>部署完成后，Alertmanager 默认监听在 9093 端口上，通过浏览器打开 http://localhost:9093 可以看到如下示例的画面
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/fesx4v/1616068406956-f10fe3df-d57f-4602-a6ab-e4aab90c89f1.jpeg" alt="">
首页 Alerts 标签上显示了从 Prometheus Server 推送过来的每一条告警，可以通过点击告警信息中的 Silence 来让该告警静音(i.e.不再发送告警邮件)&lt;/p>
&lt;h2 id="alertmanager-运行时的标志flags说明">Alertmanager 运行时的标志(Flags)说明&lt;/h2>
&lt;p>alertmanager 程序在启动时，可以使用一些标志来对程序进行一些基本设定，比如数据存储路径、存储时间等等&lt;/p>
&lt;ul>
&lt;li>&lt;strong>&amp;ndash;config.file=&amp;quot;/PATH/TO/FILE&amp;quot;&lt;/strong># 指定 alertmanager 基本配置文件。 默认 /etc/alertmanager/alertmanager.yml&lt;/li>
&lt;li>&lt;strong>&amp;ndash;storage.path=&amp;quot;/PATH&amp;quot;&lt;/strong># 指定存储数据的基础路径。该路径包括告警信息、已经 silences 的告警等信息。&lt;/li>
&lt;li>&lt;strong>&amp;ndash;data.retention=120h&lt;/strong> # 数据保存时长。&lt;/li>
&lt;li>&amp;ndash;alerts.gc-interval=30m # Interval between alert GC.&lt;/li>
&lt;li>&amp;ndash;web.external-url=WEB.EXTERNAL-URL zThe URL under which Alertmanager is externally reachable (for example, if Alertmanager is served via a reverse proxy). Used for generating relative and absolute links back to Alertmanagerzitself. If the URL has a path portion, it will be used to prefix all HTTP endpoints served by Alertmanager. If omitted, relevant URL components will be derived automatically.&lt;/li>
&lt;li>&amp;ndash;web.route-prefix=WEB.ROUTE-PREFIX zPrefix for the internal routes of web endpoints. Defaults to path of &amp;ndash;web.external-url.&lt;/li>
&lt;li>&amp;ndash;web.listen-address=&amp;quot;:9093&amp;quot; zAddress to listen on for the web interface and API.&lt;/li>
&lt;li>&amp;ndash;web.get-concurrency=0 Maximum number of GET requests processed concurrently. If negative or zero, the limit is GOMAXPROC or 8, whichever is larger.&lt;/li>
&lt;li>&amp;ndash;web.timeout=0 Timeout for HTTP requests. If negative or zero, no timeout is set.&lt;/li>
&lt;li>&amp;ndash;cluster.listen-address=&amp;ldquo;0.0.0.0:9094&amp;rdquo; zListen address for cluster. Set to empty string to disable HA mode.&lt;/li>
&lt;li>&amp;ndash;cluster.advertise-address=CLUSTER.ADVERTISE-ADDRESS zExplicit address to advertise in cluster.&lt;/li>
&lt;li>&amp;ndash;cluster.peer=CLUSTER.PEER &amp;hellip; zInitial peers (may be repeated).&lt;/li>
&lt;li>&amp;ndash;cluster.peer-timeout=15s zTime to wait between peers to send notifications.&lt;/li>
&lt;li>&amp;ndash;cluster.gossip-interval=200ms zInterval between sending gossip messages. By lowering this value (more frequent) gossip messages are propagated across the cluster more quickly at the expense of increased bandwidth.&lt;/li>
&lt;li>&amp;ndash;cluster.pushpull-interval=1m0s zInterval for gossip state syncs. Setting this interval lower (more frequent) will increase convergence speeds across larger clusters at the expense of increased bandwidth usage.&lt;/li>
&lt;li>&amp;ndash;cluster.tcp-timeout=10s Timeout for establishing a stream connection with a remote node for a full state sync, and for stream read and write operations.&lt;/li>
&lt;li>&amp;ndash;cluster.probe-timeout=500ms zTimeout to wait for an ack from a probed node before assuming it is unhealthy. This should be set to 99-percentile of RTT (round-trip time) on your network.&lt;/li>
&lt;li>&amp;ndash;cluster.probe-interval=1s zInterval between random node probes. Setting this lower (more frequent) will cause the cluster to detect failed nodes more quickly at the expense of increased bandwidth usage.&lt;/li>
&lt;li>&amp;ndash;cluster.settle-timeout=1m0s zMaximum time to wait for cluster connections to settle before evaluating notifications.&lt;/li>
&lt;li>&amp;ndash;cluster.reconnect-interval=10s zInterval between attempting to reconnect to lost peers.&lt;/li>
&lt;li>&amp;ndash;cluster.reconnect-timeout=6h0m0s zLength of time to attempt to reconnect to a lost peer.&lt;/li>
&lt;li>&amp;ndash;log.level=info Only log messages with the given severity or above. One of: [debug, info, warn, error]&lt;/li>
&lt;li>&amp;ndash;log.format=logfmt Output format of log messages. One of: [logfmt, json]&lt;/li>
&lt;li>&amp;ndash;version Show application version.&lt;/li>
&lt;/ul>
&lt;h1 id="alertmanager-配置">Alertmanager 配置&lt;/h1>
&lt;p>/etc/alertmanager/alertmanager.conf # alertmanager 基本配置文件默认位置。可以通过 &amp;ndash;config.file 标志指定其他配置文件&lt;/p>
&lt;p>下面是一个基本的 alertmanager.conf 配置文件示例：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-yaml" data-lang="yaml">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># 全局配置环境&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">global&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">resolve_timeout&lt;/span>: &lt;span style="color:#ae81ff">5m&lt;/span> &lt;span style="color:#75715e"># 该参数定义了当Alertmanager持续多长时间未接收到告警后标记告警状态为resolved（已解决）&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e"># 配置邮件发送信息&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">smtp_smarthost&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;smtp.163.com:25&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">smtp_from&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;ych_1024@163.com&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">smtp_auth_username&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;ych_1024@163.com&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">smtp_auth_password&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;&amp;lt;邮箱密码&amp;gt;&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">smtp_hello&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;163.com&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">smtp_require_tls&lt;/span>: &lt;span style="color:#66d9ef">false&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># 路由配置环境。所有报警信息进入后的根路由，用来设置报警的分发策略&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">route&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">group_by&lt;/span>: [&lt;span style="color:#e6db74">&amp;#34;alertname&amp;#34;&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;cluster&amp;#34;&lt;/span>] &lt;span style="color:#75715e"># 这里的标签列表是接收到报警信息后的重新分组标签，例如，接收到的报警信息里面有许多具有 cluster=A 和 alertname=LatncyHigh 这样的标签的报警信息将会批量被聚合到一个分组里面&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">group_wait&lt;/span>: &lt;span style="color:#ae81ff">TIME&lt;/span> &lt;span style="color:#75715e"># 当一个新的报警分组被创建后，需要等待至少TIME时间来初始化通知，这种方式可以确保您能有足够的时间为同一分组来获取多个警报，然后一起触发这个报警信息。&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">group_interval&lt;/span>: &lt;span style="color:#ae81ff">TIME&lt;/span> &lt;span style="color:#75715e"># 重复发送报警的设置(报警未消除的重复报警)。当一个组里的报警有变化时，等待&amp;#39;group_interval&amp;#39;时间来发送新的一组报警信息。默认5分钟。&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">repeat_interval&lt;/span>: &lt;span style="color:#ae81ff">TIME&lt;/span> &lt;span style="color:#75715e"># 重复发送报警的设置(报警未消除的重复报警)。一个组里的报警一直没有变化的话，等待&amp;#39;repeat_interval&amp;#39;时间来重新发送他们。默认4小时。&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">receiver&lt;/span>: &lt;span style="color:#ae81ff">STRING&lt;/span> &lt;span style="color:#75715e"># 指定默认的receiver名，如果一个报警没有任何一个routes匹配，则发送给默认的receiver&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">routes&lt;/span>: &lt;span style="color:#75715e"># 上面所有的配置参数都由所有子路由继承，并且可以在每个子路由上进行覆盖。&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#f92672">receiver&lt;/span>: &lt;span style="color:#ae81ff">STRING&lt;/span> &lt;span style="color:#75715e"># 指定该子路由要使用的receiver&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">group_wait&lt;/span>: &lt;span style="color:#ae81ff">TIME&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">match&lt;/span>: &lt;span style="color:#75715e"># 指定标签名和值，凡是具有该标签名和值的告警由将路由到指定的receiver上&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e"># 也可以使用 match_re 关键字，来进行正则表达式匹配。LabelValue 可以使用正则来表示&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">LabelName&lt;/span>: &lt;span style="color:#ae81ff">LabelValue&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># 接收者配置环境。用于定义分配好路由的告警信息将由谁来接收。&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">receivers&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#f92672">name&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;default&amp;#34;&lt;/span> &lt;span style="color:#75715e"># 指定receiver的名字&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">email_configs&lt;/span>: &lt;span style="color:#75715e"># 指定该receiver使用哪种配置&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#f92672">to&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;lichenhao@wisetv.com.cn&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">send_resolved&lt;/span>: &lt;span style="color:#66d9ef">true&lt;/span> &lt;span style="color:#75715e"># 指定是否发送告警已解决的信息。默认为false,i.e.不发送&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="配置样例">配置样例&lt;/h2>
&lt;h3 id="默认配置文件">默认配置文件&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-yaml" data-lang="yaml">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">global&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">resolve_timeout&lt;/span>: &lt;span style="color:#ae81ff">5m&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">route&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">group_by&lt;/span>: [&lt;span style="color:#e6db74">&amp;#34;alertname&amp;#34;&lt;/span>]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">group_wait&lt;/span>: &lt;span style="color:#ae81ff">10s&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">group_interval&lt;/span>: &lt;span style="color:#ae81ff">10s&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">repeat_interval&lt;/span>: &lt;span style="color:#ae81ff">1h&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">receiver&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;web.hook&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">receivers&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#f92672">name&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;web.hook&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">webhook_configs&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#f92672">url&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;http://127.0.0.1:5001/&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">inhibit_rules&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#f92672">source_match&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">severity&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;critical&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">target_match&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">severity&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;warning&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">equal&lt;/span>: [&lt;span style="color:#e6db74">&amp;#34;alertname&amp;#34;&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;dev&amp;#34;&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;instance&amp;#34;&lt;/span>]
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="使用腾讯企业邮箱的配置样例">使用腾讯企业邮箱的配置样例&lt;/h3>
&lt;p>Note：如果要使用腾讯企业邮箱，则需要生成客户端密码，位置如下图
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/fesx4v/1616068406969-84d8a216-cd2b-4438-a0e6-a6a85c64318a.jpeg" alt="">
下面的配置默认会将所有告警都发送给lichenhao@wisetv.com.cn。其中具有 network_device: interface-state 标签名和值的告警会发送给wangpeng@wisetv.com.cn&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-yaml" data-lang="yaml">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">global&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">resolve_timeout&lt;/span>: &lt;span style="color:#ae81ff">5m&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">smtp_smarthost&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;smtp.exmail.qq.com:587&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">smtp_from&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;lichenhao@wisetv.com.cn&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">smtp_auth_username&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;lichenhao@wisetv.com.cn&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">smtp_auth_password&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;bVcyqAh4jnz2hkVg&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">smtp_hello&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;qq.com&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">smtp_require_tls&lt;/span>: &lt;span style="color:#66d9ef">true&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">route&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">group_by&lt;/span>: [&lt;span style="color:#e6db74">&amp;#34;alertname&amp;#34;&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;cluster&amp;#34;&lt;/span>]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">group_wait&lt;/span>: &lt;span style="color:#ae81ff">30s&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">group_interval&lt;/span>: &lt;span style="color:#ae81ff">5m&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">repeat_interval&lt;/span>: &lt;span style="color:#ae81ff">5m&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">receiver&lt;/span>: &lt;span style="color:#ae81ff">default&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">routes&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#f92672">receiver&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;network-group&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">group_wait&lt;/span>: &lt;span style="color:#ae81ff">10s&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">match&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">network_device&lt;/span>: &lt;span style="color:#ae81ff">interface-state&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">receivers&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#f92672">name&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;default&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">email_configs&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#f92672">to&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;lichenhao@wisetv.com.cn&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">send_resolved&lt;/span>: &lt;span style="color:#66d9ef">true&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#f92672">name&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;network-group&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">email_configs&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#f92672">to&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;wangpeng@wisetv.com.cn&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">send_resolved&lt;/span>: &lt;span style="color:#66d9ef">true&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#f92672">to&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;lichenhao@wisetv.com.cn&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">send_resolved&lt;/span>: &lt;span style="color:#66d9ef">true&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h1 id="alertmanager-api">Alertmanager API&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://github.com/prometheus/alertmanager/blob/main/api/v2/openapi.yaml">GitHub 项目文件，prometheus/alertmanager/api/v2/openapi.yaml&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote></description></item><item><title>Docs: Ansible</title><link>https://desistdaydream.github.io/docs/9.%E8%BF%90%E7%BB%B4/Ansible/Ansible/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/9.%E8%BF%90%E7%BB%B4/Ansible/Ansible/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://www.ansible.com/">官网&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://github.com/ansible/ansible">GitHub 项目，ansible/ansible&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://docs.ansible.com/ansible/latest/index.html">官方文档&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://mp.weixin.qq.com/s/qu0vPgyNBbRlTtf1pMtq7Q">公众号,程序员面试吧-快速入门 Ansible 自动化运维工具&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.zsythink.net/archives/tag/ansible/">https://www.zsythink.net/archives/tag/ansible/&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>Ansible is a radically simple IT automation platform that makes your applications and systems easier to deploy and maintain. Automate everything from code deployment to network configuration to cloud management, in a language that approaches plain English, using SSH, with no agents to install on remote systems&lt;/p>
&lt;p>Ansible 是一个非常简单的 IT 自动化系统。它处理配置管理、应用程序部署、云供应、临时任务执行、网络自动化和多节点编排。Ansible 可以轻松得批量进行复杂的更改，例如使用负载均衡器进行零停机滚动更新。而这一过程使用 SSH 实现，无需在远程系统上安装代理程序。&lt;/p>
&lt;p>Ansible 的主要目标是简单易用。它还非常注重安全性和可靠性，具有最少的移动部件，使用 OpenSSH 进行传输（使用其他传输和拉模式作为替代），以及一种围绕人类可审计性设计的语言 - 即使是那些不熟悉的人该程序。&lt;/p>
&lt;h2 id="概念">概念&lt;/h2>
&lt;p>&lt;strong>Control node(控制节点)&lt;/strong> # 任何安装了 Ansible 的机器都可以称为控制节点。在控制节点中可以通过调用 &lt;code>ansible&lt;/code> 或 &lt;code>ansible-playbook&lt;/code> 命令来运行 Ansible 相关命令和 Playbooks。&lt;/p>
&lt;p>&lt;strong>Managed nodes(受管理节点)&lt;/strong> # 使用 Ansible 管理的 网络设备 或 服务器。受管理节点有时候也称为 &lt;strong>hosts&lt;/strong>。&lt;/p>
&lt;p>&lt;strong>Inventory(库存)&lt;/strong> # 库存是一个受管理节点的列表。库存有时候也称为 &lt;strong>hostfile&lt;/strong>。Inventory 还可以用来组织受管理节点，将每个节点进行分组，以便于扩展&lt;/p>
&lt;p>&lt;strong>Collections&lt;/strong> # 2.10 版本之后的新概念。Collections 是 Ansible 内容的分发格式，可以包括 Playbooks、Role、Modules、Plugins。新版中，Modules 和 Plugins 就被托管于 Collections 中。&lt;/p>
&lt;ul>
&lt;li>随着 Ansible 的发展，越来越多的模块、插件被开发并加入到 Ansible 的大家庭，这时候难免会出现命名上的冲突，或者调用上的重复。所以，从 2.10 版本之后，提出了 Collections 的概念。
&lt;ul>
&lt;li>Collections 最大的一个功能就是将模块分类，比如以前 核心模块 command，现在的全名就叫 ansible.builtin.command，前面的 ansible.builtin 就是 command 的 Collections。这种全名称为 &lt;strong>Full Qualified Class Name(完全限定类名，简称 FQCN)&lt;/strong>。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>Tasks(任务)&lt;/strong> # Ansible 工作的最小单元，Ansible 对受管理节点执行的操作，称为任务。&lt;/p>
&lt;p>&lt;strong>Modules(模块)&lt;/strong> # 模块就是 Ansible 用来执行 Tasks 的代码。&lt;/p>
&lt;p>&lt;strong>Playbooks(剧本)&lt;/strong> # 一个被保存起来的有序的 Tasks 列表，通过重复运行 Playbooks，可以方便得重复一组任务。Playbooks 中还可以包含变量、模板、条件语句、控制循环，从本质上来说，编写一个 Playbooks，就好像编写一个脚本代码一样。&lt;/p>
&lt;p>Playbooks 是 Ansible 的精髓，如果把 Ansible 当做一门语言，那么就成可以称为 Playbooks 脚本编程语言。&lt;/p>
&lt;h1 id="ansible-的核心组件">Ansible 的核心组件&lt;/h1>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/ot4g6f/1616125280904-828340be-8634-4a3f-a97b-d4600818bd6e.jpeg" alt="">&lt;/p>
&lt;ul>
&lt;li>&lt;strong>ansible core&lt;/strong> # 核心组件，ansible 本身&lt;/li>
&lt;li>&lt;strong>host inventory&lt;/strong> # 主机库存，Ansible 所管理的主机清单，一个文本文件&lt;/li>
&lt;li>&lt;strong>Modules&lt;/strong> # 模块。ansible 的 modules 是实现 ansible 的核心，
&lt;ul>
&lt;li>&lt;strong>core modules&lt;/strong> # 核心模块
&lt;ul>
&lt;li>ansible 执行任何命令，都是通过 module 来完成；比如 ansible 让被管理机创建一个用户，那么就会去 core modules 中调用一个能实现创建用户功能的模块，来执行这个操作。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>custom modules&lt;/strong> # 自定义模块
&lt;ul>
&lt;li>可以使用任何编程语言来编写模块，只要符合 ansible 的标准即可，可以实现 ansible 本身不具备的功能&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h1 id="ansible-模块与插件">Ansible 模块与插件&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://docs.ansible.com/ansible/latest/module_plugin_guide/index.html">官方文档，使用 Ansible 模块与插件&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>&lt;a href="https://desistdaydream.github.io/docs/9.%E8%BF%90%E7%BB%B4/Ansible/Ansible%20Modules/Ansible%20Modules.md">Ansible Modules(模块)&lt;/a> 是可以控制系统资源或执行系统命令的代码单元。 Ansible 提供了一个模块库，您可以直接在远程主机上或通过剧本执行。您还可以编写自定义模块。&lt;/p>
&lt;p>&lt;a href="https://desistdaydream.github.io/docs/9.%E8%BF%90%E7%BB%B4/Ansible/Ansible%20Plugins/Ansible%20Plugins.md">Ansible Plugins(插件)&lt;/a> 与模块类似，它们是扩展核心 Ansible 功能的代码片段。 Ansible 使用插件架构来实现丰富、灵活和可扩展的功能集。 Ansible 附带了几个插件，让您可以轻松使用自己的插件。&lt;/p>
&lt;p>比如，&lt;strong>Ansible 的控制节点连接到被管理节点时所使用的连接方式，就是通过 Connection 插件来实现的&lt;/strong>。而连接到目标节点后要执行的任务，则是由模块来实现的。&lt;/p>
&lt;p>再比如，我们在写 Playbook 时，会遇上处理需要文本的情况，比如大写转小写、获取第一个或最后一个字符等等，这些都是使用一种 Filters 的插件实现的。&lt;/p>
&lt;h1 id="ansible-关联文件与配置">Ansible 关联文件与配置&lt;/h1>
&lt;p>&lt;strong>/etc/ansible/ansible.cfg&lt;/strong> # ansible 使用时调用的配置文件&lt;/p>
&lt;p>&lt;strong>/etc/ansible/hosts&lt;/strong> # Inventory 的默认配置文件。该文件可以定义被管理主机的 IP，port 等，都可以定义在该文件中，具体格式如下&lt;/p>
&lt;ul>
&lt;li>单独 host，任何未分组的主机，需要在定义主机组之前定义各单独的 host，可以是 IP 地址或者主机名&lt;/li>
&lt;li>主机组，定义一个主机组，组名用[]括起来，可以定义多个主机组；当使用 ansible 命令的时候，可以使用组名来对该组内所有主机进行操作&lt;/li>
&lt;li>配置文件说明：详见：&lt;a href="https://desistdaydream.github.io/docs/9.%E8%BF%90%E7%BB%B4/Ansible/Inventory%20%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3.md">inventory 配置文件详解&lt;/a>&lt;/li>
&lt;/ul></description></item><item><title>Docs: Ansible Modules</title><link>https://desistdaydream.github.io/docs/9.%E8%BF%90%E7%BB%B4/Ansible/Ansible-Modules/Ansible-Modules/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/9.%E8%BF%90%E7%BB%B4/Ansible/Ansible-Modules/Ansible-Modules/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://docs.ansible.com/ansible/latest/module_plugin_guide/modules_intro.html">官方文档，使用 Ansible 模块和插件-模块介绍&lt;/a>
&lt;ul>
&lt;li>&lt;a href="https://docs.ansible.com/ansible/2.10/user_guide/modules.html">2.10 版本&lt;/a>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>&lt;strong>Modules(模块)&lt;/strong> 也被称为 &lt;strong>Task Plugins(任务插件)&lt;/strong> 或 &lt;strong>Library Plugins(插件库)&lt;/strong>，Modules 是可以从 Ansible 的命令行或 Playbook 的任务中使用的代码块。Ansible 通常在受管理节点上执行每个模块以完成任务，并收集返回值。&lt;/p>
&lt;blockquote>
&lt;p>注意：在 Ansible 2.10 及以上的版本中，大多数模块都被托管到 &lt;strong>Collections(集合)&lt;/strong> 中。&lt;/p>
&lt;/blockquote>
&lt;p>我们可以通过命令行使用模块执行任务，比如&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>ansible webservers -m service -a &lt;span style="color:#e6db74">&amp;#34;name=httpd state=started&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>ansible webservers -m ping
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>ansible webservers -m command -a &lt;span style="color:#e6db74">&amp;#34;/sbin/reboot -t now&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>也可以在 Playbooks 中使用模块执行任务，比如&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-yaml" data-lang="yaml">&lt;span style="display:flex;">&lt;span>- &lt;span style="color:#f92672">name&lt;/span>: &lt;span style="color:#ae81ff">restart webserver&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">service&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">name&lt;/span>: &lt;span style="color:#ae81ff">httpd&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">state&lt;/span>: &lt;span style="color:#ae81ff">restarted&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>等效于&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>ansible webservers -m service -a &lt;span style="color:#e6db74">&amp;#34;name=httpd state=started&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>每个模块都可以接受参数，以空格分割的 &lt;code>KEY=VALUE&lt;/code> 格式。&lt;/p>
&lt;blockquote>
&lt;p>注意：在命令行中使用模块与在 Playbooks 中使用模块时，可以传递的参数不太一样，比如 command 或 shell 模块，只需要传递需要运行的命令这个参数即可，但是在 Playbooks 中使用这两个模块，还可以传递其他参数。&lt;/p>
&lt;/blockquote>
&lt;p>所有模块执行完成后，都会有返回一个 JSON 格式的数据，这意味着可以使用任何编程语言编写模块。模块应该是幂等的，如果检测到当前状态与所需要的最终状态匹配，则应该避免再进行任何更改。&lt;/p>
&lt;p>下面我们拿一个最简单的模块举例，ansible.builtin.command 模块，当我们使用 command 模块时，可以为其传递参数，在其执行完任务之后，还会有返回值。&lt;/p>
&lt;h2 id="简单示例">简单示例&lt;/h2>
&lt;p>假如现在有这么一个 Playbooks&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-yaml" data-lang="yaml">&lt;span style="display:flex;">&lt;span>- &lt;span style="color:#f92672">name&lt;/span>: &lt;span style="color:#ae81ff">test&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">command&lt;/span>: &lt;span style="color:#ae81ff">whoami&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">register&lt;/span>: &lt;span style="color:#ae81ff">info&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>- &lt;span style="color:#f92672">name&lt;/span>: &lt;span style="color:#ae81ff">debug&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">debug&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">msg&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;{{info}}&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>这个 Playbooks 的意思就是在受管理节点上执行 &lt;code>whoami&lt;/code> 命令，并将返回值保存到 info 变量中，通过 debug 模块，将 info 变量中的内容输出出来，效果如下：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-json" data-lang="json">&lt;span style="display:flex;">&lt;span>[&lt;span style="color:#960050;background-color:#1e0010">lichenhao@hw-cloud-xngy-jump-server-linux&lt;/span>&lt;span style="color:#ae81ff">-2&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">~/projects/DesistDaydream/ehualu/ansible/playbook&lt;/span>]&lt;span style="color:#960050;background-color:#1e0010">$&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">ansible-playbook&lt;/span> &lt;span style="color:#ae81ff">90&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">-test.yaml&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#960050;background-color:#1e0010">PLAY&lt;/span> [&lt;span style="color:#960050;background-color:#1e0010">test&lt;/span>] &lt;span style="color:#960050;background-color:#1e0010">*******************************************************************************************************************************************************************&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#960050;background-color:#1e0010">TASK&lt;/span> [&lt;span style="color:#ae81ff">90&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">-test&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">:&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">test&lt;/span>] &lt;span style="color:#960050;background-color:#1e0010">*********************************************************************************************************************************************************&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#960050;background-color:#1e0010">changed:&lt;/span> [&lt;span style="color:#960050;background-color:#1e0010">hw-cloud-xngy-jump-server-linux&lt;/span>&lt;span style="color:#ae81ff">-2&lt;/span>]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#960050;background-color:#1e0010">TASK&lt;/span> [&lt;span style="color:#ae81ff">90&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">-test&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">:&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">debug&lt;/span>] &lt;span style="color:#960050;background-color:#1e0010">********************************************************************************************************************************************************&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#960050;background-color:#1e0010">ok:&lt;/span> [&lt;span style="color:#960050;background-color:#1e0010">hw-cloud-xngy-jump-server-linux&lt;/span>&lt;span style="color:#ae81ff">-2&lt;/span>] &lt;span style="color:#960050;background-color:#1e0010">=&amp;gt;&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;info&amp;#34;&lt;/span>: {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;ansible_facts&amp;#34;&lt;/span>: {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;discovered_interpreter_python&amp;#34;&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;/usr/bin/python3&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> },
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;changed&amp;#34;&lt;/span>: &lt;span style="color:#66d9ef">true&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;cmd&amp;#34;&lt;/span>: [
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#34;whoami&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ],
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;delta&amp;#34;&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;0:00:00.002447&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;end&amp;#34;&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;2021-10-09 23:05:10.491190&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;failed&amp;#34;&lt;/span>: &lt;span style="color:#66d9ef">false&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;rc&amp;#34;&lt;/span>: &lt;span style="color:#ae81ff">0&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;start&amp;#34;&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;2021-10-09 23:05:10.488743&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;stderr&amp;#34;&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;stderr_lines&amp;#34;&lt;/span>: [],
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;stdout&amp;#34;&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;root&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;stdout_lines&amp;#34;&lt;/span>: [
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#34;root&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#960050;background-color:#1e0010">PLAY&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">RECAP&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">********************************************************************************************************************************************************************&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#960050;background-color:#1e0010">hw-cloud-xngy-jump-server-linux&lt;/span>&lt;span style="color:#ae81ff">-2&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">:&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">ok=&lt;/span>&lt;span style="color:#ae81ff">2&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">changed=&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">unreachable=&lt;/span>&lt;span style="color:#ae81ff">0&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">failed=&lt;/span>&lt;span style="color:#ae81ff">0&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">skipped=&lt;/span>&lt;span style="color:#ae81ff">0&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">rescued=&lt;/span>&lt;span style="color:#ae81ff">0&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">ignored=&lt;/span>&lt;span style="color:#ae81ff">0&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>我们对比&lt;a href="https://docs.ansible.com/ansible/latest/collections/ansible/builtin/command_module.html#return-values">官方文档中 command 模块的返回值&lt;/a>，可以看到，与文档中的返回值保持一致。
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/shqrrv/1633792369531-e531b4d1-5c2b-427c-ade8-6207d5d6020b.png" alt="image.png">&lt;/p>
&lt;h2 id="总结">总结&lt;/h2>
&lt;p>所以，这也是为什么将 Moduels 称为代码的原因，&lt;strong>所谓的 Modules，本质上就是代码写出来的程序，就像 Functions&lt;/strong>，具有形参，可以接受实参，执行完成后，还会有返回值。Ansible 通过模块执行完一个任务之后，就会处理这些返回值，将其 或保存、或展示、或丢弃 等等。同时，在 Playbooks 中，还可以通过判断语句，根据返回值的内容，决定下一个任务的运行模式。&lt;/p>
&lt;p>我们可以通过 &lt;code>ansible-doc -l&lt;/code> 命令查看所有可用的模块，或者从&lt;a href="https://docs.ansible.com/ansible/latest/collections/index.html#list-of-collections">官方文档-Collections 文档&lt;/a>中查看所有模块
还可以使用&lt;code> ansible-doc MODULE&lt;/code> 命令查看指定模块的文档&lt;/p>
&lt;h1 id="模块分类">模块分类&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://docs.ansible.com/ansible/2.9/modules/modules_by_category.html">官方文档 2.9，用户指南-使用模块-模块索引&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://docs.ansible.com/ansible/latest/collections/index_module.html">官方文档 2.10+，所有模块和插件的索引-所有模块的索引&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>在 2.10 版本之前，模块的分类非常清晰；2.10 版本之后，由于模块被合并到集合中，所以很多已经分类的模块被合并到 &lt;a href="https://docs.ansible.com/ansible/latest/collections/index_module.html#ansible-builtin">builtin(内置) 模块&lt;/a>这个类别中，在这里则不再进行细致划分，非常乱。。。。&lt;/p>
&lt;p>模块的保存位置（ansible python module location）也产生了变化：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>~&lt;span style="color:#f92672">]&lt;/span>&lt;span style="color:#75715e"># ansible --version&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>ansible 2.9.6
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> config file &lt;span style="color:#f92672">=&lt;/span> /etc/ansible/ansible.cfg
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> configured module search path &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#f92672">[&lt;/span>&lt;span style="color:#e6db74">&amp;#39;/home/lichenhao/.ansible/plugins/modules&amp;#39;&lt;/span>, &lt;span style="color:#e6db74">&amp;#39;/usr/share/ansible/plugins/modules&amp;#39;&lt;/span>&lt;span style="color:#f92672">]&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ansible python module location &lt;span style="color:#f92672">=&lt;/span> /usr/lib/python3/dist-packages/ansible
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> executable location &lt;span style="color:#f92672">=&lt;/span> /usr/bin/ansible
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> python version &lt;span style="color:#f92672">=&lt;/span> 3.8.10 &lt;span style="color:#f92672">(&lt;/span>default, Jun &lt;span style="color:#ae81ff">22&lt;/span> 2022, 20:18:18&lt;span style="color:#f92672">)&lt;/span> &lt;span style="color:#f92672">[&lt;/span>GCC 9.4.0&lt;span style="color:#f92672">]&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/shqrrv/1669781692961-2dda8a1f-3eec-4687-beb3-fa3d141c1b5e.png" alt="image.png">&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>~&lt;span style="color:#f92672">]&lt;/span>&lt;span style="color:#75715e"># ansible --version&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>ansible &lt;span style="color:#f92672">[&lt;/span>core 2.13.6&lt;span style="color:#f92672">]&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> config file &lt;span style="color:#f92672">=&lt;/span> /etc/ansible/ansible.cfg
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> configured module search path &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#f92672">[&lt;/span>&lt;span style="color:#e6db74">&amp;#39;/root/.ansible/plugins/modules&amp;#39;&lt;/span>, &lt;span style="color:#e6db74">&amp;#39;/usr/share/ansible/plugins/modules&amp;#39;&lt;/span>&lt;span style="color:#f92672">]&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ansible python module location &lt;span style="color:#f92672">=&lt;/span> /root/.local/lib/python3.8/site-packages/ansible
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ansible collection location &lt;span style="color:#f92672">=&lt;/span> /root/.ansible/collections:/usr/share/ansible/collections
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> executable location &lt;span style="color:#f92672">=&lt;/span> /usr/bin/ansible
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> python version &lt;span style="color:#f92672">=&lt;/span> 3.8.10 &lt;span style="color:#f92672">(&lt;/span>default, Jun &lt;span style="color:#ae81ff">22&lt;/span> 2022, 20:18:18&lt;span style="color:#f92672">)&lt;/span> &lt;span style="color:#f92672">[&lt;/span>GCC 9.4.0&lt;span style="color:#f92672">]&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> jinja version &lt;span style="color:#f92672">=&lt;/span> 3.1.2
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> libyaml &lt;span style="color:#f92672">=&lt;/span> True
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/shqrrv/1669781684010-2cc9f6a7-cb1e-4e93-bf81-e41ef417c23c.png" alt="image.png">&lt;/p></description></item><item><title>Docs: Ansible 管理</title><link>https://desistdaydream.github.io/docs/9.%E8%BF%90%E7%BB%B4/Ansible/Ansible-%E7%AE%A1%E7%90%86/Ansible-%E7%AE%A1%E7%90%86/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/9.%E8%BF%90%E7%BB%B4/Ansible/Ansible-%E7%AE%A1%E7%90%86/Ansible-%E7%AE%A1%E7%90%86/</guid><description>
&lt;h1 id="实际案例">实际案例：&lt;/h1>
&lt;h2 id="批量关闭开启虚拟机">批量关闭/开启虚拟机&lt;/h2>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-yaml" data-lang="yaml">&lt;span style="display:flex;">&lt;span>- &lt;span style="color:#f92672">name&lt;/span>: &lt;span style="color:#ae81ff">获取虚拟机列表&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">virt&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">command&lt;/span>: &lt;span style="color:#ae81ff">list_vms&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">register&lt;/span>: &lt;span style="color:#ae81ff">info&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>- &lt;span style="color:#f92672">name&lt;/span>: &lt;span style="color:#ae81ff">循环开启虚拟机&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">virt&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">name&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;{{ item }}&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">command&lt;/span>: &lt;span style="color:#ae81ff">start&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">loop&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;{{ info.list_vms }}&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div></description></item><item><title>Docs: AnsiblePlugins</title><link>https://desistdaydream.github.io/docs/9.%E8%BF%90%E7%BB%B4/Ansible/Ansible-Plugins/Ansible-Plugins/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/9.%E8%BF%90%E7%BB%B4/Ansible/Ansible-Plugins/Ansible-Plugins/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://docs.ansible.com/ansible/latest/plugins/plugins.html">官方文档，使用插件&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>插件是增强 Ansible 核心功能的代码段。Ansible 使用插件架构来启用丰富，灵活和可扩展的功能集。&lt;/p>
&lt;p>朗读 Ansible 附带了许多方便的插件，您可以轻松编写自己的插件。&lt;/p>
&lt;p>本节介绍 Ansible 随附的各种类型的插件：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://docs.ansible.com/ansible/latest/plugins/action.html">Action Plugins&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://docs.ansible.com/ansible/latest/plugins/become.html">Become Plugins&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://docs.ansible.com/ansible/latest/plugins/cache.html">Cache Plugins&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://docs.ansible.com/ansible/latest/plugins/callback.html">Callback Plugins&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://docs.ansible.com/ansible/latest/plugins/cliconf.html">Cliconf Plugins&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://desistdaydream.github.io/docs/9.%E8%BF%90%E7%BB%B4/Ansible/Ansible%20Plugins/Connection%20%E6%8F%92%E4%BB%B6.md">Connection 插件&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://docs.ansible.com/ansible/latest/plugins/httpapi.html">Httpapi Plugins&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://docs.ansible.com/ansible/latest/plugins/inventory.html">Inventory Plugins&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://docs.ansible.com/ansible/latest/plugins/lookup.html">Lookup Plugins&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://docs.ansible.com/ansible/latest/plugins/netconf.html">Netconf Plugins&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://docs.ansible.com/ansible/latest/plugins/shell.html">Shell Plugins&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://docs.ansible.com/ansible/latest/plugins/strategy.html">Strategy Plugins&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://docs.ansible.com/ansible/latest/plugins/vars.html">Vars Plugins&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://docs.ansible.com/ansible/latest/user_guide/playbooks_filters.html">Filters&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://docs.ansible.com/ansible/latest/user_guide/playbooks_tests.html">Tests&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://docs.ansible.com/ansible/latest/user_guide/plugin_filtering_config.html">Plugin Filter Configuration&lt;/a>&lt;/li>
&lt;/ul></description></item><item><title>Docs: Anthropic</title><link>https://desistdaydream.github.io/docs/12.%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/Anthropic/Anthropic/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/12.%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/Anthropic/Anthropic/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://www.anthropic.com/">官网&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>Anthropic 是一家由前 OpenAI 团队成员创立的初创公司，它推出了一款名为 Claude 的 AI 聊天机器人，将其作为 ChatGPT 的竞争对手。&lt;/p>
&lt;h1 id="claude">Claude&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://mp.weixin.qq.com/s/7YJ7B6JTV7U1gXeLOiZsLw">公众号-OSC 开源社区，Anthropic推出 “更理性的 Claude”，正面硬刚ChatGPT&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>Claude 可以作为 &lt;a href="https://desistdaydream.github.io/docs/%E5%AE%9E%E7%94%A8%E5%B7%A5%E5%85%B7/%E5%8D%B3%E6%97%B6%E9%80%9A%E4%BF%A1/Slack.md">Slack&lt;/a> 的应用被添加到 Workspace 中并无条件使用。&lt;/p></description></item><item><title>Docs: API</title><link>https://desistdaydream.github.io/docs/2.%E7%BC%96%E7%A8%8B/API/API/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/2.%E7%BC%96%E7%A8%8B/API/API/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;a href="https://en.wikipedia.org/wiki/API">wiki，API&lt;/a>&lt;/p>
&lt;/blockquote>
&lt;p>&lt;strong>Application Programming Interface(应用程序接口，简称 API)&lt;/strong>。它定义了可以进行的调用或请求的类型，如何进行调用，应使用的数据格式，遵循的约定等。它还可以提供扩展机制，以便用户可以通过各种方式扩展现有功能。在不同程度上。[1] API 可以是完全自定义的，特定于组件的，也可以基于行业标准设计以确保互操作性。通过&lt;a href="https://en.wikipedia.org/wiki/Information_hiding">信息隐藏&lt;/a>，API 支持&lt;a href="https://en.wikipedia.org/wiki/Modular_programming">模块化编程&lt;/a>，从而使用户可以独立于实现使用接口。&lt;/p>
&lt;h2 id="目的">目的&lt;/h2>
&lt;p>在构建应用程序时，API（应用程序编程接口）通过抽象化底层实现并仅公开开发人员需要的对象或动作来简化编程。电子邮件客户端的图形界面可能会为用户提供执行获取和突出显示新电子邮件的所有步骤的按钮，而用于文件输入/输出的 API 可能会为开发人员提供一种将文件从一个位置复制到另一个位置的功能，而无需要求开发人员了解幕后发生的文件系统操作。[2]&lt;/p>
&lt;h2 id="术语的历史">术语的历史&lt;/h2>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/folw44/1616163705351-3d45137b-c5db-4656-839f-5fa583e353e3.png" alt="">&lt;/p>
&lt;p>1978 年的一张图建议将 API 的概念扩展为一个通用的编程接口，而不仅仅是应用程序。[3]&lt;/p>
&lt;p>“ &lt;em>API&lt;/em> ”一词的含义已经扩展了其历史。首先，它仅描述了面向面向最终用户的程序（称为应用程序）的接口。此起源仍反映在名称“应用程序编程接口”中。如今，术语 API 的范围更广，不仅包括实用程序软件，甚至包括硬件接口。[4]&lt;/p>
&lt;p>API 的概念比该术语要古老得多。英国计算机科学家 Wilkes 和 Wheeler 在 1940 年代为 EDSAC 计算机开发了模块化软件库。约书亚·布洛赫（Joshua Bloch）声称威尔克斯和惠勒（Wilker and Wheeler）“潜在地发明”了该 API，因为它更多地是被发现而不是被发明的概念。[4]&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/folw44/1616163705346-76236d7f-ccd5-42d5-81dd-04fdda266f7a.jpeg" alt="">&lt;/p>
&lt;p>尽管创造 API 一词的人是在 Univac 1108 上实现软件，但他们的 API 的目标是使独立于硬件的程序成为可能。[5]&lt;/p>
&lt;p>术语“应用程序接口”（没有_-ing_后缀）首先被记录在称为纸张_数据结构和技术对于远程计算机图形_在呈现 AFIPS 在 1968 年会议[6] [4]所述的本文使用的作者该术语描述应用程序（在这种情况下为图形程序）与计算机系统其余部分的交互。一致的应用程序接口（包括 Fortran 子例程调用）旨在使程序员摆脱处理图形显示设备的特性，并在更换计算机或显示器时提供硬件独立性。[5]&lt;/p>
&lt;p>术语被引入到的场数据库由 CJ 日期[7]中称为 1974 纸_的关系和网络途径：应用程序编程接口的比较_。[8] API 成为用于数据库管理系统的 ANSI / SPARC 框架的一部分。该框架将应用程序编程接口与其他接口（例如查询接口）分开对待。1970 年代的数据库专业人员发现，这些不同的接口可以组合在一起。一个足够丰富的应用程序接口也可以支持其他接口。[3]&lt;/p>
&lt;p>这种观察导致 API 支持所有类型的编程，而不仅是应用程序编程。到 1990 年，API 被技术专家 Carl Malamud 定义为“程序员可以用来执行某些任务的一组服务” 。[9]&lt;/p>
&lt;p>随着 Web API 的出现，API 的概念再次得到扩展。罗伊·菲尔丁（Roy Fielding）的论文《_建筑风格》和_2000 年在加州大学欧文分校（UC Irvine）_的基于网络的软件体系结构设计_概述了代表性状态转移（REST），并描述了“菲林丁”与传统的“图书馆应用程序接口”的“基于网络的应用程序编程接口”的概念。基于”的 API。[10] XML 和 JSON Web API 于 2000 年开始得到广泛的商业采用，并一直持续到 2020 年。&lt;/p>
&lt;p>现在，Web API 是术语 API 的最常见含义。[11]以这种方式使用时，术语“ API”与术语“通信协议”和“远程过程调用”在含义上有一些重叠。&lt;/p>
&lt;h2 id="用法">用法&lt;/h2>
&lt;h3 id="库和框架">库和框架&lt;/h3>
&lt;p>API 通常与软件库有关。当库是这套规则的“实际实现”时，API 描述并规定了“预期行为”（一种规范）。&lt;/p>
&lt;p>单个 API 可以采用共享同一编程接口的不同库的形式进行多种实现（或者没有一种实现是抽象的）。&lt;/p>
&lt;p>将 API 与实现分开，可以允许以一种语言编写的程序使用以另一种语言编写的库。例如，由于 Scala 和 Java 可以编译为兼容的字节码，因此 Scala 开发人员可以利用任何 Java API。[12]&lt;/p>
&lt;p>API 的使用取决于所涉及的编程语言的类型。诸如 Lua 之类的过程语言的 API 可以主要由执行代码，操纵数据或处理错误的基本例程组成，而诸如 Java 之类的面向对象语言的 API 则可以提供类及其类方法的规范。[13] [14]&lt;/p>
&lt;p>语言绑定也是 API。通过将一种语言的特性和功能映射到以另一种语言实现的接口，语言绑定允许在以另一种语言进行开发时使用以一种语言编写的库或服务。[15]诸如 SWIG 和 F2PY（一种从 Fortran 到 Python 的接口生成器）之类的工具有助于创建此类接口。[16]&lt;/p>
&lt;p>API 也可以与软件框架相关：框架可以基于实现了多个 API 的多个库，但是与 API 的正常使用不同，对框架内建行为的访问是通过使用新类扩展其内容来实现的插入框架本身。&lt;/p>
&lt;p>而且，整个控制程序流程可以通过控制反转或类似的机制而不受调用者的控制，而不受框架的控制。[17] [18]&lt;/p>
&lt;h3 id="操作系统">操作系统&lt;/h3>
&lt;p>API 可以指定应用程序和操作系统之间的接口。[19] 例如，POSIX 指定一组通用 API，这些 API 旨在使为 POSIX 兼容操作系统编写的应用程序能够为另一个 POSIX 兼容操作系统编译。&lt;/p>
&lt;p>Linux 和 Berkeley 软件发行版是实现 POSIX API 的操作系统的示例。[20]&lt;/p>
&lt;p>Microsoft 已显示出对向后兼容 API 的坚定承诺，尤其是在其 Windows API（Win32）库中，因此较旧的应用程序可以使用称为“兼容模式”的可执行程序特定设置在新版 Windows 上运行。[21]&lt;/p>
&lt;p>API 与应用程序二进制接口（ABI）的不同之处在于，API 是基于源代码的，而 ABI 是基于二进制的。例如，POSIX 提供 API，而 Linux Standard Base 提供 ABI。&lt;/p>
&lt;h3 id="远程-api">远程 API&lt;/h3>
&lt;p>远程 API 允许开发人员通过协议（特定于通信的标准）来操纵远程资源，该协议允许不同的技术一起工作，而不论语言或平台如何。例如，Java 数据库连接 API 允许开发人员使用相同的功能集查询许多不同类型的数据库，而 Java 远程方法调用 API 使用 Java 远程方法协议来允许调用可远程操作但在本地运行的功能开发人员。[24] [25]&lt;/p>
&lt;p>因此，远程 API 对于维护面向对象程序设计中的对象抽象很有用。在代理对象上本地执行的方法调用，使用远程协议在远程对象上调用相应的方法，并获取要在本地用作返回值的结果。&lt;/p>
&lt;p>代理对象的修改也将导致远程对象的相应修改。[26]&lt;/p>
&lt;h3 id="web-api">Web API&lt;/h3>
&lt;p>主要文章：Web API&lt;/p>
&lt;p>Web API 是企业和使用其资产的应用程序之间进行交互的已定义接口，这也是服务水平协议（SLA），用于指定功能提供者并为其 API 用户公开服务路径或 URL。API 方法是一种体系结构方法，它围绕为服务于不同类型消费者的不同应用程序提供一组服务的程序接口而发展。[27]&lt;/p>
&lt;p>当在 Web 开发的上下文中使用 API 时，通常将其定义为一组规范，例如超文本传输协议（HTTP）请求消息以及响应消息的结构定义，通常以可扩展标记语言（XML））或 JavaScript 对象符号（JSON）格式。例如运输公司的 API，可以将其添加到以电子商务为中心的网站上，以方便订购运输服务，并自动包括当前的运输价格，而站点开发人员不必在网络数据库中输入运输者的价格表。尽管“ Web API”在历史上实际上是 Web 服务的代名词，但最近的趋势（所谓的 Web 2.0）已从基于简单对象访问协议（SOAP）的 Web 服务和面向服务的体系结构（SOA）转向更直接的表示状态转移（REST）样式的 Web 资源和面向资源的体系结构（ROA）。[28]这种趋势的一部分与语义 Web 向资源描述框架（RDF）的发展有关，RDF 是一种促进基于 Web 的本体工程技术的概念。Web API 允许将多个 API 组合到称为 mashup 的新应用程序中。[29] 在社交媒体领域，Web API 使 Web 社区可以促进在社区和应用程序之间共享内容和数据。这样，可以将在一个地方动态创建的内容发布并更新到 Web 上的多个位置。[30]例如，Twitter 的 REST API 允许开发人员访问 Twitter 的核心数据，而 Search API 为开发人员提供了与 Twitter 搜索和趋势数据进行交互的方法。[31]&lt;/p>
&lt;h2 id="设计">设计&lt;/h2>
&lt;p>API 的设计对其使用有重大影响。[2]信息隐藏的原理将编程接口的作用描述为通过隐藏模块的实现细节来实现模块化编程，从而使模块用户无需了解模块内部的复杂性。[32]因此，API 的设计试图仅提供用户期望的工具。[2]编程接口的设计是软件体系结构的重要组成部分，是复杂软件的组织。[33]&lt;/p>
&lt;h2 id="发布政策">发布政策&lt;/h2>
&lt;p>API 是技术公司更常见的集成方式之一。提供和使用 API 的组件被视为业务生态系统的成员。[34]&lt;/p>
&lt;p>发布 API 的主要策略是：[35]&lt;/p>
&lt;ul>
&lt;li>
&lt;p>私有：该 API 仅供内部公司使用。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>合作伙伴：只有特定的业务合作伙伴可以使用 API。例如，Uber 和 Lyft 等租用公司的车辆允许经过批准的第三方开发人员直接在其应用程序内订购游乐设施。这使公司可以通过选择哪些应用程序可以访问 API 来进行质量控制，并为其提供额外的收入来源。[36]&lt;/p>
&lt;/li>
&lt;li>
&lt;p>公开：该 API 供公众使用。例如，Microsoft 公开了 Windows API，Apple 发行了其 API Cocoa，因此可以为其平台编写软件。通常，并非所有人都能访问所有公共 API。例如，Cloudflare 或 Voxility 等 Internet 服务提供商使用 RESTful API，以允许客户和转售商访问其基础结构信息，DDoS 统计信息，网络性能或仪表板控件。[37]可以通过“ API 令牌”或客户身份验证来授予对此类 API 的访问权限。[38]&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h3 id="公共-api-的含义">公共 API 的含义&lt;/h3>
&lt;p>API 公开时的重要因素是其“接口稳定性”。对 API 的更改（例如，向函数调用添加新参数）可能会破坏与依赖该 API 的客户端的兼容性。[39]&lt;/p>
&lt;p>当公开展示的 API 的某些部分可能发生更改并因此不稳定时，应将特定 API 的这些部分明确记录为“不稳定”。例如，在 Google Guava 库中，被视为不稳定的部分或可能即将更改的部分都标有 Java 注释 &lt;code>@Beta&lt;/code>。[40]&lt;/p>
&lt;p>公共 API 有时可以声明其自身的某些部分_已弃用_或废除。这通常意味着应将 API 的一部分视为要删除或以向后不兼容的方式进行修改的候选对象。因此，这些更改使开发人员可以脱离 API 的某些部分，这些部分将来将被删除或不再受支持。[41]&lt;/p>
&lt;p>客户端代码可能包含 API 设计人员不打算使用的创新用法或机会用法。换句话说，对于具有大量用户基础的库，当元素成为公共 API 的一部分时，可以多种方式使用它。[42] 2020 年 2 月 19 日，Akamai 发布了他们的年度“互联网状况”报告，展示了针对全球金融服务中针对公共 API 平台的网络犯罪分子的增长趋势。从 2017 年 12 月到 2019 年 11 月，Akamai 见证了 854.2 亿次凭证违规攻击。大约 20％（即 165.5 亿）与定义为 API 端点的主机名相对。其中，4.735 亿针对金融服务部门组织。[43]&lt;/p>
&lt;h2 id="文档">文档&lt;/h2>
&lt;p>API 文档描述了 API 提供的服务以及如何使用这些服务，旨在涵盖客户出于实际目的需要了解的所有内容。&lt;/p>
&lt;p>文档对于使用 API 开发和维护应用程序至关重要。[44] API 文档通常在文档文件中找到，但也可以在社交媒体（例如博客，论坛和问答网站）中找到。[45]&lt;/p>
&lt;p>传统的文档文件通常通过具有一致外观和结构的文档系统（例如 Javadoc 或 Pydoc）来呈现。但是，文档中包含的内容类型因 API 而异。[46]&lt;/p>
&lt;p>为了清楚起见，API 文档可能包括对 API 中的类和方法的描述以及“典型的使用场景，代码段，设计原理，性能讨论和合同”，但是 API 服务本身的实现细节通常是省略。&lt;/p>
&lt;p>该文档还涵盖了如何使用 API 的限制和限制。例如，对于一个 API 函数文档可以注意到，它的参数不能为 null，该函数本身没有线程安全的，[47]因为 API 文档往往是全面的，它是作家保持更新文档和挑战用户仔细阅读它，可能会产生错误。[39]&lt;/p>
&lt;p>API 文档可以使用 Java 注释之类的元数据信息来丰富。编译器，工具和_运行时_环境可以使用此元数据来实现自定义行为或自定义处理。[48]&lt;/p>
&lt;p>可以以数据驱动的方式生成 API 文档。通过观察使用给定 API 的许多程序，可以推断出典型用法以及所需的合同和指令。[49]然后，可以使用模板从挖掘的数据生成自然语言。&lt;/p></description></item><item><title>Docs: API Server</title><link>https://desistdaydream.github.io/docs/10.%E4%BA%91%E5%8E%9F%E7%94%9F/2.3.Kubernetes-%E5%AE%B9%E5%99%A8%E7%BC%96%E6%8E%92%E7%B3%BB%E7%BB%9F/1.API-Resource-%E4%B8%8E-Object/API-Server/API-Server/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/10.%E4%BA%91%E5%8E%9F%E7%94%9F/2.3.Kubernetes-%E5%AE%B9%E5%99%A8%E7%BC%96%E6%8E%92%E7%B3%BB%E7%BB%9F/1.API-Resource-%E4%B8%8E-Object/API-Server/API-Server/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://kubernetes.io/docs/concepts/overview/components/#kube-apiserver">官方文档，概念-概述-Kubernetes 组件-kube-apiserver&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://kubernetes.io/docs/reference/command-line-tools-reference/kube-apiserver/">官方文档，参考-通用组件-kube-apiserver&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>&lt;strong>API Server 是实现 kubernetes API 的应用程序，它是 Kubernetes 控制平面的一个组件，用以对外暴露 Kubernetes API&lt;/strong>。Kubernetes API Server 验证和配置 API 对象的数据，包括 pod、service、replicationcontroller 等。 API Server 为 REST 操作提供服务，并为集群的共享状态提供前端，所有其他组件通过该前端进行交互。&lt;/p>
&lt;p>如果是通过 kubeadm 安装的 k8s 集群，那么 API Server 的表现形式就是一个名为 &lt;strong>kube-apiserver 的静态 pod&lt;/strong>。kube-apiserver 可以水平扩展，i.e.部署多个 kube-apiserver 以实现高可用，应对高并发请求，到达 kube-apiserver 的流量可以在这些实例之间平衡。&lt;/p>
&lt;p>API Server 启动后，默认监听在 6443 端口(http 默认监听在 8080 上)。API Server 是 Kubernetes 集群的前端接口 ，各种客户端工具（CLI 或 UI）以及 Kubernetes 其他组件可以通过它管理集群的各种资源。kubectl 就是 API Server 的客户端程序，实现对 k8s 各种资源的增删改查的功能。各个 node 节点的 kubelet 也通过 master 节点的 API Server 来上报本节点的 Pod 状态。&lt;/p>
&lt;ul>
&lt;li>提供集群管理的 REST 风格 API 接口，包括认证授权、数据校验以及集群状态变更等&lt;/li>
&lt;li>提供其他模块之间的数据交互和通信的枢纽（其他模块通过 API Server 查询或修改数据，只有 API Server 才可以直接操作 etcd）&lt;/li>
&lt;/ul>
&lt;h1 id="api-server-的访问方式">API Server 的访问方式&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://kubernetes.io/docs/tasks/administer-cluster/access-cluster-api/">官方文档，任务-管理集群-使用 Kubernetes API 访问集群&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>注意：&lt;/p>
&lt;ol>
&lt;li>API Server 默认是安全的，在访问时，应使用 https 协议来操作。&lt;/li>
&lt;li>参考 [K8S 认证与授权介绍](7.API%20 访问控制.md 访问控制.md) 文章，学习在访问 API Server 时所遇到的验证问题。&lt;/li>
&lt;/ol>
&lt;h2 id="使用-kubectl-访问-api">使用 kubectl 访问 API&lt;/h2>
&lt;p>现阶段有 kubectl 工具可以实现对 API Server 的访问&lt;/p>
&lt;p>使用 kubectl get &amp;ndash;raw / 命令让 kubectl 不再输出标准格式的数据，而是直接向 api server 请求原始数据&lt;/p>
&lt;h2 id="直接访问-rest-apieg使用-curl浏览器-等方式访问-api">直接访问 REST API(e.g.使用 curl、浏览器 等方式访问 API)&lt;/h2>
&lt;p>kubectl 处理对 API 服务器的定位和身份验证。如果你想通过 http 客户端（如 curl 或 wget，或浏览器）直接访问 REST API，你可以通过多种方式对 API 服务器进行定位和身份验证：&lt;/p>
&lt;ol>
&lt;li>以代理模式运行 kubectl(推荐)。 推荐使用此方法，因为它用存储的 apiserver 位置并使用自签名证书验证 API 服务器的标识。 使用这种方法无法进行中间人（MITM）攻击。&lt;/li>
&lt;li>另外，你可以直接为 HTTP 客户端提供位置和身份认证。 这适用于被代理混淆的客户端代码。 为防止中间人攻击，你需要将根证书导入浏览器。&lt;/li>
&lt;/ol>
&lt;p>比如 curl &amp;ndash;request DELETE -cacert ${CAPATH} -H &amp;ldquo;Authorization: Bearer ${TOKEN}&amp;rdquo; https://${IP}:6443/api/v1/namespaces/monitoring/pods/prometheus-k8s-0 -k 这样一个请求就可以将集群内 monitoring 空间下的 prometheus-k8s-0 这个 pod 删除&lt;/p>
&lt;h3 id="获取认证所需信息">获取认证所需信息&lt;/h3>
&lt;p>&lt;strong>方法一：使用 kubectl 的配置文件中的证书与私钥&lt;/strong>
想要访问 https 下的内容，首先需要准备证书与私钥或者 ca 与 token 等等。&lt;/p>
&lt;ol>
&lt;li>首先获取 kubeclt 工具配置文件中的证书与私钥
&lt;ol>
&lt;li>cat /etc/kubernetes/admin.conf | grep client-certificate-data | awk &amp;lsquo;{print $2}&amp;rsquo; | base64 -d &amp;gt; /root/certs/admin.crt&lt;/li>
&lt;li>cat /etc/kubernetes/admin.conf | grep client-key-data | awk &amp;lsquo;{print $2}&amp;rsquo; | base64 -d &amp;gt; /root/certs/admin.key&lt;/li>
&lt;/ol>
&lt;/li>
&lt;li>确定 CA 文件位置(文件一般在 /etc/kubernetes/pki/ca.crt)
&lt;ol>
&lt;li>CAPATH=/etc/kubernetes/pki/ca.crt&lt;/li>
&lt;/ol>
&lt;/li>
&lt;li>确定要访问组件的的 IP
&lt;ol>
&lt;li>IP=172.38.40.212&lt;/li>
&lt;/ol>
&lt;/li>
&lt;/ol>
&lt;p>&lt;strong>方法二：使用拥有最高权限 ServiceAccount 的 Token 访问 https&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>(可选)创建一个专门存放 SA 的名称空间
&lt;ul>
&lt;li>kubectl create namespace user-sa-manage&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>创建一个 ServiceAccount
&lt;ul>
&lt;li>kubectl create -n user-sa-manage serviceaccount test-admin&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>将该 ServiceAccount 绑定到 cluster-admin 这个 clusterrole，以赋予最高权限
&lt;ul>
&lt;li>kubectl create clusterrolebinding test-admin &amp;ndash;clusterrole=cluster-admin &amp;ndash;serviceaccount=user-sa-manage:test-admin&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>将该 ServiceAccount 的 Token 的值注册到变量中
&lt;ul>
&lt;li>TOKEN=$(kubectl get -n user-sa-manage secrets -o jsonpath=&amp;quot;{.items[?(@.metadata.annotations[&amp;lsquo;kubernetes.io/service-account.name&amp;rsquo;]==&amp;lsquo;test-admin&amp;rsquo;)].data.token}&amp;quot;|base64 -d)&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>确定 CA 文件位置(文件一般在 /etc/kubernetes/pki/ca.crt)
&lt;ul>
&lt;li>CAPATH=/etc/kubernetes/pki/ca.crt&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>确定要访问组件的的 IP
&lt;ul>
&lt;li>IP=172.38.40.212&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>使用令牌玩转 API
&lt;ul>
&lt;li>curl -k $IP/api -H &amp;ldquo;Authorization: Bearer $TOKEN&amp;rdquo;&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>Note：也可以从一个具有权限的 ServiceAccount 下的 secret 获取，可以使用现成的，也可以手动创建。比如下面用 promtheus 自带的 token。&lt;/p>
&lt;ol>
&lt;li>如果权限不足，那么访问的时候会报错，比如权限不够，或者认证不通过等等。报错信息有如下几种
&lt;ol>
&lt;li>no kind is registered for the type v1.Status in scheme &amp;ldquo;k8s.io/kubernetes/pkg/api/legacyscheme/scheme.go:30&amp;rdquo;&lt;/li>
&lt;li>Unauthorized&lt;/li>
&lt;/ol>
&lt;/li>
&lt;li>TOKEN=$(kubectl get secrets -n monitoring prometheus-k8s-token-q5hm4 &amp;ndash;template={{.data.token}} | base64 -d)&lt;/li>
&lt;/ol>
&lt;p>&lt;strong>方法三：官方推荐，类似方法二&lt;/strong>
官方文档：&lt;a href="https://kubernetes.io/docs/tasks/administer-cluster/access-cluster-api/">https://kubernetes.io/docs/tasks/administer-cluster/access-cluster-api/&lt;/a>&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># 查看所有的集群，因为你的 .kubeconfig 文件中可能包含多个上下文&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>kubectl config view -o jsonpath&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#39;{&amp;#34;Cluster name\tServer\n&amp;#34;}{range .clusters[*]}{.name}{&amp;#34;\t&amp;#34;}{.cluster.server}{&amp;#34;\n&amp;#34;}{end}&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># 从上述命令输出中选择你要与之交互的集群的名称&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>export CLUSTER_NAME&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;some_server_name&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># 指向引用该集群名称的 API 服务器&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>APISERVER&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#66d9ef">$(&lt;/span>kubectl config view -o jsonpath&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;{.clusters[?(@.name==\&amp;#34;&lt;/span>&lt;span style="color:#e6db74">${&lt;/span>CLUSTER_NAME&lt;span style="color:#e6db74">}&lt;/span>&lt;span style="color:#e6db74">\&amp;#34;)].cluster.server}&amp;#34;&lt;/span>&lt;span style="color:#66d9ef">)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># 获得令牌&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>TOKEN&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#66d9ef">$(&lt;/span>kubectl get secrets -o jsonpath&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;{.items[?(@.metadata.annotations[&amp;#39;kubernetes\.io/service-account\.name&amp;#39;]==&amp;#39;default&amp;#39;)].data.token}&amp;#34;&lt;/span>|base64 -d&lt;span style="color:#66d9ef">)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># 使用令牌玩转 API&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>curl -X GET $APISERVER/api --header &lt;span style="color:#e6db74">&amp;#34;Authorization: Bearer &lt;/span>$TOKEN&lt;span style="color:#e6db74">&amp;#34;&lt;/span> --insecure
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="访问-api-server">访问 API Server&lt;/h3>
&lt;ol>
&lt;li>执行访问 https 前准备方法一
&lt;ol>
&lt;li>通过证书与私钥访问
&lt;ol>
&lt;li>curl &amp;ndash;cacert ${CAPATH} &amp;ndash;cert /root/certs/admin.crt &amp;ndash;key /root/certs/admin.key https://${IP}:6443/&lt;/li>
&lt;/ol>
&lt;/li>
&lt;/ol>
&lt;/li>
&lt;li>执行访问 https 前准备方法二
&lt;ol>
&lt;li>通过 https 的方式访问 API
&lt;ol>
&lt;li>curl &amp;ndash;cacert ${CAPATH} -H &amp;ldquo;Authorization: Bearer ${TOKEN}&amp;rdquo; https://${IP}:6443/&lt;/li>
&lt;/ol>
&lt;/li>
&lt;/ol>
&lt;/li>
&lt;li>kubeclt
&lt;ol>
&lt;li>kubectl get &amp;ndash;raw / # 让 kubectl 不再输出标准格式的数据，而是直接向 api server 请求原始数据&lt;/li>
&lt;/ol>
&lt;/li>
&lt;li>kubectl proxy，一般监听在 6443 端口的 api server 使用该方式，监听在 8080 上的为 http，可直接访问
&lt;ol>
&lt;li>kubectl proxy &amp;ndash;port=8080 &amp;ndash;accept-hosts=&amp;rsquo;^localhost$,^127.0.0.1$,^[::1]$,10.10.100.151&amp;rsquo; &amp;ndash;address=&amp;lsquo;0.0.0.0&amp;rsquo; # 在本地 8080 端口上启动 API Server 的一个代理网关，以便使用 curl 直接访问 api server 并使用命令 curl localhost:8080/获取数据
&lt;ol>
&lt;li>直接访问本地 8080 端口，即可通过 API Server 获取集群所有数据&lt;/li>
&lt;/ol>
&lt;/li>
&lt;/ol>
&lt;/li>
&lt;/ol>
&lt;h2 id="编程方式访问-api">编程方式访问 API&lt;/h2>
&lt;p>Kubernetes 官方支持  &lt;a href="https://kubernetes.io/zh/docs/tasks/administer-cluster/access-cluster-api/#go-client">Go&lt;/a>、&lt;a href="https://kubernetes.io/zh/docs/tasks/administer-cluster/access-cluster-api/#python-client">Python&lt;/a>、&lt;a href="https://kubernetes.io/zh/docs/tasks/administer-cluster/access-cluster-api/#java-client">Java&lt;/a>、 &lt;a href="https://kubernetes.io/zh/docs/tasks/administer-cluster/access-cluster-api/#dotnet-client">dotnet&lt;/a>、&lt;a href="https://kubernetes.io/zh/docs/tasks/administer-cluster/access-cluster-api/#javascript-client">Javascript&lt;/a>  和  &lt;a href="https://kubernetes.io/zh/docs/tasks/administer-cluster/access-cluster-api/#haskell-client">Haskell&lt;/a>  语言的客户端库。还有一些其他客户端库由对应作者而非 Kubernetes 团队提供并维护。 参考&lt;a href="https://kubernetes.io/zh/docs/reference/using-api/client-libraries/">客户端库&lt;/a>了解如何使用其他语言 来访问 API 以及如何执行身份认证。&lt;/p>
&lt;h3 id="go-客户端介绍">Go 客户端介绍&lt;/h3>
&lt;blockquote>
&lt;p>参考：官方文档：&lt;a href="https://github.com/kubernetes/client-go/#compatibility-matrix">https://github.com/kubernetes/client-go/#compatibility-matrix&lt;/a>
详见 &lt;a href="https://www.yuque.com/go/doc/33161293">Client Libraries&lt;/a>&lt;/p>
&lt;/blockquote>
&lt;p>版本控制策略：k8s 版本 1.18.8 对应 client-go 版本 0.18.8，其他版本以此类推。&lt;/p>
&lt;p>使用前注意事项：
使用 client-go 之前，需要手动获取对应版本的的 client-go 库。根据版本控制策略，使用如下命令进行初始化&lt;/p>
&lt;pre>&lt;code>go mod init client-go-test
go get k8s.io/client-go@kubernetes-1.19.2
&lt;/code>&lt;/pre>
&lt;p>这是一个使用 client-go 访问 API 的基本示例&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">package&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">import&lt;/span> (
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#34;context&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#34;fmt&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">v1&lt;/span> &lt;span style="color:#e6db74">&amp;#34;k8s.io/apimachinery/pkg/apis/meta/v1&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#34;k8s.io/client-go/kubernetes&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#34;k8s.io/client-go/tools/clientcmd&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">func&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 根据指定的 kubeconfig 创建一个用于连接集群的配置，/root/.kube/config 为 kubectl 命令所用的 config 文件
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#a6e22e">config&lt;/span>, &lt;span style="color:#a6e22e">_&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">clientcmd&lt;/span>.&lt;span style="color:#a6e22e">BuildConfigFromFlags&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;&amp;#34;&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;/root/.kube/config&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 根据 BuildConfigFromFlags 创建的配置，返回一个可以连接集群的指针
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#a6e22e">clientset&lt;/span>, &lt;span style="color:#a6e22e">_&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">kubernetes&lt;/span>.&lt;span style="color:#a6e22e">NewForConfig&lt;/span>(&lt;span style="color:#a6e22e">config&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 根据 NewForConfig 所创建的连接集群的指针，来访问 API，并对集群进行操作
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#a6e22e">pods&lt;/span>, &lt;span style="color:#a6e22e">_&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">clientset&lt;/span>.&lt;span style="color:#a6e22e">CoreV1&lt;/span>().&lt;span style="color:#a6e22e">Pods&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;&amp;#34;&lt;/span>).&lt;span style="color:#a6e22e">List&lt;/span>(&lt;span style="color:#a6e22e">context&lt;/span>.&lt;span style="color:#a6e22e">TODO&lt;/span>(), &lt;span style="color:#a6e22e">v1&lt;/span>.&lt;span style="color:#a6e22e">ListOptions&lt;/span>{})
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">fmt&lt;/span>.&lt;span style="color:#a6e22e">Printf&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;There are %d pods in the cluster\n&amp;#34;&lt;/span>, len(&lt;span style="color:#a6e22e">pods&lt;/span>.&lt;span style="color:#a6e22e">Items&lt;/span>))
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="从-pod-中访问-api">从 Pod 中访问 API&lt;/h2>
&lt;p>从 Pod 内部访问 API 时，定位 API 服务器和向服务器认证身份的操作 与上面描述的外部客户场景不同。&lt;/p>
&lt;p>从 Pod 使用 Kubernetes API 的最简单的方法就是使用官方的 客户端库。 这些库可以自动发现 API 服务器并进行身份验证。&lt;/p>
&lt;h3 id="使用官方客户端库">使用官方客户端库&lt;/h3>
&lt;p>从一个 Pod 内部连接到 Kubernetes API 的推荐方式为：&lt;/p>
&lt;ul>
&lt;li>对于 Go 语言客户端，使用官方的 Go 客户端库。 函数 &lt;code>rest.InClusterConfig()&lt;/code> 自动处理 API 主机发现和身份认证。 参见这里的一个例子。&lt;/li>
&lt;li>对于 Python 客户端，使用官方的 Python 客户端库。 函数 &lt;code>config.load_incluster_config()&lt;/code> 自动处理 API 主机的发现和身份认证。 参见这里的一个例子。&lt;/li>
&lt;li>还有一些其他可用的客户端库，请参阅客户端库页面。&lt;/li>
&lt;/ul>
&lt;p>在以上场景中，客户端库都使用 Pod 的服务账号凭据来与 API 服务器安全地通信。&lt;/p>
&lt;h3 id="直接访问-rest-api">直接访问 REST API&lt;/h3>
&lt;p>在运行在 Pod 中时，可以通过 &lt;code>default&lt;/code> 命名空间中的名为 &lt;code>kubernetes&lt;/code> 的服务访问 Kubernetes API 服务器。也就是说，Pod 可以使用 &lt;code>kubernetes.default.svc&lt;/code> 主机名 来查询 API 服务器。官方客户端库自动完成这个工作。&lt;/p>
&lt;p>向 API 服务器进行身份认证的推荐做法是使用 &lt;a href="https://kubernetes.io/zh/docs/tasks/configure-pod-container/configure-service-account/">服务账号&lt;/a> 凭据。 默认情况下，每个 Pod 与一个服务账号关联，该服务账户的凭证（令牌）放置在此 Pod 中 每个容器的文件系统树中的 &lt;code>/var/run/secrets/kubernetes.io/serviceaccount/token&lt;/code> 处。&lt;/p>
&lt;p>如果由证书包可用，则凭证包被放入每个容器的文件系统树中的 &lt;code>/var/run/secrets/kubernetes.io/serviceaccount/ca.crt&lt;/code> 处， 且将被用于验证 API 服务器的服务证书。&lt;/p>
&lt;p>最后，用于命名空间域 API 操作的默认命名空间放置在每个容器中的 &lt;code>/var/run/secrets/kubernetes.io/serviceaccount/namespace&lt;/code> 文件中。&lt;/p>
&lt;h3 id="使用-kubectl-proxy">使用 kubectl proxy&lt;/h3>
&lt;p>如果你希望不实用官方客户端库就完成 API 查询，可以将 &lt;code>kubectl proxy&lt;/code> 作为 command 在 Pod 启动一个边车（Sidecar）容器。&lt;/p>
&lt;p>这样，&lt;code>kubectl proxy&lt;/code> 自动完成对 API 的身份认证，并将其暴露到 Pod 的 &lt;code>localhost&lt;/code> 接口，从而 Pod 中的其他容器可以 直接使用 API。&lt;/p>
&lt;h3 id="不使用代理">不使用代理&lt;/h3>
&lt;p>通过将认证令牌直接发送到 API 服务器，也可以避免运行 kubectl proxy 命令。 内部的证书机制能够为链接提供保护。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># 指向内部 API 服务器的主机名&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>APISERVER&lt;span style="color:#f92672">=&lt;/span>https://kubernetes.default.svc
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># 服务账号令牌的路径&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>SERVICEACCOUNT&lt;span style="color:#f92672">=&lt;/span>/var/run/secrets/kubernetes.io/serviceaccount
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># 读取 Pod 的名字空间&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>NAMESPACE&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#66d9ef">$(&lt;/span>cat &lt;span style="color:#e6db74">${&lt;/span>SERVICEACCOUNT&lt;span style="color:#e6db74">}&lt;/span>/namespace&lt;span style="color:#66d9ef">)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># 读取服务账号的持有者令牌&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>TOKEN&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#66d9ef">$(&lt;/span>cat &lt;span style="color:#e6db74">${&lt;/span>SERVICEACCOUNT&lt;span style="color:#e6db74">}&lt;/span>/token&lt;span style="color:#66d9ef">)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># 引用内部整数机构（CA）&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>CACERT&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">${&lt;/span>SERVICEACCOUNT&lt;span style="color:#e6db74">}&lt;/span>/ca.crt
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># 使用令牌访问 API&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>curl --cacert &lt;span style="color:#e6db74">${&lt;/span>CACERT&lt;span style="color:#e6db74">}&lt;/span> --header &lt;span style="color:#e6db74">&amp;#34;Authorization: Bearer &lt;/span>&lt;span style="color:#e6db74">${&lt;/span>TOKEN&lt;span style="color:#e6db74">}&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span> -X GET &lt;span style="color:#e6db74">${&lt;/span>APISERVER&lt;span style="color:#e6db74">}&lt;/span>/api
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>输出类似于：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-json" data-lang="json">&lt;span style="display:flex;">&lt;span>{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;kind&amp;#34;&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;APIVersions&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;versions&amp;#34;&lt;/span>: [&lt;span style="color:#e6db74">&amp;#34;v1&amp;#34;&lt;/span>],
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;serverAddressByClientCIDRs&amp;#34;&lt;/span>: [
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;clientCIDR&amp;#34;&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;0.0.0.0/0&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;serverAddress&amp;#34;&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;10.0.1.149:443&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h1 id="api-server-健康检查点">API Server 健康检查点&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;a href="https://kubernetes.io/docs/reference/using-api/health-checks/">官方文档&lt;/a>&lt;/p>
&lt;/blockquote>
&lt;p>Kubernetes API 服务器 提供 API 端点以指示 API 服务器的当前状态。 本文描述了这些 API 端点，并说明如何使用。&lt;/p>
&lt;h3 id="api-健康检查点">API 健康检查点&lt;/h3>
&lt;p>Kubernetes API 服务器提供 3 个 API 端点（&lt;code>healthz&lt;/code>、&lt;code>livez&lt;/code> 和 &lt;code>readyz&lt;/code>）来表明 API 服务器的当前状态。 &lt;code>healthz&lt;/code> 端点已被弃用（自 Kubernetes v1.16 起），你应该使用更为明确的 &lt;code>livez&lt;/code> 和 &lt;code>readyz&lt;/code> 端点。 &lt;code>livez&lt;/code> 端点可与 &lt;code>--livez-grace-period&lt;/code> 标志一起使用，来指定启动持续时间。 为了正常关机，你可以使用 &lt;code>/readyz&lt;/code> 端点并指定 &lt;code>--shutdown-delay-duration&lt;/code> 标志。 检查 API 服务器的 &lt;code>health&lt;/code>/&lt;code>livez&lt;/code>/&lt;code>readyz&lt;/code> 端点的机器应依赖于 HTTP 状态代码。 状态码 &lt;code>200&lt;/code> 表示 API 服务器是 &lt;code>healthy&lt;/code>、&lt;code>live&lt;/code> 还是 &lt;code>ready&lt;/code>，具体取决于所调用的端点。 以下更详细的选项供操作人员使用，用来调试其集群或专门调试 API 服务器的状态。&lt;/p>
&lt;p>以下示例将显示如何与运行状况 API 端点进行交互。&lt;/p>
&lt;p>对于所有端点，都可以使用 &lt;code>verbose&lt;/code> 参数来打印检查项以及检查状态。 这对于操作人员调试 API 服务器的当前状态很有用，这些不打算给机器使用：&lt;/p>
&lt;pre>&lt;code>curl -k https://localhost:6443/livez?verbose
&lt;/code>&lt;/pre>
&lt;p>或从具有身份验证的远程主机：&lt;/p>
&lt;pre>&lt;code>kubectl get --raw='/readyz?verbose'
&lt;/code>&lt;/pre>
&lt;p>输出将如下所示：&lt;/p>
&lt;pre>&lt;code>[+]ping ok
[+]log ok
[+]etcd ok
[+]poststarthook/start-kube-apiserver-admission-initializer ok
[+]poststarthook/generic-apiserver-start-informers ok
[+]poststarthook/start-apiextensions-informers ok
[+]poststarthook/start-apiextensions-controllers ok
[+]poststarthook/crd-informer-synced ok
[+]poststarthook/bootstrap-controller ok
[+]poststarthook/rbac/bootstrap-roles ok
[+]poststarthook/scheduling/bootstrap-system-priority-classes ok
[+]poststarthook/start-cluster-authentication-info-controller ok
[+]poststarthook/start-kube-aggregator-informers ok
[+]poststarthook/apiservice-registration-controller ok
[+]poststarthook/apiservice-status-available-controller ok
[+]poststarthook/kube-apiserver-autoregistration ok
[+]autoregister-completion ok
[+]poststarthook/apiservice-openapi-controller ok
healthz check passed
&lt;/code>&lt;/pre>
&lt;p>Kubernetes API 服务器也支持排除特定的检查项。 查询参数也可以像以下示例一样进行组合：&lt;/p>
&lt;pre>&lt;code>curl -k 'https://localhost:6443/readyz?verbose&amp;amp;exclude=etcd'
&lt;/code>&lt;/pre>
&lt;p>输出显示排除了 &lt;code>etcd&lt;/code> 检查：&lt;/p>
&lt;pre>&lt;code>[+]ping ok
[+]log ok
[+]etcd excluded: ok
[+]poststarthook/start-kube-apiserver-admission-initializer ok
[+]poststarthook/generic-apiserver-start-informers ok
[+]poststarthook/start-apiextensions-informers ok
[+]poststarthook/start-apiextensions-controllers ok
[+]poststarthook/crd-informer-synced ok
[+]poststarthook/bootstrap-controller ok
[+]poststarthook/rbac/bootstrap-roles ok
[+]poststarthook/scheduling/bootstrap-system-priority-classes ok
[+]poststarthook/start-cluster-authentication-info-controller ok
[+]poststarthook/start-kube-aggregator-informers ok
[+]poststarthook/apiservice-registration-controller ok
[+]poststarthook/apiservice-status-available-controller ok
[+]poststarthook/kube-apiserver-autoregistration ok
[+]autoregister-completion ok
[+]poststarthook/apiservice-openapi-controller ok
[+]shutdown ok
healthz check passed
&lt;/code>&lt;/pre>
&lt;h3 id="独立健康检查">独立健康检查&lt;/h3>
&lt;p>&lt;strong>FEATURE STATE:&lt;/strong> &lt;code>Kubernetes v1.19 [alpha]&lt;/code>每个单独的健康检查都会公开一个 http 端点，并且可以单独检查。 单个运行状况检查的模式为 &lt;code>/livez/&amp;lt;healthcheck-name&amp;gt;&lt;/code>，其中 &lt;code>livez&lt;/code> 和 &lt;code>readyz&lt;/code> 表明你要检查的是 API 服务器是否存活或就绪。 &lt;code>&amp;lt;healthcheck-name&amp;gt;&lt;/code> 的路径可以通过上面的 &lt;code>verbose&lt;/code> 参数发现 ，并采用 &lt;code>[+]&lt;/code> 和 &lt;code>ok&lt;/code> 之间的路径。 这些单独的健康检查不应由机器使用，但对于操作人员调试系统而言，是有帮助的：&lt;/p>
&lt;pre>&lt;code>curl -k https://localhost:6443/livez/etcd
&lt;/code>&lt;/pre>
&lt;h1 id="api-server-与-etcd-的交互方式">API Server 与 Etcd 的交互方式&lt;/h1>
&lt;p>数据通过 API Server 时，一般是进行序列化后保存到 etcd 中的，可以使用参数 &amp;ndash;etcd-prefix 来指定数据保存在 etcd 中后的地址前缀，默认为 &lt;code>/registry&lt;/code>&lt;/p>
&lt;p>一般情况，保存到 etcd 中后，会省略 Group 与 Version，直接使用 Resource 来作为 etcd 中的路径。比如：URI 为 /api/v1/namespaces/kube-system/pods/kube-apiserver-master1 的 pod 资源，在 etcd 中的存储路径为 /registry/pods/kube-system/kube-apiserver-master1。&lt;/p>
&lt;p>而序列化的方式可以通过 &amp;ndash;storage-media-type 来指定，默认为 protobuf 。使用这种方式将数据序列化之后，得出来的将会有很多乱码，详见 &lt;a href="https://www.yuque.com/go/doc/33166015">Etcd 数据探秘章节&lt;/a> 中的说明&lt;/p>
&lt;h1 id="kube-apiserver-manifests-示例">kube-apiserver Manifests 示例&lt;/h1>
&lt;pre>&lt;code>apiVersion: v1
kind: Pod
metadata:
annotations:
kubeadm.kubernetes.io/kube-apiserver.advertise-address.endpoint: 172.19.42.231:6443
creationTimestamp: null
labels:
component: kube-apiserver
tier: control-plane
name: kube-apiserver
namespace: kube-system
spec:
containers:
- command:
- kube-apiserver
- --advertise-address=172.19.42.231
- --allow-privileged=true
- --authorization-mode=Node,RBAC
- --client-ca-file=/etc/kubernetes/pki/ca.crt
- --enable-admission-plugins=NodeRestriction
- --enable-bootstrap-token-auth=true
- --etcd-cafile=/etc/kubernetes/pki/etcd/ca.crt
- --etcd-certfile=/etc/kubernetes/pki/apiserver-etcd-client.crt
- --etcd-keyfile=/etc/kubernetes/pki/apiserver-etcd-client.key
- --etcd-servers=https://127.0.0.1:2379
- --insecure-port=0
- --kubelet-client-certificate=/etc/kubernetes/pki/apiserver-kubelet-client.crt
- --kubelet-client-key=/etc/kubernetes/pki/apiserver-kubelet-client.key
- --kubelet-preferred-address-types=InternalIP,ExternalIP,Hostname
- --proxy-client-cert-file=/etc/kubernetes/pki/front-proxy-client.crt
- --proxy-client-key-file=/etc/kubernetes/pki/front-proxy-client.key
- --requestheader-allowed-names=front-proxy-client
- --requestheader-client-ca-file=/etc/kubernetes/pki/front-proxy-ca.crt
- --requestheader-extra-headers-prefix=X-Remote-Extra-
- --requestheader-group-headers=X-Remote-Group
- --requestheader-username-headers=X-Remote-User
- --secure-port=6443
- --service-account-key-file=/etc/kubernetes/pki/sa.pub
- --service-cluster-ip-range=10.96.0.0/12
- --service-node-port-range=30000-60000
- --tls-cert-file=/etc/kubernetes/pki/apiserver.crt
- --tls-private-key-file=/etc/kubernetes/pki/apiserver.key
image: registry.aliyuncs.com/k8sxio/kube-apiserver:v1.19.2
imagePullPolicy: IfNotPresent
livenessProbe:
failureThreshold: 8
httpGet:
host: 172.19.42.231
path: /livez
port: 6443
scheme: HTTPS
initialDelaySeconds: 10
periodSeconds: 10
timeoutSeconds: 15
name: kube-apiserver
readinessProbe:
failureThreshold: 3
httpGet:
host: 172.19.42.231
path: /readyz
port: 6443
scheme: HTTPS
periodSeconds: 1
timeoutSeconds: 15
resources:
requests:
cpu: 250m
startupProbe:
failureThreshold: 24
httpGet:
host: 172.19.42.231
path: /livez
port: 6443
scheme: HTTPS
initialDelaySeconds: 10
periodSeconds: 10
timeoutSeconds: 15
volumeMounts:
- mountPath: /etc/ssl/certs
name: ca-certs
readOnly: true
- mountPath: /etc/pki
name: etc-pki
readOnly: true
- mountPath: /etc/localtime
name: host-time
readOnly: true
- mountPath: /etc/kubernetes/pki
name: k8s-certs
readOnly: true
hostNetwork: true
priorityClassName: system-node-critical
volumes:
- hostPath:
path: /etc/ssl/certs
type: DirectoryOrCreate
name: ca-certs
- hostPath:
path: /etc/pki
type: DirectoryOrCreate
name: etc-pki
- hostPath:
path: /etc/localtime
type: &amp;quot;&amp;quot;
name: host-time
- hostPath:
path: /etc/kubernetes/pki
type: DirectoryOrCreate
name: k8s-certs
&lt;/code>&lt;/pre></description></item><item><title>Docs: API 参考</title><link>https://desistdaydream.github.io/docs/10.%E4%BA%91%E5%8E%9F%E7%94%9F/2.3.Kubernetes-%E5%AE%B9%E5%99%A8%E7%BC%96%E6%8E%92%E7%B3%BB%E7%BB%9F/1.API-Resource-%E4%B8%8E-Object/API-%E5%8F%82%E8%80%83/API-%E5%8F%82%E8%80%83/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/10.%E4%BA%91%E5%8E%9F%E7%94%9F/2.3.Kubernetes-%E5%AE%B9%E5%99%A8%E7%BC%96%E6%8E%92%E7%B3%BB%E7%BB%9F/1.API-Resource-%E4%B8%8E-Object/API-%E5%8F%82%E8%80%83/API-%E5%8F%82%E8%80%83/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.23">官方文档，参考-API 概述-API&lt;/a>(这里是通过单一页面显示 API 资源各字段详解)
&lt;ul>
&lt;li>链接里是 1.23 的，想查看其他版本 API，改变 URL 中的版本即可。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;a href="https://kubernetes.io/docs/reference/kubernetes-api/">官方文档，参考-KubernetesAPI&lt;/a>(这里是通过多级页面显示 API 资源各字段详解)
&lt;ul>
&lt;li>这些连接的内容，其实是 &lt;code>kubectl explain&lt;/code> 命令的内容显示在浏览器中了。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;a href="https://github.com/kubernetes/kubernetes/blob/master/api/openapi-spec/swagger.json">OpeaAPI 格式文档&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>在本部分笔记后面的章节，各资源 Manifest 详解，其实已经描述了 API 中各个字段的含义。所以本篇文章不会详解每个 API，而是记录一下如何通过 Kubernetes 官网来查找 API 详解，以及如何使用官方文档查看 API 详解。&lt;/p>
&lt;p>如果笔记中记录得不够详细，&lt;code>kubectl explain&lt;/code> 命令也看着不方便，那么通过这篇文章中介绍的官方文档中的 API 详解来查看，将会更加直观。&lt;/p>
&lt;p>&lt;strong>Kubernetes API 参考中将会描述每种资源的 Manifests 中每个字段(即.YAML 中的节点)的含义。&lt;/strong>&lt;/p>
&lt;p>这是单一页面的样子。左侧是根据对资源的分类而形成的目录，右侧是完整的页面&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/dkxdpv/1616120193938-a171af16-575d-4de6-951a-99cdca271a50.png" alt="">&lt;/p>
&lt;p>这是多级页面的样子，该 API 详解是内含在官方文档中的，并且对 API 进行了细致的分类&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/dkxdpv/1616120193972-2c538ed5-7a6f-4aca-bf11-732240aa84d6.png" alt="">&lt;/p>
&lt;h2 id="字段的类型占位符">字段的类型占位符&lt;/h2>
&lt;p>官方文档中，将每个字段的类型，放在字段名称后面的 &lt;code>()&lt;/code> 中，效果如图：&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/kubernetes/api/20230419102123.png" alt="image.png">&lt;/p>
&lt;p>详见：&lt;a href="https://desistdaydream.github.io/docs/2.%E7%BC%96%E7%A8%8B/%E6%97%A0%E6%B3%95%E5%88%86%E7%B1%BB%E7%9A%84%E8%AF%AD%E8%A8%80/YAML.md#%E5%90%84%E7%A7%8D%E4%BA%A7%E5%93%81%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3%E4%B8%AD%E5%AF%B9%20YAML%20%E6%A0%BC%E5%BC%8F%E7%9A%84%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E7%9A%84%E6%8F%8F%E8%BF%B0">YAML&lt;/a> 中关于对各种文档的使用说明示例。&lt;/p>
&lt;p>下面是几种基本的类型介绍：&lt;/p>
&lt;p>&lt;strong>[]TYPE&lt;/strong> # 基本数组组成，数组元素类型为 TYPE，比如 &lt;code>[]STRING&lt;/code> 格式应该就是下面这样&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-yaml" data-lang="yaml">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">args&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#ae81ff">deletecr&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - --&lt;span style="color:#ae81ff">ns&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - --&lt;span style="color:#ae81ff">name&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;strong>OBJECT&lt;/strong> # 基本对象类型，也称为 Mapping 类型。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-yaml" data-lang="yaml">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">resources&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">limits&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">cpu&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;2&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">memory&lt;/span>: &lt;span style="color:#ae81ff">2Gi&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">requests&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">cpu&lt;/span>: &lt;span style="color:#ae81ff">500m&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">memory&lt;/span>: &lt;span style="color:#ae81ff">400Mi&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;strong>[]OBJECT&lt;/strong> # 数组中的元素是对象的特殊类型&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-yaml" data-lang="yaml">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">containers&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#f92672">args&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#ae81ff">AAA&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#ae81ff">BBB&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">name&lt;/span>: &lt;span style="color:#ae81ff">XXX&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">image&lt;/span>: &lt;span style="color:#ae81ff">XXX&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#f92672">name&lt;/span>: &lt;span style="color:#ae81ff">YYY&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">image&lt;/span>: &lt;span style="color:#ae81ff">YYY&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;strong>map[STRING]STRING&lt;/strong> # 特殊的对象类型。键 和 值 的数据类型都是 STRING&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-yaml" data-lang="yaml">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">labels&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">key1&lt;/span>: &lt;span style="color:#ae81ff">value1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">key2&lt;/span>: &lt;span style="color:#ae81ff">value2&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h1 id="api-分类">API 分类&lt;/h1>
&lt;ul>
&lt;li>&lt;a href="https://desistdaydream.github.io/docs/10.%E4%BA%91%E5%8E%9F%E7%94%9F/2.3.Kubernetes%20%E5%AE%B9%E5%99%A8%E7%BC%96%E6%8E%92%E7%B3%BB%E7%BB%9F/1.API%20Resource%20%E4%B8%8E%20Object/API%20%E5%8F%82%E8%80%83/%E5%B7%A5%E4%BD%9C%E8%B4%9F%E8%BD%BD%E8%B5%84%E6%BA%90/%E5%B7%A5%E4%BD%9C%E8%B4%9F%E8%BD%BD%E8%B5%84%E6%BA%90.md">Workloads Resources&lt;/a>(工作负载资源)&lt;/li>
&lt;li>&lt;a href="https://kubernetes.io/docs/reference/kubernetes-api/service-resources/">Services Resources&lt;/a>(服务资源)&lt;/li>
&lt;li>&lt;a href="https://kubernetes.io/docs/reference/kubernetes-api/config-and-storage-resources/">Config and Storage Resources&lt;/a>(配置与存储资源)&lt;/li>
&lt;li>&lt;a href="https://kubernetes.io/docs/reference/kubernetes-api/authentication-resources/">Authentication Resources&lt;/a>(认证资源)&lt;/li>
&lt;li>&lt;a href="https://kubernetes.io/docs/reference/kubernetes-api/authorization-resources/">Authorization Resources&lt;/a>(授权资源)&lt;/li>
&lt;li>&lt;a href="https://kubernetes.io/docs/reference/kubernetes-api/policies-resources/">Policies Resources&lt;/a>(策略资源)&lt;/li>
&lt;li>&lt;a href="https://kubernetes.io/docs/reference/kubernetes-api/extend-resources/">Extend Resources&lt;/a>(扩展资源)&lt;/li>
&lt;li>&lt;a href="https://kubernetes.io/docs/reference/kubernetes-api/cluster-resources/">Cluster Resources&lt;/a>(集群资源)&lt;/li>
&lt;li>&lt;a href="https://kubernetes.io/docs/reference/kubernetes-api/common-definitions/">Common Definitions&lt;/a>(通用定义) # 在多种资源 API 中，嵌入的 API。比如 节点选择器、meta 字段 等等&lt;/li>
&lt;li>&lt;a href="https://kubernetes.io/docs/reference/kubernetes-api/common-parameters/common-parameters/">Common Parameters&lt;/a>&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>在每种资源的 Manifests 中，会有一些共用的部分称为 &lt;a href="https://desistdaydream.github.io/docs/10.%E4%BA%91%E5%8E%9F%E7%94%9F/2.3.Kubernetes%20%E5%AE%B9%E5%99%A8%E7%BC%96%E6%8E%92%E7%B3%BB%E7%BB%9F/1.API%20Resource%20%E4%B8%8E%20Object/API%20%E5%8F%82%E8%80%83/Common%20Definitions(%E9%80%9A%E7%94%A8%E5%AE%9A%E4%B9%89)/Common%20Definitions(%E9%80%9A%E7%94%A8%E5%AE%9A%E4%B9%89).md">Common Definitions(通用定义)&lt;/a>（也可以说是功能定义），比如常见的 &lt;a href="https://desistdaydream.github.io/docs/10.%E4%BA%91%E5%8E%9F%E7%94%9F/2.3.Kubernetes%20%E5%AE%B9%E5%99%A8%E7%BC%96%E6%8E%92%E7%B3%BB%E7%BB%9F/1.API%20Resource%20%E4%B8%8E%20Object/API%20%E5%8F%82%E8%80%83/Common%20Definitions(%E9%80%9A%E7%94%A8%E5%AE%9A%E4%B9%89)/LabelSelector.md">LabelSelector&lt;/a>，这属于资源的 Manifests 的一部分。很多组件在解析 Manifests 中的通用定义时，都会遵循相同的规则。除了通用定义以外的，都属于 K8S 的资源定义，比如定义 &lt;a href="https://desistdaydream.github.io/docs/10.%E4%BA%91%E5%8E%9F%E7%94%9F/2.3.Kubernetes%20%E5%AE%B9%E5%99%A8%E7%BC%96%E6%8E%92%E7%B3%BB%E7%BB%9F/1.API%20Resource%20%E4%B8%8E%20Object/API%20%E5%8F%82%E8%80%83/%E5%B7%A5%E4%BD%9C%E8%B4%9F%E8%BD%BD%E8%B5%84%E6%BA%90/Pod%20Manifest%20%E8%AF%A6%E8%A7%A3.md">Pod&lt;/a> 的 API 参考、定义 &lt;a href="https://desistdaydream.github.io/docs/10.%E4%BA%91%E5%8E%9F%E7%94%9F/2.3.Kubernetes%20%E5%AE%B9%E5%99%A8%E7%BC%96%E6%8E%92%E7%B3%BB%E7%BB%9F/1.API%20Resource%20%E4%B8%8E%20Object/API%20%E5%8F%82%E8%80%83/%E6%9C%8D%E5%8A%A1%E8%B5%84%E6%BA%90/Service%20Manifests%20%E8%AF%A6%E8%A7%A3.md">Service&lt;/a> 的 API 参考等等。&lt;/strong>&lt;/p>
&lt;h2 id="config-and-storage-resources">Config and Storage Resources&lt;/h2>
&lt;h5 id="configmaphttpskubernetesiodocsreferencekubernetes-apiconfig-and-storage-resourcesconfig-map-v1">&lt;a href="https://kubernetes.io/docs/reference/kubernetes-api/config-and-storage-resources/config-map-v1/">ConfigMap&lt;/a>&lt;/h5>
&lt;p>ConfigMap holds configuration data for pods to consume.&lt;/p>
&lt;h5 id="secrethttpskubernetesiodocsreferencekubernetes-apiconfig-and-storage-resourcessecret-v1">&lt;a href="https://kubernetes.io/docs/reference/kubernetes-api/config-and-storage-resources/secret-v1/">Secret&lt;/a>&lt;/h5>
&lt;p>Secret holds secret data of a certain type.&lt;/p>
&lt;h5 id="volumehttpskubernetesiodocsreferencekubernetes-apiconfig-and-storage-resourcesvolume">&lt;a href="https://kubernetes.io/docs/reference/kubernetes-api/config-and-storage-resources/volume/">Volume&lt;/a>&lt;/h5>
&lt;p>Volume represents a named volume in a pod that may be accessed by any container in the pod.&lt;/p>
&lt;h5 id="persistentvolumeclaimhttpskubernetesiodocsreferencekubernetes-apiconfig-and-storage-resourcespersistent-volume-claim-v1">&lt;a href="https://kubernetes.io/docs/reference/kubernetes-api/config-and-storage-resources/persistent-volume-claim-v1/">PersistentVolumeClaim&lt;/a>&lt;/h5>
&lt;p>PersistentVolumeClaim is a user&amp;rsquo;s request for and claim to a persistent volume.&lt;/p>
&lt;h5 id="persistentvolumehttpskubernetesiodocsreferencekubernetes-apiconfig-and-storage-resourcespersistent-volume-v1">&lt;a href="https://kubernetes.io/docs/reference/kubernetes-api/config-and-storage-resources/persistent-volume-v1/">PersistentVolume&lt;/a>&lt;/h5>
&lt;p>PersistentVolume (PV) is a storage resource provisioned by an administrator.&lt;/p>
&lt;h5 id="storageclasshttpskubernetesiodocsreferencekubernetes-apiconfig-and-storage-resourcesstorage-class-v1">&lt;a href="https://kubernetes.io/docs/reference/kubernetes-api/config-and-storage-resources/storage-class-v1/">StorageClass&lt;/a>&lt;/h5>
&lt;p>StorageClass describes the parameters for a class of storage for which PersistentVolumes can be dynamically provisioned.&lt;/p>
&lt;h5 id="volumeattachmenthttpskubernetesiodocsreferencekubernetes-apiconfig-and-storage-resourcesvolume-attachment-v1">&lt;a href="https://kubernetes.io/docs/reference/kubernetes-api/config-and-storage-resources/volume-attachment-v1/">VolumeAttachment&lt;/a>&lt;/h5>
&lt;p>VolumeAttachment captures the intent to attach or detach the specified volume to/from the specified node.&lt;/p>
&lt;h5 id="csidriverhttpskubernetesiodocsreferencekubernetes-apiconfig-and-storage-resourcescsi-driver-v1">&lt;a href="https://kubernetes.io/docs/reference/kubernetes-api/config-and-storage-resources/csi-driver-v1/">CSIDriver&lt;/a>&lt;/h5>
&lt;p>CSIDriver captures information about a Container Storage Interface (CSI) volume driver deployed on the cluster.&lt;/p>
&lt;h5 id="csinodehttpskubernetesiodocsreferencekubernetes-apiconfig-and-storage-resourcescsi-node-v1">&lt;a href="https://kubernetes.io/docs/reference/kubernetes-api/config-and-storage-resources/csi-node-v1/">CSINode&lt;/a>&lt;/h5>
&lt;p>CSINode holds information about all CSI drivers installed on a node.&lt;/p>
&lt;h5 id="csistoragecapacity-v1beta1httpskubernetesiodocsreferencekubernetes-apiconfig-and-storage-resourcescsi-storage-capacity-v1beta1">&lt;a href="https://kubernetes.io/docs/reference/kubernetes-api/config-and-storage-resources/csi-storage-capacity-v1beta1/">CSIStorageCapacity v1beta1&lt;/a>&lt;/h5>
&lt;p>CSIStorageCapacity stores the result of one CSI GetCapacity call.&lt;/p>
&lt;h2 id="authentication-resources">Authentication Resources&lt;/h2>
&lt;h5 id="serviceaccounthttpskubernetesiodocsreferencekubernetes-apiauthentication-resourcesservice-account-v1">&lt;a href="https://kubernetes.io/docs/reference/kubernetes-api/authentication-resources/service-account-v1/">ServiceAccount&lt;/a>&lt;/h5>
&lt;p>ServiceAccount binds together: &lt;em>a name, understood by users, and perhaps by peripheral systems, for an identity&lt;/em> a principal that can be authenticated and authorized * a set of secrets.&lt;/p>
&lt;h5 id="tokenrequesthttpskubernetesiodocsreferencekubernetes-apiauthentication-resourcestoken-request-v1">&lt;a href="https://kubernetes.io/docs/reference/kubernetes-api/authentication-resources/token-request-v1/">TokenRequest&lt;/a>&lt;/h5>
&lt;p>TokenRequest requests a token for a given service account.&lt;/p>
&lt;h5 id="tokenreviewhttpskubernetesiodocsreferencekubernetes-apiauthentication-resourcestoken-review-v1">&lt;a href="https://kubernetes.io/docs/reference/kubernetes-api/authentication-resources/token-review-v1/">TokenReview&lt;/a>&lt;/h5>
&lt;p>TokenReview attempts to authenticate a token to a known user.&lt;/p>
&lt;h5 id="certificatesigningrequesthttpskubernetesiodocsreferencekubernetes-apiauthentication-resourcescertificate-signing-request-v1">&lt;a href="https://kubernetes.io/docs/reference/kubernetes-api/authentication-resources/certificate-signing-request-v1/">CertificateSigningRequest&lt;/a>&lt;/h5>
&lt;p>CertificateSigningRequest objects provide a mechanism to obtain x509 certificates by submitting a certificate signing request, and having it asynchronously approved and issued.&lt;/p>
&lt;h2 id="authorization-resources">Authorization Resources&lt;/h2>
&lt;h5 id="localsubjectaccessreviewhttpskubernetesiodocsreferencekubernetes-apiauthorization-resourceslocal-subject-access-review-v1">&lt;a href="https://kubernetes.io/docs/reference/kubernetes-api/authorization-resources/local-subject-access-review-v1/">LocalSubjectAccessReview&lt;/a>&lt;/h5>
&lt;p>LocalSubjectAccessReview checks whether or not a user or group can perform an action in a given namespace.&lt;/p>
&lt;h5 id="selfsubjectaccessreviewhttpskubernetesiodocsreferencekubernetes-apiauthorization-resourcesself-subject-access-review-v1">&lt;a href="https://kubernetes.io/docs/reference/kubernetes-api/authorization-resources/self-subject-access-review-v1/">SelfSubjectAccessReview&lt;/a>&lt;/h5>
&lt;p>SelfSubjectAccessReview checks whether or the current user can perform an action.&lt;/p>
&lt;h5 id="selfsubjectrulesreviewhttpskubernetesiodocsreferencekubernetes-apiauthorization-resourcesself-subject-rules-review-v1">&lt;a href="https://kubernetes.io/docs/reference/kubernetes-api/authorization-resources/self-subject-rules-review-v1/">SelfSubjectRulesReview&lt;/a>&lt;/h5>
&lt;p>SelfSubjectRulesReview enumerates the set of actions the current user can perform within a namespace.&lt;/p>
&lt;h5 id="subjectaccessreviewhttpskubernetesiodocsreferencekubernetes-apiauthorization-resourcessubject-access-review-v1">&lt;a href="https://kubernetes.io/docs/reference/kubernetes-api/authorization-resources/subject-access-review-v1/">SubjectAccessReview&lt;/a>&lt;/h5>
&lt;p>SubjectAccessReview checks whether or not a user or group can perform an action.&lt;/p>
&lt;h5 id="clusterrolehttpskubernetesiodocsreferencekubernetes-apiauthorization-resourcescluster-role-v1">&lt;a href="https://kubernetes.io/docs/reference/kubernetes-api/authorization-resources/cluster-role-v1/">ClusterRole&lt;/a>&lt;/h5>
&lt;p>ClusterRole is a cluster level, logical grouping of PolicyRules that can be referenced as a unit by a RoleBinding or ClusterRoleBinding.&lt;/p>
&lt;h5 id="clusterrolebindinghttpskubernetesiodocsreferencekubernetes-apiauthorization-resourcescluster-role-binding-v1">&lt;a href="https://kubernetes.io/docs/reference/kubernetes-api/authorization-resources/cluster-role-binding-v1/">ClusterRoleBinding&lt;/a>&lt;/h5>
&lt;p>ClusterRoleBinding references a ClusterRole, but not contain it.&lt;/p>
&lt;h5 id="rolehttpskubernetesiodocsreferencekubernetes-apiauthorization-resourcesrole-v1">&lt;a href="https://kubernetes.io/docs/reference/kubernetes-api/authorization-resources/role-v1/">Role&lt;/a>&lt;/h5>
&lt;p>Role is a namespaced, logical grouping of PolicyRules that can be referenced as a unit by a RoleBinding.&lt;/p>
&lt;h5 id="rolebindinghttpskubernetesiodocsreferencekubernetes-apiauthorization-resourcesrole-binding-v1">&lt;a href="https://kubernetes.io/docs/reference/kubernetes-api/authorization-resources/role-binding-v1/">RoleBinding&lt;/a>&lt;/h5>
&lt;p>RoleBinding references a role, but does not contain it.&lt;/p>
&lt;h2 id="policies-resources">Policies Resources&lt;/h2>
&lt;h5 id="limitrangehttpskubernetesiodocsreferencekubernetes-apipolicy-resourceslimit-range-v1">&lt;a href="https://kubernetes.io/docs/reference/kubernetes-api/policy-resources/limit-range-v1/">LimitRange&lt;/a>&lt;/h5>
&lt;p>LimitRange sets resource usage limits for each kind of resource in a Namespace.&lt;/p>
&lt;h5 id="resourcequotahttpskubernetesiodocsreferencekubernetes-apipolicy-resourcesresource-quota-v1">&lt;a href="https://kubernetes.io/docs/reference/kubernetes-api/policy-resources/resource-quota-v1/">ResourceQuota&lt;/a>&lt;/h5>
&lt;p>ResourceQuota sets aggregate quota restrictions enforced per namespace.&lt;/p>
&lt;h5 id="networkpolicyhttpskubernetesiodocsreferencekubernetes-apipolicy-resourcesnetwork-policy-v1">&lt;a href="https://kubernetes.io/docs/reference/kubernetes-api/policy-resources/network-policy-v1/">NetworkPolicy&lt;/a>&lt;/h5>
&lt;p>NetworkPolicy describes what network traffic is allowed for a set of Pods.&lt;/p>
&lt;h5 id="poddisruptionbudgethttpskubernetesiodocsreferencekubernetes-apipolicy-resourcespod-disruption-budget-v1">&lt;a href="https://kubernetes.io/docs/reference/kubernetes-api/policy-resources/pod-disruption-budget-v1/">PodDisruptionBudget&lt;/a>&lt;/h5>
&lt;p>PodDisruptionBudget is an object to define the max disruption that can be caused to a collection of pods.&lt;/p>
&lt;h5 id="podsecuritypolicy-v1beta1httpskubernetesiodocsreferencekubernetes-apipolicy-resourcespod-security-policy-v1beta1">&lt;a href="https://kubernetes.io/docs/reference/kubernetes-api/policy-resources/pod-security-policy-v1beta1/">PodSecurityPolicy v1beta1&lt;/a>&lt;/h5>
&lt;p>PodSecurityPolicy governs the ability to make requests that affect the Security Context that will be applied to a pod and container.&lt;/p>
&lt;h2 id="extend-resources">Extend Resources&lt;/h2>
&lt;h5 id="customresourcedefinitionhttpskubernetesiodocsreferencekubernetes-apiextend-resourcescustom-resource-definition-v1">&lt;a href="https://kubernetes.io/docs/reference/kubernetes-api/extend-resources/custom-resource-definition-v1/">CustomResourceDefinition&lt;/a>&lt;/h5>
&lt;p>CustomResourceDefinition represents a resource that should be exposed on the API server.&lt;/p>
&lt;h5 id="mutatingwebhookconfigurationhttpskubernetesiodocsreferencekubernetes-apiextend-resourcesmutating-webhook-configuration-v1">&lt;a href="https://kubernetes.io/docs/reference/kubernetes-api/extend-resources/mutating-webhook-configuration-v1/">MutatingWebhookConfiguration&lt;/a>&lt;/h5>
&lt;p>MutatingWebhookConfiguration describes the configuration of and admission webhook that accept or reject and may change the object.&lt;/p>
&lt;h5 id="validatingwebhookconfigurationhttpskubernetesiodocsreferencekubernetes-apiextend-resourcesvalidating-webhook-configuration-v1">&lt;a href="https://kubernetes.io/docs/reference/kubernetes-api/extend-resources/validating-webhook-configuration-v1/">ValidatingWebhookConfiguration&lt;/a>&lt;/h5>
&lt;p>ValidatingWebhookConfiguration describes the configuration of and admission webhook that accept or reject and object without changing it.&lt;/p>
&lt;h2 id="cluster-resources">Cluster Resources&lt;/h2>
&lt;h5 id="nodehttpskubernetesiodocsreferencekubernetes-apicluster-resourcesnode-v1">&lt;a href="https://kubernetes.io/docs/reference/kubernetes-api/cluster-resources/node-v1/">Node&lt;/a>&lt;/h5>
&lt;p>Node is a worker node in Kubernetes.&lt;/p>
&lt;h5 id="namespacehttpskubernetesiodocsreferencekubernetes-apicluster-resourcesnamespace-v1">&lt;a href="https://kubernetes.io/docs/reference/kubernetes-api/cluster-resources/namespace-v1/">Namespace&lt;/a>&lt;/h5>
&lt;p>Namespace provides a scope for Names.&lt;/p>
&lt;h5 id="eventhttpskubernetesiodocsreferencekubernetes-apicluster-resourcesevent-v1">&lt;a href="https://kubernetes.io/docs/reference/kubernetes-api/cluster-resources/event-v1/">Event&lt;/a>&lt;/h5>
&lt;p>Event is a report of an event somewhere in the cluster.&lt;/p>
&lt;h5 id="apiservicehttpskubernetesiodocsreferencekubernetes-apicluster-resourcesapi-service-v1">&lt;a href="https://kubernetes.io/docs/reference/kubernetes-api/cluster-resources/api-service-v1/">APIService&lt;/a>&lt;/h5>
&lt;p>APIService represents a server for a particular GroupVersion.&lt;/p>
&lt;h5 id="leasehttpskubernetesiodocsreferencekubernetes-apicluster-resourceslease-v1">&lt;a href="https://kubernetes.io/docs/reference/kubernetes-api/cluster-resources/lease-v1/">Lease&lt;/a>&lt;/h5>
&lt;p>Lease defines a lease concept.&lt;/p>
&lt;h5 id="runtimeclasshttpskubernetesiodocsreferencekubernetes-apicluster-resourcesruntime-class-v1">&lt;a href="https://kubernetes.io/docs/reference/kubernetes-api/cluster-resources/runtime-class-v1/">RuntimeClass&lt;/a>&lt;/h5>
&lt;p>RuntimeClass defines a class of container runtime supported in the cluster.&lt;/p>
&lt;h5 id="flowschema-v1beta1httpskubernetesiodocsreferencekubernetes-apicluster-resourcesflow-schema-v1beta1">&lt;a href="https://kubernetes.io/docs/reference/kubernetes-api/cluster-resources/flow-schema-v1beta1/">FlowSchema v1beta1&lt;/a>&lt;/h5>
&lt;p>FlowSchema defines the schema of a group of flows.&lt;/p>
&lt;h5 id="prioritylevelconfiguration-v1beta1httpskubernetesiodocsreferencekubernetes-apicluster-resourcespriority-level-configuration-v1beta1">&lt;a href="https://kubernetes.io/docs/reference/kubernetes-api/cluster-resources/priority-level-configuration-v1beta1/">PriorityLevelConfiguration v1beta1&lt;/a>&lt;/h5>
&lt;p>PriorityLevelConfiguration represents the configuration of a priority level.&lt;/p>
&lt;h5 id="bindinghttpskubernetesiodocsreferencekubernetes-apicluster-resourcesbinding-v1">&lt;a href="https://kubernetes.io/docs/reference/kubernetes-api/cluster-resources/binding-v1/">Binding&lt;/a>&lt;/h5>
&lt;p>Binding ties one object to another; for example, a pod is bound to a node by a scheduler.&lt;/p>
&lt;h5 id="componentstatushttpskubernetesiodocsreferencekubernetes-apicluster-resourcescomponent-status-v1">&lt;a href="https://kubernetes.io/docs/reference/kubernetes-api/cluster-resources/component-status-v1/">ComponentStatus&lt;/a>&lt;/h5>
&lt;p>ComponentStatus (and ComponentStatusList) holds the cluster validation info.&lt;/p>
&lt;h1 id="kubernetes-api-删除和弃用流程">Kubernetes API 删除和弃用流程&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://kubernetes.io/docs/reference/using-api/deprecation-policy/">官方文档，参考-API 概述-Kubernetes 弃用策略&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>Kubernetes 项目有一个记录良好的特性弃用策略[1]。该策略规定，只有当同一 API 的更新的、稳定的版本可用时，才可以弃用稳定的 API，并且 API 对于每个稳定性级别都有一个最短的生存期。给弃用的 API，是在未来的 Kubernetes 版本中被标记为删除的 API；它将继续运行，直到给删除（从弃用至少一年），但使用将导致显示警告。删除的 API 在当前版本中不再可用，此时你必须迁移到使用替换的 API。&lt;/p>
&lt;ul>
&lt;li>GA（Generally available，普遍可用）或稳定的 API 版本可能会被标记为弃用，但不得在 Kubernetes 的主要版本中删除。&lt;/li>
&lt;li>测试版或预发布 API 版本弃用后，必须支持 3 个版本。&lt;/li>
&lt;li>Alpha 或实验 API 版本可能会在任何版本中被删除，恕不另行通知。&lt;/li>
&lt;/ul>
&lt;p>无论某个 API 是因为某个功能从测试版升级到稳定版而被删除，还是因为该 API 没有成功，所有的删除都遵循这个弃用策略。每当删除一个 API 时，迁移选项都会在文档中提供说明。&lt;/p></description></item><item><title>Docs: API 与 Resource</title><link>https://desistdaydream.github.io/docs/10.%E4%BA%91%E5%8E%9F%E7%94%9F/2.3.Kubernetes-%E5%AE%B9%E5%99%A8%E7%BC%96%E6%8E%92%E7%B3%BB%E7%BB%9F/1.API-Resource-%E4%B8%8E-Object/API-%E4%B8%8E-Resource/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/10.%E4%BA%91%E5%8E%9F%E7%94%9F/2.3.Kubernetes-%E5%AE%B9%E5%99%A8%E7%BC%96%E6%8E%92%E7%B3%BB%E7%BB%9F/1.API-Resource-%E4%B8%8E-Object/API-%E4%B8%8E-Resource/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://kubernetes.io/docs/concepts/overview/kubernetes-api/">官方文档，概念-概述-Kubernetes API&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://kubernetes.io/docs/reference/using-api/">官方文档，参考-API 概述&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>Kubernetes API 使我们可以查询和操纵 Kubernetes API 中资源的状态。Kubernetes API 符合 &lt;a href="https://www.yuque.com/go/doc/33220383">RESTful 规范&lt;/a>。&lt;/p>
&lt;p>Kubernetes 把自身一切抽象理解为 &lt;strong>Resource(资源)&lt;/strong>，也叫 &lt;strong>API Resource&lt;/strong>(有地方也叫 Group Resource)。对集群的所有操作都是通过对 Kubernetes API 的 HTTP(s) 请求来实现的。可以使用命令 kubectl api-resources 命令查看所有支持的资源。&lt;/p>
&lt;p>kubernetes 控制平面的核心是 &lt;strong>API Server&lt;/strong>。API Server 是实现了 Kubernets API 的应用程序，并为 Kubernetes 公开了一个 HTTP(s) 的 API，以供用户、集群中的不同部分和集群外部组件相互通信。&lt;/p>
&lt;p>Kubernetes 中各种资源(对象)的数据都通过 API 接口被提交到后端的持久化存储（etcd）中，Kubernetes 集群中的各部件之间通过该 API 接口实现解耦合，同时 Kubernetes 集群中一个重要且便捷的管理工具 kubectl 也是通过访问该 API 接口实现其强大的管理功能的。&lt;/p>
&lt;blockquote>
&lt;p>Note：kubectl 就是代替用户执行各种 http 请求的工具&lt;/p>
&lt;/blockquote>
&lt;p>在 Kubernetes 系统中，在大多数情况下，API 定义和实现都符合标准的 HTTP REST 格式，比如通过标准的 HTTP 动词（POST、PUT、GET、DELETE）来完成对相关资源对象的查询、创建、修改、删除等操作。但同时，Kubernetes 也为某些非标准的 REST 行为实现了附加的 API 接口，例如 Watch 某个资源的变化、进入容器执行某个操作等。另外，某些 API 接口可能违背严格的 REST 模式，因为接口返回的不是单一的 JSON 对象，而是其他类型的数据，比如 JSON 对象流或非结构化的文本日志数据等。&lt;/p>
&lt;p>另外，从另一个角度看，其实 kubernetes 就是提供了一个 web 服务，只是这个 web 服务不像传统的 B/S 架构那样，可以通过浏览器直接操作~kubernetes API 就是这个 web 服务的入口。&lt;/p>
&lt;blockquote>
&lt;p>注意：Kubernetes 的 API 与传统意义上的 API 不太一样。传统 API，一个 API 就是一个功能；而 Kubernetes API 中，一个 API 实际上又可以当作功能，也可以当作一个资源。对 API 的操作，就是对 Kubernets 资源进行操作&lt;/p>
&lt;/blockquote>
&lt;h2 id="api-resource资源-分类">API Resource(资源) 分类&lt;/h2>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://kubernetes.io/docs/reference/kubernetes-api/">官方文档，参考-kubernetes API&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.19/">1.19 版本 API 参考(一页模式)&lt;/a>(要查看其他版本，修改 URL 最后的版本号即可)。&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>资源大体可以分为下面几类：&lt;/p>
&lt;ul>
&lt;li>&lt;strong>workload(工作负载)&lt;/strong> # 用于在集群上管理和运行容器
&lt;ul>
&lt;li>Pod，Deployment，StatefuSet，DaemonSet，Job 等&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>Discovery &amp;amp; LB(服务发现及均衡)&lt;/strong> # 可以使用这些资源类型的对象将工作负载“缝合”到一个外部可访问的、负载均衡的服务中。
&lt;ul>
&lt;li>Service，Ingress 等&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>Config &amp;amp; Storage(配置与存储)&lt;/strong> # 这种类型的资源是用于将初始化数据注入到应用程序中并保留容器外部数据的对象。
&lt;ul>
&lt;li>Volume，ConifgMap，secret 等&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>Cluster(集群级资源)&lt;/strong> # 这种类型的资源对象定义了群集本身的配置方式。这些通常仅由集群运营商使用。
&lt;ul>
&lt;li>Namesapces,Node,Role,ClusterRole,RoleBinding,ClusterRoleBinding 等&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>Metadata(元数据型资源)&lt;/strong> # 这种类型的资源是用于配置集群中其他资源行为的对象。
&lt;ul>
&lt;li>HPA，PodTemplate，LimitRange 等&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>各种资源所用的 manifest 文件中的各个字段的含义就可以参考该页面找到详解。&lt;/p>
&lt;h2 id="api-resource资源-的-url-结构">API Resource(资源) 的 URL 结构&lt;/h2>
&lt;p>在 Kubernetes 中，资源的 URL 结构是由：Group（组）、Version（版本）和 Resource（资源种类）三个部分组成的。(还有一种 /metrics，/healthz 之类的结构，这里面的资源是系统自带的，不在任何组里)&lt;/p>
&lt;p>通过这样的结构，整个 Kubernetes 里的所有资源，实际上就可以用如下图的树形结构表示出来：&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/sz9hgm/1616120310758-dc53a2df-2a39-45e9-92e3-9beb5d9101f0.png" alt="">&lt;/p>
&lt;p>比如，如果要创建一个 CronJob 资源&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-yaml" data-lang="yaml">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">apiVersion&lt;/span>: &lt;span style="color:#ae81ff">batch/v2alpha1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">kind&lt;/span>: &lt;span style="color:#ae81ff">CronJob&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>在这个 YAML 文件中，“CronJob”就是资源的种类(Resource)，“batch”就是它的组(Group)，v2alpha1 就是它的版本(Version)。&lt;/p>
&lt;p>现阶段，有两个 API Groups 正在使用&lt;/p>
&lt;ul>
&lt;li>&lt;strong>core group(核心组)&lt;/strong> # 在/api/v1 路径下(由于某些历史原因而并没有在 &lt;code>/apis/core/v1&lt;/code> 路径下)。核心组是不需要 Group 的（即：它们 Group 是 &lt;code>&amp;quot;&amp;quot;&lt;/code>）。URI 路径为 &lt;code>/api/v1&lt;/code>，并且在定义资源的 manifest 文件中 apiVersion 字段的值不用包含组名，直接使用 v1 即可&lt;/li>
&lt;li>&lt;strong>named groups(已命名组)&lt;/strong> # URI 路径为 &lt;code>/apis/$GROUP_NAME/$VERSION&lt;/code>，在定义资源的 manifest 文件中 apiVersion 中省略 apis，使用 GroupName/Version&lt;/li>
&lt;/ul>
&lt;p>Notes:&lt;/p>
&lt;ul>
&lt;li>有的资源是 cluster 级别的(比如 node)，有的资源是 namespace 级别的(比如 pod)，对于 namespace 级别的资源，可以在 Version 和 Resource 中间添加 namespace 字段以获取指定 namespace 下的资源。i.e.&lt;code>/api/v1/namespaces/$NAMESPACE/pods/&lt;/code> (&lt;code>${NAMESPACE}&lt;/code> 就是具体的 namesapce 的名称)。&lt;/li>
&lt;li>所以 namesapce 级别资源的对象的 URI 应该像这样：&lt;code>/api/v1/namespaces/kube-system/pods/coredns-5644d7b6d9-tw4rh&lt;/code>&lt;/li>
&lt;li>而 cluster 级别资源的对象的 URI 则是：&lt;code>/api/v1/nodes/master1&lt;/code>&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>所有资源类型要么受集群范围限制（&lt;code>/apis/GROUP/VERSION/_&lt;/code>），要么受命名空间限制（&lt;code>/apis/GROUP/VERSION/namespaces/NAMESPACE/_&lt;/code>）&lt;/strong>&lt;/p>
&lt;p>集群范围的资源：&lt;/p>
&lt;ul>
&lt;li>GET /apis/GROUP/VERSION/RESOURCETYPE # 返回指定资源类型的资源集合(返回的是一个 list 列表，比如 NodeList 等)&lt;/li>
&lt;li>GET /apis/GROUP/VERSION/RESOURCETYPE/NAME # 返回指定资源类型下名为 NAME 的的资源&lt;/li>
&lt;/ul>
&lt;p>名称空间范围的资源：&lt;/p>
&lt;ul>
&lt;li>GET /apis/GROUP/VERSION/RESOURCETYPE # 返回所有名称空间指定资源类型的实例集合(返回的是一个 list 列表，比如 podList、serviceList 等)&lt;/li>
&lt;li>GET /apis/GROUP/VERSION/namespaces/NAMESPACE/RESOURCETYPE # 返回 NAMESPACE 下指定 ResourceType 的所有实例集合(返回的是一个 list 列表，比如 podList、serviceList 等)&lt;/li>
&lt;li>GET /apis/GROUP/VERSION/namespaces/NAMESPACE/RESOURCETYPE/NAME # 返回 NAMESPACE 下指定 ResourceType，名为 NAME 的实例&lt;/li>
&lt;/ul>
&lt;h1 id="declarative-api声明式-api-的特点">Declarative API(声明式 API) 的特点：&lt;/h1>
&lt;ul>
&lt;li>首先，所谓 &lt;strong>Declarative(声明式)&lt;/strong>，指的就是我只需要提交一个定义好的 API 对象来 &lt;strong>Declarative(声明)&lt;/strong> 我所期望的状态是什么样子。&lt;/li>
&lt;li>其次，“声明式 API”允许有多个 API 写端，以 PATCH 的方式对 API 对象进行修改，而无需关心本地原始 YAML 文件的内容。&lt;/li>
&lt;li>最后，也是最重要的，有了上述两个能力，Kubernetes 项目才可以基于对 API 对象的增、删、改、查，在完全无需外界干预的情况下，完成对“实际状态”和“期望状态”的调谐（Reconcile）过程。&lt;/li>
&lt;/ul>
&lt;p>所以说，声明式 API，才是 Kubernetes 项目编排能力“赖以生存”的核心所在。而想要实现 声明式 API，离不开 Controller 控制器，K8S 的大脑 的工作。&lt;/p>
&lt;h1 id="api-url-使用示例">API URL 使用示例&lt;/h1>
&lt;p>下面是在 1.18.8 版本下获取到的 api 路径结构&lt;/p>
&lt;p>根路径将列出所有可用路径&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-json" data-lang="json">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#960050;background-color:#1e0010">~]#&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">curl&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">--cacert&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">/etc/kubernetes/pki/ca.crt&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">-H&lt;/span> &lt;span style="color:#e6db74">&amp;#34;Authorization: Bearer ${TOKEN}&amp;#34;&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">https:&lt;/span>&lt;span style="color:#75715e">//172.38.40.215:6443/ -s
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;paths&amp;#34;&lt;/span>: [
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#34;/api&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#34;/api/v1&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#34;/apis&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#34;/apis/&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#34;/apis/admissionregistration.k8s.io&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#34;/apis/admissionregistration.k8s.io/v1&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#34;/apis/admissionregistration.k8s.io/v1beta1&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#34;/apis/apiextensions.k8s.io&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#34;/apis/apiextensions.k8s.io/v1&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#34;/apis/apiextensions.k8s.io/v1beta1&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#34;/apis/apiregistration.k8s.io&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#960050;background-color:#1e0010">......&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#960050;background-color:#1e0010">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>如果访问到错误的资源，还会返回 404 的响应码&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-json" data-lang="json">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#960050;background-color:#1e0010">~]#&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">curl&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">-s&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">--cacert&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">/etc/kubernetes/pki/ca.crt&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">-H&lt;/span> &lt;span style="color:#e6db74">&amp;#34;Authorization: Bearer ${TOKEN}&amp;#34;&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">https:&lt;/span>&lt;span style="color:#75715e">//172.38.40.215:6443/api/v1/service
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;kind&amp;#34;&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;Status&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;apiVersion&amp;#34;&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;v1&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;metadata&amp;#34;&lt;/span>: {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> },
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;status&amp;#34;&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;Failure&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;message&amp;#34;&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;the server could not find the requested resource&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;reason&amp;#34;&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;NotFound&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;details&amp;#34;&lt;/span>: {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> },
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;code&amp;#34;&lt;/span>: &lt;span style="color:#ae81ff">404&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>在“组/版本”下面可以看到该“组/版本”下所包含的 API 资源列表&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-json" data-lang="json">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#960050;background-color:#1e0010">~]#&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">curl&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">-s&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">--cacert&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">/etc/kubernetes/pki/ca.crt&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">-H&lt;/span> &lt;span style="color:#e6db74">&amp;#34;Authorization: Bearer ${TOKEN}&amp;#34;&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">https:&lt;/span>&lt;span style="color:#75715e">//172.38.40.215:6443/api/v1/
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;kind&amp;#34;&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;APIResourceList&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;groupVersion&amp;#34;&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;v1&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;resources&amp;#34;&lt;/span>: [
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#960050;background-color:#1e0010">.......&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;name&amp;#34;&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;configmaps&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;singularName&amp;#34;&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;namespaced&amp;#34;&lt;/span>: &lt;span style="color:#66d9ef">true&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;kind&amp;#34;&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;ConfigMap&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;verbs&amp;#34;&lt;/span>: [
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#34;create&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#34;delete&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#34;deletecollection&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#34;get&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#34;list&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#34;patch&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#34;update&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#34;watch&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ],
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;shortNames&amp;#34;&lt;/span>: [
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#34;cm&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ],
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;storageVersionHash&amp;#34;&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;qFsyl6wFWjQ=&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> },
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;name&amp;#34;&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;endpoints&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;singularName&amp;#34;&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;namespaced&amp;#34;&lt;/span>: &lt;span style="color:#66d9ef">true&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;kind&amp;#34;&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;Endpoints&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;verbs&amp;#34;&lt;/span>: [
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#34;create&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#34;delete&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#34;deletecollection&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#34;get&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#34;list&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#34;patch&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#34;update&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#34;watch&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ],
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;shortNames&amp;#34;&lt;/span>: [
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#34;ep&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ],
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;storageVersionHash&amp;#34;&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;fWeeMqaN/OA=&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> },
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#960050;background-color:#1e0010">......&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#960050;background-color:#1e0010">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>在“资源”下可以看到该“资源”下所包含的所有对象，下图是 pod 资源的列表，包含所有 pod 对象及其信息&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-json" data-lang="json">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#960050;background-color:#1e0010">~]#&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">curl&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">-s&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">--cacert&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">/etc/kubernetes/pki/ca.crt&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">-H&lt;/span> &lt;span style="color:#e6db74">&amp;#34;Authorization: Bearer ${TOKEN}&amp;#34;&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">https:&lt;/span>&lt;span style="color:#75715e">//172.38.40.215:6443/api/v1/pods | more
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;kind&amp;#34;&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;PodList&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;apiVersion&amp;#34;&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;v1&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;metadata&amp;#34;&lt;/span>: {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;selfLink&amp;#34;&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;/api/v1/pods&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;resourceVersion&amp;#34;&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;618871&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> },
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;items&amp;#34;&lt;/span>: [
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;metadata&amp;#34;&lt;/span>: {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;name&amp;#34;&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;cattle-cluster-agent-cc6ddc6dc-7f89l&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;generateName&amp;#34;&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;cattle-cluster-agent-cc6ddc6dc-&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;namespace&amp;#34;&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;cattle-system&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;selfLink&amp;#34;&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;/api/v1/namespaces/cattle-system/pods/cattle-cluster-agent-cc6ddc6dc-7f89l&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;uid&amp;#34;&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;72f4a825-feb2-416a-900d-d8401acc9a18&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;resourceVersion&amp;#34;&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;452264&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;creationTimestamp&amp;#34;&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;2020-09-13T09:59:49Z&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;labels&amp;#34;&lt;/span>: {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;app&amp;#34;&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;cattle-cluster-agent&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;pod-template-hash&amp;#34;&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;cc6ddc6dc&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> },
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;ownerReferences&amp;#34;&lt;/span>: [
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;apiVersion&amp;#34;&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;apps/v1&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;kind&amp;#34;&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;ReplicaSet&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;name&amp;#34;&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;cattle-cluster-agent-cc6ddc6dc&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;uid&amp;#34;&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;7d4b6cbe-d6d1-46e3-99e5-8410095880c7&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;controller&amp;#34;&lt;/span>: &lt;span style="color:#66d9ef">true&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;blockOwnerDeletion&amp;#34;&lt;/span>: &lt;span style="color:#66d9ef">true&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ],
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;managedFields&amp;#34;&lt;/span>: [
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#960050;background-color:#1e0010">......&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div></description></item><item><title>Docs: Bash</title><link>https://desistdaydream.github.io/docs/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/4.Terminal-%E4%B8%8E-Shell/Bash/Bash/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/4.Terminal-%E4%B8%8E-Shell/Bash/Bash/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://www.gnu.org/software/bash/">GNU 官网&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Bash_(Unix_shell)">Wiki，Bash&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.man7.org/linux/man-pages/man1/bash.1.html#SHELL_BUILTIN_COMMANDS">Manual(手册)，bash(1)-Shell 内置命令&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://wangdoc.com/bash/index.html">网道，Bash 脚本教程&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>&lt;strong>Bourne Again Shell(简称 Bash)&lt;/strong> 是 Brian Fox 为 GNU 项目编写的 Unix Shell 和编程语言，作为 &lt;strong>Bourne shell(简称 sh)&lt;/strong> 的免费软件替代品，于 1989 年首次发布，已被用作绝大多数 Linux 发行版的默认登录 Shell。Bash 是 Linus Torvalds 在移植 GCC 到 Linux 时最先移植的程序之一。&lt;/p>
&lt;p>Bash 是一种 Shell，学习 Bash，其实也算是学习一种脚本式的编程语言，Bash 本身就是一种类似编译器似的存在。&lt;/p>
&lt;h1 id="bash-关联文件与配置">Bash 关联文件与配置&lt;/h1>
&lt;h2 id="全局配置文件对所有用户生效的配置">全局配置文件，对所有用户生效的配置&lt;/h2>
&lt;p>&lt;strong>/etc/environment&lt;/strong> # 系统的环境变量，所有登录方式都会加载的文件。&lt;/p>
&lt;p>&lt;strong>/etc/profile&lt;/strong> # 任何用户使用 shell 时都会加载的配置。linux 不推荐直接修改该文件。加载该配置时自动加载 /etc/profile.d/_.sh 的所有文件&lt;/p>
&lt;p>&lt;strong>/etc/bashrc&lt;/strong> # 常用于设置登录功能和命令别名。linux 不推荐直接修改该文件。加载该配置时自动加载 /etc/profile.d/_.sh 的所有文件&lt;/p>
&lt;p>&lt;strong>/etc/profile.d/*.sh&lt;/strong> # 类似于 include 的效果。通常用来创建自定义配置。&lt;/p>
&lt;p>在 &lt;strong>/etc/profile&lt;/strong> 和 &lt;strong>/etc/bashrc&lt;/strong> 中都会有如下代码块&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">for&lt;/span> i in /etc/profile.d/*.sh /etc/profile.d/sh.local ; &lt;span style="color:#66d9ef">do&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> &lt;span style="color:#f92672">[&lt;/span> -r &lt;span style="color:#e6db74">&amp;#34;&lt;/span>$i&lt;span style="color:#e6db74">&amp;#34;&lt;/span> &lt;span style="color:#f92672">]&lt;/span>; &lt;span style="color:#66d9ef">then&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> &lt;span style="color:#f92672">[&lt;/span> &lt;span style="color:#e6db74">&amp;#34;&lt;/span>&lt;span style="color:#e6db74">${&lt;/span>-#*i&lt;span style="color:#e6db74">}&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span> !&lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#34;&lt;/span>$-&lt;span style="color:#e6db74">&amp;#34;&lt;/span> &lt;span style="color:#f92672">]&lt;/span>; &lt;span style="color:#66d9ef">then&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> . &lt;span style="color:#e6db74">&amp;#34;&lt;/span>$i&lt;span style="color:#e6db74">&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">else&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> . &lt;span style="color:#e6db74">&amp;#34;&lt;/span>$i&lt;span style="color:#e6db74">&amp;#34;&lt;/span> &amp;gt;/dev/null
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">fi&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">fi&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">done&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>这段脚本的大致意思就是：遍历 /etc/profile.d 目录下所有以 .sh 结尾的文件和 sh.local 文件。判断它们是否可读（&lt;code>[ -r &amp;quot;$i&amp;quot;]&lt;/code>），如果可读，判断当前 Shell启动方式是不是交互式（&lt;code>$-&lt;/code> 中包含 i）的，如果是交互式的，在当前 Shell 进程中执行该脚本（&lt;code>. &amp;quot;$i&amp;quot;&lt;/code>，&lt;code>source &amp;quot;$i&amp;quot;&lt;/code> 的简写， Shell 的模块化方式），否则，也在当前 Shell 进程中执行该脚本，只不过将输出重定向到了 /dev/null 中。&lt;/p>
&lt;blockquote>
&lt;p>&lt;code>${-#*i}&lt;/code> 这个表达式的意思是：从左向右，在 - 变量中找到第一个 i ，并截取 i 之后的子串。&lt;/p>
&lt;/blockquote>
&lt;h2 id="用户配置文件对部分用户生效的配置">用户配置文件，对部分用户生效的配置&lt;/h2>
&lt;blockquote>
&lt;p>这些配置文件一般都定义在用户的家目录当中，所以当某一用户使用 shell 时，就会在其家目录中加载这些配置文件。&lt;/p>
&lt;/blockquote>
&lt;ul>
&lt;li>&lt;strong>~/.bash_profile&lt;/strong> # 仅对当前用户有效。该配置文件会对 ~/.bashrc 进行判断，如果存在，则加载 ~/.bashrc。&lt;/li>
&lt;li>&lt;strong>~/.bash_login&lt;/strong> # 仅对当前用户有效。该配置文件会对 ~/.bashrc 进行判断，如果存在，则加载 ~/.bashrc。&lt;/li>
&lt;li>&lt;strong>~/.profile&lt;/strong> # 仅对当前用户有效。该配置文件会对 ~/.bashrc 进行判断，如果存在，则加载 ~/.bashrc。&lt;/li>
&lt;li>其他
&lt;ul>
&lt;li>&lt;strong>~/.bashrc&lt;/strong> # 仅对当前用户有效。该配置文件会对 /etc/bashrc 进行判断，如果存在，则加载 /etc/bashrc。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>Note：&lt;/p>
&lt;ul>
&lt;li>仅在登录的第一次读取一次 bash 这些配置文件，如果在里面加了内容想让其实现，需要重新登录或者用 source FILE 命令来让更改的内容生效）&lt;/li>
&lt;li>用户登录时逐一加载 ~/.bash_profile、~/.bash_login、~/.profile。当任何一个文件存在时，都不再加载其余文件。&lt;/li>
&lt;li>为什么配置文件会有这么多分类呢？详见 《shell 的四种登录与交互模式》章节。不同模式，加载的配置文件是不同的&lt;/li>
&lt;li>这三个文件通常只会存在一个，并且在其中的代码中，包含了判断是否存在 ~/.bashrc 文件并执行的逻辑。&lt;/li>
&lt;/ul>
&lt;h1 id="登录与交互模式">登录与交互模式&lt;/h1>
&lt;p>这里面的概念推荐有一定 Linux 基础了之，尤其是得真正明白 Shell 到底是什么之后再来看。&lt;/p>
&lt;p>首先，有几种对登录类型的描述：&lt;/p>
&lt;ul>
&lt;li>交互式：一个个地输入命令并及时查看它们的输出结果，整个过程都在跟 Shell 不停地互动。&lt;/li>
&lt;li>非交互式：运行一个 Shell 脚本 文件，让所有命令批量化、一次性地执行。&lt;/li>
&lt;li>登录式：需要输入用户名和密码才能使用。&lt;/li>
&lt;li>非登录式：直接可以使用。&lt;/li>
&lt;/ul>
&lt;p>这几种类型的不通组合，决定了运行 Shell 的模式&lt;/p>
&lt;p>当我们运行一个 Shell 之后，Shell 会选择下面 4 中模式之一，作为运行本次 Shell 的模式，&lt;strong>不同的模式，加载的配置文件是不同的&lt;/strong>。&lt;/p>
&lt;ul>
&lt;li>&lt;strong>login + interactive # 登录交互。&lt;/strong>
&lt;ul>
&lt;li>首先读取并执行 /etc/profile。&lt;/li>
&lt;li>然后逐一加载 ~/.bash_profile、~/.bash_login、~/.profile。当任何一个文件存在时，都不再加载其余文件。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>login + non-interactive # 登录不交互。&lt;/strong>
&lt;ul>
&lt;li>与 登录交互 模式相同。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>non-login + interactive # 不登陆交互&lt;/strong>
&lt;ul>
&lt;li>直接加载 ~/.bashrc 文件&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>non-login + non-interactive # 不登陆不交互&lt;/strong>
&lt;ul>
&lt;li>与 不登录交互 模式相同&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h2 id="如何判断是否为交互式-shell-有两种方式">如何判断是否为交互式 Shell? 有两种方式&lt;/h2>
&lt;p>查看特殊变量 &lt;code>-&lt;/code> ，如果输出的值包含 &lt;code>i&lt;/code>，则是交互式，否则是非交互式&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>echo $-
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># 比如下面的情况&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>root@lichenhao:~# ssh 172.19.42.248
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>root@lichenhao:~# echo $-
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>himBHs
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># 当使用 ssh 登录时，使用 -T 参数不分配终端，则 $- 没有 i&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>root@lichenhao:~# ssh -T 172.19.42.248
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>echo $-
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>hBs
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>查看变量 PS1 是否为空，如果不为空，则是交互式，否则为非交互式&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>echo $PS1
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Note：这里需要对“交互式”这三个字进行一下说明。与平时理解的所谓交互式不太一样，这里面虽然人类还是可以与设备交互，但是依然称为“非交互式”。&lt;/p>
&lt;p>如何判断是否为登录式 Shell ?&lt;/p>
&lt;p>执行命令 shopt login_shell，如果 login_shell 的值为 on 表示登录式，为 off 表示非登录式。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>~&lt;span style="color:#f92672">]&lt;/span>&lt;span style="color:#75715e"># shopt login_shell&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>login_shell on
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="典型登录模式总结">典型登录模式总结&lt;/h2>
&lt;ul>
&lt;li>登陆机器后的第一个 shell：登录 + 交互&lt;/li>
&lt;li>通过 ssh 登陆到远程主机：登录 + 交互&lt;/li>
&lt;li>新启动一个 shell 进程，如运行 bash ：不登陆 + 交互&lt;/li>
&lt;li>执行脚本，如 bash script.sh ：不登陆 + 不交互&lt;/li>
&lt;li>运行头部有如 #!/usr/bin/env bash 的可执行文件，如 ./executable ：不登陆 + 不交互&lt;/li>
&lt;li>远程执行脚本，如 ssh user@remote script.sh ：不登陆 + 不交互&lt;/li>
&lt;li>远程执行脚本，同时请求控制台，如 ssh user@remote -t &amp;rsquo;echo $PWD&amp;rsquo; ：不登陆 + 交互&lt;/li>
&lt;li>在图形化界面中打开 terminal：不登陆 + 交互&lt;/li>
&lt;/ul>
&lt;h2 id="登录系统后可自动执行的配置文件">登录系统后可自动执行的配置文件&lt;/h2>
&lt;p>/etc/rc.local&lt;/p>
&lt;ul>
&lt;li>注意：centos7 的 rc.local 没有可执行权限，需要添加权限(chmod +x /etc/rc.d/rc.local)，否则无法使用&lt;/li>
&lt;li>官方推荐使用 systemd 来管理启动脚本。而不是这种方式&lt;/li>
&lt;/ul>
&lt;h1 id="在-bash-中执行命令">在 Bash 中执行命令&lt;/h1>
&lt;h2 id="source-程序">source 程序&lt;/h2>
&lt;p>source 程序可以在当前 Shell 环境中从指定文件中读取并执行命令&lt;/p>
&lt;p>注意：该命令可以使当前环境的配置文件在此环境中立刻生效而不用重启机器&lt;/p>
&lt;p>作用：&lt;/p>
&lt;ul>
&lt;li>这个命令其实只是简单地读取脚本里面的语句依次在当前 shell 里面执行，没有建立新的子 shell。那么脚本里面所有新建、改变变量的语句都会保存在当前 shell 里面&lt;/li>
&lt;li>source 命令(从 C Shell 而来)是 bash shell 的内置命令。&lt;/li>
&lt;li>source(或点)命令通常用于重新执行刚修改的初始化文档。&lt;/li>
&lt;/ul>
&lt;p>应用实例：一般用于写在 shell 脚本中，通过 source 执行外部文件中是变量赋值，这样不建立子 shell 的话，外部文件中的变量就可以在该脚本启动的 shell 中引用&lt;/p>
&lt;p>&lt;strong>source [选项] FILENAME&lt;/strong> # 使环境变量立刻生效&lt;/p>
&lt;p>在当前 bash 环境下读取并执行 FileName 中的命令。该 filename 文件可以“无执行权限”&lt;/p>
&lt;p>EXAMPLE：&lt;/p>
&lt;ul>
&lt;li>source openrc admin admin # 运行 openrc 这个配置文件，把第一个参数 admin 和第二个参数 admin 送给 openrc 文件中的$1 和$2&lt;/li>
&lt;li>source .bash_profile #&lt;/li>
&lt;/ul>
&lt;h2 id="sh-和-bash-程序">sh 和 bash 程序&lt;/h2>
&lt;p>实际上，执行 sh 或者 bash 就是相当于打开新的子 shell，并在新的 shell 中执行后续的命令。只不过 bash 与 sh 是不同的 shell，内置的功能有一些细微的区别。&lt;/p>
&lt;p>作用:&lt;/p>
&lt;ul>
&lt;li>开启一个新的 shell，读取并执行 File 中的命令。该 file 可以“无执行权限”&lt;/li>
&lt;li>注：两者在执行文件时的不同，是分别用自己的 shell 来跑文件。
&lt;ul>
&lt;li>sh 使用“-n”选项进行 shell 脚本的语法检查，使用“-x”选项实现 shell 脚本逐条语句的跟踪&lt;/li>
&lt;li>可以巧妙地利用 shell 的内置变量增强“-x”选项的输出信息等。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>bash [OPTIONS] [File]&lt;/strong> #&lt;/p>
&lt;p>OPTIONS&lt;/p>
&lt;ul>
&lt;li>-n # 对指定文件进行语法检查&lt;/li>
&lt;li>-x # 打印出执行脚本的过程&lt;/li>
&lt;/ul>
&lt;h2 id="-语法">./ 语法&lt;/h2>
&lt;p>作用:&lt;/p>
&lt;ul>
&lt;li>打开一个子 shell 来读取并执行 FileName 中命令。&lt;/li>
&lt;li>注：运行一个 shell 脚本时会启动另一个命令解释器.&lt;/li>
&lt;li>每个 shell 脚本有效地运行在父 shell(parent shell)的一个子进程里. 这个父 shell 是指在一个控制终端或在一个 xterm 窗口中给你命令指示符的进程.shell 脚本也可以启动他自已的子进程. 这些子 shell(即子进程)使脚本并行地，有效率地地同时运行脚本内的多个子任务.&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>Syntax(语法)&lt;/strong>&lt;/p>
&lt;p>&lt;strong>./FileName&lt;/strong>&lt;/p>
&lt;h1 id="命令行补全">命令行补全&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Command-line_completion">Wiki，CommandLineCompletion&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>&lt;strong>Command Line Completion(命令行补全)&lt;/strong> 也称为 &lt;strong>tab completion&lt;/strong>，是命令行解释器的常见功能，在命令行中的程序，可以自动填充部分需要手动输入的命令。&lt;/p>
&lt;p>由 bash-completion 程序实现&lt;/p>
&lt;h2 id="关联文件与配置">关联文件与配置&lt;/h2>
&lt;p>&lt;strong>/etc/bash_completion.d/&lt;/strong> #&lt;/p>
&lt;p>&lt;strong>/usr/share/bash-completion/completions/&lt;/strong> # 各种程序补全功能所需文件的保存目录。&lt;/p></description></item><item><title>Docs: BPF 流量控制机制</title><link>https://desistdaydream.github.io/docs/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2.Kernel%E5%86%85%E6%A0%B8/BPF/BPF-%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6%E6%9C%BA%E5%88%B6/BPF-%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6%E6%9C%BA%E5%88%B6/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2.Kernel%E5%86%85%E6%A0%B8/BPF/BPF-%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6%E6%9C%BA%E5%88%B6/BPF-%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6%E6%9C%BA%E5%88%B6/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>Kernel 网络官方文档：&lt;a href="https://www.kernel.org/doc/html/latest/networking/filter.html#">LInux Socket Filtering aka Berkeley Packet Filter&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote></description></item><item><title>Docs: C</title><link>https://desistdaydream.github.io/docs/2.%E7%BC%96%E7%A8%8B/%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/C/C/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/2.%E7%BC%96%E7%A8%8B/%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/C/C/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/C_(programming_language)">Wiki,C Programming Language&lt;/a>&lt;/li>
&lt;li>&lt;a href="http://www.open-std.org/jtc1/sc22/wg14/">ISO C 工作组官网&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://wangdoc.com/clang/">网道,C&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.learn-c.org/">https://www.learn-c.org/&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;h1 id="hello-world">Hello World&lt;/h1>
&lt;p>代码：&lt;code>hello_world.c&lt;/code>&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-c" data-lang="c">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#include&lt;/span> &lt;span style="color:#75715e">&amp;lt;stdio.h&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>(&lt;span style="color:#66d9ef">void&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">printf&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;Hello World&lt;/span>&lt;span style="color:#ae81ff">\n&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>编译&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>$ gcc hello_world.c
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>运行&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>$ ./a.out
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Hello World
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div></description></item><item><title>Docs: Ceph</title><link>https://desistdaydream.github.io/docs/5.%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8/1.%E5%AD%98%E5%82%A8/%E5%AD%98%E5%82%A8%E7%9A%84%E5%9F%BA%E7%A1%80%E8%AE%BE%E6%96%BD%E6%9E%B6%E6%9E%84/%E5%88%86%E5%B8%83%E5%BC%8F%E5%AD%98%E5%82%A8/Ceph/Ceph/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/5.%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8/1.%E5%AD%98%E5%82%A8/%E5%AD%98%E5%82%A8%E7%9A%84%E5%9F%BA%E7%A1%80%E8%AE%BE%E6%96%BD%E6%9E%B6%E6%9E%84/%E5%88%86%E5%B8%83%E5%BC%8F%E5%AD%98%E5%82%A8/Ceph/Ceph/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://ceph.io/">官网&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://docs.ceph.com/en/latest/">官方文档&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Ceph_(software)">Wiki,Ceph&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://blog.csdn.net/younger_china/article/details/73410727">https://blog.csdn.net/younger_china/article/details/73410727&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>Ceph 是一个开源的分布式存储系统，可以提供 对象存储、快存储、文件存储 能力。是一个 Software Defined Storage(软件定义存储) 的代表性产品。&lt;/p>
&lt;p>一个 Ceph 存储集群至少需要 Ceph Monitor、Ceph Manager、Ceph OSD 这三个组件；如果要运行 Ceph 文件系统客户端，则也需要 Ceph MDS。&lt;/p>
&lt;ul>
&lt;li>&lt;strong>Monitor&lt;/strong> # &lt;strong>Ceph Monitor(Ceph 监视器，简称 ceph-mon)&lt;/strong> 负责维护集群状态的映射关系。通常至少需要 3 个 ceph-mon 以实现高可用，多节点使用 Paxos 算法达成共识。
&lt;ul>
&lt;li>可以这么说，Ceph 集群就是指 ceph-mon 集群。ceph-mon 负责维护的集群状态，就是用来提供存储服务的。&lt;/li>
&lt;li>ceph-mon 映射、ceph-mgr 映射、ceph-osd 映射、ceph-mds 映射、ceph-crush 映射。这些映射是 Ceph 守护进程相互协调所需的关键集群状态，说白了，就是&lt;strong>映射关系&lt;/strong>。
&lt;ul>
&lt;li>这里的映射，英文用的是 Map，其实也有地图的意思，就是表示这个集群有多少个 ceph-mon、有多少个 ceph-mgr 等等，还有底层对象属于哪个 PG，等等等等，这些东西构成了一副 Ceph 的运行图。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>ceph-mon 还负责管理守护进程和客户端之间的身份验证。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>Manager&lt;/strong> # &lt;strong>Ceph Manager(Ceph 管理器，简称 ceph-mgr)&lt;/strong> 负责跟踪运行时指标和 Ceph 集群的当前状态，包括存储利用率、性能、系统负载等。通常至少需要 2 个 ceph-mgr 以实现高可用。
&lt;ul>
&lt;li>ceph-mgr 可以提供 Web 管理页面、关于 Ceph 集群的 Prometheus 格式的监控指标&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>OSD Daemon&lt;/strong> # &lt;strong>Ceph OSD Daemon(Ceph OSD 守护进程，简称 ceph-osd)&lt;/strong> 负责向 OSD 读写数据、处理数据复制、恢复、重新平衡，并通过检查其他 ceph-osd 的心跳向 ceph-mon 和 ceph-mgr 提供一些监控信息。通常至少需要 3 个 ceph-osd 以实现高科用。
&lt;ul>
&lt;li>&lt;strong>Object Storage Device(对象存储设备，简称 OSD)&lt;/strong> 是一个物理或逻辑上的存储单元(比如一块硬盘)，这是 Ceph 得以运行的最基本的存储单元。
&lt;ul>
&lt;li>有的时候，人们容易把 OSD 理解为 Ceph OSD Daemon，这俩是有本质区别的。因为在最早的时候，OSD 有两种含义，一种是 &lt;code>Object Storage Device&lt;/code> 另一种是 &lt;code>Object Storage Daemon&lt;/code>。由于这种称呼的模糊性，后来就将 Object Storage daemon 扩展为 OSD Daemon。OSD 则仅仅代表 Object Storage Device。只不过运行 OSD Daemon 的程序名称，依然沿用了 osd 的名字。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>注意，为了让每一个 OSD 都可以被单独使用并管理，所以每个 OSD 都有一个对应的 ceph-osd 进程来管理。一般情况，Ceph 集群中每个节点，除了系统盘做 Raid 以外，其他硬盘都会单独作为 OSD 使用，且一个节点会有大量磁盘来对应 OSD。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>MDS&lt;/strong> # &lt;strong>Ceph Metadata Server(Ceph 元数据服务器，简称 ceph-mds)&lt;/strong> 代表 Ceph 文件系统元数据。ceph-mds 允许 POSIX 文件系统用户执行基本命令(比如 ls、find 等)，而不会给 Ceph 集群带来巨大负担。
&lt;ul>
&lt;li>注意，Ceph 提供的 块存储 和 对象存储 功能并不使用 ceph-mds。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h2 id="架构">架构&lt;/h2>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://docs.ceph.com/en/latest/architecture/">官方文档，架构&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/sakrws/1630769971104-82bcc0c6-1dbd-4c47-b986-3e5b8321aac0.png" alt="image.png">&lt;/p>
&lt;p>&lt;strong>其实 Ceph 本身就是一个对象存储&lt;/strong>，基于&lt;strong>RADOS&lt;/strong> 实现，并通过 Ceph Client 为上层应用提供了通用的 块存储、文件存储、对象存储 的调用接口。&lt;/p>
&lt;ul>
&lt;li>&lt;strong>RADOS&lt;/strong> # &lt;strong>Reliable Autonomic Distributed Object Store(可靠的、自动化的分布式对象存储，简称 RADOS)&lt;/strong> 是一种由多个主机组成、由 CRUSH 算法实现数据路由的，分布式对象存储系统。是 Ceph 的底层存储系统。
&lt;ul>
&lt;li>OSD 是组成 RADOS 的基本存储单元。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>Ceph Client&lt;/strong> # &lt;strong>Ceph 客户端&lt;/strong>。是可以访问 Ceph 存储集群(即 RADOS) 的 Ceph 组件的集合。
&lt;ul>
&lt;li>&lt;strong>LIBRADOS&lt;/strong> # &lt;strong>Library RADOS(RADOS 库，简称 librados)&lt;/strong>。应用程序可以调用 librados 以直接访问 RADOS。当我们使用 Ceph 时，Ceph 实际上是调用 librados 的 API(这是一个 rpc 接口)，将提交的文件切分为固定大小的数据，存放到 RADOS 中。
&lt;ul>
&lt;li>同时，我们自己也可以使用 librados 开发出类似 ceph-rgw、ceph-rbd 这种应用程序以实现个性化需求。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>RADOSGW&lt;/strong> # &lt;strong>RADOS Gateway(RADOS 网关，简称 radosgw)&lt;/strong>。使用 librados 实现的应用程序，可以提供兼容 S3 和 Swift 对象存储的接口&lt;/li>
&lt;li>&lt;strong>RBD&lt;/strong> # &lt;strong>RADOS Block Device(RADOS 块设备，简称 RBD)&lt;/strong>。使用 librados 实现的应用程序，为 Linux 内核 和 QEMU/KVM 提供一个可靠且完全分布式的块存储设备。&lt;/li>
&lt;li>&lt;strong>CEPH FS&lt;/strong> # &lt;strong>Ceph File System(Ceph 文件系统，简称 CFS)&lt;/strong>。直接使用 RADOS 实现一个符合 POSIX 的分布式文件系统，带有 Linux 内核客户端并支持 FUSE，可以直接挂载使用。甚至可以进一步抽象，实现 NFS 功能。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h2 id="ceph-数据写入流程">Ceph 数据写入流程&lt;/h2>
&lt;p>Ceph 集群从 Ceph 的客户端接收到的数据后，将会切分为一个或多个固定大小的 &lt;strong>RADOS Object(RADOS 对象)&lt;/strong>。Ceph 使用 &lt;strong>Controlled Replication Under Scalable Hashing(简称 CRUSH)&lt;/strong> 算法计算出 RADOS 对象应该放在哪个 &lt;strong>Placement Group(归置组，简称 PG)&lt;/strong>，并进一步计算出，应该由哪个 ceph-osd 来处理这个 PG 并将 PG 存储到指定的 OSD 中。ceph-osd 会通过存储驱动器处理 RADOS 对象的 读、写 和 复制操作。&lt;/p>
&lt;blockquote>
&lt;p>注意：当创建完 Ceph 集群后，会有一个默认的 Pool，Pool 是用来对 PG 进行分组的，且 PG 必须属于一个组，不可独立存在。&lt;/p>
&lt;/blockquote>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/sakrws/1630834243384-b650e1e5-1c84-4846-bdc5-9180a361fb09.png" alt="image.png">&lt;/p>
&lt;p>RADOS 对象有如下几个部分组成&lt;/p>
&lt;ul>
&lt;li>&lt;strong>Object Identify(对象标识符，简称 OID)&lt;/strong> # OID 在整个 Ceph 集群中是唯一。&lt;/li>
&lt;li>&lt;strong>Binary Data(二进制数据数据)&lt;/strong> # 对象的数据&lt;/li>
&lt;li>&lt;strong>Metadata(元数据)&lt;/strong> # 元数据的语义完全取决于 Ceph 客户端。例如，CephFS 使用元数据来存储文件属性，如文件所有者、创建日期、上次修改日期等。&lt;/li>
&lt;/ul>
&lt;p>ceph-osd 将数据作为对象存储在平坦的命名空间中 (例如，没有目录层次结构)。对象具有标识符，二进制数据和由一组名称/值对组成的元数据。&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/sakrws/1630808425695-75766062-7570-47f0-9ae4-916c7819d113.png" alt="image.png">&lt;/p>
&lt;h1 id="rados">RADOS&lt;/h1>
&lt;p>与传统分布式存储不同，传统分布式存储中的 NameNode 极易形成性能瓶颈。基于此，RADOS 设计了一种新的方式来快速找到对象数据。RADOS 中并不需要 NameNode 来存储每个对象的元数据，RADOS 中的对象，都是通过 &lt;strong>Controlled Replication Under Scalable Hashing(简称 CRUSH)&lt;/strong> 算法来快速定位的。&lt;/p>
&lt;h2 id="bluestore">bluestore&lt;/h2>
&lt;p>这是 Ceph 所管理的 OSD 的文件系统类型&lt;/p>
&lt;h1 id="ceph-的存储能力">Ceph 的存储能力&lt;/h1>
&lt;h2 id="块存储">块存储&lt;/h2>
&lt;p>Ceph 通过 RDB 提供块存储能力&lt;/p>
&lt;h2 id="文件存储">文件存储&lt;/h2>
&lt;p>Ceph 通过 CEPHFS 提供文件存储能力&lt;/p>
&lt;h2 id="对象存储">对象存储&lt;/h2>
&lt;p>RADOS Gateway 简称 radosgw，Ceph 通过 radosgw 程序，可以对外提供标准的 S3 或 swift 接口，以实现主流对象存储功能。很多时候，radosgw 程序运行的进程称为 ceph-rgw&lt;/p>
&lt;h1 id="ceph-manager">Ceph Manager&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://docs.ceph.com/en/latest/mgr/">官方文档,Ceph 管理器&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>Ceph Manager 是通过一个名为 ceph-mgr 的二进制程序以守护进程运行的管理器。ceph-mgr 可以向外部监控和管理系统提供额外的监控和接口。&lt;/p>
&lt;p>ceph-mgr 曾经是 ceph-mon 的一部分，自 luinous(12.x) 版本依赖，ceph-mgr 独立出来，成为 Ceph 集群的必选组件。&lt;/p>
&lt;h2 id="dashboard-模块">Dashboard 模块&lt;/h2>
&lt;p>Dashboard 模块是一个内置的基于 Web 的 Ceph 管理和监控程序，通过它可以检查和管理 Ceph 集群中的各个方面和资源。默认监听 &lt;code>8443&lt;/code> 端口&lt;/p>
&lt;p>在 Dashboard 模块中，提供了一组用于管理集群的 RESTful 风格的 API 接口。这组 API 位于 &lt;code>/api&lt;/code> 路径下。详见《[API](&amp;lt;/docs/5.数据存储/1.存储/存储的基础设施架构/Distributed%20Storage(分布式存储)/Ceph/API.md&amp;raquo;)》章节&lt;/p>
&lt;h2 id="prometheus-模块">Prometheus 模块&lt;/h2>
&lt;p>启动 Prometheus 模块后，ceph-mgr 默认在 &lt;code>9283&lt;/code> 端口上暴露 Prometheus 格式的监控指标。&lt;/p>
&lt;h1 id="ceph-radosgw">Ceph RADOSGW&lt;/h1>
&lt;p>默认监听 &lt;code>7480&lt;/code> 端口&lt;/p></description></item><item><title>Docs: Cobbler</title><link>https://desistdaydream.github.io/docs/9.%E8%BF%90%E7%BB%B4/Cobbler/Cobbler/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/9.%E8%BF%90%E7%BB%B4/Cobbler/Cobbler/</guid><description>
&lt;h1 id="前言">前言&lt;/h1>
&lt;p>网络安装服务器套件 Cobbler(补鞋匠) 出现以前，我们一直在做装机民工这份很有前途的职业。自打若干年前 Red Hat 推出了 Kickstart，此后我们顿觉身价倍增。不再需要刻了光盘一台一台地安装 Linux，只要搞定 PXE、DHCP、 TFTP，还有那满屏眼花缭乱不知所云的 Kickstart 脚本，我们就可以像哈里波特一样，轻点魔棒，瞬间安装上百台服务器。这一堆花里胡哨的东西可不是一般人都能整明白的，没有大专以上学历，通不过英语四级， 根本别想玩转。&lt;/p>
&lt;p>总而言之，这是一份多么有前途，多么有技术含量的工作啊。&lt;/p>
&lt;p>很不幸，Red Hat 最新（Cobbler 项目最初在 2008 年左右发布）发布了网络安装服务器套件 Cobbler(补鞋匠)，它已将 Linux 网络安装的技术门槛，从大专以上文化水平，成功降低到初中以下，连补鞋匠都能学会。&lt;/p>
&lt;p>对于我们这些在装机领域浸淫多年，经验丰富，老骥伏枥，志在千里的民工兄弟们来说，不啻为一个晴天霹雳。&lt;/p>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://github.com/cobbler/cobbler">GitHub 项目，cobbler/cobbler&lt;/a>&lt;/li>
&lt;li>&lt;a href="http://cobbler.github.io/">官网&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>Cobbler 是一个 Linux 服务器快速网络安装的服务，而且在经过调整也可以支持网络安装 windows。&lt;/p>
&lt;p>该工具使用 python 开发，小巧轻便（才 15k 行 python 代码），可以通过网络启动(PXE)的方式来快速安装、重装物理服务器和虚拟机，同时还可以管理 DHCP，DNS，TFTP、RSYNC 以及 yum 仓库、构造系统 ISO 镜像。&lt;/p>
&lt;p>Cobbler 可以使用命令行方式管理，也提供了基于 Web 的界面管理工具(cobbler-web)，还提供了 API 接口，可以方便二次开发使用。&lt;/p>
&lt;p>Cobbler 是较早前的 kickstart 的升级版，优点是比较容易配置，还自带 web 界面比较易于管理。&lt;/p>
&lt;p>Cobbler 内置了一个轻量级配置管理系统，但它也支持和其它配置管理系统集成，如 Puppet，暂时不支持 SaltStack。&lt;/p>
&lt;p>Cobbler 客户端 Koan 支持虚拟机安装和操作系统重新安装，使重装系统更便捷。&lt;/p>
&lt;h2 id="cobbler-可以干啥">Cobbler 可以干啥&lt;/h2>
&lt;p>使用 Cobbler，您无需进行人工干预即可安装机器。Cobbler 设置一个 PXE 引导环境（它还可以使用 yaboot 支持 PowerPC），并 控制与安装相关的所有方面，比如网络引导服务（DHCP 和 TFTP）与存储库镜像。当希望安装一台新机器时，Cobbler 可以：&lt;/p>
&lt;p>1）使用一个以前定义的模板来配置 DHCP 服务（如果启用了管理 DHCP）&lt;/p>
&lt;p>2）将一个存储库（yum 或 rsync）建立镜像或解压缩一个媒介，以注册一个新操作系统&lt;/p>
&lt;p>3）在 DHCP 配置文件中为需要安装的机器创建一个条目，并使用指定的参数（IP 和 MAC）&lt;/p>
&lt;p>4）在 TFTP 服务目录下创建适当的 PXE 文件&lt;/p>
&lt;p>5）重新启动 DHCP 服务来反应新的更改&lt;/p>
&lt;p>6）重新启动机器以开始安装（如果电源管理已启动）&lt;/p>
&lt;h2 id="cobbler-支持的系统和功能">Cobbler 支持的系统和功能&lt;/h2>
&lt;p>Cobbler 支持众多的发行版：RedHat、Fedora、CentOS、Debian、Ubuntu 和 SUSE。当添加一个操作系统（通常通过使用 ISO 文件）时，Cobbler 知道如何解压缩合适的文件并调整网络服务，以正确引导机器。&lt;/p>
&lt;p>Cobbler 可以使用 kickstart 模板。基于 Red Hat 或 Fedora 的系统使用 kickstart 文件来自动化安装流程。通过使用模板，就会拥有基本的 kickstart 模板，然后定义如何针对一种配置文件或 机器配置而替换其中的变量。例如，一个模板可能包含两个变量 &lt;code>$domain&lt;/code> 和 &lt;code>$machine_name&lt;/code> 在 Cobbler 配置中，一个配置文件指定 domain=mydomain.com，并且每台使用该配置文件的机器在 machine_name 变量中指定其名称。该配置文件的所有机器都使用相同的 kickstart 安装且针对 domain=mydomain.com 进行配置，但每台机器拥有其自己的机器名称。您仍然可以使用 kickstart 模板 在不同的域中安装其他机器并使用不同的机器名称。&lt;/p>
&lt;p>为了协助管理系统，Cobbler 可通过 fence scripts 连接到各个电源管理环境。Cobbler 支持 apc_snmp、bladecenter、bullpap、drac、 ether_wake、ilo、integrity、ipmilan、ipmitool、lpar、rsa、virsh 和 wti。要重新安装一台机器，可 运行 reboot system foo 命令，而且 Cobbler 会使用必要的 和信息来为您运行恰当的 fence scripts（比如机器插槽数）。&lt;/p>
&lt;p>除了这些特性，还可以使用一个配置管理系统（CMS）。你有两种选择：该工具内的一个内部系统，或者现成的外部 CMS，比如 Chef 或 Puppet。借助内部系统，你可以指定文件模板，这些模板会依据配置参数进行处理（与 kickstart 模板的处理方式一样），然后复制到你指定的位 置。如果必须自动将配置文件部署到特定机器，那么此功能很有用。&lt;/p>
&lt;p>使用 koan 客户端，Cobbler 可从客户端配置虚拟机并重新安装系统。&lt;/p>
&lt;h2 id="cobbler-各个组件之间关系">Cobbler 各个组件之间关系&lt;/h2>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/tegfcw/1616125382993-9ef824a6-a456-4fc4-9eeb-8ca756ca7705.jpeg" alt="">&lt;/p>
&lt;p>主要目的配置网络接口：&lt;/p>
&lt;p>Cobbler 的配置结构基于一组注册的对象。每个对象表示一个与另一个实体相关联的实体（该对象指向另一个对象，或者另一个对象指向该对象）。当一个对象指向另一个对象时，它就继承了被指向对象的数据，并可覆盖或添加更多特定信息。以下对象类型的定义&lt;/p>
&lt;ul>
&lt;li>Distros（发行版）：表示一个操作系统，它承载了内核和 initrd 的信息，以及内核参数等其他数据。使用 cobbler import 命令后即可生成该对象&lt;/li>
&lt;li>Profile（配置文件）：包含一个 Distros、一个 kickstart 文件以及可能的存储库，还包含更多特定的内核参数等其他数据。使用 cobbler import 命令后，会默认使用名为/var/lib/cobbler/kickstarts/sample_end.ks 的 kickstart 文件。&lt;/li>
&lt;li>Systems（系统）：表示将要安装的新机器。它包含一个配置文件或一个镜像，还包含该机器的 IP 和 MAC 地址、电源管理（地址、凭据、类型）、（网卡绑定、设置 valn 等）&lt;/li>
&lt;li>Repository（镜像）：保存一个 yum 或 rsync 存储库的镜像信息&lt;/li>
&lt;li>Image（存储库）：可替换一个包含不属于此类比的额文件的发行版对象（例如，无法分为内核和 initrd 的对象）。&lt;/li>
&lt;/ul>
&lt;p>基于注册的对象以及各个对象之间的关联，Cobbler 知道如何更改文件系统以反应具体配置。因为系统配置的内部是抽象的，所以可以仅关注想要执行的操作。&lt;/p></description></item><item><title>Docs: Common Definitions(通用定义)</title><link>https://desistdaydream.github.io/docs/10.%E4%BA%91%E5%8E%9F%E7%94%9F/2.3.Kubernetes-%E5%AE%B9%E5%99%A8%E7%BC%96%E6%8E%92%E7%B3%BB%E7%BB%9F/1.API-Resource-%E4%B8%8E-Object/API-%E5%8F%82%E8%80%83/Common-Definitions%E9%80%9A%E7%94%A8%E5%AE%9A%E4%B9%89/Common-Definitions%E9%80%9A%E7%94%A8%E5%AE%9A%E4%B9%89/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/10.%E4%BA%91%E5%8E%9F%E7%94%9F/2.3.Kubernetes-%E5%AE%B9%E5%99%A8%E7%BC%96%E6%8E%92%E7%B3%BB%E7%BB%9F/1.API-Resource-%E4%B8%8E-Object/API-%E5%8F%82%E8%80%83/Common-Definitions%E9%80%9A%E7%94%A8%E5%AE%9A%E4%B9%89/Common-Definitions%E9%80%9A%E7%94%A8%E5%AE%9A%E4%B9%89/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://kubernetes.io/docs/reference/kubernetes-api/common-definitions/">官方文档，参考-KubernetesAPI-通用定义&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>Common Definitions(通用定义)&lt;/p>
&lt;h2 id="deleteoptionshttpskubernetesiodocsreferencekubernetes-apicommon-definitionsdelete-options">&lt;a href="https://kubernetes.io/docs/reference/kubernetes-api/common-definitions/delete-options/">DeleteOptions&lt;/a>&lt;/h2>
&lt;p>DeleteOptions may be provided when deleting an API object.&lt;/p>
&lt;h2 id="labelselectordocs10云原生23kubernetes20容器编排系统1api20resource20与20objectapi20参考common20definitions通用定义labelselectormd">&lt;a href="https://desistdaydream.github.io/docs/10.%E4%BA%91%E5%8E%9F%E7%94%9F/2.3.Kubernetes%20%E5%AE%B9%E5%99%A8%E7%BC%96%E6%8E%92%E7%B3%BB%E7%BB%9F/1.API%20Resource%20%E4%B8%8E%20Object/API%20%E5%8F%82%E8%80%83/Common%20Definitions(%E9%80%9A%E7%94%A8%E5%AE%9A%E4%B9%89)/LabelSelector.md">LabelSelector&lt;/a>&lt;/h2>
&lt;p>A label selector is a label query over a set of resources.&lt;/p>
&lt;h2 id="listmetahttpskubernetesiodocsreferencekubernetes-apicommon-definitionslist-meta">&lt;a href="https://kubernetes.io/docs/reference/kubernetes-api/common-definitions/list-meta/">ListMeta&lt;/a>&lt;/h2>
&lt;p>ListMeta describes metadata that synthetic resources must have, including lists and various status objects.&lt;/p>
&lt;h2 id="localobjectreferencehttpskubernetesiodocsreferencekubernetes-apicommon-definitionslocal-object-reference">&lt;a href="https://kubernetes.io/docs/reference/kubernetes-api/common-definitions/local-object-reference/">LocalObjectReference&lt;/a>&lt;/h2>
&lt;p>LocalObjectReference contains enough information to let you locate the referenced object inside the same namespace.&lt;/p>
&lt;h2 id="nodeselectorrequirementhttpskubernetesiodocsreferencekubernetes-apicommon-definitionsnode-selector-requirement">&lt;a href="https://kubernetes.io/docs/reference/kubernetes-api/common-definitions/node-selector-requirement/">NodeSelectorRequirement&lt;/a>&lt;/h2>
&lt;p>A node selector requirement is a selector that contains values, a key, and an operator that relates the key and values.&lt;/p>
&lt;h2 id="objectfieldselectorhttpskubernetesiodocsreferencekubernetes-apicommon-definitionsobject-field-selector">&lt;a href="https://kubernetes.io/docs/reference/kubernetes-api/common-definitions/object-field-selector/">ObjectFieldSelector&lt;/a>&lt;/h2>
&lt;p>ObjectFieldSelector selects an APIVersioned field of an object.&lt;/p>
&lt;h2 id="objectmetadocs10云原生23kubernetes20容器编排系统1api20resource20与20objectapi20参考common20definitions通用定义objectmetamd">&lt;a href="https://desistdaydream.github.io/docs/10.%E4%BA%91%E5%8E%9F%E7%94%9F/2.3.Kubernetes%20%E5%AE%B9%E5%99%A8%E7%BC%96%E6%8E%92%E7%B3%BB%E7%BB%9F/1.API%20Resource%20%E4%B8%8E%20Object/API%20%E5%8F%82%E8%80%83/Common%20Definitions(%E9%80%9A%E7%94%A8%E5%AE%9A%E4%B9%89)/ObjectMeta.md">ObjectMeta&lt;/a>&lt;/h2>
&lt;p>ObjectMeta 是所有资源持久化成对象后必须要具有的元数据，其中包括对象的 名称、所在名称空间 等等。对应的 yaml 字段为 &lt;code>.metadata&lt;/code>&lt;/p>
&lt;h2 id="objectreferencehttpskubernetesiodocsreferencekubernetes-apicommon-definitionsobject-reference">&lt;a href="https://kubernetes.io/docs/reference/kubernetes-api/common-definitions/object-reference/">ObjectReference&lt;/a>&lt;/h2>
&lt;p>ObjectReference contains enough information to let you inspect or modify the referred object.&lt;/p>
&lt;h2 id="patchhttpskubernetesiodocsreferencekubernetes-apicommon-definitionspatch">&lt;a href="https://kubernetes.io/docs/reference/kubernetes-api/common-definitions/patch/">Patch&lt;/a>&lt;/h2>
&lt;p>Patch is provided to give a concrete name and type to the Kubernetes PATCH request body.&lt;/p>
&lt;h2 id="quantityhttpskubernetesiodocsreferencekubernetes-apicommon-definitionsquantity">&lt;a href="https://kubernetes.io/docs/reference/kubernetes-api/common-definitions/quantity/">Quantity&lt;/a>&lt;/h2>
&lt;p>Quantity is a fixed-point representation of a number.&lt;/p>
&lt;h2 id="resourcefieldselectorhttpskubernetesiodocsreferencekubernetes-apicommon-definitionsresource-field-selector">&lt;a href="https://kubernetes.io/docs/reference/kubernetes-api/common-definitions/resource-field-selector/">ResourceFieldSelector&lt;/a>&lt;/h2>
&lt;p>ResourceFieldSelector represents container resources (cpu, memory) and their output format.&lt;/p>
&lt;h2 id="statusdocs10云原生23kubernetes20容器编排系统1api20resource20与20objectapi20参考common20definitions通用定义statusmd">&lt;a href="https://desistdaydream.github.io/docs/10.%E4%BA%91%E5%8E%9F%E7%94%9F/2.3.Kubernetes%20%E5%AE%B9%E5%99%A8%E7%BC%96%E6%8E%92%E7%B3%BB%E7%BB%9F/1.API%20Resource%20%E4%B8%8E%20Object/API%20%E5%8F%82%E8%80%83/Common%20Definitions(%E9%80%9A%E7%94%A8%E5%AE%9A%E4%B9%89)/Status.md">Status&lt;/a>&lt;/h2>
&lt;p>Status 字段是不返回其他对象的调用的返回值。&lt;/p>
&lt;h2 id="typedlocalobjectreferencehttpskubernetesiodocsreferencekubernetes-apicommon-definitionstyped-local-object-reference">&lt;a href="https://kubernetes.io/docs/reference/kubernetes-api/common-definitions/typed-local-object-reference/">TypedLocalObjectReference&lt;/a>&lt;/h2>
&lt;p>TypedLocalObjectReference contains enough information to let you locate the typed referenced object inside the same namespace.&lt;/p></description></item><item><title>Docs: Containerd</title><link>https://desistdaydream.github.io/docs/10.%E4%BA%91%E5%8E%9F%E7%94%9F/2.2.%E5%AE%9E%E7%8E%B0%E5%AE%B9%E5%99%A8%E7%9A%84%E5%B7%A5%E5%85%B7/Containerd/Containerd/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/10.%E4%BA%91%E5%8E%9F%E7%94%9F/2.2.%E5%AE%9E%E7%8E%B0%E5%AE%B9%E5%99%A8%E7%9A%84%E5%B7%A5%E5%85%B7/Containerd/Containerd/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://containerd.io/">官网&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://github.com/containerd/containerd">GitHub 项目，containerd/containerd&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://github.com/containerd/containerd/blob/main/docs/PLUGINS.md">GitHub 项目文档，containerd/docs/PLUGINS.md&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://fuckcloudnative.io/posts/getting-started-with-containerd/">云原生实验室，Containerd 使用教程&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://blog.frognew.com/tags/containerd.html">架构小白，Containerd 标签&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://mp.weixin.qq.com/s/Dr6851XnkNLVFHaj1b13RQ">公众号-云原生实验室，容器中的 Shim 到底是个什么鬼&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>Containerd 是行业标准的容器运行时，着重于简单性，健壮性和可移植性。&lt;/p>
&lt;h2 id="containerd-的前世今生">Containerd 的前世今生&lt;/h2>
&lt;p>很久以前，Docker 强势崛起，以“镜像”这个大招席卷全球，对其他容器技术进行致命的降维打击，使其毫无招架之力，就连 Google 也不例外。Google 为了不被拍死在沙滩上，被迫拉下脸面（当然，跪舔是不可能的），希望 Docker 公司和自己联合推进一个开源的容器运行时作为 Docker 的核心依赖，不然就走着瞧。Docker 公司觉得自己的智商被侮辱了，走着瞧就走着瞧，谁怕谁啊！&lt;/p>
&lt;p>很明显，Docker 公司的这个决策断送了自己的大好前程，造成了今天的悲剧。&lt;/p>
&lt;p>紧接着，Google 联合 Red Hat、IBM 等几位巨佬连哄带骗忽悠 Docker 公司将 &lt;code>libcontainer&lt;/code> 捐给中立的社区（OCI，Open Container Intiative），并改名为 &lt;code>runc&lt;/code>，不留一点 Docker 公司的痕迹~~这还不够，为了彻底扭转 Docker 一家独大的局面，几位大佬又合伙成立了一个基金会叫 &lt;code>CNCF&lt;/code>（Cloud Native Computing Fundation），这个名字想必大家都很熟了，我就不详细介绍了。CNCF 的目标很明确，既然在当前的维度上干不过 Docker，干脆往上爬，升级到大规模容器编排的维度，以此来击败 Docker。Docker 公司当然不甘示弱，搬出了 Swarm 和 Kubernetes 进行 PK，最后的结局大家都知道了，Swarm 战败。然后 Docker 公司耍了个小聪明，将自己的核心依赖 &lt;code>Containerd&lt;/code> 捐给了 CNCF，以此来标榜 Docker 是一个 PaaS 平台。&lt;/p>
&lt;p>很明显，这个小聪明又大大加速了自己的灭亡。&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/ox2yd7/1616122481377-1a01b919-efe6-450a-a439-5493a17e6d70.png" alt="">&lt;/p>
&lt;p>巨佬们心想，想当初想和你合作搞个中立的核心运行时，你死要面子活受罪，就是不同意，好家伙，现在自己搞了一个，还捐出来了，马老师，发生甚莫事了？&lt;/p>
&lt;p>这好吗？&lt;/p>
&lt;p>这不好&lt;/p>
&lt;p>也罢，这倒省事了，我就直接拿 Containerd 来做文章吧。首先呢，为了表示 Kubernetes 的中立性，当然要搞个标准化的容器运行时接口，只要适配了这个接口的容器运行时，都可以和我一起玩耍哦，第一个支持这个接口的当然就是 Containerd 啦。至于这个接口的名字，大家应该都知道了，它叫 CRI（Container Runntime Interface）。这样还不行，为了蛊惑 Docker 公司，Kubernetes 暂时先委屈自己，专门在自己的组件中集成了一个 &lt;code>shim&lt;/code>（你可以理解为垫片），用来将 CRI 的调用翻译成 Docker 的 API，让 Docker 也能和自己愉快地玩耍，温水煮青蛙，养肥了再杀。。。&lt;/p>
&lt;p>就这样，Kubernetes 一边假装和 Docker 愉快玩耍，一边背地里不断优化 Containerd 的健壮性以及和 CRI 对接的丝滑性。现在 Containerd 的翅膀已经完全硬了，是时候卸下我的伪装，和 Docker say bye bye 了。后面的事情大家也都知道了~~&lt;/p>
&lt;p>Docker 这门技术成功了，Docker 这个公司却失败了。&lt;/p>
&lt;h2 id="containerd-架构">Containerd 架构&lt;/h2>
&lt;p>时至今日，Containerd 已经变成一个工业级的容器运行时了，连口号都有了：超简单！超健壮！可移植性超强！&lt;/p>
&lt;p>当然，为了让 Docker 以为自己不会抢饭碗，Containerd 声称自己的设计目的主要是为了嵌入到一个更大的系统中（暗指 Kubernetes），而不是直接由开发人员或终端用户使用。&lt;/p>
&lt;p>事实上呢，Containerd 现在基本上啥都能干了，开发人员或者终端用户可以在宿主机中管理完整的容器生命周期，包括容器镜像的传输和存储、容器的执行和管理、存储和网络等。大家可以考虑学起来了。&lt;/p>
&lt;p>先来看看 Containerd 的架构：&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/ox2yd7/1616122481393-e3bb2fce-f18d-40ec-ac46-4c6d6a664cd6.png" alt="">&lt;/p>
&lt;p>可以看到 Containerd 仍然采用标准的 C/S 架构，服务端通过 &lt;code>GRPC&lt;/code> 协议提供稳定的 API，客户端通过调用服务端的 API 进行高级的操作。&lt;/p>
&lt;p>为了解耦，Containerd 将不同的职责划分给不同的组件，每个组件就相当于一个&lt;strong>子系统&lt;/strong>（subsystem）。连接不同子系统的组件被称为模块。&lt;/p>
&lt;p>总体上 Containerd 被划分为两个子系统：&lt;/p>
&lt;ul>
&lt;li>&lt;strong>Bundle&lt;/strong> : 在 Containerd 中，&lt;code>Bundle&lt;/code> 包含了配置、元数据和根文件系统数据，你可以理解为容器的文件系统。而 &lt;strong>Bundle 子系统&lt;/strong>允许用户从镜像中提取和打包 Bundles。&lt;/li>
&lt;li>&lt;strong>Runtime&lt;/strong> : Runtime 子系统用来执行 Bundles，比如创建容器。&lt;/li>
&lt;/ul>
&lt;p>其中，每一个子系统的行为都由一个或多个&lt;strong>模块&lt;/strong>协作完成（架构图中的 &lt;code>Core&lt;/code> 部分）。每一种类型的模块都以 &lt;strong>Plugin(插件)&lt;/strong> 的形式集成到 Containerd 中，而且插件之间是相互依赖的。例如，上图中的每一个长虚线的方框都表示一种类型的插件，包括 &lt;code>Service Plugin&lt;/code>、&lt;code>Metadata Plugin&lt;/code>、&lt;code>GC Plugin&lt;/code>、&lt;code>Runtime Plugin&lt;/code> 等，其中 &lt;code>Service Plugin&lt;/code> 又会依赖 Metadata Plugin、GC Plugin 和 Runtime Plugin。每一个小方框都表示一个细分的插件，例如 &lt;code>Metadata Plugin&lt;/code> 依赖 Containers Plugin、Content Plugin 等。总之，万物皆插件，插件就是模块，模块就是插件。&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/ox2yd7/1616122481388-5272b6c1-efb6-49f4-a180-5425bef8ed64.png" alt="">&lt;/p>
&lt;p>这里介绍几个常用的插件：&lt;/p>
&lt;ul>
&lt;li>&lt;strong>Content Plugin&lt;/strong> : 提供对镜像中可寻址内容的访问，所有不可变的内容都被存储在这里。&lt;/li>
&lt;li>&lt;strong>Snapshot Plugin&lt;/strong> : 用来管理容器镜像的文件系统快照。镜像中的每一个 layer 都会被解压成文件系统快照，类似于 Docker 中的 &lt;code>graphdriver&lt;/code>。&lt;/li>
&lt;li>&lt;strong>Metrics&lt;/strong> : 暴露各个组件的监控指标。&lt;/li>
&lt;/ul>
&lt;p>从总体来看，Containerd 被分为三个大块：&lt;code>Storage&lt;/code>、&lt;code>Metadata&lt;/code> 和 &lt;code>Runtime&lt;/code>，可以将上面的架构图提炼一下
：
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/ox2yd7/1616122481410-b77c18a6-2bcd-48be-b676-1b285bf1c862.png" alt="">&lt;/p>
&lt;p>这是使用 &lt;strong>bucketbench[1]&lt;/strong> 对 &lt;code>Docker&lt;/code>、&lt;code>crio&lt;/code> 和 &lt;code>Containerd&lt;/code> 的性能测试结果，包括启动、停止和删除容器，以比较它们所耗的时间：&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/ox2yd7/1616122481422-8a56805f-3ef0-46a4-be19-a0a5b1eef44f.png" alt="">&lt;/p>
&lt;p>可以看到 Containerd 在各个方面都表现良好，总体性能还是优越于 &lt;code>Docker&lt;/code> 和 &lt;code>crio&lt;/code> 的。&lt;/p>
&lt;h1 id="containerd-关联文件与配置">Containerd 关联文件与配置&lt;/h1>
&lt;p>&lt;strong>/etc/containerd/config.toml&lt;/strong> # Containerd 运行时配置文件。该文件可以通过 containerd config default 命令来生成一个默认的配置。&lt;/p>
&lt;p>&lt;strong>/var/lib/containerd/*&lt;/strong> # Root(根) 文件夹。用于保存持久化数据，镜像、元数据 所在路径。包括 Snapshots, Content, Metadata 以及各种插件的数据。每一个插件都有自己单独的目录，Containerd 本身不存储任何数据，它的所有功能都来自于已加载的插件。目录下的内容详解，见 &lt;a href="https://desistdaydream.github.io/docs/10.%E4%BA%91%E5%8E%9F%E7%94%9F/2.2.%E5%AE%9E%E7%8E%B0%E5%AE%B9%E5%99%A8%E7%9A%84%E5%B7%A5%E5%85%B7/Containerd/Containerd%20Image.md">《Containerd Image 章节》&lt;/a>&lt;/p>
&lt;ul>
&lt;li>.&lt;strong>/io.containerd.content.v1.content/&lt;/strong> # 镜像的上下文保存目录
&lt;ul>
&lt;li>.&lt;strong>/blobs/&lt;/strong> # 镜像文件系统布局中。blobs 目录数据的存放路径&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>./io.containerd.snapshotter.v1.overlayfs/&lt;/strong> # 镜像的层信息所在目录。&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>/run/containerd/&lt;/strong> # State(状态) 文件夹。用于保存运行时产生的临时数据，也就是容器启动后数据存放目录。包括 sockets、pid、挂载点、运行时状态以及不需要持久化保存的插件数据。&lt;/p>
&lt;ul>
&lt;li>&lt;strong>./io.containerd.runtime.VERSION.ID/&lt;/strong> # Containerd 运行容器时所使用的 runtime 插件，该目录的名称就是插件的版本和名称。该目录下的目录以名称空间命名。
&lt;ul>
&lt;li>&lt;strong>./NAMESPACE/&lt;/strong> # 指定名称空间下的容器启动后的数据(主要就是符合 OCI 标准的 一组 Bundle 文件)保存路径，其内目录名为 ContainerID。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>/var/lib/containerd/ 与 /run/containerd/ 是 Containerd 最常用的两个目录，一个存镜像数据，一个存容器数据。&lt;/p>
&lt;h2 id="目录结构">目录结构&lt;/h2>
&lt;p>在 /var/lib/containerd 和 /run/containerd 目录下，保存了 Containerd 运行所需的所有数据。Containerd 本身不存储任何数据，所有数据都来源于插件的功能。
看一下目录下的层次结构就一目了然了：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>? → tree -L &lt;span style="color:#ae81ff">2&lt;/span> /var/lib/containerd/
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>/var/lib/containerd/
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>├── io.containerd.content.v1.content
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>│ ├── blobs
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>│ └── ingest
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>├── io.containerd.grpc.v1.cri
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>│ ├── containers
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>│ └── sandboxes
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>├── io.containerd.metadata.v1.bolt
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>│ └── meta.db
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>├── io.containerd.runtime.v1.linux
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>│ └── k8s.io
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>├── io.containerd.runtime.v2.task
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>├── io.containerd.snapshotter.v1.aufs
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>│ └── snapshots
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>├── io.containerd.snapshotter.v1.btrfs
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>├── io.containerd.snapshotter.v1.native
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>│ └── snapshots
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>├── io.containerd.snapshotter.v1.overlayfs
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>│ ├── metadata.db
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>│ └── snapshots
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>└── tmpmounts
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">18&lt;/span> directories, &lt;span style="color:#ae81ff">2&lt;/span> files
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>每个子目录，其实都表示的是一个插件名称。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>? → tree -L &lt;span style="color:#ae81ff">2&lt;/span> /run/containerd/
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>/run/containerd/
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>├── containerd.sock
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>├── containerd.sock.ttrpc
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>├── io.containerd.grpc.v1.cri
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>│ ├── containers
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>│ └── sandboxes
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>├── io.containerd.runtime.v1.linux
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>│ └── k8s.io
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>├── io.containerd.runtime.v2.task
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>└── runc
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> └── k8s.io
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">8&lt;/span> directories, &lt;span style="color:#ae81ff">2&lt;/span> files
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h1 id="containerd-插件">Containerd 插件&lt;/h1></description></item><item><title>Docs: Containerd 配置详解</title><link>https://desistdaydream.github.io/docs/10.%E4%BA%91%E5%8E%9F%E7%94%9F/2.2.%E5%AE%9E%E7%8E%B0%E5%AE%B9%E5%99%A8%E7%9A%84%E5%B7%A5%E5%85%B7/Containerd/Containerd-%E9%85%8D%E7%BD%AE%E8%AF%A6%E8%A7%A3/Containerd-%E9%85%8D%E7%BD%AE%E8%AF%A6%E8%A7%A3/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/10.%E4%BA%91%E5%8E%9F%E7%94%9F/2.2.%E5%AE%9E%E7%8E%B0%E5%AE%B9%E5%99%A8%E7%9A%84%E5%B7%A5%E5%85%B7/Containerd/Containerd-%E9%85%8D%E7%BD%AE%E8%AF%A6%E8%A7%A3/Containerd-%E9%85%8D%E7%BD%AE%E8%AF%A6%E8%A7%A3/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://github.com/containerd/containerd/blob/main/docs/man/containerd-config.toml.5.md">Manual(手册),containerd-config.toml(5)&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://manpages.debian.org/bullseye/containerd/containerd-config.toml.5.en.html">Debian Manual&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>Containerd 使用 &lt;a href="https://desistdaydream.github.io/docs/2.%E7%BC%96%E7%A8%8B/%E6%97%A0%E6%B3%95%E5%88%86%E7%B1%BB%E7%9A%84%E8%AF%AD%E8%A8%80/TOML.md">TOML&lt;/a> 作为配置文件的格式，默认配置文件为 /etc/containerd/config.toml，我们可以通过命令来生成一个包含所有配置字段的默认配置文件&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>mkdir -p /etc/containerd
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>containerd config default &amp;gt; /etc/containerd/config.toml
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h1 id="配置文件详解">配置文件详解&lt;/h1>
&lt;h1 id="通用-配置">[通用] 配置&lt;/h1>
&lt;p>&lt;strong>version = 2&lt;/strong> #
&lt;strong>root = &amp;lt;STRING&amp;gt;&lt;/strong> # Containerd 持久化数据路径。&lt;code>默认值：/var/lib/containerd&lt;/code>。
&lt;strong>state = &amp;lt;STRING&amp;gt;&lt;/strong> # Containerd 临时数据路径。&lt;code>默认值：/run/containerd&lt;/code>。
&lt;strong>oom_score = 0&lt;/strong> # 设置 Containerd 的 OOM 权重。&lt;code>默认值：0&lt;/code>。
Containerd 是容器的守护者，一旦发生内存不足的情况，理想的情况应该是先杀死容器，而不是杀死 Containerd。所以需要调整 Containerd 的 &lt;code>OOM&lt;/code> 权重，减少其被 &lt;strong>OOM Kill&lt;/strong> 的几率。最好是将 &lt;code>oom_score&lt;/code> 的值调整为比其他守护进程略低的值。这里的 oom_socre 其实对应的是 &lt;code>/proc/&amp;lt;pid&amp;gt;/oom_socre_adj&lt;/code>，在早期的 Linux 内核版本里使用 &lt;code>oom_adj&lt;/code> 来调整权重, 后来改用 &lt;code>oom_socre_adj&lt;/code> 了。该文件描述如下：
在计算最终的 &lt;code>badness score&lt;/code> 时，会在计算结果是中加上 &lt;code>oom_score_adj&lt;/code> ,这样用户就可以通过该在值来保护某个进程不被杀死或者每次都杀某个进程。其取值范围为 &lt;code>-1000&lt;/code> 到 &lt;code>1000&lt;/code>。如果将该值设置为 &lt;code>-1000&lt;/code>，则进程永远不会被杀死，因为此时 &lt;code>badness score&lt;/code> 永远返回 0。建议 Containerd 将该值设置为 &lt;code>-999&lt;/code> 到 &lt;code>0&lt;/code> 之间。如果作为 Kubernetes 的 Worker 节点，可以考虑设置为 &lt;code>-999&lt;/code>。&lt;/p>
&lt;h1 id="cgroup-配置">[cgroup] 配置&lt;/h1>
&lt;h1 id="debug-配置">[debug] 配置&lt;/h1>
&lt;h1 id="grpc-配置表">[grpc] 配置表&lt;/h1>
&lt;p>&lt;strong>address = &amp;lt;STRING&amp;gt;&lt;/strong> # Containerd 监听的 GRPC 路径。&lt;code>默认值：/run/containerd/containerd.sock&lt;/code>&lt;/p>
&lt;h1 id="metrics-配置">[metrics] 配置&lt;/h1>
&lt;h1 id="plugins-配置">[plugins] 配置&lt;/h1>
&lt;p>详见 [《Plugin 配置》](/docs/10.云原生/2.2.实现容器的工具/Containerd/Containerd%20 配置详解/Plugin%20 配置.md 配置详解/Plugin 配置.md) 章节&lt;/p>
&lt;h1 id="timeouts-配置">[timeouts] 配置&lt;/h1>
&lt;h1 id="ttrpc-配置表">[ttrpc] 配置表&lt;/h1>
&lt;h1 id="配置文件示例">配置文件示例&lt;/h1>
&lt;h2 id="镜像加速配置示例">镜像加速配置示例&lt;/h2>
&lt;p>Containerd 的镜像仓库 mirror 与 Docker 相比有两个区别：&lt;/p>
&lt;ul>
&lt;li>Containerd 只支持通过 &lt;code>CRI&lt;/code> 拉取镜像的 mirror，也就是说，只有通过 &lt;code>crictl&lt;/code> 或者 Kubernetes 调用时 mirror 才会生效，通过 &lt;code>ctr&lt;/code> 拉取是不会生效的。&lt;/li>
&lt;li>&lt;code>Docker&lt;/code> 只支持为 &lt;code>Docker Hub&lt;/code> 配置 mirror，而 &lt;code>Containerd&lt;/code> 支持为任意镜像仓库配置 mirror。&lt;/li>
&lt;/ul>
&lt;p>所以需要修改的部分如下：&lt;/p>
&lt;pre>&lt;code>[plugins.&amp;quot;io.containerd.grpc.v1.cri&amp;quot;.registry]
[plugins.&amp;quot;io.containerd.grpc.v1.cri&amp;quot;.registry.mirrors]
[plugins.&amp;quot;io.containerd.grpc.v1.cri&amp;quot;.registry.mirrors.&amp;quot;docker.io&amp;quot;]
endpoint = [&amp;quot;https://dockerhub.mirrors.nwafu.edu.cn&amp;quot;]
[plugins.&amp;quot;io.containerd.grpc.v1.cri&amp;quot;.registry.mirrors.&amp;quot;k8s.gcr.io&amp;quot;]
endpoint = [&amp;quot;https://registry.aliyuncs.com/k8sxio&amp;quot;]
[plugins.&amp;quot;io.containerd.grpc.v1.cri&amp;quot;.registry.mirrors.&amp;quot;gcr.io&amp;quot;]
endpoint = [&amp;quot;xxx&amp;quot;]
&lt;/code>&lt;/pre>
&lt;h1 id="systemd-配置">Systemd 配置&lt;/h1>
&lt;p>建议通过 systemd 配置 Containerd 作为守护进程运行，配置文件在上文已经被解压出来了：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">[&lt;/span>Unit&lt;span style="color:#f92672">]&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Description&lt;span style="color:#f92672">=&lt;/span>containerd container runtime
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Documentation&lt;span style="color:#f92672">=&lt;/span>https://containerd.io
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>After&lt;span style="color:#f92672">=&lt;/span>network.target local-fs.target
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">[&lt;/span>Service&lt;span style="color:#f92672">]&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>ExecStartPre&lt;span style="color:#f92672">=&lt;/span>-/sbin/modprobe overlay
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>ExecStart&lt;span style="color:#f92672">=&lt;/span>/usr/local/bin/containerd
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Type&lt;span style="color:#f92672">=&lt;/span>notify
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Delegate&lt;span style="color:#f92672">=&lt;/span>yes
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>KillMode&lt;span style="color:#f92672">=&lt;/span>process
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Restart&lt;span style="color:#f92672">=&lt;/span>always
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>RestartSec&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">5&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># Having non-zero Limit*s causes performance problems due to accounting overhead&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># in the kernel. We recommend using cgroups to do container-local accounting.&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>LimitNPROC&lt;span style="color:#f92672">=&lt;/span>infinity
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>LimitCORE&lt;span style="color:#f92672">=&lt;/span>infinity
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>LimitNOFILE&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">1048576&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># Comment TasksMax if your systemd version does not supports it.&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># Only systemd 226 and above support this version.&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>TasksMax&lt;span style="color:#f92672">=&lt;/span>infinity
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>OOMScoreAdjust&lt;span style="color:#f92672">=&lt;/span>-999
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">[&lt;/span>Install&lt;span style="color:#f92672">]&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>WantedBy&lt;span style="color:#f92672">=&lt;/span>multi-user.target
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>这里有两个重要的参数：&lt;/p>
&lt;ul>
&lt;li>&lt;strong>Delegate&lt;/strong> : 这个选项允许 Containerd 以及运行时自己管理自己创建的容器的 &lt;code>cgroups&lt;/code>。如果不设置这个选项，systemd 就会将进程移到自己的 &lt;code>cgroups&lt;/code> 中，从而导致 Containerd 无法正确获取容器的资源使用情况。&lt;/li>
&lt;li>&lt;strong>KillMode&lt;/strong> : 这个选项用来处理 Containerd 进程被杀死的方式。默认情况下，systemd 会在进程的 cgroup 中查找并杀死 Containerd 的所有子进程，这肯定不是我们想要的。&lt;code>KillMode&lt;/code>字段可以设置的值如下。我们需要将 KillMode 的值设置为 &lt;code>process&lt;/code>，这样可以确保升级或重启 Containerd 时不杀死现有的容器。
&lt;ul>
&lt;li>&lt;strong>control-group&lt;/strong>（默认值）：当前控制组里面的所有子进程，都会被杀掉&lt;/li>
&lt;li>&lt;strong>process&lt;/strong>：只杀主进程&lt;/li>
&lt;li>&lt;strong>mixed&lt;/strong>：主进程将收到 SIGTERM 信号，子进程收到 SIGKILL 信号&lt;/li>
&lt;li>&lt;strong>none&lt;/strong>：没有进程会被杀掉，只是执行服务的 stop 命令。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul></description></item><item><title>Docs: CPU</title><link>https://desistdaydream.github.io/docs/0.%E8%AE%A1%E7%AE%97%E6%9C%BA/CPU/CPU/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/0.%E8%AE%A1%E7%AE%97%E6%9C%BA/CPU/CPU/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;p>&lt;strong>Central Processing Unit(中央处理器，简称 CPU)&lt;/strong>。
如同华硕主板示意图上半部的中央部分，那就是 CPU 插槽。由于 CPU 负责大量运算，因此 CPU 通常是具有相当高发热量的元件。所以如果你曾经拆开过主板，应该就会看到 CPU 上头通常会安插一颗风扇来主动散热的。&lt;/p>
&lt;p>x86 个人电脑的 CPU 主要供应商为 Intel 与 AMD，目前（2015）主流的 CPU 都是双核以上的架构了！原本的单核心 CPU 仅有一个运算单元，所谓的多核心则是在一颗 CPU 封装当中嵌入了两个以上的运算核心， 简单的说，就是一个实体的 CPU 外壳中，含有两个以上的 CPU 单元就是了。&lt;/p>
&lt;p>不同的 CPU 型号大多具有不同的脚位（CPU 上面的插脚），能够搭配的主板芯片组也不同， 所以当你想要将你的主机升级时，不能只考虑 CPU，你还得要留意你的主板上面所支持的 CPU 型号喔！不然买了最新的 CPU 也不能够安插在你的旧主板上头的！目前主流的 CPU 有 Intel 的 i3/i5/i7 系列产品中，甚至先后期出厂的类似型号的脚位也不同， 例如 i7-2600 使用 LGA1155 脚位而 i7-4790 则使用 FCLGA1150 脚位，挑选时必须要很小心喔！&lt;/p>
&lt;p>我们前面谈到 CPU 内部含有微指令集，不同的微指令集会导致 CPU 工作效率的优劣。除了这点之外， CPU 性能的比较还有什么呢？那就是 CPU 的频率了！什么是频率呢？简单的说， 频率就是 CPU 每秒钟可以进行的工作次数。所以频率越高表示这颗 CPU 单位时间内可以作更多的事情。举例来说，Intel 的 i7-4790 CPU 频率为 3.6GHz， 表示这颗 CPU 在一秒内可以进行 3.6x109 次工作，每次工作都可以进行少数的指令运行之意。&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/lgtxxk/1616168680795-7c145400-1473-4cdc-b525-3a106f810f80.gif" alt="">&lt;/p>
&lt;p>&lt;strong>Tips&lt;/strong>注意，不同的 CPU 之间不能单纯的以频率来判断运算性能喔！这是因为每颗 CPU 的微指令集不相同，架构也不见得一样，可使用的第二层高速缓存及其计算机制可能也不同，加上每次频率能够进行的工作指令数也不同！所以，频率目前仅能用来比较同款 CPU 的速度！&lt;/p>
&lt;p>CPU 的工作频率：外频与倍频&lt;/p>
&lt;p>早期的 CPU 架构主要通过北桥来链接系统最重要的 CPU、内存与显卡设备。因为所有的设备都得通过北桥来链接，因此每个设备的工作频率应该要相同。于是就有所谓的前端总线（FSB） 这个东西的产生。但因为 CPU 的运算速度比其他的设备都要来的快，又为了要满足 FSB 的频率，因此厂商就在 CPU 内部再进行加速， 于是就有所谓的外频与倍频了。&lt;/p>
&lt;p>总结来说，在早期的 CPU 设计中，所谓的外频指的是 CPU 与外部元件进行数据传输时的速度，倍频则是 CPU 内部用来加速工作性能的一个倍数， 两者相乘才是 CPU 的频率速度。例如 Intel Core 2 E8400 的内频为 3.0GHz，而外频是 333MHz，因此倍频就是 9 倍啰！（3.0G=333Mx9, 其中 1G=1000M）&lt;/p>
&lt;h2 id="超频">超频&lt;/h2>
&lt;p>&lt;strong>Tips&lt;/strong>很多计算机硬件玩家很喜欢玩“超频”，所谓的超频指的是：将 CPU 的倍频或者是外频通过主板的设置功能更改成较高频率的一种方式。但因为 CPU 的倍频通常在出厂时已经被锁定而无法修改，因此较常被超频的为外频。举例来说，像上述 3.0GHz 的 CPU 如果想要超频，可以将他的外频 333MHz 调整成为 400MHz，但如此一来整个主板的各个元件的运行频率可能都会被增加成原本的 1.333 倍(4/ 3)，虽然 CPU 可能可以到达 3.6GHz，但却因为频率并非正常速度，故可能会造成死机等问题。&lt;/p>
&lt;p>但如此一来所有的数据都被北桥卡死了，北桥又不可能比 CPU 更快，因此这家伙常常是系统性能的瓶颈。为了解决这个问题，新的 CPU 设计中， 已经将内存控制器整合到 CPU 内部，而链接 CPU 与内存、显卡的控制器的设计，在 Intel 部份使用 QPI （Quick Path Interconnect） 与 DMI 技术，而 AMD 部份则使用 Hyper Transport 了，这些技术都可以让 CPU 直接与内存、显卡等设备分别进行沟通，而不需要通过外部的链接芯片了。&lt;/p>
&lt;p>因为现在没有所谓的北桥了（整合到 CPU 内），因此，CPU 的频率设计就无须考虑得要同步的外频，只需要考虑整体的频率即可。所以，如果你经常有查阅自己 CPU 频率的习惯，当使用 cpu-z [9]这个软件时，应该会很惊讶的发现到，怎么外频变成 100MHz 而倍频可以到达 30 以上！相当有趣呢！&lt;/p>
&lt;p>&lt;strong>Tips&lt;/strong> 现在 Intel 的 CPU 会主动帮你超频喔！例如 i7-4790 这颗 CPU 的规格[10]中，基本频率为 3.6GHz，但是最高可自动超频到 4GHz 喔！通过的是 Intel 的 turbo 技术。同时，如果你没有大量的运算需求，该 CPU 频率会降到 1.xGHz 而已，借此达到节能省电的目的！所以，各位好朋友，不需要自己手动超频了！Intel 已经自动帮你进行超频了&amp;hellip;所以，如果你用 cpu-z 观察 CPU 频率，发现该频率会一直自动变动，很正常！你的系统没坏掉！&lt;/p>
&lt;p>32 位与 64 位的 CPU 与总线“宽度”&lt;/p>
&lt;p>从前面的简易说明中，我们知道 CPU 的各项数据通通得要来自于内存。因此，如果内存能提供给 CPU 的数据量越大的话，当然整体系统的性能应该也会比较快！那如何知道内存能提供的数据量呢？此时还是得要借由 CPU 内的内存控制芯片与内存间的传输速度“前端总线速度（Front Side Bus, FSB） 来说明。&lt;/p>
&lt;p>与 CPU 的频率类似的，内存也是有其工作的频率，这个频率限制还是来自于 CPU 内的内存控制器所决定的。以图 0.2.1 为例， CPU 内置的内存控制芯片对内存的工作频率最高可达到 1600MHz。这只是工作频率（每秒几次）。一般来说，每次频率能够传输的数据量，大多为 64 位，这个 64 位就是所谓的“宽度”了！因此，在图 0.2.1 这个系统中，CPU 可以从内存中取得的最快带宽就是 1600MHz &lt;em>64bit = 1600MHz&lt;/em> 8 Bytes = 12.8GByte/s。&lt;/p>
&lt;p>与总线宽度相似的，CPU 每次能够处理的数据量称为字组大小（word size）， 字组大小依据 CPU 的设计而有 32 位与 64 位。我们现在所称的电脑是 32 或 64 位主要是依据这个 CPU 解析的字组大小而来的！早期的 32 位 CPU 中，因为 CPU 每次能够解析的数据量有限， 因此由内存传来的数据量就有所限制了。这也导致 32 位的 CPU 最多只能支持最大到 4GBytes 的内存。&lt;/p>
&lt;p>&lt;strong>Tips&lt;/strong> 得利于北桥整合到 CPU 内部的设计，CPU 得以“个别”跟各个元件进行沟通！因此，每种元件与 CPU 的沟通具有很多不同的方式！例如内存使用系统总线带宽来与 CPU 沟通。而显卡则通过 PCI-E 的序列信道设计来与 CPU 沟通喔！详细说明我们在本章稍后的主板部份再来谈谈。&lt;/p>
&lt;p>CPU 等级&lt;/p>
&lt;p>由于 x86 架构的 CPU 在 Intel 的 Pentium 系列（1993 年）后就有不统一的脚位与设计，为了将不同种类的 CPU 规范等级， 所以就有 i386,i586,i686 等名词出现了。基本上，在 Intel Pentium MMX 与 AMD K6 年代的 CPU 称为 i586 等级， 而 Intel Celeron 与 AMD Athlon（K7）年代之后的 32 位 CPU 就称为 i686 等级。至于目前的 64 位 CPU 则统称为 x86_64 等级。&lt;/p>
&lt;p>目前很多的程序都有对 CPU 做最优化的设计，万一哪天你发现一些程序是注明给 x86_64 的 CPU 使用时， 就不要将他安装在 686 以下等级的电脑中，否则可是会无法执行该软件的！不过，在 x86_64 的硬件下倒是可以安装 386 的软件喔！也就是说，这些东西具有向下相容的能力啦！&lt;/p>
&lt;h2 id="超线程hyper-threading-ht">超线程（Hyper-Threading, HT）&lt;/h2>
&lt;p>我们知道现在的 CPU 至少都是两个核心以上的多核心 CPU 了，但是 Intel 还有个很怪的东西，叫做 CPU 的超线程（Hyper-Threading） 功能！那个是啥鬼东西？我们知道现在的 CPU 运算速度都太快了，因此运算核心经常处于闲置状态下。而我们也知道现在的系统大多都是多任务的系统， 同时间有很多的程序会让 CPU 来执行。因此，若 CPU 可以假象的同时执行两个程序，不就可以让系统性能增加了吗？反正 CPU 的运算能力还是没有用完啊！&lt;/p>
&lt;p>那是怎么达成的啊这个 HT 功能？强者鸟哥的同事蔡董大大用个简单的说明来解释。在每一个 CPU 内部将重要的寄存器（register） 分成两群， 而让程序分别使用这两群寄存器。也就是说，可以有两个程序“同时竞争 CPU 的运算单元”，而非通过操作系统的多任务切换！这一过程就会让 CPU 好像“同时有两个核心”的模样！因此，虽然大部分 i7 等级的 CPU 其实只有四个实体核心，但通过 HT 的机制， 则操作系统可以抓到八个核心！并且让每个核心逻辑上分离，就可以同时运行八个程序了。&lt;/p>
&lt;p>虽然很多研究与测试中，大多发现 HT 虽然可以提升性能，不过，有些情况下却可能导致性能降低喔！因为，实际上明明就仅有一个运算单元嘛！不过在鸟哥使用数值模式的情况下，因为鸟哥操作的数值模式主要为平行运算功能，且运算通常无法达到 100% 的 CPU 使用率，通常仅有大约 60%运算量而已。因此在鸟哥的实作过程中，这个 HT 确实提升相当多的性能！至少应该可以节省鸟哥大约 30%~50%的等待时间喔！不过网络上大家的研究中， 大多说这个是 case by case，而且使用的软件影响很大！所以，在鸟哥的例子是启用 HT 帮助很大！您的案例就得要自行研究啰！&lt;/p></description></item><item><title>Docs: CPU 管理工具</title><link>https://desistdaydream.github.io/docs/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/X.Linux-%E7%AE%A1%E7%90%86/Linux-%E7%B3%BB%E7%BB%9F%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/CPU-%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/X.Linux-%E7%AE%A1%E7%90%86/Linux-%E7%B3%BB%E7%BB%9F%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/CPU-%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;/blockquote></description></item><item><title>Docs: Cryptography(密码学)</title><link>https://desistdaydream.github.io/docs/7.%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8/Cryptography%E5%AF%86%E7%A0%81%E5%AD%A6/Cryptography%E5%AF%86%E7%A0%81%E5%AD%A6/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/7.%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8/Cryptography%E5%AF%86%E7%A0%81%E5%AD%A6/Cryptography%E5%AF%86%E7%A0%81%E5%AD%A6/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Cryptography">Wiki,Cryptography&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;h1 id="密码学背景">密码学背景&lt;/h1>
&lt;p>在现代时代之前，密码学着眼于消息的机密性（即加密），即将消息从一种可理解的形式转换为一种难以理解的形式，然后又在另一端再次转换，从而使拦截器或窃听者在没有秘密知识（即所需的密钥）的情况下无法读取该消息。用于解密该消息）。加密试图确保保密的通信，如那些间谍，军事领导人和外交官。在最近的几十年中，该领域已经超出了对机密性的关注范围，包括消息完整性检查，发送者/接收者身份验证，数字签名，交互式证明和安全计算等。&lt;/p>
&lt;h2 id="经典密码学">经典密码学&lt;/h2>
&lt;h2 id="现代密码学">现代密码学&lt;/h2>
&lt;p>现在我们谈论的密码学，都是现代密码学的范畴&lt;/p>
&lt;p>Public-key cryptography(公开密钥加密、非对称密钥加密)，以及根据公开密钥加密方式而衍生出的其他认证授权等基础设施，是当代最常见，也是最常用的方式.&lt;/p>
&lt;h1 id="现代加密方式">现代加密方式&lt;/h1>
&lt;h2 id="symmetric-key-algorithm对称密钥算法">Symmetric Key Algorithm(对称密钥算法)&lt;/h2>
&lt;blockquote>
&lt;p>参考： &lt;a href="https://en.wikipedia.org/wiki/Symmetric-key_algorithm">Wiki-Symmetir Key Algorithm&lt;/a>&lt;/p>
&lt;/blockquote>
&lt;p>使用相同的密钥来加密明文和解密密文&lt;/p>
&lt;p>算法：&lt;/p>
&lt;ol>
&lt;li>DES：Data Encryption Standard 数据加密标准。已被破解&lt;/li>
&lt;li>3DES：3 倍的 DES。最常用&lt;/li>
&lt;li>AES：Advanced Encryption Standard 高级加密标准。最常用&lt;/li>
&lt;li>Blowfish&lt;/li>
&lt;li>Twofish&lt;/li>
&lt;li>IDEA：商业加密算法&lt;/li>
&lt;/ol>
&lt;h3 id="ska-特点">SKA 特点&lt;/h3>
&lt;p>特性：&lt;/p>
&lt;ul>
&lt;li>加密和解密使用同一个密钥，效率高。&lt;/li>
&lt;li>将原始数据分割成固定大小的块，逐个进行加密；&lt;/li>
&lt;/ul>
&lt;p>缺点：&lt;/p>
&lt;ul>
&lt;li>密钥过多；&lt;/li>
&lt;li>密钥分发(分发密钥过程无法保证),为了解决对称加密算法每个人需要保存密钥过多的问题，可以使用公钥加密&lt;/li>
&lt;li>数据来源无法确认&lt;/li>
&lt;/ul>
&lt;h2 id="public-key-cryptography公开密钥密码学">Public Key Cryptography(公开密钥密码学)&lt;/h2>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Public-key_cryptography">Wiki,PKC 英文&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Digital_signature">Wiki,数字签名&lt;/a>&lt;/li>
&lt;li>&lt;a href="http://www.ruanyifeng.com/blog/2013/06/rsa_algorithm_part_one.html">阮一峰&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.zhihu.com/question/25912483">知乎,RSA 的公钥和私钥到底那个才是用来加密和哪个用来解密&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://zh.wikipedia.org/wiki/%E5%85%AC%E5%BC%80%E5%AF%86%E9%92%A5%E5%8A%A0%E5%AF%86">Wiki, 公开密钥加密 中文&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>**Public Key Cryptography(公开密钥密码学) &lt;strong>也称为&lt;/strong> Asymmetric Key Algorithm(非对称密钥算法)，**它是计算机通信安全的基石，保证了加密数据不会被破解。1976 年以前，所有的加密方法都是同一种模式：&lt;/p>
&lt;ul>
&lt;li>甲方选择某种加密规则，对信息进行加密&lt;/li>
&lt;li>乙方使用同一种规则，对信息进行解密&lt;/li>
&lt;/ul>
&lt;p>由于加密和解密使用同样规则（简称&amp;quot;密钥&amp;quot;），这被称为 Symmetric-key algorithm(对称密钥算法)。这种加密模式有一个最大弱点：甲方必须把加密规则告诉乙方，否则无法解密。保存和传递密钥，就成了最头疼的问题。因为大多数情况下，其实两方之间的通信，只有一方是需要加密的，另一方只需要知道信息内容。&lt;/p>
&lt;p>1976 年，两位美国计算机学家 Whitfield Diffie 和 Martin Hellman，提出了一种崭新构思，可以在不直接传递密钥的情况下，完成解密。这被称为&amp;quot;Diffie-Hellman 密钥交换算法&amp;quot;。这个算法启发了其他科学家。人们认识到，加密和解密可以使用不同的规则，只要这两种规则之间存在某种对应关系即可，这样就避免了直接传递密钥。&lt;/p>
&lt;p>这种新的加密模式就被称为&amp;quot;非对称密钥算法&amp;quot;。&lt;/p>
&lt;blockquote>
&lt;p>（1）乙方生成两把密钥（公钥和私钥）。公钥是公开的，任何人都可以获得，私钥则是保密的。
（2）甲方获取乙方的公钥，然后用它对信息加密。
（3）乙方得到加密后的信息，用私钥解密。&lt;/p>
&lt;/blockquote>
&lt;p>如果公钥加密的信息只有私钥解得开，那么只要私钥不泄漏，通信就是安全的。&lt;/p>
&lt;p>1977 年，三位数学家 Rivest、Shamir 和 Adleman 设计了一种算法，可以实现非对称加密。这种算法用他们三个人的名字命名，叫做 RSA 算法。从那时直到现在，RSA 算法一直是最广为使用的&amp;quot;非对称加密算法&amp;quot;。毫不夸张地说，只要有计算机网络的地方，就有 RSA 算法。&lt;/p>
&lt;p>这种算法非常可靠，密钥越长，它就越难破解。根据已经披露的文献，目前被破解的最长 RSA 密钥是 768 个二进制位。也就是说，长度超过 768 位的密钥，还无法破解（至少没人公开宣布）。因此可以认为，1024 位的 RSA 密钥基本安全，2048 位的密钥极其安全。&lt;/p>
&lt;h3 id="pkc-特点">PKC 特点&lt;/h3>
&lt;ul>
&lt;li>这种加密方式，需要一对密钥。只有公钥可以加密，私钥不能用来加密数据。&lt;/li>
&lt;li>&lt;strong>Public key(公钥)&lt;/strong> # 公开给所有人。用来加密数据、验证签名。使用公钥把明文加密后所得的密文，只能使用对应的私钥才能解密并得到原本的密文。反之不行。&lt;/li>
&lt;li>&lt;strong>Secret key(私钥)&lt;/strong> # 自己留存，必须保证其私密性。用来解密数据、签名。使用私钥创建数字签名，只能使用公钥才能验证该数字签名的有效性。反之不行。
&lt;ul>
&lt;li>一般情况，密钥对是通过程序自动生成的。首先生成私钥后，公钥包含在私钥当中&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>Digital signature(数字签名)&lt;/strong>。签名提供的是真实性，而不是保密性。
&lt;ul>
&lt;li>所谓的数字签名，就像人们日常生活中在文件上签字一样，都是签名的一种。&lt;/li>
&lt;li>而所谓的验证签名，其实就像日常生活中，看看签名的人的笔记与签名是否一致，等等类似的行为&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>总结一下：既然是加密，那肯定是不希望别人知道发送给我的消息，所以只有我才能解密，所以可得出&lt;strong>公钥负责加密，私钥负责解密&lt;/strong>；同理，既然是签名，那肯定是不希望有人冒充我发消息，只有我才能发布这个签名，所以可得出&lt;strong>私钥负责签名，公钥负责验证&lt;/strong>。&lt;/p>
&lt;ul>
&lt;li>这种加密方式由于是单向加密、单向解密，所以如果双方都想要加密，则需要两对密钥，双方各自用对方的公钥加密信息发送给对方，然后双方再用自己的私钥解密阅读信息。&lt;/li>
&lt;/ul>
&lt;h3 id="应用场景">应用场景&lt;/h3>
&lt;ul>
&lt;li>如果 A 持有私钥，B 持有对应公钥。那么此时 B 用对方的公钥加密一个对称密钥并发送给 A，A 使用私钥解密，以获得 B 发送的对称密钥，这时再发送的数据可以使用对称加密。&lt;/li>
&lt;li>在互联网的 C/S 架构场景中。Server 公开公钥，Client 使用公钥加密信息发送给 Server(发送密码等敏感信息)，Server 使用私钥解密后响应时，使用私钥签名，以便 Client 可以用公钥验证 Server 的真实性(防止钓鱼网站)。&lt;/li>
&lt;li>如图所示，Alice 在一条消息的末尾签了名，消息内容是 &lt;code>Hello Bob!&lt;/code>，这段签署的内容一般是对消息内容进行 hash 计算后，使用 Alice 的私钥的出来的。鲍勃同时收到消息和签名。他使用 Alice 的公钥来验证消息的真实性，即，如果使用公钥计算得出来的消息与原始消息完全匹配，那就证明，这条消息确实是 Alice 发送的。&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/as985c/1616125981836-028fe2ce-77f2-4929-91cc-559c4ce9cda1.png" alt="">&lt;/p>
&lt;p>算法：&lt;/p>
&lt;ol>
&lt;li>RSA&lt;/li>
&lt;li>DSA&lt;/li>
&lt;li>ELGamal&lt;/li>
&lt;/ol>
&lt;p>缺点&lt;/p>
&lt;ol>
&lt;li>公钥加密可能出现的问题：当两者需要通信的时候，需要把公钥发送给对方，但是公钥是谁都可以获取的，那么在二者通信过程中，公钥就有可能被劫持，当公钥被劫持，劫持者把自己的公钥再发送给对方，那么双发再收到的信息，就是被劫持者篡改过的信息了。
&lt;ol>
&lt;li>&lt;a href="https://www.yuque.com/go/doc/33177961">&lt;strong>Public Key Certificate(公钥证书)&lt;/strong>&lt;/a> 可以解决以上问题&lt;/li>
&lt;/ol>
&lt;/li>
&lt;/ol>
&lt;h2 id="cryptographic-hash-function单向加密加密散列函数">Cryptographic hash function(单向加密、加密散列函数)&lt;/h2>
&lt;p>只能加密，不能解密，提取数据特征码，用来保证数据的完成性，实现数据的完整性校验&lt;/p>
&lt;p>通常用来做数字证书的数字签名，提取数据的特征码后进行加密并放到数据后端，用来校验证书的完整性，所以证书的内容是被认可的&lt;/p>
&lt;p>特点：定长输出、雪崩效应(原始数据的微小改变会导致计算结果的完全不同)&lt;/p>
&lt;p>算法：&lt;/p>
&lt;ol>
&lt;li>md5&lt;/li>
&lt;li>sha1&lt;/li>
&lt;li>sha256&lt;/li>
&lt;li>sha384&lt;/li>
&lt;li>sha512&amp;hellip;.等&lt;/li>
&lt;/ol>
&lt;p>MAC:Message Authentication Code(消息认证码)，单向加密的一种延伸应用，用于实现在网络通信中保证所传输的数据的完整性&lt;/p></description></item><item><title>Docs: CSI</title><link>https://desistdaydream.github.io/docs/10.%E4%BA%91%E5%8E%9F%E7%94%9F/2.3.Kubernetes-%E5%AE%B9%E5%99%A8%E7%BC%96%E6%8E%92%E7%B3%BB%E7%BB%9F/9.Kubernetes-%E5%AD%98%E5%82%A8/CSI/CSI/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/10.%E4%BA%91%E5%8E%9F%E7%94%9F/2.3.Kubernetes-%E5%AE%B9%E5%99%A8%E7%BC%96%E6%8E%92%E7%B3%BB%E7%BB%9F/9.Kubernetes-%E5%AD%98%E5%82%A8/CSI/CSI/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://mp.weixin.qq.com/s/A9xWKMmrxPyOEiCs_sicYQ">公众号-阿里云云原生，一文读懂容器存储接口 CSI&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>&lt;strong>导读：&lt;/strong> 在&lt;a href="https://mp.weixin.qq.com/s?__biz=MzUzNzYxNjAzMg==&amp;amp;mid=2247490043&amp;amp;idx=1&amp;amp;sn=c09ad4a9bc790f4b742abd8ca1301ffb&amp;amp;scene=21#wechat_redirect">《一文读懂 K8s 持久化存储流程》&lt;/a>一文我们重点介绍了 K8s 内部的存储流程，以及 PV、PVC、StorageClass、Kubelet 等之间的调用关系。接下来本文将将重点放在 CSI（Container Storage Interface）容器存储接口上，探究什么是 CSI 及其内部工作原理。&lt;/p>
&lt;h1 id="背景">背景&lt;/h1>
&lt;p>K8s 原生支持一些存储类型的 PV，如 iSCSI、NFS、CephFS 等等（详见链接），这些 in-tree 类型的存储代码放在 Kubernetes 代码仓库中。这里带来的问题是 K8s 代码与三方存储厂商的代码&lt;strong>强耦合&lt;/strong>：&lt;/p>
&lt;ul>
&lt;li>更改 in-tree 类型的存储代码，用户必须更新 K8s 组件，成本较高&lt;/li>
&lt;li>in-tree 存储代码中的 bug 会引发 K8s 组件不稳定&lt;/li>
&lt;li>K8s 社区需要负责维护及测试 in-tree 类型的存储功能&lt;/li>
&lt;li>in-tree 存储插件享有与 K8s 核心组件同等的特权，存在安全隐患&lt;/li>
&lt;li>三方存储开发者必须遵循 K8s 社区的规则开发 in-tree 类型存储代码&lt;/li>
&lt;/ul>
&lt;p>CSI 容器存储接口标准的出现解决了上述问题，将三方存储代码与 K8s 代码解耦，使得三方存储厂商研发人员只需实现 CSI 接口（无需关注容器平台是 K8s 还是 Swarm 等）。&lt;/p>
&lt;h1 id="csi-核心流程介绍">CSI 核心流程介绍&lt;/h1>
&lt;p>在详细介绍 CSI 组件及其接口之前，我们先对 K8s 中 CSI 存储流程进行一个介绍。&lt;a href="https://mp.weixin.qq.com/s?__biz=MzUzNzYxNjAzMg==&amp;amp;mid=2247490043&amp;amp;idx=1&amp;amp;sn=c09ad4a9bc790f4b742abd8ca1301ffb&amp;amp;scene=21#wechat_redirect">《一文读懂 K8s 持久化存储流程》&lt;/a>一文介绍了 K8s 中的 Pod 在挂载存储卷时需经历三个的阶段：Provision/Delete（创盘/删盘）、Attach/Detach（挂接/摘除）和 Mount/Unmount（挂载/卸载），下面以图文的方式讲解 K8s 在这三个阶段使用 CSI 的流程。&lt;/p>
&lt;h3 id="1-provisioning-volumes">1. Provisioning Volumes&lt;/h3>
&lt;p>&lt;img src="https://mmbiz.qpic.cn/mmbiz_jpg/yvBJb5IiafvnZrRu67Cf0RQ5ToaxdqVPrBeY2LVjZxMVenKvU5ZKicmSw8VHGuc0Oz4e5pf4p3Obx6I0IEpTRyPg/640?wx_fmt=jpeg" alt="">&lt;/p>
&lt;ol>
&lt;li>&lt;strong>集群管理员&lt;/strong>创建 StorageClass 资源，该 StorageClass 中包含 CSI 插件名称（provisioner:pangu.csi.alibabacloud.com）以及存储类必须的参数（parameters: type=cloud_ssd）。sc.yaml 文件如下：&lt;/li>
&lt;/ol>
&lt;p>&lt;img src="https://mmbiz.qpic.cn/mmbiz_png/yvBJb5IiafvnZrRu67Cf0RQ5ToaxdqVPrANJr4ZpicWLs1OCnFLhicFAU62B2k6A0ziarheficmo68kCzlCWQM9HHicQ/640?wx_fmt=png" alt="">&lt;/p>
&lt;ol start="2">
&lt;li>&lt;strong>用户&lt;/strong>创建 PersistentVolumeClaim 资源，PVC 指定存储大小及 StorageClass（如上）。pvc.yaml 文件如下：&lt;/li>
&lt;/ol>
&lt;p>&lt;img src="https://mmbiz.qpic.cn/mmbiz_png/yvBJb5IiafvnZrRu67Cf0RQ5ToaxdqVPrutp4BzfXLmBicwlbZKic2icwyfdrONeCXriaL69aHV1dRGsV45xs8FwrAA/640?wx_fmt=png" alt="">&lt;/p>
&lt;ol start="3">
&lt;li>
&lt;p>**卷控制器（PersistentVolumeController）**观察到集群中新创建的 PVC 没有与之匹配的 PV，且其使用的存储类型为 out-of-tree，于是为 PVC 打 annotation：volume.beta.kubernetes.io/storage-provisioner=[out-of-tree CSI 插件名称]（本例中即为 provisioner:pangu.csi.alibabacloud.com）。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>External Provisioner 组件&lt;/strong>观察到 PVC 的 annotation 中包含 &amp;ldquo;volume.beta.kubernetes.io/storage-provisioner&amp;rdquo; 且其 value 是自己，于是开始创盘流程。&lt;/p>
&lt;/li>
&lt;/ol>
&lt;ul>
&lt;li>
&lt;p>获取相关 StorageClass 资源并从中获取参数（本例中 parameters 为  type=cloud_ssd），用于后面 CSI 函数调用。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>通过 unix domain socket 调用&lt;strong>外部 CSI 插件&lt;/strong>的 &lt;strong>CreateVolume 函数&lt;/strong>。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;ol start="5">
&lt;li>
&lt;p>&lt;strong>外部 CSI 插件&lt;/strong>返回成功后表示盘创建完成，此时 &lt;strong>External Provisioner 组件&lt;/strong>会在集群创建一个 PersistentVolume 资源。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>卷控制器&lt;/strong>会将 PV 与 PVC 进行绑定。&lt;/p>
&lt;/li>
&lt;/ol>
&lt;p>&lt;img src="https://mmbiz.qpic.cn/mmbiz_png/yvBJb5IiafvnZrRu67Cf0RQ5ToaxdqVPrJDTQYxaVvDX4VPpF2qCeXNPAuG4lYLYsO91gG51s5mrrQtoAkFK0gQ/640?wx_fmt=png" alt="">&lt;/p>
&lt;h3 id="2-attaching-volumes">&lt;strong>2. Attaching Volumes&lt;/strong>&lt;/h3>
&lt;p>&lt;img src="https://mmbiz.qpic.cn/mmbiz_jpg/yvBJb5IiafvnZrRu67Cf0RQ5ToaxdqVPrDnVdvz0ibIzE0rqPvICXvWdHGosbgU2UCDGtImAVbCYNSQ6gEgoXfow/640?wx_fmt=jpeg" alt="">&lt;/p>
&lt;ol>
&lt;li>
&lt;p>**AD 控制器（AttachDetachController）&lt;strong>观察到使用 CSI 类型 PV 的 Pod 被调度到某一节点，此时 &lt;strong>AD 控制器&lt;/strong>会调用&lt;/strong>内部 in-tree CSI 插件（csiAttacher）**的 Attach 函数。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>**内部 in-tree CSI 插件（csiAttacher）**会创建一个 VolumeAttachment 对象到集群中。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>External Attacher&lt;/strong>观察到该 VolumeAttachment 对象，并调用&lt;strong>外部 CSI&lt;/strong> &lt;strong>插件&lt;/strong>的 &lt;strong>ControllerPublish 函数&lt;/strong>以将卷挂接到对应节点上。&lt;strong>外部 CSI 插件&lt;/strong>挂载成功后，&lt;strong>External Attacher&lt;/strong> 会更新相关 VolumeAttachment 对象的 .Status.Attached 为 true。&lt;/p>
&lt;/li>
&lt;/ol>
&lt;p>&lt;img src="https://mmbiz.qpic.cn/mmbiz_png/yvBJb5IiafvnZrRu67Cf0RQ5ToaxdqVPr3VQrSYwJScqw9NmzQWEb2EiavN62qibOtY8UqsHf7pJOgd0dGfH51J7A/640?wx_fmt=png" alt="">&lt;/p>
&lt;ol start="4">
&lt;li>**AD 控制器内部 in-tree CSI 插件（csiAttacher）**观察到 VolumeAttachment 对象的 .Status.Attached 设置为 true，于是更新 &lt;strong>AD 控制器&lt;/strong>内部状态（ActualStateOfWorld），该状态会显示在 Node 资源的 .Status.VolumesAttached 上。&lt;/li>
&lt;/ol>
&lt;p>&lt;img src="https://mmbiz.qpic.cn/mmbiz_png/yvBJb5IiafvnZrRu67Cf0RQ5ToaxdqVPrCEstrgCCXic5WRlHKcqo9tsay8vlFtC16iaw7ibNgztibNUBF7T0Wa5GjA/640?wx_fmt=png" alt="">&lt;/p>
&lt;h3 id="3-mounting-volumes">&lt;strong>3. Mounting Volumes&lt;/strong>&lt;/h3>
&lt;p>&lt;img src="https://mmbiz.qpic.cn/mmbiz_jpg/yvBJb5IiafvnZrRu67Cf0RQ5ToaxdqVPrLCMro57TU3k6Y4n5rJshOXjyuUDSxm07DFrkwFc0PrJnQWCIuNjJMQ/640?wx_fmt=jpeg" alt="">&lt;/p>
&lt;ol>
&lt;li>
&lt;p>**Volume Manager（Kubelet 组件）&lt;strong>观察到有新的使用 CSI 类型 PV 的 Pod 调度到本节点上，于是调用&lt;/strong>内部 in-tree CSI 插件（csiAttacher）**的 WaitForAttach 函数。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>**内部 in-tree CSI 插件（csiAttacher）**等待集群中 VolumeAttachment 对象状态 .Status.Attached 变为 true。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>in-tree CSI 插件（csiAttacher）&lt;strong>调用 MountDevice 函数，该函数内部通过 unix domain socket 调用&lt;/strong>外部 CSI 插件&lt;/strong>的 &lt;strong>NodeStageVolume 函数&lt;/strong>；之后&lt;strong>插件（csiAttacher）&lt;strong>调用&lt;/strong>内部 in-tree CSI 插件（csiMountMgr）&lt;strong>的 SetUp 函数，该函数内部会通过 unix domain socket 调用&lt;/strong>外部 CSI 插件&lt;/strong>的 &lt;strong>NodePublishVolume 函数&lt;/strong>。&lt;/p>
&lt;/li>
&lt;/ol>
&lt;h3 id="4-unmounting-volumes">&lt;strong>4. Unmounting Volumes&lt;/strong>&lt;/h3>
&lt;p>&lt;img src="https://mmbiz.qpic.cn/mmbiz_jpg/yvBJb5IiafvnZrRu67Cf0RQ5ToaxdqVPrQe0rqRuybVvWT35SIHKS5SicLNrkyy0NeEWssojJpqyKw2cScnET8cg/640?wx_fmt=jpeg" alt="">&lt;/p>
&lt;ol>
&lt;li>
&lt;p>&lt;strong>用户&lt;/strong>删除相关 Pod。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>Volume Manager（Kubelet 组件）&lt;strong>观察到包含 CSI 存储卷的 Pod 被删除，于是调用&lt;/strong>内部 in-tree CSI 插件（csiMountMgr）&lt;strong>的 TearDown 函数，该函数内部会通过 unix domain socket 调用&lt;/strong>外部 CSI 插件&lt;/strong>的 &lt;strong>NodeUnpublishVolume 函数&lt;/strong>。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>Volume Manager（Kubelet 组件）&lt;strong>调用&lt;/strong>内部 in-tree CSI 插件（csiAttacher）&lt;strong>的 UnmountDevice 函数，该函数内部会通过 unix domain socket 调用&lt;/strong>外部 CSI 插件&lt;/strong>的 &lt;strong>NodeUnpublishVolume 函数&lt;/strong>。&lt;/p>
&lt;/li>
&lt;/ol>
&lt;h3 id="5-detaching-volumes">&lt;strong>5. Detaching Volumes&lt;/strong>&lt;/h3>
&lt;p>&lt;img src="https://mmbiz.qpic.cn/mmbiz_jpg/yvBJb5IiafvnZrRu67Cf0RQ5ToaxdqVPrXZxdCa6icByCacuAZetQqxVfVRNFx3EIt4g8DvFrNPmvyIjSHGSKRzg/640?wx_fmt=jpeg" alt="">&lt;/p>
&lt;ol>
&lt;li>
&lt;p>&lt;strong>AD 控制器&lt;/strong>观察到包含 CSI 存储卷的 Pod 被删除，此时该控制器会调用**内部 in-tree CSI 插件（csiAttacher）**的 Detach 函数。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>csiAttache****r&lt;/strong> 会删除集群中相关 VolumeAttachment 对象（但由于存在 finalizer，va 对象不会立即删除）。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>External Attacher&lt;/strong> 观察到集群中 VolumeAttachment 对象的 DeletionTimestamp 非空，于是调用&lt;strong>外部 CSI 插件&lt;/strong>的 &lt;strong>ControllerUnpublish 函数&lt;/strong>以将卷从对应节点上摘除。&lt;strong>外部 CSI 插件&lt;/strong>摘除成功后，&lt;strong>External Attacher&lt;/strong> 会移除相关 VolumeAttachment 对象的 finalizer 字段，此时 VolumeAttachment 对象被彻底删除。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>AD 控制器&lt;/strong>中**内部 in-tree CSI 插件（csiAttacher）**观察到 VolumeAttachment 对象已删除，于是更新 &lt;strong>AD 控制器&lt;/strong>中的内部状态；同时 &lt;strong>AD 控制器&lt;/strong>更新 Node 资源，此时 Node 资源的 .Status.VolumesAttached 上已没有相关挂接信息。&lt;/p>
&lt;/li>
&lt;/ol>
&lt;h3 id="6-deleting-volumes">&lt;strong>6. Deleting Volumes&lt;/strong>&lt;/h3>
&lt;p>&lt;img src="https://mmbiz.qpic.cn/mmbiz_jpg/yvBJb5IiafvnZrRu67Cf0RQ5ToaxdqVPrUnvXdic5KwU7cRfGTUkOG17ol0Dnicj177dzzzRLiam3XLKZUvPQwcicjQ/640?wx_fmt=jpeg" alt="">&lt;/p>
&lt;ol>
&lt;li>
&lt;p>&lt;strong>用户&lt;/strong>删除相关 PVC。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>External Provisioner 组件&lt;/strong>观察到 PVC 删除事件，根据 PVC 的回收策略（Reclaim）执行不同操作：&lt;/p>
&lt;/li>
&lt;/ol>
&lt;ul>
&lt;li>
&lt;p>Delete：调用&lt;strong>外部 CSI 插件&lt;/strong>的 &lt;strong>DeleteVolume 函数&lt;/strong>以删除卷；一旦卷成功删除，&lt;strong>Provisioner&lt;/strong> 会删除集群中对应 PV 对象。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Retain：&lt;strong>Provisione&lt;/strong> 不执行卷删除操作。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h1 id="csi-sidecar-组件介绍">CSI Sidecar 组件介绍&lt;/h1>
&lt;p>为使 K8s 适配 CSI 标准，社区将与 K8s 相关的存储流程逻辑放在了 CSI Sidecar 组件中。&lt;/p>
&lt;h2 id="1-node-driver-registrar">1. Node Driver Registrar&lt;/h2>
&lt;h3 id="1功能">&lt;strong>1）功能&lt;/strong>&lt;/h3>
&lt;p>&lt;strong>Node-Driver-Registrar 组件&lt;/strong>会将&lt;strong>外部 CSI 插件&lt;/strong>注册到 &lt;strong>Kubelet&lt;/strong>，从而使 &lt;strong>Kubelet&lt;/strong> 通过特定的 Unix Domain Socket 来调用&lt;strong>外部 CSI 插件函数&lt;/strong>（Kubelet 会调用外部 CSI 插件的 NodeGetInfo、NodeStageVolume、NodePublishVolume、NodeGetVolumeStats 等函数）。&lt;/p>
&lt;h3 id="2原理">&lt;strong>2）原理&lt;/strong>&lt;/h3>
&lt;p>&lt;strong>Node-Driver-Registrar 组件&lt;/strong>通过Kubelet 外部插件注册机制实现注册，注册成功后：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>&lt;strong>Kubelet&lt;/strong> 为本节点 Node 资源打 annotation：&lt;strong>Kubelet&lt;/strong> 调用&lt;strong>外部 CSI 插件&lt;/strong>的 &lt;strong>NodeGetInfo 函数&lt;/strong>，其返回值 [nodeID]、[driverName] 将作为值用于 &amp;ldquo;csi.volume.kubernetes.io/nodeid&amp;rdquo; 键。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>Kubelet&lt;/strong> 更新 Node Label：将 &lt;strong>NodeGetInfo 函数&lt;/strong>返回的 [AccessibleTopology] 值用于节点的 Label。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>Kubelet&lt;/strong> 更新 Node Status：将 &lt;strong>NodeGetInfo 函数&lt;/strong>返回的 maxAttachLimit（节点最大可挂载卷数量）更新到 Node 资源的 Status.Allocatable：attachable-volumes-csi-[driverName]=[maxAttachLimit]。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://mmbiz.qpic.cn/mmbiz_png/yvBJb5IiafvnZrRu67Cf0RQ5ToaxdqVPrBmrHGPKfvIpb11zVlVHicPqfFjRCCbUNSgNsufaCca3U0mgWVp3qQGg/640?wx_fmt=png" alt="">&lt;/p>
&lt;ul>
&lt;li>&lt;strong>Kubelet&lt;/strong> 更新 CSINode 资源（没有则创建）：将 [driverName]、[nodeID]、[maxAttachLimit]、[AccessibleTopology] 更新到 Spec 中（拓扑仅保留 Key 值）。&lt;/li>
&lt;/ul>
&lt;h2 id="2-external-provisioner">2. External Provisioner&lt;/h2>
&lt;h3 id="1功能-1">&lt;strong>1）功能&lt;/strong>&lt;/h3>
&lt;p>创建/删除实际的存储卷，以及代表存储卷的 PV 资源。&lt;/p>
&lt;h3 id="2原理-1">&lt;strong>2）原理&lt;/strong>&lt;/h3>
&lt;p>&lt;strong>External-Provisioner&lt;/strong> 在启动时需指定参数 -- provisioner，该参数指定 Provisioner 名称，与 StorageClass 中的 provisioner 字段对应。&lt;/p>
&lt;p>&lt;strong>External-Provisioner&lt;/strong> 启动后会 watch 集群中的 PVC 和 PV 资源。&lt;/p>
&lt;p>对于集群中的 PVC 资源：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>判断 PVC 是否需要动态创建存储卷，标准如下：&lt;/p>
&lt;/li>
&lt;li>
&lt;p>PVC 的 annotation 中是否包含 &amp;ldquo;volume.beta.kubernetes.io/storage-provisioner&amp;rdquo; 键（由卷控制器创建），并且其值是否与 Provisioner 名称相等。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>PVC 对应 StorageClass 的 VolumeBindingMode 字段若为 WaitForFirstConsumer，则 PVC 的 annotation 中必须包含 &amp;ldquo;volume.kubernetes.io/selected-node&amp;rdquo; 键（详见调度器如何处理 WaitForFirstConsumer），且其值不为空；若为 Immediate 则表示需要 Provisioner 立即提供动态存储卷。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>通过特定的 Unix Domain Socket 调用&lt;strong>外部 CSI 插件&lt;/strong>的 &lt;strong>CreateVolume 函数&lt;/strong>。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>创建 PV 资源，PV 名称为 [Provisioner 指定的 PV 前缀] - [PVC uuid]。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>对于集群中的 PV 资源：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>判断 PV 是否需要删除，标准如下：&lt;/p>
&lt;/li>
&lt;li>
&lt;p>判断其 .Status.Phase 是否为 Release。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>判断其 .Spec.PersistentVolumeReclaimPolicy 是否为 Delete。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>判断其是否包含 annotation（pv.kubernetes.io/provisioned-by），且其值是否为自己。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>通过特定的 Unix Domain Socket 调用&lt;strong>外部 CSI 插件&lt;/strong>的 &lt;strong>DeleteVolume 接口&lt;/strong>。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>删除集群中的 PV 资源。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h2 id="3-external-attacher">3. External Attacher&lt;/h2>
&lt;h3 id="1功能-2">&lt;strong>1）功能&lt;/strong>&lt;/h3>
&lt;p>挂接/摘除存储卷。&lt;/p>
&lt;h3 id="2原理-2">&lt;strong>2）原理&lt;/strong>&lt;/h3>
&lt;p>&lt;strong>External-Attacher&lt;/strong>内部会时刻 watch 集群中的 VolumeAttachment 资源和 PersistentVolume 资源。&lt;/p>
&lt;p>对于 VolumeAttachment 资源：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>从 VolumeAttachment 资源中获得 PV 的所有信息，如 volume ID、node ID、挂载 Secret 等。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>判断 VolumeAttachment 的 DeletionTimestamp 字段是否为空来判断其为卷挂接或卷摘除：若为卷挂接则通过特定的 Unix Domain Socket 调用&lt;strong>外部 CSI 插件&lt;/strong>的 &lt;strong>ControllerPublishVolume 接口&lt;/strong>；若为卷摘除则通过特定的 Unix Domain Socket 调用&lt;strong>外部 CSI 插件&lt;/strong>的 &lt;strong>ControllerUnpublishVolume 接口&lt;/strong>。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>对于 PersistentVolume 资源：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>在挂接时为相关 PV 打上 Finalizer：external-attacher/[driver 名称]。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>当 PV 处于删除状态时（DeletionTimestamp 非空），删除 Finalizer：external-attacher/[driver 名称]。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h2 id="4-external-resizer">4. External Resizer&lt;/h2>
&lt;h3 id="1功能-3">&lt;strong>1）功能&lt;/strong>&lt;/h3>
&lt;p>扩容存储卷。&lt;/p>
&lt;h3 id="2原理-3">&lt;strong>2）原理&lt;/strong>&lt;/h3>
&lt;p>&lt;strong>External-Resizer&lt;/strong> 内部会 watch 集群中的 PersistentVolumeClaim 资源。&lt;/p>
&lt;p>对于 PersistentVolumeClaim 资源：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>判断 PersistentVolumeClaim 资源是否需要扩容：PVC 状态需要是 Bound 且 .Status.Capacity 与 .Spec.Resources.Requests 不等。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>更新 PVC 的 .Status.Conditions，表明此时处于 Resizing 状态。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>通过特定的 Unix Domain Socket 调用&lt;strong>外部 CSI 插件&lt;/strong>的 &lt;strong>ControllerExpandVolume 接口&lt;/strong>。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>更新 PV 的 .Spec.Capacity。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>若 CSI 支持文件系统在线扩容，ControllerExpandVolume 接口返回值中 NodeExpansionRequired 字段为 true，&lt;strong>External-Resizer&lt;/strong> 更新 PVC 的 .Status.Conditions 为 FileSystemResizePending 状态；若不支持则扩容成功，&lt;strong>External-Resizer&lt;/strong> 更新 PVC 的 .Status.Conditions 为空，且更新 PVC 的 .Status.Capacity。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>Volume Manager（Kubelet 组件）&lt;strong>观察到存储卷需在线扩容，于是通过特定的 Unix Domain Socket 调用&lt;/strong>外部 CSI 插件&lt;/strong>的 &lt;strong>NodeExpandVolume 接口&lt;/strong>实现文件系统扩容。&lt;/p>
&lt;h2 id="5-livenessprobe">5. livenessprobe&lt;/h2>
&lt;h3 id="1功能-4">&lt;strong>1）功能&lt;/strong>&lt;/h3>
&lt;p>检查 CSI 插件是否正常。&lt;/p>
&lt;h3 id="2原理-4">&lt;strong>2）原理&lt;/strong>&lt;/h3>
&lt;p>通过对外暴露一个 / healthz HTTP 端口以服务 kubelet 的探针探测器，内部是通过特定的 Unix Domain Socket 调用&lt;strong>外部 CSI 插件&lt;/strong>的 &lt;strong>Probe 接口&lt;/strong>。&lt;/p>
&lt;h1 id="csi-接口介绍">CSI 接口介绍&lt;/h1>
&lt;p>三方存储厂商需实现 CSI 插件的三大接口：&lt;strong>IdentityServer、ControllerServer、NodeServer&lt;/strong>。&lt;/p>
&lt;h2 id="1-identityserver">1. IdentityServer&lt;/h2>
&lt;p>IdentityServer 主要用于认证 CSI 插件的身份信息。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-typescript" data-lang="typescript">&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">type&lt;/span> &lt;span style="color:#a6e22e">IdentityServer&lt;/span> &lt;span style="color:#66d9ef">interface&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">GetPluginInfo&lt;/span>(&lt;span style="color:#a6e22e">context&lt;/span>.&lt;span style="color:#a6e22e">Context&lt;/span>, &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">GetPluginInfoRequest&lt;/span>) (&lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">GetPluginInfoResponse&lt;/span>, &lt;span style="color:#a6e22e">error&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">GetPluginCapabilities&lt;/span>(&lt;span style="color:#a6e22e">context&lt;/span>.&lt;span style="color:#a6e22e">Context&lt;/span>, &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">GetPluginCapabilitiesRequest&lt;/span>) (&lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">GetPluginCapabilitiesResponse&lt;/span>, &lt;span style="color:#a6e22e">error&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">Probe&lt;/span>(&lt;span style="color:#a6e22e">context&lt;/span>.&lt;span style="color:#a6e22e">Context&lt;/span>, &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">ProbeRequest&lt;/span>) (&lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">ProbeResponse&lt;/span>, &lt;span style="color:#a6e22e">error&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="2-controllerserver">2. ControllerServer&lt;/h2>
&lt;p>ControllerServer 主要负责存储卷及快照的创建/删除以及挂接/摘除操作。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-typescript" data-lang="typescript">&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">type&lt;/span> &lt;span style="color:#a6e22e">ControllerServer&lt;/span> &lt;span style="color:#66d9ef">interface&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">CreateVolume&lt;/span>(&lt;span style="color:#a6e22e">context&lt;/span>.&lt;span style="color:#a6e22e">Context&lt;/span>, &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">CreateVolumeRequest&lt;/span>) (&lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">CreateVolumeResponse&lt;/span>, &lt;span style="color:#a6e22e">error&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">DeleteVolume&lt;/span>(&lt;span style="color:#a6e22e">context&lt;/span>.&lt;span style="color:#a6e22e">Context&lt;/span>, &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">DeleteVolumeRequest&lt;/span>) (&lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">DeleteVolumeResponse&lt;/span>, &lt;span style="color:#a6e22e">error&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">ControllerPublishVolume&lt;/span>(&lt;span style="color:#a6e22e">context&lt;/span>.&lt;span style="color:#a6e22e">Context&lt;/span>, &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">ControllerPublishVolumeRequest&lt;/span>) (&lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">ControllerPublishVolumeResponse&lt;/span>, &lt;span style="color:#a6e22e">error&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">ControllerUnpublishVolume&lt;/span>(&lt;span style="color:#a6e22e">context&lt;/span>.&lt;span style="color:#a6e22e">Context&lt;/span>, &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">ControllerUnpublishVolumeRequest&lt;/span>) (&lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">ControllerUnpublishVolumeResponse&lt;/span>, &lt;span style="color:#a6e22e">error&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">ValidateVolumeCapabilities&lt;/span>(&lt;span style="color:#a6e22e">context&lt;/span>.&lt;span style="color:#a6e22e">Context&lt;/span>, &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">ValidateVolumeCapabilitiesRequest&lt;/span>) (&lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">ValidateVolumeCapabilitiesResponse&lt;/span>, &lt;span style="color:#a6e22e">error&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">ListVolumes&lt;/span>(&lt;span style="color:#a6e22e">context&lt;/span>.&lt;span style="color:#a6e22e">Context&lt;/span>, &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">ListVolumesRequest&lt;/span>) (&lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">ListVolumesResponse&lt;/span>, &lt;span style="color:#a6e22e">error&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">GetCapacity&lt;/span>(&lt;span style="color:#a6e22e">context&lt;/span>.&lt;span style="color:#a6e22e">Context&lt;/span>, &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">GetCapacityRequest&lt;/span>) (&lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">GetCapacityResponse&lt;/span>, &lt;span style="color:#a6e22e">error&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">ControllerGetCapabilities&lt;/span>(&lt;span style="color:#a6e22e">context&lt;/span>.&lt;span style="color:#a6e22e">Context&lt;/span>, &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">ControllerGetCapabilitiesRequest&lt;/span>) (&lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">ControllerGetCapabilitiesResponse&lt;/span>, &lt;span style="color:#a6e22e">error&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">CreateSnapshot&lt;/span>(&lt;span style="color:#a6e22e">context&lt;/span>.&lt;span style="color:#a6e22e">Context&lt;/span>, &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">CreateSnapshotRequest&lt;/span>) (&lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">CreateSnapshotResponse&lt;/span>, &lt;span style="color:#a6e22e">error&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">DeleteSnapshot&lt;/span>(&lt;span style="color:#a6e22e">context&lt;/span>.&lt;span style="color:#a6e22e">Context&lt;/span>, &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">DeleteSnapshotRequest&lt;/span>) (&lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">DeleteSnapshotResponse&lt;/span>, &lt;span style="color:#a6e22e">error&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">ListSnapshots&lt;/span>(&lt;span style="color:#a6e22e">context&lt;/span>.&lt;span style="color:#a6e22e">Context&lt;/span>, &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">ListSnapshotsRequest&lt;/span>) (&lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">ListSnapshotsResponse&lt;/span>, &lt;span style="color:#a6e22e">error&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">ControllerExpandVolume&lt;/span>(&lt;span style="color:#a6e22e">context&lt;/span>.&lt;span style="color:#a6e22e">Context&lt;/span>, &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">ControllerExpandVolumeRequest&lt;/span>) (&lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">ControllerExpandVolumeResponse&lt;/span>, &lt;span style="color:#a6e22e">error&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="3-nodeserver">3. NodeServer&lt;/h2>
&lt;p>NodeServer 主要负责存储卷挂载/卸载操作。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-typescript" data-lang="typescript">&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">type&lt;/span> &lt;span style="color:#a6e22e">NodeServer&lt;/span> &lt;span style="color:#66d9ef">interface&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">NodeStageVolume&lt;/span>(&lt;span style="color:#a6e22e">context&lt;/span>.&lt;span style="color:#a6e22e">Context&lt;/span>, &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">NodeStageVolumeRequest&lt;/span>) (&lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">NodeStageVolumeResponse&lt;/span>, &lt;span style="color:#a6e22e">error&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">NodeUnstageVolume&lt;/span>(&lt;span style="color:#a6e22e">context&lt;/span>.&lt;span style="color:#a6e22e">Context&lt;/span>, &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">NodeUnstageVolumeRequest&lt;/span>) (&lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">NodeUnstageVolumeResponse&lt;/span>, &lt;span style="color:#a6e22e">error&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">NodePublishVolume&lt;/span>(&lt;span style="color:#a6e22e">context&lt;/span>.&lt;span style="color:#a6e22e">Context&lt;/span>, &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">NodePublishVolumeRequest&lt;/span>) (&lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">NodePublishVolumeResponse&lt;/span>, &lt;span style="color:#a6e22e">error&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">NodeUnpublishVolume&lt;/span>(&lt;span style="color:#a6e22e">context&lt;/span>.&lt;span style="color:#a6e22e">Context&lt;/span>, &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">NodeUnpublishVolumeRequest&lt;/span>) (&lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">NodeUnpublishVolumeResponse&lt;/span>, &lt;span style="color:#a6e22e">error&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">NodeGetVolumeStats&lt;/span>(&lt;span style="color:#a6e22e">context&lt;/span>.&lt;span style="color:#a6e22e">Context&lt;/span>, &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">NodeGetVolumeStatsRequest&lt;/span>) (&lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">NodeGetVolumeStatsResponse&lt;/span>, &lt;span style="color:#a6e22e">error&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">NodeExpandVolume&lt;/span>(&lt;span style="color:#a6e22e">context&lt;/span>.&lt;span style="color:#a6e22e">Context&lt;/span>, &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">NodeExpandVolumeRequest&lt;/span>) (&lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">NodeExpandVolumeResponse&lt;/span>, &lt;span style="color:#a6e22e">error&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">NodeGetCapabilities&lt;/span>(&lt;span style="color:#a6e22e">context&lt;/span>.&lt;span style="color:#a6e22e">Context&lt;/span>, &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">NodeGetCapabilitiesRequest&lt;/span>) (&lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">NodeGetCapabilitiesResponse&lt;/span>, &lt;span style="color:#a6e22e">error&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">NodeGetInfo&lt;/span>(&lt;span style="color:#a6e22e">context&lt;/span>.&lt;span style="color:#a6e22e">Context&lt;/span>, &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">NodeGetInfoRequest&lt;/span>) (&lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">NodeGetInfoResponse&lt;/span>, &lt;span style="color:#a6e22e">error&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h1 id="k8s-csi-api-对象">K8s CSI API 对象&lt;/h1>
&lt;p>K8s 为支持 CSI 标准，包含如下 API 对象：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>CSINode&lt;/p>
&lt;/li>
&lt;li>
&lt;p>CSIDriver&lt;/p>
&lt;/li>
&lt;li>
&lt;p>VolumeAttachment&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h2 id="1-csinode">1. CSINode&lt;/h2>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-properties" data-lang="properties">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">apiVersion&lt;/span>&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#e6db74">storage.k8s.io/v1beta1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">kind&lt;/span>&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#e6db74">CSINode&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">metadata&lt;/span>&lt;span style="color:#f92672">:&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">name&lt;/span>&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#e6db74">node-10.212.101.210&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">spec&lt;/span>&lt;span style="color:#f92672">:&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">drivers&lt;/span>&lt;span style="color:#f92672">:&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">-&lt;/span> &lt;span style="color:#e6db74">name: yodaplugin.csi.alibabacloud.com&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">nodeID&lt;/span>&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#e6db74">node-10.212.101.210&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">topologyKeys&lt;/span>&lt;span style="color:#f92672">:&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">-&lt;/span> &lt;span style="color:#e6db74">kubernetes.io/hostname&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">-&lt;/span> &lt;span style="color:#e6db74">name: pangu.csi.alibabacloud.com&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">nodeID&lt;/span>&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#e6db74">a5441fd9013042ee8104a674e4a9666a&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">topologyKeys&lt;/span>&lt;span style="color:#f92672">:&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">-&lt;/span> &lt;span style="color:#e6db74">topology.pangu.csi.alibabacloud.com/zone&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>作用：&lt;/p>
&lt;ol>
&lt;li>
&lt;p>判断&lt;strong>外部 CSI 插件&lt;/strong>是否注册成功。在 Node Driver Registrar 组件向 Kubelet 注册完毕后，Kubelet 会创建该资源，故不需要显式创建 CSINode 资源。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>将 Kubernetes 中 Node 资源名称与三方存储系统中节点名称（nodeID）一一对应。此处 &lt;strong>Kubelet&lt;/strong> 会调用&lt;strong>外部 CSI 插件&lt;/strong> NodeServer 的 &lt;strong>GetNodeInfo 函数&lt;/strong>获取 nodeID。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>显示卷拓扑信息。CSINode 中 topologyKeys 用来表示存储节点的拓扑信息，卷拓扑信息会使得 &lt;strong>Scheduler&lt;/strong> 在 Pod 调度时选择合适的存储节点。&lt;/p>
&lt;/li>
&lt;/ol>
&lt;h2 id="2-csidriver">2. CSIDriver&lt;/h2>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-properties" data-lang="properties">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">apiVersion&lt;/span>&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#e6db74">storage.k8s.io/v1beta1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">kind&lt;/span>&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#e6db74">CSIDriver&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">metadata&lt;/span>&lt;span style="color:#f92672">:&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">name&lt;/span>&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#e6db74">pangu.csi.alibabacloud.com&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">spec&lt;/span>&lt;span style="color:#f92672">:&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">attachRequired&lt;/span>&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#e6db74">true&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">podInfoOnMount&lt;/span>&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#e6db74">true&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">volumeLifecycleModes&lt;/span>&lt;span style="color:#f92672">:&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">-&lt;/span> &lt;span style="color:#e6db74">Persistent&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>作用：&lt;/p>
&lt;ol>
&lt;li>
&lt;p>简化&lt;strong>外部 CSI 插件&lt;/strong>的发现。由集群管理员创建，通过 kubectl get csidriver 即可得知环境上有哪些 CSI 插件。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>自定 义Kubernetes 行为，如一些外部 CSI 插件不需要执行卷挂接（VolumeAttach）操作，则可以设置 .spec.attachRequired 为 false。&lt;/p>
&lt;/li>
&lt;/ol>
&lt;h2 id="3-volumeattachment">3. VolumeAttachment&lt;/h2>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-properties" data-lang="properties">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">apiVersion&lt;/span>&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#e6db74">storage.k8s.io/v1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">kind&lt;/span>&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#e6db74">VolumeAttachment&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">metadata&lt;/span>&lt;span style="color:#f92672">:&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">annotations&lt;/span>&lt;span style="color:#f92672">:&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">csi.alpha.kubernetes.io/node-id&lt;/span>&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#e6db74">21481ae252a2457f9abcb86a3d02ba05&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">finalizers&lt;/span>&lt;span style="color:#f92672">:&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">-&lt;/span> &lt;span style="color:#e6db74">external-attacher/pangu-csi-alibabacloud-com&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">name&lt;/span>&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#e6db74">csi-0996e5e9459e1ccc1b3a7aba07df4ef7301c8e283d99eabc1b69626b119ce750&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">spec&lt;/span>&lt;span style="color:#f92672">:&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">attacher&lt;/span>&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#e6db74">pangu.csi.alibabacloud.com&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">nodeName&lt;/span>&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#e6db74">node-10.212.101.241&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">source&lt;/span>&lt;span style="color:#f92672">:&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">persistentVolumeName&lt;/span>&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#e6db74">pangu-39aa24e7-8877-11eb-b02f-021234350de1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">status&lt;/span>&lt;span style="color:#f92672">:&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">attached&lt;/span>&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#e6db74">true&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>作用：VolumeAttachment 记录了存储卷的挂接/摘除信息以及节点信息。&lt;/p>
&lt;h1 id="支持特性">支持特性&lt;/h1>
&lt;h2 id="1-拓扑支持">1. 拓扑支持&lt;/h2>
&lt;p>在 StorageClass 中有 AllowedTopologies 字段：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-properties" data-lang="properties">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">apiVersion&lt;/span>&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#e6db74">storage.k8s.io/v1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">kind&lt;/span>&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#e6db74">StorageClass&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">metadata&lt;/span>&lt;span style="color:#f92672">:&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">name&lt;/span>&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#e6db74">csi-pangu&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">provisioner&lt;/span>&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#e6db74">pangu.csi.alibabacloud.com&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">parameters&lt;/span>&lt;span style="color:#f92672">:&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">type&lt;/span>&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#e6db74">cloud_ssd&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">volumeBindingMode&lt;/span>&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#e6db74">Immediate&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">allowedTopologies&lt;/span>&lt;span style="color:#f92672">:&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">-&lt;/span> &lt;span style="color:#e6db74">matchLabelExpressions:&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">-&lt;/span> &lt;span style="color:#e6db74">key: topology.pangu.csi.alibabacloud.com/zone&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">values&lt;/span>&lt;span style="color:#f92672">:&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">-&lt;/span> &lt;span style="color:#e6db74">zone-1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">-&lt;/span> &lt;span style="color:#e6db74">zone-2&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;strong>外部 CSI 插件&lt;/strong>部署后会为每个节点打标，打标内容 &lt;strong>NodeGetInfo 函数&lt;/strong>返回的 [AccessibleTopology] 值（详见 Node Driver Registrar 部分）。&lt;/p>
&lt;p>&lt;strong>External Provisioner&lt;/strong> 在调用 CSI 插件的 CreateVolume 接口之前，会在请求参数设置 AccessibilityRequirements：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>对于 WaitForFirstConsumer&lt;/p>
&lt;/li>
&lt;li>
&lt;p>当 PVC 的 anno 中包含 &amp;ldquo;volume.kubernetes.io/selected-node&amp;rdquo; 且不为空，则先获取对应节点 CSINode 的 TopologyKeys，然后根据该 TopologyKeys 键从 Node 资源的 Label 获取 Values 值，最后拿该 Values 值与 StorageClass 的 AllowedTopologies 比对，判断其是否包含于其中；若不包含则报错。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>对于 Immediately&lt;/p>
&lt;/li>
&lt;li>
&lt;p>将 StorageClass 的 AllowedTopologies 的值填进来，若 StorageClass 没有设置 AllowedTopologies 则将所有包含 TopologyKeys 键的节点 Value 添进来。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h2 id="scheduler-如何处理使用存储卷调度">Scheduler 如何处理使用存储卷调度&lt;/h2>
&lt;blockquote>
&lt;p>基于社区 1.18 版本调度器&lt;/p>
&lt;/blockquote>
&lt;p>调度器的调度过程主要有如下三步：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>&lt;strong>预选（Filter）&lt;/strong>：筛选满足Pod调度要求的节点列表。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>优选（Score）&lt;/strong>：通过内部的优选算法为节点打分，获得最高分数的节点即为选中的节点。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>绑定（Bind）&lt;/strong>：调度器将调度结果通知给 kube-apiserver，更新 Pod 的 .spec.nodeName 字段。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>调度器预选阶段：处理 Pod 的 PVC/PV 绑定关系以及动态供应 PV（Dynamic Provisioning），同时使调度器调度时考虑 Pod 所使用 PV 的节点亲和性。详细调度过程如下：&lt;/p>
&lt;ol>
&lt;li>
&lt;p>Pod 不包含 PVC 直接跳过。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>FindPodVolumes&lt;/p>
&lt;/li>
&lt;/ol>
&lt;ul>
&lt;li>
&lt;p>获取 Pod 的 boundClaims、claimsToBind 以及 unboundClaimsImmediate。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>boundClaims：已 Bound 的 PVC&lt;/p>
&lt;/li>
&lt;li>
&lt;p>claimsToBind：PVC 对应 StorageClass 的 VolumeBindingMode 为 VolumeBindingWaitForFirstConsumer&lt;/p>
&lt;/li>
&lt;li>
&lt;p>unboundClaimsImmediate：PVC 对应 StorageClass 的 VolumeBindingMode 为 VolumeBindingImmediate&lt;/p>
&lt;/li>
&lt;li>
&lt;p>若 len(unboundClaimsImmediate) 不为空，表示这种 PVC 需要立即绑定 PV（即存 PVC 创建后，立刻动态创建 PV 并将其绑定到 PVC，该过程不走调度），若 PVC 处于 unbound 阶段则报错。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>若 len(boundClaims) 不为空，则检查 PVC 对应 PV 的节点亲和性与当前节点的 Label 是否冲突，若冲突则报错（可检查 Immediate 类型的 PV 拓扑）。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>若 len(claimsToBind) 不为空&lt;/p>
&lt;/li>
&lt;li>
&lt;p>先检查环境中已有的 PV 能否与该 PVC 匹配（findMatchingVolumes），将能够匹配 PVC 的 PV 记录在调度器的 cache 中。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>未匹配到 PV 的 PVC 走动态调度流程，动态调度主要通过 StorageClass 的 AllowedTopologies 字段判断当前调度节点是否满足拓扑要求（针对 WaitForFirstConsumer 类型的 PVC）。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>调度器优选阶段不讨论。&lt;/p>
&lt;p>调度器 Assume 阶段&lt;/p>
&lt;blockquote>
&lt;p>调度器会先 Assume PV/PVC，再 Assume Pod。&lt;/p>
&lt;/blockquote>
&lt;ol>
&lt;li>
&lt;p>将当前待调度的 Pod 进行深拷贝。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>AssumePodVolumes（针对 WaitForFirstConsumer 类型的 PVC）&lt;/p>
&lt;/li>
&lt;/ol>
&lt;ul>
&lt;li>
&lt;p>更改调度器 cache 中已经 Match 的 PV 信息：设置 annotation：pv.kubernetes.io/bound-by-controller=&amp;ldquo;yes&amp;rdquo;。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>更改调度器 cache 中未匹配到 PV 的 PVC，设置 annotation：volume.kubernetes.io/selected-node=【所选节点】。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;ol start="3">
&lt;li>Assume Pod 完毕&lt;/li>
&lt;/ol>
&lt;ul>
&lt;li>更改调度器 cache 中 Pod 的 .Spec.NodeName 为【所选节点】。&lt;/li>
&lt;/ul>
&lt;p>调度器 Bind 阶段&lt;/p>
&lt;p>BindPodVolumes：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>调用 Kubernetes 的 API 更新集群中 PV/PVC 资源，使其与调度器 Cache 中的 PV/PVC 一致。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>检查 PV/PVC 状态：&lt;/p>
&lt;/li>
&lt;li>
&lt;p>检查所有 PVC 是否已处于 Bound 状态。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>检查所有 PV 的 NodeAffinity 是否与节点 Label 冲突。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>调度器执行 Bind 操作：调用 Kubernetes 的 API 更新 Pod 的 .Spec.NodeName 字段。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h3 id="2-存储卷扩容">&lt;strong>2. 存储卷扩容&lt;/strong>&lt;/h3>
&lt;p>存储卷扩容部分在 External Resizer 部分已提到，故不再赘述。用户只需要编辑 PVC 的 .Spec.Resources.Requests.Storage 字段即可，注意只可扩容不可缩容。&lt;/p>
&lt;p>若 PV 扩容失败，此时 PVC 无法重新编辑 spec 字段的 storage 为原来的值（只可扩容不可缩容）。参考 K8s 官网提供的 PVC 还原方法：&lt;/p>
&lt;p>&lt;em>&lt;a href="https://kubernetes.io/docs/concepts/storage/persistent-volumes/#recovering-from-failure-when-expanding-volumes">https://kubernetes.io/docs/concepts/storage/persistent-volumes/#recovering-from-failure-when-expanding-volumes&lt;/a>&lt;/em>&lt;/p>
&lt;h2 id="3-单节点卷数量限制">3. 单节点卷数量限制&lt;/h2>
&lt;p>卷数量限制在 Node Driver Registrar 部分已提到，故不再赘述。&lt;/p>
&lt;h2 id="4-存储卷监控">4. 存储卷监控&lt;/h2>
&lt;p>存储商需实现 CSI 插件的 NodeGetVolumeStats 接口，Kubelet 会调用该函数，并反映在其 metrics上：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>kubelet_volume_stats_capacity_bytes：存储卷容量&lt;/p>
&lt;/li>
&lt;li>
&lt;p>kubelet_volume_stats_used_bytes：存储卷已使用容量&lt;/p>
&lt;/li>
&lt;li>
&lt;p>kubelet_volume_stats_available_bytes：存储卷可使用容量&lt;/p>
&lt;/li>
&lt;li>
&lt;p>kubelet_volume_stats_inodes：存储卷 inode 总量&lt;/p>
&lt;/li>
&lt;li>
&lt;p>kubelet_volume_stats_inodes_used：存储卷 inode 使用量&lt;/p>
&lt;/li>
&lt;li>
&lt;p>kubelet_volume_stats_inodes_free：存储卷 inode 剩余量&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h2 id="5-secret">5. Secret&lt;/h2>
&lt;p>CSI 存储卷支持传入 Secret 来处理不同流程中所需要的私密数据，目前 StorageClass 支持如下 Parameter：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>csi.storage.k8s.io/provisioner-secret-name&lt;/p>
&lt;/li>
&lt;li>
&lt;p>csi.storage.k8s.io/provisioner-secret-namespace&lt;/p>
&lt;/li>
&lt;li>
&lt;p>csi.storage.k8s.io/controller-publish-secret-name&lt;/p>
&lt;/li>
&lt;li>
&lt;p>csi.storage.k8s.io/controller-publish-secret-namespace&lt;/p>
&lt;/li>
&lt;li>
&lt;p>csi.storage.k8s.io/node-stage-secret-name&lt;/p>
&lt;/li>
&lt;li>
&lt;p>csi.storage.k8s.io/node-stage-secret-namespace&lt;/p>
&lt;/li>
&lt;li>
&lt;p>csi.storage.k8s.io/node-publish-secret-name&lt;/p>
&lt;/li>
&lt;li>
&lt;p>csi.storage.k8s.io/node-publish-secret-namespace&lt;/p>
&lt;/li>
&lt;li>
&lt;p>csi.storage.k8s.io/controller-expand-secret-name&lt;/p>
&lt;/li>
&lt;li>
&lt;p>csi.storage.k8s.io/controller-expand-secret-namespace&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>Secret 会包含在对应 CSI 接口的参数中，如对于 CreateVolume 接口而言则包含在 CreateVolumeRequest.Secrets 中。&lt;/p>
&lt;h2 id="6-块设备">6. 块设备&lt;/h2>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-properties" data-lang="properties">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">apiVersion&lt;/span>&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#e6db74">apps/v1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">kind&lt;/span>&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#e6db74">StatefulSet&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">metadata&lt;/span>&lt;span style="color:#f92672">:&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">name&lt;/span>&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#e6db74">nginx-example&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">spec&lt;/span>&lt;span style="color:#f92672">:&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">selector&lt;/span>&lt;span style="color:#f92672">:&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">matchLabels&lt;/span>&lt;span style="color:#f92672">:&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">app&lt;/span>&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#e6db74">nginx&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">serviceName&lt;/span>&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#e6db74">&amp;#34;nginx&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">volumeClaimTemplates&lt;/span>&lt;span style="color:#f92672">:&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">-&lt;/span> &lt;span style="color:#e6db74">metadata:&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">name&lt;/span>&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#e6db74">html&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">spec&lt;/span>&lt;span style="color:#f92672">:&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">accessModes&lt;/span>&lt;span style="color:#f92672">:&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">-&lt;/span> &lt;span style="color:#e6db74">ReadWriteOnce&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">volumeMode&lt;/span>&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#e6db74">Block&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">storageClassName&lt;/span>&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#e6db74">csi-pangu&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">resources&lt;/span>&lt;span style="color:#f92672">:&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">requests&lt;/span>&lt;span style="color:#f92672">:&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">storage&lt;/span>&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#e6db74">40Gi&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">template&lt;/span>&lt;span style="color:#f92672">:&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">metadata&lt;/span>&lt;span style="color:#f92672">:&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">labels&lt;/span>&lt;span style="color:#f92672">:&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">app&lt;/span>&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#e6db74">nginx&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">spec&lt;/span>&lt;span style="color:#f92672">:&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">containers&lt;/span>&lt;span style="color:#f92672">:&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">-&lt;/span> &lt;span style="color:#e6db74">name: nginx&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">image&lt;/span>&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#e6db74">nginx&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">volumeDevices&lt;/span>&lt;span style="color:#f92672">:&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">-&lt;/span> &lt;span style="color:#e6db74">devicePath: &amp;#34;/dev/vdb&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">name&lt;/span>&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#e6db74">html&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>三方存储厂商需实现 NodePublishVolume 接口。Kubernetes 提供了针对块设备的工具包（&amp;ldquo;k8s.io/kubernetes/pkg/util/mount&amp;rdquo;），在 NodePublishVolume 阶段可调用该工具的 EnsureBlock 和 MountBlock 函数。&lt;/p>
&lt;h2 id="7-卷快照卷克隆能力">7. 卷快照/卷克隆能力&lt;/h2>
&lt;p>鉴于本文篇幅，此处不做过多原理性介绍。读者感兴趣见官方介绍：卷快照、卷克隆。&lt;/p>
&lt;h1 id="总结">总结&lt;/h1>
&lt;p>本文首先对 CSI 核心流程进行了大体介绍，并结合 CSI Sidecar 组件、CSI 接口、API 对象对 CSI 标准进行了深度解析。在 K8s 上，使用任何一种 CSI 存储卷都离不开上面的流程，环境上的容器存储问题也一定是其中某个环节出现了问题。&lt;/p></description></item><item><title>Docs: Data type AND Literal</title><link>https://desistdaydream.github.io/docs/2.%E7%BC%96%E7%A8%8B/%E8%A7%A3%E8%B0%9C%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/Data-Type-AND-Literal/Data-type-AND-Literal/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/2.%E7%BC%96%E7%A8%8B/%E8%A7%A3%E8%B0%9C%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/Data-Type-AND-Literal/Data-type-AND-Literal/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Data_type">Wiki，DataType&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Abstract_data_type">Wiki，Abstract Data Type&lt;/a>(抽象数据类型)&lt;/li>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Literal_(computer_programming)">Wiki，Literal(字面量)&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>在计算机科学和计算机编程中，&lt;strong>Data Type(数据类型，有时也简称 Type)&lt;/strong> 是数据的一个属性，这些属性将会让编译器知道程序员想要如何使用数据。&lt;/p>
&lt;p>在计算机科学中，&lt;strong>Literal(字面量)&lt;/strong> 是表示源代码中固定值的 snotation(表示法)。几乎所有计算机编程语言都具有对基本值的字面量表示，诸如：整数、浮点数以及字符串；而有很多也对布尔类型和字符类型的值也支持字面量表示；还有一些甚至对枚举类型的元素以及像数组、记录和对象等复合类型的值也支持字面量表示法。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// b 为常量，10为字面量,数据类型为整数
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">const&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#a6e22e">b&lt;/span> = &lt;span style="color:#ae81ff">10&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// str 为变量，hello world！为字面量，数据类型为字符串
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">string&lt;/span> &lt;span style="color:#a6e22e">str&lt;/span> = &lt;span style="color:#e6db74">&amp;#34;hello world！&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h1 id="数据类型的分类">数据类型的分类&lt;/h1>
&lt;ul>
&lt;li>原始数据类型&lt;/li>
&lt;li>复合类型&lt;/li>
&lt;li>抽象数据类型&lt;/li>
&lt;li>其他类型&lt;/li>
&lt;/ul>
&lt;h2 id="primitive-data-types原始数据类型">Primitive Data Types(原始数据类型)&lt;/h2>
&lt;p>&lt;a href="https://en.wikipedia.org/wiki/Primitive_data_type">原始数据类型&lt;/a>通常是语言实现的内置或基础类型。&lt;/p>
&lt;h3 id="machine-data-type机器数据类型">Machine Data Type(机器数据类型)&lt;/h3>
&lt;p>基于数字电子的计算机中的所有数据都表示为最低级别的&lt;a href="https://en.wikipedia.org/wiki/Bit">位&lt;/a>（替代 0 和 1）。数据的最小可寻址单元通常是一组称为&lt;a href="https://en.wikipedia.org/wiki/Byte">字节&lt;/a>的位（通常是一个&lt;a href="https://en.wikipedia.org/wiki/Octet_(computing)">八位组&lt;/a>，即 8 位）。由&lt;a href="https://en.wikipedia.org/wiki/Machine_code">机器代码&lt;/a>指令处理的单元称为&lt;a href="https://en.wikipedia.org/wiki/Word_(data_type)">字&lt;/a>（截至 2011 年，通常为 32 或 64 位）。大多数指令将字解释为&lt;a href="https://en.wikipedia.org/wiki/Binary_number">二进制数&lt;/a>，因此 32 位字可以表示从 0 到 232 - 1 或有符号整数值来自 -231 到 231 - 1 由于&lt;a href="https://en.wikipedia.org/wiki/Two%27s_complement">二进制补码&lt;/a>，机器语言和机器在大多数情况下不需要区分这些无符号和有符号数据类型。&lt;/p>
&lt;p>用于浮点算术的浮点数对字中的位使用不同的解释。有关详细信息，请参阅&lt;a href="https://en.wikipedia.org/wiki/Floating-point_arithmetic">浮点运算&lt;/a>。&lt;/p>
&lt;p>机器数据类型需要在&lt;a href="https://en.wikipedia.org/wiki/Systems_programming">系统&lt;/a>或&lt;a href="https://en.wikipedia.org/wiki/Low-level_programming_language">低级编程语言中&lt;/a>公开或可用，允许对硬件进行细粒度控制。的&lt;a href="https://en.wikipedia.org/wiki/C_programming_language">C 编程语言&lt;/a>，例如，建筑材料整数类型不同的宽度，如和。如果目标平台上不存在相应的本机类型，编译器将使用确实存在的类型将它们分解为代码。例如，如果在 16 位平台上请求一个 32 位整数，编译器会默认将其视为两个 16 位整数的数组。 shortlong&lt;/p>
&lt;p>在更高级别的编程中，机器数据类型通常被隐藏或_抽象_为一个实现细节，如果暴露，会使代码的可移植性降低。例如，numeric 可以提供泛型类型而不是某些特定位宽的整数。&lt;/p>
&lt;h3 id="boolean-type布尔类型">Boolean Type(布尔类型)&lt;/h3>
&lt;p>&lt;a href="https://en.wikipedia.org/wiki/Boolean_type">Boolean(布尔)&lt;/a> 类型表示值 &lt;a href="https://en.wikipedia.org/wiki/Logical_truth">true(真)&lt;/a> 和 &lt;a href="https://en.wikipedia.org/wiki/Logical_truth">false(假)&lt;/a>。尽管只有两个值是可能的，但出于效率原因，它们很少被实现为单个二进制数字。许多编程语言没有明确的布尔类型，&lt;strong>而是将 0 解释为 false，将其他值解释为 true&lt;/strong>。布尔数据是指如何将语言解释为机器语言的逻辑结构。在这种情况下，布尔值 0 指的是逻辑 False。True 总是非零，尤其是被称为布尔值 1 的一。&lt;/p>
&lt;h3 id="numeric-type数字类型">Numeric Type(数字类型)&lt;/h3>
&lt;ul>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Integer_(computing)">Integer(整数，简写 int)&lt;/a> 数据类型，或“非分数”。可以根据它们包含负值的能力进行子类型化（例如 unsigned 在 C 和 C++ 中）。也可具有小的预定义数目的亚型（如 short 和 long 在 C / C ++）; 或允许用户自由定义子范围，例如 1..12（例如&lt;a href="https://en.wikipedia.org/wiki/Pascal_(programming_language)">Pascal&lt;/a> / &lt;a href="https://en.wikipedia.org/wiki/Ada_(programming_language)">Ada&lt;/a>）。&lt;/li>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Floating_point">Floating Point(浮点)&lt;/a> 数据类型通常将值表示为高精度分数值（&lt;a href="https://en.wikipedia.org/wiki/Rational_numbers">有理数&lt;/a>，数学上），但有时会误导性地称为实数（令人联想到数学&lt;a href="https://en.wikipedia.org/wiki/Real_numbers">实数&lt;/a>）。它们通常对最大值和精度都有预定义的限制。通常以 a × 2 b 的形式在内部存储（其中 a 和 b 是整数），但以熟悉的&lt;a href="https://en.wikipedia.org/wiki/Decimal">十进制&lt;/a>形式显示。&lt;/li>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Fixed_point_(computing)">Fixed Point(定点)&lt;/a> 数据类型便于表示货币值。它们通常在内部实现为整数，从而导致预定义的限制。&lt;/li>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Bignum">Bignum&lt;/a>或&lt;a href="https://en.wikipedia.org/wiki/Arbitrary_precision">任意精度&lt;/a>数字类型缺乏预定义的限制。它们不是原始类型，出于效率原因很少使用。&lt;/li>
&lt;/ul>
&lt;h3 id="enumerations枚举">Enumerations(枚举)&lt;/h3>
&lt;p>&lt;a href="https://en.wikipedia.org/wiki/Enumerated_type">枚举类型&lt;/a>具有不同的值，其可以被比较和分配，但不一定必须在计算机的存储器中的任何特定的具体表示; 编译器和解释器可以任意表示它们。例如，一副扑克牌中的四个花色可能是名为 CLUB、DIAMOND、HEART、SPADE 的四个枚举数，属于一个名为 suit 的枚举类型。如果变量 V 被声明为具有花色作为它的数据类型，可以为它分配这四个值中的任何一个。一些实现允许程序员为枚举值分配整数值，甚至将它们视为与整数类型等效的。&lt;/p>
&lt;h2 id="composite-types复合类型">Composite Types(复合类型)&lt;/h2>
&lt;p>&lt;a href="https://en.wikipedia.org/wiki/Composite_type">复合类型&lt;/a>派生自多个原始类型。这可以通过多种方式完成。它们组合的方式称为&lt;a href="https://en.wikipedia.org/wiki/Data_structure">数据结构&lt;/a>。构成一个基本类型为化合物类型通常导致新类型，例如阵列的整数是一个不同类型的整数。&lt;/p>
&lt;ul>
&lt;li>&lt;strong>&lt;a href="https://en.wikipedia.org/wiki/Array_data_type">Array(数组)&lt;/a>&lt;/strong>，也称为载体，&lt;strong>&lt;a href="https://en.wikipedia.org/wiki/List_(abstract_data_type)">列表或序列&lt;/a>&lt;/strong> 的存储数量的元件，并提供&lt;a href="https://en.wikipedia.org/wiki/Random_access">随机接入&lt;/a>到单个元件。数组的元素通常（但并非在所有上下文中）需要具有相同的类型。数组可以是固定长度的或可扩展的。数组中的索引通常需要是来自特定范围的整数（如果不是，可以通过谈论&lt;a href="https://en.wikipedia.org/wiki/Associative_array">关联数组&lt;/a>来强调这种放松）（如果不是该范围内的所有索引都对应于元素，则它可能是一个&lt;a href="https://en.wikipedia.org/wiki/Sparse_array">稀疏数组&lt;/a>）。&lt;/li>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Record_(computer_science)">&lt;strong>Record(记录)，也称为 tuple(元组) 或 struct(结构)&lt;/strong>&lt;/a> 是最简单的&lt;a href="https://en.wikipedia.org/wiki/Data_structure">数据结构之一&lt;/a>。记录是包含其他值的值，通常采用固定数量和顺序，通常按 1 名称索引。记录的元素通常称为 &lt;strong>Fields(字段)&lt;/strong> 或 &lt;strong>Members(成员)&lt;/strong>。&lt;/li>
&lt;li>&lt;strong>&lt;a href="https://en.wikipedia.org/wiki/Union_type">Union(联合)&lt;/a>&lt;/strong> 类型定义将指定许多允许的原始类型中的哪一个可以存储在其实例中，例如“浮点数或长整数”。与&lt;a href="https://en.wikipedia.org/wiki/Record_(computer_science)">记录&lt;/a>相反，&lt;a href="https://en.wikipedia.org/wiki/Record_(computer_science)">记录&lt;/a>可以定义为包含一个浮点数和一个整数；而在联合中，一次只允许一种类型。
&lt;ul>
&lt;li>甲&lt;a href="https://en.wikipedia.org/wiki/Tagged_union">标签联合&lt;/a>（也称为&lt;a href="https://en.wikipedia.org/wiki/Variant_type">变体&lt;/a>，变体记录，识别联合，或不相交并）包含一个附加的字段，指示其当前型增强型安全性。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Set_(abstract_data_type)">&lt;strong>Set(集)&lt;/strong>&lt;/a> 是一个&lt;a href="https://en.wikipedia.org/wiki/Abstract_data_structure">抽象的数据结构&lt;/a>可以存储某些值，没有任何特别的&lt;a href="https://en.wikipedia.org/wiki/Sequence">顺序&lt;/a>，并且不重复的值。值本身不是从集合中检索的，而是测试成员资格的值以获得布尔值“in”或“not in”。&lt;/li>
&lt;li>&lt;strong>&lt;a href="https://en.wikipedia.org/wiki/Object_(computer_science)">Object(对象)&lt;/a>&lt;/strong> 包含许多数据字段，如 Record，以及许多用于访问或修改它们的子程序，称为 &lt;a href="https://en.wikipedia.org/wiki/Method_(computer_programming)">Methods(方法)&lt;/a>。&lt;/li>
&lt;/ul>
&lt;p>许多其他的都是可能的，但它们往往是上述的进一步变体和化合物。例如，&lt;a href="https://en.wikipedia.org/wiki/Linked_list">链表&lt;/a>可以存储与数组相同的数据，但提供&lt;a href="https://en.wikipedia.org/wiki/Sequential_access">顺序访问&lt;/a>而不是随机&lt;a href="https://en.wikipedia.org/wiki/Sequential_access">访问&lt;/a>，并且由&lt;a href="https://en.wikipedia.org/wiki/Dynamic_memory">动态内存中&lt;/a>的记录组成；虽然可以说是一种数据结构而不是类型本身，但它也很常见且足够独特，因此将其包含在复合类型的讨论中是合理的。&lt;/p>
&lt;h3 id="string字符串-和-text文本-类型">String(字符串) 和 Text(文本) 类型&lt;/h3>
&lt;ul>
&lt;li>一个&lt;a href="https://en.wikipedia.org/wiki/Character_(computing)">字符&lt;/a>，可能是某个&lt;a href="https://en.wikipedia.org/wiki/Alphabet">字母表&lt;/a>中的一个&lt;a href="https://en.wikipedia.org/wiki/Alphabet">字母&lt;/a>、一个数字、一个空格、一个标点符号等。&lt;/li>
&lt;li>一个&lt;a href="https://en.wikipedia.org/wiki/String_(computer_science)">字符串&lt;/a>，它是一个字符序列。字符串通常用于表示单词和文本，尽管除了最琐碎的情况外，所有文本都不仅仅涉及字符序列。&lt;/li>
&lt;/ul>
&lt;p>字符和字符串类型可以存储字符集（例如&lt;a href="https://en.wikipedia.org/wiki/ASCII">ASCII ）中&lt;/a>的字符序列。由于大多数字符集都包含&lt;a href="https://en.wikipedia.org/wiki/Numerical_digit">数字&lt;/a>，因此可以使用数字字符串，例如&amp;quot;1234&amp;quot;. 但是，许多语言将它们视为属于与数值不同的类型 1234。&lt;/p>
&lt;p>根据所需的字符“宽度”，字符和字符串类型可以有不同的子类型。最初的 7 位宽 ASCII 被发现是有限的，并被 8 位和 16 位集取代，它们可以编码各种各样的非拉丁字母（如&lt;a href="https://en.wikipedia.org/wiki/Hebrew">希伯来语&lt;/a>和&lt;a href="https://en.wikipedia.org/wiki/Chinese_language">中文&lt;/a>）和其他符号。字符串可以是适合拉伸的，也可以是固定大小的，即使是在相同的编程语言中。它们也可以按其最大大小进行子类型化。&lt;/p>
&lt;p>注意：字符串不是所有语言中的原始数据类型。例如，在 &lt;a href="https://en.wikipedia.org/wiki/C_(programming_language)">C 语言&lt;/a> 中，它们由字符数组组成。&lt;/p>
&lt;h2 id="abstract-data-types抽象数据类型">Abstract Data Types(抽象数据类型)&lt;/h2>
&lt;p>任何未指定数据具体表示的&lt;a href="https://en.wikipedia.org/wiki/Abstract_data_type">数据类型&lt;/a> 都是 &lt;strong>Abstract Data Type(抽象数据类型，简称 ADT)&lt;/strong>。相反，使用基于数据类型操作的正式规范来描述它。规范的任何实现都必须满足给定的规则。抽象数据类型用于形式&lt;a href="https://en.wikipedia.org/wiki/Semantics_(computer_science)">语义&lt;/a>和程序&lt;a href="https://en.wikipedia.org/wiki/Formal_verification">验证，&lt;/a>并且不太严格地用于&lt;a href="https://en.wikipedia.org/wiki/Design">设计&lt;/a>。&lt;/p>
&lt;p>除了验证之外，规范可能会立即转变为实现。例如，&lt;a href="https://en.wikipedia.org/wiki/OBJ_(programming_language)">OBJ&lt;/a>系列编程语言基于此选项，使用&lt;a href="https://en.wikipedia.org/wiki/Equation">等式&lt;/a>进行规范并&lt;a href="https://en.wikipedia.org/wiki/Rewriting">重写&lt;/a>以运行它们。&lt;a href="https://en.wikipedia.org/wiki/Algebraic_specification">代数规范&lt;/a>&lt;a href="https://en.wikipedia.org/wiki/Data_type#cite_note-3">[3]&lt;/a>是 1980 年左右 CS 的一个重要研究课题，几乎是当时抽象数据类型的同义词。它具有&lt;a href="https://en.wikipedia.org/wiki/Universal_algebra">通用代数&lt;/a>的数学基础。&lt;a href="https://en.wikipedia.org/wiki/Data_type#cite_note-4">[4]&lt;/a>通过允许其他公式而不仅仅是方程，可以使规范语言更具表现力。&lt;/p>
&lt;p>一个典型的例子是&lt;a href="https://en.wikipedia.org/wiki/List_(abstract_data_type)">list&lt;/a>、&lt;a href="https://en.wikipedia.org/wiki/Set_(abstract_data_type)#Multiset">bag&lt;/a>和&lt;a href="https://en.wikipedia.org/wiki/Set_(computer_science)">set&lt;/a>数据类型的层次结构。所有这些数据类型都可以通过三个操作声明：null，它构造空容器，single，它从单个元素构造一个容器，append，它组合了两个相同类型的容器。然后，可以通过对这些操作的以下规则来给出三种数据类型的完整规范：&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>- null 是左右中性：&lt;/th>
&lt;th>追加（空，A）= A，追加（A，空）= A。&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>- 对于列表，append 是关联的：&lt;/td>
&lt;td>追加（追加（A，B），C）=追加（A，追加（B，C））。&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>- 袋子增加交换性：&lt;/td>
&lt;td>追加（B，A）=追加（A，B）。&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>- 最后，集合也是幂等的：&lt;/td>
&lt;td>追加（A，A）= A。&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>可以通过以下方式指定对数据的访问，例如这些容器的成员函数：&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>- 成员（X，单（Y））= eq（X，Y）&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>- 成员（X，空）= 假&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>- 成员(X,append(A,B)) = or(member(X,A), member(X,B))&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="associative-array关联数组也称为-map">Associative array(关联数组，也称为 map)&lt;/h3>
&lt;h2 id="其他类型">其他类型&lt;/h2>
&lt;p>类型可以基于或派生自上述基本类型。在某些语言（例如 C）中，&lt;a href="https://en.wikipedia.org/wiki/Function_(computer_science)">函数&lt;/a>具有从其&lt;a href="https://en.wikipedia.org/wiki/Return_value">返回值&lt;/a>的类型派生的类型。&lt;/p>
&lt;h3 id="pointer指针-和-reference引用">Pointer(指针) 和 Reference(引用)&lt;/h3>
&lt;p>主条目：&lt;a href="https://en.wikipedia.org/wiki/Reference_(computer_science)">引用(计算机科学）&lt;/a>
主要的非复合派生类型是&lt;a href="https://en.wikipedia.org/wiki/Pointer_(computer_programming)">指针&lt;/a>，这是一种数据类型，其值直接引用（或“指向”）使用其&lt;a href="https://en.wikipedia.org/wiki/Memory_address">地址&lt;/a>存储在&lt;a href="https://en.wikipedia.org/wiki/Computer_memory">计算机内存中&lt;/a>其他位置的另一个值。它是一种原始的&lt;a href="https://en.wikipedia.org/wiki/Reference_(computer_science)">参考&lt;/a>。（在日常生活中，一本书的页码可以被认为是引用另一本书的一段数据）。指针通常以类似于整数的格式存储；但是，尝试取消引用或“查找”其值永远不是有效内存地址的指针会导致程序崩溃。为了改善这个潜在问题，指针被认为是指向它们指向的数据类型的单独类型，即使底层表示相同。&lt;/p>
&lt;h3 id="function函数-类型">Function(函数) 类型&lt;/h3>
&lt;p>主条目：&lt;a href="https://en.wikipedia.org/wiki/Function_type">函数类型&lt;/a>
虽然也可以为函数分配类型，但在本文的设置中，它们的类型不被视为数据类型。在这里，数据被视为不同于&lt;a href="https://en.wikipedia.org/wiki/Algorithm">算法&lt;/a>。在编程中，函数与后者密切相关。但是，因为&lt;a href="https://en.wikipedia.org/wiki/Universal_Turing_machine">通用数据处理的&lt;/a>一个中心原则是算法可以&lt;a href="https://en.wikipedia.org/wiki/G%C3%B6del_numbering#Generalizations">表示为数据&lt;/a>，例如文本描述和二进制程序，数据和函数之间的对比是有限的。其实函数不仅可以用数据来表示，函数也可以用来&lt;a href="https://en.wikipedia.org/wiki/Lambda_calculus#Encoding_datatypes">对数据&lt;/a>进行&lt;a href="https://en.wikipedia.org/wiki/Lambda_calculus#Encoding_datatypes">编码&lt;/a>。许多当代&lt;a href="https://en.wikipedia.org/wiki/Type_systems">类型系统&lt;/a>强烈关注函数类型，许多现代语言允许函数作为&lt;a href="https://en.wikipedia.org/wiki/First-class_citizen">一等公民运行&lt;/a>。
将函数从被视为数据类型的对象中排除在相关领域中并不少见。[&lt;a href="https://en.wikipedia.org/wiki/Wikipedia:Citation_needed">需要引用&lt;/a>] 例如，&lt;a href="https://en.wikipedia.org/wiki/Predicate_logic">谓词逻辑&lt;/a>不允许在函数或谓词名称上应用&lt;a href="https://en.wikipedia.org/wiki/Quantifier_(logic)">量词&lt;/a>。&lt;/p>
&lt;h3 id="meta元-类型">Meta(元) 类型&lt;/h3>
&lt;p>主条目：&lt;a href="https://en.wikipedia.org/wiki/Metaclass">元类&lt;/a>
一些编程语言将类型信息表示为数据，从而实现&lt;a href="https://en.wikipedia.org/wiki/Type_introspection">类型自省&lt;/a>和&lt;a href="https://en.wikipedia.org/wiki/Reflection_(computer_programming)">反射&lt;/a>。相比之下，&lt;a href="https://en.wikipedia.org/wiki/Type_constructor">高阶&lt;/a> &lt;a href="https://en.wikipedia.org/wiki/Type_systems">类型系统&lt;/a>虽然允许从其他类型构造类型并作为值传递给函数，但通常避免基于它们进行&lt;a href="https://en.wikipedia.org/wiki/Computational">计算&lt;/a>决策。[&lt;a href="https://en.wikipedia.org/wiki/Wikipedia:Citation_needed">需要引用&lt;/a>]&lt;/p>
&lt;h3 id="utility实用程序-类型">Utility(实用程序) 类型&lt;/h3>
&lt;p>为方便起见，高级语言可能提供现成的“现实世界”数据类型，例如时间、日期、货币值和内存，即使该语言允许从原始类型构建它们。&lt;/p></description></item><item><title>Docs: Docker Compose</title><link>https://desistdaydream.github.io/docs/10.%E4%BA%91%E5%8E%9F%E7%94%9F/2.2.%E5%AE%9E%E7%8E%B0%E5%AE%B9%E5%99%A8%E7%9A%84%E5%B7%A5%E5%85%B7/Docker/Docker-Compose/Docker-Compose/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/10.%E4%BA%91%E5%8E%9F%E7%94%9F/2.2.%E5%AE%9E%E7%8E%B0%E5%AE%B9%E5%99%A8%E7%9A%84%E5%B7%A5%E5%85%B7/Docker/Docker-Compose/Docker-Compose/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://docs.docker.com/compose/">官方文档&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://compose-spec.io/">菜鸟教程&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://compose-spec.io/">Compose 规范&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;h1 id="docker-compose-简介">Docker Compose 简介&lt;/h1>
&lt;p>Compose 是用于定义和运行多容器 Docker 应用程序的工具。通过 Compose，您可以使用 YML 文件来配置应用程序需要的所有服务。然后，使用一个命令，就可以通过该配置文件创建并启动所有服务。&lt;/p>
&lt;p>Compose 使用的三个步骤：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>使用 Dockerfile 定义应用程序的环境。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>使用 docker-compose.yml 定义构成应用程序的服务，这样它们可以在隔离环境中一起运行。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>最后，执行 docker-compose up 命令来启动并运行整个应用程序。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>docker-compose.yml 的配置案例如下（配置参数参考下文）：&lt;/p>
&lt;h2 id="实例">实例&lt;/h2>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-yaml" data-lang="yaml">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># yaml 配置实例&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">version&lt;/span>: &lt;span style="color:#e6db74">&amp;#39;3&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">services&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">web&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">build&lt;/span>: &lt;span style="color:#ae81ff">.&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">ports&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#e6db74">&amp;#34;5000:5000&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">volumes&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#ae81ff">.:/code&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#ae81ff">logvolume01:/var/log&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">links&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#ae81ff">redis&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">redis&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">image&lt;/span>: &lt;span style="color:#ae81ff">redis&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">volumes&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">logvolume01&lt;/span>: {}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h1 id="compose-安装">Compose 安装&lt;/h1>
&lt;p>Linux 上我们可以从 Github 上下载它的二进制包来使用，最新发行的版本地址：&lt;a href="https://github.com/docker/compose/releases">https://github.com/docker/compose/releases&lt;/a>。&lt;/p>
&lt;p>运行以下命令以下载 Docker Compose 的当前稳定版本：&lt;/p>
&lt;pre tabindex="0">&lt;code>$ sudo curl -L &amp;#34;https://github.com/docker/compose/releases/download/1.27.4/docker-compose-$(uname -s)-$(uname -m)&amp;#34; -o /usr/local/bin/docker-compose
&lt;/code>&lt;/pre>&lt;p>要安装其他版本的 Compose，请替换 1.24.1。&lt;/p>
&lt;p>将可执行权限应用于二进制文件：&lt;/p>
&lt;pre tabindex="0">&lt;code>$ sudo chmod +x /usr/local/bin/docker-compose
&lt;/code>&lt;/pre>&lt;p>测试是否安装成功：&lt;/p>
&lt;pre tabindex="0">&lt;code>$ docker-compose version
docker-compose version 1.27.4, build 40524192
docker-py version: 4.3.1
CPython version: 3.7.7
OpenSSL version: OpenSSL 1.1.0l 10 Sep 2019
&lt;/code>&lt;/pre>&lt;p>&lt;strong>注意&lt;/strong>： 对于 alpine，需要以下依赖包： py-pip，python-dev，libffi-dev，openssl-dev，gcc，libc-dev，和 make。&lt;/p>
&lt;h1 id="使用">使用&lt;/h1>
&lt;h3 id="1准备">1、准备&lt;/h3>
&lt;p>创建一个测试目录：&lt;/p>
&lt;pre tabindex="0">&lt;code>$ mkdir composetest
$ cd composetest
&lt;/code>&lt;/pre>&lt;p>在测试目录中创建一个名为 app.py 的文件，并复制粘贴以下内容：&lt;/p>
&lt;h2 id="composetestapppy-文件代码">composetest/app.py 文件代码&lt;/h2>
&lt;pre tabindex="0">&lt;code>import time
import redis
from flask import Flask
app = Flask(__name__)
cache = redis.Redis(host=&amp;#39;redis&amp;#39;, port=6379)
def get_hit_count():
retries = 5
while True:
try:
return cache.incr(&amp;#39;hits&amp;#39;)
except redis.exceptions.ConnectionError as exc:
if retries == 0:
raise exc
retries -= 1
time.sleep(0.5)
@app.route(&amp;#39;/&amp;#39;)
def hello():
count = get_hit_count()
return &amp;#39;Hello World! I have been seen {} times.\n&amp;#39;.format(count)
&lt;/code>&lt;/pre>&lt;p>在此示例中，redis 是应用程序网络上的 redis 容器的主机名，该主机使用的端口为 6379。&lt;/p>
&lt;p>在 composetest 目录中创建另一个名为 requirements.txt 的文件，内容如下：&lt;/p>
&lt;pre tabindex="0">&lt;code>flask
redis
&lt;/code>&lt;/pre>&lt;h3 id="2创建-dockerfile-文件">2、创建 Dockerfile 文件&lt;/h3>
&lt;p>在 composetest 目录中，创建一个名为的文件 Dockerfile，内容如下：&lt;/p>
&lt;pre tabindex="0">&lt;code>FROM python:3.7-alpine
WORKDIR /code
ENV FLASK_APP app.py
ENV FLASK_RUN_HOST 0.0.0.0
RUN apk add --no-cache gcc musl-dev linux-headers
COPY requirements.txt requirements.txt
RUN pip install -r requirements.txt
COPY . .
CMD [&amp;#34;flask&amp;#34;, &amp;#34;run&amp;#34;]
&lt;/code>&lt;/pre>&lt;p>&lt;strong>Dockerfile 内容解释：&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>
&lt;p>&lt;strong>FROM python:3.7-alpine&lt;/strong>: 从 Python 3.7 映像开始构建镜像。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>WORKDIR /code&lt;/strong>: 将工作目录设置为 /code。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>ENV FLASK_APP app.pyENV FLASK_RUN_HOST 0.0.0.0设置 flask 命令使用的环境变量。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>RUN apk add &amp;ndash;no-cache gcc musl-dev linux-headers&lt;/strong>: 安装 gcc，以便诸如 MarkupSafe 和 SQLAlchemy 之类的 Python 包可以编译加速。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>COPY requirements.txt requirements.txtRUN pip install -r requirements.txt复制 requirements.txt 并安装 Python 依赖项。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>COPY . .&lt;/strong>: 将 . 项目中的当前目录复制到 . 镜像中的工作目录。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>CMD [&amp;ldquo;flask&amp;rdquo;, &amp;ldquo;run&amp;rdquo;]&lt;/strong>: 容器提供默认的执行命令为：flask run。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h3 id="3创建-docker-composeyml">3、创建 docker-compose.yml&lt;/h3>
&lt;p>在测试目录中创建一个名为 docker-compose.yml 的文件，然后粘贴以下内容：&lt;/p>
&lt;h2 id="docker-composeyml-配置文件">docker-compose.yml 配置文件&lt;/h2>
&lt;pre tabindex="0">&lt;code># yaml 配置
version: &amp;#39;3&amp;#39;
services:
web:
build: .
ports:
- &amp;#34;5000:5000&amp;#34;
redis:
image: &amp;#34;redis:alpine&amp;#34;
&lt;/code>&lt;/pre>&lt;p>该 Compose 文件定义了两个服务：web 和 redis。&lt;/p>
&lt;ul>
&lt;li>
&lt;p>&lt;strong>web&lt;/strong>：该 web 服务使用从 Dockerfile 当前目录中构建的镜像。然后，它将容器和主机绑定到暴露的端口 5000。此示例服务使用 Flask Web 服务器的默认端口 5000 。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>redis&lt;/strong>：该 redis 服务使用 Docker Hub 的公共 Redis 映像。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h3 id="4使用-compose-命令构建和运行您的应用">4、使用 Compose 命令构建和运行您的应用&lt;/h3>
&lt;p>在测试目录中，执行以下命令来启动应用程序：&lt;/p>
&lt;pre tabindex="0">&lt;code>docker-compose up
&lt;/code>&lt;/pre>&lt;p>如果你想在后台执行该服务可以加上 -d 参数：&lt;/p>
&lt;pre tabindex="0">&lt;code>docker-compose up -d
&lt;/code>&lt;/pre></description></item><item><title>Docs: Driver</title><link>https://desistdaydream.github.io/docs/10.%E4%BA%91%E5%8E%9F%E7%94%9F/1.2.%E5%AE%9E%E7%8E%B0%E8%99%9A%E6%8B%9F%E5%8C%96%E7%9A%84%E5%B7%A5%E5%85%B7/%E8%99%9A%E6%8B%9F%E5%8C%96%E7%AE%A1%E7%90%86/Libvirt/Driver/Driver/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/10.%E4%BA%91%E5%8E%9F%E7%94%9F/1.2.%E5%AE%9E%E7%8E%B0%E8%99%9A%E6%8B%9F%E5%8C%96%E7%9A%84%E5%B7%A5%E5%85%B7/%E8%99%9A%E6%8B%9F%E5%8C%96%E7%AE%A1%E7%90%86/Libvirt/Driver/Driver/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://libvirt.org/drivers.html">官方文档，驱动程序&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>市面上有多种虚拟化平台，比如 &lt;a href="https://desistdaydream.github.io/docs/10.%E4%BA%91%E5%8E%9F%E7%94%9F/1.2.%E5%AE%9E%E7%8E%B0%E8%99%9A%E6%8B%9F%E5%8C%96%E7%9A%84%E5%B7%A5%E5%85%B7/KVM_QEMU/KVM_QEMU.md">KVM/QEMU&lt;/a>、&lt;a href="docs/10.%E4%BA%91%E5%8E%9F%E7%94%9F/1.2.%E5%AE%9E%E7%8E%B0%E8%99%9A%E6%8B%9F%E5%8C%96%E7%9A%84%E5%B7%A5%E5%85%B7/Hyper-V/Hyper-V.md">Hyper-V&lt;/a>、等等，Libvirt 想要调用这些虚拟化平台的能力，需要对应平台的 &lt;strong>Driver(驱动程序)&lt;/strong>，这个 Driver 可以对接虚拟化平台的的 &lt;strong>Hypervisor(虚拟机监视器)&lt;/strong> 以控制整个虚拟化环境。这就好比 Windows 系统想要使用显卡的能力，就需要对应的显卡驱动程序一样。&lt;/p>
&lt;p>想要连接到 Driver，我们需要使用 Libvirt API 开发的客户端应用程序（e.g. &lt;a href="https://desistdaydream.github.io/docs/10.%E4%BA%91%E5%8E%9F%E7%94%9F/1.2.%E5%AE%9E%E7%8E%B0%E8%99%9A%E6%8B%9F%E5%8C%96%E7%9A%84%E5%B7%A5%E5%85%B7/%E8%99%9A%E6%8B%9F%E5%8C%96%E7%AE%A1%E7%90%86/Libvirt/virsh%20%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%B7%A5%E5%85%B7/virsh%20%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%B7%A5%E5%85%B7.md">virsh&lt;/a>、&lt;a href="docs/10.%E4%BA%91%E5%8E%9F%E7%94%9F/1.2.%E5%AE%9E%E7%8E%B0%E8%99%9A%E6%8B%9F%E5%8C%96%E7%9A%84%E5%B7%A5%E5%85%B7/%E8%99%9A%E6%8B%9F%E5%8C%96%E7%AE%A1%E7%90%86/Libvirt/Libvirt%20API/virt-manager.md">virt-manager&lt;/a>、等等）。Drivers 通常作为服务端都暴露了 &lt;a href="docs/10.%E4%BA%91%E5%8E%9F%E7%94%9F/1.2.%E5%AE%9E%E7%8E%B0%E8%99%9A%E6%8B%9F%E5%8C%96%E7%9A%84%E5%B7%A5%E5%85%B7/%E8%99%9A%E6%8B%9F%E5%8C%96%E7%AE%A1%E7%90%86/Libvirt/Libvirt%20API/Libvirt%20API.md">Libvirt API&lt;/a>，这些客户端通过 &lt;a href="#URI">&lt;strong>URI&lt;/strong>&lt;/a> 找到并连接到 Driver，这就好像 mysql 客户端连接 mysql 也需要 IP 端口、etcdctl 连接 etcd 同理，很多客户端都是同样的逻辑。&lt;/p>
&lt;p>Libvirt 有如下几类 Drivers&lt;/p>
&lt;ul>
&lt;li>&lt;strong>Hypervisor drivers(Hypervisor 驱动)&lt;/strong>&lt;/li>
&lt;li>&lt;strong>Storage drivers(存储驱动)&lt;/strong>&lt;/li>
&lt;li>&lt;strong>Node device driver&lt;/strong>&lt;/li>
&lt;li>&lt;strong>Secret driver&lt;/strong>&lt;/li>
&lt;/ul>
&lt;p>&lt;del>一般情况应该始终有一个活跃状态的 Hypervisor driver，如果 libvirtd 进程可用的话，通常还会有一个活动状态的网络驱动和存储驱动&lt;/del>&lt;/p>
&lt;blockquote>
&lt;p>除了 Hypervisor 驱动有用以外，其他的几种驱动暂时没找到用途 —— 2023.7.5&lt;/p>
&lt;/blockquote>
&lt;p>使用 Libvirt 时，我们最常见的 virsh 和 libvirtd 就是一个客户端和服务端结构，virsh 是用 LIbvirt API 实现的客户端程序、libvirtd 则是暴露 LIbvirt API 的驱动程序。virsh 使用 URI 连接到 libvirtd 的指定驱动后，可以像 libvirtd 发出命令以管理虚拟化平台。&lt;/p>
&lt;h1 id="uri">URI&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://libvirt.org/uri.html">官方文档，连接 URI&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>Libvirt 的客户端程序（e.g. virsh、virt-manager、等等）&lt;strong>通过 &lt;a href="https://datatracker.ietf.org/doc/html/rfc2396">URI&lt;/a> 连接 Driver&lt;/strong>。这就好像 mysql 客户端连接 MySQL 需要一个 URL、redis 客户端连接 Redis 需要、etcdctl 连接 ETCD 也需要、等等。其实就是 &lt;code>virsh -c URI&lt;/code> 这种，类似 &lt;code>mysql -h X.X.X.X&lt;/code>、&lt;code>etcdctl --endpoint X.X.X.X&lt;/code> 之类的。只不过 Libvirt 的应用程序还可以使用 &lt;code>qemu:///system&lt;/code> 这种方式连接本地 Socket，而不止是常见的 TCP/IP。&lt;/p>
&lt;p>驱动程序通常都暴露了 Libvirt API，连接 Driver 的代码逻辑如下：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-c" data-lang="c">&lt;span style="display:flex;">&lt;span>virConnectPtr conn &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#a6e22e">virConnectOpen&lt;/span> (&lt;span style="color:#e6db74">&amp;#34;test:///default&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>实际上，就是将 URI 作为 virConnectOpen() 函数的参数，以生成一个连接到 Driver 的实例。&lt;/p>
&lt;h2 id="uri-语法">URI 语法&lt;/h2>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-text" data-lang="text">&lt;span style="display:flex;">&lt;span>Hypervisor[+Transport]://[UserName@][HostName][:PORT]/PATH[?Extraparameters]
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Hypervisor # 虚拟化类型，可用的值有：&lt;/p>
&lt;ul>
&lt;li>qemu&lt;/li>
&lt;li>xen&lt;/li>
&lt;li>test # 专门测试的，libvirt 自带&lt;/li>
&lt;/ul>
&lt;p>Transport # 连接方式。默认为 unix&lt;/p>
&lt;ul>
&lt;li>unix&lt;/li>
&lt;li>ssh&lt;/li>
&lt;li>tcp&lt;/li>
&lt;li>libssh、libssh2&lt;/li>
&lt;li>auto&lt;/li>
&lt;li>netcat&lt;/li>
&lt;li>native&lt;/li>
&lt;li>ext&lt;/li>
&lt;li>tls&lt;/li>
&lt;/ul>
&lt;h2 id="默认-uri">默认 URI&lt;/h2>
&lt;p>如果我们传递给 &lt;code>virConnectOpen&lt;/code> 函数的参数为空，即 URI 为空，那么 Driver 通常使用如下逻辑来确定要使用的 URI&lt;/p>
&lt;ul>
&lt;li>环境变量 LIBVIRT_DEFAULT_URI&lt;/li>
&lt;li>客户端配置文件 uri_default 参数&lt;/li>
&lt;li>依次探查每个虚拟机监控程序，直到找到有效的虚拟机监控程序&lt;/li>
&lt;/ul>
&lt;p>对于 virsh 这个客户端程序来说，可以使用配置文件（/etc/libvirt/libvirt.conf）中的 uri_default 参数、还可以使用 -c 选项覆盖这个配置。&lt;/p>
&lt;h2 id="uri-种类">URI 种类&lt;/h2>
&lt;p>共分为两种 URI&lt;/p>
&lt;ul>
&lt;li>本地 URI&lt;/li>
&lt;li>远程 URI&lt;/li>
&lt;/ul>
&lt;h3 id="本地-uri">本地 URI&lt;/h3>
&lt;p>其中本地 URI 语法通常都会省略所有 &lt;code>[]&lt;/code> 部分，这样就会看到 3 个连续的 &lt;code>/&lt;/code> 符号，就像 &lt;code>qemu:///system&lt;/code>，这里的 Transport 就是默认的 unix，这就是本地 URI 了。&lt;/p>
&lt;p>URI 示例&lt;/p>
&lt;p>连接到系统模式守护程序&lt;/p>
&lt;ul>
&lt;li>&lt;code>qemu:///system&lt;/code>&lt;/li>
&lt;/ul>
&lt;p>连接到会话模式守护程序&lt;/p>
&lt;ul>
&lt;li>&lt;code>qemu:///session&lt;/code>&lt;/li>
&lt;/ul>
&lt;p>如果这样做 &lt;code>libvirtd --help&lt;/code>，守护程序将打印出以各种不同方式监听的 Unix 域套接字的路径。&lt;/p>
&lt;p>本地使用测试 URI&lt;/p>
&lt;p>连接到驱动程序内置的一组默认主机定义&lt;/p>
&lt;ul>
&lt;li>&lt;code>test:///default&lt;/code>&lt;/li>
&lt;/ul>
&lt;p>连接到指定文件中保存的一组主机定义&lt;/p>
&lt;ul>
&lt;li>&lt;code>test:///PATH/TO/HOST/DEFINITIONS&lt;/code>&lt;/li>
&lt;/ul>
&lt;h3 id="远程-uri">远程 URI&lt;/h3>
&lt;p>远程 URI 的语法有一些是不能省略的，其中 Transport、HostName 必须指定&lt;/p>
&lt;pre tabindex="0">&lt;code>Hypervisor+Transport://[UserName@]HostName[:PORT]/PATH[?Extraparameters]
&lt;/code>&lt;/pre>&lt;p>URI 示例&lt;/p>
&lt;p>通过 ssh 以 root 用户身份连接&lt;/p>
&lt;ul>
&lt;li>&lt;code>qemu+ssh://root@172.38.180.96/system&lt;/code>&lt;/li>
&lt;/ul>
&lt;p>通过 tcp 连接。默认连接到 16509 端口，前提参考 &lt;a href="#%E9%80%9A%E8%BF%87%20TCP%20%E8%BF%9E%E6%8E%A5">通过 TCP 连接&lt;/a> 部分的内容为 libvirtd 开启 TCP 监听。&lt;/p>
&lt;p>&lt;code>qemu+tcp://172.38.180.95/system&lt;/code>&lt;/p>
&lt;h2 id="uri-中额外的参数详解">URI 中额外的参数详解&lt;/h2>
&lt;h1 id="hypervisor-驱动程序">Hypervisor 驱动程序&lt;/h1>
&lt;p>Hypervisor Driver 有几种表现形式&lt;/p>
&lt;ul>
&lt;li>内嵌在 Libvirt API 客户端应用程序中&lt;/li>
&lt;li>内置到 libvirt.so 库&lt;/li>
&lt;li>&lt;a href="docs/10.%E4%BA%91%E5%8E%9F%E7%94%9F/1.2.%E5%AE%9E%E7%8E%B0%E8%99%9A%E6%8B%9F%E5%8C%96%E7%9A%84%E5%B7%A5%E5%85%B7/%E8%99%9A%E6%8B%9F%E5%8C%96%E7%AE%A1%E7%90%86/Libvirt/Driver/Libvirt%20%E5%AE%88%E6%8A%A4%E8%BF%9B%E7%A8%8B.md">Libvirt 守护进程&lt;/a>，比如 libvirtd&lt;/li>
&lt;li>等等&lt;/li>
&lt;/ul>
&lt;h2 id="qemukvm-驱动">QEMU/KVM 驱动&lt;/h2>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://libvirt.org/drvqemu.html">官方文档，QEMU/KVM/HVF hypervisor 驱动程序&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>Libvirt 的 KVM/QEMU 驱动程序将会探测 &lt;code>/usr/bin/&lt;/code> 目录是否存在 &lt;code>qemu&lt;/code>, &lt;code>qemu-system-x86_64&lt;/code>, &lt;code>qemu-system-microblaze&lt;/code>, &lt;code>qemu-system-microblazeel&lt;/code>, &lt;code>qemu-system-mips&lt;/code>,&lt;code>qemu-system-mipsel&lt;/code>, &lt;code>qemu-system-sparc&lt;/code>,&lt;code>qemu-system-ppc&lt;/code>。来决定如何连接 QEMU emulator。&lt;/p>
&lt;p>Libvirt 的 KVM/QEMU 驱动程序将会探测 &lt;code>/usr/bin&lt;/code> 目录是否存在 &lt;code>qemu-kvm&lt;/code>，以及 /dev/kvm 驱动是否存在。来决定如何连接 KVM hypervisor。&lt;/p>
&lt;p>libvirt QEMU 驱动程序是一个&lt;strong>多实例&lt;/strong>驱动程序，提供单个系统范围的特权驱动程序（“system”实例）和每用户非特权驱动程序（“session”实例）。 URI 驱动程序协议是“qemu”。 libvirt 驱动程序的一些连接 URI 示例如下：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>qemu:///session &lt;span style="color:#f92672">(&lt;/span>local access to per-user instance&lt;span style="color:#f92672">)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>qemu+unix:///session &lt;span style="color:#f92672">(&lt;/span>local access to per-user instance&lt;span style="color:#f92672">)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>qemu:///system &lt;span style="color:#f92672">(&lt;/span>local access to system instance&lt;span style="color:#f92672">)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>qemu+unix:///system &lt;span style="color:#f92672">(&lt;/span>local access to system instance&lt;span style="color:#f92672">)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>qemu://example.com/system &lt;span style="color:#f92672">(&lt;/span>remote access, TLS/x509&lt;span style="color:#f92672">)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>qemu+tcp://example.com/system &lt;span style="color:#f92672">(&lt;/span>remote access, SASl/Kerberos&lt;span style="color:#f92672">)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>qemu+ssh://root@example.com/system &lt;span style="color:#f92672">(&lt;/span>remote access, SSH tunnelled&lt;span style="color:#f92672">)&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>通常，对于本地连接 QEMU/KVM 驱动来说，默认都是 &lt;code>qemu:///system&lt;/code>，即连接到 system 实例以管理虚拟机。&lt;/p>
&lt;h3 id="嵌入式驱动">嵌入式驱动&lt;/h3>
&lt;p>&lt;a href="https://libvirt.org/drvqemu.html#embedded-driver">https://libvirt.org/drvqemu.html#embedded-driver&lt;/a>&lt;/p>
&lt;p>从 6.1.0 版本开始，可以使用 virsh 的嵌入式驱动。&lt;/p>
&lt;p>用 &lt;code>qemu:///embed?root=/some/dir&lt;/code> 这种 URI 可以使用 virsh 的内置 QEMU/KVM 驱动，并将运行时数据保存到 /some/dir/ 目录中，改目录的结构如下：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>/some/dir
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> |
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> +- log
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> | |
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> | +- qemu
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> | +- swtpm
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> +- etc
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> | |
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> | +- qemu
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> | +- pki
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> | |
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> | +- qemu
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> +- run
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> | |
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> | +- qemu
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> | +- swtpm
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> +- cache
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> | |
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> | +- qemu
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> +- lib
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> |
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> +- qemu
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> +- swtpm
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h1 id="连接驱动的方式示例">连接驱动的方式示例&lt;/h1>
&lt;h3 id="使用-virsh-连接-driver">使用 virsh 连接 Driver&lt;/h3>
&lt;p>这里以 virsh 命令行工具作为示例，其他基于 Libvirt API 的第三方工具，都是同样的道理。&lt;/p>
&lt;p>virsh 可以使用 -c 或者 &amp;ndash;connect 选项连接到指定的 libvirtd。比如：&lt;code>virsh -c qemu+tcp://172.38.180.96/system&lt;/code>&lt;/p>
&lt;p>我们可以在客户端配置文件(/etc/libvirt/libvirt.conf)中，设定 &lt;code>uri_default&lt;/code> 关键字的值以改变 virsh 默认链接到 libvirtd，通常默认值为：&lt;code>qemu:///system&lt;/code>，即连接本地的 libvirtd 并管理 QEMU 虚拟机。&lt;/p>
&lt;h3 id="以代码方式连接-driver">以代码方式连接 Driver&lt;/h3>
&lt;p>Python 客户端库&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-python" data-lang="python">&lt;span style="display:flex;">&lt;span>conn &lt;span style="color:#f92672">=&lt;/span> libvirt&lt;span style="color:#f92672">.&lt;/span>open(&lt;span style="color:#e6db74">&amp;#34;qemu+tcp://172.38.180.95/system&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Go 客户端库&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">conn&lt;/span>, &lt;span style="color:#a6e22e">err&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">libvirt&lt;/span>.&lt;span style="color:#a6e22e">NewConnect&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;qemu:///system&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div></description></item><item><title>Docs: ECMAScript</title><link>https://desistdaydream.github.io/docs/2.%E7%BC%96%E7%A8%8B/%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/ECMAScript/ECMAScript/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/2.%E7%BC%96%E7%A8%8B/%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/ECMAScript/ECMAScript/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/ECMAScript">Wiki，ECMAScript&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.javascript.com/">JavaScript 官网&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.typescriptlang.org/">TypeScript 官网&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>ECMAScript 是一种编程语言的&lt;strong>标准&lt;/strong>，起源于 JavaScripts。&lt;/p>
&lt;p>1996 年 8 月，微软模仿 JavaScript 开发了一种相近的语言，取名为 JScript（JavaScript 是 Netscape 的注册商标，微软不能用），首先内置于 IE 3.0。Netscape 公司面临丧失浏览器脚本语言的主导权的局面。&lt;/p>
&lt;p>1996 年 11 月，Netscape 公司决定将 JavaScript 提交给国际标准化组织 ECMA（European Computer Manufacturers Association），希望 JavaScript 能够成为国际标准，以此抵抗微软。ECMA 的 39 号技术委员会（Technical Committee 39）负责制定和审核这个标准，成员由业内的大公司派出的工程师组成，目前共 25 个人。该委员会定期开会，所有的邮件讨论和会议记录，都是公开的。&lt;/p>
&lt;p>1997 年 7 月，ECMA 组织发布 262 号标准文件（ECMA-262）的第一版，规定了浏览器脚本语言的标准，并将这种语言称为 ECMAScript。这个版本就是 ECMAScript 1.0 版。之所以不叫 JavaScript，一方面是由于商标的关系，Java 是 Sun 公司的商标，根据一份授权协议，只有 Netscape 公司可以合法地使用 JavaScript 这个名字，且 JavaScript 已经被 Netscape 公司注册为商标，另一方面也是想体现这门语言的制定者是 ECMA，不是 Netscape，这样有利于保证这门语言的开放性和中立性。因此，ECMAScript 和 JavaScript 的关系是，前者是后者的规范，后者是前者的一种实现。在日常场合，这两个词是可以互换的。&lt;/p>
&lt;p>ECMAScript 只用来标准化 JavaScript 这种语言的基本语法结构，与部署环境相关的标准都由其他标准规定，比如 DOM 的标准就是由 W3C 组织（World Wide Web Consortium）制定的。&lt;/p>
&lt;p>ECMA-262 标准后来也被另一个国际标准化组织 ISO（International Organization for Standardization）批准，标准号是 ISO-16262。&lt;/p>
&lt;h2 id="es6-标准">ES6 标准&lt;/h2>
&lt;p>ECMAScript 6.0 是 ECMA 的最新标准，于 2015 年 6 月发布，官方称为 ES2015 标准(ES6 的叫法更民间)。&lt;/p>
&lt;p>2011 年，ECMAScript 5.1 版发布后，就开始制定 6.0 版了。因此，ES6 这个词的原意，就是指 JavaScript 语言的下一个版本。&lt;/p>
&lt;p>但是，因为这个版本引入的语法功能太多，而且制定过程当中，还有很多组织和个人不断提交新功能。事情很快就变得清楚了，不可能在一个版本里面包括所有将要引入的功能。常规的做法是先发布 6.0 版，过一段时间再发 6.1 版，然后是 6.2 版、6.3 版等等。&lt;/p>
&lt;p>但是，标准的制定者不想这样做。他们想让标准的升级成为常规流程：任何人在任何时候，都可以向标准委员会提交新语法的提案，然后标准委员会每个月开一次会，评估这些提案是否可以接受，需要哪些改进。如果经过多次会议以后，一个提案足够成熟了，就可以正式进入标准了。这就是说，标准的版本升级成为了一个不断滚动的流程，每个月都会有变动。&lt;/p>
&lt;p>标准委员会最终决定，标准在每年的 6 月份正式发布一次，作为当年的正式版本。接下来的时间，就在这个版本的基础上做改动，直到下一年的 6 月份，草案就自然变成了新一年的版本。这样一来，就不需要以前的版本号了，只要用年份标记就可以了。&lt;/p>
&lt;p>ES6 的第一个版本，就这样在 2015 年 6 月发布了，正式名称就是《ECMAScript 2015 标准》（简称 ES2015）。2016 年 6 月，小幅修订的《ECMAScript 2016 标准》（简称 ES2016）如期发布，这个版本可以看作是 ES6.1 版，因为两者的差异非常小（只新增了数组实例的 includes 方法和指数运算符），基本上是同一个标准。根据计划，2017 年 6 月发布 ES2017 标准。&lt;/p>
&lt;p>因此，ES6 既是一个历史名词，也是一个泛指，含义是 5.1 版以后的 JavaScript 的下一代标准，涵盖了 ES2015、ES2016、ES2017 等等，而 ES2015 则是正式名称，特指该年发布的正式版本的语言标准。本书中提到 ES6 的地方，一般是指 ES2015 标准，但有时也是泛指“下一代 JavaScript 语言”。&lt;/p>
&lt;h2 id="ecmascript-的三大核心组成">ECMAScript 的三大核心组成&lt;/h2>
&lt;p>&lt;strong>ECMAScript&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>JS 的书写语法和规则&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>Browser Ojbect Model(浏览器对象模型，简称 BOM)&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>JS 控制浏览器的属性和方法。
&lt;ul>
&lt;li>比如浏览器右侧的滚动条，可以通过 JS 代码来控制。比如某些网页有个叫回到顶部的按钮，按一下，就等于是 JS 操作滚动条移动到最上面了。&lt;/li>
&lt;li>比如很多手机，我们从屏幕最左侧往右滑，一般返回上一页。这是因为这个滑动行为被 JS 代码捕获后，操作浏览器点击了一下后腿按钮。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>Document Object Model(文档对象模型，简称 DOM)&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>JS 控制文档流的属性和方法。
&lt;ul>
&lt;li>比如很多网页最上面中间都有一个图片，按一下图片左右两边的箭头，就会换到另一个图片&lt;/li>
&lt;li>也就是说，JS 控制什么时候，让页面元素发生一些变化&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h1 id="学习资料">学习资料&lt;/h1>
&lt;p>&lt;a href="https://developer.mozilla.org/en-US/docs/Web">MDN 官方文档，Web 开发技术&lt;/a>((通常指的是网站首页的 References 标签中的文档))&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript">JavaScript&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Lexical_grammar#keywords">JavaScript-参考-词汇文法-关键字&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Statements">JavaScript-参考-语句和声明&lt;/a>(这里就是 JS 的关键字的用法)&lt;/li>
&lt;/ul>
&lt;p>&lt;a href="https://www.liaoxuefeng.com/wiki/1022910821149312">廖雪峰，JavaScript&lt;/a>&lt;/p>
&lt;p>&lt;a href="https://wangdoc.com/javascript/index.html">网道，JavaScript&lt;/a>&lt;/p>
&lt;p>电子书&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://github.com/javascript-tutorial/zh.javascript.info/tree/master">GitHub 项目，javascript/zh.javascript.info&lt;/a>(现代 JavaScript 教程)&lt;/li>
&lt;/ul>
&lt;h1 id="hello-world">Hello World&lt;/h1>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-html" data-lang="html">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&amp;lt;!DOCTYPE html&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&amp;lt;&lt;span style="color:#f92672">html&lt;/span>&amp;gt;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &amp;lt;&lt;span style="color:#f92672">head&lt;/span>&amp;gt;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &amp;lt;&lt;span style="color:#f92672">meta&lt;/span> &lt;span style="color:#a6e22e">charset&lt;/span>&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;UTF-8&amp;#34;&lt;/span> /&amp;gt;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &amp;lt;&lt;span style="color:#f92672">title&lt;/span>&amp;gt;Hello World&amp;lt;/&lt;span style="color:#f92672">title&lt;/span>&amp;gt;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &amp;lt;/&lt;span style="color:#f92672">head&lt;/span>&amp;gt;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &amp;lt;&lt;span style="color:#f92672">body&lt;/span>&amp;gt;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">&amp;lt;!-- 有多种方式可以在书写 JS 代码 --&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">&amp;lt;!-- 行内式， JS 代码写在标签上--&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">&amp;lt;!-- a 标签，书写在 href 属性上 --&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &amp;lt;&lt;span style="color:#f92672">a&lt;/span> &lt;span style="color:#a6e22e">href&lt;/span>&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;javascript: alert(&amp;#39;Hello World，行内式，a 标签&amp;#39;);&amp;#34;&lt;/span>&amp;gt;点我&amp;lt;/&lt;span style="color:#f92672">a&lt;/span>&amp;gt;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">&amp;lt;!-- 非 a 标签，书写在行为属性上 --&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &amp;lt;&lt;span style="color:#f92672">div&lt;/span> &lt;span style="color:#a6e22e">onclick&lt;/span>&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;alert(&amp;#39;Hello World，行内式，非 a 标签&amp;#39;)&amp;#34;&lt;/span>&amp;gt;点我&amp;lt;/&lt;span style="color:#f92672">div&lt;/span>&amp;gt;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">&amp;lt;!-- 内嵌式，JS 代码写在 script 标签中 --&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &amp;lt;&lt;span style="color:#f92672">script&lt;/span>&amp;gt;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 在前端页面上显示的内容
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#a6e22e">alert&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;Hello World 内嵌式&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 在后端控制台显示的内容
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#a6e22e">console&lt;/span>.&lt;span style="color:#a6e22e">log&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;Hello World backend&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &amp;lt;/&lt;span style="color:#f92672">script&lt;/span>&amp;gt;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">&amp;lt;!-- 外链试，JS 代码写在单独的 .js 文件中，并通过 script 标签的 src 属性引入 .js 文件 --&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &amp;lt;&lt;span style="color:#f92672">script&lt;/span> &lt;span style="color:#a6e22e">src&lt;/span>&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;./hello_world.js&amp;#34;&lt;/span>&amp;gt;&amp;lt;/&lt;span style="color:#f92672">script&lt;/span>&amp;gt;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">&amp;lt;!-- 总结：
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> 行内式 # 强烈不推荐。不利于代码维护，也会导致 HTML 文件过于臃肿。
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> 内嵌式 # 一般测试或者学习时，使用这种方式，不用建立很多 .js 文件。
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> 外链式 # 强烈推荐
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> --&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &amp;lt;/&lt;span style="color:#f92672">body&lt;/span>&amp;gt;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&amp;lt;/&lt;span style="color:#f92672">html&lt;/span>&amp;gt;
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h1 id="javascript-语言关键字">JavaScript 语言关键字&lt;/h1>
&lt;p>break
case
catch
class
const
continue
debugger
default
delete
do
else
enum
export
extends
false
finally
for
function
if
implements
import
in
instanceof
interface
let
new
null
package
private
protected
public
return
super
switch
static
this
throw
try
true
typeof
var
void
while
with
yield&lt;/p>
&lt;h1 id="javascript-范儿">JavaScript 范儿&lt;/h1></description></item><item><title>Docs: ECMAScript 第三方库</title><link>https://desistdaydream.github.io/docs/2.%E7%BC%96%E7%A8%8B/%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/ECMAScript/ECMAScript-%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/ECMAScript-%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/2.%E7%BC%96%E7%A8%8B/%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/ECMAScript/ECMAScript-%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/ECMAScript-%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/</guid><description>
&lt;h1 id="postman">Postman&lt;/h1>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-javascript" data-lang="javascript">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 将响应体解析为 JSON 格式
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#a6e22e">respBodyJSON&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#a6e22e">JSON&lt;/span>.&lt;span style="color:#a6e22e">parse&lt;/span>(&lt;span style="color:#a6e22e">responseBody&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">respBodyJSON&lt;/span>.&lt;span style="color:#a6e22e">data&lt;/span>.&lt;span style="color:#a6e22e">forEach&lt;/span>(&lt;span style="color:#66d9ef">function&lt;/span> (&lt;span style="color:#a6e22e">item&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">console&lt;/span>.&lt;span style="color:#a6e22e">log&lt;/span>(&lt;span style="color:#a6e22e">item&lt;/span>.&lt;span style="color:#a6e22e">title&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>})
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h1 id="axios">Axios&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://github.com/axios/axios">GitHub 项目，axios/axios&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://axios-http.com/">官网&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>Axios 是用于浏览器和 node.js 的基于 Promise 的 HTTP 客户端&lt;/p></description></item><item><title>Docs: ECMAScript 环境安装与使用</title><link>https://desistdaydream.github.io/docs/2.%E7%BC%96%E7%A8%8B/%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/ECMAScript/ECMAScript-%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8/ECMAScript-%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/2.%E7%BC%96%E7%A8%8B/%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/ECMAScript/ECMAScript-%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8/ECMAScript-%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;/blockquote>
&lt;p>有两种运行时环境可以运行 ECMAScript 代码(Javascript、Typescript)&lt;/p>
&lt;ul>
&lt;li>&lt;strong>Browser&lt;/strong># 浏览器就是 ECMAScript 的运行时环境。&lt;/li>
&lt;li>&lt;strong>Node.js&lt;/strong> # 在服务器或 PC 上安装 Node.js 环境以运行 ECMAScript 代码&lt;/li>
&lt;li>&lt;strong>Deno&lt;/strong> # &lt;a href="https://github.com/denoland/deno">GtiHub 项目，denoland/deno&lt;/a>。据说要替代 Node.js，很尴尬的是。。。早期 18 年的 issue 中被各种国人无意义灌水&lt;/li>
&lt;li>&lt;strong>Bun&lt;/strong> # &lt;a href="https://github.com/oven-sh/bun">GtiHub 项目，oven-sh/bun&lt;/a>&lt;/li>
&lt;/ul>
&lt;p>但是这两者可以提供的 API 能力各不相同&lt;/p>
&lt;ul>
&lt;li>Browser 可以提供的 dockument、window 和其他关于 DOM 或其他 Web 平台 API 的对象。&lt;/li>
&lt;li>Node.js 则可以提供很多操作系统相关的 API，比如文件的读写、进程管理、网络通信等等。&lt;/li>
&lt;/ul>
&lt;p>Node.js 与 Browser 都是基于 Chrome V8 引擎的 ECMAScript 运行时环境&lt;/p>
&lt;p>你也许会想，直接在我的硬盘上创建好 HTML 和 JavaScript 文件，然后用浏览器打开，不就可以看到效果了吗？&lt;/p>
&lt;p>这种方式运行部分 JavaScript 代码没有问题，但由于浏览器的安全限制，以 file:// 开头的地址无法执行如联网等 JavaScript 代码，最终，你还是需要架设一个 Web 服务器，然后以 http:// 开头的地址来正常执行所有 JavaScript 代码。&lt;/p>
&lt;p>所以，想要运行 JavaScript 编写的静态文件，通常都需要一个可以提供 HTTP 服务的程序，以便响应客户端的请求返回这些静态文件。通常在生产环境中，我们都会将静态资源文件放到 Nginx 的目录中，由 Nginx 为客户端提供 HTTP 服务。&lt;/p>
&lt;p>而本地测试时，我们通过 npm 与 yarn 工具即可安装一个简易的 HTTP 服务，这个 HTTP 服务都是由 JS 代码写的，必须要保证本地有 Node.js 环境，即可启动一个 HTTP 服务&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># Npm 安装 http-server&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>~&lt;span style="color:#f92672">]&lt;/span>&lt;span style="color:#75715e"># npm install http-server&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># Yarn 安装 http-server&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>~&lt;span style="color:#f92672">]&lt;/span>&lt;span style="color:#75715e"># yarn add http-server&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>http-server 来源于 &lt;a href="https://github.com/http-party/http-server">GitHub 项目，http-party/http-server&lt;/a>&lt;/p>
&lt;p>通过 &lt;code>npm exec serve&lt;/code> 命令将会安装另一个名为 serve 的库以运行 HTTP 服务，默认在 3000 端口上启动 HTTP 服务，通过浏览器访问 localhost:3000 即可获取到所有自己编写的静态文件，便于让开发人员在本地调试。&lt;/p>
&lt;h2 id="重点运行具有-module模块-功能的静态资源">(重点)运行具有 Module(模块) 功能的静态资源&lt;/h2>
&lt;p>从《ECMAScript 模块》章节可以看到，当我们使用 &lt;code>import name from './one.js'&lt;/code> 导入的模块是一个文件时，那么这个文件将会被响应给浏览器，如果使用 &lt;code>import name from 'one'&lt;/code> 导入的模块是一组文件时，此时浏览器无法直接识别，将会产生报错。因为浏览器想要执行这一组文件需要发起很多次的请求将所有文件都加载到本地，这其中的路由路径将是不可控的。&lt;/p>
&lt;p>所以，此时我们则需要想办法将这一组文件变为一个文件响应给浏览器以便加载代码。这个转换的操作，我们可以使用打包工具(i.e.Webpack、Vite 等等) 将源代码&lt;strong>打包编译&lt;/strong>成新的静态文件即可。&lt;/p>
&lt;p>后面的逻辑，与基本运行 ECMAScript 代码的行为就是一样的了。&lt;/p>
&lt;h2 id="使用-vite-运行-ecmascript-代码">使用 Vite 运行 ECMAScript 代码&lt;/h2>
&lt;p>npm、yarn 的打包后运行代码的速度非常缓慢，才是推荐使用 Vite 工具启动 HTTP 服务并运行 JS/TS 代码，详见：[《Vite》](/docs/2.编程/高级编程语言/ECMAScript/ECMAScript%20 工具/Vite.md 工具/Vite.md) 章节&lt;/p>
&lt;h2 id="运行-typesript">运行 TypeSript&lt;/h2>
&lt;p>Node.js 和 浏览器都无法直接运行 TypeScript 代码，这是因为 TS 的代码需要先转换为 JS 代码才可以运行。此时就需要一种工具，先转换再运行，或者直接转换运行一体。&lt;/p>
&lt;ul>
&lt;li>&lt;strong>tsc&lt;/strong> # 将 TS 代码转换为 JS 代码。&lt;code>npm install -g typescript&lt;/code>&lt;/li>
&lt;li>&lt;strong>ts-node&lt;/strong> # 可以直接转换并运行 TS 代码，&lt;code>npm install -g ts-node&lt;/code> 安装即可&lt;/li>
&lt;/ul>
&lt;h1 id="nodejs">Node.js&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://nodejs.org/en/">org 官网&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://nodejs.dev/">dev 官网&lt;/a>&lt;/li>
&lt;li>&lt;a href="http://nodejs.cn/">dev 官网中文翻译&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Node.js">Wiki,Node.js&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>Node.js 是基于 Chrome V8 引擎的 ECMAScript 运行时环境，由 RyanDahl 于 2009 年 5 月 27 日发布。转年(i.e.2010 年 1 月)，为 Node.js 环境引入了一个名为 npm 的包管理器。包管理器使程序员更容易发布和共享 Node.js 的源代码，旨在简化包的安装、更新、卸载。&lt;/p>
&lt;p>Browser 和 Node.js 都是 ECMAScript 的运行时环境，但是这两者可以提供的 API 能力各不相同&lt;/p>
&lt;ul>
&lt;li>Browser 可以提供的 dockument、window 和其他关于 DOM 或其他 Web 平台 API 的对象。&lt;/li>
&lt;li>Node.js 则可以提供很多操作系统相关的 API，比如文件的读写、进程管理、网络通信等等。&lt;/li>
&lt;/ul>
&lt;p>通过 Node.js，可以让我们使用一种语言编写前端与后端。我们甚至可以通过 npm 与 yarn 安装第三方库后，使用 Node.js 在本地监听端口并响应给客户端静态资源文件。&lt;/p>
&lt;h2 id="安装-nodejs">安装 Node.js&lt;/h2>
&lt;h3 id="linux">Linux&lt;/h3>
&lt;p>从&lt;a href="https://nodejs.org/zh-cn/download/">官网&lt;/a>下载 Linux 版的 &lt;code>.tar.xg&lt;/code> 包，并解压&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>export NodejsVersion&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;v18.15.0&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>wget https://nodejs.org/dist/&lt;span style="color:#e6db74">${&lt;/span>NodejsVersion&lt;span style="color:#e6db74">}&lt;/span>/node-&lt;span style="color:#e6db74">${&lt;/span>NodejsVersion&lt;span style="color:#e6db74">}&lt;/span>-linux-x64.tar.xz
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>sudo tar -xvf node-&lt;span style="color:#e6db74">${&lt;/span>NodejsVersion&lt;span style="color:#e6db74">}&lt;/span>-linux-x64.tar.xz -C /usr/local/
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>sudo mv /usr/local/node-&lt;span style="color:#e6db74">${&lt;/span>NodejsVersion&lt;span style="color:#e6db74">}&lt;/span>-linux-x64 /usr/local/nodejs
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>配置环境变量&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>sudo tee /etc/profile.d/nodejs.sh &amp;gt; /dev/null &amp;lt;&amp;lt;-&lt;span style="color:#e6db74">&amp;#34;EOF&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>export PATH&lt;span style="color:#f92672">=&lt;/span>$PATH:/usr/local/nodejs/bin
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>EOF
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>source /etc/profile.d/nodejs.sh
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="windows">Windows&lt;/h3>
&lt;p>警告！！！由于 msi 安装包会修改 %PREFIX% 为 &lt;code>%APPDATA%\npm&lt;/code> ，并将该目录到 $PATH。我个人推荐下载 zip，并自己解压到想要的位置后，手动配置环境变量。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-powershell" data-lang="powershell">&lt;span style="display:flex;">&lt;span>$NodejsVersion = &lt;span style="color:#e6db74">&amp;#34;18.14.1&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>$NodejsUrl = &lt;span style="color:#e6db74">&amp;#34;https://nodejs.org/dist/v&lt;/span>$NodejsVersion&lt;span style="color:#e6db74">/node-v&lt;/span>$NodejsVersion&lt;span style="color:#e6db74">-win-x64.zip&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>$TempZipFile = &lt;span style="color:#e6db74">&amp;#34;D:\tmp\nodejs.zip&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>$ExtractPath = &lt;span style="color:#e6db74">&amp;#34;D:\Tools&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># Download the zip file to a temporary location&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Invoke-WebRequest -Uri $NodejsUrl -OutFile $TempZipFile
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># Extract the contents of the zip file to the installation directory and rename the top-level directory to &amp;#34;nodejs&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Expand-Archive -Path $TempZipFile -DestinationPath $ExtractPath
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Rename-Item -Path &lt;span style="color:#e6db74">&amp;#34;&lt;/span>$ExtractPath&lt;span style="color:#e6db74">\node-v&lt;/span>$NodejsVersion&lt;span style="color:#e6db74">-win-x64&amp;#34;&lt;/span> -NewName &lt;span style="color:#e6db74">&amp;#34;nodejs&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>将 nodejs/ 目录添加到用户的 PATH 环境变量中&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-powershell" data-lang="powershell">&lt;span style="display:flex;">&lt;span>$path = [&lt;span style="color:#66d9ef">Environment&lt;/span>]::GetEnvironmentVariable(&lt;span style="color:#e6db74">&amp;#34;Path&amp;#34;&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;User&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>$newPath = &lt;span style="color:#e6db74">&amp;#34;D:\Tools\nodejs&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>[&lt;span style="color:#66d9ef">Environment&lt;/span>]::SetEnvironmentVariable(&lt;span style="color:#e6db74">&amp;#34;Path&amp;#34;&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;&lt;/span>$path&lt;span style="color:#e6db74">;&lt;/span>$newPath&lt;span style="color:#e6db74">&amp;#34;&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;User&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="目录结构">目录结构&lt;/h3>
&lt;p>Linux 目录结构，node_modules/ 目录在 lib/ 目录下，这点与 Windows 不同。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">]&lt;/span>&lt;span style="color:#75715e"># tree -L 2 -F&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>.
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>├── bin/
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>│   ├── corepack -&amp;gt; ../lib/node_modules/corepack/dist/corepack.js*
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>│   ├── node*
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>│   ├── npm -&amp;gt; ../lib/node_modules/npm/bin/npm-cli.js*
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>│   ├── npx -&amp;gt; ../lib/node_modules/npm/bin/npx-cli.js*
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>│   ├── pnpm -&amp;gt; ../lib/node_modules/corepack/dist/pnpm.js*
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>│   ├── pnpx -&amp;gt; ../lib/node_modules/corepack/dist/pnpx.js*
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>│   ├── yarn -&amp;gt; ../lib/node_modules/corepack/dist/yarn.js*
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>│   └── yarnpkg -&amp;gt; ../lib/node_modules/corepack/dist/yarnpkg.js*
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>├── CHANGELOG.md
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>├── include/
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>│   └── node/
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>├── lib/
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>│   └── node_modules/
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>├── LICENSE
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>├── README.md
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>└── share/
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ├── doc/
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ├── man/
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> └── systemtap/
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Windows 目录结构&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>$ tree -L &lt;span style="color:#ae81ff">2&lt;/span> -F
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>./
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>├── CHANGELOG.md*
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>├── LICENSE*
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>├── README.md*
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>├── corepack*
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>├── corepack.cmd*
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>├── install_tools.bat*
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>├── node.exe*
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>├── node_etw_provider.man*
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>├── node_modules/
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>│   ├── corepack/
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>│   └── npm/
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>├── nodevars.bat*
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>├── npm*
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>├── npm.cmd*
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>├── npx*
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>└── npx.cmd*
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="nvm">NVM&lt;/h2>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://github.com/nvm-sh/nvm">GitHub 项目，nvm-sh/nvm&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>&lt;strong>Node Version Manager(Node.js 版本管理器，简称 NVM)&lt;/strong>&lt;/p>
&lt;h2 id="nodejs-关联文件与配置">Node.js 关联文件与配置&lt;/h2>
&lt;p>详见：&lt;a href="https://desistdaydream.github.io/docs/2.%E7%BC%96%E7%A8%8B/%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/ECMAScript/ECMAScript%20%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8/ECMAScript%20%E6%A8%A1%E5%9D%97%E4%B8%8E%E5%8C%85%E7%9A%84%E4%BD%BF%E7%94%A8%E4%B8%8E%E7%AE%A1%E7%90%86.md#npm%20%E5%85%B3%E8%81%94%E6%96%87%E4%BB%B6%E4%B8%8E%E9%85%8D%E7%BD%AE">npm 关键文件与配置&lt;/a>&lt;/p>
&lt;h1 id="初始化项目">初始化项目&lt;/h1>
&lt;p>npm 等包管理工具下载完框架后，会自动生成项目目录，这些目录是已经初始化完成的项目，包含了很多必要的文件，比如 package.json 等。&lt;/p>
&lt;p>随着学习深入，会逐步总结一个前端项目如果不使用框架从头构建的话会需要什么。&lt;/p>
&lt;ul>
&lt;li>&lt;strong>public/&lt;/strong> 目录存放公共资源&lt;/li>
&lt;li>&lt;strong>src/&lt;/strong> # 所有代码都在 src/ 目录下&lt;/li>
&lt;li>&lt;strong>.eslintrc.cjs&lt;/strong> # ESLint 程序配置&lt;/li>
&lt;li>&lt;strong>.prettierc.json&lt;/strong> # Prettier 插件的配置&lt;/li>
&lt;li>&lt;strong>env.d.ts&lt;/strong> #&lt;/li>
&lt;li>&lt;strong>index.html&lt;/strong> # 程序入口&lt;/li>
&lt;li>[&lt;strong>package.json&lt;/strong>](/docs/2.编程/高级编程语言/ECMAScript/ECMAScript%20 环境安装与使用/package.json.md 环境安装与使用/package.json.md) # 包管理器配置文件，比如 npm、pnpm 等&lt;/li>
&lt;li>&lt;strong>vite.config.ts&lt;/strong> # Vite 程序给项目打包时使用的配置&lt;/li>
&lt;li>&lt;strong>tsconfig.json&lt;/strong> #&lt;/li>
&lt;li>&lt;strong>tsconfig.config.json&lt;/strong> # [TSConfig](/docs/2.编程/高级编程语言/ECMAScript/ECMAScript%20 环境安装与使用/TSConfig.md 环境安装与使用/TSConfig.md) 文件&lt;/li>
&lt;/ul>
&lt;h2 id="javascript-项目初始化">JavaScript 项目初始化&lt;/h2>
&lt;p>无&lt;/p>
&lt;h2 id="typescript-项目初始化">TypeScript 项目初始化&lt;/h2>
&lt;p>使用 &lt;code>npm install -g typescript&lt;/code> 安装 tsc 命令。&lt;/p>
&lt;p>使用 &lt;code>tsc init&lt;/code> 命令将会生成 [TSConfig](/docs/2.编程/高级编程语言/ECMAScript/ECMAScript%20 环境安装与使用/TSConfig.md 环境安装与使用/TSConfig.md) 文件。&lt;/p>
&lt;h1 id="编译与打包">编译与打包&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://github.com/webpack/webpack">GitHub 项目，webpack/webpack&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://github.com/rollup/rollup">GitHub 项目，rollup/rollup&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>大型项目通常都要打包，打包工具有很多：&lt;/p>
&lt;ul>
&lt;li>Webpack&lt;/li>
&lt;li>Rollup&lt;/li>
&lt;li>Vite&lt;/li>
&lt;li>&amp;hellip;&amp;hellip;等等&lt;/li>
&lt;/ul>
&lt;h1 id="常见问题">常见问题&lt;/h1>
&lt;h2 id="nodejs-无法使用-es6-语法问题">Node.js 无法使用 ES6 语法问题&lt;/h2>
&lt;p>无法使用 import 关键字导入模块。参考 &lt;a href="https://nodejs.org/docs/latest-v16.x/api/esm.html#enabling">https://nodejs.org/docs/latest-v16.x/api/esm.html#enabling&lt;/a>，在 package.json 文件中设置 &lt;code>&amp;quot;type&amp;quot;: &amp;quot;module&amp;quot;&lt;/code> 或者使用 &lt;code>--input-type=module&lt;/code> 命令行参数以告诉 Node.js 使用 ECMAScript 模块加载器。默认情况下，Node.js 使用 CommonJS 模块加载器。&lt;/p></description></item><item><title>Docs: Electron</title><link>https://desistdaydream.github.io/docs/2.%E7%BC%96%E7%A8%8B/%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/ECMAScript/Electron/Electron/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/2.%E7%BC%96%E7%A8%8B/%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/ECMAScript/Electron/Electron/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://github.com/electron/electron">GitHub 项目，electron/electron&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.electronjs.org/">官网&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>Electron（以前称为 Atom Shell）是由 &lt;a href="https://en.wikipedia.org/wiki/OpenJS_Foundation">OpenJS 基金会&lt;/a>开发和维护的免费开源软件框架。该框架旨在使用 Web 技术（主要是 HTML、CSS 和 JavaScript，尽管也可以使用前端框架和 Web Assembly 等其他技术）创建桌面应用程序，这些技术使用 Chromium 浏览器引擎版本和后端使用Node.js 运行时环境。它还使用各种 API 来实现与 Node.js 服务的本机集成和进程间通信模块等功能。&lt;/p>
&lt;p>Electron 最初是 GitHub 为 Atom 构建的，是多个开源项目背后的主要 GUI 框架，包括 Atom、GitHub Desktop、Light Table、Visual Studio Code、WordPress Desktop 和 Eclipse Theia。&lt;/p></description></item><item><title>Docs: etcdctl</title><link>https://desistdaydream.github.io/docs/5.%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8/2.%E6%95%B0%E6%8D%AE%E5%BA%93/%E9%94%AE%E5%80%BC%E6%95%B0%E6%8D%AE/Etcd/Etcd-%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%B7%A5%E5%85%B7/etcdctl/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/5.%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8/2.%E6%95%B0%E6%8D%AE%E5%BA%93/%E9%94%AE%E5%80%BC%E6%95%B0%E6%8D%AE/Etcd/Etcd-%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%B7%A5%E5%85%B7/etcdctl/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>官方文档：&lt;a href="https://github.com/etcd-io/etcd/tree/master/etcdctl">https://github.com/etcd-io/etcd/tree/master/etcdctl&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://etcd.io/docs/latest/integrations/">etcd 可用的库和客户端&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;h1 id="syntax语法">Syntax(语法)&lt;/h1>
&lt;p>&lt;strong>etcdctl [GlobalOptions] COMMAND [CommandOptions] [Arguments&amp;hellip;]&lt;/strong>&lt;/p>
&lt;p>使用说明：&lt;/p>
&lt;ul>
&lt;li>export ETCDCTL_API=3 使用该命令使得 etcdctl 通过 v3 版本来进行操作&lt;/li>
&lt;li>如果在 etcd 的配置文件中的 Security 段落，开启了验证证书，则在使用命令时，需要使用&amp;ndash;cert、&amp;ndash;key、&amp;ndash;cacert 选项来指定验证所需证书，否则无法操纵服务器
&lt;ul>
&lt;li>v2 版本中使用如下方式 etcdctl &amp;ndash;key-file=/etc/kubernetes/pki/etcd/peer.key &amp;ndash;cert-file=/etc/kubernetes/pki/etcd/peer.crt &amp;ndash;ca-file=/etc/kubernetes/pki/etcd/ca.crt &amp;ndash;endpoints=&amp;ldquo;https://IP:PORT&amp;rdquo; COMMAND&lt;/li>
&lt;li>v3 版本中使用如下方式 etcdctl &amp;ndash;key=/etc/kubernetes/pki/etcd/peer.key &amp;ndash;cert=/etc/kubernetes/pki/etcd/peer.crt &amp;ndash;cacert=/etc/kubernetes/pki/etcd/ca.crt &amp;ndash;endpoints=&amp;ldquo;https://IP:PORT&amp;rdquo; COMMAND&lt;/li>
&lt;li>在下面的 EXAMPLE 则不再输入认证相关参数，以便查阅方便。但是实际使用中需要使用，否则无法连接 etcd 服务端&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h2 id="global-options">GLOBAL OPTIONS&lt;/h2>
&lt;ul>
&lt;li>&lt;strong>&amp;ndash;cacert=/PATH/FILE&lt;/strong> # 使用此 CA 包验证启用 TLS 的安全服务器的证书。即 etcd 的 ca，用该 ca 来验证 cert 选项中提供的证书是否正确&lt;/li>
&lt;li>&lt;strong>&amp;ndash;cert=/PATH/FILE&lt;/strong># 使用指定的 TLS 证书文件鉴定客户端是否安全。即 etcd 的 peer 证书，peer 证书对于 etcdctl 来说就是与它交互的服务端的证书&lt;/li>
&lt;li>&lt;strong>&amp;ndash;key=/PATH/FILE&lt;/strong> # 使用指定的 TLS 证书的密钥文件鉴定客户端是否安全。即 etcd 的 peer 证书的私钥&lt;/li>
&lt;li>&lt;strong>&amp;ndash;endpoints=[IP1:PORT1,IP2:PORT2,&amp;hellip;..]&lt;/strong> # 指定后端服务器的 IP 和 Port&lt;/li>
&lt;li>&amp;ndash;command-timeout=5s # timeout for short running command (excluding dial timeout)&lt;/li>
&lt;li>&amp;ndash;debug[=false] # enable client-side debug logging&lt;/li>
&lt;li>&amp;ndash;dial-timeout=2s # dial timeout for client connections&lt;/li>
&lt;li>&amp;ndash;hex[=false] # print byte strings as hex encoded strings&lt;/li>
&lt;li>&amp;ndash;insecure-skip-tls-verify[=false # skip server certificate verification&lt;/li>
&lt;li>&amp;ndash;insecure-transport[=true] # disable transport security for client connections&lt;/li>
&lt;li>&amp;ndash;user=&amp;quot;&amp;quot; # username[:password] for authentication (prompt if password is not supplied)&lt;/li>
&lt;li>-w, &amp;ndash;write-out=&amp;ldquo;simple&amp;rdquo; # 指定输出内容的格式，格式可有有这么几个 (fields, json, protobuf, simple, table)(一般常用 json)
&lt;ul>
&lt;li>Note：输出的 json 格式只有一行，可以使用 jq 程序来对 json 进行格式化，可以把每个{}分行，以便人类阅读，下图为样例&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/miobxe/1616136392283-c0b50823-df6d-49d3-8d85-2aed1c7de3e0.jpeg" alt="">&lt;/p>
&lt;h1 id="基本命令">基本命令&lt;/h1>
&lt;h2 id="get---获取键或者键的范围gets-the-key-or-a-range-of-keys">get - 获取键或者键的范围。Gets the key or a range of keys&lt;/h2>
&lt;p>&lt;strong>etcdctl get [OPTIONS] [Range-End]&lt;/strong>&lt;/p>
&lt;p>OPTIONS&lt;/p>
&lt;ul>
&lt;li>&amp;ndash;consistency=&amp;ldquo;l&amp;rdquo; Linearizable(l) or Serializable(s)&lt;/li>
&lt;li>&amp;ndash;from-key[=false] Get keys that are greater than or equal to the given key using byte compare&lt;/li>
&lt;li>&lt;strong>&amp;ndash;keys-only[=false]&lt;/strong> # 仅获取键而不显示该键所对应的值&lt;/li>
&lt;li>&amp;ndash;limit=0 # Maximum number of results&lt;/li>
&lt;li>&amp;ndash;order=&amp;quot;&amp;quot; # Order of results; ASCEND or DESCEND (ASCEND by default)&lt;/li>
&lt;li>&lt;strong>&amp;ndash;prefix[=false]&lt;/strong> # 获取 KEY 前缀匹配到的所有的键。前缀就是键名的从开头开始的的字符串。可以指定&lt;code>''&lt;/code>匹配所有 KEY&lt;/li>
&lt;li>&amp;ndash;print-value-only[=false] Only write values when using the &amp;ldquo;simple&amp;rdquo; output format&lt;/li>
&lt;li>&amp;ndash;rev=0 Specify the kv revision&lt;/li>
&lt;li>&amp;ndash;sort-by=&amp;quot;&amp;quot; Sort target; CREATE, KEY, MODIFY, VALUE, or VERSION&lt;/li>
&lt;/ul>
&lt;p>EXAMPLE&lt;/p>
&lt;ul>
&lt;li>etcdctl get &amp;ndash;prefix &amp;ndash;keys-only &amp;rsquo;&amp;rsquo; # 获取所有键，并且只显示键名。&lt;/li>
&lt;li>etcdctl get &amp;ndash;prefix &amp;ndash;keys-only / # 获取以&lt;code>/&lt;/code>开头的所有键，并且只显示键名。&lt;/li>
&lt;li>etcdv3 get /registry/events/kube-system/kube-flannel-ds-amd64-47cnw.15966b23d2027e45 -w=json | jq . # 以 json 格式输出指定键的值，并使用 jq 命令对 json 内容进行格式化输出以便人类阅读&lt;/li>
&lt;/ul>
&lt;p>put # 写入一个 key/value 到 etcd 存储中。&lt;/p>
&lt;p>del # 删除指定的 key 或一个范围的 keys&lt;/p>
&lt;p>txn Txn processes all the requests in one transaction&lt;/p>
&lt;p>compaction Compacts the event history in etcd&lt;/p>
&lt;h1 id="alarm---告警相关命令">alarm - 告警相关命令&lt;/h1>
&lt;h2 id="alerm-disarm---解除所有告警">alerm disarm - 解除所有告警&lt;/h2>
&lt;h2 id="alarm-list---列出-etcd-中所有的告警">alarm list - 列出 etcd 中所有的告警&lt;/h2>
&lt;h1 id="check---检查-etcd-的性能">check - 检查 etcd 的性能&lt;/h1>
&lt;h2 id="check-datascale">check datascale&lt;/h2>
&lt;p>检查在给定的 endpoint 上为不同工作负载保持数据时的内存使用情况。&lt;/p>
&lt;h2 id="check-perf---检查-etcd-的性能">check perf - 检查 etcd 的性能&lt;/h2>
&lt;p>检查 60 秒的 etcd 群集性能。经常运行检查性能可以创建一个较大的键空间历史记录，可以使用&amp;ndash;auto-compact 和&amp;ndash;auto-defrag 选项（如下所述）对其进行自动压缩和碎片整理。&lt;/p>
&lt;p>&lt;strong>注意：性能检查会产生碎片，推荐性能测试后，执行 &lt;code>etcdctl defrag&lt;/code> 命令清理碎片&lt;/strong>&lt;/p>
&lt;p>OPTIONS&lt;/p>
&lt;ul>
&lt;li>&lt;strong>&amp;ndash;load&lt;/strong> # 性能检查的工作负载模型。可接受的工作负载：s(small 小)，m(medium 中)，l(large 大)，xl(x 大)&lt;/li>
&lt;/ul>
&lt;h1 id="defrag">defrag&lt;/h1>
&lt;p>defrag 命令可以对 etcd 成员的存储空间进行碎片整理，etcd 成员目标可以是正在运行，也可以是未运行的，当处理未运行的数据库碎片时，指定存储路径即可。&lt;/p>
&lt;h2 id="example">EXAMPLE&lt;/h2>
&lt;p>在 Etcd 当前节点成员运行碎片整理操作&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-sh" data-lang="sh">&lt;span style="display:flex;">&lt;span>$ etcdctl defrag
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Finished defragmenting etcd member&lt;span style="color:#f92672">[&lt;/span>127.0.0.1:2379&lt;span style="color:#f92672">]&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>在集群中的所有成员运行碎片整理操作：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>$ etcdctl defrag --cluster
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Finished defragmenting etcd member&lt;span style="color:#f92672">[&lt;/span>http://127.0.0.1:2379&lt;span style="color:#f92672">]&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Finished defragmenting etcd member&lt;span style="color:#f92672">[&lt;/span>http://127.0.0.1:22379&lt;span style="color:#f92672">]&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Finished defragmenting etcd member&lt;span style="color:#f92672">[&lt;/span>http://127.0.0.1:32379&lt;span style="color:#f92672">]&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>在 Etcd 未运行时，对数据存储目录执行碎片整理操作：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-sh" data-lang="sh">&lt;span style="display:flex;">&lt;span>$ etcdctl defrag --data-dir &amp;lt;PathToEtcdDataDir&amp;gt;
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h1 id="endpoint---用于查询-etcd-中各个端点的信息">endpoint - 用于查询 etcd 中各个端点的信息&lt;/h1>
&lt;p>endpoint health # Checks the healthiness of endpoints specified in &lt;code>--endpoints&lt;/code> flag&lt;/p>
&lt;p>endpoint status # 打印出 &amp;ndash;endpoints 标志中指定的 endpoints 状态&lt;/p>
&lt;p>endpoint hashkv # Prints the KV history hash for each endpoint in &amp;ndash;endpoints&lt;/p>
&lt;h1 id="lease---相关命令">lease - 相关命令&lt;/h1>
&lt;p>lease grant Creates leases&lt;/p>
&lt;p>lease revoke Revokes leases&lt;/p>
&lt;p>lease timetolive Get lease information&lt;/p>
&lt;p>lease keep-alive Keeps leases alive (renew)&lt;/p>
&lt;h1 id="member---管理-etcd-集群中的成员">member - 管理 etcd 集群中的成员&lt;/h1>
&lt;p>member add # 将新成员作为新对等方引入 etcd 集群中。&lt;/p>
&lt;p>member remove # 从参与集群共识的成员中删除 etcd 集群的成员。&lt;/p>
&lt;p>member update # 为 etcd 集群中现有成员设置对等 URL。&lt;/p>
&lt;p>member list # 列出集群中的所有成员&lt;/p>
&lt;p>EXAMPLE&lt;/p>
&lt;ul>
&lt;li>etcdctl member list # 列出 etcd 集群中的成员&lt;/li>
&lt;li>etcdctl member list &amp;ndash;write-out=json | jq . # 通过 json 可以看到 etcd 集群中，哪个是节点是 leader&lt;/li>
&lt;/ul>
&lt;h1 id="snapshot---快照相关命令">snapshot - 快照相关命令。&lt;/h1>
&lt;p>snapshot 相关的命令可以让将 etcd 的数据进行备份与恢复&lt;/p>
&lt;p>&lt;strong>etcdctl snapshot save&lt;/strong> # 存储一个 etcd 节点后端快照到指定文件。Stores an etcd node backend snapshot to a given file
EXAMPLE&lt;/p>
&lt;ul>
&lt;li>etcdctl snapshot save snapshot.db # 备份指定后端节点的 etcd 数据到 snapshot.db 文件&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>etcdctl snapshot restore [OPTIONS]&lt;/strong> # 恢复一个 etcd 成员的快照到一个 etcd 的文件夹中。
OPTIONS&lt;/p>
&lt;ul>
&lt;li>&lt;strong>&amp;ndash;data-dir=/PATH/FILE&lt;/strong># 把指定的路径作为 snapshot 文件的恢复目录，会把数据写到指定的目录下。Path to the data directory&lt;/li>
&lt;/ul>
&lt;p>EXAMPLE&lt;/p>
&lt;ul>
&lt;li>etcdctl snapshot restore snapshot.db &amp;ndash;data-dir=/var/lib/etcd/ # 从 snapshot.db 文件中恢复数据到/var/lib/etcd/目录下&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>etcdctl snapshot status&lt;/strong> # 取指定文件的后端快照状态。Gets backend snapshot status of a given file
EXAMPLE&lt;/p>
&lt;ul>
&lt;li>etcdv3 snapshot status snapshot.db # 获取 snapshot.db 的状态，包括键/值对有多少，占多少空间&lt;/li>
&lt;/ul>
&lt;h1 id="其他">其他&lt;/h1>
&lt;p>make-mirror Makes a mirror at the destination etcd cluster&lt;/p>
&lt;p>migrate Migrates keys in a v2 store to a mvcc store&lt;/p>
&lt;p>lock Acquires a named lock&lt;/p>
&lt;p>elect Observes and participates in leader election&lt;/p>
&lt;p>auth enable Enables authentication&lt;/p>
&lt;p>auth disable Disables authentication&lt;/p>
&lt;h2 id="user--etcd-用户相关的命令">user # etcd 用户相关的命令&lt;/h2>
&lt;p>详见：&lt;a href="https://desistdaydream.github.io/docs/5.%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8/2.%E6%95%B0%E6%8D%AE%E5%BA%93/%E9%94%AE%E5%80%BC%E6%95%B0%E6%8D%AE/Etcd/Etcd%20%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%B7%A5%E5%85%B7/etcdctl%20user%20%E5%91%BD%E4%BB%A4.md">etcdctl user 命令&lt;/a>&lt;/p>
&lt;h2 id="role--etcd-的-role-相关的命令">role # etcd 的 role 相关的命令&lt;/h2>
&lt;p>role add # Adds a new role&lt;/p>
&lt;p>role delete # Deletes a role&lt;/p>
&lt;p>role get # Gets detailed information of a role&lt;/p>
&lt;p>role list # Lists all roles&lt;/p>
&lt;p>role grant-permission # Grants a key to a role&lt;/p>
&lt;p>role revoke-permission # Revokes a key from a role&lt;/p>
&lt;p>watch Watches events stream on keys or prefixes&lt;/p></description></item><item><title>Docs: EXT FileSystem</title><link>https://desistdaydream.github.io/docs/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2.Kernel%E5%86%85%E6%A0%B8/6.File-System-%E7%AE%A1%E7%90%86/%E7%A3%81%E7%9B%98%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/EXT-FileSystem/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2.Kernel%E5%86%85%E6%A0%B8/6.File-System-%E7%AE%A1%E7%90%86/%E7%A3%81%E7%9B%98%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/EXT-FileSystem/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://mp.weixin.qq.com/s/qJdoXTv_XS_4ts9YuzMNIw">公众号，小林 coding-一口气搞懂「文件系统」，就靠这 25 张图了&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.junmajinlong.com/linux/ext_filesystem/">骏马金龙，第4章 ext文件系统机制原理剖析&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>硬盘最底层的读写 IO 一次是一个扇区 512 字节，如果要读写大量文件，以扇区为单位肯定很慢很消耗性能，所以硬盘使用了一个称作逻辑块的概念。逻辑块是逻辑的，由磁盘驱动器负责维护和操作，它并非是像扇区一样物理划分的。一个逻辑块的大小可能包含一个或多个扇区，每个逻辑块都有唯一的地址，称为 LBA。有了逻辑块之后，磁盘控制器对数据的操作就以逻辑块为单位，一次读写一个逻辑块，磁盘控制器知道如何将逻辑块翻译成对应的扇区并读写数据。&lt;/p>
&lt;p>到了 Linux 操作系统层次，通过文件系统提供了一个也称为块的读写单元，文件系统数据块的大小一般为 1024bytes (1KiB) 或 2048bytes (2KiB) 或 4096bytes (4KiB)。文件系统数据块也是逻辑概念，是文件系统层次维护的，而磁盘上的逻辑数据块是由磁盘控制器维护的，文件系统的 IO 管理器知道如何将它的数据块翻译成磁盘维护的数据块地址 LBA。&lt;/p>
&lt;p>对于使用文件系统的 IO 操作来说，比如读写文件，这些 &lt;strong>IO 的基本单元&lt;/strong>是&lt;strong>文件系统上的数据块&lt;/strong>，一次读写一个文件系统数据块。比如需要读一个或多个块时，文件系统的 IO 管理器首先计算这些文件系统块对应在哪些磁盘数据块，也就是计算出 LBA，然后通知磁盘控制器要读取哪些块的数据，硬盘控制器将这些块翻译成扇区地址，然后从扇区中读取数据，再通过硬盘控制器将这些扇区数据重组写入到内存中去。&lt;/p>
&lt;p>&lt;strong>Block(块)&lt;/strong>，存放数据的最小单位，假如每个块为 4KiB，那大于 5KiB 的块就需要两个块，并且逻辑上占用了 8KiB 的空间。&lt;/p>
&lt;p>&lt;strong>Block Group(块组)&lt;/strong>，多个 Block 的集合&lt;/p>
&lt;p>Ext 预留了一些 Inode 做特殊特性使用，如下：某些可能并非总是准确，具体的 inode 号对应什么文件可以使用 &lt;code>find /-inum NUM&lt;/code> 查看&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>Ext4的特殊inode
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Inode号 用途
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">0&lt;/span> 不存在0号inode，可用于标识目录data block中已删除的文件
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">1&lt;/span> 虚拟文件系统，如/proc和/sys
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">2&lt;/span> 根目录 &lt;span style="color:#75715e"># 注意此行&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">3&lt;/span> ACL索引
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">4&lt;/span> ACL数据
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">5&lt;/span> Boot loader
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">6&lt;/span> 未删除的目录
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">7&lt;/span> 预留的块组描述符inode
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">8&lt;/span> 日志inode
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">11&lt;/span> 第一个非预留的inode，通常是 lost+found 目录
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>所以在 ext4 文件系统的 dumpe2fs 信息中，能观察到 fisrt inode 号可能为 11 也可能为 12。&lt;/p>
&lt;h2 id="块块组inode-计算">块、块组、Inode 计算&lt;/h2>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>参考哪里？我也想知道真实的计算逻辑。。。&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>这些计算的结果通常与下列设置有关&lt;/p>
&lt;ul>
&lt;li>&lt;strong>DiskSize&lt;/strong> # 磁盘空间&lt;/li>
&lt;li>&lt;strong>BlockSize&lt;/strong> # 通常为 4096 Bytes
&lt;ul>
&lt;li>可使用 mke2fs -b 手动指定&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>BlocksPerGroup&lt;/strong> # 通常为 32768。每个块组中块的数量。
&lt;ul>
&lt;li>可使用 mke2fs -g 手动指定&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>BytesPerInode&lt;/strong> # 通常为 16384 Bytes。创建文件系统时，为每块 BytesPerInode 大小的空间创建一个 Inode。
&lt;ul>
&lt;li>BytesPerInode 也称为 inode_ratio，即.Inode 比率，全称应该是 Inode 分配比率，即每多少空间分配一个 Inode。&lt;/li>
&lt;li>可使用 mke2fs -i 手动指定&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>InodeSize&lt;/strong> # 通常为 256 Bytes。大小是 128 的倍数，最小为 128 Bytes。&lt;/li>
&lt;/ul>
&lt;p>其中 BlocksPerGroup(每个块组中块的数量)、BytesPerInode(每个Inode负责的空间大小) 这种值是后续计算的基础。固定下来这些，就算分区空间自动扩容/缩容，也可以根据这种数据自动增加/删除块的数量和 Inode 的数量。&lt;/p>
&lt;p>其中块大小为 4K，Inode 比率为 16K，也就是说，至少每 4 个块分配一个 Inode。当然分配的这些 inode 号只是预分配，并不真的代表会全部使用，毕竟每个文件才会分配一个 inode 号。&lt;/p>
&lt;p>这些数据将会计算出：&lt;/p>
&lt;ul>
&lt;li>&lt;strong>BlockCount&lt;/strong> # 块总数&lt;/li>
&lt;li>&lt;strong>BlockGroup&lt;/strong> # 块组总数&lt;/li>
&lt;li>&lt;strong>InodeCount&lt;/strong> # Inode 总数&lt;/li>
&lt;li>&lt;strong>InodePreGroup&lt;/strong> # 每个块组中包含的 Inode 数量&lt;/li>
&lt;li>&lt;strong>InodeUseage&lt;/strong> # 所有 Inode 占用的空间&lt;/li>
&lt;/ul>
&lt;p>假如现在有一块 35GiB 的磁盘，需要先转为 Bytes。然后根据给定的 BlockSize(块大小) 和 BlocksPerGroup(块组中块的数量)，计算出需要创建创建的&lt;strong>块数量&lt;/strong>和&lt;strong>块组数量&lt;/strong>。&lt;/p>
&lt;p>&lt;strong>Block 与 BlockGroup 的计算&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>BlockCount = DiskSize / BlockSize = 37580963840 / 4096 = 9175040&lt;/li>
&lt;li>BlockGroupCount = BlockCount / BlocksPerGroup = 9175040 / 32768 = 280&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>Inode 的计算&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>InodeCount = DiskSize / BytesPerInode = 37580963840 / 16384 = 2293760&lt;/li>
&lt;/ul>
&lt;blockquote>
&lt;p>由于之前已经知道了“每4个块分配一个Inode”，那么用“总块数/4”也是可以得到这个 Inode 总数的。&lt;/p>
&lt;/blockquote>
&lt;p>计算出的 Inode 数量将会平均分配到每个块组中&lt;/p>
&lt;ul>
&lt;li>InodePreGroup = InodeCount / BlockGroupCount = 2293760 / 280 = 8192&lt;/li>
&lt;/ul>
&lt;blockquote>
&lt;p>由于之前已经知道了“每4个块分配一个Inode”，那么用“每个块组中块的数量/4”也是可以得到每个块组中 Inode 的数量。&lt;/p>
&lt;/blockquote>
&lt;p>计算所有 Inode 需要占用的磁盘空间&lt;/p>
&lt;ul>
&lt;li>InodeUseage = InodeCount * InodeSize = 2293760 * 256 = 587202560 Bytes = 560 MiB&lt;/li>
&lt;/ul>
&lt;p>也就是说，一块 35 G 的硬盘，需要拿出来至少 560 MiB 的空间来存放 Inode 数据。&lt;/p>
&lt;p>&lt;strong>TODO:&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>&lt;strong>Inode 还有一个最低数量？就算执行 &lt;code>mke2fs -N 1&lt;/code> 命令，最后也不会只有一个 Inode，而是有 4480 个 Inode，这个数是怎么来的？&lt;/strong>&lt;/li>
&lt;li>**试了下 &lt;code>mke2fs -N 1000000&lt;/code> 最后生成的 Inode 数为 1003520，正好是 4480 的倍数&lt;/li>
&lt;li>&lt;strong>如果是 &lt;code>mke2fs -N 4481&lt;/code>，则生成的 Inode 数为 8960，也是 4480 的倍数。。。这个值到底咋来的。。。o(╯□╰)o&lt;/strong>**&lt;/li>
&lt;li>好像是根据 Inodes per group 的值来的，这个值好像必须要是 16 的倍数，并且最低值是 16，可是这个说法的来源是在哪呢？&lt;/li>
&lt;/ul>
&lt;p>上述计算的结果可以通过 dumpe2fs 命令查看&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>~&lt;span style="color:#f92672">]&lt;/span>&lt;span style="color:#75715e"># dumpe2fs -h ${DEVICE} | egrep -i &amp;#34;block|inode&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>dumpe2fs 1.45.5 &lt;span style="color:#f92672">(&lt;/span>07-Jan-2020&lt;span style="color:#f92672">)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Filesystem features: ext_attr resize_inode dir_index filetype sparse_super large_file
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Inode count: &lt;span style="color:#ae81ff">2293760&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Block count: &lt;span style="color:#ae81ff">9175040&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Reserved block count: &lt;span style="color:#ae81ff">458752&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Free blocks: &lt;span style="color:#ae81ff">9018814&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Free inodes: &lt;span style="color:#ae81ff">2293749&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>First block: &lt;span style="color:#ae81ff">0&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Block size: &lt;span style="color:#ae81ff">4096&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Reserved GDT blocks: &lt;span style="color:#ae81ff">1021&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Blocks per group: &lt;span style="color:#ae81ff">32768&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Inodes per group: &lt;span style="color:#ae81ff">8192&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Inode blocks per group: &lt;span style="color:#ae81ff">512&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Reserved blocks uid: &lt;span style="color:#ae81ff">0&lt;/span> &lt;span style="color:#f92672">(&lt;/span>user root&lt;span style="color:#f92672">)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Reserved blocks gid: &lt;span style="color:#ae81ff">0&lt;/span> &lt;span style="color:#f92672">(&lt;/span>group root&lt;span style="color:#f92672">)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>First inode: &lt;span style="color:#ae81ff">11&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Inode size: &lt;span style="color:#ae81ff">256&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="todo-最低的-inode">TODO: 最低的 Inode&lt;/h3>
&lt;p>假如我们需要最少 1 个 Inode&lt;/p>
&lt;p>此时已知&lt;/p>
&lt;ul>
&lt;li>BlockCount = 9175040&lt;/li>
&lt;li>BlockGroupCount = 280&lt;/li>
&lt;li>BlockSize = 4096 Bytes&lt;/li>
&lt;li>InodeSize = 256 Bytes&lt;/li>
&lt;li>InodeRatio = 16384 Bytes&lt;/li>
&lt;/ul>
&lt;p>每 4 个块给 1 个 Inode，但肯定不是这个思路，因为照着这种算法，那就是有 2293760 个。所以肯定不是每 4 个块给 1 个 Inode。&lt;/p>
&lt;p>真实场景：&lt;/p>
&lt;ul>
&lt;li>现在是每 2048 个块给 一个 Inode&lt;/li>
&lt;li>280 个块组&lt;/li>
&lt;li>&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>~&lt;span style="color:#f92672">]&lt;/span>&lt;span style="color:#75715e"># mke2fs -N 1 /dev/vdb&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>mke2fs 1.45.5 &lt;span style="color:#f92672">(&lt;/span>07-Jan-2020&lt;span style="color:#f92672">)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>/dev/vdb contains a ext2 file system
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> last mounted on Sat Mar &lt;span style="color:#ae81ff">11&lt;/span> 16:14:14 &lt;span style="color:#ae81ff">2023&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Proceed anyway? &lt;span style="color:#f92672">(&lt;/span>y,N&lt;span style="color:#f92672">)&lt;/span> y
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Creating filesystem with &lt;span style="color:#ae81ff">9175040&lt;/span> 4k blocks and &lt;span style="color:#ae81ff">4480&lt;/span> inodes
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Filesystem UUID: acebc9ab-c53e-4f74-bd6b-443343a76bab
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Superblock backups stored on blocks:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> 32768, 98304, 163840, 229376, 294912, 819200, 884736, 1605632, 2654208,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> 4096000, &lt;span style="color:#ae81ff">7962624&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Allocating group tables: &lt;span style="color:#66d9ef">done&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Writing inode tables: &lt;span style="color:#66d9ef">done&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Writing superblocks and filesystem accounting information: &lt;span style="color:#66d9ef">done&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>~&lt;span style="color:#f92672">]&lt;/span>&lt;span style="color:#75715e"># dumpe2fs -h ${DEVICE} | egrep -i &amp;#34;block|inode&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>dumpe2fs 1.45.5 &lt;span style="color:#f92672">(&lt;/span>07-Jan-2020&lt;span style="color:#f92672">)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Filesystem features: ext_attr resize_inode dir_index filetype sparse_super large_file
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Inode count: &lt;span style="color:#ae81ff">4480&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Block count: &lt;span style="color:#ae81ff">9175040&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Reserved block count: &lt;span style="color:#ae81ff">458752&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Free blocks: &lt;span style="color:#ae81ff">9161894&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Free inodes: &lt;span style="color:#ae81ff">4469&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>First block: &lt;span style="color:#ae81ff">0&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Block size: &lt;span style="color:#ae81ff">4096&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Reserved GDT blocks: &lt;span style="color:#ae81ff">1021&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Blocks per group: &lt;span style="color:#ae81ff">32768&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Inodes per group: &lt;span style="color:#ae81ff">16&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Inode blocks per group: &lt;span style="color:#ae81ff">1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Reserved blocks uid: &lt;span style="color:#ae81ff">0&lt;/span> &lt;span style="color:#f92672">(&lt;/span>user root&lt;span style="color:#f92672">)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Reserved blocks gid: &lt;span style="color:#ae81ff">0&lt;/span> &lt;span style="color:#f92672">(&lt;/span>group root&lt;span style="color:#f92672">)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>First inode: &lt;span style="color:#ae81ff">11&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Inode size: &lt;span style="color:#ae81ff">256&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h1 id="文件的存储">文件的存储&lt;/h1>
&lt;p>文件的数据是要存储在硬盘上面的，数据在磁盘上的存放方式，就像程序在内存中存放的方式那样，有以下两种：&lt;/p>
&lt;ul>
&lt;li>连续空间存放方式&lt;/li>
&lt;li>非连续空间存放方式&lt;/li>
&lt;/ul>
&lt;p>其中，非连续空间存放方式又可以分为「链表方式」和「索引方式」。
不同的存储方式，有各自的特点，重点是要分析它们的存储效率和读写性能，接下来分别对每种存储方式说一下。&lt;/p>
&lt;h2 id="连续空间存放方式">连续空间存放方式&lt;/h2>
&lt;blockquote>
&lt;p>注意：这里只针对机械硬盘，固态硬盘并没有磁道等概念&lt;/p>
&lt;/blockquote>
&lt;p>连续空间存放方式顾名思义，&lt;strong>文件存放在磁盘「连续的」物理空间中&lt;/strong>。这种模式下，文件的数据都是紧密相连，&lt;strong>读写效率很高&lt;/strong>，因为一次磁盘寻道就可以读出整个文件。&lt;/p>
&lt;p>使用连续存放的方式有一个前提，必须先知道一个文件的大小，这样文件系统才会根据文件的大小在磁盘上找到一块连续的空间分配给文件。&lt;/p>
&lt;p>所以，&lt;strong>文件头里需要指定「起始块的位置」和「长度」&lt;/strong>，有了这两个信息就可以很好的表示文件存放方式是一块连续的磁盘空间。&lt;/p>
&lt;p>注意，此处说的文件头，就类似于 Linux 的 inode。&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/op2fw9/1616167677049-26c7ae42-9e37-426a-99f9-6e59df62e691.png" alt="">&lt;/p>
&lt;p>连续空间存放的方式虽然读写效率高，&lt;strong>但是有「磁盘空间碎片」和「文件长度不易扩展」的缺陷。&lt;/strong>&lt;/p>
&lt;p>如下图，如果文件 B 被删除，磁盘上就留下一块空缺，这时，如果新来的文件小于其中的一个空缺，我们就可以将其放在相应空缺里。但如果该文件的大小大于所有的空缺，但却小于空缺大小之和，则虽然磁盘上有足够的空缺，但该文件还是不能存放。当然了，我们可以通过将现有文件进行挪动来腾出空间以容纳新的文件，但是这个在磁盘挪动文件是非常耗时，所以这种方式不太现实。&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/op2fw9/1616167677046-4fd1191e-4e74-4653-8ef4-24ba781c4f57.png" alt="">&lt;/p>
&lt;p>另外一个缺陷是文件长度扩展不方便，例如上图中的文件 A 要想扩大一下，需要更多的磁盘空间，唯一的办法就只能是挪动的方式，前面也说了，这种方式效率是非常低的。
那么有没有更好的方式来解决上面的问题呢？答案当然有，既然连续空间存放的方式不太行，那么我们就改变存放的方式，使用非连续空间存放方式来解决这些缺陷。&lt;/p>
&lt;h2 id="非连续空间存放方式">非连续空间存放方式&lt;/h2>
&lt;p>非连续空间存放方式分为「链表方式」和「索引方式」。&lt;/p>
&lt;blockquote>
&lt;p>我们先来看看链表的方式。&lt;/p>
&lt;/blockquote>
&lt;p>链表的方式存放是&lt;strong>离散的，不用连续的&lt;/strong>，于是就可以&lt;strong>消除磁盘碎片&lt;/strong>，可大大提高磁盘空间的利用率，同时&lt;strong>文件的长度可以动态扩展&lt;/strong>。根据实现的方式的不同，链表可分为「&lt;strong>隐式链表&lt;/strong>」和「&lt;strong>显式链接&lt;/strong>」两种形式。&lt;/p>
&lt;p>文件要以「&lt;strong>隐式链表&lt;/strong>」的方式存放的话，&lt;strong>实现的方式是文件头要包含「第一块」和「最后一块」的位置，并且每个数据块里面留出一个指针空间，用来存放下一个数据块的位置&lt;/strong>，这样一个数据块连着一个数据块，从链头开是就可以顺着指针找到所有的数据块，所以存放的方式可以是不连续的。
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/op2fw9/1616167677039-c71df217-651d-42ac-8cf6-444dedae8c1c.png" alt="">
隐式链表的存放方式的&lt;strong>缺点在于无法直接访问数据块，只能通过指针顺序访问文件，以及数据块指针消耗了一定的存储空间&lt;/strong>。隐式链接分配的&lt;strong>稳定性较差&lt;/strong>，系统在运行过程中由于软件或者硬件错误&lt;strong>导致链表中的指针丢失或损坏，会导致文件数据的丢失。&lt;/strong>&lt;/p>
&lt;p>如果取出每个磁盘块的指针，把它放在内存的一个表中，就可以解决上述隐式链表的两个不足。那么，这种实现方式是「&lt;strong>显式链接&lt;/strong>」，它指&lt;strong>把用于链接文件各数据块的指针，显式地存放在内存的一张链接表中&lt;/strong>，该表在整个磁盘仅设置一张，&lt;strong>每个表项中存放链接指针，指向下一个数据块号&lt;/strong>。&lt;/p>
&lt;p>对于显式链接的工作方式，我们举个例子，文件 A 依次使用了磁盘块 4、7、2、10 和 12 ，文件 B 依次使用了磁盘块 6、3、11 和 14 。利用下图中的表，可以从第 4 块开始，顺着链走到最后，找到文件 A 的全部磁盘块。同样，从第 6 块开始，顺着链走到最后，也能够找出文件 B 的全部磁盘块。最后，这两个链都以一个不属于有效磁盘编号的特殊标记（如 -1 ）结束。内存中的这样一个表格称为&lt;strong>文件分配表（File Allocation Table，FAT）&lt;/strong>。&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/op2fw9/1616167677063-b7bb2a32-dde6-4c17-9119-096413902ae8.png" alt="">&lt;/p>
&lt;p>由于查找记录的过程是在内存中进行的，因而不仅显著地&lt;strong>提高了检索速度&lt;/strong>，而且&lt;strong>大大减少了访问磁盘的次数&lt;/strong>。但也正是整个表都存放在内存中的关系，它的主要的缺点是**不适用于大磁盘**。&lt;/p>
&lt;p>比如，对于 200GB 的磁盘和 1KB 大小的块，这张表需要有 2 亿项，每一项对应于这 2 亿个磁盘块中的一个块，每项如果需要 4 个字节，那这张表要占用 800MB 内存，很显然 FAT 方案对于大磁盘而言不太合适。&lt;/p>
&lt;blockquote>
&lt;p>接下来，我们来看看索引的方式。&lt;/p>
&lt;/blockquote>
&lt;p>链表的方式解决了连续分配的磁盘碎片和文件动态扩展的问题，但是不能有效支持直接访问（FAT 除外），索引的方式可以解决这个问题。
索引的实现是为每个文件创建一个「&lt;strong>索引数据块&lt;/strong>」，里面存放的是&lt;strong>指向文件数据块的指针列表&lt;/strong>，说白了就像书的目录一样，要找哪个章节的内容，看目录查就可以。&lt;/p>
&lt;p>另外，&lt;strong>文件头需要包含指向「索引数据块」的指针&lt;/strong>，这样就可以通过文件头知道索引数据块的位置，再通过索引数据块里的索引信息找到对应的数据块。
创建文件时，索引块的所有指针都设为空。当首次写入第 i 块时，先从空闲空间中取得一个块，再将其地址写到索引块的第 i 个条目。&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/op2fw9/1616167677054-825db739-3c6c-4fec-bb21-1dd52effb539.png" alt="">&lt;/p>
&lt;p>索引的方式优点在于：&lt;/p>
&lt;ul>
&lt;li>文件的创建、增大、缩小很方便；&lt;/li>
&lt;li>不会有碎片的问题；&lt;/li>
&lt;li>支持顺序读写和随机读写；&lt;/li>
&lt;/ul>
&lt;p>由于索引数据也是存放在磁盘块的，如果文件很小，明明只需一块就可以存放的下，但还是需要额外分配一块来存放索引数据，所以缺陷之一就是存储索引带来的开销。&lt;/p>
&lt;p>如果文件很大，大到一个索引数据块放不下索引信息，这时又要如何处理大文件的存放呢？我们可以通过组合的方式，来处理大文件的存。&lt;/p>
&lt;p>先来看看链表 + 索引的组合，这种组合称为「&lt;strong>链式索引块&lt;/strong>」，它的实现方式是&lt;strong>在索引数据块留出一个存放下一个索引数据块的指针&lt;/strong>，于是当一个索引数据块的索引信息用完了，就可以通过指针的方式，找到下一个索引数据块的信息。那这种方式也会出现前面提到的链表方式的问题，万一某个指针损坏了，后面的数据也就会无法读取了。&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/op2fw9/1616167677072-417dcaa4-348d-4a45-b9b0-aa170d0f3bd7.png" alt="">&lt;/p>
&lt;p>还有另外一种组合方式是索引 + 索引的方式，这种组合称为「&lt;strong>多级索引块&lt;/strong>」，实现方式是&lt;strong>通过一个索引块来存放多个索引数据块&lt;/strong>，一层套一层索引，像极了俄罗斯套娃是吧。&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/op2fw9/1616167677056-ecb3b996-c14c-455d-82aa-7ca16aeb7feb.png" alt="">&lt;/p>
&lt;h2 id="unix-文件的实现方式">Unix 文件的实现方式&lt;/h2>
&lt;p>我们先把前面提到的文件实现方式，做个比较：&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/op2fw9/1671074085764-374b9218-86e8-412d-85c7-9d051b9340b2.png" alt="image.png">&lt;/p>
&lt;p>那早期 Unix 文件系统是组合了前面的文件存放方式的优点，如下图：&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/op2fw9/1616167677095-e05fe455-c302-43bb-a9d8-dd43cd4551e1.png" alt="">&lt;/p>
&lt;p>它是根据文件的大小，存放的方式会有所变化：&lt;/p>
&lt;ul>
&lt;li>如果存放文件所需的数据块小于 10 块，则采用直接查找的方式；&lt;/li>
&lt;li>如果存放文件所需的数据块超过 10 块，则采用一级间接索引方式；&lt;/li>
&lt;li>如果前面两种方式都不够存放大文件，则采用二级间接索引方式；&lt;/li>
&lt;li>如果二级间接索引也不够存放大文件，这采用三级间接索引方式；&lt;/li>
&lt;/ul>
&lt;p>那么，文件头（&lt;em>Inode&lt;/em>）就需要包含 13 个指针：&lt;/p>
&lt;ul>
&lt;li>第 10 个指向数据块的指针；&lt;/li>
&lt;li>第 11 个指向索引块的指针；&lt;/li>
&lt;li>第 12 个指向二级索引块的指针；&lt;/li>
&lt;li>第 13 个指向三级索引块的指针；&lt;/li>
&lt;/ul>
&lt;p>所以，这种方式能很灵活地支持小文件和大文件的存放：&lt;/p>
&lt;ul>
&lt;li>对于小文件使用直接查找的方式可减少索引数据块的开销；&lt;/li>
&lt;li>对于大文件则以多级索引的方式来支持，所以大文件在访问数据块时需要大量查询；&lt;/li>
&lt;/ul>
&lt;p>这个方案就用在了 Linux Ext 2/3 文件系统里，虽然解决大文件的存储，但是对于大文件的访问，需要大量的查询，效率比较低。&lt;/p>
&lt;p>为了解决这个问题，Ext 4 做了一定的改变，具体怎么解决的，本文就不展开了。&lt;/p>
&lt;h1 id="空闲空间管理">空闲空间管理&lt;/h1>
&lt;p>前面说到的文件的存储是针对已经被占用的数据块组织和管理，接下来的问题是，如果我要保存一个数据块，我应该放在硬盘上的哪个位置呢？难道需要将所有的块扫描一遍，找个空的地方随便放吗？&lt;/p>
&lt;p>那这种方式效率就太低了，所以针对磁盘的空闲空间也是要引入管理的机制，接下来介绍几种常见的方法：&lt;/p>
&lt;ul>
&lt;li>空闲表法&lt;/li>
&lt;li>空闲链表法&lt;/li>
&lt;li>位图法&lt;/li>
&lt;/ul>
&lt;h2 id="空闲表法">空闲表法&lt;/h2>
&lt;p>空闲表法就是为所有空闲空间建立一张表，表内容包括空闲区的第一个块号和该空闲区的块个数，注意，这个方式是连续分配的。如下图：
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/op2fw9/1616167677079-9e2989d6-2cda-4460-80ca-f3c0f28783f1.png" alt="">
当请求分配磁盘空间时，系统依次扫描空闲表里的内容，直到找到一个合适的空闲区域为止。当用户撤销一个文件时，系统回收文件空间。这时，也需顺序扫描空闲表，寻找一个空闲表条目并将释放空间的第一个物理块号及它占用的块数填到这个条目中。
这种方法仅当有少量的空闲区时才有较好的效果。因为，如果存储空间中有着大量的小的空闲区，则空闲表变得很大，这样查询效率会很低。另外，这种分配技术适用于建立连续文件。&lt;/p>
&lt;h2 id="空闲链表法">空闲链表法&lt;/h2>
&lt;p>我们也可以使用「链表」的方式来管理空闲空间，每一个空闲块里有一个指针指向下一个空闲块，这样也能很方便的找到空闲块并管理起来。如下图：
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/op2fw9/1616167677070-be98384a-ad4f-4a20-b5da-1d969816b938.png" alt="">
当创建文件需要一块或几块时，就从链头上依次取下一块或几块。反之，当回收空间时，把这些空闲块依次接到链头上。&lt;/p>
&lt;p>这种技术只要在主存中保存一个指针，令它指向第一个空闲块。其特点是简单，但不能随机访问，工作效率低，因为每当在链上增加或移动空闲块时需要做很多 I/O 操作，同时数据块的指针消耗了一定的存储空间。&lt;/p>
&lt;p>空闲表法和空闲链表法都不适合用于大型文件系统，因为这会使空闲表或空闲链表太大。&lt;/p>
&lt;h2 id="位图法">位图法&lt;/h2>
&lt;p>位图是利用二进制的一位来表示磁盘中一个盘块的使用情况，磁盘上所有的盘块都有一个二进制位与之对应。&lt;/p>
&lt;p>当值为 0 时，表示对应的盘块空闲，值为 1 时，表示对应的盘块已分配。它形式如下：&lt;/p>
&lt;pre>&lt;code>1111110011111110001110110111111100111 ...
&lt;/code>&lt;/pre>
&lt;p>在 Linux 文件系统就采用了位图的方式来管理空闲空间，不仅用于数据空闲块的管理，还用于 inode 空闲块的管理，因为 inode 也是存储在磁盘的，自然也要有对其管理。&lt;/p>
&lt;h1 id="文件系统的结构">文件系统的结构&lt;/h1>
&lt;p>前面提到 Linux 是用位图的方式管理空闲空间，用户在创建一个新文件时，Linux 内核会通过 inode 的位图找到空闲可用的 inode，并进行分配。要存储数据时，会通过块的位图找到空闲的块，并分配，但仔细计算一下还是有问题的。&lt;/p>
&lt;p>数据块的位图是放在磁盘块里的，假设是放在一个块里，一个块 4K，每位表示一个数据块，共可以表示 &lt;code>4 * 1024 * 8 = 2^15&lt;/code> 个空闲块，由于 1 个数据块是 4K 大小，那么最大可以表示的空间为 &lt;code>2^15 * 4 * 1024 = 2^27&lt;/code> 个 byte，也就是 128M。&lt;/p>
&lt;p>也就是说按照上面的结构，如果采用「一个块的位图 + 一系列的块」，外加「一个块的 inode 的位图 + 一系列的 inode 的结构」能表示的最大空间也就 128M，这太少了，现在很多文件都比这个大。&lt;/p>
&lt;p>在 Linux 文件系统，把这个结构称为一个&lt;strong>块组&lt;/strong>，那么有 N 多的块组，就能够表示 N 大的文件。&lt;/p>
&lt;p>下图给出了 Linux Ext2 整个文件系统的结构和块组的内容，文件系统都由大量块组组成，在硬盘上相继排布：&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/op2fw9/1616167677099-7ffa20c4-57d9-4c49-9e02-24afef066cfb.png" alt="">&lt;/p>
&lt;p>最前面的第一个块是引导块，在系统启动时用于启用引导，接着后面就是一个一个连续的块组了，块组的内容如下：&lt;/p>
&lt;ul>
&lt;li>&lt;strong>超级块&lt;/strong> # 包含的是文件系统的重要信息，比如 inode 总个数、块总个数、每个块组的 inode 个数、每个块组的块个数等等。&lt;/li>
&lt;li>&lt;strong>块组描述符&lt;/strong> # 包含文件系统中各个块组的状态，比如块组中空闲块和 inode 的数目等，每个块组都包含了文件系统中「所有块组的组描述符信息」。&lt;/li>
&lt;li>&lt;strong>数据位图和 inode 位图&lt;/strong> # 用于表示对应的数据块或 inode 是空闲的，还是被使用中。&lt;/li>
&lt;li>&lt;strong>inode 列表&lt;/strong> # 包含了块组中所有的 inode，inode 用于保存文件系统中与各个文件和目录相关的所有元数据。&lt;/li>
&lt;li>&lt;strong>数据块&lt;/strong> # 包含文件的有用数据。&lt;/li>
&lt;/ul>
&lt;p>你可以会发现每个块组里有很多重复的信息，比如&lt;strong>超级块和块组描述符表，这两个都是全局信息，而且非常的重要&lt;/strong>，这么做是有两个原因：&lt;/p>
&lt;ul>
&lt;li>如果系统崩溃破坏了超级块或块组描述符，有关文件系统结构和内容的所有信息都会丢失。如果有冗余的副本，该信息是可能恢复的。&lt;/li>
&lt;li>通过使文件和管理数据尽可能接近，减少了磁头寻道和旋转，这可以提高文件系统的性能。&lt;/li>
&lt;/ul>
&lt;p>不过，Ext2 的后续版本采用了&lt;strong>稀疏技术&lt;/strong>。该做法是，超级块和块组描述符表不再存储到文件系统的每个块组中，而是只写入到块组 0、块组 1 和其他 ID 可以表示为 3、 5、7 的幂的块组中。&lt;/p>
&lt;p>在创建文件系统时，也可以看到 &lt;code>Superblock backups stored on blocks&lt;/code> 这种描述，这记录了超级块的备份存在哪些块中&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>~&lt;span style="color:#f92672">]&lt;/span>&lt;span style="color:#75715e"># mke2fs -N 10000000 /dev/vdb&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>mke2fs 1.45.5 &lt;span style="color:#f92672">(&lt;/span>07-Jan-2020&lt;span style="color:#f92672">)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>/dev/vdb contains a ext2 file system
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> created on Sat Mar &lt;span style="color:#ae81ff">11&lt;/span> 12:25:22 &lt;span style="color:#ae81ff">2023&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Proceed anyway? &lt;span style="color:#f92672">(&lt;/span>y,N&lt;span style="color:#f92672">)&lt;/span> y
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Creating filesystem with &lt;span style="color:#ae81ff">9175040&lt;/span> 4k blocks and &lt;span style="color:#ae81ff">10002528&lt;/span> inodes
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Filesystem UUID: 8acc177c-5f26-4bb9-a0ee-01ceb61d4eaa
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Superblock backups stored on blocks:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> 30072, 90216, 150360, 210504, 270648, 751800, 811944, 1473528, 2435832,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> 3759000, &lt;span style="color:#ae81ff">7307496&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Allocating group tables: &lt;span style="color:#66d9ef">done&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Writing inode tables: &lt;span style="color:#66d9ef">done&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Writing superblocks and filesystem accounting information: &lt;span style="color:#66d9ef">done&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div></description></item><item><title>Docs: File System 管理</title><link>https://desistdaydream.github.io/docs/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Y.Windows-%E7%AE%A1%E7%90%86/File-System-%E7%AE%A1%E7%90%86/File-System-%E7%AE%A1%E7%90%86/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Y.Windows-%E7%AE%A1%E7%90%86/File-System-%E7%AE%A1%E7%90%86/File-System-%E7%AE%A1%E7%90%86/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://www.howtogeek.com/318177/what-is-the-appdata-folder-in-windows/">https://www.howtogeek.com/318177/what-is-the-appdata-folder-in-windows/&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>&lt;strong>$USERPROFILE/AppData/&lt;/strong> #&lt;/p>
&lt;ul>
&lt;li>&lt;strong>./Local/&lt;/strong> #&lt;/li>
&lt;li>&lt;strong>./LocalLow/&lt;/strong> #&lt;/li>
&lt;li>&lt;strong>./Roaming/&lt;/strong> #&lt;/li>
&lt;/ul>
&lt;p>刚装完的 win10 专业版，用户的 AppData 中将会有如下结构：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-powershell" data-lang="powershell">&lt;span style="display:flex;">&lt;span>$USERPROFILE/AppData/Local
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>$USERPROFILE/AppData/LocalLow
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>$USERPROFILE/AppData/Roaming
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>$USERPROFILE/AppData/Local/Comms
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>$USERPROFILE/AppData/Local/ConnectedDevicesPlatform
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>$USERPROFILE/AppData/Local/D3DSCache
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>$USERPROFILE/AppData/Local/Microsoft
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>$USERPROFILE/AppData/Local/Packages
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>$USERPROFILE/AppData/Local/Temp
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>$USERPROFILE/AppData/LocalLow/Microsoft
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>$USERPROFILE/AppData/LocalLow/MSLiveStickerWhiteList
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>$USERPROFILE/AppData/Roaming/Adobe
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>$USERPROFILE/AppData/Roaming/Microsoft
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>最主要的是这三个目录下的 Microsfot 目录，还有 Packages 目录。在整理 AppData 时，不要误删了。&lt;/p>
&lt;h1 id="program-files">Program Files&lt;/h1>
&lt;p>该目录存储安装在计算机上的大多数应用程序的执行文件。&lt;/p>
&lt;h1 id="program-filesx86">Program Files(x86)&lt;/h1>
&lt;p>该目录存储在 64 位 Windows 系统上安装的 32 位应用程序的执行文件。&lt;/p>
&lt;h1 id="programdata">ProgramData&lt;/h1>
&lt;p>该目录存储全局数据，包括应用程序的配置文件，以及系统的安装和更新信息。&lt;/p>
&lt;h1 id="users">Users&lt;/h1>
&lt;p>该目录存储在 Windows 系统上创建的每个用户的个人文件夹，如桌面、文档和图片。&lt;/p>
&lt;h1 id="windows">Windows&lt;/h1>
&lt;p>Windows 操作系统的核心文件和 DLL 文件都存储在此目录中。&lt;/p>
&lt;p>&lt;strong>./System32/&lt;/strong> # 类似于 Linux 中的 /usr/sbin/ 目录，系统自带的命令、服务、msc 的可执行文件都在这里。&lt;/p></description></item><item><title>Docs: firewalld(Iptables 的管理工具)</title><link>https://desistdaydream.github.io/docs/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2.Kernel%E5%86%85%E6%A0%B8/8.Network-%E7%AE%A1%E7%90%86/Linux-%E7%BD%91%E7%BB%9C%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6/Netfilter-%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6%E7%B3%BB%E7%BB%9F/firewalldIptables-%E7%9A%84%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/firewalldIptables-%E7%9A%84%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2.Kernel%E5%86%85%E6%A0%B8/8.Network-%E7%AE%A1%E7%90%86/Linux-%E7%BD%91%E7%BB%9C%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6/Netfilter-%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6%E7%B3%BB%E7%BB%9F/firewalldIptables-%E7%9A%84%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/firewalldIptables-%E7%9A%84%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;p>firewalld 与 iptabels 一样，是管理 Linux 内核中的 Netfilter 功能的工具。&lt;/p>
&lt;p>FirewallD 使用两个配置模式：“runtime 运行时”和“permanent 持久”。&lt;/p>
&lt;ol>
&lt;li>runtime 模式：默认模式。所有配置即时生效，在重启系统、重新启动 FirewallD 时、使用&amp;ndash;reload 重载配置等操作是，在该模式下的配置都将被清除。&lt;/li>
&lt;li>permanent 模式：需要使用 &amp;ndash;permanent 选项生效，配置才会永久保存。如果想让 permanetn 模式下的配置立即生效，需要使用&amp;ndash;reload 命令或者重启 firewalld 服务。&lt;/li>
&lt;/ol>
&lt;h2 id="firewalld-中-zone区域的概念">firewalld 中 zone(区域)的概念&lt;/h2>
&lt;p>“区域”是针对给定位置或场景（例如家庭、公共、受信任等）可能具有的各种信任级别的预构建规则集。不同的区域允许不同的网络服务和入站流量类型，而拒绝其他任何流量。 首次启用 FirewallD 后，public 将是默认区域。&lt;/p>
&lt;p>区域也可以用于不同的网络接口。例如，要分离内部网络和互联网的接口，你可以在 internal 区域上允许 DHCP，但在 external 区域仅允许 HTTP 和 SSH。未明确设置为特定区域的任何接口将添加到默认区域。&lt;/p>
&lt;p>所以，一般情况下，所有区域都是拒绝所有新的入站流量，对已经建立连接的不再阻止。在使用 firewall-cmd 命令添加某 service、port、ip 等属性时，相当于允许对应属性的流量入站。i.e.添加进去就表示允许&lt;/p>
&lt;h2 id="zone-的种类与说明">zone 的种类与说明&lt;/h2>
&lt;ol>
&lt;li>public（公共） # 默认的 zone。在公共区域内使用，不能相信网络内的其他计算机不会对您的计算机造成危害，只能接收经过选取的连接。&lt;/li>
&lt;li>block（限制） # 任何接收的网络连接都被 IPv4 的 icmp-host-prohibited 信息和 IPv6 的 icmp6-adm-prohibited 信息所拒绝。&lt;/li>
&lt;li>dmz（非军事区） # 用于您的非军事区内的电脑，此区域内可公开访问，可以有限地进入您的内部网络，仅仅接收经过选择的连接。&lt;/li>
&lt;li>drop（丢弃） # 任何接收的网络数据包都被丢弃，没有任何回复。仅能有发送出去的网络连接。&lt;/li>
&lt;li>external（外部） # 特别是为路由器启用了伪装功能的外部网。您不能信任来自网络的其他计算，不能相信它们不会对您的计算机造成危害，只能接收经过选择的连接。&lt;/li>
&lt;li>home（家庭） # 用于家庭网络。您可以基本信任网络内的其他计算机不会危害您的计算机。仅仅接收经过选择的连接。&lt;/li>
&lt;li>internal（内部） # 用于内部网络。您可以基本上信任网络内的其他计算机不会威胁您的计算机。仅仅接受经过选择的连接。&lt;/li>
&lt;li>trusted（信任） # 可接受所有的网络连接。&lt;/li>
&lt;li>work（工作） # 用于工作区。您可以基本相信网络内的其他电脑不会危害您的电脑。仅仅接收经过选择的连接。&lt;/li>
&lt;/ol>
&lt;p>用实际举例：将设备某个网卡放在区域中，则流经该网卡的流量都会遵循该区域中所定义的规则。&lt;/p>
&lt;h1 id="firewalld-关联文件与配置">Firewalld 关联文件与配置&lt;/h1>
&lt;p>/usr/lib/firewalld # 保存默认配置，如默认区域和公用服务。 避免修改它们，因为每次 firewall 软件包更新时都会覆盖这些文件。
/etc/firewalld # 保存系统配置文件。这些文件将覆盖默认配置。&lt;/p>
&lt;ul>
&lt;li>firewalld.conf #&lt;/li>
&lt;/ul>
&lt;h1 id="firewall-安装完成后的-iptables-模式的默认配置">firewall 安装完成后的 iptables 模式的默认配置&lt;/h1>
&lt;p>以下是 public 区域下 filter 表的默认配置，大部分都是对于自定义链的规则&lt;/p>
&lt;ul>
&lt;li>
&lt;h1 id="设置-3-个基本链的默认-target">设置 3 个基本链的默认 target&lt;/h1>
&lt;/li>
&lt;li>
&lt;p>-P INPUT ACCEPT&lt;/p>
&lt;/li>
&lt;li>
&lt;p>-P FORWARD ACCEPT&lt;/p>
&lt;/li>
&lt;li>
&lt;p>-P OUTPUT ACCEPT&lt;/p>
&lt;/li>
&lt;li>
&lt;h1 id="默认会创建多个自定义链">默认会创建多个自定义链&lt;/h1>
&lt;/li>
&lt;li>
&lt;p>-N FORWARD_IN_ZONES&lt;/p>
&lt;/li>
&lt;li>
&lt;p>-N FORWARD_IN_ZONES_SOURCE&lt;/p>
&lt;/li>
&lt;li>
&lt;p>-N FORWARD_OUT_ZONES&lt;/p>
&lt;/li>
&lt;li>
&lt;p>-N FORWARD_OUT_ZONES_SOURCE&lt;/p>
&lt;/li>
&lt;li>
&lt;p>-N FORWARD_direct&lt;/p>
&lt;/li>
&lt;li>
&lt;p>-N FWDI_public&lt;/p>
&lt;/li>
&lt;li>
&lt;p>-N FWDI_public_allow&lt;/p>
&lt;/li>
&lt;li>
&lt;p>-N FWDI_public_deny&lt;/p>
&lt;/li>
&lt;li>
&lt;p>-N FWDI_public_log&lt;/p>
&lt;/li>
&lt;li>
&lt;p>-N FWDO_public&lt;/p>
&lt;/li>
&lt;li>
&lt;p>-N FWDO_public_allow&lt;/p>
&lt;/li>
&lt;li>
&lt;p>-N FWDO_public_deny&lt;/p>
&lt;/li>
&lt;li>
&lt;p>-N FWDO_public_log&lt;/p>
&lt;/li>
&lt;li>
&lt;p>-N INPUT_ZONES&lt;/p>
&lt;/li>
&lt;li>
&lt;p>-N INPUT_ZONES_SOURCE&lt;/p>
&lt;/li>
&lt;li>
&lt;p>-N INPUT_direct&lt;/p>
&lt;/li>
&lt;li>
&lt;p>-N IN_public&lt;/p>
&lt;/li>
&lt;li>
&lt;p>-N IN_public_allow&lt;/p>
&lt;/li>
&lt;li>
&lt;p>-N IN_public_deny&lt;/p>
&lt;/li>
&lt;li>
&lt;p>-N IN_public_log&lt;/p>
&lt;/li>
&lt;li>
&lt;p>-N OUTPUT_direct&lt;/p>
&lt;/li>
&lt;li>
&lt;h1 id="设置-input-链基本规则所有流量直接交给-input_directinput_zones_sourceinput_zones-这-3-个自定义链来继续进行规则匹配">设置 INPUT 链基本规则，所有流量直接交给 INPUT_direct、INPUT_ZONES_SOURCE、INPUT_ZONES 这 3 个自定义链来继续进行规则匹配&lt;/h1>
&lt;/li>
&lt;li>
&lt;p>-A INPUT -m conntrack &amp;ndash;ctstate RELATED,ESTABLISHED -j ACCEPT&lt;/p>
&lt;/li>
&lt;li>
&lt;p>-A INPUT -i lo -j ACCEPT&lt;/p>
&lt;/li>
&lt;li>
&lt;p>-A INPUT -j INPUT_direct&lt;/p>
&lt;/li>
&lt;li>
&lt;p>-A INPUT -j INPUT_ZONES_SOURCE&lt;/p>
&lt;/li>
&lt;li>
&lt;p>-A INPUT -j INPUT_ZONES # 流量转给 INPUT 的 ZONES&lt;/p>
&lt;/li>
&lt;li>
&lt;p>-A INPUT -m conntrack &amp;ndash;ctstate INVALID -j DROP&lt;/p>
&lt;/li>
&lt;li>
&lt;p>-A INPUT -j REJECT &amp;ndash;reject-with icmp-host-prohibited # 在 INPUT 链上拒绝所有流量，并通过 icmp 协议提示客户端 prohibited&lt;/p>
&lt;/li>
&lt;li>
&lt;h1 id="设置-forward-链基本规则所有流量直接交给">设置 FORWARD 链基本规则，所有流量直接交给&lt;/h1>
&lt;/li>
&lt;li>
&lt;p>-A FORWARD -m conntrack &amp;ndash;ctstate RELATED,ESTABLISHED -j ACCEPT&lt;/p>
&lt;/li>
&lt;li>
&lt;p>-A FORWARD -i lo -j ACCEPT&lt;/p>
&lt;/li>
&lt;li>
&lt;p>-A FORWARD -j FORWARD_direct&lt;/p>
&lt;/li>
&lt;li>
&lt;p>-A FORWARD -j FORWARD_IN_ZONES_SOURCE&lt;/p>
&lt;/li>
&lt;li>
&lt;p>-A FORWARD -j FORWARD_IN_ZONES&lt;/p>
&lt;/li>
&lt;li>
&lt;p>-A FORWARD -j FORWARD_OUT_ZONES_SOURCE&lt;/p>
&lt;/li>
&lt;li>
&lt;p>-A FORWARD -j FORWARD_OUT_ZONES&lt;/p>
&lt;/li>
&lt;li>
&lt;p>-A FORWARD -m conntrack &amp;ndash;ctstate INVALID -j DROP&lt;/p>
&lt;/li>
&lt;li>
&lt;p>-A FORWARD -j REJECT &amp;ndash;reject-with icmp-host-prohibited # 在 FORWARD 链上拒绝所有流量，并通过 icmp 协议提示客户端 prohibited&lt;/p>
&lt;/li>
&lt;li>
&lt;h1 id="设置-output-链基本规则直接把后续检查转交给-output_direct-这个自定义-chain-进行规则匹配">设置 OUTPUT 链基本规则，直接把后续检查转交给 OUTPUT_direct 这个自定义 chain 进行规则匹配&lt;/h1>
&lt;/li>
&lt;li>
&lt;p>-A OUTPUT -j OUTPUT_direct&lt;/p>
&lt;/li>
&lt;li>
&lt;h1 id="forward-相关的自定义-chain-规则">FORWARD 相关的自定义 chain 规则&lt;/h1>
&lt;/li>
&lt;li>
&lt;p>-A FORWARD_IN_ZONES -i bond0 -g FWDI_public&lt;/p>
&lt;/li>
&lt;li>
&lt;p>-A FORWARD_IN_ZONES -i eth2 -g FWDI_public&lt;/p>
&lt;/li>
&lt;li>
&lt;p>-A FORWARD_IN_ZONES -i eth1 -g FWDI_public&lt;/p>
&lt;/li>
&lt;li>
&lt;p>-A FORWARD_IN_ZONES -i eth0 -g FWDI_public&lt;/p>
&lt;/li>
&lt;li>
&lt;p>-A FORWARD_IN_ZONES -g FWDI_public&lt;/p>
&lt;/li>
&lt;li>
&lt;p>-A FORWARD_OUT_ZONES -o bond0 -g FWDO_public&lt;/p>
&lt;/li>
&lt;li>
&lt;p>-A FORWARD_OUT_ZONES -o eth2 -g FWDO_public&lt;/p>
&lt;/li>
&lt;li>
&lt;p>-A FORWARD_OUT_ZONES -o eth1 -g FWDO_public&lt;/p>
&lt;/li>
&lt;li>
&lt;p>-A FORWARD_OUT_ZONES -o eth0 -g FWDO_public&lt;/p>
&lt;/li>
&lt;li>
&lt;p>-A FORWARD_OUT_ZONES -g FWDO_public&lt;/p>
&lt;/li>
&lt;li>
&lt;p>-A FWDI_public -j FWDI_public_log&lt;/p>
&lt;/li>
&lt;li>
&lt;p>-A FWDI_public -j FWDI_public_deny&lt;/p>
&lt;/li>
&lt;li>
&lt;p>-A FWDI_public -j FWDI_public_allow&lt;/p>
&lt;/li>
&lt;li>
&lt;p>-A FWDI_public -p icmp -j ACCEPT&lt;/p>
&lt;/li>
&lt;li>
&lt;p>-A FWDO_public -j FWDO_public_log&lt;/p>
&lt;/li>
&lt;li>
&lt;p>-A FWDO_public -j FWDO_public_deny&lt;/p>
&lt;/li>
&lt;li>
&lt;p>-A FWDO_public -j FWDO_public_allow&lt;/p>
&lt;/li>
&lt;li>
&lt;h1 id="input-相关的自定义-chain-规则">INPUT 相关的自定义 chain 规则&lt;/h1>
&lt;/li>
&lt;li>
&lt;h1 id="input_zones-用来将各个网络设备区分到指定的-zone-中">INPUT_ZONES 用来将各个网络设备区分到指定的 ZONE 中&lt;/h1>
&lt;/li>
&lt;li>
&lt;p>-A INPUT_ZONES -i bond0 -g IN_public&lt;/p>
&lt;/li>
&lt;li>
&lt;p>-A INPUT_ZONES -i eth2 -g IN_public&lt;/p>
&lt;/li>
&lt;li>
&lt;p>-A INPUT_ZONES -i eth1 -g IN_public&lt;/p>
&lt;/li>
&lt;li>
&lt;p>-A INPUT_ZONES -i eth0 -g IN_public # 将 eth0 的流量放到 public 区域中继续进行匹配&lt;/p>
&lt;/li>
&lt;li>
&lt;p>-A INPUT_ZONES -g IN_public&lt;/p>
&lt;/li>
&lt;li>
&lt;h1 id="input-链上的-public-区域的规则">INPUT 链上的 public 区域的规则&lt;/h1>
&lt;/li>
&lt;li>
&lt;p>-A IN_public -j IN_public_log&lt;/p>
&lt;/li>
&lt;li>
&lt;p>-A IN_public -j IN_public_deny&lt;/p>
&lt;/li>
&lt;li>
&lt;p>-A IN_public -j IN_public_allow&lt;/p>
&lt;/li>
&lt;li>
&lt;p>-A IN_public -p icmp -j ACCEPT&lt;/p>
&lt;/li>
&lt;li>
&lt;p>-A IN_public_allow -p tcp -m tcp &amp;ndash;dport 22 -m conntrack &amp;ndash;ctstate NEW -j ACCEPT&lt;/p>
&lt;/li>
&lt;li>
&lt;h1 id="xxxx-区域的规则">XXXX 区域的规则&lt;/h1>
&lt;/li>
&lt;li>
&lt;p>。。。。每当一个网络设备被放到某个区域中，这个区域就会激活，会在整个 iptables 表中显示，可以使用 firewall-cmd &amp;ndash;zone=drop &amp;ndash;change-interface=eth1 进行验证&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>从下往上看的话，firewalld 会默认方通 22 端口(i.e.方通 sshd 服务)和 icmp 协议，并且自定义规则链的数据结构详见脑图 firewalld 之 filter 表基本配置图.mindmap&lt;/p></description></item></channel></rss>