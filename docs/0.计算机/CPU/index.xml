<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>CPU on 断念梦的站点</title><link>https://desistdaydream.github.io/docs/0.%E8%AE%A1%E7%AE%97%E6%9C%BA/CPU/</link><description>Recent content in CPU on 断念梦的站点</description><generator>Hugo</generator><language>zh-cn</language><atom:link href="https://desistdaydream.github.io/docs/0.%E8%AE%A1%E7%AE%97%E6%9C%BA/CPU/index.xml" rel="self" type="application/rss+xml"/><item><title>CPU</title><link>https://desistdaydream.github.io/docs/0.%E8%AE%A1%E7%AE%97%E6%9C%BA/CPU/CPU/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/0.%E8%AE%A1%E7%AE%97%E6%9C%BA/CPU/CPU/</guid><description>概述 参考：
Wiki, Central_processing_unit Central Processing Unit(中央处理器，简称 CPU)。
如同华硕主板示意图上半部的中央部分，那就是 CPU 插槽。由于 CPU 负责大量运算，因此 CPU 通常是具有相当高发热量的元件。所以如果你曾经拆开过主板，应该就会看到 CPU 上头通常会安插一颗风扇来主动散热的。
x86 个人电脑的 CPU 主要供应商为 Intel 与 AMD，目前（2015）主流的 CPU 都是双核以上的架构了！原本的单核心 CPU 仅有一个运算单元，所谓的多核心则是在一颗 CPU 封装当中嵌入了两个以上的运算核心， 简单的说，就是一个实体的 CPU 外壳中，含有两个以上的 CPU 单元就是了。
不同的 CPU 型号大多具有不同的脚位（CPU 上面的插脚），能够搭配的主板芯片组也不同， 所以当你想要将你的主机升级时，不能只考虑 CPU，你还得要留意你的主板上面所支持的 CPU 型号喔！不然买了最新的 CPU 也不能够安插在你的旧主板上头的！目前主流的 CPU 有 Intel 的 i3/i5/i7 系列产品中，甚至先后期出厂的类似型号的脚位也不同， 例如 i7-2600 使用 LGA1155 脚位而 i7-4790 则使用 FCLGA1150 脚位，挑选时必须要很小心喔！
我们前面谈到 CPU 内部含有微指令集，不同的微指令集会导致 CPU 工作效率的优劣。除了这点之外， CPU 性能的比较还有什么呢？那就是 CPU 的频率了！什么是频率呢？简单的说， 频率就是 CPU 每秒钟可以进行的工作次数。所以频率越高表示这颗 CPU 单位时间内可以作更多的事情。举例来说，Intel 的 i7-4790 CPU 频率为 3.</description></item><item><title>指令集架构</title><link>https://desistdaydream.github.io/docs/0.%E8%AE%A1%E7%AE%97%E6%9C%BA/CPU/%E6%8C%87%E4%BB%A4%E9%9B%86%E6%9E%B6%E6%9E%84/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/0.%E8%AE%A1%E7%AE%97%E6%9C%BA/CPU/%E6%8C%87%E4%BB%A4%E9%9B%86%E6%9E%B6%E6%9E%84/</guid><description>概述 参考：
Wiki, InstructionSetArchitecture(指令集架构) https://picture.iczhiku.com/weixin/message1583925567196.html https://a-suozhang.xyz/2019/09/27/ISA/ Instruction set architecture(指令集架构，简称 ISA) 是软件和硬件之间的接口，是一套标准规范，并不具备实体，我们可以根据这套规范去设计 CPU 和对应的软件系统，并最终形成产品。
执行 ISA 描述中的指令的设备，称为 implementation(实现)，实现这个功能的设备，通常都是 CPU。
常见的指令集如：
AMD(X86_64) ARM RISC-V 等 如果把软件和硬件看成螺母和螺钉，那么 ISA 就是螺母和螺钉之间对接的规范(e.g.尺寸、螺纹 之类的)。螺母和螺钉都按照相同的尺寸(i.e.相同的规范)去设计，即使是由不同的厂商来生产，也可以保证最终所有的螺钉都能拧到螺母上。
指令集向上承载的是整个软件生态，向下则规范了以处理器芯片为代表的整个硬件生态。根据一份指令集规范，设计一款处理器，其上可以运行同样遵循该指令集规范所编写的软件代码。故而，我们在提到指令集的时候，有时候也指的是其背后的整个软硬件生态系统，包括外围芯片、操作系统、编译器和诸多应用软件（浏览器、游戏软件等）。事实证明，每一种芯片在市场竞争中要取得成功，很大程度上取决于其生态系统。
指令 &amp;amp; 指令集 &amp;amp; 指令集架构 历史 B 站，【差评】乐疯了：为什么美国想用RISC-V搞死中国，是本年度最大的笑话。。。
RISC 与 CISC 参考:
Wiki, Complex instruction set computer Wiki, Reduced instruction set computer Complex instruction set computer(复杂指令集计算机，简称 CISC)
Reduced instruction set computer(精简指令集极端及，简称 RISC)</description></item><item><title>精简指令集</title><link>https://desistdaydream.github.io/docs/0.%E8%AE%A1%E7%AE%97%E6%9C%BA/CPU/%E7%B2%BE%E7%AE%80%E6%8C%87%E4%BB%A4%E9%9B%86/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/0.%E8%AE%A1%E7%AE%97%E6%9C%BA/CPU/%E7%B2%BE%E7%AE%80%E6%8C%87%E4%BB%A4%E9%9B%86/</guid><description>概述 参考：
不懂精简指令集还敢说自己是程序员？ 在上一篇文章《CPU 进化论：复杂指令集》中我们从历史的角度讲述了复杂指令集出现的必然，随着时间的推移，采用复杂指令集架构的 CPU 出现各种各样的问题，面对这些问题一部分人开始重新思考指令集到底该如何设计。
在这一时期，两个趋势的出现促成一种新的指令集设计思想。
内存与编译器
时间来到了 1980s 年代，此时容量 “高达”64K 的内存开始出现，内存容量上终于不再捉襟见肘，价格也开始急速下降，在 1977 年，1MB 内存的价格高达**$5000**，要知道这可是 1977 年的 5000 刀，但到了 1994 年，1MB 内存价格就急速下降到大概只有 $6，这是第一个趋势。
此外在这一时期随着编译技术的进步，编译器越来越成熟，渐渐的程序员们开始依靠编译器来生成汇编指令而不再自己手工编写。
这两个趋势的出现让人们有了更多思考。
化繁为简
19 世纪末 20 世纪初意大利经济学家 Pareto 发现，在任何一组东西中，最重要的只占其中一小部分，约 20%，其余 80% 尽管是多数，却是次要的，这就是著名的二八定律，机器指令的执行频率也有类似的规律。
大概 80% 的时间 CPU 都在执行那 20% 的机器指令，同时 CISC 中一部分比较复杂的指令并不怎么被经常用到，而且那些设计编译器的程序员也更倾向于组合一些简单的指令来完成特定任务。
与此同时我们在上文提到过的一位计算机科学家，被派去改善微代码设计，但后来这老哥发现有问题的是微代码本身，因此开始转过头来去思考微代码这种设计的问题在哪里。
他的早期工作提出一个关键点，复杂指令集中那些被认为可以提高性能的指令其实在内部被微代码拖后腿了，如果移除掉微代码，程序反而可以运行的更快，并且可以节省构造 CPU 消耗的晶体管数量。
由于微代码的设计思想是将复杂机器指令在 CPU 内部转为相对简单的机器指令，这一过程对编译器不可见，也就是说你没有办法通过编译器去影响 CPU 内部的微代码运行行为，因此如果微代码出现 bug 那么编译器是无能为力的，你没有办法通过编译器生成其它机器指令来修复问题而只能去修改微代码本身。
此外他还发现，有时一些复杂的机器指令执行起来要比等价的多个简单指令要。
这一切都在提示：为什么不直接用一些简单到指令来替换掉那些复杂的指令呢？
精简指令集哲学
基于对复杂指令集的思考，精简指令集哲学诞生了，精简指令集主要体现在以下三个方面：
1，指令本身的复杂度
精简指令集的思想其实很简单，干嘛要去死磕复杂的指令，去掉复杂指令代之以一些简单的指令。
有了简单指令 CPU 内部的微代码也不需要了，没有了微代码这层中间抽象，编译器生成的机器指令对 CPU 的控制力大大增强，有什么问题让写编译器的那帮家伙修复就好了，显然调试编译器这种软件要比调试 CPU 这种硬件要简单很多。</description></item></channel></rss>