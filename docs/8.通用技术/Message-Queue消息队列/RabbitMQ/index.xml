<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>RabbitMQ on 断念梦的站点</title><link>https://desistdaydream.github.io/docs/8.%E9%80%9A%E7%94%A8%E6%8A%80%E6%9C%AF/Message-Queue%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/RabbitMQ/</link><description>Recent content in RabbitMQ on 断念梦的站点</description><generator>Hugo</generator><language>zh-cn</language><atom:link href="https://desistdaydream.github.io/docs/8.%E9%80%9A%E7%94%A8%E6%8A%80%E6%9C%AF/Message-Queue%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/RabbitMQ/index.xml" rel="self" type="application/rss+xml"/><item><title>RabbitMQ</title><link>https://desistdaydream.github.io/docs/8.%E9%80%9A%E7%94%A8%E6%8A%80%E6%9C%AF/Message-Queue%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/RabbitMQ/RabbitMQ/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/8.%E9%80%9A%E7%94%A8%E6%8A%80%E6%9C%AF/Message-Queue%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/RabbitMQ/RabbitMQ/</guid><description>概述 参考：
官方网址 消息队列模拟器 https://www.yuque.com/noobwo/mq/hpiop0 https://m.6-km.com/next/quorum-queues.html https://zhuanlan.zhihu.com/p/63700605 Rabbit Message Queue(Rabbit 消息队列，简称：RabbitMQ)。是一个在 AMQP 基础上实现的，可复用的消息队列服务。
Advanced Message Queuing Protocol(高级消息队列协议，简称 AMQP) ，是一个提供统消息服务的应用层(7 层)协议。其设计目标是对于消息的排序、路由（包括点对点和订阅-发布）、保持可靠性、保证安全性[1]。AMQP 规范了消息传递方和接收方的行为，以使消息在不同的提供商之间实现互操作性，就像 SMTP，HTTP，FTP 等协议可以创建交互系统一样。与先前的中间件标准（如 Java 消息服务）不同的是，JMS 在特定的 API 接口层面和实现行为上进行了统一，而高级消息队列协议则关注于各种消息如何以字节流的形式进行传递。因此，使用了符合协议实现的任意应用程序之间可以保持对消息的创建、传递。
工作机制概述 在了解消息通讯之前首先要了解 3 个概念：生产者、消费者和代理。
Publisher(生产者)：消息的创建者，负责创建和推送数据到消息服务器；
Consumer(消费者)：消息的接收方，用于处理数据和确认消息；
Broker(代理)：就是 RabbitMQ 本身，用于扮演“快递”的角色，本身不生产消息，只是扮演“快递”的角色。
消息发送原理
首先你必须连接到 Rabbit 才能发布和消费消息，那怎么连接和发送消息的呢？
你的应用程序和 Rabbit Server 之间会创建一个 TCP 连接，一旦 TCP 打开，并通过了认证，认证就是你试图连接 Rabbit 之前发送的 Rabbit 服务器连接信息和用户名和密码，有点像程序连接数据库，使用 Java 有两种连接认证的方式，后面代码会详细介绍，一旦认证通过你的应用程序和 Rabbit 就创建了一条 AMQP 信道（Channel）。
信道是创建在“真实”TCP 上的虚拟连接，AMQP 命令都是通过信道发送出去的，每个信道都会有一个唯一的 ID，不论是发布消息，订阅队列或者介绍消息都是通过信道完成的。
为什么不通过 TCP 直接发送命令？
对于操作系统来说创建和销毁 TCP 会话是非常昂贵的开销，假设高峰期每秒有成千上万条连接，每个连接都要创建一条 TCP 会话，这就造成了 TCP 连接的巨大浪费，而且操作系统每秒能创建的 TCP 也是有限的，因此很快就会遇到系统瓶颈。</description></item><item><title>go rabbitmq 库</title><link>https://desistdaydream.github.io/docs/8.%E9%80%9A%E7%94%A8%E6%8A%80%E6%9C%AF/Message-Queue%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/RabbitMQ/go-rabbitmq-%E5%BA%93/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/8.%E9%80%9A%E7%94%A8%E6%8A%80%E6%9C%AF/Message-Queue%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/RabbitMQ/go-rabbitmq-%E5%BA%93/</guid><description>概述 参考：
http://www.topgoer.com/%25E6%2595%25B0%25E6%258D%25AE%25E5%25BA%2593%25E6%2593%258D%25E4%25BD%259C/go%25E6%2593%258D%25E4%25BD%259CRabbitMQ/Simple%25E6%25A8%25A1%25E5%25BC%258F.html
package RabbitMQ import ( &amp;#34;fmt&amp;#34; &amp;#34;log&amp;#34; &amp;#34;github.com/streadway/amqp&amp;#34; ) //连接信息amqp://kuteng:kuteng@127.0.0.1:5672/kuteng这个信息是固定不变的amqp://事固定参数后面两个是用户名密码ip地址端口号Virtual Host const MQURL = &amp;#34;amqp://kuteng:kuteng@127.0.0.1:5672/kuteng&amp;#34; //rabbitMQ结构体 type RabbitMQ struct { conn *amqp.Connection channel *amqp.Channel //队列名称 QueueName string //交换机名称 Exchange string //bind Key 名称 Key string //连接信息 Mqurl string } //创建结构体实例 func NewRabbitMQ(queueName string, exchange string, key string) *RabbitMQ { return &amp;amp;RabbitMQ{QueueName: queueName, Exchange: exchange, Key: key, Mqurl: MQURL} } //断开channel 和 connection func (r *RabbitMQ) Destory() { r.</description></item><item><title>RabbitMQ Operator</title><link>https://desistdaydream.github.io/docs/8.%E9%80%9A%E7%94%A8%E6%8A%80%E6%9C%AF/Message-Queue%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/RabbitMQ/RabbitMQ-Operator/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/8.%E9%80%9A%E7%94%A8%E6%8A%80%E6%9C%AF/Message-Queue%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/RabbitMQ/RabbitMQ-Operator/</guid><description>概述 参考：
官方文档， https://www.rabbitmq.com/kubernetes/operator/operator-overview.html https://www.rabbitmq.com/kubernetes/operator/using-operator.html#override 通过 Operator 部署一套生产可用的 RabbitMQ 集群 创建 namespace kubectl create ns rabbitmq 部署 operator kubectl apply -f &amp;quot;https://github.com/rabbitmq/cluster-operator/releases/latest/download/cluster-operator.yml&amp;quot; 创建 PV cat &amp;gt; rabbitmq-pv.yaml &amp;lt;&amp;lt; EOF apiVersion: v1 kind: PersistentVolume metadata: name: rabbitmq-node-1 spec: accessModes: - ReadWriteOnce capacity: storage: 10Gi local: path: /opt/rabbitmq nodeAffinity: required: nodeSelectorTerms: - matchExpressions: - key: kubernetes.io/hostname operator: In values: - node-1.tj-test --- apiVersion: v1 kind: PersistentVolume metadata: name: rabbitmq-node-2 spec: accessModes: - ReadWriteOnce capacity: storage: 10Gi local: path: /opt/rabbitmq nodeAffinity: required: nodeSelectorTerms: - matchExpressions: - key: kubernetes.</description></item><item><title>RabbitMQ 部署</title><link>https://desistdaydream.github.io/docs/8.%E9%80%9A%E7%94%A8%E6%8A%80%E6%9C%AF/Message-Queue%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/RabbitMQ/RabbitMQ-%E9%83%A8%E7%BD%B2/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/8.%E9%80%9A%E7%94%A8%E6%8A%80%E6%9C%AF/Message-Queue%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/RabbitMQ/RabbitMQ-%E9%83%A8%E7%BD%B2/</guid><description>概述 参考：
官方文档，安装与配置 使用 docker 启动单节点 RabbitMQ docker run -d --hostname my-rabbit --name rabbit \ -p 15672:15672 -p 5672:5672 \ rabbitmq:3-management 在 kubernetes 集群中使用 Operator 部署 RabbitMQ 参考：
官方文档，安装和配置-Kubernetes Operator 安装 通过 Operator 使用 RabbitMQ 集群 注意：RabbitMQ Operator 会为每一个被其创建的 rabbitmqclusters.rabbitmq.com 资源的对象添加 finalizers 字段，效果如下：
apiVersion: rabbitmq.com/v1beta1 kind: RabbitmqCluster metadata: finalizers: - deletion.finalizers.rabbitmqclusters.rabbitmq.com 基于此，若删除 RabbitmqCluster 对象前删除了 RabbitMQ Operator，那么 RabbitmqCluster 将无法被删除，除非手动删除 finalizers 字段。
部署 operator 这里会自动创建 rabbitmq-system 名称空间
kubectl apply -f &amp;#34;https://github.com/rabbitmq/cluster-operator/releases/latest/download/cluster-operator.yml&amp;#34; 创建 pv cat &amp;gt; rabbitmq-pv.</description></item><item><title>RabbitMQ 集群</title><link>https://desistdaydream.github.io/docs/8.%E9%80%9A%E7%94%A8%E6%8A%80%E6%9C%AF/Message-Queue%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/RabbitMQ/RabbitMQ-%E9%9B%86%E7%BE%A4/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/8.%E9%80%9A%E7%94%A8%E6%8A%80%E6%9C%AF/Message-Queue%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/RabbitMQ/RabbitMQ-%E9%9B%86%E7%BE%A4/</guid><description>概述 参考：
官方文档：https://www.rabbitmq.com/clustering.html RabbitMQ 这款消息队列中间件产品本身是基于 Erlang 语言编写，Erlang 语言天生具备分布式特性（通过同步 Erlang 集群各节点的 magic cookie 来实现）。
因此，RabbitMQ 天然支持 Clustering。这使得 RabbitMQ 本身不需要像 ActiveMQ、Kafka 那样通过 ZooKeeper 分别来实现 HA 方案和保存集群的元数据。集群是保证可靠性的一种方式，同时可以通过水平扩展以达到增加消息吞吐量能力的目的。下面先来看下 RabbitMQ 集群的整体方案：
上面图中采用三个节点组成了一个 RabbitMQ 的集群，Exchange A 的元数据信息在所有节点上是一致的，而 Queue 的完整数据则只会存在于它所创建的那个节点上。其他节点只知道这个 queue 的 metadata 信息和一个指向 queue 的 owner node 的指针。
RabbitMQ 集群中各节点关系 RabbitMQ 集群各节点同步的数据
RabbitMQ 集群的各节点会始终同步四种类型的内部元数据（类似索引）
队列元数据：队列名称和它的属性 交换器元数据：交换器名称、类型和属性 绑定元数据：一张简单的表格展示了如何将消息路由到队列 vhost 元数据：为 vhost 内的队列、交换器和绑定提供命名空间和安全属性 因此，当用户访问其中任何一个 RabbitMQ 节点时，通过 rabbitmqctl 查询到的 queue/user/exchange/vhost 等信息都是相同的。
默认情况下，队列中的数据(消息) 是不在各节点互相同步的。如果想要各节点数据保持一致，查看 《RabbitMQ 基于集群的高可用性》章节
Nodes Equal Peers(节点对等)
在某些分布式系统中，节点是具有领导者和追随者概念的。对于 RabbitMQ，通常情况并不是这样的。RabbitMQ 集群中所有节点都是 equal peers(对等的)。</description></item><item><title>RabbitMQ 命令行工具</title><link>https://desistdaydream.github.io/docs/8.%E9%80%9A%E7%94%A8%E6%8A%80%E6%9C%AF/Message-Queue%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/RabbitMQ/RabbitMQ-%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%B7%A5%E5%85%B7/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/8.%E9%80%9A%E7%94%A8%E6%8A%80%E6%9C%AF/Message-Queue%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/RabbitMQ/RabbitMQ-%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%B7%A5%E5%85%B7/</guid><description>概述 RabbitMQ 主要有四个命令行工具 Commend Line Tools，不同的命令行适用不用的场景
rabbitmqctl：负责服务管理和进行操作 rabbitmq-diagnostics：负责系统诊断和健康检查 rabbitmq-plugins：负责插件管理 rabbitmqadmin：用来操作 HTTP API rabbitmqctl 管理 RabbitMQ 节点 详见此处
rabbitmq-diagnostics 负责系统诊断和健康检查 rabbitmq-plugins 负责插件管理 rabbitmq-plugins [&amp;ndash;node ] [&amp;ndash;timeout ] [&amp;ndash;longnames] [&amp;ndash;quiet] []
Available commands:
Help:
autocomplete Provides command name autocomplete variants
help Displays usage information for a command
version Displays CLI tools version
Monitoring, observability and health checks:
directories Displays plugin directory and enabled plugin file paths
is_enabled Health check that exits with a non-zero code if provided plugins are not enabled on target node</description></item><item><title>RabbitMQ 性能与优化</title><link>https://desistdaydream.github.io/docs/8.%E9%80%9A%E7%94%A8%E6%8A%80%E6%9C%AF/Message-Queue%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/RabbitMQ/RabbitMQ-%E6%80%A7%E8%83%BD%E4%B8%8E%E4%BC%98%E5%8C%96/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/8.%E9%80%9A%E7%94%A8%E6%8A%80%E6%9C%AF/Message-Queue%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/RabbitMQ/RabbitMQ-%E6%80%A7%E8%83%BD%E4%B8%8E%E4%BC%98%E5%8C%96/</guid><description>RabbitMQ性能评估，第2部分
https://www.rabbitmq.com/blog/2012/04/25/rabbitmq-performance-measurements-part-2/</description></item><item><title>rabbitmqctl 命令行工具详解</title><link>https://desistdaydream.github.io/docs/8.%E9%80%9A%E7%94%A8%E6%8A%80%E6%9C%AF/Message-Queue%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/RabbitMQ/rabbitmqctl-%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%B7%A5%E5%85%B7%E8%AF%A6%E8%A7%A3/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/8.%E9%80%9A%E7%94%A8%E6%8A%80%E6%9C%AF/Message-Queue%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/RabbitMQ/rabbitmqctl-%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%B7%A5%E5%85%B7%E8%AF%A6%E8%A7%A3/</guid><description>rabbitmqctl 官方文档：https://www.rabbitmq.com/rabbitmqctl.8.html
管理 RabbitMQ 节点的工具
rabbitmqctl 是用于管理 RabbitMQ 服务器节点的命令行工具。它通过连接到专用 CLI 工具通信端口上的目标 RabbitMQ 节点并使用共享密钥（称为 cookie 文件）进行身份验证来执行所有操作。该命令主要的功能包括以下几点：
停止节点运行 获取节点状态、有效配置、健康检查 Virtual Hosts 管理 用户和权限管理 Policy 管理 查看 queues、connections、channels、exchanges 和 consumers 列表信息 集群会员身份管理 rabbitmqctl [OPTIONS] COMMAND [COMMAND_OPTIONS]
OPTIONS
-q.&amp;ndash;quiet # 安静模式输出，输出的信息减少 COMMAND 包括如下几大类：
Nodes # 节点管理 Cluster Managerment # 集群管理 Replication Users Management # 用户管理 Access Control # 访问控制 Monitoring, observability and health checks Parameters Policies Virtual hosts Configuration and Environment Definitions Feature flags Operations Queues Deprecated COMMAND_OPTIONS 中有几个通用的</description></item><item><title>问题实例</title><link>https://desistdaydream.github.io/docs/8.%E9%80%9A%E7%94%A8%E6%8A%80%E6%9C%AF/Message-Queue%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/RabbitMQ/%E9%97%AE%E9%A2%98%E5%AE%9E%E4%BE%8B/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/8.%E9%80%9A%E7%94%A8%E6%8A%80%E6%9C%AF/Message-Queue%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/RabbitMQ/%E9%97%AE%E9%A2%98%E5%AE%9E%E4%BE%8B/</guid><description>Waiting for Mnesia tables 报错 另一个 issue：https://github.com/bitnami/charts/issues/3783#，这是 bitnami 上的 rabbitmq helm 的报错 issue
多个节点同时重启，出现该问题，该问题主要是因为各个节点之间无法有效得正常通信导致的</description></item></channel></rss>