<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>断念梦的站点 – 编码与解码</title><link>https://desistdaydream.github.io/docs/8.%E9%80%9A%E7%94%A8%E6%8A%80%E6%9C%AF/%E7%BC%96%E7%A0%81%E4%B8%8E%E8%A7%A3%E7%A0%81/</link><description>Recent content in 编码与解码 on 断念梦的站点</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><atom:link href="https://desistdaydream.github.io/docs/8.%E9%80%9A%E7%94%A8%E6%8A%80%E6%9C%AF/%E7%BC%96%E7%A0%81%E4%B8%8E%E8%A7%A3%E7%A0%81/index.xml" rel="self" type="application/rss+xml"/><item><title>Docs: 编码与解码</title><link>https://desistdaydream.github.io/docs/8.%E9%80%9A%E7%94%A8%E6%8A%80%E6%9C%AF/%E7%BC%96%E7%A0%81%E4%B8%8E%E8%A7%A3%E7%A0%81/%E7%BC%96%E7%A0%81%E4%B8%8E%E8%A7%A3%E7%A0%81/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/8.%E9%80%9A%E7%94%A8%E6%8A%80%E6%9C%AF/%E7%BC%96%E7%A0%81%E4%B8%8E%E8%A7%A3%E7%A0%81/%E7%BC%96%E7%A0%81%E4%B8%8E%E8%A7%A3%E7%A0%81/</guid><description>
&lt;h1 id="概述">概述&lt;a class="td-heading-self-link" href="#%e6%a6%82%e8%bf%b0" aria-label="Heading self-link">&lt;/a>&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Code">Wiki，Code&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>在通信和信息处理中，&lt;strong>Code(代码)&lt;/strong> 是一种规则系统，用于将信息（e.g. 字母、单词、声音、图像、手势、etc.）以另一种形式展示（e.g. 数字、短码、加密、etc.），以便可以通过通信通道或存储在存储器中进行通信。&lt;/p>
&lt;blockquote>
&lt;p>注意与 &lt;a href="docs/2.%E7%BC%96%E7%A8%8B/%E7%BC%96%E7%A8%8B.md">编程&lt;/a> 中的 Code 概念区分。虽然编程中的 Code 也有类似将一种语言转成另一种语言的概念。但是与这里的 Code 概念并不完全一样。&lt;/p>
&lt;/blockquote>
&lt;p>&lt;strong>Encoding(编码)&lt;/strong> 是信息从一种形式或格式,转换为另一种形式或格式的过程。而 &lt;strong>Decoding(解码)&lt;/strong> 则是编码的逆过程。&lt;/p>
&lt;p>首先需要明确一点，计算机的组件处理信息都是基于 &lt;strong>二进制&lt;/strong> 来实现的，也就是说。都是 0 和 1 这种信息，不管电路的一开一关，灯的一亮一灭，都可以用 0 和 1 来表示。而计算机也是通过 0 和 1 来存储以及处理数据的。&lt;/p>
&lt;p>&lt;strong>但是计算机在使用的时候，我们看到并不是只有 0 和 1，我们打字也不是只输入 0 和 1，不但有文字，还有图片、视频、音频等等。这是为什么呢？&lt;/strong>&lt;/p>
&lt;p>由于计算机只认识 0 和 1 这种二进制数据，其他格式的数据都需要转换成二进制才能被计算机处理，也就是说我们在计算机上看到的文本、视频、可执行程序等格式的文件，最终都会进行编码以转换成二进制数据交给计算机处理；而计算机处理完成后，会进行解码以将二进制数据转换为 文本、图片、视频 等格式，以便人类可以查看。这种来回转换的过程，就称为 &lt;strong>Encoding(编码)&lt;/strong> 与 &lt;strong>Decoding(解码)&lt;/strong>。&lt;/p>
&lt;p>总的来说，通常编码与解码是相对人类来说，把人类当做主体，i.e. 人类是数据的发送者和接收者。此时，Encoding 是将来自发送者的信息转换为用于通信和存储的符号。Decoding 是将代码符号转换回接收者可以理解的形式。&lt;/p>
&lt;p>而文字、图片、音/视频 等等数据，其编码方式又各不相同。&lt;/p>
&lt;ul>
&lt;li>字符编码 # 用来对文字进行 编/解码 的过程&lt;/li>
&lt;li>图形编码 # 对图片进行 编/解码 的过程&lt;/li>
&lt;li>音频编码 # 对音频进行 编/解码 的过程&lt;/li>
&lt;/ul>
&lt;p>当然，随着时代的发展，Encoding(编码) 与 Decoding(解码) 也不仅仅代指上述三种类型，就如概述中的第一句话，**任何格式的数据转换成另一种，都可以称之为编码！**比如 Base64 编码，则是可以将二进制数据，转换为字符串数据，这种行为，也可以称之为编码。&lt;/p>
&lt;blockquote>
&lt;p>这里面的&lt;strong>编码和解码&lt;/strong>从某种角度看存在&lt;strong>相对概念&lt;/strong>，上文描述的编码和解码，是对于人类与计算机而言。假如将人类与计算机变为 Go 编程语言与 JSON 数据，那么对于 Go 来说，其本身其实并不认识 JSON 格式数据，所以如果 Go 程序当做主体&lt;/p>
&lt;ul>
&lt;li>作为发送者，将 Go 程序自身可以理解的数据（比如 struct、slice 等等）发送到 json 库，进行编码后，转换为供人类用于通信和存储的 JSON 符号数据。&lt;/li>
&lt;li>作为接收者，由 json 库解码后，转为 Go 程序自身可以理解的数据（比如 struct、slice 等等）。&lt;/li>
&lt;/ul>
&lt;p>这段内容要是理解不了，可以先学习编程语言的各种 JSON、YAML 数据处理库，再回头看。&lt;/p>
&lt;/blockquote>
&lt;h2 id="编码解码与协议">编码解码与协议&lt;a class="td-heading-self-link" href="#%e7%bc%96%e7%a0%81%e8%a7%a3%e7%a0%81%e4%b8%8e%e5%8d%8f%e8%ae%ae" aria-label="Heading self-link">&lt;/a>&lt;/h2>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://mp.weixin.qq.com/s/kfyTcs6xuDvlCX3U04Edng">公众号-码农的荒岛求生，神奇的 Google 二进制编解码技术：Protobuf&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>计算机网络编程中一个非常基本的问题：该怎样表示 client 与 server 之间交互的数据，在往下看之前先想一想这个问题。&lt;/p>
&lt;h3 id="共识与协议">共识与协议&lt;a class="td-heading-self-link" href="#%e5%85%b1%e8%af%86%e4%b8%8e%e5%8d%8f%e8%ae%ae" aria-label="Heading self-link">&lt;/a>&lt;/h3>
&lt;p>这个问题可不像看上去的那样简单，因为 client 进程和 server 进程运行在不同的机器上，这些机器可能运行在不同的处理器平台、可能运行在不同的操作系统、可能是由不同的编程语言编写的，server 要怎样才能识别出 client 发送的是什么数据呢？就像这样：&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/rpxf9d/1663061154712-3689268d-a902-4892-93f8-6682f9329d0a.png" alt="">&lt;/p>
&lt;p>client 给 server 发送了一段数据：&lt;/p>
&lt;p>&lt;code>0101000100100001&lt;/code>&lt;/p>
&lt;p>server 怎么能知道该怎样“解读”这段数据呢？&lt;/p>
&lt;p>显然，client 和 server 在发送数据之前必须首先达成某种关于怎样解读数据的共识，这就是所谓的&lt;strong>协议&lt;/strong>。&lt;/p>
&lt;p>这里的协议可以是这样的：“将每 8 个比特为一个单位解释为无符号数字”，如果协议是这样的，那么 server 接收到这串二进制后就会将其解析为 81(01010001)与 33(00100001)。&lt;/p>
&lt;p>当然，这里的协议也可以是这样的：“将每 8 个比特为一个单位解释为 ASCII 字符”，那么 server 接收到这串二进制后就将其解析为“Q!”。&lt;/p>
&lt;p>可见，同样一串二进制在不同的“上下文/协议”下有完全不一样的解读，&lt;strong>这也是为什么计算机明明只认知 0 和 1 但是却能处理非常复杂任务的根本原因，因为一切都可以编码为 0 和 1，同样的我们也可以从 0 和 1 中解析出我们想要的信息，这就是所谓的编解码技术。&lt;/strong>&lt;/p>
&lt;p>实际上不止 0 和 1，我们也可以将信息编码为摩斯密码(Morse code)等，只不过计算机擅长处理 0 和 1 而已。&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/rpxf9d/1663061154726-975db7c1-2b96-429d-a007-12706a83be5f.png" alt="">&lt;/p>
&lt;h1 id="字符编码">字符编码&lt;a class="td-heading-self-link" href="#%e5%ad%97%e7%ac%a6%e7%bc%96%e7%a0%81" aria-label="Heading self-link">&lt;/a>&lt;/h1>
&lt;p>详见：&lt;a href="https://desistdaydream.github.io/docs/8.%E9%80%9A%E7%94%A8%E6%8A%80%E6%9C%AF/%E7%BC%96%E7%A0%81%E4%B8%8E%E8%A7%A3%E7%A0%81/%E5%AD%97%E7%AC%A6%E7%9A%84%E7%BC%96%E7%A0%81%E4%B8%8E%E8%A7%A3%E7%A0%81/%E5%AD%97%E7%AC%A6%E7%9A%84%E7%BC%96%E7%A0%81%E4%B8%8E%E8%A7%A3%E7%A0%81.md">字符的编码与解码&lt;/a>&lt;/p>
&lt;h1 id="图形编码">图形编码&lt;a class="td-heading-self-link" href="#%e5%9b%be%e5%bd%a2%e7%bc%96%e7%a0%81" aria-label="Heading self-link">&lt;/a>&lt;/h1>
&lt;p>详见：&lt;a href="https://desistdaydream.github.io/docs/8.%E9%80%9A%E7%94%A8%E6%8A%80%E6%9C%AF/%E7%BC%96%E7%A0%81%E4%B8%8E%E8%A7%A3%E7%A0%81/%E5%9B%BE%E5%83%8F%E7%9A%84%E7%BC%96%E7%A0%81%E4%B8%8E%E8%A7%A3%E7%A0%81.md">图像的编码与解码&lt;/a>&lt;/p>
&lt;h1 id="音频编码">音频编码&lt;a class="td-heading-self-link" href="#%e9%9f%b3%e9%a2%91%e7%bc%96%e7%a0%81" aria-label="Heading self-link">&lt;/a>&lt;/h1>
&lt;p>详见：&lt;a href="https://desistdaydream.github.io/docs/8.%E9%80%9A%E7%94%A8%E6%8A%80%E6%9C%AF/%E7%BC%96%E7%A0%81%E4%B8%8E%E8%A7%A3%E7%A0%81/%E9%9F%B3%E9%A2%91%E7%9A%84%E7%BC%96%E7%A0%81%E4%B8%8E%E8%A7%A3%E7%A0%81.md">音频的编码与解码&lt;/a>&lt;/p></description></item><item><title>Docs: Base64 编码</title><link>https://desistdaydream.github.io/docs/8.%E9%80%9A%E7%94%A8%E6%8A%80%E6%9C%AF/%E7%BC%96%E7%A0%81%E4%B8%8E%E8%A7%A3%E7%A0%81/Base64-%E7%BC%96%E7%A0%81/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/8.%E9%80%9A%E7%94%A8%E6%8A%80%E6%9C%AF/%E7%BC%96%E7%A0%81%E4%B8%8E%E8%A7%A3%E7%A0%81/Base64-%E7%BC%96%E7%A0%81/</guid><description>
&lt;h1 id="概述">概述&lt;a class="td-heading-self-link" href="#%e6%a6%82%e8%bf%b0" aria-label="Heading self-link">&lt;/a>&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Base64">Wiki，Base64&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>Base64 是一组 &lt;strong>二进制 到 文本&lt;/strong> 的编码方案，它是基于64个可打印的字符来表示二进制的数据的一种方法。二进制的数据中的每一个位数的内容，都可以通过字符来表示。&lt;/p>
&lt;p>对于所有二进制到文本编码方案而言，Base64都被设计为在只能可靠地支持文本内容的通道上以二进制格式存储数据。Base64在万维网[1]上特别流行，它的用途包括将图像文件或其他二进制资产嵌入文本资产（例如HTML和CSS文件）中的功能。[2]&lt;/p>
&lt;p>Base64还广泛用于发送电子邮件附件。这是必需的，因为SMTP（原始格式）仅设计为传输7位ASCII字符。这种编码会产生33–36％的开销（编码本身的开销为33％；插入的换行符最多可导致3％的开销）。&lt;/p></description></item><item><title>Docs: 视频的编码与解码</title><link>https://desistdaydream.github.io/docs/8.%E9%80%9A%E7%94%A8%E6%8A%80%E6%9C%AF/%E7%BC%96%E7%A0%81%E4%B8%8E%E8%A7%A3%E7%A0%81/%E8%A7%86%E9%A2%91%E7%9A%84%E7%BC%96%E7%A0%81%E4%B8%8E%E8%A7%A3%E7%A0%81/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/8.%E9%80%9A%E7%94%A8%E6%8A%80%E6%9C%AF/%E7%BC%96%E7%A0%81%E4%B8%8E%E8%A7%A3%E7%A0%81/%E8%A7%86%E9%A2%91%E7%9A%84%E7%BC%96%E7%A0%81%E4%B8%8E%E8%A7%A3%E7%A0%81/</guid><description>
&lt;h1 id="概述">概述&lt;a class="td-heading-self-link" href="#%e6%a6%82%e8%bf%b0" aria-label="Heading self-link">&lt;/a>&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://www.bilibili.com/video/BV19Y4113788">B 站，差评君-这么多视频编码，为什么不能统一成一种呢？&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>视频编码其实就是 图像编码 与 音频编码 的结合体。
毕竟视频就是一幅幅图像叠加在一起而已，只不过在每时每刻又要附加上声音。&lt;/p>
&lt;h1 id="视频-编码-与-压缩">视频 编码 与 压缩&lt;a class="td-heading-self-link" href="#%e8%a7%86%e9%a2%91-%e7%bc%96%e7%a0%81-%e4%b8%8e-%e5%8e%8b%e7%bc%a9" aria-label="Heading self-link">&lt;/a>&lt;/h1>
&lt;p>可能有小伙伴不太清楚编码器是干嘛的，差评君先花点时间给大家解释下：
（ 很快的啊，不用担心内容劝退。。懂的小伙伴可以直接往下划 ）&lt;/p>
&lt;p>我们平常在爱奇艺、 B 站看的视频，它们原本的体量十分巨大。&lt;/p>
&lt;p>有多大呢，我们就拿 1080p 分辨率的视频举例吧，一秒钟视频流大概有 149 MB 那么大（ 1920 x 1080 x 8bit x 三个 RGB 通道 x 24 帧 / 8 ）。&lt;/p>
&lt;p>相当于说我们的网速至少需要达到 149 MB/s，才能够保证看 1080p 视频不卡。&lt;/p>
&lt;p>提醒一下，149 MB/s 约合 1194 Mbps，比千兆宽带（ 1000 Mbps ）还快一点。&lt;/p>
&lt;p>但是估计得有小伙伴说了，你这是在扯淡——我家里的宽带才一百兆，网上的视频不也照样看？&lt;/p>
&lt;p>不但能实时看，还能顺手缓冲个一两分钟的量。
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/dk3gg2/1616076594016-89d258bd-3205-4d80-944a-b7c1c595dd11.jpeg" alt="">&lt;/p>
&lt;p>你们啊，Too Young~&lt;/p>
&lt;p>这其实是因为，我们平常看到的视频已经是被压缩过的了。&lt;/p>
&lt;p>压缩视频的原理细讲起来有点儿复杂，但要是抽简单的说主要就是干了三件事 —— 跳帧、划块、抽色。&lt;/p>
&lt;p>就好比说，前一秒和后一秒都是黑屏，那么这两秒就可以当作一秒处理。（ 跳帧 ）&lt;/p>
&lt;p>又或者，某一秒的画面是一张天空风景图，里面很大一片区域的颜色都是相同的。&lt;/p>
&lt;p>那么这一大片区域的像素就可以直接当成一个大像素来处理。（ 划块 ）&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/dk3gg2/1616076594014-16bd468b-3f32-4125-9dbc-e86abef85e81.jpeg" alt="">&lt;/p>
&lt;p>再比如说，原始大小的视频里包含了 1760 万种色彩，可我寻思着人眼看不出来这么多色儿。&lt;/p>
&lt;p>那么我就可以偷偷抽出来几百万个色，这样又节省了不少空间。（ 抽色 ）&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/dk3gg2/1616076594045-6a0b7b8b-057d-4343-88c3-f76d96f4948e.jpeg" alt="">&lt;/p>
&lt;p>经过这么一套操作之后，原始视频的大小通常可以被压缩到一个挺夸张的地步，就算是 3G 网络也能流畅观看。&lt;/p>
&lt;p>无非就是感觉画面卡了一点儿、糊了一点、颜色绿了一点。。。&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/dk3gg2/1616076594063-16240d1b-7397-4be5-922c-00bda03c81b0.jpeg" alt="">&lt;/p>
&lt;p>而编码器就是那个用来压缩原始视频的玩意 —— 编码器好，视频小的同时画质高；编码器不好，视频大、画质烂。&lt;/p>
&lt;p>了解了这一点之后，我们再接着往下看。&lt;/p>
&lt;p>按照阿里的说法，奇点编码器能把视频压缩千倍不影响画质，那么其他编码器呢？&lt;/p>
&lt;p>差评君来给大家做个简单的实验。&lt;/p>
&lt;p>首先，我们在浏览器里输入 &lt;a href="http://bilibili.com">http://bilibili.com&lt;/a>，打开 B 站。&lt;/p>
&lt;p>然后直奔窑子区然后随便打开一个视频，把分辨率调整到 1080p 之后，在上面右键统计信息。&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/dk3gg2/1616076594011-da2071d6-36f3-4dea-86b7-b879597ead2d.jpeg" alt="">&lt;/p>
&lt;p>这样子我们就拿到了这段视频的技术向信息。&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/dk3gg2/1616076594050-fe83c040-7739-4d0e-b6b9-40e3c97ece9a.jpeg" alt="">&lt;/p>
&lt;p>差评君帮大家解释一下，B 站这段视频使用了一个名叫 H.264 （ AVC ）的编码 —— 这是个十七年前的编码。&lt;/p>
&lt;p>分辨率 1080p，码率 1086 Kbps，相当于把原始视频压缩了 1099 倍。（ 1194 Mbps / 1.086 Mbps ）&lt;/p>
&lt;p>也就是说，一款十七年前发明的编码器，就能做到压缩千倍不影响画质（ 肉眼看起来 ）。&lt;/p>
&lt;p>阿里这时候再吹这个，就好比有人在 2020 年宣布自己发明了汽车轮子。。。&lt;/p>
&lt;p>这延迟，上网用的 Internet Explorer 6.0 吧。&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/dk3gg2/1616076594030-89db9374-da67-41f5-b847-e06ccd15bb5a.jpeg" alt="">&lt;/p>
&lt;p>当然了，差评君这么说也不完全对 —— 虽然都是压缩千倍，但奇点编码器的画质肯定要比 H.264 好。&lt;/p>
&lt;p>不过这里面还有猫腻。&lt;/p>
&lt;p>是这样的，目前常用的视频编码器有这么几个方案：&lt;/p>
&lt;p>前面提到 B 站在用的 H.264，它的继任者 H.265；谷歌的 VP9，以及开放媒体联盟研发的 AV1。&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/dk3gg2/1616076594098-053bfdc6-6a89-401e-a6a1-7f8c1d273b5a.jpeg" alt="">&lt;/p>
&lt;p>从性能上讲，谷歌的 VP9 与 H.264 接近，H.265 相比 H.264 的压缩能力提高了 50%，AV1 则略强于 H.265。&lt;/p>
&lt;p>VP9 ≈ H.264 &amp;laquo; H.265 &amp;lt; AV1，差不多是这么一个意思。&lt;/p>
&lt;p>而阿里的奇点编码器（英文名 S265 ），其实是 H.265 的一个派生版本。&lt;/p>
&lt;p>在这里差评君得补充说明一下，编码器这个行当和显卡行业其实有点儿像。&lt;/p>
&lt;p>就好比说，同样是 RTX3080 显卡，我们可以直接从 NVIDIA 手上购买拉风的 FE 公版，也可以购买华硕、技嘉、微星提供的非公版。&lt;/p>
&lt;p>虽然芯都是老黄 GA106，但是各家的供电、散热设计，以及显卡最终出来的性能表现都会有些细微的区别。&lt;/p>
&lt;p>编码器也是一样。&lt;/p>
&lt;p>ISO （ 国际标准化组织 ）发了个 H.265 的规格和标准之后，各家都可以照着这个规格做一个。&lt;/p>
&lt;p>百度有 BD265，腾讯有 V265；阿里则有 S265。&lt;/p>
&lt;p>然而阿里的 S265 在一众基于 H.265 标准的编码器里并没什么优势。&lt;/p>
&lt;p>事情是这样的 —— 奇点编码器参加的这个 “ MSU 世界视频编码器大赛 ” 其实有四个比拼项目。&lt;/p>
&lt;p>但是根据主办方的说法，YUY-SSIM 维度才是最重要的指标，其他三个比拼项目只具有 “ 参考意义 ”。&lt;/p>
&lt;p>所以我们可以把它们理解成主擂台，以及分擂台 1、2、3。&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/dk3gg2/1616076594067-aa507a2f-543e-4e29-abba-3e3dec94e3ff.jpeg" alt="">&lt;/p>
&lt;p>然而，主擂台获胜的是一款来自国外的编码器，第二名是字节跳动的 BVC，第三名是爱奇艺的 QAV1，第四名是腾讯的 V265。&lt;/p>
&lt;p>阿里的奇点编码器，排。。。第七。&lt;/p>
&lt;p>至于另外三个分擂台，阿里拿了其中两个第一是没错，但也是和字节、腾讯并列的。。。&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/dk3gg2/1616076594048-3efead86-892d-4a84-9837-ce5502f9b91c.jpeg" alt="">&lt;/p>
&lt;p>然后阿里发了个通稿，我们的视频编码器包揽了两项世界冠军。。。&lt;/p>
&lt;p>话说的倒都是实话，可就是没说全。&lt;/p>
&lt;p>这个说法的确没什么错，况且近期阿里的负面有点儿多，宣传奇点编码器得奖是个冲喜的好办法。&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/dk3gg2/1616076594043-65b18125-f709-4049-9c3f-2c50859100b2.jpeg" alt="">&lt;/p>
&lt;p>但是这件事翻车就翻车在了，通稿把奇点编码器渲染的有点神 —— 压缩上千倍画质无损，两项世界第一。&lt;/p>
&lt;p>稍微对这方面技术不太了解的小伙伴看着都会发懵，这个就有点儿误导人了。。。&lt;/p>
&lt;p>小明考试拿了 100 分，可喜可贺。&lt;/p>
&lt;p>小明和同班十几个人一起考出了 100 分的好成绩，势均力敌。&lt;/p>
&lt;p>小明和同班十几个人一起考出了 100 分的好成绩，但只有小明家张灯结彩、走街串巷，仿佛完成了一件前无古人后无来者的壮举。。。&lt;/p>
&lt;p>也不知道最后尴尬的会是谁。&lt;/p></description></item><item><title>Docs: 图像的编码与解码</title><link>https://desistdaydream.github.io/docs/8.%E9%80%9A%E7%94%A8%E6%8A%80%E6%9C%AF/%E7%BC%96%E7%A0%81%E4%B8%8E%E8%A7%A3%E7%A0%81/%E5%9B%BE%E5%83%8F%E7%9A%84%E7%BC%96%E7%A0%81%E4%B8%8E%E8%A7%A3%E7%A0%81/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/8.%E9%80%9A%E7%94%A8%E6%8A%80%E6%9C%AF/%E7%BC%96%E7%A0%81%E4%B8%8E%E8%A7%A3%E7%A0%81/%E5%9B%BE%E5%83%8F%E7%9A%84%E7%BC%96%E7%A0%81%E4%B8%8E%E8%A7%A3%E7%A0%81/</guid><description>
&lt;blockquote>
&lt;p>参考： &lt;a href="https://en.wikipedia.org/wiki/Pixel">Wiki-Pixel(像素)&lt;/a> &amp;gt; &lt;a href="https://en.wikipedia.org/wiki/Image_resolution">Wiki-Image resolution(分辨率)&lt;/a> &amp;gt; &lt;a href="https://en.wikipedia.org/wiki/Raster_graphics">Wiki-Raster graphics(光栅图像)&lt;/a>&lt;/p>
&lt;/blockquote>
&lt;p>图像的编码 和 字符的编码 其实本质上都是使用二进制来进行 编/解码。&lt;/p>
&lt;h1 id="图像">图像&lt;a class="td-heading-self-link" href="#%e5%9b%be%e5%83%8f" aria-label="Heading self-link">&lt;/a>&lt;/h1>
&lt;p>想要了解图像的编码/解码，首先要明确一下图片的组成&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/azfrs3/1616478942730-94a24042-83ae-40c0-865a-d13c1164c61b.png" alt="encoding.png">&lt;/p>
&lt;p>这个图，如果放到编辑器中，然后无限放大，会看到这种效果：&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/azfrs3/1616478986453-7a25a9b3-f527-4491-b565-9154ca324d7f.png" alt="image.png">&lt;/p>
&lt;p>从这里可以看到，一张图片，其实就是很多很多的小方块组成的，每个小方块，都称之为 &lt;strong>Pixel(像素)&lt;/strong>。&lt;/p>
&lt;h2 id="piexl像素">Piexl(像素)&lt;a class="td-heading-self-link" href="#piexl%e5%83%8f%e7%b4%a0" aria-label="Heading self-link">&lt;/a>&lt;/h2>
&lt;p>&lt;strong>Picture Element(图像元素，简称 Pel)&lt;/strong>，也就是常常听说的 &lt;strong>Piexl(像素)&lt;/strong>。在&lt;a href="https://en.wikipedia.org/wiki/Digital_imaging">数字成像中&lt;/a>，像素是&lt;a href="https://en.wikipedia.org/wiki/Raster_graphics">光栅图像&lt;/a>中最小的可寻址元素，或者是&lt;a href="https://en.wikipedia.org/wiki/All_points_addressable">全点可寻址&lt;/a> &lt;a href="https://en.wikipedia.org/wiki/Display_device">显示设备中&lt;/a>的最小可寻址元素；因此，它是屏幕上所显示图片的最小可控元素。&lt;/p>
&lt;p>每个像素都是原始图像的&lt;a href="https://en.wikipedia.org/wiki/Sampling_(signal_processing)">样本&lt;/a>；通常，更多的样本会提供对原件的更准确的表示。每个像素的&lt;a href="https://en.wikipedia.org/wiki/Intensity_(physics)">强度&lt;/a>是可变的。在彩色成像系统中，颜色通常由三个或四个分量强度来表示，例如&lt;a href="https://en.wikipedia.org/wiki/RGB_color_model">红色，绿色和蓝色&lt;/a>，或&lt;a href="https://en.wikipedia.org/wiki/CMYK_color_model">青色，品红色，黄色和黑色&lt;/a>。&lt;/p>
&lt;blockquote>
&lt;p>在一些语境中(如描述&lt;a href="https://en.wikipedia.org/wiki/Camera_sensor">相机传感器&lt;/a>)，_像素 &lt;em>指的是多组分表示的单个标量元素（称为_感光点_在相机传感器上下文中，虽然&lt;/em>&lt;a href="https://en.wiktionary.org/wiki/sensel">传感器个体&lt;/a>_有时使用），&lt;a href="https://en.wikipedia.org/wiki/Pixel#cite_note-3">[3]&lt;/a>而在其它上下文中它可以指的是空间位置的一组分量强度。&lt;/p>
&lt;/blockquote>
&lt;p>一般情况下，电脑中的颜色都是使用三原色混合而成，比如：&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/azfrs3/1616548024130-3762a0c9-6f90-4c9a-811b-e5dc6203bf0e.png" alt="image.png">&lt;/p>
&lt;p>可以看到，每个颜色都有一个数字表示，而 RGB 就是三原色，不用强度的三原色，就会组成不同强度的新颜色。&lt;/p>
&lt;h2 id="image-resolution图像分辨率">Image Resolution(图像分辨率)&lt;a class="td-heading-self-link" href="#image-resolution%e5%9b%be%e5%83%8f%e5%88%86%e8%be%a8%e7%8e%87" aria-label="Heading self-link">&lt;/a>&lt;/h2>
&lt;p>&lt;strong>Image Resolution(图像分辨率)&lt;/strong> 指图像可以存在的细节，分辨率仅适用于 &lt;a href="https://en.wikipedia.org/wiki/Raster_graphics">光栅图像&lt;/a>。一般是指单位英寸中所包含的像素个数。
用白话说，分辨率就是判断一张图片清晰度的重要标志，而上文提到的 像素，就是分辨率的一部分。通常，分辨率可以通过如下几种方式来判断&lt;/p>
&lt;ul>
&lt;li>像素数&lt;/li>
&lt;li>空间分辨率&lt;/li>
&lt;li>光谱分辨率&lt;/li>
&lt;li>时间分辨率&lt;/li>
&lt;li>辐射分辨率&lt;/li>
&lt;/ul>
&lt;p>大部分时候，其实主要就是以像素的数量来决定一张图像的分辨率，比如：&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/azfrs3/1616547515643-ebb48cfe-1919-453c-96d5-02d3b173118b.png" alt="image.png">&lt;/p>
&lt;p>而 像素密度 与 像素总数，又是判断分辨率所具有像素数的两个重要指标&lt;/p>
&lt;ul>
&lt;li>&lt;strong>像素密度&lt;/strong> # 单位长度内的像素数量除以单位长度，单位为 PPI（Pixels Per Inch）。像素密度越高，说明像素越密集，5PPI 表示每英寸有 5 个像素，500PPI 表示每英寸有 500 个像素，PPI 的数值高，图片和视频的清晰度就更高。&lt;/li>
&lt;li>&lt;strong>像素总数&lt;/strong> # 图片、影像的单独一帧图所含像素的数量，单位为像素，计算方式为长边的像素个数乘以短边的像素个数。&lt;/li>
&lt;/ul>
&lt;p>宽度为 2048 像素，高度为 1536 像素的图像总计 2048×1536 = 3,145,728 像素或 3.1 兆像素。人们可以将其称为 2048 x 1536 或 3.1 兆像素的图像。如果以大约 28.5 英寸宽打印，则图像将是质量很差的图像（72ppi），但是如果以大约 7 英寸宽打印，则图像的质量将非常好（300ppi）&lt;/p>
&lt;p>这也就解释了，为什么一张图像，放在很小的地方看上去很清晰，而放在很大的地方，看上去就就相当模糊(其实就是代表像素的小方块都显示出来了)&lt;/p>
&lt;p>人眼可以识别的图形是有限的，当一个像素一直缩小，从人类眼中，就好像是一个点，而很多很多不用颜色的点，组成了一张图像，也就是我们所说的非常清晰的图像。&lt;/p>
&lt;h2 id="图像的组成">图像的组成&lt;a class="td-heading-self-link" href="#%e5%9b%be%e5%83%8f%e7%9a%84%e7%bb%84%e6%88%90" aria-label="Heading self-link">&lt;/a>&lt;/h2>
&lt;p>像素是组成图像最小单位，每个像素都是一个纯色的色块&lt;/p>
&lt;h1 id="位图-与-矢量图">位图 与 矢量图&lt;a class="td-heading-self-link" href="#%e4%bd%8d%e5%9b%be-%e4%b8%8e-%e7%9f%a2%e9%87%8f%e5%9b%be" aria-label="Heading self-link">&lt;/a>&lt;/h1>
&lt;blockquote>
&lt;p>上文描述的图像，都是指位图&lt;/p>
&lt;/blockquote>
&lt;p>&lt;strong>Raster Graphic(光栅图像)&lt;/strong> 是一种点阵数据结构，它表示可通过计算机显示器、纸张或其他显示介质查看的大致矩形的像素网络(像素点)。&lt;strong>也称为 Bitmap(位图)&lt;/strong>。&lt;/p>
&lt;p>&lt;strong>Vector Graphics(矢量图象)&lt;/strong> 是根据笛卡尔平面上的点定义的计算机图像，这些点通过直线和曲线连接以形成多边形和其他形状。&lt;/p>
&lt;p>位图无法无限放大，不管放大到多少，最后都是一个一个的像素。而矢量图则不会出现这种问题，矢量图是基于数学方程的几何图形，不管放大多少倍，也不会失真。
可是矢量图一般只能表示一些简单的图形，因为需要很明显的线条曲线。常用来制作品牌 logo、指示牌等等。而色彩丰富的图像，比如人像等等，就无法使用简单的图形或者数学方程来表示了。&lt;/p>
&lt;p>所以矢量图常用来做设计，而位图则一般用来描述照片。&lt;/p>
&lt;h1 id="图像的编码">图像的编码&lt;a class="td-heading-self-link" href="#%e5%9b%be%e5%83%8f%e7%9a%84%e7%bc%96%e7%a0%81" aria-label="Heading self-link">&lt;/a>&lt;/h1>
&lt;p>图像编码的原理，就是把每个像素的颜色，转换成数字，然后按照顺序，把所有像素的颜色数值都存储起来。并且给每一个像素一个坐标，由 像素坐标 与 像素颜色 组成的，就是电脑中的一张图像，而 像素坐标 与 像素颜色 都是可以使用字符表示，进而转换为二进制的。&lt;/p>
&lt;p>图像的清晰度越高，像素数也就越多，转换成二进制所需要占用的空间也就越高。。。这也是为什么一张图片要比一串字符占用空间要大这么多的重要原因。&lt;/p>
&lt;p>因此，也就催生出了图像压缩的需求。需要根据某种算法，可以缩小图像所占用的空间。&lt;/p>
&lt;h2 id="图像压缩">图像压缩&lt;a class="td-heading-self-link" href="#%e5%9b%be%e5%83%8f%e5%8e%8b%e7%bc%a9" aria-label="Heading self-link">&lt;/a>&lt;/h2>
&lt;p>那些 jpeg、png 等等格式，都是指压缩的方式，与字符编码中 UTF-8 之于 Unicode 类似。&lt;/p></description></item><item><title>Docs: 音频的编码与解码</title><link>https://desistdaydream.github.io/docs/8.%E9%80%9A%E7%94%A8%E6%8A%80%E6%9C%AF/%E7%BC%96%E7%A0%81%E4%B8%8E%E8%A7%A3%E7%A0%81/%E9%9F%B3%E9%A2%91%E7%9A%84%E7%BC%96%E7%A0%81%E4%B8%8E%E8%A7%A3%E7%A0%81/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/8.%E9%80%9A%E7%94%A8%E6%8A%80%E6%9C%AF/%E7%BC%96%E7%A0%81%E4%B8%8E%E8%A7%A3%E7%A0%81/%E9%9F%B3%E9%A2%91%E7%9A%84%E7%BC%96%E7%A0%81%E4%B8%8E%E8%A7%A3%E7%A0%81/</guid><description>
&lt;p>声音的本质就是波，波都是有频率的，频率就是指波在一秒钟震动的次数，单位是 Hz(赫兹)。&lt;/p>
&lt;p>计算机除了记录声音的频率，还要记录在不同频率上，声音的幅度大小。&lt;/p>
&lt;p>而想要出现声音，其实是离不开时间的，没有时间的流逝，也就不会产生声音&lt;/p>
&lt;p>所以，计算机就需要对声音进行采样，记录每时每刻声音的频率和幅度，采样频率越高，声音也就越逼真&lt;/p>
&lt;p>远程同话一般是每秒8000次的采样频率，而音乐CD则是每秒44100次的采样频率&lt;/p>
&lt;p>每次采样，都会将频率和幅度，然后将其转换为字符，进而编码为二进制。&lt;/p></description></item><item><title>Docs: 字符的编码与解码</title><link>https://desistdaydream.github.io/docs/8.%E9%80%9A%E7%94%A8%E6%8A%80%E6%9C%AF/%E7%BC%96%E7%A0%81%E4%B8%8E%E8%A7%A3%E7%A0%81/%E5%AD%97%E7%AC%A6%E7%9A%84%E7%BC%96%E7%A0%81%E4%B8%8E%E8%A7%A3%E7%A0%81/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/8.%E9%80%9A%E7%94%A8%E6%8A%80%E6%9C%AF/%E7%BC%96%E7%A0%81%E4%B8%8E%E8%A7%A3%E7%A0%81/%E5%AD%97%E7%AC%A6%E7%9A%84%E7%BC%96%E7%A0%81%E4%B8%8E%E8%A7%A3%E7%A0%81/</guid><description/></item></channel></rss>