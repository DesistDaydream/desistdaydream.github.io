<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Bash 内置命令 on 断念梦的站点</title><link>https://desistdaydream.github.io/docs/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Terminal-%E4%B8%8E-Shell/Bash/Bash-%E5%86%85%E7%BD%AE%E5%91%BD%E4%BB%A4/</link><description>Recent content in Bash 内置命令 on 断念梦的站点</description><generator>Hugo</generator><language>zh-cn</language><atom:link href="https://desistdaydream.github.io/docs/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Terminal-%E4%B8%8E-Shell/Bash/Bash-%E5%86%85%E7%BD%AE%E5%91%BD%E4%BB%A4/index.xml" rel="self" type="application/rss+xml"/><item><title>Bash 内置命令</title><link>https://desistdaydream.github.io/docs/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Terminal-%E4%B8%8E-Shell/Bash/Bash-%E5%86%85%E7%BD%AE%E5%91%BD%E4%BB%A4/Bash-%E5%86%85%E7%BD%AE%E5%91%BD%E4%BB%A4/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Terminal-%E4%B8%8E-Shell/Bash/Bash-%E5%86%85%E7%BD%AE%E5%91%BD%E4%BB%A4/Bash-%E5%86%85%E7%BD%AE%E5%91%BD%E4%BB%A4/</guid><description>概述 参考：
Manual(手册)，bash(1) - Shell 内置命令 别名 https://www.man7.org/linux/man-pages/man1/bash.1.html#ALIASES
alias unalias</description></item><item><title>Job control</title><link>https://desistdaydream.github.io/docs/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Terminal-%E4%B8%8E-Shell/Bash/Bash-%E5%86%85%E7%BD%AE%E5%91%BD%E4%BB%A4/Job-control/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Terminal-%E4%B8%8E-Shell/Bash/Bash-%E5%86%85%E7%BD%AE%E5%91%BD%E4%BB%A4/Job-control/</guid><description>概述 参考：
Manual(手册)，Bash(1) - JOB_CONTROL Job control(作业控制) 是指有选择的停止/挂起进程的执行，并在稍后继续/恢复它们的执行能力。我们一般都是在 Shell 中使用此功能的，比如 Bash。
在前台执行的程序为前台 JOB，前台程序占用一个 shell，执行该程序后，shell 无法再进行别的操作
在后台执行的程序为后台 JOB，后台程序不占用 shell，可以在该 shell 下继续执行其余任务，不受 ctrl+c 的影响
常见操作：
ctrl+z # 在正在运行的 porcess 中使用这个组合键，可以让前台进程暂停 fg %JobNumber # 让后台的进程在前台工作 bg %JobNumber # 让前台的工作在后台工作 nohup COMMAND # 让命令触发的进程不随 shell 关闭而停止 COMMAND &amp;amp; # 让命令触发的进程直接在后台运行 jobs 命令 Syntax(语法) 查看 jobs
jobs [OPTIONS]
OPTIONS：
-l # 查看 jobs 的详细信息</description></item><item><title>变量管理工具</title><link>https://desistdaydream.github.io/docs/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Terminal-%E4%B8%8E-Shell/Bash/Bash-%E5%86%85%E7%BD%AE%E5%91%BD%E4%BB%A4/%E5%8F%98%E9%87%8F%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Terminal-%E4%B8%8E-Shell/Bash/Bash-%E5%86%85%E7%BD%AE%E5%91%BD%E4%BB%A4/%E5%8F%98%E9%87%8F%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/</guid><description>export 设置或显示环境变量(export 的效力仅作用于该次登陆操作)。
Syntax(语法) export [OPTIONS] [VarName[=VALUE] &amp;hellip;]
用户创建的变量仅可用于当前 Shell，子 Shell 默认读取不到父 Shell 定义的变量。为了把变量传递给子 Shell，需要使用 export 命令。这样输出的变量，对于子 Shell 来说就是环境变量。
OPTIONS
-f # 代表[NAME]中为函数名称 -n # 删除指定的变量。变量实际上并未删除，只是不会输出到后续指令的执行环境中 -p # 列出所有的 shell 赋予程序的环境变量。 EXAMPLE export VarName=&amp;ldquo;Value&amp;rdquo;
export VarName
declare 参考:
Manual(手册)，bash(1)-Shell 内置命令 - declare 声明 shell 变量。declare 为 shell 命令，在第一种语法中可用来声明变量并设置变量的属性，在第二种语法中可用来显示 shell 函数。若不加上任何参数，则会显示全部的 shell 变量与函数(与执行 set 指令的效果相同)。
Syntax(语法) declare [+/-][OPTIONS] VarName
OPTIONS
- # 给变量添加类型属性 + # 取消变量的类型属性 变量类型选项 -a # 将变量声明为数组型 -A # 将变量声明为关联数组类型（i.</description></item><item><title>set 命令</title><link>https://desistdaydream.github.io/docs/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Terminal-%E4%B8%8E-Shell/Bash/Bash-%E5%86%85%E7%BD%AE%E5%91%BD%E4%BB%A4/set-%E5%91%BD%E4%BB%A4/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Terminal-%E4%B8%8E-Shell/Bash/Bash-%E5%86%85%E7%BD%AE%E5%91%BD%E4%BB%A4/set-%E5%91%BD%E4%BB%A4/</guid><description>概述 参考：
GNU 文档，Bash 参考手册-Shell 内置命令-修改 Shell 行为-Set 内置命令 https://morven.life/posts/how-to-write-robust-shell-script/ 前言 Shell 脚本会有各种坑，经常导致 Shell 脚本因为各种原因不能正常执行成功。实际上，编写健壮可靠的 Shell 脚本也是有一定的技巧的。
# 在执行Shell脚本的时候，通常都会创建一个新的Shell，比如，当我们执行： bash script.sh Bash 会创建一个新的 Shell 来执行 script.sh，同时也默认给定了这个执行环境的各种参数。set 命令可以用来修改 Shell 环境的运行参数，不带任何参数的 set 命令，会显示所有的环境变量和 Shell 函数。我们重点介绍其中最常用的四个。
set -euxo pipefail
set -x 默认情况下，Shell 脚本执行后只显示运行结果，不会展示结果是哪一行代码的输出，如果多个命令连续执行，它们的运行结果就会连续输出，导致很难分清一串结果是什么命令产生的。 set -x 用来在运行结果之前，先输出执行的那一行命令，行首以+表示是命令而非命令输出，同时，每个命令的参数也会展开，我们可以清晰地看到每个命令的运行实参，这对于 Shell 的 debug 来说非常友好。
#!/bin/bash set -x v=5 echo $v echo &amp;#34;hello&amp;#34; # output: # + v=5 # + echo 5 # 5 # + echo hello # hello 实际上，set -x 还有另一种写法 set -o xtrace。</description></item><item><title>管道符等组合命令</title><link>https://desistdaydream.github.io/docs/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Terminal-%E4%B8%8E-Shell/Bash/Bash-%E5%86%85%E7%BD%AE%E5%91%BD%E4%BB%A4/%E7%AE%A1%E9%81%93%E7%AC%A6%E7%AD%89%E7%BB%84%E5%90%88%E5%91%BD%E4%BB%A4/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Terminal-%E4%B8%8E-Shell/Bash/Bash-%E5%86%85%E7%BD%AE%E5%91%BD%E4%BB%A4/%E7%AE%A1%E9%81%93%E7%AC%A6%E7%AD%89%E7%BB%84%E5%90%88%E5%91%BD%E4%BB%A4/</guid><description>| (管道符) 把 | 前面的标准输出内容当作 | 后面的标准输入内容
EXAMPLE
~]# echo &amp;#34;--help&amp;#34; | cat --help echo “&amp;ndash;help” | cat # 把&amp;ndash;help 当作 cat 的标准输入输出到屏幕上，如图所示，注意与 xargs 应用实例 a 的区别 exec Syntax(语法) exec [-cl] [-a name] [COMMAND [ARGUMENTS&amp;hellip;]]
如果指定了 command，它将替换 shell。 没有创建新进程。 参数成为命令的参数。 如果提供了-l 选项，则 shell 会在传递给 command 的第 0 个参数的开头放置一个破折号。 这是 login(1) 的作用。 -c 选项导致命令在空环境中执行。 如果提供了-a，则 shell 将 name 作为第 0 个参数传递给执行的命令。 如果由于某种原因无法执行命令，则会退出非交互式 shell，除非启用了 shell 选项 execfail，在这种情况下它将返回失败。 如果无法执行文件，则交互式 shell 将返回失败。 如果未指定 command，则任何重定向在当前 shell 中生效，返回状态为 0.</description></item></channel></rss>