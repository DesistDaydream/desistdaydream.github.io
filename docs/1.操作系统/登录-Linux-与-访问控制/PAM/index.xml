<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>PAM on 断念梦的站点</title><link>https://desistdaydream.github.io/docs/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E7%99%BB%E5%BD%95-Linux-%E4%B8%8E-%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6/PAM/</link><description>Recent content in PAM on 断念梦的站点</description><generator>Hugo</generator><language>zh-cn</language><atom:link href="https://desistdaydream.github.io/docs/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E7%99%BB%E5%BD%95-Linux-%E4%B8%8E-%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6/PAM/index.xml" rel="self" type="application/rss+xml"/><item><title>PAM</title><link>https://desistdaydream.github.io/docs/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E7%99%BB%E5%BD%95-Linux-%E4%B8%8E-%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6/PAM/PAM/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E7%99%BB%E5%BD%95-Linux-%E4%B8%8E-%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6/PAM/PAM/</guid><description>概述 参考：
GitHub 项目，linux-pam 官方文档已停止更新不再维护 Manual(手册)，PAM(8) Wiki, PAM Wiki, Linux PAM 博客园，Linux 下 PAM 模块学习总结 博客园，PAM(Pluggable Authentication Modules)认证机制详情 https://www.redhat.com/sysadmin/pluggable-authentication-modules-pam 金步国，Linux PAM 学习笔记 Pluggable Authentication Modules(可插入式认证模块，简称 PAM) 是由 Sun 提出的一种认证机制。它通过提供一些动态链接库和一套统一的 API，将系统提供的服务和该服务的认证方式分开，使得系统管理员可以灵活地根据需要给不同的服务配置不同的认证方式而无需更改服务程序，同时也便于向系统中添加新的认证手段。
在过去，我们想要对一个使用者进行 Authentication(认证)，得要要求用户输入账号密码，然后通过自行撰写的程序来判断该账号密码是否正确。也因为如此，我们常常使用不同的机制来判断账号密码，所以搞的一部主机上面拥有多个各别的认证系统，也造成账号密码可能不同步的验证问题！为了解决这个问题因此有了 PAM 的机制！
以常见的 su 命令来说，它可以实现用户切换，从 root 切换至其他用户不需要密码、从非 root 用户切换至其他用户则需要验证目标用户的密码，一旦认证成功就以目标用户身份启动 shell 以供使用。本质上，su 只做两件事：(1)认证；(2)启动 shell 。按照传统思路，两件事都很容易实现，例如认证逻辑可以用伪代码这样简单的描述：
if ( uid == 0 ) 认证成功 elseif ( 输入的密码 == 目标用户的密码 ) 认证成功 else 认证失败 但是，认证需求不是一成不变的。例如：
(1)为了方便运维团队成员(也就是 wheel 组)，希望 wheel 组中的用户无需输入密码也能直接进行用户切换； (2)为了加强安全性，希望额外验证手机短信； (3)为了避免频繁输入难记的用户密码，希望可以选用指纹方式进行验证； (4)为了方便某个特定的用户测试，希望仅凭手机短信也能完成验证 &amp;hellip;&amp;hellip; 这样一来， su 的开发者将会被迫不断更改 su 的源代码，然后再重新调试、编译、分发，非常辛苦。这种情况下，PAM 就可以对 su 开发者说：&amp;ldquo;认证的事交给我，能不能通过认证由我说了算，你只需做好其他事情(启动 shell)即可&amp;rdquo;；同时又对用户(系统管理员)说：&amp;ldquo;只要学会了 PAM 配置语法，就可以利用各种 PAM 模块，编写出千变万化的认证策略。无需打扰 su 开发者，就能立即得到想要的效果&amp;rdquo;。通过把与认证相关的脏活累活都交给 PAM 来干， su 的开发者与用户之间实现了解耦，彼此皆大欢喜。</description></item><item><title>PAM 配置文件</title><link>https://desistdaydream.github.io/docs/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E7%99%BB%E5%BD%95-Linux-%E4%B8%8E-%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6/PAM/PAM-%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E7%99%BB%E5%BD%95-Linux-%E4%B8%8E-%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6/PAM/PAM-%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/</guid><description>概述 参考：
Manual(手册)，pam.conf(5) 这是一个最基本的配置文件示例：
#%PAM-1.0 auth required pam_deny.so account required pam_deny.so password required pam_deny.so session required pam_deny.so Syntax(语法) PAM 配置文件由 Rules(规则) 列表组成，每条规则一行。规则是由空格分割的多个 Tokens 组成
不知道官方为什么把每个字段要称为 Token 。。。o(╯□╰)o
Service Type Control Module-Path Module-Arguments
Service # 需要调用 PAM 的应用程序的名称。比如 su、login、sshd 等等 注意：/etc/pam.conf 和 /etc/pam.d/* 配置文件有一点差别，在于 Service 字段。/etc/pam.d/ 目录下的所有配置文件，没有 Service 字段，取而代之的是文件名称，也就是说，Service 字段的值，就是 /etc/pam.d/ 目录下的文件名。 Type # 管理类型，这个类型就是 《Linux-PAM 管理组(认证功能的分组)》 的简写。即.本条规则中使用的模块要与哪个管理组关联。 可用的类型有 auth、account、password、session 若在类型前面加上 -，则表示即使模块不存在，也不会影响认证结果，也不会将事件记录到日志中。 Control # 规则执行完成后的行为。即调用 PAM API 完成后，会有返回值，根据返回值，决定如何进行后续认证。 Module-Path # 规则调用的 PAM 模块名称，模块默认在 /usr/lib64/security/ 目录(CentOS 系统)下。 不同系统中，模块所在的默认路径可能不一样。 若调用的 PAM 模块不在默认目录下，则该字段需要使用模块的绝对路径。 Module-Arguments # 规则调用的 PAM 模块的参数。每个参数以空格分隔。 Service Service 除了以应用程序命名，还可以使用自定义的名称，这些名称通常通过 include 这种 Control 行为引用该 Service。</description></item><item><title>已弃用模块</title><link>https://desistdaydream.github.io/docs/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E7%99%BB%E5%BD%95-Linux-%E4%B8%8E-%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6/PAM/%E5%B7%B2%E5%BC%83%E7%94%A8%E6%A8%A1%E5%9D%97/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E7%99%BB%E5%BD%95-Linux-%E4%B8%8E-%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6/PAM/%E5%B7%B2%E5%BC%83%E7%94%A8%E6%A8%A1%E5%9D%97/</guid><description>概述 pam_tally2.so 模块 参考：
Manual(手册)，pam_tally2(8) 弃用说明：
GitHub,linux-pam 项目 1.4.0 版本中对 pam_tall2 模块的弃用说明 最后一行 https://access.redhat.com/solutions/62949 https://github.com/dev-sec/ansible-collection-hardening/issues/377 由 pam_faillock 模块代替 登录 Tallying(计数器) 模块
应用场景：设置 Linux 用户连续 N 次输入错误密码进行登陆时，自动锁定 X 分钟或永久锁定（这里的永久锁定指除非进行手工解锁，否则会一直锁定）。
配置 /var/log/faillog #
模块参数 deny=INT # 指定认证失败 deny 次后，将执行后面参数的策略。如锁定 N 秒，如果后面没有其他策略指定时，默认永远锁定，除非手动解锁。 lock_time=INT # 认证失败时锁定 lock_time 秒 unlock_time=INT # 锁定 unlock_time 秒后，自动解锁用户； even_deny_root # root 用户在认证出错时，一样被锁定(该功能慎用) root_unlock_time # root 用户锁定后，多久会解锁。该选项一般是配合 even_deny_root 一起使用的。 magic_root # 如果用户 uid ＝ 0（即 root 账户或相当于 root 的帐户）在帐户认证时调用该模块发现失败时，不计入统计； no_lock_time # 不使用.</description></item></channel></rss>