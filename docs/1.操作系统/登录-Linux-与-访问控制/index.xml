<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>登录 Linux 与 访问控制 on 断念梦的站点</title><link>https://desistdaydream.github.io/docs/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E7%99%BB%E5%BD%95-Linux-%E4%B8%8E-%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6/</link><description>Recent content in 登录 Linux 与 访问控制 on 断念梦的站点</description><generator>Hugo</generator><language>zh-cn</language><atom:link href="https://desistdaydream.github.io/docs/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E7%99%BB%E5%BD%95-Linux-%E4%B8%8E-%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6/index.xml" rel="self" type="application/rss+xml"/><item><title>登录 Linux 与 访问控制</title><link>https://desistdaydream.github.io/docs/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E7%99%BB%E5%BD%95-Linux-%E4%B8%8E-%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6/%E7%99%BB%E5%BD%95-Linux-%E4%B8%8E-%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E7%99%BB%E5%BD%95-Linux-%E4%B8%8E-%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6/%E7%99%BB%E5%BD%95-Linux-%E4%B8%8E-%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6/</guid><description>概述 参考：
想要登录 Linux，必须通过 Terminal(终端)，我们才可以与操作系统进行交互。
本质上，想要登录 Linux，必然需要调用某些程序(比如 Shell)，以便分配一个终端。通常，我们有多种方式可供选择：
本地命令行登录 远程命令行登录 图形界面登录 Linux 操作系统是一个多用户操作系统，所以除了 Terminal(终端) 以外，还需 Account(账户) 才可以登录上去，Linux 操作系统允许多个用户访问安装在一台机器上的单个系统。每个 User(用户) 都在自己的 Account(账户) 下操作。因此，Account Manager 代表了 Linux 系统管理的核心要素。
登录 Linux 我们可以通过多种方式登录 Linux
本地登录 远程登录 通过本地 TTY 登陆 Linux 系统 登录 Linux 最基本的方式，就是使用 login 程序。
login 程序 由于历史原因，login 可能被包含在两个包中：
util-linux shadow-utils login 的登录行为 当我们刚刚安装完操作系统，systemd-logind.service 服务会让我们看到这样的画面
想要在服务器本地登录系统，则需要进行认证，在输入用户名之后，实际上是调用了 login 这个二进制程序，看到：
此时我们通过远程方式(如果可以的话)登录服务器，查看进程，将会看到名为 login 的进程
~]$ pgrep login -alf 600 /lib/systemd/systemd-logind 1476 /bin/login -p -- 当我们输入完密码，经过 Access Control(访问控制) 相关程序的认证之后，login 工具会为我们分配一个 ttyX 的终端设备，然后我们就可以通过 tty 所关联的 Shell(通常是 bash)，与系统进行交互</description></item><item><title>TCP Wrappers</title><link>https://desistdaydream.github.io/docs/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E7%99%BB%E5%BD%95-Linux-%E4%B8%8E-%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6/TCP-Wrappers/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E7%99%BB%E5%BD%95-Linux-%E4%B8%8E-%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6/TCP-Wrappers/</guid><description>概述 注意：CentOS8 及 RHEL8 不再支持 TCP_Wrappers！！！！使用 firewalld 代替！！
Transmission Control ProtocolWrappers(简称 TCP_Wrappers) 是一个基于主机的网络访问控制表系统，用于过滤对类 Unix 系统（如 Linux 或 BSD）的网络访问。
其能将主机或子网 IP 地址、名称及 ident 查询回复作为筛选标记，实现访问控制。
Tcp_Wrappers 特点 工作在第四层（传输层）的 TCP 协议 对有状态连接的特定服务进行安全检测并实现访问控制 以库文件形式实现 某进程是否接受 libwrap 的控制取决于发起此进程的程序在编译时是否针对 libwrap 进行编译的 判断程序是否支持 Tcp_Wrappers 程序如果调用了 libwrap.so 库，表示支持。
ldd 程序路径|grep libwrap.so strings 程序路径|grep libwrap.so #ldd /usr/sbin/sshd|grep libwrap.so libwrap.so.0 =&amp;gt; /lib64/libwrap.so.0 (0x00007f9851678000) #ldd /usr/sbin/vsftpd |grep libwrap.so libwrap.so.0 =&amp;gt; /lib64/libwrap.so.0 (0x00007f802ef50000) #strings `which sshd`|grep libwrap.so libwrap.so.0 TCP_Wrappers 的执行处理机制了 TCP_Wrappers 只需要通过两个文件来处理，/etc/hosts.allow 和/etc/hosts.</description></item></channel></rss>