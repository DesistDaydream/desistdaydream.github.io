<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>断念梦 – RPC</title><link>https://desistdaydream.github.io/docs/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2.Kernel/7.Process/Inter-Process-Communication%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1/RPC/</link><description>Recent content in RPC on 断念梦</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><atom:link href="https://desistdaydream.github.io/docs/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2.Kernel/7.Process/Inter-Process-Communication%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1/RPC/index.xml" rel="self" type="application/rss+xml"/><item><title>Docs: gRPC</title><link>https://desistdaydream.github.io/docs/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2.Kernel/7.Process/Inter-Process-Communication%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1/RPC/gRPC/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2.Kernel/7.Process/Inter-Process-Communication%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1/RPC/gRPC/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://github.com/grpc">GitHub 组织，grpc&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://grpc.io/">官网&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>&lt;strong>Google Remote Procedure Calls(谷歌远程过程调用，简称 gRPC)&lt;/strong> 是一个开源的 RPC 系统，最初于 2015 年在 Google 开发，作为下一代 RPC 基础设施 Stubby。它使用 HTTP/2 进行传输，Protocol Buffers 作为接口描述语言，并提供身份验证、双向流和流量控制、阻塞或非阻塞绑定以及取消和超时等功能。它为多种语言生成跨平台的客户端和服务器绑定。最常见的使用场景包括在微服务风格架构中连接服务，或将移动设备客户端连接到后端服务。&lt;/p>
&lt;p>gRPC 对 HTTP/2 的复杂使用使得无法在浏览器中实现 gRPC 客户端，而是需要代理。&lt;/p>
&lt;h1 id="其他文章">其他文章&lt;/h1>
&lt;p>&lt;a href="https://mp.weixin.qq.com/s/DNHGBCZDdRjBXX0IaIZhwQ">gRPC 长连接在微服务业务系统中的实践&lt;/a>&lt;/p>
&lt;p>&lt;a href="https://mp.weixin.qq.com/s/Kt69BhGFaqYo466R0P7HZQ">公众号-Apifox，找不到好用的 gRPC 调试工具？Apifox 表示我可以！&lt;/a>&lt;/p></description></item><item><title>Docs: RPC</title><link>https://desistdaydream.github.io/docs/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2.Kernel/7.Process/Inter-Process-Communication%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1/RPC/RPC/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2.Kernel/7.Process/Inter-Process-Communication%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1/RPC/RPC/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Remote_procedure_call">Wiki，RPC&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/GRPC">Wiki，gRPC&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://grpc.io/">gRPC 官网&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>在&lt;a href="https://en.wikipedia.org/wiki/Distributed_computing">分布式计算&lt;/a>中，&lt;strong>Remote Procedure Call(远程过程调用，简称 RPC)&lt;/strong> 是计算机程序使 &lt;a href="https://desistdaydream.github.io/docs/2.%E7%BC%96%E7%A8%8B/%E8%A7%A3%E8%B0%9C%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/Function/Function.md">Subroutine&lt;/a> 在不同的地址空间（通常在共享网络上的另一台计算机上）执行时，被编码为 &lt;strong>Local Procedure Call(本地过程调用)&lt;/strong>，而无需程序员为远程交互显式编写细节。也就是说，程序员可以为程序编写相同的代码，而不用关心自己编写的程序将会被本地调用还是远程调用。&lt;/p>
&lt;p>其实 LPC 和 RPC 并不是对比的最佳选择，两者都 IPC 的一种方式，也就是说都是两个进程间通讯的一种方式，可能来说，LPC 与 RPC 最大的区别在于是否基于 TCP/IP 来让两个进程进行通信。而如果从网络间两个进程通信的角度看，RPC 又可以与 HTTP 进行对比。&lt;/p>
&lt;p>从某种角度来说， HTTP 其实就是一种 RPC&lt;/p>
&lt;ul>
&lt;li>HTTP 发起请求的 URL 就是 RPC 发起请求的函数名&lt;/li>
&lt;li>请求体就是函数的参数&lt;/li>
&lt;li>响应体就是函数的函数中的处理逻辑或返回值&lt;/li>
&lt;/ul>
&lt;p>只不过 HTTP 是一个协议(也可以说是一种交互标准)，而 RPC 是一种方式、方法，可以使用 HTTP 来进行 RPC 通信，也可以使用其他协议进行 RPC 通信。如果使用 HTTP 标准进行 RPC 通信，那 RPC 的 C/S 之间就是通过文本格式进行交互；但是 RPC 通信最常使用的是 Protobuf 数据格式进行通信。&lt;/p>
&lt;blockquote>
&lt;p>这里说的使用“HTTP 进行 RPC 通信”指的是使用 xml、json 等格式的数据进行 RPC 通信。而在很多 RPC 框架中，RPC 之间交互的信息与 HTTP 之间交互的信息，是可以互通的！~&lt;/p>
&lt;/blockquote>
&lt;p>&lt;strong>RPC 最常见的场景就是“微服务”&lt;/strong>，将一个大而全的产品拆分成多个服务，如果通过 HTTP 调用，那么调用函数时就需要转换为调用 URL，对于关联性非常难强的多个服务来说，这种交互是灾难性的，如果网络上的多个服务之间，可以直接通过函数调用，那么代码写起来，也是非常简洁的。&lt;/p>
&lt;p>通常来说，如果想要调用第三方平台提供的接口，使用 HTTP，而一个产品中关联性非常强，甚至可以合并成一个服务的多个服务之间的接口调用，就要使用 RPC 了，公司内服务之间的 RPC 调用，可以通过定制化的协议来使得通信更高效。&lt;/p></description></item></channel></rss>