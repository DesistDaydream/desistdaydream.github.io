<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>断念梦 – Netfilter 流量控制系统</title><link>https://desistdaydream.github.io/docs/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2.Kernel/8.Network/Linux-%E7%BD%91%E7%BB%9C%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6/Netfilter-%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6%E7%B3%BB%E7%BB%9F/</link><description>Recent content in Netfilter 流量控制系统 on 断念梦</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><atom:link href="https://desistdaydream.github.io/docs/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2.Kernel/8.Network/Linux-%E7%BD%91%E7%BB%9C%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6/Netfilter-%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6%E7%B3%BB%E7%BB%9F/index.xml" rel="self" type="application/rss+xml"/><item><title>Docs: Netfilter 流量控制系统</title><link>https://desistdaydream.github.io/docs/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2.Kernel/8.Network/Linux-%E7%BD%91%E7%BB%9C%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6/Netfilter-%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6%E7%B3%BB%E7%BB%9F/Netfilter-%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6%E7%B3%BB%E7%BB%9F/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2.Kernel/8.Network/Linux-%E7%BD%91%E7%BB%9C%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6/Netfilter-%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6%E7%B3%BB%E7%BB%9F/Netfilter-%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6%E7%B3%BB%E7%BB%9F/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://www.netfilter.org/index.html">Netfilter 官网&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.netfilter.org/documentation/index.html">Netfilter 官方文档&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Netfilter">Wiki，Netfilter&lt;/a>&lt;/li>
&lt;li>&lt;a href="http://arthurchiao.art/index.html">arthurchiao.art 的文章&lt;/a>：
&lt;ul>
&lt;li>&lt;a href="http://arthurchiao.art/blog/deep-dive-into-iptables-and-netfilter-arch-zh/">[译] 深入理解 iptables 和 netfilter 架构&lt;/a>&lt;/li>
&lt;li>&lt;a href="http://arthurchiao.art/blog/conntrack-design-and-implementation-zh/">连接跟踪（conntrack）：原理、应用及 Linux 内核实现&lt;/a>&lt;/li>
&lt;li>&lt;a href="http://arthurchiao.art/blog/nat-zh/">[译] NAT - 网络地址转换（2016）&lt;/a>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;h2 id="netfilter">Netfilter&lt;/h2>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/gral7u/1616165512374-db897dd5-0704-42f2-a1d8-441af05f247c.jpeg" alt="">&lt;/p>
&lt;p>Netfilter 是 Linux 操作系统核心层内部的一个数据包处理模块集合的统称。一种网络筛选系统，对数据包进入以及出去本机进行的一些控制与管理。该功能的所有模块可以通过下图所示的目录进行查找，其中还包括 ipvs 等。&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/gral7u/1616165512330-720231f3-a4f2-4a51-96cf-137a36724b74.jpeg" alt="">&lt;/p>
&lt;p>Netfilter 项目支持如下功能&lt;/p>
&lt;ul>
&lt;li>网络地址转换(Network Address Translate)&lt;/li>
&lt;li>数据包过滤&lt;/li>
&lt;li>数据包日志记录&lt;/li>
&lt;li>用户空间数据包队列&lt;/li>
&lt;li>其他数据包处理&lt;/li>
&lt;li>等等&lt;/li>
&lt;/ul>
&lt;p>Netfilter Hooks 是 Linux 内核中的一个框架，它会让 Netfilter 的模块在 Linux 网络堆栈的不同位置注册回调函数。然后，为遍历 Linux 网络堆栈中相应 Hook 的每个数据包调用已注册的回调函数。&lt;/p>
&lt;ul>
&lt;li>用白话说：内核加入了 Netfilter 模块后，每个数据包进来之后，都会经过五个 Hooks 点来处理，以便决定每个数据包的走向。&lt;/li>
&lt;/ul>
&lt;h2 id="hooks">Hooks&lt;/h2>
&lt;p>hooks function(钩子函数) 是 Linux 网络栈中的流量检查点。所有流量通过网卡进入内核或从内核出去都会调用 Hook 函数来进行检查，并根据其规则进行过滤。Netfilter 框架中一共有 5 个 Hook，就是下文定义的“五链”。&lt;/p>
&lt;ul>
&lt;li>当一个数据包在其中一个 Hooks 中匹配到自己的规则后，则会进入下一个 Hook 寻找匹配自身的规则，直到将 5 个 Hook 挨个匹配一遍。&lt;/li>
&lt;li>可以把 Hook 想象成地铁站的闸机，通过闸机的人，就是数据流量，这个能不能从闸机过去，则看闸机对这个人身份验证的结果，是放行还是阻止&lt;/li>
&lt;/ul>
&lt;h2 id="iptabelesnftables">iptabeles/nftables&lt;/h2>
&lt;p>工作于用户空间的管理工具，对 5 个 hook 进行规则管理，iptabels 或 nftables 进程，开机后，只是把设定好的规则写进 hook 中&lt;/p>
&lt;p>Netfilter 所设置的规则是存放在内核内存中的，Iptables 是一个应用层(Ring3)的应用程序，它通过 Netfilter 放出的接口来对存放在内核内存中的 Xtables(Netfilter 的配置表)进行修改(这是一个典型的 Ring3 和 Ring0 配合的架构)&lt;/p>
&lt;h1 id="五链chain">五链(Chain)&lt;/h1>
&lt;p>把每个 Hook 上的规则都串起来类似于一条链子，所以称为链，一共 5 个 Hook，所以有 5 个 Chain。每个规则都是由“源 IP、目标 IP、端口、目标”等信息组合起来的。(i.e 对从哪来的或者到哪去的 IP 的哪个端口，要执行什么动作或‘引用什么 Chain 来对这个数据包执行什么动作’)&lt;/p>
&lt;ol>
&lt;li>&lt;strong>PREROUTING 链&lt;/strong> # &lt;strong>路由前&lt;/strong>，处理刚到达本机并在路由转发前的数据包。它会转换数据包中的目标 IP 地址（destination ip address），通常用于 DNAT(destination NAT)。处理完成之后分成两种情况，目的 IP 为本机网口则 INPUT，目的 IP 非本机网口则 FORWARD&lt;/li>
&lt;li>&lt;strong>INPUT 链&lt;/strong> # &lt;strong>进入&lt;/strong>，处理来自外部的数据。&lt;/li>
&lt;li>&lt;strong>FORWARD 链&lt;/strong> # &lt;strong>转发&lt;/strong>，将数据转发到本机的其他网络设备上。(需要开启 linux 的 IP 转发功能 net.ipv4.ip_forward=1 才会进入该流程；就算 ping 的是本机的其余网络设备上的 IP，也是由接收该数据包的网络设备进行回应)，FORWARD 的行为类似于路由器，系统中每个网络设备就是路由器上的每个端口，只有打开转发功能，才可以把数据包路由到其余端口上。
&lt;ol>
&lt;li>虚拟化或容器技术中，如果一台设备中有多个网段，一般都会打开转发功能，以实现不同网段路由互通的效果。&lt;/li>
&lt;li>或者服务器作为 VPN 使用时，由于不同网络设备所属网段不同，也需要打开转发功能。&lt;/li>
&lt;li>等等&lt;/li>
&lt;/ol>
&lt;/li>
&lt;li>&lt;strong>OUTPUT 链&lt;/strong> # &lt;strong>出去&lt;/strong>，处理向外发送的数据。&lt;/li>
&lt;li>&lt;strong>POSTROUTING 链&lt;/strong> # &lt;strong>路由后&lt;/strong>，处理即将离开本机的数据包。它会转换数据包中的源 IP 地址（source ip address），通常用于 SNAT（source NAT）。(该路由是通过 Linux 中定义的 route 规则发送的，与内核的 ip_forward 无关)&lt;/li>
&lt;li>&lt;strong>自定义链&lt;/strong> # 用户自己定义的链，不会调用系统 Hook，而是由系统默认的 5 个链在 target 中定义引用&lt;/li>
&lt;/ol>
&lt;h2 id="规则rule匹配match">规则(Rule)匹配(Match)&lt;/h2>
&lt;p>(规则的匹配条件)匹配的用法详见：&lt;a href="docs/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2.Kernel/8.Network/Linux%20%E7%BD%91%E7%BB%9C%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6/Netfilter%20%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6%E7%B3%BB%E7%BB%9F/iptables/iptables.md">iptables&lt;/a>&lt;/p>
&lt;p>规则，需要有具体的内容才能称为规则，所以 Match 就是规则中的具体内容。&lt;/p>
&lt;p>每条链上的规则，需要对流量进行匹配后才能对该流量进行相应的处理，匹配内容包括“数据包的源地址、目标地址、协议、目标等”，(e.g.这个数据使用哪个协议从哪来的到哪去的目标是什么)&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/gral7u/1616165512349-f2e6f4c5-d617-4b04-a432-f9a7389120df.jpeg" alt="">&lt;/p>
&lt;p>Match 功能的实现依赖于模块(类似于内核的模块)，比如右图，可以使用命令 rpm -ql iptables | grep &amp;ldquo;.so&amp;quot;查看都有哪些模块，其中的 XXX.so 就是各个功能的模块，大写字母是 target 所用的模块，小写字母是基本匹配与扩展匹配所用的模块&lt;/p>
&lt;ul>
&lt;li>基本匹配：源地址、目标地址、协议、入流网卡、出流网卡&lt;/li>
&lt;li>扩展匹配：用于对基本匹配的内容扩充，包括两类，普通的扩展匹配和基于
&lt;ul>
&lt;li>通用扩展匹配，可以直接使用。&lt;/li>
&lt;li>基于基本匹配的扩展匹配。需要有基本匹配规则才可以使用。
&lt;ul>
&lt;li>e.g.需要匹配某些端口，这类匹配必须基于 tcp 匹配规则上使用，否则无效(e.g.-p tcp -m tcp -m multiport &amp;ndash;dport22,23,24)&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>目标(target)：每个规则中的目标。即在每条链上对每个进出流量匹配上之后应该执行什么动作，Target 包括以下几种
&lt;ul>
&lt;li>ACCEPT # 允许流量通过&lt;/li>
&lt;li>REJECT # 拒绝流量通过&lt;/li>
&lt;li>DROP # 丢弃，不响应，发送方无法判断是被拒绝&lt;/li>
&lt;li>RETURN # 返回调用链&lt;/li>
&lt;li>MARK # 做防火墙标记&lt;/li>
&lt;li>用于 nat 表的 target
&lt;ul>
&lt;li>DNAT|SNAT #{目的|源}地址转换&lt;/li>
&lt;li>REDIRECT # 端口重定向&lt;/li>
&lt;li>MASQUERADE # 地址伪装类似于 SNAT，但是不用指明要转换的地址，而是自动选择要转换的地址，用于外部地址不固定的情况&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>用于 raw 表的 target
&lt;ul>
&lt;li>NOTRACK # raw 表专用的 target，用于对匹配规则进行 notrack(不跟踪)处理&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>LOG # 将数据包的相关信息记录日志，执行完该目标后，会继续匹配后面的规则&lt;/li>
&lt;li>引用自定义链 # 直接使用“-j 自定义链的名称”即可，让基本 5 个 Chain 上匹配成功的数据包继续执行自定义链上的规则。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>注意，这里面的路由指数据包在 Linux 本机内部路由&lt;/p>
&lt;h2 id="linux-数据包路由原理iptablesnetfilter-入门学习">Linux 数据包路由原理、Iptables/netfilter 入门学习&lt;/h2>
&lt;p>数据流处理流程简介&lt;/p>
&lt;p>注意：每个数据包在 CHAIN 中匹配到适用于自己的规则之后，则直接进入下一个 CHAIN，而不会遍历 CHAIN 中每条规则去挨个匹配适用于自己的规则。比如下面两种情况&lt;/p>
&lt;p>INPUT 链默认 DROP，匹配第一条：目的端口是 9090 的数据 DROP，然后不再检查下一项，那么 9090 无法访问&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>-P INPUT DROP
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>-A INPUT -p tcp -m tcp --dport &lt;span style="color:#ae81ff">9090&lt;/span> -j DROP
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>-A INPUT -p tcp -m tcp --dport &lt;span style="color:#ae81ff">9090&lt;/span> -j ACCEPT
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>INPUT 链默认 DROP，匹配第一条目的端口是 9090 的数据 ACCEPT，然后不再检查下一条规则，则 9090 可以访问&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>-P INPUT DROP
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>-A INPUT -p tcp -m tcp --dport &lt;span style="color:#ae81ff">9090&lt;/span> -j ACCEPT
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>-A INPUT -p tcp -m tcp --dport &lt;span style="color:#ae81ff">9090&lt;/span> -j DROP
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>匹配条件：根据协议报文特征指定&lt;/p>
&lt;ul>
&lt;li>基本匹配条件&lt;/li>
&lt;li>扩展匹配条件&lt;/li>
&lt;/ul>
&lt;p>处理动作：&lt;/p>
&lt;ul>
&lt;li>内建处理机制&lt;/li>
&lt;li>自定义处理机制&lt;/li>
&lt;li>注意：自定义的链不会有流量经过，而是在主要的 5 链中引用自定义链上的规则，来实现对流量的处理&lt;/li>
&lt;/ul>
&lt;p>下图是从服务器外部进入网卡，再进入网络栈的数据流走向，如果直接是服务器内部服务生成的数据包进入网络栈，则不适用于该图&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/gral7u/1616165512341-aeeeff06-b602-4340-bc4f-cd582144f85f.jpeg" alt="">&lt;/p>
&lt;ol>
&lt;li>当一个数据包进入网卡时，数据包首先进入 PREROUTING 链，在 PREROUTING 链中我们有机会修改数据包的 DestIP(目的 IP)，然后内核的&amp;quot;路由模块&amp;quot;根据&amp;quot;数据包目的 IP&amp;quot;以及&amp;quot;内核中的路由表&amp;quot;判断是否需要转送出去(注意，这个时候数据包的 DestIP 有可能已经被我们修改过了)&lt;/li>
&lt;li>如果数据包就是进入本机的(即数据包的目的 IP 是本机的网口 IP)，数据包就会沿着图向下移动，到达 INPUT 链。数据包到达 INPUT 链后，任何进程都会收到它&lt;/li>
&lt;li>本机上运行的程序也可以发送数据包，这些数据包经过 OUTPUT 链，然后到达 POSTROTING 链输出(注意，这个时候数据包的 SrcIP 有可能已经被我们修改过了)&lt;/li>
&lt;li>如果数据包是要转发出去的(即目的 IP 地址不再当前子网中)，且内核允许转发，数据包就会向右移动，经过 FORWARD 链，然后到达 POSTROUTING 链输出(选择对应子网的网口发送出去)&lt;/li>
&lt;/ol>
&lt;p>出于安全考虑，Linux 系统默认是禁止数据包转发的。所谓转发即当主机拥有多于一块的网卡时，其中一块收到数据包，根据数据包的目的 ip 地址将包发往本机另一网卡，该网卡根据路由表继续发送数据包。这通常就是路由器所要实现的功能。&lt;/p>
&lt;p>配置 Linux 系统的 ip 转发功能，首先保证硬件连通，然后打开系统的转发功能，less /proc/sys/net/ipv4/ip_forward，该文件内容为 0，表示禁止数据包转发，1 表示允许，将其修改为 1。可使用命令 echo &amp;ldquo;1&amp;rdquo; &amp;gt; /proc/sys/net/ipv4/ip_forward 修改文件内容，重启网络服务或主机后效果不再。若要其自动执行，可将命令 echo &amp;ldquo;1&amp;rdquo; &amp;gt; /proc/sys/net/ipv4/ip_forward 写入脚本/etc/rc.d/rc.local 或者 在/etc/sysconfig/network 脚本中添加 FORWARD_IPV4=&amp;ldquo;YES&amp;rdquo;&lt;/p>
&lt;h1 id="natnetwork-address-translation网络地址转换">NAT(Network Address Translation)网络地址转换&lt;/h1>
&lt;p>NAT 为了安全性而产生的，主要用来隐藏本地主机的 IP 地址&lt;/p>
&lt;h2 id="snat---source-源地址转换针对请求报文的源地址而言">SNAT - Source 源地址转换，针对请求报文的源地址而言&lt;/h2>
&lt;p>当想访问外网的时候，把源地址转换，作用于 POSTROUTING 链&lt;/p>
&lt;p>常用于内网私网地址转换成公网地址，比如家用路由器&lt;/p>
&lt;h2 id="dnat---destination-目的地址转换针对请求报文的目标地址而言">DNAT - Destination 目的地址转换，针对请求报文的目标地址而言&lt;/h2>
&lt;p>当从外部访问某 IP 时，把目的 IP 转换，作用于 PREROUTING、FORWARD 链&lt;/p>
&lt;p>把内网中的服务器发布到外网中去，&lt;/p>
&lt;p>常用于公网访问一个公司的公网 IP，但是由私网 IP 来提供服务，比如 LVS 的 nat 模型&lt;/p>
&lt;p>比如在公司内网中提供一个 web 服务，但是由于是私网地址，来自互联网的任何请求无法送达这台 web 服务器，这时候我们可以对外宣称公司的 web 服务在一个公网的 IP 地址上，但是公网的 IP 地址所在服务器上又没有提供 web 服务，这时候，来自外网访问的请求，全部 DNAT 成私网 IP，即可对外提供请求。&lt;/p>
&lt;h2 id="注意">注意&lt;/h2>
&lt;p>由于 SNAT 与 DNAT 在描述的时候主要是都是针对请求报文而言的，那么当地址转换以后，响应报文响应的是转换后的地址，这时候就无法把响应请求送还给发起请求的设备了，这怎么办呢？这时候，同样需要一个地址转换，只不过通过 NAT 机制自行完成的，如何自动完成呢？这里面会有一个连接追踪机制，跟踪每一个数据连接（详见：&lt;a href="docs/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2.Kernel/8.Network/Linux%20%E7%BD%91%E7%BB%9C%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6/Connnection%20Tracking(%E8%BF%9E%E6%8E%A5%E8%B7%9F%E8%B8%AA).md">Connnection Tracking(连接跟踪)&lt;/a>），当响应报文到来的时候，根据连接追踪表中的信息记录的请求报文是怎么转换的相关信息，来对响应报文进行 NAT 转换。&lt;/p></description></item><item><title>Docs: Connection Tracking(连接跟踪)机制</title><link>https://desistdaydream.github.io/docs/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2.Kernel/8.Network/Linux-%E7%BD%91%E7%BB%9C%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6/Netfilter-%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6%E7%B3%BB%E7%BB%9F/Connection-Tracking%E8%BF%9E%E6%8E%A5%E8%B7%9F%E8%B8%AA%E6%9C%BA%E5%88%B6/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2.Kernel/8.Network/Linux-%E7%BD%91%E7%BB%9C%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6/Netfilter-%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6%E7%B3%BB%E7%BB%9F/Connection-Tracking%E8%BF%9E%E6%8E%A5%E8%B7%9F%E8%B8%AA%E6%9C%BA%E5%88%B6/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://conntrack-tools.netfilter.org/manual.html">Netfilter 官方文档，连接跟踪工具用户手册&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://opengers.github.io/openstack/openstack-base-netfilter-framework-overview/">云计算基层技术-netfilter 框架研究&lt;/a>&lt;/li>
&lt;li>&lt;a href="http://arthurchiao.art/index.html">arthurchiao.art 的文章&lt;/a>
&lt;ul>
&lt;li>&lt;a href="http://arthurchiao.art/blog/conntrack-design-and-implementation-zh/">连接跟踪（conntrack）：原理、应用及 Linux 内核实现&lt;/a>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>&lt;strong>Connection Tracking(连接跟踪系统，简称 ConnTrack、CT)&lt;/strong>，用于跟踪并且记录连接状态。Linux 为每一个经过网络堆栈的数据包，生成一个 &lt;strong>ConnTrack Entry(连接跟踪条目，简称 Entry)&lt;/strong>，并把该条目记录在一个 &lt;strong>ConnnTrack Table(连接跟踪表)&lt;/strong> 中，条目中主要是包含该连接的协议、源 IP 和 PORT、目标 IP 和 PORT、协议号、数据包的大小等等等信息。此后，在处理数据包时读取该文件，在文件中所有属于此连接的数据包都被唯一地分配给这个连接，并标识连接的状态。该文件中的每一个条目都有一个持续时间，当持续时间结束后，该连接会被自动清除，再有相同的连接进来的时候，则按照新连接来处理。Netfilter 中定义了如下几个连接状态以便对具有这些状态的连接进行处理：&lt;/p>
&lt;p>可跟踪的连接状态有以下几个&lt;/p>
&lt;ol>
&lt;li>&lt;strong>NEW&lt;/strong> # 新发出的请求。在连接跟踪文件中(nf_conntrack)不存在此连接。&lt;/li>
&lt;li>&lt;strong>ESTABLISHED&lt;/strong> # 已建立的。NEW 状态之后，在 nf_conntrack 文件中为其建立的条目失效之前所进行的通信的状态&lt;/li>
&lt;li>&lt;strong>RELATED&lt;/strong> # 有关联的。某个已经建立的连接所建立的新连接；e.g.FTP 的数据传输连接就是控制连接所 RELATED 出来的连接。–icmp-type 8(ping 请求)就是–icmp-type 0(ping 应答) 所 RELATED 出来的。&lt;/li>
&lt;li>&lt;strong>INVALIED&lt;/strong> # 无法识别的连接。&lt;/li>
&lt;li>&lt;strong>UNTRACKED&lt;/strong> # 不跟踪的链接状态，仅在使用 raw 表的时候该状态才有用，即 raw 不进行链接跟踪的时候，则连接跟踪表中没有记录的数据包就是此状态&lt;/li>
&lt;li>其他：
&lt;ol>
&lt;li>NEW 与 ESTABLISHED 的定义：只要第一次请求就算 NEW(e.g.本机往外第一次发送 和 外部第一次发往本机的请求)，哪怕对第一个 NEW 请求再回应的都算 ESTABLISHED。注意在 INPUT 和 OUTPUT 链上定义 NEW 的情况，INPUT 是外部第一次访问本机算 NEW；OUTPUT 是本机第一次访问外部算 NEW。&lt;/li>
&lt;/ol>
&lt;/li>
&lt;/ol>
&lt;p>注意：ConnTrack 中所定义的状态与 TCP 等协议所定义的状态不一样，这里面定义的状态只是为了可以通过一种新的方式来处理每一个数据包，并进行过滤，这是 Netfilter 中所定义的状态&lt;/p>
&lt;p>ConnTrack 功能依靠 &lt;strong>nf_conntrack&lt;/strong> 模块来实现的，当启用 iptables 功能时(比如 firewalld)会自动加载该模块&lt;/p>
&lt;p>连接跟踪是防火墙模块的状态检测的基础，同时也是地址转换中实现 SNAT 和 DNAT 的基础，如果在 nat 表上没有连接跟踪，那么则没法进行 nat 转换(比如通过 raw 表来关闭连接跟踪)。&lt;/p>
&lt;h1 id="conntrack-table连接跟踪表">ConnTrack Table(连接跟踪表)&lt;/h1>
&lt;p>ConnTrack 将连接跟踪表保存于系统的内存当中，可以通过 &lt;strong>cat /proc/net/nf_conntrack&lt;/strong> 或 &lt;strong>conntrack -L&lt;/strong> 命令查看到当前已跟踪的所有 &lt;strong>ConnTrack Entry(连接跟踪条目)&lt;/strong>。不同的协议，条目的内容也不太一样，下面是一个 tcp 协议的条目内容：&lt;/p>
&lt;ul>
&lt;li>&lt;code>ipv4 2 tcp 6 299 ESTABLISHED src=192.168.2.40 dst=172.38.40.250 sport=61758 dport=22 src=172.38.40.250 dst=192.168.2.40 sport=22 dport=61758 [ASSURED] mark=0 zone=0 use=2&lt;/code>&lt;/li>
&lt;/ul>
&lt;p>nf_conntrack 文件中，每个条目占用单独一行。条目中包含了数据包的原始方向信息(蓝色部分)，和期望的响应包信息(红色部分)，这样内核能够在后续到来的数据包中识别出属于此连接的双向数据包，并更新此连接的状态。&lt;/p>
&lt;p>在内核中，&lt;strong>ConnTrackTable(连接跟踪表)&lt;/strong> 实际上是一个 &lt;strong>hash table(哈希表)&lt;/strong>。收到一个数据包，通过如下步骤判断该数据包是否署一个已有连接(即定位连接跟踪条目)：&lt;/p>
&lt;ul>
&lt;li>第一步：内核提取数据包信息(源 IP、目的 IP、port，协议号)进行 hash 计算得到一个 hash 值，在哈希表中以此 hash 值做索引，索引结果为数据包所属的 &lt;strong>Bucket(储存区)&lt;/strong>。这一步 hash 计算时间固定并且很短。
&lt;ul>
&lt;li>一个 &lt;strong>Bucket(储存区)&lt;/strong> 里包含一个 &lt;strong>linked list(已链接的列表，简称链表)&lt;/strong>，即已经追踪的条目的列表。也就是说，每个 Bucket 里可以存放多个 ConnTrack Entry。所谓 Bucket 的大小，就是指一个 Bucket 中可以存放多少个 ConnTrack Entry。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>第二步：遍历第一步获取的 Bucket 中的所有条目，查找是否有匹配的条目。这一步是比较耗时的操作，所以说 Bucket 越大，遍历时间越长&lt;/li>
&lt;/ul>
&lt;h2 id="bucket储存区">Bucket(储存区)&lt;/h2>
&lt;p>在 Connection Tracking 系统中的 hash table 中，有若干个 &lt;strong>Bucket(储存区)&lt;/strong>，Bucket 的个数通过两个内核参数计算而来&lt;/p>
&lt;ul>
&lt;li>net.netfilter.nf_conntrack_buckets # 一个表最大的 Bucket 数量。默认通过内存计算得来，内存越高，Bucket 越多。也可以通过设置模块参数指定具体的数值
&lt;ul>
&lt;li>无法通过 sysctl 修改 nf_conntrack_buckets 的值，该值只能通过加载 nf_conntrack 模块时的参数来决定。使用 &lt;code>echo &amp;quot;options nf_conntrack hashsize=16384&amp;quot; &amp;gt; /etc/modprobe.d/nf_conntrack.conf&lt;/code> 命令即可设置该内核参数为 16384&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>net.netfilter.nf_conntrack_max # 一个表最大的 Entry 数量。默认为 nf_conntrack_buckets 值的 4 倍。也就是说，&lt;strong>Bucket 的大小默认为 4&lt;/strong>，即系统默认每个 Bucket 中包含 4 个 ConnTrack Entry。
&lt;ul>
&lt;li>当不使用系统默认的 nf_conntrack_buckets 值时，则 nf_conntrack_max 的值为 nf_conntrack_buckets 的 8 倍&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>如果把一个 Bucket 的大小称为 &lt;code>BucketSize&lt;/code> 的话，那么&lt;code>BucketSize = nf_conntrack_max / nf_conntrack_buckets&lt;/code>(这意思就是说 &lt;code>储存区的大小=条目总数 / 储存区的总数&lt;/code>，所以储存区大小就是指能装多少条目)&lt;/p>
&lt;h2 id="conntrack-entry连接跟踪条目">ConnTrack Entry(连接跟踪条目)&lt;/h2>
&lt;p>conntrack 从经过它的数据包中提取详细的，唯一的信息，因此能保持对每一个连接的跟踪。关于 conntrack 如何确定一个连接，对于 tcp/udp，连接由他们的源目地址，源目端口唯一确定。对于 icmp，由 type，code 和 id 字段确定。&lt;/p>
&lt;pre tabindex="0">&lt;code>ipv4 2 tcp 6 33 SYN_SENT src=172.16.200.119 dst=172.16.202.12 sport=54786 dport=10051 [UNREPLIED] src=172.16.202.12 dst=172.16.200.119 sport=10051 dport=54786 mark=0 zone=0 use=2
&lt;/code>&lt;/pre>&lt;p>如上是一条 conntrack 条目，它代表当前已跟踪到的某个连接，conntrack 维护的所有信息都包含在这个条目中，通过它就可以知道某个连接处于什么状态&lt;/p>
&lt;ul>
&lt;li>&lt;strong>ipv4&lt;/strong> # 此连接使用 ipv4 协议，是一条 tcp 连接(tcp 的协议类型代码是 6)&lt;/li>
&lt;li>&lt;strong>33&lt;/strong> # 这条 conntrack 条目在当前时间点的生存时间(每个 conntrack 条目都会有生存时间，从设置值开始倒计时，倒计时完后此条目将被清除)，可以使用&lt;code>sysctl -a |grep conntrack | grep timeout&lt;/code>查看不同协议不同状态下生存时间设置值，当然这些设置值都可以调整，注意若后续有收到属于此连接的数据包，则此生存时间将被重置(重新从设置值开始倒计时)，并且状态改变，生存时间设置值也会响应改为新状态的值&lt;/li>
&lt;li>&lt;strong>SYN_SENT&lt;/strong> # 到此刻为止 conntrack 跟踪到的这个连接的状态(内核角度)，&lt;code>SYN_SENT&lt;/code>表示这个连接只在一个方向发送了一初始 TCP SYN 包，还未看到响应的 SYN+ACK 包(只有 tcp 才会有这个字段)。&lt;/li>
&lt;li>&lt;strong>src=172.16.200.119 dst=172.16.202.12 sport=54786 dport=10051&lt;/strong> # 从数据包中提取的此连接的源目地址、源目端口，是 conntrack 首次看到此数据包时候的信息。&lt;/li>
&lt;li>&lt;strong>[UNREPLIED]&lt;/strong> # 说明此刻为止这个连接还没有收到任何响应，当一个连接已收到响应时，[UNREPLIED]标志就会被移除&lt;/li>
&lt;li>&lt;strong>src=172.16.202.12 dst=172.16.200.119 sport=10051 dport=54786&lt;/strong> # 地址和端口和前面是相反的，这部分不是数据包中带有的信息，是 conntrack 填充的信息，代表 conntrack 希望收到的响应包信息。意思是若后续 conntrack 跟踪到某个数据包信息与此部分匹配，则此数据包就是此连接的响应数据包。注意这部分确定了 conntrack 如何判断响应包(tcp/udp)，icmp 是依据另外几个字段&lt;/li>
&lt;/ul>
&lt;p>上面是 tcp 连接的条目，而 udp 和 icmp 没有连接建立和关闭过程，因此条目字段会有所不同，后面 iptables 状态匹配部分我们会看到处于各个状态的 conntrack 条目&lt;/p>
&lt;p>注意：conntrack 机制并不能够修改或过滤数据包，它只是跟踪网络连接并维护连接跟踪表，以提供给 iptables 做状态匹配使用，也就是说，如果你 iptables 中用不到状态匹配，那就没必要启用 conntrack&lt;/p>
&lt;h2 id="总结">总结&lt;/h2>
&lt;p>所以，一个 ConnTrack Table 就类似于下面的表：&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>&lt;strong>Hash Table&lt;/strong>&lt;/th>
&lt;th>Bucket 1&lt;/th>
&lt;th>Bucket 2&lt;/th>
&lt;th>Bucket 3&lt;/th>
&lt;th>&amp;hellip;&amp;hellip;.&lt;/th>
&lt;th>Bucket N&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>Entry 1&lt;/td>
&lt;td>条目内容&lt;/td>
&lt;td>条目内容&lt;/td>
&lt;td>条目内容&lt;/td>
&lt;td>条目内容&lt;/td>
&lt;td>条目内容&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Entry 2&lt;/td>
&lt;td>条目内容&lt;/td>
&lt;td>条目内容&lt;/td>
&lt;td>条目内容&lt;/td>
&lt;td>条目内容&lt;/td>
&lt;td>条目内容&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&amp;hellip;&amp;hellip;..&lt;/td>
&lt;td>条目内容&lt;/td>
&lt;td>条目内容&lt;/td>
&lt;td>条目内容&lt;/td>
&lt;td>条目内容&lt;/td>
&lt;td>条目内容&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Entry N&lt;/td>
&lt;td>条目内容&lt;/td>
&lt;td>条目内容&lt;/td>
&lt;td>条目内容&lt;/td>
&lt;td>条目内容&lt;/td>
&lt;td>条目内容&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h1 id="计算连接跟踪表所占内存">计算连接跟踪表所占内存&lt;/h1>
&lt;p>&lt;code>total * mem_used(单位为 Bytes) = nf_conntrack_max * sizeof(struct ip*conntrack) + nf_conntrack_buckets * sizeof(struct list_head)&lt;/code>&lt;/p>
&lt;ol>
&lt;li>sizeof(struct ip_conntrack) 连接跟踪对象大小，默认 376&lt;/li>
&lt;li>sizeof(struct list_head) 链表项大小，默认为 16&lt;/li>
&lt;/ol>
&lt;p>上述两个值可以通过如下 python 代码计算出来&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>import ctypes
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#不同系统可能此库名不一样，需要修改&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>LIBNETFILTER_CONNTRACK &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#39;libnetfilter_conntrack.so.3.6.0&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>nfct &lt;span style="color:#f92672">=&lt;/span> ctypes.CDLL&lt;span style="color:#f92672">(&lt;/span>LIBNETFILTER_CONNTRACK&lt;span style="color:#f92672">)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>print &lt;span style="color:#e6db74">&amp;#39;sizeof(struct nf_conntrack):&amp;#39;&lt;/span>, nfct.nfct_maxsize&lt;span style="color:#f92672">()&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>print &lt;span style="color:#e6db74">&amp;#39;sizeof(struct list_head):&amp;#39;&lt;/span>, ctypes.sizeof&lt;span style="color:#f92672">(&lt;/span>ctypes.c_void_p&lt;span style="color:#f92672">)&lt;/span> * &lt;span style="color:#ae81ff">2&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>假如，我系统信息如下：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>~&lt;span style="color:#f92672">]&lt;/span>&lt;span style="color:#75715e"># cat /proc/sys/net/netfilter/nf_conntrack_max&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">524288&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>~&lt;span style="color:#f92672">]&lt;/span>&lt;span style="color:#75715e"># cat /proc/sys/net/netfilter/nf_conntrack_buckets&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">131072&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>那么，此系统下，连接跟踪表所占内存即为：&lt;/p>
&lt;pre tabindex="0">&lt;code>(524288 * 376 + 131072 * 16) / 1024 / 1024 = 190MiB
&lt;/code>&lt;/pre>&lt;h1 id="conntrack-关联文件与配置">ConnTrack 关联文件与配置&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://www.kernel.org/doc/Documentation/networking/nf_conntrack-sysctl.txt">内核官方文档，网络-nf_conntrack-sysctl&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>连接跟踪系统的配置大部分都可以通过修改内核参数来进行，还有一部分需要通过指定 模块的参数 来配置。&lt;/p>
&lt;ul>
&lt;li>&lt;strong>/proc/net/nf_conntrack&lt;/strong> # 连接跟踪表，该文件用于记录每一个连接跟踪条目
&lt;ul>
&lt;li>注意：Ubuntu 中没有该文件，可以通过 &lt;code>conntrack -L&lt;/code> 命令获取连接跟踪条目。据说该文件已 deprecated(弃用)，但是未找到官方说明&lt;/li>
&lt;li>&lt;a href="https://forum.ubuntu.com.cn/viewtopic.php?t=480072">https://forum.ubuntu.com.cn/viewtopic.php?t=480072&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://askubuntu.com/questions/266991/in-ubuntu-12-10-how-to-enable-proc-net-ip-conntrack">https://askubuntu.com/questions/266991/in-ubuntu-12-10-how-to-enable-proc-net-ip-conntrack&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://patchwork.ozlabs.org/project/ubuntu-kernel/patch/1341986947-28300-3-git-send-email-bryan.wu@canonical.com/">https://patchwork.ozlabs.org/project/ubuntu-kernel/patch/1341986947-28300-3-git-send-email-bryan.wu@canonical.com/&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://github.com/kubernetes/kubernetes/pull/69589/files#r418929810">https://github.com/kubernetes/kubernetes/pull/69589/files#r418929810&lt;/a>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>/proc/sys/net/nf_conntrack_max&lt;/strong> # 等于 /proc/sys/net/netfilter/nf_conntrack_max 的值。修改这俩参数任意一个值，都会互相同步。&lt;/li>
&lt;li>&lt;strong>/proc/sys/net/netfilter/&lt;/strong> # 网络栈的运行时属性所在的目录
&lt;ul>
&lt;li>&lt;strong>./nf_conntrack_count&lt;/strong> # 当前连接跟踪数。&lt;/li>
&lt;li>&lt;strong>./nf_conntrack_max&lt;/strong> # 连接跟踪表的大小，即一个表中有可以存放多少个条目。默认值为 nf_conntrack_buckets *4 。等于 /proc/sys/net/nf_conntrack_max 的值。&lt;/li>
&lt;li>&lt;strong>./nf_conntrack_buckets&lt;/strong> # hash 表的大小，即一个 hash 表中有多少个 Buckets。&lt;/li>
&lt;li>&lt;strong>./nf_conntrack_tcp_timeout_time_wait&lt;/strong> # timewait 状态的条目超时时间。 默认 120 秒&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h1 id="应用实例">应用实例&lt;/h1>
&lt;p>第一次 TCP 或 UDP 或 ICMP 等协议请求建立连接后，有一个持续时间，在持续时间内，这个连接信息会保存在连接跟踪表(记录在 nf_conntrack 文件中)中，当同一个 IP 再次请求的时候，这个请求的数据包则不会被当成 NEW 状态的数据包来处理(具体的状态有几种详见下文)，这个概念可以用在这么一个真实环境当中。&lt;/p>
&lt;h1 id="conntrack-命令行工具">conntrack 命令行工具&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;/blockquote>
&lt;h1 id="常见问题">常见问题&lt;/h1>
&lt;h2 id="nf_conntrack-table-full-dropping-packets">nf_conntrack: table full, dropping packets&lt;/h2>
&lt;p>参考: &lt;a href="https://mp.weixin.qq.com/s/N7jfQCfR-1V5ppw7tLcB6w">https://mp.weixin.qq.com/s/N7jfQCfR-1V5ppw7tLcB6w&lt;/a>&lt;/p>
&lt;p>显然，调大最大值的限制就可以了。不过更大的限制意味着可以承接更多连接，意味着要耗费更多资源，这点要注意。&lt;/p>
&lt;p>查看当前有多少活跃连接：&lt;/p>
&lt;pre tabindex="0">&lt;code>cat /proc/sys/net/netfilter/nf_conntrack_count
&lt;/code>&lt;/pre>&lt;p>如果这个值跟上面介绍的 nf_conntrack_max 已经很接近了，就说明快满了，需要调大 nf_conntrack_max。可以使用下面的命令临时调大：&lt;/p>
&lt;pre tabindex="0">&lt;code>echo 524288 &amp;gt; /proc/sys/net/netfilter/nf_conntrack_max
&lt;/code>&lt;/pre>&lt;p>如果不想每次重启都要重新设置，可以修改 /etc/sysctl.conf，加入下面的配置：&lt;/p>
&lt;pre tabindex="0">&lt;code>net.netfilter.nf_conntrack_max = 524288
&lt;/code>&lt;/pre>&lt;p>为了缓解大量连接的问题，您可能还需要考虑减少服务器等待连接关闭/超时的时间。在 /etc/sysctl.conf 中加入下面的配置：&lt;/p>
&lt;pre tabindex="0">&lt;code>net.netfilter.nf_conntrack_tcp_timeout_close_wait = 60
net.netfilter.nf_conntrack_tcp_timeout_fin_wait = 60
net.netfilter.nf_conntrack_tcp_timeout_time_wait = 60
&lt;/code>&lt;/pre></description></item><item><title>Docs: firewalld(Iptables 的管理工具)</title><link>https://desistdaydream.github.io/docs/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2.Kernel/8.Network/Linux-%E7%BD%91%E7%BB%9C%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6/Netfilter-%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6%E7%B3%BB%E7%BB%9F/firewalldIptables-%E7%9A%84%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2.Kernel/8.Network/Linux-%E7%BD%91%E7%BB%9C%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6/Netfilter-%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6%E7%B3%BB%E7%BB%9F/firewalldIptables-%E7%9A%84%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/</guid><description/></item><item><title>Docs: iptables(Netfilter 的实现)</title><link>https://desistdaydream.github.io/docs/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2.Kernel/8.Network/Linux-%E7%BD%91%E7%BB%9C%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6/Netfilter-%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6%E7%B3%BB%E7%BB%9F/iptables/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2.Kernel/8.Network/Linux-%E7%BD%91%E7%BB%9C%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6/Netfilter-%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6%E7%B3%BB%E7%BB%9F/iptables/</guid><description/></item><item><title>Docs: nftables</title><link>https://desistdaydream.github.io/docs/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2.Kernel/8.Network/Linux-%E7%BD%91%E7%BB%9C%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6/Netfilter-%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6%E7%B3%BB%E7%BB%9F/nftables/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2.Kernel/8.Network/Linux-%E7%BD%91%E7%BB%9C%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6/Netfilter-%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6%E7%B3%BB%E7%BB%9F/nftables/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://wiki.nftables.org/wiki-nftables/index.php/Main_Page">官方 wiki&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>nftables 是一个 netfilter 项目，旨在替换现有的 {ip,ip6,arp,eb}tables 框架，为 {ip,ip6}tables 提供一个新的包过滤框架、一个新的用户空间实用程序（nft）和一个兼容层。它使用现有的钩子、链接跟踪系统、用户空间排队组件和 netfilter 日志子系统。&lt;/p>
&lt;p>nftables 主要由三个组件组成：内核实现、libnl netlink 通信、 nftables 用户空间。 其中内核提供了一个 netlink 配置接口以及运行时规则集评估，libnl 包含了与内核通信的基本函数，用户空间可以通过 nft 和用户进行交互。&lt;/p>
&lt;p>nftables 与 iptables 的区别&lt;/p>
&lt;p>nftables 和 iptables 一样，由 table(表)、chain(链)、rule(规则) 组成。nftables 中，表包含链，链包含规则，规则是真正的 action。与 iptables 相比，nftables 主要有以下几个变化：&lt;/p>
&lt;ul>
&lt;li>iptables 规则的布局是基于连续的大块内存的，即数组式布局；而 nftables 的规则采用链式布局。其实就是数组和链表的区别&lt;/li>
&lt;li>iptables 大部分工作在内核态完成，如果要添加新功能，只能重新编译内核；而 nftables 的大部分工作是在用户态完成的，添加新功能很 easy，不需要改内核。&lt;/li>
&lt;li>iptables 有内置的链，即使你只需要一条链，其他的链也会跟着注册；而 nftables 不存在内置的链，你可以按需注册。由于 iptables 内置了一个数据包计数器，所以即使这些内置的链是空的，也会带来性能损耗。&lt;/li>
&lt;li>简化了 IPv4/IPv6 双栈管理&lt;/li>
&lt;li>原生支持集合、字典和映射&lt;/li>
&lt;/ul>
&lt;p>nftables 没有任何默认规则，如果关闭了 firewalld 服务，则命令 nft list ruleset 输出结果为空。意思就是没有任何内置链或者表 2.&lt;/p>
&lt;h2 id="nftables-table-表-与-nftables-family-簇">nftables table 表 与 nftables family 簇&lt;/h2>
&lt;p>nftables 没有内置表，表的数量与名称由用户决定。&lt;/p>
&lt;p>family(簇) 是 nftables 技术引用的新概念。一共有 6 种簇。不同的 family 可以处理不同 Hook 上的数据包。&lt;/p>
&lt;p>Note：&lt;/p>
&lt;ol>
&lt;li>&lt;code>簇&lt;/code> 可以当做 &lt;code>类型&lt;/code> 来理解，比如建立一个名为 test 的表，该表的簇为 inet(i.e.表的类型是 inet)。&lt;/li>
&lt;li>所以每个表应且只应指定一个簇，且当表中的链被指定类型时，只能指定该簇下可以处理的链类型，详情见本文《nftables chain 链》章节&lt;/li>
&lt;/ol>
&lt;p>nftables 中一同以下几种 family：&lt;/p>
&lt;ol>
&lt;li>ip # IPv4 地址簇。对应 iptables 中 iptables 命令行工具所实现的效果。默认簇，nft 命令的所有操作如果不指定具体的 family，则默认对 ip 簇进行操作
&lt;ol>
&lt;li>可处理流量的 Hook：与 inet 簇相同&lt;/li>
&lt;/ol>
&lt;/li>
&lt;li>ip6 # IPv6 地址簇。对应 iptables 中 ip6tables 命令行工具所实现的效果
&lt;ol>
&lt;li>可处理流量的 Hook：与 inet 簇相同&lt;/li>
&lt;/ol>
&lt;/li>
&lt;li>inet # Internet (IPv4/IPv6)地址簇。对应 iptables 中 iptables 和 ip6tables 命令行工具所实现的效果
&lt;ol>
&lt;li>可处理流量的的 Hook：prerouting、input、forward、output、postrouting。ip 与 ip6 簇与 inet 簇所包含的 Hook 相同&lt;/li>
&lt;/ol>
&lt;/li>
&lt;li>arp # ARP 地址簇，处理 IPv4 ARP 包。对应 iptables 中 arptables 命令行工具所实现的效果
&lt;ol>
&lt;li>可处理流量的 Hook：input、output。&lt;/li>
&lt;/ol>
&lt;/li>
&lt;li>bridge # 桥地址簇。处理通过桥设备的数据包对应 iptables 中 ebtables 命令行工具所实现的效果
&lt;ol>
&lt;li>可处理流量的 Hook：与 inet 簇相同&lt;/li>
&lt;/ol>
&lt;/li>
&lt;li>netdev # Netdev address family, handling packets from ingress.
&lt;ol>
&lt;li>可处理流量的 Hook：ingress&lt;/li>
&lt;/ol>
&lt;/li>
&lt;/ol>
&lt;p>基本效果示例如下：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">[&lt;/span>root@centos8 ~&lt;span style="color:#f92672">]&lt;/span>&lt;span style="color:#75715e"># nft add table test # 创建名为test的表，簇为默认的ip簇&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">[&lt;/span>root@centos8 ~&lt;span style="color:#f92672">]&lt;/span>&lt;span style="color:#75715e"># nft list ruleset # 列出所有规则&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>table ip test &lt;span style="color:#f92672">{&lt;/span> &lt;span style="color:#75715e"># 仅有一个名为test的表，簇为ip，没有任何规则&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">[&lt;/span>root@centos8 ~&lt;span style="color:#f92672">]&lt;/span>&lt;span style="color:#75715e"># nft add table inet test # 创建名为test的表，使用inet簇&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">[&lt;/span>root@centos8 ~&lt;span style="color:#f92672">]&lt;/span>&lt;span style="color:#75715e"># nft list ruleset&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>table ip test &lt;span style="color:#f92672">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>table inet test &lt;span style="color:#f92672">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="nftables-chain链">nftables chain(链)&lt;/h2>
&lt;p>在 nftables 中，链是用来保存规则的。链在逻辑上被分为下述三种类型：&lt;/p>
&lt;ol>
&lt;li>filter 类型的链 # 用于过滤数据包所用
&lt;ol>
&lt;li>允许定义在哪些 family 下：all family&lt;/li>
&lt;li>链中的规则会处理这些 Hook 点的数据包：all Hook&lt;/li>
&lt;/ol>
&lt;/li>
&lt;li>nat 类型的链 # 用于进行地址转换
&lt;ol>
&lt;li>允许定义在哪些 family 下：ip、ip6&lt;/li>
&lt;li>链中的规则会处理这些 Hook 点的数据包：prerouting、input、output、postrouting&lt;/li>
&lt;/ol>
&lt;/li>
&lt;li>route 类型的链
&lt;ol>
&lt;li>允许定义在哪些 family 下：ip、ip6&lt;/li>
&lt;li>链中的规则会处理这些 Hook 点的数据包：output&lt;/li>
&lt;/ol>
&lt;/li>
&lt;/ol>
&lt;p>在创建 nftables 中的链时，通常有两种叫法，没有类型的叫常规链，含有类型的叫基本链：&lt;/p>
&lt;p>常规链(也叫自定义链) : 不需要指定钩子类型和优先级，可以用来做链与链之间的跳转，从逻辑上对规则进行分类。&lt;/p>
&lt;p>基本链 : 数据包的入口点，需要指定该链的基本信息(类型、作用的 Hook 点、优先级、默认策略等)才可以让链中的规则生效(在链管理命令的 {} 中添加链信息)。因为链中包含一条一条的规则，所以一个可以正常处理流量的链，需要指定其类型来区分该链上的规则干什么用的，还需要指定 Hook 来指明数据包到哪个 Hook 了来使用这个规则，还需要配置优先级来处理相同类型的规则，该规则应该先执行还是后执行。&lt;/p>
&lt;h2 id="nftables-rule规则">nftables rule(规则)&lt;/h2>
&lt;p>nftables 中的规则标识符有两种，一种 index，一种 handle&lt;/p>
&lt;p>&lt;strong>index # 规则的索引。每条规则在其链中，从 0 开始计数(每条链中的规则，第一条规则的 index 为 0，第二条规则的 indext 为 2，依次类推)。&lt;/strong>&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span> chain DOCKER &lt;span style="color:#f92672">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> tcp dport tcpmux accept &lt;span style="color:#75715e"># 规则index为0&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> tcp dport &lt;span style="color:#ae81ff">5&lt;/span> accept &lt;span style="color:#75715e"># 规则index为1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> tcp dport &lt;span style="color:#ae81ff">6&lt;/span> accept &lt;span style="color:#75715e"># 后续依次类推&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> tcp dport &lt;span style="color:#ae81ff">2&lt;/span> accept
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> tcp dport &lt;span style="color:#ae81ff">3&lt;/span> accept
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> tcp dport afs3-fileserver accept
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;strong>handle # 规则的句柄。句柄对于整个 nftalbes 而言，不管添加在哪个链中，第一条规则的句柄为 1，第二条规则句柄为 2。如果规则句柄为 33 号被删除，则新添加的规则的句柄为 34&lt;/strong>&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span> chain DOCKER &lt;span style="color:#f92672">{&lt;/span> &lt;span style="color:#75715e"># handle 4&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> tcp dport tcpmux accept &lt;span style="color:#75715e"># handle 28&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> tcp dport &lt;span style="color:#ae81ff">5&lt;/span> accept &lt;span style="color:#75715e"># handle 32&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> tcp dport &lt;span style="color:#ae81ff">6&lt;/span> accept &lt;span style="color:#75715e"># handle 33&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> tcp dport &lt;span style="color:#ae81ff">2&lt;/span> accept &lt;span style="color:#75715e"># handle 29&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> tcp dport &lt;span style="color:#ae81ff">3&lt;/span> accept &lt;span style="color:#75715e"># handle 30&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> tcp dport afs3-fileserver accept &lt;span style="color:#75715e"># handle 31&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Note：对于每条规则而言，其 index 可以随时改变，当在多个规则中间插入新规则时，新插入规则下面的规则 index 则会改变。而 handle 则不会改变，除非删除后重新添加&lt;/p>
&lt;h2 id="总结">总结&lt;/h2>
&lt;p>nftables 的结构为：表包含链，链包含规则，这个逻辑是非常清晰明了的。而 iptable 呢，则需要先指定什么类型的表，再添加规则，规则与链则互相存在，让人摸不清关系；其实也可以说，iptables 的表类型，就是 nftables 中的链的类型。&lt;/p>
&lt;h1 id="nftable-配置">Nftable 配置&lt;/h1>
&lt;p>&lt;strong>/etc/sysconfig/nftables.conf&lt;/strong> # CentOS 8 中，nftables.service 的规则被存储在此目录中，其中 include 一些其他的示例规则
&lt;strong>/etc/sysconfig/nftables/&lt;/strong> # nftables.conf 文件中 include 的文件，都在该目录下&lt;/p>
&lt;p>备份规则：&lt;/p>
&lt;p>$ nft list ruleset &amp;gt; /root/nftables.conf&lt;/p>
&lt;h1 id="nftable-的-set集合与-map字典-特性介绍">nftable 的 set(集合)与 map(字典) 特性介绍&lt;/h1>
&lt;p>nftables 的语法原生支持集合，集合可以用来匹配多个 IP 地址、端口号、网卡或其他任何条件。类似于 ipset 的功能。&lt;/p>
&lt;p>集合分为匿名集合与命名集合。&lt;/p>
&lt;h2 id="匿名集合">匿名集合&lt;/h2>
&lt;p>匿名集合比较适合用于未来不需要更改的规则&lt;/p>
&lt;p>例如下面的两个示例，&lt;/p>
&lt;ol>
&lt;li>该规则允许来自源 IP 处于 10.10.10.123 ~ 10.10.10.231 这个区间内的主机的流量通过。
&lt;ol>
&lt;li>nft add rule inet my_table my_filter_chain ip saddr { 10.10.10.123, 10.10.10.231 } accept&lt;/li>
&lt;/ol>
&lt;/li>
&lt;li>该规则允许来自目的端口是 http、nfs、ssh 的流量通过。
&lt;ol>
&lt;li>nft add rule inet my_table my_filter_chain tcp dport { http, nfs, ssh } accept&lt;/li>
&lt;/ol>
&lt;/li>
&lt;/ol>
&lt;p>匿名集合的缺点是，如果需要修改集合中的内容，比如像 ipset 中修改 ip 似的，就得替换规则。如果后面需要频繁修改集合，推荐使用命名集合。&lt;/p>
&lt;h2 id="命令集合">命令集合&lt;/h2>
&lt;p>iptables 可以借助 ipset 来使用集合，而 nftables 中的命名集合就相当于 ipset 的功能。&lt;/p>
&lt;p>命名集合需要使用 nft add set XXXX 命令进行创建，创建时需要指定簇名、表名、以及 set 的属性&lt;/p>
&lt;p>命名集合中包括以下几种属性，其中 type 为必须指定的属性，其余属性可选。&lt;/p>
&lt;ol>
&lt;li>type # 集合中所有元素的类型，包括 ipv4_addr(ipv4 地址), ipv6_addr(ipv6 地址), ether_addr(以太网地址), inet_proto(网络协议), inet_service(网络服务), mark(标记类型) 这几类&lt;/li>
&lt;li>flags # 集合的标志。包括 constant、interval、timeout 。
&lt;ol>
&lt;li>interval # 让集合支持区间模式。默认集合中无法使用这种方式 nft add element inet my_table my_set { 10.20.20.0-10.20.20.255 } 来添加集合 。当给集合添加类型 flag 时，就可以在给集合添加元素时，使用‘区间’的表示方法。因为内核必须提前确认该集合存储的数据类型，以便采用适当的数据结构。&lt;/li>
&lt;/ol>
&lt;/li>
&lt;li>timeout #&lt;/li>
&lt;li>gc-interval #&lt;/li>
&lt;li>elements #&lt;/li>
&lt;li>size #&lt;/li>
&lt;li>policy #&lt;/li>
&lt;li>auto-merge #&lt;/li>
&lt;/ol>
&lt;p>像 ipset 一样，光创建完还没法使用，需要在 iptables 中添加规则引用 ipset 才可以。nftables 的 set 一样，创建完成后，需要在规则中引用，引用集合规则时使用 @ 并跟上集合的名字，即可引用指定的集合(e.g.nft insert rule inet my_table my_filter_chain ip saddr @my_set drop)这条命令即时引用了 my_set 集合中的内容&lt;/p>
&lt;p>级联不同类型&lt;/p>
&lt;p>命名集合也支持对不同类型的元素进行级联，通过级联操作符 . 来分隔。例如，下面的规则可以一次性匹配 IP 地址、协议和端口号。&lt;/p>
&lt;p>$ nft add set inet my_table my_concat_set { type ipv4_addr . inet_proto . inet_service ; }&lt;/p>
&lt;p>$ nft list set inet my_table my_concat_set&lt;/p>
&lt;p>table inet my_table {&lt;/p>
&lt;p>set my_concat_set {&lt;/p>
&lt;p>type ipv4_addr . inet_proto . inet_service&lt;/p>
&lt;pre>&lt;code> }
&lt;/code>&lt;/pre>
&lt;p>}&lt;/p>
&lt;p>向集合中添加元素：&lt;/p>
&lt;p>$ nft add element inet my_table my_concat_set { 10.30.30.30 . tcp . telnet }&lt;/p>
&lt;p>在规则中引用级联类型的集合和之前一样，但需要标明集合中每个元素对应到规则中的哪个位置。&lt;/p>
&lt;p>$ nft add rule inet my_table my_filter_chain ip saddr . meta l4proto . tcp dport @my_concat_set accept&lt;/p>
&lt;p>这就表示如果数据包的源 IP、协议类型、目标端口匹配 10.30.30.30、tcp、telnet 时，nftables 就会允许该数据包通过。&lt;/p>
&lt;p>匿名集合也可以使用级联元素，例如：&lt;/p>
&lt;p>$ nft add rule inet my_table my_filter_chain ip saddr . meta l4proto . udp dport { 10.30.30.30 . udp . bootps } accept&lt;/p>
&lt;p>现在你应该能体会到 nftables 集合的强大之处了吧。&lt;/p>
&lt;p>nftables 级联类型的集合类似于 ipset 的聚合类型，例如 hash:ip,port。&lt;/p>
&lt;h1 id="nft-命令行工具介绍">nft 命令行工具介绍&lt;/h1>
&lt;p>&lt;strong>nft [OPTIONS] [COMMANDS]&lt;/strong>&lt;/p>
&lt;p>COMMANDS 包括：&lt;/p>
&lt;ol>
&lt;li>ruleset # 规则集管理命令&lt;/li>
&lt;li>table # 表管理命令&lt;/li>
&lt;li>chain # 链管理命令&lt;/li>
&lt;li>rule # 规则管理命令&lt;/li>
&lt;li>set # 集合管理命令&lt;/li>
&lt;li>map # 字典管理命令&lt;/li>
&lt;li>NOTE：
&lt;ol>
&lt;li>该 COMMANDS 与后面子命令中的 COMMAND 不同，前者是 nft 命令下的子命令，后者是 nft 命令下子命令的子命令&lt;/li>
&lt;li>nft 子命令默认对 ip 簇进行操作，当指定具体的 FAMILY 时，则对指定的簇进行操作&lt;/li>
&lt;/ol>
&lt;/li>
&lt;/ol>
&lt;p>OPTIONS&lt;/p>
&lt;ol>
&lt;li>-a,&amp;ndash;handle # 在使用命令获得输出时，显示每个对象的句柄
&lt;ol>
&lt;li>Note：handle(句柄)在 nftables 中，相当于标识符，nftables 中的每一行内容都有一个 handle。&lt;/li>
&lt;/ol>
&lt;/li>
&lt;li>-e,&amp;ndash;echo # 回显已添加、插入或替换的内容&lt;/li>
&lt;li>-f,&amp;ndash;file FILE # 从指定的文件 FILE 中读取 netfilter 配置加载到内核中&lt;/li>
&lt;/ol>
&lt;p>EXAMPLE：&lt;/p>
&lt;ol>
&lt;li>nft -f /root/nftables.conf # 从 nftables.conf 文件中，将配置规则加载到系统中&lt;/li>
&lt;/ol>
&lt;p>Note：下面子命令中的 FAMILY 如果不指定，则所有命令默认都是对 ip 簇进行操作。&lt;/p>
&lt;h2 id="表管理命令">表管理命令&lt;/h2>
&lt;p>nft COMMAND table [FAMILY] TABLE # FAMILY 指定簇名，TABLE 为表的名称&lt;/p>
&lt;p>nft list tables # 列出所有的表，不包含表中的链和规则&lt;/p>
&lt;p>COMMAND&lt;/p>
&lt;ol>
&lt;li>add # 添加指定簇下的表。&lt;/li>
&lt;li>create # 与 add 命令类似，但是如果表已经存在，则返回错误信息。&lt;/li>
&lt;li>delete # 删除指定的表。不管表中是否有内容都一并删除&lt;/li>
&lt;li>flush # 清空指定的表下的所有规则，保留链&lt;/li>
&lt;li>list # 列出指定的表的所有链，及其链中的规则&lt;/li>
&lt;/ol>
&lt;p>EXAMPLE&lt;/p>
&lt;ol>
&lt;li>nft add table my_table # 创建一个 ip 簇的，名为 my_table 的表&lt;/li>
&lt;li>nft add table inet my_table # 创建一个 inet 簇的，名为 my_table 的表&lt;/li>
&lt;li>nft list table inet my_table # 列出 inet 簇的名为 my_table 的表及其链和规则&lt;/li>
&lt;/ol>
&lt;h2 id="链管理命令">链管理命令&lt;/h2>
&lt;p>nft COMMAND chain [FAMILY] TABLE CHAIN [{ type TYPE hook HOOK [device DEVICE] priority PRIORITY; [policy POLICY;] }] # FAMILY 指定簇名，TABLE 指定表名，CHAIN 指定链名，TYPE 指定该链的类型，HOOK 指定该链作用在哪个 hook 上，DEVICE 指定该链作用在哪个网络设备上，PRIORITY 指定该链的优先级，POLICY 指定该链的策略(i.e.该链的默认策略，accept、drop 等等。)&lt;/p>
&lt;p>nft list chains # 列出所有的链&lt;/p>
&lt;p>Note:&lt;/p>
&lt;ul>
&lt;li>在输入命令时，使用反斜线 \ 用来转义分号 ; ，这样 shell 就不会将分号解释为命令的结尾。如果是直接编辑 nftables 的配置文件则不用进行转义&lt;/li>
&lt;li>PRIORITY 采用整数值，可以是负数，值较小的链优先处理。&lt;/li>
&lt;/ul>
&lt;p>COMMAND&lt;/p>
&lt;ol>
&lt;li>add # 在指定的表中添加一条链&lt;/li>
&lt;li>create # 与 add 命令类似，但是如果链已经存在，则返回错误信息。&lt;/li>
&lt;li>delete # 删除指定的链。该链不能包含任何规则，或者被其它规则作为跳转目标，否则删除失败。&lt;/li>
&lt;li>flush #&lt;/li>
&lt;li>list # 列出指定表下指定的链，及其链中的规则&lt;/li>
&lt;li>rename #&lt;/li>
&lt;/ol>
&lt;p>EXAMPLE&lt;/p>
&lt;ol>
&lt;li>nft add chain inet my_table my_utility_chain # 在 inet 簇的 my_table 表上创建一个名为 my_utility_chain 的常规链，没有任何参数&lt;/li>
&lt;li>nft add chain inet my_table my_filter_chain{type filter hook input priority 0;} # 在 inet 簇的 my_table 表上创建一个名为 my_filter_chain 的链，链的类型为 filter，作用在 input 这个 hook 上，优先级为 0&lt;/li>
&lt;li>nft list chain inet my_table my_filter_chain # 列出 inet 簇的 my_table 表下的 my_filter_chain 链的信息，包括其所属的表和其包含的规则&lt;/li>
&lt;/ol>
&lt;h2 id="规则管理命令">规则管理命令&lt;/h2>
&lt;p>nft COMMAND rule [FAMILY] TABLE CHAIN [handle HANDLE|index INDEX] STATEMENT&amp;hellip; # FAMILY 指定簇名，HANDLE 和 INDEX 指定规则的句柄值或索引值，STATEMENT 指明该规则的语句&lt;/p>
&lt;p>nft list ruleset [FAMILY] # 列出所有规则，包括规则所在的链，链所在的表。i.e.列出 nftables 中的所有信息。可以指定 FAMILY 来列出指定簇的规则信息&lt;/p>
&lt;p>[FAMILY] # 清除所有规则，包括表。i.e.清空 nftables 中所有信息。可以指定 FAMILY 来清空指定簇的规则信息&lt;/p>
&lt;p>COMMAND&lt;/p>
&lt;ol>
&lt;li>add # 将规则添加到链的末尾，或者指定规则的 handle 或 index 之后&lt;/li>
&lt;li>insert # 将规则添加到链的开头，或者指定规则的 handle 或 index 之前&lt;/li>
&lt;li>delete # 删除指定的规则。Note:只能通过 handle 删除&lt;/li>
&lt;li>replace # 替换指定规则为新规则&lt;/li>
&lt;/ol>
&lt;p>EXAMPLE&lt;/p>
&lt;ol>
&lt;li>nft add rule inet my_table my_filter_chain tcp dport ssh accept # 在 inet 簇的 my_table 表中的 my_filter_chain 链中添加一条规则，目标端口是 ssh 服务的数据都接受&lt;/li>
&lt;li>nft add rule inet my_table my_filter_chain ip saddr @my_set drop # 创建规则时引用 my_set 集合&lt;/li>
&lt;/ol>
&lt;h2 id="集合管理命令">集合管理命令&lt;/h2>
&lt;p>COMMAND set [FAMILY] table set { type TYPE; [flags FLAGS;] [timeout TIMEOUT ;] [gc-interval GC-INTERVAL ;] [elements = { ELEMENT[,&amp;hellip;] } ;] [size SIZE;] [policy POLICY;] [auto-merge AUTO-MERGE ;] } # 各字段解释详见上文 nftables 的 set 与 map 特性介绍&lt;/p>
&lt;p>list sets # 列出所有结合&lt;/p>
&lt;p>{add | delete} element [family] table set { element[,&amp;hellip;] } # 在指定集合中添加或删除元素&lt;/p>
&lt;p>Note:&lt;/p>
&lt;ul>
&lt;li>在输入命令时，使用反斜线 \ 用来转义分号 ; ，这样 shell 就不会将分号解释为命令的结尾。如果是直接编辑 nftables 的配置文件则不用进行转义&lt;/li>
&lt;/ul>
&lt;p>COMMAND&lt;/p>
&lt;ol>
&lt;li>add&lt;/li>
&lt;li>delete # 通过 handle 删除指定的集合&lt;/li>
&lt;li>flush #&lt;/li>
&lt;li>list #&lt;/li>
&lt;/ol>
&lt;p>EXAMPLE&lt;/p>
&lt;ol>
&lt;li>nft add set inet my_table my_set {type ipv4_addr; } # 在 inet 簇的 my_table 表中创建一个名为 my_set 的集合，集合的类型为 ipv4_addr&lt;/li>
&lt;li>nft add set my_table my_set {type ipv4_addr; flags interval;} # 在默认 ip 簇的 my_table 表中创建一个名为 my_set 的集合，集合类型为 ipv4_addr ，标签为 interval。让该集合支持区间&lt;/li>
&lt;li>nft add element inet my_table my_set { 10.10.10.22, 10.10.10.33 } # 向 my_set 集合中添加元素，一共添加了两个元素，是两个 ipv4 的地址&lt;/li>
&lt;/ol>
&lt;h2 id="字典管理命令">字典管理命令&lt;/h2>
&lt;p>字典&lt;/p>
&lt;p>字典是 nftables 的一个高级特性，它可以使用不同类型的数据并将匹配条件映射到某一个规则上面，并且由于是哈希映射的方式，可以完美的避免链式规则跳转的性能开销。&lt;/p>
&lt;p>例如，为了从逻辑上将对 TCP 和 UDP 数据包的处理规则拆分开来，可以使用字典来实现，这样就可以通过一条规则实现上述需求。&lt;/p>
&lt;p>$ nft add chain inet my_table my_tcp_chain&lt;/p>
&lt;p>$ nft add chain inet my_table my_udp_chain&lt;/p>
&lt;p>$ nft add rule inet my_table my_filter_chain meta l4proto vmap { tcp : jump my_tcp_chain, udp : jump my_udp_chain }&lt;/p>
&lt;p>$ nft list chain inet my_table my_filter_chain&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>table inet my_table &lt;span style="color:#f92672">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> chain my_filter_chain &lt;span style="color:#f92672">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ...
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> meta nfproto ipv4 ip saddr . meta l4proto . udp dport &lt;span style="color:#f92672">{&lt;/span> 10.30.30.30 . udp . bootps &lt;span style="color:#f92672">}&lt;/span> accept
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> meta l4proto vmap &lt;span style="color:#f92672">{&lt;/span> tcp : jump my_tcp_chain, udp : jump my_udp_chain &lt;span style="color:#f92672">}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>和集合一样，除了匿名字典之外，还可以创建命名字典：&lt;/p>
&lt;p>$ nft add map inet my_table my_vmap { type inet_proto : verdict ; }&lt;/p>
&lt;p>向字典中添加元素：&lt;/p>
&lt;p>$ nft add element inet my_table my_vmap { 192.168.0.10 : drop, 192.168.0.11 : accept }&lt;/p>
&lt;p>后面就可以在规则中引用字典中的元素了：&lt;/p>
&lt;p>$ nft add rule inet my_table my_filter_chain ip saddr vmap @my_vmap&lt;/p>
&lt;ol start="9">
&lt;li>&lt;/li>
&lt;/ol>
&lt;p>表与命名空间&lt;/p>
&lt;p>在 nftables 中，每个表都是一个独立的命名空间，这就意味着不同的表中的链、集合、字典等都可以有相同的名字。例如：&lt;/p>
&lt;p>$ nft add table inet table_one&lt;/p>
&lt;p>$ nft add chain inet table_one my_chain&lt;/p>
&lt;p>$ nft add table inet table_two&lt;/p>
&lt;p>$ nft add chain inet table_two my_chain&lt;/p>
&lt;p>$ nft list ruleset&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>...
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>table inet table_one &lt;span style="color:#f92672">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> chain my_chain &lt;span style="color:#f92672">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>table inet table_two &lt;span style="color:#f92672">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> chain my_chain &lt;span style="color:#f92672">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>有了这个特性，不同的应用就可以在相互不影响的情况下管理自己的表中的规则，而使用 iptables 就无法做到这一点。&lt;/p>
&lt;p>当然，这个特性也有缺陷，由于每个表都被视为独立的防火墙，那么某个数据包必须被所有表中的规则放行，才算真正的放行，即使 table_one 允许该数据包通过，该数据包仍然有可能被 table_two 拒绝。为了解决这个问题，nftables 引入了优先级，priority 值越高的链优先级越低，所以 priority 值低的链比 priority 值高的链先执行。如果两条链的优先级相同，就会进入竞争状态。&lt;/p>
&lt;p>总结&lt;/p>
&lt;p>希望通过本文的讲解，你能对 nftables 的功能和用法有所了解，当然本文只涉及了一些浅显的用法，更高级的用法可以查看 nftables 的官方 wiki，或者坐等我接下来的文章。相信有了本文的知识储备，你应该可以愉快地使用 nftables 实现 Linux 的智能分流了，具体扫一扫下方的二维码参考这篇文章：Linux 全局智能分流方案。&lt;/p></description></item></channel></rss>