<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>断念梦 – 特殊文件系统</title><link>https://desistdaydream.github.io/docs/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2.Kernel/6.Filesystem/%E7%89%B9%E6%AE%8A%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/</link><description>Recent content in 特殊文件系统 on 断念梦</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><atom:link href="https://desistdaydream.github.io/docs/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2.Kernel/6.Filesystem/%E7%89%B9%E6%AE%8A%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/index.xml" rel="self" type="application/rss+xml"/><item><title>Docs: tmpfs</title><link>https://desistdaydream.github.io/docs/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2.Kernel/6.Filesystem/%E7%89%B9%E6%AE%8A%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/tmpfs/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2.Kernel/6.Filesystem/%E7%89%B9%E6%AE%8A%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/tmpfs/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://www.kernel.org/doc/html/latest/filesystems/tmpfs.html">Kernel 文档，文件系统-tmpfs&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>Tmpfs 是一个将所有文件保存在虚拟内存中的文件系统。tmpfs 中的所有内容都是 &lt;strong>temporary(临时)&lt;/strong> 的，因为不会在硬盘上创建任何文件。如果卸载 tmpfs 实例，其中存储的所有内容都会丢失。&lt;/p>
&lt;p>tmpfs 将所有内容放入内核内部缓存中，并增长和收缩以容纳其包含的文件，并且如果为 tmpfs 挂载启用了交换，则能够将不需要的页面交换到交换空间。 tmpfs 还支持 THP。&lt;/p>
&lt;h1 id="分类">分类&lt;/h1>
&lt;p>#文件系统&lt;/p></description></item><item><title>Docs: Device File System</title><link>https://desistdaydream.github.io/docs/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2.Kernel/6.Filesystem/%E7%89%B9%E6%AE%8A%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/Device-File-System/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2.Kernel/6.Filesystem/%E7%89%B9%E6%AE%8A%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/Device-File-System/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://man.cx/devfs">Manual(手册)，devfs(5)&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.ibm.com/developerworks/cn/linux/l-devmapper/index.html">IBM，开发工作-Linux-DM 机制&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>&lt;strong>Device File System(设备文件系统，简称 devfs)&lt;/strong>，提供对全局文件系统名称空间中内核设备名称空间的访问。&lt;code>一般挂载到 /dev 目录&lt;/code>。&lt;/p>
&lt;p>这个文件系统包含一些目录、链接、符号链接和设备，其中一些是可写的。在 chroot 环境中，可以使用 devfs 创建一个新的/dev 挂载点。&lt;/p>
&lt;p>The &lt;a href="https://man.cx/mknod(8)">mknod(8)&lt;/a> 工具可用于恢复 devfs 下已删除的设备。&lt;/p>
&lt;h1 id="devdm-">/dev/dm-*&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Device_mapper">Wiki,Device mapper&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>&lt;strong>Device Mapper(设备映射，简称 dm)&lt;/strong>，是一个由 Linux 内核提供的框架，用于将物理块设备映射到更高级别的虚拟块设备。dm 是 LVM、软 Raid、dm-crypt 磁盘加密的基础。&lt;/p>
&lt;p>dm 通过将将数据从虚拟块设备传递到另一个块设备来工作。数据也可以再过渡中进行修改，例如，在设备映射器提供磁盘加密或模拟不可靠硬件行为的情况下，可以执行此操作。&lt;/p>
&lt;h3 id="dmsetup-命令行工具">dmsetup 命令行工具&lt;/h3>
&lt;p>dmsetup ls # 列出 dm 设备&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>~&lt;span style="color:#f92672">]&lt;/span>&lt;span style="color:#75715e"># dmsetup ls&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>vg1-swap &lt;span style="color:#f92672">(&lt;/span>253:1&lt;span style="color:#f92672">)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>vg1-root &lt;span style="color:#f92672">(&lt;/span>253:0&lt;span style="color:#f92672">)&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>其中 253 后面的数字，就是 dm-X 那个 X。所以 dm-0 对应 vg1-root 这个设备。使用 lsblk 命令可以看到 dm 与 块设备的关联关系。&lt;/p>
&lt;h1 id="分类">分类&lt;/h1>
&lt;p>#文件系统&lt;/p></description></item><item><title>Docs: OverlayFS</title><link>https://desistdaydream.github.io/docs/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2.Kernel/6.Filesystem/%E7%89%B9%E6%AE%8A%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/OverlayFS/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2.Kernel/6.Filesystem/%E7%89%B9%E6%AE%8A%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/OverlayFS/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://mp.weixin.qq.com/s/ddArEEZMbjmYefgDVSP7xg">公众号-MoeLove，聊聊 Docker 的存储驱动 Overlay2&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>大家好，我是张晋涛。&lt;/p>
&lt;p>上周在我的交流群里有个小伙伴问到了 Overlay2 相关的问题，这篇就来介绍一下。(想进群的可以留言）&lt;/p>
&lt;p>本节，我将为你介绍 Docker 现在推荐使用的存储驱动 Overlay2，在开始之前，你可以执行以下命令来查看 Docker 正在使用的存储驱动：&lt;/p>
&lt;p>&lt;code>(MoeLove) ➜  ~ docker info --format '{{.Driver}}'                   overlay2&lt;/code>&lt;/p>
&lt;p>如果你看到的结果也是 &lt;code>overlay2&lt;/code> 说明你的 Docker 已经在使用 overlay2 存储驱动了。我在个人工作站上用的是 btrfs，这是因为自从 Fedora 33 开始，btrfs 就成为了 Fedora 默认的文件系统。不过服务器上就都是 overlay2 了。&lt;/p>
&lt;p>你也可能会看到其他不同的结果，可以在启动 docker daemon 的时候，通过 &lt;code>--storage-driver&lt;/code> 参数进行指定，也可以在 &lt;code>/etc/docker/daemon.json&lt;/code> 文件中通过 &lt;code>storage-driver&lt;/code> 字段进行配置。&lt;/p>
&lt;p>目前对于 Docker 最新版本而言，你有以下几种存储驱动可供选择：&lt;/p>
&lt;ul>
&lt;li>&lt;code>overlay2&lt;/code>&lt;/li>
&lt;li>&lt;code>fuse-overlayfs&lt;/code>&lt;/li>
&lt;li>&lt;code>btrfs&lt;/code>&lt;/li>
&lt;li>&lt;code>zfs&lt;/code>&lt;/li>
&lt;li>&lt;code>aufs&lt;/code>&lt;/li>
&lt;li>&lt;code>overlay&lt;/code>&lt;/li>
&lt;li>&lt;code>devicemapper&lt;/code>&lt;/li>
&lt;li>&lt;code>vfs&lt;/code>&lt;/li>
&lt;/ul>
&lt;p>但它们对于你使用的文件系统之类的都有不同的要求，且实现方式也不尽相同。我以本节的重点 &lt;code>overlay2&lt;/code> 存储驱动为例，它需要你使用 Linux 4.x 以上版本的内核，或者是对于 RHEL/CentOS 等需要使用 3.10.0-514 以上的内核（旧版本中存在一些兼容性问题，我在之前的文章中有提到过）。&lt;/p>
&lt;p>同时，它支持你使用 ext4 的文件系统，或者增加了 &lt;code>ftype=1&lt;/code> 的 xfs 文件系统。可以通过 &lt;code>docker info&lt;/code> 进行得到文件系统相关的信息。&lt;/p>
&lt;p>&lt;code># 省略了部分输出 (MoeLove) ➜  ~ docker info                    Storage Driver: overlay2   Backing Filesystem: extfs   Supports d_type: true   Native Overlay Diff: true&lt;/code>&lt;/p>
&lt;h2 id="存储驱动的作用">存储驱动的作用&lt;/h2>
&lt;p>前面虽然已经聊了如何设置和检查当前在用的存储驱动，但尚未介绍为何一定要使用存储驱动，以及它的作用。&lt;/p>
&lt;p>还记得我在之前的文章&lt;a href="http://mp.weixin.qq.com/s?__biz=MzI2ODAwMzUwNA==&amp;amp;mid=2649295920&amp;amp;idx=1&amp;amp;sn=b89577714e45ef6d1944be3e209b415b&amp;amp;chksm=f2eb9defc59c14f9fe126f4e9cb71f71c802326bded6478ff86d240b844a7f91067a3c3b2248&amp;amp;scene=21#wechat_redirect">《万字长文：彻底搞懂容器镜像构建》&lt;/a>中为你介绍的 Docker 如何存储镜像相关的内容吗，如果忘了可以回头复习一下。&lt;/p>
&lt;p>Docker 将容器镜像做了分层存储，每个层相当于包含着一条 Dockerfile 的指令。而这些层在磁盘上的存储方式，以及在启动容器时，如何组织这些层，并提供可写层，便是存储驱动的主要作用了。&lt;/p>
&lt;p>另外需要注意的是：不同的存储驱动实现不同，性能也有差异，同时使用不同的存储驱动也会导致占用的磁盘空间有所不同。&lt;/p>
&lt;p>同时：由于它们的实现不同，当你修改存储驱动后，可能会导致看不到原有的镜像，容器等，这是正常的，不必担心，切换回原先的驱动即可见。&lt;/p>
&lt;h2 id="overlayfs">OverlayFS&lt;/h2>
&lt;p>了解完前面的背景知识后，你也看到了我刚才列出的可用存储驱动中有两个 &lt;code>overlay&lt;/code> 和 &lt;code>overlay2&lt;/code>，其实 &lt;code>overlay2&lt;/code> 算是 &lt;code>overlay&lt;/code> 的升级版，这两个存储驱动所用的都是 &lt;code>OverlayFS&lt;/code> 。&lt;/p>
&lt;p>&lt;code>overlay&lt;/code> 驱动是在 2014 年 8 月份首次进入 Docker 的，而 &lt;code>overlay2&lt;/code> 则是在 2016 年 6 月份被合并，并首次出现在 Docker 1.12 中的。它的出现是为了解决 &lt;code>overlay&lt;/code> 存储驱动可能造成 inode 耗尽的问题。&lt;/p>
&lt;p>简单介绍完 &lt;code>overlay&lt;/code> 和 &lt;code>overlay2&lt;/code> ，我们将重点回归到 &lt;code>OverlayFS&lt;/code> 上。&lt;/p>
&lt;p>我们启动一个容器，以此为切入点来认识下 OverlayFS，注意：以下内容使用 Linux 5.4 内核以及 Docker 20.10.21，不同环境下可能结果略有差异。&lt;/p>
&lt;p>`#  检查无在运行的容器和  overlay  挂载
(MoeLove) ➜  ~ mount |grep overlay
(MoeLove) ➜  ~ docker ps
CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS               NAMES&lt;/p>
&lt;p>#  启动一个容器
(MoeLove) ➜  ~ docker run &amp;ndash;rm -d alpine sleep 99999                         
caa9517ce0d799602735a30aaaaf123c07e07ff6e44c5a4b07e776af85780abe
(MoeLove) ➜  ~ docker ps
CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS               NAMES
caa9517ce0d7        alpine              &amp;ldquo;sleep 99999&amp;rdquo;       23 seconds ago      Up 22 seconds                           hopeful_dubinsky&lt;/p>
&lt;p>#  检查  overlay  挂载
(MoeLove) ➜  ~ mount |grep overlay                  
overlay on /var/lib/docker/overlay2/f4356a8f14342008fc298bf3d313b863d10f30ef447a3b2f51ea9ece0dec09db/merged type overlay (rw,relatime,seclabel,lowerdir=/var/lib/docker/overlay2/l/5OO3RLRXHJPEH3IFEXNCTO4PY5:/var/lib/docker/overlay2/l/UVA7IR67ZZTN2BNTKCZ7T6HUWU,upperdir=/var/lib/docker/overlay2/f4356a8f14342008fc298bf3d313b863d10f30ef447a3b2f51ea9ece0dec09db/diff,workdir=/var/lib/docker/overlay2/f4356a8f14342008fc298bf3d313b863d10f30ef447a3b2f51ea9ece0dec09db/work)&lt;/p>
&lt;p>`&lt;/p>
&lt;p>可以看到，在启动容器后，系统上多了一个 OverlayFS (overlay) 的挂载。注意看其中的几个内容：&lt;/p>
&lt;ul>
&lt;li>挂载点在：&lt;code>/var/lib/docker/overlay2/f4356a8f14342008fc298bf3d313b863d10f30ef447a3b2f51ea9ece0dec09db/merged&lt;/code>
&lt;code>(MoeLove) ➜  ~ sudo ls /var/lib/docker/overlay2/f4356a8f14342008fc298bf3d313b863d10f30ef447a3b2f51ea9ece0dec09db/merged bin  dev  etc  home  lib  media  mnt  opt  proc  root  run  sbin  srv  sys  tmp  usr  var&lt;/code>
其中的内容，看着很熟悉，是我们所启动容器根目录中的内容。为了验证这一说法，我在容器中新写一个文件：
&lt;code>(MoeLove) ➜  ~ docker exec -it $(docker ps -ql) sh / # echo 'Hello Docker' &amp;gt; moelove-info&lt;/code>
再次查看此挂载点中的内容：
&lt;code>(MoeLove) ➜  ~ sudo ls  /var/lib/docker/overlay2/22be5e4dc4541a60aa4f6de628c3938e7fdc9c4b117277274cd911c46166986b/merged bin  dev  moelove-info  etc  home  lib  media  mnt  opt  proc  root  run  sbin  srv  sys  tmp  usr  var (MoeLove) ➜  ~ sudo cat /var/lib/docker/overlay2/f4356a8f14342008fc298bf3d313b863d10f30ef447a3b2f51ea9ece0dec09db/merged/moelove-info Hello Docker&lt;/code>
可以看到刚才写的内容已经在这个挂载点的目录中了。&lt;/li>
&lt;li>&lt;code>lowerdir&lt;/code>: 这是 我们 mount 的目录。
这个 &lt;code>lowerdir&lt;/code> 中包含两个目录，这是使用了内核对 OverlayFS multi layer 特性的支持，我们分别查看下其中内容：
&lt;code>(MoeLove) ➜  ~ sudo ls -a /var/lib/docker/overlay2/l/5OO3RLRXHJPEH3IFEXNCTO4PY5 .  ..  dev  .dockerenv  etc (MoeLove) ➜  ~ sudo ls -a /var/lib/docker/overlay2/l/UVA7IR67ZZTN2BNTKCZ7T6HUWU .  ..  bin  dev  etc  home  lib  media  mnt  opt  proc  root  run  sbin  srv  sys  tmp  usr  var&lt;/code>
这两个目录，是不是看着很熟悉？
是的，它们就是我们所启动容器根目录中的大部分内容。为什么说是大部分内容呢？当我们查看其中的内容时，你也会发现它们的内容也并不完整。比如我们刚才新写入的 &lt;code>moelove-info&lt;/code> 文件，或者当我们查看 &lt;code>etc&lt;/code> 目录下的文件，你也会发现其中都只是常规系统 &lt;code>/etc&lt;/code> 目录下的部分内容。
&lt;code>(MoeLove) ➜  ~ sudo ls /var/lib/docker/overlay2/l/5OO3RLRXHJPEH3IFEXNCTO4PY5/etc    hostname  hosts  mtab  resolv.conf (MoeLove) ➜  ~ sudo ls /var/lib/docker/overlay2/l/UVA7IR67ZZTN2BNTKCZ7T6HUWU/etc  alpine-release  fstab     init.d       modprobe.d      mtab        passwd     protocols  shells       udhcpd.conf apk             group     inittab      modules         network     periodic   securetty  ssl conf.d          hostname  issue        modules-load.d  opt         profile    services   sysctl.conf crontabs        hosts     logrotate.d  motd            os-release  profile.d  shadow     sysctl.d&lt;/code>&lt;/li>
&lt;li>&lt;code>upperdir&lt;/code> 是另一个重要的目录，我们来看看其中的内容
&lt;code>(MoeLove) ➜  ~ sudo ls -a /var/lib/docker/overlay2/f4356a8f14342008fc298bf3d313b863d10f30ef447a3b2f51ea9ece0dec09db/diff   .  ..  moelove-info  root&lt;/code>
我们发现这个目录中包含着刚才创建的 &lt;code>moelove-info&lt;/code> 文件。同时，其中也包含一个 &lt;code>root&lt;/code> 目录，这个目录便是我们默认使用的 &lt;code>root&lt;/code> 用户的家目录。
如果去查看其中的内容，也会发现刚才我们执行命令的历史记录。&lt;/li>
&lt;li>&lt;code>workdir&lt;/code> 这个目录和 &lt;code>upperdir&lt;/code> 在同一个父目录下，查看其内容发现里面只有一个 &lt;code>work&lt;/code> 目录
&lt;code>(MoeLove) ➜  ~ sudo ls -a /var/lib/docker/overlay2/f4356a8f14342008fc298bf3d313b863d10f30ef447a3b2f51ea9ece0dec09db/work .  ..  work&lt;/code>&lt;/li>
&lt;/ul>
&lt;p>看完以上的介绍，想必你已经发现了它们之间的部分联系，在此之前，我们在额外看一个目录，那就是 &lt;code>upperdir&lt;/code> 和 &lt;code>workdir&lt;/code> 以及挂载点共同的父目录：&lt;/p>
&lt;p>&lt;code>(MoeLove) ➜  ~ sudo ls  /var/lib/docker/overlay2/f4356a8f14342008fc298bf3d313b863d10f30ef447a3b2f51ea9ece0dec09db  diff  link  lower  merged  work&lt;/code>&lt;/p>
&lt;p>你会发现这个目录下的内容就比较直观了。我们刚才已经看了其中 &lt;code>diff&lt;/code>，&lt;code>merged&lt;/code> 和 &lt;code>work&lt;/code> 目录的内容了，现在看看 &lt;code>lower&lt;/code> 中的内容吧：&lt;/p>
&lt;p>&lt;code>(MoeLove) ➜  ~ sudo cat /var/lib/docker/overlay2/f4356a8f14342008fc298bf3d313b863d10f30ef447a3b2f51ea9ece0dec09db/lower l/5OO3RLRXHJPEH3IFEXNCTO4PY5:l/UVA7IR67ZZTN2BNTKCZ7T6HUWU&lt;/code>&lt;/p>
&lt;p>我们发现，&lt;code>lower&lt;/code> 文件中的内容是以 &lt;code>:&lt;/code> 分隔的两个 &lt;code>lowerdir&lt;/code> 的目录名称。&lt;/p>
&lt;p>至此，我们可以得到以下结论：&lt;/p>
&lt;ul>
&lt;li>&lt;code>lower&lt;/code> 是基础层，可以包含多个 &lt;code>lowerdir&lt;/code>；&lt;/li>
&lt;li>&lt;code>diff&lt;/code> 是可写层，即挂载时的 &lt;code>upperdir&lt;/code>，在容器内变更的文件都在这一层存储；&lt;/li>
&lt;li>&lt;code>merged&lt;/code> 是最终的合并结果，即容器给我们呈现出来的结果；&lt;/li>
&lt;/ul>
&lt;h2 id="overlay2">Overlay2&lt;/h2>
&lt;p>经过前面对 Docker 启动容器后挂载的 OverlayFS 的介绍后，Overlay2 的工作流程想必你也就比较清楚了。&lt;/p>
&lt;p>将镜像各层作为 &lt;code>lower&lt;/code> 基础层，同时增加 &lt;code>diff&lt;/code> 这个可写层，通过 OverlayFS 的工作机制，最终将 &lt;code>merged&lt;/code> 作为容器内的文件目录展示给用户。&lt;/p>
&lt;p>你可能会有疑问，如果只是这样简单的组织，会不会有什么限制呢？答案是肯定的，当然有限制，我们可以通过 Overlay2 的代码来看&lt;/p>
&lt;p>&lt;code>// daemon/graphdriver/overlay2/overlay.go#L442 func (d *Driver) getLower(parent string) (string, error) { // 省略部分内容  if len(lowers) &amp;gt; maxDepth {   return &amp;quot;&amp;quot;, errors.New(&amp;quot;max depth exceeded&amp;quot;)  } }&lt;/code>&lt;/p>
&lt;p>可以看到其对 lower 的深度有硬编码的限制，当前硬编码的限制是 128 。如果你在使用的过程中遇到这个错误，那表示你超过了最大深度限制，你就需要找些办法来减少层级了。&lt;/p>
&lt;h2 id="总结">总结&lt;/h2>
&lt;p>本节，我为你介绍了 OverlayFS 及 Overlay2 存储驱动相关的内容。通过实际启动容器生成的相关目录来介绍 overlay2 的工作流程，想必通过这种方式能更易理解。&lt;/p>
&lt;h1 id="分类">分类&lt;/h1>
&lt;p>#文件系统&lt;/p></description></item><item><title>Docs: Proc File System</title><link>https://desistdaydream.github.io/docs/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2.Kernel/6.Filesystem/%E7%89%B9%E6%AE%8A%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/Proc-File-System/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2.Kernel/6.Filesystem/%E7%89%B9%E6%AE%8A%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/Proc-File-System/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://man7.org/linux/man-pages/man5/proc.5.html">Manual(手册)，proc(5)&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>&lt;strong>process information pseudo-filesystem(进程信息伪文件系统，简称 proc)&lt;/strong>， 提供了内核数据结构的接口。&lt;code>一般挂载到 /proc 目录&lt;/code>。一般情况是由操作系统自动挂载的，也可以通过&lt;code>mount -t proc proc /proc&lt;/code>命令手动挂载。proc 文件系统中的大多数文件都是只读的，但是有些文件是可写的，用于改变内核参数。&lt;/p>
&lt;p>proc 文件系统不用于存储。其主要目的是为硬件，内存，运行的进程和其他系统组件提供基于文件的接口。通过查看相应的 /proc 文件，可以检索许多系统组件上的实时信息。/proc 中的某些文件也可以（由用户和应用程序）操纵以配置内核。&lt;/p>
&lt;h1 id="procpid---每个进程自己的独立信息">/proc/PID/ - 每个进程自己的独立信息&lt;/h1>
&lt;p>&lt;strong>每个进程在 /proc 下有一个名为自己进程号的目录，该目录记载了该进程相关的 proc 信息。&lt;/strong>&lt;/p>
&lt;h2 id="cgroup---进程所属的控制组信息">./cgroup - 进程所属的控制组信息&lt;/h2>
&lt;p>详见 &lt;a href="https://desistdaydream.github.io/docs/10.%E4%BA%91%E5%8E%9F%E7%94%9F/2.1.%E5%AE%B9%E5%99%A8/2.CGroup/2.CGroup.md">Cgroup&lt;/a>&lt;/p>
&lt;h2 id="cmdline---该进程的完整命令">./cmdline - 该进程的完整命令&lt;/h2>
&lt;ul>
&lt;li>除非进程是僵尸和内核态进程。在后一种情况下，这个文件中什么也没有：也就是说，对这个文件的读取将返回 0 个字符。命令行参数在这个文件中以一组字符串的形式出现，用空字节(&amp;rsquo;\0&amp;rsquo;)隔开，在最后一个字符串之后还有一个空字节。&lt;/li>
&lt;li>把这个文件看作是进程希望你看到的命令行。&lt;/li>
&lt;/ul>
&lt;h2 id="exe---具有该-pid-的实际运行的程序的绝对路径是一个符号链接">./exe - 具有该 PID 的实际运行的程序的绝对路径。是一个符号链接&lt;/h2>
&lt;h2 id="fd---其中包含-pid-进程打开的每个文件的一个条目">./fd/ - 其中包含 PID 进程打开的每个文件的一个条目&lt;/h2>
&lt;ul>
&lt;li>该条目由其文件描述符命名，并且是指向实际文件的符号链接。 因此，0 是标准输入，1 是标准输出，2 是标准错误，依此类推。详解见：&lt;a href="docs/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2.Kernel/6.Filesystem/%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86/File%20Descriptor(%E6%96%87%E4%BB%B6%E6%8F%8F%E8%BF%B0%E7%AC%A6).md">File Descriptor(文件描述符)&lt;/a>&lt;/li>
&lt;/ul>
&lt;h2 id="fdinfo---其中包含-pid-进程打开的每个文件的一个条目该条目由其文件描述符命名">./fdinfo/ - 其中包含 PID 进程打开的每个文件的一个条目，该条目由其文件描述符命名&lt;/h2>
&lt;p>该目录中的文件仅由进程所有者读取。 可以读取每个文件的内容以获得有关相应文件描述符的信息。 内容取决于相应文件描述符所引用的文件类型。详解见：&lt;a href="docs/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2.Kernel/6.Filesystem/%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86/File%20Descriptor(%E6%96%87%E4%BB%B6%E6%8F%8F%E8%BF%B0%E7%AC%A6).md">File Descriptor(文件描述符)&lt;/a>&lt;/p>
&lt;h2 id="maps---进程的内存映射信息">./maps - 进程的内存映射信息&lt;/h2>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>&amp;gt; cat /proc/1751/maps
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>00400000-00401000 r-xp &lt;span style="color:#ae81ff">00000000&lt;/span> fd:01 &lt;span style="color:#ae81ff">100897359&lt;/span> /opt/java/jdk1.8.0_231/bin/java
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>00600000-00601000 r--p &lt;span style="color:#ae81ff">00000000&lt;/span> fd:01 &lt;span style="color:#ae81ff">100897359&lt;/span> /opt/java/jdk1.8.0_231/bin/java
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>00601000-00602000 rw-p &lt;span style="color:#ae81ff">00001000&lt;/span> fd:01 &lt;span style="color:#ae81ff">100897359&lt;/span> /opt/java/jdk1.8.0_231/bin/java
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>01542000-01563000 rw-p &lt;span style="color:#ae81ff">00000000&lt;/span> 00:00 &lt;span style="color:#ae81ff">0&lt;/span> &lt;span style="color:#f92672">[&lt;/span>heap&lt;span style="color:#f92672">]&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>6c7c00000-6e0100000 rw-p &lt;span style="color:#ae81ff">00000000&lt;/span> 00:00 &lt;span style="color:#ae81ff">0&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>6e0100000-76d400000 ---p &lt;span style="color:#ae81ff">00000000&lt;/span> 00:00 &lt;span style="color:#ae81ff">0&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>76d400000-797580000 rw-p &lt;span style="color:#ae81ff">00000000&lt;/span> 00:00 &lt;span style="color:#ae81ff">0&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>797580000-7c0000000 ---p &lt;span style="color:#ae81ff">00000000&lt;/span> 00:00 &lt;span style="color:#ae81ff">0&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>7c0000000-7c18a0000 rw-p &lt;span style="color:#ae81ff">00000000&lt;/span> 00:00 &lt;span style="color:#ae81ff">0&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>7c18a0000-800000000 ---p &lt;span style="color:#ae81ff">00000000&lt;/span> 00:00 &lt;span style="color:#ae81ff">0&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ul>
&lt;li>address 字段表示进程中内存映射占据的地址空间，格式为十六进制的 BeginAddress-EndAddress。&lt;/li>
&lt;li>perms 字段表示权限，共四个字符，依次为 rwxs 或 rwxp，其中 r 为 read，w 为 write，x 为 execute，s 为- -shared，p 为 private，对应位置没有权限时用一个短横线代替。&lt;/li>
&lt;li>offset 字段表示内存映射地址在文件中的字节偏移量。&lt;/li>
&lt;li>dev 字段表示 device，格式为 major:minor。&lt;/li>
&lt;li>inode 字段表示对应 device 的 inode，0 表示内存映射区域没有关联的 inode，如未初始化的 BSS 数据段就是这种情况。&lt;/li>
&lt;li>pathname 字段用于内存映射的文件，对于 ELF 格式的文件来说，可以通过命令 readelf -l 查看 ELF 程序头部的 Offset 字段，与 maps 文件的 offset 字段作对比。pathname 可能为空，表示匿名映射，这种情况下难以调试进程，如 gdb、strace 等命令。除了正常的文件路径之外，pathname 还可能是下面的值：
&lt;ul>
&lt;li>[stack]     初始进程（主线程）的 stack&lt;/li>
&lt;li>[stack:&amp;lt;tid&amp;gt;]     线程 ID 为 tid 的 stack.  对应于/proc/[pid]/task/[tid]/路径&lt;/li>
&lt;li>[vdso]    Virtual Dynamically linked Shared Object&lt;/li>
&lt;li>[heap]     进程的 heap&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h2 id="mountinfo---进程的-mount-namespace-的信息">./mountinfo - 进程的 mount namespace 的信息&lt;/h2>
&lt;p>该文件比 /proc/PID/mounts 的信息更全免并修复了一些问题，适用于云原生时代的大量 mount namesapces。&lt;/p>
&lt;p>该文件中每一行都是一条挂载信息，每条挂载信息由如下几个部分组成：&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>挂载 ID&lt;/th>
&lt;th>父 ID&lt;/th>
&lt;th>major:minor&lt;/th>
&lt;th>root&lt;/th>
&lt;th>mount point&lt;/th>
&lt;th>mount options&lt;/th>
&lt;th>optional fields&lt;/th>
&lt;th>separator&lt;/th>
&lt;th>filesystem type&lt;/th>
&lt;th>mount source&lt;/th>
&lt;th>super options&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>36&lt;/td>
&lt;td>35&lt;/td>
&lt;td>98:00:00&lt;/td>
&lt;td>/mnt1&lt;/td>
&lt;td>/mnt2&lt;/td>
&lt;td>rw,noatime&lt;/td>
&lt;td>master:1&lt;/td>
&lt;td>-&lt;/td>
&lt;td>ext3&lt;/td>
&lt;td>/dev/root&lt;/td>
&lt;td>rw,errors=continue&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;ul>
&lt;li>mount ID # 挂载的唯一 ID&lt;/li>
&lt;li>parent ID # the ID of the parent mount (or of self for the root of this mount namespace&amp;rsquo;s mount tree).
&lt;ul>
&lt;li>If a new mount is stacked on top of a previous existing mount (so that it hides the existing mount) at pathname P, then the parent of the new mount is the previous mount at that location. Thus, when looking at all the mounts stacked at a particular location, the top-most mount is the one that is not the parent of any other mount at the same location. (Note, however, that this top-most mount will be accessible only if the longest path subprefix of P that is a mount point is not itself hidden by a stacked mount.)&lt;/li>
&lt;li>If the parent mount lies outside the process&amp;rsquo;s root directory (see chroot(2)), the ID shown here won&amp;rsquo;t have a corresponding record in mountinfo whose mount ID (field 1) matches this parent mount ID (because mounts that lie outside the process&amp;rsquo;s root directory are not shown in mountinfo). As a special case of this point, the process&amp;rsquo;s root mount masy have a parent mount (for the initramfs filesystem) that lies outside the process&amp;rsquo;s root directory, and an entry for that mount will not appear in mountinfo.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>major:minor # the value of st_dev for files on this filesystem (see &lt;a href="https://man7.org/linux/man-pages/man2/stat.2.html">stat(2)&lt;/a>).&lt;/li>
&lt;li>root # the pathname of the directory in the filesystem which forms the root of this mount.&lt;/li>
&lt;li>mount point # 挂载点 the pathname of the mount point relative to the process&amp;rsquo;s root directory.&lt;/li>
&lt;li>mount options # 挂载选项 per-mount options (see mount(2)).&lt;/li>
&lt;li>optional fields # zero or more fields of the form &amp;ldquo;tag[:value]&amp;rdquo;; see below.&lt;/li>
&lt;li>separator # the end of the optional fields is marked by a single hyphen.&lt;/li>
&lt;li>filesystem type # 挂载的文件系统类型 the filesystem type in the form &amp;ldquo;type[.subtype]&amp;rdquo;.&lt;/li>
&lt;li>mount source # filesystem-specific information or &amp;ldquo;none&amp;rdquo;.&lt;/li>
&lt;li>super options # 超级快选项。per-superblock options (see mount(2)).&lt;/li>
&lt;/ul>
&lt;h2 id="root---每个进程的文件系统的--目录">./root/ - 每个进程的文件系统的 &lt;code>/&lt;/code> 目录&lt;/h2>
&lt;p>/proc/PID/root/ 目录是一个指向进程根目录的软链接，效果如下：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>~&lt;span style="color:#f92672">]&lt;/span>&lt;span style="color:#75715e"># ls -l /proc/1192/root&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>lrwxrwxrwx &lt;span style="color:#ae81ff">1&lt;/span> root root &lt;span style="color:#ae81ff">0&lt;/span> Nov &lt;span style="color:#ae81ff">11&lt;/span> 10:42 root -&amp;gt; /
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>该目录通过 chroot(2) 系统调用设置。&lt;/p>
&lt;p>该目录常被用来查看容器内的文件系统。与容器的 Merged 不同，该目录会包含所有挂载，这些挂载信息，来源于 /proc/PID/mountinfo 文件。&lt;/p>
&lt;h2 id="smaps---每个进程的内存映射的使用信息">./smaps - 每个进程的内存映射的使用信息&lt;/h2>
&lt;p>仅当内核选项 CONFIG_PROC_PAGE_MONITOR 配置了之后，才存在该文件。&lt;code>pmap&lt;/code> 命令会读取该文件，并以人类易读的形式显示信息。&lt;/p>
&lt;p>进程的每一个映射，都有其对应的信息，文件格式如下：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>00400000-00aa4000 r-xp &lt;span style="color:#ae81ff">00000000&lt;/span> fc:01 &lt;span style="color:#ae81ff">1710957&lt;/span> /bin/node_exporter
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Size: &lt;span style="color:#ae81ff">6800&lt;/span> kB
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>KernelPageSize: &lt;span style="color:#ae81ff">4&lt;/span> kB
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>MMUPageSize: &lt;span style="color:#ae81ff">4&lt;/span> kB
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Rss: &lt;span style="color:#ae81ff">5852&lt;/span> kB
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>......
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>00aa4000-01077000 r--p 006a4000 fc:01 &lt;span style="color:#ae81ff">1710957&lt;/span> /bin/node_exporter
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Size: &lt;span style="color:#ae81ff">5964&lt;/span> kB
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>KernelPageSize: &lt;span style="color:#ae81ff">4&lt;/span> kB
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>MMUPageSize: &lt;span style="color:#ae81ff">4&lt;/span> kB
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Rss: &lt;span style="color:#ae81ff">5508&lt;/span> kB
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>......
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>7fe089fd7000-7fe08c708000 rw-p &lt;span style="color:#ae81ff">00000000&lt;/span> 00:00 &lt;span style="color:#ae81ff">0&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>......
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>7fe08c708000-7fe09c888000 ---p &lt;span style="color:#ae81ff">00000000&lt;/span> 00:00 &lt;span style="color:#ae81ff">0&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>......
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>7fe09c888000-7fe09c889000 rw-p &lt;span style="color:#ae81ff">00000000&lt;/span> 00:00 &lt;span style="color:#ae81ff">0&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>......
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>......
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>ffffffffff600000-ffffffffff601000 --xp &lt;span style="color:#ae81ff">00000000&lt;/span> 00:00 &lt;span style="color:#ae81ff">0&lt;/span> &lt;span style="color:#f92672">[&lt;/span>vsyscall&lt;span style="color:#f92672">]&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>......
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>该进程的映射信息与 /proc/PID/maps 文件中的内容相同。该文件的每一个映射信息下面的都包含内存使用量&lt;/p>
&lt;ul>
&lt;li>&lt;strong>Size&lt;/strong> # 该映射的内存大小
&lt;ul>
&lt;li>通过 &lt;code>cat smaps| grep ^Size | awk '{print $2}' | awk '{sum += $1};END {print sum}' &amp;amp;&amp;amp; cat status | grep VmSize&lt;/code> 命令，可以看到 smaps 文件中的 Size 与 status 文件中的 VmSize 是相同的&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>Rss&lt;/strong> #&lt;/li>
&lt;li>&lt;strong>Pss&lt;/strong> #&lt;/li>
&lt;li>&amp;hellip;&amp;hellip;&lt;/li>
&lt;/ul>
&lt;h2 id="smaps_rollup---汇总-smaps-文件中每个映射的内存信息为一条结果">./smaps_rollup - 汇总 smaps 文件中每个映射的内存信息为一条结果&lt;/h2>
&lt;p>smaps_rollup 文件中的内容，是将 smaps 文件中每个映射的内存信息汇总之后的结果&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">[&lt;/span>root@hw-cloud-xngy-jump-server-linux-2 /proc/1185&lt;span style="color:#f92672">]&lt;/span>&lt;span style="color:#75715e"># cat smaps_rollup&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>00400000-7ffc50bfa000 ---p &lt;span style="color:#ae81ff">00000000&lt;/span> 00:00 &lt;span style="color:#ae81ff">0&lt;/span> &lt;span style="color:#f92672">[&lt;/span>rollup&lt;span style="color:#f92672">]&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Rss: &lt;span style="color:#ae81ff">21952&lt;/span> kB
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Pss: &lt;span style="color:#ae81ff">21948&lt;/span> kB
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Pss_Anon: &lt;span style="color:#ae81ff">10372&lt;/span> kB
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Pss_File: &lt;span style="color:#ae81ff">11576&lt;/span> kB
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Pss_Shmem: &lt;span style="color:#ae81ff">0&lt;/span> kB
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Shared_Clean: &lt;span style="color:#ae81ff">4&lt;/span> kB
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Shared_Dirty: &lt;span style="color:#ae81ff">0&lt;/span> kB
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Private_Clean: &lt;span style="color:#ae81ff">11576&lt;/span> kB
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Private_Dirty: &lt;span style="color:#ae81ff">10372&lt;/span> kB
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Referenced: &lt;span style="color:#ae81ff">21952&lt;/span> kB
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Anonymous: &lt;span style="color:#ae81ff">10372&lt;/span> kB
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>LazyFree: &lt;span style="color:#ae81ff">0&lt;/span> kB
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>AnonHugePages: &lt;span style="color:#ae81ff">0&lt;/span> kB
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>ShmemPmdMapped: &lt;span style="color:#ae81ff">0&lt;/span> kB
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>FilePmdMapped: &lt;span style="color:#ae81ff">0&lt;/span> kB
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Shared_Hugetlb: &lt;span style="color:#ae81ff">0&lt;/span> kB
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Private_Hugetlb: &lt;span style="color:#ae81ff">0&lt;/span> kB
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Swap: &lt;span style="color:#ae81ff">0&lt;/span> kB
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>SwapPss: &lt;span style="color:#ae81ff">0&lt;/span> kB
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Locked: &lt;span style="color:#ae81ff">0&lt;/span> kB
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>通过 awk 计算 Rss 的大小，可以看到 smaps 文件中的聚合值与 smaps_rollup 的值一样&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">[&lt;/span>root@hw-cloud-xngy-jump-server-linux-2 /proc/1185&lt;span style="color:#f92672">]&lt;/span>&lt;span style="color:#75715e"># cat smaps| grep ^Rss | awk &amp;#39;{print $2}&amp;#39; | awk &amp;#39;{sum += $1};END {print sum}&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">21304&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">[&lt;/span>root@hw-cloud-xngy-jump-server-linux-2 /proc/1185&lt;span style="color:#f92672">]&lt;/span>&lt;span style="color:#75715e"># cat smaps_rollup&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>00400000-7ffc50bfa000 ---p &lt;span style="color:#ae81ff">00000000&lt;/span> 00:00 &lt;span style="color:#ae81ff">0&lt;/span> &lt;span style="color:#f92672">[&lt;/span>rollup&lt;span style="color:#f92672">]&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Rss: &lt;span style="color:#ae81ff">21304&lt;/span> kB
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="statm---进程的内存使用情况信息">./statm - 进程的内存使用情况信息&lt;/h2>
&lt;p>该文件中只有一行，每列信息以空格分割，共 7 列&lt;/p>
&lt;ul>
&lt;li>size # 进程使用的内存。等同于 status 文件中的 VmSize，man 手册里这个描述与实际不符&lt;/li>
&lt;li>resident # 进程的 RSS。等同于 status 文件中的 VmRSS，man 手册里这个描述与实际不符&lt;/li>
&lt;li>shared # 与其他进程共享的内存。等同于 status 文件中的 RssFile + RssShmem，man 手册里这个描述与实际不符&lt;/li>
&lt;/ul>
&lt;p>由于内核内部可伸缩性优化，文件中的一些值并不准确，如果需要准确的值，可以查看 smaps 和 smaps_rollup 文件。&lt;/p>
&lt;h2 id="status---该进程的状态信息">./status - 该进程的状态信息&lt;/h2>
&lt;p>包括但不限于 PID、该进程 CPU 与 Memory 的使用情况、等等。在这个文件中，包含了 ./stat 和 ./statm 文件中的许多信息。&lt;/p>
&lt;ul>
&lt;li>Name # 进程名称&lt;/li>
&lt;li>State # 进程状态&lt;/li>
&lt;li>VmSize # 进程申请的总内存。与 statm 文件中第一个字段的值相同&lt;/li>
&lt;li>VmRSS # 也就是进程当前时刻占用的物理内存。与 statm 文件中第二个字段的值相同&lt;/li>
&lt;/ul>
&lt;h2 id="tasktid---进程的线程信息目录">./task/TID/ - 进程的线程信息目录&lt;/h2>
&lt;p>该目录中是进程的每个线程的信息，目录名称(TID)为线程 ID&lt;/p>
&lt;h1 id="proccmdline---引导系统时传递给内核的参数">/proc/cmdline - 引导系统时，传递给内核的参数&lt;/h1>
&lt;p>通常通过引导管理器（如 lilo（8）或 grub（8））完成。&lt;/p>
&lt;h1 id="proccpuinfo---cpu-信息">/proc/cpuinfo - CPU 信息&lt;/h1>
&lt;p>如 cpu 的类型、制造商、 型号和性能等。&lt;/p>
&lt;h1 id="procdevices---当前运行的核心配置的设备驱动的列表">/proc/devices - 当前运行的核心配置的设备驱动的列表&lt;/h1>
&lt;h1 id="procdma---显示当前使用的-dma-通道">/proc/dma - 显示当前使用的 dma 通道&lt;/h1>
&lt;h1 id="procfilesystems---内核可用的文件系统信息">/proc/filesystems - 内核可用的文件系统信息&lt;/h1>
&lt;h1 id="procinterrupts---系统中断统计信息">/proc/interrupts - 系统中断统计信息&lt;/h1>
&lt;p>详见：&lt;a href="docs/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2.Kernel/4.CPU/Interrupts(%E4%B8%AD%E6%96%AD)/Interrupts(%E4%B8%AD%E6%96%AD).md">Interrupts(中断)&lt;/a>&lt;/p>
&lt;p>这用于记录每个 IO 设备每个 CPU 的中断数。从 Linux 2.6.24 开始，至少对于 i386 和 x86-64 体系结构，这还包括系统内部的中断（即与设备本身不相关的中断），例如 NMI（不可屏蔽中断），LOC（本地）。计时器中断），而对于 SMP 系统，则是 TLB（TLB 刷新中断），RES（重新安排中断），CAL（远程功能调用中断）等。格式非常容易读取，以 ASCII 格式完成。&lt;/p>
&lt;h1 id="procioports---当前使用的-io-端口">/proc/ioports - 当前使用的 i/o 端口&lt;/h1>
&lt;h1 id="prockcore---系统物理内存映像">/proc/kcore - 系统物理内存映像&lt;/h1>
&lt;p>与物理内存大小完全一样，然而实际上没有 占用这么多内存；它仅仅是在程序访问它时才被创建。(注意：除非你把它拷贝到什么地方，否则/proc 下没有任何东西占用任何磁盘空间。)&lt;/p>
&lt;h1 id="prockmsg---内核输出的信息">/proc/kmsg - 内核输出的信息&lt;/h1>
&lt;p>这些信息也会被送到 syslog。dmesg 命令获取该文件中的内容并展示&lt;/p>
&lt;h1 id="procloadavg---系统-load-average-信息">/proc/loadavg - 系统 load average 信息&lt;/h1>
&lt;h1 id="procmeminfo---系统上内存使用情况的统计信息">/proc/meminfo - 系统上内存使用情况的统计信息&lt;/h1>
&lt;p>详见：《&lt;a href="https://desistdaydream.github.io/docs/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/X.Linux%20%E7%AE%A1%E7%90%86/Linux%20%E7%B3%BB%E7%BB%9F%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/Memory%20%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7.md">Memory 管理工具&lt;/a>》 章节&lt;/p>
&lt;h1 id="procmodules">/proc/modules&lt;/h1>
&lt;p>存放当前加载了哪些核心模块信息。&lt;/p>
&lt;h1 id="procnet---网络层的信息">/proc/net/ - 网络层的信息&lt;/h1>
&lt;p>&lt;strong>软连接文件，被连接到 self/net 目录。主要是链接到的进程的 network namespace 的信息&lt;/strong>&lt;/p>
&lt;p>&lt;strong>./nf_conntrack&lt;/strong> # 链接跟踪表，该文件用于记录已跟踪的连接&lt;/p>
&lt;h2 id="进程间通信所用-socket-信息">进程间通信所用 Socket 信息&lt;/h2>
&lt;p>&lt;strong>./tcp&lt;/strong> # 所有的 TCP 连接信息。&lt;/p>
&lt;p>&lt;strong>./tcp6&lt;/strong> # 所有的基于 IPv6 的 TCP 连接信息。&lt;/p>
&lt;p>参考：&lt;a href="https://github.com/torvalds/linux/blob/master/Documentation/networking/proc_net_tcp.rst">GitHub Linux 项目文档&lt;/a>&lt;/p>
&lt;p>保存 TCP 套接字表的转储。除了调试之外，大部分信息都没有什么用。&lt;/p>
&lt;ul>
&lt;li>sl # 值是套接字的内核哈希槽位&lt;/li>
&lt;li>local_address # 是本地地址和端口号对&lt;/li>
&lt;li>rem_address # 是远程地址和端口号对(如果连接)&lt;/li>
&lt;li>St # 是套接字的内部状态。根据内核内存使用情况，&lt;/li>
&lt;li>tx_queue 和 rx_queue # 是传出和传入的数据队列。&lt;/li>
&lt;li>tr、tm-&amp;gt;when 和 rexmits # 字段保存内核套接字状态的内部信息，仅在调试时有用。&lt;/li>
&lt;li>uid # 字段保存套接字创建者的有效 uid。&lt;/li>
&lt;li>inode # 该 socket 的 inode 号，后面一串 16 进制的字符是该 socket 在内存中的地址。&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>root@lichenhao:~# cat /proc/net/tcp
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> sl local_address rem_address st tx_queue rx_queue tr tm-&amp;gt;when retrnsmt uid timeout inode
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> 0: 0100007F:177A 00000000:0000 0A 00000000:00000000 00:00000000 &lt;span style="color:#ae81ff">00000000&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span> &lt;span style="color:#ae81ff">12975942&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span> ffff923dd621a300 &lt;span style="color:#ae81ff">100&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span> &lt;span style="color:#ae81ff">10&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> 1: 3500007F:0035 00000000:0000 0A 00000000:00000000 00:00000000 &lt;span style="color:#ae81ff">00000000&lt;/span> &lt;span style="color:#ae81ff">101&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span> &lt;span style="color:#ae81ff">28017&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span> ffff923ef9dd08c0 &lt;span style="color:#ae81ff">100&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span> &lt;span style="color:#ae81ff">10&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> 2: 00000000:0016 00000000:0000 0A 00000000:00000000 00:00000000 &lt;span style="color:#ae81ff">00000000&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span> &lt;span style="color:#ae81ff">33221&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span> ffff923eecf6c600 &lt;span style="color:#ae81ff">100&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span> &lt;span style="color:#ae81ff">10&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> 3: F82A13AC:0016 CB2A13AC:FD4C &lt;span style="color:#ae81ff">01&lt;/span> 00000000:00000000 02:00025EB2 &lt;span style="color:#ae81ff">00000000&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span> &lt;span style="color:#ae81ff">12973284&lt;/span> &lt;span style="color:#ae81ff">4&lt;/span> ffff923dd621e900 &lt;span style="color:#ae81ff">20&lt;/span> &lt;span style="color:#ae81ff">4&lt;/span> &lt;span style="color:#ae81ff">29&lt;/span> &lt;span style="color:#ae81ff">10&lt;/span> &lt;span style="color:#ae81ff">20&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> 4: F82A13AC:0016 CB2A13AC:FD48 &lt;span style="color:#ae81ff">01&lt;/span> 00000000:00000000 02:000A6D4A &lt;span style="color:#ae81ff">00000000&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span> &lt;span style="color:#ae81ff">12944563&lt;/span> &lt;span style="color:#ae81ff">2&lt;/span> ffff923dd621bd40 &lt;span style="color:#ae81ff">20&lt;/span> &lt;span style="color:#ae81ff">4&lt;/span> &lt;span style="color:#ae81ff">31&lt;/span> &lt;span style="color:#ae81ff">10&lt;/span> &lt;span style="color:#ae81ff">23&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>注意：&lt;/p>
&lt;p>这里用 16 进制表示的 IP 有点奇葩比如 &lt;code>F82A13AC&lt;/code> 转换成 IP 地址是 &lt;code>248.42.19.172&lt;/code>，真实 IP 地址是 &lt;code>172.19.42.248&lt;/code>，也就是说反过来了。。。。&lt;code>F82A13AC&lt;/code> 应该是 &lt;code>AC132AF8&lt;/code>&lt;/p>
&lt;p>&lt;strong>./udp&lt;/strong> # 所有 UDP 连接信息&lt;/p>
&lt;p>&lt;strong>./udp6&lt;/strong> # 所有基于 IPv6 的 UDP 连接信息&lt;/p>
&lt;p>&lt;strong>./unix&lt;/strong> # 所有 Unix Domain Socket 连接信息&lt;/p>
&lt;h1 id="procsoftirqs---软中断统计信息">/proc/softirqs - &lt;strong>软中断统计信息&lt;/strong>&lt;/h1>
&lt;h1 id="procself">/proc/self&lt;/h1>
&lt;p>&lt;strong>当某一进程访问此软连接时，该软连接将指向该进程自己的 /proc/PID/ 目录。&lt;/strong>&lt;/p>
&lt;h1 id="procsys">/proc/sys/&lt;/h1>
&lt;p>&lt;strong>sys 目录是可写的，可以通过它来访问或修改内核的参数。详见 &lt;a href="https://desistdaydream.github.io/docs/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2.Kernel/1.Linux%20Kernel/Kernel%20%E5%8F%82%E6%95%B0/Kernel%20%E5%8F%82%E6%95%B0.md">Kernel 参数&lt;/a> 文章&lt;/strong>&lt;/p>
&lt;h1 id="procstat">/proc/stat&lt;/h1>
&lt;p>&lt;strong>系统的不同状态，例如，系统启动后页面发生错误的次数。&lt;/strong>&lt;/p>
&lt;p>该文件包含系统启动以来的很多系统和内核的统计信息，平时大家比较关心的比如包括 CPU 运行情况、中断情况、启动时间、上线文切换次数、运行中的进程等信息都在其中。&lt;/p>
&lt;p>一、文件全貌&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># Linux下查看/proc/stat的具体信息如下&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">[&lt;/span>root@WSC-31-2 ~&lt;span style="color:#f92672">]&lt;/span>&lt;span style="color:#75715e"># cat /proc/stat&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>cpu &lt;span style="color:#ae81ff">60382&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span> &lt;span style="color:#ae81ff">80032&lt;/span> &lt;span style="color:#ae81ff">198934063&lt;/span> &lt;span style="color:#ae81ff">2349&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span> &lt;span style="color:#ae81ff">109&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>cpu0 &lt;span style="color:#ae81ff">2405&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span> &lt;span style="color:#ae81ff">2084&lt;/span> &lt;span style="color:#ae81ff">4140924&lt;/span> &lt;span style="color:#ae81ff">682&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span> &lt;span style="color:#ae81ff">6&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>... &lt;span style="color:#75715e"># 此处较多冗余信息，简化之&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>cpu47 &lt;span style="color:#ae81ff">200&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span> &lt;span style="color:#ae81ff">134&lt;/span> &lt;span style="color:#ae81ff">4147222&lt;/span> &lt;span style="color:#ae81ff">10&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>intr &lt;span style="color:#ae81ff">33622492&lt;/span> &lt;span style="color:#ae81ff">64&lt;/span> ... &lt;span style="color:#ae81ff">0&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span> &lt;span style="color:#75715e"># 此处较多冗余信息，简化之&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>ctxt &lt;span style="color:#ae81ff">68533835&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>btime &lt;span style="color:#ae81ff">1528905555&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>processes &lt;span style="color:#ae81ff">318904&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>procs_running &lt;span style="color:#ae81ff">1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>procs_blocked &lt;span style="color:#ae81ff">0&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>softirq &lt;span style="color:#ae81ff">16567860&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span> &lt;span style="color:#ae81ff">3850777&lt;/span> &lt;span style="color:#ae81ff">8555&lt;/span> &lt;span style="color:#ae81ff">5448802&lt;/span> &lt;span style="color:#ae81ff">116727&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span> &lt;span style="color:#ae81ff">3577293&lt;/span> &lt;span style="color:#ae81ff">1290&lt;/span> &lt;span style="color:#ae81ff">3564415&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>这里将上述内容划分成几个模块进行分析&lt;/p>
&lt;p>二、字段含义分析&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>name user nice system idle iowait irrq softirq steal guest guest_nice
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>cpu &lt;span style="color:#ae81ff">60382&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span> &lt;span style="color:#ae81ff">80032&lt;/span> &lt;span style="color:#ae81ff">198934063&lt;/span> &lt;span style="color:#ae81ff">2349&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span> &lt;span style="color:#ae81ff">109&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>cpu0 &lt;span style="color:#ae81ff">2405&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span> &lt;span style="color:#ae81ff">2084&lt;/span> &lt;span style="color:#ae81ff">4140924&lt;/span> &lt;span style="color:#ae81ff">682&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span> &lt;span style="color:#ae81ff">6&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>... &lt;span style="color:#75715e"># 此处较多冗余信息，简化之&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>cpu47 &lt;span style="color:#ae81ff">200&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span> &lt;span style="color:#ae81ff">134&lt;/span> &lt;span style="color:#ae81ff">4147222&lt;/span> &lt;span style="color:#ae81ff">10&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;table>
&lt;thead>
&lt;tr>
&lt;th>&lt;/th>
&lt;th>&lt;/th>
&lt;th>&lt;/th>
&lt;th>&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>cpu 指标&lt;/td>
&lt;td>含义&lt;/td>
&lt;td>时间单位&lt;/td>
&lt;td>备注&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>user&lt;/td>
&lt;td>用户态时间&lt;/td>
&lt;td>jiffies&lt;/td>
&lt;td>一般/高优先级，仅统计 nice&amp;lt;=0&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>nice&lt;/td>
&lt;td>nice 用户态时间&lt;/td>
&lt;td>jiffies&lt;/td>
&lt;td>低优先级，仅统计 nice&amp;gt;0&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>system&lt;/td>
&lt;td>内核态时间&lt;/td>
&lt;td>jiffies&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>idle&lt;/td>
&lt;td>空闲时间&lt;/td>
&lt;td>jiffies&lt;/td>
&lt;td>不包含 IO 等待时间&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>iowait&lt;/td>
&lt;td>I/O 等待时间&lt;/td>
&lt;td>jiffies&lt;/td>
&lt;td>硬盘 IO 等待时间&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>irq&lt;/td>
&lt;td>硬中断时间&lt;/td>
&lt;td>jiffies&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>softirq&lt;/td>
&lt;td>软中断时间&lt;/td>
&lt;td>jiffies&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>steal&lt;/td>
&lt;td>被盗时间&lt;/td>
&lt;td>jiffies&lt;/td>
&lt;td>虚拟化环境中运行其他操作系统上花费的时间（since Linux 2.6.11）&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>guest&lt;/td>
&lt;td>来宾时间&lt;/td>
&lt;td>jiffies&lt;/td>
&lt;td>操作系统运行虚拟 CPU 花费的时间(since Linux 2.6.24)&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>guest_nice&lt;/td>
&lt;td>nice 来宾时间&lt;/td>
&lt;td>jiffies&lt;/td>
&lt;td>运行一个带 nice 值的 guest 花费的时间(since Linux 2.6.33)&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>说明：&lt;/p>
&lt;ol>
&lt;li>1 jiffies = 0.01s = 10ms。也就是 100 分之一秒。该数值除以 100 就得到以秒为单位的数值&lt;/li>
&lt;li>如果把单独一个 CPU 的所有字段的时间加起来，其实就是系统的运行时间。而第一行的 CPU 是指的所有 CPU 时间之和，这个时间会超过系统运行时间。&lt;/li>
&lt;li>常用计算等式：CPU 时间 = user + system + nice + idle + iowait + irq + softirq&lt;/li>
&lt;li>man 手册中 iowait 有单独说明，iowait 时间是不可靠值，具体原因如下：
&lt;ol>
&lt;li>CPU 不会等待 I/O 执行完成，而 iowait 是等待 I/O 完成的时间。当 CPU 进入 idle 状态，很可能会调度另一个 task 执行，所以 iowait 计算时间偏小；&lt;/li>
&lt;li>多核 CPU 中，iowait 的计算并非某一个核，因此计算每一个 cpu 的 iowait 非常困难&lt;/li>
&lt;li>这个值在某些情况下会减少&lt;/li>
&lt;/ol>
&lt;/li>
&lt;/ol>
&lt;h1 id="procuptime">/proc/uptime&lt;/h1>
&lt;p>&lt;strong>系统启动的时间长度&lt;/strong>&lt;/p>
&lt;p>该文件包含两个数字:&lt;/p>
&lt;ol>
&lt;li>系统的正常运行时间（秒）&lt;/li>
&lt;li>空闲进程所花费的时间（秒）&lt;/li>
&lt;/ol>
&lt;h1 id="procversion--内核版本信息">/proc/version # 内核&lt;strong>版本信息&lt;/strong>&lt;/h1>
&lt;h1 id="应用实例">应用实例&lt;/h1>
&lt;ol>
&lt;li>cat /proc/net/bonding/* # 在该目录查看网卡 bonding 信息&lt;/li>
&lt;li>cat /proc/cpuinfo # 查看 CPU 信息&lt;/li>
&lt;/ol>
&lt;h1 id="分类">分类&lt;/h1>
&lt;p>#文件系统&lt;/p></description></item><item><title>Docs: Sys File System</title><link>https://desistdaydream.github.io/docs/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2.Kernel/6.Filesystem/%E7%89%B9%E6%AE%8A%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/Sys-File-System/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2.Kernel/6.Filesystem/%E7%89%B9%E6%AE%8A%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/Sys-File-System/</guid><description>
&lt;h1 id="sys-file-system">Sys File System&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://man7.org/linux/man-pages/man5/sysfs.5.html">Manual(手册)，sysfs(5)&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.kernel.org/doc/html/latest/admin-guide/abi.html">Kernel 文档，用户与管理员指南-Linux ABI 描述&lt;/a>
&lt;ul>
&lt;li>&lt;a href="https://www.kernel.org/doc/html/latest/block/queue-sysfs.html">Linux Kernel 官方文档,Block-Queue sysfs files&lt;/a>（这个 404 了。。。o(╯□╰)o。。。官方目录结构改了。。）&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Sysfs">Wiki，Sysfs&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>用于导出内核对象的文件系统&lt;/p>
&lt;p>&lt;strong>Sys File System(sys 文件系统，简称 sysfs)&lt;/strong> 是一个 pseudo-filesystem(伪文件系统)，提供内核数据结构的接口(更准确地说，sysfs 中的文件和目录提供了内核内部定义的 kobject 结构的视图)。sysfs 下的文件提供关于设备、内核模块、文件系统和其他内核组件的信息。&lt;code>sysfs 一般挂载到 /sys 目录&lt;/code>。通常情况下，系统会自动挂载它，但也可以使用 &lt;code>mount -t sysfs sysfs /sys&lt;/code> 命令手动挂载&lt;/p>
&lt;p>sysfs 文件系统中的许多文件都是只读的，但是某些文件是可写的，从而允许更改内核变量。 为了避免冗余，符号链接被大量用于连接整个文件系统树中的条目。&lt;/p>
&lt;p>&lt;strong>其中 &lt;a href="#/sys/devices/">/sys/devices/&lt;/a> 目录是非常重要且关键的目录，/sys/ 下的其他目录中的内容，有很多都是指向 /sys/devices/ 目录中的软链接&lt;/strong>。&lt;/p>
&lt;h2 id="sysfs-背景">sysfs 背景&lt;/h2>
&lt;p>Sysfs 文件系统是一个类似于 proc 文件系统的特殊文件系统，用于将系统中的设备组织成层次结构，并向用户模式程序提供详细的内核数据结构信息。&lt;/p>
&lt;p>在 2.5 开发周期中，引入了 Linux 驱动程序模型来修复版本 2.4 的以下缺陷：&lt;/p>
&lt;ul>
&lt;li>不存在表示驱动程序与设备关系的统一方法。&lt;/li>
&lt;li>没有通用的热插拔机制。&lt;/li>
&lt;li>procfs 充斥着非过程信息。&lt;/li>
&lt;/ul>
&lt;p>Sysfs 的设计目的是导出设备树中存在的信息，从而不再使过程变得混乱。它是由 Patrick Mochel 撰写的。Maneesh Soni 后来编写了 sysfs 后备存储修补程序，以减少大型系统上的内存使用量。&lt;/p>
&lt;p>在 2.5 开发的第二年，驱动程序模型和 driverfs（以前称为 ddfs）的基础结构功能开始被证明对其他子系统有用。开发了 kobjects 以提供中央对象管理机制，并且将 driverfs 重命名为 sysfs 以表示其子系统不可知论。&lt;/p>
&lt;p>参考：&lt;a href="https://unix.stackexchange.com/questions/4884/what-is-the-difference-between-procfs-and-sysfs">https://unix.stackexchange.com/questions/4884/what-is-the-difference-between-procfs-and-sysfs&lt;/a>&lt;/p>
&lt;p>从一开始（在 Unix 时代开始），程序就了解系统上正在运行的进程的方法是直接从内核内存中读取进程结构（打开 &lt;code>/dev/mem&lt;/code>，并直接解释原始数据）。这就是最初的 ps 命令的工作方式。随着时间的流逝，一些信息可以通过系统调用获得。&lt;/p>
&lt;p>但是，通过 /dev/mem 将系统数据直接公开给用户空间是一种不好的形式，并且每次您要导出一些新的过程数据时都不断地创建新的系统调用是令人讨厌的，因此创建了一种新的方法访问用户空间应用程序的结构化数据以查找有关流程属性的信息。这是 /proc 文件系统。使用 /proc，即使内核中的基础数据结构发生了变化，接口和结构（目录和文件）也可以保持不变。与以前的系统相比，它不那么脆弱，并且扩展性更好。&lt;/p>
&lt;p>/proc 文件系统最初旨在发布过程信息和一些关键系统属性，这些属性是“ ps”，“ top”，“ free”和其他一些系统实用程序所必需的。但是，由于易于使用（从内核和用户空间两个方面来看），它成为了整个系统信息的垃圾场。而且，它开始获取读/写文件，用于调整设置并控制内核或其各个子系统的操作。但是，实现控制接口的方法是临时的，并且 /proc 很快陷入混乱。&lt;/p>
&lt;p>sysfs（或 /sys 文件系统）旨在为这种混乱增加结构，并提供一种统一的方式来从内核向用户空间公开系统信息和控制点（可设置的系统和驱动程序属性）。现在，注册驱动程序时，内核中的驱动程序框架会根据驱动程序类型及其数据结构中的值自动在 /sys 下创建目录。这意味着特定类型的驱动程序都将具有通过 sysfs 公开的相同元素。&lt;/p>
&lt;p>/proc 中仍然可以访问许多旧版系统信息和控制点，但是所有新的总线和驱动程序都应通过 sysfs 公开其信息和控制点。&lt;/p>
&lt;h1 id="sysblock">/sys/block/&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://www.kernel.org/doc/html/latest/admin-guide/abi-stable.html#symbols-under-sys-block">Kernel 文档，Linux 内核用户与管理员指南-Linux ABI 描述-ABI 稳定 链接-/sys/block 链接&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.kernel.org/doc/html/latest/block/index.html">Kernel 文档，内核子系统文档-Block&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>该目录下的所有子目录代表着系统中当前被发现的所有块设备。按照功能来说放置在 /sys/class/ 下会更合适，但由于历史遗留因素而一直存在于 /sys/block，但从 linux2.6.22 内核开始这部分就已经标记为过去时，只有打开了 CONFIG_SYSFS_DEPRECATED 配置编译才会有 这个目录存在，并且其中的内容在从 linux2.6.26 版本开始已经正式移到了 /sys/class/block/，旧的接口 /sys/block/ 为了向后兼容而保留存在，但其中的内容已经变为了指向它们在 &lt;code>/sys/devices/&lt;/code> 中真实设备的&lt;strong>符号链接&lt;/strong>文件。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>~&lt;span style="color:#f92672">]&lt;/span>&lt;span style="color:#75715e"># ll /sys/block/&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>total &lt;span style="color:#ae81ff">0&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>drwxr-xr-x &lt;span style="color:#ae81ff">2&lt;/span> root root &lt;span style="color:#ae81ff">0&lt;/span> Apr &lt;span style="color:#ae81ff">1&lt;/span> 14:36 ./
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>dr-xr-xr-x &lt;span style="color:#ae81ff">13&lt;/span> root root &lt;span style="color:#ae81ff">0&lt;/span> Apr &lt;span style="color:#ae81ff">1&lt;/span> 14:36 ../
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>lrwxrwxrwx &lt;span style="color:#ae81ff">1&lt;/span> root root &lt;span style="color:#ae81ff">0&lt;/span> Apr &lt;span style="color:#ae81ff">1&lt;/span> 14:36 dm-0 -&amp;gt; ../devices/virtual/block/dm-0/
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>lrwxrwxrwx &lt;span style="color:#ae81ff">1&lt;/span> root root &lt;span style="color:#ae81ff">0&lt;/span> Apr &lt;span style="color:#ae81ff">1&lt;/span> 14:36 dm-1 -&amp;gt; ../devices/virtual/block/dm-1/
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>lrwxrwxrwx &lt;span style="color:#ae81ff">1&lt;/span> root root &lt;span style="color:#ae81ff">0&lt;/span> Apr &lt;span style="color:#ae81ff">1&lt;/span> 14:36 loop0 -&amp;gt; ../devices/virtual/block/loop0/
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>lrwxrwxrwx &lt;span style="color:#ae81ff">1&lt;/span> root root &lt;span style="color:#ae81ff">0&lt;/span> Apr &lt;span style="color:#ae81ff">1&lt;/span> 14:36 loop1 -&amp;gt; ../devices/virtual/block/loop1/
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>lrwxrwxrwx &lt;span style="color:#ae81ff">1&lt;/span> root root &lt;span style="color:#ae81ff">0&lt;/span> Apr &lt;span style="color:#ae81ff">1&lt;/span> 14:36 loop2 -&amp;gt; ../devices/virtual/block/loop2/
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>lrwxrwxrwx &lt;span style="color:#ae81ff">1&lt;/span> root root &lt;span style="color:#ae81ff">0&lt;/span> Apr &lt;span style="color:#ae81ff">1&lt;/span> 14:36 loop3 -&amp;gt; ../devices/virtual/block/loop3/
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>lrwxrwxrwx &lt;span style="color:#ae81ff">1&lt;/span> root root &lt;span style="color:#ae81ff">0&lt;/span> Apr &lt;span style="color:#ae81ff">1&lt;/span> 14:36 loop4 -&amp;gt; ../devices/virtual/block/loop4/
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>lrwxrwxrwx &lt;span style="color:#ae81ff">1&lt;/span> root root &lt;span style="color:#ae81ff">0&lt;/span> Apr &lt;span style="color:#ae81ff">1&lt;/span> 14:36 loop5 -&amp;gt; ../devices/virtual/block/loop5/
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>lrwxrwxrwx &lt;span style="color:#ae81ff">1&lt;/span> root root &lt;span style="color:#ae81ff">0&lt;/span> Apr &lt;span style="color:#ae81ff">1&lt;/span> 14:36 loop6 -&amp;gt; ../devices/virtual/block/loop6/
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>lrwxrwxrwx &lt;span style="color:#ae81ff">1&lt;/span> root root &lt;span style="color:#ae81ff">0&lt;/span> Apr &lt;span style="color:#ae81ff">1&lt;/span> 14:36 loop7 -&amp;gt; ../devices/virtual/block/loop7/
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>lrwxrwxrwx &lt;span style="color:#ae81ff">1&lt;/span> root root &lt;span style="color:#ae81ff">0&lt;/span> Apr &lt;span style="color:#ae81ff">1&lt;/span> 14:36 sr0 -&amp;gt; ../devices/pci0000:00/0000:00:01.1/ata1/host0/target0:0:0/0:0:0:0/block/sr0/
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>lrwxrwxrwx &lt;span style="color:#ae81ff">1&lt;/span> root root &lt;span style="color:#ae81ff">0&lt;/span> Apr &lt;span style="color:#ae81ff">1&lt;/span> 14:36 vda -&amp;gt; ../devices/pci0000:00/0000:00:07.0/virtio2/block/vda/
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;strong>/sys/block/&amp;lt;BLOCK&amp;gt;/queue/&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>&lt;strong>./rotational&lt;/strong> # 块设备旋转的类型，旋转就是 HHD，不旋转就是 SSD，非常形象生动得比喻磁盘使用的情况~哈哈。&lt;code>0 表示 SSD&lt;/code>，&lt;code>1 表示 HDD&lt;/code>
&lt;ul>
&lt;li>注意：如果磁盘已经被做了 Raid，那么这个值将会一直都是 1。这个说法忘记了出处，找到后补充。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h1 id="sysbus">/sys/bus/&lt;/h1>
&lt;p>该目录下的每个子目录都是 kernel 支持并且已经注册了的总线类型。这是内核设备按照总线类型分层放置的目录结构，/sys/devices/ 中的所有设备都是连接于某种总线之下的，bus 子目录下的每种具体总线之下可以找到每个具体设备的符号链接，一般来说每个子目录(总线类型)下包含两个子目录，一个是 devices，另一个是 drivers；其中 devices 下是这个总线类型下的所有设备，这些设备&lt;strong>都是符号链接，它们分别指向真正的设备(/sys/devices/)&lt;/strong>；而 drivers 下是所有注册在这个总线上的驱动，每个 driver 子目录下 是一些可以观察和修改的 driver 参数。&lt;/p>
&lt;p>~]# ls /sys/bus/
i2c mdio_bus platform sdio usb
iio mmc scsi spi&lt;/p>
&lt;p>应用 1：msp700 中计算电池电压
PipeADC5 = popen(&amp;ldquo;cat &lt;strong>/sys/bus/iio/devices/iio\:device0/in_voltage5_raw&lt;/strong>&amp;rdquo;, &amp;ldquo;r&amp;rdquo;);&lt;/p>
&lt;p>应用 2：改变提醒等级
echo 6 &amp;gt; /proc/sys/kernel/printk；&lt;/p>
&lt;p>应用 3：msp700 中设置背光
echo 20 &amp;gt; &lt;strong>/sys/class/backlight/pwm-backlight/brightness&lt;/strong>;&lt;/p>
&lt;p>等价于：
echo 20 &amp;gt; /sys/bus/platform/devices/pwm-backlight/backlight/pwm-backlight/brightness;&lt;/p>
&lt;h1 id="sysclass">/sys/class/&lt;/h1>
&lt;p>该目录下包含所有注册在 kernel 里面的设备类型，这是按照设备功能分类的设备模型，每个设备类型表达具有一种功能的设备。每个设备类型子目录下都是这种设备类型的各种具体设备的&lt;strong>符号链接，这些链接指向 /sys/devices/ 下的具体设备&lt;/strong>。 设备类型和设备并没有一一对应的关系，一个物理设备可能具备多种设备类型；一个设备类型只表达具有一种功能的设备，比如：系统所有输入设备都会出现在 /sys/class/input 之下，而不论它们是以何种总线连接到系统的。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>~&lt;span style="color:#f92672">]&lt;/span>&lt;span style="color:#75715e"># ls /sys/class/&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>ata_device dma i2c-dev pci_epc rfkill tpmrm
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>ata_link dmi input phy rtc tty
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>ata_port drm iommu powercap scsi_device vc
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>backlight drm_dp_aux_dev leds power_supply scsi_disk vfio
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>bdi extcon mdio_bus ppp scsi_generic virtio-ports
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>block firmware mem pps scsi_host vtconsole
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>bsg gpio misc ptp sound wakeup
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>dax graphics mmc_host pwm spi_master watchdog
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>devcoredump hidraw nd rapidio_port spi_slave
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>devfreq hwmon net regulator thermal
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>devfreq-event i2c-adapter pci_bus remoteproc tpm
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># 从 /sys/class/net 可以看到，所有网络设备信息，其中包括网络设备的各种状态，比如传输的总字节数等等。&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>~&lt;span style="color:#f92672">]&lt;/span>&lt;span style="color:#75715e"># ll /sys/class/net&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>总用量 &lt;span style="color:#ae81ff">0&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>drwxr-xr-x &lt;span style="color:#ae81ff">2&lt;/span> root root &lt;span style="color:#ae81ff">0&lt;/span> 9月 &lt;span style="color:#ae81ff">1&lt;/span> 10:35 ./
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>drwxr-xr-x &lt;span style="color:#ae81ff">73&lt;/span> root root &lt;span style="color:#ae81ff">0&lt;/span> 9月 &lt;span style="color:#ae81ff">1&lt;/span> 10:35 ../
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>lrwxrwxrwx &lt;span style="color:#ae81ff">1&lt;/span> root root &lt;span style="color:#ae81ff">0&lt;/span> 9月 &lt;span style="color:#ae81ff">1&lt;/span> 10:35 ens3 -&amp;gt; ../../devices/pci0000:00/0000:00:03.0/virtio0/net/ens3/
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>lrwxrwxrwx &lt;span style="color:#ae81ff">1&lt;/span> root root &lt;span style="color:#ae81ff">0&lt;/span> 9月 &lt;span style="color:#ae81ff">1&lt;/span> 10:35 lo -&amp;gt; ../../devices/virtual/net/lo/
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>lrwxrwxrwx &lt;span style="color:#ae81ff">1&lt;/span> root root &lt;span style="color:#ae81ff">0&lt;/span> 9月 &lt;span style="color:#ae81ff">1&lt;/span> 10:50 wg0 -&amp;gt; ../../devices/virtual/net/wg0/
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;strong>/sys/class/block/DEVICE/&lt;/strong> # 块设备信息，DEVICE 都块设备的名称，用来顶替 &lt;a href="#/sys/block">/sys/block/&lt;/a> 目录，软链接到 &lt;strong>/sys/device/&lt;/strong> 中的某个目录。&lt;/p>
&lt;h1 id="sysdev">/sys/dev/&lt;/h1>
&lt;p>该目录下存放主次设备号文件，其中分成字符设备、块设备的主次设备号码(major:minor)组成的文件名，该文件是链接文件并且链接到其真实的设备(/sys/devices)。&lt;/p>
&lt;h1 id="sysdevices">/sys/devices/&lt;/h1>
&lt;p>该目录下是&lt;strong>全局设备结构体系&lt;/strong>，包含所有被发现的注册在各种总线上的各种物理设备。&lt;strong>/sys/ 目录中，只要有关于设备信息的目录，都会是指向 /sys/devices/ 目录中的软链接&lt;/strong>。由于 /sys/devices/ 目录结构对设备的分类是按照总线拓扑结构分的，那么对于设备类型来说，就缺乏分类了，所以至今还保留了 /sys/block/ 之类的目录，将设备以类型进行区分。这些区分设备类型的目录下存放的，实际上是指向 /sys/devices/ 目录的&lt;strong>软连接&lt;/strong>。&lt;/p>
&lt;p>就用下面的 /sys/block/ 目录举例的话，其中的软连接分别会指向 /sys/devices/ 下的不用目录，这就更加说明了 /sys/devices/ 目录对设备的划分并不是按照类型来的。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">]&lt;/span>&lt;span style="color:#75715e"># ll /sys/block/&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>total &lt;span style="color:#ae81ff">0&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>drwxr-xr-x &lt;span style="color:#ae81ff">2&lt;/span> root root &lt;span style="color:#ae81ff">0&lt;/span> Mar &lt;span style="color:#ae81ff">6&lt;/span> 19:01 ./
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>dr-xr-xr-x &lt;span style="color:#ae81ff">13&lt;/span> root root &lt;span style="color:#ae81ff">0&lt;/span> Aug &lt;span style="color:#ae81ff">31&lt;/span> &lt;span style="color:#ae81ff">2022&lt;/span> ../
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>lrwxrwxrwx &lt;span style="color:#ae81ff">1&lt;/span> root root &lt;span style="color:#ae81ff">0&lt;/span> Mar &lt;span style="color:#ae81ff">6&lt;/span> 19:01 dm-0 -&amp;gt; ../devices/virtual/block/dm-0/
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>lrwxrwxrwx &lt;span style="color:#ae81ff">1&lt;/span> root root &lt;span style="color:#ae81ff">0&lt;/span> Mar &lt;span style="color:#ae81ff">6&lt;/span> 23:10 loop0 -&amp;gt; ../devices/virtual/block/loop0/
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>lrwxrwxrwx &lt;span style="color:#ae81ff">1&lt;/span> root root &lt;span style="color:#ae81ff">0&lt;/span> Mar &lt;span style="color:#ae81ff">6&lt;/span> 23:10 loop1 -&amp;gt; ../devices/virtual/block/loop1/
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>lrwxrwxrwx &lt;span style="color:#ae81ff">1&lt;/span> root root &lt;span style="color:#ae81ff">0&lt;/span> Mar &lt;span style="color:#ae81ff">6&lt;/span> 23:10 loop2 -&amp;gt; ../devices/virtual/block/loop2/
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>lrwxrwxrwx &lt;span style="color:#ae81ff">1&lt;/span> root root &lt;span style="color:#ae81ff">0&lt;/span> Mar &lt;span style="color:#ae81ff">6&lt;/span> 23:10 loop3 -&amp;gt; ../devices/virtual/block/loop3/
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>lrwxrwxrwx &lt;span style="color:#ae81ff">1&lt;/span> root root &lt;span style="color:#ae81ff">0&lt;/span> Mar &lt;span style="color:#ae81ff">6&lt;/span> 23:10 loop4 -&amp;gt; ../devices/virtual/block/loop4/
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>lrwxrwxrwx &lt;span style="color:#ae81ff">1&lt;/span> root root &lt;span style="color:#ae81ff">0&lt;/span> Mar &lt;span style="color:#ae81ff">6&lt;/span> 23:10 loop5 -&amp;gt; ../devices/virtual/block/loop5/
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>lrwxrwxrwx &lt;span style="color:#ae81ff">1&lt;/span> root root &lt;span style="color:#ae81ff">0&lt;/span> Mar &lt;span style="color:#ae81ff">6&lt;/span> 23:10 loop6 -&amp;gt; ../devices/virtual/block/loop6/
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>lrwxrwxrwx &lt;span style="color:#ae81ff">1&lt;/span> root root &lt;span style="color:#ae81ff">0&lt;/span> Mar &lt;span style="color:#ae81ff">6&lt;/span> 23:10 loop7 -&amp;gt; ../devices/virtual/block/loop7/
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>lrwxrwxrwx &lt;span style="color:#ae81ff">1&lt;/span> root root &lt;span style="color:#ae81ff">0&lt;/span> Mar &lt;span style="color:#ae81ff">6&lt;/span> 19:01 vda -&amp;gt; ../devices/pci0000:00/0000:00:05.0/0000:02:01.0/virtio3/block/vda/
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>lrwxrwxrwx &lt;span style="color:#ae81ff">1&lt;/span> root root &lt;span style="color:#ae81ff">0&lt;/span> Mar &lt;span style="color:#ae81ff">6&lt;/span> 19:01 vdb -&amp;gt; ../devices/pci0000:00/0000:00:05.0/0000:02:02.0/virtio4/block/vdb/
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>一般来说，所有的物理设备都按其在总线上的拓扑结构来显示，但有两个例外即 platform devices 和 system devices。&lt;/p>
&lt;ul>
&lt;li>platform devices 一般是挂在芯片内部的高速或者低速总线上的各种控制器和外设，它们能被 CPU 直接寻址；&lt;/li>
&lt;li>system devices 不是外设，而是芯片内部的核心结构，比如 CPU，timer 等，它们一般没有相关的驱动，但是会有一些体系结构相关的代码来配置它们。&lt;/li>
&lt;/ul>
&lt;p>/sys/devices/ 是内核对系统中所有设备的分层次表达模型，也是 &lt;strong>sysfs 管理设备的最重要的目录结构&lt;/strong>。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>~&lt;span style="color:#f92672">]&lt;/span>&lt;span style="color:#75715e"># ls /sys/devices/&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>breakpoint kprobe msr platform software tracepoint virtual
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>isa LNXSYSTM:00 pci0000:00 pnp0 system uprobe
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>~&lt;span style="color:#f92672">]&lt;/span>&lt;span style="color:#75715e"># ls /sys/devices/platform/&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> eisa.0 intel_rapl_msr.0 power uevent
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">&amp;#39;Fixed MDIO bus.0&amp;#39;&lt;/span> kgdboc reg-dummy vesa-framebuffer.0
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> i8042 pcspkr serial8250
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>~&lt;span style="color:#f92672">]&lt;/span>&lt;span style="color:#75715e"># ls /sys/devices/system/&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>clockevents clocksource container cpu edac machinecheck memory node
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h1 id="sysfirmware">/sys/firmware/&lt;/h1>
&lt;p>这里是系统加载固件机制的对用户空间的接口，关于固件有专用于固件加载的一套 API，在附录 LDD3 一书中有关于内核支持固件加载机制的更详细的介绍；&lt;/p>
&lt;h1 id="sysfs">/sys/fs/&lt;/h1>
&lt;p>此目录包含某些文件系统的子目录。仅当文件系统选择显式创建子目录时，才会在此处具有子目录。&lt;/p>
&lt;h1 id="syskernel">/sys/kernel/&lt;/h1>
&lt;p>root@RPM /sys$ ls kernel/&lt;/p>
&lt;p>debug mm profiling uevent_seqnum&lt;/p>
&lt;p>fscaps notes uevent_helper&lt;/p>
&lt;p>这个目录下存放的是内核中所有可调整的参数。&lt;/p>
&lt;h1 id="sysmodule">/sys/module/&lt;/h1>
&lt;p>该目录下有系统中所有的模块信息，不论这些模块是以内联(inlined)方式编译到内核映像文件中还是编译为外模块(.ko 文件)，都可能出现在/sys/module 中。即 module 目录下包含了所有的被载入 kernel 的模块。&lt;/p>
&lt;p>root@RPM /sys$ ls module/&lt;/p>
&lt;p>auth_rpcgss lockd rfkill tea5761&lt;/p>
&lt;p>block loop scsi_mod tea5767&lt;/p>
&lt;p>can mailbox snd tuner_simple&lt;/p>
&lt;p>cpuidle mmc_core snd_pcm tuner_xc2028&lt;/p>
&lt;p>cryptodev mmcblk snd_pcm_oss ubi&lt;/p>
&lt;p>cryptosoft mousedev snd_timer ubifs&lt;/p>
&lt;p>d_can mt20xx soundcore usb_storage&lt;/p>
&lt;p>d_can_platform mtdoops spurious usbcore&lt;/p>
&lt;p>dns_resolver nf_conntrack sunrpc vt&lt;/p>
&lt;p>g_mass_storage nf_conntrack_ipv4 tcp_cubic xc4000&lt;/p>
&lt;p>hostap nfs tda18271 xc5000&lt;/p>
&lt;p>input_polldev ocf tda827x xz_dec&lt;/p>
&lt;p>kernel oprofile tda8290&lt;/p>
&lt;p>keyboard printk tda9887&lt;/p>
&lt;h1 id="syspower">/sys/power/&lt;/h1>
&lt;p>该目录是系统中的电源选项，对正在使用的 power 子系统的描述。这个目录下有几个属性文件可以用于控制整个机器的电源状态，如可以向其中写入控制命令让机器关机/重启等等。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>root@RPM /sys$ ls power/
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>pm_async pm_test state wakeup_count
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h1 id="分类">分类&lt;/h1>
&lt;p>#文件系统&lt;/p></description></item></channel></rss>