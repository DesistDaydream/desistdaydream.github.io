<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>断念梦 – Shell 编程语言</title><link>https://desistdaydream.github.io/docs/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/4.Terminal-%E4%B8%8E-Shell/Shell-%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/</link><description>Recent content in Shell 编程语言 on 断念梦</description><generator>Hugo -- gohugo.io</generator><atom:link href="https://desistdaydream.github.io/docs/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/4.Terminal-%E4%B8%8E-Shell/Shell-%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/index.xml" rel="self" type="application/rss+xml"/><item><title>Docs: Shell 编程语言</title><link>https://desistdaydream.github.io/docs/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/4.Terminal-%E4%B8%8E-Shell/Shell-%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Shell-%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/4.Terminal-%E4%B8%8E-Shell/Shell-%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Shell-%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://wangdoc.com/bash/index.html">https://wangdoc.com/bash/index.html&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>&lt;strong>Shell Programming Language(shell 编程语言)&lt;/strong> 不是编译型的语言，而是一种脚本语言。&lt;/p>
&lt;h1 id="shell-的基本结构与要素">Shell 的基本结构与要素&lt;/h1>
&lt;p>shell 语言的运行环境依赖于其所使用的 shell，是 bash、sh 还是 zsh 等等。想要执行 shell 语言，并不需要下载一个编译器，直接在指定的 shell 中执行代码即可。&lt;/p>
&lt;p>脚本式的语言是编写完代码之后，一条一条执行，所以可以把平时在 Linux 上操作的 Bash Shell 想象成一个大型的文本编辑器，每输入一条命令，就相当于一行代码，直接通过这个 Bash 的 shell 就执行了，而把很多命令组合起来，放在一个文件里，直接运行该文件，与在界面输入很多内容，有异曲同工之妙。&lt;/p>
&lt;p>由于 Shell 语言不需要编译器，所以 Shell 代码的第一行，必须指定其内的代码使用什么 Shell 来运行。&lt;/p>
&lt;h2 id="hello-world">Hello World&lt;/h2>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#!/bin/bash # 告诉内该脚本用什么shell运行，必须是脚本第一行
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>printf &lt;span style="color:#e6db74">&amp;#39;Hello World!&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>其实如果是在某个系统下运行代码，第一行也是可以省略的，第一行的意思其实就是代表运行后续命令的环境，而第一行其实也是调用系统 /bin/ 目录下的 bash 二进制文件，来执行后续的代码。&lt;/p>
&lt;h2 id="shell-语言中的关键字">Shell 语言中的关键字&lt;/h2>
&lt;p>Shell 语言中的关键字，就是该 Shell 所在系统下的可用命令+该 Shell 自带的一些命令。比如 bash Shell 会自带 if&amp;hellip;else&amp;hellip;fi 这种控制结构的关键字(虽然没有不带的。。。我就是这么一说。。。)。所以在 Shell 的 代码中，大部分的关键字都是一个个的 Linux 命令。而那些非系统自带的命令(或者说工具)，可以理解为 Shell 编程语言的第三方库。&lt;/p>
&lt;h1 id="shell-中特殊符号的说明">Shell 中特殊符号的说明&lt;/h1>
&lt;p>这些特殊符号的作用，一般是在对 Linux 和 shell 有一定了解的基础上，才能明白其作用。&lt;/p>
&lt;h2 id="--和--单引号-和-双引号">&lt;code>' '&lt;/code> 和 &lt;code>&amp;quot; &amp;quot;&lt;/code>(单引号 和 双引号)&lt;/h2>
&lt;p>首先，单引号和双引号，都是为了解决中间有空格的问题。&lt;/p>
&lt;p>因为空格在 Shell 中时作为一个很典型的分隔符，比如 string1=this is astring，这样执行就会报错。为了避免这个问题，因此就产生了单引号和双引号。&lt;/p>
&lt;p>单引号引用的内容，所见即所得。即将单引号内的内容原样输出，或者描述为单引号里面看到的是什么就会输出什么。单引号是全引用，被单引号括起的内容不管是常量还是变量都不会发生替换。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">[&lt;/span>root@lichenhao ~&lt;span style="color:#f92672">]&lt;/span>&lt;span style="color:#75715e"># var=dablelv&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">[&lt;/span>root@lichenhao ~&lt;span style="color:#f92672">]&lt;/span>&lt;span style="color:#75715e"># echo &amp;#39;$var&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>$var
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>双引号引用的内容，所见非所得。如果内容中有命令、变量等，会先把变量、命令解析出结果，然后在输出最终内容。双引号是部分引用，被双引号括起的内容常量还是常量，变量则会发生替换，替换成变量内容。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">[&lt;/span>root@lichenhao ~&lt;span style="color:#f92672">]&lt;/span>&lt;span style="color:#75715e"># var=dablelv&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">[&lt;/span>root@lichenhao ~&lt;span style="color:#f92672">]&lt;/span>&lt;span style="color:#75715e"># echo &amp;#34;$var&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>dablelv
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>无引号不使用引号定义字符串时，字符串不能包含空白字符（如 Space 或 Tab），需要该加引号，一般连续的字符串，数字，路径等可以不加引号。如果内容中有命令、变量等，会先把变量、命令解析出结果，然后在输出最终内容。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">[&lt;/span>root@lichenhao ~&lt;span style="color:#f92672">]&lt;/span>&lt;span style="color:#75715e"># str3=test String&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>-bash: String: 未找到命令
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">[&lt;/span>root@lichenhao ~&lt;span style="color:#f92672">]&lt;/span>&lt;span style="color:#75715e"># echo $str3&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">[&lt;/span>root@lichenhao ~&lt;span style="color:#f92672">]&lt;/span>&lt;span style="color:#75715e">#&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>可见，字符串中包含有空格时不实用引号括起来，将无法正常输出。&lt;/p>
&lt;h2 id="-和--用于命令替换">&lt;code>$()&lt;/code> 和 `` 用于命令替换&lt;/h2>
&lt;p>在 bash shell 中，$( ) 与`` (反引号) 都是用来做命令替换用(command substitution)的。&lt;/p>
&lt;p>例如：version=$(uname -r) 和 version=&lt;code>uname -r&lt;/code> 都可以使 version 得到内核的版本号&lt;/p>
&lt;p>各自的优缺点：&lt;/p>
&lt;ol>
&lt;li>`` 基本上可用在全部的 unix shell 中使用，若写成 shell script ，其移植性比较高。但反单引号容易打错或看错。&lt;/li>
&lt;li>$( ) 并不是所有 shell 都支持。&lt;/li>
&lt;/ol>
&lt;h2 id="-和-">&lt;code>$[]&lt;/code> 和 &lt;code>$(())&lt;/code>&lt;/h2>
&lt;p>它们是一样的，都是进行数学运算的。支持+ - &lt;em>/ %：分别为 “加、减、乘、除、取模”。但是注意，bash 只能作整数运算，对于浮点数是当作字符串处理的。
c=2$ echo $(( a+b&lt;/em>c ))19$ echo $(( (a+b)/c ))6$ echo $(( (a*b)%c))1&lt;/p>
&lt;p>在 $(( )) 中的变量名称，可于其前面加 $ 符号来替换，也可以不用，如：&lt;/p>
&lt;p>$(( $a + $b * $c)) 也可得到 19 的结果&lt;/p>
&lt;p>此外，$(( )) 还可作不同进位(如二进制、八进位、十六进制)作运算呢，只是，输出结果皆为十进制而已：&lt;/p>
&lt;p>echo $((16#2a)) 结果为 42 (16 进位转十进制)&lt;/p>
&lt;h2 id="--test-命令的另一种形式">&lt;code>[ ]&lt;/code> &lt;code>test&lt;/code> 命令的另一种形式&lt;/h2>
&lt;p>注意：&lt;/p>
&lt;ul>
&lt;li>你必须在左括号的右侧和右括号的左侧各加一个空格，否则会报错。&lt;/li>
&lt;li>test 命令使用标准的数学比较符号来表示字符串的比较，而用文本符号来表示数值的比较。很多人会记反了。使用反了，shell 可能得不到正确的结果。&lt;/li>
&lt;li>大于符号或小于符号必须要转义，否则会被理解成重定向。
&lt;ul>
&lt;li>bash 的内部命令，[和 test 是等同的。如果我们不用绝对路径指明，通常我们用的都是 bash 自带的命令。if/test 结构中的左中括号是调用 test 的命令标识，右中括号是关闭条件判断的。这个命令把它的参数作为比较表达式或者作为文件测试，并且根据比较的结果来返回一个退出状态码。if/test 结构中并不是必须右中括号，但是新版的 Bash 中要求必须这样。&lt;/li>
&lt;li>Test 和[]中可用的比较运算符只有==和!=，两者都是用于字符串比较的，不可用于整数比较，整数比较只能使用-eq，-gt 这种形式。无论是字符串比较还是整数比较都不支持大于号小于号。如果实在想用，对于字符串比较可以使用转义形式，如果比较&amp;quot;ab&amp;quot;和&amp;quot;bc&amp;quot;：[ ab &amp;lt; bc ]，结果为真，也就是返回状态为 0。[ ]中的逻辑与和逻辑或使用-a 和-o 表示。&lt;/li>
&lt;li>字符范围。用作正则表达式的一部分，描述一个匹配的字符范围。作为 test 用途的中括号内不能使用正则。&lt;/li>
&lt;li>在一个 array 结构的上下文中，中括号用来引用数组中每个元素的编号。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h2 id="--和--">&lt;code>(( ))&lt;/code> 和 &lt;code>[[ ]]&lt;/code>&lt;/h2>
&lt;p>它们分别是[ ]的针对数学比较表达式和字符串表达式的加强版。&lt;/p>
&lt;p>注意：[[]]会把 0 开头的整型数字当成 8 进制数来处理，所以以 0 开头的整型数如果想要按照 10 进制处理需要使用[]来处理&lt;/p>
&lt;p>其中(( ))，不需要再将表达式里面的大小于符号转义，除了可以使用标准的数学运算符外，还增加了以下符号：&lt;/p>
&lt;p>①[[是 bash 程序语言的关键字。并不是一个命令，[[ ]] 结构比[ ]结构更加通用。在[[和]]之间所有的字符都不会发生文件名扩展或者单词分割，但是会发生参数扩展和命令替换。&lt;/p>
&lt;pre>&lt;code>②支持字符串的模式匹配，使用=~操作符时甚至支持shell的正则表达式。字符串比较时可以把右边的作为一个模式，而不仅仅是一个字符串，比如[[ hello == hell? ]]，结果为真。[[ ]] 中匹配字符串或通配符，不需要引号。
③使用[[ ... ]]条件判断结构，而不是[ ... ]，能够防止脚本中的许多逻辑错误。比如，&amp;amp;&amp;amp;、||、&amp;lt;和&amp;gt; 操作符能够正常存在于[[ ]]条件判断结构中，但是如果出现在[ ]结构中的话，会报错。比如可以直接使用if [[ $a != 1 &amp;amp;&amp;amp; $a != 2 ]], 如果不适用双括号, 则为if [ $a -ne 1] &amp;amp;&amp;amp; [ $a != 2 ]或者if [ $a -ne 1 -a $a != 2 ]。
④bash把双中括号中的表达式看作一个单独的元素，并返回一个退出状态码。
&lt;/code>&lt;/pre>
&lt;h1 id="脚本执行规则">脚本执行规则&lt;/h1>
&lt;ol>
&lt;li>顺序执行：默认原则，逐一执行写的每条语句&lt;/li>
&lt;li>选择执行：条件判断，符合条件的进行执行&lt;/li>
&lt;li>循环执行：将同一段代码反复执行，必须有结束条件，否则循环无法结束。&lt;/li>
&lt;/ol></description></item><item><title>Docs: set 命令</title><link>https://desistdaydream.github.io/docs/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/4.Terminal-%E4%B8%8E-Shell/Shell-%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/set-%E5%91%BD%E4%BB%A4/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/4.Terminal-%E4%B8%8E-Shell/Shell-%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/set-%E5%91%BD%E4%BB%A4/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://www.gnu.org/software/bash/manual/html_node/The-Set-Builtin.html">GNU 文档，Bash 参考手册-Shell 内置命令-修改 Shell 行为-Set 内置命令&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://morven.life/posts/how-to-write-robust-shell-script/">https://morven.life/posts/how-to-write-robust-shell-script/&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;h2 id="前言">前言&lt;/h2>
&lt;p>Shell 脚本会有各种坑，经常导致 Shell 脚本因为各种原因不能正常执行成功。实际上，编写健壮可靠的 Shell 脚本也是有一定的技巧的。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># 在执行Shell脚本的时候，通常都会创建一个新的Shell，比如，当我们执行：&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>bash script.sh
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Bash 会创建一个新的 Shell 来执行 script.sh，同时也默认给定了这个执行环境的各种参数。set 命令可以用来修改 Shell 环境的运行参数，不带任何参数的 set 命令，会显示所有的环境变量和 Shell 函数。我们重点介绍其中最常用的四个。&lt;/p>
&lt;p>set -euxo pipefail&lt;/p>
&lt;h2 id="set--x">set -x&lt;/h2>
&lt;p>默认情况下，Shell 脚本执行后只显示运行结果，不会展示结果是哪一行代码的输出，如果多个命令连续执行，它们的运行结果就会连续输出，导致很难分清一串结果是什么命令产生的。
set -x 用来在运行结果之前，先输出执行的那一行命令，行首以+表示是命令而非命令输出，同时，每个命令的参数也会展开，我们可以清晰地看到每个命令的运行实参，这对于 Shell 的 debug 来说非常友好。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#!/bin/bash
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>set -x
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>v&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">5&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>echo $v
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>echo &lt;span style="color:#e6db74">&amp;#34;hello&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># output:&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># + v=5&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># + echo 5&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># 5&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># + echo hello&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># hello&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>实际上，set -x 还有另一种写法 set -o xtrace。&lt;/p>
&lt;h2 id="set--u">set -u&lt;/h2>
&lt;p>Shell 脚本不像其他高级语言，如 Python, Ruby 等，Shell 脚本默认不提供安全机制，举个简单的例子，Ruby 脚本尝试去读取一个没有初始化的变量的内容的时候会报错，而 Shell 脚本默认不会有任何提示，只是简单地忽略。&lt;/p>
&lt;pre>&lt;code>#!/bin/bash
echo $v
echo &amp;quot;hello&amp;quot;
# output:
#
# hello
&lt;/code>&lt;/pre>
&lt;p>可以看到，echo $v 输出了一个空行，Bash完全忽略了不存在的$v 继续执行后面的命令 echo &amp;ldquo;hello&amp;rdquo;。这其实并不是开发者想要的行为，对于不存在的变量，脚本应该报错且停止执行来防止错误的叠加。set -u 就用来改变这种默认忽略未定义变量行为，脚本在头部加上它，遇到不存在的变量就会报错，并停止执行。&lt;/p>
&lt;pre>&lt;code>#!/bin/bash
set -u
echo $a
echo bar
# output:
# ./script.sh: line 4: v: unbound variable
&lt;/code>&lt;/pre>
&lt;p>set -u 另一种写法是 set -o nounset&lt;/p>
&lt;h2 id="set--e">set -e&lt;/h2>
&lt;p>对于默认的 Shell 脚本运行环境，有运行失败的命令（返回值非 0），Bash 会继续执行后面的命令：&lt;/p>
&lt;pre>&lt;code>#!/bin/bash
unknowncmd
echo &amp;quot;hello&amp;quot;
# output:
# ./script.sh: line 3: unknowncmd: command not found
# hello
&lt;/code>&lt;/pre>
&lt;p>可以看到，Bash 只是显示有错误，接着继续执行 Shell 脚本，这种行为很不利于脚本安全和排错。实际开发中，如果某个命令失败，往往需要脚本停止&lt;/p>
&lt;p>set -e 从根本上解决了这个问题，它使得脚本只要发生错误，就终止执行：&lt;/p>
&lt;pre>&lt;code>#!/bin/bash
set -e
unknowncmd
echo &amp;quot;hello&amp;quot;
# output:
# ./script.sh: line 4: unknowncmd: command not found
&lt;/code>&lt;/pre>
&lt;p>可以看到，第 4 行执行失败以后，脚本就终止执行了。&lt;/p>
&lt;p>set -e 根据命令的返回值来判断命令是否运行失败。但是，某些命令的非零返回值可能不表示失败，或者开发者希望在命令失败的情况下，脚本继续执行下去：&lt;/p>
&lt;pre>&lt;code>#!/bin/bash
set -e
$(ls foobar)
echo &amp;quot;hello&amp;quot;
# output:
# ls: cannot access 'foobar': No such file or directory
&lt;/code>&lt;/pre>
&lt;p>可以看到，打开 set -e 之后，即使 ls 是一个已存在的命令，但因为 ls 命令的运行参数 foobar 实际上并不存在导致命令的返回非 0 值，这有时候并不是我们看到的。&lt;/p>
&lt;p>可以暂时关闭 set -e，该命令执行结束后，再重新打开 set -e：&lt;/p>
&lt;pre>&lt;code>#!/bin/bash
set -e
set +e
$(ls foobar)
set -e
echo &amp;quot;hello&amp;quot;
# output:
# ls: cannot access 'foobar': No such file or directory
# hello
&lt;/code>&lt;/pre>
&lt;p>上面代码中，set +e 表示关闭-e 选项，set -e 表示重新打开-e 选项。&lt;/p>
&lt;p>还有一种方法是使用 command || true，使得该命令即使执行失败，脚本也不会终止执行。&lt;/p>
&lt;p>set -e 还有另一种写法 set -o errexit。&lt;/p>
&lt;h2 id="set--o-pipefail">set -o pipefail&lt;/h2>
&lt;p>set -e 有一个例外情况，就是不适用于管道命令。对于管道命令，Bash 会把最后一个子命令的返回值作为整个命令的返回值。也就是说，只要最后一个子命令不失败，管道命令总是会执行成功，因此它后面命令依然会执行，set -e 就失效了。&lt;/p>
&lt;p>请看下面这个例子。&lt;/p>
&lt;pre>&lt;code>#!/bin/bash
set -e
foo | echo &amp;quot;bar&amp;quot;
echo &amp;quot;hello&amp;quot;
# output:
# ./script.sh: line 4: foo: command not found
# bar
# hello
&lt;/code>&lt;/pre>
&lt;p>可以看到，foo 是一个不存在的命令，但是 foo | echo bar 这个管道命令还是会执行成功，导致后面的 echo hello 会继续执行。&lt;/p>
&lt;p>set -o pipefail 用来解决这种情况，只要一个子命令失败，整个管道命令就失败，脚本就会终止执行：&lt;/p>
&lt;pre>&lt;code>#!/bin/bash
set -e
set -o pipefail
foo | echo &amp;quot;bar&amp;quot;
echo &amp;quot;hello&amp;quot;
# output:
# ./script.sh: line 5: foo: command not found
# bar
&lt;/code>&lt;/pre>
&lt;p>可以看到，echo hello 命令并没有执行。&lt;/p>
&lt;p>合并四个参数&lt;/p>
&lt;p>对于上面提到的四个 set 命令参数，一般都放在一起使用。&lt;/p>
&lt;h1 id="写法一-set--euxo-pipefail-写法二-set--euxset--o-pipefail">写法一 set -euxo pipefail# 写法二 set -euxset -o pipefail&lt;/h1>
&lt;p>这两种写法任选其一放在所有 Shell 脚本的头部。&lt;/p>
&lt;p>当然，也可以在在执行 Shell 脚本的时候，从 Bash 命令行传入这些参数：&lt;/p>
&lt;p>bash -euxo pipefail script.sh&lt;/p>
&lt;h1 id="shell-脚本防御式编程">Shell 脚本防御式编程&lt;/h1>
&lt;p>编写 Shell 脚本的时候应该考虑不可预期的程序输入，如文件不存在或者目录没有创建成功…其实 Shell 命令有很多选项可以解决这类问题，例如，使用 mkdir 创建目录的时候，如果父目录不存在，mkdir 默认返回错误，但如果加上-p 选项，mkdir 在父目录不存在的情况下先创建父目录；rm 在删除一个不存在的文件会失败，但如果加上-f 选项，即使文件不能存在也能执行成功。&lt;/p>
&lt;p>注意字符串中的空格&lt;/p>
&lt;p>我们必须时刻注意字符串中的空格字符，如文件名中的空格，命令参数中的空格等等，对于这些空格字符安全的最佳时实践是使用&amp;quot;括住相应的字符串：&lt;/p>
&lt;h1 id="will-fail-if-filename-contains-spacesif--filename--foo--will-success-even-if-filename-contains-spacesif--filename--foo-">will fail if $filename contains spacesif [ $filename = &amp;ldquo;foo&amp;rdquo; ];# will success even if $filename contains spacesif [ &amp;ldquo;$filename&amp;rdquo; = &amp;ldquo;foo&amp;rdquo; ];&lt;/h1>
&lt;p>Someone will always use spaces in filenames or command line arguments and you should keep this in mind when writing shell scripts. In particular you should use quotes around variables.&lt;/p>
&lt;p>if [ $filename = “foo” ]; will fail if $filename contains a space. This can be fixed by using:&lt;/p>
&lt;p>if [ “$filename” = “foo” ];&lt;/p>
&lt;p>类似的情况是，我们在使用$@或者其他包含由空格分割的多个字符串也要注意使用&amp;quot;括住相应的变量，实际上，使用&amp;quot;括住相应的变量没有任何副作用，只会是我们的 Shell 脚本更加健壮：&lt;/p>
&lt;p>foo() { for i in $@; do printf &amp;ldquo;%s\n&amp;rdquo; &amp;ldquo;$i&amp;rdquo;; done }; foo bar &amp;ldquo;baz quux&amp;quot;barbazquuxfoo() { for i in &amp;ldquo;$@&amp;rdquo;; do printf &amp;ldquo;%s\n&amp;rdquo; &amp;ldquo;$i&amp;rdquo;; done }; foo bar &amp;ldquo;baz quux&amp;quot;barbaz quux&lt;/p>
&lt;h1 id="使用-trap-命令">使用 trap 命令&lt;/h1>
&lt;p>关于 Shell 脚本一个常见的情况是，脚本执行失败导致文件系统处于不一致的状态，比如文件锁、临时文件或者 Shell 脚本的错误只更新了部分文件。为了达到“事务的完整性”我们需要解决这些不一致的问题，要么删除文件锁、临时文件，要么将状态恢复到更新之前的状态。实际上，Shell 脚本确实提供了一种在捕捉到特定的 unix 信号的情况下执行一段命令或者函数的功能：&lt;/p>
&lt;p>trap command signal [signal &amp;hellip;]&lt;/p>
&lt;p>其实 Shell 脚本可以捕捉很多类型的信号（完整信号列表可以使用 kill -l 命令获取），但是我们通常只关心在问题发生之后用来恢复现场的三种信号：INT，TERM 和 EXIT&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>&lt;/th>
&lt;th>&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>Signal&lt;/td>
&lt;td>Description&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>INT&lt;/td>
&lt;td>Interrupt – this signal is sent when someone kills the script by pressing ctrl-c&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>TERM&lt;/td>
&lt;td>Terminate – this signal is sent when someone sends the TERM signal using the kill command&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>EXIT&lt;/td>
&lt;td>Exit – this is a pseudo-signal and is triggered when your script exits, either through reaching the end of the script, an exit command or by a command failing when using set -e&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>一般情况下，我们在操作对应的共享区之前先创建文件锁：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">if&lt;/span> &lt;span style="color:#f92672">[&lt;/span> ! -e $lockfile &lt;span style="color:#f92672">]&lt;/span>; &lt;span style="color:#66d9ef">then&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> touch $lockfile
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> critical-section
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> rm $lockfile
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">else&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> echo &lt;span style="color:#e6db74">&amp;#34;critical-section is already running&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">fi&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>但是当 Shell 脚本操作对应的共享区的时候有人手动 Kill 掉对应的 Shell 脚本进程，这个时候文件锁的存在会导致 Shell 脚本不能再次操作对应的共享区。使用 trap 我们可以捕捉到对应的 Kill 信号并做相应的恢复操作：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">if&lt;/span> &lt;span style="color:#f92672">[&lt;/span> ! -e $lockfile &lt;span style="color:#f92672">]&lt;/span>; &lt;span style="color:#66d9ef">then&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> trap &lt;span style="color:#e6db74">&amp;#34;rm -f &lt;/span>$lockfile&lt;span style="color:#e6db74">; exit&amp;#34;&lt;/span> INT TErm EXIT
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> touch $lockfile
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> $lockfile
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> rm $lockfile
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> trap - INT TErm EXIT
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">else&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> echo &lt;span style="color:#e6db74">&amp;#34;critical-section is already running&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">fi&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>有了上面这段 trap 命令，即使当 Shell 脚本操作对应的共享区的时候有人手动 Kill 掉对应的 Shell 脚本进程，文件锁也会被清理干净。需要注意的是，我们在捕捉到 Kill 信号之后删除完文件锁之后直接退出而不是继续执行&lt;/p>
&lt;p>。&lt;/p>
&lt;p>Be Atomic&lt;/p>
&lt;p>很多时候我们需要一次更新一批文件，但是有可能在更新了一半之后 Shell 脚本出错或者有人 kill 掉了 Shell 脚本的进程。你可能会想到，就使用刚才学到的 trap 知识，同时对就文件做备份，一旦捕捉到出错的信号，就恢复备份。这看起来没错，但是很多时候只能解决一部分的问题。例如，我们要把一个网站里面的 URL 从www.example.org全部更新为www.example.com，Shell脚本的主要逻辑类似于这样：&lt;/p>
&lt;p>for file in $(find /var/www -type f -name &amp;ldquo;*.html&amp;rdquo;); do perl -pi -e &amp;rsquo;s/www.example.org/www.example.com/&amp;rsquo; $filedone&lt;/p>
&lt;p>正确的做法是尽量使更新操作原子化，实现操作的“事务一致性”：1. 拷贝旧目录；2. 在拷贝的目录中进行更新操作；3. 替换原目录&lt;/p>
&lt;p>cp -a /var/www /var/www-tmpfor file in $(find /var/www-tmp -type f -name &amp;ldquo;*.html&amp;rdquo;); do perl -pi -e &amp;rsquo;s/www.example.org/www.example.com/&amp;rsquo; $filedonemv /var/www /var/www-oldmv /var/www-tmp /var/www&lt;/p>
&lt;p>在类 Unix 文件系统上进行最后的两次 mv 操作是非常快的（因为只需要替换两个目录的 inode，而不用执行实际的拷贝操作），换句话说，容易出错的地方是批量的更新操作，而我们将更新操作全部在拷贝的目录中执行，这样，更新操作即使出错，也不会影响原目录。这里的技巧是，使用双倍的硬盘空间来进行操作，任何是需要长时间打开文件的操作都是在备份目录中进行。事实上，保持一系列操作的原子性对于某些容易出错的 Shell 脚本来说非常重要，同时操作前备份文件也是一个好的编程习惯。&lt;/p></description></item><item><title>Docs: Shell 命令行参数处理</title><link>https://desistdaydream.github.io/docs/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/4.Terminal-%E4%B8%8E-Shell/Shell-%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Shell-%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%8F%82%E6%95%B0%E5%A4%84%E7%90%86/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/4.Terminal-%E4%B8%8E-Shell/Shell-%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Shell-%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%8F%82%E6%95%B0%E5%A4%84%E7%90%86/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://www.cnblogs.com/klb561/p/9211222.html">https://www.cnblogs.com/klb561/p/9211222.html&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://blog.csdn.net/qq_22203741/article/details/77671379">https://blog.csdn.net/qq_22203741/article/details/77671379&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;h1 id="shell-代码命令行选项与修传入参数处理">shell 代码命令行选项与修传入参数处理&lt;/h1>
&lt;p>在编写 shell 程序时经常需要处理命令行参数，本文描述在 bash 下的命令行处理方式。&lt;/p>
&lt;p>选项与参数：&lt;/p>
&lt;p>如下命令行：&lt;/p>
&lt;p>./test.sh -f config.conf -v &amp;ndash;prefix=/home&lt;/p>
&lt;ol>
&lt;li>-f 为选项，它需要一个参数，即 config.conf&lt;/li>
&lt;li>-v 也是一个选项，但它不需要参数。&lt;/li>
&lt;li>&amp;ndash;prefix 我们称之为一个长选项，即选项本身多于一个字符，它也需要一个参数，用等号连接，当然等号不是必须的，/home 可以直接写在&amp;ndash;prefix 后面，即&amp;ndash;prefix/home,更多的限制后面具体会讲到。&lt;/li>
&lt;/ol>
&lt;p>在 bash 中，可以用以下三种方式来处理命令行参数，每种方式都有自己的应用场景。&lt;/p>
&lt;ol>
&lt;li>通过位置变量手工处理参数 # 参考变量与环境变量 文章中的位置变量&lt;/li>
&lt;li>getopts # 简单工具&lt;/li>
&lt;li>getopt # 复杂工具&lt;/li>
&lt;/ol>
&lt;p>依次讨论这三种处理方式。&lt;/p>
&lt;h1 id="通过位置变量手工处理参数">通过位置变量手工处理参数&lt;/h1>
&lt;p>在手工处理方式中，首先要知道几个变量，还是以上面的命令行为例：&lt;/p>
&lt;p>代码如下:&lt;/p>
&lt;ul>
&lt;li>
&lt;p>$0 ： ./test.sh,即命令本身，相当于 c/c++中的 argv[0]&lt;/p>
&lt;/li>
&lt;li>
&lt;p>$1 ： -f,第一个参数.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>$2 ： config.conf&lt;/p>
&lt;/li>
&lt;li>
&lt;p>$3, $4 &amp;hellip; ：类推。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>$#&lt;/code> 参数的个数，不包括命令本身，上例中 &lt;code>$#&lt;/code> 为 4.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>$@ ：参数本身的列表，也不包括命令本身，如上例为 -f config.conf -v &amp;ndash;prefix=/home&lt;/p>
&lt;/li>
&lt;li>
&lt;p>$&lt;em>：和$@相同，但&amp;quot;$&lt;/em>&amp;quot; 和 &amp;ldquo;$@&amp;quot;(加引号)并不同，&amp;quot;$*&amp;ldquo;将所有的参数解释成一个字符串，而&amp;rdquo;$@&amp;ldquo;是一个参数数组。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>例子：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#!/bin/bash
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">for&lt;/span> arg in &lt;span style="color:#e6db74">&amp;#34;&lt;/span>$*&lt;span style="color:#e6db74">&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">do&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> echo $arg
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">done&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">for&lt;/span> arg in &lt;span style="color:#e6db74">&amp;#34;&lt;/span>$@&lt;span style="color:#e6db74">&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">do&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> echo $arg
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">done&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>执行./test.sh -f config.conf -n 10 会打印：&lt;/p>
&lt;pre>&lt;code>-f config.conf -n 10 #这是&amp;quot;$*&amp;quot;的输出
-f #以下为$@的输出
config.conf
-n
10
&lt;/code>&lt;/pre>
&lt;p>所以，手工处理的方式即对这些变量的处理。因为手工处理高度依赖于你在命令行上所传参数的位置，所以一般都只用来处理较简单的参数。&lt;/p>
&lt;p>例如：&lt;/p>
&lt;p>./test.sh 10&lt;/p>
&lt;p>而很少使用./test -n 10 这种带选项的方式。 典型用法为：&lt;/p>
&lt;pre>&lt;code>#!/bin/bash
if [ x$1 != x ]
then
#...有参数
else
then
#...没有参数
fi
&lt;/code>&lt;/pre>
&lt;p>为什么要使用 x$1 != x 这种方式来比较呢？想像一下这种方式比较：&lt;/p>
&lt;p>if [ -n $1 ] #$1 不为空&lt;/p>
&lt;p>但如果用户不传参数的时候，$1 为空，这时 就会变成 [ -n ] ,所以需要加一个辅助字符串来进行比较。&lt;/p>
&lt;p>手工处理方式能满足大多数的简单需求，配合 shift 使用也能构造出强大的功能，但在要处理复杂选项的时候建议用下面的两种方法。&lt;/p>
&lt;h1 id="getoptsgetopt-工具">getopts/getopt 工具&lt;/h1>
&lt;p>处理命令行参数是一个相似而又复杂的事情，为此 go 语言提供 cobra 库来实现，c++ 的 boost 提供了 options 库。&lt;/p>
&lt;p>在 shell 中，处理此事的是 getopts 和 getopt 工具。&lt;/p>
&lt;p>getopts 和 getopt 功能相似但又不完全相同，其中 getopt 是独立的可执行文件，而 getopts 是由 bash 内置的。&lt;/p>
&lt;p>先来看看参数传递的典型用法:&lt;/p>
&lt;pre>&lt;code>* ./test.sh -a -b -c ： 短选项，各选项不需参数
* ./test.sh -abc ： 短选项，和上一种方法的效果一样，只是将所有的选项写在一起。
* ./test.sh -a args -b -c ：短选项，其中-a需要参数，而-b -c不需参数。
* ./test.sh --a-long=args --b-long ：长选项
&lt;/code>&lt;/pre>
&lt;p>先来看 getopts,它不支持长选项。&lt;/p>
&lt;p>使用 getopts 非常简单，代码如下:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#test.sh&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#!/bin/bash&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">while&lt;/span> getopts &lt;span style="color:#e6db74">&amp;#34;a:bc&amp;#34;&lt;/span> arg; &lt;span style="color:#66d9ef">do&lt;/span> &lt;span style="color:#75715e">#选项后面的冒号表示该选项需要参数&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">case&lt;/span> $arg in
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> a&lt;span style="color:#f92672">)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> echo &lt;span style="color:#e6db74">&amp;#34;a&amp;#39;s arg:&lt;/span>$optarg&lt;span style="color:#e6db74">&amp;#34;&lt;/span> &lt;span style="color:#75715e">#参数存在$optarg中&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> b&lt;span style="color:#f92672">)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> echo &lt;span style="color:#e6db74">&amp;#34;b&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> c&lt;span style="color:#f92672">)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> echo &lt;span style="color:#e6db74">&amp;#34;c&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ?&lt;span style="color:#f92672">)&lt;/span> &lt;span style="color:#75715e">#当有不认识的选项的时候arg为?&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> echo &lt;span style="color:#e6db74">&amp;#34;unkonw argument&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>exit &lt;span style="color:#ae81ff">1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">esac&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">done&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>现在就可以使用：
./test.sh -a arg -b -c
或
./test.sh -a arg -bc
来加载了。&lt;/p>
&lt;p>应该说绝大多数脚本使用该函数就可以了，如果需要支持长选项以及可选参数，那么就需要使用 getopt.&lt;/p>
&lt;h1 id="getopt">getopt&lt;/h1>
&lt;h2 id="syntax语法">Syntax(语法)&lt;/h2>
&lt;p>&lt;strong>getopt optstring parameters&lt;/strong>
&lt;strong>getopt [OPTIONS] [&amp;ndash;] optstring parameters&lt;/strong>
&lt;strong>getopt [OPTIONS] -o|&amp;ndash;options optstring [options] [&amp;ndash;] parameters&lt;/strong>&lt;/p>
&lt;p>OPTIONS&lt;/p>
&lt;ul>
&lt;li>-a, &amp;ndash;alternative Allow long options starting with single -&lt;/li>
&lt;li>-h, &amp;ndash;help This small usage guide&lt;/li>
&lt;li>-l, &amp;ndash;longoptions &lt;!-- raw HTML omitted --> # 要被识别的长选项&lt;/li>
&lt;li>-n, &amp;ndash;name &lt;!-- raw HTML omitted --> The name under which errors are reported&lt;/li>
&lt;li>-o, &amp;ndash;options &lt;!-- raw HTML omitted --> # 要被识别的短选项&lt;/li>
&lt;li>-q, &amp;ndash;quiet Disable error reporting by getopt(3)&lt;/li>
&lt;li>-Q, &amp;ndash;quiet-output No normal output&lt;/li>
&lt;li>-s, &amp;ndash;shell &lt;!-- raw HTML omitted --> Set shell quoting conventions&lt;/li>
&lt;li>-T, &amp;ndash;test Test for getopt(1) version&lt;/li>
&lt;li>-u, &amp;ndash;unquoted Do not quote the output&lt;/li>
&lt;li>-V, &amp;ndash;version Output version information&lt;/li>
&lt;/ul>
&lt;p>getopt 工具基本使用示例&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#!/bin/bash
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#75715e"># 请注意，我们使用 &amp;#34;$@&amp;#34; 来使每个命令行参数扩展为一个单独的单词。 $@ 周围的引号是必不可少的！&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># -o表示短选项，两个冒号表示该选项有一个可选参数，可选参数必须紧贴选项&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># 如-carg 而不能是-c arg&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># -l或--long选项后面接可接受的长选项，每个选项用逗号分开，冒号的意义同短选项。&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># -n:出错时的信息&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># -- ：举一个例子比较好理解：&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#我们要创建一个名字为 &amp;#34;-f&amp;#34;的目录你会怎么办？&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># mkdir -f # 不成功，因为-f会被mkdir当作选项来解析，这时就可以使用&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># mkdir -- -f 这样-f就不会被作为选项。&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># 我们需要使用 temp 作为`eval set-`来抵消getopt的返回值。&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>temp&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">`&lt;/span>getopt -o ab:c:: --long a-long,b-long:,c-long:: &lt;span style="color:#ae81ff">\
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">&lt;/span> -n &lt;span style="color:#e6db74">&amp;#39;example.bash&amp;#39;&lt;/span> -- &lt;span style="color:#e6db74">&amp;#34;&lt;/span>$@&lt;span style="color:#e6db74">&amp;#34;&lt;/span>&lt;span style="color:#e6db74">`&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">if&lt;/span> &lt;span style="color:#f92672">[&lt;/span> $? !&lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span> &lt;span style="color:#f92672">]&lt;/span> ; &lt;span style="color:#66d9ef">then&lt;/span> echo &lt;span style="color:#e6db74">&amp;#34;terminating...&amp;#34;&lt;/span> &amp;gt;&amp;amp;&lt;span style="color:#ae81ff">2&lt;/span> ; exit &lt;span style="color:#ae81ff">1&lt;/span> ; &lt;span style="color:#66d9ef">fi&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># 注意 $temp 周围的引号：它们是必不可少的！&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># set 会重新排列参数的顺序，也就是改变$1,$2...$n的值，这些值在getopt中重新排列过了&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>eval set -- &lt;span style="color:#e6db74">&amp;#34;&lt;/span>$temp&lt;span style="color:#e6db74">&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># 经过getopt的处理，下面处理具体选项。&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">while&lt;/span> true ; &lt;span style="color:#66d9ef">do&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">case&lt;/span> &lt;span style="color:#e6db74">&amp;#34;&lt;/span>$1&lt;span style="color:#e6db74">&amp;#34;&lt;/span> in
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> -a|--a-long&lt;span style="color:#f92672">)&lt;/span> echo &lt;span style="color:#e6db74">&amp;#34;option a&amp;#34;&lt;/span> ; shift ;;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> -b|--b-long&lt;span style="color:#f92672">)&lt;/span> echo &lt;span style="color:#e6db74">&amp;#34;option b, argument \`&lt;/span>$2&lt;span style="color:#e6db74">&amp;#39;&amp;#34;&lt;/span> ; shift &lt;span style="color:#ae81ff">2&lt;/span> ;;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> -c|--c-long&lt;span style="color:#f92672">)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e"># c 有一个可选参数。 由于我们处于引用模式，如果找不到可选参数，则会生成一个空参数。&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">case&lt;/span> &lt;span style="color:#e6db74">&amp;#34;&lt;/span>$2&lt;span style="color:#e6db74">&amp;#34;&lt;/span> in
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#34;&amp;#34;&lt;/span>&lt;span style="color:#f92672">)&lt;/span> echo &lt;span style="color:#e6db74">&amp;#34;option c, no argument&amp;#34;&lt;/span>; shift &lt;span style="color:#ae81ff">2&lt;/span> ;;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> *&lt;span style="color:#f92672">)&lt;/span> echo &lt;span style="color:#e6db74">&amp;#34;option c, argument \`&lt;/span>$2&lt;span style="color:#e6db74">&amp;#39;&amp;#34;&lt;/span> ; shift &lt;span style="color:#ae81ff">2&lt;/span> ;;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">esac&lt;/span> ;;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> --&lt;span style="color:#f92672">)&lt;/span> shift ; break ;;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> *&lt;span style="color:#f92672">)&lt;/span> echo &lt;span style="color:#e6db74">&amp;#34;internal error!&amp;#34;&lt;/span> ; exit &lt;span style="color:#ae81ff">1&lt;/span> ;;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">esac&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">done&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>echo &lt;span style="color:#e6db74">&amp;#34;remaining arguments:&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">for&lt;/span> arg &lt;span style="color:#66d9ef">do&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> echo &lt;span style="color:#e6db74">&amp;#39;--&amp;gt; &amp;#39;&lt;/span>&lt;span style="color:#e6db74">&amp;#34;\`&lt;/span>$arg&lt;span style="color:#e6db74">&amp;#39;&amp;#34;&lt;/span> ;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">done&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>上述代码会循环处理参数，每处理一个参数，就用 shift 命令剔除，直到所有参数全部处理完，则跳出循环&lt;/p>
&lt;p>执行效果如下：&lt;/p>
&lt;pre>&lt;code>./parse.bash -a par1 'another arg' --c-long 'wow!*\?' -cmore -b &amp;quot; very long &amp;quot;
option a
option c, no argument
option c, argument `more'
option b, argument ` very long '
remaining arguments:
--&amp;gt; `par1'
--&amp;gt; `another arg'
--&amp;gt; `wow!*\?'
&lt;/code>&lt;/pre>
&lt;p>比如使用&lt;/p>
&lt;p>./test -a -b arg arg1 -c&lt;/p>
&lt;p>你可以看到,命令行中多了个 arg1 参数，在经过 getopt 和 set 之后，命令行会变为：&lt;/p>
&lt;p>-a -b arg -c &amp;ndash; arg1&lt;/p>
&lt;p>$1 指向 -a,$2 指向 -b,$3 指向 arg,$4 指向 -c,$5 指向 &amp;ndash;,而多出的 arg1 则被放到了最后。&lt;/p>
&lt;p>3，总结&lt;/p>
&lt;p>一般小脚本手工处理也就够了，getopts 能处理绝大多数的情况，getopt 较复杂，功能也更强大!/bin/bash&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">function&lt;/span> Help&lt;span style="color:#f92672">(){&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> echo &lt;span style="color:#e6db74">&amp;#39; ================================================================ &amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> echo &lt;span style="color:#e6db74">&amp;#39; 请使用下列 flags 来运行脚本，若无需改变默认值，使用 ./test.sh -- 即可；&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> echo &lt;span style="color:#e6db74">&amp;#39; 如果环境无互联网，则安装的docker版本根据离线包的版本决定，dockerversion参数无用；&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> echo &lt;span style="color:#e6db74">&amp;#39; --cgroupdriver: 指定 cgroupdrive 的类型，默认为 systemd；&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> echo &lt;span style="color:#e6db74">&amp;#39; --dockerversion: 指定要安装的 docer-ce 版本，默认为 19.03.11；&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> echo &lt;span style="color:#e6db74">&amp;#39; 使用示例:&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> echo &lt;span style="color:#e6db74">&amp;#39; ./test.sh --cgroupdriver=systemd --dockerversion=19.03.11&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> echo &lt;span style="color:#e6db74">&amp;#39; ================================================================&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">case&lt;/span> &lt;span style="color:#e6db74">&amp;#34;&lt;/span>$1&lt;span style="color:#e6db74">&amp;#34;&lt;/span> in
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> -h|--help&lt;span style="color:#f92672">)&lt;/span> Help; exit;;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">esac&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">if&lt;/span> &lt;span style="color:#f92672">[[&lt;/span> $1 &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#e6db74">&amp;#39;&amp;#39;&lt;/span> &lt;span style="color:#f92672">||&lt;/span> ! $1 &lt;span style="color:#f92672">=&lt;/span>~ &lt;span style="color:#e6db74">&amp;#39;--&amp;#39;&lt;/span> &lt;span style="color:#f92672">]]&lt;/span>;&lt;span style="color:#66d9ef">then&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Help;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> exit;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">fi&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>CMDFLAGS&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>$*&lt;span style="color:#e6db74">&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">for&lt;/span> FLAGS in $CMDFLAGS;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">do&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> key&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#66d9ef">$(&lt;/span>echo &lt;span style="color:#e6db74">${&lt;/span>FLAGS&lt;span style="color:#e6db74">}&lt;/span> | awk -F&lt;span style="color:#e6db74">&amp;#34;=&amp;#34;&lt;/span> &lt;span style="color:#e6db74">&amp;#39;{print $1}&amp;#39;&lt;/span> &lt;span style="color:#66d9ef">)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> value&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#66d9ef">$(&lt;/span>echo &lt;span style="color:#e6db74">${&lt;/span>FLAGS&lt;span style="color:#e6db74">}&lt;/span> | awk -F&lt;span style="color:#e6db74">&amp;#34;=&amp;#34;&lt;/span> &lt;span style="color:#e6db74">&amp;#39;{print $2}&amp;#39;&lt;/span> &lt;span style="color:#66d9ef">)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">case&lt;/span> &lt;span style="color:#e6db74">&amp;#34;&lt;/span>$key&lt;span style="color:#e6db74">&amp;#34;&lt;/span> in
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> --cgroupdriver&lt;span style="color:#f92672">)&lt;/span> CgroupDriver&lt;span style="color:#f92672">=&lt;/span>$value ;;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> --dockerversion&lt;span style="color:#f92672">)&lt;/span> DockerVersion&lt;span style="color:#f92672">=&lt;/span>$value ;;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">esac&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">done&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># Docker 配置&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>CgroupDriver&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">${&lt;/span>CgroupDriver&lt;span style="color:#66d9ef">:-&lt;/span>systemd&lt;span style="color:#e6db74">}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>DockerVersion&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">${&lt;/span>DockerVersion&lt;span style="color:#66d9ef">:-&lt;/span>19.03.11&lt;span style="color:#e6db74">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div></description></item><item><title>Docs: 变量</title><link>https://desistdaydream.github.io/docs/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/4.Terminal-%E4%B8%8E-Shell/Shell-%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/%E5%8F%98%E9%87%8F/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/4.Terminal-%E4%B8%8E-Shell/Shell-%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/%E5%8F%98%E9%87%8F/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;p>&lt;strong>Variable(变量，简称 var)&lt;/strong> 是一个可以改变内容的固定规定，比如我定义“这台电脑的名字”叫“XXX”，“这台电脑的名字”就是不变的内容，“XXX”就是可以改变的内容，给不变的内容定义不同的内容&lt;/p>
&lt;ul>
&lt;li>比如 X=1，X=2，X=3 等等，X 就是不变的，1，2，3 等等都是可变的，X 就是一个变量，可以被赋予某些内容&lt;/li>
&lt;li>环境变量就是在当前环境下所定义的内容，比如 linux 启动了一个 shell，在 shell 这个环境下，有一些规定被定义了，这些规定就是环境变量；不在这个 shell 下变量就不生效&lt;/li>
&lt;li>比如：LANG 是一个语言的规定，你赋予他一个内容，就相当于定义了这个 shell 环境下所显示的语言，比如 LANG=US，LANG=CN 等等。LANG 这叫定义语言，这是不变的，可变的是后面的自定义内容，语言(不变)=英语、汉语、日语(可变)。&lt;/li>
&lt;li>再比如我执行一条命令，linux 执行的命令，就是运行某个定义好的相对应的该命令的文件（注意：linux 中一切皆文件）&lt;/li>
&lt;/ul>
&lt;p>实际例子：当我在 Shell 中输入 &lt;code>ls -al /etc&lt;/code> 这个命令的时候有以下几步&lt;/p>
&lt;ul>
&lt;li>需要定义我输入的内容是什么样的结构，以空格分隔的字段，每一段都进行什么操作
&lt;ul>
&lt;li>第一段为命令段 ls，需要有一个环境变量定义去哪里执行这条命令对应的文件(一个命令是通过一个文件中写的各种代码来实现的)，这个环境变量就是 PATH，PATH 可以寻找该命令文件的目录，让 shell 去这些目录中找 ls 文件，然后执行。&lt;/li>
&lt;li>第二段是 -al，是 ls 命令的第一个参数，具体实行方法需要参考 ls 命令的说明文档&lt;/li>
&lt;li>第三段 /etc，是 ls 命令的第二个参数，具体实行方法需要参考 ls 命令的说明文档&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>根据整体变量，ls 的变量等输出最终结果&lt;/li>
&lt;/ul>
&lt;h2 id="环境变量">环境变量&lt;/h2>
&lt;p>环境变量是一种特别的变量，用来定义系统运行环境的一些参数，比如每个用户不同的家目录(&lt;code>${HOME}&lt;/code>)、可执行程序所在位置(&lt;code>${PATH}&lt;/code>)、等等。环境变量不是内核的一部分，通常由 Shell 程序管理。&lt;/p>
&lt;blockquote>
&lt;p>毕竟就算没有 &lt;code>$PATH&lt;/code> 我们也可以通过二进制文件的绝对路径来启动程序，所以这些环境变量，通常都是 Shell 用的，主要是针对 Shell 这个环境来说的。如果一个程序不在 Shell 中运行，一般也不太可能会用到环境变量，想要什么数据，直接通过代码获取即可。&lt;/p>
&lt;p>对环境变量这种理解，我是通过问 NewBing &lt;code>Linux 的环境变量是内核的一部分吗？可以在 Linux 代码中找到吗？&lt;/code> 这个问题获得的结果。&lt;/p>
&lt;/blockquote>
&lt;p>环境变量通常有以下几种：&lt;/p>
&lt;ul>
&lt;li>&lt;strong>全局环境变量&lt;/strong> # 这些变量对所有用户和进程都有效，通常在 &lt;code>/etc/environment&lt;/code> 文件中定义。&lt;/li>
&lt;li>&lt;strong>用户环境变量&lt;/strong> # 这些变量只对特定用户有效，通常在 &lt;code>~/.bashrc&lt;/code> 文件中定义。&lt;/li>
&lt;li>&lt;strong>局部环境变量&lt;/strong> # 这些变量只对当前 shell 或子 shell 有效，通常在命令行中定义。&lt;/li>
&lt;/ul>
&lt;p>环境变量通常使用 &lt;code>export&lt;/code> 声明&lt;/p>
&lt;h2 id="其他特殊变量">其他特殊变量&lt;/h2>
&lt;p>&lt;strong>位置变量&lt;/strong>：&lt;code>$0&lt;/code> 该脚本所在的绝对路径 &lt;code>$1&lt;/code> 脚本的第一个参数 &lt;code>$2&lt;/code>&amp;hellip;..等等&lt;/p>
&lt;ul>
&lt;li>&lt;code>$数字&lt;/code> # 是位置参数的用法。如果运行脚本的时候带参数，那么可以在脚本里通过 $1 获取第一个参数，$2 获取第二个参数&amp;hellip;&amp;hellip;依此类推，一共可以直接获取 9 个参数（称为位置参数）。$0 用于获取脚本名称。相应地，如果 $+数字 用在函数里，那么表示获取函数的传入参数，$0 表示函数名。
&lt;ul>
&lt;li>&lt;code>$0&lt;/code> # 该脚本所在的绝对路径&lt;/li>
&lt;li>&lt;code>$1&lt;/code> # 脚本的第一个参数&lt;/li>
&lt;li>&lt;code>$2&lt;/code> # 脚本的第二个参数&lt;/li>
&lt;li>&amp;hellip;..等等&lt;/li>
&lt;li>比如：
&lt;ul>
&lt;li>./test.sh a b c # 运行该脚本时候，a 就是变量 $1(第一个参数)，b 就是变量 $2(第二个参数)，变量 $# 为 3,一共 3 个位置参数&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>其他位置参数：
&lt;ul>
&lt;li>&lt;code>$#&lt;/code> # 位置变量的个数&lt;/li>
&lt;li>&lt;code>$*&lt;/code> # 引用所有的位置参数，引用后就是显示或者执行引用的字符串&lt;/li>
&lt;li>&lt;code>$@&lt;/code> # 引用所有的位置参数，引用后就是显示或者执行引用的字符串&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>特殊变量&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>$? # 上一条命令执行的结果的返回值，成功为 0，失败为不为 0&lt;/li>
&lt;li>&lt;code>$$&lt;/code> # 当前 shell 的 PID 号&lt;/li>
&lt;li>$! # Shell 最后运行的后台进程的 PID&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>给变量赋予默认值&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>VarName=${VarName:=VALUE} # 如果 VarName 不空，则其值不变；否则，VarName 会使用 VALUE 作为其默认值&lt;/li>
&lt;/ul>
&lt;h2 id="变量的基本类型">变量的基本类型&lt;/h2>
&lt;ul>
&lt;li>Numbers(数字型)。格式化标识符&lt;code>%d&lt;/code>
&lt;ul>
&lt;li>Integers 整数型。简写为&lt;code>int&lt;/code>&lt;/li>
&lt;li>Floating Point Numbers 浮点数型&lt;/li>
&lt;li>complex 复数共两种复数，complex64 和 complex128，分别对应 float32 和 float64 两种浮点数精度。内置的 complex 函数用于构建复数，内建的 real 和 imag 函数分别返回复数的实部和虚部&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Strings(字符型)。格式化标识符&lt;code>%s&lt;/code>&lt;/li>
&lt;li>Booleans 布尔型
&lt;ul>
&lt;li>注意：很多时候，Booleans 类型的值可以用数字表示
&lt;ul>
&lt;li>1 表示 true(真)&lt;/li>
&lt;li>0 表示 false(假)&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>等等&lt;/li>
&lt;/ul>
&lt;h1 id="声明变量取消变量">声明变量，取消变量&lt;/h1>
&lt;p>对于环境变量与普通变量，声明的方式不太一样。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>~&lt;span style="color:#f92672">]&lt;/span>&lt;span style="color:#75715e"># TestVar=&amp;#34;This is Normal Var&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>~&lt;span style="color:#f92672">]&lt;/span>&lt;span style="color:#75715e"># export TestEnvVar=&amp;#34;This is Enviroment Var&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>~&lt;span style="color:#f92672">]&lt;/span>&lt;span style="color:#75715e"># bash&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>~&lt;span style="color:#f92672">]&lt;/span>&lt;span style="color:#75715e"># echo $TestVar&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>~&lt;span style="color:#f92672">]&lt;/span>&lt;span style="color:#75715e"># echo $TestEnvVar&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>This is Enviroment Var
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>这个示例中可以看到，当我们启动一个新 Bash 时，不使用 &lt;code>export&lt;/code> 声明的变量，将不会被子 Bash 继承。这就是环境变量与普通变量的基本区别。&lt;/p>
&lt;p>对于 Shell 编程语言来说，一个变量其实不声明也是可以的，默认任意字符串组合成的变量的值都为空，比如&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>~&lt;span style="color:#f92672">]&lt;/span>&lt;span style="color:#75715e"># env | grep randomVar&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>~&lt;span style="color:#f92672">]&lt;/span>&lt;span style="color:#75715e"># echo $randomVar&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ~&lt;span style="color:#f92672">]&lt;/span>&lt;span style="color:#75715e"># echo $?&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">0&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>可以看到，一个不存在的变量依然可以正常输出，只不过值为空。&lt;/p>
&lt;h2 id="普通变量">普通变量&lt;/h2>
&lt;p>直接使用 &lt;code>变量名=变量值&lt;/code> 的方式即可声明一个变量并未该变量赋值。&lt;/p>
&lt;p>VarName=&amp;ldquo;Value&amp;rdquo;&lt;/p>
&lt;h2 id="环境变量-1">环境变量&lt;/h2>
&lt;p>&lt;strong>export [OPTIONS] [VarName[=VALUE] &amp;hellip;]&lt;/strong> # 设置或显示环境变量(export 的效力仅作用于该次登陆操作)。&lt;/p>
&lt;p>用户创建的变量仅可用于当前 Shell，子 Shell 默认读取不到父 Shell 定义的变量。为了把变量传递给子 Shell，需要使用 export 命令。这样输出的变量，对于子 Shell 来说就是环境变量。&lt;/p>
&lt;p>OPTIONS&lt;/p>
&lt;ul>
&lt;li>&lt;strong>-f&lt;/strong> # 代表[NAME]中为函数名称&lt;/li>
&lt;li>&lt;strong>-n&lt;/strong> # 删除指定的变量。变量实际上并未删除，只是不会输出到后续指令的执行环境中&lt;/li>
&lt;li>&lt;strong>-p&lt;/strong> # 列出所有的 shell 赋予程序的环境变量。&lt;/li>
&lt;/ul>
&lt;p>EXAMPLE&lt;/p>
&lt;ul>
&lt;li>export VarName=&amp;ldquo;Value&amp;rdquo; #&lt;/li>
&lt;li>export VarName #&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>[set] VarName=&amp;ldquo;Value&amp;rdquo;&lt;/strong>&lt;/p>
&lt;p>EXAMLE&lt;/p>
&lt;ul>
&lt;li>test=&amp;ldquo;test.test&amp;rdquo; # 设定一个名为 test 的变量的值为 test.test&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>unset VarName&lt;/strong>&lt;/p>
&lt;p>EXAMPLE&lt;/p>
&lt;ul>
&lt;li>unset TestVar # 取消变量名为 TestVar 的值&lt;/li>
&lt;/ul>
&lt;p>注意：如果想要给 &lt;code>$PATH&lt;/code> 变量增加内容，则需要用命令 &lt;code>PATH=$PATH:/NAME/NAME&lt;/code>，如果前面不加 &lt;code>$PATH&lt;/code>，那么这个变量就等于被改写成 &lt;code>/NAME/NAME&lt;/code>，这点在修改变量时候尤为重要，必须要在定义 PATH 的引入本身已经定义好的 &lt;code>$PATH&lt;/code>&lt;/p>
&lt;p>&lt;strong>declare # 声明 shell 变量&lt;/strong>&lt;/p>
&lt;p>declare 为 shell 命令，在第一种语法中可用来声明变量并设置变量的属性，在第二种语法中可用来显示 shell 函数。若不加上任何参数，则会显示全部的 shell 变量与函数(与执行 set 指令的效果相同)。&lt;/p>
&lt;p>语法格式：&lt;/p>
&lt;p>declare [+/-][OPTIONS] VarName&lt;/p>
&lt;p>OPTIONS&lt;/p>
&lt;ul>
&lt;li>&lt;strong>-&lt;/strong> # 给变量添加类型属性&lt;/li>
&lt;li>&lt;strong>+&lt;/strong> # 取消变量的类型属性&lt;/li>
&lt;li>&lt;strong>-a&lt;/strong> # 将变量声明为数组型&lt;/li>
&lt;li>&lt;strong>-i&lt;/strong> # 将变量声明为整型&lt;/li>
&lt;li>&lt;strong>-x&lt;/strong> # 将变量声明为环境变量&lt;/li>
&lt;li>&lt;strong>-r&lt;/strong> # 将变量声明为只读变量&lt;/li>
&lt;li>&lt;strong>-p&lt;/strong> # 查看变量的被声明的类型&lt;/li>
&lt;li>&lt;strong>-f&lt;/strong> #&lt;/li>
&lt;/ul>
&lt;h1 id="引用变量">引用变量&lt;/h1>
&lt;p>Linux 中，普通变量与环境变量的引用方式相同。&lt;/p>
&lt;p>引用变量有两种写法 &lt;code>$VAR_NAME&lt;/code> 或者 &lt;code>${VAR_NAME}&lt;/code> ，推荐使用第二种方法，两种方法的差别如下&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>~&lt;span style="color:#f92672">]&lt;/span>&lt;span style="color:#75715e"># name=&amp;#39;hello DesistDaydream!&amp;#39;; name=&amp;#34;$nameceshi&amp;#34;; echo $name&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># 这里输出为空，不是手打的回车&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>~&lt;span style="color:#f92672">]&lt;/span>&lt;span style="color:#75715e"># name=&amp;#39;hello DesistDaydream!&amp;#39;; name=&amp;#34;${name}ceshi&amp;#34;; echo $name&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>hello DesistDaydream!ceshi
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>我们还可以把命令的执行结果赋值给变量,使用 &lt;code>$(COMMAND)&lt;/code> 方式&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>~&lt;span style="color:#f92672">]&lt;/span>&lt;span style="color:#75715e"># time=$(date)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>~&lt;span style="color:#f92672">]&lt;/span>&lt;span style="color:#75715e"># echo $time&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>2020年 08月 28日 星期五 12:44:46 CST
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>变量的拼接&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>~&lt;span style="color:#f92672">]&lt;/span>&lt;span style="color:#75715e"># name=&amp;#34;小明&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>~&lt;span style="color:#f92672">]&lt;/span>&lt;span style="color:#75715e"># echo $name&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>小明
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>~&lt;span style="color:#f92672">]&lt;/span>&lt;span style="color:#75715e"># name=$name&amp;#34;和老王&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>~&lt;span style="color:#f92672">]&lt;/span>&lt;span style="color:#75715e"># echo $name&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>小明和老王
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>~&lt;span style="color:#f92672">]&lt;/span>&lt;span style="color:#75715e"># name=&amp;#34;${name}在一起&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>~&lt;span style="color:#f92672">]&lt;/span>&lt;span style="color:#75715e"># echo $name&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>小明和老王在一起
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>删除变量&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>~&lt;span style="color:#f92672">]&lt;/span>&lt;span style="color:#75715e"># name=&amp;#39;hello Desist Daydream!&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>~&lt;span style="color:#f92672">]&lt;/span>&lt;span style="color:#75715e"># echo ${name}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>hello Desist Daydream!
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>~&lt;span style="color:#f92672">]&lt;/span>&lt;span style="color:#75715e"># unset name&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>~&lt;span style="color:#f92672">]&lt;/span>&lt;span style="color:#75715e"># echo ${name}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>~&lt;span style="color:#f92672">]&lt;/span>&lt;span style="color:#75715e">#&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h1 id="操作变量的高级技巧">操作变量的高级技巧&lt;/h1>
&lt;h2 id="使用---符号的功能来处理变量中的字符串">使用 &lt;code>${ }&lt;/code> 符号的功能来处理变量中的字符串&lt;/h2>
&lt;p>在日常使用变量中，经常会需要对变量中的值进行操作，比如删除、替换、截取等等。通过&lt;code>${ }&lt;/code>符号，就可以对指定变量中的值进行各种操作&lt;/p>
&lt;p>想要处理字符串，通常有如下几种方式：&lt;/p>
&lt;ul>
&lt;li>从指定位置截取字符串
&lt;ul>
&lt;li>&lt;code>${VARIABLE:START:LENGTH}&lt;/code> # 从 VARIABLE 值的 左边 起第 START 个字符开始，向右截取 LENGTH 个字符&lt;/li>
&lt;li>&lt;code>${VARIABLE:0-START:LENGTH}&lt;/code> # 从 VARIABLE 值的 右边 起第 START 个字符开始，向右截取 LENGTH 个字符&lt;/li>
&lt;li>Note：
&lt;ul>
&lt;li>:LENGTH 可省略。省略的话表示截取到变量值的末尾&lt;/li>
&lt;li>从左边开始计数时，起始数字是 0（这符合程序员思维）；从右边开始计数时，起始数字是 1（这符合常人思维）。计数方向不同，起始数字也不同。&lt;/li>
&lt;li>左数和右数的区别就是其实位置那个位置有没有 0- 这个标识符&lt;/li>
&lt;li>不管从哪边开始计数，截取方向都是从左到右。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>从指定字符串处截取字符串
&lt;ul>
&lt;li>&lt;code>${VARIABLE#*CHARS}&lt;/code> # 从左边开始到第一个 CHARS 为止的字符全部忽略，只留下右边的所有字符&lt;/li>
&lt;li>&lt;code>${VARIABLE##*CHARS}&lt;/code> # 从左边开始到最后一个 CHARS 为止的字符全部忽略，只留下右边的所有字符&lt;/li>
&lt;li>&lt;code>${VARIABLE%CHARS*}&lt;/code> # 从右边开始到第一个 CHARS 为止的字符全部忽略，只留下左边的所有字符&lt;/li>
&lt;li>&lt;code>${VARIABLE%%CHARS*}&lt;/code> # 从右边开始到最后一个 CHARS 为止的字符全部忽略，只留下左边的所有字符&lt;/li>
&lt;li>Note:
&lt;ul>
&lt;li>截取时，CHARS 不被包含在内。CHARS 可以是一个字符，也可以是一个字符串，当作一个整体看待，不要把 CHARS 拆开。当 CHARS 为字符时，则在计数开始时，表示从出现该字符串整体开始算。&lt;/li>
&lt;li>&lt;code>-&lt;/code> 符号只是一个通配符，可以省略。上面的语法中的 * 就是表示 CHARS 左侧或者右侧的所有字符&lt;/li>
&lt;li>比如 &lt;code>${VARIABLE%%CHARS*}&lt;/code> 其实就是删掉从右数最后一个 CHARS 右侧的所有字符&lt;/li>
&lt;li>这种截取方式无法指定字符串长度。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>替换变量中匹配到的字符串
&lt;ul>
&lt;li>&lt;code>${VARIABLE/OldChars/NewChars}&lt;/code> # 将 VARIABLE 值中匹配到第一个的 OldChars 替换为 NewChars&lt;/li>
&lt;li>&lt;code>${VARIABLE//OldChars/NewChars}&lt;/code> # 将 VARIABLE 值中匹配到所有的 OldChars 替换为 NewChars&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>获取变量值的长度
&lt;ul>
&lt;li>&lt;code>${#VARIABLE}&lt;/code> # 变量名前加 # 符号&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>EXAMPLE&lt;/strong>&lt;/p>
&lt;p>&lt;strong>从指定位置截取字符串&lt;/strong>&lt;/p>
&lt;p>&lt;code>export split='www.desistdaydream.com'&lt;/code>&lt;/p>
&lt;ul>
&lt;li>&lt;code>echo ${split:4:14}&lt;/code> # 从第四位字符开始(包括第四位)，一共截取14个字符。由于第一个字符是0号位置，所以第四位字符，按照人类的理解应该是第五个字符。&lt;/li>
&lt;li>输出结果：desistdaydream&lt;/li>
&lt;li>echo ${split:4} # 省略 length，截取到字符串末尾&lt;/li>
&lt;li>输出结果：desistdaydream.com&lt;/li>
&lt;li>&lt;code>echo ${split: 0-18: 14}&lt;/code> # 从右边数，b是第 13 个字符。&lt;/li>
&lt;li>输出结果：desistdaydream&lt;/li>
&lt;li>&lt;code>echo ${split: 0-18}&lt;/code> # 省略 length，直接截取到字符串末尾&lt;/li>
&lt;li>输出结果：desistdaydream.com&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>从指定字符串处截取字符串&lt;/strong>&lt;/p>
&lt;p>&lt;code>split=&amp;quot;http://www.desistdaydream.com/index.html&amp;quot;&lt;/code>&lt;/p>
&lt;ul>
&lt;li>&lt;code>echo ${split#*/}&lt;/code> # 也可以写为 &lt;code>${split#*p:/}&lt;/code> 或 &lt;code>${split#http:/}&lt;/code>，效果相同。注意带 * 和不带 * 的区别。
&lt;ul>
&lt;li>输出结果：/www.desistdaydream.com/index.html&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;code>echo ${split##*/}&lt;/code>&lt;/li>
&lt;li>输出结果：index.html&lt;/li>
&lt;li>&lt;code>echo ${split%/*}&lt;/code>&lt;/li>
&lt;li>输出结果：&lt;a href="http://www.desistdaydream.com">http://www.desistdaydream.com&lt;/a>&lt;/li>
&lt;li>&lt;code>echo ${split%%/*}&lt;/code>&lt;/li>
&lt;li>输出结果：http:&lt;/li>
&lt;/ul>
&lt;h2 id="使用-eval-命令让变量的值作为另一个变量的变量名">使用 eval 命令让变量的值作为另一个变量的变量名&lt;/h2>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>root@lichenhao:~# varname&lt;span style="color:#f92672">=&lt;/span>name
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>root@lichenhao:~# name&lt;span style="color:#f92672">=&lt;/span>lichenhao
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>root@lichenhao:~# echo $$varname
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>209409varname
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>root@lichenhao:~# echo &lt;span style="color:#e6db74">&amp;#39;$&amp;#39;&lt;/span>$varname
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>$name
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>root@lichenhao:~# eval echo &lt;span style="color:#e6db74">&amp;#39;$&amp;#39;&lt;/span>$varname
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>lichenhao
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div></description></item><item><title>Docs: 函数</title><link>https://desistdaydream.github.io/docs/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/4.Terminal-%E4%B8%8E-Shell/Shell-%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/%E5%87%BD%E6%95%B0/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/4.Terminal-%E4%B8%8E-Shell/Shell-%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/%E5%87%BD%E6%95%B0/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;p>&lt;strong>Function(函数)&lt;/strong> 就是代码块，函数中表示了一堆代码的集合，当调用函数的时候，则会执行函数中函数体内的命令&lt;/p>
&lt;p>语法格式：&lt;/p>
&lt;pre>&lt;code>function NAME(){
函数体
}
###或者
NAME() {
函数体
}
&lt;/code>&lt;/pre>
&lt;p>调用方式：在 shell 脚本中，函数并不会执行，只有在调用的时候，才会执行函数体中的命令&lt;/p>
&lt;ol>
&lt;li>直接使用函数名即可调用，函数名出现的地方，会被自动替换为函数体中的命令&lt;/li>
&lt;li>在调用函数时，传递参数给函数体，在函数名后面以空白分隔指定的参数列表即可。e.g.FunctionName ARG1 ARG2 &amp;hellip;ARGn
&lt;ol>
&lt;li>每个参数可以在函数体中使用位置参数进行引用，i.e.ARG1 在函数体中就是$1 的值，ARG2 在函数体中就是$2 的值，以此类推&lt;/li>
&lt;/ol>
&lt;/li>
&lt;/ol>
&lt;p>函数的生命周期：被调用时创建，返回时终止&lt;/p>
&lt;p>使用 return 命令返回自定义状态结果
0：成功
1-255：失败&lt;/p>
&lt;p>函数中的变量：在函数体内定义的变量只对该函数生效，当函数生命周期结束时，变量失效。&lt;/p>
&lt;p>注意：在函数体中，可以修改全局变量的值&lt;/p>
&lt;h1 id="函数的递归函数直接或间接调用自身">函数的递归：函数直接或间接调用自身&lt;/h1>
&lt;p>函数递归的应用实例：&lt;/p>
&lt;h2 id="阶乘nnn-1n-21">阶乘：N!=N(n-1)(n-2)&amp;hellip;1&lt;/h2>
&lt;pre>&lt;code> #/bin/bashfact() { if [ $1 -eq 0 -o $1 -eq 1 ]; then echo 1 else echo $[$1*$(fact $[$1-1])] fi}fact $1
&lt;/code>&lt;/pre>
&lt;p>步骤：比如给 fact 传递参数 5&lt;/p>
&lt;ol>
&lt;li>如果 5 大于 0 或者大于 1，那么使用 5*fact 函数，且再次调用函数时参数为 5-1&lt;/li>
&lt;li>再次调用函数的时候，不但有 4，还有函数，i.e.5&lt;em>4&lt;/em>fact 函数，直到函数的参数值为 1 或 0&lt;/li>
&lt;/ol>
&lt;h2 id="斐波那契数列1-1-2-3-5-8---每个数都是前两个数之和">斐波那契数列：1 1 2 3 5 8 &amp;hellip;.. # 每个数都是前两个数之和&lt;/h2></description></item><item><title>Docs: 控制结构</title><link>https://desistdaydream.github.io/docs/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/4.Terminal-%E4%B8%8E-Shell/Shell-%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/%E6%8E%A7%E5%88%B6%E7%BB%93%E6%9E%84/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/4.Terminal-%E4%B8%8E-Shell/Shell-%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/%E6%8E%A7%E5%88%B6%E7%BB%93%E6%9E%84/</guid><description/></item><item><title>Docs: 数组</title><link>https://desistdaydream.github.io/docs/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/4.Terminal-%E4%B8%8E-Shell/Shell-%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/%E6%95%B0%E7%BB%84/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/4.Terminal-%E4%B8%8E-Shell/Shell-%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/%E6%95%B0%E7%BB%84/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;p>&lt;strong>Array(数组)&lt;/strong> 也是一种变量，数组中可以存放多个值，每个值都称为该数组的元素。Bash Shell 只支持一维数组（不支持多维数组），初始化时不需要定义数组大小（与 PHP 类似）。&lt;/p>
&lt;p>与大部分编程语言类似，数组元素的下标由 0 开始。&lt;/p>
&lt;p>Shell 数组用括号来表示，元素用&amp;quot;空格&amp;quot;符号分割开，&lt;/p>
&lt;p>定义数组的方式：&lt;code>ArrayName=(Value1 ... ValueN)&lt;/code>&lt;/p>
&lt;h2 id="数组的赋值">数组的赋值&lt;/h2>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#!/bin/bash
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>my_array&lt;span style="color:#f92672">=(&lt;/span>A B &lt;span style="color:#e6db74">&amp;#34;C&amp;#34;&lt;/span> D&lt;span style="color:#f92672">)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>我们也可以使用下标来定义数组:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>array_name&lt;span style="color:#f92672">[&lt;/span>0&lt;span style="color:#f92672">]=&lt;/span>value0
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>array_name&lt;span style="color:#f92672">[&lt;/span>1&lt;span style="color:#f92672">]=&lt;/span>value1
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>array_name&lt;span style="color:#f92672">[&lt;/span>2&lt;span style="color:#f92672">]=&lt;/span>value2
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="数组的引用">数组的引用&lt;/h2>
&lt;p>通过数组的下标来获取数组的值，数组中的第一位下标是 0，第二位下标是 2&amp;hellip;&amp;hellip;以此类推&lt;/p>
&lt;p>引用数组元素值的一般格式是：${array_name[index]} # index 是下标的数字&lt;/p>
&lt;p>实例&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#!/bin/bash
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>my_array&lt;span style="color:#f92672">=(&lt;/span>A B &lt;span style="color:#e6db74">&amp;#34;C&amp;#34;&lt;/span> D&lt;span style="color:#f92672">)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>echo &lt;span style="color:#e6db74">&amp;#34;第一个元素为: &lt;/span>&lt;span style="color:#e6db74">${&lt;/span>my_array[0]&lt;span style="color:#e6db74">}&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>echo &lt;span style="color:#e6db74">&amp;#34;第二个元素为: &lt;/span>&lt;span style="color:#e6db74">${&lt;/span>my_array[1]&lt;span style="color:#e6db74">}&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>echo &lt;span style="color:#e6db74">&amp;#34;第三个元素为: &lt;/span>&lt;span style="color:#e6db74">${&lt;/span>my_array[2]&lt;span style="color:#e6db74">}&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>echo &lt;span style="color:#e6db74">&amp;#34;第四个元素为: &lt;/span>&lt;span style="color:#e6db74">${&lt;/span>my_array[3]&lt;span style="color:#e6db74">}&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>执行脚本，输出结果如下所示：
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>$ chmod +x test.sh
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>$ ./test.sh
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>第一个元素为: A
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>第二个元素为: B
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>第三个元素为: C
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>第四个元素为: D
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="引用数组中指定的元素">引用数组中指定的元素&lt;/h3>
&lt;p>参考 变量与系统环境配置详解 中变量的高级技巧一节，可以通过 ${ } 来截取数组中的元素&lt;/p>
&lt;pre>&lt;code># 该示例通过 ${VARIABLE:START:LENGTH} 方式，将数组左边起第一个元素开始，向右截取到末尾的所有元素，并 echo 出来。
my_arrays=(a b c d)
echo ${my_arrays[@]:1}
b c d
&lt;/code>&lt;/pre>
&lt;h3 id="引用数组中的所有元素">引用数组中的所有元素&lt;/h3>
&lt;p>使用@ 或 * 可以获取数组中的所有元素，例如：&lt;/p>
&lt;pre>&lt;code>my_arrays=(A B C D)
echo &amp;quot;数组的元素为: ${my_arrays[*]}&amp;quot;
数组的元素为: A B C D
echo &amp;quot;数组的元素为: ${my_arrays[@]}&amp;quot;
数组的元素为: A B C D
&lt;/code>&lt;/pre>
&lt;p>Note：&lt;/p>
&lt;ol>
&lt;li>
&lt;ul>
&lt;li>#当变量加上 “” 会当成一串字符串处理.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>@ # 变量加上 “” 依然当做数组处理.&lt;/li>
&lt;li>在没有加上 “” 的情况下 效果是等效的.&lt;/li>
&lt;/ol>
&lt;p>效果如下：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">[&lt;/span>root@centos-8-init scripts&lt;span style="color:#f92672">]&lt;/span>&lt;span style="color:#75715e"># cat array.sh&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#!/bin/bash&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>array&lt;span style="color:#f92672">=(&lt;/span>&lt;span style="color:#e6db74">&amp;#34;li chen hao&amp;#34;&lt;/span> &lt;span style="color:#e6db74">&amp;#34;zhang_na&amp;#34;&lt;/span>&lt;span style="color:#f92672">)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">for&lt;/span> i in &lt;span style="color:#e6db74">${&lt;/span>array[@]&lt;span style="color:#e6db74">}&lt;/span>; &lt;span style="color:#66d9ef">do&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>echo &lt;span style="color:#e6db74">&amp;#34;@符号无双引号:&amp;#34;&lt;/span>&lt;span style="color:#e6db74">${&lt;/span>i&lt;span style="color:#e6db74">}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">done&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>echo ------------
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">for&lt;/span> i in &lt;span style="color:#e6db74">&amp;#34;&lt;/span>&lt;span style="color:#e6db74">${&lt;/span>array[@]&lt;span style="color:#e6db74">}&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>; &lt;span style="color:#66d9ef">do&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>echo &lt;span style="color:#e6db74">&amp;#34;@符号有双引号:&amp;#34;&lt;/span>&lt;span style="color:#e6db74">${&lt;/span>i&lt;span style="color:#e6db74">}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">done&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>echo ------------
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">for&lt;/span> i in &lt;span style="color:#e6db74">${&lt;/span>array[*]&lt;span style="color:#e6db74">}&lt;/span>; &lt;span style="color:#66d9ef">do&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> echo &lt;span style="color:#e6db74">&amp;#34;*符号无双引号:&amp;#34;&lt;/span>&lt;span style="color:#e6db74">${&lt;/span>i&lt;span style="color:#e6db74">}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">done&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>echo ------------
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">for&lt;/span> i in &lt;span style="color:#e6db74">&amp;#34;&lt;/span>&lt;span style="color:#e6db74">${&lt;/span>array[*]&lt;span style="color:#e6db74">}&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>; &lt;span style="color:#66d9ef">do&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> echo &lt;span style="color:#e6db74">&amp;#34;*符号有双引号:&amp;#34;&lt;/span>&lt;span style="color:#e6db74">${&lt;/span>i&lt;span style="color:#e6db74">}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">done&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">[&lt;/span>root@centos-8-init scripts&lt;span style="color:#f92672">]&lt;/span>&lt;span style="color:#75715e"># bash array.sh&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>@符号无双引号:li
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>@符号无双引号:chen
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>@符号无双引号:hao
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>@符号无双引号:zhang_na
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>------------
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>@符号有双引号:li chen hao
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>@符号有双引号:zhang_na
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>------------
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>*符号无双引号:li
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>*符号无双引号:chen
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>*符号无双引号:hao
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>*符号无双引号:zhang_na
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>------------
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>*符号有双引号:li chen hao zhang_na
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="获取数组的长度">获取数组的长度&lt;/h2>
&lt;p>数组的长度分两种情况，一种是数组元素的个数，另一种事数组元素的所有索引号&lt;/p>
&lt;pre>&lt;code>my_arrays=(A B C D)
echo &amp;quot;数组元素个数为: ${#my_arrays[*]}&amp;quot;
数组元素个数为: 4
echo &amp;quot;数组元素个数为: ${#my_arrays[@]}&amp;quot;
数组元素个数为: 4
echo &amp;quot;数组元素的索引号为: ${!my_arrays[@]}&amp;quot;
数组元素的索引号为: 0 1 2 3
&lt;/code>&lt;/pre>
&lt;h2 id="向数组中添加元素">向数组中添加元素&lt;/h2>
&lt;pre>&lt;code># 在数组末尾添加元素
[root@lichenhao ~]# abc=(a b c)
[root@lichenhao ~]# echo ${abc[@]}
a b c
[root@lichenhao ~]# abc+=(d)
[root@lichenhao ~]# echo ${abc[@]}
a b c d
# 向指定 index 位置添加元素
[root@master ~]# arrays=(a b c d)
[root@master ~]# arrays[5]=f
[root@master ~]# echo ${arrays[@]}
a b c d f
[root@master ~]# echo ${!arrays[@]}
0 1 2 3 5
&lt;/code>&lt;/pre>
&lt;h2 id="删除数组中的元素">删除数组中的元素&lt;/h2>
&lt;pre>&lt;code>[root@master ~]# arrays=(a b c d)
[root@master ~]# echo $arrays
a b c d
[root@master ~]# unset arrays[2]
[root@master ~]# echo ${arrays[@]}
a b d
[root@master ~]# echo ${!arrays[@]}
0 1 3
[root@master ~]# arrays+=(c)
[root@master ~]# echo ${!arrays[@]}
0 1 3 4
[root@master ~]# echo ${arrays[@]}
a b d c
[root@master ~]# arrays[2]=c
[root@master ~]# echo ${arrays[@]}
&lt;/code>&lt;/pre>
&lt;p>Note:&lt;/p>
&lt;ol>
&lt;li>某个元素删除后，其余元素的 index 号不变&lt;/li>
&lt;li>如果对删除元素的数组添加新元素，则新元素的 index 号向后递增&lt;/li>
&lt;/ol>
&lt;h1 id="数组的应用实例">数组的应用实例&lt;/h1>
&lt;h2 id="对数组中的元素排序">对数组中的元素排序&lt;/h2>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># 原始数组：B=(20 9 01 5 11 4 6 14 12 14 0808)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>b&lt;span style="color:#f92672">=(&lt;/span>&lt;span style="color:#66d9ef">$(&lt;/span>printf &lt;span style="color:#e6db74">&amp;#39;%s\n&amp;#39;&lt;/span> &lt;span style="color:#e6db74">&amp;#34;&lt;/span>&lt;span style="color:#e6db74">${&lt;/span>B[@]&lt;span style="color:#e6db74">}&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>|sort -n&lt;span style="color:#66d9ef">)&lt;/span>&lt;span style="color:#f92672">)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># 排序后的数组：b=(01 4 5 6 9 11 12 14 14 20 0808)&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="数组的遍历在-for-循环中的应用">数组的遍历，在 for 循环中的应用&lt;/h2>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#!/bin/bash
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#75715e">#&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>b&lt;span style="color:#f92672">=(&lt;/span>&lt;span style="color:#ae81ff">01&lt;/span> &lt;span style="color:#ae81ff">4&lt;/span> &lt;span style="color:#ae81ff">5&lt;/span> &lt;span style="color:#ae81ff">06&lt;/span> &lt;span style="color:#ae81ff">9&lt;/span> &lt;span style="color:#ae81ff">11&lt;/span> &lt;span style="color:#ae81ff">12&lt;/span> &lt;span style="color:#ae81ff">14&lt;/span> &lt;span style="color:#ae81ff">14&lt;/span> &lt;span style="color:#ae81ff">20&lt;/span> 0808&lt;span style="color:#f92672">)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>let max&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">${#&lt;/span>b[@]&lt;span style="color:#e6db74">}&lt;/span>-1
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">for&lt;/span> Subscript in &lt;span style="color:#e6db74">`&lt;/span>seq &lt;span style="color:#ae81ff">0&lt;/span> &lt;span style="color:#e6db74">${&lt;/span>max&lt;span style="color:#e6db74">}&lt;/span>&lt;span style="color:#e6db74">`&lt;/span>;&lt;span style="color:#66d9ef">do&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> echo &lt;span style="color:#e6db74">${&lt;/span>b[&lt;span style="color:#e6db74">${&lt;/span>Subscript&lt;span style="color:#e6db74">}&lt;/span>]&lt;span style="color:#e6db74">}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">done&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>可以遍历数组并输出数组中每一个值
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div></description></item></channel></rss>