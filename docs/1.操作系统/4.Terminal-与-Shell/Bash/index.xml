<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>断念梦 – Bash</title><link>https://desistdaydream.github.io/docs/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/4.Terminal-%E4%B8%8E-Shell/Bash/</link><description>Recent content in Bash on 断念梦</description><generator>Hugo -- gohugo.io</generator><atom:link href="https://desistdaydream.github.io/docs/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/4.Terminal-%E4%B8%8E-Shell/Bash/index.xml" rel="self" type="application/rss+xml"/><item><title>Docs: Bash</title><link>https://desistdaydream.github.io/docs/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/4.Terminal-%E4%B8%8E-Shell/Bash/Bash/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/4.Terminal-%E4%B8%8E-Shell/Bash/Bash/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://www.man7.org/linux/man-pages/man1/bash.1.html#SHELL_BUILTIN_COMMANDS">Manual(手册)，bash(1)-Shell 内置命令&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;h1 id="在-bash-中执行命令">在 Bash 中执行命令&lt;/h1>
&lt;h2 id="source-程序">source 程序&lt;/h2>
&lt;p>source 程序可以在当前 Shell 环境中从指定文件中读取并执行命令&lt;/p>
&lt;p>注意：该命令可以使当前环境的配置文件在此环境中立刻生效而不用重启机器&lt;/p>
&lt;p>作用：&lt;/p>
&lt;ul>
&lt;li>这个命令其实只是简单地读取脚本里面的语句依次在当前 shell 里面执行，没有建立新的子 shell。那么脚本里面所有新建、改变变量的语句都会保存在当前 shell 里面&lt;/li>
&lt;li>source 命令(从 C Shell 而来)是 bash shell 的内置命令。&lt;/li>
&lt;li>source(或点)命令通常用于重新执行刚修改的初始化文档。&lt;/li>
&lt;/ul>
&lt;p>应用实例：一般用于写在 shell 脚本中，通过 source 执行外部文件中是变量赋值，这样不建立子 shell 的话，外部文件中的变量就可以在该脚本启动的 shell 中引用&lt;/p>
&lt;p>&lt;strong>source [选项] FILENAME&lt;/strong> # 使环境变量立刻生效&lt;/p>
&lt;p>在当前 bash 环境下读取并执行 FileName 中的命令。该 filename 文件可以“无执行权限”&lt;/p>
&lt;p>EXAMPLE：&lt;/p>
&lt;ul>
&lt;li>source openrc admin admin # 运行 openrc 这个配置文件，把第一个参数 admin 和第二个参数 admin 送给 openrc 文件中的$1 和$2&lt;/li>
&lt;li>source .bash_profile #&lt;/li>
&lt;/ul>
&lt;p>sh 和 bash 程序：&lt;/p>
&lt;p>实际上，执行 sh 或者 bash 就是相当于打开新的子 shell，并在新的 shell 中执行后续的命令。只不过 bash 与 sh 是不同的 shell，内置的功能有一些细微的区别。&lt;/p>
&lt;p>作用:&lt;/p>
&lt;ul>
&lt;li>开启一个新的 shell，读取并执行 File 中的命令。该 file 可以“无执行权限”&lt;/li>
&lt;li>注：两者在执行文件时的不同，是分别用自己的 shell 来跑文件。
&lt;ul>
&lt;li>sh 使用“-n”选项进行 shell 脚本的语法检查，使用“-x”选项实现 shell 脚本逐条语句的跟踪&lt;/li>
&lt;li>可以巧妙地利用 shell 的内置变量增强“-x”选项的输出信息等。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>bash [OPTIONS] [File]&lt;/strong> #&lt;/p>
&lt;p>OPTIONS&lt;/p>
&lt;ul>
&lt;li>-n # 对指定文件进行语法检查&lt;/li>
&lt;li>-x # 打印出执行脚本的过程&lt;/li>
&lt;/ul>
&lt;h2 id="-的命令用法">./ 的命令用法&lt;/h2>
&lt;p>作用:&lt;/p>
&lt;ul>
&lt;li>打开一个子 shell 来读取并执行 FileName 中命令。&lt;/li>
&lt;li>注：运行一个 shell 脚本时会启动另一个命令解释器.&lt;/li>
&lt;li>每个 shell 脚本有效地运行在父 shell(parent shell)的一个子进程里. 这个父 shell 是指在一个控制终端或在一个 xterm 窗口中给你命令指示符的进程.shell 脚本也可以启动他自已的子进程. 这些子 shell(即子进程)使脚本并行地，有效率地地同时运行脚本内的多个子任务.&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>Syntax(语法)&lt;/strong>&lt;/p>
&lt;p>&lt;strong>./FileName&lt;/strong>&lt;/p>
&lt;h1 id="命令行补全">命令行补全&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Command-line_completion">Wiki,CommandLineCompletion&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>&lt;strong>Command Line Completion(命令行补全)&lt;/strong> 也称为 &lt;strong>tab completion&lt;/strong>，是命令行解释器的常见功能，在命令行中的程序，可以自动填充部分需要手动输入的命令。&lt;/p>
&lt;p>由 bash-completion 程序实现&lt;/p>
&lt;h2 id="关联文件与配置">关联文件与配置&lt;/h2>
&lt;p>&lt;strong>/etc/bash_completion.d/&lt;/strong> #
&lt;strong>/usr/share/bash-completion/completions/&lt;/strong> # 各种程序补全功能所需文件的保存目录。&lt;/p></description></item><item><title>Docs: Bash 变量</title><link>https://desistdaydream.github.io/docs/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/4.Terminal-%E4%B8%8E-Shell/Bash/Bash-%E5%8F%98%E9%87%8F/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/4.Terminal-%E4%B8%8E-Shell/Bash/Bash-%E5%8F%98%E9%87%8F/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://www.man7.org/linux/man-pages/man1/bash.1.html#PARAMETERS">Manual(手册),bash(1)-形参&lt;/a>-Shell 变量&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>环境变量是对当前环境起作用的变量，在日常操作中，我们最常用的就是 bash 这个 shell。&lt;/p>
&lt;h1 id="bash-自带的变量">Bash 自带的变量&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://www.man7.org/linux/man-pages/man1/bash.1.html#PARAMETERS">Manual(手册),bash(1)，形参-&lt;/a>Shell 变量&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>&lt;strong>EDITOR=STRING&lt;/strong> # 当 Bash 需要调用编辑器时，使用该变量指定的编辑器。
&lt;strong>IFS=STRING&lt;/strong> # (Internal Field Separator)输入字段分隔符。&lt;code>默认值：IFS 包含空格、制表符和回车&lt;/code>。
Bash 会根据 IFS 中定义的字符来进行字符串拆分。效果如下：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>~&lt;span style="color:#f92672">]&lt;/span>&lt;span style="color:#75715e"># map=(a,b c)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>~&lt;span style="color:#f92672">]&lt;/span>&lt;span style="color:#75715e"># echo ${map[0]}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>a,b
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>~&lt;span style="color:#f92672">]&lt;/span>&lt;span style="color:#75715e"># IFS=, &amp;amp;&amp;amp; echo ${map[0]}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>a b
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;strong>PATH=&amp;lt;STRING&amp;gt;&lt;/strong> # 命令的搜索路径。以 &lt;code>:&lt;/code> 分隔的目录列表，bash 执行命令时将会从 $PATH 中查找用户输入的命令，以便执行这些命令，如果在 $PATH 中无法找到，则无法执行。&lt;code>默认值：取决于操作系统&lt;/code>，通常都是 &lt;code>/usr/local/bin:/usr/local/sbin:/usr/bin:/usr/sbin:/bin:/sbin&lt;/code>&lt;/p>
&lt;ul>
&lt;li>在 bash 的源码(&lt;code>[./config-top.h](https://git.savannah.gnu.org/cgit/bash.git/tree/config-top.h)&lt;/code>)中，我们可以看到 PATH 变量的默认值由 DEFAULT_PATH_VALUE 定义：&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-c" data-lang="c">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">/* The default value of the PATH variable. */&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#ifndef DEFAULT_PATH_VALUE
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#define DEFAULT_PATH_VALUE \
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> &amp;#34;/usr/local/bin:/usr/local/sbin:/usr/bin:/usr/sbin:/bin:/sbin:.&amp;#34;
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#endif
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ul>
&lt;li>我们也可以在系统中通过 &lt;code>env -i bash -c 'echo &amp;quot;$PATH&amp;quot;'&lt;/code> 命令获取 bash 的 $PATH 变量的默认值&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>TMOUT=INT&lt;/strong> # Bash 在指定 INT 秒后未操作，则自动登出。&lt;code>默认值：空&lt;/code>&lt;/p>
&lt;ul>
&lt;li>如果设置为大于零的值，则 TMOUT 被视为读取内置的默认超时。当输入来自终端时，如果输入在指定的 X 秒后仍未到达，则 select 命令终止。在交互式 shell 中，该值被解释为发出主提示后等待一行输入的秒数。如果完整的输入行未到达，则 Bash 在等待该秒数后终止。&lt;/li>
&lt;/ul>
&lt;h2 id="历史记录相关变量">历史记录相关变量&lt;/h2>
&lt;p>&lt;strong>HISTTIMEFORMAT=STRING&lt;/strong> # 历史记录的格式
&lt;strong>HISTSIZE=INT&lt;/strong> # 历史记录可以保留的最大命令数
&lt;strong>HISTFILESIZE=INT&lt;/strong> # 历史记录可以保留的最大行数
&lt;strong>HISTCONTROL=STRING&lt;/strong> #&lt;/p>
&lt;h2 id="提示符相关变量">提示符相关变量&lt;/h2>
&lt;h3 id="ps1默认提示符">PS1——默认提示符&lt;/h3>
&lt;p>如下所示，可以通过修改 Linux 下的默认提示符，使其更加实用。在下面的例子中，默认的 PS1 的值是“\s-\v$”,显示出了 shell 的名称的版本。我们通过修改，可以使其显示用户名、主机名和当前工作目录。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>-bash-3.2$ export PS1&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;\u@\h \w&amp;gt; &amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>ramesh@dev-db ~&amp;gt; cd /etc/mail
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>ramesh@dev-db /etc/mail&amp;gt;
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>[注: 提示符修改为 &amp;ldquo;username@hostname current-dir&amp;gt;的形式]&lt;/p>
&lt;p>本例中 PS1 使用的一些代码如下：
&lt;strong>\u&lt;/strong> # 用户名
&lt;strong>\h&lt;/strong> # 主机名 建议在\h 值之后有一个空格。从个人角度来讲，使用这个空格可以增加一定的可读性。
&lt;strong>\w&lt;/strong> # 当前目录的完整路径。请注意当你在主目录下的时候，如上面所示只会显示～&lt;/p>
&lt;p>EXAMPLE&lt;/p>
&lt;ul>
&lt;li>&lt;strong>export PS1=&amp;rdquo;[[\e[34;1m]\u@[\e[0m][\e[32;1m]\H[\e[0m] [\e[31;1m]\w[\e[0m]]\$ &amp;ldquo;&lt;/strong> # 好看的提示符样式
&lt;ul>
&lt;li>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/ic2gz0/1628044442278-702aab5e-f50e-40f9-924a-e00528d1dbff.png" alt="image.png">&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h3 id="ps2再谈提示符">PS2——再谈提示符&lt;/h3>
&lt;p>一个非常长的命令可以通过在末尾加“\”使其分行显示。多行命令的默认提示符是“&amp;gt;”。 我们可以通过修改 PS2 ，将提示符修改为&amp;quot;ABC&amp;rdquo; 。&lt;/p>
&lt;pre>&lt;code>[root@lichenhao ~]# ls \
&amp;gt; ^C
[root@lichenhao ~]# PS2=&amp;quot;ABC&amp;quot;
[root@lichenhao ~]# ls \
ABC^C
&lt;/code>&lt;/pre>
&lt;p>当用“\”使长命令分行显示，我发现非常易读。当然我也见过有的人不喜欢分行显示命令&lt;/p>
&lt;h3 id="ps3--shell-脚本中使用-select-时的提示符">PS3 # Shell 脚本中使用 select 时的提示符&lt;/h3>
&lt;p>你可以像下面示范的那样，用环境变量 PS3 定制 shell 脚本的 select 提示：&lt;/p>
&lt;p>不使用 PS3 的脚本输出:&lt;/p>
&lt;p>cat ps3.sh&lt;/p>
&lt;p>执行脚本如下==&amp;gt;&lt;/p>
&lt;p>[注: 缺省的提示符是 #?]&lt;/p>
&lt;p>使用 PS3 的脚本输出：&lt;/p>
&lt;p>加了一句提示脚本,更加的友好了&lt;/p>
&lt;h3 id="ps4--ps4-set--x用来修改跟踪输出的前缀">PS4 # PS4-“set -x&amp;quot;用来修改跟踪输出的前缀&lt;/h3>
&lt;p>如果你像下面那样在调试模式下的脚本中，PS4 环境变量可以定制提示信息：&lt;/p>
&lt;p>没有设置 PS4 时的 shell 脚本输出:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">[&lt;/span>root@localhost functions&lt;span style="color:#f92672">]&lt;/span>&lt;span style="color:#75715e"># cat ps4.sh&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>set -x
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>echo &lt;span style="color:#e6db74">&amp;#34;PS4 demo script&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>ls -l /root/|wc -l
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>[注: 当使用 sex -x 跟踪输出时的提示符为 ++]&lt;/p>
&lt;p>设置 PS4 后的脚本输出:&lt;/p>
&lt;p>PS4 在 ps.sh 中定义了下面两个变量&lt;/p>
&lt;p>o $0 显示当前的脚本名&lt;/p>
&lt;p>o $LINENO 显示的当前的行号&lt;/p>
&lt;p>在 ps4.sh 脚本最顶层加一行这个==========&amp;gt;&lt;/p>
&lt;p>输出的效果如下===&amp;gt;&lt;/p>
&lt;p>如下图所示效果==&amp;gt;&lt;/p>
&lt;p>[注: 使用 PS4 后使 &amp;ldquo;{script-name}.{line-number}+&amp;rdquo; 成为 set –x 的命令提示符]&lt;/p></description></item><item><title>Docs: Bash 操作历史记录</title><link>https://desistdaydream.github.io/docs/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/4.Terminal-%E4%B8%8E-Shell/Bash/Bash-%E6%93%8D%E4%BD%9C%E5%8E%86%E5%8F%B2%E8%AE%B0%E5%BD%95/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/4.Terminal-%E4%B8%8E-Shell/Bash/Bash-%E6%93%8D%E4%BD%9C%E5%8E%86%E5%8F%B2%E8%AE%B0%E5%BD%95/</guid><description>
&lt;h1 id="history-工具">history 工具&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://www.man7.org/linux/man-pages/man3/history.3.html">Manual(手册),history&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://blog.csdn.net/m0_38020436/article/details/78730631">https://blog.csdn.net/m0_38020436/article/details/78730631&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://blog.csdn.net/sz_bdqn/article/details/46527021">https://blog.csdn.net/sz_bdqn/article/details/46527021&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>history 工具可以通过如下几个 Bash 的环境变量来配置运行方式&lt;/p>
&lt;ul>
&lt;li>&lt;strong>HISTTIMEFORMAT&lt;/strong> # 历史记录的格式&lt;/li>
&lt;li>&lt;strong>HISTSIZE&lt;/strong> # 历史记录可以保留的最大命令数&lt;/li>
&lt;li>&lt;strong>HISTFILESIZE&lt;/strong> # 历史记录可以保留的最大行数&lt;/li>
&lt;li>&lt;strong>HISTCONTROL&lt;/strong> #&lt;/li>
&lt;/ul>
&lt;h2 id="应用示例">应用示例&lt;/h2>
&lt;ul>
&lt;li>export HISTTIMEFORMAT=&amp;quot;%Y-%m-%d:%H-%M-%S:&lt;code>whoami&lt;/code>: &amp;quot;&lt;/li>
&lt;li>持久化&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span> cat &amp;gt; /etc/profile.d/custom_ops.sh &lt;span style="color:#e6db74">&amp;lt;&amp;lt;END
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">export HISTTIMEFORMAT=&amp;#34;%Y-%m-%d %H:%M:%S `whoami` &amp;#34;
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">END&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h1 id="谁动了我的主机-之活用-history-命令">谁动了我的主机? 之活用 History 命令&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="http://lab.xmirror.cn/2017/05/26/sdlwdzj/">http://lab.xmirror.cn/2017/05/26/sdlwdzj/&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>Linux 系统下可通过 history 命令查看用户所有的历史操作记录，在安全应急响应中起着非常重要的作用，但在未进行附加配置情况下，history 命令只能查看用户历史操作记录，并不能区分用户以及操作时间，不便于审计分析。&lt;/p>
&lt;p>当然，一些不好的操作习惯也可能通过命令历史泄露敏感信息。&lt;/p>
&lt;p>下面我们来介绍如何让 history 日志记录更细化，更便于我们审计分析。&lt;/p>
&lt;h3 id="1命令历史记录中加时间">1、命令历史记录中加时间&lt;/h3>
&lt;p>默认情况下如下图所示，没有命令执行时间，不利于审计分析。
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/ieek6o/1616165148137-f9789cc5-18b7-4fef-9319-70bcf57795e7.jpeg" alt="">
通过设置 export HISTTIMEFORMAT=&amp;rsquo;%F %T &amp;lsquo;，让历史记录中带上命令执行时间。&lt;/p>
&lt;p>注意”%T”和后面的”’”之间有空格，不然查看历史记录的时候，时间和命令之间没有分割。&lt;/p>
&lt;p>要一劳永逸，这个配置可以写在/etc/profile 中，当然如果要对指定用户做配置，这个配置可以写在/home/$USER/.bash_profile 中。&lt;/p>
&lt;p>本文将以/etc/profile 为例进行演示。
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/ieek6o/1616165148161-a02cf695-ebc3-4678-83bf-0dbb6a605411.jpeg" alt="">
要使配置立即生效请执行 source /etc/profile，我们再查看 history 记录，可以看到记录中带上了命令执行时间。
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/ieek6o/1616165148125-d672b6e4-155b-43e0-90cf-4c34f4b15fd7.jpeg" alt="">
如果想要实现更细化的记录，比如登陆过系统的用户、IP 地址、操作命令以及操作时间一一对应，可以通过在/etc/profile 里面加入以下代码实现&lt;/p>
&lt;p>export HISTTIMEFORMAT=&amp;quot;%F %T&lt;code>who -u am i 2&amp;gt;/dev/null| awk '{print $NF}'|sed -e 's/[()]//g'whoami&lt;/code> &amp;ldquo;，注意空格都是必须的。
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/ieek6o/1616165148147-39797dc0-8f2b-4481-8a11-521ad0d3be06.jpeg" alt="">
修改/etc/profile 并加载后，history 记录如下，时间、IP、用户及执行的命令都一一对应。&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/ieek6o/1616165148143-0955f121-58ad-4cc4-a350-c2103b8cb990.jpeg" alt="">&lt;/p>
&lt;p>通过以上配置，我们基本上可以满足日常的审计工作了，但了解系统的朋友应该很容易看出来，这种方法只是设置了环境变量，攻击者 unset 掉这个环境变量，或者直接删除命令历史，对于安全应急来说，这无疑是一个灾难。&lt;/p>
&lt;p>针对这样的问题，我们应该如何应对，下面才是我们今天的重点，通过修改 bash 源码，让 history 记录通过 syslog 发送到远程 logserver 中，大大增加了攻击者对 history 记录完整性破坏的难度。&lt;/p>
&lt;h3 id="2修改-bash-源码支持-syslog-记录">2、修改 bash 源码，支持 syslog 记录&lt;/h3>
&lt;p>首先下载 bash 源码，可以从 gnu.org 下载，这里不做详细说明了，系统需要安装 gcc 等编译环境。我们用 bash4.4 版本做演示。&lt;/p>
&lt;p>修改源码：bashhist.c
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/ieek6o/1616165148122-2898b5a5-b861-491b-ac1a-201aa6403243.jpeg" alt="">
修改源码 config-top.h，取消/#define SYSLOG_HISTORY/这行的注释
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/ieek6o/1616165148162-6b252c51-d8d8-4f98-9ad2-a67e574db7f6.jpeg" alt="">
编译安装，编译过程不做详细说明，本文中使用的编译参数为： ./configure &amp;ndash;prefix=/usr/local/bash，安装成功后对应目录如下：
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/ieek6o/1616165148144-a4bcb15d-3f39-477d-bd7f-1167d58f615d.jpeg" alt="">
此时可以修改/etc/passwd 中用户 shell 环境，也可以用编译好的文件直接替换原有的 bash 二进制文件，但最好对原文件做好备份。&lt;/p>
&lt;p>替换时要注意两点:&lt;/p>
&lt;blockquote>
&lt;p>1、一定要给可执行权限，默认是有的，不过有时候下载到 windows 系统后，再上传就没有可执行权限了，这里一定要确定，不然你会后悔的；2、替换时原 bash 被占用，可以修改原用户的 bash 环境后再进行替换。&lt;/p>
&lt;/blockquote>
&lt;p>查看效果，我们发现 history 记录已经写到了/var/log/message 中。
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/ieek6o/1616165148170-cb8d9280-1422-4701-95f3-2cdd4da96b59.jpeg" alt="">
如果要写到远程 logserver，需要配置 syslog 服务，具体配置这里不做详细讲解，大家自己研究，发送到远端 logserver 效果如下图所示。
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/ieek6o/1616165148152-c4072293-34eb-489d-ba93-70e05632e218.jpeg" alt="">
通过以上手段，可以有效保证 history 记录的完整性，避免攻击者登录系统后，通过取消环境变量、删除 history 记录等方式抹掉操作行为，为安全审计、应急响应等提供了完整的原始数据。&lt;/p>
&lt;h1 id="linux-系统监控记录用户操作轨迹谁动过服务器">linux 系统监控：记录用户操作轨迹，谁动过服务器&lt;/h1>
&lt;blockquote>
&lt;p>&lt;strong>参考：&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://blog.51cto.com/ganbing/2053636">https://blog.51cto.com/ganbing/2053636&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>&lt;strong>1、前言&lt;/strong>&lt;/p>
&lt;p>我们在实际工作当中，都碰到过误操作、误删除、误修改过配置文件等等事件。对于没有堡垒机的公司来说，要在 linux 系统上深究到底谁做过配置文件的修改、做过误删除是很头疼的事情，特别是遇到删库跑路的事件，更头大了。当然你可以通过 history 来查看历史命令记录，如果把 history 记录涂抹掉了，是不是啥也看不到了，如果你想查看在某个时间段到底是谁通过 vim 编辑过某个文件呢？&lt;/p>
&lt;p>那么，有什么办法可以看见这些操作呢，答案是一定有的，具体怎么实现呢，linux script 命令正有如此强大的功能，可以满足我们的需求，script 可以记录终端会话，只要是 linux6.3 以上的系统，都会自带 script 命令，下面我用 centos 7 系统来测试一下。&lt;/p>
&lt;p>&lt;strong>2、配置&lt;/strong>&lt;/p>
&lt;p>&lt;strong>2.1 验证 script 命令（我这里是有的）&lt;/strong>&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">[&lt;/span>root@localhost ~&lt;span style="color:#f92672">]&lt;/span>&lt;span style="color:#75715e"># which script&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>/usr/bin/script
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;strong>2.2 配置 profile 文件，在末尾添加如下内容：&lt;/strong>&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">[&lt;/span>root@localhost ~&lt;span style="color:#f92672">]&lt;/span>&lt;span style="color:#75715e"># vim /etc/profile&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">if&lt;/span> &lt;span style="color:#f92672">[&lt;/span> $UID -ge &lt;span style="color:#ae81ff">0&lt;/span> &lt;span style="color:#f92672">]&lt;/span>; &lt;span style="color:#66d9ef">then&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> exec /usr/bin/script -t 2&amp;gt;/var/log/script/$USER-$UID-&lt;span style="color:#e6db74">`&lt;/span>date +%Y%m%d%H%M&lt;span style="color:#e6db74">`&lt;/span>.date -a -f -q /var/log/script/$USER-$UID-&lt;span style="color:#e6db74">`&lt;/span>date +%Y%m%d%H%M&lt;span style="color:#e6db74">`&lt;/span>.log
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">fi&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>  -t　　　 指明输出录制的时间数据
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>    -f     如果需要在输出到日志文件的同时，也可以查看日志文件的内容，可以使用 -f 参数。PS:可以用于教学,两个命令行接-f可以实时演示
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>    -a     输出录制的文件，在现有内容上追加新的内容
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>    -q     可以使script命令以静默模式运行
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>如下图所示：&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/ieek6o/1647416324069-ae3a5928-f2d8-417c-a761-082d0c58a7fd.png" alt="image.png">&lt;/p>
&lt;p>说明：&lt;/p>
&lt;p>用户登录执行的操作都会记录到/var/log/script/*.log  里（保存日志的目录根据你自己定义），我们可以通过 more、vi 等命令查看目录里的日志。&lt;/p>
&lt;p>注意：&lt;/p>
&lt;ul>
&lt;li>我这里把用户 ID 大于 0 的都记录下来了，你可以重新登录用户，随便操作一些命令，查看生成的文件。&lt;/li>
&lt;li>root 用户的 ID 为 0，新建普通用户的 UID 是从 500 开始的(通过 cat /etc/password 可以查看用户的 UID)，如果你不想记录 root 用户的操作，你把 if 里面的值改成 500：  if [ $UID - ge 500 ];&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>2.3 创建目录、赋予权限&lt;/strong>&lt;/p>
&lt;p>你是不是以为写了这条 if 语句在/etc/profile 文件中就完事了，目录都没创建呢：&lt;/p>
&lt;p>&lt;strong>2.4 使环境生效&lt;/strong>&lt;/p>
&lt;p>3、验证&lt;/p>
&lt;p>好了，你可以退出 linux 终端，在重新登录一下，然后随便敲几个命令来看看。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">[&lt;/span>root@localhost ~&lt;span style="color:#f92672">]&lt;/span>&lt;span style="color:#75715e"># cd /var/log/script/&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">[&lt;/span>root@localhost script&lt;span style="color:#f92672">]&lt;/span>&lt;span style="color:#75715e"># ll&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>total &lt;span style="color:#ae81ff">16&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>-rw-r--r-- &lt;span style="color:#ae81ff">1&lt;/span> root root &lt;span style="color:#ae81ff">68&lt;/span> Dec &lt;span style="color:#ae81ff">22&lt;/span> 15:46 root-0-201712221545.date
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>-rw-r--r-- &lt;span style="color:#ae81ff">1&lt;/span> root root &lt;span style="color:#ae81ff">111&lt;/span> Dec &lt;span style="color:#ae81ff">22&lt;/span> 15:46 root-0-201712221545.log
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>-rw-r--r-- &lt;span style="color:#ae81ff">1&lt;/span> root root &lt;span style="color:#ae81ff">0&lt;/span> Dec &lt;span style="color:#ae81ff">22&lt;/span> 15:46 root-0-201712221546.date
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>-rw-r--r-- &lt;span style="color:#ae81ff">1&lt;/span> root root &lt;span style="color:#ae81ff">5693&lt;/span> Dec &lt;span style="color:#ae81ff">22&lt;/span> 15:46 root-0-201712221546.log
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>从上图可以看到，在/var/log/script 目录中，已经产生了 log 和 data 为后缀的文件，并且还看到了 root 用户和 UID 号 0。&lt;/p>
&lt;p>.log：记录了操作&lt;/p>
&lt;p>.data：可以回放操作&lt;/p>
&lt;p>我们用 scriptreplay 来回放一下操作，看下效果如何：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">[&lt;/span>root@localhost script&lt;span style="color:#f92672">]&lt;/span>&lt;span style="color:#75715e"># scriptreplay root-0-201712221545.date root-0-201712221545.log&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;strong>注意：&lt;/strong> 先指定“时间文件 .data”，然后是“命令文件 .log”，不要颠倒了。&lt;/p>
&lt;p>以上就完也了记录用户的所有操作，并且还可以随时查看，相当于有回放功能，像录像一样，以后定位是谁的问题就好找原因了。&lt;/p></description></item><item><title>Docs: Bash 快捷键</title><link>https://desistdaydream.github.io/docs/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/4.Terminal-%E4%B8%8E-Shell/Bash/Bash-%E5%BF%AB%E6%8D%B7%E9%94%AE/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/4.Terminal-%E4%B8%8E-Shell/Bash/Bash-%E5%BF%AB%E6%8D%B7%E9%94%AE/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;p>快速编辑命令高效率输入&lt;/p>
&lt;p>并非大型软件或者 IDE 才有快捷键,shell 也有,如果能够熟练使用快捷键,做起事情来且不事半功倍。&lt;/p>
&lt;p>网上流传的快捷键在 xshell 下可能和菜单的快捷键 alt 啥的冲突&lt;/p>
&lt;p>我只说下 xshell 下和用的最多的&lt;/p>
&lt;p>光标部分总的来说就是移动,最常用的就四个:&lt;/p>
&lt;p>移动到行首和行尾部&lt;/p>
&lt;p>ctrl + a 行首&lt;/p>
&lt;p>ctrl + e 行末&lt;/p>
&lt;p>然后单词移动,xshell 下 alt 不起作用,esc+b/f 可以前后&lt;/p>
&lt;p>但是 ctrl+左/右也可以,所以建议单词之间移动使用:&lt;/p>
&lt;p>ctrl + ← 光标移动到前一个单词开头&lt;/p>
&lt;p>ctrl + → 光标移动到后一个单词结尾&lt;/p>
&lt;p>配合下面的 ctrl+w 或者 esc+d 来删除前后单词&lt;/p>
&lt;p>删除部分&lt;/p>
&lt;p>ctrl + u 删除当前光标左边所有内容&lt;/p>
&lt;p>ctrl + k 删除当前光标右边所有内容&lt;/p>
&lt;p>ctrl + w 删除当前光标到左边最近的一个空格(通常用来删除一个单词)&lt;/p>
&lt;p>esc + d 删除当前光标到右边最近的一个空格(通常用来删除一个单词)&lt;/p>
&lt;p>ctrl + y 粘贴上面删除的部分&lt;/p>
&lt;p>编辑部分&lt;/p>
&lt;p>esc + t 互换相邻的两个单词&lt;/p>
&lt;p>esc + u 大写当前单词&lt;/p>
&lt;p>esc + l 小写当前单词&lt;/p>
&lt;p>esc + c 大写当前字母&lt;/p>
&lt;p>esc + . 当前位置插入上一条命令的最后一个参数&lt;/p>
&lt;p>另外熟悉 vim 的话可以把 bash 的默认编辑器设置为 vim,set -o vi 后按下 esc 进入命令模式和 vim 一样操作&lt;/p>
&lt;p>默认的编辑器是 emacs,如果不是请 set -o emacs 设置回来&lt;/p>
&lt;p>还有关于感叹号的妙用,&lt;/p>
&lt;p>!xyz:3 表示上一条 xyz 命令的第三个参数&lt;/p></description></item><item><title>Docs: exec,xargs,管道符等组合命令</title><link>https://desistdaydream.github.io/docs/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/4.Terminal-%E4%B8%8E-Shell/Bash/execxargs%E7%AE%A1%E9%81%93%E7%AC%A6%E7%AD%89%E7%BB%84%E5%90%88%E5%91%BD%E4%BB%A4/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/4.Terminal-%E4%B8%8E-Shell/Bash/execxargs%E7%AE%A1%E9%81%93%E7%AC%A6%E7%AD%89%E7%BB%84%E5%90%88%E5%91%BD%E4%BB%A4/</guid><description>
&lt;h1 id="-管道符">| (管道符)&lt;/h1>
&lt;p>把 &lt;code>|&lt;/code> 前面的标准输出内容当作 &lt;code>|&lt;/code> 后面的标准输入内容&lt;/p>
&lt;p>EXAMPLE&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/sl7f9m/1616165959227-38b8c228-113d-4a87-a335-22560fdc396b.jpeg" alt="">&lt;/p>
&lt;ul>
&lt;li>echo “&amp;ndash;help” | cat # 把&amp;ndash;help 当作 cat 的标准输入输出到屏幕上，如图所示，注意与 xargs 应用实例 a 的区别&lt;/li>
&lt;/ul>
&lt;h1 id="exec">exec&lt;/h1>
&lt;h2 id="syntax语法">Syntax(语法)&lt;/h2>
&lt;p>exec [-cl] [-a name] [COMMAND [ARGUMENTS&amp;hellip;]]&lt;/p>
&lt;p>如果指定了 command，它将替换 shell。 没有创建新进程。 参数成为命令的参数。 如果提供了-l 选项，则 shell 会在传递给 command 的第 0 个参数的开头放置一个破折号。 这是 login(1) 的作用。 -c 选项导致命令在空环境中执行。 如果提供了-a，则 shell 将 name 作为第 0 个参数传递给执行的命令。 如果由于某种原因无法执行命令，则会退出非交互式 shell，除非启用了 shell 选项 execfail，在这种情况下它将返回失败。 如果无法执行文件，则交互式 shell 将返回失败。 如果未指定 command，则任何重定向在当前 shell 中生效，返回状态为 0.如果存在重定向错误，则返回状态为 1&lt;/p>
&lt;p>通过 exec 来执行的命令会顶替掉当前 shell 的进程，但是进程 PID 保持不变&lt;/p>
&lt;h1 id="xargs">xargs&lt;/h1>
&lt;p>xargs 可以把从 &lt;code>|&lt;/code> 前面获得的输入内容，当成 xargs 后面的命令的选项或者参数来执行&lt;/p>
&lt;h2 id="syntax语法-1">Syntax(语法)&lt;/h2>
&lt;p>&lt;strong>xargs [OPTIONS] COMMAND&lt;/strong> # 不指定 COMMAND 则默认输出到屏幕上&lt;/p>
&lt;p>OPTIONS：&lt;/p>
&lt;ul>
&lt;li>-d 指定获得输入内容的分隔符，默认分隔符为空白或换行&lt;/li>
&lt;li>-n 每次传递 NUM 个字符给|后的内容&lt;/li>
&lt;/ul>
&lt;h2 id="example">EXAMPLE&lt;/h2>
&lt;ul>
&lt;li>echo “&amp;ndash;help” | xargs cat # 把&amp;ndash;help 当作 cat 的选项或者参数，如图所示，注意与管道符的应用实例 a 中的区别&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/sl7f9m/1616165959237-c4a1a831-c6a0-4c52-ba6f-9f071cb59ba3.jpeg" alt="">&lt;/p>
&lt;ul>
&lt;li>ls /var/run/docker/netns | xargs -I {} nsenter &amp;ndash;net=/var/run/docker/netns/{} ip addr # 遍历 netns 目录下的所有文件,通过 xargs 命令把所有文件名传递给后面命令，作为后面命令的参数&lt;/li>
&lt;/ul></description></item><item><title>Docs: Job(任务)控制</title><link>https://desistdaydream.github.io/docs/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/4.Terminal-%E4%B8%8E-Shell/Bash/Job%E4%BB%BB%E5%8A%A1%E6%8E%A7%E5%88%B6/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/4.Terminal-%E4%B8%8E-Shell/Bash/Job%E4%BB%BB%E5%8A%A1%E6%8E%A7%E5%88%B6/</guid><description>
&lt;h2 id="job-control--在同一个-shell-下执行多个任务的控制">Job Control # 在同一个 Shell 下，执行多个任务的控制&lt;/h2>
&lt;p>在前台执行的程序为前台 JOB，前台程序占用一个 shell，执行该程序后，shell 无法再进行别的操作&lt;/p>
&lt;p>在后台执行的程序为后台 JOB，后台程序不占用 shell，可以在该 shell 下继续执行其余任务，不受 ctrl+c 的影响&lt;/p>
&lt;p>语法格式：&lt;/p>
&lt;ul>
&lt;li>ctrl+z # 在正在运行的 porcess 中使用这个组合键，可以让前台进程暂停&lt;/li>
&lt;li>fg %JobNumber # 让后台的进程在前台工作&lt;/li>
&lt;li>bg %JobNumber # 让前台的工作在后台工作&lt;/li>
&lt;li>nohup COMMAND # 让命令触发的进程不随 shell 关闭而停止&lt;/li>
&lt;li>COMMAND &amp;amp; # 让命令触发的进程直接在后台运行&lt;/li>
&lt;/ul>
&lt;p>**jobs [OPTIONS] **# 查看 jobs
OPTIONS：&lt;/p>
&lt;ul>
&lt;li>-l # 查看 jobs 的详细信息&lt;/li>
&lt;/ul></description></item><item><title>Docs: Redirection(重定向)</title><link>https://desistdaydream.github.io/docs/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/4.Terminal-%E4%B8%8E-Shell/Bash/Redirection%E9%87%8D%E5%AE%9A%E5%90%91/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/4.Terminal-%E4%B8%8E-Shell/Bash/Redirection%E9%87%8D%E5%AE%9A%E5%90%91/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;p>在执行命令之前，可以使用由 Shell 的特殊符号来重定向其输入和输出。 重定向还可以用于打开和关闭当前 Shell 执行环境的文件。 重定向操作符可以出现在简单命令的前面，也可以出现在命令的后面。重定向按照它们出现的顺序进行处理。 重定向按照从左到右的顺序显示。&lt;/p>
&lt;p>用一个简单的例子来理解一下什么是重定向&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>~&lt;span style="color:#f92672">]&lt;/span>&lt;span style="color:#75715e"># ls&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>anaconda-ks.cfg playbook scripts
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>~&lt;span style="color:#f92672">]&lt;/span>&lt;span style="color:#75715e"># ls &amp;gt; dirlist&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>~&lt;span style="color:#f92672">]&lt;/span>&lt;span style="color:#75715e"># cat dirlist&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>anaconda-ks.cfg
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>dirlist
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>playbook
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>scripts
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>这个例子就是将 ls 命令的标准输出的内容，重定向到 dirlist 文件中。(默认一个命令执行时，输出内容会打印在屏幕上，但是重定向后，将内容写入文件中)&lt;/p>
&lt;p>每个程序在运行后，都会至少打开三个 文件描述符，分别是&lt;/p>
&lt;ul>
&lt;li>0：标准输入&lt;/li>
&lt;li>1：标准输出&lt;/li>
&lt;li>2：标准错误&lt;/li>
&lt;/ul>
&lt;p>文件描述符介绍详见：文件描述符与打开文件之间的关系&lt;/p>
&lt;p>所以，shell 可以实现重定向，就是这 3 者其中之一，或者全部三者。&lt;/p>
&lt;h1 id="重定向的种类">重定向的种类&lt;/h1>
&lt;p>在下面各种重定向的语法中，n 表示文件描述符&lt;/p>
&lt;h2 id="redirecting-input-重定向输入">Redirecting Input 重定向输入&lt;/h2>
&lt;p>输入的重定向将打开名称为 WORD 的文件，以便在文件描述符 n 下打开标准输入，n 默认为 0。&lt;/p>
&lt;p>语法：COMMAND [n]&amp;lt; WORD&lt;/p>
&lt;p>EXAMPLE&lt;/p>
&lt;h2 id="redirecting-output-重定向输出">Redirecting Output 重定向输出&lt;/h2>
&lt;p>输出重定向将打开名称为 WORD 的文件，以便在文件描述符 n 上进行写操作，n 默认为 1。 如果 WORD 文件不存在，则创建该文件； 如果存在，则将其截断为零大小。&lt;/p>
&lt;p>语法：COMMAND [n]&amp;gt; WORD&lt;/p>
&lt;p>EXAMPLE&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># 将某个程序产生的标准输出和标注错误分别重定向到不同文件&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">[&lt;/span>root@ansible te&lt;span style="color:#f92672">]&lt;/span>&lt;span style="color:#75715e"># ls a.txt b.txt&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>ls: cannot access b.txt: No such file or directory
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>a.txt
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">[&lt;/span>root@ansible te&lt;span style="color:#f92672">]&lt;/span>&lt;span style="color:#75715e"># ls a.txt b.txt 1&amp;gt; stdout.log 2&amp;gt; errout.log&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">[&lt;/span>root@ansible te&lt;span style="color:#f92672">]&lt;/span>&lt;span style="color:#75715e"># ls&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>a.txt errout.log stdout.log
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">[&lt;/span>root@ansible te&lt;span style="color:#f92672">]&lt;/span>&lt;span style="color:#75715e"># cat errout.log&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>ls: cannot access b.txt: No such file or directory
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">[&lt;/span>root@ansible te&lt;span style="color:#f92672">]&lt;/span>&lt;span style="color:#75715e"># cat stdout.log&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>a.txt
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="appending-redirected-output-重定向输出追加方式">Appending Redirected Output 重定向输出(追加方式)&lt;/h2>
&lt;p>语法：COMMAND [n]&amp;raquo; WORD&lt;/p>
&lt;h2 id="redirecting-standard-output-and-standard-error-重定向标准输出和标准错误">Redirecting Standard Output and Standard Error 重定向标准输出和标准错误&lt;/h2>
&lt;p>此结构允许将标准输出（文件描述符 1）和标准错误输出（文件描述符 2）都重定向到名称为 word 扩展的文件。&lt;/p>
&lt;p>语法：&lt;/p>
&lt;p>COMMAND &amp;gt; WORD 2&amp;gt;&amp;amp;1 # 标准错误的信息传递给标准输出通道。&amp;amp;1 表示 标注输出通道。同理 1&amp;gt;&amp;amp;2 反过来理解即可。&lt;/p>
&lt;p>EXAMPLE&lt;/p>
&lt;pre>&lt;code># 与重定向输入的例子类似，这种符号可以理解为将 ls 命令的标准输出重定向到 out.log 文件中
# 而该命令的 标准错误 则传递到 标注输出 中，与标准输出一起重定向到 out.log 文件中
[root@ansible te]# ls a.txt b.txt
ls: cannot access b.txt: No such file or directory
a.txt
[root@ansible te]# ls a.txt b.txt &amp;gt; out.log 2&amp;gt;&amp;amp;1
[root@ansible te]# cat out.log
ls: cannot access b.txt: No such file or directory
a.txt
&lt;/code>&lt;/pre>
&lt;h2 id="here-documenttag-的重定向模式">Here Document(&amp;laquo;TAG 的重定向模式)&lt;/h2>
&lt;p>&lt;strong>Here Document(简称 Heredoc)&lt;/strong> 是 shell 中的一种特殊重定向方式，用来将输入重定向到一个交互式的 shell 脚本或程序。&lt;/p>
&lt;p>语法：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-text" data-lang="text">&lt;span style="display:flex;">&lt;span>COMMAND [n] &amp;lt;&amp;lt; TAG
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Document
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>TAG
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>它的作用是将两个 TAG 之间的内容（docuemnt）作为输入传递给 n。&lt;/p>
&lt;p>注意：&lt;/p>
&lt;ul>
&lt;li>结尾的 TAG 一定要顶头写，前面不能有任何字符，后面也不能有任何字符，包括空格和 tab 缩进。&lt;/li>
&lt;li>开始的前后的空格不要被忽略掉。&lt;/li>
&lt;li>TAG 这三个字符可以用任意字符代替，日常常用 EOF 来标识，只要开头与结尾的字符相同即可&lt;/li>
&lt;/ul>
&lt;p>实例：
在命令行中通过 wc -l 命令计算 Here Document 的行数&lt;/p>
&lt;pre tabindex="0">&lt;code>wc -l &amp;lt;&amp;lt; EOF
学习使用shell 编程
www.xuhaoblog.com
EOF
&lt;/code>&lt;/pre>&lt;p>输出的结果为 2。&lt;/p>
&lt;p>我们也可以将 Here Document 用在脚本中，例如：&lt;/p>
&lt;pre tabindex="0">&lt;code>#!/bin/bash
cat &amp;lt;&amp;lt; EOF
学习使用shell脚本编程
www.xuhaoblog.com
EOF
&lt;/code>&lt;/pre>&lt;p>注意！！！：&lt;/p>
&lt;ul>
&lt;li>EOF 如果在写入内容时，想要防止将变量替换成值的话，需要在第一行 EOF 之前加 &lt;code>\&lt;/code> 或 &lt;code>-&lt;/code>，否则写入内容中如果有执行命令或者变量，则无法以文本写入。&lt;/li>
&lt;/ul>
&lt;p>效果如下&lt;/p>
&lt;pre tabindex="0">&lt;code>~]# cat &amp;gt; 123 &amp;lt;&amp;lt; EOF
&amp;gt; $123
&amp;gt; EOF
~]# cat 123
23
~]# cat &amp;gt; 123 &amp;lt;&amp;lt; \EOF
&amp;gt; $123
&amp;gt; EOF
~]# cat 123
$123
&lt;/code>&lt;/pre>&lt;h2 id="here-strings">Here Strings&lt;/h2>
&lt;h2 id="duplicating-file-descriptors">Duplicating File Descriptors&lt;/h2>
&lt;pre>&lt;code> The redirection operator [n]&amp;lt;&amp;amp;word is used to duplicate input file descriptors. If word expands to one or more digits, the file descriptor denoted by n is made to be a copy of that file descriptor. If the digits in word do not specify a file descriptor open for input, a redirection error occurs. If word evaluates to -, file descriptor n is closed. If n is not specified, the standard input (file descriptor 0) is used. The operator [n]&amp;gt;&amp;amp;word is used similarly to duplicate output file descriptors. If n is not specified, the standard output (file descriptor 1) is used. If the digits in word do not specify a file descriptor open for output, a redirection error occurs. If word evaluates to -, file descriptor n is closed. As a special case, if n is omitted, and word does not expand to one or more digits or -, the standard output and standard error are redirected as described previously.
&lt;/code>&lt;/pre>
&lt;h2 id="moving-file-descriptors">Moving File Descriptors&lt;/h2>
&lt;pre>&lt;code> The redirection operator [n]&amp;lt;&amp;amp;digit- moves the file descriptor digit to file descriptor n, or the standard input (file descriptor 0) if n is not specified. digit is closed after being duplicated to n. Similarly, the redirection operator [n]&amp;gt;&amp;amp;digit- moves the file descriptor digit to file descriptor n, or the standard output (file descriptor 1) if n is not specified.
&lt;/code>&lt;/pre>
&lt;h2 id="opening-file-descriptors-for-reading-and-writing">Opening File Descriptors for Reading and Writing&lt;/h2>
&lt;p>The redirection operator [n]&amp;lt;&amp;gt;word causes the file whose name is the expansion of word to be opened for both reading and writing on file descriptor n, or on file descriptor 0 if n is not specified. If the file does not exist, it is created.&lt;/p>
&lt;h1 id="简单总结">简单总结&lt;/h1>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>命令&lt;/th>
&lt;th>说明&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>command &amp;gt; file&lt;/td>
&lt;td>将输出重定向到 file。&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>command &amp;lt; file&lt;/td>
&lt;td>将输入重定向到 command。&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>command &amp;raquo; file&lt;/td>
&lt;td>将输出以追加的方式重定向到 file。&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>n &amp;gt; file&lt;/td>
&lt;td>将文件描述符为 n 的文件重定向到 file。&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>n &amp;raquo; file&lt;/td>
&lt;td>将文件描述符为 n 的文件以追加的方式重定向到 file。&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>n &amp;gt;&amp;amp; m&lt;/td>
&lt;td>将输出文件 m 和 n 合并。&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>n &amp;lt;&amp;amp; m&lt;/td>
&lt;td>将输入文件 m 和 n 合并。&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&amp;laquo; tag&lt;/td>
&lt;td>将开始标记 tag 和结束标记 tag 之间的内容作为输入。&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h1 id="如何理解-linux-shell-中重定向">如何理解 Linux shell 中重定向&lt;/h1>
&lt;p>原文：https://www.cnblogs.com/even160941/p/15630065.html&lt;/p>
&lt;h4 id="前言">前言&lt;/h4>
&lt;p>有时候我们常看到类似这样的脚本调用：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>./test.sh &amp;gt; log.txt 2&amp;gt;&amp;amp;&lt;span style="color:#ae81ff">1&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>这里的2&amp;gt;&amp;amp;1是什么意思？该如何理解？&lt;br>
先说结论：上面的调用表明将 &lt;code>./test.sh&lt;/code>的输出重定向到 &lt;code>log.txt&lt;/code>文件中，同时将标准错误也重定向到 &lt;code>log.txt&lt;/code>文件中。&lt;/p>
&lt;h4 id="有何妙用">有何妙用&lt;/h4>
&lt;p>（如果已经明白是什么作用，可跳过此小节）&lt;br>
上面到底是什么意思呢？我们来看下面的例子，假如有脚本 &lt;code>test.sh&lt;/code>：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#!/bin/bash
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>date &lt;span style="color:#75715e">#打印当前时间&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">while&lt;/span> true &lt;span style="color:#75715e">#死循环&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">do&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">#每隔2秒打印一次&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> sleep &lt;span style="color:#ae81ff">2&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> whatthis &lt;span style="color:#75715e">#不存在的命令&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> echo -e &lt;span style="color:#e6db74">&amp;#34;std output&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">done&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>脚本中先打印当前日期，然后每隔2秒执行 &lt;code>whatthis&lt;/code>并打印一段字符。由于系统中不存在 &lt;code>whatthis&lt;/code>命令，因此执行会报错。&lt;br>
假如我们想保存该脚本的打印结果，只需将 &lt;code>test.sh&lt;/code>的结果重定向到 &lt;code>log.txt&lt;/code>中即可：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>./test.sh &amp;gt; log.txt
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>执行结果如下：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>./test.sh &amp;gt;log.txt
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>./test.sh: 行 7: whatthis: 未找到命令
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>我们明明将打印内容重定向到 &lt;code>log.txt&lt;/code>中了，但是这条错误信息却没有重定向到 &lt;code>log.txt&lt;/code>中。如果你是使用程序调用该脚本，当查看脚本日志的时候，将会完全看不到这条错误信息。而使用下面的方式则会将出错信息也重定向到 &lt;code>log.txt&lt;/code>中：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>./test.sh &amp;gt; log.txt 2&amp;gt;&amp;amp;&lt;span style="color:#ae81ff">1&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>以这样的方式调用脚本，可以很好地将错误信息保存，帮助我们定位问题。&lt;/p>
&lt;h4 id="如何理解">如何理解&lt;/h4>
&lt;p>每个程序在运行后，都会至少打开三个文件描述符，分别是&lt;br>
0：标准输入 =&amp;gt; stdin；&lt;br>
1：标准输出 =&amp;gt; stdout；&lt;br>
2：标准错误 =&amp;gt; stderr。&lt;br>
例如，对于前面的test.sh脚本，我们通过下面的步骤看到它至少打开了三个文件描述符：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cmake" data-lang="cmake">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#960050;background-color:#1e0010">./test.sh&lt;/span> &lt;span style="color:#75715e">#运行脚本
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">ps&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">-ef|grep&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">test.sh&lt;/span> &lt;span style="color:#75715e">#重新打开命令串口，使用ps命令找到test.sh的pid
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">root&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">96126&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">88139&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">0&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">10:44&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">pts/2&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">00:00:00&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">sh&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">test.sh
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#960050;background-color:#1e0010">root&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">96177&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">56236&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">0&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">10:45&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">pts/1&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">00:00:00&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">grep&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">--color=auto&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">test.sh
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>可以看到 &lt;code>test.sh&lt;/code>的pid为96126，进入到相关fd目录：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>cd /proc/96126/fd &lt;span style="color:#75715e">#进程96126所有打开的文件描述符信息都在此&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>ls -l &lt;span style="color:#75715e">#列出目录下的内容&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">0&lt;/span> -&amp;gt; /dev/pts/2
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">1&lt;/span> -&amp;gt; /dev/pts/2
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">2&lt;/span> -&amp;gt; /dev/pts/2
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">255&lt;/span> -&amp;gt; /root/shell/test.sh
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>可以看到，&lt;code>test.sh&lt;/code>打开了0，1，2三个文件描述符。同样的，如果有兴趣，也可以查看其他运行进程的文件描述符打开情况，除非关闭了否则都会有这三个文件描述符。&lt;/p>
&lt;p>那么现在就容易理解前面的疑问了，2&amp;gt;&amp;amp;1表明将文件描述2（标准错误输出）的内容重定向到文件描述符1（标准输出）的文件（/dev/stdout）中，为什么1前面需要&amp;amp;？当没有&amp;amp;时，1会被认为是一个普通的文件，有&amp;amp;表示重定向的目标不是一个文件，而是一个文件描述符。在前面我们知道，&lt;code>sh test.sh &amp;gt;log.txt&lt;/code>又将文件描述符1的内容重定向到了文件 &lt;code>log.txt&lt;/code>，那么最终标准错误也会重定向到 &lt;code>log.txt&lt;/code>。我们同样通过前面的方法 &lt;code>sh test.sh &amp;gt; log.txt 2&amp;gt;&amp;amp;1&lt;/code>，可以看到 &lt;code>test.sh&lt;/code>进程的文件描述符情况如下：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-basic" data-lang="basic">&lt;span style="display:flex;">&lt;span>0 &lt;span style="color:#f92672">-&amp;gt;&lt;/span> &lt;span style="color:#f92672">/&lt;/span>dev&lt;span style="color:#f92672">/&lt;/span>pts&lt;span style="color:#f92672">/&lt;/span>&lt;span style="color:#ae81ff">2&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>1 &lt;span style="color:#f92672">-&amp;gt;&lt;/span> &lt;span style="color:#f92672">/&lt;/span>root&lt;span style="color:#f92672">/&lt;/span>shell&lt;span style="color:#f92672">/&lt;/span>log&lt;span style="color:#f92672">.&lt;/span>txt
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>2 &lt;span style="color:#f92672">-&amp;gt;&lt;/span> &lt;span style="color:#f92672">/&lt;/span>root&lt;span style="color:#f92672">/&lt;/span>shell&lt;span style="color:#f92672">/&lt;/span>log&lt;span style="color:#f92672">.&lt;/span>txt
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>255 &lt;span style="color:#f92672">-&amp;gt;&lt;/span> &lt;span style="color:#f92672">/&lt;/span>root&lt;span style="color:#f92672">/&lt;/span>shell&lt;span style="color:#f92672">/&lt;/span>test&lt;span style="color:#f92672">.&lt;/span>sh
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>我们可以很明显地看到，文件描述符1和2都指向了 &lt;code>log.txt&lt;/code>文件，也就得到了我们最终想要的效果：将标准错误输出重定向到文件中。&lt;br>
它们还有两种等价写法：&lt;/p>
&lt;pre tabindex="0">&lt;code class="language-mipsasm" data-lang="mipsasm">sh test.sh &amp;gt;&amp;amp; log.txt
sh test.sh &amp;amp;&amp;gt; log.txt
&lt;/code>&lt;/pre>&lt;p>此处 &lt;code>&amp;gt;&amp;amp;&lt;/code> 或者 &lt;code>&amp;amp;&amp;gt;&lt;/code> 视作整体，分开没有单独的意义。&lt;/p>
&lt;h4 id="总结">总结&lt;/h4>
&lt;p>我们总结一下前面的内容：&lt;/p>
&lt;ul>
&lt;li>1.程序运行后会打开三个文件描述符，分别是标准输入，标准输出和标准错误输出。&lt;/li>
&lt;li>2.在调用脚本时，可使用2&amp;gt;&amp;amp;1来将标准错误输出重定向。&lt;/li>
&lt;li>3.只需要查看脚本的错误时，可将标准输出重定向到文件，而标准错误会打印在控制台，便于查看。&lt;/li>
&lt;li>4.&lt;code>&amp;gt;&amp;gt;log.txt&lt;/code>会将重定向内容追加到&lt;code>log.txt&lt;/code>文件末尾。&lt;/li>
&lt;li>5.通过查看&lt;code>/proc/进程id/fd&lt;/code>下的内容，可了解进程打开的文件描述符信息。&lt;/li>
&lt;/ul>
&lt;h1 id="重定向应用示例">重定向应用示例&lt;/h1>
&lt;h2 id="一般来说-1-通常可以省略成-">一般来说, &amp;ldquo;1&amp;gt;&amp;rdquo; 通常可以省略成 &amp;ldquo;&amp;gt;&amp;rdquo;.&lt;/h2>
&lt;p>即可以把如上命令写成: ls a.txt b.txt &amp;gt;file.out 2&amp;gt;file.err&lt;/p>
&lt;p>有了这些认识才能理解 &amp;ldquo;1&amp;gt;&amp;amp;2&amp;rdquo; 和 &amp;ldquo;2&amp;gt;&amp;amp;1&amp;rdquo;.&lt;/p>
&lt;p>1&amp;gt;&amp;amp;2 正确返回值传递给 2 输出通道 &amp;amp;2 表示 2 输出通道&lt;/p>
&lt;p>如果此处错写成 1&amp;gt;2, 就表示把 1 输出重定向到文件 2 中.&lt;/p>
&lt;p>2&amp;gt;&amp;amp;1 错误返回值传递给 1 输出通道, 同样&amp;amp;1 表示 1 输出通道.&lt;/p>
&lt;p>举个例子.&lt;/p>
&lt;p>[root@redhat box]# ls a.txt b.txt 1&amp;gt;file.out 2&amp;gt;&amp;amp;1&lt;/p>
&lt;p>[root@redhat box]# cat file.out&lt;/p>
&lt;p>ls: b.txt: No such file or directory&lt;/p>
&lt;p>a.txt&lt;/p>
&lt;p>现在, 正确的输出和错误的输出都定向到了 file.out 这个文件中, 而不显示在前端.&lt;/p>
&lt;p>补充下, 输出不只 1 和 2, 还有其他的类型, 这两种只是最常用和最基本的.&lt;/p>
&lt;p>例如：&lt;/p>
&lt;p>rm -f $(find / -name core) &amp;amp;&amp;gt; /dev/null，/dev/null 是一个文件，这个文件比较特殊，所有传给它的东西它都丢弃掉。&lt;/p>
&lt;p>例如：&lt;/p>
&lt;p>注意，为了方便理解，必须设置一个环境使得执行 grep da *命令会有正常输出和错误输出，然后分别使用下面的命令生成三个文件：&lt;/p>
&lt;p>grep da * &amp;gt; greplog1&lt;/p>
&lt;p>grep da * &amp;gt; greplog2 1&amp;gt;&amp;amp;2&lt;/p>
&lt;p>grep da _ &amp;gt; greplog3 2&amp;gt;&amp;amp;1 //grep da _ 2&amp;gt; greplog4 1&amp;gt;&amp;amp;2 结果一样&lt;/p>
&lt;p>#查看 greplog1 会发现里面只有正常输出内容&lt;/p>
&lt;p>#查看 greplog2 会发现里面什么都没有#查看 greplog3 会发现里面既有正常输出内容又有错误输出内容&lt;/p>
&lt;h1 id="tee-命令">tee 命令&lt;/h1>
&lt;p>在非 root 用户时，重定向总是会提示权限不够，这时候，可以使用 tee 命令来代替重定向符号&lt;/p>
&lt;p>比如&lt;/p>
&lt;p>&lt;code>containerd config default | sudo tee /etc/containerd/config.toml &amp;gt; /dev/null&lt;/code>&lt;/p>
&lt;p>等效于&lt;/p>
&lt;p>&lt;code>sudo sh -c &amp;quot;containerd config default &amp;gt; /etc/containerd/config.toml&amp;quot;&lt;/code>&lt;/p>
&lt;p>还可以这么用&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>sudo tee ~/test_dir/test.sh &lt;span style="color:#e6db74">&amp;lt;&amp;lt;EOF
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">${abc}
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">EOF&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>若要让写入文件中的内容，将 &lt;code>$&lt;/code> 等符号当做字符串处理的话，则这么用：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>sudo tee ~/test_dir/test.sh &amp;lt;&amp;lt;-&lt;span style="color:#e6db74">&amp;#34;EOF&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">${&lt;/span>abc&lt;span style="color:#e6db74">}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>EOF
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="syntax语法">Syntax(语法)&lt;/h2>
&lt;p>&lt;strong>tee [OPTIONS] FILE&lt;/strong>&lt;/p>
&lt;p>OPTIONS&lt;/p>
&lt;ul>
&lt;li>&lt;strong>-a, &amp;ndash;append&lt;/strong> # 将读取到内容追加到文件中，而不是覆盖。等效于 &lt;code>&amp;gt;&amp;gt;&lt;/code> 符号&lt;/li>
&lt;/ul></description></item></channel></rss>