<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>断念梦的站点 – Bash</title><link>https://desistdaydream.github.io/docs/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/4.Terminal-%E4%B8%8E-Shell/Bash/</link><description>Recent content in Bash on 断念梦的站点</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><atom:link href="https://desistdaydream.github.io/docs/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/4.Terminal-%E4%B8%8E-Shell/Bash/index.xml" rel="self" type="application/rss+xml"/><item><title>Docs: Bash</title><link>https://desistdaydream.github.io/docs/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/4.Terminal-%E4%B8%8E-Shell/Bash/Bash/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/4.Terminal-%E4%B8%8E-Shell/Bash/Bash/</guid><description>
&lt;h1 id="概述">概述&lt;a class="td-heading-self-link" href="#%e6%a6%82%e8%bf%b0" aria-label="Heading self-link">&lt;/a>&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://www.gnu.org/software/bash/">GNU 官网&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Bash_(Unix_shell)">Wiki，Bash&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.man7.org/linux/man-pages/man1/bash.1.html#SHELL_BUILTIN_COMMANDS">Manual(手册)，bash(1)-Shell 内置命令&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://wangdoc.com/bash/index.html">网道，Bash 脚本教程&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>&lt;strong>Bourne Again Shell(简称 Bash)&lt;/strong> 是 Brian Fox 为 GNU 项目编写的 Unix Shell 和编程语言，作为 &lt;strong>Bourne shell(简称 sh)&lt;/strong> 的免费软件替代品，于 1989 年首次发布，已被用作绝大多数 Linux 发行版的默认登录 Shell。Bash 是 Linus Torvalds 在移植 GCC 到 Linux 时最先移植的程序之一。&lt;/p>
&lt;p>Bash 是一种 Shell，学习 Bash，其实也算是学习一种脚本式的编程语言，Bash 本身就是一种类似编译器似的存在。&lt;/p>
&lt;h1 id="bash-关联文件与配置">Bash 关联文件与配置&lt;a class="td-heading-self-link" href="#bash-%e5%85%b3%e8%81%94%e6%96%87%e4%bb%b6%e4%b8%8e%e9%85%8d%e7%bd%ae" aria-label="Heading self-link">&lt;/a>&lt;/h1>
&lt;h2 id="全局配置文件对所有用户生效的配置">全局配置文件，对所有用户生效的配置&lt;a class="td-heading-self-link" href="#%e5%85%a8%e5%b1%80%e9%85%8d%e7%bd%ae%e6%96%87%e4%bb%b6%e5%af%b9%e6%89%80%e6%9c%89%e7%94%a8%e6%88%b7%e7%94%9f%e6%95%88%e7%9a%84%e9%85%8d%e7%bd%ae" aria-label="Heading self-link">&lt;/a>&lt;/h2>
&lt;p>&lt;strong>/etc/environment&lt;/strong> # 系统的环境变量，所有登录方式都会加载的文件。&lt;/p>
&lt;p>&lt;strong>/etc/profile&lt;/strong> # 任何用户使用 shell 时都会加载的配置。linux 不推荐直接修改该文件。加载该配置时自动加载 /etc/profile.d/_.sh 的所有文件&lt;/p>
&lt;p>&lt;strong>/etc/bashrc&lt;/strong> # 常用于设置登录功能和命令别名。linux 不推荐直接修改该文件。加载该配置时自动加载 /etc/profile.d/_.sh 的所有文件&lt;/p>
&lt;p>&lt;strong>/etc/profile.d/*.sh&lt;/strong> # 类似于 include 的效果。通常用来创建自定义配置。&lt;/p>
&lt;p>在 &lt;strong>/etc/profile&lt;/strong> 和 &lt;strong>/etc/bashrc&lt;/strong> 中都会有如下代码块&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#204a87;font-weight:bold">for&lt;/span> i in /etc/profile.d/*.sh /etc/profile.d/sh.local &lt;span style="color:#000;font-weight:bold">;&lt;/span> &lt;span style="color:#204a87;font-weight:bold">do&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#204a87;font-weight:bold">if&lt;/span> &lt;span style="color:#ce5c00;font-weight:bold">[&lt;/span> -r &lt;span style="color:#4e9a06">&amp;#34;&lt;/span>&lt;span style="color:#000">$i&lt;/span>&lt;span style="color:#4e9a06">&amp;#34;&lt;/span> &lt;span style="color:#ce5c00;font-weight:bold">]&lt;/span>&lt;span style="color:#000;font-weight:bold">;&lt;/span> &lt;span style="color:#204a87;font-weight:bold">then&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#204a87;font-weight:bold">if&lt;/span> &lt;span style="color:#ce5c00;font-weight:bold">[&lt;/span> &lt;span style="color:#4e9a06">&amp;#34;&lt;/span>&lt;span style="color:#4e9a06">${&lt;/span>&lt;span style="color:#000;font-weight:bold">-#*i&lt;/span>&lt;span style="color:#4e9a06">}&lt;/span>&lt;span style="color:#4e9a06">&amp;#34;&lt;/span> !&lt;span style="color:#ce5c00;font-weight:bold">=&lt;/span> &lt;span style="color:#4e9a06">&amp;#34;&lt;/span>&lt;span style="color:#000">$-&lt;/span>&lt;span style="color:#4e9a06">&amp;#34;&lt;/span> &lt;span style="color:#ce5c00;font-weight:bold">]&lt;/span>&lt;span style="color:#000;font-weight:bold">;&lt;/span> &lt;span style="color:#204a87;font-weight:bold">then&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> . &lt;span style="color:#4e9a06">&amp;#34;&lt;/span>&lt;span style="color:#000">$i&lt;/span>&lt;span style="color:#4e9a06">&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#204a87;font-weight:bold">else&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> . &lt;span style="color:#4e9a06">&amp;#34;&lt;/span>&lt;span style="color:#000">$i&lt;/span>&lt;span style="color:#4e9a06">&amp;#34;&lt;/span> &amp;gt;/dev/null
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#204a87;font-weight:bold">fi&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#204a87;font-weight:bold">fi&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#204a87;font-weight:bold">done&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>这段脚本的大致意思就是：遍历 /etc/profile.d 目录下所有以 .sh 结尾的文件和 sh.local 文件。判断它们是否可读（&lt;code>[ -r &amp;quot;$i&amp;quot;]&lt;/code>），如果可读，判断当前 Shell启动方式是不是交互式（&lt;code>$-&lt;/code> 中包含 i）的，如果是交互式的，在当前 Shell 进程中执行该脚本（&lt;code>. &amp;quot;$i&amp;quot;&lt;/code>，&lt;code>source &amp;quot;$i&amp;quot;&lt;/code> 的简写， Shell 的模块化方式），否则，也在当前 Shell 进程中执行该脚本，只不过将输出重定向到了 /dev/null 中。&lt;/p>
&lt;blockquote>
&lt;p>&lt;code>${-#*i}&lt;/code> 这个表达式的意思是：从左向右，在 - 变量中找到第一个 i ，并截取 i 之后的子串。&lt;/p>
&lt;/blockquote>
&lt;h2 id="用户配置文件对部分用户生效的配置">用户配置文件，对部分用户生效的配置&lt;a class="td-heading-self-link" href="#%e7%94%a8%e6%88%b7%e9%85%8d%e7%bd%ae%e6%96%87%e4%bb%b6%e5%af%b9%e9%83%a8%e5%88%86%e7%94%a8%e6%88%b7%e7%94%9f%e6%95%88%e7%9a%84%e9%85%8d%e7%bd%ae" aria-label="Heading self-link">&lt;/a>&lt;/h2>
&lt;blockquote>
&lt;p>这些配置文件一般都定义在用户的家目录当中，所以当某一用户使用 shell 时，就会在其家目录中加载这些配置文件。&lt;/p>
&lt;/blockquote>
&lt;ul>
&lt;li>&lt;strong>~/.bash_profile&lt;/strong> # 仅对当前用户有效。该配置文件会对 ~/.bashrc 进行判断，如果存在，则加载 ~/.bashrc。&lt;/li>
&lt;li>&lt;strong>~/.bash_login&lt;/strong> # 仅对当前用户有效。该配置文件会对 ~/.bashrc 进行判断，如果存在，则加载 ~/.bashrc。&lt;/li>
&lt;li>&lt;strong>~/.profile&lt;/strong> # 仅对当前用户有效。该配置文件会对 ~/.bashrc 进行判断，如果存在，则加载 ~/.bashrc。&lt;/li>
&lt;li>其他
&lt;ul>
&lt;li>&lt;strong>~/.bashrc&lt;/strong> # 仅对当前用户有效。该配置文件会对 /etc/bashrc 进行判断，如果存在，则加载 /etc/bashrc。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>Note：&lt;/p>
&lt;ul>
&lt;li>仅在登录的第一次读取一次 bash 这些配置文件，如果在里面加了内容想让其实现，需要重新登录或者用 source FILE 命令来让更改的内容生效）&lt;/li>
&lt;li>用户登录时逐一加载 ~/.bash_profile、~/.bash_login、~/.profile。当任何一个文件存在时，都不再加载其余文件。&lt;/li>
&lt;li>为什么配置文件会有这么多分类呢？详见 《shell 的四种登录与交互模式》章节。不同模式，加载的配置文件是不同的&lt;/li>
&lt;li>这三个文件通常只会存在一个，并且在其中的代码中，包含了判断是否存在 ~/.bashrc 文件并执行的逻辑。&lt;/li>
&lt;/ul>
&lt;h1 id="登录与交互模式">登录与交互模式&lt;a class="td-heading-self-link" href="#%e7%99%bb%e5%bd%95%e4%b8%8e%e4%ba%a4%e4%ba%92%e6%a8%a1%e5%bc%8f" aria-label="Heading self-link">&lt;/a>&lt;/h1>
&lt;p>这里面的概念推荐有一定 Linux 基础了之，尤其是得真正明白 Shell 到底是什么之后再来看。&lt;/p>
&lt;p>首先，有几种对登录类型的描述：&lt;/p>
&lt;ul>
&lt;li>交互式：一个个地输入命令并及时查看它们的输出结果，整个过程都在跟 Shell 不停地互动。&lt;/li>
&lt;li>非交互式：运行一个 Shell 脚本 文件，让所有命令批量化、一次性地执行。&lt;/li>
&lt;li>登录式：需要输入用户名和密码才能使用。&lt;/li>
&lt;li>非登录式：直接可以使用。&lt;/li>
&lt;/ul>
&lt;p>这几种类型的不通组合，决定了运行 Shell 的模式&lt;/p>
&lt;p>当我们运行一个 Shell 之后，Shell 会选择下面 4 中模式之一，作为运行本次 Shell 的模式，&lt;strong>不同的模式，加载的配置文件是不同的&lt;/strong>。&lt;/p>
&lt;ul>
&lt;li>&lt;strong>login + interactive # 登录交互。&lt;/strong>
&lt;ul>
&lt;li>首先读取并执行 /etc/profile。&lt;/li>
&lt;li>然后逐一加载 ~/.bash_profile、~/.bash_login、~/.profile。当任何一个文件存在时，都不再加载其余文件。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>login + non-interactive # 登录不交互。&lt;/strong>
&lt;ul>
&lt;li>与 登录交互 模式相同。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>non-login + interactive # 不登陆交互&lt;/strong>
&lt;ul>
&lt;li>直接加载 ~/.bashrc 文件&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>non-login + non-interactive # 不登陆不交互&lt;/strong>
&lt;ul>
&lt;li>与 不登录交互 模式相同&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h2 id="如何判断是否为交互式-shell-有两种方式">如何判断是否为交互式 Shell? 有两种方式&lt;a class="td-heading-self-link" href="#%e5%a6%82%e4%bd%95%e5%88%a4%e6%96%ad%e6%98%af%e5%90%a6%e4%b8%ba%e4%ba%a4%e4%ba%92%e5%bc%8f-shell-%e6%9c%89%e4%b8%a4%e7%a7%8d%e6%96%b9%e5%bc%8f" aria-label="Heading self-link">&lt;/a>&lt;/h2>
&lt;p>查看特殊变量 &lt;code>-&lt;/code> ，如果输出的值包含 &lt;code>i&lt;/code>，则是交互式，否则是非交互式&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#204a87">echo&lt;/span> &lt;span style="color:#000">$-&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8f5902;font-style:italic"># 比如下面的情况&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>root@lichenhao:~# ssh 172.19.42.248
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>root@lichenhao:~# &lt;span style="color:#204a87">echo&lt;/span> &lt;span style="color:#000">$-&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>himBHs
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8f5902;font-style:italic"># 当使用 ssh 登录时，使用 -T 参数不分配终端，则 $- 没有 i&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>root@lichenhao:~# ssh -T 172.19.42.248
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#204a87">echo&lt;/span> &lt;span style="color:#000">$-&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>hBs
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>查看变量 PS1 是否为空，如果不为空，则是交互式，否则为非交互式&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#204a87">echo&lt;/span> &lt;span style="color:#000">$PS1&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Note：这里需要对“交互式”这三个字进行一下说明。与平时理解的所谓交互式不太一样，这里面虽然人类还是可以与设备交互，但是依然称为“非交互式”。&lt;/p>
&lt;p>如何判断是否为登录式 Shell ?&lt;/p>
&lt;p>执行命令 shopt login_shell，如果 login_shell 的值为 on 表示登录式，为 off 表示非登录式。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>~&lt;span style="color:#ce5c00;font-weight:bold">]&lt;/span>&lt;span style="color:#8f5902;font-style:italic"># shopt login_shell&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>login_shell on
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="典型登录模式总结">典型登录模式总结&lt;a class="td-heading-self-link" href="#%e5%85%b8%e5%9e%8b%e7%99%bb%e5%bd%95%e6%a8%a1%e5%bc%8f%e6%80%bb%e7%bb%93" aria-label="Heading self-link">&lt;/a>&lt;/h2>
&lt;ul>
&lt;li>登陆机器后的第一个 shell：登录 + 交互&lt;/li>
&lt;li>通过 ssh 登陆到远程主机：登录 + 交互&lt;/li>
&lt;li>新启动一个 shell 进程，如运行 bash ：不登陆 + 交互&lt;/li>
&lt;li>执行脚本，如 bash script.sh ：不登陆 + 不交互&lt;/li>
&lt;li>运行头部有如 #!/usr/bin/env bash 的可执行文件，如 ./executable ：不登陆 + 不交互&lt;/li>
&lt;li>远程执行脚本，如 ssh user@remote script.sh ：不登陆 + 不交互&lt;/li>
&lt;li>远程执行脚本，同时请求控制台，如 ssh user@remote -t &amp;rsquo;echo $PWD&amp;rsquo; ：不登陆 + 交互&lt;/li>
&lt;li>在图形化界面中打开 terminal：不登陆 + 交互&lt;/li>
&lt;/ul>
&lt;h2 id="登录系统后可自动执行的配置文件">登录系统后可自动执行的配置文件&lt;a class="td-heading-self-link" href="#%e7%99%bb%e5%bd%95%e7%b3%bb%e7%bb%9f%e5%90%8e%e5%8f%af%e8%87%aa%e5%8a%a8%e6%89%a7%e8%a1%8c%e7%9a%84%e9%85%8d%e7%bd%ae%e6%96%87%e4%bb%b6" aria-label="Heading self-link">&lt;/a>&lt;/h2>
&lt;p>/etc/rc.local&lt;/p>
&lt;ul>
&lt;li>注意：centos7 的 rc.local 没有可执行权限，需要添加权限(chmod +x /etc/rc.d/rc.local)，否则无法使用&lt;/li>
&lt;li>官方推荐使用 systemd 来管理启动脚本。而不是这种方式&lt;/li>
&lt;/ul>
&lt;h1 id="在-bash-中执行命令">在 Bash 中执行命令&lt;a class="td-heading-self-link" href="#%e5%9c%a8-bash-%e4%b8%ad%e6%89%a7%e8%a1%8c%e5%91%bd%e4%bb%a4" aria-label="Heading self-link">&lt;/a>&lt;/h1>
&lt;h2 id="source-程序">source 程序&lt;a class="td-heading-self-link" href="#source-%e7%a8%8b%e5%ba%8f" aria-label="Heading self-link">&lt;/a>&lt;/h2>
&lt;p>source 程序可以在当前 Shell 环境中从指定文件中读取并执行命令&lt;/p>
&lt;p>注意：该命令可以使当前环境的配置文件在此环境中立刻生效而不用重启机器&lt;/p>
&lt;p>作用：&lt;/p>
&lt;ul>
&lt;li>这个命令其实只是简单地读取脚本里面的语句依次在当前 shell 里面执行，没有建立新的子 shell。那么脚本里面所有新建、改变变量的语句都会保存在当前 shell 里面&lt;/li>
&lt;li>source 命令(从 C Shell 而来)是 bash shell 的内置命令。&lt;/li>
&lt;li>source(或点)命令通常用于重新执行刚修改的初始化文档。&lt;/li>
&lt;/ul>
&lt;p>应用实例：一般用于写在 shell 脚本中，通过 source 执行外部文件中是变量赋值，这样不建立子 shell 的话，外部文件中的变量就可以在该脚本启动的 shell 中引用&lt;/p>
&lt;p>&lt;strong>source [选项] FILENAME&lt;/strong> # 使环境变量立刻生效&lt;/p>
&lt;p>在当前 bash 环境下读取并执行 FileName 中的命令。该 filename 文件可以“无执行权限”&lt;/p>
&lt;p>EXAMPLE：&lt;/p>
&lt;ul>
&lt;li>source openrc admin admin # 运行 openrc 这个配置文件，把第一个参数 admin 和第二个参数 admin 送给 openrc 文件中的$1 和$2&lt;/li>
&lt;li>source .bash_profile #&lt;/li>
&lt;/ul>
&lt;h2 id="sh-和-bash-程序">sh 和 bash 程序&lt;a class="td-heading-self-link" href="#sh-%e5%92%8c-bash-%e7%a8%8b%e5%ba%8f" aria-label="Heading self-link">&lt;/a>&lt;/h2>
&lt;p>实际上，执行 sh 或者 bash 就是相当于打开新的子 shell，并在新的 shell 中执行后续的命令。只不过 bash 与 sh 是不同的 shell，内置的功能有一些细微的区别。&lt;/p>
&lt;p>作用:&lt;/p>
&lt;ul>
&lt;li>开启一个新的 shell，读取并执行 File 中的命令。该 file 可以“无执行权限”&lt;/li>
&lt;li>注：两者在执行文件时的不同，是分别用自己的 shell 来跑文件。
&lt;ul>
&lt;li>sh 使用“-n”选项进行 shell 脚本的语法检查，使用“-x”选项实现 shell 脚本逐条语句的跟踪&lt;/li>
&lt;li>可以巧妙地利用 shell 的内置变量增强“-x”选项的输出信息等。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>bash [OPTIONS] [File]&lt;/strong> #&lt;/p>
&lt;p>OPTIONS&lt;/p>
&lt;ul>
&lt;li>-n # 对指定文件进行语法检查&lt;/li>
&lt;li>-x # 打印出执行脚本的过程&lt;/li>
&lt;/ul>
&lt;h2 id="-语法">./ 语法&lt;a class="td-heading-self-link" href="#-%e8%af%ad%e6%b3%95" aria-label="Heading self-link">&lt;/a>&lt;/h2>
&lt;p>作用:&lt;/p>
&lt;ul>
&lt;li>打开一个子 shell 来读取并执行 FileName 中命令。&lt;/li>
&lt;li>注：运行一个 shell 脚本时会启动另一个命令解释器.&lt;/li>
&lt;li>每个 shell 脚本有效地运行在父 shell(parent shell)的一个子进程里. 这个父 shell 是指在一个控制终端或在一个 xterm 窗口中给你命令指示符的进程.shell 脚本也可以启动他自已的子进程. 这些子 shell(即子进程)使脚本并行地，有效率地地同时运行脚本内的多个子任务.&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>Syntax(语法)&lt;/strong>&lt;/p>
&lt;p>&lt;strong>./FileName&lt;/strong>&lt;/p>
&lt;h1 id="命令行补全">命令行补全&lt;a class="td-heading-self-link" href="#%e5%91%bd%e4%bb%a4%e8%a1%8c%e8%a1%a5%e5%85%a8" aria-label="Heading self-link">&lt;/a>&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Command-line_completion">Wiki，CommandLineCompletion&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>&lt;strong>Command Line Completion(命令行补全)&lt;/strong> 也称为 &lt;strong>tab completion&lt;/strong>，是命令行解释器的常见功能，在命令行中的程序，可以自动填充部分需要手动输入的命令。&lt;/p>
&lt;p>由 bash-completion 程序实现&lt;/p>
&lt;h2 id="关联文件与配置">关联文件与配置&lt;a class="td-heading-self-link" href="#%e5%85%b3%e8%81%94%e6%96%87%e4%bb%b6%e4%b8%8e%e9%85%8d%e7%bd%ae" aria-label="Heading self-link">&lt;/a>&lt;/h2>
&lt;p>&lt;strong>/etc/bash_completion.d/&lt;/strong> #&lt;/p>
&lt;p>&lt;strong>/usr/share/bash-completion/completions/&lt;/strong> # 各种程序补全功能所需文件的保存目录。&lt;/p></description></item><item><title>Docs: Bash 内置命令</title><link>https://desistdaydream.github.io/docs/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/4.Terminal-%E4%B8%8E-Shell/Bash/Bash-%E5%86%85%E7%BD%AE%E5%91%BD%E4%BB%A4/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/4.Terminal-%E4%B8%8E-Shell/Bash/Bash-%E5%86%85%E7%BD%AE%E5%91%BD%E4%BB%A4/</guid><description>
&lt;h1 id="概述">概述&lt;a class="td-heading-self-link" href="#%e6%a6%82%e8%bf%b0" aria-label="Heading self-link">&lt;/a>&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://www.man7.org/linux/man-pages/man1/bash.1.html#SHELL_BUILTIN_COMMANDS">Manual(手册)，bash(1)-Shell 内置命令&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote></description></item><item><title>Docs: 数据类型</title><link>https://desistdaydream.github.io/docs/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/4.Terminal-%E4%B8%8E-Shell/Bash/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/4.Terminal-%E4%B8%8E-Shell/Bash/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</guid><description>
&lt;h1 id="概述">概述&lt;a class="td-heading-self-link" href="#%e6%a6%82%e8%bf%b0" aria-label="Heading self-link">&lt;/a>&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>&lt;strong>Numbers(数字型)&lt;/strong> # 格式化标识符 &lt;code>%d&lt;/code>&lt;/p>
&lt;ul>
&lt;li>&lt;strong>Integers(整数型)&lt;/strong> # 简写为 &lt;code>int&lt;/code>&lt;/li>
&lt;li>&lt;strong>Floating Point Numbers(浮点数型)&lt;/strong>&lt;/li>
&lt;li>&lt;strong>complex&lt;/strong> 复数共两种复数，complex64 和 complex128，分别对应 float32 和 float64 两种浮点数精度。内置的 complex 函数用于构建复数，内建的 real 和 imag 函数分别返回复数的实部和虚部&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>Strings(字符型)&lt;/strong> # 格式化标识符 &lt;code>%s&lt;/code>&lt;/p>
&lt;p>&lt;strong>Booleans(布尔型)&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>
&lt;p>注意：很多时候，Booleans 类型的值可以用数字表示&lt;/p>
&lt;ul>
&lt;li>1 表示 true(真)&lt;/li>
&lt;li>0 表示 false(假)&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul></description></item><item><title>Docs: 特殊符号</title><link>https://desistdaydream.github.io/docs/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/4.Terminal-%E4%B8%8E-Shell/Bash/%E7%89%B9%E6%AE%8A%E7%AC%A6%E5%8F%B7/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/4.Terminal-%E4%B8%8E-Shell/Bash/%E7%89%B9%E6%AE%8A%E7%AC%A6%E5%8F%B7/</guid><description>
&lt;h1 id="概述">概述&lt;a class="td-heading-self-link" href="#%e6%a6%82%e8%bf%b0" aria-label="Heading self-link">&lt;/a>&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;h1 id="bash-中特殊符号的说明">Bash 中特殊符号的说明&lt;a class="td-heading-self-link" href="#bash-%e4%b8%ad%e7%89%b9%e6%ae%8a%e7%ac%a6%e5%8f%b7%e7%9a%84%e8%af%b4%e6%98%8e" aria-label="Heading self-link">&lt;/a>&lt;/h1>
&lt;p>这些特殊符号的作用，一般是在对 Linux 和 shell 有一定了解的基础上，才能明白其作用。&lt;/p>
&lt;h2 id="--和--单引号-和-双引号">&lt;code>' '&lt;/code> 和 &lt;code>&amp;quot; &amp;quot;&lt;/code>(单引号 和 双引号)&lt;a class="td-heading-self-link" href="#--%e5%92%8c--%e5%8d%95%e5%bc%95%e5%8f%b7-%e5%92%8c-%e5%8f%8c%e5%bc%95%e5%8f%b7" aria-label="Heading self-link">&lt;/a>&lt;/h2>
&lt;p>首先，单引号和双引号，都是为了解决中间有空格的问题。&lt;/p>
&lt;p>因为空格在 Shell 中时作为一个很典型的分隔符，比如 string1=this is astring，这样执行就会报错。为了避免这个问题，因此就产生了单引号和双引号。&lt;/p>
&lt;p>单引号引用的内容，所见即所得。即将单引号内的内容原样输出，或者描述为单引号里面看到的是什么就会输出什么。单引号是全引用，被单引号括起的内容不管是常量还是变量都不会发生替换。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>~&lt;span style="color:#ce5c00;font-weight:bold">]&lt;/span>&lt;span style="color:#8f5902;font-style:italic"># var=dablelv&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>~&lt;span style="color:#ce5c00;font-weight:bold">]&lt;/span>&lt;span style="color:#8f5902;font-style:italic"># echo &amp;#39;$var&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#000">$var&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>双引号引用的内容，所见非所得。如果内容中有命令、变量等，会先把变量、命令解析出结果，然后在输出最终内容。双引号是部分引用，被双引号括起的内容常量还是常量，变量则会发生替换，替换成变量内容。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>~&lt;span style="color:#ce5c00;font-weight:bold">]&lt;/span>&lt;span style="color:#8f5902;font-style:italic"># var=dablelv&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>~&lt;span style="color:#ce5c00;font-weight:bold">]&lt;/span>&lt;span style="color:#8f5902;font-style:italic"># echo &amp;#34;$var&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>dablelv
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>无引号不使用引号定义字符串时，字符串不能包含空白字符（如 Space 或 Tab），需要该加引号，一般连续的字符串，数字，路径等可以不加引号。如果内容中有命令、变量等，会先把变量、命令解析出结果，然后在输出最终内容。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>~&lt;span style="color:#ce5c00;font-weight:bold">]&lt;/span>&lt;span style="color:#8f5902;font-style:italic"># str3=test String&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>-bash: String: 未找到命令
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>~&lt;span style="color:#ce5c00;font-weight:bold">]&lt;/span>&lt;span style="color:#8f5902;font-style:italic"># echo $str3&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>~&lt;span style="color:#ce5c00;font-weight:bold">]&lt;/span>&lt;span style="color:#8f5902;font-style:italic">#&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>可见，字符串中包含有空格时不实用引号括起来，将无法正常输出。&lt;/p>
&lt;h2 id="-和--用于命令替换">&lt;code>$()&lt;/code> 和 `` 用于命令替换&lt;a class="td-heading-self-link" href="#-%e5%92%8c--%e7%94%a8%e4%ba%8e%e5%91%bd%e4%bb%a4%e6%9b%bf%e6%8d%a2" aria-label="Heading self-link">&lt;/a>&lt;/h2>
&lt;p>在 bash shell 中，$( ) 与`` (反引号) 都是用来做命令替换用(command substitution)的。&lt;/p>
&lt;p>例如：version=$(uname -r) 和 version=&lt;code>uname -r&lt;/code> 都可以使 version 得到内核的版本号&lt;/p>
&lt;p>各自的优缺点：&lt;/p>
&lt;ul>
&lt;li>`` 基本上可用在全部的 unix shell 中使用，若写成 shell script ，其移植性比较高。但反单引号容易打错或看错。&lt;/li>
&lt;li>&lt;code>$( )&lt;/code> 并不是所有 shell 都支持。&lt;/li>
&lt;/ul>
&lt;h2 id="-和-">&lt;code>$[]&lt;/code> 和 &lt;code>$(())&lt;/code>&lt;a class="td-heading-self-link" href="#-%e5%92%8c-" aria-label="Heading self-link">&lt;/a>&lt;/h2>
&lt;p>它们是一样的，都是进行数学运算的。支持+ - */ %：分别为 “加、减、乘、除、取模”。但是注意，bash 只能作整数运算，对于浮点数是当作字符串处理的。&lt;/p>
&lt;p>&lt;code> c=2$ echo $(( a+b*c ))19$ echo $(( (a+b)/c ))6$ echo $(( (a*b)%c))1&lt;/code>&lt;/p>
&lt;p>在 &lt;code>$(( ))&lt;/code> 中的变量名称，可于其前面加 &lt;code>$&lt;/code> 符号来替换，也可以不用，如：&lt;/p>
&lt;p>&lt;code>$(( $a + $b * $c))&lt;/code> 也可得到 19 的结果&lt;/p>
&lt;p>此外，$(( )) 还可作不同进位(如二进制、八进位、十六进制)作运算呢，只是，输出结果皆为十进制而已：&lt;/p>
&lt;p>echo $((16#2a)) 结果为 42 (16 进位转十进制)&lt;/p>
&lt;h2 id="--test-命令的另一种形式">&lt;code>[ ]&lt;/code> &lt;code>test&lt;/code> 命令的另一种形式&lt;a class="td-heading-self-link" href="#--test-%e5%91%bd%e4%bb%a4%e7%9a%84%e5%8f%a6%e4%b8%80%e7%a7%8d%e5%bd%a2%e5%bc%8f" aria-label="Heading self-link">&lt;/a>&lt;/h2>
&lt;p>注意：&lt;/p>
&lt;ul>
&lt;li>你必须在左括号的右侧和右括号的左侧各加一个空格，否则会报错。&lt;/li>
&lt;li>test 命令使用标准的数学比较符号来表示字符串的比较，而用文本符号来表示数值的比较。很多人会记反了。使用反了，shell 可能得不到正确的结果。&lt;/li>
&lt;li>大于符号或小于符号必须要转义，否则会被理解成重定向。
&lt;ul>
&lt;li>bash 的内部命令，[和 test 是等同的。如果我们不用绝对路径指明，通常我们用的都是 bash 自带的命令。if/test 结构中的左中括号是调用 test 的命令标识，右中括号是关闭条件判断的。这个命令把它的参数作为比较表达式或者作为文件测试，并且根据比较的结果来返回一个退出状态码。if/test 结构中并不是必须右中括号，但是新版的 Bash 中要求必须这样。&lt;/li>
&lt;li>test 和 &lt;code>[]&lt;/code> 中可用的比较运算符只有 &lt;code>==&lt;/code> 和 &lt;code>!=&lt;/code> ，两者都是用于字符串比较的，不可用于整数比较，整数比较只能使用 -eq，-gt 这种形式。无论是字符串比较还是整数比较都不支持大于号小于号。如果实在想用，对于字符串比较可以使用转义形式，如果比较&amp;quot;ab&amp;quot;和&amp;quot;bc&amp;quot;：&lt;code>[ ab &amp;lt; bc ]&lt;/code>，结果为真，也就是返回状态为 0。&lt;code>[ ]&lt;/code> 中的逻辑与和逻辑或使用 -a 和 -o 表示。&lt;/li>
&lt;li>字符范围。用作正则表达式的一部分，描述一个匹配的字符范围。作为 test 用途的中括号内不能使用正则。&lt;/li>
&lt;li>在一个 array 结构的上下文中，中括号用来引用数组中每个元素的编号。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h2 id="--和--">&lt;code>(( ))&lt;/code> 和 &lt;code>[[ ]]&lt;/code>&lt;a class="td-heading-self-link" href="#--%e5%92%8c--" aria-label="Heading self-link">&lt;/a>&lt;/h2>
&lt;p>它们分别是[ ]的针对数学比较表达式和字符串表达式的加强版。&lt;/p>
&lt;p>注意：[[]]会把 0 开头的整型数字当成 8 进制数来处理，所以以 0 开头的整型数如果想要按照 10 进制处理需要使用[]来处理&lt;/p>
&lt;p>其中(( ))，不需要再将表达式里面的大小于符号转义，除了可以使用标准的数学运算符外，还增加了以下符号：&lt;/p>
&lt;p>&lt;code>[[&lt;/code> 是 bash 程序语言的关键字。并不是一个命令，&lt;code>[[ ]]&lt;/code> 结构比 &lt;code>[ ]&lt;/code> 结构更加通用。在 &lt;code>[[&lt;/code> 和 &lt;code>]]&lt;/code> 之间所有的字符都不会发生文件名扩展或者单词分割，但是会发生参数扩展和命令替换。&lt;/p>
&lt;p>支持字符串的模式匹配，使用=~操作符时甚至支持shell的正则表达式。字符串比较时可以把右边的作为一个模式，而不仅仅是一个字符串，比如[[ hello == hell? ]]，结果为真。[[ ]] 中匹配字符串或通配符，不需要引号。&lt;/p>
&lt;p>使用 &lt;code>[[ ... ]]&lt;/code> 条件判断结构，而不是 &lt;code>[ ... ]&lt;/code>，能够防止脚本中的许多逻辑错误。比如，&lt;code>&amp;amp;&amp;amp;&lt;/code>、&lt;code>||&lt;/code>、&lt;code>&amp;lt;&lt;/code> 和 &lt;code>&amp;gt;&lt;/code> 操作符能够正常存在于 &lt;code>[[ ]]&lt;/code> 条件判断结构中，但是如果出现在[ ]结构中的话，会报错。比如可以直接使用 &lt;code>if [[ $a != 1 &amp;amp;&amp;amp; $a != 2 ]]&lt;/code>, 如果不适用双括号, 则为 &lt;code>if [ $a -ne 1] &amp;amp;&amp;amp; [ $a != 2 ]&lt;/code> 或者 &lt;code>if [ $a -ne 1 -a $a != 2 ]&lt;/code>。&lt;/p>
&lt;p>Bash 把双中括号中的表达式看作一个单独的元素，并返回一个退出状态码。&lt;/p></description></item><item><title>Docs: Bash 变量</title><link>https://desistdaydream.github.io/docs/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/4.Terminal-%E4%B8%8E-Shell/Bash/Bash-%E5%8F%98%E9%87%8F/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/4.Terminal-%E4%B8%8E-Shell/Bash/Bash-%E5%8F%98%E9%87%8F/</guid><description>
&lt;h1 id="概述">概述&lt;a class="td-heading-self-link" href="#%e6%a6%82%e8%bf%b0" aria-label="Heading self-link">&lt;/a>&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://www.man7.org/linux/man-pages/man1/bash.1.html#PARAMETERS">Manual(手册),bash(1)-形参&lt;/a>-Shell 变量&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>Bash 可以从逻辑上分为如下几种变量&lt;/p>
&lt;ul>
&lt;li>&lt;strong>局部变量&lt;/strong> # 不以被子进程继承的变量。通常在脚本或命令中定义，仅在当前shell实例中有效，其他shell启动的程序不能访问局部变量。&lt;/li>
&lt;li>&lt;strong>环境变量&lt;/strong> # 可以被子进程继承的变量。通常继承自操作系统的环境变量。所有的程序，包括 Shell 启动的程序，都能访问环境变量，有些程序需要环境变量来保证其正常运行。必要的时候 Shell 脚本也可以定义环境变量。&lt;/li>
&lt;/ul>
&lt;p>局部变量与环境变量的区别主要在于是否可以被子进程继承&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>~&lt;span style="color:#ce5c00;font-weight:bold">]&lt;/span>&lt;span style="color:#8f5902;font-style:italic"># TestVar=&amp;#34;This is Normal Var&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>~&lt;span style="color:#ce5c00;font-weight:bold">]&lt;/span>&lt;span style="color:#8f5902;font-style:italic"># export TestEnvVar=&amp;#34;This is Enviroment Var&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>~&lt;span style="color:#ce5c00;font-weight:bold">]&lt;/span>&lt;span style="color:#8f5902;font-style:italic"># bash # 在这里进入了一个新的 Bash 程序，不通过 export 声明的非环境变量&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>~&lt;span style="color:#ce5c00;font-weight:bold">]&lt;/span>&lt;span style="color:#8f5902;font-style:italic"># echo $TestVar&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>~&lt;span style="color:#ce5c00;font-weight:bold">]&lt;/span>&lt;span style="color:#8f5902;font-style:italic"># echo $TestEnvVar&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>This is Enviroment Var
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>这个示例中可以看到，当我们启动一个新 Bash 时，不使用 &lt;code>export&lt;/code> 声明的变量，将不会被子 Bash 继承。这就是环境变量与普通变量的基本区别。&lt;/p>
&lt;h2 id="局部变量">局部变量&lt;a class="td-heading-self-link" href="#%e5%b1%80%e9%83%a8%e5%8f%98%e9%87%8f" aria-label="Heading self-link">&lt;/a>&lt;/h2>
&lt;p>没什么特殊的说明&lt;/p>
&lt;h2 id="环境变量">环境变量&lt;a class="td-heading-self-link" href="#%e7%8e%af%e5%a2%83%e5%8f%98%e9%87%8f" aria-label="Heading self-link">&lt;/a>&lt;/h2>
&lt;p>根据变量的定义位置，环境变量分为多个作用域：&lt;/p>
&lt;ul>
&lt;li>系统范围&lt;/li>
&lt;li>用户范围&lt;/li>
&lt;li>进程范围&lt;/li>
&lt;/ul>
&lt;h1 id="声明变量与取消变量">声明变量与取消变量&lt;a class="td-heading-self-link" href="#%e5%a3%b0%e6%98%8e%e5%8f%98%e9%87%8f%e4%b8%8e%e5%8f%96%e6%b6%88%e5%8f%98%e9%87%8f" aria-label="Heading self-link">&lt;/a>&lt;/h1>
&lt;p>对于 Shell 编程语言来说，一个变量其实不声明也是可以的，默认任意字符串组合成的变量的值都为空，比如&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>~&lt;span style="color:#ce5c00;font-weight:bold">]&lt;/span>&lt;span style="color:#8f5902;font-style:italic"># env | grep randomVar&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>~&lt;span style="color:#ce5c00;font-weight:bold">]&lt;/span>&lt;span style="color:#8f5902;font-style:italic"># echo $randomVar&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ~&lt;span style="color:#ce5c00;font-weight:bold">]&lt;/span>&lt;span style="color:#8f5902;font-style:italic"># echo $?&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#0000cf;font-weight:bold">0&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>可以看到，一个不存在的变量依然可以正常输出，只不过值为空。&lt;/p>
&lt;h2 id="赋值语句">赋值语句&lt;a class="td-heading-self-link" href="#%e8%b5%8b%e5%80%bc%e8%af%ad%e5%8f%a5" aria-label="Heading self-link">&lt;/a>&lt;/h2>
&lt;p>&lt;strong>VarName=VALUE&lt;/strong>&lt;/p>
&lt;p>如果未给出值，则为变量分配空字符串。&lt;/p>
&lt;p>赋值语句也可以作为 &lt;strong>alias&lt;/strong>, &lt;strong>declare&lt;/strong>, &lt;strong>typeset&lt;/strong>, &lt;strong>export&lt;/strong>, &lt;strong>readonly&lt;/strong>, &lt;strong>local&lt;/strong> 内置命令（声明命令）的参数出现&lt;/p>
&lt;h2 id="局部变量-1">局部变量&lt;a class="td-heading-self-link" href="#%e5%b1%80%e9%83%a8%e5%8f%98%e9%87%8f-1" aria-label="Heading self-link">&lt;/a>&lt;/h2>
&lt;p>直接使用&lt;a href="#%E8%B5%8B%E5%80%BC%E8%AF%AD%E5%8F%A5">赋值语句&lt;/a>的方式即可声明一个变量并为该变量赋值。&lt;/p>
&lt;p>&lt;strong>给变量赋予默认值&lt;/strong>&lt;/p>
&lt;p>&lt;code>VarName=${VarName:=VALUE}&lt;/code> # 如果 VarName 不空，则其值不变；否则，VarName 会使用 VALUE 作为其默认值&lt;/p>
&lt;h2 id="环境变量-1">环境变量&lt;a class="td-heading-self-link" href="#%e7%8e%af%e5%a2%83%e5%8f%98%e9%87%8f-1" aria-label="Heading self-link">&lt;/a>&lt;/h2>
&lt;p>使用 &lt;a href="https://desistdaydream.github.io/docs/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/4.Terminal%20%E4%B8%8E%20Shell/Bash/Bash%20%E5%86%85%E7%BD%AE%E5%91%BD%E4%BB%A4/%E5%8F%98%E9%87%8F%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7.md#export">export&lt;/a> 或 &lt;a href="https://desistdaydream.github.io/docs/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/4.Terminal%20%E4%B8%8E%20Shell/Bash/Bash%20%E5%86%85%E7%BD%AE%E5%91%BD%E4%BB%A4/%E5%8F%98%E9%87%8F%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7.md#declare">declare&lt;/a> 命令可以声明环境变量。&lt;/p>
&lt;h2 id="注意事项">注意事项&lt;a class="td-heading-self-link" href="#%e6%b3%a8%e6%84%8f%e4%ba%8b%e9%a1%b9" aria-label="Heading self-link">&lt;/a>&lt;/h2>
&lt;p>注意：如果想要给 &lt;code>$PATH&lt;/code> 变量增加内容，则需要用命令 &lt;code>PATH=$PATH:/NAM E/NAME&lt;/code>，如果前面不加 &lt;code>$PATH&lt;/code>，那么这个变量就等于被改写成 &lt;code>/NAME/NAME&lt;/code>，这点在修改变量时候尤为重要，必须要在定义 PATH 的引入本身已经定义好的 &lt;code>$PATH&lt;/code>&lt;/p>
&lt;h1 id="引用变量">引用变量&lt;a class="td-heading-self-link" href="#%e5%bc%95%e7%94%a8%e5%8f%98%e9%87%8f" aria-label="Heading self-link">&lt;/a>&lt;/h1>
&lt;p>Linux 中，普通变量与环境变量的引用方式相同。引用变量有两种写法&lt;/p>
&lt;ul>
&lt;li>&lt;code>$VAR_NAME&lt;/code>&lt;/li>
&lt;li>&lt;code>${VAR_NAME}&lt;/code>&lt;/li>
&lt;/ul>
&lt;p>推荐使用第二种方法，两种方法的差别如下：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>~&lt;span style="color:#ce5c00;font-weight:bold">]&lt;/span>&lt;span style="color:#8f5902;font-style:italic"># name=&amp;#39;hello DesistDaydream!&amp;#39;; name=&amp;#34;$nameceshi&amp;#34;; echo $name&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8f5902;font-style:italic"># 这里输出为空，不是手打的回车&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>~&lt;span style="color:#ce5c00;font-weight:bold">]&lt;/span>&lt;span style="color:#8f5902;font-style:italic"># name=&amp;#39;hello DesistDaydream!&amp;#39;; name=&amp;#34;${name}ceshi&amp;#34;; echo $name&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>hello DesistDaydream!ceshi
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>我们还可以把命令的执行结果赋值给变量,使用 &lt;code>$(COMMAND)&lt;/code> 方式&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>~&lt;span style="color:#ce5c00;font-weight:bold">]&lt;/span>&lt;span style="color:#8f5902;font-style:italic"># time=$(date)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>~&lt;span style="color:#ce5c00;font-weight:bold">]&lt;/span>&lt;span style="color:#8f5902;font-style:italic"># echo $time&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>2020年 08月 28日 星期五 12:44:46 CST
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>变量的拼接&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>~&lt;span style="color:#ce5c00;font-weight:bold">]&lt;/span>&lt;span style="color:#8f5902;font-style:italic"># name=&amp;#34;小明&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>~&lt;span style="color:#ce5c00;font-weight:bold">]&lt;/span>&lt;span style="color:#8f5902;font-style:italic"># echo $name&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>小明
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>~&lt;span style="color:#ce5c00;font-weight:bold">]&lt;/span>&lt;span style="color:#8f5902;font-style:italic"># name=$name&amp;#34;和老王&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>~&lt;span style="color:#ce5c00;font-weight:bold">]&lt;/span>&lt;span style="color:#8f5902;font-style:italic"># echo $name&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>小明和老王
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>~&lt;span style="color:#ce5c00;font-weight:bold">]&lt;/span>&lt;span style="color:#8f5902;font-style:italic"># name=&amp;#34;${name}在一起&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>~&lt;span style="color:#ce5c00;font-weight:bold">]&lt;/span>&lt;span style="color:#8f5902;font-style:italic"># echo $name&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>小明和老王在一起
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>删除变量&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>~&lt;span style="color:#ce5c00;font-weight:bold">]&lt;/span>&lt;span style="color:#8f5902;font-style:italic"># name=&amp;#39;hello Desist Daydream!&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>~&lt;span style="color:#ce5c00;font-weight:bold">]&lt;/span>&lt;span style="color:#8f5902;font-style:italic"># echo ${name}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>hello Desist Daydream!
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>~&lt;span style="color:#ce5c00;font-weight:bold">]&lt;/span>&lt;span style="color:#8f5902;font-style:italic"># unset name&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>~&lt;span style="color:#ce5c00;font-weight:bold">]&lt;/span>&lt;span style="color:#8f5902;font-style:italic"># echo ${name}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>~&lt;span style="color:#ce5c00;font-weight:bold">]&lt;/span>&lt;span style="color:#8f5902;font-style:italic">#&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h1 id="bash-自带的变量">Bash 自带的变量&lt;a class="td-heading-self-link" href="#bash-%e8%87%aa%e5%b8%a6%e7%9a%84%e5%8f%98%e9%87%8f" aria-label="Heading self-link">&lt;/a>&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://www.man7.org/linux/man-pages/man1/bash.1.html#PARAMETERS">Manual(手册),bash(1)，形参-&lt;/a>Shell 变量&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>&lt;strong>EDITOR=STRING&lt;/strong> # 当 Bash 需要调用编辑器时，使用该变量指定的编辑器。&lt;/p>
&lt;p>&lt;strong>IFS=STRING&lt;/strong> # (Internal Field Separator)输入字段分隔符。&lt;code>默认值：IFS 包含空格、制表符和回车&lt;/code>。&lt;/p>
&lt;ul>
&lt;li>Bash 会根据 IFS 中定义的字符来进行字符串拆分。效果如下：&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>~&lt;span style="color:#ce5c00;font-weight:bold">]&lt;/span>&lt;span style="color:#8f5902;font-style:italic"># map=(a,b c)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>~&lt;span style="color:#ce5c00;font-weight:bold">]&lt;/span>&lt;span style="color:#8f5902;font-style:italic"># echo ${map[0]}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>a,b
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>~&lt;span style="color:#ce5c00;font-weight:bold">]&lt;/span>&lt;span style="color:#8f5902;font-style:italic"># IFS=, &amp;amp;&amp;amp; echo ${map[0]}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>a b
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;strong>PATH=&amp;lt;STRING&amp;gt;&lt;/strong> # 命令的搜索路径。以 &lt;code>:&lt;/code> 分隔的目录列表，bash 执行命令时将会从 $PATH 中查找用户输入的命令，以便执行这些命令，如果在 $PATH 中无法找到，则无法执行。&lt;code>默认值：取决于操作系统&lt;/code>，通常都是 &lt;code>/usr/local/bin:/usr/local/sbin:/usr/bin:/usr/sbin:/bin:/sbin&lt;/code>&lt;/p>
&lt;ul>
&lt;li>在 bash 的源码(&lt;code>[./config-top.h](https://git.savannah.gnu.org/cgit/bash.git/tree/config-top.h)&lt;/code>)中，我们可以看到 PATH 变量的默认值由 DEFAULT_PATH_VALUE 定义：&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-c" data-lang="c">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8f5902;font-style:italic">/* The default value of the PATH variable. */&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8f5902;font-style:italic">#ifndef DEFAULT_PATH_VALUE
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8f5902;font-style:italic">#define DEFAULT_PATH_VALUE \
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8f5902;font-style:italic"> &amp;#34;/usr/local/bin:/usr/local/sbin:/usr/bin:/usr/sbin:/bin:/sbin:.&amp;#34;
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8f5902;font-style:italic">#endif
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ul>
&lt;li>我们也可以在系统中通过 &lt;code>env -i bash -c 'echo &amp;quot;$PATH&amp;quot;'&lt;/code> 命令获取 bash 的 $PATH 变量的默认值&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>TMOUT=INT&lt;/strong> # Bash 在指定 INT 秒后未操作，则自动登出。&lt;code>默认值：空&lt;/code>&lt;/p>
&lt;ul>
&lt;li>如果设置为大于零的值，则 TMOUT 被视为读取内置的默认超时。当输入来自终端时，如果输入在指定的 X 秒后仍未到达，则 select 命令终止。在交互式 shell 中，该值被解释为发出主提示后等待一行输入的秒数。如果完整的输入行未到达，则 Bash 在等待该秒数后终止。&lt;/li>
&lt;/ul>
&lt;h2 id="历史记录相关变量">历史记录相关变量&lt;a class="td-heading-self-link" href="#%e5%8e%86%e5%8f%b2%e8%ae%b0%e5%bd%95%e7%9b%b8%e5%85%b3%e5%8f%98%e9%87%8f" aria-label="Heading self-link">&lt;/a>&lt;/h2>
&lt;p>详见 &lt;a href="https://desistdaydream.github.io/docs/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/4.Terminal%20%E4%B8%8E%20Shell/Bash/Bash%20%E6%93%8D%E4%BD%9C%E5%8E%86%E5%8F%B2%E8%AE%B0%E5%BD%95.md">Bash 操作历史记录&lt;/a>&lt;/p>
&lt;h2 id="提示符相关变量">提示符相关变量&lt;a class="td-heading-self-link" href="#%e6%8f%90%e7%a4%ba%e7%ac%a6%e7%9b%b8%e5%85%b3%e5%8f%98%e9%87%8f" aria-label="Heading self-link">&lt;/a>&lt;/h2>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>Manual(手册)，Bash(1)-Prompting&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>&lt;strong>Prompting(提示符)&lt;/strong> 是我们使用 Bash 时，Bash 提供给我们的一些提示信息，用以告诉我们当前正在做的事情以及可以做的事情。&lt;/p>
&lt;p>当 Bash 在进行交互式执行时，当它准备读取一条命令时，会显示主提示 PS1，当它需要更多的输入来完成命令时，会显示次要提示 PS2。在读取命令但还未执行之前，Bash 显示 PS0。当启用 -x 选项进行追踪时，Bash 会像上面描述的那样显示 PS4。&lt;/p>
&lt;p>Bash 允许通过插入多个反斜杠转义的特殊字符来自定义这些提示字符串，如下所示进行解码：&lt;/p>
&lt;ul>
&lt;li>&lt;strong>&lt;code>\u&lt;/code>&lt;/strong> # 用户名&lt;/li>
&lt;li>&lt;strong>&lt;code>\h&lt;/code>&lt;/strong> # 主机名 建议在\h 值之后有一个空格。从个人角度来讲，使用这个空格可以增加一定的可读性。&lt;/li>
&lt;li>&lt;strong>&lt;code>\w&lt;/code>&lt;/strong> # 当前目录的完整路径。请注意当你在主目录下的时候，如上面所示只会显示～&lt;/li>
&lt;/ul>
&lt;h3 id="ps1默认提示符">PS1——默认提示符&lt;a class="td-heading-self-link" href="#ps1%e9%bb%98%e8%ae%a4%e6%8f%90%e7%a4%ba%e7%ac%a6" aria-label="Heading self-link">&lt;/a>&lt;/h3>
&lt;p>如下所示，可以通过修改 Linux 下的默认提示符，使其更加实用。在下面的例子中，默认的 PS1 的值是“\s-\v$”,显示出了 shell 的名称的版本。我们通过修改，可以使其显示用户名、主机名和当前工作目录。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>-bash-3.2$ &lt;span style="color:#204a87">export&lt;/span> &lt;span style="color:#000">PS1&lt;/span>&lt;span style="color:#ce5c00;font-weight:bold">=&lt;/span>&lt;span style="color:#4e9a06">&amp;#34;\u@\h \w&amp;gt; &amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>ramesh@dev-db ~&amp;gt; &lt;span style="color:#204a87">cd&lt;/span> /etc/mail
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>ramesh@dev-db /etc/mail&amp;gt;
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>这里将提示符修改为 &amp;ldquo;username@hostname current-dir&amp;gt;的形式&lt;/p>
&lt;p>&lt;strong>EXAMPLE&lt;/strong>&lt;/p>
&lt;p>好看的提示符样式&lt;/p>
&lt;p>&lt;code>export PS1=&amp;quot;[\[\e[34;1m\]\u@\[\e[0m\]\[\e[32;1m\]\H\[\e[0m\] \[\e[31;1m\]\w\[\e[0m\]]\\$ &amp;quot;&lt;/code>&lt;/p>
&lt;blockquote>
&lt;p>这个配置可以直接修改 &lt;code>~/.bashrc&lt;/code> 文件中的 &lt;code>$PS1&lt;/code> 变量即可&lt;/p>
&lt;/blockquote>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/ic2gz0/1628044442278-702aab5e-f50e-40f9-924a-e00528d1dbff.png" alt="image.png">&lt;/p>
&lt;h3 id="ps2再谈提示符">PS2——再谈提示符&lt;a class="td-heading-self-link" href="#ps2%e5%86%8d%e8%b0%88%e6%8f%90%e7%a4%ba%e7%ac%a6" aria-label="Heading self-link">&lt;/a>&lt;/h3>
&lt;p>一个非常长的命令可以通过在末尾加 `` 使其分行显示。多行命令的默认提示符是 &lt;code>&amp;gt;&lt;/code>。 我们可以通过修改 PS2 ，将提示符修改为&amp;quot;ABC&amp;rdquo; 。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>~&lt;span style="color:#ce5c00;font-weight:bold">]&lt;/span>&lt;span style="color:#8f5902;font-style:italic"># ls \&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&amp;gt; ^C
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>~&lt;span style="color:#ce5c00;font-weight:bold">]&lt;/span>&lt;span style="color:#8f5902;font-style:italic"># PS2=&amp;#34;ABC&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>~&lt;span style="color:#ce5c00;font-weight:bold">]&lt;/span>&lt;span style="color:#8f5902;font-style:italic"># ls \&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>ABC^C
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>当用“\”使长命令分行显示，我发现非常易读。当然我也见过有的人不喜欢分行显示命令&lt;/p>
&lt;h3 id="ps3--shell-脚本中使用-select-时的提示符">PS3 # Shell 脚本中使用 select 时的提示符&lt;a class="td-heading-self-link" href="#ps3--shell-%e8%84%9a%e6%9c%ac%e4%b8%ad%e4%bd%bf%e7%94%a8-select-%e6%97%b6%e7%9a%84%e6%8f%90%e7%a4%ba%e7%ac%a6" aria-label="Heading self-link">&lt;/a>&lt;/h3>
&lt;p>你可以像下面示范的那样，用环境变量 PS3 定制 shell 脚本的 select 提示：&lt;/p>
&lt;p>不使用 PS3 的脚本输出:&lt;/p>
&lt;p>cat ps3.sh&lt;/p>
&lt;p>执行脚本如下==&amp;gt;&lt;/p>
&lt;p>[注: 缺省的提示符是 #?]&lt;/p>
&lt;p>使用 PS3 的脚本输出：&lt;/p>
&lt;p>加了一句提示脚本,更加的友好了&lt;/p>
&lt;h3 id="ps4--ps4-set--x用来修改跟踪输出的前缀">PS4 # PS4-“set -x&amp;quot;用来修改跟踪输出的前缀&lt;a class="td-heading-self-link" href="#ps4--ps4-set--x%e7%94%a8%e6%9d%a5%e4%bf%ae%e6%94%b9%e8%b7%9f%e8%b8%aa%e8%be%93%e5%87%ba%e7%9a%84%e5%89%8d%e7%bc%80" aria-label="Heading self-link">&lt;/a>&lt;/h3>
&lt;p>如果你像下面那样在调试模式下的脚本中，PS4 环境变量可以定制提示信息：&lt;/p>
&lt;p>没有设置 PS4 时的 shell 脚本输出:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>~&lt;span style="color:#ce5c00;font-weight:bold">]&lt;/span>&lt;span style="color:#8f5902;font-style:italic"># cat ps4.sh&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#204a87">set&lt;/span> -x
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#204a87">echo&lt;/span> &lt;span style="color:#4e9a06">&amp;#34;PS4 demo script&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>ls -l /root/&lt;span style="color:#000;font-weight:bold">|&lt;/span>wc -l
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>[注: 当使用 sex -x 跟踪输出时的提示符为 ++]&lt;/p>
&lt;p>设置 PS4 后的脚本输出:&lt;/p>
&lt;p>PS4 在 ps.sh 中定义了下面两个变量&lt;/p>
&lt;p>o $0 显示当前的脚本名&lt;/p>
&lt;p>o $LINENO 显示的当前的行号&lt;/p>
&lt;p>在 ps4.sh 脚本最顶层加一行这个==========&amp;gt;&lt;/p>
&lt;p>输出的效果如下===&amp;gt;&lt;/p>
&lt;p>如下图所示效果==&amp;gt;&lt;/p>
&lt;p>[注: 使用 PS4 后使 &amp;ldquo;{script-name}.{line-number}+&amp;rdquo; 成为 set –x 的命令提示符]&lt;/p>
&lt;h2 id="特殊变量">特殊变量&lt;a class="td-heading-self-link" href="#%e7%89%b9%e6%ae%8a%e5%8f%98%e9%87%8f" aria-label="Heading self-link">&lt;/a>&lt;/h2>
&lt;p>&lt;strong>位置变量&lt;/strong>：&lt;code>$0&lt;/code> 该脚本所在的绝对路径 &lt;code>$1&lt;/code> 脚本的第一个参数 &lt;code>$2&lt;/code>&amp;hellip;..等等&lt;/p>
&lt;ul>
&lt;li>&lt;code>$数字&lt;/code> # 是位置参数的用法。如果运行脚本的时候带参数，那么可以在脚本里通过 $1 获取第一个参数，$2 获取第二个参数&amp;hellip;&amp;hellip;依此类推，一共可以直接获取 9 个参数（称为位置参数）。$0 用于获取脚本名称。相应地，如果 $+数字 用在函数里，那么表示获取函数的传入参数，$0 表示函数名。
&lt;ul>
&lt;li>&lt;code>$0&lt;/code> # 该脚本所在的绝对路径&lt;/li>
&lt;li>&lt;code>$1&lt;/code> # 脚本的第一个参数&lt;/li>
&lt;li>&lt;code>$2&lt;/code> # 脚本的第二个参数&lt;/li>
&lt;li>&amp;hellip;..等等&lt;/li>
&lt;li>比如：
&lt;ul>
&lt;li>./test.sh a b c # 运行该脚本时候，a 就是变量 $1(第一个参数)，b 就是变量 $2(第二个参数)，变量 $# 为 3,一共 3 个位置参数&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>其他位置参数：
&lt;ul>
&lt;li>&lt;code>$#&lt;/code> # 位置变量的个数&lt;/li>
&lt;li>&lt;code>$*&lt;/code> # 引用所有的位置参数，引用后就是显示或者执行引用的字符串&lt;/li>
&lt;li>&lt;code>$@&lt;/code> # 引用所有的位置参数，引用后就是显示或者执行引用的字符串&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>特殊变量&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>$? # 上一条命令执行的结果的返回值，成功为 0，失败为不为 0&lt;/li>
&lt;li>&lt;code>$$&lt;/code> # 当前 shell 的 PID 号&lt;/li>
&lt;li>$! # Shell 最后运行的后台进程的 PID&lt;/li>
&lt;/ul>
&lt;h1 id="操作变量的高级技巧">操作变量的高级技巧&lt;a class="td-heading-self-link" href="#%e6%93%8d%e4%bd%9c%e5%8f%98%e9%87%8f%e7%9a%84%e9%ab%98%e7%ba%a7%e6%8a%80%e5%b7%a7" aria-label="Heading self-link">&lt;/a>&lt;/h1>
&lt;h2 id="使用---符号的功能来处理变量中的字符串">使用 &lt;code>${ }&lt;/code> 符号的功能来处理变量中的字符串&lt;a class="td-heading-self-link" href="#%e4%bd%bf%e7%94%a8---%e7%ac%a6%e5%8f%b7%e7%9a%84%e5%8a%9f%e8%83%bd%e6%9d%a5%e5%a4%84%e7%90%86%e5%8f%98%e9%87%8f%e4%b8%ad%e7%9a%84%e5%ad%97%e7%ac%a6%e4%b8%b2" aria-label="Heading self-link">&lt;/a>&lt;/h2>
&lt;p>在日常使用变量中，经常会需要对变量中的值进行操作，比如删除、替换、截取等等。通过&lt;code>${ }&lt;/code>符号，就可以对指定变量中的值进行各种操作&lt;/p>
&lt;p>想要处理字符串，通常有如下几种方式：&lt;/p>
&lt;ul>
&lt;li>从指定位置截取字符串
&lt;ul>
&lt;li>&lt;code>${VARIABLE:START:LENGTH}&lt;/code> # 从 VARIABLE 值的 左边 起第 START 个字符开始，向右截取 LENGTH 个字符&lt;/li>
&lt;li>&lt;code>${VARIABLE:0-START:LENGTH}&lt;/code> # 从 VARIABLE 值的 右边 起第 START 个字符开始，向右截取 LENGTH 个字符&lt;/li>
&lt;li>Note：
&lt;ul>
&lt;li>:LENGTH 可省略。省略的话表示截取到变量值的末尾&lt;/li>
&lt;li>从左边开始计数时，起始数字是 0（这符合程序员思维）；从右边开始计数时，起始数字是 1（这符合常人思维）。计数方向不同，起始数字也不同。&lt;/li>
&lt;li>左数和右数的区别就是其实位置那个位置有没有 0- 这个标识符&lt;/li>
&lt;li>不管从哪边开始计数，截取方向都是从左到右。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>从指定字符串处截取字符串
&lt;ul>
&lt;li>&lt;code>${VARIABLE#*CHARS}&lt;/code> # 从左边开始到第一个 CHARS 为止的字符全部忽略，只留下右边的所有字符&lt;/li>
&lt;li>&lt;code>${VARIABLE##*CHARS}&lt;/code> # 从左边开始到最后一个 CHARS 为止的字符全部忽略，只留下右边的所有字符&lt;/li>
&lt;li>&lt;code>${VARIABLE%CHARS*}&lt;/code> # 从右边开始到第一个 CHARS 为止的字符全部忽略，只留下左边的所有字符&lt;/li>
&lt;li>&lt;code>${VARIABLE%%CHARS*}&lt;/code> # 从右边开始到最后一个 CHARS 为止的字符全部忽略，只留下左边的所有字符&lt;/li>
&lt;li>Note:
&lt;ul>
&lt;li>截取时，CHARS 不被包含在内。CHARS 可以是一个字符，也可以是一个字符串，当作一个整体看待，不要把 CHARS 拆开。当 CHARS 为字符时，则在计数开始时，表示从出现该字符串整体开始算。&lt;/li>
&lt;li>&lt;code>-&lt;/code> 符号只是一个通配符，可以省略。上面的语法中的 * 就是表示 CHARS 左侧或者右侧的所有字符&lt;/li>
&lt;li>比如 &lt;code>${VARIABLE%%CHARS*}&lt;/code> 其实就是删掉从右数最后一个 CHARS 右侧的所有字符&lt;/li>
&lt;li>这种截取方式无法指定字符串长度。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>替换变量中匹配到的字符串
&lt;ul>
&lt;li>&lt;code>${VARIABLE/OldChars/NewChars}&lt;/code> # 将 VARIABLE 值中匹配到第一个的 OldChars 替换为 NewChars&lt;/li>
&lt;li>&lt;code>${VARIABLE//OldChars/NewChars}&lt;/code> # 将 VARIABLE 值中匹配到所有的 OldChars 替换为 NewChars&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>获取变量值的长度
&lt;ul>
&lt;li>&lt;code>${#VARIABLE}&lt;/code> # 变量名前加 # 符号&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>EXAMPLE&lt;/strong>&lt;/p>
&lt;p>&lt;strong>从指定位置截取字符串&lt;/strong>&lt;/p>
&lt;p>&lt;code>export split='www.desistdaydream.com'&lt;/code>&lt;/p>
&lt;ul>
&lt;li>&lt;code>echo ${split:4:14}&lt;/code> # 从第四位字符开始(包括第四位)，一共截取14个字符。由于第一个字符是0号位置，所以第四位字符，按照人类的理解应该是第五个字符。&lt;/li>
&lt;li>输出结果：desistdaydream&lt;/li>
&lt;li>echo ${split:4} # 省略 length，截取到字符串末尾&lt;/li>
&lt;li>输出结果：desistdaydream.com&lt;/li>
&lt;li>&lt;code>echo ${split: 0-18: 14}&lt;/code> # 从右边数，b是第 13 个字符。&lt;/li>
&lt;li>输出结果：desistdaydream&lt;/li>
&lt;li>&lt;code>echo ${split: 0-18}&lt;/code> # 省略 length，直接截取到字符串末尾&lt;/li>
&lt;li>输出结果：desistdaydream.com&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>从指定字符串处截取字符串&lt;/strong>&lt;/p>
&lt;p>&lt;code>split=&amp;quot;http://www.desistdaydream.com/index.html&amp;quot;&lt;/code>&lt;/p>
&lt;ul>
&lt;li>&lt;code>echo ${split#*/}&lt;/code> # 也可以写为 &lt;code>${split#*p:/}&lt;/code> 或 &lt;code>${split#http:/}&lt;/code>，效果相同。注意带 * 和不带 * 的区别。
&lt;ul>
&lt;li>输出结果：/www.desistdaydream.com/index.html&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;code>echo ${split##*/}&lt;/code>&lt;/li>
&lt;li>输出结果：index.html&lt;/li>
&lt;li>&lt;code>echo ${split%/*}&lt;/code>&lt;/li>
&lt;li>输出结果：&lt;a href="http://www.desistdaydream.com">http://www.desistdaydream.com&lt;/a>&lt;/li>
&lt;li>&lt;code>echo ${split%%/*}&lt;/code>&lt;/li>
&lt;li>输出结果：http:&lt;/li>
&lt;/ul>
&lt;h2 id="使用-eval-命令让变量的值作为另一个变量的变量名">使用 eval 命令让变量的值作为另一个变量的变量名&lt;a class="td-heading-self-link" href="#%e4%bd%bf%e7%94%a8-eval-%e5%91%bd%e4%bb%a4%e8%ae%a9%e5%8f%98%e9%87%8f%e7%9a%84%e5%80%bc%e4%bd%9c%e4%b8%ba%e5%8f%a6%e4%b8%80%e4%b8%aa%e5%8f%98%e9%87%8f%e7%9a%84%e5%8f%98%e9%87%8f%e5%90%8d" aria-label="Heading self-link">&lt;/a>&lt;/h2>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>root@lichenhao:~# &lt;span style="color:#000">varname&lt;/span>&lt;span style="color:#ce5c00;font-weight:bold">=&lt;/span>name
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>root@lichenhao:~# &lt;span style="color:#000">name&lt;/span>&lt;span style="color:#ce5c00;font-weight:bold">=&lt;/span>lichenhao
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>root@lichenhao:~# &lt;span style="color:#204a87">echo&lt;/span> &lt;span style="color:#000">$$&lt;/span>varname
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>209409varname
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>root@lichenhao:~# &lt;span style="color:#204a87">echo&lt;/span> &lt;span style="color:#4e9a06">&amp;#39;$&amp;#39;&lt;/span>&lt;span style="color:#000">$varname&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#000">$name&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>root@lichenhao:~# &lt;span style="color:#204a87">eval&lt;/span> &lt;span style="color:#204a87">echo&lt;/span> &lt;span style="color:#4e9a06">&amp;#39;$&amp;#39;&lt;/span>&lt;span style="color:#000">$varname&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>lichenhao
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div></description></item><item><title>Docs: Bash 操作历史记录</title><link>https://desistdaydream.github.io/docs/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/4.Terminal-%E4%B8%8E-Shell/Bash/Bash-%E6%93%8D%E4%BD%9C%E5%8E%86%E5%8F%B2%E8%AE%B0%E5%BD%95/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/4.Terminal-%E4%B8%8E-Shell/Bash/Bash-%E6%93%8D%E4%BD%9C%E5%8E%86%E5%8F%B2%E8%AE%B0%E5%BD%95/</guid><description>
&lt;h1 id="history-工具">history 工具&lt;a class="td-heading-self-link" href="#history-%e5%b7%a5%e5%85%b7" aria-label="Heading self-link">&lt;/a>&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://www.man7.org/linux/man-pages/man3/history.3.html">Manual(手册),history&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://blog.csdn.net/m0_38020436/article/details/78730631">https://blog.csdn.net/m0_38020436/article/details/78730631&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://blog.csdn.net/sz_bdqn/article/details/46527021">https://blog.csdn.net/sz_bdqn/article/details/46527021&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>history 工具可以通过如下几个 Bash 的环境变量来配置运行方式&lt;/p>
&lt;ul>
&lt;li>&lt;strong>HISTTIMEFORMAT&lt;/strong> # 历史记录的格式&lt;/li>
&lt;li>&lt;strong>HISTSIZE&lt;/strong> # 历史记录可以保留的最大命令数&lt;/li>
&lt;li>&lt;strong>HISTFILESIZE&lt;/strong> # 历史记录可以保留的最大行数&lt;/li>
&lt;li>&lt;strong>HISTCONTROL&lt;/strong> #&lt;/li>
&lt;/ul>
&lt;h2 id="应用示例">应用示例&lt;a class="td-heading-self-link" href="#%e5%ba%94%e7%94%a8%e7%a4%ba%e4%be%8b" aria-label="Heading self-link">&lt;/a>&lt;/h2>
&lt;ul>
&lt;li>export HISTTIMEFORMAT=&amp;quot;%Y-%m-%d:%H-%M-%S:&lt;code>whoami&lt;/code>: &amp;quot;&lt;/li>
&lt;li>持久化&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span> cat &amp;gt; /etc/profile.d/custom_ops.sh &lt;span style="color:#4e9a06">&amp;lt;&amp;lt;END
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#4e9a06">export HISTTIMEFORMAT=&amp;#34;%Y-%m-%d %H:%M:%S `whoami` &amp;#34;
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#4e9a06">END&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h1 id="谁动了我的主机-之活用-history-命令">谁动了我的主机? 之活用 History 命令&lt;a class="td-heading-self-link" href="#%e8%b0%81%e5%8a%a8%e4%ba%86%e6%88%91%e7%9a%84%e4%b8%bb%e6%9c%ba-%e4%b9%8b%e6%b4%bb%e7%94%a8-history-%e5%91%bd%e4%bb%a4" aria-label="Heading self-link">&lt;/a>&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="http://lab.xmirror.cn/2017/05/26/sdlwdzj/">http://lab.xmirror.cn/2017/05/26/sdlwdzj/&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>Linux 系统下可通过 history 命令查看用户所有的历史操作记录，在安全应急响应中起着非常重要的作用，但在未进行附加配置情况下，history 命令只能查看用户历史操作记录，并不能区分用户以及操作时间，不便于审计分析。&lt;/p>
&lt;p>当然，一些不好的操作习惯也可能通过命令历史泄露敏感信息。&lt;/p>
&lt;p>下面我们来介绍如何让 history 日志记录更细化，更便于我们审计分析。&lt;/p>
&lt;h3 id="1命令历史记录中加时间">1、命令历史记录中加时间&lt;a class="td-heading-self-link" href="#1%e5%91%bd%e4%bb%a4%e5%8e%86%e5%8f%b2%e8%ae%b0%e5%bd%95%e4%b8%ad%e5%8a%a0%e6%97%b6%e9%97%b4" aria-label="Heading self-link">&lt;/a>&lt;/h3>
&lt;p>默认情况下如下图所示，没有命令执行时间，不利于审计分析。&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/ieek6o/1616165148137-f9789cc5-18b7-4fef-9319-70bcf57795e7.jpeg" alt="">&lt;/p>
&lt;p>通过设置 export HISTTIMEFORMAT=&amp;rsquo;%F %T &amp;lsquo;，让历史记录中带上命令执行时间。&lt;/p>
&lt;p>注意”%T”和后面的”’”之间有空格，不然查看历史记录的时候，时间和命令之间没有分割。&lt;/p>
&lt;p>要一劳永逸，这个配置可以写在/etc/profile 中，当然如果要对指定用户做配置，这个配置可以写在/home/$USER/.bash_profile 中。&lt;/p>
&lt;p>本文将以/etc/profile 为例进行演示。&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/ieek6o/1616165148161-a02cf695-ebc3-4678-83bf-0dbb6a605411.jpeg" alt="">&lt;/p>
&lt;p>要使配置立即生效请执行 source /etc/profile，我们再查看 history 记录，可以看到记录中带上了命令执行时间。&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/ieek6o/1616165148125-d672b6e4-155b-43e0-90cf-4c34f4b15fd7.jpeg" alt="">&lt;/p>
&lt;p>如果想要实现更细化的记录，比如登陆过系统的用户、IP 地址、操作命令以及操作时间一一对应，可以通过在/etc/profile 里面加入以下代码实现&lt;/p>
&lt;p>export HISTTIMEFORMAT=&amp;quot;%F %T&lt;code>who -u am i 2&amp;gt;/dev/null| awk '{print $NF}'|sed -e 's/[()]//g'whoami&lt;/code> &amp;ldquo;，注意空格都是必须的。&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/ieek6o/1616165148147-39797dc0-8f2b-4481-8a11-521ad0d3be06.jpeg" alt="">&lt;/p>
&lt;p>修改/etc/profile 并加载后，history 记录如下，时间、IP、用户及执行的命令都一一对应。&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/ieek6o/1616165148143-0955f121-58ad-4cc4-a350-c2103b8cb990.jpeg" alt="">&lt;/p>
&lt;p>通过以上配置，我们基本上可以满足日常的审计工作了，但了解系统的朋友应该很容易看出来，这种方法只是设置了环境变量，攻击者 unset 掉这个环境变量，或者直接删除命令历史，对于安全应急来说，这无疑是一个灾难。&lt;/p>
&lt;p>针对这样的问题，我们应该如何应对，下面才是我们今天的重点，通过修改 bash 源码，让 history 记录通过 syslog 发送到远程 logserver 中，大大增加了攻击者对 history 记录完整性破坏的难度。&lt;/p>
&lt;h3 id="2修改-bash-源码支持-syslog-记录">2、修改 bash 源码，支持 syslog 记录&lt;a class="td-heading-self-link" href="#2%e4%bf%ae%e6%94%b9-bash-%e6%ba%90%e7%a0%81%e6%94%af%e6%8c%81-syslog-%e8%ae%b0%e5%bd%95" aria-label="Heading self-link">&lt;/a>&lt;/h3>
&lt;p>首先下载 bash 源码，可以从 gnu.org 下载，这里不做详细说明了，系统需要安装 gcc 等编译环境。我们用 bash4.4 版本做演示。&lt;/p>
&lt;p>修改源码：bashhist.c
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/ieek6o/1616165148122-2898b5a5-b861-491b-ac1a-201aa6403243.jpeg" alt="">
修改源码 config-top.h，取消/#define SYSLOG_HISTORY/这行的注释
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/ieek6o/1616165148162-6b252c51-d8d8-4f98-9ad2-a67e574db7f6.jpeg" alt="">
编译安装，编译过程不做详细说明，本文中使用的编译参数为： ./configure &amp;ndash;prefix=/usr/local/bash，安装成功后对应目录如下：
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/ieek6o/1616165148144-a4bcb15d-3f39-477d-bd7f-1167d58f615d.jpeg" alt="">
此时可以修改/etc/passwd 中用户 shell 环境，也可以用编译好的文件直接替换原有的 bash 二进制文件，但最好对原文件做好备份。&lt;/p>
&lt;p>替换时要注意两点:&lt;/p>
&lt;blockquote>
&lt;p>1、一定要给可执行权限，默认是有的，不过有时候下载到 windows 系统后，再上传就没有可执行权限了，这里一定要确定，不然你会后悔的；2、替换时原 bash 被占用，可以修改原用户的 bash 环境后再进行替换。&lt;/p>
&lt;/blockquote>
&lt;p>查看效果，我们发现 history 记录已经写到了/var/log/message 中。
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/ieek6o/1616165148170-cb8d9280-1422-4701-95f3-2cdd4da96b59.jpeg" alt="">
如果要写到远程 logserver，需要配置 syslog 服务，具体配置这里不做详细讲解，大家自己研究，发送到远端 logserver 效果如下图所示。
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/ieek6o/1616165148152-c4072293-34eb-489d-ba93-70e05632e218.jpeg" alt="">
通过以上手段，可以有效保证 history 记录的完整性，避免攻击者登录系统后，通过取消环境变量、删除 history 记录等方式抹掉操作行为，为安全审计、应急响应等提供了完整的原始数据。&lt;/p>
&lt;h1 id="linux-系统监控记录用户操作轨迹谁动过服务器">linux 系统监控：记录用户操作轨迹，谁动过服务器&lt;a class="td-heading-self-link" href="#linux-%e7%b3%bb%e7%bb%9f%e7%9b%91%e6%8e%a7%e8%ae%b0%e5%bd%95%e7%94%a8%e6%88%b7%e6%93%8d%e4%bd%9c%e8%bd%a8%e8%bf%b9%e8%b0%81%e5%8a%a8%e8%bf%87%e6%9c%8d%e5%8a%a1%e5%99%a8" aria-label="Heading self-link">&lt;/a>&lt;/h1>
&lt;blockquote>
&lt;p>&lt;strong>参考：&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://blog.51cto.com/ganbing/2053636">https://blog.51cto.com/ganbing/2053636&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>&lt;strong>1、前言&lt;/strong>&lt;/p>
&lt;p>我们在实际工作当中，都碰到过误操作、误删除、误修改过配置文件等等事件。对于没有堡垒机的公司来说，要在 linux 系统上深究到底谁做过配置文件的修改、做过误删除是很头疼的事情，特别是遇到删库跑路的事件，更头大了。当然你可以通过 history 来查看历史命令记录，如果把 history 记录涂抹掉了，是不是啥也看不到了，如果你想查看在某个时间段到底是谁通过 vim 编辑过某个文件呢？&lt;/p>
&lt;p>那么，有什么办法可以看见这些操作呢，答案是一定有的，具体怎么实现呢，linux script 命令正有如此强大的功能，可以满足我们的需求，script 可以记录终端会话，只要是 linux6.3 以上的系统，都会自带 script 命令，下面我用 centos 7 系统来测试一下。&lt;/p>
&lt;p>&lt;strong>2、配置&lt;/strong>&lt;/p>
&lt;p>&lt;strong>2.1 验证 script 命令（我这里是有的）&lt;/strong>&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ce5c00;font-weight:bold">[&lt;/span>root@localhost ~&lt;span style="color:#ce5c00;font-weight:bold">]&lt;/span>&lt;span style="color:#8f5902;font-style:italic"># which script&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>/usr/bin/script
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;strong>2.2 配置 profile 文件，在末尾添加如下内容：&lt;/strong>&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ce5c00;font-weight:bold">[&lt;/span>root@localhost ~&lt;span style="color:#ce5c00;font-weight:bold">]&lt;/span>&lt;span style="color:#8f5902;font-style:italic"># vim /etc/profile&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#204a87;font-weight:bold">if&lt;/span> &lt;span style="color:#ce5c00;font-weight:bold">[&lt;/span> &lt;span style="color:#000">$UID&lt;/span> -ge &lt;span style="color:#0000cf;font-weight:bold">0&lt;/span> &lt;span style="color:#ce5c00;font-weight:bold">]&lt;/span>&lt;span style="color:#000;font-weight:bold">;&lt;/span> &lt;span style="color:#204a87;font-weight:bold">then&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#204a87">exec&lt;/span> /usr/bin/script -t 2&amp;gt;/var/log/script/&lt;span style="color:#000">$USER&lt;/span>-&lt;span style="color:#000">$UID&lt;/span>-&lt;span style="color:#4e9a06">`&lt;/span>date +%Y%m%d%H%M&lt;span style="color:#4e9a06">`&lt;/span>.date -a -f -q /var/log/script/&lt;span style="color:#000">$USER&lt;/span>-&lt;span style="color:#000">$UID&lt;/span>-&lt;span style="color:#4e9a06">`&lt;/span>date +%Y%m%d%H%M&lt;span style="color:#4e9a06">`&lt;/span>.log
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#204a87;font-weight:bold">fi&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>  -t　　　 指明输出录制的时间数据
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>    -f     如果需要在输出到日志文件的同时，也可以查看日志文件的内容，可以使用 -f 参数。PS:可以用于教学,两个命令行接-f可以实时演示
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>    -a     输出录制的文件，在现有内容上追加新的内容
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>    -q     可以使script命令以静默模式运行
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>如下图所示：&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/ieek6o/1647416324069-ae3a5928-f2d8-417c-a761-082d0c58a7fd.png" alt="image.png">&lt;/p>
&lt;p>说明：&lt;/p>
&lt;p>用户登录执行的操作都会记录到/var/log/script/*.log  里（保存日志的目录根据你自己定义），我们可以通过 more、vi 等命令查看目录里的日志。&lt;/p>
&lt;p>注意：&lt;/p>
&lt;ul>
&lt;li>我这里把用户 ID 大于 0 的都记录下来了，你可以重新登录用户，随便操作一些命令，查看生成的文件。&lt;/li>
&lt;li>root 用户的 ID 为 0，新建普通用户的 UID 是从 500 开始的(通过 cat /etc/password 可以查看用户的 UID)，如果你不想记录 root 用户的操作，你把 if 里面的值改成 500：  if [ $UID - ge 500 ];&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>2.3 创建目录、赋予权限&lt;/strong>&lt;/p>
&lt;p>你是不是以为写了这条 if 语句在/etc/profile 文件中就完事了，目录都没创建呢：&lt;/p>
&lt;p>&lt;strong>2.4 使环境生效&lt;/strong>&lt;/p>
&lt;p>3、验证&lt;/p>
&lt;p>好了，你可以退出 linux 终端，在重新登录一下，然后随便敲几个命令来看看。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ce5c00;font-weight:bold">[&lt;/span>root@localhost ~&lt;span style="color:#ce5c00;font-weight:bold">]&lt;/span>&lt;span style="color:#8f5902;font-style:italic"># cd /var/log/script/&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ce5c00;font-weight:bold">[&lt;/span>root@localhost script&lt;span style="color:#ce5c00;font-weight:bold">]&lt;/span>&lt;span style="color:#8f5902;font-style:italic"># ll&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>total &lt;span style="color:#0000cf;font-weight:bold">16&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>-rw-r--r-- &lt;span style="color:#0000cf;font-weight:bold">1&lt;/span> root root &lt;span style="color:#0000cf;font-weight:bold">68&lt;/span> Dec &lt;span style="color:#0000cf;font-weight:bold">22&lt;/span> 15:46 root-0-201712221545.date
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>-rw-r--r-- &lt;span style="color:#0000cf;font-weight:bold">1&lt;/span> root root &lt;span style="color:#0000cf;font-weight:bold">111&lt;/span> Dec &lt;span style="color:#0000cf;font-weight:bold">22&lt;/span> 15:46 root-0-201712221545.log
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>-rw-r--r-- &lt;span style="color:#0000cf;font-weight:bold">1&lt;/span> root root &lt;span style="color:#0000cf;font-weight:bold">0&lt;/span> Dec &lt;span style="color:#0000cf;font-weight:bold">22&lt;/span> 15:46 root-0-201712221546.date
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>-rw-r--r-- &lt;span style="color:#0000cf;font-weight:bold">1&lt;/span> root root &lt;span style="color:#0000cf;font-weight:bold">5693&lt;/span> Dec &lt;span style="color:#0000cf;font-weight:bold">22&lt;/span> 15:46 root-0-201712221546.log
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>从上图可以看到，在/var/log/script 目录中，已经产生了 log 和 data 为后缀的文件，并且还看到了 root 用户和 UID 号 0。&lt;/p>
&lt;p>.log：记录了操作&lt;/p>
&lt;p>.data：可以回放操作&lt;/p>
&lt;p>我们用 scriptreplay 来回放一下操作，看下效果如何：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ce5c00;font-weight:bold">[&lt;/span>root@localhost script&lt;span style="color:#ce5c00;font-weight:bold">]&lt;/span>&lt;span style="color:#8f5902;font-style:italic"># scriptreplay root-0-201712221545.date root-0-201712221545.log&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;strong>注意：&lt;/strong> 先指定“时间文件 .data”，然后是“命令文件 .log”，不要颠倒了。&lt;/p>
&lt;p>以上就完也了记录用户的所有操作，并且还可以随时查看，相当于有回放功能，像录像一样，以后定位是谁的问题就好找原因了。&lt;/p></description></item><item><title>Docs: Bash 快捷键</title><link>https://desistdaydream.github.io/docs/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/4.Terminal-%E4%B8%8E-Shell/Bash/Bash-%E5%BF%AB%E6%8D%B7%E9%94%AE/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/4.Terminal-%E4%B8%8E-Shell/Bash/Bash-%E5%BF%AB%E6%8D%B7%E9%94%AE/</guid><description>
&lt;h1 id="概述">概述&lt;a class="td-heading-self-link" href="#%e6%a6%82%e8%bf%b0" aria-label="Heading self-link">&lt;/a>&lt;/h1>
&lt;p>快速编辑命令高效率输入&lt;/p>
&lt;p>并非大型软件或者 IDE 才有快捷键,shell 也有,如果能够熟练使用快捷键,做起事情来且不事半功倍。&lt;/p>
&lt;p>网上流传的快捷键在 xshell 下可能和菜单的快捷键 alt 啥的冲突&lt;/p>
&lt;p>我只说下 xshell 下和用的最多的&lt;/p>
&lt;p>光标部分总的来说就是移动,最常用的就四个:&lt;/p>
&lt;p>移动到行首和行尾部&lt;/p>
&lt;p>ctrl + a 行首&lt;/p>
&lt;p>ctrl + e 行末&lt;/p>
&lt;p>然后单词移动,xshell 下 alt 不起作用,esc+b/f 可以前后&lt;/p>
&lt;p>但是 ctrl+左/右也可以,所以建议单词之间移动使用:&lt;/p>
&lt;p>ctrl + ← 光标移动到前一个单词开头&lt;/p>
&lt;p>ctrl + → 光标移动到后一个单词结尾&lt;/p>
&lt;p>配合下面的 ctrl+w 或者 esc+d 来删除前后单词&lt;/p>
&lt;p>删除部分&lt;/p>
&lt;p>ctrl + u 删除当前光标左边所有内容&lt;/p>
&lt;p>ctrl + k 删除当前光标右边所有内容&lt;/p>
&lt;p>ctrl + w 删除当前光标到左边最近的一个空格(通常用来删除一个单词)&lt;/p>
&lt;p>esc + d 删除当前光标到右边最近的一个空格(通常用来删除一个单词)&lt;/p>
&lt;p>ctrl + y 粘贴上面删除的部分&lt;/p>
&lt;p>编辑部分&lt;/p>
&lt;p>esc + t 互换相邻的两个单词&lt;/p>
&lt;p>esc + u 大写当前单词&lt;/p>
&lt;p>esc + l 小写当前单词&lt;/p>
&lt;p>esc + c 大写当前字母&lt;/p>
&lt;p>esc + . 当前位置插入上一条命令的最后一个参数&lt;/p>
&lt;p>另外熟悉 vim 的话可以把 bash 的默认编辑器设置为 vim,set -o vi 后按下 esc 进入命令模式和 vim 一样操作&lt;/p>
&lt;p>默认的编辑器是 emacs,如果不是请 set -o emacs 设置回来&lt;/p>
&lt;p>还有关于感叹号的妙用,&lt;/p>
&lt;p>!xyz:3 表示上一条 xyz 命令的第三个参数&lt;/p></description></item><item><title>Docs: Bash 命令行参数处理</title><link>https://desistdaydream.github.io/docs/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/4.Terminal-%E4%B8%8E-Shell/Bash/Bash-%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%8F%82%E6%95%B0%E5%A4%84%E7%90%86/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/4.Terminal-%E4%B8%8E-Shell/Bash/Bash-%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%8F%82%E6%95%B0%E5%A4%84%E7%90%86/</guid><description>
&lt;h1 id="概述">概述&lt;a class="td-heading-self-link" href="#%e6%a6%82%e8%bf%b0" aria-label="Heading self-link">&lt;/a>&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://www.cnblogs.com/klb561/p/9211222.html">https://www.cnblogs.com/klb561/p/9211222.html&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://blog.csdn.net/qq_22203741/article/details/77671379">https://blog.csdn.net/qq_22203741/article/details/77671379&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;h1 id="shell-代码命令行选项与修传入参数处理">shell 代码命令行选项与修传入参数处理&lt;a class="td-heading-self-link" href="#shell-%e4%bb%a3%e7%a0%81%e5%91%bd%e4%bb%a4%e8%a1%8c%e9%80%89%e9%a1%b9%e4%b8%8e%e4%bf%ae%e4%bc%a0%e5%85%a5%e5%8f%82%e6%95%b0%e5%a4%84%e7%90%86" aria-label="Heading self-link">&lt;/a>&lt;/h1>
&lt;p>在编写 shell 程序时经常需要处理命令行参数，本文描述在 bash 下的命令行处理方式。&lt;/p>
&lt;p>选项与参数：&lt;/p>
&lt;p>如下命令行：&lt;/p>
&lt;p>./test.sh -f config.conf -v &amp;ndash;prefix=/home&lt;/p>
&lt;ul>
&lt;li>-f 为选项，它需要一个参数，即 config.conf&lt;/li>
&lt;li>-v 也是一个选项，但它不需要参数。&lt;/li>
&lt;li>&amp;ndash;prefix 我们称之为一个长选项，即选项本身多于一个字符，它也需要一个参数，用等号连接，当然等号不是必须的，/home 可以直接写在&amp;ndash;prefix 后面，即&amp;ndash;prefix/home,更多的限制后面具体会讲到。&lt;/li>
&lt;/ul>
&lt;p>在 bash 中，可以用以下三种方式来处理命令行参数，每种方式都有自己的应用场景。&lt;/p>
&lt;ul>
&lt;li>通过位置变量手工处理参数 # 参考变量与环境变量 文章中的位置变量&lt;/li>
&lt;li>getopts # 简单工具&lt;/li>
&lt;li>getopt # 复杂工具&lt;/li>
&lt;/ul>
&lt;p>依次讨论这三种处理方式。&lt;/p>
&lt;h1 id="通过位置变量手工处理参数">通过位置变量手工处理参数&lt;a class="td-heading-self-link" href="#%e9%80%9a%e8%bf%87%e4%bd%8d%e7%bd%ae%e5%8f%98%e9%87%8f%e6%89%8b%e5%b7%a5%e5%a4%84%e7%90%86%e5%8f%82%e6%95%b0" aria-label="Heading self-link">&lt;/a>&lt;/h1>
&lt;p>在手工处理方式中，首先要知道几个变量，还是以上面的命令行为例：&lt;/p>
&lt;p>代码如下:&lt;/p>
&lt;ul>
&lt;li>$0 ： ./test.sh,即命令本身，相当于 c/c++中的 argv[0]&lt;/li>
&lt;li>$1 ： -f,第一个参数.&lt;/li>
&lt;li>$2 ： config.conf&lt;/li>
&lt;li>$3, $4 &amp;hellip; ：类推。&lt;/li>
&lt;li>&lt;code>$#&lt;/code> 参数的个数，不包括命令本身，上例中 &lt;code>$#&lt;/code> 为 4.&lt;/li>
&lt;li>&lt;code>$@&lt;/code> # 参数本身的列表，也不包括命令本身，如上例为 -f config.conf -v &amp;ndash;prefix=/home&lt;/li>
&lt;li>&lt;code>$*&lt;/code> # 和 &lt;code>$@&lt;/code> 相同，但 &lt;code>&amp;quot;$*&amp;quot;&lt;/code> 和 &lt;code>&amp;quot;$@&amp;quot;&lt;/code>(加引号)并不同，&lt;code>&amp;quot;$*&amp;quot;&lt;/code> 将所有的参数解释成一个字符串，而 &lt;code>&amp;quot;$@&amp;quot;&lt;/code> 是一个参数数组。&lt;/li>
&lt;/ul>
&lt;p>例子：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8f5902;font-style:italic">#!/bin/bash
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8f5902;font-style:italic">&lt;/span>&lt;span style="color:#204a87;font-weight:bold">for&lt;/span> arg in &lt;span style="color:#4e9a06">&amp;#34;&lt;/span>&lt;span style="color:#000">$*&lt;/span>&lt;span style="color:#4e9a06">&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#204a87;font-weight:bold">do&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#204a87">echo&lt;/span> &lt;span style="color:#000">$arg&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#204a87;font-weight:bold">done&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#204a87;font-weight:bold">for&lt;/span> arg in &lt;span style="color:#4e9a06">&amp;#34;&lt;/span>&lt;span style="color:#000">$@&lt;/span>&lt;span style="color:#4e9a06">&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#204a87;font-weight:bold">do&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#204a87">echo&lt;/span> &lt;span style="color:#000">$arg&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#204a87;font-weight:bold">done&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>执行./test.sh -f config.conf -n 10 会打印：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>-f config.conf -n &lt;span style="color:#0000cf;font-weight:bold">10&lt;/span> &lt;span style="color:#8f5902;font-style:italic">#这是&amp;#34;$*&amp;#34;的输出&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>-f &lt;span style="color:#8f5902;font-style:italic">#以下为$@的输出&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>config.conf
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>-n
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#0000cf;font-weight:bold">10&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>所以，手工处理的方式即对这些变量的处理。因为手工处理高度依赖于你在命令行上所传参数的位置，所以一般都只用来处理较简单的参数。&lt;/p>
&lt;p>例如：&lt;/p>
&lt;p>./test.sh 10&lt;/p>
&lt;p>而很少使用./test -n 10 这种带选项的方式。 典型用法为：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8f5902;font-style:italic">#!/bin/bash
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8f5902;font-style:italic">&lt;/span>&lt;span style="color:#204a87;font-weight:bold">if&lt;/span> &lt;span style="color:#ce5c00;font-weight:bold">[&lt;/span> x&lt;span style="color:#000">$1&lt;/span> !&lt;span style="color:#ce5c00;font-weight:bold">=&lt;/span> x &lt;span style="color:#ce5c00;font-weight:bold">]&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#204a87;font-weight:bold">then&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#8f5902;font-style:italic">#...有参数&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#204a87;font-weight:bold">else&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#204a87;font-weight:bold">then&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#8f5902;font-style:italic">#...没有参数&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#204a87;font-weight:bold">fi&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>为什么要使用 &lt;code>x$1 != x&lt;/code> 这种方式来比较呢？想像一下这种方式比较：&lt;/p>
&lt;p>&lt;code>if [ -n $1 ]&lt;/code> #$1 不为空&lt;/p>
&lt;p>但如果用户不传参数的时候，$1 为空，这时 就会变成 [ -n ] ,所以需要加一个辅助字符串来进行比较。&lt;/p>
&lt;p>手工处理方式能满足大多数的简单需求，配合 shift 使用也能构造出强大的功能，但在要处理复杂选项的时候建议用下面的两种方法。&lt;/p>
&lt;h1 id="getoptsgetopt-工具">getopts/getopt 工具&lt;a class="td-heading-self-link" href="#getoptsgetopt-%e5%b7%a5%e5%85%b7" aria-label="Heading self-link">&lt;/a>&lt;/h1>
&lt;p>处理命令行参数是一个相似而又复杂的事情，为此 go 语言提供 cobra 库来实现，c++ 的 boost 提供了 options 库。&lt;/p>
&lt;p>在 shell 中，处理此事的是 getopts 和 getopt 工具。&lt;/p>
&lt;p>getopts 和 getopt 功能相似但又不完全相同，其中 getopt 是独立的可执行文件，而 getopts 是由 bash 内置的。&lt;/p>
&lt;p>先来看看参数传递的典型用法:&lt;/p>
&lt;pre>&lt;code>* ./test.sh -a -b -c ： 短选项，各选项不需参数
* ./test.sh -abc ： 短选项，和上一种方法的效果一样，只是将所有的选项写在一起。
* ./test.sh -a args -b -c ：短选项，其中-a需要参数，而-b -c不需参数。
* ./test.sh --a-long=args --b-long ：长选项
&lt;/code>&lt;/pre>
&lt;p>先来看 getopts,它不支持长选项。&lt;/p>
&lt;p>使用 getopts 非常简单，代码如下:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8f5902;font-style:italic">#test.sh&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8f5902;font-style:italic">#!/bin/bash&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#204a87;font-weight:bold">while&lt;/span> &lt;span style="color:#204a87">getopts&lt;/span> &lt;span style="color:#4e9a06">&amp;#34;a:bc&amp;#34;&lt;/span> arg&lt;span style="color:#000;font-weight:bold">;&lt;/span> &lt;span style="color:#204a87;font-weight:bold">do&lt;/span> &lt;span style="color:#8f5902;font-style:italic">#选项后面的冒号表示该选项需要参数&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#204a87;font-weight:bold">case&lt;/span> &lt;span style="color:#000">$arg&lt;/span> in
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> a&lt;span style="color:#ce5c00;font-weight:bold">)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#204a87">echo&lt;/span> &lt;span style="color:#4e9a06">&amp;#34;a&amp;#39;s arg:&lt;/span>&lt;span style="color:#000">$optarg&lt;/span>&lt;span style="color:#4e9a06">&amp;#34;&lt;/span> &lt;span style="color:#8f5902;font-style:italic">#参数存在$optarg中&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> b&lt;span style="color:#ce5c00;font-weight:bold">)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#204a87">echo&lt;/span> &lt;span style="color:#4e9a06">&amp;#34;b&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> c&lt;span style="color:#ce5c00;font-weight:bold">)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#204a87">echo&lt;/span> &lt;span style="color:#4e9a06">&amp;#34;c&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ?&lt;span style="color:#ce5c00;font-weight:bold">)&lt;/span> &lt;span style="color:#8f5902;font-style:italic">#当有不认识的选项的时候arg为?&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#204a87">echo&lt;/span> &lt;span style="color:#4e9a06">&amp;#34;unkonw argument&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#204a87">exit&lt;/span> &lt;span style="color:#0000cf;font-weight:bold">1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#204a87;font-weight:bold">esac&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#204a87;font-weight:bold">done&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>现在就可以使用：&lt;/p>
&lt;p>./test.sh -a arg -b -c&lt;/p>
&lt;p>或&lt;/p>
&lt;p>./test.sh -a arg -bc&lt;/p>
&lt;p>来加载了&lt;/p>
&lt;p>应该说绝大多数脚本使用该函数就可以了，如果需要支持长选项以及可选参数，那么就需要使用 getopt.&lt;/p>
&lt;h1 id="getopt">getopt&lt;a class="td-heading-self-link" href="#getopt" aria-label="Heading self-link">&lt;/a>&lt;/h1>
&lt;h2 id="syntax语法">Syntax(语法)&lt;a class="td-heading-self-link" href="#syntax%e8%af%ad%e6%b3%95" aria-label="Heading self-link">&lt;/a>&lt;/h2>
&lt;p>&lt;strong>getopt optstring parameters&lt;/strong>
&lt;strong>getopt [OPTIONS] [&amp;ndash;] optstring parameters&lt;/strong>
&lt;strong>getopt [OPTIONS] -o|&amp;ndash;options optstring [options] [&amp;ndash;] parameters&lt;/strong>&lt;/p>
&lt;p>OPTIONS&lt;/p>
&lt;ul>
&lt;li>-a, &amp;ndash;alternative Allow long options starting with single -&lt;/li>
&lt;li>-h, &amp;ndash;help This small usage guide&lt;/li>
&lt;li>-l, &amp;ndash;longoptions &amp;lt;LongOPTS&amp;gt; # 要被识别的长选项&lt;/li>
&lt;li>-n, &amp;ndash;name &amp;lt;progname&amp;gt; The name under which errors are reported&lt;/li>
&lt;li>-o, &amp;ndash;options &amp;lt;OPTString&amp;gt; # 要被识别的短选项&lt;/li>
&lt;li>-q, &amp;ndash;quiet Disable error reporting by getopt(3)&lt;/li>
&lt;li>-Q, &amp;ndash;quiet-output No normal output&lt;/li>
&lt;li>-s, &amp;ndash;shell &amp;lt;shell&amp;gt; Set shell quoting conventions&lt;/li>
&lt;li>-T, &amp;ndash;test Test for getopt(1) version&lt;/li>
&lt;li>-u, &amp;ndash;unquoted Do not quote the output&lt;/li>
&lt;li>-V, &amp;ndash;version Output version information&lt;/li>
&lt;/ul>
&lt;p>getopt 工具基本使用示例&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8f5902;font-style:italic">#!/bin/bash
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8f5902;font-style:italic">&lt;/span>&lt;span style="color:#8f5902;font-style:italic"># 请注意，我们使用 &amp;#34;$@&amp;#34; 来使每个命令行参数扩展为一个单独的单词。 $@ 周围的引号是必不可少的！&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8f5902;font-style:italic"># -o表示短选项，两个冒号表示该选项有一个可选参数，可选参数必须紧贴选项&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8f5902;font-style:italic"># 如-carg 而不能是-c arg&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8f5902;font-style:italic"># -l或--long选项后面接可接受的长选项，每个选项用逗号分开，冒号的意义同短选项。&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8f5902;font-style:italic"># -n:出错时的信息&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8f5902;font-style:italic"># -- ：举一个例子比较好理解：&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8f5902;font-style:italic">#我们要创建一个名字为 &amp;#34;-f&amp;#34;的目录你会怎么办？&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8f5902;font-style:italic"># mkdir -f # 不成功，因为-f会被mkdir当作选项来解析，这时就可以使用&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8f5902;font-style:italic"># mkdir -- -f 这样-f就不会被作为选项。&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8f5902;font-style:italic"># 我们需要使用 temp 作为`eval set-`来抵消getopt的返回值。&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#000">temp&lt;/span>&lt;span style="color:#ce5c00;font-weight:bold">=&lt;/span>&lt;span style="color:#4e9a06">`&lt;/span>getopt -o ab:c:: --long a-long,b-long:,c-long:: &lt;span style="color:#4e9a06">\
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#4e9a06">&lt;/span> -n &lt;span style="color:#4e9a06">&amp;#39;example.bash&amp;#39;&lt;/span> -- &lt;span style="color:#4e9a06">&amp;#34;&lt;/span>&lt;span style="color:#000">$@&lt;/span>&lt;span style="color:#4e9a06">&amp;#34;&lt;/span>&lt;span style="color:#4e9a06">`&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#204a87;font-weight:bold">if&lt;/span> &lt;span style="color:#ce5c00;font-weight:bold">[&lt;/span> &lt;span style="color:#000">$?&lt;/span> !&lt;span style="color:#ce5c00;font-weight:bold">=&lt;/span> &lt;span style="color:#0000cf;font-weight:bold">0&lt;/span> &lt;span style="color:#ce5c00;font-weight:bold">]&lt;/span> &lt;span style="color:#000;font-weight:bold">;&lt;/span> &lt;span style="color:#204a87;font-weight:bold">then&lt;/span> &lt;span style="color:#204a87">echo&lt;/span> &lt;span style="color:#4e9a06">&amp;#34;terminating...&amp;#34;&lt;/span> &amp;gt;&lt;span style="color:#000;font-weight:bold">&amp;amp;&lt;/span>&lt;span style="color:#0000cf;font-weight:bold">2&lt;/span> &lt;span style="color:#000;font-weight:bold">;&lt;/span> &lt;span style="color:#204a87">exit&lt;/span> &lt;span style="color:#0000cf;font-weight:bold">1&lt;/span> &lt;span style="color:#000;font-weight:bold">;&lt;/span> &lt;span style="color:#204a87;font-weight:bold">fi&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8f5902;font-style:italic"># 注意 $temp 周围的引号：它们是必不可少的！&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8f5902;font-style:italic"># set 会重新排列参数的顺序，也就是改变$1,$2...$n的值，这些值在getopt中重新排列过了&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#204a87">eval&lt;/span> &lt;span style="color:#204a87">set&lt;/span> -- &lt;span style="color:#4e9a06">&amp;#34;&lt;/span>&lt;span style="color:#000">$temp&lt;/span>&lt;span style="color:#4e9a06">&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8f5902;font-style:italic"># 经过getopt的处理，下面处理具体选项。&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#204a87;font-weight:bold">while&lt;/span> &lt;span style="color:#204a87">true&lt;/span> &lt;span style="color:#000;font-weight:bold">;&lt;/span> &lt;span style="color:#204a87;font-weight:bold">do&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#204a87;font-weight:bold">case&lt;/span> &lt;span style="color:#4e9a06">&amp;#34;&lt;/span>&lt;span style="color:#000">$1&lt;/span>&lt;span style="color:#4e9a06">&amp;#34;&lt;/span> in
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> -a&lt;span style="color:#000;font-weight:bold">|&lt;/span>--a-long&lt;span style="color:#ce5c00;font-weight:bold">)&lt;/span> &lt;span style="color:#204a87">echo&lt;/span> &lt;span style="color:#4e9a06">&amp;#34;option a&amp;#34;&lt;/span> &lt;span style="color:#000;font-weight:bold">;&lt;/span> &lt;span style="color:#204a87">shift&lt;/span> &lt;span style="color:#000;font-weight:bold">;;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> -b&lt;span style="color:#000;font-weight:bold">|&lt;/span>--b-long&lt;span style="color:#ce5c00;font-weight:bold">)&lt;/span> &lt;span style="color:#204a87">echo&lt;/span> &lt;span style="color:#4e9a06">&amp;#34;option b, argument \`&lt;/span>&lt;span style="color:#000">$2&lt;/span>&lt;span style="color:#4e9a06">&amp;#39;&amp;#34;&lt;/span> &lt;span style="color:#000;font-weight:bold">;&lt;/span> &lt;span style="color:#204a87">shift&lt;/span> &lt;span style="color:#0000cf;font-weight:bold">2&lt;/span> &lt;span style="color:#000;font-weight:bold">;;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> -c&lt;span style="color:#000;font-weight:bold">|&lt;/span>--c-long&lt;span style="color:#ce5c00;font-weight:bold">)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#8f5902;font-style:italic"># c 有一个可选参数。 由于我们处于引用模式，如果找不到可选参数，则会生成一个空参数。&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#204a87;font-weight:bold">case&lt;/span> &lt;span style="color:#4e9a06">&amp;#34;&lt;/span>&lt;span style="color:#000">$2&lt;/span>&lt;span style="color:#4e9a06">&amp;#34;&lt;/span> in
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#4e9a06">&amp;#34;&amp;#34;&lt;/span>&lt;span style="color:#ce5c00;font-weight:bold">)&lt;/span> &lt;span style="color:#204a87">echo&lt;/span> &lt;span style="color:#4e9a06">&amp;#34;option c, no argument&amp;#34;&lt;/span>&lt;span style="color:#000;font-weight:bold">;&lt;/span> &lt;span style="color:#204a87">shift&lt;/span> &lt;span style="color:#0000cf;font-weight:bold">2&lt;/span> &lt;span style="color:#000;font-weight:bold">;;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> *&lt;span style="color:#ce5c00;font-weight:bold">)&lt;/span> &lt;span style="color:#204a87">echo&lt;/span> &lt;span style="color:#4e9a06">&amp;#34;option c, argument \`&lt;/span>&lt;span style="color:#000">$2&lt;/span>&lt;span style="color:#4e9a06">&amp;#39;&amp;#34;&lt;/span> &lt;span style="color:#000;font-weight:bold">;&lt;/span> &lt;span style="color:#204a87">shift&lt;/span> &lt;span style="color:#0000cf;font-weight:bold">2&lt;/span> &lt;span style="color:#000;font-weight:bold">;;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#204a87;font-weight:bold">esac&lt;/span> &lt;span style="color:#000;font-weight:bold">;;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> --&lt;span style="color:#ce5c00;font-weight:bold">)&lt;/span> &lt;span style="color:#204a87">shift&lt;/span> &lt;span style="color:#000;font-weight:bold">;&lt;/span> &lt;span style="color:#204a87">break&lt;/span> &lt;span style="color:#000;font-weight:bold">;;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> *&lt;span style="color:#ce5c00;font-weight:bold">)&lt;/span> &lt;span style="color:#204a87">echo&lt;/span> &lt;span style="color:#4e9a06">&amp;#34;internal error!&amp;#34;&lt;/span> &lt;span style="color:#000;font-weight:bold">;&lt;/span> &lt;span style="color:#204a87">exit&lt;/span> &lt;span style="color:#0000cf;font-weight:bold">1&lt;/span> &lt;span style="color:#000;font-weight:bold">;;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#204a87;font-weight:bold">esac&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#204a87;font-weight:bold">done&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#204a87">echo&lt;/span> &lt;span style="color:#4e9a06">&amp;#34;remaining arguments:&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#204a87;font-weight:bold">for&lt;/span> arg &lt;span style="color:#204a87;font-weight:bold">do&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#204a87">echo&lt;/span> &lt;span style="color:#4e9a06">&amp;#39;--&amp;gt; &amp;#39;&lt;/span>&lt;span style="color:#4e9a06">&amp;#34;\`&lt;/span>&lt;span style="color:#000">$arg&lt;/span>&lt;span style="color:#4e9a06">&amp;#39;&amp;#34;&lt;/span> &lt;span style="color:#000;font-weight:bold">;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#204a87;font-weight:bold">done&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>上述代码会循环处理参数，每处理一个参数，就用 shift 命令剔除，直到所有参数全部处理完，则跳出循环&lt;/p>
&lt;p>执行效果如下：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>./parse.bash -a par1 &lt;span style="color:#4e9a06">&amp;#39;another arg&amp;#39;&lt;/span> --c-long &lt;span style="color:#4e9a06">&amp;#39;wow!*\?&amp;#39;&lt;/span> -cmore -b &lt;span style="color:#4e9a06">&amp;#34; very long &amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>option a
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>option c, no argument
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>option c, argument &lt;span style="color:#4e9a06">`&lt;/span>more&lt;span style="color:#4e9a06">&amp;#39;
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#4e9a06">option b, argument ` very long &amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>remaining arguments:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>--&amp;gt; &lt;span style="color:#4e9a06">`&lt;/span>par1&lt;span style="color:#4e9a06">&amp;#39;
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#4e9a06">--&amp;gt; `another arg&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>--&amp;gt; &lt;span style="color:#4e9a06">`&lt;/span>wow!*&lt;span style="color:#4e9a06">\?&lt;/span>&lt;span style="color:#a40000">&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>比如使用&lt;/p>
&lt;p>./test -a -b arg arg1 -c&lt;/p>
&lt;p>你可以看到,命令行中多了个 arg1 参数，在经过 getopt 和 set 之后，命令行会变为：&lt;/p>
&lt;p>-a -b arg -c &amp;ndash; arg1&lt;/p>
&lt;p>$1 指向 -a,$2 指向 -b,$3 指向 arg,$4 指向 -c,$5 指向 &amp;ndash;,而多出的 arg1 则被放到了最后。&lt;/p>
&lt;p>3，总结&lt;/p>
&lt;p>一般小脚本手工处理也就够了，getopts 能处理绝大多数的情况，getopt 较复杂，功能也更强大!/bin/bash&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#204a87;font-weight:bold">function&lt;/span> Help&lt;span style="color:#ce5c00;font-weight:bold">(){&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#204a87">echo&lt;/span> &lt;span style="color:#4e9a06">&amp;#39; ================================================================ &amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#204a87">echo&lt;/span> &lt;span style="color:#4e9a06">&amp;#39; 请使用下列 flags 来运行脚本，若无需改变默认值，使用 ./test.sh -- 即可；&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#204a87">echo&lt;/span> &lt;span style="color:#4e9a06">&amp;#39; 如果环境无互联网，则安装的docker版本根据离线包的版本决定，dockerversion参数无用；&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#204a87">echo&lt;/span> &lt;span style="color:#4e9a06">&amp;#39; --cgroupdriver: 指定 cgroupdrive 的类型，默认为 systemd；&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#204a87">echo&lt;/span> &lt;span style="color:#4e9a06">&amp;#39; --dockerversion: 指定要安装的 docer-ce 版本，默认为 19.03.11；&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#204a87">echo&lt;/span> &lt;span style="color:#4e9a06">&amp;#39; 使用示例:&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#204a87">echo&lt;/span> &lt;span style="color:#4e9a06">&amp;#39; ./test.sh --cgroupdriver=systemd --dockerversion=19.03.11&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#204a87">echo&lt;/span> &lt;span style="color:#4e9a06">&amp;#39; ================================================================&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ce5c00;font-weight:bold">}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#204a87;font-weight:bold">case&lt;/span> &lt;span style="color:#4e9a06">&amp;#34;&lt;/span>&lt;span style="color:#000">$1&lt;/span>&lt;span style="color:#4e9a06">&amp;#34;&lt;/span> in
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> -h&lt;span style="color:#000;font-weight:bold">|&lt;/span>--help&lt;span style="color:#ce5c00;font-weight:bold">)&lt;/span> Help&lt;span style="color:#000;font-weight:bold">;&lt;/span> exit&lt;span style="color:#000;font-weight:bold">;;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#204a87;font-weight:bold">esac&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#204a87;font-weight:bold">if&lt;/span> &lt;span style="color:#ce5c00;font-weight:bold">[[&lt;/span> &lt;span style="color:#000">$1&lt;/span> &lt;span style="color:#ce5c00;font-weight:bold">==&lt;/span> &lt;span style="color:#4e9a06">&amp;#39;&amp;#39;&lt;/span> &lt;span style="color:#ce5c00;font-weight:bold">||&lt;/span> ! &lt;span style="color:#000">$1&lt;/span> &lt;span style="color:#ce5c00;font-weight:bold">=&lt;/span>~ &lt;span style="color:#4e9a06">&amp;#39;--&amp;#39;&lt;/span> &lt;span style="color:#ce5c00;font-weight:bold">]]&lt;/span>&lt;span style="color:#000;font-weight:bold">;&lt;/span>&lt;span style="color:#204a87;font-weight:bold">then&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Help&lt;span style="color:#000;font-weight:bold">;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> exit&lt;span style="color:#000;font-weight:bold">;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#204a87;font-weight:bold">fi&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#000">CMDFLAGS&lt;/span>&lt;span style="color:#ce5c00;font-weight:bold">=&lt;/span>&lt;span style="color:#4e9a06">&amp;#34;&lt;/span>&lt;span style="color:#000">$*&lt;/span>&lt;span style="color:#4e9a06">&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#204a87;font-weight:bold">for&lt;/span> FLAGS in &lt;span style="color:#000">$CMDFLAGS&lt;/span>&lt;span style="color:#000;font-weight:bold">;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#204a87;font-weight:bold">do&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#000">key&lt;/span>&lt;span style="color:#ce5c00;font-weight:bold">=&lt;/span>&lt;span style="color:#204a87;font-weight:bold">$(&lt;/span>&lt;span style="color:#204a87">echo&lt;/span> &lt;span style="color:#4e9a06">${&lt;/span>&lt;span style="color:#000">FLAGS&lt;/span>&lt;span style="color:#4e9a06">}&lt;/span> &lt;span style="color:#000;font-weight:bold">|&lt;/span> awk -F&lt;span style="color:#4e9a06">&amp;#34;=&amp;#34;&lt;/span> &lt;span style="color:#4e9a06">&amp;#39;{print $1}&amp;#39;&lt;/span> &lt;span style="color:#204a87;font-weight:bold">)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#000">value&lt;/span>&lt;span style="color:#ce5c00;font-weight:bold">=&lt;/span>&lt;span style="color:#204a87;font-weight:bold">$(&lt;/span>&lt;span style="color:#204a87">echo&lt;/span> &lt;span style="color:#4e9a06">${&lt;/span>&lt;span style="color:#000">FLAGS&lt;/span>&lt;span style="color:#4e9a06">}&lt;/span> &lt;span style="color:#000;font-weight:bold">|&lt;/span> awk -F&lt;span style="color:#4e9a06">&amp;#34;=&amp;#34;&lt;/span> &lt;span style="color:#4e9a06">&amp;#39;{print $2}&amp;#39;&lt;/span> &lt;span style="color:#204a87;font-weight:bold">)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#204a87;font-weight:bold">case&lt;/span> &lt;span style="color:#4e9a06">&amp;#34;&lt;/span>&lt;span style="color:#000">$key&lt;/span>&lt;span style="color:#4e9a06">&amp;#34;&lt;/span> in
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> --cgroupdriver&lt;span style="color:#ce5c00;font-weight:bold">)&lt;/span> &lt;span style="color:#000">CgroupDriver&lt;/span>&lt;span style="color:#ce5c00;font-weight:bold">=&lt;/span>&lt;span style="color:#000">$value&lt;/span> &lt;span style="color:#000;font-weight:bold">;;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> --dockerversion&lt;span style="color:#ce5c00;font-weight:bold">)&lt;/span> &lt;span style="color:#000">DockerVersion&lt;/span>&lt;span style="color:#ce5c00;font-weight:bold">=&lt;/span>&lt;span style="color:#000">$value&lt;/span> &lt;span style="color:#000;font-weight:bold">;;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#204a87;font-weight:bold">esac&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#204a87;font-weight:bold">done&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8f5902;font-style:italic"># Docker 配置&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#000">CgroupDriver&lt;/span>&lt;span style="color:#ce5c00;font-weight:bold">=&lt;/span>&lt;span style="color:#4e9a06">${&lt;/span>&lt;span style="color:#000">CgroupDriver&lt;/span>&lt;span style="color:#204a87;font-weight:bold">:-&lt;/span>&lt;span style="color:#000">systemd&lt;/span>&lt;span style="color:#4e9a06">}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#000">DockerVersion&lt;/span>&lt;span style="color:#ce5c00;font-weight:bold">=&lt;/span>&lt;span style="color:#4e9a06">${&lt;/span>&lt;span style="color:#000">DockerVersion&lt;/span>&lt;span style="color:#204a87;font-weight:bold">:-&lt;/span>&lt;span style="color:#000">19&lt;/span>&lt;span style="color:#000;font-weight:bold">.03.11&lt;/span>&lt;span style="color:#4e9a06">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div></description></item><item><title>Docs: 函数</title><link>https://desistdaydream.github.io/docs/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/4.Terminal-%E4%B8%8E-Shell/Bash/%E5%87%BD%E6%95%B0/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/4.Terminal-%E4%B8%8E-Shell/Bash/%E5%87%BD%E6%95%B0/</guid><description>
&lt;h1 id="概述">概述&lt;a class="td-heading-self-link" href="#%e6%a6%82%e8%bf%b0" aria-label="Heading self-link">&lt;/a>&lt;/h1>
&lt;p>&lt;strong>Function(函数)&lt;/strong> 就是代码块，函数中表示了一堆代码的集合，当调用函数的时候，则会执行函数中函数体内的命令&lt;/p>
&lt;p>语法格式：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#204a87;font-weight:bold">function&lt;/span> NAME&lt;span style="color:#ce5c00;font-weight:bold">(){&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> 函数体
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ce5c00;font-weight:bold">}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8f5902;font-style:italic">###或者&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>NAME&lt;span style="color:#ce5c00;font-weight:bold">()&lt;/span> &lt;span style="color:#ce5c00;font-weight:bold">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> 函数体
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ce5c00;font-weight:bold">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>调用方式：在 shell 脚本中，函数并不会执行，只有在调用的时候，才会执行函数体中的命令&lt;/p>
&lt;ul>
&lt;li>直接使用函数名即可调用，函数名出现的地方，会被自动替换为函数体中的命令&lt;/li>
&lt;li>在调用函数时，传递参数给函数体，在函数名后面以空白分隔指定的参数列表即可。e.g.FunctionName ARG1 ARG2 &amp;hellip;ARGn
&lt;ul>
&lt;li>每个参数可以在函数体中使用位置参数进行引用，i.e.ARG1 在函数体中就是$1 的值，ARG2 在函数体中就是$2 的值，以此类推&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>函数的生命周期：被调用时创建，返回时终止&lt;/p>
&lt;p>使用 return 命令返回自定义状态结果&lt;/p>
&lt;ul>
&lt;li>0：成功&lt;/li>
&lt;li>1-255：失败&lt;/li>
&lt;/ul>
&lt;p>函数中的变量：在函数体内定义的变量只对该函数生效，当函数生命周期结束时，变量失效。&lt;/p>
&lt;p>注意：在函数体中，可以修改全局变量的值&lt;/p>
&lt;h1 id="函数的递归函数直接或间接调用自身">函数的递归：函数直接或间接调用自身&lt;a class="td-heading-self-link" href="#%e5%87%bd%e6%95%b0%e7%9a%84%e9%80%92%e5%bd%92%e5%87%bd%e6%95%b0%e7%9b%b4%e6%8e%a5%e6%88%96%e9%97%b4%e6%8e%a5%e8%b0%83%e7%94%a8%e8%87%aa%e8%ba%ab" aria-label="Heading self-link">&lt;/a>&lt;/h1>
&lt;p>函数递归的应用实例：&lt;/p>
&lt;h2 id="阶乘nnn-1n-21">阶乘：N!=N(n-1)(n-2)&amp;hellip;1&lt;a class="td-heading-self-link" href="#%e9%98%b6%e4%b9%98nnn-1n-21" aria-label="Heading self-link">&lt;/a>&lt;/h2>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8f5902;font-style:italic">#/bin/bash&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>fact&lt;span style="color:#ce5c00;font-weight:bold">()&lt;/span> &lt;span style="color:#ce5c00;font-weight:bold">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#204a87;font-weight:bold">if&lt;/span> &lt;span style="color:#ce5c00;font-weight:bold">[&lt;/span> &lt;span style="color:#000">$1&lt;/span> -eq &lt;span style="color:#0000cf;font-weight:bold">0&lt;/span> -o &lt;span style="color:#000">$1&lt;/span> -eq &lt;span style="color:#0000cf;font-weight:bold">1&lt;/span> &lt;span style="color:#ce5c00;font-weight:bold">]&lt;/span>&lt;span style="color:#000;font-weight:bold">;&lt;/span> &lt;span style="color:#204a87;font-weight:bold">then&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#204a87">echo&lt;/span> &lt;span style="color:#0000cf;font-weight:bold">1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#204a87;font-weight:bold">else&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#204a87">echo&lt;/span> $&lt;span style="color:#ce5c00;font-weight:bold">[&lt;/span>&lt;span style="color:#000">$1&lt;/span>*&lt;span style="color:#204a87;font-weight:bold">$(&lt;/span>fact $&lt;span style="color:#ce5c00;font-weight:bold">[&lt;/span>&lt;span style="color:#000">$1&lt;/span>-1&lt;span style="color:#ce5c00;font-weight:bold">]&lt;/span>&lt;span style="color:#204a87;font-weight:bold">)&lt;/span>&lt;span style="color:#ce5c00;font-weight:bold">]&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#204a87;font-weight:bold">fi&lt;/span>&lt;span style="color:#ce5c00;font-weight:bold">}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>fact &lt;span style="color:#000">$1&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>步骤：比如给 fact 传递参数 5&lt;/p>
&lt;ul>
&lt;li>如果 5 大于 0 或者大于 1，那么使用 &lt;code>5*fact&lt;/code> 函数，且再次调用函数时参数为 5-1&lt;/li>
&lt;li>再次调用函数的时候，不但有 4，还有函数，i.e.&lt;code>5*4*fact&lt;/code> 函数，直到函数的参数值为 1 或 0&lt;/li>
&lt;/ul></description></item><item><title>Docs: 控制结构</title><link>https://desistdaydream.github.io/docs/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/4.Terminal-%E4%B8%8E-Shell/Bash/%E6%8E%A7%E5%88%B6%E7%BB%93%E6%9E%84/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/4.Terminal-%E4%B8%8E-Shell/Bash/%E6%8E%A7%E5%88%B6%E7%BB%93%E6%9E%84/</guid><description/></item><item><title>Docs: 数组</title><link>https://desistdaydream.github.io/docs/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/4.Terminal-%E4%B8%8E-Shell/Bash/%E6%95%B0%E7%BB%84/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/4.Terminal-%E4%B8%8E-Shell/Bash/%E6%95%B0%E7%BB%84/</guid><description>
&lt;h1 id="概述">概述&lt;a class="td-heading-self-link" href="#%e6%a6%82%e8%bf%b0" aria-label="Heading self-link">&lt;/a>&lt;/h1>
&lt;p>&lt;strong>Array(数组)&lt;/strong> 也是一种变量，数组中可以存放多个值，每个值都称为该数组的元素。Bash Shell 只支持一维数组（不支持多维数组），初始化时不需要定义数组大小（与 PHP 类似）。&lt;/p>
&lt;p>与大部分编程语言类似，数组元素的下标由 0 开始。&lt;/p>
&lt;p>Shell 数组用括号来表示，元素用&amp;quot;空格&amp;quot;符号分割开，&lt;/p>
&lt;p>定义数组的方式：&lt;code>ArrayName=(Value1 ... ValueN)&lt;/code>&lt;/p>
&lt;h2 id="数组的赋值">数组的赋值&lt;a class="td-heading-self-link" href="#%e6%95%b0%e7%bb%84%e7%9a%84%e8%b5%8b%e5%80%bc" aria-label="Heading self-link">&lt;/a>&lt;/h2>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8f5902;font-style:italic">#!/bin/bash
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8f5902;font-style:italic">&lt;/span>&lt;span style="color:#000">my_array&lt;/span>&lt;span style="color:#ce5c00;font-weight:bold">=(&lt;/span>A B &lt;span style="color:#4e9a06">&amp;#34;C&amp;#34;&lt;/span> D&lt;span style="color:#ce5c00;font-weight:bold">)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>我们也可以使用下标来定义数组:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>array_name&lt;span style="color:#ce5c00;font-weight:bold">[&lt;/span>0&lt;span style="color:#ce5c00;font-weight:bold">]=&lt;/span>value0
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>array_name&lt;span style="color:#ce5c00;font-weight:bold">[&lt;/span>1&lt;span style="color:#ce5c00;font-weight:bold">]=&lt;/span>value1
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>array_name&lt;span style="color:#ce5c00;font-weight:bold">[&lt;/span>2&lt;span style="color:#ce5c00;font-weight:bold">]=&lt;/span>value2
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="数组的引用">数组的引用&lt;a class="td-heading-self-link" href="#%e6%95%b0%e7%bb%84%e7%9a%84%e5%bc%95%e7%94%a8" aria-label="Heading self-link">&lt;/a>&lt;/h2>
&lt;p>通过数组的下标来获取数组的值，数组中的第一位下标是 0，第二位下标是 2&amp;hellip;&amp;hellip;以此类推&lt;/p>
&lt;p>引用数组元素值的一般格式是：${array_name[index]} # index 是下标的数字&lt;/p>
&lt;p>实例&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8f5902;font-style:italic">#!/bin/bash
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8f5902;font-style:italic">&lt;/span>&lt;span style="color:#000">my_array&lt;/span>&lt;span style="color:#ce5c00;font-weight:bold">=(&lt;/span>A B &lt;span style="color:#4e9a06">&amp;#34;C&amp;#34;&lt;/span> D&lt;span style="color:#ce5c00;font-weight:bold">)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#204a87">echo&lt;/span> &lt;span style="color:#4e9a06">&amp;#34;第一个元素为: &lt;/span>&lt;span style="color:#4e9a06">${&lt;/span>&lt;span style="color:#000">my_array&lt;/span>&lt;span style="color:#000;font-weight:bold">[0]&lt;/span>&lt;span style="color:#4e9a06">}&lt;/span>&lt;span style="color:#4e9a06">&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#204a87">echo&lt;/span> &lt;span style="color:#4e9a06">&amp;#34;第二个元素为: &lt;/span>&lt;span style="color:#4e9a06">${&lt;/span>&lt;span style="color:#000">my_array&lt;/span>&lt;span style="color:#000;font-weight:bold">[1]&lt;/span>&lt;span style="color:#4e9a06">}&lt;/span>&lt;span style="color:#4e9a06">&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#204a87">echo&lt;/span> &lt;span style="color:#4e9a06">&amp;#34;第三个元素为: &lt;/span>&lt;span style="color:#4e9a06">${&lt;/span>&lt;span style="color:#000">my_array&lt;/span>&lt;span style="color:#000;font-weight:bold">[2]&lt;/span>&lt;span style="color:#4e9a06">}&lt;/span>&lt;span style="color:#4e9a06">&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#204a87">echo&lt;/span> &lt;span style="color:#4e9a06">&amp;#34;第四个元素为: &lt;/span>&lt;span style="color:#4e9a06">${&lt;/span>&lt;span style="color:#000">my_array&lt;/span>&lt;span style="color:#000;font-weight:bold">[3]&lt;/span>&lt;span style="color:#4e9a06">}&lt;/span>&lt;span style="color:#4e9a06">&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>执行脚本，输出结果如下所示：
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>$ chmod +x test.sh
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>$ ./test.sh
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>第一个元素为: A
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>第二个元素为: B
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>第三个元素为: C
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>第四个元素为: D
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="引用数组中指定的元素">引用数组中指定的元素&lt;a class="td-heading-self-link" href="#%e5%bc%95%e7%94%a8%e6%95%b0%e7%bb%84%e4%b8%ad%e6%8c%87%e5%ae%9a%e7%9a%84%e5%85%83%e7%b4%a0" aria-label="Heading self-link">&lt;/a>&lt;/h3>
&lt;p>参考 变量与系统环境配置详解 中变量的高级技巧一节，可以通过 ${ } 来截取数组中的元素&lt;/p>
&lt;pre>&lt;code># 该示例通过 ${VARIABLE:START:LENGTH} 方式，将数组左边起第一个元素开始，向右截取到末尾的所有元素，并 echo 出来。
my_arrays=(a b c d)
echo ${my_arrays[@]:1}
b c d
&lt;/code>&lt;/pre>
&lt;h3 id="引用数组中的所有元素">引用数组中的所有元素&lt;a class="td-heading-self-link" href="#%e5%bc%95%e7%94%a8%e6%95%b0%e7%bb%84%e4%b8%ad%e7%9a%84%e6%89%80%e6%9c%89%e5%85%83%e7%b4%a0" aria-label="Heading self-link">&lt;/a>&lt;/h3>
&lt;p>使用@ 或 * 可以获取数组中的所有元素，例如：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#000">my_arrays&lt;/span>&lt;span style="color:#ce5c00;font-weight:bold">=(&lt;/span>A B C D&lt;span style="color:#ce5c00;font-weight:bold">)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#204a87">echo&lt;/span> &lt;span style="color:#4e9a06">&amp;#34;数组的元素为: &lt;/span>&lt;span style="color:#4e9a06">${&lt;/span>&lt;span style="color:#000">my_arrays&lt;/span>&lt;span style="color:#000;font-weight:bold">[*]&lt;/span>&lt;span style="color:#4e9a06">}&lt;/span>&lt;span style="color:#4e9a06">&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>数组的元素为: A B C D
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#204a87">echo&lt;/span> &lt;span style="color:#4e9a06">&amp;#34;数组的元素为: &lt;/span>&lt;span style="color:#4e9a06">${&lt;/span>&lt;span style="color:#000">my_arrays&lt;/span>&lt;span style="color:#000;font-weight:bold">[@]&lt;/span>&lt;span style="color:#4e9a06">}&lt;/span>&lt;span style="color:#4e9a06">&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>数组的元素为: A B C D
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Note：&lt;/p>
&lt;ul>
&lt;li>&lt;code>-&lt;/code> # 当变量加上 “” 会当成一串字符串处理.&lt;/li>
&lt;li>&lt;code>@&lt;/code> # 变量加上 “” 依然当做数组处理.&lt;/li>
&lt;li>在没有加上 “” 的情况下 效果是等效的.&lt;/li>
&lt;/ul>
&lt;p>效果如下：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>~&lt;span style="color:#ce5c00;font-weight:bold">]&lt;/span>&lt;span style="color:#8f5902;font-style:italic"># cat array.sh&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8f5902;font-style:italic">#!/bin/bash&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#000">array&lt;/span>&lt;span style="color:#ce5c00;font-weight:bold">=(&lt;/span>&lt;span style="color:#4e9a06">&amp;#34;li chen hao&amp;#34;&lt;/span> &lt;span style="color:#4e9a06">&amp;#34;zhang_na&amp;#34;&lt;/span>&lt;span style="color:#ce5c00;font-weight:bold">)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#204a87;font-weight:bold">for&lt;/span> i in &lt;span style="color:#4e9a06">${&lt;/span>&lt;span style="color:#000">array&lt;/span>&lt;span style="color:#000;font-weight:bold">[@]&lt;/span>&lt;span style="color:#4e9a06">}&lt;/span>&lt;span style="color:#000;font-weight:bold">;&lt;/span> &lt;span style="color:#204a87;font-weight:bold">do&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#204a87">echo&lt;/span> &lt;span style="color:#4e9a06">&amp;#34;@符号无双引号:&amp;#34;&lt;/span>&lt;span style="color:#4e9a06">${&lt;/span>&lt;span style="color:#000">i&lt;/span>&lt;span style="color:#4e9a06">}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#204a87;font-weight:bold">done&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#204a87">echo&lt;/span> ------------
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#204a87;font-weight:bold">for&lt;/span> i in &lt;span style="color:#4e9a06">&amp;#34;&lt;/span>&lt;span style="color:#4e9a06">${&lt;/span>&lt;span style="color:#000">array&lt;/span>&lt;span style="color:#000;font-weight:bold">[@]&lt;/span>&lt;span style="color:#4e9a06">}&lt;/span>&lt;span style="color:#4e9a06">&amp;#34;&lt;/span>&lt;span style="color:#000;font-weight:bold">;&lt;/span> &lt;span style="color:#204a87;font-weight:bold">do&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#204a87">echo&lt;/span> &lt;span style="color:#4e9a06">&amp;#34;@符号有双引号:&amp;#34;&lt;/span>&lt;span style="color:#4e9a06">${&lt;/span>&lt;span style="color:#000">i&lt;/span>&lt;span style="color:#4e9a06">}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#204a87;font-weight:bold">done&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#204a87">echo&lt;/span> ------------
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#204a87;font-weight:bold">for&lt;/span> i in &lt;span style="color:#4e9a06">${&lt;/span>&lt;span style="color:#000">array&lt;/span>&lt;span style="color:#000;font-weight:bold">[*]&lt;/span>&lt;span style="color:#4e9a06">}&lt;/span>&lt;span style="color:#000;font-weight:bold">;&lt;/span> &lt;span style="color:#204a87;font-weight:bold">do&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#204a87">echo&lt;/span> &lt;span style="color:#4e9a06">&amp;#34;*符号无双引号:&amp;#34;&lt;/span>&lt;span style="color:#4e9a06">${&lt;/span>&lt;span style="color:#000">i&lt;/span>&lt;span style="color:#4e9a06">}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#204a87;font-weight:bold">done&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#204a87">echo&lt;/span> ------------
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#204a87;font-weight:bold">for&lt;/span> i in &lt;span style="color:#4e9a06">&amp;#34;&lt;/span>&lt;span style="color:#4e9a06">${&lt;/span>&lt;span style="color:#000">array&lt;/span>&lt;span style="color:#000;font-weight:bold">[*]&lt;/span>&lt;span style="color:#4e9a06">}&lt;/span>&lt;span style="color:#4e9a06">&amp;#34;&lt;/span>&lt;span style="color:#000;font-weight:bold">;&lt;/span> &lt;span style="color:#204a87;font-weight:bold">do&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#204a87">echo&lt;/span> &lt;span style="color:#4e9a06">&amp;#34;*符号有双引号:&amp;#34;&lt;/span>&lt;span style="color:#4e9a06">${&lt;/span>&lt;span style="color:#000">i&lt;/span>&lt;span style="color:#4e9a06">}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#204a87;font-weight:bold">done&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>~&lt;span style="color:#ce5c00;font-weight:bold">]&lt;/span>&lt;span style="color:#8f5902;font-style:italic"># bash array.sh&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>@符号无双引号:li
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>@符号无双引号:chen
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>@符号无双引号:hao
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>@符号无双引号:zhang_na
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>------------
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>@符号有双引号:li chen hao
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>@符号有双引号:zhang_na
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>------------
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>*符号无双引号:li
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>*符号无双引号:chen
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>*符号无双引号:hao
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>*符号无双引号:zhang_na
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>------------
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>*符号有双引号:li chen hao zhang_na
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="获取数组的长度">获取数组的长度&lt;a class="td-heading-self-link" href="#%e8%8e%b7%e5%8f%96%e6%95%b0%e7%bb%84%e7%9a%84%e9%95%bf%e5%ba%a6" aria-label="Heading self-link">&lt;/a>&lt;/h2>
&lt;p>数组的长度分两种情况，一种是数组元素的个数，另一种事数组元素的所有索引号&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#000">my_arrays&lt;/span>&lt;span style="color:#ce5c00;font-weight:bold">=(&lt;/span>A B C D&lt;span style="color:#ce5c00;font-weight:bold">)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#204a87">echo&lt;/span> &lt;span style="color:#4e9a06">&amp;#34;数组元素个数为: &lt;/span>&lt;span style="color:#4e9a06">${#&lt;/span>&lt;span style="color:#000">my_arrays&lt;/span>&lt;span style="color:#000;font-weight:bold">[*]&lt;/span>&lt;span style="color:#4e9a06">}&lt;/span>&lt;span style="color:#4e9a06">&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>数组元素个数为: &lt;span style="color:#0000cf;font-weight:bold">4&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#204a87">echo&lt;/span> &lt;span style="color:#4e9a06">&amp;#34;数组元素个数为: &lt;/span>&lt;span style="color:#4e9a06">${#&lt;/span>&lt;span style="color:#000">my_arrays&lt;/span>&lt;span style="color:#000;font-weight:bold">[@]&lt;/span>&lt;span style="color:#4e9a06">}&lt;/span>&lt;span style="color:#4e9a06">&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>数组元素个数为: &lt;span style="color:#0000cf;font-weight:bold">4&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#204a87">echo&lt;/span> &lt;span style="color:#4e9a06">&amp;#34;数组元素的索引号为: &lt;/span>&lt;span style="color:#4e9a06">${&lt;/span>&lt;span style="color:#000;font-weight:bold">!my_arrays[@]&lt;/span>&lt;span style="color:#4e9a06">}&lt;/span>&lt;span style="color:#4e9a06">&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>数组元素的索引号为: &lt;span style="color:#0000cf;font-weight:bold">0&lt;/span> &lt;span style="color:#0000cf;font-weight:bold">1&lt;/span> &lt;span style="color:#0000cf;font-weight:bold">2&lt;/span> &lt;span style="color:#0000cf;font-weight:bold">3&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="向数组中添加元素">向数组中添加元素&lt;a class="td-heading-self-link" href="#%e5%90%91%e6%95%b0%e7%bb%84%e4%b8%ad%e6%b7%bb%e5%8a%a0%e5%85%83%e7%b4%a0" aria-label="Heading self-link">&lt;/a>&lt;/h2>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8f5902;font-style:italic"># 在数组末尾添加元素&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>~&lt;span style="color:#ce5c00;font-weight:bold">]&lt;/span>&lt;span style="color:#8f5902;font-style:italic"># abc=(a b c)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>~&lt;span style="color:#ce5c00;font-weight:bold">]&lt;/span>&lt;span style="color:#8f5902;font-style:italic"># echo ${abc[@]}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>a b c
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>~&lt;span style="color:#ce5c00;font-weight:bold">]&lt;/span>&lt;span style="color:#8f5902;font-style:italic"># abc+=(d)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>~&lt;span style="color:#ce5c00;font-weight:bold">]&lt;/span>&lt;span style="color:#8f5902;font-style:italic"># echo ${abc[@]}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>a b c d
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8f5902;font-style:italic"># 向指定 index 位置添加元素&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>~&lt;span style="color:#ce5c00;font-weight:bold">]&lt;/span>&lt;span style="color:#8f5902;font-style:italic"># arrays=(a b c d)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>~&lt;span style="color:#ce5c00;font-weight:bold">]&lt;/span>&lt;span style="color:#8f5902;font-style:italic"># arrays[5]=f&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>~&lt;span style="color:#ce5c00;font-weight:bold">]&lt;/span>&lt;span style="color:#8f5902;font-style:italic"># echo ${arrays[@]}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>a b c d f
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>~&lt;span style="color:#ce5c00;font-weight:bold">]&lt;/span>&lt;span style="color:#8f5902;font-style:italic"># echo ${!arrays[@]}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#0000cf;font-weight:bold">0&lt;/span> &lt;span style="color:#0000cf;font-weight:bold">1&lt;/span> &lt;span style="color:#0000cf;font-weight:bold">2&lt;/span> &lt;span style="color:#0000cf;font-weight:bold">3&lt;/span> &lt;span style="color:#0000cf;font-weight:bold">5&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="删除数组中的元素">删除数组中的元素&lt;a class="td-heading-self-link" href="#%e5%88%a0%e9%99%a4%e6%95%b0%e7%bb%84%e4%b8%ad%e7%9a%84%e5%85%83%e7%b4%a0" aria-label="Heading self-link">&lt;/a>&lt;/h2>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>~&lt;span style="color:#ce5c00;font-weight:bold">]&lt;/span>&lt;span style="color:#8f5902;font-style:italic"># arrays=(a b c d)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>~&lt;span style="color:#ce5c00;font-weight:bold">]&lt;/span>&lt;span style="color:#8f5902;font-style:italic"># echo $arrays&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>a b c d
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>~&lt;span style="color:#ce5c00;font-weight:bold">]&lt;/span>&lt;span style="color:#8f5902;font-style:italic"># unset arrays[2]&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>~&lt;span style="color:#ce5c00;font-weight:bold">]&lt;/span>&lt;span style="color:#8f5902;font-style:italic"># echo ${arrays[@]}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>a b d
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>~&lt;span style="color:#ce5c00;font-weight:bold">]&lt;/span>&lt;span style="color:#8f5902;font-style:italic"># echo ${!arrays[@]}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#0000cf;font-weight:bold">0&lt;/span> &lt;span style="color:#0000cf;font-weight:bold">1&lt;/span> &lt;span style="color:#0000cf;font-weight:bold">3&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>~&lt;span style="color:#ce5c00;font-weight:bold">]&lt;/span>&lt;span style="color:#8f5902;font-style:italic"># arrays+=(c)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>~&lt;span style="color:#ce5c00;font-weight:bold">]&lt;/span>&lt;span style="color:#8f5902;font-style:italic"># echo ${!arrays[@]}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#0000cf;font-weight:bold">0&lt;/span> &lt;span style="color:#0000cf;font-weight:bold">1&lt;/span> &lt;span style="color:#0000cf;font-weight:bold">3&lt;/span> &lt;span style="color:#0000cf;font-weight:bold">4&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>~&lt;span style="color:#ce5c00;font-weight:bold">]&lt;/span>&lt;span style="color:#8f5902;font-style:italic"># echo ${arrays[@]}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>a b d c
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>~&lt;span style="color:#ce5c00;font-weight:bold">]&lt;/span>&lt;span style="color:#8f5902;font-style:italic"># arrays[2]=c&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>~&lt;span style="color:#ce5c00;font-weight:bold">]&lt;/span>&lt;span style="color:#8f5902;font-style:italic"># echo ${arrays[@]}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Note:&lt;/p>
&lt;ul>
&lt;li>某个元素删除后，其余元素的 index 号不变&lt;/li>
&lt;li>如果对删除元素的数组添加新元素，则新元素的 index 号向后递增&lt;/li>
&lt;/ul>
&lt;h1 id="数组的应用实例">数组的应用实例&lt;a class="td-heading-self-link" href="#%e6%95%b0%e7%bb%84%e7%9a%84%e5%ba%94%e7%94%a8%e5%ae%9e%e4%be%8b" aria-label="Heading self-link">&lt;/a>&lt;/h1>
&lt;h2 id="对数组中的元素排序">对数组中的元素排序&lt;a class="td-heading-self-link" href="#%e5%af%b9%e6%95%b0%e7%bb%84%e4%b8%ad%e7%9a%84%e5%85%83%e7%b4%a0%e6%8e%92%e5%ba%8f" aria-label="Heading self-link">&lt;/a>&lt;/h2>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8f5902;font-style:italic"># 原始数组：B=(20 9 01 5 11 4 6 14 12 14 0808)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#000">b&lt;/span>&lt;span style="color:#ce5c00;font-weight:bold">=(&lt;/span>&lt;span style="color:#204a87;font-weight:bold">$(&lt;/span>&lt;span style="color:#204a87">printf&lt;/span> &lt;span style="color:#4e9a06">&amp;#39;%s\n&amp;#39;&lt;/span> &lt;span style="color:#4e9a06">&amp;#34;&lt;/span>&lt;span style="color:#4e9a06">${&lt;/span>&lt;span style="color:#000">B&lt;/span>&lt;span style="color:#000;font-weight:bold">[@]&lt;/span>&lt;span style="color:#4e9a06">}&lt;/span>&lt;span style="color:#4e9a06">&amp;#34;&lt;/span>&lt;span style="color:#000;font-weight:bold">|&lt;/span>sort -n&lt;span style="color:#204a87;font-weight:bold">)&lt;/span>&lt;span style="color:#ce5c00;font-weight:bold">)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8f5902;font-style:italic"># 排序后的数组：b=(01 4 5 6 9 11 12 14 14 20 0808)&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="数组的遍历在-for-循环中的应用">数组的遍历，在 for 循环中的应用&lt;a class="td-heading-self-link" href="#%e6%95%b0%e7%bb%84%e7%9a%84%e9%81%8d%e5%8e%86%e5%9c%a8-for-%e5%be%aa%e7%8e%af%e4%b8%ad%e7%9a%84%e5%ba%94%e7%94%a8" aria-label="Heading self-link">&lt;/a>&lt;/h2>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8f5902;font-style:italic">#!/bin/bash
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8f5902;font-style:italic">&lt;/span>&lt;span style="color:#8f5902;font-style:italic">#&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#000">b&lt;/span>&lt;span style="color:#ce5c00;font-weight:bold">=(&lt;/span>&lt;span style="color:#0000cf;font-weight:bold">01&lt;/span> &lt;span style="color:#0000cf;font-weight:bold">4&lt;/span> &lt;span style="color:#0000cf;font-weight:bold">5&lt;/span> &lt;span style="color:#0000cf;font-weight:bold">06&lt;/span> &lt;span style="color:#0000cf;font-weight:bold">9&lt;/span> &lt;span style="color:#0000cf;font-weight:bold">11&lt;/span> &lt;span style="color:#0000cf;font-weight:bold">12&lt;/span> &lt;span style="color:#0000cf;font-weight:bold">14&lt;/span> &lt;span style="color:#0000cf;font-weight:bold">14&lt;/span> &lt;span style="color:#0000cf;font-weight:bold">20&lt;/span> 0808&lt;span style="color:#ce5c00;font-weight:bold">)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#204a87">let&lt;/span> &lt;span style="color:#000">max&lt;/span>&lt;span style="color:#ce5c00;font-weight:bold">=&lt;/span>&lt;span style="color:#4e9a06">${#&lt;/span>&lt;span style="color:#000">b&lt;/span>&lt;span style="color:#000;font-weight:bold">[@]&lt;/span>&lt;span style="color:#4e9a06">}&lt;/span>-1
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#204a87;font-weight:bold">for&lt;/span> Subscript in &lt;span style="color:#4e9a06">`&lt;/span>seq &lt;span style="color:#0000cf;font-weight:bold">0&lt;/span> &lt;span style="color:#4e9a06">${&lt;/span>&lt;span style="color:#000">max&lt;/span>&lt;span style="color:#4e9a06">}&lt;/span>&lt;span style="color:#4e9a06">`&lt;/span>&lt;span style="color:#000;font-weight:bold">;&lt;/span>&lt;span style="color:#204a87;font-weight:bold">do&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#204a87">echo&lt;/span> &lt;span style="color:#4e9a06">${&lt;/span>&lt;span style="color:#000">b&lt;/span>&lt;span style="color:#000;font-weight:bold">[&lt;/span>&lt;span style="color:#4e9a06">${&lt;/span>&lt;span style="color:#000">Subscript&lt;/span>&lt;span style="color:#4e9a06">}&lt;/span>&lt;span style="color:#000;font-weight:bold">]&lt;/span>&lt;span style="color:#4e9a06">}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#204a87;font-weight:bold">done&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>可以遍历数组并输出数组中每一个值
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div></description></item><item><title>Docs: 重定向</title><link>https://desistdaydream.github.io/docs/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/4.Terminal-%E4%B8%8E-Shell/Bash/%E9%87%8D%E5%AE%9A%E5%90%91/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/4.Terminal-%E4%B8%8E-Shell/Bash/%E9%87%8D%E5%AE%9A%E5%90%91/</guid><description>
&lt;h1 id="概述">概述&lt;a class="td-heading-self-link" href="#%e6%a6%82%e8%bf%b0" aria-label="Heading self-link">&lt;/a>&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://www.man7.org/linux/man-pages/man1/bash.1.html#REDIRECTION">Manual(手册)，bash(1)-重定向&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>&lt;strong>Redirection(重定向)&lt;/strong> 功能可以在执行命令之前，使用 Bash 的特殊符号来重定向其输入和输出。 重定向还可以用于打开和关闭当前 Shell 执行环境的文件。 重定向操作符可以出现在简单命令的前面，也可以出现在命令的后面。重定向按照它们出现的顺序进行处理。 重定向按照从左到右的顺序显示。&lt;/p>
&lt;p>用一个简单的例子来理解一下什么是重定向&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>~&lt;span style="color:#ce5c00;font-weight:bold">]&lt;/span>&lt;span style="color:#8f5902;font-style:italic"># ls&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>anaconda-ks.cfg playbook scripts
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>~&lt;span style="color:#ce5c00;font-weight:bold">]&lt;/span>&lt;span style="color:#8f5902;font-style:italic"># ls &amp;gt; dirlist&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>~&lt;span style="color:#ce5c00;font-weight:bold">]&lt;/span>&lt;span style="color:#8f5902;font-style:italic"># cat dirlist&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>anaconda-ks.cfg
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>dirlist
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>playbook
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>scripts
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>这个例子就是将 ls 命令的标准输出的内容，重定向到 dirlist 文件中。(默认一个命令执行时，输出内容会打印在屏幕上，但是重定向后，将内容写入文件中)&lt;/p>
&lt;p>每个程序在运行后，都会至少打开三个 文件描述符，分别是&lt;/p>
&lt;ul>
&lt;li>0：标准输入&lt;/li>
&lt;li>1：标准输出&lt;/li>
&lt;li>2：标准错误&lt;/li>
&lt;/ul>
&lt;p>文件描述符介绍详见：文件描述符与打开文件之间的关系&lt;/p>
&lt;p>所以，shell 可以实现重定向，就是这 3 者其中之一，或者全部三者。&lt;/p>
&lt;h1 id="重定向的种类">重定向的种类&lt;a class="td-heading-self-link" href="#%e9%87%8d%e5%ae%9a%e5%90%91%e7%9a%84%e7%a7%8d%e7%b1%bb" aria-label="Heading self-link">&lt;/a>&lt;/h1>
&lt;p>在下面各种重定向的语法中，n 表示文件描述符&lt;/p>
&lt;h2 id="redirecting-input-重定向输入">Redirecting Input 重定向输入&lt;a class="td-heading-self-link" href="#redirecting-input-%e9%87%8d%e5%ae%9a%e5%90%91%e8%be%93%e5%85%a5" aria-label="Heading self-link">&lt;/a>&lt;/h2>
&lt;p>输入的重定向将打开名称为 WORD 的文件，以便在文件描述符 n 下打开标准输入，n 默认为 0。&lt;/p>
&lt;p>语法：COMMAND [n]&amp;lt; WORD&lt;/p>
&lt;p>EXAMPLE&lt;/p>
&lt;h2 id="redirecting-output-重定向输出">Redirecting Output 重定向输出&lt;a class="td-heading-self-link" href="#redirecting-output-%e9%87%8d%e5%ae%9a%e5%90%91%e8%be%93%e5%87%ba" aria-label="Heading self-link">&lt;/a>&lt;/h2>
&lt;p>输出重定向将打开名称为 WORD 的文件，以便在文件描述符 n 上进行写操作，n 默认为 1。 如果 WORD 文件不存在，则创建该文件； 如果存在，则将其截断为零大小。&lt;/p>
&lt;p>语法：COMMAND [n]&amp;gt; WORD&lt;/p>
&lt;p>EXAMPLE&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8f5902;font-style:italic"># 将某个程序产生的标准输出和标注错误分别重定向到不同文件&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ce5c00;font-weight:bold">[&lt;/span>root@ansible te&lt;span style="color:#ce5c00;font-weight:bold">]&lt;/span>&lt;span style="color:#8f5902;font-style:italic"># ls a.txt b.txt&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>ls: cannot access b.txt: No such file or directory
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>a.txt
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ce5c00;font-weight:bold">[&lt;/span>root@ansible te&lt;span style="color:#ce5c00;font-weight:bold">]&lt;/span>&lt;span style="color:#8f5902;font-style:italic"># ls a.txt b.txt 1&amp;gt; stdout.log 2&amp;gt; errout.log&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ce5c00;font-weight:bold">[&lt;/span>root@ansible te&lt;span style="color:#ce5c00;font-weight:bold">]&lt;/span>&lt;span style="color:#8f5902;font-style:italic"># ls&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>a.txt errout.log stdout.log
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ce5c00;font-weight:bold">[&lt;/span>root@ansible te&lt;span style="color:#ce5c00;font-weight:bold">]&lt;/span>&lt;span style="color:#8f5902;font-style:italic"># cat errout.log&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>ls: cannot access b.txt: No such file or directory
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ce5c00;font-weight:bold">[&lt;/span>root@ansible te&lt;span style="color:#ce5c00;font-weight:bold">]&lt;/span>&lt;span style="color:#8f5902;font-style:italic"># cat stdout.log&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>a.txt
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="appending-redirected-output-重定向输出追加方式">Appending Redirected Output 重定向输出(追加方式)&lt;a class="td-heading-self-link" href="#appending-redirected-output-%e9%87%8d%e5%ae%9a%e5%90%91%e8%be%93%e5%87%ba%e8%bf%bd%e5%8a%a0%e6%96%b9%e5%bc%8f" aria-label="Heading self-link">&lt;/a>&lt;/h2>
&lt;p>语法：COMMAND [n]&amp;raquo; WORD&lt;/p>
&lt;h2 id="redirecting-standard-output-and-standard-error-重定向标准输出和标准错误">Redirecting Standard Output and Standard Error 重定向标准输出和标准错误&lt;a class="td-heading-self-link" href="#redirecting-standard-output-and-standard-error-%e9%87%8d%e5%ae%9a%e5%90%91%e6%a0%87%e5%87%86%e8%be%93%e5%87%ba%e5%92%8c%e6%a0%87%e5%87%86%e9%94%99%e8%af%af" aria-label="Heading self-link">&lt;/a>&lt;/h2>
&lt;p>此结构允许将标准输出（文件描述符 1）和标准错误输出（文件描述符 2）都重定向到名称为 word 扩展的文件。&lt;/p>
&lt;p>语法：&lt;/p>
&lt;p>COMMAND &amp;gt; WORD 2&amp;gt;&amp;amp;1 # 标准错误的信息传递给标准输出通道。&amp;amp;1 表示 标注输出通道。同理 1&amp;gt;&amp;amp;2 反过来理解即可。&lt;/p>
&lt;p>EXAMPLE&lt;/p>
&lt;pre>&lt;code># 与重定向输入的例子类似，这种符号可以理解为将 ls 命令的标准输出重定向到 out.log 文件中
# 而该命令的 标准错误 则传递到 标注输出 中，与标准输出一起重定向到 out.log 文件中
[root@ansible te]# ls a.txt b.txt
ls: cannot access b.txt: No such file or directory
a.txt
[root@ansible te]# ls a.txt b.txt &amp;gt; out.log 2&amp;gt;&amp;amp;1
[root@ansible te]# cat out.log
ls: cannot access b.txt: No such file or directory
a.txt
&lt;/code>&lt;/pre>
&lt;h2 id="here-documenttag-的重定向模式">Here Document(&amp;laquo;TAG 的重定向模式)&lt;a class="td-heading-self-link" href="#here-documenttag-%e7%9a%84%e9%87%8d%e5%ae%9a%e5%90%91%e6%a8%a1%e5%bc%8f" aria-label="Heading self-link">&lt;/a>&lt;/h2>
&lt;p>&lt;strong>Here Document(简称 Heredoc)&lt;/strong> 是 shell 中的一种特殊重定向方式，用来将输入重定向到一个交互式的 shell 脚本或程序。&lt;/p>
&lt;p>语法：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-text" data-lang="text">&lt;span style="display:flex;">&lt;span>COMMAND [n] &amp;lt;&amp;lt; TAG
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Document
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>TAG
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>它的作用是将两个 TAG 之间的内容（docuemnt）作为输入传递给 n。&lt;/p>
&lt;p>注意：&lt;/p>
&lt;ul>
&lt;li>结尾的 TAG 一定要顶头写，前面不能有任何字符，后面也不能有任何字符，包括空格和 tab 缩进。&lt;/li>
&lt;li>开始的前后的空格不要被忽略掉。&lt;/li>
&lt;li>TAG 这三个字符可以用任意字符代替，日常常用 EOF 来标识，只要开头与结尾的字符相同即可&lt;/li>
&lt;/ul>
&lt;p>实例：
在命令行中通过 wc -l 命令计算 Here Document 的行数&lt;/p>
&lt;pre tabindex="0">&lt;code>wc -l &amp;lt;&amp;lt; EOF
学习使用shell 编程
www.xuhaoblog.com
EOF
&lt;/code>&lt;/pre>&lt;p>输出的结果为 2。&lt;/p>
&lt;p>我们也可以将 Here Document 用在脚本中，例如：&lt;/p>
&lt;pre tabindex="0">&lt;code>#!/bin/bash
cat &amp;lt;&amp;lt; EOF
学习使用shell脚本编程
www.xuhaoblog.com
EOF
&lt;/code>&lt;/pre>&lt;p>注意！！！：&lt;/p>
&lt;ul>
&lt;li>EOF 如果在写入内容时，想要防止将变量替换成值的话，需要在第一行 EOF 之前加 &lt;code>\&lt;/code> 或 &lt;code>-&lt;/code>，否则写入内容中如果有执行命令或者变量，则无法以文本写入。&lt;/li>
&lt;/ul>
&lt;p>效果如下&lt;/p>
&lt;pre tabindex="0">&lt;code>~]# cat &amp;gt; 123 &amp;lt;&amp;lt; EOF
&amp;gt; $123
&amp;gt; EOF
~]# cat 123
23
~]# cat &amp;gt; 123 &amp;lt;&amp;lt; \EOF
&amp;gt; $123
&amp;gt; EOF
~]# cat 123
$123
&lt;/code>&lt;/pre>&lt;h2 id="here-strings">Here Strings&lt;a class="td-heading-self-link" href="#here-strings" aria-label="Heading self-link">&lt;/a>&lt;/h2>
&lt;h2 id="duplicating-file-descriptors">Duplicating File Descriptors&lt;a class="td-heading-self-link" href="#duplicating-file-descriptors" aria-label="Heading self-link">&lt;/a>&lt;/h2>
&lt;pre>&lt;code> The redirection operator [n]&amp;lt;&amp;amp;word is used to duplicate input file descriptors. If word expands to one or more digits, the file descriptor denoted by n is made to be a copy of that file descriptor. If the digits in word do not specify a file descriptor open for input, a redirection error occurs. If word evaluates to -, file descriptor n is closed. If n is not specified, the standard input (file descriptor 0) is used. The operator [n]&amp;gt;&amp;amp;word is used similarly to duplicate output file descriptors. If n is not specified, the standard output (file descriptor 1) is used. If the digits in word do not specify a file descriptor open for output, a redirection error occurs. If word evaluates to -, file descriptor n is closed. As a special case, if n is omitted, and word does not expand to one or more digits or -, the standard output and standard error are redirected as described previously.
&lt;/code>&lt;/pre>
&lt;h2 id="moving-file-descriptors">Moving File Descriptors&lt;a class="td-heading-self-link" href="#moving-file-descriptors" aria-label="Heading self-link">&lt;/a>&lt;/h2>
&lt;pre>&lt;code> The redirection operator [n]&amp;lt;&amp;amp;digit- moves the file descriptor digit to file descriptor n, or the standard input (file descriptor 0) if n is not specified. digit is closed after being duplicated to n. Similarly, the redirection operator [n]&amp;gt;&amp;amp;digit- moves the file descriptor digit to file descriptor n, or the standard output (file descriptor 1) if n is not specified.
&lt;/code>&lt;/pre>
&lt;h2 id="opening-file-descriptors-for-reading-and-writing">Opening File Descriptors for Reading and Writing&lt;a class="td-heading-self-link" href="#opening-file-descriptors-for-reading-and-writing" aria-label="Heading self-link">&lt;/a>&lt;/h2>
&lt;p>The redirection operator [n]&amp;lt;&amp;gt;word causes the file whose name is the expansion of word to be opened for both reading and writing on file descriptor n, or on file descriptor 0 if n is not specified. If the file does not exist, it is created.&lt;/p>
&lt;h1 id="简单总结">简单总结&lt;a class="td-heading-self-link" href="#%e7%ae%80%e5%8d%95%e6%80%bb%e7%bb%93" aria-label="Heading self-link">&lt;/a>&lt;/h1>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>命令&lt;/th>
&lt;th>说明&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>command &amp;gt; file&lt;/td>
&lt;td>将输出重定向到 file。&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>command &amp;lt; file&lt;/td>
&lt;td>将输入重定向到 command。&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>command &amp;raquo; file&lt;/td>
&lt;td>将输出以追加的方式重定向到 file。&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>n &amp;gt; file&lt;/td>
&lt;td>将文件描述符为 n 的文件重定向到 file。&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>n &amp;raquo; file&lt;/td>
&lt;td>将文件描述符为 n 的文件以追加的方式重定向到 file。&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>n &amp;gt;&amp;amp; m&lt;/td>
&lt;td>将输出文件 m 和 n 合并。&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>n &amp;lt;&amp;amp; m&lt;/td>
&lt;td>将输入文件 m 和 n 合并。&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&amp;laquo; tag&lt;/td>
&lt;td>将开始标记 tag 和结束标记 tag 之间的内容作为输入。&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h1 id="如何理解-linux-shell-中重定向">如何理解 Linux shell 中重定向&lt;a class="td-heading-self-link" href="#%e5%a6%82%e4%bd%95%e7%90%86%e8%a7%a3-linux-shell-%e4%b8%ad%e9%87%8d%e5%ae%9a%e5%90%91" aria-label="Heading self-link">&lt;/a>&lt;/h1>
&lt;p>原文：https://www.cnblogs.com/even160941/p/15630065.html&lt;/p>
&lt;h4 id="前言">前言&lt;a class="td-heading-self-link" href="#%e5%89%8d%e8%a8%80" aria-label="Heading self-link">&lt;/a>&lt;/h4>
&lt;p>有时候我们常看到类似这样的脚本调用：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>./test.sh &amp;gt; log.txt 2&amp;gt;&lt;span style="color:#000;font-weight:bold">&amp;amp;&lt;/span>&lt;span style="color:#0000cf;font-weight:bold">1&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>这里的2&amp;gt;&amp;amp;1是什么意思？该如何理解？&lt;br>
先说结论：上面的调用表明将 &lt;code>./test.sh&lt;/code>的输出重定向到 &lt;code>log.txt&lt;/code>文件中，同时将标准错误也重定向到 &lt;code>log.txt&lt;/code>文件中。&lt;/p>
&lt;h4 id="有何妙用">有何妙用&lt;a class="td-heading-self-link" href="#%e6%9c%89%e4%bd%95%e5%a6%99%e7%94%a8" aria-label="Heading self-link">&lt;/a>&lt;/h4>
&lt;p>（如果已经明白是什么作用，可跳过此小节）&lt;br>
上面到底是什么意思呢？我们来看下面的例子，假如有脚本 &lt;code>test.sh&lt;/code>：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8f5902;font-style:italic">#!/bin/bash
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8f5902;font-style:italic">&lt;/span>date &lt;span style="color:#8f5902;font-style:italic">#打印当前时间&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#204a87;font-weight:bold">while&lt;/span> &lt;span style="color:#204a87">true&lt;/span> &lt;span style="color:#8f5902;font-style:italic">#死循环&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#204a87;font-weight:bold">do&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#8f5902;font-style:italic">#每隔2秒打印一次&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> sleep &lt;span style="color:#0000cf;font-weight:bold">2&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> whatthis &lt;span style="color:#8f5902;font-style:italic">#不存在的命令&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#204a87">echo&lt;/span> -e &lt;span style="color:#4e9a06">&amp;#34;std output&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#204a87;font-weight:bold">done&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>脚本中先打印当前日期，然后每隔2秒执行 &lt;code>whatthis&lt;/code>并打印一段字符。由于系统中不存在 &lt;code>whatthis&lt;/code>命令，因此执行会报错。&lt;br>
假如我们想保存该脚本的打印结果，只需将 &lt;code>test.sh&lt;/code>的结果重定向到 &lt;code>log.txt&lt;/code>中即可：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>./test.sh &amp;gt; log.txt
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>执行结果如下：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>./test.sh &amp;gt;log.txt
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>./test.sh: 行 7: whatthis: 未找到命令
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>我们明明将打印内容重定向到 &lt;code>log.txt&lt;/code>中了，但是这条错误信息却没有重定向到 &lt;code>log.txt&lt;/code>中。如果你是使用程序调用该脚本，当查看脚本日志的时候，将会完全看不到这条错误信息。而使用下面的方式则会将出错信息也重定向到 &lt;code>log.txt&lt;/code>中：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>./test.sh &amp;gt; log.txt 2&amp;gt;&lt;span style="color:#000;font-weight:bold">&amp;amp;&lt;/span>&lt;span style="color:#0000cf;font-weight:bold">1&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>以这样的方式调用脚本，可以很好地将错误信息保存，帮助我们定位问题。&lt;/p>
&lt;h4 id="如何理解">如何理解&lt;a class="td-heading-self-link" href="#%e5%a6%82%e4%bd%95%e7%90%86%e8%a7%a3" aria-label="Heading self-link">&lt;/a>&lt;/h4>
&lt;p>每个程序在运行后，都会至少打开三个文件描述符，分别是&lt;br>
0：标准输入 =&amp;gt; stdin；&lt;br>
1：标准输出 =&amp;gt; stdout；&lt;br>
2：标准错误 =&amp;gt; stderr。&lt;br>
例如，对于前面的test.sh脚本，我们通过下面的步骤看到它至少打开了三个文件描述符：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cmake" data-lang="cmake">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a40000">./test.sh&lt;/span> &lt;span style="color:#8f5902;font-style:italic">#运行脚本
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8f5902;font-style:italic">&lt;/span>&lt;span style="color:#a40000">ps&lt;/span> &lt;span style="color:#a40000">-ef|grep&lt;/span> &lt;span style="color:#a40000">test.sh&lt;/span> &lt;span style="color:#8f5902;font-style:italic">#重新打开命令串口，使用ps命令找到test.sh的pid
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8f5902;font-style:italic">&lt;/span>&lt;span style="color:#a40000">root&lt;/span> &lt;span style="color:#a40000">96126&lt;/span> &lt;span style="color:#a40000">88139&lt;/span> &lt;span style="color:#a40000">0&lt;/span> &lt;span style="color:#a40000">10:44&lt;/span> &lt;span style="color:#a40000">pts/2&lt;/span> &lt;span style="color:#a40000">00:00:00&lt;/span> &lt;span style="color:#a40000">sh&lt;/span> &lt;span style="color:#a40000">test.sh
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a40000">root&lt;/span> &lt;span style="color:#a40000">96177&lt;/span> &lt;span style="color:#a40000">56236&lt;/span> &lt;span style="color:#a40000">0&lt;/span> &lt;span style="color:#a40000">10:45&lt;/span> &lt;span style="color:#a40000">pts/1&lt;/span> &lt;span style="color:#a40000">00:00:00&lt;/span> &lt;span style="color:#a40000">grep&lt;/span> &lt;span style="color:#a40000">--color=auto&lt;/span> &lt;span style="color:#a40000">test.sh
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>可以看到 &lt;code>test.sh&lt;/code>的pid为96126，进入到相关fd目录：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#204a87">cd&lt;/span> /proc/96126/fd &lt;span style="color:#8f5902;font-style:italic">#进程96126所有打开的文件描述符信息都在此&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>ls -l &lt;span style="color:#8f5902;font-style:italic">#列出目录下的内容&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#0000cf;font-weight:bold">0&lt;/span> -&amp;gt; /dev/pts/2
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#0000cf;font-weight:bold">1&lt;/span> -&amp;gt; /dev/pts/2
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#0000cf;font-weight:bold">2&lt;/span> -&amp;gt; /dev/pts/2
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#0000cf;font-weight:bold">255&lt;/span> -&amp;gt; /root/shell/test.sh
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>可以看到，&lt;code>test.sh&lt;/code>打开了0，1，2三个文件描述符。同样的，如果有兴趣，也可以查看其他运行进程的文件描述符打开情况，除非关闭了否则都会有这三个文件描述符。&lt;/p>
&lt;p>那么现在就容易理解前面的疑问了，2&amp;gt;&amp;amp;1表明将文件描述2（标准错误输出）的内容重定向到文件描述符1（标准输出）的文件（/dev/stdout）中，为什么1前面需要&amp;amp;？当没有&amp;amp;时，1会被认为是一个普通的文件，有&amp;amp;表示重定向的目标不是一个文件，而是一个文件描述符。在前面我们知道，&lt;code>sh test.sh &amp;gt;log.txt&lt;/code>又将文件描述符1的内容重定向到了文件 &lt;code>log.txt&lt;/code>，那么最终标准错误也会重定向到 &lt;code>log.txt&lt;/code>。我们同样通过前面的方法 &lt;code>sh test.sh &amp;gt; log.txt 2&amp;gt;&amp;amp;1&lt;/code>，可以看到 &lt;code>test.sh&lt;/code>进程的文件描述符情况如下：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-basic" data-lang="basic">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f57900">0&lt;/span>&lt;span style="color:#f8f8f8;text-decoration:underline"> &lt;/span>&lt;span style="color:#ce5c00;font-weight:bold">-&amp;gt;&lt;/span>&lt;span style="color:#f8f8f8;text-decoration:underline"> &lt;/span>&lt;span style="color:#ce5c00;font-weight:bold">/&lt;/span>&lt;span style="color:#000">dev&lt;/span>&lt;span style="color:#ce5c00;font-weight:bold">/&lt;/span>&lt;span style="color:#000">pts&lt;/span>&lt;span style="color:#ce5c00;font-weight:bold">/&lt;/span>&lt;span style="color:#0000cf;font-weight:bold">2&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f57900">1&lt;/span>&lt;span style="color:#f8f8f8;text-decoration:underline"> &lt;/span>&lt;span style="color:#ce5c00;font-weight:bold">-&amp;gt;&lt;/span>&lt;span style="color:#f8f8f8;text-decoration:underline"> &lt;/span>&lt;span style="color:#ce5c00;font-weight:bold">/&lt;/span>&lt;span style="color:#000">root&lt;/span>&lt;span style="color:#ce5c00;font-weight:bold">/&lt;/span>&lt;span style="color:#000">shell&lt;/span>&lt;span style="color:#ce5c00;font-weight:bold">/&lt;/span>&lt;span style="color:#000">log&lt;/span>&lt;span style="color:#ce5c00;font-weight:bold">.&lt;/span>&lt;span style="color:#000">txt&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f57900">2&lt;/span>&lt;span style="color:#f8f8f8;text-decoration:underline"> &lt;/span>&lt;span style="color:#ce5c00;font-weight:bold">-&amp;gt;&lt;/span>&lt;span style="color:#f8f8f8;text-decoration:underline"> &lt;/span>&lt;span style="color:#ce5c00;font-weight:bold">/&lt;/span>&lt;span style="color:#000">root&lt;/span>&lt;span style="color:#ce5c00;font-weight:bold">/&lt;/span>&lt;span style="color:#000">shell&lt;/span>&lt;span style="color:#ce5c00;font-weight:bold">/&lt;/span>&lt;span style="color:#000">log&lt;/span>&lt;span style="color:#ce5c00;font-weight:bold">.&lt;/span>&lt;span style="color:#000">txt&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f57900">255&lt;/span>&lt;span style="color:#f8f8f8;text-decoration:underline"> &lt;/span>&lt;span style="color:#ce5c00;font-weight:bold">-&amp;gt;&lt;/span>&lt;span style="color:#f8f8f8;text-decoration:underline"> &lt;/span>&lt;span style="color:#ce5c00;font-weight:bold">/&lt;/span>&lt;span style="color:#000">root&lt;/span>&lt;span style="color:#ce5c00;font-weight:bold">/&lt;/span>&lt;span style="color:#000">shell&lt;/span>&lt;span style="color:#ce5c00;font-weight:bold">/&lt;/span>&lt;span style="color:#000">test&lt;/span>&lt;span style="color:#ce5c00;font-weight:bold">.&lt;/span>&lt;span style="color:#000">sh&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>我们可以很明显地看到，文件描述符1和2都指向了 &lt;code>log.txt&lt;/code>文件，也就得到了我们最终想要的效果：将标准错误输出重定向到文件中。&lt;br>
它们还有两种等价写法：&lt;/p>
&lt;pre tabindex="0">&lt;code class="language-mipsasm" data-lang="mipsasm">sh test.sh &amp;gt;&amp;amp; log.txt
sh test.sh &amp;amp;&amp;gt; log.txt
&lt;/code>&lt;/pre>&lt;p>此处 &lt;code>&amp;gt;&amp;amp;&lt;/code> 或者 &lt;code>&amp;amp;&amp;gt;&lt;/code> 视作整体，分开没有单独的意义。&lt;/p>
&lt;h4 id="总结">总结&lt;a class="td-heading-self-link" href="#%e6%80%bb%e7%bb%93" aria-label="Heading self-link">&lt;/a>&lt;/h4>
&lt;p>我们总结一下前面的内容：&lt;/p>
&lt;ul>
&lt;li>1.程序运行后会打开三个文件描述符，分别是标准输入，标准输出和标准错误输出。&lt;/li>
&lt;li>2.在调用脚本时，可使用2&amp;gt;&amp;amp;1来将标准错误输出重定向。&lt;/li>
&lt;li>3.只需要查看脚本的错误时，可将标准输出重定向到文件，而标准错误会打印在控制台，便于查看。&lt;/li>
&lt;li>4.&lt;code>&amp;gt;&amp;gt;log.txt&lt;/code>会将重定向内容追加到&lt;code>log.txt&lt;/code>文件末尾。&lt;/li>
&lt;li>5.通过查看&lt;code>/proc/进程id/fd&lt;/code>下的内容，可了解进程打开的文件描述符信息。&lt;/li>
&lt;/ul>
&lt;h1 id="重定向应用示例">重定向应用示例&lt;a class="td-heading-self-link" href="#%e9%87%8d%e5%ae%9a%e5%90%91%e5%ba%94%e7%94%a8%e7%a4%ba%e4%be%8b" aria-label="Heading self-link">&lt;/a>&lt;/h1>
&lt;h2 id="一般来说-1-通常可以省略成-">一般来说, &amp;ldquo;1&amp;gt;&amp;rdquo; 通常可以省略成 &amp;ldquo;&amp;gt;&amp;rdquo;.&lt;a class="td-heading-self-link" href="#%e4%b8%80%e8%88%ac%e6%9d%a5%e8%af%b4-1-%e9%80%9a%e5%b8%b8%e5%8f%af%e4%bb%a5%e7%9c%81%e7%95%a5%e6%88%90-" aria-label="Heading self-link">&lt;/a>&lt;/h2>
&lt;p>即可以把如上命令写成: ls a.txt b.txt &amp;gt;file.out 2&amp;gt;file.err&lt;/p>
&lt;p>有了这些认识才能理解 &amp;ldquo;1&amp;gt;&amp;amp;2&amp;rdquo; 和 &amp;ldquo;2&amp;gt;&amp;amp;1&amp;rdquo;.&lt;/p>
&lt;p>1&amp;gt;&amp;amp;2 正确返回值传递给 2 输出通道 &amp;amp;2 表示 2 输出通道&lt;/p>
&lt;p>如果此处错写成 1&amp;gt;2, 就表示把 1 输出重定向到文件 2 中.&lt;/p>
&lt;p>2&amp;gt;&amp;amp;1 错误返回值传递给 1 输出通道, 同样&amp;amp;1 表示 1 输出通道.&lt;/p>
&lt;p>举个例子.&lt;/p>
&lt;p>[root@redhat box]# ls a.txt b.txt 1&amp;gt;file.out 2&amp;gt;&amp;amp;1&lt;/p>
&lt;p>[root@redhat box]# cat file.out&lt;/p>
&lt;p>ls: b.txt: No such file or directory&lt;/p>
&lt;p>a.txt&lt;/p>
&lt;p>现在, 正确的输出和错误的输出都定向到了 file.out 这个文件中, 而不显示在前端.&lt;/p>
&lt;p>补充下, 输出不只 1 和 2, 还有其他的类型, 这两种只是最常用和最基本的.&lt;/p>
&lt;p>例如：&lt;/p>
&lt;p>rm -f $(find / -name core) &amp;amp;&amp;gt; /dev/null，/dev/null 是一个文件，这个文件比较特殊，所有传给它的东西它都丢弃掉。&lt;/p>
&lt;p>例如：&lt;/p>
&lt;p>注意，为了方便理解，必须设置一个环境使得执行 grep da *命令会有正常输出和错误输出，然后分别使用下面的命令生成三个文件：&lt;/p>
&lt;p>grep da * &amp;gt; greplog1&lt;/p>
&lt;p>grep da * &amp;gt; greplog2 1&amp;gt;&amp;amp;2&lt;/p>
&lt;p>grep da _ &amp;gt; greplog3 2&amp;gt;&amp;amp;1 //grep da _ 2&amp;gt; greplog4 1&amp;gt;&amp;amp;2 结果一样&lt;/p>
&lt;p>#查看 greplog1 会发现里面只有正常输出内容&lt;/p>
&lt;p>#查看 greplog2 会发现里面什么都没有#查看 greplog3 会发现里面既有正常输出内容又有错误输出内容&lt;/p>
&lt;h1 id="tee-命令">tee 命令&lt;a class="td-heading-self-link" href="#tee-%e5%91%bd%e4%bb%a4" aria-label="Heading self-link">&lt;/a>&lt;/h1>
&lt;p>在非 root 用户时，重定向总是会提示权限不够，这时候，可以使用 tee 命令来代替重定向符号&lt;/p>
&lt;p>比如&lt;/p>
&lt;p>&lt;code>containerd config default | sudo tee /etc/containerd/config.toml &amp;gt; /dev/null&lt;/code>&lt;/p>
&lt;p>等效于&lt;/p>
&lt;p>&lt;code>sudo sh -c &amp;quot;containerd config default &amp;gt; /etc/containerd/config.toml&amp;quot;&lt;/code>&lt;/p>
&lt;p>还可以这么用&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>sudo tee ~/test_dir/test.sh &lt;span style="color:#4e9a06">&amp;lt;&amp;lt;EOF
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#4e9a06">${abc}
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#4e9a06">EOF&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>若要让写入文件中的内容，将 &lt;code>$&lt;/code> 等符号当做字符串处理的话，则这么用：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>sudo tee ~/test_dir/test.sh &amp;lt;&amp;lt;-&lt;span style="color:#4e9a06">&amp;#34;EOF&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#4e9a06">${&lt;/span>&lt;span style="color:#000">abc&lt;/span>&lt;span style="color:#4e9a06">}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>EOF
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="syntax语法">Syntax(语法)&lt;a class="td-heading-self-link" href="#syntax%e8%af%ad%e6%b3%95" aria-label="Heading self-link">&lt;/a>&lt;/h2>
&lt;p>&lt;strong>tee [OPTIONS] FILE&lt;/strong>&lt;/p>
&lt;p>OPTIONS&lt;/p>
&lt;ul>
&lt;li>&lt;strong>-a, &amp;ndash;append&lt;/strong> # 将读取到内容追加到文件中，而不是覆盖。等效于 &lt;code>&amp;gt;&amp;gt;&lt;/code> 符号&lt;/li>
&lt;/ul></description></item></channel></rss>