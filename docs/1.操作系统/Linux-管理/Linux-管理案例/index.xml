<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Linux 管理案例 on 断念梦的站点</title><link>https://desistdaydream.github.io/docs/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Linux-%E7%AE%A1%E7%90%86/Linux-%E7%AE%A1%E7%90%86%E6%A1%88%E4%BE%8B/</link><description>Recent content in Linux 管理案例 on 断念梦的站点</description><generator>Hugo</generator><language>zh-cn</language><atom:link href="https://desistdaydream.github.io/docs/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Linux-%E7%AE%A1%E7%90%86/Linux-%E7%AE%A1%E7%90%86%E6%A1%88%E4%BE%8B/index.xml" rel="self" type="application/rss+xml"/><item><title>Linux 管理案例</title><link>https://desistdaydream.github.io/docs/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Linux-%E7%AE%A1%E7%90%86/Linux-%E7%AE%A1%E7%90%86%E6%A1%88%E4%BE%8B/Linux-%E7%AE%A1%E7%90%86%E6%A1%88%E4%BE%8B/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Linux-%E7%AE%A1%E7%90%86/Linux-%E7%AE%A1%E7%90%86%E6%A1%88%E4%BE%8B/Linux-%E7%AE%A1%E7%90%86%E6%A1%88%E4%BE%8B/</guid><description>重置 Linux 的 root 密码 进入紧急模式 详见 紧急模式或救援模式
修改密码 切换到原系统执行：chroot /sysroot/ 更改 root 密码：passwd root 在/目录下创建一个.autorelabel 文件，而有这个文件存在，系统在重启时就会对整个文件系统进行 relabeling touch /.autorelabel exit reboot 修改网卡名 centos 系统
vi /etc/default/grub GRUB_CMDLINE_LINUX=&amp;ldquo;net.ifnames=0 biosdevname=0 crashkernel=auto rd.lvm.lv=myvg/root rd.lvm.lv=myvg/swap rhgb quiet&amp;rdquo; 注意，标红位置改为自己的 lvm 中 volume group 的名字 主要就是添加紫色内容的字符串 grub2-mkconfig -o /boot/grub2/grub.cfg mv /etc/sysconfig/network-scripts/ifcfg-ens33 /etc/sysconfig/network-scripts/ifcfg-eth0 sed -i &amp;ldquo;s/ens33/eth0/g&amp;rdquo; /etc/sysconfig/network-scripts/ifcfg-eth0 ubuntu 系统
修改 grub 文件 vim /etc/default/grub 查找 GRUB_CMDLINE_LINUX=&amp;quot;&amp;quot; 修改为 GRUB_CMDLINE_LINUX=&amp;ldquo;net.ifnames=0 biosdevname=0&amp;rdquo; 重新生成 grub 引导配置文件 grub-mkconfig -o /boot/grub/grub.cfg 修改网络配置 ens32 为 eth0 vim /etc/netplan/01-netcfg.</description></item><item><title>进程与CPU核心的绑定</title><link>https://desistdaydream.github.io/docs/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Linux-%E7%AE%A1%E7%90%86/Linux-%E7%AE%A1%E7%90%86%E6%A1%88%E4%BE%8B/%E8%BF%9B%E7%A8%8B%E4%B8%8ECPU%E6%A0%B8%E5%BF%83%E7%9A%84%E7%BB%91%E5%AE%9A/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Linux-%E7%AE%A1%E7%90%86/Linux-%E7%AE%A1%E7%90%86%E6%A1%88%E4%BE%8B/%E8%BF%9B%E7%A8%8B%E4%B8%8ECPU%E6%A0%B8%E5%BF%83%E7%9A%84%E7%BB%91%E5%AE%9A/</guid><description>概述 参考:
Linux 有问必答：如何知道进程运行在哪个 CPU 内核上？ https://www.xmodulo.com/cpu-core-process-is-running.html 问题：我有个 Linux 进程运行在多核处理器系统上。怎样才能找出哪个 CPU 内核正在运行该进程？
当你在 多核 NUMA 处理器上运行需要较高性能的 HPC（高性能计算）程序或非常消耗网络资源的程序时，CPU/memory 的亲和力是限度其发挥最大性能的重要因素之一。在同一 NUMA 节点上调度最相关的进程可以减少缓慢的远程内存访问。像英特尔 Sandy Bridge 处理器，该处理器有一个集成的 PCIe 控制器，你可以在同一 NUMA 节点上调度网络 I/O 负载（如网卡）来突破 PCI 到 CPU 亲和力限制。
作为性能优化和故障排除的一部分，你可能想知道特定的进程被调度到哪个 CPU 内核（或 NUMA 节点）上运行。
这里有几种方法可以找出哪个 CPU 内核被调度来运行给定的 Linux 进程或线程。
方法一 如果一个进程使用 taskset 命令明确的被固定（pinned）到 CPU 的特定内核上，你可以使用 taskset 命令找出被固定的 CPU 内核：
$ taskset -c -p
例如, 如果你对 PID 5357 这个进程有兴趣:
$ taskset -c -p 5357
pid 5357&amp;rsquo;s current affinity list: 5</description></item><item><title>Linux 代理配置</title><link>https://desistdaydream.github.io/docs/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Linux-%E7%AE%A1%E7%90%86/Linux-%E7%AE%A1%E7%90%86%E6%A1%88%E4%BE%8B/Linux-%E4%BB%A3%E7%90%86%E9%85%8D%E7%BD%AE/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Linux-%E7%AE%A1%E7%90%86/Linux-%E7%AE%A1%E7%90%86%E6%A1%88%E4%BE%8B/Linux-%E4%BB%A3%E7%90%86%E9%85%8D%E7%BD%AE/</guid><description>概述 在 Unix-like OS 中，很多程序都会读取 Terminal 与 Shell 中的某些变量来读取代理信息
TODO: 这些变量到底应该大写还是小写？wget 命令无法识别到大写的变量。
http_proxy | https_proxy | ftp_proxy | all_proxy # 此变量值用于所有 http、https、ftp 或者所有流量 socks_proxy # 在大多数情况下，它用于 TCP 和 UDP 流量。其值通常采用 socks：// address：port 格式。 rsync_proxy # 这用于 rsync 流量，尤其是在 Gentoo 和 Arch 等发行版中。 no_proxy # 以逗号分隔的域名或 IP 列表，应绕过代理。该本地主机就是一个很好的例子。一个例子是 localhost，127.0.0.1。 TODO: 但是这些变量却不是 Bash 的自带变量，但是这些程序却无一例外得统一使用这些变量，具体为什么暂时不知道
语法格式
XXXX_proxy=&amp;ldquo;http://[USER:PASSWORD@]ServerIP:PORT/&amp;rdquo; # 需要设置用户名，密码，代理服务器的 IP 和端口，用户名和密码可省
EXAMPLE
http_proxy=&amp;ldquo;http://tom:secret@10.23.42.11:8080/&amp;rdquo; # 设置本机的 http 代理服务器为 10.23.42.11:8080，用户名是 tom，密码是 secret
同时设置 3 种类型代理，没有用户名和密码，代理服务器是 192.</description></item><item><title>通过 Socket 文件找到 TCP 连接信息</title><link>https://desistdaydream.github.io/docs/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Linux-%E7%AE%A1%E7%90%86/Linux-%E7%AE%A1%E7%90%86%E6%A1%88%E4%BE%8B/%E9%80%9A%E8%BF%87-Socket-%E6%96%87%E4%BB%B6%E6%89%BE%E5%88%B0-TCP-%E8%BF%9E%E6%8E%A5%E4%BF%A1%E6%81%AF/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Linux-%E7%AE%A1%E7%90%86/Linux-%E7%AE%A1%E7%90%86%E6%A1%88%E4%BE%8B/%E9%80%9A%E8%BF%87-Socket-%E6%96%87%E4%BB%B6%E6%89%BE%E5%88%B0-TCP-%E8%BF%9E%E6%8E%A5%E4%BF%A1%E6%81%AF/</guid><description>概述 参考：原文链接
进程的打开文件描述符表 Linux Kernel 的三个系统调用：open，socket，pipe 返回的都是一个描述符。不同的进程中，他们返回的描述符可以相同。那么，在同一个进程中，他们可以相同吗？或者说，普通文件、套接字和管道，这三者的描述符属于同一个集合吗？
在内核源码中，三个系统调用声明如下：
SYSCALL_DEFINE3(open, const char __user *, filename, int, flags, umode_t, mode); SYSCALL_DEFINE3(socket, int, family, int, type, int, protocol); SYSCALL_DEFINE1(pipe, int __user *, fildes); 他们都会先后调用函数
get_unused_fd_flags：获取当前进程打开文件描述符表中的空闲描述符； fd_install：安装新描述符到当前进程打开文件描述符表。 内核为每个进程维护了一个结构体 struct task_struct，可称为进程表项、进程控制块（PCB: Process Control Block）或者进程描述符，定义如下：
struct task_struct { volatile long state; /* -1 unrunnable, 0 runnable,&amp;gt;0 stopped */ … pid_t pid; … struct files_struct *files; … }; 其中 files 成员成为打开文件描述符表，定义如下：
struct files_struct { … struct fdtable fdtab; … struct file __rcu * fd_array[NR_OPEN_DEFAULT]; }; 其成员 fdtab 为关键数据成员，定义如下：</description></item></channel></rss>