<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Linux 文本处理 on 断念梦的站点</title><link>https://desistdaydream.github.io/docs/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Linux-%E7%AE%A1%E7%90%86/Linux-%E6%96%87%E6%9C%AC%E5%A4%84%E7%90%86/</link><description>Recent content in Linux 文本处理 on 断念梦的站点</description><generator>Hugo</generator><language>zh-cn</language><atom:link href="https://desistdaydream.github.io/docs/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Linux-%E7%AE%A1%E7%90%86/Linux-%E6%96%87%E6%9C%AC%E5%A4%84%E7%90%86/index.xml" rel="self" type="application/rss+xml"/><item><title>Linux 文本处理</title><link>https://desistdaydream.github.io/docs/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Linux-%E7%AE%A1%E7%90%86/Linux-%E6%96%87%E6%9C%AC%E5%A4%84%E7%90%86/Linux-%E6%96%87%E6%9C%AC%E5%A4%84%E7%90%86/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Linux-%E7%AE%A1%E7%90%86/Linux-%E6%96%87%E6%9C%AC%E5%A4%84%E7%90%86/Linux-%E6%96%87%E6%9C%AC%E5%A4%84%E7%90%86/</guid><description>概述 参考：
文本处理三剑客：
grep sed awk cat - 用于把标准输入的内容输出到屏幕上 Note: 如果标准输入的内容是一个文件，那么就把文件中的内容当作标准输入发送给 cat 命令，然后再输出到屏幕上
执行完 cat 命令后，屏幕上会等待我输入内容，当我输入完成按回车后，会在屏幕上输出同样的内容，这就是 cat 最基本的作用，效果如下图，第一行是我主动输入的，按下回车后，自动输出内容
~]$ cat 我在标准输入上输入了一些内容，按下回车后，输入的内容原样输出出来 我在标准输入上输入了一些内容，按下回车后，输入的内容原样输出出来 Syntax(语法) cat [OPTIONS] [FILE]
OPTIONS
-A, &amp;ndash;show-all # 与 -vET 选项的效果相同 -b, &amp;ndash;number-nonblank # number nonempty output lines, overrides -n -e # 与 -vE 选项的效果相同 -E, &amp;ndash;show-ends # 在每行末尾显示 $。 -n, &amp;ndash;number # 显示行号。 -s, &amp;ndash;squeeze-blank # suppress repeated empty output lines -t # 等价于 -vT -T, &amp;ndash;show-tabs # 将 TAB 字符显示为 ^|。TAB 字符就是按下键盘 TAB 键产生的内容，是一个制表符。也就是说将空白的制表符以 ^| 形式显示 -u (ignored) -v, &amp;ndash;show-nonprinting # 常用于查看该文件的换行符是否是 windows 下的 ^M。use ^ and M- notation, except for LFD and TAB EXAMPLE</description></item><item><title>gettext</title><link>https://desistdaydream.github.io/docs/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Linux-%E7%AE%A1%E7%90%86/Linux-%E6%96%87%E6%9C%AC%E5%A4%84%E7%90%86/gettext/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Linux-%E7%AE%A1%E7%90%86/Linux-%E6%96%87%E6%9C%AC%E5%A4%84%E7%90%86/gettext/</guid><description>概述 参考：
官网 gettext 是 GNU 旗下的一组工具集合，提供了一个框架以帮助其他 GNU 包生成多语言消息。
通常包含如下几个工具：
envsubst gettext gettext.sh ngettext 安装 gettext 一般的发行版都默认自带 gettext 工具集，如果没有，使用包管理器安装 gettext 包即可
Ubuntu
apt install gettext-base envsubst 参考：
官方手册，envsubst envsubst 程序可以用来替换环境变量的值。正常情况下，与 cat 命令类似，所有的标准输入都会复制到标准输出，但是不同的地方在于，如果标准输入中包含变量引用，比如 $VARIABLE 或 ${VARIABLE} 这种形式，则这些引用将会被替换为变量的值：
~]# envsubst HOME HOME $HOME /root ${HOME} /root 若我们将标准输入改为由文件提供，那么我们就可以将文件中的所有变量引用的地方都替换为对应的值。比如：
sudo tee ~/tmp/test.txt &amp;lt;&amp;lt;-&amp;#34;EOF&amp;#34; HOME = ${HOME} PATH = ${PATH} API_URL = ${API_URL} EOF 执行 envsubst &amp;lt; test.txt &amp;gt; test2.txt 命令以替换文件中的环境变量，生成的 test.txt 内容如下：
~]# cat test2.</description></item><item><title>grep</title><link>https://desistdaydream.github.io/docs/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Linux-%E7%AE%A1%E7%90%86/Linux-%E6%96%87%E6%9C%AC%E5%A4%84%E7%90%86/grep/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Linux-%E7%AE%A1%E7%90%86/Linux-%E6%96%87%E6%9C%AC%E5%A4%84%E7%90%86/grep/</guid><description>概述 参考：
Manual(手册)，grep(1) grep 是文本搜索工具，可以使用正则表达式在文件内查找符合条件的字串行
Syntax(语法) grep [OPTIONS] PATTERNS [FILE&amp;hellip;]
grep 根据 PATTERNS(模式) 过滤给定的内容。其实就是使用正则表达式，过滤内容。
OPTIONS Pattern Syntaz(模式语法) 用于定义过滤时所解析的正则表达式语法
-E, &amp;ndash;extended-regexp # 将 PATTERNS 解释为扩展的正则表达式（ERE，请参见下文）。 -P,&amp;ndash;perl-regexp # 将 PATTERNS 解释为与 Perl 兼容的正则表达式(PCREs)。与-z（&amp;ndash;null-data）选项结合使用时，此选项是实验性的，并且 grep -P 可能会警告未实现的功能。 Matching Control(配置控制) -i # 忽略大小写 -v, &amp;ndash;invert-match # 反向选择，选择没有要匹配的字符串的行 General Output Control(通用输出控制) 选项 -c, &amp;ndash;count # 计算找到的符合行的次数 &amp;ndash;color=auto # 把查找到内容自动表上默认颜色，auto 可改成别的颜色英文 -l,&amp;ndash;files-with-matches # 只输出匹配到的文件的文件名。常用来在一堆文件中，筛选指定内容，只查看哪些文件有指定的内容。 -m, &amp;ndash;max-count=NUM # 在 NUM 个匹配行后停止读取文件。i.e. -o, &amp;ndash;only-matching # 仅显示被匹配到的字符串，不显示整行 -s, &amp;ndash;no-messages # 不显示错误信息 Output Line Prefix Control(控制输出行的前缀) -h, &amp;ndash;no-filename # 当过滤多个文件时，不要输出文件名，仅输出过滤到的内容。 -n, &amp;ndash;line-number # 顺便输出行号 Context Line Control(控制输出内容的上下行) -A NUM, &amp;ndash;after-context=NUM # 打印出查找到的行的下面 NUM 行 -B NUM, &amp;ndash;before-context=NUM # 打印出查找到的行的上面 NUM 行 -C NUM, &amp;ndash;context=NUM # -A 与 -B 选项的结合体，控制输出内容的 上面 和下面 NUM 行 File and Directory Selection(文件和目录选择) -a, &amp;ndash;text # 像对待文本一样处理二进制文件；这等效于&amp;ndash;binary-files = text 选项。 &amp;ndash;exclude FILE # 跳过指定文件，不让 grep 处理跳过的文件。可以使用通配符。 &amp;ndash;exclude-dir=DIR # 跳过指定目录，不让 grep 处理跳过的目录。可以使用通配符。 -R, &amp;ndash;dereference-recursive # 递归地阅读每个目录下的所有文件并进行 grep 操作;该选项相当于-d recurse EXAMPLE 查看 accesslog 文件的实时更新，并筛选出不包含两个字符串的行 tailf accesslog | grep -vE &amp;lsquo;(miguvideo|mgtv)&amp;rsquo; grep &amp;ndash;color=auto -i R.</description></item><item><title>jq</title><link>https://desistdaydream.github.io/docs/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Linux-%E7%AE%A1%E7%90%86/Linux-%E6%96%87%E6%9C%AC%E5%A4%84%E7%90%86/jq/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Linux-%E7%AE%A1%E7%90%86/Linux-%E6%96%87%E6%9C%AC%E5%A4%84%E7%90%86/jq/</guid><description>概述 参考：
官方文档 jq 是轻量级且灵活的处理 JSON 数据的 Shell 命令行工具
这里是官方提供的 jq 命令在线测试工具，提供原始 JSON 内容，会自动根据 表达式 输出结果。
jq 用法详解 官方文档：https://stedolan.github.io/jq/manual/
jq 程序是一个过滤器，接收一个输入，并产生一个输出。
基础过滤 官方文档：https://stedolan.github.io/jq/manual/#Basicfilters
下面的 jq 用法，都是用下面这个 json 文件作为演示
{&amp;#34;favorite&amp;#34;:{&amp;#34;drink&amp;#34;:&amp;#34;water&amp;#34;,&amp;#34;food&amp;#34;:&amp;#34;sushi&amp;#34;,&amp;#34;game&amp;#34;:&amp;#34;WOW &amp;amp; PAL&amp;#34;},&amp;#34;sushiKinds&amp;#34;:[&amp;#34;sashimi&amp;#34;,{&amp;#34;name&amp;#34;:&amp;#34;hot&amp;#34;},{&amp;#34;name&amp;#34;:&amp;#34;handRoll&amp;#34;,&amp;#34;rice&amp;#34;:&amp;#34;more&amp;#34;},{&amp;#34;name&amp;#34;:null}],&amp;#34;arrayBrowser&amp;#34;:[{&amp;#34;name&amp;#34;:&amp;#34;360&amp;#34;,&amp;#34;url&amp;#34;:&amp;#34;http://www.so.com&amp;#34;},{&amp;#34;name&amp;#34;:&amp;#34;bing&amp;#34;,&amp;#34;url&amp;#34;:&amp;#34;http://www.bing.com&amp;#34;}]} 格式化后的内容如下，格式化内容仅作参考对照，因为 jq 命令本身就可以实现格式化的 json 的作用。
{ &amp;#34;favorite&amp;#34;: { &amp;#34;drink&amp;#34;: &amp;#34;water&amp;#34;, &amp;#34;food&amp;#34;: &amp;#34;sushi&amp;#34;, &amp;#34;game&amp;#34;: &amp;#34;WOW &amp;amp; PAL&amp;#34; }, &amp;#34;sushiKinds&amp;#34;: [ &amp;#34;sashimi&amp;#34;, { &amp;#34;name&amp;#34;: &amp;#34;hot&amp;#34; }, { &amp;#34;name&amp;#34;: &amp;#34;handRoll&amp;#34;, &amp;#34;rice&amp;#34;: &amp;#34;more&amp;#34; }, { &amp;#34;name&amp;#34;: null } ], &amp;#34;arrayBrowser&amp;#34;: [ { &amp;#34;name&amp;#34;: &amp;#34;360&amp;#34;, &amp;#34;url&amp;#34;: &amp;#34;http://www.</description></item><item><title>awk</title><link>https://desistdaydream.github.io/docs/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Linux-%E7%AE%A1%E7%90%86/Linux-%E6%96%87%E6%9C%AC%E5%A4%84%E7%90%86/awk/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Linux-%E7%AE%A1%E7%90%86/Linux-%E6%96%87%E6%9C%AC%E5%A4%84%E7%90%86/awk/</guid><description>概述 参考：
官网 官方文档 awk 以字段为单位进行处理
其实就是把一行的数据分割,然后对每个字段进行处理,包含 cut 等命令)，支持变量，条件判断，循环，数组等编程基本语言
Syntax(语法) awk [OPTIONS] &amp;lsquo;COMMAND&amp;rsquo; FILE
awk [OPTIONS] &amp;lsquo;PATTERN1{ACTION1} PATTERN2{ACTION2}&amp;hellip;.&amp;rsquo; FILE
OPTIONS
-f FILE # 指定要使用的 awk 代码文件。 -F [“[分隔符]”] # 指定分隔符，默认分隔符为一个或多个的“空格键”或者“tab 键”，也可以具体指定一个或多个 e.g.当使用-F “ [/:]”的时候即是空格、/、:这三个符号出现任意一个都算作一个分隔符 AWK 语言 awk 其实本质上可以看作编程语言，只不过这个语言只是用来处理文本的而已。在使用命令时，可以使用 -f 选项指定要使用的代码文件。
awk 语言的基本结构 awk 代码由 PATTERN {ACTION} 组成，PATTERN 是可省略的。
PATTERN 用来进行匹配的模式，匹配到的内容将会执行 ACTION 中定义的操作 /搜索模式/ 判断模式 BEGIN 执行 ACTION 前的准备工作，比如给 awk 中的自带变量赋值,在 print 前在屏幕输出点内容 END 执行 ACTION 后的收尾工作 ACTION 用来执行具体的动作 print $NUM &amp;ldquo;输出内容&amp;rdquo; $NUM&amp;hellip;&amp;hellip; # 在屏幕输出哪几个字段以及哪些内容，内容可以是各种分隔符 一个最简单的 awk 代码如下：</description></item><item><title>printf 与 echo 文本输出命令</title><link>https://desistdaydream.github.io/docs/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Linux-%E7%AE%A1%E7%90%86/Linux-%E6%96%87%E6%9C%AC%E5%A4%84%E7%90%86/printf-%E4%B8%8E-echo-%E6%96%87%E6%9C%AC%E8%BE%93%E5%87%BA%E5%91%BD%E4%BB%A4/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Linux-%E7%AE%A1%E7%90%86/Linux-%E6%96%87%E6%9C%AC%E5%A4%84%E7%90%86/printf-%E4%B8%8E-echo-%E6%96%87%E6%9C%AC%E8%BE%93%E5%87%BA%E5%91%BD%E4%BB%A4/</guid><description>概述 printf, fprintf, sprintf, snprintf, vprintf, vfprintf, vsprintf, vsnprintf - 格式化输出转换
printf 命令：格式化并且打印数据 format and print data 主要用于对 ARGUMENTs 进行格式化输出，ARGUMENTs 可以是字符串、数值等等，甚至可以通过变量引用；FORMAT 主要是对 ARGUMENTs 里的各种数据进行格式化输出，e.g.每个 ARGUMENT 是什么类型的(字符、整数、2 进制、16 进制等等)，各个 ARGUMENT 中间使用什么分隔符、是否换行等等。
语法格式：printf FORMAT [ARGUMENT&amp;hellip;] 主要用于按照 FORMAT 定义的格式来输出 ARGUMENT&amp;hellip;给出的内容
FORMAT 包括：格式替代符，自定义内容，格式控制符，这 3 个在使用的时候没有先后顺序 格式替代符 # 用于控制输出的每个 Argument 的类型。一个“格式替代符”对应后面一个 Argument，如果想要输出的类型与 Argument 给定的类型不符，则进行类型转换后输出 e.g.Argument 给了一个整数 100，而格式替代符使用的是%X,则会输出 64；若 Argument 不够 FORMAT 的个数，则以空白补充。一般情况格式替代符使用双引号引起来
%b # 相对应的参数被视为含有要被处理的转义序列之字符串。 %c # ASCII 字符。显示相对应参数的第一个字符 %d, %i # 十进制整数 %e, %E, %f # 浮点格式 %g #%e 或%f 转换，看哪一个较短，则删除结尾的零 %G #%E 或%f 转换，看哪一个较短，则删除结尾的零 %o # 不带正负号的八进制值 %s # 字符串 %u # 不带正负号的十进制值 %x # 不带正负号的十六进制值，使用 a 至 f 表示 10 至 15 %X # 不带正负号的十六进制值，使用 A 至 F 表示 10 至 15 %% # 字面意义的% 自定义内容 # 在输出内容的格式中，可以自己添加任务字符串</description></item><item><title>sed</title><link>https://desistdaydream.github.io/docs/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Linux-%E7%AE%A1%E7%90%86/Linux-%E6%96%87%E6%9C%AC%E5%A4%84%E7%90%86/sed/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Linux-%E7%AE%A1%E7%90%86/Linux-%E6%96%87%E6%9C%AC%E5%A4%84%E7%90%86/sed/</guid><description>概述 参考：
官方文档：https://www.gnu.org/software/sed/ 官方手册：https://www.gnu.org/software/sed/manual/sed.html 官方文档：https://www.gnu.org/software/sed/manual/sed.html#Execution-Cycle https://opus.konghy.cn/sed-refer/ https://github.com/liquanzhou/ops_doc/blob/master/shell%E5%AE%9E%E4%BE%8B%E6%89%8B%E5%86%8C.sh#L2925 https://mp.weixin.qq.com/s/tKvg69WvAFLJSfHsgRe1Yw sed 是一种新型的，非交互式的编辑器。它能执行与编辑器 vi 相同的编辑任务。
sed 是一种 stream editor(流编辑器)，逐行处理文件(或输入)，并将结果发送到标准输出。处理时，把当前处理的行存储在临时缓冲区中，称为 pattern space( 模式空间)，接着用 sed 命令处理缓冲区中的内容，处理完成后，把缓冲区的内容送往屏幕。然后读入下行，执行下一个循环。如果没有使诸如‘D’的特殊命令，那会在两个循环之间清空模式空间，但不会清空保留空间。这样不断重复，直到文件末尾。文件内容并没有改变，除非你使用重定向存储输出。
功能：主要用来自动编辑一个或多个文件,简化对文件的反复操作,编写转换程序等。 sed 工作原理 sed 实际上是一个循环结构，该循环用来对输入给 sed 文本的每一行执行下列操作：
sed 从输入内容中读取一行，删除任何尾随的换行符，并将该行保存到 模式空间 中。 对模式空间中的内容，执行 COMMAND。执行之前需要根据 ADDR(行定位)，验证模式空间中的行是否符合 ADDR 中给定的条件。 只有符合条件的，COMMAND 才会执行 上一步完成后，模式空间中的内容会打印到标准输出中。如果删除了末尾的换行符，则会添加回去。(如果使用了 -n 选项，则不会将模式空间中的行输出) 然后回到循环体的开头，继续处理输入内容的下一行 除非有特殊命令（例如“d 使用&amp;rsquo;），则在两个循环之间删除模式空间。另一方面，保持空间可在周期之间保持其数据（请参见命令&amp;rsquo;H&amp;rsquo;，&amp;lsquo;H&amp;rsquo;，&amp;lsquo;X&amp;rsquo;，&amp;lsquo;G&amp;rsquo;，&amp;lsquo;G&amp;rsquo;在两个缓冲区之间移动数据）
Syntax(语法) sed [OPTIONS] SCRIPT FILE(s)
OPTIONS -e, &amp;ndash;expression=&amp;lt;SCRIPT&amp;gt; # 以选项中的指定的 SCRIPT 来处理输入的文本文件，常用来在一行命令中，执行两个 sed SCRIPT -f, &amp;ndash;file=&amp;lt;SCRIPT&amp;gt; # 以选项中指定的 SCRIPT 文件来处理输入的文本文件,把 sed 相关命令写进文件里，直接引用该文件中的命令进行操作 -i # 直接编辑原文件，sed 操作的内容不输出到屏幕，直接更改文件内容 -n, &amp;ndash;quiet, -silent # 禁止模式空间中的内容在标准输出中打印 通常与 p 命令一同使用，用来仅显示 sed 操作的行。 -r, &amp;ndash;regexp-extended # 允许在 SCRIPT 中使用扩展的正则表达式。如果在 SCRIPT 中使用正则，且不使用该选项，运行就会报错 SCRIPT SCRIPT 是 sed 在处理文本时主要依赖的部分，脚本包含多个部分，至少要具有一个 COMMAND</description></item></channel></rss>