<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>断念梦的站点 – 故障处理</title><link>https://desistdaydream.github.io/docs/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Linux-%E7%AE%A1%E7%90%86/%E6%80%A7%E8%83%BD%E8%AF%84%E4%BC%B0%E4%B8%8E%E6%95%85%E9%9A%9C%E5%A4%84%E7%90%86/%E6%95%85%E9%9A%9C%E5%A4%84%E7%90%86/</link><description>Recent content in 故障处理 on 断念梦的站点</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><atom:link href="https://desistdaydream.github.io/docs/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Linux-%E7%AE%A1%E7%90%86/%E6%80%A7%E8%83%BD%E8%AF%84%E4%BC%B0%E4%B8%8E%E6%95%85%E9%9A%9C%E5%A4%84%E7%90%86/%E6%95%85%E9%9A%9C%E5%A4%84%E7%90%86/index.xml" rel="self" type="application/rss+xml"/><item><title>Docs: 紧急模式或救援模式</title><link>https://desistdaydream.github.io/docs/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Linux-%E7%AE%A1%E7%90%86/%E6%80%A7%E8%83%BD%E8%AF%84%E4%BC%B0%E4%B8%8E%E6%95%85%E9%9A%9C%E5%A4%84%E7%90%86/%E6%95%85%E9%9A%9C%E5%A4%84%E7%90%86/%E7%B4%A7%E6%80%A5%E6%A8%A1%E5%BC%8F%E6%88%96%E6%95%91%E6%8F%B4%E6%A8%A1%E5%BC%8F/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Linux-%E7%AE%A1%E7%90%86/%E6%80%A7%E8%83%BD%E8%AF%84%E4%BC%B0%E4%B8%8E%E6%95%85%E9%9A%9C%E5%A4%84%E7%90%86/%E6%95%85%E9%9A%9C%E5%A4%84%E7%90%86/%E7%B4%A7%E6%80%A5%E6%A8%A1%E5%BC%8F%E6%88%96%E6%95%91%E6%8F%B4%E6%A8%A1%E5%BC%8F/</guid><description>
&lt;h1 id="概述">概述&lt;a class="td-heading-self-link" href="#%e6%a6%82%e8%bf%b0" aria-label="Heading self-link">&lt;/a>&lt;/h1>
&lt;p>Linux 系统难免出现问题，下面总结了一些在出现问题时，可以用到的修复方式。&lt;/p>
&lt;p>比如 单用户模式、GRUB 命令操作、Linux 救援模式 的故障修复案例。&lt;/p>
&lt;p>一般的故障修复，都是通过进入一个微型系统，并在微型系统中关联正常系统，来实现对正常系统进行修复操作的。常见的微型系统大体分为两类：&lt;/p>
&lt;ul>
&lt;li>&lt;strong>存在于内核中的微型系统，通过内核来启动&lt;/strong>&lt;/li>
&lt;li>&lt;strong>通过外部挂载(光盘、usb 等)的方式来启动&lt;/strong>
&lt;ul>
&lt;li>Preinstallation Environment 版本与 Live 版本是 Windows 和 Linux 的预安装系统的两种微型系统的称呼。&lt;/li>
&lt;li>部分 Linux 发行版的安装 iso 中也会自带一个微型系统（比如 CentOS），而没有专门的 Live 系统。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h1 id="emergency紧急-模式">Emergency(紧急) 模式&lt;a class="td-heading-self-link" href="#emergency%e7%b4%a7%e6%80%a5-%e6%a8%a1%e5%bc%8f" aria-label="Heading self-link">&lt;/a>&lt;/h1>
&lt;p>Linux 系统提供了紧急模式(类似 Windows 安全模式)，该模式镶嵌在内核中。可以在最小环境中(仅仅运行系统所需的必要程序)进行系统维护。在紧急模式中，Linux 引导进入根 shell，网络被禁用，只有少数进程运行。紧急模式可以用来修改文件系统损坏、还原配置文件、移动用户数据等。&lt;/p>
&lt;h2 id="启动紧急模式">启动紧急模式&lt;a class="td-heading-self-link" href="#%e5%90%af%e5%8a%a8%e7%b4%a7%e6%80%a5%e6%a8%a1%e5%bc%8f" aria-label="Heading self-link">&lt;/a>&lt;/h2>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/ewdpso/1616163959565-28b07db0-d297-4c04-bdf7-b31a43af0106.jpeg" alt="">&lt;/p>
&lt;p>在该界面选中想要使用的内核后，按 e 键 ，进入编辑启动参数界面&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/ewdpso/1616163959592-6d0be599-731a-4f6c-b6b1-9e195991cfb9.jpeg" alt="">&lt;/p>
&lt;p>在上图红框位置将 ro 改为 rw init=/sysroot/bin/sh 。然后按 ctrl+x 来启动。这时候，就进入了紧急模式，紧急模式的界面是像下图这样的&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/ewdpso/1616163959556-b1d3734e-d706-47fc-a83c-131c6f049baa.jpeg" alt="">&lt;/p>
&lt;p>这是一个 sh 的 shell(也可以启动其他 shell，比如 bash 等)，可以执行一些基本命令，目录结构如下&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>~&lt;span style="color:#ce5c00;font-weight:bold">]&lt;/span>&lt;span style="color:#8f5902;font-style:italic"># ls&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>bin dev dracut-state.sh etc init lib lib64 proc root run sbin shutdown sys sysroot tmp usr var
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>其中 &lt;code>sysroot&lt;/code> 目录，就是我们正常启动系统时，所看到的 &lt;code>/&lt;/code> 目录&lt;/p>
&lt;p>在这种模式下，可以看到，仅有个别进程在运行，/init rhgb 是该系统模式下的第一个进程，与正常系统不同。&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/ewdpso/1616163959562-5047fe7d-4089-43e3-933c-0eb9ab6c80d4.jpeg" alt="">&lt;/p>
&lt;p>sh 进程是因为我们需要一个可以操作的 shell，所以在修改启动项时添加的。&lt;/p>
&lt;p>实际上，所谓的紧急模式，就是在安装 linux 系统时，内核中内置的一个微型系统，进入该微型系统后，咱正常系统的根目录，就被挂载到微型系统的/sysroot 下了，由于没有挂载其他物理磁盘，也没有任何多余进程运行，所以只要内核是好的，那么紧急模式是可以正常进入的。&lt;/p>
&lt;p>该模式可以用来修复一些与非内核错误的一些故障&lt;/p>
&lt;h1 id="rescue救援-模式">Rescue(救援) 模式&lt;a class="td-heading-self-link" href="#rescue%e6%95%91%e6%8f%b4-%e6%a8%a1%e5%bc%8f" aria-label="Heading self-link">&lt;/a>&lt;/h1>
&lt;p>当紧急模式不可用时，说明内核或者内核相关出现问题，这时候，我们就需要使用救援模式了。&lt;/p>
&lt;p>救援模式并不在已经安装的系统或者内核上，而是通过外部挂载 linux 系统镜像来启动。相当于通过外挂的系统镜像来启动一个微型系统，来诊断并修复当前系统&lt;/p>
&lt;h2 id="启动救援模式">启动救援模式&lt;a class="td-heading-self-link" href="#%e5%90%af%e5%8a%a8%e6%95%91%e6%8f%b4%e6%a8%a1%e5%bc%8f" aria-label="Heading self-link">&lt;/a>&lt;/h2>
&lt;p>首先需要将系统镜像挂载到设备上，物理机直接插入光盘或者 U 盘，并修改启动项；虚拟机的话同理，将 linux 系统镜像挂载进虚拟机然后通过该系统镜像启动系统。&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/ewdpso/1616163959557-c45d87ec-9d2c-4296-b14a-fdd3f7b710e1.jpeg" alt="">&lt;/p>
&lt;p>在上图选择 &lt;code>Troubleshooting&lt;/code> 后，选择 &lt;code>Rescue a CentOS system&lt;/code>（救援一个 centos 系统）&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/ewdpso/1616163959573-28e0e935-14ef-4a12-8d1f-20ad9d79a274.jpeg" alt="">&lt;/p>
&lt;p>在上图蓝线上半部分，选择 1 继续之后。将会启动一个微型系统，并进入一个 shell，其中会提示我们，设备上正常系统的 &lt;code>/&lt;/code> 目录被挂载到 &lt;code>/mnt/sysimage&lt;/code> ，该情况与 紧急模式 一样，只是正常系统的跟目录被挂载的路径不同罢了。&lt;/p>
&lt;p>通过光盘启动的微型系统，明显比紧急模式的微型系统 功能更加完善，可以看到有很多进程&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/ewdpso/1616163959579-0a7e5ff3-ae98-4560-8a00-c3b58808a04d.jpeg" alt="">&lt;/p>
&lt;p>同样也是一个 sh 的 shell。可以在该 shell 下，进入 /mnt/sysimage 目录来对正常的系统进行修复&lt;/p>
&lt;h2 id="这类模式常见使用方式">这类模式常见使用方式&lt;a class="td-heading-self-link" href="#%e8%bf%99%e7%b1%bb%e6%a8%a1%e5%bc%8f%e5%b8%b8%e8%a7%81%e4%bd%bf%e7%94%a8%e6%96%b9%e5%bc%8f" aria-label="Heading self-link">&lt;/a>&lt;/h2>
&lt;p>由于进入这类救援模式后，原本系统的 &lt;code>/&lt;/code> 被挂载到微型系统的的其他目录，这之后直接使用 chroot /PATH/DIR 命令，即可将当前 / 目录转变到原本系统上，然后就可以更方便的定位问题了，如果不进行 chroot，那么操作目录的时候，其实挺不方便的~~~~&lt;/p>
&lt;h2 id="ubuntu-的-rescue-模式">Ubuntu 的 Rescue 模式&lt;a class="td-heading-self-link" href="#ubuntu-%e7%9a%84-rescue-%e6%a8%a1%e5%bc%8f" aria-label="Heading self-link">&lt;/a>&lt;/h2>
&lt;p>网上充斥着大量的垃圾信息，并没有明确指导如何通过挂盘来进入 Rescue 模式，实际上，Ubuntu Server 版的 ISO 并没有提供这个功能，那么有两种方式来实现：&lt;/p>
&lt;ul>
&lt;li>使用 Ubuntu Desktop 的 ISO，进入界面后选择 &lt;strong>Try Ubuntu&lt;/strong>，也就是网上常说的 &lt;strong>Live CD&lt;/strong> 模式。只不过这是图形界面，进入后配置好 root 密码，可以使用 &lt;code>ctrl + alt + f3&lt;/code> 来切换 TTY，并在 CLI 下进行修复工作&lt;/li>
&lt;li>使用 CentOS 的 ISO 进入 Rescue 模式，同样可以修复挂载 Ubuntu 的分区到指定的目录。&lt;/li>
&lt;/ul>
&lt;h1 id="centos-8-上的紧急与救援模式">CentOS 8 上的紧急与救援模式&lt;a class="td-heading-self-link" href="#centos-8-%e4%b8%8a%e7%9a%84%e7%b4%a7%e6%80%a5%e4%b8%8e%e6%95%91%e6%8f%b4%e6%a8%a1%e5%bc%8f" aria-label="Heading self-link">&lt;/a>&lt;/h1>
&lt;p>原文链接：&lt;a href="https://linuxhint.com/boot-emergency-mode-centos-8/">https://linuxhint.com/boot-emergency-mode-centos-8/&lt;/a>&lt;/p>
&lt;p>在最新的 CentOS 中，即 CentOS 8 紧急模式和救援模式已经取代了运行级别的概念。运行级别是用于各种任务的不同模式。在 CentOS 8 中，Rescue 模式相当于单用户模式，而紧急启动模式提供了一个最小的环境来修复您的系统。&lt;/p>
&lt;p>今天我们将学习如何将 CentOS 8 启动到救援和紧急模式。&lt;/p>
&lt;h2 id="如何启动进入救援模式">如何启动进入救援模式&lt;a class="td-heading-self-link" href="#%e5%a6%82%e4%bd%95%e5%90%af%e5%8a%a8%e8%bf%9b%e5%85%a5%e6%95%91%e6%8f%b4%e6%a8%a1%e5%bc%8f" aria-label="Heading self-link">&lt;/a>&lt;/h2>
&lt;p>救援模式需要 root 密码进行身份验证，并允许您在正常启动过程不起作用时恢复系统。救援模式将尝试设置所有本地文件系统并启动一些基本系统服务。救援模式不启动网络接口，也不允许多个用户登录。&lt;/p>
&lt;p>启动计算机并等待 GRUB 菜单出现。&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/ewdpso/1630379281707-861e3e5b-49c3-4721-9e4e-d2f0dd9239cc.png" alt="image.png">&lt;/p>
&lt;p>现在按“e”打开编辑菜单：&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/ewdpso/1630379281756-579ed222-fa5a-48c6-9182-5a19adc12983.png" alt="image.png">&lt;/p>
&lt;p>现在，找到以下面的屏幕截图所示的 “Linux” 关键字开头的行：&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/ewdpso/1630379280843-f87b7899-36d3-4049-8ba5-38f918926497.png" alt="image.png">&lt;/p>
&lt;p>使用键盘上的终点按钮转到线的末尾，并在行结束时添加以下参数：&lt;/p>
&lt;p>systemd.Unit = Rescue.target&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/ewdpso/1630379280876-d0125040-66ac-4757-abde-e5089a4c1b4e.png" alt="image.png">&lt;/p>
&lt;p>按 Ctrl + X 启动系统，但此时使用新参数将让您输入救援模式。&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/ewdpso/1630379280860-c9be44a2-22e8-4fa5-a6c7-4dc77dffa729.png" alt="image.png">&lt;/p>
&lt;p>操作系统会要求 root 密码。在提供密码后，您将进入救援模式。&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/ewdpso/1630379281433-ed1c7906-6118-4f92-a7cc-1dc556b445a6.png" alt="image.png">&lt;/p>
&lt;p>现在，您可以在救援模式下修复系统。&lt;/p>
&lt;p>完成救援模式后，您可以通过运行“退出”命令来退出救援/紧急模式。&lt;/p>
&lt;h2 id="启动进入紧急模式">启动进入紧急模式&lt;a class="td-heading-self-link" href="#%e5%90%af%e5%8a%a8%e8%bf%9b%e5%85%a5%e7%b4%a7%e6%80%a5%e6%a8%a1%e5%bc%8f" aria-label="Heading self-link">&lt;/a>&lt;/h2>
&lt;p>紧急模式甚至救援模式不起作用时，恢复系统的最小环境。紧急将根文件安装为只读，并不尝试挂载本地文件系统。紧急模式也没有启动网络接口。&lt;/p>
&lt;p>将系统启动到紧急模式的过程与救援模式相同。&lt;/p>
&lt;p>首先，启动计算机并等待 GRUB 菜单显示：&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/ewdpso/1630379281944-4f628d77-411e-4319-af8c-1a1557c7e8ce.png" alt="image.png">&lt;/p>
&lt;p>现在按“E”打开编辑菜单：&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/ewdpso/1630379282293-94e66990-034a-4b85-8cfa-7e9262ade0a8.png" alt="image.png">&lt;/p>
&lt;p>现在定位以“Linux”关键字开头的行，如下屏幕截图所示：&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/ewdpso/1630379282273-c76fcd43-02db-4a14-b7e3-52b4ca27cb3e.png" alt="image.png">&lt;/p>
&lt;p>使用键盘上的终点按钮转到线的末尾，并在行结束时添加以下参数：&lt;/p>
&lt;p>systemd.unit = Encrasst.target.&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/ewdpso/1630379283117-bf48ec7a-b48c-4d23-bd05-b284dce0dcb3.png" alt="image.png">&lt;/p>
&lt;p>按 Ctrl + X 启动系统，但此时使用新参数将让您输入紧急模式。&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/ewdpso/1630379283276-16043784-d87e-4a63-8c3b-95c4c030fd98.png" alt="image.png">&lt;/p>
&lt;p>提供密码后，您将进入紧急模式。&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/ewdpso/1630379283239-886da796-8374-441c-a133-2e28b376336d.png" alt="image.png">&lt;/p>
&lt;p>现在，即使救援模式不起作用，您也可以在紧急模式下修复系统。&lt;/p>
&lt;p>完成紧急模式后，您可以通过运行“退出”命令来退出救援/紧急模式。&lt;/p></description></item><item><title>Docs: 网络丢包问题处理</title><link>https://desistdaydream.github.io/docs/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Linux-%E7%AE%A1%E7%90%86/%E6%80%A7%E8%83%BD%E8%AF%84%E4%BC%B0%E4%B8%8E%E6%95%85%E9%9A%9C%E5%A4%84%E7%90%86/%E6%95%85%E9%9A%9C%E5%A4%84%E7%90%86/%E7%BD%91%E7%BB%9C%E4%B8%A2%E5%8C%85%E9%97%AE%E9%A2%98%E5%A4%84%E7%90%86/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Linux-%E7%AE%A1%E7%90%86/%E6%80%A7%E8%83%BD%E8%AF%84%E4%BC%B0%E4%B8%8E%E6%95%85%E9%9A%9C%E5%A4%84%E7%90%86/%E6%95%85%E9%9A%9C%E5%A4%84%E7%90%86/%E7%BD%91%E7%BB%9C%E4%B8%A2%E5%8C%85%E9%97%AE%E9%A2%98%E5%A4%84%E7%90%86/</guid><description>
&lt;h1 id="概述">概述&lt;a class="td-heading-self-link" href="#%e6%a6%82%e8%bf%b0" aria-label="Heading self-link">&lt;/a>&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://mp.weixin.qq.com/s/iw7KnLlSIhmhYYwKYuqQSA">公众号-马哥Linux运维，如何高效定位网络丢包问题？&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>引言&lt;/p>
&lt;hr>
&lt;p>本期分享一个比较常见的网络问题&amp;ndash;丢包。例如我们去ping一个网站，如果能ping通，且网站返回信息全面，则说明与网站服务器的通信是畅通的，如果ping不通，或者网站返回的信息不全等，则很可能是数据被丢包了，类似情况想必大家都不陌生。针对网络丢包，本人提供一些常见的丢包故障定位方法，希望能够帮助大家对网络丢包有更多的认识，遇到丢包莫要慌，且跟着一起来涨姿(知)势(识)···&lt;/p>
&lt;p>什么是丢包&lt;/p>
&lt;hr>
&lt;p>数据在Internet上是以数据包为单位传输的，单位为字节，数据在网络上传输，受网络设备，网络质量等原因的影响，使得接收到的数据少于发送出去的数据，造成丢包。&lt;/p>
&lt;p>数据包接收、发送原理&lt;/p>
&lt;hr>
&lt;p>&lt;img src="https://mmbiz.qpic.cn/sz_mmbiz_jpg/8pECVbqIO0wf4MEvQSRT3JhRrXHLiaELpicKb0Fr29FJFV5BXqgW1WhuRmyOhGI4whSVWyypG5l8gBtkarPFicMqg/640?wx_fmt=jpeg&amp;amp;wxfrom=13" alt="">&lt;/p>
&lt;p>发送数据包：&lt;/p>
&lt;p>1.应用程序的数据包，在TCP层增加TCP报文头，形成可传输的数据包。 2.在IP层增加IP报头，形成IP报文。 3.经过数据网卡驱动程序将IP包再添加14字节的MAC头，构成frame（暂⽆CRC），frame（暂⽆CRC）中含有发送端和接收端的MAC地址。 4.驱动程序将frame（暂⽆CRC）拷贝到网卡的缓冲区，由网卡处理。 5.⽹卡为frame（暂⽆CRC）添加头部同步信息和CRC校验，将其封装为可以发送的packet，然后再发送到网线上，这样说就完成了一个IP报文的发送了，所有连接到这个网线上的网卡都可以看到该packet。&lt;/p>
&lt;p>接收数据包：&lt;/p>
&lt;p>&lt;img src="https://mmbiz.qpic.cn/sz_mmbiz_png/8pECVbqIO0wf4MEvQSRT3JhRrXHLiaELp3HyibibaE0ic8WwHP9vianZ7uGoyIfMPvPoQQtc2Uq4ibIX1R6QUqQHM5SQ/640?wx_fmt=png&amp;amp;wxfrom=13" alt="">&lt;/p>
&lt;p>1.⽹卡收到⽹线上的packet，⾸先检查packet的CRC校验，保证完整性，然后将packet头去掉，得到frame。（⽹卡会检查MAC包内的⽬的MAC地址是否和本⽹卡的MAC地址⼀样，不⼀样则会丢弃。） 2.⽹卡将frame拷贝到预分配的ring buffer缓冲。 3.⽹卡驱动程序通知内核处理，经过TCP/IP协议栈层层解码处理。 4.应⽤程序从socket buffer 中读取数据。&lt;/p>
&lt;p>核心思路&lt;/p>
&lt;hr>
&lt;p>了解了收发包的原理，可以了解到丢包原因主要会涉及⽹卡设备、⽹卡驱动、内核协议栈三⼤类。以下我们将遵循“从下到上分层分析（各层可能性出现的丢包场景），然后查看关键信息，最终得出分析结果”的原则展开介绍。&lt;/p>
&lt;p>目录&amp;ndash;网络丢包情形概览&lt;/p>
&lt;hr>
&lt;p>&amp;gt; 硬件网卡丢包&lt;/p>
&lt;p>&amp;gt; 网卡驱动丢包&lt;/p>
&lt;p>&amp;gt; 以太网链路层丢包&lt;/p>
&lt;p>&amp;gt; 网络IP层丢包&lt;/p>
&lt;p>&amp;gt; 传输层UDP/TCP丢包&lt;/p>
&lt;p>&amp;gt; 应用层socket丢包&lt;/p>
&lt;p>针对以上6种情形，分别作出如下详述~&lt;/p>
&lt;p>硬件网卡丢包&lt;/p>
&lt;hr>
&lt;p>Ring Buffer溢出&lt;/p>
&lt;p>&lt;img src="https://mmbiz.qpic.cn/sz_mmbiz_jpg/8pECVbqIO0wf4MEvQSRT3JhRrXHLiaELpApdl8PFzEWia5vCPZp4UibSyyicscT82tqIZenrQkkCAtMneklMibXo6Lg/640?wx_fmt=jpeg&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1" alt="">&lt;/p>
&lt;p>如图所示，物理介质上的数据帧到达后首先由NIC（网络适配器）读取，写入设备内部缓冲区Ring Buffer中，再由中断处理程序触发Softirq从中消费，Ring Buffer的大小因网卡设备而异。当网络数据包到达（生产）的速率快于内核处理（消费）的速率时，Ring Buffer很快会被填满，新来的数据包将被丢弃；&lt;/p>
&lt;p>查看：&lt;/p>
&lt;p>通过ethtool或/proc/net/dev可以查看因Ring Buffer满而丢弃的包统计，在统计项中以fifo标识：&lt;/p>
&lt;p>$ ethtool -S eth0|grep rx_fifo&lt;br>
rx_fifo_errors: 0&lt;br>
$ cat /proc/net/dev&lt;br>
Inter-|Receive | Transmitface |bytes packets errs drop fifo frame compressed&lt;br>
multicast|bytes packets errs drop fifo colls carrier compressed&lt;br>
eth0: 17253386680731 42839525880 0 0 0 0 0 244182022 14879545018057 41657801805 0 0 0 0 0 0&lt;/p>
&lt;p># 查看eth0网卡Ring Buffer最大值和当前设置&lt;/p>
&lt;p>$ ethtool -g eth0&lt;/p>
&lt;p>解决方案：修改网卡eth0接收与发送硬件缓存区大小&lt;/p>
&lt;p>$ ethtool -G eth0 rx 4096 tx 4096&lt;/p>
&lt;p>网卡端口协商丢包&lt;/p>
&lt;p>1. 查看网卡丢包统计：ethtool -S eth1/eth0&lt;/p>
&lt;p>&lt;img src="https://mmbiz.qpic.cn/sz_mmbiz_jpg/8pECVbqIO0wf4MEvQSRT3JhRrXHLiaELpU6TOoAUgVKF8hdibBIQ3ArRrvry7evhlkWvxjicEseKYgM57ZzlB1drw/640?wx_fmt=jpeg&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1" alt="">&lt;/p>
&lt;p>2. 查看网卡配置状态：ethtool eth1/eth0&lt;/p>
&lt;p>&lt;img src="https://mmbiz.qpic.cn/sz_mmbiz_jpg/8pECVbqIO0wf4MEvQSRT3JhRrXHLiaELpJuzjHnt4h075U6g7zem5F46mVNXZkex6vAXu4ZqxZrY7icwELK3AULQ/640?wx_fmt=jpeg&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1" alt="">&lt;/p>
&lt;p>主要查看网卡和上游网络设备协商速率和模式是否符合预期；&lt;/p>
&lt;p>解决方案：&lt;/p>
&lt;p>1 重新自协商： ethtool -r eth1/eth0;&lt;/p>
&lt;p>2 如果上游不支持自协商，可以强制设置端口速率：&lt;/p>
&lt;p>ethtool -s eth1 speed 1000 duplex full autoneg off&lt;/p>
&lt;p>网卡流控丢包&lt;/p>
&lt;p>1. 查看流控统计：&lt;/p>
&lt;p>ethtool -S eth1 | grep control&lt;/p>
&lt;p>&lt;img src="https://mmbiz.qpic.cn/sz_mmbiz_png/8pECVbqIO0wf4MEvQSRT3JhRrXHLiaELpl0KcSQ36THNlzrEicYT5L0tibAzzbulqicia1B0IEDy9I24XGZia1gGYDrw/640?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1" alt="">&lt;/p>
&lt;p>rx_flow_control_xon是在网卡的RX Buffer满或其他网卡内部的资源受限时，给交换机端口发送的开启流控的pause帧计数。对应的，tx_flow_control_xoff是在资源可用之后发送的关闭流控的pause帧计数。&lt;/p>
&lt;p>2 .查看网络流控配置：ethtool -a eth1&lt;/p>
&lt;p>&lt;img src="https://mmbiz.qpic.cn/sz_mmbiz_jpg/8pECVbqIO0wf4MEvQSRT3JhRrXHLiaELp8BibppkXUpwverDFkF6ibdgBFoDk38ApWHTuxw2dnWZ3sMBgHK7MrM6A/640?wx_fmt=jpeg&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1" alt="">&lt;/p>
&lt;p>解决方案：关闭网卡流控&lt;/p>
&lt;p>ethtool -A ethx autoneg off //自协商关闭&lt;br>
ethtool -A ethx tx off //发送模块关闭&lt;br>
ethtool -A ethx rx off //接收模块关闭&lt;/p>
&lt;p>报文mac地址丢包&lt;/p>
&lt;hr>
&lt;p>一般计算机网卡都工作在非混杂模式下，此时网卡只接受来自网络端口的目的地址指向自己的数据，如果报文的目的mac地址不是对端的接口的mac地址，一般都会丢包，一般这种情况很有可能是源端设置静态arp表项或者动态学习的arp表项没有及时更新，但目的端mac地址已发生变化（换了网卡），没有更新通知到源端（比如更新报文被丢失，中间交换机异常等情况）；&lt;/p>
&lt;p>查看：&lt;/p>
&lt;p>1.目的端抓包，tcpdump可以开启混杂模式，可以抓到对应的报文，然后查看mac地址；&lt;/p>
&lt;p>2.源端查看arp表或者抓包（上一跳设备），看发送的mac地址是否和下一跳目的端的mac地址一致；&lt;/p>
&lt;p>解决方案：&lt;/p>
&lt;p>1.刷新arp表然后发包触发arp重新学习（可能影响其他报文，增加延时，需要小心操作）；&lt;/p>
&lt;p>2.可以在源端手动设置正确的静态的arp表项；&lt;/p>
&lt;p>其他网卡异常丢包&lt;/p>
&lt;p>这类异常比少见，但如果都不是上面哪些情况，但网卡统计里面任然有丢包计数，可以试着排查一下：&lt;/p>
&lt;p>网卡firmware版本:&lt;/p>
&lt;p>排查一下网卡phy芯片firmware是不是有bug，安装的版本是不是符合预期，查看 ethtool -i eth1:&lt;/p>
&lt;p>&lt;img src="https://mmbiz.qpic.cn/sz_mmbiz_jpg/8pECVbqIO0wf4MEvQSRT3JhRrXHLiaELpO18ia59libkA80icp3oQNXVlgzBXibKHNY4tJXZuG2ice3y5ItcXl45fe9Q/640?wx_fmt=jpeg&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1" alt="">&lt;/p>
&lt;p>和厂家提case询问是不是已知问题，有没有新版本等；&lt;/p>
&lt;p>网线接触不良：&lt;/p>
&lt;p>如果网卡统计里面存在crc error 计数增长，很可能是网线接触不良，可以通知网管排查一下：&lt;/p>
&lt;p>ethtool -S eth0&lt;/p>
&lt;p>&lt;img src="https://mmbiz.qpic.cn/sz_mmbiz_jpg/8pECVbqIO0wf4MEvQSRT3JhRrXHLiaELphRNMfo5BSoZT1Hicda2Jf9jWY12eNgcMMpCA38YhztfWveRPw3dn4Mw/640?wx_fmt=jpeg&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1" alt="">&lt;/p>
&lt;p>解决方案：一般试着重新插拔一下网线，或者换一根网线，排查插口是否符合端口规格等;&lt;/p>
&lt;p>报文长度丢包&lt;/p>
&lt;p>网卡有接收正确报文长度范围，一般正常以太网报文长度范围：64-1518，发送端正常情况会填充或者分片来适配，偶尔会发生一些异常情况导致发送报文不正常丢包；&lt;/p>
&lt;p>查看：&lt;/p>
&lt;p>ethtool -S eth1|grep length_errors&lt;/p>
&lt;p>&lt;img src="https://mmbiz.qpic.cn/sz_mmbiz_png/8pECVbqIO0wf4MEvQSRT3JhRrXHLiaELpL9DY8z56qeecMib4uyCvUPEzaHf38vGwl1M1wXC1BLiavQm9HNFeK85A/640?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1" alt="">&lt;/p>
&lt;p>解决方案：&lt;/p>
&lt;p>1 调整接口MTU配置，是否开启支持以太网巨帧；&lt;/p>
&lt;p>2 发送端开启PATH MTU进行合理分片；&lt;/p>
&lt;p>简单总结一下网卡丢包：&lt;/p>
&lt;p>&lt;img src="https://mmbiz.qpic.cn/sz_mmbiz_png/8pECVbqIO0wf4MEvQSRT3JhRrXHLiaELpGXZAEyPnaZscDmniaNZYYQpkiaJ72nsLLqjwVnUSs7kLnyGrj70oJnNQ/640?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1" alt="">&lt;/p>
&lt;p>网卡驱动丢包&lt;/p>
&lt;hr>
&lt;p>查看：ifconfig eth1/eth0 等接口&lt;/p>
&lt;p>&lt;img src="https://mmbiz.qpic.cn/sz_mmbiz_png/8pECVbqIO0wf4MEvQSRT3JhRrXHLiaELp5x4TxlNUFooiaAqqh82tadCBDgV1Itm3z7YsxgwwJfzrjtevXibBVPJA/640?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1" alt="">&lt;/p>
&lt;p>1.RX errors: 表示总的收包的错误数量，还包括too-long-frames错误，Ring Buffer 溢出错误，crc 校验错误，帧同步错误，fifo overruns 以及 missed pkg 等等。&lt;/p>
&lt;p>2.RX dropped: 表示数据包已经进入了 Ring Buffer，但是由于内存不够等系统原因，导致在拷贝到内存的过程中被丢弃。&lt;/p>
&lt;p>3.RX overruns: 表示了 fifo 的 overruns，这是由于 Ring Buffer(aka Driver Queue) 传输的 IO 大于 kernel 能够处理的 IO 导致的，而 Ring Buffer 则是指在发起 IRQ 请求之前的那块 buffer。很明显，overruns 的增大意味着数据包没到 Ring Buffer 就被网卡物理层给丢弃了，而 CPU 无法即使的处理中断是造成 Ring Buffer 满的原因之一，上面那台有问题的机器就是因为 interruprs 分布的不均匀(都压在 core0)，没有做 affinity 而造成的丢包。&lt;/p>
&lt;p>4. RX frame: 表示 misaligned 的 frames。&lt;/p>
&lt;p>5. 对于 TX 的来说，出现上述 counter 增大的原因主要包括 aborted transmission, errors due to carrirer, fifo error, heartbeat erros 以及 windown error，而 collisions 则表示由于 CSMA/CD 造成的传输中断。&lt;/p>
&lt;p>驱动溢出丢包&lt;/p>
&lt;p>netdev_max_backlog是内核从NIC收到包后，交由协议栈（如IP、TCP）处理之前的缓冲队列。每个CPU核都有一个backlog队列，与Ring Buffer同理，当接收包的速率大于内核协议栈处理的速率时，CPU的backlog队列不断增长，当达到设定的netdev_max_backlog值时，数据包将被丢弃。&lt;/p>
&lt;p>查看:&lt;/p>
&lt;p>通过查看/proc/net/softnet_stat可以确定是否发生了netdev backlog队列溢出：&lt;/p>
&lt;p>&lt;img src="https://mmbiz.qpic.cn/sz_mmbiz_png/8pECVbqIO0wf4MEvQSRT3JhRrXHLiaELpAiblOcMrLMiaiaNDjia8kiayUQJ21WbLzH3ic3CicyOR9K2J4wzNRNuPpHprQ/640?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1" alt="">&lt;/p>
&lt;p>其中：每一行代表每个CPU核的状态统计，从CPU0依次往下；每一列代表一个CPU核的各项统计：第一列代表中断处理程序收到的包总数；第二列即代表由于netdev_max_backlog队列溢出而被丢弃的包总数。从上面的输出可以看出，这台服务器统计中，并没有因为netdev_max_backlog导致的丢包。&lt;/p>
&lt;p>解决方案：&lt;/p>
&lt;p>netdev_max_backlog的默认值是1000，在高速链路上，可能会出现上述第二统计不为0的情况，可以通过修改内核参数 net.core.netdev_max_backlog来解决：&lt;/p>
&lt;p>$ sysctl -w net.core.netdev_max_backlog=2000&lt;/p>
&lt;p>单核负载高导致丢包&lt;/p>
&lt;p>单核CPU软中断占有高, 导致应用没有机会收发或者收包比较慢，即使调整netdev_max_backlog队列大小仍然会一段时间后丢包，处理速度跟不上网卡接收的速度;&lt;/p>
&lt;p>查看：mpstat -P ALL 1&lt;/p>
&lt;p>&lt;img src="https://mmbiz.qpic.cn/sz_mmbiz_png/8pECVbqIO0wf4MEvQSRT3JhRrXHLiaELpknZxjHZOCAUOTh6F7XkBTNTLgMhUXdqdybYSga2W6YOlCEiaUQWcndQ/640?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1" alt="">&lt;/p>
&lt;p>单核软中断占有100%，导致应用没有机会收发或者收包比较慢而丢包；&lt;/p>
&lt;p>解决方案：&lt;/p>
&lt;p>1.调整网卡RSS队列配置：&lt;/p>
&lt;p>查看：ethtool -x ethx；&lt;/p>
&lt;p>调整：ethtool -X ethx xxxx；&lt;/p>
&lt;p>2.看一下网卡中断配置是否均衡 cat /proc/interrupts&lt;/p>
&lt;p>调整：&lt;/p>
&lt;p>1） irqbalance 调整；&lt;br>
# 查看当前运行情况&lt;br>
service irqbalance status&lt;br>
# 终止服务&lt;br>
service irqbalance stop&lt;br>
2） 中断绑CPU核 echo mask &amp;gt; /proc/irq/xxx/smp_affinity&lt;/p>
&lt;p>3.根据CPU和网卡队列个数调整网卡多队列和RPS配置&lt;/p>
&lt;p>-CPU大于网卡队列个数：&lt;/p>
&lt;p>查看网卡队列 ethtool -x ethx；&lt;/p>
&lt;p>协议栈开启RPS并设置RPS；&lt;/p>
&lt;p>echo $mask（CPU配置）&amp;gt; /sys/class/net/$eth/queues/rx-$i/rps_cpus&lt;br>
echo 4096（网卡buff）&amp;gt; /sys/class/net/$eth/queues/rx-$i/rps_flow_cnt&lt;br>
2）CPU小于网卡队列个数，绑中断就可以，可以试着关闭RPS看一下效果：&lt;br>
echo 0 &amp;gt; /sys/class/net/&lt;dev>/queues/rx-&lt;n>/rps_cpus&lt;/p>
&lt;p>4.numa CPU调整，对齐网卡位置，可以提高内核处理速度，从而给更多CPU给应用收包，减缓丢包概率；&lt;/p>
&lt;p>查看网卡numa位置：&lt;/p>
&lt;p>ethtool -i eth1|grep bus-info&lt;br>
lspci -s bus-info -vv|grep node&lt;/p>
&lt;p>上面中断和RPS设置里面mask需要重新按numa CPU分配重新设置;&lt;/p>
&lt;p>5.可以试着开启中断聚合（看网卡是否支持）&lt;/p>
&lt;p>查看 :&lt;/p>
&lt;p>ethtool -c ethx&lt;br>
Coalesce parameters for eth1:&lt;br>
Adaptive RX: on TX: on&lt;br>
stats-block-usecs: 0&lt;br>
sample-interval: 0&lt;br>
pkt-rate-low: 0&lt;br>
pkt-rate-high: 0&lt;/p>
&lt;p>rx-usecs: 25&lt;br>
rx-frames: 0&lt;br>
rx-usecs-irq: 0&lt;br>
rx-frames-irq: 256&lt;/p>
&lt;p>tx-usecs: 25&lt;br>
tx-frames: 0&lt;br>
tx-usecs-irq: 0&lt;br>
tx-frames-irq: 256&lt;/p>
&lt;p>rx-usecs-low: 0&lt;br>
rx-frame-low: 0&lt;br>
tx-usecs-low: 0&lt;br>
tx-frame-low: 0&lt;/p>
&lt;p>rx-usecs-high: 0&lt;br>
rx-frame-high: 0&lt;br>
tx-usecs-high: 0&lt;br>
tx-frame-high: 0&lt;/p>
&lt;p>调整：&lt;/p>
&lt;p>ethtool -C ethx adaptive-rx on&lt;/p>
&lt;p>简单总结一下网卡驱动丢包处理：&lt;/p>
&lt;p>&lt;img src="https://mmbiz.qpic.cn/sz_mmbiz_png/8pECVbqIO0wf4MEvQSRT3JhRrXHLiaELpnkO9nUG4g2kCKB4VfNPzpDoRBygJ1yVUib1kg245iaux0uTWxuJY0iatA/640?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1" alt="">&lt;/p>
&lt;p>内核协议栈丢包&lt;/p>
&lt;hr>
&lt;p>以太网链路层丢包&lt;/p>
&lt;hr>
&lt;p>neighbor系统arp丢包&lt;/p>
&lt;p>arp_ignore配置丢包&lt;/p>
&lt;p>arp_ignore参数的作用是控制系统在收到外部的arp请求时，是否要返回arp响应。arp_ignore参数常用的取值主要有0，1，2，3~8较少用到；&lt;/p>
&lt;p>查看：sysctl -a|grep arp_ignore&lt;/p>
&lt;p>&lt;img src="https://mmbiz.qpic.cn/sz_mmbiz_jpg/8pECVbqIO0wf4MEvQSRT3JhRrXHLiaELp1Fyj3g08oG8S4yEJtsSFQhTFiaDjFibrFS5YVrugiaqM7QW0frvw3zyicw/640?wx_fmt=jpeg&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1" alt="">&lt;/p>
&lt;p>解决方案：根据实际场景设置对应值；&lt;/p>
&lt;p>0：响应任意网卡上接收到的对本机IP地址的arp请求（包括环回网卡上的地址），而不管该目的IP是否在接收网卡上。&lt;/p>
&lt;p>1：只响应目的IP地址为接收网卡上的本地地址的arp请求。&lt;/p>
&lt;p>2：只响应目的IP地址为接收网卡上的本地地址的arp请求，并且arp请求的源IP必须和接收网卡同网段。&lt;/p>
&lt;p>3：如果ARP请求数据包所请求的IP地址对应的本地地址其作用域（scope）为主机（host），则不回应ARP响应数据包，如果作用域为全局（global）或链路（link），则回应ARP响应数据包。&lt;/p>
&lt;p>&lt;img src="https://mmbiz.qpic.cn/sz_mmbiz_jpg/8pECVbqIO0wf4MEvQSRT3JhRrXHLiaELphxSlOHae76d8yuiac1trzo51H662AdYtYVcSmibibAR5opzT3CTHC5Mtg/640?wx_fmt=jpeg&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1" alt="">&lt;/p>
&lt;p>&lt;img src="https://mmbiz.qpic.cn/sz_mmbiz_jpg/8pECVbqIO0wf4MEvQSRT3JhRrXHLiaELpMZl9lWQxagUSCia2XiarXsfZGlJqbmqjtMnQY2Y4DJ9iaDYpb0qeCXFwg/640?wx_fmt=jpeg&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1" alt="">&lt;/p>
&lt;p>arp_filter配置丢包&lt;/p>
&lt;p>在多接口系统里面（比如腾讯云的弹性网卡场景），这些接口都可以回应arp请求，导致对端有可能学到不同的mac地址，后续报文发送可能由于mac地址和接收报文接口mac地址不一样而导致丢包，arp_filter主要是用来适配这种场景；&lt;/p>
&lt;p>查看：&lt;/p>
&lt;p>sysctl -a | grep arp_filter&lt;/p>
&lt;p>&lt;img src="https://mmbiz.qpic.cn/sz_mmbiz_png/8pECVbqIO0wf4MEvQSRT3JhRrXHLiaELpazDq9OJaviaMLPdr86IQcwXnRIichKyVQUzlVia5u9mmXAZR4QtEOMSeA/640?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1" alt="">&lt;/p>
&lt;p>解决方案：&lt;/p>
&lt;p>根据实际场景设置对应的值，一般默认是关掉此过滤规则，特殊情况可以打开；&lt;br>
0：默认值，表示回应arp请求的时候不检查接口情况；&lt;br>
1：表示回应arp请求时会检查接口是否和接收请求接口一致，不一致就不回应；&lt;/p>
&lt;p>arp表满导致丢包&lt;/p>
&lt;p>比如下面这种情况，由于突发arp表项很多 超过协议栈默认配置，发送报文的时候部分arp创建失败，导致发送失败，从而丢包：&lt;/p>
&lt;p>&lt;img src="https://mmbiz.qpic.cn/sz_mmbiz_png/8pECVbqIO0wf4MEvQSRT3JhRrXHLiaELpRIklWGpB2UqzPM8wW53nInfMJG2y7vF1ia5p3zFnDmjN1OnLkjTRClQ/640?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1" alt="">&lt;/p>
&lt;p>查看：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>查看arp状态：cat /proc/net/stat/arp_cache ，table_fulls统计：&lt;/p>
&lt;/li>
&lt;li>
&lt;p>查看dmesg消息（内核打印）：&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://mmbiz.qpic.cn/sz_mmbiz_png/8pECVbqIO0wf4MEvQSRT3JhRrXHLiaELpEibxTls4twtb9WyQ5kAfNt2rKcgH17QIaeDfDypjBlQmsTZxg29QpSg/640?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1" alt="">&lt;/p>
&lt;p>dmesg|grep neighbour&lt;br>
neighbour: arp_cache: neighbor table overflow!&lt;/p>
&lt;ul>
&lt;li>查看当前arp表大小：ip n|wc -l&lt;/li>
&lt;/ul>
&lt;p>查看系统配额：&lt;/p>
&lt;p>sysctl -a |grep net.ipv4.neigh.default.gc_thresh&lt;br>
gc_thresh1：存在于ARP高速缓存中的最少层数，如果少于这个数，垃圾收集器将不会运行。缺省值是128。&lt;/p>
&lt;p>gc_thresh2 ：保存在 ARP 高速缓存中的最多的记录软限制。垃圾收集器在开始收集前，允许记录数超过这个数字 5 秒。缺省值是 512。&lt;br>
gc_thresh3 ：保存在 ARP 高速缓存中的最多记录的硬限制，一旦高速缓存中的数目高于此，垃圾收集器将马上运行。缺省值是1024。&lt;/p>
&lt;p>一般在内存足够情况下，可以认为gc_thresh3 值是arp 表总大小；&lt;/p>
&lt;p>&lt;img src="https://mmbiz.qpic.cn/sz_mmbiz_png/8pECVbqIO0wf4MEvQSRT3JhRrXHLiaELpC1icjGwAGxhoH02AgNPSmJgyDrlvibic3dLAZpEOCKAfs7NqR6Y1AuZBA/640?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1" alt="">&lt;/p>
&lt;p>解决方案：根据实际arp最大值情况（比如访问其他子机最大个数），调整arp表大小&lt;/p>
&lt;p>$ sudo sysctl -w net.ipv4.neigh.default.gc_thresh1=1024&lt;br>
$ sudo sysctl -w net.ipv4.neigh.default.gc_thresh2=2048&lt;br>
$ sudo sysctl -w net.ipv4.neigh.default.gc_thresh3=4096&lt;br>
$ sudo sysctl -p&lt;/p>
&lt;p>arp请求缓存队列溢出丢包&lt;/p>
&lt;p>查看：&lt;/p>
&lt;p>cat /proc/net/stat/arp_cache ，unresolved_discards是否有新增计数&lt;/p>
&lt;p>解决方案：根据客户需求调整缓存队列大小unres_qlen_bytes：&lt;/p>
&lt;p>&lt;img src="https://mmbiz.qpic.cn/sz_mmbiz_jpg/8pECVbqIO0wf4MEvQSRT3JhRrXHLiaELpj0lzAicryehohib677icGwcOCEEFwKcibFY0KUh4lpWgKegBicn0UpgorVw/640?wx_fmt=jpeg&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1" alt="">&lt;/p>
&lt;p>网络IP层丢包&lt;/p>
&lt;hr>
&lt;p>接口ip地址配置丢包&lt;/p>
&lt;hr>
&lt;p>1. 本机服务不通，检查lo接口有没有配置地址是127.0.0.1；&lt;/p>
&lt;p>2 .本机接收失败， 查看local路由表：ip r show table local|grep 子机ip地址；这种丢包一般会出现在多IP场景，子机底层配置多ip失败，导致对应ip收不到包而丢包；&lt;/p>
&lt;p>&lt;img src="https://mmbiz.qpic.cn/sz_mmbiz_png/8pECVbqIO0wf4MEvQSRT3JhRrXHLiaELp95FI28uQxI3rTGg3siak3B5TES8Eic8kNn7X84fy64ZkyPKAkjkLss6Q/640?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1" alt="">&lt;/p>
&lt;p>解决方案：&lt;/p>
&lt;p>1.配置正确接口ip地址；比如ip a add 1.1.1.1 dev eth0&lt;/p>
&lt;p>2.如果发现接口有地址还丢包，可能是local路由表没有对应条目，紧急情况下，可以用手工补上：&lt;/p>
&lt;p>比如ip r add local 本机ip地址 dev eth0 table local ；&lt;/p>
&lt;p>路由丢包&lt;/p>
&lt;hr>
&lt;p>路由配置丢包&lt;/p>
&lt;p>查看：&lt;/p>
&lt;p>1.查看配置 路由是否设置正确（是否可达），是否配置策略路由（在弹性网卡场景会出现此配置）ip rule：&lt;/p>
&lt;p>&lt;img src="https://mmbiz.qpic.cn/sz_mmbiz_jpg/8pECVbqIO0wf4MEvQSRT3JhRrXHLiaELpe8SGlTCUCBzOnHicrefdGbA74LgYuvCAQ9KCm3PoeBOsic12ey5v3iclg/640?wx_fmt=jpeg&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1" alt="">&lt;/p>
&lt;p>然后找到对应路由表。查看路由表：&lt;/p>
&lt;p>&lt;img src="https://mmbiz.qpic.cn/sz_mmbiz_png/8pECVbqIO0wf4MEvQSRT3JhRrXHLiaELpcsmP3r9LZibovd5xxWeTHibwpsNmnS1BeeiaYfv5tQ5Yq91TbbyoZXMOA/640?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1" alt="">&lt;/p>
&lt;p>或者直接用 ip r get x.x.x.x，让系统帮你查找是否存在可达路由，接口是否符合预期；&lt;/p>
&lt;p>2.查看系统统计信息：&lt;/p>
&lt;p>netstat -s|grep &amp;ldquo;dropped because of missing route&amp;rdquo;&lt;/p>
&lt;p>解决方案：重新配置正确的路由；&lt;/p>
&lt;p>反向路由过滤丢包&lt;/p>
&lt;p>反向路由过滤机制是Linux通过反向路由查询，检查收到的数据包源IP是否可路由（Loose mode）、是否最佳路由（Strict mode），如果没有通过验证，则丢弃数据包，设计的目的是防范IP地址欺骗攻击。&lt;/p>
&lt;p>查看：&lt;/p>
&lt;p>rp_filter提供三种模式供配置：&lt;/p>
&lt;p>0 - 不验证&lt;/p>
&lt;p>1 - RFC3704定义的严格模式：对每个收到的数据包，查询反向路由，如果数据包入口和反向路由出口不一致，则不通过&lt;/p>
&lt;p>2 - RFC3704定义的松散模式：对每个收到的数据包，查询反向路由，如果任何接口都不可达，则不通过&lt;/p>
&lt;p>查看当前rp_filter策略配置：&lt;/p>
&lt;p>$cat /proc/sys/net/ipv4/conf/eth0/rp_filter&lt;/p>
&lt;p>如果这里设置为1，就需要查看主机的网络环境和路由策略是否可能会导致客户端的入包无法通过反向路由验证了。&lt;/p>
&lt;p>从原理来看这个机制工作在网络层，因此，如果客户端能够Ping通服务器，就能够排除这个因素了。&lt;/p>
&lt;p>解决方案：&lt;/p>
&lt;p>根据实际网络环境将rp_filter设置为0或2：&lt;/p>
&lt;p>$ sysctl -w net.ipv4.conf.all.rp_filter=2或&lt;br>
$ sysctl -w net.ipv4.conf.eth0.rp_filter=2&lt;/p>
&lt;p>防火墙丢包&lt;/p>
&lt;hr>
&lt;p>客户设置规则导致丢包&lt;/p>
&lt;p>查看：&lt;/p>
&lt;p>iptables -nvL |grep DROP ;&lt;/p>
&lt;p>解决方案： 修改防火墙规则；&lt;/p>
&lt;p>连接跟踪导致丢包&lt;/p>
&lt;p>连接跟踪表溢出丢包&lt;/p>
&lt;p>kernel 用 ip_conntrack 模块来记录 iptables 网络包的状态，并把每条记录保存到 table 里（这个 table 在内存里，可以通过/proc/net/ip_conntrack 查看当前已经记录的总数），如果网络状况繁忙，比如高连接，高并发连接等会导致逐步占用这个 table 可用空间，一般这个 table 很大不容易占满并且可以自己清理，table 的记录会一直呆在 table 里占用空间直到源 IP 发一个 RST 包，但是如果出现被攻击、错误的网络配置、有问题的路由/路由器、有问题的网卡等情况的时候，就会导致源 IP 发的这个 RST 包收不到，这样就积累在 table 里，越积累越多直到占满。无论，哪种情况导致table变满，满了以后就会丢包，出现外部无法连接服务器的情况。内核会报如下错误信息：kernel: ip_conntrack: table full, dropping packet；&lt;/p>
&lt;p>查看当前连接跟踪数 :&lt;/p>
&lt;p>cat /proc/sys/net/netfilter/nf_conntrack_max&lt;/p>
&lt;p>解决方案：&lt;/p>
&lt;p>增大跟踪的最大条数&lt;br>
net.netfilter.nf_conntrack_max = 3276800&lt;br>
减少跟踪连接的最大有效时间&lt;br>
net.netfilter.nf_conntrack_tcp_timeout_established = 1200&lt;br>
net.netfilter.nf_conntrack_udp_timeout_stream = 180&lt;br>
net.netfilter.nf_conntrack_icmp_timeout = 30&lt;/p>
&lt;p>ct创建冲突失导致丢包&lt;/p>
&lt;hr>
&lt;p>查看：当前连接跟踪统计：cat  /proc/net/stat/nf_conntrack，可以查各种ct异常丢包统计&lt;/p>
&lt;p>&lt;img src="https://mmbiz.qpic.cn/sz_mmbiz_png/8pECVbqIO0wf4MEvQSRT3JhRrXHLiaELpyPRGF7iaS3oeA9uRBmZ63Lwra6tGqEm4z83ibjgZJCVtNdNM9qfKTexQ/640?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1" alt="">&lt;/p>
&lt;p>解决方案：内核热补丁修复或者更新内核版本（合入补丁修改）；&lt;/p>
&lt;p>传输层UDP/TCP丢包&lt;/p>
&lt;hr>
&lt;p>tcp 连接跟踪安全检查丢包&lt;/p>
&lt;p>丢包原因：由于连接没有断开，但服务端或者client之前出现过发包异常等情况（报文没有经过连接跟踪模块更新窗口计数），没有更新合法的window范围，导致后续报文安全检查被丢包；协议栈用 nf_conntrack_tcp_be_liberal 来控制这个选项：&lt;/p>
&lt;p>1：关闭，只有不在tcp窗口内的rst包被标志为无效；&lt;/p>
&lt;p>0：开启; 所有不在tcp窗口中的包都被标志为无效；&lt;/p>
&lt;p>查看：&lt;/p>
&lt;p>查看配置 ：&lt;/p>
&lt;p>sysctl -a|grep nf_conntrack_tcp_be_liberal&lt;br>
net.netfilter.nf_conntrack_tcp_be_liberal = 1&lt;/p>
&lt;p>查看log：&lt;/p>
&lt;p>一般情况下netfiler模块默认没有加载log，需要手动加载;&lt;/p>
&lt;p>modprobe ipt_LOG11&lt;br>
sysctl -w net.netfilter.nf_log.2=ipt_LOG&lt;/p>
&lt;p>然后发包后在查看syslog；&lt;/p>
&lt;p>解决方案：根据实际抓包分析情况判断是不是此机制导致的丢包，可以试着关闭试一下；&lt;/p>
&lt;p>分片重组丢包&lt;/p>
&lt;hr>
&lt;p>情况总结：超时&lt;/p>
&lt;p>查看：&lt;/p>
&lt;p>netstat -s|grep timeout&lt;br>
601 fragments dropped after timeout&lt;/p>
&lt;p>解决方法：调整超时时间&lt;/p>
&lt;p>net.ipv4.ipfrag_time = 30&lt;br>
sysctl -w net.ipv4.ipfrag_time=60&lt;/p>
&lt;p>frag_high_thresh, 分片的内存超过一定阈值会导致系统安全检查丢包&lt;/p>
&lt;p>查看：&lt;/p>
&lt;p>netstat -s|grep reassembles&lt;br>
8094 packet reassembles failed&lt;/p>
&lt;p>解决方案：调整大小&lt;/p>
&lt;p>net.ipv4.ipfrag_high_thresh&lt;br>
net.ipv4.ipfrag_low_thresh&lt;/p>
&lt;p>分片安全距检查离丢包&lt;/p>
&lt;p>查看：&lt;/p>
&lt;p>netstat -s|grep reassembles&lt;br>
8094 packet reassembles failed&lt;/p>
&lt;p>解决方案： 把ipfrag_max_dist设置为0，就关掉此安全检查&lt;/p>
&lt;p>&lt;img src="https://mmbiz.qpic.cn/sz_mmbiz_png/8pECVbqIO0wf4MEvQSRT3JhRrXHLiaELp7SzcxFlaHb7b1tt84QbicibF39bXgAofFcAEqo0j21y7t3ItzB6v3Cicg/640?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1" alt="">&lt;/p>
&lt;p>pfrag_max_dist特性，在一些场景下其实并不适用：&lt;/p>
&lt;p>1.有大量的网络报文交互&lt;/p>
&lt;p>2.发送端的并发度很高，同时SMP架构，导致很容易造成这种乱序情况；&lt;/p>
&lt;p>分片hash bucket冲突链太长超过系统默认值128&lt;/p>
&lt;p>查看：&lt;/p>
&lt;p>dmesg|grep “Dropping fragment”&lt;br>
inet_frag_find: Fragment hash bucket 128 list length grew over limit. Dropping fragment.&lt;/p>
&lt;p>解决方案：热补丁调整hash大小；&lt;/p>
&lt;p>系统内存不足，创建新分片队列失败&lt;/p>
&lt;p>查看方法：&lt;/p>
&lt;p>netstat -s|grep reassembles&lt;br>
8094 packet reassembles failed&lt;/p>
&lt;p>dropwatch查看丢包位置 ：&lt;/p>
&lt;p>&lt;img src="https://mmbiz.qpic.cn/sz_mmbiz_jpg/8pECVbqIO0wf4MEvQSRT3JhRrXHLiaELp83LWyjXXv7hA3NnalsUQrP4qicl3PYiaR6JL3132MAg6fcJYbYj3kdwA/640?wx_fmt=jpeg&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1" alt="">&lt;/p>
&lt;p>解决方案：&lt;/p>
&lt;p>a.增大系统网络内存：&lt;/p>
&lt;p>net.core.rmem_default&lt;br>
net.core.rmem_max&lt;br>
net.core.wmem_default&lt;/p>
&lt;p>b.系统回收内存：&lt;/p>
&lt;p>紧急情况下，可以用 /proc/sys/vm/drop_caches, 去释放一下虚拟内存；&lt;/p>
&lt;p>To free pagecache:&lt;br>
# echo 1 &amp;gt; /proc/sys/vm/drop_caches&lt;br>
To free dentries and inodes:&lt;br>
# echo 2 &amp;gt; /proc/sys/vm/drop_caches&lt;br>
To free pagecache, dentries and inodes:&lt;br>
echo 3 &amp;gt; /proc/sys/vm/drop_caches&lt;/p>
&lt;p>MTU丢包&lt;/p>
&lt;hr>
&lt;p>&lt;img src="https://mmbiz.qpic.cn/sz_mmbiz_jpg/8pECVbqIO0wf4MEvQSRT3JhRrXHLiaELpFbjiaVEm6alds0a7lMBticz5iacRpia9k67BCHMgPomh0UTU6ib8IX3mSIQ/640?wx_fmt=jpeg&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1" alt="">&lt;/p>
&lt;p>查看：&lt;/p>
&lt;p>1.检查接口MTU配置，ifconfig eth1/eth0，默认是1500；&lt;/p>
&lt;p>2.进行MTU探测，然后设置接口对应的MTU值；&lt;/p>
&lt;p>解决方案：&lt;/p>
&lt;p>1. 根据实际情况，设置正确MTU值；&lt;/p>
&lt;p>2. 设置合理的tcp mss，启用TCP MTU Probe:&lt;/p>
&lt;p>cat /proc/sys/net/ipv4/tcp_mtu_probing:&lt;br>
tcp_mtu_probing - INTEGER Controls TCP Packetization-Layer Path MTU Discovery.&lt;br>
Takes three values:&lt;br>
0 - Disabled&lt;br>
1 - Disabled by default, enabled when an ICMP black hole detected&lt;br>
2 - Always enabled, use initial MSS of tcp_base_mss.&lt;/p>
&lt;p>tcp层丢包&lt;/p>
&lt;hr>
&lt;p>TIME_WAIT过多丢包&lt;/p>
&lt;p>大量TIMEWAIT出现，并且需要解决的场景，在高并发短连接的TCP服务器上，当服务器处理完请求后立刻按照主动正常关闭连接。。。这个场景下，会出现大量socket处于TIMEWAIT状态。如果客户端的并发量持续很高，此时部分客户端就会显示连接不上；&lt;/p>
&lt;p>查看：&lt;/p>
&lt;p>查看系统log ：&lt;/p>
&lt;p>dmsg&lt;br>
TCP: time wait bucket table overflow；&lt;/p>
&lt;p>查看系统配置：&lt;/p>
&lt;p>sysctl -a|grep tcp_max_tw_buckets&lt;br>
net.ipv4.tcp_max_tw_buckets = 16384&lt;/p>
&lt;p>解决方案：&lt;/p>
&lt;p>1. tw_reuse，tw_recycle 必须在客户端和服务端timestamps 开启时才管用（默认打开）&lt;/p>
&lt;p>2. tw_reuse 只对客户端起作用，开启后客户端在1s内回收；&lt;/p>
&lt;p>3. tw_recycle对客户端和服务器同时起作用，开启后在3.5*RTO 内回收，RTO 200ms~ 120s具体时间视网络状况。内网状况比tw_reuse稍快，公网尤其移动网络大多要比tw_reuse 慢，优点就是能够回收服务端的TIME_WAIT数量；&lt;/p>
&lt;p>在服务端，如果网络路径会经过NAT节点，不要启用net.ipv4.tcp_tw_recycle，会导致时间戳混乱，引起其他丢包问题；&lt;/p>
&lt;p>4. 调整tcp_max_tw_buckets大小，如果内存足够：&lt;/p>
&lt;p>sysctl -w net.ipv4.tcp_max_tw_buckets=163840；&lt;/p>
&lt;p>时间戳异常丢包&lt;/p>
&lt;p>当多个客户端处于同一个NAT环境时，同时访问服务器，不同客户端的时间可能不一致，此时服务端接收到同一个NAT发送的请求，就会出现时间戳错乱的现象，于是后面的数据包就被丢弃了，具体的表现通常是是客户端明明发送的SYN，但服务端就是不响应ACK。在服务器借助下面的命令可以来确认数据包是否有不断被丢弃的现象。&lt;/p>
&lt;p>检查：&lt;/p>
&lt;p>netstat -s | grep rejects&lt;/p>
&lt;p>解决方案：&lt;/p>
&lt;p>如果网络路径会经过NAT节点，不要启用net.ipv4.tcp_tw_recycle；&lt;/p>
&lt;p>TCP队列问题导致丢包&lt;/p>
&lt;p>原理：&lt;/p>
&lt;p>tcp状态机（三次握手）&lt;/p>
&lt;p>&lt;img src="https://mmbiz.qpic.cn/sz_mmbiz_png/8pECVbqIO0wf4MEvQSRT3JhRrXHLiaELpibIMQq71IoFNibA1xsRelgvwFFjQxnfJDkMsmf7wRUia8heRBE9DDe04A/640?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1" alt="">&lt;/p>
&lt;p>协议处理：&lt;/p>
&lt;p>&lt;img src="https://mmbiz.qpic.cn/sz_mmbiz_jpg/8pECVbqIO0wf4MEvQSRT3JhRrXHLiaELpjIkz0h2QgpCNPWxCq8b9HlVfzlTmoEqiaoFyXJ3zmVD0Io0CjCmPuiaQ/640?wx_fmt=jpeg&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1" alt="">&lt;/p>
&lt;p>一个是半连接队列（syn queue）：&lt;/p>
&lt;p>在三次握手协议中，服务器维护一个半连接队列，该队列为每个客户端的SYN包开设一个条目(服务端在接收到SYN包的时候，就已经创建了request_sock结构，存储在半连接队列中)，该条目表明服务器已收到SYN包，并向客户发出确认，正在等待客户的确认包（会进行第二次握手发送SYN＋ACK的包加以确认）。这些条目所标识的连接在服务器处于Syn_RECV状态，当服务器收到客户的确认包时，删除该条目，服务器进入ESTABLISHED状态。该队列为SYN队列，长度为max(64, /proc/sys/net/ipv4/tcp_max_syn_backlog), 机器的tcp_max_syn_backlog值在/proc/sys/net/ipv4/tcp_max_syn_backlog下配置;&lt;/p>
&lt;p>一个是全连接队列（accept queue）：&lt;/p>
&lt;p>第三次握手时，当server接收到ACK 报之后， 会进入一个新的叫 accept 的队列，该队列的长度为 min(backlog, somaxconn)，默认情况下，somaxconn 的值为 128，表示最多有 129 的 ESTAB 的连接等待 accept()，而 backlog 的值则应该是由 int listen(int sockfd, int backlog) 中的第二个参数指定，listen 里面的 backlog 可以有我们的应用程序去定义的;&lt;/p>
&lt;p>查看：&lt;/p>
&lt;p>连接建立失败,syn丢包：&lt;/p>
&lt;p>netstat -s |grep -i listen&lt;br>
SYNs to LISTEN sockets dropped&lt;/p>
&lt;p>也会受到连接满丢包影响&lt;/p>
&lt;p>解决方案： 增加大小 tcp_max_syn_backlog&lt;/p>
&lt;p>连接满丢包&lt;/p>
&lt;p>-xxx times the listen queue of a socket overflowed&lt;/p>
&lt;p>查看：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>查看accept队列大小 ：net.core.somaxconn&lt;/p>
&lt;/li>
&lt;li>
&lt;p>ss -lnt查询socket队列 ：LISTEN 状态: Recv-Q 表示的当前等待服务端调用 accept 完成三次握手的 listen backlog 数值，也就是说，当客户端通过 connect() 去连接正在 listen() 的服务端时，这些连接会一直处于这个 queue 里面直到被服务端 accept()；Send-Q 表示的则是最大的 listen backlog 数值，这就就是上面提到的 min(backlog, somaxconn) 的值，&lt;/p>
&lt;/li>
&lt;li>
&lt;p>看一下是不是应用程序设置限制， int listen(int sockfd, int backlog)；&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>解决方案：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>Linux内核参进行优化，可以缓解压力 tcp_abort_on_overflow=1&lt;/p>
&lt;/li>
&lt;li>
&lt;p>调整net.core.somaxconn大小;&lt;/p>
&lt;/li>
&lt;li>
&lt;p>应用程序设置问题，通知客户程序修改；&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>syn flood攻击丢包&lt;/p>
&lt;p>目前，Linux下默认会进行5次重发SYN-ACK包，重试的间隔时间从1s开始，下次的重试间隔时间是前一次的双倍，5次的重试时间间隔为1s, 2s, 4s, 8s, 16s，总共31s，第5次发出后还要等32s都知道第5次也超时了，所以，总共需要 1s + 2s + 4s+ 8s+ 16s + 32s = 63s，TCP才会把断开这个连接。由于，SYN超时需要63秒，那么就给攻击者一个攻击服务器的机会，攻击者在短时间内发送大量的SYN包给Server(俗称 SYN flood 攻击)，用于耗尽Server的SYN队列。对于应对SYN 过多的问题;&lt;/p>
&lt;p>查看： 查看syslog： kernel: [3649830.269068] TCP: Possible SYN flooding on port xxx. Sending cookies. Check SNMP counters.&lt;/p>
&lt;p>解决方案：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>增大tcp_max_syn_backlog&lt;/p>
&lt;/li>
&lt;li>
&lt;p>减少tcp_synack_retries&lt;/p>
&lt;/li>
&lt;li>
&lt;p>启用tcp_syncookies&lt;/p>
&lt;/li>
&lt;li>
&lt;p>启用tcp_abort_on_overflow， tcp_abort_on_overflow修改成 1，1表示第三步的时候如果全连接队列满了，server发送一个reset包给client，表示废掉这个握手过程和这个连接（本来在server端这个连接就还没建立起来）；&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>PAWS机制丢包&lt;/p>
&lt;p>原理：PAWS(Protect Against Wrapped Sequence numbers)，高带宽下，TCP序列号可能在较短的时间内就被重复使用(recycle/wrapped) 就可能导致同一条TCP流在短时间内出现序号一样的两个合法的数据包及其确认包。&lt;/p>
&lt;p>查看：&lt;/p>
&lt;p>$netstat -s |grep -e &amp;ldquo;passive connections rejected because of time&lt;br>
stamp&amp;rdquo; -e &amp;ldquo;packets rejects in established connections because of&lt;br>
timestamp”&lt;br>
387158 passive connections rejected because of time stamp&lt;br>
825313 packets rejects in established connections because of timestamp&lt;/p>
&lt;p>通过sysctl查看是否启用了tcp_tw_recycle及tcp_timestamp:&lt;/p>
&lt;p>$ sysctl net.ipv4.tcp_tw_recycle&lt;br>
net.ipv4.tcp_tw_recycle = 1&lt;br>
$ sysctl net.ipv4.tcp_timestamps&lt;br>
net.ipv4.tcp_timestamps = 1&lt;/p>
&lt;p>1. tcp_tw_recycle参数。它用来快速回收TIME_WAIT连接，不过如果在NAT环境下会引发问题;&lt;/p>
&lt;p>2. 当多个客户端通过NAT方式联网并与服务端交互时，服务端看到的是同一个IP，也就是说对服务端而言这些客户端实际上等同于一个，可惜由于这些客户端的时间戳可能存在差异，于是乎从服务端的视角看，便可能出现时间戳错乱的现象，进而直接导致时间戳小的数据包被丢弃。如果发生了此类问题，具体的表现通常是是客户端明明发送的SYN，但服务端就是不响应ACK。&lt;/p>
&lt;p>解决方案：&lt;/p>
&lt;p>在NAT环境下，清除tcp时间戳选项，或者不开启tcp_tw_recycle参数；&lt;/p>
&lt;p>TLP问题丢包&lt;/p>
&lt;p>TLP主要是为了解决尾丢包重传效率的问题，TLP能够有效的避免较长的RTO超时，进而提高TCP性能，详细参考文章：&lt;/p>
&lt;p>&lt;a href="http://perthcharles.github.io/2015/10/31/wiki-network-tcp-tlp/">http://perthcharles.github.io/2015/10/31/wiki-network-tcp-tlp/&lt;/a>；&lt;/p>
&lt;p>但在低时延场景下（短连接小包量），TLP与延迟ACK组合可能会造成无效重传，导致客户端感发现大量假重传包，加大了响应延迟；&lt;/p>
&lt;p>查看：&lt;/p>
&lt;p>查看协议栈统计：&lt;/p>
&lt;p>netstat -s |grep TCPLossProbes&lt;/p>
&lt;p>查看系统配置：&lt;/p>
&lt;p>sysctl -a | grep tcp_early_retrans&lt;/p>
&lt;p>&lt;img src="https://mmbiz.qpic.cn/sz_mmbiz_png/8pECVbqIO0wf4MEvQSRT3JhRrXHLiaELptRicvMicZtzRoM3PhwiaeqzPvQKODQEzQtm55Gqp04A5fQ0Q6HsdAsplA/640?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1" alt="">&lt;/p>
&lt;p>解决方案：&lt;/p>
&lt;p>1.关掉延迟ack，打开快速ack；&lt;/p>
&lt;p>2.linux实现nodelay语意不是快速ack，只是关闭nagle算法；&lt;/p>
&lt;p>3.打开快速ack选项，socket里面有个 TCP_QUICKACK 选项， 需要每次recv后再设置一次。&lt;/p>
&lt;p>内存不足导致丢包&lt;/p>
&lt;p>查看：&lt;/p>
&lt;p>查看log：&lt;/p>
&lt;p>dmesg|grep “out of memory”&lt;/p>
&lt;p>查看系统配置：&lt;/p>
&lt;p>cat /proc/sys/net/ipv4/tcp_mem&lt;br>
cat /proc/sys/net/ipv4/tcp_rmem&lt;br>
cat /proc/sys/net/ipv4/tcp_wmem&lt;/p>
&lt;p>解决方案：&lt;/p>
&lt;p>根据TCP业务并发流量，调整系统参数，一般试着增大2倍或者其他倍数来看是否缓解；&lt;/p>
&lt;p>sysclt -w net.ipv4.tcp_mem=&lt;br>
sysclt -w net.ipv4.tcp_wmem=&lt;br>
sysclt -w net.ipv4.tcp_rmem=&lt;br>
sysctl -p&lt;/p>
&lt;p>TCP超时丢包&lt;/p>
&lt;p>查看：&lt;/p>
&lt;p>抓包分析一下网络RTT：&lt;/p>
&lt;p>&lt;img src="https://mmbiz.qpic.cn/sz_mmbiz_png/8pECVbqIO0wf4MEvQSRT3JhRrXHLiaELpezYtbPYsd4m5R8Yeka5wLgMF5qmfSL7hSZ6Oeiarv0YoLpqXliaom0XA/640?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1" alt="">&lt;/p>
&lt;p>用其他工具测试一下当前端到端网络质量（hping等）；&lt;/p>
&lt;p># hping -S 9.199.10.104 -A&lt;br>
HPING 9.199.10.104 (bond1 9.199.10.104): SA set, 40 headers + 0 data bytes&lt;br>
len=46 ip=9.199.10.104 ttl=53 DF id=47617 sport=0 flags=R seq=0 win=0 rtt=38.3 ms&lt;br>
len=46 ip=9.199.10.104 ttl=53 DF id=47658 sport=0 flags=R seq=1 win=0 rtt=38.3 ms&lt;br>
len=46 ip=9.199.10.104 ttl=53 DF id=47739 sport=0 flags=R seq=2 win=0 rtt=30.4 ms&lt;br>
len=46 ip=9.199.10.104 ttl=53 DF id=47842 sport=0 flags=R seq=3 win=0 rtt=30.4 ms&lt;br>
len=46 ip=9.199.10.104 ttl=53 DF id=48485 sport=0 flags=R seq=4 win=0 rtt=38.7 ms&lt;br>
len=46 ip=9.199.10.104 ttl=53 DF id=49274 sport=0 flags=R seq=5 win=0 rtt=34.1 ms&lt;br>
len=46 ip=9.199.10.104 ttl=53 DF id=49491 sport=0 flags=R seq=6 win=0 rtt=30.3 ms&lt;/p>
&lt;p>解决方案：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>关闭Nagle算法，减少小包延迟；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>关闭延迟ack:&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>sysctl -w net.ipv4.tcp_no_delay_ack=1&lt;/p>
&lt;p>TCP乱序丢包&lt;/p>
&lt;p>此时TCP会无法判断是数据包丢失还是乱序，因为丢包和乱序都会导致接收端收到次序混乱的数据包，造成接收端的数据空洞。TCP会将这种情况暂定为数据包的乱序，因为乱序是时间问题（可能是数据包的迟到），而丢包则意味着重传。当TCP意识到包出现乱序的情况时，会立即ACK，该ACK的TSER部分包含的TSEV值会记录当前接收端收到有序报文段的时刻。这会使得数据包的RTT样本值增大，进一步导致RTO时间延长。这对TCP来说无疑是有益的，因为TCP有充分的时间判断数据包到底是失序还是丢了来防止不必要的数据重传。当然严重的乱序则会让发送端以为是丢包一旦重复的ACK超过TCP的阈值，便会触发超时重传机制，以及时解决这种问题；&lt;/p>
&lt;p>查看：抓包分析是否存在很多乱序报文：&lt;/p>
&lt;p>&lt;img src="https://mmbiz.qpic.cn/sz_mmbiz_png/8pECVbqIO0wf4MEvQSRT3JhRrXHLiaELp7h8SiaYgFkn1MKFvvOicRPwupic0QvrRTgVSbLLnpTPyonesSAGKROT8Q/640?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1" alt="">&lt;/p>
&lt;p>解决方案：如果在多径传输场景或者网络质量不好，可以通过修改下面值来提供系统对TCP无序传送的容错率：&lt;/p>
&lt;p>&lt;img src="https://mmbiz.qpic.cn/sz_mmbiz_png/8pECVbqIO0wf4MEvQSRT3JhRrXHLiaELpHIeiaeJ7PibBQyKXicVnQLBFelJ7ibHXDCvgNicsYDQShslAtkA8vtaN6Gw/640?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1" alt="">&lt;/p>
&lt;p>拥塞控制丢包&lt;/p>
&lt;hr>
&lt;p>在互联网发展的过程当中，TCP算法也做出了一定改变，先后演进了&lt;/p>
&lt;p>Reno、NewReno、Cubic和Vegas，这些改进算法大体可以分为基于丢包和基于延时的拥塞控制算法。基于丢包的拥塞控制算法以Reno、NewReno为代表，它的主要问题有Buffer bloat和长肥管道两种，基于丢包的协议拥塞控制机制是被动式的，其依据网络中的丢包事件来做网络拥塞判断。即使网络中的负载很高，只要没有产生拥塞丢包，协议就不会主动降低自己的发送速度。最初路由器转发出口的Buffer 是比较小的，TCP在利用时容易造成全局同步，降低带宽利用率，随后路由器厂家由于硬件成本下降不断地增加Buffer，基于丢包反馈的协议在不丢包的情况下持续占用路由器buffer，虽然提高了网络带宽的利用率，但同时也意味着发生拥塞丢包后，网络抖动性加大。另外对于带宽和RTT都很高的长肥管道问题来说，管道中随机丢包的可能性很大，TCP的默认buffer设置比较小加上随机丢包造成的cwnd经常下折，导致带宽利用率依旧很低； BBR（Bottleneck Bandwidth and Round-trip propagation time）是一种基于带宽和延迟反馈的拥塞控制算法。目前已经演化到第二版，是一个典型的封闭反馈系统，发送多少报文和用多快的速度发送这些报文都是在每次反馈中不断调节。在BBR提出之前，拥塞控制都是基于事件的算法，需要通过丢包或延时事件驱动；BBR提出之后，拥塞控制是基于反馈的自主自动控制算法，对于速率的控制是由算法决定，而不由网络事件决定，BBR算法的核心是找到最大带宽（Max BW）和最小延时（Min RTT）这两个参数，最大带宽和最小延时的乘积可以得到BDP(Bandwidth Delay Product), 而BDP就是网络链路中可以存放数据的最大容量。BDP驱动Probing State Machine得到Rate quantum和cwnd，分别设置到发送引擎中就可以解决发送速度和数据量的问题。&lt;/p>
&lt;p>Linux 4.9内核首次采用BBR拥塞控制算法第一个版本，BBR抗丢包能力比其他算法要强，但这个版本在某些场景下面有问题（缺点），BBR在实时音视频领域存在的问题，深队列竞争不过Cubic。&lt;/p>
&lt;p>问题现象就是：在深队列场景，BBR的ProbeRTT阶段只发4个包，发送速率下降太多会引发延迟加大和卡顿问题。&lt;/p>
&lt;p>查看：&lt;/p>
&lt;p>ss -sti //在源端 ss -sti|grep 10.125.42.49:47699 -A 3 （ 10.125.42.49:47699 是目的端地址和端口号）&lt;/p>
&lt;p>&lt;img src="https://mmbiz.qpic.cn/sz_mmbiz_png/8pECVbqIO0wf4MEvQSRT3JhRrXHLiaELp6WojlO3oYmf2NJwXwMGjrlYWPJNe9KiaowxueNia5TMSqoLoL1PSrdwg/640" alt="">&lt;/p>
&lt;p>&lt;img src="https://mmbiz.qpic.cn/sz_mmbiz_png/8pECVbqIO0wf4MEvQSRT3JhRrXHLiaELpPuwyibfwaTwJa4bzLZs5bVz38CdSp8JWGV39gpFffWSyCfBNiaQjEmzg/640" alt="">&lt;/p>
&lt;p>解决方案：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>ProbeRTT并不适用实时音视频领域，因此可以选择直接去除，或者像BBRV2把probe RTT缩短到2.5s一次，使用0.5xBDP发送；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>如果没有特殊需求，切换成稳定的cubic算法；&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>UDP层丢包&lt;/p>
&lt;hr>
&lt;p>收发包失败丢包&lt;/p>
&lt;p>查看：netstat 统计&lt;/p>
&lt;p>如果有持续的 receive buffer errors/send buffer errors 计数；&lt;/p>
&lt;p>&lt;img src="https://mmbiz.qpic.cn/sz_mmbiz_png/8pECVbqIO0wf4MEvQSRT3JhRrXHLiaELpjlbmDfTtEaR0MibP1SRKJhrSDMCVSveCh6Cyjh6ib8g8PicYNQTrM7Lsg/640?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1" alt="">&lt;/p>
&lt;p>解决方案：&lt;/p>
&lt;ol>
&lt;li>
&lt;p>CPU负载（多核绑核配置），网络负载（软中断优化，调整驱动队列netdev_max_backlog），内存配置（协议栈内存）；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>按峰值在来，增大buffer缓存区大小：&lt;/p>
&lt;/li>
&lt;/ol>
&lt;p>net.ipv4.udp_mem = xxx&lt;br>
net.ipv4.udp_rmem_min = xxx&lt;br>
net.ipv4.udp_wmem_min = xxx&lt;/p>
&lt;p>3. 调整应用设计：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>UDP本身就是无连接不可靠的协议，适用于报文偶尔丢失也不影响程序状态的场景，比如视频、音频、游戏、监控等。对报文可靠性要求比较高的应用不要使用 UDP，推荐直接使用 TCP。当然，也可以在应用层做重试、去重保证可靠性&lt;/p>
&lt;/li>
&lt;li>
&lt;p>如果发现服务器丢包，首先通过监控查看系统负载是否过高，先想办法把负载降低再看丢包问题是否消失&lt;/p>
&lt;/li>
&lt;li>
&lt;p>如果系统负载过高，UDP丢包是没有有效解决方案的。如果是应用异常导致CPU、memory、IO 过高，请及时定位异常应用并修复；如果是资源不够，监控应该能及时发现并快速扩容&lt;/p>
&lt;/li>
&lt;li>
&lt;p>对于系统大量接收或者发送UDP报文的，可以通过调节系统和程序的 socket buffer size 来降低丢包的概率&lt;/p>
&lt;/li>
&lt;li>
&lt;p>应用程序在处理UDP报文时，要采用异步方式，在两次接收报文之间不要有太多的处理逻辑&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>应用层socket丢包&lt;/p>
&lt;hr>
&lt;p>socket缓存区接收丢包&lt;/p>
&lt;p>查看：&lt;/p>
&lt;p>1. 抓包分析是否存在丢包情况；&lt;/p>
&lt;p>2. 查看统计：&lt;/p>
&lt;p>netstat -s|grep &amp;ldquo;packet receive errors&amp;rdquo;&lt;/p>
&lt;p>解决方案：&lt;/p>
&lt;p>调整socket缓冲区大小：&lt;/p>
&lt;p>socket配置（所有协议socket）：&lt;br>
# Default Socket Receive Buffer&lt;br>
net.core.rmem_default = 31457280&lt;br>
# Maximum Socket Receive Buffer&lt;br>
net.core.rmem_max = 67108864&lt;/p>
&lt;p>具体大小调整原理：&lt;/p>
&lt;p>缓冲区大小没有任何设置值是最佳的，因为最佳大小随具体情况而不同&lt;/p>
&lt;p>缓冲区估算原理：在数据通信中，带宽时延乘积（英语：bandwidth-delay product；或称带宽延时乘积、带宽延时积等）指的是一个数据链路的能力（每秒比特）与来回通信延迟（单位秒）的乘积。[1][2]其结果是以比特（或字节）为单位的一个数据总量，等同在任何特定时间该网络线路上的最大数据量——已发送但尚未确认的数据。&lt;/p>
&lt;p>BDP = 带宽 * RTT&lt;/p>
&lt;p>可以通过计算当面节点带宽和统计平均时延来估算BDP，即缓冲区的大小，可以参考下面常见场景估计：&lt;/p>
&lt;p>&lt;img src="https://mmbiz.qpic.cn/sz_mmbiz_png/8pECVbqIO0wf4MEvQSRT3JhRrXHLiaELpcCrGObrTZqH4G5GBSMX8Wv5rfYTpSrFvp7RqCM0mXAe5aK6dzu4pEA/640?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1" alt="">&lt;/p>
&lt;p>应用设置tcp连接数大小丢包&lt;/p>
&lt;p>查看：&lt;/p>
&lt;p>请参考上面TCP连接队列分析；&lt;/p>
&lt;p>解决方案：&lt;/p>
&lt;p>设置合理的连接队列大小，当第三次握手时，当server接收到ACK 报之后， 会进入一个新的叫 accept 的队列，该队列的长度为 min(backlog, somaxconn)，默认情况下，somaxconn 的值为 128，表示最多有 129 的 ESTAB 的连接等待 accept()，而 backlog 的值则应该是由 int listen(int sockfd, int backlog) 中的第二个参数指定，listen 里面的 backlog 可以有我们的应用程序去定义的；&lt;/p>
&lt;p>应用发送太快导致丢包&lt;/p>
&lt;p>查看统计：&lt;/p>
&lt;p>netstat -s|grep &amp;ldquo;send buffer errors&lt;/p>
&lt;p>解决方案：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>ICMP/UDP没有流控机制，需要应用设计合理发送方式和速度，照顾到底层buff大小和CPU负载以及网络带宽质量；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>设置合理的sock缓冲区大小：&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>setsockopt(s,SOL_SOCKET,SO_SNDBUF, i(const char*)&amp;amp;nSendBuf,sizeof(int));&lt;/p>
&lt;ul>
&lt;li>调整系统socket缓冲区大小：&lt;/li>
&lt;/ul>
&lt;p># Default Socket Send Buffer&lt;br>
net.core.wmem_default = 31457280&lt;/p>
&lt;h1 id="maximum-socket-send-buffer">Maximum Socket Send Buffer&lt;a class="td-heading-self-link" href="#maximum-socket-send-buffer" aria-label="Heading self-link">&lt;/a>&lt;/h1>
&lt;p>net.core.wmem_max = 33554432&lt;/p>
&lt;p>附：简单总结一下内核协议栈丢包：&lt;/p>
&lt;p>&lt;img src="https://mmbiz.qpic.cn/sz_mmbiz_png/8pECVbqIO0wf4MEvQSRT3JhRrXHLiaELpzBXHS71Q8hc6ibuU2yLazGgl9L3AUySNkkDCJBJeVr9bEenx2PtUeCg/640?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1" alt="">&lt;/p>
&lt;p>相关工具介绍&lt;/p>
&lt;hr>
&lt;p>1.dropwatch工具&lt;/p>
&lt;p>原理： 监听 kfree_skb（把网络报文丢弃时会调用该函数）函数或者事件吗，然后打印对应调用堆栈；想要详细了解 linux 系统在执行哪个函数时丢包的话，可以使用 dropwatch 工具，它监听系统丢包信息，并打印出丢包发生的函数：&lt;/p>
&lt;p>&lt;img src="https://mmbiz.qpic.cn/sz_mmbiz_png/8pECVbqIO0wf4MEvQSRT3JhRrXHLiaELpicsdibyLpZl0o5JO5emoibHRWG9QiaaJrHCuD8oFXFf1ibbAIj93jmaU2iag/640?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1" alt="">&lt;/p>
&lt;p>2. tcpdump工具&lt;/p>
&lt;p>原理: tcpdump 是一个Unix下一个功能强大的网络抓包工具，它允许用户拦截和显示发送或收到过网络连接到该计算机的TCP/IP和其他数据包&lt;/p>
&lt;p>&lt;img src="https://mmbiz.qpic.cn/sz_mmbiz_png/8pECVbqIO0wf4MEvQSRT3JhRrXHLiaELp9fU6JBZo97YRkUOjiaiah4T9oia88U6dCZyHqsJBW7k4pVEsAks0BFeWQ/640?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1" alt="">&lt;/p>
&lt;p>抓包命令参考：&lt;/p>
&lt;p>&lt;a href="https://www.tcpdump.org/manpages/tcpdump.1.html">https://www.tcpdump.org/manpages/tcpdump.1.html&lt;/a>&lt;/p>
&lt;p>数据包分析：&lt;/p>
&lt;p>1.用wireshark工具分析 参考：Wireshark数据包分析实战.pdf&lt;/p>
&lt;p>2.可以转化生成CSV数据，用Excel或者shell去分析特定场景报文；&lt;/p>
&lt;p>3.可以在linux上用tshark命令行工具进行分析:&lt;/p>
&lt;p>&lt;a href="https://www.wireshark.org/docs/man-pages/tshark.html">https://www.wireshark.org/docs/man-pages/tshark.html&lt;/a>&lt;/p>
&lt;p>总结&lt;/p>
&lt;hr>
&lt;p>本文只是分析大部分可能会丢包节点，提供了单个节点丢包排查和相关的解决方案, 丢包问题牵扯网络链路各个组件，尤其是在云网络时代，网络拓扑复杂多变，涉及运营商网络，IDC网络，专线等underlay网络，边界网关，VPC网络，CLB负载均衡等云上overlay网络，各种丢包问题排障起来非常复杂且困难，但掌握网络通信基本原理后，可以分解网络拓扑，对通信节点进行逐一排查，也可以找到丢包位置，后续会更加深入介绍云计算时代，云上网络丢包排查方法，网络架构解析等，达到任何丢包问题都可以快速排查和定位解决，帮助客户快速恢复业务&lt;/p></description></item></channel></rss>