<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Linux 系统管理工具 on 断念梦的站点</title><link>https://desistdaydream.github.io/docs/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Linux-%E7%AE%A1%E7%90%86/Linux-%E7%B3%BB%E7%BB%9F%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/</link><description>Recent content in Linux 系统管理工具 on 断念梦的站点</description><generator>Hugo</generator><language>zh-cn</language><atom:link href="https://desistdaydream.github.io/docs/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Linux-%E7%AE%A1%E7%90%86/Linux-%E7%B3%BB%E7%BB%9F%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/index.xml" rel="self" type="application/rss+xml"/><item><title>CPU 管理工具</title><link>https://desistdaydream.github.io/docs/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Linux-%E7%AE%A1%E7%90%86/Linux-%E7%B3%BB%E7%BB%9F%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/CPU-%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Linux-%E7%AE%A1%E7%90%86/Linux-%E7%B3%BB%E7%BB%9F%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/CPU-%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/</guid><description>概述 参考：</description></item><item><title>Memory 管理工具</title><link>https://desistdaydream.github.io/docs/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Linux-%E7%AE%A1%E7%90%86/Linux-%E7%B3%BB%E7%BB%9F%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/Memory-%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Linux-%E7%AE%A1%E7%90%86/Linux-%E7%B3%BB%E7%BB%9F%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/Memory-%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/</guid><description>概述 参考：
查看 Memory 的使用情况 我们可以通过多种方式查看 Memory 信息。
free 命令 参考：
https://gitlab.com/procps-ng/procps ~]# free -h total used free shared buff/cache available Mem: 3.8Gi 846Mi 506Mi 1.0Mi 2.5Gi 2.9Gi Swap: 0B 0B 0B Mem：设备上的真实内存
total # 总计。该设备的总内存大小 used # 已使用的。linux 对内存的使用量 free # 空闲的。还剩多少内存可用 shared # 共享内存 buff # 缓冲区(buffer)。保存一些将要写入到硬盘中的数据。 cache # 缓存。从硬盘中读出的数据存放到内存中，以便再次读取相同数据时速度更快。 availabel # 可用的。free+buff/cache 合起来就是可用的。 free 命令 与 /proc/meminfo 文件中信息的对应关系 free 命令输出 /proc/meminfo文件的字段 Mem: total MemTotal Mem: used MemTotal - MemFree - Buffers - Cached - SReclaimable Mem: free MemFree Mem: shared Shmem Mem: buff/cache Buffers + Cached + SReclaimable Mem: available MemAvailable Swap: total SwapTotal Swap: used SwapTotal - SwapFree Swap: free SwapFree buff/cache = Buffers + Cached + SReclaimable</description></item><item><title>Cron</title><link>https://desistdaydream.github.io/docs/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Linux-%E7%AE%A1%E7%90%86/Linux-%E7%B3%BB%E7%BB%9F%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/Cron/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Linux-%E7%AE%A1%E7%90%86/Linux-%E7%B3%BB%E7%BB%9F%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/Cron/</guid><description>概述 参考：
Wiki, Cron 软件实用程序 Cron 也称为 Cron Job(定时任务)，是类 Unix 计算机操作系统中基于时间的 Job 调度 程序。设置和维护软件环境的用户使用 cron 来调度作业 (命令或 shell 脚本)，以便在固定的时间、日期或时间间隔定期运行。
cron 的操作由 Cron Table(计划任务表，简称 crontab) 文件驱动，该文件是一个配置文件，用于指定按给定计划定期运行的命令。 crontab 文件存储在保存作业列表和 cron 守护程序的其他指令的位置。用户可以拥有自己的个人 crontab 文件，并且通常有一个系统范围的 crontab 文件（通常在 /etc 或 /etc 的子目录中），只有系统管理员才能编辑。
Syntax(语法) Cron Table 的格式如下：
# ┌───────────── minute (0 - 59) # │ ┌───────────── hour (0 - 23) # │ │ ┌───────────── day of the month (1 - 31) # │ │ │ ┌───────────── month (1 - 12) # │ │ │ │ ┌───────────── day of the week (0 - 6) (Sunday to Saturday; # │ │ │ │ │ 7 is also Sunday on some systems) # │ │ │ │ │ # │ │ │ │ │ # * * * * * &amp;lt;COMMAND&amp;gt; 一个 crontab 中可以有多行，每行都代表一个 Job。</description></item><item><title>Login info mgmt</title><link>https://desistdaydream.github.io/docs/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Linux-%E7%AE%A1%E7%90%86/Linux-%E7%B3%BB%E7%BB%9F%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/Login-info-mgmt/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Linux-%E7%AE%A1%E7%90%86/Linux-%E7%B3%BB%E7%BB%9F%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/Login-info-mgmt/</guid><description>概述 参考：
查看登录日志
tail /var/log/secure procps 工具包中，有一些可以处理登录信息的工具，比如 pkill、w 等
last - 用来显示所有登录的信息 last 是 Util-linux Utilities
EXAMPLE
last reboot # 查看系统重新引导的时间。i.e.客户查看设备什么时候关机再开机过 lastb - 查看登录失败的用户信息 Notes: 这是一个指向 last 程序的软连接
lastb 程序在不同的发行版中，所属的 Package 不同。
lastb 工具会读取 /var/log/btmp 文件，并把文件内容中记录登录失败的信息列出来。b 是 bad 的含义，lastb 就是指现实坏的登录信息
~]# lastb root ssh:notty 172.19.42.203 Mon Jun 7 21:49 - 21:49 (00:00) root ssh:notty 172.19.42.203 Mon Jun 7 21:24 - 21:24 (00:00) root ssh:notty 172.19.42.203 Mon Jun 7 21:22 - 21:22 (00:00) .</description></item><item><title>BCC 工具集</title><link>https://desistdaydream.github.io/docs/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Linux-%E7%AE%A1%E7%90%86/Linux-%E7%B3%BB%E7%BB%9F%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/BCC-%E5%B7%A5%E5%85%B7%E9%9B%86/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Linux-%E7%AE%A1%E7%90%86/Linux-%E7%B3%BB%E7%BB%9F%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/BCC-%E5%B7%A5%E5%85%B7%E9%9B%86/</guid><description>概述 参考：
官网 GitHub 项目, iovisor/bcc BPF Compiler Collection(BPF 编译器合集，简称 BCC) 是用于创建有效的内核跟踪和操作程序的工具包。BCC 是 Linux 基金会旗下的 IO Visor 项目组做出来的基于 eBPF 的产品。BBC 主要用来为 Linux 提供 Dynamic Tracing(动态追踪) 功能的实现。
BCC 安装 通过 Linux 包管理器安装 Ubuntu 标准的 Ubuntu Universe 仓库 与 iovisor 的 PPA 仓库中都可以用来安装 BCC 工具，但是包的名称不同。Ubuntu 安装完的程序，其名称会在最后加上 -bpfcc。
使用 Ubuntu 仓库安装 sudo apt-get install bpfcc-tools linux-headers-$(uname -r) 使用 iovisor 仓库安装 sudo apt-key adv --keyserver keyserver.ubuntu.com --recv-keys 4052245BD4284CDD echo &amp;#34;deb https://repo.iovisor.org/apt/$(lsb_release -cs) $(lsb_release -cs) main&amp;#34; | sudo tee /etc/apt/sources.</description></item><item><title>bpftrace 工具</title><link>https://desistdaydream.github.io/docs/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Linux-%E7%AE%A1%E7%90%86/Linux-%E7%B3%BB%E7%BB%9F%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/bpftrace-%E5%B7%A5%E5%85%B7/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Linux-%E7%AE%A1%E7%90%86/Linux-%E7%B3%BB%E7%BB%9F%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/bpftrace-%E5%B7%A5%E5%85%B7/</guid><description>概述 参考：
GitHub 项目，iovisor/bpftrace bpftrace 是用于 Linux 增强型 eBPF 的高级跟踪语言，可在最近的 Linux 内核 (4.x) 中使用。 bpftrace 使用 LLVM 作为后端，将脚本编译为 BPF 字节码，并利用 BCC 与 Linux BPF 系统交互，以及现有的 Linux 跟踪功能：内核动态跟踪（kprobes）、用户级动态跟踪（uprobes）、和跟踪点。 bpftrace 语言的灵感来自 awk 和 C，以及 DTrace 和 SystemTap 等前身跟踪器。 bpftrace 是由 Alastair Robertson 创建的。、
简单示例
# Files opened by process bpftrace -e &amp;#39;tracepoint:syscalls:sys_enter_open { printf(&amp;#34;%s %s\n&amp;#34;, comm, str(args-&amp;gt;filename)); }&amp;#39; # Syscall count by program bpftrace -e &amp;#39;tracepoint:raw_syscalls:sys_enter { @[comm] = count(); }&amp;#39; # Read bytes by process: bpftrace -e &amp;#39;tracepoint:syscalls:sys_exit_read /args-&amp;gt;ret/ { @[comm] = sum(args-&amp;gt;ret); }&amp;#39; # Read size distribution by process: bpftrace -e &amp;#39;tracepoint:syscalls:sys_exit_read { @[comm] = hist(args-&amp;gt;ret); }&amp;#39; # Show per-second syscall rates: bpftrace -e &amp;#39;tracepoint:raw_syscalls:sys_enter { @ = count(); } interval:s:1 { print(@); clear(@); }&amp;#39; # Trace disk size by process bpftrace -e &amp;#39;tracepoint:block:block_rq_issue { printf(&amp;#34;%d %s %d\n&amp;#34;, pid, comm, args-&amp;gt;bytes); }&amp;#39; # Count page faults by process bpftrace -e &amp;#39;software:faults:1 { @[comm] = count(); }&amp;#39; # Count LLC cache misses by process name and PID (uses PMCs): bpftrace -e &amp;#39;hardware:cache-misses:1000000 { @[comm, pid] = count(); }&amp;#39; # Profile user-level stacks at 99 Hertz, for PID 189: bpftrace -e &amp;#39;profile:hz:99 /pid == 189/ { @[ustack] = count(); }&amp;#39; # Files opened, for processes in the root cgroup-v2 bpftrace -e &amp;#39;tracepoint:syscalls:sys_enter_openat /cgroup == cgroupid(&amp;#34;/sys/fs/cgroup/unified/mycg&amp;#34;)/ { printf(&amp;#34;%s\n&amp;#34;, str(args-&amp;gt;filename)); }&amp;#39;</description></item><item><title>Cockpit</title><link>https://desistdaydream.github.io/docs/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Linux-%E7%AE%A1%E7%90%86/Linux-%E7%B3%BB%E7%BB%9F%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/Cockpit/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Linux-%E7%AE%A1%E7%90%86/Linux-%E7%B3%BB%E7%BB%9F%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/Cockpit/</guid><description>概述 参考：
官网：https://cockpit-project.org/ cockpit 是一个基于 web 的 Linxu 服务器管理工具。可以通过 web 端管理服务器上的虚拟机、容器、服务、网络、存储等等。还可以提供一个 web 版的控制台。
Cockpit 关联文件与配置 /etc/cockpit/
./ws-certs.d/ # https 证书保存目录。cockpit 第一次启动时，会在该目录生成 https 所需的 证书与私钥</description></item><item><title>procps 工具集</title><link>https://desistdaydream.github.io/docs/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Linux-%E7%AE%A1%E7%90%86/Linux-%E7%B3%BB%E7%BB%9F%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/procps-%E5%B7%A5%E5%85%B7%E9%9B%86/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Linux-%E7%AE%A1%E7%90%86/Linux-%E7%B3%BB%E7%BB%9F%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/procps-%E5%B7%A5%E5%85%B7%E9%9B%86/</guid><description>概述 参考：
https://sourceforge.net/projects/procps-ng/ GitLab 项目，procps-ng/procps GitHub 项目，uutils/procps # 有人用 Rust 重写了 procps 项目 procps 是一组命令行和全屏实用程序，它们主要从 Proc 文件系统 中获取信心，该文件系统为内核数据结构提供了一个简单的接口。procps 程序通常集中在描述系统上运行的进程的结构上。包括以下程序(每个标题都是一个程序)
Note：该工具集就算是最小化安装的 linux 发行版系统也是默认包含的~
free - 显示系统中可用和已用的内存量 详见 Memory 管理工具
kill - 向指定PID的进程发送信号 可用的信号详见 Signal(信号)
kill 命令将指定的信号发送到指定的进程或进程组。 如果未指定信号，则发送 TERM 信号。 TERM 信号将杀死不捕获该信号的进程。对于其他过程，由于无法捕获该信号，可能需要使用 KILL（9）信号。
大多数现代 Shell 具有内置的 kill 函数，其用法与此处描述的命令非常相似。&amp;rsquo;-a&amp;rsquo; 和 &amp;lsquo;-p&amp;rsquo; 选项以及通过命令名称指定进程的可能性是 本地扩展。
如果 sig 为 0，则不发送信号，但仍执行错误检查。
“信号 0” 有点像精神上的 “ping”。在 shell 程序脚本中使用 kill -0 PID 是判断 PID 是否有效的好方法。信号 0 仅用于检查进程是否存在。
Syntax(语法) sysstat 工具集</description></item><item><title>psmisc 工具集</title><link>https://desistdaydream.github.io/docs/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Linux-%E7%AE%A1%E7%90%86/Linux-%E7%B3%BB%E7%BB%9F%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/psmisc-%E5%B7%A5%E5%85%B7%E9%9B%86/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Linux-%E7%AE%A1%E7%90%86/Linux-%E7%B3%BB%E7%BB%9F%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/psmisc-%E5%B7%A5%E5%85%B7%E9%9B%86/</guid><description>概述 参考：
项目地址：https://gitlab.com/psmisc/psmisc psmisc 是一个小型的应用程序集合，与 procps-ng 工具集类似，都是使用伪文件系统(/proc)内的信息来展示系统信息
该工具集包含包含以下程序(每个标题都是一个)
fuser - 显示正在使用指定 文件 或 sockets 的进程 fuser 使用指定的文件或文件系统显示进程的 PID。 在默认的显示模式下，每个文件名后都有一个字母，表示访问类型：
c # 当前目录。 e # 一个可执行文件正在运行。 f # 打开文件。 在默认显示模式下省略 f。 F # 打开文件进行写入。 默认显示模式下省略 F。 r # 根目录。 m # 映射文件或共享库。 fuser [OPTIONS] OPTIONS
-m # 显示使用命名文件系统或块设备的所有进程 killall - 通过进程名称向指定进程发送信号 与 kill 命令类似，但是不像 kill 只能指定进程的 PID，而是可以通过进程的名称来发送信号
EXAMPLE：
killall -0 nginx # 向名为 nginx 的进程发送 0 信号 peekfd - shows the data travelling over a file descriptor prtstat - 输出一个进程的统计信息 pslog - prints log path(s) of a process pstree - 以树状显示当前正在运行的进程 该命令与 ps 类似，但是不会像 ps -ef 一样显示内核态进程</description></item><item><title>strace 工具</title><link>https://desistdaydream.github.io/docs/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Linux-%E7%AE%A1%E7%90%86/Linux-%E7%B3%BB%E7%BB%9F%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/strace-%E5%B7%A5%E5%85%B7/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Linux-%E7%AE%A1%E7%90%86/Linux-%E7%B3%BB%E7%BB%9F%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/strace-%E5%B7%A5%E5%85%B7/</guid><description>概述 参考：
GitHub 项目，strace/strace 官网 Manual(手册)，strace(1) strace 是一个用来跟踪 system calls(系统调用) 和 signals(信号) 的工具。
在最简单的情况下，strace 会运行指定的命令，直到退出为止。 它截获并记录 由进程调用的系统调用 和 由进程接收的信号。 每个系统调用的名称，其参数及其返回值都会在 标准错误 或使用 -o 选项指定的文件上显示。
strace 是有用的诊断，说明和调试工具。系统管理员，诊断人员和疑难解答人员将发现，对于不容易获取源代码的程序而言，这是无价的，因为它们无需重新编译即可跟踪它们。学生，黑客和过于好奇的人会发现，即使跟踪普通程序，也可以学到很多有关系统及其系统调用的知识。而且程序员会发现，由于系统调用和信号是在用户/内核界面上发生的事件，因此仔细检查此边界对于错误隔离，健全性检查和尝试捕获竞争状况非常有用。
strace 输出内容介绍 追踪到系统调用时输出的信息 下面是一个最基本，最简单的追踪，strace 程序执行时，输出的每一行内容都是一个 syscall(系统调用)。基本格式如下：
SyscallName(Parameter) = ReturnValue
假如我追踪 cat /dev/null 命令，则输出中有这么一段：
# 使用了 openat 这个系统调用，参数为 &amp;#34;/dev/null&amp;#34;,O_RDONLY，返回值为 3 openat(AT_FDCWD, &amp;#34;/dev/null&amp;#34;, O_RDONLY) = 3 如果命令出现错误，通常 ReturenVale 为 -1，并附加 errno 符号和错误信息
openat(AT_FDCWD, &amp;#34;123&amp;#34;, O_RDONLY) = -1 ENOENT (No such file or directory) 追踪到信号时输出的信息 如果追踪到信号，则输出内容的基本格式如下：
SignalName{si_signo=SignalName, si_code=SI_USER, si_pid=PID, .</description></item><item><title>sysstat 工具集</title><link>https://desistdaydream.github.io/docs/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Linux-%E7%AE%A1%E7%90%86/Linux-%E7%B3%BB%E7%BB%9F%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/sysstat-%E5%B7%A5%E5%85%B7%E9%9B%86/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Linux-%E7%AE%A1%E7%90%86/Linux-%E7%B3%BB%E7%BB%9F%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/sysstat-%E5%B7%A5%E5%85%B7%E9%9B%86/</guid><description>概述 参考：
GitHub 项目，sysstat/sysstat 官网 Manual(手册)，pidstat(1) Manual(手册)，sar(1) sysstat 包包含很多类 UNIX 的应用程序，用以监控系统性能和使用活动。
cifsiostat iostat - 报告设备和分区的 I/O 统计数据 iostat 命令用于通过观察设备活动的时间及其平均传输速率来监视系统 I/O 设备的负载。 iostat 命令生成可用于更改系统配置的报告，以更好地平衡物理磁盘之间的输入/输出负载。
iostat 命令生成两种类型的报告，即 CPU 利用率报告和设备利用率报告。
CPU 利用率报告
Device 利用率报告
~]# iostat -xd Linux 4.18.0-193.19.1.el8_2.x86_64 (ansible.tj-test) 11/24/2020 _x86_64_ (4 CPU) Device r/s w/s rkB/s wkB/s rrqm/s wrqm/s %rrqm %wrqm r_await w_await aqu-sz rareq-sz wareq-sz svctm %util sda 0.04 0.17 1.56 11.25 0.00 0.26 0.19 60.08 10.57 54.93 0.01 40.14 65.</description></item></channel></rss>