<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Operating system on 断念梦的站点</title><link>https://desistdaydream.github.io/docs/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Operating-system/</link><description>Recent content in Operating system on 断念梦的站点</description><generator>Hugo</generator><language>zh-cn</language><atom:link href="https://desistdaydream.github.io/docs/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Operating-system/index.xml" rel="self" type="application/rss+xml"/><item><title>Operating system</title><link>https://desistdaydream.github.io/docs/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Operating-system/Operating-system/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Operating-system/Operating-system/</guid><description>概述 参考：
Wiki, Operating_system Operating system(操作系统，简称 OS) 也是一种软件，用来管理计算机硬件和其他以及自身软件资源的。
学习 《操作系统导论》
Time Sharing System(分时系统) 概述 Time Sharing Operating System(分时操作系统，简称 TSOS) 的出现是为了弥补批处理方式不能向用户提供交互式快速服务的缺点而发展起来的，并且成为了当今(2021 年) 的主流操作系统。
在分时系统中，一台计算机主机连接了多个终端，每个终端可由一个用户使用。用户通过终端交互式地向系统发出命令请求，系统接受用户的命令之后，采用时间片轮转方式处理服务请求，并通过交互方式在终端上向用户显示结果。
这样的系统现在(2021 年)仍然占据着大量的市场，Windos、MacOS，Linux 都属于分时操作系统。分时系统的典型代表就是 UNIX，它对后续操作系统的设计产生了重大影响。
分时共享是出于这样的认识而开发的：即尽管任何单个用户都会低效地使用计算机，但一大群用户在一起却不会。这是由于交互模式所致: 通常，单个用户会输入大量信息，然后进行长时间的暂停，但是一组用户同时工作将意味着一个用户的暂停将被其他用户的活动所填补。给定最佳的群体规模，整个过程可能非常有效。同样，可以将等待磁盘，磁带或网络输入所花费的一小部分时间授予其他用户。
分时的概念与实现 分时操作系统将 CPU 的运行时间划分为若干个小片段，称为 Time slice(时间片)。Time slice(时间片) 是系统规定进程一次使用 CPU 的最长时间(时间片的长短可以因不同系统而异)。
最开始，时间片通常是 100ms 左右，这是一个实验统计值(不能太大也不能太小)。另外，在硬件方面设立一个中断时钟，它每过时间片便向 CPU 发一次中断信号。于是，假设现在有多个用户程序 A、B、C，CPU 在一个 A 执行完一个时间片后便被中断，然后去执行 B 一个时间片，再执行 C 一个时间片，一次循环，直到 A、B、C 三个程序全部执行完成。操作系统会保护被中断程序的运行现场，转去执行另一个用户程序。
就这样，操作系统可以把 CPU 按时间片依次分配给系统中的各个用户程序。由于系统中用户程序的数目是有限的，所以，只要时间片大小选取合适，就能给用户以独占系统资源的感觉，可以使每个用户能及时与自己的作业交互，使用户的请求得到及时响应。其实，为了实现人机交互，分时操作系统对早起批处理系统的运行方式进行了两大改进：一是作业直接进内存；二是作业不能长期占用 CPU，而是以时间片为单位交替使用 CPU。
分时系统的原理，同样也适用于多任务上，当系统中 1 个用户同时运行了多个程序时，也可以使用时间片的概念，让多个程序形成逻辑上的“并行”执行。
UNIX 就是典型的通用的分时操作系统。
Real Time System(实时操作系统) 概述 参考：Wiki, Real-time OS</description></item><item><title>环境变量</title><link>https://desistdaydream.github.io/docs/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Operating-system/%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Operating-system/%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/</guid><description>概述 参考：
Wiki, Environment_variable Environment variable(环境变量) 是一种特殊的Variable（本质也是变量，只不过是一个抽象的概念，将特定用途的变量抽象为环境变量）。环境变量可以影响计算机上运行中的进程的行为方式。环境变量是进程运行所在环境的一部分。例如，正在运行的进程可以查询 TEMP 环境变量的值，以发现一个合适的位置来存储临时文件；或者查询 HOME 变量以查找由运行进程的用户拥有的目录结构。
环境变量于 1979 年与 Unix 7 版本一起引入，因此从那时起包括在所有Unix-like OS中（包括 Linux、macOS）。从 1982 年的 PC DOS 2.0 开始，所有后续的 Microsoft OS也都将环境变量作为一项功能包含在其中。
尽管各种操作系统中对于环境变量在使用时的语法、标准各有不同，但所有系统都统一将环境变量作为操作系统的基本功能之一。</description></item><item><title>POSIX</title><link>https://desistdaydream.github.io/docs/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Operating-system/POSIX/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Operating-system/POSIX/</guid><description>概述 参考：
Wiki, POSIX 腾讯云，什么是 POSIX Portable Operating System Interface(便携式操作系统接口，POSIX) 是 IEEE 的计算机协会指定的一系列标准，用于维护操作系统之间的兼容性。 POSIX 定义了应用程序编程接口 (API)，以及命令行 shell 和实用程序接口，以实现与 类 Unix 操作系统 和 其他操作系统的软件兼容性。
一般情况下，应用程序通过应用编程接口(API)而不是直接通过系统调用来编程。这点很重要，因为应用程序使用的这种编程接口实际上并不需要和内核 提供的系统调用对应。一个 API 定义了一组应用程序使用的编程接%% %%口。它们可以实现成一个系统调用，也可以通过调用多个系统调用来实现，而完全不使用任何系 统调用也不存在问题。实际上，API 可以在各种不同的操作系统上实现，给应用程序提供完全相同的接口，而它们本身在这些系统上的实现却可能迥异。
在 Unix 世界中，最流行的应用编程接口是基于 POSIX 标准的。从纯技术的角度看，POSIX 是由 IEEE 的一组标准组成，其目标是提供一套大体上基于 Unix 的可移植操作系统标准。Linux 是与 POSIX 兼容的。
POSIX 是说明 API 和系统调用之间关系的一个极好例子。在大多数 Unix 系统上，根据 POSIX 而定义的 API 函数和系统调用之间有着直接关 系。实际上，POSIX 标准就是仿照早期 Unix 系统的界面建立的。另一方面，许多操作系统，像 Windows NT，尽管和 Unix 没有什么关系，也提供了与 POSIX 兼容的库。
Linux 的系统调用像大多数 Unix 系统一样，作为 C 库的一部分提供如图 5-1 所示。如图 5-1 所示 C 库实现了 Unix 系统的主要 API，包括标 准 C 库函数和系统调用。所有的 C 程序都可以使用 C 库，而由于 C 语言本身的特点，其他语言也可以很方便地把它们封装起来使用。此外，C 库提供了 POSIX 的绝大部分 API。</description></item></channel></rss>