<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>微内核 on 断念梦的站点</title><link>https://desistdaydream.github.io/docs/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Kernel/%E5%BE%AE%E5%86%85%E6%A0%B8/</link><description>Recent content in 微内核 on 断念梦的站点</description><generator>Hugo</generator><language>zh-cn</language><atom:link href="https://desistdaydream.github.io/docs/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Kernel/%E5%BE%AE%E5%86%85%E6%A0%B8/index.xml" rel="self" type="application/rss+xml"/><item><title>关于微内核的对话</title><link>https://desistdaydream.github.io/docs/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Kernel/%E5%BE%AE%E5%86%85%E6%A0%B8/%E5%85%B3%E4%BA%8E%E5%BE%AE%E5%86%85%E6%A0%B8%E7%9A%84%E5%AF%B9%E8%AF%9D/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Kernel/%E5%BE%AE%E5%86%85%E6%A0%B8/%E5%85%B3%E4%BA%8E%E5%BE%AE%E5%86%85%E6%A0%B8%E7%9A%84%E5%AF%B9%E8%AF%9D/</guid><description>参考：原文链接
不知怎么的，最近 “微内核 vs 宏内核” 又成了热门话题。这场争论从 1992 年开始……
前言 说实话我很久没有关心操作系统了，因为通常所谓的 “操作系统” 在我心里不过是一个 C 语言的运行时系统（run-time system），就像 JVM 是 Java 的运行时系统一样。由于 C 语言的设计缺陷，这些系统引入了各种无需有的概念（进程，线程，虚拟内存……），以及它们带来的复杂性和开销。
微内核与宏内核之争当然也包括在内，在我看来这些都是无需有的概念和争论。操作系统相关的领域有很多的 “宗教斗争”，比如“Linux vs Windows”，“自由软件 vs 不自由软件”，“RISC vs CISC”，甚至“VIM vs Emacs”…… 人们为了证明自己用的系统或者工具是世界上“最好” 的，吵得昏天黑地。遇到有人指出自己用的工具的缺点，随时可能拿枪毙了对方。这些被叫做“flame war”。
我曾经是某些宗教斗争中活跃的一员，不知道这事的人可以去查一下我的历史。等你经历了很多才发现，原来这些宗教情绪和斗争都是那么幼稚无知。
这种 “技术宗教情绪” 往往显示出参与者心理地位的低下。因为他们缺乏自信，所以他们的心理需要靠山。这个靠山可能是某种操作系统（比如 Linux），某种编程语言（比如 C++），或者某种工具（比如 VIM）。这些人以自己能熟练使用这些工具为豪，居高临下，看不起“异教徒”。
具有技术宗教情绪的人看似是为了 “技术”，“理想”，而其实跟那些以为开着豪车，穿着名牌就是“上流社会” 的人是一样低级的，因为他们依靠于这些物品，所以他们的地位在这些物品之下。
一个人需要彻底的把这些东西看成是 “东西”，不带有任何崇拜或者鄙视的情绪，他的心理才算是成熟了。
在我的理念里，一个操作系统本应该大概是这个样子。简单得很，根本不存在那么多问题。我可以利用这些思想来看透现有操作系统的绝大部分思想，管它是微内核还是宏内核。我可以把现有的操作系统看成是这个系统的 “退化版”。
操作系统是一个死知识横行的领域。很多人发现操作系统课难学，难理解。里面有些内容，比如各种同步机制，很多人上完课毕了业，工作很多年以后都还弄不明白是怎么回事，它们为什么在那里。类似的东西包括虚拟内存，进程与线程的区别，等等。
经过了很多的经验和思考，加上其他领域给我的启发，我终于明白了。原来很多这些概念都是无须有的，死掉的知识。
操作系统课程里面的概念经常是这样形成的：
很久以前，有人为了解决了一个特定的问题，提出了一个概念（比如 semaphore）。这个概念本来只有一个用途，就是解决他遇到的那个特定的问题。 因为这人太有名，这概念就被写进了教科书里。有时候连他当时的具体实现细节都给写进去了。比如 semaphore 的两个操作被叫做 P 和 V，连这两个名字都给作为 “典故” 写进去了。 教授们照本宣科，吹毛求疵，要你用这概念解决很多其它问题。很多根本就是人为造出来的变态问题，现实中遇不到的，或者是一些不该用这个概念解决的问题。 这就是为什么操作系统课学起来那么难——很多都是没道理的难。
再加上 Unix 系统里面一堆设计恶劣，无法有效组合使用的工具软件，操作系统就在学生心中产生了威慑力。死记硬背，喜欢折腾，喜欢发现奇技淫巧的人，在这个领域里茁壮成长。逐渐的，他们产生了莫名的自信。他们并不理解里面的很多概念是怎么来的，只是记住了它们，他们写的代码很难看懂。然后他们开始从心理上打压那些记不住这些概念，看不懂他们代码的人。
久而久之，这些人就成为了大家所崇拜的 “神”。
跟有些人聊操作系统是件闹心的事，因为我往往会抛弃一些术语和概念，从零开始讨论。我试图从 “计算本质” 的出发点来理解这类事物，理解它们的起因，发展，现状和可能的改进。我所关心的往往是“这个事物应该是什么样子”，“它还可以是什么（也许更好的）样子”，而不只是“它现在是什么样子”。不明白我的这一特性，又自恃懂点东西的人，往往会误以为我连基本的术语都不明白。于是天就这样被他们聊死了。</description></item><item><title>什么是微内核架构设计？</title><link>https://desistdaydream.github.io/docs/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Kernel/%E5%BE%AE%E5%86%85%E6%A0%B8/%E4%BB%80%E4%B9%88%E6%98%AF%E5%BE%AE%E5%86%85%E6%A0%B8%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Kernel/%E5%BE%AE%E5%86%85%E6%A0%B8/%E4%BB%80%E4%B9%88%E6%98%AF%E5%BE%AE%E5%86%85%E6%A0%B8%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/</guid><description>阿里妹导读：作为一名 Java 程序员，相信同学们都听说过微内核架构设计，也有自己的理解。那么微内核是如何被提出来的？微内核在操作系统内核的设计中又有什么作用？本文从插件化(Plug-in)架构的角度来诠释微内核架构设计，通过微内核架构和微服务架构的对比，分享其对微服务设计的参考意义。
文末福利：技术公开课《微服务实战：Service Mesh 与 Istio》。
关于微内核架构设计现在比较热，听起来好像是操作系统内核相关的，作为 Java 程序员，操作系统内核那么遥远的事情，好像和我们没有什么关系。但是如果我说微内核其实就是插件化(Plug-in)架构，你一定会一脸疑惑，“你居然向 Java 程序员解释什么是插件化架构？我每天都在用啊，Eclipse、IntelliJ IDEA、OSGi、Spring Plugin、SPI 等，哪个不是插件化架构。我的一些项目也是采用插件化设计的，如使用插件实现流程控制定制等等”。但是别着急，即便是我们每天都在使用的技术，而且大多数人也都知道，如果我们能将其阐述得更清楚，并且能从中发现一些问题，做出一些优化有助于以后的架构设计，那么大多数人在日常的设计和开发中都能受益，岂不是更好。现在我们就来聊一聊微内核架构设计。
一 微内核设计之操作系统内核
微内核设计其实就是插件体系。我们都知道，操作系统内核诞生得比较早，所以插件化最早被用在内核设计上，于是就有了微内核设计这一称呼。
微内核是这样一种内核：它只完成内核不得不完成的功能，包括时钟中断、进程创建与销毁、进程调度、进程间通信，而其他的诸如文件系统、内存管理、设备驱动等都被作为系统进程放到了用户态空间。说白了，微内核是相对于宏内核而言的，像 Linux 就是典型的宏内核，它除了时钟中断、进程创建与销毁、进程调度、进程间通信外，其他的文件系统、内存管理、输入输出、设备驱动管理都需要内核完成。
也就是说，微内核是相对宏内核而言的，宏内核是一个包含非常多功能的底层程序，也就是我们现在讲的 Monolith。它干的事情非常多，而且不是可插拔的，修改一些小的功能，都会涉及到整个程序的重新编译等，比如一个功能出现了一个小 bug，可能导致整个内核都出问题。这也是很多人将 Linux 称为 monolithic OS 的原因。而微内核只负责最核心的功能，其他功能都是通过用户态独立进程以插件方式加入进来，然后微内核负责进程的管理、调度和进程之间通讯，从而完成整个内核需要的功能。基本一个功能出现问题，但是该功能是以独立进程方式存在的，不会对其他进程有什么影响从而导致内核不可用，最多就是内核某一功能现在不可用而已。
微内核就是一个运行在最高级别的程序片段，它能完成用户态程序不能完成的一些功能。微内核通过进程间通信来协调各个系统进程间的合作，这就需要系统调用，而系统调用需要切换堆栈以及保护进程现场，比较耗费时间；而宏内核则是通过简单的函数调用来完成各个模块之间的合作，所以理论上宏内核效率要比微内核高。这个和微服务的架构设计一样，我们将 Monolith 应用划分为多个小应用后，系统的设计就变得比较复杂了，之前都是应用内部函数调用，现在要涉及网络通讯、超时等问题，同时响应时间会被拉长。
聊到这里，相信大家对微内核和宏内核已经有了一个大致的了解，看起来各有千秋。但是宏内核有一个最大的问题就是定制和维护陈本。现在的移动设备和 IoT 设备越来越多，如果要把一个庞大复杂的内核适配到某一设备上，是一件非常复杂的事情，如果很简单的话，那么把 Linux 内核适配到 Android 内核，甚至到 Tesla 等车载系统，基本上人人都可以做了。
因此我们更需要一个微内核的架构设计，方便定制，而且非常小，可以实现功能的热替换或者在线更新等，这就是微内核被提出来的核心需求。但是微内核有一个运行的效率问题，所以在微内核和宏内核之间，又有了 Hybrid 内核，主要是想拥有微内核的灵活性，同时在关键点上有宏内核的性能。微内核设计在理论上确实有效率问题，但是随着芯片设计、硬件性能提升等，这方面或许已经有了非常大的提升，已经不再是最关键的问题。
总体下来，内核设计有三个形式，如下：
二 插件化(Plug-in)架构设计
上面聊了微内核在操作系统内核设计中的作用，接下来我们就开始讨论更通用的插件化架构设计，毕竟这个词大家都明白。
插件化架构非常简单，就两个核心组件：系统核心(Core System)和插件化组件(Plug-in component)。Core System 负责管理各种插件，当然 Core System 也会包含一些重要功能，如插件注册管理、插件生命周期管理、插件之间的通讯、插件动态替换等。整体结构如下：
插件化架构对微服务架构设计帮助非常大，考虑到隔离性，插件可能是以独立进程方式运行的，那么这些进程如果扩展到网络上，分布在众多的服务器上，这个就是微服务架构的原型，所以了解微内核的同学都不屑于和你讨论微服务架构，相信你也明白了，除了 IT 传统的鄙视链因素，原理上确实就是这么回事。
回到微服务架构设计场景，我们将 Plug-in component 重新命名为服务(Service)，这个和微内核设计中的服务也差不多，这个时候微服务和微内核就差不多了，都涉及到服务注册、管理和服务之间的通讯等。那我们看一下微内核是如何解决服务之间的通讯问题的？以下摘自维基百科：
因为所有服务行程都各自在不同地址空间运行，因此在微核心架构下，不能像宏内核一样直接进行函数调用。在微核心架构下，要创建一个进程间通信机制，通过消息传递的机制来让服务进程间相互交换消息，调用彼此的服务，以及完成同步。采用主从式架构，使得它在分布式系统中有特别的优势，因为远程系统与本地进程间，可以采用同一套进程间通信机制。
也就是说，采取的是基于消息的进程间通讯机制。消息最简单，就两个接口：send 和 receive，消息发送出去，然后等着收消息，处理后再发消息就可以了，这里大家应该也知道了，这个是异步的。回到插件化架构设计中，Plug-in 组件设计包含交互规范，也就是和外界相互通讯的接口，如果是基于消息通讯的话，就是 send 和 receive 接口，可以说是非常简单的。</description></item></channel></rss>