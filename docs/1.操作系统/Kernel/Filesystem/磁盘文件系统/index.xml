<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>断念梦的站点 – 磁盘文件系统</title><link>https://desistdaydream.github.io/docs/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Kernel/Filesystem/%E7%A3%81%E7%9B%98%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/</link><description>Recent content in 磁盘文件系统 on 断念梦的站点</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><atom:link href="https://desistdaydream.github.io/docs/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Kernel/Filesystem/%E7%A3%81%E7%9B%98%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/index.xml" rel="self" type="application/rss+xml"/><item><title>Docs: EXT FileSystem</title><link>https://desistdaydream.github.io/docs/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Kernel/Filesystem/%E7%A3%81%E7%9B%98%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/EXT-FileSystem/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Kernel/Filesystem/%E7%A3%81%E7%9B%98%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/EXT-FileSystem/</guid><description>
&lt;h1 id="概述">概述&lt;a class="td-heading-self-link" href="#%e6%a6%82%e8%bf%b0" aria-label="Heading self-link">&lt;/a>&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://mp.weixin.qq.com/s/qJdoXTv_XS_4ts9YuzMNIw">公众号 - 小林 coding，一口气搞懂「文件系统」，就靠这 25 张图了&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.junmajinlong.com/linux/ext_filesystem/">骏马金龙，第4章 ext文件系统机制原理剖析&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;h2 id="block-的出现">block 的出现&lt;a class="td-heading-self-link" href="#block-%e7%9a%84%e5%87%ba%e7%8e%b0" aria-label="Heading self-link">&lt;/a>&lt;/h2>
&lt;p>硬盘最底层的读写 I/O 一次是一个扇区 512 字节，如果要读写大量文件，以扇区为单位肯定很慢很消耗性能，所以硬盘使用了一个称作逻辑块的概念。逻辑块是逻辑的，由磁盘驱动器负责维护和操作，它并非是像扇区一样物理划分的。一个逻辑块的大小可能包含一个或多个扇区，每个逻辑块都有唯一的地址，称为 LBA。有了逻辑块之后，磁盘控制器对数据的操作就以逻辑块为单位，一次读写一个逻辑块，磁盘控制器知道如何将逻辑块翻译成对应的扇区并读写数据。&lt;/p>
&lt;p>到了 Linux 操作系统层次，通过文件系统提供了一个也称为块的读写单元，文件系统数据块的大小一般为 1024bytes (1KiB) 或 2048bytes (2KiB) 或 4096bytes (4KiB)。文件系统数据块也是逻辑概念，是文件系统层次维护的，而磁盘上的逻辑数据块是由磁盘控制器维护的，文件系统的 IO 管理器知道如何将它的数据块翻译成磁盘维护的数据块地址 LBA。&lt;/p>
&lt;p>对于使用文件系统的 IO 操作来说，比如读写文件，这些 &lt;strong>IO 的基本单元&lt;/strong>是&lt;strong>文件系统上的数据块&lt;/strong>，一次读写一个文件系统数据块。比如需要读一个或多个块时，文件系统的 IO 管理器首先计算这些文件系统块对应在哪些磁盘数据块，也就是计算出 LBA，然后通知磁盘控制器要读取哪些块的数据，硬盘控制器将这些块翻译成扇区地址，然后从扇区中读取数据，再通过硬盘控制器将这些扇区数据重组写入到内存中去。&lt;/p>
&lt;p>&lt;strong>Block(块)&lt;/strong>，存放数据的最小单位，假如每个块为 4KiB，那大于 5KiB 的块就需要两个块，并且逻辑上占用了 8KiB 的空间。&lt;/p>
&lt;p>&lt;strong>Block Group(块组)&lt;/strong>，多个 Block 的集合&lt;/p>
&lt;p>Ext 预留了一些 Inode 做特殊特性使用，如下：某些可能并非总是准确，具体的 inode 号对应什么文件可以使用 &lt;code>find /-inum NUM&lt;/code> 查看&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>Ext4 的特殊 inode
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Inode号 用途
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#0000cf;font-weight:bold">0&lt;/span> 不存在0号inode，可用于标识目录data block中已删除的文件
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#0000cf;font-weight:bold">1&lt;/span> 虚拟文件系统，如/proc和/sys
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#0000cf;font-weight:bold">2&lt;/span> 根目录 &lt;span style="color:#8f5902;font-style:italic"># 注意此行&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#0000cf;font-weight:bold">3&lt;/span> ACL索引
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#0000cf;font-weight:bold">4&lt;/span> ACL数据
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#0000cf;font-weight:bold">5&lt;/span> Boot loader
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#0000cf;font-weight:bold">6&lt;/span> 未删除的目录
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#0000cf;font-weight:bold">7&lt;/span> 预留的块组描述符inode
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#0000cf;font-weight:bold">8&lt;/span> 日志inode
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#0000cf;font-weight:bold">11&lt;/span> 第一个非预留的inode，通常是 lost+found 目录
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>所以在 ext4 文件系统的 dumpe2fs 信息中，能观察到 fisrt inode 号可能为 11 也可能为 12。&lt;/p>
&lt;h2 id="块块组inode-计算">块、块组、Inode 计算&lt;a class="td-heading-self-link" href="#%e5%9d%97%e5%9d%97%e7%bb%84inode-%e8%ae%a1%e7%ae%97" aria-label="Heading self-link">&lt;/a>&lt;/h2>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>参考哪里？我也想知道真实的计算逻辑。。。&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>这些计算的结果通常与下列设置有关&lt;/p>
&lt;ul>
&lt;li>&lt;strong>DiskSize&lt;/strong> # 磁盘空间&lt;/li>
&lt;li>&lt;strong>BlockSize&lt;/strong> # 通常为 4096 Bytes
&lt;ul>
&lt;li>可使用 mke2fs -b 手动指定&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>BlocksPerGroup&lt;/strong> # 通常为 32768。每个块组中块的数量。
&lt;ul>
&lt;li>可使用 mke2fs -g 手动指定&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>BytesPerInode&lt;/strong> # 通常为 16384 Bytes。创建文件系统时，为每块 BytesPerInode 大小的空间创建一个 Inode。
&lt;ul>
&lt;li>BytesPerInode 也称为 inode_ratio，即.Inode 比率，全称应该是 Inode 分配比率，即每多少空间分配一个 Inode。&lt;/li>
&lt;li>可使用 mke2fs -i 手动指定&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>InodeSize&lt;/strong> # 通常为 256 Bytes。大小是 128 的倍数，最小为 128 Bytes。&lt;/li>
&lt;/ul>
&lt;p>其中 BlocksPerGroup(每个块组中块的数量)、BytesPerInode(每个Inode负责的空间大小) 这种值是后续计算的基础。固定下来这些，就算分区空间自动扩容/缩容，也可以根据这种数据自动增加/删除块的数量和 Inode 的数量。&lt;/p>
&lt;p>其中块大小为 4K，Inode 比率为 16K，也就是说，至少每 4 个块分配一个 Inode。当然分配的这些 inode 号只是预分配，并不真的代表会全部使用，毕竟每个文件才会分配一个 inode 号。&lt;/p>
&lt;p>这些数据将会计算出：&lt;/p>
&lt;ul>
&lt;li>&lt;strong>BlockCount&lt;/strong> # 块总数&lt;/li>
&lt;li>&lt;strong>BlockGroup&lt;/strong> # 块组总数&lt;/li>
&lt;li>&lt;strong>InodeCount&lt;/strong> # Inode 总数&lt;/li>
&lt;li>&lt;strong>InodePreGroup&lt;/strong> # 每个块组中包含的 Inode 数量&lt;/li>
&lt;li>&lt;strong>InodeUseage&lt;/strong> # 所有 Inode 占用的空间&lt;/li>
&lt;/ul>
&lt;p>假如现在有一块 35GiB 的磁盘，需要先转为 Bytes。然后根据给定的 BlockSize(块大小) 和 BlocksPerGroup(块组中块的数量)，计算出需要创建创建的&lt;strong>块数量&lt;/strong>和&lt;strong>块组数量&lt;/strong>。&lt;/p>
&lt;p>&lt;strong>Block 与 BlockGroup 的计算&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>BlockCount = DiskSize / BlockSize = 37580963840 / 4096 = 9175040&lt;/li>
&lt;li>BlockGroupCount = BlockCount / BlocksPerGroup = 9175040 / 32768 = 280&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>Inode 的计算&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>InodeCount = DiskSize / BytesPerInode = 37580963840 / 16384 = 2293760&lt;/li>
&lt;/ul>
&lt;blockquote>
&lt;p>由于之前已经知道了“每4个块分配一个Inode”，那么用“总块数/4”也是可以得到这个 Inode 总数的。&lt;/p>
&lt;/blockquote>
&lt;p>计算出的 Inode 数量将会平均分配到每个块组中&lt;/p>
&lt;ul>
&lt;li>InodePreGroup = InodeCount / BlockGroupCount = 2293760 / 280 = 8192&lt;/li>
&lt;/ul>
&lt;blockquote>
&lt;p>由于之前已经知道了“每4个块分配一个Inode”，那么用“每个块组中块的数量/4”也是可以得到每个块组中 Inode 的数量。&lt;/p>
&lt;/blockquote>
&lt;p>计算所有 Inode 需要占用的磁盘空间&lt;/p>
&lt;ul>
&lt;li>InodeUseage = InodeCount &lt;em>InodeSize = 2293760&lt;/em> 256 = 587202560 Bytes = 560 MiB&lt;/li>
&lt;/ul>
&lt;p>也就是说，一块 35 G 的硬盘，需要拿出来至少 560 MiB 的空间来存放 Inode 数据。&lt;/p>
&lt;p>&lt;strong>TODO:&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>&lt;strong>Inode 还有一个最低数量？就算执行 &lt;code>mke2fs -N 1&lt;/code> 命令，最后也不会只有一个 Inode，而是有 4480 个 Inode，这个数是怎么来的？&lt;/strong>&lt;/li>
&lt;li>**试了下 &lt;code>mke2fs -N 1000000&lt;/code> 最后生成的 Inode 数为 1003520，正好是 4480 的倍数&lt;/li>
&lt;li>&lt;strong>如果是 &lt;code>mke2fs -N 4481&lt;/code>，则生成的 Inode 数为 8960，也是 4480 的倍数。。。这个值到底咋来的。。。o(╯□╰)o&lt;/strong>**&lt;/li>
&lt;li>好像是根据 Inodes per group 的值来的，这个值好像必须要是 16 的倍数，并且最低值是 16，可是这个说法的来源是在哪呢？&lt;/li>
&lt;/ul>
&lt;p>上述计算的结果可以通过 dumpe2fs 命令查看&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>~&lt;span style="color:#ce5c00;font-weight:bold">]&lt;/span>&lt;span style="color:#8f5902;font-style:italic"># dumpe2fs -h ${DEVICE} | egrep -i &amp;#34;block|inode&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>dumpe2fs 1.45.5 &lt;span style="color:#ce5c00;font-weight:bold">(&lt;/span>07-Jan-2020&lt;span style="color:#ce5c00;font-weight:bold">)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Filesystem features: ext_attr resize_inode dir_index filetype sparse_super large_file
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Inode count: &lt;span style="color:#0000cf;font-weight:bold">2293760&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Block count: &lt;span style="color:#0000cf;font-weight:bold">9175040&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Reserved block count: &lt;span style="color:#0000cf;font-weight:bold">458752&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Free blocks: &lt;span style="color:#0000cf;font-weight:bold">9018814&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Free inodes: &lt;span style="color:#0000cf;font-weight:bold">2293749&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>First block: &lt;span style="color:#0000cf;font-weight:bold">0&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Block size: &lt;span style="color:#0000cf;font-weight:bold">4096&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Reserved GDT blocks: &lt;span style="color:#0000cf;font-weight:bold">1021&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Blocks per group: &lt;span style="color:#0000cf;font-weight:bold">32768&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Inodes per group: &lt;span style="color:#0000cf;font-weight:bold">8192&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Inode blocks per group: &lt;span style="color:#0000cf;font-weight:bold">512&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Reserved blocks uid: &lt;span style="color:#0000cf;font-weight:bold">0&lt;/span> &lt;span style="color:#ce5c00;font-weight:bold">(&lt;/span>user root&lt;span style="color:#ce5c00;font-weight:bold">)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Reserved blocks gid: &lt;span style="color:#0000cf;font-weight:bold">0&lt;/span> &lt;span style="color:#ce5c00;font-weight:bold">(&lt;/span>group root&lt;span style="color:#ce5c00;font-weight:bold">)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>First inode: &lt;span style="color:#0000cf;font-weight:bold">11&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Inode size: &lt;span style="color:#0000cf;font-weight:bold">256&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="todo-最低的-inode">TODO: 最低的 Inode&lt;a class="td-heading-self-link" href="#todo-%e6%9c%80%e4%bd%8e%e7%9a%84-inode" aria-label="Heading self-link">&lt;/a>&lt;/h3>
&lt;p>假如我们需要最少 1 个 Inode&lt;/p>
&lt;p>此时已知&lt;/p>
&lt;ul>
&lt;li>BlockCount = 9175040&lt;/li>
&lt;li>BlockGroupCount = 280&lt;/li>
&lt;li>BlockSize = 4096 Bytes&lt;/li>
&lt;li>InodeSize = 256 Bytes&lt;/li>
&lt;li>InodeRatio = 16384 Bytes&lt;/li>
&lt;/ul>
&lt;p>每 4 个块给 1 个 Inode，但肯定不是这个思路，因为照着这种算法，那就是有 2293760 个。所以肯定不是每 4 个块给 1 个 Inode。&lt;/p>
&lt;p>真实场景：&lt;/p>
&lt;ul>
&lt;li>现在是每 2048 个块给 一个 Inode&lt;/li>
&lt;li>280 个块组&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>~&lt;span style="color:#ce5c00;font-weight:bold">]&lt;/span>&lt;span style="color:#8f5902;font-style:italic"># mke2fs -N 1 /dev/vdb&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>mke2fs 1.45.5 &lt;span style="color:#ce5c00;font-weight:bold">(&lt;/span>07-Jan-2020&lt;span style="color:#ce5c00;font-weight:bold">)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>/dev/vdb contains a ext2 file system
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> last mounted on Sat Mar &lt;span style="color:#0000cf;font-weight:bold">11&lt;/span> 16:14:14 &lt;span style="color:#0000cf;font-weight:bold">2023&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Proceed anyway? &lt;span style="color:#ce5c00;font-weight:bold">(&lt;/span>y,N&lt;span style="color:#ce5c00;font-weight:bold">)&lt;/span> y
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Creating filesystem with &lt;span style="color:#0000cf;font-weight:bold">9175040&lt;/span> 4k blocks and &lt;span style="color:#0000cf;font-weight:bold">4480&lt;/span> inodes
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Filesystem UUID: acebc9ab-c53e-4f74-bd6b-443343a76bab
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Superblock backups stored on blocks:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> 32768, 98304, 163840, 229376, 294912, 819200, 884736, 1605632, 2654208,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> 4096000, &lt;span style="color:#0000cf;font-weight:bold">7962624&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Allocating group tables: &lt;span style="color:#204a87;font-weight:bold">done&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Writing inode tables: &lt;span style="color:#204a87;font-weight:bold">done&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Writing superblocks and filesystem accounting information: &lt;span style="color:#204a87;font-weight:bold">done&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>~&lt;span style="color:#ce5c00;font-weight:bold">]&lt;/span>&lt;span style="color:#8f5902;font-style:italic"># dumpe2fs -h ${DEVICE} | egrep -i &amp;#34;block|inode&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>dumpe2fs 1.45.5 &lt;span style="color:#ce5c00;font-weight:bold">(&lt;/span>07-Jan-2020&lt;span style="color:#ce5c00;font-weight:bold">)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Filesystem features: ext_attr resize_inode dir_index filetype sparse_super large_file
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Inode count: &lt;span style="color:#0000cf;font-weight:bold">4480&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Block count: &lt;span style="color:#0000cf;font-weight:bold">9175040&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Reserved block count: &lt;span style="color:#0000cf;font-weight:bold">458752&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Free blocks: &lt;span style="color:#0000cf;font-weight:bold">9161894&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Free inodes: &lt;span style="color:#0000cf;font-weight:bold">4469&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>First block: &lt;span style="color:#0000cf;font-weight:bold">0&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Block size: &lt;span style="color:#0000cf;font-weight:bold">4096&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Reserved GDT blocks: &lt;span style="color:#0000cf;font-weight:bold">1021&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Blocks per group: &lt;span style="color:#0000cf;font-weight:bold">32768&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Inodes per group: &lt;span style="color:#0000cf;font-weight:bold">16&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Inode blocks per group: &lt;span style="color:#0000cf;font-weight:bold">1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Reserved blocks uid: &lt;span style="color:#0000cf;font-weight:bold">0&lt;/span> &lt;span style="color:#ce5c00;font-weight:bold">(&lt;/span>user root&lt;span style="color:#ce5c00;font-weight:bold">)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Reserved blocks gid: &lt;span style="color:#0000cf;font-weight:bold">0&lt;/span> &lt;span style="color:#ce5c00;font-weight:bold">(&lt;/span>group root&lt;span style="color:#ce5c00;font-weight:bold">)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>First inode: &lt;span style="color:#0000cf;font-weight:bold">11&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Inode size: &lt;span style="color:#0000cf;font-weight:bold">256&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h1 id="ext-文件系统详解">EXT 文件系统详解&lt;a class="td-heading-self-link" href="#ext-%e6%96%87%e4%bb%b6%e7%b3%bb%e7%bb%9f%e8%af%a6%e8%a7%a3" aria-label="Heading self-link">&lt;/a>&lt;/h1>
&lt;blockquote>
&lt;p>参考:&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://mp.weixin.qq.com/s/q6OjwCXSk05TvX_BIu1M0g">公众号 -  无聊的闪客，你管这破玩意叫文件系统&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>&lt;strong>你手里有一块硬盘，大小为 1T&lt;/strong>&lt;/p>
&lt;p>&lt;img src="https://mmbiz.qpic.cn/mmbiz_png/GLeh42uInXRPpGdb1rLVOuU9fgMuLiaDfZqVQibyBs0wVPoFMcGCmqwVCiaBK4j30rciagooOJK38S0Gk3Tb2udw0g/640?wx_fmt=png" alt="">&lt;/p>
&lt;p>&lt;strong>你还有一堆文件&lt;/strong>&lt;/p>
&lt;p>&lt;img src="https://mmbiz.qpic.cn/mmbiz_jpg/GLeh42uInXRPpGdb1rLVOuU9fgMuLiaDfDf52Y0RCfHGsgYDk3yP8RXAjlFgFaPwPyNPVqmiaxrCDY2y2hHDRuzQ/640?wx_fmt=jpeg" alt="">&lt;/p>
&lt;p>这些文件在硬盘看来，就是一堆二进制数据而已&lt;/p>
&lt;p>&lt;img src="https://mmbiz.qpic.cn/mmbiz_jpg/GLeh42uInXRPpGdb1rLVOuU9fgMuLiaDfmENc0IKA0Kd8ITOfDe5D0z3wlTsyvb0iamvbzjy3icUU5uKHPb8icklIg/640?wx_fmt=jpeg" alt="">&lt;/p>
&lt;p>你准备把这些文件存储在硬盘上，并在需要的时候读取出来。&lt;/p>
&lt;p>要设计怎样的软件，才能更方便地在硬盘中读写这些文件呢？&lt;/p>
&lt;p>首先我不想和复杂的扇区，设备驱动等细节打交道，因此我先实现了一个简单的功能，将硬盘按逻辑分成一个个的&lt;strong>块&lt;/strong>，并可以以块为单位进行读写。&lt;/p>
&lt;p>每个块就定义为两个物理扇区的大小，即 1024 字节，就是 1KB 啦。&lt;/p>
&lt;p>硬盘太大不好分析，我们就假设你的硬盘只有 1MB，那么这块硬盘则有 1024 个块。&lt;/p>
&lt;p>&lt;img src="https://mmbiz.qpic.cn/mmbiz_jpg/GLeh42uInXRPpGdb1rLVOuU9fgMuLiaDf56b6Iia6zq3Yw6XeosYOV7Rds82Xn2sxuV75Iaib9Qb72yE30zNqXOicg/640?wx_fmt=jpeg" alt="">&lt;/p>
&lt;p>OK，我们开始存文件啦！&lt;/p>
&lt;p>准备一个文件&lt;/p>
&lt;p>&lt;img src="https://mmbiz.qpic.cn/mmbiz_png/GLeh42uInXRPpGdb1rLVOuU9fgMuLiaDftL60S3R7ftR7ygNTQOHRAmPayVlLj4At7uJKoAyu6icibxIXzIWAKsHg/640?wx_fmt=png" alt="">&lt;/p>
&lt;p>随便选个块放进去，3 号块吧！&lt;/p>
&lt;p>&lt;img src="https://mmbiz.qpic.cn/mmbiz_jpg/GLeh42uInXRPpGdb1rLVOuU9fgMuLiaDfkHibk00PpYTMhgbwniamDKiarXxAU0oibicgXTjeznytfHdJZJR7a2PTl2w/640?wx_fmt=jpeg" alt="">&lt;/p>
&lt;p>成功！首战告捷！&lt;/p>
&lt;h2 id="再存一个文件">再存一个文件！&lt;a class="td-heading-self-link" href="#%e5%86%8d%e5%ad%98%e4%b8%80%e4%b8%aa%e6%96%87%e4%bb%b6" aria-label="Heading self-link">&lt;/a>&lt;/h2>
&lt;p>诶？发现问题了，万一这个文件也存到了 3 号块，不是把原来的文件覆盖了么？不行，得有一个地方记录，现在可使用的块有哪些，像这样。&lt;/p>
&lt;p>块 0：未使用&lt;/p>
&lt;p>块 1：未使用&lt;/p>
&lt;p>块 2：未使用&lt;/p>
&lt;p>块 3：已使用&lt;/p>
&lt;p>块 4：未使用&lt;/p>
&lt;p>&amp;hellip;&lt;/p>
&lt;p>块 1023：未使用&lt;/p>
&lt;p>那我们就用 0 号块，来记录所有块的使用情况吧！怎么记录呢？&lt;/p>
&lt;p>&lt;strong>位图！&lt;/strong>&lt;/p>
&lt;p>&lt;img src="https://mmbiz.qpic.cn/mmbiz_gif/GLeh42uInXRPpGdb1rLVOuU9fgMuLiaDfRruNoC8sYKTcib1ibOYFzGlLtYBphS1U3fnavQY1vasqjw4EG6IkrGfQ/640?wx_fmt=gif" alt="">&lt;/p>
&lt;p>那我们给块 0 起个名字，叫&lt;strong>块位图&lt;/strong>，之后这个块 0 就专门用来记录所有块的使用情况，不再用来存具体文件了。&lt;/p>
&lt;p>&lt;img src="https://mmbiz.qpic.cn/mmbiz_jpg/GLeh42uInXRPpGdb1rLVOuU9fgMuLiaDfN7kfnVIs7NVmZVxcBoTyK2aoa24OOxu56VMDEYXpeibswiagvGMZqB7A/640?wx_fmt=jpeg" alt="">&lt;/p>
&lt;p>当我们再存入一个新文件时，只需要在块位图中找到第一个为 0 的位，就可以找到第一个还未被使用的块，将文件存入。同时，别忘了把块位图中的相应位置 1。&lt;/p>
&lt;p>完美！&lt;/p>
&lt;h2 id="尝试读取刚刚的文件">尝试读取刚刚的文件。&lt;a class="td-heading-self-link" href="#%e5%b0%9d%e8%af%95%e8%af%bb%e5%8f%96%e5%88%9a%e5%88%9a%e7%9a%84%e6%96%87%e4%bb%b6" aria-label="Heading self-link">&lt;/a>&lt;/h2>
&lt;p>咦？又遇到问题了，我怎么找到刚刚的文件呢？根据块号么？这也太蠢了，就像你去书店找书，店员让你提供书的编号，而不是书名，显然不合理。&lt;/p>
&lt;p>因此我们给每个文件起一个名字，叫&lt;strong>文件名&lt;/strong>，通过它来寻找这个文件。&lt;/p>
&lt;p>那必然就要有一个地方，记录文件名与块号的对应关系，像这样。&lt;/p>
&lt;p>葵花宝典.txt：3 号块&lt;/p>
&lt;p>数学期末复习资料.mp4：5 号块&lt;/p>
&lt;p>无聊的闪客.pdf：10 号块&lt;/p>
&lt;p>&amp;hellip;&lt;/p>
&lt;p>别急，既然都要选一个地方记录文件名称了，不妨多记录一点我们关心的信息吧，比如文件大小、文件创建时间、文件权限等。&lt;/p>
&lt;p>这些东西自然也要保存在硬盘上，我们选择用一个固定大小的空间，来表示这些信息，多大空间呢？128 字节吧。&lt;/p>
&lt;p>为啥是 128 字节呢？我乐意。&lt;/p>
&lt;p>&lt;img src="https://mmbiz.qpic.cn/mmbiz_png/GLeh42uInXRPpGdb1rLVOuU9fgMuLiaDfUHOgLG93SuaRKVQx7KwvwEMkibXibUBiahk2zPGHxJEllw9yGIiaEHOZ7w/640?wx_fmt=png" alt="">&lt;/p>
&lt;p>我们将这 128 字节的结构体，叫做一个 &lt;strong>inode&lt;/strong>。&lt;/p>
&lt;p>之后，我们每存入一个新的文件，不但要占用一个块来存放这个文件本身，还要占用一个 inode 来存放文件的这些&lt;strong>元信息&lt;/strong>，并且这个 inode 的&lt;strong>所在块号&lt;/strong>这个字段，就指向这个文件所在的块号。&lt;/p>
&lt;p>&lt;img src="https://mmbiz.qpic.cn/mmbiz_jpg/GLeh42uInXRPpGdb1rLVOuU9fgMuLiaDfXh1ic04TbyrJJ8tjpSWGDnsStYz6Diazzibg6keU2nJdODg5XAq6IZ8eQ/640?wx_fmt=jpeg" alt="">&lt;/p>
&lt;p>如果一个 inode 为 128 字节，那么一个块就可以容纳 8 个 inode，我们可以将这些 inode 编上号。&lt;/p>
&lt;p>&lt;img src="https://mmbiz.qpic.cn/mmbiz_jpg/GLeh42uInXRPpGdb1rLVOuU9fgMuLiaDf4yV2MR2qXibFaibLRaT23S0FicZyuFAbUtCQnylRic8KdQL6zS04KvzM2Q/640?wx_fmt=jpeg" alt="">&lt;/p>
&lt;p>如果你觉得 inode 数不够，也可以用两个或者多个块来存放 inode 信息，但这样用于存放数据的块就少了，这就看你自己的平衡了。&lt;/p>
&lt;p>&lt;img src="https://mmbiz.qpic.cn/mmbiz_jpg/GLeh42uInXRPpGdb1rLVOuU9fgMuLiaDffrPoFxjuBZdpk3FFcrBricxWA8Iur8vSianfxgOFbVSxA1qjkMF9AugQ/640?wx_fmt=jpeg" alt="">&lt;/p>
&lt;p>同样，和块位图管理块的使用情况一样，我们也需要一个 &lt;strong>inode 位图&lt;/strong>，来管理 inode 的使用情况。我们就把 inode 位图，放在 1 号块吧！&lt;/p>
&lt;p>同时，我们把 inode 信息，放在 2 号块，一共存 8 条 inode，这样我们的 2 号块就叫做 &lt;strong>inode 表&lt;/strong>。&lt;/p>
&lt;p>现在，我们的文件系统结构，变成了下面这个样子。&lt;/p>
&lt;p>&lt;img src="https://mmbiz.qpic.cn/mmbiz_jpg/GLeh42uInXRPpGdb1rLVOuU9fgMuLiaDf7uy19fsibjjvkCBD82o2LzYoiaXMOUCoH5tswW0HVTAIxmdsbyH0oVDQ/640?wx_fmt=jpeg" alt="">&lt;/p>
&lt;p>注意：块位图是管理可用的块，每一位代表一个块的使用与否。inode 位图管理的是一条一条的 inode，并不是 inode 所占用的块，比如上图中有 8 条 inode，则 inode 位图中就有 8 位是管理他们的使用与否。&lt;/p>
&lt;h2 id="多个块">多个块&lt;a class="td-heading-self-link" href="#%e5%a4%9a%e4%b8%aa%e5%9d%97" aria-label="Heading self-link">&lt;/a>&lt;/h2>
&lt;p>现在，我们的文件很小，一个块就能容下。&lt;/p>
&lt;p>但如果需要两个块、三个块、四个块呢？&lt;/p>
&lt;p>很简单，我们只需要采用&lt;strong>连续存储法&lt;/strong>，而 inode 则只记录文件的第一个块，以及后面还需要多少块，即可。&lt;/p>
&lt;p>这种办法的缺点就是：容易留下大大小小的&lt;strong>空洞&lt;/strong>，新的文件到来以后，难以找到合适的空白块，空间会被浪费。&lt;/p>
&lt;p>&lt;img src="https://mmbiz.qpic.cn/mmbiz_png/GLeh42uInXRPpGdb1rLVOuU9fgMuLiaDfdjiaibCH3Amv5m7eslaImM2Z1HgnobqPdicCdczx9yd01ZkkykHxiaB4ug/640?wx_fmt=png" alt="">&lt;/p>
&lt;p>看来这种方式不行，那怎么办呢？&lt;/p>
&lt;p>既然在 inode 中记录了文件所在的块号，为什么不扩展一下，多记录几块呢？&lt;/p>
&lt;p>&lt;img src="https://mmbiz.qpic.cn/mmbiz_png/GLeh42uInXRPpGdb1rLVOuU9fgMuLiaDfUHOgLG93SuaRKVQx7KwvwEMkibXibUBiahk2zPGHxJEllw9yGIiaEHOZ7w/640?wx_fmt=png" alt="">&lt;/p>
&lt;p>原来在 inode 中只记录了一个块号，现在扩展一下，记录 8 个块号！而且这些块&lt;strong>不需要连续&lt;/strong>。&lt;/p>
&lt;p>&lt;img src="https://mmbiz.qpic.cn/mmbiz_png/GLeh42uInXRPpGdb1rLVOuU9fgMuLiaDfkJRKnxe1tV7DsOYnibcqnx06huWZHgJZS8qG5kKG3UPOfAlvGF5oL1A/640?wx_fmt=png" alt="">&lt;/p>
&lt;p>嗯，这是个可行的办法！&lt;/p>
&lt;p>但是这也仅仅能表示 8 个块，能记录的最大文件是 8K（记住，一个块是 1K）, 现在的文件轻松就超过这个限制了，这怎么办？&lt;/p>
&lt;p>很简单，我们可以让其中一个块，作为&lt;strong>间接索引&lt;/strong>。&lt;/p>
&lt;p>&lt;img src="https://mmbiz.qpic.cn/mmbiz_png/GLeh42uInXRPpGdb1rLVOuU9fgMuLiaDf78H2eJA2Hsib2kDzzibPdaM37BII5aJOkIbemBSWlfKL9VpaLmLemYkA/640?wx_fmt=png" alt="">&lt;/p>
&lt;p>这样瞬间就有 263 个块（多了 256 -1 个块）可用了，这种索引叫&lt;strong>一级间接索引&lt;/strong>。&lt;/p>
&lt;p>如果还嫌不够，就再弄一个块做一级间接索引，或者做二级间接索引（二级间接索引则可以多出 256 * 256 - 1 个块）。&lt;/p>
&lt;p>我们的文件系统，暂且先只弄一个一级间接索引。硬盘一共才 1024 个块，一个文件 263 个块够大了。再大了不允许，就这么任性，爱用不用。&lt;/p>
&lt;p>好了，现在我们已经可以保存很大的文件了，并且可以通过文件名和文件大小，将它们准确读取出来啦！&lt;/p>
&lt;h2 id="元数据记录">元数据记录&lt;a class="td-heading-self-link" href="#%e5%85%83%e6%95%b0%e6%8d%ae%e8%ae%b0%e5%bd%95" aria-label="Heading self-link">&lt;/a>&lt;/h2>
&lt;p>但我们得精益求精，我们再想想看这个文件系统有什么毛病。&lt;/p>
&lt;p>比如，inode 数量不够时，我们是怎么得知的呢？是不是需要在 inode 位图中找，找不到了才知道不够用了？&lt;/p>
&lt;p>同样，对于块数量不够时，也是如此。&lt;/p>
&lt;p>要是有个全局的地方，来记录这一切，就好了，也方便随时调整，比如这样&lt;/p>
&lt;p>inode 数量&lt;/p>
&lt;p>空闲 inode 数量&lt;/p>
&lt;p>块数量&lt;/p>
&lt;p>空闲块数量&lt;/p>
&lt;p>那我们就再占用一个块来存储这些数据吧！由于他们看起来像是站在上帝视角来描述这个文件系统的，所以我们把它放在最开始的块上，并把它叫做&lt;strong>超级块&lt;/strong>，现在的布局如下。&lt;/p>
&lt;p>&lt;img src="https://mmbiz.qpic.cn/mmbiz_jpg/GLeh42uInXRPpGdb1rLVOuU9fgMuLiaDfc7McjdEjQfcUbDDxOzVw6ZDqLLrJDAsY8IgdXN5lmsodZ6aHCxpbjg/640?wx_fmt=jpeg" alt="">&lt;/p>
&lt;p>我们继续精益求精。&lt;/p>
&lt;p>现在，&lt;strong>块位图&lt;/strong>、&lt;strong>inode 位图&lt;/strong>、&lt;strong>inode 表&lt;/strong>，都是是固定地占据这块 1、块 2、块 3 这三个位置。&lt;/p>
&lt;p>假如之后 inode 的数量很多，使得 inode 表或者 inode 位图需要占据多个块，怎么办？&lt;/p>
&lt;p>或者，块的数量增多（硬盘本身大了，或者每个块变小了），块位图需要占据多个块，怎么办？&lt;/p>
&lt;p>程序是死的，你不告诉它哪个块表示什么，它可不会自己猜。&lt;/p>
&lt;p>很简单，与超级块记录信息一样，这些信息也选择一个块来记录，就不怕了。那我们就选择紧跟在超级块后面的 1 号块来记录这些信息吧，并把它称之为&lt;strong>块描述符&lt;/strong>。&lt;/p>
&lt;p>&lt;img src="https://mmbiz.qpic.cn/mmbiz_jpg/GLeh42uInXRPpGdb1rLVOuU9fgMuLiaDffia4t0XszAj6icMpTAiaJY4d5cgN0Ka0DnULFZZZlCEdK3UmanFbqcSEA/640?wx_fmt=jpeg" alt="">&lt;/p>
&lt;p>当然，这些所在块号只是记录起始块号，块位图、inode 位图、inode 表分别都可以占用多个块。&lt;/p>
&lt;p>好了，大功告成！&lt;/p>
&lt;h2 id="我们再尝试存入一批文件">我们再尝试存入一批文件。&lt;a class="td-heading-self-link" href="#%e6%88%91%e4%bb%ac%e5%86%8d%e5%b0%9d%e8%af%95%e5%ad%98%e5%85%a5%e4%b8%80%e6%89%b9%e6%96%87%e4%bb%b6" aria-label="Heading self-link">&lt;/a>&lt;/h2>
&lt;ul>
&lt;li>葵花宝典.txt&lt;/li>
&lt;li>数学期末复习资料.mp4&lt;/li>
&lt;li>赘婿1.mp4&lt;/li>
&lt;li>赘婿2.mp4&lt;/li>
&lt;li>赘婿3.mp4&lt;/li>
&lt;li>赘婿4.mp4&lt;/li>
&lt;li>无聊的闪客.pdf&lt;/li>
&lt;/ul>
&lt;p>诶？这看着好不爽，所有的文件都是平铺开的，能不能拥有&lt;strong>层级关系&lt;/strong>呢？比如这样&lt;/p>
&lt;ul>
&lt;li>葵花宝典.txt&lt;/li>
&lt;li>数学期末复习资料.mp4&lt;/li>
&lt;li>赘婿&lt;/li>
&lt;li>赘婿1.mp4&lt;/li>
&lt;li>赘婿2.mp4&lt;/li>
&lt;li>赘婿3.mp4&lt;/li>
&lt;li>赘婿4.mp4&lt;/li>
&lt;li>无聊的闪客.pdf&lt;/li>
&lt;/ul>
&lt;p>我们将葵花宝典.txt 这种称为&lt;strong>普通文件&lt;/strong>，将赘婿这种称为&lt;strong>目录文件&lt;/strong>，如果要访问赘婿1.mp4，那全文件名要写成：赘婿/赘婿1.mp4。&lt;/p>
&lt;p>如何做到这一点呢？那我们又得把 inode 结构拿出来说事了。&lt;/p>
&lt;p>&lt;img src="https://mmbiz.qpic.cn/mmbiz_png/GLeh42uInXRPpGdb1rLVOuU9fgMuLiaDfUHOgLG93SuaRKVQx7KwvwEMkibXibUBiahk2zPGHxJEllw9yGIiaEHOZ7w/640?wx_fmt=png" alt="">&lt;/p>
&lt;p>此时需要一个属性来区分这个文件是普通文件，还是目录文件。&lt;/p>
&lt;p>缺什么就补什么嘛，我们已经很熟悉了，专门加一个 4 字节，来表示&lt;strong>文件类型&lt;/strong>。&lt;/p>
&lt;p>&lt;img src="https://mmbiz.qpic.cn/mmbiz_png/GLeh42uInXRPpGdb1rLVOuU9fgMuLiaDf9C2jf6WySMyJTvESoChM9aOCWDibOys76I4hufo45zu0WPWWMnea0xw/640?wx_fmt=png" alt="">&lt;/p>
&lt;p>如果是&lt;strong>普通文件&lt;/strong>，则这个 inode 所指向的数据块仍然和之前一样，就是文件本身原封不动的内容。&lt;/p>
&lt;p>但如果是&lt;strong>目录文件&lt;/strong>，则这个 inode 所指向的数据块，就需要重新规划了。&lt;/p>
&lt;p>这个数据块里应该是什么样子呢？可以是一个一个指向不同 inode 的紧挨着的结构体，比如这样。&lt;/p>
&lt;p>&lt;img src="https://mmbiz.qpic.cn/mmbiz_png/GLeh42uInXRPpGdb1rLVOuU9fgMuLiaDf4ia6OOsneVH1xWqnibiboqPCbDvZetEmTJ15oRATib4NicpqHibhPPp83BMw/640?wx_fmt=png" alt="">&lt;/p>
&lt;p>这样先通过 &lt;strong>赘婿&lt;/strong>这个目录文件，找到所在的数据块。再根据这个数据块里的一个个带有 &lt;strong>inode&lt;/strong> 信息的结构体，找到这个目录下的所有文件。&lt;/p>
&lt;p>完美！&lt;/p>
&lt;h2 id="目录">目录&lt;a class="td-heading-self-link" href="#%e7%9b%ae%e5%bd%95" aria-label="Heading self-link">&lt;/a>&lt;/h2>
&lt;p>不过这样的话，你想想看，如果想要查看一下赘婿&lt;strong>这个目录下的所有文件&lt;/strong>（比如 ll 命令），将文件名和文件类型都展示出来，怎么办呢？&lt;/p>
&lt;p>就需要把一个个结构体指向的 inode 从 inode 表中取出，再把文件名和文件类型取出，这很是浪费时间。&lt;/p>
&lt;p>而让用户看到一个目录下的所有文件，又是一个极其常见的操作。&lt;/p>
&lt;p>所以，不如把文件名和文件类型这种常见的信息，放在数据块中的结构体里吧。&lt;/p>
&lt;p>&lt;img src="https://mmbiz.qpic.cn/mmbiz_png/GLeh42uInXRPpGdb1rLVOuU9fgMuLiaDfaCmiaOAibU7q8kxf8CJdJRYYdqGdmnGAvb2pN5IhKENAON2GicIjAAAww/640?wx_fmt=png" alt="">&lt;/p>
&lt;p>同时，inode 结构中的文件名，好像就没啥用了，这种变长的东西放在这种定长的结构中本身就很讨厌，早就想给它去掉了。而且还能给其他信息省下空间，比如文件所在块的数组，就能再多几个了。&lt;/p>
&lt;p>太好了，去掉它！&lt;/p>
&lt;p>&lt;img src="https://mmbiz.qpic.cn/mmbiz_png/GLeh42uInXRPpGdb1rLVOuU9fgMuLiaDfJSNp4Dxibd7IFba5DoicWdgkHiba1khAdAibwU1vmpDjN8ia3DS1ibwMklew/640?wx_fmt=png" alt="">&lt;/p>
&lt;p>OK，大功告成，现在我们就可以给文件分门别类放进不同目录下了，还可以在目录下创建目录，无限套娃！&lt;/p>
&lt;p>现在的文件系统，已经比较完善了，只是还有一点不太爽。&lt;/p>
&lt;h2 id="最后">最后&lt;a class="td-heading-self-link" href="#%e6%9c%80%e5%90%8e" aria-label="Heading self-link">&lt;/a>&lt;/h2>
&lt;p>我们访问到一个目录下，可以很舒服地看到目录里的文件，然后再根据名称访问这个目录下的文件或者目录，整个过程都是一个套路。&lt;/p>
&lt;p>但是，最上层的目录下的所有文件，即&lt;strong>根目录&lt;/strong>，现在仍然需要通过遍历所有的 inode 来获得，能不能和上面的套路统一呢？&lt;/p>
&lt;p>答案非常简单，我们规定，&lt;strong>inode 表中的 0 号 inode，就表示根目录&lt;/strong>，一切的访问，就从这个根目录开始！&lt;/p>
&lt;p>&lt;img src="https://mmbiz.qpic.cn/mmbiz_png/GLeh42uInXRPpGdb1rLVOuU9fgMuLiaDf8t0qNVGLR6cKLv4SR0SGywsX1b5lPcu3AcGzUNjnCQ7V7QA7YE5IWg/640?wx_fmt=png" alt="">&lt;/p>
&lt;p>好了，这回没有然后了！&lt;/p>
&lt;p>我们最后来欣赏下我们的文件系统架构。&lt;/p>
&lt;p>&lt;img src="https://mmbiz.qpic.cn/mmbiz_png/GLeh42uInXRPpGdb1rLVOuU9fgMuLiaDfnk5ApwlxjBJSF2rSoxyhVFDcmktSrrah5Mj8iakhm4raOciaT4PLqQRg/640?wx_fmt=png" alt="">&lt;/p>
&lt;p>你是不是觉得这没啥了不起的。&lt;/p>
&lt;p>&lt;strong>但这个破玩意，它就叫文件系统&lt;/strong>&lt;/p>
&lt;h2 id="后记">后记&lt;a class="td-heading-self-link" href="#%e5%90%8e%e8%ae%b0" aria-label="Heading self-link">&lt;/a>&lt;/h2>
&lt;p>这个文件系统，和 linux 上的经典文件系统 &lt;strong>ext2&lt;/strong> 基本相同。&lt;/p>
&lt;p>下面是我画的 ext2 文件系统的结构（字段部分只画了核心字段）&lt;/p>
&lt;p>&lt;img src="https://mmbiz.qpic.cn/mmbiz_png/GLeh42uInXRPpGdb1rLVOuU9fgMuLiaDfP9ia54kT3wLekE3Id4bAib4EYTHVWP7p0PX1VQun1789BYzJNgTq2uUw/640?wx_fmt=png" alt="">&lt;/p>
&lt;p>如果你想了解更多的细节，可以参考官方说明文档: &lt;a href="https://www.nongnu.org/ext2-doc/ext2.pdf">https://www.nongnu.org/ext2-doc/ext2.pdf&lt;/a>&lt;/p>
&lt;p>你也可以用 linux 的 mke2fs 命令生成一个 ext2 文件系统的磁盘镜像，然后一个字节一个字节地对照这官方说明文档拆解，这种方式其实是最直接的。&lt;/p></description></item><item><title>Docs: Journaling File System</title><link>https://desistdaydream.github.io/docs/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Kernel/Filesystem/%E7%A3%81%E7%9B%98%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/Journaling-File-System/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Kernel/Filesystem/%E7%A3%81%E7%9B%98%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/Journaling-File-System/</guid><description>
&lt;h1 id="概述">概述&lt;a class="td-heading-self-link" href="#%e6%a6%82%e8%bf%b0" aria-label="Heading self-link">&lt;/a>&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Journaling_file_system">Wiki, Journaling file system&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;h2 id="背景">背景&lt;a class="td-heading-self-link" href="#%e8%83%8c%e6%99%af" aria-label="Heading self-link">&lt;/a>&lt;/h2>
&lt;p>File System(文件系统) 要解决的一个关键问题是怎样防止掉电或系统崩溃造成数据损坏，在此类意外事件中，导致文件系统损坏的根本原因在于写文件不是原子操作，因为写文件涉及的不仅仅是用户数据，还涉及 metadata(元数据) 包括 Superblock、inode bitmap、inode、data block bitmap 等，所以写操作无法一步完成，如果其中任何一个步骤被打断，就会造成数据的不一致或损坏。&lt;/p>
&lt;p>举一个简化的例子，我们对一个文件进行写操作，要涉及以下步骤：&lt;/p>
&lt;ol>
&lt;li>从 data block bitmap 中分配一个数据块；&lt;/li>
&lt;li>在 inode 中添加指向数据块的指针；&lt;/li>
&lt;li>把用户数据写入数据块。&lt;/li>
&lt;/ol>
&lt;ul>
&lt;li>如果 步骤 2 完成了，3 未完成。结果是数据损坏，因为该文件认为数据块是自己的，但里面的数据其实是垃圾；&lt;/li>
&lt;li>如果 步骤 2 完成了，1 未完成。结果是元数据不一致，因为该文件已经把数据块据为己有，然而文件系统却还认为该数据块未分配、随后又可能会把该数据块分配给别的文件、造成数据覆盖；&lt;/li>
&lt;li>如果 步骤 1 完成了、2 未完成。结果就是文件系统分配了一个数据块，但是没有任何文件用到这个数据块，造成空间浪费；&lt;/li>
&lt;li>如果 步骤 3 完成了，2 未完成。结果就是用户数据写入了硬盘数据块中，但白写了，因为文件不知道这个数据块是自己的。&lt;/li>
&lt;/ul>
&lt;h1 id="journaling-file-system-原理">Journaling File System 原理&lt;a class="td-heading-self-link" href="#journaling-file-system-%e5%8e%9f%e7%90%86" aria-label="Heading self-link">&lt;/a>&lt;/h1>
&lt;blockquote>
&lt;p>&lt;strong>ext3、ext4、xfs 等都是一种 Journaling File System(日志文件系统)&lt;/strong>&lt;/p>
&lt;/blockquote>
&lt;p>&lt;strong>Journaling File System(日志文件系统)&lt;/strong> 就是为解决上述问题而诞生的。&lt;/p>
&lt;p>它的原理是在进行写操作之前，把即将进行的各个步骤（称为 transaction）事先记录下来，保存在文件系统上单独开辟的一块空间上，这就是所谓的日志(journal)，也被称为 Write-ahead logging，日志保存成功之后才进行真正的写操作、把文件系统的元数据和用户数据写进硬盘（称为 checkpoint），这样万一写操作的过程中掉电，下次挂载文件系统之前把保存好的日志重新执行一遍就行了（术语叫做 replay），避免了前述的数据损坏场景。&lt;/p>
&lt;p>有人问如果保存日志的过程中掉电怎么办？最初始的想法是把一条日志的数据一次性写入硬盘，相当于一个原子操作，然而这并不可行，因为硬盘通常以 512 字节为单位进行操作，日志数据一超过 512 字节就不可能一次性写入了。所以实际上是这么做的：给每一条日志设置一个结束符，只有在日志写入成功之后才写结束符，如果一条日志没有对应的结束符就会被视为无效日志，直接丢弃，这样就保证了日志里的数据是完整的。&lt;/p>
&lt;p>一条日志在它对应的写操作完成之后就没用了，占用的硬盘空间就可以释放。保存日志的硬盘空间大小是有限的，被循环使用，所以日志也被称为 circular log。&lt;/p>
&lt;p>至此可以总结一下日志文件系统的工作步骤了：&lt;/p>
&lt;ol>
&lt;li>Journal write : 把 transaction 写入日志中；&lt;/li>
&lt;li>Journal commit : 在一条日志保存好之后，写入结束符；&lt;/li>
&lt;li>Checkpoint : 进行真正的写操作，把元数据(metadata)和用户数据(user data)写入文件系统；&lt;/li>
&lt;li>Free : 回收日志占用的硬盘空间。&lt;/li>
&lt;/ol>
&lt;p>以上方式把 user data(用户数据) 也记录在日志中，称为 Data Journaling，Linux EXT3 文件系统就支持这种方式，这种方式存在效率问题：
就是每一个写操作涉及的元数据(metadata)和用户数据(user data)实际上都要在硬盘上写两次，一次写在日志里，一次写在文件系统上。元数据倒也罢了，用户数据通常比较大，拷贝几个 GB 的电影文件也要乘以 2 实在是降低了效率。&lt;/p>
&lt;p>一个更高效的方式是 Metadata Journaling，不把 user data(用户数据) 记录在日志中，它防止数据损坏的方法是先写入 user data(用户数据)、再写日志，即在上述 ”Journal write” 之前先写用户数据，这样就保证了只要日志是有效的，那么它对应的用户数据也是有效的，一旦发生掉电故障，最坏的结果也就是最后一条日志没记完，那么对应的用户数据也会丢，效果与 Data Journaling 丢弃日志一样，重要的是文件系统的一致性和完整性是有保证的。&lt;/p>
&lt;p>Metadata Journaling 又叫 Ordered Journaling，大多数文件系统都采用这种方式。像 Linux EXT3 文件系统也是可以选择 Data Journaling 还是 Ordered Journaling 的。&lt;/p></description></item><item><title>Docs: XFS</title><link>https://desistdaydream.github.io/docs/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Kernel/Filesystem/%E7%A3%81%E7%9B%98%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/XFS/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Kernel/Filesystem/%E7%A3%81%E7%9B%98%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/XFS/</guid><description>
&lt;h1 id="概述">概述&lt;a class="td-heading-self-link" href="#%e6%a6%82%e8%bf%b0" aria-label="Heading self-link">&lt;/a>&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/XFS">Wiki, XFS&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>XFS 是由 Silicon Graphics 于 1993 年创建的高性能 64 位 &lt;strong>Journaling File System(日志文件系统)&lt;/strong>。&lt;/p>
&lt;p>可以通过 &lt;a href="https://desistdaydream.github.io/docs/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Linux%20%E7%AE%A1%E7%90%86/Linux%20%E7%B3%BB%E7%BB%9F%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/%E7%A3%81%E7%9B%98%E4%B8%8E%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7.md#xfs_info">xfs_info&lt;/a> 命令行工具看到信息&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>~&lt;span style="color:#ce5c00;font-weight:bold">]&lt;/span>&lt;span style="color:#8f5902;font-style:italic"># xfs_info /dev/mapper/vg1-root&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>meta-data&lt;span style="color:#ce5c00;font-weight:bold">=&lt;/span>/dev/mapper/vg1-root &lt;span style="color:#000">isize&lt;/span>&lt;span style="color:#ce5c00;font-weight:bold">=&lt;/span>&lt;span style="color:#0000cf;font-weight:bold">512&lt;/span> &lt;span style="color:#000">agcount&lt;/span>&lt;span style="color:#ce5c00;font-weight:bold">=&lt;/span>4, &lt;span style="color:#000">agsize&lt;/span>&lt;span style="color:#ce5c00;font-weight:bold">=&lt;/span>&lt;span style="color:#0000cf;font-weight:bold">32735744&lt;/span> &lt;span style="color:#000">blks&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ce5c00;font-weight:bold">=&lt;/span> &lt;span style="color:#000">sectsz&lt;/span>&lt;span style="color:#ce5c00;font-weight:bold">=&lt;/span>&lt;span style="color:#0000cf;font-weight:bold">512&lt;/span> &lt;span style="color:#000">attr&lt;/span>&lt;span style="color:#ce5c00;font-weight:bold">=&lt;/span>2, &lt;span style="color:#000">projid32bit&lt;/span>&lt;span style="color:#ce5c00;font-weight:bold">=&lt;/span>&lt;span style="color:#000">1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ce5c00;font-weight:bold">=&lt;/span> &lt;span style="color:#000">crc&lt;/span>&lt;span style="color:#ce5c00;font-weight:bold">=&lt;/span>&lt;span style="color:#0000cf;font-weight:bold">1&lt;/span> &lt;span style="color:#000">finobt&lt;/span>&lt;span style="color:#ce5c00;font-weight:bold">=&lt;/span>1, &lt;span style="color:#000">sparse&lt;/span>&lt;span style="color:#ce5c00;font-weight:bold">=&lt;/span>1, &lt;span style="color:#000">rmapbt&lt;/span>&lt;span style="color:#ce5c00;font-weight:bold">=&lt;/span>&lt;span style="color:#000">0&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ce5c00;font-weight:bold">=&lt;/span> &lt;span style="color:#000">reflink&lt;/span>&lt;span style="color:#ce5c00;font-weight:bold">=&lt;/span>&lt;span style="color:#0000cf;font-weight:bold">1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#000">data&lt;/span> &lt;span style="color:#ce5c00;font-weight:bold">=&lt;/span> &lt;span style="color:#000">bsize&lt;/span>&lt;span style="color:#ce5c00;font-weight:bold">=&lt;/span>&lt;span style="color:#0000cf;font-weight:bold">4096&lt;/span> &lt;span style="color:#000">blocks&lt;/span>&lt;span style="color:#ce5c00;font-weight:bold">=&lt;/span>130942976, &lt;span style="color:#000">imaxpct&lt;/span>&lt;span style="color:#ce5c00;font-weight:bold">=&lt;/span>&lt;span style="color:#000">25&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ce5c00;font-weight:bold">=&lt;/span> &lt;span style="color:#000">sunit&lt;/span>&lt;span style="color:#ce5c00;font-weight:bold">=&lt;/span>&lt;span style="color:#0000cf;font-weight:bold">0&lt;/span> &lt;span style="color:#000">swidth&lt;/span>&lt;span style="color:#ce5c00;font-weight:bold">=&lt;/span>&lt;span style="color:#0000cf;font-weight:bold">0&lt;/span> blks
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#000">naming&lt;/span> &lt;span style="color:#ce5c00;font-weight:bold">=&lt;/span>version &lt;span style="color:#0000cf;font-weight:bold">2&lt;/span> &lt;span style="color:#000">bsize&lt;/span>&lt;span style="color:#ce5c00;font-weight:bold">=&lt;/span>&lt;span style="color:#0000cf;font-weight:bold">4096&lt;/span> ascii-ci&lt;span style="color:#ce5c00;font-weight:bold">=&lt;/span>0, &lt;span style="color:#000">ftype&lt;/span>&lt;span style="color:#ce5c00;font-weight:bold">=&lt;/span>&lt;span style="color:#0000cf;font-weight:bold">1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#000">log&lt;/span> &lt;span style="color:#ce5c00;font-weight:bold">=&lt;/span>internal log &lt;span style="color:#000">bsize&lt;/span>&lt;span style="color:#ce5c00;font-weight:bold">=&lt;/span>&lt;span style="color:#0000cf;font-weight:bold">4096&lt;/span> &lt;span style="color:#000">blocks&lt;/span>&lt;span style="color:#ce5c00;font-weight:bold">=&lt;/span>63937, &lt;span style="color:#000">version&lt;/span>&lt;span style="color:#ce5c00;font-weight:bold">=&lt;/span>&lt;span style="color:#000">2&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ce5c00;font-weight:bold">=&lt;/span> &lt;span style="color:#000">sectsz&lt;/span>&lt;span style="color:#ce5c00;font-weight:bold">=&lt;/span>&lt;span style="color:#0000cf;font-weight:bold">512&lt;/span> &lt;span style="color:#000">sunit&lt;/span>&lt;span style="color:#ce5c00;font-weight:bold">=&lt;/span>&lt;span style="color:#0000cf;font-weight:bold">0&lt;/span> blks, lazy-count&lt;span style="color:#ce5c00;font-weight:bold">=&lt;/span>&lt;span style="color:#0000cf;font-weight:bold">1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#000">realtime&lt;/span> &lt;span style="color:#ce5c00;font-weight:bold">=&lt;/span>none &lt;span style="color:#000">extsz&lt;/span>&lt;span style="color:#ce5c00;font-weight:bold">=&lt;/span>&lt;span style="color:#0000cf;font-weight:bold">4096&lt;/span> &lt;span style="color:#000">blocks&lt;/span>&lt;span style="color:#ce5c00;font-weight:bold">=&lt;/span>0, &lt;span style="color:#000">rtextents&lt;/span>&lt;span style="color:#ce5c00;font-weight:bold">=&lt;/span>&lt;span style="color:#0000cf;font-weight:bold">0&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div></description></item></channel></rss>