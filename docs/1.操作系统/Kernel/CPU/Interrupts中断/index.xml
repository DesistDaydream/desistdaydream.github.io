<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Interrupts(中断) on 断念梦的站点</title><link>https://desistdaydream.github.io/docs/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Kernel/CPU/Interrupts%E4%B8%AD%E6%96%AD/</link><description>Recent content in Interrupts(中断) on 断念梦的站点</description><generator>Hugo</generator><language>zh-cn</language><atom:link href="https://desistdaydream.github.io/docs/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Kernel/CPU/Interrupts%E4%B8%AD%E6%96%AD/index.xml" rel="self" type="application/rss+xml"/><item><title>Interrupts(中断)</title><link>https://desistdaydream.github.io/docs/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Kernel/CPU/Interrupts%E4%B8%AD%E6%96%AD/Interrupts%E4%B8%AD%E6%96%AD/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Kernel/CPU/Interrupts%E4%B8%AD%E6%96%AD/Interrupts%E4%B8%AD%E6%96%AD/</guid><description>概述 参考：
Wiki, Interrupt 公众号-云原生实验室，Linux 中断（IRQ/softirq）基础：原理及内核实现 Interrupte Request(终端请求，简称 IRQ)，是一种信号，该信号来源于外围硬件(相对于 CPU 和内存)的异步信号或者来自软件的同步信号，收到该信号后进行相应的硬件、软件处理。中断其实是一种异步的事件处理机制，可以提高系统的并发处理能力。
Linux 内核对计算机上所有的设备进行管理，进行管理的方式是内核和设备之间的通信。解决通信的方式有两种：
轮询。轮询是指内核对设备状态进行周期性的查询 中断。中断是指在设备需要 CPU 的时候主动发起通信 从物理学的角度看，中断是一种电信号，由硬件设备产生，并直接送入中断控制器（如 8259A）的输入引脚上，然后再由中断控制器向处理器发送相应的信号。处理器一经检测到该信号，便中断自己当前正在处理的工作，转而去处理中断。此后，处理器会通知 OS 已经产生中断。这样，OS 就可以对这个中断进行适当的处理。不同的设备对应的中断不同，而每个中断都通过一个唯一的数字标识，这些值通常被称为中断线。
中断可以分为 NMI(不可屏蔽中断) 和 INTR(可屏蔽中断)。其中 NMI 通常用于电源掉电和物理存储器奇偶校验；INTR 是可屏蔽中断，可以通过设置中断屏蔽位来进行中断屏蔽，它主要用于接受外部硬件的中断信号，这些信号由中断控制器传递给 CPU。
常见的两种中断控制器：
Programmable Interrupt Controller(可编程中断控制器，简称 PIC) 8259A Advanced Programmable Interrupt Controller(高级可编程中断控制器，简称 APIC) 传统的 PIC 是由两片 8259A 风格的外部芯片以“级联”的方式连接在一起。每个芯片可处理多达 8 个不同的 IRQ。因为从 PIC 的 INT 输出线连接到主 PIC 的 IRQ2 引脚，所以可用 IRQ 线的个数达到 15 个
硬中断与软中断 中断处理分为两部分，上半部与下半部。
硬中断，也就是中断处理的上半部 外围硬件发给 CPU 或者内存的异步信号就称之为硬中断 由与系统相连的外设(比如网卡、硬盘)自动产生的。主要是用来通知操作系统系统外设状态的变化。比如当网卡收到数据包的时候，就会发出一个中断。我们通常所说的中断指的是硬中断(hardirq)。 软中断：也就是中断处理的下半部 由软件系统本身发给操作系统内核的中断信号，称之为软中断。通常是由硬中断处理程序或进程调度程序对操作系统内核的中断，也就是我们常说的系统调用(System Call) 为了满足实时系统的要求，中断处理应该是越快越好。linux 为了实现这个特点，当中断发生的时候，硬中断处理那些短时间就可以完成的工作，而将那些处理事件比较长的工作，放到中断之后来完成，也就是软中断(softirq)来完成。 也就是说，如果在一个完整的中断流程中，硬中断首先产生，然后硬中断的处理程序将会发出中断信号后，再有软中断进行处理。</description></item><item><title>中断的理解</title><link>https://desistdaydream.github.io/docs/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Kernel/CPU/Interrupts%E4%B8%AD%E6%96%AD/%E4%B8%AD%E6%96%AD%E7%9A%84%E7%90%86%E8%A7%A3/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Kernel/CPU/Interrupts%E4%B8%AD%E6%96%AD/%E4%B8%AD%E6%96%AD%E7%9A%84%E7%90%86%E8%A7%A3/</guid><description>回到操作系统：中断 参考：https://www.junmajinlong.com/os/interrupt/
要想在任何需要的时候回到操作系统，这相当于是改变了 CPU 的正常执行流程，所以一个非常熟悉的字眼——中断（Interrupt）就出现了。通过中断，可以保证回到操作系统，从而将 CPU 的控制权交给操作系统。
中断的字面意思就是打断正常执行流程，但是注意，它表示的是打断流程而不是终止流程，这是不同的概念。中断是操作系统中非常重要的机制，正如上面所描述的：中断用于保证 CPU 控制权交给操作系统，从而让操作系统可以执行某些操作。
中断分为硬件中断和软件中断。
任何硬件，都有自己的 IRQ（中断请求），都可以在需要的时候通过总线向 CPU 发送硬件中断通知。比如时钟中断，当进程执行耗光时间片时将产生一个时钟中断，使得能够立刻进入操作系统并调度下一个要执行的进程，时钟中断是操作系统具有安全感的保证，只要时钟开始运行后，就意味着操作系统最终总能够获取到 CPU 控制权。再比如硬盘的 IO 中断，当硬盘读取所请求的数据完成后，就会发送硬盘 IO 中断，CPU 接到该中断后就会切换到操作系统，让操作系统去处理这个中断事件。
软件也可以发送中断，比如请求一个系统调用（system call），关于系统调用，后面再介绍。
无论是软中断还是硬件中断，最终的目的都是为了回到操作系统，将 CPU 交给操作系统。那么，中断是如何回到操作系统的呢？换句话说，中断时是如何进入内核态的呢？内核态又如何回到用户态呢？
当操作系统执行完相关操作后，就要回到用户态，要回到用户态也只需执行特殊的指令即可，一般称之为 return-from-trap 指令。（此处的 trap 又似乎是个名词，表示脱离陷阱，回到用户态之下。它将内核态描述为陷阱，这其实也是可以理解的，中断是事件，收到事件表示捕获到事件，什么具有捕获的能力？陷阱。在 bash 中也有一个 trap 命令，也可以理解为陷进，它用来设置信号处理程序，当捕获到信号时就做出某些处理。我们不管 trap 是陷入还是陷阱，我们关注的是作用：进入内核态和退出内核态。）
中断既然是打断 CPU 的执行流程，那么可能需要重新回到中断点继续正常的执行流程。所以，在发生中断时，需要保存好中断点以及相关的一些状态，以便能够在处理完中断后恢复执行流程继续向下执行。
所以，中断就像是突发事件，处理完成后如果恢复到断点处，那么对整个流程来说，中断就像是从未发生过的事一样，但却实实在在的被处理了。但是，中断后并不一定会恢复到断点处，因为中断处理程序可能会在恢复断点前直接退出这个执行流程，比如有些硬件中断表示一些异常现象（比如除 0 异常），这些异常可能会导致终止进程。</description></item><item><title>中断优化</title><link>https://desistdaydream.github.io/docs/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Kernel/CPU/Interrupts%E4%B8%AD%E6%96%AD/%E4%B8%AD%E6%96%AD%E4%BC%98%E5%8C%96/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Kernel/CPU/Interrupts%E4%B8%AD%E6%96%AD/%E4%B8%AD%E6%96%AD%E4%BC%98%E5%8C%96/</guid><description>如何优化软中断 CPU0 过高问题 RSS(Receive Side Scaling，需网卡支持多队列)
查看网卡是否支持队列 root@geekwolf:~# lscpi -vvv 06:00.0 Ethernet controller: Broadcom Corporation BCM57840 NetXtreme II 10/20-Gigabit Ethernet (rev 11) Subsystem: Hewlett-Packard Company Device 22fa Control: I/O- Mem+ BusMaster+ SpecCycle- MemWINV- VGASnoop- ParErr+ Stepping- SERR+ FastB2B- DisINTx+ Status: Cap+ 66MHz- UDF- FastB2B- ParErr- DEVSEL=fast &amp;gt;TAbort- &amp;lt;tabort - &amp;lt;MAbort- &amp;gt;SERR- &amp;lt;perr - INTx- Latency: 0, Cache Line Size: 64 bytes Interrupt: pin A routed to IRQ 32 Region 0: Memory at 93800000 (64-bit, prefetchable) [size=8M] Region 2: Memory at 93000000 (64-bit, prefetchable) [size=8M] Region 4: Memory at 95000000 (64-bit, prefetchable) [size=64K] [virtual] Expansion ROM at 95080000 [disabled] [size=512K] Capabilities: [48] Power Management version 3 Flags: PMEClk- DSI- D1- D2- AuxCurrent=0mA PME(D0+,D1-,D2-,D3hot+,D3cold+) Status: D0 NoSoftRst+ PME-Enable- DSel=0 DScale=1 PME- Capabilities: [50] Vital Product Data Product Name: HP FlexFabric 10Gb 2-port 536FLB Adapter Read-only fields: [PN] Part number: 766488-001 [EC] Engineering changes: A-5444 [MN] Manufacture ID: 31 30 33 43 [V0] Vendor specific: 12W PCIeGen3 [V1] Vendor specific: 7.</description></item></channel></rss>