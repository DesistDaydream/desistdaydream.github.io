<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Hardware on 断念梦的站点</title><link>https://desistdaydream.github.io/docs/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Kernel/Hardware/</link><description>Recent content in Hardware on 断念梦的站点</description><generator>Hugo</generator><language>zh-cn</language><atom:link href="https://desistdaydream.github.io/docs/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Kernel/Hardware/index.xml" rel="self" type="application/rss+xml"/><item><title>Block</title><link>https://desistdaydream.github.io/docs/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Kernel/Hardware/Block/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Kernel/Hardware/Block/</guid><description>概述 参考：
Block(块) 设备 包含的信息常见于如下几处
Sysfs 中的磁盘信息 Proc 中的磁盘信息 I/O 时间 I/O 时间 指 Block(块设备、磁盘、硬盘、etc.) 在执行 I/O 操作上花费的时间。
在 /sys/block/&amp;lt;DEV&amp;gt;/stat 文件中，io_ticks 字段记录了毫秒级的 磁盘 I/O 时间。如果磁盘在 1 秒内持续执行 I/O 操作，那么在 1 秒钟后，io_ticks 的值是 1000；如果 1 秒内磁盘一直空闲，那么 io_ticks 的值是 0。也就是说，io_ticks 的值每秒最多增加 1000。
[!Note] 在 Node Exporter 源码中，这里 可以看到 stats.IOsTotalTicks 对应 diskstatsCollector.descs[10](i.e. node_disk_io_time_seconds_total 指标)。而 IOsTotalTics 对应到 prometheus/procfs 项目，blockdevice/stats.go 中的 IOStats 结构体得 IOsTotalTicks 属性。这些结构体的信息来源遵循以下几个内核文档的说明
https://www.kernel.org/doc/Documentation/iostats.txt, https://www.kernel.org/doc/Documentation/block/stat.txt https://www.kernel.org/doc/Documentation/ABI/testing/procfs-diskstats 一般情况下，io_ticks 的值可以当作磁盘的使用率，比如计算某区间时间中，io_ticks 每秒的变化率（基于上面的逻辑，这个变化率一定是 0 到 1 之间的小数）。比如我们统计 1 分钟时间 io_ticks 增加了 60000，那说明这一分钟的时间中，磁盘一直在执行 I/O，i.</description></item><item><title>Driver</title><link>https://desistdaydream.github.io/docs/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Kernel/Hardware/Driver/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Kernel/Hardware/Driver/</guid><description>概述 参考：
Linux 中的 Driver(驱动) 管理。
部分 BUS_TYPE 可以在 /sys/bus/${BUS_TYPE}/drivers/ 可以找到各类型总线下的驱动。e.g. PCI 设备、USB 设备、etc. 。
Tip: 并不是所有的 BUS_TYPE 都有驱动，e.g. /sys/bus/memory/drivers/ 目录是空的
PCI /sys/bus/pci/drivers/${DRIVER}/ 目录是某个具体驱动下关联的设备的 PCI Addr 以及驱动相关操作
./${PCI_ADDR} # 使用了本驱动的设备的 PCI Addr 软链接，指向 /sys/devices/pciXXX/XXX/... 某个目录 ./bind # 向该文件写入 PCI Addr 将会让设备与内核绑定 ./unbind # 向该文件写入 PCI Addr 将会让设备从内核解绑 最佳实践 网卡的绑定与解绑 我这里用网卡演示绑定和解绑的过程
可以通过 lspci 命令查看该设备在内核中可以使用的驱动。
~]# lspci -s 0000:21:00.1 -v 21:00.1 Ethernet controller: Intel Corporation Ethernet Controller X710 for 10GbE SFP+ (rev 02) Subsystem: Intel Corporation Ethernet Converged Network Adapter X710 .</description></item><item><title>PCI</title><link>https://desistdaydream.github.io/docs/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Kernel/Hardware/PCI/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Kernel/Hardware/PCI/</guid><description>概述 参考:
GitHub 项目，torvalds/linux - 通过 sysfs 访问 PCI 设备资源 GitHub 项目，torvalds/linux - 如何编写 PCI 驱动 博客园，如何编写Linux PCI驱动程序 https://www.makelinux.net/ldd3/ - 12.1. The PCI Interface PCI device resources(PCI 设备资源) 由 Kernel 注册在 sysfs 的 /sys/devices/pci${DOMAIN:BUS}/ 目录。每个 PCI 设备资源在该目录下都有一个以 唯一标识符(有的时候也称为 PCI Address) 命名的目录，格式为: DOMAIN:BUS:SLOT.FUNC（e.g. 0000:17:00.0）
DOMAIN(域) # 表示 PCI 域编号。用于识别主机系统中的不同 PCI 主机桥。在较早期的系统中，只有一个域编号为 0。随着系统规模扩大，可能存在多个 PCI 域。 BUS(总线) # 表示 PCI 总线编号（16 进制）。一个 PCI 域中可能包含多条 PCI 总线，每条总线都有一个唯一编号。 SLOT(插槽) # 表示 PCI 插槽编号。每条 PCI 总线上可以连接多个 PCI 设备，每个设备对应一个插槽编号。 有的源码中也描述为 DEVICE。比如这里 FUNC(功能) # 表示 PCI 功能编号。一些 PCI 设备可能包含多个独立的功能，每个功能都有一个编号,用于区分和访问。对于单功能设备,该编号通常为 0。 有的源码中也描述为 FUNCTION 通常来说，目录可能是像这样的:</description></item></channel></rss>