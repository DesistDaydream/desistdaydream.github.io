<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Linux 网络栈管理 on 断念梦的站点</title><link>https://desistdaydream.github.io/docs/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Kernel/Network/Linux-%E7%BD%91%E7%BB%9C%E6%A0%88%E7%AE%A1%E7%90%86/</link><description>Recent content in Linux 网络栈管理 on 断念梦的站点</description><generator>Hugo</generator><language>zh-cn</language><atom:link href="https://desistdaydream.github.io/docs/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Kernel/Network/Linux-%E7%BD%91%E7%BB%9C%E6%A0%88%E7%AE%A1%E7%90%86/index.xml" rel="self" type="application/rss+xml"/><item><title>Linux 网络栈管理</title><link>https://desistdaydream.github.io/docs/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Kernel/Network/Linux-%E7%BD%91%E7%BB%9C%E6%A0%88%E7%AE%A1%E7%90%86/Linux-%E7%BD%91%E7%BB%9C%E6%A0%88%E7%AE%A1%E7%90%86/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Kernel/Network/Linux-%E7%BD%91%E7%BB%9C%E6%A0%88%E7%AE%A1%E7%90%86/Linux-%E7%BD%91%E7%BB%9C%E6%A0%88%E7%AE%A1%E7%90%86/</guid><description>概述 参考：
Kernel 文档-Linux Networking Documentation Kernel 文档-Linux Networking and Network Devices APIs arthurchiao.art 的文章 [译] Linux 网络栈监控和调优：接收数据（2016） [译] Linux 网络栈监控和调优：发送数据（2017） 和磁盘设备类似，Linux 用户想要使用网络功能，不能通过直接操作硬件完成，而需要直接或间接的操作一个 Linux 为我们抽象出来的设备，即通用的 Linux 网络设备来完成。一个常见的情况是，系统里装有一个硬件网卡，Linux 会在系统里为其生成一个网络设备实例，如 eth0，用户需要对 eth0 发出命令以配置或使用它了。更多的硬件会带来更多的设备实例，虚拟的硬件也会带来更多的设备实例。
网卡本身并不会连接连接任何网络，网卡需要相应的配置文件来告诉他们如何实现网络连接。而让网卡与配置文件关联的过程，就是 network.service 这类服务来实现的
在 Linux Kernel 中，一般使用“网络设备”这种称呼，来描述硬件物理网卡设备在系统中的实例。在不同的语境中，有时也简称为 “设备”、“DEV” 等等。网络设备可以是一块真实机器上的网卡，也可以是创建的虚拟的网卡。
而网络设备与网卡之间如何建立关系，就是网卡驱动程序的工作了，不同的网卡，驱动不一样，可以实现的功能也各有千秋。所以，想要系统出现 eth0 这种网络设备，网卡驱动程序是必须存在的，否则，没有驱动，也就无法识别硬件，无法识别硬件，在系统中也就不知道如何操作这个硬件。
常见术语 DataPath(数据路径) 网络数据在内核中进行网络传输时，所经过的所有点组合起来，称为数据路径。
Socket Buffer(简称 sk_buff 或 skb) 在内核代码中是一个名为 sk_buff 的结构体。内核显然需要一个数据结构来储存报文的信息。这就是 skb 的作用。
sk_buff 结构自身并不存储报文内容，它通过多个指针指向真正的报文内存空间:
sk_buff 是一个贯穿整个协议栈层次的结构，在各层间传递时，内核只需要调整 sk_buff 中的指针位置就行。
DEVICE(设备) 在内核代码中，是一个名为 net_device 的结构体。一个巨大的数据结构，描述一个网络设备的所有 属性、数据 等信息。
Linux 网络功能的实现 数据包的 Transmit(发送) 与 Receive(接收) 过程概览 Receive(接收) 过程 本文将拿 Intel I350 网卡的 igb 驱动作为参考，网卡的 data sheet 这里可以下 载 PDF （警告：文件很大）。 从比较高的层次看，一个数据包从被网卡接收到进入 socket 接收队列的整个过程如下：</description></item><item><title>Linux 网络包发送过程</title><link>https://desistdaydream.github.io/docs/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Kernel/Network/Linux-%E7%BD%91%E7%BB%9C%E6%A0%88%E7%AE%A1%E7%90%86/Linux-%E7%BD%91%E7%BB%9C%E5%8C%85%E5%8F%91%E9%80%81%E8%BF%87%E7%A8%8B/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Kernel/Network/Linux-%E7%BD%91%E7%BB%9C%E6%A0%88%E7%AE%A1%E7%90%86/Linux-%E7%BD%91%E7%BB%9C%E5%8C%85%E5%8F%91%E9%80%81%E8%BF%87%E7%A8%8B/</guid><description>25 张图，一万字，拆解 Linux 网络包发送过程
大家好，我是飞哥!
半年前我以源码的方式描述了网络包的接收过程。之后不断有粉丝提醒我还没聊发送过程呢。好，安排！
在开始今天的文章之前，我先来请大家思考几个小问题。
问 1：我们在查看内核发送数据消耗的 CPU 时，是应该看 sy 还是 si ？ 问 2：为什么你服务器上的 /proc/softirqs 里 NET_RX 要比 NET_TX 大的多的多？ 问 3：发送网络数据的时候都涉及到哪些内存拷贝操作？ 这些问题虽然在线上经常看到，但我们似乎很少去深究。如果真的能透彻地把这些问题理解到位，我们对性能的掌控能力将会变得更强。
带着这三个问题，我们开始今天对 Linux 内核网络发送过程的深度剖析。还是按照我们之前的传统，先从一段简单的代码作为切入。如下代码是一个典型服务器程序的典型的缩微代码：
int main(){ fd = socket(AF_INET, SOCK_STREAM, 0); bind(fd, ...); listen(fd, ...); cfd = accept(fd, ...); // 接收用户请求 read(cfd, ...); // 用户请求处理 dosometing(); // 给用户返回结果 send(cfd, buf, sizeof(buf), 0); } 今天我们来讨论上述代码中，调用 send 之后内核是怎么样把数据包发送出去的。本文基于 Linux 3.10，网卡驱动采用 Intel 的 igb 网卡举例。
预警：本文共有一万多字，25 张图，长文慎入！
开发内功修炼</description></item><item><title>network-scripts</title><link>https://desistdaydream.github.io/docs/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Kernel/Network/Linux-%E7%BD%91%E7%BB%9C%E6%A0%88%E7%AE%A1%E7%90%86/network-scripts/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Kernel/Network/Linux-%E7%BD%91%E7%BB%9C%E6%A0%88%E7%AE%A1%E7%90%86/network-scripts/</guid><description>概述 参考：
RedHat 官方文档，生产文档-RedHatEnterpriseLinux-6-部署指南-11.2.接口配置文件 /usr/share/doc/initscripts-XX/sysconfig.txt中的 ifcfg-&amp;lt;interface-name&amp;gt; 部分 Manual(手册),nm-settings-ifcfg-rh(5) RedHad 相关发行版的网络配置通过一系列脚本实现，随着时代的发展，已经逐渐启用，并由 NetworkManager 取代，NetworkManager 还单独出了一个适用于 RedHad 发行版的插件，名为 nm-setting-ifcfg-rh。这样，NetworkManager 可以将原本的配置目录中文件的格式，转变为适应 RedHad 的格式，并将配置文件保存到 /etc/sysconfig/network-scripts/ 目录下。
关联文件 /etc/sysconfig/ # 全局
./network # 全局网络配置 ./network-scripts/ # 曾经是网络配置脚本文件所在目录。CentOS 8 以后，移除了所有脚本，只用来为网络配置程序提供网络设备的配置文件 ./ifcfg-INTERFACE # 名为 INTERFACE 网络设备配置文件。通常情况下，INTERFACE 的值通常与配置文件中 DEVICE 指令的值相同。 ./route-INTERFACE # IPv4 静态路由配置文件。INTERFACE 为网络设备名称，该路由条目仅对名为 INTERFACE 的网络设备起作用 ./route6-INTERFACE # IPv6 静态路由配置文件。INTERFACE 为网络设备名称，该路由条目仅对名为 INTERFACE 的网络设备起作用 ./rule-INTERFACE # 定义内核将流量路由到特定路由表的 IPv4 源网络规则。 ./rule6-INTERFACE # 定义内核将流量路由到特定路由表的 IPv6 源网络规则。 ./networking/* # 注意：在 RedHat 6 文档中表示，/etc/sysconfig/networking/ 目录由现在已经弃用的网络管理工具(system-config-network) 管理，这个内容不应该手动编辑。推荐使用 NetworkManager。并且在后续的版本中， NetworkManager 也接管了这些文件 /etc/iproute2/rt_tables # 如果您想要使用名称而不是数字来引用特定的路由表，这个文件会定义映射映射。</description></item><item><title>systemd-networkd</title><link>https://desistdaydream.github.io/docs/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Kernel/Network/Linux-%E7%BD%91%E7%BB%9C%E6%A0%88%E7%AE%A1%E7%90%86/systemd-networkd/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Kernel/Network/Linux-%E7%BD%91%E7%BB%9C%E6%A0%88%E7%AE%A1%E7%90%86/systemd-networkd/</guid><description>概述 参考：
配置 /run/systemd/network/ # 读取网络设备配置的目录</description></item><item><title>数据包发送过程详解</title><link>https://desistdaydream.github.io/docs/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Kernel/Network/Linux-%E7%BD%91%E7%BB%9C%E6%A0%88%E7%AE%A1%E7%90%86/%E6%95%B0%E6%8D%AE%E5%8C%85%E5%8F%91%E9%80%81%E8%BF%87%E7%A8%8B%E8%AF%A6%E8%A7%A3/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Kernel/Network/Linux-%E7%BD%91%E7%BB%9C%E6%A0%88%E7%AE%A1%E7%90%86/%E6%95%B0%E6%8D%AE%E5%8C%85%E5%8F%91%E9%80%81%E8%BF%87%E7%A8%8B%E8%AF%A6%E8%A7%A3/</guid><description>[译] Linux 网络栈监控和调优：发送数据（2017） Published at 2018-12-17 | Last Update 2020-09-29
译者序 本文翻译自 2017 年的一篇英文博客 Monitoring and Tuning the Linux Networking Stack: Sending Data。如果能看懂英文，建议阅读原文，或者和本文对照看。 这篇文章写的是 “Linux networking stack”，这里的 ”stack“ 不仅仅是内核协议栈， 而是包括内核协议栈在内的，从应用程序通过系统调用写数据到 socket，到数据被组织 成一个或多个数据包最终被物理网卡发出去的整个路径。所以文章有三方面，交织在一起， 看起来非常累（但是很过瘾）：
原理及代码实现：网络各层，包括驱动、硬中断、软中断、内核协议栈、socket 等等。 监控：对代码中的重要计数进行监控，一般在/proc 或/sys 下面有对应输出。 调优：修改网络配置参数。 本文的另一个特色是，几乎所有讨论的内核代码，都在相应的地方给出了 github 上的链接， 具体到行。 网络栈非常复杂，原文太长又没有任何章节号，看起来非常累。因此本文翻译时添加了适当 的章节号，以期按图索骥。
2020 更新:
基于 Prometheus+Grafana 监控网络栈：Monitoring Network Stack。 以下是翻译。
太长不读（TL; DR） 本文介绍了运行 Linux 内核的机器是如何发包（send packets）的，包是怎样从用户程 序一步步到达硬件网卡并被发出去的，以及如何监控（monitoring）和调优（ tuning）这一路径上的各个网络栈组件。 本文的姊妹篇是 Linux 网络栈监控和调优：接收数据， 对应的原文是 Monitoring and Tuning the Linux Networking Stack: Receiving Data 。</description></item><item><title>数据包接收过程详解</title><link>https://desistdaydream.github.io/docs/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Kernel/Network/Linux-%E7%BD%91%E7%BB%9C%E6%A0%88%E7%AE%A1%E7%90%86/%E6%95%B0%E6%8D%AE%E5%8C%85%E6%8E%A5%E6%94%B6%E8%BF%87%E7%A8%8B%E8%AF%A6%E8%A7%A3/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Kernel/Network/Linux-%E7%BD%91%E7%BB%9C%E6%A0%88%E7%AE%A1%E7%90%86/%E6%95%B0%E6%8D%AE%E5%8C%85%E6%8E%A5%E6%94%B6%E8%BF%87%E7%A8%8B%E8%AF%A6%E8%A7%A3/</guid><description>[译] Linux 网络栈监控和调优：接收数据（2016） Published at 2018-12-05 | Last Update 2020-03-29
译者序 本文翻译自 2016 年的一篇英文博客 Monitoring and Tuning the Linux Networking Stack: Receiving Data。如果能看懂英文，建议阅读原文，或者和本文对照看。 这篇文章写的是 “Linux networking stack”，这里的 ”stack“ 指的不仅仅是内核协议 栈，而是包括内核协议栈在内的、从数据包到达物理网卡到最终被用户态程序收起的整个路 径。所以文章有三方面，交织在一起，看起来非常累（但是很过瘾）：
原理及代码实现：网络各层，包括驱动、硬中断、软中断、内核协议栈、socket 等等 监控：对代码中的重要计数进行监控，一般在 /proc 或 /sys 下面有对应输出 调优：修改网络配置参数 本文的另一个特色是，几乎所有讨论的内核代码，都在相应的地方给出了 github 上的链接 ，具体到行。 网络栈非常复杂，原文太长又没有任何章节号，看起来非常累。因此本文翻译时添加了适当 的章节号，以期按图索骥。
2020 更新： 基于 Prometheus+Grafana 监控网络栈：Monitoring Network Stack。 以下是翻译。
太长不读（TL; DR） 本文介绍了 Linux 内核是如何收包（receive packets）的，包是怎样从网络栈到达用 户空间程序的，以及如何监控（monitoring）和调优（tuning）这一路径上的各个 网络栈组件。 这篇文章的姊妹篇 Monitoring and Tuning the Linux Networking Stack: Sending Data。 这篇文章的图文注释版 the Illustrated Guide to Monitoring and Tuning the Linux Networking Stack: Receiving Data。 想对 Linux 网络栈进行监控或调优，必须对它的行为（what exactly is happening）和原 理有深入的理解，而这是离不开读内核源码的。希望本文可以给那些正准备投身于此的人提 供一份参考。 特别鸣谢 特别感谢 Private Internet Access 的各位同 僚。公司雇佣我们做一些包括本文主题在内的网络研究，并非常慷慨地允许我们将研究成果 以文章的形式发表。 本文基于在 Private Internet Access 时的研 究成果，最开始以 5 篇连载 的形式出现。</description></item></channel></rss>