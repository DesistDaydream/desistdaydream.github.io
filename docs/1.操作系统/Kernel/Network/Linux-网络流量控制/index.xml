<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Linux 网络流量控制 on 断念梦的站点</title><link>https://desistdaydream.github.io/docs/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Kernel/Network/Linux-%E7%BD%91%E7%BB%9C%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6/</link><description>Recent content in Linux 网络流量控制 on 断念梦的站点</description><generator>Hugo</generator><language>zh-cn</language><atom:link href="https://desistdaydream.github.io/docs/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Kernel/Network/Linux-%E7%BD%91%E7%BB%9C%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6/index.xml" rel="self" type="application/rss+xml"/><item><title>Linux 网络流量控制</title><link>https://desistdaydream.github.io/docs/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Kernel/Network/Linux-%E7%BD%91%E7%BB%9C%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6/Linux-%E7%BD%91%E7%BB%9C%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Kernel/Network/Linux-%E7%BD%91%E7%BB%9C%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6/Linux-%E7%BD%91%E7%BB%9C%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6/</guid><description>概述 参考：
Wiki, Network Traffic Control arthurchiao.art 的文章： 连接跟踪（conntrack）：原理、应用及 Linux 内核实现 [译] 《Linux 高级路由与流量控制手册（2012）》第九章：用 tc qdisc 管理 Linux 网络带宽 《Linux 高级路由与流量控制手册（2003）》 中文翻译 在计算机网络中，Traffic Control(流量控制，简称 TC) 系统可以让服务器，像路由器一样工作，这也是 SDN(软件定义网路) 中重要的组成部分。通过精准的流量控制，可以让服务器减少拥塞、延迟、数据包丢失；实现 NAT 功能、控制带宽、阻止入侵；等等等等。
Traffic Control(流量控制) 在不同的语境中有不同的含义，可以表示一整套完整功能的系统、也可以表示为一种处理网络数据包的行为
背景 众所周知，在互联网诞生之初都是各个高校和科研机构相互通讯，并没有网络流量控制方面的考虑和设计，TCP/IP 协议的原则是尽可能好地为所有数据流服务，不同的数据流之间是平等的。然而多年的实践表明，这种原则并不是最理想的，有些数据流应该得到特别的照顾， 比如，远程登录的交互数据流应该比数据下载有更高的优先级。
针对不同的数据流采取不同的策略，这种可能性是存在的。并且，随着研究的发展和深入， 人们已经提出了各种不同的管理模式。IETF 已经发布了几个标准， 如综合服务(Integrated Services)、区分服务(Diferentiated Services)等。其实，Linux 内核从 2 2 开始，就已经实现了相关的 Traffic Control(流量控制) 功能。
实际上，流量控制系统可以想象成 Message Queue(消息队列) 的功能。都是为了解决数据量瞬间太大导致处理不过来的问题。
Traffic Control 的实现 想要实现 Traffic Control(流量控制) 系统，通常需要以下功能中的一个或多个：
Queuing(队列) # 每个进出服务器的数据包，都排好队逐一处理。 Hook(钩子) # 也可以称为DataPath。用于拦截进出服务器的每个数据包，并对数据包进行处理。 每种实现流量控制的程序，在内核中添加的 Hook 的功能各不相同，Hook 的先后顺序也各不相同，甚至可以多个 Traffic Control 共存，然后在各自的 Hook 上处理数据包 Connection Tracking(连接跟踪) # 每个被拦截到的数据包，都需要记录其信息以跟踪他们。 通过对数据包进行 Queuing(排队)，我们可以决定数据的发送方式。我们只能对发送的数据进行整形。</description></item><item><title>Connnection Tracking(连接跟踪)</title><link>https://desistdaydream.github.io/docs/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Kernel/Network/Linux-%E7%BD%91%E7%BB%9C%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6/Connnection-Tracking%E8%BF%9E%E6%8E%A5%E8%B7%9F%E8%B8%AA/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Kernel/Network/Linux-%E7%BD%91%E7%BB%9C%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6/Connnection-Tracking%E8%BF%9E%E6%8E%A5%E8%B7%9F%E8%B8%AA/</guid><description>概述 参考：
arthurchiao，连接跟踪：原理、应用及 Linux 内核实现 Connection Tracking(连接跟踪系统，简称 ConnTrack、CT)，用于跟踪并且记录连接状态。CT 是 Linux 网络流量控制的基础
例如，上图是一台 IP 地址为 10.1.1.2 的 Linux 机器，我们能看到这台机器上有三条 连接：
机器访问外部 HTTP 服务的连接（目的端口 80） 外部访问机器内 FTP 服务的连接（目的端口 21） 机器访问外部 DNS 服务的连接（目的端口 53） 连接跟踪所做的事情就是发现并跟踪这些连接的状态，具体包括：
从数据包中提取元组（tuple）信息，辨别数据流（flow）和对应的连接（connection） 为所有连接维护一个状态数据库（conntrack table），例如连接的创建时间、发送 包数、发送字节数等等 回收过期的连接（GC） 为更上层的功能（例如 NAT）提供服务 需要注意的是，连接跟踪中所说的“连接”，概念和 TCP/IP 协议中“面向连接”（ connection oriented）的“连接”并不完全相同，简单来说：
TCP/IP 协议中，连接是一个四层（Layer 4）的概念。 TCP 是有连接的，或称面向连接的（connection oriented），发送出去的包都要求对端应答（ACK），并且有重传机制 UDP 是无连接的，发送的包无需对端应答，也没有重传机制 CT 中，一个元组（tuple）定义的一条数据流（flow ）就表示一条连接（connection）。 后面会看到 UDP 甚至是 ICMP 这种三层协议在 CT 中也都是有连接记录的 但不是所有协议都会被连接跟踪 本文中用到“连接”一词时，大部分情况下指的都是后者，即“连接跟踪”中的“连接”。
原理 要跟踪一台机器的所有连接状态，就需要：
拦截（或称过滤）流经这台机器的每一个数据包，并进行分析。 根据这些信息建立起这台机器上的连接信息数据库（conntrack table）。 根据拦截到的包信息，不断更新数据库 例如</description></item></channel></rss>