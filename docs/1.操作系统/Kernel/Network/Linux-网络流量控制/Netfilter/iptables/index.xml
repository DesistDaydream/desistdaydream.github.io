<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>iptables on 断念梦的站点</title><link>https://desistdaydream.github.io/docs/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Kernel/Network/Linux-%E7%BD%91%E7%BB%9C%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6/Netfilter/iptables/</link><description>Recent content in iptables on 断念梦的站点</description><generator>Hugo</generator><language>zh-cn</language><atom:link href="https://desistdaydream.github.io/docs/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Kernel/Network/Linux-%E7%BD%91%E7%BB%9C%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6/Netfilter/iptables/index.xml" rel="self" type="application/rss+xml"/><item><title>iptables</title><link>https://desistdaydream.github.io/docs/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Kernel/Network/Linux-%E7%BD%91%E7%BB%9C%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6/Netfilter/iptables/iptables/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Kernel/Network/Linux-%E7%BD%91%E7%BB%9C%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6/Netfilter/iptables/iptables/</guid><description>概述 参考：
Manual(手册)，iptables(8) Netfilter 官方文档，iptables 教程 https://www.zsythink.net/archives/1199 iptables 是 Netfilter 团队开发的一组用于与 netfilter 模块进行交互的 CLI 工具，其中包括 iptables、ip6tables、arptables、ebtables 等。
iptables 和 ip6tables 用于建立、维护和检查 Linux 内核中的 IPv4 和 IPv6 包过滤规则表。可以定义几个不同的表中的各种规则，也可以定义用户定义的链。并把已经定义的规则发送给 netfilter 模块。
四表(Table) 注意：四表是 iptables 框架中的概念，不是 Netfilter 中的
iptables 框架将流量抽象分为 4 类：过滤类、网络地址转换类、拆解报文类、原始类。每种类型的链作用在 Netfilter 系统中的 Hook 各不不相同，每种类型具有不同的功能。每一类都称为一张表。比如 fileter 表用来在指定链上检查流量是否可以通过，nat 表用来在指定链上检查流量是否可以进行地址转换，等等。Note：不是所有表都可以在所有链上具有规则，下表是 4 个表在 5 个 Hook 上的可用关系。
表名\链名 PREROUTING INPUT FORWARD OUTPUT POSTROUTING filter 可用 可用 可用 nat 可用 可用 可用 可用 mangle 可用 可用 可用 可用 可用 raw 可用 可用 iptables 中有默认的内置 4 个表，每个表的名称就是其 chain 类型的名称</description></item><item><title>iptables 命令行工具</title><link>https://desistdaydream.github.io/docs/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Kernel/Network/Linux-%E7%BD%91%E7%BB%9C%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6/Netfilter/iptables/iptables-%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%B7%A5%E5%85%B7/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Kernel/Network/Linux-%E7%BD%91%E7%BB%9C%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6/Netfilter/iptables/iptables-%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%B7%A5%E5%85%B7/</guid><description>概述 参考：
Manual(手册)，iptables(8) Manual(手册)，iptables-extensions(8) Man 手册中，将 iptables 分为两部分，基本的 iptables 和用于描述扩展规则的 iptables-extensions，当使用扩展规则时，需要通过 -m, --match ModuleName 选项指定要使用的扩展模块的名称。
另外，所谓的扩展规则，其实是对原始 iptables 的扩展，并不仅仅扩展了匹配数据包的规则，还有很多其他的功能。
Syntax(语法) iptables [OPTIONS] COMMAND [CHAIN] [RuleSpecifitcation]
Command # 指定要执行的具体操作。比如 增删改查规则/链 等等。 CHAIN # 指定要执行操作的链。在不指定的时候，默认对所有链进行操作。 CHAIN 其实不应该放在这，一般都是 COMMAND 中的组成部分。 RuleSpecifitcation = MATCHES TARGET # 通常用在增加规则时，指定规则的具体规范。由两部分组成：[MATCHES&amp;hellip;] 和 [TARGET] MATCHES = [基本匹配规则] [扩展匹配规则] # 匹配条件，可以指定多个。用以筛选出要执行 TARGET 的数据包的条件 TARGET = -j TargetName [Per-Target-Options] # 指定匹配到规则的数据包的 Target(目标) 是什么。 OPTIONS -t, &amp;ndash;table TALBLE # 指定 iptables 命令要对 TABLE 这个表进行操作。默认值: filter。省略该选项时，表示默认对 filter 表进行操作。 -n, &amp;ndash;numeric # 所有输出以数字的形式展示。IP 地址、端口号等都以数字输出。默认情况下一般是显示主机名、网络名称、服务。 &amp;ndash;line-numbers # 显示每个 chain 中的行号 -v # 显示更详细的信息，vv 更详细，vvv 再详细一些 pkts # 报文数 bytes # 字节数 target # prot # in/out # 显示要限制的具体网卡，* 为所有 source/destination # COMMAND 增 -A, &amp;ndash;append &amp;lt;CHAIN&amp;gt; &amp;lt;RuleSpecification&amp;gt; # 在规则连末尾添加规则 -I, &amp;ndash;insert &amp;lt;CHAIN&amp;gt; [RuleNum] &amp;lt;RuleSpecification&amp;gt; # 在规则链开头添加规则，也可以指定添加到指定的规则号 -N, &amp;ndash;new-chain CHAIN # 创建名为 CHAIN 的自定义规则链 删 -F, &amp;ndash;flush [CHAIN [RuleNum]] # 删除所有 chain 下的所有规则，也可删除指定 chain 下的指定的规则 -D, &amp;ndash;delete &amp;lt;CHAIN&amp;gt; &amp;lt;RULE&amp;gt; # 删除一个 chain 中规则，RULE 可以是该 chain 中的行号，也可以是规则具体配置 -X, &amp;ndash;delete-chain [CHAIN] # 删除用户自定义的空的 chain 改 -P, &amp;ndash;policy &amp;lt;CHAIN&amp;gt; &amp;lt;TARGET&amp;gt; # 设置指定的规则链(CHAIN)的默认策略为指定目标(Targe) -E, &amp;ndash;rename-chain &amp;lt;OldChainName&amp;gt; &amp;lt;NewChainName&amp;gt; # 重命名自定义 chain，引用计数不为 0 的自定义 chain，无法改名也无法删除 -R, &amp;ndash;replace CHAIN [RuleNum] &amp;lt;RuleSpecification&amp;gt; # 替换指定链上的指定规则 查 -L, &amp;ndash;list [CHAIN [RuleNum]] # 列出指定 CHAIN 的规则。默认值: 不指定。i.</description></item><item><title>最佳实践</title><link>https://desistdaydream.github.io/docs/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Kernel/Network/Linux-%E7%BD%91%E7%BB%9C%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6/Netfilter/iptables/%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Kernel/Network/Linux-%E7%BD%91%E7%BB%9C%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6/Netfilter/iptables/%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/</guid><description>概述 参考：
让服务器成为路由器 这里假设想作为路由器的服务器的 IP 为 172.38.180.211
一、首先需要保证路由器具有 IP 转发能力，开启 IP 转发
echo 1 &amp;gt; /proc/sys/net/ipv4/ip_forward 二、保证路由器在收到局域网内其他设备的数据包时，将收到的 IP SNAT 为本机 IP。这有两种方法
方法一：手动 SNAT
export LOCAL_IP=&amp;#34;172.38.180.211&amp;#34; export LAN_CIDR=&amp;#34;172.38.180.0/24&amp;#34; iptables -t nat -A POSTROUTING -s ${LAN_CIDR} ! -d ${LAN_CIDR} -j SNAT --to-source ${LOCAL_IP} 如果 LOCAL_IP 直接就是公网 IP 的话，也就是这台服务器本身就有公网 IP 的话，那就更完美了。
方法二：自动 SNAT
iptables -t nat -A POSTROUTING -o eth0 -j MASQUERADE 这条命令表示将 eth0 接口的出站流量进行伪装，i.e. 使用 eth0 接口的 IP 地址作为源地址。这样，内网的主机就可以通过本服务器访问外网了。
三、将内网服务器的网关设为这台服务器即可
我可以 ping 别人，别人不能 ping 我 iptables -A INPUT -p icmp &amp;ndash;icmp-type 8 -s 0/0 -j DROP # 默认 INPUT 链的策略为 ACCEPT 的时候用 iptables -A INPUT -p icmp &amp;ndash;icmp-type 0 -s 0/0 -j ACCEPT # 默认 INPUT 链的策略为 DROP 的时候用 iptables -A OUTPUT -p icmp &amp;ndash;icmp-type 0 -s LOCALIP -j DROP # 默认 OUTPUT 链的策略为 ACCEPT 的时候用，注意把 Localip 改为本机 IP iptables -A OUTPUT -p icmp &amp;ndash;icmp-type 8 -s LOCALIP -j ACCEPT # 默认 OUTPUT 链的策略为 DROP 的时候用，注意把 Localip 改为本机 IP 其他 屏蔽 HTTP 服务 Flood×××，有时会有用户在某个服务，例如 HTTP 80 上发起大量连接请求，此时我们可以启用如下规则：</description></item><item><title>iptables 源码解析</title><link>https://desistdaydream.github.io/docs/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Kernel/Network/Linux-%E7%BD%91%E7%BB%9C%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6/Netfilter/iptables/iptables-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Kernel/Network/Linux-%E7%BD%91%E7%BB%9C%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6/Netfilter/iptables/iptables-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/</guid><description>原文链接：https://mp.weixin.qq.com/s/O084fYzUFk7jAzJ2DDeADg
大家好，我是飞哥！
现在 iptables 这个工具的应用似乎是越来越广了。不仅仅是在传统的防火墙、NAT 等功能出现，在今天流行的的 Docker、Kubernets、Istio 项目中也经常能见着对它的身影。正因为如此，所以深入理解 iptables 工作原理是非常有价值的事情。
Linux 内核网络栈是一个纯内核态的东西，和用户层功能是天然隔离。但为了迎合各种各样用户层不同的需求，内核开放了一些口子出来供用户干预。使得用户层可以通过一些配置，改变内核的工作方式，从而实现特殊的需求。
Linux 在内核网络组件中很多关键位置布置了 netfilter 过滤器。Iptables 就是基于 netfilter 来实现的。所以本文中 iptables 和 netfilter 这两个名词有时候就混着用了。
飞哥也在网上看过很多关于 netfilter 技术文章，但是我觉得都写的不够清晰。所以咱们撸起袖子，自己写一篇。Netfilter 的实现可以简单地归纳为四表五链。我们来详细看看四表、五链究竟是啥意思。
一、Iptables 中的五链 Linux 下的 netfilter 在内核协议栈的各个重要关卡埋下了五个钩子。每一个钩子都对应是一系列规则，以链表的形式存在，所以俗称五链。当网络包在协议栈中流转到这些关卡的时候，就会依次执行在这些钩子上注册的各种规则，进而实现对网络包的各种处理。
要想把五链理解好，飞哥认为最关键是要把内核接收、发送、转发三个过程分开来看。
1.1 接收过程 Linux 在网络包接收在 IP 层的入口函数是 ip_rcv。网络在这里包碰到的第一个 HOOK 就是 PREROUTING。当该钩子上的规则都处理完后，会进行路由选择。如果发现是本设备的网络包，进入 ip_local_deliver 中，在这里又会遇到 INPUT 钩子。
我们来看下详细的代码，先看 ip_rcv。
`//file: net/ipv4/ip_input.c
int ip_rcv(struct sk_buff *skb, &amp;hellip;&amp;hellip;){
&amp;hellip;&amp;hellip;
return NF_HOOK(NFPROTO_IPV4, NF_INET_PRE_ROUTING, skb, dev, NULL,
ip_rcv_finish);
}
`
NF_HOOK 这个函数会执行到 iptables 中 pre_routing 里的各种表注册的各种规则。当处理完后，进入 ip_rcv_finish。在这里函数里将进行路由选择。这也就是 PREROUTING 这一链名字得来的原因，因为是在路由前执行的。</description></item></channel></rss>