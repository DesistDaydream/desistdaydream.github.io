<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>断念梦的站点 – BPF</title><link>https://desistdaydream.github.io/docs/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Kernel/BPF/</link><description>Recent content in BPF on 断念梦的站点</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><atom:link href="https://desistdaydream.github.io/docs/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Kernel/BPF/index.xml" rel="self" type="application/rss+xml"/><item><title>Docs: BPF</title><link>https://desistdaydream.github.io/docs/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Kernel/BPF/BPF/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Kernel/BPF/BPF/</guid><description>
&lt;h1 id="概述">概述&lt;a class="td-heading-self-link" href="#%e6%a6%82%e8%bf%b0" aria-label="Heading self-link">&lt;/a>&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Berkeley_Packet_Filter">Wiki，BPF&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://github.com/iovisor/bcc/blob/master/docs/kernel-versions.md">GitHub 项目,bcc-BPF 特性与 LInux 内核版本对照表&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>《Linux 内核观测技术 BPF》&lt;/p>
&lt;p>&lt;strong>Berkeley Packet Filter(伯克利包过滤器，简称 BPF)&lt;/strong>，是类 Unix 系统上数据链路层的一种原始接口，提供原始链路层封包的收发。在 Kernel 官方文档中，BPF 也称为 &lt;strong>Linux Socket Filtering(LInux 套接字过滤，简称 LSF)&lt;/strong>。BPF 有时也只表示 &lt;strong>filtering mechanism(过滤机制)&lt;/strong>，而不是整个接口。&lt;/p>
&lt;p>&lt;strong>注意：不管是后面描述的 eBPF 还是 BPF，这个名字或缩写，其本身所表达的含义，其实已经没有太大的意义了，因为这个项目的发展远远超出了它最初的构想。&lt;/strong>&lt;/p>
&lt;p>在 BPF 之前，如果想做数据包过滤，则必须将所有数据包复制到用户空间中，然后在那里过滤它们，这种方式意味着必须将所有数据包复制到用户空间中，复制数据的开销很大。当然可以通过将过滤逻辑转移到内核中解决开销问题，我们来看 BPF 做了什么工作。&lt;/p>
&lt;p>实际上，BPF 最早称为 &lt;strong>BSD Packet Filter&lt;/strong>，是很早就有的 Unix 内核特性，最早可追溯到 1992 年发表在 USENIX Conference 上的一篇论文&lt;a href="http://www.tcpdump.org/papers/bpf-usenix93.pdf">《BSD 数据包过滤：一种新的用户级包捕获架构》&lt;/a>，这篇文章作者描述了他们如何在 Unix 内核实现网络数据包过滤，这种技术比当时最先进的数据包过滤技术快了 20 倍。这篇文章描述的 BPF 在数据包过滤上引入了两大革新：&lt;/p>
&lt;ul>
&lt;li>一个新的虚拟机设计，可以有效得工作在基于寄存器结构的 CPU 之上。&lt;/li>
&lt;li>应用程序使用缓存只复制与过滤数据包相关的数据，不会复制数据包的宿友信息。这样可以最大程度得减少 BPF 处理的数据。&lt;/li>
&lt;/ul>
&lt;p>随后，得益于如此强大的性能优势，所有 Unix 系统都将 BPF 作为网络包过滤的首选技术，抛弃了消耗更多内存和性能更差的原有技术实现。后来由于 BPF 的理念逐渐成为主流，为各大操作系统所接受，这样早期 &amp;ldquo;B&amp;rdquo; 所代表的 BSD 便渐渐淡去，最终演化成了今天我们眼中的 BPF(Berkeley Packet Filter)。&lt;/p>
&lt;p>比如我们熟知的 Tcpdump 程序，其底层就是依赖 BPF 实现的包过滤。我们可以在命令后面增加 ”-d“ 来查看 tcpdump 过滤条件的底层汇编指令。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>~&lt;span style="color:#ce5c00;font-weight:bold">]&lt;/span>&lt;span style="color:#8f5902;font-style:italic"># tcpdump -d &amp;#39;ip and tcp port 8080&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ce5c00;font-weight:bold">(&lt;/span>000&lt;span style="color:#ce5c00;font-weight:bold">)&lt;/span> ldh &lt;span style="color:#ce5c00;font-weight:bold">[&lt;/span>12&lt;span style="color:#ce5c00;font-weight:bold">]&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ce5c00;font-weight:bold">(&lt;/span>001&lt;span style="color:#ce5c00;font-weight:bold">)&lt;/span> jeq &lt;span style="color:#8f5902;font-style:italic">#0x800 jt 2 jf 12&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ce5c00;font-weight:bold">(&lt;/span>002&lt;span style="color:#ce5c00;font-weight:bold">)&lt;/span> ldb &lt;span style="color:#ce5c00;font-weight:bold">[&lt;/span>23&lt;span style="color:#ce5c00;font-weight:bold">]&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ce5c00;font-weight:bold">(&lt;/span>003&lt;span style="color:#ce5c00;font-weight:bold">)&lt;/span> jeq &lt;span style="color:#8f5902;font-style:italic">#0x6 jt 4 jf 12&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ce5c00;font-weight:bold">(&lt;/span>004&lt;span style="color:#ce5c00;font-weight:bold">)&lt;/span> ldh &lt;span style="color:#ce5c00;font-weight:bold">[&lt;/span>20&lt;span style="color:#ce5c00;font-weight:bold">]&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ce5c00;font-weight:bold">(&lt;/span>005&lt;span style="color:#ce5c00;font-weight:bold">)&lt;/span> jset &lt;span style="color:#8f5902;font-style:italic">#0x1fff jt 12 jf 6&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ce5c00;font-weight:bold">(&lt;/span>006&lt;span style="color:#ce5c00;font-weight:bold">)&lt;/span> ldxb 4*&lt;span style="color:#ce5c00;font-weight:bold">([&lt;/span>14&lt;span style="color:#ce5c00;font-weight:bold">]&lt;/span>&lt;span style="color:#000;font-weight:bold">&amp;amp;&lt;/span>0xf&lt;span style="color:#ce5c00;font-weight:bold">)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ce5c00;font-weight:bold">(&lt;/span>007&lt;span style="color:#ce5c00;font-weight:bold">)&lt;/span> ldh &lt;span style="color:#ce5c00;font-weight:bold">[&lt;/span>x + 14&lt;span style="color:#ce5c00;font-weight:bold">]&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ce5c00;font-weight:bold">(&lt;/span>008&lt;span style="color:#ce5c00;font-weight:bold">)&lt;/span> jeq &lt;span style="color:#8f5902;font-style:italic">#0x1f90 jt 11 jf 9&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ce5c00;font-weight:bold">(&lt;/span>009&lt;span style="color:#ce5c00;font-weight:bold">)&lt;/span> ldh &lt;span style="color:#ce5c00;font-weight:bold">[&lt;/span>x + 16&lt;span style="color:#ce5c00;font-weight:bold">]&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ce5c00;font-weight:bold">(&lt;/span>010&lt;span style="color:#ce5c00;font-weight:bold">)&lt;/span> jeq &lt;span style="color:#8f5902;font-style:italic">#0x1f90 jt 11 jf 12&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ce5c00;font-weight:bold">(&lt;/span>011&lt;span style="color:#ce5c00;font-weight:bold">)&lt;/span> ret &lt;span style="color:#8f5902;font-style:italic">#262144&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ce5c00;font-weight:bold">(&lt;/span>012&lt;span style="color:#ce5c00;font-weight:bold">)&lt;/span> ret &lt;span style="color:#8f5902;font-style:italic">#0&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>-dd 可以打印字节码&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>~&lt;span style="color:#ce5c00;font-weight:bold">]&lt;/span>&lt;span style="color:#8f5902;font-style:italic"># tcpdump -dd &amp;#39;ip and tcp port 8080&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ce5c00;font-weight:bold">{&lt;/span> 0x28, 0, 0, 0x0000000c &lt;span style="color:#ce5c00;font-weight:bold">}&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ce5c00;font-weight:bold">{&lt;/span> 0x15, 0, 10, 0x00000800 &lt;span style="color:#ce5c00;font-weight:bold">}&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ce5c00;font-weight:bold">{&lt;/span> 0x30, 0, 0, 0x00000017 &lt;span style="color:#ce5c00;font-weight:bold">}&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ce5c00;font-weight:bold">{&lt;/span> 0x15, 0, 8, 0x00000006 &lt;span style="color:#ce5c00;font-weight:bold">}&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ce5c00;font-weight:bold">{&lt;/span> 0x28, 0, 0, 0x00000014 &lt;span style="color:#ce5c00;font-weight:bold">}&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ce5c00;font-weight:bold">{&lt;/span> 0x45, 6, 0, 0x00001fff &lt;span style="color:#ce5c00;font-weight:bold">}&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ce5c00;font-weight:bold">{&lt;/span> 0xb1, 0, 0, 0x0000000e &lt;span style="color:#ce5c00;font-weight:bold">}&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ce5c00;font-weight:bold">{&lt;/span> 0x48, 0, 0, 0x0000000e &lt;span style="color:#ce5c00;font-weight:bold">}&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ce5c00;font-weight:bold">{&lt;/span> 0x15, 2, 0, 0x00001f90 &lt;span style="color:#ce5c00;font-weight:bold">}&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ce5c00;font-weight:bold">{&lt;/span> 0x48, 0, 0, 0x00000010 &lt;span style="color:#ce5c00;font-weight:bold">}&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ce5c00;font-weight:bold">{&lt;/span> 0x15, 0, 1, 0x00001f90 &lt;span style="color:#ce5c00;font-weight:bold">}&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ce5c00;font-weight:bold">{&lt;/span> 0x6, 0, 0, 0x00040000 &lt;span style="color:#ce5c00;font-weight:bold">}&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ce5c00;font-weight:bold">{&lt;/span> 0x6, 0, 0, 0x00000000 &lt;span style="color:#ce5c00;font-weight:bold">}&lt;/span>,
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="bpf-的进化">BPF 的进化&lt;a class="td-heading-self-link" href="#bpf-%e7%9a%84%e8%bf%9b%e5%8c%96" aria-label="Heading self-link">&lt;/a>&lt;/h2>
&lt;p>得益于 BPF 在包过滤上的良好表现，Alexei Starovoitov 对 BPF 进行彻底的改造，并增加了新的功能，改善了它的性能，这个新版本被命名为 &lt;strong>extended BPF(扩展的 BPF，简称 eBPF)&lt;/strong>，新版本的 BPF 全面兼容并扩充了原有 BPF 的功能。因此，将传统的 BPF 重命名为 &lt;strong>classical BPF(传统的 BPF，简称 cBPF)&lt;/strong>，相对应的，新版本的 BPF 则命名为 eBPF 或直接称为 BPF(&lt;strong>所以，我们现在所说的 BPF，大部分情况下就是指 eBPF&lt;/strong>)。Linux Kernel 3.18 版本开始实现对 eBPF 的支持。&lt;/p>
&lt;h1 id="ebpf-概述">eBPF 概述&lt;a class="td-heading-self-link" href="#ebpf-%e6%a6%82%e8%bf%b0" aria-label="Heading self-link">&lt;/a>&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://ebpf.io/">eBPF 官网&lt;/a>&lt;/li>
&lt;li>&lt;a href="http://kerneltravel.net/categories/ebpf/">某网站系列文章&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>&lt;strong>extended Berkeley Packet Filter(扩展的 BPF，简称 eBPF)&lt;/strong> 起源于 BPF，是对 BPF 的扩展。eBPF 针对现代硬件进行了优化和全新的设计，使其生成的指令集比 cBPF 解释器生成的机器码更快。这个扩展版本还将 cBPF VM 中的寄存器数量从两个 32 位寄存器增加到 10 个 64 位寄存器。寄存器数量和寄存器宽度的增加为编写更复杂的程序提供了可能性，开发人员可以自由的使用函数参数交换更多的信息。这些改进使得 eBPF 比原来的 cBPF 快四倍。这些改进，主要还是对网络过滤器内部处理的 eBPF 指令集进行优化，仍然被限制在内核空间中，只有少数用户空间中的程序可以编写 BPF 过滤器供内核处理，比如 Tcpdump 和 Seccomp。&lt;/p>
&lt;p>除了上述的优化之外，eBPF 最让人兴奋的改进，是其向用户空间的开放。开发者可以在用户空间，编写 eBPF 程序，并将其加在到内核空间执行。虽然 eBPF 程序看起来更像内核模块，但与内核模块不同的是，eBPF 程序不需要开发者重新编译内核，而且保证了在内核不崩溃的情况下完成加载操作，着重强调了安全性和稳定性。BPF 代码的主要贡献单位主要包括 Cilium、Facebook、Red Hat 以及 Netronome 等。&lt;/p>
&lt;p>Linux Kernel 一直是实现 可观察性、网络、安全性 的理想场所。不幸的是，想要自定义这些实现通常是不切实际的，因为它需要更改内核源代码或加载内核模块，并导致彼此堆叠的抽象层。而 eBPF 的出现，让这一切成为可能，&lt;strong>eBPF 可以在 Linux 内核中运行沙盒程序，而无需更改内核源代码或加载内核模块&lt;/strong>。通过&lt;strong>使 Linux Kernel 可编程&lt;/strong>，基础架构软件可以利用现有的层，从而使它们更加智能和功能丰富，而无需继续为系统增加额外的复杂性层。&lt;/p>
&lt;p>也正由于此，eBPF 不再局限于网络的过滤，而且 eBPF 就相当于内核本身的代码，想象空间无限，并且热加载到内核，换句话说，一旦加载到内核，内核的行为就变了。所以，eBPF 带动了 安全性、应用程序配置/跟踪、性能故障排除 等等领域的新一代工具的开发，这些工具不再依赖现有的内核功能，而是在不影响执行效率或安全性的情况下主动重新编程运行时行为：&lt;/p>
&lt;ul>
&lt;li>&lt;strong>Networking(网络)&lt;/strong>&lt;/li>
&lt;li>&lt;strong>Observability(可观测性)&lt;/strong>
&lt;ul>
&lt;li>&lt;strong>Monitoring(监控)&lt;/strong>&lt;/li>
&lt;li>&lt;strong>Tracing(跟踪)&lt;/strong>&lt;/li>
&lt;li>&lt;strong>Profiling(分析)&lt;/strong>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>Security(安全)&lt;/strong>&lt;/li>
&lt;li>&lt;strong>等等，随着发展，eBPF 还可以实现更多!&lt;/strong>&lt;/li>
&lt;/ul>
&lt;p>可以这么说，BPF 的种种能力，实现了 &lt;strong>Software Define Kernel(软件定义内核)&lt;/strong>。&lt;/p>
&lt;h2 id="ebpf-与-内核模块-的对比">eBPF 与 内核模块 的对比&lt;a class="td-heading-self-link" href="#ebpf-%e4%b8%8e-%e5%86%85%e6%a0%b8%e6%a8%a1%e5%9d%97-%e7%9a%84%e5%af%b9%e6%af%94" aria-label="Heading self-link">&lt;/a>&lt;/h2>
&lt;p>在 Linux 观测方面，eBPF 总是会拿来与 kernel 模块方式进行对比，eBPF 在安全性、入门门槛上比内核模块都有优势，这两点在观测场景下对于用户来讲尤其重要。&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>维度&lt;/th>
&lt;th>Linux 内核模块&lt;/th>
&lt;th>eBPF&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>kprobes/tracepoints&lt;/td>
&lt;td>支持&lt;/td>
&lt;td>支持&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>安全性&lt;/td>
&lt;td>可能引入安全漏洞或导致内核 Panic&lt;/td>
&lt;td>通过验证器进行检查，可以保障内核安全&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>内核函数&lt;/td>
&lt;td>可以调用内核函数&lt;/td>
&lt;td>只能通过 BPF Helper 函数调用&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>编译性&lt;/td>
&lt;td>需要编译内核&lt;/td>
&lt;td>不需要编译内核，引入头文件即可&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>运行&lt;/td>
&lt;td>基于相同内核运行&lt;/td>
&lt;td>基于稳定 ABI 的 BPF 程序可以编译一次，各处运行&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>与应用程序交互&lt;/td>
&lt;td>打印日志或文件&lt;/td>
&lt;td>通过 perf_event 或 map 结构&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>数据结构丰富性&lt;/td>
&lt;td>一般&lt;/td>
&lt;td>丰富&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>入门门槛&lt;/td>
&lt;td>高&lt;/td>
&lt;td>低&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>升级&lt;/td>
&lt;td>需要卸载和加载，可能导致处理流程中断&lt;/td>
&lt;td>原子替换升级，不会造成处理流程中断&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>内核内置&lt;/td>
&lt;td>视情况而定&lt;/td>
&lt;td>内核内置支持&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h1 id="ebpf-发展史">eBPF 发展史&lt;a class="td-heading-self-link" href="#ebpf-%e5%8f%91%e5%b1%95%e5%8f%b2" aria-label="Heading self-link">&lt;/a>&lt;/h1>
&lt;p>eBPF 是如何诞生的呢？我最初开始讲起。这里“最初”我指的是 2013 年之前。&lt;/p>
&lt;h2 id="2013">2013&lt;a class="td-heading-self-link" href="#2013" aria-label="Heading self-link">&lt;/a>&lt;/h2>
&lt;h3 id="传统的流量控制工具和系统">传统的流量控制工具和系统&lt;a class="td-heading-self-link" href="#%e4%bc%a0%e7%bb%9f%e7%9a%84%e6%b5%81%e9%87%8f%e6%8e%a7%e5%88%b6%e5%b7%a5%e5%85%b7%e5%92%8c%e7%b3%bb%e7%bb%9f" aria-label="Heading self-link">&lt;/a>&lt;/h3>
&lt;p>回顾一下当时的 “SDN” 蓝图。&lt;/p>
&lt;ol>
&lt;li>当时有 OpenvSwitch（OVS）、&lt;code>tc&lt;/code>（Traffic control），以及内核中的 Netfilter 子系 统（包括 &lt;code>iptables&lt;/code>、&lt;code>ipvs&lt;/code>、&lt;code>nftalbes&lt;/code> 工具），可以用这些工具对 datapath 进行“ 编程”：。&lt;/li>
&lt;li>BPF 当时用于 &lt;code>tcpdump&lt;/code>，&lt;strong>在内核中尽量前面的位置抓包&lt;/strong>，它不会 crash 内核；此 外，它还用于 seccomp，&lt;strong>对系统调用进行过滤&lt;/strong>（system call filtering），但当时 使用的非常受限，远不是今天我们已经在用的样子。&lt;/li>
&lt;li>此外就是前面提到的 feature creeping 问题，以及 &lt;strong>tc 和 netfilter 的代码重复问题，因为这两个子系统是竞争关系&lt;/strong>。&lt;/li>
&lt;li>&lt;strong>OVS 当时被认为是内核中最先进的数据平面&lt;/strong>，但它最大的问题是：与内核中其他网 络模块的集成不好【译者注 1】。此外，很多核心的内核开发者也比较抵触 OVS，觉得它很怪。&lt;/li>
&lt;/ol>
&lt;blockquote>
&lt;p>【译者注 1】例如，OVS 的 internal port、patch port 用 tcpdump 都是 &lt;a href="http://arthurchiao.art/blog/ovs-deep-dive-4-patch-port/">抓不到包的&lt;/a>，排障非常不方便。&lt;/p>
&lt;/blockquote>
&lt;h3 id="ebpf-与-传统流量控制-的区别">eBPF 与 传统流量控制 的区别&lt;a class="td-heading-self-link" href="#ebpf-%e4%b8%8e-%e4%bc%a0%e7%bb%9f%e6%b5%81%e9%87%8f%e6%8e%a7%e5%88%b6-%e7%9a%84%e5%8c%ba%e5%88%ab" aria-label="Heading self-link">&lt;/a>&lt;/h3>
&lt;p>对比 eBPF 和这些已经存在很多年的工具：&lt;/p>
&lt;ol>
&lt;li>tc、OVS、netfilter 可以对 datapath 进行“编程”：但前提是 datapath 知道你想做什 么（but only if the datapath knows what you want to do）。
&lt;ul>
&lt;li>只能利用这些工具或模块提供的既有功能。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>eBPF 能够让你&lt;strong>创建新的 datapath&lt;/strong>（eBPF lets you create the datapath instead）。&lt;/li>
&lt;/ol>
&lt;blockquote>
&lt;ul>
&lt;li>eBPF 就是内核本身的代码，想象空间无限，并且热加载到内核；换句话说，一旦加 载到内核，内核的行为就变了。&lt;/li>
&lt;li>在 eBPF 之前，改变内核行为这件事情，只能通过修改内核再重新编译，或者开发内 核模块才能实现。&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>译者注&lt;/p>
&lt;h3 id="ebpf第一个巨型patch">eBPF：第一个（巨型）patch&lt;a class="td-heading-self-link" href="#ebpf%e7%ac%ac%e4%b8%80%e4%b8%aa%e5%b7%a8%e5%9e%8bpatch" aria-label="Heading self-link">&lt;/a>&lt;/h3>
&lt;ul>
&lt;li>描述 eBPF 的 RFC 引起了广泛讨论，但普遍认为侵入性太强了（改动太大）。&lt;/li>
&lt;li>另外，当时 nftables (inspired by BPF) 正在上升期，它是一个与 eBPF 有点类似的 BPF 解释器，大家不想同时维护两个解释器。&lt;/li>
&lt;/ul>
&lt;p>最终这个 patch 被拒绝了。
被拒的另外一个原因是前面提到的，没有遵循“大改动小提交”原则，全部代码放到了一个 patch。Linus 会疯的。&lt;/p>
&lt;h2 id="2014">2014&lt;a class="td-heading-self-link" href="#2014" aria-label="Heading self-link">&lt;/a>&lt;/h2>
&lt;h3 id="第一个-ebpf-patch-合并到内核">第一个 eBPF patch 合并到内核&lt;a class="td-heading-self-link" href="#%e7%ac%ac%e4%b8%80%e4%b8%aa-ebpf-patch-%e5%90%88%e5%b9%b6%e5%88%b0%e5%86%85%e6%a0%b8" aria-label="Heading self-link">&lt;/a>&lt;/h3>
&lt;ul>
&lt;li>用一个&lt;strong>扩展（extended）指令集&lt;/strong>逐步、全面替换原来老的 BPF 解释器。&lt;/li>
&lt;li>&lt;strong>自动新老 BPF 转换&lt;/strong>：in-kernel translation。&lt;/li>
&lt;li>后续 patch 将 eBPF 暴露给 UAPI，并添加了 verifier 代码和 JIT 代码。&lt;/li>
&lt;li>更多后续 patch，从核心代码中移除老的 BPF。&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/ksq56w/1617847999424-2c5e5133-2862-4574-bffb-0776c6b0aa4b.png" alt="">&lt;/p>
&lt;p>我们也从那时开始，顺理成章地成为了 eBPF 的 maintainer。&lt;/p>
&lt;h3 id="kubernetes-提交第一个-commit">Kubernetes 提交第一个 commit&lt;a class="td-heading-self-link" href="#kubernetes-%e6%8f%90%e4%ba%a4%e7%ac%ac%e4%b8%80%e4%b8%aa-commit" aria-label="Heading self-link">&lt;/a>&lt;/h3>
&lt;p>巧合的是，&lt;strong>对后来影响深远的 Kubernetes，也在这一年提交了第一个 commit&lt;/strong>：&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/ksq56w/1617847999414-121919ac-67f3-4841-b2a0-c0bd1668c7bd.png" alt="">&lt;/p>
&lt;h2 id="2015">2015&lt;a class="td-heading-self-link" href="#2015" aria-label="Heading self-link">&lt;/a>&lt;/h2>
&lt;h3 id="ebpf-分成两个方向networking--tracing">eBPF 分成两个方向：networking &amp;amp; tracing&lt;a class="td-heading-self-link" href="#ebpf-%e5%88%86%e6%88%90%e4%b8%a4%e4%b8%aa%e6%96%b9%e5%90%91networking--tracing" aria-label="Heading self-link">&lt;/a>&lt;/h3>
&lt;p>到了 2015 年，eBPF 开发分成了两个方向：&lt;/p>
&lt;ul>
&lt;li>networking&lt;/li>
&lt;li>tracing&lt;/li>
&lt;/ul>
&lt;h3 id="ebpf-backend-合并到-llvm-37">eBPF backend 合并到 LLVM 3.7&lt;a class="td-heading-self-link" href="#ebpf-backend-%e5%90%88%e5%b9%b6%e5%88%b0-llvm-37" aria-label="Heading self-link">&lt;/a>&lt;/h3>
&lt;p>这一年的一个重要里程碑是 eBPF backend 合并到了 upstream LLVM 编译器套件，因此你 现在才能用 clang 编译 eBPF 代码。&lt;/p>
&lt;h3 id="支持将-ebpf-attach-到-kprobes">支持将 eBPF attach 到 kprobes&lt;a class="td-heading-self-link" href="#%e6%94%af%e6%8c%81%e5%b0%86-ebpf-attach-%e5%88%b0-kprobes" aria-label="Heading self-link">&lt;/a>&lt;/h3>
&lt;p>这是 tracing 的第一个使用案例。
Alexei 主要负责 tracing 部分，他添加了一个 patch，支持加载 eBPF 用来做 tracing， 能获取系统的观测数据。&lt;/p>
&lt;h3 id="通过-cls_bpftc-变得完全可编程">通过 cls_bpf，tc 变得完全可编程&lt;a class="td-heading-self-link" href="#%e9%80%9a%e8%bf%87-cls_bpftc-%e5%8f%98%e5%be%97%e5%ae%8c%e5%85%a8%e5%8f%af%e7%bc%96%e7%a8%8b" aria-label="Heading self-link">&lt;/a>&lt;/h3>
&lt;p>我主要负责 networking 部分，使 tc 子系统可编程，这样我们就能用 eBPF 来灵活的对 datapath 进行编程，获得一个高性能 datapath。&lt;/p>
&lt;h3 id="为-tc-添加了一个-lockless-ingress--egress-hook-点">为 tc 添加了一个 lockless ingress &amp;amp; egress hook 点&lt;a class="td-heading-self-link" href="#%e4%b8%ba-tc-%e6%b7%bb%e5%8a%a0%e4%ba%86%e4%b8%80%e4%b8%aa-lockless-ingress--egress-hook-%e7%82%b9" aria-label="Heading self-link">&lt;/a>&lt;/h3>
&lt;blockquote>
&lt;p>译注：可参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="http://arthurchiao.art/blog/understanding-tc-da-mode-zh/">深入理解 tc ebpf 的 direct-action (da) 模式（2020）&lt;/a>&lt;/li>
&lt;li>&lt;a href="http://arthurchiao.art/blog/advanced-bpf-kernel-features-for-container-age-zh/">为容器时代设计的高级 eBPF 内核特性（FOSDEM, 2021）&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;h3 id="添加了很多-verifer-和-ebpf-辅助代码helper">添加了很多 verifer 和 eBPF 辅助代码（helper）&lt;a class="td-heading-self-link" href="#%e6%b7%bb%e5%8a%a0%e4%ba%86%e5%be%88%e5%a4%9a-verifer-%e5%92%8c-ebpf-%e8%be%85%e5%8a%a9%e4%bb%a3%e7%a0%81helper" aria-label="Heading self-link">&lt;/a>&lt;/h3>
&lt;p>使用更方便。&lt;/p>
&lt;h3 id="bcc-项目发布">bcc 项目发布&lt;a class="td-heading-self-link" href="#bcc-%e9%a1%b9%e7%9b%ae%e5%8f%91%e5%b8%83" aria-label="Heading self-link">&lt;/a>&lt;/h3>
&lt;p>作为 tracing frontend for eBPF。&lt;/p>
&lt;h2 id="2016">2016&lt;a class="td-heading-self-link" href="#2016" aria-label="Heading self-link">&lt;/a>&lt;/h2>
&lt;h3 id="ebpf-添加了一个新-fast-pathxdp">eBPF 添加了一个新 fast path：XDP&lt;a class="td-heading-self-link" href="#ebpf-%e6%b7%bb%e5%8a%a0%e4%ba%86%e4%b8%80%e4%b8%aa%e6%96%b0-fast-pathxdp" aria-label="Heading self-link">&lt;/a>&lt;/h3>
&lt;ul>
&lt;li>XDP 合并到内核，支持在驱动的 ingress 层 attach BPF 程序。&lt;/li>
&lt;li>nfp 最为第一家网卡及驱动，支持将 eBPF 程序 offload 到 cls_bpf &amp;amp; XDP hook 点。&lt;/li>
&lt;/ul>
&lt;h3 id="cilium-项目发布">Cilium 项目发布&lt;a class="td-heading-self-link" href="#cilium-%e9%a1%b9%e7%9b%ae%e5%8f%91%e5%b8%83" aria-label="Heading self-link">&lt;/a>&lt;/h3>
&lt;p>Cilium 最开始的目标是 &lt;strong>docker 网络解决方案&lt;/strong>。&lt;/p>
&lt;ul>
&lt;li>通过 eBPF 实现高效的 label-based policy、NAT64、tunnel mesh、容器连通性。&lt;/li>
&lt;li>整个 datapath &amp;amp; forwarding 逻辑全用 eBPF 实现，不再需要 Docker 或 OVS 桥接设备。&lt;/li>
&lt;/ul>
&lt;h2 id="2017">2017&lt;a class="td-heading-self-link" href="#2017" aria-label="Heading self-link">&lt;/a>&lt;/h2>
&lt;h3 id="ebpf-开始大规模应用于生产环境">eBPF 开始大规模应用于生产环境&lt;a class="td-heading-self-link" href="#ebpf-%e5%bc%80%e5%a7%8b%e5%a4%a7%e8%a7%84%e6%a8%a1%e5%ba%94%e7%94%a8%e4%ba%8e%e7%94%9f%e4%ba%a7%e7%8e%af%e5%a2%83" aria-label="Heading self-link">&lt;/a>&lt;/h3>
&lt;p>2016 ~ 2017 年，eBPF 开始应用于生产环境：&lt;/p>
&lt;ol>
&lt;li>Netflix on eBPF for tracing: ‘Linux BPF superpowers’&lt;/li>
&lt;li>Facebook 公布了生产环境 XDP+eBPF 使用案例（DDoS &amp;amp; LB）
&lt;ul>
&lt;li>用 XDP/eBPF 重写了原来基于 IPVS 的 L4LB，性能 &lt;code>10x&lt;/code>。&lt;/li>
&lt;li>&lt;strong>eBPF 经受住了严苛的考验&lt;/strong>：从 2017 开始，每个进入 facebook.com 的包，都是经过了 XDP &amp;amp; eBPF 处理的。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Cloudflare 将 XDP+BPF 集成到了它们的 DDoS mitigation 产品。
&lt;ul>
&lt;li>成功将其组件从基于 Netfilter 迁移到基于 eBPF。&lt;/li>
&lt;li>到 2018 年，它们的 XDP L4LB 完全接管生产环境。&lt;/li>
&lt;li>扩展阅读：&lt;a href="http://arthurchiao.art/blog/cloudflare-arch-and-bpf-zh/">(译) Cloudflare 边缘网络架构：无处不在的 BPF（2019）&lt;/a>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ol>
&lt;blockquote>
&lt;p>译者注：基于 XDP/eBPF 的 L4LB 原理都是类似的，简单来说，&lt;/p>
&lt;ol>
&lt;li>通过 BGP 宣告 VIP&lt;/li>
&lt;li>通过 ECMP 做物理链路高可用&lt;/li>
&lt;li>通过 XDP/eBPF 代码做重定向，将请求转发到后端（VIP -&amp;gt; Backend）&lt;/li>
&lt;/ol>
&lt;/blockquote>
&lt;p>对此感兴趣可参考入门级介绍：&lt;a href="http://arthurchiao.art/blog/k8s-l4lb/">L4LB for Kubernetes: Theory and Practice with Cilium+BGP+ECMP&lt;/a>&lt;/p>
&lt;h2 id="2017--2018">2017 ~ 2018&lt;a class="td-heading-self-link" href="#2017--2018" aria-label="Heading self-link">&lt;/a>&lt;/h2>
&lt;h3 id="ebpf-成为内核独立子系统">eBPF 成为内核独立子系统&lt;a class="td-heading-self-link" href="#ebpf-%e6%88%90%e4%b8%ba%e5%86%85%e6%a0%b8%e7%8b%ac%e7%ab%8b%e5%ad%90%e7%b3%bb%e7%bb%9f" aria-label="Heading self-link">&lt;/a>&lt;/h3>
&lt;p>随着 eBPF 社区的发展，feature 和 patch 越来越多，为了管理这些 patch，Alexei、我和 networking 的一位 maintainer David Miller 经过讨论，决定将 eBPF 作为独立的内核子 系统。&lt;/p>
&lt;ul>
&lt;li>eBPF patch 合并到 &lt;code>bpf&lt;/code> &amp;amp; &lt;code>bpf-next&lt;/code> kernel trees on git.kernel.org&lt;/li>
&lt;li>拆分 eBPF 邮件列表：&lt;code>bpf@vger.kernel.org&lt;/code> (archive at: &lt;code>lore.kernel.org/bpf/&lt;/code>)&lt;/li>
&lt;li>eBPF PR 经内核网络部分的 maintainer David S. Miller 提交给 Linus Torvalds&lt;/li>
&lt;/ul>
&lt;h3 id="ktls--ebpf">kTLS &amp;amp; eBPF&lt;a class="td-heading-self-link" href="#ktls--ebpf" aria-label="Heading self-link">&lt;/a>&lt;/h3>
&lt;blockquote>
&lt;p>kTLS &amp;amp; eBPF for introspection and ability for in-kernel TLS policy enforcement&lt;/p>
&lt;/blockquote>
&lt;p>kTLS 是&lt;strong>将 TLS 处理 offload 到内核&lt;/strong>，例如，将加解密过程从 openssl 下放到内核进 行，以&lt;strong>使得内核具备更强的可观测性&lt;/strong>（gain visibility）。
有了 kTLS，就可以用 eBPF 查看数据和状态，在内核应用安全策略。 &lt;strong>目前 openssl 已经完全原生支持这个功能&lt;/strong>。&lt;/p>
&lt;h3 id="bpftool--libbpf">bpftool &amp;amp; libbpf&lt;a class="td-heading-self-link" href="#bpftool--libbpf" aria-label="Heading self-link">&lt;/a>&lt;/h3>
&lt;p>为了检查内核内 eBPF 的状态（introspection）、查看内核加载了哪些 BPF 程序等， 我们添加了一个新工具 bpftool。现在这个工具已经功能非常强大了。
同样，为了方便用户空间应用使用 eBPF，我们提供了&lt;strong>用户空间 API&lt;/strong>（user space API for applications） &lt;code>libbpf&lt;/code>。这是一个 C 库，接管了所有加载工作，这样用户就不需要 自己处理复杂的加载过程了。&lt;/p>
&lt;h3 id="bpf-to-bpf-function-calls">BPF to BPF function calls&lt;a class="td-heading-self-link" href="#bpf-to-bpf-function-calls" aria-label="Heading self-link">&lt;/a>&lt;/h3>
&lt;p>增加了一个 BPF 函数调用另一个 BPF 函数的支持，使得 BPF 程序的编写更加灵活。&lt;/p>
&lt;h2 id="2018">2018&lt;a class="td-heading-self-link" href="#2018" aria-label="Heading self-link">&lt;/a>&lt;/h2>
&lt;h3 id="cilium-10-发布">Cilium 1.0 发布&lt;a class="td-heading-self-link" href="#cilium-10-%e5%8f%91%e5%b8%83" aria-label="Heading self-link">&lt;/a>&lt;/h3>
&lt;p>这标志着 &lt;strong>BPF 革命之火燃烧到了 Kubernetes networking &amp;amp; security 领域&lt;/strong>。
Cilium 此时支持的功能：&lt;/p>
&lt;ul>
&lt;li>K8s CNI&lt;/li>
&lt;li>Identity-based L3-L7 policy&lt;/li>
&lt;li>ClusterIP Services&lt;/li>
&lt;/ul>
&lt;h3 id="btfbyte-type-format">BTF（Byte Type Format）&lt;a class="td-heading-self-link" href="#btfbyte-type-format" aria-label="Heading self-link">&lt;/a>&lt;/h3>
&lt;p>内核添加了一个称为 BTF 的组件。这是一种元数据格式，和 DWARF 这样的 debugging data 类似。但 BTF 的 size 要小的多，而更重要的是，有史以来，&lt;strong>内核第一次变得可自 描述了&lt;/strong>（self-descriptive）。什么意思？
想象一下当前正在运行中的内核，它&lt;strong>内置了自己的数据格式&lt;/strong>（its own data format） 和&lt;strong>内部数据结构&lt;/strong>（internal structures），你能用工具来查看这些东西（you can introspect them）。还是不太懂？这么说吧，&lt;strong>BTF 是后来的 “一次编译、到处运行”、 热补丁（live-patching）、BPF global data 处理等等所有这些 BPF 特性的基础&lt;/strong>。
新的特性不断加入，它们都依赖 BTF 提供富元数据（rich metadata）这个基础。&lt;/p>
&lt;blockquote>
&lt;p>更多 BTF 内容，可参考 &lt;a href="http://arthurchiao.art/blog/cilium-bpf-xdp-reference-guide-zh/">(译) Cilium：BPF 和 XDP 参考指南（2019）&lt;/a>
译者注&lt;/p>
&lt;/blockquote>
&lt;h3 id="linux-plumbers-会议开辟-bpfxdp-主题">Linux Plumbers 会议开辟 BPF/XDP 主题&lt;a class="td-heading-self-link" href="#linux-plumbers-%e4%bc%9a%e8%ae%ae%e5%bc%80%e8%be%9f-bpfxdp-%e4%b8%bb%e9%a2%98" aria-label="Heading self-link">&lt;/a>&lt;/h3>
&lt;p>这一年，Linux Plumbers 会议第一次开辟了专门讨论 BPF/XDP 的微型分会，我们 一起组织这场会议。其中，Networking Track 一半以上的议题都涉及 BPF 和 XDP 主题，因为这是一个非常振奋人心的特性，越来越多的人用它来解决实际问题。&lt;/p>
&lt;h3 id="新-socket-类型af_xdp">新 socket 类型：AF_XDP&lt;a class="td-heading-self-link" href="#%e6%96%b0-socket-%e7%b1%bb%e5%9e%8baf_xdp" aria-label="Heading self-link">&lt;/a>&lt;/h3>
&lt;p>内核添加了一个&lt;strong>新 socket 类型&lt;/strong>&lt;code>**AF_XDP**&lt;/code>。它提供的能力是：&lt;strong>在零拷贝（ zero-copy）的前提下将包从网卡驱动送到用户空间&lt;/strong>。&lt;/p>
&lt;blockquote>
&lt;p>回忆前面的内容，数据包到达网卡后，先经过 XDP，然后才为这个包分配内存。 因此在 XDP 层直接将包送到用户态是无需拷贝的。
译者注&lt;/p>
&lt;/blockquote>
&lt;p>&lt;code>AF_XDP&lt;/code> 提供的能力与 DPDK 有点类似，不过&lt;/p>
&lt;ul>
&lt;li>DPDK 需要&lt;strong>重写网卡驱动&lt;/strong>，需要额外维护&lt;strong>用户空间的驱动代码&lt;/strong>。&lt;/li>
&lt;li>&lt;code>AF_XDP&lt;/code> 在&lt;strong>复用内核网卡驱动&lt;/strong>的情况下，能达到与 DPDK 一样的性能。&lt;/li>
&lt;/ul>
&lt;p>而且由于&lt;strong>复用了内核基础设施，所有的网络管理工具还都是可以用的&lt;/strong>，因此非常方便， 而 DPDK 这种 bypass 内核的方案导致绝大大部分现有工具都用不了了。
由于所有这些操作都是发生在 XDP 层的，因此它称为 &lt;code>AF_XDP&lt;/code>。插入到这里的 BPF 代码 能直接将包送到 socket。&lt;/p>
&lt;h3 id="bpffilter">bpffilter&lt;a class="td-heading-self-link" href="#bpffilter" aria-label="Heading self-link">&lt;/a>&lt;/h3>
&lt;p>开始了 bpffilter prototype，作用是通过用户空间驱动（userspace driver），&lt;strong>将 iptables 规则转换成 eBPF 代码&lt;/strong>。
这是将 iptables 转换成 eBPF 的第一次尝试，整个过程对用户都是无感知的，其中的某些 组件现在还在用，用于在其他方面扩展内核的功能。&lt;/p>
&lt;h2 id="2018--2019">2018 ~ 2019&lt;a class="td-heading-self-link" href="#2018--2019" aria-label="Heading self-link">&lt;/a>&lt;/h2>
&lt;h3 id="bpftrace">bpftrace&lt;a class="td-heading-self-link" href="#bpftrace" aria-label="Heading self-link">&lt;/a>&lt;/h3>
&lt;p>Brendan 发布了 bpftrace 工具，作为 DTrace 2.0 for Linux。&lt;/p>
&lt;h3 id="bpf-专著bpf-performance-tools">BPF 专著《BPF Performance Tools》&lt;a class="td-heading-self-link" href="#bpf-%e4%b8%93%e8%91%97bpf-performance-tools" aria-label="Heading self-link">&lt;/a>&lt;/h3>
&lt;p>Berendan 写了一本 800 多页的 BPF 书。&lt;/p>
&lt;h3 id="cilium-16-发布">Cilium 1.6 发布&lt;a class="td-heading-self-link" href="#cilium-16-%e5%8f%91%e5%b8%83" aria-label="Heading self-link">&lt;/a>&lt;/h3>
&lt;p>第一次支持完全干掉基于 iptables 的 kube-proxy，全部功能基于 eBPF。&lt;/p>
&lt;blockquote>
&lt;p>这个版本其实是有问题的，例如 1.6 发布之后我们发现 externalIPs 的实现是有问题 ，社区在后面的版本修复了这个问题。在修复之前，还是得用 kube-proxy： &lt;a href="https://github.com/cilium/cilium/issues/9285">https://github.com/cilium/cilium/issues/9285&lt;/a>
译者注&lt;/p>
&lt;/blockquote>
&lt;h3 id="bpf-live-patching">BPF live-patching&lt;a class="td-heading-self-link" href="#bpf-live-patching" aria-label="Heading self-link">&lt;/a>&lt;/h3>
&lt;p>添加了一些内核新特性，例如尾调用（tail call），这使得 &lt;strong>eBPF 核心基础 设施第一次实现了热加载&lt;/strong>。这个功能帮我们极大地优化了 datapath。
另一个重要功能是 BPF trampolines，这里就不展开了，感兴趣的可以搜索相关资料，我只 能说这是另一个振奋人心的技术。&lt;/p>
&lt;h3 id="第一次-bpfconf受邀请才能参加的-bpf-内核专家会议">第一次 bpfconf：受邀请才能参加的 BPF 内核专家会议&lt;a class="td-heading-self-link" href="#%e7%ac%ac%e4%b8%80%e6%ac%a1-bpfconf%e5%8f%97%e9%82%80%e8%af%b7%e6%89%8d%e8%83%bd%e5%8f%82%e5%8a%a0%e7%9a%84-bpf-%e5%86%85%e6%a0%b8%e4%b8%93%e5%ae%b6%e4%bc%9a%e8%ae%ae" aria-label="Heading self-link">&lt;/a>&lt;/h3>
&lt;p>如题，这是 BPF 内核专家交换想法和讨论问题的会议。与 Linux Plumbers 会议互补。&lt;/p>
&lt;h3 id="bpf-backend-合并到-gcc">BPF backend 合并到 GCC&lt;a class="td-heading-self-link" href="#bpf-backend-%e5%90%88%e5%b9%b6%e5%88%b0-gcc" aria-label="Heading self-link">&lt;/a>&lt;/h3>
&lt;p>前面提到，BPF backend 很早就合并到 LLVM/Clang，现在，它终于合并到 GCC 了。 至此，&lt;strong>GCC 和 LLVM 这两个最主要的编译器套件都支持了 BPF backend&lt;/strong>。
此外，BPF 开始支持有限循环（bounded loops），在此之前，是不支持循环的，以防止程 序无限执行。&lt;/p>
&lt;h2 id="2019--2020">2019 ~ 2020&lt;a class="td-heading-self-link" href="#2019--2020" aria-label="Heading self-link">&lt;/a>&lt;/h2>
&lt;h3 id="不知疲倦的增长和-ebpf-的第三个方向linux-security-modules">不知疲倦的增长和 eBPF 的第三个方向：Linux security modules&lt;a class="td-heading-self-link" href="#%e4%b8%8d%e7%9f%a5%e7%96%b2%e5%80%a6%e7%9a%84%e5%a2%9e%e9%95%bf%e5%92%8c-ebpf-%e7%9a%84%e7%ac%ac%e4%b8%89%e4%b8%aa%e6%96%b9%e5%90%91linux-security-modules" aria-label="Heading self-link">&lt;/a>&lt;/h3>
&lt;ul>
&lt;li>Google 贡献了 &lt;a href="https://www.kernel.org/doc/html/latest/bpf/bpf_lsm.html">BPF LSM&lt;/a>（安全），部署在了他们的数据中心服务器上。&lt;/li>
&lt;li>BPF verifier 防护 Spectre 漏洞（2018 年轰动世界的 CPU bug）：even verifying safety on speculative program paths。&lt;/li>
&lt;li>&lt;strong>主流云厂商开始通过 SRIOV 支持 XDP&lt;/strong>：AWS (ena driver), Azure (hv_netvsc driver), …&lt;/li>
&lt;li>Cilium 1.8 支持基于 XDP 的 Service 负载均衡和 host network policies。&lt;/li>
&lt;li>Facebook 开发了基于 BPF 的 TCP 拥塞控制模块。&lt;/li>
&lt;li>Microsoft 基于 BPF 重写了将他们的 Windows monitoring 工具。&lt;/li>
&lt;/ul></description></item><item><title>Docs: eBPF</title><link>https://desistdaydream.github.io/docs/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Kernel/BPF/eBPF/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Kernel/BPF/eBPF/</guid><description>
&lt;h1 id="概述">概述&lt;a class="td-heading-self-link" href="#%e6%a6%82%e8%bf%b0" aria-label="Heading self-link">&lt;/a>&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://ebpf.io/">官网&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.kernel.org/doc/html/latest/bpf/">Kernel 官方文档，BPF&lt;/a>
&lt;ul>
&lt;li>&lt;a href="https://www.infradead.org/~mchehab/kernel_docs/bpf/index.html">Kernel 官方文档&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://docs.cilium.io/en/latest/bpf/">Cilium 官方文档，BPF&lt;/a> Kernel 官方文档中指向的另一个文档&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;a href="https://github.com/torvalds/linux/tree/master/tools/lib/bpf">GitHub 项目，torvalds/linux/tools/lib/bpf&lt;/a>(libbpf 库)&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;h1 id="学习资料">学习资料&lt;a class="td-heading-self-link" href="#%e5%ad%a6%e4%b9%a0%e8%b5%84%e6%96%99" aria-label="Heading self-link">&lt;/a>&lt;/h1>
&lt;p>&lt;a href="http://arthurchiao.art/index.html">arthurchiao.art 的文章&lt;/a>：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="http://arthurchiao.art/blog/ebpf-and-k8s-zh/">[译] 大规模微服务利器：eBPF + Kubernetes（KubeCon, 2020）&lt;/a>&lt;/li>
&lt;/ul>
&lt;p>&lt;a href="https://mp.weixin.qq.com/mp/appmsgalbum?__biz=MzA3NzUzNTM4NA==&amp;amp;action=getalbum&amp;amp;album_id=1996568890906148869&amp;amp;scene=173&amp;amp;from_msgid=2649613575&amp;amp;from_itemidx=1&amp;amp;count=3&amp;amp;nolastread=1#wechat_redirect">公众号，深入浅出 BPF&lt;/a>&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://mp.weixin.qq.com/s/DK3Fv96m8dzKomSNGBznPw">eBPF 概述：第 1 部分：介绍&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://mp.weixin.qq.com/s/CWxRROFmP2E4iUCXy5FzWA">eBPF 概述：第 2 部分：机器和字节码&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://mp.weixin.qq.com/s/H61TdIKCF-soyazJmWItTg">eBPF 概述：第 3 部分：软件开发生态&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://mp.weixin.qq.com/s/7JGZHqn_sglGMWoRs4CcbQ">eBPF 概述：第 4 部分：在嵌入式系统运行&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://mp.weixin.qq.com/s/zgu68HrCltVt7A0xs3f-nQ">eBPF 概述：第 5 部分：跟踪用户进程&lt;/a>&lt;/li>
&lt;/ul>
&lt;p>&lt;a href="https://mp.weixin.qq.com/s/xs3ckWeCXKnE-lUoMQrUEw">高效入门 eBPF&lt;/a>&lt;/p>
&lt;p>&lt;a href="https://mp.weixin.qq.com/s/LaoNpE5MNMrEeKzOFb_lYA">公众号，阿里云云原生-深入浅出 eBPF | 你要了解的 7 个核心问题&lt;/a>&lt;/p>
&lt;p>&lt;a href="https://github.com/DavadDi/bpf_study">GitHub 项目，DavadDi/bpf_study&lt;/a>(DavaDi 的 BPF 学习文章)&lt;/p>
&lt;p>&lt;a href="https://coolshell.cn/articles/22320.html">https://coolshell.cn/articles/22320.html&lt;/a>&lt;/p>
&lt;h1 id="为什么要使用-ebpf">为什么要使用 eBPF&lt;a class="td-heading-self-link" href="#%e4%b8%ba%e4%bb%80%e4%b9%88%e8%a6%81%e4%bd%bf%e7%94%a8-ebpf" aria-label="Heading self-link">&lt;/a>&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://mp.weixin.qq.com/s/K5bVHjJeOm8KpluPW1iyvw">公众号，云原生实验室，为什么 eBPF 如此受欢迎&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>eBPF 是一项革命性的技术，起源于 Linux 内核，可以在操作系统内核中运行 &lt;strong>Sandbox Programs(沙箱程序)&lt;/strong> 而无需修改内核源代码或加载内核模块。&lt;/p>
&lt;p>纵观历史，由于内核具有监督和控制整个系统的特权，操作系统一直是实现可观测性、安全性、网络功能的理想场所。同时，操作系统内核由于其核心租用以及对稳定性和安全性的高要求而难以发展。因此，与在操作系统之外实现的功能相比，操作系统级别的创新率传统上较低。&lt;/p>
&lt;p>eBPF 从根本上改变了这个套路。通过允许在操作系统中运行沙盒程序，应用程序开发人员可以运行 eBPF 程序以在运行时向操作系统添加额外的功能。然后，操作系统保证安全性和执行效率，就像借助 &lt;strong>Just-In-Time(即时，简称 JIT)&lt;/strong> 编译器和验证引擎进行本地编译一样。这引发了一波基于 eBPF 的项目，涵盖了广泛的用例，包括下一代网络、可观察性和安全功能。&lt;/p>
&lt;h2 id="ebpf-为什么高效">eBPF 为什么高效&lt;a class="td-heading-self-link" href="#ebpf-%e4%b8%ba%e4%bb%80%e4%b9%88%e9%ab%98%e6%95%88" aria-label="Heading self-link">&lt;/a>&lt;/h2>
&lt;p>eBPF 程序比传统程序“跑得”更快，因为它的代码是直接在内核空间中执行的。&lt;/p>
&lt;p>设想这样一个场景，假设一个程序想要统计其从 Linux 系统上发送出去的字节数，需要经过哪些步骤？&lt;/p>
&lt;p>首先，网络活动发生时，内核会生成原始数据，这些原始数据包含了大量的信息，而且大部分信息都与“字节数”这个信息无关。所以，无论生成的原始数据是个啥，只要你想统计发送出去的字节数，就必须反复过滤，并对其进行数学计算。这个过程每分钟要重复数百次（甚至更多）。&lt;/p>
&lt;p>传统的监控程序都运行在用户空间，内核生成的所有原始数据都必须从内核空间复制到用户空间，这种数据复制和过滤的操作会对 CPU 造成极大的负担。这就是为什么 ptrace 很“慢”，而 bpftrace[6] 很”快“。&lt;/p>
&lt;p>eBPF 无需将数据从内核空间复制到用户空间，你可以直接在内核空间运行监控程序来聚合可观测性数据，并将其发送到用户空间。eBPF 也可以直接在内核空间过滤数据以及创建 Histogram，这比在用户空间和内核空间之间交换大量数据要快得多。&lt;/p>
&lt;h1 id="ebpf-map">eBPF Map&lt;a class="td-heading-self-link" href="#ebpf-map" aria-label="Heading self-link">&lt;/a>&lt;/h1>
&lt;p>eBPF 有一个黑科技，它会使用 &lt;strong>eBPF Map(eBPF 映射)&lt;/strong> 来允许用户空间和内核空间之间进行双向数据交换。在 Linux 中，映射（Map）是一种通用的存储类型，用于在用户空间和内核空间之间共享数据，它们是驻留在内核中的键值存储。&lt;/p>
&lt;p>对于可观测性这种应用场景，eBPF 程序会直接在内核空间进行计算，并将结果写入用户空间应用程序可以读取/写入的 eBPF 映射中。&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/kqvmni/1656471724028-9a437fff-c998-434e-a75d-808c9e309295.jpeg" alt="">&lt;/p>
&lt;p>eBPF 的高效主要还是 &lt;strong>eBPF 提供了一种直接在内核空间运行自定义程序，并且避免了在内核空间和用户空间之间复制无关数据的方法。&lt;/strong>&lt;/p>
&lt;h1 id="ebpf-原理与架构简述">eBPF 原理与架构简述&lt;a class="td-heading-self-link" href="#ebpf-%e5%8e%9f%e7%90%86%e4%b8%8e%e6%9e%b6%e6%9e%84%e7%ae%80%e8%bf%b0" aria-label="Heading self-link">&lt;/a>&lt;/h1>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/kqvmni/1649300475763-25ddd536-5730-4065-a33c-5fb8fdd1c097.png" alt="image.png|800">&lt;/p>
&lt;p>众所周知，Linux 内核是一个事件驱动的系统设计，这意味着所有的操作都是基于事件来描述和执行的。比如打开文件是一种事件、CPU 执行指令是一种事件、接收网络数据包是一种事件等等。eBPF 作为内核中的一个子系统，可以检查这些基于事件的信息源，并且允许开发者编写并运行在内核触发任何事件时安全执行的 BPF 程序。&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/kqvmni/1619101127228-9138d591-82c8-4ce2-9f45-c431a34d3189.png" alt="800">&lt;/p>
&lt;p>下图简要描述了 eBPF 的架构及基本的工作流程。&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/bpf/20230206115723.png" alt="image.png">&lt;/p>
&lt;p>首先，开发者可以使用 C 语言（或者 Python 等其他高级程序语言）编写自己的 eBPF 程序，然后通过 LLVM 或者 GNU、Clang 等编译器，将其编译成 eBPF 字节码。Linux 提供了一个 bpf() 系统调用，通过 bpf() 系统调用，将这段编译之后的字节码传入内核空间。&lt;/p>
&lt;p>传入内核空间之后的 BPF 程序，并不是直接就在其指定的内核跟踪点上开始执行，而是先通过 Verifier 这个组件，来保证我们传入的这个 BPF 程序可以在内核中安全的运行。经过安全检测之后，Linux 内核 还为 eBPF 字节码提供了一个实时的编译器（Just-In-Time，JIT），JIT 将确认后的 eBPF 字节码编译为对应的机器码。这样就可以在 eBPF 指定的跟踪点上执行我们的操作逻辑了。&lt;/p>
&lt;p>那么，用户空间的应用程序怎么样拿到我们插入到内核中的 BPF 程序产生的数据呢？BPF 是通过一种 MAP 的数据结构来进行数据的存储和管理的，BPF 将产生的数据，通过指定的 MAP 数据类型进行存储，用户空间的应用程序，作为消费者，通过 bpf() 系统调用，从 MAP 数据结构中读取数据并进行相应的存储和处理。这样一个完整 BPF 程序的流程就完成了。&lt;/p>
&lt;h2 id="5-个模块">5 个模块&lt;a class="td-heading-self-link" href="#5-%e4%b8%aa%e6%a8%a1%e5%9d%97" aria-label="Heading self-link">&lt;/a>&lt;/h2>
&lt;p>eBPF 在内核主要由 5 个模块协作：&lt;/p>
&lt;p>&lt;strong>1、BPF Verifier（验证器）&lt;/strong>&lt;/p>
&lt;p>确保 eBPF 程序的安全。验证器会将待执行的指令创建为一个有向无环图（DAG），确保程序中不包含不可达指令；接着再模拟指令的执行过程，确保不会执行无效指令，这里通过和个别同学了解到，这里的验证器并无法保证 100%的安全，所以对于所有 BPF 程序，都还需要严格的监控和评审。&lt;/p>
&lt;p>&lt;strong>2、BPF JIT&lt;/strong>&lt;/p>
&lt;p>将 eBPF 字节码编译成本地机器指令，以便更高效地在内核中执行。&lt;/p>
&lt;p>3、多个 64 位寄存器、一个程序计数器和一个 512 字节的栈组成的存储模块&lt;/p>
&lt;p>用于控制 eBPF 程序的运行，保存栈数据，入参与出参。&lt;/p>
&lt;p>&lt;strong>4、BPF Helpers（辅助函数）&lt;/strong>&lt;/p>
&lt;p>提供了一系列用于 eBPF 程序与内核其他模块进行交互的函数。这些函数并不是任意一个 eBPF 程序都可以调用的，具体可用的函数集由 BPF 程序类型决定。注意，eBPF 里面所有对入参，出参的修改都必须符合 BPF 规范，除了本地变量的变更，其他变化都应当使用 BPF Helpers 完成，如果 BPF Helpers 不支持，则无法修改。&lt;/p>
&lt;p>bpftool feature probe&lt;/p>
&lt;p>通过以上命令可以看到不同类型的 eBPF 程序可以运行哪些 BPF Helpers。&lt;/p>
&lt;p>&lt;strong>5、BPF Map &amp;amp; context&lt;/strong>&lt;/p>
&lt;p>用于提供大块的存储，这些存储可被用户空间程序用来进行访问，进而控制 eBPF 程序的运行状态。&lt;/p>
&lt;p>bpftool feature probe | grep map_type&lt;/p>
&lt;p>通过以上命令可以看到系统支持哪些类型的 map。&lt;/p>
&lt;h2 id="3-个动作">3 个动作&lt;a class="td-heading-self-link" href="#3-%e4%b8%aa%e5%8a%a8%e4%bd%9c" aria-label="Heading self-link">&lt;/a>&lt;/h2>
&lt;p>先说下重要的系统调用 bpf：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-c" data-lang="c">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#204a87;font-weight:bold">int&lt;/span> &lt;span style="color:#000">bpf&lt;/span>&lt;span style="color:#000;font-weight:bold">(&lt;/span>&lt;span style="color:#204a87;font-weight:bold">int&lt;/span> &lt;span style="color:#000">cmd&lt;/span>&lt;span style="color:#000;font-weight:bold">,&lt;/span> &lt;span style="color:#204a87;font-weight:bold">union&lt;/span> &lt;span style="color:#000">bpf_attr&lt;/span> &lt;span style="color:#ce5c00;font-weight:bold">*&lt;/span>&lt;span style="color:#000">attr&lt;/span>&lt;span style="color:#000;font-weight:bold">,&lt;/span> &lt;span style="color:#204a87;font-weight:bold">unsigned&lt;/span> &lt;span style="color:#204a87;font-weight:bold">int&lt;/span> &lt;span style="color:#000">size&lt;/span>&lt;span style="color:#000;font-weight:bold">);&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>这里 cmd 是关键，attr 是 cmd 的参数，size 是参数大小，所以关键是看 cmd 有哪些：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-c" data-lang="c">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8f5902;font-style:italic">// 5.11内核
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8f5902;font-style:italic">&lt;/span>&lt;span style="color:#204a87;font-weight:bold">enum&lt;/span> &lt;span style="color:#000">bpf_cmd&lt;/span> &lt;span style="color:#000;font-weight:bold">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#000">BPF_MAP_CREATE&lt;/span>&lt;span style="color:#000;font-weight:bold">,&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#000">BPF_MAP_LOOKUP_ELEM&lt;/span>&lt;span style="color:#000;font-weight:bold">,&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#000">BPF_MAP_UPDATE_ELEM&lt;/span>&lt;span style="color:#000;font-weight:bold">,&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#000">BPF_MAP_DELETE_ELEM&lt;/span>&lt;span style="color:#000;font-weight:bold">,&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#000">BPF_MAP_GET_NEXT_KEY&lt;/span>&lt;span style="color:#000;font-weight:bold">,&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#000;font-weight:bold">......&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#000;font-weight:bold">};&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>最核心的就是 PROG，MAP 相关的 cmd，就是程序加载和映射处理。&lt;/p>
&lt;p>&lt;strong>1、程序加载&lt;/strong>&lt;/p>
&lt;p>调用 BPF_PROG_LOAD cmd，会将 BPF 程序加载到内核，但 eBPF 程序并不像常规的线程那样，启动后就一直运行在那里，它需要事件触发后才会执行。这些事件包括系统调用、内核跟踪点、内核函数和用户态函数的调用退出、网络事件，等等，所以需要第 2 个动作。&lt;/p>
&lt;p>&lt;strong>2、绑定事件&lt;/strong>&lt;/p>
&lt;p>b.attach_kprobe(event=&amp;ldquo;xxx&amp;rdquo;, fn_name=&amp;ldquo;yyy&amp;rdquo;)&lt;/p>
&lt;p>以上就是将特定的事件绑定到特定的 BPF 函数，实际实现原理如下：
（1）借助 bpf 系统调用，加载 BPF 程序之后，会记住返回的文件描述符；
（2）通过 attach 操作知道对应函数类型的事件编号；
（3）根据 attach 的返回值调用 perf_event_open 创建性能监控事件；
（4）通过 ioctl 的 PERF_EVENT_IOC_SET_BPF 命令，将 BPF 程序绑定到性能监控事件。&lt;/p>
&lt;p>&lt;strong>3、映射操作&lt;/strong>&lt;/p>
&lt;p>通过 MAP 相关的 cmd，控制 MAP 增删，然后用户态基于该 MAP 与内核状态进行交互。&lt;/p>
&lt;h1 id="基于-ebpf-的实现">基于 eBPF 的实现&lt;a class="td-heading-self-link" href="#%e5%9f%ba%e4%ba%8e-ebpf-%e7%9a%84%e5%ae%9e%e7%8e%b0" aria-label="Heading self-link">&lt;/a>&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://ebpf.io/projects">官方文档，项目&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;ul>
&lt;li>bcc # 高效的基于 BPF 的内核跟踪的工具包和库&lt;/li>
&lt;li>bpftrace # Linux eBPF 的高级跟踪语言&lt;/li>
&lt;/ul>
&lt;p>&lt;a href="https://desistdaydream.github.io/docs/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Kernel/BPF/BPF%20%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6%E6%9C%BA%E5%88%B6/BPF%20%E5%9C%A8%E7%BD%91%E7%BB%9C%E9%A2%86%E5%9F%9F%E7%9A%84%E5%AE%9E%E7%8E%B0.md">BPF 在网络领域的实现&lt;/a>&lt;/p>
&lt;ul>
&lt;li>tcpdump # 网络抓包工具&lt;/li>
&lt;li>TC eBPF # 作用在传统 TC 模块的 eBPF&lt;/li>
&lt;li>XDP eBPF # 各种 eBPF 程序新增加的 DataPath 通常都称为 XDP。&lt;/li>
&lt;li>Cilium #&lt;/li>
&lt;/ul>
&lt;h1 id="bpf-程序示例">BPF 程序示例&lt;a class="td-heading-self-link" href="#bpf-%e7%a8%8b%e5%ba%8f%e7%a4%ba%e4%be%8b" aria-label="Heading self-link">&lt;/a>&lt;/h1>
&lt;h2 id="bcc-版-hellowrold">BCC 版 HelloWrold&lt;a class="td-heading-self-link" href="#bcc-%e7%89%88-hellowrold" aria-label="Heading self-link">&lt;/a>&lt;/h2>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-python" data-lang="python">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8f5902;font-style:italic">#!/usr/bin/env python3&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#204a87;font-weight:bold">from&lt;/span> &lt;span style="color:#000">bcc&lt;/span> &lt;span style="color:#204a87;font-weight:bold">import&lt;/span> &lt;span style="color:#000">BPF&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8f5902;font-style:italic"># This may not work for 4.17 on x64, you need replace kprobe__sys_clone with kprobe____x64_sys_clone&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#000">prog&lt;/span> &lt;span style="color:#ce5c00;font-weight:bold">=&lt;/span> &lt;span style="color:#4e9a06">&amp;#34;&amp;#34;&amp;#34;
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#4e9a06"> int kprobe__sys_clone(void *ctx) {
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#4e9a06"> bpf_trace_printk(&amp;#34;Hello, World!&lt;/span>&lt;span style="color:#4e9a06">\\&lt;/span>&lt;span style="color:#4e9a06">n&amp;#34;);
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#4e9a06"> return 0;
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#4e9a06"> }
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#4e9a06">&amp;#34;&amp;#34;&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#000">b&lt;/span> &lt;span style="color:#ce5c00;font-weight:bold">=&lt;/span> &lt;span style="color:#000">BPF&lt;/span>&lt;span style="color:#000;font-weight:bold">(&lt;/span>&lt;span style="color:#000">text&lt;/span>&lt;span style="color:#ce5c00;font-weight:bold">=&lt;/span>&lt;span style="color:#000">prog&lt;/span>&lt;span style="color:#000;font-weight:bold">,&lt;/span> &lt;span style="color:#000">debug&lt;/span>&lt;span style="color:#ce5c00;font-weight:bold">=&lt;/span>&lt;span style="color:#0000cf;font-weight:bold">0x04&lt;/span>&lt;span style="color:#000;font-weight:bold">)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#000">b&lt;/span>&lt;span style="color:#ce5c00;font-weight:bold">.&lt;/span>&lt;span style="color:#000">trace_print&lt;/span>&lt;span style="color:#000;font-weight:bold">()&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>运行程序前需要安装过 bcc 相关工具包，正常运行后，每当系统中发生 &lt;code>sys_clone()&lt;/code> 系统调用时，运行的控制台上就会打印 “Hello, World!”，在打印文字前面还包含了调用程序的进程名称，进程 ID 等信息；&lt;/p>
&lt;blockquote>
&lt;p>如果运行报错，可能是缺少头文件，一般安装 kernel-devel 包即可。&lt;/p>
&lt;/blockquote>
&lt;h1 id="ebpf-库">eBPF 库&lt;a class="td-heading-self-link" href="#ebpf-%e5%ba%93" aria-label="Heading self-link">&lt;/a>&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://ebpf.io/projects/#ebpf-libraries">官方文档，项目-eBPF 库&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>&lt;a href="https://github.com/libbpf/libbpf">github.com/libpf/libbpf&lt;/a> # 基于 C/C++ 的库，作为上游 Linux 内核的一部分进行维护。&lt;/p>
&lt;ul>
&lt;li>上游代码在 &lt;a href="https://github.com/torvalds/linux/tree/master/tools/lib/bpf">GitHub 项目，torvalds/linux/tools/lib/bpf&lt;/a>&lt;/li>
&lt;/ul>
&lt;p>&lt;a href="https://github.com/cilium/ebpf">github.com/cilium/ebpf&lt;/a> # Cilium 维护的纯 Go 语言的 eBPF 库&lt;/p>
&lt;p>&lt;a href="https://github.com/aquasecurity/libbpfgo">github.com/aquasecurity/libbpfgo&lt;/a> # Aqua 维护的围绕 libbpf 的 Go 语言 eBPF 库。支持 CO-RE。使用 CGo 调用 libbpf 的链接版本。&lt;/p>
&lt;h1 id="其他">其他&lt;a class="td-heading-self-link" href="#%e5%85%b6%e4%bb%96" aria-label="Heading self-link">&lt;/a>&lt;/h1>
&lt;p>其实，eBPF 是一种设计思想，eBPF 是一个 &lt;strong>General purpose execution Engine(通用目的执行引擎)&lt;/strong>。换句话说，eBPF 是一个&lt;strong>最小指令集架构&lt;/strong>（a minimal instruction set architecture），在设计时&lt;strong>两个主要考虑&lt;/strong>：&lt;/p>
&lt;ol>
&lt;li>将 eBPF 指令映射到平台原生指令时开销尽可能小 —— 尤其是 x86-64 和 arm64 平台，因此我们针对这两种架构进行了很多优化，使程序运行地尽可能快。&lt;/li>
&lt;li>内核在加载 eBPF 代码时要能验证代码的安全性 —— 这也是为什么我们一 直将其限制为一个最小指令集，因为这样才能确保它是可验证的（进而是安全的）。很多人像我一样，在过去很长时间都在开发&lt;strong>内核模块&lt;/strong>（kernel module）。 但&lt;strong>内核模块中引入 bug 是一件极度危险的事情 —— 它会导致内核 crash&lt;/strong>。 此时 &lt;strong>BPF 的优势&lt;/strong>就体现出来了：校验器（verifier）会检查是否有越界内存访问 、无限循环等问题，一旦发现就会拒绝加载，而非将这些问题留到运行时（导致 内核 crash 等破坏系统稳定性的行为）。所以出于安全方面的原因，很多内核开发者开始用 eBPF 编写程序，而不再使用传统的内核模块方式。&lt;/li>
&lt;/ol>
&lt;p>eBPF 提供的是 &lt;strong>基本功能模块(building blocks)&lt;/strong> 和 &lt;strong>attachment points(程序附着点)&lt;/strong>。 我们可以编写 eBPF 程序来 attach 到这些 points 点完成某些高级功能。&lt;/p>
&lt;h1 id="bpf-项目介绍">BPF 项目介绍&lt;a class="td-heading-self-link" href="#bpf-%e9%a1%b9%e7%9b%ae%e4%bb%8b%e7%bb%8d" aria-label="Heading self-link">&lt;/a>&lt;/h1>
&lt;p>&lt;a href="https://github.com/ehids/ecapture">GitHub 项目，ehids/ecapture&lt;/a> #&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://mp.weixin.qq.com/s/PHYR-E02A6nR0N4aim26pg">基于 eBPF 的开源项目 eCapture 介绍：无需 CA 证书抓 https 网络明文通讯&lt;/a>&lt;/li>
&lt;/ul></description></item><item><title>Docs: BPF 流量控制机制</title><link>https://desistdaydream.github.io/docs/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Kernel/BPF/BPF-%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6%E6%9C%BA%E5%88%B6/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Kernel/BPF/BPF-%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6%E6%9C%BA%E5%88%B6/</guid><description/></item></channel></rss>