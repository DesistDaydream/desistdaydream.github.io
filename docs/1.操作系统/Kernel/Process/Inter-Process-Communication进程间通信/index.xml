<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Inter Process Communication(进程间通信) on 断念梦的站点</title><link>https://desistdaydream.github.io/docs/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Kernel/Process/Inter-Process-Communication%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1/</link><description>Recent content in Inter Process Communication(进程间通信) on 断念梦的站点</description><generator>Hugo</generator><language>zh-cn</language><atom:link href="https://desistdaydream.github.io/docs/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Kernel/Process/Inter-Process-Communication%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1/index.xml" rel="self" type="application/rss+xml"/><item><title>Inter Process Communication(进程间通信)</title><link>https://desistdaydream.github.io/docs/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Kernel/Process/Inter-Process-Communication%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1/Inter-Process-Communication%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Kernel/Process/Inter-Process-Communication%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1/Inter-Process-Communication%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1/</guid><description>概述 参考：
Wiki, IPC Wiki, LPC 公众号,小林 Coding-进程间通信 Inter Process Communication(进程间通信，简称 IPC) 是一种允许多个进程共享数据的机制。IPC 的两个应用可以被分为客户端和服务端，客户端进程请求数据，服务端响应客户端的数据请求。有一些应用本身既是服务器又是客户端，这在分布式计算中，时常可以见到。这些进程可以运行在同一计算机上或网络连接的不同计算机上。
IPC 对微内核和 nano 内核的设计过程非常重要。 微内核减少了内核提供的功能数量。 然后通过 IPC 与服务器通信获得这些功能，与普通的宏内核相比，IPC 的数量大幅增加。
IPC 可以分为如下两类：
Local Procedure Call(本地过程调用，简称 LPC) # Remote Procedure Call(远程过程调用，简称 RPC) # IPC 可以通过多种方式实现：
file(文件) # 多个进程可以通过磁盘上的文件共享数据。 Signal(信号)# 从一个进程发送到另一个进程的系统消息，通常不用于传输数据，而是用于远程命令伙伴进程。Signal(信号) pipe(管道)# 使用标准输入和输出的单向数据通道。写入管道的写入端的数据由操作系统进行缓冲，直到从管道的读取端读取数据为止。通过使用相反“方向”上的两个管道可以实现过程之间的双向通信。详见 管道符等组合命令 Socket(套接字) # 计算机领域中数据通信的一种约定，或者说是一种方法，《Socket(套接字)》。Socket 又分为两种 Unix Domain Socket Network Socket Shared Memory(共享内存) # Message Queue(消息队列) # 类似于 Socket 的数据流，但这通常保留了信息的边界。通常由操作系统实现，它们允许多个进程读写消息队列，而不需要彼此直接连接。 Mesage Passing(消息传递) # 允许多个程序使用消息队列和/或非 OS 托管通道进行通信。常用于并发模型。比如 LPC、RPC 等等。 等等 IPC 实现方式概述 每个进程的用户地址空间都是独立的，一般而言是不能互相访问的，但内核空间是每个进程都共享的，所以进程之间要通信必须通过内核。</description></item><item><title>Signal(信号)</title><link>https://desistdaydream.github.io/docs/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Kernel/Process/Inter-Process-Communication%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1/Signal%E4%BF%A1%E5%8F%B7/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Kernel/Process/Inter-Process-Communication%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1/Signal%E4%BF%A1%E5%8F%B7/</guid><description>概述 参考：
Wiki, Signal Signal(信号) 是 Inter Process Communication(进程间通信) 的一种受限形式。信号是发送到进程或同一进程内的特定线程的异步通知，目的是将发生的事件通知给它。发送信号后，操作系统会中断目标进程的正常执行流程以传递信号。在任何非原子指令中，执行都可以中断。如果该进程先前已注册了信号处理程序，则将执行该例程。否则，将执行默认信号处理程序。
信号类似于中断，区别在于中断由处理器介导并由内核处理，而信号由内核介导（可能通过系统调用）并由进程处理。内核可能会将中断作为信号传递给引起中断的进程（典型示例为 SIGSEGV，SIGBUS，SIGILL 和 SIGFPE）。
信号类型
Linux 系统共定义了 64 种信号，分为两大类：可靠信号与不可靠信号，前 32 种信号为不可靠信号，后 32 种为可靠信号。
1.1 概念
不可靠信号： 也称为非实时信号，不支持排队，信号可能会丢失, 比如发送多次相同的信号, 进程只能收到一次. 信号值取值区间为 1~31； 可靠信号： 也称为实时信号，支持排队, 信号不会丢失, 发多少次, 就可以收到多少次. 信号值取值区间为 32~64 1.2 信号表
在终端，可通过 kill -l 查看所有的 signal 信号
使用时，这些信号开头的 3 个大写字符(SIG)可以省略
~]# kill -l 1) SIGHUP 2) SIGINT 3) SIGQUIT 4) SIGILL 5) SIGTRAP 6) SIGABRT 7) SIGBUS 8) SIGFPE 9) SIGKILL 10) SIGUSR1 11) SIGSEGV 12) SIGUSR2 13) SIGPIPE 14) SIGALRM 15) SIGTERM 16) SIGSTKFLT 17) SIGCHLD 18) SIGCONT 19) SIGSTOP 20) SIGTSTP 21) SIGTTIN 22) SIGTTOU 23) SIGURG 24) SIGXCPU 25) SIGXFSZ 26) SIGVTALRM 27) SIGPROF 28) SIGWINCH 29) SIGIO 30) SIGPWR 31) SIGSYS 34) SIGRTMIN 35) SIGRTMIN+1 36) SIGRTMIN+2 37) SIGRTMIN+3 38) SIGRTMIN+4 39) SIGRTMIN+5 40) SIGRTMIN+6 41) SIGRTMIN+7 42) SIGRTMIN+8 43) SIGRTMIN+9 44) SIGRTMIN+10 45) SIGRTMIN+11 46) SIGRTMIN+12 47) SIGRTMIN+13 48) SIGRTMIN+14 49) SIGRTMIN+15 50) SIGRTMAX-14 51) SIGRTMAX-13 52) SIGRTMAX-12 53) SIGRTMAX-11 54) SIGRTMAX-10 55) SIGRTMAX-9 56) SIGRTMAX-8 57) SIGRTMAX-7 58) SIGRTMAX-6 59) SIGRTMAX-5 60) SIGRTMAX-4 61) SIGRTMAX-3 62) SIGRTMAX-2 63) SIGRTMAX-1 64) SIGRTMAX 取值 名称 解释 默认动作 1 SIGHUP 挂起 2 SIGINT 中断 3 SIGQUIT 退出 4 SIGILL 非法指令 5 SIGTRAP 断点或陷阱指令 6 SIGABRT abort 发出的信号 7 SIGBUS 非法内存访问 8 SIGFPE 浮点异常 9 SIGKILL kill 信号 不能被忽略、处理和阻塞 10 SIGUSR1 用户信号 1 程序自定义的信号，常用这种信号来处理日志或加载配置文件。比如 docker 用这种信号来生成日志 11 SIGSEGV 无效内存访问 12 SIGUSR2 用户信号 2 13 SIGPIPE 管道破损，没有读端的管道写数据 14 SIGALRM alarm 发出的信号 15 SIGTERM 终止信号 16 SIGSTKFLT 栈溢出 17 SIGCHLD 子进程退出 默认忽略 18 SIGCONT 进程继续 19 SIGSTOP 进程停止 不能被忽略、处理和阻塞 20 SIGTSTP 进程停止 21 SIGTTIN 进程停止，后台进程从终端读数据时 22 SIGTTOU 进程停止，后台进程想终端写数据时 23 SIGURG I/O 有紧急数据到达当前进程 默认忽略 24 SIGXCPU 进程的 CPU 时间片到期 25 SIGXFSZ 文件大小的超出上限 26 SIGVTALRM 虚拟时钟超时 27 SIGPROF profile 时钟超时 28 SIGWINCH 窗口大小改变 默认忽略 29 SIGIO I/O 相关 30 SIGPWR 关机 默认忽略 31 SIGSYS 系统调用异常 对于 signal 信号，绝大部分的默认处理都是终止进程或停止进程，或 dump 内核映像转储。 上述的 31 的信号为非实时信号，其他的信号 32-64 都是实时信号。</description></item></channel></rss>