<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>断念梦 – 0_操作系统</title><link>https://desistdaydream.github.io/docs/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/0_%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/</link><description>Recent content in 0_操作系统 on 断念梦</description><generator>Hugo -- gohugo.io</generator><atom:link href="https://desistdaydream.github.io/docs/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/0_%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/index.xml" rel="self" type="application/rss+xml"/><item><title>Docs: Windows 操作系统</title><link>https://desistdaydream.github.io/docs/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/0_%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Windows-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/0_%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Windows-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;h2 id="参考">参考：&lt;/h2>
&lt;/blockquote>
&lt;h1 id="学习资料">学习资料&lt;/h1>
&lt;p>&lt;a href="https://learn.microsoft.com/">官方学习&lt;/a>&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://learn.microsoft.com/training/">培训&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://learn.microsoft.com/certifications/">认证&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://learn.microsoft.com//docs/">文档&lt;/a>&lt;/li>
&lt;/ul></description></item><item><title>Docs: POSIX</title><link>https://desistdaydream.github.io/docs/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/0_%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/POSIX/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/0_%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/POSIX/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/POSIX">Wiki,POSIX&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://cloud.tencent.com/developer/ask/26856">腾讯云,什么是 POSIX&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>&lt;strong>Portable Operating System Interface(便携式操作系统接口，POSIX)&lt;/strong> 是 IEEE 计算机协会指定的一系列标准，用于维护操作系统之间的兼容性。 POSIX 定义了应用程序编程接口 (API)，以及命令行 shell 和实用程序接口，以实现与 类 Unix 操作系统 和 其他操作系统的软件兼容性。&lt;/p>
&lt;p>一般情况下，应用程序通过应用编程接口(API)而不是直接通过系统调用来编程。这点很重要，因为应用程序使用的这种编程接口实际上并不需要和内核 提供的系统调用对应。一个 API 定义了一组应用程序使用的编程接口。它们可以实现成一个系统调用，也可以通过调用多个系统调用来实现，而完全不使用任何系 统调用也不存在问题。实际上，API 可以在各种不同的操作系统上实现，给应用程序提供完全相同的接口，而它们本身在这些系统上的实现却可能迥异。&lt;/p>
&lt;p>在 Unix 世界中，最流行的应用编程接口是基于 POSIX 标准的。从纯技术的角度看，POSIX 是由 IEEE 的一组标准组成，其目标是提供一套大体上基于 Unix 的可移植操作系统标准。Linux 是与 POSIX 兼容的。&lt;/p>
&lt;p>POSIX 是说明 API 和系统调用之间关系的一个极好例子。在大多数 Unix 系统上，根据 POSIX 而定义的 API 函数和系统调用之间有着直接关 系。实际上，POSIX 标准就是仿照早期 Unix 系统的界面建立的。另一方面，许多操作系统，像 Windows NT，尽管和 Unix 没有什么关系，也提供了与 POSIX 兼容的库。&lt;/p>
&lt;p>Linux 的系统调用像大多数 Unix 系统一样，作为 C 库的一部分提供如图 5-1 所示。如图 5-1 所示 C 库实现了 Unix 系统的主要 API，包括标 准 C 库函数和系统调用。所有的 C 程序都可以使用 C 库，而由于 C 语言本身的特点，其他语言也可以很方便地把它们封装起来使用。此外，C 库提供了 POSIX 的绝大部分 API。&lt;/p>
&lt;p>从程序员的角度看，系统调用无关紧要；他们只需要跟 API 打交道就可以了。相反，内核只跟系统调用打交道；库函数及应用程序是怎么使用系统调用不是内核所关心的。
&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;这是分割线&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;ndash;
简单总结：
完成同一功能，不同内核提供的系统调用（也就是一个函数）是不同的，例如创建进程，linux 下是 fork 函数，windows 下是 creatprocess 函数。好，我现在在 linux 下写一个程序，用到 fork 函数，那么这个程序该怎么往 windows 上移植？我需要把源代码里的 fork 通通改成 creatprocess，然后重新编译&amp;hellip;&lt;/p>
&lt;p>POSIX 标准的出现就是为了解决这个问题。linux 和 windows 都要实现基本的 POSIX 标准，Linux 把 fork 函数封装成 posix_fork（随便说的），windows 把 creatprocess 函数也封装成 posix_fork，都声明在 unistd.h 里。这样，程序员编写普通应用时候，只用包含 unistd.h，调用 posix_fork 函数，程序就在源代码级别可移植了&lt;/p></description></item><item><title>Docs: 分时系统 与 实时系统</title><link>https://desistdaydream.github.io/docs/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/0_%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E5%88%86%E6%97%B6%E7%B3%BB%E7%BB%9F-%E4%B8%8E-%E5%AE%9E%E6%97%B6%E7%B3%BB%E7%BB%9F/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/0_%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E5%88%86%E6%97%B6%E7%B3%BB%E7%BB%9F-%E4%B8%8E-%E5%AE%9E%E6%97%B6%E7%B3%BB%E7%BB%9F/</guid><description>
&lt;h1 id="time-sharing-system分时系统">Time Sharing System(分时系统)&lt;/h1>
&lt;h2 id="概述">概述&lt;/h2>
&lt;p>**Time Sharing Operating System(分时操作系统，简称 TSOS) **的出现是为了弥补批处理方式不能向用户提供交互式快速服务的缺点而发展起来的，并且成为了当今(2021 年) 的主流操作系统。&lt;/p>
&lt;p>在分时系统中，一台计算机主机连接了多个终端，每个终端可由一个用户使用。用户通过终端交互式地向系统发出命令请求，系统接受用户的命令之后，采用时间片轮转方式处理服务请求，并通过交互方式在终端上向用户显示结果。&lt;/p>
&lt;p>这样的系统现在(2021 年)仍然占据着大量的市场，Windos、MacOS，Linux 都属于分时操作系统。分时系统的典型代表就是 UNIX，它对后续操作系统的设计产生了重大影响。&lt;/p>
&lt;p>分时共享是出于这样的认识而开发的：即尽管任何单个用户都会低效地使用计算机，但一大群用户在一起却不会。这是由于交互模式所致: 通常，单个用户会输入大量信息，然后进行长时间的暂停，但是一组用户同时工作将意味着一个用户的暂停将被其他用户的活动所填补。给定最佳的群体规模，整个过程可能非常有效。同样，可以将等待磁盘，磁带或网络输入所花费的一小部分时间授予其他用户。&lt;/p>
&lt;h2 id="分时的概念与实现">分时的概念与实现&lt;/h2>
&lt;p>分时操作系统将 CPU 的运行时间划分为若干个小片段，称为 &lt;strong>Time slice(时间片)。Time slice(时间片)&lt;/strong> 是系统规定进程一次使用 CPU 的最长时间(时间片的长短可以因不同系统而异)。&lt;/p>
&lt;p>最开始，时间片通常是 100ms 左右，这是一个实验统计值(不能太大也不能太小)。另外，在硬件方面设立一个中断时钟，它每过时间片便向 CPU 发一次中断信号。于是，假设现在有多个用户程序 A、B、C，CPU 在一个 A 执行完一个时间片后便被中断，然后去执行 B 一个时间片，再执行 C 一个时间片，一次循环，直到 A、B、C 三个程序全部执行完成。操作系统会保护被中断程序的运行现场，转去执行另一个用户程序。&lt;/p>
&lt;p>就这样，操作系统可以把 CPU 按时间片依次分配给系统中的各个用户程序。由于系统中用户程序的数目是有限的，所以，只要时间片大小选取合适，就能给用户以独占系统资源的感觉，可以使每个用户能及时与自己的作业交互，使用户的请求得到及时响应。其实，为了实现人机交互，分时操作系统对早起批处理系统的运行方式进行了两大改进：一是作业直接进内存；二是作业不能长期占用 CPU，而是以时间片为单位交替使用 CPU。&lt;/p>
&lt;p>分时系统的原理，同样也适用于多任务上，当系统中 1 个用户同时运行了多个程序时，也可以使用时间片的概念，让多个程序形成逻辑上的“并行”执行。&lt;/p>
&lt;p>UNIX 就是典型的通用的分时操作系统。&lt;/p>
&lt;h1 id="real-time-system实时操作系统">Real Time System(实时操作系统)&lt;/h1>
&lt;h2 id="概述-1">概述&lt;/h2>
&lt;blockquote>
&lt;p>参考：&lt;a href="https://en.wikipedia.org/wiki/Real-time_operating_system">Wiki,Real-time OS&lt;/a>&lt;/p>
&lt;/blockquote>
&lt;p>&lt;strong>Real Time Operating System(实时操作系统，简称 RTOS)&lt;/strong> 是一种操作系统 (OS)，旨在为实时应用程序提供服务，这些应用程序通常在没有缓冲区延迟的情况下处理数据。处理时间要求 (包括任何 OS 延迟) 以十分之一秒或更短的时间增量来衡量。实时系统是具有明确定义的固定时间约束的有时限的系统。处理必须在定义的约束条件下完成，否则系统将失败。它们要么是事件驱动的，要么是分时的。事件驱动系统根据任务的优先级在任务之间切换，而分时系统根据时钟中断切换任务。大多数 RTOS 使用先发制人的调度算法。&lt;/p>
&lt;p>实时操作系统主要有两类：&lt;/p>
&lt;ul>
&lt;li>硬实时系统 # 对关键外部时间的响应和处理时间有这极其严格的要求，系统必须满足这种严格的时间要求，否则会产生严重的不良后果。
&lt;ul>
&lt;li>火箭和导弹控制、机器人控制、核反应堆控制等都是硬实时系统应用的典型领域。飞行控制系统就是硬实时的。这种时间精确度通常会要求在微秒以下。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>软实时系统 # 对时间的响应和处理时间有一定的时间范围要求，不能满足相关的要求会影响系统的服务质量，但是通常不会引发灾难性的后果。如视频信息处理、电信、银行、飞机订票等领域的信息处理。&lt;/li>
&lt;/ul>
&lt;h1 id="总结">总结&lt;/h1>
&lt;p>实际上，Time Sharing 与 Real Time 都是一种任务处理的方式，只要一个操作系统实现了这种方式，就可以称为 TSOS 或 RTOS，LInux 的进程调度系统，随着时间的发展，也逐渐具备了两种方式。&lt;/p></description></item><item><title>Docs: 类 Unix 操作系统</title><link>https://desistdaydream.github.io/docs/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/0_%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E7%B1%BB-Unix-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/0_%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E7%B1%BB-Unix-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/</guid><description/></item><item><title>Docs: 系统启动流程</title><link>https://desistdaydream.github.io/docs/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/0_%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E7%B3%BB%E7%BB%9F%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/0_%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E7%B3%BB%E7%BB%9F%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://mp.weixin.qq.com/s/hItVJbvxN2DHkb1rwYSltA">公众号，马哥 Linux 运维-Linux 系统开机加电后发生了什么？&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://mp.weixin.qq.com/s/QDjAIzas5EXQ24-NfTU3TQ">公众号，码农的荒岛求生-操作系统是如何启动起来的？&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>操作系统被称为 The first programme(第一个程序)，原因很简单，只有当操作系统启动起来后才能运行我们编写的程序，那么操作系统是怎样启动起来的呢？&lt;strong>实际上这个过程就像发射火箭一样有趣&lt;/strong>&lt;/p>
&lt;h2 id="操作系统也是普通程序">操作系统也是普通程序&lt;/h2>
&lt;p>首先我们必须意识到这样两点：&lt;/p>
&lt;ul>
&lt;li>CPU 执行的是机器指令，编译器将程序翻译后成了机器指令&lt;/li>
&lt;li>操作系统本身也是一个程序，这个程序被编译后也会生成一大堆机器指令&lt;/li>
&lt;/ul>
&lt;p>现在我们知道了，操作系统本身其实也是一大堆机器指令，既然是机器指令那么它必须得存放在什么地方。&lt;/p>
&lt;p>存放在哪里呢？&lt;/p>
&lt;p>想想我们编写的程序，编译后生成的是可执行文件，也就是说是以“文件”的形式存放的，并且存放在硬盘上，而操作系统也没什么不同，编译后生成的机器指令同样是以文件的形式存放的，存放在哪里呢？可以存放在任何能存储数据的介质，像 CD、磁盘之类都可以。&lt;/p>
&lt;p>我们编写的程序在启动时被加载器——也就是 loader，加载到内存，加载器也是一个程序，这是一个加载其它程序的程序；这么说可能有点拗口，但计算机系统中有大量类似的程序，编译器是一个翻译程序的程序、操作系统是一个运行其它程序的程序、链接器是一个链接程序的程序、解释器是一个执行脚本程序的程序等等。
&lt;strong>鸡生蛋蛋生鸡的问题&lt;/strong>&lt;/p>
&lt;p>回到我们的主题，我们写的代码是 loader 加载到内存后运行的，那么操作系统这个程序是也同样的道理，必须得有个什么东西也要把操作系统加载到内存中运行才可以，这个东西不叫 loader，而是叫 boot loader，其本身也是一个程序，&lt;strong>它的任务就是加载一个更大的程序&lt;/strong>，就像这里的操作系统。&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/id9gn1/1648429100745-ceca564f-ccaf-4249-83c4-03637c50eb6f.png" alt="">&lt;/p>
&lt;p>此时这里会出现一个鸡生蛋蛋生鸡的，既然我们的程序是被加载器 loader(操作系统的一部分)加载到内存中，而操作系统又是被 boot loader 这个加载程序加载到内存中的，那么又是什么加载器把 boot loader 这个加载程序加载到内存中呢？而又又是什么加载器把上一句中的什么加载器加载内存中呢？而又又又是什么。。？&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/id9gn1/1648429100748-550bd283-9b49-4e33-9791-a47013d74bca.png" alt="">&lt;/p>
&lt;p>你会发现这个一个没有出口的无穷递归啊有没有，总得有个什么把前一个程序加载到内存，&lt;strong>就好比今天的前一天是昨天、昨天的前一天是前天、前天的前一天是大前天，如果一直这样思考下去那么时间到底在哪里开始的呢&lt;/strong>？时间到底有没有开始(参考时间简史或相对论)？&lt;/p>
&lt;p>时间有没有开始这个问题我不清楚，但操作系统启动的这个问题我知道。&lt;/p>
&lt;p>上述关于加载器以及加载加载器等问题全部指向了内存，让我们好好想一想内存有什么特殊性？&lt;/p>
&lt;h2 id="内存断电后是无法保存数据">内存断电后是无法保存数据&lt;/h2>
&lt;p>程序员都知道内存只有在加电的情况下才可以保存数据(关于内存的实现原理你可以参考这篇《&lt;a href="http://mp.weixin.qq.com/s?__biz=Mzg4OTYzODM4Mw==&amp;amp;mid=2247485736&amp;amp;idx=1&amp;amp;sn=a70558b5200e840ef251e19a2eef099b&amp;amp;chksm=cfe995a8f89e1cbe8fab1240515f35ec90fb520d122ec60761b71a8664ae3af390689be370aa&amp;amp;scene=21#wechat_redirect">你管这破玩意叫 CPU？&lt;/a>》)，那么很显然，&lt;strong>当断电后内存中的内容就丢失了&lt;/strong>，那么又很显然的，当你在按下计算机开关通电时，内存中的内容是未被初始化的，也就是说内存中的内容是无效的，&lt;strong>此时的内存里还是一片荒芜&lt;/strong>，这里没有任何东西可供 CPU 来执行，这就好比大爆炸之前的宇宙。
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/id9gn1/1648429100787-22b14442-38f8-43b5-9e92-0cd8bc048d40.png" alt="">
但我们的计算机总是能启动起来，CPU 必须得执行“一段什么程序”把第一个 boot loader 加载到内存中，&lt;strong>由于此时内存中还什么都没有，那么这段程序一定被保存在了其它地方&lt;/strong>。&lt;/p>
&lt;p>保存在了哪里呢？&lt;/p>
&lt;p>没错，这段程序就被保存在了 BIOS 的非易失性存储 ROM 或者 flash 存储中了，这里的代码在即使断电后也会保存下来，加电后 CPU 开始执行这里代码，把 boot loader 加载到内存中，现在你应该明白第一个 boot loader 是怎样被加载到内存的了吧。
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/id9gn1/1648429100774-74b706fc-5218-4dda-b30c-eeb9ab95e7a7.png" alt="">
在早期的计算机上甚至专门有一个按钮，让用户自己选择该从哪里，比如打孔纸带、打孔卡片或者硬盘，加载一个更复杂的程序来运行，操作面板上的旋钮可以控制把这些程序加载到内存的什么位置上去：
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/id9gn1/1648429100742-3d35999a-6920-47f7-afd0-07403a3ba21c.jpeg" alt="">&lt;/p>
&lt;h2 id="火箭与操作系统启动">火箭与操作系统启动&lt;/h2>
&lt;p>然而现实情况比较复杂，我们刚才提到的 boot loader 这段小程序功能实在是太弱了，此时其能访问的磁盘地址空间有限，不能把完整的内核全部加载到操作系统中，该怎么办呢？&lt;/p>
&lt;p>既然 boot loader 比较弱那么就换一个比较牛的 loader 程序来，就这样出现了二阶 boot loader，second stage loader：
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/id9gn1/1648429101226-b5e1f5bb-da1d-43a2-932d-10265a2f2bb1.png" alt="">
二阶 boot loader 功能更为丰富，比如对硬件进行检查、给用户提供选项加载哪个操作系统等等，安装多系统的同学应该知道，启动时会给你一个选项到底是启动 windows 还是 linux，这就是二阶 boot loader 的作用。
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/id9gn1/1648429101278-dd790173-0a36-429f-9be3-be5699d90f5a.png" alt="">
最终，操作系统被二阶 boot loader 加载到内存中开始运行。&lt;/p>
&lt;p>你会发现这个过程就和发射三级火箭一样，最初一级火箭启动，燃料用尽后二级火箭启动，二级火箭完成使命后三级火箭启动，最终把卫星送到太空，而计算机的启动过程也类似。&lt;/p>
&lt;p>最初是 CPU 运行 BIOS 中的一段代码把一级 boot loader 加载到内存中运行，该程序又会把二级 boot loader 加载到内存运行，而二级 boot loader 又会把操作系统加载到内存中，此后控制权被转移到操作系统，(所谓控制权是指 CPU 跳转到操作系统的代码)，操作系统开始运行，经过一系列的初始化，比如硬件检测、开启必要的后台进程等等，最终图形界面或者命令行界面呈现出来。
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/id9gn1/1648429101302-750c6a86-5693-4248-858e-d0e1a3884a8e.png" alt="">
接下来我们把这个过程细化一下。&lt;/p>
&lt;h2 id="更详细的启动过程">更详细的启动过程&lt;/h2>
&lt;p>你在按下电源的瞬间相当于火箭点火，此时一级发动机开始工作。&lt;/p>
&lt;p>加电 CPU 重置后开始在地址 0xffff0 处开始执行指令，这个地址其实是 BIOS ROM 的末尾处，该位置其实是一个跳转指令，跳转到 ROM 的一段启动代码上，该代码会进行必要的自检，Power-on self-test (POST)，展示 BIOS 启动界面等等，最重要的一步是找到启动设备，所谓启动设备就是指从哪里加载操作系统，比如 CD-ROM、或者磁盘、甚至 U 盘等都可以作为启动设备，早些年流行用 U 盘重新安装系统，其实就是告诉 BIOS 的这段代码从 U 盘中加载操作系统。&lt;/p>
&lt;p>通常 BIOS 会把磁盘当做启动设备(大部分情况下)，此时 BIOS 中的这段代码开始将磁盘的第 0 号块加载到内存中，那么这第 0 号块中有什么呢？没错，就是第一阶段 boot loader 程序，这第 0 号块也被称之为 Master Boot Record，MBR，肯定有不少同学听说过。&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/id9gn1/1648429101348-dbe515f5-8c00-4f46-91c8-b8944d6a12d9.png" alt="">&lt;/p>
&lt;p>到这里，火箭的一级发动机燃料用尽，二级发动机开始点火，BIOS 中的这段代码把控制权交给加载到内存 boot loader，所谓控制权就是跳转到 boot loader 程序，这样 CPU 终于开始直接与内存交互了，CPU 开始从内存中取出指令然后执行。&lt;/p>
&lt;p>MBR 中除了包含一段可执行代码之外还有一个分区表，partition table，这个表的中的每一个条目本质上在说：“操作系统是否在我这个分区，我这个分区有多大”，CPU 在执行 MBR 中的代码时会去检查操作系统存在哪个分区中，定位后开始从相应分区的起始位置读取磁盘数据到内存中，这时的磁盘数据中保存的就是二阶 boot loader，second-stage boot loader，此时一阶 boot loader 把控制权转交给二阶 boot loader，火箭三级发动机开始工作。&lt;/p>
&lt;p>2_boot loader 的主要工作将操作系统加载到内存中，此后控制权转交给操作系统，火箭的三级发动机完成使命，&lt;strong>到这一时刻，操作系统开始接管计算机&lt;/strong>，操作系统经过一系列自身的初始化后创建出若干必要进程，至此计算机启动完毕，卫星被成功送到了外太空中。&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/id9gn1/1648429101351-eb22ccb7-7957-4f8c-b88e-854522e1a60c.png" alt="">&lt;/p>
&lt;p>然而限于篇幅这里依然没有过多涉及细节，操作系统本身的初始化也是一个比较复杂的过程，感兴趣的同学可以去翻阅相关操作系统的资料。&lt;/p>
&lt;h1 id="系统启动流程">系统启动流程&lt;/h1>
&lt;ul>
&lt;li>&lt;strong>Power-on self-test(POST)&lt;/strong> # 加电自检通过 ROM 芯片来检测&lt;/li>
&lt;li>&lt;strong>ROM 芯片&lt;/strong> # CMOS 然后启动 BIOS 程序&lt;/li>
&lt;li>&lt;strong>Basic Input and Output System(BIOS)&lt;/strong> # 基本输出输出系统&lt;/li>
&lt;li>&lt;strong>Boot Sequence&lt;/strong> # 按次序查找各引导设备，第一个有引导程序的设备准备本次启动用到的设备，不管该引导程序是否执行成功，只要有引导程序，就不再找下一个设备了。
&lt;ul>
&lt;li>读取硬盘的第一个扇区，这个扇区被称为 MBR．这个扇区中存储了一个小程序，叫做 boot loader．MBR 很小，只有 446B. 最常见的一种 boot loader 叫 grub.&lt;/li>
&lt;li>MBR，前 446 字节为 bootloader，后面 64 字节为 fat(磁盘分区表)，后面 2 字节为 55AA 标记&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>Bootloader&lt;/strong> # 引导加载器，这是一个程序。功能：提供一个菜单，供用户选择要启动的系统或不同的内核版本，把用户选定的内核装载到内存中的特定空间中，解压，展开，并把系统控制权移交给内核
&lt;ul>
&lt;li>boot loader 程序主要做两件事，一个是将内核加载到内存中，另一个是启动一个虚拟文件系统．内核文件是 /boot/vmlinuz*,虚拟文件系统文件是 /boot/initrd*．&lt;/li>
&lt;li>GRUB(GRand Uniform BootLoader)用来找到操作系统所在的磁盘分区，把内核加载至内存中，还能把控制权正常转交给内核的程序
&lt;ul>
&lt;li>GRUB 0.x 版：GRUB Legacy&lt;/li>
&lt;li>GRUB 1.X 版：GRUB2&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Kernel
&lt;ul>
&lt;li>初始化：
&lt;ul>
&lt;li>探测硬件&lt;/li>
&lt;li>装载硬件的驱动程序(有可能会借助于 ramdisk 加载驱动程序)&lt;/li>
&lt;li>挂载根文件系统到 / 目录下&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>运行用户空间的第一个应用程序
&lt;ul>
&lt;li>init(初始化)程序的类型
&lt;ul>
&lt;li>SysV：第一个进程名 init 早期的系统用的这个程序，通过脚本启动程序，一个启动完了才能启动下一个&lt;/li>
&lt;li>配置文件/etc/inittab&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Upstart：第一个进程名 init
&lt;ul>
&lt;li>配置文件/etc/inittab、/etc/init/*.conf&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Systemd：第一个进程名 systemd 所有程序可以并行同时启动
&lt;ul>
&lt;li>配置文件：/lib/systemd/system，/etc/systemd/system&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>ramdisk&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>POST &amp;ndash;&amp;gt; BootSequence(BIOS) &amp;ndash;&amp;gt; Bootloader(MBR) &amp;ndash;&amp;gt; kernel(ramdisk) &amp;ndash;&amp;gt; rootfs &amp;ndash;&amp;gt; init(systemd)&lt;/p>
&lt;h2 id="上电引导">上电、引导&lt;/h2>
&lt;p>按下开关键，触发主板引脚，开启电源，为主板通电&lt;/p>
&lt;h2 id="装载内核">装载内核&lt;/h2>
&lt;p>vmlinuz 分析
a. mkdir /tmp/vmlinuz&amp;amp;&amp;amp;cp /boot/vmlinuz-4.4.0-21-generic  /tmp/vmlinuz/
b. cd /tmp/vmlinuz/
c. od -t x1 -A d vmlinuz-4.4.0-21-generic | grep &amp;ldquo;1f 8b 08&amp;rdquo;
本质上，vmlinuz-4.4.0-21-generic  是一个 gzip 压缩文件，但是不能直接用 gzip 指令解压，因为在这个文件的开头嵌入了 gzip 的代码．
所以首先用指令 c 找到真正的压缩文件的头部．这个指令的输出形如:
0018864 ac fe ff ff 1f 8b 08 00 00 00 00 00 02 03 ec fd
然后执行下面的指令，其中的 18868 就是 18864+4，这里 4 是指 1f 8b 08 前面有 4 个字节．
dd if=vmlinuz-4.4.0-21-generic bs=1 skip=18868 | zcat &amp;gt; vmlinuz-gakki
objdump -D vmlinuz-gakki &amp;raquo; result
我们可以看到，最终得到的 result 就是一个汇编文件．而 vmlinuz-gakki 文件本质上是一个可执行程序．可以尝试
执行他，chmod +x vmlinuz-gakki &amp;amp;&amp;amp;./vmlinuz-gakki ．
显示 Segmentation fault&lt;/p>
&lt;p>intrid 分析
首先将/boot/intird.img 文件复制到/tmp 文件夹下
执行 file /tmp/initrd.img-4.4.0-21-generic，得到的结果如下：
/tmp/initrd.img-4.4.0-21-generic: gzip compressed data, last modified: Fri Jun 15 13:57:43 2018, from Unix
可以看到本质上这是一个 gzip 格式的压缩文件
cd /tmp
mv initrd.img-4.4.0-21-generic initrd.img-4.4.0-21-generic.gz
gzip -d initrd.img-4.4.0-21-generic.gz
file initrd.img-4.4.0-21-generic
得到的结果为：
initrd.img-4.4.0-21-generic: ASCII cpio archive (SVR4 with no CRC)
这是一个 cpio 文件
执行 cpio -idmv &amp;lt; initrd.img-4.4.0-21-generic
这样，我们可以看到它最终生成了一个小型的文件系统．&lt;/p>
&lt;h2 id="systemd-运行">Systemd 运行&lt;/h2>
&lt;p>详见 《[Systemd 运行流程](/docs/IT学习笔记/1.操作系统/3.Systemd%20 系统守护程序/Systemd%20 运行流程.md 系统守护程序/Systemd 运行流程.md)》章节&lt;/p></description></item></channel></rss>