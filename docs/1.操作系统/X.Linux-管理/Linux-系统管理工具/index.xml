<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>断念梦 – Linux 系统管理工具</title><link>https://desistdaydream.github.io/docs/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/X.Linux-%E7%AE%A1%E7%90%86/Linux-%E7%B3%BB%E7%BB%9F%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/</link><description>Recent content in Linux 系统管理工具 on 断念梦</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><atom:link href="https://desistdaydream.github.io/docs/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/X.Linux-%E7%AE%A1%E7%90%86/Linux-%E7%B3%BB%E7%BB%9F%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/index.xml" rel="self" type="application/rss+xml"/><item><title>Docs: CPU 管理工具</title><link>https://desistdaydream.github.io/docs/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/X.Linux-%E7%AE%A1%E7%90%86/Linux-%E7%B3%BB%E7%BB%9F%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/CPU-%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/X.Linux-%E7%AE%A1%E7%90%86/Linux-%E7%B3%BB%E7%BB%9F%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/CPU-%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;/blockquote></description></item><item><title>Docs: Memory 管理工具</title><link>https://desistdaydream.github.io/docs/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/X.Linux-%E7%AE%A1%E7%90%86/Linux-%E7%B3%BB%E7%BB%9F%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/Memory-%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/X.Linux-%E7%AE%A1%E7%90%86/Linux-%E7%B3%BB%E7%BB%9F%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/Memory-%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;/blockquote>
&lt;h1 id="查看-memory-的使用情况">查看 Memory 的使用情况&lt;/h1>
&lt;p>我们可以通过多种方式查看 Memory 信息。&lt;/p>
&lt;h2 id="procmeminfo-文件">/proc/meminfo 文件&lt;/h2>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://access.redhat.com/solutions/406773">RedHat 官方给的解释&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>该文件报告有关系统上内存使用情况的统计信息。 free 命令使用该文件来报告系统上的可用内存和已使用内存（物理内存和交换内存）以及内核使用的共享内存和缓冲区的数量。该文件是以 &lt;code>:&lt;/code> 符号分割的 &lt;strong>Key/Value pair(键/值对)&lt;/strong> 格式。可用参数及其详解如下：&lt;/p>
&lt;h3 id="memtotal">MemTotal&lt;/h3>
&lt;p>总可用 Memory。即.物理 RAM 减去一些保留的 bits 和内核二进制代码所用的量&lt;/p>
&lt;h3 id="memfree">MemFree&lt;/h3>
&lt;p>空闲的 Memory。LowFree 与 HighFree 两个参数的值的和&lt;/p>
&lt;h3 id="memavailable">MemAvailable&lt;/h3>
&lt;p>可用的 Memory。估算值，估计有多少内存可用于启动新的应用程序&lt;/p>
&lt;h3 id="buffers-与-cached">Buffers 与 Cached&lt;/h3>
&lt;p>详见：《&lt;a href="docs/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2.Kernel/5.Memory/Memory%20%E7%9A%84%E7%BC%93%E5%AD%98.md">Memory 的缓存&lt;/a>》&lt;/p>
&lt;h3 id="active">Active&lt;/h3>
&lt;p>最近使用过的 Memory。除非必要，否则通常不会回收。&lt;/p>
&lt;h3 id="inactive">Inactive&lt;/h3>
&lt;p>最近使用比较收的 Memory。这些内存会被优先回收。&lt;/p>
&lt;h3 id="slab">Slab&lt;/h3>
&lt;p>内核数据结构缓存。dentry、inode_cache 等&lt;/p>
&lt;h3 id="sreclaimable">SReclaimable&lt;/h3>
&lt;p>Slab Reclaimable。Slab 的一部分，可以被 reclaimed(回收)。例如 dentry、inode 的缓存等等。&lt;/p>
&lt;h3 id="sunreclaim">SUnreclaim&lt;/h3>
&lt;p>Slab UnReclaim。Slab 的一部分，不可以被 reclaimed(回收)。即使内存有压力也无法回收&lt;/p>
&lt;h3 id="commitlimit">CommitLimit&lt;/h3>
&lt;p>提交限制。当前可以分配的内存上限。只有当 [/proc/sys/vm/overcommit_memory](net(网络相关参数).md Kernel/Kernel 参数/net(网络相关参数).md) 的参数值为 2 的时候，该限制才生效。这个上限是指当程序向系统申请内存时，如果申请的内存加上现在已经分配的内存，超过了 commitlimit 的值，则该申请将会失败。&lt;/p>
&lt;p>该值通过如下公式：
&lt;code>CommitLimit = (total_RAM - total_huge_TLB) * overcommit_ratio / 100 + total_swap&lt;/code>&lt;/p>
&lt;ul>
&lt;li>totaol_RAM # 系统内存总量(就是物理内存)&lt;/li>
&lt;li>total_huge_TLB # 为 huge pages 保留的内存量，一般没有保留，都是 0&lt;/li>
&lt;li>overcommit_ratio # /proc/sys/vm/overcommit_ratio 内核参数的值。&lt;/li>
&lt;li>total_swap # swap 空间的总量&lt;/li>
&lt;/ul>
&lt;h3 id="committed_as">Committed_AS&lt;/h3>
&lt;blockquote>
&lt;p>Allocated Size(已经分配的大小，简称 AS)&lt;/p>
&lt;/blockquote>
&lt;p>当前已经分配的内存总量。注意：不是正在使用的，而是已经分配的。&lt;/p>
&lt;p>当 overcommit_memory 参数的值为 2 时，该值不能超过 CommitLimit 的值。其余时候该值可以无限大。&lt;/p>
&lt;h3 id="vmallocxxx">VmallocXXX&lt;/h3>
&lt;p>参考：&lt;a href="https://zhuanlan.zhihu.com/p/77827102">https://zhuanlan.zhihu.com/p/77827102&lt;/a>&lt;/p>
&lt;ul>
&lt;li>VmallocTotal&lt;/li>
&lt;li>VmallocUsed&lt;/li>
&lt;li>VmallocChunk&lt;/li>
&lt;/ul>
&lt;p>注意：&lt;strong>VmallocTotal 会非常大，这是正常的&lt;/strong>&lt;/p>
&lt;h3 id="percpu">Percpu&lt;/h3>
&lt;h3 id="hardwarecorrupted">HardwareCorrupted&lt;/h3>
&lt;h3 id="anonhugepages">AnonHugePages&lt;/h3>
&lt;h3 id="cmaxxx">CmaXXX&lt;/h3>
&lt;ul>
&lt;li>CmaTotal&lt;/li>
&lt;li>CmaFree&lt;/li>
&lt;/ul>
&lt;h3 id="hugepagesxxx">HugePagesXXX&lt;/h3>
&lt;ul>
&lt;li>HugePages_Total&lt;/li>
&lt;li>HugePages_Free&lt;/li>
&lt;li>HugePages_Rsvd&lt;/li>
&lt;li>HugePages_Surp&lt;/li>
&lt;li>Hugepagesize&lt;/li>
&lt;/ul>
&lt;h3 id="directmapxxx">DirectMapXXX&lt;/h3>
&lt;ul>
&lt;li>DirectMap4k&lt;/li>
&lt;li>DirectMap2M&lt;/li>
&lt;li>DirectMap1G&lt;/li>
&lt;/ul>
&lt;h2 id="free-命令">free 命令&lt;/h2>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>~&lt;span style="color:#f92672">]&lt;/span>&lt;span style="color:#75715e"># free -h&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> total used free shared buff/cache available
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Mem: 3.8Gi 846Mi 506Mi 1.0Mi 2.5Gi 2.9Gi
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Swap: 0B 0B 0B
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Mem：设备上的真实内存&lt;/p>
&lt;ul>
&lt;li>total # 总计。该设备的总内存大小&lt;/li>
&lt;li>used # 已使用的。linux 对内存的使用量&lt;/li>
&lt;li>free # 空闲的。还剩多少内存可用&lt;/li>
&lt;li>shared # 共享内存&lt;/li>
&lt;li>buff # 缓冲区(buffer)。保存一些将要写入到硬盘中的数据。&lt;/li>
&lt;li>cache # 缓存。从硬盘中读出的数据存放到内存中，以便再次读取相同数据时速度更快。&lt;/li>
&lt;li>availabel # 可用的。free+buff/cache 合起来就是可用的。&lt;/li>
&lt;/ul>
&lt;h2 id="free-命令-与-procmeminfo-文件中信息的对应关系">free 命令 与 /proc/meminfo 文件中信息的对应关系&lt;/h2>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>free 命令输出&lt;/th>
&lt;th>&lt;code>/proc/meminfo&lt;/code>文件的字段&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>&lt;code>Mem: total&lt;/code>&lt;/td>
&lt;td>&lt;code>MemTotal&lt;/code>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>Mem: used&lt;/code>&lt;/td>
&lt;td>&lt;code>MemTotal - MemFree - Buffers - Cached - SReclaimable&lt;/code>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>Mem: free&lt;/code>&lt;/td>
&lt;td>&lt;code>MemFree&lt;/code>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>Mem: shared&lt;/code>&lt;/td>
&lt;td>&lt;code>Shmem&lt;/code>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>Mem: buff/cache&lt;/code>&lt;/td>
&lt;td>&lt;code>Buffers + Cached + Slab&lt;/code>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>Mem:available&lt;/code>&lt;/td>
&lt;td>&lt;code>MemAvailable&lt;/code>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>Swap: total&lt;/code>&lt;/td>
&lt;td>&lt;code>SwapTotal&lt;/code>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>Swap: used&lt;/code>&lt;/td>
&lt;td>&lt;code>SwapTotal - SwapFree&lt;/code>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>Swap: free&lt;/code>&lt;/td>
&lt;td>&lt;code>SwapFree&lt;/code>&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h1 id="一个可以消耗-linux-内存的-shell-脚本">一个可以消耗 Linux 内存的 Shell 脚本&lt;/h1>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#!/bin/bash
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>mkdir /tmp/memory
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>mount -t tmpfs -o size&lt;span style="color:#f92672">=&lt;/span>1024M tmpfs /tmp/memory
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>dd &lt;span style="color:#66d9ef">if&lt;/span>&lt;span style="color:#f92672">=&lt;/span>/dev/zero of&lt;span style="color:#f92672">=&lt;/span>/tmp/memory/block
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>sleep &lt;span style="color:#ae81ff">3600&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>rm /tmp/memory/block
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>umount /tmp/memory
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>rmdir /tmp/memory
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div></description></item><item><title>Docs: 磁盘与文件系统管理工具</title><link>https://desistdaydream.github.io/docs/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/X.Linux-%E7%AE%A1%E7%90%86/Linux-%E7%B3%BB%E7%BB%9F%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/%E7%A3%81%E7%9B%98%E4%B8%8E%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/X.Linux-%E7%AE%A1%E7%90%86/Linux-%E7%B3%BB%E7%BB%9F%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/%E7%A3%81%E7%9B%98%E4%B8%8E%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/</guid><description/></item><item><title>Docs: 文件与文件系统管理工具</title><link>https://desistdaydream.github.io/docs/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/X.Linux-%E7%AE%A1%E7%90%86/Linux-%E7%B3%BB%E7%BB%9F%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/%E6%96%87%E4%BB%B6%E4%B8%8E%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/X.Linux-%E7%AE%A1%E7%90%86/Linux-%E7%B3%BB%E7%BB%9F%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/%E6%96%87%E4%BB%B6%E4%B8%8E%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/</guid><description/></item><item><title>Docs: Cron</title><link>https://desistdaydream.github.io/docs/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/X.Linux-%E7%AE%A1%E7%90%86/Linux-%E7%B3%BB%E7%BB%9F%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/Cron/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/X.Linux-%E7%AE%A1%E7%90%86/Linux-%E7%B3%BB%E7%BB%9F%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/Cron/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Cron">Wiki，Cron&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>软件实用程序 Cron 也称为 Cron Job(定时任务)，是类 Unix 计算机操作系统中基于时间的 &lt;a href="docs/8.%E9%80%9A%E7%94%A8%E6%8A%80%E6%9C%AF/Job/Job.md">Job 调度&lt;/a> 程序。设置和维护软件环境的用户使用 cron 来调度作业 (命令或 shell 脚本)，以便在固定的时间、日期或时间间隔定期运行。&lt;/p>
&lt;p>cron 的操作由 &lt;strong>Cron Table(计划任务表，简称 crontab)&lt;/strong> 文件驱动，该文件是一个配置文件，用于指定按给定计划定期运行的命令。 crontab 文件存储在保存作业列表和 cron 守护程序的其他指令的位置。用户可以拥有自己的个人 crontab 文件，并且通常有一个系统范围的 crontab 文件（通常在 /etc 或 /etc 的子目录中），只有系统管理员才能编辑。&lt;/p>
&lt;h2 id="syntax语法">Syntax(语法)&lt;/h2>
&lt;p>Cron Table 的格式如下：&lt;/p>
&lt;pre>&lt;code># ┌───────────── minute (0 - 59)
# │ ┌───────────── hour (0 - 23)
# │ │ ┌───────────── day of the month (1 - 31)
# │ │ │ ┌───────────── month (1 - 12)
# │ │ │ │ ┌───────────── day of the week (0 - 6) (Sunday to Saturday;
# │ │ │ │ │ 7 is also Sunday on some systems)
# │ │ │ │ │
# │ │ │ │ │
# * * * * * &amp;lt;COMMAND&amp;gt;
&lt;/code>&lt;/pre>
&lt;p>一个 crontab 中可以有多行，每行都代表一个 Job。&lt;/p>
&lt;p>crontab 特殊的符号说明：&lt;/p>
&lt;ul>
&lt;li>&lt;code>*&lt;/code> 代表所有的取值范围内的数字。特别要注意哦！&lt;/li>
&lt;li>&lt;code>/&lt;/code> 代表每的意思，如 &lt;code>*/5&lt;/code> 表示每 5 个单位&lt;/li>
&lt;li>&lt;code>-&lt;/code> 代表从某个数字到某个数字&lt;/li>
&lt;li>&lt;code>,&lt;/code> 分散的数字&lt;/li>
&lt;/ul>
&lt;h2 id="基本示例">基本示例&lt;/h2>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>分&lt;/th>
&lt;th>时&lt;/th>
&lt;th>日&lt;/th>
&lt;th>月&lt;/th>
&lt;th>年&lt;/th>
&lt;th>命令&lt;/th>
&lt;th>描述&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>*&lt;/td>
&lt;td>*&lt;/td>
&lt;td>*&lt;/td>
&lt;td>*&lt;/td>
&lt;td>*&lt;/td>
&lt;td>ls&lt;/td>
&lt;td>每分钟执行 ls 命令&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>5&lt;/td>
&lt;td>*&lt;/td>
&lt;td>*&lt;/td>
&lt;td>*&lt;/td>
&lt;td>*&lt;/td>
&lt;td>ls&lt;/td>
&lt;td>每小时的第 5 分钟执行 ls 命令&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>*/15&lt;/td>
&lt;td>*&lt;/td>
&lt;td>*&lt;/td>
&lt;td>*&lt;/td>
&lt;td>*&lt;/td>
&lt;td>ls&lt;/td>
&lt;td>每 15 分钟执行命令(i.e.每个小时的第 0 15 30 45 60 分钟执行 ls 命令)&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;ul>
&lt;li>0 0 * * * COMMAND # 每天 0 点 0 分执行一次 ls 命令&lt;/li>
&lt;li>2 8-20/3 * * * COMMAND # 每天 8:02,11:02,14:02,17:02,20:02 这几个时间执行&lt;/li>
&lt;li>0/15 0 * * * COMMAND # 每天 0 点到 1 点这一段时间，每隔 15 分钟执行命令&lt;/li>
&lt;li>30 5,17 * * * COMMAND # 每天 5:30 和 17:30 执行命令&lt;/li>
&lt;li>0 0 1 * * COMMAND # 每月 1 号的 0 点 0 分，执行命令&lt;/li>
&lt;li>0 0 _/7 _ * COMMAND # 每隔 7 天&lt;/li>
&lt;li>30 5 8 6 * COMMAND # 指定每年的 6 月 8 日 5：30 执行命令&lt;/li>
&lt;li>30 6 * * 0 COMMAND # 指定每星期日的 6:30 执行命令&lt;/li>
&lt;/ul>
&lt;h1 id="crontab">crontab&lt;/h1>
&lt;p>Linux 中的 crontab 程序可以实现定时任务功能&lt;/p>
&lt;h1 id="概述-1">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;h2 id="关联文件与配置">关联文件与配置&lt;/h2>
&lt;p>&lt;strong>/etc/crontab&lt;/strong> # corntab 程序运行时配置文件&lt;/p>
&lt;p>&lt;strong>/var/mail/${USERNAME}&lt;/strong> # 任务执行结果存放文件&lt;/p>
&lt;p>&lt;strong>/var/log/cron&lt;/strong> # 任务日志&lt;/p>
&lt;h1 id="crontab-命令行工具">crontab 命令行工具&lt;/h1>
&lt;h2 id="example">EXAMPLE&lt;/h2>
&lt;p>crontab -l # 查看定时任务&lt;/p>
&lt;p>crontab -e # 创建定时任务（直接对文本进行增加）&lt;/p>
&lt;p>新增定时任务可用两种方法：&lt;/p>
&lt;ul>
&lt;li>在命令行输入: crontab -e 然后添加相应的任务，wq 存盘退出。&lt;/li>
&lt;li>直接编辑 /etc/crontab 文件，即 vi /etc/crontab，添加相应的任务。&lt;/li>
&lt;/ul></description></item><item><title>Docs: BCC 工具集</title><link>https://desistdaydream.github.io/docs/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/X.Linux-%E7%AE%A1%E7%90%86/Linux-%E7%B3%BB%E7%BB%9F%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/BCC-%E5%B7%A5%E5%85%B7%E9%9B%86/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/X.Linux-%E7%AE%A1%E7%90%86/Linux-%E7%B3%BB%E7%BB%9F%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/BCC-%E5%B7%A5%E5%85%B7%E9%9B%86/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://iovisor.github.io/bcc/">官网&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://github.com/iovisor/bcc">GitHub 项目,iovisor/bcc&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>&lt;strong>BPF Compiler Collection(BPF 编译器合集，简称 BCC)&lt;/strong> 是用于创建有效的内核跟踪和操作程序的工具包。BCC 是 Linux 基金会旗下的 IO Visor 项目组做出来的基于 eBPF 的产品。BBC 主要用来为 Linux 提供 &lt;strong>Dynamic Tracing(动态追踪)&lt;/strong> 功能的实现。
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/ng174l/1619076409581-b90915a0-9bcb-4aa7-8ea4-4f0d66048ddd.png" alt="image.png">&lt;/p>
&lt;h1 id="bcc-安装">BCC 安装&lt;/h1>
&lt;h2 id="通过-linux-包管理器安装">通过 Linux 包管理器安装&lt;/h2>
&lt;h3 id="ubuntu">Ubuntu&lt;/h3>
&lt;p>标准的 Ubuntu Universe 仓库 与 iovisor 的 PPA 仓库中都可以用来安装 BCC 工具，但是包的名称不同。Ubuntu 安装完的程序，其名称会在最后加上 &lt;code>-bpfcc&lt;/code>。&lt;/p>
&lt;ul>
&lt;li>使用 Ubuntu 仓库安装&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>sudo apt-get install bpfcc-tools linux-headers-&lt;span style="color:#66d9ef">$(&lt;/span>uname -r&lt;span style="color:#66d9ef">)&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ul>
&lt;li>使用 iovisor 仓库安装&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>sudo apt-key adv --keyserver keyserver.ubuntu.com --recv-keys 4052245BD4284CDD
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>echo &lt;span style="color:#e6db74">&amp;#34;deb https://repo.iovisor.org/apt/&lt;/span>&lt;span style="color:#66d9ef">$(&lt;/span>lsb_release -cs&lt;span style="color:#66d9ef">)&lt;/span>&lt;span style="color:#e6db74"> &lt;/span>&lt;span style="color:#66d9ef">$(&lt;/span>lsb_release -cs&lt;span style="color:#66d9ef">)&lt;/span>&lt;span style="color:#e6db74"> main&amp;#34;&lt;/span> | sudo tee /etc/apt/sources.list.d/iovisor.list
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>sudo apt-get update
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>sudo apt-get install bcc-tools libbcc-examples linux-headers-&lt;span style="color:#66d9ef">$(&lt;/span>uname -r&lt;span style="color:#66d9ef">)&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="centos">CentOS&lt;/h3>
&lt;h1 id="bcc-工具概述">BCC 工具概述&lt;/h1>
&lt;p>命名规则
XXXsnoop 这类工具的名字通常用来追踪指定对象，snoop 有窥探之意。比如 opensnoop 工具用来追踪 open() 系统调用、execsnoop 工具用来追踪 exec() 系统调用 等等。&lt;/p>
&lt;p>&lt;strong>syscount&lt;/strong> # 追踪系统调用，并统计次数
&lt;strong>tcpconnect&lt;/strong> # 追踪活动的 TCP 连接，即 &lt;code>connect()&lt;/code> 系统调用。
&lt;strong>tcptracer&lt;/strong> # 追踪&lt;/p></description></item><item><title>Docs: bpftrace 工具</title><link>https://desistdaydream.github.io/docs/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/X.Linux-%E7%AE%A1%E7%90%86/Linux-%E7%B3%BB%E7%BB%9F%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/bpftrace-%E5%B7%A5%E5%85%B7/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/X.Linux-%E7%AE%A1%E7%90%86/Linux-%E7%B3%BB%E7%BB%9F%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/bpftrace-%E5%B7%A5%E5%85%B7/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://github.com/iovisor/bpftrace">GitHub 项目，iovisor/bpftrace&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>bpftrace 是用于 Linux 增强型 eBPF 的高级跟踪语言，可在最近的 Linux 内核 (4.x) 中使用。 bpftrace 使用 LLVM 作为后端，将脚本编译为 BPF 字节码，并利用 BCC 与 Linux BPF 系统交互，以及现有的 Linux 跟踪功能：内核动态跟踪（kprobes）、用户级动态跟踪（uprobes）、和跟踪点。 bpftrace 语言的灵感来自 awk 和 C，以及 DTrace 和 SystemTap 等前身跟踪器。 bpftrace 是由 Alastair Robertson 创建的。、&lt;/p>
&lt;p>&lt;strong>简单示例&lt;/strong>&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># Files opened by process&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>bpftrace -e &lt;span style="color:#e6db74">&amp;#39;tracepoint:syscalls:sys_enter_open { printf(&amp;#34;%s %s\n&amp;#34;, comm, str(args-&amp;gt;filename)); }&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># Syscall count by program&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>bpftrace -e &lt;span style="color:#e6db74">&amp;#39;tracepoint:raw_syscalls:sys_enter { @[comm] = count(); }&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># Read bytes by process:&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>bpftrace -e &lt;span style="color:#e6db74">&amp;#39;tracepoint:syscalls:sys_exit_read /args-&amp;gt;ret/ { @[comm] = sum(args-&amp;gt;ret); }&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># Read size distribution by process:&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>bpftrace -e &lt;span style="color:#e6db74">&amp;#39;tracepoint:syscalls:sys_exit_read { @[comm] = hist(args-&amp;gt;ret); }&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># Show per-second syscall rates:&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>bpftrace -e &lt;span style="color:#e6db74">&amp;#39;tracepoint:raw_syscalls:sys_enter { @ = count(); } interval:s:1 { print(@); clear(@); }&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># Trace disk size by process&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>bpftrace -e &lt;span style="color:#e6db74">&amp;#39;tracepoint:block:block_rq_issue { printf(&amp;#34;%d %s %d\n&amp;#34;, pid, comm, args-&amp;gt;bytes); }&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># Count page faults by process&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>bpftrace -e &lt;span style="color:#e6db74">&amp;#39;software:faults:1 { @[comm] = count(); }&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># Count LLC cache misses by process name and PID (uses PMCs):&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>bpftrace -e &lt;span style="color:#e6db74">&amp;#39;hardware:cache-misses:1000000 { @[comm, pid] = count(); }&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># Profile user-level stacks at 99 Hertz, for PID 189:&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>bpftrace -e &lt;span style="color:#e6db74">&amp;#39;profile:hz:99 /pid == 189/ { @[ustack] = count(); }&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># Files opened, for processes in the root cgroup-v2&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>bpftrace -e &lt;span style="color:#e6db74">&amp;#39;tracepoint:syscalls:sys_enter_openat /cgroup == cgroupid(&amp;#34;/sys/fs/cgroup/unified/mycg&amp;#34;)/ { printf(&amp;#34;%s\n&amp;#34;, str(args-&amp;gt;filename)); }&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div></description></item><item><title>Docs: Cockpit</title><link>https://desistdaydream.github.io/docs/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/X.Linux-%E7%AE%A1%E7%90%86/Linux-%E7%B3%BB%E7%BB%9F%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/Cockpit/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/X.Linux-%E7%AE%A1%E7%90%86/Linux-%E7%B3%BB%E7%BB%9F%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/Cockpit/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>官网：&lt;a href="https://cockpit-project.org/">https://cockpit-project.org/&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>cockpit 是一个基于 web 的 Linxu 服务器管理工具。可以通过 web 端管理服务器上的虚拟机、容器、服务、网络、存储等等。还可以提供一个 web 版的控制台。&lt;/p>
&lt;h1 id="cockpit-关联文件与配置">Cockpit 关联文件与配置&lt;/h1>
&lt;p>&lt;strong>/etc/cockpit/&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>&lt;strong>./ws-certs.d/&lt;/strong> # https 证书保存目录。cockpit 第一次启动时，会在该目录生成 https 所需的 证书与私钥&lt;/li>
&lt;/ul></description></item><item><title>Docs: perf 性能分析工具</title><link>https://desistdaydream.github.io/docs/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/X.Linux-%E7%AE%A1%E7%90%86/Linux-%E7%B3%BB%E7%BB%9F%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/perf-%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/X.Linux-%E7%AE%A1%E7%90%86/Linux-%E7%B3%BB%E7%BB%9F%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/perf-%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7/</guid><description/></item><item><title>Docs: procps 工具集</title><link>https://desistdaydream.github.io/docs/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/X.Linux-%E7%AE%A1%E7%90%86/Linux-%E7%B3%BB%E7%BB%9F%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/procps-%E5%B7%A5%E5%85%B7%E9%9B%86/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/X.Linux-%E7%AE%A1%E7%90%86/Linux-%E7%B3%BB%E7%BB%9F%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/procps-%E5%B7%A5%E5%85%B7%E9%9B%86/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://gitlab.com/procps-ng/procps">GitLab 项目，procps-ng/procps&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>procps 是一组命令行和全屏实用程序，它们主要从 &lt;a href="docs/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2.Kernel/6.Filesystem/%E7%89%B9%E6%AE%8A%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/Proc%20File%20System.md">Proc 文件系统&lt;/a> 中获取信心，该文件系统为内核数据结构提供了一个简单的接口。procps 程序通常集中在描述系统上运行的进程的结构上。包括以下程序(每个标题都是一个程序)&lt;/p>
&lt;p>Note：该工具集就算是最小化安装的 linux 发行版系统也是默认包含的~&lt;/p>
&lt;h1 id="free---显示系统中可用和已用的内存量">free - 显示系统中可用和已用的内存量&lt;/h1>
&lt;h1 id="kill-向指定pid的进程发送信号">kill-向指定PID的进程发送信号&lt;/h1>
&lt;p>可用的信号详见 &lt;a href="docs/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2.Kernel/7.Process/Inter%20Process%20Communication(%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1)/Signal(%E4%BF%A1%E5%8F%B7).md">Signal(信号)&lt;/a>&lt;/p>
&lt;p>kill 命令将指定的信号发送到指定的进程或进程组。 如果未指定信号，则发送 TERM 信号。 TERM 信号将杀死不捕获该信号的进程。对于其他过程，由于无法捕获该信号，可能需要使用 KILL（9）信号。&lt;/p>
&lt;p>大多数现代 Shell 具有内置的 kill 函数，其用法与此处描述的命令非常相似。 &amp;lsquo;-a&amp;rsquo; 和&amp;rsquo;-p&amp;rsquo; 选项以及通过命令名称指定进程的可能性是 本地扩展。&lt;/p>
&lt;p>如果 sig 为 0，则不发送信号，但仍执行错误检查。&lt;/p>
&lt;p>“信号 0” 有点像精神上的 “ping”。在 shell 程序脚本中使用 kill -0 PID 是判断 PID 是否有效的好方法。信号 0 仅用于检查进程是否存在。&lt;/p>
&lt;h2 id="syntax语法">Syntax(语法)&lt;/h2>
&lt;p>&lt;a href="docs/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/X.Linux%20%E7%AE%A1%E7%90%86/Linux%20%E7%B3%BB%E7%BB%9F%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/sysstat%20%E5%B7%A5%E5%85%B7%E9%9B%86.md">sysstat 工具集&lt;/a>&lt;/p>
&lt;p>&lt;strong>kill [-s signal|-p] [-q sigval] [-a] [&amp;ndash;] pid&amp;hellip;&lt;/strong>&lt;/p>
&lt;h1 id="pgreppkillpidwait-根据名字或其他属性列出进程发送信号暂停进程">pgrep，pkill，pidwait-根据名字或其他属性列出进程、发送信号、暂停进程&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://man7.org/linux/man-pages/man1/pgrep.1.html">Manual(手册)，pgrep(1)&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>pgrep 查看当前正在运行的进程，并列出所有符合匹配模式的进程 ID。比如：&lt;code>pgrep -u root sshd&lt;/code> 命令将会列出由 root 用户运行的进程命令中包含 &lt;code>sshd&lt;/code> 字符串的进程 ID。效果如下：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>~&lt;span style="color:#f92672">]&lt;/span>&lt;span style="color:#75715e"># pgrep -u root sshd -a&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">1521&lt;/span> sshd: /usr/sbin/sshd -D &lt;span style="color:#f92672">[&lt;/span>listener&lt;span style="color:#f92672">]&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span> of 10-100 startups
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">16257&lt;/span> sshd: root@pts/1
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">26155&lt;/span> sshd: root@pts/2
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">26266&lt;/span> sshd: root@notty
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="syntax语法-1">Syntax(语法)&lt;/h2>
&lt;p>&lt;strong>pgrep [OPTIONS] PATTERN&lt;/strong>&lt;/p>
&lt;p>&lt;strong>pkill [OPTIONS] PATTERN&lt;/strong>&lt;/p>
&lt;p>&lt;strong>pidwait [OPTIONS] PATTERN&lt;/strong>&lt;/p>
&lt;p>PATTERN(模式) 代指正则表达式的匹配模式。比如 pgrep 根据 PATTERN 中的内容匹配进程&lt;/p>
&lt;p>&lt;strong>OPTIONS：&lt;/strong>&lt;/p>
&lt;p>&lt;code>()&lt;/code> 表示该选项所适用的工具，若没有括号，则说明选项适用于所有三个工具&lt;/p>
&lt;ul>
&lt;li>&lt;strong>-SIGNAL, &amp;ndash;signal SIGNAL&lt;/strong> # (pkill)指定要发送的信号。可以使用数字或信号名称。&lt;/li>
&lt;li>&lt;strong>-f, &amp;ndash;full&lt;/strong> # 这三个程序通常只会对进程名称进行匹配。加上 -f 之后，会对进程的完整命令行进行匹配。
&lt;ul>
&lt;li>比如 &lt;code>pgrep -f containerd&lt;/code> 将会出现 &lt;code>3313 /usr/bin/dockerd --containerd=/run/containerd/containerd.sock&lt;/code> 这种结果。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>-l, &amp;ndash;list-full&lt;/strong> # (pgrep)显示出完整的命令行以及进程 ID&lt;/li>
&lt;li>&lt;strong>-t, &amp;ndash;terminal &amp;lt;TERM,&amp;hellip;&amp;gt;&lt;/strong> # 仅匹配使用指定终端的进程。终端名称不用使用绝对路径。&lt;/li>
&lt;li>&lt;strong>-x, &amp;ndash;exact&lt;/strong> # 精确匹配。PATTERN 必须与 进程名称 或 进程命令行 完全对应上才会被匹配到。&lt;/li>
&lt;/ul>
&lt;h2 id="example">EXAMPLE&lt;/h2>
&lt;ul>
&lt;li>列出名字中包含 docker 的进程号
&lt;ul>
&lt;li>&lt;strong>pgrep docker&lt;/strong>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>列出 containerd 进程的进程号
&lt;ul>
&lt;li>&lt;strong>pgrep -x containerd&lt;/strong>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>踢掉 TTY 为 pts/1 的用户
&lt;ul>
&lt;li>&lt;strong>pkill -kill -t pts/1&lt;/strong>&lt;/li>
&lt;li>注意：想要获取一个用户所使用的终端，可以通过 &lt;a href="#w%20-%20%E6%8A%A5%E5%91%8A%E5%B7%B2%E7%BB%8F%E7%99%BB%E5%BD%95%E7%9A%84%E7%94%A8%E6%88%B7%E5%92%8C%E8%BF%99%E4%BA%9B%E7%94%A8%E6%88%B7%E6%AD%A3%E5%9C%A8%E6%89%A7%E8%A1%8C%E7%9A%84%E5%91%BD%E4%BB%A4">procps 包中的 w 工具&lt;/a>即可&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h1 id="pmap---报告进程的内存映射">pmap - 报告进程的内存映射&lt;/h1>
&lt;h1 id="ps---报告进程的信息">ps - 报告进程的信息&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://man7.org/linux/man-pages/man1/ps.1.html">Manual(手册)，ps(1)&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>ps 是 &lt;strong>process status(进程状态)&lt;/strong> 的简称~&lt;/p>
&lt;p>Note：该命令显示出来的带 &lt;code>[]&lt;/code> 的进程为内核线程，一般不用关注。出现这种情况一般是因为 ps 命令无法获取进程的命令参数，所以会将命令名称放入括号中。毕竟用户态的 ps 命令怎么可能会获得内核内部程序的参数呢~~~&lt;/p>
&lt;p>ps 命令输出的内容中部分字段的含义说明：&lt;/p>
&lt;ul>
&lt;li>PID # Process ID(进程标识符)&lt;/li>
&lt;li>PPID # Parent Process ID(父进程标识符)，父进程是创建一个或多个子进程的进程。&lt;/li>
&lt;li>VSZ # Virtual Memory Size(虚拟内存大小)，包括进程可以访问的所有内存，包括进入交换分区的内容，以及共享库占用的内存。有的地方也称为 total_vm、VIRT&lt;/li>
&lt;li>RRS # Resident Set Size(实际内存用量)，不包括进入交换分区的内存。RSS 包括共享库占用的内存（只要共享库在内存中）。RSS 包括所有分配的栈内存和堆内存。&lt;/li>
&lt;li>LWP # 线程 ID&lt;/li>
&lt;li>NLWP # 线程数量&lt;/li>
&lt;li>STAT # 进程的当前状态
&lt;ul>
&lt;li>D # 不可中断的休眠。通常是 IO。&lt;/li>
&lt;li>R # 运行。正在运行或者在运行队列中等待。&lt;/li>
&lt;li>S # 休眠。在等待某个事件，信号。&lt;/li>
&lt;li>T # 停止。进程接收到信息 SIGSTOP，SIGSTP，SIGTIN，SIGTOU 信号。&lt;/li>
&lt;li>X # 死掉的进程，不应该出现。&lt;/li>
&lt;li>Z # 僵死进程。
&lt;ul>
&lt;li>通常还会跟随如下字母表示更详细的状态。
&lt;ul>
&lt;li>&amp;lt; 高优先级&lt;/li>
&lt;li>N 低优先级&lt;/li>
&lt;li>L 有 pages 在内存中 locked。用于实时或者自定义 IO。&lt;/li>
&lt;li>s 进程领导者，其有子进程。&lt;/li>
&lt;li>l 多线程
&lt;ul>
&lt;li>&lt;code>-&lt;/code> 位于前台进程组。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>可以使用 &lt;strong>-o FORMAT&lt;/strong> 选项来自定义输出的格式(就是字段)。 FORMAT 是单个参数，格式为空格分隔或逗号分隔的列表，它提供了一种指定单个输出列的方法。 可以在 man 手册的 &lt;a href="https://man7.org/linux/man-pages/man1/ps.1.html#STANDARD_FORMAT_SPECIFIERS">STANDARD FORMAT SPECIFIERS(标准格式说明符)&lt;/a> 部分中找到所有可用的关键字。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># 标题可以根据需要重命名&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>~&lt;span style="color:#f92672">]&lt;/span>&lt;span style="color:#75715e"># ps -o pid,ruser=RealUser -o comm=Command&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> PID RealUser Command
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ae81ff">4652&lt;/span> root bash
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ae81ff">4774&lt;/span> root ps
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># 可以不输出标题行。&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>~&lt;span style="color:#f92672">]&lt;/span>&lt;span style="color:#75715e"># ps -o pid= -o comm=&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ae81ff">4652&lt;/span> bash
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ae81ff">4787&lt;/span> ps
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># 列宽将根据宽标题增加； 这可以用来加宽WCHAN等列&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>~&lt;span style="color:#f92672">]&lt;/span>&lt;span style="color:#75715e"># ps -o pid,wchan=WIDE-WCHAN-COLUMN -o comm&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> PID WIDE-WCHAN-COLUMN COMMAND
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ae81ff">4652&lt;/span> - bash
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ae81ff">4789&lt;/span> - ps
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># 可以也提供显式宽度控制&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>~&lt;span style="color:#f92672">]&lt;/span>&lt;span style="color:#75715e"># ps opid,wchan:42,cmd&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> PID WCHAN CMD
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ae81ff">881&lt;/span> core_sys_select /sbin/agetty -o -p -- &lt;span style="color:#ae81ff">\u&lt;/span> --noclear tty1 linux
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ae81ff">4652&lt;/span> - -bash
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ae81ff">4790&lt;/span> - ps opid,wchan:42,cmd
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># 行为因人格而异； 输出可能是名为“ X，comm = Y”的一列或名为“ X”和“ Y”的两列。如有疑问，请使用多个-o选项。&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>~&lt;span style="color:#f92672">]&lt;/span>&lt;span style="color:#75715e"># ps -o pid=X,comm=Y&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> X Y
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ae81ff">4652&lt;/span> bash
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ae81ff">4791&lt;/span> ps
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># 仅输出 启动总时长、PID、进程命令 这三列&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>~&lt;span style="color:#f92672">]&lt;/span>&lt;span style="color:#75715e"># ps -p 38095 -o etime,pid,cmd&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ELAPSED PID CMD
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>10-03:22:51 &lt;span style="color:#ae81ff">38095&lt;/span> /bin/prometheus --web.console.templates&lt;span style="color:#f92672">=&lt;/span>/etc/prometheus/consoles --web.console.libraries&lt;span style="color:#f92672">=&lt;/span>/etc/prometheus/console_libraries --config.file&lt;span style="color:#f92672">=&lt;/span>/etc/prometheus/config_out/prometheus.yml
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>可用的 SPECIFIERS 有很多，下面仅列出常用的几个&lt;/p>
&lt;ul>
&lt;li>etime # 进程启动的总时长，格式为&lt;code>d-h:m:s&lt;/code>&lt;/li>
&lt;li>etimes # 进程启动的总时长，以秒为单位&lt;/li>
&lt;/ul>
&lt;h2 id="syntax语法-2">Syntax(语法)&lt;/h2>
&lt;p>&lt;strong>ps [OPTIONS]&lt;/strong>&lt;/p>
&lt;p>默认操作显示该 shell 环境下的所有进程&lt;/p>
&lt;h3 id="options">OPTIONS&lt;/h3>
&lt;h4 id="process-selection进程选择">PROCESS SELECTION(进程选择)&lt;/h4>
&lt;p>&lt;a href="https://man.cx/ps#heading5">https://man.cx/ps#heading5&lt;/a>&lt;/p>
&lt;p>一共有两种选择进程的方式，且两种方式互相冲突，比如使用 -e 选项后， -p 选项则毫无意义，依然会输出所有进程&lt;/p>
&lt;ul>
&lt;li>整体选择
&lt;ul>
&lt;li>&lt;strong>-e, -A&lt;/strong> # 选择所有进程，包括不在本 shell 环境下的进程进行展示&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>按列表选择
&lt;ul>
&lt;li>&lt;strong>-p, &amp;ndash;pid &amp;lt;PIDList&amp;gt;&lt;/strong> # 选择 PIDList 中列出来的进程。多个 PID 以逗号分隔&lt;/li>
&lt;li>&lt;strong>&amp;ndash;ppid &amp;lt;PIDList&amp;gt;&lt;/strong> # 选择 PIDList 中列出来的进程的子进程。多个 PID 以逗号分割&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>通用选择
&lt;ul>
&lt;li>&lt;strong>-N, &amp;ndash;deselect&lt;/strong> # 取消选择。也可以理解为 反向选择。即，选择“通过 整体选择 与 按列表选择 中选择到的”进程以外的所有进程&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h4 id="output-format-control输出格式控制">OUTPUT FORMAT CONTROL(输出格式控制)&lt;/h4>
&lt;p>&lt;a href="https://man.cx/ps#heading7">https://man.cx/ps#heading7&lt;/a>&lt;/p>
&lt;ul>
&lt;li>&lt;strong>-f&lt;/strong> # 更多显示信息&lt;/li>
&lt;li>&lt;strong>-l&lt;/strong> # 显示进程的详细信息&lt;/li>
&lt;li>&lt;strong>-o &amp;lt;FORMAT&amp;gt;&lt;/strong> # 使用指定的格式输出。&lt;/li>
&lt;li>&lt;strong>-ww&lt;/strong> # 更宽的输出，让输出的内容不受屏幕限制，可以换行显示&lt;/li>
&lt;/ul>
&lt;h4 id="output-modifiers输出模式">OUTPUT MODIFIERS(输出模式)&lt;/h4>
&lt;p>&lt;a href="https://man.cx/ps#heading8">https://man.cx/ps#heading8&lt;/a>&lt;/p>
&lt;ul>
&lt;li>&lt;strong>f,&amp;ndash;forest&lt;/strong> # 以树状结构显示输出结果。与显示线程的选项冲突&lt;/li>
&lt;li>&lt;strong>-o &amp;lt;FORMAT&amp;gt;&lt;/strong> # 以自定义的格式 FORMAT 输出信息。FORMAT 是以逗号或空格分隔的参数列表，详见前文&lt;/li>
&lt;/ul>
&lt;h4 id="thread-display线程显示">THREAD DISPLAY(线程显示)&lt;/h4>
&lt;p>&lt;a href="https://man.cx/ps#heading9">https://man.cx/ps#heading9&lt;/a>&lt;/p>
&lt;p>显示线程的选项与 -f, &amp;ndash;forest 选项不可同时使用。&lt;/p>
&lt;ul>
&lt;li>&lt;strong>-T&lt;/strong> # 显示线程，会多出 SPID 列，这列为 线程 号&lt;/li>
&lt;/ul>
&lt;h2 id="example-1">EXAMPLE&lt;/h2>
&lt;p>简单使用&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>~&lt;span style="color:#f92672">]&lt;/span>&lt;span style="color:#75715e"># ps -elf&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>F S UID         PID   PPID  C PRI  NI ADDR SZ WCHAN  STIME TTY          TIME CMD
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">4&lt;/span> S root          &lt;span style="color:#ae81ff">1&lt;/span>      &lt;span style="color:#ae81ff">0&lt;/span>  &lt;span style="color:#ae81ff">0&lt;/span>  &lt;span style="color:#ae81ff">80&lt;/span>   &lt;span style="color:#ae81ff">0&lt;/span> - &lt;span style="color:#ae81ff">32013&lt;/span> ep_pol 15:16 ?        00:00:01 /usr/lib/systemd/systemd --switched-root --system --deserialize &lt;span style="color:#ae81ff">2&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">1&lt;/span> S root          &lt;span style="color:#ae81ff">2&lt;/span>      &lt;span style="color:#ae81ff">0&lt;/span>  &lt;span style="color:#ae81ff">0&lt;/span>  &lt;span style="color:#ae81ff">80&lt;/span>   &lt;span style="color:#ae81ff">0&lt;/span> -     &lt;span style="color:#ae81ff">0&lt;/span> kthrea 15:16 ?        00:00:00 &lt;span style="color:#f92672">[&lt;/span>kthreadd&lt;span style="color:#f92672">]&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>~&lt;span style="color:#f92672">]&lt;/span>&lt;span style="color:#75715e"># ps aux&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>USER        PID %CPU %MEM    VSZ   RSS TTY      STAT START   TIME COMMAND
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>root          &lt;span style="color:#ae81ff">1&lt;/span>  0.0  0.4 &lt;span style="color:#ae81ff">128052&lt;/span>  &lt;span style="color:#ae81ff">6596&lt;/span> ?        Ss   15:16   0:01 /usr/lib/systemd/systemd --switched-root --system --deserialize &lt;span style="color:#ae81ff">22&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>root          &lt;span style="color:#ae81ff">2&lt;/span>  0.0  0.0      &lt;span style="color:#ae81ff">0&lt;/span>     &lt;span style="color:#ae81ff">0&lt;/span> ?        S    15:16   0:00 &lt;span style="color:#f92672">[&lt;/span>kthreadd&lt;span style="color:#f92672">]&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>显示 ps 的完整内容，不受 COMMAND 命令有字符限制影响。说白了就是，让过长的内容可以换行显示，而不是截断&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>~&lt;span style="color:#f92672">]&lt;/span>&lt;span style="color:#75715e"># ps -efww&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>以树状形式显示，且带中括号的内核进程将会放在最上面，与下面的系统进程分开，显示较为直观，效果如下&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>~&lt;span style="color:#f92672">]&lt;/span>&lt;span style="color:#75715e"># ps -ef f&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>root &lt;span style="color:#ae81ff">1&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span> Dec24 ? Ss 0:04 /usr/lib/systemd/systemd --switched-root --system --deserialize &lt;span style="color:#ae81ff">22&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>.......
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>root &lt;span style="color:#ae81ff">2827&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span> Dec24 ? Ss 0:00 /usr/sbin/sshd -D
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>root &lt;span style="color:#ae81ff">6400&lt;/span> &lt;span style="color:#ae81ff">2827&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span> 10:51 ? Ss 0:00 &lt;span style="color:#ae81ff">\_&lt;/span> sshd: root@pts/0
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>root &lt;span style="color:#ae81ff">6402&lt;/span> &lt;span style="color:#ae81ff">6400&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span> 10:51 pts/0 Ss 0:00 &lt;span style="color:#ae81ff">\_&lt;/span> -bash
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>root &lt;span style="color:#ae81ff">6720&lt;/span> &lt;span style="color:#ae81ff">6402&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span> 10:52 pts/0 R+ 0:00 &lt;span style="color:#ae81ff">\_&lt;/span> ps -ef f
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>不显示内核进程，以树状格式显示&lt;/p>
&lt;ul>
&lt;li>ps -N -p 2 &amp;ndash;ppid 2 -f f&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>~&lt;span style="color:#f92672">]&lt;/span>&lt;span style="color:#75715e"># ps --deselect -p 2 --ppid 2 -f f&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>UID PID PPID C STIME TTY STAT TIME CMD
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>root &lt;span style="color:#ae81ff">1&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span> Oct19 ? Ss 0:16 /usr/lib/systemd/systemd --switched-root --system --deserialize &lt;span style="color:#ae81ff">22&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>root &lt;span style="color:#ae81ff">478&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span> Oct19 ? Ss 0:03 /usr/lib/systemd/systemd-journald
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>root &lt;span style="color:#ae81ff">496&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span> Oct19 ? Ss 0:00 /usr/sbin/lvmetad -f
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>root &lt;span style="color:#ae81ff">502&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span> Oct19 ? Ss 0:00 /usr/lib/systemd/systemd-udevd
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>root &lt;span style="color:#ae81ff">630&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span> Oct19 ? S&amp;lt;sl 0:00 /sbin/auditd
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>polkitd &lt;span style="color:#ae81ff">653&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span> Oct19 ? Ssl 0:01 /usr/lib/polkit-1/polkitd --no-debug
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>root &lt;span style="color:#ae81ff">654&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span> Oct19 ? Ss 0:00 /usr/bin/qemu-ga --method&lt;span style="color:#f92672">=&lt;/span>virtio-serial --path&lt;span style="color:#f92672">=&lt;/span>/dev/virtio-ports/org.qemu.guest_agent.0 --blacklist&lt;span style="color:#f92672">=&lt;/span>guest-file-open,guest-file-close,guest-file-read,guest-file-write,guest-file-seek,guest-file-flush,guest-exec,guest-
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>root &lt;span style="color:#ae81ff">655&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span> Oct19 ? Ss 0:04 /usr/lib/systemd/systemd-logind
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>root &lt;span style="color:#ae81ff">657&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span> Oct19 ? Ss 0:16 /usr/sbin/irqbalance --foreground
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>dbus &lt;span style="color:#ae81ff">658&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span> Oct19 ? Ssl 0:06 /usr/bin/dbus-daemon --system --address&lt;span style="color:#f92672">=&lt;/span>systemd: --nofork --nopidfile --systemd-activation
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>root &lt;span style="color:#ae81ff">670&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span> Oct19 ? Ss 0:02 /usr/sbin/crond -n
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>chrony &lt;span style="color:#ae81ff">679&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span> Oct19 ? S 0:00 /usr/sbin/chronyd
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>root &lt;span style="color:#ae81ff">689&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span> Oct19 ? Ssl 1:14 /usr/sbin/NetworkManager --no-daemon
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>root &lt;span style="color:#ae81ff">990&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span> Oct19 ? Ssl 0:47 /usr/bin/python2 -Es /usr/sbin/tuned -l -P
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>root &lt;span style="color:#ae81ff">992&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span> Oct19 ? Ssl 0:24 /usr/sbin/rsyslogd -n
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>root &lt;span style="color:#ae81ff">14438&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span> Oct21 tty1 Ss+ 0:00 /sbin/agetty --noclear tty1 linux
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>root &lt;span style="color:#ae81ff">14445&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span> Oct21 ttyS0 Ss+ 0:00 /sbin/agetty --keep-baud 115200,38400,9600 ttyS0 vt220
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>root &lt;span style="color:#ae81ff">15151&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span> Oct21 ? Ss 0:00 sshd: /usr/sbin/sshd &lt;span style="color:#f92672">[&lt;/span>listener&lt;span style="color:#f92672">]&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span> of 10-100 startups
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>root &lt;span style="color:#ae81ff">17321&lt;/span> &lt;span style="color:#ae81ff">15151&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span> 09:18 ? Ss 0:00 &lt;span style="color:#ae81ff">\_&lt;/span> sshd: root@pts/0
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>root &lt;span style="color:#ae81ff">17325&lt;/span> &lt;span style="color:#ae81ff">17321&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span> 09:18 pts/0 Ss 0:00 &lt;span style="color:#ae81ff">\_&lt;/span> -bash
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>root &lt;span style="color:#ae81ff">17365&lt;/span> &lt;span style="color:#ae81ff">17325&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span> 09:23 pts/0 R+ 0:00 &lt;span style="color:#ae81ff">\_&lt;/span> ps --deselect -p &lt;span style="color:#ae81ff">2&lt;/span> --ppid &lt;span style="color:#ae81ff">2&lt;/span> -f f
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>这是(⊙o⊙)啥？~~&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>~&lt;span style="color:#f92672">]&lt;/span>&lt;span style="color:#75715e"># ps -eo rss,pid,user,command | sort -rn | head -10 | awk &amp;#39;{ hr\[1024**2]=&amp;#34;GB&amp;#34;; hr\[1024]=&amp;#34;MB&amp;#34;;for (x=1024**3; x&amp;gt;=1024; x/=1024) { if ($1&amp;gt;=x) { printf (&amp;#34;%-6.2f %s &amp;#34;, $1/x, hr\[x]); break }} } { printf (&amp;#34;%-6s %-10s &amp;#34;, $2, $3) }{ for ( x=4 ; x&amp;lt;=NF ; x++ ) { printf (&amp;#34;%s &amp;#34;,$x) } print (&amp;#34;\n&amp;#34;) }&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>15.94 MB &lt;span style="color:#ae81ff">627&lt;/span> root /usr/bin/python3 /usr/bin/networkd-dispatcher --run-startup-triggers
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>15.18 MB &lt;span style="color:#ae81ff">683&lt;/span> root /usr/bin/python3 /usr/share/unattended-upgrades/unattended-upgrade-shutdown --wait-for-signal
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h1 id="pwdx---report-current-directory-of-a-process">pwdx - Report current directory of a process&lt;/h1>
&lt;h1 id="skill---obsolete-version-of-pgreppkill">skill - Obsolete version of pgrep/pkill&lt;/h1>
&lt;h1 id="slabtop---display-kernel-slab-cache-information-in-real-time">slabtop - Display kernel slab cache information in real time&lt;/h1>
&lt;h1 id="snice---renice-a-process">snice - Renice a process&lt;/h1>
&lt;h1 id="sysctl---在运行时读取或写入内核参数">sysctl - 在运行时读取或写入内核参数&lt;/h1>
&lt;p>详见 &lt;a href="https://desistdaydream.github.io/docs/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/X.Linux%20%E7%AE%A1%E7%90%86/Linux%20%E5%86%85%E6%A0%B8%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/sysctl.md">sysctl&lt;/a>&lt;/p>
&lt;h1 id="tload---graphical-representation-of-system-load-average">tload - Graphical representation of system load average&lt;/h1>
&lt;h1 id="top运行中的进程的实时动态视图">top：运行中的进程的实时动态视图&lt;/h1>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>top - 14:06:23 up &lt;span style="color:#ae81ff">70&lt;/span> days, 16:44, &lt;span style="color:#ae81ff">2&lt;/span> users, load average: 1.25, 1.32, 1.35
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Tasks: &lt;span style="color:#ae81ff">206&lt;/span> total, &lt;span style="color:#ae81ff">1&lt;/span> running, &lt;span style="color:#ae81ff">205&lt;/span> sleeping, &lt;span style="color:#ae81ff">0&lt;/span> stopped, &lt;span style="color:#ae81ff">0&lt;/span> zombie
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Cpu&lt;span style="color:#f92672">(&lt;/span>s&lt;span style="color:#f92672">)&lt;/span>: 5.9%us, 3.4%sy, 0.0%ni, 90.4%id, 0.0%wa, 0.0%hi, 0.2%si, 0.0%st
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Mem: 32949016k total, 14411180k used, 18537836k free, 169884k buffers
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Swap: 32764556k total, 0k used, 32764556k free, 3612636k cached
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> PID USER PR NI VIRT RES SHR S %CPU %MEM TIME+ COMMAND
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">28894&lt;/span> root &lt;span style="color:#ae81ff">22&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span> 1501m 405m 10m S 52.2 1.3 2534:16 java
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">18249&lt;/span> root &lt;span style="color:#ae81ff">18&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span> 3201m 1.9g 11m S 35.9 6.0 569:39.41 java
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>第一行解析：任务队列信息，同 uptime 命令的执行结果，具体参数说明情况如下：&lt;/p>
&lt;ol>
&lt;li>14:06:23 # 当前系统时间&lt;/li>
&lt;li>up 70 days, 16:44 # 系统已经运行了 70 天 16 小时 44 分钟&lt;/li>
&lt;li>2 users # 当前有 2 个用户登录系统&lt;/li>
&lt;li>load average: 1.25, 1.32, 1.35 # load average 后面的三个数分别是 1 分钟、5 分钟、15 分钟的负载情况。
&lt;ol>
&lt;li>load average 数据是每隔 5 秒钟检查一次活跃的进程数，然后按特定算法计算出的数值。如果这个数除以逻辑 CPU 的数量，结果高于 5 的时候就表明系统在超负荷运转了。&lt;/li>
&lt;li>关于 load average 的说明详见：理解 load average—Linux 系统负荷&lt;/li>
&lt;/ol>
&lt;/li>
&lt;/ol>
&lt;p>第二行解析：Tasks # 任务（进程），具体信息说明如下：&lt;/p>
&lt;ol>
&lt;li>total # 系统全部的进程数。现在共有 206 个进程&lt;/li>
&lt;li>running # 运行状态的进程数&lt;/li>
&lt;li>sleeping # 睡眠状态的进程数&lt;/li>
&lt;li>stoped # 已经停止的状态的进程数&lt;/li>
&lt;li>zombie # 僵尸状态的进程数。&lt;/li>
&lt;/ol>
&lt;p>第三行解析：cpu 状态信息，显示了基于上次刷新时间间隔内，CPU 使用率的百分比。如果 top 命令每 1 秒刷新一次，则下面的信息为 1 秒时间内，CPU 被占用时间的百分比（也就意味着 us 占用 0.059 秒，sy 占用 0.034 秒，空闲了 0.904 秒，st 占用了 0.002 秒）。
具体属性说明如下：(且所有参数的值加起来应为 100%)&lt;/p>
&lt;ol>
&lt;li>5.9%us # user cpu time，未改变过 nice 值的用户空间进程的运行时间&lt;/li>
&lt;li>3.4% sy # system cpu time，内核空间进程的运行时间&lt;/li>
&lt;li>0.0% ni # user nice cpu time，已改变过 nice 值的用户空间进程的运行时间&lt;/li>
&lt;li>90.4% id # idle cpu time，CPU 空闲时间。&lt;/li>
&lt;li>0.0% wa # io wait cpu time，等待磁盘写入完成的时间。该值较高时，说明 IO 等待比较严重，这可能磁盘大量作随机访问造成的，也可能是磁盘性能出现了瓶颈。&lt;/li>
&lt;li>0.0% hi # hardware irq，硬中断（Hardware Interrupts）花费的时间&lt;/li>
&lt;li>0.2% si # software irq，软中断（Software Interrupts）花费的时间&lt;/li>
&lt;li>0.0% st # steal time，使用 hypervisor 管理的虚拟机偷取的时间&lt;/li>
&lt;/ol>
&lt;p>第四行解析：内存状态，具体信息如下：&lt;/p>
&lt;ol>
&lt;li>32949016k total — 物理内存总量（32GB）&lt;/li>
&lt;li>14411180k used — 使用中的内存总量（14GB）&lt;/li>
&lt;li>18537836k free — 空闲内存总量（18GB）&lt;/li>
&lt;li>169884k buffers — 缓存的内存量 （169M）&lt;/li>
&lt;/ol>
&lt;p>第五行解析：swap 交换分区信息，具体信息说明如下：&lt;/p>
&lt;ol>
&lt;li>32764556k total — 交换区总量（32GB）&lt;/li>
&lt;li>0k used — 使用的交换区总量（0K）&lt;/li>
&lt;li>32764556k free — 空闲交换区总量（32GB）&lt;/li>
&lt;li>3612636k cached — 缓冲的交换区总量（3.6GB）&lt;/li>
&lt;/ol>
&lt;p>第六行解析：以下各进程（任务）的状态监控，项目列信息说明如下：&lt;/p>
&lt;ol>
&lt;li>&lt;strong>PID&lt;/strong> # 进程 id&lt;/li>
&lt;li>&lt;strong>USER&lt;/strong> # 进程所有者&lt;/li>
&lt;li>&lt;strong>PR&lt;/strong> # 进程优先级&lt;/li>
&lt;li>&lt;strong>NI&lt;/strong> # nice 值。负值表示高优先级，正值表示低优先级&lt;/li>
&lt;li>&lt;strong>VIRT&lt;/strong> # 进程的虚拟内存总量，单位 KiB。即便还没有真正分配物理内存，也会计算在内。&lt;/li>
&lt;li>&lt;strong>RES&lt;/strong> # 进程常驻内存的大小，单位 KiB。是进程实际使用的物理内存的大小，但不包括 Swap 和 共享内存&lt;/li>
&lt;li>&lt;strong>SHR&lt;/strong> # 共享内存大小，单位 KiB。与其他进程共同使用的共享内存、加载的动态链接库、程序的代码段等等。&lt;/li>
&lt;li>&lt;strong>S&lt;/strong> # 进程状态。D=不可中断的睡眠状态 R=运行 S=睡眠 T=跟踪/停止 Z=僵尸进程&lt;/li>
&lt;li>&lt;strong>%CPU&lt;/strong> # 上次更新到现在的 CPU 时间占用百分比。注意：这个 CPU 的使用百分比为所有逻辑 CPU 的使用率总和，所有对于多核 CPU 的设备来说，该值很有可能会超过 100%&lt;/li>
&lt;li>&lt;strong>%MEM&lt;/strong> # 进程使用的物理内存百分比&lt;/li>
&lt;li>&lt;strong>TIME+&lt;/strong> # 进程使用的 CPU 时间总计，单位 1/100 秒&lt;/li>
&lt;li>&lt;strong>COMMAND&lt;/strong> # 进程名称（命令名/命令行）&lt;/li>
&lt;/ol>
&lt;h2 id="syntax语法-3">Syntax(语法)&lt;/h2>
&lt;p>&lt;strong>top [OPTIONS]&lt;/strong>
除了标注选项，当 top 运行时，可以通过快捷键进行一些操作&lt;/p>
&lt;ul>
&lt;li>&lt;strong>P&lt;/strong> # 按照 CPU 使用率排序&lt;/li>
&lt;li>&lt;strong>M&lt;/strong> # 按照内存使用率排序&lt;/li>
&lt;/ul>
&lt;p>OPTIONS&lt;/p>
&lt;ul>
&lt;li>&lt;strong>-d &amp;lt;NUM&amp;gt;&lt;/strong> # 设定整个进程视图更新的秒数，默认为 5 秒更新一次&lt;/li>
&lt;li>&lt;strong>-H&lt;/strong># 显示线程。 如果没有此命令行选项，则显示每个进程中所有线程的总和。 稍后，可以使用“ H”交互式命令来更改它。&lt;/li>
&lt;li>&lt;strong>-p &amp;lt;PID&amp;gt;&lt;/strong> # 指定 PID 进程进行观察&lt;/li>
&lt;/ul>
&lt;p>EXAMPLE&lt;/p>
&lt;ul>
&lt;li>1 # 展开第三行的 CPU，显示每个逻辑 CPU 的状态信息&lt;/li>
&lt;li>b # 高亮显示处于 Running 状态的进程&lt;/li>
&lt;li>f # 管理所要展示的字段(i.e.第六行的内容)以及按照指定的字段排序。
&lt;ul>
&lt;li>按 ↑↓ 选择要操作的字段&lt;/li>
&lt;li>按空格表示显示或不显示当前字段&lt;/li>
&lt;li>按 → 选中当前行，然后按 ↑↓ 将选中的行移动，以便变更该字段所在位置&lt;/li>
&lt;li>按 ← 取消选中当前行&lt;/li>
&lt;li>按 s 选择光标所在的行作为 排序 标准&lt;/li>
&lt;li>按 q 退出当前编辑界面。i.e.再次显示 top 面板&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>R # 按照 f 命令里指定的字段进行排序，倒序或者顺序&lt;/li>
&lt;li>查看 744 进程及其线程的动态试图
&lt;ul>
&lt;li>top -p 744 -H&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h1 id="uptime--显示系统运行了多长时间">uptime -显示系统运行了多长时间&lt;/h1>
&lt;h1 id="vmstat---报告虚拟内存状态还有-io系统cpu-等信息">vmstat - 报告虚拟内存状态，还有 io、系统、cpu 等信息&lt;/h1>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">[&lt;/span>root@ansible ~&lt;span style="color:#f92672">]&lt;/span>&lt;span style="color:#75715e"># vmstat -w&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>procs -----------------------memory---------------------- ---swap-- -----io---- -system-- --------cpu--------
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> r b swpd free buff cache si so bi bo in cs us sy id wa st
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ae81ff">0&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span> &lt;span style="color:#ae81ff">7282784&lt;/span> &lt;span style="color:#ae81ff">2148&lt;/span> &lt;span style="color:#ae81ff">463980&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span> &lt;span style="color:#ae81ff">8&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span> &lt;span style="color:#ae81ff">33&lt;/span> &lt;span style="color:#ae81ff">39&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span> &lt;span style="color:#ae81ff">100&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;strong>顶部字段说明：&lt;/strong>
procs&lt;/p>
&lt;ul>
&lt;li>r # 可运行的进程数(正在运行或等待运行)。即就绪队列的长度&lt;/li>
&lt;li>b # 等待 I/O 完成时阻塞(blocked)的进程数。即不可中断睡眠状态的进程数。&lt;/li>
&lt;/ul>
&lt;p>memory&lt;/p>
&lt;ul>
&lt;li>详见 内存管理。(单位是 KiB)&lt;/li>
&lt;/ul>
&lt;p>swap&lt;/p>
&lt;ul>
&lt;li>si # 每秒从 swap 到内存的大小。(单位是 KiB)&lt;/li>
&lt;li>so # 每秒从内存到 swap 的大小。(单位是 KiB)&lt;/li>
&lt;/ul>
&lt;p>io&lt;/p>
&lt;ul>
&lt;li>bi # 每秒从块设备接收的块数。即磁盘读取速度。&lt;/li>
&lt;li>bo # 每秒发送到块设备的块数。即磁盘写入速度。&lt;/li>
&lt;li>注意：bi 与 bo 的单位为&lt;code>块/秒&lt;/code>。因为 Linux 中块的大小是 1 KiB，所以这个单位也就等价于 KiB/s&lt;/li>
&lt;/ul>
&lt;p>system&lt;/p>
&lt;ul>
&lt;li>in # 每秒中断的次数。包括时钟的中断&lt;/li>
&lt;li>cs # 每秒上下文切换次数&lt;/li>
&lt;/ul>
&lt;p>cpu&lt;/p>
&lt;ul>
&lt;li>详见：CPU 使用率。(单位是百分比)&lt;/li>
&lt;/ul>
&lt;h2 id="syntax语法-4">Syntax(语法)&lt;/h2>
&lt;p>&lt;strong>vmstat [OTIONS] [DELAY [COUNT]]&lt;/strong>
DELAY # 延迟时间(单位是秒)。指定 DELAY 后，程序每隔 DELAY 时间运行一次。如果未指定 DELAY，则值输出一行结果，其中包含自 vmstat 启动到结束的平均值。&lt;/p>
&lt;ul>
&lt;li>&lt;strong>COUNT&lt;/strong> # 每隔 DELAY 时间，程序运行的次数。若不指定则一直运行。&lt;/li>
&lt;/ul>
&lt;p>OPTIONS&lt;/p>
&lt;ul>
&lt;li>&lt;strong>-w&lt;/strong> # 格式化输出。如果不加 -w ,则输出非常紧凑，不利于人们观察，且每行最大 80 字符。&lt;/li>
&lt;/ul>
&lt;p>EXAMPLE&lt;/p>
&lt;ul>
&lt;li>每隔一秒输出一行信息，一共输出 5 次
&lt;ul>
&lt;li>vmstat 1 5&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h1 id="w---报告已经登录的用户和这些用户正在执行的命令">w - 报告已经登录的用户和这些用户正在执行的命令&lt;/h1>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>root@lichenhao:~# w
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> 09:22:37 up 22:46, &lt;span style="color:#ae81ff">1&lt;/span> user, load average: 0.00, 0.00, 0.00
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>USER TTY FROM LOGIN@ IDLE JCPU PCPU WHAT
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>root pts/0 172.19.42.203 09:06 0.00s 0.21s 0.01s w
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ul>
&lt;li>USER：用哪个用户登录的&lt;/li>
&lt;li>TTY：为该用户开启的终端名&lt;/li>
&lt;li>FROM：该登录用户从哪个 IP 登录的&lt;/li>
&lt;li>LOGIN@：用户登录的时间&lt;/li>
&lt;li>IDLE：用户登录&lt;/li>
&lt;li>WHAT：该用户当前正在执行的命令&lt;/li>
&lt;/ul>
&lt;p>获取到的用户信息中，TTY 的信息可以被 pkill 工具使用，以踢掉用户，让其下线&lt;/p>
&lt;h1 id="watch---定期执行程序在全部屏幕上显示输出结果">watch - 定期执行程序，在全部屏幕上显示输出结果&lt;/h1>
&lt;p>该工具就是持续执行同一个命令，并实时显示&lt;/p></description></item><item><title>Docs: psmisc 工具集</title><link>https://desistdaydream.github.io/docs/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/X.Linux-%E7%AE%A1%E7%90%86/Linux-%E7%B3%BB%E7%BB%9F%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/psmisc-%E5%B7%A5%E5%85%B7%E9%9B%86/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/X.Linux-%E7%AE%A1%E7%90%86/Linux-%E7%B3%BB%E7%BB%9F%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/psmisc-%E5%B7%A5%E5%85%B7%E9%9B%86/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>项目地址：&lt;a href="https://gitlab.com/psmisc/psmisc">https://gitlab.com/psmisc/psmisc&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>psmisc 是一个小型的应用程序集合，与 procps-ng 工具集类似，都是使用伪文件系统(/proc)内的信息来展示系统信息&lt;/p>
&lt;p>该工具集包含包含以下程序(每个标题都是一个)&lt;/p>
&lt;h1 id="fuser---显示正在使用指定-文件-或-sockets-的进程">fuser - 显示正在使用指定 文件 或 sockets 的进程&lt;/h1>
&lt;p>fuser 使用指定的文件或文件系统显示进程的 PID。 在默认的显示模式下，每个文件名后都有一个字母，表示访问类型：&lt;/p>
&lt;ul>
&lt;li>c # 当前目录。&lt;/li>
&lt;li>e # 一个可执行文件正在运行。&lt;/li>
&lt;li>f # 打开文件。 在默认显示模式下省略 f。&lt;/li>
&lt;li>F # 打开文件进行写入。 默认显示模式下省略 F。&lt;/li>
&lt;li>r # 根目录。&lt;/li>
&lt;li>m # 映射文件或共享库。&lt;/li>
&lt;/ul>
&lt;h2 id="fuser-options">fuser [OPTIONS]&lt;/h2>
&lt;p>OPTIONS&lt;/p>
&lt;ul>
&lt;li>&lt;strong>-m&lt;/strong> # 显示使用命名文件系统或块设备的所有进程&lt;/li>
&lt;/ul>
&lt;h1 id="killall---通过进程名称向指定进程发送信号">killall - 通过进程名称向指定进程发送信号&lt;/h1>
&lt;p>与 kill 命令类似，但是不像 kill 只能指定进程的 PID，而是可以通过进程的名称来发送信号&lt;/p>
&lt;p>EXAMPLE：&lt;/p>
&lt;ul>
&lt;li>killall -0 nginx # 向名为 nginx 的进程发送 0 信号&lt;/li>
&lt;/ul>
&lt;h1 id="peekfd---shows-the-data-travelling-over-a-file-descriptor">peekfd - shows the data travelling over a file descriptor&lt;/h1>
&lt;h1 id="prtstat---输出一个进程的统计信息">prtstat - 输出一个进程的统计信息&lt;/h1>
&lt;h1 id="pslog---prints-log-paths-of-a-process">pslog - prints log path(s) of a process&lt;/h1>
&lt;h1 id="pstree---以树状显示当前正在运行的进程">pstree - 以树状显示当前正在运行的进程&lt;/h1>
&lt;p>该命令与 ps 类似，但是不会像 ps -ef 一样显示内核态进程&lt;/p>
&lt;h2 id="syntax语法">Syntax(语法)&lt;/h2>
&lt;p>pstree [OPTIONS] [USER or PID]&lt;/p>
&lt;p>OPTIONS:&lt;/p>
&lt;ul>
&lt;li>-p # 显示进程的 PID&lt;/li>
&lt;li>-a # 显示进程运行的命令行参数&lt;/li>
&lt;li>-c # 禁用相同分支的合并&lt;/li>
&lt;li>-h # 高亮显示当前进程及其父进程&lt;/li>
&lt;li>-H PID # 高亮显示指定进程&lt;/li>
&lt;li>-t # 显示完整的进程名称&lt;/li>
&lt;li>-s # 显示指定进程的父进程&lt;/li>
&lt;li>-n # 按 PID 排序&lt;/li>
&lt;li>-g # 显示 PGID。i.e 一个或多个进程组 ID&lt;/li>
&lt;/ul>
&lt;h2 id="example">EXAMPLE&lt;/h2>
&lt;ul>
&lt;li>pstree -n&lt;/li>
&lt;/ul>
&lt;p>以最简单的形式调用时没有任何选项或参数，&lt;code>pstree&lt;/code> 命令将显示所有正在运行的进程的分层树结构。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>$ pstree
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>systemd─┬─VBoxService───7*&lt;span style="color:#f92672">[{&lt;/span>VBoxService&lt;span style="color:#f92672">}]&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ├─accounts-daemon───2*&lt;span style="color:#f92672">[{&lt;/span>accounts-daemon&lt;span style="color:#f92672">}]&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ├─2*&lt;span style="color:#f92672">[&lt;/span>agetty&lt;span style="color:#f92672">]&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ├─atd
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ├─cron
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ├─dbus-daemon
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ├─irqbalance───&lt;span style="color:#f92672">{&lt;/span>irqbalance&lt;span style="color:#f92672">}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ├─2*&lt;span style="color:#f92672">[&lt;/span>iscsid&lt;span style="color:#f92672">]&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ├─lvmetad
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ├─lxcfs───2*&lt;span style="color:#f92672">[{&lt;/span>lxcfs&lt;span style="color:#f92672">}]&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ├─networkd-dispat───&lt;span style="color:#f92672">{&lt;/span>networkd-dispat&lt;span style="color:#f92672">}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ├─nginx───2*&lt;span style="color:#f92672">[&lt;/span>nginx&lt;span style="color:#f92672">]&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div></description></item><item><title>Docs: strace 工具</title><link>https://desistdaydream.github.io/docs/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/X.Linux-%E7%AE%A1%E7%90%86/Linux-%E7%B3%BB%E7%BB%9F%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/strace-%E5%B7%A5%E5%85%B7/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/X.Linux-%E7%AE%A1%E7%90%86/Linux-%E7%B3%BB%E7%BB%9F%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/strace-%E5%B7%A5%E5%85%B7/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://github.com/strace/strace">GitHub 项目，strace/strace&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://strace.io/">官网&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://man7.org/linux/man-pages/man1/strace.1.html">Manual(手册),strace(1)&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>&lt;strong>strace&lt;/strong> 是一个用来跟踪 &lt;strong>system calls(系统调用)&lt;/strong> 和 &lt;strong>signals(信号)&lt;/strong> 的工具。&lt;/p>
&lt;p>在最简单的情况下，strace 会运行指定的命令，直到退出为止。 它截获并记录 &lt;strong>由进程调用的系统调用&lt;/strong> 和 &lt;strong>由进程接收的信号&lt;/strong>。 每个系统调用的名称，其参数及其返回值都会在 标准错误 或使用 -o 选项指定的文件上显示。&lt;/p>
&lt;p>strace 是有用的诊断，说明和调试工具。系统管理员，诊断人员和疑难解答人员将发现，对于不容易获取源代码的程序而言，这是无价的，因为它们无需重新编译即可跟踪它们。学生，黑客和过于好奇的人会发现，即使跟踪普通程序，也可以学到很多有关系统及其系统调用的知识。而且程序员会发现，由于系统调用和信号是在用户/内核界面上发生的事件，因此仔细检查此边界对于错误隔离，健全性检查和尝试捕获竞争状况非常有用。&lt;/p>
&lt;h2 id="strace-输出内容介绍">strace 输出内容介绍&lt;/h2>
&lt;h3 id="追踪到系统调用时输出的信息">追踪到系统调用时输出的信息&lt;/h3>
&lt;p>下面是一个最基本，最简单的追踪，strace 程序执行时，输出的每一行内容都是一个 syscall(系统调用)。基本格式如下：&lt;/p>
&lt;p>&lt;code>SyscallName(Parameter) = ReturnValue&lt;/code>&lt;/p>
&lt;p>假如我追踪 cat /dev/null 命令，则输出中有这么一段：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># 使用了 openat 这个系统调用，参数为 &amp;#34;/dev/null&amp;#34;,O_RDONLY，返回值为 3&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>openat&lt;span style="color:#f92672">(&lt;/span>AT_FDCWD, &lt;span style="color:#e6db74">&amp;#34;/dev/null&amp;#34;&lt;/span>, O_RDONLY&lt;span style="color:#f92672">)&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">3&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>如果命令出现错误，通常 ReturenVale 为 -1，并附加 errno 符号和错误信息&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>openat&lt;span style="color:#f92672">(&lt;/span>AT_FDCWD, &lt;span style="color:#e6db74">&amp;#34;123&amp;#34;&lt;/span>, O_RDONLY&lt;span style="color:#f92672">)&lt;/span> &lt;span style="color:#f92672">=&lt;/span> -1 ENOENT &lt;span style="color:#f92672">(&lt;/span>No such file or directory&lt;span style="color:#f92672">)&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="追踪到信号时输出的信息">追踪到信号时输出的信息&lt;/h3>
&lt;p>如果追踪到信号，则输出内容的基本格式如下：&lt;/p>
&lt;p>&lt;code>SignalName{si_signo=SignalName, si_code=SI_USER, si_pid=PID, ...}&lt;/code>&lt;/p>
&lt;p>假如我同时最总两个进程，并像其中一个进程发送了 SIGTERM 信号，则输出中有这么一段：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">[&lt;/span>pid 5314&lt;span style="color:#f92672">]&lt;/span> --- SIGTERM &lt;span style="color:#f92672">{&lt;/span>si_signo&lt;span style="color:#f92672">=&lt;/span>SIGTERM, si_code&lt;span style="color:#f92672">=&lt;/span>SI_USER, si_pid&lt;span style="color:#f92672">=&lt;/span>27467, si_uid&lt;span style="color:#f92672">=&lt;/span>0&lt;span style="color:#f92672">}&lt;/span> ---
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h1 id="starce-语法">starce 语法&lt;/h1>
&lt;p>strace [-ACdffhikqrtttTvVxxy] [-I n] [-b execve] [-e expr]&amp;hellip; [-a column] [-o file] [-s strsize] [-X format] [-P path]&amp;hellip; [-p pid]&amp;hellip; { -p pid | [-D] [-E var[=val]]&amp;hellip; [-u username] COMMAND [args] }&lt;/p>
&lt;p>strace -c [-df] [-I n] [-b execve] [-e expr]&amp;hellip; [-O overhead] [-S sortby] [-P path]&amp;hellip; [-p pid]&amp;hellip; { -p pid | [-D] [-E var[=val]]&amp;hellip; [-u username] COMMAND [args] }&lt;/p>
&lt;h2 id="options">OPTIONS&lt;/h2>
&lt;h3 id="general-通用选项">General 通用选项&lt;/h3>
&lt;p>&lt;strong>-e EXPR&lt;/strong> # 用来指定要追踪的事件以及如何追踪。&lt;/p>
&lt;p>EXPR(表达式) 的格式为 &lt;code>QUALIFIER=[!]VALUE[,VALUE...]&lt;/code>&lt;/p>
&lt;ul>
&lt;li>&lt;strong>QUALIFIER(限定词)&lt;/strong> # 可用的限定词有 trace、abbrev、verbose、raw、signal、read、write、fault、inject、status、quiet、decode-fds、kvm。&lt;code>默认值：trace&lt;/code>。&lt;/li>
&lt;li>&lt;strong>VALUE&lt;/strong> # 是与 qualifier 相关的字符串或数字。&lt;/li>
&lt;/ul>
&lt;p>Note：&lt;/p>
&lt;ul>
&lt;li>由于 QUALIFIER 的默认值为 trace。所以 -e trace=sendto,read 也可以写成 -e sendto,read。&lt;/li>
&lt;li>QUALIFIER 限定词根据功能不通，在 filtering、tampering、Output format 等选项中，有具体的使用说明。&lt;/li>
&lt;li>使用 &lt;code>!&lt;/code> 会否定该组值。比如，-e trace=open 表示仅追踪 open 系统调用；而 -e trace=&amp;rsquo;!open&amp;rsquo; 表示追踪除了 open 以外的所有系统调用
&lt;ul>
&lt;li>注意加单引号，否则无法识别，并报错提示：&lt;code>-bash: !XXXX: event not found&lt;/code>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h3 id="startup-启动选项">Startup 启动选项&lt;/h3>
&lt;ul>
&lt;li>&lt;strong>-p PID&lt;/strong> # 追踪指定 PID 的进程的系统调用。&lt;/li>
&lt;/ul>
&lt;h3 id="tracing-跟踪选项">Tracing 跟踪选项&lt;/h3>
&lt;ul>
&lt;li>&lt;strong>-f&lt;/strong> # 跟踪子进程，并显示 PID 号。些子进程是由 fork(2)，vfork(2) 和 clone(2) 系统调用而由当前跟踪的进程创建的。&lt;/li>
&lt;/ul>
&lt;h3 id="filtering-过滤选项">Filtering 过滤选项&lt;/h3>
&lt;ul>
&lt;li>&lt;strong>-e trace=SYSCALL_SET&lt;/strong> # 指定要追踪的系统调用。
&lt;ul>
&lt;li>可用的 SYSCALL_SET 有如下这些
&lt;ul>
&lt;li>&lt;strong>SYSCALL1[,SYSCALL2,&amp;hellip;]&lt;/strong> # 直接指定系统调用的名称，多个名称以逗号分隔。&lt;/li>
&lt;li>&lt;strong>/REGEX&lt;/strong> # 前面加上 &lt;code>/&lt;/code> ，后面可以使用正则表达式进行匹配，来匹配系统调用的名称。&lt;/li>
&lt;li>&lt;strong>%SyscallSet&lt;/strong> # 前面加上 &lt;code>%&lt;/code>，就会追踪一类系统调用的集合。比如：
&lt;ul>
&lt;li>%clock    Trace all system calls that read or modify system clocks.&lt;/li>
&lt;li>%creds    Trace all system calls that read or modify user and group identifiers or capability sets.&lt;/li>
&lt;li>%desc     Trace all file descriptor related system calls.&lt;/li>
&lt;li>&lt;strong>%file&lt;/strong> # 追踪所有以文件名为参数的系统调用。可以看作是 -e trace=open,stat,chmod,unlink,&amp;hellip;.. 的简写。&lt;/li>
&lt;li>%fstat    Trace fstat and fstatat syscall variants.&lt;/li>
&lt;li>%fstatfs  Trace fstatfs, fstatfs64, fstatvfs, osf_fstatfs, and osf_fstatfs64 system calls.&lt;/li>
&lt;li>%ipc      Trace all IPC related system calls.&lt;/li>
&lt;li>%lstat    Trace lstat syscall variants.&lt;/li>
&lt;li>%memory   Trace all memory mapping related system calls.&lt;/li>
&lt;li>%network  Trace all the network related system calls.&lt;/li>
&lt;li>%process  Trace all system calls which involve process management.&lt;/li>
&lt;li>%pure     Trace syscalls that always succeed and have no arguments.&lt;/li>
&lt;li>&lt;strong>%signal&lt;/strong> # 追踪所有与信号相关的系统调用。&lt;/li>
&lt;li>%stat     Trace stat syscall variants.&lt;/li>
&lt;li>%statfs   Trace statfs, statfs64, statvfs, osf_statfs, and osf_statfs64 system calls.&lt;/li>
&lt;li>%%stat    Trace syscalls used for requesting file status.&lt;/li>
&lt;li>%%statfs  Trace syscalls related to file system statistic&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&amp;hellip;&amp;hellip;..等等&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>-e signal=SIGNAL_SET&lt;/strong> # 指定要追踪的信号。&lt;/li>
&lt;li>&lt;strong>-e status=STATUS_SET&lt;/strong> # 指定要追踪的系统调用的返回码&lt;/li>
&lt;/ul>
&lt;h3 id="output-format-输出格式选项">Output format 输出格式选项&lt;/h3>
&lt;ul>
&lt;li>&lt;strong>-a COLUMN&lt;/strong> # 设定列的间隔为 COLUMN，默认为 40。i.e. &lt;code>=&lt;/code> 与前面的间隔&lt;/li>
&lt;li>&lt;strong>-o, &amp;ndash;output &amp;lt;FILE&amp;gt;&lt;/strong> # 将追踪结果输出到文件中(默认标准错误)。
&lt;ul>
&lt;li>与 -ff 参数一起使用时，会把每个线程的追踪写到单独的文件中，以 FileName.PID 格式命名。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>-q, &amp;ndash;quiet=STRING&lt;/strong> # 抑制有关附加、分离、个性的消息。当 strace 的输出被重定向到文件中时，会自动添加该选项。
&lt;ul>
&lt;li>可用的值有：attach,personality,exit,all。这些可用的值只在 &amp;ndash;quiet 选项时可用，我们还可以使用 -q、-qq、-qqq 以添加不同的抑制信息，q 越多，抑制的信息就越多。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>-s, &amp;ndash;string-limit &amp;lt;STRSIZE&amp;gt;&lt;/strong> # 设定要输出的最大字符串长度为 STRSIZE。&lt;code>默认值：32&lt;/code>。Note:文件名不作为字符串，并始终完整打印。
&lt;ul>
&lt;li>示例如下，在 sendto 和 read 系统调用中，参数只显示了 32 个字符。当指定 -s 选项后，可以输出更多字符。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>~&lt;span style="color:#f92672">]&lt;/span>&lt;span style="color:#75715e"># strace -p 22863 -e trace=sendto,read&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>sendto&lt;span style="color:#f92672">(&lt;/span>6, &lt;span style="color:#e6db74">&amp;#34;GET / HTTP/1.0\r\nUser-Agent: Keep&amp;#34;&lt;/span>..., 71, 0, NULL, 0&lt;span style="color:#f92672">)&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">71&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>read&lt;span style="color:#f92672">(&lt;/span>6, &lt;span style="color:#e6db74">&amp;#34;HTTP/1.1 426 Upgrade Required\r\nd&amp;#34;&lt;/span>..., 4096&lt;span style="color:#f92672">)&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">129&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>~&lt;span style="color:#f92672">]&lt;/span>&lt;span style="color:#75715e"># strace -p 22863 -s 1000 -e trace=sendto,read&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>strace: Process &lt;span style="color:#ae81ff">22863&lt;/span> attached
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>sendto&lt;span style="color:#f92672">(&lt;/span>7, &lt;span style="color:#e6db74">&amp;#34;GET / HTTP/1.0\r\nUser-Agent: KeepAliveClient\r\nHost: 10.0.9.213:50080\r\n\r\n&amp;#34;&lt;/span>, 71, 0, NULL, 0&lt;span style="color:#f92672">)&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">71&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>read&lt;span style="color:#f92672">(&lt;/span>7, &lt;span style="color:#e6db74">&amp;#34;HTTP/1.1 426 Upgrade Required\r\ndate: Fri, 24 Jul 2020 07:53:01 GMT\r\nserver: istio-envoy\r\nconnection: close\r\ncontent-length: 0\r\n\r\n&amp;#34;&lt;/span>, 4096&lt;span style="color:#f92672">)&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">129&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ul>
&lt;li>&lt;strong>-t, -tt, -ttt&lt;/strong> # 显示追踪时间(在输出的行开头显示)。2 个 t 显示微秒，3 个 t 显示时间戳&lt;/li>
&lt;li>&lt;strong>-T&lt;/strong> # 显示追踪花费的时间(在输出的行末尾显示)&lt;/li>
&lt;li>&lt;strong>-y, -yy&lt;/strong> # 打印与文件描述符参数相关联的路径。2 个 y，打印与套接字文件描述符相关的特定协议信息，以及与设备文件描述符相关的块/字符设备号。&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># 这是一个建立 http 连接的系统调用追踪&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># 不加 -y，只显示数字 3，表示当前文件描述符的编号为3&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">[&lt;/span>pid 8675&lt;span style="color:#f92672">]&lt;/span> write&lt;span style="color:#f92672">(&lt;/span>3, &lt;span style="color:#e6db74">&amp;#34;POST /api/v1/auth/tokens:login HTTP/1.1\r\nHost: 10.20.5.98:8056\r\nUser-Agent: Go-http-client/1.1\r\nContent-Length: 44\r\nContent-Type: application/json\r\nAccept-Encoding: gzip\r\n\r\n{\&amp;#34;auth\&amp;#34;:{\&amp;#34;name\&amp;#34;:\&amp;#34;admin\&amp;#34;,\&amp;#34;password\&amp;#34;:\&amp;#34;admin\&amp;#34;}}&amp;#34;&lt;/span>, 217&lt;span style="color:#f92672">)&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">217&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># 使用 -y 参数，显示编号为3的文件描述符的路径&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">[&lt;/span>pid 8667&lt;span style="color:#f92672">]&lt;/span> write&lt;span style="color:#f92672">(&lt;/span>3&amp;lt;socket:&lt;span style="color:#f92672">[&lt;/span>80219&lt;span style="color:#f92672">]&lt;/span>&amp;gt;, &lt;span style="color:#e6db74">&amp;#34;POST /api/v1/auth/tokens:login HTTP/1.1\r\nHost: 10.20.5.98:8056\r\nUser-Agent: Go-http-client/1.1\r\nContent-Length: 44\r\nContent-Type: application/json\r\nAccept-Encoding: gzip\r\n\r\n{\&amp;#34;auth\&amp;#34;:{\&amp;#34;name\&amp;#34;:\&amp;#34;admin\&amp;#34;,\&amp;#34;password\&amp;#34;:\&amp;#34;admin\&amp;#34;}}&amp;#34;&lt;/span>, 217&lt;span style="color:#f92672">)&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">217&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># 使用 -yy 参数，显示3号文件描述符的Socket的具体信息(源和目的地址)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">[&lt;/span>pid 8623&lt;span style="color:#f92672">]&lt;/span> write&lt;span style="color:#f92672">(&lt;/span>3&amp;lt;TCP:&lt;span style="color:#f92672">[&lt;/span>172.38.40.250:27436-&amp;gt;10.20.5.98:8056&lt;span style="color:#f92672">]&lt;/span>&amp;gt;, &lt;span style="color:#e6db74">&amp;#34;POST /api/v1/auth/tokens:login HTTP/1.1\r\nHost: 10.20.5.98:8056\r\nUser-Agent: Go-http-client/1.1\r\nContent-Length: 44\r\nContent-Type: application/json\r\nAccept-Encoding: gzip\r\n\r\n{\&amp;#34;auth\&amp;#34;:{\&amp;#34;name\&amp;#34;:\&amp;#34;admin\&amp;#34;,\&amp;#34;password\&amp;#34;:\&amp;#34;admin\&amp;#34;}}&amp;#34;&lt;/span>, 217&lt;span style="color:#f92672">)&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">217&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># 查看一下这个进程的3号文件描述符&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">[&lt;/span>root@ansible fd&lt;span style="color:#f92672">]&lt;/span>&lt;span style="color:#75715e"># ll /proc/8685/fd/3&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>lrwx------ &lt;span style="color:#ae81ff">1&lt;/span> root root &lt;span style="color:#ae81ff">64&lt;/span> Jan &lt;span style="color:#ae81ff">24&lt;/span> 10:55 /proc/8675/fd/3 -&amp;gt; &lt;span style="color:#e6db74">&amp;#39;socket:[80219]&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">[&lt;/span>root@ansible fdinfo&lt;span style="color:#f92672">]&lt;/span>&lt;span style="color:#75715e"># cat /proc/net/tcp&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># 从这里查看socket号为80219的连接信息，16进制转换过去就是 172.38.40.250:27436 与 10.20.5.98:8056&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="statistics-统计选项">Statistics 统计选项&lt;/h3>
&lt;ul>
&lt;li>&lt;strong>-c&lt;/strong> # 统计每一次系统调用的执行时间、次数、错误次数。输出效果如下：
&lt;ul>
&lt;li>-c 参数常用来在排障之前，查看当前进程使用了哪些系统调用，然后在后续排障中单独追踪指定的系统调用&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">[&lt;/span>root@dr-02 keepalived&lt;span style="color:#f92672">]&lt;/span>&lt;span style="color:#75715e"># strace -p 22863 -c&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>strace: Process &lt;span style="color:#ae81ff">22863&lt;/span> attached
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>% time seconds usecs/call calls errors syscall
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>------ ----------- ----------- --------- --------- ----------------
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> 39.04 0.002437 &lt;span style="color:#ae81ff">32&lt;/span> &lt;span style="color:#ae81ff">76&lt;/span> &lt;span style="color:#66d9ef">select&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> 16.42 0.001025 &lt;span style="color:#ae81ff">6&lt;/span> &lt;span style="color:#ae81ff">147&lt;/span> fcntl
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> 14.48 0.000904 &lt;span style="color:#ae81ff">69&lt;/span> &lt;span style="color:#ae81ff">13&lt;/span> &lt;span style="color:#ae81ff">13&lt;/span> connect
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> 9.55 0.000596 &lt;span style="color:#ae81ff">59&lt;/span> &lt;span style="color:#ae81ff">10&lt;/span> close
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> 7.59 0.000474 &lt;span style="color:#ae81ff">36&lt;/span> &lt;span style="color:#ae81ff">13&lt;/span> sendto
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> 4.37 0.000273 &lt;span style="color:#ae81ff">11&lt;/span> &lt;span style="color:#ae81ff">23&lt;/span> read
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> 3.57 0.000223 &lt;span style="color:#ae81ff">8&lt;/span> &lt;span style="color:#ae81ff">26&lt;/span> getsockopt
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> 3.22 0.000201 &lt;span style="color:#ae81ff">15&lt;/span> &lt;span style="color:#ae81ff">13&lt;/span> socket
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> 1.75 0.000109 &lt;span style="color:#ae81ff">8&lt;/span> &lt;span style="color:#ae81ff">13&lt;/span> setsockopt
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>------ ----------- ----------- --------- --------- ----------------
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>100.00 0.006242 &lt;span style="color:#ae81ff">334&lt;/span> &lt;span style="color:#ae81ff">13&lt;/span> total
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ul>
&lt;li>&lt;strong>-o FILE&lt;/strong> # 将追踪的输出写入 FILE。 如果提供了-ff 选项，则使用 filename.pid 格式。 如果参数以“ |”开头 或“！”，则将其余参数视为命令，并将所有输出通过管道传递给它。 这对于将调试输出管道传输到程序而不影响已执行程序的重定向非常方便。 后者当前与 -ff 选项不兼容。&lt;/li>
&lt;/ul>
&lt;h3 id="tampering-干预选项">Tampering 干预选项&lt;/h3>
&lt;ul>
&lt;li>&lt;strong>-e inject=SYSCALL_SET&lt;/strong> #&lt;/li>
&lt;/ul>
&lt;h3 id="miscellaneous-选项">Miscellaneous 选项&lt;/h3>
&lt;h1 id="应用示例">应用示例&lt;/h1>
&lt;h2 id="设置-strace-命令的运行时间">设置 strace 命令的运行时间&lt;/h2>
&lt;p>&lt;code>strace&lt;/code> 命令本身并不支持指定运行最大时间的选项。但是，你可以使用 &lt;code>timeout&lt;/code> 命令来限制 &lt;code>strace&lt;/code> 命令的运行时间。&lt;code>timeout&lt;/code> 命令可以在指定的时间内运行一个命令，并在超时时终止该命令的执行。&lt;/p>
&lt;p>例如，如果你想在 &lt;code>strace&lt;/code> 命令在 5 秒内运行，你可以使用以下命令：&lt;/p>
&lt;p>&lt;code>timeout 5 strace -p 123456&lt;/code>&lt;/p>
&lt;p>这将运行 &lt;code>&amp;lt;your command&amp;gt;&lt;/code> 命令并使用 &lt;code>strace&lt;/code> 进行跟踪，但最多只运行 5 秒。如果命令在 5 秒内完成，则 &lt;code>timeout&lt;/code> 命令将返回该命令的退出状态码。否则，&lt;code>timeout&lt;/code> 命令将终止该命令并返回一个非零的退出状态码。&lt;/p>
&lt;h2 id="其他">其他&lt;/h2>
&lt;ul>
&lt;li>追踪 ls 命令的系统调用情况。
&lt;ul>
&lt;li>&lt;strong>starce ls&lt;/strong>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>统计 df 命令的系统调用信息。
&lt;ul>
&lt;li>&lt;strong>strace -c df&lt;/strong>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>追踪 22863 进程的系统调用，只追踪网络与 read 相关的系统调用。输出更多信息，扩大输出字符串到 1000。
&lt;ul>
&lt;li>&lt;strong>strace -p 22863 -s 1000 -e trace=%network,read&lt;/strong>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>追踪新编译的 main 程序，显示时间、追踪线程、扩大输出字符、追踪 write()、追踪 SIGHUP 信号
&lt;ul>
&lt;li>&lt;strong>strace -t -f -s 1000 -e trace=write -e signal=&amp;lsquo;SIGHUP&amp;rsquo; ./main &amp;ndash;xsky-pass=admin&lt;/strong>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>分析进程 I/O 情况&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>追踪 1234 进程及其子进程，去掉所有字符串，在末尾显示花费的时间，将结果保存到 strace.file 文件中
&lt;ul>
&lt;li>&lt;strong>strace -T -s 0 -f -p 1234 -o strace.file&lt;/strong>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>文件中的内容如下&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>~&lt;span style="color:#f92672">]&lt;/span>&lt;span style="color:#75715e"># cat strace.file&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">31090&lt;/span> pread64&lt;span style="color:#f92672">(&lt;/span>227, &lt;span style="color:#e6db74">&amp;#34;&amp;#34;&lt;/span>..., 16384, 81920&lt;span style="color:#f92672">)&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">16384&lt;/span> &amp;lt;0.000991&amp;gt;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">31090&lt;/span> pread64&lt;span style="color:#f92672">(&lt;/span>227, &lt;span style="color:#e6db74">&amp;#34;&amp;#34;&lt;/span>..., 16384, 65536&lt;span style="color:#f92672">)&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">16384&lt;/span> &amp;lt;0.001292&amp;gt;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">31090&lt;/span> pread64&lt;span style="color:#f92672">(&lt;/span>227, &lt;span style="color:#e6db74">&amp;#34;&amp;#34;&lt;/span>..., 16384, 98304&lt;span style="color:#f92672">)&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">16384&lt;/span> &amp;lt;0.000176&amp;gt;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">31090&lt;/span> pread64&lt;span style="color:#f92672">(&lt;/span>129, &lt;span style="color:#e6db74">&amp;#34;&amp;#34;&lt;/span>..., 16384, 131072&lt;span style="color:#f92672">)&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">16384&lt;/span> &amp;lt;0.002121&amp;gt;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">31090&lt;/span> pread64&lt;span style="color:#f92672">(&lt;/span>129, &lt;span style="color:#e6db74">&amp;#34;&amp;#34;&lt;/span>..., 16384, 16384&lt;span style="color:#f92672">)&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">16384&lt;/span> &amp;lt;0.000932&amp;gt;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">31090&lt;/span> pread64&lt;span style="color:#f92672">(&lt;/span>128, &lt;span style="color:#e6db74">&amp;#34;&amp;#34;&lt;/span>..., 16384, 49152&lt;span style="color:#f92672">)&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">16384&lt;/span> &amp;lt;0.001072&amp;gt;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">31090&lt;/span> pread64&lt;span style="color:#f92672">(&lt;/span>128, &lt;span style="color:#e6db74">&amp;#34;&amp;#34;&lt;/span>..., 16384, 16384&lt;span style="color:#f92672">)&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">16384&lt;/span> &amp;lt;0.000820&amp;gt;
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ul>
&lt;li>通过 awk 命令，聚合系统调用中的第三个参数，即可得出来追踪这一段时间，这个程序从磁盘中读取了多少数据&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>awk -F, &lt;span style="color:#e6db74">&amp;#39;{print $3}&amp;#39;&lt;/span> test.file | awk &lt;span style="color:#e6db74">&amp;#39;{sum += $1} END {print sum}&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div></description></item><item><title>Docs: sysstat 工具集</title><link>https://desistdaydream.github.io/docs/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/X.Linux-%E7%AE%A1%E7%90%86/Linux-%E7%B3%BB%E7%BB%9F%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/sysstat-%E5%B7%A5%E5%85%B7%E9%9B%86/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/X.Linux-%E7%AE%A1%E7%90%86/Linux-%E7%B3%BB%E7%BB%9F%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/sysstat-%E5%B7%A5%E5%85%B7%E9%9B%86/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://github.com/sysstat/sysstat">GitHub 项目&lt;/a>&lt;/li>
&lt;li>&lt;a href="http://sebastien.godard.pagesperso-orange.fr/">官网&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://man7.org/linux/man-pages/man1/pidstat.1.html">Manual(手册),pidstat(1)&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://man7.org/linux/man-pages/man1/sar.1.html">Manual(手册),sar(1)&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>sysstat 包包含很多类 UNIX 的应用程序，用以监控系统性能和使用活动。&lt;/p>
&lt;h1 id="cifsiostat">cifsiostat&lt;/h1>
&lt;h1 id="iostat---报告设备和分区的-io-统计数据">iostat - 报告设备和分区的 I/O 统计数据&lt;/h1>
&lt;p>iostat 命令用于通过观察设备活动的时间及其平均传输速率来监视系统 I/O 设备的负载。 iostat 命令生成可用于更改系统配置的报告，以更好地平衡物理磁盘之间的输入/输出负载。&lt;/p>
&lt;p>iostat 命令生成两种类型的报告，即 CPU 利用率报告和设备利用率报告。&lt;/p>
&lt;p>CPU 利用率报告&lt;/p>
&lt;p>Device 利用率报告&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>~&lt;span style="color:#f92672">]&lt;/span>&lt;span style="color:#75715e"># iostat -xd&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Linux 4.18.0-193.19.1.el8_2.x86_64 &lt;span style="color:#f92672">(&lt;/span>ansible.tj-test&lt;span style="color:#f92672">)&lt;/span> 11/24/2020 _x86_64_ &lt;span style="color:#f92672">(&lt;/span>&lt;span style="color:#ae81ff">4&lt;/span> CPU&lt;span style="color:#f92672">)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Device r/s w/s rkB/s wkB/s rrqm/s wrqm/s %rrqm %wrqm r_await w_await aqu-sz rareq-sz wareq-sz svctm %util
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>sda 0.04 0.17 1.56 11.25 0.00 0.26 0.19 60.08 10.57 54.93 0.01 40.14 65.48 0.97 0.02
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>scd0 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 6.41 0.00 0.00 38.52 0.00 1.00 0.00
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>dm-0 0.04 0.43 1.51 11.25 0.00 0.00 0.00 0.00 9.71 108.32 0.05 40.01 26.33 0.44 0.02
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>dm-1 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 1.69 0.00 0.00 21.57 0.00 0.39 0.00
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ul>
&lt;li>%util # 向设备发出 I/O 请求所占时间的百分比(设备的带宽利用率)。其实就是磁盘 I/O 使用率&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/bremrf/1616164910414-5cadf78b-954f-4409-8dfc-e7f9f5b950b3.png" alt="">&lt;/p>
&lt;h1 id="iostat---显示-io-状态信息">iostat - 显示 I/O 状态信息&lt;/h1>
&lt;p>&lt;strong>iostat [OPTIONS] [INTERVAL [COUNT]]&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>INTERVAL # 间隔时间，单位是秒，指定 INTERVAL 时，mpstat 根据该时间每隔 INTERVAL 秒输出一次信息，并在最后输出平均值。
&lt;ul>
&lt;li>COUNT # 每隔 INTERVAL 时间，输出信息的数量。若不指定 CONUNT，则 mpstat 会根据间隔时间持续输出统计信息。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>OPTIONS&lt;/p>
&lt;ul>
&lt;li>&lt;strong>-c&lt;/strong> # 只显示 CPU 利用率报告&lt;/li>
&lt;li>&lt;strong>-d&lt;/strong> # 只显示磁盘利用率报告&lt;/li>
&lt;li>&lt;strong>-x&lt;/strong> # 显示扩展信息。输出更多的统计信息&lt;/li>
&lt;/ul>
&lt;p>EXAMPLE&lt;/p>
&lt;h1 id="mpstat---显示处理器相关的统计信息">mpstat - 显示处理器相关的统计信息&lt;/h1>
&lt;p>&lt;strong>mpstat [OPTIONS] [INTERVAL [COUNT]]&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>INTERVAL # 间隔时间，单位是秒。指定 INTERVAL 时，mpstat 根据该时间每隔 INTERVAL 秒输出一次信息，并在最后输出平均值。
&lt;ul>
&lt;li>COUNT # 每隔 INTERVAL 时间，输出信息的数量。若不指定 CONUNT，则 mpstat 会根据间隔时间持续输出统计信息。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>OPTIONS&lt;/p>
&lt;ul>
&lt;li>&lt;strong>-A&lt;/strong> # 此选项等效于 -u -I ALL -P ALL&lt;/li>
&lt;li>&lt;strong>-P&lt;/strong> &lt;strong>&amp;lt;CPU[,CPU2&amp;hellip;.]&amp;gt;&lt;/strong> # 指定要监控的 CPU，ALL 为监控所有 CPU&lt;/li>
&lt;/ul>
&lt;p>EXAMPLE&lt;/p>
&lt;ul>
&lt;li>显示所有 CPU 的统计信息。每隔 5 秒输出 1 次信息，总共输出 2 次。
&lt;ul>
&lt;li>&lt;strong>mpstat -P ALL 5 2&lt;/strong>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h1 id="nfsiostat-sysstat">nfsiostat-sysstat&lt;/h1>
&lt;h1 id="pidstat---显示-linux-进程的统计信息">pidstat - 显示 Linux 进程的统计信息&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://man7.org/linux/man-pages/man1/pidstat.1.html">Manual(手册)，pidstat(1)&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>pidstat 是一个以 Task(任务) 为主体，显示 Task 相关系统使用情况的工具。&lt;/p>
&lt;blockquote>
&lt;p>Task(任务) 是 进程、线程 之类的统称。&lt;/p>
&lt;/blockquote>
&lt;p>根据命令的不同选项，显示进程的不同信息。&lt;/p>
&lt;h2 id="-d---报告-io-统计信息">-d - 报告 I/O 统计信息&lt;/h2>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>~&lt;span style="color:#f92672">]&lt;/span>$ pidstat -d &lt;span style="color:#ae81ff">1&lt;/span> --human
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Linux 5.4.0-88-generic &lt;span style="color:#f92672">(&lt;/span>hw-cloud-xngy-jump-server-linux-2&lt;span style="color:#f92672">)&lt;/span> 10/03/2021 _x86_64_ &lt;span style="color:#f92672">(&lt;/span>&lt;span style="color:#ae81ff">2&lt;/span> CPU&lt;span style="color:#f92672">)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>10:27:48 PM UID PID kB_rd/s kB_wr/s kB_ccwr/s iodelay Command
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>10:27:49 PM UID PID kB_rd/s kB_wr/s kB_ccwr/s iodelay Command
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>10:27:50 PM &lt;span style="color:#ae81ff">1000&lt;/span> &lt;span style="color:#ae81ff">16829&lt;/span> 0.0B 4.0k 0.0B &lt;span style="color:#ae81ff">0&lt;/span> bash
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>10:27:50 PM UID PID kB_rd/s kB_wr/s kB_ccwr/s iodelay Command
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>^C
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Average: UID PID kB_rd/s kB_wr/s kB_ccwr/s iodelay Command
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Average: &lt;span style="color:#ae81ff">1000&lt;/span> &lt;span style="color:#ae81ff">16829&lt;/span> 0.0B 1.3k 0.0B &lt;span style="color:#ae81ff">0&lt;/span> bash
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="-u---默认选项报告进程的-cpu-利用率">-u - 默认选项。报告进程的 CPU 利用率&lt;/h2>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>~&lt;span style="color:#f92672">]&lt;/span>&lt;span style="color:#75715e"># pidstat&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Linux 4.18.0-193.19.1.el8_2.x86_64 &lt;span style="color:#f92672">(&lt;/span>ansible.tj-test&lt;span style="color:#f92672">)&lt;/span> 10/27/2020 _x86_64_ &lt;span style="color:#f92672">(&lt;/span>&lt;span style="color:#ae81ff">4&lt;/span> CPU&lt;span style="color:#f92672">)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>09:51:15 PM UID PID %usr %system %guest %wait %CPU CPU Command
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>09:51:15 PM &lt;span style="color:#ae81ff">0&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span> 0.00 0.01 0.00 0.00 0.02 &lt;span style="color:#ae81ff">1&lt;/span> systemd
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>09:51:15 PM &lt;span style="color:#ae81ff">0&lt;/span> &lt;span style="color:#ae81ff">2&lt;/span> 0.00 0.00 0.00 0.00 0.00 &lt;span style="color:#ae81ff">0&lt;/span> kthreadd
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="-w---报告进程的上下文切换情况">-w - 报告进程的上下文切换情况&lt;/h2>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>~&lt;span style="color:#f92672">]&lt;/span>&lt;span style="color:#75715e"># pidstat -w&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Linux 4.18.0-193.19.1.el8_2.x86_64 &lt;span style="color:#f92672">(&lt;/span>ansible.tj-test&lt;span style="color:#f92672">)&lt;/span> 10/27/2020 _x86_64_ &lt;span style="color:#f92672">(&lt;/span>&lt;span style="color:#ae81ff">4&lt;/span> CPU&lt;span style="color:#f92672">)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>10:00:14 PM UID PID cswch/s nvcswch/s Command
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>10:00:14 PM &lt;span style="color:#ae81ff">0&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span> 0.11 0.03 systemd
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>10:00:14 PM &lt;span style="color:#ae81ff">0&lt;/span> &lt;span style="color:#ae81ff">2&lt;/span> 0.02 0.00 kthreadd
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ul>
&lt;li>&lt;strong>cswch/s&lt;/strong> # 每秒自愿上下文切换(voluntary context switches)的次数&lt;/li>
&lt;li>&lt;strong>nvcswch&lt;/strong> # 每秒非自愿上下文切换(non voluntary context switches)的次数&lt;/li>
&lt;/ul>
&lt;h2 id="-r---报告进程的内存使用情况统计信息">-r - 报告进程的内存使用情况统计信息&lt;/h2>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>~&lt;span style="color:#f92672">]&lt;/span>&lt;span style="color:#75715e"># pidstat -r&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Linux 4.18.0-193.28.1.el8_2.x86_64 &lt;span style="color:#f92672">(&lt;/span>lichenhao.bj-net&lt;span style="color:#f92672">)&lt;/span> 11/18/2020 _x86_64_ &lt;span style="color:#f92672">(&lt;/span>&lt;span style="color:#ae81ff">2&lt;/span> CPU&lt;span style="color:#f92672">)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>09:58:16 PM UID PID minflt/s majflt/s VSZ RSS %MEM Command
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>09:58:16 PM &lt;span style="color:#ae81ff">0&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span> 5.57 0.05 &lt;span style="color:#ae81ff">176812&lt;/span> &lt;span style="color:#ae81ff">10844&lt;/span> 0.28 systemd
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>09:58:16 PM &lt;span style="color:#ae81ff">0&lt;/span> &lt;span style="color:#ae81ff">664&lt;/span> 0.43 0.00 &lt;span style="color:#ae81ff">91980&lt;/span> &lt;span style="color:#ae81ff">8980&lt;/span> 0.23 systemd-journal
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ul>
&lt;li>&lt;strong>minflt/s&lt;/strong> # 每秒任务执行的次要故障总数，即不需要从磁盘加载内存页面的次要故障总数。&lt;/li>
&lt;li>&lt;strong>majflt/s&lt;/strong> # 每秒任务执行的主要故障总数，即需要从磁盘加载内存页面的主要故障总数。&lt;/li>
&lt;li>&lt;strong>VSZ&lt;/strong> # Virtual Size(虚拟大小)。整个任务的虚拟内存使用量，以千字节为单位。&lt;/li>
&lt;li>&lt;strong>RSS&lt;/strong> # Resident Set Size(常驻集大小)。任务使用的未交换的物理内存，以千字节为单位。&lt;/li>
&lt;/ul>
&lt;h2 id="-d---报告进程的磁盘-io-统计信息">-d - 报告进程的磁盘 I/O 统计信息&lt;/h2>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>~&lt;span style="color:#f92672">]&lt;/span>&lt;span style="color:#75715e"># pidstat -d&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Linux 4.18.0-193.28.1.el8_2.x86_64 &lt;span style="color:#f92672">(&lt;/span>lichenhao.bj-net&lt;span style="color:#f92672">)&lt;/span> 11/18/2020 _x86_64_ &lt;span style="color:#f92672">(&lt;/span>&lt;span style="color:#ae81ff">2&lt;/span> CPU&lt;span style="color:#f92672">)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>09:58:37 PM UID PID kB_rd/s kB_wr/s kB_ccwr/s iodelay Command
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>09:58:37 PM &lt;span style="color:#ae81ff">0&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span> 56.46 0.18 0.01 &lt;span style="color:#ae81ff">33&lt;/span> systemd
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>09:58:37 PM &lt;span style="color:#ae81ff">0&lt;/span> &lt;span style="color:#ae81ff">7&lt;/span> 0.18 0.00 0.00 &lt;span style="color:#ae81ff">0&lt;/span> kworker/u4:0-events_unbound
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="syntax语法">Syntax(语法)&lt;/h2>
&lt;p>&lt;strong>pidstat [OPTIONS] [INTERVAL [COUNT]]&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>&lt;strong>INTERVAL&lt;/strong> # 间隔时间，单位是秒，指定 INTERVAL 时，mpstat 根据该时间每隔 INTERVAL 秒输出一次信息，并在最后输出平均值。
&lt;ul>
&lt;li>&lt;strong>COUNT&lt;/strong> # 每隔 INTERVAL 时间，输出信息的数量。若不指定 CONUNT，则 mpstat 会根据间隔时间持续输出统计信息。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>OPTIONS&lt;/p>
&lt;ul>
&lt;li>&lt;strong>-C STRING&lt;/strong> # 仅显示 Task 名称包含 STRING 的任务。该字符串可以是正则表达式。就是根据进程名过滤。&lt;/li>
&lt;li>&lt;strong>-p &amp;lt;PID[,PID2&amp;hellip;.]&amp;gt;&lt;/strong> # 只显示指定的一个或多个进程的信息。默认关键字为 ALL，显示所有信息。可以用 SELF 关键字来只显示自身的信息&lt;/li>
&lt;li>&lt;strong>-t&lt;/strong> # 显示进程所关联的线程的统计信息。&lt;/li>
&lt;/ul>
&lt;p>EXAMPLE&lt;/p>
&lt;ul>
&lt;li>&lt;strong>pidstat -u 5 1&lt;/strong>&lt;/li>
&lt;/ul>
&lt;h1 id="sadf---以多种格式显示-sar-工具收集到的数据">sadf - 以多种格式显示 sar 工具收集到的数据&lt;/h1>
&lt;h1 id="sar---系统活动报告">sar - 系统活动报告&lt;/h1>
&lt;p>&lt;strong>system activity report(系统活动报告，简称 SAR)&lt;/strong>。sar 是以系统为主体，报告系统相关信息的工具，包括 CPU 使用率、RAM 使用情况、磁盘 IO、网络活动状态等等。&lt;/p>
&lt;p>根据命令的不同选项，显示不同信息。&lt;/p>
&lt;h2 id="-b---报告-io-和传输速率的统计信息">-b - 报告 I/O 和传输速率的统计信息&lt;/h2>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>~&lt;span style="color:#f92672">]&lt;/span>$ sar --human -b &lt;span style="color:#ae81ff">1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Linux 5.4.0-88-generic &lt;span style="color:#f92672">(&lt;/span>hw-cloud-xngy-jump-server-linux-2&lt;span style="color:#f92672">)&lt;/span> 10/03/2021 _x86_64_ &lt;span style="color:#f92672">(&lt;/span>&lt;span style="color:#ae81ff">2&lt;/span> CPU&lt;span style="color:#f92672">)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>10:07:46 PM tps rtps wtps dtps bread/s bwrtn/s bdscd/s
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>10:07:47 PM 0.00 0.00 0.00 0.00 0.00 0.00 0.00
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>10:07:48 PM 0.00 0.00 0.00 0.00 0.00 0.00 0.00
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>10:07:49 PM 0.00 0.00 0.00 0.00 0.00 0.00 0.00
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>10:07:50 PM 2.00 0.00 2.00 0.00 0.00 16.00 0.00
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>^CAverage: 0.50 0.00 0.50 0.00 0.00 3.99 0.00
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ul>
&lt;li>&lt;strong>tpc&lt;/strong> # Transfers Per Second(每秒传输总数)，即每秒发送到物理设备的传输总数。也就是物理设备的 I/O 请求数。比如上面的例子，就是在 10 点 07 分 49 秒时，发起的两次 I/O 请求，这里面并不关心 I/O 的传输总量，或者具体是读还是写，仅记录次数。&lt;/li>
&lt;li>&lt;strong>rtps&lt;/strong> # Read TPS，每秒向物理设备发送的读请求总数&lt;/li>
&lt;li>&lt;strong>wtps&lt;/strong> # Write TPS，每秒向物理设备发送的写请求总数&lt;/li>
&lt;li>&lt;strong>dtps&lt;/strong> # Discard TPS，每秒向物理设备发送的丢弃请求总数&lt;/li>
&lt;li>&lt;strong>bread/s&lt;/strong> # Black Read，每秒从设备中读取的数据总量(以块为单位)&lt;/li>
&lt;li>&lt;strong>bwrtn/s&lt;/strong> # Black Written，每秒写入设备的数据总量(以块为单位)&lt;/li>
&lt;li>&lt;strong>bdscd/s&lt;/strong> # Black Discarded，每秒为设备丢弃的丢弃的数据总量(以块为单位)&lt;/li>
&lt;/ul>
&lt;h2 id="-n-keyword---报告网络统计信息">-n KEYWORD - 报告网络统计信息&lt;/h2>
&lt;p>KEYWORD 可用的值有 DEV、EDEV、NFS、NFSD、SOCK、IP、EIP、ICMP、EICMP、TCP、ETCP、UDP、SOCK6、IP6、EIP6、ICMP6、EICMP6、UDP6。当然，也可以用使用 ALL 来报告所有的网络统计信息&lt;/p>
&lt;h3 id="dev---报告指定网络设备的统计信息">DEV - 报告指定网络设备的统计信息&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>~&lt;span style="color:#f92672">]&lt;/span>&lt;span style="color:#75715e"># sar -n DEV 1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Linux 4.18.0-193.28.1.el8_2.x86_64 &lt;span style="color:#f92672">(&lt;/span>lichenhao.bj-net&lt;span style="color:#f92672">)&lt;/span> 11/18/2020 _x86_64_ &lt;span style="color:#f92672">(&lt;/span>&lt;span style="color:#ae81ff">2&lt;/span> CPU&lt;span style="color:#f92672">)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>10:18:38 PM IFACE rxpck/s txpck/s rxkB/s txkB/s rxcmp/s txcmp/s rxmcst/s %ifutil
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>10:18:39 PM docker0 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>10:18:39 PM ens3 4.00 1.00 0.23 0.10 0.00 0.00 0.00 0.00
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>10:18:39 PM lo 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ul>
&lt;li>&lt;strong>rxpck/s&lt;/strong> 和 &lt;strong>txpck/s&lt;/strong> 分别表示每秒接收、发送的网络帧数，也就是 PPS&lt;/li>
&lt;li>&lt;strong>rxkB/s&lt;/strong> 和 &lt;strong>txkB/s&lt;/strong> 分别表示每秒接收、发送的千字节数，也就是 BPS&lt;/li>
&lt;li>&lt;strong>rxcmp/s&lt;/strong> 和 &lt;strong>txcmp/s&lt;/strong>  分别表示每秒接收、发送的压缩数据包&lt;/li>
&lt;li>&lt;strong>rxmcst/s&lt;/strong> # 表示每秒接收的多播数据包&lt;/li>
&lt;/ul>
&lt;h3 id="tcp---报告-tcpv4-网络流量的统计信息">TCP - 报告 TCPv4 网络流量的统计信息&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>~&lt;span style="color:#f92672">]&lt;/span>$ sar -n TCP &lt;span style="color:#ae81ff">1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Linux 5.4.0-88-generic &lt;span style="color:#f92672">(&lt;/span>hw-cloud-xngy-jump-server-linux-2&lt;span style="color:#f92672">)&lt;/span> 10/03/2021 _x86_64_ &lt;span style="color:#f92672">(&lt;/span>&lt;span style="color:#ae81ff">2&lt;/span> CPU&lt;span style="color:#f92672">)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>09:46:03 PM active/s passive/s iseg/s oseg/s
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>09:46:04 PM 0.00 0.00 2.00 2.00
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>09:46:05 PM 0.00 0.00 2.00 3.00
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>09:46:06 PM 0.00 0.00 2.00 2.00
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>09:46:07 PM 0.00 0.00 2.00 2.00
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>^C
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Average: 0.00 0.00 2.00 2.25
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ul>
&lt;li>&lt;strong>active/s&lt;/strong> # TCP 连接每秒从 CLOSED 状态直接转换到 SYN-SENT 状态的次数。
&lt;ul>
&lt;li>每秒本地发起 TCP 连接数，例如通过 connect() 系统调用。(待确认描述)&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>passive/s&lt;/strong> # TCP 连接每秒从 LISTEN 状态直接转换到 SYN-RCVD 状态的次数。
&lt;ul>
&lt;li>每秒远程发起的 TCP 连接数，例如通过 accept() 系统调用。(待确认描述)&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>iseg/s&lt;/strong> # 每秒接受的 TCP segments 总数，包括错误的。
&lt;ul>
&lt;li>也就是每秒收到了多少个 TCP 包&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>oseg/s&lt;/strong> # 每秒发送的 TCP segments 总数。不包括重传的。
&lt;ul>
&lt;li>也就是每秒发送了多少个 TCP 包&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h2 id="syntax语法-1">Syntax(语法)&lt;/h2>
&lt;p>&lt;strong>sar [OPTIONS] [INTERVAL [COUNT]]&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>&lt;strong>INTERVAL&lt;/strong> # 间隔时间，单位是秒。指定 INTERVAL 时，mpstat 根据该时间每隔 INTERVAL 秒输出一次信息，并在最后输出平均值。
&lt;ul>
&lt;li>&lt;strong>COUNT&lt;/strong> # 每隔 INTERVAL 时间，输出信息的数量。若不指定 CONUNT，则 mpstat 会根据间隔时间持续输出统计信息。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>OPTIONS&lt;/p>
&lt;ul>
&lt;li>&lt;strong>-p &amp;lt;CPU[,CPU2&amp;hellip;.]&amp;gt;&lt;/strong> # 只显示指定的一个或多个 CPU 的信息，以需要表示，多个 CPU 以逗号分割。&lt;/li>
&lt;/ul>
&lt;p>EXAMPLE&lt;/p>
&lt;ul>
&lt;li>输出 1，3，5，7 这 4 个 CPU 中，idle 小于 10 的 CPU
&lt;ul>
&lt;li>&lt;strong>sar -P 1,3,5,7 1 | tail -n+3 | awk &amp;lsquo;$NF&amp;lt;10 {print $0}&amp;rsquo;&lt;/strong>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h1 id="tapestat">tapestat&lt;/h1></description></item></channel></rss>