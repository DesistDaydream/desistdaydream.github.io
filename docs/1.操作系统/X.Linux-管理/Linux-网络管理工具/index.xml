<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>断念梦 – Linux 网络管理工具</title><link>https://desistdaydream.github.io/docs/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/X.Linux-%E7%AE%A1%E7%90%86/Linux-%E7%BD%91%E7%BB%9C%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/</link><description>Recent content in Linux 网络管理工具 on 断念梦</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><atom:link href="https://desistdaydream.github.io/docs/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/X.Linux-%E7%AE%A1%E7%90%86/Linux-%E7%BD%91%E7%BB%9C%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/index.xml" rel="self" type="application/rss+xml"/><item><title>Docs: cURL</title><link>https://desistdaydream.github.io/docs/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/X.Linux-%E7%AE%A1%E7%90%86/Linux-%E7%BD%91%E7%BB%9C%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/cURL/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/X.Linux-%E7%AE%A1%E7%90%86/Linux-%E7%BD%91%E7%BB%9C%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/cURL/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://curl.se/">官网&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://man.cx/curl">manual(手册)&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>cURL 是一个用于 URLs 传输的命令行工具和库，始于 1998 年。&lt;/p>
&lt;p>早在 20 世纪 90 年代中期，当时互联网还处于萌芽阶段，瑞典程序员 Daniel Stenberg 开始了一个项目，这个项目最终发展成了我们今天所知道的 curl 程序。&lt;/p>
&lt;p>最初，他的目标是开发一种机器人，可以定期从网页上下载货币汇率，并向 IRC 用户提供等值的瑞典克朗美元。这个项目蓬勃发展，在这个过程中添加了几个协议和特性——剩下的就是历史了。&lt;/p>
&lt;p>curl 是常用的命令行工具，用来请求 Web 服务器。它的名字就是“客户端(client)的 URL ”工具的意思。&lt;/p>
&lt;blockquote>
&lt;p>注意：curl 最常见是通过网络 URL 来传输数据。但是，curl 还可以通过 Socket 的 URL 来传输数据，只需要使用 &amp;ndash;unix-socket 选项指定 Socket 路径即可。&lt;/p>
&lt;/blockquote>
&lt;h1 id="syntax语法">Syntax(语法)&lt;/h1>
&lt;p>&lt;strong>curl [OPTIONS] URL&amp;hellip;.&lt;/strong>
如果没有另外说明，curl 将接收到的数据写入标准输出。可以使用 -o、&amp;ndash;output 或 -O、&amp;ndash;remote-name 选项将该数据保存到本地文件中。如果 curl 被赋予多个 URL 以在命令行上传输，它同样需要多个选项来保存它们。curl 不会解析或以其他方式“理解”它作为输出获取或写入的内容。它不进行编码或解码，除非使用专用命令行选项明确要求。&lt;/p>
&lt;h2 id="options">OPTIONS&lt;/h2>
&lt;p>由于 curl 程序支持多种协议，可以使用各种不同的协议向指定的 URL 发起请求，所以，并不是所有选项都适用于所有协议。在下面的笔记中，每个选项后面会添加一个 &lt;code>()&lt;/code>，括号中说明此选项支持的协议，多个协议以空格分割；没有 &lt;code>()&lt;/code> 的表示该选项适用于所有协议。若括号内为 TLS 则表示使用安全的各种协议，比如 https、ftps、imaps 等等&lt;/p>
&lt;ul>
&lt;li>&lt;strong>&amp;ndash;compressed&lt;/strong> # (HTTP)使用 curl 支持的算法之一请求压缩响应，并自动解压缩响应体。
&lt;ul>
&lt;li>在有 Sever 端会将响应体压缩，若不使用该选项，则响应体是无法输出到标准输出的，且会出现如下报错：&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>Warning: Binary output can mess up your terminal. Use &lt;span style="color:#e6db74">&amp;#34;--output -&amp;#34;&lt;/span> to tell
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Warning: curl to output it to your terminal anyway, or consider &lt;span style="color:#e6db74">&amp;#34;--output
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">Warning: &amp;lt;FILE&amp;gt;&amp;#34;&lt;/span> to save to a file.
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ul>
&lt;li>&lt;strong>-d,&amp;ndash;data DATA&lt;/strong> # (HTTP MQTT)使用 POST 请求将指定数据作为请求体。
&lt;ul>
&lt;li>与 &lt;code>Content-Type: application/x-www-form-urlencoded&lt;/code> 头信息配合，发送的 DATA 是 x-www-form-urlencoded 类型的请求体数据。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>&amp;ndash;data-urlencode DATA&lt;/strong> # (HTTP)与 -d 选项类似，发起 POST 请求，但是它执行 URL 编码。(urlencode 就是 URL Encode)&lt;/li>
&lt;li>&lt;strong>-f,&amp;ndash;fail&lt;/strong> # (HTTP)连接失败时不显示 HTTP 错误信息&lt;/li>
&lt;li>&lt;strong>-g, &amp;ndash;globoff&lt;/strong> # 关闭 &lt;code>URL Globbing Parser(URL全局解析器)&lt;/code>。设置此选项，则 URL 中可以包含 &lt;code>{}&lt;/code> 和 &lt;code>[]&lt;/code> 符号，这些符号将被当做字符。
&lt;ul>
&lt;li>该选项常用来配合 IPv6 使用&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>-H,&amp;ndash;header &amp;lt;STRING&amp;gt;&lt;/strong># (HTTP)使用指定的 STRING 作为请求 header 发送给服务器
&lt;ul>
&lt;li>STRING 可以使用 @FILE 格式来通过文件传递请求头信息。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>-I,&amp;ndash;head&lt;/strong># (HTTP FTP FILE)只显示本次请求的 Header 信息。当用于 FTP 或 FILE 时，则只显示文件大小和最后修改时间。&lt;/li>
&lt;li>&lt;strong>-k,&amp;ndash;insecure&lt;/strong> # (TLS)此选项表示此次 curl 请求允许&amp;quot;不安全&amp;quot;的 SSL 连接和传输。也就是说对于 https 请求，可以允许私有证书。如果使用 curl 进行 https 请求的时候，不使用该参数的话，服务端使用的私有证书或自建 CA 的证书，则有可能产生如下报错
&lt;ul>
&lt;li>curl: (60) Peer&amp;rsquo;s certificate issuer has been marked as not trusted by the user.&lt;/li>
&lt;li>curl: (60) Peer&amp;rsquo;s Certificate issuer is not recognized.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>-L, &amp;ndash;location&lt;/strong> # (HTTP)如果服务器报告所请求的页面已移动到其他位置（用 Location：标题和 3XX 响应代码表示），则此选项将使 curl 重做新位置的请求。
&lt;ul>
&lt;li>Note:如果下载文件出错之后，发现文件大小异常，则说明该文件被移动到其他链接下了，需要使用-L 与-O 配合使用才能正确下载&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>&amp;ndash;limit-rate NUM&lt;/strong> # 限制现在时的速率，NMU 为每秒下载速度，单位可以使 K、M、G&lt;/li>
&lt;li>&lt;strong>-m, &amp;ndash;max-time TIME&lt;/strong># 指定 curl 不管访问成功还是失败，最大消耗时间为 TIME。TIME 时间后服务端未响应，则视为无法连接。&lt;/li>
&lt;li>&lt;strong>-O, &amp;ndash;remote-name&lt;/strong># 将输入写入的一个文件中，默认的文件名与请求的资源的名称一样。i.e.下载文件
&lt;ul>
&lt;li>curl -O &lt;a href="https://www.example.com/foo/bar.html">https://www.example.com/foo/bar.html&lt;/a> # 将服务器回应保存成文件，文件名为 bar.html。&lt;/li>
&lt;li>可以在一条命令中多次使用 -O 来下载多个文件&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>-o, &amp;ndash;output FileName&lt;/strong> # 与 -O 一样，下载文件，只不过可以自己制定下载到本地后的文件名。可以重定向到 /dev/null，以便隐藏输出。&lt;/li>
&lt;li>&lt;strong>&amp;ndash;resolve DN:PORT:IP,IP&amp;hellip;&lt;/strong> # 指定将 DN(域名)解析成哪个 IP。DN 可以使用通配符&lt;/li>
&lt;li>&lt;strong>-s, &amp;ndash;silent&lt;/strong> # 静默模式。将不输出错误和进度信息,但是会正常显示运行结果。&lt;/li>
&lt;li>&lt;strong>&amp;ndash;trace&lt;/strong># 与-v 类似也可以用于调试，还会输出原始的二进制数据。&lt;/li>
&lt;li>&lt;strong>-u, &amp;ndash;user &lt;a href="USER:%5BPASSWORD%5D">USER:[PASSWORD]&lt;/a>&lt;/strong> # 指定发起请求时，所使用的基本认证信息。若省略 PASSWORD，则会以交互方式，在执行命令之后输入。&lt;/li>
&lt;li>&lt;strong>&amp;ndash;unix-socket PATH&amp;gt;&lt;/strong> # (HTTP)通过 Unix 套接字连接，而不使用网络。&lt;/li>
&lt;li>&lt;strong>-v, &amp;ndash;verbose&lt;/strong> # 输出通信的整个过程，用于调试。&lt;/li>
&lt;li>&lt;strong>-w, &amp;ndash;write-out FORMAT&lt;/strong> # 指定在 curl 完成后，输出的信息，详细介绍可以参考&lt;a href="https://desistdaydream.github.io/docs/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/X.Linux%20%E7%AE%A1%E7%90%86/Linux%20%E7%BD%91%E7%BB%9C%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/cURL.md">样例&lt;/a>&lt;/li>
&lt;li>&lt;strong>-X, &amp;ndash;request METHOD&lt;/strong> # (HTTP)指定 HTTP 请求的方法。&lt;/li>
&lt;/ul>
&lt;h3 id="-w---write-out-选项详解">-w, &amp;ndash;write-out 选项详解&lt;/h3>
&lt;p>-w, &amp;ndash;write-out 选项可以根据指定格式输出本次请求的一些统计信息。简单的效果如下所示：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>~# curl -o /dev/null -s -w &lt;span style="color:#e6db74">&amp;#34;DNS解析时间：&amp;#34;&lt;/span>%&lt;span style="color:#f92672">{&lt;/span>time_namelookup&lt;span style="color:#f92672">}&lt;/span>&lt;span style="color:#e6db74">&amp;#34;\n&amp;#34;&lt;/span>&lt;span style="color:#ae81ff">\
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">&lt;/span>&lt;span style="color:#e6db74">&amp;#34;TCP建立时间:&amp;#34;&lt;/span>%&lt;span style="color:#f92672">{&lt;/span>time_connect&lt;span style="color:#f92672">}&lt;/span>&lt;span style="color:#e6db74">&amp;#34;\n&amp;#34;&lt;/span>&lt;span style="color:#ae81ff">\
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">&lt;/span>&lt;span style="color:#e6db74">&amp;#34;响应第一个字节时间:&amp;#34;&lt;/span>%&lt;span style="color:#f92672">{&lt;/span>time_starttransfer&lt;span style="color:#f92672">}&lt;/span>&lt;span style="color:#e6db74">&amp;#34;\n&amp;#34;&lt;/span>&lt;span style="color:#ae81ff">\
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">&lt;/span>&lt;span style="color:#e6db74">&amp;#34;总时间:&amp;#34;&lt;/span>%&lt;span style="color:#f92672">{&lt;/span>time_total&lt;span style="color:#f92672">}&lt;/span>&lt;span style="color:#e6db74">&amp;#34;\n&amp;#34;&lt;/span>&lt;span style="color:#ae81ff">\
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">&lt;/span>&lt;span style="color:#e6db74">&amp;#34;下载速度:&amp;#34;&lt;/span>%&lt;span style="color:#f92672">{&lt;/span>speed_download&lt;span style="color:#f92672">}&lt;/span>&lt;span style="color:#e6db74">&amp;#34;\n&amp;#34;&lt;/span> &lt;span style="color:#ae81ff">\
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">&lt;/span>&lt;span style="color:#e6db74">&amp;#34;http://www.taobao.com&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># 下面是命令结果&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>DNS解析时间：0.534294
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>TCP建立时间:0.551090
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>响应第一个字节时间:0.569936
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>总时间:0.570050
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>下载速度:487.000
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>FORMAT 中可用字段：&lt;/p>
&lt;ul>
&lt;li>time_namelookup # DNS 解析域名的时间&lt;/li>
&lt;li>time_commect # client 和 server 端建立 TCP 连接的时间&lt;/li>
&lt;li>time_starttransfer # 从 client 发出请求；到 web 的 server 响应第一个字节的时间&lt;/li>
&lt;li>time_total # client 发出请求；到 web 的 server 发送会所有的相应数据的时间&lt;/li>
&lt;li>speed_download # 下载速度 单位 byte/s&lt;/li>
&lt;li>http_code # 本次请求的 http 响应状态码。&lt;/li>
&lt;li>content_type # 显示在 Header 里面使用 Content-Type 来表示的具体请求中的媒体类型信息；&lt;/li>
&lt;li>time_namelookup # 从请求开始，到 DNS 解析完成所使用的时间，经常用来排除 DNS 解析的问题；&lt;/li>
&lt;li>time_redirect # 重定向的时间；&lt;/li>
&lt;li>time_pretransfer # 从开始到准备传输的时间；&lt;/li>
&lt;li>time_connect # 连接时间，从开始到 TCP 三次握手完成时间，这里面包括 DNS 解析的时候，如果想求连接时间，需要减去上面的解析时间；&lt;/li>
&lt;li>time_starttransfer # 开始传输时间，从发起请求开始，到服务器返回第一个字段的时间；&lt;/li>
&lt;li>time_total # 总时间；&lt;/li>
&lt;li>speed_download # 经常使用它来测试网速度，下载速度，单位是字节每秒；&lt;/li>
&lt;li>size_request # 请求头的大小；&lt;/li>
&lt;li>size_header # 下载的 header 的大小；&lt;/li>
&lt;li>等等&lt;/li>
&lt;/ul>
&lt;h1 id="example">EXAMPLE&lt;/h1>
&lt;ul>
&lt;li>基本示例。不带有任何参数时，curl 就是发出 GET 请求。命令向 &lt;a href="https://www.baidu.com">www.baidu.com&lt;/a> 发出 GET 请求，服务器返回的内容会在命令行输出。
&lt;ul>
&lt;li>curl &lt;a href="https://www.baidu.com">https://www.baidu.com&lt;/a>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>使用 curl 访问 IPv6
&lt;ul>
&lt;li>curl -g -6 &amp;lsquo;http://[2408:8210:3c3c:35e0:7df1:783c:ce23:e958]:8080&amp;rsquo;&lt;/li>
&lt;li>curl &amp;ndash;ipv6 &amp;lsquo;http://2408:8210:3c3c:35e0:7df1:783c:ce23:e958:8080&amp;rsquo;&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>下载指定的件
&lt;ul>
&lt;li>curl -LO &lt;a href="https://github.com/goharbor/harbor/releases/download/v1.9.3/harbor-online-installer-v1.9.3.tgz">https://github.com/goharbor/harbor/releases/download/v1.9.3/harbor-online-installer-v1.9.3.tgz&lt;/a>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>请求一个域名时，指定要解析的 IP
&lt;ul>
&lt;li>curl &lt;a href="http://myapp.example.com/myapp">http://myapp.example.com/myapp&lt;/a> &amp;ndash;resolv &amp;lsquo;myapp.example.com:80:172.19.42.217&amp;rsquo;&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>修改请求头的 Head 信息来发送请求
&lt;ul>
&lt;li>curl -v -H&amp;quot;Host: gw-test.wisetv.com.cn&amp;quot; http://10.10.100.116/app-node/monitor&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>通过文件下载多个 URL
&lt;ul>
&lt;li>xargs -n 1 curl -O &amp;lt; wenjianlisturls.txt # 从 wenjianlisturls.txt 中的 url 列表下载文件&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>不去验证目标证书直接获取 /healthz
&lt;ul>
&lt;li>curl &amp;ndash;insecure https://localhost:6443/healthz&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>通过 docker 的 socket 文件获取容器信息
&lt;ul>
&lt;li>&lt;strong>curl &amp;ndash;unix-socket /var/run/docker.sock http://localhost/containers/json&lt;/strong>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>使用或不使用身份验证将文件上载到 FTP 服务器。要使用 curl 将名为 wodewenjian.tar.gz 的本地文件上载到 ftp://ftpserver，请执行以下操作：
&lt;ul>
&lt;li>&lt;strong>curl -u username:password -T wodewenjian.tar.gz ftp://ftpserver&lt;/strong>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>存储 Cookie。使用以下命令将它们保存到 linuxidccookies.txt。然后，您可以使用 cat 命令查看该文件。
&lt;ul>
&lt;li>&lt;strong>curl &amp;ndash;cookie-jar linuxidcookies.txt &lt;a href="https://www.linuxidc.com/index.htm">https://www.linuxidc.com/index.htm&lt;/a> -O&lt;/strong>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>使用 Cookie 发起请求。
&lt;ul>
&lt;li>&lt;strong>curl &amp;ndash;cookie cnncookies.txt &lt;a href="https://www.linuxidc.com">https://www.linuxidc.com&lt;/a>&lt;/strong>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>使用 -d 参数以后，HTTP 请求会自动加上标头 Content-Type : application/x-www-form-urlencoded。并且会自动将请求转为 POST 方法，因此可以省略 -X POST。
&lt;ul>
&lt;li>curl -d&amp;rsquo;login=emma＆password=123&amp;rsquo;-X POST &lt;a href="https://google.com/login">https://google.com/login&lt;/a>&lt;/li>
&lt;li>curl -d &amp;rsquo;login=emma&amp;rsquo; -d &amp;lsquo;password=123&amp;rsquo; -X POST &lt;a href="https://google.com/login">https://google.com/login&lt;/a>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h2 id="-d---data-选项示例">-d, &amp;ndash;data 选项示例&lt;/h2>
&lt;ul>
&lt;li>读取 data.txt 文件的内容，作为请求体向服务器发送。
&lt;ul>
&lt;li>curl -d &amp;lsquo;@data.txt&amp;rsquo; &lt;a href="https://google.com/login">https://google.com/login&lt;/a>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&amp;ndash;data-urlencode 参数等同于 -d，发送 POST 请求的数据体，区别在于会自动将发送的数据进行 URL 编码。下面代码中，发送的数据 hello world 之间有一个空格，需要进行 URL 编码。
&lt;ul>
&lt;li>curl &amp;ndash;data-urlencode &amp;lsquo;comment=hello world&amp;rsquo; &lt;a href="https://google.com/login">https://google.com/login&lt;/a>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h2 id="-w---write-out-选项示例">-w, &amp;ndash;write-out 选项示例&lt;/h2>
&lt;ul>
&lt;li>获取请求 &lt;a href="https://www.baidu.com">www.baidu.com&lt;/a> 总共花费的时间
&lt;ul>
&lt;li>curl -o /dev/null -s -w &amp;lsquo;%{time_total}\n&amp;rsquo; &lt;a href="https://www.baidu.com">https://www.baidu.com&lt;/a>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>只显示响应的状态码。
&lt;ul>
&lt;li>curl -s -o /dev/null -w %{http_code}&amp;quot;\n&amp;quot; &lt;a href="http://www.baidu.com">http://www.baidu.com&lt;/a>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h1 id="复杂应用实例">复杂应用实例&lt;/h1>
&lt;h2 id="从-chrome-浏览器的请求中获取-curl-参数">从 Chrome 浏览器的请求中，获取 curl 参数&lt;/h2>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/fwy2as/1616165084827-164a7bfc-f35f-43a4-8580-9a8eb3856784.png" alt="">&lt;/p>
&lt;h1 id="可能是东半球最好的-curl-学习指南">可能是东半球最好的 Curl 学习指南&lt;/h1>
&lt;p>-A&lt;/p>
&lt;p>-A 参数指定客户端的用户代理标头，即 User-Agent。curl 的默认用户代理字符串是 curl/[version]。&lt;/p>
&lt;p>$ curl -A &amp;lsquo;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/76.0.3809.100 Safari/537.36&amp;rsquo; &lt;a href="https://google.com">https://google.com&lt;/a>&lt;/p>
&lt;p>上面命令将 User-Agent 改成 Chrome 浏览器。&lt;/p>
&lt;p>$ curl -A &amp;rsquo;&amp;rsquo; &lt;a href="https://google.com">https://google.com&lt;/a>&lt;/p>
&lt;p>上面命令会移除 User-Agent 标头。你也可以通过 -H 参数直接指定标头，更改 User-Agent。&lt;/p>
&lt;p>$ curl -H &amp;lsquo;User-Agent: php/1.0&amp;rsquo; &lt;a href="https://google.com">https://google.com&lt;/a>&lt;/p>
&lt;p>-b&lt;/p>
&lt;p>-b 参数用来向服务器发送 Cookie。&lt;/p>
&lt;p>$ curl -b &amp;lsquo;foo=bar&amp;rsquo; &lt;a href="https://google.com">https://google.com&lt;/a>&lt;/p>
&lt;p>上面命令会生成一个标头 Cookie: foo=bar，向服务器发送一个名为 foo、值为 bar 的 Cookie。&lt;/p>
&lt;p>$ curl -b &amp;lsquo;foo1=bar&amp;rsquo; -b &amp;lsquo;foo2=baz&amp;rsquo; &lt;a href="https://google.com">https://google.com&lt;/a>&lt;/p>
&lt;p>上面命令发送两个 Cookie。&lt;/p>
&lt;p>$ curl -b cookies.txt &lt;a href="https://www.google.com">https://www.google.com&lt;/a>&lt;/p>
&lt;p>上面命令读取本地文件 cookies.txt，里面是服务器设置的 Cookie（参见 -c 参数），将其发送到服务器。&lt;/p>
&lt;p>-c&lt;/p>
&lt;p>-c 参数将服务器设置的 Cookie 写入一个文件。&lt;/p>
&lt;p>$ curl -c cookies.txt &lt;a href="https://www.google.com">https://www.google.com&lt;/a>&lt;/p>
&lt;p>上面命令将服务器的 HTTP 回应所设置 Cookie 写入文本文件 cookies.txt。&lt;/p>
&lt;p>-e&lt;/p>
&lt;p>-e 参数用来设置 HTTP 的标头 Referer，表示请求的来源。&lt;/p>
&lt;p>$ curl -e &amp;lsquo;&lt;a href="https://google.com?q=example'">https://google.com?q=example'&lt;/a> &lt;a href="https://www.example.com">https://www.example.com&lt;/a>&lt;/p>
&lt;p>上面命令将 Referer 标头设为 &lt;a href="https://google.com?q=example">https://google.com?q=example&lt;/a>。&lt;/p>
&lt;p>-H 参数可以通过直接添加标头 Referer，达到同样效果。&lt;/p>
&lt;p>$ curl -H &amp;lsquo;Referer: &lt;a href="https://google.com?q=example'">https://google.com?q=example'&lt;/a> &lt;a href="https://www.example.com">https://www.example.com&lt;/a>&lt;/p>
&lt;p>-F&lt;/p>
&lt;p>-F 参数用来向服务器上传二进制文件。&lt;/p>
&lt;p>$ curl -F &amp;lsquo;&lt;a href="mailto:file=@photo.png">file=@photo.png&lt;/a>&amp;rsquo; &lt;a href="https://google.com/profile">https://google.com/profile&lt;/a>&lt;/p>
&lt;p>上面命令会给 HTTP 请求加上标头 Content-Type: multipart/form-data，然后将文件 photo.png 作为 file 字段上传。&lt;/p>
&lt;p>-F 参数可以指定 MIME 类型。&lt;/p>
&lt;p>$ curl -F &amp;lsquo;&lt;a href="mailto:file=@photo.png">file=@photo.png&lt;/a>;type=image/png&amp;rsquo; &lt;a href="https://google.com/profile">https://google.com/profile&lt;/a>&lt;/p>
&lt;p>上面命令指定 MIME 类型为 image/png，否则 curl 会把 MIME 类型设为 application/octet-stream。&lt;/p>
&lt;p>-F 参数也可以指定文件名。&lt;/p>
&lt;p>$ curl -F &amp;lsquo;&lt;a href="mailto:file=@photo.png">file=@photo.png&lt;/a>;filename=me.png&amp;rsquo; &lt;a href="https://google.com/profile">https://google.com/profile&lt;/a>&lt;/p>
&lt;p>上面命令中，原始文件名为 photo.png，但是服务器接收到的文件名为 me.png。&lt;/p>
&lt;p>-G&lt;/p>
&lt;p>-G 参数用来构造 URL 的查询字符串。&lt;/p>
&lt;p>$ curl -G -d &amp;lsquo;q=kitties&amp;rsquo; -d &amp;lsquo;count=20&amp;rsquo; &lt;a href="https://google.com/search">https://google.com/search&lt;/a>&lt;/p>
&lt;p>上面命令会发出一个 GET 请求，实际请求的 URL 为 &lt;a href="https://google.com/search?q=kitties&amp;amp;count=20">https://google.com/search?q=kitties&amp;amp;count=20&lt;/a>。如果省略 &amp;ndash;G，会发出一个 POST 请求。&lt;/p>
&lt;p>如果数据需要 URL 编码，可以结合 &amp;ndash;data&amp;ndash;urlencode 参数。&lt;/p>
&lt;p>$ curl -G &amp;ndash;data-urlencode &amp;lsquo;comment=hello world&amp;rsquo; &lt;a href="https://www.example.com">https://www.example.com&lt;/a>&lt;/p>
&lt;p>-H&lt;/p>
&lt;p>-H 参数添加 HTTP 请求的标头。&lt;/p>
&lt;p>$ curl -H &amp;lsquo;Accept-Language: en-US&amp;rsquo; &lt;a href="https://google.com">https://google.com&lt;/a>&lt;/p>
&lt;p>上面命令添加 HTTP 标头 Accept-Language: en-US。&lt;/p>
&lt;p>$ curl -H &amp;lsquo;Accept-Language: en-US&amp;rsquo; -H &amp;lsquo;Secret-Message: xyzzy&amp;rsquo; &lt;a href="https://google.com">https://google.com&lt;/a>&lt;/p>
&lt;p>上面命令添加两个 HTTP 标头。&lt;/p>
&lt;p>$ curl -d &amp;lsquo;{&amp;ldquo;login&amp;rdquo;: &amp;ldquo;emma&amp;rdquo;, &amp;ldquo;pass&amp;rdquo;: &amp;ldquo;123&amp;rdquo;}&amp;rsquo; -H &amp;lsquo;Content-Type: application/json&amp;rsquo; &lt;a href="https://google.com/login">https://google.com/login&lt;/a>&lt;/p>
&lt;p>上面命令添加 HTTP 请求的标头是 Content-Type: application/json，然后用 -d 参数发送 JSON 数据。&lt;/p>
&lt;p>-i&lt;/p>
&lt;p>-i 参数打印出服务器回应的 HTTP 标头。&lt;/p>
&lt;p>$ curl -i &lt;a href="https://www.example.com">https://www.example.com&lt;/a>&lt;/p>
&lt;p>上面命令收到服务器回应后，先输出服务器回应的标头，然后空一行，再输出网页的源码。&lt;/p>
&lt;p>-s&lt;/p>
&lt;p>-s 参数将不输出错误和进度信息。&lt;/p>
&lt;p>$ curl -s &lt;a href="https://www.example.com">https://www.example.com&lt;/a>&lt;/p>
&lt;p>上面命令一旦发生错误，不会显示错误信息。不发生错误的话，会正常显示运行结果。&lt;/p>
&lt;p>如果想让 curl 不产生任何输出，可以使用下面的命令。&lt;/p>
&lt;p>$ curl -s -o /dev/null &lt;a href="https://google.com">https://google.com&lt;/a>&lt;/p>
&lt;p>-S&lt;/p>
&lt;p>-S 参数指定只输出错误信息，通常与 -s 一起使用。&lt;/p>
&lt;p>$ curl -s -o /dev/null &lt;a href="https://google.com">https://google.com&lt;/a>&lt;/p>
&lt;p>上面命令没有任何输出，除非发生错误。&lt;/p>
&lt;p>-u&lt;/p>
&lt;p>-u 参数用来设置服务器认证的用户名和密码。&lt;/p>
&lt;p>$ curl -u &amp;lsquo;bob:12345&amp;rsquo; &lt;a href="https://google.com/login">https://google.com/login&lt;/a>&lt;/p>
&lt;p>上面命令设置用户名为 bob，密码为 12345，然后将其转为 HTTP 标头 Authorization: Basic Ym9iOjEyMzQ1。&lt;/p>
&lt;p>curl 能够识别 URL 里面的用户名和密码。&lt;/p>
&lt;p>$ curl &lt;a href="https://bob:12345@google.com/login">https://bob:12345@google.com/login&lt;/a>&lt;/p>
&lt;p>上面命令能够识别 URL 里面的用户名和密码，将其转为上个例子里面的 HTTP 标头。&lt;/p>
&lt;p>$ curl -u &amp;lsquo;bob&amp;rsquo; &lt;a href="https://google.com/login">https://google.com/login&lt;/a>&lt;/p>
&lt;p>上面命令只设置了用户名，执行后，curl 会提示用户输入密码。&lt;/p>
&lt;p>-x&lt;/p>
&lt;p>-x 参数指定 HTTP 请求的代理。&lt;/p>
&lt;p>$ curl -x socks5://james:cats@myproxy.com:8080 &lt;a href="https://www.example.com">https://www.example.com&lt;/a>&lt;/p>
&lt;p>上面命令指定 HTTP 请求通过 myproxy.com:8080 的 socks5 代理发出。&lt;/p>
&lt;p>如果没有指定代理协议，默认为 HTTP。&lt;/p>
&lt;p>$ curl -x james:cats@myproxy.com:8080 &lt;a href="https://www.example.com">https://www.example.com&lt;/a>&lt;/p>
&lt;p>上面命令中，请求的代理使用 HTTP 协议。&lt;/p></description></item><item><title>Docs: ethtool</title><link>https://desistdaydream.github.io/docs/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/X.Linux-%E7%AE%A1%E7%90%86/Linux-%E7%BD%91%E7%BB%9C%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/ethtool/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/X.Linux-%E7%AE%A1%E7%90%86/Linux-%E7%BD%91%E7%BB%9C%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/ethtool/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://man7.org/linux/man-pages/man8/ethtool.8.html">Manual(手册),ethtool(8)&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>ethtool 是一个工具，用来查询或控制网络驱动程序和硬件设备&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>~&lt;span style="color:#f92672">]&lt;/span>&lt;span style="color:#75715e"># ethtool em1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Settings &lt;span style="color:#66d9ef">for&lt;/span> em1:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Supported ports: &lt;span style="color:#f92672">[&lt;/span> TP &lt;span style="color:#f92672">]&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Supported link modes: 10baseT/Half 10baseT/Full
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> 100baseT/Half 100baseT/Full
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> 1000baseT/Half 1000baseT/Full
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Supported pause frame use: No
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Supports auto-negotiation: Yes
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Supported FEC modes: Not reported
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Advertised link modes: 10baseT/Half 10baseT/Full
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> 100baseT/Half 100baseT/Full
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> 1000baseT/Half 1000baseT/Full
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Advertised pause frame use: Symmetric
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Advertised auto-negotiation: Yes
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Advertised FEC modes: Not reported
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Link partner advertised link modes: 10baseT/Full
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> 100baseT/Full
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> 1000baseT/Full
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Link partner advertised pause frame use: No
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Link partner advertised auto-negotiation: Yes
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Link partner advertised FEC modes: Not reported
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Speed: 1000Mb/s
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Duplex: Full
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Port: Twisted Pair
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> PHYAD: &lt;span style="color:#ae81ff">1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Transceiver: internal
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Auto-negotiation: on
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> MDI-X: on
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Supports Wake-on: g
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Wake-on: d
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Current message level: 0x000000ff &lt;span style="color:#f92672">(&lt;/span>255&lt;span style="color:#f92672">)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> drv probe link timer ifdown ifup rx_err tx_err
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Link detected: yes
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h1 id="syntax语法">Syntax(语法)&lt;/h1>
&lt;p>&lt;strong>ethtool [OPTIONS] DeviceName&lt;/strong>&lt;/p>
&lt;h2 id="options">OPTIONS&lt;/h2>
&lt;h3 id="查询选项">查询选项&lt;/h3>
&lt;ul>
&lt;li>&lt;strong>-l, &amp;ndash;show-channels&lt;/strong> # 显示指定网络设备的通道数。通道是一个 IRQ，是可以触发该 IRQ 的队列集。&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>~&lt;span style="color:#f92672">]&lt;/span>&lt;span style="color:#75715e"># ethtool -l ens4f0&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Channel parameters &lt;span style="color:#66d9ef">for&lt;/span> ens4f0:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Pre-set maximums:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>RX: &lt;span style="color:#ae81ff">0&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>TX: &lt;span style="color:#ae81ff">0&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Other: &lt;span style="color:#ae81ff">1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Combined: &lt;span style="color:#ae81ff">63&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Current hardware settings:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>RX: &lt;span style="color:#ae81ff">0&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>TX: &lt;span style="color:#ae81ff">0&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Other: &lt;span style="color:#ae81ff">1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Combined: &lt;span style="color:#ae81ff">32&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ul>
&lt;li>&lt;strong>-m, &amp;ndash;dump-module-eeprom, &amp;ndash;module-info&lt;/strong> # 从 “EEPROM 插件模块”检索并解码硬件信息。比如 SFP+、QSFP。如果驱动程序和模块支持它，光学诊断信息也会被读取和解码。如果指定了 page、bank 或 i2c 参数之一，则仅允许转储单个页面或其部分。在这种情况下，偏移和长度参数相对于 EEPROM 页面边界进行处理。
&lt;ul>
&lt;li>“插件模块”，就是指网卡口插的模块。通常情况下来说，都是光模块。
&lt;ul>
&lt;li>光模块能显示的信息详见下文“&lt;a href="#yVQY0">光模块插件信息&lt;/a>”&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>这种信息一般只存在于具有模块网卡的物理机上。虚拟机或者无法插模块的网卡，是没有这种信息的，这时候获取信息，将会出现如下报错：&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>~&lt;span style="color:#f92672">]&lt;/span>&lt;span style="color:#75715e"># ethtool -m enp25s0f0&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Cannot get module EEPROM information: Invalid argument
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ul>
&lt;li>&lt;strong>-S, &amp;ndash;statistics&lt;/strong> # 获得特定于 NIC 和 驱动程序 的统计信息。&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>~&lt;span style="color:#f92672">]&lt;/span>&lt;span style="color:#75715e"># ethtool -S ens4f0&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>NIC statistics:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> rx_packets: &lt;span style="color:#ae81ff">100463573&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> tx_packets: &lt;span style="color:#ae81ff">59794837&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> rx_bytes: &lt;span style="color:#ae81ff">74687073845&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> tx_bytes: &lt;span style="color:#ae81ff">7381975533&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> rx_pkts_nic: &lt;span style="color:#ae81ff">100463561&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> tx_pkts_nic: &lt;span style="color:#ae81ff">59794820&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> rx_bytes_nic: &lt;span style="color:#ae81ff">75088927199&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> tx_bytes_nic: &lt;span style="color:#ae81ff">7672892990&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ......略
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="其他选项">其他选项&lt;/h3>
&lt;ul>
&lt;li>&lt;strong>-p, &amp;ndash;identify&lt;/strong> # 可以让指定网络设备关联的网卡上的 led 灯闪烁。&lt;strong>常用来在机房中识别机器网卡&lt;/strong>。&lt;/li>
&lt;li>&lt;strong>-s,&amp;ndash;change &lt;!-- raw HTML omitted -->&lt;/strong> # 允许更改指定网络设备的部分或全部设置。 以下所有选项仅在指定了-s 时适用。
&lt;ul>
&lt;li>&lt;strong>speed N&lt;/strong> # 用 Mb/s 作为单位设置网卡速率。Set speed in Mb/s. ethtool with just the device name as an argument will show you the supported device speeds.&lt;/li>
&lt;li>**duplex {half|full} **# 设置全双工或半双工模式&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h1 id="example">EXAMPLE&lt;/h1>
&lt;p>显示 veth1.1 对的状态信息，可以在 container 或 namespace 中查看绑定的另一半 veth 在 Host 上的网卡号&lt;/p>
&lt;ul>
&lt;li>ethtool -S veth1.1&lt;/li>
&lt;/ul>
&lt;p>设置 eth0 网卡速率为 100Mb/s，全双工&lt;/p>
&lt;ul>
&lt;li>ethtool -s eth0 speed 100 duplex full&lt;/li>
&lt;/ul>
&lt;h2 id="-m-选项信息">-m 选项信息&lt;/h2>
&lt;h3 id="光模块插件信息">光模块插件信息&lt;/h3>
&lt;ul>
&lt;li>&lt;strong>Identifier&lt;/strong> # 标识符。即该口上所插的模块信息。示例值：&lt;code>**0x03 (SFP)**&lt;/code>&lt;/li>
&lt;li>**Extended identifier **# 扩展标识符。模块的扩展信息。示例值：&lt;code>**0x04 (GBIC/SFP defined by 2-wire interface ID)**&lt;/code>&lt;/li>
&lt;li>**Connector **# 连接器信息。即. 示例值：&lt;code>**0x07 (LC)**&lt;/code>&lt;/li>
&lt;li>&lt;strong>Transceiver codes : 0x10 0x00 0x00 0x00 0x00 0x00 0x00 0x00&lt;/strong>&lt;/li>
&lt;li>**Transceiver type **# 收发器类型。示例值：&lt;code>**10G Ethernet: 10G Base-SR**&lt;/code>&lt;/li>
&lt;li>&lt;strong>Encoding : 0x06 (64B/66B)&lt;/strong>&lt;/li>
&lt;li>&lt;strong>BR, Nominal : 10300MBd&lt;/strong>&lt;/li>
&lt;li>&lt;strong>Rate identifier : 0x00 (unspecified)&lt;/strong>&lt;/li>
&lt;li>&lt;strong>Length (SMF,km) : 0km&lt;/strong>&lt;/li>
&lt;li>&lt;strong>Length (SMF) : 0m&lt;/strong>&lt;/li>
&lt;li>&lt;strong>Length (50um) : 80m&lt;/strong>&lt;/li>
&lt;li>&lt;strong>Length (62.5um) : 20m&lt;/strong>&lt;/li>
&lt;li>&lt;strong>Length (Copper) : 0m&lt;/strong>&lt;/li>
&lt;li>&lt;strong>Length (OM3) : 300m&lt;/strong>&lt;/li>
&lt;li>&lt;strong>Laser wavelength : 850nm&lt;/strong>&lt;/li>
&lt;li>&lt;strong>Vendor name : Hisense&lt;/strong>&lt;/li>
&lt;li>&lt;strong>Vendor OUI : 00:00:00&lt;/strong>&lt;/li>
&lt;li>&lt;strong>Vendor PN : LTF8502-BC+-H3C&lt;/strong>&lt;/li>
&lt;li>&lt;strong>Vendor rev : 1&lt;/strong>&lt;/li>
&lt;li>&lt;strong>Option values : 0x00 0x1a&lt;/strong>&lt;/li>
&lt;li>&lt;strong>Option : RX_LOS implemented&lt;/strong>&lt;/li>
&lt;li>**Option : TX_FAULT implemented **&lt;/li>
&lt;li>**Option : TX_DISABLE implemented **&lt;/li>
&lt;li>&lt;strong>BR margin, max : 20%&lt;/strong>&lt;/li>
&lt;li>&lt;strong>BR margin, min : 20%&lt;/strong>&lt;/li>
&lt;li>&lt;strong>Vendor SN : U8AA7H05H97&lt;/strong>&lt;/li>
&lt;li>&lt;strong>Date code : 200727__&lt;/strong>&lt;/li>
&lt;li>&lt;strong>Optical diagnostics support : Yes&lt;/strong>&lt;/li>
&lt;li>&lt;strong>光模块特有信息&lt;/strong>
&lt;ul>
&lt;li>**Laser bias current **# 激光偏置电流。示例值：&lt;code>**5.762 mA**&lt;/code>&lt;/li>
&lt;li>&lt;strong>Laser output power&lt;/strong> # 激光输出功率(光模块发送功率)。示例值：&lt;code>**0.5240 mW / -2.81 dBm**&lt;/code>&lt;/li>
&lt;li>**Receiver signal average optical power **# 接收信号的平均光功率(光模块接收功率)。示例值：&lt;code>**0.4646 mW / -3.33 dBm**&lt;/code>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>Module temperature : 26.32 degrees C / 79.38 degrees F&lt;/strong>&lt;/li>
&lt;li>&lt;strong>Module voltage : 3.3360 V&lt;/strong>&lt;/li>
&lt;li>&lt;strong>模块告警开关&lt;/strong>
&lt;ul>
&lt;li>&lt;strong>Alarm/warning flags implemented : Yes&lt;/strong>&lt;/li>
&lt;li>&lt;strong>Laser bias current high alarm : Off&lt;/strong>&lt;/li>
&lt;li>&lt;strong>Laser bias current low alarm : Off&lt;/strong>&lt;/li>
&lt;li>&lt;strong>Laser bias current high warning : Off&lt;/strong>&lt;/li>
&lt;li>&lt;strong>Laser bias current low warning : Off&lt;/strong>&lt;/li>
&lt;li>&lt;strong>Laser output power high alarm : Off&lt;/strong>&lt;/li>
&lt;li>&lt;strong>Laser output power low alarm : Off&lt;/strong>&lt;/li>
&lt;li>&lt;strong>Laser output power high warning : Off&lt;/strong>&lt;/li>
&lt;li>&lt;strong>Laser output power low warning : Off&lt;/strong>&lt;/li>
&lt;li>&lt;strong>Module temperature high alarm : Off&lt;/strong>&lt;/li>
&lt;li>&lt;strong>Module temperature low alarm : Off&lt;/strong>&lt;/li>
&lt;li>&lt;strong>Module temperature high warning : Off&lt;/strong>&lt;/li>
&lt;li>&lt;strong>Module temperature low warning : Off&lt;/strong>&lt;/li>
&lt;li>&lt;strong>Module voltage high alarm : Off&lt;/strong>&lt;/li>
&lt;li>&lt;strong>Module voltage low alarm : Off&lt;/strong>&lt;/li>
&lt;li>&lt;strong>Module voltage high warning : `Off&lt;/strong>&lt;/li>
&lt;li>&lt;strong>Module voltage low warning : Off&lt;/strong>&lt;/li>
&lt;li>&lt;strong>Laser rx power high alarm : Off&lt;/strong>&lt;/li>
&lt;li>&lt;strong>Laser rx power low alarm : Off&lt;/strong>&lt;/li>
&lt;li>&lt;strong>Laser rx power high warning : Off&lt;/strong>&lt;/li>
&lt;li>&lt;strong>Laser rx power low warning : Off&lt;/strong>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>模块告警阈值&lt;/strong>
&lt;ul>
&lt;li>&lt;strong>Laser bias current high alarm threshold : 16.500 mA&lt;/strong>&lt;/li>
&lt;li>&lt;strong>Laser bias current low alarm threshold : 1.000 mA&lt;/strong>&lt;/li>
&lt;li>&lt;strong>Laser bias current high warning threshold : 15.000 mA&lt;/strong>&lt;/li>
&lt;li>&lt;strong>Laser bias current low warning threshold : 1.000 mA&lt;/strong>&lt;/li>
&lt;li>&lt;strong>Laser output power high alarm threshold : 1.2589 mW / 1.00 dBm&lt;/strong>&lt;/li>
&lt;li>&lt;strong>Laser output power low alarm threshold : 0.0933 mW / -10.30 dBm&lt;/strong>&lt;/li>
&lt;li>&lt;strong>Laser output power high warning threshold : 0.7943 mW / -1.00 dBm&lt;/strong>&lt;/li>
&lt;li>&lt;strong>Laser output power low warning threshold : 0.1862 mW / -7.30 dBm&lt;/strong>&lt;/li>
&lt;li>&lt;strong>Module temperature high alarm threshold : 81.00 degrees C / 177.80 degrees F&lt;/strong>&lt;/li>
&lt;li>&lt;strong>Module temperature low alarm threshold : 0.00 degrees C / 32.00 degrees F&lt;/strong>&lt;/li>
&lt;li>&lt;strong>Module temperature high warning threshold : 78.00 degrees C / 172.40 degrees F&lt;/strong>&lt;/li>
&lt;li>&lt;strong>Module temperature low warning threshold : 3.00 degrees C / 37.40 degrees F&lt;/strong>&lt;/li>
&lt;li>&lt;strong>Module voltage high alarm threshold : 3.7950 V&lt;/strong>&lt;/li>
&lt;li>&lt;strong>Module voltage low alarm threshold : 2.8050 V&lt;/strong>&lt;/li>
&lt;li>&lt;strong>Module voltage high warning threshold : 3.5000 V&lt;/strong>&lt;/li>
&lt;li>&lt;strong>Module voltage low warning threshold : 3.1000 V&lt;/strong>&lt;/li>
&lt;li>&lt;strong>Laser rx power high alarm threshold : 1.2589 mW / 1.00 dBm&lt;/strong>&lt;/li>
&lt;li>&lt;strong>Laser rx power low alarm threshold : 0.0646 mW / -11.90 dBm&lt;/strong>&lt;/li>
&lt;li>&lt;strong>Laser rx power high warning threshold : 0.7943 mW / -1.00 dBm&lt;/strong>&lt;/li>
&lt;li>&lt;strong>Laser rx power low warning threshold : 0.1023 mW / -9.90 dBm&lt;/strong>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul></description></item><item><title>Docs: Iproute 工具包</title><link>https://desistdaydream.github.io/docs/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/X.Linux-%E7%AE%A1%E7%90%86/Linux-%E7%BD%91%E7%BB%9C%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/Iproute-%E5%B7%A5%E5%85%B7%E5%8C%85/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/X.Linux-%E7%AE%A1%E7%90%86/Linux-%E7%BD%91%E7%BB%9C%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/Iproute-%E5%B7%A5%E5%85%B7%E5%8C%85/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>官方文档：&lt;a href="https://wiki.linuxfoundation.org/networking/iproute2">https://wiki.linuxfoundation.org/networking/iproute2&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Iproute2">Wiki,Iproute2&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>Iprtoue2 是一组应用程序的集合，用于管理 Linux 网络栈。可以控制、监控 LInux 内核中网络栈的各个方面，包括路由、网络接口、隧道、流量控制、与网络相关的设备驱动程序。&lt;/p>
&lt;p>iproute2 基于 Linux 的 &lt;a href="https://www.yuque.com/go/doc/44482585">Netlink 接口&lt;/a> 与 LInux 内核通信，以实现网络栈管理功能。&lt;/p>
&lt;h2 id="该工具包包含如下工具">该工具包包含如下工具&lt;/h2>
&lt;ol>
&lt;li>
&lt;p>arpd&lt;/p>
&lt;/li>
&lt;li>
&lt;p>bridge # 显示或操纵 Linux 网桥 地址和设备&lt;/p>
&lt;/li>
&lt;li>
&lt;p>cbq&lt;/p>
&lt;/li>
&lt;li>
&lt;p>ctstat&lt;/p>
&lt;/li>
&lt;li>
&lt;p>devlink&lt;/p>
&lt;/li>
&lt;li>
&lt;p>genl&lt;/p>
&lt;/li>
&lt;li>
&lt;p>ifcfg&lt;/p>
&lt;/li>
&lt;li>
&lt;p>ifstat&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://www.yuque.com/go/doc/33221919">ip&lt;/a> # 显示或操纵 routing, devices, policy routing and tunnels&lt;/p>
&lt;/li>
&lt;li>
&lt;p>lnstat&lt;/p>
&lt;/li>
&lt;li>
&lt;p>nstat&lt;/p>
&lt;/li>
&lt;li>
&lt;p>rdma&lt;/p>
&lt;/li>
&lt;li>
&lt;p>routef&lt;/p>
&lt;/li>
&lt;li>
&lt;p>routel&lt;/p>
&lt;/li>
&lt;li>
&lt;p>rtacct&lt;/p>
&lt;/li>
&lt;li>
&lt;p>rtmon&lt;/p>
&lt;/li>
&lt;li>
&lt;p>rtpr&lt;/p>
&lt;/li>
&lt;li>
&lt;p>rtstat&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://www.yuque.com/go/doc/33221911">ss&lt;/a> # 转存 Socket 信息&lt;/p>
&lt;/li>
&lt;li>
&lt;p>tipc #&lt;/p>
&lt;/li>
&lt;li>
&lt;p>tc # 实现 &lt;a href="https://www.yuque.com/go/doc/34380573">TC 模块&lt;/a>进行流量控制的程序&lt;/p>
&lt;/li>
&lt;/ol>
&lt;h1 id="配置">配置&lt;/h1>
&lt;p>&lt;strong>/etc/iproute2/*&lt;/strong>#&lt;/p></description></item><item><title>Docs: Iproute 工具包</title><link>https://desistdaydream.github.io/docs/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/X.Linux-%E7%AE%A1%E7%90%86/Linux-%E7%BD%91%E7%BB%9C%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/Iproute-%E5%B7%A5%E5%85%B7%E5%8C%85/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/X.Linux-%E7%AE%A1%E7%90%86/Linux-%E7%BD%91%E7%BB%9C%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/Iproute-%E5%B7%A5%E5%85%B7%E5%8C%85/</guid><description/></item><item><title>Docs: Linux 代理配置</title><link>https://desistdaydream.github.io/docs/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/X.Linux-%E7%AE%A1%E7%90%86/Linux-%E7%BD%91%E7%BB%9C%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/Linux-%E4%BB%A3%E7%90%86%E9%85%8D%E7%BD%AE/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/X.Linux-%E7%AE%A1%E7%90%86/Linux-%E7%BD%91%E7%BB%9C%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/Linux-%E4%BB%A3%E7%90%86%E9%85%8D%E7%BD%AE/</guid><description>
&lt;h1 id="linux-代理服务相关变量">Linux 代理服务相关变量&lt;/h1>
&lt;ul>
&lt;li>http_proxy | https_proxy | ftp_proxy | all_proxy # 此变量值用于所有 http、https、ftp 或者所有流量&lt;/li>
&lt;li>socks_proxy # 在大多数情况下，它用于 TCP 和 UDP 流量。其值通常采用 socks：// address：port 格式。&lt;/li>
&lt;li>rsync_proxy # 这用于 rsync 流量，尤其是在 Gentoo 和 Arch 等发行版中。&lt;/li>
&lt;li>no_proxy # 以逗号分隔的域名或 IP 列表，应绕过代理。该本地主机就是一个很好的例子。一个例子是 localhost，127.0.0.1。&lt;/li>
&lt;/ul>
&lt;p>语法格式&lt;/p>
&lt;p>XXXX_proxy=&amp;ldquo;http://[USER:PASSWORD@]ServerIP:PORT/&amp;rdquo; # 需要设置用户名，密码，代理服务器的 IP 和端口，用户名和密码可省&lt;/p>
&lt;p>EXAMPLE&lt;/p>
&lt;ul>
&lt;li>
&lt;p>http_proxy=&amp;ldquo;http://tom:secret@10.23.42.11:8080/&amp;rdquo; # 设置本机的 http 代理服务器为 10.23.42.11:8080，用户名是 tom，密码是 secret&lt;/p>
&lt;/li>
&lt;li>
&lt;p>同时设置 3 种类型代理，没有用户名和密码，代理服务器是 192.168.19.79:1080&lt;/p>
&lt;ul>
&lt;li>export {https,ftp,http}_proxy=&amp;ldquo;127.0.0.1:8889&amp;rdquo;&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>all_proxy=&amp;ldquo;socks5://localhost:10808&amp;rdquo; # 使用本地 10808 端口的 socks 协议代理所有流量(e.g.安装完 v2ray 客户端并配置好启动后，即可使用该变量来让设备使用代理进行翻墙)&lt;/p>
&lt;/li>
&lt;li>
&lt;p>no_proxy=&amp;ldquo;10.&lt;em>.&lt;/em>.&lt;em>,192.168.&lt;/em>.&lt;em>,&lt;/em>.local,localhost,127.0.0.1&amp;rdquo; # 忽略指定 ip 的代理&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>注意：通过 Systemd 启动的进程，无法识别这些环境变量，只能通过 Unit File 中的 [Service] 部分的 Environment 指令指定代理信息。&lt;/strong>&lt;/p>
&lt;h1 id="linux-bash-终端设置代理proxy访问">Linux bash 终端设置代理（proxy）访问&lt;/h1>
&lt;p>Linux 是开源操作系统，有很多软件包需要从国外网站上下载，而其中大部分国外网站是被墙的，这时我们需要通过代理来访问这些网站。下面我们介绍 Linux bash shell 终端代理设置方法，包括 socks 代理，http 代理。&lt;/p>
&lt;p>一、linux shell 终端代理设置方法：&lt;/p>
&lt;p>linux 要在 shell 终端为 http、https、ftp 协议设置代理，值需要设置对应的环境变量即可。下面是一些关于代理的环境变量：&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>环境变量&lt;/th>
&lt;th>描述&lt;/th>
&lt;th>值示例&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>http_proxy&lt;/td>
&lt;td>为 http 网站设置代理；&lt;/td>
&lt;td>10.0.0.51:8080;&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>user:pass@10.0.0.10:8080
socks4://10.0.0.51:1080
socks5://192.168.1.1:1080 |
| https_proxy | 为 https 网站设置代理； | 同上 |
| ftp_proxy | 为 ftp 协议设置代理； | socks5://192.168.1.1:1080 |
| no_proxy | 无需代理的主机或域名；
可以使用通配符；
多个时使用“,”号分隔； | &lt;em>.aiezu.com,10.&lt;/em>.&lt;em>.&lt;/em>,192.168.&lt;em>.&lt;/em>,
*.local,localhost,127.0.0.1 |&lt;/p>
&lt;p>可以将上面 4 个环境变量设置项放于~/.bashrc 文件尾部，这样用户打开 bash shell 终端时会自动调用此脚本，读入它们。&lt;/p>
&lt;p>二、linux bash 为 http 站点设置代理：&lt;/p>
&lt;p>根据代理类型，将下面对应的设置项添加到~/.bashrc 文件末尾，然后运行&amp;quot;. ~/.bashrc&amp;quot;（前面是一个“.”号）命令使用之在当前环境生效。&lt;/p>
&lt;p>1、为 http 站点设置 http 代理（默认）：&lt;/p>
&lt;p>export http_proxy=10.0.0.52:8080&lt;/p>
&lt;p>2、为 http 站点设置 sock4、sock5 代理：&lt;/p>
&lt;p>设置 socks 代理，自动识别socks版本
export http_proxy=socks://10.0.0.52:1080
设置 socks4 代理
export http_proxy=socks4://10.0.0.52:1080
设置 socks5 代理
export http_proxy=socks5://10.0.0.52:1080&lt;/p>
&lt;p>3、代理使用用户名密码认证：&lt;/p>
&lt;p>export http_proxy=user:pass@192.158.8.8:8080&lt;/p>
&lt;p>三、linux bash 为 https 站点设置代理：&lt;/p>
&lt;p>如果需要为 https 网站设置代理，设置 https_proxy 环境变量即可；设置方法完全与 http_proxy 环境变量相同：&lt;/p>
&lt;p>任意使用一项&lt;/p>
&lt;p>export https_proxy=10.0.0.52:8080&lt;/p>
&lt;p>export https_proxy=user:pass@192.158.8.8:8080&lt;/p>
&lt;p>export https_proxy=socks://10.0.0.52:1080&lt;/p>
&lt;p>export https_proxy=socks4://10.0.0.52:1080&lt;/p>
&lt;p>export https_proxy=socks5://10.0.0.52:1080&lt;/p>
&lt;p>四、举例：&lt;/p>
&lt;p>现在我们要设置 http、https 网站都使用 socks5 代理 10.0.0.52:1080，下面为完整设置方法：&lt;/p>
&lt;p>1、vim ~/.bashrc，在文件尾部添加下面内容：
export http_proxy=socks5://10.0.0.52:1080
export https_proxy=socks5://10.0.0.52:1080
export no_proxy=&amp;quot;&lt;em>.aiezu.com,10.&lt;/em>.&lt;em>.&lt;/em>,192.168.&lt;em>.&lt;/em>,*.local,localhost,127.0.0.1&amp;quot; |&lt;/p>
&lt;p>2、加载设置:&lt;/p>
&lt;p>[root@aiezu.com ~]# . ~/.bashrc
[root@aiezu.com ~]# echo $http_proxy
socks5://10.0.0.52:1080
[root@aiezu.com ~]# echo $https_proxy
socks5://10.0.0.52:1080 |&lt;/p>
&lt;p>3、测试代理：&lt;/p>
&lt;p>[root@aiezu.com ~]# curl -I &lt;a href="http://www.fackbook.com">http://www.fackbook.com&lt;/a>
HTTP/1.1 200 OK
Content-Length: 2423
Content-Type: text/html
Last-Modified: Mon, 14 Nov 2016 22:03:32 GMT
Accept-Ranges: bytes
ETag: &amp;ldquo;0521af0c23ed21:0&amp;rdquo;
Server: Microsoft-IIS/7.5
X-Powered-By: ASP.NET
Date: Sun, 11 Dec 2016 13:21:33 GMT |&lt;/p>
&lt;h1 id="proxychains">proxychains&lt;/h1>
&lt;p>项目地址：&lt;a href="https://github.com/haad/proxychains">https://github.com/haad/proxychains&lt;/a>&lt;/p>
&lt;p>凡是通过 proxychains 程序运行的程序都会通过 proxychains 配置文件中设置的代理配置来发送数据包。&lt;/p>
&lt;p>apt install proxychains 即可&lt;/p>
&lt;p>修改配置文件&lt;/p>
&lt;p>sock5 127.0.0.1 10808 # 指定本地代理服务所监听的地址&lt;/p>
&lt;p>proxychains /opt/google/chrome/chrome # 即可通过代理打开 chrome 浏览器&lt;/p>
&lt;p>proxychains curl -I &lt;a href="https://www.google.com">https://www.google.com&lt;/a> 会成功&lt;/p></description></item><item><title>Docs: Netcat</title><link>https://desistdaydream.github.io/docs/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/X.Linux-%E7%AE%A1%E7%90%86/Linux-%E7%BD%91%E7%BB%9C%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/Netcat/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/X.Linux-%E7%AE%A1%E7%90%86/Linux-%E7%BD%91%E7%BB%9C%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/Netcat/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Netcat">Wike,Netcat&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://nmap.org/">Nmap 官网&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://nmap.org/ncat/">Nmap 官网-Ncat&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://nmap.org/book/ncat-man.html">Ncat Manual(手册)&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://man.openbsd.org/nc">OpenBSD-nc Manual(手册)&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://zhuanlan.zhihu.com/p/83959309">https://zhuanlan.zhihu.com/p/83959309&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>Netcat 是一个简单的实用程序通过 TCP 或 UDP 网络连接读取和写入数据。它旨在成为一个可靠的后端工具，可直接使用或轻松由其他程序和脚本驱动。同时，它还是一个功能丰富的网络调试和探索工具，因为它几乎可以创建您需要的任何类型的连接，包括端口绑定以接受传入连接。&lt;/p>
&lt;p>由于 Netcat 的设计理念和功能，被人亲切的亲切得称为 &lt;strong>网络工具中的瑞士军刀&lt;/strong>&lt;/p>
&lt;p>最初的 Netcat 是由霍比特人于 1995 年&lt;a href="http://seclists.org/bugtraq/1995/Oct/0028.html">发布&lt;/a>的，尽管它很受欢迎，但它并没有得到维护。有时甚至很难找到&lt;a href="http://download.insecure.org/stf/nc110.tgz">v1.10 源代码的副本&lt;/a>。该工具的灵活性和实用性促使 Nmap 项目产生&lt;a href="http://nmap.org/ncat/">Ncat&lt;/a>，这是一种支持 SSL、IPv6、SOCKS 和 http 代理、连接代理等的现代重新实现。除了 Nmap 项目重新了 Netcat，还有很多重写甚至扩展了 Netcat 的工具&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://sectools.org/tool/socat/">Socat&lt;/a>&lt;/li>
&lt;li>&lt;a href="http://www.openbsd.org/cgi-bin/cvsweb/src/usr.bin/nc/">OpenBSD 的 Netcat&lt;/a>&lt;/li>
&lt;li>&lt;a href="http://cryptcat.sourceforge.net/">Cryptcat&lt;/a>&lt;/li>
&lt;li>&lt;a href="http://www.deepspace6.net/projects/netcat6.html">Netcat6&lt;/a>&lt;/li>
&lt;li>&lt;a href="http://stromberg.dnsalias.org/~strombrg/pnetcat.html">pnetcat&lt;/a>&lt;/li>
&lt;li>&lt;a href="http://cycom.se/dl/sbd">SBD&lt;/a>&lt;/li>
&lt;li>所谓的&lt;a href="http://netcat.sourceforge.net/">GNU Netcat&lt;/a>&lt;/li>
&lt;/ul>
&lt;p>如需下载和更多信息， &lt;a href="http://en.wikipedia.org/wiki/Netcat">访问 Netcat 主页&lt;/a>。&lt;/p>
&lt;h2 id="ncat">Ncat&lt;/h2>
&lt;p>Ncat 是一个功能丰富的网络实用程序，它可以从命令行跨网络读取和写入数据。Ncat 由 Nmap 项目编写的，是对古老的 &lt;a href="http://sectools.org/tool/netcat/">Netcat&lt;/a> 的大大改进的重新实现。它同时使用 TCP 和 UDP 进行通信，并被设计为一种可靠的后端工具，可立即为其他应用程序和用户提供网络连接。Ncat 不仅适用于 IPv4 和 IPv6，还为用户提供了几乎无限的潜在用途。&lt;/p>
&lt;p>在 Ncat 的众多功能中，包括将 Ncat 链接在一起、将 TCP 和 UDP 端口重定向到其他站点、SSL 支持以及通过 SOCKS4 或 HTTP（CONNECT 方法）代理（以及可选的代理身份验证）进行代理连接的能力。一些通用原则适用于大多数应用程序，从而使您能够立即向通常不支持它的软件添加网络支持。&lt;/p>
&lt;p>Ncat 与 Nmap 集成，可在 Nmap 下载页面提供的标准 Nmap 下载包（包括源代码和 Linux、Windows 和 Mac 二进制文件）中找到。。您也可以在我们的&lt;a href="http://nmap.org/book/install.html#inst-svn">SVN 源代码存储库中&lt;/a>找到它。&lt;/p>
&lt;p>许多用户要求提供一个静态编译的 ncat.exe 版本，他们可以将其放在 Windows 系统上并使用，而无需运行任何安装程序或复制额外的库文件。我们已经构建了一个静态编译的 Windows 二进制版本的 Ncat 5.59BETA1。您可以在&lt;a href="http://nmap.org/dist/ncat-portable-5.59BETA1.zip">此处&lt;/a>下载 zip 文件。为确保文件未被篡改，您可以检查&lt;a href="http://nmap.org/book/install.html#inst-integrity">加密签名&lt;/a>。如果您需要更新的 Ncat 版本的便携版本，请参阅&lt;a href="https://secwiki.org/w/Nmap/Ncat_Portable">Ncat 便携编译说明&lt;/a>。&lt;/p>
&lt;p>该&lt;a href="https://nmap.org/ncat/guide/index.html">NCAT 用户指南&lt;/a>包含完整的文档，包括很多技巧，窍门和实用现实生活的例子！还有一个&lt;a href="https://nmap.org/book/ncat-man.html">Ncat 手册页&lt;/a>用于快速使用摘要。&lt;/p>
&lt;h2 id="openbsd-netcat">OpenBSD Netcat&lt;/h2>
&lt;h1 id="netcat-安装">Netcat 安装&lt;/h1>
&lt;h2 id="ubuntu">Ubuntu&lt;/h2>
&lt;p>Ubuntu 使用 OpenBSD 的 Netcat 作为 Netcat 的替代品&lt;/p>
&lt;p>安装 netcat-openbsd 包即可，安装完成后，nc 命令本质上是 nc.openbsd 命令的软链接&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/nnt66u/1626359398275-d7639c00-614d-4ff7-8b10-3e49b50eb576.png" alt="image.png">&lt;/p>
&lt;h2 id="centos">CentOS&lt;/h2>
&lt;p>CentOS 使用 Nmap 的 Ncat 作为 Netcat 的替代品&lt;/p>
&lt;p>安装 nmap-ncat 包即可，安装完成后，nc 命令本质上是 ncat 命令的软链接&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/nnt66u/1626359200164-165e5748-0a31-433b-bd62-0dcd3c157cf3.png" alt="image.png">&lt;/p>
&lt;h1 id="syntax语法">Syntax(语法)&lt;/h1>
&lt;p>&lt;strong>nc [&amp;lt;OPTIONS&amp;gt; &amp;hellip;] [ &amp;lt;hostname&amp;gt; ] [ &amp;lt;port&amp;gt; ]&lt;/strong>&lt;/p>
&lt;h2 id="options">OPTIONS&lt;/h2>
&lt;ul>
&lt;li>&lt;strong>-k, &amp;ndash;keep-open&lt;/strong> # 通常与 -l 选项配合使用。在监听模式下接受多个连接。若不使用 -k 选项，则第一个连接断开后，监听也就结束了。&lt;/li>
&lt;li>&lt;strong>-l, &amp;ndash;listen &amp;lt;PORT&amp;gt;&lt;/strong> # 让程序监听指定的端口&lt;/li>
&lt;li>&lt;strong>-u, &amp;ndash;udp&lt;/strong> # 使用 UDP，而不是默认的 TCP&lt;/li>
&lt;/ul>
&lt;p>Ncat 与 OpenBSD-nc 这两个程序的选项有不同的地方&lt;/p>
&lt;h3 id="ncat-options">Ncat OPTIONS&lt;/h3>
&lt;ul>
&lt;li>&lt;strong>&amp;ndash;proxy &lt;a href="ADDRESS:%5BPORT%5D">ADDRESS:[PORT]&lt;/a>&lt;/strong> # 连接目的地时所使用代理 IP 和 PORT。&lt;/li>
&lt;li>&lt;strong>&amp;ndash;proxy-type &amp;lt;STRING&amp;gt;&lt;/strong> # 连接目的地时所使用的代理类型(也就是代理协议)。可用的值有：
&lt;ul>
&lt;li>socks4 # 表示 SOCKS v.4&lt;/li>
&lt;li>socks5 # 表示 SOCKS v.5。默认值&lt;/li>
&lt;li>http # 表示 HTTP&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h3 id="openbsd-nc-options">OpenBSD-nc OPTIONS&lt;/h3>
&lt;ul>
&lt;li>&lt;strong>-x &amp;lt;ADDRESS[:PORT]&amp;gt;&lt;/strong> # 连接目的地时所使用代理 IP 和 PORT。代理不能与 -LsuU 这些选项一起使用。&lt;/li>
&lt;li>&lt;strong>-X &amp;lt;PROTOCOL&amp;gt;&lt;/strong> # 连接目的地时所使用的代理协议。可用的值有：
&lt;ul>
&lt;li>4 # 表示 SOCKS v.4&lt;/li>
&lt;li>5 # 表示 SOCKS v.5。默认值&lt;/li>
&lt;li>connect # 表示 HTTP&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h1 id="应用示例">应用示例&lt;/h1>
&lt;ul>
&lt;li>测试本地 323/udp 端口
&lt;ul>
&lt;li>nc -uvz localhost 323&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>测试本地 22/tcp 端口
&lt;ul>
&lt;li>nc -vz localhost 22&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>执行效果如下：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>~&lt;span style="color:#f92672">]&lt;/span>&lt;span style="color:#75715e"># nc -vz localhost 22&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Connection to localhost &lt;span style="color:#ae81ff">22&lt;/span> port &lt;span style="color:#f92672">[&lt;/span>tcp/ssh&lt;span style="color:#f92672">]&lt;/span> succeeded!
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>~&lt;span style="color:#f92672">]&lt;/span>&lt;span style="color:#75715e"># nc -uvz localhost 323&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Connection to localhost &lt;span style="color:#ae81ff">323&lt;/span> port &lt;span style="color:#f92672">[&lt;/span>udp/*&lt;span style="color:#f92672">]&lt;/span> succeeded!
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>测试两台机器之间的 8080/udp 连接是否正常&lt;/p>
&lt;ul>
&lt;li>在主机 A 上监听 8080/udp
&lt;ul>
&lt;li>nc -u -l 8080&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>在主机 B 上测试主机 A 的 8080/udp 是否正常
&lt;ul>
&lt;li>nc -u 172.19.42.248 8080&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>然后在任意主机输入任意内容，只要另一个主机能看到相同内容，即表示连接正常&lt;/li>
&lt;/ul>
&lt;h1 id="常见问题">常见问题&lt;/h1>
&lt;p>在 Windows 使用 ncat 通过代理连接 ssh，报错 &lt;code>ssh_exchange_identification: Connection closed by remote host&lt;/code>&lt;/p>
&lt;p>问题 issue：&lt;a href="https://github.com/nmap/nmap/issues/2149">https://github.com/nmap/nmap/issues/2149&lt;/a>&lt;/p>
&lt;p>解决：下载 7.80 版本即可，将下载连接的版本号改为 7.80 即可下载。&lt;/p>
&lt;h1 id="nmap">Nmap&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://nmap.org/book/man.html">Manual(手册),NMAP(1)&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>&lt;strong>Network Mapper(网络映射器，简称 Nmap)&lt;/strong> 是一个用于网络探索和安全审计的开源工具。旨在快速扫描大型网络。&lt;/p>
&lt;h2 id="syntax语法-1">Syntax(语法)&lt;/h2>
&lt;p>&lt;strong>nmap [Scan Type&amp;hellip;] [OPTIONS] {TARGET}&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>&lt;strong>Scan Type(扫描类型)&lt;/strong> #&lt;/li>
&lt;li>**TARGET **# 扫描目标&lt;/li>
&lt;/ul>
&lt;p>直接使用 &lt;code>nmap IP&lt;/code> 即可开始一个简单的扫描任务&lt;/p>
&lt;h2 id="example">EXAMPLE&lt;/h2></description></item><item><title>Docs: Socat</title><link>https://desistdaydream.github.io/docs/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/X.Linux-%E7%AE%A1%E7%90%86/Linux-%E7%BD%91%E7%BB%9C%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/Socat/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/X.Linux-%E7%AE%A1%E7%90%86/Linux-%E7%BD%91%E7%BB%9C%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/Socat/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>官网：&lt;a href="http://www.dest-unreach.org/socat/">http://www.dest-unreach.org/socat/&lt;/a>&lt;/li>
&lt;li>官方文档：&lt;a href="http://www.dest-unreach.org/socat/doc/socat.html">http://www.dest-unreach.org/socat/doc/socat.html&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>Socat 是一个多功能的网络工具，名字来由是” Socket CAT”，可以看作是 netcat 的 N 倍加强版。&lt;/p>
&lt;p>Socat 是一个两个独立数据通道之间的双向数据传输的继电器。这些数据通道包含文件、管道、设备（终端或调制解调器等）、socket（Unix，IP4，IP6 - raw，UDP，TCP）、SSL、SOCKS4 客户端或代理 CONNECT。&lt;/p>
&lt;p>Socat 支持广播和多播、抽象 Unix sockets、Linux tun/tap、GNU readline 和 PTY。它提供了分叉、记录和进程间通信的不同模式。多个选项可用于调整 socat 和其渠道，Socat 可以作为 TCP 中继（一次性或守护进程），作为一个守护进程基于 socksifier，作为一个 shell Unix 套接字接口，作为 IP6 的继电器，或面向 TCP 的程序重定向到一个串行线。&lt;/p>
&lt;p>socat 的主要特点就是在两个数据流之间建立通道；且支持众多协议和链接方式：ip, tcp, udp, ipv6, pipe,exec,system,open,proxy,openssl,socket 等。&lt;/p>
&lt;p>工作原理&lt;/p>
&lt;p>socat 的运行有 4 个阶段:&lt;/p>
&lt;ul>
&lt;li>初始化 解析命令行以及初始化日志系统。&lt;/li>
&lt;li>打开连接 先打开第一个连接，再打开第二个连接。这个单步执行的。 如果第一个连接失败，则会直接退出。&lt;/li>
&lt;li>数据转发 谁有数据就转发到另外一个连接上, read/write 互换。&lt;/li>
&lt;li>关闭 其中一个连接掉开，执行处理另外一个连接。&lt;/li>
&lt;li>地址类型 参数由 2 部分组成，第一个连接和第二个连接，最简单的用法就是 socat - - 其效果就是输入什么，回显什么其用法主要在于地址如何描述, 下面介绍几个常用的。&lt;/li>
&lt;li>TCP&lt;/li>
&lt;/ul>
&lt;p>TCP:&lt;!-- raw HTML omitted -->:&lt;!-- raw HTML omitted --> 目标机器 IP 对应端口 portTCP-LISTEN:&lt;!-- raw HTML omitted --> 本机监听端口。&lt;/p>
&lt;ul>
&lt;li>UDP&lt;/li>
&lt;/ul>
&lt;p>UDP:&lt;!-- raw HTML omitted -->:&lt;!-- raw HTML omitted --> 目标机器 host 对应端口 portUDP-LISTEN:&lt;!-- raw HTML omitted --> 本机监听端口。&lt;/p>
&lt;ul>
&lt;li>OPENSSL&lt;/li>
&lt;/ul>
&lt;p>需要一个证书,否则会失败提示: 2012/04/06 11:29:11 socat[1614] E SSL_connect(): error:14077410:SSL routines:SSL23_GET_SERVER_HELLO:sslv3 alert handshake failure&lt;/p>
&lt;p>OPENSSL:&lt;!-- raw HTML omitted -->:&lt;!-- raw HTML omitted --> 目标机器 host 对应端口 portOPENSSL-LISTEN:&lt;!-- raw HTML omitted --> 本机监听端口。&lt;/p>
&lt;ul>
&lt;li>TUN&lt;/li>
&lt;/ul>
&lt;p>Syntax(语法)&lt;/p>
&lt;p>&lt;strong>socat [OPTIONS] &lt;!-- raw HTML omitted --> &lt;!-- raw HTML omitted -->&lt;/strong>&lt;/p>
&lt;h2 id="options">OPTIONS&lt;/h2>
&lt;p>ADDRESS&lt;/p>
&lt;p>ADDRESS 类似于一个文件描述符，socat 所做的工作就是在 2 个 ADDRESS 指定的描述符间建立一个 pipe 用于发送和接收数据。&lt;/p>
&lt;p>格式为：&lt;code>AddressTYPE[:ARGS][,OPTIONS]&lt;/code>&lt;/p>
&lt;h3 id="addresstype">AddressTYPE&lt;/h3>
&lt;ul>
&lt;li>STDIN, STDOUT # 表示标准输入输出，可以使用 &lt;code>-&lt;/code> 符号代替&lt;/li>
&lt;li>/PATH/TO/FILE # 任意路径，也可以使用相对路径，打开一个文件作为数据流&lt;/li>
&lt;li>tcp # 建立一个 TCP 连接作为数据流&lt;/li>
&lt;li>tcp-listen:PORT # 建立 TCP 监听端口&lt;/li>
&lt;li>EXEC # 指定一个程序作为数据流&lt;/li>
&lt;li>unix #&lt;/li>
&lt;li>&lt;/li>
&lt;/ul>
&lt;h3 id="addressoptions">AddressOPTIONS&lt;/h3>
&lt;h1 id="example">EXAMPLE&lt;/h1>
&lt;ul>
&lt;li>测试 172.19.42.243 的 161/UDP 端口
&lt;ul>
&lt;li>socat - udp:172.19.42.243:161&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>类似于 cat 命令，将 /var/log/messages 中的内容输出到标准输出
&lt;ul>
&lt;li>socat - /var/log/messages&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>监听本机 500 端口 并与 标准输入输出 建立连接。当其他设备 telnet 到本端口时，输入输出都会在两端互相显示。
&lt;ul>
&lt;li>socat tcp-listen:500 -&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>监听本地的 18080 端口，所有到 18080 的数据包，都会转发给 172.19.42.248 的 8080 端口
&lt;ul>
&lt;li>socat TCP-LISTEN:18080,fork,reuseaddr  TCP:172.19.42.248:8080&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>在本地 8080 端口与 docker 的 sock 建立连接。直接访问 &lt;a href="http://172.38.40.250:8080/debug/pprof/">http://172.38.40.250:8080/debug/pprof/&lt;/a> 可以 debug docker(最后的 / 不能少)。
&lt;ul>
&lt;li>socat -d -d tcp-listen:8080,fork,bind:172.38.40.250 UNIX:/var/run/docker.sock&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>连接目标&lt;/p>
&lt;p>&lt;code>socat - tcp:192.168.1.18:80&lt;/code>&lt;/p>
&lt;p>这个命令等同于 nc 192.168.1.18 80。&lt;/p>
&lt;p>socat 里面，必须有两个流，所以第一个参数-代表标准的输入输出，第二个流连接到 192.168.1.18 的 80 端口。&lt;/p>
&lt;p>&lt;code>socat -d -d READLINE,history=$HOME/.http_history TCP4:www.qq.com:80&lt;/code>&lt;/p>
&lt;p>这个例子支持历史记录查询，类似于 bash 的历史记录。&lt;/p>
&lt;h3 id="反向连接">反向连接&lt;/h3>
&lt;p>再看一个反向 telnet 的例子： on server:&lt;/p>
&lt;p>&lt;code>socat tcp-listen:23 exec:cmd,pty,stderr&lt;/code>&lt;/p>
&lt;p>这个命名把 cmd 绑定到端口 23，同时把 cmd 的 Stderr 复位向到 stdout。&lt;/p>
&lt;p>on client:&lt;/p>
&lt;p>&lt;code>socat readline tcp:server:23&lt;/code>&lt;/p>
&lt;p>连接到服务器的 23 端口，即可获得一个 cmd shell。readline 是 gnu 的命令行编辑器，具有历史功能。&lt;/p>
&lt;h3 id="向远程端口发数据">向远程端口发数据&lt;/h3>
&lt;p>&lt;code>echo “test” | socat – tcp-connect:127.0.0.1:12345&lt;/code>&lt;/p>
&lt;h3 id="本地开启端口">本地开启端口&lt;/h3>
&lt;p>&lt;code>socat tcp-l:7777,reuseaddr,fork system:bash&lt;/code>&lt;/p>
&lt;p>同 nc -l -p 7777 -e bash。&lt;/p>
&lt;h3 id="执行-bash-的完美用法">执行 bash 的完美用法&lt;/h3>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>&lt;/th>
&lt;th>&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>服务端&lt;/td>
&lt;td>&lt;code>socat tcp-l:8888 system:bash,pty,stderr&lt;/code>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>本地&lt;/td>
&lt;td>&lt;code>socat readline tcp:$target:8888&lt;/code>&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>用 readline 替代-，就能支持历史功能了。在这个模式下的客户端有本地一样的效果&lt;/p>
&lt;h3 id="文件传递">文件传递&lt;/h3>
&lt;p>再看文件传递的例子。nc 也经常用来传递文件，但是 nc 有一个缺点，就是不知道文件什么时候传完了，一般要用 Ctrl+c 来终止，或者估计一个时间，用-w 参数来让他自动终止。用 socat 就不用这么麻烦了：&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>&lt;/th>
&lt;th>&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>on host 1&lt;/td>
&lt;td>socat -u open:myfile.exe,binary tcp-listen:999&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>on host 2&lt;/td>
&lt;td>socat -u tcp:host1:999 open:myfile.exe,create,binary&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>这个命令把文件 myfile.exe 用二进制的方式，从 host 1 传到 host 2。-u 表示数据单向流动，从第一个参数到第二个参数，-U 表示从第二个到第一个。文件传完了，自动退出。&lt;/p>
&lt;h3 id="转发">转发&lt;/h3>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>&lt;/th>
&lt;th>&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>本地端口转向远程主机&lt;/td>
&lt;td>socat TCP4-LISTEN:8888 TCP4:www.qq.com:80&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>如果需要使用并发连接，则加一个 fork,如下:&lt;/p>
&lt;p>&lt;code>socat TCP4-LISTEN:8888,fork TCP4:www.qq.com:80&lt;/code>&lt;/p>
&lt;p>本地监听 8888 端口，来自 8888 的连接重定向到目标www.qq.com:80&lt;/p>
&lt;h3 id="端口映射">端口映射&lt;/h3>
&lt;p>再来一个大家喜欢用的例子。在一个 NAT 环境，如何从外部连接到内部的一个端口呢？只要能够在内部运行 socat 就可以了。&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>&lt;/th>
&lt;th>&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>外部&lt;/td>
&lt;td>socat tcp-listen:1234 tcp-listen:3389&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>内部&lt;/td>
&lt;td>socat tcp:outerhost:1234 tcp:192.168.12.34:3389&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>这样，你外部机器上的 3389 就映射在内部网 192.168.12.34 的 3389 端口上。&lt;/p>
&lt;h3 id="vpn">VPN&lt;/h3>
&lt;p>| 服务端 | socat -d -d TCP-LISTEN:11443,reuseaddr TUN:192.168.255.1/24,up | | 客户端 | socat TCP:1.2.3.4:11443 TUN:192.168.255.2/24,up |&lt;/p>
&lt;h3 id="重定向">重定向&lt;/h3>
&lt;p>&lt;code>socat TCP4-LISTEN:80,reuseaddr,fork TCP4:192.168.123.12:8080&lt;/code>&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>&lt;/th>
&lt;th>&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>TCP4-LISTEN&lt;/td>
&lt;td>在本地建立的是一个 TCP ipv4 协议的监听端口&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>reuseaddr&lt;/td>
&lt;td>绑定本地一个端口；&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>fork&lt;/td>
&lt;td>设定多链接模式，即当一个链接被建立后，自动复制一个同样的端口再进行监听&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>socat 启动监听模式会在前端占用一个 shell，因此需使其在后台执行。&lt;/p>
&lt;p>&lt;code>socat -d -d tcp4-listen:8900,reuseaddr,fork tcp4:10.5.5.10:3389&lt;/code>&lt;/p>
&lt;p>或者&lt;/p>
&lt;p>&lt;code>socat -d -d -lf /var/log/socat.log TCP4-LISTEN:15000,reuseaddr,fork,su=nobody TCP4:static.5iops.com:15000-d -d -lf /var/log/socat.log&lt;/code>是参数，前面两个连续的&lt;code>-d -d&lt;/code>代表调试信息的输出级别，&lt;code>-lf&lt;/code>则指定输出信息的保存文件。&lt;code>TCP4-LISTEN:15000,reuseaddr,fork,su=nobody&lt;/code>是一号地址，代表在 15000 端口上进行 TCP4 协议的监听，复用绑定的 IP，每次有连接到来就 fork 复制一个进程进行处理，同时将执行用户设置为 nobody 用户。&lt;code>TCP4:static.5iops.com:15000&lt;/code>是二号地址，代表将 socat 监听到的任何请求，转发到&lt;code>static.5iops.com:15000&lt;/code>上去。&lt;/p>
&lt;h3 id="读写分流">读写分流&lt;/h3>
&lt;p>socat 还具有一个独特的读写分流功能，比如：&lt;/p>
&lt;pre>&lt;code>socat open:read.txt!!open:write.txt,create,append tcp-listen:80,reuseaddr,fork
&lt;/code>&lt;/pre>
&lt;p>1
Plain Text&lt;/p>
&lt;p>这个命令实现一个假的 web server，客户端连过来之后，就把 read.txt 里面的内容发过去，同时把客户的数据保存到 write.txt 里面。”！！”符号用户合并读写流，前面的用于读，后面的用于写。&lt;/p>
&lt;h3 id="通过-openssl-来加密传输过程">通过 openssl 来加密传输过程&lt;/h3>
&lt;p>证书生成&lt;/p>
&lt;pre>&lt;code>FILENAME=60.*.*.*
openssl genrsa -out $FILENAME.key 1024
openssl req -new -key $FILENAME.key -x509 -days 3653 -out $FILENAME.crtcat $FILENAME.key $FILENAME.crt &amp;gt;$FILENAME.pem
&lt;/code>&lt;/pre>
&lt;p>1
2
3
Plain Text&lt;/p>
&lt;p>在当前目录下生成 &lt;code>server.pem 、server.crt&lt;/code>&lt;/p>
&lt;p>使用&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>&lt;/th>
&lt;th>&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>服务端&lt;/td>
&lt;td>socat openssl-listen:4433,reuseaddr,cert=srv.pem,cafile=srv.crt system:bash,pty,stderr&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>本地&lt;/td>
&lt;td>socat readline openssl:localhost:4433,cert=srv.pem,cafile=srv.crt&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table></description></item><item><title>Docs: wget</title><link>https://desistdaydream.github.io/docs/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/X.Linux-%E7%AE%A1%E7%90%86/Linux-%E7%BD%91%E7%BB%9C%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/wget/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/X.Linux-%E7%AE%A1%E7%90%86/Linux-%E7%BD%91%E7%BB%9C%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/wget/</guid><description>
&lt;p>语法格式&lt;/p>
&lt;p>OPTIONS&lt;/p>
&lt;ul>
&lt;li>-O NAME # 下载后重命名为指定的 NAME&lt;/li>
&lt;/ul>
&lt;p>EXAMPLE&lt;/p>
&lt;ul>
&lt;li>wget -q -O - &lt;a href="http://www.baidu.com/">http://www.baidu.com/&lt;/a> # 不下载，将 URL 为&lt;a href="http://www.baidu.com/">http://www.baidu.com/&lt;/a>的内容输出到标准输出上&lt;/li>
&lt;/ul></description></item><item><title>Docs: 流量监控与处理工具</title><link>https://desistdaydream.github.io/docs/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/X.Linux-%E7%AE%A1%E7%90%86/Linux-%E7%BD%91%E7%BB%9C%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/%E6%B5%81%E9%87%8F%E7%9B%91%E6%8E%A7%E4%B8%8E%E5%A4%84%E7%90%86%E5%B7%A5%E5%85%B7/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/X.Linux-%E7%AE%A1%E7%90%86/Linux-%E7%BD%91%E7%BB%9C%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/%E6%B5%81%E9%87%8F%E7%9B%91%E6%8E%A7%E4%B8%8E%E5%A4%84%E7%90%86%E5%B7%A5%E5%85%B7/</guid><description>
&lt;h1 id="heading">&lt;/h1>
&lt;h1 id="iftop">iftop&lt;/h1>
&lt;p>iftop 是一个类似 top 的命令，只不过是监控系统网络中数据传输情况的，使用该命令默认打开如下的界面
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/rg36ax/1616165049582-f8d34053-bca3-4e59-8077-83baefca9e4a.png" alt="">
界面上面显示的是类似刻度尺的刻度范围，为显示流量图形的长条作标尺用的。
中间的&amp;lt;= =&amp;gt;这两个左右箭头，表示的是流量的方向。&lt;/p>
&lt;ul>
&lt;li>TX：发送流量&lt;/li>
&lt;li>RX：接收流量&lt;/li>
&lt;li>TOTAL：总流量&lt;/li>
&lt;li>Cumm：运行 iftop 到目前时间的总流量&lt;/li>
&lt;li>peak：流量峰值&lt;/li>
&lt;li>rates：分别表示过去 2s 10s 40s 的平均流量&lt;/li>
&lt;/ul>
&lt;p>OPTIONS：
其中有一些选项，可以用在打开 iftop 程序之后，这些选项使用 黄色背景 来表示在 iftop 程序中使用的字母&lt;/p>
&lt;ul>
&lt;li>&lt;strong>-F&lt;/strong># 显示特定网段的进出流量，如# iftop -F 10.10.1.0/24 或# iftop -F 10.10.1.0/255.255.255.0&lt;/li>
&lt;li>&lt;strong>-i &amp;lt;DEV&amp;gt;&lt;/strong> # 指定要监测的网卡&lt;/li>
&lt;li>&lt;strong>-n&lt;/strong> # 不进行主机名的查找，e.g.显示 ip 而不显示主机名&lt;/li>
&lt;li>&lt;strong>-N&lt;/strong> # 显示端口号时，直接显示端口号，而不显示使用端口的进程名。&lt;/li>
&lt;li>&lt;strong>-P&lt;/strong> # 在展示界面显示每个连接的端口。也就是说显示当前连接的流量是哪个进程的。&lt;/li>
&lt;/ul>
&lt;p>EXAMPLE&lt;/p>
&lt;ul>
&lt;li>iftop -P #&lt;/li>
&lt;/ul>
&lt;h1 id="nethogs-网络流量监控工具">Nethogs 网络流量监控工具&lt;/h1>
&lt;p>nethogs 可以根据进程来查看网络带宽利用率。nethogs 类似于网络版的 top 命令，如果有突发的网络流量增大，可以使用 nethogs 去定位是哪一个 PID 造成的。&lt;/p>
&lt;p>直接使用 yum 进行安装即可，yum -y install nethogs&lt;/p>
&lt;p>直接执行 nethogs 命令，即可像 top 命令一样打开一个窗口实时显示当前有流量的进程，如图所示&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/rg36ax/1616165049610-12cf9dda-f16c-420d-8a75-a156882f4e25.png" alt="">&lt;/p>
&lt;p>该监控程序会显示进程的 PID，用户，进程的程序，通过哪个网卡产生的流量，发送流量和接受流量&lt;/p>
&lt;h2 id="nethogs-options-device">nethogs [OPTIONS] [DEVICE&amp;hellip;.]&lt;/h2>
&lt;p>可以指定 DEVICE 来监控指定网卡的流量，Note：可以指定多个网卡&lt;/p>
&lt;p>OPTIONS&lt;/p>
&lt;ol>
&lt;li>-b : bughunt mode - implies tracemode.&lt;/li>
&lt;li>-d # 每次刷新数据的时间间隔，默认为 1 秒&lt;/li>
&lt;li>-v : view mode (0 = KB/s, 1 = total KB, 2 = total B, 3 = total MB). default is 0.&lt;/li>
&lt;li>-c : number of updates. default is 0 (unlimited).&lt;/li>
&lt;li>-t # 追踪模式，类似于 tailf 命令，不再显示 top 命令式的窗口&lt;/li>
&lt;li>-p : sniff in promiscious mode (not recommended).&lt;/li>
&lt;li>-s : sort output by sent column.&lt;/li>
&lt;li>-a : monitor all devices, even loopback/stopped ones.&lt;/li>
&lt;/ol>
&lt;p>当 nethogs 运行时，可以在打开的窗口执行下面的命令进行操作&lt;/p>
&lt;ol>
&lt;li>q # 退出&lt;/li>
&lt;li>s # 按照发送流量排序 sort by SENT traffic&lt;/li>
&lt;li>r # 按照接收流量排序 sort by RECEIVE traffic&lt;/li>
&lt;li>m # 在总流量计数(KB、B、MB)和流量速速(KB/s)之间切换显示方式&lt;/li>
&lt;/ol>
&lt;h1 id="vnstat-监控网卡流量的工具">vnstat 监控网卡流量的工具&lt;/h1>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/rg36ax/1616165049568-900ba26e-a259-42dd-8f08-b58a6fde585f.png" alt="">&lt;/p>
&lt;h2 id="vnstat-options">vnstat &amp;lt;OPTIONS&amp;gt;&lt;/h2>
&lt;p>OPTIONS:&lt;/p>
&lt;ul>
&lt;li>-q, &amp;ndash;query query database&lt;/li>
&lt;li>-h, &amp;ndash;hours show hours&lt;/li>
&lt;li>-d, &amp;ndash;days show days&lt;/li>
&lt;li>-m, &amp;ndash;months show months&lt;/li>
&lt;li>-w, &amp;ndash;weeks show weeks&lt;/li>
&lt;li>-t, &amp;ndash;top10 show top 10 days&lt;/li>
&lt;li>-s, &amp;ndash;short use short output&lt;/li>
&lt;li>-u, &amp;ndash;update update database&lt;/li>
&lt;li>-i, &amp;ndash;iface # 指定要监控的网络设备，默认为 eth0&lt;/li>
&lt;li>-?, &amp;ndash;help short help&lt;/li>
&lt;li>-v, &amp;ndash;version show version&lt;/li>
&lt;li>-tr, &amp;ndash;traffic calculate traffic&lt;/li>
&lt;li>-ru, &amp;ndash;rateunit swap configured rate unit&lt;/li>
&lt;li>-l, &amp;ndash;live # 实时显示传输速率&lt;/li>
&lt;/ul>
&lt;h2 id="example">EXAMPLE&lt;/h2>
&lt;ol>
&lt;li>vnstat -i eth0 -l # 查看 eth0 网卡的实时流量，结束后，会显示从命令开始执行到结束总共的网卡 收/发 流量的最大、最小、平均值&lt;/li>
&lt;/ol></description></item><item><title>Docs: 网络链路追踪工具</title><link>https://desistdaydream.github.io/docs/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/X.Linux-%E7%AE%A1%E7%90%86/Linux-%E7%BD%91%E7%BB%9C%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/%E7%BD%91%E7%BB%9C%E9%93%BE%E8%B7%AF%E8%BF%BD%E8%B8%AA%E5%B7%A5%E5%85%B7/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/X.Linux-%E7%AE%A1%E7%90%86/Linux-%E7%BD%91%E7%BB%9C%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/%E7%BD%91%E7%BB%9C%E9%93%BE%E8%B7%AF%E8%BF%BD%E8%B8%AA%E5%B7%A5%E5%85%B7/</guid><description>
&lt;h1 id="trace-路由追踪">trace 路由追踪&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;/blockquote>
&lt;p>Linux 中有两个工具可以用来追踪路由，tracepath 与 traceroute。tracepath 工具包含在 iputils 包中，安装完系统可以直接使用。traceroute 是单独的一个包，需要手动安装。&lt;/p>
&lt;p>默认使用 UDP 来进行追踪。&lt;/p>
&lt;p>下面是 tracepath 工具输出的信息&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>~&lt;span style="color:#f92672">]&lt;/span>&lt;span style="color:#75715e"># tracepath qq.com -n&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>1?: &lt;span style="color:#f92672">[&lt;/span>LOCALHOST&lt;span style="color:#f92672">]&lt;/span> pmtu &lt;span style="color:#ae81ff">1500&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>1: no reply
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>2: 10.20.1.1 1.205ms
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>.....
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>6: 111.33.170.185 3.582ms
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>7: 117.131.130.137 6.999ms
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>8: 221.183.13.45 6.017ms asymm &lt;span style="color:#ae81ff">9&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>9: 221.183.38.61 7.326ms asymm &lt;span style="color:#ae81ff">8&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>第一列为 TTL 的值。TTL(Time To Live)存活时间，指一个数据包到达目的地时，可传递的最长距离(Hop)。每当数据包经过一个路由器时，其存活次数就会减一，当存货次数为 0 时，路由器会丢弃该数据包。TTL 的设计目的时为了防止数据包因为不正确的路由表等原因造成的无限循环而无法送达目的地。&lt;/p>
&lt;p>第二列为每个 hop (i.e.每跳)的信息(就是路由吓一跳的地址)。注意，如果当前 hop 的设备禁止 icmp 报文，那么该 hop 无法显示地址。&lt;/p>
&lt;p>剩下的信息为当前 hop 路径点的信息。这些信息包含如下内容&lt;/p>
&lt;ul>
&lt;li>RTT 的值(默认显示的信息)。RTT(Round-trip delay time)来回通信延迟。指在双方通信中，发讯方的信号（Signal）传播（Propagation）到收讯方的时间（意即：传播延迟（Propagation delay）），加上收讯方回传消息到发讯方的时间（如果没有造成双向传播速率差异的因素，此时间与发讯方将信号传播到收讯方的时间一样久）&lt;/li>
&lt;li>MTU 的值。如果当前 hop 的 MTU 与上一个 hop 的 MTU 不相同，即显示。&lt;/li>
&lt;li>asymm 的值。如果路径是不对称的，或者探测在到达指定跳之前完成，则显示前向和后向跳数之间的差异。这一信息不可靠。F.E.第三行显示 1 的不对称性，这是因为第一次 TTL 为 2 的探针在第一跳时由于路径 MTU 发现而被拒绝。&lt;/li>
&lt;/ul>
&lt;h2 id="tracepath--n--b--l-pktlen--m-max_hops--p-port-destination">tracepath [-n] [-b] [-l pktlen] [-m max_hops] [-p port] destination&lt;/h2>
&lt;p>OPTIONS
默认是&lt;code>-U&lt;/code>选项使用 UDP 的 33434 端口进行侦测&lt;/p>
&lt;ul>
&lt;li>-n # 不进行域名解析，单纯用 IP&lt;/li>
&lt;li>-b # Print both of host names and IP addresses.&lt;/li>
&lt;li>-l # Sets the initial packet length to pktlen instead of 65535 for tracepath or 128000 for tracepath6.&lt;/li>
&lt;li>-m # 将最大 hots(或者最大 TTLs)设置为 max_hops，而不是默认的 30&lt;/li>
&lt;li>-p # Sets the initial destination port to use.&lt;/li>
&lt;/ul>
&lt;h2 id="traceroute">traceroute&lt;/h2>
&lt;p>OPTIONS&lt;/p>
&lt;ul>
&lt;li>-n&lt;/li>
&lt;li>-T # 使用 TCP 进行侦测，一般是 80 端口。当默认 UDP trace 不到目标的时候，可以尝试使用 TCP 来 trace&lt;/li>
&lt;li>-i &lt;!-- raw HTML omitted --> 使用 DEV 的网卡来进行 trace&lt;/li>
&lt;/ul>
&lt;p>EXAMPLE&lt;/p>
&lt;ul>
&lt;li>&lt;strong>traceroute -w 1 -n -T baidu.com&lt;/strong> # 使用 TCP 协议追踪 baidu.com 的路由经过，不进行 DNS，如果 1 秒没回复则终端&lt;/li>
&lt;/ul>
&lt;h1 id="ping-测试网络情况">ping 测试网络情况&lt;/h1>
&lt;p>ping [OPTIONS] DESTINATION&lt;/p>
&lt;p>OPTIONS：&lt;/p>
&lt;ul>
&lt;li>-I &amp;lt;源 IP&amp;gt; # 以&amp;lt;&amp;gt;括号中指定的 IP 去 ping 目标 ip&lt;/li>
&lt;li>-s NUM # 指定每次 ping 包的大小，默认为 64Btye&lt;/li>
&lt;/ul>
&lt;h1 id="ping6">ping6&lt;/h1>
&lt;p>使用 ping6 时需要指定网络设备，否则会报 &lt;code>connect: Invalid argument&lt;/code> 错误。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">[&lt;/span>root@host-3 sysctl.d&lt;span style="color:#f92672">]&lt;/span>&lt;span style="color:#75715e"># ping6 fe80::2c75:df14:7422:36a&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>connect: Invalid argument
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">[&lt;/span>root@host-3 sysctl.d&lt;span style="color:#f92672">]&lt;/span>&lt;span style="color:#75715e"># ping6 -I br0 fe80::2c75:df14:7422:36a&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>PING fe80::2c75:df14:7422:36a&lt;span style="color:#f92672">(&lt;/span>fe80::2c75:df14:7422:36a&lt;span style="color:#f92672">)&lt;/span> from fe80::2c75:df14:7422:36a%br0 br0: &lt;span style="color:#ae81ff">56&lt;/span> data bytes
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">64&lt;/span> bytes from fe80::2c75:df14:7422:36a%br0: icmp_seq&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span> ttl&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">64&lt;/span> time&lt;span style="color:#f92672">=&lt;/span>0.050 ms
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>EXAMPLE&lt;/p>
&lt;ul>
&lt;li>ping6 -I br0 fe80::2c75:df14:7422:36a&lt;/li>
&lt;/ul>
&lt;h1 id="mtr">mtr&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/MTR_(software)">Wiki,MTR&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://github.com/traviscross/mtr">https://github.com/traviscross/mtr&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.bitwizard.nl/mtr/">https://www.bitwizard.nl/mtr/&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>&lt;strong>My Traceroute(简称 MTR)&lt;/strong> 原名是 **Matt&amp;rsquo;s traceroute，**是一个结合了 ping 与 traceroute 工具的网络诊断程序。MTR 通过限制单个数据包可能经过的跳数来探测路由路径上的路由器，并监听他们的到期响应。它将定期重复此过程，通常每秒一次，并跟踪路径上的跃点的响应时间。&lt;/p></description></item><item><title>Docs: 一个简易的http服务器，一条命令即可</title><link>https://desistdaydream.github.io/docs/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/X.Linux-%E7%AE%A1%E7%90%86/Linux-%E7%BD%91%E7%BB%9C%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/%E4%B8%80%E4%B8%AA%E7%AE%80%E6%98%93%E7%9A%84http%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%B8%80%E6%9D%A1%E5%91%BD%E4%BB%A4%E5%8D%B3%E5%8F%AF/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/X.Linux-%E7%AE%A1%E7%90%86/Linux-%E7%BD%91%E7%BB%9C%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/%E4%B8%80%E4%B8%AA%E7%AE%80%E6%98%93%E7%9A%84http%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%B8%80%E6%9D%A1%E5%91%BD%E4%BB%A4%E5%8D%B3%E5%8F%AF/</guid><description>
&lt;h1 id="heading">&lt;/h1>
&lt;pre>&lt;code># 使用该命令可以在当前目录搭建一个简易的http服务器，当client访问的时候，就可以直接看到该目录下的内容，还可以下载该目录下的内容
python -m SimpleHTTPServer NUM
&lt;/code>&lt;/pre>
&lt;p>若报错则使用如下命令：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>python3 -m http.server NUM
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div></description></item></channel></rss>