<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>断念梦 – 6.File System 管理</title><link>https://desistdaydream.github.io/docs/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2.Kernel%E5%86%85%E6%A0%B8/6.File_System_%E7%AE%A1%E7%90%86/</link><description>Recent content in 6.File System 管理 on 断念梦</description><generator>Hugo -- gohugo.io</generator><atom:link href="https://desistdaydream.github.io/docs/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2.Kernel%E5%86%85%E6%A0%B8/6.File_System_%E7%AE%A1%E7%90%86/index.xml" rel="self" type="application/rss+xml"/><item><title>Docs: 6.File System 管理</title><link>https://desistdaydream.github.io/docs/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2.Kernel%E5%86%85%E6%A0%B8/6.File_System_%E7%AE%A1%E7%90%86/6.File_System_%E7%AE%A1%E7%90%86/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2.Kernel%E5%86%85%E6%A0%B8/6.File_System_%E7%AE%A1%E7%90%86/6.File_System_%E7%AE%A1%E7%90%86/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Category:Computer_file_systems">Wiki-Category,Computer file systemd&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://time.geekbang.org/column/article/76876">Linux 性能优化实践-文件系统&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://mp.weixin.qq.com/s/qJdoXTv_XS_4ts9YuzMNIw">公众号，小林 coding-一口气搞懂「文件系统」，就靠这 25 张图了&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/op2fw9/1616167805545-2b948cff-7e56-4eb8-8c12-3851fd6c2e36.png" alt="">&lt;/p>
&lt;blockquote>
&lt;p>图片来源：&lt;a href="https://www.thomas-krenn.com/en/wiki/Linux_Storage_Stack_Diagram">https://www.thomas-krenn.com/en/wiki/Linux_Storage_Stack_Diagram&lt;/a>
从上面的结构可以看到，文件系统的作用就是用来接收用户的操作，并将数据保存到物理硬盘的。可以想见，如果没有文件系统帮助用户操作，那么人们又怎么能将数据保存到存储设备上呢~&lt;/p>
&lt;/blockquote>
&lt;p>&lt;strong>File System(文件系统，简称 FS)&lt;/strong> 是一种对存储设备上的数据，进行组织管理的机制。组织方式的不同，就会形成不同的文件系统。&lt;/p>
&lt;p>如果没有文件系统，放置在存储介质中的数据将是一个庞大的数据主体，无法分辨一个数据在哪里停止以及下一个数据在哪里开始。通过将数据分成多个部分并给每个部分命名，可以轻松地隔离和识别数据。每组数据称为 &lt;strong>File(文件)&lt;/strong>。所以，用于管理这些文件及其名称的&lt;strong>结构和逻辑规则&lt;/strong>，称为 &lt;strong>File System(文件系统)&lt;/strong>。&lt;/p>
&lt;h2 id="什么是-file文件">什么是 File(文件)&lt;/h2>
&lt;p>详见《&lt;a href="https://desistdaydream.github.io/docs/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2.Kernel(%E5%86%85%E6%A0%B8)/6.File_System_%E7%AE%A1%E7%90%86/%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86/%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86.md">文件管理&lt;/a>》章节&lt;/p>
&lt;h1 id="文件组织结构">文件组织结构&lt;/h1>
&lt;blockquote>
&lt;p>文件管理详解见&lt;a href="https://desistdaydream.github.io/docs/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2.Kernel(%E5%86%85%E6%A0%B8)/6.File_System_%E7%AE%A1%E7%90%86/%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86/%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86.md">单独章节&lt;/a>&lt;/p>
&lt;/blockquote>
&lt;p>为了方便管理，Linux 的文件系统为每个文件都分配了两个数据结构。&lt;/p>
&lt;ul>
&lt;li>&lt;strong>index node(索引节点，简称 inode)&lt;/strong> # 记录文件的元数据。inode 编号、文件大小、访问权限、修改日期、数据的位置等。
&lt;ul>
&lt;li>inode 和文件一一对应，它跟文件内容一样，都会被持久化到存储的磁盘中。所以&lt;strong>inode 同样占用磁盘空间&lt;/strong>。&lt;/li>
&lt;li>inode 包含文件的元数据，具体来说有以下内容：
&lt;ul>
&lt;li>文件的字节数&lt;/li>
&lt;li>文件拥有者的 User ID&lt;/li>
&lt;li>文件的 Group ID&lt;/li>
&lt;li>文件的读、写、执行权限&lt;/li>
&lt;li>文件的时间戳，共有三个：ctime 指 inode 上一次变动的时间，mtime 指文件内容上一次变动的时间，atime 指文件上一次打开的时间。&lt;/li>
&lt;li>链接数，即有多少文件名指向这个 inode&lt;/li>
&lt;li>文件数据 block 的位置&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>directory entry(目录项，简称 dentry)&lt;/strong> # 记录文件的名字、inode 指针、与其他目录项的关联关系。
&lt;ul>
&lt;li>多个关联的目录项，就构成了文件系统的目录结构(&lt;strong>一个层次化的树形结构&lt;/strong>)。不过，不同于 inode，目录项是由内核维护的一个内存数据结构，所以通常也被叫做 &lt;strong>dentries(目录项缓存)。&lt;/strong>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>这个层次化的树形结构就像下图一样：
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/op2fw9/1617088781476-3d7a9ccc-e8df-4680-acc5-26f4f82aa8b5.png" alt="image.png">
&lt;strong>注意：目录项缓存记录在 slab 中，当我们使用 find 命令时，slab 中的 dentry 缓存就会增大；打开文件过多，slab 中的 dentry 缓存也会增大。&lt;/strong>&lt;/p>
&lt;p>inode 是每个文件的唯一标志，而 dentry 维护的正是文件系统的树状结构。dentry 与 inode 的关系是多对一(可以简单理解为一个文件可以有多个别名)&lt;/p>
&lt;p>下面用一个形象点的白话来描述这些概念，假如现在系统中有如下目录结构&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>~&lt;span style="color:#f92672">]&lt;/span>&lt;span style="color:#75715e"># tree --inodes&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>.
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>├── &lt;span style="color:#f92672">[&lt;/span> 2218&lt;span style="color:#f92672">]&lt;/span> dir_1 &lt;span style="color:#75715e"># 这是目录类型的文件&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>│ ├── &lt;span style="color:#f92672">[&lt;/span> 2235&lt;span style="color:#f92672">]&lt;/span> file_1 &lt;span style="color:#75715e"># 这是普通类型的文件&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>│ └── &lt;span style="color:#f92672">[&lt;/span> 2236&lt;span style="color:#f92672">]&lt;/span> file_2
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>├── &lt;span style="color:#f92672">[&lt;/span>269167463&lt;span style="color:#f92672">]&lt;/span> dir_2
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>│ └── &lt;span style="color:#f92672">[&lt;/span>269167464&lt;span style="color:#f92672">]&lt;/span> file_3
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>└── &lt;span style="color:#f92672">[&lt;/span>537384536&lt;span style="color:#f92672">]&lt;/span> dir_3
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ├── &lt;span style="color:#f92672">[&lt;/span> 2235&lt;span style="color:#f92672">]&lt;/span> fie_1_ln
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> └── &lt;span style="color:#f92672">[&lt;/span>537384537&lt;span style="color:#f92672">]&lt;/span> file_4
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">3&lt;/span> directories, &lt;span style="color:#ae81ff">5&lt;/span> files
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>可以这么描述上述看到的内容：dir_1、file_1、dir_2 这些名称都是 dentry 中的文件名，&lt;code>[]&lt;/code> 中的数字是 inode 号，每个 dentry 都会与 inode 关联。其中 file_1 和 file_1_ln 的 inode 相同，但是 dentry 不同，这就对应了 dentry 与 inode 是多对一的关系。而哪些文件在哪个目录中，则是由每个文件的 dentry 中的关联关系来决定。比如 dir_1 目录中，包含了 file_1 和 file_2 文件。&lt;/p>
&lt;blockquote>
&lt;p>索引节点和目录项记录了文件的元数据，以及文件间的目录关系，那么具体来说，文件数据到底是怎么存储的呢？是不是直接写到磁盘中就好了呢？
实际上，磁盘读写的最小单位是扇区，然而扇区只有 512B 大小，如果每次都读写这么小的单位，效率一定很低。所以，文件系统又把连续的扇区组成了逻辑块，然后每次都以逻辑块为最小单元，来管理数据。常见的逻辑块大小为 4KB，也就是由连续的 8 个扇区组成。&lt;/p>
&lt;/blockquote>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/op2fw9/1616167805558-180916c2-cc19-40a0-b8f4-3ff805929883.png" alt="">&lt;/p>
&lt;p>注意：&lt;/p>
&lt;ul>
&lt;li>dentry 本身只是一个存储在内存中的缓存，而 inode 则是存储在磁盘中的数据。由于内存的 Buffer 和 Cache 原理，所以 inode 也会缓存到内存中，以便加速文件的访问。&lt;/li>
&lt;li>磁盘在执行文件系统格式化时，会被分成三个存储区域，超级快、索引节点区、数据区块
&lt;ul>
&lt;li>超级块 # 存储整个文件系统的状态&lt;/li>
&lt;li>索引节点区 # 存储 inode&lt;/li>
&lt;li>数据区块 # 存储文件数据&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>我们不可能把超级块和索引节点区全部加载到内存，这样内存肯定撑不住，所以只有当需要使用的时候，才将其加载进内存，它们加载进内存的时机是不同的：
&lt;ul>
&lt;li>超级块 # 当文件系统挂载时进入内存；&lt;/li>
&lt;li>索引节点区 # 当文件被访问时进入内存&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>dentry、inode、逻辑块以及超级块构成了 Linux 文件系统的四大基本要素。&lt;/p>
&lt;h2 id="小结">小结&lt;/h2>
&lt;p>通过上面的描述，文件在文件系统中，也就可以归纳为两个部分&lt;/p>
&lt;ul>
&lt;li>指针部分 # 指针位于文件系统的元数据中，在将数据删除后，这个指针就从元数据中清除了(元数据其实就是上文的 inode 与 dentry)。&lt;/li>
&lt;li>数据部分 # 文件的具体内容，存储在磁盘中。&lt;/li>
&lt;/ul>
&lt;p>平时我们在删除数据时，其实仅仅从元数据中删除了数据对应的指针。当指针被删除时，其原本占用的空间就可以被覆盖并写入新内容。&lt;/p>
&lt;h2 id="常见问题">常见问题&lt;/h2>
&lt;ul>
&lt;li>这也是为什么我们可以恢复数据的原因，只要旧数据还没被覆盖，就依然可以获取到。&lt;/li>
&lt;li>有时候在删除文件时，会发现并没有释放空间，也是同样的道理，当某个进程持续写入内容时，如果强制删除了文件，由于进程锁定文件对应的指针部分并不会从元数据中清除，而由于指针并未删除，系统内核就默认文件并未删除，因此查询文件系统空间时，显示空间并未释放。可以通过 lsof 命令筛选 deleted 查找这些有问题的文件。&lt;/li>
&lt;/ul>
&lt;h1 id="virtual-file-system虚拟文件系统">Virtual File System(虚拟文件系统)&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Virtual_file_system">Wiki,，Virtual file system&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://zhuanlan.zhihu.com/p/69289429">知乎&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://time.geekbang.org/column/article/76876">极客-Linux 性能优化实践&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>&lt;strong>Virtual File System(虚拟文件系统，简称 VFS)&lt;/strong> 是 Linux 为了支持多种多样的文件系统，在用户空间进程和文件系统中间，引入的一个抽象层。VFS 的目的是运行客户端应用程序以统一的方式访问不同类型的文件系统。VFS &lt;strong>定义了&lt;/strong>一组所有文件系统都支持的&lt;strong>数据结构和标准 API&lt;/strong>。这样，用户进程和内核中的其他子系统，只需要跟 VFS 提供的统一接口进行交互即可，而不需要关系底层各种文件系统的实现细节。&lt;/p>
&lt;blockquote>
&lt;p>比如不同文件系统的调用函数不一样，如果没有 VFS ，那么在使用的时候，就需要为特定的文件系统，编写不同的调用方式，非常繁琐复杂。&lt;/p>
&lt;p>比如 VFS 可以用来弥合 Windows、MacOS、Unix 文件系统中的差异，以便应用程序可以访问那些类型的本地文件系统上的文件，而不必知道它们正在访问哪种文件系统。&lt;/p>
&lt;/blockquote>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/op2fw9/1616167805621-09dbf293-4f9a-4892-8e30-8d33f32031c4.png" alt="">&lt;/p>
&lt;p>举个例子，Linux 用户程序可以通过&lt;code>read()&lt;/code> 来读取&lt;code>ext4&lt;/code>、&lt;code>NFS&lt;/code>、&lt;code>XFS&lt;/code>等文件系统的文件，也可以读取存储在&lt;code>SSD&lt;/code>、&lt;code>HDD&lt;/code>等不同存储介质的文件，无须考虑不同文件系统或者不同存储介质的差异。&lt;/p>
&lt;p>通过 VFS 系统，Linux 提供了通用的系统调用，可以跨越不同文件系统和介质之间执行，极大简化了用户访问不同文件系统的过程。另一方面，新的文件系统、新类型的存储介质，可以无须编译的情况下，动态加载到 Linux 中。&lt;/p>
&lt;p>&amp;ldquo;一切皆文件&amp;quot;是 Linux 的基本哲学之一，不仅是普通的文件，包括目录、字符设备、块设备、套接字等，都可以以文件的方式被对待。实现这一行为的基础，正是 Linux 的虚拟文件系统机制。&lt;/p>
&lt;p>VFS 之所以能够衔接各种各样的文件系统，是因为它抽象了一个通用的文件系统模型，定义了通用文件系统都支持的、概念上的接口。新的文件系统只要支持并实现这些接口，并注册到 Linux 内核中，即可安装和使用。&lt;/p>
&lt;p>再举个例子，比如 Linux 写一个文件：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>int ret &lt;span style="color:#f92672">=&lt;/span> write&lt;span style="color:#f92672">(&lt;/span>fd, buf, len&lt;span style="color:#f92672">)&lt;/span>;
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>调用了 &lt;code>write()&lt;/code> 系统调用，它的过程简要如下：&lt;/p>
&lt;ul>
&lt;li>首先，勾起 VFS 通用系统调用&lt;code>sys_write()&lt;/code>处理。&lt;/li>
&lt;li>接着，&lt;code>sys_write()&lt;/code> 根据&lt;code>fd&lt;/code>找到所在的文件系统提供的写操作函数，比如 &lt;code>op_write()&lt;/code>。&lt;/li>
&lt;li>最后，调用 &lt;code>op_write()&lt;/code> 实际的把数据写入到文件中。&lt;/li>
&lt;/ul>
&lt;p>操作示意图如下：
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/op2fw9/1616167805551-1b23e389-6142-4e11-8ef1-b1b1c1722cbe.jpeg" alt="">&lt;/p>
&lt;h1 id="文件系统类型">文件系统类型&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/File_system#Types_of_file_systems">Wiki，File system-Types_of_file_systems&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>可以通过 &lt;strong>/proc/filesystems&lt;/strong> 文件查看当前内核所支持的文件系统类型&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>~&lt;span style="color:#f92672">]&lt;/span>&lt;span style="color:#75715e"># cat /proc/filesystems&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>nodev sysfs
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>...
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>nodev proc
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>...
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>nodev cgroup2
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>nodev tmpfs
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>nodev devtmpfs
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>nodev configfs
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>...
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> xfs
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>...
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ext4
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>...
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ul>
&lt;li>第一列说明文件系统是否需要挂载在一个块设备上
&lt;ul>
&lt;li>nodev 表明本行的文件系统类型不需要挂接在块设备上。凡是没有 nodev 的类型，通常来说都是磁盘文件系统。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>第二列是内核支持的文件系统类型。&lt;/li>
&lt;/ul>
&lt;p>当系统中安装了某个文件系统的驱动，则该文件内容也会有增加，比如我安装了 nfs-utils 包，则该文件还会增加 nfs 行。&lt;/p>
&lt;h2 id="按照存储位置分类">按照存储位置分类&lt;/h2>
&lt;ul>
&lt;li>&lt;strong>Disk file systems(磁盘文件系统)&lt;/strong>
&lt;ul>
&lt;li>基于磁盘的文件系统，也就是把数据直接存储到计算机本地挂载磁盘中。常见的 &lt;strong>ext4、xfs&lt;/strong> 等，都是这类文件系统&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>Network File Systems(网络文件系统)&lt;/strong>
&lt;ul>
&lt;li>网络文件系统是充当远程文件访问协议的客户端的文件系统，提供对服务器上文件的访问。 使用本地接口的程序可以透明地创建，管理和访问远程网络连接计算机中的分层目录和文件。 网络文件系统的示例包括 NFS，AFS，SMB 协议的客户端，以及 FTP 和 WebDAV 的类似于文件系统的客户端。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>Distributed File System(分布式文件系统)&lt;/strong> # 使用网络协议的分布式文件系统也属于网络文件系统的一种。&lt;/li>
&lt;li>&lt;strong>Special-purpose File Systems(特殊目的文件系统)&lt;/strong> # 特殊的文件系统将操作系统的非文件元素显示为文件，以便可以使用文件系统 API 对其进行操作。 这种文件系统一般都是基于内存的，不需要任何磁盘为其分配存储空间，但会占用内存。
&lt;ul>
&lt;li>&lt;strong>device file system(设备文件系统)&lt;/strong> # 简称 devfs，设备文件系统将 I/O 设备和伪设备表示为文件，称为设备文件。 默认挂载到&lt;code>/dev&lt;/code>目录下。&lt;/li>
&lt;li>&lt;strong>Proc File System(进程文件系统)&lt;/strong> # 简称_ _procfs，将进程以及 Linux 上的其他操作系统结构映射到文件空间。默认挂载到&lt;code>/proc&lt;/code>目录下。&lt;/li>
&lt;li>&lt;strong>configfs&lt;/strong> 和 &lt;strong>sysfs&lt;/strong> 提供了可用于向内核查询信息并在内核中配置实体的文件。&lt;/li>
&lt;li>等等&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h1 id="文件系统的使用">文件系统的使用&lt;/h1>
&lt;blockquote>
&lt;p>和 DOS 等操作系统不同，Linux 操作系统中文件系统并不是由驱动器号或驱动器名称（如 A: 或 C: 等）来标识的。Linux 操作系统将独立的文件系统组合成了一个层次化的树形结构，并且由一个单独的实体代表这一文件系统。&lt;/p>
&lt;/blockquote>
&lt;p>Linux 将新的文件系统通过 &lt;a href="https://desistdaydream.github.io/docs/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2.Kernel(%E5%86%85%E6%A0%B8)/6.File_System_%E7%AE%A1%E7%90%86/Mount(%E6%8C%82%E8%BD%BD).md">&lt;strong>Mount(挂载)&lt;/strong>&lt;/a> 操作将其挂载到某个目录上，从而让不同的文件系统结合成为一个整体。&lt;/p>
&lt;p>这些文件系统，要先挂载到 VFS 目录树中的某个子目录（称为挂载点），然后才能访问其中的文件。拿第一类，也就是基于磁盘的文件系统为例，在安装系统时，要先挂载一个根目录&lt;code>/&lt;/code>，在根目录下再把其他文件系统（比如其他的磁盘分区、/proc 文件系统、/sys 文件系统、NFS 等）挂载进来。&lt;/p>
&lt;h1 id="文件系统-io">文件系统 I/O&lt;/h1>
&lt;p>把文件系统挂载到挂载点后，就可以通过挂载点访问它管理的文件了。 VFS 提供了一组标准的文件访问接口。这些接口以系统调用的方式，提供给应用程序使用。&lt;/p>
&lt;p>就比如 cat 命令，首先调用 &lt;code>openat()&lt;/code> 打开一个文件，然后调用 &lt;code>read()&lt;/code> 读取文件内容，最后调用 &lt;code>write()&lt;/code> 将内容输出到控制台的标准输出中&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>~&lt;span style="color:#f92672">]&lt;/span>&lt;span style="color:#75715e"># strace -e openat,read,write cat /root/test&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>......
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>openat&lt;span style="color:#f92672">(&lt;/span>AT_FDCWD, &lt;span style="color:#e6db74">&amp;#34;/root/test&amp;#34;&lt;/span>, O_RDONLY&lt;span style="color:#f92672">)&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">3&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>read&lt;span style="color:#f92672">(&lt;/span>3, &lt;span style="color:#e6db74">&amp;#34;Test I/O for File System&amp;#34;&lt;/span>, 131072&lt;span style="color:#f92672">)&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">24&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>write&lt;span style="color:#f92672">(&lt;/span>1, &lt;span style="color:#e6db74">&amp;#34;Test I/O for File System&amp;#34;&lt;/span>, 24Test I/O &lt;span style="color:#66d9ef">for&lt;/span> File System&lt;span style="color:#f92672">)&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">24&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>......
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># 代码中的方法如下：open() 与 openat() 这两个调用效果一样。&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>int open&lt;span style="color:#f92672">(&lt;/span>const char *pathname, int flags, mode_t mode&lt;span style="color:#f92672">)&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>ssize_t read&lt;span style="color:#f92672">(&lt;/span>int fd, void *buf, size_t count&lt;span style="color:#f92672">)&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>ssize_t write&lt;span style="color:#f92672">(&lt;/span>int fd, const void *buf, size_t count&lt;span style="color:#f92672">)&lt;/span>;
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>文件读写方式的各种差异，导致 I/O 的分类多种多样。最常见的有，缓冲与非缓冲 I/O、直接与非直接 I/O、阻塞与非阻塞 I/O、同步与异步 I/O 等。&lt;/p>
&lt;h2 id="缓冲与非缓冲-io">缓冲与非缓冲 I/O&lt;/h2>
&lt;p>根据是否利用标准库缓存&lt;/p>
&lt;ul>
&lt;li>缓冲 I/O # 利用标准库缓存来加速文件的访问，而标准库内部再通过系统调用访问文件&lt;/li>
&lt;li>非缓冲 I/O # 直接通过系统调用来访问文件，不再经过标准库缓存。&lt;/li>
&lt;/ul>
&lt;p>注意，这里所说的“缓冲”，是指标准库内部实现的缓存。比方说，你可能见到过，很多程序遇到换行时才真正输出，而换行前的内容，其实就是被标准库暂时缓存了起来。
无论缓冲 I/O 还是非缓冲 I/O，它们最终还是要经过系统调用来访问文件。而根据上一节内容，我们知道，系统调用后，还会通过页缓存，来减少磁盘的 I/O 操作。&lt;/p>
&lt;h2 id="直接与非直接-io">直接与非直接 I/O&lt;/h2>
&lt;p>根据是否利用操作系统的页缓存&lt;/p>
&lt;ol>
&lt;li>直接 I/O，是指跳过操作系统的页缓存，直接跟文件系统交互来访问文件。&lt;/li>
&lt;li>非直接 I/O 正好相反，文件读写时，先要经过系统的页缓存，然后再由内核或额外的系统调用，真正写入磁盘。&lt;/li>
&lt;/ol>
&lt;p>想要实现直接 I/O，需要你在系统调用中，指定 O_DIRECT 标志。如果没有设置过，默认的是非直接 I/O。
不过要注意，直接 I/O、非直接 I/O，本质上还是和文件系统交互。如果是在数据库等场景中，你还会看到，跳过文件系统读写磁盘的情况，也就是我们通常所说的裸 I/O。&lt;/p>
&lt;h2 id="阻塞与非阻塞-io">阻塞与非阻塞 I/O&lt;/h2>
&lt;p>根据应用程序是否阻塞自身运行&lt;/p>
&lt;ol>
&lt;li>所谓阻塞 I/O，是指应用程序执行 I/O 操作后，如果没有获得响应，就会阻塞当前线程，自然就不能执行其他任务。&lt;/li>
&lt;li>所谓非阻塞 I/O，是指应用程序执行 I/O 操作后，不会阻塞当前的线程，可以继续执行其他的任务，随后再通过轮询或者事件通知的形式，获取调用的结果。&lt;/li>
&lt;/ol>
&lt;p>比方说，访问管道或者网络套接字时，设置 O_NONBLOCK 标志，就表示用非阻塞方式访问；而如果不做任何设置，默认的就是阻塞访问。&lt;/p>
&lt;h2 id="同步与异步-io">同步与异步 I/O&lt;/h2>
&lt;p>根据是否等待响应结果&lt;/p>
&lt;ol>
&lt;li>所谓同步 I/O，是指应用程序执行 I/O 操作后，要一直等到整个 I/O 完成后，才能获得 I/O 响应。&lt;/li>
&lt;li>所谓异步 I/O，是指应用程序执行 I/O 操作后，不用等待完成和完成后的响应，而是继续执行就可以。等到这次 I/O 完成后，响应会用事件通知的方式，告诉应用程序。&lt;/li>
&lt;/ol>
&lt;p>举个例子，在操作文件时，如果你设置了 O_SYNC 或者 O_DSYNC 标志，就代表同步 I/O。如果设置了 O_DSYNC，就要等文件数据写入磁盘后，才能返回；而 O_SYNC，则是在 O_DSYNC 基础上，要求文件元数据也要写入磁盘后，才能返回。
再比如，在访问管道或者网络套接字时，设置了 O_ASYNC 选项后，相应的 I/O 就是异步 I/O。这样，内核会再通过 SIGIO 或者 SIGPOLL，来通知进程文件是否可读写。
你可能发现了，这里的好多概念也经常出现在网络编程中。比如非阻塞 I/O，通常会跟 select/poll 配合，用在网络套接字的 I/O 中。
你也应该可以理解，“Linux 一切皆文件”的深刻含义。无论是普通文件和块设备、还是网络套接字和管道等，它们都通过统一的 VFS 接口来访问。&lt;/p>
&lt;h2 id="总结">总结&lt;/h2>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/op2fw9/1616167677139-656d34bf-0195-4576-919f-2eedc4f4ba5a.png" alt="">
在前面我们知道了，I/O 是分为两个过程的：&lt;/p>
&lt;ol>
&lt;li>数据准备的过程&lt;/li>
&lt;li>数据从内核空间拷贝到用户进程缓冲区的过程&lt;/li>
&lt;/ol>
&lt;p>阻塞 I/O 会阻塞在「过程 1 」和「过程 2」，而非阻塞 I/O 和基于非阻塞 I/O 的多路复用只会阻塞在「过程 2」，所以这三个都可以认为是同步 I/O。
异步 I/O 则不同，「过程 1 」和「过程 2 」都不会阻塞。&lt;/p>
&lt;h2 id="用故事去理解这几种-io-模型">用故事去理解这几种 I/O 模型&lt;/h2>
&lt;p>举个你去饭堂吃饭的例子，你好比用户程序，饭堂好比操作系统。&lt;/p>
&lt;p>阻塞 I/O 好比，你去饭堂吃饭，但是饭堂的菜还没做好，然后你就一直在那里等啊等，等了好长一段时间终于等到饭堂阿姨把菜端了出来（数据准备的过程），但是你还得继续等阿姨把菜（内核空间）打到你的饭盒里（用户空间），经历完这两个过程，你才可以离开。&lt;/p>
&lt;p>非阻塞 I/O 好比，你去了饭堂，问阿姨菜做好了没有，阿姨告诉你没，你就离开了，过几十分钟，你又来饭堂问阿姨，阿姨说做好了，于是阿姨帮你把菜打到你的饭盒里，这个过程你是得等待的。&lt;/p>
&lt;p>基于非阻塞的 I/O 多路复用好比，你去饭堂吃饭，发现有一排窗口，饭堂阿姨告诉你这些窗口都还没做好菜，等做好了再通知你，于是等啊等（&lt;code>select&lt;/code> 调用中），过了一会阿姨通知你菜做好了，但是不知道哪个窗口的菜做好了，你自己看吧。于是你只能一个一个窗口去确认，后面发现 5 号窗口菜做好了，于是你让 5 号窗口的阿姨帮你打菜到饭盒里，这个打菜的过程你是要等待的，虽然时间不长。打完菜后，你自然就可以离开了。&lt;/p>
&lt;p>异步 I/O 好比，你让饭堂阿姨将菜做好并把菜打到饭盒里后，把饭盒送到你面前，整个过程你都不需要任何等待。&lt;/p></description></item><item><title>Docs: Mount(挂载)</title><link>https://desistdaydream.github.io/docs/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2.Kernel%E5%86%85%E6%A0%B8/6.File_System_%E7%AE%A1%E7%90%86/Mount%E6%8C%82%E8%BD%BD/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2.Kernel%E5%86%85%E6%A0%B8/6.File_System_%E7%AE%A1%E7%90%86/Mount%E6%8C%82%E8%BD%BD/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://man7.org/linux/man-pages/man5/fstab.5.html">Manual(手册),fstab(5)&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://man7.org/linux/man-pages/man8/mount.8.html">Manual(手册),mount(8)&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>注意：&lt;/p>
&lt;p>mount 命令无法列出 bind 类型的挂载(比如 Docker 和 Containerd 的 bind 类型挂载，不知道如何列出)。&lt;/p>
&lt;p>不过 findmnt 命令可以列出使用 &lt;code>mount --bind XX XX&lt;/code> 挂载的目录，效果如下&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>~&lt;span style="color:#f92672">]&lt;/span>&lt;span style="color:#75715e"># findmnt&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>TARGET SOURCE FSTYPE OPTIONS
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>/ /dev/vda3 ext4 rw,relatime
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>......
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>└─/mnt/cdrom /dev/vda3&lt;span style="color:#f92672">[&lt;/span>/root/downloads/webvirtcloud&lt;span style="color:#f92672">]&lt;/span> ext4 rw,relatime
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h1 id="关联文件与配置">关联文件与配置&lt;/h1>
&lt;p>/etc/fstab # 包含各种 file systems 的描述性信息。系统启动时，根据该文件配置挂载分区到指定路径。&lt;/p>
&lt;p>/etc/mtab # 是一个软连接，连接到 /proc/self/mounts&lt;/p>
&lt;p>XXX.mount # 以 .mount 为后缀的 unit 文件，是由 systemd 管理的文件系统描述信息。systemd 将根据这些 unit 文件，将指定的文件系统挂载到系统中。&lt;/p>
&lt;h2 id="fstab-文件详解">fstab 文件详解&lt;/h2>
&lt;p>&lt;strong>File System Table(文件系统表，简称 fstab)&lt;/strong> 是一个关于文件系统的静态信息文件。默认路径为 &lt;strong>/etc/fstab&lt;/strong>&lt;/p>
&lt;p>fstab 包含操作系统中可以挂载的文件系统的描述性信息。每个描述信息占用单独一行，每行的各个字段由制表符或空格分隔。fsck、mount、umount 命令在执行某些操作时将会顺序读取该文件的每一行。&lt;/p>
&lt;p>下面是一个 fstab 文件中关于文件系统描述的典型示例(一共具有 6 个字段)：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>LABEL&lt;span style="color:#f92672">=&lt;/span>t-home2 /home ext4 defaults,auto_da_alloc &lt;span style="color:#ae81ff">0&lt;/span> &lt;span style="color:#ae81ff">2&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ul>
&lt;li>fs_spec # 要挂载的分区或存储设备&lt;/li>
&lt;li>fs_file # 挂载的位置&lt;/li>
&lt;li>fs_vfstype # 文件系统的类型&lt;/li>
&lt;li>fs_mntopts # 与文件系统关联的挂载选项&lt;/li>
&lt;li>fs_freq # 确定需要转储哪些文件系统&lt;/li>
&lt;li>fs_passno # 确定引导时执行文件系统检查的顺序。&lt;/li>
&lt;/ul>
&lt;p>下面各字段的名称中 fs 就是 file system 的简称。&lt;/p>
&lt;h3 id="fs_spec">fs_spec&lt;/h3>
&lt;p>该字段用于指定该文件系统所用存储设备是什么，可以是块设备、远程文件系统、文件系统镜像、交换分区 等等。&lt;/p>
&lt;p>对于普通的挂载，它将为要挂载的设备保存（链接到）块专用设备节点（由 mknod（2）创建），例如“ /dev/cdrom”或“ /dev/sdb7”。 对于 NFS 挂载，此字段为：，例如`knuth.aeb.nl:/&amp;rsquo;。 对于没有存储空间的文件系统，可以使用任何字符串，例如，这些字符串将显示在 df（1）输出中。 procfs 的典型用法是“ proc”； tmpfs 的“ mem”，“ none”或“ tmpfs”。 其他特殊文件系统（例如 udev 和 sysfs）通常不在 fstab 中列出。&lt;/p>
&lt;p>可以给出 LABEL = &amp;lt;标签&amp;gt;或 UUID = 代替设备名称。这是推荐的方法，因为设备名称通常是硬件检测顺序的重合，并且在添加或删除其他磁盘时可能会更改。例如，“ LABEL = Boot”或“ UUID = 3e6be9de-8139-11d1-9106-a43f08d823a6”。 （使用特定于文件系统的工具，例如 e2label（8），xfs_admin（8）或 fatlabel（8）在文件系统上设置 LABEL）。&lt;/p>
&lt;h3 id="fs_file">fs_file&lt;/h3>
&lt;p>该字段描述文件系统的挂载点（目标）。 使用 绝对路径 来描述一个挂载点.&lt;/p>
&lt;h3 id="fs_vfstype">fs_vfstype&lt;/h3>
&lt;p>要挂载设备或是分区的文件系统类型，支持许多种不同的文件系统：ext2, ext3, ext4, reiserfs, xfs, jfs, smbfs, iso9660, vfat, ntfs, swap 及 auto。 设置成 auto 类型，mount 命令会猜测使用的文件系统类型，对 CDROM 和 DVD 等移动设备是非常有用的。&lt;/p>
&lt;h3 id="fs_mntopts">fs_mntopts&lt;/h3>
&lt;p>详见下文 mount 命令中关于挂载选项的详解 &lt;a href="#Mount%20OPTIONS(%E6%8C%82%E8%BD%BD%E9%80%89%E9%A1%B9)">Mount OPTIONS&lt;/a>&lt;/p>
&lt;h3 id="fs_freq">fs_freq&lt;/h3>
&lt;p>dump 工具通过该字段的值决定何时作备份。 允许的数字是 0 和 1 。&lt;/p>
&lt;ul>
&lt;li>0 # (默认值)表示忽略&lt;/li>
&lt;li>1 # 表示进行备份。&lt;/li>
&lt;/ul>
&lt;p>大部分的用户是没有安装 dump 的 ，对这些用户而言该字段值应设为 0。&lt;/p>
&lt;h3 id="fs_passno">fs_passno&lt;/h3>
&lt;p>fsck 工具读取该字段的值来决定需要检查的文件系统的检查顺序。允许的数字是 0, 1, 和 2。&lt;/p>
&lt;ul>
&lt;li>0 # 表示设备不会被 fsck 所检查&lt;/li>
&lt;li>1 # 根目录应当获得最高的优先权 1,&lt;/li>
&lt;li>2 # 其它所有需要被检查的设备设置为 2.&lt;/li>
&lt;/ul>
&lt;h1 id="mount-工具">mount 工具&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://man7.org/linux/man-pages/man8/mount.8.html">Manual(手册)，mount(8)&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>mount/umount 文件系统挂载/卸载工具&lt;/p>
&lt;h2 id="syntax语法">Syntax(语法)&lt;/h2>
&lt;p>&lt;strong>mount [-l] [-t fstype]&lt;/strong>
&lt;strong>mount -a [-fFnrsvw] [-t fstype] [-O optlist]&lt;/strong>
&lt;strong>mount [-fnrsvw] [-o options] &amp;lt;DEVICE | MountPoint&amp;gt;&lt;/strong> # 从 /etc/fstab 文件读取 Device 或 MountPoint 的信息后执行对应的挂载操作
&lt;strong>mount [-fnrsvw] [-t fstype] [-o options] DEVICE MountPoint&lt;/strong> # 将 DEVICE 设备挂载到 MountPoint 上&lt;/p>
&lt;ul>
&lt;li>MountPoint 通常是一个绝对路径，/PATH/DIR，即将 DEVICE 设备挂载在 PATH 路径下的 DIR 目录上&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>mount &amp;ndash;bind|&amp;ndash;rbind|&amp;ndash;move &amp;lt;OldDIR&amp;gt; &amp;lt;NewDIR&amp;gt;&lt;/strong> # 执行 bind 挂载，将 OldDIR 目录挂载到 NewDIR 目录上
&lt;strong>mount &amp;ndash;make-[shared|slave|private|unbindable|rshared|rslave|rprivate|runbindable] MountPoint&lt;/strong>&lt;/p>
&lt;p>OPTIONS&lt;/p>
&lt;ul>
&lt;li>&lt;strong>-o, &amp;ndash;options &amp;lt;OPTS&amp;gt;&lt;/strong> # 使用指定选项挂载，OPTS 是一个逗号分割的列表，可以从下面的 &lt;a href="#Mount%20OPTIONS(%E6%8C%82%E8%BD%BD%E9%80%89%E9%A1%B9)">Mount OPTIONS&lt;/a> 中查看所有可用的选项。&lt;/li>
&lt;li>&lt;strong>-r, &amp;ndash;read-only&lt;/strong> # 以只读方式挂载。可以被 &lt;code>-o ro&lt;/code> 选项替代&lt;/li>
&lt;li>&lt;strong>-t &amp;lt;STRING&amp;gt;&lt;/strong> # 指明文件系统的类型。当前内核支持的文件系统类型可以从 /proc/filesystems 或 /lib/modules/$(uname -r)/kernel/fs 文件中获取&lt;/li>
&lt;li>&lt;strong>&amp;ndash;bind|&amp;ndash;rbind|&amp;ndash;move&lt;/strong> # 进行 bind 模式挂载&lt;/li>
&lt;/ul>
&lt;h3 id="mount-options挂载选项">Mount OPTIONS(挂载选项)&lt;/h3>
&lt;p>&lt;a href="https://man7.org/linux/man-pages/man8/mount.8.html#FILESYSTEM-INDEPENDENT_MOUNT_OPTIONS">FileSystem-Independent Mount Options(适用于所有文件系统的选项)&lt;/a>&lt;/p>
&lt;ul>
&lt;li>&lt;strong>async&lt;/strong> # I/O 异步进行。&lt;/li>
&lt;li>&lt;strong>auto&lt;/strong> # 在启动时或键入了 mount -a 命令时自动挂载。&lt;/li>
&lt;li>&lt;strong>defaults&lt;/strong> # 使用文件系统的默认挂载参数，例如 ext4 的默认参数为:rw, suid, dev, exec, auto, nouser, async.&lt;/li>
&lt;li>&lt;strong>dev&lt;/strong> # 解析文件系统上的块特殊设备。&lt;/li>
&lt;li>&lt;strong>exec&lt;/strong> # 允许执行此分区的二进制文件。&lt;/li>
&lt;li>&lt;strong>flush&lt;/strong> # vfat 的选项，更频繁的刷新数据，复制对话框或进度条在全部数据都写入后才消失。&lt;/li>
&lt;li>&lt;strong>noatime&lt;/strong> # 不更新文件系统上 inode 访问记录。&lt;strong>可以提升性能&lt;/strong>。&lt;/li>
&lt;li>&lt;strong>noauto&lt;/strong> # 只在你的命令下被挂载。&lt;/li>
&lt;li>&lt;strong>nodev&lt;/strong> # 不解析文件系统上的块特殊设备。&lt;/li>
&lt;li>&lt;strong>nodiratime&lt;/strong> # 不更新文件系统上的目录 inode 访问记录，可以提升性能(参见 atime 参数)。&lt;/li>
&lt;li>&lt;strong>noexec&lt;/strong> # 不允许执行此文件系统上的二进制文件。&lt;/li>
&lt;li>&lt;strong>nosuid&lt;/strong> # 禁止 suid 操作和设定 sgid 位。&lt;/li>
&lt;li>&lt;strong>nouser&lt;/strong> # 只能被 root 挂载。&lt;/li>
&lt;li>&lt;strong>owner&lt;/strong> # 允许设备所有者挂载.&lt;/li>
&lt;li>&lt;strong>relatime&lt;/strong> # 实时更新 inode access 记录。只有在记录中的访问时间早于当前访问才会被更新。（与 noatime 相似，但不会打断如 mutt 或其它程序探测文件在上次访问后是否被修改的进程。），可以提升性能(参见 atime 参数)。&lt;/li>
&lt;li>&lt;strong>ro&lt;/strong> # 以只读模式挂载文件系统&lt;/li>
&lt;li>&lt;strong>rw&lt;/strong> # 以读写模式挂载文件系统&lt;/li>
&lt;li>&lt;strong>suid&lt;/strong> # 允许 suid 操作和设定 sgid 位。这一参数通常用于一些特殊任务，使一般用户运行程序时临时提升权限。&lt;/li>
&lt;li>&lt;strong>sync&lt;/strong> # I/O 同步进行。&lt;/li>
&lt;li>&lt;strong>user&lt;/strong> # 允许任意用户挂载此文件系统，若无显示定义，隐含启用 noexec, nosuid, nodev 参数。&lt;/li>
&lt;li>&lt;strong>users&lt;/strong> # 允许所有 users 组中的用户挂载文件系统.&lt;/li>
&lt;/ul>
&lt;p>&lt;a href="https://man7.org/linux/man-pages/man8/mount.8.html#FILESYSTEM-SPECIFIC_MOUNT_OPTIONS">FileSystem-Specific Mount Options(只适用于特定文件系统的选项)&lt;/a>&lt;/p>
&lt;h2 id="example">EXAMPLE&lt;/h2>
&lt;ul>
&lt;li>mount -a # 会将 /etc/fstab 中定义的所有挂载点都挂上(一般是在系统启动时的脚本中调用，自己最好别用！)。&lt;/li>
&lt;li>mount /dev/sdb1 /mnt # /把/dev/sdb1 分区挂载到/mnt 目录&lt;/li>
&lt;li>mount &amp;ndash;bind /root/tmp_one /root/tmp_two # 将 /root/tmp_one 目录挂载到 /root/tmp_two 目录下。&lt;/li>
&lt;/ul>
&lt;p>mount [-t ] # 查看当前系统下的挂载信息[查看指定的类型]&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/hla4gc/1616167790128-b08b713d-147f-4c61-8289-47133e8124cf.jpeg" alt="">&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/hla4gc/1616167790134-5f30f99c-3a70-44b7-b9c4-6c1cc3f9429f.jpeg" alt="">&lt;/p>
&lt;p>各段落含义与 fstab 文件相同&lt;/p>
&lt;h1 id="umount-工具">umount 工具&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://man7.org/linux/man-pages/man8/umount.8.html">Manual(手册)，umount(8)&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;h2 id="syntax语法-1">Syntax(语法)&lt;/h2>
&lt;p>&lt;strong>OPTIONS&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>&lt;strong>-f, &amp;ndash;force&lt;/strong> # 强制卸载（在无法访问 NFS 系统的情况下）。&lt;/li>
&lt;li>&lt;strong>-l, &amp;ndash;lazy&lt;/strong> # 延迟卸载。现在从文件层次结构中分离文件系统，并在它不再忙时立即清除对该文件系统的所有引用。&lt;/li>
&lt;/ul>
&lt;h1 id="systemd-管理-mount">systemd 管理 mount&lt;/h1>
&lt;p>详见 &lt;a href="https://desistdaydream.github.io/docs/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/3.Systemd%20%E7%B3%BB%E7%BB%9F%E5%AE%88%E6%8A%A4%E7%A8%8B%E5%BA%8F/Unit%20File/mount%20Unit.md">mount Unit&lt;/a>&lt;/p></description></item><item><title>Docs: FHS(文件系统层次标准)</title><link>https://desistdaydream.github.io/docs/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2.Kernel%E5%86%85%E6%A0%B8/6.File_System_%E7%AE%A1%E7%90%86/FHS%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%B1%82%E6%AC%A1%E6%A0%87%E5%87%86/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2.Kernel%E5%86%85%E6%A0%B8/6.File_System_%E7%AE%A1%E7%90%86/FHS%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%B1%82%E6%AC%A1%E6%A0%87%E5%87%86/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://refspecs.linuxfoundation.org/fhs.shtml">Linux 基金会参考标准,文件系统层次标准&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Filesystem_Hierarchy_Standard">Wiki,FHS&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>&lt;strong>Filesystem Hierarchy Standard(文件系统层次标准，简称 FHS)&lt;/strong> 为文件系统的每个区域指定指导原则，指定所需的最少文件和目录&lt;/p>
&lt;p>该标准使：&lt;/p>
&lt;ul>
&lt;li>用于预测已安装文件和目录位置的软件&lt;/li>
&lt;li>用户预测已安装文件和目录的位置。&lt;/li>
&lt;/ul>
&lt;p>我们这样做：&lt;/p>
&lt;ul>
&lt;li>为文件系统的每个区域指定指导原则，&lt;/li>
&lt;li>指定所需的最少文件和目录，&lt;/li>
&lt;li>列举原则的例外情况，以及&lt;/li>
&lt;li>列举发生历史冲突的具体案例。&lt;/li>
&lt;/ul>
&lt;p>FHS 文件用于：&lt;/p>
&lt;ul>
&lt;li>独立软件供应商创建符合 FHS 的应用程序，并与符合 FHS 的发行版合作，&lt;/li>
&lt;li>操作系统创建者提供符合 FHS 的系统，以及&lt;/li>
&lt;li>用户了解并维护系统的 FHS 合规性。&lt;/li>
&lt;/ul>
&lt;p>FHS 文件的范围有限：&lt;/p>
&lt;ul>
&lt;li>本地文件的本地放置是本地问题，因此 FHS 不会试图篡夺系统管理员。&lt;/li>
&lt;li>FHS 解决了需要在多方（例如本地站点、发行版、应用程序、文档等）之间协调文件放置的问题。&lt;/li>
&lt;/ul>
&lt;h2 id="unix-目录结构的来历">Unix 目录结构的来历&lt;/h2>
&lt;p>Unix（包含 Linux）的初学者，常常会很困惑，不明白目录结构的含义何在。
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/cbem3o/1616167692312-d409e171-1b36-486c-8ab8-369fb7496328.jpeg" alt="">
举例来说，根目录下面有一个子目录 /bin，用于存放二进制程序。但是，/usr 子目录下面还有 /usr/bin，以及 /usr/local/bin，也用于存放二进制程序；某些系统甚至还有 /opt/bin。它们有何区别？&lt;/p>
&lt;p>长久以来，我也感到很费解，不明白为什么这样设计。像大多数人一样，我只是根据《Unix 文件系统结构标准》（Filesystem Hierarchy Standard），死记硬背不同目录的区别。&lt;/p>
&lt;p>昨天，我读到了 Rob Landley 的，这才恍然大悟，原来 Unix 目录结构是历史造成的。&lt;/p>
&lt;p>话说 1969 年，Ken Thompson 和 Dennis Ritchie 在小型机 PDP-7 上发明了 Unix。1971 年，他们将主机升级到了 PDP-11。&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/cbem3o/1616167692315-3e0daae3-bc42-43c2-bdcc-daaf010e60a0.jpeg" alt="">&lt;/p>
&lt;p>当时，他们使用一种叫做 RK05 的储存盘，一盘的容量大约是 1.5MB。&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/cbem3o/1616167692330-7be3ddfe-c384-4e49-a7a7-6607e438f03d.jpeg" alt="">&lt;/p>
&lt;p>没过多久，操作系统（根目录）变得越来越大，一块盘已经装不下了。于是，他们加上了第二盘 RK05，并且规定第一块盘专门放系统程序，第二块盘专门放用户自己的程序，因此挂载的目录点取名为/usr。也就是说，根目录&amp;quot;/&amp;ldquo;挂载在第一块盘，&amp;quot;/usr&amp;quot;目录挂载在第二块盘。除此之外，两块盘的目录结构完全相同，第一块盘的目录（/bin, /sbin, /lib, /tmp&amp;hellip;）都在/usr 目录下重新出现一次。&lt;/p>
&lt;p>后来，第二块盘也满了，他们只好又加了第三盘 RK05，挂载的目录点取名为/home，并且规定/usr 用于存放用户的程序，/home 用于存放用户的数据。&lt;/p>
&lt;p>从此，这种目录结构就延续了下来。随着硬盘容量越来越大，各个目录的含义进一步得到明确。&lt;/p>
&lt;h1 id="目录结构概览">目录结构概览&lt;/h1>
&lt;h2 id="---第一层次结构的根整个文件系统层次结构的根目录">/ - 第一层次结构的根、整个文件系统层次结构的根目录&lt;/h2>
&lt;p>通常情况下，根文件系统所占空间一般应该比较小，因为其中的绝大部分文件都不需要经常改动，而且包括严格的文件和一个小的 不经常改变的文件系统不容易损坏。除了可能的一个叫/vmlinuz 标准的系统引导映像之外，根目录一般不含任何文 件。所有其他文件在根文件系统的子目录中。&lt;/p>
&lt;h2 id="boot---内核-及-引导文件的目录">/boot - 内核 及 引导文件的目录&lt;/h2>
&lt;p>包括内核和其它系统启动期间使用的文件。是启动 linux 时使用的核心文件。Linux kernel 常用的档名为：vmlinuz ，如果使用的是 grub 这个开机管理程式，则还会存在/boot/grub/这个目录。&lt;/p>
&lt;p>/boot 目录存放引导加载器(bootstrap loader)使用的文件，如 lilo，核心映像也经常放在这里，而不是放在根目录中。但是如果有许多核心映像，这个目录就可能变得很大，这时使用单独的 文件系统会更好一些。还有一点要注意的是，要确保核心映像必须在 ide 硬盘的前 1024 柱面内&lt;/p>
&lt;h2 id="dev---存放设备文件的目录">/dev - 存放设备文件的目录&lt;/h2>
&lt;p>这些包括终端设备、USB 或连接到系统的任何设备。例如：/dev/tty1、/dev/usbmon0&lt;/p>
&lt;p>/dev 目录存放了设备文件，即设备驱动程序，用户通过这些文件访问外部设备。比如，用户可 以通过访问/dev/mouse 来访问鼠标的输入，就像访问其他文件一样。&lt;/p>
&lt;ul>
&lt;li>/dev/console：系统控制台，也就是直接和系统连接的监视器。&lt;/li>
&lt;li>/dev/hd：ide 硬盘驱动程序接口。如：/dev/hda 指的是第一个硬 盘，had1 则是指/dev/hda 的第一个分区。如系统中有其他的硬盘，则依次为/dev/hdb、/dev/hdc、. . . . . .；如有多个分区则依次为 hda1、hda2 . . . . . .&lt;/li>
&lt;li>/dev/sd：scsi 磁盘驱动程序接口。如系统有 scsi 硬盘，就不会访问/dev/had， 而会访问/dev/sda。&lt;/li>
&lt;li>/dev/fd：软驱设备驱动程序。如：/dev/fd0 指 系统的第一个软盘，也就是通常所说的 a 盘，/dev/fd1 指第二个软盘，. . . . . .而/dev/fd1 h1440 则表示访问驱动器 1 中的 4.5 高密盘。&lt;/li>
&lt;li>/dev/st：scsi 磁带驱动器驱动程序。&lt;/li>
&lt;li>/dev/tty：提供虚拟控制台支持。如：/dev/tty1 指 的是系统的第一个虚拟控制台，/dev/tty2 则是系统的第二个虚拟控制台。&lt;/li>
&lt;li>/dev/pty：提供远程登陆伪终端支持。在进行 telnet 登录时就要用到/dev/pty 设 备。&lt;/li>
&lt;li>/dev/ttys：计算机串行接口，对于 dos 来说就是“com1”口。&lt;/li>
&lt;li>/dev/cua：计算机串行接口，与调制解调器一起使用的设备。&lt;/li>
&lt;li>/dev/null：“黑洞”，所有写入该设备的信息都将消失。例如：当想要将屏幕 上的输出信息隐藏起来时，只要将输出信息输入到/dev/null 中即可。&lt;/li>
&lt;li>/dev/randow 与/dev/unrandom # 随机数生成器。random 仅从熵池返回随机数，随机数用尽，阻塞。urandom 从熵池返回随机数，随机数用尽会利用软件生成伪随机数，非阻塞。&lt;/li>
&lt;/ul>
&lt;h2 id="etc---存放配置文件">/etc - 存放配置文件&lt;/h2>
&lt;p>包含所有程序所需的配置文件。也包含了用于启动/停止单个程序的启动和关闭 shell 脚本。&lt;/p>
&lt;p>/etc 目录存放着各种系统配置文件，其中包括了用户信息文件 /etc/passwd， 系统初始化文件 /etc/rc 等。linux 正是靠这些文件才得以正常地运行。&lt;/p>
&lt;ul>
&lt;li>/etc/rc 或 /etc/rc.d 或 /etc/rc?.d # 启动、或改变运行级时运 行的脚本或脚本的目录。&lt;/li>
&lt;li>/etc/passwd：用户数据库，其中的域给出了用户名、真实姓名、用户起始目 录、加密口令和用户的其他信息。&lt;/li>
&lt;li>/etc/fstab：指定启动时需要自动安装的文件系统列表。也包括用 swapon -a 启用的 swap 区的信息。&lt;/li>
&lt;li>/etc/group：类似/etc/passwd ，但说明的不是用户信息而是组的信息。包括组的各种数据。&lt;/li>
&lt;li>/etc/issue：包括用户在登录提示符前的输出信息。通常包括系统的一段短说明 或欢迎信息。具体内容由系统管理员确定。&lt;/li>
&lt;li>/etc/magic：“file”的配置文件。包含不同文件格式的说 明，“file”基于它猜测文件类型。&lt;/li>
&lt;li>/etc/motd：motd 是 message of the day 的缩写，用户成功登录后自动输出。内容由系统管理员确定。常用于通告信息，如计划关机时间的警告等。&lt;/li>
&lt;li>/etc/mtab：当前安装的文件系统列表。由脚本(scritp)初始化，并由 mount 命令自动更新。当需要一个当前安装的文件系统的列表时使用(例如 df 命令)。&lt;/li>
&lt;li>/etc/login.defs：login 命令的配置文件。&lt;/li>
&lt;li>/etc/printcap：类似/etc/termcap ，但针对打印机。语法不同。&lt;/li>
&lt;li>/etc/profile 、/etc/csh.login、/etc/csh.cshrc：登 录或启动时 bourne 或 cshells 执行的文件。这允许系统管理员为所有用户建立全局缺省环境。&lt;/li>
&lt;li>/etc/services # 该文件为 daemon 与端口号，所用协议的对应关系&lt;/li>
&lt;li>/etc/securetty：确认安全终端，即哪个终端允许超级用户(root) 登录。一般只列出虚拟控制台，这样就不可能(至少很困难)通过调制解调器(modem)或网络闯入系统并得到超级用户特权。&lt;/li>
&lt;li>/etc/shadow：在安装了影子(shadow)口令软件的系统上的影子口令 文件。影子口令文件将/etc/passwd 文件中的加密口令移动到/etc/shadow 中，而后者只对超级用户(root)可读。这使破译口令更困 难，以此增加系统的安全性。&lt;/li>
&lt;li>/etc/shells：列出可以使用的 shell。chsh 命令允许用户在本文件指定范围内改变登录的 shell。提供一台机器 ftp 服务的服务进程 ftpd 检查用户 shell 是否列在 /etc/shells 文件 中，如果不是，将不允许该用户登录。&lt;/li>
&lt;/ul>
&lt;h2 id="home---系统预设的用户家目录">/home - 系统预设的用户家目录&lt;/h2>
&lt;p>当新建用户没有指定家目录时默认家目录在“/home/用户名”下。例如：/home/john。&lt;/p>
&lt;h2 id="media---可移动媒体设备用于挂载可移动设备的临时目录">/media - 可移动媒体设备。用于挂载可移动设备的临时目录&lt;/h2>
&lt;h2 id="mnt---临时挂载目录">/mnt - 临时挂载目录&lt;/h2>
&lt;p>/mnt 目录是系统管理员临时安装(mount)文件系统的安装点。程序并不自动支持安装到 /mnt 。/mnt 下面可以分为许多子目录，例如 /mnt/dosa 可能是使用 msdos 文件系统的软驱，而 /mnt/exta 可能是使用 ext2 文件系统的软驱，/mnt/cdrom 光 驱等等。&lt;/p>
&lt;h2 id="opt---给第三方软件安装存放的目录如-oraclehacs-通常安装在此目录下">/opt - 给第三方软件安装存放的目录，如 Oracle、Hacs 通常安装在此目录下&lt;/h2>
&lt;p>/opt 目录开始默认是空的。&lt;/p>
&lt;h2 id="proc---包含系统进程的相关信息">/proc - 包含系统进程的相关信息&lt;/h2>
&lt;p>&lt;strong>process information pseudo-filesystem(进程信息伪文件系统，简称 proc)&lt;/strong>， 提供了内核数据结构的接口。默认被挂载到 /proc 目录上。一般情况是由操作系统自动挂载的，也可以通过&lt;code>mount -t proc proc /proc&lt;/code>命令手动挂载。proc 文件系统中的大多数文件都是只读的，但是有些文件是可写的，用于改变内核参数。&lt;/p>
&lt;p>详见：&lt;a href="https://desistdaydream.github.io/docs/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2.Kernel(%E5%86%85%E6%A0%B8)/6.File_System_%E7%AE%A1%E7%90%86/%E7%89%B9%E6%AE%8A%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/Proc%20File%20System.md">Proc File System&lt;/a>&lt;/p>
&lt;h2 id="root---系统管理员的家目录">/root - 系统管理员的家目录&lt;/h2>
&lt;h2 id="run---存放目录">/run - 存放目录&lt;/h2>
&lt;p>&lt;strong>Run-time Variable Data(运行时变量数据，简称 Run)&lt;/strong>。/run 目录是一个 &lt;strong>tmpfs(临时文件系统)&lt;/strong>。该目录下的文件，在系统启动时会被清除，之后用来存放自系统启动以来正在运行的系统信息，例如 当前登录的用户 和 正在运行的程序 pid 等等。 详见 &lt;a href="https://www.yuque.com/go/doc/33222775">tmpfs 详解&lt;/a>&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>~&lt;span style="color:#f92672">]&lt;/span>&lt;span style="color:#75715e"># df -h&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Filesystem Size Used Avail Use% Mounted on
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>devtmpfs 1.9G &lt;span style="color:#ae81ff">0&lt;/span> 1.9G 0% /dev
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>tmpfs 1.9G &lt;span style="color:#ae81ff">0&lt;/span> 1.9G 0% /dev/shm
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>tmpfs 1.9G 8.5M 1.9G 1% /run
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>tmpfs 1.9G &lt;span style="color:#ae81ff">0&lt;/span> 1.9G 0% /sys/fs/cgroup
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>/dev/mapper/vg1-root 500G 5.3G 494G 2% /
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>/dev/vda2 477M 198M 250M 45% /boot
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>tmpfs 378M &lt;span style="color:#ae81ff">0&lt;/span> 378M 0% /run/user/0
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="srv---存放服务数据的目录srv-代表服务包含服务器特定服务相关的数据">/srv - 存放服务数据的目录。srv 代表服务。包含服务器特定服务相关的数据&lt;/h2>
&lt;h2 id="sys---在该目录下查看内核空间中一些驱动和设备">/sys - 在该目录下查看内核空间中一些驱动和设备&lt;/h2>
&lt;p>/sys/class/dmi - 物理设备信息，包括品牌、型号、序列号。&lt;/p>
&lt;h2 id="tmp---创建临时文件的目录">/tmp - 创建临时文件的目录&lt;/h2>
&lt;p>/tmp 目录存放程序在运行时产生的信息和数据。但在引导启动后，运行的程序最好使用/var/tmp 来 代替/tmp，因为前者可能拥有一个更大的磁盘空间。&lt;/p>
&lt;h2 id="usr---存放程序包含二进制文件库文件文档和二级程序的源代码">/usr - 存放程序。包含二进制文件、库文件、文档和二级程序的源代码&lt;/h2>
&lt;p>最庞大的目录，要用到的应用程序和文件几乎都在这个目录&lt;/p>
&lt;p>usr 是哪个的缩写一般无法准确，就现在来看，unix share resource 这个解释更合理一点，在 linux 很早之前，确实把 usr 目录当作用户的家目录来看，只不过后来把把用户家目录移动到/home 下罢了，现在的 usr 目录是个很重要的目录，通常这一文件系统很大，因为所有程序安装在这里。/usr 里的所有文件一般来自 linux 发行版；本地安装的程序和其他东西在/usr/local 下，因为这样可以在升级新版系 统或新发行版时无须重新安装全部程序。/usr 目录下的许多内容是可选的，但这些功能会使用户使用系统更加有效。/usr 可容纳许多大型的软件包和它们的 配置文件&lt;/p>
&lt;p>除了/usr/share 目录的内容外，/usr 文件系统中的文件和目录可由具有相同硬件体系结构的所有机器共享&lt;/p>
&lt;ul>
&lt;li>&lt;strong>/usr/bin&lt;/strong> 与 &lt;strong>/usr/sbin&lt;/strong> # 中包含用户程序的应用程序(二进制文件)。如果你在/bin 中找不到用户二进制文件，到/usr/bin 目录看看。例如：at、awk、cc、less、scp。集中了几乎所有用户命令，是系统的软件库。另有些命令在/bin 或/usr/local/bin 中。sbin 中包含系统管理员的管理程序(二进制文件)。如果你在/sbin 中找不到系统二进制文件，到/usr/sbin 目录看看。例如：atd、cron、sshd、useradd、userdel。包括了根文件系统不必要的系统管理命令，例如多数服务程序。&lt;/li>
&lt;li>/usr/include # 包含了 c 语言的头文件，这些文件多以.h 结尾，用来描述 c 语言程序中用到的数据结构、子过程和常量。为了保持一致性，这实际上应该放在/usr/lib 下，但习惯上一直沿用了这 个名字。&lt;/li>
&lt;li>&lt;strong>/usr/lib&lt;/strong>与 &lt;strong>/usr/lib64&lt;/strong> # 常用的动态链接库和软件包的配置文件。包含了程序或子系统的不变的数据文件，包括一些 site – wide 配置文件。名字 lib 来源于库(library); 编程的原始库也存在/usr/lib 里。当编译程序时，程序便会和其中的库进行连接。也有许多程序把配置文件存入其中。包含支持位于/bin 和/sbin 下的二进制文件的库文件，库文件名为 ld&lt;em>或 lib&lt;/em>.so.*。
&lt;ul>
&lt;li>&lt;strong>/lib/modules&lt;/strong> 目录包含系统核心可加载各种模块，尤其是那些在恢复损坏的系统时重 新引导系统所需的模块(例如网络和文件系统驱动)。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>/usr/local&lt;/strong> # 本地安装的软件和其他文件放在这里。这与/usr 很相似。用户 可能会在这发现一些比较大的软件包，如 tex、emacs 等。
&lt;ul>
&lt;li>&lt;strong>/usr/local/bin&lt;/strong> # 本地增加的命令。&lt;/li>
&lt;li>&lt;strong>/usr/local/lib&lt;/strong> # 本地增加的库根文件系统。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>/usr/share&lt;/strong> # 包含于体系结构无关的可共享的文本文件。无论硬件体系结(x86、小型机等)构如何，此目录的内容都可由所有机器共享。
&lt;ul>
&lt;li>&lt;strong>./man、./info、./doc&lt;/strong> # 这些目录包含所有 man 命令手册页、 gnu 信息文档和各种其他文档文件。每个联机手册的“节”都有两个子目录。例如：./man/man1 中包含联机手册第一节的源码(没有格式化的原 始文件)，./man/cat1 包含第一节已格式化的内容。联机手册分为以下九节：内部命令、系统调用、库函数、设备、文件格式、游戏、宏软件包、 系统管理和核心程序。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>/usr/src&lt;/strong> # 源代码，linux 内核的源代码就放在/usr/src/linux 里。&lt;/li>
&lt;li>&lt;strong>/usr/x11r6&lt;/strong> # 存放 x window 的目录。包含 x window 系统的所有可执行程序、配置文件和支持文件。为简化 x 的开发和安装，x 的文件没有集成到系统中。x window 系统是一个功能强大的图形环境，提供了大量的图形工具程序。用户如果对 microsoft windows 比较熟悉的话，就不会对 x window 系统感到束手无策了&lt;/li>
&lt;li>&lt;strong>/usr/x386&lt;/strong> # 类似/usr/x11r6 ，但是是专门给 x 11 release 5 的。&lt;/li>
&lt;/ul>
&lt;h2 id="var---存放变量文件的目录这个目录下的文件是可能增长的">/var - 存放变量文件的目录。这个目录下的文件是可能增长的&lt;/h2>
&lt;p>包括系统日志文件（/var/log）、包和数据库文件（/var/lib）、电子邮件（/var/mail）、打印队列（/var/spool）等等。&lt;/p>
&lt;p>/var 包含系统一般运行时要改变的数据。通常这些数据所在的目录的大小是要经常变化或扩充 的。原来/var 目录中有些内容是在/usr 中的，但为了保持/usr 目录的相对稳定，就把那些需要经常改变的目录放到/var 中了。每个系统是特定的， 即不通过网络与其他计算机共享。下面列出一些重要的目录(一些不太重要的目录省略了)。&lt;/p>
&lt;ul>
&lt;li>&lt;strong>/var/catman&lt;/strong> # 包括了格式化过的帮助(man)页。帮助页的源文件一般存在 /usr/man/catman 中；有些 man 页可能有预格式化的版本，存在/usr/man/cat 中。而其他的 man 页在第一次看时都需要格式化，格 式化完的版本存在/var/man 中，这样其他人再看相同的页时就无须等待格式化了。(/var/catman 经常被 清除，就像清除临时目录一样。)&lt;/li>
&lt;li>&lt;strong>/var/lib&lt;/strong> # 存放系统正常运行时要改变的文件。&lt;/li>
&lt;li>&lt;strong>/var/local&lt;/strong> # 存放/usr/local 中 安装的程序的可变数据(即系统管理员安装的程序)。注意，如果必要，即使本地安装的程序也会使用其他/var 目录，例如/var/lock 。&lt;/li>
&lt;li>&lt;strong>/var/lock&lt;/strong> # 锁定文件。许多程序遵循在/var/lock 中 产生一个锁定文件的约定，以用来支持他们正在使用某个特定的设备或文件。其他程序注意到这个锁定文件时，就不会再使用这个设备或文件。&lt;/li>
&lt;li>&lt;strong>/var/log/&lt;/strong> # 各种程序的日志(log)文件，尤其是 login (/var/log/wtmplog 纪 录所有到系统的登录和注销) 和 syslog (/var/log/messages 纪录存储所有核心和系统程序信息)。/var/log 里的文件经常不确定地增长，应该定期清除。&lt;/li>
&lt;li>&lt;strong>/var/run/&lt;/strong> # 是 /run 目录的软链接&lt;/li>
&lt;li>&lt;strong>/var/spool&lt;/strong> # 放置“假脱机(spool)”程序的目录，如 mail、 news、打印队列和其他队列工作的目录。每个不同的 spool 在/var/spool 下有自己的子目录，例如，用户的邮箱就存放在/var/spool/mail 中。&lt;/li>
&lt;li>&lt;strong>/var/tmp&lt;/strong> # 比/tmp 允许更大的或需要存在较长时间的临时文件。注意系统管理 员可能不允许/var/tmp 有很旧的文件。&lt;/li>
&lt;/ul></description></item><item><title>Docs: 磁盘文件系统</title><link>https://desistdaydream.github.io/docs/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2.Kernel%E5%86%85%E6%A0%B8/6.File_System_%E7%AE%A1%E7%90%86/%E7%A3%81%E7%9B%98%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2.Kernel%E5%86%85%E6%A0%B8/6.File_System_%E7%AE%A1%E7%90%86/%E7%A3%81%E7%9B%98%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/</guid><description/></item><item><title>Docs: 特殊文件系统</title><link>https://desistdaydream.github.io/docs/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2.Kernel%E5%86%85%E6%A0%B8/6.File_System_%E7%AE%A1%E7%90%86/%E7%89%B9%E6%AE%8A%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2.Kernel%E5%86%85%E6%A0%B8/6.File_System_%E7%AE%A1%E7%90%86/%E7%89%B9%E6%AE%8A%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/</guid><description/></item><item><title>Docs: 文件管理</title><link>https://desistdaydream.github.io/docs/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2.Kernel%E5%86%85%E6%A0%B8/6.File_System_%E7%AE%A1%E7%90%86/%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2.Kernel%E5%86%85%E6%A0%B8/6.File_System_%E7%AE%A1%E7%90%86/%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86/</guid><description/></item><item><title>Docs: I_O Multiplexing(输入_输出多路复用)</title><link>https://desistdaydream.github.io/docs/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2.Kernel%E5%86%85%E6%A0%B8/6.File_System_%E7%AE%A1%E7%90%86/I_O-Multiplexing%E8%BE%93%E5%85%A5_%E8%BE%93%E5%87%BA%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2.Kernel%E5%86%85%E6%A0%B8/6.File_System_%E7%AE%A1%E7%90%86/I_O-Multiplexing%E8%BE%93%E5%85%A5_%E8%BE%93%E5%87%BA%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8/</guid><description/></item><item><title>Docs: 读取文件时，程序经历了什么？</title><link>https://desistdaydream.github.io/docs/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2.Kernel%E5%86%85%E6%A0%B8/6.File_System_%E7%AE%A1%E7%90%86/%E8%AF%BB%E5%8F%96%E6%96%87%E4%BB%B6%E6%97%B6%E7%A8%8B%E5%BA%8F%E7%BB%8F%E5%8E%86%E4%BA%86%E4%BB%80%E4%B9%88/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2.Kernel%E5%86%85%E6%A0%B8/6.File_System_%E7%AE%A1%E7%90%86/%E8%AF%BB%E5%8F%96%E6%96%87%E4%BB%B6%E6%97%B6%E7%A8%8B%E5%BA%8F%E7%BB%8F%E5%8E%86%E4%BA%86%E4%BB%80%E4%B9%88/</guid><description>
&lt;p>&lt;a href="https://mp.weixin.qq.com/s?__biz=Mzg4OTYzODM4Mw==&amp;amp;mid=2247485706&amp;amp;idx=1&amp;amp;sn=bc5d6e4bf9ee5dccef520e5b2051d943&amp;amp;source=41#wechat_redirect">https://mp.weixin.qq.com/s?__biz=Mzg4OTYzODM4Mw==&amp;amp;mid=2247485706&amp;amp;idx=1&amp;amp;sn=bc5d6e4bf9ee5dccef520e5b2051d943&amp;amp;source=41#wechat_redirect&lt;/a>&lt;/p>
&lt;p>承接上文《看完这篇还不懂高并发中的线程与线程池你来打我》，这是高性能、高并发系列的第二篇文章，在这里我们来到了 I/O 这一话题。&lt;/p>
&lt;p>码农的荒岛求生：图解 | 看完这篇还不懂高并发中的线程与线程池你来打我 zhuanlan.zhihu.com&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/funqnh/1616167569949-61c844f7-bb43-4068-899f-7ca8a0631e14.jpeg" alt="">&lt;/p>
&lt;p>你有没有想过当我们执行 I/O 操作时计算机底层都发生了些什么？&lt;/p>
&lt;p>在回答这个问题之前，我们先来看下为什么对于计算机来说 I/O 是极其重要的。&lt;/p>
&lt;h2 id="不能执行-io-的计算机是什么">&lt;strong>不能执行 I/O 的计算机是什么？&lt;/strong>&lt;/h2>
&lt;p>相信对于程序员来说 I/O 操作是最为熟悉不过的了：&lt;/p>
&lt;p>当我们使用 C 语言中的 printf、C++中的&amp;quot;&amp;laquo;&amp;quot;，Python 中的 print，Java 中的 System.out.println 等时，这是 I/O；当我们使用各种语言读写文件时，这也是 I/O；当我们通过 TCP/IP 进行网络通信时，这同样是 I/O;当我们使用鼠标龙飞凤舞时，当我们扛起键盘在评论区里指点江山亦或是埋头苦干努力制造 bug 时、当我们能看到屏幕上的漂亮的图形界面时等等，这一切都是 I/O。&lt;/p>
&lt;p>想一想，如果没有 I/O 计算机该是一种多么枯燥的设备，不能看电影、不能玩游戏，也不能上网，这样的计算机最多就是一个大号的计算器。&lt;/p>
&lt;p>既然 I/O 这么重要，那么到底什么才是 I/O 呢？&lt;/p>
&lt;h2 id="什么是-io">&lt;strong>什么是 I/O&lt;/strong>&lt;/h2>
&lt;p>I/O 就是简单的&lt;strong>数据 Copy&lt;/strong>，仅此而已。&lt;/p>
&lt;p>这一点很重要，为了加深大家的印象，来，Everybody，Follow me，那边树上的朋友，还有那边墙上的朋友们，举起你们的双手，跟我唱，苍茫的天涯是。。。Sorry，I/O 仅仅就是数据 copy、I/O 仅仅就是数据 copy。&lt;/p>
&lt;p>让我们先把演唱会的事情放在一边，既然是 copy 数据，又是从哪里 copy 到哪里呢？&lt;/p>
&lt;p>如果数据是从外部设备 copy 到内存中，这就是 Input。&lt;/p>
&lt;p>如果数据是从内存 copy 到外部设备，这就是 Output。&lt;/p>
&lt;p>&lt;strong>内存与外部设备之间不嫌麻烦的来回 copy 数据就是 Input and Output，简称 I/O&lt;/strong>（Input/Output），仅此而已。&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/funqnh/1616167569957-0700ad3d-4f0a-4f25-a308-bf8fa3bc9259.jpeg" alt="">&lt;/p>
&lt;h2 id="io-与-cpu">&lt;strong>I/O 与 CPU&lt;/strong>&lt;/h2>
&lt;p>现在我们知道了什么是 I/O，接下来就是重点部分了，大家注意，坐稳了。&lt;/p>
&lt;p>我们知道现在的 CPU 其主频都是数 GHz 起步，这是什么意思呢？简单说就是 CPU 执行机器指令的速度是纳秒级别的，而通常的 I/O 比如磁盘操作，一次磁盘 seek 大概在毫秒级别，&lt;strong>因此如果我们把 CPU 的速度比作战斗机的话，那么 I/O 操作的速度就是肯德鸡&lt;/strong>。&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/funqnh/1616167569966-3f124af4-18e4-4c8a-98c1-793d3e2c3a9e.jpeg" alt="">&lt;/p>
&lt;p>也就是说当我们的程序跑起来时(CPU 执行机器指令)，其速度是要远远快于 I/O 速度的，那么接下来的问题就是二者速度相差这么大，那么我们该如何设计、该如何更加合理的高效利用系统资源呢？&lt;/p>
&lt;p>既然有速度差异，而且进程在执行完 I/O 操作前不能继续向前推进，那么显然只有一个办法，那就是&lt;strong>等待，wait&lt;/strong>。&lt;/p>
&lt;p>同样是等待，有聪明的等待，也有傻傻的等待，简称傻等，那么是选择聪明的等待呢还是选择傻等呢？&lt;/p>
&lt;p>假设你是一个急性子(CPU)，需要等待一个重要的文件，不巧的是这个文件只能快递过来(I/O)，那么这时你是选择什么事情都不干了，深情的注视着门口就像盼望着你的哈尼一样专心等待这个快递呢？还是暂时先不要管快递了，玩个游戏看个电影刷会儿短视频等快递来了再说呢？&lt;/p>
&lt;p>很显然，更好的方法就是先去干其它事情，快递来了再说。&lt;/p>
&lt;p>&lt;strong>因此这里的关键点就是快递没到前手头上的事情可以先暂停，切换到其它任务，等快递过来了再切换回来&lt;/strong>。&lt;/p>
&lt;p>理解了这一点你就能明白执行 I/O 操作时底层都发生了什么。&lt;/p>
&lt;p>接下来让我们以读取磁盘文件为例来讲解这一过程。&lt;/p>
&lt;h2 id="执行-io-时底层都发生了什么">&lt;strong>执行 I/O 时底层都发生了什么&lt;/strong>&lt;/h2>
&lt;p>在上一篇《一文彻底理解高并发高性能中的线程与线程池》中，我们引入了进程和线程的概念，在支持线程的操作系统中，实际上被调度的是线程而不是进程，为了更加清晰的理解 I/O 过程，我们暂时假设操作系统只有进程这样的概念，先不去考虑线程，这并不会影响我们的讨论。&lt;/p>
&lt;p>现在内存中有两个进程，进程 A 和进程 B，当前进程 A 正在运行，如图所示：&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/funqnh/1616167569940-d2d3bdbc-c805-4f6e-bdbc-2b7a04cdecb6.jpeg" alt="">&lt;/p>
&lt;p>进程 A 中有一段读取文件的代码，不管在什么语言中通常我们定义一个用来装数据的 buff，然后调用 read 之类的函数，像这样：&lt;/p>
&lt;pre>&lt;code>read(buff);
&lt;/code>&lt;/pre>
&lt;p>这就是一种典型的 I/O 操作，当 CPU 执行到这段代码的时候会向磁盘发送读取请求，注意与 CPU 执行指令的速度相比，I/O 操作操作是非常慢的，因此操作系统是不可能把宝贵的 CPU 计算资源浪费在无谓的等待上的，这时重点来了，注意接下来是重点哦。&lt;/p>
&lt;p>由于外部设备执行 I/O 操作是相当慢的，因此在 I/O 操作完成之前进程是无法继续向前推进的，这就是所谓的&lt;strong>阻塞&lt;/strong>，即通常所说的 block。操作系统检测到进程向 I/O 设备发起请求后就暂停进程的运行，怎么暂停运行呢？很简单，只需要记录下当前进程的运行状态并把 CPU 的 PC 寄存器指向其它进程的指令就可以了。&lt;/p>
&lt;p>进程有暂停就会有继续执行，因此操作系统必须保存被暂停的进程以备后续继续执行，显然我们可以用队列来保存被暂停执行的进程，如图所示，进程 A 被暂停执行并被放到阻塞队列中(注意，不同的操作系统会有不同的实现，可能每个 I/O 设备都有一个对应的阻塞队列，但这种实现细节上的差异不影响我们的讨论)。&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/funqnh/1616167569940-4c41239e-bb6f-42a4-9111-8ca9b2ed634d.jpeg" alt="">&lt;/p>
&lt;p>这时操作系统已经向磁盘发送了 I/O 请求，因此磁盘 driver 开始将磁盘中的数据 copy 到进程 A 的 buff 中，虽然这时进程 A 已经被暂停执行了，但这并不妨碍磁盘向内存中 copy 数据。注意，现代磁盘向内存 copy 数据时无需借助 CPU 的帮助，这就是所谓的 DMA(Direct Memory Access)，这个过程如图所示：&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/funqnh/1616167569921-5b8dc049-61a5-498e-ae21-4adb68bd49e5.jpeg" alt="">&lt;/p>
&lt;p>让磁盘先 copy 着数据，我们接着聊。&lt;/p>
&lt;p>实际上操作系统中除了有阻塞队列之外也有&lt;strong>就绪&lt;/strong>队列，所谓就绪队列是指队列里的进程准备就绪可以被 CPU 执行了，你可能会问为什么不直接执行非要有个就绪队列呢？答案很简单，那就是&lt;strong>僧多粥少&lt;/strong>，在即使只有 1 个核的机器上也可以创建出成千上万个进程，CPU 不可能同时执行这么多的进程，因此必然存在这样的进程，&lt;strong>即使其一切准备就绪也不能被分配到计算资源&lt;/strong>，这样的进程就被放到了就绪队列。&lt;/p>
&lt;p>现在进程 B 就位于就绪队列，万事俱备只欠 CPU，如图所示：&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/funqnh/1616167569959-d7bf4862-5f3a-402f-94f3-ec2d8e31e121.jpeg" alt="">&lt;/p>
&lt;p>当进程 A 被暂停执行后 CPU 是不可以闲下来的，因为就绪队列中还有嗷嗷待哺的进程 B，这时操作系统开始在就绪队列中找下一个可以执行的进程，也就是这里的进程 B。&lt;/p>
&lt;p>此时操作系统将进程 B 从就绪队列中取出，找出进程 B 被暂停时执行到的机器指令的位置，然后将 CPU 的 PC 寄存器指向该位置，这样进程 B 就开始运行啦，如图所示：&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/funqnh/1616167569941-4a2d092b-f747-43b4-abbc-6a8e238b4cbe.jpeg" alt="">&lt;/p>
&lt;p>注意，注意，接下来的这段是重点中的重点。&lt;/p>
&lt;p>注意观察上图，此时进程 B 在被 CPU 执行，磁盘在向进程 A 的内存空间中 copy 数据，看出来了吗，&lt;strong>大家都在忙，谁都没有闲着，数据 copy 和指令执行在同时进行&lt;/strong>，在操作系统的调度下，CPU、磁盘都得到了&lt;strong>充分&lt;/strong>的利用，这就是程序员的智慧所在。&lt;/p>
&lt;p>&lt;strong>现在你应该理解为什么操作系统这么重要了吧。&lt;/strong>&lt;/p>
&lt;p>此后磁盘终于将全部数据都 copy 到了进程 A 的内存中，这时磁盘通知操作系统任务完成啦，你可能会问怎么通知呢？这就是中断。&lt;/p>
&lt;p>操作系统接收到磁盘中断后发现数据 copy 完毕，进程 A 重新获得继续运行的资格，这时操作系统小心翼翼的把进程 A 从阻塞队列放到了就绪队列当中，如图所示：&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/funqnh/1616167569942-ce92b9c9-06b3-4c3e-99e7-bc5d7777795b.jpeg" alt="">&lt;/p>
&lt;p>注意，从前面关于就绪状态的讨论中我们知道，操作系统是不会直接运行进程 A 的，进程 A 必须被放到就绪队列中等待，这样对大家都公平。&lt;/p>
&lt;p>此后进程 B 继续执行，进程 A 继续等待，进程 B 执行了一会儿后操作系统认为进程 B 执行的时间够长了，因此把进程 B 放到就绪队列，把进程 A 取出并继续执行。&lt;/p>
&lt;p>注意操作系统把进程 B 放到的是就绪队列，因此进程 B 被暂停运行仅仅是因为时间片到了而不是因为发起 I/O 请求被阻塞，如图所示：&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/funqnh/1616167569968-658743aa-149f-402d-a608-676638aa4868.jpeg" alt="">&lt;/p>
&lt;p>进程 A 继续执行，&lt;strong>此时 buff 中已经装满了想要的数据，进程 A 就这样愉快的运行下去了，就好像从来没有被暂停过一样，进程对于自己被暂停一事一无所知，这就是操作系统的魔法&lt;/strong>。&lt;/p>
&lt;p>现在你应该明白了 I/O 是一个怎样的过程了吧。&lt;/p>
&lt;p>这种进程执行 I/O 操作被阻塞暂停执行的方式被称为阻塞式 I/O，blocking I/O，这也是最常见最容易理解的 I/O 方式，有阻塞式 I/O 就有非阻塞式 I/O，在这里我们暂时先不考虑这种方式。&lt;/p>
&lt;p>在本节开头我们说过暂时只考虑进程而不考虑线程，现在我们放宽这个条件，实际上也非常简单，只需要把前图中调度的进程改为线程就可以了，这里的讨论对于线程一样成立。&lt;/p>
&lt;h2 id="零拷贝zero-copy">&lt;strong>零拷贝，Zero-copy&lt;/strong>&lt;/h2>
&lt;p>最后需要注意的一点就是上面的讲解中我们直接把磁盘数据 copy 到了进程空间中，&lt;strong>但实际上一般情况下 I/O 数据是要首先 copy 到操作系统内部，然后操作系统再 copy 到进程空间中&lt;/strong>。因此我们可以看到这里其实还有一层经过操作系统的 copy，对于性能要求很高的场景其实也是可以绕过操作系统直接进行数据 copy 的，这也是本文描述的场景，这种绕过操作系统直接进行数据 copy 的技术被称为&lt;strong>Zero-copy&lt;/strong>，也就零拷贝，高并发、高性能场景下常用的一种技术，原理上很简单吧。&lt;/p>
&lt;h2 id="总结">&lt;strong>总结&lt;/strong>&lt;/h2>
&lt;p>本文讲解的是程序员常用的 I/O，一般来说作为程序员我们无需关心，但是理解 I/O 背后的底层原理对于设计高性能、高并发系统是极为有益的，希望这篇能对大家加深对 I/O 的认识有所帮助。&lt;/p></description></item><item><title>Docs: 零拷贝</title><link>https://desistdaydream.github.io/docs/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2.Kernel%E5%86%85%E6%A0%B8/6.File_System_%E7%AE%A1%E7%90%86/%E9%9B%B6%E6%8B%B7%E8%B4%9D/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2.Kernel%E5%86%85%E6%A0%B8/6.File_System_%E7%AE%A1%E7%90%86/%E9%9B%B6%E6%8B%B7%E8%B4%9D/</guid><description>
&lt;hr>
&lt;h2 id="前言">前言&lt;/h2>
&lt;p>磁盘可以说是计算机系统最慢的硬件之一，读写速度相差内存 10 倍以上，所以针对优化磁盘的技术非常的多，比如零拷贝、直接 I/O、异步 I/O 等等，这些优化的目的就是为了提高系统的吞吐量，另外操作系统内核中的磁盘高速缓存区，可以有效的减少磁盘的访问次数。&lt;/p>
&lt;p>这次，我们就以「文件传输」作为切入点，来分析 I/O 工作方式，以及如何优化传输文件的性能。&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/zl0fv1/1616167581743-fe1685b9-8478-478c-bec2-c7d550e1f54a.png" alt="">&lt;/p>
&lt;hr>
&lt;h2 id="正文">正文&lt;/h2>
&lt;h3 id="为什么要有-dma-技术">为什么要有 DMA 技术?&lt;/h3>
&lt;p>在没有 DMA 技术前，I/O 的过程是这样的：&lt;/p>
&lt;ul>
&lt;li>CPU 发出对应的指令给磁盘控制器，然后返回；&lt;/li>
&lt;li>磁盘控制器收到指令后，于是就开始准备数据，会把数据放入到磁盘控制器的内部缓冲区中，然后产生一个&lt;strong>中断&lt;/strong>；&lt;/li>
&lt;li>CPU 收到中断信号后，停下手头的工作，接着把磁盘控制器的缓冲区的数据一次一个字节地读进自己的寄存器，然后再把寄存器里的数据写入到内存，而在数据传输的期间 CPU 是无法执行其他任务的。&lt;/li>
&lt;/ul>
&lt;p>为了方便你理解，我画了一副图：&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/zl0fv1/1616167581747-833fd3d8-b587-44e5-a4d7-2118e13b1b44.png" alt="">&lt;/p>
&lt;p>可以看到，整个数据的传输过程，都要需要 CPU 亲自参与搬运数据的过程，而且这个过程，CPU 是不能做其他事情的。&lt;/p>
&lt;p>简单的搬运几个字符数据那没问题，但是如果我们用千兆网卡或者硬盘传输大量数据的时候，都用 CPU 来搬运的话，肯定忙不过来。&lt;/p>
&lt;p>计算机科学家们发现了事情的严重性后，于是就发明了 DMA 技术，也就是&lt;strong>直接内存访问（***&lt;strong>Direct Memory Access&lt;/strong>*&lt;/strong>）** 技术。&lt;/p>
&lt;p>什么是 DMA 技术？简单理解就是，&lt;strong>在进行 I/O 设备和内存的数据传输的时候，数据搬运的工作全部交给 DMA 控制器，而 CPU 不再参与任何与数据搬运相关的事情，这样 CPU 就可以去处理别的事务&lt;/strong>。&lt;/p>
&lt;p>那使用 DMA 控制器进行数据传输的过程究竟是什么样的呢？下面我们来具体看看。&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/zl0fv1/1616167581757-ef21d29d-7f2b-4cd1-a747-98b242f710cf.png" alt="">&lt;/p>
&lt;p>具体过程：&lt;/p>
&lt;ul>
&lt;li>用户进程调用 read 方法，向操作系统发出 I/O 请求，请求读取数据到自己的内存缓冲区中，进程进入阻塞状态；&lt;/li>
&lt;li>操作系统收到请求后，进一步将 I/O 请求发送 DMA，然后让 CPU 执行其他任务；&lt;/li>
&lt;li>DMA 进一步将 I/O 请求发送给磁盘；&lt;/li>
&lt;li>磁盘收到 DMA 的 I/O 请求，把数据从磁盘读取到磁盘控制器的缓冲区中，当磁盘控制器的缓冲区被读满后，向 DMA 发起中断信号，告知自己缓冲区已满；&lt;/li>
&lt;li>&lt;strong>DMA 收到磁盘的信号，将磁盘控制器缓冲区中的数据拷贝到内核缓冲区中，此时不占用 CPU，CPU 可以执行其他任务&lt;/strong>；&lt;/li>
&lt;li>当 DMA 读取了足够多的数据，就会发送中断信号给 CPU；&lt;/li>
&lt;li>CPU 收到 DMA 的信号，知道数据已经准备好，于是将数据从内核拷贝到用户空间，系统调用返回；&lt;/li>
&lt;/ul>
&lt;p>可以看到， 整个数据传输的过程，CPU 不再参与数据搬运的工作，而是全程由 DMA 完成，但是 CPU 在这个过程中也是必不可少的，因为传输什么数据，从哪里传输到哪里，都需要 CPU 来告诉 DMA 控制器。&lt;/p>
&lt;p>早期 DMA 只存在在主板上，如今由于 I/O 设备越来越多，数据传输的需求也不尽相同，所以每个 I/O 设备里面都有自己的 DMA 控制器。&lt;/p>
&lt;hr>
&lt;h3 id="传统的文件传输有多糟糕">传统的文件传输有多糟糕？&lt;/h3>
&lt;p>如果服务端要提供文件传输的功能，我们能想到的最简单的方式是：将磁盘上的文件读取出来，然后通过网络协议发送给客户端。&lt;/p>
&lt;p>传统 I/O 的工作方式是，数据读取和写入是从用户空间到内核空间来回复制，而内核空间的数据是通过操作系统层面的 I/O 接口从磁盘读取或写入。&lt;/p>
&lt;p>代码通常如下，一般会需要两个系统调用：&lt;/p>
&lt;pre>&lt;code>read(file, tmp_buf, len);write(socket, tmp_buf, len);
&lt;/code>&lt;/pre>
&lt;p>1
Plain Text&lt;/p>
&lt;p>代码很简单，虽然就两行代码，但是这里面发生了不少的事情。&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/zl0fv1/1616167581754-e4951f6d-41a5-4564-a890-901bf62db701.png" alt="">&lt;/p>
&lt;p>首先，期间共&lt;strong>发生了 4 次用户态与内核态的上下文切换&lt;/strong>，因为发生了两次系统调用，一次是 &lt;code>read()&lt;/code> ，一次是 &lt;code>write()&lt;/code>，每次系统调用都得先从用户态切换到内核态，等内核完成任务后，再从内核态切换回用户态。&lt;/p>
&lt;p>上下文切换到成本并不小，一次切换需要耗时几十纳秒到几微秒，虽然时间看上去很短，但是在高并发的场景下，这类时间容易被累积和放大，从而影响系统的性能。&lt;/p>
&lt;p>其次，还&lt;strong>发生了 4 次数据拷贝&lt;/strong>，其中两次是 DMA 的拷贝，另外两次则是通过 CPU 拷贝的，下面说一下这个过程：&lt;/p>
&lt;ul>
&lt;li>&lt;em>第一次拷贝&lt;/em>，把磁盘上的数据拷贝到操作系统内核的缓冲区里，这个拷贝的过程是通过 DMA 搬运的。&lt;/li>
&lt;li>&lt;em>第二次拷贝&lt;/em>，把内核缓冲区的数据拷贝到用户的缓冲区里，于是我们应用程序就可以使用这部分数据了，这个拷贝到过程是由 CPU 完成的。&lt;/li>
&lt;li>&lt;em>第三次拷贝&lt;/em>，把刚才拷贝到用户的缓冲区里的数据，再拷贝到内核的 socket 的缓冲区里，这个过程依然还是由 CPU 搬运的。&lt;/li>
&lt;li>&lt;em>第四次拷贝&lt;/em>，把内核的 socket 缓冲区里的数据，拷贝到网卡的缓冲区里，这个过程又是由 DMA 搬运的。&lt;/li>
&lt;/ul>
&lt;p>我们回过头看这个文件传输的过程，我们只是搬运一份数据，结果却搬运了 4 次，过多的数据拷贝无疑会消耗 CPU 资源，大大降低了系统性能。&lt;/p>
&lt;p>这种简单又传统的文件传输方式，存在冗余的上文切换和数据拷贝，在高并发系统里是非常糟糕的，多了很多不必要的开销，会严重影响系统性能。&lt;/p>
&lt;p>所以，&lt;strong>要想提高文件传输的性能，就需要减少「用户态与内核态的上下文切换」和「内存拷贝」的次数&lt;/strong>。&lt;/p>
&lt;hr>
&lt;h3 id="如何优化文件传输的性能">如何优化文件传输的性能？&lt;/h3>
&lt;blockquote>
&lt;p>先来看看，如何减少「用户态与内核态的上下文切换」的次数呢？&lt;/p>
&lt;/blockquote>
&lt;p>读取磁盘数据的时候，之所以要发生上下文切换，这是因为用户空间没有权限操作磁盘或网卡，内核的权限最高，这些操作设备的过程都需要交由操作系统内核来完成，所以一般要通过内核去完成某些任务的时候，就需要使用操作系统提供的系统调用函数。&lt;/p>
&lt;p>而一次系统调用必然会发生 2 次上下文切换：首先从用户态切换到内核态，当内核执行完任务后，再切换回用户态交由进程代码执行。&lt;/p>
&lt;p>所以，&lt;strong>要想减少上下文切换到次数，就要减少系统调用的次数&lt;/strong>。&lt;/p>
&lt;blockquote>
&lt;p>再来看看，如何减少「数据拷贝」的次数？&lt;/p>
&lt;/blockquote>
&lt;p>在前面我们知道了，传统的文件传输方式会历经 4 次数据拷贝，而且这里面，「从内核的读缓冲区拷贝到用户的缓冲区里，再从用户的缓冲区里拷贝到 socket 的缓冲区里」，这个过程是没有必要的。&lt;/p>
&lt;p>因为文件传输的应用场景中，在用户空间我们并不会对数据「再加工」，所以数据实际上可以不用搬运到用户空间，因此&lt;strong>用户的缓冲区是没有必要存在的&lt;/strong>。&lt;/p>
&lt;hr>
&lt;h3 id="如何实现零拷贝">如何实现零拷贝？&lt;/h3>
&lt;p>零拷贝技术实现的方式通常有 2 种：&lt;/p>
&lt;ul>
&lt;li>mmap + write&lt;/li>
&lt;li>sendfile&lt;/li>
&lt;/ul>
&lt;p>下面就谈一谈，它们是如何减少「上下文切换」和「数据拷贝」的次数。&lt;/p>
&lt;p>mmap + write&lt;/p>
&lt;p>在前面我们知道，&lt;code>read()&lt;/code> 系统调用的过程中会把内核缓冲区的数据拷贝到用户的缓冲区里，于是为了减少这一步开销，我们可以用 &lt;code>mmap()&lt;/code> 替换 &lt;code>read()&lt;/code> 系统调用函数。&lt;/p>
&lt;pre>&lt;code>buf = mmap(file, len);write(sockfd, buf, len);
&lt;/code>&lt;/pre>
&lt;p>1
Plain Text&lt;/p>
&lt;p>&lt;code>mmap()&lt;/code> 系统调用函数会直接把内核缓冲区里的数据「&lt;strong>映射&lt;/strong>」到用户空间，这样，操作系统内核与用户空间就不需要再进行任何的数据拷贝操作。&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/zl0fv1/1616167581773-7d9df0ea-5e23-48c7-9e90-5575bf286553.png" alt="">&lt;/p>
&lt;p>具体过程如下：&lt;/p>
&lt;ul>
&lt;li>应用进程调用了 &lt;code>mmap()&lt;/code> 后，DMA 会把磁盘的数据拷贝到内核的缓冲区里。接着，应用进程跟操作系统内核「共享」这个缓冲区；&lt;/li>
&lt;li>应用进程再调用 &lt;code>write()&lt;/code>，操作系统直接将内核缓冲区的数据拷贝到 socket 缓冲区中，这一切都发生在内核态，由 CPU 来搬运数据；&lt;/li>
&lt;li>最后，把内核的 socket 缓冲区里的数据，拷贝到网卡的缓冲区里，这个过程是由 DMA 搬运的。&lt;/li>
&lt;/ul>
&lt;p>我们可以得知，通过使用 &lt;code>mmap()&lt;/code> 来代替 &lt;code>read()&lt;/code>， 可以减少一次数据拷贝的过程。&lt;/p>
&lt;p>但这还不是最理想的零拷贝，因为仍然需要通过 CPU 把内核缓冲区的数据拷贝到 socket 缓冲区里，而且仍然需要 4 次上下文切换，因为系统调用还是 2 次。&lt;/p>
&lt;p>sendfile&lt;/p>
&lt;p>在 Linux 内核版本 2.1 中，提供了一个专门发送文件的系统调用函数 &lt;code>sendfile()&lt;/code>，函数形式如下：&lt;/p>
&lt;pre>&lt;code>#include &amp;lt;sys/socket.h&amp;gt;ssize_t sendfile(int out_fd, int in_fd, off_t *offset, size_t count);
&lt;/code>&lt;/pre>
&lt;p>1
Plain Text&lt;/p>
&lt;p>它的前两个参数分别是目的端和源端的文件描述符，后面两个参数是源端的偏移量和复制数据的长度，返回值是实际复制数据的长度。&lt;/p>
&lt;p>首先，它可以替代前面的 &lt;code>read()&lt;/code> 和 &lt;code>write()&lt;/code> 这两个系统调用，这样就可以减少一次系统调用，也就减少了 2 次上下文切换的开销。&lt;/p>
&lt;p>其次，该系统调用，可以直接把内核缓冲区里的数据拷贝到 socket 缓冲区里，不再拷贝到用户态，这样就只有 2 次上下文切换，和 3 次数据拷贝。如下图：&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/zl0fv1/1616167581761-10aa5962-487a-444d-9c3b-878f1a5f0d4d.png" alt="">&lt;/p>
&lt;p>但是这还不是真正的零拷贝技术，如果网卡支持 SG-DMA（&lt;em>The Scatter-Gather Direct Memory Access&lt;/em>）技术（和普通的 DMA 有所不同），我们可以进一步减少通过 CPU 把内核缓冲区里的数据拷贝到 socket 缓冲区的过程。&lt;/p>
&lt;p>你可以在你的 Linux 系统通过下面这个命令，查看网卡是否支持 scatter-gather 特性：&lt;/p>
&lt;pre>&lt;code>$ ethtool -k eth0 | grep scatter-gatherscatter-gather: on
&lt;/code>&lt;/pre>
&lt;p>1
Plain Text&lt;/p>
&lt;p>于是，从 Linux 内核 &lt;code>2.4&lt;/code> 版本开始起，对于支持网卡支持 SG-DMA 技术的情况下， &lt;code>sendfile()&lt;/code> 系统调用的过程发生了点变化，具体过程如下：&lt;/p>
&lt;ul>
&lt;li>第一步，通过 DMA 将磁盘上的数据拷贝到内核缓冲区里；&lt;/li>
&lt;li>第二步，缓冲区描述符和数据长度传到 socket 缓冲区，这样网卡的 SG-DMA 控制器就可以直接将内核缓存中的数据拷贝到网卡的缓冲区里，此过程不需要将数据从操作系统内核缓冲区拷贝到 socket 缓冲区中，这样就减少了一次数据拷贝；&lt;/li>
&lt;/ul>
&lt;p>所以，这个过程之中，只进行了 2 次数据拷贝，如下图：&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/zl0fv1/1616167581761-cd2da78d-0ce1-4048-ae1c-ec5d19830fc6.png" alt="">&lt;/p>
&lt;p>这就是所谓的&lt;strong>零拷贝（***&lt;strong>Zero-copy&lt;/strong>*&lt;/strong>）技术，因为我们没有在内存层面去拷贝数据，也就是说全程没有通过 CPU 来搬运数据，所有的数据都是通过 DMA 来进行传输的。**。&lt;/p>
&lt;p>零拷贝技术的文件传输方式相比传统文件传输的方式，减少了 2 次上下文切换和数据拷贝次数，&lt;strong>只需要 2 次上下文切换和数据拷贝次数，就可以完成文件的传输，而且 2 次的数据拷贝过程，都不需要通过 CPU，2 次都是由 DMA 来搬运。&lt;/strong>&lt;/p>
&lt;p>所以，总体来看，&lt;strong>零拷贝技术可以把文件传输的性能提高至少一倍以上&lt;/strong>。&lt;/p>
&lt;p>使用零拷贝技术的项目&lt;/p>
&lt;p>事实上，Kafka 这个开源项目，就利用了「零拷贝」技术，从而大幅提升了 I/O 的吞吐率，这也是 Kafka 在处理海量数据为什么这么快的原因之一。&lt;/p>
&lt;p>如果你追溯 Kafka 文件传输的代码，你会发现，最终它调用了 Java NIO 库里的 &lt;code>transferTo&lt;/code> 方法：&lt;/p>
&lt;pre>&lt;code>@Overridepublic long transferFrom(FileChannel fileChannel, long position, long count) throws IOException { return fileChannel.transferTo(position, count, socketChannel);}
&lt;/code>&lt;/pre>
&lt;p>1
Plain Text&lt;/p>
&lt;p>如果 Linux 系统支持 &lt;code>sendfile()&lt;/code> 系统调用，那么 &lt;code>transferTo()&lt;/code> 实际上最后就会使用到 &lt;code>sendfile()&lt;/code> 系统调用函数。曾经有大佬专门写过程序测试过，在同样的硬件条件下，传统文件传输和零拷拷贝文件传输的性能差异，你可以看到下面这张测试数据图，使用了零拷贝能够缩短 &lt;code>65%&lt;/code> 的时间，大幅度提升了机器传输数据的吞吐量。&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/zl0fv1/1616167581773-3ca39dfc-4c62-4827-a5f8-1ccd96ce7a88.png" alt="">&lt;/p>
&lt;p>数据来源于：&lt;a href="https://developer.ibm.com/articles/j-zerocopy/">https://developer.ibm.com/articles/j-zerocopy/&lt;/a>&lt;/p>
&lt;p>另外，Nginx 也支持零拷贝技术，一般默认是开启零拷贝技术，这样有利于提高文件传输的效率，是否开启零拷贝技术的配置如下：&lt;/p>
&lt;pre>&lt;code>http {... sendfile on...}
&lt;/code>&lt;/pre>
&lt;p>1
Plain Text&lt;/p>
&lt;p>sendfile 配置的具体意思:&lt;/p>
&lt;ul>
&lt;li>设置为 on 表示，使用零拷贝技术来传输文件：sendfile ，这样只需要 2 次上下文切换，和 2 次数据拷贝。&lt;/li>
&lt;li>设置为 off 表示，使用传统的文件传输技术：read + write，这时就需要 4 次上下文切换，和 4 次数据拷贝。&lt;/li>
&lt;/ul>
&lt;p>当然，要使用 sendfile，Linux 内核版本必须要 2.1 以上的版本。&lt;/p>
&lt;hr>
&lt;h3 id="pagecache-有什么作用">PageCache 有什么作用？&lt;/h3>
&lt;p>回顾前面说道文件传输过程，其中第一步都是先需要先把磁盘文件数据拷贝「内核缓冲区」里，这个「内核缓冲区」实际上是&lt;strong>磁盘高速缓存（***&lt;strong>PageCache&lt;/strong>*&lt;/strong>）**。&lt;/p>
&lt;p>由于零拷贝使用了 PageCache 技术，可以使得零拷贝进一步提升了性能，我们接下来看看 PageCache 是如何做到这一点的。&lt;/p>
&lt;p>读写磁盘相比读写内存的速度慢太多了，所以我们应该想办法把「读写磁盘」替换成「读写内存」。于是，我们会通过 DMA 把磁盘里的数据搬运到内存里，这样就可以用读内存替换读磁盘。&lt;/p>
&lt;p>但是，内存空间远比磁盘要小，内存注定只能拷贝磁盘里的一小部分数据。&lt;/p>
&lt;p>那问题来了，选择哪些磁盘数据拷贝到内存呢？&lt;/p>
&lt;p>我们都知道程序运行的时候，具有「局部性」，所以通常，刚被访问的数据在短时间内再次被访问的概率很高，于是我们可以用 &lt;strong>PageCache 来缓存最近被访问的数据&lt;/strong>，当空间不足时淘汰最久未被访问的缓存。&lt;/p>
&lt;p>所以，读磁盘数据的时候，优先在 PageCache 找，如果数据存在则可以直接返回；如果没有，则从磁盘中读取，然后缓存 PageCache 中。&lt;/p>
&lt;p>还有一点，读取磁盘数据的时候，需要找到数据所在的位置，但是对于机械磁盘来说，就是通过磁头旋转到数据所在的扇区，再开始「顺序」读取数据，但是旋转磁头这个物理动作是非常耗时的，为了降低它的影响，&lt;strong>PageCache 使用了「预读功能」&lt;/strong>。&lt;/p>
&lt;p>比如，假设 read 方法每次只会读 &lt;code>32 KB&lt;/code> 的字节，虽然 read 刚开始只会读 0 ～ 32 KB 的字节，但内核会把其后面的 32 ～ 64 KB 也读取到 PageCache，这样后面读取 32 ～ 64 KB 的成本就很低，如果在 32 ～ 64 KB 淘汰出 PageCache 前，进程读取到它了，收益就非常大。&lt;/p>
&lt;p>所以，PageCache 的优点主要是两个：&lt;/p>
&lt;ul>
&lt;li>缓存最近被访问的数据；&lt;/li>
&lt;li>预读功能；&lt;/li>
&lt;/ul>
&lt;p>这两个做法，将大大提高读写磁盘的性能。&lt;/p>
&lt;p>&lt;strong>但是，在传输大文件（GB 级别的文件）的时候，PageCache 会不起作用，那就白白浪费 DMA 多做的一次数据拷贝，造成性能的降低，即使使用了 PageCache 的零拷贝也会损失性能&lt;/strong>&lt;/p>
&lt;p>这是因为如果你有很多 GB 级别文件需要传输，每当用户访问这些大文件的时候，内核就会把它们载入 PageCache 中，于是 PageCache 空间很快被这些大文件占满。&lt;/p>
&lt;p>另外，由于文件太大，可能某些部分的文件数据被再次访问的概率比较低，这样就会带来 2 个问题：&lt;/p>
&lt;ul>
&lt;li>PageCache 由于长时间被大文件占据，其他「热点」的小文件可能就无法充分使用到 PageCache，于是这样磁盘读写的性能就会下降了；&lt;/li>
&lt;li>PageCache 中的大文件数据，由于没有享受到缓存带来的好处，但却耗费 DMA 多拷贝到 PageCache 一次；&lt;/li>
&lt;/ul>
&lt;p>所以，针对大文件的传输，不应该使用 PageCache，也就是说不应该使用零拷贝技术，因为可能由于 PageCache 被大文件占据，而导致「热点」小文件无法利用到 PageCache，这样在高并发的环境下，会带来严重的性能问题。&lt;/p>
&lt;hr>
&lt;h3 id="大文件传输用什么方式实现">大文件传输用什么方式实现？&lt;/h3>
&lt;p>那针对大文件的传输，我们应该使用什么方式呢？&lt;/p>
&lt;p>我们先来看看最初的例子，当调用 read 方法读取文件时，进程实际上会阻塞在 read 方法调用，因为要等待磁盘数据的返回，如下图：&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/zl0fv1/1616167581758-1e058506-1c0b-4bad-ae68-9846cd0f3016.png" alt="">&lt;/p>
&lt;p>具体过程：&lt;/p>
&lt;ul>
&lt;li>当调用 read 方法时，会阻塞着，此时内核会向磁盘发起 I/O 请求，磁盘收到请求后，便会寻址，当磁盘数据准备好后，就会向内核发起 I/O 中断，告知内核磁盘数据已经准备好；&lt;/li>
&lt;li>内核收到 I/O 中断后，就将数据从磁盘控制器缓冲区拷贝到 PageCache 里；&lt;/li>
&lt;li>最后，内核再把 PageCache 中的数据拷贝到用户缓冲区，于是 read 调用就正常返回了。&lt;/li>
&lt;/ul>
&lt;p>对于阻塞的问题，可以用异步 I/O 来解决，它工作方式如下图：&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/zl0fv1/1616167581774-bf45125c-8de0-493f-892e-1b57b4b150b9.png" alt="">&lt;/p>
&lt;p>它把读操作分为两部分：&lt;/p>
&lt;ul>
&lt;li>前半部分，内核向磁盘发起读请求，但是可以&lt;strong>不等待数据就位就可以返回&lt;/strong>，于是进程此时可以处理其他任务；&lt;/li>
&lt;li>后半部分，当内核将磁盘中的数据拷贝到进程缓冲区后，进程将接收到内核的&lt;strong>通知&lt;/strong>，再去处理数据；&lt;/li>
&lt;/ul>
&lt;p>而且，我们可以发现，异步 I/O 并没有涉及到 PageCache，所以使用异步 I/O 就意味着要绕开 PageCache。&lt;/p>
&lt;p>绕开 PageCache 的 I/O 叫直接 I/O，使用 PageCache 的 I/O 则叫缓存 I/O。通常，对于磁盘，异步 I/O 只支持直接 I/O。&lt;/p>
&lt;p>前面也提到，大文件的传输不应该使用 PageCache，因为可能由于 PageCache 被大文件占据，而导致「热点」小文件无法利用到 PageCache。&lt;/p>
&lt;p>于是，&lt;strong>在高并发的场景下，针对大文件的传输的方式，应该使用「异步 I/O + 直接 I/O」来替代零拷贝技术&lt;/strong>。&lt;/p>
&lt;p>直接 I/O 应用场景常见的两种：&lt;/p>
&lt;ul>
&lt;li>应用程序已经实现了磁盘数据的缓存，那么可以不需要 PageCache 再次缓存，减少额外的性能损耗。在 MySQL 数据库中，可以通过参数设置开启直接 I/O，默认是不开启；&lt;/li>
&lt;li>传输大文件的时候，由于大文件难以命中 PageCache 缓存，而且会占满 PageCache 导致「热点」文件无法充分利用缓存，从而增大了性能开销，因此，这时应该使用直接 I/O。&lt;/li>
&lt;/ul>
&lt;p>另外，由于直接 I/O 绕过了 PageCache，就无法享受内核的这两点的优化：&lt;/p>
&lt;ul>
&lt;li>内核的 I/O 调度算法会缓存尽可能多的 I/O 请求在 PageCache 中，最后「&lt;strong>合并&lt;/strong>」成一个更大的 I/O 请求再发给磁盘，这样做是为了减少磁盘的寻址操作；&lt;/li>
&lt;li>内核也会「&lt;strong>预读&lt;/strong>」后续的 I/O 请求放在 PageCache 中，一样是为了减少对磁盘的操作；&lt;/li>
&lt;/ul>
&lt;p>于是，传输大文件的时候，使用「异步 I/O + 直接 I/O」了，就可以无阻塞地读取文件了。&lt;/p>
&lt;p>所以，传输文件的时候，我们要根据文件的大小来使用不同的方式：&lt;/p>
&lt;ul>
&lt;li>传输大文件的时候，使用「异步 I/O + 直接 I/O」；&lt;/li>
&lt;li>传输小文件的时候，则使用「零拷贝技术」；&lt;/li>
&lt;/ul>
&lt;p>在 nginx 中，我们可以用如下配置，来根据文件的大小来使用不同的方式：&lt;/p>
&lt;pre>&lt;code>location /video/ { sendfile on; aio on; directio 1024m; }
&lt;/code>&lt;/pre>
&lt;p>1
Plain Text&lt;/p>
&lt;p>当文件大小大于 &lt;code>directio&lt;/code> 值后，使用「异步 I/O + 直接 I/O」，否则使用「零拷贝技术」。&lt;/p>
&lt;hr>
&lt;h3 id="总结">总结&lt;/h3>
&lt;p>早期 I/O 操作，内存与磁盘的数据传输的工作都是由 CPU 完成的，而此时 CPU 不能执行其他任务，会特别浪费 CPU 资源。&lt;/p>
&lt;p>于是，为了解决这一问题，DMA 技术就出现了，每个 I/O 设备都有自己的 DMA 控制器，通过这个 DMA 控制器，CPU 只需要告诉 DMA 控制器，我们要传输什么数据，从哪里来，到哪里去，就可以放心离开了。后续的实际数据传输工作，都会由 DMA 控制器来完成，CPU 不需要参与数据传输的工作。&lt;/p>
&lt;p>传统 IO 的工作方式，从硬盘读取数据，然后再通过网卡向外发送，我们需要进行 4 上下文切换，和 4 次数据拷贝，其中 2 次数据拷贝发生在内存里的缓冲区和对应的硬件设备之间，这个是由 DMA 完成，另外 2 次则发生在内核态和用户态之间，这个数据搬移工作是由 CPU 完成的。&lt;/p>
&lt;p>为了提高文件传输的性能，于是就出现了零拷贝技术，它通过一次系统调用（&lt;code>sendfile&lt;/code> 方法）合并了磁盘读取与网络发送两个操作，降低了上下文切换次数。另外，拷贝数据都是发生在内核中的，天然就降低了数据拷贝的次数。&lt;/p>
&lt;p>Kafka 和 Nginx 都有实现零拷贝技术，这将大大提高文件传输的性能。&lt;/p>
&lt;p>零拷贝技术是基于 PageCache 的，PageCache 会缓存最近访问的数据，提升了访问缓存数据的性能，同时，为了解决机械硬盘寻址慢的问题，它还协助 I/O 调度算法实现了 IO 合并与预读，这也是顺序读比随机读性能好的原因。这些优势，进一步提升了零拷贝的性能。&lt;/p>
&lt;p>需要注意的是，零拷贝技术是不允许进程对文件内容作进一步的加工的，比如压缩数据再发送。&lt;/p>
&lt;p>另外，当传输大文件时，不能使用零拷贝，因为可能由于 PageCache 被大文件占据，而导致「热点」小文件无法利用到 PageCache，并且大文件的缓存命中率不高，这时就需要使用「异步 IO + 直接 IO 」的方式。&lt;/p>
&lt;p>在 Nginx 里，可以通过配置，设定一个文件大小阈值，针对大文件使用异步 IO 和直接 IO，而对小文件使用零拷贝。&lt;/p>
&lt;hr>
&lt;h2 id="絮叨">絮叨&lt;/h2>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/zl0fv1/1616167581788-f2a0299b-a76a-4d58-b228-f6d81888f5fb.png" alt="">&lt;/p>
&lt;p>&lt;strong>大家好，我是小林，一个专为大家图解的工具人，如果觉得文章对你有帮助，欢迎分享给你的朋友，这对小林非常重要，谢谢你们，我们下次见！&lt;/strong>&lt;/p></description></item></channel></rss>