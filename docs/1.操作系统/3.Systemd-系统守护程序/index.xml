<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>断念梦 – 3.Systemd 系统守护程序</title><link>https://desistdaydream.github.io/docs/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/3.Systemd-%E7%B3%BB%E7%BB%9F%E5%AE%88%E6%8A%A4%E7%A8%8B%E5%BA%8F/</link><description>Recent content in 3.Systemd 系统守护程序 on 断念梦</description><generator>Hugo -- gohugo.io</generator><atom:link href="https://desistdaydream.github.io/docs/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/3.Systemd-%E7%B3%BB%E7%BB%9F%E5%AE%88%E6%8A%A4%E7%A8%8B%E5%BA%8F/index.xml" rel="self" type="application/rss+xml"/><item><title>Docs: systemctl 命令行工具</title><link>https://desistdaydream.github.io/docs/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/3.Systemd-%E7%B3%BB%E7%BB%9F%E5%AE%88%E6%8A%A4%E7%A8%8B%E5%BA%8F/systemctl-%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%B7%A5%E5%85%B7/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/3.Systemd-%E7%B3%BB%E7%BB%9F%E5%AE%88%E6%8A%A4%E7%A8%8B%E5%BA%8F/systemctl-%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%B7%A5%E5%85%B7/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://man7.org/linux/man-pages/man1/systemctl.1.html">Manual(手册)，systemctl(1)&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>systemctl 命令用来对整个“systemd”的系统和服务进行管理&lt;/p>
&lt;h1 id="syntax语法">Syntax(语法)&lt;/h1>
&lt;p>&lt;strong>systemctl [OPTIONS] COMMAND [UNIT&amp;hellip;]&lt;/strong>
UNIT 为 Unit 名称，如果指定了 UNIT 则只对这个 Unit 执行 COMMAND，如果不指定则对全局 Unit 进行操作&lt;/p>
&lt;h2 id="options">OPTIONS&lt;/h2>
&lt;ul>
&lt;li>&lt;strong>-t&lt;/strong> # 对指定类型的 unit 进行操作&lt;/li>
&lt;li>&lt;strong>&amp;ndash;all&lt;/strong> #&lt;/li>
&lt;li>&lt;strong>&amp;ndash;now&lt;/strong> # 该选项可以与 enable、disable、mask 命令一起使用。
&lt;ul>
&lt;li>与 enable 命令一起使用时，将同时启动该 Unit&lt;/li>
&lt;li>与 disable 和 mask 命令一起使用时，将同时停止该 Unit、&lt;/li>
&lt;li>注意：只有当 enable 或 disable 命令成功时，才会执行启动或停止操作。加了该选项就类似于执行了 &lt;code>systemctl enable UNIT &amp;amp;&amp;amp; systemctl start UNIT&lt;/code> 命令&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h2 id="command-分类">COMMAND 分类&lt;/h2>
&lt;ul>
&lt;li>&lt;a href="#Unit%20Command">Unit Command&lt;/a> # 对 unit 执行操作的命令&lt;/li>
&lt;li>&lt;a href="#Unit%20File%20Commands">Unit File Commands&lt;/a> # 对 Unit 文件执行操作的命令&lt;/li>
&lt;li>Machine Commands&lt;/li>
&lt;li>Job Commands&lt;/li>
&lt;li>Snapshot Commands&lt;/li>
&lt;li>Environment Commands&lt;/li>
&lt;li>&lt;a href="#Manager%20Lifecycle%20Commands">Manager Lifecycle Commands&lt;/a> # 生命周期管理器的命令&lt;/li>
&lt;li>System Commands&lt;/li>
&lt;/ul>
&lt;p>注意：OBJECT 可以使用 PATTERN(模式)来进行匹配，i.e.使用正则表达式来通过关键字查找 unit 来显示包含这些关键字的 unit 的状态&lt;/p>
&lt;h1 id="unit-command">Unit Command&lt;/h1>
&lt;h2 id="list-units">list-units&lt;/h2>
&lt;p>&lt;strong>默认命令&lt;/strong>，当 COMMAND 为空时，默认执行该命令列出已加载(已启动)的 UNIT&lt;/p>
&lt;h3 id="syntax语法-1">Syntax(语法)&lt;/h3>
&lt;p>&lt;strong>systemctl list-units [PATTERN]&lt;/strong>&lt;/p>
&lt;h3 id="example">EXAMPLE&lt;/h3>
&lt;ul>
&lt;li>systemctl -t service # 查看所有 service unit 的信息，systemctl 命令默认列出所有 unit&lt;/li>
&lt;li>systemctl list-units &amp;ndash;failed # 列出所有失败的 unit&lt;/li>
&lt;/ul>
&lt;p>list-sockets [PATTERN] List loaded sockets ordered by address&lt;/p>
&lt;p>list-timers [PATTERN] List loaded timers ordered by next elapse&lt;/p>
&lt;p>{start | stop | restart} UnitName # 立刻启动或者关闭或者重启某个 Unit&lt;/p>
&lt;h2 id="reload-name">reload NAME&lt;/h2>
&lt;p>不关闭 UNIT 的情况下重新载入配置文件，让配置生效，只重新加载.conf 类的文件&lt;/p>
&lt;p>try-restart NAME&amp;hellip; Restart one or more units if active&lt;/p>
&lt;p>reload-or-restart NAME&amp;hellip; Reload one or more units if possible, otherwise start or restart&lt;/p>
&lt;p>reload-or-try-restart NAME&amp;hellip; Reload one or more units if possible,otherwise restart if active&lt;/p>
&lt;h2 id="isolate-name">isolate NAME&lt;/h2>
&lt;p>启动一个 unit 并关闭其他的。如果指定的 Unit 没写扩展名，则默认 target。&lt;/p>
&lt;p>这个命令的作用类似于老的 init 系统中修改运行级别的效果&lt;/p>
&lt;p>EXAMPLE&lt;/p>
&lt;ul>
&lt;li>systemctl isolate multi-user.target # 启动 multi-user.target 这个 unit 并关闭其他(类似于切换成纯文本运行方式)&lt;/li>
&lt;li>systemctl isolate graphical.target # 类似于切换成图形模式&lt;/li>
&lt;/ul>
&lt;p>kill NAME&amp;hellip; Send signal to processes of a unit&lt;/p>
&lt;p>is-active PATTERN&amp;hellip; Check whether units are active&lt;/p>
&lt;p>is-failed PATTERN&amp;hellip; Check whether units are failed&lt;/p>
&lt;h2 id="status-patternpid">status [PATTERN|PID]&lt;/h2>
&lt;p>显示整个系统的 Unit 状态信息包括树状关联信息,如果指定了 &lt;code>[]&lt;/code> 中的内容,则显示指定 Unit 运行时的状态信息&lt;/p>
&lt;p>EXAMPLE&lt;/p>
&lt;ul>
&lt;li>systemctl status ssh.service # 查看 ssh.service 这个 unit 的状态
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/iqtd0r/1616167368492-74c581c3-e6a6-48e6-b6db-49e0fd799a63.jpeg" alt="">&lt;/li>
&lt;/ul>
&lt;p>show [PATTERN&amp;hellip;|JOB&amp;hellip;] Show properties of one or more units/jobs or the manager&lt;/p>
&lt;h2 id="cat-pattern">cat PATTERN&lt;/h2>
&lt;p>显示一个或多个 unit 的文件及其内容&lt;/p>
&lt;p>查看 sshd 这个服务的配置文件路径以及配置文件的内容，效果如下&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>~&lt;span style="color:#f92672">]&lt;/span>&lt;span style="color:#75715e"># systemctl cat sshd&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># /lib/systemd/system/ssh.service&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">[&lt;/span>Unit&lt;span style="color:#f92672">]&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Description&lt;span style="color:#f92672">=&lt;/span>OpenBSD Secure Shell server
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Documentation&lt;span style="color:#f92672">=&lt;/span>man:sshd&lt;span style="color:#f92672">(&lt;/span>8&lt;span style="color:#f92672">)&lt;/span> man:sshd_config&lt;span style="color:#f92672">(&lt;/span>5&lt;span style="color:#f92672">)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>After&lt;span style="color:#f92672">=&lt;/span>network.target auditd.service
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>ConditionPathExists&lt;span style="color:#f92672">=&lt;/span>!/etc/ssh/sshd_not_to_be_run
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">[&lt;/span>Service&lt;span style="color:#f92672">]&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>EnvironmentFile&lt;span style="color:#f92672">=&lt;/span>-/etc/default/ssh
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>ExecStartPre&lt;span style="color:#f92672">=&lt;/span>/usr/sbin/sshd -t
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>ExecStart&lt;span style="color:#f92672">=&lt;/span>/usr/sbin/sshd -D $SSHD_OPTS
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>ExecReload&lt;span style="color:#f92672">=&lt;/span>/usr/sbin/sshd -t
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>ExecReload&lt;span style="color:#f92672">=&lt;/span>/bin/kill -HUP $MAINPID
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>KillMode&lt;span style="color:#f92672">=&lt;/span>process
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Restart&lt;span style="color:#f92672">=&lt;/span>on-failure
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>RestartPreventExitStatus&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">255&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Type&lt;span style="color:#f92672">=&lt;/span>notify
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>RuntimeDirectory&lt;span style="color:#f92672">=&lt;/span>sshd
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>RuntimeDirectoryMode&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">0755&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">[&lt;/span>Install&lt;span style="color:#f92672">]&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>WantedBy&lt;span style="color:#f92672">=&lt;/span>multi-user.target
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Alias&lt;span style="color:#f92672">=&lt;/span>sshd.service
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>set-property NAME ASSIGNMENT&amp;hellip; Sets one or more properties of a unit&lt;/p>
&lt;p>help PATTERN&amp;hellip;|PID&amp;hellip; Show manual for one or more units&lt;/p>
&lt;p>reset-failed [PATTERN&amp;hellip;] Reset failed state for all, one, or more units&lt;/p>
&lt;h2 id="list-dependencies">list-dependencies&lt;/h2>
&lt;p>列出服务的依赖关系，树状显示。默认列出 default.target 的依赖树，即 default.target &lt;strong>被哪些服务依赖&lt;/strong>。&lt;/p>
&lt;h3 id="syntax语法-2">Syntax(语法)&lt;/h3>
&lt;p>&lt;strong>systemctl list-dependencies [OPTIONS] [UnitName]&lt;/strong>&lt;/p>
&lt;p>可以指定 Unit，以列出该 UNIT &lt;strong>被哪些服务依赖&lt;/strong>&lt;/p>
&lt;p>&lt;strong>OPTIONS&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>&lt;strong>&amp;ndash;reverse&lt;/strong> # 反向追踪，列出该 UNIT &lt;strong>依赖于哪些服务&lt;/strong>。即该 UNIT 可以给谁提供依赖，即被谁需要，即启动哪些 UNIT 需要以这个 UNIT 启动为前提&lt;/li>
&lt;/ul>
&lt;h3 id="example-1">EXAMPLE&lt;/h3>
&lt;p>列出 sshd.service 这个 unit 可以给谁提供依赖&lt;/p>
&lt;ul>
&lt;li>systemctl list-dependencies sshd.service &amp;ndash;reverse&lt;/li>
&lt;/ul>
&lt;h1 id="unit-file-commands">Unit File Commands&lt;/h1>
&lt;h2 id="list-unit-files-pattern">list-unit-files [PATTERN&amp;hellip;]&lt;/h2>
&lt;p>列出所有已经安装的 Unit 的配置文件。（目录为/usr/lib/systemd/system/下的所有文件）&lt;/p>
&lt;h2 id="enabledisable-name">{enable|disable} NAME&lt;/h2>
&lt;p>启用或禁用一个或多个 Unit 文件&lt;/p>
&lt;p>reenable NAME&amp;hellip; Reenable one or more unit files&lt;/p>
&lt;p>preset NAME&amp;hellip; Enable/disable one or more unit files based on preset configuration&lt;/p>
&lt;p>preset-all Enable/disable all unit files based on preset configuration&lt;/p>
&lt;p>is-enabled NAME&amp;hellip; Check whether unit files are enabled&lt;/p>
&lt;p>mask NAME&amp;hellip; Mask one or more units&lt;/p>
&lt;p>unmask NAME&amp;hellip; Unmask one or more units&lt;/p>
&lt;p>link PATH&amp;hellip; Link one or more units files into the search path&lt;/p>
&lt;p>add-wants TARGET NAME&amp;hellip; Add &amp;lsquo;Wants&amp;rsquo; dependency for the target on specified one or more units&lt;/p>
&lt;p>add-requires TARGET NAME&amp;hellip; Add &amp;lsquo;Requires&amp;rsquo; dependency for the target on specified one or more units&lt;/p>
&lt;p>edit NAME&amp;hellip; Edit one or more unit files&lt;/p>
&lt;h2 id="get-default--获取-defaulttarget-的名字">get-default # 获取 default.target 的名字&lt;/h2>
&lt;p>获取引导进入的 default.target。获取的 TargetUnit 名字是(会通过符号链接的方式)default.target 的别名
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/iqtd0r/1616167368520-867ed609-6df3-41f4-8a42-48d7b7497340.jpeg" alt="">&lt;/p>
&lt;h2 id="set-default-name--设置-defaulttarget">set-default NAME # 设置 default.target&lt;/h2>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/iqtd0r/1616167368506-ab34c24b-0f8f-4a0f-8618-8d6ad5a75673.jpeg" alt="">
设置引导进入的 default.target。这个设置(会通过符号链接的方式)会用给定的 TargetUnit 给 default.target 起一个别名。相当于给一个 target 类型的 unit 建立了一个名为 default.target 的软链接&lt;/p>
&lt;ol>
&lt;li>EXAMPLE
&lt;ol>
&lt;li>systemctl set-defult graphical.target # 给 graphical.target 创建一个名为 default.target 的软连接到 /etc/systemd/system/ 目录下&lt;/li>
&lt;/ol>
&lt;/li>
&lt;/ol>
&lt;h1 id="machine-commands">Machine Commands&lt;/h1>
&lt;p>list-machines [PATTERN&amp;hellip;] List local containers and host&lt;/p>
&lt;h1 id="job-commands">Job Commands&lt;/h1>
&lt;p>list-jobs [PATTERN&amp;hellip;] List jobs&lt;/p>
&lt;p>cancel [JOB&amp;hellip;] Cancel all, one, or more jobs&lt;/p>
&lt;h1 id="snapshot-commands">Snapshot Commands&lt;/h1>
&lt;p>snapshot [NAME] Create a snapshot&lt;/p>
&lt;p>delete NAME&amp;hellip; Remove one or more snapshots&lt;/p>
&lt;h1 id="environment-commands">Environment Commands&lt;/h1>
&lt;p>show-environment Dump environment&lt;/p>
&lt;p>set-environment NAME=VALUE&amp;hellip; Set one or more environment variables&lt;/p>
&lt;p>unset-environment NAME&amp;hellip; Unset one or more environment variables&lt;/p>
&lt;p>import-environment [NAME&amp;hellip;] Import all or some environment variables&lt;/p>
&lt;h1 id="manager-lifecycle-commands">Manager Lifecycle Commands&lt;/h1>
&lt;h2 id="daemon-reload">daemon-reload&lt;/h2>
&lt;p>重新加载所有 daemon 的配置文件，包括.service 等文件一起重新加载&lt;/p>
&lt;p>daemon-reexec Reexecute systemd manager&lt;/p>
&lt;h1 id="system-commands">System Commands&lt;/h1>
&lt;p>is-system-running Check whether system is fully running&lt;/p>
&lt;p>default Enter system default mode&lt;/p>
&lt;p>rescue Enter system rescue mode&lt;/p>
&lt;p>emergency Enter system emergency mode&lt;/p>
&lt;p>halt Shut down and halt the system&lt;/p>
&lt;p>poweroff Shut down and power-off the system&lt;/p>
&lt;p>reboot [ARG] Shut down and reboot the system&lt;/p>
&lt;p>kexec Shut down and reboot the system with kexec&lt;/p>
&lt;p>exit Request user instance exit&lt;/p>
&lt;p>switch-root ROOT [INIT] Change to a different root file system&lt;/p>
&lt;p>suspend Suspend the system&lt;/p>
&lt;p>hibernate Hibernate the system&lt;/p>
&lt;p>hybrid-sleep Hibernate and suspend the system&lt;/p></description></item><item><title>Docs: Systemd 运行流程</title><link>https://desistdaydream.github.io/docs/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/3.Systemd-%E7%B3%BB%E7%BB%9F%E5%AE%88%E6%8A%A4%E7%A8%8B%E5%BA%8F/Systemd-%E8%BF%90%E8%A1%8C%E6%B5%81%E7%A8%8B/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/3.Systemd-%E7%B3%BB%E7%BB%9F%E5%AE%88%E6%8A%A4%E7%A8%8B%E5%BA%8F/Systemd-%E8%BF%90%E8%A1%8C%E6%B5%81%E7%A8%8B/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;/blockquote>
&lt;h1 id="systemd-运行">Systemd 运行&lt;/h1>
&lt;p>这里以 CentOS 7 版本为例&lt;/p>
&lt;h3 id="确认系统运行级别">确认系统运行级别&lt;/h3>
&lt;p>systemd 执行的第一个目标是 /etc/systemd/system/default.target，是一个软链接，该文件决定了老版本称为 “运行级别” 的一种行为&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">[&lt;/span>root@common-centos-test ~&lt;span style="color:#f92672">]&lt;/span>&lt;span style="color:#75715e"># ll /etc/systemd/system/default.target&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>lrwxrwxrwx. &lt;span style="color:#ae81ff">1&lt;/span> root root &lt;span style="color:#ae81ff">37&lt;/span> Oct &lt;span style="color:#ae81ff">10&lt;/span> &lt;span style="color:#ae81ff">2020&lt;/span> /etc/systemd/system/default.target -&amp;gt; /lib/systemd/system/multi-user.target
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>如果想要更改系统启动级别，可以使用 systemctl set-defult XXXXX 命令来修改默认启动级别&lt;/p>
&lt;h3 id="启动-multi-usertaget">启动 multi-user.taget&lt;/h3>
&lt;p>multi-user.target 文件内容如下：&lt;/p>
&lt;pre>&lt;code>[root@common-centos-test ~]# cat /usr/lib/systemd/system/multi-user.target
[Unit]
Description=Multi-User System
Documentation=man:systemd.special(7)
Requires=basic.target
Conflicts=rescue.service rescue.target
After=basic.target rescue.service rescue.target
AllowIsolate=yes
&lt;/code>&lt;/pre>
&lt;p>从 multi-user.target 中获取到下一步需要启动的服务。&lt;/p>
&lt;ul>
&lt;li>根据 Requires 指令，需要先启动 basic.target 关联的服务&lt;/li>
&lt;li>启动 /usr/lib/systemd/system/multi-user.target.wants/ 和 /etc/systemd/system/multi-user.target.wants/ 目录中的服务&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">[&lt;/span>root@common-centos-test ~&lt;span style="color:#f92672">]&lt;/span>&lt;span style="color:#75715e"># ls /usr/lib/systemd/system/multi-user.target.wants/&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>dbus.service getty.target plymouth-quit.service plymouth-quit-wait.service systemd-ask-password-wall.path systemd-logind.service systemd-update-utmp-runlevel.service systemd-user-sessions.service
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">[&lt;/span>root@common-centos-test ~&lt;span style="color:#f92672">]&lt;/span>&lt;span style="color:#75715e"># ls /etc/systemd/system/multi-user.target.wants/&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>auditd.service chronyd.service crond.service firewalld.service irqbalance.service kdump.service NetworkManager.service remote-fs.target rhel-configure.service rsyslog.service sshd.service sysstat.service tuned.service
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="启动-basictarget">启动 basic.target&lt;/h3>
&lt;p>basic.target 文件内容如下：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">[&lt;/span>root@common-centos-test ~&lt;span style="color:#f92672">]&lt;/span>&lt;span style="color:#75715e"># cat /usr/lib/systemd/system/basic.target&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">[&lt;/span>Unit&lt;span style="color:#f92672">]&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Description&lt;span style="color:#f92672">=&lt;/span>Basic System
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Documentation&lt;span style="color:#f92672">=&lt;/span>man:systemd.special&lt;span style="color:#f92672">(&lt;/span>7&lt;span style="color:#f92672">)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Requires&lt;span style="color:#f92672">=&lt;/span>sysinit.target
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>After&lt;span style="color:#f92672">=&lt;/span>sysinit.target
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Wants&lt;span style="color:#f92672">=&lt;/span>sockets.target timers.target paths.target slices.target
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>After&lt;span style="color:#f92672">=&lt;/span>sockets.target paths.target slices.target
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>从 basic.target 中获取下一步需要启动的服务。&lt;/p>
&lt;ul>
&lt;li>根据 Requires 指令，需要先启动 sysinit.target 关联的服务。&lt;/li>
&lt;li>根据 Wants 和 After 指令，启动 sockets.target、timers.target、paths.target、slices.target 下关联的服务&lt;/li>
&lt;li>启动 /etc/systemd/system/basic.target.wants/ 和 /usr/lib/systemd/system/basic.target.wants/ 目录中的服务。&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">[&lt;/span>root@common-centos-test ~&lt;span style="color:#f92672">]&lt;/span>&lt;span style="color:#75715e"># ls /etc/systemd/system/basic.target.wants/&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>microcode.service rhel-dmesg.service
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">[&lt;/span>root@common-centos-test ~&lt;span style="color:#f92672">]&lt;/span>&lt;span style="color:#75715e"># ls /usr/lib/systemd/system/basic.target.wants/&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>selinux-policy-migrate-local-changes@targeted.service
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="启动-sysinittarget">启动 sysinit.target&lt;/h3>
&lt;p>sysinit.target 文件内容如下：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">[&lt;/span>root@common-centos-test ~&lt;span style="color:#f92672">]&lt;/span>&lt;span style="color:#75715e"># cat /usr/lib/systemd/system/sysinit.target&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">[&lt;/span>Unit&lt;span style="color:#f92672">]&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Description&lt;span style="color:#f92672">=&lt;/span>System Initialization
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Documentation&lt;span style="color:#f92672">=&lt;/span>man:systemd.special&lt;span style="color:#f92672">(&lt;/span>7&lt;span style="color:#f92672">)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Conflicts&lt;span style="color:#f92672">=&lt;/span>emergency.service emergency.target
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Wants&lt;span style="color:#f92672">=&lt;/span>local-fs.target swap.target
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>After&lt;span style="color:#f92672">=&lt;/span>local-fs.target swap.target emergency.service emergency.target
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>此时没有 Requires 指令了，也就是从该 Unit 开始，同时启动上述所有已经关联到的服务。sysinit.target 会启动重要的系统服务例如系统挂载，内存交换空间和设备，内核补充选项等等。&lt;/p>
&lt;p>sysinit.target 将会启动如下服务&lt;/p>
&lt;ul>
&lt;li>loacl-fs.target 关联服务&lt;/li>
&lt;li>swap.target 关联服务&lt;/li>
&lt;li>emergency.service 服务 和 emergency.target 关联服务&lt;/li>
&lt;li>/etc/systemd/system/sysinit.target.wants/ 与 /usr/lib/systemd/system/sysinit.target.wants/ 目录中的服务&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">[&lt;/span>root@common-centos-test ~&lt;span style="color:#f92672">]&lt;/span>&lt;span style="color:#75715e"># ls /etc/systemd/system/sysinit.target.wants/&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>lvm2-lvmetad.socket lvm2-lvmpolld.socket lvm2-monitor.service rhel-autorelabel-mark.service rhel-autorelabel.service rhel-domainname.service rhel-import-state.service rhel-loadmodules.service
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">[&lt;/span>root@common-centos-test ~&lt;span style="color:#f92672">]&lt;/span>&lt;span style="color:#75715e"># ls /usr/lib/systemd/system/sysinit.target.wants/&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>cryptsetup.target plymouth-read-write.service sys-kernel-config.mount systemd-firstboot.service systemd-journal-flush.service systemd-sysctl.service systemd-udev-trigger.service
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>dev-hugepages.mount plymouth-start.service sys-kernel-debug.mount systemd-hwdb-update.service systemd-machine-id-commit.service systemd-tmpfiles-setup-dev.service systemd-update-done.service
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>dev-mqueue.mount proc-sys-fs-binfmt_misc.automount systemd-ask-password-console.path systemd-journal-catalog-update.service systemd-modules-load.service systemd-tmpfiles-setup.service systemd-update-utmp.service
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>kmod-static-nodes.service sys-fs-fuse-connections.mount systemd-binfmt.service systemd-journald.service systemd-random-seed.service systemd-udevd.service systemd-vconsole-setup.service
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="启动-local-fstarget-与-swaptarget-关联服务">启动 local-fs.target 与 swap.target 关联服务&lt;/h3>
&lt;p>local-fs.target 文件内容如下：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">[&lt;/span>root@common-centos-test ~&lt;span style="color:#f92672">]&lt;/span>&lt;span style="color:#75715e"># cat /usr/lib/systemd/system/local-fs.target&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">[&lt;/span>Unit&lt;span style="color:#f92672">]&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Description&lt;span style="color:#f92672">=&lt;/span>Local File Systems
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Documentation&lt;span style="color:#f92672">=&lt;/span>man:systemd.special&lt;span style="color:#f92672">(&lt;/span>7&lt;span style="color:#f92672">)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>DefaultDependencies&lt;span style="color:#f92672">=&lt;/span>no
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Conflicts&lt;span style="color:#f92672">=&lt;/span>shutdown.target
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>After&lt;span style="color:#f92672">=&lt;/span>local-fs-pre.target
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>OnFailure&lt;span style="color:#f92672">=&lt;/span>emergency.target
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>OnFailureJobMode&lt;span style="color:#f92672">=&lt;/span>replace-irreversibly
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>local-fs.target 不会启动用户相关服务，它只处理底层核心服务，这个 target 会根据 /etc/fstab 来执行相关磁盘挂载操作。它通过如下一个目录决定哪些 Unit 会被启动。&lt;/p>
&lt;ul>
&lt;li>/usr/lib/systemd/system/local-fs.target.wants/&lt;/li>
&lt;/ul>
&lt;p>swap.target 文件内容如下：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">[&lt;/span>root@common-centos-test ~&lt;span style="color:#f92672">]&lt;/span>&lt;span style="color:#75715e"># cat /usr/lib/systemd/system/swap.target&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">[&lt;/span>Unit&lt;span style="color:#f92672">]&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Description&lt;span style="color:#f92672">=&lt;/span>Swap
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Documentation&lt;span style="color:#f92672">=&lt;/span>man:systemd.special&lt;span style="color:#f92672">(&lt;/span>7&lt;span style="color:#f92672">)&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="总结">总结&lt;/h2>
&lt;p>虽然 systemd 的引用 target 的顺序如上，但是真正的启动顺序为从下到上，所以可以通过设置 default.target 文件来确定开机后默认的登录级别。其中管理单元可以并行启动，从而使效率大大提高。同时 Systemd 是向下兼容 System V 的。&lt;/p>
&lt;p>具体顺序应该如下：&lt;/p>
&lt;ol>
&lt;li>**local-s.target + swap.target **# 这两个 target 主要在挂载本机 /etc/fstab 里面所规范的文件系统与相关的内存交换空间。&lt;/li>
&lt;li>&lt;strong>sysinit.target&lt;/strong> # 这个 target 主要在侦测硬件,载入所需要的核心模块等动作。核心所侦测到的各硬件设备，会被记录在 /proc/ 与 /sys/ 目录中，内核参数的修改详见 sysctl 命令。该 target 包括但不限于以下 Unit，详见/usr/lib/systemd/system/sysinit.target.wants/目录
&lt;ol>
&lt;li>特殊文件系统装置的挂载：包括 dev-hugepages.mount、dev-mqueue.mount 等，主要在挂载跟巨量内存分页使用与消息队列的功能。成功后，会在/dev/目录下简历/dev/hugepages/、/dev/mqueue/等目录&lt;/li>
&lt;li>特殊文件系统的启动：包括磁盘阵列、网络驱动器(iscsi)、LVM 文件系统、文件系统对照服务(multipath)等等&lt;/li>
&lt;li>开机过程的讯息传递与动画执行：使用 plymouthd 服务搭配 plymouth 指令来传递动画与讯息&lt;/li>
&lt;li>日志式登录文件的使用：systemd-journald&lt;/li>
&lt;li>加载额外的内核模块：通过 /etc/modules-load.d/*.conf 文件的设定，让内核额外加载管理员所需要的内核模块&lt;/li>
&lt;li>加载额外的内核参数设定：包括 /etc/sysctl.conf 以及 /etc/sysctl.d/*.conf 内的设定&lt;/li>
&lt;li>启动系统的随机数生成器：随机数生成器可以帮助系统进行一些密码加密演算的功能&lt;/li>
&lt;li>设定终端(console)字形&lt;/li>
&lt;li>启动动态设备管理器：udevd。用来动态对应实际设备存取与设备文件名对应的一个服务&lt;/li>
&lt;/ol>
&lt;/li>
&lt;li>&lt;strong>basic.target&lt;/strong> # 载入主要的周边硬件驱动程序与防火墙相关任务。该 target 包括但不限于以下 Unit，详见/usr/lib/systemd/system/basic.target.wants/目录
&lt;ol>
&lt;li>加载 alsa 音效驱动程序：这个 alsa 是个音效相关的驱动程序，会系统产生音效&lt;/li>
&lt;li>载入 firewalld 防火墙&lt;/li>
&lt;li>加载 CPU 微指令功能&lt;/li>
&lt;li>启动与设定 SELinux 的安全文本&lt;/li>
&lt;li>将目前的开机过程所产生的开机信息写入到/var/log/dmesg 当中&lt;/li>
&lt;li>由/etc/sysconfig/module/*.module 以及/etc/rcmodules 载入管理员指定的模块&lt;/li>
&lt;li>加载 systemd 支持的 timer 功能&lt;/li>
&lt;/ol>
&lt;/li>
&lt;li>&lt;strong>multi-user.target&lt;/strong> # 下面的其它一般系统或网络服务的载入。在加载核心驱动硬件后,经过 sysinit.target 的初始化流程让系统可以存取之后,加上 basic.target 让系统成为操作系统的基础, 之后就是服务器要顺利运作时,需要的各种主机服务以及提供服务器功能的网络服务的启动了。这些服务的启动则大多是附挂在 multi-user.target 这个操作环境底下, 可以到 /etc/systemd/system/multi-user.target.wants/ 里头去瞧瞧预设要被启动的服务。针对主机的本地服务与网络服务的各项 Unit 若要 enable 的话，就是将该 Unit 放到这个目录下做个软链接。该 target 包括但不限于以下 Unit，详见 /usr/lib/systemd/system/multi-user.target.wants/ 目录
&lt;ol>
&lt;li>相容 systemV 的 rc-loacl.service，开机自动执行的命令&lt;/li>
&lt;li>提供 tty(终端)界面与登录的服务&lt;/li>
&lt;/ol>
&lt;/li>
&lt;/ol>
&lt;h3 id="查看启动顺序的时间">查看启动顺序的时间&lt;/h3>
&lt;ul>
&lt;li>要查看具体的启动顺序可以通过如下命令输入到文件，然后通过浏览器打开查看。
&lt;ul>
&lt;li>systemd-analyze plot &amp;gt; boot.html&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>列出所有正在运行的单元，按从初始化开始到启动所花的时间排序。
&lt;ul>
&lt;li>systemd-analyze blame&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>也就是说，如果想让一个 systemd 的系统正常运行，则通过 default.target 来一步一步决定运行那些 Unit，最后从决定的末尾开始，一步一步启动各个 Unit，如图所示；&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/az9p3g/1616634160644-69ffd65b-b9c4-490b-aad8-77e8e218bb02.jpeg" alt="">&lt;/p></description></item><item><title>Docs: Unit File</title><link>https://desistdaydream.github.io/docs/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/3.Systemd-%E7%B3%BB%E7%BB%9F%E5%AE%88%E6%8A%A4%E7%A8%8B%E5%BA%8F/Unit-File/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/3.Systemd-%E7%B3%BB%E7%BB%9F%E5%AE%88%E6%8A%A4%E7%A8%8B%E5%BA%8F/Unit-File/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://man.cx/systemd.unit(5)">manual(手册),systemd.unit(5)&lt;/a> # Unit 的介绍&lt;/li>
&lt;li>&lt;a href="https://man.cx/systemd.syntax(7)">manual(手册),systemd.syntax(7)&lt;/a> # Unit 的配置语法&lt;/li>
&lt;li>&lt;a href="http://www.jinbuguo.com/systemd/systemd.unit.html#">金步国 systemd.unit 中文手册&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>&lt;strong>Unit File&lt;/strong>，是 &lt;a href="https://desistdaydream.github.io/docs/2.%E7%BC%96%E7%A8%8B/%E6%97%A0%E6%B3%95%E5%88%86%E7%B1%BB%E7%9A%84%E8%AF%AD%E8%A8%80/INI.md">ini 格式&lt;/a>的纯文本文件。在这个文件中，由 &lt;strong>Directives(指令)&lt;/strong> 和 &lt;strong>Sections(部分)&lt;/strong> 组成，这里的 Directve 就是 INI 格式中的 &lt;code>键/值对&lt;/code>。&lt;/p>
&lt;ul>
&lt;li>&lt;strong>Directives(指令)&lt;/strong> # 指令由 名称 与 值 组成，以 &lt;code>=&lt;/code> 分割&lt;/li>
&lt;li>&lt;strong>Sections(部分)&lt;/strong> # 与 INI 中的 Sections 概念一样。是一组 Directives 的集合&lt;/li>
&lt;/ul>
&lt;p>Unit File 与 INI 格式文件不同的地方是关于注释，Unit File 使用 &lt;code>#&lt;/code> 作为注释行的开头。&lt;/p>
&lt;h2 id="unit-file-最简单示例">Unit File 最简单示例&lt;/h2>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">[&lt;/span>Unit&lt;span style="color:#f92672">]&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># Unit 的描述&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Description&lt;span style="color:#f92672">=&lt;/span>Foo
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">[&lt;/span>Service&lt;span style="color:#f92672">]&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># 如何启动该 Unit&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>ExecStart&lt;span style="color:#f92672">=&lt;/span>/usr/sbin/foo-daemon
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">[&lt;/span>Install&lt;span style="color:#f92672">]&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># 当 enable 该 Unit 时，应该在 multi-user.tartet.wants/ 目录中创建软链接&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>WantedBy&lt;span style="color:#f92672">=&lt;/span>multi-user.target
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h1 id="unit-file-配置">Unit File 配置&lt;/h1>
&lt;p>&lt;strong>/etc/systemd/system/*&lt;/strong> # Unit File 的存放路径，具有最高优先级&lt;/p>
&lt;ul>
&lt;li>&lt;strong>./UnitName.d/*.conf&lt;/strong> # Unit File 的 include 功能，该路径下的的以 .conf 结尾的文件，将会附加到主 Unit File 中&lt;/li>
&lt;li>.&lt;strong>/UnitName.wants/*&lt;/strong> # 与 include 功能类似，区别在于，该路径下的文件都是其他 Unit File 的软链接，这些 Unit File 的文件名将会作为主 Unit File 配置中 [Unit] 部分中 Wants 指令的值。&lt;/li>
&lt;li>.&lt;strong>/UnitName.requires/*&lt;/strong> # 与 include 功能类似，区别在于，该路径下的文件都是其他 Unit File 的软链接，这些 Unit File 的文件名将会作为主 Unit File 配置中 [Unit] 部分中 Requires 指令的值。&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>/run/systemd/system/*&lt;/strong> # Unit File 的存放路径，具有中等优先级&lt;/p>
&lt;ul>
&lt;li>&lt;strong>./UnitName.d/*.conf&lt;/strong> # Unit File 的 include 功能，该路径下的的以 .conf 结尾的文件，将会附加到主 Unit File 中&lt;/li>
&lt;li>.&lt;strong>/UnitName.wants/*&lt;/strong> # 与 include 功能类似，区别在于，该路径下的文件都是其他 Unit File 的软链接，这些 Unit File 的文件名将会作为主 Unit File 配置中 [Unit] 部分中 Wants 指令的值。&lt;/li>
&lt;li>.&lt;strong>/UnitName.requires/*&lt;/strong> # 与 include 功能类似，区别在于，该路径下的文件都是其他 Unit File 的软链接，这些 Unit File 的文件名将会作为主 Unit File 配置中 [Unit] 部分中 Requires 指令的值。&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>/usr/lib/systemd/system/*&lt;/strong> # Unit File 的存放路径，具有最低优先级&lt;/p>
&lt;ul>
&lt;li>&lt;strong>./UnitName.d/*.conf&lt;/strong> # Unit File 的 include 功能，该路径下的的以 .conf 结尾的文件，将会附加到主 Unit File 中&lt;/li>
&lt;li>.&lt;strong>/UnitName.wants/*&lt;/strong> # 与 include 功能类似，区别在于，该路径下的文件都是其他 Unit File 的软链接，这些 Unit File 的文件名将会作为主 Unit File 配置中 [Unit] 部分中 Wants 指令的值。&lt;/li>
&lt;li>.&lt;strong>/UnitName.requires/*&lt;/strong> # 与 include 功能类似，区别在于，该路径下的文件都是其他 Unit File 的软链接，这些 Unit File 的文件名将会作为主 Unit File 配置中 [Unit] 部分中 Requires 指令的值。&lt;/li>
&lt;/ul>
&lt;p>Systemd 会从最低优先级的目录 /usr/lib/&lt;em>下开始加载配置，注意加载其中的文件，直到最高优先级的目录 /etc/systemd/&lt;/em> 为止。&lt;/p>
&lt;h1 id="unit-file-规范">Unit File 规范&lt;/h1>
&lt;h2 id="unit-file-名称">Unit File 名称&lt;/h2>
&lt;p>一个有效的 Unit File 名称由三部分组成&lt;/p>
&lt;ul>
&lt;li>&lt;strong>NAME&lt;/strong> # Unit 的名称。&lt;/li>
&lt;li>&lt;strong>DOT&lt;/strong> # &lt;code>.&lt;/code> 符号。&lt;/li>
&lt;li>&lt;strong>TYPE&lt;/strong># Unit 的类型。
&lt;ul>
&lt;li>TYPE 必须是 &amp;ldquo;.service&amp;rdquo;, &amp;ldquo;.socket&amp;rdquo;, &amp;ldquo;.device&amp;rdquo;, &amp;ldquo;.mount&amp;rdquo;, &amp;ldquo;.automount&amp;rdquo;, &amp;ldquo;.swap&amp;rdquo;, &amp;ldquo;.target&amp;rdquo;, &amp;ldquo;.path&amp;rdquo;, &amp;ldquo;.timer&amp;rdquo;, &amp;ldquo;.slice&amp;rdquo;, or &amp;ldquo;.scope&amp;rdquo; 中的一个。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>比如 &lt;code>foo.server&lt;/code> 就是一个有效的 Unit File 名称。&lt;/p>
&lt;p>除了手册中列出的选项之外，单元文件还可以包含更多其他选项。 无法识别的选项不会中断单元文件的加载，但是 systemd 会输出一条警告日志。 如果选项或者小节的名字以 &lt;code>X-&lt;/code> 开头， 那么 systemd 将会完全忽略它。 以 &lt;code>X-&lt;/code> 开头的小节中的选项没必要再以 &lt;code>X-&lt;/code> 开头， 因为整个小节都已经被忽略。 应用程序可以利用这个特性在单元文件中包含额外的信息。&lt;/p>
&lt;p>如果想要给一个单元赋予别名，那么可以按照需求，在系统单元目录或用户单元目录中， 创建一个软连接(以别名作为文件名)，并将其指向该单元的单元文件。 例如 &lt;code>systemd-networkd.service&lt;/code> 在安装时就通过 &lt;code>/usr/lib/systemd/system/dbus-org.freedesktop.network1.service&lt;/code> 软连接创建了 &lt;code>dbus-org.freedesktop.network1.service&lt;/code> 别名。 此外，还可以直接在单元文件的 [Install] 部分中使用 &lt;code>Alias=&lt;/code> 创建别名。 注意，单元文件中设置的别名会随着单元的启用(enable)与禁用(disable)而生效和失效， 也就是别名软连接会随着单元的启用(enable)与禁用(disable)而创建与删除。 例如，因为 &lt;code>reboot.target&lt;/code> 单元文件中含有 &lt;code>Alias=ctrl-alt-del.target&lt;/code> 的设置，所以启用(enable)此单元之后，按下 CTRL+ALT+DEL 组合键将会导致启动该单元。单元的别名可以用于 &lt;strong>enable&lt;/strong>, &lt;strong>disable&lt;/strong>, &lt;strong>start&lt;/strong>, &lt;strong>stop&lt;/strong>, &lt;strong>status&lt;/strong>, … 这些命令中，也可以用于 &lt;code>Wants=&lt;/code>, &lt;code>Requires=&lt;/code>, &lt;code>Before=&lt;/code>, &lt;code>After=&lt;/code>, … 这些依赖关系选项中。 但是务必注意，不可将单元的别名用于 &lt;strong>preset&lt;/strong> 命令中。 再次提醒，通过 &lt;code>Alias=&lt;/code> 设置的别名仅在单元被启用(enable)之后才会生效。&lt;/p>
&lt;h2 id="unit-file-模板--多实例">Unit File 模板 &amp;amp;&amp;amp; 多实例&lt;/h2>
&lt;p>Unit File 可以通过 &lt;code>@&lt;/code> 符号声明一个&lt;strong>模板文件&lt;/strong>，通过在 &lt;code>@&lt;/code> 添加字符串，可以根据模板文件，生成一个&lt;strong>实例文件&lt;/strong>。经过实例化后的实例文件，就是一个真实可用的 Unit File 了&lt;/p>
&lt;p>就拿 Wireguard 的 Unit File 为例&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">[&lt;/span>lichenhao@hw-cloud-xngy-jump-server-linux-2 ~&lt;span style="color:#f92672">]&lt;/span>$ systemctl cat wg-quick@.service
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># /lib/systemd/system/wg-quick@.service&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">[&lt;/span>Unit&lt;span style="color:#f92672">]&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Description&lt;span style="color:#f92672">=&lt;/span>WireGuard via wg-quick&lt;span style="color:#f92672">(&lt;/span>8&lt;span style="color:#f92672">)&lt;/span> &lt;span style="color:#66d9ef">for&lt;/span> %I
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>After&lt;span style="color:#f92672">=&lt;/span>network-online.target nss-lookup.target
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Wants&lt;span style="color:#f92672">=&lt;/span>network-online.target nss-lookup.target
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>PartOf&lt;span style="color:#f92672">=&lt;/span>wg-quick.target
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">[&lt;/span>Service&lt;span style="color:#f92672">]&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Type&lt;span style="color:#f92672">=&lt;/span>oneshot
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>RemainAfterExit&lt;span style="color:#f92672">=&lt;/span>yes
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>ExecStart&lt;span style="color:#f92672">=&lt;/span>/usr/bin/wg-quick up %i
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>ExecStop&lt;span style="color:#f92672">=&lt;/span>/usr/bin/wg-quick down %i
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Environment&lt;span style="color:#f92672">=&lt;/span>WG_ENDPOINT_RESOLUTION_RETRIES&lt;span style="color:#f92672">=&lt;/span>infinity
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">[&lt;/span>Install&lt;span style="color:#f92672">]&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>WantedBy&lt;span style="color:#f92672">=&lt;/span>multi-user.target
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>上面就是一个模板文件，我们需要实例化他，那么只需要在 &lt;code>@&lt;/code> 符号后面添加字符串即可，&lt;code>systemctl enable wg-quick@wg0.service&lt;/code>，此时，将会生成如下 Unit File&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">[&lt;/span>lichenhao@hw-cloud-xngy-jump-server-linux-2 ~&lt;span style="color:#f92672">]&lt;/span>$ systemctl cat wg-quick@wg0.service
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># /lib/systemd/system/wg-quick@.service&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">[&lt;/span>Unit&lt;span style="color:#f92672">]&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Description&lt;span style="color:#f92672">=&lt;/span>WireGuard via wg-quick&lt;span style="color:#f92672">(&lt;/span>8&lt;span style="color:#f92672">)&lt;/span> &lt;span style="color:#66d9ef">for&lt;/span> %I
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>After&lt;span style="color:#f92672">=&lt;/span>network-online.target nss-lookup.target
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Wants&lt;span style="color:#f92672">=&lt;/span>network-online.target nss-lookup.target
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>PartOf&lt;span style="color:#f92672">=&lt;/span>wg-quick.target
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">[&lt;/span>Service&lt;span style="color:#f92672">]&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Type&lt;span style="color:#f92672">=&lt;/span>oneshot
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>RemainAfterExit&lt;span style="color:#f92672">=&lt;/span>yes
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>ExecStart&lt;span style="color:#f92672">=&lt;/span>/usr/bin/wg-quick up %i
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>ExecStop&lt;span style="color:#f92672">=&lt;/span>/usr/bin/wg-quick down %i
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Environment&lt;span style="color:#f92672">=&lt;/span>WG_ENDPOINT_RESOLUTION_RETRIES&lt;span style="color:#f92672">=&lt;/span>infinity
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">[&lt;/span>Install&lt;span style="color:#f92672">]&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>WantedBy&lt;span style="color:#f92672">=&lt;/span>multi-user.target
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>当我们启动该服务时，其实就是执行了 ExecStart 指令中的命令，并且 &lt;code>%i&lt;/code> 被替换成了 wg0，即 &lt;code>/usr/bin/wg-quick up wg0&lt;/code>&lt;/p>
&lt;p>这种模板化的 Unit File 特别适合这种服务来使用，还有那些配置 TTY、磁盘名称的，都可以将想要实例化的 TTY 或者 分区，作为 %i 配置。&lt;/p>
&lt;h2 id="drop-in嵌入式-unit-file就是-include-功能">drop-in(嵌入式) Unit File(就是 include 功能)&lt;/h2>
&lt;p>&lt;strong>drop-in(嵌入式)&lt;/strong> 单元文件就是一种类似配置文件的 &lt;strong>include&lt;/strong>的功能(比如 Nginx 中的 include 指令)，可以让主配置文件包含其他子配置文件。&lt;strong>Systemd 设定了两种 include 的规范&lt;/strong>&lt;/p>
&lt;p>假如现在有一个名为 &lt;code>foo.service&lt;/code> 的 Unit File，那么，&lt;a href="https://www.yuque.com/desistdaydream/learning/sa1uqi#o317e">Systemd 会从加载 Unit File 的目录&lt;/a>中，加载与之相关联的一系列文件&lt;/p>
&lt;ul>
&lt;li>**UnitFileName.wants/ 与 UnitFileName.requires/ #**比如 foo.service.wants/  与  foo.service.requires/。该目录中可以放置许多指向其他 Unit Files 的软连接。 软连接所指向的 Unit 将会被当做  &lt;code>foo.service&lt;/code>  的 Unit 文件中  &lt;code>Wants=&lt;/code>  与  &lt;code>Requires=&lt;/code>  指令的值(
&lt;ul>
&lt;li>注意：即使文件中不存在 Wants 和 Requires 指令。只要存在对应的 &lt;em>.wants/ 和&lt;/em>.requires/ 目录，就相当于为 Unit File 中加上了这两个指令。&lt;/li>
&lt;li>这样就可以方便的为 Unit 添加依赖关系，而无需修改单元文件本身。 向  &lt;code>*.wants/&lt;/code>  与  &lt;code>*.requires/&lt;/code>  目录中添加软连接的首选方法是使用  &lt;a href="http://www.jinbuguo.com/systemd/systemctl.html#">systemctl(1)&lt;/a>  的  &lt;strong>enable&lt;/strong>  命令， 它会读取 Unit File 的 [Install] 部分。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>UnitFileName.d/&lt;/strong> # 比如 foo.service.d/** **。这就是配置文件的 include 功能。当解析完主 Unit File 之后，该目录中所有以 &lt;code>.conf&lt;/code> 结尾的文件，都会被依次附加到主 Unit File 的末尾。
&lt;ul>
&lt;li>这样就可以方便的修改 Unit 的设置，或者为 Unit 添加额外的设置，而无需修改 Unit File 本身。&lt;/li>
&lt;li>注意，include 功能中的文件遵守如下规则：
&lt;ul>
&lt;li>必须包含明确的 Sections (例如 &lt;code>[Service]&lt;/code> 之类)。&lt;/li>
&lt;li>对于从模板文件实例化而来的 Unit，会优先读取与此实例对应的 &lt;code>UnitFileName.d/&lt;/code> 目录(例如 &amp;ldquo;&lt;code>foo@bar.service.d/&lt;/code>&amp;quot;)中的配置片段(&lt;code>*.conf&lt;/code> 文件)， 然后才会读取与模板对应的 &amp;ldquo;&lt;code>.d/&lt;/code>&amp;rdquo; 目录(例如 &amp;ldquo;&lt;code>foo@.service.d/&lt;/code>&amp;quot;)中的配置片段(&amp;quot;&lt;code>.conf&lt;/code>&amp;rdquo; 文件)。&lt;/li>
&lt;li>对于名称中包含连字符(&amp;quot;&lt;code>-&lt;/code>&amp;quot;)的单元，将会按特定顺序依次在一组(而不是一个)目录中搜索单元配置片段。 例如对于  &lt;code>foo-bar-baz.service&lt;/code>  单元来说，将会依次在  &lt;code>foo-.service.d/&lt;/code>, &lt;code>foo-bar-.service.d/&lt;/code>, &lt;code>foo-bar-baz.service.d/&lt;/code>  目录下搜索单元配置片段。
&lt;ul>
&lt;li>这个机制可以方便的为一组相关单元(单元名称的前缀都相同)定义共同的单元配置片段， 特别适合应用于 mount, automount, slice 类型的单元， 因为这些单元的命名规则就是基于连字符构建的。&lt;/li>
&lt;li>注意，在前缀层次结构的下层目录中的单元配置片段，会覆盖上层目录中的同名文件， 也就是  &lt;code>foo-bar-.service.d/10-override.conf&lt;/code>  会覆盖(取代) &lt;code>foo-.service.d/10-override.conf&lt;/code>  文件。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>注意：通常情况下，drop-in Unit File 放在 &lt;code>/etc/systemd/{system,user}&lt;/code>  目录中， 还可以放置在  &lt;code>/usr/lib/systemd/{system,user}&lt;/code>  与  &lt;code>/run/systemd/{system,user}&lt;/code>  目录中。 虽然在优先级上，&lt;code>/etc&lt;/code>  中的配置片段优先级最高、&lt;code>/run&lt;/code>  中的配置片段优先级居中、 &lt;code>/usr/lib&lt;/code>  中的配置片段优先级最低。但是这仅对同名配置片段之间的覆盖关系有意义。 因为所有 &lt;code>.d/&lt;/code> 目录中的配置片段，无论其位于哪个目录， 都会被按照文件名的字典顺序，依次覆盖单元文件中的设置(相当于依次附加到主单元文件的末尾)。&lt;/p>
&lt;h3 id="drop-in-示例">drop-in 示例&lt;/h3>
&lt;ul>
&lt;li>/usr/lib/systemd/system/ssh.service # ssh 这个 Unit 的主配置文件&lt;/li>
&lt;li>/etc/systemd/system/ssh.service.d/CUSTOM.conf # 在 /etc/systemd/system 下面创建与配置文件相同文件名的目录,但是要加上 .d 的扩展名。然后在该目录下创建 .conf 结尾的配置文件即可。&lt;/li>
&lt;li>/etc/systemd/system/vsftpd.service.wants/ # 此目录内的文件为链接文件,设置相依服务的链接。意思是启动了 vsftpd.service 之后,最好再加上这目录下面建议的服务。&lt;/li>
&lt;li>/etc/systemd/system/vsftpd.service.requires/ # 此目录内的文件为链接文件,设置相依服务的链接。意思是在启动 vsftpd.service 之前,需要事先启动哪些服务的意思。&lt;/li>
&lt;/ul>
&lt;p>配置文件分为 4 种状态，当启用(enable)该文件的时候，从配置文件目录建立一个软连接到 /etc/systemd/system/ 目录下，当禁用(disable)该文件的时候，会把该软连接删除。如果在/etc/systemd/system/目录下有 Unit 的配置文件，则开机则会自动加载并启动 Unit。可以使用命令 systemctl list-unit-files 命令查看所有的配置文件状态。结论：建立了连接则说明该 Unit 会开机启动，没建立连接则该 Unit 不会开机启动；还可以禁止该 Unit 建立连接，则说明该 Unit 永远不能开机启动。
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/gvdc29/1620129636770-82d464a7-f1ef-4e5c-9749-61b258d1b0e6.png" alt="image.png">&lt;/p>
&lt;ul>
&lt;li>enabled：启用(该文件已建立链接)&lt;/li>
&lt;li>disabled：禁用(该文件没建立链接)&lt;/li>
&lt;li>static：这个文件不可以被建立链接，但是可以被其他服务进行关联启动&lt;/li>
&lt;li>masked：该配置文件被禁止建立启动链接，可以使用 systemctl unmask 命令开启&lt;/li>
&lt;/ul>
&lt;h2 id="总结以及注意事项">总结以及注意事项&lt;/h2>
&lt;p>在使用 systemctl 命令时，会有两个子命令，systemctl list-units 和 systemctl list-unit-files，这俩命令的区别如下&lt;/p>
&lt;ul>
&lt;li>list-units 是列出已经载入的 Unit(加上-a 选项可以看 start 和 stop 所有的)，其中还包括各种.device 的 unit，这类设备是硬件，没有配置文件的，不会再 list-unit-files 命令下列出来&lt;/li>
&lt;li>list-unit-files 是列出所有已经安装的 Unit 的配置文件(有一部分 Unit 是没有配置文件的)，安装完的 Unit 会把配置文件存放在/lib/systemd/system/目录下，而且通过查看 list-unit-files 还能看出来是否是开机启动，具体原因请见下文的《systemd 的 unit 配置文件说明》&lt;/li>
&lt;li>如果一个单元文件的大小为零字节或者是指向 &lt;code>/dev/null&lt;/code> 的软连接， 那么它的所有相关配置都将被忽略。同时，该单元将被标记为 &amp;ldquo;&lt;code>masked&lt;/code>&amp;rdquo; 状态，并且无法被启动。 这样就可以 彻底屏蔽一个单元(即使手动启动也不行)。&lt;/li>
&lt;/ul>
&lt;h1 id="各种-unit-额外说明">各种 Unit 额外说明&lt;/h1>
&lt;h2 id="target-unit">Target Unit&lt;/h2>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/gvdc29/1616167393736-e7bb0f5d-83be-4d38-856d-a22c56e9fab1.jpeg" alt="">
启动计算机的时候，需要启动大量的 Unit。如果每一次启动，都要一一写明本次启动需要哪些 Unit，显然非常不方便。Systemd 的解决方案就是 Target。&lt;/p>
&lt;p>简单说，Target 就是一个 Unit 组，包含许多相关的 Unit 。启动某个 Target 的时候，Systemd 就会启动里面所有的 Unit。从这个意义上说，Target 这个概念类似于&amp;quot;状态点&amp;rdquo;，启动某个 Target 就好比启动到某种状态。&lt;/p>
&lt;p>注意&lt;/p>
&lt;ol>
&lt;li>在启动系统的时候，也是首先通过查询 target 中的内容，以便启动相应的 Unit&lt;/li>
&lt;li>传统的 init 启动模式里面，有 RunLevel 的概念，Target 就能起到同样的效果。不同的是，RunLevel 是互斥的，不可能多个 RunLevel 同时启动，但是多个 Target 可以同时启动，并且更加灵活，可以自己定义每个 Target 可以包含的 Unit。比如启动 graphical.target 则里面就包含运行图形界面的 Unit 和 multi-user.target 中的所有 Unit。&lt;/li>
&lt;li>我们可以通过 systemctl set-default UNIT 命令来设定系统启动时，默认启动的一组 Unit&lt;/li>
&lt;/ol>
&lt;h1 id="unit-file-加载示例">Unit File 加载示例&lt;/h1>
&lt;p>可以通过 &lt;a href="https://desistdaydream.github.io/docs/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/0.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E7%B3%BB%E7%BB%9F%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B.md">系统启动流程&lt;/a> 看出来 Systemd 是如何加载 Unit File 的&lt;/p></description></item><item><title>Docs: Unit File</title><link>https://desistdaydream.github.io/docs/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/3.Systemd-%E7%B3%BB%E7%BB%9F%E5%AE%88%E6%8A%A4%E7%A8%8B%E5%BA%8F/Unit-File/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/3.Systemd-%E7%B3%BB%E7%BB%9F%E5%AE%88%E6%8A%A4%E7%A8%8B%E5%BA%8F/Unit-File/</guid><description/></item></channel></rss>