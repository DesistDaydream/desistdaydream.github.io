<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>断念梦 – Unit File</title><link>https://desistdaydream.github.io/docs/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/3.Systemd-%E7%B3%BB%E7%BB%9F%E5%AE%88%E6%8A%A4%E7%A8%8B%E5%BA%8F/Unit-File/</link><description>Recent content in Unit File on 断念梦</description><generator>Hugo -- gohugo.io</generator><atom:link href="https://desistdaydream.github.io/docs/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/3.Systemd-%E7%B3%BB%E7%BB%9F%E5%AE%88%E6%8A%A4%E7%A8%8B%E5%BA%8F/Unit-File/index.xml" rel="self" type="application/rss+xml"/><item><title>Docs: mount Unit</title><link>https://desistdaydream.github.io/docs/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/3.Systemd-%E7%B3%BB%E7%BB%9F%E5%AE%88%E6%8A%A4%E7%A8%8B%E5%BA%8F/Unit-File/mount-Unit/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/3.Systemd-%E7%B3%BB%E7%BB%9F%E5%AE%88%E6%8A%A4%E7%A8%8B%E5%BA%8F/Unit-File/mount-Unit/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://man7.org/linux/man-pages/man5/systemd.mount.5.html">Manual(手册),systemd-mount(5)&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://zhangguanzhang.github.io/2019/01/30/fstab/">张馆长博客,fstab 与 systemd.mount 自动挂载的一点研究和见解&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>所有以 &lt;code>.mount&lt;/code> 结尾的 Unit 都是由 Systemd 控制和监督的文件系统挂载功能。该功能可以代替传统的 /etc/fstab 文件。&lt;/p>
&lt;h1 id="张馆长文章">张馆长文章&lt;/h1>
&lt;p>x-systemd.automount 属于 systemd.mount，systemd 造了好多轮子，什么 crontab、网络管理器、日志服务 它都想给接替了。fstab 也是这样，systemd 引入了 .mount 单元这么个东西，用于控制文件系统挂载。&lt;/p>
&lt;p>&lt;code>defaults&lt;/code>下有&lt;code>auto&lt;/code>会被开机挂载，&lt;code>noauto&lt;/code>一般是和&lt;code>x-systemd.automount&lt;/code>配合使用。而&lt;code>x-systemd.automount&lt;/code>属于 systemd.mount，systemd 造了好多轮子，什么 crontab、网络管理器、日志服务 它都想给接替了。fstab 也是这样，systemd 引入了 .mount 单元这么个东西，用于控制文件系统挂载。&lt;/p>
&lt;p>其实现在很多发行版都开始慢慢抛弃 fstab 了，先看一个 centos6 在 init 下的 fstab&lt;/p>
&lt;pre>&lt;code>[root@APP-SRV-001 ~]# cat /etc/fstab
#
# /etc/fstab
# Created by anaconda on Mon Nov 26 22:13:02 2018
#
# Accessible filesystems, by reference, are maintained under '/dev/disk'
# See man pages fstab(5), findfs(8), mount(8) and/or blkid(8) for more info
#
UUID=19698973-561a-4b5b-aded-f6092bd1f341 / ext4 defaults 1 1
UUID=1f808272-972d-416a-af7f-d3c88b16f434 /boot ext4 defaults 1 2
UUID=C6D4-B036 /boot/efi vfat umask=0077,shortname=winnt 0 0
UUID=7877eff3-a174-4cb5-9024-43be4fab35b2 swap swap defaults 0 0
tmpfs /dev/shm tmpfs defaults 0 0
devpts /dev/pts devpts gid=5,mode=620 0 0
sysfs /sys sysfs defaults 0 0
proc /proc proc defaults 0 0
&lt;/code>&lt;/pre>
&lt;p>下面是 centos7 在 systemd 下的 fstab&lt;/p>
&lt;pre>&lt;code>[root@CentOS76 ~]# cat /etc/fstab
#
# /etc/fstab
# Created by anaconda on Mon Dec 17 01:38:08 2018
#
# Accessible filesystems, by reference, are maintained under '/dev/disk'
# See man pages fstab(5), findfs(8), mount(8) and/or blkid(8) for more info
#
/dev/mapper/centos-root / xfs defaults 0 0
UUID=cec0b2aa-7695-4d24-a641-5b3ae111500a /boot xfs defaults 0 0
#/dev/mapper/centos-swap swap swap defaults 0 0
&lt;/code>&lt;/pre>
&lt;p>我们发现很多东西在 fstab 里消失了，但是 centos7 上 mount 看实际上还是挂载了&lt;/p>
&lt;pre>&lt;code>[root@CentOS76 ~]# mount
sysfs on /sys type sysfs (rw,nosuid,nodev,noexec,relatime)
proc on /proc type proc (rw,nosuid,nodev,noexec,relatime)
devtmpfs on /dev type devtmpfs (rw,nosuid,size=995764k,nr_inodes=248941,mode=755)
securityfs on /sys/kernel/security type securityfs (rw,nosuid,nodev,noexec,relatime)
tmpfs on /dev/shm type tmpfs (rw,nosuid,nodev)
devpts on /dev/pts type devpts (rw,nosuid,noexec,relatime,gid=5,mode=620,ptmxmode=000)
tmpfs on /run type tmpfs (rw,nosuid,nodev,mode=755)
tmpfs on /sys/fs/cgroup type tmpfs (ro,nosuid,nodev,noexec,mode=755)
configfs on /sys/kernel/config type configfs (rw,relatime)
/dev/mapper/centos-root on / type xfs (rw,relatime,attr2,inode64,noquota)
systemd-1 on /proc/sys/fs/binfmt_misc type autofs (rw,relatime,fd=22,pgrp=1,timeout=0,minproto=5,maxproto=5,direct,pipe_ino=21472)
hugetlbfs on /dev/hugepages type hugetlbfs (rw,relatime,pagesize=2M)
debugfs on /sys/kernel/debug type debugfs (rw,relatime)
mqueue on /dev/mqueue type mqueue (rw,relatime)
/dev/sda1 on /boot type xfs (rw,relatime,attr2,inode64,noquota)
tmpfs on /run/user/0 type tmpfs (rw,nosuid,nodev,relatime,size=201784k,mode=700)
&lt;/code>&lt;/pre>
&lt;p>其实是已经被 systemd 挂载了，我们可以查看 systemd 的挂载单元 tmp&lt;/p>
&lt;pre>&lt;code>[root@CentOS76 ~]# systemctl cat tmp.mount
# /usr/lib/systemd/system/tmp.mount
# This file is part of systemd.
#
# systemd is free software; you can redistribute it and/or modify it
# under the terms of the GNU Lesser General Public License as published by
# the Free Software Foundation; either version 2.1 of the License, or
# (at your option) any later version.
[Unit]
Description=Temporary Directory
Documentation=man:hier(7)
Documentation=http://www.freedesktop.org/wiki/Software/systemd/APIFileSystems
ConditionPathIsSymbolicLink=!/tmp
DefaultDependencies=no
Conflicts=umount.target
Before=local-fs.target umount.target
[Mount]
What=tmpfs
Where=/tmp
Type=tmpfs
Options=mode=1777,strictatime
# Make 'systemctl enable tmp.mount' work:
[Install]
WantedBy=local-fs.target
&lt;/code>&lt;/pre>
&lt;p>内容也很好看懂。Requires、After 这和 systemd service 的写法基本一致，[Mount] 下就是挂载的说明了，What 后是要挂载的文件系统，Where 是挂载到的地方，Type 是文件系统类型，Options 是挂载参数。相当于：&lt;/p>
&lt;pre>&lt;code>mount -t &amp;lt;Type&amp;gt; -o &amp;lt;Options&amp;gt; &amp;lt;What&amp;gt; &amp;lt;Where&amp;gt;
&lt;/code>&lt;/pre>
&lt;p>我们看看目录下的挂载单元&lt;/p>
&lt;pre>&lt;code>$ ll /usr/lib/systemd/system/*.mount
-rw-r--r--. 1 root root 670 Oct 31 07:31 /usr/lib/systemd/system/dev-hugepages.mount
-rw-r--r--. 1 root root 590 Oct 31 07:31 /usr/lib/systemd/system/dev-mqueue.mount
-rw-r--r--. 1 root root 615 Oct 31 07:31 /usr/lib/systemd/system/proc-sys-fs-binfmt_misc.mount
-rw-r--r--. 1 root root 681 Oct 31 07:31 /usr/lib/systemd/system/sys-fs-fuse-connections.mount
-rw-r--r--. 1 root root 719 Oct 31 07:31 /usr/lib/systemd/system/sys-kernel-config.mount
-rw-r--r--. 1 root root 662 Oct 31 07:31 /usr/lib/systemd/system/sys-kernel-debug.mount
-rw-r--r--. 1 root root 703 Oct 31 07:31 /usr/lib/systemd/system/tmp.mount
&lt;/code>&lt;/pre>
&lt;p>我们看一个文件&lt;/p>
&lt;pre>&lt;code>$ cat /usr/lib/systemd/system/proc-sys-fs-binfmt_misc.mount
# This file is part of systemd.
#
# systemd is free software; you can redistribute it and/or modify it
# under the terms of the GNU Lesser General Public License as published by
# the Free Software Foundation; either version 2.1 of the License, or
# (at your option) any later version.
[Unit]
Description=Arbitrary Executable File Formats File System
Documentation=https://www.kernel.org/doc/Documentation/admin-guide/binfmt-misc.rst
Documentation=http://www.freedesktop.org/wiki/Software/systemd/APIFileSystems
DefaultDependencies=no
[Mount]
What=binfmt_misc
Where=/proc/sys/fs/binfmt_misc
Type=binfmt_misc
&lt;/code>&lt;/pre>
&lt;p>实际上挂载单元的文件名和挂载点是关联的，挂载点路径转换为去掉以一个斜线，所有斜线转成横线&lt;/p>
&lt;p>例如它这个&lt;code>/proc/sys/fs/binfmt_misc&lt;/code>转成&lt;code>proc-sys-fs-binfmt_misc.mount&lt;/code>，注意，mount 单元不能从模版实例化而来， 也不能通过创建软连接的方法给同一个 mount 单元赋予多个别名。&lt;/p>
&lt;p>在系统运行时创建的挂载点(独立于单元文件与 /etc/fstab 之外)将同样被 systemd 监控， 并且看上去与其他常规的 mount 单元没啥差别。详见 proc(5) 手册中对 /proc/self/mountinfo 的解释。&lt;/p>
&lt;p>注意，某些 虚拟文件系统 拥有特别的功能，例如： /sys, /proc, /dev, /tmp, sys/fs/cgroup, /dev/mqueue, /proc/sys/fs/binfmt_misc … 无法通过 mount 单元对其进行修改或禁用。&lt;/p>
&lt;p>mount 单元既可以通过单元文件进行配置， 也可以通过 /etc/fstab 文件(参见 fstab(5) 手册)进行配置。 /etc/fstab 中的挂载点将在每次重新加载 systemd 配置时(包括系统启动时) 动态的自动转化为 mount 单元。 一般来说，通过 /etc/fstab 配置挂载点是首选的方法， 详见 systemd-fstab-generator(8) 手册。&lt;/p>
&lt;p>可以在 /etc/fstab 中使用一些无法被其他程序识别的 systemd 专用挂载选项， 以帮助创建与挂载点相关的依赖关系。 对于本地文件系统挂载点， systemd 将会自动在 local-fs.target 中创建指向此挂载点的 Wants= 或 Requires= 依赖； 对于网络文件系统挂载点， systemd 将会自动在 remote-fs.target 中创建指向此挂载点的 Wants= 或 Requires= 依赖； 至于究竟是 Wants= 还是 Requires= 依赖， 则取决于是否设置了下面的 nofail 选项。&lt;/p>
&lt;ul>
&lt;li>x-systemd.requires=设置一个到其他单元(例如 device 或 mount 单元)的 Requires= 与 After= 依赖(详见 systemd.unit(5) 手册)， 参数必须是以下三者之一： 一个单独的单元名称、 一个以绝对路径表示的设备节点、 一个以绝对路径表示的挂载点。 可以多次使用此选项以指定对多个单元的依赖。此选项对于如下两种挂载点特别有用： (1)需要额外辅助设备的，例如将日志存储在其他设备上的日志文件系统 (2)需要事先存在其他挂载点的，例如可以融合多个挂载点的叠合文件系统 (Overlay Filesystem)。&lt;/li>
&lt;li>x-systemd.before=, x-systemd.after=设置一个到其他单元(例如 mount 单元)的 Before= 或 After= 依赖。 参数必须是一个单独的单元名称或者一个以绝对路径表示的挂载点。 可以多次使用这些选项以指定对多个单元的依赖。 这些选项对于同时具备如下特征的挂载点特别有用： 挂载点带有 nofail 标记、 以异步方式挂载(async)(默认即是异步)、 需要在特定单元启动之前或之后才能挂载(例如必须在启动 local-fs.target 之前挂载)。 关于 Before= 与 After= 的解释，详见 systemd.unit(5) 手册。&lt;/li>
&lt;li>x-systemd.requires-mounts-for=设置一个到其他挂载点的 RequiresMountsFor= 依赖(详见 systemd.unit(5) 手册)。 参数必须是一个以绝对路径表示的挂载点， 可以多次使用此选项以指定对多个挂载点的依赖。&lt;/li>
&lt;li>x-systemd.device-bound 将文件系统所在的块设备升级为 BindsTo= 依赖。 此选项仅在使用 mount(8) 手动挂载时才有意义，因为此时默认为 Requires= 依赖。 注意，对于 /etc/fstab 中的条目或 mount 单元来说， 已经自动隐含的设置了此选项。&lt;/li>
&lt;li>x-systemd.automount 同时创建一个对应的 automount 单元， 详见 systemd.automount(5) 手册。&lt;/li>
&lt;li>x-systemd.idle-timeout=设置对应的 automount 单元的最大闲置时长。详见 systemd.automount(5) 手册中的 TimeoutIdleSec= 选项。&lt;/li>
&lt;li>x-systemd.device-timeout=设置等候所依赖的设备进入可用状态的最大时长，若超时则放弃挂载。 可以使用 “ms”, “s”, “min”, “h” 这样的时间单位后缀。 若省略后缀则表示单位是秒。&lt;/li>
&lt;/ul>
&lt;p>注意，此选项仅可用于 /etc/fstab 文件， 不可用于单元文件中的 Options= 选项。&lt;/p>
&lt;ul>
&lt;li>x-systemd.mount-timeout=设置 /etc/fstab 中挂载点的超时时长。 如果超过指定的时间仍未挂载成功，那么将会放弃该挂载点。 可以使用 “s”, “min”, “h”, “ms” 这样的时间单位后缀。 若省略后缀则表示单位是秒。&lt;/li>
&lt;/ul>
&lt;p>注意，此选项仅可用于 /etc/fstab 文件， 不可用于单元文件中的 Options= 选项。&lt;/p>
&lt;p>参见下文的 TimeoutSec= 选项。&lt;/p>
&lt;ul>
&lt;li>_netdev 通常根据文件系统的类型来判断是否为网络文件系统(例如 xfs, ext4 是本地，而 cifs, nfs 则是网络)， 以决定是否必须在网络可用之后才能启动。 但是在某些情况下这种判断是不可靠的(例如对于 iSCSI 这样基于网络的块设备)， 使用此选项之后就可以强迫将此文件系统标记为网络文件系统。&lt;/li>
&lt;/ul>
&lt;p>网络文件系统所对应的 mount 单元将被安排在 remote-fs-pre.target 与 remote-fs.target 之间启动(而不是在 local-fs-pre.target 与 local-fs.target 之间)， 并且自动获得 After=network-online.target, Wants=network-online.target, After=network.target 依赖。&lt;/p>
&lt;ul>
&lt;li>noauto, autonoauto 表示不将此挂载点加入到 local-fs.target/remote-fs.target 的依赖中， 也就是不在系统启动时自动挂载(除非为了满足其他单元的依赖而被挂载)。 auto(默认值) 表示自动将此挂载点加入到 local-fs.target/remote-fs.target 的依赖中， 也就是在系统启动时自动挂载。&lt;/li>
&lt;li>nofail 表示仅在 local-fs.target/remote-fs.target 中对此挂载点使用 Wants= 依赖(而不是默认的 Requires=)。 也就是即使此挂载点挂载失败，也不会中断系统的启动流程。&lt;/li>
&lt;li>x-initrd.mount 要在 initramfs 中额外挂载的文件系统，参见 systemd.special(7) 手册中对 initrd-fs.target 的解释。&lt;/li>
&lt;/ul>
&lt;p>如果一个挂载点既被封装到了一个 mount 单元中， 又被配置到了 /etc/fstab 文件中，那么： (1)如果单元文件位于 /usr 中， 那么以 /etc/fstab 文件为准(无视单元文件)。 (2)如果单元文件位于 /etc 中， 那么以单元文件为准(无视 /etc/fstab 文件)。 这意味着对于同一个挂载点来说， /etc 中的单元文件优先级最高、/etc/fstab 文件次之、 /usr 中的单元文件优先级最低。&lt;/p>
&lt;p>选项&lt;/p>
&lt;p>每个 mount 单元文件都必须包含一个 [Mount] 小节， 用于包含该单元封装的挂载点信息。 可在 [Mount] 小节中使用的选项， 有许多是与其他单元共享的，详见 systemd.exec(5) 与 systemd.kill(5) 手册。 这里只列出仅能用于 [Mount] 小节的选项(亦称”指令”或”属性”)：&lt;/p>
&lt;ul>
&lt;li>What=绝对路径形式表示的被挂载对象：设备节点、LOOP 文件、其他资源(例如网络资源)。 详见 mount(8) 手册。 如果是一个设备节点，那么将会自动添加对此设备节点单元的依赖(参见 systemd.device(5) 手册)。 这是一个必需的设置。注意，因为可以在此选项中使用 “%” 系列替换标记， 所以百分号(%)应该使用 “%%” 表示。&lt;/li>
&lt;li>Where=绝对路径形式表示的挂载点目录。 注意，不可设为一个软连接(即使它实际指向了一个目录)。 如果挂载时此目录不存在，那么将尝试创建它。 注意，这里设置的绝对路径必须与单元文件的名称相对应(见上文)。 这是一个必需的设置。&lt;/li>
&lt;li>Type=字符串形式表示的文件系统类型。详见 mount(8) 手册。这是一个可选的设置。&lt;/li>
&lt;li>Options=一组逗号分隔的挂载选项。详见 mount(8) 手册。 这是一个可选的设置。注意，因为可以在此选项中使用 “%” 系列替换标记， 所以百分号(%)应该使用 “%%” 表示。&lt;/li>
&lt;li>SloppyOptions=设为 yes 表示允许在 Options= 中使用文件系统不支持的挂载选项， 且不会导致挂载失败(相当于使用了 mount(8) 的 -s 命令行选项)。 默认值 no 表示禁止在 Options= 中使用文件系统不支持的挂载选项(会导致挂载失败)。&lt;/li>
&lt;li>LazyUnmount=设置是否使用延迟卸载。 设为 yes 表示立即将文件系统从当前的挂载点分离， 但是一直等待到设备不再忙碌的时候， 才会清理所有对此文件系统的引用(也就是真正完成卸载)。 这相当于使用 umount(8) 的 -l 选项进行卸载。 默认值为 no&lt;/li>
&lt;li>ForceUnmount=设置是否使用强制卸载。 设为 yes 表示使用强制卸载(仅建议用于 NFS 文件系统)。 这相当于使用 umount(8) 的 -f 选项进行卸载。 默认值为 no&lt;/li>
&lt;li>DirectoryMode=自动创建挂载点目录(包括必要的上级目录)时， 所使用的权限模式(八进制表示法)。 默认值是 0755&lt;/li>
&lt;li>TimeoutSec=最大允许使用多长时间以完成挂载动作。 若超时则被视为挂载失败， 并且所有当前正在运行的命令都将被以 SIGTERM 信号终止； 若继续等待相同的时长之后命令仍未终止， 那么将使用 SIGKILL 信号强制终止 (详见 systemd.kill(5) 中的 KillMode= 选项)。 可以使用 “ms”, “s”, “min”, “h” 这样的时间单位后缀。 若省略后缀则表示单位是秒。 设为零表示永不超时。 默认值为 DefaultTimeoutStartSec= 选项的值 (参见 systemd-system.conf(5) 手册)。&lt;/li>
&lt;/ul>
&lt;p>参见 systemd.exec(5) 与 systemd.kill(5) 以了解更多设置。&lt;/p>
&lt;p>按照我找的实际观察下,开机后&lt;/p>
&lt;pre>&lt;code>$ grep mnt /etc/fstab
//10.0.23.85/test /mnt cifs x-systemd.automount,noauto,username=zhangguanzhang@xxxx.com,password=xxxxx,iocharset=utf8,x-systemd.device-timeout=20s 0 0
$ mount | grep mnt
systemd-1 on /mnt type autofs (rw,relatime,fd=26,pgrp=1,timeout=0,minproto=5,maxproto=5,direct,pipe_ino=21338)
$ ll /mnt
total 51288
-rwxr-xr-x 1 root root 52517368 Jul 23 2018 XshellPlus-6.0.0006r.exe
$ mount | grep mnt
systemd-1 on /mnt type autofs (rw,relatime,fd=26,pgrp=1,timeout=0,minproto=5,maxproto=5,direct,pipe_ino=21338)
//10.0.23.85/test on /mnt type cifs (rw,relatime,vers=default,cache=strict,username=zhangguanzhang@xxxx.com,domain=,uid=0,noforceuid,gid=0,noforcegid,addr=10.0.23.85,file_mode=0755,dir_mode=0755,soft,nounix,serverino,mapposix,rsize=1048576,wsize=1048576,echo_interval=60,actimeo=1)
&lt;/code>&lt;/pre>
&lt;p>从上面可以看出只有我们访问的时候 systemd 收到了访问的请求才会去挂载的，也就是下面选项生效了&lt;/p>
&lt;pre>&lt;code>noauto,x-systemd.automount
&lt;/code>&lt;/pre>
&lt;p>我们看下生成的挂载单元&lt;/p>
&lt;pre>&lt;code>systemctl cat mnt.mount
# /run/systemd/generator/mnt.mount
# Automatically generated by systemd-fstab-generator
[Unit]
SourcePath=/etc/fstab
Documentation=man:fstab(5) man:systemd-fstab-generator(8)
[Mount]
What=//10.0.23.85/test
Where=/mnt
Type=cifs
Options=x-systemd.automount,noauto,username=zhangguanzhang@xxxx.com,password=xxxxxx,iocharset=utf8
&lt;/code>&lt;/pre>
&lt;p>我们还可以通过&lt;code>systemctl status mnt.mount&lt;/code>查看啥时候挂载的，可以查看&lt;code>systemctl status mnt.automount&lt;/code>查看是被哪个进程 pid 触发的挂载&lt;/p>
&lt;pre>&lt;code>[root@CentOS76 ~]# systemctl status mnt.mount
● mnt.mount - /mnt
Loaded: loaded (/etc/fstab; bad; vendor preset: disabled)
Active: active (mounted) since Wed 2019-04-24 18:46:19 CST; 3min 7s ago
Where: /mnt
What: //10.0.23.85/test
Docs: man:fstab(5)
man:systemd-fstab-generator(8)
Process: 6901 ExecMount=/bin/mount //10.0.23.85/test /mnt -t cifs -o x-systemd.automount,username=zhangguanzhang@outlook.com,password=hj945417,_netdev,iocharset=utf8 (code=exited, status=0/SUCCESS)
Tasks: 0
Memory: 580.0K
Apr 24 18:46:19 CentOS76 systemd[1]: Mounting /mnt...
Apr 24 18:46:19 CentOS76 systemd[1]: Mounted /mnt.
[root@CentOS76 ~]# date
Wed Apr 24 18:49:33 CST 2019
[root@CentOS76 ~]# systemctl status mnt.automount
● mnt.automount
Loaded: loaded (/etc/fstab; bad; vendor preset: disabled)
Active: active (running) since Wed 2019-04-24 18:44:43 CST; 5min ago
Where: /mnt
Docs: man:fstab(5)
man:systemd-fstab-generator(8)
Apr 24 18:46:19 CentOS76 systemd[1]: Got automount request for /mnt, triggered by 6900 (ls)
&lt;/code>&lt;/pre>
&lt;p>参考
&lt;a href="http://www.jinbuguo.com/systemd/systemd.mount.html">http://www.jinbuguo.com/systemd/systemd.mount.html&lt;/a>
&lt;a href="http://www.jinbuguo.com/systemd/systemd.automount.html#">http://www.jinbuguo.com/systemd/systemd.automount.html#&lt;/a>
&lt;a href="https://blog.csdn.net/richerg85/article/details/17917129">https://blog.csdn.net/richerg85/article/details/17917129&lt;/a>
&lt;a href="https://wiki.archlinux.org/index.php/Fstab_(%25E7%25AE%2580%25E4%25BD%2593%25E4%25B8%25AD%25E6%2596%2587)">https://wiki.archlinux.org/index.php/Fstab_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87)&lt;/a>&lt;/p></description></item><item><title>Docs: service Unit</title><link>https://desistdaydream.github.io/docs/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/3.Systemd-%E7%B3%BB%E7%BB%9F%E5%AE%88%E6%8A%A4%E7%A8%8B%E5%BA%8F/Unit-File/service-Unit/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/3.Systemd-%E7%B3%BB%E7%BB%9F%E5%AE%88%E6%8A%A4%E7%A8%8B%E5%BA%8F/Unit-File/service-Unit/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://man7.org/linux/man-pages/man5/systemd.service.5.html">Manual(手册),systemd.service(5)&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>所有名称以 &lt;code>.service&lt;/code> 结尾的 Unit 都是由 Systemd 控制和监督的进程。说白了，就是一个一个的“服务”，这些“服务”就是一个一个的进程。&lt;/p>
&lt;p>service Unit 是 systemd 使用数量最多，使用频率最高的单元。&lt;/p>
&lt;h1 id="service-指令">service 指令&lt;/h1>
&lt;p>&lt;strong>ExecStart=&lt;!-- raw HTML omitted -->&lt;/strong> # 启动 Unit 所使用的命令
&lt;strong>ExecStartPre=&lt;!-- raw HTML omitted -->&lt;/strong> # 启动 Unit 之前执行的命令
&lt;strong>ExecStartPost=&lt;!-- raw HTML omitted -->&lt;/strong> # 启动 Unit 之后执行的命令
&lt;strong>ExecReload=&lt;!-- raw HTML omitted -->&lt;/strong> # 重启 Unit 时执行的命令
&lt;strong>ExecStop=&lt;!-- raw HTML omitted -->&lt;/strong> # 停止 Unit 时执行的命令
&lt;strong>ExecStopPost=&lt;!-- raw HTML omitted -->&lt;/strong> # 停止 Unit 之后执行的命令
&lt;strong>RemainAfterExit=&lt;/strong> # 即是 Service 启动的所有进程都退出了，该 Service 是否应该被视为活动状态。&lt;code>默认值：no&lt;/code>
&lt;strong>RestartSec=&lt;!-- raw HTML omitted -->&lt;/strong> # 自动重启当前服务间隔的时间，单位为秒。&lt;code>默认值：100ms&lt;/code>
&lt;strong>Restart=&lt;!-- raw HTML omitted -->&lt;/strong> # 定义何种情况 Systemd 会自动重启当前服务。&lt;code>默认值：no&lt;/code>。
可用的值有：no(永不重启)、always(无条件重启)、on-success(仅在服务正常退出时重启)、on-failure()、on-abnormal、on-abort、on-watchdog。
下表描述了当由于何种原因退出时，将会执行重启操作的配置。表中有 X 的表示第一行 Restart 的值在第一列列出的退出原因时，将会重启&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>退出原因(↓)&lt;/th>
&lt;th>Restart= (→)&lt;/th>
&lt;th>&lt;code>no&lt;/code>&lt;/th>
&lt;th>&lt;code>always&lt;/code>&lt;/th>
&lt;th>&lt;code>on-success&lt;/code>&lt;/th>
&lt;th>&lt;code>on-failure&lt;/code>&lt;/th>
&lt;th>&lt;code>on-abnormal&lt;/code>&lt;/th>
&lt;th>&lt;code>on-abort&lt;/code>&lt;/th>
&lt;th>&lt;code>on-watchdog&lt;/code>&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>正常退出&lt;/td>
&lt;td>&lt;/td>
&lt;td>X&lt;/td>
&lt;td>X&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>退出码不为&amp;quot;0&amp;quot;&lt;/td>
&lt;td>&lt;/td>
&lt;td>X&lt;/td>
&lt;td>&lt;/td>
&lt;td>X&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>进程被强制杀死&lt;/td>
&lt;td>&lt;/td>
&lt;td>X&lt;/td>
&lt;td>&lt;/td>
&lt;td>X&lt;/td>
&lt;td>X&lt;/td>
&lt;td>X&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>systemd 操作超时&lt;/td>
&lt;td>&lt;/td>
&lt;td>X&lt;/td>
&lt;td>&lt;/td>
&lt;td>X&lt;/td>
&lt;td>X&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>看门狗超时&lt;/td>
&lt;td>&lt;/td>
&lt;td>X&lt;/td>
&lt;td>&lt;/td>
&lt;td>X&lt;/td>
&lt;td>X&lt;/td>
&lt;td>&lt;/td>
&lt;td>X&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>&lt;strong>TimeoutSec=&lt;!-- raw HTML omitted -->&lt;/strong> # 定义 Systemd 停止当前服务之前等待的秒数
&lt;strong>Type=&lt;!-- raw HTML omitted -->&lt;/strong> # 定义启动时的进程行为。
它有以下几种值：&lt;/p>
&lt;ul>
&lt;li>&lt;strong>simple&lt;/strong> # 默认值，执行 ExecStart 指定的命令，启动主进程&lt;/li>
&lt;li>&lt;strong>forking&lt;/strong> # 以 fork 方式从父进程创建子进程，创建后父进程会立即退出&lt;/li>
&lt;li>&lt;strong>oneshot&lt;/strong> # 一次性进程，Systemd 会等当前服务退出，再继续往下执行&lt;/li>
&lt;li>&lt;strong>dbus&lt;/strong> # 当前服务通过 D-Bus 启动&lt;/li>
&lt;li>&lt;strong>notify&lt;/strong> # 当前服务启动完毕，会通知 Systemd，再继续往下执行&lt;/li>
&lt;li>&lt;strong>idle&lt;/strong> # 若有其他任务执行完毕，当前服务才会运行&lt;/li>
&lt;/ul></description></item><item><title>Docs: timer Unit</title><link>https://desistdaydream.github.io/docs/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/3.Systemd-%E7%B3%BB%E7%BB%9F%E5%AE%88%E6%8A%A4%E7%A8%8B%E5%BA%8F/Unit-File/timer-Unit/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/3.Systemd-%E7%B3%BB%E7%BB%9F%E5%AE%88%E6%8A%A4%E7%A8%8B%E5%BA%8F/Unit-File/timer-Unit/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://man7.org/linux/man-pages/man5/systemd.timer.5.html">Manual(手册),systemd.timer(5)&lt;/a>&lt;/li>
&lt;li>&lt;a href="http://www.ruanyifeng.com/blog/2018/03/systemd-timer.html">阮一峰博客,Systemd 定时器教程&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>所有以 &lt;code>.timer&lt;/code> 结尾的 Unit 都是由 Systemd 控制和监督的定时器任务。这是一个替代 Linux 中的 Crontab 程序的功能。通过 timer 单元，可以通过 systemd 来管理所有定时任务。&lt;/p>
&lt;h1 id="timer-指令">timer 指令&lt;/h1>
&lt;h1 id="阮一峰文章">阮一峰文章&lt;/h1>
&lt;h2 id="一定时任务">一、定时任务&lt;/h2>
&lt;p>所谓定时任务，就是未来的某个或多个时点，预定要执行的任务，比如每五分钟收一次邮件、每天半夜两点分析一下日志等等。&lt;/p>
&lt;p>Linux 系统通常都使用 &lt;a href="https://wiki.archlinux.org/index.php/Cron_%28%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87%29">cron&lt;/a> 设置定时任务，但是 Systemd 也有这个功能，而且优点显著。&lt;/p>
&lt;blockquote>
&lt;ul>
&lt;li>自动生成日志，配合 Systemd 的日志工具，很方便除错&lt;/li>
&lt;li>可以设置内存和 CPU 的使用额度，比如最多使用 50% 的 CPU&lt;/li>
&lt;li>任务可以拆分，依赖其他 Systemd 单元，完成非常复杂的任务&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>下面，我就来演示一个 Systemd 定时任务：每小时发送一封电子邮件。&lt;/p>
&lt;h2 id="二邮件脚本">二、邮件脚本&lt;/h2>
&lt;p>先写一个发邮件的脚本&lt;code>mail.sh&lt;/code>。&lt;/p>
&lt;pre>&lt;code> echo &amp;quot;This is the body&amp;quot; | /usr/bin/mail -s &amp;quot;Subject&amp;quot; [someone@example](mailto:someone@example).com
&lt;/code>&lt;/pre>
&lt;p>上面代码的&lt;code>someone@example.com&lt;/code>，请替换成你的邮箱地址。&lt;/p>
&lt;p>然后，执行这个脚本。&lt;/p>
&lt;blockquote>
&lt;/blockquote>
&lt;pre>&lt;code> $ bash mail.sh
&lt;/code>&lt;/pre>
&lt;p>执行后，你应该就会收到一封邮件，标题为&lt;code>Subject&lt;/code>。&lt;/p>
&lt;p>如果你的 Linux 系统不能发邮件，建议安装 &lt;a href="http://tombuntu.com/index.php/2008/10/21/sending-email-from-your-system-with-ssmtp/">ssmtp&lt;/a> 或者 &lt;a href="https://wiki.archlinux.org/index.php/msmtp">msmtp&lt;/a>。另外，&lt;code>mail&lt;/code>命令的用法，可以参考&lt;a href="https://www.binarytides.com/linux-mail-command-examples/">这里&lt;/a>。&lt;/p>
&lt;h2 id="三systemd-单元">三、Systemd 单元&lt;/h2>
&lt;p>学习 Systemd 的第一步，就是搞懂 &amp;ldquo;单元&amp;rdquo;（unit）是什么。&lt;/p>
&lt;p>简单说，单元就是 Systemd 的最小功能单位，是单个进程的描述。一个个小的单元互相调用和依赖，组成一个庞大的任务管理系统，这就是 Systemd 的基本思想。&lt;/p>
&lt;p>由于 Systemd 要做的事情太多，导致单元有很多&lt;a href="https://www.digitalocean.com/community/tutorials/understanding-systemd-units-and-unit-files">不同的种类&lt;/a>，大概一共有 12 种。举例来说，Service 单元负责后台服务，Timer 单元负责定时器，Slice 单元负责资源的分配。&lt;/p>
&lt;p>每个单元都有一个单元描述文件，它们分散在三个目录。&lt;/p>
&lt;blockquote>
&lt;ul>
&lt;li>&lt;code>/lib/systemd/system&lt;/code>：系统默认的单元文件&lt;/li>
&lt;li>&lt;code>/etc/systemd/system&lt;/code>：用户安装的软件的单元文件&lt;/li>
&lt;li>&lt;code>/usr/lib/systemd/system&lt;/code>：用户自己定义的单元文件&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>下面的命令可以查看所有的单元文件。&lt;/p>
&lt;blockquote>
&lt;/blockquote>
&lt;pre>&lt;code> $ systemctl list-unit-files
$ systemctl list-unit-files --type service
$ systemctl list-unit-files --type timer
&lt;/code>&lt;/pre>
&lt;h2 id="四单元的管理命令">四、单元的管理命令&lt;/h2>
&lt;p>下面是常用的单元管理命令。&lt;/p>
&lt;pre>&lt;code> $ systemctl start [UnitName]
$ systemctl stop [UnitName]
$ systemctl restart [UnitName]
$ systemctl kill [UnitName]
$ systemctl status [UnitName]
$ systemctl enable [UnitName]
$ systemctl disable [UnitName]
&lt;/code>&lt;/pre>
&lt;h2 id="五service-单元">五、Service 单元&lt;/h2>
&lt;p>前面说过，Service 单元就是所要执行的任务，比如发送邮件就是一种 Service。&lt;/p>
&lt;p>新建 Service 非常简单，就是在&lt;code>/usr/lib/systemd/system&lt;/code>目录里面新建一个文件，比如&lt;code>mytimer.service&lt;/code>文件，你可以写入下面的内容。&lt;/p>
&lt;pre>&lt;code> [Unit]
Description=MyTimer
[Service]
ExecStart=/bin/bash /path/to/mail.sh
&lt;/code>&lt;/pre>
&lt;p>可以看到，这个 Service 单元文件分成两个部分。&lt;/p>
&lt;p>&lt;code>[Unit]&lt;/code>部分介绍本单元的基本信息（即元数据），&lt;code>Description&lt;/code>字段给出这个单元的简单介绍（名字叫做&lt;code>MyTimer&lt;/code>）。&lt;/p>
&lt;p>&lt;code>[Service]&lt;/code>部分用来定制行为，Systemd 提供许多字段。&lt;/p>
&lt;blockquote>
&lt;ul>
&lt;li>&lt;code>ExecStart&lt;/code>：&lt;code>systemctl start&lt;/code>所要执行的命令&lt;/li>
&lt;li>&lt;code>ExecStop&lt;/code>：&lt;code>systemctl stop&lt;/code>所要执行的命令&lt;/li>
&lt;li>&lt;code>ExecReload&lt;/code>：&lt;code>systemctl reload&lt;/code>所要执行的命令&lt;/li>
&lt;li>&lt;code>ExecStartPre&lt;/code>：&lt;code>ExecStart&lt;/code>之前自动执行的命令&lt;/li>
&lt;li>&lt;code>ExecStartPost&lt;/code>：&lt;code>ExecStart&lt;/code>之后自动执行的命令&lt;/li>
&lt;li>&lt;code>ExecStopPost&lt;/code>：&lt;code>ExecStop&lt;/code>之后自动执行的命令&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>注意，定义的时候，所有路径都要写成绝对路径，比如&lt;code>bash&lt;/code>要写成&lt;code>/bin/bash&lt;/code>，否则 Systemd 会找不到。&lt;/p>
&lt;p>现在，启动这个 Service。&lt;/p>
&lt;pre>&lt;code> $ sudo systemctl start mytimer.service
&lt;/code>&lt;/pre>
&lt;p>如果一切正常，你应该就会收到一封邮件。&lt;/p>
&lt;h2 id="六timer-单元">六、Timer 单元&lt;/h2>
&lt;p>Service 单元只是定义了如何执行任务，要定时执行这个 Service，还必须定义 Timer 单元。&lt;/p>
&lt;p>&lt;code>/usr/lib/systemd/system&lt;/code>目录里面，新建一个&lt;code>mytimer.timer&lt;/code>文件，写入下面的内容。&lt;/p>
&lt;pre>&lt;code>[Unit]
Description=Runs mytimer every hour
[Timer]
OnUnitActiveSec=1h
Unit=mytimer.service
[Install]
WantedBy=multi-user.target
&lt;/code>&lt;/pre>
&lt;p>这个 Timer 单元文件分成几个部分。&lt;/p>
&lt;p>&lt;code>[Unit]&lt;/code>部分定义元数据。&lt;/p>
&lt;p>&lt;code>[Timer]&lt;/code>部分定制定时器。Systemd 提供以下一些字段。&lt;/p>
&lt;blockquote>
&lt;ul>
&lt;li>&lt;code>OnActiveSec&lt;/code>：定时器生效后，多少时间开始执行任务&lt;/li>
&lt;li>&lt;code>OnBootSec&lt;/code>：系统启动后，多少时间开始执行任务&lt;/li>
&lt;li>&lt;code>OnStartupSec&lt;/code>：Systemd 进程启动后，多少时间开始执行任务&lt;/li>
&lt;li>&lt;code>OnUnitActiveSec&lt;/code>：该单元上次执行后，等多少时间再次执行&lt;/li>
&lt;li>&lt;code>OnUnitInactiveSec&lt;/code>： 定时器上次关闭后多少时间，再次执行&lt;/li>
&lt;li>&lt;code>OnCalendar&lt;/code>：基于绝对时间，而不是相对时间执行&lt;/li>
&lt;li>&lt;code>AccuracySec&lt;/code>：如果因为各种原因，任务必须推迟执行，推迟的最大秒数，默认是 60 秒&lt;/li>
&lt;li>&lt;code>Unit&lt;/code>：真正要执行的任务，默认是同名的带有&lt;code>.service&lt;/code>后缀的单元&lt;/li>
&lt;li>&lt;code>Persistent&lt;/code>：如果设置了该字段，即使定时器到时没有启动，也会自动执行相应的单元&lt;/li>
&lt;li>&lt;code>WakeSystem&lt;/code>：如果系统休眠，是否自动唤醒系统&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>上面的脚本里面，&lt;code>OnUnitActiveSec=1h&lt;/code>表示一小时执行一次任务。其他的写法还有&lt;code>OnUnitActiveSec=*-*-* 02:00:00&lt;/code>表示每天凌晨两点执行，&lt;code>OnUnitActiveSec=Mon *-*-* 02:00:00&lt;/code>表示每周一凌晨两点执行，具体请参考&lt;a href="https://www.freedesktop.org/software/systemd/man/systemd.time.html">官方文档&lt;/a>。&lt;/p>
&lt;h2 id="七install-和-target">七、[Install] 和 target&lt;/h2>
&lt;p>&lt;code>mytimer.timer&lt;/code>文件里面，还有一个&lt;code>[Install]&lt;/code>部分，定义开机自启动（&lt;code>systemctl enable&lt;/code>）和关闭开机自启动（&lt;code>systemctl disable&lt;/code>）这个单元时，所要执行的命令。&lt;/p>
&lt;p>上面脚本中，&lt;code>[Install]&lt;/code>部分只写了一个字段，即&lt;code>WantedBy=multi-user.target&lt;/code>。它的意思是，如果执行了&lt;code>systemctl enable mytimer.timer&lt;/code>（只要开机，定时器自动生效），那么该定时器归属于&lt;code>multi-user.target&lt;/code>。&lt;/p>
&lt;p>所谓 Target 指的是一组相关进程，有点像 init 进程模式下面的启动级别。启动某个 Target 的时候，属于这个 Target 的所有进程都会全部启动。&lt;/p>
&lt;p>&lt;code>multi-user.target&lt;/code>是一个最常用的 Target，意为多用户模式。也就是说，当系统以多用户模式启动时，就会一起启动&lt;code>mytimer.timer&lt;/code>。它背后的操作其实很简单，执行&lt;code>systemctl enable mytimer.timer&lt;/code>命令时，就会在&lt;code>multi-user.target.wants&lt;/code>目录里面创建一个符号链接，指向&lt;code>mytimer.timer&lt;/code>。&lt;/p>
&lt;h2 id="八定时器的相关命令">八、定时器的相关命令&lt;/h2>
&lt;p>下面，启动刚刚新建的这个定时器。&lt;/p>
&lt;pre>&lt;code> $ sudo systemctl start mytimer.timer
&lt;/code>&lt;/pre>
&lt;p>你应该立刻就会收到邮件，然后每个小时都会收到同样邮件。&lt;/p>
&lt;p>查看这个定时器的状态。&lt;/p>
&lt;pre>&lt;code> $ systemctl status mytimer.timer
&lt;/code>&lt;/pre>
&lt;p>查看所有正在运行的定时器。&lt;/p>
&lt;pre>&lt;code> $ systemctl list-timers
&lt;/code>&lt;/pre>
&lt;p>关闭这个定时器。&lt;/p>
&lt;pre>&lt;code> $ sudo systemctl stop myscript.timer
&lt;/code>&lt;/pre>
&lt;p>下次开机，自动运行这个定时器。&lt;/p>
&lt;pre>&lt;code> $ sudo systemctl enable myscript.timer
&lt;/code>&lt;/pre>
&lt;p>关闭定时器的开机自启动。&lt;/p>
&lt;pre>&lt;code> $ sudo systemctl disable myscript.timer
&lt;/code>&lt;/pre>
&lt;h2 id="九日志相关命令">九、日志相关命令&lt;/h2>
&lt;p>如果发生问题，就需要查看日志。Systemd 的日志功能很强，提供统一的命令。&lt;/p>
&lt;pre>&lt;code>$ sudo journalctl
$ sudo journalctl -u mytimer.timer
$ sudo journalctl -u mytimer
$ sudo journalctl -f
$ journalctl -f -u timer.timer
&lt;/code>&lt;/pre>
&lt;h2 id="十参考链接">十、参考链接&lt;/h2>
&lt;ul>
&lt;li>&lt;a href="https://jason.the-graham.com/2013/03/06/how-to-use-systemd-timers/">How to Use Systemd Timers&lt;/a>, by Jason Graham&lt;/li>
&lt;li>&lt;a href="https://medium.com/horrible-hacks/using-systemd-as-a-better-cron-a4023eea996d">Using systemd as a better cron&lt;/a>, by luqmaan&lt;/li>
&lt;li>&lt;a href="https://coreos.com/os/docs/latest/getting-started-with-systemd.html">Getting started with systemd&lt;/a>, by CoreOS&lt;/li>
&lt;li>&lt;a href="https://wiki.archlinux.org/index.php/Systemd/Timers">systemd/Timers&lt;/a>, by ArchWiki&lt;/li>
&lt;li>&lt;a href="https://www.digitalocean.com/community/tutorials/understanding-systemd-units-and-unit-files">Understanding Systemd Units and Unit Files&lt;/a>, by Justin Ellingwood&lt;/li>
&lt;/ul>
&lt;p>（完）&lt;/p></description></item><item><title>Docs: Unit File</title><link>https://desistdaydream.github.io/docs/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/3.Systemd-%E7%B3%BB%E7%BB%9F%E5%AE%88%E6%8A%A4%E7%A8%8B%E5%BA%8F/Unit-File/Unit-File/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/3.Systemd-%E7%B3%BB%E7%BB%9F%E5%AE%88%E6%8A%A4%E7%A8%8B%E5%BA%8F/Unit-File/Unit-File/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://man.cx/systemd.unit(5)">manual(手册),systemd.unit(5)&lt;/a> # Unit 的介绍&lt;/li>
&lt;li>&lt;a href="https://man.cx/systemd.syntax(7)">manual(手册),systemd.syntax(7)&lt;/a> # Unit 的配置语法&lt;/li>
&lt;li>&lt;a href="http://www.jinbuguo.com/systemd/systemd.unit.html#">金步国 systemd.unit 中文手册&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>&lt;strong>Unit File&lt;/strong>，是 &lt;a href="https://desistdaydream.github.io/docs/2.%E7%BC%96%E7%A8%8B/%E6%97%A0%E6%B3%95%E5%88%86%E7%B1%BB%E7%9A%84%E8%AF%AD%E8%A8%80/INI.md">ini 格式&lt;/a>的纯文本文件。在这个文件中，由 &lt;strong>Directives(指令)&lt;/strong> 和 &lt;strong>Sections(部分)&lt;/strong> 组成，这里的 Directve 就是 INI 格式中的 &lt;code>键/值对&lt;/code>。&lt;/p>
&lt;ul>
&lt;li>&lt;strong>Directives(指令)&lt;/strong> # 指令由 名称 与 值 组成，以 &lt;code>=&lt;/code> 分割&lt;/li>
&lt;li>&lt;strong>Sections(部分)&lt;/strong> # 与 INI 中的 Sections 概念一样。是一组 Directives 的集合&lt;/li>
&lt;/ul>
&lt;p>Unit File 与 INI 格式文件不同的地方是关于注释，Unit File 使用 &lt;code>#&lt;/code> 作为注释行的开头。&lt;/p>
&lt;h2 id="unit-file-最简单示例">Unit File 最简单示例&lt;/h2>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">[&lt;/span>Unit&lt;span style="color:#f92672">]&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># Unit 的描述&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Description&lt;span style="color:#f92672">=&lt;/span>Foo
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">[&lt;/span>Service&lt;span style="color:#f92672">]&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># 如何启动该 Unit&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>ExecStart&lt;span style="color:#f92672">=&lt;/span>/usr/sbin/foo-daemon
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">[&lt;/span>Install&lt;span style="color:#f92672">]&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># 当 enable 该 Unit 时，应该在 multi-user.tartet.wants/ 目录中创建软链接&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>WantedBy&lt;span style="color:#f92672">=&lt;/span>multi-user.target
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h1 id="unit-file-配置">Unit File 配置&lt;/h1>
&lt;p>&lt;strong>/etc/systemd/system/*&lt;/strong> # Unit File 的存放路径，具有最高优先级&lt;/p>
&lt;ul>
&lt;li>&lt;strong>./UnitName.d/*.conf&lt;/strong> # Unit File 的 include 功能，该路径下的的以 .conf 结尾的文件，将会附加到主 Unit File 中&lt;/li>
&lt;li>.&lt;strong>/UnitName.wants/*&lt;/strong> # 与 include 功能类似，区别在于，该路径下的文件都是其他 Unit File 的软链接，这些 Unit File 的文件名将会作为主 Unit File 配置中 [Unit] 部分中 Wants 指令的值。&lt;/li>
&lt;li>.&lt;strong>/UnitName.requires/*&lt;/strong> # 与 include 功能类似，区别在于，该路径下的文件都是其他 Unit File 的软链接，这些 Unit File 的文件名将会作为主 Unit File 配置中 [Unit] 部分中 Requires 指令的值。&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>/run/systemd/system/*&lt;/strong> # Unit File 的存放路径，具有中等优先级&lt;/p>
&lt;ul>
&lt;li>&lt;strong>./UnitName.d/*.conf&lt;/strong> # Unit File 的 include 功能，该路径下的的以 .conf 结尾的文件，将会附加到主 Unit File 中&lt;/li>
&lt;li>.&lt;strong>/UnitName.wants/*&lt;/strong> # 与 include 功能类似，区别在于，该路径下的文件都是其他 Unit File 的软链接，这些 Unit File 的文件名将会作为主 Unit File 配置中 [Unit] 部分中 Wants 指令的值。&lt;/li>
&lt;li>.&lt;strong>/UnitName.requires/*&lt;/strong> # 与 include 功能类似，区别在于，该路径下的文件都是其他 Unit File 的软链接，这些 Unit File 的文件名将会作为主 Unit File 配置中 [Unit] 部分中 Requires 指令的值。&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>/usr/lib/systemd/system/*&lt;/strong> # Unit File 的存放路径，具有最低优先级&lt;/p>
&lt;ul>
&lt;li>&lt;strong>./UnitName.d/*.conf&lt;/strong> # Unit File 的 include 功能，该路径下的的以 .conf 结尾的文件，将会附加到主 Unit File 中&lt;/li>
&lt;li>.&lt;strong>/UnitName.wants/*&lt;/strong> # 与 include 功能类似，区别在于，该路径下的文件都是其他 Unit File 的软链接，这些 Unit File 的文件名将会作为主 Unit File 配置中 [Unit] 部分中 Wants 指令的值。&lt;/li>
&lt;li>.&lt;strong>/UnitName.requires/*&lt;/strong> # 与 include 功能类似，区别在于，该路径下的文件都是其他 Unit File 的软链接，这些 Unit File 的文件名将会作为主 Unit File 配置中 [Unit] 部分中 Requires 指令的值。&lt;/li>
&lt;/ul>
&lt;p>Systemd 会从最低优先级的目录 /usr/lib/&lt;em>下开始加载配置，注意加载其中的文件，直到最高优先级的目录 /etc/systemd/&lt;/em> 为止。&lt;/p>
&lt;h1 id="unit-file-规范">Unit File 规范&lt;/h1>
&lt;h2 id="unit-file-名称">Unit File 名称&lt;/h2>
&lt;p>一个有效的 Unit File 名称由三部分组成&lt;/p>
&lt;ul>
&lt;li>&lt;strong>NAME&lt;/strong> # Unit 的名称。&lt;/li>
&lt;li>&lt;strong>DOT&lt;/strong> # &lt;code>.&lt;/code> 符号。&lt;/li>
&lt;li>&lt;strong>TYPE&lt;/strong># Unit 的类型。
&lt;ul>
&lt;li>TYPE 必须是 &amp;ldquo;.service&amp;rdquo;, &amp;ldquo;.socket&amp;rdquo;, &amp;ldquo;.device&amp;rdquo;, &amp;ldquo;.mount&amp;rdquo;, &amp;ldquo;.automount&amp;rdquo;, &amp;ldquo;.swap&amp;rdquo;, &amp;ldquo;.target&amp;rdquo;, &amp;ldquo;.path&amp;rdquo;, &amp;ldquo;.timer&amp;rdquo;, &amp;ldquo;.slice&amp;rdquo;, or &amp;ldquo;.scope&amp;rdquo; 中的一个。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>比如 &lt;code>foo.server&lt;/code> 就是一个有效的 Unit File 名称。&lt;/p>
&lt;p>除了手册中列出的选项之外，单元文件还可以包含更多其他选项。 无法识别的选项不会中断单元文件的加载，但是 systemd 会输出一条警告日志。 如果选项或者小节的名字以 &lt;code>X-&lt;/code> 开头， 那么 systemd 将会完全忽略它。 以 &lt;code>X-&lt;/code> 开头的小节中的选项没必要再以 &lt;code>X-&lt;/code> 开头， 因为整个小节都已经被忽略。 应用程序可以利用这个特性在单元文件中包含额外的信息。&lt;/p>
&lt;p>如果想要给一个单元赋予别名，那么可以按照需求，在系统单元目录或用户单元目录中， 创建一个软连接(以别名作为文件名)，并将其指向该单元的单元文件。 例如 &lt;code>systemd-networkd.service&lt;/code> 在安装时就通过 &lt;code>/usr/lib/systemd/system/dbus-org.freedesktop.network1.service&lt;/code> 软连接创建了 &lt;code>dbus-org.freedesktop.network1.service&lt;/code> 别名。 此外，还可以直接在单元文件的 [Install] 部分中使用 &lt;code>Alias=&lt;/code> 创建别名。 注意，单元文件中设置的别名会随着单元的启用(enable)与禁用(disable)而生效和失效， 也就是别名软连接会随着单元的启用(enable)与禁用(disable)而创建与删除。 例如，因为 &lt;code>reboot.target&lt;/code> 单元文件中含有 &lt;code>Alias=ctrl-alt-del.target&lt;/code> 的设置，所以启用(enable)此单元之后，按下 CTRL+ALT+DEL 组合键将会导致启动该单元。单元的别名可以用于 &lt;strong>enable&lt;/strong>, &lt;strong>disable&lt;/strong>, &lt;strong>start&lt;/strong>, &lt;strong>stop&lt;/strong>, &lt;strong>status&lt;/strong>, … 这些命令中，也可以用于 &lt;code>Wants=&lt;/code>, &lt;code>Requires=&lt;/code>, &lt;code>Before=&lt;/code>, &lt;code>After=&lt;/code>, … 这些依赖关系选项中。 但是务必注意，不可将单元的别名用于 &lt;strong>preset&lt;/strong> 命令中。 再次提醒，通过 &lt;code>Alias=&lt;/code> 设置的别名仅在单元被启用(enable)之后才会生效。&lt;/p>
&lt;h2 id="unit-file-模板--多实例">Unit File 模板 &amp;amp;&amp;amp; 多实例&lt;/h2>
&lt;p>Unit File 可以通过 &lt;code>@&lt;/code> 符号声明一个&lt;strong>模板文件&lt;/strong>，通过在 &lt;code>@&lt;/code> 添加字符串，可以根据模板文件，生成一个&lt;strong>实例文件&lt;/strong>。经过实例化后的实例文件，就是一个真实可用的 Unit File 了&lt;/p>
&lt;p>就拿 Wireguard 的 Unit File 为例&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">[&lt;/span>lichenhao@hw-cloud-xngy-jump-server-linux-2 ~&lt;span style="color:#f92672">]&lt;/span>$ systemctl cat wg-quick@.service
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># /lib/systemd/system/wg-quick@.service&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">[&lt;/span>Unit&lt;span style="color:#f92672">]&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Description&lt;span style="color:#f92672">=&lt;/span>WireGuard via wg-quick&lt;span style="color:#f92672">(&lt;/span>8&lt;span style="color:#f92672">)&lt;/span> &lt;span style="color:#66d9ef">for&lt;/span> %I
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>After&lt;span style="color:#f92672">=&lt;/span>network-online.target nss-lookup.target
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Wants&lt;span style="color:#f92672">=&lt;/span>network-online.target nss-lookup.target
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>PartOf&lt;span style="color:#f92672">=&lt;/span>wg-quick.target
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">[&lt;/span>Service&lt;span style="color:#f92672">]&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Type&lt;span style="color:#f92672">=&lt;/span>oneshot
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>RemainAfterExit&lt;span style="color:#f92672">=&lt;/span>yes
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>ExecStart&lt;span style="color:#f92672">=&lt;/span>/usr/bin/wg-quick up %i
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>ExecStop&lt;span style="color:#f92672">=&lt;/span>/usr/bin/wg-quick down %i
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Environment&lt;span style="color:#f92672">=&lt;/span>WG_ENDPOINT_RESOLUTION_RETRIES&lt;span style="color:#f92672">=&lt;/span>infinity
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">[&lt;/span>Install&lt;span style="color:#f92672">]&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>WantedBy&lt;span style="color:#f92672">=&lt;/span>multi-user.target
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>上面就是一个模板文件，我们需要实例化他，那么只需要在 &lt;code>@&lt;/code> 符号后面添加字符串即可，&lt;code>systemctl enable wg-quick@wg0.service&lt;/code>，此时，将会生成如下 Unit File&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">[&lt;/span>lichenhao@hw-cloud-xngy-jump-server-linux-2 ~&lt;span style="color:#f92672">]&lt;/span>$ systemctl cat wg-quick@wg0.service
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># /lib/systemd/system/wg-quick@.service&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">[&lt;/span>Unit&lt;span style="color:#f92672">]&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Description&lt;span style="color:#f92672">=&lt;/span>WireGuard via wg-quick&lt;span style="color:#f92672">(&lt;/span>8&lt;span style="color:#f92672">)&lt;/span> &lt;span style="color:#66d9ef">for&lt;/span> %I
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>After&lt;span style="color:#f92672">=&lt;/span>network-online.target nss-lookup.target
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Wants&lt;span style="color:#f92672">=&lt;/span>network-online.target nss-lookup.target
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>PartOf&lt;span style="color:#f92672">=&lt;/span>wg-quick.target
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">[&lt;/span>Service&lt;span style="color:#f92672">]&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Type&lt;span style="color:#f92672">=&lt;/span>oneshot
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>RemainAfterExit&lt;span style="color:#f92672">=&lt;/span>yes
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>ExecStart&lt;span style="color:#f92672">=&lt;/span>/usr/bin/wg-quick up %i
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>ExecStop&lt;span style="color:#f92672">=&lt;/span>/usr/bin/wg-quick down %i
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Environment&lt;span style="color:#f92672">=&lt;/span>WG_ENDPOINT_RESOLUTION_RETRIES&lt;span style="color:#f92672">=&lt;/span>infinity
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">[&lt;/span>Install&lt;span style="color:#f92672">]&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>WantedBy&lt;span style="color:#f92672">=&lt;/span>multi-user.target
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>当我们启动该服务时，其实就是执行了 ExecStart 指令中的命令，并且 &lt;code>%i&lt;/code> 被替换成了 wg0，即 &lt;code>/usr/bin/wg-quick up wg0&lt;/code>&lt;/p>
&lt;p>这种模板化的 Unit File 特别适合这种服务来使用，还有那些配置 TTY、磁盘名称的，都可以将想要实例化的 TTY 或者 分区，作为 %i 配置。&lt;/p>
&lt;h2 id="drop-in嵌入式-unit-file就是-include-功能">drop-in(嵌入式) Unit File(就是 include 功能)&lt;/h2>
&lt;p>&lt;strong>drop-in(嵌入式)&lt;/strong> 单元文件就是一种类似配置文件的 &lt;strong>include&lt;/strong>的功能(比如 Nginx 中的 include 指令)，可以让主配置文件包含其他子配置文件。&lt;strong>Systemd 设定了两种 include 的规范&lt;/strong>&lt;/p>
&lt;p>假如现在有一个名为 &lt;code>foo.service&lt;/code> 的 Unit File，那么，&lt;a href="https://www.yuque.com/desistdaydream/learning/sa1uqi#o317e">Systemd 会从加载 Unit File 的目录&lt;/a>中，加载与之相关联的一系列文件&lt;/p>
&lt;ul>
&lt;li>**UnitFileName.wants/ 与 UnitFileName.requires/ #**比如 foo.service.wants/  与  foo.service.requires/。该目录中可以放置许多指向其他 Unit Files 的软连接。 软连接所指向的 Unit 将会被当做  &lt;code>foo.service&lt;/code>  的 Unit 文件中  &lt;code>Wants=&lt;/code>  与  &lt;code>Requires=&lt;/code>  指令的值(
&lt;ul>
&lt;li>注意：即使文件中不存在 Wants 和 Requires 指令。只要存在对应的 &lt;em>.wants/ 和&lt;/em>.requires/ 目录，就相当于为 Unit File 中加上了这两个指令。&lt;/li>
&lt;li>这样就可以方便的为 Unit 添加依赖关系，而无需修改单元文件本身。 向  &lt;code>*.wants/&lt;/code>  与  &lt;code>*.requires/&lt;/code>  目录中添加软连接的首选方法是使用  &lt;a href="http://www.jinbuguo.com/systemd/systemctl.html#">systemctl(1)&lt;/a>  的  &lt;strong>enable&lt;/strong>  命令， 它会读取 Unit File 的 [Install] 部分。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>UnitFileName.d/&lt;/strong> # 比如 foo.service.d/** **。这就是配置文件的 include 功能。当解析完主 Unit File 之后，该目录中所有以 &lt;code>.conf&lt;/code> 结尾的文件，都会被依次附加到主 Unit File 的末尾。
&lt;ul>
&lt;li>这样就可以方便的修改 Unit 的设置，或者为 Unit 添加额外的设置，而无需修改 Unit File 本身。&lt;/li>
&lt;li>注意，include 功能中的文件遵守如下规则：
&lt;ul>
&lt;li>必须包含明确的 Sections (例如 &lt;code>[Service]&lt;/code> 之类)。&lt;/li>
&lt;li>对于从模板文件实例化而来的 Unit，会优先读取与此实例对应的 &lt;code>UnitFileName.d/&lt;/code> 目录(例如 &amp;ldquo;&lt;code>foo@bar.service.d/&lt;/code>&amp;quot;)中的配置片段(&lt;code>*.conf&lt;/code> 文件)， 然后才会读取与模板对应的 &amp;ldquo;&lt;code>.d/&lt;/code>&amp;rdquo; 目录(例如 &amp;ldquo;&lt;code>foo@.service.d/&lt;/code>&amp;quot;)中的配置片段(&amp;quot;&lt;code>.conf&lt;/code>&amp;rdquo; 文件)。&lt;/li>
&lt;li>对于名称中包含连字符(&amp;quot;&lt;code>-&lt;/code>&amp;quot;)的单元，将会按特定顺序依次在一组(而不是一个)目录中搜索单元配置片段。 例如对于  &lt;code>foo-bar-baz.service&lt;/code>  单元来说，将会依次在  &lt;code>foo-.service.d/&lt;/code>, &lt;code>foo-bar-.service.d/&lt;/code>, &lt;code>foo-bar-baz.service.d/&lt;/code>  目录下搜索单元配置片段。
&lt;ul>
&lt;li>这个机制可以方便的为一组相关单元(单元名称的前缀都相同)定义共同的单元配置片段， 特别适合应用于 mount, automount, slice 类型的单元， 因为这些单元的命名规则就是基于连字符构建的。&lt;/li>
&lt;li>注意，在前缀层次结构的下层目录中的单元配置片段，会覆盖上层目录中的同名文件， 也就是  &lt;code>foo-bar-.service.d/10-override.conf&lt;/code>  会覆盖(取代) &lt;code>foo-.service.d/10-override.conf&lt;/code>  文件。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>注意：通常情况下，drop-in Unit File 放在 &lt;code>/etc/systemd/{system,user}&lt;/code>  目录中， 还可以放置在  &lt;code>/usr/lib/systemd/{system,user}&lt;/code>  与  &lt;code>/run/systemd/{system,user}&lt;/code>  目录中。 虽然在优先级上，&lt;code>/etc&lt;/code>  中的配置片段优先级最高、&lt;code>/run&lt;/code>  中的配置片段优先级居中、 &lt;code>/usr/lib&lt;/code>  中的配置片段优先级最低。但是这仅对同名配置片段之间的覆盖关系有意义。 因为所有 &lt;code>.d/&lt;/code> 目录中的配置片段，无论其位于哪个目录， 都会被按照文件名的字典顺序，依次覆盖单元文件中的设置(相当于依次附加到主单元文件的末尾)。&lt;/p>
&lt;h3 id="drop-in-示例">drop-in 示例&lt;/h3>
&lt;ul>
&lt;li>/usr/lib/systemd/system/ssh.service # ssh 这个 Unit 的主配置文件&lt;/li>
&lt;li>/etc/systemd/system/ssh.service.d/CUSTOM.conf # 在 /etc/systemd/system 下面创建与配置文件相同文件名的目录,但是要加上 .d 的扩展名。然后在该目录下创建 .conf 结尾的配置文件即可。&lt;/li>
&lt;li>/etc/systemd/system/vsftpd.service.wants/ # 此目录内的文件为链接文件,设置相依服务的链接。意思是启动了 vsftpd.service 之后,最好再加上这目录下面建议的服务。&lt;/li>
&lt;li>/etc/systemd/system/vsftpd.service.requires/ # 此目录内的文件为链接文件,设置相依服务的链接。意思是在启动 vsftpd.service 之前,需要事先启动哪些服务的意思。&lt;/li>
&lt;/ul>
&lt;p>配置文件分为 4 种状态，当启用(enable)该文件的时候，从配置文件目录建立一个软连接到 /etc/systemd/system/ 目录下，当禁用(disable)该文件的时候，会把该软连接删除。如果在/etc/systemd/system/目录下有 Unit 的配置文件，则开机则会自动加载并启动 Unit。可以使用命令 systemctl list-unit-files 命令查看所有的配置文件状态。结论：建立了连接则说明该 Unit 会开机启动，没建立连接则该 Unit 不会开机启动；还可以禁止该 Unit 建立连接，则说明该 Unit 永远不能开机启动。
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/gvdc29/1620129636770-82d464a7-f1ef-4e5c-9749-61b258d1b0e6.png" alt="image.png">&lt;/p>
&lt;ul>
&lt;li>enabled：启用(该文件已建立链接)&lt;/li>
&lt;li>disabled：禁用(该文件没建立链接)&lt;/li>
&lt;li>static：这个文件不可以被建立链接，但是可以被其他服务进行关联启动&lt;/li>
&lt;li>masked：该配置文件被禁止建立启动链接，可以使用 systemctl unmask 命令开启&lt;/li>
&lt;/ul>
&lt;h2 id="总结以及注意事项">总结以及注意事项&lt;/h2>
&lt;p>在使用 systemctl 命令时，会有两个子命令，systemctl list-units 和 systemctl list-unit-files，这俩命令的区别如下&lt;/p>
&lt;ul>
&lt;li>list-units 是列出已经载入的 Unit(加上-a 选项可以看 start 和 stop 所有的)，其中还包括各种.device 的 unit，这类设备是硬件，没有配置文件的，不会再 list-unit-files 命令下列出来&lt;/li>
&lt;li>list-unit-files 是列出所有已经安装的 Unit 的配置文件(有一部分 Unit 是没有配置文件的)，安装完的 Unit 会把配置文件存放在/lib/systemd/system/目录下，而且通过查看 list-unit-files 还能看出来是否是开机启动，具体原因请见下文的《systemd 的 unit 配置文件说明》&lt;/li>
&lt;li>如果一个单元文件的大小为零字节或者是指向 &lt;code>/dev/null&lt;/code> 的软连接， 那么它的所有相关配置都将被忽略。同时，该单元将被标记为 &amp;ldquo;&lt;code>masked&lt;/code>&amp;rdquo; 状态，并且无法被启动。 这样就可以 彻底屏蔽一个单元(即使手动启动也不行)。&lt;/li>
&lt;/ul>
&lt;h1 id="各种-unit-额外说明">各种 Unit 额外说明&lt;/h1>
&lt;h2 id="target-unit">Target Unit&lt;/h2>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/gvdc29/1616167393736-e7bb0f5d-83be-4d38-856d-a22c56e9fab1.jpeg" alt="">
启动计算机的时候，需要启动大量的 Unit。如果每一次启动，都要一一写明本次启动需要哪些 Unit，显然非常不方便。Systemd 的解决方案就是 Target。&lt;/p>
&lt;p>简单说，Target 就是一个 Unit 组，包含许多相关的 Unit 。启动某个 Target 的时候，Systemd 就会启动里面所有的 Unit。从这个意义上说，Target 这个概念类似于&amp;quot;状态点&amp;rdquo;，启动某个 Target 就好比启动到某种状态。&lt;/p>
&lt;p>注意&lt;/p>
&lt;ol>
&lt;li>在启动系统的时候，也是首先通过查询 target 中的内容，以便启动相应的 Unit&lt;/li>
&lt;li>传统的 init 启动模式里面，有 RunLevel 的概念，Target 就能起到同样的效果。不同的是，RunLevel 是互斥的，不可能多个 RunLevel 同时启动，但是多个 Target 可以同时启动，并且更加灵活，可以自己定义每个 Target 可以包含的 Unit。比如启动 graphical.target 则里面就包含运行图形界面的 Unit 和 multi-user.target 中的所有 Unit。&lt;/li>
&lt;li>我们可以通过 systemctl set-default UNIT 命令来设定系统启动时，默认启动的一组 Unit&lt;/li>
&lt;/ol>
&lt;h1 id="unit-file-加载示例">Unit File 加载示例&lt;/h1>
&lt;p>可以通过 &lt;a href="https://desistdaydream.github.io/docs/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/0.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E7%B3%BB%E7%BB%9F%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B.md">系统启动流程&lt;/a> 看出来 Systemd 是如何加载 Unit File 的&lt;/p></description></item><item><title>Docs: Unit File 指令</title><link>https://desistdaydream.github.io/docs/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/3.Systemd-%E7%B3%BB%E7%BB%9F%E5%AE%88%E6%8A%A4%E7%A8%8B%E5%BA%8F/Unit-File/Unit-File-%E6%8C%87%E4%BB%A4/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/3.Systemd-%E7%B3%BB%E7%BB%9F%E5%AE%88%E6%8A%A4%E7%A8%8B%E5%BA%8F/Unit-File/Unit-File-%E6%8C%87%E4%BB%A4/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://man7.org/linux/man-pages/man7/systemd.directives.7.html">Manual(手册),systemd.directives(7)&lt;/a> # Unit File 中全部的指令列表&lt;/li>
&lt;li>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>一个 Unit File 具有多个 Sections，大体可以分为 2 类&lt;/p>
&lt;ul>
&lt;li>通用 Sections # 与 Unit 类型无关的部分
&lt;ul>
&lt;li>[Unit] 与 [Install]&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>特殊 Sections # 特定于 Unit 类型的部分
&lt;ul>
&lt;li>[Service]、[Socket]、[Timer]、[Mount]、[Path] 等等&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>除了 Unit 和 Install 以外的其余每个 Sections(部分) 都有其特定的 Directives(指令)，同时，也有一些通用的 Directives(指令) 可以用在多个 Sections(部分) 中。&lt;/p>
&lt;h1 id="通用部分的指令">通用部分的指令&lt;/h1>
&lt;h2 id="unithttpsman7orglinuxman-pagesman5systemdunit5htmlunit_section_options-部分的指令">&lt;a href="https://man7.org/linux/man-pages/man5/systemd.unit.5.html#%5BUNIT%5D_SECTION_OPTIONS">[Unit]&lt;/a> 部分的指令&lt;/h2>
&lt;p>unit 本身的说明，以及与其他相依赖的 daemon 的设置，包括在什么服务之前或之后启动等设置
&lt;strong>Description=&amp;lt;STRING&amp;gt;&lt;/strong> # Unit 描述，用 systemctl list-units 和 systemctl status 查看服务时候的描述内容就是这里定义的
&lt;strong>Documentation=&amp;lt;STRING&amp;gt;&lt;/strong> # 提供该 Unit 可以进一步文件查询的地址或者位置
&lt;strong>After(Before)=&amp;lt;STRING&amp;gt;&lt;/strong> # 在哪些之后(前)启动，说明该 Unit 可以在哪些 daemon 启动后(前)才能够启动，非强制性，只是推荐规范
&lt;strong>Requires=&amp;lt;STRING&amp;gt;&lt;/strong> # 需要启动哪些，说明启动该 Unit 前需要启动哪些 Unit，强制性的，如果不启动该项定义的 Unit 则无法启动该 Unit
&lt;strong>Wants=&amp;lt;STRING&amp;gt;&lt;/strong> # 想要启动哪些，与 Requires 相反，说明启动该 Unit 后想要启动哪些 Unit，非强制
&lt;strong>Conflicts=&amp;lt;STRING&amp;gt;&lt;/strong> # 代表该 Unit 与列表中的 daemon 有冲突，如果该设置里的服务启动了，那么这个 Unit 就不能启动&lt;/p>
&lt;h2 id="installhttpsman7orglinuxman-pagesman5systemdunit5htmlinstall_section_options-部分的指令">&lt;a href="https://man7.org/linux/man-pages/man5/systemd.unit.5.html#%5BINSTALL%5D_SECTION_OPTIONS">[Install]&lt;/a> 部分的指令&lt;/h2>
&lt;p>Install 部分包含 Unit 的启动信息。通常是配置文件的最后一个区块，用来定义如何启动，以及是否开机启动等等。
&lt;strong>WantedBy=&amp;lt;STRING&amp;gt;&lt;/strong> # 它的值是一个或多个 Target，当前 Unit 激活时（enable）符号链接会放入/etc/systemd/system/目录下面以 Target 名 + .wants 后缀构成的子目录中
&lt;strong>RequiredBy=&amp;lt;STRING&amp;gt;&lt;/strong> # 它的值是一个或多个 Target，当前 Unit 激活时，符号链接会放入/etc/systemd/system 目录下面以 Target 名 + .required 后缀构成的子目录中
&lt;strong>Alias=&amp;lt;STRING&amp;gt;&lt;/strong> # 当前 Unit 可用于启动的别名
&lt;strong>Also=&amp;lt;STRING&amp;gt;&lt;/strong> # 当前 Unit 激活（enable）时，会被同时激活的其他 Unit&lt;/p>
&lt;h1 id="特殊部分的指令">特殊部分的指令&lt;/h1>
&lt;p>不同的 Unit 类型就使用对应的部分，在这里面设定 启动程序的命令、环境配置、重启方式 等等。&lt;/p>
&lt;p>每个 特殊 Sections(部分) 都有其特定的 Directives(指令)，同时，也有一些通用的 Directives(指令) 可以用在多个 特殊 Sections(部分) 中。&lt;/p>
&lt;h2 id="通用指令">通用指令&lt;/h2>
&lt;h3 id="systemdexechttpsman7orglinuxman-pagesman5systemdexec5html-类指令">&lt;a href="https://man7.org/linux/man-pages/man5/systemd.exec.5.html">systemd.exec&lt;/a> 类指令&lt;/h3>
&lt;p>systemd.exec 类的指令用于配置进程执行时的环境，比如 环境变量、运行程序的用户和组、运行路径 等等&lt;/p>
&lt;ul>
&lt;li>用于 service、socket、mount、swap 部分&lt;/li>
&lt;/ul>
&lt;p>&lt;a href="https://man7.org/linux/man-pages/man5/systemd.exec.5.html#PATHS">&lt;strong>PATHS(路径)&lt;/strong>&lt;/a>&lt;strong>相关指令&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>&lt;strong>WorkingDirectory=&amp;lt;STRING&amp;gt;&lt;/strong> # 采用相对于由 RootDirectory 指令 或特殊值 &lt;code>~&lt;/code> 指定的服务根目录的目录路径。&lt;/li>
&lt;/ul>
&lt;p>&lt;a href="https://man7.org/linux/man-pages/man5/systemd.exec.5.html#USER/GROUP_IDENTITY">&lt;strong>USER/GROUP IDENTITY(用户/组标识)&lt;/strong>&lt;/a>&lt;strong>相关指令&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>&lt;strong>User=&amp;lt;STRING&amp;gt;&lt;/strong> # 指定运行该 Unit 使用的用户。&lt;/li>
&lt;/ul>
&lt;p>&lt;a href="https://man7.org/linux/man-pages/man5/systemd.exec.5.html#CAPABILITIES">&lt;strong>CAPABILITIES(能力)&lt;/strong>&lt;/a>&lt;strong>相关指令&lt;/strong>&lt;/p>
&lt;p>&lt;a href="https://man7.org/linux/man-pages/man5/systemd.exec.5.html#SECURITY">&lt;strong>SECURITY(安全)&lt;/strong>&lt;/a>&lt;strong>相关指令&lt;/strong>&lt;/p>
&lt;p>&lt;a href="https://man7.org/linux/man-pages/man5/systemd.exec.5.html#MANDATORY_ACCESS_CONTROL">&lt;strong>MANDATORY ACCESS CONTROL(强制访问控制)&lt;/strong>&lt;/a>&lt;strong>相关指令&lt;/strong>&lt;/p>
&lt;p>&lt;a href="https://man7.org/linux/man-pages/man5/systemd.exec.5.html#PROCESS_PROPERTIES">&lt;strong>PROCESS PROPERITES(进程属性)&lt;/strong>&lt;/a>&lt;strong>相关指令&lt;/strong>
为执行的进程设置各种资源的软限制和硬限制。&lt;/p>
&lt;p>&lt;a href="https://man7.org/linux/man-pages/man5/systemd.exec.5.html#SCHEDULING">&lt;strong>SCHEDULING(调度)&lt;/strong>&lt;/a>&lt;strong>相关指令&lt;/strong>&lt;/p>
&lt;p>&lt;a href="https://man7.org/linux/man-pages/man5/systemd.exec.5.html#SANDBOXING">&lt;strong>SANDBOXING(沙盒)&lt;/strong>&lt;/a>&lt;strong>相关指令&lt;/strong>&lt;/p>
&lt;p>&lt;a href="https://man7.org/linux/man-pages/man5/systemd.exec.5.html#SYSTEM_CALL_FILTERING">&lt;strong>SYSTEM CALL FILTERING(系统调用过滤)&lt;/strong>&lt;/a>&lt;strong>相关指令&lt;/strong>&lt;/p>
&lt;p>&lt;a href="https://man7.org/linux/man-pages/man5/systemd.exec.5.html#ENVIRONMENT">&lt;strong>ENVIRONMENT(环境变量)&lt;/strong>&lt;/a>&lt;strong>相关指令&lt;/strong>
&lt;strong>Environment=&amp;lt;STRING&amp;gt;&lt;/strong> # 指定 Unit 启动时所使用的环境变量&lt;/p>
&lt;p>&lt;a href="https://man7.org/linux/man-pages/man5/systemd.exec.5.html#LOGGING_AND_STANDARD_INPUT/OUTPUT">&lt;strong>LOGGING AND STANDARD INPUT/OUTPUT(日志的标准输入/输出)&lt;/strong>&lt;/a>&lt;strong>相关指令&lt;/strong>&lt;/p>
&lt;h3 id="systemdkillhttpsman7orglinuxman-pagesman5systemdkill5html-类指令">&lt;a href="https://man7.org/linux/man-pages/man5/systemd.kill.5.html">systemd.kill&lt;/a> 类指令&lt;/h3>
&lt;p>systemd.kill 类的指令用于配置进程停止时，应该使用方式方法。&lt;/p>
&lt;ul>
&lt;li>用于 service、socket、swap、mount、scope 部分&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>KillMode=&amp;lt;STRING&amp;gt;&lt;/strong> # 这个选项用来处理 Containerd 进程被杀死的方式。默认情况下，systemd 会在进程的 cgroup 中查找并杀死 Containerd 的所有子进程，这肯定不是我们想要的。&lt;code>KillMode&lt;/code>字段可以设置的值如下。我们需要将 KillMode 的值设置为 &lt;code>process&lt;/code>，这样可以确保升级或重启 Containerd 时不杀死现有的容器。&lt;/p>
&lt;ul>
&lt;li>&lt;strong>control-group&lt;/strong>（默认值）：当前控制组里面的所有子进程，都会被杀掉&lt;/li>
&lt;li>&lt;strong>process&lt;/strong>：只杀主进程&lt;/li>
&lt;li>&lt;strong>mixed&lt;/strong>：主进程将收到 SIGTERM 信号，子进程收到 SIGKILL 信号&lt;/li>
&lt;li>&lt;strong>none&lt;/strong>：没有进程会被杀掉，只是执行服务的 stop 命令。&lt;/li>
&lt;/ul>
&lt;h3 id="systemdresource-controlhttpsman7orglinuxman-pagesman5systemdresource-control5html-类指令">&lt;a href="https://man7.org/linux/man-pages/man5/systemd.resource-control.5.html">systemd.resource-control&lt;/a> 类指令&lt;/h3>
&lt;p>用于对 Unit 启动的进程进行资源限制相关的指令
&lt;strong>Delegate=&amp;lt;STRING&amp;gt;&lt;/strong> # 这个选项允许进程(比如 containerd)以及运行时自己管理自己创建的容器的 &lt;code>cgroups&lt;/code>。如果不设置这个选项，systemd 就会将进程移到自己的 &lt;code>cgroups&lt;/code> 中，从而导致该进程无法正确获取容器的资源使用情况。&lt;/p>
&lt;h2 id="servicehttpsman7orglinuxman-pagesman5systemdservice5html-部分的指令">&lt;a href="https://man7.org/linux/man-pages/man5/systemd.service.5.html">[Service]&lt;/a> 部分的指令&lt;/h2>
&lt;p>详见 [service Unit](/docs/1.操作系统/3.Systemd%20 系统守护程序/Unit%20File/service%20Unit.md Unit.md)&lt;/p>
&lt;h2 id="timerhttpsman7orglinuxman-pagesman5systemdtimer5html-部分指令">&lt;a href="https://man7.org/linux/man-pages/man5/systemd.timer.5.html">[timer]&lt;/a> 部分指令&lt;/h2>
&lt;p>详见 [timer Unit](/docs/1.操作系统/3.Systemd%20 系统守护程序/Unit%20File/timer%20Unit.md Unit.md)&lt;/p></description></item><item><title>Docs: 应用示例</title><link>https://desistdaydream.github.io/docs/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/3.Systemd-%E7%B3%BB%E7%BB%9F%E5%AE%88%E6%8A%A4%E7%A8%8B%E5%BA%8F/Unit-File/%E5%BA%94%E7%94%A8%E7%A4%BA%E4%BE%8B/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/3.Systemd-%E7%B3%BB%E7%BB%9F%E5%AE%88%E6%8A%A4%E7%A8%8B%E5%BA%8F/Unit-File/%E5%BA%94%E7%94%A8%E7%A4%BA%E4%BE%8B/</guid><description>
&lt;p>开机建立远程隧道&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-nginx" data-lang="nginx">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">[Unit]&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">Description=Remote&lt;/span> &lt;span style="color:#e6db74">SSH&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">[Service]&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">ExecStart=/bin/ssh&lt;/span> &lt;span style="color:#e6db74">-N&lt;/span> &lt;span style="color:#e6db74">-R&lt;/span> &lt;span style="color:#ae81ff">20001&lt;/span>:localhost:&lt;span style="color:#ae81ff">22&lt;/span> &lt;span style="color:#e6db74">root@10.253.26.241&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">Restart=on-failure&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">RestartSec=10&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">[Install]&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">WantedBy=network.target&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div></description></item></channel></rss>