<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>断念梦 – Linux 图形处理</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/11.%E5%9B%BE%E5%BD%A2%E5%A4%84%E7%90%86/linux-%E5%9B%BE%E5%BD%A2%E5%A4%84%E7%90%86/</link><description>Recent content in Linux 图形处理 on 断念梦</description><generator>Hugo -- gohugo.io</generator><atom:link href="https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/11.%E5%9B%BE%E5%BD%A2%E5%A4%84%E7%90%86/linux-%E5%9B%BE%E5%BD%A2%E5%A4%84%E7%90%86/index.xml" rel="self" type="application/rss+xml"/><item><title>Docs: GSettings 与 Dconf</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/11.%E5%9B%BE%E5%BD%A2%E5%A4%84%E7%90%86/linux-%E5%9B%BE%E5%BD%A2%E5%A4%84%E7%90%86/gsettings-%E4%B8%8E-dconf/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/11.%E5%9B%BE%E5%BD%A2%E5%A4%84%E7%90%86/linux-%E5%9B%BE%E5%BD%A2%E5%A4%84%E7%90%86/gsettings-%E4%B8%8E-dconf/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;h2 id="参考">参考：&lt;/h2>
&lt;/blockquote>
&lt;h1 id="gsetting-命令行工具">gsetting 命令行工具&lt;/h1>
&lt;h2 id="应用示例">应用示例&lt;/h2>
&lt;p>关闭 Ubuntu 20.04 的桌面动画效果&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>gsettings set org.gnome.desktop.interface enable-animations false
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div></description></item><item><title>Docs: VNC</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/11.%E5%9B%BE%E5%BD%A2%E5%A4%84%E7%90%86/linux-%E5%9B%BE%E5%BD%A2%E5%A4%84%E7%90%86/vnc/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/11.%E5%9B%BE%E5%BD%A2%E5%A4%84%E7%90%86/linux-%E5%9B%BE%E5%BD%A2%E5%A4%84%E7%90%86/vnc/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Virtual_Network_Computing">Wiki,VNC&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://github.com/rfbproto/rfbproto">GitHub 项目，rfbproto/rfbproto&lt;/a>(RFB 协议规范)&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>&lt;strong>Virtual Network Computing(虚拟网络计算，简称 VNC)&lt;/strong> 是一种图形桌面共享系统，VNC 使用 &lt;strong>RFB Protocol(远程帧缓冲协议)&lt;/strong> 以控制另一台计算机；它将键盘和鼠标输入从一台计算机传输到另一台计算机，通过网络中继更新显示器上的信息。&lt;/p>
&lt;p>VNC 是独立于平台的——有许多基于 GUI 的操作系统和 Java 的客户端和服务器。多个客户端可以同时连接到 VNC 服务器。该技术的流行用途包括远程技术支持和从家庭计算机访问工作计算机上的文件，反之亦然。&lt;/p>
&lt;p>为什么没法通过 VNC 连接物理机的 CLI，但是可以连接虚拟机的 CLI 呢？！在 &lt;a href="https://github.com/rfbproto/rfbproto/issues/18">rfbproto/rfbproto 的 #18 issue&lt;/a> 中倒是说了 QEMU 中内置了 VNC/RFB，并对该协议进行了一些修改以支持一些额外的功能&lt;/p>
&lt;h1 id="tigervnc">TigerVNC&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://github.com/TigerVNC/tigervnc">GitHub 项目，TigerVNC/tigernvc&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://tigervnc.org/">官网&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>TigerVNC 是 VNC 的高性能、平台无关的实现，是一个 C/S 架构应用程序，允许用户在远程机器上启动图形应用程序并与之交互。&lt;/p>
&lt;h2 id="安装-tigervnc">安装 TigerVNC&lt;/h2>
&lt;p>CentOS&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>yum install tigervnc-server
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Ubuntu&lt;/p>
&lt;h1 id="realvnc">RealVNC&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://www.realvnc.com/en/">官网&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote></description></item><item><title>Docs: Wayland</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/11.%E5%9B%BE%E5%BD%A2%E5%A4%84%E7%90%86/linux-%E5%9B%BE%E5%BD%A2%E5%A4%84%E7%90%86/wayland/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/11.%E5%9B%BE%E5%BD%A2%E5%A4%84%E7%90%86/linux-%E5%9B%BE%E5%BD%A2%E5%A4%84%E7%90%86/wayland/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Wayland_(display_server_protocol)">Wiki,Wayland&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>Wayland 是一种通信协议，用来指定显示服务器及其客户端之间的通信。还可以表示该协议的 C 库实现。Wayland 是&lt;strong>下一代图形接口&lt;/strong>&lt;/p></description></item><item><title>Docs: X Window</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/11.%E5%9B%BE%E5%BD%A2%E5%A4%84%E7%90%86/linux-%E5%9B%BE%E5%BD%A2%E5%A4%84%E7%90%86/x-window/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/11.%E5%9B%BE%E5%BD%A2%E5%A4%84%E7%90%86/linux-%E5%9B%BE%E5%BD%A2%E5%A4%84%E7%90%86/x-window/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/X_Window_System_protocols_and_architecture">Wiki,X Window 系统协议和架构&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/X_window_manager">Wiki,X Window 管理器&lt;/a>&lt;/li>
&lt;li>&lt;a href="http://linux.vbird.org/linux_basic/0590xwindow.php">鸟哥的 Linux 私房菜,第二十三章、X Window&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>Unix Like 操作系统不是只能进行服务器的架设而已，在美编、排版、制图、多媒体应用上也是有其需要的。 这些需求都需要用到图形介面 (Graphical User Interface, GUI) 的操作的， 所以后来才有所谓的 X Window System 这玩意儿。那么为啥图形窗口介面要称为 X 呢？因为就英文字母来看 X 是在 W(indow) 后面，因此，人们就戏称这一版的窗口介面为 X (有下一版的新窗口之意)！&lt;/p>
&lt;p>事实上， X Window System 是个非常大的架构，他还用到网络功能呢！也就是说，其实 X 窗口系统是能够跨网络与跨操作系统平台的！&lt;/p>
&lt;h2 id="x-window-的发展简史">X Window 的发展简史&lt;/h2>
&lt;p>X Window 系统最早是由 MIT (Massachusetts Institute of Technology, 麻省理工学院) 在 1984 年发展出来的， 当初 X 就是在 Unix 的 System V 这个操作系统版本上面开发出来的。在开发 X 时，开发者就希望这个窗口介面不要与硬件有强烈的相关性，这是因为如果与硬件的相关性高，那就等於是一个操作系统了， 如此一来的应用性会比较局限。因此 X 在当初就是以应用程序的概念来开发的，而非以操作系统来开发。&lt;/p>
&lt;p>由於这个 X 希望能够透过网络进行图形介面的存取，因此发展出许多的 X 通讯协议，这些网络架构非常的有趣， 所以吸引了很多厂商加入研发，因此 X 的功能一直持续在加强！一直到 1987 年更改 X 版本到 X11 ，这一版 X 取得了明显的进步， 后来的窗口介面改良都是架构於此一版本，因此后来 X 窗口也被称为 X11 。这个版本持续在进步当中，到了 1994 年发布了新版的 X11R6 ，后来的架构都是沿用此一释出版本，所以后来的版本定义就变成了类似 1995 年的 X11R6.3 之类的样式。 (注 1)&lt;/p>
&lt;p>1992 年 XFree86 (&lt;a href="http://www.xfree86.org/">http://www.xfree86.org/&lt;/a>) 计画顺利展开， 该计画持续在维护 X11R6 的功能性，包括对新硬件的支持以及更多新增的功能等等。当初定名为 XFree86 其实是根据『 X + Free software + x86 硬件 』而来的呢。早期 Linux 所使用的 X Window 的主要核心都是由 XFree86 这个计画所提供的，因此，我们常常将 X 系统与 XFree86 挂上等号的说。&lt;/p>
&lt;p>不过由於一些授权的问题导致 XFree86 无法继续提供类似 GPL 的自由软件，后来 Xorg 基金会就接手 X11R6 的维护！ Xorg (&lt;a href="http://www.x.org/">http://www.x.org/&lt;/a>) 利用当初 MIT 发布的类似自由软件的授权， 将 X11R6 拿来进行维护，并且在 2004 年发布了 X11R6.8 版本，更在 2005 年后发表了 X11R7.x 版。 现在我们 CentOS 5.x 使用的 X 就是 Xorg 提供的 X11R7 喔！ 而这个 X11R6/X11R7 的版本是自由软件，因此很多组织都利用这个架构去设计他们的图形介面喔！包括 Mac OS X v10.3 也曾利用过这个架构来设计他们的窗口呢！我们的 CentOS 也是利用 Xorg 提供的 X11 啦！&lt;/p>
&lt;p>从上面的说明，我们可以知道的是：&lt;/p>
&lt;ul>
&lt;li>在 Unix Like 上面的图形使用者界面 (GUI) 被称为 X 或 X11；&lt;/li>
&lt;li>X11 是一个『软件』而不是一个操作系统；&lt;/li>
&lt;li>X11 是利用网络架构来进行图形介面的运行与绘制；&lt;/li>
&lt;li>较著名的 X 版本为 X11R6 这一版，目前大部分的 X 都是这一版演化出来的 (包括 X11R7)；&lt;/li>
&lt;li>现在大部分的 distribution 使用的 X 都是由 Xorg 基金会所提供的 X11 软件；&lt;/li>
&lt;li>X11 使用的是 MIT 授权，为类似 GPL 的自由软件授权方式。&lt;/li>
&lt;/ul>
&lt;h1 id="x-原理">X 原理&lt;/h1>
&lt;p>X Window system 是个利用网络架构的图形使用者接口软件，基本上是分成 X Server 与 X Client 两个元件而已喔！&lt;/p>
&lt;ol>
&lt;li>X Server 管理硬件&lt;/li>
&lt;li>X Client 则是应用程序。&lt;/li>
&lt;/ol>
&lt;p>在运行上，X Client 应用程序会将所想要呈现的画面告知 X Server ，最终由 X server 来将结果通过他所管理的硬件绘制出来！整体的架构我们大约可以使用如下的图示来作个介绍：[2]
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/qpbz9c/1616164721534-04137e6f-04ce-41e4-8b0a-2a4765c43e41.png" alt="">
上面的图示非常有趣喔！我们在用户端想要取得来自服务器的图形数据时，我们用户端使用的当然是用户端的硬件设备啊， 所以，X Server 的重点就是在管理用户端的硬件，包括接受键盘/鼠标等设备的输入信息， 并且将图形绘制到屏幕上（请注意上图的所有元件之间的箭头指示）。但是到底要绘制个啥东西呢？绘图总是需要一些数据才能绘制吧？此时 X Client(就是 X 应用程序) 就很重要啦！他主要提供的就是告知 X Server 要绘制啥东西。那照这样的想法来思考，我们是想要取得远端服务器的绘图数据来我们的计算机上面显示嘛！所以啰，远端服务器提供的是 X client 软件啊！&lt;/p>
&lt;p>注意：在 X Window 环境中的 C/S 架构与通常意义上的 C/S 架构不太一样，有点反着来的感觉。&lt;/p>
&lt;h2 id="x-server--硬件管理屏幕绘制与提供字体功能">X Server # 硬件管理、屏幕绘制与提供字体功能&lt;/h2>
&lt;p>既然 X Window System 是要显示图形接口，因此理所当然的需要一个元件来管理我主机上面的所有硬件设备才行！这个任务就是 X Server 所负责的。而我们在 X 发展简史当中提到的 XFree86 计划及 Xorg 基金会，主要提供的就是这个 X Server 啦！那么 X Server 管理的设备主要有哪些呢？其实与输入/输出有关喔！包括键盘、鼠标、手写板、显示器（monitor） 、屏幕分辨率与色彩深度、显卡（包含驱动程序） 与显示的字体等等，都是 X Server 管理的。&lt;/p>
&lt;p>咦！显卡、屏幕以及键盘鼠标的设置，不是在开机的时候 Linux 系统以 systemd 的相关设置处理好了吗？为何 X Server 还要重新设置啊？这是因为 X Window 在 Linux 里面仅能算是“一套很棒的软件”， 所以 X Window 有自己的配置文件，你必须要针对他的配置文件设置妥当才行。也就是说， Linux 的设置与 X Server 的设置不一定要相同的！因此，你在 CentOS 7 的 multi-user.target 想要玩图形接口时，就得要载入 X Window 需要的驱动程序才行～总之， X Server 的主要功能就是在管理“主机”上面的显示硬件与驱动程序。&lt;/p>
&lt;p>既然 X Window System 是以通过网络取得图形接口的一个架构，那么用户端是如何取得服务器端提供的图形画面呢？由于服务器与用户端的硬件不可能完全相同，因此我们用户端当然不可能使用到服务器端的硬件显示功能！举例来说，你的用户端计算机并没有 3D 影像加速功能，那么你的画面可能呈现出服务器端提供的 3D 加速吗？当然不可能吧！所以啰 X Server 的目的在管理用户端的硬件设备！也就是说：“每部用户端主机都需要安装 X Server，而服务器端则是提供 X Client 软件， 以提供用户端绘图所需要的数据数据”。&lt;/p>
&lt;p>X Server/X Client 的互动并非仅有 client &amp;ndash;&amp;gt; server，两者其实有互动的！从上图 23.1.1 我们也可以发现， X Server 还有一个重要的工作，那就是将来自输入设备（如键盘、鼠标等） 的动作告知 X Client， 你晓得， X Server 既然是管理这些周边硬件，所以，周边硬件的动作当然是由 X Server 来管理的， 但是 X Server 本身并不知道周边设备这些动作会造成什么显示上的效果， 因此 X Server 会将周边设备的这些动作行为告知 X Client ，让 X Client 去伤脑筋。&lt;/p>
&lt;h2 id="x-client--负责-x-server-要求的事件之处理">X Client # 负责 X Server 要求的“事件”之处理&lt;/h2>
&lt;p>前面提到的 X Server 主要是管理显示接口与在屏幕上绘图，同时将输入设备的行为告知 X Client， 此时 X Client 就会依据这个输入设备的行为来开始处理，最后 X Client 会得到“ 嗯！这个输入设备的行为会产生某个图示”，然后将这个图示的显示数据回传给 X Server ， X server 再根据 X Client 传来的绘图数据将他描图在自己的屏幕上，来得到显示的结果。&lt;/p>
&lt;p>也就是说， X Client 最重要的工作就是处理来自 X Server 的动作，将该动作处理成为绘图数据， 再将这些绘图数据传回给 X Server 啰！由于 X Client 的目的在产生绘图的数据，因此我们也称呼 X Client 为 X Application(X 应用程序)。而且，每个 X Client 并不知道其他 X Client 的存在， 意思是说，如果有两个以上的 X client 同时存在时，两者并不知道对方到底传了什么数据给 X Server ， 因此 X Client 的绘图常常会互相重叠而产生困扰喔！&lt;/p>
&lt;p>举个例子来说，当我们在 X Window 的画面中，将鼠标向右移动，那他是怎么告知 X Server 与 X Client 的呢？首先， X server 会侦测到鼠标的移动，但是他不知道应该怎么绘图啊！此时，他将鼠标的这个动作告知 X Client， X Client 就会去运算，结果得到，嘿嘿！其实要将鼠标指标向右移动几个像素，然后将这个结果告知 X server ， 接下来，您就会看到 X Server 将鼠标指标向右移动啰～&lt;/p>
&lt;p>这样做有什么好处啊？最大的好处是， X Client 不需要知道 X Server 的硬件配备与操作系统！因为 X Client 单纯就是在处理绘图的数据而已，本身是不绘图的。所以，在用户端的 X Server 用的是什么硬件？用的是哪套操作系统？服务器端的 X Client 根本不需要知道～相当的先进与优秀～对吧！^_^ 整个运行流程可以参考下图：用户端用的是什么操作系统在 Linux 主机端是不在乎的！
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/qpbz9c/1622302517121-61886ebd-b390-479f-a848-0558c2909ded.gif" alt="">
图 23.1.2、X Server 用户端的操作系统与 X client 的沟通示意&lt;/p>
&lt;h2 id="x-window-manager--特殊的-x-client-负责管理所有的-x-client-软件">X Window Manager # 特殊的 X Client ，负责管理所有的 X client 软件&lt;/h2>
&lt;p>刚刚前面提到，X Client 的主要工作是将来自 X Server 的数据处理成为绘图数据，再回传给 X Server 而已， 所以 X Client 本身是不知道他在 X Server 当中的位置、大小以及其他相关信息的。这也是上面我们谈到的， X Client 彼此不知道对方在屏幕的哪个位置啊！为了克服这个问题，因此就有 Window Manager(窗口管理器) 的产生了。窗口管理器也是 X client ，只是他主要在负责全部 X client 的控管，还包括提供某些特殊的功能，例如：&lt;/p>
&lt;ul>
&lt;li>提供许多的控制元素，包括工作列、背景桌面的设置等等；&lt;/li>
&lt;li>管理虚拟桌面（virtual desktop）；&lt;/li>
&lt;li>提供窗口控制参数，这包括窗口的大小、窗口的重叠显示、窗口的移动、窗口的最小化等等。&lt;/li>
&lt;/ul>
&lt;p>当 X Window Manager 开始运作时，&lt;a href="https://zh.wikipedia.org/wiki/X_Window%E7%B3%BB%E7%B5%B1%E7%9A%84%E5%8D%94%E8%AD%B0%E5%92%8C%E6%9E%B6%E6%A7%8B">X-Server&lt;/a> 和 X-Client 之间的交互，会重定向 X Window Manager。每当要显示一个新视窗时，这个请求便会被重定向到 X Window Manager，它会决定视窗的初始位置。此外，大部分较新的 X Window Manager 会改变视窗的亲属关系，通常会在视窗顶部加上标题栏，并在视窗周围加上装饰性的框架。这两个部分皆由视窗管理器来控制，而不是其它程序。因此，当用户点击或拖曳那些组件时，X Window Manager 会进行适当的动作（如移动或改变视窗的大小）。&lt;/p>
&lt;p>X Window Manager 也负责处理&lt;a href="https://zh.wikipedia.org/wiki/%E5%9C%96%E7%A4%BA">图标&lt;/a>，图标并不存在于 &lt;a href="https://zh.wikipedia.org/wiki/X_Window%E6%A0%B8%E5%BF%83%E5%8D%94%E8%AD%B0">X Window 核心协议&lt;/a>的层次中。当用户将视窗最小化时，X Window Manager 会取消视窗的映射（使其不可见），并完成适当的动作，将视窗改显示成图标。某些 X Window Manager 并不支持图标功能。&lt;/p>
&lt;p>X Window Manager 主要的目标，就如同其名，是用来管理视窗的。许多 X Window Manager 提供附加的功能，如处理鼠标在&lt;a href="https://zh.wikipedia.org/w/index.php?title=%E6%A0%B9%E8%A6%96%E7%AA%97&amp;amp;action=edit&amp;amp;redlink=1">根视窗&lt;/a>上的点击，呈现出窗格以及其它的可视化组件，处理按键（例如 Alt-F4 可关闭视窗），判定哪一个应用程序在引导时运行等等。&lt;/p>
&lt;p>我们常常听到的 KDE, GNOME, XFCE 还有阳春到爆的 twm 等等，都是一些窗口管理员的专案计划啦！这些专案计划中，每种窗口管理员所用以开发的显示发动机都不太相同，所著重的方向也不一样， 因此我们才会说，在 Linux 下面，每套 Window Manager 都是独特存在的，不是换了桌面与显示效果而已， 而是连显示的发动机都不会一样喔！下面是这些常见的 Window Manager 全名与链接：&lt;/p>
&lt;ul>
&lt;li>&lt;strong>GNU Network Object Model Environment(简称 GNOME)&lt;/strong>：&lt;a href="http://www.gnome.org/">http://www.gnome.org/&lt;/a>&lt;/li>
&lt;li>&lt;strong>K Desktop Enviroment(简称 KDE)&lt;/strong>：&lt;a href="http://kde.org/">http://kde.org/&lt;/a>&lt;/li>
&lt;li>&lt;strong>Tab Window Manager(简称 TWM)&lt;/strong>：&lt;a href="http://xwinman.org/vtwm.php">http://xwinman.org/vtwm.php&lt;/a>&lt;/li>
&lt;li>&lt;strong>XForms Common Environment(简称 XFCE)&lt;/strong>：&lt;a href="http://www.xfce.org/">http://www.xfce.org/&lt;/a>&lt;/li>
&lt;/ul>
&lt;p>由于 Linux 越来越朝向 Desktop 桌面电脑使用方向走，因此窗口管理员的角色会越来越重要！目前我们 CentOS 默认提供的有 GNOME 与 KDE ，这两个窗口管理员上面还有提供非常多的 X client 软件， 包括办公室生产力软件（Open Office） 以及常用的网络功能（firefox 浏览器、 Thunderbird 收发信件软件） 等。现在使用者想要接触 Linux 其实真的越来越简单了，如果不要架设服务器，那么 Linux 桌面的使用与 Windows 系统可以说是一模一样的！不需要学习也能够入门哩！^_^&lt;/p>
&lt;p>那么你知道 X Server / X client / window manager 的关系了吗？我们举 CentOS 默认的 GNOME 为例好了， 由于我们要在本机端启动 X Window system ，因此，在我们的 CentOS 主机上面必须要有 Xorg 的 X server 核心， 这样才能够提供屏幕的绘制啊～然后为了让窗口管理更方便，于是就加装了 GNOME 这个计划的 window manager ， 然后为了让自己的使用更方便，于是就在 GNOME 上面加上更多的窗口应用软件，包括输入法等等的， 最后就建构出我们的 X Window System 啰～ ^_^！所以你也会知道，X server/X client/Window Manager 是同时存在于我们一部 Linux 主机上头的啦！&lt;/p>
&lt;h3 id="display-manager--提供登陆需求">Display Manager # 提供登陆需求&lt;/h3>
&lt;p>谈完了上述的数据后，我们得要了解一下，那么我如何取得 X Window 的控制？在本机的命令行下面你可以输入 startx 来启动 X 系统，此时由于你已经登陆系统了，因此不需要重新登陆即可取得 X 环境。但如果是 graphical.target 的环境呢？你会发现在 tty1 或其他 tty 的地方有个可以让你使用图形接口登陆（输入帐号密码） 的咚咚，那个是啥？是 X Server/X client 还是什么的？其实那是个 Display Manager 啦！这个 display manager 最大的任务就是提供登陆的环境， 并且载入使用者选择的 Window Manager 与语系等数据喔！&lt;/p>
&lt;p>几乎所有的大型窗口管理员专案计划都会提供 display manager 的，在 CentOS 上面我们主要利用的是 GNOME 的 GNOME Display Manager(gdm) 这支程序来提供 tty1 的图形接口登陆喔！至于登陆后取得的窗口管理员，则可以在 gdm 上面进行选择的！我们在第四章介绍的登陆环境，那个环境其实就是 gdm 提供的啦！再回去参考看看图示吧！^_^！所以说，并非 gdm 只能提供 GNOME 的登陆而已喔！&lt;/p>
&lt;ul>
&lt;li>GDM3 # GNOME 管理器&lt;/li>
&lt;li>KDM # KDE 管理器&lt;/li>
&lt;li>LightDM&lt;/li>
&lt;/ul>
&lt;h2 id="xdmcp--x-显示管理控制协议">XDMCP # X 显示管理控制协议&lt;/h2>
&lt;p>当 X server, X client 都在同一部主机上面的时候，你可以很轻松的启动一个完整的 X Window System。但是如果你想要透过这个机制在网络上面启动 X 呢？此时你得先在客户端启动一个 X server 将图形接口绘图所需要的硬件装置配置好， 并且启动一个 X server 常见的接收埠口(通常是 port 6000)，然后再由服务器端的 X client 取得绘图数据，再将数据绘制成图啰。透过这个机制，你可以在任何一部启动 X server 登入服务器喔！而且不管你的操作系统是啥呢！意义就像下图， 如此一来，你就可以取得服务器所提供的图形接口环境啦！
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/qpbz9c/1622307045187-e725761e-968e-455a-bdf4-797f37215985.png" alt="">
但是如果你是使用最笨的方法在客户端自己启动 X server ，然后在告诉服务器将 X client 程序一个一个的加载回来，那就太累人了吧！我们之前上面不是提到过可以用 display manager 来管理使用者的登入与启动 X 吗？那服务器能不能提供一个类似的服务，那我们直接透过服务器的 display manager 就能够提供我们登入的认证与加载自己选择的 window manager 的话，这样就太棒了！能够达到吗？当然可以啊！那就是透过 Xdmcp (X display manager control protocol) (&lt;a href="http://cn.linux.vbird.org/linux_server/0310telnetssh_3.php#ps3">注 3&lt;/a> )啦！&lt;/p>
&lt;p>Xdmcp 启动后会在服务器的 udp 177 开始监听，然后当客户端的 X server 联机到服务器的 port 177 之后， 我们的 Xdmcp 就会在客户端的 X server 放上用户输入账密的图形接口程序啰！那你就能透过这个 Xdmcp 去加载服务器所提供的类似 Window Manager 的相关 X client 啰！那你就能够取得图形接口的远程联机服务器哩！赞吧！&lt;/p>
&lt;p>那么什么时候会出现多使用者连入服务器取得 X 的情况呢？以鸟哥的例子来说，鸟哥实验室有一组 Linux 在进行数值模拟，他输出的结果是 NetCDF 档案，我们必须使用 PAVE 这一套软件去处理这些数据。但是我们有两三个人同时都会使用到那个功能，偏偏 Linux 主机是放在机架柜里面的，要我们挤在那个小小的空间前面『站着』操作计算机，可真是讨人厌啊～这个时候，我们就会架设图形接口的远程登录服务器，让我们可以『多人同时以图形接口登入 Linux 主机』来操作我们自己的程序！很棒，不是吗！&lt;/p>
&lt;h2 id="x-serverx-clientx-window-manager-之间的关系">X Server、X Client、X Window Manager 之间的关系&lt;/h2>
&lt;p>X Server、X Client、X Window Manager 之间的关系很像操作系统与应用程序之间的关系。很早之前，一台电脑只能运行一个程序，就好比只能运行 一个 X Client。所以，为了同时运行多个程序，就产生了操作系统。而为了同时打开多个图形界面，也就产生了 X Window Manager。&lt;/p>
&lt;h1 id="x-的安装">X 的安装&lt;/h1>
&lt;h2 id="x-server-安装">x Server 安装&lt;/h2>
&lt;p>yum install xorg-x11-xauth xorg-x11-server-utils&lt;/p>
&lt;p>有了服务端之后，一些简单的 X 程序就可以通过 X client 打开了。&lt;/p>
&lt;p>Node：xorg-x11-xinit 包含 xorg-x11-xauth xorg-x11-server-utils 这两个包，有时候安装 xorg-x11-xinit 即可&lt;/p>
&lt;p>X server 安装完成后，可以安装 xorg-x11-apps 包，这里面有一些 x 程序，可以测试系统的图形接口。&lt;/p>
&lt;p>Note: 在 centos8 下安装 apps 包，需要先开启 PowerTools 库(yum config-manager &amp;ndash;set-enabled PowerTools)&lt;/p>
&lt;ul>
&lt;li>/usr/bin/luit&lt;/li>
&lt;li>/usr/bin/oclock&lt;/li>
&lt;li>/usr/bin/x11perf&lt;/li>
&lt;li>/usr/bin/x11perfcomp&lt;/li>
&lt;li>/usr/bin/xbiff&lt;/li>
&lt;li>/usr/bin/xclipboard&lt;/li>
&lt;li>/usr/bin/xclock&lt;/li>
&lt;li>/usr/bin/xconsole&lt;/li>
&lt;li>/usr/bin/xcursorgen&lt;/li>
&lt;li>/usr/bin/xcutsel&lt;/li>
&lt;li>/usr/bin/xdpr&lt;/li>
&lt;li>/usr/bin/xeyes&lt;/li>
&lt;li>/usr/bin/xfd&lt;/li>
&lt;li>/usr/bin/xfontsel&lt;/li>
&lt;li>/usr/bin/xload&lt;/li>
&lt;li>/usr/bin/xlogo&lt;/li>
&lt;li>/usr/bin/xmag&lt;/li>
&lt;li>/usr/bin/xmessage&lt;/li>
&lt;li>/usr/bin/xpr&lt;/li>
&lt;li>/usr/bin/xvidtune&lt;/li>
&lt;li>/usr/bin/xwd&lt;/li>
&lt;li>/usr/bin/xwud&lt;/li>
&lt;/ul>
&lt;h2 id="x-client-安装">X Client 安装&lt;/h2>
&lt;ol>
&lt;li>xshell 工具在官方提供了一个 Xmanager 的软件，该软件可以作为 X Client 所用。&lt;/li>
&lt;/ol>
&lt;h2 id="heading">&lt;/h2></description></item><item><title>Docs: Xrdp</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/11.%E5%9B%BE%E5%BD%A2%E5%A4%84%E7%90%86/linux-%E5%9B%BE%E5%BD%A2%E5%A4%84%E7%90%86/xrdp/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/11.%E5%9B%BE%E5%BD%A2%E5%A4%84%E7%90%86/linux-%E5%9B%BE%E5%BD%A2%E5%A4%84%E7%90%86/xrdp/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://github.com/neutrinolabs/xrdp">GitHub 项目，neutrinolabs/xrdp&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://tecadmin.net/how-to-install-xrdp-on-ubuntu-20-04/">https://tecadmin.net/how-to-install-xrdp-on-ubuntu-20-04/&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>&lt;strong>XRDP&lt;/strong> 使用 &lt;strong>Microsoft 的 Remote Desktop Protocol(远程桌面协议，简称 RDP)&lt;/strong> 提供了一个图形界面以登录到计算机。XRDP 接受来自各种 RDP 客户端的连接。比如：&lt;/p>
&lt;ul>
&lt;li>FreeRDP&lt;/li>
&lt;li>rdesktop&lt;/li>
&lt;li>KRDC&lt;/li>
&lt;li>NeutrinoRDP&lt;/li>
&lt;li>Windows MSTSC (Microsoft Terminal Services Client, aka mstsc.exe)&lt;/li>
&lt;li>Microsoft Remote Desktop (found on Microsoft Store, which is distinct from MSTSC)&lt;/li>
&lt;/ul>
&lt;p>XRDP 主要针对 Linux 操作系统，可以让 Windows，使用其自带的远程桌面，通过 RDP 协议，远程控制装有 XRDP 的 Linux 系统，以实现远程图形化控制。&lt;/p>
&lt;h1 id="为-ubuntu-安装-xrdp">为 Ubuntu 安装 Xrdp&lt;/h1>
&lt;p>远程桌面协议允许用户访问远程系统桌面。 XRDP 服务向您提供使用 Microsoft RDP（远程桌面协议）的远程计算机的图形登录。 XRDP 还支持双向剪贴板传输（文本，位图，文件），音频重定向和驱动器重定向（在远程计算机上安装本地客户端驱动器）。
XRDP 是 Ubuntu 系统的易于安装和可配置的服务。但您还可以使用 VNC Server 访问 Ubuntu 系统的远程桌面。在 Ubuntu 20.04 系统上找到安装 VNC 服务器的教程。
本教程可帮助您在 Ubuntu 20.04 Linux 系统上安装远程桌面（XRDP）。还提供在系统上安装桌面环境的说明。&lt;/p>
&lt;h2 id="安装桌面环境">安装桌面环境&lt;/h2>
&lt;p>默认情况下，Ubuntu Server 没有已安装的桌面环境。 XRDP 服务器旨在仅控制桌面系统。因此，您需要向系统添加桌面环境。
使用 &lt;code>tasksel&lt;/code> 工具安装桌面环境&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>sudo apt update &lt;span style="color:#f92672">&amp;amp;&amp;amp;&lt;/span> sudo apt upgrade
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>apt install tasksel -y
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>安装 Tasksel 后，使用命令 &lt;code>tasksel&lt;/code> 启动程序：&lt;/p>
&lt;p>应该看到以下界面：
&lt;a href="https://tecadmin.net/wp-content/uploads/2020/11/tasksel-ubuntu-desktop.png">&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/ff73o6/1630033188975-4b9f059c-5f81-4263-8965-bb83636058bf.png" alt="image.png">&lt;/a>
使用箭头键向下滚动列表并查找 &lt;code>Ubuntu minimal desktop&lt;/code>。接下来，按空格键选择它，然后按 Tab 键选择确定，然后按 Enter 安装 &lt;code>Ubuntu minimal desktop&lt;/code> 桌面。&lt;/p>
&lt;p>安装所有包后，&lt;code>reboot&lt;/code> 重启操作系统&lt;/p>
&lt;h2 id="安装-xrdp-包">安装 xrdp 包&lt;/h2>
&lt;p>XRDP 软件包可在默认系统存储库下提供。您可以通过执行以下命令在 Ubuntu 系统上安装远程桌面。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>sudo apt install xrdp -y
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="配置-xrdp">配置 XRDP&lt;/h2>
&lt;p>在安装过程中，XRDP 在您的系统中添加了名为“XRDP”的系统中的用户。 XRDP 会话使用证书密钥文件“/etc/sl/private/ssl-cert-snakeoil.key”，它与远程桌面播放一个重要的角色。
要正确工作，请使用以下命令将 XRDP 用户添加到“SSL-Cert”组。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>sudo usermod -a -G ssl-cert xrdp
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>有时用户面临黑屏的问题出现在后台。因此，我是一个介绍在背景中解析黑屏问题的步骤。在文本编辑器中编辑 XRDP 文件 /etc/xrdp/startwm.sh：&lt;/p>
&lt;p>在 测试 和执行 XSession 的命令之间添加这些命令:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>Unset DBUS_SESSION_ADDRESS
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Unset XDG_RUNTIME_DIR
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>如下所示：
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/ff73o6/1630060168909-03b02b6b-c076-479b-ab43-ccad7d2993ff.png" alt="image.png">
通过运行下面给出的命令重新启动 XRDP 服务：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>sudo systemctl restart xrdp
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="连接到远程桌面">连接到远程桌面&lt;/h2>
&lt;p>xrdp 默认监听 3389 端口，防火墙放通该端口&lt;/p>
&lt;p>XRDP 服务已成功安装并准备连接。在 Windows 客户端上，打开 RDP 客户端并输入 Ubuntu 系统的 IP 地址。&lt;/p>
&lt;p>您可以通过在运行窗口或命令行中键入“mstsc”来启动 RDP 客户端。
&lt;a href="https://tecadmin.net/wp-content/uploads/2021/06/connect-xrdp.png">&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/ff73o6/1630033188968-627c5a91-5c70-4d84-8b6d-5513705883ad.png" alt="image.png">&lt;/a>
一旦连接成功，远程系统提示用于身份验证。输入远程 Ubuntu 系统的登录凭据以获取远程桌面访问。
&lt;a href="https://tecadmin.net/wp-content/uploads/2021/06/xrdp-enter-login-credentials.png">&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/ff73o6/1630033190060-961f359c-adbe-4058-84fc-fa92a0ff780e.png" alt="image.png">&lt;/a>&lt;/p>
&lt;h1 id="xrdp-配置">Xrdp 配置&lt;/h1>
&lt;p>&lt;strong>/etc/xrdp/*&lt;/strong> #&lt;/p>
&lt;ul>
&lt;li>&lt;strong>./sesman.ini&lt;/strong> #&lt;/li>
&lt;li>&lt;strong>./xrdp.ini&lt;/strong> #&lt;/li>
&lt;/ul>
&lt;h1 id="ubuntu-desktop-可能需要优化的地方">Ubuntu Desktop 可能需要优化的地方&lt;/h1>
&lt;h2 id="sorry-that-didnt-work-please-try-again抱歉登录失败请再试一次-问题">sorry, that didn’t work please try again(抱歉，登录失败，请再试一次) 问题&lt;/h2>
&lt;p>注释掉下面文件文件中 &lt;code>auth required pam_succeed_if.so user != root quiet_success&lt;/code> 这一行&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>sudo sed -i.bak &lt;span style="color:#e6db74">&amp;#39;s/^auth.*quiet_success/#&amp;amp;/&amp;#39;&lt;/span> /etc/pam.d/gdm-autologin
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>sudo sed -i.bak &lt;span style="color:#e6db74">&amp;#39;s/^auth.*quiet_success/#&amp;amp;/&amp;#39;&lt;/span> /etc/pam.d/gdm-password
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="关闭-ubuntu-2004-的桌面动画效果">关闭 Ubuntu 20.04 的桌面动画效果&lt;/h2>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>gsettings set org.gnome.desktop.interface enable-animations false
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>注意：改命令仅对当前用户生效。&lt;/p>
&lt;h2 id="xrdp_mm_process_login_response-login-failed">xrdp_mm_process_login_response: login failed&lt;/h2>
&lt;p>问题原因：远程桌面没有正确关闭，虽然在 windows 系统关闭远程桌面连接，但是在里 linux 上的进程还在运行，导致连接数量达到上限，出现问题。&lt;/p>
&lt;p>解决：通过设置 sesman.in 文件内的参数解决：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>sudo sed -i.bak &lt;span style="color:#e6db74">&amp;#39;s/KillDisconnected=false/KillDisconnected=true/&amp;#39;&lt;/span> /etc/xrdp/sesman.ini
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>可以修改会话设置 ：将最大会话限制该大 MaxSessions=50; 将 KillDisconnected=1；则每次断开连接时，linux 都会关闭会话进程。 然后重启/etc/init.d/xrdp restart 就可解决问题&lt;/p>
&lt;h2 id="其他未知问题">其他未知问题&lt;/h2>
&lt;p>sudo sed -i.bak &amp;ldquo;4 a #Improved Look n Feel Method\ncat &amp;laquo;EOF &amp;gt; ~/.xsessionrc\nexport GNOME_SHELL_SESSION_MODE=ubuntu\nexport XDG_CURRENT_DESKTOP=ubuntu:GNOME\nexport XDG_CONFIG_DIRS=/etc/xdg/xdg-ubuntu:/etc/xdg\nEOF\n&amp;rdquo; /etc/xrdp/startwm.sh&lt;/p>
&lt;p>sudo sed -i &amp;rsquo;s/allowed_users=console/allowed_users=anybody/&amp;rsquo; /etc/X11/Xwrapper.config[&lt;/p>
&lt;p>](https://blog.csdn.net/u014447845/article/details/80291678)
在 /etc/profile.d/ 目录中添加 &lt;code>source &amp;lt;(kubectl completion bash)&lt;/code> 这种命令会导致 xrdp 登录失败，现象是输入完用户名和密码之后就闪退。
[&lt;/p>
&lt;p>](https://blog.csdn.net/u014447845/article/details/80291678)&lt;/p></description></item><item><title>Docs: 揭开Wayland的面纱（一）：X Window的前生今世</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/11.%E5%9B%BE%E5%BD%A2%E5%A4%84%E7%90%86/linux-%E5%9B%BE%E5%BD%A2%E5%A4%84%E7%90%86/wayland/%E6%8F%AD%E5%BC%80wayland%E7%9A%84%E9%9D%A2%E7%BA%B1%E4%B8%80x-window%E7%9A%84%E5%89%8D%E7%94%9F%E4%BB%8A%E4%B8%96/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/11.%E5%9B%BE%E5%BD%A2%E5%A4%84%E7%90%86/linux-%E5%9B%BE%E5%BD%A2%E5%A4%84%E7%90%86/wayland/%E6%8F%AD%E5%BC%80wayland%E7%9A%84%E9%9D%A2%E7%BA%B1%E4%B8%80x-window%E7%9A%84%E5%89%8D%E7%94%9F%E4%BB%8A%E4%B8%96/</guid><description>
&lt;p>今天大家可能在&amp;quot;Wow! Ubuntu&amp;quot;或其他地方看到了这篇文章：Ubuntu 决定未来将启用 Wayland X-Server。
Wayland 是什么呢？它是 X Window？还是要取代 X Window？它的优势在哪里？Linux 桌面/移动会因此有什么变化？在本篇中，我将回顾历史，展望未来，通过简易的文字，来先回顾一下 X Window，从而继续解答 Wayland。
注：在下对 X Window 的理解仅限于表面，文章中会有不少技术、历史方面的错误，若有大侠指出，不胜感激！
&lt;strong>古老的 X Window 和现代的桌面技术&lt;/strong>
X Window 在 1984 年由 MIT 研发，它的设计哲学之一是：提供机制，而非策略。举个最简单的例子吧：X Window 提供了生成窗口（Window）的方法，但它没规定窗口要怎么呈现（map）或摆放（place），这个策略是由外部程序&amp;mdash;- 窗口管理器（Window Manager）所决定的。另外一个 X Window 的主要特点便是：Server/Client 网络模型。不论是本地、远程的应用程序，都统一通过 Server/Client 模型来运作，比如：让远程的应用程序跑在本地上。
X Window 在推出之后快速演化，在 1987 年时候，其核心协议已经是第 11 版本了，简称：x11。这个版本已经将&amp;quot;提供机制，而非策略&amp;quot;这个哲学贯彻地非常彻底，以致于核心协议基本稳定，不需要特别大的改动。于是乎，你看到了，现在是 2010 年，整整 23 年了，X Window 依然是 X11。
你可能会诧异，23 年了，X Window 的核心都没有特别大的变化，它能适应现代桌面的快速发展吗？这就要再次提到 X Window 的设计优势了，X Window 在核心层之外提供一个扩展层，开发者可以开发相应扩展，来实现自己的扩展协议，比方说：&lt;/p>
&lt;blockquote>
&lt;p>标准的 Window 都是矩形的，我如何用它来画一个圆形的窗口？X Window 协议并未提供，但是通过&amp;quot;shape&amp;quot;这个扩展，X Window 可以实现不规则的窗体。&lt;/p>
&lt;/blockquote>
&lt;p>所以啊，这 23 年，X Window 除了继续完善核心协议、驱动以外，很大程度上，都是扩展使它保持&amp;quot;与时俱进&amp;quot;，比如说：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>要多头显示支持，这个是由&amp;quot;Xinerama&amp;quot;扩展实现的；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>要有多媒体视频回放的支持，这个是由&amp;quot;X Video&amp;quot;扩展实现的;&lt;/p>
&lt;/li>
&lt;li>
&lt;p>OpenGL 的 3D 支持，则是通过&amp;quot;GL&amp;quot;扩展来实现的；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Compiz 那样的合成桌面特效是怎么弄的？没错，还需要一个新的扩展，它便是：&amp;ldquo;Composite&amp;rdquo;；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>甚至 Keyboard 的支持，都是通过&amp;quot;X Keyboard Extension&amp;quot;（也就是&amp;quot;XKB&amp;quot;）的！&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>X Window 的核心，基本上就是在处理 Server/Client、驱动之类的，而外部的那些支持，基本上全是通过&amp;quot;扩展&amp;quot;进行的。这没什么不好，X Window 的结构设计精良，尽管是扩展，但它们没有任何效能上的问题。通过扩展方便地实现了一些对新技术、新事物的支持，而且方便维护，这再好不过了。
所以你看到了尽管 23 年过去了，基于 X Window 的 GNOME、KDE，还能保持与同期 Windows、Mac OS X 竞争甚至某些方面更好，你就不得不佩服这些前辈在最初设计时定下的设计哲学是多么正确了。
虽然扩展的众多没有给 X Window 造成什么问题，也跟 X Window 的设计哲学相符，但是其 Server/Client 的网络构架，却一直倍受质疑，这便是：
&lt;strong>X Window 的效率问题&lt;/strong>
经常听到有人说，X Window 的 Server/Client 结构严重影响效率，导致 Linux 桌面的效应速度一直不如 Windows、Mac OS X。事实是不是这样呢？让我们还是透过原理来说话吧。
这张，便是当前 X Window 系统的架构图，稍微解释一下：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>X Client：图形应用程序，如 Firefox、Pidgin 等；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>X Server：你看不见的控制中心；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Compositor：合成桌面系统，如 Compiz；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Kernel/KMS/evdev：这便是 Linux Kernel，后面会提到 KMS 技术了，其中还有一项 evdev，是管理输入设备的。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/ne0akv/1622379411352-ed852deb-5802-486f-85d6-c9b587b05238.jpeg" alt="">
通过这些箭头，你已经可以明白一些 X Window 的工作机制了，不过还从一个应用场景来解释一下，想像一下，当你点击了 Firefox（X Client）的&amp;quot;刷新&amp;quot;按钮，将会发生以下事情：&lt;/p>
&lt;ol>
&lt;li>
&lt;p>你用鼠标点击了 Firefox 的&amp;quot;刷新&amp;quot;按钮，这时内核收到了鼠标发来的事件，并将其通过 evdev 输入驱动发送至了 X Server。这时内核实际上做了很多事情，包括将不同品牌的鼠标发出的不同信号转换成了标准的&amp;quot;evdev&amp;quot;输入信息。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>这时 X Server 可以判断哪个 Window 该收到这个消息，并将某座标按下按钮的消息发往 X Client&amp;mdash;-Firefox。但事实上 X Server 并不知道它得到的窗口信息是不是正确！为什么呢？因为当前的 Linux 桌面早已经不是 10 年前的那样了，现在是&amp;quot;Composite&amp;quot;即合成桌面的时代，合成桌面的一个特点便是：Compositor（如 Compiz）管理窗口的一切，X Server 只能知道屏幕的某个点收到了鼠标消息，却不知道这个点下面到底有没有窗口&amp;mdash;-谁知道 Compiz 是不是正在搞一个漂亮的、缓慢的动画，把窗口收缩起来了呢？&lt;/p>
&lt;/li>
&lt;li>
&lt;p>假设应用场景没这么复杂，Firefox 顺利地收到了消息，这时 Firefox 要决定该如何做：按钮要有按下的效果。于是 Firefox 再发送请求给 X Server，说：&amp;ldquo;麻烦画一下按钮按下的效果。&amp;rdquo;&lt;/p>
&lt;/li>
&lt;li>
&lt;p>当 X Server 收到消息后，它就准备开始做具体的绘图工作了：首先它告诉显卡驱动，要画怎么样一个效果，然后它也计算了被改变的那块区域，同时告诉 Compiz 那块区域需要重新合成一下。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Compiz 收到消息后，它将从缓冲里取得显卡渲染出的图形并重新合成至整个屏幕&amp;mdash;-当然，Compiz 的&amp;quot;合成&amp;quot;动作，也属于&amp;quot;渲染（render）&amp;quot;，也是需要请求 X Server，我要画这块，然后 X Server 回复：你可以画了。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>整个过程可能已经明了了，请求和渲染的动作，从 X Client-&amp;gt;X Server，再从 X Server-&amp;gt;Compositor，而且是双向的，确实是比较耗时的，但是，事实还不是如此。介于 X Window 已有的机制，尽管 Compiz 已经掌管了全部最终桌面呈现的效果，但 X Server 在收到 Compiz 的&amp;quot;渲染&amp;quot;请求时，还会做一些&amp;quot;本职工作&amp;quot;，如：窗口的重叠判断、被覆盖窗口的剪载计算等等（不然它怎么知道鼠标按下的坐标下，是 Firefox 的窗口呢）&amp;mdash;-这些都是无意义的重复工作，而且 Compiz 不会理会这些，Compiz 依然会在自己的全屏幕&amp;quot;画布&amp;quot;上，画着自己的动画效果……&lt;/p>
&lt;/li>
&lt;/ol>
&lt;p>从这个过程，基本可以得出结论：&lt;/p>
&lt;ol>
&lt;li>
&lt;p>X Client &amp;lt;-&amp;gt; X Server &amp;lt;-&amp;gt; Compositor，这三者请求渲染的过程，不是很高效；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>X Server，Compositor，这两者做了很多不必要的重复工作和正文切换。&lt;/p>
&lt;/li>
&lt;/ol>
&lt;p>当然，这里我没有直接说明这种模式有没有给 X Window 造成效率问题，因为我们还少一个对照组。再看对照组之前，再来看看 X Server 的另一个趋势：
&lt;strong>从&amp;quot;什么都做&amp;quot;到&amp;quot;做得越来越少&amp;quot;的 X Window&lt;/strong>
X Window 刚出现那会，主要提供一个在操作系统内核上的抽象层，来实现一个图形环境。所谓图形环境，最主要的便是：图形＋文字。当时的 X Window 便提供&amp;quot;绘图&amp;quot;和&amp;quot;渲染文字&amp;quot;的机制。图形桌面上的图案和文字，都通过 X Window 合成并绘制出来。
一个典型的例子，如果你要用 X 来画点，就要在你的程序中通过&amp;quot;XDrawPoint&amp;quot;来进行，X Server 收到消息后，便会画出相应的点。
现在，稍微接触过图形开发的人都知道了，在 X Window 下，一般都通过 GTK+和 Qt 来进行了。更深一层的是，通过 Cairo（Qt 不是）来绘制图形。Cairo 是什么？它是一个绘图＋渲染引擎，著名的浏览器 Firefox，便是使用 Cairo 来渲染网页和文字的。
Cairo 是一个全能的、跨平台的矢量绘图库，它不是简单的包装一下各个平台的绘图库而已，尽管它最初是基于 X Window 开发出来的绘图库。现在 Cairo 支持各种不同的后端，来向其输出图形，比如 X、Windows 的 GDI、Mac OS X 的 Quartz，还有各种文件格式：PNG、PDF，当然还有 SVG。可以说，Cairo 是一个很彻底的、全能的绘图库，现在无论绘制什么图形，都不会考虑到用 XLib 了。
在 Cairo 之上，还有文字排版库：Pango，同样很明显的，处理文字排版，都不会用 XFont 之类的东西了，而是直接用 Pango 画。当然 Pango 也是跨平台的。
尽管在 Linux 平台下，Cairo、Pango 的发挥依然是基于 X Window 的，但 X Window 充其量仅仅是一个&amp;quot;backend&amp;quot;而已，并不是少它不行。同理，跨平台的 GTK+、Ｑ t 也只是视 X 为其中所支持的后端之一，假如哪天 X 真的不在了，更换一个新后端，当前的 GNOME、KDE 也能完整的跑起来。
再提另外一个比较典型的关于&amp;quot;X 曾经做的，但现已不做&amp;quot;的例子，便是&amp;quot;模式设置（mode- setting）&amp;quot;，说通俗点，就是&amp;quot;分辨率的设置&amp;quot;，但后面会说明不仅仅如此。
大家都知道，Linux 只是一个内核，它只有控制台，通过 Shell 来进行交互，而控制台默认是 80x24（单位：字符）的，要进入分辨率 1024x768 或更高的图形模式，就需要 X 进行一次&amp;quot;模式设置&amp;quot;，设置正确的分辨率等等。
尽管后来 Linux 也支持了各种用户层（user- space）的模式设置，让终端也支持标准的分辨率，但是 X 的模式设置与此是不相干的，所以一两年前，在 Linux 的启动过程中，从终端进入图形界面时，屏幕会&amp;quot;闪&amp;quot;一下，这时便在进行&amp;quot;模式设置&amp;quot; &amp;mdash;-这里就一定要用&amp;quot;模式设置&amp;quot;这个术语了，因为即使终端是 1024 的，进入 X 图形也是 1024 的，模式的变更还是要进行。
后来呢，嗯，2009 年初期，KMS（内核模式设置）终于出现了！！！很少关心桌面图形的 Linux 内核，在当时引入了&amp;quot;内核级&amp;quot;的模式设置，也就是说，在内核载入完毕、显示驱动初始化后很短的时间内，即设置好标准的分辨率和色深，通过在 X 层做相应的更改，从此 X 的初始化就可以省去&amp;quot;模式设置&amp;quot;这一过程了！也就是从 Fedora 10 开始，Linux 的启动非常平滑、漂亮，没有任何闪烁了。现在的 Ubuntu 10.10 也一样，KMS 的应用已经相当成熟。
X 从此又少了一样图形任务……&amp;ldquo;X 泪奔～你们都不要我了。&amp;rdquo;
可以说，这 20 多年来，X 从&amp;quot;什么都做&amp;quot;已经到了&amp;quot;做的越来越少&amp;quot;。绝大多数的开发者开发图形应用程序，已经可以完全无视 X 的存在了，X 现在更像是一个中间人的角色。那么，X 这个中间人会不会有一天，完全被其他事物所取代呢？
没错！它便是下篇要介绍的：Wayland！！！&lt;/p></description></item></channel></rss>