<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>断念梦 – 公开密钥加密</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/7.%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8/cryptography%E5%AF%86%E7%A0%81%E5%AD%A6/%E5%85%AC%E5%BC%80%E5%AF%86%E9%92%A5%E5%8A%A0%E5%AF%86/</link><description>Recent content in 公开密钥加密 on 断念梦</description><generator>Hugo -- gohugo.io</generator><atom:link href="https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/7.%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8/cryptography%E5%AF%86%E7%A0%81%E5%AD%A6/%E5%85%AC%E5%BC%80%E5%AF%86%E9%92%A5%E5%8A%A0%E5%AF%86/index.xml" rel="self" type="application/rss+xml"/><item><title>Docs: 密钥/证书 的编码</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/7.%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8/cryptography%E5%AF%86%E7%A0%81%E5%AD%A6/%E5%85%AC%E5%BC%80%E5%AF%86%E9%92%A5%E5%8A%A0%E5%AF%86/%E5%AF%86%E9%92%A5_%E8%AF%81%E4%B9%A6-%E7%9A%84%E7%BC%96%E7%A0%81/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/7.%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8/cryptography%E5%AF%86%E7%A0%81%E5%AD%A6/%E5%85%AC%E5%BC%80%E5%AF%86%E9%92%A5%E5%8A%A0%E5%AF%86/%E5%AF%86%E9%92%A5_%E8%AF%81%E4%B9%A6-%E7%9A%84%E7%BC%96%E7%A0%81/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;p>当我们生成密钥后，是不易于保存的，比如我在 go 代码，使用 RSA 算法生成了这么一个密钥：
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/oxf9fa/1616125711062-22c30c47-afff-4ee4-a81a-d8a5225aad74.png" alt="">&lt;/p>
&lt;p>私钥中包含里 &lt;code>公钥、n、d、组件&lt;/code>，公钥中包含 &lt;code>n、e&lt;/code>。可以发现，这种数据是不便于保存与共享的。所以，一般情况是使用一种 **Encoding(编码) **规则，对密钥进行处理后以生成某种格式的文件，以便保存。当需要使用密钥时，使用对应规则的来 &lt;strong>Decoding(解码)&lt;/strong> 该文件以获得密钥，然后再开始使用。而现阶段最常用的文件就是，就是 &lt;strong>PEM 文件格式&lt;/strong>。&lt;/p>
&lt;p>除了可以对密钥编码，还可以对证书进行编码，证书由于其复杂的格式，也不利于传输。&lt;/p>
&lt;p>如果用 openssl 命令查看私钥，则是下面这种格式&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>root@lichenhao:~/projects/DesistDaydream/GoLearning# openssl rsa -text -noout -in cryptography/private.pem
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>RSA Private-Key: &lt;span style="color:#f92672">(&lt;/span>&lt;span style="color:#ae81ff">2048&lt;/span> bit, &lt;span style="color:#ae81ff">2&lt;/span> primes&lt;span style="color:#f92672">)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>modulus:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> 00:d0:94:1c:6e:25:54:61:1d:34:23:1f:25:f7:a5:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ......
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>publicExponent: &lt;span style="color:#ae81ff">65537&lt;/span> &lt;span style="color:#f92672">(&lt;/span>0x10001&lt;span style="color:#f92672">)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>privateExponent:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> 00:bb:fe:52:e5:9f:f5:be:96:30:d0:db:19:40:6d:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ......
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>prime1:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> 00:f3:06:5f:c4:e6:27:d2:1d:ba:d1:35:40:34:b1:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ......
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>prime2:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> 00:db:b6:ee:09:28:3c:53:f5:70:e7:9a:11:8b:55:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ......
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>exponent1:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> 3b:17:1e:ac:22:86:26:29:c2:65:e1:fb:c5:94:3e:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ......
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>exponent2:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> 00:a4:a5:5d:95:61:20:6c:2e:36:30:68:45:13:6b:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ......
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>coefficient:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> 00:e3:ed:7a:4a:2d:4c:ec:e0:0d:77:e8:4e:df:9b:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ......
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h1 id="pem-文件格式">PEM 文件格式&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Privacy-Enhanced_Mail">Wiki&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>&lt;strong>Privacy-Enhanced Mail(增强隐私的邮件，简称 PEM) &lt;strong>是一种&lt;/strong>文件的格式&lt;/strong>(虽然曾经不止代表文件格式)。这种格式的文件用于存储 加密的密钥、证书 等数据。&lt;/p>
&lt;p>PEM 起源于 1993 年 IETF 定义“隐私增强邮件”的一组标准，尽管这个标准未得到广泛采用，并已被 PGP 和 S/MIME 取代，但其中定义的&lt;strong>各种文本编码格式&lt;/strong>却变得非常流行。所以，PEM 这种文件编码格式最终由 IETF 在 RFC7468 中正式定义。&lt;/p>
&lt;h2 id="pem-格式">PEM 格式&lt;/h2>
&lt;p>PEM 格式的内容由两部分组成&lt;/p>
&lt;ul>
&lt;li>**Type(类型) **# 用来表示 Contents(内容) 是什么，是 密钥 还是 证书 等等，同时也用来定位 Contents(内容) 在 PEM 格式文件中的位置。
&lt;ul>
&lt;li>类型以 &lt;code>-----BEGIN 标签-----&lt;/code>作为开头第一行，并以&lt;code>----- END 标签 -----&lt;/code>作为结尾最后一行。其中的&lt;code>标签&lt;/code>用来确定编码消息的类型，也就是说，标签用来表示该 PEM 格式的文件的作用是什么。标签包括以下几种：
&lt;ul>
&lt;li>CERTIFICATE # 证书&lt;/li>
&lt;li>CERTIFICATE REQUEST # 证书请求&lt;/li>
&lt;li>PRIVATE KEY# 私钥&lt;/li>
&lt;li>PUBLIC KEY # 公钥&lt;/li>
&lt;li>X509 CRL #&lt;/li>
&lt;li>等等等等，很多&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>标签中还可以添加其他标识符，只要保证标签中具有上述字符串即可。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>**Contents(内容) **# 密钥或证书的具体内容。
&lt;ul>
&lt;li>Contents 是 密钥、证书等数据 转换为 Bytes(字节流) 后，使用** Base64 **对这些 &lt;strong>Bytes 进行编码&lt;/strong> 得到的结果。&lt;/li>
&lt;li>注意：现在这个时代(本文写于 2020 年)由于 &lt;strong>PKCS&lt;/strong> 这种规范标准。一般情况下，Contents 必须符合 PKCS 这种标准，所以 密钥证书 并不会直接转换为 Bytes。一般情况下，是先使用 &lt;strong>ASN.1 的 DER(或其他规则)&lt;/strong> 将 证书、密钥 等数据 &lt;strong>编码为 Bytes 类型数据&lt;/strong>。然后再使用 Base64 对这些 Bytes 数据 进行编码得到字符串类型数据。
&lt;ul>
&lt;li>也就是说 证书或密钥 转换为 PCKS#X 标准(&lt;em>X 是数字&lt;/em>)，然后使用 Base64 编码得到 Contents(内容)。而常用的 PCKS#X 标准一般都是用的 ASN.1 的 DER 规则进行编码。
&lt;ul>
&lt;li>再深入一些的话，可以这么描述，&lt;strong>Contents(内容) 可以是使用 Base64 对符合 PKCS#1 标准格式的数据进行编码后得到的字符串&lt;/strong>
&lt;ul>
&lt;li>&lt;strong>而 PKCS#1 标准实际上指的是使用 ASN.1 的 DER 编码规则对公钥和私钥编码。由于编码后通常是 Bytes 类型的数据，所以需要再使用 Base64 编码得到便于传递的字符串类型的数据。&lt;/strong>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>**一般写为 **&lt;code>**PCKS#1, ASN.1 DER**&lt;/code>** &lt;strong>&lt;code>**PCKS#8, ASN.1 DER**&lt;/code>&lt;/strong> 等等。逗号前面是标准名称，逗号后面是符合该标准的编码规则**&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>PEM 格式的数据文件通常以 &lt;code>.pem&lt;/code>、&lt;code>.cer&lt;/code>、&lt;code>.crt&lt;/code>、&lt;code>.key&lt;/code> 结尾。其中 .ert 和 .crt 常用来表示证书、.key 常用来表示密钥(公钥或私钥)&lt;/p>
&lt;blockquote>
&lt;p>PEM 文件中的标签比文件后缀更准确地表示数据类型，因为可以将许多不同类型的数据保存在 .pem 文件中。&lt;/p>
&lt;/blockquote>
&lt;h2 id="pem-格式文件示例">PEM 格式文件示例&lt;/h2>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># 私钥&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>-----BEGIN RSA PRIVATE KEY-----
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>kXxvLDA91VHVdTmRCYPWDOlNCbUi6S42KHmN2RukRM/Y0wMxHvlN7hnYCTrv8nEk
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>KcKJ9XNJAlWxETUe6hYQbvU6JtgIwPav38ZF2IqqdJF/v5EsQd1mg8PI3dqaGFNn
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>wc2osmNP4FN4sz57P1ifsNWobVwvol0VLvuF5zfjvlNzr7YuNGxr/Uu/pQVukQFf
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>8u0mmi7AZdzjdfsphW0Zi4fil3hI5m8HbTsbhfT53TofKt4nRZA/DUCCu6+/NHEW
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>ntY5STMyU0DQW8hasD9DfF9RiSVKm4Unn8TQ6yMFNQXCX5Sg3vgduMz8TUkT1KM3
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>WnwX9X5IO5WeA72dsVOXgQ&lt;span style="color:#f92672">==&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>-----END RSA PRIVATE KEY-----
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># 公钥&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>-----BEGIN RSA PUBLIC KEY-----
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>0JUbBOzKiYp/0MXhux8XH0SxWBfnzCATH4oGvDj5SD6H2z1m97mkpRhRMul4l8vM
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Lhgf2rWHsVHq5FjMeRVigOIIlHyjOFurigZ7pcVqWzHYIck6cGsI4JtEBNuqQ9EM
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>NyMYGpcV+TV0bw9nTUK//Fst++dueWVLmqlKTCbFQRmo2lxwKzXqKjJkSgxge/gh
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>MvC4/xh1Keizzlm73pAnOVhTow+HW5Wgas+maPXMaNcpJ8RryFlG6ke3CBaNqrV8
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>iheO4riYPZQWQkl8NGLlJyXeq/awl6ovbshyZcO45faoDMxl/J93+sczW1ZlF/1B
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>QKUvQGEsNFsT7YAejZvh7w&lt;span style="color:#f92672">==&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>-----END RSA PUBLIC KEY-----
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h1 id="der-编码规则">DER 编码规则&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;a href="https://en.wikipedia.org/wiki/X.690#DER_encoding">Wiki&lt;/a>&lt;/p>
&lt;/blockquote>
&lt;p>&lt;strong>Distinguished Encoding Rules(专用编码规则，简称 DER)&lt;/strong> 是 BER 的一种受限制变体，用于为 ASN.1 所描述的数据结构生成明确的传输语法。像 CER 一样，DER 编码是有效的 BER 编码。 DER 与 BER 相同，只是删除了一个发送者的所有选项。&lt;/p>
&lt;p>用白话说： DER 是一种以二进制形式编码 ASN.1 语法的方法&lt;/p>
&lt;p>&lt;strong>DER，是对 &lt;strong>&lt;a href="https://www.yuque.com/go/doc/33220231">&lt;strong>ASN.1&lt;/strong>&lt;/a>&lt;/strong> 这种语言进行编码的一种规则&lt;/strong>，也是最常用的一种。所谓对某种语言编码，就是类似编译器的效果。所以也可以称为 &lt;strong>ASN.1 的 DER 规则&lt;/strong>。&lt;/p>
&lt;h2 id="x690-标准">X.690 标准&lt;/h2>
&lt;p>是 ITU-T 标准，指定了几种 ASN.1 编码格式&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/X.690#BER_encoding">Basic Encoding Rules&lt;/a>(基本编码规则，简称 BER)&lt;/li>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/X.690#CER_encoding">Canonical Encoding Rules&lt;/a>(规范编码规则，简称 CER)&lt;/li>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/X.690#DER_encoding">Distinguished Encoding Rules&lt;/a>(杰出编码规则，简称 DER)&lt;/li>
&lt;/ul>
&lt;h1 id="asn1-与-pem-的关系">ASN.1 与 PEM 的关系&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;a href="https://en.wikipedia.org/wiki/ASN.1#Relation_to_Privacy-Enhanced_Mail_(PEM)_Encoding">Wiki&lt;/a>&lt;/p>
&lt;/blockquote>
&lt;p>PEM 编码 与 ASN.1 及其 编码/解码器 完全无关。但是由于编码后的 ASN.1 数据通常是二进制的，也就是 Bytes(字节流) 类型的数据，所以经常使用 PEM 对这些编码后的 ASN.1 数据再次进行编码，以获得人类可读的字符串类型数据。这可以帮助再文本编码敏感的媒体(比如 SMTP 服务)上进行传输以及复制和粘贴。&lt;/p>
&lt;h1 id="pkcs非对称加密标准">PKCS(非对称加密标准)&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;a href="https://en.wikipedia.org/wiki/PKCS">Wiki&lt;/a>&lt;/p>
&lt;/blockquote>
&lt;p>&lt;strong>Public Key Cryptography Standards(非对称加密标准，简称 PKCS)&lt;/strong>。在密码学中，&lt;strong>PKCS&lt;/strong>代表“公钥密码学标准”。这些是 RSA Security LLC 从 1990 年代初开始设计和发布的一组&lt;a href="https://en.wikipedia.org/wiki/Public-key_cryptography">&lt;strong>公共密钥加密&lt;/strong>&lt;/a>&lt;strong>标准&lt;/strong>。该公司发布了这些标准，以促进他们拥有专利的加密技术的使用，例如 RSA 算法，Schnorr 签名算法以及其他几种。尽管不是行业标准（因为公司保留了对它们的控制权），但近年来有些标准[&lt;em>何时？&lt;/em>]已开始进入“标准轨道”相关标准组织的流程，例如 IETF 和 PKIX 工作组。&lt;/p>
&lt;blockquote>
&lt;p>注意:很多标准已经被废弃,所以下文看到的标准的编号不是连续的,比如 2、4、13、14 等等标准，就没有了，现在最常用的是 1、8 号标准&lt;/p>
&lt;/blockquote>
&lt;p>PKCS 的起源
X.509 只是一种常用的证书格式，但有人觉得这种格式能装的信息不够多，因此 又定义了一些比 X.509 更大的数据结构（但仍然用 ASN.1）， 能将证书、秘钥以及其他东西封装（打包）到一起。因此，有时说我需要“一个证书”时，其 实真正说的是包（package）中包含的那个“证书”（a certificate in one of these envelopes），而不是这个包本身。&lt;/p>
&lt;h2 id="pkcs1--rsa-密码学标准">PKCS＃1 # RSA 密码学标准&lt;/h2>
&lt;p>参见 RFC 8017。该标准定义了 RSA 公钥和私钥的数学属性和格式(这个密钥对是使用 ASN.1 的编码规则编码后的结果)。此外，还定义了执行 RSA 加密、解密、签名、验签的基本算法。&lt;/p>
&lt;h2 id="pkcs3--diffie-hellman-密钥协商标准">PKCS＃3 # Diffie-Hellman 密钥协商标准&lt;/h2>
&lt;p>一种加密协议，允许彼此不具有先验知识的两个方通过不安全的通信通道共同建立共享的秘密密钥。&lt;/p>
&lt;h2 id="pkcs5--基于密码的加密标准">PKCS＃5 # 基于密码的加密标准&lt;/h2>
&lt;p>参见 RFC 8018 和 PBKDF2。&lt;/p>
&lt;h2 id="pkcs7--加密消息语法标准">PKCS＃7 # 加密消息语法标准&lt;/h2>
&lt;p>参见 RFC 2315。用于在 PKI 下对消息进行签名和/或加密。也用于证书分发（例如，作为对 PKCS＃10 消息的响应）。形成了 S / MIME 的基础，S / MIME 于 2010 年基于 RFC 5652（一种更新的加密消息语法标准（CMS））建立。通常用于单点登录。&lt;/p>
&lt;h2 id="pkcs8-私钥内容的标准语法">PKCS＃8 #私钥内容的标准语法&lt;/h2>
&lt;blockquote>
&lt;p>注意：
该标准仅定义了私钥的标准，一般情况下，对应的公钥标准一般是 PKIX。
该标准不仅定义了 RSA 算法的密钥的标准，还定义了其他算法的标准。而 PKCS#1 仅定义了 RSA 算法密钥的标准。&lt;/p>
&lt;/blockquote>
&lt;p>参见 RFC 5958。用于携带私有证书密钥对（加密或未加密）。&lt;/p>
&lt;h2 id="pkcs9--所选属性类型">PKCS＃9 # 所选属性类型&lt;/h2>
&lt;p>参见 RFC 2985。
定义用于 PKCS＃6 扩展证书，PKCS＃7 数字签名消息，PKCS＃8 私钥信息和 PKCS＃10 证书签名请求中使用的所选属性类型。&lt;/p>
&lt;h2 id="pkcs10--认证请求标准证书请求-csr-的标准">PKCS＃10 # 认证请求标准(证书请求 CSR 的标准)&lt;/h2>
&lt;p>参见 RFC 2986。发送到 CA 以请求公钥认证的消息格式。请参阅证书签名请求。&lt;/p>
&lt;h2 id="pkcs11--加密令牌接口">PKCS＃11 # 加密令牌接口&lt;/h2>
&lt;p>也称为“ Cryptoki”。一个 API，用于定义加密令牌的通用接口（另请参阅硬件安全模块）。常用于单点登录，公共密钥加密和磁盘加密[10]系统。
RSA Security 已将 PKCS＃11 标准的进一步开发移交给了 OASIS PKCS 11 技术委员会。&lt;/p>
&lt;h2 id="pkcs12--个人信息交换语法标准">PKCS＃12 # 个人信息交换语法标准&lt;/h2>
&lt;p>参见 RFC 7292。定义一种文件格式，通常用于存储私有密钥以及随附的公共密钥证书，并使用基于密码的对称密钥进行保护。
PFX 是 PKCS＃12 的前身。
此容器格式可以包含多个嵌入式对象，例如多个证书。通常使用密码进行保护/加密。可用作 Java 密钥库的格式，并在 Mozilla Firefox 中建立客户端身份验证证书。可用于 Apache Tomcat。&lt;/p>
&lt;h2 id="pkcs15--密码令牌信息格式标准">PKCS＃15 # 密码令牌信息格式标准&lt;/h2>
&lt;p>定义一个标准，允许加密令牌的用户向应用程序标识自己，而与应用程序的 Cryptoki 实现（PKCS＃11）或其他 API 无关。RSA 放弃了本标准中与 IC 卡相关的部分，使其符合 ISO / IEC 7816-15。[14]&lt;/p></description></item><item><title>Docs: 证书 与 PKI</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/7.%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8/cryptography%E5%AF%86%E7%A0%81%E5%AD%A6/%E5%85%AC%E5%BC%80%E5%AF%86%E9%92%A5%E5%8A%A0%E5%AF%86/%E8%AF%81%E4%B9%A6-%E4%B8%8E-pki/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/7.%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8/cryptography%E5%AF%86%E7%A0%81%E5%AD%A6/%E5%85%AC%E5%BC%80%E5%AF%86%E9%92%A5%E5%8A%A0%E5%AF%86/%E8%AF%81%E4%B9%A6-%E4%B8%8E-pki/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Public_key_certificate">Wiki,Public Key Certificate&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Public_key_infrastructure">Wiki,PKI&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Certificate_signing_request">Wiki,CSR&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Certificate_authority">Wiki,CA&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Root_certificate">Wiki,Root Certificate&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://datatracker.ietf.org/doc/html/rfc5280">RFC,5280&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://mp.weixin.qq.com/s/E-aU-lbieGLokDKbjdGc3g">公众号,云原生生态圈-白话文说 CA 原理&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://arthurchiao.art/blog/everything-about-pki-zh/">Arthurchiao 博客,[译] 写给工程师：关于证书（certificate）和公钥基础设施（PKI）的一切（SmallStep, 2018）&lt;/a>
&lt;ul>
&lt;li>&lt;a href="https://mp.weixin.qq.com/s/li3ZjfNgX5nh7AKjyyzt5A">公众号-云原生实验室，搬运了上面的文章&lt;/a>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>Certificate 与 PKI 的目标很简单：Bind names to Public Keys(将名字关联到公钥)。这是关于 Certificate 与 PKI 的最高抽象，其他都是属于实现细节&lt;/p>
&lt;h1 id="certificate">Certificate&lt;/h1>
&lt;p>&lt;strong>Certificate(证书)&lt;/strong> 在密码学中，是指 &lt;a href="https://desistdaydream.github.io/docs/IT%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/7.%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8/Cryptography(%E5%AF%86%E7%A0%81%E5%AD%A6)/%E5%85%AC%E5%BC%80%E5%AF%86%E9%92%A5%E5%8A%A0%E5%AF%86.md">公开密钥加密&lt;/a> 中完善其签名&lt;a href="https://desistdaydream.github.io/docs/IT%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/7.%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8/Cryptography(%E5%AF%86%E7%A0%81%E5%AD%A6)/%E5%85%AC%E5%BC%80%E5%AF%86%E9%92%A5%E5%8A%A0%E5%AF%86.md#%E7%BC%BA%E7%82%B9">缺点&lt;/a>的 &lt;strong>Public Key Certificate(公钥证书)&lt;/strong>。在公开密钥加密的介绍中，我们看到了公钥加密的特点，并且也发现了缺点，公钥容易被劫持。那么为了解决这个问题，就需要一个东西可以&lt;strong>验证公钥的真实性&lt;/strong>。公钥证书也就由此而来。&lt;/p>
&lt;p>&lt;strong>Public Key Certificate(公钥证书，简称 PKC)&lt;/strong> 也称为 &lt;strong>Digital Certifacte(数字证书)&lt;/strong> 或 &lt;strong>Identity Certificate(身份证书)&lt;/strong>，是一种用于证明公钥的所有权的电子文档。&lt;/p>
&lt;p>假设有这么一种场景：公钥加密系统使我们能知道和谁在通信，但这个事情的前提是：我们必须要有对方的公钥&lt;/p>
&lt;p>那么，如果我们不知道对方的公钥，那么该怎么办呢？这时候 Certificate 就出现了。&lt;/p>
&lt;ul>
&lt;li>首先，我需要从对方手里拿到公钥和其拥有者的信息&lt;/li>
&lt;li>那么我如何相信我拿到的信息是真实有效的呢？~可以请一个双方都信任的权威机构，对我拿到的信息做出证明
&lt;ul>
&lt;li>而这个权威机构用来证明信息有效的东西，就是 Certificate&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>公钥证书通常应该包含如下内容：&lt;/p>
&lt;ul>
&lt;li>密钥的信息&lt;/li>
&lt;li>有关其所有者的身份信息，称为 Subject(主体)&lt;/li>
&lt;li>验证证书内容的实体的数字签名，这个实体称为 Issuer(发行人)&lt;/li>
&lt;li>权威机构对证书的签名，签名的大概意思就是：&lt;code>Public key XXX 关联到了 name XXX&lt;/code>，这就对应了文章开头的那句话：Certificate 与 PKI 的目标很简单：Bind names to Public Keys(将名字关联到公钥)
&lt;ul>
&lt;li>对证书的签名的实体称为 &lt;strong>Certificate Authority(简称 CA)&lt;/strong>，也可以称为 &lt;strong>Issuer(签发者)&lt;/strong>。&lt;/li>
&lt;li>被签名的实体称为 &lt;strong>Subject(主体)&lt;/strong>。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>举个例子，如果某个 Issuer 为 Bob 签发了一张证书，其中的内容就可以解读如下：
&lt;em>Some Issuer&lt;/em> says &lt;em>Bob&lt;/em>’s public key is 01:23:42…
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/wlyw54/1634110798410-4fe856d6-2d02-43a9-b233-229b8d48fa51.png" alt="image.png">
证书是权威机构颁发的身份证明，并没有什么神奇之处
其中 &lt;code>Some Issuer&lt;/code> 是证书的签发者(CA)，证书是为了证明这是 Bob 的公钥， Some Issuer 也是这个声明的签字方。&lt;/p>
&lt;p>如果签名有效，并且检查证书的软件信任发行者，那么它可以使用该密钥与证书的主题安全地通信。在电子邮件加密，代码签名和电子签名系统中，证书的主体通常是一个人或组织。然而，在传输层安全性（TLS）中，证书的主体通常是计算机或其他设备，但除了在识别设备中的核心作用之外，TLS 证书还可以识别组织或个人。 TLS 有时被其旧的名称安全套接字层（SSL）调用，对于 HTTPS 的一部分是值得注意的，该协议是安全浏览 Web 的协议。&lt;/p>
&lt;p>公钥证书最常用的格式是 X.509 标准。&lt;/p>
&lt;h2 id="证书的类型">证书的类型&lt;/h2>
&lt;ol>
&lt;li>自签名证书：一般都是 CA 机构使用 CA 自己的的公钥签署的证书，这样别人拿到该证书后，才可以去找 CA 验证这个证书是不是可信的。&lt;/li>
&lt;li>根证书：根证书是标识根证书颁发机构(CA)的公钥证书。根证书是自签名的，并构成基于 X.509 的公钥基础结构（PKI）的基础。&lt;/li>
&lt;li>TLS / SSL 服务器证书&lt;/li>
&lt;li>TLS / SSL 客户端证书&lt;/li>
&lt;li>电子邮件证书&lt;/li>
&lt;li>代码签名证书&lt;/li>
&lt;li>合格证书&lt;/li>
&lt;li>中级证书&lt;/li>
&lt;li>终端实体或叶子证书&lt;/li>
&lt;/ol>
&lt;h1 id="public-key-infrastructure">Public Key Infrastructure&lt;/h1>
&lt;p>&lt;strong>Public Key Infrastructure(公钥基础设施)&lt;/strong> 是用来管理数字证书和管理公钥加密所需的一组 Entity(实体，包括但不限于 角色、策略、硬件、软件、程序 等等)。PKI 的目的是为了促进一系列网络活动的安全传输，例如电子商务、网上银行、敏感电子邮件。&lt;/p>
&lt;p>PKI 是通用的，与厂商无关的概念，适用于任何地方，因此及时系统分布在世界各地，彼此之间也能安全地通信；如果我们使用 TLS everywhere 模型，甚至连 VPN 都不需要。&lt;/p>
&lt;p>PKI 的标准由 RFC 5280 定义，然后 &lt;a href="https://cabforum.org/">CA/Browser Forum&lt;/a> (a.k.a., CA/B or CAB Forum) 对其进行了进一步完善。PKI 的标准称为 &lt;strong>Public-Key Infrastructure(X.509)(公要基础设施(X.509)，简称 PKIX)&lt;/strong>，由于 PKIX 是围绕 X.509 证书标准定义的 PKI 标准，所以 PKI 后面就加了一个 X~~~~~o(╯□╰)o ~~~从 RFC 5280 也可以看到每页文档的页眉写的是 &lt;code>PKIX Certificate and CRL Profile&lt;/code>。并且 IETF 与 1995 年秋季成了了 &lt;a href="https://datatracker.ietf.org/wg/pkix/about/">PKIX 工作组&lt;/a>。&lt;/p>
&lt;h2 id="certificate-authority证书权威">Certificate Authority(证书权威)&lt;/h2>
&lt;p>&lt;strong>Certificate Authority(证书权威，简称 CA)&lt;/strong> 是拥有公信力的颁发数字证书的实体，通常称为&lt;strong>证书颁发机构&lt;/strong>。&lt;/p>
&lt;p>CA 自身的证书，通常称为 &lt;strong>Root Certificate(根证书)&lt;/strong>，根证书是使用 CA 的私钥 &lt;strong>Self-signed(自签名的)&lt;/strong>，且是 CA 的唯一标识。&lt;/p>
&lt;p>&lt;strong>CA 使用自己的私钥为其他实体签名并颁发证书&lt;/strong>。就像文章开头提到的一样，Bind names to Public Keys，CA 为公钥和名字之间的绑定关系做担保。&lt;/p>
&lt;h3 id="trust-stores信任仓库即操作系统浏览器等保存证书的地方">Trust Stores(信任仓库)，即操作系统、浏览器等保存证书的地方&lt;/h3>
&lt;p>那么，当我们访问一个网站时，是如何验证其证书的真实性呢?~其实，通常都会有一个 CA 仓库，用来保存一些预配置的可信的根证书。凭借这些预配置的根证书，当我们访问互联网上绝大部分网站时，就可以验证其身份。&lt;/p>
&lt;p>这个信任仓库又是如何来的呢？&lt;/p>
&lt;ul>
&lt;li>浏览器 # 浏览器默认使用的信任仓库以及其他任何使用 TLS 的东西，都是由 4 个组织维护的
&lt;ul>
&lt;li>&lt;a href="http://www.apple.com/certificateauthority/ca_program.html">Apple’s root certificate&lt;/a>：iOS/macOS 程序&lt;/li>
&lt;li>&lt;a href="https://social.technet.microsoft.com/wiki/contents/articles/31633.microsoft-trusted-root-program-requirements.aspx">Microsoft’s root certificate program&lt;/a>：Windows 使用&lt;/li>
&lt;li>&lt;a href="https://www.mozilla.org/en-US/about/governance/policies/security-group/certs/">Mozilla’s root certificate program&lt;/a>： Mozilla 产品使用，由于其开放和透明，也作为其他一些信任仓库从基础 (e.g., for many Linux distributions)&lt;/li>
&lt;li>Google &lt;a href="https://www.chromium.org/Home/chromium-security/root-ca-policy">未维护 root certificate program&lt;/a> （Chrome 通常使用所在计算的操作系统的信任仓库），但 &lt;a href="https://chromium.googlesource.com/chromium/src/+/master/net/data/ssl/blacklist/README.md">维护了自己的黑名单&lt;/a>， 列出了自己不信任的根证书或特定证书。 (&lt;a href="https://chromium.googlesource.com/chromiumos/docs/+/master/ca_certs.md">ChromeOS builds off of Mozilla’s certificate program&lt;/a>)&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>操作系统 # 操作系统中的信任仓库通常是各自发行版自带的。不同的发行版，保存路径不同，保存方式也不同：
&lt;ul>
&lt;li>CentOS 发行版
&lt;ul>
&lt;li>/etc/pki/ca-trust/extracted/openssl/ca-bundle.trust.crt # 包含所有证书，每个证书前有注释&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Ubuntu 发行版
&lt;ul>
&lt;li>/etc/ssl/certs/* # 该目录中一个证书一个文件&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Windows，证书位置如图
&lt;ul>
&lt;li>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/wlyw54/1662898111701-e46d8a99-c518-48fa-8eb2-9a37448d3df3.png" alt="image.png">&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>信任仓库中通常包含了超过 100 个由这些程序维护的常见 CA。比如：&lt;/p>
&lt;ul>
&lt;li>Let’s Encrypt&lt;/li>
&lt;li>Symantec&lt;/li>
&lt;li>DigiCert&lt;/li>
&lt;li>Entrust&lt;/li>
&lt;/ul>
&lt;h4 id="示例">示例&lt;/h4>
&lt;p>比如在 Linux 各种发行版中上述目录中有一个名为 GlobalSign_Root_CA 的根证书，百度就是使用这个证书签名的。&lt;/p>
&lt;p>这是通过浏览器访问 &lt;a href="http://www.baidu.com">http://www.baidu.com&lt;/a> 获取到的证书信息
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/wlyw54/1638255619893-aaa4aaf0-0b19-4aab-94c7-ea6d52c40e8b.png" alt="image.png">
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/wlyw54/1638255970307-44dc01bc-7d7d-4adb-94c7-bb7ec2ce1636.png" alt="image.png">
这是从服务器的 CA 仓库中获取的 GlobalSign_Root_CA 这个 CA 的证书信息
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/wlyw54/1638255663132-94adcb92-b634-4f45-936b-8f51245f7558.png" alt="image.png">&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">[&lt;/span>root@hw-cloud-xngy-jump-server-linux-2 ~&lt;span style="color:#f92672">]&lt;/span>&lt;span style="color:#75715e"># openssl x509 -text -noout -in /etc/ssl/certs/GlobalSign_Root_CA.pem&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Certificate:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Data:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Version: &lt;span style="color:#ae81ff">3&lt;/span> &lt;span style="color:#f92672">(&lt;/span>0x2&lt;span style="color:#f92672">)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Serial Number:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> 04:00:00:00:00:01:15:4b:5a:c3:94
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Signature Algorithm: sha1WithRSAEncryption
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Issuer: C &lt;span style="color:#f92672">=&lt;/span> BE, O &lt;span style="color:#f92672">=&lt;/span> GlobalSign nv-sa, OU &lt;span style="color:#f92672">=&lt;/span> Root CA, CN &lt;span style="color:#f92672">=&lt;/span> GlobalSign Root CA
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Validity
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Not Before: Sep &lt;span style="color:#ae81ff">1&lt;/span> 12:00:00 &lt;span style="color:#ae81ff">1998&lt;/span> GMT
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Not After : Jan &lt;span style="color:#ae81ff">28&lt;/span> 12:00:00 &lt;span style="color:#ae81ff">2028&lt;/span> GMT
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Subject: C &lt;span style="color:#f92672">=&lt;/span> BE, O &lt;span style="color:#f92672">=&lt;/span> GlobalSign nv-sa, OU &lt;span style="color:#f92672">=&lt;/span> Root CA, CN &lt;span style="color:#f92672">=&lt;/span> GlobalSign Root CA
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>......
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>可以看到，两个证书的信息是一样的，时间不一致是由于时区设置的问题，浏览器直接打开证书变成了东八区。所以是 20:00:00；如果从窗口导出证书成文件，再使用 openssl 命令查看，就可以发现，两个证书是一模一样的。&lt;/p>
&lt;h3 id="chain-of-trust信任链">Chain of trust(信任链)&lt;/h3>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/wlyw54/1638252283465-124564d9-4f52-4812-9cfb-484fb54b599b.png" alt="image.png">
CA 使用自己的私钥签一个根证书，然后再为下级 Issuer 签署证书，下级 Issuer 还可以为其自身的下级 Issuer 签署证书。这么层层签署，可以形成一个树形结构的信任链。&lt;/p>
&lt;p>现在假如 A 是 CA，签署证书给 B，C 想访问 B 提供的服务，C 在访问时，如何确保 B 就是 B 呢？~这就是 TLS/SSL 协议所要做的事情。总结一下就是 C 首先要获取 A 的证书，这是访问 B 时，就可以使用 A 的证书验证 B 的证书。并且，由于 A 的证书是用其私钥签名的，只要 A 签证书的私钥(即 CA 的私钥)不泄露，整个信任链就是可信的。&lt;/p>
&lt;h3 id="保证-ca-私钥的安全">保证 CA 私钥的安全&lt;/h3>
&lt;p>CAB Forum Baseline Requirements 4.3.1 明确规定：一个 Web PKI CA 的 root private key 只能通过 issue a direct command 来签发证书。&lt;/p>
&lt;ul>
&lt;li>换句话说，Web PKI root CA 不能自动化证书签名（certificate signing）过程。&lt;/li>
&lt;li>对于任何大的 CA operation 来说，无法在线完成都是一个问题。 不可能每次签发一个证书时，都人工敲一个命令。&lt;/li>
&lt;/ul>
&lt;p>这样规定是出于安全考虑。&lt;/p>
&lt;ul>
&lt;li>Web PKI root certificates 广泛存在于信任仓库中，很难被撤回。截获一个 root CA private key 理论上将影响几十亿的人和设备。&lt;/li>
&lt;li>因此，最佳实践就是，确保 root private keys 是离线的（offline），理想情况下在一些 &lt;a href="https://en.wikipedia.org/wiki/Hardware_security_module">专用硬件&lt;/a> 上，连接到某些物理空间隔离的设备上，有很好的物理安全性，有严格的使用流程。&lt;/li>
&lt;/ul>
&lt;p>一些 internal PKI 也遵循类似的实践，但实际上并没有这个必要。&lt;/p>
&lt;ul>
&lt;li>如果能自动化 root certificate rotation （例如，通过配置管理或编排工具，更新信任仓库）， 你就能轻松地 rotate 一个 compromised root key。&lt;/li>
&lt;li>由于人们如此沉迷于 internal PKI 的根秘钥管理，导致 internal PKI 的部署效率大大 降低。你的 AWS root account credentials 至少也是机密信息，你又是如何管理它的呢？&lt;/li>
&lt;/ul>
&lt;h3 id="其他">其他&lt;/h3>
&lt;p>可以通过工具来创建私有 CA 证书(即自己创造一个 CA 所用的证书，等于是自己的其中一台设备当做 CA 来给自己所用的其余设备颁发证书)(自签名的)以便让个人或公司内部使用。比如 openssl 工具就可以实现。openssl 即可创建私有 CA 证书。&lt;/p>
&lt;h2 id="certificate-signing-request证书签名请求">Certificate Signing Request(证书签名请求)&lt;/h2>
&lt;p>在 PKI 系统中，&lt;strong>Certificate Signing Request(证书签名请求，简称 CSR) &lt;strong>是申请人发送到 PKI 的注册机构，用来申请&lt;/strong>公钥证书&lt;/strong>的一种消息。&lt;/p>
&lt;p>CSR 最常见的格式是 &lt;a href="https://en.wikipedia.org/wiki/PKCS">PKCS&lt;/a>＃10 规范；另一个是某些&lt;a href="https://en.wikipedia.org/wiki/Web_browser">浏览器&lt;/a>生成的签名公钥和质询 &lt;a href="https://en.wikipedia.org/wiki/SPKAC">SPKAC&lt;/a> 格式。&lt;/p>
&lt;p>在创建 CSR 之前，申请人首先需要生成一个密钥对，并将私钥保密。实际上，CSR 也可以称为证书，想要创建一个 CSR，则需要使用申请人的密钥中的私钥进行签名。&lt;/p>
&lt;p>CSR 中应包含&lt;/p>
&lt;ul>
&lt;li>
&lt;p>&lt;strong>名字&lt;/strong> # 申请人的识别信息(比如 X.509 规范中的 Subject 字段)&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>公钥&lt;/strong> # 从申请人密钥中提取出的公钥&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>签名&lt;/strong> #&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>其他信息&lt;/strong> #&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h1 id="证书的验证过程">证书的验证过程&lt;/h1>
&lt;p>CA 收到一个 CSR 并验证签名之后，接下来需要确认证书中绑定的 name 是否真的 是这个 subscriber 的 name。这项工作很棘手。 证书的核心功能是&lt;strong>能让 RP 对 subscriber 进行认证&lt;/strong>。因此， 如果一个&lt;strong>证书都还没有颁发，CA 如何对这个 subscriber 进行认证呢&lt;/strong>？
答案是：分情况。&lt;/p>
&lt;h2 id="web-pki-证明身份过程">Web PKI 证明身份过程&lt;/h2>
&lt;p>Web PKI 有三种类型的证书，它们&lt;strong>最大的区别就是如何识别 subscriber&lt;/strong>， 以及它们所用到的 &lt;strong>identity proofing 机制&lt;/strong>。
这三种证书是：&lt;/p>
&lt;ol>
&lt;li>domain validation (DV，域验证)DV 证书绑定的是 &lt;strong>DNS name&lt;/strong>，CA 在颁发时需要验证的这个 domain name 确实是由该 subscriber 控制的。证明过程通常是通过一个简单的流程，例如
&lt;ol>
&lt;li>给 WHOIS 记录中该 domain name 的管理员发送一封确认邮件。&lt;/li>
&lt;li>&lt;a href="https://ietf-wg-acme.github.io/acme/draft-ietf-acme-acme.html">ACME protocol&lt;/a> （最初由 Let’s Encrypt 开发和使用）改进了这种方式，更加自动化：不再用邮件验证 ，而是由 ACME CA 提出一个 challenge，该 subscriber 通过完成这个问题来证明它拥有 这个域名。challenge 部分属于 ACME 规范的扩展部门，常见的包括：
&lt;ul>
&lt;li>在指定的 URL 上提供一个随机数（HTTP challenge）&lt;/li>
&lt;li>在 DNS TXT 记录中放置一个随机数（DNS challenge）&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ol>
&lt;/li>
&lt;li>organization validation (OV，组织验证)
&lt;ul>
&lt;li>OV 和下面将介绍的 EV 证书构建在 DV 证书之上，它们包括了 name 和域名 &lt;strong>所属组织的位置信息（location）&lt;/strong>。&lt;/li>
&lt;li>OV 和 EV 证书不仅仅将证书关联到域名，还关联到控制这个域名的法律实体（legal entity）。&lt;/li>
&lt;li>OV 证书的验证过程，不同的 CA 并不统一。为解决这个问题，CAB Forum 引入了 EV 证书。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>extended validation&lt;/strong> (EV，扩展验证)这些完成之后，当相应网站时，&lt;strong>某些浏览器会在 URL 栏中显示该组织的名称&lt;/strong>。例如：&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/wlyw54/1638261597799-3bbc2a87-727d-4c25-8492-f993a2e94ead.png" alt="image.png">但除了这个场景之外，EV certificates 并未得到广泛使用，Web PKI RP 也未强依赖它。
&lt;ul>
&lt;li>EV 证书包含的基本信息与 OV 是一样的，但强制要求严格验证（identity proofing）。&lt;/li>
&lt;li>EV 过程需要几天或几个星期，其中可能包括公网记录搜索（public records searches）和公司人员（用笔）签署的（纸质）证词。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ol>
&lt;p>&lt;strong>本质上来说，每个 Web PKI RP 只需要 DV 级别的 assurance&lt;/strong> 就行了， 也就是确保域名是被该 subscriber 控制的。重要的是能理解一个 DV 证书在设计上的意思和在实际上做了什么：&lt;/p>
&lt;ul>
&lt;li>在设计上，希望通过它证明：请求这个证书的 entity 拥有对应的域名；&lt;/li>
&lt;li>在实际上，真正完成的操作是：在某个时间，请求这个证书的 entity 能读一封邮件，或配置一条 DNS 记录，或能通过 HTTP serve 一个指定随机数等等。&lt;/li>
&lt;/ul>
&lt;p>但话说回来，DNS、电子邮件和 BGP 这些底层基础设施本身的安全性也并没有做到足够好， 针对这些基础设施的攻击还是 &lt;a href="https://doublepulsar.com/hijack-of-amazons-internet-domain-service-used-to-reroute-web-traffic-for-two-hours-unnoticed-3a6f0dda6a6f">时有发生&lt;/a>， 目的之一就是获取证书。&lt;/p>
&lt;h2 id="internal-pki-证明身份过程">Internal PKI 证明身份过程&lt;/h2>
&lt;p>上面是 Web PKI 的身份证明过程，再来看 internal PKI 的身份证明过程。
实际上，用户可以使用&lt;strong>任何方式&lt;/strong>来做 internal PKI 的 identity proofing， 并且效果可能比 Web PKI 依赖 DNS 或邮件方式的效果更好。
乍听起来好像很难，但其实不难，因为可以&lt;strong>利用已有的受信基础设施&lt;/strong>： 用来搭建基础设施的工具，也能用来为这些基础设施之上的服务创建和证明安全身份。&lt;/p>
&lt;ul>
&lt;li>如果用户已经信任 Chef/Puppet/Ansible/Kubernetes，允许它们将代码放到服务器上， 那也应该信任它们能完成 identity attestations&lt;/li>
&lt;li>如果在 AWS 上，可以用 &lt;a href="https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/instance-identity-documents.html">instance identity documents&lt;/a>&lt;/li>
&lt;li>如果在 GCP：&lt;a href="https://cloud.google.com/compute/docs/instances/verifying-instance-identity">GCP&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://docs.microsoft.com/en-us/azure/active-directory/managed-identities-azure-resources/how-to-use-vm-token">Azure&lt;/a>&lt;/li>
&lt;/ul>
&lt;p>provisioning infrastructure 必须理解 identity 的概念，这样才能将正确的代码放到正确的位置。 此外，用户必须信任这套机制。基于这些知识和信任，才能配置 RP 信任仓库、将 subscribers 纳入你的 internal PKI 管理范围。 而完成这些功能全部所需做的就是：设计和实现某种方式，能让 provisioning infrastructure 在每个服务启动时，能将它们的 identity 告诉你的 CA。 顺便说一句，这正是 &lt;a href="https://smallstep.com/certificates/">step certificates&lt;/a> 解决的事情。&lt;/p>
&lt;h1 id="证书的生命周期">证书的生命周期&lt;/h1>
&lt;h2 id="expiration过期">Expiration（过期）&lt;/h2>
&lt;p>证书通常都会过期。虽然这不是强制规定，但一般都这么做。设置一个过期时间非常重要，&lt;/p>
&lt;ul>
&lt;li>&lt;strong>证书都是分散在各处的&lt;/strong>：通常 RP 在验证一个证书时，并没有某个中心式权威能感知到（这个操作）。&lt;/li>
&lt;li>如果没有过期时间，证书将永久有效。&lt;/li>
&lt;li>安全领域的一条经验就是：&lt;strong>时间过的越久，凭证被泄露的概率就越接近 100%&lt;/strong>。&lt;/li>
&lt;/ul>
&lt;p>因此，设置过期时间非常重要。具体来说，X.509 证书中包含一个有效时间范围：&lt;/p>
&lt;ol>
&lt;li>&lt;em>issued at&lt;/em>&lt;/li>
&lt;li>&lt;em>not before&lt;/em>&lt;/li>
&lt;li>&lt;em>not after&lt;/em>：过了这个时间，证书就过期了。&lt;/li>
&lt;/ol>
&lt;p>这个机制看起来设计良好，但实际上也是有一些不足的：&lt;/p>
&lt;ul>
&lt;li>首先，&lt;strong>没有什么能阻止 RP&lt;/strong> 错误地（或因为糟糕的设计）&lt;strong>接受一个过期证书&lt;/strong>；&lt;/li>
&lt;li>其次，证书是分散的。验证证书是否过期是每个 RP 的责任，而有时它们会出乱子。例如，&lt;strong>RP 依赖的系统时钟不对&lt;/strong>时。 &lt;strong>最坏的情况就是系统时钟被重置为了 unix epoch&lt;/strong>（1970.1.1），此时它无法信任任何证书。&lt;/li>
&lt;/ul>
&lt;p>在 subscriber 侧，证书过期后，私钥要处理得当：&lt;/p>
&lt;ul>
&lt;li>如果一个密钥对之前是&lt;strong>用来签名/认证&lt;/strong>的（例如，基于 TLS），
&lt;ul>
&lt;li>应该在不需要这个密钥对之后，&lt;strong>立即删除私钥&lt;/strong>。&lt;/li>
&lt;li>保留已经失效的签名秘钥（signing key）会导致不必要的风险：对谁都已经没有用处，反而会被拿去仿冒签名。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>如果密钥对是&lt;strong>用来加密的&lt;/strong>，情况就不同了。
&lt;ul>
&lt;li>只要还有数据是用这个加密过的，就需要&lt;strong>留着这个私钥&lt;/strong>。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>这就是为什么很多人会说，&lt;strong>不要用同一组秘钥来同时做签名和加密&lt;/strong>（signing and encryption）。 因为当一个用于签名的私钥过期时，&lt;strong>无法实现秘钥生命周期的最佳管理&lt;/strong>： 最终不得不保留着这个私钥，因为解密还要用它。&lt;/p>
&lt;h2 id="renewal续期">Renewal（续期）&lt;/h2>
&lt;p>证书快过期时，如果还想继续使用，就需要续期。&lt;/p>
&lt;h3 id="web-pki-证书续期">Web PKI 证书续期&lt;/h3>
&lt;p>Web PKI 实际上并&lt;strong>没有标准的续期过期&lt;/strong>：&lt;/p>
&lt;ul>
&lt;li>没有一个标准方式来延长证书的合法时间，&lt;/li>
&lt;li>一般是&lt;strong>直接用一个新证书替换过期的&lt;/strong>。&lt;/li>
&lt;li>因此续期过程和 issuance 过程是一样的：&lt;strong>生成并提交一个 CSR&lt;/strong>，然后完成 identity proofing。&lt;/li>
&lt;/ul>
&lt;h3 id="internal-pki-证书续期">Internal PKI 证书续期&lt;/h3>
&lt;p>对于 internal PKI 我们能做的更好。
最简单的方式是：&lt;/p>
&lt;ul>
&lt;li>&lt;strong>用 mTLS 之类的协议对老证书续期&lt;/strong>。&lt;/li>
&lt;li>CA 能对 subscriber 提供的客户端证书进行认证（authenticate），&lt;strong>重签一个更长的时间&lt;/strong>，然后返回这个证书。&lt;/li>
&lt;li>这使得续期过程&lt;strong>很容易自动化&lt;/strong>，而且强制 subscriber 定期与中心权威保持沟通。&lt;/li>
&lt;li>基于这种机制能轻松&lt;strong>构建一个证书的监控和撤销基础设施&lt;/strong>。&lt;/li>
&lt;/ul>
&lt;h3 id="小结">小结&lt;/h3>
&lt;p>证书的续期过程其实并不是太难，&lt;strong>最难的是记得续期这件事&lt;/strong>。
几乎每个管理过公网证书的人，都经历过证书过期导致的生产事故，&lt;a href="https://expired.badssl.com/">例如这个&lt;/a>。 我的建议是：&lt;/p>
&lt;ol>
&lt;li>发现问题之后，一定要全面排查，解决能发现的所有此类问题。&lt;/li>
&lt;li>另外，使用生命周期比较短的证书。这会反过来逼迫你们优化和自动化整个流程。&lt;/li>
&lt;/ol>
&lt;p>Let’s Encrypt 使自动化非常容易，它签发 90 天有效期的证书，因此对 Web PKI 来说非常合适。 对于 internal PKI，建议有效期签的更短：24 小时或更短。有一些实现上的挑战 —— &lt;a href="https://diogomonica.com/2017/01/11/hitless-tls-certificate-rotation-in-go/">hitless certificate rotation&lt;/a> 可能比较棘手 —— 但这些工作是值得的。&lt;/p>
&lt;p>用 step 检查证书过期时间：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>step certificate inspect cert.pem --format json | jq .validity.end
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>step certificate inspect https://smallstep.com --format json | jq .validity.end
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>将这种命令行封装到监控采集脚本，就可以实现某种程度的监控和自动化。&lt;/p>
&lt;h2 id="revocation撤销">Revocation（撤销）&lt;/h2>
&lt;p>如果一个私钥泄露了，或者一个证书已经不再用了，就需要撤销它。即希望：&lt;/p>
&lt;ol>
&lt;li>明确地将其标记为非法的，&lt;/li>
&lt;li>所有 RP 都不再信任这个证书了，即使它还未过期。&lt;/li>
&lt;/ol>
&lt;p>但实际上，&lt;strong>撤销证书过程也是一团糟&lt;/strong>。&lt;/p>
&lt;h3 id="主动撤销的困难">主动撤销的困难&lt;/h3>
&lt;ul>
&lt;li>与过期类似，&lt;strong>执行撤回的职责在 RP&lt;/strong>。&lt;/li>
&lt;li>与过期不同的是，&lt;strong>撤销状态无法编码在证书中&lt;/strong>。RP 只能依靠某些带外过程（out-of-band process） 来判断证书的撤销状态。&lt;/li>
&lt;/ul>
&lt;p>除非显式配置，否则大部分 Web PKI TLS RP 并不关注撤销状态。换句话说，默认情况下， 大部分 TLS 实现都乐于接受已经撤销的证书。&lt;/p>
&lt;h3 id="internal-pki被动撤销机制">Internal PKI：被动撤销机制&lt;/h3>
&lt;p>Internal PKI 的趋势是接受这个现实，然后试图通过&lt;strong>被动撤销&lt;/strong>（passive revocation）机制来弥补， 具体来说就是&lt;strong>签发生命周期很短的证书&lt;/strong>，这样就使撤销过程变得不再那么重要了。 想撤销一个证书时，直接不给它续期就行了，过一段时间就会自动过期。
可以看到，&lt;strong>这个机制有效的前提&lt;/strong>就是使用生命周期很短的证书。具体有多短？&lt;/p>
&lt;ol>
&lt;li>取决于你的威胁模型（安全专家说了算）。&lt;/li>
&lt;li>24 小时是很常见的，但也有短到 5 分钟的。&lt;/li>
&lt;li>如果生命周期太短，显然也会给可扩展性和可用性带来挑战：&lt;strong>每次续期都需要与 online CA 交互&lt;/strong>， 因此 CA 有性能压力。&lt;/li>
&lt;li>如果缩短了证书的生命周期，记得&lt;strong>确保你的时钟是同步的&lt;/strong>，否则就有罪受了。&lt;/li>
&lt;/ol>
&lt;p>对于 web 和其他的被动撤销不适合的场景，如果认真思考之后发现&lt;strong>真的&lt;/strong> 需要撤销功能，那有两个选择：&lt;/p>
&lt;ol>
&lt;li>CRL（，&lt;strong>证书撤销列表&lt;/strong>，RFC 5280）&lt;/li>
&lt;li>OCSP（Online Certificate Signing Protocol，&lt;strong>在线证书签名协议&lt;/strong>，RFC 2560）&lt;/li>
&lt;/ol>
&lt;h3 id="主动检查机制crl">主动检查机制：CRL&lt;/h3>
&lt;p>&lt;strong>Certificate Revocation Lists(证书吊销列表，简称 CRL)&lt;/strong> 定义在 RFC 5280 中，这是一个相当庞杂的 RFC，还定义了很多其他东西。 简单来是，CRL 是一个&lt;strong>有符号整数序列，用来识别已撤销的证书&lt;/strong>。
这个维护在一个 &lt;strong>CRL distribution point&lt;/strong> 服务中，每个证书中都包含指向这个服务的 URL。 工作流程：每个 RP 下载这个列表并缓存到本地，在对证书进行验证时，从本地缓存查询撤销状态。 但这里也有一些明显的问题：&lt;/p>
&lt;ol>
&lt;li>&lt;strong>CRL 可能很大&lt;/strong>，&lt;/li>
&lt;li>distribution point 也可能失效。&lt;/li>
&lt;li>RP 的 CRL 缓存同步经常是天级的，因此如果一个证书撤销了，可能要几天之后才能同步到这个状态。&lt;/li>
&lt;li>此外，RP &lt;em>fail open&lt;/em> 也很常见 —— CRL distribution point 挂了之后，就接受这个证书。 这显然是一个安全问题：只要对 CRL distribution point 发起 DDoS 攻击，就能让 RP 接受一个已经撤销的证书。&lt;/li>
&lt;/ol>
&lt;p>因此，即使已经在用 CRL，也应该考虑使用短时证书来保持 CRL size 比较小。 CRL 只需要包含&lt;strong>已撤销但还未过期的证书&lt;/strong>的 serial numbers，因此 证书生命周期越短，CRL 越短。&lt;/p>
&lt;h3 id="主动检查机制ocsp">主动检查机制：OCSP&lt;/h3>
&lt;p>主动检查机制除了 CRL 之外，另一个选择是 &lt;strong>Online Certificate Signing Protocol(简称 OCSP)&lt;/strong>，它允许 RP 实时查询一个 &lt;em>OCSP responder&lt;/em>： 指定证书的 serial number 来获取这个证书的撤销状态。
与 CRL distribution point 类似，OCSP responder URL 也包含在证书中。 这样看，OCSP 似乎更加友好，但实际上它也有自己的问题。对于 Web PKI，它引入了验证的隐私问题：&lt;/p>
&lt;ol>
&lt;li>每次查询 OCSP responder，使得它能看到我正在访问哪个网站。&lt;/li>
&lt;li>此外，它还增加了每个 TLS 连接的开销：需要一个额外请求来检查证实的撤销状态。&lt;/li>
&lt;li>与 CRL 一样，很多 RPs (including browsers) 会在 OCSP responder 失效时直接认为证书有效（未撤销）。&lt;/li>
&lt;/ol>
&lt;h3 id="主动检查机制ocsp-stapling合订绑定">主动检查机制：OCSP stapling（合订，绑定）&lt;/h3>
&lt;p>OCSP stapling 是 OCSP 的一个变种，目的是解决以上提到的那些问题。&lt;/p>
&lt;p>相比于让 RP 每次都去查询 OCSP responder，OCSP stapling 中让证书的 subscriber 来做这件事情。 OCSP response 是一个经过签名的、时间较短的证词（signed attestation），证明这个证书未被撤销。&lt;/p>
&lt;p>attestation 包含在 subscriber 和 RP 的 TLS handshake (“stapled to” the certificate) 中。 这给 RP 提供了相对比较及时的撤销状态，而不用每次都去查询 OCSP responder。 subscriber 可以在 signed OCSP response 过期之前多次使用它。这减少了 OCSP 的负担，也解决了 OCSP 的隐私问题。&lt;/p>
&lt;p>但是，所有这些东西其实最终都像是一个 **鲁布·戈德堡装置（Rube Goldberg Device） **，&lt;/p>
&lt;blockquote>
&lt;p>鲁布·戈德堡机械（Rube Goldberg machine）是一种被设计得过度复杂的机械组合，以 迂回曲折的方法去完成一些其实是非常简单的工作，例如倒一杯茶，或打一只蛋等等。 设计者必须计算精确，令机械的每个部件都能够准确发挥功用，因为任何一个环节出错 ，都极有可能令原定的任务不能达成。
解释来自 &lt;a href="https://www.zhihu.com/topic/20017497/intro">知乎&lt;/a>。&lt;/p>
&lt;/blockquote>
&lt;p>如果让 subscribers 去 CA 获取一些生命周期很短的证词（signed attestation）来证明对应的证书并没有过期， 为什么不直接干掉中间环节，直接使用生命周期很短的证书呢？&lt;/p>
&lt;h1 id="证书申请及签署步骤">证书申请及签署步骤&lt;/h1>
&lt;ol>
&lt;li>生成申请请求&lt;/li>
&lt;li>RA 核验你的申请信息&lt;/li>
&lt;li>CA 签署&lt;/li>
&lt;li>获取证书(从证书存取库)&lt;/li>
&lt;/ol>
&lt;p>私有 CA 的创建以及签发证书步骤，详细命令详见 2.0.OpenSSL.note 命令说明&lt;/p>
&lt;ol>
&lt;li>(可选)配置需要使用 CA 功能服务器的 CA 配置文件&lt;/li>
&lt;li>在 CA 功能服务器上创建自签证书以便给其余设备签证&lt;/li>
&lt;li>在需要签证的设备上创建密钥以及证书签署请求，并把请求文件发送给 CA 服务器&lt;/li>
&lt;li>CA 服务器给该请求签证后，把生成的证书文件发还给需要签证的设备。&lt;/li>
&lt;/ol>
&lt;p>吊销证书&lt;/p>
&lt;ol>
&lt;li>获取证书的 serial&lt;/li>
&lt;li>根据用户提交的 serial 与 subject 信息，对比验证是否与 index.txt 文件中的信息一致，使用吊销命令吊销/etc/pki/CA/newcerts/目录下对应的证书文件&lt;/li>
&lt;li>生成吊销证书的编号&lt;/li>
&lt;li>echo 01 &amp;gt; /etc/pki/CA/crl/NUM&lt;/li>
&lt;li>更新证书吊销列表&lt;/li>
&lt;/ol>
&lt;p>证书文件格式：&lt;/p>
&lt;ol>
&lt;li>XXX.pem #证书相关文件标准格式&lt;/li>
&lt;li>XXX.key #明确指明这是一个密钥文件&lt;/li>
&lt;li>XXX.csr #Certificate signing request。证书签署请求文件&lt;/li>
&lt;li>XXX.crt #明确指明这是一个证书文件&lt;/li>
&lt;/ol></description></item><item><title>Docs: 证书 与 PKI</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/7.%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8/cryptography%E5%AF%86%E7%A0%81%E5%AD%A6/%E5%85%AC%E5%BC%80%E5%AF%86%E9%92%A5%E5%8A%A0%E5%AF%86/%E8%AF%81%E4%B9%A6-%E4%B8%8E-pki/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/7.%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8/cryptography%E5%AF%86%E7%A0%81%E5%AD%A6/%E5%85%AC%E5%BC%80%E5%AF%86%E9%92%A5%E5%8A%A0%E5%AF%86/%E8%AF%81%E4%B9%A6-%E4%B8%8E-pki/</guid><description/></item></channel></rss>