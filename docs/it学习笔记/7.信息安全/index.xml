<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>断念梦 – 7.信息安全</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/7.%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8/</link><description>Recent content in 7.信息安全 on 断念梦</description><generator>Hugo -- gohugo.io</generator><atom:link href="https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/7.%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8/index.xml" rel="self" type="application/rss+xml"/><item><title>Docs: Access Control(访问控制)</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/7.%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8/access-control%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/7.%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8/access-control%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://mp.weixin.qq.com/s/vhwA-1UrE_6R7lICCMpG6A">RBAC 的演进历史、设计理念及简洁实现&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;h2 id="译者序">译者序&lt;/h2>
&lt;p>本文翻译自 2021 年的一篇英文博客：RBAC like it was meant to be[1]。&lt;/p>
&lt;p>很多系统（例如 Kubernetes）都在使用某种形式的 RBAC 做权限 / 访问控制。&lt;/p>
&lt;p>本文基于 access control 的发展历史，从设计层面分析了&lt;code>DAC -&amp;gt; MAC -&amp;gt; RBAC -&amp;gt; ABAC&lt;/code>的演进历程及各模型的优缺点、适用场景等， 然后从实际需求出发，一步一步地设计出一个实用、简洁、真正符合 RBAC 理念的访问控制系统。&lt;/p>
&lt;p>&lt;strong>由于译者水平有限，本文不免存在遗漏或错误之处。如有疑问，请查阅原文。&lt;/strong>&lt;/p>
&lt;p>以下是译文。&lt;/p>
&lt;hr>
&lt;p>大部分人都听说过&lt;strong>基于角色的访问控制&lt;/strong>（role-based access control, RBAC）以及它 的后继演进版&lt;strong>基于属性的访问控制&lt;/strong>（attribute-based access control, ABAC）， 但我们经常遗忘或不懂得欣赏其中的伟大思想。&lt;/p>
&lt;p>大部分如今常见的 RBAC 系统都经过了某种程度的简化，因此比最初的设计要弱一些。而本文想要说明，只要回到 RBAC 最初的设计，我们就能构建一个真正的 RBAC/ABAC 安全模型[2]，它比你能见到的那些系统更简单而强大，而且不管网络规模大还是小，它都能适用。&lt;/p>
&lt;p>客户经常跟我们反馈说，他们如何震惊于如下事实：在 Tailscale 平台上，只用如此少的规则就能表达他们的安全策略。这并非偶然！但在解释为什么之前，我们先来回顾一些历史。&lt;/p>
&lt;p>RBAC/ABAC 的概念和术语都源自几十年前的美国军方。[Role-Based Access Controls (Ferraiolo and Kuhn, 1992)](https://www.researchgate.net/publication/24164143_Role-Based_Access_Controls&amp;gt; &amp;ldquo;Role-Based Access Controls (Ferraiolo and Kuhn, 1992&amp;quot;Role-Based Access Controls (Ferraiolo and Kuhn, 1992)&amp;rdquo;)&amp;quot;) 是一篇很好的介绍。下面来看一下它们的一些演进过程。&lt;/p>
&lt;h2 id="11-dac自主访问控制各文件-owner-自主设置文件权限">1.1 DAC（自主访问控制）：各文件 owner 自主设置文件权限&lt;/h2>
&lt;p>最早出现的是 DAC（Discretionary Access Control），直到今天仍然很常见。&lt;/p>
&lt;h3 id="设计">设计&lt;/h3>
&lt;p>如下图所示，在 DAC 中 object owner 有权设置该 object 的访问权限。&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/ef62c7f4-2473-4713-a153-66b5d85aa2f0/640" alt="">&lt;/p>
&lt;p>通过授予 individuals/groups 以 read/write/execute 权限， object (file) 的创建者能完全控制该 object 的内容和权限。&lt;/p>
&lt;p>例如，&lt;/p>
&lt;ol>
&lt;li>在 Unix 系统中，设置 file permission（“模式”，这也是 &lt;code>chmod&lt;/code> change mode 的来历） 就能授予别人 &lt;code>读 / 写 / 执行&lt;/code> 这个文件的权限。&lt;/li>
&lt;li>在 Google Doc 中，点击 share 按钮能授予权限。&lt;/li>
&lt;/ol>
&lt;h3 id="使用场景普通用户的文件权限控制">使用场景：普通用户的文件权限控制&lt;/h3>
&lt;ul>
&lt;li>军方不怎么喜欢 DAC，因为这种方式中，合规性很难保证，机密文件很容易被恶意 reshare 出去。&lt;/li>
&lt;li>但在普通用户场景中，这种方式还是很常用也很合理的。&lt;/li>
&lt;/ul>
&lt;h2 id="12-mac强制访问控制强制由专门的-admin-设置文件权限">1.2 MAC（强制访问控制）：（强制由）专门的 admin 设置文件权限&lt;/h2>
&lt;blockquote>
&lt;p>注意：不要把 MAC (mandatory access control) 与网络术语 &amp;ldquo;MAC address&amp;rdquo; 中的 MAC (media access address) 搞混了，二者没有任何关系，只是碰巧缩写相同。&lt;/p>
&lt;/blockquote>
&lt;h3 id="设计dac-基础上引入专门的-admin-角色">设计：DAC 基础上引入专门的 admin 角色&lt;/h3>
&lt;p>MAC (Mandatory access control) 对 DAC 做了增强。如下图所示， 由 administrator（管理员）或 administrative rule（管理员级别的规则） 来定义 rules。&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/ef62c7f4-2473-4713-a153-66b5d85aa2f0/640" alt="">&lt;/p>
&lt;p>文件 owner 只能设置一个文件 type，这个 type 包含了哪些权限是由 admin 或 policy 设置的。用户能编辑文件内容，但无法修改文件权限。&lt;/p>
&lt;p>因此在 MAC 模型中，一个人做某些事情的 能力是无法再分享给其他人的，从而避免了文件被 reshare 的问题。&lt;/p>
&lt;h3 id="例子tcpudp-端口号">例子：TCP/UDP 端口号&lt;/h3>
&lt;p>MAC 很难解释，因为在实际中很少看到它，甚至看到了之后，你都不觉得它是 “访问控制”。&lt;/p>
&lt;p>Wikipedia 给了一个很好的例子：TCP 或 UDP 端口号。当你占用了一个 local port 之后（假设没设置 SO_REUSEADDR[3]）， 这台机器上的其他任何人就都无法再用这个端口号了 —— 不管他们是什么级别的特权用户。这里，端口范围不可重叠这一条件，就是强制性的（mandatory）。&lt;/p>
&lt;h3 id="适用场景文档--系统访问控制">适用场景：文档 / 系统访问控制&lt;/h3>
&lt;p>之前关于 file locking[4] 的文章中，我讨论了 advisory locks 和 mandatory locks 之间的区别：&lt;/p>
&lt;ul>
&lt;li>advisory lock：其他 apps 可以安全地读这个文件；&lt;/li>
&lt;li>mandatory lock：按照规则，其他不允许 apps 读任何内容。&lt;/li>
&lt;/ul>
&lt;p>可以看出，MAC 适用于对文档或系统的访问控制，这就不难理解为什么 军方对 MAC —— 至少在理论上 —— 如此兴奋了。理想场景：&lt;/p>
&lt;ul>
&lt;li>一个带锁的房间，门口有警卫站岗，&lt;/li>
&lt;li>出示门禁卡能进入这个房间，&lt;/li>
&lt;li>但警卫禁止携带相机进入房间。&lt;/li>
&lt;/ul>
&lt;p>在这种场景下，你自己有权限查看房间内的文档，但无法将其分享给其他人。&lt;/p>
&lt;p>这个例子给我们的一个启示是：数字系统中，MAC 在理论要比在实际中简单（easier in theory than in practice）。&lt;/p>
&lt;ul>
&lt;li>一个功能完整的（full-on）MAC 系统是很难真正实现的。&lt;/li>
&lt;li>Digital restrictions management(DRM，数字限制管理) 是 MAC 的 一种，在这种模型中，文件的接收方无法再将文件分享给别人—— 每个 BitTorrent 用户都能体会到这种方式是如何奏效的。&lt;/li>
&lt;/ul>
&lt;h2 id="13-mac-之双因素登录two-factor-login-as-mac">1.3 MAC 之双因素登录（two-factor login as MAC）&lt;/h2>
&lt;p>大家可能没意识到，另一种 MAC 是 multi-factor authentication (MFA or 2FA):&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/ef62c7f4-2473-4713-a153-66b5d85aa2f0/640" alt="">&lt;/p>
&lt;p>2FA as MAC：密码可以共享，但硬件 token 不能。密码是 DAC，而硬件 token 是 MAC。&lt;/p>
&lt;p>用 MFA 能允许特定的人登录一台计算机或服务，如果这个人不是管理员（admin），那他 自己能登录，但将无法进一步将计算机共享给其他人，将密码告诉他们也不行。&lt;/p>
&lt;p>这种 login 是强制性的（mandatory，单有密码不行，还必须有硬件 token 才能登录）。在这个模型中，假设了第二因素（the second factor，即硬件 token）是不可分享的。&lt;/p>
&lt;h2 id="14-图片分享dacmac-模型比较">1.4 图片分享：DAC/MAC 模型比较&lt;/h2>
&lt;p>另一个例子是分享图片。&lt;/p>
&lt;ul>
&lt;li>在某些服务中，任何有正确 secret URL 的人都能访问给定的图片 / 消息 / 文件，并且任何有这个 URL 的人都能继续分享它，这是 DAC 模式。&lt;/li>
&lt;li>在另一些服务中，单有这个 URL 还不行，必须要登录有权限查看这个文件的账号之后， 才能 reshare：这 MAC 模式。虽然某些人能通过特定的 URL 访问 这个文件，但 reshre 这个 URL 并不能让其他人看到这个文件。&lt;/li>
&lt;/ul>
&lt;blockquote>
&lt;p>当然，如果一个人能下载这个文件，然后发送副本给别人，那结果还是泄露了这个文件 。这也是为什么一些人认为 secret URL 的安全性在数学上与 MAC 是等价的，因为现在 分享 URL 已经和分享文件一样难了。但二者有一个区别：你可以关闭一个 URL 的共享，但无法追回一个已经发送出去的文件副本。&lt;/p>
&lt;/blockquote>
&lt;h2 id="15-mac-概念限制太多又好像没什么限制">1.5 MAC 概念：限制太多，又好像没什么限制&lt;/h2>
&lt;p>历史上，军方中的 MAC 是围绕 multi-level security[5] 构建的，这里的设计思想是：并非只有 admin 和 non-admin 两种用户，实际上有很多层的访问。他们最初将其设想为同心圆（“最高机密许可”、“机密许可” 等等），但最后证明 表达力太弱（too unexpressive）。&lt;/p>
&lt;p>如今的访问控制更像是独立的 flags 或 subgroups。例如， SELinux 提供了对每个进程内的每个权限的细粒度控制，而传统 Unix/Linux 上只有 root 和常规用户权限的区分。但最终证明 SELinux 这套东西是噩梦般的复杂， 难以真正实用 —— 除非你在 NSA（发明 SELinux 的机构）工作，但即使 你在 NSA 也不一定会用。&lt;/p>
&lt;p>最终来说，MAC 的概念证明是过于限制又过于模糊（both too restrictive and too vague）。当人们谈论 MAC 时，我们很难搞清楚他们到底指的是什么，唯一知道是：这东西用起来非常让人抓狂。&lt;/p>
&lt;h2 id="21-rbac基于角色的访问控制">2.1 RBAC（基于角色的访问控制）&lt;/h2>
&lt;p>RBAC 是 MAC 的一个子集，它是一种特殊类型的 MAC，更加具体，因此 在讨论及使用上会更加方便。&lt;/p>
&lt;p>RBAC 与常见的 users/groups 模型类似。在 RBAC 中，&lt;/p>
&lt;ul>
&lt;li>admin 将某些 user 放到一个 group，然后&lt;/li>
&lt;li>可以指定将某些资源（文件、计算机等）共享给某个 group（role）；&lt;/li>
&lt;li>系统确保只有指定的 role 能访问指定的资源；&lt;/li>
&lt;li>文件的接收方没有 reshare 权限 —— 除非拷贝一份，否则是无法 reshare 的。&lt;/li>
&lt;/ul>
&lt;h2 id="22-abac基于属性的访问控制">2.2 ABAC（基于属性的访问控制）&lt;/h2>
&lt;p>Attribute-based access control (Hu, Kuhn, Ferraiolo, 2015)[6] 是对 RBAC 的改进，加了一些细节（属性，Attributes）。&lt;/p>
&lt;ul>
&lt;li>属性可以是位置、客户端设备平台、认证类型、用户的 http cookies 等。&lt;/li>
&lt;li>当系统判断是否授予某个用户对某资源的访问权限时，ABAC 系统除了检查他们的 RBAC role（group），还会检查这个人携带的各种属性。&lt;/li>
&lt;/ul>
&lt;p>如果你遇到过下面这种情况 —— 登录某个服务时弹出额外的图片识别认证 reCAPTCHA[7]， 而你旁边的朋友登录时却不用 —— 就说明你遇到了 ABAC。&lt;/p>
&lt;p>ABAC 很有用，因为这些额外的属性能给我们带来很多有用信息，尤其 是对于那些连接到互联网的、攻击矢量特别多的系统。但在概念上，ABAC 与 RBAC 类似，只是稍微向前演进了一点。属性的解析和认证工作是中心式的，大部分都实现 在各家的 identity provider 中。有鉴于此，接下来我们的讨论重点扔将放在 RBAC。&lt;/p>
&lt;h2 id="23-也许你从未用过真正的-rbac">2.3 也许你从未用过真正的 RBAC&lt;/h2>
&lt;p>RBAC 与前面提到的 users/groups 模型类似。接下来看一个具体的文件系统安全模型，例如 Windows。&lt;/p>
&lt;blockquote>
&lt;p>这里也可以拿 Unix 作为例子，但经典 Unix 文件安全与常见的安全模型不同， 它只支持单个 owner、单个 group，以及 self/group/other 文件模式。如今 Linux 也支持 facls[8]， 这算是 RBAC，但没人知道怎么用，因此这个也不算数。&lt;/p>
&lt;/blockquote>
&lt;h3 id="windows-文件安全模型每个文件一个-acl">Windows 文件安全模型：每个文件一个 ACL&lt;/h3>
&lt;p>在 Windows 中，&lt;/p>
&lt;ol>
&lt;li>每个文件（或目录）都有一个 users 和 groups 列表，以及&lt;/li>
&lt;li>每个列表中的成员可以对这个文件做什么操作。&lt;/li>
&lt;/ol>
&lt;p>这是一种访问控制列表（access control list，ACL）。owner 设置 ACL，操作系 统执行 ACL。这是 MAC，对吧？&lt;/p>
&lt;p>对的 —— 大部分情况下。想一下，任何有文件读权限的人，都可以拷贝一份，然后在副本上 设置权限，因此这是某种形式的 DAC，或者说在执行上充满漏洞的 MAC。但在真实文件上（而非 API 上）执行 MAC 非常难。我们将这个难题留给军方，现在把关注点放在 ACL 语义上。&lt;/p>
&lt;p>在一个 Windows filesystem ACL 中，有如下概念：&lt;/p>
&lt;ol>
&lt;li>User：在这个文件上执行操作的用户。在经典 RBAC 术语中，称为 subject。&lt;/li>
&lt;li>Group 或 Role：由管理员定义的一组 user。&lt;/li>
&lt;li>File：需要做访问控制的资源（resource）。也称为 object。subject 对 object 进行操作。&lt;/li>
&lt;li>Permission 或 Entitlement：一条 &lt;code>subject-action-object&lt;/code>（用户 - 动作 - 目标文件）规则。有时会说某个 subject 有一条 entitlement，或者说某个 object 允许某个 permission，这两种表达方式本质上是一样的，只是从不同的角度描述。&lt;/li>
&lt;li>ACL：一个 entitlements 列表。&lt;/li>
&lt;/ol>
&lt;h3 id="控制谁能访问哪个文件">控制谁能访问哪个文件&lt;/h3>
&lt;p>每个文件都有一个 ACL（permission 列表）。&lt;/p>
&lt;blockquote>
&lt;ul>
&lt;li>每个文件都有一个 ACL。该 ACL 可能从文件所在子目录的 ACL 中继承某些 entry，也 可能不会，这些对我们目前的讨论来说不重要。&lt;/li>
&lt;li>ACL 相同的文件，它们的 ACL 可能在磁盘上是分别存储的，这些是实现细节，我们这里 也不关心。&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>如果想控制谁能访问这些文件，可通过以下任一种方式：&lt;/p>
&lt;ol>
&lt;li>找到 ACL 对应的 groups/roles，在其中添加或删除 user（称为修改 group/role 的 membership）；或者，&lt;/li>
&lt;li>直接修改 ACL，添加或删除 permissions。&lt;/li>
&lt;/ol>
&lt;p>如果想一次修改一组文件的 ACL，可以&lt;/p>
&lt;ol>
&lt;li>修改 group/role membership（简单），或者&lt;/li>
&lt;li>找到所有相关文件，逐个修改对应的 ACL（慢且易出错）。&lt;/li>
&lt;/ol>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/ef62c7f4-2473-4713-a153-66b5d85aa2f0/640" alt="">&lt;/p>
&lt;p>文件多了之后，逐个修改 ACL 就不切实际了。&lt;/p>
&lt;h2 id="24-存在的问题acl-太多到处重复批量修改麻烦">2.4 存在的问题：ACL 太多，到处重复，批量修改麻烦&lt;/h2>
&lt;p>最后一点，也是访问控制开始出现漏洞的地方。&lt;/p>
&lt;ul>
&lt;li>几乎所有系统，不管是不是 RBAC，都支持寻找文件系统中的 objects，然后修改它们的 ACL， 但配套的 object 管理系统可能做的很差。&lt;/li>
&lt;li>在分布式系统中，这些 objects 可能分散在世界各地，放在各种不同的存储系统中，而 它们的共同之处就是都依赖你的 identity 系统。&lt;/li>
&lt;li>如果某天发现一个 permission 给错了，就必须找到这个 permission 的所有副本并解 决之，否则就遗留了一个安全问题。但如果 objects 管理系统做得比较糟糕，这里做起 来就会很麻烦。&lt;/li>
&lt;/ul>
&lt;p>被以上问题折磨多次之后，你可能会尝试一些新东西：&lt;/p>
&lt;ul>
&lt;li>将尽量多的信息从 ACL（分散在各处）中移出，&lt;/li>
&lt;li>将尽量多的东西移入 user groups（集中式存储，而且能审计）。&lt;/li>
&lt;/ul>
&lt;h2 id="31-仍以-windows-文件系统为例">3.1 仍以 Windows 文件系统为例&lt;/h2>
&lt;p>仍然以 Windows 文件系统为例，如下图所示，你可能会创建两个 group &lt;code>report-readers&lt;/code>和 &lt;code>report-writers&lt;/code>：&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/ef62c7f4-2473-4713-a153-66b5d85aa2f0/640" alt="">&lt;/p>
&lt;p>将尽量多的东西从 ACL 中移出，将尽量多的东西移入 groups 中。&lt;/p>
&lt;p>效果是：所有 reports 文件能被 &lt;code>report-readers&lt;/code> 组内的用户读，能被 &lt;code>report-writers&lt;/code>组内的用户写。&lt;/p>
&lt;blockquote>
&lt;p>经验不足的人在这里会犯的一个错误是：只创建一个名为 &lt;code>report&lt;/code> 的 group，然后给 予这个 group read/write 权限。通常来说，需要文件读权限的用户，要比需要 写权限的用户更多。甚至在某些情况下，writer 和 reader 用户之间都没有重叠（例如审计日志场景）。&lt;/p>
&lt;/blockquote>
&lt;p>这种 per-file-type group（每种文件访问类型一个单独的 user group）结构是 Don&amp;rsquo;t Repeat Yourself(DRY) 原则在实际应用中的一个例子：上一节 RBAC/ABAC 模型中，根源问题是每个文件都有自己的 ACL， 这些 ACL 到处重复，因此这里提取出了重复部分放到了一个公共的地方。&lt;/p>
&lt;h2 id="32-存在的问题">3.2 存在的问题&lt;/h2>
&lt;p>这个改进比较合理，尤其是在有很多 objects 的大公司中工作良好，但也有几个问题：&lt;/p>
&lt;ol>
&lt;li>现在需要有某种形式的 IAM admin 访问控制，也就是对用户组的增删查改做控制。
上一节的 RBAC/ABAC 模型中无需这种功能，因为它直接修改文件的 ACL。IAM admin 管控带来的一个新问题是：&lt;/li>
&lt;/ol>
&lt;ul>
&lt;li>如果管控太松，会导致很多人都有 IAM 的访问权限，存在风险；&lt;/li>
&lt;li>如果管控太紧，大部分都无权修改 group membership，又会使得这种模型的好处大打折扣。&lt;/li>
&lt;/ul>
&lt;ol start="3">
&lt;li>End users 仍然能四处游荡，在需要时能修改每个 report 文件的 ACL（“Alice 真的真的需要查看这个文件”），破坏了你精心设计的系统 —— 而你自己都无法察觉。&lt;/li>
&lt;li>现在需要为每个 ACL 组合创建一个 user group。
最后会发现，公司的每个工程师都属于 975 个 group，每个 group 都需要定义 read/write 两种类型。你必须 review 每个 group 的 membership。这种方式虽然比 老的 ad-hoc 文件权限方式审计性要好，但也好不了太多。&lt;/li>
&lt;/ol>
&lt;p>至此，我们决定放弃文件系统的 ACL，原因是：文件系统已经设计成这样了， 基于文件系统的 ACL 我们只能做到目前这样。你大概率无法解决现有的文件系统和操作系统中这些问题。&lt;/p>
&lt;p>但接下来的好消息是：如今的服务都运行在无状态容器内， 大部分 VM 都无需密码就能执行 sudo， 因此我们不用再对文件系统进行控制，而是对 web 应用和 NoSQL 的 API 做控制。这也许不是巧合，因为对细粒度分布式安全（fine-grained distributed security）的需求一直在增长，而文件系统还停留在 1980s 年代。&lt;/p>
&lt;p>那么，接下来就开始设计我们想要的 permission 系统！&lt;/p>
&lt;h2 id="41-根据-user-type-而非-file-type-创建-user-group">4.1 根据 user type 而非 file type 创建 user group&lt;/h2>
&lt;p>首先，注意到，前面两节的文件系统 ACL 方案其实并不是真正意义上基于角色的（role-based）访问控制。为什么呢？它把 user groups 作为 roles —— 这没有问题 —— 但如果你有 975 个像 &lt;code>report-readers&lt;/code> 和 &lt;code>report-writers&lt;/code>一样的 group，那这些就不算不上是真正的 human-relevant roles。HR 并不知道 你的新员工是否应该是 report-reader，这个决策太底层了（low-level）。&lt;/p>
&lt;p>因此我们得到的第一个启示就是：应该根据用户类型（user types）而非文件类型（file types）来创建 user groups。如下图所示：&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/ef62c7f4-2473-4713-a153-66b5d85aa2f0/640" alt="">&lt;/p>
&lt;h2 id="42-roles-去扁平化增强表达力将-acl-定义为一组策略规则">4.2 Roles 去扁平化，增强表达力：将 ACL 定义为一组策略规则&lt;/h2>
&lt;p>以上 group-per-user-type 格式还是过于扁平了（too flat）：它已经丢失了 “为什么某人会在某 group” 的语义含义（semantic meaning）。如果 Bob 离职了，我们必须修改所有可能包含 Bob 的 groups。这虽然已经比跟踪每个 &lt;code>report&lt;/code> 类型的文件 然后 double check 它的 permissions 是否还正确要好，但仍然很容易出错。&lt;/p>
&lt;p>我们假设有如下角色（roles）：Accounting（审计人员）、DevOps（研发运维人员）、Engineering（工程师）、Executive（高管）。&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/ef62c7f4-2473-4713-a153-66b5d85aa2f0/640" alt="">&lt;/p>
&lt;p>然后我们就可以将 ACL 定义为一组策略规则（a set of policy rules）：&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/ef62c7f4-2473-4713-a153-66b5d85aa2f0/640" alt="">&lt;/p>
&lt;p>这种模型与最初的 flat 模型表达的东西是一样的，但通过增加一个间接层（indirection）， 它表达了我们一直想表达（而没有表达出来）的东西。有了这个模型， 接下来就可以讨论：&lt;/p>
&lt;ul>
&lt;li>由 HR 部门定义的 human-relevant roles，以及&lt;/li>
&lt;li>由安全部门定义的标签（tags），以及&lt;/li>
&lt;li>二者是如何联系到一起的。&lt;/li>
&lt;/ul>
&lt;h2 id="43-关于策略规则的进一步解释">4.3 关于策略规则的进一步解释&lt;/h2>
&lt;p>我们正在设计一个新的权限系统。&lt;/p>
&lt;p>现在，先将刚才设计的能转换成的 roles 的 policy rules 进一步表示为：&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/ef62c7f4-2473-4713-a153-66b5d85aa2f0/640" alt="">&lt;/p>
&lt;p>有了这样一种格式的描述之后，当我们需要满足 SOC2 合规性要求时，只需将 &lt;code>database&lt;/code>的 readers 改为，例如 &lt;code>[DevOps, Prod]&lt;/code>，这将会立即锁定所有数据库相关的对象。&lt;/p>
&lt;h2 id="44-其他特性">4.4 其他特性&lt;/h2>
&lt;p>最后，我们来加两个其他特性：&lt;/p>
&lt;p>首先，与文件只有一种 type（读或写）不同，一个对象可以有零或多个 tags。因此，与数据库相关的源文件可以打上 &lt;code>database&lt;/code> 和 &lt;code>sourcefile&lt;/code> 两个 tag，对应地， 它获得的是两种 permission set 的交集。&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/ef62c7f4-2473-4713-a153-66b5d85aa2f0/640" alt="">&lt;/p>
&lt;p>第二，只有 tag 的 owner 有权限增加或删除任何对象上的该 tag。例如在下图中，只有 Engineering 可以在某个对象打 &lt;code>sourcefile&lt;/code> tag。这能够避免意外将对象分享给应该完全隔离的人，或在不期望的地方错误地应用已有策略。&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/ef62c7f4-2473-4713-a153-66b5d85aa2f0/640" alt="">&lt;/p>
&lt;h2 id="45-mac-归来">4.5 MAC 归来&lt;/h2>
&lt;p>至此，我们看到了 MAC 回归的身影。但是，现在它，&lt;/p>
&lt;ol>
&lt;li>不需要一个针对 security policy 的 global admin access control。&lt;/li>
&lt;li>每个 tag owner 能直接对他们的 objects 进行授权，但他们能授予哪些访问权限，是 由整体上的安全策略（the overall security policy，即 roles）控制的。&lt;/li>
&lt;/ol>
&lt;h2 id="46-例子api-访问控制">4.6 例子：API 访问控制&lt;/h2>
&lt;p>在类似 Tailscale 的网络系统中，我们其实并不会用 readers 和 writers 这样的文件系统术语。我们定义 node 和 port，以及允许谁连接到这些 node 和 port。例如可能会如下规则：&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/ef62c7f4-2473-4713-a153-66b5d85aa2f0/640" alt="">&lt;/p>
&lt;p>有了以上规则，&lt;/p>
&lt;ol>
&lt;li>Engineering 中的任何人都可以启动一个&lt;code>dev-api-server&lt;/code> node，&lt;/li>
&lt;li>该 node 能接受从任何 &lt;code>dev-api-client&lt;/code> node 来的非加密连接（TLS 太难了！开发环境就放行非加密连接吧），但反之并不亦然。&lt;/li>
&lt;li>只有 Ops 中的人能启动 &lt;code>prod-api-server&lt;/code> 和 &lt;code>prod-api-client&lt;/code> nodes，它们只处理 https 流量，拒绝非加密 http。&lt;/li>
&lt;/ol>
&lt;p>下面是效果：&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/ef62c7f4-2473-4713-a153-66b5d85aa2f0/640" alt="">&lt;/p>
&lt;p>这里注意：我们递归地用一些 tag names 来定义 permissions for other tags。Ops 中的某个人可以启动一个 node 并打上 &lt;code>prod-api-server&lt;/code> tag， 这个 node 就会获得与 &lt;code>prod-api-server&lt;/code> 而不是 Ops 相关联的 permissions 和 entitlements（ 这很重要，因为&lt;code>prod-api-server&lt;/code> instance 无法像 Ops 一样启动更多 instance）。&lt;/p>
&lt;p>真实的 Tailscale ACLs 和 tags[9] 与此很像，但更加具体。&lt;/p>
&lt;h2 id="51-根据-policy-rules-和-user-groups-自动生成访问权限">5.1 根据 policy rules 和 user groups 自动生成访问权限&lt;/h2>
&lt;p>如果试图将这个模型反向适配到 legacy-style filesystem permissions， 我们就会发现 roles 和 tag definitions 其实是相同类型的对象（都是 lists of users）， 二者之间通过一个（“安全策略”）算法进行单向转换：&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/ef62c7f4-2473-4713-a153-66b5d85aa2f0/640" alt="">&lt;/p>
&lt;p>将 roles 扩展成 tags，然后适配到传统文件系统的权限控制模型。&lt;/p>
&lt;p>你可以类似地写一些脚本，将给定的 roles 和 group membership rules 自动生成你的 /etc/group 内容，我知道有些公司就是这样做的。这不是标准方式，维护很痛苦，而且通常用定时任务来批量执行，这意味着当修改 一个 tag 或 group membership 之后，必须要等上一段时间才能生效。但本质上来说，这 种方式是能工作的，而且比典型的操作系统默认值要好多了。&lt;/p>
&lt;h2 id="52-tags-和-roles-各自的适用场景">5.2 Tags 和 roles 各自的适用场景&lt;/h2>
&lt;p>前面说 tags（用于 ACL 目的）和 roles（用于 user management 目的）都是 “用户列表”（lists of users），其实这种说法有误导性。二者用于不同场景。最重要的是，不同的人负责系统的不同部分：&lt;/p>
&lt;ol>
&lt;li>Roles 描述的是 identity system (authentication) 中的人。Roles 变化很少，通常在入职、晋升或转岗时由 HR 部门设置。&lt;/li>
&lt;li>Object types (tags) 由 object owner 在这个 object 创建时设置。&lt;/li>
&lt;li>Entitlements 用 &lt;code>(Role, Tag)&lt;/code> 描述，由简单的程序（安全策略）来定义，由安全团队设置。&lt;/li>
&lt;/ol>
&lt;p>在这个架构中，这三种类型的人只有很少时候才需要交互：&lt;/p>
&lt;ol>
&lt;li>Accounting 部门中的财报 writer 并不关心谁是 Executive，也不关心 Executive 是否 有权查看或编辑财报。他们只需知道要给 report 文件打上 financial-report tag。&lt;/li>
&lt;li>安全团队并不关心哪个文件打了 &lt;code>financial-report&lt;/code>（讨论一般情况下），也不关心谁是 Executive。他们需要的是&lt;/li>
&lt;/ol>
&lt;ul>
&lt;li>能读、写对应的安全策略，以及确保策略生效：&lt;/li>
&lt;li>确保 financial-report tag 只能被 Accounting 部门打，对应的文件只能被 Executives 和 Accounting 读（read only）。&lt;/li>
&lt;/ul>
&lt;ol start="4">
&lt;li>HR 团队不知道也不关心文件或安全策略，他们只关心这周招了一个 Accounting role 的人。&lt;/li>
&lt;/ol>
&lt;h2 id="53-小结">5.3 小结&lt;/h2>
&lt;p>回到 network permissions 场景：在大公司中，正确地围绕这些概念设计你的模型，就能避免大量摩擦。&lt;/p>
&lt;p>我们在实际工作中可能会遇到如下类似的例子：工程师创建了一个新的开发（&lt;code>dev&lt;/code>）集群后，还要去提个工单，让安全团队给他开防火墙端口。为什么会这样？因为在这些公司中，安全团队维护的策略并不规范，没有收敛到以上模型：&lt;/p>
&lt;ol>
&lt;li>允许 Engineers 运行 dev API servers，接受来自本机或 dev API clients 的 incoming 连接 —— 这个没问题；&lt;/li>
&lt;li>通常不允许创建 outgoing connections —— 这个也没问题；&lt;/li>
&lt;li>噢对了，Carol 的 dev API server 需要主动访问数据库服务器，只能开单独策略了 —— 问题来了。&lt;/li>
&lt;/ol>
&lt;p>如果安全团队能将这些安全规则固化成代码片段，结果将会更好，能确保它们在整张 网络上得到一致执行。&lt;/p>
&lt;p>以上提到的所有东西，users、roles、object types、policies 都不是新概念， 它们都来自 1992 提出 RBAC 模型的那篇论文，只是术语稍有不同。&lt;/p>
&lt;p>如今，几乎每个人都在使用 users、groups、ACLs 了。一些人认为，我们实现的东西已经 是 RBAC，但事实告诉我们：并不是。还没有谁实现过完整的 RBAC 模型：&lt;/p>
&lt;ol>
&lt;li>每个人都是一个 User (subject)。&lt;/li>
&lt;li>每个 user 都有一个或多个 Roles。&lt;/li>
&lt;li>每个 object 都有一个或多个 Tags。&lt;/li>
&lt;li>一条 &amp;ldquo;security policy&amp;rdquo; 定义一个将 &lt;code>(Role, Tag)&lt;/code> 转换成 Entitlements 的公式。&lt;/li>
&lt;li>一个执行层（enforcement layer）负责 enforce security policy，并为每个 object 生成有效 entitlements 列表（ACL）。&lt;/li>
&lt;/ol>
&lt;p>但另一方面，实现这样一个模型比实现常见的 users+groups 模型并没有复杂多少—— 只要从一开始就将其放到系统的核心。&lt;/p>
&lt;p>最后回到文初，这就是为什么 Tailscale RBAC、ABAC 和 security policy 不同寻常的地方[10]。Tailscale objects 都是设备和端口（devices and ports），而非文件，但所有概念在使用上与在文件系统中是一样的。最终的产品在理念设计上很简洁：&lt;/p>
&lt;ol>
&lt;li>Device 或 container 的 owner 可以设置 tag；&lt;/li>
&lt;li>安全团队决定谁 own 哪些 tag、每个 tag 关联了哪些 permissions、tags 会授权给哪些 roles；&lt;/li>
&lt;li>Identity/HR 团队决定哪些 users 应该属于哪些 roles。&lt;/li>
&lt;/ol>
&lt;h3 id="引用链接">引用链接&lt;/h3>
&lt;p>[1]&lt;/p>
&lt;p>RBAC like it was meant to be: &lt;a href="https://tailscale.com/blog/rbac-like-it-was-meant-to-be/">&lt;em>https://tailscale.com/blog/rbac-like-it-was-meant-to-be/&lt;/em>&lt;/a>&lt;/p>
&lt;p>[2]&lt;/p>
&lt;p>真正的 RBAC/ABAC 安全模型: &lt;a href="https://tailscale.com/kb/1018/acls/">&lt;em>https://tailscale.com/kb/1018/acls/&lt;/em>&lt;/a>&lt;/p>
&lt;p>[3]&lt;/p>
&lt;p>SO*REUSEADDR: &lt;a href="https://man7.org/linux/man-pages/man7/socket.7.html">_https://man7.org/linux/man-pages/man7/socket.7.html*&lt;/a>&lt;/p>
&lt;p>[4]&lt;/p>
&lt;p>之前关于 file locking: &lt;a href="https://apenwarr.ca/log/20101213">&lt;em>https://apenwarr.ca/log/20101213&lt;/em>&lt;/a>&lt;/p>
&lt;p>[5]&lt;/p>
&lt;p>multi-level security: &lt;a href="https://en.wikipedia.org/wiki/Multilevel_security">&lt;em>https://en.wikipedia.org/wiki/Multilevel_security&lt;/em>&lt;/a>&lt;/p>
&lt;p>[6]&lt;/p>
&lt;p>Attribute-based access control (Hu, Kuhn, Ferraiolo, 2015): &lt;a href="https://www.researchgate.net/publication/273393378_Attribute-Based_Access_Control">&lt;em>https://www.researchgate.net/publication/273393378_Attribute-Based_Access_Control&lt;/em>&lt;/a>&lt;/p>
&lt;p>[7]&lt;/p>
&lt;p>reCAPTCHA: &lt;a href="https://www.google.com/recaptcha/about/">&lt;em>https://www.google.com/recaptcha/about/&lt;/em>&lt;/a>&lt;/p>
&lt;p>[8]&lt;/p>
&lt;p>facls: &lt;a href="https://www.usenix.org/legacy/publications/library/proceedings/usenix03/tech/freenix03/full_papers/gruenbacher/gruenbacher_html/main.html">&lt;em>https://www.usenix.org/legacy/publications/library/proceedings/usenix03/tech/freenix03/full_papers/gruenbacher/gruenbacher_html/main.html&lt;/em>&lt;/a>&lt;/p>
&lt;p>[9]&lt;/p>
&lt;p>真实的 Tailscale ACLs 和 tags: &lt;a href="https://tailscale.com/kb/1018/acls/">&lt;em>https://tailscale.com/kb/1018/acls/&lt;/em>&lt;/a>&lt;/p>
&lt;p>[10]&lt;/p>
&lt;p>Tailscale RBAC、ABAC 和 security policy 不同寻常的地方: &lt;a href="https://tailscale.com/kb/1018/acls/">&lt;em>https://tailscale.com/kb/1018/acls/&lt;/em>&lt;/a>&lt;/p></description></item><item><title>Docs: Access Control(访问控制)</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/7.%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8/access-control%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/7.%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8/access-control%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6/</guid><description/></item><item><title>Docs: Bastion Host(堡垒机)</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/7.%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8/bastion-host%E5%A0%A1%E5%9E%92%E6%9C%BA/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/7.%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8/bastion-host%E5%A0%A1%E5%9E%92%E6%9C%BA/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Bastion_host">Wiki,Bastion host&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote></description></item><item><title>Docs: Cryptography(密码学)</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/7.%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8/cryptography%E5%AF%86%E7%A0%81%E5%AD%A6/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/7.%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8/cryptography%E5%AF%86%E7%A0%81%E5%AD%A6/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Cryptography">Wiki,Cryptography&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;h1 id="密码学背景">密码学背景&lt;/h1>
&lt;p>在现代时代之前，密码学着眼于消息的机密性（即加密），即将消息从一种可理解的形式转换为一种难以理解的形式，然后又在另一端再次转换，从而使拦截器或窃听者在没有秘密知识（即所需的密钥）的情况下无法读取该消息。用于解密该消息）。加密试图确保保密的通信，如那些间谍，军事领导人和外交官。在最近的几十年中，该领域已经超出了对机密性的关注范围，包括消息完整性检查，发送者/接收者身份验证，数字签名，交互式证明和安全计算等。&lt;/p>
&lt;h2 id="经典密码学">经典密码学&lt;/h2>
&lt;h2 id="现代密码学">现代密码学&lt;/h2>
&lt;p>现在我们谈论的密码学，都是现代密码学的范畴&lt;/p>
&lt;p>Public-key cryptography(公开密钥加密、非对称密钥加密)，以及根据公开密钥加密方式而衍生出的其他认证授权等基础设施，是当代最常见，也是最常用的方式.&lt;/p>
&lt;h1 id="现代加密方式">现代加密方式&lt;/h1>
&lt;h2 id="symmetric-key-algorithm对称密钥算法">Symmetric Key Algorithm(对称密钥算法)&lt;/h2>
&lt;blockquote>
&lt;p>参考： &lt;a href="https://en.wikipedia.org/wiki/Symmetric-key_algorithm">Wiki-Symmetir Key Algorithm&lt;/a>&lt;/p>
&lt;/blockquote>
&lt;p>使用相同的密钥来加密明文和解密密文&lt;/p>
&lt;p>算法：&lt;/p>
&lt;ol>
&lt;li>DES：Data Encryption Standard 数据加密标准。已被破解&lt;/li>
&lt;li>3DES：3 倍的 DES。最常用&lt;/li>
&lt;li>AES：Advanced Encryption Standard 高级加密标准。最常用&lt;/li>
&lt;li>Blowfish&lt;/li>
&lt;li>Twofish&lt;/li>
&lt;li>IDEA：商业加密算法&lt;/li>
&lt;/ol>
&lt;h3 id="ska-特点">SKA 特点&lt;/h3>
&lt;p>特性：&lt;/p>
&lt;ul>
&lt;li>加密和解密使用同一个密钥，效率高。&lt;/li>
&lt;li>将原始数据分割成固定大小的块，逐个进行加密；&lt;/li>
&lt;/ul>
&lt;p>缺点：&lt;/p>
&lt;ul>
&lt;li>密钥过多；&lt;/li>
&lt;li>密钥分发(分发密钥过程无法保证),为了解决对称加密算法每个人需要保存密钥过多的问题，可以使用公钥加密&lt;/li>
&lt;li>数据来源无法确认&lt;/li>
&lt;/ul>
&lt;h2 id="public-key-cryptography公开密钥密码学">Public Key Cryptography(公开密钥密码学)&lt;/h2>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Public-key_cryptography">Wiki,PKC 英文&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Digital_signature">Wiki,数字签名&lt;/a>&lt;/li>
&lt;li>&lt;a href="http://www.ruanyifeng.com/blog/2013/06/rsa_algorithm_part_one.html">阮一峰&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.zhihu.com/question/25912483">知乎,RSA 的公钥和私钥到底那个才是用来加密和哪个用来解密&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://zh.wikipedia.org/wiki/%E5%85%AC%E5%BC%80%E5%AF%86%E9%92%A5%E5%8A%A0%E5%AF%86">Wiki, 公开密钥加密 中文&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>**Public Key Cryptography(公开密钥密码学) &lt;strong>也称为&lt;/strong> Asymmetric Key Algorithm(非对称密钥算法)，**它是计算机通信安全的基石，保证了加密数据不会被破解。1976 年以前，所有的加密方法都是同一种模式：&lt;/p>
&lt;ul>
&lt;li>甲方选择某种加密规则，对信息进行加密&lt;/li>
&lt;li>乙方使用同一种规则，对信息进行解密&lt;/li>
&lt;/ul>
&lt;p>由于加密和解密使用同样规则（简称&amp;quot;密钥&amp;quot;），这被称为 Symmetric-key algorithm(对称密钥算法)。这种加密模式有一个最大弱点：甲方必须把加密规则告诉乙方，否则无法解密。保存和传递密钥，就成了最头疼的问题。因为大多数情况下，其实两方之间的通信，只有一方是需要加密的，另一方只需要知道信息内容。&lt;/p>
&lt;p>1976 年，两位美国计算机学家 Whitfield Diffie 和 Martin Hellman，提出了一种崭新构思，可以在不直接传递密钥的情况下，完成解密。这被称为&amp;quot;Diffie-Hellman 密钥交换算法&amp;quot;。这个算法启发了其他科学家。人们认识到，加密和解密可以使用不同的规则，只要这两种规则之间存在某种对应关系即可，这样就避免了直接传递密钥。&lt;/p>
&lt;p>这种新的加密模式就被称为&amp;quot;非对称密钥算法&amp;quot;。&lt;/p>
&lt;blockquote>
&lt;p>（1）乙方生成两把密钥（公钥和私钥）。公钥是公开的，任何人都可以获得，私钥则是保密的。
（2）甲方获取乙方的公钥，然后用它对信息加密。
（3）乙方得到加密后的信息，用私钥解密。&lt;/p>
&lt;/blockquote>
&lt;p>如果公钥加密的信息只有私钥解得开，那么只要私钥不泄漏，通信就是安全的。&lt;/p>
&lt;p>1977 年，三位数学家 Rivest、Shamir 和 Adleman 设计了一种算法，可以实现非对称加密。这种算法用他们三个人的名字命名，叫做 RSA 算法。从那时直到现在，RSA 算法一直是最广为使用的&amp;quot;非对称加密算法&amp;quot;。毫不夸张地说，只要有计算机网络的地方，就有 RSA 算法。&lt;/p>
&lt;p>这种算法非常可靠，密钥越长，它就越难破解。根据已经披露的文献，目前被破解的最长 RSA 密钥是 768 个二进制位。也就是说，长度超过 768 位的密钥，还无法破解（至少没人公开宣布）。因此可以认为，1024 位的 RSA 密钥基本安全，2048 位的密钥极其安全。&lt;/p>
&lt;h3 id="pkc-特点">PKC 特点&lt;/h3>
&lt;ul>
&lt;li>这种加密方式，需要一对密钥。只有公钥可以加密，私钥不能用来加密数据。&lt;/li>
&lt;li>&lt;strong>Public key(公钥)&lt;/strong> # 公开给所有人。用来加密数据、验证签名。使用公钥把明文加密后所得的密文，只能使用对应的私钥才能解密并得到原本的密文。反之不行。&lt;/li>
&lt;li>&lt;strong>Secret key(私钥)&lt;/strong> # 自己留存，必须保证其私密性。用来解密数据、签名。使用私钥创建数字签名，只能使用公钥才能验证该数字签名的有效性。反之不行。
&lt;ul>
&lt;li>一般情况，密钥对是通过程序自动生成的。首先生成私钥后，公钥包含在私钥当中&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>Digital signature(数字签名)&lt;/strong>。签名提供的是真实性，而不是保密性。
&lt;ul>
&lt;li>所谓的数字签名，就像人们日常生活中在文件上签字一样，都是签名的一种。&lt;/li>
&lt;li>而所谓的验证签名，其实就像日常生活中，看看签名的人的笔记与签名是否一致，等等类似的行为&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>总结一下：既然是加密，那肯定是不希望别人知道发送给我的消息，所以只有我才能解密，所以可得出&lt;strong>公钥负责加密，私钥负责解密&lt;/strong>；同理，既然是签名，那肯定是不希望有人冒充我发消息，只有我才能发布这个签名，所以可得出&lt;strong>私钥负责签名，公钥负责验证&lt;/strong>。&lt;/p>
&lt;ul>
&lt;li>这种加密方式由于是单向加密、单向解密，所以如果双方都想要加密，则需要两对密钥，双方各自用对方的公钥加密信息发送给对方，然后双方再用自己的私钥解密阅读信息。&lt;/li>
&lt;/ul>
&lt;h3 id="应用场景">应用场景&lt;/h3>
&lt;ul>
&lt;li>如果 A 持有私钥，B 持有对应公钥。那么此时 B 用对方的公钥加密一个对称密钥并发送给 A，A 使用私钥解密，以获得 B 发送的对称密钥，这时再发送的数据可以使用对称加密。&lt;/li>
&lt;li>在互联网的 C/S 架构场景中。Server 公开公钥，Client 使用公钥加密信息发送给 Server(发送密码等敏感信息)，Server 使用私钥解密后响应时，使用私钥签名，以便 Client 可以用公钥验证 Server 的真实性(防止钓鱼网站)。&lt;/li>
&lt;li>如图所示，Alice 在一条消息的末尾签了名，消息内容是 &lt;code>Hello Bob!&lt;/code>，这段签署的内容一般是对消息内容进行 hash 计算后，使用 Alice 的私钥的出来的。鲍勃同时收到消息和签名。他使用 Alice 的公钥来验证消息的真实性，即，如果使用公钥计算得出来的消息与原始消息完全匹配，那就证明，这条消息确实是 Alice 发送的。&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/as985c/1616125981836-028fe2ce-77f2-4929-91cc-559c4ce9cda1.png" alt="">&lt;/p>
&lt;p>算法：&lt;/p>
&lt;ol>
&lt;li>RSA&lt;/li>
&lt;li>DSA&lt;/li>
&lt;li>ELGamal&lt;/li>
&lt;/ol>
&lt;p>缺点&lt;/p>
&lt;ol>
&lt;li>公钥加密可能出现的问题：当两者需要通信的时候，需要把公钥发送给对方，但是公钥是谁都可以获取的，那么在二者通信过程中，公钥就有可能被劫持，当公钥被劫持，劫持者把自己的公钥再发送给对方，那么双发再收到的信息，就是被劫持者篡改过的信息了。
&lt;ol>
&lt;li>&lt;a href="https://www.yuque.com/go/doc/33177961">&lt;strong>Public Key Certificate(公钥证书)&lt;/strong>&lt;/a> 可以解决以上问题&lt;/li>
&lt;/ol>
&lt;/li>
&lt;/ol>
&lt;h2 id="cryptographic-hash-function单向加密加密散列函数">Cryptographic hash function(单向加密、加密散列函数)&lt;/h2>
&lt;p>只能加密，不能解密，提取数据特征码，用来保证数据的完成性，实现数据的完整性校验&lt;/p>
&lt;p>通常用来做数字证书的数字签名，提取数据的特征码后进行加密并放到数据后端，用来校验证书的完整性，所以证书的内容是被认可的&lt;/p>
&lt;p>特点：定长输出、雪崩效应(原始数据的微小改变会导致计算结果的完全不同)&lt;/p>
&lt;p>算法：&lt;/p>
&lt;ol>
&lt;li>md5&lt;/li>
&lt;li>sha1&lt;/li>
&lt;li>sha256&lt;/li>
&lt;li>sha384&lt;/li>
&lt;li>sha512&amp;hellip;.等&lt;/li>
&lt;/ol>
&lt;p>MAC:Message Authentication Code(消息认证码)，单向加密的一种延伸应用，用于实现在网络通信中保证所传输的数据的完整性&lt;/p></description></item><item><title>Docs: Cryptography(密码学)</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/7.%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8/cryptography%E5%AF%86%E7%A0%81%E5%AD%A6/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/7.%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8/cryptography%E5%AF%86%E7%A0%81%E5%AD%A6/</guid><description/></item><item><title>Docs: Hacking</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/7.%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8/hacking/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/7.%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8/hacking/</guid><description>
&lt;h1 id="名词解释">名词解释&lt;/h1>
&lt;p>补充一个小知识点，软件漏洞在英文里不是 Hole——孔洞，而是 &lt;strong>Vulnerability(脆弱性)&lt;/strong>，因为软件里的漏洞往往不会是一个明晃晃的“洞”，而是一个不起眼的“脆弱性”。&lt;/p>
&lt;p>&lt;strong>Robo Hacking Game(机器人网络安全大赛，简称 RHG)&lt;/strong> 是中国版的 CGC 大赛。&lt;/p>
&lt;p>&lt;strong>Cyber Grand Challenge(网络空间超级挑战赛，简称 CGC)&lt;/strong> 是 **Defense Advanced Research Projects Agency(国防高级研究计划局，简称 DARPA) **举办的比赛。&lt;/p>
&lt;h2 id="安全公司">安全公司&lt;/h2>
&lt;p>深信服
360
永信至诚&lt;/p></description></item><item><title>Docs: Standardized Glossary(标准化术语)</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/7.%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8/standardized-glossary%E6%A0%87%E5%87%86%E5%8C%96%E6%9C%AF%E8%AF%AD/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/7.%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8/standardized-glossary%E6%A0%87%E5%87%86%E5%8C%96%E6%9C%AF%E8%AF%AD/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://datatracker.ietf.org/doc/html/rfc4949">RFC 4949(互联网安全术语)&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>**Entity(实体) **# 是任何存在的东西（anything that exists） —— 即使 只在逻辑或概念上存在（even if only exists logically or conceptually）。 例如，&lt;/p>
&lt;ul>
&lt;li>你的计算机是一个 entity，&lt;/li>
&lt;li>你写的代码也是一个 entity，&lt;/li>
&lt;li>你自己也是一个 entity，&lt;/li>
&lt;li>你吃的杂粮饼也是一个 entity，&lt;/li>
&lt;li>你六岁时见过的幽灵也是一个 entity —— 即使你妈告诉你幽灵并不存在，这只是你的臆想。&lt;/li>
&lt;li>所以
&lt;ul>
&lt;li>CA 也算一个实体&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>Identity(身份)&lt;/strong> # 每个 entity（实体）都有一个 identity（身份）。 要精确定义这个概念比较困难，这么来说吧：identity 是使你之所以为你 （what makes you you）的东西。&lt;/p>
&lt;ul>
&lt;li>具体到计算机领域，identity 通常用一系列属性来表示，描述某个具体的 entity， 这里的属性包括 group、age、location、favorite color、shoe size 等等。&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>Identifier(身份标识符)&lt;/strong> # Identifier 跟 identity 还不是一个东西：每个 identifier 都是一个唯一标识符， 也唯一地关联到某个有 identity 的 entity。&lt;/p>
&lt;ul>
&lt;li>例如，我是 Mike，但 Mike 并不是我的 identity，而只是个 name —— 虽然二者在我们 小范围的讨论中是同义的。&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>Claim(声明) &amp;amp; Authentication(认证)&lt;/strong> #&lt;/p>
&lt;ul>
&lt;li>一个 entity 能 claim（声明）说，它拥有某个或某些 name。&lt;/li>
&lt;li>其他 entity 能够对这个 claim 进行认证（authenticate），以确认这份声明的真假。一般来说，认证的目的是确认某些 claim 的合法性。&lt;/li>
&lt;li>Claim 不是只能关联到 name，还可以关联到别的东西。例如，我能 claim 任何东西： my age, your age, access rights, the meaning of life 等等。&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>Subscriber &amp;amp; CA &amp;amp; relying party (RP)&lt;/strong> #&lt;/p>
&lt;ul>
&lt;li>能作为一个证书的 subject 的 entity，称为 subscriber（证书 owner）或 end entity。对应地，subscriber 的证书有时也称为 end entity certificates 或 leaf certificates， 原因在后面讨论 certificate chains 时会介绍。&lt;/li>
&lt;li>CA（certificate authority，证书权威）是给 subscriber 颁发证书的 entity，是一种 certificate issuer（证书颁发者）。CA 的证书，通常称为 root certificate 或 intermediate certificate，具体取决于 CA 类型。&lt;/li>
&lt;li>Relying party 是 使用证书的用户（certificate user），它验证由 CA 颁发（给 subscriber）的证书是否合法。一个 entity 可以同时是一个 subscriber 和一个 relying party。 也就是说，单个 entity 既有自己的证书，又使用其他证书来认证 remote peers， 例如双向 TLS（mutual TLS，mTLS）场景。&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>key(密钥)&lt;/strong> # 在密码学中，是指某个用来完成加密、解密、完整性验证等密码学应用的秘密信息。对于加密算法，key 指定明文转换成密文；对于解密算法，key 指定密文转换成明文&lt;/p>
&lt;ul>
&lt;li>&lt;strong>Plaintext/Cleartext(明文)&lt;/strong> # 在密码学中，明文是未加密的信息，可以供人类和计算机读取的信息&lt;/li>
&lt;li>**Ciphertext/Cyphertext(密文) **# 在密码学中，密文是明文通过加密算法计算后生成的人类或计算器无法读取的一种信息&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>Key Generation(密钥生成)&lt;/strong> # &lt;a href="https://en.wikipedia.org/wiki/Key_generation">详见 Wiki&lt;/a>。密钥一般都是各种程序根据指定算法生成的。&lt;/p>
&lt;p>&lt;strong>Password(密码)&lt;/strong> 与 &lt;strong>Key(密钥) 的区别&lt;/strong> # 详见 &lt;a href="https://en.wikipedia.org/wiki/Key_(cryptography)">Wiki Key，Key vs Password&lt;/a>。&lt;/p>
&lt;ul>
&lt;li>对于大多数计算机安全目的和大多数用户而言，“密钥”与“密码”（或“密码短语”）并不相同，尽管实际上可以将密码用作密钥。密钥和密码之间的主要实际区别在于，密码和密码旨在由人类用户生成，读取，记住和再现（尽管用户可以将这些任务委托给密码管理软件）。相反，密钥旨在由实现密码算法的软件使用，因此不需要人类可读性等。实际上，大多数用户在大多数情况下甚至都不知道其日常软件应用程序的安全组件正在使用代表他们的密钥。&lt;/li>
&lt;li>如果 &lt;a href="https://en.wikipedia.org/wiki/Password">密码&lt;/a> 被用作加密密钥，然后在精心设计的密码系统就不会这样使用它自己。这是因为密码往往是人类可读的，因此可能不是特别强。作为补偿，一个好的加密系统将不使用_密码作为密钥_来执行主要的加密任务本身，而是充当&lt;a href="https://en.wikipedia.org/wiki/Key_derivation_function">密钥派生功能&lt;/a>（KDF）的输入。该 KDF 使用密码作为起点，然后它将从该起点本身生成实际的安全加密密钥。世代可以使用各种方法，例如添加盐和拉伸键。&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>Encoding(编码)&lt;/strong> # 将数据的原始格式，转换为便于存储的格式&lt;/p>
&lt;p>**Decoding(解码) **# 将存储的数据转换为原始格式以便使用&lt;/p>
&lt;p>&lt;strong>Encrypt(加密)&lt;/strong> # 使用 Key(密钥) 对信息进行编码的过程。&lt;/p>
&lt;p>&lt;strong>Decrypt(解密)&lt;/strong> # 使用 Key(密钥) 对信息进行解码的过程&lt;/p>
&lt;p>**Encoding(编码) 与 Encrypt(加密) 的区别 **#&lt;/p>
&lt;ul>
&lt;li>编码使用公开的方案，将数据转换为另一种格式，便于维护数据与传播。任何人都可以使用相同的编码规范，解码数据&lt;/li>
&lt;li>加密使用私密的方法，将数据抓换为另一种格式，着重于数据的保密。只有拥有相同 Key 的人才可以使用相同的加密规范，解密数据&lt;/li>
&lt;li>总结：编码和加密都是对格式的一种转换，但是它们是有区别的。&lt;strong>编码是公开的&lt;/strong>，比如 Base 64 编码，任何人都可以解码；&lt;strong>而加密则相反，你只希望自己或者特定的人才可以对内容进行解密。&lt;/strong>&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>Signature(签名)&lt;/strong> # 非对称加密中，使用私钥进行数字签名的行为。&lt;/p>
&lt;p>&lt;strong>Verifying(验证)&lt;/strong> # 非对称加密中，使用公钥验证数字签名的行为。&lt;/p>
&lt;p>&lt;strong>Digital Signature(数字签名)&lt;/strong> # &lt;a href="https://en.wikipedia.org/wiki/Digital_signature">详见 Wiki&lt;/a>**。**用于检验数字消息或文件的真实性的数学方案&lt;/p>
&lt;p>**Public Key Cryptography Standards(非对称密钥加密标准，简称 PKCS) **# &lt;a href="https://en.wikipedia.org/wiki/PKCS">详见 Wiki&lt;/a>。该标准指定了使用公开密钥加密技术时所应该遵守的标准&lt;/p>
&lt;p>&lt;strong>Public Key Infrastructure(非对称密钥基础设施，简称 PKI)&lt;/strong> # &lt;a href="https://en.wikipedia.org/wiki/Public_key_infrastructure">详见 Wiki&lt;/a>。一个包括硬件、软件、人员、策略和规程的集合，用来实现基于公钥密码体制的密钥和证书的产生、管理、存储、分发和撤销等功能。&lt;/p>
&lt;p>&lt;strong>Secure Hash Algorithm(安全哈希算法，简称 SHA)&lt;/strong> # &lt;/p></description></item><item><title>Docs: 管理工具</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/7.%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8/%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/7.%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8/%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/</guid><description>
&lt;h1 id="acme">ACME&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://datatracker.ietf.org/doc/html/rfc8555">RFC,8555&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Automatic_Certificate_Management_Environment">Wiki,ACME&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>&lt;strong>Automatic Certificate Management Environment(自动证书管理环境，简称 ACME)&lt;/strong> 是一种通信协议，用于自动化证书颁发机构与其用户的 Web 服务器之间的交互，允许以非常低的成本自动部署 PKI。它是油 ISRG 为他们的 Let&amp;rsquo;s Encrypt 服务设计的。&lt;/p>
&lt;h2 id="acme-服务提供商">ACME 服务提供商&lt;/h2>
&lt;p>支持免费或低成本基于 ACME 的证书服务的提供商包括 &lt;a href="https://en.wikipedia.org/wiki/Let%27s_Encrypt">Let&amp;rsquo;s Encrypt&lt;/a>、&lt;a href="https://en.wikipedia.org/wiki/Buypass">Buypass&lt;/a> Go SSL、ZeroSSL 和 SSL.com。许多其他证书颁发机构和软件供应商提供 ACME 服务，作为 &lt;a href="https://en.wikipedia.org/wiki/Entrust">Entrust&lt;/a> 和 &lt;a href="https://en.wikipedia.org/wiki/DigiCert">DigiCert&lt;/a> 等付费 PKI 解决方案的一部分。&lt;/p>
&lt;h2 id="acme-的实现">ACME 的实现&lt;/h2>
&lt;p>想要实现自动签证书，要经过如下几个步骤&lt;/p>
&lt;ul>
&lt;li>验证要签名证书所使用的域名是属于我的。这个验证过程又有多种途径
&lt;ul>
&lt;li>&lt;strong>DNS 验证&lt;/strong> # 通过提供域名注册商的认证信息(比如 ak、sk)，ACME 程序将会从域名注册商处验证域名属于我的&lt;/li>
&lt;li>**Web 验证 **# 通过域名访问 Web 服务。由于自己可以配置域名解析，所以只要域名可以解析到运行 ACME 程序的设备上，那么 ACME 程序就认为这个域名是属于我的。
&lt;ul>
&lt;li>这种方式有个弊端：首先要保证自己的域名可以解析到运行 ACME 程序的设备上；然后还要保证 ACME 程序可以通过域名访问到自己。这在国内没有备案的域名是不方便的&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h1 id="lets-encrypt">Let&amp;rsquo;s Encrypt&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://letsencrypt.org/">官网&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Let%27s_Encrypt">Wiki,Let&amp;rsquo;s Encrypt&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://github.com/certbot/certbot">GitHub 项目，certbot/certbot&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;h2 id="使用-certbot-创建证书">使用 certbot 创建证书&lt;/h2>
&lt;p>Let&amp;rsquo;s Encrypt 使用 certbot 工具为我们签署证书&lt;/p>
&lt;blockquote>
&lt;p>注意：保证执行 certbot 的服务器的 80 端口是可以被公网访问的，且保证签署证书时提供的域名是可以解析的(即已备案或无需备案)&lt;/p>
&lt;/blockquote>
&lt;p>证书申请成功后将会出现如下提示：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>~&lt;span style="color:#f92672">]&lt;/span>&lt;span style="color:#75715e"># certbot certonly --standalone&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Saving debug log to /var/log/letsencrypt/letsencrypt.log
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Plugins selected: Authenticator standalone, Installer None
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Please enter in your domain name&lt;span style="color:#f92672">(&lt;/span>s&lt;span style="color:#f92672">)&lt;/span> &lt;span style="color:#f92672">(&lt;/span>comma and/or space separated&lt;span style="color:#f92672">)&lt;/span> &lt;span style="color:#f92672">(&lt;/span>Enter &lt;span style="color:#e6db74">&amp;#39;c&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>to cancel&lt;span style="color:#f92672">)&lt;/span>: 这里输入自己的&lt;span style="color:#e6db74">${&lt;/span>域名&lt;span style="color:#e6db74">}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Obtaining a new certificate
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Performing the following challenges:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>http-01 challenge &lt;span style="color:#66d9ef">for&lt;/span> &lt;span style="color:#e6db74">${&lt;/span>域名&lt;span style="color:#e6db74">}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Waiting &lt;span style="color:#66d9ef">for&lt;/span> verification...
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Cleaning up challenges
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>IMPORTANT NOTES:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - Congratulations! Your certificate and chain have been saved at:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> /etc/letsencrypt/live/&lt;span style="color:#e6db74">${&lt;/span>域名&lt;span style="color:#e6db74">}&lt;/span>/fullchain.pem
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Your key file has been saved at:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> /etc/letsencrypt/live/&lt;span style="color:#e6db74">${&lt;/span>域名&lt;span style="color:#e6db74">}&lt;/span>/privkey.pem
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Your cert will expire on 2022-09-05. To obtain a new or tweaked
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> version of this certificate in the future, simply run certbot
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> again. To non-interactively renew *all* of your certificates, run
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#34;certbot renew&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - If you like Certbot, please consider supporting our work by:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Donating to ISRG / Let&lt;span style="color:#960050;background-color:#1e0010">&amp;#39;&lt;/span>s Encrypt: https://letsencrypt.org/donate
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Donating to EFF: https://eff.org/donate-le
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>根据提示，在 &lt;code>/etc/letsencrypt/live/${DNS}/&lt;/code> 目录下，可以找到已经签署的证书及私钥&lt;/p>
&lt;h1 id="zerosll">ZeroSLL&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://zerossl.com/">官网&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://github.com/zerossl/">GitHub 组织，ZeroSSL&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://github.com/acmesh-official/acme.sh">GitHub 项目，acemsh-official/acme.sh&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>使用 acem.sh 通过阿里云创建证书：&lt;a href="https://f-e-d.club/topic/use-acme-sh-deployment-let-s-encrypt-by-ali-cloud-dns-generic-domain-https-authentication.article">https://f-e-d.club/topic/use-acme-sh-deployment-let-s-encrypt-by-ali-cloud-dns-generic-domain-https-authentication.article&lt;/a>&lt;/p>
&lt;h2 id="使用-acmesh-创建证书">使用 acme.sh 创建证书&lt;/h2>
&lt;h3 id="安装-acmesh">安装 acme.sh&lt;/h3>
&lt;p>acme.sh 是一个纯 Shell 脚本~~
下载这个脚本&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>curl https://get.acme.sh | sh
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>source ~/.bashrc
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>该脚本会创建 &lt;code>~/.acme.sh/&lt;/code> 目录，并在该目录中安装 acme.sh 脚本。acme.sh 的配置文件，生成证书默认保存的位置也在这里。同时会在 &lt;code>~/.bashrc&lt;/code> 文件中添加 &lt;code>. &amp;quot;/root/.acme.sh/acme.sh.env&amp;quot;&lt;/code>&lt;/p>
&lt;h3 id="获取域名注册商认证信息">获取域名注册商认证信息&lt;/h3>
&lt;h4 id="阿里">阿里&lt;/h4>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://github.com/acmesh-official/acme.sh/wiki/dnsapi#11-use-aliyun-domain-api-to-automatically-issue-cert">GitHub 项目 Wiki，acmesh-official/acme.sh-dnsapi-使用阿里云域名 API 自动颁发证书&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>从 &lt;a href="https://ram.console.aliyun.com/users">阿里云控制台-RAM 访问控制-身份管理-用户&lt;/a> 处创建用户并获取 AK、SK&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>export Ali_Key&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;AccessKeyId&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>export Ali_Secret&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;AccessKeySecret&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h4 id="namecom">Name.com&lt;/h4>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://github.com/acmesh-official/acme.sh/wiki/dnsapi#28-use-namecom-api">GitHub 项目 Wiki，acmesh-official/acme.sh-dnsapi-使用 Name.com API&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>从 &lt;a href="https://www.name.com/zh-cn/account/settings/api">https://www.name.com/zh-cn/account/settings/api&lt;/a> 创建 Token&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>export Namecom_Username&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;XXXX&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>export Namecom_Token&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;XXXXX&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>注意：这俩变量要使用 PRODUCTION(生产)环境的。Name.com 创建完 Token 后会有两个~一个用于生产，一个用于测试，对应不用的 API&lt;/p>
&lt;h3 id="生成证书">生成证书&lt;/h3>
&lt;p>使用“阿里云”生成证书文件到指定目录后，执行命令重启容器&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>acme.sh --issue --dns dns_ali -d desistdaydream.ltd -d *.desistdaydream.ltd &lt;span style="color:#ae81ff">\
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">&lt;/span>--installcert &lt;span style="color:#ae81ff">\
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">&lt;/span>--key-file /opt/alist/data/cert/desistdaydream.key &lt;span style="color:#ae81ff">\
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">&lt;/span>--fullchain-file /opt/alist/data/cert/desistdaydream.pem &lt;span style="color:#ae81ff">\
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">&lt;/span>--reloadcmd &lt;span style="color:#e6db74">&amp;#34;docker restart alist&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>使用“Name.com”生成证书文件到指定目录后，执行命令重启容器&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>acme.sh --issue --dns dns_namecom -d 102205.xyz -d *.102205.xyz &lt;span style="color:#ae81ff">\
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">&lt;/span>--key-file /opt/alist/data/cert/102205.key &lt;span style="color:#ae81ff">\
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">&lt;/span>--fullchain-file /opt/alist/data/cert/102205.pem &lt;span style="color:#ae81ff">\
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">&lt;/span>--reloadcmd &lt;span style="color:#e6db74">&amp;#34;docker restart alist&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># 或&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>acme.sh --issue --dns dns_namecom -d 102205.xyz -d *.102205.xyz &lt;span style="color:#ae81ff">\
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">&lt;/span>--installcert &lt;span style="color:#ae81ff">\
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">&lt;/span>--key-file /opt/alist/data/cert/102205.key &lt;span style="color:#ae81ff">\
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">&lt;/span>--fullchain-file /opt/alist/data/cert/102205.pem &lt;span style="color:#ae81ff">\
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">&lt;/span>--reloadcmd &lt;span style="color:#e6db74">&amp;#34;docker restart alist&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># 或&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># 生成到 Nginx 目录&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>acme.sh --issue --dns dns_namecom -d 102205.xyz -d *.102205.xyz &lt;span style="color:#ae81ff">\
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">&lt;/span>--installcert &lt;span style="color:#ae81ff">\
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">&lt;/span>--key-file ~/projects/DesistDaydream/cloud-native-apps/compose/nginx-lch/config/certs/102205.key &lt;span style="color:#ae81ff">\
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">&lt;/span>--fullchain-file ~/projects/DesistDaydream/cloud-native-apps/compose/nginx-lch/config/certs/102205.pem &lt;span style="color:#ae81ff">\
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">&lt;/span>--reloadcmd &lt;span style="color:#e6db74">&amp;#34;docker exec -it nginx-geoip2 nginx -c /etc/nginx/nginx/nginx.conf -s reload&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="创建完成">创建完成&lt;/h3>
&lt;p>证书创建完成后，将会在系统的 Crontab 中创建一个逻辑&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>~&lt;span style="color:#f92672">]&lt;/span>&lt;span style="color:#75715e"># crontab -l&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">26&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span> * * * /root/.acme.sh/acme.sh --cron --home &lt;span style="color:#e6db74">&amp;#34;/root/.acme.sh&amp;#34;&lt;/span> &amp;gt; /dev/null
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div></description></item><item><title>Docs: 管理工具</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/7.%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8/%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/7.%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8/%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/</guid><description/></item><item><title>Docs: 什么鬼？</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/7.%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8/%E4%BB%80%E4%B9%88%E9%AC%BC/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/7.%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8/%E4%BB%80%E4%B9%88%E9%AC%BC/</guid><description>
&lt;p>要研究态势感知或安全运营中心，可以采用OSSIM
要研究入侵防御技术，可以采用Snort或Security Onion
要研究防火墙技术，可以采用pfSense或OPNsense
要研究Web应用防火墙（WAF ），可以采用ModSecurity
要研究威胁情报技术，可以采用MISP或OpenCTI
要研究漏洞扫描技术，可以采用OpenVAS或W3AF
要研究堡垒机技术，可以采用JumpServer
要研究蜜罐技术，可以采用T-Pot或Hfish&lt;/p></description></item></channel></rss>