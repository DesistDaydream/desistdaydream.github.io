<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>断念梦 – 7.信息安全</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/7.%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8/</link><description>Recent content in 7.信息安全 on 断念梦</description><generator>Hugo -- gohugo.io</generator><atom:link href="https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/7.%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8/index.xml" rel="self" type="application/rss+xml"/><item><title>Docs: Access Control(访问控制)</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/7.%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8/access-control%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/7.%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8/access-control%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://mp.weixin.qq.com/s/vhwA-1UrE_6R7lICCMpG6A">RBAC 的演进历史、设计理念及简洁实现&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;h2 id="译者序">译者序&lt;/h2>
&lt;p>本文翻译自 2021 年的一篇英文博客：RBAC like it was meant to be[1]。&lt;/p>
&lt;p>很多系统（例如 Kubernetes）都在使用某种形式的 RBAC 做权限 / 访问控制。&lt;/p>
&lt;p>本文基于 access control 的发展历史，从设计层面分析了&lt;code>DAC -&amp;gt; MAC -&amp;gt; RBAC -&amp;gt; ABAC&lt;/code>的演进历程及各模型的优缺点、适用场景等， 然后从实际需求出发，一步一步地设计出一个实用、简洁、真正符合 RBAC 理念的访问控制系统。&lt;/p>
&lt;p>&lt;strong>由于译者水平有限，本文不免存在遗漏或错误之处。如有疑问，请查阅原文。&lt;/strong>&lt;/p>
&lt;p>以下是译文。&lt;/p>
&lt;hr>
&lt;p>大部分人都听说过&lt;strong>基于角色的访问控制&lt;/strong>（role-based access control, RBAC）以及它 的后继演进版&lt;strong>基于属性的访问控制&lt;/strong>（attribute-based access control, ABAC）， 但我们经常遗忘或不懂得欣赏其中的伟大思想。&lt;/p>
&lt;p>大部分如今常见的 RBAC 系统都经过了某种程度的简化，因此比最初的设计要弱一些。而本文想要说明，只要回到 RBAC 最初的设计，我们就能构建一个真正的 RBAC/ABAC 安全模型[2]，它比你能见到的那些系统更简单而强大，而且不管网络规模大还是小，它都能适用。&lt;/p>
&lt;p>客户经常跟我们反馈说，他们如何震惊于如下事实：在 Tailscale 平台上，只用如此少的规则就能表达他们的安全策略。这并非偶然！但在解释为什么之前，我们先来回顾一些历史。&lt;/p>
&lt;p>RBAC/ABAC 的概念和术语都源自几十年前的美国军方。[Role-Based Access Controls (Ferraiolo and Kuhn, 1992)](https://www.researchgate.net/publication/24164143_Role-Based_Access_Controls&amp;gt; &amp;ldquo;Role-Based Access Controls (Ferraiolo and Kuhn, 1992&amp;quot;Role-Based Access Controls (Ferraiolo and Kuhn, 1992)&amp;rdquo;)&amp;quot;) 是一篇很好的介绍。下面来看一下它们的一些演进过程。&lt;/p>
&lt;h2 id="11-dac自主访问控制各文件-owner-自主设置文件权限">1.1 DAC（自主访问控制）：各文件 owner 自主设置文件权限&lt;/h2>
&lt;p>最早出现的是 DAC（Discretionary Access Control），直到今天仍然很常见。&lt;/p>
&lt;h3 id="设计">设计&lt;/h3>
&lt;p>如下图所示，在 DAC 中 object owner 有权设置该 object 的访问权限。&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/ef62c7f4-2473-4713-a153-66b5d85aa2f0/640" alt="">&lt;/p>
&lt;p>通过授予 individuals/groups 以 read/write/execute 权限， object (file) 的创建者能完全控制该 object 的内容和权限。&lt;/p>
&lt;p>例如，&lt;/p>
&lt;ol>
&lt;li>在 Unix 系统中，设置 file permission（“模式”，这也是 &lt;code>chmod&lt;/code> change mode 的来历） 就能授予别人 &lt;code>读 / 写 / 执行&lt;/code> 这个文件的权限。&lt;/li>
&lt;li>在 Google Doc 中，点击 share 按钮能授予权限。&lt;/li>
&lt;/ol>
&lt;h3 id="使用场景普通用户的文件权限控制">使用场景：普通用户的文件权限控制&lt;/h3>
&lt;ul>
&lt;li>军方不怎么喜欢 DAC，因为这种方式中，合规性很难保证，机密文件很容易被恶意 reshare 出去。&lt;/li>
&lt;li>但在普通用户场景中，这种方式还是很常用也很合理的。&lt;/li>
&lt;/ul>
&lt;h2 id="12-mac强制访问控制强制由专门的-admin-设置文件权限">1.2 MAC（强制访问控制）：（强制由）专门的 admin 设置文件权限&lt;/h2>
&lt;blockquote>
&lt;p>注意：不要把 MAC (mandatory access control) 与网络术语 &amp;ldquo;MAC address&amp;rdquo; 中的 MAC (media access address) 搞混了，二者没有任何关系，只是碰巧缩写相同。&lt;/p>
&lt;/blockquote>
&lt;h3 id="设计dac-基础上引入专门的-admin-角色">设计：DAC 基础上引入专门的 admin 角色&lt;/h3>
&lt;p>MAC (Mandatory access control) 对 DAC 做了增强。如下图所示， 由 administrator（管理员）或 administrative rule（管理员级别的规则） 来定义 rules。&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/ef62c7f4-2473-4713-a153-66b5d85aa2f0/640" alt="">&lt;/p>
&lt;p>文件 owner 只能设置一个文件 type，这个 type 包含了哪些权限是由 admin 或 policy 设置的。用户能编辑文件内容，但无法修改文件权限。&lt;/p>
&lt;p>因此在 MAC 模型中，一个人做某些事情的 能力是无法再分享给其他人的，从而避免了文件被 reshare 的问题。&lt;/p>
&lt;h3 id="例子tcpudp-端口号">例子：TCP/UDP 端口号&lt;/h3>
&lt;p>MAC 很难解释，因为在实际中很少看到它，甚至看到了之后，你都不觉得它是 “访问控制”。&lt;/p>
&lt;p>Wikipedia 给了一个很好的例子：TCP 或 UDP 端口号。当你占用了一个 local port 之后（假设没设置 SO_REUSEADDR[3]）， 这台机器上的其他任何人就都无法再用这个端口号了 —— 不管他们是什么级别的特权用户。这里，端口范围不可重叠这一条件，就是强制性的（mandatory）。&lt;/p>
&lt;h3 id="适用场景文档--系统访问控制">适用场景：文档 / 系统访问控制&lt;/h3>
&lt;p>之前关于 file locking[4] 的文章中，我讨论了 advisory locks 和 mandatory locks 之间的区别：&lt;/p>
&lt;ul>
&lt;li>advisory lock：其他 apps 可以安全地读这个文件；&lt;/li>
&lt;li>mandatory lock：按照规则，其他不允许 apps 读任何内容。&lt;/li>
&lt;/ul>
&lt;p>可以看出，MAC 适用于对文档或系统的访问控制，这就不难理解为什么 军方对 MAC —— 至少在理论上 —— 如此兴奋了。理想场景：&lt;/p>
&lt;ul>
&lt;li>一个带锁的房间，门口有警卫站岗，&lt;/li>
&lt;li>出示门禁卡能进入这个房间，&lt;/li>
&lt;li>但警卫禁止携带相机进入房间。&lt;/li>
&lt;/ul>
&lt;p>在这种场景下，你自己有权限查看房间内的文档，但无法将其分享给其他人。&lt;/p>
&lt;p>这个例子给我们的一个启示是：数字系统中，MAC 在理论要比在实际中简单（easier in theory than in practice）。&lt;/p>
&lt;ul>
&lt;li>一个功能完整的（full-on）MAC 系统是很难真正实现的。&lt;/li>
&lt;li>Digital restrictions management(DRM，数字限制管理) 是 MAC 的 一种，在这种模型中，文件的接收方无法再将文件分享给别人—— 每个 BitTorrent 用户都能体会到这种方式是如何奏效的。&lt;/li>
&lt;/ul>
&lt;h2 id="13-mac-之双因素登录two-factor-login-as-mac">1.3 MAC 之双因素登录（two-factor login as MAC）&lt;/h2>
&lt;p>大家可能没意识到，另一种 MAC 是 multi-factor authentication (MFA or 2FA):&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/ef62c7f4-2473-4713-a153-66b5d85aa2f0/640" alt="">&lt;/p>
&lt;p>2FA as MAC：密码可以共享，但硬件 token 不能。密码是 DAC，而硬件 token 是 MAC。&lt;/p>
&lt;p>用 MFA 能允许特定的人登录一台计算机或服务，如果这个人不是管理员（admin），那他 自己能登录，但将无法进一步将计算机共享给其他人，将密码告诉他们也不行。&lt;/p>
&lt;p>这种 login 是强制性的（mandatory，单有密码不行，还必须有硬件 token 才能登录）。在这个模型中，假设了第二因素（the second factor，即硬件 token）是不可分享的。&lt;/p>
&lt;h2 id="14-图片分享dacmac-模型比较">1.4 图片分享：DAC/MAC 模型比较&lt;/h2>
&lt;p>另一个例子是分享图片。&lt;/p>
&lt;ul>
&lt;li>在某些服务中，任何有正确 secret URL 的人都能访问给定的图片 / 消息 / 文件，并且任何有这个 URL 的人都能继续分享它，这是 DAC 模式。&lt;/li>
&lt;li>在另一些服务中，单有这个 URL 还不行，必须要登录有权限查看这个文件的账号之后， 才能 reshare：这 MAC 模式。虽然某些人能通过特定的 URL 访问 这个文件，但 reshre 这个 URL 并不能让其他人看到这个文件。&lt;/li>
&lt;/ul>
&lt;blockquote>
&lt;p>当然，如果一个人能下载这个文件，然后发送副本给别人，那结果还是泄露了这个文件 。这也是为什么一些人认为 secret URL 的安全性在数学上与 MAC 是等价的，因为现在 分享 URL 已经和分享文件一样难了。但二者有一个区别：你可以关闭一个 URL 的共享，但无法追回一个已经发送出去的文件副本。&lt;/p>
&lt;/blockquote>
&lt;h2 id="15-mac-概念限制太多又好像没什么限制">1.5 MAC 概念：限制太多，又好像没什么限制&lt;/h2>
&lt;p>历史上，军方中的 MAC 是围绕 multi-level security[5] 构建的，这里的设计思想是：并非只有 admin 和 non-admin 两种用户，实际上有很多层的访问。他们最初将其设想为同心圆（“最高机密许可”、“机密许可” 等等），但最后证明 表达力太弱（too unexpressive）。&lt;/p>
&lt;p>如今的访问控制更像是独立的 flags 或 subgroups。例如， SELinux 提供了对每个进程内的每个权限的细粒度控制，而传统 Unix/Linux 上只有 root 和常规用户权限的区分。但最终证明 SELinux 这套东西是噩梦般的复杂， 难以真正实用 —— 除非你在 NSA（发明 SELinux 的机构）工作，但即使 你在 NSA 也不一定会用。&lt;/p>
&lt;p>最终来说，MAC 的概念证明是过于限制又过于模糊（both too restrictive and too vague）。当人们谈论 MAC 时，我们很难搞清楚他们到底指的是什么，唯一知道是：这东西用起来非常让人抓狂。&lt;/p>
&lt;h2 id="21-rbac基于角色的访问控制">2.1 RBAC（基于角色的访问控制）&lt;/h2>
&lt;p>RBAC 是 MAC 的一个子集，它是一种特殊类型的 MAC，更加具体，因此 在讨论及使用上会更加方便。&lt;/p>
&lt;p>RBAC 与常见的 users/groups 模型类似。在 RBAC 中，&lt;/p>
&lt;ul>
&lt;li>admin 将某些 user 放到一个 group，然后&lt;/li>
&lt;li>可以指定将某些资源（文件、计算机等）共享给某个 group（role）；&lt;/li>
&lt;li>系统确保只有指定的 role 能访问指定的资源；&lt;/li>
&lt;li>文件的接收方没有 reshare 权限 —— 除非拷贝一份，否则是无法 reshare 的。&lt;/li>
&lt;/ul>
&lt;h2 id="22-abac基于属性的访问控制">2.2 ABAC（基于属性的访问控制）&lt;/h2>
&lt;p>Attribute-based access control (Hu, Kuhn, Ferraiolo, 2015)[6] 是对 RBAC 的改进，加了一些细节（属性，Attributes）。&lt;/p>
&lt;ul>
&lt;li>属性可以是位置、客户端设备平台、认证类型、用户的 http cookies 等。&lt;/li>
&lt;li>当系统判断是否授予某个用户对某资源的访问权限时，ABAC 系统除了检查他们的 RBAC role（group），还会检查这个人携带的各种属性。&lt;/li>
&lt;/ul>
&lt;p>如果你遇到过下面这种情况 —— 登录某个服务时弹出额外的图片识别认证 reCAPTCHA[7]， 而你旁边的朋友登录时却不用 —— 就说明你遇到了 ABAC。&lt;/p>
&lt;p>ABAC 很有用，因为这些额外的属性能给我们带来很多有用信息，尤其 是对于那些连接到互联网的、攻击矢量特别多的系统。但在概念上，ABAC 与 RBAC 类似，只是稍微向前演进了一点。属性的解析和认证工作是中心式的，大部分都实现 在各家的 identity provider 中。有鉴于此，接下来我们的讨论重点扔将放在 RBAC。&lt;/p>
&lt;h2 id="23-也许你从未用过真正的-rbac">2.3 也许你从未用过真正的 RBAC&lt;/h2>
&lt;p>RBAC 与前面提到的 users/groups 模型类似。接下来看一个具体的文件系统安全模型，例如 Windows。&lt;/p>
&lt;blockquote>
&lt;p>这里也可以拿 Unix 作为例子，但经典 Unix 文件安全与常见的安全模型不同， 它只支持单个 owner、单个 group，以及 self/group/other 文件模式。如今 Linux 也支持 facls[8]， 这算是 RBAC，但没人知道怎么用，因此这个也不算数。&lt;/p>
&lt;/blockquote>
&lt;h3 id="windows-文件安全模型每个文件一个-acl">Windows 文件安全模型：每个文件一个 ACL&lt;/h3>
&lt;p>在 Windows 中，&lt;/p>
&lt;ol>
&lt;li>每个文件（或目录）都有一个 users 和 groups 列表，以及&lt;/li>
&lt;li>每个列表中的成员可以对这个文件做什么操作。&lt;/li>
&lt;/ol>
&lt;p>这是一种访问控制列表（access control list，ACL）。owner 设置 ACL，操作系 统执行 ACL。这是 MAC，对吧？&lt;/p>
&lt;p>对的 —— 大部分情况下。想一下，任何有文件读权限的人，都可以拷贝一份，然后在副本上 设置权限，因此这是某种形式的 DAC，或者说在执行上充满漏洞的 MAC。但在真实文件上（而非 API 上）执行 MAC 非常难。我们将这个难题留给军方，现在把关注点放在 ACL 语义上。&lt;/p>
&lt;p>在一个 Windows filesystem ACL 中，有如下概念：&lt;/p>
&lt;ol>
&lt;li>User：在这个文件上执行操作的用户。在经典 RBAC 术语中，称为 subject。&lt;/li>
&lt;li>Group 或 Role：由管理员定义的一组 user。&lt;/li>
&lt;li>File：需要做访问控制的资源（resource）。也称为 object。subject 对 object 进行操作。&lt;/li>
&lt;li>Permission 或 Entitlement：一条 &lt;code>subject-action-object&lt;/code>（用户 - 动作 - 目标文件）规则。有时会说某个 subject 有一条 entitlement，或者说某个 object 允许某个 permission，这两种表达方式本质上是一样的，只是从不同的角度描述。&lt;/li>
&lt;li>ACL：一个 entitlements 列表。&lt;/li>
&lt;/ol>
&lt;h3 id="控制谁能访问哪个文件">控制谁能访问哪个文件&lt;/h3>
&lt;p>每个文件都有一个 ACL（permission 列表）。&lt;/p>
&lt;blockquote>
&lt;ul>
&lt;li>每个文件都有一个 ACL。该 ACL 可能从文件所在子目录的 ACL 中继承某些 entry，也 可能不会，这些对我们目前的讨论来说不重要。&lt;/li>
&lt;li>ACL 相同的文件，它们的 ACL 可能在磁盘上是分别存储的，这些是实现细节，我们这里 也不关心。&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>如果想控制谁能访问这些文件，可通过以下任一种方式：&lt;/p>
&lt;ol>
&lt;li>找到 ACL 对应的 groups/roles，在其中添加或删除 user（称为修改 group/role 的 membership）；或者，&lt;/li>
&lt;li>直接修改 ACL，添加或删除 permissions。&lt;/li>
&lt;/ol>
&lt;p>如果想一次修改一组文件的 ACL，可以&lt;/p>
&lt;ol>
&lt;li>修改 group/role membership（简单），或者&lt;/li>
&lt;li>找到所有相关文件，逐个修改对应的 ACL（慢且易出错）。&lt;/li>
&lt;/ol>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/ef62c7f4-2473-4713-a153-66b5d85aa2f0/640" alt="">&lt;/p>
&lt;p>文件多了之后，逐个修改 ACL 就不切实际了。&lt;/p>
&lt;h2 id="24-存在的问题acl-太多到处重复批量修改麻烦">2.4 存在的问题：ACL 太多，到处重复，批量修改麻烦&lt;/h2>
&lt;p>最后一点，也是访问控制开始出现漏洞的地方。&lt;/p>
&lt;ul>
&lt;li>几乎所有系统，不管是不是 RBAC，都支持寻找文件系统中的 objects，然后修改它们的 ACL， 但配套的 object 管理系统可能做的很差。&lt;/li>
&lt;li>在分布式系统中，这些 objects 可能分散在世界各地，放在各种不同的存储系统中，而 它们的共同之处就是都依赖你的 identity 系统。&lt;/li>
&lt;li>如果某天发现一个 permission 给错了，就必须找到这个 permission 的所有副本并解 决之，否则就遗留了一个安全问题。但如果 objects 管理系统做得比较糟糕，这里做起 来就会很麻烦。&lt;/li>
&lt;/ul>
&lt;p>被以上问题折磨多次之后，你可能会尝试一些新东西：&lt;/p>
&lt;ul>
&lt;li>将尽量多的信息从 ACL（分散在各处）中移出，&lt;/li>
&lt;li>将尽量多的东西移入 user groups（集中式存储，而且能审计）。&lt;/li>
&lt;/ul>
&lt;h2 id="31-仍以-windows-文件系统为例">3.1 仍以 Windows 文件系统为例&lt;/h2>
&lt;p>仍然以 Windows 文件系统为例，如下图所示，你可能会创建两个 group &lt;code>report-readers&lt;/code>和 &lt;code>report-writers&lt;/code>：&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/ef62c7f4-2473-4713-a153-66b5d85aa2f0/640" alt="">&lt;/p>
&lt;p>将尽量多的东西从 ACL 中移出，将尽量多的东西移入 groups 中。&lt;/p>
&lt;p>效果是：所有 reports 文件能被 &lt;code>report-readers&lt;/code> 组内的用户读，能被 &lt;code>report-writers&lt;/code>组内的用户写。&lt;/p>
&lt;blockquote>
&lt;p>经验不足的人在这里会犯的一个错误是：只创建一个名为 &lt;code>report&lt;/code> 的 group，然后给 予这个 group read/write 权限。通常来说，需要文件读权限的用户，要比需要 写权限的用户更多。甚至在某些情况下，writer 和 reader 用户之间都没有重叠（例如审计日志场景）。&lt;/p>
&lt;/blockquote>
&lt;p>这种 per-file-type group（每种文件访问类型一个单独的 user group）结构是 Don&amp;rsquo;t Repeat Yourself(DRY) 原则在实际应用中的一个例子：上一节 RBAC/ABAC 模型中，根源问题是每个文件都有自己的 ACL， 这些 ACL 到处重复，因此这里提取出了重复部分放到了一个公共的地方。&lt;/p>
&lt;h2 id="32-存在的问题">3.2 存在的问题&lt;/h2>
&lt;p>这个改进比较合理，尤其是在有很多 objects 的大公司中工作良好，但也有几个问题：&lt;/p>
&lt;ol>
&lt;li>现在需要有某种形式的 IAM admin 访问控制，也就是对用户组的增删查改做控制。
上一节的 RBAC/ABAC 模型中无需这种功能，因为它直接修改文件的 ACL。IAM admin 管控带来的一个新问题是：&lt;/li>
&lt;/ol>
&lt;ul>
&lt;li>如果管控太松，会导致很多人都有 IAM 的访问权限，存在风险；&lt;/li>
&lt;li>如果管控太紧，大部分都无权修改 group membership，又会使得这种模型的好处大打折扣。&lt;/li>
&lt;/ul>
&lt;ol start="3">
&lt;li>End users 仍然能四处游荡，在需要时能修改每个 report 文件的 ACL（“Alice 真的真的需要查看这个文件”），破坏了你精心设计的系统 —— 而你自己都无法察觉。&lt;/li>
&lt;li>现在需要为每个 ACL 组合创建一个 user group。
最后会发现，公司的每个工程师都属于 975 个 group，每个 group 都需要定义 read/write 两种类型。你必须 review 每个 group 的 membership。这种方式虽然比 老的 ad-hoc 文件权限方式审计性要好，但也好不了太多。&lt;/li>
&lt;/ol>
&lt;p>至此，我们决定放弃文件系统的 ACL，原因是：文件系统已经设计成这样了， 基于文件系统的 ACL 我们只能做到目前这样。你大概率无法解决现有的文件系统和操作系统中这些问题。&lt;/p>
&lt;p>但接下来的好消息是：如今的服务都运行在无状态容器内， 大部分 VM 都无需密码就能执行 sudo， 因此我们不用再对文件系统进行控制，而是对 web 应用和 NoSQL 的 API 做控制。这也许不是巧合，因为对细粒度分布式安全（fine-grained distributed security）的需求一直在增长，而文件系统还停留在 1980s 年代。&lt;/p>
&lt;p>那么，接下来就开始设计我们想要的 permission 系统！&lt;/p>
&lt;h2 id="41-根据-user-type-而非-file-type-创建-user-group">4.1 根据 user type 而非 file type 创建 user group&lt;/h2>
&lt;p>首先，注意到，前面两节的文件系统 ACL 方案其实并不是真正意义上基于角色的（role-based）访问控制。为什么呢？它把 user groups 作为 roles —— 这没有问题 —— 但如果你有 975 个像 &lt;code>report-readers&lt;/code> 和 &lt;code>report-writers&lt;/code>一样的 group，那这些就不算不上是真正的 human-relevant roles。HR 并不知道 你的新员工是否应该是 report-reader，这个决策太底层了（low-level）。&lt;/p>
&lt;p>因此我们得到的第一个启示就是：应该根据用户类型（user types）而非文件类型（file types）来创建 user groups。如下图所示：&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/ef62c7f4-2473-4713-a153-66b5d85aa2f0/640" alt="">&lt;/p>
&lt;h2 id="42-roles-去扁平化增强表达力将-acl-定义为一组策略规则">4.2 Roles 去扁平化，增强表达力：将 ACL 定义为一组策略规则&lt;/h2>
&lt;p>以上 group-per-user-type 格式还是过于扁平了（too flat）：它已经丢失了 “为什么某人会在某 group” 的语义含义（semantic meaning）。如果 Bob 离职了，我们必须修改所有可能包含 Bob 的 groups。这虽然已经比跟踪每个 &lt;code>report&lt;/code> 类型的文件 然后 double check 它的 permissions 是否还正确要好，但仍然很容易出错。&lt;/p>
&lt;p>我们假设有如下角色（roles）：Accounting（审计人员）、DevOps（研发运维人员）、Engineering（工程师）、Executive（高管）。&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/ef62c7f4-2473-4713-a153-66b5d85aa2f0/640" alt="">&lt;/p>
&lt;p>然后我们就可以将 ACL 定义为一组策略规则（a set of policy rules）：&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/ef62c7f4-2473-4713-a153-66b5d85aa2f0/640" alt="">&lt;/p>
&lt;p>这种模型与最初的 flat 模型表达的东西是一样的，但通过增加一个间接层（indirection）， 它表达了我们一直想表达（而没有表达出来）的东西。有了这个模型， 接下来就可以讨论：&lt;/p>
&lt;ul>
&lt;li>由 HR 部门定义的 human-relevant roles，以及&lt;/li>
&lt;li>由安全部门定义的标签（tags），以及&lt;/li>
&lt;li>二者是如何联系到一起的。&lt;/li>
&lt;/ul>
&lt;h2 id="43-关于策略规则的进一步解释">4.3 关于策略规则的进一步解释&lt;/h2>
&lt;p>我们正在设计一个新的权限系统。&lt;/p>
&lt;p>现在，先将刚才设计的能转换成的 roles 的 policy rules 进一步表示为：&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/ef62c7f4-2473-4713-a153-66b5d85aa2f0/640" alt="">&lt;/p>
&lt;p>有了这样一种格式的描述之后，当我们需要满足 SOC2 合规性要求时，只需将 &lt;code>database&lt;/code>的 readers 改为，例如 &lt;code>[DevOps, Prod]&lt;/code>，这将会立即锁定所有数据库相关的对象。&lt;/p>
&lt;h2 id="44-其他特性">4.4 其他特性&lt;/h2>
&lt;p>最后，我们来加两个其他特性：&lt;/p>
&lt;p>首先，与文件只有一种 type（读或写）不同，一个对象可以有零或多个 tags。因此，与数据库相关的源文件可以打上 &lt;code>database&lt;/code> 和 &lt;code>sourcefile&lt;/code> 两个 tag，对应地， 它获得的是两种 permission set 的交集。&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/ef62c7f4-2473-4713-a153-66b5d85aa2f0/640" alt="">&lt;/p>
&lt;p>第二，只有 tag 的 owner 有权限增加或删除任何对象上的该 tag。例如在下图中，只有 Engineering 可以在某个对象打 &lt;code>sourcefile&lt;/code> tag。这能够避免意外将对象分享给应该完全隔离的人，或在不期望的地方错误地应用已有策略。&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/ef62c7f4-2473-4713-a153-66b5d85aa2f0/640" alt="">&lt;/p>
&lt;h2 id="45-mac-归来">4.5 MAC 归来&lt;/h2>
&lt;p>至此，我们看到了 MAC 回归的身影。但是，现在它，&lt;/p>
&lt;ol>
&lt;li>不需要一个针对 security policy 的 global admin access control。&lt;/li>
&lt;li>每个 tag owner 能直接对他们的 objects 进行授权，但他们能授予哪些访问权限，是 由整体上的安全策略（the overall security policy，即 roles）控制的。&lt;/li>
&lt;/ol>
&lt;h2 id="46-例子api-访问控制">4.6 例子：API 访问控制&lt;/h2>
&lt;p>在类似 Tailscale 的网络系统中，我们其实并不会用 readers 和 writers 这样的文件系统术语。我们定义 node 和 port，以及允许谁连接到这些 node 和 port。例如可能会如下规则：&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/ef62c7f4-2473-4713-a153-66b5d85aa2f0/640" alt="">&lt;/p>
&lt;p>有了以上规则，&lt;/p>
&lt;ol>
&lt;li>Engineering 中的任何人都可以启动一个&lt;code>dev-api-server&lt;/code> node，&lt;/li>
&lt;li>该 node 能接受从任何 &lt;code>dev-api-client&lt;/code> node 来的非加密连接（TLS 太难了！开发环境就放行非加密连接吧），但反之并不亦然。&lt;/li>
&lt;li>只有 Ops 中的人能启动 &lt;code>prod-api-server&lt;/code> 和 &lt;code>prod-api-client&lt;/code> nodes，它们只处理 https 流量，拒绝非加密 http。&lt;/li>
&lt;/ol>
&lt;p>下面是效果：&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/ef62c7f4-2473-4713-a153-66b5d85aa2f0/640" alt="">&lt;/p>
&lt;p>这里注意：我们递归地用一些 tag names 来定义 permissions for other tags。Ops 中的某个人可以启动一个 node 并打上 &lt;code>prod-api-server&lt;/code> tag， 这个 node 就会获得与 &lt;code>prod-api-server&lt;/code> 而不是 Ops 相关联的 permissions 和 entitlements（ 这很重要，因为&lt;code>prod-api-server&lt;/code> instance 无法像 Ops 一样启动更多 instance）。&lt;/p>
&lt;p>真实的 Tailscale ACLs 和 tags[9] 与此很像，但更加具体。&lt;/p>
&lt;h2 id="51-根据-policy-rules-和-user-groups-自动生成访问权限">5.1 根据 policy rules 和 user groups 自动生成访问权限&lt;/h2>
&lt;p>如果试图将这个模型反向适配到 legacy-style filesystem permissions， 我们就会发现 roles 和 tag definitions 其实是相同类型的对象（都是 lists of users）， 二者之间通过一个（“安全策略”）算法进行单向转换：&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/ef62c7f4-2473-4713-a153-66b5d85aa2f0/640" alt="">&lt;/p>
&lt;p>将 roles 扩展成 tags，然后适配到传统文件系统的权限控制模型。&lt;/p>
&lt;p>你可以类似地写一些脚本，将给定的 roles 和 group membership rules 自动生成你的 /etc/group 内容，我知道有些公司就是这样做的。这不是标准方式，维护很痛苦，而且通常用定时任务来批量执行，这意味着当修改 一个 tag 或 group membership 之后，必须要等上一段时间才能生效。但本质上来说，这 种方式是能工作的，而且比典型的操作系统默认值要好多了。&lt;/p>
&lt;h2 id="52-tags-和-roles-各自的适用场景">5.2 Tags 和 roles 各自的适用场景&lt;/h2>
&lt;p>前面说 tags（用于 ACL 目的）和 roles（用于 user management 目的）都是 “用户列表”（lists of users），其实这种说法有误导性。二者用于不同场景。最重要的是，不同的人负责系统的不同部分：&lt;/p>
&lt;ol>
&lt;li>Roles 描述的是 identity system (authentication) 中的人。Roles 变化很少，通常在入职、晋升或转岗时由 HR 部门设置。&lt;/li>
&lt;li>Object types (tags) 由 object owner 在这个 object 创建时设置。&lt;/li>
&lt;li>Entitlements 用 &lt;code>(Role, Tag)&lt;/code> 描述，由简单的程序（安全策略）来定义，由安全团队设置。&lt;/li>
&lt;/ol>
&lt;p>在这个架构中，这三种类型的人只有很少时候才需要交互：&lt;/p>
&lt;ol>
&lt;li>Accounting 部门中的财报 writer 并不关心谁是 Executive，也不关心 Executive 是否 有权查看或编辑财报。他们只需知道要给 report 文件打上 financial-report tag。&lt;/li>
&lt;li>安全团队并不关心哪个文件打了 &lt;code>financial-report&lt;/code>（讨论一般情况下），也不关心谁是 Executive。他们需要的是&lt;/li>
&lt;/ol>
&lt;ul>
&lt;li>能读、写对应的安全策略，以及确保策略生效：&lt;/li>
&lt;li>确保 financial-report tag 只能被 Accounting 部门打，对应的文件只能被 Executives 和 Accounting 读（read only）。&lt;/li>
&lt;/ul>
&lt;ol start="4">
&lt;li>HR 团队不知道也不关心文件或安全策略，他们只关心这周招了一个 Accounting role 的人。&lt;/li>
&lt;/ol>
&lt;h2 id="53-小结">5.3 小结&lt;/h2>
&lt;p>回到 network permissions 场景：在大公司中，正确地围绕这些概念设计你的模型，就能避免大量摩擦。&lt;/p>
&lt;p>我们在实际工作中可能会遇到如下类似的例子：工程师创建了一个新的开发（&lt;code>dev&lt;/code>）集群后，还要去提个工单，让安全团队给他开防火墙端口。为什么会这样？因为在这些公司中，安全团队维护的策略并不规范，没有收敛到以上模型：&lt;/p>
&lt;ol>
&lt;li>允许 Engineers 运行 dev API servers，接受来自本机或 dev API clients 的 incoming 连接 —— 这个没问题；&lt;/li>
&lt;li>通常不允许创建 outgoing connections —— 这个也没问题；&lt;/li>
&lt;li>噢对了，Carol 的 dev API server 需要主动访问数据库服务器，只能开单独策略了 —— 问题来了。&lt;/li>
&lt;/ol>
&lt;p>如果安全团队能将这些安全规则固化成代码片段，结果将会更好，能确保它们在整张 网络上得到一致执行。&lt;/p>
&lt;p>以上提到的所有东西，users、roles、object types、policies 都不是新概念， 它们都来自 1992 提出 RBAC 模型的那篇论文，只是术语稍有不同。&lt;/p>
&lt;p>如今，几乎每个人都在使用 users、groups、ACLs 了。一些人认为，我们实现的东西已经 是 RBAC，但事实告诉我们：并不是。还没有谁实现过完整的 RBAC 模型：&lt;/p>
&lt;ol>
&lt;li>每个人都是一个 User (subject)。&lt;/li>
&lt;li>每个 user 都有一个或多个 Roles。&lt;/li>
&lt;li>每个 object 都有一个或多个 Tags。&lt;/li>
&lt;li>一条 &amp;ldquo;security policy&amp;rdquo; 定义一个将 &lt;code>(Role, Tag)&lt;/code> 转换成 Entitlements 的公式。&lt;/li>
&lt;li>一个执行层（enforcement layer）负责 enforce security policy，并为每个 object 生成有效 entitlements 列表（ACL）。&lt;/li>
&lt;/ol>
&lt;p>但另一方面，实现这样一个模型比实现常见的 users+groups 模型并没有复杂多少—— 只要从一开始就将其放到系统的核心。&lt;/p>
&lt;p>最后回到文初，这就是为什么 Tailscale RBAC、ABAC 和 security policy 不同寻常的地方[10]。Tailscale objects 都是设备和端口（devices and ports），而非文件，但所有概念在使用上与在文件系统中是一样的。最终的产品在理念设计上很简洁：&lt;/p>
&lt;ol>
&lt;li>Device 或 container 的 owner 可以设置 tag；&lt;/li>
&lt;li>安全团队决定谁 own 哪些 tag、每个 tag 关联了哪些 permissions、tags 会授权给哪些 roles；&lt;/li>
&lt;li>Identity/HR 团队决定哪些 users 应该属于哪些 roles。&lt;/li>
&lt;/ol>
&lt;h3 id="引用链接">引用链接&lt;/h3>
&lt;p>[1]&lt;/p>
&lt;p>RBAC like it was meant to be: &lt;a href="https://tailscale.com/blog/rbac-like-it-was-meant-to-be/">&lt;em>https://tailscale.com/blog/rbac-like-it-was-meant-to-be/&lt;/em>&lt;/a>&lt;/p>
&lt;p>[2]&lt;/p>
&lt;p>真正的 RBAC/ABAC 安全模型: &lt;a href="https://tailscale.com/kb/1018/acls/">&lt;em>https://tailscale.com/kb/1018/acls/&lt;/em>&lt;/a>&lt;/p>
&lt;p>[3]&lt;/p>
&lt;p>SO*REUSEADDR: &lt;a href="https://man7.org/linux/man-pages/man7/socket.7.html">_https://man7.org/linux/man-pages/man7/socket.7.html*&lt;/a>&lt;/p>
&lt;p>[4]&lt;/p>
&lt;p>之前关于 file locking: &lt;a href="https://apenwarr.ca/log/20101213">&lt;em>https://apenwarr.ca/log/20101213&lt;/em>&lt;/a>&lt;/p>
&lt;p>[5]&lt;/p>
&lt;p>multi-level security: &lt;a href="https://en.wikipedia.org/wiki/Multilevel_security">&lt;em>https://en.wikipedia.org/wiki/Multilevel_security&lt;/em>&lt;/a>&lt;/p>
&lt;p>[6]&lt;/p>
&lt;p>Attribute-based access control (Hu, Kuhn, Ferraiolo, 2015): &lt;a href="https://www.researchgate.net/publication/273393378_Attribute-Based_Access_Control">&lt;em>https://www.researchgate.net/publication/273393378_Attribute-Based_Access_Control&lt;/em>&lt;/a>&lt;/p>
&lt;p>[7]&lt;/p>
&lt;p>reCAPTCHA: &lt;a href="https://www.google.com/recaptcha/about/">&lt;em>https://www.google.com/recaptcha/about/&lt;/em>&lt;/a>&lt;/p>
&lt;p>[8]&lt;/p>
&lt;p>facls: &lt;a href="https://www.usenix.org/legacy/publications/library/proceedings/usenix03/tech/freenix03/full_papers/gruenbacher/gruenbacher_html/main.html">&lt;em>https://www.usenix.org/legacy/publications/library/proceedings/usenix03/tech/freenix03/full_papers/gruenbacher/gruenbacher_html/main.html&lt;/em>&lt;/a>&lt;/p>
&lt;p>[9]&lt;/p>
&lt;p>真实的 Tailscale ACLs 和 tags: &lt;a href="https://tailscale.com/kb/1018/acls/">&lt;em>https://tailscale.com/kb/1018/acls/&lt;/em>&lt;/a>&lt;/p>
&lt;p>[10]&lt;/p>
&lt;p>Tailscale RBAC、ABAC 和 security policy 不同寻常的地方: &lt;a href="https://tailscale.com/kb/1018/acls/">&lt;em>https://tailscale.com/kb/1018/acls/&lt;/em>&lt;/a>&lt;/p></description></item><item><title>Docs: Bastion Host(堡垒机)</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/7.%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8/bastion-host%E5%A0%A1%E5%9E%92%E6%9C%BA/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/7.%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8/bastion-host%E5%A0%A1%E5%9E%92%E6%9C%BA/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Bastion_host">Wiki,Bastion host&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote></description></item><item><title>Docs: CFSSL</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/7.%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8/%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/cfssl/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/7.%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8/%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/cfssl/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://github.com/cloudflare/cfssl">GitHub 项目,cloudflare/cfssll&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://cfssl.org/">官网&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://mp.weixin.qq.com/s/E-aU-lbieGLokDKbjdGc3g">公众号&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>cfssl 与 openssl 类似，不过是使用 go 编写，由 CloudFlare 开源的一款 PKI/TLS 工具。主要程序有 cfssl，是 CFSSL 的命令行工具，cfssljson 用来从 cfssl 程序获取 JSON 输出，并将证书，密钥，CSR 和 bundle 写入文件中。&lt;/p>
&lt;h2 id="使用-cfssl-创建-ca-认证步骤">使用 CFSSL 创建 CA 认证步骤&lt;/h2>
&lt;h3 id="创建认证中心ca">创建认证中心(CA)&lt;/h3>
&lt;p>cfssl 可以创建一个获取和操作证书的内部认证中心。运行认证中心需要一个 CA 证书和相应的 CA 私钥。任何知道私钥的人都可以充当 CA 来颁发证书。因此，私钥的保护至关重要，这里我们以 k8s 所需的证书来实践一下：&lt;/p>
&lt;pre>&lt;code>cfssl print-defaults config &amp;gt; config.json # 默认证书策略配置模板
cfssl print-defaults csr &amp;gt; csr.json #默认csr请求模板
&lt;/code>&lt;/pre>
&lt;p>结合自身的要求，修改证书请求文件&lt;code>csr.json&lt;/code>,证书 10 年&lt;/p>
&lt;pre>&lt;code>{
&amp;quot;CN&amp;quot;: &amp;quot;kubernetes&amp;quot;,
&amp;quot;key&amp;quot;: {
&amp;quot;algo&amp;quot;: &amp;quot;rsa&amp;quot;,
&amp;quot;size&amp;quot;: 2048
},
&amp;quot;names&amp;quot;: [
{
&amp;quot;C&amp;quot;: &amp;quot;CN&amp;quot;,
&amp;quot;ST&amp;quot;: &amp;quot;BeiJing&amp;quot;,
&amp;quot;L&amp;quot;: &amp;quot;BeiJing&amp;quot;,
&amp;quot;O&amp;quot;: &amp;quot;k8s&amp;quot;,
&amp;quot;OU&amp;quot;: &amp;quot;System&amp;quot;
}
],
&amp;quot;ca&amp;quot;: {
&amp;quot;expiry&amp;quot;: &amp;quot;87600h&amp;quot;
}
}
&lt;/code>&lt;/pre>
&lt;p>知识点:&lt;/p>
&lt;ul>
&lt;li>&lt;code>&amp;quot;CN&amp;quot;&lt;/code>：Common Name，kube-apiserver 从证书中提取该字段作为请求的用户名 (User Name)&lt;/li>
&lt;li>&lt;code>&amp;quot;O&amp;quot;&lt;/code>：Organization，kube-apiserver 从证书中提取该字段作为请求用户所属的组 (Group)&lt;/li>
&lt;li>&lt;code>C&lt;/code>: Country， 国家&lt;/li>
&lt;li>&lt;code>L&lt;/code>: Locality，地区，城市&lt;/li>
&lt;li>&lt;code>O&lt;/code>: Organization Name，组织名称，公司名称&lt;/li>
&lt;li>&lt;code>OU&lt;/code>: Organization Unit Name，组织单位名称，公司部门&lt;/li>
&lt;li>&lt;code>ST&lt;/code>: State，州，省&lt;/li>
&lt;/ul>
&lt;p>证书配置模板文件&lt;code>ca-config.json&lt;/code>&lt;/p>
&lt;pre>&lt;code>{
&amp;quot;signing&amp;quot;: {
&amp;quot;default&amp;quot;: {
&amp;quot;expiry&amp;quot;: &amp;quot;87600h&amp;quot;
},
&amp;quot;profiles&amp;quot;: {
&amp;quot;kubernetes&amp;quot;: {
&amp;quot;usages&amp;quot;: [
&amp;quot;signing&amp;quot;,
&amp;quot;key encipherment&amp;quot;,
&amp;quot;server auth&amp;quot;,
&amp;quot;client auth&amp;quot;
],
&amp;quot;expiry&amp;quot;: &amp;quot;87600h&amp;quot;
}
}
}
}
&lt;/code>&lt;/pre>
&lt;p>知识点：&lt;/p>
&lt;ul>
&lt;li>&lt;code>config.json&lt;/code>：可以定义多个 &lt;code>profiles&lt;/code>，分别指定不同的过期时间、使用场景等参数；后续在签名证书时使用某个 &lt;code>profile&lt;/code>；此实例只有一个 kubernetes 模板。&lt;/li>
&lt;li>&lt;code>signing&lt;/code>：表示该证书可用于签名其它证书；生成的 ca.pem 证书中&lt;code>CA=TRUE&lt;/code>&lt;/li>
&lt;li>&lt;code>server auth&lt;/code>：表示 client 可以用该 CA 对 server 提供的证书进行验证；&lt;/li>
&lt;li>&lt;code>client auth&lt;/code>：表示 server 可以用该 CA 对 client 提供的证书进行验证；&lt;/li>
&lt;li>注意标点符号，最后一个字段一般是没有&lt;code>逗号&lt;/code>的。&lt;/li>
&lt;/ul>
&lt;p>初始化创建 CA 认证中心，将会生成&lt;code>ca-key.pem&lt;/code>（私钥）和&lt;code>ca.pem&lt;/code>（公钥）&lt;/p>
&lt;pre>&lt;code>cfssl gencert -initca ca-csr.json | cfssljson -bare ca
&lt;/code>&lt;/pre>
&lt;h3 id="创建-kubernetes-证书">创建 kubernetes 证书&lt;/h3>
&lt;p>创建&lt;code>kubernetes-csr.json&lt;/code>证书请求文件&lt;/p>
&lt;pre>&lt;code>{
&amp;quot;CN&amp;quot;: &amp;quot;kubernetes&amp;quot;,
&amp;quot;hosts&amp;quot;: [
&amp;quot;127.0.0.1&amp;quot;,
&amp;quot;10.1.20.129&amp;quot;,
&amp;quot;10.1.20.128&amp;quot;,
&amp;quot;10.1.20.126&amp;quot;,
&amp;quot;10.1.20.127&amp;quot;,
&amp;quot;10.254.0.1&amp;quot;,
&amp;quot;*.kubernetes.master&amp;quot;,
&amp;quot;localhost&amp;quot;,
&amp;quot;kubernetes&amp;quot;,
&amp;quot;kubernetes.default&amp;quot;,
&amp;quot;kubernetes.default.svc&amp;quot;,
&amp;quot;kubernetes.default.svc.cluster&amp;quot;,
&amp;quot;kubernetes.default.svc.cluster.local&amp;quot;
],
&amp;quot;key&amp;quot;: {
&amp;quot;algo&amp;quot;: &amp;quot;rsa&amp;quot;,
&amp;quot;size&amp;quot;: 2048
},
&amp;quot;names&amp;quot;: [
{
&amp;quot;C&amp;quot;: &amp;quot;CN&amp;quot;,
&amp;quot;ST&amp;quot;: &amp;quot;BeiJing&amp;quot;,
&amp;quot;L&amp;quot;: &amp;quot;BeiJing&amp;quot;,
&amp;quot;O&amp;quot;: &amp;quot;k8s&amp;quot;,
&amp;quot;OU&amp;quot;: &amp;quot;System&amp;quot;
}
]
}
&lt;/code>&lt;/pre>
&lt;p>&lt;strong>知识点&lt;/strong>：&lt;/p>
&lt;ul>
&lt;li>这个证书目前专属于 apiserver，加了一个 &lt;code>*.kubernetes.master&lt;/code>域名以便内部私有 DNS 解析使用(可删除)；至于很多人问过 kubernetes 这几个能不能删掉，答案是&lt;strong>不可以&lt;/strong>的；因为当集群创建好后，&lt;code>default namespace&lt;/code> 下会创建一个叫 &lt;code>kubenretes&lt;/code> 的&lt;code>svc&lt;/code>，有一些组件会直接连接这个 svc 来跟 api 通信的，证书如果不包含可能会出现无法连接的情况；其他几个 kubernetes 开头的域名作用相同&lt;/li>
&lt;li>&lt;code>hosts&lt;/code>包含的是授权范围，不在此范围的的节点或者服务使用此证书就会报证书不匹配错误。&lt;code>10.254.0.1&lt;/code>是指 kube-apiserver 指定的 service-cluster-ip-range 网段的第一个 IP。&lt;/li>
&lt;/ul>
&lt;p>生成 kubernetes 证书和私钥&lt;/p>
&lt;pre>&lt;code>cfssl gencert -ca=ca.pem -ca-key=ca-key.pem -config=ca-config.json -profile=kubernetes kubernetes-csr.json | cfssljson -bare kubernetes
&lt;/code>&lt;/pre>
&lt;p>&lt;strong>知识点&lt;/strong>：&lt;/p>
&lt;ul>
&lt;li>&lt;code>-config&lt;/code> 引用的是模板中的默认配置文件，&lt;/li>
&lt;li>&lt;code>-profiles&lt;/code>是指定特定的使用场景，比如 config.json 中的&lt;code>kubernetes&lt;/code>区域&lt;/li>
&lt;/ul>
&lt;h3 id="创建-admin-证书">创建 admin 证书&lt;/h3>
&lt;p>创建 admin 证书请求文件&lt;code>admin-csr.json&lt;/code>&lt;/p>
&lt;pre>&lt;code>{
&amp;quot;CN&amp;quot;: &amp;quot;admin&amp;quot;,
&amp;quot;hosts&amp;quot;: [],
&amp;quot;key&amp;quot;: {
&amp;quot;algo&amp;quot;: &amp;quot;rsa&amp;quot;,
&amp;quot;size&amp;quot;: 2048
},
&amp;quot;names&amp;quot;: [
{
&amp;quot;C&amp;quot;: &amp;quot;CN&amp;quot;,
&amp;quot;ST&amp;quot;: &amp;quot;BeiJing&amp;quot;,
&amp;quot;L&amp;quot;: &amp;quot;BeiJing&amp;quot;,
&amp;quot;O&amp;quot;: &amp;quot;system:masters&amp;quot;,
&amp;quot;OU&amp;quot;: &amp;quot;System&amp;quot;
}
]
}
&lt;/code>&lt;/pre>
&lt;p>生成 admin 证书和私钥&lt;/p>
&lt;pre>&lt;code>cfssl gencert -ca=ca.pem -ca-key=ca-key.pem -config=ca-config.json -profile=kubernetes admin-csr.json | cfssljson -bare admin
&lt;/code>&lt;/pre>
&lt;p>&lt;strong>知识点&lt;/strong>这个 admin 证书，是将来生成管理员用的&lt;code>kubeconfig&lt;/code> 配置文件用的，现在我们一般建议使用 RBAC 来对 kubernetes 进行角色权限控制， kubernetes 将证书中的 CN 字段作为 User， O 字段作为 Group
同样，我们也可以按照同样的方式来创建 kubernetes 中 etcd 集群的证书&lt;/p>
&lt;h3 id="创建-etcd-集群证书">创建 etcd 集群证书&lt;/h3>
&lt;ol>
&lt;li>证书签署请求文件&lt;code>ca-csr.json&lt;/code>&lt;/li>
&lt;/ol>
&lt;!-- raw HTML omitted -->
&lt;pre>&lt;code>{
&amp;quot;CN&amp;quot;: &amp;quot;etcd CA&amp;quot;,
&amp;quot;key&amp;quot;: {
&amp;quot;algo&amp;quot;: &amp;quot;rsa&amp;quot;,
&amp;quot;size&amp;quot;: 2048
},
&amp;quot;names&amp;quot;: [
{
&amp;quot;C&amp;quot;: &amp;quot;CN&amp;quot;,
&amp;quot;L&amp;quot;: &amp;quot;Beijing&amp;quot;,
&amp;quot;ST&amp;quot;: &amp;quot;Beijing&amp;quot;
}
]
}
&lt;/code>&lt;/pre>
&lt;ol start="2">
&lt;li>为节点创建服务证书请求文件，指定授权的主机节点&lt;code>etcd-server-csr.json&lt;/code>&lt;/li>
&lt;/ol>
&lt;!-- raw HTML omitted -->
&lt;pre>&lt;code>{
&amp;quot;CN&amp;quot;: &amp;quot;etcd&amp;quot;,
&amp;quot;hosts&amp;quot;: [
&amp;quot;10.1.20.129&amp;quot;,
&amp;quot;10.1.20.126&amp;quot;,
&amp;quot;10.1.20.128&amp;quot;
],
&amp;quot;key&amp;quot;: {
&amp;quot;algo&amp;quot;: &amp;quot;rsa&amp;quot;,
&amp;quot;size&amp;quot;: 2048
},
&amp;quot;names&amp;quot;: [
{
&amp;quot;C&amp;quot;: &amp;quot;CN&amp;quot;,
&amp;quot;L&amp;quot;: &amp;quot;BeiJing&amp;quot;,
&amp;quot;ST&amp;quot;: &amp;quot;BeiJing&amp;quot;
}
]
}
&lt;/code>&lt;/pre>
&lt;ol start="3">
&lt;li>证书配置模板文件&lt;code>ca-config.json&lt;/code>&lt;/li>
&lt;/ol>
&lt;!-- raw HTML omitted -->
&lt;pre>&lt;code>{
&amp;quot;signing&amp;quot;: {
&amp;quot;default&amp;quot;: {
&amp;quot;expiry&amp;quot;: &amp;quot;87600h&amp;quot;
},
&amp;quot;profiles&amp;quot;: {
&amp;quot;etcd&amp;quot;: {
&amp;quot;expiry&amp;quot;: &amp;quot;87600h&amp;quot;,
&amp;quot;usages&amp;quot;: [
&amp;quot;signing&amp;quot;,
&amp;quot;key encipherment&amp;quot;,
&amp;quot;server auth&amp;quot;,
&amp;quot;client auth&amp;quot;
]
}
}
}
}
&lt;/code>&lt;/pre>
&lt;ol start="5">
&lt;li>生成 etcd 集群所需的证书与私钥&lt;/li>
&lt;/ol>
&lt;!-- raw HTML omitted -->
&lt;pre>&lt;code>cfssl gencert -initca ca-csr.json | cfssljson -bare ca -
cfssl gencert -ca=ca.pem -ca-key=ca-key.pem -config=ca-config.json -profile=etcd etcd-server-csr.json | cfssljson -bare server
&lt;/code>&lt;/pre>
&lt;p>这样就完成 etcd 所需证书的申请，同时了解了 cfssl 工具的强大，写到这里，本次的实验就结束了。&lt;/p></description></item><item><title>Docs: Cryptography(密码学)</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/7.%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8/cryptography%E5%AF%86%E7%A0%81%E5%AD%A6/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/7.%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8/cryptography%E5%AF%86%E7%A0%81%E5%AD%A6/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Cryptography">Wiki,Cryptography&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;h1 id="密码学背景">密码学背景&lt;/h1>
&lt;p>在现代时代之前，密码学着眼于消息的机密性（即加密），即将消息从一种可理解的形式转换为一种难以理解的形式，然后又在另一端再次转换，从而使拦截器或窃听者在没有秘密知识（即所需的密钥）的情况下无法读取该消息。用于解密该消息）。加密试图确保保密的通信，如那些间谍，军事领导人和外交官。在最近的几十年中，该领域已经超出了对机密性的关注范围，包括消息完整性检查，发送者/接收者身份验证，数字签名，交互式证明和安全计算等。&lt;/p>
&lt;h2 id="经典密码学">经典密码学&lt;/h2>
&lt;h2 id="现代密码学">现代密码学&lt;/h2>
&lt;p>现在我们谈论的密码学，都是现代密码学的范畴&lt;/p>
&lt;p>Public-key cryptography(公开密钥加密、非对称密钥加密)，以及根据公开密钥加密方式而衍生出的其他认证授权等基础设施，是当代最常见，也是最常用的方式.&lt;/p>
&lt;h1 id="现代加密方式">现代加密方式&lt;/h1>
&lt;h2 id="symmetric-key-algorithm对称密钥算法">Symmetric Key Algorithm(对称密钥算法)&lt;/h2>
&lt;blockquote>
&lt;p>参考： &lt;a href="https://en.wikipedia.org/wiki/Symmetric-key_algorithm">Wiki-Symmetir Key Algorithm&lt;/a>&lt;/p>
&lt;/blockquote>
&lt;p>使用相同的密钥来加密明文和解密密文&lt;/p>
&lt;p>算法：&lt;/p>
&lt;ol>
&lt;li>DES：Data Encryption Standard 数据加密标准。已被破解&lt;/li>
&lt;li>3DES：3 倍的 DES。最常用&lt;/li>
&lt;li>AES：Advanced Encryption Standard 高级加密标准。最常用&lt;/li>
&lt;li>Blowfish&lt;/li>
&lt;li>Twofish&lt;/li>
&lt;li>IDEA：商业加密算法&lt;/li>
&lt;/ol>
&lt;h3 id="ska-特点">SKA 特点&lt;/h3>
&lt;p>特性：&lt;/p>
&lt;ul>
&lt;li>加密和解密使用同一个密钥，效率高。&lt;/li>
&lt;li>将原始数据分割成固定大小的块，逐个进行加密；&lt;/li>
&lt;/ul>
&lt;p>缺点：&lt;/p>
&lt;ul>
&lt;li>密钥过多；&lt;/li>
&lt;li>密钥分发(分发密钥过程无法保证),为了解决对称加密算法每个人需要保存密钥过多的问题，可以使用公钥加密&lt;/li>
&lt;li>数据来源无法确认&lt;/li>
&lt;/ul>
&lt;h2 id="public-key-cryptography公开密钥密码学">Public Key Cryptography(公开密钥密码学)&lt;/h2>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Public-key_cryptography">Wiki,PKC 英文&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Digital_signature">Wiki,数字签名&lt;/a>&lt;/li>
&lt;li>&lt;a href="http://www.ruanyifeng.com/blog/2013/06/rsa_algorithm_part_one.html">阮一峰&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.zhihu.com/question/25912483">知乎,RSA 的公钥和私钥到底那个才是用来加密和哪个用来解密&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://zh.wikipedia.org/wiki/%E5%85%AC%E5%BC%80%E5%AF%86%E9%92%A5%E5%8A%A0%E5%AF%86">Wiki, 公开密钥加密 中文&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>**Public Key Cryptography(公开密钥密码学) &lt;strong>也称为&lt;/strong> Asymmetric Key Algorithm(非对称密钥算法)，**它是计算机通信安全的基石，保证了加密数据不会被破解。1976 年以前，所有的加密方法都是同一种模式：&lt;/p>
&lt;ul>
&lt;li>甲方选择某种加密规则，对信息进行加密&lt;/li>
&lt;li>乙方使用同一种规则，对信息进行解密&lt;/li>
&lt;/ul>
&lt;p>由于加密和解密使用同样规则（简称&amp;quot;密钥&amp;quot;），这被称为 Symmetric-key algorithm(对称密钥算法)。这种加密模式有一个最大弱点：甲方必须把加密规则告诉乙方，否则无法解密。保存和传递密钥，就成了最头疼的问题。因为大多数情况下，其实两方之间的通信，只有一方是需要加密的，另一方只需要知道信息内容。&lt;/p>
&lt;p>1976 年，两位美国计算机学家 Whitfield Diffie 和 Martin Hellman，提出了一种崭新构思，可以在不直接传递密钥的情况下，完成解密。这被称为&amp;quot;Diffie-Hellman 密钥交换算法&amp;quot;。这个算法启发了其他科学家。人们认识到，加密和解密可以使用不同的规则，只要这两种规则之间存在某种对应关系即可，这样就避免了直接传递密钥。&lt;/p>
&lt;p>这种新的加密模式就被称为&amp;quot;非对称密钥算法&amp;quot;。&lt;/p>
&lt;blockquote>
&lt;p>（1）乙方生成两把密钥（公钥和私钥）。公钥是公开的，任何人都可以获得，私钥则是保密的。
（2）甲方获取乙方的公钥，然后用它对信息加密。
（3）乙方得到加密后的信息，用私钥解密。&lt;/p>
&lt;/blockquote>
&lt;p>如果公钥加密的信息只有私钥解得开，那么只要私钥不泄漏，通信就是安全的。&lt;/p>
&lt;p>1977 年，三位数学家 Rivest、Shamir 和 Adleman 设计了一种算法，可以实现非对称加密。这种算法用他们三个人的名字命名，叫做 RSA 算法。从那时直到现在，RSA 算法一直是最广为使用的&amp;quot;非对称加密算法&amp;quot;。毫不夸张地说，只要有计算机网络的地方，就有 RSA 算法。&lt;/p>
&lt;p>这种算法非常可靠，密钥越长，它就越难破解。根据已经披露的文献，目前被破解的最长 RSA 密钥是 768 个二进制位。也就是说，长度超过 768 位的密钥，还无法破解（至少没人公开宣布）。因此可以认为，1024 位的 RSA 密钥基本安全，2048 位的密钥极其安全。&lt;/p>
&lt;h3 id="pkc-特点">PKC 特点&lt;/h3>
&lt;ul>
&lt;li>这种加密方式，需要一对密钥。只有公钥可以加密，私钥不能用来加密数据。&lt;/li>
&lt;li>&lt;strong>Public key(公钥)&lt;/strong> # 公开给所有人。用来加密数据、验证签名。使用公钥把明文加密后所得的密文，只能使用对应的私钥才能解密并得到原本的密文。反之不行。&lt;/li>
&lt;li>&lt;strong>Secret key(私钥)&lt;/strong> # 自己留存，必须保证其私密性。用来解密数据、签名。使用私钥创建数字签名，只能使用公钥才能验证该数字签名的有效性。反之不行。
&lt;ul>
&lt;li>一般情况，密钥对是通过程序自动生成的。首先生成私钥后，公钥包含在私钥当中&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>Digital signature(数字签名)&lt;/strong>。签名提供的是真实性，而不是保密性。
&lt;ul>
&lt;li>所谓的数字签名，就像人们日常生活中在文件上签字一样，都是签名的一种。&lt;/li>
&lt;li>而所谓的验证签名，其实就像日常生活中，看看签名的人的笔记与签名是否一致，等等类似的行为&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>总结一下：既然是加密，那肯定是不希望别人知道发送给我的消息，所以只有我才能解密，所以可得出&lt;strong>公钥负责加密，私钥负责解密&lt;/strong>；同理，既然是签名，那肯定是不希望有人冒充我发消息，只有我才能发布这个签名，所以可得出&lt;strong>私钥负责签名，公钥负责验证&lt;/strong>。&lt;/p>
&lt;ul>
&lt;li>这种加密方式由于是单向加密、单向解密，所以如果双方都想要加密，则需要两对密钥，双方各自用对方的公钥加密信息发送给对方，然后双方再用自己的私钥解密阅读信息。&lt;/li>
&lt;/ul>
&lt;h3 id="应用场景">应用场景&lt;/h3>
&lt;ul>
&lt;li>如果 A 持有私钥，B 持有对应公钥。那么此时 B 用对方的公钥加密一个对称密钥并发送给 A，A 使用私钥解密，以获得 B 发送的对称密钥，这时再发送的数据可以使用对称加密。&lt;/li>
&lt;li>在互联网的 C/S 架构场景中。Server 公开公钥，Client 使用公钥加密信息发送给 Server(发送密码等敏感信息)，Server 使用私钥解密后响应时，使用私钥签名，以便 Client 可以用公钥验证 Server 的真实性(防止钓鱼网站)。&lt;/li>
&lt;li>如图所示，Alice 在一条消息的末尾签了名，消息内容是 &lt;code>Hello Bob!&lt;/code>，这段签署的内容一般是对消息内容进行 hash 计算后，使用 Alice 的私钥的出来的。鲍勃同时收到消息和签名。他使用 Alice 的公钥来验证消息的真实性，即，如果使用公钥计算得出来的消息与原始消息完全匹配，那就证明，这条消息确实是 Alice 发送的。&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/as985c/1616125981836-028fe2ce-77f2-4929-91cc-559c4ce9cda1.png" alt="">&lt;/p>
&lt;p>算法：&lt;/p>
&lt;ol>
&lt;li>RSA&lt;/li>
&lt;li>DSA&lt;/li>
&lt;li>ELGamal&lt;/li>
&lt;/ol>
&lt;p>缺点&lt;/p>
&lt;ol>
&lt;li>公钥加密可能出现的问题：当两者需要通信的时候，需要把公钥发送给对方，但是公钥是谁都可以获取的，那么在二者通信过程中，公钥就有可能被劫持，当公钥被劫持，劫持者把自己的公钥再发送给对方，那么双发再收到的信息，就是被劫持者篡改过的信息了。
&lt;ol>
&lt;li>&lt;a href="https://www.yuque.com/go/doc/33177961">&lt;strong>Public Key Certificate(公钥证书)&lt;/strong>&lt;/a> 可以解决以上问题&lt;/li>
&lt;/ol>
&lt;/li>
&lt;/ol>
&lt;h2 id="cryptographic-hash-function单向加密加密散列函数">Cryptographic hash function(单向加密、加密散列函数)&lt;/h2>
&lt;p>只能加密，不能解密，提取数据特征码，用来保证数据的完成性，实现数据的完整性校验&lt;/p>
&lt;p>通常用来做数字证书的数字签名，提取数据的特征码后进行加密并放到数据后端，用来校验证书的完整性，所以证书的内容是被认可的&lt;/p>
&lt;p>特点：定长输出、雪崩效应(原始数据的微小改变会导致计算结果的完全不同)&lt;/p>
&lt;p>算法：&lt;/p>
&lt;ol>
&lt;li>md5&lt;/li>
&lt;li>sha1&lt;/li>
&lt;li>sha256&lt;/li>
&lt;li>sha384&lt;/li>
&lt;li>sha512&amp;hellip;.等&lt;/li>
&lt;/ol>
&lt;p>MAC:Message Authentication Code(消息认证码)，单向加密的一种延伸应用，用于实现在网络通信中保证所传输的数据的完整性&lt;/p></description></item><item><title>Docs: Hacking</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/7.%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8/hacking/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/7.%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8/hacking/</guid><description>
&lt;h1 id="名词解释">名词解释&lt;/h1>
&lt;p>补充一个小知识点，软件漏洞在英文里不是 Hole——孔洞，而是 &lt;strong>Vulnerability(脆弱性)&lt;/strong>，因为软件里的漏洞往往不会是一个明晃晃的“洞”，而是一个不起眼的“脆弱性”。&lt;/p>
&lt;p>&lt;strong>Robo Hacking Game(机器人网络安全大赛，简称 RHG)&lt;/strong> 是中国版的 CGC 大赛。&lt;/p>
&lt;p>&lt;strong>Cyber Grand Challenge(网络空间超级挑战赛，简称 CGC)&lt;/strong> 是 **Defense Advanced Research Projects Agency(国防高级研究计划局，简称 DARPA) **举办的比赛。&lt;/p>
&lt;h2 id="安全公司">安全公司&lt;/h2>
&lt;p>深信服
360
永信至诚&lt;/p></description></item><item><title>Docs: OpenSSL</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/7.%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8/%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/openssl/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/7.%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8/%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/openssl/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://www.openssl.org/">官网&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://github.com/openssl/openssl">GitHub 项目,openssl/openssl&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>OpenSSL 是一个商业级且功能齐全的工具包，用于通用密码学和安全通信&lt;/p>
&lt;p>OpenSSL 可以实现 &lt;strong>TLS(传输层安全性)&lt;/strong> 和 &lt;strong>SSL(安全套接字层)&lt;/strong> 协议的预期功能，类似于 OpenSSH 是 ssh 协议的实现&lt;/p>
&lt;p>OpenSSL 主要包含两组东西：&lt;/p>
&lt;ul>
&lt;li>openssl # 多用途的命令行工具&lt;/li>
&lt;li>libraries # OpenSSL 库
&lt;ul>
&lt;li>libcrypto # 加密解密库&lt;/li>
&lt;li>libssl # ssl 库，实现了 ssl 及 tls 的功能&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h1 id="openssl-关联文件">OpenSSL 关联文件&lt;/h1>
&lt;p>&lt;strong>/etc/ssl/openssl.conf&lt;/strong> # OpenSSL 的“命令行工具”和 “库”默认使用的配置文件。&lt;/p>
&lt;p>如果想要使用 CA 功能，需要进行如下配置&lt;/p>
&lt;ul>
&lt;li>touch /etc/pki/CA/index.txt&lt;/li>
&lt;li>echo 01 &amp;gt; /etc/pki/CA/serial&lt;/li>
&lt;/ul>
&lt;h1 id="openssl-命令行工具">openssl 命令行工具&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://www.openssl.org/docs/manmaster/man1/openssl.html">Manual(手册),openssl&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>openssl 程序提供了丰富的子命令，以实现 TLS/SSL 网络协议以及它们所需要的相关加密标准。&lt;/p>
&lt;h2 id="syntax语法">Syntax(语法)&lt;/h2>
&lt;p>&lt;strong>openssl Command [ OPTIONS ] [ ARGUMENTS ]&lt;/strong>&lt;/p>
&lt;h3 id="command">Command&lt;/h3>
&lt;ul>
&lt;li>Standard commands # 标准命令
&lt;ul>
&lt;li>asn1parse，ca，ciphers，cms，crl，crl2pkcs7，dgst，dh，dhparam，dsa，dsaparam，ec，ecparam，enc，engine，errstr，gendh，gendsa，genpkey，genrsa，nseq，ocsp，passwd，pkcs12，pkcs7，pkcs8，pkey，pkeyparam，pkeyutl，prime，rand，req，rsa，rsautl，s_client，s_server，s_time，sess_id，smime，speed，spkac，ts，verify，version，x509&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Message Digest commands #消息摘要命令，消息摘要算法的实现(用于单向加密)。使用 dgst 命令
&lt;ul>
&lt;li>md2，md4，md5，rmd160，sha，sha1&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Cipher commands #密码命令（其中都是各种加密算法，用于对称加密）。使用 enc 命令
&lt;ul>
&lt;li>aes-128-cbc，aes-128-ecb，aes-192-cbc，aes-192-ecb，aes-256-cbc，aes-256-ecb，base64，bf，bf-cbc，bf-cfb，bf-ecb，bf-ofb，camellia-128-cbc，camellia-128-ecb，camellia-192-cbc，camellia-192-ecb，camellia-256-cbc，camellia-256-ecb，cast，cast-cbc，cast5-cbc，cast5-cfb，cast5-ecb，cast5-ofb，des，des-cbc，des-cfb，des-ecb，des-ede，des-ede-cbc，des-ede-cfb，des-ede-ofb，des-ede3，des-ede3-cbc，des-ede3-cfb，des-ede3-ofb，des-ofb，des3，desx，idea，idea-cbc，idea-cfb，idea-ecb，idea-ofb，rc2，rc2-40-cbc，rc2-64-cbc，rc2-cbc，rc2-cfb，rc2-ecb，rc2-ofb，rc4，rc4-40，rc5，rc5-cbc，rc5-cfb，rc5-ecb，rc5-ofb，seed，seed-cbc，seed-cfb，seed-ecb，seed-ofb，zlib&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h3 id="global-options">Global OPTIONS&lt;/h3>
&lt;ul>
&lt;li>-in FILE # 指明使用的文件&lt;/li>
&lt;li>-out FILE # 指明输出的文件&lt;/li>
&lt;/ul>
&lt;h2 id="standard-commands-标准命令">Standard commands #标准命令&lt;/h2>
&lt;p>[Standard commands(标准命令)](✏IT 学习笔记/🔐7.信息安全/管理工具/OpenSSL/Standard%20commands(标准命令).md commands(标准命令).md)&lt;/p>
&lt;h2 id="message-digest-commands--消息摘要命令">Message Digest commands # 消息摘要命令&lt;/h2>
&lt;p>消息摘要算法的实现(用于单向加密)。使用 dgst 命令&lt;/p>
&lt;h2 id="cipher-commands--密码命令">Cipher commands # 密码命令&lt;/h2>
&lt;p>其中都是各种加密算法，用于对称加密。使用 enc 命令&lt;/p>
&lt;h3 id="openssl-enc--对称密钥程序用于创建管理对称密钥">openssl enc # 对称密钥程序，用于创建管理对称密钥&lt;/h3>
&lt;p>OPTIONS&lt;/p>
&lt;ul>
&lt;li>&lt;strong>-e&lt;/strong> # 加密文件&lt;/li>
&lt;li>&lt;strong>-d&lt;/strong> # 解密文件&lt;/li>
&lt;li>&lt;strong>-des3&lt;/strong> # 使用 des3 算法进行加密或解密&lt;/li>
&lt;li>&lt;strong>-a&lt;/strong> # 基于文本进行编码&lt;/li>
&lt;li>&lt;strong>-salt&lt;/strong> # 加入一些盐&lt;/li>
&lt;/ul>
&lt;p>EXAMPLE&lt;/p>
&lt;ul>
&lt;li>openssl enc -e -des3 -a -salt -in fstab -out fstab.ciphertext # 加密 fstab 文件为 fstab.ciphertext，算法为 des3，基于文本进行编码，加入一些 salt&lt;/li>
&lt;li>openssl enc -d -des3 -a -salt -in fstab.ciphertext -out fstab # 解密 fstab.ciphertext 为 fstab 文件&lt;/li>
&lt;/ul>
&lt;h1 id="应用实例">应用实例：&lt;/h1>
&lt;h2 id="创建自签-ca-证书">创建自签 ca 证书&lt;/h2>
&lt;ul>
&lt;li>(umask 077; openssl genrsa -out ca.key 2048)&lt;/li>
&lt;li>openssl req -new -x509 -key ca.key -days 3650 -out ca.crt&lt;/li>
&lt;/ul>
&lt;h2 id="在-kubernetes-中生成个人证书">在 kubernetes 中生成个人证书&lt;/h2>
&lt;ul>
&lt;li>在当前目录下生成一个 2048 位的名为 lch.key 的私钥（括号的作用是创建子 shell 执行命令，这样 umask 命令对当前 shell 没影响）
&lt;ul>
&lt;li>(umask 077;openssl genrsa -out lch.key 2048)&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>使用 lck.key 进行证书申请
&lt;ul>
&lt;li>openssl req -new -key lch.key -out lch.csr -subj &amp;ldquo;/CN=lch&amp;rdquo;&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>使用 ca.key 来给 lch.crt 颁发证书，以生成 lch.crt 文件
&lt;ul>
&lt;li>openssl x509 -req -in lch.csr -CA ca.crt -CAkey ca.key -CAcreateserial -out lch.crt -days 365&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>查看 ca.crt 证书的信息
&lt;ul>
&lt;li>openssl x509 -in lch.crt -text -noout&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>openssl x509 部分命令&lt;/p>
&lt;p>打印出证书的内容：&lt;/p>
&lt;p>openssl x509 -in cert.pem -noout -text&lt;/p>
&lt;p>打印出证书的系列号&lt;/p>
&lt;p>openssl x509 -in cert.pem -noout -serial&lt;/p>
&lt;p>打印出证书的拥有者名字&lt;/p>
&lt;p>openssl x509 -in cert.pem -noout -subject&lt;/p>
&lt;p>以 RFC2253 规定的格式打印出证书的拥有者名字&lt;/p>
&lt;p>openssl x509 -in cert.pem -noout -subject -nameopt RFC2253&lt;/p>
&lt;p>在支持 UTF8 的终端一行过打印出证书的拥有者名字&lt;/p>
&lt;p>openssl x509 -in cert.pem -noout -subject -nameopt oneline -nameopt -escmsb&lt;/p>
&lt;p>打印出证书的 MD5 特征参数&lt;/p>
&lt;p>openssl x509 -in cert.pem -noout -fingerprint&lt;/p>
&lt;p>打印出证书的 SHA 特征参数&lt;/p>
&lt;p>openssl x509 -sha1 -in cert.pem -noout -fingerprint&lt;/p>
&lt;p>把 PEM 格式的证书转化成 DER 格式&lt;/p>
&lt;p>openssl x509 -in cert.pem -inform PEM -out cert.der -outform DER&lt;/p>
&lt;p>把一个证书转化成 CSR&lt;/p>
&lt;p>openssl x509 -x509toreq -in cert.pem -out req.pem -signkey key.pem&lt;/p>
&lt;p>给一个 CSR 进行处理，颁发字签名证书，增加 CA 扩展项&lt;/p>
&lt;p>openssl x509 -req -in careq.pem -extfile openssl.cnf -extensions v3_ca -signkey key.pem -out cacert.pem&lt;/p>
&lt;p>给一个 CSR 签名，增加用户证书扩展项&lt;/p>
&lt;p>openssl x509 -req -in req.pem -extfile openssl.cnf -extensions v3_usr -CA cacert.pem -CAkey key.pem -CAcreateserial&lt;/p>
&lt;p>查看 csr 文件细节：&lt;/p>
&lt;p>openssl req -in my.csr -noout -text&lt;/p></description></item><item><title>Docs: OpenSSL 配置详解</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/7.%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8/%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/openssl/openssl-%E9%85%8D%E7%BD%AE%E8%AF%A6%E8%A7%A3/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/7.%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8/%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/openssl/openssl-%E9%85%8D%E7%BD%AE%E8%AF%A6%E8%A7%A3/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://www.openssl.org/docs/manmaster/man5/config.html">Manual(手册),config(5)&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.openssl.org/docs/manmaster/man5/x509v3_config.html">Manual(手册),x509v3_config(5)&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.openssl.org/docs/man3.0/man1/openssl-req.html">Manual(),openssl-req(1)&lt;/a>-CONFIGURATION FILE FORMAT 部分&lt;/li>
&lt;li>&lt;a href="https://www.cnblogs.com/f-ck-need-u/p/6091027.html">https://www.cnblogs.com/f-ck-need-u/p/6091027.html&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>OpenSSL 配置文件为 OpenSSL 库及其二进制程序提供运行时参数。这是一个 &lt;a href="https://desistdaydream.github.io/docs/IT%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/2.%E7%BC%96%E7%A8%8B/%E6%97%A0%E6%B3%95%E5%88%86%E7%B1%BB%E7%9A%84%E8%AF%AD%E8%A8%80/INI.md">INI&lt;/a> 格式的配置文件。&lt;/p>
&lt;p>配置文件一共有三类格式：&lt;/p>
&lt;ul>
&lt;li>config # OpenSSL 通用配置格式&lt;/li>
&lt;li>fips_config # OpenSSL FIPS 配置格式&lt;/li>
&lt;li>x509v3_config # X.509 V3 证书扩展配置格式&lt;/li>
&lt;/ul>
&lt;p>OpenSSL 配置文件为 INI 格式的配置扩展了很多功能，并规定了一些新的规则：&lt;/p>
&lt;ul>
&lt;li>Section 中除了 &lt;strong>key/value pair(键值对)&lt;/strong> 以外，还可以包括 &lt;strong>Directives(指令)&lt;/strong>&lt;/li>
&lt;li>Section 中的 &lt;strong>Key/Value Pair 可以进行变量定义&lt;/strong>，也可以引用变量。此时 Key 就是变量名，Value 就是变量的值。
&lt;ul>
&lt;li>引用方式有 &lt;code>$VAR&lt;/code> 或 &lt;code>${VAR}&lt;/code> 两种，要想引用其他 Section 中的变量，则使用 &lt;code>$SectionName::VAR&lt;/code> 或 &lt;code>${SectionName::VAR}&lt;/code>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e"># 这是默认 Section&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> HOME &lt;span style="color:#f92672">=&lt;/span> /temp
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> configdir &lt;span style="color:#f92672">=&lt;/span> $ENV::HOME/config
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">[&lt;/span> section_one &lt;span style="color:#f92672">]&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e"># Quotes permit leading and trailing whitespace&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> any &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#34; any variable name &amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> other &lt;span style="color:#f92672">=&lt;/span> A string that can &lt;span style="color:#ae81ff">\
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">&lt;/span> cover several lines &lt;span style="color:#ae81ff">\
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">&lt;/span> by including &lt;span style="color:#ae81ff">\\&lt;/span> characters
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> message &lt;span style="color:#f92672">=&lt;/span> Hello World&lt;span style="color:#ae81ff">\n&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">[&lt;/span> section_two &lt;span style="color:#f92672">]&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> greeting &lt;span style="color:#f92672">=&lt;/span> $section_one::message
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ul>
&lt;li>配置文件中的第一部分是一个 &lt;code>默认&lt;/code> Section。若要引用默认 Section 的变量，则使用 &lt;code>ENV&lt;/code> 作为 Section 名&lt;/li>
&lt;li>可以在 Section 中引用其他 Section。比如：&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e"># These must be in the default section&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> config_diagnostics &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e"># 引用 openssl_init 部分的配置&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> openssl_conf &lt;span style="color:#f92672">=&lt;/span> openssl_init
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">[&lt;/span>openssl_init&lt;span style="color:#f92672">]&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e"># 引用 oids 部分的配置&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> oid_section &lt;span style="color:#f92672">=&lt;/span> oids
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e"># 以此类推&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> providers &lt;span style="color:#f92672">=&lt;/span> providers
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> alg_section &lt;span style="color:#f92672">=&lt;/span> evp_properties
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ssl_conf &lt;span style="color:#f92672">=&lt;/span> ssl_configuration
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> engines &lt;span style="color:#f92672">=&lt;/span> engines
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> random &lt;span style="color:#f92672">=&lt;/span> random
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">[&lt;/span>oids&lt;span style="color:#f92672">]&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ... new oids here ...
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">[&lt;/span>providers&lt;span style="color:#f92672">]&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ... provider stuff here ...
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">[&lt;/span>evp_properties&lt;span style="color:#f92672">]&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ... EVP properties here ...
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">[&lt;/span>ssl_configuration&lt;span style="color:#f92672">]&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ... SSL/TLS configuration properties here ...
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">[&lt;/span>engines&lt;span style="color:#f92672">]&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ... engine properties here ...
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">[&lt;/span>random&lt;span style="color:#f92672">]&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ... random properties here ...
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ul>
&lt;li>&lt;strong>特定的 Section 的名字是有意义的&lt;/strong>，比如 &lt;code>[req]&lt;/code> Section 可以为 &lt;code>openssl req&lt;/code> 命令提供参数，当执行 &lt;code>openssl req&lt;/code> 命令时，会从默认配置文件的 &lt;code>[req]&lt;/code> Section 获取配置参数，若没有，则再从 &lt;code>默认&lt;/code> Section 获取参数&lt;/li>
&lt;/ul>
&lt;h1 id="默认">[默认]&lt;/h1>
&lt;h1 id="req">[req]&lt;/h1>
&lt;p>&lt;strong>distinguished_name = &lt;!-- raw HTML omitted -->&lt;/strong> # 生成证书或 CSR 时，如何配置 DN(专有名称)。
&lt;strong>req_extensions = &lt;!-- raw HTML omitted -->&lt;/strong> # 要添加到 CSR 的扩展信息。&lt;/p>
&lt;h2 id="distinguished_name">[Distinguished_Name]&lt;/h2>
&lt;h2 id="req_extensions-">[Req_Extensions ]&lt;/h2>
&lt;blockquote>
&lt;p>关于 CSR 的扩展信息的格式，详见 &lt;a href="https://www.openssl.org/docs/manmaster/man5/x509v3_config.html">Manual(手册),x509v3_config(5)&lt;/a>&lt;/p>
&lt;/blockquote>
&lt;p>&lt;strong>basicConstraints = CA:FALSE&lt;/strong> #
&lt;strong>keyUsage = nonRepudiation, digitalSignature, keyEncipherment&lt;/strong> #
&lt;strong>extendedKeyUsage = clientAuth, serverAuth&lt;/strong> #
**subjectAltName = &lt;!-- raw HTML omitted --> **#&lt;/p>
&lt;h3 id="subjectaltname">[SubjectAltName]&lt;/h3>
&lt;p>DNS.1 = abc
IP.1 = 1.1.1.1&lt;/p>
&lt;h1 id="默认配置文件详解">默认配置文件详解&lt;/h1>
&lt;p>默认的配置路径在 /etc/pki/tls/openssl.cnf，该文件主要设置了 CSR、签名、crl 相关的配置。为 &lt;code>ca&lt;/code>、&lt;code>req&lt;/code> 子命令提供信息。&lt;/p>
&lt;p>该文件默认自带 4 个 Section：默认、ca、req、tsa&lt;/p>
&lt;h2 id="默认-section">默认 Section&lt;/h2>
&lt;h2 id="ca-section">ca Section&lt;/h2>
&lt;p>[ ca ]
default&lt;em>ca = CA_default /_The default ca section&lt;/em>/
####################################################################
[ CA&lt;em>default ]
dir = /etc/pki/CA /&lt;/em> Where everything is kept &lt;em>/
/&lt;/em> #### 这是第一个 openssl 目录结构中的目录 &lt;em>/
certs = $dir/certs /&lt;/em> Where the issued certs are kept(已颁发的证书路径，即 CA 或自签的) &lt;em>/
/&lt;/em> #### 这是第二个 openssl 目录结构中的目录，但非必须 &lt;em>/
crl_dir = $dir/crl /&lt;/em> Where the issued crl are kept(已颁发的 crl 存放目录) &lt;em>/
/&lt;/em> #### 这是第三个 openssl 目录结构中的目录*/
database = $dir/index.txt /* database index file &lt;em>/
#unique_subject = no /&lt;/em> 设置为 yes 则 database 文件中的 subject 列不能出现重复值 &lt;em>/
/&lt;/em> 即不能为 subject 相同的证书或证书请求签名*/
/* 建议设置为 no，但为了保持老版本的兼容性默认是 yes &lt;em>/
new_certs_dir = $dir/newcerts /&lt;/em> default place for new certs(将来颁发的证书存放路径) &lt;em>/
/&lt;/em> #### 这是第四个 openssl 目录结构中的目录 &lt;em>/
certificate = $dir/cacert.pem /&lt;/em> The A certificate(CA 自己的证书文件) &lt;em>/
serial = $dir/serial /&lt;/em> The current serial number(提供序列号的文件)&lt;em>/
crlnumber = $dir/crlnumber /&lt;/em> the current crl number(当前 crl 序列号) &lt;em>/
crl = $dir/crl.pem /&lt;/em> The current CRL(当前 CRL) &lt;em>/
private_key = $dir/private/cakey.pem /&lt;/em> The private key(签名时需要的私钥，即 CA 自己的私钥) &lt;em>/
RANDFILE = $dir/private/.rand /&lt;/em> private random number file(提供随机数种子的文件) &lt;em>/
x509_extensions = usr_cert /&lt;/em> The extentions to add to the cert(添加到证书中的扩展项) &lt;em>/
/&lt;/em> 以下两行是关于证书展示格式的，虽非必须项，但推荐设置。一般就如下格式不用修改 &lt;em>/
name_opt = ca_default /&lt;/em> Subject Name options*/
cert_opt = ca_default /* Certificate field options &lt;em>/
/&lt;/em> 以下是 copy&lt;em>extensions 扩展项，需谨慎使用 &lt;em>/
# copy&lt;/em>extensions = copy /&lt;/em> 生成证书时扩展项的 copy 行为，可设置为 none/copy/copyall &lt;em>/
/&lt;/em> 不设置该 name 时默认为 none &lt;em>/
/&lt;/em> 建议简单使用时设置为 none 或不设置，且强烈建议不要设置为 copyall &lt;em>/
# crl_extensions = crl_ext
default_days = 365 /&lt;/em> how long to certify for(默认的证书有效期) &lt;em>/
default_crl_days= 30 /&lt;/em> how long before next CRL(CRL 的有效期) &lt;em>/
default_md = default /&lt;/em> use public key default MD(默认摘要算法) &lt;em>/
preserve = no /&lt;/em> keep passed DN ordering(Distinguished Name 顺序，一般设置为 no &lt;em>/
/&lt;/em> 设置为 yes 仅为了和老版本的 IE 兼容)&lt;em>/
policy = policy_match /&lt;/em> 证书匹配策略,此处表示引用[ policy&lt;em>match ]的策略 &lt;em>/
/_ 证书匹配策略定义了证书请求的 DN 字段(field)被 CA 签署时和 CA 证书的匹配规则 &lt;em>/
/&lt;/em> 对于 CA 证书请求，这些匹配规则必须要和父 CA 完全相同 _/
[ policy&lt;/em>match ]
countryName = match /&lt;/em> match 表示请求中填写的该字段信息要和 CA 证书中的匹配 &lt;em>/
stateOrProvinceName = match
organizationName = match
organizationalUnitName = optional /&lt;/em> optional 表示该字段信息可提供可不提供 &lt;em>/
commonName = supplied /&lt;/em> supplied 表示该字段信息必须提供 &lt;em>/
emailAddress = optional
/&lt;/em> For the &amp;lsquo;anything&amp;rsquo; policy*/
/* At this point in time, you must list all acceptable &amp;lsquo;object&amp;rsquo; types. &lt;em>/
/&lt;/em> 以下是没被引用的策略扩展，只要是没被引用的都是被忽略的 &lt;em>/
[ policy_anything ]
countryName = optional
stateOrProvinceName = optional
localityName = optional
organizationName = optional
organizationalUnitName = optional
commonName = supplied
emailAddress = optional
/&lt;/em> 以下是添加的扩展项 usr&lt;em>cert 的内容&lt;/em>/
[ usr&lt;em>cert ]
basicConstraints=CA:FALSE /&lt;/em> 基本约束，CA:FALSE 表示该证书不能作为 CA 证书，即不能给其他人颁发证书*/
/* keyUsage = critical,keyCertSign,cRLSign # 指定证书的目的，也就是限制证书的用法*/
/* 除了上面两个扩展项可能会修改下，其余的扩展项别管了，如下面的 _/
nsComment = &amp;ldquo;OpenSSL Generated Certificate&amp;rdquo;
subjectKeyIdentifier=hash
authorityKeyIdentifier=keyid,issuer&lt;/p>
&lt;h2 id="req-section">req Section&lt;/h2>
&lt;p>为 &lt;code>openssl req&lt;/code> 命令提供运行时参数
[ req ]
default&lt;em>bits = 2048 /&lt;/em> 生成证书请求时用到的私钥的密钥长度 &lt;em>/
default_md = sha1 /&lt;/em> 证书请求签名时的单向加密算法 &lt;em>/
default_keyfile = privkey.pem /&lt;/em> 默认新创建的私钥存放位置， &lt;em>/
/&lt;/em> 如-new 选项没指定-key 时会自动创建私钥 &lt;em>/
/&lt;/em> -newkey 选项也会自动创建私钥 &lt;em>/
distinguished_name = req_distinguished_name /&lt;/em> 可识别的字段名(常被简称为 DN) &lt;em>/
/&lt;/em> 引用 req&lt;em>distinguished_name 段的设置 &lt;em>/
x509&lt;/em>extensions = v3_ca /&lt;/em> 加入到自签证书中的扩展项 &lt;em>/
# req_extensions = v3_req /&lt;/em> 加入到证书请求中的扩展项 &lt;em>/
attributes = req_attributes /&lt;/em> 证书请求的属性，引用 req&lt;em>attributes 段的设置，可以不设置它 &lt;em>/
# encrypt&lt;/em>key = yes | no /&lt;/em> 自动生成的私钥文件要加密否？一般设置 no，和-nodes 选项等价 &lt;em>/
/&lt;/em> 输入和输出私钥文件的密码，如果该私钥文件有密码，不写该设置则会提示输入 &lt;em>/
/&lt;/em> input&lt;em>password = secret &lt;em>/
/_ output_password = secret &lt;em>/
# prompt = yes | no /&lt;/em> 设置为 no 将不提示输入 DN field，而是直接从配置文件中读取，需要同时设置 DN 默认值，否则创建证书请求时将出错。 _/
string&lt;/em>mask = utf8only
[ req_distinguished_name ]
/&lt;/em> 以下项均可指定可不指定，但 ca 段的 policy 中指定为 match 和 supplied 一定要指定。 &lt;em>/
/&lt;/em> 以下选项都可以自定义，如 countryName = C，commonName = CN &lt;em>/
countryName = Country Name (2 letter code) /&lt;/em> 国家名(C) &lt;em>/
countryName_default = XX /&lt;/em> 默认的国家名 &lt;em>/
countryName_min = 2 /&lt;/em> 填写的国家名的最小字符长度 &lt;em>/
countryName_max = 2 /&lt;/em> 填写的国家名的最大字符长度 &lt;em>/
stateOrProvinceName = State or Province Name (full name) /&lt;/em> 省份(S) &lt;em>/
/&lt;/em> stateOrProvinceName&lt;em>default = Default Province &lt;em>/
localityName = Locality Name (eg, city) /_ 城市(LT) _/
localityName&lt;/em>default = Default City
0.organizationName = Organization Name (eg, company) /&lt;/em> 公司(ON) &lt;em>/
0.organizationName_default = Default Company Ltd
organizationalUnitName = Organizational Unit Name (eg, section) /&lt;/em> 部门(OU) &lt;em>/
/&lt;/em> organizationalUnitName&lt;em>default = &lt;em>/
/_ 以下的 commonName(CN)一般必须给,如果作为 CA，那么需要在 ca 的 policy 中定义 CN = supplied &lt;em>/
/&lt;/em> CN 定义的是将要申请 SSL 证书的域名或子域名或主机名。 &lt;em>/
/&lt;/em> 例如要为 zhonghua.com 申请 ssl 证书则填写 zhonghua.com，而不能填写www.zhonghua.com &lt;em>/
/&lt;/em> 要为www.zhonghua.com申请SSL则填写www.zhonghua.com &lt;em>/
/&lt;/em> CN 必须和将要访问的网站地址一样，否则访问时就会给出警告 &lt;em>/
/&lt;/em> 该项要填写正确，否则该请求被签名后证书中的 CN 与实际环境中的 CN 不对应，将无法提供证书服务 &lt;em>/
commonName = Common Name (eg, your name or your server&amp;rsquo;s hostname) /&lt;/em> 主机名(CN) _/
commonName&lt;/em>max = 64
emailAddress = Email Address /&lt;/em> Email 地址，很多时候不需要该项的 &lt;em>/
emailAddress_max = 64
[ req_attributes ] /&lt;/em> 该段是为了某些特定软件的运行需要而设定的， &lt;em>/
/&lt;/em> 现在一般都不需要提供 challengepassword &lt;em>/
/&lt;/em> 所以该段几乎用不上 &lt;em>/
/&lt;/em> 所以不用管这段 &lt;em>/
challengePassword = A challenge password
challengePassword_min = 4
challengePassword_max = 20
unstructuredName = An optional company name
[ v3_req ]
/&lt;/em> Extensions to add to a certificate request &lt;em>/
basicConstraints = CA:FALSE
keyUsage = nonRepudiation, digitalSignature, keyEncipherment
[ v3_ca ]
/&lt;/em> Extensions for a typical CA &lt;em>/
subjectKeyIdentifier=hash
authorityKeyIdentifier=keyid:always,issuer
basicConstraints = CA:true
# keyUsage = cRLSign, keyCertSign /&lt;/em> 典型的 CA 证书的使用方法设置，由于测试使用所以注释了 _/
/* 如果真的需要申请为 CA/*么该设置可以如此配置 */&lt;/p>
&lt;p>可以自定义 DN(Distinguished Name)段中的字段信息，注意 ca 段中的 policy 指定的匹配规则中如果指定了 match 或这 supplied 的则 DN 中必须定义。例如下面的示例：由于只有 countryName、organizationName 和 commonName 被设定为 match 和 supplied，其余的都是 optional，所以在 DN 中可以只定义这 3 个字段，而且在 DN 中定义了自定义的名称。
[policy_to_match]
countryName = match
stateOrProvinceName = optional
organizationName = match
organizationalUnitName = optional
commonName = supplied
emailAddress = optional
[DN]
countryName = &amp;ldquo;C&amp;rdquo;
organizationName = &amp;ldquo;O&amp;rdquo;
commonName = &amp;ldquo;Root CA&amp;rdquo;&lt;/p>
&lt;h2 id="tas-section">tas Section&lt;/h2>
&lt;p>[ tsa ]
default_tsa = tsa_config1 # the default TSA section
[ tsa_config1 ]
# These are used by the TSA reply generation only.
dir = ./demoCA # TSA root directory
serial = $dir/tsaserial # The current serial number (mandatory)
crypto_device = builtin # OpenSSL engine to use for signing
signer_cert = $dir/tsacert.pem # The TSA signing certificate
# (optional)
certs = $dir/cacert.pem # Certificate chain to include in reply
# (optional)
signer_key = $dir/private/tsakey.pem # The TSA private key (optional)
signer_digest = sha256 # Signing digest to use. (Optional)
default_policy = tsa_policy1 # Policy if request did not specify it
# (optional)
other_policies = tsa_policy2, tsa_policy3 # acceptable policies (optional)
digests = sha1, sha256, sha384, sha512 # Acceptable message digests (mandatory)
accuracy = secs:1, millisecs:500, microsecs:100 # (optional)
clock_precision_digits = 0 # number of digits after dot. (optional)
ordering = yes # Is ordering defined for timestamps?
# (optional, default: no)
tsa_name = yes # Must the TSA name be included in the reply?
# (optional, default: no)
ess_cert_id_chain = no # Must the ESS cert id chain be included?
# (optional, default: no)
ess_cert_id_alg = sha1 # algorithm to compute certificate
# identifier (optional, default: sha1)&lt;/p>
&lt;h1 id="配置示例">配置示例&lt;/h1>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">[&lt;/span>req&lt;span style="color:#f92672">]&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>req_extensions &lt;span style="color:#f92672">=&lt;/span> v3_req
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>distinguished_name &lt;span style="color:#f92672">=&lt;/span> req_distinguished_name
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">[&lt;/span>req_distinguished_name&lt;span style="color:#f92672">]&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">[&lt;/span> v3_req &lt;span style="color:#f92672">]&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>basicConstraints &lt;span style="color:#f92672">=&lt;/span> CA:FALSE
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>keyUsage &lt;span style="color:#f92672">=&lt;/span> nonRepudiation, digitalSignature, keyEncipherment
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>extendedKeyUsage &lt;span style="color:#f92672">=&lt;/span> clientAuth, serverAuth
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>subjectAltName &lt;span style="color:#f92672">=&lt;/span> @alt_names
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">[&lt;/span>alt_names&lt;span style="color:#f92672">]&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>DNS.1 &lt;span style="color:#f92672">=&lt;/span> abc
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>IP.1 &lt;span style="color:#f92672">=&lt;/span> 1.1.1.1
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div></description></item><item><title>Docs: RBAC</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/7.%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8/access-control%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6/rbac/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/7.%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8/access-control%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6/rbac/</guid><description>
&lt;p>基于角色的权限访问控制（Role-Based Access Control）作为传统访问控制（自主访问，强制访问）的有前景的代替受到广泛的关注。在 RBAC 中，权限与角色相关联，用户通过成为适当角色的成员而得到这些角色的权限。这就极大地简化了权限的管理。在一个组织中，角色是为了完成各种工作而创造，用户则依据它的责任和资格来被指派相应的角色，用户可以很容易地从一个角色被指派到另一个角色。角色可依新的需求和系统的合并而赋予新的权限，而权限也可根据需要而从某角色中回收。角色与角色的关系可以建立起来以囊括更广泛的客观情况。&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/wn3hwi/1616125478657-b931db83-6f72-44d0-9371-0e19ae04ee25.jpeg" alt="">&lt;/p>
&lt;p>RBAC 支持三个著名的安全原则：最小权限原则，责任分离原则和数据抽象原则。&lt;/p>
&lt;p>（1）最小权限原则之所以被 RBAC 所支持，是因为 RBAC 可以将其角色配置成其完成任务所需要的最小的权限集。&lt;/p>
&lt;p>（2）责任分离原则可以通过调用相互独立互斥的角色来共同完成敏感的任务而体现，比如要求一个计帐员和财务管理员共参与同一过帐。&lt;/p>
&lt;p>（3）数据抽象可以通过权限的抽象来体现，如财务操作用借款、存款等抽象权限，而不用操作系统提供的典型的读、写、执行权限。然而这些原则必须通过 RBAC 各部件的详细配置才能得以体现。&lt;/p>
&lt;p>RBAC 有许多部件(BUCU)，这使得 RBAC 的管理多面化。尤其是，我们要分割这些问题来讨论：用户与角色的指派；角色与权限的指派；为定义角色的继承进行的角色与角色的指派。这些活动都要求把用户和权限联系起来。然而在很多情况下它们最好由不同的管理员或管理角色来做。对角色指派权限是典型的应用管理者的职责。银行应用中，把借款、存款操作权限指派给出纳角色，把批准贷款操作权限指派给经理角色。而将具体人员指派给相应的出纳角色和管理者角色是人事管理的范畴。角色与角色的指派包含用户与角色的指派、角色与权限的指派的一些特点。更一般来说，角色与角色的关系体现了更广泛的策略。&lt;/p>
&lt;h2 id="基本概念">基本概念&lt;/h2>
&lt;p>RBAC 认为权限授权实际上是 Who、What、How 的问题。在 RBAC 模型中，who、what、how 构成了访问权限三元组,也就是“Who 对 What(Which)进行 How 的操作”。&lt;/p>
&lt;p>Who：权限的拥用者或主体（如 Principal、User、Group、Role、Actor 等等）。&lt;/p>
&lt;p>What：权限针对的对象或资源（Resource、Class）。&lt;/p>
&lt;p>How：具体的权限（Privilege,正向授权与负向授权）。&lt;/p>
&lt;p>Operator：操作。表明对 What 的 How 操作。也就是 Privilege+Resource&lt;/p>
&lt;p>Role：角色，一定数量的权限的集合。权限分配的单位与载体,目的是隔离 User 与 Privilege 的逻辑关系.&lt;/p>
&lt;p>Group：用户组，权限分配的单位与载体。权限不考虑分配给特定的用户而给组。组可以包括组(以实现权限的继承)，也可以包含用户，组内用户继承组的权限。User 与 Group 是多对多的关系。Group 可以层次化，以满足不同层级权限控制的要求。&lt;/p>
&lt;p>RBAC 的关注点在于 Role 和 User, Permission（允许/权限）的关系。称为 User assignment(UA)和 Permission assignment(PA).关系的左右两边都是 Many-to-Many 关系。就是 user 可以有多个 role，role 可以包括多个 user。&lt;/p>
&lt;p>凡是用过 RDBMS 都知道，n:m 的关系需要一个中间表来保存两个表的关系。这 UA 和 PA 就相当于中间表。事实上，整个 RBAC 都是基于关系模型。&lt;/p>
&lt;p>Session 在 RBAC 中是比较隐晦的一个元素。标准上说：每个 Session 是一个映射，一个用户到多个 role 的映射。当一个用户激活他所有角色的一个子集的时候，建立一个 session。每个 Session 和单个的 user 关联，并且每个 User 可以关联到一或多个 Session.&lt;/p>
&lt;p>在 RBAC 系统中，User 实际上是在扮演角色(Role)，可以用 Actor 来取代 User，这个想法来自于 Business Modeling With UML 一书 Actor-Role 模式。考虑到多人可以有相同权限，RBAC 引入了 Group 的概念。Group 同样也看作是 Actor。而 User 的概念就具象到一个人。&lt;/p>
&lt;p>这里的 Group 和 GBAC（Group-Based Access Control）中的 Group（组）不同。GBAC 多用于操作系统中。其中的 Group 直接和权限相关联，实际上 RBAC 也借鉴了一些 GBAC 的概念。&lt;/p>
&lt;p>Group 和 User 都和组织机构有关，但不是组织机构。二者在概念上是不同的。组织机构是物理存在的公司结构的抽象模型，包括部门，人，职位等等，而权限模型是对抽象概念描述。组织结构一般用 Martin fowler 的 Party 或责任模式来建模。&lt;/p>
&lt;p>Party 模式中的 Person 和 User 的关系，是每个 Person 可以对应到一个 User，但可能不是所有的 User 都有对应的 Person。Party 中的部门 Department 或组织 Organization，都可以对应到 Group。反之 Group 未必对应一个实际的机构。例如，可以有副经理这个 Group，这是多人有相同职责。&lt;/p>
&lt;p>引入 Group 这个概念，除了用来解决多人相同角色问题外，还用以解决组织机构的另一种授权问题：例如，A 部门的新闻我希望所有的 A 部门的人都能看。有了这样一个 A 部门对应的 Group，就可直接授权给这个 Group&lt;/p></description></item><item><title>Docs: RSA 加密算法</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/7.%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8/cryptography%E5%AF%86%E7%A0%81%E5%AD%A6/rsa-%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/7.%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8/cryptography%E5%AF%86%E7%A0%81%E5%AD%A6/rsa-%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95/</guid><description/></item><item><title>Docs: RSA 密钥生成的步骤</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/7.%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8/cryptography%E5%AF%86%E7%A0%81%E5%AD%A6/rsa-%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95/rsa-%E5%AF%86%E9%92%A5%E7%94%9F%E6%88%90%E7%9A%84%E6%AD%A5%E9%AA%A4/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/7.%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8/cryptography%E5%AF%86%E7%A0%81%E5%AD%A6/rsa-%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95/rsa-%E5%AF%86%E9%92%A5%E7%94%9F%E6%88%90%E7%9A%84%E6%AD%A5%E9%AA%A4/</guid><description>
&lt;p>参考：&lt;a href="https://www.ruanyifeng.com/blog/2013/07/rsa_algorithm_part_two.html">阮一峰&lt;/a>&lt;/p>
&lt;p>&lt;strong>六、密钥生成的步骤&lt;/strong>&lt;/p>
&lt;p>我们通过一个例子，来理解 RSA 算法。假设&lt;a href="http://zh.wikipedia.org/wiki/%E7%88%B1%E4%B8%BD%E4%B8%9D%E4%B8%8E%E9%B2%8D%E4%BC%AF">爱丽丝要与鲍勃&lt;/a>进行加密通信，她该怎么生成公钥和私钥呢？&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/zd4wod/1616125649610-fba85c22-0313-466e-83df-6133ea29c477.png" alt="">&lt;/p>
&lt;p>&lt;strong>第一步，随机选择两个不相等的质数 p 和 q。&lt;/strong>&lt;/p>
&lt;p>爱丽丝选择了 61 和 53。（实际应用中，这两个质数越大，就越难破解。）&lt;/p>
&lt;p>&lt;strong>第二步，计算 p 和 q 的乘积 n。&lt;/strong>&lt;/p>
&lt;p>爱丽丝就把 61 和 53 相乘。&lt;/p>
&lt;blockquote>
&lt;p>n = 61×53 = 3233&lt;/p>
&lt;/blockquote>
&lt;p>n 的长度就是密钥长度。3233 写成二进制是 110010100001，一共有 12 位，所以这个密钥就是 12 位。实际应用中，RSA 密钥一般是 1024 位，重要场合则为 2048 位。&lt;/p>
&lt;p>&lt;strong>第三步，计算 n 的欧拉函数 φ(n)。&lt;/strong>&lt;/p>
&lt;p>根据公式：&lt;/p>
&lt;blockquote>
&lt;p>φ(n) = (p-1)(q-1)&lt;/p>
&lt;/blockquote>
&lt;p>爱丽丝算出 φ(3233)等于 60×52，即 3120。&lt;/p>
&lt;p>&lt;strong>第四步，随机选择一个整数 e，条件是 1&amp;lt; e &amp;lt; φ(n)，且 e 与 φ(n) 互质。&lt;/strong>&lt;/p>
&lt;p>爱丽丝就在 1 到 3120 之间，随机选择了 17。（实际应用中，常常选择 65537。）&lt;/p>
&lt;p>&lt;strong>第五步，计算 e 对于 φ(n)的模反元素 d。&lt;/strong>&lt;/p>
&lt;p>所谓&amp;quot;模反元素&amp;quot;就是指有一个整数 d，可以使得 ed 被 φ(n)除的余数为 1。&lt;/p>
&lt;blockquote>
&lt;p>ed ≡ 1 (mod φ(n))&lt;/p>
&lt;/blockquote>
&lt;p>这个式子等价于&lt;/p>
&lt;blockquote>
&lt;p>ed - 1 = kφ(n)&lt;/p>
&lt;/blockquote>
&lt;p>于是，找到模反元素 d，实质上就是对下面这个二元一次方程求解。&lt;/p>
&lt;blockquote>
&lt;p>ex + φ(n)y = 1&lt;/p>
&lt;/blockquote>
&lt;p>已知 e=17, φ(n)=3120，&lt;/p>
&lt;blockquote>
&lt;p>17x + 3120y = 1&lt;/p>
&lt;/blockquote>
&lt;p>这个方程可以用&amp;quot;扩展欧几里得算法&amp;quot;求解，此处省略具体过程。总之，爱丽丝算出一组整数解为 (x,y)=(2753,-15)，即 d=2753。&lt;/p>
&lt;p>至此所有计算完成。&lt;/p>
&lt;p>&lt;strong>第六步，将 n 和 e 封装成公钥，n 和 d 封装成私钥。&lt;/strong>&lt;/p>
&lt;p>在爱丽丝的例子中，n=3233，e=17，d=2753，所以公钥就是 (3233,17)，私钥就是（3233, 2753）。&lt;/p>
&lt;p>实际应用中，公钥和私钥的数据都采用 ASN.1 格式表达（实例）。&lt;/p>
&lt;p>&lt;strong>七、RSA 算法的可靠性&lt;/strong>&lt;/p>
&lt;p>回顾上面的密钥生成步骤，一共出现六个数字：&lt;/p>
&lt;p>这六个数字之中，公钥用到了两个（n 和 e），其余四个数字都是不公开的。其中最关键的是 d，因为 n 和 d 组成了私钥，一旦 d 泄漏，就等于私钥泄漏。&lt;/p>
&lt;p>&lt;strong>那么，有无可能在已知 n 和 e 的情况下，推导出 d？&lt;/strong>&lt;/p>
&lt;blockquote>
&lt;p>（1）ed≡1 (mod φ(n))。只有知道 e 和 φ(n)，才能算出 d。　　（2）φ(n)=(p-1)(q-1)。只有知道 p 和 q，才能算出 φ(n)。　　（3）n=pq。只有将 n 因数分解，才能算出 p 和 q。&lt;/p>
&lt;/blockquote>
&lt;p>&lt;strong>结论：如果 n 可以被因数分解，d 就可以算出，也就意味着私钥被破解。&lt;/strong>&lt;/p>
&lt;p>可是，大整数的因数分解，是一件非常困难的事情。目前，除了暴力破解，还没有发现别的有效方法。维基百科这样写道：&lt;/p>
&lt;blockquote>
&lt;p>&amp;ldquo;对极大整数做因数分解的难度决定了 RSA 算法的可靠性。换言之，对一极大整数做因数分解愈困难，RSA 算法愈可靠。　　假如有人找到一种快速因数分解的算法，那么 RSA 的可靠性就会极度下降。但找到这样的算法的可能性是非常小的。今天只有短的 RSA 密钥才可能被暴力破解。到 2008 年为止，世界上还没有任何可靠的攻击 RSA 算法的方式。　　只要密钥长度足够长，用 RSA 加密的信息实际上是不能被解破的。&amp;rdquo;&lt;/p>
&lt;/blockquote>
&lt;p>举例来说，你可以对 3233 进行因数分解（61×53），但是你没法对下面这个整数进行因数分解。&lt;/p>
&lt;p>它等于这样两个质数的乘积：&lt;/p>
&lt;p>事实上，这大概是人类已经分解的最大整数（232 个十进制位，768 个二进制位）。比它更大的因数分解，还没有被报道过，因此目前被破解的最长 RSA 密钥就是 768 位。&lt;/p>
&lt;p>&lt;strong>八、加密和解密&lt;/strong>&lt;/p>
&lt;p>有了公钥和密钥，就能进行加密和解密了。&lt;/p>
&lt;p>&lt;strong>（1）加密要用公钥 (n,e)&lt;/strong>&lt;/p>
&lt;p>假设鲍勃要向爱丽丝发送加密信息 m，他就要用爱丽丝的公钥 (n,e) 对 m 进行加密。这里需要注意，m 必须是整数（字符串可以取 ascii 值或 unicode 值），且 m 必须小于 n。&lt;/p>
&lt;p>所谓&amp;quot;加密&amp;quot;，就是算出下式的 c：&lt;/p>
&lt;blockquote>
&lt;p>me ≡ c (mod n)&lt;/p>
&lt;/blockquote>
&lt;p>爱丽丝的公钥是 (3233, 17)，鲍勃的 m 假设是 65，那么可以算出下面的等式：&lt;/p>
&lt;blockquote>
&lt;p>6517 ≡ 2790 (mod 3233)&lt;/p>
&lt;/blockquote>
&lt;p>于是，c 等于 2790，鲍勃就把 2790 发给了爱丽丝。&lt;/p>
&lt;p>&lt;strong>（2）解密要用私钥(n,d)&lt;/strong>&lt;/p>
&lt;p>爱丽丝拿到鲍勃发来的 2790 以后，就用自己的私钥(3233, 2753) 进行解密。可以证明，下面的等式一定成立：&lt;/p>
&lt;blockquote>
&lt;p>cd ≡ m (mod n)&lt;/p>
&lt;/blockquote>
&lt;p>也就是说，c 的 d 次方除以 n 的余数为 m。现在，c 等于 2790，私钥是(3233, 2753)，那么，爱丽丝算出&lt;/p>
&lt;blockquote>
&lt;p>27902753 ≡ 65 (mod 3233)&lt;/p>
&lt;/blockquote>
&lt;p>因此，爱丽丝知道了鲍勃加密前的原文就是 65。&lt;/p>
&lt;p>至此，&amp;ldquo;加密&amp;ndash;解密&amp;quot;的整个过程全部完成。&lt;/p>
&lt;p>我们可以看到，如果不知道 d，就没有办法从 c 求出 m。而前面已经说过，要知道 d 就必须分解 n，这是极难做到的，所以 RSA 算法保证了通信安全。&lt;/p>
&lt;p>你可能会问，公钥(n,e) 只能加密小于 n 的整数 m，那么如果要加密大于 n 的整数，该怎么办？有两种解决方法：一种是把长信息分割成若干段短消息，每段分别加密；另一种是先选择一种&amp;quot;对称性加密算法&amp;rdquo;（比如 DES），用这种算法的密钥加密信息，再用 RSA 公钥加密 DES 密钥。&lt;/p>
&lt;p>&lt;strong>九、私钥解密的证明&lt;/strong>&lt;/p>
&lt;p>最后，我们来证明，为什么用私钥解密，一定可以正确地得到 m。也就是证明下面这个式子：&lt;/p>
&lt;blockquote>
&lt;p>cd ≡ m (mod n)&lt;/p>
&lt;/blockquote>
&lt;p>因为，根据加密规则&lt;/p>
&lt;blockquote>
&lt;p>ｍ e ≡ c (mod n)&lt;/p>
&lt;/blockquote>
&lt;p>于是，c 可以写成下面的形式：&lt;/p>
&lt;blockquote>
&lt;p>c = me - kn&lt;/p>
&lt;/blockquote>
&lt;p>将 c 代入要我们要证明的那个解密规则：&lt;/p>
&lt;blockquote>
&lt;p>(me - kn)d ≡ m (mod n)&lt;/p>
&lt;/blockquote>
&lt;p>它等同于求证&lt;/p>
&lt;blockquote>
&lt;p>med ≡ m (mod n)&lt;/p>
&lt;/blockquote>
&lt;p>由于&lt;/p>
&lt;blockquote>
&lt;p>ed ≡ 1 (mod φ(n))&lt;/p>
&lt;/blockquote>
&lt;p>所以&lt;/p>
&lt;blockquote>
&lt;p>ed = hφ(n)+1&lt;/p>
&lt;/blockquote>
&lt;p>将 ed 代入：&lt;/p>
&lt;blockquote>
&lt;p>mhφ(n)+1 ≡ m (mod n)&lt;/p>
&lt;/blockquote>
&lt;p>接下来，分成两种情况证明上面这个式子。&lt;/p>
&lt;p>&lt;strong>（1）m 与 n 互质。&lt;/strong>&lt;/p>
&lt;p>根据欧拉定理，此时&lt;/p>
&lt;blockquote>
&lt;p>mφ(n) ≡ 1 (mod n)&lt;/p>
&lt;/blockquote>
&lt;p>得到&lt;/p>
&lt;blockquote>
&lt;p>(mφ(n))h × m ≡ m (mod n)&lt;/p>
&lt;/blockquote>
&lt;p>原式得到证明。&lt;/p>
&lt;p>&lt;strong>（2）m 与 n 不是互质关系。&lt;/strong>&lt;/p>
&lt;p>此时，由于 n 等于质数 p 和 q 的乘积，所以 m 必然等于 kp 或 kq。&lt;/p>
&lt;p>以 m = kp 为例，考虑到这时 k 与 q 必然互质，则根据欧拉定理，下面的式子成立：&lt;/p>
&lt;blockquote>
&lt;p>(kp)q-1 ≡ 1 (mod q)&lt;/p>
&lt;/blockquote>
&lt;p>进一步得到&lt;/p>
&lt;blockquote>
&lt;p>[(kp)q-1]h(p-1) × kp ≡ kp (mod q)&lt;/p>
&lt;/blockquote>
&lt;p>即&lt;/p>
&lt;blockquote>
&lt;p>(kp)ed ≡ kp (mod q)&lt;/p>
&lt;/blockquote>
&lt;p>将它改写成下面的等式&lt;/p>
&lt;blockquote>
&lt;p>(kp)ed = tq + kp&lt;/p>
&lt;/blockquote>
&lt;p>这时 t 必然能被 p 整除，即 t=t&amp;rsquo;p&lt;/p>
&lt;blockquote>
&lt;p>(kp)ed = t&amp;rsquo;pq + kp&lt;/p>
&lt;/blockquote>
&lt;p>因为 m=kp，n=pq，所以&lt;/p>
&lt;blockquote>
&lt;p>med ≡ m (mod n)&lt;/p>
&lt;/blockquote>
&lt;p>原式得到证明。&lt;/p>
&lt;p>（完）&lt;/p></description></item><item><title>Docs: Standard commands(标准命令)</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/7.%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8/%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/openssl/standard-commands%E6%A0%87%E5%87%86%E5%91%BD%E4%BB%A4/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/7.%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8/%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/openssl/standard-commands%E6%A0%87%E5%87%86%E5%91%BD%E4%BB%A4/</guid><description>
&lt;h1 id="其他标准命令">其他标准命令&lt;/h1>
&lt;h2 id="openssl-passwd--对指定的字符串生成-hash-过的密码">openssl passwd # 对指定的字符串生成 hash 过的密码&lt;/h2>
&lt;p>&lt;strong>openssl password [OPTIONS] [STRING]&lt;/strong>
MD5 算法加密后的格式为：$算法简称$SALT$XXXXXX，算法简称为 1 或者 apr1，SALT 为指定的盐的字符串，XXXX 为生成的加密的字符串&lt;/p>
&lt;p>OPTIONS&lt;/p>
&lt;ul>
&lt;li>-crypt # standard Unix password algorithm (default)&lt;/li>
&lt;li>-1 # -1 基于 MD5 的密码算法（注意：不指定 salt 的话，会使用随机的 slat）&lt;/li>
&lt;li>-salt # 在生成加密的密码中加盐(salt)。（为什么叫盐详见&lt;a href="https://zh.wikipedia.org/wiki/%25E7%259B%2590_(%25E5%25AF%2586%25E7%25A0%2581%25E5%25AD%25A6)">https://zh.wikipedia.org/wiki/%E7%9B%90_(%E5%AF%86%E7%A0%81%E5%AD%A6)&lt;/a>这是密码学的一个概念）,加盐与不加盐得出的结果是不一样的&lt;/li>
&lt;/ul>
&lt;p>EXAMPLE&lt;/p>
&lt;ul>
&lt;li>openssl passwd -1 123456
&lt;ul>
&lt;li>结果为：$1$ONQ8XSuX$Cv0wy2WbbbwOt/YkXuAlU/&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>openssl passwd -1 -salt 123 123456
&lt;ul>
&lt;li>结果为：$1$123$7mft0jKnzzvAdU4t0unTG1&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h2 id="openssl-rand--生成伪随机数字节">openssl rand # 生成伪随机数字节&lt;/h2>
&lt;p>EXAMPLE&lt;/p>
&lt;ul>
&lt;li>openssl rand -hex 6 # 生成随机数&lt;/li>
&lt;/ul>
&lt;h1 id="rsa-标准命令">RSA 标准命令&lt;/h1>
&lt;h2 id="openssl-genrsa--生成-rsa-密钥">openssl genrsa # 生成 RSA 密钥&lt;/h2>
&lt;h3 id="syntax语法">Syntax(语法)&lt;/h3>
&lt;p>&lt;strong>openssl genrsa [ OPTIONS ] [ ARGUMENTS ]&lt;/strong>&lt;/p>
&lt;p>OPTIONS&lt;/p>
&lt;p>EXAMPLE&lt;/p>
&lt;ul>
&lt;li>在当前目录下生成一个 2048 位的名为 lch.key 的私钥（括号的作用是创建子 shell 执行命令，这样 umask 命令对当前 shell 没影响）
&lt;ul>
&lt;li>&lt;strong>(umask 077; openssl genrsa -out ./lch.key 2048)&lt;/strong>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h2 id="openssl-rsa--rsa-密钥管理">openssl rsa # RSA 密钥管理&lt;/h2>
&lt;p>openssl rsa [OPTIONS] [ARGUMENTS]&lt;/p>
&lt;p>OPTIONS&lt;/p>
&lt;ul>
&lt;li>&lt;strong>-noout&lt;/strong> # 不输出密钥的编码格式&lt;/li>
&lt;li>&lt;strong>-text&lt;/strong> # 除了编码后的格式，还会输出纯文本格式的内容，这些内容有公钥和私钥组件&lt;/li>
&lt;/ul>
&lt;p>EXAMPLE&lt;/p>
&lt;ul>
&lt;li>从 lch.key 私钥中输出公钥信息，并将公钥信息写入到 lch.pub 文件中
&lt;ul>
&lt;li>&lt;strong>openssl rsa -in lch.key -pubout -out lch.pub&lt;/strong>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>显示 ca.key 密钥的信息
&lt;ul>
&lt;li>&lt;strong>openssl rsa -noout -text -in ca.key&lt;/strong>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h1 id="证书标准命令">证书标准命令&lt;/h1>
&lt;h2 id="openssl-ca--sample-minimal-ca-applicationca-程序">openssl ca # sample minimal CA application。CA 程序&lt;/h2>
&lt;p>&lt;strong>注意&lt;/strong>：使用 &lt;code>req&lt;/code> 和 &lt;code>x509&lt;/code> 命令是非常精简的生成证书的方式。&lt;/p>
&lt;p>EXAMPLE&lt;/p>
&lt;ul>
&lt;li>在 CA 所在服务器使用 httpd.csr 的请求文件签署证书生成证书文件 httpd.crt，然后再把该证书文件，发送给请求方，整套流程就完成了。
&lt;ul>
&lt;li>注意：如果想要执行该命令，需要注意为该服务器进行 CA 的配置，详见本章前面的&amp;quot;配置文件说明&amp;quot;&lt;/li>
&lt;li>openssl ca -in httpd.csr -out httpd.crt -days 365&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>openssl ca -revoke /etc/pki/CA/newcerts/SERIAL.pem # 吊销证书&lt;/li>
&lt;li>openssl ca -gencrl -out&lt;/li>
&lt;/ul>
&lt;h2 id="openssl-req--生成根证书或符合-pkcs-10-标准的证书请求">openssl req # 生成根证书或符合 PKCS #10 标准的证书请求&lt;/h2>
&lt;p>该命令主要以 PKCS#10 标准格式创建和处理 CSR。并且还可以创建自签名证书，以用作根 CA 证书。&lt;/p>
&lt;h3 id="syntax语法-1">Syntax(语法)&lt;/h3>
&lt;p>&lt;strong>openssl req [ OPTIONS ] [ ARGUMENTS ]&lt;/strong>
OPTIONS&lt;/p>
&lt;ul>
&lt;li>&lt;strong>-config &lt;!-- raw HTML omitted -->&lt;/strong> #&lt;/li>
&lt;li>**-new **#生成新证书请求&lt;/li>
&lt;li>&lt;strong>-x509&lt;/strong> # 生成自签证书&lt;/li>
&lt;li>&lt;strong>-key /PATH/FILE&lt;/strong> #指明用于生成请求时用到的私钥文件&lt;/li>
&lt;li>&lt;strong>-days NUM&lt;/strong> #指明证书的有效期&lt;/li>
&lt;li>&lt;strong>-text&lt;/strong> # 以文本形式打印出证书&lt;/li>
&lt;li>&lt;strong>-noout&lt;/strong> #不输出证书的编码格式内容&lt;/li>
&lt;/ul>
&lt;p>EXAMPLE&lt;/p>
&lt;ul>
&lt;li>创建一个 ca 自签证书。
&lt;ul>
&lt;li>openssl req -new -x509 -key /etc/pki/CA/private/cakey.pem -days 3650 -out /etc/pki/CA/cacert.pem&lt;/li>
&lt;li>这个命令之后还需要输入几个身份信息，如下。输入完成后，自动生成 CA 自签证书
&lt;ul>
&lt;li>Country Name (2 letter code) [XX]:CN # 指明国家名，两个英文缩写&lt;/li>
&lt;li>State or Province Name (full name) []:Tianjin # 指明省或州名&lt;/li>
&lt;li>Locality Name (eg, city) [Default City]:Tianjin # 指明地点名称，例如城市&lt;/li>
&lt;li>Organization Name (eg, company) [Default Company Ltd]:GuanDian # 指明组织名称。例如公司&lt;/li>
&lt;li>Organizational Unit Name (eg, section) []:Ops # 指明组织单位名称，例如部门&lt;/li>
&lt;li>Common Name (eg, your name or your server&amp;rsquo;s hostname) []:master0 # 指明通用名称，例如 CA 名或者服务器主机名。
&lt;ul>
&lt;li>Note：证书中的 CN 是很重要的标志，CN 可以使用主机名来表示，这样在使用证书来访问的时候，可以使用 CN 来验证域名是否可信。&lt;/li>
&lt;li>如果 CN 不使用主机名，则在签发证书的时候，需要 subjectAltName 字段来设定 DNS 别名，否则会报错提示证书对某些域名不可用。&lt;/li>
&lt;li>样例详见 harbor 使用私有证书部署：harbor 云原生注册中心.note&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Email Address []:373406000@qq.com #指明邮箱地址&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>使用 httpd.key 这个密钥创建一个证书请求文件 httpd.csr
&lt;ul>
&lt;li>openssl req -new -key httpd.key -days 365 -out httpd.csr&lt;/li>
&lt;li>在输入完该命令后，同样需要输入几个身份信息以供 CA 进行验证。由于是私有 CA，所以所有信息应该保持跟 CA 的信息一样，具体信息详见上面那个命令，否则无法签署成功。后面还可以输入密码，当然密码也可以为空，密码主要是对改请求进行加密的。创建完请求后，把该请求文件 XXX.csr 发送给 CA 所在的服务器，然后由 CA 进行签署。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h2 id="openssl-x509--证书显示或签名工具">openssl x509 # 证书显示或签名工具&lt;/h2>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://www.openssl.org/docs/manmaster/man1/openssl-x509.html">Manual(手册),openssl-x509(1)&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>这是一个多用途的证书处理命令。&lt;/p>
&lt;ul>
&lt;li>可以用于打印证书信息&lt;/li>
&lt;li>将证书转换为各种形式&lt;/li>
&lt;li>编辑证书信息设置&lt;/li>
&lt;li>从头开始或从认证请求生成证书&lt;/li>
&lt;li>等等&lt;/li>
&lt;/ul>
&lt;h3 id="syntax语法-2">Syntax(语法)&lt;/h3>
&lt;p>**openssl x509 [ OPTIONS ] [ ARGUMENTS ] **&lt;/p>
&lt;h4 id="input-output-and-general-purpose-options输入输出通用选项">Input, Output, and General Purpose OPTIONS(输入、输出、通用选项)&lt;/h4>
&lt;ul>
&lt;li>&lt;strong>-noout&lt;/strong> # 禁止输出证书请求文件中的编码部分&lt;/li>
&lt;li>**-pubkey **# 输出证书中的公钥&lt;/li>
&lt;li>**-modulus **# 输出证书中公钥模块部分&lt;/li>
&lt;li>&lt;strong>-serial&lt;/strong> # 输出证书的序列号&lt;/li>
&lt;li>**-subject **# 输出证书中的 subject&lt;/li>
&lt;li>**-issuer **# 输出证书中的 issuer，即颁发者的 subject&lt;/li>
&lt;li>&lt;strong>-subject_hash&lt;/strong> # 输出证书中 subject 的 hash 码&lt;/li>
&lt;li>&lt;strong>-issuer_hash&lt;/strong> # 输出证书中 issuer(即颁发者的 subject)的 hash 码&lt;/li>
&lt;li>&lt;strong>-hash&lt;/strong> # 等价于&amp;quot;-subject_hash&amp;quot;，但此项是为了向后兼容才提供的选项&lt;/li>
&lt;li>**-email **# 输出证书中的 email 地址，如果有 email 的话&lt;/li>
&lt;li>&lt;strong>-startdate&lt;/strong> # 输出证书有效期的起始日期&lt;/li>
&lt;li>&lt;strong>-enddate&lt;/strong> # 输出证书有效期的终止日期&lt;/li>
&lt;li>&lt;strong>-dates&lt;/strong> # 输出证书有效期，等价于&amp;quot;startdate+enddate&amp;quot;&lt;/li>
&lt;li>&lt;strong>-fingerprint&lt;/strong> # 输出指纹摘要信息&lt;/li>
&lt;/ul>
&lt;h4 id="certificate-printing-options证书打印选项">Certificate Printing OPTIONS(证书打印选项)&lt;/h4>
&lt;ul>
&lt;li>&lt;strong>-text&lt;/strong> # 以 text 格式输出证书内容，即以最全格式输出、包括 public key,signature algorithms,issuer 和 subject names,serial number 以及 any trust settings.&lt;/li>
&lt;/ul>
&lt;h4 id="certificate-checking-options证书检查选项">Certificate Checking OPTIONS(证书检查选项)&lt;/h4>
&lt;ul>
&lt;li>&lt;strong>-days&lt;/strong> #&lt;/li>
&lt;li>&lt;strong>-extfile &lt;!-- raw HTML omitted -->&lt;/strong> #&lt;/li>
&lt;li>&lt;strong>-extensions &lt;!-- raw HTML omitted -->&lt;/strong> # 从 -extfile 选项指定的文件中指定 SectionName，该 Section 中的参数用来配置 X.509 证书的 &lt;code>X509v3 extensions&lt;/code> 字段。
&lt;ul>
&lt;li>若未指定本选项，则默认使用 “默认部分” 的 extensions 指令。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h4 id="certificate-output-options证书输出选项">Certificate Output OPTIONS(证书输出选项)&lt;/h4>
&lt;h4 id="micro-ca-options">Micro-CA OPTIONS&lt;/h4>
&lt;ul>
&lt;li>&lt;strong>-CA &amp;lt;FileName|URI&amp;gt;&lt;/strong> # 指定用于签署证书的 CA 证书。&lt;/li>
&lt;li>&lt;strong>-CAkey &amp;lt;FileName|URI&amp;gt;&lt;/strong> # 指定用于签署证书的 CA 私钥。&lt;/li>
&lt;/ul></description></item><item><title>Docs: Standardized Glossary(标准化术语)</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/7.%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8/standardized-glossary%E6%A0%87%E5%87%86%E5%8C%96%E6%9C%AF%E8%AF%AD/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/7.%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8/standardized-glossary%E6%A0%87%E5%87%86%E5%8C%96%E6%9C%AF%E8%AF%AD/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://datatracker.ietf.org/doc/html/rfc4949">RFC 4949(互联网安全术语)&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>**Entity(实体) **# 是任何存在的东西（anything that exists） —— 即使 只在逻辑或概念上存在（even if only exists logically or conceptually）。 例如，&lt;/p>
&lt;ul>
&lt;li>你的计算机是一个 entity，&lt;/li>
&lt;li>你写的代码也是一个 entity，&lt;/li>
&lt;li>你自己也是一个 entity，&lt;/li>
&lt;li>你吃的杂粮饼也是一个 entity，&lt;/li>
&lt;li>你六岁时见过的幽灵也是一个 entity —— 即使你妈告诉你幽灵并不存在，这只是你的臆想。&lt;/li>
&lt;li>所以
&lt;ul>
&lt;li>CA 也算一个实体&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>Identity(身份)&lt;/strong> # 每个 entity（实体）都有一个 identity（身份）。 要精确定义这个概念比较困难，这么来说吧：identity 是使你之所以为你 （what makes you you）的东西。&lt;/p>
&lt;ul>
&lt;li>具体到计算机领域，identity 通常用一系列属性来表示，描述某个具体的 entity， 这里的属性包括 group、age、location、favorite color、shoe size 等等。&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>Identifier(身份标识符)&lt;/strong> # Identifier 跟 identity 还不是一个东西：每个 identifier 都是一个唯一标识符， 也唯一地关联到某个有 identity 的 entity。&lt;/p>
&lt;ul>
&lt;li>例如，我是 Mike，但 Mike 并不是我的 identity，而只是个 name —— 虽然二者在我们 小范围的讨论中是同义的。&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>Claim(声明) &amp;amp; Authentication(认证)&lt;/strong> #&lt;/p>
&lt;ul>
&lt;li>一个 entity 能 claim（声明）说，它拥有某个或某些 name。&lt;/li>
&lt;li>其他 entity 能够对这个 claim 进行认证（authenticate），以确认这份声明的真假。一般来说，认证的目的是确认某些 claim 的合法性。&lt;/li>
&lt;li>Claim 不是只能关联到 name，还可以关联到别的东西。例如，我能 claim 任何东西： my age, your age, access rights, the meaning of life 等等。&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>Subscriber &amp;amp; CA &amp;amp; relying party (RP)&lt;/strong> #&lt;/p>
&lt;ul>
&lt;li>能作为一个证书的 subject 的 entity，称为 subscriber（证书 owner）或 end entity。对应地，subscriber 的证书有时也称为 end entity certificates 或 leaf certificates， 原因在后面讨论 certificate chains 时会介绍。&lt;/li>
&lt;li>CA（certificate authority，证书权威）是给 subscriber 颁发证书的 entity，是一种 certificate issuer（证书颁发者）。CA 的证书，通常称为 root certificate 或 intermediate certificate，具体取决于 CA 类型。&lt;/li>
&lt;li>Relying party 是 使用证书的用户（certificate user），它验证由 CA 颁发（给 subscriber）的证书是否合法。一个 entity 可以同时是一个 subscriber 和一个 relying party。 也就是说，单个 entity 既有自己的证书，又使用其他证书来认证 remote peers， 例如双向 TLS（mutual TLS，mTLS）场景。&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>key(密钥)&lt;/strong> # 在密码学中，是指某个用来完成加密、解密、完整性验证等密码学应用的秘密信息。对于加密算法，key 指定明文转换成密文；对于解密算法，key 指定密文转换成明文&lt;/p>
&lt;ul>
&lt;li>&lt;strong>Plaintext/Cleartext(明文)&lt;/strong> # 在密码学中，明文是未加密的信息，可以供人类和计算机读取的信息&lt;/li>
&lt;li>**Ciphertext/Cyphertext(密文) **# 在密码学中，密文是明文通过加密算法计算后生成的人类或计算器无法读取的一种信息&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>Key Generation(密钥生成)&lt;/strong> # &lt;a href="https://en.wikipedia.org/wiki/Key_generation">详见 Wiki&lt;/a>。密钥一般都是各种程序根据指定算法生成的。&lt;/p>
&lt;p>&lt;strong>Password(密码)&lt;/strong> 与 &lt;strong>Key(密钥) 的区别&lt;/strong> # 详见 &lt;a href="https://en.wikipedia.org/wiki/Key_(cryptography)">Wiki Key，Key vs Password&lt;/a>。&lt;/p>
&lt;ul>
&lt;li>对于大多数计算机安全目的和大多数用户而言，“密钥”与“密码”（或“密码短语”）并不相同，尽管实际上可以将密码用作密钥。密钥和密码之间的主要实际区别在于，密码和密码旨在由人类用户生成，读取，记住和再现（尽管用户可以将这些任务委托给密码管理软件）。相反，密钥旨在由实现密码算法的软件使用，因此不需要人类可读性等。实际上，大多数用户在大多数情况下甚至都不知道其日常软件应用程序的安全组件正在使用代表他们的密钥。&lt;/li>
&lt;li>如果 &lt;a href="https://en.wikipedia.org/wiki/Password">密码&lt;/a> 被用作加密密钥，然后在精心设计的密码系统就不会这样使用它自己。这是因为密码往往是人类可读的，因此可能不是特别强。作为补偿，一个好的加密系统将不使用_密码作为密钥_来执行主要的加密任务本身，而是充当&lt;a href="https://en.wikipedia.org/wiki/Key_derivation_function">密钥派生功能&lt;/a>（KDF）的输入。该 KDF 使用密码作为起点，然后它将从该起点本身生成实际的安全加密密钥。世代可以使用各种方法，例如添加盐和拉伸键。&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>Encoding(编码)&lt;/strong> # 将数据的原始格式，转换为便于存储的格式&lt;/p>
&lt;p>**Decoding(解码) **# 将存储的数据转换为原始格式以便使用&lt;/p>
&lt;p>&lt;strong>Encrypt(加密)&lt;/strong> # 使用 Key(密钥) 对信息进行编码的过程。&lt;/p>
&lt;p>&lt;strong>Decrypt(解密)&lt;/strong> # 使用 Key(密钥) 对信息进行解码的过程&lt;/p>
&lt;p>**Encoding(编码) 与 Encrypt(加密) 的区别 **#&lt;/p>
&lt;ul>
&lt;li>编码使用公开的方案，将数据转换为另一种格式，便于维护数据与传播。任何人都可以使用相同的编码规范，解码数据&lt;/li>
&lt;li>加密使用私密的方法，将数据抓换为另一种格式，着重于数据的保密。只有拥有相同 Key 的人才可以使用相同的加密规范，解密数据&lt;/li>
&lt;li>总结：编码和加密都是对格式的一种转换，但是它们是有区别的。&lt;strong>编码是公开的&lt;/strong>，比如 Base 64 编码，任何人都可以解码；&lt;strong>而加密则相反，你只希望自己或者特定的人才可以对内容进行解密。&lt;/strong>&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>Signature(签名)&lt;/strong> # 非对称加密中，使用私钥进行数字签名的行为。&lt;/p>
&lt;p>&lt;strong>Verifying(验证)&lt;/strong> # 非对称加密中，使用公钥验证数字签名的行为。&lt;/p>
&lt;p>&lt;strong>Digital Signature(数字签名)&lt;/strong> # &lt;a href="https://en.wikipedia.org/wiki/Digital_signature">详见 Wiki&lt;/a>**。**用于检验数字消息或文件的真实性的数学方案&lt;/p>
&lt;p>**Public Key Cryptography Standards(非对称密钥加密标准，简称 PKCS) **# &lt;a href="https://en.wikipedia.org/wiki/PKCS">详见 Wiki&lt;/a>。该标准指定了使用公开密钥加密技术时所应该遵守的标准&lt;/p>
&lt;p>&lt;strong>Public Key Infrastructure(非对称密钥基础设施，简称 PKI)&lt;/strong> # &lt;a href="https://en.wikipedia.org/wiki/Public_key_infrastructure">详见 Wiki&lt;/a>。一个包括硬件、软件、人员、策略和规程的集合，用来实现基于公钥密码体制的密钥和证书的产生、管理、存储、分发和撤销等功能。&lt;/p>
&lt;p>&lt;strong>Secure Hash Algorithm(安全哈希算法，简称 SHA)&lt;/strong> # &lt;/p></description></item><item><title>Docs: X.509</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/7.%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8/cryptography%E5%AF%86%E7%A0%81%E5%AD%A6/%E5%85%AC%E5%BC%80%E5%AF%86%E9%92%A5%E5%8A%A0%E5%AF%86/%E8%AF%81%E4%B9%A6-%E4%B8%8E-pki/x.509/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/7.%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8/cryptography%E5%AF%86%E7%A0%81%E5%AD%A6/%E5%85%AC%E5%BC%80%E5%AF%86%E9%92%A5%E5%8A%A0%E5%AF%86/%E8%AF%81%E4%B9%A6-%E4%B8%8E-pki/x.509/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/X.509">Wiki,X.509&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://datatracker.ietf.org/doc/html/rfc5280">RFC,5280&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://arthurchiao.art/blog/everything-about-pki-zh/">Arthurchiao 博客,[译] 写给工程师：关于证书（certificate）和公钥基础设施（PKI）的一切（SmallStep, 2018）&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://datatracker.ietf.org/doc/html/rfc5280">RFC 5280,Internet X.509 PKI 证书和 CRL 配置文件&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>X.509 是&lt;a href="https://www.yuque.com/go/doc/33178368">密码学&lt;/a>里定义公钥证书格式的&lt;strong>标准&lt;/strong>。X.509 格式的证书已应用在包括 TSL/SSL 在内的众多网络协议里，它是 HTTPS 的基础。&lt;/p>
&lt;p>在大部分时候，人们提到证书而没有加额外的限定词时，通常都是指 X.509 v3 证书。&lt;/p>
&lt;ul>
&lt;li>更准确的说，是 RFC 5280 中描述、 CA/Browser Forum &lt;a href="https://cabforum.org/baseline-requirements-documents/">Baseline Requirements&lt;/a>中进一步完善的 PKIX 变种。&lt;/li>
&lt;li>也可以说，指的是浏览器理解并用来做 HTTPS 的那些证书。&lt;/li>
&lt;li>也是那些具有通过 HTTP + TLS 协议交互的程序们所使用的证书&lt;/li>
&lt;/ul>
&lt;p>当然，全世界并不是只有 X.509 这一种格式，SSH 和 PGP 都有其各自的格式。&lt;/p>
&lt;p>X.509 在 1988 年作为 ITU(国际电信联盟) X.500 项目的一部分首次标准化。 这是 telecom(通信) 领域的标准，想通过它构建一个 global telephone book(全球电话簿)。 虽然这个项目没有成功，但却留下了一些遗产，X.509 就是其中之一。如果查看 X.509 的证书，会看到其中包含了 locality、state、country 等信息， 之前可能会有疑问为什么为 web 设计的证书会有这些东西，现在应该明白了，因为 X.509 并不是为 web 设计的。
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/puor14/1635944301557-e8774c02-d1c8-4e0f-9f7a-a2c3a7180ce0.png" alt="image.png">
图片补充：可以说 Subject 其实就是符合 &lt;a href="https://en.wikipedia.org/wiki/Lightweight_Directory_Access_Protocol#Directory_structure">Distinguished Name(专有名称，简称 DN)&lt;/a> 的规范，只不过 Subject 只是包含了 DN 中的部分字段罢了。也可以说，&lt;strong>Subject 是符合 X.509 标准的 DN。&lt;/strong>&lt;/p>
&lt;h1 id="x509-证书的格式">X.509 证书的格式&lt;/h1>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/puor14/1635931450920-fd8cad72-9ee7-476a-96ef-5e6ed60cc52b.png" alt="image.png">
&lt;strong>Certificate: &lt;!-- raw HTML omitted -->&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>**Data: &lt;!-- raw HTML omitted --> **# 证书的数据
&lt;ul>
&lt;li>&lt;strong>Version: STRING&lt;/strong> # 版本号&lt;/li>
&lt;li>**Serial Number: STRING **# 序列号&lt;/li>
&lt;li>&lt;strong>Signature Algorithm: STRING&lt;/strong> # 签名算法&lt;/li>
&lt;li>&lt;strong>Issuer: STRING&lt;/strong> # 发行人名称，也就是这个证书的签发者。&lt;/li>
&lt;li>**Validity: &lt;!-- raw HTML omitted --> **# 有效期
&lt;ul>
&lt;li>**Not Before: STRING **# 不能早于该日期。即证书从本日期开始生效&lt;/li>
&lt;li>**Not After: STRING **# 不能晚于该日期。即证书到本日期为止失效&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>**Subject: STRING **# 主体信息。如何 X.509 规范的 Distinguished Name。
&lt;ul>
&lt;li>对于 CA 证书来说， Subject 与 Issuer 的值相同。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>**Subject Public Key Info: **# 主体的公钥信息
&lt;ul>
&lt;li>**Public Key Algorithm: STRING **# 公钥算法&lt;/li>
&lt;li>&lt;strong>主体的公钥&lt;/strong>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>Issuer Unique Identifier:&lt;/strong> # 颁发者唯一身份信息（可选项）&lt;/li>
&lt;li>&lt;strong>Subject Unique Identifier:&lt;/strong> # 主体唯一身份信息（可选项）&lt;/li>
&lt;li>&lt;strong>Extensions: &lt;!-- raw HTML omitted -->&lt;/strong> # 扩展信息（可选项）
&lt;ul>
&lt;li>&amp;hellip;&amp;hellip;&lt;/li>
&lt;li>&lt;strong>X509v3 Subject Alternative Name:&lt;/strong> # SAN 信息。常用来作为该证书的名称。&lt;/li>
&lt;li>&amp;hellip;&amp;hellip;&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>**Signature Algorithm: STRING **# 证书签名算法&lt;/li>
&lt;li>证书签名&lt;/li>
&lt;/ul>
&lt;p>证书的 Issuer 和证书的 Subject 用 X.509 DN 表示，DN 是由 RDN 构成的序列。RDN 用“属性类型=属性值”的形式表示。常用的属性类型名称以及简写如下：&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>属性类型名称&lt;/th>
&lt;th>含义&lt;/th>
&lt;th>简写&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>Common Name&lt;/td>
&lt;td>通用名称&lt;/td>
&lt;td>CN&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Organizational Unit name&lt;/td>
&lt;td>机构单元名称&lt;/td>
&lt;td>OU&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Organization name&lt;/td>
&lt;td>机构名&lt;/td>
&lt;td>O&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Locality&lt;/td>
&lt;td>地理位置&lt;/td>
&lt;td>L&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>State or province name&lt;/td>
&lt;td>州/省名&lt;/td>
&lt;td>S&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Country&lt;/td>
&lt;td>国名&lt;/td>
&lt;td>C&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h2 id="dn-与-san-命名的历史包袱">DN 与 SAN 命名的历史包袱&lt;/h2>
&lt;h3 id="dn-distinguished-names">DN (distinguished names)&lt;/h3>
&lt;p>历史上，X.509 使用 X.500 distinguished names (DN) 来命名证书的使用者（name the subject of a certificate），即 subscriber。 一个 DN 包含了一个 common name （对作者我来说，就是 “Mike Malone”），此外还可以包含 locality、country、organization、organizational unit 及其他一些东西（数字电话簿相关）。&lt;/p>
&lt;ul>
&lt;li>没人理解 DN，它在互联网上也没什么意义。&lt;/li>
&lt;li>应该避免使用 DN。如果真的要用，也要尽量保持简单。&lt;/li>
&lt;li>无需使用全部字段，实际上，也不应该使用全部字段。&lt;/li>
&lt;li>common name 可能就是需要用到的全部字段了，如果你是一个 thrill seeker ，可以在用上一个 organization name。&lt;/li>
&lt;/ul>
&lt;p>PKIX 规定一个网站的 DNS hostname 应该关联到 DN common name。最近，CAB Forum 已 经废弃了这个规定，使整个 DN 字段变成可选的（Baseline Requirements, sections 7.1.4.2）。&lt;/p>
&lt;h3 id="san-subject-alternative-name">SAN (subject alternative name)&lt;/h3>
&lt;p>在 &lt;a href="https://tools.ietf.org/html/rfc5280#section-4.2.1.6">RFC 5280 的 4.2.1.6 部分&lt;/a>中，推荐的现代最佳实践是使用 &lt;strong>证书扩展中的 subject alternative name(SAN)&lt;/strong> 来绑定证书中的 name。&lt;/p>
&lt;p>常用的 SAN 有四种类型，绑定的都是广泛使用的名字：&lt;/p>
&lt;ul>
&lt;li>domain names (DNS)&lt;/li>
&lt;li>email addresse&lt;/li>
&lt;li>IP addresse&lt;/li>
&lt;li>URI&lt;/li>
&lt;/ul>
&lt;p>在我们讨论的上下文中，这些都是唯一的，而且它们能很好地映射到我们想识别的东西：&lt;/p>
&lt;ul>
&lt;li>email addresses for people&lt;/li>
&lt;li>domain names and IP addresses for machines and code,&lt;/li>
&lt;li>URIs if you want to get fancy&lt;/li>
&lt;/ul>
&lt;p>应该使用 SAN。
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/puor14/1638258551706-2b7a5b62-a093-4b12-8b34-7c6b9eefe49b.png" alt="image.png">
注意，Web PKI 允许在一个证书内 bind 多个 name，name 也允许通配符。也就是说，&lt;/p>
&lt;ul>
&lt;li>一个证书可以有多个 SNA，也可以有类似 *.smallstep.com 这样的 SAN。&lt;/li>
&lt;li>这对有多个域名的的网站来说很有用。&lt;/li>
&lt;/ul>
&lt;h1 id="证书扩展名与编码">证书扩展名与编码&lt;/h1>
&lt;p>通常，为了便于传输，需要为证书进行编码。就好比传输 JSON 数据时，也需要对其进行编码，收到后再解码。&lt;/p>
&lt;p>一般情况下，X.509 格式证书的原始数据，会使用 ASN.1 的 DER 进行编码，将编码后的二进制数据再使用根据 PEM 格式使用 Base64 编码，然后就会生成 PEM 格式的证书数据，实际上，所谓的 X.509 格式的文件，其实就是具有 CERTIFICATE 标志的 PEM 格式文件。&lt;/p>
&lt;ul>
&lt;li>可以将 ASN.1 理解成 X.509 的 JSON&lt;/li>
&lt;li>但是实际上，更像是 protobuf、thrift 或 SQL DDL。说白了就是通过一种算法，将人类可读的明文的证书编码成另一种便于传输的格式。&lt;/li>
&lt;/ul>
&lt;h2 id="oid">OID&lt;/h2>
&lt;p>ASN.1 除了有常见的数据类型，如整形、字符串、集合、列表等， 还有一个&lt;strong>不常见但很重要的类型：OID&lt;/strong>（object identifier，&lt;strong>对象标识符&lt;/strong>）。&lt;/p>
&lt;ul>
&lt;li>OID &lt;strong>与 URI 有些像&lt;/strong>，但比 URI 要怪。&lt;/li>
&lt;li>OID （在设计上）是&lt;strong>全球唯一标识符&lt;/strong>。&lt;/li>
&lt;li>在结构上，OID 是在一个 hierarchical namespace 中的一个整数序列（例如 2.5.4.3）。&lt;/li>
&lt;/ul>
&lt;p>可以用 OID 来 tag 一段数据的类型。例如，一个 string 本来只是一个 string，但可 以 tag 一个 OID 2.5.4.3，然后就&lt;strong>变成了一个特殊 string&lt;/strong>：这是 &lt;strong>X.509 的通用名字（common name）&lt;/strong> 字段。
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/puor14/1638343160689-8e109cf9-cb84-4a14-94fb-99421dab444c.png" alt="oids.png">&lt;/p>
&lt;h2 id="证书的扩展名">证书的扩展名&lt;/h2>
&lt;p>X.509 有多种常用的扩展名。不过其中的一些还用于其它用途，就是说具有这个扩展名的文件可能并不是证书，比如说可能只是保存了私钥。&lt;/p>
&lt;ul>
&lt;li>.pem # 将使用 DER 格式编码的内容，再通过 PEM 进行 Base64 编码，得出来的数据存放在&amp;quot;&amp;mdash;&amp;ndash;BEGIN CERTIFICATE&amp;mdash;&amp;ndash;&amp;ldquo;和&amp;rdquo;&amp;mdash;&amp;ndash;END CERTIFICATE&amp;mdash;&amp;ndash;&amp;ldquo;之中&lt;/li>
&lt;li>.cer, .crt, .der – 通常是 DER 二进制格式的，但 Base64 编码后也很常见。&lt;/li>
&lt;li>.p7b, .p7c – PKCS#7 SignedData structure without data, just certificate(s) or CRL(s)&lt;/li>
&lt;li>.p12 – PKCS#12 格式，包含证书的同时可能还有带密码保护的私钥&lt;/li>
&lt;li>.pfx – PFX，PKCS#12 之前的格式（通常用 PKCS#12 格式，比如那些由 IIS 产生的 PFX 文件）&lt;/li>
&lt;/ul>
&lt;p>更多的编码信息见：
[密钥/证书 的编码](✏IT 学习笔记/🔐7.信息安全/Cryptography(密码学)/公开密钥加密/密钥_证书%20 的编码.md 的编码.md)&lt;/p>
&lt;h1 id="证书示例">证书示例&lt;/h1>
&lt;h3 id="终端实体证书">终端实体证书&lt;/h3>
&lt;p>这是 wikipedia.org 和其他几个维基百科网站使用的解码 X.509 证书的示例。它由 &lt;a href="https://en.wikipedia.org/wiki/GlobalSign">GlobalSign&lt;/a> 颁发，如 &lt;code>Issuer&lt;/code> 字段中所述。它的 &lt;code>Subject&lt;/code> 字段将维基百科描述为一个组织，它的 &lt;code>Subject Alternative Name&lt;/code> 字段描述了可以使用它的域名。主题公钥信息字段包含一个&lt;a href="https://en.wikipedia.org/wiki/ECDSA">ECDSA&lt;/a>公钥，而底部的签名是由 GlobalSign 的&lt;a href="https://en.wikipedia.org/wiki/RSA_(cryptosystem)">RSA&lt;/a>私钥生成的。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>Certificate:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Data:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e"># 证书版本&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Version: &lt;span style="color:#ae81ff">3&lt;/span> &lt;span style="color:#f92672">(&lt;/span>0x2&lt;span style="color:#f92672">)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e"># 序列号&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Serial Number:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> 10:e6:fc:62:b7:41:8a:d5:00:5e:45:b6
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e"># 证书的签名算法&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Signature Algorithm: sha256WithRSAEncryption
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e"># 证书的颁发者信息。CA 证书的 Issuer 与 Subject 相同&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Issuer: C&lt;span style="color:#f92672">=&lt;/span>BE, O&lt;span style="color:#f92672">=&lt;/span>GlobalSign nv-sa, CN&lt;span style="color:#f92672">=&lt;/span>GlobalSign Organization Validation CA - SHA256 - G2
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e"># 证书有效期&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Validity
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Not Before: Nov &lt;span style="color:#ae81ff">21&lt;/span> 08:00:00 &lt;span style="color:#ae81ff">2016&lt;/span> GMT
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Not After : Nov &lt;span style="color:#ae81ff">22&lt;/span> 07:59:59 &lt;span style="color:#ae81ff">2017&lt;/span> GMT
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e"># 证书主体信息。i.e.该证书颁发给谁&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Subject: C&lt;span style="color:#f92672">=&lt;/span>US, ST&lt;span style="color:#f92672">=&lt;/span>California, L&lt;span style="color:#f92672">=&lt;/span>San Francisco, O&lt;span style="color:#f92672">=&lt;/span>Wikimedia Foundation, Inc., CN&lt;span style="color:#f92672">=&lt;/span>*.wikipedia.org
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e"># 证书公钥信息&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Subject Public Key Info:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e"># 证书主体的公钥算法&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Public Key Algorithm: id-ecPublicKey
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Public-Key: &lt;span style="color:#f92672">(&lt;/span>&lt;span style="color:#ae81ff">256&lt;/span> bit&lt;span style="color:#f92672">)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> pub:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> 00:c9:22:69:31:8a:d6:6c:ea:da:c3:7f:2c:ac:a5:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> af:c0:02:ea:81:cb:65:b9:fd:0c:6d:46:5b:c9:1e:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> 9d:3b:ef
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ASN1 OID: prime256v1
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> NIST CURVE: P-256
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e"># X509 v3版本的扩展信息&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> X509v3 extensions:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e"># 密钥用法：critical级别。包括数字签名、密钥加密&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> X509v3 Key Usage: critical
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Digital Signature, Key Agreement
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Authority Information Access:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> CA Issuers - URI:http://secure.globalsign.com/cacert/gsorganizationvalsha2g2r1.crt
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> OCSP - URI:http://ocsp2.globalsign.com/gsorganizationvalsha2g2
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> X509v3 Certificate Policies:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Policy: 1.3.6.1.4.1.4146.1.20
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> CPS: https://www.globalsign.com/repository/
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Policy: 2.23.140.1.2.2
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> X509v3 Basic Constraints:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> CA:FALSE
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> X509v3 CRL Distribution Points:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Full Name:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> URI:http://crl.globalsign.com/gs/gsorganizationvalsha2g2.crl
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e"># 证书主体名称的替代名称。i.e.别名&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> X509v3 Subject Alternative Name:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> DNS:*.wikipedia.org, DNS:*.m.mediawiki.org, DNS:*.m.wikibooks.org, DNS:*.m.wikidata.org, DNS:*.m.wikimedia.org, DNS:*.m.wikimediafoundation.org, DNS:*.m.wikinews.org, DNS:*.m.wikipedia.org, DNS:*.m.wikiquote.org, DNS:*.m.wikisource.org, DNS:*.m.wikiversity.org, DNS:*.m.wikivoyage.org, DNS:*.m.wiktionary.org, DNS:*.mediawiki.org, DNS:*.planet.wikimedia.org, DNS:*.wikibooks.org, DNS:*.wikidata.org, DNS:*.wikimedia.org, DNS:*.wikimediafoundation.org, DNS:*.wikinews.org, DNS:*.wikiquote.org, DNS:*.wikisource.org, DNS:*.wikiversity.org, DNS:*.wikivoyage.org, DNS:*.wiktionary.org, DNS:*.wmfusercontent.org, DNS:*.zero.wikipedia.org, DNS:mediawiki.org, DNS:w.wiki, DNS:wikibooks.org, DNS:wikidata.org, DNS:wikimedia.org, DNS:wikimediafoundation.org, DNS:wikinews.org, DNS:wikiquote.org, DNS:wikisource.org, DNS:wikiversity.org, DNS:wikivoyage.org, DNS:wiktionary.org, DNS:wmfusercontent.org, DNS:wikipedia.org
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e"># 扩展密钥用法&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> X509v3 Extended Key Usage:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> TLS Web Server Authentication, TLS Web Client Authentication
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> X509v3 Subject Key Identifier:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> 28:2A:26:2A:57:8B:3B:CE:B4:D6:AB:54:EF:D7:38:21:2C:49:5C:36
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> X509v3 Authority Key Identifier:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> keyid:96:DE:61:F1:BD:1C:16:29:53:1C:C0:CC:7D:3B:83:00:40:E6:1A:7C
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e"># 证书的签名算法及其标识符&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Signature Algorithm: sha256WithRSAEncryption
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> 8b:c3:ed:d1:9d:39:6f:af:40:72:bd:1e:18:5e:30:54:23:35:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ...
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="中级证书">中级证书&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>Certificate:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Data:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Version: &lt;span style="color:#ae81ff">3&lt;/span> &lt;span style="color:#f92672">(&lt;/span>0x2&lt;span style="color:#f92672">)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Serial Number:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> 04:00:00:00:00:01:44:4e:f0:42:47
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Signature Algorithm: sha256WithRSAEncryption
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Issuer: C&lt;span style="color:#f92672">=&lt;/span>BE, O&lt;span style="color:#f92672">=&lt;/span>GlobalSign nv-sa, OU&lt;span style="color:#f92672">=&lt;/span>Root CA, CN&lt;span style="color:#f92672">=&lt;/span>GlobalSign Root CA
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Validity
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Not Before: Feb &lt;span style="color:#ae81ff">20&lt;/span> 10:00:00 &lt;span style="color:#ae81ff">2014&lt;/span> GMT
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Not After : Feb &lt;span style="color:#ae81ff">20&lt;/span> 10:00:00 &lt;span style="color:#ae81ff">2024&lt;/span> GMT
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Subject: C&lt;span style="color:#f92672">=&lt;/span>BE, O&lt;span style="color:#f92672">=&lt;/span>GlobalSign nv-sa, CN&lt;span style="color:#f92672">=&lt;/span>GlobalSign Organization Validation CA - SHA256 - G2
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Subject Public Key Info:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Public Key Algorithm: rsaEncryption
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Public-Key: &lt;span style="color:#f92672">(&lt;/span>&lt;span style="color:#ae81ff">2048&lt;/span> bit&lt;span style="color:#f92672">)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Modulus:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> 00:c7:0e:6c:3f:23:93:7f:cc:70:a5:9d:20:c3:0e:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ...
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Exponent: &lt;span style="color:#ae81ff">65537&lt;/span> &lt;span style="color:#f92672">(&lt;/span>0x10001&lt;span style="color:#f92672">)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> X509v3 extensions:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> X509v3 Key Usage: critical
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Certificate Sign, CRL Sign
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> X509v3 Basic Constraints: critical
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> CA:TRUE, pathlen:0
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> X509v3 Subject Key Identifier:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> 96:DE:61:F1:BD:1C:16:29:53:1C:C0:CC:7D:3B:83:00:40:E6:1A:7C
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> X509v3 Certificate Policies:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Policy: X509v3 Any Policy
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> CPS: https://www.globalsign.com/repository/
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> X509v3 CRL Distribution Points:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Full Name:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> URI:http://crl.globalsign.net/root.crl
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Authority Information Access:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> OCSP - URI:http://ocsp.globalsign.com/rootr1
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> X509v3 Authority Key Identifier:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> keyid:60:7B:66:1A:45:0D:97:CA:89:50:2F:7D:04:CD:34:A8:FF:FC:FD:4B
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Signature Algorithm: sha256WithRSAEncryption
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> 46:2a:ee:5e:bd:ae:01:60:37:31:11:86:71:74:b6:46:49:c8:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ...
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="根证书">根证书&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>Certificate:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Data:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Version: &lt;span style="color:#ae81ff">3&lt;/span> &lt;span style="color:#f92672">(&lt;/span>0x2&lt;span style="color:#f92672">)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Serial Number:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> 04:00:00:00:00:01:15:4b:5a:c3:94
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Signature Algorithm: sha1WithRSAEncryption
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Issuer: C&lt;span style="color:#f92672">=&lt;/span>BE, O&lt;span style="color:#f92672">=&lt;/span>GlobalSign nv-sa, OU&lt;span style="color:#f92672">=&lt;/span>Root CA, CN&lt;span style="color:#f92672">=&lt;/span>GlobalSign Root CA
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Validity
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Not Before: Sep &lt;span style="color:#ae81ff">1&lt;/span> 12:00:00 &lt;span style="color:#ae81ff">1998&lt;/span> GMT
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Not After : Jan &lt;span style="color:#ae81ff">28&lt;/span> 12:00:00 &lt;span style="color:#ae81ff">2028&lt;/span> GMT
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Subject: C&lt;span style="color:#f92672">=&lt;/span>BE, O&lt;span style="color:#f92672">=&lt;/span>GlobalSign nv-sa, OU&lt;span style="color:#f92672">=&lt;/span>Root CA, CN&lt;span style="color:#f92672">=&lt;/span>GlobalSign Root CA
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Subject Public Key Info:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Public Key Algorithm: rsaEncryption
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Public-Key: &lt;span style="color:#f92672">(&lt;/span>&lt;span style="color:#ae81ff">2048&lt;/span> bit&lt;span style="color:#f92672">)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Modulus:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> 00:da:0e:e6:99:8d:ce:a3:e3:4f:8a:7e:fb:f1:8b:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ...
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Exponent: &lt;span style="color:#ae81ff">65537&lt;/span> &lt;span style="color:#f92672">(&lt;/span>0x10001&lt;span style="color:#f92672">)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> X509v3 extensions:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> X509v3 Key Usage: critical
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Certificate Sign, CRL Sign
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> X509v3 Basic Constraints: critical
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> CA:TRUE
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> X509v3 Subject Key Identifier:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> 60:7B:66:1A:45:0D:97:CA:89:50:2F:7D:04:CD:34:A8:FF:FC:FD:4B
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Signature Algorithm: sha1WithRSAEncryption
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> d6:73:e7:7c:4f:76:d0:8d:bf:ec:ba:a2:be:34:c5:28:32:b5:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ...
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h1 id="x509-格式证书数据示例">X.509 格式证书数据示例&lt;/h1>
&lt;h2 id="pem-格式数据">PEM 格式数据&lt;/h2>
&lt;p>从 &lt;code>-----BEGIN CERTIFICATE-----&lt;/code> 开始到 &lt;code>-----END CERTIFICATE-----&lt;/code> 为止是证书的明文格式经过 ASN.1 编码再经过 Base64 编码得到的。&lt;/p>
&lt;p>对于私钥文件，真正的私钥是包含在字符串 &lt;code>-----BEGIN PRIVATE KEY-----&lt;/code> 和字符串 &lt;code>-----END PRIVATE KEY-----&lt;/code> 之间。&lt;/p>
&lt;h2 id="原始数据">原始数据&lt;/h2>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">[&lt;/span>root@master-1 pki&lt;span style="color:#f92672">]&lt;/span>&lt;span style="color:#75715e"># openssl x509 -text -noout -in apiserver.crt&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Certificate:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Data:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Version: &lt;span style="color:#ae81ff">3&lt;/span> &lt;span style="color:#f92672">(&lt;/span>0x2&lt;span style="color:#f92672">)&lt;/span> &lt;span style="color:#75715e"># 证书版本&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Serial Number: &lt;span style="color:#ae81ff">0&lt;/span> &lt;span style="color:#f92672">(&lt;/span>0x0&lt;span style="color:#f92672">)&lt;/span> &lt;span style="color:#75715e"># 序列号&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Signature Algorithm: sha256WithRSAEncryption &lt;span style="color:#75715e"># 证书的签名算法&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Issuer: CN&lt;span style="color:#f92672">=&lt;/span>kubernetes &lt;span style="color:#75715e"># 证书的颁发者信息。CA证书的Issuer与Subject相同&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Validity &lt;span style="color:#75715e"># 证书有效期&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Not Before: Nov &lt;span style="color:#ae81ff">20&lt;/span> 08:45:23 &lt;span style="color:#ae81ff">2019&lt;/span> GMT
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Not After : Nov &lt;span style="color:#ae81ff">17&lt;/span> 08:45:23 &lt;span style="color:#ae81ff">2029&lt;/span> GMT
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Subject: CN&lt;span style="color:#f92672">=&lt;/span>kube-apiserver &lt;span style="color:#75715e"># 证书主体信息。i.e.该证书颁发给谁&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Subject Public Key Info: &lt;span style="color:#75715e"># 证书公钥信息&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Public Key Algorithm: rsaEncryption &lt;span style="color:#75715e"># 证书主体的公钥算法&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Public-Key: &lt;span style="color:#f92672">(&lt;/span>&lt;span style="color:#ae81ff">2048&lt;/span> bit&lt;span style="color:#f92672">)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Modulus:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> 00:c7:2e:02:61:db:b0:24:db:22:aa:46:94:de:7e:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .......
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Exponent: &lt;span style="color:#ae81ff">65537&lt;/span> &lt;span style="color:#f92672">(&lt;/span>0x10001&lt;span style="color:#f92672">)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> X509v3 extensions: &lt;span style="color:#75715e"># X509 v3版本的扩展信息&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> X509v3 Key Usage: critical &lt;span style="color:#75715e"># 密钥用法：critical级别。包括数字签名、密钥加密&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Digital Signature, Key Encipherment
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> X509v3 Extended Key Usage: &lt;span style="color:#75715e"># 扩展密钥用法&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> TLS Web Server Authentication
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> X509v3 Subject Alternative Name: &lt;span style="color:#75715e"># 证书主体名称的替代名称。i.e.别名&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> DNS:master-1.k8s.cloud.tjiptv.net, DNS:kubernetes, DNS:kubernetes.default, DNS:kubernetes.default.svc, DNS:kubernetes.default.svc.cluster.local, IP Address:10.96.0.1, IP Address:10.10.9.51, IP Address:10.10.9.54
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Signature Algorithm: sha256WithRSAEncryption &lt;span style="color:#75715e"># 证书的签名算法及其标识符&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> 47:38:42:cf:02:85:71:49:ac:19:9c:ba:3a:f3:74:c3:4b:09:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .....
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div></description></item><item><title>Docs: 对称密码加密</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/7.%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8/cryptography%E5%AF%86%E7%A0%81%E5%AD%A6/%E5%AF%B9%E7%A7%B0%E5%AF%86%E7%A0%81%E5%8A%A0%E5%AF%86/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/7.%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8/cryptography%E5%AF%86%E7%A0%81%E5%AD%A6/%E5%AF%B9%E7%A7%B0%E5%AF%86%E7%A0%81%E5%8A%A0%E5%AF%86/</guid><description/></item><item><title>Docs: 公开密钥加密</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/7.%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8/cryptography%E5%AF%86%E7%A0%81%E5%AD%A6/%E5%85%AC%E5%BC%80%E5%AF%86%E9%92%A5%E5%8A%A0%E5%AF%86/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/7.%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8/cryptography%E5%AF%86%E7%A0%81%E5%AD%A6/%E5%85%AC%E5%BC%80%E5%AF%86%E9%92%A5%E5%8A%A0%E5%AF%86/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Public-key_cryptography">Wiki,PKC 英文&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Digital_signature">Wiki,数字签名&lt;/a>&lt;/li>
&lt;li>&lt;a href="http://www.ruanyifeng.com/blog/2013/06/rsa_algorithm_part_one.html">阮一峰&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.zhihu.com/question/25912483">知乎,RSA 的公钥和私钥到底那个才是用来加密和哪个用来解密&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://zh.wikipedia.org/wiki/%E5%85%AC%E5%BC%80%E5%AF%86%E9%92%A5%E5%8A%A0%E5%AF%86">Wiki, 公开密钥加密 中文&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://arthurchiao.art/blog/everything-about-pki-zh">https://arthurchiao.art/blog/everything-about-pki-zh&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;hr>
&lt;ul>
&lt;li>甲方选择某种加密规则，对信息进行加密&lt;/li>
&lt;li>乙方使用同一种规则，对信息进行解密&lt;/li>
&lt;/ul>
&lt;p>由于加密和解密使用同样规则（简称&amp;quot;密钥&amp;quot;），这被称为 Symmetric-key algorithm(对称密钥算法)。这种加密模式有一个最大弱点：甲方必须把加密规则告诉乙方，否则无法解密。保存和传递密钥，就成了最头疼的问题。因为大多数情况下，其实两方之间的通信，只有一方是需要加密的，另一方只需要知道信息内容。&lt;/p>
&lt;p>1976 年，两位美国计算机学家 Whitfield Diffie 和 Martin Hellman，提出了一种崭新构思，可以在不直接传递密钥的情况下，完成解密。这被称为&amp;quot;Diffie-Hellman 密钥交换算法&amp;quot;。这个算法启发了其他科学家。人们认识到，加密和解密可以使用不同的规则，只要这两种规则之间存在某种对应关系即可，这样就避免了直接传递密钥。&lt;/p>
&lt;p>这种新的加密模式就被称为&amp;quot;非对称密钥算法&amp;quot;。&lt;/p>
&lt;blockquote>
&lt;p>（1）乙方生成两把密钥（公钥和私钥）。公钥是公开的，任何人都可以获得，私钥则是保密的。
（2）甲方获取乙方的公钥，然后用它对信息加密。
（3）乙方得到加密后的信息，用私钥解密。&lt;/p>
&lt;/blockquote>
&lt;p>如果公钥加密的信息只有私钥解得开，那么只要私钥不泄漏，通信就是安全的。&lt;/p>
&lt;p>1977 年，三位数学家 Rivest、Shamir 和 Adleman 设计了一种算法，可以实现非对称加密。这种算法用他们三个人的名字命名，叫做 RSA 算法。从那时直到现在，RSA 算法一直是最广为使用的&amp;quot;非对称加密算法&amp;quot;。毫不夸张地说，只要有计算机网络的地方，就有 RSA 算法。&lt;/p>
&lt;p>这种算法非常可靠，密钥越长，它就越难破解。根据已经披露的文献，目前被破解的最长 RSA 密钥是 768 个二进制位。也就是说，长度超过 768 位的密钥，还无法破解（至少没人公开宣布）。因此可以认为，1024 位的 RSA 密钥基本安全，2048 位的密钥极其安全。&lt;/p>
&lt;h2 id="pkc-特点">PKC 特点&lt;/h2>
&lt;ul>
&lt;li>这种加密方式，需要一对密钥。只有公钥可以加密，私钥不能用来加密数据。&lt;/li>
&lt;li>&lt;strong>Public key(公钥)&lt;/strong> # 公开给所有人。用来&lt;strong>加密数据&lt;/strong>、&lt;strong>验证签名&lt;/strong>。使用公钥把明文加密后所得的密文，只能使用对应的私钥才能解密并得到原本的密文。反之不行。&lt;/li>
&lt;li>&lt;strong>Secret key(私钥)&lt;/strong> # 自己留存，必须保证其私密性。用来&lt;strong>解密数据&lt;/strong>、&lt;strong>签名&lt;/strong>。使用私钥创建数字签名，只能使用公钥才能验证该数字签名的有效性。反之不行。
&lt;ul>
&lt;li>一般情况，密钥对是通过程序自动生成的。首先生成私钥后，公钥包含在私钥当中&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>Digital signature(数字签名)&lt;/strong>。签名提供的是真实性，而不是保密性。
&lt;ul>
&lt;li>所谓的数字签名，就像人们日常生活中在文件上签字一样，都是签名的一种。&lt;/li>
&lt;li>而所谓的验证签名，其实就像日常生活中，看看签名的人的笔记与签名是否一致，等等类似的行为&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>总结一下：既然是加密，那肯定是不希望别人知道发送给我的消息，所以只有我才能解密，所以可得出&lt;strong>公钥负责加密，私钥负责解密&lt;/strong>；同理，既然是签名，那肯定是不希望有人冒充我发消息，只有我才能发布这个签名，所以可得出&lt;strong>私钥负责签名，公钥负责验证&lt;/strong>。&lt;/p>
&lt;ul>
&lt;li>这种加密方式由于是单向加密、单向解密，所以如果双方都想要加密，则需要两对密钥，双方各自用对方的公钥加密信息发送给对方，然后双方再用自己的私钥解密阅读信息。&lt;/li>
&lt;/ul>
&lt;h2 id="signature签名">Signature(签名)&lt;/h2>
&lt;p>&lt;strong>Signature(签名)&lt;/strong> 的前身是 &lt;strong>Message Authentication Code(消息认证码，简称 MAC)，&lt;strong>都是用来验证某个 Entity(实体) 发送的消息&lt;/strong>没有被篡改&lt;/strong>。&lt;/p>
&lt;p>MAC 的原理：
图片来源：&lt;a href="https://www.okta.com/identity-101/hmac/">https://www.okta.com/identity-101/hmac/&lt;/a>
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/eq9he4/1634100917764-014705d7-d376-4fa1-ba43-e1811f54023a.png" alt="image.png">&lt;/p>
&lt;ul>
&lt;li>对 &lt;code>message(消息)&lt;/code> 和 &lt;code>shared secret，a password(双方都知道的一个密码)&lt;/code> 做哈希，得到的哈希值就是 MAC；&lt;/li>
&lt;li>发送方将消息连带 MAC 一起发给接收方；&lt;/li>
&lt;li>接收方收到消息之后，用同一个密码来计算 MAC，然后跟消息中提供的 MAC 对比。如果相同，就证明未被篡改。&lt;/li>
&lt;/ul>
&lt;p>关于哈希：&lt;/p>
&lt;ul>
&lt;li>哈希是单向的，因此无法从输出反推输入。这一点至关重要：否则截获消息的人就可以根据 MAC 和哈希函数反推出你的 secrets。&lt;/li>
&lt;li>此外，生成 MAC 的哈希算法选择也至关重要，本文不会展开，但 提醒一点：不要试图用自己设计的 MAC 算法。&lt;/li>
&lt;li>最常用的 MAC 算法是 &lt;a href="https://en.wikipedia.org/wiki/HMAC">HMAC&lt;/a>（hash-based message authentication code）。&lt;/li>
&lt;/ul>
&lt;p>但是 MAC 的缺点是：&lt;/p>
&lt;ul>
&lt;li>至少有两个 Entity 需要知道共享的密码，所以双方都可以生成 MAC，因此给定一个合法的 MAC，我们无法知道是谁生成的&lt;/li>
&lt;/ul>
&lt;p>为了解决这个问题，我们可以通过 PKC，使用私钥签名、公钥验签的方式避免 MAC 的缺点，这，就是 PKC 的 **Signature(签名) **功能。正因为对一个已经签名消息只能使用公钥验证，且只能使用对应的私钥生成。因此对于接收方来说，它只能验证签名是否合法，而无法生成同样的签名。&lt;/p>
&lt;p>如果只有一个 Entity 知道密钥，那么这种特性就称为 &lt;strong>non-repudiation(不可否认性)&lt;/strong>，即持有私钥的人无法否认数据是由他签名的这一事实。&lt;/p>
&lt;h3 id="总结">总结&lt;/h3>
&lt;p>MAC 与 signature 都叫做签名，是因为它们和现实世界中的签名是很像的。例如，如果想让某人同意某事，并且事后还能证明他们当时的确同意了，就把问题写下来，然后让他们 手写签字（签名）。&lt;/p>
&lt;p>通常人们常说的 &lt;strong>Digital signature(数字签名)&lt;/strong>，其实就是基于 PKC 的公钥与私钥这种非对称特点而实现的签名行为。只不过是数字的签名，该签名是存在与计算机世界中的数字形态~~~&lt;/p>
&lt;h2 id="总结-1">总结&lt;/h2>
&lt;p>公钥加密是数学给计算机科学的神秘礼物， &lt;a href="https://www.math.auckland.ac.nz/~sgal018/crypto-book/crypto-book.html">其数学基础&lt;/a> 显然很复杂，但如果只是使用，那并不理解它的每一步数学原理。 公钥加密使计算机能做一些之前无法做的事情：它们现在能看到对方是谁了。
这句话的意思是说，公钥加密使一台计算（或代码）能向其他计算机或程序证明， &lt;strong>不用直接分享某些信息，它也能知道该信息&lt;/strong>。更具体来说，&lt;/p>
&lt;ul>
&lt;li>以前要证明你有密码，就必须向别人展示这个密码。但展示之后，任何有这个密码的人就都能使用它了。&lt;/li>
&lt;li>私钥却与此不同。你能通过私钥对我的身份进行认证（authenticate my identity），但却无法假冒我。例如，你发给我一个大随机数，我对这个随机数进行签名，然后将再发送给你。 你能用公钥对这个签名进行认证，确认这个签名（消息）确实来自我。 这就是一种证明你在和我（而不是别的其他的人）通信的很好证据。这使得网络上的 计算机能有效地知道它们在和谁通信。这听起来是一件如此理所当然的事情，但仔细地想一下，网络上只有流动的 0 和 1， 你怎么知道消息来自谁，在和谁通信？因此公钥加密系统是一个非常伟大的发明。&lt;/li>
&lt;/ul>
&lt;h1 id="应用场景-与-缺点">应用场景 与 缺点&lt;/h1>
&lt;ul>
&lt;li>如果 A 持有私钥，B 持有对应公钥。那么此时 B 用对方的公钥加密一个对称密钥并发送给 A，A 使用私钥解密，以获得 B 发送的对称密钥，这时再发送的数据可以使用对称加密。&lt;/li>
&lt;li>在互联网的 C/S 架构场景中。Server 公开公钥，Client 使用公钥加密信息发送给 Server(发送密码等敏感信息)，Server 使用私钥解密后响应时，使用私钥签名，以便 Client 可以用公钥验证 Server 的真实性(防止钓鱼网站)。&lt;/li>
&lt;li>如图所示，Alice 在一条消息的末尾签了名，消息内容是 &lt;code>Hello Bob!&lt;/code>，这段签署的内容一般是对消息内容进行 hash 计算后，使用 Alice 的私钥的出来的。鲍勃同时收到消息和签名。他使用 Alice 的公钥来验证消息的真实性，即，如果使用公钥计算得出来的消息与原始消息完全匹配，那就证明，这条消息确实是 Alice 发送的。&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/eq9he4/1616125981836-028fe2ce-77f2-4929-91cc-559c4ce9cda1.png" alt="">
算法：&lt;/p>
&lt;ul>
&lt;li>RSA&lt;/li>
&lt;li>DSA&lt;/li>
&lt;li>ELGamal&lt;/li>
&lt;/ul>
&lt;h2 id="缺点">缺点&lt;/h2>
&lt;p>公钥加密可能出现的问题：当两者需要通信的时候，需要把公钥发送给对方，但是公钥是谁都可以获取的，那么在二者通信过程中，公钥就有可能被劫持，当公钥被劫持，劫持者把自己的公钥再发送给对方，那么双发再收到的信息，就是被劫持者篡改过的信息了。&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://www.yuque.com/go/doc/33177961">&lt;strong>Public Key Certificate(公钥证书)&lt;/strong>&lt;/a> 可以解决以上问题&lt;/li>
&lt;/ul>
&lt;h1 id="heading">&lt;/h1></description></item><item><title>Docs: 管理工具</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/7.%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8/%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/7.%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8/%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/</guid><description>
&lt;h1 id="acme">ACME&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://datatracker.ietf.org/doc/html/rfc8555">RFC,8555&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Automatic_Certificate_Management_Environment">Wiki,ACME&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>&lt;strong>Automatic Certificate Management Environment(自动证书管理环境，简称 ACME)&lt;/strong> 是一种通信协议，用于自动化证书颁发机构与其用户的 Web 服务器之间的交互，允许以非常低的成本自动部署 PKI。它是油 ISRG 为他们的 Let&amp;rsquo;s Encrypt 服务设计的。&lt;/p>
&lt;h2 id="acme-服务提供商">ACME 服务提供商&lt;/h2>
&lt;p>支持免费或低成本基于 ACME 的证书服务的提供商包括 &lt;a href="https://en.wikipedia.org/wiki/Let%27s_Encrypt">Let&amp;rsquo;s Encrypt&lt;/a>、&lt;a href="https://en.wikipedia.org/wiki/Buypass">Buypass&lt;/a> Go SSL、ZeroSSL 和 SSL.com。许多其他证书颁发机构和软件供应商提供 ACME 服务，作为 &lt;a href="https://en.wikipedia.org/wiki/Entrust">Entrust&lt;/a> 和 &lt;a href="https://en.wikipedia.org/wiki/DigiCert">DigiCert&lt;/a> 等付费 PKI 解决方案的一部分。&lt;/p>
&lt;h2 id="acme-的实现">ACME 的实现&lt;/h2>
&lt;p>想要实现自动签证书，要经过如下几个步骤&lt;/p>
&lt;ul>
&lt;li>验证要签名证书所使用的域名是属于我的。这个验证过程又有多种途径
&lt;ul>
&lt;li>&lt;strong>DNS 验证&lt;/strong> # 通过提供域名注册商的认证信息(比如 ak、sk)，ACME 程序将会从域名注册商处验证域名属于我的&lt;/li>
&lt;li>**Web 验证 **# 通过域名访问 Web 服务。由于自己可以配置域名解析，所以只要域名可以解析到运行 ACME 程序的设备上，那么 ACME 程序就认为这个域名是属于我的。
&lt;ul>
&lt;li>这种方式有个弊端：首先要保证自己的域名可以解析到运行 ACME 程序的设备上；然后还要保证 ACME 程序可以通过域名访问到自己。这在国内没有备案的域名是不方便的&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h1 id="lets-encrypt">Let&amp;rsquo;s Encrypt&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://letsencrypt.org/">官网&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Let%27s_Encrypt">Wiki,Let&amp;rsquo;s Encrypt&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://github.com/certbot/certbot">GitHub 项目，certbot/certbot&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;h2 id="使用-certbot-创建证书">使用 certbot 创建证书&lt;/h2>
&lt;p>Let&amp;rsquo;s Encrypt 使用 certbot 工具为我们签署证书&lt;/p>
&lt;blockquote>
&lt;p>注意：保证执行 certbot 的服务器的 80 端口是可以被公网访问的，且保证签署证书时提供的域名是可以解析的(即已备案或无需备案)&lt;/p>
&lt;/blockquote>
&lt;p>证书申请成功后将会出现如下提示：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>~&lt;span style="color:#f92672">]&lt;/span>&lt;span style="color:#75715e"># certbot certonly --standalone&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Saving debug log to /var/log/letsencrypt/letsencrypt.log
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Plugins selected: Authenticator standalone, Installer None
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Please enter in your domain name&lt;span style="color:#f92672">(&lt;/span>s&lt;span style="color:#f92672">)&lt;/span> &lt;span style="color:#f92672">(&lt;/span>comma and/or space separated&lt;span style="color:#f92672">)&lt;/span> &lt;span style="color:#f92672">(&lt;/span>Enter &lt;span style="color:#e6db74">&amp;#39;c&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>to cancel&lt;span style="color:#f92672">)&lt;/span>: 这里输入自己的&lt;span style="color:#e6db74">${&lt;/span>域名&lt;span style="color:#e6db74">}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Obtaining a new certificate
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Performing the following challenges:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>http-01 challenge &lt;span style="color:#66d9ef">for&lt;/span> &lt;span style="color:#e6db74">${&lt;/span>域名&lt;span style="color:#e6db74">}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Waiting &lt;span style="color:#66d9ef">for&lt;/span> verification...
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Cleaning up challenges
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>IMPORTANT NOTES:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - Congratulations! Your certificate and chain have been saved at:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> /etc/letsencrypt/live/&lt;span style="color:#e6db74">${&lt;/span>域名&lt;span style="color:#e6db74">}&lt;/span>/fullchain.pem
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Your key file has been saved at:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> /etc/letsencrypt/live/&lt;span style="color:#e6db74">${&lt;/span>域名&lt;span style="color:#e6db74">}&lt;/span>/privkey.pem
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Your cert will expire on 2022-09-05. To obtain a new or tweaked
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> version of this certificate in the future, simply run certbot
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> again. To non-interactively renew *all* of your certificates, run
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#34;certbot renew&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - If you like Certbot, please consider supporting our work by:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Donating to ISRG / Let&lt;span style="color:#960050;background-color:#1e0010">&amp;#39;&lt;/span>s Encrypt: https://letsencrypt.org/donate
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Donating to EFF: https://eff.org/donate-le
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>根据提示，在 &lt;code>/etc/letsencrypt/live/${DNS}/&lt;/code> 目录下，可以找到已经签署的证书及私钥&lt;/p>
&lt;h1 id="zerosll">ZeroSLL&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://zerossl.com/">官网&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://github.com/zerossl/">GitHub 组织，ZeroSSL&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://github.com/acmesh-official/acme.sh">GitHub 项目，acemsh-official/acme.sh&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>使用 acem.sh 通过阿里云创建证书：&lt;a href="https://f-e-d.club/topic/use-acme-sh-deployment-let-s-encrypt-by-ali-cloud-dns-generic-domain-https-authentication.article">https://f-e-d.club/topic/use-acme-sh-deployment-let-s-encrypt-by-ali-cloud-dns-generic-domain-https-authentication.article&lt;/a>&lt;/p>
&lt;h2 id="使用-acmesh-创建证书">使用 acme.sh 创建证书&lt;/h2>
&lt;h3 id="安装-acmesh">安装 acme.sh&lt;/h3>
&lt;p>acme.sh 是一个纯 Shell 脚本~~
下载这个脚本&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>curl https://get.acme.sh | sh
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>source ~/.bashrc
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>该脚本会创建 &lt;code>~/.acme.sh/&lt;/code> 目录，并在该目录中安装 acme.sh 脚本。acme.sh 的配置文件，生成证书默认保存的位置也在这里。同时会在 &lt;code>~/.bashrc&lt;/code> 文件中添加 &lt;code>. &amp;quot;/root/.acme.sh/acme.sh.env&amp;quot;&lt;/code>&lt;/p>
&lt;h3 id="获取域名注册商认证信息">获取域名注册商认证信息&lt;/h3>
&lt;h4 id="阿里">阿里&lt;/h4>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://github.com/acmesh-official/acme.sh/wiki/dnsapi#11-use-aliyun-domain-api-to-automatically-issue-cert">GitHub 项目 Wiki，acmesh-official/acme.sh-dnsapi-使用阿里云域名 API 自动颁发证书&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>从 &lt;a href="https://ram.console.aliyun.com/users">阿里云控制台-RAM 访问控制-身份管理-用户&lt;/a> 处创建用户并获取 AK、SK&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>export Ali_Key&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;AccessKeyId&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>export Ali_Secret&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;AccessKeySecret&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h4 id="namecom">Name.com&lt;/h4>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://github.com/acmesh-official/acme.sh/wiki/dnsapi#28-use-namecom-api">GitHub 项目 Wiki，acmesh-official/acme.sh-dnsapi-使用 Name.com API&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>从 &lt;a href="https://www.name.com/zh-cn/account/settings/api">https://www.name.com/zh-cn/account/settings/api&lt;/a> 创建 Token&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>export Namecom_Username&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;XXXX&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>export Namecom_Token&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;XXXXX&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>注意：这俩变量要使用 PRODUCTION(生产)环境的。Name.com 创建完 Token 后会有两个~一个用于生产，一个用于测试，对应不用的 API&lt;/p>
&lt;h3 id="生成证书">生成证书&lt;/h3>
&lt;p>使用“阿里云”生成证书文件到指定目录后，执行命令重启容器&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>acme.sh --issue --dns dns_ali -d desistdaydream.ltd -d *.desistdaydream.ltd &lt;span style="color:#ae81ff">\
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">&lt;/span>--installcert &lt;span style="color:#ae81ff">\
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">&lt;/span>--key-file /opt/alist/data/cert/desistdaydream.key &lt;span style="color:#ae81ff">\
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">&lt;/span>--fullchain-file /opt/alist/data/cert/desistdaydream.pem &lt;span style="color:#ae81ff">\
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">&lt;/span>--reloadcmd &lt;span style="color:#e6db74">&amp;#34;docker restart alist&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>使用“Name.com”生成证书文件到指定目录后，执行命令重启容器&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>acme.sh --issue --dns dns_namecom -d 102205.xyz -d *.102205.xyz &lt;span style="color:#ae81ff">\
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">&lt;/span>--key-file /opt/alist/data/cert/102205.key &lt;span style="color:#ae81ff">\
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">&lt;/span>--fullchain-file /opt/alist/data/cert/102205.pem &lt;span style="color:#ae81ff">\
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">&lt;/span>--reloadcmd &lt;span style="color:#e6db74">&amp;#34;docker restart alist&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># 或&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>acme.sh --issue --dns dns_namecom -d 102205.xyz -d *.102205.xyz &lt;span style="color:#ae81ff">\
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">&lt;/span>--installcert &lt;span style="color:#ae81ff">\
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">&lt;/span>--key-file /opt/alist/data/cert/102205.key &lt;span style="color:#ae81ff">\
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">&lt;/span>--fullchain-file /opt/alist/data/cert/102205.pem &lt;span style="color:#ae81ff">\
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">&lt;/span>--reloadcmd &lt;span style="color:#e6db74">&amp;#34;docker restart alist&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># 或&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># 生成到 Nginx 目录&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>acme.sh --issue --dns dns_namecom -d 102205.xyz -d *.102205.xyz &lt;span style="color:#ae81ff">\
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">&lt;/span>--installcert &lt;span style="color:#ae81ff">\
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">&lt;/span>--key-file ~/projects/DesistDaydream/cloud-native-apps/compose/nginx-lch/config/certs/102205.key &lt;span style="color:#ae81ff">\
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">&lt;/span>--fullchain-file ~/projects/DesistDaydream/cloud-native-apps/compose/nginx-lch/config/certs/102205.pem &lt;span style="color:#ae81ff">\
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">&lt;/span>--reloadcmd &lt;span style="color:#e6db74">&amp;#34;docker exec -it nginx-geoip2 nginx -c /etc/nginx/nginx/nginx.conf -s reload&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="创建完成">创建完成&lt;/h3>
&lt;p>证书创建完成后，将会在系统的 Crontab 中创建一个逻辑&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>~&lt;span style="color:#f92672">]&lt;/span>&lt;span style="color:#75715e"># crontab -l&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">26&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span> * * * /root/.acme.sh/acme.sh --cron --home &lt;span style="color:#e6db74">&amp;#34;/root/.acme.sh&amp;#34;&lt;/span> &amp;gt; /dev/null
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div></description></item><item><title>Docs: 密钥/证书 的编码</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/7.%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8/cryptography%E5%AF%86%E7%A0%81%E5%AD%A6/%E5%85%AC%E5%BC%80%E5%AF%86%E9%92%A5%E5%8A%A0%E5%AF%86/%E5%AF%86%E9%92%A5_%E8%AF%81%E4%B9%A6-%E7%9A%84%E7%BC%96%E7%A0%81/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/7.%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8/cryptography%E5%AF%86%E7%A0%81%E5%AD%A6/%E5%85%AC%E5%BC%80%E5%AF%86%E9%92%A5%E5%8A%A0%E5%AF%86/%E5%AF%86%E9%92%A5_%E8%AF%81%E4%B9%A6-%E7%9A%84%E7%BC%96%E7%A0%81/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;p>当我们生成密钥后，是不易于保存的，比如我在 go 代码，使用 RSA 算法生成了这么一个密钥：
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/oxf9fa/1616125711062-22c30c47-afff-4ee4-a81a-d8a5225aad74.png" alt="">&lt;/p>
&lt;p>私钥中包含里 &lt;code>公钥、n、d、组件&lt;/code>，公钥中包含 &lt;code>n、e&lt;/code>。可以发现，这种数据是不便于保存与共享的。所以，一般情况是使用一种 **Encoding(编码) **规则，对密钥进行处理后以生成某种格式的文件，以便保存。当需要使用密钥时，使用对应规则的来 &lt;strong>Decoding(解码)&lt;/strong> 该文件以获得密钥，然后再开始使用。而现阶段最常用的文件就是，就是 &lt;strong>PEM 文件格式&lt;/strong>。&lt;/p>
&lt;p>除了可以对密钥编码，还可以对证书进行编码，证书由于其复杂的格式，也不利于传输。&lt;/p>
&lt;p>如果用 openssl 命令查看私钥，则是下面这种格式&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>root@lichenhao:~/projects/DesistDaydream/GoLearning# openssl rsa -text -noout -in cryptography/private.pem
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>RSA Private-Key: &lt;span style="color:#f92672">(&lt;/span>&lt;span style="color:#ae81ff">2048&lt;/span> bit, &lt;span style="color:#ae81ff">2&lt;/span> primes&lt;span style="color:#f92672">)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>modulus:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> 00:d0:94:1c:6e:25:54:61:1d:34:23:1f:25:f7:a5:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ......
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>publicExponent: &lt;span style="color:#ae81ff">65537&lt;/span> &lt;span style="color:#f92672">(&lt;/span>0x10001&lt;span style="color:#f92672">)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>privateExponent:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> 00:bb:fe:52:e5:9f:f5:be:96:30:d0:db:19:40:6d:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ......
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>prime1:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> 00:f3:06:5f:c4:e6:27:d2:1d:ba:d1:35:40:34:b1:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ......
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>prime2:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> 00:db:b6:ee:09:28:3c:53:f5:70:e7:9a:11:8b:55:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ......
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>exponent1:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> 3b:17:1e:ac:22:86:26:29:c2:65:e1:fb:c5:94:3e:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ......
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>exponent2:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> 00:a4:a5:5d:95:61:20:6c:2e:36:30:68:45:13:6b:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ......
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>coefficient:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> 00:e3:ed:7a:4a:2d:4c:ec:e0:0d:77:e8:4e:df:9b:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ......
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h1 id="pem-文件格式">PEM 文件格式&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Privacy-Enhanced_Mail">Wiki&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>&lt;strong>Privacy-Enhanced Mail(增强隐私的邮件，简称 PEM) &lt;strong>是一种&lt;/strong>文件的格式&lt;/strong>(虽然曾经不止代表文件格式)。这种格式的文件用于存储 加密的密钥、证书 等数据。&lt;/p>
&lt;p>PEM 起源于 1993 年 IETF 定义“隐私增强邮件”的一组标准，尽管这个标准未得到广泛采用，并已被 PGP 和 S/MIME 取代，但其中定义的&lt;strong>各种文本编码格式&lt;/strong>却变得非常流行。所以，PEM 这种文件编码格式最终由 IETF 在 RFC7468 中正式定义。&lt;/p>
&lt;h2 id="pem-格式">PEM 格式&lt;/h2>
&lt;p>PEM 格式的内容由两部分组成&lt;/p>
&lt;ul>
&lt;li>**Type(类型) **# 用来表示 Contents(内容) 是什么，是 密钥 还是 证书 等等，同时也用来定位 Contents(内容) 在 PEM 格式文件中的位置。
&lt;ul>
&lt;li>类型以 &lt;code>-----BEGIN 标签-----&lt;/code>作为开头第一行，并以&lt;code>----- END 标签 -----&lt;/code>作为结尾最后一行。其中的&lt;code>标签&lt;/code>用来确定编码消息的类型，也就是说，标签用来表示该 PEM 格式的文件的作用是什么。标签包括以下几种：
&lt;ul>
&lt;li>CERTIFICATE # 证书&lt;/li>
&lt;li>CERTIFICATE REQUEST # 证书请求&lt;/li>
&lt;li>PRIVATE KEY# 私钥&lt;/li>
&lt;li>PUBLIC KEY # 公钥&lt;/li>
&lt;li>X509 CRL #&lt;/li>
&lt;li>等等等等，很多&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>标签中还可以添加其他标识符，只要保证标签中具有上述字符串即可。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>**Contents(内容) **# 密钥或证书的具体内容。
&lt;ul>
&lt;li>Contents 是 密钥、证书等数据 转换为 Bytes(字节流) 后，使用** Base64 **对这些 &lt;strong>Bytes 进行编码&lt;/strong> 得到的结果。&lt;/li>
&lt;li>注意：现在这个时代(本文写于 2020 年)由于 &lt;strong>PKCS&lt;/strong> 这种规范标准。一般情况下，Contents 必须符合 PKCS 这种标准，所以 密钥证书 并不会直接转换为 Bytes。一般情况下，是先使用 &lt;strong>ASN.1 的 DER(或其他规则)&lt;/strong> 将 证书、密钥 等数据 &lt;strong>编码为 Bytes 类型数据&lt;/strong>。然后再使用 Base64 对这些 Bytes 数据 进行编码得到字符串类型数据。
&lt;ul>
&lt;li>也就是说 证书或密钥 转换为 PCKS#X 标准(&lt;em>X 是数字&lt;/em>)，然后使用 Base64 编码得到 Contents(内容)。而常用的 PCKS#X 标准一般都是用的 ASN.1 的 DER 规则进行编码。
&lt;ul>
&lt;li>再深入一些的话，可以这么描述，&lt;strong>Contents(内容) 可以是使用 Base64 对符合 PKCS#1 标准格式的数据进行编码后得到的字符串&lt;/strong>
&lt;ul>
&lt;li>&lt;strong>而 PKCS#1 标准实际上指的是使用 ASN.1 的 DER 编码规则对公钥和私钥编码。由于编码后通常是 Bytes 类型的数据，所以需要再使用 Base64 编码得到便于传递的字符串类型的数据。&lt;/strong>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>**一般写为 **&lt;code>**PCKS#1, ASN.1 DER**&lt;/code>** &lt;strong>&lt;code>**PCKS#8, ASN.1 DER**&lt;/code>&lt;/strong> 等等。逗号前面是标准名称，逗号后面是符合该标准的编码规则**&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>PEM 格式的数据文件通常以 &lt;code>.pem&lt;/code>、&lt;code>.cer&lt;/code>、&lt;code>.crt&lt;/code>、&lt;code>.key&lt;/code> 结尾。其中 .ert 和 .crt 常用来表示证书、.key 常用来表示密钥(公钥或私钥)&lt;/p>
&lt;blockquote>
&lt;p>PEM 文件中的标签比文件后缀更准确地表示数据类型，因为可以将许多不同类型的数据保存在 .pem 文件中。&lt;/p>
&lt;/blockquote>
&lt;h2 id="pem-格式文件示例">PEM 格式文件示例&lt;/h2>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># 私钥&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>-----BEGIN RSA PRIVATE KEY-----
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>kXxvLDA91VHVdTmRCYPWDOlNCbUi6S42KHmN2RukRM/Y0wMxHvlN7hnYCTrv8nEk
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>KcKJ9XNJAlWxETUe6hYQbvU6JtgIwPav38ZF2IqqdJF/v5EsQd1mg8PI3dqaGFNn
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>wc2osmNP4FN4sz57P1ifsNWobVwvol0VLvuF5zfjvlNzr7YuNGxr/Uu/pQVukQFf
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>8u0mmi7AZdzjdfsphW0Zi4fil3hI5m8HbTsbhfT53TofKt4nRZA/DUCCu6+/NHEW
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>ntY5STMyU0DQW8hasD9DfF9RiSVKm4Unn8TQ6yMFNQXCX5Sg3vgduMz8TUkT1KM3
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>WnwX9X5IO5WeA72dsVOXgQ&lt;span style="color:#f92672">==&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>-----END RSA PRIVATE KEY-----
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># 公钥&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>-----BEGIN RSA PUBLIC KEY-----
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>0JUbBOzKiYp/0MXhux8XH0SxWBfnzCATH4oGvDj5SD6H2z1m97mkpRhRMul4l8vM
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Lhgf2rWHsVHq5FjMeRVigOIIlHyjOFurigZ7pcVqWzHYIck6cGsI4JtEBNuqQ9EM
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>NyMYGpcV+TV0bw9nTUK//Fst++dueWVLmqlKTCbFQRmo2lxwKzXqKjJkSgxge/gh
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>MvC4/xh1Keizzlm73pAnOVhTow+HW5Wgas+maPXMaNcpJ8RryFlG6ke3CBaNqrV8
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>iheO4riYPZQWQkl8NGLlJyXeq/awl6ovbshyZcO45faoDMxl/J93+sczW1ZlF/1B
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>QKUvQGEsNFsT7YAejZvh7w&lt;span style="color:#f92672">==&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>-----END RSA PUBLIC KEY-----
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h1 id="der-编码规则">DER 编码规则&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;a href="https://en.wikipedia.org/wiki/X.690#DER_encoding">Wiki&lt;/a>&lt;/p>
&lt;/blockquote>
&lt;p>&lt;strong>Distinguished Encoding Rules(专用编码规则，简称 DER)&lt;/strong> 是 BER 的一种受限制变体，用于为 ASN.1 所描述的数据结构生成明确的传输语法。像 CER 一样，DER 编码是有效的 BER 编码。 DER 与 BER 相同，只是删除了一个发送者的所有选项。&lt;/p>
&lt;p>用白话说： DER 是一种以二进制形式编码 ASN.1 语法的方法&lt;/p>
&lt;p>&lt;strong>DER，是对 &lt;strong>&lt;a href="https://www.yuque.com/go/doc/33220231">&lt;strong>ASN.1&lt;/strong>&lt;/a>&lt;/strong> 这种语言进行编码的一种规则&lt;/strong>，也是最常用的一种。所谓对某种语言编码，就是类似编译器的效果。所以也可以称为 &lt;strong>ASN.1 的 DER 规则&lt;/strong>。&lt;/p>
&lt;h2 id="x690-标准">X.690 标准&lt;/h2>
&lt;p>是 ITU-T 标准，指定了几种 ASN.1 编码格式&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/X.690#BER_encoding">Basic Encoding Rules&lt;/a>(基本编码规则，简称 BER)&lt;/li>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/X.690#CER_encoding">Canonical Encoding Rules&lt;/a>(规范编码规则，简称 CER)&lt;/li>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/X.690#DER_encoding">Distinguished Encoding Rules&lt;/a>(杰出编码规则，简称 DER)&lt;/li>
&lt;/ul>
&lt;h1 id="asn1-与-pem-的关系">ASN.1 与 PEM 的关系&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;a href="https://en.wikipedia.org/wiki/ASN.1#Relation_to_Privacy-Enhanced_Mail_(PEM)_Encoding">Wiki&lt;/a>&lt;/p>
&lt;/blockquote>
&lt;p>PEM 编码 与 ASN.1 及其 编码/解码器 完全无关。但是由于编码后的 ASN.1 数据通常是二进制的，也就是 Bytes(字节流) 类型的数据，所以经常使用 PEM 对这些编码后的 ASN.1 数据再次进行编码，以获得人类可读的字符串类型数据。这可以帮助再文本编码敏感的媒体(比如 SMTP 服务)上进行传输以及复制和粘贴。&lt;/p>
&lt;h1 id="pkcs非对称加密标准">PKCS(非对称加密标准)&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;a href="https://en.wikipedia.org/wiki/PKCS">Wiki&lt;/a>&lt;/p>
&lt;/blockquote>
&lt;p>&lt;strong>Public Key Cryptography Standards(非对称加密标准，简称 PKCS)&lt;/strong>。在密码学中，&lt;strong>PKCS&lt;/strong>代表“公钥密码学标准”。这些是 RSA Security LLC 从 1990 年代初开始设计和发布的一组&lt;a href="https://en.wikipedia.org/wiki/Public-key_cryptography">&lt;strong>公共密钥加密&lt;/strong>&lt;/a>&lt;strong>标准&lt;/strong>。该公司发布了这些标准，以促进他们拥有专利的加密技术的使用，例如 RSA 算法，Schnorr 签名算法以及其他几种。尽管不是行业标准（因为公司保留了对它们的控制权），但近年来有些标准[&lt;em>何时？&lt;/em>]已开始进入“标准轨道”相关标准组织的流程，例如 IETF 和 PKIX 工作组。&lt;/p>
&lt;blockquote>
&lt;p>注意:很多标准已经被废弃,所以下文看到的标准的编号不是连续的,比如 2、4、13、14 等等标准，就没有了，现在最常用的是 1、8 号标准&lt;/p>
&lt;/blockquote>
&lt;p>PKCS 的起源
X.509 只是一种常用的证书格式，但有人觉得这种格式能装的信息不够多，因此 又定义了一些比 X.509 更大的数据结构（但仍然用 ASN.1）， 能将证书、秘钥以及其他东西封装（打包）到一起。因此，有时说我需要“一个证书”时，其 实真正说的是包（package）中包含的那个“证书”（a certificate in one of these envelopes），而不是这个包本身。&lt;/p>
&lt;h2 id="pkcs1--rsa-密码学标准">PKCS＃1 # RSA 密码学标准&lt;/h2>
&lt;p>参见 RFC 8017。该标准定义了 RSA 公钥和私钥的数学属性和格式(这个密钥对是使用 ASN.1 的编码规则编码后的结果)。此外，还定义了执行 RSA 加密、解密、签名、验签的基本算法。&lt;/p>
&lt;h2 id="pkcs3--diffie-hellman-密钥协商标准">PKCS＃3 # Diffie-Hellman 密钥协商标准&lt;/h2>
&lt;p>一种加密协议，允许彼此不具有先验知识的两个方通过不安全的通信通道共同建立共享的秘密密钥。&lt;/p>
&lt;h2 id="pkcs5--基于密码的加密标准">PKCS＃5 # 基于密码的加密标准&lt;/h2>
&lt;p>参见 RFC 8018 和 PBKDF2。&lt;/p>
&lt;h2 id="pkcs7--加密消息语法标准">PKCS＃7 # 加密消息语法标准&lt;/h2>
&lt;p>参见 RFC 2315。用于在 PKI 下对消息进行签名和/或加密。也用于证书分发（例如，作为对 PKCS＃10 消息的响应）。形成了 S / MIME 的基础，S / MIME 于 2010 年基于 RFC 5652（一种更新的加密消息语法标准（CMS））建立。通常用于单点登录。&lt;/p>
&lt;h2 id="pkcs8-私钥内容的标准语法">PKCS＃8 #私钥内容的标准语法&lt;/h2>
&lt;blockquote>
&lt;p>注意：
该标准仅定义了私钥的标准，一般情况下，对应的公钥标准一般是 PKIX。
该标准不仅定义了 RSA 算法的密钥的标准，还定义了其他算法的标准。而 PKCS#1 仅定义了 RSA 算法密钥的标准。&lt;/p>
&lt;/blockquote>
&lt;p>参见 RFC 5958。用于携带私有证书密钥对（加密或未加密）。&lt;/p>
&lt;h2 id="pkcs9--所选属性类型">PKCS＃9 # 所选属性类型&lt;/h2>
&lt;p>参见 RFC 2985。
定义用于 PKCS＃6 扩展证书，PKCS＃7 数字签名消息，PKCS＃8 私钥信息和 PKCS＃10 证书签名请求中使用的所选属性类型。&lt;/p>
&lt;h2 id="pkcs10--认证请求标准证书请求-csr-的标准">PKCS＃10 # 认证请求标准(证书请求 CSR 的标准)&lt;/h2>
&lt;p>参见 RFC 2986。发送到 CA 以请求公钥认证的消息格式。请参阅证书签名请求。&lt;/p>
&lt;h2 id="pkcs11--加密令牌接口">PKCS＃11 # 加密令牌接口&lt;/h2>
&lt;p>也称为“ Cryptoki”。一个 API，用于定义加密令牌的通用接口（另请参阅硬件安全模块）。常用于单点登录，公共密钥加密和磁盘加密[10]系统。
RSA Security 已将 PKCS＃11 标准的进一步开发移交给了 OASIS PKCS 11 技术委员会。&lt;/p>
&lt;h2 id="pkcs12--个人信息交换语法标准">PKCS＃12 # 个人信息交换语法标准&lt;/h2>
&lt;p>参见 RFC 7292。定义一种文件格式，通常用于存储私有密钥以及随附的公共密钥证书，并使用基于密码的对称密钥进行保护。
PFX 是 PKCS＃12 的前身。
此容器格式可以包含多个嵌入式对象，例如多个证书。通常使用密码进行保护/加密。可用作 Java 密钥库的格式，并在 Mozilla Firefox 中建立客户端身份验证证书。可用于 Apache Tomcat。&lt;/p>
&lt;h2 id="pkcs15--密码令牌信息格式标准">PKCS＃15 # 密码令牌信息格式标准&lt;/h2>
&lt;p>定义一个标准，允许加密令牌的用户向应用程序标识自己，而与应用程序的 Cryptoki 实现（PKCS＃11）或其他 API 无关。RSA 放弃了本标准中与 IC 卡相关的部分，使其符合 ISO / IEC 7816-15。[14]&lt;/p></description></item><item><title>Docs: 什么鬼？</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/7.%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8/%E4%BB%80%E4%B9%88%E9%AC%BC/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/7.%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8/%E4%BB%80%E4%B9%88%E9%AC%BC/</guid><description>
&lt;p>要研究态势感知或安全运营中心，可以采用OSSIM
要研究入侵防御技术，可以采用Snort或Security Onion
要研究防火墙技术，可以采用pfSense或OPNsense
要研究Web应用防火墙（WAF ），可以采用ModSecurity
要研究威胁情报技术，可以采用MISP或OpenCTI
要研究漏洞扫描技术，可以采用OpenVAS或W3AF
要研究堡垒机技术，可以采用JumpServer
要研究蜜罐技术，可以采用T-Pot或Hfish&lt;/p></description></item><item><title>Docs: 证书 与 PKI</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/7.%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8/cryptography%E5%AF%86%E7%A0%81%E5%AD%A6/%E5%85%AC%E5%BC%80%E5%AF%86%E9%92%A5%E5%8A%A0%E5%AF%86/%E8%AF%81%E4%B9%A6-%E4%B8%8E-pki/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/7.%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8/cryptography%E5%AF%86%E7%A0%81%E5%AD%A6/%E5%85%AC%E5%BC%80%E5%AF%86%E9%92%A5%E5%8A%A0%E5%AF%86/%E8%AF%81%E4%B9%A6-%E4%B8%8E-pki/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Public_key_certificate">Wiki,Public Key Certificate&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Public_key_infrastructure">Wiki,PKI&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Certificate_signing_request">Wiki,CSR&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Certificate_authority">Wiki,CA&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Root_certificate">Wiki,Root Certificate&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://datatracker.ietf.org/doc/html/rfc5280">RFC,5280&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://mp.weixin.qq.com/s/E-aU-lbieGLokDKbjdGc3g">公众号,云原生生态圈-白话文说 CA 原理&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://arthurchiao.art/blog/everything-about-pki-zh/">Arthurchiao 博客,[译] 写给工程师：关于证书（certificate）和公钥基础设施（PKI）的一切（SmallStep, 2018）&lt;/a>
&lt;ul>
&lt;li>&lt;a href="https://mp.weixin.qq.com/s/li3ZjfNgX5nh7AKjyyzt5A">公众号-云原生实验室，搬运了上面的文章&lt;/a>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>Certificate 与 PKI 的目标很简单：Bind names to Public Keys(将名字关联到公钥)。这是关于 Certificate 与 PKI 的最高抽象，其他都是属于实现细节&lt;/p>
&lt;h1 id="certificate">Certificate&lt;/h1>
&lt;p>&lt;strong>Certificate(证书)&lt;/strong> 在密码学中，是指 &lt;a href=".md">公开密钥加密&lt;/a> 中完善其签名&lt;a href=".md">缺点&lt;/a>的 &lt;strong>Public Key Certificate(公钥证书)&lt;/strong>。在&lt;a href=".md">公开密钥加密&lt;/a>的介绍中，我们看到了公钥加密的特点，并且也发现了缺点，公钥容易被劫持。那么为了解决这个问题，就需要一个东西可以&lt;strong>验证公钥的真实性&lt;/strong>。公钥证书也就由此而来。&lt;/p>
&lt;p>&lt;strong>Public Key Certificate(公钥证书，简称 PKC)&lt;/strong> 也称为 &lt;strong>Digital Certifacte(数字证书)&lt;/strong> 或 &lt;strong>Identity Certificate(身份证书)&lt;/strong>，是一种用于证明公钥的所有权的电子文档。&lt;/p>
&lt;p>假设有这么一种场景：公钥加密系统使我们能知道和谁在通信，但这个事情的前提是：我们必须要有对方的公钥&lt;/p>
&lt;p>那么，如果我们不知道对方的公钥，那么该怎么办呢？这时候 Certificate 就出现了。&lt;/p>
&lt;ul>
&lt;li>首先，我需要从对方手里拿到公钥和其拥有者的信息&lt;/li>
&lt;li>那么我如何相信我拿到的信息是真实有效的呢？~可以请一个双方都信任的权威机构，对我拿到的信息做出证明
&lt;ul>
&lt;li>而这个权威机构用来证明信息有效的东西，就是 Certificate&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>公钥证书通常应该包含如下内容：&lt;/p>
&lt;ul>
&lt;li>密钥的信息&lt;/li>
&lt;li>有关其所有者的身份信息，称为 Subject(主体)&lt;/li>
&lt;li>验证证书内容的实体的数字签名，这个实体称为 Issuer(发行人)&lt;/li>
&lt;li>权威机构对证书的签名，签名的大概意思就是：&lt;code>Public key XXX 关联到了 name XXX&lt;/code>，这就对应了文章开头的那句话：Certificate 与 PKI 的目标很简单：Bind names to Public Keys(将名字关联到公钥)
&lt;ul>
&lt;li>对证书的签名的实体称为 &lt;strong>Certificate Authority(简称 CA)&lt;/strong>，也可以称为 &lt;strong>Issuer(签发者)&lt;/strong>。&lt;/li>
&lt;li>被签名的实体称为 &lt;strong>Subject(主体)&lt;/strong>。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>举个例子，如果某个 Issuer 为 Bob 签发了一张证书，其中的内容就可以解读如下：
&lt;em>Some Issuer&lt;/em> says &lt;em>Bob&lt;/em>’s public key is 01:23:42…
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/wlyw54/1634110798410-4fe856d6-2d02-43a9-b233-229b8d48fa51.png" alt="image.png">
证书是权威机构颁发的身份证明，并没有什么神奇之处
其中 &lt;code>Some Issuer&lt;/code> 是证书的签发者(CA)，证书是为了证明这是 Bob 的公钥， Some Issuer 也是这个声明的签字方。&lt;/p>
&lt;p>如果签名有效，并且检查证书的软件信任发行者，那么它可以使用该密钥与证书的主题安全地通信。在电子邮件加密，代码签名和电子签名系统中，证书的主体通常是一个人或组织。然而，在传输层安全性（TLS）中，证书的主体通常是计算机或其他设备，但除了在识别设备中的核心作用之外，TLS 证书还可以识别组织或个人。 TLS 有时被其旧的名称安全套接字层（SSL）调用，对于 HTTPS 的一部分是值得注意的，该协议是安全浏览 Web 的协议。&lt;/p>
&lt;p>公钥证书最常用的格式是 X.509 标准。&lt;/p>
&lt;h2 id="证书的类型">证书的类型&lt;/h2>
&lt;ol>
&lt;li>自签名证书：一般都是 CA 机构使用 CA 自己的的公钥签署的证书，这样别人拿到该证书后，才可以去找 CA 验证这个证书是不是可信的。&lt;/li>
&lt;li>根证书：根证书是标识根证书颁发机构(CA)的公钥证书。根证书是自签名的，并构成基于 X.509 的公钥基础结构（PKI）的基础。&lt;/li>
&lt;li>TLS / SSL 服务器证书&lt;/li>
&lt;li>TLS / SSL 客户端证书&lt;/li>
&lt;li>电子邮件证书&lt;/li>
&lt;li>代码签名证书&lt;/li>
&lt;li>合格证书&lt;/li>
&lt;li>中级证书&lt;/li>
&lt;li>终端实体或叶子证书&lt;/li>
&lt;/ol>
&lt;h1 id="public-key-infrastructure">Public Key Infrastructure&lt;/h1>
&lt;p>&lt;strong>Public Key Infrastructure(公钥基础设施)&lt;/strong> 是用来管理数字证书和管理公钥加密所需的一组 Entity(实体，包括但不限于 角色、策略、硬件、软件、程序 等等)。PKI 的目的是为了促进一系列网络活动的安全传输，例如电子商务、网上银行、敏感电子邮件。&lt;/p>
&lt;p>PKI 是通用的，与厂商无关的概念，适用于任何地方，因此及时系统分布在世界各地，彼此之间也能安全地通信；如果我们使用 TLS everywhere 模型，甚至连 VPN 都不需要。&lt;/p>
&lt;p>PKI 的标准由 RFC 5280 定义，然后 &lt;a href="https://cabforum.org/">CA/Browser Forum&lt;/a> (a.k.a., CA/B or CAB Forum) 对其进行了进一步完善。PKI 的标准称为 &lt;strong>Public-Key Infrastructure(X.509)(公要基础设施(X.509)，简称 PKIX)&lt;/strong>，由于 PKIX 是围绕 X.509 证书标准定义的 PKI 标准，所以 PKI 后面就加了一个 X~~~~~o(╯□╰)o ~~~从 RFC 5280 也可以看到每页文档的页眉写的是 &lt;code>PKIX Certificate and CRL Profile&lt;/code>。并且 IETF 与 1995 年秋季成了了 &lt;a href="https://datatracker.ietf.org/wg/pkix/about/">PKIX 工作组&lt;/a>。&lt;/p>
&lt;h2 id="certificate-authority证书权威">Certificate Authority(证书权威)&lt;/h2>
&lt;p>&lt;strong>Certificate Authority(证书权威，简称 CA)&lt;/strong> 是拥有公信力的颁发数字证书的实体，通常称为&lt;strong>证书颁发机构&lt;/strong>。&lt;/p>
&lt;p>CA 自身的证书，通常称为 &lt;strong>Root Certificate(根证书)&lt;/strong>，根证书是使用 CA 的私钥 &lt;strong>Self-signed(自签名的)&lt;/strong>，且是 CA 的唯一标识。&lt;/p>
&lt;p>&lt;strong>CA 使用自己的私钥为其他实体签名并颁发证书&lt;/strong>。就像文章开头提到的一样，Bind names to Public Keys，CA 为公钥和名字之间的绑定关系做担保。&lt;/p>
&lt;h3 id="trust-stores信任仓库即操作系统浏览器等保存证书的地方">Trust Stores(信任仓库)，即操作系统、浏览器等保存证书的地方&lt;/h3>
&lt;p>那么，当我们访问一个网站时，是如何验证其证书的真实性呢?~其实，通常都会有一个 CA 仓库，用来保存一些预配置的可信的根证书。凭借这些预配置的根证书，当我们访问互联网上绝大部分网站时，就可以验证其身份。&lt;/p>
&lt;p>这个信任仓库又是如何来的呢？&lt;/p>
&lt;ul>
&lt;li>浏览器 # 浏览器默认使用的信任仓库以及其他任何使用 TLS 的东西，都是由 4 个组织维护的
&lt;ul>
&lt;li>&lt;a href="http://www.apple.com/certificateauthority/ca_program.html">Apple’s root certificate&lt;/a>：iOS/macOS 程序&lt;/li>
&lt;li>&lt;a href="https://social.technet.microsoft.com/wiki/contents/articles/31633.microsoft-trusted-root-program-requirements.aspx">Microsoft’s root certificate program&lt;/a>：Windows 使用&lt;/li>
&lt;li>&lt;a href="https://www.mozilla.org/en-US/about/governance/policies/security-group/certs/">Mozilla’s root certificate program&lt;/a>： Mozilla 产品使用，由于其开放和透明，也作为其他一些信任仓库从基础 (e.g., for many Linux distributions)&lt;/li>
&lt;li>Google &lt;a href="https://www.chromium.org/Home/chromium-security/root-ca-policy">未维护 root certificate program&lt;/a> （Chrome 通常使用所在计算的操作系统的信任仓库），但 &lt;a href="https://chromium.googlesource.com/chromium/src/+/master/net/data/ssl/blacklist/README.md">维护了自己的黑名单&lt;/a>， 列出了自己不信任的根证书或特定证书。 (&lt;a href="https://chromium.googlesource.com/chromiumos/docs/+/master/ca_certs.md">ChromeOS builds off of Mozilla’s certificate program&lt;/a>)&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>操作系统 # 操作系统中的信任仓库通常是各自发行版自带的。不同的发行版，保存路径不同，保存方式也不同：
&lt;ul>
&lt;li>CentOS 发行版
&lt;ul>
&lt;li>/etc/pki/ca-trust/extracted/openssl/ca-bundle.trust.crt # 包含所有证书，每个证书前有注释&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Ubuntu 发行版
&lt;ul>
&lt;li>/etc/ssl/certs/* # 该目录中一个证书一个文件&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Windows，证书位置如图
&lt;ul>
&lt;li>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/wlyw54/1662898111701-e46d8a99-c518-48fa-8eb2-9a37448d3df3.png" alt="image.png">&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>信任仓库中通常包含了超过 100 个由这些程序维护的常见 CA。比如：&lt;/p>
&lt;ul>
&lt;li>Let’s Encrypt&lt;/li>
&lt;li>Symantec&lt;/li>
&lt;li>DigiCert&lt;/li>
&lt;li>Entrust&lt;/li>
&lt;/ul>
&lt;h4 id="示例">示例&lt;/h4>
&lt;p>比如在 Linux 各种发行版中上述目录中有一个名为 GlobalSign_Root_CA 的根证书，百度就是使用这个证书签名的。&lt;/p>
&lt;p>这是通过浏览器访问 &lt;a href="http://www.baidu.com">http://www.baidu.com&lt;/a> 获取到的证书信息
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/wlyw54/1638255619893-aaa4aaf0-0b19-4aab-94c7-ea6d52c40e8b.png" alt="image.png">
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/wlyw54/1638255970307-44dc01bc-7d7d-4adb-94c7-bb7ec2ce1636.png" alt="image.png">
这是从服务器的 CA 仓库中获取的 GlobalSign_Root_CA 这个 CA 的证书信息
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/wlyw54/1638255663132-94adcb92-b634-4f45-936b-8f51245f7558.png" alt="image.png">&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">[&lt;/span>root@hw-cloud-xngy-jump-server-linux-2 ~&lt;span style="color:#f92672">]&lt;/span>&lt;span style="color:#75715e"># openssl x509 -text -noout -in /etc/ssl/certs/GlobalSign_Root_CA.pem&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Certificate:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Data:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Version: &lt;span style="color:#ae81ff">3&lt;/span> &lt;span style="color:#f92672">(&lt;/span>0x2&lt;span style="color:#f92672">)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Serial Number:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> 04:00:00:00:00:01:15:4b:5a:c3:94
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Signature Algorithm: sha1WithRSAEncryption
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Issuer: C &lt;span style="color:#f92672">=&lt;/span> BE, O &lt;span style="color:#f92672">=&lt;/span> GlobalSign nv-sa, OU &lt;span style="color:#f92672">=&lt;/span> Root CA, CN &lt;span style="color:#f92672">=&lt;/span> GlobalSign Root CA
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Validity
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Not Before: Sep &lt;span style="color:#ae81ff">1&lt;/span> 12:00:00 &lt;span style="color:#ae81ff">1998&lt;/span> GMT
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Not After : Jan &lt;span style="color:#ae81ff">28&lt;/span> 12:00:00 &lt;span style="color:#ae81ff">2028&lt;/span> GMT
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Subject: C &lt;span style="color:#f92672">=&lt;/span> BE, O &lt;span style="color:#f92672">=&lt;/span> GlobalSign nv-sa, OU &lt;span style="color:#f92672">=&lt;/span> Root CA, CN &lt;span style="color:#f92672">=&lt;/span> GlobalSign Root CA
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>......
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>可以看到，两个证书的信息是一样的，时间不一致是由于时区设置的问题，浏览器直接打开证书变成了东八区。所以是 20:00:00；如果从窗口导出证书成文件，再使用 openssl 命令查看，就可以发现，两个证书是一模一样的。&lt;/p>
&lt;h3 id="chain-of-trust信任链">Chain of trust(信任链)&lt;/h3>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/wlyw54/1638252283465-124564d9-4f52-4812-9cfb-484fb54b599b.png" alt="image.png">
CA 使用自己的私钥签一个根证书，然后再为下级 Issuer 签署证书，下级 Issuer 还可以为其自身的下级 Issuer 签署证书。这么层层签署，可以形成一个树形结构的信任链。&lt;/p>
&lt;p>现在假如 A 是 CA，签署证书给 B，C 想访问 B 提供的服务，C 在访问时，如何确保 B 就是 B 呢？~这就是 TLS/SSL 协议所要做的事情。总结一下就是 C 首先要获取 A 的证书，这是访问 B 时，就可以使用 A 的证书验证 B 的证书。并且，由于 A 的证书是用其私钥签名的，只要 A 签证书的私钥(即 CA 的私钥)不泄露，整个信任链就是可信的。&lt;/p>
&lt;h3 id="保证-ca-私钥的安全">保证 CA 私钥的安全&lt;/h3>
&lt;p>CAB Forum Baseline Requirements 4.3.1 明确规定：一个 Web PKI CA 的 root private key 只能通过 issue a direct command 来签发证书。&lt;/p>
&lt;ul>
&lt;li>换句话说，Web PKI root CA 不能自动化证书签名（certificate signing）过程。&lt;/li>
&lt;li>对于任何大的 CA operation 来说，无法在线完成都是一个问题。 不可能每次签发一个证书时，都人工敲一个命令。&lt;/li>
&lt;/ul>
&lt;p>这样规定是出于安全考虑。&lt;/p>
&lt;ul>
&lt;li>Web PKI root certificates 广泛存在于信任仓库中，很难被撤回。截获一个 root CA private key 理论上将影响几十亿的人和设备。&lt;/li>
&lt;li>因此，最佳实践就是，确保 root private keys 是离线的（offline），理想情况下在一些 &lt;a href="https://en.wikipedia.org/wiki/Hardware_security_module">专用硬件&lt;/a> 上，连接到某些物理空间隔离的设备上，有很好的物理安全性，有严格的使用流程。&lt;/li>
&lt;/ul>
&lt;p>一些 internal PKI 也遵循类似的实践，但实际上并没有这个必要。&lt;/p>
&lt;ul>
&lt;li>如果能自动化 root certificate rotation （例如，通过配置管理或编排工具，更新信任仓库）， 你就能轻松地 rotate 一个 compromised root key。&lt;/li>
&lt;li>由于人们如此沉迷于 internal PKI 的根秘钥管理，导致 internal PKI 的部署效率大大 降低。你的 AWS root account credentials 至少也是机密信息，你又是如何管理它的呢？&lt;/li>
&lt;/ul>
&lt;h3 id="其他">其他&lt;/h3>
&lt;p>可以通过工具来创建私有 CA 证书(即自己创造一个 CA 所用的证书，等于是自己的其中一台设备当做 CA 来给自己所用的其余设备颁发证书)(自签名的)以便让个人或公司内部使用。比如 openssl 工具就可以实现。openssl 即可创建私有 CA 证书。&lt;/p>
&lt;h2 id="certificate-signing-request证书签名请求">Certificate Signing Request(证书签名请求)&lt;/h2>
&lt;p>在 PKI 系统中，&lt;strong>Certificate Signing Request(证书签名请求，简称 CSR) &lt;strong>是申请人发送到 PKI 的注册机构，用来申请&lt;/strong>公钥证书&lt;/strong>的一种消息。&lt;/p>
&lt;p>CSR 最常见的格式是 &lt;a href="https://en.wikipedia.org/wiki/PKCS">PKCS&lt;/a>＃10 规范；另一个是某些&lt;a href="https://en.wikipedia.org/wiki/Web_browser">浏览器&lt;/a>生成的签名公钥和质询 &lt;a href="https://en.wikipedia.org/wiki/SPKAC">SPKAC&lt;/a> 格式。&lt;/p>
&lt;p>在创建 CSR 之前，申请人首先需要生成一个密钥对，并将私钥保密。实际上，CSR 也可以称为证书，想要创建一个 CSR，则需要使用申请人的密钥中的私钥进行签名。&lt;/p>
&lt;p>CSR 中应包含&lt;/p>
&lt;ul>
&lt;li>
&lt;p>&lt;strong>名字&lt;/strong> # 申请人的识别信息(比如 X.509 规范中的 Subject 字段)&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>公钥&lt;/strong> # 从申请人密钥中提取出的公钥&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>签名&lt;/strong> #&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>其他信息&lt;/strong> #&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h1 id="证书的验证过程">证书的验证过程&lt;/h1>
&lt;p>CA 收到一个 CSR 并验证签名之后，接下来需要确认证书中绑定的 name 是否真的 是这个 subscriber 的 name。这项工作很棘手。 证书的核心功能是&lt;strong>能让 RP 对 subscriber 进行认证&lt;/strong>。因此， 如果一个&lt;strong>证书都还没有颁发，CA 如何对这个 subscriber 进行认证呢&lt;/strong>？
答案是：分情况。&lt;/p>
&lt;h2 id="web-pki-证明身份过程">Web PKI 证明身份过程&lt;/h2>
&lt;p>Web PKI 有三种类型的证书，它们&lt;strong>最大的区别就是如何识别 subscriber&lt;/strong>， 以及它们所用到的 &lt;strong>identity proofing 机制&lt;/strong>。
这三种证书是：&lt;/p>
&lt;ol>
&lt;li>domain validation (DV，域验证)DV 证书绑定的是 &lt;strong>DNS name&lt;/strong>，CA 在颁发时需要验证的这个 domain name 确实是由该 subscriber 控制的。证明过程通常是通过一个简单的流程，例如
&lt;ol>
&lt;li>给 WHOIS 记录中该 domain name 的管理员发送一封确认邮件。&lt;/li>
&lt;li>&lt;a href="https://ietf-wg-acme.github.io/acme/draft-ietf-acme-acme.html">ACME protocol&lt;/a> （最初由 Let’s Encrypt 开发和使用）改进了这种方式，更加自动化：不再用邮件验证 ，而是由 ACME CA 提出一个 challenge，该 subscriber 通过完成这个问题来证明它拥有 这个域名。challenge 部分属于 ACME 规范的扩展部门，常见的包括：
&lt;ul>
&lt;li>在指定的 URL 上提供一个随机数（HTTP challenge）&lt;/li>
&lt;li>在 DNS TXT 记录中放置一个随机数（DNS challenge）&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ol>
&lt;/li>
&lt;li>organization validation (OV，组织验证)
&lt;ul>
&lt;li>OV 和下面将介绍的 EV 证书构建在 DV 证书之上，它们包括了 name 和域名 &lt;strong>所属组织的位置信息（location）&lt;/strong>。&lt;/li>
&lt;li>OV 和 EV 证书不仅仅将证书关联到域名，还关联到控制这个域名的法律实体（legal entity）。&lt;/li>
&lt;li>OV 证书的验证过程，不同的 CA 并不统一。为解决这个问题，CAB Forum 引入了 EV 证书。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>extended validation&lt;/strong> (EV，扩展验证)这些完成之后，当相应网站时，&lt;strong>某些浏览器会在 URL 栏中显示该组织的名称&lt;/strong>。例如：&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/wlyw54/1638261597799-3bbc2a87-727d-4c25-8492-f993a2e94ead.png" alt="image.png">但除了这个场景之外，EV certificates 并未得到广泛使用，Web PKI RP 也未强依赖它。
&lt;ul>
&lt;li>EV 证书包含的基本信息与 OV 是一样的，但强制要求严格验证（identity proofing）。&lt;/li>
&lt;li>EV 过程需要几天或几个星期，其中可能包括公网记录搜索（public records searches）和公司人员（用笔）签署的（纸质）证词。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ol>
&lt;p>&lt;strong>本质上来说，每个 Web PKI RP 只需要 DV 级别的 assurance&lt;/strong> 就行了， 也就是确保域名是被该 subscriber 控制的。重要的是能理解一个 DV 证书在设计上的意思和在实际上做了什么：&lt;/p>
&lt;ul>
&lt;li>在设计上，希望通过它证明：请求这个证书的 entity 拥有对应的域名；&lt;/li>
&lt;li>在实际上，真正完成的操作是：在某个时间，请求这个证书的 entity 能读一封邮件，或配置一条 DNS 记录，或能通过 HTTP serve 一个指定随机数等等。&lt;/li>
&lt;/ul>
&lt;p>但话说回来，DNS、电子邮件和 BGP 这些底层基础设施本身的安全性也并没有做到足够好， 针对这些基础设施的攻击还是 &lt;a href="https://doublepulsar.com/hijack-of-amazons-internet-domain-service-used-to-reroute-web-traffic-for-two-hours-unnoticed-3a6f0dda6a6f">时有发生&lt;/a>， 目的之一就是获取证书。&lt;/p>
&lt;h2 id="internal-pki-证明身份过程">Internal PKI 证明身份过程&lt;/h2>
&lt;p>上面是 Web PKI 的身份证明过程，再来看 internal PKI 的身份证明过程。
实际上，用户可以使用&lt;strong>任何方式&lt;/strong>来做 internal PKI 的 identity proofing， 并且效果可能比 Web PKI 依赖 DNS 或邮件方式的效果更好。
乍听起来好像很难，但其实不难，因为可以&lt;strong>利用已有的受信基础设施&lt;/strong>： 用来搭建基础设施的工具，也能用来为这些基础设施之上的服务创建和证明安全身份。&lt;/p>
&lt;ul>
&lt;li>如果用户已经信任 Chef/Puppet/Ansible/Kubernetes，允许它们将代码放到服务器上， 那也应该信任它们能完成 identity attestations&lt;/li>
&lt;li>如果在 AWS 上，可以用 &lt;a href="https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/instance-identity-documents.html">instance identity documents&lt;/a>&lt;/li>
&lt;li>如果在 GCP：&lt;a href="https://cloud.google.com/compute/docs/instances/verifying-instance-identity">GCP&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://docs.microsoft.com/en-us/azure/active-directory/managed-identities-azure-resources/how-to-use-vm-token">Azure&lt;/a>&lt;/li>
&lt;/ul>
&lt;p>provisioning infrastructure 必须理解 identity 的概念，这样才能将正确的代码放到正确的位置。 此外，用户必须信任这套机制。基于这些知识和信任，才能配置 RP 信任仓库、将 subscribers 纳入你的 internal PKI 管理范围。 而完成这些功能全部所需做的就是：设计和实现某种方式，能让 provisioning infrastructure 在每个服务启动时，能将它们的 identity 告诉你的 CA。 顺便说一句，这正是 &lt;a href="https://smallstep.com/certificates/">step certificates&lt;/a> 解决的事情。&lt;/p>
&lt;h1 id="证书的生命周期">证书的生命周期&lt;/h1>
&lt;h2 id="expiration过期">Expiration（过期）&lt;/h2>
&lt;p>证书通常都会过期。虽然这不是强制规定，但一般都这么做。设置一个过期时间非常重要，&lt;/p>
&lt;ul>
&lt;li>&lt;strong>证书都是分散在各处的&lt;/strong>：通常 RP 在验证一个证书时，并没有某个中心式权威能感知到（这个操作）。&lt;/li>
&lt;li>如果没有过期时间，证书将永久有效。&lt;/li>
&lt;li>安全领域的一条经验就是：&lt;strong>时间过的越久，凭证被泄露的概率就越接近 100%&lt;/strong>。&lt;/li>
&lt;/ul>
&lt;p>因此，设置过期时间非常重要。具体来说，X.509 证书中包含一个有效时间范围：&lt;/p>
&lt;ol>
&lt;li>&lt;em>issued at&lt;/em>&lt;/li>
&lt;li>&lt;em>not before&lt;/em>&lt;/li>
&lt;li>&lt;em>not after&lt;/em>：过了这个时间，证书就过期了。&lt;/li>
&lt;/ol>
&lt;p>这个机制看起来设计良好，但实际上也是有一些不足的：&lt;/p>
&lt;ul>
&lt;li>首先，&lt;strong>没有什么能阻止 RP&lt;/strong> 错误地（或因为糟糕的设计）&lt;strong>接受一个过期证书&lt;/strong>；&lt;/li>
&lt;li>其次，证书是分散的。验证证书是否过期是每个 RP 的责任，而有时它们会出乱子。例如，&lt;strong>RP 依赖的系统时钟不对&lt;/strong>时。 &lt;strong>最坏的情况就是系统时钟被重置为了 unix epoch&lt;/strong>（1970.1.1），此时它无法信任任何证书。&lt;/li>
&lt;/ul>
&lt;p>在 subscriber 侧，证书过期后，私钥要处理得当：&lt;/p>
&lt;ul>
&lt;li>如果一个密钥对之前是&lt;strong>用来签名/认证&lt;/strong>的（例如，基于 TLS），
&lt;ul>
&lt;li>应该在不需要这个密钥对之后，&lt;strong>立即删除私钥&lt;/strong>。&lt;/li>
&lt;li>保留已经失效的签名秘钥（signing key）会导致不必要的风险：对谁都已经没有用处，反而会被拿去仿冒签名。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>如果密钥对是&lt;strong>用来加密的&lt;/strong>，情况就不同了。
&lt;ul>
&lt;li>只要还有数据是用这个加密过的，就需要&lt;strong>留着这个私钥&lt;/strong>。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>这就是为什么很多人会说，&lt;strong>不要用同一组秘钥来同时做签名和加密&lt;/strong>（signing and encryption）。 因为当一个用于签名的私钥过期时，&lt;strong>无法实现秘钥生命周期的最佳管理&lt;/strong>： 最终不得不保留着这个私钥，因为解密还要用它。&lt;/p>
&lt;h2 id="renewal续期">Renewal（续期）&lt;/h2>
&lt;p>证书快过期时，如果还想继续使用，就需要续期。&lt;/p>
&lt;h3 id="web-pki-证书续期">Web PKI 证书续期&lt;/h3>
&lt;p>Web PKI 实际上并&lt;strong>没有标准的续期过期&lt;/strong>：&lt;/p>
&lt;ul>
&lt;li>没有一个标准方式来延长证书的合法时间，&lt;/li>
&lt;li>一般是&lt;strong>直接用一个新证书替换过期的&lt;/strong>。&lt;/li>
&lt;li>因此续期过程和 issuance 过程是一样的：&lt;strong>生成并提交一个 CSR&lt;/strong>，然后完成 identity proofing。&lt;/li>
&lt;/ul>
&lt;h3 id="internal-pki-证书续期">Internal PKI 证书续期&lt;/h3>
&lt;p>对于 internal PKI 我们能做的更好。
最简单的方式是：&lt;/p>
&lt;ul>
&lt;li>&lt;strong>用 mTLS 之类的协议对老证书续期&lt;/strong>。&lt;/li>
&lt;li>CA 能对 subscriber 提供的客户端证书进行认证（authenticate），&lt;strong>重签一个更长的时间&lt;/strong>，然后返回这个证书。&lt;/li>
&lt;li>这使得续期过程&lt;strong>很容易自动化&lt;/strong>，而且强制 subscriber 定期与中心权威保持沟通。&lt;/li>
&lt;li>基于这种机制能轻松&lt;strong>构建一个证书的监控和撤销基础设施&lt;/strong>。&lt;/li>
&lt;/ul>
&lt;h3 id="小结">小结&lt;/h3>
&lt;p>证书的续期过程其实并不是太难，&lt;strong>最难的是记得续期这件事&lt;/strong>。
几乎每个管理过公网证书的人，都经历过证书过期导致的生产事故，&lt;a href="https://expired.badssl.com/">例如这个&lt;/a>。 我的建议是：&lt;/p>
&lt;ol>
&lt;li>发现问题之后，一定要全面排查，解决能发现的所有此类问题。&lt;/li>
&lt;li>另外，使用生命周期比较短的证书。这会反过来逼迫你们优化和自动化整个流程。&lt;/li>
&lt;/ol>
&lt;p>Let’s Encrypt 使自动化非常容易，它签发 90 天有效期的证书，因此对 Web PKI 来说非常合适。 对于 internal PKI，建议有效期签的更短：24 小时或更短。有一些实现上的挑战 —— &lt;a href="https://diogomonica.com/2017/01/11/hitless-tls-certificate-rotation-in-go/">hitless certificate rotation&lt;/a> 可能比较棘手 —— 但这些工作是值得的。&lt;/p>
&lt;p>用 step 检查证书过期时间：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>step certificate inspect cert.pem --format json | jq .validity.end
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>step certificate inspect https://smallstep.com --format json | jq .validity.end
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>将这种命令行封装到监控采集脚本，就可以实现某种程度的监控和自动化。&lt;/p>
&lt;h2 id="revocation撤销">Revocation（撤销）&lt;/h2>
&lt;p>如果一个私钥泄露了，或者一个证书已经不再用了，就需要撤销它。即希望：&lt;/p>
&lt;ol>
&lt;li>明确地将其标记为非法的，&lt;/li>
&lt;li>所有 RP 都不再信任这个证书了，即使它还未过期。&lt;/li>
&lt;/ol>
&lt;p>但实际上，&lt;strong>撤销证书过程也是一团糟&lt;/strong>。&lt;/p>
&lt;h3 id="主动撤销的困难">主动撤销的困难&lt;/h3>
&lt;ul>
&lt;li>与过期类似，&lt;strong>执行撤回的职责在 RP&lt;/strong>。&lt;/li>
&lt;li>与过期不同的是，&lt;strong>撤销状态无法编码在证书中&lt;/strong>。RP 只能依靠某些带外过程（out-of-band process） 来判断证书的撤销状态。&lt;/li>
&lt;/ul>
&lt;p>除非显式配置，否则大部分 Web PKI TLS RP 并不关注撤销状态。换句话说，默认情况下， 大部分 TLS 实现都乐于接受已经撤销的证书。&lt;/p>
&lt;h3 id="internal-pki被动撤销机制">Internal PKI：被动撤销机制&lt;/h3>
&lt;p>Internal PKI 的趋势是接受这个现实，然后试图通过&lt;strong>被动撤销&lt;/strong>（passive revocation）机制来弥补， 具体来说就是&lt;strong>签发生命周期很短的证书&lt;/strong>，这样就使撤销过程变得不再那么重要了。 想撤销一个证书时，直接不给它续期就行了，过一段时间就会自动过期。
可以看到，&lt;strong>这个机制有效的前提&lt;/strong>就是使用生命周期很短的证书。具体有多短？&lt;/p>
&lt;ol>
&lt;li>取决于你的威胁模型（安全专家说了算）。&lt;/li>
&lt;li>24 小时是很常见的，但也有短到 5 分钟的。&lt;/li>
&lt;li>如果生命周期太短，显然也会给可扩展性和可用性带来挑战：&lt;strong>每次续期都需要与 online CA 交互&lt;/strong>， 因此 CA 有性能压力。&lt;/li>
&lt;li>如果缩短了证书的生命周期，记得&lt;strong>确保你的时钟是同步的&lt;/strong>，否则就有罪受了。&lt;/li>
&lt;/ol>
&lt;p>对于 web 和其他的被动撤销不适合的场景，如果认真思考之后发现&lt;strong>真的&lt;/strong> 需要撤销功能，那有两个选择：&lt;/p>
&lt;ol>
&lt;li>CRL（，&lt;strong>证书撤销列表&lt;/strong>，RFC 5280）&lt;/li>
&lt;li>OCSP（Online Certificate Signing Protocol，&lt;strong>在线证书签名协议&lt;/strong>，RFC 2560）&lt;/li>
&lt;/ol>
&lt;h3 id="主动检查机制crl">主动检查机制：CRL&lt;/h3>
&lt;p>&lt;strong>Certificate Revocation Lists(证书吊销列表，简称 CRL)&lt;/strong> 定义在 RFC 5280 中，这是一个相当庞杂的 RFC，还定义了很多其他东西。 简单来是，CRL 是一个&lt;strong>有符号整数序列，用来识别已撤销的证书&lt;/strong>。
这个维护在一个 &lt;strong>CRL distribution point&lt;/strong> 服务中，每个证书中都包含指向这个服务的 URL。 工作流程：每个 RP 下载这个列表并缓存到本地，在对证书进行验证时，从本地缓存查询撤销状态。 但这里也有一些明显的问题：&lt;/p>
&lt;ol>
&lt;li>&lt;strong>CRL 可能很大&lt;/strong>，&lt;/li>
&lt;li>distribution point 也可能失效。&lt;/li>
&lt;li>RP 的 CRL 缓存同步经常是天级的，因此如果一个证书撤销了，可能要几天之后才能同步到这个状态。&lt;/li>
&lt;li>此外，RP &lt;em>fail open&lt;/em> 也很常见 —— CRL distribution point 挂了之后，就接受这个证书。 这显然是一个安全问题：只要对 CRL distribution point 发起 DDoS 攻击，就能让 RP 接受一个已经撤销的证书。&lt;/li>
&lt;/ol>
&lt;p>因此，即使已经在用 CRL，也应该考虑使用短时证书来保持 CRL size 比较小。 CRL 只需要包含&lt;strong>已撤销但还未过期的证书&lt;/strong>的 serial numbers，因此 证书生命周期越短，CRL 越短。&lt;/p>
&lt;h3 id="主动检查机制ocsp">主动检查机制：OCSP&lt;/h3>
&lt;p>主动检查机制除了 CRL 之外，另一个选择是 &lt;strong>Online Certificate Signing Protocol(简称 OCSP)&lt;/strong>，它允许 RP 实时查询一个 &lt;em>OCSP responder&lt;/em>： 指定证书的 serial number 来获取这个证书的撤销状态。
与 CRL distribution point 类似，OCSP responder URL 也包含在证书中。 这样看，OCSP 似乎更加友好，但实际上它也有自己的问题。对于 Web PKI，它引入了验证的隐私问题：&lt;/p>
&lt;ol>
&lt;li>每次查询 OCSP responder，使得它能看到我正在访问哪个网站。&lt;/li>
&lt;li>此外，它还增加了每个 TLS 连接的开销：需要一个额外请求来检查证实的撤销状态。&lt;/li>
&lt;li>与 CRL 一样，很多 RPs (including browsers) 会在 OCSP responder 失效时直接认为证书有效（未撤销）。&lt;/li>
&lt;/ol>
&lt;h3 id="主动检查机制ocsp-stapling合订绑定">主动检查机制：OCSP stapling（合订，绑定）&lt;/h3>
&lt;p>OCSP stapling 是 OCSP 的一个变种，目的是解决以上提到的那些问题。&lt;/p>
&lt;p>相比于让 RP 每次都去查询 OCSP responder，OCSP stapling 中让证书的 subscriber 来做这件事情。 OCSP response 是一个经过签名的、时间较短的证词（signed attestation），证明这个证书未被撤销。&lt;/p>
&lt;p>attestation 包含在 subscriber 和 RP 的 TLS handshake (“stapled to” the certificate) 中。 这给 RP 提供了相对比较及时的撤销状态，而不用每次都去查询 OCSP responder。 subscriber 可以在 signed OCSP response 过期之前多次使用它。这减少了 OCSP 的负担，也解决了 OCSP 的隐私问题。&lt;/p>
&lt;p>但是，所有这些东西其实最终都像是一个 **鲁布·戈德堡装置（Rube Goldberg Device） **，&lt;/p>
&lt;blockquote>
&lt;p>鲁布·戈德堡机械（Rube Goldberg machine）是一种被设计得过度复杂的机械组合，以 迂回曲折的方法去完成一些其实是非常简单的工作，例如倒一杯茶，或打一只蛋等等。 设计者必须计算精确，令机械的每个部件都能够准确发挥功用，因为任何一个环节出错 ，都极有可能令原定的任务不能达成。
解释来自 &lt;a href="https://www.zhihu.com/topic/20017497/intro">知乎&lt;/a>。&lt;/p>
&lt;/blockquote>
&lt;p>如果让 subscribers 去 CA 获取一些生命周期很短的证词（signed attestation）来证明对应的证书并没有过期， 为什么不直接干掉中间环节，直接使用生命周期很短的证书呢？&lt;/p>
&lt;h1 id="证书申请及签署步骤">证书申请及签署步骤&lt;/h1>
&lt;ol>
&lt;li>生成申请请求&lt;/li>
&lt;li>RA 核验你的申请信息&lt;/li>
&lt;li>CA 签署&lt;/li>
&lt;li>获取证书(从证书存取库)&lt;/li>
&lt;/ol>
&lt;p>私有 CA 的创建以及签发证书步骤，详细命令详见 2.0.OpenSSL.note 命令说明&lt;/p>
&lt;ol>
&lt;li>(可选)配置需要使用 CA 功能服务器的 CA 配置文件&lt;/li>
&lt;li>在 CA 功能服务器上创建自签证书以便给其余设备签证&lt;/li>
&lt;li>在需要签证的设备上创建密钥以及证书签署请求，并把请求文件发送给 CA 服务器&lt;/li>
&lt;li>CA 服务器给该请求签证后，把生成的证书文件发还给需要签证的设备。&lt;/li>
&lt;/ol>
&lt;p>吊销证书&lt;/p>
&lt;ol>
&lt;li>获取证书的 serial&lt;/li>
&lt;li>根据用户提交的 serial 与 subject 信息，对比验证是否与 index.txt 文件中的信息一致，使用吊销命令吊销/etc/pki/CA/newcerts/目录下对应的证书文件&lt;/li>
&lt;li>生成吊销证书的编号&lt;/li>
&lt;li>echo 01 &amp;gt; /etc/pki/CA/crl/NUM&lt;/li>
&lt;li>更新证书吊销列表&lt;/li>
&lt;/ol>
&lt;p>证书文件格式：&lt;/p>
&lt;ol>
&lt;li>XXX.pem #证书相关文件标准格式&lt;/li>
&lt;li>XXX.key #明确指明这是一个密钥文件&lt;/li>
&lt;li>XXX.csr #Certificate signing request。证书签署请求文件&lt;/li>
&lt;li>XXX.crt #明确指明这是一个证书文件&lt;/li>
&lt;/ol></description></item><item><title>Docs: 自建CA脚本</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/7.%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8/%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/%E8%87%AA%E5%BB%BAca%E8%84%9A%E6%9C%AC/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/7.%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8/%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/%E8%87%AA%E5%BB%BAca%E8%84%9A%E6%9C%AC/</guid><description>
&lt;blockquote>
&lt;p>参考：&lt;a href="https://rancher2.docs.rancher.cn/docs/installation/options/self-signed-ssl/_index">https://rancher2.docs.rancher.cn/docs/installation/options/self-signed-ssl/_index&lt;/a>&lt;/p>
&lt;/blockquote>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#!/bin/bash -e
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>help &lt;span style="color:#f92672">()&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> echo &lt;span style="color:#e6db74">&amp;#39; ================================================================ &amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> echo &lt;span style="color:#e6db74">&amp;#39; --ssl-domain: 生成ssl证书需要的主域名，如不指定则默认为www.rancher.local，如果是ip访问服务，则可忽略；&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> echo &lt;span style="color:#e6db74">&amp;#39; --ssl-trusted-ip: 一般ssl证书只信任域名的访问请求，有时候需要使用ip去访问server，那么需要给ssl证书添加扩展IP，多个IP用逗号隔开；&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> echo &lt;span style="color:#e6db74">&amp;#39; --ssl-trusted-domain: 如果想多个域名访问，则添加扩展域名（SSL_TRUSTED_DOMAIN）,多个扩展域名用逗号隔开；&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> echo &lt;span style="color:#e6db74">&amp;#39; --ssl-size: ssl加密位数，默认2048；&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> echo &lt;span style="color:#e6db74">&amp;#39; --ssl-cn: 国家代码(2个字母的代号),默认CN;&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> echo &lt;span style="color:#e6db74">&amp;#39; --ssl-date: 指定ca签署的证书有效期,默认10年;&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> echo &lt;span style="color:#e6db74">&amp;#39; --ca-date: 指定ca证书有效期,默认10年;&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> echo &lt;span style="color:#e6db74">&amp;#39; 使用示例:&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> echo &lt;span style="color:#e6db74">&amp;#39; ./create_self-signed-cert.sh --ssl-domain=www.test.com --ssl-trusted-domain=www.test2.com \ &amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> echo &lt;span style="color:#e6db74">&amp;#39; --ssl-trusted-ip=1.1.1.1,2.2.2.2,3.3.3.3 --ssl-size=2048 --ssl-date=36500 --ca-date=36500&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> echo &lt;span style="color:#e6db74">&amp;#39; ================================================================&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">case&lt;/span> &lt;span style="color:#e6db74">&amp;#34;&lt;/span>$1&lt;span style="color:#e6db74">&amp;#34;&lt;/span> in
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> -h|--help&lt;span style="color:#f92672">)&lt;/span> help; exit;;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">esac&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">if&lt;/span> &lt;span style="color:#f92672">[[&lt;/span> $1 &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#e6db74">&amp;#39;&amp;#39;&lt;/span> &lt;span style="color:#f92672">]]&lt;/span>;&lt;span style="color:#66d9ef">then&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> help;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> exit;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">fi&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>CMDOPTS&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>$*&lt;span style="color:#e6db74">&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">for&lt;/span> OPTS in $CMDOPTS;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">do&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> key&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#66d9ef">$(&lt;/span>echo &lt;span style="color:#e6db74">${&lt;/span>OPTS&lt;span style="color:#e6db74">}&lt;/span> | awk -F&lt;span style="color:#e6db74">&amp;#34;=&amp;#34;&lt;/span> &lt;span style="color:#e6db74">&amp;#39;{print $1}&amp;#39;&lt;/span> &lt;span style="color:#66d9ef">)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> value&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#66d9ef">$(&lt;/span>echo &lt;span style="color:#e6db74">${&lt;/span>OPTS&lt;span style="color:#e6db74">}&lt;/span> | awk -F&lt;span style="color:#e6db74">&amp;#34;=&amp;#34;&lt;/span> &lt;span style="color:#e6db74">&amp;#39;{print $2}&amp;#39;&lt;/span> &lt;span style="color:#66d9ef">)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">case&lt;/span> &lt;span style="color:#e6db74">&amp;#34;&lt;/span>$key&lt;span style="color:#e6db74">&amp;#34;&lt;/span> in
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> --ssl-domain&lt;span style="color:#f92672">)&lt;/span> SSL_DOMAIN&lt;span style="color:#f92672">=&lt;/span>$value ;;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> --ssl-trusted-ip&lt;span style="color:#f92672">)&lt;/span> SSL_TRUSTED_IP&lt;span style="color:#f92672">=&lt;/span>$value ;;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> --ssl-trusted-domain&lt;span style="color:#f92672">)&lt;/span> SSL_TRUSTED_DOMAIN&lt;span style="color:#f92672">=&lt;/span>$value ;;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> --ssl-size&lt;span style="color:#f92672">)&lt;/span> SSL_SIZE&lt;span style="color:#f92672">=&lt;/span>$value ;;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> --ssl-date&lt;span style="color:#f92672">)&lt;/span> SSL_DATE&lt;span style="color:#f92672">=&lt;/span>$value ;;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> --ca-date&lt;span style="color:#f92672">)&lt;/span> CA_DATE&lt;span style="color:#f92672">=&lt;/span>$value ;;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> --ssl-cn&lt;span style="color:#f92672">)&lt;/span> CN&lt;span style="color:#f92672">=&lt;/span>$value ;;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">esac&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">done&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># CA相关配置&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>CA_DATE&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">${&lt;/span>CA_DATE&lt;span style="color:#66d9ef">:-&lt;/span>3650&lt;span style="color:#e6db74">}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>CA_KEY&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">${&lt;/span>CA_KEY&lt;span style="color:#66d9ef">:-&lt;/span>cakey.pem&lt;span style="color:#e6db74">}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>CA_CERT&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">${&lt;/span>CA_CERT&lt;span style="color:#66d9ef">:-&lt;/span>cacerts.pem&lt;span style="color:#e6db74">}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>CA_DOMAIN&lt;span style="color:#f92672">=&lt;/span>cattle-ca
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># ssl相关配置&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>SSL_CONFIG&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">${&lt;/span>SSL_CONFIG&lt;span style="color:#66d9ef">:-&lt;/span>$PWD/openssl.cnf&lt;span style="color:#e6db74">}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>SSL_DOMAIN&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">${&lt;/span>SSL_DOMAIN&lt;span style="color:#66d9ef">:-&lt;/span>&lt;span style="color:#e6db74">&amp;#39;www.rancher.local&amp;#39;&lt;/span>&lt;span style="color:#e6db74">}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>SSL_DATE&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">${&lt;/span>SSL_DATE&lt;span style="color:#66d9ef">:-&lt;/span>3650&lt;span style="color:#e6db74">}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>SSL_SIZE&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">${&lt;/span>SSL_SIZE&lt;span style="color:#66d9ef">:-&lt;/span>2048&lt;span style="color:#e6db74">}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">## 国家代码(2个字母的代号),默认CN;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>CN&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">${&lt;/span>CN&lt;span style="color:#66d9ef">:-&lt;/span>CN&lt;span style="color:#e6db74">}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>SSL_KEY&lt;span style="color:#f92672">=&lt;/span>$SSL_DOMAIN.key
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>SSL_CSR&lt;span style="color:#f92672">=&lt;/span>$SSL_DOMAIN.csr
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>SSL_CERT&lt;span style="color:#f92672">=&lt;/span>$SSL_DOMAIN.crt
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>echo -e &lt;span style="color:#e6db74">&amp;#34;\033[32m ---------------------------- \033[0m&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>echo -e &lt;span style="color:#e6db74">&amp;#34;\033[32m | 生成 SSL Cert | \033[0m&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>echo -e &lt;span style="color:#e6db74">&amp;#34;\033[32m ---------------------------- \033[0m&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">if&lt;/span> &lt;span style="color:#f92672">[[&lt;/span> -e ./&lt;span style="color:#e6db74">${&lt;/span>CA_KEY&lt;span style="color:#e6db74">}&lt;/span> &lt;span style="color:#f92672">]]&lt;/span>; &lt;span style="color:#66d9ef">then&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> echo -e &lt;span style="color:#e6db74">&amp;#34;\033[32m ====&amp;gt; 1. 发现已存在CA私钥，备份&amp;#34;&lt;/span>&lt;span style="color:#e6db74">${&lt;/span>CA_KEY&lt;span style="color:#e6db74">}&lt;/span>&lt;span style="color:#e6db74">&amp;#34;为&amp;#34;&lt;/span>&lt;span style="color:#e6db74">${&lt;/span>CA_KEY&lt;span style="color:#e6db74">}&lt;/span>&lt;span style="color:#e6db74">&amp;#34;-bak，然后重新创建 \033[0m&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> mv &lt;span style="color:#e6db74">${&lt;/span>CA_KEY&lt;span style="color:#e6db74">}&lt;/span> &lt;span style="color:#e6db74">&amp;#34;&lt;/span>&lt;span style="color:#e6db74">${&lt;/span>CA_KEY&lt;span style="color:#e6db74">}&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>-bak
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> openssl genrsa -out &lt;span style="color:#e6db74">${&lt;/span>CA_KEY&lt;span style="color:#e6db74">}&lt;/span> &lt;span style="color:#e6db74">${&lt;/span>SSL_SIZE&lt;span style="color:#e6db74">}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">else&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> echo -e &lt;span style="color:#e6db74">&amp;#34;\033[32m ====&amp;gt; 1. 生成新的CA私钥 &lt;/span>&lt;span style="color:#e6db74">${&lt;/span>CA_KEY&lt;span style="color:#e6db74">}&lt;/span>&lt;span style="color:#e6db74"> \033[0m&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> openssl genrsa -out &lt;span style="color:#e6db74">${&lt;/span>CA_KEY&lt;span style="color:#e6db74">}&lt;/span> &lt;span style="color:#e6db74">${&lt;/span>SSL_SIZE&lt;span style="color:#e6db74">}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">fi&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">if&lt;/span> &lt;span style="color:#f92672">[[&lt;/span> -e ./&lt;span style="color:#e6db74">${&lt;/span>CA_CERT&lt;span style="color:#e6db74">}&lt;/span> &lt;span style="color:#f92672">]]&lt;/span>; &lt;span style="color:#66d9ef">then&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> echo -e &lt;span style="color:#e6db74">&amp;#34;\033[32m ====&amp;gt; 2. 发现已存在CA证书，先备份&amp;#34;&lt;/span>&lt;span style="color:#e6db74">${&lt;/span>CA_CERT&lt;span style="color:#e6db74">}&lt;/span>&lt;span style="color:#e6db74">&amp;#34;为&amp;#34;&lt;/span>&lt;span style="color:#e6db74">${&lt;/span>CA_CERT&lt;span style="color:#e6db74">}&lt;/span>&lt;span style="color:#e6db74">&amp;#34;-bak，然后重新创建 \033[0m&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> mv &lt;span style="color:#e6db74">${&lt;/span>CA_CERT&lt;span style="color:#e6db74">}&lt;/span> &lt;span style="color:#e6db74">&amp;#34;&lt;/span>&lt;span style="color:#e6db74">${&lt;/span>CA_CERT&lt;span style="color:#e6db74">}&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>-bak
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> openssl req -x509 -sha256 -new -nodes -key &lt;span style="color:#e6db74">${&lt;/span>CA_KEY&lt;span style="color:#e6db74">}&lt;/span> -days &lt;span style="color:#e6db74">${&lt;/span>CA_DATE&lt;span style="color:#e6db74">}&lt;/span> -out &lt;span style="color:#e6db74">${&lt;/span>CA_CERT&lt;span style="color:#e6db74">}&lt;/span> -subj &lt;span style="color:#e6db74">&amp;#34;/C=&lt;/span>&lt;span style="color:#e6db74">${&lt;/span>CN&lt;span style="color:#e6db74">}&lt;/span>&lt;span style="color:#e6db74">/CN=&lt;/span>&lt;span style="color:#e6db74">${&lt;/span>CA_DOMAIN&lt;span style="color:#e6db74">}&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">else&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> echo -e &lt;span style="color:#e6db74">&amp;#34;\033[32m ====&amp;gt; 2. 生成新的CA证书 &lt;/span>&lt;span style="color:#e6db74">${&lt;/span>CA_CERT&lt;span style="color:#e6db74">}&lt;/span>&lt;span style="color:#e6db74"> \033[0m&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> openssl req -x509 -sha256 -new -nodes -key &lt;span style="color:#e6db74">${&lt;/span>CA_KEY&lt;span style="color:#e6db74">}&lt;/span> -days &lt;span style="color:#e6db74">${&lt;/span>CA_DATE&lt;span style="color:#e6db74">}&lt;/span> -out &lt;span style="color:#e6db74">${&lt;/span>CA_CERT&lt;span style="color:#e6db74">}&lt;/span> -subj &lt;span style="color:#e6db74">&amp;#34;/C=&lt;/span>&lt;span style="color:#e6db74">${&lt;/span>CN&lt;span style="color:#e6db74">}&lt;/span>&lt;span style="color:#e6db74">/CN=&lt;/span>&lt;span style="color:#e6db74">${&lt;/span>CA_DOMAIN&lt;span style="color:#e6db74">}&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">fi&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>echo -e &lt;span style="color:#e6db74">&amp;#34;\033[32m ====&amp;gt; 3. 生成Openssl配置文件 &lt;/span>&lt;span style="color:#e6db74">${&lt;/span>SSL_CONFIG&lt;span style="color:#e6db74">}&lt;/span>&lt;span style="color:#e6db74"> \033[0m&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>cat &amp;gt; &lt;span style="color:#e6db74">${&lt;/span>SSL_CONFIG&lt;span style="color:#e6db74">}&lt;/span> &lt;span style="color:#e6db74">&amp;lt;&amp;lt;EOM
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">[req]
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">req_extensions = v3_req
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">distinguished_name = req_distinguished_name
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">[req_distinguished_name]
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">[ v3_req ]
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">basicConstraints = CA:FALSE
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">keyUsage = nonRepudiation, digitalSignature, keyEncipherment
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">extendedKeyUsage = clientAuth, serverAuth
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">EOM&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">if&lt;/span> &lt;span style="color:#f92672">[[&lt;/span> -n &lt;span style="color:#e6db74">${&lt;/span>SSL_TRUSTED_IP&lt;span style="color:#e6db74">}&lt;/span> &lt;span style="color:#f92672">||&lt;/span> -n &lt;span style="color:#e6db74">${&lt;/span>SSL_TRUSTED_DOMAIN&lt;span style="color:#e6db74">}&lt;/span> &lt;span style="color:#f92672">]]&lt;/span>; &lt;span style="color:#66d9ef">then&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> cat &amp;gt;&amp;gt; &lt;span style="color:#e6db74">${&lt;/span>SSL_CONFIG&lt;span style="color:#e6db74">}&lt;/span> &lt;span style="color:#e6db74">&amp;lt;&amp;lt;EOM
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">subjectAltName = @alt_names
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">[alt_names]
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">EOM&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> IFS&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;,&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> dns&lt;span style="color:#f92672">=(&lt;/span>&lt;span style="color:#e6db74">${&lt;/span>SSL_TRUSTED_DOMAIN&lt;span style="color:#e6db74">}&lt;/span>&lt;span style="color:#f92672">)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> dns&lt;span style="color:#f92672">+=(&lt;/span>&lt;span style="color:#e6db74">${&lt;/span>SSL_DOMAIN&lt;span style="color:#e6db74">}&lt;/span>&lt;span style="color:#f92672">)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span> i in &lt;span style="color:#e6db74">&amp;#34;&lt;/span>&lt;span style="color:#e6db74">${&lt;/span>!dns[@]&lt;span style="color:#e6db74">}&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>; &lt;span style="color:#66d9ef">do&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> echo DNS.&lt;span style="color:#66d9ef">$((&lt;/span>i+1&lt;span style="color:#66d9ef">))&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">${&lt;/span>dns[$i]&lt;span style="color:#e6db74">}&lt;/span> &amp;gt;&amp;gt; &lt;span style="color:#e6db74">${&lt;/span>SSL_CONFIG&lt;span style="color:#e6db74">}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">done&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> &lt;span style="color:#f92672">[[&lt;/span> -n &lt;span style="color:#e6db74">${&lt;/span>SSL_TRUSTED_IP&lt;span style="color:#e6db74">}&lt;/span> &lt;span style="color:#f92672">]]&lt;/span>; &lt;span style="color:#66d9ef">then&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ip&lt;span style="color:#f92672">=(&lt;/span>&lt;span style="color:#e6db74">${&lt;/span>SSL_TRUSTED_IP&lt;span style="color:#e6db74">}&lt;/span>&lt;span style="color:#f92672">)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span> i in &lt;span style="color:#e6db74">&amp;#34;&lt;/span>&lt;span style="color:#e6db74">${&lt;/span>!ip[@]&lt;span style="color:#e6db74">}&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>; &lt;span style="color:#66d9ef">do&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> echo IP.&lt;span style="color:#66d9ef">$((&lt;/span>i+1&lt;span style="color:#66d9ef">))&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">${&lt;/span>ip[$i]&lt;span style="color:#e6db74">}&lt;/span> &amp;gt;&amp;gt; &lt;span style="color:#e6db74">${&lt;/span>SSL_CONFIG&lt;span style="color:#e6db74">}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">done&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">fi&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">fi&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>echo -e &lt;span style="color:#e6db74">&amp;#34;\033[32m ====&amp;gt; 4. 生成服务SSL KEY &lt;/span>&lt;span style="color:#e6db74">${&lt;/span>SSL_KEY&lt;span style="color:#e6db74">}&lt;/span>&lt;span style="color:#e6db74"> \033[0m&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>openssl genrsa -out &lt;span style="color:#e6db74">${&lt;/span>SSL_KEY&lt;span style="color:#e6db74">}&lt;/span> &lt;span style="color:#e6db74">${&lt;/span>SSL_SIZE&lt;span style="color:#e6db74">}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>echo -e &lt;span style="color:#e6db74">&amp;#34;\033[32m ====&amp;gt; 5. 生成服务SSL CSR &lt;/span>&lt;span style="color:#e6db74">${&lt;/span>SSL_CSR&lt;span style="color:#e6db74">}&lt;/span>&lt;span style="color:#e6db74"> \033[0m&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>openssl req -sha256 -new -key &lt;span style="color:#e6db74">${&lt;/span>SSL_KEY&lt;span style="color:#e6db74">}&lt;/span> -out &lt;span style="color:#e6db74">${&lt;/span>SSL_CSR&lt;span style="color:#e6db74">}&lt;/span> -subj &lt;span style="color:#e6db74">&amp;#34;/C=&lt;/span>&lt;span style="color:#e6db74">${&lt;/span>CN&lt;span style="color:#e6db74">}&lt;/span>&lt;span style="color:#e6db74">/CN=&lt;/span>&lt;span style="color:#e6db74">${&lt;/span>SSL_DOMAIN&lt;span style="color:#e6db74">}&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span> -config &lt;span style="color:#e6db74">${&lt;/span>SSL_CONFIG&lt;span style="color:#e6db74">}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>echo -e &lt;span style="color:#e6db74">&amp;#34;\033[32m ====&amp;gt; 6. 生成服务SSL CERT &lt;/span>&lt;span style="color:#e6db74">${&lt;/span>SSL_CERT&lt;span style="color:#e6db74">}&lt;/span>&lt;span style="color:#e6db74"> \033[0m&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>openssl x509 -sha256 -req -in &lt;span style="color:#e6db74">${&lt;/span>SSL_CSR&lt;span style="color:#e6db74">}&lt;/span> -CA &lt;span style="color:#e6db74">${&lt;/span>CA_CERT&lt;span style="color:#e6db74">}&lt;/span> &lt;span style="color:#ae81ff">\
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">&lt;/span> -CAkey &lt;span style="color:#e6db74">${&lt;/span>CA_KEY&lt;span style="color:#e6db74">}&lt;/span> -CAcreateserial -out &lt;span style="color:#e6db74">${&lt;/span>SSL_CERT&lt;span style="color:#e6db74">}&lt;/span> &lt;span style="color:#ae81ff">\
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">&lt;/span> -days &lt;span style="color:#e6db74">${&lt;/span>SSL_DATE&lt;span style="color:#e6db74">}&lt;/span> -extensions v3_req &lt;span style="color:#ae81ff">\
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">&lt;/span> -extfile &lt;span style="color:#e6db74">${&lt;/span>SSL_CONFIG&lt;span style="color:#e6db74">}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>echo -e &lt;span style="color:#e6db74">&amp;#34;\033[32m ====&amp;gt; 7. 证书制作完成 \033[0m&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>echo
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>echo -e &lt;span style="color:#e6db74">&amp;#34;\033[32m ====&amp;gt; 8. 以YAML格式输出结果 \033[0m&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>echo &lt;span style="color:#e6db74">&amp;#34;----------------------------------------------------------&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>echo -e &lt;span style="color:#e6db74">&amp;#34;\033[32m ====&amp;gt; 9. 附加CA证书到Cert文件 \033[0m&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>cat &lt;span style="color:#e6db74">${&lt;/span>CA_CERT&lt;span style="color:#e6db74">}&lt;/span> &amp;gt;&amp;gt; &lt;span style="color:#e6db74">${&lt;/span>SSL_CERT&lt;span style="color:#e6db74">}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>echo -e &lt;span style="color:#e6db74">&amp;#34;\033[32m ====&amp;gt; 10. 重命名服务证书 \033[0m&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>echo &lt;span style="color:#e6db74">&amp;#34;cp &lt;/span>&lt;span style="color:#e6db74">${&lt;/span>SSL_DOMAIN&lt;span style="color:#e6db74">}&lt;/span>&lt;span style="color:#e6db74">.key tls.key&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>cp &lt;span style="color:#e6db74">${&lt;/span>SSL_DOMAIN&lt;span style="color:#e6db74">}&lt;/span>.key tls.key
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>echo &lt;span style="color:#e6db74">&amp;#34;cp &lt;/span>&lt;span style="color:#e6db74">${&lt;/span>SSL_DOMAIN&lt;span style="color:#e6db74">}&lt;/span>&lt;span style="color:#e6db74">.crt tls.crt&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>cp &lt;span style="color:#e6db74">${&lt;/span>SSL_DOMAIN&lt;span style="color:#e6db74">}&lt;/span>.crt tls.crt
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div></description></item></channel></rss>