<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>断念梦 – 8.通用技术</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/8.%E9%80%9A%E7%94%A8%E6%8A%80%E6%9C%AF/</link><description>Recent content in 8.通用技术 on 断念梦</description><generator>Hugo -- gohugo.io</generator><atom:link href="https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/8.%E9%80%9A%E7%94%A8%E6%8A%80%E6%9C%AF/index.xml" rel="self" type="application/rss+xml"/><item><title>Docs: ASCII 表</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/8.%E9%80%9A%E7%94%A8%E6%8A%80%E6%9C%AF/%E7%BC%96%E7%A0%81%E8%A7%A3%E7%A0%81%E4%B8%8E%E5%8D%8F%E8%AE%AE/%E5%AD%97%E7%AC%A6%E7%9A%84%E7%BC%96%E7%A0%81%E4%B8%8E%E8%A7%A3%E7%A0%81/ascii-%E8%A1%A8/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/8.%E9%80%9A%E7%94%A8%E6%8A%80%E6%9C%AF/%E7%BC%96%E7%A0%81%E8%A7%A3%E7%A0%81%E4%B8%8E%E5%8D%8F%E8%AE%AE/%E5%AD%97%E7%AC%A6%E7%9A%84%E7%BC%96%E7%A0%81%E4%B8%8E%E8%A7%A3%E7%A0%81/ascii-%E8%A1%A8/</guid><description>
&lt;p>原文链接：&lt;a href="https://www.middlewareinventory.com/ascii-table/">https://www.middlewareinventory.com/ascii-table/&lt;/a>&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>Character&lt;/th>
&lt;th>Binary Value&lt;/th>
&lt;th>Decimal Value&lt;/th>
&lt;th>Octal Value&lt;/th>
&lt;th>Hex Value&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>NUL – null&lt;/td>
&lt;td>0&lt;/td>
&lt;td>0&lt;/td>
&lt;td>0&lt;/td>
&lt;td>0&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>SOH – start of heading&lt;/td>
&lt;td>1&lt;/td>
&lt;td>1&lt;/td>
&lt;td>1&lt;/td>
&lt;td>1&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>STX – start of text&lt;/td>
&lt;td>10&lt;/td>
&lt;td>2&lt;/td>
&lt;td>2&lt;/td>
&lt;td>2&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>ETX – end of text&lt;/td>
&lt;td>11&lt;/td>
&lt;td>3&lt;/td>
&lt;td>3&lt;/td>
&lt;td>3&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>EOT – end of transmission&lt;/td>
&lt;td>100&lt;/td>
&lt;td>4&lt;/td>
&lt;td>4&lt;/td>
&lt;td>4&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>ENQ – enquiry&lt;/td>
&lt;td>101&lt;/td>
&lt;td>5&lt;/td>
&lt;td>5&lt;/td>
&lt;td>5&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>ACK – acknowledge&lt;/td>
&lt;td>110&lt;/td>
&lt;td>6&lt;/td>
&lt;td>6&lt;/td>
&lt;td>6&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>BEL – bell&lt;/td>
&lt;td>111&lt;/td>
&lt;td>7&lt;/td>
&lt;td>7&lt;/td>
&lt;td>7&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>BS – backspace&lt;/td>
&lt;td>1000&lt;/td>
&lt;td>8&lt;/td>
&lt;td>10&lt;/td>
&lt;td>8&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>TAB – horizontal tab&lt;/td>
&lt;td>1001&lt;/td>
&lt;td>9&lt;/td>
&lt;td>11&lt;/td>
&lt;td>9&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>LF – line feed&lt;/td>
&lt;td>1010&lt;/td>
&lt;td>10&lt;/td>
&lt;td>12&lt;/td>
&lt;td>A&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>VT – vertical tab&lt;/td>
&lt;td>1011&lt;/td>
&lt;td>11&lt;/td>
&lt;td>13&lt;/td>
&lt;td>B&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>FF – form feed&lt;/td>
&lt;td>1100&lt;/td>
&lt;td>12&lt;/td>
&lt;td>14&lt;/td>
&lt;td>C&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>CR – carriage return&lt;/td>
&lt;td>1101&lt;/td>
&lt;td>13&lt;/td>
&lt;td>15&lt;/td>
&lt;td>D&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>SO – shift out&lt;/td>
&lt;td>1110&lt;/td>
&lt;td>14&lt;/td>
&lt;td>16&lt;/td>
&lt;td>E&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>SI – shift in&lt;/td>
&lt;td>1111&lt;/td>
&lt;td>15&lt;/td>
&lt;td>17&lt;/td>
&lt;td>F&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>DLE – data link escape&lt;/td>
&lt;td>10000&lt;/td>
&lt;td>16&lt;/td>
&lt;td>20&lt;/td>
&lt;td>10&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>DC1 – device control 1&lt;/td>
&lt;td>10001&lt;/td>
&lt;td>17&lt;/td>
&lt;td>21&lt;/td>
&lt;td>11&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>DC2 – device control 2&lt;/td>
&lt;td>10010&lt;/td>
&lt;td>18&lt;/td>
&lt;td>22&lt;/td>
&lt;td>12&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>DC3 – device control 3&lt;/td>
&lt;td>10011&lt;/td>
&lt;td>19&lt;/td>
&lt;td>23&lt;/td>
&lt;td>13&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>DC4 – device control 4&lt;/td>
&lt;td>10100&lt;/td>
&lt;td>20&lt;/td>
&lt;td>24&lt;/td>
&lt;td>14&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>NAK – negative acknowledge&lt;/td>
&lt;td>10101&lt;/td>
&lt;td>21&lt;/td>
&lt;td>25&lt;/td>
&lt;td>15&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>SYN – synchronous idle&lt;/td>
&lt;td>10110&lt;/td>
&lt;td>22&lt;/td>
&lt;td>26&lt;/td>
&lt;td>16&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>ETB – end of trans. block&lt;/td>
&lt;td>10111&lt;/td>
&lt;td>23&lt;/td>
&lt;td>27&lt;/td>
&lt;td>17&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>CAN – cancel&lt;/td>
&lt;td>11000&lt;/td>
&lt;td>24&lt;/td>
&lt;td>30&lt;/td>
&lt;td>18&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>EM – end of medium&lt;/td>
&lt;td>11001&lt;/td>
&lt;td>25&lt;/td>
&lt;td>31&lt;/td>
&lt;td>19&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>SUB – substitute&lt;/td>
&lt;td>11010&lt;/td>
&lt;td>26&lt;/td>
&lt;td>32&lt;/td>
&lt;td>1A&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>ESC – escape&lt;/td>
&lt;td>11011&lt;/td>
&lt;td>27&lt;/td>
&lt;td>33&lt;/td>
&lt;td>1B&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>FS – file separator&lt;/td>
&lt;td>11100&lt;/td>
&lt;td>28&lt;/td>
&lt;td>34&lt;/td>
&lt;td>1C&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>GS – group separator&lt;/td>
&lt;td>11101&lt;/td>
&lt;td>29&lt;/td>
&lt;td>35&lt;/td>
&lt;td>1D&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>RS – record separator&lt;/td>
&lt;td>11110&lt;/td>
&lt;td>30&lt;/td>
&lt;td>36&lt;/td>
&lt;td>1E&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>US – unit separator&lt;/td>
&lt;td>11111&lt;/td>
&lt;td>31&lt;/td>
&lt;td>37&lt;/td>
&lt;td>1F&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>SP – Space&lt;/td>
&lt;td>100000&lt;/td>
&lt;td>32&lt;/td>
&lt;td>40&lt;/td>
&lt;td>20&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>!&lt;/td>
&lt;td>100001&lt;/td>
&lt;td>33&lt;/td>
&lt;td>41&lt;/td>
&lt;td>21&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>“&lt;/td>
&lt;td>100010&lt;/td>
&lt;td>34&lt;/td>
&lt;td>42&lt;/td>
&lt;td>22&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>#&lt;/td>
&lt;td>100011&lt;/td>
&lt;td>35&lt;/td>
&lt;td>43&lt;/td>
&lt;td>23&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>$&lt;/td>
&lt;td>100100&lt;/td>
&lt;td>36&lt;/td>
&lt;td>44&lt;/td>
&lt;td>24&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>%&lt;/td>
&lt;td>100101&lt;/td>
&lt;td>37&lt;/td>
&lt;td>45&lt;/td>
&lt;td>25&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&amp;amp;&lt;/td>
&lt;td>100110&lt;/td>
&lt;td>38&lt;/td>
&lt;td>46&lt;/td>
&lt;td>26&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>‘&lt;/td>
&lt;td>100111&lt;/td>
&lt;td>39&lt;/td>
&lt;td>47&lt;/td>
&lt;td>27&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>(&lt;/td>
&lt;td>101000&lt;/td>
&lt;td>40&lt;/td>
&lt;td>50&lt;/td>
&lt;td>28&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>)&lt;/td>
&lt;td>101001&lt;/td>
&lt;td>41&lt;/td>
&lt;td>51&lt;/td>
&lt;td>29&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>*&lt;/td>
&lt;td>101010&lt;/td>
&lt;td>42&lt;/td>
&lt;td>52&lt;/td>
&lt;td>2A&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>+&lt;/td>
&lt;td>101011&lt;/td>
&lt;td>43&lt;/td>
&lt;td>53&lt;/td>
&lt;td>2B&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>,&lt;/td>
&lt;td>101100&lt;/td>
&lt;td>44&lt;/td>
&lt;td>54&lt;/td>
&lt;td>2C&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>–&lt;/td>
&lt;td>101101&lt;/td>
&lt;td>45&lt;/td>
&lt;td>55&lt;/td>
&lt;td>2D&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>.&lt;/td>
&lt;td>101110&lt;/td>
&lt;td>46&lt;/td>
&lt;td>56&lt;/td>
&lt;td>2E&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>/&lt;/td>
&lt;td>101111&lt;/td>
&lt;td>47&lt;/td>
&lt;td>57&lt;/td>
&lt;td>2F&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>0&lt;/td>
&lt;td>110000&lt;/td>
&lt;td>48&lt;/td>
&lt;td>60&lt;/td>
&lt;td>30&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>1&lt;/td>
&lt;td>110001&lt;/td>
&lt;td>49&lt;/td>
&lt;td>61&lt;/td>
&lt;td>31&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>2&lt;/td>
&lt;td>110010&lt;/td>
&lt;td>50&lt;/td>
&lt;td>62&lt;/td>
&lt;td>32&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>3&lt;/td>
&lt;td>110011&lt;/td>
&lt;td>51&lt;/td>
&lt;td>63&lt;/td>
&lt;td>33&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>4&lt;/td>
&lt;td>110100&lt;/td>
&lt;td>52&lt;/td>
&lt;td>64&lt;/td>
&lt;td>34&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>5&lt;/td>
&lt;td>110101&lt;/td>
&lt;td>53&lt;/td>
&lt;td>65&lt;/td>
&lt;td>35&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>6&lt;/td>
&lt;td>110110&lt;/td>
&lt;td>54&lt;/td>
&lt;td>66&lt;/td>
&lt;td>36&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>7&lt;/td>
&lt;td>110111&lt;/td>
&lt;td>55&lt;/td>
&lt;td>67&lt;/td>
&lt;td>37&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>8&lt;/td>
&lt;td>111000&lt;/td>
&lt;td>56&lt;/td>
&lt;td>70&lt;/td>
&lt;td>38&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>9&lt;/td>
&lt;td>111001&lt;/td>
&lt;td>57&lt;/td>
&lt;td>71&lt;/td>
&lt;td>39&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>:&lt;/td>
&lt;td>111010&lt;/td>
&lt;td>58&lt;/td>
&lt;td>72&lt;/td>
&lt;td>3A&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>;&lt;/td>
&lt;td>111011&lt;/td>
&lt;td>59&lt;/td>
&lt;td>73&lt;/td>
&lt;td>3B&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&amp;lt;&lt;/td>
&lt;td>111100&lt;/td>
&lt;td>60&lt;/td>
&lt;td>74&lt;/td>
&lt;td>3C&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>=&lt;/td>
&lt;td>111101&lt;/td>
&lt;td>61&lt;/td>
&lt;td>75&lt;/td>
&lt;td>3D&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&amp;gt;&lt;/td>
&lt;td>111110&lt;/td>
&lt;td>62&lt;/td>
&lt;td>76&lt;/td>
&lt;td>3E&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>?&lt;/td>
&lt;td>111111&lt;/td>
&lt;td>63&lt;/td>
&lt;td>77&lt;/td>
&lt;td>3F&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>@&lt;/td>
&lt;td>1000000&lt;/td>
&lt;td>64&lt;/td>
&lt;td>100&lt;/td>
&lt;td>40&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>A&lt;/td>
&lt;td>1000001&lt;/td>
&lt;td>65&lt;/td>
&lt;td>101&lt;/td>
&lt;td>41&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>B&lt;/td>
&lt;td>1000010&lt;/td>
&lt;td>66&lt;/td>
&lt;td>102&lt;/td>
&lt;td>42&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>C&lt;/td>
&lt;td>1000011&lt;/td>
&lt;td>67&lt;/td>
&lt;td>103&lt;/td>
&lt;td>43&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>D&lt;/td>
&lt;td>1000100&lt;/td>
&lt;td>68&lt;/td>
&lt;td>104&lt;/td>
&lt;td>44&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>E&lt;/td>
&lt;td>1000101&lt;/td>
&lt;td>69&lt;/td>
&lt;td>105&lt;/td>
&lt;td>45&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>F&lt;/td>
&lt;td>1000110&lt;/td>
&lt;td>70&lt;/td>
&lt;td>106&lt;/td>
&lt;td>46&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>G&lt;/td>
&lt;td>1000111&lt;/td>
&lt;td>71&lt;/td>
&lt;td>107&lt;/td>
&lt;td>47&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>H&lt;/td>
&lt;td>1001000&lt;/td>
&lt;td>72&lt;/td>
&lt;td>110&lt;/td>
&lt;td>48&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>I&lt;/td>
&lt;td>1001001&lt;/td>
&lt;td>73&lt;/td>
&lt;td>111&lt;/td>
&lt;td>49&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>J&lt;/td>
&lt;td>1001010&lt;/td>
&lt;td>74&lt;/td>
&lt;td>112&lt;/td>
&lt;td>4A&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>K&lt;/td>
&lt;td>1001011&lt;/td>
&lt;td>75&lt;/td>
&lt;td>113&lt;/td>
&lt;td>4B&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>L&lt;/td>
&lt;td>1001100&lt;/td>
&lt;td>76&lt;/td>
&lt;td>114&lt;/td>
&lt;td>4C&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>M&lt;/td>
&lt;td>1001101&lt;/td>
&lt;td>77&lt;/td>
&lt;td>115&lt;/td>
&lt;td>4D&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>N&lt;/td>
&lt;td>1001110&lt;/td>
&lt;td>78&lt;/td>
&lt;td>116&lt;/td>
&lt;td>4E&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>O&lt;/td>
&lt;td>1001111&lt;/td>
&lt;td>79&lt;/td>
&lt;td>117&lt;/td>
&lt;td>4F&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>P&lt;/td>
&lt;td>1010000&lt;/td>
&lt;td>80&lt;/td>
&lt;td>120&lt;/td>
&lt;td>50&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Q&lt;/td>
&lt;td>1010001&lt;/td>
&lt;td>81&lt;/td>
&lt;td>121&lt;/td>
&lt;td>51&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>R&lt;/td>
&lt;td>1010010&lt;/td>
&lt;td>82&lt;/td>
&lt;td>122&lt;/td>
&lt;td>52&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>S&lt;/td>
&lt;td>1010011&lt;/td>
&lt;td>83&lt;/td>
&lt;td>123&lt;/td>
&lt;td>53&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>T&lt;/td>
&lt;td>1010100&lt;/td>
&lt;td>84&lt;/td>
&lt;td>124&lt;/td>
&lt;td>54&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>U&lt;/td>
&lt;td>1010101&lt;/td>
&lt;td>85&lt;/td>
&lt;td>125&lt;/td>
&lt;td>55&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>V&lt;/td>
&lt;td>1010110&lt;/td>
&lt;td>86&lt;/td>
&lt;td>126&lt;/td>
&lt;td>56&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>W&lt;/td>
&lt;td>1010111&lt;/td>
&lt;td>87&lt;/td>
&lt;td>127&lt;/td>
&lt;td>57&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>X&lt;/td>
&lt;td>1011000&lt;/td>
&lt;td>88&lt;/td>
&lt;td>130&lt;/td>
&lt;td>58&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Y&lt;/td>
&lt;td>1011001&lt;/td>
&lt;td>89&lt;/td>
&lt;td>131&lt;/td>
&lt;td>59&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Z&lt;/td>
&lt;td>1011010&lt;/td>
&lt;td>90&lt;/td>
&lt;td>132&lt;/td>
&lt;td>5A&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>[&lt;/td>
&lt;td>1011011&lt;/td>
&lt;td>91&lt;/td>
&lt;td>133&lt;/td>
&lt;td>5B&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>\&lt;/td>
&lt;td>1011100&lt;/td>
&lt;td>92&lt;/td>
&lt;td>134&lt;/td>
&lt;td>5C&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>]&lt;/td>
&lt;td>1011101&lt;/td>
&lt;td>93&lt;/td>
&lt;td>135&lt;/td>
&lt;td>5D&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>^&lt;/td>
&lt;td>1011110&lt;/td>
&lt;td>94&lt;/td>
&lt;td>136&lt;/td>
&lt;td>5E&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>_&lt;/td>
&lt;td>1011111&lt;/td>
&lt;td>95&lt;/td>
&lt;td>137&lt;/td>
&lt;td>5F&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>`&lt;/td>
&lt;td>1100000&lt;/td>
&lt;td>96&lt;/td>
&lt;td>140&lt;/td>
&lt;td>60&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>a&lt;/td>
&lt;td>1100001&lt;/td>
&lt;td>97&lt;/td>
&lt;td>141&lt;/td>
&lt;td>61&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>b&lt;/td>
&lt;td>1100010&lt;/td>
&lt;td>98&lt;/td>
&lt;td>142&lt;/td>
&lt;td>62&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>c&lt;/td>
&lt;td>1100011&lt;/td>
&lt;td>99&lt;/td>
&lt;td>143&lt;/td>
&lt;td>63&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>d&lt;/td>
&lt;td>1100100&lt;/td>
&lt;td>100&lt;/td>
&lt;td>144&lt;/td>
&lt;td>64&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>e&lt;/td>
&lt;td>1100101&lt;/td>
&lt;td>101&lt;/td>
&lt;td>145&lt;/td>
&lt;td>65&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>f&lt;/td>
&lt;td>1100110&lt;/td>
&lt;td>102&lt;/td>
&lt;td>146&lt;/td>
&lt;td>66&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>g&lt;/td>
&lt;td>1100111&lt;/td>
&lt;td>103&lt;/td>
&lt;td>147&lt;/td>
&lt;td>67&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>h&lt;/td>
&lt;td>1101000&lt;/td>
&lt;td>104&lt;/td>
&lt;td>150&lt;/td>
&lt;td>68&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>i&lt;/td>
&lt;td>1101001&lt;/td>
&lt;td>105&lt;/td>
&lt;td>151&lt;/td>
&lt;td>69&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>j&lt;/td>
&lt;td>1101010&lt;/td>
&lt;td>106&lt;/td>
&lt;td>152&lt;/td>
&lt;td>6A&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>k&lt;/td>
&lt;td>1101011&lt;/td>
&lt;td>107&lt;/td>
&lt;td>153&lt;/td>
&lt;td>6B&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>l&lt;/td>
&lt;td>1101100&lt;/td>
&lt;td>108&lt;/td>
&lt;td>154&lt;/td>
&lt;td>6C&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>m&lt;/td>
&lt;td>1101101&lt;/td>
&lt;td>109&lt;/td>
&lt;td>155&lt;/td>
&lt;td>6D&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>n&lt;/td>
&lt;td>1101110&lt;/td>
&lt;td>110&lt;/td>
&lt;td>156&lt;/td>
&lt;td>6E&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>o&lt;/td>
&lt;td>1101111&lt;/td>
&lt;td>111&lt;/td>
&lt;td>157&lt;/td>
&lt;td>6F&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>p&lt;/td>
&lt;td>1110000&lt;/td>
&lt;td>112&lt;/td>
&lt;td>160&lt;/td>
&lt;td>70&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>q&lt;/td>
&lt;td>1110001&lt;/td>
&lt;td>113&lt;/td>
&lt;td>161&lt;/td>
&lt;td>71&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>r&lt;/td>
&lt;td>1110010&lt;/td>
&lt;td>114&lt;/td>
&lt;td>162&lt;/td>
&lt;td>72&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>s&lt;/td>
&lt;td>1110011&lt;/td>
&lt;td>115&lt;/td>
&lt;td>163&lt;/td>
&lt;td>73&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>t&lt;/td>
&lt;td>1110100&lt;/td>
&lt;td>116&lt;/td>
&lt;td>164&lt;/td>
&lt;td>74&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>u&lt;/td>
&lt;td>1110101&lt;/td>
&lt;td>117&lt;/td>
&lt;td>165&lt;/td>
&lt;td>75&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>v&lt;/td>
&lt;td>1110110&lt;/td>
&lt;td>118&lt;/td>
&lt;td>166&lt;/td>
&lt;td>76&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>w&lt;/td>
&lt;td>1110111&lt;/td>
&lt;td>119&lt;/td>
&lt;td>167&lt;/td>
&lt;td>77&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>x&lt;/td>
&lt;td>1111000&lt;/td>
&lt;td>120&lt;/td>
&lt;td>170&lt;/td>
&lt;td>78&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>y&lt;/td>
&lt;td>1111001&lt;/td>
&lt;td>121&lt;/td>
&lt;td>171&lt;/td>
&lt;td>79&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>z&lt;/td>
&lt;td>1111010&lt;/td>
&lt;td>122&lt;/td>
&lt;td>172&lt;/td>
&lt;td>7A&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>{&lt;/td>
&lt;td>1111011&lt;/td>
&lt;td>123&lt;/td>
&lt;td>173&lt;/td>
&lt;td>7B&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;td>1111100&lt;/td>
&lt;td>124&lt;/td>
&lt;td>174&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>}&lt;/td>
&lt;td>1111101&lt;/td>
&lt;td>125&lt;/td>
&lt;td>175&lt;/td>
&lt;td>7D&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>~&lt;/td>
&lt;td>1111110&lt;/td>
&lt;td>126&lt;/td>
&lt;td>176&lt;/td>
&lt;td>7E&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;/td>
&lt;td>1111111&lt;/td>
&lt;td>127&lt;/td>
&lt;td>177&lt;/td>
&lt;td>7F&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>€&lt;/td>
&lt;td>10000000&lt;/td>
&lt;td>128&lt;/td>
&lt;td>200&lt;/td>
&lt;td>80&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>�&lt;/td>
&lt;td>10000001&lt;/td>
&lt;td>129&lt;/td>
&lt;td>201&lt;/td>
&lt;td>81&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>‚&lt;/td>
&lt;td>10000010&lt;/td>
&lt;td>130&lt;/td>
&lt;td>202&lt;/td>
&lt;td>82&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>ƒ&lt;/td>
&lt;td>10000011&lt;/td>
&lt;td>131&lt;/td>
&lt;td>203&lt;/td>
&lt;td>83&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>„&lt;/td>
&lt;td>10000100&lt;/td>
&lt;td>132&lt;/td>
&lt;td>204&lt;/td>
&lt;td>84&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>…&lt;/td>
&lt;td>10000101&lt;/td>
&lt;td>133&lt;/td>
&lt;td>205&lt;/td>
&lt;td>85&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>†&lt;/td>
&lt;td>10000110&lt;/td>
&lt;td>134&lt;/td>
&lt;td>206&lt;/td>
&lt;td>86&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>‡&lt;/td>
&lt;td>10000111&lt;/td>
&lt;td>135&lt;/td>
&lt;td>207&lt;/td>
&lt;td>87&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>ˆ&lt;/td>
&lt;td>10001000&lt;/td>
&lt;td>136&lt;/td>
&lt;td>210&lt;/td>
&lt;td>88&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>‰&lt;/td>
&lt;td>10001001&lt;/td>
&lt;td>137&lt;/td>
&lt;td>211&lt;/td>
&lt;td>89&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Š&lt;/td>
&lt;td>10001010&lt;/td>
&lt;td>138&lt;/td>
&lt;td>212&lt;/td>
&lt;td>8A&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>‹&lt;/td>
&lt;td>10001011&lt;/td>
&lt;td>139&lt;/td>
&lt;td>213&lt;/td>
&lt;td>8B&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Œ&lt;/td>
&lt;td>10001100&lt;/td>
&lt;td>140&lt;/td>
&lt;td>214&lt;/td>
&lt;td>8C&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>�&lt;/td>
&lt;td>10001101&lt;/td>
&lt;td>141&lt;/td>
&lt;td>215&lt;/td>
&lt;td>8D&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Ž&lt;/td>
&lt;td>10001110&lt;/td>
&lt;td>142&lt;/td>
&lt;td>216&lt;/td>
&lt;td>8E&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>�&lt;/td>
&lt;td>10001111&lt;/td>
&lt;td>143&lt;/td>
&lt;td>217&lt;/td>
&lt;td>8F&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>�&lt;/td>
&lt;td>10010000&lt;/td>
&lt;td>144&lt;/td>
&lt;td>220&lt;/td>
&lt;td>90&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>‘&lt;/td>
&lt;td>10010001&lt;/td>
&lt;td>145&lt;/td>
&lt;td>221&lt;/td>
&lt;td>91&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>’&lt;/td>
&lt;td>10010010&lt;/td>
&lt;td>146&lt;/td>
&lt;td>222&lt;/td>
&lt;td>92&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>“&lt;/td>
&lt;td>10010011&lt;/td>
&lt;td>147&lt;/td>
&lt;td>223&lt;/td>
&lt;td>93&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>”&lt;/td>
&lt;td>10010100&lt;/td>
&lt;td>148&lt;/td>
&lt;td>224&lt;/td>
&lt;td>94&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>•&lt;/td>
&lt;td>10010101&lt;/td>
&lt;td>149&lt;/td>
&lt;td>225&lt;/td>
&lt;td>95&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>–&lt;/td>
&lt;td>10010110&lt;/td>
&lt;td>150&lt;/td>
&lt;td>226&lt;/td>
&lt;td>96&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>—&lt;/td>
&lt;td>10010111&lt;/td>
&lt;td>151&lt;/td>
&lt;td>227&lt;/td>
&lt;td>97&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>˜&lt;/td>
&lt;td>10011000&lt;/td>
&lt;td>152&lt;/td>
&lt;td>230&lt;/td>
&lt;td>98&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>™&lt;/td>
&lt;td>10011001&lt;/td>
&lt;td>153&lt;/td>
&lt;td>231&lt;/td>
&lt;td>99&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>š&lt;/td>
&lt;td>10011010&lt;/td>
&lt;td>154&lt;/td>
&lt;td>232&lt;/td>
&lt;td>9A&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>›&lt;/td>
&lt;td>10011011&lt;/td>
&lt;td>155&lt;/td>
&lt;td>233&lt;/td>
&lt;td>9B&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>œ&lt;/td>
&lt;td>10011100&lt;/td>
&lt;td>156&lt;/td>
&lt;td>234&lt;/td>
&lt;td>9C&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>�&lt;/td>
&lt;td>10011101&lt;/td>
&lt;td>157&lt;/td>
&lt;td>235&lt;/td>
&lt;td>9D&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>ž&lt;/td>
&lt;td>10011110&lt;/td>
&lt;td>158&lt;/td>
&lt;td>236&lt;/td>
&lt;td>9E&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Ÿ&lt;/td>
&lt;td>10011111&lt;/td>
&lt;td>159&lt;/td>
&lt;td>237&lt;/td>
&lt;td>9F&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;/td>
&lt;td>10100000&lt;/td>
&lt;td>160&lt;/td>
&lt;td>240&lt;/td>
&lt;td>A0&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>¡&lt;/td>
&lt;td>10100001&lt;/td>
&lt;td>161&lt;/td>
&lt;td>241&lt;/td>
&lt;td>A1&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>¢&lt;/td>
&lt;td>10100010&lt;/td>
&lt;td>162&lt;/td>
&lt;td>242&lt;/td>
&lt;td>A2&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>£&lt;/td>
&lt;td>10100011&lt;/td>
&lt;td>163&lt;/td>
&lt;td>243&lt;/td>
&lt;td>A3&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>¤&lt;/td>
&lt;td>10100100&lt;/td>
&lt;td>164&lt;/td>
&lt;td>244&lt;/td>
&lt;td>A4&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>¥&lt;/td>
&lt;td>10100101&lt;/td>
&lt;td>165&lt;/td>
&lt;td>245&lt;/td>
&lt;td>A5&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>¦&lt;/td>
&lt;td>10100110&lt;/td>
&lt;td>166&lt;/td>
&lt;td>246&lt;/td>
&lt;td>A6&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>§&lt;/td>
&lt;td>10100111&lt;/td>
&lt;td>167&lt;/td>
&lt;td>247&lt;/td>
&lt;td>A7&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>¨&lt;/td>
&lt;td>10101000&lt;/td>
&lt;td>168&lt;/td>
&lt;td>250&lt;/td>
&lt;td>A8&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>©&lt;/td>
&lt;td>10101001&lt;/td>
&lt;td>169&lt;/td>
&lt;td>251&lt;/td>
&lt;td>A9&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>ª&lt;/td>
&lt;td>10101010&lt;/td>
&lt;td>170&lt;/td>
&lt;td>252&lt;/td>
&lt;td>AA&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>«&lt;/td>
&lt;td>10101011&lt;/td>
&lt;td>171&lt;/td>
&lt;td>253&lt;/td>
&lt;td>AB&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>¬&lt;/td>
&lt;td>10101100&lt;/td>
&lt;td>172&lt;/td>
&lt;td>254&lt;/td>
&lt;td>AC&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;/td>
&lt;td>10101101&lt;/td>
&lt;td>173&lt;/td>
&lt;td>255&lt;/td>
&lt;td>AD&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>®&lt;/td>
&lt;td>10101110&lt;/td>
&lt;td>174&lt;/td>
&lt;td>256&lt;/td>
&lt;td>AE&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>¯&lt;/td>
&lt;td>10101111&lt;/td>
&lt;td>175&lt;/td>
&lt;td>257&lt;/td>
&lt;td>AF&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>°&lt;/td>
&lt;td>10110000&lt;/td>
&lt;td>176&lt;/td>
&lt;td>260&lt;/td>
&lt;td>B0&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>±&lt;/td>
&lt;td>10110001&lt;/td>
&lt;td>177&lt;/td>
&lt;td>261&lt;/td>
&lt;td>B1&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>²&lt;/td>
&lt;td>10110010&lt;/td>
&lt;td>178&lt;/td>
&lt;td>262&lt;/td>
&lt;td>B2&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>³&lt;/td>
&lt;td>10110011&lt;/td>
&lt;td>179&lt;/td>
&lt;td>263&lt;/td>
&lt;td>B3&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>´&lt;/td>
&lt;td>10110100&lt;/td>
&lt;td>180&lt;/td>
&lt;td>264&lt;/td>
&lt;td>B4&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>µ&lt;/td>
&lt;td>10110101&lt;/td>
&lt;td>181&lt;/td>
&lt;td>265&lt;/td>
&lt;td>B5&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>¶&lt;/td>
&lt;td>10110110&lt;/td>
&lt;td>182&lt;/td>
&lt;td>266&lt;/td>
&lt;td>B6&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>·&lt;/td>
&lt;td>10110111&lt;/td>
&lt;td>183&lt;/td>
&lt;td>267&lt;/td>
&lt;td>B7&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>¸&lt;/td>
&lt;td>10111000&lt;/td>
&lt;td>184&lt;/td>
&lt;td>270&lt;/td>
&lt;td>B8&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>¹&lt;/td>
&lt;td>10111001&lt;/td>
&lt;td>185&lt;/td>
&lt;td>271&lt;/td>
&lt;td>B9&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>º&lt;/td>
&lt;td>10111010&lt;/td>
&lt;td>186&lt;/td>
&lt;td>272&lt;/td>
&lt;td>BA&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>»&lt;/td>
&lt;td>10111011&lt;/td>
&lt;td>187&lt;/td>
&lt;td>273&lt;/td>
&lt;td>BB&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>¼&lt;/td>
&lt;td>10111100&lt;/td>
&lt;td>188&lt;/td>
&lt;td>274&lt;/td>
&lt;td>BC&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>½&lt;/td>
&lt;td>10111101&lt;/td>
&lt;td>189&lt;/td>
&lt;td>275&lt;/td>
&lt;td>BD&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>¾&lt;/td>
&lt;td>10111110&lt;/td>
&lt;td>190&lt;/td>
&lt;td>276&lt;/td>
&lt;td>BE&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>¿&lt;/td>
&lt;td>10111111&lt;/td>
&lt;td>191&lt;/td>
&lt;td>277&lt;/td>
&lt;td>BF&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>À&lt;/td>
&lt;td>11000000&lt;/td>
&lt;td>192&lt;/td>
&lt;td>300&lt;/td>
&lt;td>C0&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Á&lt;/td>
&lt;td>11000001&lt;/td>
&lt;td>193&lt;/td>
&lt;td>301&lt;/td>
&lt;td>C1&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Â&lt;/td>
&lt;td>11000010&lt;/td>
&lt;td>194&lt;/td>
&lt;td>302&lt;/td>
&lt;td>C2&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Ã&lt;/td>
&lt;td>11000011&lt;/td>
&lt;td>195&lt;/td>
&lt;td>303&lt;/td>
&lt;td>C3&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Ä&lt;/td>
&lt;td>11000100&lt;/td>
&lt;td>196&lt;/td>
&lt;td>304&lt;/td>
&lt;td>C4&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Å&lt;/td>
&lt;td>11000101&lt;/td>
&lt;td>197&lt;/td>
&lt;td>305&lt;/td>
&lt;td>C5&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Æ&lt;/td>
&lt;td>11000110&lt;/td>
&lt;td>198&lt;/td>
&lt;td>306&lt;/td>
&lt;td>C6&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Ç&lt;/td>
&lt;td>11000111&lt;/td>
&lt;td>199&lt;/td>
&lt;td>307&lt;/td>
&lt;td>C7&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>È&lt;/td>
&lt;td>11001000&lt;/td>
&lt;td>200&lt;/td>
&lt;td>310&lt;/td>
&lt;td>C8&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>É&lt;/td>
&lt;td>11001001&lt;/td>
&lt;td>201&lt;/td>
&lt;td>311&lt;/td>
&lt;td>C9&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Ê&lt;/td>
&lt;td>11001010&lt;/td>
&lt;td>202&lt;/td>
&lt;td>312&lt;/td>
&lt;td>CA&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Ë&lt;/td>
&lt;td>11001011&lt;/td>
&lt;td>203&lt;/td>
&lt;td>313&lt;/td>
&lt;td>CB&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Ì&lt;/td>
&lt;td>11001100&lt;/td>
&lt;td>204&lt;/td>
&lt;td>314&lt;/td>
&lt;td>CC&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Í&lt;/td>
&lt;td>11001101&lt;/td>
&lt;td>205&lt;/td>
&lt;td>315&lt;/td>
&lt;td>CD&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Î&lt;/td>
&lt;td>11001110&lt;/td>
&lt;td>206&lt;/td>
&lt;td>316&lt;/td>
&lt;td>CE&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Ï&lt;/td>
&lt;td>11001111&lt;/td>
&lt;td>207&lt;/td>
&lt;td>317&lt;/td>
&lt;td>CF&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Ð&lt;/td>
&lt;td>11010000&lt;/td>
&lt;td>208&lt;/td>
&lt;td>320&lt;/td>
&lt;td>D0&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Ñ&lt;/td>
&lt;td>11010001&lt;/td>
&lt;td>209&lt;/td>
&lt;td>321&lt;/td>
&lt;td>D1&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Ò&lt;/td>
&lt;td>11010010&lt;/td>
&lt;td>210&lt;/td>
&lt;td>322&lt;/td>
&lt;td>D2&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Ó&lt;/td>
&lt;td>11010011&lt;/td>
&lt;td>211&lt;/td>
&lt;td>323&lt;/td>
&lt;td>D3&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Ô&lt;/td>
&lt;td>11010100&lt;/td>
&lt;td>212&lt;/td>
&lt;td>324&lt;/td>
&lt;td>D4&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Õ&lt;/td>
&lt;td>11010101&lt;/td>
&lt;td>213&lt;/td>
&lt;td>325&lt;/td>
&lt;td>D5&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Ö&lt;/td>
&lt;td>11010110&lt;/td>
&lt;td>214&lt;/td>
&lt;td>326&lt;/td>
&lt;td>D6&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>×&lt;/td>
&lt;td>11010111&lt;/td>
&lt;td>215&lt;/td>
&lt;td>327&lt;/td>
&lt;td>D7&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Ø&lt;/td>
&lt;td>11011000&lt;/td>
&lt;td>216&lt;/td>
&lt;td>330&lt;/td>
&lt;td>D8&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Ù&lt;/td>
&lt;td>11011001&lt;/td>
&lt;td>217&lt;/td>
&lt;td>331&lt;/td>
&lt;td>D9&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Ú&lt;/td>
&lt;td>11011010&lt;/td>
&lt;td>218&lt;/td>
&lt;td>332&lt;/td>
&lt;td>DA&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Û&lt;/td>
&lt;td>11011011&lt;/td>
&lt;td>219&lt;/td>
&lt;td>333&lt;/td>
&lt;td>DB&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Ü&lt;/td>
&lt;td>11011100&lt;/td>
&lt;td>220&lt;/td>
&lt;td>334&lt;/td>
&lt;td>DC&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Ý&lt;/td>
&lt;td>11011101&lt;/td>
&lt;td>221&lt;/td>
&lt;td>335&lt;/td>
&lt;td>DD&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Þ&lt;/td>
&lt;td>11011110&lt;/td>
&lt;td>222&lt;/td>
&lt;td>336&lt;/td>
&lt;td>DE&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>ß&lt;/td>
&lt;td>11011111&lt;/td>
&lt;td>223&lt;/td>
&lt;td>337&lt;/td>
&lt;td>DF&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>à&lt;/td>
&lt;td>11100000&lt;/td>
&lt;td>224&lt;/td>
&lt;td>340&lt;/td>
&lt;td>E0&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>á&lt;/td>
&lt;td>11100001&lt;/td>
&lt;td>225&lt;/td>
&lt;td>341&lt;/td>
&lt;td>E1&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>â&lt;/td>
&lt;td>11100010&lt;/td>
&lt;td>226&lt;/td>
&lt;td>342&lt;/td>
&lt;td>E2&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>ã&lt;/td>
&lt;td>11100011&lt;/td>
&lt;td>227&lt;/td>
&lt;td>343&lt;/td>
&lt;td>E3&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>ä&lt;/td>
&lt;td>11100100&lt;/td>
&lt;td>228&lt;/td>
&lt;td>344&lt;/td>
&lt;td>E4&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>å&lt;/td>
&lt;td>11100101&lt;/td>
&lt;td>229&lt;/td>
&lt;td>345&lt;/td>
&lt;td>E5&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>æ&lt;/td>
&lt;td>11100110&lt;/td>
&lt;td>230&lt;/td>
&lt;td>346&lt;/td>
&lt;td>E6&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>ç&lt;/td>
&lt;td>11100111&lt;/td>
&lt;td>231&lt;/td>
&lt;td>347&lt;/td>
&lt;td>E7&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>è&lt;/td>
&lt;td>11101000&lt;/td>
&lt;td>232&lt;/td>
&lt;td>350&lt;/td>
&lt;td>E8&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>é&lt;/td>
&lt;td>11101001&lt;/td>
&lt;td>233&lt;/td>
&lt;td>351&lt;/td>
&lt;td>E9&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>ê&lt;/td>
&lt;td>11101010&lt;/td>
&lt;td>234&lt;/td>
&lt;td>352&lt;/td>
&lt;td>EA&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>ë&lt;/td>
&lt;td>11101011&lt;/td>
&lt;td>235&lt;/td>
&lt;td>353&lt;/td>
&lt;td>EB&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>ì&lt;/td>
&lt;td>11101100&lt;/td>
&lt;td>236&lt;/td>
&lt;td>354&lt;/td>
&lt;td>EC&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>í&lt;/td>
&lt;td>11101101&lt;/td>
&lt;td>237&lt;/td>
&lt;td>355&lt;/td>
&lt;td>ED&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>î&lt;/td>
&lt;td>11101110&lt;/td>
&lt;td>238&lt;/td>
&lt;td>356&lt;/td>
&lt;td>EE&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>ï&lt;/td>
&lt;td>11101111&lt;/td>
&lt;td>239&lt;/td>
&lt;td>357&lt;/td>
&lt;td>EF&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>ð&lt;/td>
&lt;td>11110000&lt;/td>
&lt;td>240&lt;/td>
&lt;td>360&lt;/td>
&lt;td>F0&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>ñ&lt;/td>
&lt;td>11110001&lt;/td>
&lt;td>241&lt;/td>
&lt;td>361&lt;/td>
&lt;td>F1&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>ò&lt;/td>
&lt;td>11110010&lt;/td>
&lt;td>242&lt;/td>
&lt;td>362&lt;/td>
&lt;td>F2&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>ó&lt;/td>
&lt;td>11110011&lt;/td>
&lt;td>243&lt;/td>
&lt;td>363&lt;/td>
&lt;td>F3&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>ô&lt;/td>
&lt;td>11110100&lt;/td>
&lt;td>244&lt;/td>
&lt;td>364&lt;/td>
&lt;td>F4&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>õ&lt;/td>
&lt;td>11110101&lt;/td>
&lt;td>245&lt;/td>
&lt;td>365&lt;/td>
&lt;td>F5&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>ö&lt;/td>
&lt;td>11110110&lt;/td>
&lt;td>246&lt;/td>
&lt;td>366&lt;/td>
&lt;td>F6&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>÷&lt;/td>
&lt;td>11110111&lt;/td>
&lt;td>247&lt;/td>
&lt;td>367&lt;/td>
&lt;td>F7&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>ø&lt;/td>
&lt;td>11111000&lt;/td>
&lt;td>248&lt;/td>
&lt;td>370&lt;/td>
&lt;td>F8&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>ù&lt;/td>
&lt;td>11111001&lt;/td>
&lt;td>249&lt;/td>
&lt;td>371&lt;/td>
&lt;td>F9&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>ú&lt;/td>
&lt;td>11111010&lt;/td>
&lt;td>250&lt;/td>
&lt;td>372&lt;/td>
&lt;td>FA&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>û&lt;/td>
&lt;td>11111011&lt;/td>
&lt;td>251&lt;/td>
&lt;td>373&lt;/td>
&lt;td>FB&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>ü&lt;/td>
&lt;td>11111100&lt;/td>
&lt;td>252&lt;/td>
&lt;td>374&lt;/td>
&lt;td>FC&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>ý&lt;/td>
&lt;td>11111101&lt;/td>
&lt;td>253&lt;/td>
&lt;td>375&lt;/td>
&lt;td>FD&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>þ&lt;/td>
&lt;td>11111110&lt;/td>
&lt;td>254&lt;/td>
&lt;td>376&lt;/td>
&lt;td>FE&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>ÿ&lt;/td>
&lt;td>11111111&lt;/td>
&lt;td>255&lt;/td>
&lt;td>377&lt;/td>
&lt;td>FF&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table></description></item><item><title>Docs: Base64 编码</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/8.%E9%80%9A%E7%94%A8%E6%8A%80%E6%9C%AF/%E7%BC%96%E7%A0%81%E8%A7%A3%E7%A0%81%E4%B8%8E%E5%8D%8F%E8%AE%AE/base64-%E7%BC%96%E7%A0%81/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/8.%E9%80%9A%E7%94%A8%E6%8A%80%E6%9C%AF/%E7%BC%96%E7%A0%81%E8%A7%A3%E7%A0%81%E4%B8%8E%E5%8D%8F%E8%AE%AE/base64-%E7%BC%96%E7%A0%81/</guid><description>
&lt;blockquote>
&lt;p>参考：&lt;a href="https://en.wikipedia.org/wiki/Base64">Wiki&lt;/a>&lt;/p>
&lt;/blockquote>
&lt;p>Base64 是一组 **二进制 到 文本 **的编码方案，它是基于64个可打印的字符来表示二进制的数据的一种方法。二进制的数据中的每一个位数的内容，都可以通过字符来表示。&lt;/p>
&lt;p>对于所有二进制到文本编码方案而言，Base64都被设计为在只能可靠地支持文本内容的通道上以二进制格式存储数据。Base64在万维网[1]上特别流行，它的用途包括将图像文件或其他二进制资产嵌入文本资产（例如HTML和CSS文件）中的功能。[2]&lt;/p>
&lt;p>Base64还广泛用于发送电子邮件附件。这是必需的，因为SMTP（原始格式）仅设计为传输7位ASCII字符。这种编码会产生33–36％的开销（编码本身的开销为33％；插入的换行符最多可导致3％的开销）。&lt;/p></description></item><item><title>Docs: CDN</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/8.%E9%80%9A%E7%94%A8%E6%8A%80%E6%9C%AF/cdn/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/8.%E9%80%9A%E7%94%A8%E6%8A%80%E6%9C%AF/cdn/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;p>&lt;a href="http://3ms.huawei.com/km/groups/1002549/home?l=zh-cn#category=5402776">http://3ms.huawei.com/km/groups/1002549/home?l=zh-cn#category=5402776&lt;/a> 学习材料&lt;/p>
&lt;p>&lt;strong>Content Delivery Network(内容分发网络，简称 CDN)&lt;/strong>&lt;/p>
&lt;p>内容的定义：内容就是资源，人们浏览的网页，下载的数据，观看的视频等等都属于内容范畴&lt;/p>
&lt;p>CDN 产生的原因以及 CDN 的基本概念&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/yiw4sk/1616130888007-9f69ee92-f49a-47b2-981d-de386691f4b4.jpeg" alt="">&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/yiw4sk/1616130887987-dbdd175d-b52c-42e6-93b4-dfb190aa09d2.jpeg" alt="">&lt;/p>
&lt;p>非签约模式：即不通过与内容提供方签约的方式来获取资源镜像&lt;/p>
&lt;ol>
&lt;li>DNS 引流&lt;/li>
&lt;li>流量镜像&lt;/li>
&lt;/ol>
&lt;p>签约模式：即与内容提供方签约后，获取对方的资源景象&lt;/p>
&lt;ol>
&lt;li>通过 CNAME，域名的别名方式来重定向用户请求&lt;/li>
&lt;/ol>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>&lt;/th>
&lt;th>&lt;/th>
&lt;th>&lt;/th>
&lt;th>&lt;/th>
&lt;th>&lt;/th>
&lt;th>&lt;/th>
&lt;th>&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>模式&lt;/td>
&lt;td>非签约模式&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;td>签约模式&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>文件类型&lt;/td>
&lt;td>大文件(视频类，下载类)&lt;/td>
&lt;td>小文件(网页类)&lt;/td>
&lt;td>大文件(视频类，下载类)&lt;/td>
&lt;td>小文件(网页类)&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>调度模式&lt;/td>
&lt;td>流量镜像&lt;/td>
&lt;td>本地 DNS&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>DNS 引流，转发&lt;/td>
&lt;td>全局 DNS+本地 HTTP&lt;/td>
&lt;td>全局 DNS&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>CDN 流程&lt;/p>
&lt;p>Cache 结构&lt;/p>
&lt;p>用户请求资源的缓存状态信息表：&lt;/p>
&lt;ol>
&lt;li>TCP_HIT：内网用户请求的资源是 HCS 已缓存资源，内网用户获取的资源来自于 HCS 中的已缓存资源。&lt;/li>
&lt;li>TCP_MISS：内网用户请求的资源不是 HCS 已缓存资源，内网用户获取的资源来自于外网 Web 服务器。&lt;/li>
&lt;li>TCP_CNC_MISS：内网用户请求的头部规定不缓存这个资源，HCS 不缓存这个资源，内网用户获取的资源来自于外网 Web 服务器。&lt;/li>
&lt;li>TCP_SNC_MISS：外网 Web 服务器返回的头部规定不缓存这个资源，HCS 不缓存这个资源，内网用户获取的资源来自于外网 Web 服务器。&lt;/li>
&lt;li>TCP_REFRESH(刷新)_HIT：内网用户请求的资源命中了 HCS 已缓存资源，但 HCS 需要检查这个资源是否已更新，外网 Web 服务器通知 HCS 这个资源未修改，HCS 将这个资源发送给内网用户。&lt;/li>
&lt;li>TCP_REFRESH_MISS_METADATA：外网 Web 服务器返回一个对应请求资源的 304 报文，表示这个资源已临时被移走。&lt;/li>
&lt;li>TCP_REFRESH_MISS：内网用户请求的资源命中了 HCS 已缓存资源，但 HCS 需要检查这个资源是否已更新，外网 Web 服务器通知 HCS 这个资源已经过期，HCS 重新从 Web 服务器获取这个资源后再发送给内网用户。&lt;/li>
&lt;li>TCP_PARTIAL(部分)_HIT：客户端分段请求文件的时候，命中请求资源。&lt;/li>
&lt;li>TCP_PARTIAL_MISS：客户端分段请求文件的时候，未命中请求资源。&lt;/li>
&lt;li>TCP_REFRESH_UKN_MISS：内网用户请求的资源命中了 HCS 已缓存资源，但 HCS 需要检查这个资源是否已更新，但未能判断出是否更新，代理访问。&lt;/li>
&lt;li>TCP_REFRESH_NC_MISS：内网用户请求的资源命中了 HCS 已缓存资源，但 HCS 需要检查这个资源是否已更新，，外网 Web 服务器通知 HCS 这个资源未修改，但未从本地吐出，代理访问。&lt;/li>
&lt;/ol>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/yiw4sk/1616130887966-257146b0-91a9-4008-a239-adfa46ce58b9.jpeg" alt="">&lt;/p></description></item><item><title>Docs: go rabbitmq 库</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/8.%E9%80%9A%E7%94%A8%E6%8A%80%E6%9C%AF/message-queue%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/rabbitmq/go-rabbitmq-%E5%BA%93/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/8.%E9%80%9A%E7%94%A8%E6%8A%80%E6%9C%AF/message-queue%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/rabbitmq/go-rabbitmq-%E5%BA%93/</guid><description>
&lt;h1 id="heading">&lt;/h1>
&lt;p>&lt;a href="http://www.topgoer.com/%25E6%2595%25B0%25E6%258D%25AE%25E5%25BA%2593%25E6%2593%258D%25E4%25BD%259C/go%25E6%2593%258D%25E4%25BD%259CRabbitMQ/Simple%25E6%25A8%25A1%25E5%25BC%258F.html">http://www.topgoer.com/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%93%8D%E4%BD%9C/go%E6%93%8D%E4%BD%9CRabbitMQ/Simple%E6%A8%A1%E5%BC%8F.html&lt;/a>&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">package&lt;/span> &lt;span style="color:#a6e22e">RabbitMQ&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">import&lt;/span> (
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#34;fmt&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#34;log&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#34;github.com/streadway/amqp&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">//连接信息amqp://kuteng:kuteng@127.0.0.1:5672/kuteng这个信息是固定不变的amqp://事固定参数后面两个是用户名密码ip地址端口号Virtual Host
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">const&lt;/span> &lt;span style="color:#a6e22e">MQURL&lt;/span> = &lt;span style="color:#e6db74">&amp;#34;amqp://kuteng:kuteng@127.0.0.1:5672/kuteng&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">//rabbitMQ结构体
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">type&lt;/span> &lt;span style="color:#a6e22e">RabbitMQ&lt;/span> &lt;span style="color:#66d9ef">struct&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">conn&lt;/span> &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">amqp&lt;/span>.&lt;span style="color:#a6e22e">Connection&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">channel&lt;/span> &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">amqp&lt;/span>.&lt;span style="color:#a6e22e">Channel&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">//队列名称
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#a6e22e">QueueName&lt;/span> &lt;span style="color:#66d9ef">string&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">//交换机名称
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#a6e22e">Exchange&lt;/span> &lt;span style="color:#66d9ef">string&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">//bind Key 名称
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#a6e22e">Key&lt;/span> &lt;span style="color:#66d9ef">string&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">//连接信息
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#a6e22e">Mqurl&lt;/span> &lt;span style="color:#66d9ef">string&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">//创建结构体实例
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">func&lt;/span> &lt;span style="color:#a6e22e">NewRabbitMQ&lt;/span>(&lt;span style="color:#a6e22e">queueName&lt;/span> &lt;span style="color:#66d9ef">string&lt;/span>, &lt;span style="color:#a6e22e">exchange&lt;/span> &lt;span style="color:#66d9ef">string&lt;/span>, &lt;span style="color:#a6e22e">key&lt;/span> &lt;span style="color:#66d9ef">string&lt;/span>) &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">RabbitMQ&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#f92672">&amp;amp;&lt;/span>&lt;span style="color:#a6e22e">RabbitMQ&lt;/span>{&lt;span style="color:#a6e22e">QueueName&lt;/span>: &lt;span style="color:#a6e22e">queueName&lt;/span>, &lt;span style="color:#a6e22e">Exchange&lt;/span>: &lt;span style="color:#a6e22e">exchange&lt;/span>, &lt;span style="color:#a6e22e">Key&lt;/span>: &lt;span style="color:#a6e22e">key&lt;/span>, &lt;span style="color:#a6e22e">Mqurl&lt;/span>: &lt;span style="color:#a6e22e">MQURL&lt;/span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">//断开channel 和 connection
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">func&lt;/span> (&lt;span style="color:#a6e22e">r&lt;/span> &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">RabbitMQ&lt;/span>) &lt;span style="color:#a6e22e">Destory&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">r&lt;/span>.&lt;span style="color:#a6e22e">channel&lt;/span>.&lt;span style="color:#a6e22e">Close&lt;/span>()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">r&lt;/span>.&lt;span style="color:#a6e22e">conn&lt;/span>.&lt;span style="color:#a6e22e">Close&lt;/span>()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">//错误处理函数
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">func&lt;/span> (&lt;span style="color:#a6e22e">r&lt;/span> &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">RabbitMQ&lt;/span>) &lt;span style="color:#a6e22e">failOnErr&lt;/span>(&lt;span style="color:#a6e22e">err&lt;/span> &lt;span style="color:#66d9ef">error&lt;/span>, &lt;span style="color:#a6e22e">message&lt;/span> &lt;span style="color:#66d9ef">string&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> &lt;span style="color:#a6e22e">err&lt;/span> &lt;span style="color:#f92672">!=&lt;/span> &lt;span style="color:#66d9ef">nil&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">log&lt;/span>.&lt;span style="color:#a6e22e">Fatalf&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;%s:%s&amp;#34;&lt;/span>, &lt;span style="color:#a6e22e">message&lt;/span>, &lt;span style="color:#a6e22e">err&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> panic(&lt;span style="color:#a6e22e">fmt&lt;/span>.&lt;span style="color:#a6e22e">Sprintf&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;%s:%s&amp;#34;&lt;/span>, &lt;span style="color:#a6e22e">message&lt;/span>, &lt;span style="color:#a6e22e">err&lt;/span>))
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">//创建简单模式下RabbitMQ实例
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">func&lt;/span> &lt;span style="color:#a6e22e">NewRabbitMQSimple&lt;/span>(&lt;span style="color:#a6e22e">queueName&lt;/span> &lt;span style="color:#66d9ef">string&lt;/span>) &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">RabbitMQ&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">//创建RabbitMQ实例
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#a6e22e">rabbitmq&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">NewRabbitMQ&lt;/span>(&lt;span style="color:#a6e22e">queueName&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;&amp;#34;&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">var&lt;/span> &lt;span style="color:#a6e22e">err&lt;/span> &lt;span style="color:#66d9ef">error&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">//获取connection
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#a6e22e">rabbitmq&lt;/span>.&lt;span style="color:#a6e22e">conn&lt;/span>, &lt;span style="color:#a6e22e">err&lt;/span> = &lt;span style="color:#a6e22e">amqp&lt;/span>.&lt;span style="color:#a6e22e">Dial&lt;/span>(&lt;span style="color:#a6e22e">rabbitmq&lt;/span>.&lt;span style="color:#a6e22e">Mqurl&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">rabbitmq&lt;/span>.&lt;span style="color:#a6e22e">failOnErr&lt;/span>(&lt;span style="color:#a6e22e">err&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;failed to connect rabb&amp;#34;&lt;/span>&lt;span style="color:#f92672">+&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#34;itmq!&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">//获取channel
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#a6e22e">rabbitmq&lt;/span>.&lt;span style="color:#a6e22e">channel&lt;/span>, &lt;span style="color:#a6e22e">err&lt;/span> = &lt;span style="color:#a6e22e">rabbitmq&lt;/span>.&lt;span style="color:#a6e22e">conn&lt;/span>.&lt;span style="color:#a6e22e">Channel&lt;/span>()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">rabbitmq&lt;/span>.&lt;span style="color:#a6e22e">failOnErr&lt;/span>(&lt;span style="color:#a6e22e">err&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;failed to open a channel&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#a6e22e">rabbitmq&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">//直接模式队列生产
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">func&lt;/span> (&lt;span style="color:#a6e22e">r&lt;/span> &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">RabbitMQ&lt;/span>) &lt;span style="color:#a6e22e">PublishSimple&lt;/span>(&lt;span style="color:#a6e22e">message&lt;/span> &lt;span style="color:#66d9ef">string&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">//1.申请队列，如果队列不存在会自动创建，存在则跳过创建
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#a6e22e">_&lt;/span>, &lt;span style="color:#a6e22e">err&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">r&lt;/span>.&lt;span style="color:#a6e22e">channel&lt;/span>.&lt;span style="color:#a6e22e">QueueDeclare&lt;/span>(
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">r&lt;/span>.&lt;span style="color:#a6e22e">QueueName&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">//是否持久化
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">false&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">//是否自动删除
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">false&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">//是否具有排他性
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">false&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">//是否阻塞处理
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">false&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">//额外的属性
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">nil&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> )
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> &lt;span style="color:#a6e22e">err&lt;/span> &lt;span style="color:#f92672">!=&lt;/span> &lt;span style="color:#66d9ef">nil&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">fmt&lt;/span>.&lt;span style="color:#a6e22e">Println&lt;/span>(&lt;span style="color:#a6e22e">err&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">//调用channel 发送消息到队列中
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#a6e22e">r&lt;/span>.&lt;span style="color:#a6e22e">channel&lt;/span>.&lt;span style="color:#a6e22e">Publish&lt;/span>(
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">r&lt;/span>.&lt;span style="color:#a6e22e">Exchange&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">r&lt;/span>.&lt;span style="color:#a6e22e">QueueName&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">//如果为true，根据自身exchange类型和routekey规则无法找到符合条件的队列会把消息返还给发送者
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">false&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">//如果为true，当exchange发送消息到队列后发现队列上没有消费者，则会把消息返还给发送者
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">false&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">amqp&lt;/span>.&lt;span style="color:#a6e22e">Publishing&lt;/span>{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">ContentType&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;text/plain&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">Body&lt;/span>: []byte(&lt;span style="color:#a6e22e">message&lt;/span>),
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> })
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">//simple 模式下消费者
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">func&lt;/span> (&lt;span style="color:#a6e22e">r&lt;/span> &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">RabbitMQ&lt;/span>) &lt;span style="color:#a6e22e">ConsumeSimple&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">//1.申请队列，如果队列不存在会自动创建，存在则跳过创建
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#a6e22e">q&lt;/span>, &lt;span style="color:#a6e22e">err&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">r&lt;/span>.&lt;span style="color:#a6e22e">channel&lt;/span>.&lt;span style="color:#a6e22e">QueueDeclare&lt;/span>(
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">r&lt;/span>.&lt;span style="color:#a6e22e">QueueName&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">//是否持久化
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">false&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">//是否自动删除
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">false&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">//是否具有排他性
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">false&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">//是否阻塞处理
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">false&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">//额外的属性
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">nil&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> )
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> &lt;span style="color:#a6e22e">err&lt;/span> &lt;span style="color:#f92672">!=&lt;/span> &lt;span style="color:#66d9ef">nil&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">fmt&lt;/span>.&lt;span style="color:#a6e22e">Println&lt;/span>(&lt;span style="color:#a6e22e">err&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">//接收消息
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#a6e22e">msgs&lt;/span>, &lt;span style="color:#a6e22e">err&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">r&lt;/span>.&lt;span style="color:#a6e22e">channel&lt;/span>.&lt;span style="color:#a6e22e">Consume&lt;/span>(
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">q&lt;/span>.&lt;span style="color:#a6e22e">Name&lt;/span>, &lt;span style="color:#75715e">// queue
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#75715e">//用来区分多个消费者
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#e6db74">&amp;#34;&amp;#34;&lt;/span>, &lt;span style="color:#75715e">// consumer
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#75715e">//是否自动应答
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">true&lt;/span>, &lt;span style="color:#75715e">// auto-ack
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#75715e">//是否独有
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">false&lt;/span>, &lt;span style="color:#75715e">// exclusive
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#75715e">//设置为true，表示 不能将同一个Conenction中生产者发送的消息传递给这个Connection中 的消费者
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">false&lt;/span>, &lt;span style="color:#75715e">// no-local
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#75715e">//列是否阻塞
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">false&lt;/span>, &lt;span style="color:#75715e">// no-wait
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">nil&lt;/span>, &lt;span style="color:#75715e">// args
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> )
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> &lt;span style="color:#a6e22e">err&lt;/span> &lt;span style="color:#f92672">!=&lt;/span> &lt;span style="color:#66d9ef">nil&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">fmt&lt;/span>.&lt;span style="color:#a6e22e">Println&lt;/span>(&lt;span style="color:#a6e22e">err&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">forever&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> make(&lt;span style="color:#66d9ef">chan&lt;/span> &lt;span style="color:#66d9ef">bool&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">//启用协程处理消息
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">go&lt;/span> &lt;span style="color:#66d9ef">func&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span> &lt;span style="color:#a6e22e">d&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#66d9ef">range&lt;/span> &lt;span style="color:#a6e22e">msgs&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">//消息逻辑处理，可以自行设计逻辑
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#a6e22e">log&lt;/span>.&lt;span style="color:#a6e22e">Printf&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;Received a message: %s&amp;#34;&lt;/span>, &lt;span style="color:#a6e22e">d&lt;/span>.&lt;span style="color:#a6e22e">Body&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">log&lt;/span>.&lt;span style="color:#a6e22e">Printf&lt;/span>(&lt;span style="color:#e6db74">&amp;#34; [*] Waiting for messages. To exit press CTRL+C&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;-&lt;/span>&lt;span style="color:#a6e22e">forever&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div></description></item><item><title>Docs: I/O模型</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/8.%E9%80%9A%E7%94%A8%E6%8A%80%E6%9C%AF/i_o%E6%A8%A1%E5%9E%8B/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/8.%E9%80%9A%E7%94%A8%E6%8A%80%E6%9C%AF/i_o%E6%A8%A1%E5%9E%8B/</guid><description>
&lt;ol>
&lt;li>同步/异步：关注的是消息通信机制，被调用者在收到调用请求后，是否立即返回，还是得到最终结果后才返回,立即返回为异步，等待结果再返回为同步，异步不会影响调用者处理后续
&lt;ol>
&lt;li>同步和异步通常用来形容一次方法调用。&lt;/li>
&lt;/ol>
&lt;/li>
&lt;/ol>
&lt;ul>
&lt;li>同步方法调用一旦开始，调用者必须等到方法调用返回后，才能继续后续的行为。&lt;/li>
&lt;li>异步方法调用更像一个消息传递，一旦开始，方法调用就会立即返回，调用者就可以继续后续的操作。而，异步方法通常会在另外一个线程中，“真实”地执行着。整个过程，不会阻碍调用者的工作。
&lt;ul>
&lt;li>举个例子
&lt;ul>
&lt;li>你打电话问书店老板有没有《分布式系统》这本书，如果是同步通信机制，书店老板会说，你稍等，”我查一下&amp;quot;，然后开始查啊查，等查好了（可能是5秒，也可能是一天）告诉你结果（返回结果）。&lt;/li>
&lt;li>而异步通信机制，书店老板直接告诉你我查一下啊，查好了打电话给你，然后直接挂电话了（不返回结果）。然后查好了，他会主动打电话给你。在这里老板通过“回电”这种方式来回调。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>阻塞/非阻塞：关注的是程序在等待调用结果（消息，返回值）时的状态.，调用者发起调用请求后，在收到响应结果之前是否会被挂起，被挂起为阻塞，不被挂起为非阻塞
&lt;ul>
&lt;li>举个例子&lt;/li>
&lt;li>同步阻塞：
&lt;ul>
&lt;li>老张在厨房用普通水壶烧水，一直在厨房等着（阻塞），盯到水烧开（同步）；&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>异步阻塞：
&lt;ul>
&lt;li>老张在厨房用响水壶烧水，一直在厨房中等着（阻塞），直到水壶发出响声（异步），老张知道水烧开了；&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>同步非阻塞：
&lt;ul>
&lt;li>老张在厨房用普通水壶烧水，在烧水过程中，就到客厅去看电视（非阻塞），然后时不时去厨房看看水烧开了没（轮询检查同步结果）；&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>异步非阻塞：
&lt;ul>
&lt;li>老张在厨房用响水壶烧水，在烧水过程中，就到客厅去看电视（非阻塞），当水壶发出响声（异步），老张就知道 水烧开了。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>所谓同步异步，只是对于水壶而言。
&lt;ul>
&lt;li>普通水壶，同步；响水壶，异步。&lt;/li>
&lt;li>虽然都能干活，但响水壶可以在自己完工之后，提示老张水开了。这是普通水壶所不能及的。&lt;/li>
&lt;li>同步只能让调用者去轮询自己（情况2中），造成老张效率的低下。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>所谓阻塞非阻塞，仅仅对于老张而言。
&lt;ul>
&lt;li>立等的老张，阻塞；看电视的老张，非阻塞。&lt;/li>
&lt;li>情况1和情况3中老张就是阻塞的，媳妇喊他都不知道。虽然3中响水壶是异步的，可对于立等的老张没有太大的意义。所以一般异步是配合非阻塞使用的，这样才能发挥异步的效用。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul></description></item><item><title>Docs: Kafka原理详解</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/8.%E9%80%9A%E7%94%A8%E6%8A%80%E6%9C%AF/message-queue%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/kafka%E5%8E%9F%E7%90%86%E8%AF%A6%E8%A7%A3/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/8.%E9%80%9A%E7%94%A8%E6%8A%80%E6%9C%AF/message-queue%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/kafka%E5%8E%9F%E7%90%86%E8%AF%A6%E8%A7%A3/</guid><description>
&lt;p>Kafka 原理详解&lt;/p>
&lt;p>原创 马哥企业教练团队 马哥 Linux 运维 3 天前&lt;/p>
&lt;p>Kafka 是什么？&lt;/p>
&lt;p>Kafka 是 Apache 旗下的一款分布式流媒体平台，Kafka 是一种高吞吐量、持久性、分布式的发布订阅的消息队列系统。它最初由 LinkedIn(领英)公司发布，使用 Scala 语言编写，与 2010 年 12 月份开源，成为 Apache 的顶级子项目。它主要用于处理消费者规模网站中的所有动作流数据。动作指(网页浏览、搜索和其它用户行动所产生的数据)。&lt;/p>
&lt;p>消息系统分类&lt;/p>
&lt;p>我们知道常见的消息系统有 Kafka、RabbitMQ、ActiveMQ 等等，但是这些消息系统中所使用的消息模式如下两种：&lt;/p>
&lt;p>Peer-to-Peer (Queue)&lt;/p>
&lt;p>简称 PTP 队列模式，也可以理解为点到点。例如单发邮件，我发送一封邮件给小徐，我发送过之后邮件会保存在服务器的云端，当小徐打开邮件客户端并且成功连接云端服务器后，可以自动接收邮件或者手动接收邮件到本地，当服务器云端的邮件被小徐消费过之后，云端就不再存储(这根据邮件服务器的配置方式而定)。&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/takfzz/1616130276202-0f04f19a-eec4-44db-a3a5-4880460e16bd.jpeg" alt="">&lt;/p>
&lt;p>名词解释：&lt;/p>
&lt;p>Producer=生产者&lt;/p>
&lt;p>Queue=队列&lt;/p>
&lt;p>Consumer=消费者&lt;/p>
&lt;p>Peer-to-Peer 模式工作原理：&lt;/p>
&lt;p>1.消息生产者 Producer1 生产消息到 Queue，然后 Consumer1 从 Queue 中取出并且消费消息。2.消息被消费后，Queue 将不再存储消息，其它所有 Consumer 不可能消费到已经被其它 Consumer 消费过的消息。3.Queue 支持存在多个 Producer，但是对一条消息而言，只会有一个 Consumer 可以消费，其它 Consumer 则不能再次消费。4.但 Consumer 不存在时，消息则由 Queue 一直保存，直到有 Consumer 把它消费。&lt;/p>
&lt;p>Publish/Subscribe（Topic）&lt;/p>
&lt;p>简称发布/订阅模式。例如我微博有 30 万粉丝，我今天更新了一条微博，那么这 30 万粉丝都可以接收到我的微博更新，大家都可以消费我的消息。&lt;/p>
&lt;p>注：以下图示中的 Pushlisher 是错误的名词，正确的为 Publisher&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/takfzz/1616130276240-fca326b2-c114-47c9-92f9-a54b5e47dc99.jpeg" alt="">&lt;/p>
&lt;p>名词解释：&lt;/p>
&lt;p>Publisher=发布者&lt;/p>
&lt;p>Topic=主题&lt;/p>
&lt;p>Subscriber=订阅者&lt;/p>
&lt;p>Publish/Subscribe 模式工作原理：&lt;/p>
&lt;p>1.消息发布者 Publisher 将消息发布到主题 Topic 中，同时有多个消息消费者 Subscriber 消费该消息。2.和 PTP 方式不同，发布到 Topic 的消息会被所有订阅者消费。3.当发布者发布消息，不管是否有订阅者，都不会报错信息。4.一定要先有消息发布者，后有消息订阅者。&lt;/p>
&lt;p>注意：Kafka 所采用的就是发布/订阅模式，被称为一种高吞吐量、持久性、分布式的发布订阅的消息队列系统。&lt;/p>
&lt;p>常用消息系统对比&lt;/p>
&lt;p>•RabbitMQ Erlang 编写，支持多协议 AMQP，XMPP，SMTP，STOMP。支持负载均衡、数据持久化。同时 支持 Peer-to-Peer 和发布/订阅模式•Redis 基于 Key-Value 对的 NoSQL 数据库，同时支持 MQ 功能，可做轻量级队列服务使用。就入队操作而言， Redis 对短消息(小于 10KB)的性能比 RabbitMQ 好，长消息的性能比 RabbitMQ 差。•ZeroMQ 轻量级，不需要单独的消息服务器或中间件，应用程序本身扮演该角色，Peer-to-Peer。它实质上是 一个库，需要开发人员自己组合多种技术，使用复杂度高•ActiveMQ JMS 实现，Peer-to-Peer，支持持久化、XA 事务•Kafka/Jafka 高性能跨语言的分布式发布/订阅消息系统，数据持久化，全分布式，同时支持在线和离线处理•MetaQ/RocketMQ 纯 Java 实现，发布/订阅消息系统，支持本地事务和 XA 分布式事务&lt;/p>
&lt;p>Kafka 介绍&lt;/p>
&lt;p>Kafka 三大特点&lt;/p>
&lt;p>1.高吞吐量：可以满足每秒百万级别消息的生产和消费。&lt;/p>
&lt;p>2.持久性：有一套完善的消息存储机制，确保数据高效安全且持久化。&lt;/p>
&lt;p>3.分布式：基于分布式的扩展；Kafka 的数据都会复制到几台服务器上，当某台故障失效时，生产者和消费者转而使用其它的 Kafka。&lt;/p>
&lt;p>Kafka 的几个概念&lt;/p>
&lt;p>1.Kafka 作为一个集群运行在一个或多个服务器上，这些服务器可以跨多个机房，所以说 kafka 是分布式的发布订阅消息队列系统。&lt;/p>
&lt;p>2.Kafka 集群将记录流存储在称为 Topic 的类别中。&lt;/p>
&lt;p>3.每条记录由键值；&amp;ldquo;key value&amp;quot;和一个时间戳组成。&lt;/p>
&lt;p>Kafka 的四个核心 API：&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/takfzz/1616130276252-1256f05d-0cf7-402b-867c-3ba5568c86b3.jpeg" alt="">&lt;/p>
&lt;p>1.Producer API：生产者 API 允许应用程序将一组记录发布到一个或多个 Kafka Topic 中。2.Consumer API：消费者 API 允许应用程序订阅一个或多个 Topic，并处理向他们传输的记录流。3.Streams API：流 API 允许应用程序充当流处理器，从一个或者多个 Topic 中消费输入流，并将输出流生成为一个或多个输出主题，从而将输入流有效地转换为输出流。4.Connector API：连接器 API 允许构建和运行可重用的生产者或消费者，这些生产者或消费者将 Kafka Topic 连接到现有的应用程序或数据系统。例如：连接到关系数据库的连接器可能会捕获对表的每次更改。&lt;/p>
&lt;p>在 Kafka 中，客户端和服务器之间的通信采用 TCP 协议完成，该协议经过版本控制，新版本与旧版本保存向后兼容性，我们为 Kafka 提供了一个 Java 客户端，但是客户端可以使用多种语言。&lt;/p>
&lt;p>Kafka 架构简介&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/takfzz/1616130276237-feaedd53-58e7-4d88-9693-a6c869df6110.jpeg" alt="">&lt;/p>
&lt;p>上图中画了一下 Kafka 的架构，较为凌乱，相同颜色的线条表示一种功能，但是希望大家能够仔细看下&lt;/p>
&lt;p>•Producer：消息和数据的生产者，主要负责生产 Push 消息到指定 Broker 的 Topic 中。•Broker：Kafka 节点就是被称为 Broker，Broker 主要负责创建 Topic，存储 Producer 所发布的消息，记录消息处理的过程，现是将消息保存到内存中，然后持久化到磁盘。•Topic：同一个 Topic 的消息可以分布在一个或多个 Broker 上，一个 Topic 包含一个或者多个 Partition 分区，数据被存储在多个 Partition 中。•replication-factor：复制因子；这个名词在上图中从未出现，在我们下一章节创建 Topic 时会指定该选项，意思为创建当前的 Topic 是否需要副本，如果在创建 Topic 时将此值设置为 1 的话，代表整个 Topic 在 Kafka 中只有一份，该复制因子数量建议与 Broker 节点数量一致。•Partition：分区；在这里被称为 Topic 物理上的分组，一个 Topic 在 Broker 中被分为 1 个或者多个 Partition，也可以说为每个 Topic 包含一个或多个 Partition，(一般为 kafka 节. 点数 CPU 的总核心数量)分区在创建 Topic 的时候可以指定。分区才是真正存储数据的单元。•Consumer：消息和数据的消费者，主要负责主动到已订阅的 Topic 中拉取消息并消费，为什么 Consumer 不能像 Producer 一样的由 Broker 去 push 数据呢？因为 Broker 不知道 Consumer 能够消费多少，如果 push 消息数据量过多，会造成消息阻塞，而由 Consumer 去主动 pull 数据的话，Consumer 可以根据自己的处理情况去 pull 消息数据，消费完多少消息再次去取。这样就不会造成 Consumer 本身已经拿到的数据成为阻塞状态。•ZooKeeper：ZooKeeper 负责维护整个 Kafka 集群的状态，存储 Kafka 各个节点的信息及状态，实现 Kafka 集群的高可用，协调 Kafka 的工作内容。&lt;/p>
&lt;p>我们可以看到上图，Broker 和 Consumer 有使用到 ZooKeeper，而 Producer 并没有使用到 ZooKeeper，因为 Kafka 从 0.8 版本开始，Producer 并不需要根据 ZooKeeper 来获取集群状态，而是在配置中指定多个 Broker 节点进行发送消息，同时跟指定的 Broker 建立连接，来从该 Broker 中获取集群的状态信息，这是 Producer 可以知道集群中有多少个 Broker 是否在存活状态，每个 Broker 上的 Topic 有多少个 Partition，Prodocuer 会讲这些元信息存储到 Producuer 的内存中。如果 Producoer 像集群中的一台 Broker 节点发送信息超时等故障，Producer 会主动刷新该内存中的元信息，以获取当前 Broker 集群中的最新状态，转而把信息发送给当前可用的 Broker，当然 Prodocuer 也可以在配置中指定周期性的去刷新 Broker 的元信息以更新到内存中。&lt;/p>
&lt;p>注意：只有 Broker 和 ZooKeeper 才是服务，而 Producer 和 Consumer 只是 Kafka 的 SDK 罢了&lt;/p>
&lt;p>主题和日志&lt;/p>
&lt;p>主题和日志官方被称为是 Topic and log。Topic 是记录发布到的类别或者订阅源的名称，Kafka 的 Topic 总是多用户的；也就是说，一个 Topic 可以有零个、一个或者多个消费者订阅写入它的数据。每个 Topic Kafka 集群都为一个 Partition 分区日志，如下图所示：&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/takfzz/1616130276222-33e53691-f9e4-4eff-8871-5d6a56e51622.jpeg" alt="">&lt;/p>
&lt;p>每个 Partition 分区都是一个有序的记录序列(不可变),如果有新的日志会按顺序结构化添加到末尾，分区中的记录每个都按顺序的分配一个 ID 号，称之为偏移量，在整个 Partition 中具有唯一性。如上图所示，有 Partition、Partition1、Partition2，其中日志写入的顺序从 Old 到 New，ID 号从 0-12 等。&lt;/p>
&lt;p>Kafka 集群发布过的消息记录会被持久化到硬盘中，无论该消息是否被消费，发布记录都会被 Kafka 保留到硬盘当中，我们可以设置保留期限。例如，如果保留策略我们设置为两天，则在发布记录的两天内，该消息可供使用，之后则被 Kafka 丢弃以释放空间，Kafka 的性能在数据大小方面是非常出色的，可以长时间保留数据不成问题。&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/takfzz/1616130276252-41c286e2-c058-45e1-8dbb-bd53b942b190.jpeg" alt="">&lt;/p>
&lt;p>实际上，以消费者为单位地保留的唯一元数据是消费者在日志中的偏移或位置。这个偏移量由消费者控制的：消费者通常会在读取记录时线性地推进偏移量，但事实上，由于消费者的位置时由消费者控制的，所以它可以按照自己喜欢的任何顺序进行消费记录。例如，消费者可以重置之前的偏移量来处理之前的数据，或者直接从最新的偏移量开始消费。这些功能的组合意味着 Kafka 消费者非常的不值一提，他们可以很随便，即使这样，对集群或者其他消费者没有太大影响。例如：可以使用命令工具来“tail”任何 Topic 的内容，而不会更改任何现有使用者所使用的内容。&lt;/p>
&lt;p>日志中分区有几个用途。首先，他们允许日志的大小超出适合单台服务器的大小，每个单独的分区必须适合托管它的服务器，但是一个主题可能有许多分区，因此它可以处理任意数量的数据，其次，他们作为并行的单位-更多的是在一点上。&lt;/p>
&lt;p>Distribution(分布)&lt;/p>
&lt;p>日志 Partition 分区分布在 Kafka 集群中的服务器上，每台服务器都处理数据并请求共享分区。为了实现容错，每个 Partition 分区被复制到多个可配置的 Kafka 集群中的服务器上。&lt;/p>
&lt;p>名词介绍：&lt;/p>
&lt;p>leader：领导者&lt;/p>
&lt;p>followers：追随者&lt;/p>
&lt;p>每个 Partition 分区都有一个 leader(领导者)服务器，是每个 Partition 分区，假如我们的 Partition1 分区分别被复制到了三台服务器上，其中第二台为这个 Partition 分区的领导者，其它两台服务器都会成为这个 Partition 的 followers(追随者)。其中 Partition 分片的 leader(领导者)处理该 Partition 分区的所有读和写请求，而 follower(追随者)被动地复制 leader(领导者)所发生的改变，如果该 Partition 分片的领导者发生了故障等，两个 follower(追随者)中的其中一台服务器将自动成为新的 leader 领导者。每台服务器都充当一些分区的 leader(领导者)和一些分区的 follower(追随者)，因此集群内的负载非常平衡。&lt;/p>
&lt;p>注意：上面讲的 leader 和 follower 仅仅是每个 Partition 分区的领导者和追随者，并不是我们之前学习到的整个集群的主节点和备节点，希望大家不要混淆。&lt;/p>
&lt;p>Geo-Replication(地域复制)&lt;/p>
&lt;p>Kafka Mirrormaker 为集群提供地域复制支持，使用 MirrorMaker，可以跨多个机房或云端来复制数据，可以在主动/被动方案中使用它进行备份和恢复；在主动方案中，可以使数据更接近用户，或支持数据位置要求。&lt;/p>
&lt;p>Producers(生产者)&lt;/p>
&lt;p>生产者将数据发布到他们选择的 Topic，生产者负责选择分配给 Topic 中的哪个分区的记录。这可以通过循环方式来完成，只是为了负载均衡，或者可以根据一些语义分区函数(比如基于记录中的某个键)来完成。&lt;/p>
&lt;p>Consumers(消费者)&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/takfzz/1616130276249-40cdfc85-7b14-4783-9add-ea99966847a1.jpeg" alt="">&lt;/p>
&lt;p>名词介绍&lt;/p>
&lt;p>Consumers：消费者&lt;/p>
&lt;p>Consumers Group：消费者组&lt;/p>
&lt;p>Consumers Group name：消费者组名&lt;/p>
&lt;p>Consumers 使用 Consumers Group name 标记自己，并且发布到 Topic 的每个记录被传递到每个订阅 Consumers Group 中的一个 Consumers 实例，Consumers 实例可以在单独的进程中，也可以在不同的机器，如果所有 Consumers 实例具有相同的 Consumers Group，则记录将有效地在 Consumers 上进行负载均衡。&lt;/p>
&lt;p>如果所有 Consumers 实例在不同的 Consumers Group 中，则每个记录将广播到所有 Consumers 进程中。&lt;/p>
&lt;p>两个 Kafka Cluster，托管了四个 Partition(分区)，从 P0-P3，包含两个 Consumers Group 分别是 Consumer Group A 和 Consumer Group B，Consumners Group A 有两个 Consumers 实例，B 有四个 Consumers 实例。也就是消费者 A 组有两个消费者，B 组有四个消费者。然后，更常见的是，我们发现 Topic 有少量的 Consumers Group，每个消费者对应一个用户组，每个组有许多消费者实例组成，用于可伸缩和容错，这只不过是发布/订阅语义，其中订阅者是一组消费者，而不是单个进程。&lt;/p>
&lt;p>在 Kfaka 中实现消费者的方式是通过在消费者实例上划分日志中的 Partition 分区，以便每个实例在任何时间点都是分配的“相同份额”，维护消费者组成功资格的过程由 Kafka 动态协议实现，如果新的消费者实例加入该消费者组，新消费者实例将从该组的其它成员手里接管一些分区；如果消费者实例故障，其分区将分发给其余消费者实例。&lt;/p>
&lt;p>Kafka 仅提供分区内记录的总顺序，而不是 Topic 中不同分区之间的记录。对于大多数应用程序而言，按分区排序和按键分许数据的能力已经足够，但是如果你需要记录总顺序，则可以使用只有一个分区的 Topic 来实现，尽管这意味着每个消费者组只有一个消费者进程。&lt;/p>
&lt;p>Consumer Group&lt;/p>
&lt;p>我们开始处有讲到消息系统分类：P-T-P 模式和发布/订阅模式，也有说到我们的 Kafka 采用的就是发布订阅模式，即一个消息产生者产生消息到 Topic 中，所有的消费者都可以消费到该条消息，采用异步模型；而 P-T-P 则是一个消息生产者生产的消息发不到 Queue 中，只能被一个消息消费者所消费，采用同步模型 其实发布订阅模式也可以实现 P-T-P 的模式，即将多个消费者加入一个消费者组中，例如有三个消费者组，每个组中有 3 个消息消费者实例，也就是共有 9 个消费者实例，如果当 Topic 中有消息要接收的时候，三个消费者组都会去接收消息，但是每个人都接收一条消息，然后消费者组再将这条消息发送给本组内的一个消费者实例，而不是所有消费者实例，到最后也就是只有三个消费者实例得到了这条消息，当然我们也可以将这些消费者只加入一个消费者组，这样就只有一个消费者能够获得到消息了。&lt;/p>
&lt;p>Guarantees(担保)&lt;/p>
&lt;p>在高级别的 Kafka 中提供了以下保证：&lt;/p>
&lt;p>•生产者发送到特定 Topic 分区的消息将按照其发送顺序附加。也就是说，如果一个 Producers 生产者发送了 M1 和 M2，一般根据顺序来讲，肯定是先发送的 M1，随后发送的 M2，如果是这样，假如 M1 的编号为 1，M2 的编号为 2，那么在日志中就会现有 M1，随后有 M2。•消费者实例按照他们存储在日志中的顺序查看记录。•对于具有复制因子 N 的 Topic，Kafka 最多容忍 N-1 个服务器故障，则不会丢失任何提交到日志的记录。&lt;/p></description></item><item><title>Docs: Message Queue(消息队列)</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/8.%E9%80%9A%E7%94%A8%E6%8A%80%E6%9C%AF/message-queue%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/8.%E9%80%9A%E7%94%A8%E6%8A%80%E6%9C%AF/message-queue%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/</guid><description>
&lt;p>场景一：日志采集系统，拿 Loki 举例，采集器(promtail)采集数据后，存储到后端日志存储器(Loki)上，当需要采集多个节点，并且当日志大量产生时， Loki 的处理很有可能会出现瓶颈而无法处理写入请求，这时候，我们就想要在 采集器 和 存储中间添加一个缓冲，来减慢后端存储的压力&lt;/p>
&lt;p>而这就是 消息队列 的作用之一，采集器作为 MQ 的生产者，将日志数据传入队列，日志存储器作为 MQ 的消费者，从队列中逐步拿取日志数据并存储。有了这么一个缓冲，Loki 的压力将会得到很大缓和。&lt;/p>
&lt;p>这时候可能还会有这种想法：我直接限制 采集器 的处理逻辑不好么，为什么还要中间再加一层东西，增加故障点。这是为了解耦，采集器的处理逻辑就是采集日志并上传，不要过多关注此行为之外的东西，这样一个产品才能快速迭代，更好的处理逻辑。&lt;/p>
&lt;p>这种行为简称：消减波峰，保护后端(消费端)&lt;/p>
&lt;p>场景二：现代的互联网应用大量地使用了消息队列（Messaging）。消息队列不仅被用于系统内部组件之间的通信，同时也被用于系统跟其它服务之间的交互。消息队列的使用可以增加系统的可扩展性、灵活性和用户体验。非基于消息队列的系统，其运行速度取决于系统中最慢的组件的速度（注：短板效应）。而基于消息队列可以将系统中各组件解除耦合，这样系统就不再受最慢组件的束缚，各组件可以异步运行从而得以更快的速度完成各自的工作。&lt;/p>
&lt;p>总结：消息队列能够将业务逻辑解耦，调用方只需要下达命令而不用等待整个逻辑执行完毕。除此之外消息队列也可以抑制性能波峰的产生，在瞬时业务增长产生时保持性能曲线的平滑。&lt;/p></description></item><item><title>Docs: NSQ 消息队列</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/8.%E9%80%9A%E7%94%A8%E6%8A%80%E6%9C%AF/message-queue%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/nsq-%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/8.%E9%80%9A%E7%94%A8%E6%8A%80%E6%9C%AF/message-queue%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/nsq-%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://github.com/nsqio/nsq">GitHub 项目，nsqio/nsq&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://nsq.io/">官网&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote></description></item><item><title>Docs: RabbitMQ</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/8.%E9%80%9A%E7%94%A8%E6%8A%80%E6%9C%AF/message-queue%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/rabbitmq/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/8.%E9%80%9A%E7%94%A8%E6%8A%80%E6%9C%AF/message-queue%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/rabbitmq/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>官方网址：&lt;a href="https://www.rabbitmq.com/">https://www.rabbitmq.com/&lt;/a>&lt;/li>
&lt;li>消息队列模拟器：&lt;a href="http://tryrabbitmq.com/">http://tryrabbitmq.com/&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.yuque.com/noobwo/mq/hpiop0">https://www.yuque.com/noobwo/mq/hpiop0&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://m.6-km.com/next/quorum-queues.html">https://m.6-km.com/next/quorum-queues.html&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://zhuanlan.zhihu.com/p/63700605">https://zhuanlan.zhihu.com/p/63700605&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>Rabbit Message Queue(Rabbit 消息队列，简称：RabbitMQ)。是一个在 AMQP 基础上实现的，可复用的消息队列服务。&lt;/p>
&lt;p>Advanced Message Queuing Protocol(高级消息队列协议，简称 AMQP) ，是一个提供统消息服务的应用层(7 层)协议。其设计目标是对于消息的排序、路由（包括点对点和订阅-发布）、保持可靠性、保证安全性[1]。AMQP 规范了消息传递方和接收方的行为，以使消息在不同的提供商之间实现互操作性，就像 SMTP，HTTP，FTP 等协议可以创建交互系统一样。与先前的中间件标准（如 Java 消息服务）不同的是，JMS 在特定的 API 接口层面和实现行为上进行了统一，而高级消息队列协议则关注于各种消息如何以字节流的形式进行传递。因此，使用了符合协议实现的任意应用程序之间可以保持对消息的创建、传递。&lt;/p>
&lt;h2 id="工作机制概述">工作机制概述&lt;/h2>
&lt;p>在了解消息通讯之前首先要了解 3 个概念：生产者、消费者和代理。&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/vi79ye/1616130695655-d434cc0d-b15a-48c2-9fad-7fa971d2ffa4.jpeg" alt="">&lt;/p>
&lt;p>Publisher(生产者)：消息的创建者，负责创建和推送数据到消息服务器；&lt;/p>
&lt;p>Consumer(消费者)：消息的接收方，用于处理数据和确认消息；&lt;/p>
&lt;p>Broker(代理)：就是 RabbitMQ 本身，用于扮演“快递”的角色，本身不生产消息，只是扮演“快递”的角色。&lt;/p>
&lt;p>消息发送原理&lt;/p>
&lt;p>首先你必须连接到 Rabbit 才能发布和消费消息，那怎么连接和发送消息的呢？&lt;/p>
&lt;p>你的应用程序和 Rabbit Server 之间会创建一个 TCP 连接，一旦 TCP 打开，并通过了认证，认证就是你试图连接 Rabbit 之前发送的 Rabbit 服务器连接信息和用户名和密码，有点像程序连接数据库，使用 Java 有两种连接认证的方式，后面代码会详细介绍，一旦认证通过你的应用程序和 Rabbit 就创建了一条 AMQP 信道（Channel）。&lt;/p>
&lt;p>信道是创建在“真实”TCP 上的虚拟连接，AMQP 命令都是通过信道发送出去的，每个信道都会有一个唯一的 ID，不论是发布消息，订阅队列或者介绍消息都是通过信道完成的。&lt;/p>
&lt;p>为什么不通过 TCP 直接发送命令？&lt;/p>
&lt;p>对于操作系统来说创建和销毁 TCP 会话是非常昂贵的开销，假设高峰期每秒有成千上万条连接，每个连接都要创建一条 TCP 会话，这就造成了 TCP 连接的巨大浪费，而且操作系统每秒能创建的 TCP 也是有限的，因此很快就会遇到系统瓶颈。&lt;/p>
&lt;p>如果我们每个请求都使用一条 TCP 连接，既满足了性能的需要，又能确保每个连接的私密性，这就是引入信道概念的原因。&lt;/p>
&lt;p>其实在生活中，这种模型用得非常多，就比如我们都会接触的网购快递，可以说是一个典型的消息队列的 case 了：&lt;/p>
&lt;p>商家不断的把商品扔给快递公司（注意不是直接将商品给买家），而快递公司则将商品根据地质分发对应的买家&lt;/p>
&lt;p>对上面这个过程进行拆解，可以映射扮演的角色&lt;/p>
&lt;ul>
&lt;li>商品：Message，传递的消息，由商家投递给快递公司时，需要进行打包（一般 Producer 生产消息也会将实体数据进行封装）&lt;/li>
&lt;li>商家：Produer 生产者&lt;/li>
&lt;li>快递公司： Queue，消息的载体&lt;/li>
&lt;li>买家：Consumer 消费者&lt;/li>
&lt;/ul>
&lt;p>那么快递公司时怎么知道要把商品给对应的买家呢？根据包裹上的地址+电话&lt;/p>
&lt;ul>
&lt;li>同样消息队列也需要一个映射规则，实现 Message 和 Consumer 之间的路由&lt;/li>
&lt;/ul>
&lt;h1 id="rabbitmq-基本概念">RabbitMQ 基本概念&lt;/h1>
&lt;ol>
&lt;li>Exchange&lt;/li>
&lt;li>Queue&lt;/li>
&lt;li>Routing key # 一种规则，用于 Exchange 路由消息到匹配到规则的 Queue 上&lt;/li>
&lt;li>Binding # 交换器 与 队列(或另一个交换器) 的关联行为&lt;/li>
&lt;/ol>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/vi79ye/1616130695576-789c9f61-914e-4f88-951c-b1a0915fdc4a.jpeg" alt="">&lt;/p>
&lt;h2 id="broker--指安装了-rabbitmq-的服务器">Broker # 指安装了 RabbitMQ 的服务器&lt;/h2>
&lt;h2 id="virtual-host虚拟主机--类似-rabbitmq-虚拟化的感觉">Virtual Host(虚拟主机) # 类似 RabbitMQ 虚拟化的感觉&lt;/h2>
&lt;p>每个 Rabbit 都能创建很多 vhost 我们称之为虚拟主机，每个虚拟主机其实都是 mini 版的 RabbitMQ，拥有自己的队列，交换器和绑定，拥有自己的权限机制。&lt;/p>
&lt;ol>
&lt;li>RabbitMQ 默认的 vhost 是 / 开箱即用；&lt;/li>
&lt;li>多个 vhost 是隔离的，多个 vhost 无法通讯，并且不用担心命名冲突（队列和交换器和绑定），实现了多层分离；&lt;/li>
&lt;li>创建用户的时候必须指定 vhost；&lt;/li>
&lt;/ol>
&lt;p>注意，从上层角度看，RabbitMQ 实现主要依靠 Exchange 与 Queue 来实现。&lt;/p>
&lt;h2 id="queue队列--用于存储消息">Queue(队列) # 用于存储消息&lt;/h2>
&lt;p>官方文档：&lt;a href="https://www.rabbitmq.com/queues.html">https://www.rabbitmq.com/queues.html&lt;/a>&lt;/p>
&lt;h2 id="exchange交换器--用于接受分配消息">Exchange(交换器) # 用于接受、分配消息&lt;/h2>
&lt;p>官方文档：未知&lt;/p>
&lt;p>客户端向 RebbitMQ 发送消息，并不会直接发送到 Queue 中，而是从 5674 端口到达 Exchange，然后根据路由规则，决定收到消息应该投递到哪个队列上，这些规则其中一部分称为 &lt;strong>Routing key(路由键)&lt;/strong>，另外一部分规则是根据 Exchange 的类型来决定。&lt;/p>
&lt;p>Queue 可以通过 Routing key 关联到 Exchange 上(也可以省略 Routing key 直接绑定)，这种关联行为称为 &lt;strong>Binding(绑定)&lt;/strong>。&lt;/p>
&lt;p>注意：&lt;/p>
&lt;ol>
&lt;li>绑定时所使用的 Routing key 可以使用通配符。&lt;/li>
&lt;li>为了与每个消息中的 Routing key 区分，我们一般称绑定时使用的 Routing key 为 &lt;strong>Binding key(绑定键)&lt;/strong>。&lt;/li>
&lt;/ol>
&lt;p>绑定完成后，当 Exchange 收到消息(&lt;strong>每个消息也可以指定 Routing key&lt;/strong>)后，凡是 Routing key 匹配 Binding key 条件的，则该消息会被发送到具有 Binding key 的队列中。如果匹配多分，则消息在 Exchange 中会复制多份。&lt;/p>
&lt;p>例如：现在发送一条消息，Routing key 为 test.1，两个队列绑定到交换器时，Binding key 分别为 &lt;em>.1 和 test.&lt;/em>，则该消息到达 Exchange 时，会复制为两份，分别发送到这两各队列中。&lt;/p>
&lt;p>&lt;strong>Exchange 的 4 种类型&lt;/strong>&lt;/p>
&lt;ol>
&lt;li>direct # Routing key 与 Binding key 必须完全匹配，不接受通配符匹配。&lt;/li>
&lt;li>fanot # 不需要 routing key，收到消息后，自动将消息复制多份并发送给与自己绑定的队列上。&lt;/li>
&lt;li>headers&lt;/li>
&lt;li>topic # Routing key 与 Binding key 可以根据通配符匹配。匹配规则如下：
&lt;ol>
&lt;li>
&lt;ul>
&lt;li>匹配一个单词&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;h1 id="匹配-0-个或多个字符">匹配 0 个或多个字符&lt;/h1>
&lt;/li>
&lt;li>*，# 只能写在.号左右，且不能挨着字符&lt;/li>
&lt;li>单词和单词之间需要用.隔开。&lt;/li>
&lt;/ol>
&lt;/li>
&lt;li>特殊的 Exchange
&lt;ol>
&lt;li>如果不手动绑定 Exchange 与 Queue，发送消息时不指定 Exchange，但是消息依然可以路由到队列中。&lt;/li>
&lt;li>这是因为每个 vhost 下都有一个 default Exchange。默认的 Exchange 不可以手动绑定，没有名字，不可以删除，direct 类型。每个 Queue 都会与当前 vhost 下的 默认 Exchange 隐式绑定在一起，且 Binding key 为 Queue 名称。&lt;/li>
&lt;li>消息中的 Routing key 必须指定为 Queue 名称，这时消息通过默认的 Exchange 被路由到对应的 Queue 上。这保证了消息准确投递。&lt;/li>
&lt;/ol>
&lt;/li>
&lt;/ol>
&lt;h2 id="connection连接--应用程序与-rabbit-之间建立的连接程序代码中使用">Connection(连接) # 应用程序与 Rabbit 之间建立的连接，程序代码中使用&lt;/h2>
&lt;h2 id="channel信道--消息推送使用的通道">Channel(信道) # 消息推送使用的通道&lt;/h2>
&lt;h1 id="rabbitmq-配置">RabbitMQ 配置&lt;/h1></description></item><item><title>Docs: RabbitMQ Operator</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/8.%E9%80%9A%E7%94%A8%E6%8A%80%E6%9C%AF/message-queue%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/rabbitmq/rabbitmq-operator/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/8.%E9%80%9A%E7%94%A8%E6%8A%80%E6%9C%AF/message-queue%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/rabbitmq/rabbitmq-operator/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>官方文档&lt;/li>
&lt;li>&lt;a href="https://www.rabbitmq.com/kubernetes/operator/operator-overview.html">https://www.rabbitmq.com/kubernetes/operator/operator-overview.html&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.rabbitmq.com/kubernetes/operator/using-operator.html#override">https://www.rabbitmq.com/kubernetes/operator/using-operator.html#override&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;h1 id="通过-operator-部署一套生产可用的-rabbitmq-集群">通过 Operator 部署一套生产可用的 RabbitMQ 集群&lt;/h1>
&lt;h3 id="创建-namespace">创建 namespace&lt;/h3>
&lt;pre>&lt;code>kubectl create ns rabbitmq
&lt;/code>&lt;/pre>
&lt;h3 id="部署-operator">部署 operator&lt;/h3>
&lt;pre>&lt;code>kubectl apply -f &amp;quot;https://github.com/rabbitmq/cluster-operator/releases/latest/download/cluster-operator.yml&amp;quot;
&lt;/code>&lt;/pre>
&lt;h3 id="创建-pv">创建 PV&lt;/h3>
&lt;pre>&lt;code>cat &amp;gt; rabbitmq-pv.yaml &amp;lt;&amp;lt; EOF
apiVersion: v1
kind: PersistentVolume
metadata:
name: rabbitmq-node-1
spec:
accessModes:
- ReadWriteOnce
capacity:
storage: 10Gi
local:
path: /opt/rabbitmq
nodeAffinity:
required:
nodeSelectorTerms:
- matchExpressions:
- key: kubernetes.io/hostname
operator: In
values:
- node-1.tj-test
---
apiVersion: v1
kind: PersistentVolume
metadata:
name: rabbitmq-node-2
spec:
accessModes:
- ReadWriteOnce
capacity:
storage: 10Gi
local:
path: /opt/rabbitmq
nodeAffinity:
required:
nodeSelectorTerms:
- matchExpressions:
- key: kubernetes.io/hostname
operator: In
values:
- node-2.tj-test
---
apiVersion: v1
kind: PersistentVolume
metadata:
name: rabbitmq-node-3
spec:
accessModes:
- ReadWriteOnce
capacity:
storage: 10Gi
local:
path: /opt/rabbitmq
nodeAffinity:
required:
nodeSelectorTerms:
- matchExpressions:
- key: kubernetes.io/hostname
operator: In
values:
- node-3.tj-test
EOF
kubectl apply -f rabbitmq-pv.yaml
&lt;/code>&lt;/pre>
&lt;h3 id="部署-rabbitmq-集群">部署 RabbitMQ 集群&lt;/h3>
&lt;p>若使用默认 image ，则镜像中无 python 环境，也无 rabbitmqadmin 工具。&lt;/p>
&lt;pre>&lt;code>cat &amp;gt; rabbitmq.yaml &amp;lt;&amp;lt;EOF
apiVersion: rabbitmq.com/v1beta1
kind: RabbitmqCluster
metadata:
name: tj-test
namespace: rabbitmq
spec:
rabbitmq:
additionalPlugins:
- rabbitmq_delayed_message_exchange
image: registry.cn-zhangjiakou.aliyuncs.com/ehl_common/rabbitmq:3.8.3-xdelay
replicas: 3
service:
type: NodePort
override:
# clientService 再新版crd中变成了 service
clientService:
spec:
ports:
- name: http
protocol: TCP
nodePort: 45672
port: 15672
- name: amqp
protocol: TCP
nodePort: 35672
port: 5672
EOF
kubectl apply -f rabbitmq.yaml
&lt;/code>&lt;/pre>
&lt;h3 id="创建用户并配置权限">创建用户并配置权限&lt;/h3>
&lt;pre>&lt;code>kubectl exec -it -n rabbitmq rabbitmq-tj-test-server-0 -- /bin/bash
rabbitmqctl add_user admin admin &amp;amp;&amp;amp; rabbitmqctl set_user_tags admin administrator &amp;amp;&amp;amp; rabbitmqctl add_vhost test &amp;amp;&amp;amp; rabbitmqctl set_permissions -p test admin '.*' '.*' '.*' &amp;amp;&amp;amp; rabbitmqctl set_permissions -p / admin '.*' '.*' '.*' &amp;amp;&amp;amp; exit
&lt;/code>&lt;/pre>
&lt;h3 id="测试是否可以创建队列">测试是否可以创建队列&lt;/h3>
&lt;pre>&lt;code>rabbitmqadmin --vhost=test declare queue name=test-1 queue_type=quorum
&lt;/code>&lt;/pre></description></item><item><title>Docs: RabbitMQ 部署</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/8.%E9%80%9A%E7%94%A8%E6%8A%80%E6%9C%AF/message-queue%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/rabbitmq/rabbitmq-%E9%83%A8%E7%BD%B2/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/8.%E9%80%9A%E7%94%A8%E6%8A%80%E6%9C%AF/message-queue%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/rabbitmq/rabbitmq-%E9%83%A8%E7%BD%B2/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://www.rabbitmq.com/download.html">官方文档，安装与配置&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;h2 id="使用-docker-启动单节点-rabbitmq">使用 docker 启动单节点 RabbitMQ&lt;/h2>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>docker run -d --hostname my-rabbit --name rabbit &lt;span style="color:#ae81ff">\
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">&lt;/span>-p 15672:15672 -p 5672:5672 &lt;span style="color:#ae81ff">\
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">&lt;/span>rabbitmq:3-management
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="在-kubernetes-集群中使用-operator-部署-rabbitmq">在 kubernetes 集群中使用 Operator 部署 RabbitMQ&lt;/h2>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://www.rabbitmq.com/kubernetes/operator/operator-overview.html">官方文档，安装和配置-Kubernetes Operator&lt;/a>
&lt;ul>
&lt;li>&lt;a href="https://www.rabbitmq.com/kubernetes/operator/install-operator.html">安装&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.rabbitmq.com/kubernetes/operator/using-operator.html">通过 Operator 使用 RabbitMQ 集群&lt;/a>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>注意：RabbitMQ Operator 会为每一个被其创建的 &lt;code>rabbitmqclusters.rabbitmq.com&lt;/code> 资源的对象添加 &lt;code>[finalizers](https://www.yuque.com/desistdaydream/learning/md69s3)&lt;/code> 字段，效果如下：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-yaml" data-lang="yaml">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">apiVersion&lt;/span>: &lt;span style="color:#ae81ff">rabbitmq.com/v1beta1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">kind&lt;/span>: &lt;span style="color:#ae81ff">RabbitmqCluster&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">metadata&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">finalizers&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#ae81ff">deletion.finalizers.rabbitmqclusters.rabbitmq.com&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>基于此，若删除 RabbitmqCluster 对象前删除了 RabbitMQ Operator，那么 RabbitmqCluster 将无法被删除，除非手动删除 &lt;code>finalizers&lt;/code> 字段。&lt;/p>
&lt;h3 id="部署-operator">部署 operator&lt;/h3>
&lt;blockquote>
&lt;p>这里会自动创建 rabbitmq-system 名称空间&lt;/p>
&lt;/blockquote>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>kubectl apply -f &lt;span style="color:#e6db74">&amp;#34;https://github.com/rabbitmq/cluster-operator/releases/latest/download/cluster-operator.yml&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="创建-pv">创建 pv&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-yaml" data-lang="yaml">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">cat &amp;gt; rabbitmq-pv.yaml &amp;lt;&amp;lt; EOF&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">apiVersion&lt;/span>: &lt;span style="color:#ae81ff">v1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">kind&lt;/span>: &lt;span style="color:#ae81ff">PersistentVolume&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">metadata&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">name&lt;/span>: &lt;span style="color:#ae81ff">rabbitmq-node-1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">spec&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">accessModes&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#ae81ff">ReadWriteOnce&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">capacity&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">storage&lt;/span>: &lt;span style="color:#ae81ff">10Gi&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">local&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">path&lt;/span>: &lt;span style="color:#ae81ff">/opt/rabbitmq&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">nodeAffinity&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">required&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">nodeSelectorTerms&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#f92672">matchExpressions&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#f92672">key&lt;/span>: &lt;span style="color:#ae81ff">kubernetes.io/hostname&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">operator&lt;/span>: &lt;span style="color:#ae81ff">In&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">values&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#ae81ff">node-1.tj-test&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">EOF&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">kubectl apply -f rabbitmq-pv.yaml&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="部署-rabbitmq">部署 rabbitmq&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-yaml" data-lang="yaml">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">cat &amp;gt; rabbitmq.yaml &amp;lt;&amp;lt; EOF&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">apiVersion&lt;/span>: &lt;span style="color:#ae81ff">rabbitmq.com/v1beta1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">kind&lt;/span>: &lt;span style="color:#ae81ff">RabbitmqCluster&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">metadata&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">name&lt;/span>: &lt;span style="color:#ae81ff">tj-test&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">namespace&lt;/span>: &lt;span style="color:#ae81ff">rabbitmq&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">EOF&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">kubectl apply -f rabbitmq.yaml&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="创建用户并配置权限">创建用户并配置权限&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>kubectl exec -it -n rabbitmq rabbitmq-bj-cs-server-0 -- /bin/bash
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>rabbitmqctl add_user admin admin &lt;span style="color:#f92672">&amp;amp;&amp;amp;&lt;/span> rabbitmqctl set_user_tags admin administrator &lt;span style="color:#f92672">&amp;amp;&amp;amp;&lt;/span> rabbitmqctl add_vhost test &lt;span style="color:#f92672">&amp;amp;&amp;amp;&lt;/span> rabbitmqctl set_permissions -p test admin &lt;span style="color:#e6db74">&amp;#39;.*&amp;#39;&lt;/span> &lt;span style="color:#e6db74">&amp;#39;.*&amp;#39;&lt;/span> &lt;span style="color:#e6db74">&amp;#39;.*&amp;#39;&lt;/span> &lt;span style="color:#f92672">&amp;amp;&amp;amp;&lt;/span> exit
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h1 id="rabbitmq-部署后验证">RabbitMQ 部署后验证&lt;/h1>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>rabbitmqadmin declare vhost name&lt;span style="color:#f92672">=&lt;/span>test
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>rabbitmqadmin declare queue name&lt;span style="color:#f92672">=&lt;/span>test queue_type&lt;span style="color:#f92672">=&lt;/span>quorum
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>rabbitmqadmin publish routing_key&lt;span style="color:#f92672">=&lt;/span>test payload&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;hello world&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>rabbitmqadmin get queue&lt;span style="color:#f92672">=&lt;/span>test
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>rabbitmqadmin get queue&lt;span style="color:#f92672">=&lt;/span>test ackmode&lt;span style="color:#f92672">=&lt;/span>ack_requeue_false
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>rabbitmqadmin declare exchange name&lt;span style="color:#f92672">=&lt;/span>test.topic type&lt;span style="color:#f92672">=&lt;/span>topic
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>rabbitmqadmin declare binding source&lt;span style="color:#f92672">=&lt;/span>test.topic destination&lt;span style="color:#f92672">=&lt;/span>test routing_key&lt;span style="color:#f92672">=&lt;/span>my.#
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>rabbitmqadmin publish routing_key&lt;span style="color:#f92672">=&lt;/span>my.test exchange&lt;span style="color:#f92672">=&lt;/span>my.topic payload&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;hello world by my.test&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>rabbitmqadmin publish routing_key&lt;span style="color:#f92672">=&lt;/span>my.test.test exchange&lt;span style="color:#f92672">=&lt;/span>my.topic payload&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;hello world by my.test.test&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>rabbitmqadmin get queue&lt;span style="color:#f92672">=&lt;/span>test count&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">2&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h1 id="rabbitmq-监控部署">RabbitMQ 监控部署&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://www.rabbitmq.com/kubernetes/operator/operator-monitoring.html#prom-operator">官方文档，安装与配置-Kubernetes Operator-在 Kubernetes 上监控 RabbitMQ 集群-使用 Prometheus Operator 监控 RabbitMQ&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.rabbitmq.com/kubernetes/operator/operator-monitoring.html#grafana">官方文档，安装与配置-Kubernetes Operator-在 Kubernetes 上监控 RabbitMQ 集群-导入 Grafana 面板&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>为 prometheus-operator 赋予更多权限&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-yaml" data-lang="yaml">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">export PrometheusOperatorSA=&amp;#34;bj-test-k8s-operator&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">cat &amp;gt; prometheus-cluster-role-and-binding.yaml &amp;lt;&amp;lt;EOF&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">apiVersion&lt;/span>: &lt;span style="color:#ae81ff">rbac.authorization.k8s.io/v1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">kind&lt;/span>: &lt;span style="color:#ae81ff">ClusterRole&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">metadata&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">name&lt;/span>: &lt;span style="color:#ae81ff">prometheus&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">rules&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>- &lt;span style="color:#f92672">apiGroups&lt;/span>: [&lt;span style="color:#e6db74">&amp;#34;&amp;#34;&lt;/span>]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">resources&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#ae81ff">nodes&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#ae81ff">services&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#ae81ff">endpoints&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#ae81ff">pods&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">verbs&lt;/span>: [&lt;span style="color:#e6db74">&amp;#34;get&amp;#34;&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;list&amp;#34;&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;watch&amp;#34;&lt;/span>]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>- &lt;span style="color:#f92672">apiGroups&lt;/span>: [&lt;span style="color:#e6db74">&amp;#34;&amp;#34;&lt;/span>]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">resources&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#ae81ff">configmaps&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">verbs&lt;/span>: [&lt;span style="color:#e6db74">&amp;#34;get&amp;#34;&lt;/span>]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>- &lt;span style="color:#f92672">nonResourceURLs&lt;/span>: [&lt;span style="color:#e6db74">&amp;#34;/metrics&amp;#34;&lt;/span>]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">verbs&lt;/span>: [&lt;span style="color:#e6db74">&amp;#34;get&amp;#34;&lt;/span>]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>---
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">apiVersion&lt;/span>: &lt;span style="color:#ae81ff">rbac.authorization.k8s.io/v1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">kind&lt;/span>: &lt;span style="color:#ae81ff">ClusterRoleBinding&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">metadata&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">name&lt;/span>: &lt;span style="color:#ae81ff">prometheus&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">roleRef&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">apiGroup&lt;/span>: &lt;span style="color:#ae81ff">rbac.authorization.k8s.io&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">kind&lt;/span>: &lt;span style="color:#ae81ff">ClusterRole&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">name&lt;/span>: &lt;span style="color:#ae81ff">prometheus&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">subjects&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>- &lt;span style="color:#f92672">kind&lt;/span>: &lt;span style="color:#ae81ff">ServiceAccount&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">name&lt;/span>: &lt;span style="color:#ae81ff">${PrometheusOperatorSA}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">namespace&lt;/span>: &lt;span style="color:#ae81ff">monitoring&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">EOF&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>添加 rabbitmq 的监控配置&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-yaml" data-lang="yaml">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">cat &amp;gt; rabbitmq-podmonitor.yaml &amp;lt;&amp;lt;EOF&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">apiVersion&lt;/span>: &lt;span style="color:#ae81ff">monitoring.coreos.com/v1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">kind&lt;/span>: &lt;span style="color:#ae81ff">PodMonitor&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">metadata&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">name&lt;/span>: &lt;span style="color:#ae81ff">rabbitmq&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">namespace&lt;/span>: &lt;span style="color:#ae81ff">monitoring&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">spec&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">podMetricsEndpoints&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#f92672">interval&lt;/span>: &lt;span style="color:#ae81ff">15s&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">port&lt;/span>: &lt;span style="color:#ae81ff">prometheus&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">selector&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">matchLabels&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">app.kubernetes.io/component&lt;/span>: &lt;span style="color:#ae81ff">rabbitmq&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">namespaceSelector&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">any&lt;/span>: &lt;span style="color:#66d9ef">true&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">EOF&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>导入 grafana 面板(面板 ID：10991)&lt;/p></description></item><item><title>Docs: RabbitMQ 集群</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/8.%E9%80%9A%E7%94%A8%E6%8A%80%E6%9C%AF/message-queue%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/rabbitmq/rabbitmq-%E9%9B%86%E7%BE%A4/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/8.%E9%80%9A%E7%94%A8%E6%8A%80%E6%9C%AF/message-queue%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/rabbitmq/rabbitmq-%E9%9B%86%E7%BE%A4/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>官方文档：&lt;a href="https://www.rabbitmq.com/clustering.html">https://www.rabbitmq.com/clustering.html&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>RabbitMQ 这款消息队列中间件产品本身是基于 Erlang 语言编写，Erlang 语言天生具备分布式特性（通过同步 Erlang 集群各节点的 magic cookie 来实现）。&lt;/p>
&lt;p>因此，RabbitMQ 天然支持 Clustering。这使得 RabbitMQ 本身不需要像 ActiveMQ、Kafka 那样通过 ZooKeeper 分别来实现 HA 方案和保存集群的元数据。集群是保证可靠性的一种方式，同时可以通过水平扩展以达到增加消息吞吐量能力的目的。下面先来看下 RabbitMQ 集群的整体方案：&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/iqase5/1616130673298-8615562e-d09c-44b6-be6d-1db0294d30e6.jpeg" alt="">&lt;/p>
&lt;p>上面图中采用三个节点组成了一个 RabbitMQ 的集群，Exchange A 的元数据信息在所有节点上是一致的，而 Queue 的完整数据则只会存在于它所创建的那个节点上。其他节点只知道这个 queue 的 metadata 信息和一个指向 queue 的 owner node 的指针。&lt;/p>
&lt;h2 id="rabbitmq-集群中各节点关系">RabbitMQ 集群中各节点关系&lt;/h2>
&lt;p>RabbitMQ 集群各节点同步的数据&lt;/p>
&lt;p>RabbitMQ 集群的各节点会始终同步四种类型的内部元数据（类似索引）&lt;/p>
&lt;ol>
&lt;li>队列元数据：队列名称和它的属性&lt;/li>
&lt;li>交换器元数据：交换器名称、类型和属性&lt;/li>
&lt;li>绑定元数据：一张简单的表格展示了如何将消息路由到队列&lt;/li>
&lt;li>vhost 元数据：为 vhost 内的队列、交换器和绑定提供命名空间和安全属性&lt;/li>
&lt;/ol>
&lt;p>因此，当用户访问其中任何一个 RabbitMQ 节点时，通过 rabbitmqctl 查询到的 queue/user/exchange/vhost 等信息都是相同的。&lt;/p>
&lt;p>默认情况下，队列中的数据(消息) 是不在各节点互相同步的。如果想要各节点数据保持一致，查看 《RabbitMQ 基于集群的高可用性》章节&lt;/p>
&lt;p>Nodes Equal Peers(节点对等)&lt;/p>
&lt;p>在某些分布式系统中，节点是具有领导者和追随者概念的。对于 RabbitMQ，通常情况并不是这样的。RabbitMQ 集群中所有节点都是 equal peers(对等的)。&lt;/p>
&lt;p>RabbitMQ 集群发送/订阅消息的基本原理&lt;/p>
&lt;p>RabbitMQ 集群的工作原理图如下：&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/iqase5/1616130673314-38d3cddf-87ca-4f97-88aa-523c76136332.jpeg" alt="">&lt;/p>
&lt;p>场景 1：客户端直接连接队列所在节点&lt;/p>
&lt;p>如果有一个生产者或者消费者通过 amqp-client 的客户端连接至节点 1 进行消息的发布或者订阅，那么此时的集群中的消息收发只与节点 1 相关，这个没有任何问题；如果客户端相连的是节点 2 或者节点 3（队列 1 数据不在该节点上），那么情况又会是怎么样呢？&lt;/p>
&lt;p>场景 2：客户端连接的是非队列数据所在节点&lt;/p>
&lt;p>如果消息生产者所连接的是节点 2 或者节点 3，此时队列 1 的完整数据不在该两个节点上，那么在发送消息过程中这两个节点主要起了一个路由转发作用，根据这两个节点上的元数据（也就是上文提到的：指向 queue 的 owner node 的指针）转发至节点 1 上，最终发送的消息还是会存储至节点 1 的队列 1 上。&lt;/p>
&lt;p>同样，如果消息消费者所连接的节点 2 或者节点 3，那这两个节点也会作为路由节点起到转发作用，将会从节点 1 的队列 1 中拉取消息进行消费。&lt;/p>
&lt;h1 id="rabbitmq-基于集群的高可用性">RabbitMQ 基于集群的高可用性&lt;/h1>
&lt;p>默认情况，RabbitMQ 集群模式下，队列的数据(也就是消息)只会留在该队列所在节点上，并不在所有节点互相同步数据。比如我在 node1 创建了 queue1，则 queue1 中的消息，则只存在于 node1 上，这是为了提高 RabbitMQ 的性能，可以将压力分担在集群中每个节点上。&lt;/p>
&lt;p>那么如果想要让集群中的节点复制队列中的数据，以实现高可用效果，RabbitMQ 提供了两种方式实现：&lt;/p>
&lt;ol>
&lt;li>Classic Mirrored Queues(传统镜像队列) # 不会随节点故障而转移&lt;/li>
&lt;li>Quorum Queues(仲裁队列) # 节点故障后，队列自动转移到其他节点&lt;/li>
&lt;/ol>
&lt;p>持久化：&lt;/p>
&lt;ol>
&lt;li>Durable # 节点故障后，队列处于 down 状态。即 开启持久化&lt;/li>
&lt;li>Transient # 节点故障后，队列自动消失。即 关闭持久化&lt;/li>
&lt;/ol>
&lt;p>Note：Quorum 类型队列的持久化必须开启。&lt;/p>
&lt;h2 id="classic-mirrored-queues--不会随节点故障而转移">Classic Mirrored Queues # 不会随节点故障而转移&lt;/h2>
&lt;p>官方文档：&lt;a href="https://www.rabbitmq.com/ha.html">https://www.rabbitmq.com/ha.html&lt;/a>&lt;/p>
&lt;p>Quorum Queues(仲裁队列) 是另一种更现代的队列类型，通过复制提供高可用性，并关注数据安全。在很多情况下，仲裁队列是比传统镜像队列更好的选择&lt;/p>
&lt;h2 id="quorum-queues--节点故障后队列自动转移到其他节点该类型从-380-版本起可用">Quorum Queues # 节点故障后，队列自动转移到其他节点。(该类型从 3.8.0 版本起可用)&lt;/h2>
&lt;p>官方文档：&lt;a href="https://www.rabbitmq.com/quorum-queues.html">https://www.rabbitmq.com/quorum-queues.html&lt;/a>&lt;/p>
&lt;p>仲裁队列是 RabbitMQ 实现高可用的队列类型，基于 RAFT 共识算法 ，从 RabbitMQ 3.8.0 版本开始作为默认推荐的高可用方法。&lt;/p>
&lt;p>Quorum 队列中的数据在个节点保持一致，当其中一个节点故障时，队列会自动转移到其他节点上。&lt;/p>
&lt;h2 id="classic-mirrored-与-quorum-的区别">Classic Mirrored 与 Quorum 的区别&lt;/h2>
&lt;p>永昌，在下列情况下，应使用仲裁队列&lt;/p>
&lt;ol>
&lt;li>数据可用性需求较高，比如销售系统中的新订单或选举系统中的投票，这些消息丢失会造成功能产生重大影响&lt;/li>
&lt;/ol>
&lt;p>通常，在下列情况下，不应使用仲裁队列&lt;/p>
&lt;ol>
&lt;li>数据可用性需求不高的场景。比如股票行情和即使通讯系统&lt;/li>
&lt;/ol></description></item><item><title>Docs: RabbitMQ 命令行工具</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/8.%E9%80%9A%E7%94%A8%E6%8A%80%E6%9C%AF/message-queue%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/rabbitmq/rabbitmq-%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%B7%A5%E5%85%B7/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/8.%E9%80%9A%E7%94%A8%E6%8A%80%E6%9C%AF/message-queue%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/rabbitmq/rabbitmq-%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%B7%A5%E5%85%B7/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;p>RabbitMQ 主要有四个命令行工具 Commend Line Tools，不同的命令行适用不用的场景&lt;/p>
&lt;ul>
&lt;li>rabbitmqctl：负责服务管理和进行操作&lt;/li>
&lt;li>rabbitmq-diagnostics：负责系统诊断和健康检查&lt;/li>
&lt;li>rabbitmq-plugins：负责插件管理&lt;/li>
&lt;li>rabbitmqadmin：用来操作 HTTP API&lt;/li>
&lt;/ul>
&lt;h1 id="rabbitmqctl-管理-rabbitmq-节点">rabbitmqctl 管理 RabbitMQ 节点&lt;/h1>
&lt;p>详见此处&lt;/p>
&lt;h1 id="rabbitmq-diagnostics-负责系统诊断和健康检查">rabbitmq-diagnostics 负责系统诊断和健康检查&lt;/h1>
&lt;h1 id="rabbitmq-plugins-负责插件管理">rabbitmq-plugins 负责插件管理&lt;/h1>
&lt;p>rabbitmq-plugins [&amp;ndash;node ] [&amp;ndash;timeout ] [&amp;ndash;longnames] [&amp;ndash;quiet] []&lt;/p>
&lt;p>Available commands:&lt;/p>
&lt;p>Help:&lt;/p>
&lt;p>autocomplete Provides command name autocomplete variants&lt;/p>
&lt;p>help Displays usage information for a command&lt;/p>
&lt;p>version Displays CLI tools version&lt;/p>
&lt;p>Monitoring, observability and health checks:&lt;/p>
&lt;p>directories Displays plugin directory and enabled plugin file paths&lt;/p>
&lt;p>is_enabled Health check that exits with a non-zero code if provided plugins are not enabled on target node&lt;/p>
&lt;p>Plugin Management:&lt;/p>
&lt;ol>
&lt;li>disable # 禁用一个或多个插件&lt;/li>
&lt;li>enable # 启用一个或多个插件&lt;/li>
&lt;li>list # 列出插件及其状态&lt;/li>
&lt;li>set # 启用一个或多个插件，并禁用其他的插件。&lt;/li>
&lt;/ol>
&lt;h1 id="rabbitmqadmin-用来操作-http-api">rabbitmqadmin 用来操作 HTTP API&lt;/h1>
&lt;p>官方文档：&lt;a href="https://www.rabbitmq.com/management-cli.html">https://www.rabbitmq.com/management-cli.html&lt;/a>&lt;/p>
&lt;p>参考：&lt;a href="https://www.cnblogs.com/xishuai/p/rabbitmq-cli-rabbitmqadmin.html">https://www.cnblogs.com/xishuai/p/rabbitmq-cli-rabbitmqadmin.html&lt;/a>&lt;/p>
&lt;p>rabbitmqadmin 是一个 python 脚本。从 rabbitmq 的 http api 接口可以直接获取该脚本&lt;/p>
&lt;ol>
&lt;li>curl -L 172.38.40.212:45672/cli/rabbitmqadmin -o /usr/local/bin/rabbitmqadmin&lt;/li>
&lt;li>chmod 755 /usr/local/bin/rabbitmqadmin&lt;/li>
&lt;/ol>
&lt;p>生成命令行配置文件&lt;/p>
&lt;p>rabbitmqadmin 默认使用 ~/.rabbitmqadmin.conf 作为配置文件。配置文件用来指定 rabbitmqadmin 连接 rabbitmq http api 的信息，比如 ip、port、登录用户名和密码、所使用的 vhost 等等。注意：配置文件中的内容可以通过命令行参数代替。&lt;/p>
&lt;ol>
&lt;li>cat &amp;gt; /root/.rabbitmqadmin.conf &amp;laquo; EOF&lt;/li>
&lt;li>[default]&lt;/li>
&lt;li>hostname = 172.19.42.214&lt;/li>
&lt;li>port = 45672&lt;/li>
&lt;li>username = admin&lt;/li>
&lt;li>password = admin&lt;/li>
&lt;li>declare_vhost = /&lt;/li>
&lt;li>vhost = /&lt;/li>
&lt;li>EOF&lt;/li>
&lt;/ol>
&lt;p>生成命令补全&lt;/p>
&lt;ol>
&lt;li>echo &amp;ldquo;source &amp;lt;(rabbitmqadmin &amp;ndash;bash-completion)&amp;rdquo; &amp;raquo; /root/.bashrc&lt;/li>
&lt;/ol>
&lt;p>rabbitmqadmin [OPTIONS] COMMAND&lt;/p>
&lt;p>OPTIONS&lt;/p>
&lt;ol>
&lt;li>--config=CONFIG, -c CONFIG # 指定 rabbitmqadmin 的配置文件，默认为: ~/.rabbitmqadmin.conf&lt;/li>
&lt;li>--node=NODE, -N NODE # 指定配置文件中节点(即配置中间中 [] 内的值就是节点名) [default:&amp;lsquo;default&amp;rsquo; only if configuration file is specified]&lt;/li>
&lt;li>--host=HOST, -H HOST # connect to host HOST [default: localhost]&lt;/li>
&lt;li>--port=PORT, -P PORT # connect to port PORT [default: 15672]&lt;/li>
&lt;li>--path-prefix=PATH_PREFIX # use specific URI path prefix for the RabbitMQ HTTP API. /api and operation path will be appended to it.(default: blank string) [default: ]&lt;/li>
&lt;li>--vhost=VHOST, -V VHOST # 指定要连接的 VHost [default: all vhosts for list,&amp;rsquo;/&amp;rsquo; for declare]&lt;/li>
&lt;li>--username=USERNAME, -u USERNAME # 指定连接时所使用的用户名，默认为 guest&lt;/li>
&lt;li>--password=PASSWORD, -p PASSWORD # 指定连接时所使用的密码，默认为 guest&lt;/li>
&lt;li>--base-uri=URI, -U URI # connect using a base HTTP API URI. /api and operation path will be appended to it. Path will be ignored.&amp;ndash;vhost has to be provided separately.&lt;/li>
&lt;li>--quiet, -q # suppress status messages [default: True]&lt;/li>
&lt;li>--ssl, -s # connect with ssl [default: False]&lt;/li>
&lt;li>--ssl-key-file=SSL_KEY_FILE # PEM format key file for SSL&lt;/li>
&lt;li>--ssl-cert-file=SSL_CERT_FILE # PEM format certificate file for SSL&lt;/li>
&lt;li>--ssl-ca-cert-file=SSL_CA_CERT_FILE # PEM format CA certificate file for SSL&lt;/li>
&lt;li>--ssl-disable-hostname-verification # Disables peer hostname verification&lt;/li>
&lt;li>--ssl-insecure, -k # Disables all SSL validations like curl&amp;rsquo;s &amp;lsquo;-k&amp;rsquo; argument&lt;/li>
&lt;li>--request-timeout=REQUEST_TIMEOUT, -t REQUEST_TIMEOUT # HTTP request timeout in seconds [default: 120]&lt;/li>
&lt;li>--format=FORMAT, -f FORMAT # format for listing commands - one of [raw_json,pretty_json, tsv, long, table, kvp, bash] [default:table]&lt;/li>
&lt;li>--sort=SORT, -S SORT # sort key for listing queries&lt;/li>
&lt;li>--sort-reverse, -R # reverse the sort order&lt;/li>
&lt;li>--depth=DEPTH, -d DEPTH # maximum depth to recurse for listing tables [default:1]&lt;/li>
&lt;li>--bash-completion # Print bash completion script [default: False]&lt;/li>
&lt;li>--version # Display version and exit&lt;/li>
&lt;/ol>
&lt;h2 id="显示信息-command">显示信息 COMMAND&lt;/h2>
&lt;p>list connections [&amp;hellip;] # 显示连接信息&lt;/p>
&lt;p>list channels [&amp;hellip;]&lt;/p>
&lt;p>list consumers [&amp;hellip;]&lt;/p>
&lt;p>list exchanges [&amp;hellip;]&lt;/p>
&lt;p>list queues [&amp;hellip;]&lt;/p>
&lt;p>list bindings [&amp;hellip;]&lt;/p>
&lt;p>list users [&amp;hellip;] # 显示所有用户&lt;/p>
&lt;p>list vhosts [&amp;hellip;] # 显示所有 vhosts&lt;/p>
&lt;p>list permissions [&amp;hellip;]&lt;/p>
&lt;p>list nodes [&amp;hellip;] # 显示所有节点&lt;/p>
&lt;p>list parameters [&amp;hellip;]&lt;/p>
&lt;p>list policies [&amp;hellip;]&lt;/p>
&lt;p>list operator_policies [&amp;hellip;]&lt;/p>
&lt;p>list vhost_limits [&amp;hellip;]&lt;/p>
&lt;p>show overview [&amp;hellip;]&lt;/p>
&lt;h2 id="创建资源-command">创建资源 COMMAND&lt;/h2>
&lt;h3 id="exchange-声明交换器">exchange 声明交换器&lt;/h3>
&lt;p>rabbitmqadmin declare exchange name=&amp;hellip; type=&amp;hellip; [auto_delete=&amp;hellip; durable=&amp;hellip; internal=&amp;hellip; arguments=&amp;hellip;]&lt;/p>
&lt;p>EXAMPLE&lt;/p>
&lt;ol>
&lt;li>rabbitmqadmin &amp;ndash;vhost=test declare exchange name=test.topic type=topic #&lt;/li>
&lt;/ol>
&lt;h3 id="queue-声明队列">queue 声明队列&lt;/h3>
&lt;p>rabbitmqadmin declare queue name=&amp;hellip; [auto_delete=&amp;hellip; durable=&amp;hellip; arguments=&amp;hellip; node=&amp;hellip; queue_type=&amp;hellip;]&lt;/p>
&lt;p>OPTIONS&lt;/p>
&lt;ol>
&lt;li>durable= # 该队列是否持久化。默认为 true&lt;/li>
&lt;li>queue_type= # 该队列类型。默认为 classic。TYPE 可用值为 classic、quorum&lt;/li>
&lt;li>Note：quorum 类型下，durable 只能为 true。&lt;/li>
&lt;/ol>
&lt;p>EXAMPLE&lt;/p>
&lt;ol>
&lt;li>rabbitmqadmin &amp;ndash;vhost=test declare queue name=test-1 queue_type=quorum #&lt;/li>
&lt;/ol>
&lt;h3 id="binding-绑定一个交换器和队列">binding 绑定一个交换器和队列&lt;/h3>
&lt;p>rabbitmqadmin declare binding source=&amp;hellip; destination=&amp;hellip; [destination_type=&amp;hellip; routing_key=&amp;hellip; arguments=&amp;hellip;]&lt;/p>
&lt;p>OPTIONS&lt;/p>
&lt;p>EXAMPLE&lt;/p>
&lt;ol>
&lt;li>rabbitmqadmin &amp;ndash;vhost=test declare binding source=test.topic destination=test routing_key=my.# #&lt;/li>
&lt;/ol>
&lt;h3 id="vhost-声明虚拟主机">vhost 声明虚拟主机&lt;/h3>
&lt;p>rabbitmqadmin declare vhost name=&amp;hellip; [tracing=&amp;hellip;]&lt;/p>
&lt;p>OPTIONS&lt;/p>
&lt;p>EXAMPLE&lt;/p>
&lt;ol>
&lt;li>rabbitmqadmin declare vhost name=test #&lt;/li>
&lt;/ol>
&lt;p>declare user name=&amp;hellip; password=&amp;hellip; OR password_hash=&amp;hellip; tags=&amp;hellip; [hashing_algorithm=&amp;hellip;]&lt;/p>
&lt;p>declare permission vhost=&amp;hellip; user=&amp;hellip; configure=&amp;hellip; write=&amp;hellip; read=&amp;hellip;&lt;/p>
&lt;p>declare parameter component=&amp;hellip; name=&amp;hellip; value=&amp;hellip;&lt;/p>
&lt;p>declare policy name=&amp;hellip; pattern=&amp;hellip; definition=&amp;hellip; [priority=&amp;hellip; apply-to=&amp;hellip;]&lt;/p>
&lt;p>declare operator_policy name=&amp;hellip; pattern=&amp;hellip; definition=&amp;hellip; [priority=&amp;hellip; apply-to=&amp;hellip;]&lt;/p>
&lt;p>declare vhost_limit vhost=&amp;hellip; name=&amp;hellip; value=&amp;hellip;&lt;/p>
&lt;h2 id="删除清理资源-command">删除、清理资源 COMMAND&lt;/h2>
&lt;p>delete exchange name=&amp;hellip;&lt;/p>
&lt;p>delete queue name=&amp;hellip;&lt;/p>
&lt;p>delete binding source=&amp;hellip; destination_type=&amp;hellip; destination=&amp;hellip; [properties_key=&amp;hellip;]&lt;/p>
&lt;p>delete vhost name=&amp;hellip;&lt;/p>
&lt;p>delete user name=&amp;hellip;&lt;/p>
&lt;p>delete permission vhost=&amp;hellip; user=&amp;hellip;&lt;/p>
&lt;p>delete parameter component=&amp;hellip; name=&amp;hellip;&lt;/p>
&lt;p>delete policy name=&amp;hellip;&lt;/p>
&lt;p>delete operator_policy name=&amp;hellip;&lt;/p>
&lt;p>delete vhost_limit vhost=&amp;hellip; name=&amp;hellip;&lt;/p>
&lt;p>close connection name=&amp;hellip;&lt;/p>
&lt;p>purge queue name=&amp;hellip;&lt;/p>
&lt;h2 id="broker-定义-command">Broker 定义 COMMAND&lt;/h2>
&lt;p>export&lt;/p>
&lt;p>import&lt;/p>
&lt;h2 id="发布与消费消息-command">发布与消费消息 COMMAND&lt;/h2>
&lt;h3 id="publish-发布消息">publish 发布消息&lt;/h3>
&lt;p>rabbitmqadmin publish routing_key=&amp;hellip; [payload=&amp;hellip; properties=&amp;hellip; exchange=&amp;hellip; payload_encoding=&amp;hellip;]&lt;/p>
&lt;p>EXAMPLE&lt;/p>
&lt;ol>
&lt;li>rabbitmqadmin publish routing_key=test payload=&amp;ldquo;hello world&amp;rdquo; #&lt;/li>
&lt;li>rabbitmqadmin publish routing_key=my.test exchange=my.topic payload=&amp;ldquo;hello world by my.test&amp;rdquo; #&lt;/li>
&lt;li>rabbitmqadmin publish routing_key=my.test.test exchange=my.topic payload=&amp;ldquo;hello world by my.test.test&amp;rdquo; #&lt;/li>
&lt;/ol>
&lt;h3 id="get-消费消息">get 消费消息&lt;/h3>
&lt;p>rabbitmqadmin get queue=&amp;hellip; [count=&amp;hellip; ackmode=&amp;hellip; payload_file=&amp;hellip; encoding=&amp;hellip;]&lt;/p>
&lt;p>OPTIONS&lt;/p>
&lt;ol>
&lt;li>count= # 指定要获取的最大消息数。默认为 1，即只获取队列中最先进入的消息。&lt;/li>
&lt;li>ackmode= # 指定是否从队列中删除消息。默认为 ack_requeue_true&lt;/li>
&lt;li>ack_requeue_true # 重新排队，不删除消息&lt;/li>
&lt;li>ack_requeue_fale # 删除消息&lt;/li>
&lt;/ol>
&lt;p>EXAMPLE&lt;/p>
&lt;ol>
&lt;li>rabbitmqadmin get queue=test # 获取 test 队列中的消息&lt;/li>
&lt;li>rabbitmqadmin get queue=test ackmode=ack_requeue_false # 获取 test 队列中的消息，并将获取到的消息删除&lt;/li>
&lt;/ol>
&lt;ul>
&lt;li>
&lt;p>If payload is not specified on publish, standard input is used&lt;/p>
&lt;/li>
&lt;li>
&lt;p>If payload_file is not specified on get, the payload will be shown on&lt;/p>
&lt;p>standard output along with the message metadata&lt;/p>
&lt;/li>
&lt;li>
&lt;p>If payload_file is specified on get, count must not be set&lt;/p>
&lt;/li>
&lt;/ul></description></item><item><title>Docs: RabbitMQ 配置详解</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/8.%E9%80%9A%E7%94%A8%E6%8A%80%E6%9C%AF/message-queue%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/rabbitmq/rabbitmq-%E9%85%8D%E7%BD%AE%E8%AF%A6%E8%A7%A3/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/8.%E9%80%9A%E7%94%A8%E6%8A%80%E6%9C%AF/message-queue%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/rabbitmq/rabbitmq-%E9%85%8D%E7%BD%AE%E8%AF%A6%E8%A7%A3/</guid><description/></item><item><title>Docs: RabbitMQ 性能与优化</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/8.%E9%80%9A%E7%94%A8%E6%8A%80%E6%9C%AF/message-queue%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/rabbitmq/rabbitmq-%E6%80%A7%E8%83%BD%E4%B8%8E%E4%BC%98%E5%8C%96/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/8.%E9%80%9A%E7%94%A8%E6%8A%80%E6%9C%AF/message-queue%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/rabbitmq/rabbitmq-%E6%80%A7%E8%83%BD%E4%B8%8E%E4%BC%98%E5%8C%96/</guid><description>
&lt;p>RabbitMQ性能评估，第2部分&lt;/p>
&lt;p>&lt;a href="https://www.rabbitmq.com/blog/2012/04/25/rabbitmq-performance-measurements-part-2/">https://www.rabbitmq.com/blog/2012/04/25/rabbitmq-performance-measurements-part-2/&lt;/a>&lt;/p></description></item><item><title>Docs: rabbitmqctl 命令行工具详解</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/8.%E9%80%9A%E7%94%A8%E6%8A%80%E6%9C%AF/message-queue%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/rabbitmq/rabbitmqctl-%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%B7%A5%E5%85%B7%E8%AF%A6%E8%A7%A3/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/8.%E9%80%9A%E7%94%A8%E6%8A%80%E6%9C%AF/message-queue%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/rabbitmq/rabbitmqctl-%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%B7%A5%E5%85%B7%E8%AF%A6%E8%A7%A3/</guid><description>
&lt;h1 id="rabbitmqctl-管理-rabbitmq-节点的工具">rabbitmqctl 管理 RabbitMQ 节点的工具&lt;/h1>
&lt;p>官方文档：&lt;a href="https://www.rabbitmq.com/rabbitmqctl.8.html">https://www.rabbitmq.com/rabbitmqctl.8.html&lt;/a>&lt;/p>
&lt;p>rabbitmqctl 是用于管理 RabbitMQ 服务器节点的命令行工具。它通过连接到专用 CLI 工具通信端口上的目标 RabbitMQ 节点并使用共享密钥（称为 cookie 文件）进行身份验证来执行所有操作。该命令主要的功能包括以下几点：&lt;/p>
&lt;ol>
&lt;li>
&lt;p>停止节点运行&lt;/p>
&lt;/li>
&lt;li>
&lt;p>获取节点状态、有效配置、健康检查&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Virtual Hosts 管理&lt;/p>
&lt;/li>
&lt;li>
&lt;p>用户和权限管理&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Policy 管理&lt;/p>
&lt;/li>
&lt;li>
&lt;p>查看 queues、connections、channels、exchanges 和 consumers 列表信息&lt;/p>
&lt;/li>
&lt;li>
&lt;p>集群会员身份管理&lt;/p>
&lt;/li>
&lt;/ol>
&lt;p>&lt;strong>rabbitmqctl [OPTIONS] COMMAND [COMMAND_OPTIONS]&lt;/strong>&lt;/p>
&lt;p>OPTIONS&lt;/p>
&lt;ol>
&lt;li>-q.&amp;ndash;quiet # 安静模式输出，输出的信息减少&lt;/li>
&lt;/ol>
&lt;p>COMMAND 包括如下几大类：&lt;/p>
&lt;ol>
&lt;li>
&lt;p>Nodes # 节点管理&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Cluster Managerment # 集群管理&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Replication&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Users Management # 用户管理&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Access Control # 访问控制&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Monitoring, observability and health checks&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Parameters&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Policies&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Virtual hosts&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Configuration and Environment&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Definitions&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Feature flags&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Operations&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Queues&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Deprecated&lt;/p>
&lt;/li>
&lt;/ol>
&lt;p>COMMAND_OPTIONS 中有几个通用的&lt;/p>
&lt;ol>
&lt;li>-p &lt;!-- raw HTML omitted --> # 用于当前适用的 COMMAND 所作用的 Virtual Host(虚拟主机)，VHost 为虚拟主机名称。默认为 / 这个 Virtual Host&lt;/li>
&lt;/ol>
&lt;h1 id="nodes-类子命令">Nodes 类子命令&lt;/h1>
&lt;p>await_startup # Waits for the RabbitMQ application to start on the target node&lt;/p>
&lt;p>reset # Instructs a RabbitMQ node to leave the cluster and return to its virgin state&lt;/p>
&lt;p>rotate_logs # Instructs the RabbitMQ node to perform internal log rotation&lt;/p>
&lt;p>shutdown # Stops RabbitMQ and its runtime (Erlang VM). Monitors progress for local nodes. Does not require a PID file path.&lt;/p>
&lt;p>start_app # Starts the RabbitMQ application but leaves the runtime (Erlang VM) running&lt;/p>
&lt;p>stop # Stops RabbitMQ and its runtime (Erlang VM). Requires a local node pid file path to monitor progress.&lt;/p>
&lt;p>stop_app # Stops the RabbitMQ application, leaving the runtime (Erlang VM) running&lt;/p>
&lt;p>wait # Waits for RabbitMQ node startup by monitoring a local PID file. See also &amp;lsquo;rabbitmqctl await_online_nodes&amp;rsquo;&lt;/p>
&lt;h1 id="cluster-management-集群管理类子命令">Cluster Management 集群管理类子命令&lt;/h1>
&lt;p>await_online_nodes Waits for nodes to join the cluster&lt;/p>
&lt;p>change_cluster_node_typeChanges the type of the cluster node&lt;/p>
&lt;h2 id="cluster_status--显示按节点类型分组的集群中的所有节点信息以及当前正在运行的节点">cluster_status # 显示按节点类型分组的集群中的所有节点信息，以及当前正在运行的节点&lt;/h2>
&lt;p>force_boot Forces node to start even if it cannot contact or rejoin any of its previously known peers&lt;/p>
&lt;p>force_reset Forcefully returns a RabbitMQ node to its virgin state&lt;/p>
&lt;p>forget_cluster_node Removes a node from the cluster&lt;/p>
&lt;p>join_cluster Instructs the node to become a member of the cluster that the specified node is in&lt;/p>
&lt;p>rename_cluster_node Renames cluster nodes in the local database&lt;/p>
&lt;p>update_cluster_nodes Instructs a cluster member node to sync the list of known cluster members from&lt;/p>
&lt;h1 id="replication">Replication&lt;/h1>
&lt;h1 id="users-management-用户管理类子命令">Users Management 用户管理类子命令&lt;/h1>
&lt;h2 id="add_user--在内部数据库中创建一个新用户">add_user # 在内部数据库中创建一个新用户&lt;/h2>
&lt;p>&lt;strong>rabbitmqctl add_user &lt;!-- raw HTML omitted --> &lt;!-- raw HTML omitted -->&lt;/strong>&lt;/p>
&lt;p>EXAMPLE&lt;/p>
&lt;ol>
&lt;li>rabbitmqctl add_user admin admin # 添加一个名为 admin 的用户，并设置其密码为 admin&lt;/li>
&lt;/ol>
&lt;p>authenticate_user # Attempts to authenticate a user. Exits with a non-zero code if authentication fails.&lt;/p>
&lt;p>change_password # Changes the user password&lt;/p>
&lt;p>clear_password # Clears (resets) password and disables password login for a user&lt;/p>
&lt;p>delete_user # Removes a user from the internal database. Has no effect on users provided by external backends such as LDAP&lt;/p>
&lt;h2 id="list_users--列出所有用户和其标签">list_users # 列出所有用户和其标签&lt;/h2>
&lt;p>该命令效果如下：共两列，第一列为用户名，第二列为标签&lt;/p>
&lt;pre>&lt;code>rabbitmq@hello-world-rabbitmq-server-0:/$ rabbitmqctl list_users
Listing users ...
user tags
8E3s22eVBbIy3EINPFo0f8hBQ0FClORp [administrator]
admin [administrator]
test [monitoring]
&lt;/code>&lt;/pre>
&lt;p>set_user_tags # 设置指定用户的标签&lt;/p>
&lt;p>&lt;strong>rabbitmqctl set_user_tags &lt;!-- raw HTML omitted --> &lt;!-- raw HTML omitted -->&lt;/strong>&lt;/p>
&lt;p>TAG 可以是任意值，但是有几个值在 rabbitmq 中具有特殊含义&lt;/p>
&lt;ol>
&lt;li>
&lt;p>administrator # 可登录管理控制台（启用 management plugin 的情况下），查看所有的信息，并且可以对用户、策略（policy）进行操作；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>monitoring # 可登录管理控制台（启用 management plugin 的情况下），同时可以查看 rabbitmq 节点的相关信息（进程数、内存使用情况，磁盘使用情况等）；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>policymaker # 可以登录管理控制台（启用 management plugin 的情况下），同时可以对策略（policy）进行操作；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>management # 仅可登录管理控制台（启用 management plugin 的情况下），无法看到节点信息，也无法对策略进行管理；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>其他任意值 # 无法登录管理控制台，通常就是普通的生产者和消费者，这种 TAG 仅仅作为标识符。&lt;/p>
&lt;/li>
&lt;/ol>
&lt;p>EXAMPLE&lt;/p>
&lt;ol>
&lt;li>
&lt;p>rabbitmqctl set_user_tags admin administrator # 设置 admin 这个用户的标签为 administrator，让 admin 用户具有管理员权限。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>rabbitmqctl set_user_tags admin # 移除 admin 这个用户的所有标签&lt;/p>
&lt;/li>
&lt;/ol>
&lt;h1 id="access-control-访问控制子命令">Access Control 访问控制子命令&lt;/h1>
&lt;h2 id="clear_permissions--撤销指定用户关于-vhost-的权限">clear_permissions # 撤销指定用户关于 vhost 的权限&lt;/h2>
&lt;p>&lt;strong>rabbitmqctl clear_permissions [-p VHOST] UserNAME&lt;/strong>&lt;/p>
&lt;p>EXAMPLE&lt;/p>
&lt;ol>
&lt;li>rabbitmqctl clear_permissions -p test admin # 撤销 admin 用户关于 / 这个 vhost 的所有全新&lt;/li>
&lt;/ol>
&lt;p>clear_topic_permissions # Clears user topic permissions for a vhost or exchange&lt;/p>
&lt;p>list_permissions # Lists user permissions in a virtual host&lt;/p>
&lt;p>list_topic_permissions # Lists topic permissions in a virtual host&lt;/p>
&lt;p>list_user_permissions # Lists permissions of a user across all virtual hosts&lt;/p>
&lt;p>list_user_topic_permissions # Lists user topic permissions&lt;/p>
&lt;h2 id="list_vhosts--列出所有-virtual-hosts">list_vhosts # 列出所有 virtual hosts&lt;/h2>
&lt;h2 id="set_permissions--设置指定用户关于-vhost-的权限">set_permissions # 设置指定用户关于 vhost 的权限&lt;/h2>
&lt;p>&lt;strong>rabbitmqctl set_permissions [-p VHost] UserName CONF WRITE READ&lt;/strong>&lt;/p>
&lt;p>一个用户对于 vhost 来说，有 CONF(配置)、WRITE(写)、READ(读) 这三个权限。可以使用正则表达式。&lt;/p>
&lt;p>EXAMPLE&lt;/p>
&lt;ol>
&lt;li>rabbitmqctl set_permissions -p / admin &amp;lsquo;.&lt;em>&amp;rsquo; &amp;lsquo;.&lt;/em>&amp;rsquo; &amp;lsquo;.*&amp;rsquo; # 为 admin 用户授予关于 / 这个 vhost 下所有资源的所有权限。&lt;/li>
&lt;/ol>
&lt;p>set_topic_permissions # Sets user topic permissions for an exchange&lt;/p>
&lt;h1 id="monitoring-observability-and-health-checks-监控可观察性以及健康检查子命令">Monitoring, observability and health checks 监控，可观察性以及健康检查子命令&lt;/h1>
&lt;p>list_bindings # Lists all bindings on a vhost&lt;/p>
&lt;p>list_channels # Lists all channels in the node&lt;/p>
&lt;p>list_ciphers # Lists cipher suites supported by encoding commands&lt;/p>
&lt;p>list_connections # Lists AMQP 0.9.1 connections for the node&lt;/p>
&lt;p>list_consumers # Lists all consumers for a vhost&lt;/p>
&lt;h2 id="list_exchanges--列出交换器的详细信息">list_exchanges # 列出交换器的详细信息&lt;/h2>
&lt;p>&lt;strong>rabbitmqctl list_exchanges [-p VHost] [ExchangeInfoItem]&lt;/strong>&lt;/p>
&lt;p>ExchangeInfoItem # 该参数用于指示要在结果中包括交换器的哪些信息。多个信息使用逗号或空格分隔。默认显示 exchanges 的 name 与 type 信息。&lt;/p>
&lt;p>可用的信息有如下几个：&lt;/p>
&lt;ol>
&lt;li>name、type、durable、auto_delete、internal、arguments、policy&lt;/li>
&lt;/ol>
&lt;p>EXAMPLE&lt;/p>
&lt;p>list_hashes # Lists hash functions supported by encoding commands&lt;/p>
&lt;h2 id="list_queues--列出队列及其属性">list_queues # 列出队列及其属性&lt;/h2>
&lt;p>&lt;strong>rabbitmqctl list_queues [-p VHost] [QueueInfoItem]&lt;/strong>&lt;/p>
&lt;p>QueueInfoItem 用于指示要在结果中包括哪些队列信息项。结果中的列顺序将与参数的顺序匹配。不使用该参数时，默认显示 name 与 message 信息。&lt;/p>
&lt;p>QueueInfoItem&lt;/p>
&lt;ol>
&lt;li>
&lt;p>name # 队列的名称&lt;/p>
&lt;/li>
&lt;li>
&lt;p>pid # 队列的 Erlang 进程标识符(其中包含队列在哪个节点)&lt;/p>
&lt;/li>
&lt;li>
&lt;p>messages # 队列深度，即 ready 和 unacknowledged 两种状态的消息总和。&lt;/p>
&lt;/li>
&lt;/ol>
&lt;p>EXAMPLE&lt;/p>
&lt;ol>
&lt;li>rabbitmqctl list_queues # 列出 / vhost 下的队列名及其消息数量，效果如下&lt;/li>
&lt;/ol>
&lt;!-- raw HTML omitted -->
&lt;pre>&lt;code>rabbitmq@hello-world-rabbitmq-server-0:/$ rabbitmqctl list_queues
Timeout: 60.0 seconds ...
Listing queues for vhost / ...
name messages
test 2
&lt;/code>&lt;/pre>
&lt;p>list_unresponsive_queues # Tests queues to respond within timeout. Lists those which did not respond&lt;/p>
&lt;p>ping # Checks that the node OS process is up, registered with EPMD and CLI tools can authenticate with it&lt;/p>
&lt;p>report # Generate a server status report containing a concatenation of all server status information for support purposes&lt;/p>
&lt;p>schema_info # Lists schema database tables and their properties&lt;/p>
&lt;h2 id="status--显示节点的状态">status # 显示节点的状态&lt;/h2>
&lt;h1 id="runtime-parameters-and-policies-运行时参数和策略相关子命令">Runtime Parameters and Policies 运行时参数和策略相关子命令&lt;/h1>
&lt;p>clear_global_parameter Clears a global runtime parameter&lt;/p>
&lt;p>clear_parameter Clears a runtime parameter.&lt;/p>
&lt;p>list_global_parameters Lists global runtime parameters&lt;/p>
&lt;p>list_parameters Lists runtime parameters for a virtual host&lt;/p>
&lt;p>set_global_parameter Sets a runtime parameter.&lt;/p>
&lt;p>set_parameter Sets a runtime parameter.&lt;/p>
&lt;p>clear_operator_policy Clears an operator policy&lt;/p>
&lt;p>clear_policy Clears (removes) a policy&lt;/p>
&lt;p>list_operator_policies Lists operator policy overrides for a virtual host&lt;/p>
&lt;p>list_policies Lists all policies in a virtual host&lt;/p>
&lt;p>set_operator_policy Sets an operator policy that overrides a subset of arguments in user policies&lt;/p>
&lt;p>set_policy Sets or updates a policy&lt;/p>
&lt;h1 id="virtual-hosts-虚拟主机相关子命令">Virtual hosts 虚拟主机相关子命令&lt;/h1>
&lt;h2 id="add_vhost--创建一个-vhost">add_vhost # 创建一个 vhost&lt;/h2>
&lt;p>&lt;strong>rabbitmqctl add_vhost VHOST&lt;/strong>&lt;/p>
&lt;p>EXAMPLE&lt;/p>
&lt;ol>
&lt;li>rabbitmqctl add_vhost test # 创建一个名为 test 的 vhost&lt;/li>
&lt;/ol>
&lt;p>clear_vhost_limits # Clears virtual host limits&lt;/p>
&lt;h2 id="delete_vhost--删除一个-vhost">delete_vhost # 删除一个 vhost&lt;/h2>
&lt;blockquote>
&lt;p>注意：删除 vhost 将删除其所有交换，队列，绑定，用户权限，参数和策略。&lt;/p>
&lt;/blockquote>
&lt;p>&lt;strong>rabbitmqctl delete_vhost VHOST&lt;/strong>&lt;/p>
&lt;p>EXAMPLE&lt;/p>
&lt;ol>
&lt;li>rabbitmqctl delete_vhost test # 删除一个名为 test 的 vhost&lt;/li>
&lt;/ol>
&lt;p>list_vhost_limits # Displays configured virtual host limits&lt;/p>
&lt;p>restart_vhost # Restarts a failed vhost data stores and queues&lt;/p>
&lt;p>set_vhost_limits # Sets virtual host limits&lt;/p>
&lt;p>trace_off #&lt;/p>
&lt;p>trace_on #&lt;/p>
&lt;p>Configuration and Environment&lt;/p>
&lt;p>Definitions&lt;/p>
&lt;p>Feature flags&lt;/p>
&lt;p>Operations&lt;/p>
&lt;h1 id="queues-operations-队列的相关操作子命令">Queues Operations 队列的相关操作子命令&lt;/h1>
&lt;h2 id="delete_queue--删除一个队列">delete_queue # 删除一个队列&lt;/h2>
&lt;p>&lt;strong>rabbitmqctl delete_queue QueueName [-p VHost] [OPTIONS]&lt;/strong>&lt;/p>
&lt;p>OPTIONS&lt;/p>
&lt;ol>
&lt;li>
&lt;p>--if-empty,-e # 如果队列为空，则删除。(没有准备好传递的消息)&lt;/p>
&lt;/li>
&lt;li>
&lt;p>--if-unused,-u # 仅当队列没有消费者时才删除。&lt;/p>
&lt;/li>
&lt;/ol>
&lt;h2 id="purge_queue--清洗一个队列删除队列中所有的消息">purge_queue # 清洗一个队列(删除队列中所有的消息)&lt;/h2>
&lt;h1 id="deprecated">Deprecated&lt;/h1></description></item><item><title>Docs: Regular Expression(正则表达式)</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/8.%E9%80%9A%E7%94%A8%E6%8A%80%E6%9C%AF/regular-expression%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/8.%E9%80%9A%E7%94%A8%E6%8A%80%E6%9C%AF/regular-expression%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="v">Wiki,Regular Expression&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://regex101.com/">正则表达式在线测试&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://r2coding.com/#/README?id=%e6%ad%a3%e5%88%99%e8%a1%a8%e8%be%be%e5%bc%8f">https://r2coding.com/#/README?id=%e6%ad%a3%e5%88%99%e8%a1%a8%e8%be%be%e5%bc%8f&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>&lt;strong>Regular Expression(正则表达式，简称 RegEX 或 RegEXP)&lt;/strong> 是用于定义 Search Pattern(搜索模式) 的一系列字符串。这种 &lt;strong>Pattern(模式)&lt;/strong> 通常被字符串搜索算法用于 find(查找) 字符串、或 find and replace(查找并替换) 字符串、或者验证输入内容。RegEX 是一种在 Theoretical Computer Science(理论计算机科学) 和 Formal Language(形式语言) 理论中发展起来的技术。&lt;/p>
&lt;p>用白话说，所谓的 正则表达式，就是用来通过一种称为 **Pattern(模式) **的方式，筛选出长篇内容里的部分内容。其实就是一堆字符组合在一起形成一种行为，这个行为就是匹配字符行为。也可以勉强算编程语言的一种吧~&lt;/p>
&lt;p>&lt;strong>所以，这个世界在很多时候，把正则表达式这个概念，用 RegEX、RegEXP、Pattern 这几种单词表示。&lt;/strong>&lt;/p>
&lt;p>RegEX 概念产生于 1950 年，美国数学家 斯蒂芬·科尔·克莱恩 正式定义了 &lt;strong>Regular Language(正则表达式语言)&lt;/strong>。这个概念在 Unix 文本处理工具中得到了普遍使用，自 20 世纪 80 年代 以来，存在着不同的正则表达式书写语法，一种是 POSIX 标准，另一种是 Perl 语法。&lt;/p>
&lt;p>正则表达式用于搜索引擎，字处理器和文本编辑器的搜索和替换对话框，sed 和 awk 等文本处理应用程序以及词法分析中。许多编程语言通过内置或库提供正则表达式功能。&lt;/p>
&lt;h1 id="正则表达式的符号参考">正则表达式的符号参考&lt;/h1>
&lt;p>说明：&lt;/p>
&lt;ul>
&lt;li>&lt;code>...&lt;/code> 表示任意字符串，并不是正则字符的组成部分&lt;/li>
&lt;/ul>
&lt;h2 id="字符匹配">字符匹配&lt;/h2>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>字符&lt;/th>
&lt;th>描述&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>.&lt;/td>
&lt;td>匹配除换行符之外的任意单个字符(不包含空行)。等价于 [^\n\r]&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>\w&lt;/td>
&lt;td>匹配字母、数字、下划线。等价于 [A-Za-z0-9_]&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h2 id="次数匹配模式匹配该表达式前面的一个字符出现的次数">次数匹配模式：匹配该表达式前面的一个字符出现的次数&lt;/h2>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>符号&lt;/th>
&lt;th>详解&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>*&lt;/td>
&lt;td>次数匹配，匹配 &lt;code>*&lt;/code> 前面的一个字符重复出现任意(包括 0 次,即不出现前一个字符)次数，例：x&lt;em>是无数个 x，1&lt;/em>是无数个 1&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>.*&lt;/td>
&lt;td>重复任意一个字符，即任意多个字符&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>^.*&lt;/td>
&lt;td>以任意多个字符串开头，.*尽可能多，有多少算多少，贪婪性&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>?&lt;/td>
&lt;td>&lt;code>?&lt;/code> 前面字符出现 0 次或者 1 次的，即问一下这个字符有还是没有&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>+&lt;/td>
&lt;td>匹配 &lt;code>+&lt;/code> 前的字符至少一次&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>{m}&lt;/td>
&lt;td>匹配前一个字符 m 次，例：grep &amp;ldquo;s\{3\} /home 匹配 sss 的内容&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>{m,n}&lt;/td>
&lt;td>匹配最少 m 次，最多 n 次，注意：这几种类型的匹配如果不在 egrep 中搜索需要在{前加\&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>{m,}&lt;/td>
&lt;td>匹配最少 m 次&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>{0,n}&lt;/td>
&lt;td>匹配最多 n 次&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h2 id="非打印字符匹配">非打印字符匹配&lt;/h2>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>符号&lt;/th>
&lt;th>描述&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>\cx&lt;/td>
&lt;td>匹配由 x 指明的控制字符。例如， \cM 匹配一个 Control-M 或回车符。x 的值必须为 A-Z 或 a-z 之一。否则，将 c 视为一个原义的 &amp;lsquo;c&amp;rsquo; 字符。&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>\f&lt;/td>
&lt;td>匹配一个换页符。等价于 \x0c 和 \cL。&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>\n&lt;/td>
&lt;td>匹配一个换行符。等价于 \x0a 和 \cJ。&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>\r&lt;/td>
&lt;td>匹配一个回车符。等价于 \x0d 和 \cM。&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>\s&lt;/td>
&lt;td>匹配任何空白字符，包括空格、制表符、换页符等等。等价于 [ \f\n\r\t\v]。注意 Unicode 正则表达式会匹配全角空格符。&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>\S&lt;/td>
&lt;td>匹配任何非空白字符。等价于 [^ \f\n\r\t\v]。&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>\t&lt;/td>
&lt;td>匹配一个制表符。等价于 \x09 和 \cI。&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>\v&lt;/td>
&lt;td>匹配一个垂直制表符。等价于 \x0b 和 \cK。&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h2 id="锚点匹配用于指定字符出现的位置">锚点匹配：用于指定字符出现的位置&lt;/h2>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>符号&lt;/th>
&lt;th>详解&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>^&lt;/td>
&lt;td>指定行首，^WORD 搜索一行开头以 WORD 字符开头的行的内容&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>$&lt;/td>
&lt;td>指定行尾，word$搜索一行最后以 word 结尾的内容&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>^$&lt;/td>
&lt;td>表示空白行，不是空格（^li$显示只有 li 的行）&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>\b&lt;/td>
&lt;td>匹配单词边界&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>\&amp;gt;&lt;/td>
&lt;td>指定词尾， “abc\&amp;gt;”表示所有包含以”abc”结尾的单词的行“&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>\&amp;lt;&lt;/td>
&lt;td>指定词首， “\&amp;lt;abc”表示所有包含以”abc”开头的单词的行“&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h2 id="括号表达式">括号表达式&lt;/h2>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>符号&lt;/th>
&lt;th>详解&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>[abc][0-9][\.,/]&lt;/td>
&lt;td>匹配字符集合内的任意一个字符 a 或 b 或 c。[a-z]匹配所有小写字母，表示一个区间，[abc]找 a 或 b 或 c 可以写成[a-c]&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>[^abc]&lt;/td>
&lt;td>匹配不包含^后的任意字符 a 或 b 或 c，是对[abc]的取反，且与^含义不同&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>[\s\S]&lt;/td>
&lt;td>匹配所有。\s 匹配所有空白符。\S 匹配所有非空白符，包括换行&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>[[:space:]]&lt;/td>
&lt;td>匹配空白字符&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>[^[:space:]]&lt;/td>
&lt;td>匹配非空白字符&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h2 id="特殊符号">特殊符号&lt;/h2>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>符号&lt;/th>
&lt;th>详解&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>\&lt;/td>
&lt;td>&lt;strong>escape character(转义字符)&lt;/strong>,让有特殊含义的字符脱掉马甲,不执行该特殊字符所代表的含义,如\.只表示小数点,不代表任意一个字符&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h2 id="元字符序列">元字符序列&lt;/h2>
&lt;p>| 元字符 | &lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th> &lt;/th>
&lt;th>示例&lt;/th>
&lt;th>&lt;/th>
&lt;th>&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;td>/a&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>a or b, pick one!&lt;/td>
&lt;td>表示“或”，即匹配其中任何一个，”book&lt;/td>
&lt;td>desk”将匹配”book”或”desk”&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>()&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;td>小括号，可以将正则字符和元字符或表达式进行组合，”(book&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>-&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;td>减号，用于指明字符范围， “[a-c]”将匹配包含 a、b 和 c 中任意一个字符的字符串&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>(..(..)..)(..)..\#&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;td>#为任意数字,该字符表示匹配前面的第#个小括号组中的内容。正则表达式中的小括号&amp;rdquo;()&amp;ldquo;是代表分组的意思。 如果再其后面出现\1 则是代表引用第一个小括号中匹配的内容。注意：\1 必须与小括号配合使用&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>\#例子&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;td>(li)#\1 表示查找 li#li 这个内容&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;td>(li(chen))#\1\2 表示引用 lichen#lichenchen,注:括号顺序以左括号为准&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h2 id="子组结构">子组结构&lt;/h2>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>符号&lt;/th>
&lt;th>描述&lt;/th>
&lt;th>示例&lt;/th>
&lt;th>详解&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>(?!&amp;hellip;)&lt;/td>
&lt;td>正向否定零宽断言&lt;/td>
&lt;td>/foo(?!bar)/&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>foobar foobaz&lt;/td>
&lt;td>子表达式不可在此后成功匹配的位置，不占用字符。&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>(?=)&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>&lt;strong>表达式&lt;/strong>&lt;/th>
&lt;th>&lt;strong>描述&lt;/strong>&lt;/th>
&lt;th>&lt;/th>
&lt;th>&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>(?=)&lt;/td>
&lt;td>正向预查。比如 Code(?=Sheep)能匹配 CodeSheep 中的 Code，但不能匹配 CodePig 中的 Code。&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>(?!)&lt;/td>
&lt;td>正向否定预查。比如 Code(?!Sheep)不能匹配 CodeSheep 中的 Code，但能匹配 CodePig 中的 Code。&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>(?&amp;lt;=)&lt;/td>
&lt;td>反向预查。比如(?&amp;lt;=Code)Sheep 能匹配 CodeSheep 中的 Sheep，但不能匹配 ReadSheep 中的 Sheep。&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>(?&amp;lt;!)&lt;/td>
&lt;td>反向否定预查。比如(?&amp;lt;!Code)Sheep 不能匹配 CodeSheep 中的 Sheep，但能匹配 ReadSheep 中的 Sheep。&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>基本和扩展正则表达式具体区别见下图，扩展中的元字符如果用在基本正则表达式中，需要在每个元字符前面加转义符&amp;lt;br /&amp;gt;&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/gpte3g/1616130197884-a0718c40-7e61-429d-9f4b-fe45a665d0d7.jpeg" alt="">&lt;/p>
&lt;h1 id="示例">示例&lt;/h1>
&lt;p>空行&lt;/p>
&lt;ul>
&lt;li>&lt;strong>^(\s*)\n&lt;/strong>&lt;/li>
&lt;/ul>
&lt;p>行尾的空字符串&lt;/p>
&lt;ul>
&lt;li>&lt;strong>\s+$&lt;/strong>&lt;/li>
&lt;/ul>
&lt;p>匹配所有 IPv4 地址&lt;/p>
&lt;ul>
&lt;li>&lt;strong>(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)(.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}&lt;/strong>&lt;/li>
&lt;/ul>
&lt;p>所有开头不是 &lt;code># HELP&lt;/code> 的行，以及行尾的换行符&lt;/p>
&lt;ul>
&lt;li>&lt;strong>^(?!# HELP).*\n&lt;/strong>&lt;/li>
&lt;/ul>
&lt;p>从 hosts 文件中筛选出指定的域名&lt;/p>
&lt;ul>
&lt;li>去掉除所有 IP 地址
&lt;ul>
&lt;li>**(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)(.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3} **&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>方向匹配开头是 optical-admin 的所有行之后。即匹配开头不是 optical-admin 的行
&lt;ul>
&lt;li>&lt;strong>^(?!optical-admin).*\n&lt;/strong>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>匹配所有汉字或空白字符&lt;/p>
&lt;ul>
&lt;li>[\u4e00-\u9fa5 | \u00a0]&lt;/li>
&lt;/ul>
&lt;h1 id="通配符">通配符&lt;/h1>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>通配符&lt;/th>
&lt;th>含义&lt;/th>
&lt;th>实例&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>*&lt;/td>
&lt;td>匹配 0 或多个字符&lt;/td>
&lt;td>a*b a 与 b 之间可以有任意长度的任意字符, 也可以一个也没有, 如 aabcb, axyzb, a012b, ab。&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>?&lt;/td>
&lt;td>匹配任意一个字符&lt;/td>
&lt;td>a?b a 与 b 之间必须也只能有一个字符, 可以是任意字符, 如 aab, abb, acb, a0b。&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>[list]&lt;/td>
&lt;td>匹配 list 中的任意单一字符&lt;/td>
&lt;td>a[xyz]b a 与 b 之间必须也只能有一个字符, 但只能是 x 或 y 或 z, 如: axb, ayb, azb。&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>[!list]或[^list]&lt;/td>
&lt;td>匹配 除 list 中的任意单一字符&lt;/td>
&lt;td>a[!0-9]b a 与 b 之间必须也只能有一个字符, 但不能是阿拉伯数字, 如 axb, aab, a-b。&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>[c1-c2]&lt;/td>
&lt;td>匹配 c1-c2 中的任意单一字符 如：[0-9] [a-z]&lt;/td>
&lt;td>a[0-9]b 0 与 9 之间必须也只能有一个字符 如 a0b, a1b&amp;hellip; a9b。&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>[!c1-c2]或[^c1-c2]&lt;/td>
&lt;td>匹配不在 c1-c2 的任意字符&lt;/td>
&lt;td>a[!0-9]b 如 acb adb&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>{string1,string2,&amp;hellip;}&lt;/td>
&lt;td>匹配 sring1 或 string2 (或更多)其一字符串&lt;/td>
&lt;td>a{abc,xyz,123}b 列出 aabcb,axyzb,a123b&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table></description></item><item><title>Docs: RocketMQ</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/8.%E9%80%9A%E7%94%A8%E6%8A%80%E6%9C%AF/message-queue%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/rocketmq/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/8.%E9%80%9A%E7%94%A8%E6%8A%80%E6%9C%AF/message-queue%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/rocketmq/</guid><description/></item><item><title>Docs: Service Discovery(服务发现)</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/8.%E9%80%9A%E7%94%A8%E6%8A%80%E6%9C%AF/service-discovery%E6%9C%8D%E5%8A%A1%E5%8F%91%E7%8E%B0/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/8.%E9%80%9A%E7%94%A8%E6%8A%80%E6%9C%AF/service-discovery%E6%9C%8D%E5%8A%A1%E5%8F%91%E7%8E%B0/</guid><description>
&lt;h1 id="nacos">Nacos&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://nacos.io/zh-cn/index.html">官网&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://nacos.io/zh-cn/docs/what-is-nacos.html">官方文档&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://github.com/nacos-group/nacos-k8s">部署文档&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>发现、配置和管理微服务
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/dwwdty/1621820962410-022fd4d3-3f5a-45eb-8b5c-5f176dd11adf.png" alt="image.png">&lt;/p></description></item><item><title>Docs: Timestamps(时间戳)</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/8.%E9%80%9A%E7%94%A8%E6%8A%80%E6%9C%AF/timestamps%E6%97%B6%E9%97%B4%E6%88%B3/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/8.%E9%80%9A%E7%94%A8%E6%8A%80%E6%9C%AF/timestamps%E6%97%B6%E9%97%B4%E6%88%B3/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;a href="https://tools.ietf.org/html/rfc3339">RFC 3339&lt;/a>、&lt;a href="https://www.bejson.com/convert/unix/">时间戳在线转换&lt;/a>&lt;/p>
&lt;/blockquote>
&lt;p>&lt;a href="https://baike.baidu.com/item/unix">https://baike.baidu.com/item/unix&lt;/a>时间戳&lt;/p>
&lt;p>&lt;a href="https://baike.baidu.com/item/2038">https://baike.baidu.com/item/2038&lt;/a>年问题&lt;/p>
&lt;p>时间戳转换工具，可以把浮点型的毫秒数字串转换成真实时间
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/vym7ql/1616165162261-f89b406f-0967-44d2-b496-baa6ebe57434.png" alt="">
时间戳有两种格式&lt;/p>
&lt;p>以秒为单位的当前 UNIX 时间戳 # 1562757107, 1562757108, 1562757109&lt;/p>
&lt;p>$timestamp&lt;/p>
&lt;p>ISO 格式(zero UTC)当前时间戳 # 2019-10-21T06:05:50.000Z&lt;/p>
&lt;p>$isoTimestamp&lt;/p>
&lt;p>Epoch Time&lt;/p>
&lt;p>**Unix 时间(Unix Time) **也叫做 **POSIX 时间 **或 &lt;strong>Epoch Time(纪元时间)&lt;/strong>，是用来记录时间的流逝，定义为从 UTC 时间 1970 年 1 月 1 日 00:00 开始流逝的秒数，不考虑闰秒。&lt;/p></description></item><item><title>Docs: UUID 与 ULID</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/8.%E9%80%9A%E7%94%A8%E6%8A%80%E6%9C%AF/uuid-%E4%B8%8E-ulid/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/8.%E9%80%9A%E7%94%A8%E6%8A%80%E6%9C%AF/uuid-%E4%B8%8E-ulid/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Universally_unique_identifier">Wiki,UUID&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://github.com/ulid/spec">GitHub,ULID&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;h2 id="uuid">UUID&lt;/h2>
&lt;p>&lt;strong>universally unique identifier(通用唯一标识符，简称 UUID)&lt;/strong> 是一个&lt;a href="https://en.wikipedia.org/wiki/128-bit">128 位的&lt;/a> &lt;a href="https://en.wikipedia.org/wiki/Nominal_number">标签&lt;/a>用于在计算机系统中的信息。还使用术语&lt;strong>全局唯一标识符&lt;/strong>( &lt;strong>GUID&lt;/strong> )，通常在&lt;a href="https://en.wikipedia.org/wiki/Microsoft">Microsoft&lt;/a>创建的软件中使用。&lt;a href="https://en.wikipedia.org/wiki/Universally_unique_identifier#cite_note-RFC_4122-1">[1]&lt;/a>
根据标准方法生成时，UUID 出于实用目的是唯一的。与大多数其他编号方案不同，它们的唯一性不依赖于中央注册机构或生成它们的各方之间的协调。虽然 UUID 被复制的&lt;a href="https://en.wikipedia.org/wiki/Probability">概率&lt;/a>不是零，但它足够接近零，可以忽略不计。&lt;a href="https://en.wikipedia.org/wiki/Universally_unique_identifier#cite_note-2">[2]&lt;/a>
因此，任何人都可以创建一个 UUID 并使用它来识别某些东西，几乎可以肯定的是，该标识符不会与已经或将要创建的标识符重复以识别其他东西。因此，独立方标有 UUID 的信息稍后可以合并到单个数据库中或在同一频道上传输，重复的可能性可以忽略不计。
UUID 的采用很普遍，许多计算平台为生成它们和解析它们的文本表示提供支持。&lt;/p>
&lt;h2 id="ulid">ULID&lt;/h2>
&lt;p>&lt;strong>Universally Unique Lexicographically Sortable Identifier(通用唯一的字典可排序标识符，简称 ULID)&lt;/strong>&lt;/p></description></item><item><title>Docs: 编码解码与协议</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/8.%E9%80%9A%E7%94%A8%E6%8A%80%E6%9C%AF/%E7%BC%96%E7%A0%81%E8%A7%A3%E7%A0%81%E4%B8%8E%E5%8D%8F%E8%AE%AE/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/8.%E9%80%9A%E7%94%A8%E6%8A%80%E6%9C%AF/%E7%BC%96%E7%A0%81%E8%A7%A3%E7%A0%81%E4%B8%8E%E5%8D%8F%E8%AE%AE/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Code">Wiki,Code&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>&lt;strong>Encoding(编码)&lt;/strong> 是信息从一种形式或格式,转换为另一种形式或格式的过程。而 &lt;strong>Decoding(解码)&lt;/strong> 则是编码的逆过程。&lt;/p>
&lt;p>首先需要明确一点，计算机的组件处理信息都是基于 &lt;strong>二进制&lt;/strong> 来实现的，也就是说。都是 0 和 1 这种信息，不管电路的一开一关，灯的一亮一灭，都可以用 0 和 1 来表示。而计算机也是通过 0 和 1 来存储以及处理数据的。&lt;/p>
&lt;p>&lt;strong>但是计算机在使用的时候，我们看到并不是只有 0 和 1，我们打字也不是只输入 0 和 1，不但有文字，还有图片、视频、音频等等。这是为什么呢？&lt;/strong>&lt;/p>
&lt;p>由于计算机只认识 0 和 1 这种二进制数据，其他格式的数据都需要转换成二进制才能被计算机处理，也就是说我们在计算机上看到的文本、视频、可执行程序等格式的文件，最终都会转换成二进制数据交给计算机处理；而计算机处理完成后，又会再次转换二进制数据为 文本、图片、视频 等格式，以便人类可以查看。这种来回转换的过程，就称为 &lt;strong>Encoding(编码)&lt;/strong> 与 &lt;strong>Decoding(解码)&lt;/strong>。而文字、图片、音/视频 等等数据，其编码方式又各不相同。&lt;/p>
&lt;ul>
&lt;li>字符编码 # 用来对文字进行 编/解码 的过程&lt;/li>
&lt;li>图形编码 # 对图片进行 编/解码 的过程&lt;/li>
&lt;li>音频编码 # 对音频进行 编/解码 的过程&lt;/li>
&lt;/ul>
&lt;p>当然，随着时代的发展，Encoding(编码) 与 Decoding(解码) 也不仅仅代指上述三种类型，就如概述中的第一句话，**任何格式的数据转换成另一种，都可以称之为 编码！**比如，Base64 编码，则是可以将二进制数据，转换为字符串数据，这种行为，也可以称之为编码。&lt;/p>
&lt;h2 id="编码解码与协议">编码解码与协议&lt;/h2>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://mp.weixin.qq.com/s/kfyTcs6xuDvlCX3U04Edng">公众号-码农的荒岛求生，神奇的 Google 二进制编解码技术：Protobuf&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>计算机网络编程中一个非常基本的问题：该怎样表示 client 与 server 之间交互的数据，在往下看之前先想一想这个问题。&lt;/p>
&lt;h3 id="共识与协议">共识与协议&lt;/h3>
&lt;p>这个问题可不像看上去的那样简单，因为 client 进程和 server 进程运行在不同的机器上，这些机器可能运行在不同的处理器平台、可能运行在不同的操作系统、可能是由不同的编程语言编写的，server 要怎样才能识别出 client 发送的是什么数据呢？就像这样：&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/rpxf9d/1663061154712-3689268d-a902-4892-93f8-6682f9329d0a.png" alt="">
client 给 server 发送了一段数据：
&lt;code>0101000100100001&lt;/code>
server 怎么能知道该怎样“解读”这段数据呢？&lt;/p>
&lt;p>显然，client 和 server 在发送数据之前必须首先达成某种关于怎样解读数据的共识，这就是所谓的&lt;strong>协议&lt;/strong>。&lt;/p>
&lt;p>这里的协议可以是这样的：“将每 8 个比特为一个单位解释为无符号数字”，如果协议是这样的，那么 server 接收到这串二进制后就会将其解析为 81(01010001)与 33(00100001)。&lt;/p>
&lt;p>当然，这里的协议也可以是这样的：“将每 8 个比特为一个单位解释为 ASCII 字符”，那么 server 接收到这串二进制后就将其解析为“Q!”。&lt;/p>
&lt;p>可见，同样一串二进制在不同的“上下文/协议”下有完全不一样的解读，&lt;strong>这也是为什么计算机明明只认知 0 和 1 但是却能处理非常复杂任务的根本原因，因为一切都可以编码为 0 和 1，同样的我们也可以从 0 和 1 中解析出我们想要的信息，这就是所谓的编解码技术。&lt;/strong>&lt;/p>
&lt;p>实际上不止 0 和 1，我们也可以将信息编码为摩斯密码(Morse code)等，只不过计算机擅长处理 0 和 1 而已。
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/rpxf9d/1663061154726-975db7c1-2b96-429d-a007-12706a83be5f.png" alt="">&lt;/p>
&lt;h1 id="字符编码">字符编码&lt;/h1>
&lt;p>详见：&lt;a href="https://desistdaydream.github.io/docs/IT%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/8.%E9%80%9A%E7%94%A8%E6%8A%80%E6%9C%AF/%E7%BC%96%E7%A0%81%E8%A7%A3%E7%A0%81%E4%B8%8E%E5%8D%8F%E8%AE%AE/%E5%AD%97%E7%AC%A6%E7%9A%84%E7%BC%96%E7%A0%81%E4%B8%8E%E8%A7%A3%E7%A0%81.md">字符的编码与解码&lt;/a>&lt;/p>
&lt;h1 id="图形编码">图形编码&lt;/h1>
&lt;p>详见：&lt;a href="https://desistdaydream.github.io/docs/IT%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/8.%E9%80%9A%E7%94%A8%E6%8A%80%E6%9C%AF/%E7%BC%96%E7%A0%81%E8%A7%A3%E7%A0%81%E4%B8%8E%E5%8D%8F%E8%AE%AE/%E5%9B%BE%E5%83%8F%E7%9A%84%E7%BC%96%E7%A0%81%E4%B8%8E%E8%A7%A3%E7%A0%81.md">图像的编码与解码&lt;/a>&lt;/p>
&lt;h1 id="音频编码">音频编码&lt;/h1>
&lt;p>详见：&lt;a href="https://desistdaydream.github.io/docs/IT%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/8.%E9%80%9A%E7%94%A8%E6%8A%80%E6%9C%AF/%E7%BC%96%E7%A0%81%E8%A7%A3%E7%A0%81%E4%B8%8E%E5%8D%8F%E8%AE%AE/%E9%9F%B3%E9%A2%91%E7%9A%84%E7%BC%96%E7%A0%81%E4%B8%8E%E8%A7%A3%E7%A0%81.md">音频的编码与解码&lt;/a>&lt;/p></description></item><item><title>Docs: 调度系统设计精要</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/8.%E9%80%9A%E7%94%A8%E6%8A%80%E6%9C%AF/%E8%B0%83%E5%BA%A6%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E7%B2%BE%E8%A6%81/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/8.%E9%80%9A%E7%94%A8%E6%8A%80%E6%9C%AF/%E8%B0%83%E5%BA%A6%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E7%B2%BE%E8%A6%81/</guid><description>
&lt;p>&lt;!-- raw HTML omitted -->&lt;!-- raw HTML omitted -->#2020-02-02 系统设计精要 系统设计 调度器 Linux Go Kubernetes 抢占式 协作式 工作窃取 NUMA&lt;/p>
&lt;blockquote>
&lt;p>系统设计精要是一系列深入研究系统设计方法的系列文章，文中不仅会分析系统设计的理论，还会分析多个实际场景下的具体实现。这是一个季更或者半年更的系列，如果你有想要了解的问题，可以在文章下面留言。
调度是一个非常广泛的概念，很多领域都会使用调度这个术语，在计算机科学中，调度就是一种将任务（Work）分配给资源的方法 1。任务可能是虚拟的计算任务，例如线程、进程或者数据流，这些任务会被调度到硬件资源上执行，例如：处理器 CPU 等设备。&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/zk3f35/1616130171841-d584896c-0ff4-4139-93c3-624d3a27e67e.png" alt="">&lt;strong>图 2 - 文章脉络和内容&lt;/strong>除了介绍调度系统设计时会遇到的常见问题之外，本文还会深入分析几种常见的调度器的设计、演进与实现原理，包括操作系统的进程调度器，Go 语言的运行时调度器以及 Kubernetes 的工作负载调度器，帮助我们理解调度器设计的核心原理。
&lt;!-- raw HTML omitted -->&lt;!-- raw HTML omitted -->## 设计原理
调度系统其实就是调度器（Scheduler），我们在很多系统中都能见到调度器的身影，就像我们在上面说的，不止操作系统中存在调度器，编程语言、容器编排以及很多业务系统中都会存在调度系统或者调度模块。这些调度模块的核心作用就是对有限的资源进行分配以实现最大化资源的利用率或者降低系统的尾延迟，调度系统面对的就是&lt;strong>资源的需求和供给不平衡&lt;/strong>的问题。&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/zk3f35/1616130171809-04cdba28-749a-43b6-88c3-7b228d22e575.png" alt="">&lt;strong>图 3 - 调度器的任务和资源&lt;/strong>我们在这一节中将从多个方面介绍调度系统设计时需要重点考虑的问题，其中包括调度系统的需求调研、调度原理以及架构设计。
&lt;!-- raw HTML omitted -->&lt;!-- raw HTML omitted -->### 需求调研
在着手构建调度系统之前，首要的工作就是进行详细的需求调研和分析，在这个过程中需要完成以下两件事：&lt;/p>
&lt;/blockquote>
&lt;ul>
&lt;li>
&lt;p>调研调度系统的应用场景，深入研究场景中待执行的任务（Work）和能用来执行任务的资源（Resource）的特性；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>分析调度系统的目的，可能是成本优先、质量优先、最大化资源的利用率等，调度目的一般都是动态的，会随着需求的变化而转变；&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>应用场景调度系统应用的场景是我们首先需要考虑的问题，对应用场景的分析至关重要，我们需要深入了解当前场景下待执行任务和能用来执行任务的资源的特点。我们需要分析待执行任务的以下特征：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>任务是否有截止日期，必须在某个时间点之前完成；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>任务是否支持抢占，抢占的具体规则是什么；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>任务是否包含前置的依赖条件；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>任务是否只能在指定的资源上运行；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>…&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>而用于执行任务的资源也可能存在资源不平衡，不同资源处理任务的速度不一致的问题。资源和任务特点的多样性决定了调度系统的设计，我们在这里举几个简单的例子帮助各位读者理解调度系统需求分析的过程。&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/zk3f35/1616130171821-feaa3816-5c1a-40c7-aad2-357446cc70cb.jpeg" alt="">&lt;strong>图 4 - Linux 操作系统&lt;/strong>在操作系统的进程调度器（Process Scheduler）中，待调度的任务就是线程，这些任务一般只会处于正在执行或者未执行（等待或者终止）的状态；而用于处理这些任务的 CPU 往往都是不可再分的，同一个 CPU 在同一时间只能执行一个任务，这是物理上的限制。简单总结一下，操作系统调度器的任务和资源有以下特性：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>任务 —— Thread&lt;/p>
&lt;/li>
&lt;li>
&lt;p>状态简单：只会处于正在执行或者未被执行两种状态；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>优先级不同：待执行的任务可能有不同的优先级，在考虑优先级的情况下，需要保证不同任务的公平性；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>资源 —— CPU 时间&lt;/p>
&lt;/li>
&lt;li>
&lt;p>资源不可再分：同一时间只能运行一个任务；&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>在上述场景中，待执行的任务是操作系统调度的基本单位 —— 线程，而可分配的资源是 CPU 的时间。Go 语言的调度器与操作系统的调度器面对的是几乎相同的场景，其中的任务是 Goroutine，可以分配的资源是在 CPU 上运行的线程。&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/zk3f35/1616130171836-b70334ff-4b79-4d70-af74-79d6d4871db9.png" alt="">&lt;strong>图 5 - 容器编排系统 Kubernetes&lt;/strong>除了操作系统和编程语言这种较为底层的调度器之外，容器和计算任务调度在今天也很常见，Kubernetes 作为容器编排系统会负责调取集群中的容器，对它稍有了解的人都知道，Kubernetes 中调度的基本单元是 Pod，这些 Pod 会被调度到节点 Node 上执行：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>任务 —— Pod&lt;/p>
&lt;/li>
&lt;li>
&lt;p>优先级不同：Pod 的优先级可能不同，高优先级的系统 Pod 可以抢占低优先级 Pod 的资源；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>有状态：Pod 可以分为无状态和有状态，有状态的 Pod 需要依赖持久存储卷；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>资源 —— Node&lt;/p>
&lt;/li>
&lt;li>
&lt;p>类型不同：不同节点上的资源类型不同，包括 CPU、GPU 和内存等，这些资源可以被拆分但是都属于当前节点；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>不稳定：节点可能由于突发原因不可用，例如：无网络连接、磁盘损坏等；&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>调度系统在生活和工作中都很常见，除了上述的两个场景之外，其他需要调度系统的场景包括 CDN 的资源调度、订单调度以及离线任务调度系统等。在不同场景中，我们都需要深入思考任务和资源的特性，它们对系统的设计起者指导作用。调度目的在深入分析调度场景后，我们需要理解调度的目的。我们可以将调度目的理解成机器学习中的成本函数（Cost function），确定调度目的就是确定成本函数的定义，调度理论一书中曾经介绍过常见的调度目的包含以下的内容 2：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>完成跨度（Makesapan） — 第一个到最后一个任务完成调度的时间跨度；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>最大延迟（Maximum Lateness） — 超过截止时间最长的任务；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>加权完成时间的和（Total weighted completion time）— 权重乘完成时间的总和；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>…&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>这些都是偏理论的调度的目的，多数业务调度系统的调度目的都是优化与业务联系紧密的指标 — 成本和质量。如何在成本和质量之间达到平衡是需要仔细思考和设计的，由于篇幅所限以及业务场景的复杂，本文不会分析如何权衡成本和质量，这往往都是需要结合业务考虑的事情，不具有足够的相似性。
&lt;!-- raw HTML omitted -->&lt;!-- raw HTML omitted -->### 调度原理
性能优异的调度器是实现特定调度目的前提，我们在讨论调度场景和目的时往往都会忽略调度的额外开销，然而调度器执行时的延时和吞吐量等指标在调度负载较重时是不可忽视的。本节会分析与调度器实现相关的一些重要概念，这些概念能够帮助我们实现高性能的调度器：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>协作式调度与抢占式调度；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>单调度器与多调度器；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>任务分享与任务窃取；&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>协作式与抢占式协作式（Cooperative）与抢占式（Preemptive）调度是操作系统中常见的多任务运行策略。这两种调度方法的定义完全不同：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>协作式调度允许任务执行任意长的时间，直到&lt;strong>任务主动通知调度器&lt;/strong>让出资源；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>抢占式调度允许任务在执行过程中被调度器挂起，&lt;strong>调度器会重新决定&lt;/strong>下一个运行的任务；&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/zk3f35/1616130171887-5cbe3c78-2085-4f3c-9799-d009ceebf507.png" alt="">&lt;strong>图 12 - 工作窃取调度器&lt;/strong>这两种任务再分配的策略都为系统增加了额外的开销，与工作分享相比，工作窃取只会在当前调度器的资源没有被充分利用时才会触发，所以工作窃取引入的额外开销更小。工作窃取在生产环境中更加常用，Linux 操作系统和 Go 语言都选择了工作窃取策略。
&lt;!-- raw HTML omitted -->&lt;!-- raw HTML omitted -->### 架构设计
本节将从调度器内部和外部两个角度分析调度器的架构设计，前者分析调度器内部多个组件的关系和做出调度决策的过程；后者分析多个调度器应该如何协作，是否有其他的外部服务可以辅助调度器做出更合理的调度决策。调度器内部当调度器收到待调度任务时，会根据采集到的状态和待调度任务的规格（Spec）做出合理的调度决策，我们可以从下图中了解常见调度系统的内部逻辑。&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/zk3f35/1616130171918-afbbd94a-16d4-44ee-9fdb-dd09f9808f9c.png" alt="">&lt;strong>图 13 - 调度器做出调度决策&lt;/strong>常见的调度器一般由两部分组成 — 用于收集状态的状态模块和负责做决策的决策模块。状态模块状态模块会从不同途径收集尽可能多的信息为调度提供丰富的上下文，其中可能包括资源的属性、利用率和可用性等信息。根据场景的不同，上下文可能需要存储在 MySQL 等持久存储中，一般也会在内存中缓存一份以减少调度器访问上下文的开销。决策模块决策模块会根据状态模块收集的上下文和任务的规格做出调度决策，需要注意的是做出的&lt;strong>调度决策只是在当下有效&lt;/strong>，在未来某个时间点，状态的改变可能会导致之前做的决策不符合任务的需求，例如：当我们使用 Kubernetes 调度器将工作负载调度到某些节点上，这些节点可能由于网络问题突然不可用，该节点上的工作负载也就不能正常工作，即调度决策失效。调度器在调度时都会通过以下的三个步骤为任务调度合适的资源：&lt;/p>
&lt;ol>
&lt;li>
&lt;p>通过优先级、任务创建时间等信息确定不同任务的调度顺序；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>通过过滤和打分两个阶段为任务选择合适的资源；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>不存在满足条件的资源时，选择牺牲的抢占对象；&lt;/p>
&lt;/li>
&lt;/ol>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/zk3f35/1616130171914-9da35c11-ddbf-40bd-9d25-d5e114e9ba91.png" alt="">&lt;strong>图 15 - 调度器与反调度器&lt;/strong>反调度器的引入使得整个调度系统变得更加健壮。调度器负责根据当前的状态做出正确的调度决策，反调度器根据当前的状态移除错误的调度决策，它们的作用看起来相反，但是目的都是为任务调度更合适的资源。反调度器的使用没有那么广泛，实际的应用场景也比较有限。作者第一次发现这个概念是在 Kubernetes 孵化的 descheduler 项目 4 中，不过因为反调度器移除调度关系可能会影响正在运行的线上服务，所以 Kubernetes 也只会在特定场景下使用。
&lt;!-- raw HTML omitted -->&lt;!-- raw HTML omitted -->## 操作系统
调度器是操作系统中的重要组件，操作系统中有进程调度器（Process Scheduler）、网络调度器（Network Scheduler）和 I/O 调度器（I/O Scheduler）等组件，本节介绍的是操作系统中的进程调度器。有一些读者可能会感到困惑，操作系统调度的最小单位不是线程么，为什么这里使用的是进程调度。在 Linux 操作系统中，调度器调度的不是进程也不是线程，它调度的是 &lt;code>task_struct&lt;/code> 结构体，该结构体既可以表示线程，也可以表示进程，而调度器会将进程和线程都看成任务，我们在这里先说明这一问题，避免读者感到困惑 5。我们会使用进程调度器这个术语，但是一定要注意 Linux 调度器中并不区分线程和进程。&lt;/p>
&lt;blockquote>
&lt;p>Linux incorporates process and thread scheduling by treating them as one in the same. A process can be viewed as a single thread, but a process can contain multiple threads that share some number of resources (code and/or data).
接下来，本节会研究操作系统中调度系统的类型以及 Linux 进程调度器的演进过程。
&lt;!-- raw HTML omitted -->&lt;!-- raw HTML omitted -->### 调度系统类型
操作系统会将进程调度器分成三种不同的类型，即长期调度器、中期调度器和短期调度器。这三种不同类型的调度器分别提供了不同的功能，我们将在这一节中依次介绍它们。长期调度器长期调度器（Long-Term Scheduler）也被称作任务调度器（Job Scheduler），它能够决定哪些任务会进入调度器的准备队列。当我们尝试执行新的程序时，长期调度器会负责授权或者延迟该程序的执行。长期调度器的作用是平衡同时正在运行的 I/O 密集型或者 CPU 密集型进程的任务数量：&lt;/p>
&lt;/blockquote>
&lt;ul>
&lt;li>
&lt;p>如果 I/O 密集型任务过多，就绪队列中就不存在待调度的任务，短期调度器不需要执行调度，CPU 资源就会面临闲置；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>如果 CPU 密集型任务过多，I/O 等待队列中就不存在待调度的任务，I/O 设备就会面临闲置；&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>长期调度器能平衡同时正在运行的 I/O 密集型和 CPU 密集型任务，最大化的利用操作系统的 I/O 和 CPU 资源。中期调度器中期调度器会将不活跃的、低优先级的、发生大量页错误的或者占用大量内存的进程从内存中移除，为其他的进程释放资源。&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/zk3f35/1616130171904-1df9d120-973a-4bd3-af89-26d4eb375746.png" alt="">&lt;strong>图 16 - 中期调度器&lt;/strong>当正在运行的进程陷入 I/O 操作时，该进程只会占用计算资源，在这种情况下，中期调度器就会将它从内存中移除等待 I/O 操作完成后，该进程会重新加入就绪队列并等待短期调度器的调度。短期调度器短期调度器应该是我们最熟悉的调度器，它会从就绪队列中选出一个进程执行。进程的选择会使用特定的调度算法，它会同时考虑进程的优先级、入队时间等特征。因为每个进程能够得到的执行时间有限，所以短期调度器的执行十分频繁。
&lt;!-- raw HTML omitted -->&lt;!-- raw HTML omitted -->### 设计与演进
本节将重点介绍 Linux 的 CPU 调度器，也就是短期调度器。Linux 的 CPU 调度器并不是从设计之初就是像今天这样复杂的，在很长的一段时间里（v0.01 ~ v2.4），Linux 的进程调度都由几十行的简单函数负责，我们先了解一下不同版本调度器的历史：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>初始调度器 · v0.01 ~ v2.4&lt;/p>
&lt;/li>
&lt;li>
&lt;p>由几十行代码实现，功能非常简陋；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>同时最多处理 64 个任务；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>O(n)O(n) 调度器 · v2.4 ~ v2.6&lt;/p>
&lt;/li>
&lt;li>
&lt;p>调度时需要遍历全部任务；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>当待执行的任务较多时，同一个任务两次执行的间隔很长，会有比较严重的饥饿问题；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>O(1)O(1) 调度器 · v2.6.0 ~ v2.6.22&lt;/p>
&lt;/li>
&lt;li>
&lt;p>通过引入运行队列和优先数组实现 O(1)O(1) 的时间复杂度;&lt;/p>
&lt;/li>
&lt;li>
&lt;p>使用本地运行队列替代全局运行队列增强在对称多处理器的扩展性；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>引入工作窃取保证多个运行队列中任务的平衡；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>完全公平调度器 · v2.6.23 ~ 至今&lt;/p>
&lt;/li>
&lt;li>
&lt;p>引入红黑树和运行时间保证调度的公平性；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>引入调度类实现不同任务类型的不同调度策略；&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>这里会详细介绍从最初的调度器到今天复杂的完全公平调度器（Completely Fair Scheduler，CFS）的演变过程。初始调度器 Linux 最初的进程调度器仅由 &lt;code>sched.h&lt;/code> 和 &lt;code>sched.c&lt;/code> 两个文件构成。你可能很难想象 Linux 早期版本使用只有几十行的 &lt;code>schedule&lt;/code> 函数负责了操作系统进程的调度 6：
void schedule(void) {
int i,next,c;
struct task_struct ** p;
for(p = &amp;amp;LAST_TASK ; p &amp;gt; &amp;amp;FIRST_TASK ; &amp;ndash;p) {
&amp;hellip;
}
while (1) {
c = -1;
next = 0;
i = NR_TASKS;
p = &amp;amp;task[NR_TASKS];
while (&amp;ndash;i) {
if (!*&amp;ndash;p) continue;
if ((*p)-&amp;gt;state == TASK_RUNNING &amp;amp;&amp;amp; (*p)-&amp;gt;counter &amp;gt; c)
c = (*p)-&amp;gt;counter, next = i;
}
if (c) break;
for(p = &amp;amp;LAST_TASK ; p &amp;gt; &amp;amp;FIRST_TASK ; &amp;ndash;p)
if (*p)
(*p)-&amp;gt;counter = ((*p)-&amp;gt;counter &amp;raquo; 1) + (*p)-&amp;gt;priority;
}
switch_to(next);
}1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
C 无论是进程还是线程，在 Linux 中都被看做是 &lt;code>task_struct&lt;/code> 结构体，所有的调度进程都存储在上限仅为 64 的数组中，调度器能够处理的进程上限也只有 64 个。&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/zk3f35/1616130171909-f8c152dc-e326-4f7b-9304-f783e3b4d5cb.png" alt="">**图 17 - 最初的进程调度器**上述函数会先唤醒获得信号的可中断进程，然后从队列倒序查找计数器 &lt;code>counter&lt;/code> 最大的可执行进程，&lt;code>counter&lt;/code> 是进程能够占用的时间切片数量，该函数会根据时间切片的值执行不同的逻辑：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>如果最大的 &lt;code>counter&lt;/code> 时间切片大于 0，调用汇编语言的实现的 &lt;code>switch_to&lt;/code> 切换进程；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>如果最大的 &lt;code>counter&lt;/code> 时间切片等于 0，意味着所有进程的可执行时间都为 0，那么所有进程都会获得新的时间切片；&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>Linux 操作系统的计时器会每隔 10ms 触发一次 &lt;code>do_timer&lt;/code> 将当前正在运行进程的 &lt;code>counter&lt;/code> 减一，当前进程的计数器归零时就会重新触发调度。O(n) 调度器 O(n)O(n) 调度器是 Linux 在 v2.4 ~ v2.6 版本使用的调度器，由于该调取器在最坏的情况下会遍历所有的任务，所以它调度任务的时间复杂度就是 O(n)O(n)。Linux 调度算法将 CPU 时间分割成了不同的时期（Epoch），也就是每个任务能够使用的时间切片。我们可以在 &lt;code>sched.h&lt;/code> 和 &lt;code>sched.c&lt;/code> 两个文件中找到 O(n)O(n) 调度器的源代码。与上一个版本的调度器相比，O(n)O(n) 调度器的实现复杂了很多，该调度器会在 &lt;code>schedule&lt;/code> 函数中遍历运行队列中的所有任务并调用 &lt;code>goodness&lt;/code> 函数分别计算它们的权重获得下一个运行的进程 7：
asmlinkage void schedule(void)
{
&amp;hellip;
still_running_back:
list_for_each(tmp, &amp;amp;runqueue_head) {
p = list_entry(tmp, struct task_struct, run_list);
if (can_schedule(p, this_cpu)) {
int weight = goodness(p, this_cpu, prev-&amp;gt;active_mm);
if (weight &amp;gt; c)
c = weight, next = p;
}
}
&amp;hellip;
}1
2
3
4
5
6
7
8
9
10
11
12
13
14
Go 在每个时期开始时，上述代码都会为所有的任务计算时间切片，因为需要执行 n 次，所以调度器被称作 O(n)O(n) 调度器。在默认情况下，每个任务在一个周期都会分配到 200ms 左右的时间切片，然而这种调度和分配方式是 O(n)O(n) 调度器的最大问题：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>每轮调度完成之后就会陷入没有任务需要调度的情况，需要提升交互性能的场景会受到严重影响，例如：在桌面拖动鼠标会感觉到明显的卡顿；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>每次查找权重最高的任务都需要遍历数组中的全部任务；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>调度器分配的平均时间片大小为 210ms8，当程序中包含 100 个进程时，同一个进程被运行两次的间隔是 21s，这严重影响了操作系统的可用性；&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>正是因为 O(n)O(n) 调度器存在了上述的问题，所以 Linux 内核在两个版本后使用新的 O(1)O(1) 调度器替换该实现。O(1) 调度器 O(1)O(1) 调度器在 v2.6.0 到 v2.6.22 的 Linux 内核中使用了四年的时间，它能够在常数时间内完成进程调度，你可以在 &lt;code>sched.h&lt;/code> 和 &lt;code>sched.c&lt;/code> 中查看 O(1)O(1) 调度器的源代码。因为实现和功能复杂性的增加，调度器的代码行数从 O(n)O(n) 的 2100 行增加到 5000 行，它在 O(n)O(n) 调度器的基础上进行了如下的改进 9：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>调度器支持了 O(1)O(1) 时间复杂度的调度；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>调度器支持了对称多处理（Symmetric multiprocessing，SMP）的扩展性；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>调度器优化了对称多处理的亲和性；&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>数据结构调度器通过运行队列 &lt;code>runqueue&lt;/code> 和优先数组 &lt;code>prio_array&lt;/code> 两个重要的数据结构实现了 O(1)O(1) 的时间复杂度。每一个运行队列都持有两个优先数组，分别存储活跃的和过期的进程数组：
struct runqueue {
&amp;hellip;
prio_array_t *active, *expired, arrays[2];
&amp;hellip;
}
struct prio_array {
unsigned int nr_active;
unsigned long bitmap[BITMAP_SIZE];
struct list_head queue[MAX_PRIO];
};1
2
3
4
5
6
7
8
9
10
11
C 优先数组中的 &lt;code>nr_active&lt;/code> 表示活跃的进程数，而 &lt;code>bitmap&lt;/code> 和 &lt;code>list_head&lt;/code> 共同组成了如下图所示的数据结构：&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/zk3f35/1616130171912-c7da8bae-d99c-471a-bb69-3ca3febeaa56.png" alt="">&lt;strong>图 18 - 优先数组&lt;/strong>优先数组的 &lt;code>bitmap&lt;/code> 总共包含 140 位，每一位都表示对应优先级的进程是否存在。图 17 中的优先数组包含 3 个优先级为 2 的进程和 1 个优先级为 5 的进程。每一个优先级的标志位都对应一个 &lt;code>list_head&lt;/code> 数组中的链表。O(1)O(1) 调度器使用上述的数据结构进行如下所示的调度：&lt;/p>
&lt;ol>
&lt;li>
&lt;p>调用 &lt;code>sched_find_first_bit&lt;/code> 按照优先级分配 CPU 资源；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>调用 &lt;code>schedule&lt;/code> 从链表头选择进程执行；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>通过 &lt;code>schedule&lt;/code> 轮询调度同一优先级的进程，该函数在每次选中待执行的进程后，将进程添加到队列的末尾，这样可以保证同一优先级的进程会依次执行（Round-Robin）；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>计时器每隔 1ms 会触发一次 &lt;code>scheduler_tick&lt;/code> 函数，如果当前进程的执行时间已经耗尽，就会将其移入过期数组；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>当活跃队列中不存在待运行的进程时，&lt;code>schedule&lt;/code> 会交换活跃优先数组和过期优先数组；&lt;/p>
&lt;/li>
&lt;/ol>
&lt;p>上述的这些规则是 O(1)O(1) 调度器运行遵守的主要规则，除了上述规则之外，调度器还需要支持抢占、CPU 亲和等功能，不过在这里就不展开介绍了。本地运行队列全局的运行队列是 O(n)O(n) 调度器难以在对称多处理器架构上扩展的主要原因。为了保证运行队列的一致性，调度器在调度时需要获取运行队列的全局锁，随着处理器数量的增加，多个处理器在调度时会导致更多的锁竞争，严重影响调度性能。O(1)O(1) 调度器通过引入本地运行队列解决这个问题，不同的 CPU 可以通过 &lt;code>this_rq&lt;/code> 获取绑定在当前 CPU 上的运行队列，降低了锁的粒度和冲突的可能性。
#define this_rq() (&amp;amp;__get_cpu_var(runqueues))1
C&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/zk3f35/1616130171909-b5e4678f-a40d-482c-b5ca-37e308989ab2.png" alt="">&lt;strong>图 19 - 全局运行队列和本地运行队列&lt;/strong>多个处理器由于不再需要共享全局的运行队列，所以增强了在对称对处理器架构上的扩展性，当我们增加新的处理器时，只需要增加新的运行队列，这种方式不会引入更多的锁冲突。优先级和时间切片调度器中包含两种不同的优先级计算方式，一种是静态任务优先级，另一种是动态任务优先级。在默认情况下，任务的静态任务优先级都是 0，不过我们可以通过系统调用 &lt;code>nice&lt;/code> 改变任务的优先级；O(1)O(1) 调度器会奖励 I/O 密集型任务并惩罚 CPU 密集型任务，它会通过改变任务的静态优先级来完成优先级的动态调整，因为与用户交互的进程时 I/O 密集型的进程，这些进程由于调度器的动态策略会提高自身的优先级，从而提升用户体验。完全公平调度器完全公平调度器（Completely Fair Scheduler，CFS）是 v2.6.23 版本被合入内核的调度器，也是内核的默认进程调度器，它的目的是最大化 CPU 利用率和交互的性能 10。Linux 内核版本 v2.6.23 中的 CFS 由以下的多个文件组成：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>include/linux/sched.h&lt;/p>
&lt;/li>
&lt;li>
&lt;p>kernel/sched_stats.h&lt;/p>
&lt;/li>
&lt;li>
&lt;p>kernel/sched.c&lt;/p>
&lt;/li>
&lt;li>
&lt;p>kernel/sched_fair.c&lt;/p>
&lt;/li>
&lt;li>
&lt;p>kernel/sched_idletask.c&lt;/p>
&lt;/li>
&lt;li>
&lt;p>kernel/sched_rt.c&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>通过 CFS 的名字我们就能发现，该调度器的能为不同的进程提供完全公平性。一旦某些进程受到了不公平的待遇，调度器就会运行这些进程，从而维持所有进程运行时间的公平性。这种保证公平性的方式与『水多了加面，面多了加水』有一些相似：&lt;/p>
&lt;ol>
&lt;li>
&lt;p>调度器会查找运行队列中受到最不公平待遇的进程，并为进程分配计算资源，分配的计算资源是与其他资源运行时间的差值加上最小能够运行的时间单位；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>进程运行结束之后发现运行队列中又有了其他的进程受到了最不公平的待遇，调度器又会运行新的进程；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>…&lt;/p>
&lt;/li>
&lt;/ol>
&lt;p>调度器算法不断计算各个进程的运行时间并依次调度队列中的受到最不公平对待的进程，保证各个进程的运行时间差不会大于最小运行的时间单位。数据结构虽然我们还是会延用运行队列这一术语，但是 CFS 的内部已经不再使用队列来存储进程了，&lt;code>cfs_rq&lt;/code> 是用来管理待运行进程的新结构体，该结构体会使用红黑树（Red-black tree）替代链表：
struct cfs_rq {
struct load_weight load;
unsigned long nr_running;
s64 fair_clock;
u64 exec_clock;
s64 wait_runtime;
u64 sleeper_bonus;
unsigned long wait_runtime_overruns, wait_runtime_underruns;
struct rb_root tasks_timeline;
struct rb_node *rb_leftmost;
struct rb_node *rb_load_balance_curr;
struct sched_entity *curr;
struct rq *rq;
struct list_head leaf_cfs_rq_list;
};1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
C 红黑树（Red-black tree）是平衡的二叉搜索树 11，红黑树的增删改查操作的最坏时间复杂度为 O(logn)O(log⁡n)，也就是树的高度，树中最左侧的节点 &lt;code>rb_leftmost&lt;/code> 运行的时间最短，也是下一个待运行的进程。&lt;/p>
&lt;blockquote>
&lt;p>注：在最新版本的 CFS 实现中，内核使用虚拟运行时间 vruntime 替代了等待时间，但是基本的调度原理和排序方式没有太多变化。
调度过程 CFS 的调度过程还是由 schedule 函数完成的，该函数的执行过程可以分成以下几个步骤：&lt;/p>
&lt;/blockquote>
&lt;ol>
&lt;li>
&lt;p>关闭当前 CPU 的抢占功能；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>如果当前 CPU 的运行队列中不存在任务，调用 &lt;code>idle_balance&lt;/code> 从其他 CPU 的运行队列中取一部分执行；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>调用 &lt;code>pick_next_task&lt;/code> 选择红黑树中优先级最高的任务；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>调用 &lt;code>context_switch&lt;/code> 切换运行的上下文，包括寄存器的状态和堆栈；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>重新开启当前 CPU 的抢占功能；&lt;/p>
&lt;/li>
&lt;/ol>
&lt;p>CFS 的调度过程与 O(1)O(1) 调度器十分类似，当前调度器与前者的区别只是增加了可选的工作窃取机制并改变了底层的数据结构。调度类 CFS 中的调度类是比较有趣的概念，调度类可以决定进程的调度策略。每个调度类都包含一组负责调度的函数，调度类由如下所示的 &lt;code>sched_class&lt;/code> 结构体表示：
struct sched_class {
struct sched_class *next;
void (*enqueue_task) (struct rq *rq, struct task_struct *p, int wakeup);
void (*dequeue_task) (struct rq *rq, struct task_struct *p, int sleep);
void (*yield_task) (struct rq *rq, struct task_struct *p);
void (*check_preempt_curr) (struct rq *rq, struct task_struct _p);
struct task_struct _ (*pick_next_task) (struct rq *rq);
void (*put_prev_task) (struct rq *rq, struct task_struct *p);
unsigned long (*load_balance) (struct rq *this_rq, int this_cpu,
struct rq *busiest,
unsigned long max_nr_move, unsigned long max_load_move,
struct sched_domain *sd, enum cpu_idle_type idle,
int *all_pinned, int *this_best_prio);
void (*set_curr_task) (struct rq *rq);
void (*task_tick) (struct rq *rq, struct task_struct *p);
void (*task_new) (struct rq *rq, struct task_struct *p);
};1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
C 调度类中包含任务的初始化、入队和出队等函数，这里的设计与面向对象中的设计稍微有些相似。内核中包含 &lt;code>SCHED_NORMAL&lt;/code>、&lt;code>SCHED_BATCH&lt;/code>、&lt;code>SCHED_IDLE&lt;/code>、&lt;code>SCHED_FIFO&lt;/code> 和 &lt;code>SCHED_RR&lt;/code> 调度类，这些不同的调度类分别实现了 &lt;code>sched_class&lt;/code> 中的函数以提供不同的调度行为。
&lt;!-- raw HTML omitted -->&lt;!-- raw HTML omitted -->### 小结
本节介绍了操作系统调度器的设计原理以及演进的历史，从 2007 年合入 CFS 到现在已经过去了很长时间，目前的调度器 12 也变得更加复杂，社区也在不断改进进程调度器。我们可以从 Linux 调度器的演进的过程看到主流系统架构的变化，最初几十行代码的调度器就能完成基本的调度功能，而现在要使用几万行代码来完成复杂的调度，保证系统的低延时和高吞吐量。由于篇幅有限，我们很难对操作系统的调度器进行面面俱到的分析，你可以在 这里 找到作者使用的 Linux 源代码，亲自动手分析不同版本的进程调度器。
&lt;!-- raw HTML omitted -->&lt;!-- raw HTML omitted -->### 延伸阅读- What is long term scheduler, short term scheduler and mid term term scheduler in OS?&lt;/p>
&lt;ul>
&lt;li>
&lt;p>A brief history of the Linux Kernel’s process scheduler: The very first scheduler, v0.01&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Understanding the Linux 2.6.8.1 CPU Scheduler&lt;/p>
&lt;/li>
&lt;li>
&lt;p>CFS Scheduler&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Inside the Linux 2.6 Completely Fair Scheduler&lt;/p>
&lt;/li>
&lt;li>
&lt;p>The Linux desktop may soon be a lot faster&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Modular Scheduler Core and Completely Fair Scheduler&lt;/p>
&lt;/li>
&lt;li>
&lt;p>The Linux Scheduler: A Decade of Wasted Cores
&lt;!-- raw HTML omitted -->&lt;!-- raw HTML omitted -->## Go 语言
Go 语言是诞生自 2009 年的编程语言，相信很多人对 Go 语言的印象都是语法简单，能够支撑高并发的服务。语法简单是编程语言的顶层设计哲学，而语言的高并发支持依靠的是运行时的调度器（Runtime Scheduler），这也是本节将要研究的内容。对 Go 语言稍微有了解的人都知道，通信顺序进程（Communicating sequential processes，CSP）13 影响着 Go 语言的并发模型，其中的 Goroutine 和 Channel 分别表示实体和用于通信的媒介。&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/zk3f35/1616130171943-341cf12b-6889-4fdc-83e2-fba601bb8e85.png" alt="">&lt;strong>图 20 - Go 和 Erlang 的并发模型&lt;/strong>『不要通过共享内存来通信，我们应该使用通信来共享内存』不只是 Go 语言鼓励的设计哲学，更为古老的 Erlang 语言其实也遵循了同样的设计，但是 Erlang 选择使用了 Actor 模型 14，我们在这里就不介绍 CSP 和 Actor 的区别和联系的，感兴趣的读者可以在推荐阅读和应引用中找到相关资源。
&lt;!-- raw HTML omitted -->&lt;!-- raw HTML omitted -->### 设计与演进
今天的 Go 语言调度器有着优异的性能，但是如果我们回头看 Go 语言的 0.x 版本的调度器就会发现最初的调度器不仅实现非常简陋，也无法支撑高并发的服务。调度器经过几个大版本的迭代才有今天的优异性能，几个不同版本的调度器引入了不同的改进，也存在不同的缺陷:&lt;/p>
&lt;/li>
&lt;li>
&lt;p>单线程调度器 · 0.x&lt;/p>
&lt;/li>
&lt;li>
&lt;p>只包含 40 多行代码；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>程序中只能存在一个活跃线程，由 G-M 模型组成；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>多线程调度器 · 1.0&lt;/p>
&lt;/li>
&lt;li>
&lt;p>允许运行多线程的程序；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>全局锁导致竞争严重；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>任务窃取调度器 · 1.1&lt;/p>
&lt;/li>
&lt;li>
&lt;p>引入了处理器 P，构成了目前的 &lt;strong>G-M-P&lt;/strong> 模型；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>在处理器 P 的基础上实现了基于&lt;strong>工作窃取&lt;/strong>的调度器；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>在某些情况下，Goroutine 不会让出线程，进而造成饥饿问题；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>时间过长的垃圾回收（Stop-the-world，STW）会导致程序长时间无法工作；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>抢占式调度器 · 1.2 ~ 至今&lt;/p>
&lt;/li>
&lt;li>
&lt;p>基于协作的抢占式调度器 - 1.2 ~ 1.13&lt;/p>
&lt;/li>
&lt;li>
&lt;p>通过编译器在函数调用时插入&lt;strong>抢占检查&lt;/strong>指令，在函数调用时检查当前 Goroutine 是否发起了抢占请求，实现基于协作的抢占式调度；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Goroutine 可能会因为垃圾回收和循环长时间占用资源导致程序暂停；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>基于信号的抢占式调度器 - 1.14 ~ 至今&lt;/p>
&lt;/li>
&lt;li>
&lt;p>实现&lt;strong>基于信号的真抢占式调度&lt;/strong>；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>垃圾回收在扫描栈时会触发抢占调度；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>抢占的时间点不够多，还不能覆盖全部的边缘情况；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>非均匀存储访问调度器 · 提案&lt;/p>
&lt;/li>
&lt;li>
&lt;p>对运行时的各种资源进行分区；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>实现非常复杂，到今天还没有提上日程；&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>除了多线程、任务窃取和抢占式调度器之外，Go 语言社区目前还有一个非均匀存储访问（Non-uniform memory access，NUMA）调度器的提案，Go 语言在未来也有实现该提案的可能。在这一节中，我们将依次介绍不同版本调度器的实现原理以及未来可能会实现的调度器提案。单线程调度器 0.x 版本调度器只包含表示 Goroutine 的 G 和表示线程的 M 两种结构，全局也只有一个线程。我们可以在 clean up scheduler 提交中找到单线程调度器的源代码，在这时 Go 语言的调度器还是由 C 语言实现的，调度函数 &lt;code>runtime.schedule&lt;/code> 也只包含 40 多行代码 ：
static void scheduler(void) {
G* gp;
lock(&amp;amp;sched);
if(gosave(&amp;amp;m-&amp;gt;sched)){
lock(&amp;amp;sched);
gp = m-&amp;gt;curg;
switch(gp-&amp;gt;status){
case Grunnable:
case Grunning:
gp-&amp;gt;status = Grunnable;
gput(gp);
break;
&amp;hellip;
}
notewakeup(&amp;amp;gp-&amp;gt;stopped);
}
gp = nextgandunlock();
noteclear(&amp;amp;gp-&amp;gt;stopped);
gp-&amp;gt;status = Grunning;
m-&amp;gt;curg = gp;
g = gp;
gogo(&amp;amp;gp-&amp;gt;sched);
}1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
C 该函数会遵循如下的过程调度 Goroutine：&lt;/p>
&lt;ol>
&lt;li>
&lt;p>获取调度器的全局锁；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>调用 &lt;code>runtime.gosave&lt;/code> 保存栈寄存器和程序计数器；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>调用 &lt;code>runtime.nextgandunlock&lt;/code> 获取下一个需要运行的 Goroutine 并解锁调度器；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>修改全局线程 &lt;code>m&lt;/code> 上要执行的 Goroutine；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>调用 &lt;code>runtime.gogo&lt;/code> 函数运行最新的 Goroutine；&lt;/p>
&lt;/li>
&lt;/ol>
&lt;p>虽然这个单线程调度器的唯一优点就是&lt;strong>能运行&lt;/strong>，但是这次提交已经包含了 G 和 M 两个重要的数据结构，也建立了 Go 语言调度器的框架。多线程调度器 Go 语言在 1.0 版本正式发布时就支持了多线程的调度器，与上一个版本几乎不可用的调度器相比，Go 语言团队在这一阶段实现了从不可用到可用的跨越。我们可以在 &lt;code>pkg/runtime/proc.c&lt;/code> 文件中找到 1.0.1 版本的调度器，多线程版本的调度函数 &lt;code>runtime.schedule&lt;/code> 包含 70 多行代码，我们在这里保留了该函数的核心逻辑：
static void schedule(G *gp) {
schedlock();
if(gp != nil) {
gp-&amp;gt;m = nil;
uint32 v = runtime·xadd(&amp;amp;runtime·sched.atomic, -1&amp;laquo;mcpuShift);
if(atomic_mcpu(v) &amp;gt; maxgomaxprocs)
runtime·throw(&amp;ldquo;negative mcpu in scheduler&amp;rdquo;);
switch(gp-&amp;gt;status){
case Grunning:
gp-&amp;gt;status = Grunnable;
gput(gp);
break;
case &amp;hellip;:
}
} else {
&amp;hellip;
}
gp = nextgandunlock();
gp-&amp;gt;status = Grunning;
m-&amp;gt;curg = gp;
gp-&amp;gt;m = m;
runtime·gogo(&amp;amp;gp-&amp;gt;sched, 0);
}1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
C 整体的逻辑与单线程调度器没有太多区别，因为我们的程序中可能同时存在多个活跃线程，所以多线程调度器引入了 &lt;code>GOMAXPROCS&lt;/code> 变量帮助我们灵活控制程序中的最大处理器数，即活跃线程数。多线程调度器的主要问题是调度时的锁竞争会严重浪费资源，Scalable Go Scheduler Design Doc 中对调度器做的性能测试发现 14% 的时间都花费在 &lt;code>runtime.futex&lt;/code> 上 15，该调度器有以下问题需要解决：&lt;/p>
&lt;ol>
&lt;li>
&lt;p>调度器和锁是全局资源，所有的调度状态都是中心化存储的，锁竞争问严重；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>线程需要经常互相传递可运行的 Goroutine，引入了大量的延迟；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>每个线程都需要处理内存缓存，导致大量的内存占用并影响数据局部性（Data locality）；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>系统调用频繁阻塞和解除阻塞正在运行的线程，增加了额外开销；&lt;/p>
&lt;/li>
&lt;/ol>
&lt;p>这里的全局锁问题和 Linux 操作系统调度器在早期遇到的问题比较相似，解决的方案也都大同小异。任务窃取调度器 2012 年 Google 的工程师 Dmitry Vyukov 在 Scalable Go Scheduler Design Doc 中指出了现有多线程调度器的问题并在多线程调度器上提出了两个改进的手段：&lt;/p>
&lt;ol>
&lt;li>
&lt;p>在当前的 G-M 模型中引入了处理器 P，增加中间层；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>在处理器 P 的基础上实现基于工作窃取的调度器；&lt;/p>
&lt;/li>
&lt;/ol>
&lt;p>基于任务窃取的 Go 语言调度器使用了沿用至今的 G-M-P 模型，我们能在 runtime: improved scheduler 提交中找到任务窃取调度器刚被实现时的源代码，调度器的 &lt;code>runtime.schedule&lt;/code> 函数在这个版本的调度器中反而更简单了：
static void schedule(void) {
G *gp;
top:
if(runtime·gcwaiting) {
gcstopm();
goto top;
}
gp = runqget(m-&amp;gt;p);
if(gp == nil)
gp = findrunnable();
&amp;hellip;
execute(gp);
}1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
Go1. 如果当前运行时在等待垃圾回收，调用 &lt;code>runtime.gcstopm&lt;/code> 函数；&lt;/p>
&lt;ol start="2">
&lt;li>
&lt;p>调用 &lt;code>runtime.runqget&lt;/code> 和 &lt;code>runtime.findrunnable&lt;/code> 从本地或者全局的运行队列中获取待执行的 Goroutine；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>调用 &lt;code>runtime.execute&lt;/code> 函数在当前线程 M 上运行 Goroutine；&lt;/p>
&lt;/li>
&lt;/ol>
&lt;p>当前处理器本地的运行队列中不包含 Goroutine 时，调用 &lt;code>findrunnable&lt;/code> 函数会触发工作窃取，从其它的处理器的队列中随机获取一些 Goroutine。运行时 G-M-P 模型中引入的处理器 P 是线程和 Goroutine 的中间层，我们从它的结构体中就能看到处理器与 M 和 G 的关系：
struct P {
Lock;
uint32 status;
P* link;
uint32 tick;
M* m;
MCache* mcache;
G** runq;
int32 runqhead;
int32 runqtail;
int32 runqsize;
G* gfree;
int32 gfreecnt;
};1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
C 处理器持有一个由可运行的 Goroutine 组成的运行队列 &lt;code>runq&lt;/code>，还反向持有一个线程。调度器在调度时会从处理器的队列中选择队列头的 Goroutine 放到线程 M 上执行。如下所示的图片展示了 Go 语言中的线程 M、处理器 P 和 Goroutine 的关系。&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/zk3f35/1616130171921-811eca3d-9570-42e5-9cc3-52d04aad0dfd.png" alt="">&lt;strong>图 21 - G-M-P 模型&lt;/strong>基于工作窃取的多线程调度器将每一个线程绑定到了独立的 CPU 上，这些线程会被不同处理器管理，不同的处理器通过工作窃取对任务进行再分配实现任务的平衡，也能提升调度器和 Go 语言程序的整体性能，今天所有的 Go 语言服务都受益于这一改动。抢占式调度器对 Go 语言并发模型的修改提升了调度器的性能，但是 1.1 版本中的调度器仍然不支持抢占式调度，程序只能依靠 Goroutine 主动让出 CPU 资源才能触发调度。Go 语言的调度器在 1.2 版本 16 中引入基于协作的抢占式调度解决下面的问题 17：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>某些 Goroutine 可以长时间占用线程，造成其它 Goroutine 的饥饿；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>垃圾回收需要暂停整个程序（Stop-the-world，STW），最长可能需要几分钟的时间 18，导致整个程序无法工作；&lt;/p>
&lt;p>1.2 版本的抢占式调度虽然能够缓解这个问题，但是它实现的抢占式调度是基于协作的，在之后很长的一段时间里 Go 语言的调度器都有一些无法被抢占的边缘情况，例如：for 循环或者垃圾回收长时间占用线程，这些问题中的一部分直到 1.14 才被基于信号的抢占式调度解决。基于协作的抢占式调度我们可以在 &lt;code>pkg/runtime/proc.c&lt;/code> 文件中找到引入基于协作的抢占式调度后的调度器。Go 语言会在分段栈的机制上实现抢占调度，利用编译器在分段栈上插入的函数，所有 Goroutine 在函数调用时都有机会进入运行时检查是否需要执行抢占。Go 团队通过以下的多个提交实现该特性：&lt;/p>
&lt;/li>
&lt;li>
&lt;p>runtime: add stackguard0 to G&lt;/p>
&lt;/li>
&lt;li>
&lt;p>为 Goroutine 引入 &lt;code>stackguard0&lt;/code> 字段，该字段被设置成 &lt;code>StackPreempt&lt;/code> 意味着当前 Goroutine 发出了抢占请求；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>runtime: introduce preemption function (not used for now)&lt;/p>
&lt;/li>
&lt;li>
&lt;p>引入抢占函数 &lt;code>runtime.preemptone&lt;/code> 和 &lt;code>runtime.preemptall&lt;/code>，这两个函数会改变 Goroutine 的 &lt;code>stackguard0&lt;/code> 字段发出抢占请求；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>定义抢占请求 &lt;code>StackPreempt&lt;/code>；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>runtime: preempt goroutines for GC&lt;/p>
&lt;/li>
&lt;li>
&lt;p>在 &lt;code>runtime.stoptheworld&lt;/code> 中调用 &lt;code>runtime.preemptall&lt;/code> 设置所有处理器上正在运行的 Goroutine 的 &lt;code>stackguard0&lt;/code> 为 &lt;code>StackPreempt&lt;/code>；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>在 &lt;code>runtime.newstack&lt;/code> 函数中增加抢占的代码，当 &lt;code>stackguard0&lt;/code> 等于 &lt;code>StackPreempt&lt;/code> 时触发调度器抢占让出线程；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>runtime: preempt long-running goroutines&lt;/p>
&lt;/li>
&lt;li>
&lt;p>在系统监控中，如果一个 Goroutine 的运行时间超过 10ms，就会调用 &lt;code>runtime.retake&lt;/code> 和 &lt;code>runtime.preemptone&lt;/code>；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>runtime: more reliable preemption&lt;/p>
&lt;/li>
&lt;li>
&lt;p>修复 Goroutine 因为周期性执行非阻塞的 CGO 或者系统调用不会被抢占的问题；&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>上面的多个提交实现了抢占式调度，但是还缺少最关键的一个环节 — 编译器如何在函数调用前插入函数，我们能在非常古老的提交 runtime: stack growth adjustments, cleanup 中找到编译器插入函数的出行，最新版本的 Go 语言会通过 &lt;code>cmd/internal/obj/x86.stacksplit&lt;/code> 插入 &lt;code>runtime.morestack&lt;/code> 函数，该函数可能会调用 &lt;code>runtime.newstack&lt;/code> 触发抢占。从上面的多个提交中，我们能归纳出基于协作的抢占式调度的工作原理：&lt;/p>
&lt;ol>
&lt;li>
&lt;p>编译器会在调用函数前插入 &lt;code>runtime.morestack&lt;/code>；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Go 语言运行时会在垃圾回收暂停程序、系统监控发现 Goroutine 运行超过 10ms 时发出抢占请求 &lt;code>StackPreempt&lt;/code>；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>当发生函数调用时，可能会执行编译器插入的 &lt;code>runtime.morestack&lt;/code> 函数，它调用的 &lt;code>runtime.newstack&lt;/code> 会检查 Goroutine 的 &lt;code>stackguard0&lt;/code> 字段是否为 &lt;code>StackPreempt&lt;/code>；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>如果 &lt;code>stackguard0&lt;/code> 是 &lt;code>StackPreempt&lt;/code>，就会触发抢占让出当前线程；&lt;/p>
&lt;/li>
&lt;/ol>
&lt;p>这种实现方式虽然增加了运行时的复杂度，但是实现相对简单，也没有带来过多的额外开销，总体来看还是比较成功的实现，也在 Go 语言中使用了 10 几个版本。因为这里的抢占是通过编译器插入函数实现的，还是需要函数调用作为入口才能触发抢占，所以这是一种&lt;strong>协作式的抢占式调度&lt;/strong>。基于信号的抢占式调度基于协作的抢占式调度虽然实现巧妙，但是并不完备，我们能在 runtime: non-cooperative goroutine preemption 中找到一些遗留问题：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>runtime: tight loops should be preemptible #10958&lt;/p>
&lt;/li>
&lt;li>
&lt;p>An empty for{} will block large slice allocation in another goroutine, even with GOMAXPROCS &amp;gt; 1 ? #17174&lt;/p>
&lt;/li>
&lt;li>
&lt;p>runtime: tight loop hangs process completely after some time #15442&lt;/p>
&lt;/li>
&lt;li>
&lt;p>…&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>Go 语言在 1.14 版本中实现了非协作的抢占式调度，在实现的过程中我们重构已有的逻辑并为 Goroutine 增加新的状态和字段来支持抢占。Go 团队通过下面的一系列提交实现了这一功能，我们可以按时间顺序分析相关提交理解它的工作原理：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>runtime: add general suspendG/resumeG&lt;/p>
&lt;/li>
&lt;li>
&lt;p>挂起 Goroutine 的过程是在垃圾回收的栈扫描时完成的，我们通过 &lt;code>runtime.suspendG&lt;/code> 和 &lt;code>runtime.resumeG&lt;/code> 两个函数重构栈扫描这一过程；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>调用 &lt;code>runtime.suspendG&lt;/code> 函数时会将处于运行状态的 Goroutine 的 &lt;code>preemptStop&lt;/code> 标记成 &lt;code>true&lt;/code>；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>调用 &lt;code>runtime.preemptPark&lt;/code> 函数可以挂起当前 Goroutine、将其状态更新成 &lt;code>_Gpreempted&lt;/code> 并触发调度器的重新调度，该函数能够交出线程控制权；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>runtime: asynchronous preemption function for x86&lt;/p>
&lt;/li>
&lt;li>
&lt;p>在 x86 架构上增加异步抢占的函数 &lt;code>runtime.asyncPreempt&lt;/code> 和 &lt;code>runtime.asyncPreempt2&lt;/code>；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>runtime: use signals to preempt Gs for suspendG&lt;/p>
&lt;/li>
&lt;li>
&lt;p>支持通过向线程发送信号的方式暂停运行的 Goroutine；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>在 &lt;code>runtime.sighandler&lt;/code> 函数中注册 &lt;code>SIGURG&lt;/code> 信号的处理函数 &lt;code>runtime.doSigPreempt&lt;/code>；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>实现 &lt;code>runtime.preemptM&lt;/code> 函数，它可以通过 &lt;code>SIGURG&lt;/code> 信号向线程发送抢占请求；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>runtime: implement async scheduler preemption&lt;/p>
&lt;/li>
&lt;li>
&lt;p>修改 &lt;code>runtime.preemptone&lt;/code> 函数的实现，加入异步抢占的逻辑；&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>目前的抢占式调度也只会在垃圾回收扫描任务时触发，我们可以梳理一下上述代码实现的抢占式调度过程：&lt;/p>
&lt;ol>
&lt;li>
&lt;p>程序启动时，在 &lt;code>runtime.sighandler&lt;/code> 函数中注册 &lt;code>SIGURG&lt;/code> 信号的处理函数 &lt;code>runtime.doSigPreempt&lt;/code>；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>在触发垃圾回收的栈扫描时会调用 &lt;code>runtime.suspendG&lt;/code> 挂起 Goroutine，该函数会执行下面的逻辑：&lt;/p>
&lt;/li>
&lt;li>
&lt;p>将 &lt;code>_Grunning&lt;/code> 状态的 Goroutine 标记成可以被抢占，即将 &lt;code>preemptStop&lt;/code> 设置成 &lt;code>true&lt;/code>；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>调用 &lt;code>runtime.preemptM&lt;/code> 触发抢占；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>runtime.preemptM&lt;/code> 会调用 &lt;code>runtime.signalM&lt;/code> 向线程发送信号 &lt;code>SIGURG&lt;/code>；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>操作系统会中断正在运行的线程并执行预先注册的信号处理函数 &lt;code>runtime.doSigPreempt&lt;/code>；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>runtime.doSigPreempt&lt;/code> 函数会处理抢占信号，获取当前的 SP 和 PC 寄存器并调用 &lt;code>runtime.sigctxt.pushCall&lt;/code>；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>runtime.sigctxt.pushCall&lt;/code> 会修改寄存器并在程序回到用户态时执行 &lt;code>runtime.asyncPreempt&lt;/code>；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>汇编指令 &lt;code>runtime.asyncPreempt&lt;/code> 会调用运行时函数 &lt;code>runtime.asyncPreempt2&lt;/code>；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>runtime.asyncPreempt2&lt;/code> 会调用 &lt;code>runtime.preemptPark&lt;/code>；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>runtime.preemptPark&lt;/code> 会修改当前 Goroutine 的状态到 &lt;code>_Gpreempted&lt;/code> 并调用 &lt;code>runtime.schedule&lt;/code> 让当前函数陷入休眠并让出线程，调度器会选择其它的 Goroutine 继续执行；&lt;/p>
&lt;/li>
&lt;/ol>
&lt;p>上述 9 个步骤展示了基于信号的抢占式调度的执行过程。除了分析抢占的过程之外，我们还需要讨论一下抢占信号的选择，提案根据以下的四个原因选择 &lt;code>SIGURG&lt;/code> 作为触发异步抢占的信号 19；&lt;/p>
&lt;ol>
&lt;li>
&lt;p>该信号需要被调试器透传；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>该信号不会被内部的 libc 库使用并拦截；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>该信号可以随意出现并且不触发任何后果；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>我们需要处理多个平台上的不同信号；&lt;/p>
&lt;/li>
&lt;/ol>
&lt;p>STW 和栈扫描是一个可以抢占的安全点（Safe-points），所以 Go 语言会在这里先加入抢占功能 20。基于信号的抢占式调度只解决了垃圾回收和栈扫描时存在的问题，它到目前为止没有解决全部问题，但是这种真抢占式调度时调度器走向完备的开始，相信在未来我们可以会更多的地方触发抢占。非均匀内存访问调度器非均匀内存访问（Non-uniform memory access，NUMA）调度器现在只是 Go 语言的提案 21，因为该提案过于复杂，而目前的调度器的性能已经足够优异，所以我们暂时没有实现该提案。该提案的原理就是通过拆分全局资源，让各个处理器能够就近获取，减少锁竞争并增加数据的局部性。在目前的运行时中，线程、处理器、网络轮询器、运行队列、全局内存分配器状态、内存分配缓存和垃圾收集器都是全局资源。运行时没有保证本地化，也不清楚系统的拓扑结构，部分结构可以提供一定的局部性，但是从全局来看没有这种保证。&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/zk3f35/1616130171960-301c5138-6fd1-48bb-91a1-e0d6305780f3.png" alt="">&lt;strong>图 22 - Go 语言 NUMA 调度器&lt;/strong>如上图所示，堆栈、全局运行队列和线程池会按照 NUMA 节点进行分区，网络轮询器和计时器会由单独的处理器持有。这种方式虽然能够利用局部性提高调度器的性能，但是本身的实现过于复杂，所以 Go 语言团队还没有着手实现这一提案。
&lt;!-- raw HTML omitted -->&lt;!-- raw HTML omitted -->### 小结
Go 语言的调度器在最初的几个版本中迅速迭代，但是从 1.2 版本之后调度器就没有太多的变化，直到 1.14 版本引入了真正的抢占式调度才解决了自 1.2 以来一直存在的问题。在可预见的未来，Go 语言的调度器还会进一步演进，增加触发抢占式调度的时间点以减少存在的边缘情况。&lt;/p>
&lt;blockquote>
&lt;p>本节内容选择一书中的 ，你可以点击链接了解更多与 Go 语言设计与实现原理相关的内容。&lt;!-- raw HTML omitted -->&lt;!-- raw HTML omitted -->### 延伸阅读- How Erlang does scheduling&lt;/p>
&lt;/blockquote>
&lt;ul>
&lt;li>
&lt;p>Analysis of the Go runtime scheduler&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Go’s work-stealing scheduler&lt;/p>
&lt;/li>
&lt;li>
&lt;p>cmd/compile: insert scheduling checks on loop backedges&lt;/p>
&lt;/li>
&lt;li>
&lt;p>runtime: clean up async preemption loose ends&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Proposal: Non-cooperative goroutine preemption&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Proposal: Conservative inner-frame scanning for non-cooperative goroutine preemption&lt;/p>
&lt;/li>
&lt;li>
&lt;p>NUMA-aware scheduler for Go&lt;/p>
&lt;/li>
&lt;li>
&lt;p>The Go scheduler&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Why goroutines are not lightweight threads?&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Scheduling In Go : Part I - OS Scheduler&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Scheduling In Go : Part II - Go Scheduler&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Scheduling In Go : Part III - Concurrency&lt;/p>
&lt;/li>
&lt;li>
&lt;p>The Go netpoller&lt;/p>
&lt;/li>
&lt;li>
&lt;p>System Calls Make the World Go Round&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Linux Syscall Reference
&lt;!-- raw HTML omitted -->&lt;!-- raw HTML omitted -->## Kubernetes
Kubernetes 是生产级别的容器调度和管理系统，在过去的一段时间中，Kubernetes 迅速占领市场，成为容器编排领域的事实标准。&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/zk3f35/1616130172073-7c2957b4-ba14-4c3c-bf6d-cf690af5e589.png" alt="">&lt;strong>图 23 - 容器编排系统演进&lt;/strong>Kubernetes 是希腊语『舵手』的意思，它最开始由 Google 的几位软件工程师创立，深受公司内部 Borg 和 Omega 项目 22 的影响，很多设计都是从 Borg 中借鉴的，同时也对 Borg 的缺陷进行了改进，Kubernetes 目前是 Cloud Native Computing Foundation (CNCF) 的项目，也是很多公司管理分布式系统的解决方案 23。调度器（Scheduler）是 Kubernetes 的核心组件，它的主要功能是为待运行的工作负载 Pod 绑定运行的节点 Node。与其他调度场景不同，虽然资源利用率在 Kubernetes 中也非常重要，但是这只是 Kubernetes 关注的一个因素，它需要在容器编排这个场景中支持非常多并且复杂的业务需求，除了考虑 CPU 和内存是否充足，还需要考虑其他的领域特定场景，例如：两个服务不能占用同一台机器的相同端口、几个服务要运行在同一台机器上，根据节点的类型调度资源等。这些复杂的业务场景和调度需求使 Kubernetes 调度器的内部设计与其他调度器完全不同，但是作为用户应用层的调度器，我们却能从中学到很多有用的模式和设计。接下来，本节将介绍 Kubernetes 中调度器的设计以及演变。
&lt;!-- raw HTML omitted -->&lt;!-- raw HTML omitted -->### 设计与演进
Kubernetes 调度器的演变过程比较简单，我们可以将它的演进过程分成以下的两个阶段：&lt;/p>
&lt;/li>
&lt;li>
&lt;p>基于谓词和优先级的调度器（Predicates and Priorities） · v1.0.0 ~ v1.14.0&lt;/p>
&lt;/li>
&lt;li>
&lt;p>基于调度框架的调度器（Scheduling Framework） · v1.15.0 ~ 至今&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>Kubernetes 从 v1.0.0 版本发布到 v1.14.0，总共 15 个版本一直都在使用谓词和优先级来管理不同的调度算法，知道 v1.15.0 开始引入调度框架（Alpha 功能）来重构现有的调度器。我们在这里将以 v1.14.0 版本的谓词和优先级和 v1.17.0 版本的调度框架分析调度器的演进过程。谓词和优先级算法谓词（Predicates）和优先级（Priorities）调度器是从 Kubernetes v1.0.0 发布时就存在的模式，v1.14.0 的最后实现与最开始的设计也没有太多区别。然而从 v1.0.0 到 v1.14.0 期间也引入了很多改进：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>调度器扩展（Scheduler Extender） · v1.2.0 - Scheduler extension&lt;/p>
&lt;/li>
&lt;li>
&lt;p>通过调用外部调度器扩展的方式改变调度器的决策；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Map-Reduce 优先级算法 · v1.5.0 - MapReduce-like scheduler priority functions&lt;/p>
&lt;/li>
&lt;li>
&lt;p>为调度器的优先级算法支持 Map-Reduce 的计算方式，通过引入可并行的 Map 阶段优化调度器的计算性能；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>调度器迁移 · v1.10.0 - Move scheduler code out of plugin directory&lt;/p>
&lt;/li>
&lt;li>
&lt;p>从 &lt;code>plugin/pkg/scheduler&lt;/code> 移到 &lt;code>pkg/scheduler&lt;/code>；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>kube-scheduler&lt;/code> 成为对外直接提供的可执行文件；&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>谓词和优先级都是 Kubernetes 在调度系统中提供的两个抽象，谓词算法使用 &lt;code>FitPredicate&lt;/code> 类型，而优先级算法使用 &lt;code>PriorityMapFunction&lt;/code> 和 &lt;code>PriorityReduceFunction&lt;/code> 两个类型：
type FitPredicate func(pod *v1.Pod, meta PredicateMetadata, nodeInfo *schedulernodeinfo.NodeInfo) (bool, []PredicateFailureReason, error)
type PriorityMapFunction func(pod *v1.Pod, meta interface{}, nodeInfo *schedulernodeinfo.NodeInfo) (schedulerapi.HostPriority, error)
type PriorityReduceFunction func(pod *v1.Pod, meta interface{}, nodeNameToInfo map[string]*schedulernodeinfo.NodeInfo, result schedulerapi.HostPriorityList) error1
2
3
4
Go 因为 v1.14.0 也是作者刚开始参与 Kubernetes 开发的第一个版本，所以对当时的设计印象也非常深刻，v1.14.0 的 Kubernetes 调度器会使用 &lt;code>PriorityMapFunction&lt;/code> 和 &lt;code>PriorityReduceFunction&lt;/code> 这种 Map-Reduce 的方式计算所有节点的分数并从其中选择分数最高的节点。下图展示了，v1.14.0 版本中调度器的执行过程：&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/zk3f35/1616130171987-60f85976-1905-49d4-8b1e-12c40e6a708d.png" alt="">&lt;strong>图 24 - 谓词和优先级算法&lt;/strong>如上图所示，我们假设调度器中存在一个谓词算法和一个 Map-Reduce 优先级算法，当我们为一个 Pod 在 6 个节点中选择最合适的一个时，6 个节点会先经过谓词的筛选，图中的谓词算法会过滤掉一半的节点，剩余的 3 个节点经过 Map 和 Reduce 两个过程分别得到了 5、10 和 5 分，最终调度器就会选择分数最高的 4 号节点。&lt;code>genericScheduler.Schedule&lt;/code> 是 Kubernetes 为 Pod 选择节点的方法，我们省略了该方法中用于检查边界条件以及打点的代码：
func (g *genericScheduler) Schedule(pod *v1.Pod, nodeLister algorithm.NodeLister) (result ScheduleResult, err error) {
nodes, err := nodeLister.List()
if err != nil {
return result, err
}
if len(nodes) == 0 {
return result, ErrNoNodesAvailable
}
filteredNodes, failedPredicateMap, err := g.findNodesThatFit(pod, nodes)
if err != nil {
return result, err
}
&amp;hellip;
priorityList, err := PrioritizeNodes(pod, g.nodeInfoSnapshot.NodeInfoMap, &amp;hellip;, g.prioritizers, filteredNodes, g.extenders)
if err != nil {
return result, err
}
host, err := g.selectHost(priorityList)
return ScheduleResult{
SuggestedHost: host,
EvaluatedNodes: len(filteredNodes) + len(failedPredicateMap),
FeasibleNodes: len(filteredNodes),
}, err
}1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
Go1. 从 &lt;code>NodeLister&lt;/code> 中获取当前系统中存在的全部节点；&lt;/p>
&lt;ol start="2">
&lt;li>
&lt;p>调用 &lt;code>genericScheduler.findNodesThatFit&lt;/code> 方法并行执行全部的谓词算法过滤节点；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>谓词算法会根据传入的 Pod 和 Node 对节点进行过滤，这时会过滤掉端口号冲突、资源不足的节点；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>调用所有调度器扩展的 &lt;code>Filter&lt;/code> 方法辅助过滤；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>调用 &lt;code>PrioritizeNodes&lt;/code> 函数为所有的节点打分；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>以 Pod 和 Node 作为参数并发执行同一优先级的 &lt;code>PriorityMapFunction&lt;/code>;&lt;/p>
&lt;/li>
&lt;li>
&lt;p>以 Pod 和优先级返回的 Node 到分数的映射为参数调用 &lt;code>PriorityReduceFunction&lt;/code> 函数；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>调用所有调度器扩展的 &lt;code>Prioritize&lt;/code> 方法；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>将所有分数按照权重相加后返回从 Node 到分数的映射；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>调用 &lt;code>genericScheduler.selectHost&lt;/code> 方法选择得分最高的节点；&lt;/p>
&lt;/li>
&lt;/ol>
&lt;p>这就是使用谓词和优先级算法时的调度过程，我们在这里省略了调度器的优先队列中的排序，出现调度错误时的抢占以及 Pod 持久存储卷绑定到 Node 上的过程，只保留了核心的调度逻辑。调度框架 Kubernetes 调度框架（Scheduling Framework）是 Babak Salamat 和 Jonathan Basseri 2018 年提出的最新调度器设计 24，这个提案明确了 Kubernetes 中的各个调度阶段，提供了设计良好的基于插件的接口。调度框架认为 Kubernetes 中目前存在调度（Scheduling）和绑定（Binding）两个循环：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>调度循环在多个 Node 中为 Pod 选择最合适的 Node；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>绑定循环将调度决策应用到集群中，包括绑定 Pod 和 Node、绑定持久存储等工作；&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>除了两个大循环之外，调度框架中还包含 &lt;code>QueueSort&lt;/code>、&lt;code>PreFilter&lt;/code>、&lt;code>Filter&lt;/code>、&lt;code>PostFilter&lt;/code>、&lt;code>Score&lt;/code>、&lt;code>Reserve&lt;/code>、&lt;code>Permit&lt;/code>、&lt;code>PreBind&lt;/code>、&lt;code>Bind&lt;/code>、&lt;code>PostBind&lt;/code> 和 &lt;code>Unreserve&lt;/code> 11 个扩展点（Extension Point），这些扩展点会在调度的过程中触发，它们的运行顺序如下：&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/zk3f35/1616130171976-b7821824-7f6e-4cf7-bcf6-2bc707495b9e.png" alt="">&lt;strong>图 25 - Kubernetes 调度框架&lt;/strong>我们可以将调度器中的 &lt;code>Scheduler.scheduleOne&lt;/code> 方法作为入口分析基于调度框架的调度器实现，每次调用该方法都会完成一遍为 Pod 调度节点的全部流程，我们将该函数的执行过程分成调度和绑定两个阶段，首先是调度器的调度阶段：
func (sched *Scheduler) scheduleOne(ctx context.Context) {
fwk := sched.Framework
podInfo := sched.NextPod()
pod := podInfo.Pod
state := framework.NewCycleState()
scheduleResult, _ := sched.Algorithm.Schedule(schedulingCycleCtx, state, pod)
assumedPod := podInfo.DeepCopy().Pod
allBound, _ := sched.VolumeBinder.Binder.AssumePodVolumes(assumedPod, scheduleResult.SuggestedHost)
if err != nil {
return
}
if sts := fwk.RunReservePlugins(schedulingCycleCtx, state, assumedPod, scheduleResult.SuggestedHost); !sts.IsSuccess() {
return
}
if err := sched.assume(assumedPod, scheduleResult.SuggestedHost); err != nil {
fwk.RunUnreservePlugins(schedulingCycleCtx, state, assumedPod, scheduleResult.SuggestedHost)
return
}
&amp;hellip;
}1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
Go1. 调用内部优先队列的 &lt;code>MakeNextPodFunc&lt;/code> 返回的函数从队列中获取下一个等待调度的 Pod，用于维护等待 Pod 的队列会执行 &lt;code>QueueSort&lt;/code> 插件；&lt;/p>
&lt;ol start="2">
&lt;li>
&lt;p>调用 &lt;code>genericScheduler.Schedule&lt;/code> 函数选择节点，该过程会执行 &lt;code>PreFilter&lt;/code>、&lt;code>Filter&lt;/code>、&lt;code>PostFilter&lt;/code>、&lt;code>Score&lt;/code> 四个扩展点的插件；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>调用 &lt;code>framework.RunReservePlugins&lt;/code> 函数运行 &lt;code>Reserve&lt;/code> 插件用于保留资源并进入绑定阶段（绑定阶段运行时间较长，避免资源被抢占）；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>如果运行失败执行，调用 &lt;code>framework.RunUnreservePlugins&lt;/code> 函数运行 &lt;code>Unreserve&lt;/code> 插件；&lt;/p>
&lt;/li>
&lt;/ol>
&lt;p>因为每一次调度决策都会改变上下文，所以该阶段 Kubernetes 需要串行执行。而绑定阶段就是实现调度的过程了，我们会创建一个新的 Goroutine 并行执行绑定循环：
func (sched *Scheduler) scheduleOne(ctx context.Context) {
&amp;hellip;
go func() {
bindingCycleCtx, cancel := context.WithCancel(ctx)
defer cancel()
fwk.RunPermitPlugins(bindingCycleCtx, state, assumedPod, scheduleResult.SuggestedHost)
if !allBound {
sched.bindVolumes(assumedPod)
}
fwk.RunPreBindPlugins(bindingCycleCtx, state, assumedPod, scheduleResult.SuggestedHost)
if err := sched.bind(bindingCycleCtx, assumedPod, scheduleResult.SuggestedHost, state); err != nil {
fwk.RunUnreservePlugins(bindingCycleCtx, state, assumedPod, scheduleResult.SuggestedHost)
} else {
fwk.RunPostBindPlugins(bindingCycleCtx, state, assumedPod, scheduleResult.SuggestedHost)
}
}()
}1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
Go1. 启动一个 Goroutine 并调用 &lt;code>framework.RunPermitPlugin&lt;/code> 异步运行 &lt;code>Permit&lt;/code> 插件，这个阶段可以用来实现批调度器；&lt;/p>
&lt;ol start="2">
&lt;li>
&lt;p>调用 &lt;code>Scheduler.bindVolumes&lt;/code> 将卷先绑定到 Node 上；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>调用 &lt;code>Scheduler.bind&lt;/code> 函数将 Pod 绑定到 Node 上完成调度，绑定的过程会执行 &lt;code>PreBind&lt;/code>、&lt;code>Bind&lt;/code> 和 &lt;code>PostBind&lt;/code> 三个扩展点的插件；&lt;/p>
&lt;/li>
&lt;/ol>
&lt;p>目前的调度框架在 Kubernetes v1.17.0 版本中还是 Alpha 阶段，很多功能还不明确，为了支持更多、更丰富的场景，在接下来的几个版本还可能会做出很多改进，不过调度框架在很长的一段时间中都会是调度器的核心。
&lt;!-- raw HTML omitted -->&lt;!-- raw HTML omitted -->### 小结
本节介绍了 Kubernetes 调度器从 v1.0.0 到最新版本中的不同设计，Kubernetes 调度器中总共存在两种不同的设计，一种是基于谓词和优先级算法的调度器，另一种是基于调度框架的调度器。很多的业务调度器也需要从多个选项中选出最优的选择，无论是成本最低还是质量最优，我们可以考虑将调度的过程分成过滤和打分两个阶段为调度器建立合适的抽象，过滤阶段会按照需求过滤掉不满足需求的选项，打分阶段可能会按照质量、成本和权重对多个选项进行排序，遵循这种设计思路可以解决很多类似问题。目前的 Kubernetes 已经通过调度框架详细地支持了多个阶段的扩展方法，几乎是调度器内部实现的最终形态了。不过随着调度器功能的逐渐复杂，未来可能还会遇到更复杂的调度场景，例如：多租户的调度资源隔离、多调度器等功能，而 Kubernetes 社区也一直都在为构建高性能的调度器而努力。
&lt;!-- raw HTML omitted -->&lt;!-- raw HTML omitted -->### 延伸阅读- Borg, Omega, and Kubernetes&lt;/p>
&lt;ul>
&lt;li>
&lt;p>Scheduling Framework&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Scheduling Framework #624&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Create a custom Kubernetes scheduler&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Scheduler extender Document
&lt;!-- raw HTML omitted -->&lt;!-- raw HTML omitted -->## 总结
从操作系统、编程语言到应用程序，我们在这篇文章中分析了 Linux、Go 语言和 Kubernetes 调度器的设计与实现原理，这三个不同的调度器其实有相互依赖的关系：&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/zk3f35/1616130171960-876393d3-3bcb-4f1d-9623-afb68dccd1bc.png" alt="">&lt;strong>图 26 - 三层调度器&lt;/strong>如上图所示，Kubernetes 的调度器依赖于 Go 语言的运行时调度器，而 Go 语言的运行时调度器也依赖于 Linux 的进程调度器，从上到下离用户越来越远，从下到上越来越关注具体业务。我们在最后通过两个比较分析一下这几个调度器的异同：&lt;/p>
&lt;/li>
&lt;/ul>
&lt;ol>
&lt;li>
&lt;p>Linux 进程调度器与 Go 语言运行时调度器；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>系统级调度器（Linux 和 Go）与业务调度器（Kubernetes）；&lt;/p>
&lt;/li>
&lt;/ol>
&lt;p>这是两种不同层面的比较，相信通过不同角度的比较能够让我们对调度器的设计有更深入的认识。
&lt;!-- raw HTML omitted -->&lt;!-- raw HTML omitted -->### Linux 和 Go
首先是 Linux 和 Go 语言调度器，这两个调度器的场景都非常相似，它们最终都是要充分利用机器上的 CPU 资源，所以在实现和演进上有很多相似之处：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>调度器的初始版本都非常简单，甚至很简陋，只能支持协作式的调度；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>按照运行队列进行分区，通过工作窃取的方式平衡不同 CPU 或者线程上的运行队列；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>最终都通过某些方式实现了基于信号的抢占式调度，不过 Go 语言的实现并不完善；&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>因为场景非常相似，所以它们的目的也非常相似，只是它们调度的任务粒度会有不同，Linux 进程调度器的最小调度单位是线程，而 Go 语言是 Goroutine，与 Linux 进程调度器相比，Go 语言在用户层建立新的模型，实现了另一个调度器，为使用者提供轻量级的调度单位来增强程序的性能，但是它也引入了很多组件来处理系统调用、网络轮询等线程相关的操作，同时组合多个不同粒度的任务导致实现相对复杂。Linux 调度器的最终设计引入了调度类的概念，让不同任务的类型分别享受不同的调度策略以此来调和低延时和实时性这个在调度上两难的问题。Go 语言的调度器目前刚刚引入了基于信号的抢占式调度，还有很多功能都不完善。除了抢占式调度之外，复杂的 NUMA 调度器提案也可能是未来 Go 语言的发展方向。
&lt;!-- raw HTML omitted -->&lt;!-- raw HTML omitted -->### 系统和业务
如果我们将系统调度器和业务调度器进行对比的话，你会发现两者在设计差别非常大，毕竟它们处于系统的不同层级。系统调度器考虑的是极致的性能，所以它通过分区的方式将运行队列等资源分离，通过降低锁的粒度来降低系统的延迟；而业务调度器关注的是完善的调度功能，调度的性能虽然十分重要，但是一定要建立在满足特定调度需求之上，而因为业务上的调度需求往往都是比较复杂，所以只能做出权衡和取舍。正是因为需求的不同，我们会发现不同调度器的演进过程也完全不同。系统调度器都会先充分利用资源，降低系统延时，随后在性能无法优化时才考虑加入调度类等功能满足不同场景下的调度，而 Kubernetes 调度器更关注内部不同调度算法的组织，如何同时维护多个复杂的调度算法，当设计了良好的抽象之后，它才会考虑更加复杂的多调度器、多租户等场景。
&lt;!-- raw HTML omitted -->&lt;!-- raw HTML omitted -->### 总结的总结
这种研究历史变化带来的快乐是很不同的，当我们发现代码发生变化的原因时也会感到欣喜，这让我们站在今天重新见证了历史上的决策，本文中的相应章节已经包含了对应源代码的链接，各位读者可以自行阅读相应内容，也衷心希望各位读者能够有所收获。&lt;/p>
&lt;blockquote>
&lt;p>系统设计精要是一系列深入研究系统设计方法的系列文章，文中不仅会分析系统设计的理论，还会分析多个实际场景下的具体实现。这是一个季更或者半年更的系列，如果你有想要了解的问题，可以在文章下面留言。&lt;!-- raw HTML omitted -->&lt;!-- raw HTML omitted -->## 延伸阅读- Cooperative vs. Preemptive: a quest to maximize concurrency power&lt;/p>
&lt;/blockquote>
&lt;ul>
&lt;li>
&lt;p>Randomized Work Stealing versus Sharing in Large-scale Systems with Non-exponential Job Sizes&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Scalable work stealing
***1. Wikipedia: Scheduling (computing) ↩︎&lt;/p>
&lt;/li>
&lt;/ul>
&lt;ol start="2">
&lt;li>
&lt;p>Scheduling: Theory, Algorithms, and Systems ↩︎&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Scheduling multithreaded computations by work stealing ↩︎&lt;/p>
&lt;/li>
&lt;li>
&lt;p>descheduler · GitHub ↩︎&lt;/p>
&lt;/li>
&lt;li>
&lt;p>How Linux handles threads and process scheduling ↩︎&lt;/p>
&lt;/li>
&lt;li>
&lt;p>schedule · Linux 0.01 ↩︎&lt;/p>
&lt;/li>
&lt;li>
&lt;p>O(n) 调度器遍历就绪队列 ↩︎&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Understanding the Linux Kernel, Third Edition. ↩︎&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Introducing the 2.6 Kernel ↩︎&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Wikipedia: Completely Fair Scheduler ↩︎&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Wikipedia: Red-black tree ↩︎&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Linux Scheduler ↩︎&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Communicating sequential processes ↩︎&lt;/p>
&lt;/li>
&lt;li>
&lt;p>为什么使用通信来共享内存 ↩︎&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Scalable Go Scheduler Design Doc ↩︎&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Pre-emption in the scheduler ↩︎&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Go Preemptive Scheduler Design Doc ↩︎&lt;/p>
&lt;/li>
&lt;li>
&lt;p>runtime: goroutines do not get scheduled for a long time for no obvious reason ↩︎&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Proposal: Non-cooperative goroutine preemption ↩︎&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Proposal: Conservative inner-frame scanning for non-cooperative goroutine preemption ↩︎&lt;/p>
&lt;/li>
&lt;li>
&lt;p>NUMA-aware scheduler for Go ↩︎&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Borg, Omega, and Kubernetes ↩︎&lt;/p>
&lt;/li>
&lt;li>
&lt;p>谈 Kubernetes 的架构设计与实现原理 ↩︎&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Scheduling Framework ↩︎&lt;/p>
&lt;/li>
&lt;/ol></description></item><item><title>Docs: 华为 CDN</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/8.%E9%80%9A%E7%94%A8%E6%8A%80%E6%9C%AF/cdn/%E5%8D%8E%E4%B8%BA-cdn/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/8.%E9%80%9A%E7%94%A8%E6%8A%80%E6%9C%AF/cdn/%E5%8D%8E%E4%B8%BA-cdn/</guid><description>
&lt;h1 id="cdn-整体部件名词解释">CDN 整体部件名词解释&lt;/h1>
&lt;ol>
&lt;li>上层平台术语
&lt;ol>
&lt;li>CP：（ Content Provider） 内容提供者&lt;/li>
&lt;li>BOSS：(Business and Operation Support System)业务运营支撑系统&lt;/li>
&lt;li>CRS：（Content Resource System ）内容资源系统&lt;/li>
&lt;li>OMS 运营中心系统
&lt;ol>
&lt;li>NMS：（Network Management Subsytem） 网络管理子系统&lt;/li>
&lt;/ol>
&lt;/li>
&lt;li>CDNC：（ Content Delivery Network Center ）内容分发网络中心&lt;/li>
&lt;li>BMS：（ Business Management Subsystem） 业务管理子系统，
&lt;ol>
&lt;li>本节点业务管理、规则库管理(是否允许 HCS 缓存哪些域名的哪些内容等)、资源管理、系统管理等一般维护操作。&lt;/li>
&lt;li>配置下发给本节点子系统。包括 TIS,HCS 等&lt;/li>
&lt;/ol>
&lt;/li>
&lt;/ol>
&lt;/li>
&lt;li>调度系统(Traffic Control)(系统只是一个概念一个解决方案，现场环境安装的全是组件，每个组件是组成一套系统的基础)&lt;/li>
&lt;li>TCS：（Global Traffic Control System ）流量(全局)控制系统，该全局系统一般是总公司的系统，也包含下面说到的相关组件。当用户请求的时候，通过 TCS 的组件之间互相调度后再调度到 LTC 的组件。&lt;/li>
&lt;li>LTC：（Local Traffic Control System ）本地(区域)流量控制系统。&lt;/li>
&lt;li>DPI(特殊设备)：在 Cache 环境中，用户请求非签约模式的大文件内容时候，负责把请求镜像到 TIS-Mirror 上进行处理&lt;/li>
&lt;li>DPI 非华为设备，一般是运营商与华为商量好，溯源中心的 DPI 部署在本省流量到外网的出口的位置上，当本地 HCS 需要去源站回源出去到外网的时候，会被该 DPI 劫持，然后把回源请求重定向到溯源中心的 HCS 上&lt;/li>
&lt;li>TIS：Traffic Insight Subsystem 流量洞察子系统，负责流量镜像方式引流，包括 DNS 重定向、HTTP 重定向、P2P 重定向等方式。TIS 通过流量镜像方式获得终端用户上行请求的拷贝，对请求进行深度识别和处理后，通过重定向方式将终端用户引导到缓存服务器接受服务。&lt;/li>
&lt;li>TIS-GSLB，用户请求内容时，通过 Local DNS 进行域名以及 cName DNS(DNS 别名)的解析，该组件通过 Local DNS 的地理位置，把离用户最近的 LBS 或者 LTC 的 IP 发送给客户(OTT,B2B 场景中)&lt;/li>
&lt;li>GSLB：（Global Service Load Balance）全局服务负载均衡&lt;/li>
&lt;li>LBS：（ Load Balancing Subsystem） 负载均衡子系统，接受用户的 HTTP 请求后，通过负载均衡调度策略，为用户选择一台 HCS(HMS)&lt;/li>
&lt;li>SLB（Software Load Balancer），即软件负载均衡器，设置在一组功能相同或相似的集群服务器前端，对到达集群服务器组的流量进行合理分发，并在其中某一台服务器故障时，能将访问请求转移到其它可以正常工作的服务器的软件或网络设备&lt;/li>
&lt;li>TIS-Mirror，用户请求内容时，收到 DPI 镜像过来的用户请求，来直接给用户分配 HCS(Cache 场景中)&lt;/li>
&lt;li>TIS-DNS，用户请求内容时，Local DNS 本地 DNS 转发(Foward 方式)请求到该处，由 TIS_DNS 根据 BMS 规则进行域名匹配，把匹配到的 LBS(Cache 场景中)&lt;/li>
&lt;li>TIS-HTTP：(Traffic Insight Subsystem HTTP)向 UE 返回 302(重定向)报文，报文中包含距离用户最近的边缘节点地市 HCS(HMS)前端 LBS 的虚 IP 地址。&lt;/li>
&lt;li>TIS（Traffic Insight Suite）流量洞察套件，提供可观、可控、可预测的流量管理，用户行为预测、分析服务 ，是媒体使能平台（CDN）的媒体数据分析套件，负责用户访问日志的采集、处理、存储，对日志进行转换、分析热度模型和访问模型、历史访问及空间利用率统计，为 CDN 流量可视化和 CDN 现网资源运维、调配、优化提供分析支撑。&lt;/li>
&lt;li>TA：（Traffic Analytics ）负责根据 CDN 的访问分析出 CDN 缓存系统的命中率、当前用户和内容的访问模型情况、当前最热的内容，从而为 CDN 运维，设备资源的配置、优化、业务规划部署、网路规划提供最佳的理论支撑。&lt;/li>
&lt;li>UM：(Usage Mediator)用量采集器，负责从媒体服务器上接收用户访问的话单处理，并为外部报表系统提供数据源。也包括从 HMS、RRS 收集用户访问日志、调度日志并进行统一的日志规整，供流量洞察套件、VQE 套件实时分析。&lt;/li>
&lt;li>ELB（Elastic Load Balancing）弹性负载均衡，用于实时监控系统的健康状况、下发配置变更以及安全防护。&lt;/li>
&lt;/ol>
&lt;ul>
&lt;li>ELB 管理节点采用集群模式。&lt;/li>
&lt;li>接收用户配置文件，并发送给 LVS 处理。&lt;/li>
&lt;li>接收 LVS 上报的监控数据，管理负载均衡系统的健康状态。&lt;/li>
&lt;/ul>
&lt;ol>
&lt;li>内容，资源缓存系统术语&lt;/li>
&lt;li>HCS：（ Hybrid Cache Subsystem ）混合缓存子系统，缓存各种内容内容，并为用户提供内容，供用户下载，观看等，多台 HCS 内部可以互相查找内容，当用户在 HCS1 上没找到所需内容的时候，HCS1 会通知用户去 HCS2 上获取内容&lt;/li>
&lt;li>CSS-BT：(Cache Subsystem of BT)BT 缓存子系统，负责缓存 BT 热门资源，在 UE 请求资源时返回给 UE。&lt;/li>
&lt;li>CSS-XL：(Cache Subsystem of XunLei)XL 缓存子系统，负责缓存迅雷热门资源，在 UE 请求资源时返回给 UE。&lt;/li>
&lt;li>DMFS：（DigitalMedia File Server） 数字媒体文件服务器对应 MDN&lt;/li>
&lt;li>网管系统相关术语(网管指的是网络中所有设备的管理者，可以管理各种设备的设备，比如 I2000,cacti 等)&lt;/li>
&lt;li>DV：（DigitalView ）数字化视图，可接收接入设备上报的告警并展示，还可以对设备进行运维管理(包括部署等操作，需要安装扩展插件 DF 等)&lt;/li>
&lt;li>DF:（Digita Foundry）数字化部署，把 DF 安装后接入 DV，可以通过 DV 的部署界面在 web 界面上部署各种应用以及软件&lt;/li>
&lt;li>UOA：（Uniform Operation &amp;amp; Maintenance Agent）统一操作与维护(简称 OM)代理，统一网管代理是设备接入网管的统一接口，该代理模块负责将网元设备接入网管系统。网管与 UOA 之间的通信基于 SNMP（Simple Network Management Protocol）协议。&lt;/li>
&lt;li>BMU：(Board Management Unit)单板管理单元，&lt;/li>
&lt;li>报表，数据收集等相关术语&lt;/li>
&lt;li>Report 报表系统：里面包含 BDI，ISA 组件&lt;/li>
&lt;li>BDI：（Big Data Integration）大数据集成&lt;/li>
&lt;li>ISA：（Interactive Self Analytics）交互式自我分析&lt;/li>
&lt;li>Zookeeper 是基于 Java 的开源软件，是 Hadoop 和 Hbase 的重要组件。主要作用是集群状态管理。MK 平台也是利用该组件来实现集群状态管理。&lt;/li>
&lt;li>媒体服务相关术语&lt;/li>
&lt;li>CMI：Content Management Interface 内容管理接口，负责接收外部内容管理系统分发内容等请求，把请求转交给 MM&lt;/li>
&lt;li>MM：Media Manager 媒体管理，即内容调度服务，处理 CMI 下发的任务，通过 MC 的健康检查机制，来决定调度哪台 HMS 去内容源获取内容&lt;/li>
&lt;li>MC：Management Component 管理组件&lt;/li>
&lt;li>向网管提供设备管理接口，网管通过 MC 对 CDN 进行配置管理。&lt;/li>
&lt;li>监控并记录 CDN 设备健康状态，获取告警和日志信息。通过设备健康状态来决定由哪台 HCS(HMS)设备来获取资源&lt;/li>
&lt;li>UM：Usage Management 使用管理，即鉴权，鉴别用户有没有权利来使用该内容。并且在订户体验点播、录播、网络时移以及直播（单播）业务时，记录订户的播放记录，生成播放记录文件，供报表子系统读取。&lt;/li>
&lt;li>RRS：Request Routing System 路由请求系统，主要用于当用户请求媒体内容时，负责调度其中一台 HMS 给用户提供服务&lt;/li>
&lt;li>HMS：Huawei Media Server 华为媒体服务器，一般情况下有很多很多台，存储媒体内容，给用户提供媒体内容&lt;/li>
&lt;li>LRM：Live TV &amp;amp; Recording Management 直播与录像管理。直录播管理服务，负责直播频道和录播任务的管理、录制索引的管理。提升热点直播频道录制节目的分发速度。&lt;/li>
&lt;li>GPM：Global Popularity Management 全局热度管理。负责 POP 点内分片热度数据的收集、统计、分析、排序、搬迁、空间均衡和热点均衡。&lt;/li>
&lt;li>其他&lt;/li>
&lt;li>FS：（FusionSphere） 融合领域，华为的云操作系统&lt;/li>
&lt;li>DNS： Domain Name Server 域名服务器&lt;/li>
&lt;li>Local DNS&lt;/li>
&lt;li>CP 授权 DNS,授权 DNS 通过 Cname(别名)的方式返回查询的域名的别名&lt;/li>
&lt;/ol>
&lt;p>其他&lt;/p>
&lt;p>OPIN：（open Network integtation platform）开放的网络集成平台，电软的下一代平台， 在 ENIP2.0 的基础上继承发展，并扩展 ONIP3.0 的范围到云服务、IT 集成和互联网领域，为产品和解决方案提供开放的、易集成的、弹性可伸缩的、敏捷的核心平台。ONIP 是一系列平台的套件集合，以 SOA 架构为基础，服务和组件可以做为独立的交付件，按需应用到各解决方案中； 同时 ONIP 的领域平台集成了公共技术能力和领域部件，为解决方案提供集成的领域平台。&lt;/p>
&lt;p>CIE 运维组件：（Carrier-grade Infrastructure application Environment）电信基础设施应用环境。包含 OMU,DMU。主要提供物理设备接入，虚拟设备接入，安装部署(OS,基础软件以及业务软件)等&lt;/p>
&lt;ol>
&lt;li>OMU：Unit 操作维护单元，实现系统操作维护管理功能，提供 B/S 管理界面，实现对系统中设备管理、部署等功能的操作维护能力，包括配置、监控、告警、日志等 OM 能力。OMU 支持分布式管理多个 DMU&lt;/li>
&lt;li>提供 Web 界面，接收用户的软件安装请求。&lt;/li>
&lt;li>与 DMU 通信，将安装任务下发给 DMU。&lt;/li>
&lt;li>DMU：Unit 域管理单元，实现系统全局设备管理功能。对所在区域内各类设备的集中管理，包括计算设备、存储设备、网络设备、虚拟资源的管理，及提供对业务板、虚拟机、存储设备的部署能力。同事 DMU 作为系统全局服务的协调单元，实现系统中各类自动化服务和 RAS 决策协调功能&lt;/li>
&lt;li>与 OMU 通信，接收下发的任务。&lt;/li>
&lt;li>通过 PXE、TFTP、NFS 等协议与单板建立安装通道，完成软件安装。&lt;/li>
&lt;/ol>
&lt;p>HACS：(High Availability Cluster Server)高可用集群服务器&lt;/p>
&lt;p>GDR：（Geographical Disaster Recovery，地理容灾恢复）数据库双机&lt;/p>
&lt;ol>
&lt;li>SCP：service control point 业务控制点&lt;/li>
&lt;li>SAU：signaling access unit 信令接入单元&lt;/li>
&lt;li>STP：signaling transfer point 信令转接点&lt;/li>
&lt;li>MSC：mobile switching center 移动交换中心&lt;/li>
&lt;/ol>
&lt;p>UVP：(Universal Virtualization Platform)统一虚拟化平台，虚拟化类型，实现虚拟化的组件&lt;/p>
&lt;p>USM：（Universal Server Manager）通用服务器管理，是一款采用 B/S（Browser/Server）架构的设备管理软件。USM 定位于提高华为 ATAE 设备的可管理性。USM 通过局域网管理 ATAE 设备，具有零客户端安装、网络任意点接入管理，安全、单一、集中的管理特点。使设备管理工作变得轻松、便捷、低成本。&lt;/p>
&lt;p>UDB：（URL Database）用于记录 URL 热度，根据访问情况统计内容访问热度&lt;/p>
&lt;h1 id="bms-相关问题">BMS 相关问题&lt;/h1>
&lt;p>升级规则库&lt;/p>
&lt;p>测试规则库是否可以正常的方法&lt;/p>
&lt;p>BMS 相关问题&lt;/p>
&lt;p>/home/icache/rule/baseline 目录下可以查看规则库中设定的所有缓存的域名地址，就算 web 界面设置禁用了在这里也能看到，可以从这里总结规则库条目(即规则库里缓存的域名地址的数量)&lt;/p>
&lt;p>测试单个资源在源站与本地 cache 之间的区别，通过放行用户访问请求达到测试目的&lt;/p>
&lt;ol>
&lt;li>业务管理—黑名单管理—创建—URL 关键字黑名单，选择节点，URL 中输入源站资源的 URL&lt;/li>
&lt;li>通过业务管理—配置报文下发监控 查看规则是否生效&lt;/li>
&lt;/ol>
&lt;p>升级规则库&lt;/p>
&lt;p>详情见相关产品线产品文档，比如《(For Engineer) Internet Cache V200R002C34 产品文档 06》&lt;/p>
&lt;p>注意事项：&lt;/p>
&lt;ol>
&lt;li>注意升级规则库之前，要往下翻页，只把第一页选中不行&lt;/li>
&lt;li>在准备下次升级之前，一定要查看升级结果，等待升级结果中全部已经完成再进下一次升级&lt;/li>
&lt;/ol>
&lt;p>产品分类&lt;/p>
&lt;p>视频，网页，下载共三类&lt;/p>
&lt;p>测试规则库是否可以正常的方法&lt;/p>
&lt;ol>
&lt;li>tailf /home/icache/hcs/hcs/log/accesslog #使用该命令查看日志内容是否会产生 TCP_HIT 200 GET 这样的状态信息日志，如果全是 MISS 则不正常&lt;/li>
&lt;/ol></description></item><item><title>Docs: 视频的编码与解码</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/8.%E9%80%9A%E7%94%A8%E6%8A%80%E6%9C%AF/%E7%BC%96%E7%A0%81%E8%A7%A3%E7%A0%81%E4%B8%8E%E5%8D%8F%E8%AE%AE/%E8%A7%86%E9%A2%91%E7%9A%84%E7%BC%96%E7%A0%81%E4%B8%8E%E8%A7%A3%E7%A0%81/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/8.%E9%80%9A%E7%94%A8%E6%8A%80%E6%9C%AF/%E7%BC%96%E7%A0%81%E8%A7%A3%E7%A0%81%E4%B8%8E%E5%8D%8F%E8%AE%AE/%E8%A7%86%E9%A2%91%E7%9A%84%E7%BC%96%E7%A0%81%E4%B8%8E%E8%A7%A3%E7%A0%81/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://www.bilibili.com/video/BV19Y4113788">B 站，差评君-这么多视频编码，为什么不能统一成一种呢？&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>视频编码其实就是 图像编码 与 音频编码 的结合体。
毕竟视频就是一幅幅图像叠加在一起而已，只不过在每时每刻又要附加上声音。&lt;/p>
&lt;h1 id="视频-编码-与-压缩">视频 编码 与 压缩&lt;/h1>
&lt;p>可能有小伙伴不太清楚编码器是干嘛的，差评君先花点时间给大家解释下：
（ 很快的啊，不用担心内容劝退。。懂的小伙伴可以直接往下划 ）&lt;/p>
&lt;p>我们平常在爱奇艺、 B 站看的视频，它们原本的体量十分巨大。&lt;/p>
&lt;p>有多大呢，我们就拿 1080p 分辨率的视频举例吧，一秒钟视频流大概有 149 MB 那么大（ 1920 x 1080 x 8bit x 三个 RGB 通道 x 24 帧 / 8 ）。&lt;/p>
&lt;p>相当于说我们的网速至少需要达到 149 MB/s，才能够保证看 1080p 视频不卡。&lt;/p>
&lt;p>提醒一下，149 MB/s 约合 1194 Mbps，比千兆宽带（ 1000 Mbps ）还快一点。&lt;/p>
&lt;p>但是估计得有小伙伴说了，你这是在扯淡——我家里的宽带才一百兆，网上的视频不也照样看？&lt;/p>
&lt;p>不但能实时看，还能顺手缓冲个一两分钟的量。
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/dk3gg2/1616076594016-89d258bd-3205-4d80-944a-b7c1c595dd11.jpeg" alt="">&lt;/p>
&lt;p>你们啊，Too Young~&lt;/p>
&lt;p>这其实是因为，我们平常看到的视频已经是被压缩过的了。&lt;/p>
&lt;p>压缩视频的原理细讲起来有点儿复杂，但要是抽简单的说主要就是干了三件事 —— 跳帧、划块、抽色。&lt;/p>
&lt;p>就好比说，前一秒和后一秒都是黑屏，那么这两秒就可以当作一秒处理。（ 跳帧 ）&lt;/p>
&lt;p>又或者，某一秒的画面是一张天空风景图，里面很大一片区域的颜色都是相同的。&lt;/p>
&lt;p>那么这一大片区域的像素就可以直接当成一个大像素来处理。（ 划块 ）&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/dk3gg2/1616076594014-16bd468b-3f32-4125-9dbc-e86abef85e81.jpeg" alt="">&lt;/p>
&lt;p>再比如说，原始大小的视频里包含了 1760 万种色彩，可我寻思着人眼看不出来这么多色儿。&lt;/p>
&lt;p>那么我就可以偷偷抽出来几百万个色，这样又节省了不少空间。（ 抽色 ）&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/dk3gg2/1616076594045-6a0b7b8b-057d-4343-88c3-f76d96f4948e.jpeg" alt="">&lt;/p>
&lt;p>经过这么一套操作之后，原始视频的大小通常可以被压缩到一个挺夸张的地步，就算是 3G 网络也能流畅观看。&lt;/p>
&lt;p>无非就是感觉画面卡了一点儿、糊了一点、颜色绿了一点。。。&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/dk3gg2/1616076594063-16240d1b-7397-4be5-922c-00bda03c81b0.jpeg" alt="">&lt;/p>
&lt;p>而编码器就是那个用来压缩原始视频的玩意 —— 编码器好，视频小的同时画质高；编码器不好，视频大、画质烂。&lt;/p>
&lt;p>了解了这一点之后，我们再接着往下看。&lt;/p>
&lt;p>按照阿里的说法，奇点编码器能把视频压缩千倍不影响画质，那么其他编码器呢？&lt;/p>
&lt;p>差评君来给大家做个简单的实验。&lt;/p>
&lt;p>首先，我们在浏览器里输入 &lt;a href="http://bilibili.com">http://bilibili.com&lt;/a>，打开 B 站。&lt;/p>
&lt;p>然后直奔窑子区然后随便打开一个视频，把分辨率调整到 1080p 之后，在上面右键统计信息。&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/dk3gg2/1616076594011-da2071d6-36f3-4dea-86b7-b879597ead2d.jpeg" alt="">&lt;/p>
&lt;p>这样子我们就拿到了这段视频的技术向信息。&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/dk3gg2/1616076594050-fe83c040-7739-4d0e-b6b9-40e3c97ece9a.jpeg" alt="">&lt;/p>
&lt;p>差评君帮大家解释一下，B 站这段视频使用了一个名叫 H.264 （ AVC ）的编码 —— 这是个十七年前的编码。&lt;/p>
&lt;p>分辨率 1080p，码率 1086 Kbps，相当于把原始视频压缩了 1099 倍。（ 1194 Mbps / 1.086 Mbps ）&lt;/p>
&lt;p>也就是说，一款十七年前发明的编码器，就能做到压缩千倍不影响画质（ 肉眼看起来 ）。&lt;/p>
&lt;p>阿里这时候再吹这个，就好比有人在 2020 年宣布自己发明了汽车轮子。。。&lt;/p>
&lt;p>这延迟，上网用的 Internet Explorer 6.0 吧。&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/dk3gg2/1616076594030-89db9374-da67-41f5-b847-e06ccd15bb5a.jpeg" alt="">&lt;/p>
&lt;p>当然了，差评君这么说也不完全对 —— 虽然都是压缩千倍，但奇点编码器的画质肯定要比 H.264 好。&lt;/p>
&lt;p>不过这里面还有猫腻。&lt;/p>
&lt;p>是这样的，目前常用的视频编码器有这么几个方案：&lt;/p>
&lt;p>前面提到 B 站在用的 H.264，它的继任者 H.265；谷歌的 VP9，以及开放媒体联盟研发的 AV1。&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/dk3gg2/1616076594098-053bfdc6-6a89-401e-a6a1-7f8c1d273b5a.jpeg" alt="">&lt;/p>
&lt;p>从性能上讲，谷歌的 VP9 与 H.264 接近，H.265 相比 H.264 的压缩能力提高了 50%，AV1 则略强于 H.265。&lt;/p>
&lt;p>VP9 ≈ H.264 &amp;laquo; H.265 &amp;lt; AV1，差不多是这么一个意思。&lt;/p>
&lt;p>而阿里的奇点编码器（英文名 S265 ），其实是 H.265 的一个派生版本。&lt;/p>
&lt;p>在这里差评君得补充说明一下，编码器这个行当和显卡行业其实有点儿像。&lt;/p>
&lt;p>就好比说，同样是 RTX3080 显卡，我们可以直接从 NVIDIA 手上购买拉风的 FE 公版，也可以购买华硕、技嘉、微星提供的非公版。&lt;/p>
&lt;p>虽然芯都是老黄 GA106，但是各家的供电、散热设计，以及显卡最终出来的性能表现都会有些细微的区别。&lt;/p>
&lt;p>编码器也是一样。&lt;/p>
&lt;p>ISO （ 国际标准化组织 ）发了个 H.265 的规格和标准之后，各家都可以照着这个规格做一个。&lt;/p>
&lt;p>百度有 BD265，腾讯有 V265；阿里则有 S265。&lt;/p>
&lt;p>然而阿里的 S265 在一众基于 H.265 标准的编码器里并没什么优势。&lt;/p>
&lt;p>事情是这样的 —— 奇点编码器参加的这个 “ MSU 世界视频编码器大赛 ” 其实有四个比拼项目。&lt;/p>
&lt;p>但是根据主办方的说法，YUY-SSIM 维度才是最重要的指标，其他三个比拼项目只具有 “ 参考意义 ”。&lt;/p>
&lt;p>所以我们可以把它们理解成主擂台，以及分擂台 1、2、3。&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/dk3gg2/1616076594067-aa507a2f-543e-4e29-abba-3e3dec94e3ff.jpeg" alt="">&lt;/p>
&lt;p>然而，主擂台获胜的是一款来自国外的编码器，第二名是字节跳动的 BVC，第三名是爱奇艺的 QAV1，第四名是腾讯的 V265。&lt;/p>
&lt;p>阿里的奇点编码器，排。。。第七。&lt;/p>
&lt;p>至于另外三个分擂台，阿里拿了其中两个第一是没错，但也是和字节、腾讯并列的。。。&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/dk3gg2/1616076594048-3efead86-892d-4a84-9837-ce5502f9b91c.jpeg" alt="">&lt;/p>
&lt;p>然后阿里发了个通稿，我们的视频编码器包揽了两项世界冠军。。。&lt;/p>
&lt;p>话说的倒都是实话，可就是没说全。&lt;/p>
&lt;p>这个说法的确没什么错，况且近期阿里的负面有点儿多，宣传奇点编码器得奖是个冲喜的好办法。&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/dk3gg2/1616076594043-65b18125-f709-4049-9c3f-2c50859100b2.jpeg" alt="">&lt;/p>
&lt;p>但是这件事翻车就翻车在了，通稿把奇点编码器渲染的有点神 —— 压缩上千倍画质无损，两项世界第一。&lt;/p>
&lt;p>稍微对这方面技术不太了解的小伙伴看着都会发懵，这个就有点儿误导人了。。。&lt;/p>
&lt;p>小明考试拿了 100 分，可喜可贺。&lt;/p>
&lt;p>小明和同班十几个人一起考出了 100 分的好成绩，势均力敌。&lt;/p>
&lt;p>小明和同班十几个人一起考出了 100 分的好成绩，但只有小明家张灯结彩、走街串巷，仿佛完成了一件前无古人后无来者的壮举。。。&lt;/p>
&lt;p>也不知道最后尴尬的会是谁。&lt;/p></description></item><item><title>Docs: 图像的编码与解码</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/8.%E9%80%9A%E7%94%A8%E6%8A%80%E6%9C%AF/%E7%BC%96%E7%A0%81%E8%A7%A3%E7%A0%81%E4%B8%8E%E5%8D%8F%E8%AE%AE/%E5%9B%BE%E5%83%8F%E7%9A%84%E7%BC%96%E7%A0%81%E4%B8%8E%E8%A7%A3%E7%A0%81/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/8.%E9%80%9A%E7%94%A8%E6%8A%80%E6%9C%AF/%E7%BC%96%E7%A0%81%E8%A7%A3%E7%A0%81%E4%B8%8E%E5%8D%8F%E8%AE%AE/%E5%9B%BE%E5%83%8F%E7%9A%84%E7%BC%96%E7%A0%81%E4%B8%8E%E8%A7%A3%E7%A0%81/</guid><description>
&lt;blockquote>
&lt;p>参考： &lt;a href="https://en.wikipedia.org/wiki/Pixel">Wiki-Pixel(像素)&lt;/a> &amp;gt; &lt;a href="https://en.wikipedia.org/wiki/Image_resolution">Wiki-Image resolution(分辨率)&lt;/a> &amp;gt; &lt;a href="https://en.wikipedia.org/wiki/Raster_graphics">Wiki-Raster graphics(光栅图像)&lt;/a>&lt;/p>
&lt;/blockquote>
&lt;p>图像的编码 和 字符的编码 其实本质上都是使用二进制来进行 编/解码。&lt;/p>
&lt;h1 id="图像">图像&lt;/h1>
&lt;p>想要了解图像的编码/解码，首先要明确一下图片的组成
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/azfrs3/1616478942730-94a24042-83ae-40c0-865a-d13c1164c61b.png" alt="encoding.png">
这个图，如果放到编辑器中，然后无限放大，会看到这种效果：
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/azfrs3/1616478986453-7a25a9b3-f527-4491-b565-9154ca324d7f.png" alt="image.png">
从这里可以看到，一张图片，其实就是很多很多的小方块组成的，每个小方块，都称之为 &lt;strong>Pixel(像素)&lt;/strong>。&lt;/p>
&lt;h2 id="piexl像素">Piexl(像素)&lt;/h2>
&lt;p>&lt;strong>Picture Element(图像元素，简称 Pel)&lt;/strong>，也就是常常听说的 &lt;strong>Piexl(像素)&lt;/strong>。在&lt;a href="https://en.wikipedia.org/wiki/Digital_imaging">数字成像中&lt;/a>，像素是&lt;a href="https://en.wikipedia.org/wiki/Raster_graphics">光栅图像&lt;/a>中最小的可寻址元素，或者是&lt;a href="https://en.wikipedia.org/wiki/All_points_addressable">全点可寻址&lt;/a> &lt;a href="https://en.wikipedia.org/wiki/Display_device">显示设备中&lt;/a>的最小可寻址元素；因此，它是屏幕上所显示图片的最小可控元素。&lt;/p>
&lt;p>每个像素都是原始图像的&lt;a href="https://en.wikipedia.org/wiki/Sampling_(signal_processing)">样本&lt;/a>；通常，更多的样本会提供对原件的更准确的表示。每个像素的&lt;a href="https://en.wikipedia.org/wiki/Intensity_(physics)">强度&lt;/a>是可变的。在彩色成像系统中，颜色通常由三个或四个分量强度来表示，例如&lt;a href="https://en.wikipedia.org/wiki/RGB_color_model">红色，绿色和蓝色&lt;/a>，或&lt;a href="https://en.wikipedia.org/wiki/CMYK_color_model">青色，品红色，黄色和黑色&lt;/a>。&lt;/p>
&lt;blockquote>
&lt;p>在一些语境中(如描述&lt;a href="https://en.wikipedia.org/wiki/Camera_sensor">相机传感器&lt;/a>)，_像素 &lt;em>指的是多组分表示的单个标量元素（称为_感光点_在相机传感器上下文中，虽然&lt;/em>&lt;a href="https://en.wiktionary.org/wiki/sensel">传感器个体&lt;/a>_有时使用），&lt;a href="https://en.wikipedia.org/wiki/Pixel#cite_note-3">[3]&lt;/a>而在其它上下文中它可以指的是空间位置的一组分量强度。&lt;/p>
&lt;/blockquote>
&lt;p>一般情况下，电脑中的颜色都是使用三原色混合而成，比如：
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/azfrs3/1616548024130-3762a0c9-6f90-4c9a-811b-e5dc6203bf0e.png" alt="image.png">
可以看到，每个颜色都有一个数字表示，而 RGB 就是三原色，不用强度的三原色，就会组成不同强度的新颜色。&lt;/p>
&lt;h2 id="image-resolution图像分辨率">Image Resolution(图像分辨率)&lt;/h2>
&lt;p>**Image Resolution(图像分辨率) **指图像可以存在的细节，分辨率仅适用于 &lt;a href="https://en.wikipedia.org/wiki/Raster_graphics">光栅图像&lt;/a>。一般是指单位英寸中所包含的像素个数。
用白话说，分辨率就是判断一张图片清晰度的重要标志，而上文提到的 像素，就是分辨率的一部分。通常，分辨率可以通过如下几种方式来判断&lt;/p>
&lt;ul>
&lt;li>像素数&lt;/li>
&lt;li>空间分辨率&lt;/li>
&lt;li>光谱分辨率&lt;/li>
&lt;li>时间分辨率&lt;/li>
&lt;li>辐射分辨率&lt;/li>
&lt;/ul>
&lt;p>大部分时候，其实主要就是以像素的数量来决定一张图像的分辨率，比如：
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/azfrs3/1616547515643-ebb48cfe-1919-453c-96d5-02d3b173118b.png" alt="image.png">
而 像素密度 与 像素总数，又是判断分辨率所具有像素数的两个重要指标&lt;/p>
&lt;ul>
&lt;li>&lt;strong>像素密度&lt;/strong> # 单位长度内的像素数量除以单位长度，单位为 PPI（Pixels Per Inch）。像素密度越高，说明像素越密集，5PPI 表示每英寸有 5 个像素，500PPI 表示每英寸有 500 个像素，PPI 的数值高，图片和视频的清晰度就更高。&lt;/li>
&lt;li>&lt;strong>像素总数&lt;/strong> # 图片、影像的单独一帧图所含像素的数量，单位为像素，计算方式为长边的像素个数乘以短边的像素个数。&lt;/li>
&lt;/ul>
&lt;p>宽度为 2048 像素，高度为 1536 像素的图像总计 2048×1536 = 3,145,728 像素或 3.1 兆像素。人们可以将其称为 2048 x 1536 或 3.1 兆像素的图像。如果以大约 28.5 英寸宽打印，则图像将是质量很差的图像（72ppi），但是如果以大约 7 英寸宽打印，则图像的质量将非常好（300ppi）&lt;/p>
&lt;p>这也就解释了，为什么一张图像，放在很小的地方看上去很清晰，而放在很大的地方，看上去就就相当模糊(其实就是代表像素的小方块都显示出来了)&lt;/p>
&lt;p>人眼可以识别的图形是有限的，当一个像素一直缩小，从人类眼中，就好像是一个点，而很多很多不用颜色的点，组成了一张图像，也就是我们所说的非常清晰的图像。&lt;/p>
&lt;h2 id="图像的组成">图像的组成&lt;/h2>
&lt;p>像素是组成图像最小单位，每个像素都是一个纯色的色块&lt;/p>
&lt;h1 id="位图-与-矢量图">位图 与 矢量图&lt;/h1>
&lt;blockquote>
&lt;p>上文描述的图像，都是指位图&lt;/p>
&lt;/blockquote>
&lt;p>&lt;strong>Raster Graphic(光栅图像)&lt;/strong> 是一种点阵数据结构，它表示可通过计算机显示器、纸张或其他显示介质查看的大致矩形的像素网络(像素点)。&lt;strong>也称为 Bitmap(位图)。&lt;/strong>
**
**Vector Graphics(矢量图象) **是根据笛卡尔平面上的点定义的计算机图像，这些点通过直线和曲线连接以形成多边形和其他形状。&lt;/p>
&lt;p>位图无法无限放大，不管放大到多少，最后都是一个一个的像素。而矢量图则不会出现这种问题，矢量图是基于数学方程的几何图形，不管放大多少倍，也不会失真。
可是矢量图一般只能表示一些简单的图形，因为需要很明显的线条曲线。常用来制作品牌 logo、指示牌等等。而色彩丰富的图像，比如人像等等，就无法使用简单的图形或者数学方程来表示了。&lt;/p>
&lt;p>所以矢量图常用来做设计，而位图则一般用来描述照片。&lt;/p>
&lt;h1 id="图像的编码">图像的编码&lt;/h1>
&lt;p>图像编码的原理，就是把每个像素的颜色，转换成数字，然后按照顺序，把所有像素的颜色数值都存储起来。并且给每一个像素一个坐标，由 像素坐标 与 像素颜色 组成的，就是电脑中的一张图像，而 像素坐标 与 像素颜色 都是可以使用字符表示，进而转换为二进制的。&lt;/p>
&lt;p>图像的清晰度越高，像素数也就越多，转换成二进制所需要占用的空间也就越高~~这也是为什么一张图片要比一串字符占用空间要大这么多的重要原因。&lt;/p>
&lt;p>因此，也就催生出了图像压缩的需求。需要根据某种算法，可以缩小图像所占用的空间。&lt;/p>
&lt;h2 id="图像压缩">图像压缩&lt;/h2>
&lt;p>那些 jpeg、png 等等格式，都是指压缩的方式，与字符编码中 UTF-8 之于 Unicode 类似。&lt;/p></description></item><item><title>Docs: 问题实例</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/8.%E9%80%9A%E7%94%A8%E6%8A%80%E6%9C%AF/message-queue%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/rabbitmq/%E9%97%AE%E9%A2%98%E5%AE%9E%E4%BE%8B/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/8.%E9%80%9A%E7%94%A8%E6%8A%80%E6%9C%AF/message-queue%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/rabbitmq/%E9%97%AE%E9%A2%98%E5%AE%9E%E4%BE%8B/</guid><description>
&lt;h1 id="heading">&lt;/h1>
&lt;h2 id="waiting-for-mnesia-tableshttpsgithubcomrabbitmqcluster-operatorissues480-报错">&lt;a href="https://github.com/rabbitmq/cluster-operator/issues/480">Waiting for Mnesia tables&lt;/a> 报错&lt;/h2>
&lt;p>另一个 issue：&lt;a href="https://github.com/bitnami/charts/issues/3783#">https://github.com/bitnami/charts/issues/3783#&lt;/a>，这是 bitnami 上的 rabbitmq helm 的报错 issue&lt;/p>
&lt;p>多个节点同时重启，出现该问题，该问题主要是因为各个节点之间无法有效得正常通信导致的&lt;/p></description></item><item><title>Docs: 音频的编码与解码</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/8.%E9%80%9A%E7%94%A8%E6%8A%80%E6%9C%AF/%E7%BC%96%E7%A0%81%E8%A7%A3%E7%A0%81%E4%B8%8E%E5%8D%8F%E8%AE%AE/%E9%9F%B3%E9%A2%91%E7%9A%84%E7%BC%96%E7%A0%81%E4%B8%8E%E8%A7%A3%E7%A0%81/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/8.%E9%80%9A%E7%94%A8%E6%8A%80%E6%9C%AF/%E7%BC%96%E7%A0%81%E8%A7%A3%E7%A0%81%E4%B8%8E%E5%8D%8F%E8%AE%AE/%E9%9F%B3%E9%A2%91%E7%9A%84%E7%BC%96%E7%A0%81%E4%B8%8E%E8%A7%A3%E7%A0%81/</guid><description>
&lt;p>声音的本质就是波，波都是有频率的，频率就是指波在一秒钟震动的次数，单位是 Hz(赫兹)。&lt;/p>
&lt;p>计算机除了记录声音的频率，还要记录在不同频率上，声音的幅度大小。&lt;/p>
&lt;p>而想要出现声音，其实是离不开时间的，没有时间的流逝，也就不会产生声音&lt;/p>
&lt;p>所以，计算机就需要对声音进行采样，记录每时每刻声音的频率和幅度，采样频率越高，声音也就越逼真&lt;/p>
&lt;p>远程同话一般是每秒8000次的采样频率，而音乐CD则是每秒44100次的采样频率&lt;/p>
&lt;p>每次采样，都会将频率和幅度，然后将其转换为字符，进而编码为二进制。&lt;/p></description></item><item><title>Docs: 在CentOS7上安装RocketMQ 4.7.1解决fastjson低版本漏洞问题</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/8.%E9%80%9A%E7%94%A8%E6%8A%80%E6%9C%AF/message-queue%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/rocketmq/%E5%9C%A8centos7%E4%B8%8A%E5%AE%89%E8%A3%85rocketmq-4.7.1%E8%A7%A3%E5%86%B3fastjson%E4%BD%8E%E7%89%88%E6%9C%AC%E6%BC%8F%E6%B4%9E%E9%97%AE%E9%A2%98/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/8.%E9%80%9A%E7%94%A8%E6%8A%80%E6%9C%AF/message-queue%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/rocketmq/%E5%9C%A8centos7%E4%B8%8A%E5%AE%89%E8%A3%85rocketmq-4.7.1%E8%A7%A3%E5%86%B3fastjson%E4%BD%8E%E7%89%88%E6%9C%AC%E6%BC%8F%E6%B4%9E%E9%97%AE%E9%A2%98/</guid><description>
&lt;p>&lt;!-- raw HTML omitted -->&lt;!-- raw HTML omitted -->### 文章目录- 在 CentOS7 上安装 RocketMQ 4.7.1 解决 fastjson 低版本漏洞问题&lt;/p>
&lt;ul>
&lt;li>
&lt;p>前言&lt;/p>
&lt;/li>
&lt;li>
&lt;p>安装过程&lt;/p>
&lt;/li>
&lt;li>
&lt;p>下载和解压 RocketMQ&lt;/p>
&lt;/li>
&lt;li>
&lt;p>调低 RocketMQ 的 JVM 大小&lt;/p>
&lt;/li>
&lt;li>
&lt;p>bin/runserver.sh&lt;/p>
&lt;/li>
&lt;li>
&lt;p>bin/runserver.sh&lt;/p>
&lt;/li>
&lt;li>
&lt;p>bin/tools.sh&lt;/p>
&lt;/li>
&lt;li>
&lt;p>启动 Name Server&lt;/p>
&lt;/li>
&lt;li>
&lt;p>启动 Broker&lt;/p>
&lt;/li>
&lt;li>
&lt;p>查看 RocketMQ 进程&lt;/p>
&lt;/li>
&lt;li>
&lt;p>测试 RocketMQ&lt;/p>
&lt;/li>
&lt;li>
&lt;p>测试发送消息和接收消息&lt;/p>
&lt;/li>
&lt;li>
&lt;p>关闭 RocketMQ&lt;/p>
&lt;/li>
&lt;li>
&lt;p>关闭 Broker&lt;/p>
&lt;/li>
&lt;li>
&lt;p>关闭 Name Server&lt;/p>
&lt;/li>
&lt;li>
&lt;p>修改 Name Server 的端口&lt;/p>
&lt;/li>
&lt;li>
&lt;p>安装 RocketMQ 控制台&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Troubleshooting&lt;/p>
&lt;/li>
&lt;li>
&lt;p>参考文档&lt;/p>
&lt;/li>
&lt;li>
&lt;p>扩展阅读 &lt;!-- raw HTML omitted -->&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h1 id="在-centos7-上安装-rocketmq-471-解决-fastjson-低版本漏洞问题a-namenrrtna-前言">在 CentOS7 上安装 RocketMQ 4.7.1 解决 fastjson 低版本漏洞问题&lt;!-- raw HTML omitted -->&lt;!-- raw HTML omitted -->## 前言&lt;/h1>
&lt;p>阿里的 fastjson 的低版本（&amp;lt;=1.2.68）被爆出有安全漏洞，而 RocketMQ 4.7.0 使用了 fastjson 1.2.62，因此需要将 RocketMQ 升级到 RocketMQ 4.7.1(fastjson 1.2.69)。本文描述了在 CentOS7 上安装 RocketMQ 4.7.1 的过程，仅作为开发测试环境使用：&lt;/p>
&lt;ol>
&lt;li>
&lt;p>单机部署，Name Server 和 Broker 都装在一台服务器上；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>调低了 RocketMQ 默认的 JVM 大小；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>没有设置开机自启动和守护进程。
&lt;!-- raw HTML omitted -->&lt;!-- raw HTML omitted -->## 安装过程
服务器上已经安装了 OpenJDK 8，并设置了 JAVA_HOME。
&lt;!-- raw HTML omitted -->&lt;!-- raw HTML omitted -->### 下载和解压 RocketMQ
在 RocketMQ 官网上找到下载 RocketMQ 4.7.1 的链接，下载和解压 RocketMQ： # 下载
wget &lt;a href="http://ftp.cuhk.edu.hk/pub/packages/apache.org/rocketmq/4.7.1/rocketmq-all-4.7.1-bin-release.zip">http://ftp.cuhk.edu.hk/pub/packages/apache.org/rocketmq/4.7.1/rocketmq-all-4.7.1-bin-release.zip&lt;/a> # 解压
unzip rocketmq-all-4.7.1-bin-release.zip # 安装到/usr/local/rocketmq
mv rocketmq-all-4.7.1-bin-release /usr/local
ln -s /usr/local/rocketmq-all-4.7.1-bin-release /usr/local/rocketmq
1
2
3
4
5
6
7
8
91
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
Plain Text
&lt;!-- raw HTML omitted -->&lt;!-- raw HTML omitted -->### 调低 RocketMQ 的 JVM 大小
RocketMQ 的默认 JVM 太大，不适合在开发测试环境中使用，需要调低 JVM 大小。在 RocketMQ 的安装目录（本例为&lt;code>/usr/local/rocketmq&lt;/code>)，查找 sh 脚本中的 JVM 参数设置：
find . -name &amp;lsquo;*.sh&amp;rsquo; | xargs egrep &amp;lsquo;Xms'1
Plain Text 需要修改以下 sh 脚本的 JVM 参数：&lt;/p>
&lt;/li>
&lt;/ol>
&lt;ul>
&lt;li>
&lt;p>bin/runserver.sh&lt;/p>
&lt;/li>
&lt;li>
&lt;p>bin/runbroker.sh&lt;/p>
&lt;/li>
&lt;li>
&lt;p>bin/tools.sh&lt;/p>
&lt;blockquote>
&lt;p>修改前记得先备份相应脚本，具体 JVM 大小根据实际情况设定。
bin/runserver.sh 修改前：
JAVA_OPT=&amp;quot;${JAVA_OPT} -server -Xms4g -Xmx4g -Xmn2g -XX:MetaspaceSize=128m -XX:MaxMetaspaceSize=320m&amp;quot;1
Plain Text 修改后：
JAVA_OPT=&amp;quot;${JAVA_OPT} -server -Xms256m -Xmx256m -Xmn128m -XX:MetaspaceSize=128m -XX:MaxMetaspaceSize=320m&amp;quot;1
Plain Textbin/runserver.sh修改前：
JAVA_OPT=&amp;quot;${JAVA_OPT} -server -Xms4g -Xmx4g -Xmn2g -XX:MetaspaceSize=128m -XX:MaxMetaspaceSize=320m&amp;quot;1
Plain Text 修改后：
JAVA_OPT=&amp;quot;${JAVA_OPT} -server -Xms256m -Xmx256m -Xmn128m -XX:MetaspaceSize=128m -XX:MaxMetaspaceSize=320m&amp;quot;1
Plain Textbin/tools.sh修改前：
JAVA_OPT=&amp;quot;${JAVA_OPT} -server -Xms1g -Xmx1g -Xmn256m -XX:MetaspaceSize=128m -XX:MaxMetaspaceSize=128m&amp;quot;1
Plain Text 修改后：
JAVA_OPT=&amp;quot;${JAVA_OPT} -server -Xms256m -Xmx256m -Xmn128m -XX:MetaspaceSize=128m -XX:MaxMetaspaceSize=128m&amp;quot;1
Plain Text
&lt;!-- raw HTML omitted -->&lt;!-- raw HTML omitted -->### 启动 Name Server # 后台启动
nohup sh bin/mqnamesrv &amp;gt;/dev/null 2&amp;gt;&amp;amp;1 &amp;amp;1
2
Plain Text
可以将启动 Name Server 命令保存为脚本，以方便下次启动。&lt;!-- raw HTML omitted -->&lt;!-- raw HTML omitted -->### 启动 Broker
启动 Broker 时需要指定要连接的 Name Server：
# 后台启动
nohup sh bin/mqbroker -n localhost:9876 &amp;gt;/dev/null 2&amp;gt;&amp;amp;1 &amp;amp;1
2
Plain Text
可以将启动 Broker 命令保存为脚本，以方便下次启动。&lt;!-- raw HTML omitted -->&lt;!-- raw HTML omitted -->### 查看 RocketMQ 进程 ps -ef | grep -v grep | grep rocketmq
11
2
3
Plain Text
&lt;!-- raw HTML omitted -->&lt;!-- raw HTML omitted -->## 测试 RocketMQ&lt;!-- raw HTML omitted -->&lt;!-- raw HTML omitted -->### 测试发送消息和接收消息
使用 RocketMQ 自带的消息生产者和消费者示例来测试发送消息和接收消息：
export NAMESRV_ADDR=localhost:9876
sh bin/tools.sh org.apache.rocketmq.example.quickstart.Producer
sh bin/tools.sh org.apache.rocketmq.example.quickstart.Consumer
1
2
31
2
3
4
5
6
7
Plain Text
&lt;!-- raw HTML omitted -->&lt;!-- raw HTML omitted -->## 关闭 RocketMQ&lt;!-- raw HTML omitted -->&lt;!-- raw HTML omitted -->### 关闭 Broker sh bin/mqshutdown broker
11
2
3
Plain Text
可以将关闭 Broker 命令保存为脚本，以方便下次关闭。&lt;!-- raw HTML omitted -->&lt;!-- raw HTML omitted -->### 关闭 Name Server sh bin/mqshutdown namesrv
11
2
3
Plain Text
关闭 Name Server 前需要先关闭 Broker；可以将关闭 Name Server 命令保存为脚本，以方便下次关闭。&lt;!-- raw HTML omitted -->&lt;!-- raw HTML omitted -->## 修改 Name Server 的端口
RocketMQ Name Server 的默认端口为 9876，可以通过以下方法修改 Name Server 的端口：&lt;/p>
&lt;/blockquote>
&lt;/li>
&lt;/ul>
&lt;ol>
&lt;li>
&lt;p>新增一个 Name Server 配置文件 namesrv.conf，保存内容为：listenPort=100761&lt;/p>
&lt;/li>
&lt;li>
&lt;p>1&lt;/p>
&lt;/li>
&lt;li>
&lt;p>启动 Name Server 时指定配置文件：nohup sh bin/mqnamesrv -c namesrv.conf &amp;gt;/dev/null 2&amp;gt;&amp;amp;1 &amp;amp;1&lt;/p>
&lt;/li>
&lt;li>
&lt;p>1&lt;/p>
&lt;/li>
&lt;li>
&lt;p>查看 RocketMQ 进程：ps -ef | grep rocketmq1&lt;/p>
&lt;/li>
&lt;li>
&lt;p>1&lt;/p>
&lt;/li>
&lt;li>
&lt;p>查看 RocketMQ Name Server 的端口号：netstat -tnlp | grep &amp;lt;nameserver_pid&amp;gt;1&lt;/p>
&lt;/li>
&lt;li>
&lt;p>1&lt;/p>
&lt;/li>
&lt;li>
&lt;p>修改后 Broker 需要指定新的 Name Server 地址（端口）。
&lt;!-- raw HTML omitted -->&lt;!-- raw HTML omitted -->## 安装 RocketMQ 控制台 docker run -d &amp;ndash;name console &lt;br>
-e &amp;ldquo;JAVA_OPTS=-Drocketmq.namesrv.addr=172.38.40.247:9876 -Dcom.rocketmq.sendMessageWithVIPChannel=false&amp;rdquo; &lt;br>
-p 8080:8080 &lt;br>
-t styletang/rocketmq-console-ng1
2
3
4
Plain Text 克隆 rocketmq-externals 项目，并编译 rocketmq-console。命令示例：
git clone &lt;a href="https://github.com/apache/rocketmq-externals.git">https://github.com/apache/rocketmq-externals.git&lt;/a>
cd rocketmq-externals/rocketmq-console
mvn clean package -Dmaven.test.skip=true1
2
3
Plain Text 将&lt;code>target/rocketmq-console-ng*.jar&lt;/code> 放到和 RocketMQ 安装目录（本例为&lt;code>/usr/local/rocketmq&lt;/code>)下。在 RocketMQ 安装目录下新建一个启动 RocketMQ 控制台的脚本来启动 RocketMQ 控制台：
nohup java -jar rocketmq-console-ng*.jar &amp;ndash;server.port=8080 &amp;ndash;rocketmq.config.namesrvAddr=localhost:9876 &amp;gt; /dev/null 2&amp;gt;&amp;amp;1 &amp;amp;1
Plain Text 默认 RocketMQ 控制台不需要密码登录，请参考 RocketMQ 使用文档 进行配置。参见：&lt;/p>
&lt;/li>
&lt;/ol>
&lt;ul>
&lt;li>
&lt;p>&lt;a href="https://github.com/apache/rocketmq-externals">https://github.com/apache/rocketmq-externals&lt;/a>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://github.com/apache/rocketmq-externals/tree/master/rocketmq-console">https://github.com/apache/rocketmq-externals/tree/master/rocketmq-console&lt;/a>
&lt;!-- raw HTML omitted -->&lt;!-- raw HTML omitted -->## Troubleshooting
问题 1: 启动 Name Server 和 Broker，或测试时报错&lt;code>Please set the JAVA_HOME variable in your environment, We need java(x64)!&lt;/code> 但是系统已经安装了 OpenJDK8，并且已经设置了 JAVA_HOME。解决方法: 运行&lt;code>which java&lt;/code>来查看 java 的路径，比如为&lt;code>/usr/bin/java&lt;/code>。修改 bin/runserver.sh 和 bin/runbroker.sh 和 bin/tools.sh，注释掉校验 JAVA_HOME 语句，并明确指定 JAVA 路径： #[ ! -e &amp;ldquo;$JAVA_HOME/bin/java&amp;rdquo; ] &amp;amp;&amp;amp; JAVA_HOME=$HOME/jdk/java
#[ ! -e &amp;ldquo;$JAVA_HOME/bin/java&amp;rdquo; ] &amp;amp;&amp;amp; JAVA_HOME=/usr/java #[ ! -e &amp;ldquo;$JAVA_HOME/bin/java&amp;rdquo; ] &amp;amp;&amp;amp; error_exit &amp;ldquo;Please set the JAVA_HOME variable in your environment, We need java(x64)!&amp;rdquo;
#export JAVA_HOME
export JAVA=&amp;quot;/usr/bin/java&amp;quot;1
2
3
4
5
6
Plain Text
&lt;!-- raw HTML omitted -->&lt;!-- raw HTML omitted -->## 参考文档- RocketMQ 安装部署教程详解&lt;/p>
&lt;/li>
&lt;li>
&lt;p>RocketMQ 安装详细说明
&lt;!-- raw HTML omitted -->&lt;!-- raw HTML omitted -->## 扩展阅读- 十分钟入门 RocketMQ&lt;/p>
&lt;/li>
&lt;li>
&lt;p>RocketMQ 核心设计理念&lt;/p>
&lt;/li>
&lt;li>
&lt;p>RocketMQ 中文文档(非官方）&lt;/p>
&lt;/li>
&lt;/ul></description></item><item><title>Docs: 整合RocketMq提示RemotingTooMuchRequestException: sendDefaultImpl call timeout</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/8.%E9%80%9A%E7%94%A8%E6%8A%80%E6%9C%AF/message-queue%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/rocketmq/%E6%95%B4%E5%90%88rocketmq%E6%8F%90%E7%A4%BAremotingtoomuchrequestexception_-senddefaultimpl-call-timeout/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/8.%E9%80%9A%E7%94%A8%E6%8A%80%E6%9C%AF/message-queue%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/rocketmq/%E6%95%B4%E5%90%88rocketmq%E6%8F%90%E7%A4%BAremotingtoomuchrequestexception_-senddefaultimpl-call-timeout/</guid><description>
&lt;p>在云服务器上安装 RocketMq 后，项目整合测试&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/xuvc3b/1616130360509-382458c2-a13e-443d-b718-bdf91b083bb3.png" alt="">&lt;/p>
&lt;p>启动好 nameServer 和 Broker 之后, 启动生产者会报这样的错误 &lt;/p>
&lt;pre>&lt;code>Exception in thread &amp;quot;main&amp;quot; org.apache.rocketmq.remoting.exception.RemotingTooMuchRequestException: sendDefaultImpl call timeout at org.apache.rocketmq.client.impl.producer.DefaultMQProducerImpl.sendDefaultImpl(DefaultMQProducerImpl.java:588) at org.apache.rocketmq.client.impl.producer.DefaultMQProducerImpl.send(DefaultMQProducerImpl.java:1223) at org.apache.rocketmq.client.impl.producer.DefaultMQProducerImpl.send(DefaultMQProducerImpl.java:1173) at org.apache.rocketmq.client.producer.DefaultMQProducer.send(DefaultMQProducer.java:214) at com.baojian.mob.base.producer.SyncProducer.main(SyncProducer.java:41)15:22:31.455 [NettyClientSelector_1] INFO RocketmqRemoting - closeChannel: close the connection to remote address[] result: true15:22:32.049 [NettyClientSelector_1] INFO RocketmqRemoting - closeChannel: close the connection to remote address[] result: true
&lt;/code>&lt;/pre>
&lt;p>1
Plain Text&lt;/p>
&lt;p>&lt;strong>原因： BrokerIP 展示的是云服务器的本地 IP，不是公网 IP;&lt;/strong>&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/xuvc3b/1616130360476-d1af823e-9914-4962-8925-f5cd19599ee0.png" alt="">&lt;/p>
&lt;p>&lt;strong>解决方法：&lt;/strong>&lt;/p>
&lt;p>在 conf/broker.conf 中 加入 两行配置&lt;/p>
&lt;p>namesrvAddr = 你的公网 IP:9876&lt;/p>
&lt;p>brokerIP1=你的公网 IP&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/xuvc3b/1616130360465-f2ca9153-4a43-4646-b792-9f8dc7c5d986.png" alt="">&lt;/p>
&lt;p>&lt;strong>重新启动 broker&lt;/strong>&lt;/p>
&lt;p>启动 broker 的指令要修改下, 要将这个配置文件指定加载&lt;/p>
&lt;pre>&lt;code>nohup sh mqbroker -n localhost:9876 -c ../conf/broker.conf autoCreateTopicEnable=true &amp;amp;
&lt;/code>&lt;/pre>
&lt;p>1
Plain Text&lt;/p></description></item><item><title>Docs: 字符的编码与解码</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/8.%E9%80%9A%E7%94%A8%E6%8A%80%E6%9C%AF/%E7%BC%96%E7%A0%81%E8%A7%A3%E7%A0%81%E4%B8%8E%E5%8D%8F%E8%AE%AE/%E5%AD%97%E7%AC%A6%E7%9A%84%E7%BC%96%E7%A0%81%E4%B8%8E%E8%A7%A3%E7%A0%81/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/8.%E9%80%9A%E7%94%A8%E6%8A%80%E6%9C%AF/%E7%BC%96%E7%A0%81%E8%A7%A3%E7%A0%81%E4%B8%8E%E5%8D%8F%E8%AE%AE/%E5%AD%97%E7%AC%A6%E7%9A%84%E7%BC%96%E7%A0%81%E4%B8%8E%E8%A7%A3%E7%A0%81/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Character_encoding">Wiki,Character encoding&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/ASCII">Wiki-ASCII&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Unicode">Wiki-Unicode&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://home.unicode.org/">Unicode 官网&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://unicode.org/main.html">Unicode 技术网站&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.unicode.org/charts/unihan.html">Unicode 字符集汉子数据库&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Variable-length_code">Wiki,Variable-length code&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/UTF-8">Wiki-UTF-8&lt;/a>&lt;/li>
&lt;li>&lt;a href="http://www.ruanyifeng.com/blog/2007/10/ascii_unicode_and_utf-8.html">阮一峰博客&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://mp.weixin.qq.com/s/vTh4LP8_Qew-S8s-3KqwJA">公众号,k8s 技术圈-计算机字符编码的前世今生&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.bilibili.com/video/av246038798">B 站,Golang 合辑-P1 string(这个 P 讲的就是字符的编码与解码)&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>我们知道计算机只认识二进制数据，其他格式的数据都需要转换成二进制才能被计算机处理，也就是说我们在计算机上看到的文本、视频、可执行程序等格式的文件，最终都会转换成二进制数据交给计算机处理&lt;/p>
&lt;p>计算机中最小的数据单位是 &lt;strong>bit&lt;/strong>，也叫&lt;strong>二进制位(简称：位)&lt;/strong>，每一个 bit 都有 0 和 1 两种状态，最早的计算机在设计时采用了 &lt;strong>8 个 bit 作为一个 Byte(字节)&lt;/strong>，所以一个字节能表示的最大整数就是二进制的 11111111 等于十进制的 255，一共 256 个数字(即.0~255)，想要表示更大的整数就必须要用多个字节，例如两个字节可以表示最大的整数就是二进制的 1111111111111111，共 16 位，等于十进制的 65535。&lt;/p>
&lt;p>更多的字节，就可以表示更大的数值范围，比如 32 位，最大可以表示为 4,294,967,295，我们平时说的 32 位电脑、64 位电脑，也是同一个意思，所以就说 32 位电脑，没法传输 4 G 以上的文件，就是因为其最大可以表示的数字就是 4,294,967,295，更大的文件，已经无法识别了。整数可以这么表示，那么字符怎么办呢？一堆二进制的 0 和 1，任何计算都无法算出字母 A 吧？~o(╯□╰)o&lt;/p>
&lt;p>聪明的人类啊~~~如果无法通过计算得到，那么就中转一下，人为规定就好了~比如：&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>字符&lt;/th>
&lt;th>十进制编号&lt;/th>
&lt;th>二进制编号&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>A&lt;/td>
&lt;td>65&lt;/td>
&lt;td>0100 0001&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>B&lt;/td>
&lt;td>66&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&amp;hellip;&amp;hellip;&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>a&lt;/td>
&lt;td>97&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&amp;hellip;&amp;hellip;&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>要存储字符时，就存储这个数值；要读取字符时，按照映射关系，找到这个字符；就像这样，收录许多字符，然后给它们一一编号，得到一个字符与编号的对照表，这就是 &lt;strong>Character sets(字符集)&lt;/strong>，经过这么多年的发展，大家对这个术语有很多种叫法：Character encoding(字符编码)、Character map(字符映射)、Code page(代码页) 都可以表示同一个概念。&lt;/p>
&lt;h1 id="ascii">ASCII&lt;/h1>
&lt;p>由于计算机是由美国人发明的，在 1967 年美国人制订了一套&lt;strong>字符集&lt;/strong>，规定了包含大小写字母、数字和一些符号共计 128 个字符与二进制数字的对应关系，这一套字符编码被称为 &lt;strong>American Standard Code for Information Interchange(美国标准信息交换码，简称 ASCII)&lt;/strong>，ASCII 一直沿用至今。&lt;/p>
&lt;p>英文比较简单，用 128 个符号编码就够了，就算需要其他的对应关系，也只需要扩展一下 ASCII 即可，一个 Byte，一共可以表示 256 个字符。但是用来表示中文就不够了，单单汉字就有超过 8 万个，所以就有了针对中文的编码标准出现，例如我们经常见到的 GB2312 字符集，使用两个字节表示一个汉字，理论上最多可以表示 65535 个；没有繁体字也不行啊，所以出现了 BIG 5 字符集；但是依然有许多字符没被收录。&lt;/p>
&lt;p>世界上有上百种语言，每种语言都有自己的编码标准，例如韩文编码 EUC_KR，日文编码 Shift_JIS，俄文编码 KOI8-R，为了促进互联网的发展，本着全球化统一标准的目的，制作一个通用字符集，&lt;strong>Unicode 应运而生。&lt;/strong>&lt;/p>
&lt;h1 id="unicode">Unicode&lt;/h1>
&lt;p>**Universal Coded Character Set(通用编码的字符集，简称 Unicode)，&lt;strong>在汉语中又称为&lt;/strong> 万国码、国际码、统一码，**它于 1990 年开始研发，并于 1994 年正式公布。&lt;strong>Unicode&lt;/strong> 对世界上大部分的文字系统进行了整理，使每一个文字符号都用独一无二的编码表示，当前 Unicode 最新的版本为 2019 年 5 月公布的 12.1.0，已经收录超过 13 万个字符，很明显 2 个字节已经无法保证所有字符都独一无二了，实际上最新的 Unicode 规定可以占用 4 字节来表示一个字符，理论上最多能表示 231 共计 2147483648 个字符。&lt;/p>
&lt;p>Unicode 使用 16 进制格式来表示一个字符，比如：
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/gptlcx/1616470249845-a210b975-ff93-4945-ba7e-aa06332e2473.png" alt="image.png">
&lt;code>\u&lt;/code> 是一个用来表示 Unicode 的标记。当计算机识别到这个标记时，就会使用 Unicode 进行解码。&lt;code>4f60&lt;/code> 表示 &lt;code>你&lt;/code>，&lt;code>597d&lt;/code> 表示 &lt;code>好&lt;/code>。&lt;/p>
&lt;p>所以随着技术的发展，Unicode 慢慢成为了一种 &lt;strong>Unicode Standard(Unicode 标准)&lt;/strong>&lt;/p>
&lt;h2 id="unicode-的问题">Unicode 的问题&lt;/h2>
&lt;p>需要注意的是，Unicode 只是一个字符集，它只规定了符号的二进制代码，却没有规定这个二进制代码应该如何存储。&lt;/p>
&lt;p>比如，汉字 &lt;code>严&lt;/code> 的 Unicode 是十六进制数 &lt;code>4E25&lt;/code>，转换成二进制数足足有 15 个 bit 位(&lt;code>100111000100101&lt;/code>)，也就是说，这个符号的表示至少需要 2 个字节。表示其他更大的符号，可能需要 3 个字节或者 4 个字节，甚至更多。&lt;/p>
&lt;p>这里就有两个严重的问题，第一个问题是，如何才能区别 Unicode 和 ASCII ？计算机怎么知道三个字节表示一个符号，而不是分别表示三个符号呢？第二个问题是，我们已经知道，英文字母只用一个字节表示就够了，如果 Unicode 统一规定，每个符号用三个或四个字节表示，那么每个英文字母前都必然有二到三个字节是 0，这对于存储来说是极大的浪费，文本文件的大小会因此大出二三倍，这是无法接受的。&lt;/p>
&lt;p>它们造成的结果是：&lt;/p>
&lt;ul>
&lt;li>出现了 Unicode 的多种存储方式，也就是说有许多种不同的二进制格式，可以用来表示 Unicode。&lt;/li>
&lt;li>Unicode 在很长一段时间内无法推广，直到互联网的出现。&lt;/li>
&lt;/ul>
&lt;p>其中一种 Unicode 的存储方式如下：
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/gptlcx/1636861654037-a5bcf9bc-3a12-4958-b308-71955c77229d.png" alt="image.png">
上图左侧的几个字符，通过字符集找到对应的二进制编号之后，你怎么知道这一大串二进制内容，就是 &lt;code>eggo世界&lt;/code> 这几个字符呢？&lt;/p>
&lt;p>正常来说是这样的：
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/gptlcx/1636861731027-04bdc7aa-cedd-456a-abd9-e07793eff7ed.png" alt="image.png">
但是，也可以这样啊：
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/gptlcx/1636861748931-7e8aa489-51ae-4b25-bba2-efe7ec588bc7.png" alt="image.png">&lt;/p>
&lt;p>这里面的主要问题，就是 **划分字符边界。**所以，我们需要一种编码规则，通过字符集中的对照关系，对二进制进行编码。&lt;/p>
&lt;p>那么可以这样，不管编号多大多小，统一按照最长的来，位数不够，高位补零，效果如下：
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/gptlcx/1636861872939-a637432d-a70e-4606-b7e8-b9d50450b19b.png" alt="image.png">
这种方式，&lt;strong>Fixed-length codes(固定长度编码)&lt;/strong>。虽然字符边界的问题解决了，但是。。。。。这么存数据。。。非常浪费内存啊。。。。&lt;/p>
&lt;p>互联网的普及，强烈要求出现一种统一的编码方式。既然&lt;strong>固定长度编码&lt;/strong>不行，咱就来个 &lt;strong>Variable length code(可变长度编码)。&lt;/strong>&lt;/p>
&lt;p>**UTF-8 **就是在互联网上使用最广的一种 &lt;strong>Unicode 的编码规则&lt;/strong>。其他实现方式还包括 UTF-16（字符用两个字节或四个字节表示）和 UTF-32（字符用四个字节表示），不过在互联网上基本不用。&lt;/p>
&lt;h2 id="utf">UTF&lt;/h2>
&lt;p>&lt;strong>Unicode Transformation Formats(Unicode 转换格式，简称 UTF) 是&lt;/strong>根据 Unicode 实现的一种编码&lt;strong>规则&lt;/strong>。&lt;/p>
&lt;p>Unicode 标准定义了 &lt;strong>Unicode Transformation Formats(Unicode 转换格式，简称 UTF)&lt;/strong>。UTF-8、UTF-16、UTF-32 以及其他几种编码。最常用的编码是 UTF-8&lt;/p>
&lt;h3 id="utf-8">UTF-8&lt;/h3>
&lt;p>UTF-8 最大的一个特点，它是一种变长的编码方式。它可以使用 1~4 个 Bytes 表示一个字符(最多 32 个 bit)，根据不同的符号而变化字节长度。&lt;/p>
&lt;p>UTF-8 顾名思义，是一套以 8 位为一个编码单位的可变长编码。会&lt;strong>将一个 &amp;ldquo;Unicom 编号&amp;rdquo; 重新编码为 1 到 4 个字节&lt;/strong>&lt;/p>
&lt;p>既然是可变长度编码，那么小编号的字符就要少占字节，大编号的多占字节，但是，怎么划分字符的边界呢？有这么一种方案：&lt;/p>
&lt;p>UTF -8 首先定义一组模板，规范如下：&lt;/p>
&lt;ul>
&lt;li>首先获取到该字符的 Unicom 编号，然后根据该字符编号，决定对字符编码时所使用的模板，每个字符编码后存储时，所使用的 &amp;ldquo;Bytes 数&amp;rdquo; 不同&lt;/li>
&lt;li>如果字符需要存储 1 Bytes，则，字节的第一位设为 0。
&lt;ul>
&lt;li>后面 7 位为这个符号的 Unicode 码。因此对于英语字母，UTF-8 编码和 ASCII 码是相同的。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>如果字符需要存储 n Bytes(&lt;code>n &amp;gt; 1&lt;/code>)，则一个字节的前 n 个 bit 位都设为 1，第 n + 1 bit 位 设为 0，后面字节的前 两 bit 位 一律设为 10。
&lt;ul>
&lt;li>剩下的没有提及的二进制位，全部为这个符号的 Unicode 码。
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>Unicom 编号&lt;/th>
&lt;th>字节数&lt;/th>
&lt;th>最高位标识位&lt;/th>
&lt;th>模板(二进制)&lt;/th>
&lt;th>模板(十六进制)&lt;/th>
&lt;th>模板可以填充的 bit 数&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>0~127&lt;/td>
&lt;td>1 Bytes&lt;/td>
&lt;td>0&lt;/td>
&lt;td>0???????&lt;/td>
&lt;td>0000 0000-0000 007F&lt;/td>
&lt;td>7&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>128~2047&lt;/td>
&lt;td>2 Bytes&lt;/td>
&lt;td>110 和 10&lt;/td>
&lt;td>110????? 10??????&lt;/td>
&lt;td>0000 0080-0000 07FF&lt;/td>
&lt;td>5 + 6&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>2048~65535&lt;/td>
&lt;td>3 Bytes&lt;/td>
&lt;td>1110 和 10 和 10&lt;/td>
&lt;td>1110???? 10?????? 10??????&lt;/td>
&lt;td>0000 0800-0000 FFFF&lt;/td>
&lt;td>4 + 6 + 6&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>65536~4294967295&lt;/td>
&lt;td>4 Bytes&lt;/td>
&lt;td>11110 和 10 和 10 和 10&lt;/td>
&lt;td>11110??? 10?????? 10?????? 10??????&lt;/td>
&lt;td>0001 0000-0010 FFFF&lt;/td>
&lt;td>3 + 6 + 6 + 6&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>跟据上表，解读 UTF-8 编码非常简单。如果一个 Bytes 的第一个 bit 是 0，则这个字节单独就是一个字符；如果第一位是 1，则连续有多少个 1，就表示当前字符占用多少个字节。&lt;/p>
&lt;p>比如：&lt;/p>
&lt;ul>
&lt;li>&lt;code>01100101&lt;/code> 最高位为 0，则表示这是一个只占 1 Bytes 的字符，并且是在 0~127 编号范围内的字符。
&lt;ul>
&lt;li>除去标识 bit，剩下的 7 bit 就是该字符的二进制编号，即 &lt;code>1100101&lt;/code>，十进制是 &lt;code>101&lt;/code>，十六进制是 &lt;code>0065&lt;/code>，也就是字符 &lt;code>e&lt;/code>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;code>11100100 10111000 10010110&lt;/code> 最高位是 1110，则表示这是一个占用 3 bytes 的字符，并且要和后面两个以 10 开头的字节共同表示一个字符，并且是在 2048~65535 编号范围内的字符。
&lt;ul>
&lt;li>除去标识 bit，剩下的 bit 组合起来，即 &lt;code>01001110 00010110&lt;/code>，十进制是 &lt;code>19990&lt;/code>，十六进制是 &lt;code>4E16&lt;/code> ，也就是字符 &lt;code>世&lt;/code>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>字符 &lt;code>界&lt;/code> 在 Unicode 中的编号为 &lt;code>30028&lt;/code>，十六进制是 &lt;code>754C&lt;/code>，二进制是 &lt;code>01110101 01001100&lt;/code>，也就是说，如果想要使用 UTF-8 对字符编码后储存，则应该占用 3 Byes，所以应该使用 &lt;code>1110???? 10?????? 10??????&lt;/code> 模板。
&lt;ul>
&lt;li>将 &lt;code>界&lt;/code> 的二进制 bit 填入到模板中，得到 &lt;code>**1110**0111 **10**010101 **10**001100&lt;/code>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h3 id="总结">总结&lt;/h3>
&lt;p>虽然使用 UTF-8 对字符进行编码后，依然会浪费一部分 bit，但是对比&lt;a href="#DRcSC">定长编码&lt;/a>，已经极大得节省了存储空间。&lt;/p>
&lt;h2 id="unicode-与-utf-的区别">Unicode 与 UTF 的区别&lt;/h2>
&lt;p>简单来说：&lt;/p>
&lt;ul>
&lt;li>Unicode 是 字符集，即字符与编号的对应关系&lt;/li>
&lt;li>UTF 是 编码规则&lt;/li>
&lt;/ul>
&lt;p>其中：&lt;/p>
&lt;ul>
&lt;li>字符集：为每一个「字符」分配一个唯一的 ID（学名为码位 / 码点 / Code Point）&lt;/li>
&lt;li>编码规则：将「码位」转换为字节序列的规则&lt;/li>
&lt;/ul>
&lt;p>广义的 Unicode 是一个标准，定义了一个字符集以及一系列的编码规则，即 Unicode 字符集和 UTF-8、UTF-16、UTF-32 等等编码规则……&lt;/p>
&lt;p>Unicode 字符集为每一个字符分配一个编号，例如「知」的 Unicom 编号是 30693，记作 U+77E5（30693 的十六进制为 0x77E5）。&lt;/p>
&lt;p>UTF-8 顾名思义，是一套以 8 位为一个编码单位的可变长编码。会将一个编号重新编码为 1 到 4 个字节：&lt;/p>
&lt;pre>&lt;code>U+ 0000 ~ U+ 007F: 0XXXXXXX
U+ 0080 ~ U+ 07FF: 110XXXXX 10XXXXXX
U+ 0800 ~ U+ FFFF: 1110XXXX 10XXXXXX 10XXXXXX
U+10000 ~ U+10FFFF: 11110XXX 10XXXXXX 10XXXXXX 10XXXXXX
&lt;/code>&lt;/pre>
&lt;p>根据上表中的编码规则，之前的「知」字的码位 U+77E5 属于第三行的范围：&lt;/p>
&lt;pre>&lt;code>7 7 E 5
0111 0111 1110 0101 二进制的 77E5
--------------------------
0111 011111 100101 二进制的 77E5
1110XXXX 10XXXXXX 10XXXXXX 模版（上表第三行）
11100111 10011111 10100101 代入模版
E 7 9 F A 5
&lt;/code>&lt;/pre>
&lt;p>这就是将 U+77E5 按照 UTF-8 编码为字节序列 E79FA5 的过程。反之亦然。&lt;/p>
&lt;h1 id="乱码的出现">乱码的出现&lt;/h1>
&lt;p>从上边的编码介绍中我们已经知道了不同编码的存在，那么想要查看一个文件，就必须知道他的编码方式，用错误的编码方式打开文件就会出现乱码。
linux 下可以通过 file 命令查看文件的编码方式&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>root@lichenhao:~# touch encoding_file
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>root@lichenhao:~# file encoding_file
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>encoding_file: empty
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>root@lichenhao:~# echo &lt;span style="color:#e6db74">&amp;#34;hello world!&amp;#34;&lt;/span> &amp;gt; encoding_file
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>root@lichenhao:~# file encoding_file
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>encoding_file: ASCII text
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>root@lichenhao:~# echo &lt;span style="color:#e6db74">&amp;#34;你好，世界！&amp;#34;&lt;/span> &amp;gt;&amp;gt; encoding_file
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>root@lichenhao:~# file encoding_file
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>encoding_file: UTF-8 Unicode text
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>工作中我们在 XSHELL 之类的终端中查看文件时出现的乱码就是系统或文件保存的中文编码与终端设置的编码不一致，从而导致解码错误。这里涉及到三方编码：&lt;/p>
&lt;ol>
&lt;li>文件内容或文件名&lt;/li>
&lt;li>SHELL 环境的语言编码&lt;/li>
&lt;li>XSHELL 之类的终端编码&lt;/li>
&lt;/ol>
&lt;p>需要保持三方编码统一，才不会有乱码的出现，其中 SHELL 环境的语言编码指的是登陆服务器的 SHELL 环境时指定的语言编码，例如 LANG、LC_*这些变量设置的编码，XSHELL 之类终端编码就是这类终端软件设置的编码
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/gptlcx/1616053185837-0c93a28f-6155-47e3-9cf4-bbb563b402c1.jpeg" alt="">
所有遇到的乱码问题都仔细检查以上三方编码是否一致，就可以顺利解决了，同时也建议在工作中制定相应的规范，减少乱码的发生&lt;/p>
&lt;p>此时，我现在将 Xshell 中的编码规则变为其他的
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/gptlcx/1616475169200-5248e6d0-2b70-47f6-9a88-5f7c46a4758c.png" alt="image.png">
此时再看这个文件，就发现，已经无法正确解码了:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>root@lichenhao:~# cat encoding_file
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>hello world!
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>浣??ソ锛???????
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="乱码处理技巧">乱码处理技巧&lt;/h2>
&lt;ol>
&lt;li>临时切换命令输出语言
正常情况下命令的输出结果都遵循系统设置的语言编码，例如&lt;/li>
&lt;/ol>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>root@ops-coffee:~# echo $LANG
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>zh_CN.UTF-8
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>root@ops-coffee:~# date
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>2020年 03月 04日 星期三 19:00:55 HKT
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>root@ops-coffee:~# export LANG&lt;span style="color:#f92672">=&lt;/span>en_US.UTF-8
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>root@ops-coffee:~# echo $LANG
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>en_US.UTF-8
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>root@ops-coffee:~# date
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Wed Mar &lt;span style="color:#ae81ff">4&lt;/span> 19:01:21 HKT &lt;span style="color:#ae81ff">2020&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>运维脚本中，我们希望所有系统执行相同命令的时候输出的结果一致，不要因为字符集不同而产生不同的结果，那么如可处理呢？在命令前添加 LC_ALL=C&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>root@ops-coffee:~# date
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>2020年 03月 04日 星期三 19:05:58 HKT
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>root@ops-coffee:~# LC_ALL&lt;span style="color:#f92672">=&lt;/span>C date
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Wed Mar &lt;span style="color:#ae81ff">4&lt;/span> 19:06:05 HKT &lt;span style="color:#ae81ff">2020&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>这里之所以用 LC_ALL 是因为在 LOCALE 标准中，LC_ALL 优先级最高：LC_ALL&amp;gt;LC_*&amp;gt;LANG&lt;/p>
&lt;ol start="2">
&lt;li>批量转换文件名编码&lt;/li>
&lt;/ol>
&lt;p>有时候我们会遇到文件名或者目录名乱码的问题，尤其是在不同类型系统之间传输时，可以借助 rsync 实现批量转换文件名或目录名的编码
rsync -av &amp;ndash;iconv=GBK,UTF8 /www/ /nav/
iconv 模块在 rsync 的 3.0 以后版本中才支持，用法为&amp;ndash;iconv=,，需要注意的是，本地两个目录之间同步时 LOCAL 表示的是源目录的文件名编码，通过网络同步时 LOCAL 表示本地编码&lt;/p></description></item></channel></rss>