<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>断念梦 – 4.数据通信</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/4.%E6%95%B0%E6%8D%AE%E9%80%9A%E4%BF%A1/</link><description>Recent content in 4.数据通信 on 断念梦</description><generator>Hugo -- gohugo.io</generator><atom:link href="https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/4.%E6%95%B0%E6%8D%AE%E9%80%9A%E4%BF%A1/index.xml" rel="self" type="application/rss+xml"/><item><title>Docs: 2.ARP 与 NDP</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/4.%E6%95%B0%E6%8D%AE%E9%80%9A%E4%BF%A1/%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/2.arp-%E4%B8%8E-ndp/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/4.%E6%95%B0%E6%8D%AE%E9%80%9A%E4%BF%A1/%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/2.arp-%E4%B8%8E-ndp/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Address_Resolution_Protocol">Wiki,ARP&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Neighbor_Discovery_Protocol">Wiki,NDP&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.rfc-editor.org/rfc/rfc826.html">RFC 826&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://mp.weixin.qq.com/s/_5Wgsx4mEoDZgwv9-yHYEA">公众号,36 张图详解 ARP&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>**Address Resolution Protoco(地址解析协议，简称 ARP) **是一种通信协议，该协议可以通过给定的网络层地址(通常是 IPv4 地址)，发现与之相关联的链路层地址(通常你是 MAC 地址)。ARP 于 1982 年在 &lt;a href="https://www.rfc-editor.org/rfc/rfc826.html">RFC 826&lt;/a> 中定义。说白了，就是根据 IP 地址查询对应 MAC 地址的协议。&lt;/p>
&lt;p>注意：在 IPv6 网络环境下，APR 的功能已经被 NDP 替代&lt;/p>
&lt;p>对应关系：一个 ip 地址对应一个 MAC 地址。多个 ip 地址可以对应一个 MAC 地址(e.g.一个网卡上配置两个 ip)&lt;/p>
&lt;h2 id="arp-报文">ARP 报文&lt;/h2>
&lt;p>在抓包时，可以抓到如下几种 ARP 包&lt;/p>
&lt;ol>
&lt;li>ARP, Request who-has 10.10.100.254 tell 10.10.100.101, length 28
&lt;ol>
&lt;li>在局域网中询问谁有 10.10.100.254，告诉自己，自己就是 10.10.100.101&lt;/li>
&lt;/ol>
&lt;/li>
&lt;li>ARP, Reply 10.10.100.254 is-at 00:0f:e2:ff:05:92, length 46
&lt;ol>
&lt;li>当 10.10.100.254 收到 arp 广播包之后，就会进行 reply(响应)，10.10.100.254 的 mac 地址是 00:0f:e2:ff:05:92&lt;/li>
&lt;/ol>
&lt;/li>
&lt;li>这时候 10.10.100.101 就会更新自己的 arp 表，记录下来 10.10.100.254 与 00:0f:e2:ff:05:92 的对应关系&lt;/li>
&lt;/ol>
&lt;p>ARP 报文分为 &lt;strong>ARP 请求报文&lt;/strong>和 &lt;strong>ARP 应答报文&lt;/strong>，它们的报文格式相同，但是各个字段的取值不同。
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/nguycm/1623911614198-6f1cde9d-cf37-4711-b6ce-cd9b8b1ccdd5.png" alt="">ARP 报文格式
ARP 报文中各个字段的含义如下。
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/nguycm/1623911614222-e8fe87d5-ca7b-494c-99c1-b8b1be472301.png" alt="">&lt;/p>
&lt;h1 id="arp-原理">ARP 原理&lt;/h1>
&lt;p>ARP 是通过 **ARP Request(请求) **和 **ARP Reply(响应) **报文确定 MAC 地址的。
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/nguycm/1623910582328-062e8f26-c6da-4ee5-97e4-857507dbb707.png" alt="">&lt;/p>
&lt;h2 id="同网段交互流程">同网段交互流程&lt;/h2>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>root@lichenhao:~# tcpdump -i any host 172.19.42.202
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>tcpdump: verbose output suppressed, use -v or -vv &lt;span style="color:#66d9ef">for&lt;/span> full protocol decode
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>listening on any, link-type LINUX_SLL &lt;span style="color:#f92672">(&lt;/span>Linux cooked v1&lt;span style="color:#f92672">)&lt;/span>, capture size &lt;span style="color:#ae81ff">262144&lt;/span> bytes
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>14:13:38.036170 ARP, Request who-has 172.19.42.202 tell lichenhao.bj-test, length &lt;span style="color:#ae81ff">28&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>14:13:38.036549 ARP, Reply 172.19.42.202 is-at 00:be:d5:ef:24:4e &lt;span style="color:#f92672">(&lt;/span>oui Unknown&lt;span style="color:#f92672">)&lt;/span>, length &lt;span style="color:#ae81ff">46&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>14:13:38.036583 IP lichenhao.bj-test &amp;gt; 172.19.42.202: ICMP echo request, id 3, seq 1, length &lt;span style="color:#ae81ff">64&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>14:13:38.036821 IP 172.19.42.202 &amp;gt; lichenhao.bj-test: ICMP echo reply, id 3, seq 1, length &lt;span style="color:#ae81ff">64&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>如上所示，当前主机没有 172.19.42.202 主机的 arp 关系表，当我们向 172.19.42.202 发送 icmp 请求时，数据包将会经历如下过程：&lt;/p>
&lt;p>假如主机 A 向同一网段上的主机 B 发送数据。主机 A 的 IP 地址为 &lt;code>10.0.0.1&lt;/code> ，主机 B 的 IP 地址为 &lt;code>10.0.0.2&lt;/code> ，主机 C 的 IP 地址为 &lt;code>10.0.0.3&lt;/code> 。它们都不知道对方的 MAC 地址。ARP 地址解析过程如下：
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/nguycm/1623910652117-bd47d4a3-1fb2-4f50-9b4f-bc8e5c2a1b2b.png" alt="">&lt;/p>
&lt;ol>
&lt;li>&lt;strong>主机 A&lt;/strong> 首先查看自己的 ARP 表（即 ARP 缓存表），确定是否有主机 B 的 IP 地址对应表项。如果有，则直接使用表项中的 MAC 地址进行封装，封装成帧后发送给主机 B 。&lt;/li>
&lt;/ol>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/nguycm/1623910669257-9b3f2f80-ddd3-4501-807e-96acfe414c20.png" alt="">&lt;/p>
&lt;ol start="2">
&lt;li>如果&lt;strong>主机 A&lt;/strong> 的 ARP 表没有对应的表项，就发送一个广播帧，源 IP 和源 MAC 地址是主机 A ，目的 IP 地址是主机 B ，目的 MAC 地址是广播 MAC 地址，即 &lt;code>FFFF-FFFF-FFFF&lt;/code> 。这就是 &lt;strong>ARP 请求报文&lt;/strong>。&lt;/li>
&lt;/ol>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/nguycm/1623910669279-c6354c1b-c098-4974-b4cd-22e93fc54efe.png" alt="">&lt;/p>
&lt;ol start="3">
&lt;li>ARP 请求是广播报文，同一个网段的所有主机都能收到。只有主机 B 发现报文中的目的 IP 地址是自己，于是&lt;strong>主机 B&lt;/strong> 发送响应报文给主机 A ，源 MAC 地址和源 IP 地址是主机 B ，目的 MAC 地址和目的 IP 地址是主机 A ，这个报文就叫 &lt;strong>ARP 响应报文&lt;/strong>。同时，主机 B 的 ARP 表记录主机 A 的映射关系，即主机 A 的 IP 地址和 MAC 地址的对应关系。&lt;/li>
&lt;/ol>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/nguycm/1623910669203-16790059-e9ef-45f9-9c9b-28f5f835c556.png" alt="">&lt;/p>
&lt;ol start="4">
&lt;li>&lt;strong>主机 C&lt;/strong> 也收到了 ARP 请求报文，但目的 IP 地址不是自己，所以不会进行响应。于是主机 C 添加主机 A 的映射关系到 ARP 表，并丢弃 ARP 请求报文。&lt;/li>
&lt;/ol>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/nguycm/1623910669305-20a3b990-6012-45d5-8462-176106ad6dd6.png" alt="">&lt;/p>
&lt;ol start="5">
&lt;li>主机 A 收到 ARP 响应报文后，添加主机 B 的映射关系，同时用主机 B 的 MAC 地址做为目的地址封装成帧，并发送给主机 B 。&lt;/li>
&lt;/ol>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/nguycm/1623910669300-be2dccaa-122c-41d2-92b6-3b035e70335d.png" alt="">
如果每发送一个 IP 报文就要进行一次 ARP 请求，来确定 MAC 地址，那将会造成不必要的网络流量，通常的做法是用 ARP 表记录 IP 地址和 MAC 地址的映射关系。主机发送报文时，首先会查看它的 &lt;strong>ARP 表&lt;/strong>，目的是为了确定是否是已知的设备 MAC 地址。如果有，就直接使用；如果没有，就发起 ARP 请求获取。不过，缓存是有一定期限的。ARP 表项在&lt;strong>老化时间&lt;/strong>（ &lt;code>aging time&lt;/code> ）内是有效的，如果老化时间内未被使用，表项就会被删除。
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/nguycm/1623910669502-4614b748-fac7-4301-bc85-68ccec45c91a.png" alt="">
ARP 表项分为&lt;strong>动态 ARP 表项&lt;/strong>和&lt;strong>静态 ARP 表项&lt;/strong>：&lt;/p>
&lt;ul>
&lt;li>&lt;strong>动态 ARP 表项&lt;/strong>由 ARP 动态获取，因此在网络通信中，无需事先知道 MAC 地址，只要有 IP 地址即可。如果老化时间内未被使用，表项就会被自动删除。&lt;/li>
&lt;li>&lt;strong>静态 ARP 表项&lt;/strong>是手工配置，不会老化。静态 ARP 表项的优先级高于动态 ARP 表项，可以将相应的动态 ARP 表项覆盖。&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/nguycm/1623910669307-374038c8-0ab6-4a06-ad5a-b55240326db1.png" alt="">&lt;/p>
&lt;h2 id="跨网段交互流程">跨网段交互流程&lt;/h2>
&lt;ol>
&lt;li>在 client 向 server 发送数据时，内核会在该数据包外封装 源 IP、源 MAC、目的 IP，由于目的 MAC 未知，所以不填&lt;/li>
&lt;li>数据包经过交换、路由等设备后，到达 server 前的交换机，交换机根据自身的 arp 表，找到目的 IP 与哪个口的 mac 地址相关联，则把数据包交给响应的网口，以便顺利到达 server。&lt;/li>
&lt;li>server 收到数据包后，内核会把最外层的 IP 与 MAC 都玻璃，并交给相对应的用户空间内的程序，处理完成后，再发送数据响应 client&lt;/li>
&lt;li>此时 server 已经有个 client 的 MAC 与 IP，所以在内核封装的时候，会填写源 IP、源 MAC、目的 IP、目的 MAC。&lt;/li>
&lt;li>之后数据包到达 client 前面的交换机时，交换机发现目的 IP 与 MAC，则更新或者保持不变 arp 表，并把数据包交给 MAC 为目的 MAC 的端口，以便数据送达 client&lt;/li>
&lt;li>这样就完成了两台设备之间的互相通信以及数据报文的完整封装&lt;/li>
&lt;li>否则第一次发送数据的时候，如果是不在本网段的地址，则目的 MAC 一般都是未知的，除非已经建立连接之后，才能根据数据包的源 MAC 知道响应的时候目的 MAC 填什么&lt;/li>
&lt;/ol>
&lt;h1 id="免费-arp-广播-与-一般-arp-广播">免费 ARP 广播 与 一般 ARP 广播&lt;/h1>
&lt;ul>
&lt;li>&lt;strong>免费 arp 广播&lt;/strong> # 在设备首次接通网线之后，会进行 arp 广播，告诉大家自己的 IP 与 MAC 对应关系。当局域网内的设备收到这个免费的 arp 广播时，没有该 arp 记录则会添加，如果该 arp 记录改变了则会更新。&lt;/li>
&lt;li>&lt;strong>一般 arp 广播&lt;/strong> # 在对本机未知同网段的设备发送数据时，会进行 arp 广播，询问该设备在哪里。&lt;/li>
&lt;li>“免费 arp 广播”与“一般 arp 广播”的区别：
&lt;ol>
&lt;li>普通的 arp 请求如果目的地址不是本机，则本机就直接丢弃了，但是免费的 arp 广播，则会在本机保留或者更新。&lt;/li>
&lt;/ol>
&lt;/li>
&lt;/ul>
&lt;p>如果目的 IP 不在本网段，则不会进行 arp 广播，因为目的地址不在本网段的设备，发送出去直接就到网关了，而网关在接入的时候、每隔 N 时间，都会发送 arp 来询问网关在哪。至于交换机测，也是同样的道理，本网段的设备，在需要发送数据包的时候，如果 arp 表里没有，则会先进行 arp 广播再发送。因为这些都是通过 mac 地址来进行二层发送的。&lt;/p>
&lt;p>&lt;strong>免费 ARP&lt;/strong> 是一种特殊的 ARP 请求，它并非通过 IP 找到对应的 MAC 地址，而是当主机启动的时候，发送一个免费 ARP 请求，即请求自己的 IP 地址的 MAC 地址。
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/nguycm/1623911576682-1a99a60a-4fa9-4480-8061-cec725fe9073.webp" alt="">
与普通 ARP 请求报文的区别在于报文中的目标 IP 地址。普通 ARP 报文中的目标 IP 地址是其它主机的 IP 地址；而免费 ARP 的请求报文中，&lt;strong>目标 IP 地址是自己的 IP 地址&lt;/strong>。
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/nguycm/1623911577030-243f8668-60e2-4952-bac9-beef00f9cba4.png" alt="">
免费 ARP 的作用：&lt;/p>
&lt;ul>
&lt;li>起到一个&lt;strong>宣告&lt;/strong>作用。它以广播的形式将数据包发送出去，不需要得到回应，只为了告诉其它主机自己的 IP 地址和 MAC 地址。&lt;/li>
&lt;li>可用于&lt;strong>检测 IP 地址冲突&lt;/strong>。当一台主机发送了免费 ARP 请求报文后，如果收到了 ARP 响应报文，则说明网络内已经存在使用该 IP 地址的主机。&lt;/li>
&lt;li>可用于&lt;strong>更新&lt;/strong>其它主机的 ARP 缓存表。如果该主机更换了网卡，而其它主机的 ARP 缓存表仍然保留着原来的 MAC 地址。这时，通过免费的 ARP 数据包，更新其它主机的 ARP 缓存表。&lt;/li>
&lt;/ul>
&lt;h1 id="ndp">NDP&lt;/h1></description></item><item><title>Docs: 3.BGP</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/4.%E6%95%B0%E6%8D%AE%E9%80%9A%E4%BF%A1/%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/3.bgp/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/4.%E6%95%B0%E6%8D%AE%E9%80%9A%E4%BF%A1/%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/3.bgp/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;p>**Border Gateway Protocol(边界网关协议，简称 BFP) **是一个 Linux 内核原生就支持的、专门用在大规模数据中心里维护不同的“自治系统”之间路由信息的、无中心的路由协议。
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/pzl1r1/1616161506385-ecfc3cc9-11e3-4188-adfe-c551023cf332.jpeg" alt="">
在这个图中，我们有两个自治系统（Autonomous System，简称为 AS）：AS 1 和 AS 2。而所谓的一个自治系统，指的是一个组织管辖下的所有 IP 网络和路由器的全体。你可以把它想象成一个小公司里的所有主机和路由器。在正常情况下，自治系统之间不会有任何“来往”。&lt;/p>
&lt;p>但是，如果这样两个自治系统里的主机，要通过 IP 地址直接进行通信，我们就必须使用路由器把这两个自治系统连接起来。&lt;/p>
&lt;p>比如，AS 1 里面的主机 10.10.0.2，要访问 AS 2 里面的主机 172.17.0.3 的话。它发出的 IP 包，就会先到达自治系统 AS 1 上的路由器 Router 1。&lt;/p>
&lt;p>而在此时，Router 1 的路由表里，有这样一条规则，即：目的地址是 172.17.0.2 包，应该经过 Router 1 的 C 接口，发往网关 Router 2（即：自治系统 AS 2 上的路由器）。&lt;/p>
&lt;p>所以 IP 包就会到达 Router 2 上，然后经过 Router 2 的路由表，从 B 接口出来到达目的主机 172.17.0.3。&lt;/p>
&lt;p>但是反过来，如果主机 172.17.0.3 要访问 10.10.0.2，那么这个 IP 包，在到达 Router 2 之后，就不知道该去哪儿了。因为在 Router 2 的路由表里，并没有关于 AS 1 自治系统的任何路由规则。&lt;/p>
&lt;p>所以这时候，网络管理员就应该给 Router 2 也添加一条路由规则，比如：目标地址是 10.10.0.2 的 IP 包，应该经过 Router 2 的 C 接口，发往网关 Router 1。&lt;/p>
&lt;p>像上面这样负责把自治系统连接在一起的路由器，我们就把它形象地称为：边界网关。它跟普通路由器的不同之处在于，它的路由表里拥有其他自治系统里的主机路由信息。&lt;/p>
&lt;p>上面的这部分原理，相信你理解起来应该很容易。毕竟，路由器这个设备本身的主要作用，就是连通不同的网络。但是，你可以想象一下，假设我们现在的网络拓扑结构非常复杂，每个自治系统都有成千上万个&lt;/p>
&lt;p>主机、无数个路由器，甚至是由多个公司、多个网络提供商、多个自治系统组成的复合自治系统呢？&lt;/p>
&lt;p>这时候，如果还要依靠人工来对边界网关的路由表进行配置和维护，那是绝对不现实的。而这种情况下，BGP 大显身手的时刻就到了。在使用了 BGP 之后，你可以认为，在每个边界网关上都会运行着一个小程序，它们会将各自的路由表信息，通过 TCP 传输给其他的边界网关。而其他边界网关上的这个小程序，则会对收到的这些数据进行分析，然后将需要的信息添加到自己的路由表里。这样，图 2 中 Router 2 的路由表里，就会自动出现 10.10.0.2 和 10.10.0.3 对应的路由规则了。&lt;/p>
&lt;p>所以说，所谓 BGP，就是在大规模网络中实现节点路由信息共享的一种协议。而 BGP 的这个能力，正好可以取代 Flannel 维护主机上路由表的功能。而且，BGP 这种原生就是为大规模网络环境而实现的协议，其可靠性和可扩展性，远非 Flannel 自己的方案可比。&lt;/p>
&lt;p>Note：BGP 协议实际上是最复杂的一种路由协议。我在这里的讲述和所举的例子，仅是为了能够帮助你建立对 BGP 的感性认识，并不代表 BGP 真正的实现方式。&lt;/p></description></item><item><title>Docs: 3.ICMP</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/4.%E6%95%B0%E6%8D%AE%E9%80%9A%E4%BF%A1/%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/3.icmp/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/4.%E6%95%B0%E6%8D%AE%E9%80%9A%E4%BF%A1/%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/3.icmp/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://mp.weixin.qq.com/s/AKiUyMbsGhOZi7cDAhSGkg">公众号,24 张图搞定 ICMP&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;h3 id="icmp">ICMP&lt;/h3>
&lt;p>&lt;strong>IP&lt;/strong> 是尽力传输的网络协议，提供的数据传输服务是&lt;strong>不可靠&lt;/strong>的、无连接的，不能保证数据包能成功到达目的地。那么问题来了：如何确定数据包成功到达目的地？
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/boov5o/1622087956279-d468d429-a172-4d1d-8296-bd855385f80b.png" alt="">不可靠传输
这需要一个网络层协议，提供错误检测功能和报告机制功能，于是出现了 &lt;strong>ICMP&lt;/strong>（互联网控制消息协议）。ICMP 的主要功能是，&lt;strong>确认 IP 包是否成功送达目的地址&lt;/strong>，&lt;strong>通知发送过程中 IP 包被丢弃的原因&lt;/strong>。有了这些功能，就可以检查网络是否正常、网络配置是否正确、设备是否异常等信息，方便进行&lt;strong>网络问题诊断&lt;/strong>。
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/boov5o/1622087956391-eae4cc3c-7eb0-47aa-875a-154dec57c1cf.png" alt="">ICMP 网络诊断功能
&lt;strong>举个栗子&lt;/strong>：如果在传输过程中，发生了某个错误，设备便会向源设备返回一条 ICMP 消息，告诉它发生的错误类型。
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/boov5o/1622087956489-289bd365-0f3c-4891-b798-016dcab13bb4.png" alt="">ICMP 举例
ICMP 消息是通过 IP 进行传输，但它的目的并不是让 IP 成为一种可靠的协议，而是对传输中发生的问题进行反馈。ICMP 消息的传输同样得不到可靠性保证，也有可能在传输过程中丢失。因此 ICMP 不是传输层的补充，应该把它当做&lt;strong>网络层协议&lt;/strong>。&lt;/p>
&lt;h4 id="icmp-消息封装">ICMP 消息封装&lt;/h4>
&lt;p>ICMP 消息使用 IP 来封装，&lt;strong>封装格式&lt;/strong>如下图。
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/boov5o/1622087956425-eb063720-58a0-4b78-bfa8-39c2e96d569d.png" alt="">ICMP 封装格式
其中 &lt;strong>type&lt;/strong>（类型）字段表示 ICMP 消息的类型，&lt;strong>code&lt;/strong>（代码）字段表示 ICMP 消息的具体含义。例如：type 值为 3 表示目的不可达消息（ Destination Unreachable Message ），若 code 值为 0 表示目的网络不可达（ Network Unreachable ）。常见的 ICMP 消息类型如下图。
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/boov5o/1622087956257-cc3d7e06-5c0f-4f20-9026-48917ba962ee.png" alt="">ICMP 消息类型
从功能上，ICMP 的消息可分为两类：一类是通知出错原因的&lt;strong>错误消息&lt;/strong>，另一类是用于诊断的&lt;strong>查询消息&lt;/strong>。
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/boov5o/1622087956583-0a4b1076-322c-4b5f-bd43-8b5364ce42a4.png" alt="">错误消息和查询消息&lt;/p>
&lt;h4 id="常见的-icmp-消息类型">常见的 ICMP 消息类型&lt;/h4>
&lt;ul>
&lt;li>&lt;strong>回送请求消息&lt;/strong>（ Echo Request ）：是由源设备（主机或路由器等）向一个指定的目的设备发出的请求。这种消息用来测试目的地是否可达。&lt;/li>
&lt;li>&lt;strong>回送响应消息&lt;/strong>（ Echo Reply ）：对 Echo Request 的响应。目的设备发送 Echo Reply 来响应收到的 Echo Request 。最常用的 ping 命令就是使用 Echo Request 和 Echo Reply 来实现的。&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/boov5o/1622087956612-4e223795-e42d-4c78-8be6-48000ccc7632.png" alt="">回送消息&lt;/p>
&lt;ul>
&lt;li>&lt;strong>目的不可达&lt;/strong>（ Destination Unreachable ）：路由器无法将 IP 包发送给目的地址时，会给源设备返回一个 Destination Unreachable 消息，并在消息中显示不可达的具体原因。
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/boov5o/1622087956380-16033d96-d332-4f13-9a3a-3d24a50b113d.png" alt="">目的不可达实际情况下，经常会遇到的错误代码是 1 ，表示主机不可达，它是指路由表中没有目的设备的信息，或目的设备没有连接到网络。&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/boov5o/1622087956460-afdf7e80-77ee-4e32-8e0d-749e9bc5c483.png" alt="">目的不可达类型&lt;/p>
&lt;ul>
&lt;li>&lt;strong>参数问题&lt;/strong>（ Parameter Problem ）：路由器发现 IP 包头出现错误或非法值后，向源设备发送一个 Parameter Problem 消息。这个消息包含有问题的 IP 头，或错误字段的提示信息。&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/boov5o/1622087956530-5dcf521e-a938-4961-b7b1-00d735a998b6.png" alt="">参数问题消息&lt;/p>
&lt;ul>
&lt;li>&lt;strong>重定向&lt;/strong>（ Redirect ）：如果路由器发现一条更优的路径发送数据，那么它就会返回一个 Redirect 消息给主机。这个消息包含了最合适的路由信息和源数据。
实际情况下，这种 Redirect 消息会引发路由问题，所以不进行这种设置。比如：路由器的路由表不准确时，ICMP 有可能就无法正常工作。&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/boov5o/1622087956439-255f3c69-1653-431d-81a4-9592520ed469.png" alt="">重定向&lt;/p>
&lt;ul>
&lt;li>&lt;strong>超时&lt;/strong>（ Time Exceeded ）：IP 包中有一个字段是 TTL（生存周期），它的值每经过一次路由器就减 1 ，直到减到 0 时 IP 包会被丢弃。这时，路由器会发送一个 Time Exceeded 消息给源设备，并通知 IP 包已被丢弃。
设置 TTL 的主要目的，是当路由发生环路时，避免 IP 包无休止的在网络上转发。还可以用 TTL 控制 IP 包的可达范围，比如设置一个较小的 TTL 值。&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/boov5o/1622087956563-69d4450f-834a-4f6e-9ae0-f54f6ad81866.png" alt="">超时&lt;/p>
&lt;ul>
&lt;li>&lt;strong>时间戳请求/时间戳响应&lt;/strong>（ Timestamp Request / Timestamp Reply ）：时间戳可以记录 ICMP 消息一次往返所需的时间。源设备发送一个带有发送时间的 Timestamp Request 消息，目的设备收到后，发送一个带有原设备发送时间、目的设备接收时间以及目的设备发送时间的 Timestamp Reply 消息。源设备收到 Timestamp Reply 时，并同时记录到达时间。这些时间戳可以估计网络上的传输时间。&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/boov5o/1622087956537-0334836c-2e44-4f22-83c5-b81cf4d3031a.png" alt="">时间戳&lt;/p>
&lt;h3 id="icmp-的应用">ICMP 的应用&lt;/h3>
&lt;p>ICMP 被广泛应用于网络测试，最常用的 &lt;strong>ping&lt;/strong> 和 &lt;strong>tracert&lt;/strong> 网络测试工具，都是使用 ICMP 协议实现的。&lt;/p>
&lt;h4 id="ping">ping&lt;/h4>
&lt;p>ping 是 ICMP 最著名的一个应用，通过 ping 可以&lt;strong>测试网络的可达性&lt;/strong>，即网络上的报文能否成功到达目的地。使用 ping 命令时，源设备向目的设备发送 &lt;em>Echo request&lt;/em> 消息，目的地址是目的设备的 IP 地址。目的设备收到 &lt;em>Echo request&lt;/em> 消息后，向源设备回应一个 &lt;em>Echo reply&lt;/em> 消息，可知目的设备是可达的。也可以通过 ping 命令来判断目标主机是否启用。
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/boov5o/1622087956406-67c2d46c-ad49-4904-8ead-569eaeb0ef80.png" alt="">ping
如果中间某个路由器没有到达目的网络的路由，便会向源设备回应一个 &lt;em>Destination Unreachable&lt;/em> 消息，告知目的设备不可达。
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/boov5o/1622087956546-e4b22038-cd77-4ba6-a18a-8f58b0961db2.png" alt="">ping 目的不可达
如果源主机在一定时间内无法收到回应报文，就认为目的设备不可达，并显示超时。
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/boov5o/1622087956386-8c862599-839b-4eba-a995-b9267f202d65.png" alt="">超时
需要注意的是 ping 过程是双向的消息通信，只有双向都成功传输时，才能说明通信是正常的。另外主机也可能因为防火墙拦截，导致 ping 不通。&lt;/p>
&lt;h4 id="tracert">tracert&lt;/h4>
&lt;p>ping 工具只能测试目的设备的连通性，但是看不到数据包的传输路径。所以在网络不通的情况下，无法知道网络问题发生在哪个位置。tracert 工具可以查看数据包的&lt;strong>整条传输路径&lt;/strong>，包括途中经过的&lt;strong>中间设备&lt;/strong>。
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/boov5o/1622087956431-46f8e00a-d012-428d-8bcc-247f97e0b7a6.png" alt="">tracert
IP 头部的 &lt;strong>TTL&lt;/strong> 字段是为避免数据包循环转发而设计的。每经过一个路由器，数据包头中的 TTL 值减 1 。如果 TTL 值为 0 则丢弃报文，并向源设备回应一个 Time Exceeded 消息，告知错误类型。tracert 就是基于 TTL 字段和 ICMP 协议实现的。在 Windows 中命令是 &lt;strong>tracert&lt;/strong> ，在 Unix 、MacOS 中命令是 &lt;strong>traceroute&lt;/strong> 。
使用 tracert 命令时，源设备的 tracert &lt;strong>逐跳发送数据包&lt;/strong>，并等待每一个响应报文。发送第一个数据包时，TTL 值设为 1 。第一个路由器收到数据包后 TTL 值减 1 ，随即丢弃数据包，并返回一个 &lt;em>Time Exceeded&lt;/em> 消息。源设备的 tracert 收到响应报文后，取出源 IP 地址，即路径上的第一个路由器地址。然后 tracert 发送一个 TTL 值为 2 的数据包。第一个路由器将 TTL 值减 1 ，并转发数据包。第二个路由器再将 TTL 值减 1 ，丢弃数据包并返回一个 &lt;em>Time Exceeded&lt;/em> 消息。tracert 收到响应报文后，取出源 IP 地址，即路径上的第二个路由器地址。类似步骤，tracert 逐跳获得每一个路由器的地址，并探测到目的设备的可达性。
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/boov5o/1622087956576-de3f09ef-891d-4830-bef8-c84ef221aac4.png" alt="">tracert
tracert 过程也是双向的消息通信，只有双向都成功传输时，才能正确探测路径。另外主机安装了防火墙，也可能造成路径探测失败。&lt;/p>
&lt;h3 id="网络实战">网络实战&lt;/h3>
&lt;h4 id="ping-1">ping&lt;/h4>
&lt;p>在 Windows 电脑上使用 &lt;strong>ping&lt;/strong> 命令，并查看返回信息。
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/boov5o/1622087956590-14d0d35c-c869-48f1-be86-6ffd13a9591e.png" alt="">ping 命令
同步&lt;strong>抓包&lt;/strong>进行验证。
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/boov5o/1622087956373-656b7067-8cd6-4d87-9fcf-f18863eae6ec.png" alt="">ping 抓包
还可以直接使用 ping 命令，查看 ping 命令的&lt;strong>使用方法&lt;/strong>。
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/boov5o/1622087956428-2fb4954b-c839-4523-b3a2-ff3565ba6188.png" alt="">ping 命令用法&lt;/p>
&lt;h4 id="tracert-1">tracert&lt;/h4>
&lt;p>在 Windows 电脑上使用 &lt;strong>tracert&lt;/strong> 命令，并查看返回信息。
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/boov5o/1622087956498-ede48849-269f-4fe6-883e-1ed11215e544.png" alt="">tracert 命令
同步&lt;strong>抓包&lt;/strong>进行验证。
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/boov5o/1622087956533-997964bf-42cb-4306-92bc-11b97ccd05e9.png" alt="">tracert 抓包
也可以直接使用 tracert 命令，查看 tracert 命令的&lt;strong>使用方法&lt;/strong>。
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/boov5o/1622087956443-84a5971e-0af1-4287-b740-d0160533e903.png" alt="">tracert 用法&lt;/p>
&lt;hr>
&lt;p>&lt;strong>饮水思源：&lt;/strong>
TCP/IP 详解 卷 1：协议 - Kevin R.Fall
网络基础 - 田果
图解 TCP/IP - 竹下隆史
路由交换技术 - 杭州华三通信技术有限公司&lt;/p>
&lt;h1 id="icmpv6">ICMPv6&lt;/h1>
&lt;p>ICMPv6 是 IPv6 的基础协议之一，定义在 RFC 2463 中。用来传递报文转发中产生的信息或者错误。ICMPv6 定义的报文被广泛地应用在其他协议中，包括 NDP(邻居发现协议)、PathMTU 发现机制 等等。&lt;/p></description></item><item><title>Docs: 3.VRRP</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/4.%E6%95%B0%E6%8D%AE%E9%80%9A%E4%BF%A1/%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/3.vrrp/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/4.%E6%95%B0%E6%8D%AE%E9%80%9A%E4%BF%A1/%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/3.vrrp/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;p>&lt;strong>Virtual Router Redundancy Protocol(虚拟路由冗余协议，简称 VRRP)&lt;/strong> 是一种容错协议，其主要目的是解决路由单点故障的问题。VRRP 协议将局域网内的一组路由器虚拟为单个路由，通常将其称为一个路由备份组， 而这组路由器内包括一个 Master 路由（ 即活动路由器）和若干个 Backup 路由（即备份路由器）， VRRP 虚拟路由示意图如图 3-3 所示。在图 3-3 中 RouterA 、RouterB 和 RouterC 属于同一个 VRRP 组，组成一个虚拟路由器，而由 VRRP 协议虚拟出来的路由器拥有自己的 IP 地址 10.110.10.1 ，而备份组内的路由器也有自己的 IP 地址（如 Master 的 IP 地址为 10.110.10.5, Backup 的 IP 地址为 10.110.10.6 和 10.110.10.7）。&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/cv6gcm/1616161487047-bb1bc9ee-9e3e-40a2-9a92-403553eb3520.jpeg" alt="">&lt;/p>
&lt;ol>
&lt;li>
&lt;p>虚拟 IP：VIP，Virtual IP Address，在实际使用中，局域网内的主机仅仅知道这命虚拟路由器的 IP 地址 10 .110.10.1，而并不知道具体的 Master 路由器的 IP 地址以及 Backup 路由器的 IP 地址。局域网内的主机将自己的默认路由下一跳地址设置为该虚拟路由器的 IP 地址 10.110.10.1 之后，网络内的主机就通过这个虚拟的路由器来与其他网络进行通信。在通信过程中，如果备份组内的 Master 路由器故障，则 Backup 路由器将会通过选举机制重新选出一个新的 Master 路由器，从而继续向网络内的主机提供路由服务，最终实现了路由功能的高可用。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>此外，虚拟 IP 可以配置多个，比如 RouteA,B,C 的各个端口 1 绑定成一个 VIP1，RouteA,B,C 的各个端口 2 绑定成另一个 VIP2，RouteA,B,C 的各个端口 3 绑定成另一个 VIP3 以此类推，一组 VRRP 中，可以有多个 VIP，VIP1 的主路由是 Route1，VIP2 的主路由是 Route2，VIP3 的主路由是 Route3，各个 VIP 坏了，都可以有另外两台 Route 来代替工作，这样也解决了资源闲置问题，所有设备都是主，另外两台也是各个主设备的备设备&lt;/p>
&lt;/li>
&lt;li>
&lt;p>虚拟 MAC 地址：如果某一时刻 VIP 在 RouteA 上，当 A 坏了之后，VIP 自动转移到了 RouteB 上，但是对于后端的 Host 来说，该 VIP 所对应的 MAC 地址已经改变了，是该 VIP 所配置的物理网卡的 MAC 地址，这意味着之前 Host 已经缓存下来了这个对应规则，则再发送数据的时候，还会使用原来的 MAC，发送给坏了的 RouteA。为了解决这个情况，则可以使用虚拟 MAC 地址的方案,使用一个虚拟的 MAC 与 VIP 绑定&lt;/p>
&lt;/li>
&lt;li>
&lt;p>ARP 欺骗：当一台新设备接入网络后，可以使用自问自答方式，广播问一下“网关在哪里”，然后自己广播回答“网关在这里”，这时候，这台设备就可以拿到网关的 IP 所对应的自己的端口的 MAC 地址了&lt;/p>
&lt;/li>
&lt;li>
&lt;p>优先级：路由器开启 VRRP 功能后，会根据设定的优先级确定自己在备份组中的角色。优先级高的路由器成为 Master 路由器，优先级低的成为 Backup 路由器，并且 Master 路由器定期发送 VRRP 通告报文，通知备份组内的其他 Backup 路由器自己工作正常， 而备用路由器则启动定时器等待通告报文的到来。（如何判断 Master 路由器是否正常工作？）如果 Backup 路由器的定时器超时后仍未收到 Master 路由器发送来的 VRRP 通告报文， 则认为 Master 路由器已经故障，此时 Backup 路由器会认为自己是主用路由器（备份组内的路由器会根据优先级选举出新的 Master 路由器），并对外发送 VRRP 通告报文。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>此外， VRRP 在提高路由可靠性的同时，还简化了主机的路由配置， 在具有多播或广播能力的局域网中，借助 VRRP 能在某台路由器出现故障时仍然提供高可靠的默认链路，有效避免单一链路发生故障后网络中断的问题，并且无需修改主机动态路由协议、路由发现协议等配置信息。&lt;/p>
&lt;/li>
&lt;/ol>
&lt;h1 id="试验">试验：&lt;/h1>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/cv6gcm/1616161487021-bdc76b76-08cd-4480-b281-3230f6e829a3.jpeg" alt="">&lt;/p>
&lt;p>PC11 在 VLAN10 中 192.168.10.11，PC21 在 VLAN20 中 192.168.20.21，如果让两台设备互通，那么需要通过三层路由实现&lt;/p>
&lt;p>为了实现路由冗余，在网关所在设备启 VRRP 协议，保证一个路由（网关）坏掉的情况，可以有另一个代替。&lt;/p>
&lt;p>那么首先需要在 VRRP master 和 VRRPbackup 设备上配置 VLAN10 和 VLAN20 的虚拟网关 IP，以及给每个 VLAN 配置一个 IP 以启动该 VLAN 接口，如图所示 （需要设置优先级 priority 以确保其中一台设备始终为 MASTER，优先级默认为 100）&lt;/p>
&lt;p>VRRPmaster 的配置&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/cv6gcm/1616161487070-34b33cb9-f96b-4142-934b-ad1261217e5d.jpeg" alt="">&lt;/p>
&lt;p>VRRPbackup 的配置&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/cv6gcm/1616161487028-8f6c1dca-c7d6-4dda-92cb-d00a1251a495.jpeg" alt="">&lt;/p>
&lt;p>其余基础配置：&lt;/p>
&lt;ol>
&lt;li>
&lt;p>port link-type trunk&lt;/p>
&lt;pre>&lt;code> port trunk allow-pass vlan 10 20 交换机互联端口为trunk切允许相应vlan通过
&lt;/code>&lt;/pre>
&lt;/li>
&lt;li>
&lt;p>port link-type access&lt;/p>
&lt;pre>&lt;code> port default vlan 10 指定接入层交换机接入设备端口的VLAN以实现隔离
&lt;/code>&lt;/pre>
&lt;/li>
&lt;/ol>
&lt;p>两个路由之间互相发送报文保证双方是主还是备（注：当 VRRP 两个设备互相无法收到验证报文的时候，会出现两台都是 MASTER 的情况）&lt;/p>
&lt;p>为了实现更高的冗余效果，可以在两台 VRRP 设备上增加级联线（即互联两台设备）该极连线采取链路聚合原则（上图的 23，24 口），具体配置如下：&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/cv6gcm/1616161487040-d85f0bfa-26c8-45f4-85a8-a7ab3a98234f.jpeg" alt="">&lt;/p>
&lt;p>并且使用 interface eth-trunk 1&lt;/p>
&lt;pre>&lt;code> trunkport gigabitethernet 0/0/x to 0/0/y 该命令，创建聚合端口并且把X到Y的端口都加到聚合组里去
&lt;/code>&lt;/pre></description></item><item><title>Docs: 3/4.TCP/IP</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/4.%E6%95%B0%E6%8D%AE%E9%80%9A%E4%BF%A1/%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/3_4.tcp_ip/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/4.%E6%95%B0%E6%8D%AE%E9%80%9A%E4%BF%A1/%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/3_4.tcp_ip/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://datatracker.ietf.org/doc/html/rfc791">RFC,791&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;h2 id="封装">封装&lt;/h2>
&lt;p>当应用程序用 TCP 传输数据时，数据被送入协议栈中，然后逐个通过每一层直到被当做一串比特流送入网络。其中每一层对收到的数据都要增加一些首部信息(有时还需要增加尾部信息)，过程如图所示：
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/oc8ill/1628821300980-52f384b2-d2c9-4227-a1c5-6481d6cbf20e.png" alt="image.png">
以太网帧的帧头和帧尾下面所标注的数字是典型以太网帧首部的字节查高难度。以太网数据帧的物理特性是其查高难度必须在 &lt;strong>46~1500 字节之间(也就是 MTU 的长度)&lt;/strong>&lt;/p>
&lt;blockquote>
&lt;p>注意：所有的 Internet 标准和大多数有关 TCP/IP 的书都使用 octe 这个术语来表示字节。使用这个过分雕琢的术语是有历史原因的，因为 TCP/IP 的很多工作都是在 DEC-10 系统上进行的，但是它并不使用 8bit 的字节。由于现在几乎所有的计算机系统都采用 8bit 的字节，因此我们在本书中使用 Byte(字节) 这个术语。&lt;/p>
&lt;/blockquote>
&lt;p>由于应用数据受 MSS 长度限制，IP 首部 + TCP 首部 + 应用数据受 MTU 长度限制。所以，当一个 IP 报文超过 MTU 时就会进行 &lt;strong>Packet(分片/分组)&lt;/strong>。分组既可以是一个 IP 数据报，也可以是 IP 数据报的一个 &lt;strong>Fragment(片段)&lt;/strong>。&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/oc8ill/1628821542180-6dae0209-e7ac-494e-b6f3-715ce143c6d5.png" alt="image.png">&lt;/p></description></item><item><title>Docs: 5.SSL 与 TLS</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/4.%E6%95%B0%E6%8D%AE%E9%80%9A%E4%BF%A1/%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/5.ssl-%E4%B8%8E-tls/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/4.%E6%95%B0%E6%8D%AE%E9%80%9A%E4%BF%A1/%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/5.ssl-%E4%B8%8E-tls/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Transport_Layer_Security">Wiki,TLS&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>为了解决人类在互联网世界信息的安全性，所研究出来的相关技术&lt;/p>
&lt;p>安全机制：加密、数字签名、访问控制、数据完整性、认证交换、流量填充、路由控制、公证&lt;/p>
&lt;p>安全服务：认证、访问控制、数据保密性(连接保密性、无连接保密性、选择与保密性、流量保密性)、数据完整性、不可否认性&lt;/p>
&lt;h2 id="ssltls-介绍">SSL/TLS 介绍&lt;/h2>
&lt;p>&lt;strong>Secure Socket Layer(安全的套接字层，简称 SSL)&lt;/strong> # 一个安全协议&lt;/p>
&lt;p>**Transport Layer Security(传输层安全，简称 TLS) **# SSL3.0 的升级版&lt;/p>
&lt;p>SSL/TLS 就是在应用层与传输层中间又加了半层，应用层协议可以自行决定改层的功能，比如 http 协议用了这半层，就是 https。&lt;/p>
&lt;p>SSL/TLS 的分层设计&lt;/p>
&lt;ol>
&lt;li>最底层，基础算法原语的实现，比如 aes，rsa，md5 等&lt;/li>
&lt;li>各种算法的实现&lt;/li>
&lt;li>组合算法实现的半成品&lt;/li>
&lt;li>用各种组件拼装而成的各种成品密码学协议/软件，tls,ssh 等 openssh 也是用 openssl 实现的软件&lt;/li>
&lt;/ol>
&lt;p>&lt;strong>key(密钥)&lt;/strong> # 在密码学中，是指某个用来完成加密、解密、完整性验证等密码学应用的秘密信息。对于加密算法，key 指定明文转换成密文；对于解密算法，key 指定密文转换成明文&lt;/p>
&lt;ul>
&lt;li>&lt;strong>Plaintext or Cleartext(明文)&lt;/strong> # 在密码学中，明文是未加密的信息，可以供人类和计算机读取的信息&lt;/li>
&lt;li>**Ciphertext or Cyphertext(密文) **# 在密码学中，密文是明文通过加密算法计算后生成的人类或计算器无法读取的一种信息&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>PKI：Public Key Infrastructure(公开密钥基础建设，简称 PKI)&lt;/strong>，又称公开密钥基础架构、公钥基础建设、公钥基础设施、公开密码匙基础建设或公钥基础架构，是一组由硬件、软件、参与者、管理政策与流程组成的基础架构，其目的在于创造、管理、分配、使用、存储以及撤销数字证书。&lt;/p>
&lt;p>PKI 是借助 CA（权威数字证书颁发/认证机构）将用户的个人身份跟公开密钥链接在一起，它能够确保每个用户身份的唯一性，这种链接关系是通过注册和发布过程实现，并且根据担保级别，链接关系可能由 CA 和各种软件或在人为监督下完成。PKI 用来确定链接关系的这一角色称为 RA（Registration Authority, 注册管理中心），RA 能够确保公开密钥和个人身份链接，可以防抵赖，防篡改。在微软的公钥基础建设下，RA 又被称为 CA，目前大多数称为 CA。&lt;/p>
&lt;p>PKI 组成要素
从上面可以得知 PKI 的几个主要组成要素，用户（使用 PKI 的人或机构），认证机构（CA，颁发证书的人或机构），仓库（保存证书的数据库）等。&lt;/p>
&lt;ol>
&lt;li>签证机构：CA(Certificate authority)证书权威机构&lt;/li>
&lt;li>注册机构：RA&lt;/li>
&lt;li>证书吊销列表:CRL&lt;/li>
&lt;li>证书存取库：&lt;/li>
&lt;li>x.509：一种证书格式规范&lt;/li>
&lt;/ol>
&lt;h1 id="通信加密安全实例">通信加密安全实例：&lt;/h1>
&lt;p>甲要发送数据给乙，甲为了只让乙看到&lt;/p>
&lt;ol>
&lt;li>首先，甲用单向加密算法提取数据的特征码，然后用自己的私钥加密这段特征码，并附加在这段数据的后面。&lt;/li>
&lt;li>甲用对称密钥，把整个数据加密。再用乙的公钥加密这个对称密钥，并附加在特征码后面&lt;/li>
&lt;li>乙先用自己的私钥解密出来对称密钥是什么。再使用对称加密机制，用解密出来的对称密钥解密整个数据和加密的特征码。&lt;/li>
&lt;li>乙再对方的公钥解密特征码，得到特征码，使用同样的单向加密算法计算特征码是否一样，则说明数据完整&lt;/li>
&lt;/ol>
&lt;p>密钥交换：IKE，DH&lt;/p>
&lt;p>openSSL 与 gpg(pgp 协议)&lt;/p>
&lt;h1 id="关联文件">关联文件&lt;/h1>
&lt;p>Linux 发行版中，有一个目录会保存一些常见的 CA 证书，称之为[信任仓库](✏IT 学习笔记/🔐7.信息安全/Cryptography(密码学)/公开密钥加密/证书%20 与%20PKI.md 与 PKI.md)：&lt;/p>
&lt;ul>
&lt;li>CentOS 发行版
&lt;ul>
&lt;li>&lt;strong>/etc/pki/ca-trust/extracted/openssl/ca-bundle.trust.crt&lt;/strong> # 包含所有证书，每个证书前一行有注释&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Ubuntu 发行版
&lt;ul>
&lt;li>&lt;strong>/etc/ssl/certs/*&lt;/strong> # 该目录中一个证书一个文件&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul></description></item><item><title>Docs: 7.DHCP</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/4.%E6%95%B0%E6%8D%AE%E9%80%9A%E4%BF%A1/%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/7.dhcp/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/4.%E6%95%B0%E6%8D%AE%E9%80%9A%E4%BF%A1/%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/7.dhcp/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Dynamic_Host_Configuration_Protocol">Wiki,DHCP&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>&lt;strong>Dynamic Host Configuration Protocol(动态主机设置协议，简称 DHCP)&lt;/strong> 主要用于由一部主机来自动的分配所有的网络参数给指定网段内的所有设备。&lt;/p>
&lt;p>DHCP 可以分配的网络参数有 IP 地址、掩码、网关、DNS 等&lt;/p>
&lt;p>DHCP 的运作方式：
他主要由客户端发送广播包给整个物理网段内的所有主机， 若该网段内有 DHCP 服务器时，就会响应客户端的 DHCP 请求。所以，DHCP 服务器与客户端是应该要在同一个物理网段内的，如果想跨网段提供 DHCP 服务，需要在对应网段启用 dhcrelay 服务。&lt;/p>
&lt;p>至于整个 DHCP 封包在服务器与客户端的来来回回情况如右图，具体有 4 个步骤
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/sc7lh2/1616161468691-c82332ec-254e-485f-861d-9186e60a3dd8.jpeg" alt="">&lt;/p>
&lt;ul>
&lt;li>&lt;strong>DISCOVER(发现)&lt;/strong> # 客户端利用广播封包发送搜索 DHCP 服务器的封包：
&lt;ul>
&lt;li>若客户端网络设定使用 DHCP 协议取得 IP (在 Windows 内为『自动取得 IP』)，则当客户端开机或者是重新启动网络卡时， 客户端主机会发送出搜寻 DHCP 服务器的 UDP 封包给所有物理网段内的计算机。此封包的目标 IP 会是 255.255.255.255， 所以一般主机接收到这个封包后会直接予以丢弃，但若局域网络内有 DHCP 服务器时，则会开始进行后续行为。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>OFFER(提供)&lt;/strong> # DHCP 服务端提供客户端网络相关的租约以供选择
&lt;ul>
&lt;li>DHCP 服务器在接收到这个客户端的要求后，会针对这个客户端的硬件地址 (MAC) 与本身的设定数据来进行下列工作：
&lt;ul>
&lt;li>到服务器的登录文件中寻找该用户之前是否曾经用过某个 IP ，若有且该 IP 目前无人使用，则提供此 IP 给客户端；&lt;/li>
&lt;li>若配置文件针对该 MAC 提供额外的固定 IP (static IP) 时，则提供该固定 IP 给客户端；&lt;/li>
&lt;li>若不符合上述两个条件，则随机取用目前没有被使用的 IP 参数给客户端，并记录下来。&lt;/li>
&lt;li>总之，服务器端会针对客户端的要求提供一组网络参数租约给客户端选择，由于此时客户端尚未有 IP ，因此服务器端响应的封包信息中， 主要是针对客户端的 MAC 来给予回应。此时服务器端会保留这个租约然后开始等待客户端的回应。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>REQUEST(请求)&lt;/strong> # 客户端决定选择的 DHCP 服务器提供的网络参数租约并回报服务器
&lt;ul>
&lt;li>由于局域网络内可能并非仅有一部 DHCP 服务器，但客户端仅能接受一组网络参数的租约。 因此客户端必需要选择是否要认可该服务器提供的相关网络参数的租约。当决定好使用此服务器的网络参数租约后， 客户端便开始使用这组网络参数来设定自己的网络环境。此外，客户端也会发送一个广播封包给所有物理网段内的主机， 告知已经接受该服务器的租约。此时若有第二台以上的 DHCP 服务器，则这些没有被接受的服务器会收回该 IP 租约。至于被接受的 DHCP 服务器会继续进行底下的动作。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>Acknowledge(确认，ACK)&lt;/strong> # 服务端记录该次租约行为并回报客户端已确认的响应封包信息
- 当服务器端收到客户端的确认选择后，服务器会回传确认的响应封包，并且告知客户端这个网络参数租约的期限， 并且开始租约计时喔！那么该次租约何时会到期而被解约，可以这样想：
- 客户端脱机：不论是关闭网络接口 (ifdown)、重新启动 (reboot)、关机 (shutdown) 等行为，皆算是脱机状态，这个时候 Server 端就会将该 IP 回收，并放到 Server 自己的备用区中，等待未来的使用；
- 客户端租约到期：前面提到 DHCP server 端发放的 IP 有使用的期限，客户端使用这个 IP 到达期限规定的时间，而且没有重新提出 DHCP 的申请时，就需要将 IP 缴回去！这个时候就会造成断线。但用户也可以再向 DHCP 服务器要求再次分配 IP 啰。&lt;/li>
&lt;/ul>
&lt;p>这四个步骤也称为 DHCP 分配地址时的需要进行的 DORA 进程&lt;/p>
&lt;h2 id="dhcp-租约">DHCP 租约&lt;/h2>
&lt;p>每次 DHCP 服务给客户端提供网络参数时，同时会提供一个有效时间，该有效时间表示客户端使用这些参数的有效时间，当有效时间过了之后，客户端则不再拥有这些网络参数。租约是由客户端发起请求具体租用时间，然后服务器回应是否可以给客户端租用这些时间。&lt;/p>
&lt;p>DHCP 提供的租约信息保存在 /var/lib/dhcpd/dhcpd.lesses 文件中，租约中包括这些参数：提供的 IP，客户端 MAC，租赁时长&lt;/p>
&lt;h1 id="isc-dhcp">ISC-DHCP&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://www.isc.org/dhcp/">ISC DHCP 官网&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://access.redhat.com/documentation/zh-cn/red_hat_enterprise_linux/8/html/configuring_and_managing_networking/providing-dhcp-services_configuring-and-managing-networking#setting-up-the-dhcp-service-for-subnets-directly-connected-to-the-dhcp-server_providing-dhcp-services">https://access.redhat.com/documentation/zh-cn/red_hat_enterprise_linux/8/html/configuring_and_managing_networking/providing-dhcp-services_configuring-and-managing-networking#setting-up-the-dhcp-service-for-subnets-directly-connected-to-the-dhcp-server_providing-dhcp-services&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>ISC-DHCP 提供了一个完整的开源解决方案，用来实现 DHCP 服务端、DHCP 客户端、DHCP 中继代理 这几种 DHCP 服务，可以将 ISC-DHCP 看作一个&lt;strong>程序的集合&lt;/strong>。ISC DHCP 支持 IPv4 和 IPv6，适用于大批量和高可靠性的应用&lt;/p>
&lt;p>CentOS 和 Ubuntu 安装的都是 ISC 分发的 DCHP 程序，不过 ISC 官方已经推荐使用 Kea DHCP 替代 ISC DHCP
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/sc7lh2/1643021582679-beb6a411-3391-4577-a658-295acbd0f2a5.png" alt="image.png">&lt;/p>
&lt;p>注意：&lt;/p>
&lt;ul>
&lt;li>在为 IPv6 分配地址时，通常需要与 radvd 程序一起运行，详见 &lt;a href="#NMGBa">DHCPv6 与 radvd 章节&lt;/a>&lt;/li>
&lt;/ul>
&lt;h2 id="安装">安装&lt;/h2>
&lt;h3 id="centos">CentOS&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>yum install dhcp
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>CentOS 的包是真的不更新。。。囧。。。。好多这种情况了。。。包中写的网址都是错误的。。。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">[&lt;/span>root@test ~&lt;span style="color:#f92672">]&lt;/span>&lt;span style="color:#75715e"># yum info dhcp&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Loaded plugins: fastestmirror, product-id, search-disabled-repos, subscription-manager
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>This system is not registered with an entitlement server. You can use subscription-manager to register.
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Loading mirror speeds from cached hostfile
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> * base: mirrors.tuna.tsinghua.edu.cn
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> * epel: mirrors.tuna.tsinghua.edu.cn
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> * extras: mirrors.tuna.tsinghua.edu.cn
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> * updates: mirrors.tuna.tsinghua.edu.cn
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Available Packages
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Name : dhcp
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Arch : x86_64
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Epoch : &lt;span style="color:#ae81ff">12&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Version : 4.2.5
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Release : 83.el7.centos.1
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Size : &lt;span style="color:#ae81ff">515&lt;/span> k
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Repo : updates/7/x86_64
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Summary : Dynamic host configuration protocol software
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>URL : http://isc.org/products/DHCP/ // 在 ISC 官网。。。这个页面已经没了。。。。。
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>License : ISC
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Description : DHCP &lt;span style="color:#f92672">(&lt;/span>Dynamic Host Configuration Protocol&lt;span style="color:#f92672">)&lt;/span> is a protocol which allows
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> : individual devices on an IP network to get their own network
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> : configuration information &lt;span style="color:#f92672">(&lt;/span>IP address, subnetmask, broadcast address,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> : etc.&lt;span style="color:#f92672">)&lt;/span> from a DHCP server. The overall purpose of DHCP is to make it
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> : easier to administer a large network.
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> :
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> : To use DHCP on your network, install a DHCP service &lt;span style="color:#f92672">(&lt;/span>or relay agent&lt;span style="color:#f92672">)&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> : and on clients run a DHCP client daemon. The dhcp package provides
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> : the ISC DHCP service and relay agent.
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="ubunt">Ubunt&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>apt install isc-dhcp-server
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>包的信息&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>root@common-ubuntu-test:/etc/dhcp# apt-cache show isc-dhcp-server
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Package: isc-dhcp-server
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Architecture: amd64
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Version: 4.4.1-2.1ubuntu5.20.04.2
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Priority: optional
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Section: net
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Source: isc-dhcp
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Origin: Ubuntu
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Maintainer: Ubuntu Developers &amp;lt;ubuntu-devel-discuss@lists.ubuntu.com&amp;gt;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Original-Maintainer: Debian ISC DHCP Maintainers &amp;lt;isc-dhcp@packages.debian.org&amp;gt;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Bugs: https://bugs.launchpad.net/ubuntu/+filebug
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Installed-Size: &lt;span style="color:#ae81ff">1503&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Depends: debconf &lt;span style="color:#f92672">(&lt;/span>&amp;gt;&lt;span style="color:#f92672">=&lt;/span> 0.5&lt;span style="color:#f92672">)&lt;/span> | debconf-2.0, libc6 &lt;span style="color:#f92672">(&lt;/span>&amp;gt;&lt;span style="color:#f92672">=&lt;/span> 2.15&lt;span style="color:#f92672">)&lt;/span>, libdns-export1109, libirs-export161, libisc-export1105, debianutils &lt;span style="color:#f92672">(&lt;/span>&amp;gt;&lt;span style="color:#f92672">=&lt;/span> 2.8.2&lt;span style="color:#f92672">)&lt;/span>, lsb-base, adduser
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Recommends: isc-dhcp-common
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Suggests: policykit-1, isc-dhcp-server-ldap, policycoreutils
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Breaks: isc-dhcp-common &lt;span style="color:#f92672">(=&lt;/span> 4.3.3-1&lt;span style="color:#f92672">)&lt;/span>, logcheck-database &lt;span style="color:#f92672">(=&lt;/span> 1.3.17~&lt;span style="color:#f92672">)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Replaces: isc-dhcp-common &lt;span style="color:#f92672">(=&lt;/span> 4.3.3-1&lt;span style="color:#f92672">)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Filename: pool/main/i/isc-dhcp/isc-dhcp-server_4.4.1-2.1ubuntu5.20.04.2_amd64.deb
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Size: &lt;span style="color:#ae81ff">454712&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>MD5sum: 92a2ec90073e62f5fe65ecb840e2fcd9
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>SHA1: 1f1253f7bcd4a8d3bec5d9736d4238115635df21
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>SHA256: b537b40e5c35054d8d3f82060936de737b08f1daa48e731652aa230170f0b21a
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>SHA512: f00f30b52b085dcf9737c7cd5d37095ecdbcf9750e7bf1e5ca1f80591d1ad9f24d5b29b2c89d40dee639803b7e1e90b92f8b3396d8976a1171321eef5d960559
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Homepage: http://www.isc.org
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Description-en: ISC DHCP server &lt;span style="color:#66d9ef">for&lt;/span> automatic IP address assignment
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> This is the Internet Software Consortium&lt;span style="color:#960050;background-color:#1e0010">&amp;#39;&lt;/span>s DHCP server.
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Dynamic Host Configuration Protocol &lt;span style="color:#f92672">(&lt;/span>DHCP&lt;span style="color:#f92672">)&lt;/span> is a protocol like BOOTP
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">(&lt;/span>actually dhcpd includes much of the functionality of bootpd&lt;span style="color:#f92672">)&lt;/span>. It
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> gives client machines &lt;span style="color:#e6db74">&amp;#34;leases&amp;#34;&lt;/span> &lt;span style="color:#66d9ef">for&lt;/span> IP addresses and can
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> automatically set their network configuration.
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> This server can handle multiple ethernet interfaces.
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Description-md5: 38647f497f13c9a0a99f9d9cf772d70d
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="dhcp-程序关联文件">dhcp 程序关联文件&lt;/h2>
&lt;p>/etc/default/isc-dhcp-server #
/etc/dhcp/dhcpd.conf # dhcpd 程序运行时行为的配置文件
/var/lib/dhcpd/dhcpd.leases 与 /var/lib/dhcpd/dhcpd.leases~ # DHCP 的客户端租约的缓存文件&lt;/p>
&lt;ul>
&lt;li>所有从 DHCP 服务器获取 IP 的客户端信息都会记录在这个文件里&lt;/li>
&lt;li>并且 dhcp 服务会探测所能分配的 IP 是否被占用，所有被占用的记录也会记在这个文件里&lt;/li>
&lt;li>注意：当 DHCP 无法按照预想的样子分配 IP 的时候，可以尝试清除该文件里的内容，让其重新获取信息&lt;/li>
&lt;/ul>
&lt;h3 id="配置文件样例">配置文件样例&lt;/h3>
&lt;p>dhcp4&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-nginx" data-lang="nginx">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">ddns-update-style&lt;/span> &lt;span style="color:#e6db74">interim&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">allow&lt;/span> &lt;span style="color:#e6db74">booting&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">allow&lt;/span> &lt;span style="color:#e6db74">bootp&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">ignore&lt;/span> &lt;span style="color:#e6db74">client-updates&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">set&lt;/span> &lt;span style="color:#e6db74">vendorclass&lt;/span> = &lt;span style="color:#e6db74">option&lt;/span> &lt;span style="color:#e6db74">vendor-class-identifier&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">option&lt;/span> &lt;span style="color:#e6db74">pxe-system-type&lt;/span> &lt;span style="color:#e6db74">code&lt;/span> &lt;span style="color:#ae81ff">93&lt;/span> = &lt;span style="color:#e6db74">unsigned&lt;/span> &lt;span style="color:#e6db74">integer&lt;/span> &lt;span style="color:#ae81ff">16&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#以下是dhcp服务所能租赁的具体网段的IP信息
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">subnet&lt;/span> &lt;span style="color:#ae81ff">192&lt;/span>&lt;span style="color:#e6db74">.168.10.0&lt;/span> &lt;span style="color:#e6db74">netmask&lt;/span> &lt;span style="color:#ae81ff">255&lt;/span>&lt;span style="color:#e6db74">.255.255.0&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e"># 指定要分配的网关
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#f92672">option&lt;/span> &lt;span style="color:#e6db74">routers&lt;/span> &lt;span style="color:#ae81ff">192&lt;/span>&lt;span style="color:#e6db74">.168.10.1&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e"># 指定要分配的DNS地址
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#f92672">option&lt;/span> &lt;span style="color:#e6db74">domain-name-servers&lt;/span> &lt;span style="color:#ae81ff">114&lt;/span>&lt;span style="color:#e6db74">.114.114.114&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e"># 指定要分配的子网掩码
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#f92672">option&lt;/span> &lt;span style="color:#e6db74">subnet-mask&lt;/span> &lt;span style="color:#ae81ff">255&lt;/span>&lt;span style="color:#e6db74">.255.255.0&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e"># 指定可分配的IP地址范围是从哪到哪
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#f92672">range&lt;/span> &lt;span style="color:#e6db74">dynamic-bootp&lt;/span> &lt;span style="color:#ae81ff">192&lt;/span>&lt;span style="color:#e6db74">.168.10.100&lt;/span> &lt;span style="color:#ae81ff">192&lt;/span>&lt;span style="color:#e6db74">.168.10.254&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e"># 默认租赁时间，如果客户端没有请求租约，则提供默认时间，数值单位为秒
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#f92672">default-lease-time&lt;/span> &lt;span style="color:#ae81ff">21600&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e"># 最大租赁时间，可以提供给客户端租用网络参数的最大时间，数值单位为秒
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#f92672">max-lease-time&lt;/span> &lt;span style="color:#ae81ff">43200&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e"># PXE环境下指定的提供引导程序的服务器。i.e.该参数的值为PEX服务端的设备IP或HostName。
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#75715e"># 比如cobbler服务所在的服务器地址，或者tftp服务所在服务地址等等
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#f92672">next-server&lt;/span> &lt;span style="color:#ae81ff">10&lt;/span>&lt;span style="color:#e6db74">.10.17.15&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">class&lt;/span> &lt;span style="color:#e6db74">&amp;#34;pxeclients&amp;#34;&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">match&lt;/span> &lt;span style="color:#e6db74">if&lt;/span> &lt;span style="color:#e6db74">substring&lt;/span> &lt;span style="color:#e6db74">(option&lt;/span> &lt;span style="color:#e6db74">vendor-class-identifier,&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>&lt;span style="color:#e6db74">,&lt;/span> &lt;span style="color:#ae81ff">9&lt;/span>&lt;span style="color:#e6db74">)&lt;/span> = &lt;span style="color:#e6db74">&amp;#34;PXEClient&amp;#34;&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">if&lt;/span> &lt;span style="color:#e6db74">option&lt;/span> &lt;span style="color:#e6db74">pxe-system-type&lt;/span> = 00:&lt;span style="color:#ae81ff">02&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">filename&lt;/span> &lt;span style="color:#e6db74">&amp;#34;ia64/elilo.efi&amp;#34;&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> } &lt;span style="color:#f92672">else&lt;/span> &lt;span style="color:#e6db74">if&lt;/span> &lt;span style="color:#e6db74">option&lt;/span> &lt;span style="color:#e6db74">pxe-system-type&lt;/span> = 00:&lt;span style="color:#ae81ff">06&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">filename&lt;/span> &lt;span style="color:#e6db74">&amp;#34;grub/grub-x86.efi&amp;#34;&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> } &lt;span style="color:#f92672">else&lt;/span> &lt;span style="color:#e6db74">if&lt;/span> &lt;span style="color:#e6db74">option&lt;/span> &lt;span style="color:#e6db74">pxe-system-type&lt;/span> = 00:&lt;span style="color:#ae81ff">07&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">filename&lt;/span> &lt;span style="color:#e6db74">&amp;#34;grub/grub-x86_64.efi&amp;#34;&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> } &lt;span style="color:#f92672">else&lt;/span> &lt;span style="color:#e6db74">if&lt;/span> &lt;span style="color:#e6db74">option&lt;/span> &lt;span style="color:#e6db74">pxe-system-type&lt;/span> = 00:&lt;span style="color:#ae81ff">09&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">filename&lt;/span> &lt;span style="color:#e6db74">&amp;#34;grub/grub-x86_64.efi&amp;#34;&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> } &lt;span style="color:#f92672">else&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">filename&lt;/span> &lt;span style="color:#e6db74">&amp;#34;pxelinux.0&amp;#34;&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># group for Cobbler DHCP tag: default
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">group&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#当有其余网段需要分配时，可以继续添加相关信息
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">subnet&lt;/span> &lt;span style="color:#ae81ff">10&lt;/span>&lt;span style="color:#e6db74">.10.17.0&lt;/span> &lt;span style="color:#e6db74">netmask&lt;/span> &lt;span style="color:#ae81ff">255&lt;/span>&lt;span style="color:#e6db74">.255.255.0&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">option&lt;/span> &lt;span style="color:#e6db74">domain-name-servers&lt;/span> &lt;span style="color:#ae81ff">114&lt;/span>&lt;span style="color:#e6db74">.114.114.114&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">option&lt;/span> &lt;span style="color:#e6db74">routers&lt;/span> &lt;span style="color:#ae81ff">10&lt;/span>&lt;span style="color:#e6db74">.10.17.1&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">range&lt;/span> &lt;span style="color:#e6db74">dynamic-bootp&lt;/span> &lt;span style="color:#ae81ff">10&lt;/span>&lt;span style="color:#e6db74">.10.17.15&lt;/span> &lt;span style="color:#ae81ff">10&lt;/span>&lt;span style="color:#e6db74">.10.17.22&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">option&lt;/span> &lt;span style="color:#e6db74">subnet-mask&lt;/span> &lt;span style="color:#ae81ff">255&lt;/span>&lt;span style="color:#e6db74">.255.255.0&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">next-server&lt;/span> &lt;span style="color:#ae81ff">10&lt;/span>&lt;span style="color:#e6db74">.10.17.15&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">default-lease-time&lt;/span> &lt;span style="color:#ae81ff">21600&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">max-lease-time&lt;/span> &lt;span style="color:#ae81ff">43200&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>dhcp6&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-properties" data-lang="properties">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">default-lease-time&lt;/span> &lt;span style="color:#e6db74">600;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">max-lease-time&lt;/span> &lt;span style="color:#e6db74">7200;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">log-facility&lt;/span> &lt;span style="color:#e6db74">local7;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">subnet6&lt;/span> &lt;span style="color:#e6db74">2001:db8:0:1::/64 {&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e"># 可以分配的地址范围&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">range6&lt;/span> &lt;span style="color:#e6db74">2001:db8:0:1::129 2001:db8:0:1::254;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e"># 为客户端分配的临时地址&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">range6&lt;/span> &lt;span style="color:#e6db74">2001:db8:0:1::/64 temporary;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e"># Prefix range for delegation to sub-routers&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">prefix6&lt;/span> &lt;span style="color:#e6db74">2001:db8:0:100:: 2001:db8:0:f00:: /56;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e"># 一些可选的配置&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">option&lt;/span> &lt;span style="color:#e6db74">dhcp6.name-servers fec0:0:0:1::1;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">option&lt;/span> &lt;span style="color:#e6db74">dhcp6.domain-search &amp;#34;domain.example&amp;#34;;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e"># 将 IP 地址与 MAC 绑定的示例&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">host&lt;/span> &lt;span style="color:#e6db74">specialclient {&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">host-identifier&lt;/span> &lt;span style="color:#e6db74">option dhcp6.client-id 00:01:00:01:4a:1f:ba:e3:60:b9:1f:01:23:45;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">fixed-address6&lt;/span> &lt;span style="color:#e6db74">2001:db8:0:1::127;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#960050;background-color:#1e0010"> }&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#960050;background-color:#1e0010">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h1 id="kea-dhcp">Kea-DHCP&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://www.isc.org/kea/">Kea DHCP 官网&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;h1 id="dhcrelaydhcp-中继器简介">DhcRelay(DHCP 中继器)简介&lt;/h1>
&lt;p>DHCP Relay，DHCP 中继器，用于从没有 DHCP 服务的子网中连接到其他子网上的一个或多个 DHCP 服务器，来中继(代理、转发)DHCP 和 BOOTP 请求。它支持 DHCPv4 / BOOTP 和 DHCPv6 协议。实际应用：e.g.我有两个网段 192.168.10.0/24 和 192.168.20.0/24，在 10 网段有 DHCP 服务器，但是 20 网段没有，这时候就可以在 20 网段的设备上开启 dhcrelay 服务，然后指定一个 DHCP 服务器，来为 20 网段进行 DHCP 服务。&lt;/p>
&lt;h2 id="dhcrelay-的使用方法">dhcrelay 的使用方法&lt;/h2>
&lt;h2 id="dhcrelay-命令">dhcrelay 命令&lt;/h2>
&lt;p>语法格式：&lt;/p>
&lt;ul>
&lt;li>dhcrelay [ -4 ] [ -dqaD ] [ -p port ] [ -c count ] [ -A length ] [ -pf pid-file ] [ &amp;ndash;no-pid ] [ -m append | replace | forward | dis‐card ] [ -i interface0 [ &amp;hellip; -i interfaceN ] ] server0 [ &amp;hellip;serverN ]&lt;/li>
&lt;li>dhcrelay -6 [ -dqI ] [ -p port ] [ -c count ] [ -pf pid-file ] [ &amp;ndash;no-pid ] -l lower0 [ &amp;hellip; -l lowerN ] -u upper0 [ &amp;hellip; -u upperN ]&lt;/li>
&lt;/ul>
&lt;p>OPTIONS&lt;/p>
&lt;ul>
&lt;li>-i #在指定网络接口上监听 DHCPv4 / BOOTP 查询。&lt;/li>
&lt;/ul>
&lt;p>EXAMPLE&lt;/p>
&lt;ul>
&lt;li>dhcrelay 192.168.10.12 # 在本机开启 dhcp 中继代理，指定目的 DHCP 服务器 IP 为 192.168.10.12&lt;/li>
&lt;/ul>
&lt;h1 id="dhcpv6-与-radvd">DHCPv6 与 radvd&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://access.redhat.com/documentation/zh-cn/red_hat_enterprise_linux/8/html/configuring_and_managing_networking/providing-dhcp-services_configuring-and-managing-networking#comparison-of-dhcpv6-to-radvd_providing-dhcp-services">https://access.redhat.com/documentation/zh-cn/red_hat_enterprise_linux/8/html/configuring_and_managing_networking/providing-dhcp-services_configuring-and-managing-networking#comparison-of-dhcpv6-to-radvd_providing-dhcp-services&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>在 IPv6 网络中，只有路由器广告信息在 IPv6 默认网关上提供信息。因此，如果您要在需要默认网关设置的子网中使用 DHCPv6，还必须配置路由器广告服务，如 Router Advertisement Daemon（radvd）。&lt;/p>
&lt;p>radvd 服务使用路由器广告数据包中的标记声明 DHCPv6 服务器可用。&lt;/p>
&lt;p>路由器广告守护进程（radvd）发送路由器公告信息，这是 IPv6 无状态自动配置所需的。这可让用户根据这些公告自动配置其地址、设置、路由和选择默认路由器。
本节中的步骤解释了如何配置 radvd。
&lt;strong>先决条件&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>您以 root 用户身份登录。&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>流程&lt;/strong>&lt;/p>
&lt;ol>
&lt;li>安装 radvd 软件包：# yum install radvd&lt;/li>
&lt;li>编辑 /etc/radvd.conf 文件并添加以下配置：&lt;/li>
&lt;/ol>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-properties" data-lang="properties">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">interface&lt;/span> &lt;span style="color:#e6db74">ens3&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#960050;background-color:#1e0010">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">AdvSendAdvert&lt;/span> &lt;span style="color:#e6db74">on;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">AdvManagedFlag&lt;/span> &lt;span style="color:#e6db74">on;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">AdvOtherConfigFlag&lt;/span> &lt;span style="color:#e6db74">on;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">prefix&lt;/span> &lt;span style="color:#e6db74">2001:db8:0:1::/64 {&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#960050;background-color:#1e0010"> };&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#960050;background-color:#1e0010">};&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ol start="3">
&lt;li>这些设置将 radvd 配置为在 enp1s0 设备中为 2001:db8:0:1::/64 子网发送路由器广告信息。AdvManagedFlag on 设置定义客户端应该从 DHCP 服务器接收 IP 地址，AdvOtherConfigFlag 参数设置为 on 定义客户端也应该从 DHCP 服务器接收非地址信息。&lt;/li>
&lt;li>（可选）配置 radvd 会在系统引导时自动启动：# systemctl enable radvd&lt;/li>
&lt;li>启动 radvd 服务：# systemctl start radvd&lt;/li>
&lt;li>另外，还可显示路由器公告软件包的内容和配置的值 radvd 发送：# radvdump&lt;/li>
&lt;/ol>
&lt;p>&lt;strong>其它资源&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>有关配置 radvd 的详情，请查看 radvd.conf(5) man page。&lt;/li>
&lt;li>如需 radvd 的示例配置，请参阅 /usr/share/doc/radvd/radvd.conf.example 文件。&lt;/li>
&lt;/ul></description></item><item><title>Docs: 7.FTP</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/4.%E6%95%B0%E6%8D%AE%E9%80%9A%E4%BF%A1/%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/7.ftp/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/4.%E6%95%B0%E6%8D%AE%E9%80%9A%E4%BF%A1/%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/7.ftp/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;p>&lt;strong>File Transfer Protocol(文件传输协议，简称 FTP)&lt;/strong> 是因特网网络上历史最悠久的网络工具，从 1971 年由 A KBHUSHAN 提出第一个 FTP 的 RFC（RFC114） [2] 至今近半个世纪来，FTP 凭借其独特的优势一直都是因特网中最重要、最广泛的服务之一。 [3]&lt;/p>
&lt;p>FTP 的目标是提高文件的共享性，提供非直接使用远程计算机，使存储介质对用户透明和可靠高效地传送数据。它能操作任何类型的文件而不需要进一步处理，就像 MIME 或 Unicode 一样。但是，FTP 有着极高的延时，这意味着，从开始请求到第一次接收需求数据之间的时间，会非常长；并且不时的必须执行一些冗长的登录进程。 [4-5]&lt;/p></description></item><item><title>Docs: 7.HTTP</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/4.%E6%95%B0%E6%8D%AE%E9%80%9A%E4%BF%A1/%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/7.http/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/4.%E6%95%B0%E6%8D%AE%E9%80%9A%E4%BF%A1/%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/7.http/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://tools.ietf.org/html/rfc2616">RFC 2616&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://developer.mozilla.org/en-US/docs/Web/HTTP">Mozilla 官方 HTTP 开发文档&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://mp.weixin.qq.com/s/bUy220-ect00N4gnO0697A">公众号-小林 coding，硬核！30 张图解 HTTP 常见的面试题&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://mp.weixin.qq.com/s/WQpxfwLArltKEjEAdOO2Pw">公众号-码海，51 张图助你彻底掌握 HTTP 协议&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>&lt;strong>HyperText Transfer Protocol(超文本传输协议，简称 HTTP)&lt;/strong>。是基于 TCP 的用于分布式、协作式、超媒体的信息系统的应用层协议。HTTP 是 &lt;a href="https://en.wikipedia.org/wiki/World_Wide_Web">World Wide Web(万维网,简称 WWW.就是我们俗称的 Web)&lt;/a> 的数据通信基础。&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/rlkp9t/1616161240441-f2958719-b738-4698-9fca-64d90f3471ba.png" alt="">&lt;/p>
&lt;h2 id="http-标准的演化">HTTP 标准的演化&lt;/h2>
&lt;blockquote>
&lt;p>参考：&lt;a href="https://www.infoq.cn/article/2014/06/http-11-updated">InfoQ 中的消息&lt;/a>&lt;/p>
&lt;/blockquote>
&lt;p>在 2014 年之前，HTTP/1.1 版本的标准为 &lt;a href="https://tools.ietf.org/html/rfc2616">RFC 2616&lt;/a>，但由于&lt;a href="https://tools.ietf.org/html/rfc7230#appendix-A.2">某些原因&lt;/a>，为了让标准更规范，HTTP/1.1 被拆分成了 6 个部分：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://tools.ietf.org/html/rfc7230">RFC7230 - HTTP/1.1&lt;/a>: Message Syntax and Routing(消息语法和路由)。这里包含 低级的消息解析 和 链接管理。&lt;/li>
&lt;li>&lt;a href="https://tools.ietf.org/html/rfc7231">RFC7231 - HTTP/1.1&lt;/a>: Semantics and Content(语意和内容)。这里面包含了 Methods、Status Codes、Headers&lt;/li>
&lt;li>RFC7232 - HTTP/1.1: Conditional Requests - e.g., If-Modified-Since&lt;/li>
&lt;li>RFC7233 - HTTP/1.1: Range Requests - getting partial content&lt;/li>
&lt;li>RFC7234 - HTTP/1.1: Caching - browser and intermediary caches&lt;/li>
&lt;li>RFC7235 - HTTP/1.1: Authentication - a framework for HTTP authentication&lt;/li>
&lt;/ul>
&lt;h2 id="http-三个部分">HTTP 三个部分&lt;/h2>
&lt;h3 id="1-协议">1. 「协议」&lt;/h3>
&lt;p>在生活中，我们也能随处可见「协议」，例如：&lt;/p>
&lt;ul>
&lt;li>刚毕业时会签一个「三方协议」；&lt;/li>
&lt;li>找房子时会签一个「租房协议」；&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/rlkp9t/1616161240448-b1263f75-a700-4431-9d6b-a99b36a58214.png" alt="">
三方协议和租房协议&lt;/p>
&lt;p>生活中的协议，本质上与计算机中的协议是相同的，协议的特点:&lt;/p>
&lt;ul>
&lt;li>「&lt;strong>协&lt;/strong>」字，代表的意思是必须有&lt;strong>两个以上的参与者&lt;/strong>。例如三方协议里的参与者有三个：你、公司、学校三个；租房协议里的参与者有两个：你和房东。&lt;/li>
&lt;li>「&lt;strong>议&lt;/strong>」字，代表的意思是对参与者的一种&lt;strong>行为约定和规范&lt;/strong>。例如三方协议里规定试用期期限、毁约金等；租房协议里规定租期期限、每月租金金额、违约如何处理等。&lt;/li>
&lt;/ul>
&lt;p>针对 HTTP &lt;strong>协议&lt;/strong>，我们可以这么理解。&lt;/p>
&lt;p>HTTP 是一个用在计算机世界里的&lt;strong>协议&lt;/strong>。它使用计算机能够理解的语言确立了一种计算机之间交流通信的规范（&lt;strong>两个以上的参与者&lt;/strong>），以及相关的各种控制和错误处理方式（&lt;strong>行为约定和规范&lt;/strong>）。&lt;/p>
&lt;h3 id="2-传输">2. 「传输」&lt;/h3>
&lt;p>所谓的「传输」，很好理解，就是把一堆东西从 A 点搬到 B 点，或者从 B 点 搬到 A 点。&lt;/p>
&lt;p>别轻视了这个简单的动作，它至少包含两项重要的信息。&lt;/p>
&lt;p>HTTP 协议是一个&lt;strong>双向协议&lt;/strong>。&lt;/p>
&lt;p>我们在上网冲浪时，浏览器是请求方 A ，百度网站就是应答方 B。双方约定用 HTTP 协议来通信，于是浏览器把请求数据发送给网站，网站再把一些数据返回给浏览器，最后由浏览器渲染在屏幕，就可以看到图片、视频了。
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/rlkp9t/1616161240434-514ef4d5-6830-46f1-9674-7c6564798dfd.png" alt="">
Request(请求) - (Response)应答&lt;/p>
&lt;p>数据虽然是在 A 和 B 之间传输，但允许中间有&lt;strong>中转或接力&lt;/strong>。&lt;/p>
&lt;p>就好像第一排的同学想传递纸条给最后一排的同学，那么传递的过程中就需要经过好多个同学（中间人），这样的传输方式就从「A &amp;lt; &amp;mdash; &amp;gt; B」，变成了「A &amp;lt;-&amp;gt; N &amp;lt;-&amp;gt; M &amp;lt;-&amp;gt; B」。&lt;/p>
&lt;p>而在 HTTP 里，需要中间人遵从 HTTP 协议，只要不打扰基本的数据传输，就可以添加任意额外的东西。&lt;/p>
&lt;p>针对&lt;strong>传输&lt;/strong>，我们可以进一步理解了 HTTP。&lt;/p>
&lt;p>HTTP 是一个在计算机世界里专门用来在&lt;strong>两点之间传输数据&lt;/strong>的约定和规范。&lt;/p>
&lt;h3 id="3-超文本">3. 「超文本」&lt;/h3>
&lt;p>HTTP 传输的内容是「超文本」。&lt;/p>
&lt;p>我们先来理解「文本」，在互联网早期的时候只是简单的字符文字，但现在「文本」的涵义已经可以扩展为图片、视频、压缩包等，在 HTTP 眼里这些都算作「文本」。&lt;/p>
&lt;p>再来理解「超文本」，它就是&lt;strong>超越了普通文本的文本&lt;/strong>，它是文字、图片、视频等的混合体，最关键有超链接，能从一个超文本跳转到另外一个超文本。&lt;/p>
&lt;p>HTML 格式的文件就是最常见的超文本了，它本身只是纯文字文件，但内部用很多标签定义了图片、视频等的链接，再经过浏览器的解释，呈现给我们的就是一个文字、有画面的网页了。&lt;/p>
&lt;h2 id="总结">总结&lt;/h2>
&lt;p>OK，经过了对 HTTP 里这三个名词的详细解释，就可以给出比「超文本传输协议」这七个字更准确更有技术含量的答案：&lt;/p>
&lt;p>&lt;strong>HTTP 是一个在计算机世界里专门在「两点」之间「传输」文字、图片、音频、视频等「超文本」数据的「约定和规范」。&lt;/strong>&lt;/p>
&lt;blockquote>
&lt;p>这里的两点可以是服务器到本地电脑，本地电脑到服务器、服务器到服务器、电脑到电脑，等等。&lt;/p>
&lt;/blockquote>
&lt;h1 id="http-请求过程概述">HTTP 请求过程概述&lt;/h1>
&lt;p>HTTP 事务由一次 &lt;strong>Client 的 Request(请求)&lt;/strong> 和 &lt;strong>Server 的 Response(响应)&lt;/strong> 组成。即 HTTP 协议是 Stateless(无状态)。(因为连接一次后就断开了，不会持久化存储任何数据)&lt;/p>
&lt;p>比如一个用户(Client 客户端)向服务器发起了一个请求，请求一个页面，在该页面输入完用户名和密码后进行登录后，如果刷新页面，那么就需要重新输入用户名和密码，因为 client 向 server 只请求了一个页面，请求完成后，连接就断开了，后续的请求是新的，没法再用以前的信息。这时候为了解决该问题，引用了 Cookie 和 Session 保持 的概念。&lt;/p>
&lt;p>相关技术&lt;/p>
&lt;ol>
&lt;li>Cookie：类似于 Token，相当于一个令牌，当访问一个 web server 的时候，server 发给 client 一个 Cookie，让 client 保存在本地，再次访问的时候，即可通过该 Cookie 识别身份&lt;/li>
&lt;li>Session(会话)保持：关联至 Cookie：当你在动态网页上访问了一些信息，比如购物车，在购物车添加一件物品，即通过 Session 功能来保存该信息，以便下次登录还能使用。否则下次登录购物车中的东西就没了&lt;/li>
&lt;/ol>
&lt;h2 id="流程简述">流程简述&lt;/h2>
&lt;ul>
&lt;li>建立或处理连接，接收请求或拒绝请求
&lt;ul>
&lt;li>建立 TCP 连接，WEB 浏览器向 Web 服务器发送请求&lt;/li>
&lt;li>web 浏览器发送请求头部信息
&lt;ul>
&lt;li>建立连接后，客户机发送一个请求给服务器，请求方式的格式为：URL、协议版本号、后面是 MIME 信息包括请求修饰符、客户机信息和可能得内容&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Server 接收请求，并应答
&lt;ul>
&lt;li>WEB 服务器接收到请求后，给予相应的响应信息，其格式为一个状态行，包括信息的协议版本号、一个成功或错误的代码，后边是 MIME 信息包括服务器信息、实体信息和可能得内容&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Server 处理请求
&lt;ul>
&lt;li>Web 服务器发送应答头信息&lt;/li>
&lt;li>Web 服务器向浏览器发送数据&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Client 访问资源
&lt;ul>
&lt;li>WEB 服务器关闭 TCP 连接&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>构建响应报文&lt;/li>
&lt;li>发送响应报文&lt;/li>
&lt;li>记录日志&lt;/li>
&lt;/ul>
&lt;h1 id="http-报文格式">HTTP 报文格式&lt;/h1>
&lt;h2 id="request-与-response-报文">Request 与 Response 报文&lt;/h2>
&lt;h3 id="request-请求报文">Request 请求报文&lt;/h3>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/rlkp9t/1616161240468-d9f13310-3f67-43b8-b5b7-b48dde683170.png" alt="">&lt;/p>
&lt;ul>
&lt;li>&lt;strong>Method&lt;/strong> # 请求方法，用于表明 Client 希望 Server 对 Resource 执行的动作。常用：GET、POST、DELETE&lt;/li>
&lt;li>&lt;strong>URL&lt;/strong> # HTTP 请求的 URL。
&lt;ul>
&lt;li>&lt;strong>Params&lt;/strong> # URL 参数。就是 URL 中的 Query 部分&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>Version&lt;/strong> # 发送给 Server 的请求的 HTTP 协议版本。&lt;/li>
&lt;li>**Headers **# 请求头。&lt;/li>
&lt;li>**Body **# 请求体。&lt;/li>
&lt;/ul>
&lt;blockquote>
&lt;p>这里面有一个要注意的地方，就是 Params 与 Headers，&lt;strong>Params 是 URL 的一部分&lt;/strong>，但是 Headers 不是。虽然两者的作用类似，都是用来定义这个请求中应该发送给对方的一些基本信息、认证信息 等等。但是在一个 HTTP 的请求中，两者所处的位置是不一样，用于不同场景。&lt;/p>
&lt;/blockquote>
&lt;p>&lt;strong>Authorization&lt;/strong> # 认证信息。这是一个比较特殊的东西，可以存在于 URL 的 Params 中、Headers 中、Body 中。请求报文的各个部分，都可以填写认证信息。&lt;/p>
&lt;ul>
&lt;li>当 Server 需要一个认证信息时，就需要在 HTTP 请求中加入认证相关的信息。&lt;/li>
&lt;/ul>
&lt;h4 id="example">EXAMPLE&lt;/h4>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/rlkp9t/1616161240442-63d3fc7f-80c2-43e4-bec5-50061f2e02f2.png" alt="">&lt;/p>
&lt;h3 id="response-响应报文">Response 响应报文&lt;/h3>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/rlkp9t/1616161240462-a29c9d65-119a-4b70-993f-bd1a4cfbbd7e.png" alt="">&lt;/p>
&lt;ul>
&lt;li>&lt;strong>Version&lt;/strong> # 响应给 Client 的 HTTP 版本。&lt;/li>
&lt;li>&lt;strong>Status&lt;/strong> # HTTP 响应状态。用来标记请求过程中发生的情况，由 server 告诉 client。响应状态由两部分组成&lt;/li>
&lt;li>&lt;strong>StatusCode&lt;/strong> # 状态码。统一为 3 位的数字。
&lt;ul>
&lt;li>各个状态码的含义，见&lt;a href="https://www.yuque.com/go/doc/33218939">状态码详解章节&lt;/a>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>**ReasonPhrase **# 原因短语。用来表示产生该状态的原因的简要说明&lt;/li>
&lt;li>&lt;strong>Headers&lt;/strong> # 响应头。&lt;/li>
&lt;li>&lt;strong>Body&lt;/strong> # 响应体。实体部分，请求时附加的数据或响应时附加的数据&lt;/li>
&lt;/ul>
&lt;h4 id="example-1">EXAMPLE&lt;/h4>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/rlkp9t/1616161240440-85fac56c-d3ed-44dc-94f3-20d60017e622.png" alt="">&lt;/p>
&lt;h2 id="http-header">HTTP Header&lt;/h2>
&lt;blockquote>
&lt;p>参考：&lt;a href="https://tools.ietf.org/html/rfc2616">RFC 2616&lt;/a>&lt;/p>
&lt;/blockquote>
&lt;p>HTTP 请求和响应报文的 Header(头) 基本都是 Key/Value(键值) 格式，Key 与 Value 以冒号分隔，此外，除了标准的头部字段之外，还可以添加自定义头，这就给 HTTP 带来了无限的扩展可能。注意，Value 不区分大小写。&lt;/p>
&lt;p>HTTP 协议规定了非常多的 Header 字段，可以实现各种各样的功能，但基本上可以分为以下四类&lt;/p>
&lt;ol>
&lt;li>&lt;strong>General Header(通用头)&lt;/strong> # 在请求头和响应头里都可以出现；&lt;/li>
&lt;li>&lt;strong>Request Header(请求头)&lt;/strong> # 仅能出现在请求头里，进一步说明请求信息或者额外的附加条件；&lt;/li>
&lt;li>&lt;strong>Response Header(响应头)&lt;/strong> # 仅能出现在响应头里，补充说明响应报文的信息；&lt;/li>
&lt;li>&lt;strong>Entity Header(实体头)&lt;/strong> # 它实际上属于通用字段，但专门描述 body 的额外信息。&lt;/li>
&lt;li>&lt;strong>Extension Header(扩展头)&lt;/strong> # 不在标准规范中，可以通过自定义头实现更多定制化需求的 Header 信息。&lt;/li>
&lt;/ol>
&lt;p>&lt;strong>对 HTTP 报文的解析和处理其实本质上就是对头字段的处理&lt;/strong>，HTTP 的连接管理，缓存控制，内容协商等都是通过头字段来处理的，&lt;strong>理解了头字段，基本上也就理解了 HTTP&lt;/strong>，所以理解头字段非常重要。&lt;/p>
&lt;p>详见：&lt;a href="https://www.yuque.com/go/doc/33218949">HTTP 协议头部字段详解&lt;/a>&lt;/p>
&lt;p>注意：这种分类是在 RFC 2616 标准中定义的，在新的 RFC 7231 中，已经看不到这种分类了&lt;/p>
&lt;h2 id="http-的请求-method方法">HTTP 的请求 Method(方法)&lt;/h2>
&lt;p>根据 HTTP 标准，HTTP 请求可以使用多种请求方法。 HTTP 的 1.0 版本中只有三种请求方法： GET, POST 和 HEAD 方法。到了 1.1 版本时，新增加了五种请求方法：OPTIONS, PUT, DELETE, TRACE 和 CONNECT 方法。&lt;/p>
&lt;ul>
&lt;li>&lt;strong>GET&lt;/strong> # 从服务器获取了资源
&lt;ul>
&lt;li>请求指定的页面信息，并返回实体主体。&lt;/li>
&lt;li>GET 请求请提交的数据放置在 HTTP 请求协议头中，GET 方法通过 URL 请求来传递用户的输入，GET 方式的提交你需要用 Request.QueryString 来取得变量的值。&lt;/li>
&lt;li>GET 方法提交数据，可能会带来安全性的问题，数据被浏览器缓存。&lt;/li>
&lt;li>GET 请求有长度限制。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>HEAD&lt;/strong> # 只从 server 获取文档的响应首部（报文中的 Headers）
&lt;ul>
&lt;li>类似于 get 请求，只不过返回的响应中没有具体的内容，用于获取报头。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>POST&lt;/strong> # 向 server 发送要处理的数据
&lt;ul>
&lt;li>向指定资源提交数据进行处理请求（例如提交表单或者上传文件）。&lt;/li>
&lt;li>POST 请求可能会导致新的资源的建立和/或已有资源的修改。&lt;/li>
&lt;li>POST 方式提交时，你必须通过 Request.Form 来访问提交的内容&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>PUT&lt;/strong> # 将请求的主体存储在 server 上
&lt;ul>
&lt;li>从客户端向服务器传送的数据取代指定的文档的内容。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>DELETE&lt;/strong> # 请求删除 server 上通过 URL 指定的文档，DELETE 请求一般返回 3 种码
&lt;ul>
&lt;li>200（OK）——删除成功，同时返回已经删除的资源。&lt;/li>
&lt;li>202（Accepted）——删除请求已经接受，但没有被立即执行（资源也许已经被转移到了待删除区域）。&lt;/li>
&lt;li>204（No Content）——删除请求已经被执行，但是没有返回资源（也许是请求删除不存在的资源造成的）。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>OPTIONS&lt;/strong> #** **请求服务器返回对指定资源支持使用的请求方法
&lt;ul>
&lt;li>允许客户端查看服务器的性能。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>TRACE&lt;/strong> # 追踪请求到达 server 中间经过的 server agent
&lt;ul>
&lt;li>回显服务器收到的请求，主要用于测试或诊断。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h3 id="get-与-post">GET 与 POST&lt;/h3>
&lt;p>&lt;code>Get&lt;/code> 方法的含义是请求&lt;strong>从服务器获取资源&lt;/strong>，这个资源可以是静态的文本、页面、图片视频等。&lt;/p>
&lt;p>比如，你打开我的文章，浏览器就会发送 GET 请求给服务器，服务器就会返回文章的所有文字及资源。
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/rlkp9t/1649668233003-6c01ab91-90f8-4ea8-8095-5448302146e8.jpeg" alt="">
而&lt;code>POST&lt;/code> 方法则是相反操作，它向 &lt;code>URI&lt;/code> 指定的资源提交数据，数据就放在报文的 body 里。&lt;/p>
&lt;p>比如，你在我文章底部，敲入了留言后点击「提交」（&lt;strong>暗示你们留言&lt;/strong>），浏览器就会执行一次 POST 请求，把你的留言文字放进了报文 body 里，然后拼接好 POST 请求头，通过 TCP 协议发送给服务器。
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/rlkp9t/1649668232954-1a090cec-1a9c-4c11-a370-d49b4156cac3.jpeg" alt="">
GET 和 POST 方法都是安全和幂等的吗？&lt;/p>
&lt;p>先说明下安全和幂等的概念：&lt;/p>
&lt;ul>
&lt;li>在 HTTP 协议里，所谓的「安全」是指请求方法不会「破坏」服务器上的资源。&lt;/li>
&lt;li>所谓的「幂等」，意思是多次执行相同的操作，结果都是「相同」的。&lt;/li>
&lt;/ul>
&lt;p>那么很明显 &lt;strong>GET 方法就是安全且幂等的&lt;/strong>，因为它是「只读」操作，无论操作多少次，服务器上的数据都是安全的，且每次的结果都是相同的。&lt;/p>
&lt;p>&lt;strong>POST&lt;/strong> 因为是「新增或提交数据」的操作，会修改服务器上的资源，所以是&lt;strong>不安全&lt;/strong>的，且多次提交数据就会创建多个资源，所以&lt;strong>不是幂等&lt;/strong>的。&lt;/p></description></item><item><title>Docs: 7.NTP</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/4.%E6%95%B0%E6%8D%AE%E9%80%9A%E4%BF%A1/%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/7.ntp/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/4.%E6%95%B0%E6%8D%AE%E9%80%9A%E4%BF%A1/%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/7.ntp/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;p>&lt;strong>Network Time Protocol(网络时间协议，简称 NTP)&lt;/strong> 是在数据网络潜伏时间可变的计算机系统之间通过分组交换进行时钟同步的一个网络协议，位于 OSI 模型的应用层。自 1985 年以来，NTP 是目前仍在使用的最古老的互联网协议之一。NTP 由特拉华大学的 David L. Mills 设计。&lt;/p>
&lt;p>NTP 意图将所有参与计算机的协调世界时（UTC）时间同步到几毫秒的误差内。[1]:3 它使用 Marzullo 算法的修改版来选择准确的时间服务器，其设计旨在减轻可变网络延迟造成的影响。NTP 通常可以在公共互联网保持几十毫秒的误差，并且在理想的局域网环境中可以实现超过 1 毫秒的精度。不对称路由和拥塞控制可能导致 100 毫秒（或更高）的错误。[2][3]&lt;/p>
&lt;p>该协议通常描述为一种主从式架构，但它也可以用在点对点网络中，对等体双方可将另一端认定为潜在的时间源。[1]:20 发送和接收时间戳采用用户数据报协议（UDP）的端口 123 实现。[4][5]这也可以使用广播或多播，其中的客户端在最初的往返校准交换后被动地监听时间更新。[3]NTP 提供一个即将到来闰秒调整的警告，但不会传输有关本地时区或夏时制的信息。[2][3]&lt;/p>
&lt;p>当前协议为版本 4（NTPv4），这是一个 RFC 5905 文档中的建议标准。它向下兼容指定于 RFC 1305 的版本 3。&lt;/p>
&lt;p>目录&lt;/p>
&lt;ul>
&lt;li>1 历史&lt;/li>
&lt;li>2 时钟层&lt;/li>
&lt;li>3 时间戳&lt;/li>
&lt;li>4 时钟同步算法&lt;/li>
&lt;li>5 软件实现&lt;/li>
&lt;li>5.1 参考实现&lt;/li>
&lt;li>5.2SNTP&lt;/li>
&lt;li>5.3Windows 时间服务&lt;/li>
&lt;li>5.4Ntimed&lt;/li>
&lt;li>6 闰秒&lt;/li>
&lt;li>72038 年问题&lt;/li>
&lt;li>8 安全问题&lt;/li>
&lt;li>9 参见&lt;/li>
&lt;li>10 备注&lt;/li>
&lt;li>11 参考资料&lt;/li>
&lt;li>12 拓展阅读&lt;/li>
&lt;li>13 外部链接&lt;/li>
&lt;/ul>
&lt;p>历史[编辑]&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/lqlu60/1616161444690-ae048176-3985-441b-86bb-8fcaf5569d90.jpeg" alt="">&lt;/p>
&lt;p>NTP 的设计者 David L. Mills。&lt;/p>
&lt;p>1979 年，网络时间同步技术在纽约的国家计算机会议上于运行在跨大西洋卫星网络的互联网服务上公开演示，这可能是该技术的首次公开演示。该技术后在 1981 年互联网工程笔记（IEN）173 中描述，并根据 RFC 778 文档开发为一个公开协议。该技术首先被部署在一个本地网络，作为 Hello 路由协议的一部分，并在 Fuzzball（一个用于网络原型的实验操作系统，已运行多年）中实现。&lt;/p>
&lt;p>现在还有其他的相关网络工具。这包括 Daytime 和 Time 协议用以记录事件时间，以及互联网控制消息协议和 IP 时间戳选项（RFC 781）。更多完整的同步系统，虽然缺乏 NTP 的数据分析和时钟规律算法，包括 Unix 守护进程 timed 在内的软件其使用选举算法为所有客户端指定服务器。以及数字时间同步服务（Digital Time Synchronization Service，DTSS）使用类似构 NTP 阶层模型的服务器层次结构。&lt;/p>
&lt;p>1985 年，NTPv0 被实现于 Fuzzball 和 Unix，文档化于 RFC 958 的 NTP 数据包头、和往返延迟和偏移计算都被留存至 NTPv4。尽管当时可用的计算机和网络相对较慢，但在跨大西洋链路上也获取了优于 100 毫秒的精度，在以太网网络上准确度为几十毫秒。&lt;/p>
&lt;p>1988 年，一个更完整的 NTPv1 协议规范及相关的算法发表在 RFC 1059。它利用了 RFC 956 的文献中的实验结果和时钟滤波算法，并是第一个描述客户端-服务器和点对点网络模型的版本。1991 年，NTPv1 架构、协议和算法通过 David L. Mills 在 IEEE Transactions on Communications 发布的一篇文章得到了工程学界的更广泛关注。&lt;/p>
&lt;p>1989 年，RFC 1119 发布通过有限状态机定义的 NTPv2，使用伪代码来描述其操作。它引入了一个管理协议和加密认证方案，它们留存至 NTPv4。社区批评 NTP 的设计缺乏形式正确性原则。他们的替代设计包括 Marzullo 算法，其修改版本已及时添加到 NTP。这个时代的大多数算法也大部分留存至 NTPv4。&lt;/p>
&lt;p>1992 年，RFC 1305 定义了 NTPv3。该 RFC 包括一个对所有错误来源的分析，从参考时钟至最终客户端，这使帮助度量和选择最佳服务器成为可能（在其中几个候选者反对的情况下）。广播模式被引入。&lt;/p>
&lt;p>在接下来的几年里，随着新特性的添加和算法的改进，显然还需要一个新的协议版本。[6]2010 年，RFC 5905 发布了一个对 NTPv4 的建议规范，但该协议自那时以来已经显著改变，截至 2014 年，更新的 RFC 尚未发布。[7]在 Mills 从特拉华大学退休后，该参考实现目前由 Harlan Stenn 保持为一个开放源代码项目。[8][9]&lt;/p>
&lt;p>时钟层[编辑]&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/lqlu60/1616161444688-dd02f9db-d4f3-4ba6-b2a1-10daf2c80df3.jpeg" alt="">&lt;/p>
&lt;p>美国海军天文台备用主时钟 Schriever AFB (Colorado)是一个第 0 层的 NTP 源&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/lqlu60/1616161444707-1f04a452-f5ae-4d30-abaa-6646e633ffa0.jpeg" alt="">&lt;/p>
&lt;p>黄色箭头表示直接连接；红色箭头表示网络连接。&lt;/p>
&lt;p>NTP 使用一个分层、半分层的时间源系统。该层次的每个级别被称为“stratum”，顶层分配为数字 0。一个通过阶层 n 同步的服务器将运行在阶层 n + 1。数字表示与参考时钟的距离，用于防止层次结构中的循环依赖性。阶层并不总是指示质量或可靠性；在阶层 3 的时间源得到比阶层 2 时间源更高的时间质量也很常见。电信系统对时钟层使用不同的定义。以下提供了阶层 0、1、2、3 的简要描述。&lt;/p>
&lt;p>阶层 0（Stratum 0）&lt;/p>
&lt;p>这些是高精度计时设备，例如原子钟（如铯、铷）、GPS 时钟或其他无线电时钟。它们生成非常精确的脉冲秒信号，触发所连接计算机上的中断和时间戳。阶层 0 设备也称为参考（基准）时钟。&lt;/p>
&lt;p>阶层 1&lt;/p>
&lt;p>这些与阶层 0 设备相连、在几微秒误差内同步系统时钟的计算机。阶层 1 服务器可能与其他阶层 1 服务器对等相连，以进行完整性检查和备份。[10]它们也被称为主要（primary）时间服务器。[2][3]&lt;/p>
&lt;p>阶层 2&lt;/p>
&lt;p>这些计算机通过网络与阶层 1 服务器同步。提供阶层 2 的计算机将查询多个阶层 1 服务器。阶层 2 计算机也可能与其他阶层 2 计算机对等相连，为对等组中的所有设备提供更健全稳定的时间。&lt;/p>
&lt;p>阶层 3&lt;/p>
&lt;p>这些计算机与阶层 2 的服务器同步。它们使用与阶层 2 相同的算法进行对等和数据采样，并可以自己作为服务器担任阶层 4 计算机，以此类推。&lt;/p>
&lt;p>阶层的上限为 15；阶层 16 被用于标识设备未同步。每台计算机上的 NTP 算法相互构造一个贝尔曼-福特算法最短路径生成树，以最小化所有客户端到阶层 1 服务器的累积往返延迟。[1]:20&lt;/p>
&lt;p>时间戳[编辑]&lt;/p>
&lt;p>NTP 使用 64 比特的时间戳，其中 32 位表示秒，32 位表示秒的小数，给出一个每 232 秒（136 年）才会翻转的时间尺度，理论分辨率 2−32 秒（233 皮秒）。NTP 以 1900 年 1 月 1 日作为开始时间，因此第一次翻转将在 2036 年 2 月 7 日发生。[11][12]&lt;/p>
&lt;p>NTP 的未来版本可能将时间表示扩展到 128 位：其中 64 位表示秒，64 位表示秒的小数。当前的 NTPv4 格式支持“时代数字”（Era Number）和“时代偏移”（Era Offset），正确使用它们应该有助于解决日期翻转问题。据 Mills 称：“64 位的秒小数足以分辨光子以光速通过电子所需的时间。64 位的秒足以提供明确的时间表示，直到宇宙变暗。”[13][note 1]&lt;/p>
&lt;p>时钟同步算法[编辑]&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/lqlu60/1616161444690-fed573bb-2fbf-45f7-b1db-69f4d664acee.jpeg" alt="">&lt;/p>
&lt;p>往返延迟时间 δ&lt;/p>
&lt;p>典型的 NTP 客户端将定期轮询不同网络上的三个或更多服务器。为同步其时钟，客户端必须计算其时间偏移量和来回通信延迟。时间偏移“θ”定义为：&lt;/p>
&lt;p>&lt;img src="" alt="">&lt;/p>
&lt;p>，&lt;/p>
&lt;p>往返延迟“δ”为：&lt;/p>
&lt;p>&lt;img src="" alt="">&lt;/p>
&lt;p>，&lt;/p>
&lt;p>其中：&lt;/p>
&lt;p>t0 是请求数据包传输的客户端时间戳，&lt;/p>
&lt;p>t1 是请求数据包回复的服务器时间戳，&lt;/p>
&lt;p>t2 是响应数据包传输的服务器时间戳&lt;/p>
&lt;p>t3 是响应数据包回复的客户端时间戳。[1]:19&lt;/p>
&lt;p>“θ”和“δ”的值通过过滤器并进行统计分析。异常值被剔除，并从最好的三个剩余候选中导出估算的时间偏移。然后调整时钟频率以逐渐减小偏移，创建一个反馈回路。[1]:20&lt;/p>
&lt;p>当客户端和服务器之间的输入和输出路由都具有对称的标称延迟时，同步是正确的。如果路由没有共同的标称延迟，则将差异取半作为测量误差。[14]&lt;/p>
&lt;p>软件实现[编辑]&lt;/p>
&lt;p>&lt;img src="" alt="">&lt;/p>
&lt;p>查询第二层服务器状态的 NTP 管理协议实用工具 ntpq。&lt;/p>
&lt;p>参考实现[编辑]&lt;/p>
&lt;p>NTP 参考实现连同协议的开发已持续发展了 20 多年。随着新功能的添加，向后兼容性仍保持不变。它包含几个敏感的算法，尤其是时钟规律，在同步到使用不同算法的服务器时可能会发生错误。该软件已移植到几乎各个计算平台，包括个人计算机。[1]:13 它在 Unix 上运行名为 ntpd 的守护进程，或在 Windows 上运行为一个 Windows 服务。[1]:15 支持参考时钟，并且以与远程服务器相同的方式对偏移进行过滤和分析，尽管它们通常更频繁地轮询。[1]:19&lt;/p>
&lt;p>SNTP[编辑]&lt;/p>
&lt;p>一个不太复杂的 NTP 实现，使用相同的协议但不需要存储较长时间的状态[15]，也称简单网络时间协议（Simple Network Time Protocol，SNTP）。它使用在某些嵌入式系统和不需要高精度时间的应用中。[16][17]&lt;/p>
&lt;p>Windows 时间服务[编辑]&lt;/p>
&lt;p>从 Windows 2000 起的所有 Microsoft Windows 版本都包括 Windows 时间服务（W32Time），[18]其具有将计算机时钟同步到 NTP 服务器的能力。&lt;/p>
&lt;p>W32Time 服务最初是为实现 Kerberos 第五版的身份验证协议，它需要误差 5 分钟内正确时间值以防止重放攻击。Windows 2000 和 Windows XP 中只实现了简单的 NTP，并在几个方面违反了 NTP 第 3 版的标准。[19]从 Windows Server 2003 和 Windows Vista 开始，已包括符合完整 NTP 的实现。[20]微软称 W32Time 服务不能可靠地将同步时间保持在 1 至 2 秒的范围内。[21]如果需要更高的精度，微软建议使用其他 NTP 实现。[22]&lt;/p>
&lt;p>Windows Server 2016 现在在某些操作条件下支持 1ms 的时间精度。[23]&lt;/p>
&lt;p>Ntimed[编辑]&lt;/p>
&lt;p>一个新的 NTP 客户端 ntimed 由 Poul-Henning Kamp 在 2014 年开始编写。[24]新的实现由 Linux 基金会赞助，作为参考实现的一个替代，因为它决定更容易地从头开始编写新的实现，而不是修复现有大型代码库的现有问题。截至 2015 年 6 月，它尚未正式发布，但 ntimed 可以可靠地同步时钟。[25]ntimed 在 Debian 和 FreeBSD 上工作，但也被移植到 Windows 和 Mac OS。[26]&lt;/p>
&lt;p>闰秒[编辑]&lt;/p>
&lt;p>在闰秒事件的当天，ntpd 从配置文件、附加参考时钟或远程服务器收到通知。因为时间必须是单调递增，所以闰秒的插入方式为：23:59:59、23:59:60、00:00:00。虽然时钟实际上在事件期间停止，但任何查询系统时间的进程都会使它增加微小的量，以保持事件的顺序。如果必要，在序列中删除闰秒的形式为：23:59:58、00:00:00，跳过 23:59:59。[27]&lt;/p>
&lt;p>2038 年问题[编辑]&lt;/p>
&lt;p>安全问题[编辑]&lt;/p>
&lt;p>2014 年底，几个安全问题被发现。在以前，研究人员发现 NTP 服务器可能受到中间人攻击的影响，除非数据包被加密和签名以验证身份。[28]但这所涉及的计算量在繁忙的服务器上可能是不切实际的，尤其是容易遭遇拒绝服务攻击。[29]NTP 消息欺骗可以被用来偏移客户端计算机上的时钟，并配合过期的加密密钥来完成其他攻击。[30]可能受到伪造 NTP 消息影响的服务包括 TLS、DNSSEC、各类缓存方案（例如 DNS 缓存）、比特币以及许多持久登录方案。[31][32]&lt;/p>
&lt;p>有着 25 年以上历史的 NTP 代码库中的参考实现中只发现了几个其他的安全问题，但最近[何时？]出现的几个引起了人们的强烈关注。[33][34]该协议正在对其整个历史进行修订和审查。截至 2011 年 1 月，在 NTP 规范中没有安全修订，也没有在 CERT 的报告。[35]几年来，该参考实现的当前代码库已经被多个来源进行安全审计，在当前发布的软件中没有已知的高风险漏洞。[36]&lt;/p>
&lt;p>多种 NTP 服务器误用和滥用实践的存在导致了对网络时间协议（NTP）服务器的破坏或劣化。&lt;/p>
&lt;p>NTP 已经被用于分布式拒绝服务（DDoS）攻击，[37][38]方法是将一个具有伪造的返回地址的小的查询发送到 NTP 服务器。类似 DNS 放大攻击，服务器将以比攻击者发送数据量大很多倍的数据量回复给伪造的目标。为了避免参与攻击，服务器可以配置为忽略外部查询，或者升级到 4.2.7p26 或更高版本。[39]&lt;/p>
&lt;p>一个缓存溢出漏洞已经被发现，并自 2014 年 12 月 19 日提供补丁。漏洞覆盖 NTP 第四版所有版本，自 4.2.8 修复。[40]苹果公司首次使用自动更新功能解决该问题[41]，不过这只适用最近的 MacOS 版本。在 10.6.8 版本中，用户可以手动修复服务器版本，以及普通用户可以在系统首选项-日期和时间中关闭自动更新时间。[42]研究人员认为该协议的设计是相当好的，缺陷出现在协议的实现中。某些错误很基础，例如例程中缺少返回语句，这可能导致某些运行在 root 权限下的 NTP 版本被利用以无限制的访问系统。守护进程不使用 root 权限的系统（例如 BSD）不受此缺陷的影响。[43]&lt;/p></description></item><item><title>Docs: 7.WebSocket</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/4.%E6%95%B0%E6%8D%AE%E9%80%9A%E4%BF%A1/%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/7.websocket/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/4.%E6%95%B0%E6%8D%AE%E9%80%9A%E4%BF%A1/%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/7.websocket/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/WebSocket">Wiki,WebSocket&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://mp.weixin.qq.com/s/TtRKkVxS6H-miQ8luQgY1A">公众号-小林 coding，有了 HTTP 协议，为什么还要有 websocket 协议？&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>WebSocket 是一种计算机通信协议，通过单个 TCP 连接提供&lt;strong>全双工&lt;/strong>通信通道。&lt;/p>
&lt;p>WebSocket 与 HTTP 不同。这两种协议都位于&lt;a href="https://en.wikipedia.org/wiki/OSI_model">OSI 模型的&lt;/a>&lt;a href="https://en.wikipedia.org/wiki/Layer_7">第 7 层&lt;/a>，并依赖于第 4 层的 TCP。尽管它们不同，但 &lt;a href="https://en.wikipedia.org/wiki/RFC_(identifier)">RFC&lt;/a>&lt;a href="https://datatracker.ietf.org/doc/html/rfc6455">6455&lt;/a> 指出 WebSocket“旨在通过 HTTP 端口 443 和 80 工作，并支持 HTTP 代理和中介” ，从而使其与 HTTP 兼容。为了实现兼容性，WebSocket &lt;a href="https://en.wikipedia.org/wiki/Handshaking">握手&lt;/a>使用 &lt;a href="https://en.wikipedia.org/wiki/HTTP/1.1_Upgrade_header">HTTP Upgrade 头&lt;/a>从 HTTP 协议更改为 WebSocket 协议。&lt;/p>
&lt;p>WebSocket 协议支持 &lt;a href="https://en.wikipedia.org/wiki/Web_browser">Web 浏览器&lt;/a>（或其他客户端应用程序）和 &lt;a href="https://en.wikipedia.org/wiki/Web_server">Web 服务器&lt;/a>之间的交互，其开销比半双工替代方案（例如 HTTP&lt;a href="https://en.wikipedia.org/wiki/Polling_(computer_science)">轮询）低&lt;/a>，从而促进从服务器到服务器的实时数据传输。这是通过为服务器提供一种标准化的方式来向客户端发送内容而无需客户端首先请求，并允许消息在保持连接打开的同时来回传递而实现的。通过这种方式，可以在客户端和服务器之间进行双向正在进行的对话。通信通常通过 TCP&lt;a href="https://en.wikipedia.org/wiki/Port_(computer_networking)">端口&lt;/a>完成数字 443（或在不安全连接的情况下为 80），这对于使用&lt;a href="https://en.wikipedia.org/wiki/Firewall_(computing)">防火墙&lt;/a>阻止非网络 Internet 连接的环境有益。类似的浏览器-服务器双向双向通信已经使用&lt;a href="https://en.wikipedia.org/wiki/Comet_(programming)">Comet&lt;/a>或&lt;a href="https://en.wikipedia.org/wiki/Adobe_Flash_Player">Adobe Flash Player&lt;/a>等临时技术以非标准化方式实现。&lt;a href="https://en.wikipedia.org/wiki/WebSocket#cite_note-2">[2]&lt;/a>&lt;/p>
&lt;p>大多数浏览器都支持该协议，包括&lt;a href="https://en.wikipedia.org/wiki/Google_Chrome">Google Chrome&lt;/a>、&lt;a href="https://en.wikipedia.org/wiki/Firefox">Firefox&lt;/a>、&lt;a href="https://en.wikipedia.org/wiki/Microsoft_Edge">Microsoft Edge&lt;/a>、&lt;a href="https://en.wikipedia.org/wiki/Internet_Explorer">Internet Explorer&lt;/a>、&lt;a href="https://en.wikipedia.org/wiki/Safari_(web_browser)">Safari&lt;/a>和&lt;a href="https://en.wikipedia.org/wiki/Opera_web_browser">Opera&lt;/a>。&lt;a href="https://en.wikipedia.org/wiki/WebSocket#cite_note-3">[3]&lt;/a>
与 HTTP 不同，WebSocket 提供全双工通信。&lt;a href="https://en.wikipedia.org/wiki/WebSocket#cite_note-4">[4]&lt;/a>&lt;a href="https://en.wikipedia.org/wiki/WebSocket#cite_note-quantum-5">[5]&lt;/a> 此外，WebSocket 支持基于 TCP 的消息流。TCP 单独处理字节流，而没有消息的固有概念。在 WebSocket 之前，使用&lt;a href="https://en.wikipedia.org/wiki/Comet_(programming)">Comet&lt;/a>通道可以实现端口 80 全双工通信；然而，Comet 的实现并不简单，并且由于 TCP 握手和 HTTP 标头开销，对于小消息来说效率低下。WebSocket 协议旨在在不损害 Web 安全假设的情况下解决这些问题。&lt;/p>
&lt;p>WebSocket 协议规范将 ws(WebSocket) 和 wss(WebSocket Secure) 定义为两种新的&lt;a href="https://en.wikipedia.org/wiki/Uniform_resource_identifier">统一资源标识符&lt;/a>(URI) 方案&lt;a href="https://en.wikipedia.org/wiki/WebSocket#cite_note-6">[6]&lt;/a>，分别用于未加密和加密连接。除了方案名称和&lt;a href="https://en.wikipedia.org/wiki/Fragment_identifier">片段&lt;/a>（即#不支持），其余的 URI 组件被定义为使用&lt;a href="https://en.wikipedia.org/wiki/Path_segment">URI 通用语法&lt;/a>。&lt;a href="https://en.wikipedia.org/wiki/WebSocket#cite_note-7">[7]&lt;/a>
使用浏览器开发人员工具，开发人员可以检查 WebSocket 握手以及 WebSocket 帧。&lt;a href="https://en.wikipedia.org/wiki/WebSocket#cite_note-8">[8]&lt;/a>&lt;/p>
&lt;h1 id="其他文章">其他文章&lt;/h1>
&lt;blockquote>
&lt;p>&lt;a href="https://mp.weixin.qq.com/s/38hgQ2zDBfl09tSruiwtDA">https://mp.weixin.qq.com/s/38hgQ2zDBfl09tSruiwtDA&lt;/a>&lt;/p>
&lt;/blockquote>
&lt;p>随着科技发展，人们需求越来越多，生活的方方面面都离不开一些实时信息。比如：疫情期间在家协同办公、疫情监控目标人的实时运动轨迹、社交中的实时消息、多玩家互动游戏、每秒瞬息万变的股市基金报价、体育实况播放、音视频聊天、视频会议、在线教育等等，都可以借用 WebSocket TCP 链接可以让数据飞起来。下面就聊一下 WebSocket 协议。&lt;/p>
&lt;p>WebSocket 是 HTML5 开始提供的一种浏览器与服务器间进行全双工通讯的网络技术,一种基于 TCP 连接上进行全双工通信的协议，相对于 HTTP 这种非持久的协议来说，WebSocket 是一个持久化网络通信的协议。依靠这种技术可以实现客户端和服务器端的长连接，双向实时通信。&lt;/p>
&lt;p>它不仅可以实现客户端请求服务器，同时可以允许服务端主动向客户端推送数据。是真正的双向平等对话，属于服务器推送技术的一种。在 WebSocket API 中，客户端和服务器只需要完成一次握手，两者之间就直接可以创建持久性的连接，并进行双向数据传输。&lt;/p>
&lt;p>&lt;strong>「其他特点包括：」&lt;/strong>&lt;/p>
&lt;blockquote>
&lt;ul>
&lt;li>建立在 TCP 协议之上，服务器端的实现比较容易。&lt;/li>
&lt;li>与 HTTP 协议有着良好的兼容性。默认端口也是 80 和 443，并且握手阶段采用 HTTP 协议，因此握手时不容易屏蔽，能通过各种 HTTP 代理服务器。&lt;/li>
&lt;li>数据格式比较轻量，性能开销小，通信高效。&lt;/li>
&lt;li>可以发送文本，也可以发送二进制数据。&lt;/li>
&lt;li>没有同源限制，客户端可以与任意服务器通信。&lt;/li>
&lt;li>协议标识符是 ws（如果加密，则为 wss），服务器网址就是 URL。&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>协议标识符是 ws（如果加密，则为 wss），服务器网址就是 URL&lt;/p>
&lt;p>&lt;code>ws://xxx.ayunw.cn:80/some/path wss://xxx.ayunw.cn:443/some/path&lt;/code>&lt;/p>
&lt;p>另外客户端不只是浏览器，只要实现了 ws 或者 wss 协议的客户端 socket 都可以和服务器进行通信。&lt;/p>
&lt;h3 id="先说一下为什么需要-websocket-协议">先说一下为什么需要 WebSocket 协议?&lt;/h3>
&lt;p>在 Web 应用架构中，连接由 HTTP/1.0 和 HTTP/1.1 处理。HTTP 是客户端/服务器模式中 请求一响应 所用的协议，在这种模式中，客户端(一般是浏览器)向服务器提交 HTTP 请求，服务器响应请求的资源(例如 HTML 页面)。&lt;/p>
&lt;p>HTTP 是无状态的，也就是说，它将每个请求当成唯一和独立的。无状态协议具有一些优势，例如，服务器不需要保存有关会话的信息，从而不需要存储数据。但是，这也意味着在每次 HTTP 请求和响应中都会发送关于请求的冗余信息，比如使用 Cookie 进行用户状态的验证。&lt;/p>
&lt;p>随着客户端和服务器之间交互的增加，HTTP 协议在客户端和服务器之间通信所需要的信息量快速增加。&lt;/p>
&lt;p>从根本上讲，HTTP 还是 半双工 的协议，也就是说，在同一时刻信息的流向只能单向的：客户端向服务器发送请求(单向)，然后服务器响应请求(单向)。半双工方式的通信效率是非常低的。&lt;/p>
&lt;p>同时 HTTP 协议有一个缺陷：通信只能由客户端发起。&lt;/p>
&lt;p>这种单向请求的特点，注定了如果服务器有状态变化，是无法主动通知客户端的。&lt;/p>
&lt;p>为了能够及时的获取服务器的变化，我们尝试过各种各样的方式：&lt;/p>
&lt;blockquote>
&lt;ul>
&lt;li>轮询(polling)：每隔一段时间，就发出一个请求，了解服务器有没有新的信息。不精准，有延时，大量无效数据交换。&lt;/li>
&lt;li>长轮询( long polling)：客户端向服务器请求信息，并在设定的时间段内保持连接。直到服务器有新消息响应，或者连接超时，这种技术常常称作“挂起 GET”或“搁置 POST”。占用服务器资源，相对轮询并没有优势，没有标准化。&lt;/li>
&lt;li>流化技术：在流化技术中，客户端发送一个请求，服务器发送并维护一个持续更新和保持打开(可以是无限或者规定的时间段)的开放响应。每当服务器有需要交付给客户端的信息时，它就更新响应。服务器从不发出完成 HTTP 响应。代理和防火墙可能缓存响应，导致信息交付的延迟增加。&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>上述方法提供了近乎实时的通信，但是它们也涉及 HTTP 请求和响应首标，包含了许多附加和不必要的首标数据与延迟。此外，在每一种情况下，客户端都必须等待请求返回，才能发出后续的请求，而这显著地增加了延退。同时也极大地增加了服务器的压力。&lt;/p>
&lt;h3 id="什么是-websocket-协议">什么是 websocket 协议?&lt;/h3>
&lt;p>Websocket 其实是一个新协议，借用了 HTTP 的协议来完成一部分握手，只是为了兼容现有浏览器的握手规范而已。Websocket 是一种自然的全双工、双向、单套接字连接，解决了 HTTP 协议中不适合于实时通信的问题。&lt;/p>
&lt;p>&lt;strong>「一个典型的 Websocket 握手如下：」&lt;/strong>&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>GET /chat HTTP/1.1
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Host: server.example.com
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Upgrade: websocket
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Connection: Upgrade
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Sec-WebSocket-Key: x3JJHMbDL1EzLkh9GBhXDw&lt;span style="color:#f92672">==&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Sec-WebSocket-Protocol: chat, superchat
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Sec-WebSocket-Version: &lt;span style="color:#ae81ff">13&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Origin: http://example.com
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>其中 Websocket 的核心如下，它告诉 Apache、Nginx 等服务器：注意，我发起的是 Websocket 协议，快点帮我找到对应的助理处理而不是那个老土的 HTTP。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>Upgrade: websocket
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Connection: Upgrade
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;strong>「服务器返回如下：」&lt;/strong>&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>HTTP/1.1 &lt;span style="color:#ae81ff">101&lt;/span> Switching Protocols
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Upgrade: websocket
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Connection: Upgrade
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Sec-WebSocket-Accept: HSmrc0sMlYUkAGmm5OPpG2HaGWk&lt;span style="color:#f92672">=&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Sec-WebSocket-Protocol: chat
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>至此，HTTP 已经完成它所有工作了，接下来就是完全按照 Websocket 协议进行了。&lt;/p>
&lt;h1 id="tcp-segment-结构">TCP Segment 结构&lt;/h1>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/xgaggc/1669021238963-8fd674c5-92c0-408a-9c39-a1df68ed7e24.png" alt="">&lt;/p></description></item><item><title>Docs: BIND</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/4.%E6%95%B0%E6%8D%AE%E9%80%9A%E4%BF%A1/dns/bind/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/4.%E6%95%B0%E6%8D%AE%E9%80%9A%E4%BF%A1/dns/bind/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://www.isc.org/bind/">ISC-BIND9 官方网站&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/BIND">Wiki,BIND&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>&lt;strong>Bekerley Internat Name Domain(伯克利互联网名字域，简称 BIND)&lt;/strong> 是实现 DNS 服务的应用程序。该程序最著名的组件被称为 &lt;strong>named&lt;/strong>，主要用来实现两个最主要的 DNS 功能：&lt;strong>NameServer(名称服务器)&lt;/strong> 与 &lt;strong>Resolver(解析器)&lt;/strong>。&lt;/p>
&lt;p>该软件最初是在 1980 年代初在加州大学伯克利分校 (UCB) 设计的。该名称起源于 Berkeley Internet Name Domain 的首字母缩写词，反映了该应用程序在 UCB 中的使用。最新版本是 BIND 9，于 2000 年首次发布，仍然由 Internet Systems Consortium (ISC) 积极维护，每年发布数次新版本。&lt;/p>
&lt;p>BIND9 已进化为一个非常灵活，全功能的 DNS 系统。无论您的应用程序是什么，绑定 9 可能具有所需的功能。作为第一个，最旧，最常见的解决方案，还有更多网络工程师已经熟悉绑定 9，而不是与任何其他系统。&lt;/p>
&lt;h1 id="bind-部署">BIND 部署&lt;/h1>
&lt;p>dns 服务，包名 bind，程序名 named&lt;/p>
&lt;p>基础程序包：bind 提供服务，bing-libs 提供库文件，bind-utils 提供测试程序&lt;/p>
&lt;p>rndc:remote name domain controller,默认与 bind 安装在同一主机，且只能通过 127.0.1 来连接 named 进程，提供辅助性的管理功能，使用 tcp 的 953 端口&lt;/p>
&lt;p>配置文件：&lt;/p>
&lt;ul>
&lt;li>/etc/named.conf&lt;/li>
&lt;li>/etc/named.rfc1912.zomes #该文件的引用，定义在 named.conf 的最后几行&lt;/li>
&lt;li>/etc/rndc.key&lt;/li>
&lt;/ul>
&lt;p>解析库文件：/var/named/ZONE_NAME.ZONE,有以下注意事项&lt;/p>
&lt;ul>
&lt;li>一台物理服务器可以同时为多个区域提供解析&lt;/li>
&lt;li>必须要有根区域文件 named.ca&lt;/li>
&lt;li>应该有两个实现 localhost 和本地回环地址的解析库&lt;/li>
&lt;/ul>
&lt;p>/etc/named.conf # 配置文件 keywords 说明&lt;/p>
&lt;ol>
&lt;li>options{ #用于全局 BIND 配置，BIND 的工作目录在 /var/named&lt;/li>
&lt;/ol>
&lt;ul>
&lt;li>listen-on port NUM { IP1; IP2; }; #设置 DNS 服务监听的端口号 NUM 和监听该端口的 IP 地址&lt;/li>
&lt;li>allow-query { any; }; #设置任何人都可以来这台服务器解析&lt;/li>
&lt;li>forward { first|only }； #转发服务器配置，加了此项则定义先进行域名解析请求转发,转发不了再去迭代查询,可用 first 或者 only 模式&lt;/li>
&lt;li>forwarders { IP； } #转发服务器配置，转发的 IP 地址&lt;/li>
&lt;li>}；&lt;/li>
&lt;/ul>
&lt;ol>
&lt;li>loggin{} #配置哪些需要记录，哪些需要忽略&lt;/li>
&lt;li>zone &amp;ldquo;ZONE_NAME&amp;rdquo; IN { #定义 DNS 区域。本机能够为哪些 zone(区域)进行解析，就要定义哪些 zone，比如域名 google.com，它包含子域名 mail.google.com 和 analytics.google.com 等。这几个域名都有一个由 zone 语句定义的区域，该定义可以直接写在.zone 的解析库文件里&lt;/li>
&lt;/ol>
&lt;ul>
&lt;li>type ; #定义该服务器是什么职责，包括主，辅助，根，转发这四种&lt;/li>
&lt;li>file ”ZONE_NAME.zone“； #区域解析库文件，默认在该文件在/var/named 目录下，所以该位置直接写文件名即可&lt;/li>
&lt;li>};&lt;/li>
&lt;/ul>
&lt;ol>
&lt;li>include #在 named.conf 中包含另一个文件。比如 named.rfc1912.zomes 该文件包含其余定义的 zone 信息&lt;/li>
&lt;/ol>
&lt;p>/var/named/ZONE_NAME.zone #解析库文件说明&lt;/p>
&lt;p>EXAMPLE&lt;/p>
&lt;ul>
&lt;li>$TTL 86400 #该条目告诉 BIND 每个单独记录的 TTL 值（time to live，生存时间值）。它是以秒为单位的数值，比如 14,400 秒（4 个小时），因此 DNS 服务器最多缓存你的域文件 4 个小时，之后就会向你的 DNS 服务器重新查询。&lt;/li>
&lt;li>$ORIGIN baidu.com. #定义该项后，资源格式里可以省略后面的根域名，顶级域名，所有写的域名自带该变量定义的域名&lt;/li>
&lt;li>@ IN SOA ns1.baidu.com. admin.baidu.com (&lt;/li>
&lt;li>2015042201&lt;/li>
&lt;li>1H&lt;/li>
&lt;li>5M&lt;/li>
&lt;li>7D&lt;/li>
&lt;li>1D )&lt;/li>
&lt;li>
&lt;pre>&lt;code> IN NS ns1.baidu.com
&lt;/code>&lt;/pre>
&lt;/li>
&lt;li>
&lt;pre>&lt;code> IN NS ns2.baidu.com
&lt;/code>&lt;/pre>
&lt;/li>
&lt;li>ns1 IN A 1.1.1.1&lt;/li>
&lt;li>ns2 IN A 1.1.1.2&lt;/li>
&lt;li>www IN A 1.1.1.3&lt;/li>
&lt;li>
&lt;pre>&lt;code> IN A 1.1.1.4
&lt;/code>&lt;/pre>
&lt;/li>
&lt;li>
&lt;pre>&lt;code> IN MX 10 mx1.baidu.com
&lt;/code>&lt;/pre>
&lt;/li>
&lt;li>
&lt;pre>&lt;code> IN MX 20 mx2.baidu.com
&lt;/code>&lt;/pre>
&lt;/li>
&lt;li>4.3.2.1in-addr.arpa. IN PTR &lt;a href="https://www.baidu.com">www.baidu.com&lt;/a>&lt;/li>
&lt;li>web IN CNAME &lt;a href="https://www.baidu.com">www.baidu.com&lt;/a>&lt;/li>
&lt;/ul>
&lt;p>主从复制机制：&lt;/p>
&lt;ol>
&lt;li>应该为一台独立的名称服务器&lt;/li>
&lt;li>主服务器的区域解析库文件中必须有一条 NS 记录是指向从服务器&lt;/li>
&lt;li>从服务器只需定义区域，而无需提供解析库文件，解析库问文件应该放置于/var/named/slaves/目录中&lt;/li>
&lt;li>主服务器得允许从服务器作区域传送&lt;/li>
&lt;li>主从服务器时间应该同步，可通过 NTP 进行&lt;/li>
&lt;li>bind 程序的版本应该保持一致，如果无法一致，至少应该从高主低&lt;/li>
&lt;/ol>
&lt;p>日志文件说明&lt;/p>
&lt;p>当您写入域文件时，也许您忘记了一个句号或空格或其他任意错误。&lt;/p>
&lt;p>你可以从日志诊断 Linux DNS 服务器错误。BIND 服务通过/var/log/messages 上的错误，可以使用 tail 命令来查看实时错误日志，须使用-f 选项：$ tail -f /var /log/messages。&lt;/p>
&lt;p>因此，当你编写域文件或修改/etc/named.config 并重新启动服务时，显示错误之后，你可以从日志中轻松识别错误类型。&lt;/p>
&lt;p>定义一个主域服务器&lt;/p>
&lt;p>我们知道 DNS 服务器类型有主域名服务器、辅助域名服务器和缓存域名服务器。不同于缓存域名服务器，主域名服务器和辅助域名服务器在应答过程中是处于同等地位的。&lt;/p>
&lt;p>在 /etc/named.conf 的配置文件中，你可以使用如下语法定义一个主域服务器：&lt;/p>
&lt;p>包含主要区域信息的文件存放在 /var/named 目录下，从 options 可知，这是一个工作目录。&lt;/p>
&lt;p>注意：软件服务器或者托管面板会根据你的域名自动为你创建主域服务器信息的文件名，因此如果你的域名是 example.org，那么你主域服务器信息的文件就为 /var/named/example.org.db。&lt;/p>
&lt;p>类型为 master，也就是说这是一个主域服务器。&lt;/p>
&lt;p>定义一个辅助域服务器&lt;/p>
&lt;p>同定义一个主域服务器一样，辅助域服务器的定义稍微有些变化&lt;/p>
&lt;p>zone &amp;ldquo;ZONE_NAME&amp;rdquo; IN {&lt;/p>
&lt;p>type slave;&lt;/p>
&lt;p>masters I{ MASTER-IP; } ;&lt;/p>
&lt;p>file “slaves/ZONE_NAME.zone”;&lt;/p>
&lt;p>};&lt;/p>
&lt;p>对于辅助域服务器来说，它的域名和主域服务器是一样的。上述语法里的的 slave 类型表示这是一个辅助域服务器，“masters IP Address list”表示辅助域服务器中区域文件内的信息都是通过主域服务器中区域文件内的信息复制过来的。&lt;/p>
&lt;p>定义一个缓存服务器&lt;/p>
&lt;p>即使你已经配置了主域或者辅助域服务器，你仍有必要（不是必须）定义一个缓存服务器，因为这样你可以减少 DNS 服务器的查询次数。&lt;/p>
&lt;p>在定义缓存服务器之前，你需要先定义三个区域选择器，第一个：&lt;/p>
&lt;p>zone &amp;ldquo;.&amp;rdquo; IN {&lt;/p>
&lt;p>type hint;&lt;/p>
&lt;p>file &amp;ldquo;root.hint&amp;rdquo;;&lt;/p>
&lt;p>};&lt;/p>
&lt;p>zone &amp;ldquo;.&amp;rdquo; IN {&lt;/p>
&lt;p>type hint;&lt;/p>
&lt;p>file &amp;ldquo;root.hint&amp;rdquo;;&lt;/p>
&lt;p>};&lt;/p>
&lt;p>zone &amp;ldquo;.&amp;rdquo; IN {&lt;/p>
&lt;p>type hint;&lt;/p>
&lt;p>file &amp;ldquo;root.hint&amp;rdquo;;&lt;/p>
&lt;p>};&lt;/p>
&lt;p>zone &amp;ldquo;localhost&amp;rdquo; IN {&lt;/p>
&lt;p>type master;&lt;/p>
&lt;p>file &amp;ldquo;localhost.db&amp;rdquo;;&lt;/p>
&lt;p>};&lt;/p>
&lt;p>定义第三个区域是为了反向查找到本地主机。这种反向查找是把本地的 IP 地址执向本地主机。&lt;/p>
&lt;p>zone &amp;ldquo;0.0.127.in-addr.arpa&amp;rdquo; IN {&lt;/p>
&lt;p>type master;&lt;/p>
&lt;p>file &amp;ldquo;127.0.0.rev&amp;rdquo;;&lt;/p>
&lt;p>};&lt;/p>
&lt;p>把这三个区域信息放到/etc/named.conf 文件里，你的系统就可以以缓存服务器来工作了。&lt;/p>
&lt;p>TXT 记录&lt;/p>
&lt;p>您可以将任何信息存储到 TXT 记录中，例如你的联系方式或者你希望人们在查询 DNS 服务器时可获得的任意其他信息。&lt;/p>
&lt;p>你可以这样保存 TXT 记录：example.com. IN TXT ” YOUR INFO GOES HERE”.&lt;/p>
&lt;p>此外，RP 记录被创建为对 host 联系信息的显式容器：example.com. IN RP mail.example.com. example.com。&lt;/p>
&lt;p>Linux DNS 解析器&lt;/p>
&lt;p>我们已经知道 Linux DNS 服务器的工作原理以及如何配置它。另一部分当然是与 DNS 服务器交互的（正在与 DNS 服务器通信以将主机名解析为 IP 地址的）客户端。&lt;/p>
&lt;p>在 Linux 上，解析器位于 DNS 的客户端。要配置解析器，可以检查/etc/resolv.conf 这个配置文件。&lt;/p>
&lt;p>在基于 Debian 的发行版上，可以查看/etc/resolvconf/resolv.conf.d/目录。&lt;/p>
&lt;p>/etc/resolv.conf 文件中包含客户端用于获取其本地 DNS 服务器地址所需的信息。&lt;/p>
&lt;p>第一个表示默认搜索域，第二个表示主机名称服务器(nameserver)的 IP 地址。&lt;/p>
&lt;p>名称服务器行告诉解析器哪个名称服务器可使用。 只要你的 BIND 服务正在运行，你就可以使用自己的 DNS 服务器。&lt;/p>
&lt;h2 id="bind-的基础安全相关配置">BIND 的基础安全相关配置&lt;/h2>
&lt;p>acl：把一个或多个地址归位一个集合，并通过一个统一的名册很难过调用，这些配置放在 named.conf 配置文件中&lt;/p>
&lt;ul>
&lt;li>acl ACL-NAME {&lt;/li>
&lt;li>IP；&lt;/li>
&lt;li>IP;&lt;/li>
&lt;li>net/perlen;&lt;/li>
&lt;li>};&lt;/li>
&lt;/ul>
&lt;p>bind 有 4 个内置的 acl&lt;/p>
&lt;ol>
&lt;li>none:没有一个主机&lt;/li>
&lt;li>any：任意主机&lt;/li>
&lt;li>local：本机&lt;/li>
&lt;li>localnet：本机的 IP 同掩码运算后得到的网络地址&lt;/li>
&lt;/ol>
&lt;p>注意：只能先定义后使用，因此，一般定义在配置文件中 options 的前面&lt;/p>
&lt;p>访问控制的指令&lt;/p>
&lt;p>allow-query {} 允许查询的主机，白名单&lt;/p>
&lt;p>allow-transfer {} 允许区域传送的主机，白名单&lt;/p>
&lt;p>allow-recursion {} 允许递归的主机，白名单&lt;/p>
&lt;p>allow-update {} 允许更新区域数据库中的内容&lt;/p>
&lt;p>BIND VIEW：用于同一个域名解析成多个不同区域的 IP&lt;/p></description></item><item><title>Docs: Charles</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/4.%E6%95%B0%E6%8D%AE%E9%80%9A%E4%BF%A1/%E6%95%B0%E6%8D%AE%E5%8C%85%E5%88%86%E6%9E%90/charles/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/4.%E6%95%B0%E6%8D%AE%E9%80%9A%E4%BF%A1/%E6%95%B0%E6%8D%AE%E5%8C%85%E5%88%86%E6%9E%90/charles/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>官网：&lt;a href="https://www.charlesproxy.com/">https://www.charlesproxy.com/&lt;/a>&lt;/li>
&lt;li>小米手机安装 Charles 证书：&lt;a href="https://blog.csdn.net/yang450712123/article/details/112908643">https://blog.csdn.net/yang450712123/article/details/112908643&lt;/a>
&lt;ul>
&lt;li>安卓用不了 2022.9.19&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>ISO 安装 Charles 证书：&lt;a href="https://www.jianshu.com/p/08f602eabb54">https://www.jianshu.com/p/08f602eabb54&lt;/a>
&lt;ul>
&lt;li>苹果的能用 2022.9.19&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;a href="https://www.charles.ren/">https://www.charles.ren/&lt;/a> 生成注册码&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/arzv8v/1671955685091-ae697c1c-96a5-4d8c-8b3c-e47da76fc75e.png" alt="image.png">
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/arzv8v/1671955755610-395fe14a-f08d-42a7-877c-7296c96e473f.png" alt="image.png">&lt;/p>
&lt;p>在手机、pad 上配置 WLAN 代理，访问 &lt;code>chls.pro/ssl&lt;/code> 下载证书。
打开手机设置，搜索：加密与凭据 =&amp;gt; 安装证书 =&amp;gt; 证书&lt;/p>
&lt;h1 id="安卓安装-charles-证书无效">安卓安装 Charles 证书无效&lt;/h1>
&lt;p>证书安装成功，但是抓到的包都是 unknow，可能的原因：&lt;/p>
&lt;ul>
&lt;li>Android7.0 之后默认不信任用户添加到系统的 CA 证书&lt;/li>
&lt;/ul>
&lt;h1 id="微信小程序抓包">微信小程序抓包&lt;/h1>
&lt;p>到底怎么抓呢？~&lt;/p>
&lt;p>&lt;a href="https://www.zhihu.com/question/350183786/answer/2487803703">知乎上的一篇文章&lt;/a>中说删除 PC 小程序缓存在 2022 年 9 月 5 号之后也不管用了
给微信降级后即可在 PC 上抓包：&lt;a href="https://blog.csdn.net/weixin_46552558/article/details/124037807">https://blog.csdn.net/weixin_46552558/article/details/124037807&lt;/a>&lt;/p>
&lt;p>小程序内嵌的 h5 调用如何抓到？&lt;/p></description></item><item><title>Docs: CIDR</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/4.%E6%95%B0%E6%8D%AE%E9%80%9A%E4%BF%A1/%E6%95%B0%E6%8D%AE%E9%80%9A%E4%BF%A1/cidr/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/4.%E6%95%B0%E6%8D%AE%E9%80%9A%E4%BF%A1/%E6%95%B0%E6%8D%AE%E9%80%9A%E4%BF%A1/cidr/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Classless_Inter-Domain_Routing">Wiki-CIDR&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>&lt;strong>Classless Inter-Domain Routing(无类别域间路由，简称 CIDR)&lt;/strong> 是一个用于给用户分配&lt;a href="https://zh.wikipedia.org/wiki/IP%E5%9C%B0%E5%9D%80">IP 地址&lt;/a>以及在&lt;a href="https://zh.wikipedia.org/wiki/%E4%BA%92%E8%81%94%E7%BD%91">互联网&lt;/a>上有效地路由 IP&lt;a href="https://zh.wikipedia.org/wiki/%E6%95%B0%E6%8D%AE%E5%8C%85">数据包&lt;/a>的对 IP 地址进行归类的方法。&lt;/p>
&lt;p>在&lt;a href="https://zh.wikipedia.org/wiki/%E5%9F%9F%E5%90%8D%E7%B3%BB%E7%BB%9F">域名系统&lt;/a>出现之后的第一个十年里，基于&lt;a href="https://zh.wikipedia.org/wiki/%E5%88%86%E7%B1%BB%E7%BD%91%E7%BB%9C">分类网络&lt;/a>进行地址分配和路由 IP 数据包的设计就已明显显得&lt;a href="https://zh.wikipedia.org/wiki/%E5%8F%AF%E6%89%A9%E6%94%BE%E6%80%A7">可扩充性&lt;/a>不足（参见 RFC 1517）。为了解决这个问题，&lt;a href="https://zh.wikipedia.org/wiki/%E4%BA%92%E8%81%94%E7%BD%91%E5%B7%A5%E7%A8%8B%E5%B7%A5%E4%BD%9C%E5%B0%8F%E7%BB%84">互联网工程工作小组&lt;/a>在 1993 年发布了一新系列的标准 RFC 1518 和 RFC 1519 以定义新的分配 IP 地址块和路由&lt;a href="https://zh.wikipedia.org/wiki/IPv4">IPv4&lt;/a>数据包的方法。&lt;a href="https://zh.wikipedia.org/wiki/%E6%97%A0%E7%B1%BB%E5%88%AB%E5%9F%9F%E9%97%B4%E8%B7%AF%E7%94%B1#cite_note-RFC_1518-1">[1]&lt;/a>&lt;a href="https://zh.wikipedia.org/wiki/%E6%97%A0%E7%B1%BB%E5%88%AB%E5%9F%9F%E9%97%B4%E8%B7%AF%E7%94%B1#cite_note-RFC_1519-2">[2]&lt;/a>&lt;/p>
&lt;p>一个 IP 地址包含两部分：标识网络的&lt;strong>前缀&lt;/strong>和紧接着的在这个网络内的&lt;strong>主机地址&lt;/strong>。在之前的&lt;a href="https://zh.wikipedia.org/wiki/%E5%88%86%E7%B1%BB%E7%BD%91%E7%BB%9C">分类网络&lt;/a>中，IP 地址的分配把 IP 地址的 32 位按每 8 位为一段分开。这使得前缀必须为 8，16 或者 24 位。因此，可分配的最小的地址块有 256（24 位前缀，8 位主机地址，28=256）个地址，而这对大多数企业来说太少了。大一点的地址块包含 65536（16 位前缀，16 位主机，216=65536）个地址，而这对大公司来说都太多了。这导致不能充分使用 IP 地址和在路由上的不便，因为大量的需要单独路由的小型网络（C 类网络）因在地域上分得很开而很难进行&lt;a href="https://zh.wikipedia.org/w/index.php?title=%E8%81%9A%E5%90%88%E8%B7%AF%E7%94%B1&amp;amp;action=edit&amp;amp;redlink=1">聚合路由&lt;/a>，于是给路由设备增加了很多负担。&lt;/p>
&lt;p>无类别域间路由是基于 **Variable-length Subnet Masking(可变长子网掩码，简称 VLSM) **来进行任意长度的前缀的分配。在 RFC 950（1985）中有关于可变长子网掩码的说明。CIDR 包括：&lt;/p>
&lt;ul>
&lt;li>指定任意长度的前缀的可变长子网掩码技术。遵从 CIDR 规则的地址有一个后缀说明前缀的位数，例如：192.168.0.0/16。这使得对日益缺乏的 IPv4 地址的使用更加有效。&lt;/li>
&lt;li>将多个连续的前缀聚合成&lt;a href="https://zh.wikipedia.org/w/index.php?title=%E8%B6%85%E7%BD%91&amp;amp;action=edit&amp;amp;redlink=1">&lt;strong>超网&lt;/strong>&lt;/a>，以及，在互联网中，只要有可能，就显示为一个聚合的网络，因此在总体上可以减少路由表的表项数目。聚合使得互联网的路由表不用分为多级，并通过 VLSM 逆转“划分子网”的过程。&lt;/li>
&lt;li>根据机构的实际需要和短期预期需要而不是分类网络中所限定的过大或过小的地址块来管理 IP 地址的分配的过程。&lt;/li>
&lt;/ul>
&lt;p>因为在&lt;a href="https://zh.wikipedia.org/wiki/IPv6">IPv6&lt;/a>中也使用了 IPv4 的用后缀指示前缀长度的 CIDR，所以 IPv4 中的_分类_在 IPv6 中已不再使用。&lt;/p></description></item><item><title>Docs: CORS跨域(一)：深入理解跨域请求概念及其根因</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/4.%E6%95%B0%E6%8D%AE%E9%80%9A%E4%BF%A1/%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/7.http/http-%E7%AE%A1%E7%90%86/cors%E8%B7%A8%E5%9F%9F%E4%B8%80%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%B7%A8%E5%9F%9F%E8%AF%B7%E6%B1%82%E6%A6%82%E5%BF%B5%E5%8F%8A%E5%85%B6%E6%A0%B9%E5%9B%A0/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/4.%E6%95%B0%E6%8D%AE%E9%80%9A%E4%BF%A1/%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/7.http/http-%E7%AE%A1%E7%90%86/cors%E8%B7%A8%E5%9F%9F%E4%B8%80%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%B7%A8%E5%9F%9F%E8%AF%B7%E6%B1%82%E6%A6%82%E5%BF%B5%E5%8F%8A%E5%85%B6%E6%A0%B9%E5%9B%A0/</guid><description>
&lt;p>&lt;strong>原文链接：&lt;/strong>&lt;a href="https://mp.weixin.qq.com/s/dynx7wrSINYFKZgGPcD3zQ">https://mp.weixin.qq.com/s/dynx7wrSINYFKZgGPcD3zQ&lt;/a>&lt;/p>
&lt;blockquote>
&lt;p>&lt;strong>❝Talk is cheap. Show me the money.&lt;/strong>&amp;gt; ❞&lt;/p>
&lt;/blockquote>
&lt;h1 id="前言">前言&lt;/h1>
&lt;p>你好，我是&lt;strong>YourBatman&lt;/strong>。
做 Web 开发的小伙伴对“跨域”定并不陌生，像狗皮膏药一样粘着几乎每位同学，对它可谓既爱又恨。跨域请求之于创业、小型公司来讲是个头疼的问题，因为这类企业还未沉淀出一套行之有效的、统一的解决方案。
让人担忧的是，据我了解不少程序员同学（不乏有高级开发）碰到跨域问题大都一头雾水：&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/glml9g/1624260182917-3c20dcea-66db-4950-bd08-2ca996afbd43.webp" alt="">然后很自然的 用谷歌去百度一下搜索答案，但相关文章可能参差不齐、鱼龙混杂。短则半天长则一天（包含改代码、部署等流程）此问题才得以解决，一个“小小跨域”问题成功偷走你的宝贵时间。
既然跨域是个如此常见（特别是当下前后端分离的开发模式），因此深入理解 CORS 变得就异常的重要了（反倒前端工程师不用太了解），因此早在 2019 年我刚开始写博客那会就有过较为详细的系列文章：&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/glml9g/1624260182890-838bfbb6-192c-4666-8af4-a89e80a8aad6.png" alt="">现在把它搬到公众号形成技术专栏，并且加点料，让它更深、更全面、更系统的帮助到你，希望可以助你从此不再怕 Cors 跨域资源共享问题。&lt;/p>
&lt;h2 id="本文提纲">本文提纲&lt;/h2>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/glml9g/1624260182696-51d2c077-47b0-4137-b399-a8bc3183bb21.png" alt="">&lt;/p>
&lt;h2 id="版本约定">版本约定&lt;/h2>
&lt;ul>
&lt;li>JDK：8&lt;/li>
&lt;li>Servlet：4.x&lt;/li>
&lt;/ul>
&lt;h1 id="正文">正文&lt;/h1>
&lt;p>文章遵循一贯的风格，本文将采用概念 + 代码示例的方式，层层递进的进行展开叙述。那么上菜，先来个示例预览，模拟一下&lt;strong>跨域请求&lt;/strong>，后面的一些的概念示例将以此作为抓手。&lt;/p>
&lt;h2 id="模拟跨域请求">模拟跨域请求&lt;/h2>
&lt;p>要模拟跨域请求的根本是需要&lt;strong>两个源&lt;/strong>：让请求的来源和目标源不一样。这里我就使用 IDEA 作为静态 Web 服务器（63342），Tomcat 作为后端动态 Servlet 服务器（8080）。&lt;/p>
&lt;blockquote>
&lt;p>&lt;strong>❝&lt;/strong>&amp;gt; 说明：服务器都在本机，端口不一样即可
❞&lt;/p>
&lt;/blockquote>
&lt;h3 id="前端代码">前端代码&lt;/h3>
&lt;p>index.html&lt;/p>
&lt;pre>&lt;code>&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html lang=&amp;quot;en&amp;quot;&amp;gt;
&amp;lt;head&amp;gt;
&amp;lt;meta charset=&amp;quot;UTF-8&amp;quot;&amp;gt;
&amp;lt;title&amp;gt;CORS跨域请求&amp;lt;/title&amp;gt;
&amp;lt;!--导入Jquery--&amp;gt;
&amp;lt;script src=&amp;quot;https://cdn.bootcdn.net/ajax/libs/jquery/3.6.0/jquery.js&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
&amp;lt;button id=&amp;quot;btn&amp;quot;&amp;gt;跨域从服务端获取内容&amp;lt;/button&amp;gt;
&amp;lt;div id=&amp;quot;content&amp;quot;&amp;gt;&amp;lt;/div&amp;gt;
&amp;lt;script&amp;gt;
$(&amp;quot;#btn&amp;quot;).click(function () {
// 跨域请求
$.get(&amp;quot;http://localhost:8080/cors&amp;quot;, function (result) {
$(&amp;quot;#content&amp;quot;).append(result).append(&amp;quot;&amp;lt;br/&amp;gt;&amp;quot;);
});
// 同域请求
$.get(&amp;quot;http://localhost:63342&amp;quot;);
$.post(&amp;quot;http://localhost:63342&amp;quot;);
});
&amp;lt;/script&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/code>&lt;/pre>
&lt;p>使用 IDEA 作为静态 web 服务器，浏览器输入地址即可访问（注：端口号为 63342）：&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/glml9g/1624260183029-7a7f9241-b8f1-43b1-830a-55e244ea8427.png" alt="">&lt;/p>
&lt;h3 id="后端代码">后端代码&lt;/h3>
&lt;p>后端写个 Servlet 来接收 cors 请求&lt;/p>
&lt;pre>&lt;code>/**
* 在此处添加备注信息
*
* @author YourBatman. &amp;lt;a href=mailto:yourbatman@aliyun.com&amp;gt;Send email to me&amp;lt;/a&amp;gt;
* @site https://yourbatman.cn
* @date 2021/6/9 10:36
* @since 0.0.1
*/
@Slf4j
@WebServlet(urlPatterns = &amp;quot;/cors&amp;quot;)
public class CorsServlet extends HttpServlet {
@Override
protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
String requestURI = req.getRequestURI();
String method = req.getMethod();
String originHeader = req.getHeader(&amp;quot;Origin&amp;quot;);
log.info(&amp;quot;收到请求：{}，方法：{}， Origin头：{}&amp;quot;, requestURI, method, originHeader);
resp.getWriter().write(&amp;quot;hello cors...&amp;quot;);
}
}
&lt;/code>&lt;/pre>
&lt;p>启动后端服务器，点击页面上的&lt;strong>按钮&lt;/strong>，结果如下：&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/glml9g/1624260183029-6d0cd299-4e43-4c40-b451-8a036ce30019.png" alt="">服务端控制台输出：&lt;/p>
&lt;pre>&lt;code>... INFO c.y.cors.servlet.CorsServlet - 收到请求：/cors，方法：GET， Origin头：http://localhost:63342
&lt;/code>&lt;/pre>
&lt;blockquote>
&lt;p>&lt;strong>❝&lt;/strong>&amp;gt; 服务端输出日志，说明即使前端的 Http Status 是 error，但服务端还是收到&lt;strong>并处理了&lt;/strong>这个请求的
❞
下面以此代码示例为基础，普及一下和 Cors 跨域资源共享相关的概念。&lt;/p>
&lt;/blockquote>
&lt;h2 id="hostrefererorigin-的区别">Host、Referer、Origin 的区别&lt;/h2>
&lt;p>这哥三看起来很是相似，下面对概念作出区分。&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/glml9g/1624260182992-b5ba405f-82dd-4071-a854-b6d62a458711.png" alt="">&lt;/p>
&lt;ul>
&lt;li>&lt;strong>Host&lt;/strong>：去哪里。&lt;strong>域名+端口&lt;/strong>。值为客户端将要访问的远程主机，浏览器在发送 Http 请求时会带有此 Header&lt;/li>
&lt;li>&lt;strong>Referer&lt;/strong>：来自哪里。&lt;strong>协议+域名+端口+路径+参数&lt;/strong>。当前请求的&lt;strong>来源页面&lt;/strong>的地址，服务端一般使用 Referer 首部识别访问来源，可能会以此进行统计分析、日志记录以及缓存优化等
&lt;ul>
&lt;li>来源页面协议为 File 或者 Data URI（如页面从本地打开的）&lt;/li>
&lt;li>来源页面是 Https，而目标 URL 是 http&lt;/li>
&lt;li>浏览器地址栏直接输入网址访问，或者通过浏览器的书签直接访问&lt;/li>
&lt;li>使用 JS 的 location.href 跳转&lt;/li>
&lt;li>&amp;hellip;&lt;/li>
&lt;li>常见应用场景：百度的搜索广告就会分析 Referer 来判断打开站点是从百度搜索跳转的，还是直接 URL 输入地址的&lt;/li>
&lt;li>一般情况下浏览器会带有此 Header，但这些 case 不会带有 Referer 这个头&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>Origin&lt;/strong>：来自哪里（跨域）。&lt;strong>协议+域名+端口&lt;/strong>。它用于 Cors 请求和同域 POST 请求&lt;/li>
&lt;/ul>
&lt;p>可以看到 Referer 与 Origin 功能相似，前者一般用于统计和阻止盗链，后者用于 CORS 请求。但是还是有几点不同：&lt;/p>
&lt;ol>
&lt;li>
&lt;p>只有&lt;strong>跨域请求&lt;/strong>，或者&lt;strong>同域时发送 post&lt;/strong>请求，才会携带 Origin 请求头；而 Referer 只要浏览器能获取到都会携带（除了上面说明的几种 case 外）&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/glml9g/1624260183074-01c3b097-a969-4628-8afc-1b048c8cab82.png" alt="">&lt;/p>
&lt;/li>
&lt;li>
&lt;p>若浏览器不能获取到请求源页面地址（如上面的几种 case），Referer 头不会发送，但 Origin 依旧会发送，只是值是 null 而已（注：虽然值为 null，但此请求依旧属于 Cors 请求哦），如下图所示：&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/glml9g/1624260183177-3c056e2d-4e67-4242-995e-a946a5f4692e.png" alt="">&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Origin 的值只包括&lt;strong>协议、域名和端口&lt;/strong>，而 Rerferer 不但包括协议、域名、端口还包括路径，参数，注意不包括 hash 值&lt;/p>
&lt;/li>
&lt;/ol>
&lt;h2 id="浏览器的同源策略">浏览器的同源策略&lt;/h2>
&lt;p>浏览器的职责是展示/渲染 document、css、script 脚本等，但是这些资源（将 document、css、script 统一称为资源）可能来自不同的地方，如本地、远程服务器、甚至黑客的服务器&amp;hellip;&amp;hellip;浏览器作为万维网的入口，是我们接入互联网最重要的软件之一（甚至没有之一），因此它的安全性显得尤为重要，这就出现了浏览器的同源策略。
&lt;strong>同源策略&lt;/strong>是浏览器一个重要的安全策略，它用于限制一个 origin 源的 document 或者它加载的脚本如何能与另一个 origin 源的资源进行交互。它能帮助阻隔恶意文档，&lt;strong>减少&lt;/strong>（并不是杜绝）可能被攻击的媒介。&lt;/p>
&lt;blockquote>
&lt;p>&lt;strong>❝&lt;/strong>&amp;gt; 方便和安全往往是相悖的：安全性增高了，方便性就会有所降低
❞
那么问题来了，什么才算同源？&lt;/p>
&lt;/blockquote>
&lt;h3 id="同源的定义">同源的定义&lt;/h3>
&lt;p>URL 被称作：统一资源定位符，同源是针对 URL 而言的。一个完整的 URL 各部分如下图所示：&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/glml9g/1624260182773-6d283640-a36c-47f5-891b-35544f3429f1.png" alt="">&lt;/p>
&lt;blockquote>
&lt;p>&lt;strong>❝&lt;/strong>&amp;gt; Tips：域名和 host 是等同的概念，域名+端口号 = host+端口号（大部分情况下你看到域名并没有端口号，那是采用了默认端口号 80 而已）
❞
&lt;strong>同源：只和上图的前两部分（protocol + domain）有关，规则为：全部相同则为同源&lt;/strong>。这个定义不难理解，但有几点需要再强调一下：&lt;/p>
&lt;/blockquote>
&lt;ul>
&lt;li>两部分必须&lt;strong>完全一样&lt;/strong>才算同源&lt;/li>
&lt;li>这里的 domain 包含 port 端口号，所以总共是两部分而非三部分
&lt;ul>
&lt;li>当然也有说三部分的（协议+host+port），理解其含义就成&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>下面通过举例来彻底了解下。譬如，我的源 URL 为：&lt;code>[http://www.baidu.com/api/user](http://www.baidu.com/api/user)&lt;/code>，下面表格描述了不同 URL 的各类情况：&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:left">URL&lt;/th>
&lt;th style="text-align:left">是否同源&lt;/th>
&lt;th style="text-align:left">原因说明&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:left">&lt;code>[http://www.baidu.com/account](http://www.baidu.com/account)&lt;/code>&lt;/td>
&lt;td style="text-align:left">是&lt;/td>
&lt;td style="text-align:left">前两部分相同，path 路径不一样而已&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:left">&lt;code>[http://www.baidu.com/account?name=a](http://www.baidu.com/account?name=a)&lt;/code>&lt;/td>
&lt;td style="text-align:left">是&lt;/td>
&lt;td style="text-align:left">前两部分相同，path 路径、参数不同而已&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:left">&lt;code>[https://www.baidu.com/api/user](https://www.baidu.com/api/user)&lt;/code>&lt;/td>
&lt;td style="text-align:left">否&lt;/td>
&lt;td style="text-align:left">协议不同&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:left">&lt;code>[http://www.baidu.com:8080/api/user](http://www.baidu.com:8080/api/user)&lt;/code>&lt;/td>
&lt;td style="text-align:left">否&lt;/td>
&lt;td style="text-align:left">端口不同(domain 不同)&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:left">&lt;code>[http://map.baidu.com/api/user](http://map.baidu.com/api/user)&lt;/code>&lt;/td>
&lt;td style="text-align:left">否&lt;/td>
&lt;td style="text-align:left">host 不同(domain 不同)&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="不同源的网络访问">不同源的网络访问&lt;/h3>
&lt;p>浏览器同源策略的存在，限制了不同源之间的交互，实为不便。但是浏览器也开了一些“绿灯”，让其不受同源策略的约束。此种情况一般可分为如下三类：&lt;/p>
&lt;ol>
&lt;li>跨域写操作（Cross-origin writes）：一般是被允许的。如链接（如 a 标签）、重定向以及表单提交（如 form 表单的提交）&lt;/li>
&lt;li>跨域资源嵌入（Cross-origin embedding）：一般是允许的。比如下面这些例子：
&lt;ol>
&lt;li>&lt;code>&amp;lt;script src=&amp;quot;...&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;&lt;/code>标签嵌入 js 脚本&lt;/li>
&lt;li>&lt;code>&amp;lt;link rel=&amp;quot;stylesheet&amp;quot; href=&amp;quot;...&amp;quot;&amp;gt;&lt;/code>标签嵌入 CSS&lt;/li>
&lt;li>&lt;code>&amp;lt;img&amp;gt;&lt;/code>展示的图片&lt;/li>
&lt;li>&lt;code>&amp;lt;video&amp;gt;&lt;/code>和&lt;code>&amp;lt;audio&amp;gt;&lt;/code>媒体资源&lt;/li>
&lt;li>&lt;code>&amp;lt;object&amp;gt;、 &amp;lt;embed&amp;gt; 、&amp;lt;applet&amp;gt;&lt;/code>嵌入的插件&lt;/li>
&lt;li>CSS 中使用&lt;code>@font-face&lt;/code>引入字体&lt;/li>
&lt;li>通过&lt;code>&amp;lt;iframe&amp;gt;&lt;/code>载入资源&lt;/li>
&lt;/ol>
&lt;/li>
&lt;li>跨域读操作（Cross-origin reads）：一般是&lt;strong>不被允许&lt;/strong>的。比如我们的 http 接口请求等都属于此范畴，也是本专栏关注的焦点&lt;/li>
&lt;/ol>
&lt;p>简单总结成一句话：&lt;strong>浏览器自己&lt;/strong>是可以发起跨域请求的（比如 a 标签、img 标签、form 表单等），但是 Javascript 是不能去跨域获取资源（如 ajax）。&lt;/p>
&lt;h3 id="如何允许不同源的网络访问">如何允许不同源的网络访问&lt;/h3>
&lt;p>上面说到的第三种情况：跨域读操作一般是不允许跨域访问的，而这种情况是我们开发过程中最关心、最常见的 case，因此必须解决。&lt;/p>
&lt;blockquote>
&lt;p>&lt;strong>❝&lt;/strong>&amp;gt; Tips：这里的读指的是广义上的读，指的是从服务器获取资源（有 response）的都叫读操作，而和具体是什么 Http Method 无关。换句话讲，所有的 Http API 接口请求都在这里都指的是读操作
❞
可以使用 CORS 来允许跨源访问。&lt;strong>CORS 是 HTTP 的一部分&lt;/strong>，它允许服务端来指定哪些主机可以从这个服务端加载资源。&lt;/p>
&lt;/blockquote>
&lt;h2 id="什么是-cors-跨域">什么是 Cors 跨域&lt;/h2>
&lt;p>Cors(Cross-origin resource sharing)：跨域资源共享，它是&lt;strong>浏览器&lt;/strong>的一个技术&lt;strong>规范&lt;/strong>，由 W3C 规定，规范的 wiki 地址在此：&lt;a href="https://www.w3.org/wiki/CORS_Enabled#What_is_CORS_about.3F">https://www.w3.org/wiki/CORS_Enabled#What_is_CORS_about.3F&lt;/a>&lt;/p>
&lt;blockquote>
&lt;p>&lt;strong>❝&lt;/strong>&amp;gt; 话外音：它是浏览器的一种（自我保护）行为，并且已形成规范。也就是说：backend 请求 backend 是不存在此现象的喽
❞
若想实现 Cors 机制的跨域请求，是需要浏览器和服务器同时支持的。关于浏览器对 CORS 的支持情况：现在都 2021 年了，so 可以认为 100%的浏览器都是支持的，再加上 CORS 的整个过程都由浏览器自动完成，&lt;strong>前端无需做任何设置&lt;/strong>，所以前端工程师的 ajax 原来怎么用现在还是怎么用，它对前段开发人员是完全透明的。&lt;/p>
&lt;/blockquote>
&lt;h3 id="为何需要-cors-跨域访问">为何需要 Cors 跨域访问？&lt;/h3>
&lt;p>浏览器费尽心思的搞个同源策略来保护我们的安全，但为何又需要跨域来打破这种安全策略呢？其实啊，这一切都和互联网的快速发展有关~
随着 Web 开放的程度越来越高，页面的内容也是越来越丰富。因此页面上出现的元素也就越来越多：图片、视频、各种文字内容等。为了分而治之，一个页面的内容可能来自不同地方，也就是不同的 domain 域，因此通过 API 跨域访问成了&lt;strong>必然&lt;/strong>。
浏览器作为进入 Internet 最大的入口，很长时间它是个大互联公司的必争之地，因此市面上并存的浏览器种类繁多且鱼龙混扎：IE 7、8、9、10，Chrome、Safari、火狐，每个浏览器对跨域的实现可能都不一样。因此对开发者而言亟待需要一个规范的、统一方案，它就是&lt;code>Cors&lt;/code>。
&lt;strong>CORS（Cross-Origin Resource Sharing）由 W3C 组织于 2009-03-17 编写工作草案，直到 2014-01-16 才正式毕业成为行业规范，所有浏览器得以遵守&lt;/strong>。至此，程序员同学们在解决跨域问题上，只需按照 Cors 规范实施即可。&lt;/p>
&lt;h3 id="cors-的工作原理">Cors 的工作原理&lt;/h3>
&lt;p>Web 资源涉及到两个角色：浏览器（消费者）和服务器（提供者），面向这两个角色来了解 Cors 的原理非常简单，如下图所示：&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/glml9g/1624260183135-6470a44e-03d9-49d7-af38-910b998f158c.png" alt="">&lt;/p>
&lt;ol>
&lt;li>若浏览器发送的是个跨域请求，http 请求中就会携带一个名为&lt;strong>Origin&lt;/strong>的头表明自己的“位置”，如&lt;code>Origin: http://localhost:5432&lt;/code>&lt;/li>
&lt;li>服务端接到请求后，就可以根据传过来的 Origin 头做逻辑，决定是否要将资源共享给这个源喽。而这个决定通过响应头&lt;strong>Access-Control-Allow-Origin&lt;/strong>来承载，它的 value 值可以是任意值，有如下情况：
&lt;ol>
&lt;li>值为&lt;code>*&lt;/code>，通配符，允许所有的 Origin 共享此资源&lt;/li>
&lt;li>值为 http://localhost:5432（也就是和 Origin 相同），共享给此 Origin&lt;/li>
&lt;li>值为非 http://localhost:5432（也就是和 Origin 不相同），不共享给此 Origin&lt;/li>
&lt;li>无此头：不共享给此 origin&lt;/li>
&lt;li>有此头：值有如下可能情况&lt;/li>
&lt;/ol>
&lt;/li>
&lt;li>浏览器接收到 Response 响应后，会去提取 Access-Control-Allow-Origin 这个头。然后根据上述规则来决定要接收此响应内容还是拒绝&lt;/li>
&lt;/ol>
&lt;blockquote>
&lt;p>&lt;strong>❝&lt;/strong>&amp;gt; Tips：Access-Control-Allow-Origin 响应头只能有 1 个，且 value 值就是个字符串。另外，value 值即使写为&lt;code>[http://aa.com,http://bb.com](http://aa.com,http://bb.com)&lt;/code>这种也属于一个而非两个值
❞&lt;/p>
&lt;/blockquote>
&lt;h3 id="cors-细粒度控制授权响应头">Cors 细粒度控制：授权响应头&lt;/h3>
&lt;p>在 Cors 规范中，除了可以通过&lt;strong>Access-Control-Allow-Origin&lt;/strong>响应头来对主体资源（URL 级别）进行授权外，还提供了针对于具体响应头更细粒度的控制，这个响应头就是：&lt;strong>Access-Control-Expose-Headers&lt;/strong>。换句话讲，该头用于规定哪些响应头（们）可以暴露给前端，默认情况下这 6 个响应头无需特别的显示指定就支持：&lt;/p>
&lt;ul>
&lt;li>Cache-Control&lt;/li>
&lt;li>Content-Language&lt;/li>
&lt;li>Content-Type&lt;/li>
&lt;li>Expires&lt;/li>
&lt;li>Last-Modified&lt;/li>
&lt;li>Pragma&lt;/li>
&lt;/ul>
&lt;p>若不在此值里面的头将&lt;strong>不会返回给前端&lt;/strong>（其实返回了，只是浏览器让其对前端不可见了而已，对 JavaScript 也不可见哦）。
&lt;strong>但是，但是，但是&lt;/strong>，这种细粒度控制 header 的机制对简单请求是无效的，只针对于非简单请求（也叫复杂请求）。由此可见，将哪些类型的跨域资源请求划分为简单请求的范畴就显得特备重要了。&lt;/p>
&lt;h3 id="何为简单请求">何为简单请求&lt;/h3>
&lt;p>Cors 规范定义简单请求的原则是：请求不是以更新（添加、修改和删除）资源为目的，服务端对请求的处理不会导致自身维护资源的改变。对于简单跨域资源请求来说，浏览器将两个步骤（取得授权和获取资源）合二为一，由于不涉及到资源的改变，所以不会带来任何副作用。
对于一个请求，必须&lt;strong>同时符合&lt;/strong>如下要求才被划为简单请求：&lt;/p>
&lt;ol>
&lt;li>Http Method 只能为其一：
&lt;ol>
&lt;li>GET&lt;/li>
&lt;li>POST&lt;/li>
&lt;li>HEAD&lt;/li>
&lt;/ol>
&lt;/li>
&lt;li>请求头只能在如下范围：
&lt;ol>
&lt;li>application/x-www-form-urlencoded&lt;/li>
&lt;li>multipart/form-data&lt;/li>
&lt;li>text/plain&lt;/li>
&lt;li>Accept&lt;/li>
&lt;li>Accept-Language&lt;/li>
&lt;li>Content-Language&lt;/li>
&lt;li>&lt;strong>Content-Type&lt;/strong>，其中它的值必须如下其一：&lt;/li>
&lt;/ol>
&lt;/li>
&lt;/ol>
&lt;p>除此之外的请求都为非简单请求（也可称为复杂请求）。非简单请求可能对服务端资源改变，因此 Cors 规定浏览器在发出此类请求&lt;strong>之前&lt;/strong>必须有一个“预检（Preflight）”机制，这也就是我们熟悉的&lt;code>OPTIONS&lt;/code>请求。&lt;/p>
&lt;h3 id="什么是-preflight-预检机制">什么是 Preflight 预检机制&lt;/h3>
&lt;p>顾名思义，它表示在浏览器发出&lt;strong>真正&lt;/strong>请求&lt;strong>之前&lt;/strong>，先发送一个预检请求，这个在 Http 里就是 OPTIONS 请求方式。这个请求很特殊，它不包含主体（无请求参数、请求体等），主要就是将一些凭证、授权相关的辅助信息放在请求头里交给服务器去做决策。因此它除了携带 Origin 请求头外，还会额外携带如下两个&lt;strong>请求头&lt;/strong>：&lt;/p>
&lt;ul>
&lt;li>&lt;strong>Access-Control-Request-Method&lt;/strong>：真正请求的方法&lt;/li>
&lt;li>&lt;strong>Access-Control-Request-Headers&lt;/strong>：真正请求的&lt;strong>自定义&lt;/strong>请求头（若没有自定义的就是空呗）&lt;/li>
&lt;/ul>
&lt;p>服务端在接收到此类请求后，就可以根据其值做逻辑决策啦。如果允许预检请求通过，返回个 200 即可，否则返回 400 或者 403 呗。
如果预检成功，在响应里应该包含上文提到的响应头&lt;strong>Access-Control-Allow-Origin&lt;/strong>和&lt;strong>Access-Control-Expose-Headers&lt;/strong>，除此之外，服务端还可以做更精细化的控制，这些精细化控制的响应头为：&lt;/p>
&lt;ul>
&lt;li>&lt;strong>Access-Control-Allow-Methods&lt;/strong>：允许实际请求的 Http 方法（们）&lt;/li>
&lt;li>&lt;strong>Access-Control-Allow-Headers&lt;/strong>：允许实际请求的请求头（们）&lt;/li>
&lt;li>&lt;strong>Access-Control-Max-Age&lt;/strong>：允许浏览器缓存此结果多久，单位：&lt;strong>秒&lt;/strong>。有了缓存，以后就不用每次请求都发送预检请求啦&lt;/li>
&lt;/ul>
&lt;blockquote>
&lt;p>&lt;strong>❝&lt;/strong>&amp;gt; 说明：以上响应头并不是必须的。若没有此响应头，代表接受所有
❞
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/glml9g/1624260183047-fe0cff44-2fad-43ff-9b1d-418e6cc8bbd2.webp" alt="">预检请求完成后，有个关键点，便是浏览器拿到预检请求的响应后的处理逻辑，这里描述如下：&lt;/p>
&lt;/blockquote>
&lt;ol>
&lt;li>先通过自己的 Origin 匹配预检响应中的&lt;strong>Access-Control-Allow-Origin&lt;/strong>的值，若不匹配就结束请求，若匹配就继续下一步验证
&lt;ol>
&lt;li>关于 Access-Control-Allow-Origin 的验证逻辑，请参考文上描述&lt;/li>
&lt;/ol>
&lt;/li>
&lt;li>拿到预检响应中的&lt;strong>Access-Control-Allow-Methods&lt;/strong>头。若此头不存在，则进行下一步，若存在则校验预检请求头 Access-Control-Request-Method 的值是否在此列表中，在其内继续下一步，否则失败&lt;/li>
&lt;li>拿到预检响应中的&lt;strong>Access-Control-Request-Headers&lt;/strong>头。同请求头中的&lt;strong>Access-Control-Allow-Headers&lt;/strong>值记性比较，&lt;strong>全部包含在内&lt;/strong>则匹配成功，否则失败&lt;/li>
&lt;/ol>
&lt;p>以上全部匹配成功，就代表预检成功，可以开始发送正式请求了。值得一提的事，Access-Control-Max-Age 控制预检结果的浏览器缓存，若缓存还生效的话，是不用单独再发送 OPTIONS 请求的，匹配成功直接发送目标真实即可。&lt;/p>
&lt;h4 id="access-control-max-age-使用细节">Access-Control-Max-Age 使用细节&lt;/h4>
&lt;p>Access-Control-Max-Age 用于控制浏览器缓存预检请求结果的时间，这里存在一些使用细节你需要注意：&lt;/p>
&lt;ol>
&lt;li>若浏览器禁用了缓存，也就是勾选了&lt;code>Disable cache&lt;/code>，那么此属性无效。也就说每次都还得发送 OPTIONS 请求&lt;/li>
&lt;li>判断此缓存结果的因素有两个：
&lt;ol>
&lt;li>必须是同一 URL（也就是 Origin 相同才会去找对应的缓存）&lt;/li>
&lt;li>header 变化了，也会重新去发 OPTIONS 请求（当然若去掉一些 header 编程简单请求了，就另当别论喽）&lt;/li>
&lt;/ol>
&lt;/li>
&lt;/ol>
&lt;h2 id="跨域请求代码示例">跨域请求代码示例&lt;/h2>
&lt;p>正所谓说再多，也抵不上跑几个 case，毕竟 show me your code 才是最重要。下面就针对跨域情况的简单请求、非简单请求（预检通过、预检不通过）等 case 分别用代码（基于文首代码）说明。&lt;/p>
&lt;h3 id="简单请求">简单请求&lt;/h3>
&lt;p>简单请求正如其名，是最简单的请求方式。&lt;/p>
&lt;pre>&lt;code>// 跨域请求
$.get(&amp;quot;http://localhost:8080/cors&amp;quot;, function (result) {
$(&amp;quot;#content&amp;quot;).append(result).append(&amp;quot;&amp;lt;br/&amp;gt;&amp;quot;);
});
&lt;/code>&lt;/pre>
&lt;p>服务端结果：&lt;/p>
&lt;pre>&lt;code>INFO ...CorsServlet - 收到请求：/cors，方法：GET， Origin头：http://localhost:63342
&lt;/code>&lt;/pre>
&lt;p>浏览器结果：&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/glml9g/1624260183182-8f80baa8-d029-42c4-8bce-a29833a2f28d.png" alt="">若想让请求正常，只需在服务端响应头里“加点料”就成：&lt;/p>
&lt;pre>&lt;code>...
resp.setHeader(&amp;quot;Access-Control-Allow-Origin&amp;quot;,&amp;quot;http://localhost:63342&amp;quot;);
resp.getWriter().write(&amp;quot;hello cors...&amp;quot;);
...
&lt;/code>&lt;/pre>
&lt;p>再次请求，结果成功：&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/glml9g/1624260182990-03d5ab7f-9e0f-42a9-852e-7f1d0f6d6430.png" alt="">
对于简单请求来讲，服务端只需要设置&lt;strong>Access-Control-Allow-Origin&lt;/strong>这个一个头即可，一个即可。&lt;/p>
&lt;h3 id="非简单请求">非简单请求&lt;/h3>
&lt;p>非简单请求的模拟非常简单，随便打破一个简单请求的约束即可。比如我们先在上面 get 请求的基础上自定义个请求头：&lt;/p>
&lt;pre>&lt;code>$.ajax({
type: &amp;quot;get&amp;quot;,
url: &amp;quot;http://localhost:8080/cors&amp;quot;,
headers: {secret:&amp;quot;kkjtjnbgjlfrfgv&amp;quot;,token: &amp;quot;abc123&amp;quot;}
});
&lt;/code>&lt;/pre>
&lt;p>服务端代码：&lt;/p>
&lt;pre>&lt;code>/**
* 在此处添加备注信息
*
* @author YourBatman. &amp;lt;a href=mailto:yourbatman@aliyun.com&amp;gt;Send email to me&amp;lt;/a&amp;gt;
* @site https://yourbatman.cn
* @date 2021/6/9 10:36
* @since 0.0.1
*/
@Slf4j
@WebServlet(urlPatterns = &amp;quot;/cors&amp;quot;)
public class CorsServlet extends HttpServlet {
@Override
protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
String requestURI = req.getRequestURI();
String method = req.getMethod();
String originHeader = req.getHeader(&amp;quot;Origin&amp;quot;);
log.info(&amp;quot;收到请求：{}，方法：{}， Origin头：{}&amp;quot;, requestURI, method, originHeader);
resp.setHeader(&amp;quot;Access-Control-Allow-Origin&amp;quot;,&amp;quot;http://localhost:63342&amp;quot;);
resp.setHeader(&amp;quot;Access-Control-Expose-Headers&amp;quot;,&amp;quot;token,secret&amp;quot;);
resp.setHeader(&amp;quot;Access-Control-Allow-Headers&amp;quot;,&amp;quot;token,secret&amp;quot;); // 一般来讲，让此头的值是上面那个的【子集】（或相同）
resp.getWriter().write(&amp;quot;hello cors...&amp;quot;);
}
}
&lt;/code>&lt;/pre>
&lt;p>点击按钮，浏览器发送请求，结果为：&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/glml9g/1624260183014-9b0617b6-5b7b-4c38-b7e1-c7fe01a03cdd.png" alt="">根本原因为：OPTIONS 的响应头里并未含有任何跨域相关信息，虽然预检通过（注意：这个预检是通过的哟，预检不通过的场景就不用额外演示了吧~），但预检的结果经浏览器判断此跨域实际请求不能发出，所以给拦下来了。
从代码层面问题就出现在&lt;code>resp.setHeader(xxx,xxx)&lt;/code>放在了处理实际方法的 Get 方法上，显然不对嘛，应该放在&lt;code>doOptions()&lt;/code>方法里才行：&lt;/p>
&lt;pre>&lt;code>@Override
protected void doOptions(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
super.doOptions(req, resp);
resp.setHeader(&amp;quot;Access-Control-Allow-Origin&amp;quot;,&amp;quot;http://localhost:63342&amp;quot;);
resp.setHeader(&amp;quot;Access-Control-Expose-Headers&amp;quot;,&amp;quot;token,secret&amp;quot;);
resp.setHeader(&amp;quot;Access-Control-Allow-Headers&amp;quot;,&amp;quot;token,secret&amp;quot;); // 一般来讲，让此头的值是上面那个的【子集】（或相同）
}
&lt;/code>&lt;/pre>
&lt;p>在此运行，一切正常：&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/glml9g/1624260182853-033ea229-1f94-47fe-abf1-be70ab519582.webp" alt="">值得特别注意的是：设置跨域的响应头这块代码，在处理真实请求的 doGet 里也必须得有，否则服务端处理了，浏览器“不认”也是会出跨域错误的。
另外就是，Access-Control-Allow-Headers/Access-Control-Expose-Headers 这两个头里必须包含你的请求的自定义的 Header（标准的 header 不需要包含），否则依旧跨域失败哦~
在实际生产场景中，Http 请求的 Content-type 大都是&lt;code>application/json&lt;/code>并非简单请求的头，所以有个现实情况是：&lt;strong>实际的跨域请求中，几乎 100%的情况下我们发的都是非简单请求&lt;/strong>。&lt;/p>
&lt;h2 id="cros-跨域使用展望">Cros 跨域使用展望&lt;/h2>
&lt;p>如上代码示例，处理简单请求尚且简单，但对于非简单请求来说，我们在 doOptions 和 doGet 都写了一段 setHeader 的代码，是否觉得麻烦呢？
另外，对于&lt;strong>Access-Control-Allow-Origin&lt;/strong>若我需要允许多个源怎么办呢？&lt;/p>
&lt;blockquote>
&lt;p>&lt;strong>❝&lt;/strong>&amp;gt; Tips：Access-Control-Allow-Origin 头只允许一个，且 Access-Control-Allow-Origin:a.com,b.com 依旧算作一个源的，它没有逗号分隔的“特性”。从命名的艺术你也可看出，它并非是 xxx-Origins 而是 xxx-Origin
❞
既然实际场景中几乎 100%都是非简单请求，那么对于控制非简单请求的&lt;strong>Access-Control-Allow-Methods&lt;/strong>、&lt;strong>Access-Control-Allow-Headers&lt;/strong>、&lt;strong>Access-Control-Max-Age&lt;/strong>这些都都改如何赋值？是否有最佳实践？
现在我们大都在 Spring Framework/Spring Boot 场景下开发应用，框架层面是否提供一些优雅的解决方案？
作为一名后端开发工程师（编程语言不限），也许你从未处理过跨域问题，那么到底是谁默默的帮你解决了这一切呢？是否想知其所以然？
如果这些问题也是你在使用过程中的疑问，或者希望了解的知识点，那么请关注专栏吧。&lt;/p>
&lt;/blockquote>
&lt;h1 id="总结">总结&lt;/h1>
&lt;p>本文用很长的篇幅介绍了 Cors 跨域资源共享的相关知识，并且用代码做了示范，希望能助你通关 Cors 这个狗皮膏药一样粘着我们的硬核知识点。本文文字叙述较多，介绍了同源、跨域、Cors 的几乎所有概念，虽然略显难啃，但这些是指导我们实践的说明书。
革命尚未统一，带着 👆🏻 给到的问题，一起开启通过 Cors 跨域之旅吧~&lt;/p>
&lt;h2 id="本文思考题">本文思考题&lt;/h2>
&lt;p>本文已被&lt;code>[https://yourbatman.cn](https://yourbatman.cn)&lt;/code>收录。所属专栏：&lt;strong>点拨-Cors 跨域&lt;/strong>，后台回复“专栏列表”即可查看详情。
&lt;strong>看完了不一定懂，看懂了不一定会&lt;/strong>。来，3 个思考题帮你复盘：&lt;/p>
&lt;ol>
&lt;li>试想一下，如果浏览器没有同源策略，将有多大的风险？&lt;/li>
&lt;li>Cors 共涉及到哪些请求头？哪些响应头？&lt;/li>
&lt;li>你所知道的解决 Cors 跨域问题最佳实践是什么？&lt;/li>
&lt;/ol>
&lt;h2 id="推荐阅读">推荐阅读&lt;/h2>
&lt;ul>
&lt;li>&lt;a href="https://mp.weixin.qq.com/s?__biz=MzI0MTUwOTgyOQ==&amp;amp;mid=2247493900&amp;amp;idx=1&amp;amp;sn=f903380f7d7065192959b07acd1683ae&amp;amp;scene=21#wechat_redirect">10. 原来是这么玩的，@DateTimeFormat 和@NumberFormat&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://mp.weixin.qq.com/s?__biz=MzI0MTUwOTgyOQ==&amp;amp;mid=2247491641&amp;amp;idx=1&amp;amp;sn=794c1fadf5d5144df83079a549d3b15f&amp;amp;scene=21#wechat_redirect">9. 细节见真章，Formatter 注册中心的设计很讨巧&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://mp.weixin.qq.com/s?__biz=MzI0MTUwOTgyOQ==&amp;amp;mid=2247491457&amp;amp;idx=1&amp;amp;sn=dc16a2b7f069df4b0329e66365efd980&amp;amp;scene=21#wechat_redirect">8. 格式化器大一统 &amp;ndash; Spring 的 Formatter 抽象&lt;/a>&lt;/li>
&lt;/ul></description></item><item><title>Docs: DDNS</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/4.%E6%95%B0%E6%8D%AE%E9%80%9A%E4%BF%A1/dns/ddns/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/4.%E6%95%B0%E6%8D%AE%E9%80%9A%E4%BF%A1/dns/ddns/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Dynamic_DNS">Wiki,DDNS&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>**Dynamic Domain Name System(动态域名系统，简称 DDNS) **是一种方法、概念，这个方法用来动态更新 DNS 中名称对应的 IP。通常情况下，域名都是解析到一个固定的 IP，但 DDNS 系统为动态网域提供一个固定的&lt;a href="https://zh.wikipedia.org/wiki/%E5%90%8D%E7%A8%B1%E4%BC%BA%E6%9C%8D%E5%99%A8">名称服务器&lt;/a>（Name server），透过即时更新，使外界用户能够连上动态用户的网址。&lt;/p>
&lt;p>比如家庭宽带，获取到的 IP 地址是实时变化的，要想通过域名访问当家庭宽带内部的服务，则必须使用 DDNS。&lt;/p></description></item><item><title>Docs: DNS</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/4.%E6%95%B0%E6%8D%AE%E9%80%9A%E4%BF%A1/dns/dns/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/4.%E6%95%B0%E6%8D%AE%E9%80%9A%E4%BF%A1/dns/dns/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Domain_Name_System">Wiki,DNS&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Name_server">Wiki,Name Server&lt;/a>&lt;/li>
&lt;li>《DNS 与 BIND》(第 5 版)&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>**Domain Name System(域名系统，简称 DNS) **是一个分层的和去中心化的命名系统，以便人们可以更方便得访问互联网。DNS 主要用来将更容易让人类记忆的 &lt;code>域名&lt;/code> 与 &lt;code>IP地址&lt;/code> 互相映射，以便可以通过域名定位和访问互联网上的服务。自 1985 年以来，域名系统通过提供全球性、分布式的域名服务，已成为 Internet 功能的重要组成部分。&lt;/p>
&lt;p>从另一个方面说，DNS(域名系统) 其实是一个&lt;strong>分布式的数据库&lt;/strong>。这种结构允许对整体数据库的各个部分进行本地控制，并且在各个部分中的数据通过 C/S 模式变得对整个网络都可用。通过复制和缓存等机制，DNS 将会拥有健壮性和充足的性能。&lt;/p>
&lt;blockquote>
&lt;p>注：这段描述不好理解，需要看完后面才能体会。所谓的分布式，其实就是指 DNS 的模式，每个 Name Server 都可以是分布式数据库的一个节点。&lt;/p>
&lt;/blockquote>
&lt;p>当我们访问一个网站时，在浏览器上输入 &lt;code>https://www.baidu.com/&lt;/code> 时，&lt;code>www.baidu.com&lt;/code> 就是域名。而管理 域名与 IP 对应关系的系统，就是域名系统。&lt;/p>
&lt;p>DNS 其实是一个规范、概念，具体想要让 DNS 在世界上应用起来，则至少要保证两个方面&lt;/p>
&lt;ul>
&lt;li>其一是服务端，通过 NameServer 为大家提供解析服务、存储域名与 IP 的对应关系，&lt;/li>
&lt;li>其二是客户端，客户端上的应用程序将会调用符合 DNS 标准的库以便向 NameServer 发起域名查询请求，程序收到解析后的 IP 后将会发起请求。&lt;/li>
&lt;/ul>
&lt;h2 id="背景">背景&lt;/h2>
&lt;p>网络诞生之初并没有 DNS，那时候访问对方只需要 IP 地址就可以了，但是后来接入互联网的主机太多了，IP 没法记，所以研究了 DNS。&lt;/p>
&lt;p>&lt;strong>Internet Assigned Numbers Authority(互联网数字分配机构，简称 IANA)&lt;/strong> 是负责协调一些使 Internet 正常运作的机构。同时，由于 Internet 已经成为一个全球范围的不受集权控制的全球网络，为了使网络在全球范围内协调，存在对互联网一些关键的部分达成技术共识的需要，而这就是 IANA 的任务&lt;/p>
&lt;p>IANA 的所有任务可以大致分为三个类型：
一、域名。IANA 管理 DNS 域名根和.int，.arpa 域名以及 IDN（国际化域名）资源。
二、数字资源。IANA 协调全球 IP 和 AS（自治系统）号并将它们提供给各区域 Internet 注册机构。
三、协议分配。IANA 与各标准化组织一同管理协议编号系统。&lt;/p>
&lt;h2 id="nameserver">NameServer&lt;/h2>
&lt;p>&lt;strong>NameServer(名称服务器)&lt;/strong> 是 DNS 中最重要的概念，有的时候也称为 &lt;strong>DNS Server&lt;/strong>。Name Server 是 DNS 的一个组件。该组件的最重要功能就是将人类记忆的域名解析为 IP 地址。&lt;/p>
&lt;blockquote>
&lt;p>简单得说，想要让全世界都接入 DNS(域名系统)，就需要有一个服务，这个服务就是一个翻译器。比如我要访问谷歌，就会问 NameServer：谷歌在哪。此时这个翻译器(NameServer)就会告诉我谷歌的 IP 地址，这时我再去访问这个 IP 地址即可。&lt;/p>
&lt;/blockquote>
&lt;p>可以实现上述的程序有很多，凡是可以实现 DNS 功能的程序，我们一般成为 &lt;strong>NameServer(名称服务器)：&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>&lt;strong>Bind&lt;/strong> # 最常用 NameServer，Bind 的具体介绍详见 《&lt;a href="https://www.yuque.com/go/doc/33218857">Bind&lt;/a>》章节。&lt;/li>
&lt;li>&lt;strong>DNSmasq&lt;/strong> # 轻量的 NameServer，用于提供 DNS 缓存功能。&lt;/li>
&lt;li>&amp;hellip;&amp;hellip; 等等&lt;/li>
&lt;/ul>
&lt;p>一个 NameServer 通常包含了整个 DNS 数据库中的某些部分的信息，并让这些信息可以被客户端所用(客户端通常称为 &lt;strong>Resolver(解析器)&lt;/strong>)。解析器通常只是一组 Library，这些库产生查询请求，并将请求通过网络发送给名称服务器。&lt;/p>
&lt;ul>
&lt;li>比如 Linux 中 curl、ping 等等命令就会调用 Resolver，毕竟这些命令如何请求一个域名，就需要要知道对应的 IP 才可以。&lt;/li>
&lt;li>解析器一般是被内嵌在系统中，当在系统中运行任何需要域名解析的程序时，都会调用这个解析器。&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>用白话说，Name Server 通常是一个默认监听在 53/UDP 与 53/TCP 上的服务，用来处理客户端发来的域名解析请求(根据自身数据库中 &lt;strong>&lt;a href="#lcTmS">&lt;strong>RR&lt;/strong>&lt;/a>&lt;/strong> 解析域名)，或者向上级 Name Server 发起域名查询请求。比如 8.8.8.8、114.114.114.114 等等，都属于 NameServer。&lt;/strong>&lt;/p>
&lt;p>&lt;strong>NameServer 是实现 DNS 的具体实现&lt;/strong>&lt;/p>
&lt;p>注意：&lt;/p>
&lt;ul>
&lt;li>上述描述的都是自建 Name Server。如果我们在一个域名注册商出购买域名后，都需要指定用来处理自己购买域名的 Name Server，只不过通常情况，域名注册商本身自己就有 Name Server，这样也方便进行身份验证(即域名属于自己)。&lt;/li>
&lt;li>但是也有例外，比如免费的域名注册商 eu.org 就没有自己的 Name Server，在 eu.org 出买的域名必须要指定其他的 Name Server。&lt;/li>
&lt;/ul>
&lt;h3 id="nameserver-类型">NameServer 类型&lt;/h3>
&lt;blockquote>
&lt;p>这部分内容需要理解域名结构后，再回来看。否则无法理解为什么 NameServer 会有这么多分类&lt;/p>
&lt;/blockquote>
&lt;ol>
&lt;li>主 DNS Server：维护其所负责解析的域内解析库服务器，解析库由管理员维护&lt;/li>
&lt;li>辅助 DNS Server：从主 DNS Server 或其他辅助 DNS Server 那里复制(区域传送)一份解析库
&lt;ol>
&lt;li>序列号：解析库的版本号，主服务器的解析库内容发生变化，其序列号发生变化，当序列号发生变化的时候，辅助 DNS Server 则去复制解析库&lt;/li>
&lt;li>区域传送：
&lt;ol>
&lt;li>全量传送：传送整个解析库&lt;/li>
&lt;li>增量传送：传送解析库变化的那部分内容&lt;/li>
&lt;/ol>
&lt;/li>
&lt;li>刷新时间间隔：辅助 DNS Server 从主 DNS Server 请求同步解析库的时间间隔&lt;/li>
&lt;li>重试时间间隔：辅助 DNS Server 从主 DNS Server 请求同步解析库失败时，再次尝试的时间间隔&lt;/li>
&lt;li>过期时长：辅助 DNS Server 始终联系不到主 DNS Server 时，多久之后放弃辅助 DNS Server 职责，变成主服务器&lt;/li>
&lt;/ol>
&lt;/li>
&lt;li>缓存 DNS Server：这些服务器上不存放特定域名的配置文件。当客户端请求缓存服务器来解析域名时，该服务器将首先检查其本地缓存。如果找不到匹配项便会询问主服务器。接着这条响应将被缓存起来。您也可以轻松地将自己的系统用作缓存服务器，如果该域内不存在主 DNS 服务器，那么则直接去找根域的 DNS 服务器进行域名解析。&lt;/li>
&lt;li>转发器 Server：该服务器会转发收到的域名解析请求到别的服务器，这杯被转发到的服务器需要能够为请求做递归处理，否则，转发请求不予进行
&lt;ol>
&lt;li>全部转发：凡是对非本机所有负责解析的区域的请求，统统转发给指定的服务器&lt;/li>
&lt;li>区域转发：仅转发对特定的区域的请求至某服务器&lt;/li>
&lt;/ol>
&lt;/li>
&lt;/ol>
&lt;h1 id="dns-架构与概念">DNS 架构与概念&lt;/h1>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/msw4yv/1617092212523-dcc0c65c-8807-4964-8766-8613f94c8cd0.png" alt="1024px-Domain_name_space.svg.png">
DNS(域名系统) 是一个树型架构，这颗大树被称为 **Domain Namespace(域名称空间)，**树中的每个节点都具有 &lt;strong>Label(标签)&lt;/strong> 和 0 个或多个 &lt;strong>ResourceRecords(资源记录，简称 RR)&lt;/strong>，其中保存与域名相关联的信息。域名本身由 Label(标签) 组成，多个标签通过 &lt;code>.&lt;/code> 符号串联而成，&lt;code>.&lt;/code> 符号右侧的标签就是其左侧标签的父节点名称。&lt;/p>
&lt;blockquote>
&lt;p>这里所描述的树形结构中的节点，实际上就是一个个的 NameSever&lt;/p>
&lt;/blockquote>
&lt;h2 id="domain域-的概念">Domain(域) 的概念&lt;/h2>
&lt;p>根负责管理他下面的一些域，这些域再负责其所在域的管理，依次类推，域就是该 NameServer 可管辖的范围。而被管的域则称为 &lt;strong>SubDomain(子域)&lt;/strong>。在树型结构中，也可以说低级节点就是高级节点的 SubDomain(子域)。&lt;/p>
&lt;p>Domain 还可以用现实中的地理来类比，比如我前文所说的我的名字”四.李.海淀区.北京市.中国.“，根域里包括多个国家域，每个国家域又包括很多城市域，每个城市域包括很多区域，每个区域里有很多姓氏域，姓氏域中，名为李姓氏域中，叫四的就是我(某台设备的名字就是这个区域的一台)&lt;/p>
&lt;p>我们光有 Domain 的概念还不行，在真正使用上，还需要给每个域起一个名称，就叫 &lt;strong>DomainName(域名)&lt;/strong>。所以，DNS 这整套系统，就是围绕着 Domain 来进行的。而&lt;strong>每个 Domain 的名称，就是其 Label 的名称。&lt;/strong>&lt;/p>
&lt;h2 id="zone区-的概念">Zone(区) 的概念&lt;/h2>
&lt;p>DNS 这个树型结构还使用了一个 &lt;strong>Zone(区)&lt;/strong> 的概念来进行分区管理，一个 Zone 可以包含一个域，也可以包含很多域及其子域。Zone 可以包含的内容具体取决于 &lt;strong>Delegation(授权)&lt;/strong>。
详见：&lt;a href="https://www.yuque.com/go/doc/33890339">Zone 与 Domain 详解&lt;/a>&lt;/p>
&lt;h2 id="domainname域名-的结构">DomainName(域名) 的结构&lt;/h2>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/msw4yv/1616161023756-88e23654-7efc-4c25-826f-632042129088.jpeg" alt="">
域名由一个或多个部分组成，每个部分由 &lt;code>.&lt;/code> 符号连接。组成域名的每个部分称为 &lt;strong>Label(标签)&lt;/strong>。这个 Label 就是 NameServer 的 Label。
结构如下：&lt;code>Label-N...Label-3.Label-2.Label-1.&lt;/code>
最右侧的空标签是为 root 保留的，长度为 0。其余每个 Label 最多可以写 63 个文本字符。&lt;/p>
&lt;ol>
&lt;li>**RootDomain(根域名) **# 空标签，管理根以下的所有顶级域名，全世界一共有 13 组根域名 Server，不包括中国
&lt;ol>
&lt;li>实际上，当你访问任何网站时，浏览器会默认在域的末尾添加一个不可见的点，因此域名像 &lt;code>www.baidu.com.&lt;/code> 一样。 最后边的点被称为根域。&lt;/li>
&lt;li>注意，任何 NameServer 在本地数据库没有查到请求的域名的时候，必然会去根 NameServer 请求，不会去顶级或者二级直接发请求，这是规定&lt;/li>
&lt;/ol>
&lt;/li>
&lt;li>&lt;strong>Top-Level Domain(顶级域名)&lt;/strong> #** **Label-1，管理该域名下的所有二级域名。比如 &lt;code>com.&lt;/code>、&lt;code>net.&lt;/code> 等都是顶级域名&lt;/li>
&lt;li>**二级域名 **# Label-2，常用来标识该网站名称，比如 baidu.com、google.com&lt;/li>
&lt;li>**三级域名 **# Label-3，常用来标识域名作用的，比如提供网页服务的用 &lt;a href="https://www.baidu.com">www.baidu.com&lt;/a>、提供邮箱服务的用 mail.baidu.com&lt;/li>
&lt;li>&lt;strong>其他级域名&lt;/strong> # 理论上来说，一共可以划分 127 个等级。&lt;/li>
&lt;/ol>
&lt;p>比如 &lt;code>www.baidu.com&lt;/code> 实际上就是 &lt;code>www.baidu.com.&lt;/code>。baidu.com. 就是二级域名，www.baidu.com. 就是三级域名。&lt;/p>
&lt;blockquote>
&lt;p>这就好比 Linux 的目录树结构一样，只不过 Linux 中，域 称为 目录，子域 称为 子目录。最顶层的称为 根目录，而且分隔符是 &lt;code>/&lt;/code>。只不过 Linux 的结构是从左至右的。
域名就是区域的名字，就好像本人的名字李四一样，我是四.李.南开区.天津市.中国.，域名就是这样的结构。&lt;/p>
&lt;/blockquote>
&lt;p>比如我现在想知道 &lt;code>www.baidu.com&lt;/code> 在哪：&lt;/p>
&lt;ol>
&lt;li>该域名查询的时候，先去问根.，根告诉我这个归 .com 管&lt;/li>
&lt;li>然后去问 .com，.com 告诉我这个域名归 baidu 管&lt;/li>
&lt;li>然后去问 .baidu，.baidu 告诉我，这是他们的 web 服务器，IP 地址是这个，然后我就可以跟 &lt;a href="https://www.baidu.com">www.baidu.com&lt;/a> 建立链接了&lt;/li>
&lt;/ol>
&lt;p>&lt;strong>Fully Qualified Domain Name(完全限定域名，简称 FQDN)&lt;/strong> 。类似于 &lt;code>www.baidu.com.&lt;/code> 就是完全限定域名，即该域名直接代表一台提供业务服务的设备。这就好比 Linux 中的绝对路径概念一样。其他的都是相对域名&lt;/p>
&lt;h2 id="resource-record资源记录">Resource Record(资源记录)&lt;/h2>
&lt;p>与域名相关的数据都被保存在每个 NameServer 的 &lt;strong>ResourceRecord(资源记录，简称 RR)&lt;/strong> 中。域名与 IP 之间的对应关系，称为 &lt;strong>Record(记录)&lt;/strong>。&lt;/p>
&lt;p>RR 用于标示 NameServer 解析库中每一个解析条目的具体类型，比如本域的域名与 IP 的对应关系，下级域的域名中的资源等等，标注出这些资源，以便用这些资源解析用户的 DNS 请求&lt;/p>
&lt;p>RR 具有标准格式，遵守 RFC1035，每一条记录都可以包含如下几个字段：&lt;/p>
&lt;ul>
&lt;li>&lt;strong>NAME&lt;/strong> # 本条记录中节点的完全限定域名&lt;/li>
&lt;li>&lt;strong>CLASS&lt;/strong> # 本条记录的类。对于互联网来说，通常为 IN&lt;/li>
&lt;li>**TYPE **# 本条记录的类型&lt;/li>
&lt;li>**TTL **# 本条记录的保存时长&lt;/li>
&lt;li>**RDLENGTH **# RDATA 字段的长度&lt;/li>
&lt;li>**RDATA **# 本条记录的额外内容&lt;/li>
&lt;li>&lt;strong>VALUE&lt;/strong> # 本条记录的具体内容。不同的记录类型，该字段的内容也不同。&lt;/li>
&lt;/ul>
&lt;p>RR 定义的格式：NAME [TTL] CLASS RR-TYPE VALUE（注意：格式中的域名都要带根域名，即域名最后都要加一个 . ）&lt;/p>
&lt;ul>
&lt;li>NAME 和 VALUE # 不同的 RR-TYPE 有不同的格式&lt;/li>
&lt;li>CLASS：IN&lt;/li>
&lt;li>TYPE 资源记录类型：A，AAAA，PTR，SOA，NS，CNAME，MX 等：
&lt;ul>
&lt;li>SRV：域名系统中用于指定服务器提供服务的位置（如主机名和端口）
&lt;ul>
&lt;li>name # _服务._协议.名称.&lt;/li>
&lt;li>value # 优先级 权重 端口 主机.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>SOA：Start Of Authority：起始授权记录，一个区域解析库有且只能有一个 SOA 记录，而且必须为解析库第一条记录
&lt;ul>
&lt;li>name # 域名，例如”baidu.com.“&lt;/li>
&lt;li>value # (属性)
&lt;ul>
&lt;li>当前区域的主 DNS 服务器的 FQDN，也可以使用当前区域的名字&lt;/li>
&lt;li>当前区域管理员的邮箱地址，但是地址中不能用@符号，@符号用.替换&lt;/li>
&lt;li>（主从服务协调属性的定义以及否定结果的统一的 TTL）&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>NS：Name Server：专用于标明当前区域的 DNS 服务器
&lt;ul>
&lt;li>name # 域名&lt;/li>
&lt;li>value # 当前区域的某 DNS 服务器的名字，例如 ns.baidu.com.;(一个区域可以有多个 NS 记录)&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>MX：Mail eXchanger：邮件交换器
&lt;ul>
&lt;li>TTL 可以从全局继承&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>A/AAAA：Address，A 格式用于实现将 FQDN 解析为 IPv4(AAAA 格式用于将 FQDN 解析为 IPv6)
&lt;ul>
&lt;li>name # 域名&lt;/li>
&lt;li>value # 域名对应的 IP 地址&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>PTR：PoinTeR，用于将 IP 解析为 FQDN
&lt;ul>
&lt;li>name # IP，特殊格式，反写 IP，比如 1.2.3.4 要写成 4.3.2.1，跟后缀 in-addr.arpa.&lt;/li>
&lt;li>value # FQDN&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>CNAME：Canonical Name，别名记录
&lt;ul>
&lt;li>name # 别名的 FQDN&lt;/li>
&lt;li>value # 正式名字的 FQDN&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>注意：
&lt;ul>
&lt;li>@可用于引用当前区域的名字&lt;/li>
&lt;li>相邻的两个资源记录的 name 相同时，后续的可省略&lt;/li>
&lt;li>同一个名字可以通过多条记录定义多个不同的值，此时 DNS 服务器会轮循响应&lt;/li>
&lt;li>同一个值也有可能有多个不同的定义名字，通过多个不同的名字指向同一个&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h3 id="example">EXAMPLE&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>baidu.com &lt;span style="color:#ae81ff">86499&lt;/span> IN SOA ns.baidu.com. lichenhao.qq.com. （
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ae81ff">2018072001&lt;/span> &lt;span style="color:#75715e">#序列号，当序列号变化时，即代表资源有变化，主DNS会主动同步数据给备&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> 2H &lt;span style="color:#75715e">#刷新时间，2小时&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> 10M &lt;span style="color:#75715e">#重试时间，10分钟&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> 1W &lt;span style="color:#75715e">#过期时间，1周&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> 1D ） &lt;span style="color:#75715e">#否定结果的TTL值，1天&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>baidu.com. IN NS ns1.baidu.com
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>ns1.baidu.com IN A 1.1.1.0
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>www.baidu.com IN A 1.1.1.1
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> IN A 1.1.1.2
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>baidu.com. IN MX &lt;span style="color:#ae81ff">10&lt;/span> mx1.baidu.com
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> IN MX &lt;span style="color:#ae81ff">20&lt;/span> mx2.baidu.com
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>4.3.2.1.in-addr.arpa. IN PTR www.baidu.com
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>web.baidu.com. IN CNAME www.baidu.com.
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>子域授权：每个域的 DNS 服务器，都是通过在其上级 DNS 服务器中的解析库添加该域的 DNS 服务器信息进行授权&lt;/p>
&lt;p>EXAMPLE，在根域的 DNS 服务器中，记录了.com.域的资源记录，类似下面的方式，不是绝对的
.com. IN NS ns1.com. 定义.com.域的域名服务器为 ns1.com.
.com. IN NS ns2.com.
ns1.com. IN A 2.2.2.1 定于.com.域中的域名服务器 ns1.com.的 IP 地址为 2.2.2.1
ns2.com. IN A 2.2.2.2&lt;/p>
&lt;p>当www.baidu.com.的DNS请求到根的DNS服务器的时候，根的DNS服务器查找自己解析库中.com的域中的DNS服务器资源，然后看到该DNS服务器所对应的IP，然后把该请求转发到.com域中的DNS服务器进行下一步解析，然后.com域的DNS服务器在从解析库中找到baidu的资源再转发到baidu的DNS服务器上(或者直接返回baidu的IP地址)&lt;/p>
&lt;p>以上例子是.com 域在.根域中解析库中的资源记录，如果还有 baidu.com 的域名，则该域的资源记录写在.com 域中的解析库，以此类推&lt;/p>
&lt;p>反向区域：&lt;/p>
&lt;p>区域名称：网络地址反写.in-addr-arpa.&lt;/p>
&lt;p>EXAMPLE：172.16.100. 写成 100.16.172.in-addr-arpa.&lt;/p>
&lt;h1 id="dns-解析过程">DNS 解析过程&lt;/h1>
&lt;p>DNS 查询过程：主机发送请求到根域名解析服务器，然后重定向到二级域名解析服务器，再重定向到三级域名解析服务器，以此类推&lt;/p>
&lt;ul>
&lt;li>在本机上查询 DNS 的配置文件(比如/etc/hosts)，有没有 IP 地址与 Domain Name 的对应关系
&lt;ul>
&lt;li>EXAMPLE：如果把本机 IP 的对应域名改 baidu.com.，那么在访问百度的时候，就只会访问本机了&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>如果在本机无法查询到 Domain Name 与 IP 的对应关系，那么需要通过 DNS 代理来进行查询，总共分为两种查询类型
&lt;ul>
&lt;li>递归查询：主机只发送一次 DNS 解析请求，就获得最后的结果。
&lt;ul>
&lt;li>在本机配置一个运行 DNS 服务的 Server 的 IP 地址，把请求直接发送给该 server，&lt;/li>
&lt;li>由该 server 去找.根域名服务器进行查询，然后.根域名服务器再根据该请求中的顶级域名把该请求重定向到顶级域名服务器上&lt;/li>
&lt;li>如果该请求还有二级域名，那么顶级域名 server 会 再把该请求重定向二级域名 server 上&lt;/li>
&lt;li>直到查询到最终结果后，把该结果返回给 DNS Server，然后 DNS Server 把结果直接告诉发送请求的主机&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>迭代查询：主机发送一次 DNS 解析请求后，被重定向到另一台 DNS 服务器继续发送请求，直到获得最后结果。
&lt;ul>
&lt;li>该查询主机直接发送请求到.根域名 server，然后进行递归查询中的 2,3,4 步骤&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>一次完整的查询请求经过的流程&lt;/p>
&lt;ul>
&lt;li>首先，客户端查询本地的 DNS 服务器。默认情况下，即/etc/resolv.conf 文件中所列的第一个名称服务器。&lt;/li>
&lt;li>接着本地名称服务器会查询本地解析库和缓存，如果本地数据库中有该资源记录（该名称服务器对该域进行权威解析），则返回查询结果。&lt;/li>
&lt;li>如果没有，则查询缓存，看看缓存中是否有以前对该资源记录的查询结果，如有，则返回查询结果；如果仍然没有，则会向其他 DNS 服务器进行递归解析。&lt;/li>
&lt;li>进入递归解析，本地 DNS 服务器向根域 DNS 服务器（Root Nameserver）提出查询请求，根域 DNS 服务器会返回顶级域（TLD）DNS 服务器地址（例如.com 的 DNS 服务器地址）；本地 DNS 服务器再次向 TLD Nameserver 发出查询请求，TLD Nameserver 会返回下一级域的 DNS 服务器地址；依此类推，直到查询到权威的名称服务器（Authoritative Nameserver）;&lt;/li>
&lt;/ul>
&lt;p>解析类型：&lt;/p>
&lt;ol>
&lt;li>Name &amp;ndash;&amp;gt; IP 正向解析&lt;/li>
&lt;li>IP &amp;ndash;&amp;gt; Name 反向解析&lt;/li>
&lt;/ol>
&lt;h2 id="域名解析结果">域名解析结果：&lt;/h2>
&lt;p>DNS-Rcode 作为 DNS 应答报文中有效的字段，主要用来说明 DNS 应答状态，这可是小编排查域名解析失败的重要指标。通常常见的 Rcode 值如下：&lt;/p>
&lt;ul>
&lt;li>Rcode 值为 0，对应的 DNS 应答状态为 NOERROR，意思是成功的响应，即这个域名解析是成功&lt;/li>
&lt;li>Rcode 值为 2，对应的 DNS 应答状态为 SERVFAIL，意思是服务器失败，也就是这个域名的权威服务器拒绝响应或者响应 REFUSE，递归服务器返回 Rcode 值为 2 给 CLIENT&lt;/li>
&lt;li>Rcode 值为 3，对应的 DNS 应答状态为 NXDOMAIN，意思是不存在的记录，也就是这个具体的域名在权威服务器中并不存在&lt;/li>
&lt;li>Rcode 值为 5，对应的 DNS 应答状态为 REFUSE，意思是拒绝，也就是这个请求源 IP 不在服务的范围内&lt;/li>
&lt;/ul>
&lt;h3 id="dns-请求失败的具体分析">DNS 请求失败的具体分析&lt;/h3>
&lt;p>常见的请求失败包括：
1、域名记录不存在，即 Rcode 值为 3（NXDOMAIN）的情况，这种情况下域名权威服务器及托管的主域名均正常，但是权威并不存在这条具体的域名记录，于是权威返回了 NXDOMAIN，值的注意的是这个 NXDOMAIN 的报文中会包含一个 AUTHORITY SECTION，内容为改主域名的 SOA 记录，这个应答结果会在递归服务器中被缓存，缓存时间周期为域名的 SOA 记录的 TTL：
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/msw4yv/1616161023846-76ea5416-093f-4be5-93ca-8f2ec94d745e.jpeg" alt="">
2、权威解析失败，即 Rcode 值为 2（SERVFAIL）的情况，递归服务器会给请求源这个结果的原因是向权威解释请求异常，包括且不限于权威不响应/或者权威返回 refuse/或者权威返回 servfail，这个 SERVFAIL 的应答结果当然是一个空结果，不过 BIND 会强制给这个结果增加一个 1S 的 TTL，所以 SERVFAIL 的应答会在递归服务器中被缓存，缓存时间周期为 1S&lt;/p>
&lt;ul>
&lt;li>2.1）权威不响应。包括递归服务器至权威服务器中间的网络异常在内，递归服务器在发出递归请求并完成重试超时后，给请求源一个 SERVFAIL 的应答，并缓存 1S ：&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/msw4yv/1616161023768-36d66d1b-0e60-4295-9fd7-899f67b2fe9b.jpeg" alt="">&lt;/p>
&lt;ul>
&lt;li>2.2）权威向递归服务器应答 REFUSE。当权威服务器不存在主域名及对应的 SOA 记录时，权威会向递归服务器返回 REFUSE，即不在我服务的范围内拒绝，递归服务器在收到这个 REFUSE 应答后，给请求源一个 SERVFAIL 的应答，并缓存 1S：&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/msw4yv/1616161023786-286f827b-fc20-42ba-8997-e83267a91a55.jpeg" alt="">&lt;/p>
&lt;ul>
&lt;li>2.3）权威向递归服务器应答 SERVFAIL。当权威服务器存在主域名但是由于 zonefile 被破坏导致权威服务器上域名的 NS 记录异常时，权威会向递归服务器返回 SERVFAIL，即解析失败，递归服务器在收到这个 SERVFAIL 应答后，给请求源一个 SERVFAIL 的应答，并缓存 1S：&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/msw4yv/1616161023782-ace75691-f594-4871-a17a-ee667e422bde.jpeg" alt="">&lt;/p>
&lt;ul>
&lt;li>2.4）权威向递归服务器应答其他的错误 Rcode。由于不常见本文就不展开了，递归服务器在收到其他错误应答后，给请求源一个 SERVFAIL 的应答，并缓存 1S：&lt;/li>
&lt;/ul>
&lt;p>3、拒绝服务，即 Rcode 值为 5（REFUSE）的情况。除了记录不存在（NXDOMAIN）和解析失败（SERVFAIL）以外，如果请求源不在递归服务器的服务范围内，这种情况下递归服务器会直接给请求源一个 REFUSE 的应答，本地直接应答无缓存：
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/msw4yv/1616161023827-0e3a338b-f567-46de-96fc-bf08dbd86720.jpeg" alt="">
4、响应成功，但是没有解析结果，这是一种比较特殊的情况，这种情况是 Rcode 值为 0（NOERROR）的情况。这种情况下域名权威服务器及托管的主域名均正常，权威本身也存在这条具体的域名记录，但是没有对应的记录类型（不包含 CNAME，CNAME 是特殊情况，可以响应任意类型的请求），这是权威返回了 NOERROR，值的注意的是这个 NOERROR 的报文中没有 ANSWER SECTION。但是会包含一个 AUTHORITY SECTION，内容为改主域名的 SOA 记录，这个应答结果会在递归服务器中被缓存，缓存时间周期为域名的 SOA 记录的 TTL：
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/msw4yv/1616161023799-a2ec8dd5-576d-42db-8c4f-224070eb0e21.jpeg" alt="">
5、还有最后的一种情况，就是递归服务器本身不响应了，这个比较容易理解，如果递归服务器不响应，那么请求段收不到任何应答，这个时候请求端终端如果有超时机制则会跑出一个 dns 请求 timeout 的结果：
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/msw4yv/1616161023809-badb7042-8c8f-44c0-888f-802672eddd6b.jpeg" alt="">
结论：
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/msw4yv/1616161023767-6dcbac05-682c-4b55-8225-1e50694e0f68.jpeg" alt="">&lt;/p>
&lt;h1 id="domain-name-registrar域名注册商">Domain name registrar(域名注册商)&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Domain_name_registrar">Wiki,Domain name registrar&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.name.com/">Name.com&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://nic.eu.org/arf/en/">eu.org&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://iweec.com/144.html">https://iweec.com/144.html&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>&lt;strong>Domain name registrar(域名注册商&lt;/strong>) 是一个商业实体或组织，它们由&lt;a href="https://zh.wikipedia.org/wiki/%E4%BA%92%E8%81%94%E7%BD%91%E5%90%8D%E7%A7%B0%E4%B8%8E%E6%95%B0%E5%AD%97%E5%9C%B0%E5%9D%80%E5%88%86%E9%85%8D%E6%9C%BA%E6%9E%84">互联网名称与数字地址分配机构&lt;/a>（ICANN）或者一个国家性的 &lt;a href="https://en.wikipedia.org/wiki/Country_code_top-level_domain">Country code top-level domain&lt;/a> (国家代码顶级域名，简称 ccTLD) &lt;a href="https://zh.wikipedia.org/wiki/%E5%9F%9F%E5%90%8D%E6%B3%A8%E5%86%8C%E5%B1%80">域名注册局&lt;/a>委派，以在指定的&lt;a href="https://zh.wikipedia.org/wiki/%E5%9F%9F%E5%90%8D%E6%B3%A8%E5%86%8C%E6%95%B0%E6%8D%AE%E5%BA%93">域名注册数据库&lt;/a>中管理&lt;a href="https://zh.wikipedia.org/wiki/%E4%BA%92%E8%81%94%E7%BD%91">互联网&lt;/a>&lt;a href="https://zh.wikipedia.org/wiki/%E5%9F%9F%E5%90%8D">域名&lt;/a>，向公众提供此类服务。&lt;/p>
&lt;p>国内域名注册商：&lt;/p>
&lt;ul>
&lt;li>万网&lt;/li>
&lt;li>新网&lt;/li>
&lt;li>DNSPod&lt;/li>
&lt;/ul>
&lt;p>国外域名注册商：&lt;/p>
&lt;ul>
&lt;li>eu.org # 没有自己的 Name Server&lt;/li>
&lt;li>godaddy&lt;/li>
&lt;li>Name.com&lt;/li>
&lt;li>freenom&lt;/li>
&lt;/ul>
&lt;p>我的域名：&lt;/p>
&lt;ul>
&lt;li>Name.com
&lt;ul>
&lt;li>102205.xyz&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>阿里
&lt;ul>
&lt;li>desistdaydream.ltd&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>eu.org #&lt;/li>
&lt;/ul>
&lt;h2 id="euorg-注册方式">eu.org 注册方式&lt;/h2>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://iweec.com/363.html">https://iweec.com/363.html&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.bilibili.com/video/BV1JB4y1m7e9">https://www.bilibili.com/video/BV1JB4y1m7e9&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>eu.org 免费域名从 1996 年就有了，由此可见是非常非常早，计划是专门给无力承担费用的一些组织使用的，现在我们来申请一个。
注册地址：&lt;a href="https://nic.eu.org/arf/en/login/?next=/arf/en/">https://nic.eu.org/arf/en/login/?next=/arf/en/&lt;/a>
点击：Register
填表挺简单的，可以参考我的视频教程。
B 站：&lt;a href="https://www.bilibili.com/video/BV1JB4y1m7e9/">https://www.bilibili.com/video/BV1JB4y1m7e9/&lt;/a>
Youtube：&lt;a href="https://www.youtube.com/watch?v=xWgeCUpM81I">https://www.youtube.com/watch?v=xWgeCUpM81I&lt;/a>
然后成功后到邮箱（垃圾箱）找到邮件、激活，然后登录。
点击登录，然后点击：New domain
填写理想的完整域名例如：abcde.eu.org 同意协议；
域名服务器建议填写下面两个 dnspod，否则无法转到 cloudflare。
edmund.dnspod.net
dempsey.dnspod.net
这里先只选择 server names，然后 Submit，注意看检查页面，如果出现 No error,Done.说明成功了~
如果有错误，请返回修改！
域名审核 1 天——30 天都有可能，所以慢慢等吧，经过我的测试，一个账号内最多可以申请 4 个免费域名。
域名投资参考：&lt;a href="https://iweec.com/144.html">https://iweec.com/144.html&lt;/a>
eu.org 域名通过后是有邮件通知的，但是都在垃圾箱。若是想转到 cloudflare 出现问题，请参考视频：
Bilibili：&lt;a href="https://www.bilibili.com/video/BV1ST4y1z7Ra/">https://www.bilibili.com/video/BV1ST4y1z7Ra/&lt;/a>
Youtube：&lt;a href="https://www.youtube.com/watch?v=EOsBJxtiOho">https://www.youtube.com/watch?v=EOsBJxtiOho&lt;/a>&lt;/p>
&lt;p>注意：&lt;/p>
&lt;ul>
&lt;li>eu.org 本身没有自己的 Name Server，在这里免费获取到域名后，需要指定其他的 Name Server(比如 DNSPod 中的 NameServer)&lt;/li>
&lt;/ul>
&lt;h2 id="可以为其他域名提供-nameserver-的域名注册商">可以为其他域名提供 NameServer 的域名注册商&lt;/h2>
&lt;p>DNSPod&lt;/p>
&lt;h1 id="国内域名备案说明">国内域名备案说明&lt;/h1>
&lt;p>在国内的域名注册机构是必须要备案的，备案时需要关联自己的服务器或者通过公司进行备案。如果不备案，那么域名只有解析 IP 的功能，无法在公网被访问，效果如下：
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/msw4yv/1654614073447-ad968e6f-5cda-4fa1-a31a-84c148d8e6a8.png" alt="image.png">
若访问的是 https，则会提示
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/msw4yv/1656167438257-cf4f1287-4ce6-4ca1-b7b7-3814937ebe74.png" alt="image.png">
这个是由于在国内的服务器，都会收到服务器所在 IDC 的限制，这些 IDC 会在最外层部署一套检测服务，用以检查每个标准端口(80 和 443)的请求域名是否已经备案，若没有备案，该请求 IDC 则不会放行到服务器上。&lt;/p>
&lt;p>DNS 污染、GFW、阻断，这是三座大山&lt;/p></description></item><item><title>Docs: DNSmasq</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/4.%E6%95%B0%E6%8D%AE%E9%80%9A%E4%BF%A1/dns/dnsmasq/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/4.%E6%95%B0%E6%8D%AE%E9%80%9A%E4%BF%A1/dns/dnsmasq/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://thekelleys.org.uk/dnsmasq/docs/dnsmasq-man.html">Manual(手册)&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>DNSmasq 是一个轻量的 DHCP 和 DNS 缓存 服务。&lt;/p>
&lt;h1 id="dns-泛解析实例">DNS 泛解析实例&lt;/h1>
&lt;p>最近遇到一个问题，需要在服务器上对域名进行泛解析，比如访问百度的域名统统解析到 6.6.6.6，然而发现 hosts 文件根本就不支持类似 *.baidu.com 的这种写法。&lt;/p>
&lt;p>于是乎就在网上找了下资料，发现可以通过 Dnsmasq 来解决这个问题，原理其实就是本机的 DNS 指向 Dnsmasq 服务器，然后 Dnsmasq 通过类似通配符 (_) 的方式进行匹配，凡是匹配到 _.baidu.com 的都解析到 6.6.6.6。 &lt;strong>利用 Dnsmasq 实现 hosts 泛解析&lt;/strong>&lt;/p>
&lt;p>&lt;strong>环境介绍&lt;/strong>&lt;/p>
&lt;pre>&lt;code>$ uname \-a
Linux ansheng 3.10.0\-957.1.3.el7.x86\_64 #1 SMP Thu Nov 29 14:49:43 UTC 2018 x86\_64 x86\_64 x86\_64 GNU/Linux
$ whoami
root
$ cat /etc/redhat\-release
CentOS Linux release 7.6.1810 (Core)
&lt;/code>&lt;/pre>
&lt;h2 id="安装-dnsmasq">&lt;strong>安装 Dnsmasq&lt;/strong>&lt;/h2>
&lt;p>安装非常简单，通过 yum 即可。&lt;/p>
&lt;pre>&lt;code>$ yum install dnsmasq \-y
&lt;/code>&lt;/pre>
&lt;p>&lt;strong>配置 Dnsmasq&lt;/strong>
先把配置文件备份一份&lt;/p>
&lt;pre>&lt;code>$ cp /etc/dnsmasq.conf /etc/dnsmasq.conf\_bak
&lt;/code>&lt;/pre>
&lt;p>Dnsmasq 的配置在配置文件中都有详细的说明，你可以通过阅读配置文件的注释更改自己想要的配置，我只是想做泛解析，所以我的配置如下：&lt;/p>
&lt;pre>&lt;code>$ vim /etc/dnsmasq.conf
# 严格按照 resolv\-file 文件中的顺序从上到下进行 DNS 解析, 直到第一个成功解析成功为止
strict\-order
# 监听的 IP 地址
listen\-address\=127.0.0.1
# 设置缓存大小
cache\-size\=10240
# 泛域名解析，访问任何 baidu.com 域名都会被解析到 6.6.6.6
address\=/baidu.com/6.6.6.6
&lt;/code>&lt;/pre>
&lt;p>&lt;a href="https://cloud.tencent.com/product/cns?from=10680">域名解析&lt;/a>默认读取 /etc/hosts 文件到本地域名配置文件（不支持泛域名）。&lt;/p>
&lt;p>DNS 配置默认读取 /etc/resolv.conf 上游 DNS 配置文件，如果读取不到 /etc/hosts 的地址解析，就会转发给 resolv.conf 进行解析地址。&lt;/p>
&lt;ul>
&lt;li>DNS 配置文件
$ vim /etc/resolv.conf 这些都是常用的 DNS，可以配置很多&lt;/li>
&lt;/ul>
&lt;p>nameserver 127.0.0.1  # 一定要放在第一个
nameserver 8.8.8.8
nameserver 8.8.4.4
nameserver 1.1.1.1&lt;/p>
&lt;ul>
&lt;li>启动服务
$ systemctl enable &amp;ndash;now dnsmasq
Created symlink from /etc/systemd/system/multi-user.target.wants/dnsmasq.service to /usr/lib/systemd/system/dnsmasq.service.
查看运行状态
$ systemctl status dnsmasq
● dnsmasq.service - DNS caching server.
Loaded: loaded (/usr/lib/systemd/system/dnsmasq.service; enabled; vendor preset: disabled)
Active: active (running) since 日 2018-12-23 09:00:12 UTC; 3s ago
Main PID: 3844 (dnsmasq)
CGroup: /system.slice/dnsmasq.service
└─3844 /usr/sbin/dnsmasq -k
12 月 23 09:00:12 ansheng systemd[1]: Started DNS caching server..
12 月 23 09:00:12 ansheng dnsmasq[3844]: started, version 2.76 cachesize 10000
12 月 23 09:00:12 ansheng dnsmasq[3844]: compile time options: IPv6 GNU-getopt DBus no-i18n IDN DHCP DHCPv6 no-Lua TFTP no-conntrack ipset auth no-DNSSEC loop-detect inotify
12 月 23 09:00:12 ansheng dnsmasq[3844]: reading /etc/resolv.conf
12 月 23 09:00:12 ansheng dnsmasq[3844]: ignoring nameserver 127.0.0.1 - local interface
12 月 23 09:00:12 ansheng dnsmasq[3844]: using nameserver 8.8.8.8#53
12 月 23 09:00:12 ansheng dnsmasq[3844]: using nameserver 8.8.4.4#53
12 月 23 09:00:12 ansheng dnsmasq[3844]: using nameserver 1.1.1.1#53
12 月 23 09:00:12 ansheng dnsmasq[3844]: read /etc/hosts - 6 addresses&lt;/li>
&lt;/ul>
&lt;h2 id="测试">&lt;strong>测试&lt;/strong>&lt;/h2>
&lt;pre>&lt;code>$ ping baidu.com
PING baidu.com (6.6.6.6) 56(84) bytes of data.
^C
\--\- baidu.com ping statistics \--\-
2 packets transmitted, 0 received, 100% packet loss, time 1000ms
$ ping www.baidu.com
PING www.baidu.com (6.6.6.6) 56(84) bytes of data.
^C
\--\- www.baidu.com ping statistics \--\-
2 packets transmitted, 0 received, 100% packet loss, time 999ms
$ ping pan.baidu.com
PING pan.baidu.com (6.6.6.6) 56(84) bytes of data.
^C
\--\- pan.baidu.com ping statistics \--\-
2 packets transmitted, 0 received, 100% packet loss, time 999ms
&lt;/code>&lt;/pre>
&lt;p>由上可以看到，几乎访问任何 baidu.com 的域名都会被解析到 6.6.6.6，基本上就达到了我们最初的目的。&lt;/p>
&lt;h2 id="利用-dnsmasq-缓存特性实现-dns-加速">&lt;strong>利用 Dnsmasq 缓存特性实现 DNS 加速&lt;/strong>&lt;/h2>
&lt;p>Dnsmasq 还有一项非常有用的功能就是可以对已经解析过的域名进行缓存，下次在访问这个域名的时候就可以直接返回 IP 地址，而不再需要经过 DNS 查询，这对于扶墙的来说，其实也算是一点优化，默认已经配置好了，我们只需要来演示下缓存的效果。&lt;/p>
&lt;ul>
&lt;li>安装 dig 工具&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>$ yum install bind-utils -y
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>演示效果&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>$ dig www.centos.com | grep &lt;span style="color:#e6db74">&amp;#34;Query time&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>;; Query time: &lt;span style="color:#ae81ff">88&lt;/span> msec
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>$ dig www.centos.com | grep &lt;span style="color:#e6db74">&amp;#34;Query time&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>;; Query time: &lt;span style="color:#ae81ff">0&lt;/span> msec
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>$ dig www.centos.com | grep &lt;span style="color:#e6db74">&amp;#34;Query time&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>;; Query time: &lt;span style="color:#ae81ff">0&lt;/span> msec
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>$ dig www.centos.com | grep &lt;span style="color:#e6db74">&amp;#34;Query time&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>;; Query time: &lt;span style="color:#ae81ff">0&lt;/span> msec
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>$ dig www.youtube.com | grep &lt;span style="color:#e6db74">&amp;#34;Query time&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>;; Query time: &lt;span style="color:#ae81ff">28&lt;/span> msec
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>$ dig www.youtube.com | grep &lt;span style="color:#e6db74">&amp;#34;Query time&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>;; Query time: &lt;span style="color:#ae81ff">0&lt;/span> msec
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>$ dig www.qq.com | grep &lt;span style="color:#e6db74">&amp;#34;Query time&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>;; Query time: &lt;span style="color:#ae81ff">71&lt;/span> msec
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>$ dig www.qq.com | grep &lt;span style="color:#e6db74">&amp;#34;Query time&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>;; Query time: &lt;span style="color:#ae81ff">0&lt;/span> msec
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>看看上面的对比，查询时间缩小了不少倍，可见缓存已经产生作用。&lt;/p>
&lt;blockquote>
&lt;p>来源：&lt;em>安生博客&lt;/em> 原文：&lt;a href="http://t.cn/AiCohacf">&lt;em>http://t.cn/AiCohacf&lt;/em>&lt;/a> 题图：&lt;em>来自谷歌图片搜索&lt;/em> 版权：&lt;em>本文版权归原作者所有&lt;/em> 投稿：_欢迎投稿，投稿邮箱: _&lt;a href="mailto:editor@hi-linux.com">&lt;em>editor@hi-linux.com&lt;/em>&lt;/a>&lt;/p>
&lt;/blockquote>
&lt;p>本文分享自微信公众号 - 运维之美（Hi-Linux），作者：ansheng&lt;/p>
&lt;p>原文出处及转载信息见文内详细说明，如有侵权，请联系 &lt;a href="mailto:yunjia_community@tencent.com">yunjia_community@tencent.com&lt;/a> 删除。&lt;/p>
&lt;p>原始发表时间：2019-11-02&lt;/p>
&lt;p>本文参与&lt;a href="https://cloud.tencent.com/developer/support-plan">腾讯云自媒体分享计划&lt;/a>，欢迎正在阅读的你也加入，一起分享。
&lt;a href="https://cloud.tencent.com/developer/article/1534150">https://cloud.tencent.com/developer/article/1534150&lt;/a>&lt;/p></description></item><item><title>Docs: GRE</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/4.%E6%95%B0%E6%8D%AE%E9%80%9A%E4%BF%A1/tunneling-protocol%E9%9A%A7%E9%81%93%E5%8D%8F%E8%AE%AE/gre/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/4.%E6%95%B0%E6%8D%AE%E9%80%9A%E4%BF%A1/tunneling-protocol%E9%9A%A7%E9%81%93%E5%8D%8F%E8%AE%AE/gre/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;p>**Generic Routing Encapsulation(通用路由封装，简称 GRE)**是一种隧道协议，在数据两端，对数据进行封装和解封装。是 Cisco Systems 开发的隧道协议，可以通过 Internet 协议网络将各种网络层协议封装在虚拟点对点链路中。&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/qp0rg3/1616160946635-68a0d422-0333-48eb-aa84-f8f03f1c76a0.jpeg" alt="">
如上图，当从本机想要通过隧道发送数据时，会通过 GRE 模块进行封装，然后把对外通信的 IP 地址当做 GRE 的外部地址，封装在最外成变成新的 IP。此时，GRE 还会有一个内部地址用来与隧道的对端进行协商，以便识别公网上的隧道两端的设备&lt;/p>
&lt;h2 id="linux-下实现-gre">Linux 下实现 GRE&lt;/h2>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/qp0rg3/1616160946644-61636d63-9002-4967-b9e5-98fb974f4fb7.jpeg" alt="">
场景一：
如果 Linux1 想要访问 10.10.2.0/24 网段的设备，这时候可以使用 GRE 建立隧道来实 现。比如在 Linux1 上想访问 10.10.2.100 这台设备，把数据包通过手动添加路由的方式，直接送给 tun 设备，tun 设备会直接把数据包发送给其隧道的对端(i.e.Linux2)，当 Linux2 收到这个数据包时，会发现 GRE 的包头，并解开 GRE 后发现真实的目的地址(10.10.2.100)，这时候可以在 Linux2 上做一个 snat，指明源地址 172.16.0.1/32 且目的地址是 10.10.2.0/24 网段的数据包全部把源地址转换成 10.10.2.1(如果不做 snat，源地址是 172.16.0.1，在回包的时候，是无法回去的，否则再添加其余路由条目)&lt;/p>
&lt;p>场景二：
10.10.0.1/24 与 10.10.1.1/24 作为网段的网关使用，可以让两边的内网机器，直接互相访问。同样需要手动添加路由，目的地址是对端内网网段的 IP 的数据包送给 tun 设备。&lt;/p>
&lt;p>注意：在 Linux1 上 ping172.16.0.2 的时候，在 Linux2 上抓包的话，会显示源地址是 172.16.0.1。&lt;/p>
&lt;h2 id="配置方式">配置方式：&lt;/h2>
&lt;p>通过配置文件来进行配置&lt;/p>
&lt;p>| Linux1 的 tun 设备的配置文件：
DEVICE=tun0
ONBOOT=yes
TYPE=GRE
PEER_OUTER_IPADDR=100.0.2.100
PEER_INNER_IPADDR=172.16.0.2/30
MY_OUTER_IPADDR=100.0.1.100
MY_INNER_IPADDR=172.16.0.1
KEY=lichenhao
BOOTPROTO=none
配置完成后会自动下面的路由信息
172.16.0.2/30 dev tun0 proto kernel scope link src 172.16.0.1/30 | Linux2 的 tun 设备的配置文件：
DEVICE=tun0
ONBOOT=yes
TYPE=GRE
PEER_OUTER_IPADDR=100.0.1.100
PEER_INNER_IPADDR=172.16.0.1/30
MY_OUTER_IPADDR=100.0.2.100
MY_INNER_IPADDR=172.16.0.2
KEY=lichenhao
BOOTPROTO=none
配置完成后会自动下面的路由信息&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>172.16.0.1/30 dev tun0 proto kernel scope link src 172.16.0.2/30&lt;/th>
&lt;th>&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;/table>
&lt;p>如果想要实现场景一的功能,可以在 Linux1 上添加路由条目：ip route add 10.10.2.0/24 dev tun0。在 Linux 添加 snat 规则：iptables -t nat -A POSTROUTING -s 1772.16.0.1 -d 10.10.2.0/24 -j SNAT &amp;ndash;to-source 10.10.2.1&lt;/p>
&lt;p>配置文件说明：&lt;/p>
&lt;ul>
&lt;li>PEER_OUTER_IPADDR=100.0.2.100 #隧道外部对端地址。i.e.能让两台服务器互相访问的对端地址&lt;/li>
&lt;li>PEER_INNER_IPADDR=172.16.0.2/30 #隧道内部对端地址。i.e.对端服务器的 tun 设备的 IP&lt;/li>
&lt;li>MY_OUTER_IPADDR=100.0.1.100 #隧道外部本地地址。i.e.能让两台服务器互相访问的本地地址&lt;/li>
&lt;li>MY_INNER_IPADDR=172.16.0.1 #隧道内部本地地址。i.e.本服务器的 tun 设备的 ip&lt;/li>
&lt;/ul>
&lt;p>从命令行来体现的话，PEER 就是命令行中的 remote 和 peer。MY 就是 local&lt;/p>
&lt;p>通过 ip 命令来进行配置&lt;/p>
&lt;p>Linux1 上的命令
ip tunnel add tun0 mode gre remote 100.0.2.100 local 100.0.1.100
ip addr add 172.16.0.1/30 peer 172.16.0.2/30 dev tun0
ip route add 10.10.2.0/24 dev tun0&lt;/p>
&lt;p>Linux2 上的命令
ip tunnel add tun0 mode gre remote 100.0.2.100 local 100.0.1.100
ip addr add 172.16.0.1/30 peer 172.16.0.2/30 dev tun0
ip route add 10.10.1.0/24 dev tun0&lt;/p>
&lt;p>通过 NetworkManager 来进行配置&lt;/p>
&lt;p>Linux1 上的命令
nmcli connection add con-name tun0 ifname tun0 type ip-tunnel mode gre ip-tunnel.remote 100.0.2.100 ip-tunnel.local 100.0.1.100 ipv4.method manual ipv4.addresses 172.16.0.1/30
ip route add 10.10.2.0/24 dev tun0&lt;/p>
&lt;p>Linux2 上的命令
nmcli connection add con-name tun0 ifname tun0 type ip-tunnel mode gre ip-tunnel.remote 100.0.1.100 ip-tunnel.local 100.0.2.100 ipv4.method manual ipv4.addresses 172.16.0.2/30
ip route add 10.10.1.0/24 dev tun0&lt;/p></description></item><item><title>Docs: Headscale(Tailscale开源版本)</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/4.%E6%95%B0%E6%8D%AE%E9%80%9A%E4%BF%A1/tunneling-protocol%E9%9A%A7%E9%81%93%E5%8D%8F%E8%AE%AE/tailscale/headscaletailscale%E5%BC%80%E6%BA%90%E7%89%88%E6%9C%AC/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/4.%E6%95%B0%E6%8D%AE%E9%80%9A%E4%BF%A1/tunneling-protocol%E9%9A%A7%E9%81%93%E5%8D%8F%E8%AE%AE/tailscale/headscaletailscale%E5%BC%80%E6%BA%90%E7%89%88%E6%9C%AC/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://mp.weixin.qq.com/s/Y3z5RzuapZc8jS0UuHLhBw">公众号，云原声实验室-Tailscal 开源版本让你的 WireGuard 直接起飞&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://github.com/juanfont/headscale">GitHub 项目，juanfont/headscale&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>目前国家工信部在大力推动三大运营商发展 IPv6，对家用宽带而言，可以使用的 IPv4 公网 IP 会越来越少。有部分地区即使拿到了公网 IPv4 地址，也是个大内网地址，根本不是真正的公网 IP，访问家庭内网的资源将会变得越来越困难。&lt;/p>
&lt;p>部分小伙伴可能会选择使用 frp 等针对特定协议和端口的内网穿透方案，但这种方案还是不够酸爽，无法访问家庭内网任意设备的任意端口。更佳的选择还是通过 VPN 来组建大内网。至于该选择哪种 VPN，毫无疑问肯定是 WireGuard，WireGuard 就是 VPN 的未来。&lt;/p>
&lt;p>WireGuard 相比于传统 VPN 的核心优势是没有 VPN 网关，所有节点之间都可以点对点（P2P）连接，也就是我之前提到的全互联模式（full mesh），效率更高，速度更快，成本更低。&lt;/p>
&lt;p>WireGuard 目前最大的痛点就是上层应用的功能不够健全，因为 WireGuard 推崇的是 Unix 的哲学，WireGuard 本身只是一个内核级别的模块，只是一个数据平面，至于上层的更高级的功能（比如秘钥交换机制，UDP 打洞，ACL 等），需要通过用户空间的应用来实现。&lt;/p>
&lt;p>所以为了基于 WireGuard 实现更完美的 VPN 工具，现在已经涌现出了很多项目在互相厮杀。笔者前段时间一直在推崇 Netmaker，它通过可视化界面来配置 WireGuard 的全互联模式，它支持 UDP 打洞、多租户等各种高端功能，几乎适配所有平台，非常强大。然而现实世界是复杂的，无法保证所有的 NAT 都能打洞成功，且 Netmaker 目前还没有 fallback 机制，如果打洞失败，无法 fallback 改成走中继节点。Tailscale 在这一点上比 Netmaker 高明许多，它支持 fallback 机制，可以尽最大努力实现全互联模式，部分节点即使打洞不成功，也能通过中继节点在这个虚拟网络中畅通无阻。&lt;/p>
&lt;h2 id="tailscale-是什么">Tailscale 是什么&lt;/h2>
&lt;p>Tailscale 是一种基于 WireGuard 的虚拟组网工具，和 Netmaker 类似，&lt;strong>最大的区别在于 Tailscale 是在用户态实现了 WireGuard 协议，而 Netmaker 直接使用了内核态的 WireGuard&lt;/strong>。所以 Tailscale 相比于内核态 WireGuard 性能会有所损失，但与 OpenVPN 之流相比还是能甩好几十条街的，Tailscale 虽然在性能上做了些许取舍，但在功能和易用性上绝对是完爆其他工具：&lt;/p>
&lt;ul>
&lt;li>开箱即用
&lt;ul>
&lt;li>无需配置防火墙&lt;/li>
&lt;li>没有额外的配置&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>高安全性/私密性
&lt;ul>
&lt;li>自动密钥轮换&lt;/li>
&lt;li>点对点连接&lt;/li>
&lt;li>支持用户审查端到端的访问记录&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>在原有的 ICE、STUN 等 UDP 协议外，实现了 DERP TCP 协议来实现 NAT 穿透&lt;/li>
&lt;li>基于公网的控制服务器下发 ACL 和配置，实现节点动态更新&lt;/li>
&lt;li>通过第三方（如 Google） SSO 服务生成用户和私钥，实现身份认证&lt;/li>
&lt;/ul>
&lt;p>简而言之，我们可以将 Tailscale 看成是更为易用、功能更完善的 WireGuard。&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/af37c7a5-9f8e-4905-a639-0a377cb44ee6/640" alt="">&lt;/p>
&lt;p>光有这些还不够，作为一个白嫖党，咱更关心的是&lt;strong>免费&lt;/strong>与&lt;strong>开源&lt;/strong>。&lt;/p>
&lt;p>Tailscale 是一款商业产品，但个人用户是可以白嫖的，个人用户在接入设备不超过 20 台的情况下是可以免费使用的（虽然有一些限制，比如子网网段无法自定义，且无法设置多个子网）。除 Windows 和 macOS 的图形应用程序外，其他 Tailscale 客户端的组件（包含 Android 客户端）是在 BSD 许可下以开源项目的形式开发的，你可以在他们的 GitHub 仓库[3]找到各个操作系统的客户端源码。&lt;/p>
&lt;p>对于大部份用户来说，白嫖 Tailscale 已经足够了，如果你有更高的需求，比如自定义网段，可以选择付费。&lt;/p>
&lt;p>&lt;strong>我就不想付费行不行？行，不过得往下看。&lt;/strong>&lt;/p>
&lt;h2 id="headscale-是什么">Headscale 是什么&lt;/h2>
&lt;p>Tailscale 的控制服务器是不开源的，而且对免费用户有诸多限制，这是人家的摇钱树，可以理解。好在目前有一款开源的实现叫 Headscale，这也是唯一的一款，希望能发展壮大。&lt;/p>
&lt;p>Headscale 由欧洲航天局的 Juan Font 使用 Go 语言开发，在 BSD 许可下发布，实现了 Tailscale 控制服务器的所有主要功能，可以部署在企业内部，没有任何设备数量的限制，且所有的网络流量都由自己控制。&lt;/p>
&lt;p>目前 Headscale 还没有可视化界面，期待后续更新吧。&lt;/p>
&lt;h1 id="headscale-部署">Headscale 部署&lt;/h1>
&lt;p>Headscale 部署很简单，推荐直接在 Linux 主机上安装。&lt;/p>
&lt;blockquote>
&lt;p>理论上来说只要你的 Headscale 服务可以暴露到公网出口就行，但最好不要有 NAT，所以推荐将 Headscale 部署在有公网 IP 的云主机上。&lt;/p>
&lt;/blockquote>
&lt;h2 id="准备一些环境变量">准备一些环境变量&lt;/h2>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>export HeadscaleVersion&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;0.15.0&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>export HeadscaleArch&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;amd64&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># Headscale 用于与各个节点通信的 IP&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>export HeadscaleIP&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;X.X.X.X&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="准备-headscale-相关文件及目录">准备 Headscale 相关文件及目录&lt;/h2>
&lt;p>从 &lt;a href="https://github.com/juanfont/headscale/releases">GitHub 仓库的 Release 页面&lt;/a>下载最新版的二进制文件。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>wget --output-document&lt;span style="color:#f92672">=&lt;/span>/usr/local/bin/headscale &lt;span style="color:#ae81ff">\
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">&lt;/span> https://github.com/juanfont/headscale/releases/download/v&lt;span style="color:#e6db74">${&lt;/span>HeadscaleVersion&lt;span style="color:#e6db74">}&lt;/span>/headscale_&lt;span style="color:#e6db74">${&lt;/span>HeadscaleVersion&lt;span style="color:#e6db74">}&lt;/span>_linux_&lt;span style="color:#e6db74">${&lt;/span>HeadscaleArch&lt;span style="color:#e6db74">}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>chmod +x /usr/local/bin/headscale
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>创建相关目录及文件&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>mkdir -p /etc/headscale
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>mkdir -p /var/lib/headscale
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>touch /var/lib/headscale/db.sqlite
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>创建 headscale 用户，并修改相关文件权限：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>useradd headscale -d /home/headscale -m
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>chown -R headscale:headscale /var/lib/headscale
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="创建-headscale-配置文件">创建 Headscale 配置文件&lt;/h3>
&lt;p>有两种方式&lt;/p>
&lt;ul>
&lt;li>下载文件后修改内容&lt;/li>
&lt;li>直接按照自己的要求创建&lt;/li>
&lt;/ul>
&lt;p>下载配置文件&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>wget https://github.com/juanfont/headscale/raw/main/config-example.yaml -O /etc/headscale/config.yaml
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ul>
&lt;li>修改配置文件
&lt;ul>
&lt;li>&lt;strong>server_url&lt;/strong> # 改为公网 IP 或域名。&lt;strong>如果是国内服务器，域名必须要备案&lt;/strong>。我的域名无法备案，所以我就直接用公网 IP 了。&lt;/li>
&lt;li>&lt;strong>magic_dns&lt;/strong> # 如果暂时用不到 DNS 功能，该值设为 false&lt;/li>
&lt;li>&lt;strong>unix_socket&lt;/strong> # unix_socket: /var/run/headscale/headscale.sock&lt;/li>
&lt;li>&lt;strong>ip_prefixes&lt;/strong> # 可自定义私有网段&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>直接创建配置&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-yaml" data-lang="yaml">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">tee /etc/headscale/config.yaml &amp;gt; /dev/null &amp;lt;&amp;lt;EOF&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">server_url&lt;/span>: &lt;span style="color:#ae81ff">http://${HeadscaleIP}:8080&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">listen_addr&lt;/span>: &lt;span style="color:#ae81ff">0.0.0.0&lt;/span>:&lt;span style="color:#ae81ff">8080&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">metrics_listen_addr&lt;/span>: &lt;span style="color:#ae81ff">127.0.0.1&lt;/span>:&lt;span style="color:#ae81ff">9090&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">grpc_listen_addr&lt;/span>: &lt;span style="color:#ae81ff">0.0.0.0&lt;/span>:&lt;span style="color:#ae81ff">50443&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">grpc_allow_insecure&lt;/span>: &lt;span style="color:#66d9ef">false&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">private_key_path&lt;/span>: &lt;span style="color:#ae81ff">/var/lib/headscale/private.key&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">ip_prefixes&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#ae81ff">fd7a:115c:a1e0::/48&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#ae81ff">100.64.0.0&lt;/span>&lt;span style="color:#ae81ff">/10&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">derp&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">server&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">enabled&lt;/span>: &lt;span style="color:#66d9ef">false&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">region_id&lt;/span>: &lt;span style="color:#ae81ff">999&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">region_code&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;headscale&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">region_name&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;Headscale Embedded DERP&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">stun_listen_addr&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;0.0.0.0:3478&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">urls&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#ae81ff">https://controlplane.tailscale.com/derpmap/default&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">paths&lt;/span>: []
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">auto_update_enabled&lt;/span>: &lt;span style="color:#66d9ef">true&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">update_frequency&lt;/span>: &lt;span style="color:#ae81ff">24h&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">disable_check_updates&lt;/span>: &lt;span style="color:#66d9ef">false&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">ephemeral_node_inactivity_timeout&lt;/span>: &lt;span style="color:#ae81ff">30m&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">db_type&lt;/span>: &lt;span style="color:#ae81ff">sqlite3&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">db_path&lt;/span>: &lt;span style="color:#ae81ff">/var/lib/headscale/db.sqlite&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">acme_url&lt;/span>: &lt;span style="color:#ae81ff">https://acme-v02.api.letsencrypt.org/directory&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">acme_email&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">tls_letsencrypt_hostname&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">tls_client_auth_mode&lt;/span>: &lt;span style="color:#ae81ff">relaxed&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">tls_letsencrypt_cache_dir&lt;/span>: &lt;span style="color:#ae81ff">/var/lib/headscale/cache&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">tls_letsencrypt_challenge_type&lt;/span>: &lt;span style="color:#ae81ff">HTTP-01&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">tls_letsencrypt_listen&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;:http&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">tls_cert_path&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">tls_key_path&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">log_level&lt;/span>: &lt;span style="color:#ae81ff">info&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">acl_policy_path&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">dns_config&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">nameservers&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#ae81ff">1.1.1.1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">domains&lt;/span>: []
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">magic_dns&lt;/span>: &lt;span style="color:#66d9ef">true&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">base_domain&lt;/span>: &lt;span style="color:#ae81ff">example.com&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">unix_socket&lt;/span>: &lt;span style="color:#ae81ff">/var/run/headscale/headscale.sock&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">unix_socket_permission&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;0770&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">EOF&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="创建-systemd-unit-文件">创建 Systemd Unit 文件&lt;/h2>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>tee /etc/systemd/system/headscale.service &amp;gt; /dev/null &lt;span style="color:#e6db74">&amp;lt;&amp;lt;EOF
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">[Unit]
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">Description=headscale controller
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">After=syslog.target
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">After=network.target
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">[Service]
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">Type=simple
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">User=headscale
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">Group=headscale
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">ExecStart=/usr/local/bin/headscale serve
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">Restart=always
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">RestartSec=5
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74"># Optional security enhancements
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">NoNewPrivileges=yes
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">PrivateTmp=yes
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">ProtectSystem=strict
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">ProtectHome=yes
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">ReadWritePaths=/var/lib/headscale /var/run/headscale
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">AmbientCapabilities=CAP_NET_BIND_SERVICE
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">RuntimeDirectory=headscale
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">[Install]
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">WantedBy=multi-user.target
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">EOF&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="启动-headscale-服务">启动 Headscale 服务&lt;/h2>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>systemctl daemon-reload
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>systemctl enable --now headscale
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="创建-headscale-namespace">创建 Headscale Namespace&lt;/h2>
&lt;p>Tailscale 中有一个概念叫 tailnet，你可以理解成租户， Tailscale 与 Tailscale 之间是相互隔离的，具体看参考 Tailscale 的官方文档：&lt;a href="https://tailscale.com/kb/1136/tailnet/">What is a tailnet&lt;/a>。&lt;/p>
&lt;p>Headscale 也有类似的实现叫 namespace，即命名空间。Namespace 是一个实体拥有的机器的逻辑组，这个实体对于 Tailscale 来说，通常代表一个用户。&lt;/p>
&lt;p>我们需要先创建一个 namespace，以便后续客户端接入，例如：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>~&lt;span style="color:#f92672">]&lt;/span>&lt;span style="color:#75715e"># headscale namespaces create lichenhao&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Namespace created
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>~&lt;span style="color:#f92672">]&lt;/span>&lt;span style="color:#75715e"># headscale namespaces list&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>ID | Name | Created
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">1&lt;/span> | lichenhao | 2022-03-24 04:23:04
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>注意：&lt;/p>
&lt;ul>
&lt;li>从 v0.15.0 开始，Namespace 之间的边界已经被移除了，所有节点默认可以通信，如果想要限制节点之间的访问，可以使用 &lt;a href="https://github.com/juanfont/headscale/blob/v0.15.0/docs/acls.md">ACL&lt;/a>。在配置文件中只用 &lt;code>acl_policy_path&lt;/code> 字段指定 ACL 配置文件路径，文件配置方式详见：&lt;a href="https://tailscale.com/kb/1018/acls/">https://tailscale.com/kb/1018/acls/&lt;/a>&lt;/li>
&lt;/ul>
&lt;h1 id="headscale-关联文件与配置">Headscale 关联文件与配置&lt;/h1>
&lt;p>&lt;strong>/etc/headscale/config.yaml&lt;/strong> # Headscale 运行时配置文件
**/var/lib/headscale/* **# Headscale 运行时数据目录。包括 数据库文件、证书 等&lt;/p>
&lt;ul>
&lt;li>&lt;strong>./db.sqlite&lt;/strong> # Headscale 使用 sqlite 作为数据库&lt;/li>
&lt;/ul>
&lt;p>&lt;a href="https://github.com/juanfont/headscale/blob/main/config-example.yaml">这里&lt;/a>是配置文件示例&lt;/p>
&lt;h1 id="tailscale-客户端部署与接入-headscale">Tailscale 客户端部署与接入 Headscale&lt;/h1>
&lt;p>Headscale 只是实现了 Tailscale 的控制台，想要接入，依然需要使用 Tailscale 客户端。&lt;/p>
&lt;p>目前除了 iOS 客户端，其他平台的客户端都有办法自定义 Tailscale 的控制服务器。&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>OS&lt;/th>
&lt;th>是否支持 Headscale&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>Linux&lt;/td>
&lt;td>Yes&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>OpenBSD&lt;/td>
&lt;td>Yes&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>FreeBSD&lt;/td>
&lt;td>Yes&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>macOS&lt;/td>
&lt;td>Yes&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Windows&lt;/td>
&lt;td>Yes 参考 Windows 客户端文档[6]&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Android&lt;/td>
&lt;td>需要自己编译客户端[7]&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>iOS&lt;/td>
&lt;td>暂不支持&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>想要让 Tailscale 客户端接入 Headscale，大体分为两个部分&lt;/p>
&lt;ul>
&lt;li>下载并配置 Tailscale 客户端，获取加入节点的指令&lt;/li>
&lt;li>在 Headscale 上执行加入节点的指令&lt;/li>
&lt;/ul>
&lt;h2 id="部署-tailscale-客户端">部署 Tailscale 客户端&lt;/h2>
&lt;h3 id="linux">Linux&lt;/h3>
&lt;p>在 Tailscale 部署的节点准备环境变量&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>export TailscaleVersion&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;1.26.1&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>export TailscaleArch&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;amd64&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>export HeadscaleIP&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;X.X.X.X&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Tailscale 官方提供了各种 Linux 发行版的软件包，但在国内由于网络原因，这些软件源基本用不了。所以我们可以在&lt;a href="https://pkgs.tailscale.com/stable/#static">这里&lt;/a>可以找到所有 Tailscale 的二进制文件，下载，并解压&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>wget https://pkgs.tailscale.com/stable/tailscale_&lt;span style="color:#e6db74">${&lt;/span>TailscaleVersion&lt;span style="color:#e6db74">}&lt;/span>_&lt;span style="color:#e6db74">${&lt;/span>TailscaleArch&lt;span style="color:#e6db74">}&lt;/span>.tgz
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>tar -zxvf tailscale_&lt;span style="color:#e6db74">${&lt;/span>TailscaleVersion&lt;span style="color:#e6db74">}&lt;/span>_&lt;span style="color:#e6db74">${&lt;/span>TailscaleArch&lt;span style="color:#e6db74">}&lt;/span>.tgz
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>这个包里包含如下文件：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>tailscale_&lt;span style="color:#e6db74">${&lt;/span>TailscaleVersion&lt;span style="color:#e6db74">}&lt;/span>_&lt;span style="color:#e6db74">${&lt;/span>TailscaleArch&lt;span style="color:#e6db74">}&lt;/span>/tailscale
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>tailscale_&lt;span style="color:#e6db74">${&lt;/span>TailscaleVersion&lt;span style="color:#e6db74">}&lt;/span>_&lt;span style="color:#e6db74">${&lt;/span>TailscaleArch&lt;span style="color:#e6db74">}&lt;/span>/tailscaled
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>tailscale_&lt;span style="color:#e6db74">${&lt;/span>TailscaleVersion&lt;span style="color:#e6db74">}&lt;/span>_&lt;span style="color:#e6db74">${&lt;/span>TailscaleArch&lt;span style="color:#e6db74">}&lt;/span>/systemd/
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>tailscale_&lt;span style="color:#e6db74">${&lt;/span>TailscaleVersion&lt;span style="color:#e6db74">}&lt;/span>_&lt;span style="color:#e6db74">${&lt;/span>TailscaleArch&lt;span style="color:#e6db74">}&lt;/span>/systemd/tailscaled.defaults
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>tailscale_&lt;span style="color:#e6db74">${&lt;/span>TailscaleVersion&lt;span style="color:#e6db74">}&lt;/span>_&lt;span style="color:#e6db74">${&lt;/span>TailscaleArch&lt;span style="color:#e6db74">}&lt;/span>/systemd/tailscaled.service
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>将文件复制到对应路径下(这里的路径其实就是通过各种软件源安装的路径)：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>cp tailscale_&lt;span style="color:#e6db74">${&lt;/span>TailscaleVersion&lt;span style="color:#e6db74">}&lt;/span>_&lt;span style="color:#e6db74">${&lt;/span>TailscaleArch&lt;span style="color:#e6db74">}&lt;/span>/tailscaled /usr/sbin/tailscaled
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>cp tailscale_&lt;span style="color:#e6db74">${&lt;/span>TailscaleVersion&lt;span style="color:#e6db74">}&lt;/span>_&lt;span style="color:#e6db74">${&lt;/span>TailscaleArch&lt;span style="color:#e6db74">}&lt;/span>/tailscale /usr/bin/tailscale
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>cp tailscale_&lt;span style="color:#e6db74">${&lt;/span>TailscaleVersion&lt;span style="color:#e6db74">}&lt;/span>_&lt;span style="color:#e6db74">${&lt;/span>TailscaleArch&lt;span style="color:#e6db74">}&lt;/span>/systemd/tailscaled.service /lib/systemd/system/tailscaled.service
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>cp tailscale_&lt;span style="color:#e6db74">${&lt;/span>TailscaleVersion&lt;span style="color:#e6db74">}&lt;/span>_&lt;span style="color:#e6db74">${&lt;/span>TailscaleArch&lt;span style="color:#e6db74">}&lt;/span>/systemd/tailscaled.defaults /etc/default/tailscaled
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>启动 tailscaled.service 并设置开机自启：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>systemctl enable tailscaled --now
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Tailscale 接入 Headscale：&lt;/p>
&lt;blockquote>
&lt;p>这里推荐将 DNS 功能关闭，因为它会覆盖系统的默认 DNS。&lt;/p>
&lt;/blockquote>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>tailscale up --login-server&lt;span style="color:#f92672">=&lt;/span>http://&lt;span style="color:#e6db74">${&lt;/span>HeadscaleIP&lt;span style="color:#e6db74">}&lt;/span>:8080 --accept-routes&lt;span style="color:#f92672">=&lt;/span>true --accept-dns&lt;span style="color:#f92672">=&lt;/span>false
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>执行完上面的命令后，会出现下面的信息：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>Warning: IP forwarding is disabled, subnet routing/exit nodes will not work.
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>See https://tailscale.com/kb/1104/enable-ip-forwarding/
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>To authenticate, visit:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> http://X.X.X.X:8080/register?key&lt;span style="color:#f92672">=&lt;/span>30e9c9c952e2d66680b9904eb861e24a595e80c0839e3541142edb56c0d43e16
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Success.
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>在浏览器中打开该链接，就会出现如下的界面：
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/af37c7a5-9f8e-4905-a639-0a377cb44ee6/1648097896734-2252f545-7f43-46fb-ad3a-1e1c85ce3d08.png" alt="image.png">
最后，根据 &lt;a href="#LWIp8">在 Headscale 中添加节点&lt;/a> 部分的文档，将节点接入到 Headscale 中。&lt;/p>
&lt;h3 id="macos">macOS&lt;/h3>
&lt;p>macOS 客户端的安装相对来说就简单多了，只需要在应用商店安装 APP 即可，前提是你&lt;strong>需要一个美区 ID&lt;/strong>。。。&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/af37c7a5-9f8e-4905-a639-0a377cb44ee6/640" alt="">&lt;/p>
&lt;p>安装完成后还需要做一些骚操作，才能让 Tailscale 使用 Headscale 作为控制服务器。当然，Headscale 已经给我们提供了详细的操作步骤，你只需要在浏览器中打开 URL：&lt;code>http://&amp;lt;HEADSCALE_PUB_IP&amp;gt;:8080/apple&lt;/code>，便会出现如下的界面：&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/af37c7a5-9f8e-4905-a639-0a377cb44ee6/640" alt="">&lt;/p>
&lt;p>你只需要按照图中所述的步骤操作即可，本文就不再赘述了。&lt;/p>
&lt;p>修改完成后重启 Tailscale 客户端，在 macOS 顶部状态栏中找到 Tailscale 并点击，然后再点击 &lt;code>Log in&lt;/code>。&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/af37c7a5-9f8e-4905-a639-0a377cb44ee6/640" alt="">&lt;/p>
&lt;p>然后立马就会跳转到浏览器并打开一个页面。&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/af37c7a5-9f8e-4905-a639-0a377cb44ee6/640" alt="">&lt;/p>
&lt;p>接下来与之前 Linux 客户端相同，回到 Headscale 所在的机器执行浏览器中的命令即可，注册成功：&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/af37c7a5-9f8e-4905-a639-0a377cb44ee6/640" alt="">&lt;/p>
&lt;p>回到 Headscale 所在主机，查看注册的节点：&lt;/p>
&lt;p>`$ headscale nodes list&lt;/p>
&lt;p>ID | Name | NodeKey | Namespace | IP addresses | Ephemeral | Last seen | Onlin&lt;/p>
&lt;p>e | Expired&lt;/p>
&lt;p>1 | coredns | [Ew3RB] | default | 10.1.0.1 | false | 2022-03-20 09:08:58 | onlin&lt;/p>
&lt;p>e | no
2 | carsondemacbook-pro | [k7bzX] | default   | 10.1.0.2     | false     | 2022-03-20 09:48:30 | online  | no&lt;/p>
&lt;p>`&lt;/p>
&lt;p>回到 macOS，测试是否能 ping 通对端节点：&lt;/p>
&lt;p>`$ ping -c 2 10.1.0.1
PING 10.1.0.1 (10.1.0.1): 56 data bytes
64 bytes from 10.1.0.1: icmp_seq=0 ttl=64 time=37.025 ms
64 bytes from 10.1.0.1: icmp_seq=1 ttl=64 time=38.181 ms&lt;/p>
&lt;p>-&amp;ndash; 10.1.0.1 ping statistics &amp;mdash;
2 packets transmitted, 2 packets received, 0.0% packet loss
round-trip min/avg/max/stddev = 37.025/37.603/38.181/0.578 ms&lt;/p>
&lt;p>`&lt;/p>
&lt;p>也可以使用 Tailscale CLI 来测试：&lt;/p>
&lt;p>&lt;code>$ /Applications/Tailscale.app/Contents/MacOS/Tailscale ping 10.1.0.1 pong from coredns (10.1.0.1) via xxxx:41641 in 36ms&lt;/code>&lt;/p>
&lt;hr>
&lt;p>如果你没有美区 ID，无法安装 App，可以直接使用命令行版本，通过 Homebrew 安装即可：&lt;/p>
&lt;p>&lt;code>$ brew install tailscale&lt;/code>&lt;/p>
&lt;h3 id="android">Android&lt;/h3>
&lt;p>Android 客户端就比较麻烦了，需要自己修改源代码编译 App，具体可参考这个 issue[9]。编译过程还是比较麻烦的，需要先修改源码，然后构建一个包含编译环境的 Docker 镜像，最后再通过该镜像启动容器编译 apk。&lt;/p>
&lt;p>我知道很多人一看麻烦就不想搞了，这个问题不大，我送佛送到西，提供了一条龙服务，你只需 fork 我的 GitHub 仓库 tailscale-android[10]：&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/af37c7a5-9f8e-4905-a639-0a377cb44ee6/640" alt="">&lt;/p>
&lt;p>然后在你的仓库中点击 &lt;strong>Settings&lt;/strong> 标签，找到 &lt;strong>Secrets&lt;/strong> 下拉框中的 Actions 选项：&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/af37c7a5-9f8e-4905-a639-0a377cb44ee6/640" alt="">&lt;/p>
&lt;p>选择 &lt;strong>New repository secret&lt;/strong> 添加一个 secret 叫 &lt;code>HEADSCALE_URL&lt;/code>，将你的 Headscale 服务公网地址填入其中：&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/af37c7a5-9f8e-4905-a639-0a377cb44ee6/640" alt="">&lt;/p>
&lt;p>&lt;strong>添加在这里的配置，将只对你可见，不用担心会泄露给他人。&lt;/strong>&lt;/p>
&lt;p>然后点击 &lt;strong>Actions&lt;/strong> 标签，选择 &lt;strong>Release&lt;/strong> Workflow。&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/af37c7a5-9f8e-4905-a639-0a377cb44ee6/640" alt="">&lt;/p>
&lt;p>你会看到一个 &lt;strong>Run workflow&lt;/strong> 按钮，点击它，然后在下拉框中点击 &lt;strong>Run workflow&lt;/strong>。&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/af37c7a5-9f8e-4905-a639-0a377cb44ee6/640" alt="">&lt;/p>
&lt;p>流水线就会开始执行，执行成功后就会在 Release 页面看到编译好的 apk。&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/af37c7a5-9f8e-4905-a639-0a377cb44ee6/640" alt="">&lt;/p>
&lt;p>接下来的事情就简单了，下载这个 apk 到你的 Android 手机上安装就好了。安装完成后打开 Tailscale App，选择 &lt;strong>Sign in with other&lt;/strong>。
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/af37c7a5-9f8e-4905-a639-0a377cb44ee6/1648104924984-783c04d7-d504-43dd-b1ad-98dcf7231783.png" alt="image.png">&lt;/p>
&lt;p>然后就会跳出这个页面：
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/af37c7a5-9f8e-4905-a639-0a377cb44ee6/1648103496461-34386c19-5d46-4ddf-88f3-198d0e463d8a.png" alt="image.png">&lt;/p>
&lt;p>将其中的命令粘贴到 Headscale 所在主机的终端，将 &lt;strong>NAMESPACE&lt;/strong> 替换为之前创建的 namespace，然后执行命令即可。注册成功后可将该页面关闭，回到 App 主页，效果如图：&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/af37c7a5-9f8e-4905-a639-0a377cb44ee6/640" alt="">&lt;/p>
&lt;hr>
&lt;p>回到之前的 GitHub 仓库，刚才我们是通过手动触发 Workflow 来编译 apk 的，有没有办法自动编译呢？&lt;strong>只要 Tailscale 官方仓库有更新，就立即触发 Workflow 开始编译。&lt;/strong>&lt;/p>
&lt;p>那当然是可以实现的，而且我已经实现了，仔细看 GitHub Actions 的编排文件：&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/af37c7a5-9f8e-4905-a639-0a377cb44ee6/640" alt="">&lt;/p>
&lt;p>红框圈出来的部分表示只要仓库的 &lt;code>main&lt;/code> 分支有更新，便会触发 Workflow。&lt;strong>现在的问题是如何让 main 分支和上游官方仓库一致，一直保持在最新状态。&lt;/strong>&lt;/p>
&lt;p>这个问题使用第三方 Github App 就可以解决，这个 App 名字简单粗暴，就叫 Pull[11]，它的作用非也很简单粗暴：保持你的 Fork 在最新状态。&lt;/p>
&lt;p>Pull 的使用方法很简单：&lt;/p>
&lt;ol>
&lt;li>打开 Pull App[12] 页面&lt;/li>
&lt;li>点击右上角绿色的 install 按钮&lt;/li>
&lt;/ol>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/af37c7a5-9f8e-4905-a639-0a377cb44ee6/640" alt="">&lt;/p>
&lt;ol start="3">
&lt;li>在选项页面，使用默认的 &lt;strong>All repositories&lt;/strong> 即可（你也可以选择指定的仓库，比如 tailscale-android），然后点击绿色的 &lt;strong>install&lt;/strong> 按钮：&lt;/li>
&lt;/ol>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/af37c7a5-9f8e-4905-a639-0a377cb44ee6/640" alt="">&lt;/p>
&lt;p>简单三步，Pull App 就安装好了。接下来 Pull App 会每天定时帮你更新代码库，使你 fork 的代码始终是最新版的。&lt;/p>
&lt;h3 id="windows">Windows&lt;/h3>
&lt;p>Windows Tailscale 客户端想要使用 Headscale 作为控制服务器，只需在浏览器中打开 &lt;code>http://${HeadscaleIP}&amp;gt;:8080/windows&lt;/code>，便会出现如下的界面：
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/af37c7a5-9f8e-4905-a639-0a377cb44ee6/1648103689211-3b019793-7262-4a6c-a668-127c0f01c284.png" alt="image.png">&lt;/p>
&lt;ul>
&lt;li>下载页面中的 &lt;code>Windows registry file&lt;/code>，这是一个注册表文件，用来配置 Tailscale 客户端中控制服务器的地址，让其指向自己部署的 Headscale&lt;/li>
&lt;li>下载完成后运行 &lt;code>tailscale.reg&lt;/code> 文件以编辑注册表信息。&lt;/li>
&lt;li>在&lt;a href="https://tailscale.com/download/windows">这里&lt;/a>下载 Windows 版的 Tailscale 客户端并安装&lt;/li>
&lt;li>右键点击任务栏中的 Tailscale 图标，再点击 &lt;code>Log in&lt;/code> 获取接入 Headscale 的命令&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/af37c7a5-9f8e-4905-a639-0a377cb44ee6/1648104111282-99d562e1-d7d9-4ea5-9943-f16861efe87e.png" alt="image.png">&lt;/p>
&lt;ul>
&lt;li>此时会自动在浏览器中出现接入 Headscale 的页面&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/af37c7a5-9f8e-4905-a639-0a377cb44ee6/1648104342439-c7a4a6ba-8690-4883-bf2f-c324c8336607.png" alt="image.png">&lt;/p>
&lt;h3 id="其他-linux-发行版">其他 Linux 发行版&lt;/h3>
&lt;p>除了常规的 Linux 发行版之外，还有一些特殊场景的 Linux 发行版，比如 OpenWrt、威联通（QNAP）、群晖等，这些发行版的安装方法已经有人写好了，这里就不详细描述了，我只给出相关的 GitHub 仓库，大家如果自己有需求，直接去看相关仓库的文档即可。&lt;/p>
&lt;ul>
&lt;li>OpenWrt：&lt;a href="https://github.com/adyanth/openwrt-tailscale-enabler">https://github.com/adyanth/openwrt-tailscale-enabler&lt;/a>&lt;/li>
&lt;li>群晖：&lt;a href="https://github.com/tailscale/tailscale-synology">https://github.com/tailscale/tailscale-synology&lt;/a>&lt;/li>
&lt;li>威联通：&lt;a href="https://github.com/ivokub/tailscale-qpkg">https://github.com/ivokub/tailscale-qpkg&lt;/a>&lt;/li>
&lt;/ul>
&lt;h3 id="ios">iOS&lt;/h3>
&lt;p>Tailscale iOS 客户端源代码没有开源，目前还无法破解使其使用第三方控制服务器，遗憾~~&lt;/p>
&lt;h2 id="headscale-中添加节点">Headscale 中添加节点&lt;/h2>
&lt;p>将其中的命令复制粘贴到 Headscale 所在机器的终端中，并将 NAMESPACE 替换为前面所创建的 namespace。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>export HeadscaleNamespace&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;lichenhao&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># 上面例子中的 Linux 客户端&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>headscale -n &lt;span style="color:#e6db74">${&lt;/span>HeadscaleNamespace&lt;span style="color:#e6db74">}&lt;/span> nodes register --key 30e9c9c952e2d66680b9904eb861e24a595e80c0839e3541142edb56c0d43e16
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># 上面例子中的 Windows 客户端&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>headscale -n &lt;span style="color:#e6db74">${&lt;/span>HeadscaleNamespace&lt;span style="color:#e6db74">}&lt;/span> nodes register --key 105363c37b5449b85bb3e4107b6f6bbd3a2bb379dcf731bc98f979584740644a
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>注册成功，查看注册的节点：&lt;/p>
&lt;blockquote>
&lt;p>这里可以看到，已经注册的节点将会分配一个 IP，这里是 100.64.0.1，其他注册的节点可以通过这个 IP 访问该节点。&lt;/p>
&lt;/blockquote>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>~&lt;span style="color:#f92672">]&lt;/span>&lt;span style="color:#75715e"># headscale nodes list&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>ID | Name | NodeKey | Namespace | IP addresses | Ephemeral | Last seen | Online | Expired
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">1&lt;/span> | tj-test-oc-lichenhao | &lt;span style="color:#f92672">[&lt;/span>Bo2d3&lt;span style="color:#f92672">]&lt;/span> | lichenhao | fd7a:115c:a1e0::1, 100.64.0.1 | false | 2022-03-24 06:48:46 | online | no
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">2&lt;/span> | home-desktop | &lt;span style="color:#f92672">[&lt;/span>VZuAp&lt;span style="color:#f92672">]&lt;/span> | lichenhao | fd7a:115c:a1e0::2, 100.64.0.2 | false | 2022-03-24 06:49:31 | online | no
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="检查-tailscale">检查 Tailscale&lt;/h2>
&lt;p>回到 Tailscale 客户端所在的 Linux 主机，可以看到 Tailscale 会自动创建相关的路由表和 iptables 规则。路由表可通过以下命令查看：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>~&lt;span style="color:#f92672">]&lt;/span>&lt;span style="color:#75715e"># ip rule show&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>0: from all lookup local
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>5210: from all fwmark 0x80000 lookup main
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>5230: from all fwmark 0x80000 lookup default
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>5250: from all fwmark 0x80000 unreachable
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>5270: from all lookup &lt;span style="color:#ae81ff">52&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>32766: from all lookup main
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>32767: from all lookup default
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>~&lt;span style="color:#f92672">]&lt;/span>&lt;span style="color:#75715e"># ip route show table 52&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>100.64.0.2 dev tailscale0 &lt;span style="color:#75715e"># 这就是那个 Windows 节点&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>100.100.100.100 dev tailscale0
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>查看 iptables 规则：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>~&lt;span style="color:#f92672">]&lt;/span>&lt;span style="color:#75715e"># iptables -S&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>-P INPUT ACCEPT
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>-P FORWARD ACCEPT
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>-P OUTPUT ACCEPT
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>-N ts-forward
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>-N ts-input
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>-A INPUT -j ts-input
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>-A FORWARD -j ts-forward
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>-A FORWARD -i company -j ACCEPT
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>-A FORWARD -o company -j ACCEPT
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>-A ts-forward -i tailscale0 -j MARK --set-xmark 0x40000/0xffffffff
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>-A ts-forward -m mark --mark 0x40000 -j ACCEPT
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>-A ts-forward -s 100.64.0.0/10 -o tailscale0 -j DROP
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>-A ts-forward -o tailscale0 -j ACCEPT
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>-A ts-input -s 100.64.0.1/32 -i lo -j ACCEPT
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>-A ts-input -s 100.115.92.0/23 ! -i tailscale0 -j RETURN
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>-A ts-input -s 100.64.0.0/10 ! -i tailscale0 -j DROP
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>~&lt;span style="color:#f92672">]&lt;/span>&lt;span style="color:#75715e"># iptables -t nat -S&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>-P PREROUTING ACCEPT
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>-P INPUT ACCEPT
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>-P OUTPUT ACCEPT
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>-P POSTROUTING ACCEPT
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>-N ts-postrouting
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>-A POSTROUTING -j ts-postrouting
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>-A POSTROUTING -o ens192 -j MASQUERADE
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>-A ts-postrouting -m mark --mark 0x40000 -j MASQUERADE
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h1 id="打通局域网">打通局域网&lt;/h1>
&lt;p>到目前为止我们只是打造了一个点对点的 Mesh 网络，各个节点之间都可以通过 WireGuard 的私有网络 IP 进行直连(就是部署时默认使用的 100.64.0.0/10 网段中的 IP)。&lt;/p>
&lt;p>但我们可以更大胆一点，还记得我在文章开头提到的访问家庭内网的资源吗？我们可以通过适当的配置让每个节点都能访问其他节点的局域网 IP。这个使用场景就比较多了，你可以直接访问家庭内网的 NAS，或者内网的任何一个服务，&lt;strong>更高级的玩家可以使用这个方法来访问云上 Kubernetes 集群的 Pod IP 和 Service IP。&lt;/strong>&lt;/p>
&lt;p>假设你的家庭内网有一台 Linux 主机（比如 OpenWrt）安装了 Tailscale 客户端，我们希望其他 Tailscale 客户端可以直接通过家中的局域网 IP（例如 &lt;strong>192.168.100.0/24&lt;/strong>） 访问家庭内网的任何一台设备。&lt;/p>
&lt;p>配置方法很简单，首先需要设置 IPv4 与 IPv6 路由转发：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>tee /etc/sysctl.d/ipforwarding.conf &amp;gt; /dev/null &lt;span style="color:#e6db74">&amp;lt;&amp;lt;EOF
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">net.ipv4.ip_forward = 1
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">net.ipv6.conf.all.forwarding = 1
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">EOF&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>sysctl -p /etc/sysctl.d/ipforwarding.conf
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>客户端修改注册节点的命令，在原来命令的基础上加上参数 &lt;code>--advertise-routes=192.168.100.0/24&lt;/code>。&lt;/p>
&lt;ul>
&lt;li>多个 CIDR 以 &lt;code>,&lt;/code> 分割&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>tailscale up --login-server&lt;span style="color:#f92672">=&lt;/span>http://&lt;span style="color:#e6db74">${&lt;/span>HeadscaleIP&lt;span style="color:#e6db74">}&lt;/span>:8080 --accept-routes&lt;span style="color:#f92672">=&lt;/span>true --accept-dns&lt;span style="color:#f92672">=&lt;/span>false --advertise-routes&lt;span style="color:#f92672">=&lt;/span>172.38.40.0/24,192.168.88.0/24
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>在 Headscale 端查看路由，可以看到相关路由是关闭的。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>~&lt;span style="color:#f92672">]&lt;/span>&lt;span style="color:#75715e"># headscale nodes list&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>ID | Name | NodeKey | Namespace | IP addresses | Ephemeral | Last seen | Online | Expired
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">1&lt;/span> | tj-test-oc-lichenhao | &lt;span style="color:#f92672">[&lt;/span>Bo2d3&lt;span style="color:#f92672">]&lt;/span> | lichenhao | fd7a:115c:a1e0::1, 100.64.0.1 | false | 2022-03-24 05:08:46 | online | no
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">2&lt;/span> | home-desktop | &lt;span style="color:#f92672">[&lt;/span>qZVTo&lt;span style="color:#f92672">]&lt;/span> | lichenhao | fd7a:115c:a1e0::2, 100.64.0.2 | false | 2022-03-24 05:09:16 | online | no
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>~&lt;span style="color:#f92672">]&lt;/span>&lt;span style="color:#75715e"># headscale routes list -i 1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Route | Enabled
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>172.38.40.0/24 | false
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>192.168.88.0/24 | false
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>开启路由：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>~&lt;span style="color:#f92672">]&lt;/span>&lt;span style="color:#75715e"># headscale routes enable -i 1 -r &amp;#34;172.38.40.0/24,192.168.88.0/24&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Route | Enabled
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>172.38.40.0/24 | true
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>192.168.88.0/24 | true
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>其他非 Headscale 节点查看路由结果：
&lt;code>$ ip route show table 52|grep &amp;quot;172.38.40.0/24&amp;quot; 172.38.40.0/24 dev tailscale0&lt;/code>&lt;/p>
&lt;h1 id="总结">总结&lt;/h1>
&lt;p>目前从稳定性来看，Tailscale 比 Netmaker 略胜一筹，基本上不会像 Netmaker 一样时不时出现 ping 不通的情况，这取决于 Tailscale 在用户态对 NAT 穿透所做的种种优化，他们还专门写了一篇文章介绍 NAT 穿透的原理[13]，中文版[14]由国内的 eBPF 大佬赵亚楠翻译，墙裂推荐大家阅读。放一张图给大家感受一下：
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/af37c7a5-9f8e-4905-a639-0a377cb44ee6/640" alt="">&lt;/p>
&lt;p>本文给大家介绍了 Tailscale 和 Headscale，包括 Headscale 的安装部署和各个平台客户端的接入，以及如何打通各个节点所在的局域网。下篇文章将会给大家介绍如何让 Tailscale 使用自定义的 DERP Servers（也就是中继服务器），See you~~&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/af37c7a5-9f8e-4905-a639-0a377cb44ee6/640" alt="">&lt;/p>
&lt;p>随着云原生对 IT   产业的重新洗牌，很多传统的技术在云原生的场景下已经不再适用，譬如备份和容灾。传统的备份容灾还停留在数据搬运的层次上，备份机制比较固化，以存储为核心，无法适应容器化的弹性、池化部署场景；而云原生的核心是服务本身，不再以存储为核心，用户需要更贴合容器场景的备份容灾能力，利用云原生的编排能力，实现备份容灾的高度自动化，同时灵活运用云原生的弹性能力按需付费，降低成本。&lt;/p>
&lt;p>为了适应云原生场景，众多 Kubernetes 备份容灾产品开始涌现，比如 Veeam 推出的 Kasten K10 以及 VMware 推出的 Velero。青云科技也推出了 Kubernetes 备份容灾即服务产品，基于原生的 Kubernetes API，提供了可视化界面，能够覆盖云原生数据保护的绝大多数重要场景，而且能够跨集群、跨云服务商、跨存储区域，轻松实现基础设施间多地、按需的备份恢复。目前该服务已正式上线，提供了 1TB 的免费托管仓库，感兴趣的可以前往试用 👇‍&lt;/p>
&lt;h1 id="引用链接">引用链接&lt;/h1>
&lt;p>[1]&lt;/p>
&lt;p>全互联模式（full mesh）: &lt;em>&lt;a href="https://fuckcloudnative.io/posts/wireguard-full-mesh/#1-">https://fuckcloudnative.io/posts/wireguard-full-mesh/#1-&lt;/a>全互联模式架构与配置&lt;/em>&lt;/p>
&lt;p>[2]&lt;/p>
&lt;p>Netmaker: &lt;a href="https://fuckcloudnative.io/posts/configure-a-mesh-network-with-netmaker/">&lt;em>https://fuckcloudnative.io/posts/configure-a-mesh-network-with-netmaker/&lt;/em>&lt;/a>&lt;/p>
&lt;p>[3]&lt;/p>
&lt;p>GitHub 仓库: &lt;a href="https://github.com/tailscale/">&lt;em>https://github.com/tailscale/&lt;/em>&lt;/a>&lt;/p>
&lt;p>[4]&lt;/p>
&lt;p>Headscale: &lt;a href="https://github.com/juanfont/headscale">&lt;em>https://github.com/juanfont/headscale&lt;/em>&lt;/a>&lt;/p>
&lt;p>[6]&lt;/p>
&lt;p>Windows 客户端文档: &lt;a href="https://github.com/juanfont/headscale/blob/main/docs/windows-client.md">&lt;em>https://github.com/juanfont/headscale/blob/main/docs/windows-client.md&lt;/em>&lt;/a>&lt;/p>
&lt;p>[7]&lt;/p>
&lt;p>需要自己编译客户端: &lt;a href="https://github.com/juanfont/headscale/issues/58#issuecomment-950386833">&lt;em>https://github.com/juanfont/headscale/issues/58#issuecomment-950386833&lt;/em>&lt;/a>&lt;/p>
&lt;p>[9]&lt;/p>
&lt;p>这个 issue: &lt;a href="https://github.com/juanfont/headscale/issues/58#issuecomment-950386833">&lt;em>https://github.com/juanfont/headscale/issues/58#issuecomment-950386833&lt;/em>&lt;/a>&lt;/p>
&lt;p>[10]&lt;/p>
&lt;p>tailscale-android: &lt;a href="https://github.com/yangchuansheng/tailscale-android">&lt;em>https://github.com/yangchuansheng/tailscale-android&lt;/em>&lt;/a>&lt;/p>
&lt;p>[11]&lt;/p>
&lt;p>Pull: &lt;a href="https://github.com/apps/pull">&lt;em>https://github.com/apps/pull&lt;/em>&lt;/a>&lt;/p>
&lt;p>[12]&lt;/p>
&lt;p>Pull App: &lt;a href="https://github.com/apps/pull">&lt;em>https://github.com/apps/pull&lt;/em>&lt;/a>&lt;/p>
&lt;p>[13]&lt;/p>
&lt;p>NAT 穿透的原理: &lt;a href="https://tailscale.com/blog/how-nat-traversal-works/">&lt;em>https://tailscale.com/blog/how-nat-traversal-works/&lt;/em>&lt;/a>&lt;/p>
&lt;p>[14]&lt;/p>
&lt;p>中文版: &lt;a href="https://arthurchiao.art/blog/how-nat-traversal-works-zh/">&lt;em>https://arthurchiao.art/blog/how-nat-traversal-works-zh/&lt;/em>&lt;/a>&lt;/p></description></item><item><title>Docs: HTTP Header</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/4.%E6%95%B0%E6%8D%AE%E9%80%9A%E4%BF%A1/%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/7.http/http-header/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/4.%E6%95%B0%E6%8D%AE%E9%80%9A%E4%BF%A1/%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/7.http/http-header/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://tools.ietf.org/html/rfc2616#section-4.2">RFC 2616-Message Headers&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://tools.ietf.org/html/rfc7231#section-5">RFC 7231,第五章-请求头字段&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://datatracker.ietf.org/doc/html/rfc7231#section-7">RFC 7231,第七章-响应头字段&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/List_of_HTTP_header_fields">Wiki,List of HTTP header fields&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers">Mozilla 官方文档&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>一般情况下，在浏览器按 F12 后查看到的首部大部分都是请求和响应首部,这俩首部的信息通常包含了通用首部中的信息
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/rzfx0t/1616161207830-cf569808-255f-4e34-9f02-d7da892c9170.jpeg" alt="">
HTTP 请求和响应报文的 Header(头) 基本都是 Key/Value Pair(键/值对) 格式的 &lt;strong>Field(字段)&lt;/strong>，每个字段都是以冒号分割的 &lt;strong>键/值对&lt;/strong>。此外，除了标准的 Header 字段之外，还可以添加自定义 Header，这就给 HTTP 带来了无限的扩展可能。注意，&lt;strong>Key 不区分大小写&lt;/strong>。&lt;/p>
&lt;p>自定义 Header 历来以 &lt;code>X-&lt;/code> 开头，但是该约定在 2012 年 6 月被弃用，因为它在非标准字段成为标准字段时会造成不必要的麻烦，详见 &lt;a href="https://datatracker.ietf.org/doc/html/rfc6648">RFC 6648&lt;/a>。IANA 维护了一个通用的 &lt;a href="https://www.iana.org/assignments/message-headers/message-headers.xhtml">&lt;strong>HTTP Header 列表&lt;/strong>&lt;/a>，其中包括 RFC 中定义的标准头以及不在 RFC 中定义的扩展头；并且在同一个页面还有新的提议增加的 HTTP Header 列表。&lt;/p>
&lt;p>HTTP (RFC 2616 版本)规定了非常多的 Header 字段，可以实现各种各样的功能，但基本上可以分为以下四类&lt;/p>
&lt;ol>
&lt;li>&lt;strong>General Header(通用头)&lt;/strong> # 在请求头和响应头里都可以出现；&lt;/li>
&lt;li>&lt;strong>Request Header(请求头)&lt;/strong> # 仅能出现在请求头里，进一步说明请求信息或者额外的附加条件；&lt;/li>
&lt;li>&lt;strong>Response Header(响应头)&lt;/strong> # 仅能出现在响应头里，补充说明响应报文的信息；&lt;/li>
&lt;li>&lt;strong>Entity Header(实体头)&lt;/strong> # 它实际上属于通用字段，但专门描述 body 的额外信息。&lt;/li>
&lt;li>&lt;strong>Extension Header(扩展头)&lt;/strong> # 不在标准规范中，可以通过自定义头实现更多定制化需求的 Header 信息。&lt;/li>
&lt;/ol>
&lt;p>&lt;strong>对 HTTP 报文的解析和处理其实本质上就是对头字段的处理&lt;/strong>，HTTP 的连接管理，缓存控制，内容协商等都是通过头字段来处理的，&lt;strong>理解了头字段，基本上也就理解了 HTTP&lt;/strong>，所以理解头字段非常重要。&lt;/p>
&lt;h2 id="新版-http-header-规范">新版 HTTP Header 规范&lt;/h2>
&lt;p>注意：上面描述分类是在 RFC 2616 标准中定义的，在新的 RFC 7231 中，已经看不到这种分类了，仅仅简单得分为请求头和响应头&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://tools.ietf.org/html/rfc7231#section-5">Request Header(请求头)&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://tools.ietf.org/html/rfc7231#section-7">Response Header(响应头)&lt;/a>&lt;/li>
&lt;/ul>
&lt;p>而这两类头字段下，又有各自的子分类&lt;/p>
&lt;p>在 2014 年之后的新版规范中，并非所有出现在请求中的 Header 都称为请求头，比如 Content-Length，在 RFC 2616 中称为 Entity Header(实体头)，而在新版规范中，称之为元数据。这也为 HTTP 2.0 的 &lt;a href="https://desistdaydream.github.io/docs/IT%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/4.%E6%95%B0%E6%8D%AE%E9%80%9A%E4%BF%A1/%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/7.HTTP/HTTP2.md">Header 压缩&lt;/a> 打下了基础&lt;/p>
&lt;h1 id="request-header请求头">Request Header(请求头)&lt;/h1>
&lt;p>Request Header(请求头) 主要是在每个 HTTP 的请求中指定。包含要获取的资源或请求某个资源的客户端本身的信息，以便服务端可以根据这些内容，来定制响应。&lt;/p>
&lt;p>Request Header 中，将各种 Header 分为多个类别&lt;/p>
&lt;ul>
&lt;li>Controls # 控制本次 HTTP 请求的行为&lt;/li>
&lt;li>Conditionals # 条件相关 Header&lt;/li>
&lt;li>Content Negotiation # 内容协商相关 Header&lt;/li>
&lt;li>Authentication Credentials # 认证相关的 Header&lt;/li>
&lt;li>Request Context # 请求上下文&lt;/li>
&lt;/ul>
&lt;h2 id="controls控制">Controls(控制)&lt;/h2>
&lt;p>Controls 类型的请求头用来指定客户端如何处理本次 HTTP 请求。
&lt;strong>Cache-Control&lt;/strong> # 缓存控制
&lt;strong>Expect&lt;/strong> # 期待服务器的特定行为
&lt;strong>Host&lt;/strong> # 请求资源所在服务器。客户端指定自己想访问的服务器的 &lt;code>域名&lt;/code> 或者 &lt;code>IP:PORT&lt;/code>。例如：&lt;code>Host：www.baidu.com&lt;/code>&lt;/p>
&lt;ul>
&lt;li>Note：输入的什么网址，请求的就是什么，输入域名就是域名，输入 IP 就是 IP&lt;/li>
&lt;li>Note：当服务器接到这个请求时，如果自身无法处理 ip 或者无法处理域名，则该请求就会丢弃(比如 k8s 的 ingress)。所以在测试的时候一般使用 curl 命令请求 IP 时加上 -H 参数以自己制定 URL 内容即可，否则如果服务器不处理 IP 的话，就会返回 404&lt;/li>
&lt;/ul>
&lt;p>**Max-Forwards **# 最大传输逐跳数
&lt;strong>Pragma&lt;/strong> #
&lt;strong>Range&lt;/strong> # 实体的字节范围请求
**TE **# 传输编码的优先级&lt;/p>
&lt;h2 id="conditionals条件">Conditionals(条件)&lt;/h2>
&lt;p>&lt;strong>If-Match&lt;/strong> # 比较实体标记(ETag)
&lt;strong>If-None-Match&lt;/strong> # 比较实体标记(与 If-Match 相反)
&lt;strong>If-Modified-Since&lt;/strong> # 比较资源的更新时间
**If-Unmodified-Since **# 比较资源的更新时间(与 If-Modified-Since 相反)
**If-Range **# 资源未更新时发送实体 Byte 的范围请求&lt;/p>
&lt;h2 id="content-negotiation内容协商">Content Negotiation(内容协商)&lt;/h2>
&lt;p>&lt;strong>Accept&lt;/strong> # 用户代理可处理的媒体类型
&lt;strong>Accept-[ Charset | Encoding | Language]&lt;/strong> # 通知 server 自己可接收的媒体类型[字符集|编码格式|语言]&lt;/p>
&lt;h2 id="authentication-credentials认证">Authentication Credentials(认证)&lt;/h2>
&lt;p>&lt;strong>Authorization&lt;/strong> # Web 认证信息。IANA 维护了一个&lt;a href="https://www.iana.org/assignments/http-authschemes/http-authschemes.xhtml">身份验证方案的列表&lt;/a>&lt;/p>
&lt;ul>
&lt;li>&lt;strong>Basic&lt;/strong> # 基本认证。就是用户名和密码。如果用户名和密码为 &lt;code>admin/admin1234&lt;/code> 的话，该字段应该是这样的：
&lt;ul>
&lt;li>&lt;code>Authorization: Basic YWRtaW46YWRtaW4xMjM0&lt;/code>&lt;/li>
&lt;li>也就是说，用户名和密码是 &lt;code>admin:admin1234&lt;/code> 这样的 base64 编码后的格式&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>Bearer&lt;/strong> # 不记名令牌。&lt;/li>
&lt;li>&amp;hellip;&amp;hellip;&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>Proxy-Authorization&lt;/strong> # 代理服务器要求客户端的认证信息&lt;/p>
&lt;h2 id="request-context">Request Context&lt;/h2>
&lt;p>&lt;strong>From&lt;/strong> # 用户的电子邮箱地址
&lt;strong>Referer&lt;/strong> # 对请求中 URI 的原始获取方
&lt;strong>User-Agent&lt;/strong> # HTTP 客户端程序的信息&lt;/p>
&lt;h1 id="response-header响应头">Response Header(响应头)&lt;/h1>
&lt;p>包含有关响应的补充信息，如其位置或服务器本身(名称和版本等)的消息头。&lt;/p>
&lt;p>Response Header 中，将各种 Header 分为多个类别：&lt;/p>
&lt;ul>
&lt;li>Control Data&lt;/li>
&lt;li>Validator Header Fields&lt;/li>
&lt;li>Authentication Challenges&lt;/li>
&lt;li>Response Context&lt;/li>
&lt;/ul>
&lt;h2 id="control-data控制数据">Control Data(控制数据)&lt;/h2>
&lt;p>控制服务端如何处理 HTTP 响应
Age # 推算资源创建经过时间
Cache-Control #
Expires #
Data #
Location #
Retry-After #
Vary #
Warning #&lt;/p>
&lt;h2 id="validator-header-fields验证器头字段">Validator Header Fields(验证器头字段)&lt;/h2>
&lt;p>&lt;strong>ETag&lt;/strong> # 资源的匹配信息
&lt;strong>Last-Modified&lt;/strong> # 最后一次修改时间&lt;/p>
&lt;h2 id="authentication-challenges">Authentication Challenges&lt;/h2>
&lt;p>&lt;strong>WWW-Authenticate&lt;/strong> # 服务器对客户端的认证信息
&lt;strong>Proxy-Authorization&lt;/strong> # 代理服务器要求客户端的认证信息&lt;/p>
&lt;h2 id="response-context">Response Context&lt;/h2>
&lt;p>&lt;strong>Accept-Ranges&lt;/strong> # 是否接受字节范围请求
&lt;strong>Allow&lt;/strong> #
**Server **# HTTP 服务器的安装信息&lt;/p>
&lt;h1 id="extension-header扩展头">&lt;strong>Extension Header(扩展头)&lt;/strong>&lt;/h1>
&lt;p>通常情况下，一个 web 界面有 N 多个资源，比如 index.html 首页是一个资源，首页中有各种 img，css，js 等静态或动态资源，当用户访问一个网站后，除了要请求主页资源，还需要再请求主页上各个图片，板式，功能等资源，每一个资源都有一个单独的报文。也就说有可能每一类资源都可以单独存在在一个相对应的集群服务器群中，比如通过一个图片的 URL，可以直接访问该图片，而不用在网站主页才能看到；而这些资源都需要前端负载均衡器来进行调度用户请求到相应的服务器中去拿去资源，这时候 LB 的压力会非常大，为了解决这种问题，人们就可以根据自己的协商，定义一些标准之外的 Header。&lt;/p>
&lt;h1 id="老版本的两个-header-笔记">老版本的两个 Header 笔记&lt;/h1>
&lt;h2 id="general-header通用头">General Header(通用头)&lt;/h2>
&lt;p>同时适用于请求和响应消息，但与最终消息主体中传输的数据无关的消息头。
&lt;strong>Cache-Control&lt;/strong> # 控制缓存的行为&lt;/p>
&lt;ul>
&lt;li>no-cache：不缓存&lt;/li>
&lt;li>max-age：缓存最大保留时间&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>Connection&lt;/strong> # 逐跳首部、连接的管理。连接状态。HTTP/2 中不在支持该 Header&lt;/p>
&lt;ul>
&lt;li>keepalive(长连接)：需要实时更新的网络资源，比如网络游戏，具体点就是网页上的游戏，需要实时连接，如果游戏中每一步操作都要进行 TCP 建连，然后各种请求和响应，那么用户体验会非常不好，也会极大得消耗网络带宽，所以需要使用类似 keepalive 这种长连接&lt;/li>
&lt;li>close(短连接)：不需要实时更新的网络资源，当浏览静态网页资源的时候，当把整个网页发送给用户之后即可关闭连接，因为网页资源已经发送到 Client 本地，不需要实时更新了&lt;/li>
&lt;/ul>
&lt;p>**Date **# 创建报文的日期时间
**Pragma **# 报文指令
**Trailer **# 报文末端的首部一览
**Transfer-Encoding **# 指定报文主体的传输编码方式
**Upgrade **# 升级为其他协议
**Via **# 报文经过的中间节点。也就是代理服务器的相关信息。
&lt;strong>Warning&lt;/strong> # 错误通知&lt;/p>
&lt;h2 id="entity-header实体头">Entity Header(实体头)&lt;/h2>
&lt;p>包含有关实体主体的更多信息，比如主体长(Content-Length)度或其 MIME 类型。
Allow：列出对此实体可使用的请求方法
Location：告诉 client 真正的实体位于何处
Content-
缓存相关&lt;/p>
&lt;ol>
&lt;li>ETag # 实体扩展标签&lt;/li>
&lt;li>Expires # 实体过期时间&lt;/li>
&lt;li>Last-Modified # 最后一次修改时间&lt;/li>
&lt;/ol>
&lt;p>**Content-Length **# 实体主体的大小(单位 :字节)&lt;/p></description></item><item><title>Docs: HTTP Status Codes</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/4.%E6%95%B0%E6%8D%AE%E9%80%9A%E4%BF%A1/%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/7.http/http-status-codes/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/4.%E6%95%B0%E6%8D%AE%E9%80%9A%E4%BF%A1/%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/7.http/http-status-codes/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://datatracker.ietf.org/doc/html/rfc7231#section-6">RFC 7231,第六章-响应状态码&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;h1 id="http-的-status-状态码和-reason-phrase-原因短语">HTTP 的 Status 状态码和 Reason-Phrase 原因短语&lt;/h1>
&lt;p>常用 200,301,302,304,401,403,404,500,502&lt;/p>
&lt;h2 id="http-常见的状态码">HTTP 常见的状态码&lt;/h2>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/ytigiz/1616161194550-be1a091b-4d94-4180-97cb-9a54f082ca47.png" alt="">&lt;/p>
&lt;h2 id="五大类-http-状态码">五大类 HTTP 状态码&lt;/h2>
&lt;p>&lt;em>1xx&lt;/em>&lt;/p>
&lt;p>&lt;code>1xx&lt;/code> 类状态码属于&lt;strong>提示信息&lt;/strong>，是协议处理中的一种中间状态，实际用到的比较少。&lt;/p>
&lt;p>&lt;em>2xx&lt;/em>&lt;/p>
&lt;p>&lt;code>2xx&lt;/code> 类状态码表示服务器&lt;strong>成功&lt;/strong>处理了客户端的请求，也是我们最愿意看到的状态。&lt;/p>
&lt;p>「&lt;strong>200 OK&lt;/strong>」是最常见的成功状态码，表示一切正常。如果是非 &lt;code>HEAD&lt;/code> 请求，服务器返回的响应头都会有 body 数据。&lt;/p>
&lt;p>「&lt;strong>204 No Content&lt;/strong>」也是常见的成功状态码，与 200 OK 基本相同，但响应头没有 body 数据。&lt;/p>
&lt;p>「&lt;strong>206 Partial Content&lt;/strong>」是应用于 HTTP 分块下载或断点续传，表示响应返回的 body 数据并不是资源的全部，而是其中的一部分，也是服务器处理成功的状态。&lt;/p>
&lt;p>&lt;em>3xx&lt;/em>&lt;/p>
&lt;p>&lt;code>3xx&lt;/code> 类状态码表示客户端请求的资源发送了变动，需要客户端用新的 URL 重新发送请求获取资源，也就是&lt;strong>重定向&lt;/strong>。&lt;/p>
&lt;p>「&lt;strong>301 Moved Permanently&lt;/strong>」表示永久重定向，说明请求的资源已经不存在了，需改用新的 URL 再次访问。&lt;/p>
&lt;p>「&lt;strong>302 Found&lt;/strong>」表示临时重定向，说明请求的资源还在，但暂时需要用另一个 URL 来访问。&lt;/p>
&lt;p>301 和 302 都会在响应头里使用字段 &lt;code>Location&lt;/code>，指明后续要跳转的 URL，浏览器会自动重定向新的 URL。&lt;/p>
&lt;p>「&lt;strong>304 Not Modified&lt;/strong>」不具有跳转的含义，表示资源未修改，重定向已存在的缓冲文件，也称缓存重定向，用于缓存控制。&lt;/p>
&lt;p>&lt;em>4xx&lt;/em>&lt;/p>
&lt;p>&lt;code>4xx&lt;/code> 类状态码表示客户端发送的&lt;strong>报文有误&lt;/strong>，服务器无法处理，也就是错误码的含义。&lt;/p>
&lt;p>「&lt;strong>400 Bad Request&lt;/strong>」表示客户端请求的报文有错误，但只是个笼统的错误。&lt;/p>
&lt;p>「&lt;strong>403 Forbidden&lt;/strong>」表示服务器禁止访问资源，并不是客户端的请求出错。&lt;/p>
&lt;p>「&lt;strong>404 Not Found&lt;/strong>」表示请求的资源在服务器上不存在或未找到，所以无法提供给客户端。&lt;/p>
&lt;p>&lt;em>5xx&lt;/em>&lt;/p>
&lt;p>&lt;code>5xx&lt;/code> 类状态码表示客户端请求报文正确，但是&lt;strong>服务器处理时内部发生了错误&lt;/strong>，属于服务器端的错误码。&lt;/p>
&lt;p>「&lt;strong>500 Internal Server Error&lt;/strong>」与 400 类型，是个笼统通用的错误码，服务器发生了什么错误，我们并不知道。&lt;/p>
&lt;p>「&lt;strong>501 Not Implemented&lt;/strong>」表示客户端请求的功能还不支持，类似“即将开业，敬请期待”的意思。&lt;/p>
&lt;p>「&lt;strong>502 Bad Gateway&lt;/strong>」通常是服务器作为网关或代理时返回的错误码，表示服务器自身工作正常，访问后端服务器发生了错误。&lt;/p>
&lt;p>「&lt;strong>503 Service Unavailable&lt;/strong>」表示服务器当前很忙，暂时无法响应服务器，类似“网络服务正忙，请稍后重试”的意思。&lt;/p>
&lt;h1 id="状态码">状态码&lt;/h1>
&lt;h2 id="消息1xx">消息，1XX&lt;/h2>
&lt;p>这一类型的状态码，代表请求已被接受，需要继续处理。这类响应是临时响应，只包含状态行和某些可选的响应头信息，并以空行结束。由于 HTTP/1.0 协议中没有定义任何 1xx 状态码，所以除非在某些试验条件下，服务器禁止向此类客户端发送 1xx 响应。&lt;/p>
&lt;ul>
&lt;li>100 Continue，客户端应当继续发送请求。这个临时响应是用来通知客户端它的部分请求已经被服务器接收，且仍未被拒绝。客户端应当继续发送请求的剩余部分，或者如果请求已经完成，忽略这个响应。服务器必须在请求完成后向客户端发送一个最终响应。&lt;/li>
&lt;li>101 Switching Protocols，服务器已经理解了客户端的请求，并将通过 Upgrade 消息头通知客户端采用不同的协议来完成这个请求。在发送完这个响应最后的空行后，服务器将会切换到在 Upgrade 消息头中定义的那些协议。只有在切换新的协议更有好处的时候才应该采取类似措施。例如，切换到新的 HTTP 版本比旧版本更有优势，或者切换到一个实时且同步的协议以传送利用此类特性的资源。&lt;/li>
&lt;/ul>
&lt;h2 id="成功2xx200-206">成功，2XX，（200-206）&lt;/h2>
&lt;p>这一类型的状态码，代表请求已成功被服务器接收、理解、并接受&lt;/p>
&lt;ul>
&lt;li>200 OK，请求已成功，请求的所有数据通过响应报文的 Entity-Body 这一部分发送&lt;/li>
&lt;li>201 Created，请求已经被实现，而且有一个新的资源已经依据请求的需要而建立，且其 URI 已经随 Location 头信息返回。假如需要的资源无法及时建立的话，应当返回 &amp;lsquo;202 Accepted&amp;rsquo;。&lt;/li>
&lt;li>202 Accepted，服务器已接受请求，但尚未处理。正如它可能被拒绝一样，最终该请求可能会也可能不会被执行。在异步操作的场合下，没有比发送这个状态码更方便的做法了。返回 202 状态码的响应的目的是允许服务器接受其他过程的请求（例如某个每天只执行一次的基于批处理的操作），而不必让客户端一直保持与服务器的连接直到批处理操作全部完成。在接受请求处理并返回 202 状态码的响应应当在返回的实体中包含一些指示处理当前状态的信息，以及指向处理状态监视器或状态预测的指针，以便用户能够估计操作是否已经完成。&lt;/li>
&lt;li>203 Non-Authoritative Information，服务器已成功处理了请求，但返回的实体头部元信息不是在原始服务器上有效的确定集合，而是来自本地或者第三方的拷贝。当前的信息可能是原始版本的子集或者超集。例如，包含资源的元数据可能导致原始服务器知道元信息的超集。使用此状态码不是必须的，而且只有在响应不使用此状态码便会返回 200 OK 的情况下才是合适的。&lt;/li>
&lt;li>204 No Content，服务器成功处理了请求，但不需要返回任何实体内容，并且希望返回更新了的元信息。响应可能通过实体头部的形式，返回新的或更新后的元信息。如果存在这些头部信息，则应当与所请求的变量相呼应。如果客户端是浏览器的话，那么用户浏览器应保留发送了该请求的页面，而不产生任何文档视图上的变化，即使按照规范新的或更新后的元信息应当被应用到用户浏览器活动视图中的文档。由于 204 响应被禁止包含任何消息体，因此它始终以消息头后的第一个空行结尾。&lt;/li>
&lt;li>205 Reset Content，服务器成功处理了请求，且没有返回任何内容。但是与 204 响应不同，返回此状态码的响应要求请求者重置文档视图。该响应主要是被用于接受用户输入后，立即重置表单，以便用户能够轻松地开始另一次输入。&lt;/li>
&lt;li>与 204 响应一样，该响应也被禁止包含任何消息体，且以消息头后的第一个空行结束。&lt;/li>
&lt;li>206 Partial Content，服务器已经成功处理了部分 GET 请求。类似于 FlashGet 或者迅雷这类的 HTTP 下载工具都是使用此类响应实现断点续传或者将一个大文档分解为多个下载段同时下载。该请求必须包含 Range 头信息来指示客户端希望得到的内容范围，并且可能包含 If-Range 来作为请求条件。
&lt;ul>
&lt;li>响应必须包含如下的头部域：&lt;/li>
&lt;li>Content-Range 用以指示本次响应中返回的内容的范围；如果是 Content-Type 为 multipart/byteranges 的多段下载，则每一 multipart 段中都应包含 Content-Range 域用以指示本段的内容范围。假如响应中包含 Content-Length，那么它的数值必须匹配它返回的内容范围的真实字节数。&lt;/li>
&lt;li>Date&lt;/li>
&lt;li>ETag 和/或 Content-Location，假如同样的请求本应该返回 200 响应。&lt;/li>
&lt;li>Expires, Cache-Control，和/或 Vary，假如其值可能与之前相同变量的其他响应对应的值不同的话。&lt;/li>
&lt;li>假如本响应请求使用了 If-Range 强缓存验证，那么本次响应不应该包含其他实体头；假如本响应的请求使用了 If-Range 弱缓存验证，那么本次响应禁止包含其他实体头；这避免了缓存的实体内容和更新了的实体头信息之间的不一致。否则，本响应就应当包含所有本应该返回 200 响应中应当返回的所有实体头部域。&lt;/li>
&lt;li>假如 ETag 或 Last-Modified 头部不能精确匹配的话，则客户端缓存应禁止将 206 响应返回的内容与之前任何缓存过的内容组合在一起。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>207 Multi-Status，由 WebDAV(RFC 2518)扩展的状态码，代表之后的消息体将是一个 XML 消息，并且可能依照之前子请求数量的不同，包含一系列独立的响应代码。&lt;/li>
&lt;/ul>
&lt;h2 id="重定向3xx300-305">重定向，3XX（300-305）&lt;/h2>
&lt;p>这类状态码代表需要客户端采取进一步的操作才能完成请求。通常，这些状态码用来重定向，后续的请求地址（重定向目标）在本次响应的 Location 域中指明。当且仅当后续的请求所使用的方法是 GET 或者 HEAD 时，用户浏览器才可以在没有用户介入的情况下自动提交所需要的后续请求。客户端应当自动监测无限循环重定向（例如：A-&amp;gt;A，或者 A-&amp;gt;B-&amp;gt;C-&amp;gt;A），因为这会导致服务器和客户端大量不必要的资源消耗。按照 HTTP/1.0 版规范的建议，浏览器不应自动访问超过 5 次的重定向。&lt;/p>
&lt;ul>
&lt;li>300 Multiple Choices，被请求的资源有一系列可供选择的回馈信息，每个都有自己特定的地址和浏览器驱动的商议信息。用户或浏览器能够自行选择一个首选的地址进行重定向。除非这是一个 HEAD 请求，否则该响应应当包括一个资源特性及地址的列表的实体，以便用户或浏览器从中选择最合适的重定向地址。这个实体的格式由 Content-Type 定义的格式所决定。浏览器可能根据响应的格式以及浏览器自身能力，自动作出最合适的选择。当然，RFC 2616 规范并没有规定这样的自动选择该如何进行。如果服务器本身已经有了首选的回馈选择，那么在 Location(位置)中应当指明这个回馈的 URL；浏览器可能会将这个 Location 值作为自动重定向的地址。此外，除非额外指定，否则这个响应也是可缓存的。&lt;/li>
&lt;li>301 Moved Permanently，永久重定向被请求的资源已永久移动到新位置，并且将来任何对此资源的引用都应该使用本响应返回的若干个 URL 之一。如果可能，拥有链接编辑功能的客户端应当自动把请求的地址修改为从服务器反馈回来的地址。除非额外指定，否则这个响应也是可缓存的。新的永久性的 URL 应当在响应的 Location 域中返回。除非这是一个 HEAD 请求，否则响应的实体中应当包含指向新的 URI 的超链接及简短说明。如果这不是一个 GET 或者 HEAD 请求，因此浏览器禁止自动进行重定向，除非得到用户的确认，因为请求的条件可能因此发生变化。
&lt;ul>
&lt;li>注意：对于某些使用 HTTP/1.0 协议的浏览器，当它们发送的 POST 请求得到了一个 301 响应的话，接下来的重定向请求将会变成 GET 方式。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>302 Move temporarily，临时重定向请求的资源临时从不同的 URL 响应请求。由于这样的重定向是临时的，客户端应当继续向原有地址发送以后的请求。只有在 Cache-Control 或 Expires 中进行了指定的情况下，这个响应才是可缓存的。如果这不是一个 GET 或者 HEAD 请求，那么浏览器禁止自动进行重定向，除非得到用户的确认，因为请求的条件可能因此发生变化。&lt;/li>
&lt;li>303 See Other，对应当前请求的响应可以在另一个 URI 上被找到，而且客户端应当采用 GET 的方式访问那个资源。这个方法的存在主要是为了允许由脚本激活的 POST 请求输出重定向到一个新的资源。这个新的 URI 不是原始资源的替代引用。同时，303 响应禁止被缓存。当然，第二个请求（重定向）可能被缓存。&lt;/li>
&lt;li>304 Not Modified，缓存没被修改，client 发出条件式请求，但 server 上的资源未曾发生改变（比如本地有缓存，client 就发出条件请求，向 server 确认该缓存是否有更新）如果客户端发送了一个带条件的 GET 请求且该请求已被允许，而文档的内容（自上次访问以来或者根据请求的条件）并没有改变，则服务器应当返回这个状态码。304 响应禁止包含消息体，因此始终以消息头后的第一个空行结尾。
&lt;ul>
&lt;li>该响应必须包含以下的头信息：
&lt;ul>
&lt;li>Date，除非这个服务器没有时钟。假如没有时钟的服务器也遵守这些规则，那么代理服务器以及客户端可以自行将 Date 字段添加到接收到的响应头中去，缓存机制将会正常工作。&lt;/li>
&lt;li>ETag 和/或 Content-Location，假如同样的请求本应返回 200 响应。&lt;/li>
&lt;li>Expires, Cache-Control，和/或 Vary，假如其值可能与之前相同变量的其他响应对应的值不同的话。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>假如本响应请求使用了强缓存验证，那么本次响应不应该包含其他实体头；否则（例如，某个带条件的 GET 请求使用了弱缓存验证），本次响应禁止包含其他实体头；这避免了缓存了的实体内容和更新了的实体头信息之间的不一致。&lt;/li>
&lt;li>假如某个 304 响应指明了当前某个实体没有缓存，那么缓存系统必须忽视这个响应，并且重复发送不包含限制条件的请求。&lt;/li>
&lt;li>假如接收到一个要求更新某个缓存条目的 304 响应，那么缓存系统必须更新整个条目以反映所有在响应中被更新的字段的值。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>305 Use Proxy，被请求的资源必须通过指定的代理才能被访问。Location 域中将给出指定的代理所在的 URI 信息，接收者需要重复发送一个单独的请求，通过这个代理才能访问相应资源。只有原始服务器才能建立 305 响应。&lt;/li>
&lt;li>306 Switch Proxy，在最新版的规范中，306 状态码已经不再被使用。&lt;/li>
&lt;li>307 Temporary Redirect，请求的资源临时从不同的 URI 响应请求。新的临时性的 URI 应当在响应的 Location 域中返回。除非这是一个 HEAD 请求，否则响应的实体中应当包含指向新的 URI 的超链接及简短说明。因为部分浏览器不能识别 307 响应，因此需要添加上述必要信息以便用户能够理解并向新的 URI 发出访问请求。如果这不是一个 GET 或者 HEAD 请求，那么浏览器禁止自动进行重定向，除非得到用户的确认，因为请求的条件可能因此发生变化。&lt;/li>
&lt;/ul>
&lt;h2 id="client-错误4xx400-415">client 错误，4XX（400-415）&lt;/h2>
&lt;p>这类的状态码代表了客户端看起来可能发生了错误，妨碍了服务器的处理。除非响应的是一个 HEAD 请求，否则服务器就应该返回一个解释当前错误状况的实体，以及这是临时的还是永久性的状况。这些状态码适用于任何请求方法。浏览器应当向用户显示任何包含在此类错误响应中的实体内容。&lt;/p>
&lt;p>如果错误发生时客户端正在传送数据，那么使用 TCP 的服务器实现应当仔细确保在关闭客户端与服务器之间的连接之前，客户端已经收到了包含错误信息的数据包。如果客户端在收到错误信息后继续向服务器发送数据，服务器的 TCP 栈将向客户端发送一个重置数据包，以清除该客户端所有还未识别的输入缓冲，以免这些数据被服务器上的应用程序读取并干扰后者。&lt;/p>
&lt;ul>
&lt;li>400 Bad Request
&lt;ul>
&lt;li>语义有误，当前请求无法被服务器理解。除非进行修改，否则客户端不应该重复提交这个请求。&lt;/li>
&lt;li>请求参数有误。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>401 Unauthorized，当前请求需要用户验证。该响应必须包含一个适用于被请求资源的 WWW-Authenticate 信息头用以询问用户信息。客户端可以重复提交一个包含恰当的 Authorization 头信息的请求。如果当前请求已经包含了 Authorization 证书，那么 401 响应代表着服务器验证已经拒绝了那些证书。如果 401 响应包含了与前一个响应相同的身份验证询问，且浏览器已经至少尝试了一次验证，那么浏览器应当向用户展示响应中包含的实体信息，因为这个实体信息中可能包含了相关诊断信息。参见 RFC 2617。&lt;/li>
&lt;li>402 Payment Required，该状态码是为了将来可能的需求而预留的。&lt;/li>
&lt;li>403 Forbidden，请求被禁止，服务器已经理解请求，但是拒绝执行它。与 401 响应不同的是，身份验证并不能提供任何帮助，而且这个请求也不应该被重复提交。如果这不是一个 HEAD 请求，而且服务器希望能够讲清楚为何请求不能被执行，那么就应该在实体内描述拒绝的原因。当然服务器也可以返回一个 404 响应，假如它不希望让客户端获得任何信息。&lt;/li>
&lt;li>404 Not Found，server 无法找到 client 请求的 resource。没有信息能够告诉用户这个状况到底是暂时的还是永久的。假如服务器知道情况的话，应当使用 410 状态码来告知旧资源因为某些内部的配置机制问题，已经永久的不可用，而且没有任何可以跳转的地址。404 这个状态码被广泛应用于当服务器不想揭示到底为何请求被拒绝或者没有其他适合的响应可用的情况下。出现这个错误的最有可能的原因是服务器端没有这个页面。&lt;/li>
&lt;li>405 Method Not Allowed，请求行中指定的请求方法不能被用于请求相应的资源。该响应必须返回一个 Allow 头信息用以表示出当前资源能够接受的请求方法的列表。鉴于 PUT，DELETE 方法会对服务器上的资源进行写操作，因而绝大部分的网页服务器都不支持或者在默认配置下不允许上述请求方法，对于此类请求均会返回 405 错误。&lt;/li>
&lt;li>406 Not Acceptable，请求的资源的内容特性无法满足请求头中的条件，因而无法生成响应实体。除非这是一个 HEAD 请求，否则该响应就应当返回一个包含可以让用户或者浏览器从中选择最合适的实体特性以及地址列表的实体。实体的格式由 Content-Type 头中定义的媒体类型决定。浏览器可以根据格式及自身能力自行作出最佳选择。但是，规范中并没有定义任何作出此类自动选择的标准。&lt;/li>
&lt;li>407 Proxy Authentication Required，与 401 响应类似，只不过客户端必须在代理服务器上进行身份验证。代理服务器必须返回一个 Proxy-Authenticate 用以进行身份询问。客户端可以返回一个 Proxy-Authorization 信息头用以验证。参见 RFC 2617。&lt;/li>
&lt;li>408 Request Timeout，请求超时。客户端没有在服务器预备等待的时间内完成一个请求的发送。客户端可以随时再次提交这一请求而无需进行任何更改。&lt;/li>
&lt;li>409 Conflict，由于和被请求的资源的当前状态之间存在冲突，请求无法完成。这个代码只允许用在这样的情况下才能被使用：用户被认为能够解决冲突，并且会重新提交新的请求。该响应应当包含足够的信息以便用户发现冲突的源头。冲突通常发生于对 PUT 请求的处理中。例如，在采用版本检查的环境下，某次 PUT 提交的对特定资源的修改请求所附带的版本信息与之前的某个（第三方）请求向冲突，那么此时服务器就应该返回一个 409 错误，告知用户请求无法完成。此时，响应实体中很可能会包含两个冲突版本之间的差异比较，以便用户重新提交归并以后的新版本。&lt;/li>
&lt;li>410 Gone，被请求的资源在服务器上已经不再可用，而且没有任何已知的转发地址。这样的状况应当被认为是永久性的。如果可能，拥有链接编辑功能的客户端应当在获得用户许可后删除所有指向这个地址的引用。如果服务器不知道或者无法确定这个状况是否是永久的，那么就应该使用 404 状态码。除非额外说明，否则这个响应是可缓存的。410 响应的目的主要是帮助网站管理员维护网站，通知用户该资源已经不再可用，并且服务器拥有者希望所有指向这个资源的远端连接也被删除。这类事件在限时、增值服务中很普遍。同样，410 响应也被用于通知客户端在当前服务器站点上，原本属于某个个人的资源已经不再可用。当然，是否需要把所有永久不可用的资源标记为'410 Gone&amp;rsquo;，以及是否需要保持此标记多长时间，完全取决于服务器拥有者。&lt;/li>
&lt;li>411 Length Required，服务器拒绝在没有定义 Content-Length 头的情况下接受请求。在添加了表明请求消息体长度的有效 Content-Length 头之后，客户端可以再次提交该请求。&lt;/li>
&lt;li>412 Precondition Failed。服务器在验证在请求的头字段中给出先决条件时，没能满足其中的一个或多个。这个状态码允许客户端在获取资源时在请求的元信息（请求头字段数据）中设置先决条件，以此避免该请求方法被应用到其希望的内容以外的资源上。&lt;/li>
&lt;li>413 Request Entity Too Large。服务器拒绝处理当前请求，因为该请求提交的实体数据大小超过了服务器愿意或者能够处理的范围。此种情况下，服务器可以关闭连接以免客户端继续发送此请求。如果这个状况是临时的，服务器应当返回一个 Retry-After 的响应头，以告知客户端可以在多少时间以后重新尝试。&lt;/li>
&lt;li>414 Request-URI Too Long。请求的 URL 长度超过了服务器能够解释的长度，因此服务器拒绝对该请求提供服务。这比较少见，通常的情况包括：
&lt;ul>
&lt;li>本应使用 POST 方法的表单提交变成了 GET 方法，导致查询字符串（Query String）过长。&lt;/li>
&lt;li>重定向 URL “黑洞”，例如每次重定向把旧的 URI 作为新的 URI 的一部分，导致在若干次重定向后 URI 超长。&lt;/li>
&lt;li>客户端正在尝试利用某些服务器中存在的安全漏洞攻击服务器。这类服务器使用固定长度的缓冲读取或操作请求的 URI，当 GET 后的参数超过某个数值后，可能会产生缓冲区溢出，导致任意代码被执行。没有此类漏洞的服务器，应当返回 414 状态码。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>415 Unsupported Media Type。对于当前请求的方法和所请求的资源，请求中提交的实体并不是服务器中所支持的格式，因此请求被拒绝。&lt;/li>
&lt;li>416 Requested Range Not Satisfiable。如果请求中包含了 Range 请求头，并且 Range 中指定的任何数据范围都与当前资源的可用范围不重合，同时请求中又没有定义 If-Range 请求头，那么服务器就应当返回 416 状态码。假如 Range 使用的是字节范围，那么这种情况就是指请求指定的所有数据范围的首字节位置都超过了当前资源的长度。服务器也应当在返回 416 状态码的同时，包含一个 Content-Range 实体头，用以指明当前资源的长度。这个响应也被禁止使用 multipart/byteranges 作为其 Content-Type。&lt;/li>
&lt;li>417 Expectation Failed。在请求头 Expect 中指定的预期内容无法被服务器满足，或者这个服务器是一个代理服务器，它有明显的证据证明在当前路由的下一个节点上，Expect 的内容无法被满足。&lt;/li>
&lt;li>421 too many connections。There are too many connections from your internet address 从当前客户端所在的 IP 地址到服务器的连接数超过了服务器许可的最大范围。通常，这里的 IP 地址指的是从服务器上看到的客户端地址（比如用户的网关或者代理服务器地址）。在这种情况下，连接数的计算可能涉及到不止一个终端用户。&lt;/li>
&lt;li>426 Upgrade Required 是一种 HTTP 协议的错误状态代码，表示服务器拒绝处理客户端使用当前协议发送的请求，但是可以接受其使用升级后的协议发送的请求。比如 http1.0 发起请求，http1.1 响应请求，一般会出现这个状态码&lt;/li>
&lt;/ul>
&lt;h2 id="server-错误5xx500-505">server 错误，5XX（500-505）&lt;/h2>
&lt;p>（5、6 字头）这类状态码代表了服务器在处理请求的过程中有错误或者异常状态发生，也有可能是服务器意识到以当前的软硬件资源无法完成对请求的处理。除非这是一个 HEAD 请求，否则服务器应当包含一个解释当前错误状态以及这个状况是临时的还是永久的解释信息实体。浏览器应当向用户展示任何在当前响应中被包含的实体。这些状态码适用于任何响应方法。&lt;/p>
&lt;ul>
&lt;li>500 Internal Server Error。服务器遇到了一个未曾预料的状况，导致了它无法完成对请求的处理。一般来说，这个问题都会在服务器端的源代码出现错误时出现。&lt;/li>
&lt;li>501 Not Implemented。服务器不支持当前请求所需要的某个功能。当服务器无法识别请求的方法，并且无法支持其对任何资源的请求。&lt;/li>
&lt;li>502 Bad Gateway。作为网关或者代理工作的服务器尝试执行请求时，从上游服务器接收到无效的响应。&lt;/li>
&lt;li>503 Service Unavailable。由于临时的服务器维护或者过载，服务器当前无法处理请求。这个状况是临时的，并且将在一段时间以后恢复。如果能够预计延迟时间，那么响应中可以包含一个 Retry-After 头用以标明这个延迟时间。如果没有给出这个 Retry-After 信息，那么客户端应当以处理 500 响应的方式处理它。
&lt;ul>
&lt;li>注意：503 状态码的存在并不意味着服务器在过载的时候必须使用它。某些服务器只不过是希望拒绝客户端的连接。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>504 Gateway Timeout。作为网关或者代理工作的服务器尝试执行请求时，未能及时从上游服务器（URI 标识出的服务器，例如 HTTP、FTP、LDAP）或者辅助服务器（例如 DNS）收到响应。
&lt;ul>
&lt;li>注意：某些代理服务器在 DNS 查询超时时会返回 400 或者 500 错误&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>505 HTTP Version Not Supported。服务器不支持，或者拒绝支持在请求中使用的 HTTP 版本。这暗示着服务器不能或不愿使用与客户端相同的版本。响应中应当包含一个描述了为何版本不被支持以及服务器支持哪些协议的实体。&lt;/li>
&lt;li>506 Variant Also Negotiates。由《透明内容协商协议》（RFC 2295）扩展，代表服务器存在内部配置错误：被请求的协商变元资源被配置为在透明内容协商中使用自己，因此在一个协商处理中不是一个合适的重点。&lt;/li>
&lt;li>507 Insufficient Storage。服务器无法存储完成请求所必须的内容。这个状况被认为是临时的。WebDAV (RFC 4918)&lt;/li>
&lt;li>509 Bandwidth Limit Exceeded。服务器达到带宽限制。这不是一个官方的状态码，但是仍被广泛使用。&lt;/li>
&lt;li>510 Not Extended。获取资源所需要的策略并没有被满足。（RFC 2774）&lt;/li>
&lt;li>600 Unparseable Response Headers。源站没有返回响应头部，只返回实体内容&lt;/li>
&lt;/ul></description></item><item><title>Docs: HTTP 的 持久化 与 认证/授权</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/4.%E6%95%B0%E6%8D%AE%E9%80%9A%E4%BF%A1/%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/7.http/http-%E7%9A%84-%E6%8C%81%E4%B9%85%E5%8C%96-%E4%B8%8E-%E8%AE%A4%E8%AF%81_%E6%8E%88%E6%9D%83/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/4.%E6%95%B0%E6%8D%AE%E9%80%9A%E4%BF%A1/%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/7.http/http-%E7%9A%84-%E6%8C%81%E4%B9%85%E5%8C%96-%E4%B8%8E-%E8%AE%A4%E8%AF%81_%E6%8E%88%E6%9D%83/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>原文链接：&lt;a href="https://juejin.cn/post/6844904034181070861">https://juejin.cn/post/6844904034181070861&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;h1 id="傻傻分不清之-cookiesessiontokenjwt">傻傻分不清之 Cookie、Session、Token、JWT&lt;/h1>
&lt;h2 id="什么是认证authentication">什么是认证（Authentication）&lt;/h2>
&lt;ul>
&lt;li>通俗地讲就是&lt;strong>验证当前用户的身份&lt;/strong>，证明“你是你自己”（比如：你每天上下班打卡，都需要通过指纹打卡，当你的指纹和系统里录入的指纹相匹配时，就打卡成功）&lt;/li>
&lt;li>互联网中的认证：
&lt;ul>
&lt;li>用户名密码登录&lt;/li>
&lt;li>邮箱发送登录链接&lt;/li>
&lt;li>手机号接收验证码&lt;/li>
&lt;li>只要你能收到邮箱/验证码，就默认你是账号的主人&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h2 id="什么是授权authorization">什么是授权（Authorization）&lt;/h2>
&lt;ul>
&lt;li>&lt;strong>用户授予第三方应用访问该用户某些资源的权限&lt;/strong>
&lt;ul>
&lt;li>你在安装手机应用的时候，APP 会询问是否允许授予权限（访问相册、地理位置等权限）&lt;/li>
&lt;li>你在访问微信小程序时，当登录时，小程序会询问是否允许授予权限（获取昵称、头像、地区、性别等个人信息）&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>实现授权的方式有：cookie、session、token、OAuth&lt;/li>
&lt;/ul>
&lt;h2 id="什么是凭证credentials">什么是凭证（Credentials）&lt;/h2>
&lt;ul>
&lt;li>&lt;strong>实现认证和授权的前提&lt;/strong>是需要一种**媒介（证书）**来标记访问者的身份
&lt;ul>
&lt;li>在战国时期，商鞅变法，发明了照身帖。照身帖由官府发放，是一块打磨光滑细密的竹板，上面刻有持有人的头像和籍贯信息。国人必须持有，如若没有就被认为是黑户，或者间谍之类的。&lt;/li>
&lt;li>在现实生活中，每个人都会有一张专属的&lt;a href="https://baike.baidu.com/item/%E5%B1%85%E6%B0%91%E8%BA%AB%E4%BB%BD%E8%AF%81/2080960">居民身份证&lt;/a>，是用于证明持有人身份的一种法定&lt;a href="https://baike.baidu.com/item/%E8%AF%81%E4%BB%B6/5804999">证件&lt;/a>。通过身份证，我们可以办理手机卡/银行卡/个人贷款/交通出行等等，这就是&lt;strong>认证的凭证。&lt;/strong>&lt;/li>
&lt;li>在互联网应用中，一般网站（如掘金）会有两种模式，游客模式和登录模式。游客模式下，可以正常浏览网站上面的文章，一旦想要点赞/收藏/分享文章，就需要登录或者注册账号。当用户登录成功后，服务器会给该用户使用的浏览器颁发一个令牌（token），这个令牌用来表明你的身份，每次浏览器发送请求时会带上这个令牌，就可以使用游客模式下无法使用的功能。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h2 id="什么是-cookie">什么是 Cookie&lt;/h2>
&lt;ul>
&lt;li>&lt;strong>HTTP 是无状态的协议（对于事务处理没有记忆能力，每次客户端和服务端会话完成时，服务端不会保存任何会话信息&lt;/strong>）：每个请求都是完全独立的，服务端无法确认当前访问者的身份信息，无法分辨上一次的请求发送者和这一次的发送者是不是同一个人。所以服务器与浏览器为了进行会话跟踪（知道是谁在访问我），就必须主动的去维护一个状态，这个状态用于告知服务端前后两个请求是否来自同一浏览器。而这个状态需要通过 cookie 或者 session 去实现。&lt;/li>
&lt;li>&lt;strong>cookie 存储在客户端：&lt;/strong> cookie 是服务器发送到用户浏览器并保存在本地的一小块数据，它会在浏览器下次向同一服务器再发起请求时被携带并发送到服务器上。&lt;/li>
&lt;li>&lt;strong>cookie 是不可跨域的：&lt;/strong> 每个 cookie 都会绑定单一的域名，无法在别的域名下获取使用，&lt;strong>一级域名和二级域名之间是允许共享使用的&lt;/strong>（&lt;strong>靠的是 domain）&lt;/strong>。&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>cookie 重要的属性&lt;/strong>&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>属性&lt;/th>
&lt;th>说明&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>&lt;strong>name=value&lt;/strong>&lt;/td>
&lt;td>键值对，设置 Cookie 的名称及相对应的值，都必须是&lt;strong>字符串类型&lt;/strong>&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>- 如果值为 Unicode 字符，需要为字符编码。
- 如果值为二进制数据，则需要使用 BASE64 编码。
|
| &lt;strong>domain&lt;/strong> | 指定 cookie 所属域名，默认是当前域名 |
| &lt;strong>path&lt;/strong> | &lt;strong>指定 cookie 在哪个路径（路由）下生效，默认是 &amp;lsquo;/&amp;rsquo;&lt;/strong>。
如果设置为 &lt;code>/abc&lt;/code>，则只有 &lt;code>/abc&lt;/code> 下的路由可以访问到该 cookie，如：&lt;code>/abc/read&lt;/code>。 |
| &lt;strong>maxAge&lt;/strong> | cookie 失效的时间，单位秒。如果为整数，则该 cookie 在 maxAge 秒后失效。如果为负数，该 cookie 为临时 cookie ，关闭浏览器即失效，浏览器也不会以任何形式保存该 cookie 。如果为 0，表示删除该 cookie 。默认为 -1。
- &lt;strong>比 expires 好用&lt;/strong>。
|
| &lt;strong>expires&lt;/strong> | 过期时间，在设置的某个时间点后该 cookie 就会失效。
一般浏览器的 cookie 都是默认储存的，当关闭浏览器结束这个会话的时候，这个 cookie 也就会被删除 |
| &lt;strong>secure&lt;/strong> | 该 cookie 是否仅被使用安全协议传输。安全协议有 HTTPS，SSL 等，在网络上传输数据之前先将数据加密。默认为 false。
当 secure 值为 true 时，cookie 在 HTTP 中是无效，在 HTTPS 中才有效。 |
| &lt;strong>httpOnly&lt;/strong> | &lt;strong>如果给某个 cookie 设置了 httpOnly 属性，则无法通过 JS 脚本 读取到该 cookie 的信息，但还是能通过 Application 中手动修改 cookie，所以只是在一定程度上可以防止 XSS 攻击，不是绝对的安全&lt;/strong> |
| | |&lt;/p>
&lt;h2 id="什么是-session">什么是 Session&lt;/h2>
&lt;ul>
&lt;li>&lt;strong>session 是另一种记录服务器和客户端会话状态的机制&lt;/strong>&lt;/li>
&lt;li>&lt;strong>session 是基于 cookie 实现的，session 存储在服务器端，sessionId 会被存储到客户端的 cookie 中&lt;/strong>&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/rv7ih5/1623681275011-42bd5bea-dbaf-4605-95a2-c433d48b78c8.webp" alt="">&lt;/p>
&lt;ul>
&lt;li>&lt;strong>session 认证流程：&lt;/strong>
&lt;ul>
&lt;li>用户第一次请求服务器的时候，服务器根据用户提交的相关信息，创建对应的 Session&lt;/li>
&lt;li>请求返回时将此 Session 的唯一标识信息 SessionID 返回给浏览器&lt;/li>
&lt;li>浏览器接收到服务器返回的 SessionID 信息后，会将此信息存入到 Cookie 中，同时 Cookie 记录此 SessionID 属于哪个域名&lt;/li>
&lt;li>当用户第二次访问服务器的时候，请求会自动判断此域名下是否存在 Cookie 信息，如果存在自动将 Cookie 信息也发送给服务端，服务端会从 Cookie 中获取 SessionID，再根据 SessionID 查找对应的 Session 信息，如果没有找到说明用户没有登录或者登录失效，如果找到 Session 证明用户已经登录可执行后面操作。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>根据以上流程可知，&lt;strong>SessionID 是连接 Cookie 和 Session 的一道桥梁&lt;/strong>，大部分系统也是根据此原理来验证用户登录状态。&lt;/p>
&lt;h2 id="cookie-和-session-的区别">Cookie 和 Session 的区别&lt;/h2>
&lt;ul>
&lt;li>&lt;strong>安全性：&lt;/strong> Session 比 Cookie 安全，Session 是存储在服务器端的，Cookie 是存储在客户端的。&lt;/li>
&lt;li>&lt;strong>存取值的类型不同&lt;/strong>：Cookie 只支持存字符串数据，想要设置其他类型的数据，需要将其转换成字符串，Session 可以存任意数据类型。&lt;/li>
&lt;li>&lt;strong>有效期不同：&lt;/strong> Cookie 可设置为长时间保持，比如我们经常使用的默认登录功能，Session 一般失效时间较短，客户端关闭（默认情况下）或者 Session 超时都会失效。&lt;/li>
&lt;li>&lt;strong>存储大小不同：&lt;/strong> 单个 Cookie 保存的数据不能超过 4K，Session 可存储数据远高于 Cookie，但是当访问量过多，会占用过多的服务器资源。&lt;/li>
&lt;/ul>
&lt;h2 id="什么是-token令牌">什么是 Token（令牌）&lt;/h2>
&lt;h3 id="acesss-token">Acesss Token&lt;/h3>
&lt;ul>
&lt;li>&lt;strong>访问资源接口（API）时所需要的资源凭证&lt;/strong>&lt;/li>
&lt;li>&lt;strong>简单 token 的组成：&lt;/strong> uid(用户唯一的身份标识)、time(当前时间的时间戳)、sign（签名，token 的前几位以哈希算法压缩成的一定长度的十六进制字符串）&lt;/li>
&lt;li>&lt;strong>特点：&lt;/strong>
&lt;ul>
&lt;li>&lt;strong>服务端无状态化、可扩展性好&lt;/strong>&lt;/li>
&lt;li>&lt;strong>支持移动端设备&lt;/strong>&lt;/li>
&lt;li>安全&lt;/li>
&lt;li>支持跨程序调用&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>token 的身份验证流程：&lt;/strong>&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/rv7ih5/1623681275029-dccf3312-cfa7-4ac5-9008-0697991e35b3.webp" alt="">&lt;/p>
&lt;ol>
&lt;li>客户端使用用户名跟密码请求登录&lt;/li>
&lt;li>服务端收到请求，去验证用户名与密码&lt;/li>
&lt;li>验证成功后，服务端会签发一个 token 并把这个 token 发送给客户端&lt;/li>
&lt;li>客户端收到 token 以后，会把它存储起来，比如放在 cookie 里或者 localStorage 里&lt;/li>
&lt;li>客户端每次向服务端请求资源的时候需要带着服务端签发的 token&lt;/li>
&lt;li>服务端收到请求，然后去验证客户端请求里面带着的 token ，如果验证成功，就向客户端返回请求的数据&lt;/li>
&lt;/ol>
&lt;ul>
&lt;li>&lt;strong>每一次请求都需要携带 token，需要把 token 放到 HTTP 的 Header 里&lt;/strong>&lt;/li>
&lt;li>&lt;strong>基于 token 的用户认证是一种服务端无状态的认证方式，服务端不用存放 token 数据。用解析 token 的计算时间换取 session 的存储空间，从而减轻服务器的压力，减少频繁的查询数据库&lt;/strong>&lt;/li>
&lt;li>&lt;strong>token 完全由应用管理，所以它可以避开同源策略&lt;/strong>&lt;/li>
&lt;/ul>
&lt;h3 id="refresh-token">Refresh Token&lt;/h3>
&lt;ul>
&lt;li>
&lt;p>另外一种 token——refresh token&lt;/p>
&lt;/li>
&lt;li>
&lt;p>refresh token 是专用于刷新 access token 的 token。如果没有 refresh token，也可以刷新 access token，但每次刷新都要用户输入登录用户名与密码，会很麻烦。有了 refresh token，可以减少这个麻烦，客户端直接用 refresh token 去更新 access token，无需用户进行额外的操作。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/rv7ih5/1623681275000-372bff85-cf45-4502-a00d-981a4d52f36b.webp" alt="">&lt;/p>
&lt;ul>
&lt;li>Access Token 的有效期比较短，当 Acesss Token 由于过期而失效时，使用 Refresh Token 就可以获取到新的 Token，如果 Refresh Token 也失效了，用户就只能重新登录了。&lt;/li>
&lt;li>Refresh Token 及过期时间是存储在服务器的数据库中，只有在申请新的 Acesss Token 时才会验证，不会对业务接口响应时间造成影响，也不需要向 Session 一样一直保持在内存中以应对大量的请求。&lt;/li>
&lt;/ul>
&lt;h2 id="token-和-session-的区别">Token 和 Session 的区别&lt;/h2>
&lt;ul>
&lt;li>Session 是一种&lt;strong>记录服务器和客户端会话状态的机制，使服务端有状态化，可以记录会话信息&lt;/strong>。而 Token 是&lt;strong>令牌&lt;/strong>，&lt;strong>访问资源接口（API）时所需要的资源凭证&lt;/strong>。Token &lt;strong>使服务端无状态化，不会存储会话信息。&lt;/strong>&lt;/li>
&lt;li>Session 和 Token 并不矛盾，作为身份认证 Token 安全性比 Session 好，因为每一个请求都有签名还能防止监听以及重放攻击，而 Session 就必须依赖链路层来保障通讯安全了。&lt;strong>如果你需要实现有状态的会话，仍然可以增加 Session 来在服务器端保存一些状态。&lt;/strong>&lt;/li>
&lt;li>所谓 Session 认证只是简单的把 User 信息存储到 Session 里，因为 SessionID 的不可预测性，暂且认为是安全的。而 Token ，如果指的是 OAuth Token 或类似的机制的话，提供的是 认证 和 授权 ，认证是针对用户，授权是针对 App 。其目的是让某 App 有权利访问某用户的信息。这里的 Token 是唯一的。不可以转移到其它 App 上，也不可以转到其它用户上。Session 只提供一种简单的认证，即只要有此 SessionID ，即认为有此 User 的全部权利。是需要严格保密的，这个数据应该只保存在站方，不应该共享给其它网站或者第三方 App。所以简单来说：&lt;strong>如果你的用户数据可能需要和第三方共享，或者允许第三方调用 API 接口，用 Token 。如果永远只是自己的网站，自己的 App，用什么就无所谓了。&lt;/strong>&lt;/li>
&lt;/ul>
&lt;h2 id="什么是-jwt">什么是 JWT&lt;/h2>
&lt;ul>
&lt;li>JSON Web Token（简称 JWT）是目前最流行的&lt;strong>跨域认证&lt;/strong>解决方案。&lt;/li>
&lt;li>是一种&lt;strong>认证授权机制&lt;/strong>。&lt;/li>
&lt;li>JWT 是为了在网络应用环境间&lt;strong>传递声明&lt;/strong>而执行的一种基于 JSON 的开放标准（&lt;a href="https://tools.ietf.org/html/rfc7519">RFC 7519&lt;/a>）。JWT 的声明一般被用来在身份提供者和服务提供者间传递被认证的用户身份信息，以便于从资源服务器获取资源。比如用在用户登录上。&lt;/li>
&lt;li>可以使用 HMAC 算法或者是 RSA 的公/私秘钥对 JWT 进行签名。因为数字签名的存在，这些传递的信息是可信的。&lt;/li>
&lt;li>&lt;strong>阮一峰老师的 &lt;a href="http://www.ruanyifeng.com/blog/2018/07/json_web_token-tutorial.html">JSON Web Token 入门教程&lt;/a> 讲的非常通俗易懂，这里就不再班门弄斧了&lt;/strong>&lt;/li>
&lt;/ul>
&lt;h3 id="生成-jwt">生成 JWT&lt;/h3>
&lt;p>&lt;a href="https://jwt.io/">jwt.io/&lt;/a>
&lt;a href="https://www.jsonwebtoken.io/">www.jsonwebtoken.io/&lt;/a>&lt;/p>
&lt;h3 id="jwt-的原理">JWT 的原理&lt;/h3>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/rv7ih5/1623681275062-caae1d23-b1ee-4012-a7a6-551725463c32.webp" alt="">&lt;/p>
&lt;ul>
&lt;li>&lt;strong>JWT 认证流程：&lt;/strong>
&lt;ul>
&lt;li>用户输入用户名/密码登录，服务端认证成功后，会返回给客户端一个 JWT&lt;/li>
&lt;li>客户端将 token 保存到本地（通常使用 localstorage，也可以使用 cookie）&lt;/li>
&lt;li>当用户希望访问一个受保护的路由或者资源的时候，需要请求头的 Authorization 字段中使用 Bearer 模式添加 JWT，其内容看起来是下面这样&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;!-- raw HTML omitted -->
&lt;pre>&lt;code>Authorization: Bearer &amp;lt;token&amp;gt;
复制代码
&lt;/code>&lt;/pre>
&lt;ul>
&lt;li>服务端的保护路由将会检查请求头 Authorization 中的 JWT 信息，如果合法，则允许用户的行为&lt;/li>
&lt;li>因为 JWT 是自包含的（内部包含了一些会话信息），因此减少了需要查询数据库的需要&lt;/li>
&lt;li>因为 JWT 并不使用 Cookie 的，所以你可以使用任何域名提供你的 API 服务而不需要担心跨域资源共享问题（CORS）&lt;/li>
&lt;li>因为用户的状态不再存储在服务端的内存中，所以这是一种无状态的认证机制&lt;/li>
&lt;/ul>
&lt;h3 id="jwt-的使用方式">JWT 的使用方式&lt;/h3>
&lt;ul>
&lt;li>客户端收到服务器返回的 JWT，可以储存在 Cookie 里面，也可以储存在 localStorage。&lt;/li>
&lt;/ul>
&lt;h4 id="方式一">方式一&lt;/h4>
&lt;ul>
&lt;li>当用户希望访问一个受保护的路由或者资源的时候，可以把它放在 Cookie 里面自动发送，但是这样不能跨域，所以更好的做法是放在 HTTP 请求头信息的 Authorization 字段里，使用 Bearer 模式添加 JWT。&lt;/li>
&lt;/ul>
&lt;!-- raw HTML omitted -->
&lt;pre>&lt;code>GET /calendar/v1/events
Host: api.example.com
Authorization: Bearer &amp;lt;token&amp;gt;
复制代码
&lt;/code>&lt;/pre>
&lt;ul>
&lt;li>用户的状态不会存储在服务端的内存中，这是一种 &lt;strong>无状态的认证机制&lt;/strong>&lt;/li>
&lt;li>服务端的保护路由将会检查请求头 Authorization 中的 JWT 信息，如果合法，则允许用户的行为。&lt;/li>
&lt;li>由于 JWT 是自包含的，因此减少了需要查询数据库的需要&lt;/li>
&lt;li>JWT 的这些特性使得我们可以完全依赖其无状态的特性提供数据 API 服务，甚至是创建一个下载流服务。&lt;/li>
&lt;li>因为 JWT 并不使用 Cookie ，所以你可以使用任何域名提供你的 API 服务而&lt;strong>不需要担心跨域资源共享问题&lt;/strong>（CORS）&lt;/li>
&lt;/ul>
&lt;h4 id="方式二">方式二&lt;/h4>
&lt;ul>
&lt;li>跨域的时候，可以把 JWT 放在 POST 请求的数据体里。&lt;/li>
&lt;/ul>
&lt;h4 id="方式三">方式三&lt;/h4>
&lt;ul>
&lt;li>通过 URL 传输&lt;/li>
&lt;/ul>
&lt;!-- raw HTML omitted -->
&lt;pre>&lt;code>http://www.example.com/user?token=xxx
复制代码
&lt;/code>&lt;/pre>
&lt;h3 id="项目中使用-jwt">项目中使用 JWT&lt;/h3>
&lt;p>&lt;a href="https://github.com/yjdjiayou/jwt-demo">&lt;strong>项目地址&lt;/strong>&lt;/a>&lt;/p>
&lt;h2 id="token-和-jwt-的区别">Token 和 JWT 的区别&lt;/h2>
&lt;p>&lt;strong>相同：&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>都是访问资源的令牌&lt;/li>
&lt;li>都可以记录用户的信息&lt;/li>
&lt;li>都是使服务端无状态化&lt;/li>
&lt;li>都是只有验证成功后，客户端才能访问服务端上受保护的资源&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>区别：&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>Token：服务端验证客户端发送过来的 Token 时，还需要查询数据库获取用户信息，然后验证 Token 是否有效。&lt;/li>
&lt;li>JWT： 将 Token 和 Payload 加密后存储于客户端，服务端只需要使用密钥解密进行校验（校验也是 JWT 自己实现的）即可，不需要查询或者减少查询数据库，因为 JWT 自包含了用户信息和加密的数据。&lt;/li>
&lt;/ul>
&lt;h2 id="常见的前后端鉴权方式">常见的前后端鉴权方式&lt;/h2>
&lt;ol>
&lt;li>Session-Cookie&lt;/li>
&lt;li>Token 验证（包括 JWT，SSO）&lt;/li>
&lt;li>OAuth2.0（开放授权）&lt;/li>
&lt;/ol>
&lt;h2 id="常见的加密算法">常见的加密算法&lt;/h2>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/rv7ih5/1623681275046-ccd24609-06ff-4db8-95c9-6619fb91e5ae.webp" alt="">&lt;/p>
&lt;ul>
&lt;li>哈希算法(Hash Algorithm)又称散列算法、散列函数、哈希函数，是一种从任何一种数据中创建小的数字“指纹”的方法。哈希算法将数据重新打乱混合，重新创建一个哈希值。&lt;/li>
&lt;li>哈希算法主要用来保障数据真实性(即完整性)，即发信人将原始消息和哈希值一起发送，收信人通过相同的哈希函数来校验原始数据是否真实。&lt;/li>
&lt;li>哈希算法通常有以下几个特点：
&lt;ul>
&lt;li>正像快速：原始数据可以快速计算出哈希值&lt;/li>
&lt;li>逆向困难：通过哈希值基本不可能推导出原始数据&lt;/li>
&lt;li>输入敏感：原始数据只要有一点变动，得到的哈希值差别很大&lt;/li>
&lt;li>冲突避免：很难找到不同的原始数据得到相同的哈希值，宇宙中原子数大约在 10 的 60 次方到 80 次方之间，所以 2 的 256 次方有足够的空间容纳所有的可能，算法好的情况下冲突碰撞的概率很低：
&lt;ul>
&lt;li>2 的 128 次方为 340282366920938463463374607431768211456，也就是 10 的 39 次方级别&lt;/li>
&lt;li>2 的 160 次方为 1.4615016373309029182036848327163e+48，也就是 10 的 48 次方级别&lt;/li>
&lt;li>2 的 256 次方为 1.1579208923731619542357098500869 × 10 的 77 次方，也就是 10 的 77 次方&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>注意：&lt;/strong>&lt;/p>
&lt;ol>
&lt;li>以上不能保证数据被恶意篡改，原始数据和哈希值都可能被恶意篡改，要保证不被篡改，可以使用 RSA 公钥私钥方案，再配合哈希值。&lt;/li>
&lt;li>哈希算法主要用来防止计算机传输过程中的错误，早期计算机通过前 7 位数据第 8 位奇偶校验码来保障（12.5% 的浪费效率低），对于一段数据或文件，通过哈希算法生成 128bit 或者 256bit 的哈希值，如果校验有问题就要求重传。&lt;/li>
&lt;/ol>
&lt;h2 id="常见问题">常见问题&lt;/h2>
&lt;h3 id="使用-cookie-时需要考虑的问题">使用 cookie 时需要考虑的问题&lt;/h3>
&lt;ul>
&lt;li>因为存储在客户端，容易被客户端篡改，使用前需要验证合法性&lt;/li>
&lt;li>不要存储敏感数据，比如用户密码，账户余额&lt;/li>
&lt;li>使用 httpOnly 在一定程度上提高安全性&lt;/li>
&lt;li>尽量减少 cookie 的体积，能存储的数据量不能超过 4kb&lt;/li>
&lt;li>设置正确的 domain 和 path，减少数据传输&lt;/li>
&lt;li>&lt;strong>cookie 无法跨域&lt;/strong>&lt;/li>
&lt;li>一个浏览器针对一个网站最多存 20 个 Cookie，浏览器一般只允许存放 300 个 Cookie&lt;/li>
&lt;li>&lt;strong>移动端对 cookie 的支持不是很好，而 session 需要基于 cookie 实现，所以移动端常用的是 token&lt;/strong>&lt;/li>
&lt;/ul>
&lt;h3 id="使用-session-时需要考虑的问题">使用 session 时需要考虑的问题&lt;/h3>
&lt;ul>
&lt;li>将 session 存储在服务器里面，当用户同时在线量比较多时，这些 session 会占据较多的内存，需要在服务端定期的去清理过期的 session&lt;/li>
&lt;li>当网站采用&lt;strong>集群部署&lt;/strong>的时候，会遇到多台 web 服务器之间如何做 session 共享的问题。因为 session 是由单个服务器创建的，但是处理用户请求的服务器不一定是那个创建 session 的服务器，那么该服务器就无法拿到之前已经放入到 session 中的登录凭证之类的信息了。&lt;/li>
&lt;li>当多个应用要共享 session 时，除了以上问题，还会遇到跨域问题，因为不同的应用可能部署的主机不一样，需要在各个应用做好 cookie 跨域的处理。&lt;/li>
&lt;li>&lt;strong>sessionId 是存储在 cookie 中的，假如浏览器禁止 cookie 或不支持 cookie 怎么办？&lt;/strong> 一般会把 sessionId 跟在 url 参数后面即重写 url，所以 session 不一定非得需要靠 cookie 实现&lt;/li>
&lt;li>&lt;strong>移动端对 cookie 的支持不是很好，而 session 需要基于 cookie 实现，所以移动端常用的是 token&lt;/strong>&lt;/li>
&lt;/ul>
&lt;h3 id="使用-token-时需要考虑的问题">使用 token 时需要考虑的问题&lt;/h3>
&lt;ul>
&lt;li>如果你认为用数据库来存储 token 会导致查询时间太长，可以选择放在内存当中。比如 redis 很适合你对 token 查询的需求。&lt;/li>
&lt;li>&lt;strong>token 完全由应用管理，所以它可以避开同源策略&lt;/strong>&lt;/li>
&lt;li>&lt;strong>token 可以避免 CSRF 攻击(因为不需要 cookie 了)&lt;/strong>&lt;/li>
&lt;li>&lt;strong>移动端对 cookie 的支持不是很好，而 session 需要基于 cookie 实现，所以移动端常用的是 token&lt;/strong>&lt;/li>
&lt;/ul>
&lt;h3 id="使用-jwt-时需要考虑的问题">使用 JWT 时需要考虑的问题&lt;/h3>
&lt;ul>
&lt;li>因为 JWT 并不依赖 Cookie 的，所以你可以使用任何域名提供你的 API 服务而不需要担心跨域资源共享问题（CORS）&lt;/li>
&lt;li>JWT 默认是不加密，但也是可以加密的。生成原始 Token 以后，可以用密钥再加密一次。&lt;/li>
&lt;li>JWT 不加密的情况下，不能将秘密数据写入 JWT。&lt;/li>
&lt;li>JWT 不仅可以用于认证，也可以用于交换信息。有效使用 JWT，可以降低服务器查询数据库的次数。&lt;/li>
&lt;li>JWT 最大的优势是服务器不再需要存储 Session，使得服务器认证鉴权业务可以方便扩展。但这也是 JWT 最大的缺点：由于服务器不需要存储 Session 状态，因此使用过程中无法废弃某个 Token 或者更改 Token 的权限。也就是说一旦 JWT 签发了，到期之前就会始终有效，除非服务器部署额外的逻辑。&lt;/li>
&lt;li>JWT 本身包含了认证信息，一旦泄露，任何人都可以获得该令牌的所有权限。为了减少盗用，JWT 的有效期应该设置得比较短。对于一些比较重要的权限，使用时应该再次对用户进行认证。&lt;/li>
&lt;li>JWT 适合一次性的命令认证，颁发一个有效期极短的 JWT，即使暴露了危险也很小，由于每次操作都会生成新的 JWT，因此也没必要保存 JWT，真正实现无状态。&lt;/li>
&lt;li>为了减少盗用，JWT 不应该使用 HTTP 协议明码传输，要使用 HTTPS 协议传输。&lt;/li>
&lt;/ul>
&lt;h3 id="使用加密算法时需要考虑的问题">使用加密算法时需要考虑的问题&lt;/h3>
&lt;ul>
&lt;li>绝不要以&lt;strong>明文存储&lt;/strong>密码&lt;/li>
&lt;li>&lt;strong>永远使用 哈希算法 来处理密码，绝不要使用 Base64 或其他编码方式来存储密码，这和以明文存储密码是一样的，使用哈希，而不要使用编码&lt;/strong>。编码以及加密，都是双向的过程，而密码是保密的，应该只被它的所有者知道， 这个过程必须是单向的。哈希正是用于做这个的，从来没有解哈希这种说法， 但是编码就存在解码，加密就存在解密。&lt;/li>
&lt;li>绝不要使用弱哈希或已被破解的哈希算法，像 MD5 或 SHA1 ，只使用强密码哈希算法。&lt;/li>
&lt;li>绝不要以明文形式显示或发送密码，即使是对密码的所有者也应该这样。如果你需要 “忘记密码” 的功能，可以随机生成一个新的 &lt;strong>一次性的&lt;/strong>（这点很重要）密码，然后把这个密码发送给用户。&lt;/li>
&lt;/ul>
&lt;h3 id="分布式架构下-session-共享方案">分布式架构下 session 共享方案&lt;/h3>
&lt;h4 id="1-session-复制">1. session 复制&lt;/h4>
&lt;ul>
&lt;li>任何一个服务器上的 session 发生改变（增删改），该节点会把这个 session 的所有内容序列化，然后广播给所有其它节点，不管其他服务器需不需要 session ，以此来保证 session 同步&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>优点：&lt;/strong> 可容错，各个服务器间 session 能够实时响应。
&lt;strong>缺点：&lt;/strong> 会对网络负荷造成一定压力，如果 session 量大的话可能会造成网络堵塞，拖慢服务器性能。&lt;/p>
&lt;h4 id="2-粘性-session-ip-绑定策略">2. 粘性 session /IP 绑定策略&lt;/h4>
&lt;ul>
&lt;li>&lt;strong>采用 Ngnix 中的 ip_hash 机制，将某个 ip 的所有请求都定向到同一台服务器上，即将用户与服务器绑定。&lt;/strong> 用户第一次请求时，负载均衡器将用户的请求转发到了 A 服务器上，如果负载均衡器设置了粘性 session 的话，那么用户以后的每次请求都会转发到 A 服务器上，相当于把用户和 A 服务器粘到了一块，这就是粘性 session 机制。&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>优点：&lt;/strong> 简单，不需要对 session 做任何处理。
&lt;strong>缺点：&lt;/strong> 缺乏容错性，如果当前访问的服务器发生故障，用户被转移到第二个服务器上时，他的 session 信息都将失效。
&lt;strong>适用场景：&lt;/strong> 发生故障对客户产生的影响较小；服务器发生故障是低概率事件 。
&lt;strong>实现方式：&lt;/strong> 以 Nginx 为例，在 upstream 模块配置 ip_hash 属性即可实现粘性 session。&lt;/p>
&lt;h4 id="3-session-共享常用">3. session 共享（常用）&lt;/h4>
&lt;ul>
&lt;li>使用分布式缓存方案比如 Memcached 、Redis 来缓存 session，但是要求 Memcached 或 Redis 必须是集群&lt;/li>
&lt;li>把 session 放到 Redis 中存储，虽然架构上变得复杂，并且需要多访问一次 Redis ，但是这种方案带来的好处也是很大的：
&lt;ul>
&lt;li>实现了 session 共享；&lt;/li>
&lt;li>可以水平扩展（增加 Redis 服务器）；&lt;/li>
&lt;li>服务器重启 session 不丢失（不过也要注意 session 在 Redis 中的刷新/失效机制）；&lt;/li>
&lt;li>不仅可以跨服务器 session 共享，甚至可以跨平台（例如网页端和 APP 端）&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/rv7ih5/1623681275027-55a77f32-68e2-4a4e-9636-10ddd23989f8.webp" alt="">&lt;/p>
&lt;h4 id="4-session-持久化">4. session 持久化&lt;/h4>
&lt;ul>
&lt;li>将 session 存储到数据库中，保证 session 的持久化&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>优点：&lt;/strong> 服务器出现问题，session 不会丢失
&lt;strong>缺点：&lt;/strong> 如果网站的访问量很大，把 session 存储到数据库中，会对数据库造成很大压力，还需要增加额外的开销维护数据库。&lt;/p>
&lt;h3 id="只要关闭浏览器-session-真的就消失了">&lt;strong>只要关闭浏览器 ，session 真的就消失了？&lt;/strong>&lt;/h3>
&lt;p>不对。对 session 来说，除非程序通知服务器删除一个 session，否则服务器会一直保留，程序一般都是在用户做 log off 的时候发个指令去删除 session。
然而浏览器从来不会主动在关闭之前通知服务器它将要关闭，因此服务器根本不会有机会知道浏览器已经关闭，之所以会有这种错觉，是大部分 session 机制都使用会话 cookie 来保存 session id，而关闭浏览器后这个 session id 就消失了，再次连接服务器时也就无法找到原来的 session。如果服务器设置的 cookie 被保存在硬盘上，或者使用某种手段改写浏览器发出的 HTTP 请求头，把原来的 session id 发送给服务器，则再次打开浏览器仍然能够打开原来的 session。
恰恰是&lt;strong>由于关闭浏览器不会导致 session 被删除，迫使服务器为 session 设置了一个失效时间，当距离客户端上一次使用 session 的时间超过这个失效时间时，服务器就认为客户端已经停止了活动，才会把 session 删除以节省存储空间。&lt;/strong>&lt;/p>
&lt;h2 id="项目地址">项目地址&lt;/h2>
&lt;p>&lt;a href="https://github.com/yjdjiayou/jwt-demo">&lt;strong>在项目中使用 JWT&lt;/strong>&lt;/a>&lt;/p>
&lt;h2 id="后语">后语&lt;/h2>
&lt;ul>
&lt;li>本文只是基于自己的理解讲了理论知识，因为对后端/算法知识不是很熟，如有谬误，还请告知，万分感谢&lt;/li>
&lt;li>如果本文对你有所帮助，还请点个赞~~&lt;/li>
&lt;/ul>
&lt;h2 id="参考">参考&lt;/h2>
&lt;p>&lt;a href="https://baike.baidu.com/item/cookie/1119?fr=aladdin">&lt;strong>百度百科-cookie&lt;/strong>&lt;/a>
&lt;a href="https://baike.baidu.com/item/session/479100?fr=aladdin#3">&lt;strong>百度百科-session&lt;/strong>&lt;/a>
&lt;a href="https://juejin.im/post/6844903864810864647">&lt;strong>详解 Cookie，Session，Token&lt;/strong>&lt;/a>
&lt;a href="https://juejin.im/post/6844904009061367821#heading-0">&lt;strong>一文彻底搞懂 Cookie、Session、Token 到底是什么&lt;/strong>&lt;/a>
&lt;strong>&lt;a href="https://www.cnblogs.com/lyzg/p/6067766.html">3 种 web 会话管理的方式&lt;/a>！！！&lt;/strong>
&lt;strong>&lt;a href="https://www.cnblogs.com/JamesWang1993/p/8593494.html">Token ，Cookie 和 Session 的区别&lt;/a>！！！&lt;/strong>
&lt;strong>&lt;a href="https://www.cnblogs.com/moyand/p/9047978.html">彻底理解 cookie、session、token&lt;/a>！！！&lt;/strong>
&lt;a href="https://juejin.im/post/6844903781704941576">&lt;strong>前端鉴权&lt;/strong>&lt;/a>
&lt;a href="https://zh.wikipedia.org/wiki/SHA-1">&lt;strong>SHA-1&lt;/strong>&lt;/a>
&lt;a href="https://zh.wikipedia.org/wiki/SHA-2">&lt;strong>SHA-2&lt;/strong>&lt;/a>
&lt;a href="https://zh.wikipedia.org/wiki/SHA-3">&lt;strong>SHA-3&lt;/strong>&lt;/a>
&lt;a href="https://blog.csdn.net/zhezhebie/article/details/71631077">&lt;strong>不要再使用 MD5 和 SHA1 加密密码了！&lt;/strong>&lt;/a>
&lt;a href="https://www.liaoxuefeng.com/wiki/1022910821149312/1023025778520640">&lt;strong>廖雪峰 Node 教程之 crypto&lt;/strong>&lt;/a>&lt;/p>
&lt;h2 id="推荐阅读">推荐阅读&lt;/h2>
&lt;p>&lt;a href="https://juejin.im/post/6844904021233238024">&lt;strong>你真的了解 React 生命周期吗&lt;/strong>&lt;/a>
&lt;strong>&lt;a href="https://juejin.im/post/6844903985338400782">React Hooks 详解 【近 1W 字】+ 项目实战&lt;/a>&lt;/strong>
&lt;strong>&lt;a href="https://juejin.im/post/6844904017487724557">React SSR 详解【近 1W 字】+ 2 个项目实战&lt;/a>&lt;/strong>
&lt;strong>&lt;a href="https://juejin.im/post/6844903966849892359">从 0 到 1 实现一款简易版 Webpack&lt;/a>&lt;/strong>&lt;/p></description></item><item><title>Docs: HTTP 的实现</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/4.%E6%95%B0%E6%8D%AE%E9%80%9A%E4%BF%A1/%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/7.http/http-%E7%9A%84%E5%AE%9E%E7%8E%B0/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/4.%E6%95%B0%E6%8D%AE%E9%80%9A%E4%BF%A1/%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/7.http/http-%E7%9A%84%E5%AE%9E%E7%8E%B0/</guid><description>
&lt;p>HTTP 服务器的程序(想提供 web 服务必须要安装一下程序中的一个)&lt;/p>
&lt;ul>
&lt;li>httpd(apache)&lt;/li>
&lt;li>nginx&lt;/li>
&lt;li>lighttpd&lt;/li>
&lt;li>应用程序服务器：上面的程序如果不附加插件则只支持静态的网页，装上下面的程序还能解析 PHP 等动态界面
&lt;ul>
&lt;li>IIS&lt;/li>
&lt;li>tomcat，jetty，就 boss，resin&lt;/li>
&lt;li>webshpere,weblogic,oc4j&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h1 id="httpd">httpd&lt;/h1>
&lt;p>apache(a patchy server)的特性&lt;/p>
&lt;ul>
&lt;li>高度模块化：core+modules&lt;/li>
&lt;li>DSO：Dynamic Shared Object&lt;/li>
&lt;li>MPM：Multipath Processing Modules 多路处理模块，不同的工作方式，可以切换，使用不同模块可以满足不同需求
&lt;ul>
&lt;li>prefork：多进程模型，每个进程响应一个请求
&lt;ul>
&lt;li>一个主进程：负责生成 n 个子近侧很难过，子进程也成为工作进程，每个子进程处理一个用户请求，即便没有用户请求，也会预先生成多个空闲进程，随时等待请求到达，最大不超过 1024 个&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>worker：多线程模型
&lt;ul>
&lt;li>一个主进程：负责生成子进程；负责创建套接字；负责接收请求，并将其派发给某子进程进行处理；&lt;/li>
&lt;li>多个子进程：每个子进程负责生成多个线程；&lt;/li>
&lt;li>每个线程：负责响应用户请求；&lt;/li>
&lt;li>并发响应数量：m*n&lt;/li>
&lt;li>m：子进程数量&lt;/li>
&lt;li>n：每个子进程所能创建的最大线程数量；&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>event：事件驱动模型，多进程模型，每个进程响应多个请求（老版本系统不支持，systemd 系统支持）
&lt;ul>
&lt;li>一个主进程 ：负责生成子进程；负责创建套接字；负责接收请求，并将其派发给某子进程进行处理；&lt;/li>
&lt;li>子进程：基于事件驱动机制直接响应多个请求；&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h2 id="httpd-配置">Httpd 配置&lt;/h2>
&lt;p>程序环境(.init 系统下)&lt;/p>
&lt;ul>
&lt;li>配置文件
&lt;ul>
&lt;li>/etc/httpd/conf/httpd.conf&lt;/li>
&lt;li>/etc/httpd/conf.d/*.conf&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>服务脚本
&lt;ul>
&lt;li>/etc/rc.d/init.d/httpd&lt;/li>
&lt;li>配置文件/etc/sysconfig/httpd&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>主程序文件
&lt;ul>
&lt;li>/usr/sbin/httpd&lt;/li>
&lt;li>/usr/sbin/httpd.event&lt;/li>
&lt;li>/usr/sbin/httpd.worker&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>日志文件目录
&lt;ul>
&lt;li>/var/log/httpd
&lt;ul>
&lt;li>access_log:访问日志&lt;/li>
&lt;li>error_log:错误日志&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>站点文档目录
&lt;ul>
&lt;li>/var/www/html&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul></description></item><item><title>Docs: HTTP 管理</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/4.%E6%95%B0%E6%8D%AE%E9%80%9A%E4%BF%A1/%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/7.http/http-%E7%AE%A1%E7%90%86/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/4.%E6%95%B0%E6%8D%AE%E9%80%9A%E4%BF%A1/%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/7.http/http-%E7%AE%A1%E7%90%86/</guid><description/></item><item><title>Docs: HTTP 缓存</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/4.%E6%95%B0%E6%8D%AE%E9%80%9A%E4%BF%A1/%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/7.http/http-%E7%BC%93%E5%AD%98/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/4.%E6%95%B0%E6%8D%AE%E9%80%9A%E4%BF%A1/%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/7.http/http-%E7%BC%93%E5%AD%98/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://mp.weixin.qq.com/s/bUy220-ect00N4gnO0697A">公众号-小林 coding，硬核！30 张图解 HTTP 常见的面试题&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://mp.weixin.qq.com/s/fvvnQ3xI1nz-Ri3vBfG2lw">公众号-小林 coding，告别 HTTP&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;h3 id="http-缓存有哪些实现方式">HTTP 缓存有哪些实现方式？&lt;/h3>
&lt;p>对于一些具有重复性的 HTTP 请求，比如每次请求得到的数据都一样的，我们可以把这对「请求-响应」的数据都&lt;strong>缓存在本地&lt;/strong>，那么下次就直接读取本地的数据，不必在通过网络获取服务器的响应了，这样的话 HTTP/1.1 的性能肯定肉眼可见的提升。&lt;/p>
&lt;p>所以，避免发送 HTTP 请求的方法就是通过&lt;strong>缓存技术&lt;/strong>，HTTP 设计者早在之前就考虑到了这点，因此 HTTP 协议的头部有不少是针对缓存的字段。&lt;/p>
&lt;p>HTTP 缓存有两种实现方式，分别是&lt;strong>强制缓存和协商缓存&lt;/strong>。&lt;/p>
&lt;h3 id="什么是强制缓存">什么是强制缓存？&lt;/h3>
&lt;p>强缓存指的是只要浏览器判断缓存没有过期，则直接使用浏览器的本地缓存，决定是否使用缓存的主动性在于浏览器这边。&lt;/p>
&lt;p>如下图中，返回的是 200 状态码，但在 size 项中标识的是 from disk cache，就是使用了强制缓存。&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/884948f1-0dd2-48b3-8dd0-41b261df0633/1649668520864-47bf15a0-854c-4725-ae4f-45751f99cf0f.png" alt="">&lt;/p>
&lt;p>强缓存是利用下面这两个 HTTP 响应头部（Response Header）字段实现的，它们都用来表示资源在客户端缓存的有效期：&lt;/p>
&lt;ul>
&lt;li>&lt;code>Cache-Control&lt;/code>， 是一个相对时间；&lt;/li>
&lt;li>&lt;code>Expires&lt;/code>，是一个绝对时间；&lt;/li>
&lt;/ul>
&lt;p>如果 HTTP 响应头部同时有 Cache-Control 和 Expires 字段的话，&lt;strong>Cache-Control 的优先级高于 Expires&lt;/strong> 。&lt;/p>
&lt;p>Cache-control 选项更多一些，设置更加精细，所以建议使用 Cache-Control 来实现强缓存。具体的实现流程如下：&lt;/p>
&lt;ul>
&lt;li>当浏览器第一次请求访问服务器资源时，服务器会在返回这个资源的同时，在 Response 头部加上 Cache-Control，Cache-Control 中设置了过期时间大小；&lt;/li>
&lt;li>浏览器再次请求访问服务器中的该资源时，会先&lt;strong>通过请求资源的时间与 Cache-Control 中设置的过期时间大小，来计算出该资源是否过期&lt;/strong>，如果没有，则使用该缓存，否则重新请求服务器；&lt;/li>
&lt;li>服务器再次收到请求后，会再次更新 Response 头部的 Cache-Control。&lt;/li>
&lt;/ul>
&lt;h3 id="什么是协商缓存">什么是协商缓存？&lt;/h3>
&lt;p>当我们在浏览器使用开发者工具的时候，你可能会看到过某些请求的响应码是 &lt;code>304&lt;/code>，这个是告诉浏览器可以使用本地缓存的资源，通常这种通过服务端告知客户端是否可以使用缓存的方式被称为协商缓存。&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/884948f1-0dd2-48b3-8dd0-41b261df0633/1649668520944-8c9a8b13-8145-4ffc-9334-3d5eb46c4231.png" alt="">&lt;/p>
&lt;p>上图就是一个协商缓存的过程，所以&lt;strong>协商缓存就是与服务端协商之后，通过协商结果来判断是否使用本地缓存&lt;/strong>。&lt;/p>
&lt;p>协商缓存可以基于两种头部来实现。&lt;/p>
&lt;p>第一种：请求头部中的 &lt;code>If-Modified-Since&lt;/code> 字段与响应头部中的 &lt;code>Last-Modified&lt;/code> 字段实现，这两个字段的意思是：&lt;/p>
&lt;ul>
&lt;li>响应头部中的 &lt;code>Last-Modified&lt;/code>：标示这个响应资源的最后修改时间；&lt;/li>
&lt;li>请求头部中的 &lt;code>If-Modified-Since&lt;/code>：当资源过期了，发现响应头中具有 Last-Modified 声明，则再次发起请求的时候带上 Last-Modified 的时间，服务器收到请求后发现有 If-Modified-Since 则与被请求资源的最后修改时间进行对比（Last-Modified），如果最后修改时间较新（大），说明资源又被改过，则返回最新资源，HTTP 200 OK；如果最后修改时间较旧（小），说明资源无新修改，响应 HTTP 304 走缓存。&lt;/li>
&lt;/ul>
&lt;p>第二种：请求头部中的 &lt;code>If-None-Match&lt;/code> 字段与响应头部中的 &lt;code>ETag&lt;/code> 字段，这两个字段的意思是：&lt;/p>
&lt;ul>
&lt;li>响应头部中 &lt;code>Etag&lt;/code>：唯一标识响应资源；&lt;/li>
&lt;li>请求头部中的 &lt;code>If-None-Match&lt;/code>：当资源过期时，浏览器发现响应头里有 Etag，则再次向服务器发起请求时，会将请求头 If-None-Match 值设置为 Etag 的值。服务器收到请求后进行比对，如果资源没有变化返回 304，如果资源变化了返回 200。&lt;/li>
&lt;/ul>
&lt;p>第一种实现方式是基于时间实现的，第二种实现方式是基于一个唯一标识实现的，相对来说后者可以更加准确地判断文件内容是否被修改，避免由于时间篡改导致的不可靠问题。&lt;/p>
&lt;p>如果 HTTP 响应头部同时有 Etag 和 Last-Modified 字段的时候， Etag 的优先级更高，也就是先会判断 Etag 是否变化了，如果 Etag 没有变化，然后再看  Last-Modified。&lt;/p>
&lt;p>注意，&lt;strong>协商缓存这两个字段都需要配合强制缓存中 Cache-control 字段来使用，只有在未能命中强制缓存的时候，才能发起带有协商缓存字段的请求&lt;/strong>。&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/884948f1-0dd2-48b3-8dd0-41b261df0633/1649668520918-e343317a-4c73-4f3c-b059-fc656dab9631.png" alt="">&lt;/p>
&lt;p>使用 ETag 字段实现的协商缓存的过程如下；&lt;/p>
&lt;ul>
&lt;li>当浏览器第一次请求访问服务器资源时，服务器会在返回这个资源的同时，在 Response 头部加上 ETag 唯一标识，这个唯一标识的值是根据当前请求的资源生成的；&lt;/li>
&lt;li>当浏览器再次请求访问服务器中的该资源时，首先会先检查强制缓存是否过期，如果没有过期，则直接使用本地缓存；如果缓存过期了，会在 Request 头部加上 If-None-Match 字段，该字段的值就是 ETag 唯一标识；&lt;/li>
&lt;li>服务器再次收到请求后，&lt;strong>会根据请求中的 If-None-Match 值与当前请求的资源生成的唯一标识进行比较&lt;/strong>：&lt;/li>
&lt;li>&lt;strong>如果值相等，则返回 304 Not Modified，不会返回资源&lt;/strong>；&lt;/li>
&lt;li>如果不相等，则返回 200 状态码和返回资源，并在 Response 头部加上新的 ETag 唯一标识；&lt;/li>
&lt;li>如果浏览器收到 304 的请求响应状态码，则会从本地缓存中加载资源，否则更新资源。&lt;/li>
&lt;/ul>
&lt;h3 id="xaxahttpsmpweixinqqcomsbuy220-ect00n4gno0697a">&lt;a href="https://mp.weixin.qq.com/s/bUy220-ect00N4gnO0697A">
&lt;/a>&lt;/h3></description></item><item><title>Docs: HTTP 相关的协议或规范</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/4.%E6%95%B0%E6%8D%AE%E9%80%9A%E4%BF%A1/%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/7.http/http-%E7%9B%B8%E5%85%B3%E7%9A%84%E5%8D%8F%E8%AE%AE%E6%88%96%E8%A7%84%E8%8C%83/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/4.%E6%95%B0%E6%8D%AE%E9%80%9A%E4%BF%A1/%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/7.http/http-%E7%9B%B8%E5%85%B3%E7%9A%84%E5%8D%8F%E8%AE%AE%E6%88%96%E8%A7%84%E8%8C%83/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;p>HTTP 无法单独存在，要想让它生效，必须依赖其他的协议或者规范&lt;/p>
&lt;h2 id="uri-与-url">URI 与 URL&lt;/h2>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Uniform_Resource_Identifier">Wiki&lt;/a>,&lt;a href="https://en.wikipedia.org/wiki/Uniform_Resource_Identifier">URI&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Internationalized_Resource_Identifier">Wiki&lt;/a>,&lt;a href="https://en.wikipedia.org/wiki/Internationalized_Resource_Identifier">IRI&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/URL">Wiki,URL&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Clean_URL">Wiki,CleanURL-slug&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Percent-encoding">Wiki,URL encoding&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.rfc-editor.org/rfc/rfc3986.html">RFC 3986,Uniform Resource Identifier(URI): Generic Syntax&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.rfc-editor.org/rfc/rfc1738">RFC 1738,Uniform Resource Locators (URL)&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.ruanyifeng.com/blog/2010/02/url_encoding.html">https://www.ruanyifeng.com/blog/2010/02/url_encoding.html&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>既然 HTTP 的本质是是在两点之间传输超文本，那么这个超文本又该如何表示呢？我们应该如何正确得找到这个超文本呢？所以，人们将超文本描述为 &lt;strong>Resource(资源)&lt;/strong>，互联网上如此之多得资源，就需要一个唯一标识符来标识每一个资源。URI 就是这么一个用来标识资源的规范。
**Uniform Resource Identifier(统一资源标识符，简称 URI) **是 Web 技术使用的唯一标识符。URI 可以用于标识任何东西，包括现实世界中的对象，例如人和地方，概念或信息资源，例如网页和书籍。某些 URI 提供了一种在网络上(在 Internet 上或在另一个专用网络上，例如在计算机文件系统或 Intranet 上)定位和检索信息资源的方法，它们是 &lt;strong>Uniform Resource Locator(统一资源定位符，简称 URL)&lt;/strong>。而其他 URI 仅提供一个唯一名称，而没有找到或检索该资源的信息，这类 URI 被称为 &lt;strong>Uniform Resource Name(统一资源名称，简称 URN)&lt;/strong>。&lt;/p>
&lt;blockquote>
&lt;p>尽管 URI 仍然是常用术语，但定义 URI 的规范已经被 Internationalized Resource Identifiers(国际化资源标识符，简称 IRI) 的规范所取代。IRI 扩展了 URI 的定义，以便 IRI 可以处理诸如 Kanji(汉字) 之类的字符集，而不是仅限于 ASCII。&lt;/p>
&lt;/blockquote>
&lt;p>**Uniform Resource Locator(统一资源定位符，简称 URL) **是 URI 的一种子集。
要强制区分 URL 和 URI/IRI 这两种标准化术语是很难的。实际上，两者都使用同一种算法，因此没必要强行区分二者的区别，而且 URL 这个词也更具有人气。所以没有必要强制区分 URI 与 URL。&lt;/p>
&lt;h3 id="url-syntaxurl-语法">URL Syntax(URL 语法)&lt;/h3>
&lt;p>URL 主要由四个部分组成：协议、主机、端口、路径
&lt;strong>Scheme:[//Authority]/Path[?query][#fragment]&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>&lt;strong>Scheme://&lt;/strong> # URL 方案，即访问协议,指定低层使用的协议(例如：http, https, ftp)&lt;/li>
&lt;li>&lt;strong>Authority&lt;/strong> # 分为三个部分 &lt;code>[UserInfo@]Host[:Port]&lt;/code>&lt;/li>
&lt;li>**UserInfo **# 认证信息。由于安全原因，现在这个年代，都省略这部分，而通过其他方式传递认证信息。&lt;/li>
&lt;li>&lt;strong>Host:PORT&lt;/strong> # 服务器 IP 地址或者域名:要访问的端口号&lt;/li>
&lt;li>&lt;strong>/PATH&lt;/strong> # 要访问的资源路径。即资源在主机上的存放相对路径。&lt;/li>
&lt;li>&lt;strong>QUERY&lt;/strong> # 其实就是参数。用于给动态网页或接口传递参数，可有多个参数，用“&amp;amp;”符号隔开，每个参数的名和值用“=”符号隔开。&lt;/li>
&lt;li>**Fragment **# 片段，主要用于浏览器中。当前页面的其中一段的位置，比如一篇小说有 N 个章节在统一页面显示，开头有目录，点击某一个章节会跳到该页面的某一段，该段的开头就是整个页面的片段，类似于一个位置锚定的作用，该字段即实现这个功能&lt;/li>
&lt;/ul>
&lt;h3 id="url-slug">URL slug&lt;/h3>
&lt;p>URL slug 是位于域扩展名之后的 URL 或链接的一部分。&lt;/p>
&lt;ul>
&lt;li>它们可用于网站：
&lt;ul>
&lt;li>&lt;a href="https://www.rebrandly.com/links">www.rebrandly.com/links&lt;/a> # &amp;rsquo;links&amp;rsquo; 是 URL Slug。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>或者它们可以用于您的自定义短链接：
&lt;ul>
&lt;li>rebrandly.rocks/content-curation # &amp;lsquo;content-curation&amp;rsquo; 是 URL slug。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h3 id="url-encodingurl-编码">URL Encoding(URL 编码)&lt;/h3>
&lt;p>通常来说，URL 只能使用英文字母、阿拉伯数字和某些标点符号。那么如果在 URL 中想使用其他字符，比如中文或某些特殊字符怎么办呢？
上述问题就是 URL 编码的由来。在初期，并没有 RFC 规定具体如何进行编码，而是由应用程序自行处理。这就导致 URL 编码称为一个混乱的领域。
在浏览器中，如果输入 &lt;code>http://www.google.com/你好&lt;/code>，则会被编码为 &lt;code>http://www.google.com/%E4%BD%A0%E5%A5%BD&lt;/code>。这里面的规则非常简单：&lt;/p>
&lt;ul>
&lt;li>你好 两个汉子的 UTF-8 编码结果为 E4 BD A0 E5 A5 BD，每个字节前面加上个 &lt;code>%&lt;/code>，就得到了 URL 编码。&lt;/li>
&lt;/ul>
&lt;h3 id="example">EXAMPLE&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span> userinfo host port
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ┌──┴───┐ ┌──────┴──────┐ ┌┴┐
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> https://john.doe@www.example.com:123/forum/questions/?tag&lt;span style="color:#f92672">=&lt;/span>networking&amp;amp;order&lt;span style="color:#f92672">=&lt;/span>newest#top
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> └─┬─┘ └───────────┬──────────────┘└───────┬───────┘ └───────────┬─────────────┘ └┬┘
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> scheme authority path query fragment
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ul>
&lt;li>&lt;code>unix:///run/containerd/containerd.sock&lt;/code> # 这也是 URI 的一种，这就是不同于网络定位符的地方，没有域名之类的东西。Scheme 后面直接接的是 PATH&lt;/li>
&lt;/ul>
&lt;h2 id="tcpip">TCP/IP&lt;/h2>
&lt;p>详见：&lt;a href="https://www.yuque.com/go/doc/33218376">TCP/IP 相关文章&lt;/a>&lt;/p>
&lt;h2 id="dns">DNS&lt;/h2>
&lt;p>详见：&lt;a href="https://www.yuque.com/go/doc/33218346">DNS 相关文章&lt;/a>&lt;/p></description></item><item><title>Docs: HTTP 优化</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/4.%E6%95%B0%E6%8D%AE%E9%80%9A%E4%BF%A1/%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/7.http/http-%E7%AE%A1%E7%90%86/http-%E4%BC%98%E5%8C%96/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/4.%E6%95%B0%E6%8D%AE%E9%80%9A%E4%BF%A1/%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/7.http/http-%E7%AE%A1%E7%90%86/http-%E4%BC%98%E5%8C%96/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;p>参考：&lt;a href="https://mp.weixin.qq.com/s/1Vb87OGa05a7zkbRrLsLGg">原文链接&lt;/a>&lt;/p>
&lt;p>问你一句：「*&lt;strong>* 你知道 HTTP/1.1 该如何优化吗？**&lt;/strong>」&lt;/p>
&lt;p>我想你第一时间想到的是，使用 KeepAlive 将 HTTP/1.1 从短连接改成长链接。&lt;/p>
&lt;p>这个确实是一个优化的手段，它是从底层的传输层这一方向入手的，通过减少 TCP 连接建立和断开的次数，来减少了网络传输的延迟，从而提高 HTTP/1.1 协议的传输效率。&lt;/p>
&lt;p>但其实还可以从其他方向来优化 HTTP/1.1 协议，比如有如下 3 种优化思路：&lt;/p>
&lt;ul>
&lt;li>&lt;em>尽量避免发送 HTTP 请求&lt;/em>；&lt;/li>
&lt;li>&lt;em>在需要发送 HTTP 请求时，考虑如何减少请求次数&lt;/em>；&lt;/li>
&lt;li>&lt;em>减少服务器的 HTTP 响应的数据大小&lt;/em>；&lt;/li>
&lt;/ul>
&lt;p>下面，就针对这三种思路具体看看有哪些优化方法。&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/wdgp8s/1649668055309-f75050df-d892-4df4-a1b8-485a3d983297.png" alt="">&lt;/p>
&lt;hr>
&lt;h3 id="1-如何避免发送-http-请求">1 如何避免发送 HTTP 请求？&lt;/h3>
&lt;p>这个思路你看到是不是觉得很奇怪，不发送 HTTP 请求，那还客户端还怎么和服务器交互数据？小林你这不是耍流氓嘛？&lt;/p>
&lt;p>冷静冷静，你说的没错，客户端当然要向服务器发送请求的。&lt;/p>
&lt;p>但是，对于一些具有重复性的 HTTP 请求，比如每次请求得到的数据都一样的，我们可以把这对「请求 - 响应」的数据都&lt;strong>缓存在本地&lt;/strong>，那么下次就直接读取本地的数据，不必在通过网络获取服务器的响应了，这样的话 HTTP/1.1 的性能肯定肉眼可见的提升。&lt;/p>
&lt;p>所以，避免发送 HTTP 请求的方法就是通过&lt;strong>缓存技术&lt;/strong>，HTTP 设计者早在之前就考虑到了这点，因此 HTTP 协议的头部有不少是针对缓存的字段。&lt;/p>
&lt;p>那缓存是如何做到的呢？&lt;/p>
&lt;p>客户端会把第一次请求以及响应的数据保存在本地磁盘上，其中将请求的 URL 作为 key，而响应作为 value，两者形成映射关系。&lt;/p>
&lt;p>这样当后续发起相同的请求时，就可以先在本地磁盘上通过 key 查到对应的 value，也就是响应，如果找到了，就直接从本地读取该响应。毋庸置疑，读取本次磁盘的速度肯定比网络请求快得多，如下图：&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/wdgp8s/1649668055405-5c6b569c-02bd-4e0a-b5e0-4fac6ceccdf9.png" alt="">&lt;/p>
&lt;p>聪明的你可能想到了，万一缓存的响应不是最新的，而客户端并不知情，那么该怎么办呢？&lt;/p>
&lt;p>放心，这个问题 HTTP 设计者早已考虑到。&lt;/p>
&lt;p>所以，服务器在发送 HTTP 响应时，会估算一个过期的时间，并把这个信息放到响应头部中，这样客户端在查看响应头部的信息时，一旦发现缓存的响应是过期的，则就会重新发送网络请求。HTTP 关于缓说明会的头部字段很多，这部分内容留在下次文章，这次暂时不具体说明。&lt;/p>
&lt;p>如果客户端从第一次请求得到的响应头部中发现该响应过期了，客户端重新发送请求，假设服务器上的资源并没有变更，还是老样子，那么你觉得还要在服务器的响应带上这个资源吗？&lt;/p>
&lt;p>很显然不带的话，可以提高 HTTP 协议的性能，那具体如何做到呢？&lt;/p>
&lt;p>只需要客户端在重新发送请求时，在请求的  &lt;code>Etag&lt;/code>  头部带上第一次请求的响应头部中的摘要，这个摘要是唯一标识响应的资源，当服务器收到请求后，会将本地资源的摘要与请求中的摘要做个比较。&lt;/p>
&lt;p>如果不同，那么说明客户端的缓存已经没有价值，服务器在响应中带上最新的资源。&lt;/p>
&lt;p>如果相同，说明客户端的缓存还是可以继续使用的，那么服务器&lt;strong>仅返回不含有包体的  &lt;strong>&lt;code>**304 Not Modified**&lt;/code>&lt;/strong>  响应&lt;/strong>，告诉客户端仍然有效，这样就可以减少响应资源在网络中传输的延时，如下图：&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/wdgp8s/1649668055482-075cc0a2-91a4-4ec0-9e71-91bcce17381b.png" alt="">&lt;/p>
&lt;p>缓存真的是性能优化的一把万能钥匙，小到 CPU Cache、Page Cache、Redis Cache，大到 HTTP 协议的缓存。&lt;/p>
&lt;hr>
&lt;h3 id="2-如何减少-http-请求次数">2 如何减少 HTTP 请求次数？&lt;/h3>
&lt;p>减少 HTTP 请求次数自然也就提升了 HTTP 性能，可以从这 3 个方面入手：&lt;/p>
&lt;ul>
&lt;li>&lt;em>减少重定向请求次数&lt;/em>；&lt;/li>
&lt;li>&lt;em>合并请求&lt;/em>；&lt;/li>
&lt;li>&lt;em>延迟发送请求&lt;/em>；&lt;/li>
&lt;/ul>
&lt;h4 id="21-减少重定向请求次数">2.1 减少重定向请求次数&lt;/h4>
&lt;p>我们先来看看什么是&lt;strong>重定向请求&lt;/strong>？&lt;/p>
&lt;p>服务器上的一个资源可能由于迁移、维护等原因从 url1 移至 url2 后，而客户端不知情，它还是继续请求 url1，这时服务器不能粗暴地返回错误，而是通过  &lt;code>302&lt;/code>  响应码和  &lt;code>Location&lt;/code>  头部，告诉客户端该资源已经迁移至 url2 了，于是客户端需要再发送 url2 请求以获得服务器的资源。&lt;/p>
&lt;p>那么，如果重定向请求越多，那么客户端就要多次发起 HTTP 请求，每一次的 HTTP 请求都得经过网络，这无疑会越降低网络性能。&lt;/p>
&lt;p>另外，服务端这一方往往不只有一台服务器，比如源服务器上一级是代理服务器，然后代理服务器才与客户端通信，这时客户端重定向就会导致客户端与代理服务器之间需要 2 次消息传递，如下图：&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/wdgp8s/1649668055379-b9c5c223-4625-4ce4-8af9-3a85613d2fd3.png" alt="">&lt;/p>
&lt;p>如果&lt;strong>重定向的工作交由代理服务器完成，就能减少 HTTP 请求次数了&lt;/strong>，如下图：&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/wdgp8s/1649668055355-3afcffb9-c9b0-4263-81a4-b7b472828862.png" alt="">&lt;/p>
&lt;p>而且当代理服务器知晓了重定向规则后，可以进一步减少消息传递次数，如下图：&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/wdgp8s/1649668056072-7ae663e5-5fcc-44ba-bd4a-e713d9bcd9d8.png" alt="">&lt;/p>
&lt;p>除了  &lt;code>302&lt;/code>  重定向响应码，还有其他一些重定向的响应码，你可以从下图看到：&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/wdgp8s/1649668056138-0b18be21-b2c0-4cc7-90df-5613477c941e.png" alt="">&lt;/p>
&lt;p>其中，&lt;code>301&lt;/code>  和  &lt;code>308&lt;/code>  响应码是告诉客户端可以将重定向响应缓存到本地磁盘，之后客户端就自动用 url2 替代 url1 访问服务器的资源。&lt;/p>
&lt;h4 id="22-合并请求">2.2 合并请求&lt;/h4>
&lt;p>如果把多个访问小文件的请求合并成一个大的请求，虽然传输的总资源还是一样，但是减少请求，也就意味着&lt;strong>减少了重复发送的 HTTP 头部&lt;/strong>。&lt;/p>
&lt;p>另外由于 HTTP/1.1 是请求响应模型，如果第一个发送的请求，未收到对应的响应，那么后续的请求就不会发送，于是为了防止单个请求的阻塞，所以一般浏览器会同时发起 5-6 个请求，每一个请求都是不同的 TCP 连接，那么如果合并了请求，也就会&lt;strong>减少 TCP 连接的数量，因而省去了 TCP 握手和慢启动过程耗费的时间&lt;/strong>。&lt;/p>
&lt;p>接下来，具体看看合并请求的几种方式。&lt;/p>
&lt;p>有的网页会含有很多小图片、小图标，有多少个小图片，客户端就要发起多少次请求。那么对于这些小图片，我们可以考虑使用  &lt;code>CSS Image Sprites&lt;/code>  技术把它们合成一个大图片，这样浏览器就可以用一次请求获得一个大图片，然后再根据 CSS 数据把大图片切割成多张小图片。&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/wdgp8s/1649668056210-aaa25f9e-eccf-45d3-a4ae-65a5a28597ec.png" alt="">&lt;/p>
&lt;p>图来源于：墨染枫林的 CSDN&lt;/p>
&lt;p>这种方式就是&lt;strong>通过将多个小图片合并成一个大图片来减少 HTTP 请求的次数，以减少 HTTP 请求的次数，从而减少网络的开销&lt;/strong>。&lt;/p>
&lt;p>除了将小图片合并成大图片的方式，还有服务端使用  &lt;code>webpack&lt;/code>  等打包工具将 js、css 等资源合并打包成大文件，也是能达到类似的效果。&lt;/p>
&lt;p>另外，还可以将图片的二进制数据用  &lt;code>base64&lt;/code>  编码后，以 URL 的形式潜入到 HTML 文件，跟随 HTML 文件一并发送.&lt;/p>
&lt;pre>&lt;code>&amp;lt;image src=&amp;quot;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAPoAAAFKCAIAAAC7M9WrAAAACXBIWXMAA ... /&amp;gt;
&lt;/code>&lt;/pre>
&lt;p>这样客户端收到 HTML 后，就可以直接解码出数据，然后直接显示图片，就不用再发起图片相关的请求，这样便减少了请求的次数。&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/wdgp8s/1649668056402-ae46bb78-755b-4a92-9da3-4c1738895cdc.png" alt="">&lt;/p>
&lt;p>图来源于：陈健平的 CSDN&lt;/p>
&lt;p>可以看到，&lt;strong>合并请求的方式就是合并资源，以一个大资源的请求替换多个小资源的请求&lt;/strong>。&lt;/p>
&lt;p>但是这样的合并请求会带来新的问题，&lt;strong>当大资源中的某一个小资源发生变化后，客户端必须重新下载整个完整的大资源文件&lt;/strong>，这显然带来了额外的网络消耗。&lt;/p>
&lt;h4 id="23-延迟发送请求">2.3 延迟发送请求&lt;/h4>
&lt;p>不要一口气吃成大胖子，一般 HTML 里会含有很多 HTTP 的 URL，当前不需要的资源，我们没必要也获取过来，于是可以通过「&lt;strong>按需获取&lt;/strong>」的方式，来减少第一时间的 HTTP 请求次数。&lt;/p>
&lt;p>请求网页的时候，没必要把全部资源都获取到，而是只获取当前用户所看到的页面资源，当用户向下滑动页面的时候，再向服务器获取接下来的资源，这样就达到了延迟发送请求的效果。&lt;/p>
&lt;hr>
&lt;h3 id="3-如何减少-http-响应的数据大小">3 如何减少 HTTP 响应的数据大小？&lt;/h3>
&lt;p>对于 HTTP 的请求和响应，通常 HTTP 的响应的数据大小会比较大，也就是服务器返回的资源会比较大。&lt;/p>
&lt;p>于是，我们可以考虑对响应的资源进行&lt;strong>压缩&lt;/strong>，这样就可以减少响应的数据大小，从而提高网络传输的效率。&lt;/p>
&lt;p>压缩的方式一般分为 2 种，分别是：&lt;/p>
&lt;ul>
&lt;li>&lt;em>无损压缩&lt;/em>；&lt;/li>
&lt;li>&lt;em>有损压缩&lt;/em>；&lt;/li>
&lt;/ul>
&lt;h4 id="31-无损压缩">3.1 无损压缩&lt;/h4>
&lt;p>无损压缩是指资源经过压缩后，信息不被破坏，还能完全恢复到压缩前的原样，适合用在文本文件、程序可执行文件、程序源代码。&lt;/p>
&lt;p>首先，我们针对代码的语法规则进行压缩，因为通常代码文件都有很多换行符或者空格，这些是为了帮助程序员更好的阅读，但是机器执行时并不要这些符，把这些多余的符号给去除掉。&lt;/p>
&lt;p>接下来，就是无损压缩了，需要对原始资源建立统计模型，利用这个统计模型，将常出现的数据用较短的二进制比特序列表示，将不常出现的数据用较长的二进制比特序列表示，生成二进制比特序列一般是「霍夫曼编码」算法。&lt;/p>
&lt;p>gzip 就是比较常见的无损压缩。客户端支持的压缩算法，会在 HTTP 请求中通过头部中的  &lt;code>Accept-Encoding&lt;/code>  字段告诉服务器：&lt;/p>
&lt;pre>&lt;code>Accept-Encoding: gzip, deflate, br
&lt;/code>&lt;/pre>
&lt;p>服务器收到后，会从中选择一个服务器支持的或者合适的压缩算法，然后使用此压缩算法对响应资源进行压缩，最后通过响应头部中的  &lt;code>content-encoding&lt;/code>  字段告诉客户端该资源使用的压缩算法。&lt;/p>
&lt;pre>&lt;code>content-encoding: gzip
&lt;/code>&lt;/pre>
&lt;p>gzip 的压缩效率相比 Google 推出的 Brotli 算法还是差点意思，也就是上文中的 br，所以如果可以，服务器应该选择压缩效率更高的 br 压缩算法。&lt;/p>
&lt;h4 id="32-有损压缩">3.2 有损压缩&lt;/h4>
&lt;p>与无损压缩相对的就是有损压缩，经过此方法压缩，解压的数据会与原始数据不同但是非常接近。&lt;/p>
&lt;p>有损压缩主要将次要的数据舍弃，牺牲一些质量来减少数据量、提高压缩比，这种方法经常用于压缩多媒体数据，比如音频、视频、图片。&lt;/p>
&lt;p>可以通过 HTTP 请求头部中的  &lt;code>Accept&lt;/code>  字段里的「 q 质量因子」，告诉服务器期望的资源质量。&lt;/p>
&lt;pre>&lt;code>Accept: audio/*; q=0.2, audio/basic
&lt;/code>&lt;/pre>
&lt;p>关于图片的压缩，目前压缩比较高的是 Google 推出的  &lt;strong>WebP 格式&lt;/strong>，它与常见的 Png 格式图片的压缩比例对比如下图：&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/wdgp8s/1649668056461-8cf206e8-fa3d-4df9-be2e-57709cb9cb6f.png" alt="">&lt;/p>
&lt;p>来源于：&lt;a href="https://isparta.github.io/compare-webp/index.html">https://isparta.github.io/compare-webp/index.html&lt;/a>&lt;/p>
&lt;p>可以发现，相同图片质量下，WebP 格式的图片大小都比 Png 格式的图片小，所以对于大量图片的网站，可以考虑使用 WebP 格式的图片，这将大幅度提升网络传输的性能。&lt;/p>
&lt;p>关于音视频的压缩，音视频主要是动态的，每个帧都有时序的关系，通常时间连续的帧之间的变化是很小的。&lt;/p>
&lt;p>比如，一个在看书的视频，画面通常只有人物的手和书桌上的书是会有变化的，而其他地方通常都是静态的，于是只需要在一个静态的关键帧，使用&lt;strong>增量数据&lt;/strong>来表达后续的帧，这样便减少了很多数据，提高了网络传输的性能。对于视频常见的编码格式有 H264、H265 等，音频常见的编码格式有 AAC、AC3。&lt;/p>
&lt;hr>
&lt;h3 id="总结">总结&lt;/h3>
&lt;p>这次主要从 3 个方面介绍了优化 HTTP/1.1 协议的思路。&lt;/p>
&lt;p>第一个思路是，通过缓存技术来避免发送 HTTP 请求。客户端收到第一个请求的响应后，可以将其缓存在本地磁盘，下次请求的时候，如果缓存没过期，就直接读取本地缓存的响应数据。如果缓存过期，客户端发送请求的时候带上响应数据的摘要，服务器比对后发现资源没有变化，就发出不带包体的 304 响应，告诉客户端缓存的响应仍然有效。&lt;/p>
&lt;p>第二个思路是，减少 HTTP 请求的次数，有以下的方法：&lt;/p>
&lt;ol>
&lt;li>将原本由客户端处理的重定向请求，交给代理服务器处理，这样可以减少重定向请求的次数；&lt;/li>
&lt;li>将多个小资源合并成一个大资源再传输，能够减少 HTTP 请求次数以及 头部的重复传输，再来减少 TCP 连接数量，进而省去 TCP 握手和慢启动的网络消耗；&lt;/li>
&lt;li>按需访问资源，只访问当前用户看得到 / 用得到的资源，当客户往下滑动，再访问接下来的资源，以此达到延迟请求，也就减少了同一时间的 HTTP 请求次数。&lt;/li>
&lt;/ol>
&lt;p>第三思路是，通过压缩响应资源，降低传输资源的大小，从而提高传输效率，所以应当选择更优秀的压缩算法。&lt;/p>
&lt;p>不管怎么优化 HTTP/1.1 协议都是有限的，不然也不会出现 HTTP/2 和 HTTP/3 协议，后续我们再来介绍 HTTP/2 和 HTTP/3 协议。&lt;/p>
&lt;p>好了，此次分享到这就结束了，如果这篇文章对你有帮助，欢迎来个三连，&lt;strong>你们的支持就是小林的最大动力&lt;/strong>，我们下次见！&lt;/p>
&lt;hr>
&lt;h6 id="巨人的肩膀">巨人的肩膀&lt;/h6>
&lt;ol>
&lt;li>&lt;a href="https://isparta.github.io/compare-webp/index.html">https://isparta.github.io/compare-webp/index.html&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://zh.wikipedia.org/wiki/https://en.wikipedia.org/wiki/Lossy_compression">https://zh.wikipedia.org/wiki/https://en.wikipedia.org/wiki/Lossy_compression&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Lossless_compression">https://en.wikipedia.org/wiki/Lossless_compression&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://time.geekbang.org/column/article/242667">https://time.geekbang.org/column/article/242667&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.tutorialrepublic.com/css-tutorial/css-sprites.php">https://www.tutorialrepublic.com/css-tutorial/css-sprites.php&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://blog.csdn.net/weixin_38055381/article/details/81504716">https://blog.csdn.net/weixin_38055381/article/details/81504716&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://blog.csdn.net/weixin_44151887/article/details/106278559">https://blog.csdn.net/weixin_44151887/article/details/106278559&lt;/a>&lt;/li>
&lt;/ol>
&lt;h6 id="推荐阅读">推荐阅读&lt;/h6>
&lt;h6 id="优化-https-的手段你知道几个httpmpweixinqqcoms__bizmzuxodazndg4nqmid2247488081idx1sna285752b4b1516830ba1f549323d3580chksmf98e56fbcef9dfedcfe006a920722a52bd865f0c1211ba8449cc55b32a7de2df1ddd88a25fb7scene21wechat_redirect">&lt;a href="http://mp.weixin.qq.com/s?__biz=MzUxODAzNDg4NQ==&amp;amp;mid=2247488081&amp;amp;idx=1&amp;amp;sn=a285752b4b1516830ba1f549323d3580&amp;amp;chksm=f98e56fbcef9dfedcfe006a920722a52bd865f0c1211ba8449cc55b32a7de2df1ddd88a25fb7&amp;amp;scene=21#wechat_redirect">优化 HTTPS 的手段，你知道几个？&lt;/a>&lt;/h6>
&lt;h6 id="硬核30-张图解-http-常见的面试题httpmpweixinqqcoms__bizmzuxodazndg4nqmid2247483971idx1sn8f2d5dae3d95efc446061b352c8e9961chksmf98e46e9cef9cfff1f6bee1974b8dc27dcc42f0627dcf8ff0c0df8dbaa7a1f74587e3fafc167scene21wechat_redirect">&lt;a href="http://mp.weixin.qq.com/s?__biz=MzUxODAzNDg4NQ==&amp;amp;mid=2247483971&amp;amp;idx=1&amp;amp;sn=8f2d5dae3d95efc446061b352c8e9961&amp;amp;chksm=f98e46e9cef9cfff1f6bee1974b8dc27dcc42f0627dcf8ff0c0df8dbaa7a1f74587e3fafc167&amp;amp;scene=21#wechat_redirect">硬核！30 张图解 HTTP 常见的面试题&lt;/a>&lt;/h6>
&lt;hr>
&lt;p>&lt;a href="https://mp.weixin.qq.com/s/1Vb87OGa05a7zkbRrLsLGg">https://mp.weixin.qq.com/s/1Vb87OGa05a7zkbRrLsLGg&lt;/a>&lt;/p></description></item><item><title>Docs: HTTP2</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/4.%E6%95%B0%E6%8D%AE%E9%80%9A%E4%BF%A1/%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/7.http/http2/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/4.%E6%95%B0%E6%8D%AE%E9%80%9A%E4%BF%A1/%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/7.http/http2/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://tools.ietf.org/html/rfc7540">RFC,7540&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://http2.github.io/">官网&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://mp.weixin.qq.com/s/WQpxfwLArltKEjEAdOO2Pw">51 张图助你彻底掌握 HTTP 协议&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://mp.weixin.qq.com/s/a83_NE-ww36FZsy320MQFQ">https://mp.weixin.qq.com/s/a83_NE-ww36FZsy320MQFQ&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>HTTP 2.0 在性能上实现了很大的飞跃，更难得的是它在改进的同时保持了语义的不变，与 HTTP 1.1 的语义完全相同！比如请求方法、URI、状态码、头字段等概念都保留不变，这样就消除了再学习的成本，在我们的日常软件升级中，&lt;strong>向下兼容&lt;/strong>非常重要，也是促进产品大规模使用的一个前提，不然你一升级，各种接口之类的全换了，谁还敢升。 &lt;strong>HTTP 2.0 只在语法上做了重要改进，完全变更了 HTTP 报文的传输格式&lt;/strong>&lt;/p>
&lt;p>在语法上主要实现了以下改造&lt;/p>
&lt;h3 id="1头部压缩">1、头部压缩&lt;/h3>
&lt;p>HTTP 1.1 考虑了 body 的压缩，但没有考虑 header 的压缩, 经常出现传了头部上百，上千字节，但 Body 却只有几十字节的情况，浪费了带宽，而且我们知道从 1.1 开始默认是长连接，几百上千个请求都用的这个连接，而请求的头部很多都是重复的，造成了带宽的极大浪费!想象一下面的这个请求，为了传输区区 「name=michale 」这几个字节，却要传输如此巨量的头部，浪费的带宽确实惊人。&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/ucykv5/1616161148212-dbadab6a-315e-4589-8750-cb9f05553948.png" alt="">&lt;/p>
&lt;p>那么 HTTP 2.0 是如何解决的呢？它开发了专门的 「HPACK」算法，在客户端和服务器两端建立字典，用索引号表示重复的字符串，还采用哈夫曼编码来压缩数字和整数，可以达到最高达 90% 的压缩率&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/ucykv5/1616161148192-45f35344-e164-46ee-aa3c-61a0bba6c732.png" alt="">&lt;/p>
&lt;p>这里简单解释下，头部压缩需要在支持 HTTP 2.0 的客户端和服务器之间：&lt;/p>
&lt;ol>
&lt;li>维护一份静态的字典（Static table），包含常见的头部名称，以及特别常见的头部名称与值的组合。这样的话如果请求响应命中了静态字典，直接发索引号即可&lt;/li>
&lt;li>维护一份相同的动态字典（Dynamic table），可以动态地添加字典，这样的话如果客户端首次请求由于「User-Agent: xxx」,「host:xxx」,「Cookie」这些的动态键值对没有命中静态字典，还是会传给服务器，但服务器收到后会基于传过来的键值对创建动态字典条目，如上图的「User-Agent: xxx」对应数字 62，「host:xxx」对应数字 63，这样双方都创建动态条目后，之后就可以用只传 62，63 这样的索引号来通信了！显而易见，传输数据急遽降低，极大地提升了传输效率！需要注意的是动态字典是每个连接自己维护的，也就是对于每个连接而言，首次都必须发送动态键值对&lt;/li>
&lt;li>支持基于静态哈夫曼码表的哈夫曼编码（Huffman Coding）：对于静态、动态字典中不存在的内容，可以使用哈夫曼编码来减小体积。HTTP/2 使用了一份静态哈夫曼码表（详见），也需要内置在客户端和服务端之中。&lt;/li>
&lt;/ol>
&lt;h3 id="2二进制格式">2、二进制格式&lt;/h3>
&lt;p>HTTP 1.1 是纯文本形式，而 2.0 是完全的二进制形式，它把 TCP 协议的部分特性挪到了应用层，把原来的 Header+Body 消息打散为了数个小版的二进制&amp;quot;帧&amp;quot;（Frame）,“HEADERS”帧存放头数据、“DATA”帧存放实体数据&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/ucykv5/1616161148271-6532e9c1-a86d-4794-ae42-de56f5188c1a.png" alt="">&lt;/p>
&lt;p>这些二进制帧只认 0，1，基于这种考虑 http 2.0 的协议解析决定采用二进制格式，使用二进制的形式虽然对人不友好，但&lt;strong>大大方便了计算机的解析&lt;/strong>，原来使用纯文本容易出现多义性，如大小写，空白字符等，程序在处理时必须用复杂的状态机，&lt;strong>效率低，还麻烦&lt;/strong>。而使用二进制的话可以严格规定字段大小、顺序、标志位等格式，“对就是对，错就是错”，&lt;strong>解析起来没有歧义，实现简单，而且体积小、速度快。&lt;/strong>&lt;/p>
&lt;h3 id="3-流">3. 流&lt;/h3>
&lt;p>HTTP 2 定义了「流」（stream）的的概念，它是二进制帧的双向传输序列，同一个消息往返的数据帧 （header 帧和 data 帧）会分配一个唯一的流 ID，这样我们就能区分每一个请求。在这个虚拟的流里，数据帧按先后次序传输，到达应答方后，将这些数据帧按它们的先后顺序组装起来，最后解析 HTTP 1.1 的请求头和实体。&lt;/p>
&lt;p>在&lt;strong>同一时间&lt;/strong>，请求方可以在流里发请求，应答方也可以也流里发响应，对比 HTTP 1.1 一个连接一次只能处理一次请求-应答，吞吐量大大提升&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/ucykv5/1616161148223-75161729-344f-4bd8-98f5-10f6f23aab4c.png" alt="">&lt;/p>
&lt;p>&lt;strong>如图示，一个连接里多个流可以同时收发请求-应答数据帧，每个流中数据包按序传输组装&lt;/strong>&lt;/p>
&lt;p>所有的流都是在同一个连接中流动的，这也是 HTTP 2.0 经典的&lt;strong>多路复用&lt;/strong>（ Multiplexing），另外由于每个流都是独立的，所以谁先处理好请求，谁就可以先将响应通过连接发送给对方，也就解决了队头阻塞的问题。&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/ucykv5/1616161148167-417e8e93-dbe1-43d6-b4b0-ffdda356eb36.png" alt="">&lt;/p>
&lt;p>&lt;strong>如图示，在 HTTP 2 中，两个请求同时发送，可以同时接收，而在 HTTP 1.1 中必须等上一个请求响应后才能处理下一个请求&lt;/strong>&lt;/p>
&lt;h3 id="http-2-的队头阻塞">HTTP 2 的队头阻塞&lt;/h3>
&lt;p>HTTP 2 引入的流，帧等语法层面的改造确实让其传输效率有了质的飞跃，但是它依然存在着队头阻塞，这是咋回事？&lt;/p>
&lt;p>其实主要是因为 HTTP 2 的分帧主要是在应用层处理的，而分帧最终还是要传给下层的 TCP 层经由它封装后再进行传输，每个连接最终还是顺序传输这些包，
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/ucykv5/1616161148187-3d17b319-06b7-4fb6-98cd-7a3ce63af1d8.png" alt="">
&lt;strong>如图示：流只是我们虚拟出来的概念，最终在连接层面还是顺序传的&lt;/strong>&lt;/p>
&lt;p>TCP 是可靠连接，为了保证这些包能顺序传给对方，会进行丢包重传机制，如果传了三个包，后两个包传成功，但第一个包传失败了，TCP 协议栈会把已收到的包暂存到缓存区中，停下等待第一个包的重传成功，这样的话在网络不佳的情况下只要一个包阻塞了，由于重传机制，后面的包就被阻塞了，上层应用由于拿不到包也只能干瞪眼了。&lt;/p>
&lt;p>由于这是 TCP 协议层面的机制，无法改造，所以 HTTP 2 的队头阻塞是不可避免的。HTTP 3 对此进行了改进，将 TCP 换成了 UDP 来进行传输，由于 UDP 是无序的，不需要断建连，包之间没有依赖关系，所以从根本上解决了“队头阻塞”, 当然由于 UDP 本身的这些特性不足以支撑可靠的通信，所以 Google 在 UDP 的基础上也加了 TCP 的连接管理，拥塞窗口，流量控制等机制，这套协议我们称之为 QUIC 协议。
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/ucykv5/1616161148202-483920df-f46e-43fc-83b2-75c6e80cd747.png" alt="">
可以看到不管是 HTTP 2 还是 3 它们底层都支持用 TLS，保留了 HTTPS 安全的特性，这也可以理解，在互联网发展如此迅猛的今天，各大企业也越来越重视通信安全。&lt;/p></description></item><item><title>Docs: HTTP3</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/4.%E6%95%B0%E6%8D%AE%E9%80%9A%E4%BF%A1/%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/7.http/http3/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/4.%E6%95%B0%E6%8D%AE%E9%80%9A%E4%BF%A1/%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/7.http/http3/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://mp.weixin.qq.com/s/Fwxfzzu6QdqyiYUI38afIQ"> &amp;gt; &lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;h1 id="quic">QUIC&lt;/h1>
&lt;ul>
&lt;li>原文：&lt;a href="https://mp.weixin.qq.com/s/Fwxfzzu6QdqyiYUI38afIQ">公众号-编程指北，如何用 UDP 实现可靠传输&lt;/a>&lt;/li>
&lt;/ul>
&lt;blockquote>
&lt;p>&lt;strong>自 2015 年以来，QUIC 协议开始在 IETF 进行标准化并被国内外各大厂商相继落地。鉴于 QUIC 具备“0RTT 建联”、“支持连接迁移”等诸多优势，并将成为下一代互联网协议：HTTP3.0 的底层传输协议，蚂蚁集团支付宝客户端团队与接入网关团队于 2018 年下半年开始在移动支付、海外加速等场景落地 QUIC。&lt;/strong>&lt;/p>
&lt;/blockquote>
&lt;p>本文是综述篇，介绍&lt;strong>QUIC&lt;/strong>  在蚂蚁的整体落地情况。&lt;/p>
&lt;p>之所以是综述，是因为 QUIC 协议过于复杂，如果对标已有的协议，QUIC 近似等于 HTTP + TLS +TCP，无法详细的毕其功于一役，因此我们通过综述的方式将落地的重点呈现给读者，主要介绍如下几个部分：&lt;/p>
&lt;ul>
&lt;li>QUIC 背景：简单全面的介绍下 QUIC 相关的背景知识&lt;/li>
&lt;li>方案选型设计：详细介绍蚂蚁的落地方案如何另辟蹊径、优雅的支撑 QUIC 的诸多特性，包括连接迁移等&lt;/li>
&lt;li>落地场景：介绍 QUIC 在蚂蚁的两个落地场景，包括：支付宝客户端链路以及海外加速链路&lt;/li>
&lt;li>几项关键技术：介绍落地 QUIC 过程中核心需要解决的问题，以及我们使用的方案，包括：“支持连接迁移”、“提升 0RTT 比例&amp;quot;， &amp;ldquo;支持 UDP 无损升级”以及“客户端智能选路”  等&lt;/li>
&lt;li>几项关键的技术专利&lt;/li>
&lt;/ul>
&lt;p>本文也是 QUIC 协议介绍的第一篇，后续我们会把更多的落地细节、体验优化手段、性能优化手段、安全与高可用、QUIC 新技术等呈现给大家。&lt;/p>
&lt;p>【注】蚂蚁 QUIC 开发团队包括：支付宝客户端团队的梅男、苍茫、述言，以及接入网关的伯琴、子荃、毅丝。&lt;/p>
&lt;p>&lt;strong>QUIC  背景介绍&lt;/strong>&lt;/p>
&lt;p>鉴于读者的背景可能不同，在开始本文之前，我们先简单介绍下 QUIC 相关的背景知识，如果您对这个协议的更多设计细节感兴趣，可以参见相关 Draft：&lt;a href="https://datatracker.ietf.org/wg/quic/documents/">https://datatracker.ietf.org/wg/quic/documents/&lt;/a>&lt;/p>
&lt;h2 id="一quic-是什么">&lt;strong>一、QUIC 是什么？&lt;/strong>&lt;/h2>
&lt;p>简单来说，QUIC (Quick UDP Internet Connections) 是一种基于 UDP 封装的安全   可靠传输协议，他的目标是取代 TCP 并自包含 TLS 成为标准的安全传输协议。下图是 QUIC 在协议栈中的位置，基于 QUIC 承载的 HTTP 协议进一步被标准化为 HTTP3.0。&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/ed23ba12-a45f-4b3f-a00e-fcf7716c950a/640" alt="">&lt;/p>
&lt;h2 id="二为什么是-quic-">&lt;strong>二、为什么是 QUIC ？&lt;/strong>&lt;/h2>
&lt;p>在 QUIC 出现之前，TCP 承载了 90% 多的互联网流量，似乎也没什么问题，那又为何会出现革命者 QUIC 呢？这主要是因为发展了几十年的 TCP 面临 “协议僵化问题”，表现在几方面：&lt;/p>
&lt;ol>
&lt;li>网络设备支持 TCP 时的僵化，表现在：对于一些防火墙或者 NAT 等设备，如果 TCP 引入了新的特性，比如增加了某些 TCP OPTION 等，可能会被认为是攻击而丢包，导致新特性在老的网络设备上无法工作。&lt;/li>
&lt;li>网络操作系统升级困难导致的 TCP 僵化，一些 TCP 的特性无法快速的被演进。&lt;/li>
&lt;li>除此之外，当应用层协议优化到 TLS1.3、 HTTP2.0 后， 传输层的优化也提上了议程，QUIC 在 TCP 基础上，取其精华去其糟粕具有如下的硬核优势：&lt;/li>
&lt;/ol>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/ed23ba12-a45f-4b3f-a00e-fcf7716c950a/640" alt="">&lt;/p>
&lt;h2 id="三quic-生态圈发展简史">&lt;strong>三、QUIC 生态圈发展简史&lt;/strong>&lt;/h2>
&lt;p>下图是 QUIC 从创建到现在为止的一些比较重要的时间节点，2021 年，QUIC V1 即将成为 RFC，结束百花齐放的态势。&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/ed23ba12-a45f-4b3f-a00e-fcf7716c950a/640" alt="">&lt;/p>
&lt;p>介绍完 QUIC 相关背景，之后我们来介绍蚂蚁的整个落地的内容，这里为了便于阐述，我们用蚂蚁 QUIC 的 一、二、三、四 来进行概括总结，即 “一套落地框架”、“两个落地场景”、“三篇创新专利保护”、“四项关键技术”。&lt;/p>
&lt;p>&lt;strong>一套落地框架&lt;/strong>&lt;/p>
&lt;p>蚂蚁的接入网关是基于多进程的 NGINX 开发的 (内部称为 Spanner，协议卸载的扳手)，而 UDP 在多进程编程模型上存在诸多挑战，典型的像无损升级等。为了设计一套完备的框架，我们在落地前充分考虑了服务端在云上部署上的方便性、扩展性、以及性能问题，设计了如下的落地框架以支撑不同的落地场景：&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/ed23ba12-a45f-4b3f-a00e-fcf7716c950a/640" alt="">&lt;/p>
&lt;p>在这套框架中，包括如下两个组件：&lt;/p>
&lt;ol>
&lt;li>QUIC LB 组件：基于 NGINX 4 层 UDP Stream 模块开发，用来基于 QUIC DCID 中携带的服务端信息进行路由，以支持连接迁移。&lt;/li>
&lt;li>NGINX QUIC 服务器：开发了 NGINX_QUIC_MODULE，每个 Worker 监听两种类型的端口：
（1）BASE PORT ，每个 Worker 使用的相同的端口号，以 Reuseport 的形式监听，并暴露给 QUIC LB，用以接收客户端过来的第一个 RTT 中的数据包，这类包的特点是 DCID 由客户端生成，没有路由信息。
（2）Working PORT，每个 Worker 使用的不同的端口号，是真正的工作端口，用以接收第一个 RTT 之后的 QUIC 包，这类包的特定是 DCID 由服务端的进程生成携带有服务端的信息。&lt;/li>
&lt;/ol>
&lt;p>当前框架支持的能力包括如下：&lt;/p>
&lt;ol>
&lt;li>在不用修改内核的情况下，完全在用户态支持 QUIC 的连接迁移，以及连接迁移时 CID 的 Update&lt;/li>
&lt;li>在不用修改内核的情况下，完全在用户态支持 QUIC 的无损升级以及其他运维问题&lt;/li>
&lt;li>支持真正意义上的 0RTT ，并可提升 0RTT 的比例&lt;/li>
&lt;/ol>
&lt;p>为何能支持上述能力，我们后面会展开叙述&lt;/p>
&lt;p>&lt;strong>两个落地场景&lt;/strong>&lt;/p>
&lt;p>我们由近及远的两个落地场景如下：&lt;/p>
&lt;p>&lt;strong>场景一、支付宝移动端落地&lt;/strong>&lt;/p>
&lt;p>如下为我们落地架构的示意图，支付宝手机客户端通过 QUIC 携带 HTTP 请求，通过 QUIC LB 等四层网关将请求转发到 Spanner （蚂蚁内部基于 NGINX 开发的 7 层网关），在 Spanner 上我们将 QUIC 请求 Proxy 成 TCP 请求，发送给业务网关（RS）。&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/ed23ba12-a45f-4b3f-a00e-fcf7716c950a/640" alt="">&lt;/p>
&lt;p>具体的方案选型如下：&lt;/p>
&lt;ul>
&lt;li>支持的 QUIC 版本是 gQUIC Q46。&lt;/li>
&lt;li>NGINX QUIC MODULE 支持 QUIC 的接入和 PROXY 成 TCP 的能力。&lt;/li>
&lt;li>支持包括移动支付、基金、蚂蚁森林在内的所有的 RPC 请求。&lt;/li>
&lt;li>当前选择 QUIC 链路的方式有两种 ：&lt;/li>
&lt;/ul>
&lt;ol>
&lt;li>Backup 模式，即在 TCP 链路无法使用的情况下，降级到 QUIC 链路。&lt;/li>
&lt;li>Smart 模式，即 TCP 和 QUIC 竞速，在 TCP 表现力弱于 QUIC 的情况下，下次请求主动使用 QUIC 链路。&lt;/li>
&lt;/ol>
&lt;p>在此场景下，通过使用 QUIC 可以获得的红利包括：&lt;/p>
&lt;ol>
&lt;li>在客户端连接发生迁移的时候，可以不断链继续服务&lt;/li>
&lt;li>客户端在首次发起连接时，可以节省 TCP 三次握手的时间&lt;/li>
&lt;li>对于弱网情况，QUIC 的传输控制可以带来传输性能提升&lt;/li>
&lt;/ol>
&lt;p>**场景二、**海外加速落地&lt;/p>
&lt;p>蚂蚁集团从 2018 年开始自研了海外的动态加速平台 AGNA（Ant Global Network Accelerator）以替换第三方厂商的加速服务。AGNA 通过在海外部署接入点：Local Proxy(LP) 以及在国内部署接出点：Remote Proxy （RP）的方式，将用户的海外请求通过 LP 和 RP 的加速链路回源国内。如下图所示，我们将 QUIC 部署在 LP 和 RP 之间的链路。&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/ed23ba12-a45f-4b3f-a00e-fcf7716c950a/640" alt="">&lt;/p>
&lt;p>在海外接入点上(LP)，每一个 TCP 连接都被 Proxy 成 QUIC 上的一个 Stream 进行承载，在国内接出点上(RP), 每一个 QUIC Stream 又被 Proxy 成一个 TCP 连接，LP 和 RP 之间使用 QUIC 长连接。&lt;/p>
&lt;p>在此场景下，通过使用 QUIC 可以获得的红利包括：&lt;/p>
&lt;ol>
&lt;li>通过 QUIC 长连接的上的 Stream 承载 TCP 请求，避免每次的跨海建联。&lt;/li>
&lt;li>对于跨海的网络，QUIC 的传输控制可以带来传输性能提升。&lt;/li>
&lt;/ol>
&lt;p>&lt;strong>三篇关键专利&lt;/strong>&lt;/p>
&lt;p>到目前为止，我们把落地过程中一些创新的技术点通过申请专利进行了保护，并积极在 IETF 进行标准化分享我们的研究成果，包括：&lt;/p>
&lt;h3 id="专利一">&lt;strong>专利一&lt;/strong>&lt;/h3>
&lt;p>我们将落地场景 2 中，通过 QUIC Stream 进行四层代理的手段来进行海外回源的加速方法进行专利保护，提出：“一种基于 QUIC 协议代理的的链路加速方法”，目前此专利已经获得美国专利授权，专利号：CN110213241A。&lt;/p>
&lt;h3 id="专利二">&lt;strong>专利二&lt;/strong>&lt;/h3>
&lt;p>将我们落地框架中的 QUIC LB 组件作为专利进行保护，提出：“一种无状态、一致性、分布式的 QUIC 负载均衡设备”，目前此专利还在受理中。由于通过 QUIC LB 可以很好的支持 QUIC 协议的连接迁移问题，所以目前 IETF QUIC WG 上有关于 QUIC LB 相关的草案，我们目前已经参与到 Draft 的讨论和制定中，后序相关的方案也会继续推广到云上产品。&lt;/p>
&lt;h3 id="专利三">&lt;strong>专利三&lt;/strong>&lt;/h3>
&lt;p>将我们解决的 UDP 的无损升级方法进行专利保护，提出 “一种 QUIC 服务器无损升级方案”，目前此专利还在受理中。由于 UDP 无损升级问题是一个业界难题，当前有些手段需要在用户态进行跳转，性能损失较大，我们的方案可以在我们的落地框架中解决当前问题，关于这个方案的细节我们再后面的关键技术中进行介绍。&lt;/p>
&lt;p>&lt;strong>四项关键技术&lt;/strong>&lt;/p>
&lt;p>在整个的落地中，我们设计的方案围绕解决几个核心问题展开，形成了四项关键技术，分别如下&lt;/p>
&lt;h4 id="技术点-1优雅的支持连接迁移能力">&lt;strong>技术点 1.优雅的支持连接迁移能力&lt;/strong>&lt;/h4>
&lt;h4 id="先说-连接迁移面临的问题-上文有提到quic-有一项比较重要的功能是支持连接迁移这里的连接迁移是指如果客户端在长连接保持的情况下切换网络比如从-4g-切换到-wifi--或者因为-nat-rebinding-导致五元组发生变化quic-依然可以在新的五元组上继续进行连接状态quic-之所以能支持连接迁移一个原因是-quic-底层是基于无连接的-udp另一个重要原因是因为-quic-使用唯一的-cid-来标识一个连接而不是五元组">先说  **连接迁移面临的问题 ，**上文有提到，QUIC 有一项比较重要的功能是支持连接迁移。这里的连接迁移是指：如果客户端在长连接保持的情况下切换网络，比如从 4G 切换到 Wifi , 或者因为 NAT Rebinding 导致五元组发生变化，QUIC 依然可以在新的五元组上继续进行连接状态。QUIC 之所以能支持连接迁移，一个原因是 QUIC 底层是基于无连接的 UDP，另一个重要原因是因为 QUIC 使用唯一的 CID 来标识一个连接，而不是五元组。&lt;/h4>
&lt;p>如下图所示，是 QUIC 支持连接的一个示意图，当客户端出口地址从 A 切换成 B 的时候，因为 CID 保持不变，所以在 QUIC 服务器上，依然可以查询到对应的 Session 状态。&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/ed23ba12-a45f-4b3f-a00e-fcf7716c950a/640" alt="">&lt;/p>
&lt;p>然而，理论很丰满，落地却很艰难，在端到端的落地过程中，因为引入了负载均衡设备，会导致在连接迁移时，所有依赖五元组 Hash 做转发或者关联 Session 的机制失效。以 LVS 为例，连接迁移后， LVS 依靠五元组寻址会导致寻址的服务器存在不一致。即便 LVS 寻址正确，当报文到达服务器时，内核根据五元组关联进程，依然会寻址出错。同时，IETF Draft 要求，连接迁移时 CID 需要更新掉，这就为仅依靠 CID 来转发的计划同样变的不可行。&lt;/p>
&lt;h4 id="再说-我们的解决方法为了解决此问题我们设计了开篇介绍的落地框架这里我们将方案做一些简化和抽象整体思路如下图所示">再说  **我们的解决方法，**为了解决此问题，我们设计了开篇介绍的落地框架，这里我们将方案做一些简化和抽象，整体思路如下图所示：&lt;/h4>
&lt;ol>
&lt;li>在四层负载均衡上，我们设计了 QUIC LoadBalancer 的机制：&lt;/li>
&lt;li>我们在 QUIC 的 CID 中扩展了一些字段（ServerInfo）用来关联 QUIC Server 的 IP 和 Working Port 信息。&lt;/li>
&lt;li>在发生连接迁移的时候，QUIC LoadBalancer 可以依赖 CID 中的 ServerInfo 进行路由，避免依赖五元组关联 Session 导致的问题。&lt;/li>
&lt;li>在 CID 需要 Update 的时候，NewCID 中的 ServerInfo 保留不变，这样就避免在 CID 发生 Update 时，仅依赖 CID Hash 挑选后端导致的寻址不一致问题。&lt;/li>
&lt;li>在 QUIC 服务器多进程工作模式上，我们突破了 NGINX 固有的多 Worker 监听在相同端口上的桎梏，设计了多端口监听的机制，每个 Worker 在工作端口上进行隔离，并将端口的信息携带在对 First Initial Packet 的回包的 CID 中，这样代理的好处是：&lt;/li>
&lt;li>无论是否连接迁移，QUIC LB 都可以根据 ServerInfo，将报文转发到正确的进程。&lt;/li>
&lt;li>而业界普遍的方案是修改内核，将 Reuse port 机制改为 Reuse CID 机制，即内核根据 CID 挑选进程。即便后面可以通过 ebpf 等手段支持，但我们认为这种修改内核的机制对底层过于依赖，不利于方案的大规模部署和运维，尤其在公有云上。&lt;/li>
&lt;li>使用独立端口，也有利于多进程模式下，UDP 无损升级问题的解决，这个我们在技术点 3 中介绍。&lt;/li>
&lt;/ol>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/ed23ba12-a45f-4b3f-a00e-fcf7716c950a/640" alt="">&lt;/p>
&lt;p>&lt;strong>技术点 2.提升  0RTT  握手比例&lt;/strong>&lt;/p>
&lt;h4 id="这里先-介绍-quic-0rtt-原理前文我们介绍过-quic-支持传输层握手和安全加密层握手都在一个-0rtt-内完成tls13-本身就支持加密层握手的-0rtt所以不足为奇而-quic-如何实现传输层握手支持-0rtt-呢我们先看下传输层握手的目的即服务端校验客户端是真正想握手的客户端地址不存在欺骗从而避免伪造源地址攻击在-tcp-中服务端依赖三次握手的最后一个-ack-来校验客户端是真正的客户端即只有真正的客户端才会收到-sever-的-syn_ack-并回复">这里先  &lt;strong>介绍 QUIC 0RTT 原理&lt;/strong>。前文我们介绍过， QUIC 支持传输层握手和安全加密层握手都在一个 0RTT 内完成。TLS1.3 本身就支持加密层握手的 0RTT，所以不足为奇。而 QUIC 如何实现传输层握手支持 0RTT 呢？我们先看下传输层握手的目的，即：服务端校验客户端是真正想握手的客户端，地址不存在欺骗，从而避免伪造源地址攻击。在 TCP 中，服务端依赖三次握手的最后一个 ACK 来校验客户端是真正的客户端，即只有真正的客户端才会收到 Sever 的 syn_ack 并回复。&lt;/h4>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/ed23ba12-a45f-4b3f-a00e-fcf7716c950a/640" alt="">&lt;/p>
&lt;p>QUIC 同样需要对握手的源地址做校验，否则便会存在 UDP 本身的 DDOS 问题，那 QUIC 是如何实现的？依赖 STK(Source Address Token) 机制。这里我们先声明下，跟 TLS 类似，QUIC 的 0RTT 握手，是建立在已经同一个服务器建立过连接的基础上，所以如果是纯的第一次连接，仍然需要一个 RTT 来获取这个 STK。如下图所示，我们介绍下这个原理：&lt;/p>
&lt;ol>
&lt;li>类似于 Session Ticket 原理，Server 会将客户端的地址和当前的 Timestamp 通过自己的 KEY 加密生成 STK。&lt;/li>
&lt;li>Client 下次握手的时候，将 STK 携带过来，由于 STK 无法篡改，所以 Server 通过自己的 KEY 解密，如果解出来的地址和客户端此次握手的地址一致，且时间在有效期内，则表示客户端可信，便可以建立连接。&lt;/li>
&lt;li>由于客户端第一次握手的时候，没有这个 STK，所以服务度会回复 REJ 这次握手的信息，并携带 STK。&lt;/li>
&lt;/ol>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/ed23ba12-a45f-4b3f-a00e-fcf7716c950a/640" alt="">&lt;/p>
&lt;p>理论上说，只要客户端缓存了这个 STK，下次握手的时候带过来，服务端便可以直接校验通过，即实现传输层的 0RTT。但是真实的场景却存在&lt;strong>如下两个问题&lt;/strong>：&lt;/p>
&lt;ol>
&lt;li>因为 STK 是服务端加密的，所以如果下次这个客户端路由到别的服务器上了，则这个服务器也需要可以识别出来。&lt;/li>
&lt;li>STK 中 encode 的是上一次客户端的地址，如果下一次客户端携带的地址发生了变化，则同样会导致校验失败。此现象在移动端发生的概率非常大，尤其是 IPV6 场景下，客户端的出口地址会经常发生变化。&lt;/li>
&lt;/ol>
&lt;h4 id="再介绍下我们的解决方法-第一个问题比较好解我们只要保证集群内的机器生成-stk-的秘钥一致即可第二个问题我们的解题思路是">再介绍下&lt;strong>我们的解决方法。&lt;/strong> 第一个问题比较好解，我们只要保证集群内的机器生成 STK 的秘钥一致即可。&lt;strong>第二个问题，我们的解题思路是&lt;/strong>：&lt;/h4>
&lt;ol>
&lt;li>我们在 STK 中扩展了一个 Client ID, 这个 Clinet ID 是客户端通过无线保镖黑盒生成并全局唯一不变的，类似于一个设备的 SIMID，客户端通过加密的 Trasnport Parameter 传递给服务端，服务端在 STK 中包含这个 ID。&lt;/li>
&lt;li>如果因为 Client IP 发生变化导致校验 STK 校验失败，便会去校验 Client ID，因为 ID 对于一个 Client 是永远不变的，所以可以校验成功，当然前提是，这个客户端是真实的。为了防止 Client ID 的泄露等，我们会选择性对 Client ID 校验能力做限流保护。&lt;/li>
&lt;/ol>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/ed23ba12-a45f-4b3f-a00e-fcf7716c950a/640" alt="">&lt;/p>
&lt;h4 id="技术点-3-支持-quic-无损升级">&lt;strong>技术点 3. 支持 QUIC 无损升级&lt;/strong>&lt;/h4>
&lt;h4 id="我们知道-udp-无损升级是业界难题-无损升级是指在-reload-或者更新二进制时老的进程可以处理完存量连接上的数据后优雅退出以-nginx-为例这里先介绍下-tcp-是如何处理无损升级的主要是如下的两个步骤">我们知道  &lt;strong>UDP 无损升级是业界难题。&lt;/strong> 无损升级是指在 reload 或者更新二进制时，老的进程可以处理完存量连接上的数据后优雅退出。以 NGINX 为例，这里先介绍下 TCP 是如何处理无损升级的，主要是如下的两个步骤：&lt;/h4>
&lt;ol>
&lt;li>老进程先关闭 listening socket，待存量连接请求都结束后，再关闭连接套接字&lt;/li>
&lt;li>新进程从老进程继承 listening socket , 开始 accept 新的请求&lt;/li>
&lt;/ol>
&lt;p>而 UDP 无法做到无损升级是因为 UDP 只有一个 listening socket 没有类似 TCP 的连接套接字，所有的收发数据包都在这个 socket 上，导致下面的热升级步骤会存在问题：&lt;/p>
&lt;ol>
&lt;li>在热升级的时候，old process fork 出 new process 后，new process 会继承 listening socket 并开始 recv msg。&lt;/li>
&lt;li>而 old process 此时如果关闭 listenging socket， 则在途的数据包便无法接收，达不到优雅退出的目的。&lt;/li>
&lt;li>而如果继续监听，则新老进程都会同时收取新连接上的报文，导致老进程无法退出。&lt;/li>
&lt;/ol>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/ed23ba12-a45f-4b3f-a00e-fcf7716c950a/640" alt="">&lt;/p>
&lt;h4 id="这里介绍下相关的解决方法-针对此问题业界有一些方法比如在数据包中携带进程号当数据包收发错乱后在新老进程之间做一次转发考虑到接入层上的性能等原因我们不希望数据再做一次跳转结合我们的落地架构我们设计了如下的-基于多端口轮转的无损升级方案简单来说我们让新老进程监听在不同的端口组并携带在-cid-中这样-quic-lb-就可以根据端口转发到新老进程为了便于运维我们采用端口轮转的方式新老进程会在-reload-n-次之后重新开始之前选中的端口如下图所示">这里介绍下&lt;strong>相关的解决方法。&lt;/strong> 针对此问题，业界有一些方法，比如：在数据包中携带进程号，当数据包收发错乱后，在新老进程之间做一次转发。考虑到接入层上的性能等原因，我们不希望数据再做一次跳转。结合我们的落地架构，我们设计了如下的  &lt;strong>基于多端口轮转的无损升级方案&lt;/strong>，简单来说，我们让新老进程监听在不同的端口组并携带在 CID 中，这样 QUIC LB 就可以根据端口转发到新老进程。为了便于运维，我们采用端口轮转的方式，新老进程会在 reload N 次之后，重新开始之前选中的端口。如下图所示：&lt;/h4>
&lt;ol>
&lt;li>无损升级期间，老进程的 Baseport 端口关闭，这样不会再接受 first intial packet, 类似于关闭了 tcp 的 listening socket。&lt;/li>
&lt;li>老进程的工作端口，继续工作，用来接收当前进程上残余的流量。&lt;/li>
&lt;li>新进程的 Baseport 开始工作，用来接收 first initial packet, 开启新的连接，类似于开启了 tcp 的 listening socket。&lt;/li>
&lt;li>新进程的 working port = (I + 1) mod N,  N 是指同时支持新老进程的状态的次数，例如 N = 4， 表示可以同时 reload 四次，四种 Old, New1, New2, New3 四种状态同时并存，I 是上一个进程工作的端口号，这里 + 1 是因为只有一个 worker, 如果 worker 数有 M 个，则加 M。&lt;/li>
&lt;li>建好的连接便被 Load Balancer 转移到新进程的监听端口的 Working Port 上。&lt;/li>
&lt;/ol>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/ed23ba12-a45f-4b3f-a00e-fcf7716c950a/640" alt="">&lt;/p>
&lt;p>&lt;strong>技术点 4.客户端智能选路&lt;/strong>&lt;/p>
&lt;p>尽管落地 QUIC 的愿望是好的，但是新事物的发展并不是一帆风顺的。由于 QUIC 是基于 UDP 的，而 UDP 相比于 TCP 在运营商的支持上并非友好，表现在：&lt;/p>
&lt;ol>
&lt;li>在带宽紧张的时候，UDP 会经常被限流。&lt;/li>
&lt;li>一些防火墙对于 UDP 包会直接 Drop。&lt;/li>
&lt;li>NAT 网关针对 UDP 的 Session 存活时间也较短。&lt;/li>
&lt;/ol>
&lt;p>同时，根据观察发现，不同的手机厂商对于 UDP 的支持能力也不同，所以在落地过程中，如果盲目的将所有流量完全切为 QUIC 可能会导致一些难以预料的结果。为此，我们在客户端上，设计了开篇介绍的 TCP 和 QUIC 相互 Backup 的链路，如下图所示，我们实时探测 TCP 链路和 QUIC 链路的 RTT、丢包率、请求完成时间、错误率等指标情况，并根据一定的量化方法对两种链路进行打分，根据评分高低，决定选择走哪种链路，从而避免寻址只走一条链路导致的问题。&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/ed23ba12-a45f-4b3f-a00e-fcf7716c950a/640" alt="">&lt;/p>
&lt;p>&lt;strong>做个总结&lt;/strong>&lt;/p>
&lt;p>本文主要综述性的介绍了 QUIC 在蚂蚁的落地方案、场景以及一些关键技术。&lt;strong>关键技术上&lt;/strong>，主要介绍了我们如何通过创造性的提出 QUIC LB 组件、以及多端口监听的机制来优雅的支持  QUIC 的连接迁移机制、QUIC 服务端的无损升级等，依赖这套方案我们的接入网关不需要像业界一样依赖底层内核的改动，这极大的方便了我们方案的部署，尤其在公有云场景下。除了连接迁移以外，我们还提出了 0RTT 建联提升方案、客户端智能选路方案，以最大化 QUIC 在移动端上的收益。截止当前，QUIC 已经在支付宝移动端以及全球加速链路&lt;strong>两个场景&lt;/strong>上平稳运行，并带来了较好的业务收益。&lt;/p>
&lt;p>&lt;strong>未来规划&lt;/strong>&lt;/p>
&lt;p>两年来，我们主要以社区的 gQuic 为基础，充分发挥 QUIC 的协议优势，并结合蚂蚁的业务特征以最大化移动端收益为目标，创造性的提出了一些解决方案，并积极向社区和 IETF 进行推广。在未来，随着蚂蚁在更多业务上的开展和探索以及 HTTP3.0/QUIC 即将成为标准，我们会主要围绕以下几个方向继续深挖 QUIC 的价值：&lt;/p>
&lt;ol>
&lt;li>我们将利用 QUIC 在应用层实现的优势，设计一套统一的具备自适应业务类型和网络类型的 QUIC 传输控制框架，对不同类型的业务和网络类型，做传输上的调优，以优化业务的网络传输体验。&lt;/li>
&lt;li>将 gQUIC 切换成 IETF QUIC，推进标准的 HTTP3.0 在蚂蚁的进一步落地。&lt;/li>
&lt;li>将蚂蚁的 QUIC LB 技术点向 IETF QUIC LB 进行推进，并最终演变为标准的 QUIC LB。&lt;/li>
&lt;li>探索并落地 MPQUIC（多路径 QUIC）  技术，最大化在移动端的收益。&lt;/li>
&lt;li>继续 QUIC 的性能优化工作，使用 UDP GSO， eBPF，io_uring 等内核技术。&lt;/li>
&lt;li>探索 QUIC 在内网承载东西向流量的机会。&lt;/li>
&lt;/ol></description></item><item><title>Docs: HTTPS</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/4.%E6%95%B0%E6%8D%AE%E9%80%9A%E4%BF%A1/%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/7.http/https/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/4.%E6%95%B0%E6%8D%AE%E9%80%9A%E4%BF%A1/%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/7.http/https/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;p>**Hyper Text Transfer Protocol over Secure Socket Layer(简称 HTTPS) **是以安全为目标的 HTTP 通道，简单讲是 HTTP 的安全版。即 HTTP 下加入 SSL 层，HTTPS 的安全基础是 SSL，因此加密的详细内容就需要 SSL。 它是一个 URI scheme（抽象标识符体系），句法类同 http:体系。用于安全的 HTTP 数据传输。https://URL 表明它使用了 HTTP，但 HTTPS 存在不同于 HTTP 的默认端口及一个加密/身份验证层（在 HTTP 与 TCP 之间）。这个系统的最初研发由网景公司(Netscape)进行，并内置于其浏览器 Netscape Navigator 中，提供了身份验证与加密通讯方法。现在它被广泛用于万维网上安全敏感的通讯，例如交易支付方面。&lt;/p>
&lt;h2 id="http-和-https-区别">HTTP 和 HTTPS 区别&lt;/h2>
&lt;p>https 本质是 http 与 ssl 结合的协议，并没有绝对意义上的 https 协议。需要到 ca 申请证书，一般免费证书很少，需要交费。&lt;/p>
&lt;p>http 是超文本传输协议，信息是明文传输，https 则是具有安全性的 ssl 加密传输协议 http 和 https 使用的是完全不同的连接方式用的端口也不一样：前者是 80，后者是 443。&lt;/p>
&lt;p>http 的连接很简单，是无状态的 HTTPS 协议是由 SSL+HTTP 协议构建的可进行加密传输、身份认证的网络协议 要比 http 协议安全&lt;/p>
&lt;h2 id="https-解决的问题">HTTPS 解决的问题&lt;/h2>
&lt;p>（1）信任主机的问题。&lt;/p>
&lt;p>采用 https 的 server 必须从 CA 申请一个用于证明服务器用途类型的证书。&lt;/p>
&lt;p>该证书只有用于对应的 server 的时候，客户度才信任次主机。所以目前所有的银行系统网站，关键部分应用都是 https 的。 客户通过信任该证书，从而信任了该主机。其实这样做效率很低，但是银行更侧重安全。 这一点对我们没有任何意义，我们的 server，采用的证书不管自己 issue 还是从公众的地方 issue， 客户端都是自己人，所以我们也就肯定信任该 server。&lt;/p>
&lt;p>（2）通讯过程中的数据的泄密和被窜改。&lt;/p>
&lt;p>1)一般意义上的 https， 就是 server 有一个证书。&lt;/p>
&lt;p>a) 主要目的是保证 server 就是他声称的 server。这个跟第一点一样。&lt;/p>
&lt;p>b) 服务端和客户端之间的所有通讯，都是加密的。&lt;/p>
&lt;p>i、具体讲，是客户端产生一个对称的密钥，通过 server 的证书来交换密钥。 一般意义上的握手过程。&lt;/p>
&lt;p>ii、加下来所有的信息往来就都是加密的。 第三方即使截获，也没有任何意义。因为他没有密钥。 当然窜改也就没有什么意义了。&lt;/p>
&lt;p>2)少许对客户端有要求的情况下，会要求客户端也必须有一个证书。&lt;/p>
&lt;p>a) 这里客户端证书，其实就类似表示个人信息的时候，除了用户名/密码， 还有一个 CA 认证过的身份。 应为个人证书一般来说上别人无法模拟的，所有这样能够更深的确认自己的身份。&lt;/p>
&lt;p>b) 目前少数个人银行的专业版是这种做法，具体证书可能是拿 U 盘作为一个备份的载体。像我用的交通银行的网上银行就是采取的这种方式。 HTTPS 一定是繁琐的。&lt;/p>
&lt;p>a) 本来简单的 http 协议，一个 get 一个 response。由于 https 要还密钥和确认加密算法的需要。单握手就需要 6/7 个往返。&lt;/p>
&lt;p>i、任何应用中，过多的 round trip 肯定影响性能。&lt;/p>
&lt;p>b) 接下来才是具体的 http 协议，每一次响应或者请求， 都要求客户端和服务端对会话的内容做加密/解密。&lt;/p>
&lt;p>i、尽管对称加密/解密效率比较高，可是仍然要消耗过多的 CPU，为此有专门的 SSL 芯片。 如果 CPU 信能比较低的话，肯定会降低性能，从而不能 serve 更多的请求。&lt;/p>
&lt;p>附 SSL 的简介&lt;/p>
&lt;p>SSL 是 Netscape 公司所提出的安全保密协议，在浏览器(如 Internet Explorer、Netscape Navigator)和 Web 服务器(如 Netscape 的 Netscape Enterprise Server、ColdFusion Server 等等)之间构造安全通道来进行数据传输，SSL 运行在 TCP/IP 层之上、应用层之下，为应用程序提供加密数据通道，它采用了 RC4、MD5 以及 RSA 等加密算法，使用 40 位的密钥，适用于商业信息的加密。&lt;/p>
&lt;p>同时，Netscape 公司相应开发了 HTTPS 协议并内置于其浏览器中，HTTPS 实际上就是 SSL over HTTP，它使用默认端口 443，而不是像 HTTP 那样使用端口 80 来和 TCP/IP 进行通信。HTTPS 协议使用 SSL 在发送方把原始数据进行加密，然 后在接受方进行解密，加密和解密需要发送方和接受方通过交换共知的密钥来实现，因此，所传送的数据不容易被网络黑客截获和解密。&lt;/p>
&lt;p>然而，加密和解密过程需要耗费系统大量的开销，严重降低机器的性能，相关测试数据表明使用 HTTPS 协议传输数据的工作效率只有使用 HTTP 协议传输的十分之一。&lt;/p>
&lt;p>假如为了安全保密，将一个网站所有的 Web 应用都启用 SSL 技术来加密，并使用 HTTPS 协议进行传输，那么该网站的性能和效率将会大大降低，而且 没有这个必要，因为一般来说并不是所有数据都要求那么高的安全保密级别，所以，我们只需对那些涉及机密数据的交互处理使用 HTTPS 协议，这样就做到鱼与 熊掌兼得。总之不需要用 https 的地方，就尽量不要用。&lt;/p>
&lt;h1 id="双向认证">双向认证&lt;/h1>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/qygdgr/1660900843557-9912cd1f-2f59-4860-97e3-f9a8640772bf.png" alt="">&lt;/p></description></item><item><title>Docs: HTTPS 交互流程(ECDHE 算法)</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/4.%E6%95%B0%E6%8D%AE%E9%80%9A%E4%BF%A1/%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/7.http/https/https-%E4%BA%A4%E4%BA%92%E6%B5%81%E7%A8%8Becdhe-%E7%AE%97%E6%B3%95/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/4.%E6%95%B0%E6%8D%AE%E9%80%9A%E4%BF%A1/%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/7.http/https/https-%E4%BA%A4%E4%BA%92%E6%B5%81%E7%A8%8Becdhe-%E7%AE%97%E6%B3%95/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://mp.weixin.qq.com/s/pLyR8zuw4l7Z6sdUZ4IL5w">公众号-小林 coding，这 HTTPS，真滴牛逼！&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>HTTPS 常用的密钥交换算法有两种，分别是 RSA 和 ECDHE 算法。&lt;/p>
&lt;p>其中，RSA 是比较传统的密钥交换算法，它不具备前向安全的性质，因此现在很少服务器使用的。而 ECDHE 算法具有前向安全，所以被广泛使用。&lt;/p>
&lt;p>我在上一篇已经介绍了 RSA 握手的过程，今天这一篇就「从理论再到实战抓包」介绍 &lt;strong>ECDHE 算法&lt;/strong>。&lt;/p>
&lt;h3 id="离散对数">离散对数&lt;/h3>
&lt;p>ECDHE 密钥协商算法是 DH 算法演进过来的，所以我们先从 DH 算法说起。&lt;/p>
&lt;p>DH 算法是非对称加密算法， 因此它可以用于密钥交换，该算法的核心数学思想是&lt;strong>离散对数&lt;/strong>。&lt;/p>
&lt;p>是不是听到这个数学概念就怂了？不怕，这次不会说离散对数推到的过程，只简单提一下它的数学公式。&lt;/p>
&lt;p>离散对数是「离散 + 对数」的两个数学概念的组合，所以我们先来复习一遍对数。&lt;/p>
&lt;p>要说起对数，必然要说指数，因为它们是互为反函数，指数就是幂运算，对数是指数的逆运算。&lt;/p>
&lt;p>举个栗子，如果以 2 作为底数，那么指数和对数运算公式，如下图所示：&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/dcp3g1/1616161079316-312e475f-cb69-45af-8289-7931f6ba39fa.png" alt="">&lt;/p>
&lt;p>那么对于底数为 2 的时候， 32 的对数是 5，64 的对数是 6，计算过程如下：&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/dcp3g1/1616161079333-e70a9a79-3367-4ab3-b41f-87d78ba1f188.png" alt="">&lt;/p>
&lt;p>对数运算的取值是可以连续的，而离散对数的取值是不能连续的，因此也以「离散」得名，&lt;/p>
&lt;p>离散对数是在对数运算的基础上加了「模运算」，也就说取余数，对应编程语言的操作符是「%」，也可以用 mod 表示。离散对数的概念如下图：&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/dcp3g1/1616161079336-e6d23927-9889-4040-ba45-a7c468d0e9b4.png" alt="">&lt;/p>
&lt;p>上图的，底数 a 和模数 p 是离散对数的公共参数，也就说是公开的，b 是真数，i 是对数。知道了对数，就可以用上面的公式计算出真数。但反过来，知道真数却很难推算出对数。&lt;/p>
&lt;p>&lt;strong>特别是当模数 p 是一个很大的质数，即使知道底数 a 和真数 b ，在现有的计算机的计算水平是几乎无法算出离散对数的，这就是 DH 算法的数学基础。&lt;/strong>&lt;/p>
&lt;hr>
&lt;h3 id="dh-算法">DH 算法&lt;/h3>
&lt;p>认识了离散对数，我们来看看 DH 算法是如何密钥交换的。&lt;/p>
&lt;p>现假设小红和小明约定使用 DH 算法来交换密钥，那么基于离散对数，小红和小明需要先确定模数和底数作为算法的参数，这两个参数是公开的，用 P 和 G 来代称。&lt;/p>
&lt;p>然后小红和小明各自生成一个随机整数作为&lt;strong>私钥&lt;/strong>，双方的私钥要各自严格保管，不能泄漏，小红的私钥用 a 代称，小明的私钥用 b 代称。&lt;/p>
&lt;p>现在小红和小明双方都有了 P 和 G 以及各自的私钥，于是就可以计算出&lt;strong>公钥&lt;/strong>：&lt;/p>
&lt;ul>
&lt;li>小红的公钥记作 A，A = G ^ a ( mod P )；&lt;/li>
&lt;li>小明的公钥记作 B，B = G ^ b ( mod P )；&lt;/li>
&lt;/ul>
&lt;p>A 和 B 也是公开的，因为根据离散对数的原理，从真数（A 和 B）反向计算对数 a 和 b 是非常困难的，至少在现有计算机的计算能力是无法破解的，如果量子计算机出来了，那就有可能被破解，当然如果量子计算机真的出来了，那么密钥协商算法就要做大的升级了。&lt;/p>
&lt;p>双方交换各自 DH 公钥后，小红手上共有 5 个数：P、G、a、A、B，小明手上也同样共有 5 个数：P、G、b、B、A。&lt;/p>
&lt;p>然后小红执行运算：B ^ a ( mod P )，其结果为 K，因为离散对数的幂运算有交换律，所以小明执行运算：A ^ b ( mod P )，得到的结果也是 K。&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/dcp3g1/1616161079410-0f5ff362-59ad-4930-8c5b-702e0ec61916.png" alt="">&lt;/p>
&lt;p>这个 K 就是小红和小明之间用的&lt;strong>对称加密密钥&lt;/strong>，可以作为会话密钥使用。&lt;/p>
&lt;p>可以看到，整个密钥协商过程中，小红和小明公开了 4 个信息：P、G、A、B，其中 P、G 是算法的参数，A 和 B 是公钥，而 a、b 是双方各自保管的私钥，黑客无法获取这 2 个私钥，因此黑客只能从公开的 P、G、A、B 入手，计算出离散对数（私钥）。&lt;/p>
&lt;p>前面也多次强调， 根据离散对数的原理，如果 P 是一个大数，在现有的计算机的计算能力是很难破解出 私钥 a、b 的，破解不出私钥，也就无法计算出会话密钥，因此 DH 密钥交换是安全的。&lt;/p>
&lt;hr>
&lt;h3 id="dhe-算法">DHE 算法&lt;/h3>
&lt;p>根据私钥生成的方式，DH 算法分为两种实现：&lt;/p>
&lt;ul>
&lt;li>static DH 算法，这个是已经被废弃了；&lt;/li>
&lt;li>DHE 算法，现在常用的；&lt;/li>
&lt;/ul>
&lt;p>static DH 算法里有一方的私钥是静态的，也就说每次密钥协商的时候有一方的私钥都是一样的，一般是服务器方固定，即 a 不变，客户端的私钥则是随机生成的。&lt;/p>
&lt;p>于是，DH 交换密钥时就只有客户端的公钥是变化，而服务端公钥是不变的，那么随着时间延长，黑客就会截获海量的密钥协商过程的数据，因为密钥协商的过程有些数据是公开的，黑客就可以依据这些数据暴力破解出服务器的私钥，然后就可以计算出会话密钥了，于是之前截获的加密数据会被破解，所以 &lt;strong>static DH 算法不具备前向安全性&lt;/strong>。&lt;/p>
&lt;p>既然固定一方的私钥有被破解的风险，那么干脆就让双方的私钥在每次密钥交换通信时，都是随机生成的、临时的，这个方式也就是 DHE 算法，E 全称是 ephemeral（临时性的）。&lt;/p>
&lt;p>所以，即使有个牛逼的黑客破解了某一次通信过程的私钥，其他通信过程的私钥仍然是安全的，因为&lt;strong>每个通信过程的私钥都是没有任何关系的，都是独立的，这样就保证了「前向安全」&lt;/strong>。&lt;/p>
&lt;hr>
&lt;h3 id="ecdhe-算法">ECDHE 算法&lt;/h3>
&lt;p>DHE 算法由于计算性能不佳，因为需要做大量的乘法，为了提升 DHE 算法的性能，所以就出现了现在广泛用于密钥交换算法 —— &lt;strong>ECDHE 算法&lt;/strong>。&lt;/p>
&lt;p>ECDHE 算法是在 DHE 算法的基础上利用了 ECC 椭圆曲线特性，可以用更少的计算量计算出公钥，以及最终的会话密钥。&lt;/p>
&lt;p>小红和小明使用 ECDHE 密钥交换算法的过程：&lt;/p>
&lt;ul>
&lt;li>双方事先确定好使用哪种椭圆曲线，和曲线上的基点 G，这两个参数都是公开的；&lt;/li>
&lt;li>双方各自随机生成一个随机数作为&lt;strong>私钥 d&lt;/strong>，并与基点 G 相乘得到&lt;strong>公钥 Q&lt;/strong>（Q = dG），此时小红的公私钥为 Q1 和 d1，小明的公私钥为 Q2 和 d2；&lt;/li>
&lt;li>双方交换各自的公钥，最后小红计算点（x1，y1） = d1Q2，小明计算点（x2，y2） = d2Q1，由于椭圆曲线上是可以满足乘法交换和结合律，所以 d1Q2 = d1d2G = d2d1G = d2Q1 ，因此&lt;strong>双方的 x 坐标是一样的，所以它是共享密钥，也就是会话密钥&lt;/strong>。&lt;/li>
&lt;/ul>
&lt;p>这个过程中，双方的私钥都是随机、临时生成的，都是不公开的，即使根据公开的信息（椭圆曲线、公钥、基点 G）也是很难计算出椭圆曲线上的离散对数（私钥）。&lt;/p>
&lt;hr>
&lt;h3 id="ecdhe-握手过程">ECDHE 握手过程&lt;/h3>
&lt;p>知道了 ECDHE 算法基本原理后，我们就结合实际的情况来看看。&lt;/p>
&lt;p>我用 Wireshark 工具抓了用 ECDHE 密钥协商算法的 TSL 握手过程，可以看到是四次握手：&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/dcp3g1/1616161079396-cb3c352a-51fd-4666-8b40-06b3abfb18b1.png" alt="">&lt;/p>
&lt;p>细心的小伙伴应该发现了，&lt;strong>使用了 ECDHE，在 TLS 第四次握手前，客户端就已经发送了加密的 HTTP 数据&lt;/strong>，而对于 RSA 握手过程，必须要完成 TLS 四次握手，才能传输应用数据。&lt;/p>
&lt;p>所以，&lt;strong>ECDHE 相比 RSA 握手过程省去了一个消息往返的时间&lt;/strong>，这个有点「抢跑」的意思，它被称为是「&lt;em>TLS False Start&lt;/em>」，跟「&lt;em>TCP Fast Open&lt;/em>」有点像，都是在还没连接完全建立前，就发送了应用数据，这样便提高了传输的效率。&lt;/p>
&lt;p>接下来，分析每一个 ECDHE 握手过程。&lt;/p>
&lt;p>TLS 第一次握手&lt;/p>
&lt;p>客户端首先会发一个「&lt;strong>Client Hello&lt;/strong>」消息，消息里面有客户端使用的 TLS 版本号、支持的密码套件列表，以及生成的&lt;strong>随机数（***&lt;strong>Client Random&lt;/strong>*&lt;/strong>）**。&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/dcp3g1/1616161079363-01339e83-2b01-4b86-a51f-158604aec01c.png" alt="">&lt;/p>
&lt;p>TLS 第二次握手&lt;/p>
&lt;p>服务端收到客户端的「打招呼」，同样也要回礼，会返回「&lt;strong>Server Hello&lt;/strong>」消息，消息面有服务器确认的 TLS 版本号，也给出了一个&lt;strong>随机数（***&lt;strong>Server Random&lt;/strong>*&lt;/strong>）**，然后从客户端的密码套件列表选择了一个合适的密码套件。&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/dcp3g1/1616161079346-2d236807-70d0-4ab9-8435-d9d1fd616d48.png" alt="">&lt;/p>
&lt;p>不过，这次选择的密码套件就和 RSA 不一样了，我们来分析一下这次的密码套件的意思。&lt;/p>
&lt;p>「 TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384」&lt;/p>
&lt;ul>
&lt;li>密钥协商算法使用 ECDHE；&lt;/li>
&lt;li>签名算法使用 RSA；&lt;/li>
&lt;li>握手后的通信使用 AES 对称算法，密钥长度 256 位，分组模式是 GCM；&lt;/li>
&lt;li>摘要算法使用 SHA384；&lt;/li>
&lt;/ul>
&lt;p>接着，服务端为了证明自己的身份，发送「&lt;strong>Certificate&lt;/strong>」消息，会把证书也发给客户端。&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/dcp3g1/1616161079339-c3c5361d-6e16-442d-9689-5e0bcd8c3dd4.png" alt="">&lt;/p>
&lt;p>这一步就和 RSA 握手过程有很大到区别了，因为服务端选择了 ECDHE 密钥协商算法，所以会在发送完证书后，发送「&lt;strong>Server Key Exchange&lt;/strong>」消息。&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/dcp3g1/1616161079354-28ca02df-58e1-4973-98ca-9ebf05385b3d.png" alt="">&lt;/p>
&lt;p>这个过程服务器做了三件事：&lt;/p>
&lt;ul>
&lt;li>选择了&lt;strong>名为 named_curve 的椭圆曲线&lt;/strong>，选好了椭圆曲线相当于椭圆曲线基点 G 也定好了，这些都会公开给客户端；&lt;/li>
&lt;li>生成随机数作为服务端椭圆曲线的私钥，保留到本地；&lt;/li>
&lt;li>根据基点 G 和私钥计算出&lt;strong>服务端的椭圆曲线公钥&lt;/strong>，这个会公开给客户端。&lt;/li>
&lt;/ul>
&lt;p>为了保证这个椭圆曲线的公钥不被第三方篡改，服务端会用 RSA 签名算法给服务端的椭圆曲线公钥做个签名。&lt;/p>
&lt;p>随后，就是「&lt;strong>Server Hello Done&lt;/strong>」消息，服务端跟客户端表明：“这些就是我提供的信息，打招呼完毕”。&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/dcp3g1/1616161079353-e59ab88d-3cc9-4318-8c16-dc534d248e0a.png" alt="">&lt;/p>
&lt;p>至此，TLS 两次握手就已经完成了，目前客户端和服务端通过明文共享了这几个信息：&lt;strong>Client Random、Server Random 、使用的椭圆曲线、椭圆曲线基点 G、服务端椭圆曲线的公钥&lt;/strong>，这几个信息很重要，是后续生成会话密钥的材料。&lt;/p>
&lt;p>TLS 第三次握手&lt;/p>
&lt;p>客户端收到了服务端的证书后，自然要校验证书是否合法，如果证书合法，那么服务端到身份就是没问题的。校验证书到过程，会走证书链逐级验证，确认证书的真实性，再用证书的公钥验证签名，这样就能确认服务端的身份了，确认无误后，就可以继续往下走。&lt;/p>
&lt;p>客户端会生成一个随机数作为客户端椭圆曲线的私钥，然后再根据服务端前面给的信息，生成&lt;strong>客户端的椭圆曲线公钥&lt;/strong>，然后用「&lt;strong>Client Key Exchange&lt;/strong>」消息发给服务端。&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/dcp3g1/1616161079379-454c2d83-0d99-432c-a365-ec9d421264c6.png" alt="">&lt;/p>
&lt;p>至此，双方都有对方的椭圆曲线公钥、自己的椭圆曲线私钥、椭圆曲线基点 G。于是，双方都就计算出点（x，y），其中 x 坐标值双方都是一样的，前面说 ECDHE 算法时候，说 x 是会话密钥，&lt;strong>但实际应用中，x 还不是最终的会话密钥&lt;/strong>。&lt;/p>
&lt;p>还记得 TLS 握手阶段，客户端和服务端都会生成了一个随机数传递给对方吗？&lt;/p>
&lt;p>&lt;strong>最终的会话密钥，就是用「客户端随机数 + 服务端随机数 + x（ECDHE 算法算出的共享密钥） 」三个材料生成的&lt;/strong>。&lt;/p>
&lt;p>之所以这么麻烦，是因为 TLS 设计者不信任客户端或服务器「伪随机数」的可靠性，为了保证真正的完全随机，把三个不可靠的随机数混合起来，那么「随机」的程度就非常高了，足够让黑客计算出最终的会话密钥，安全性更高。&lt;/p>
&lt;p>算好会话密钥后，客户端会发一个「&lt;strong>Change Cipher Spec&lt;/strong>」消息，告诉服务端后续改用对称算法加密通信。&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/dcp3g1/1616161079357-dace13e4-767a-4e9f-8065-088d25cb9e87.png" alt="">&lt;/p>
&lt;p>接着，客户端会发「&lt;strong>Encrypted Handshake Message&lt;/strong>」消息，把之前发送的数据做一个摘要，再用对称密钥加密一下，让服务端做个验证，验证下本次生成的对称密钥是否可以正常使用。&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/dcp3g1/1616161079349-ca3ffe7c-cf01-4e7c-8fc8-c9a966c7ce85.png" alt="">&lt;/p>
&lt;p>TLS 第四次握手&lt;/p>
&lt;p>最后，服务端也会有一个同样的操作，发「&lt;strong>Change Cipher Spec&lt;/strong>」和「&lt;strong>Encrypted Handshake Message&lt;/strong>」消息，如果双方都验证加密和解密没问题，那么握手正式完成。于是，就可以正常收发加密的 HTTP 请求和响应了。&lt;/p>
&lt;hr>
&lt;h3 id="总结">总结&lt;/h3>
&lt;p>RSA 和 ECDHE 握手过程的区别：&lt;/p>
&lt;ul>
&lt;li>RSA 密钥协商算法「不支持」前向保密，ECDHE 密钥协商算法「支持」前向保密；&lt;/li>
&lt;li>使用了 RSA 密钥协商算法，TLS 完成四次握手后，才能进行应用数据传输，而对于 ECDHE 算法，客户端可以不用等服务端的最后一次 TLS 握手，就可以提前发出加密的 HTTP 数据，节省了一个消息的往返时间；&lt;/li>
&lt;li>使用 ECDHE， 在 TLS 第 2 次握手中，会出现服务器端发出的「Server Key Exchange」消息，而 RSA 握手过程没有该消息；&lt;/li>
&lt;/ul>
&lt;hr>
&lt;p>巨人的肩膀&lt;/p>
&lt;ol>
&lt;li>&lt;a href="https://zh.wikipedia.org/wiki/">https://zh.wikipedia.org/wiki/&lt;/a>橢圓曲線迪菲-赫爾曼金鑰交換&lt;/li>
&lt;li>&lt;a href="https://zh.wikipedia.org/wiki/">https://zh.wikipedia.org/wiki/&lt;/a>椭圆曲线&lt;/li>
&lt;li>&lt;a href="https://zh.wikipedia.org/wiki/">https://zh.wikipedia.org/wiki/&lt;/a>迪菲-赫爾曼密鑰交換&lt;/li>
&lt;li>&lt;a href="https://time.geekbang.org/column/article/148188">https://time.geekbang.org/column/article/148188&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://zhuanlan.zhihu.com/p/106967180">https://zhuanlan.zhihu.com/p/106967180&lt;/a>&lt;/li>
&lt;/ol></description></item><item><title>Docs: HTTPS 交互流程(RSA 算法)</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/4.%E6%95%B0%E6%8D%AE%E9%80%9A%E4%BF%A1/%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/7.http/https/https-%E4%BA%A4%E4%BA%92%E6%B5%81%E7%A8%8Brsa-%E7%AE%97%E6%B3%95/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/4.%E6%95%B0%E6%8D%AE%E9%80%9A%E4%BF%A1/%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/7.http/https/https-%E4%BA%A4%E4%BA%92%E6%B5%81%E7%A8%8Brsa-%E7%AE%97%E6%B3%95/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://mp.weixin.qq.com/s/U9SRLE7jZTB6lUZ6c8gTKg">公众号-小林 coding，几幅图，拿下 HTTPS&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>对于还不知道对称加密和非对称加密的同学，你先复习我以前的这篇文章「&lt;a href="https://mp.weixin.qq.com/s/bUy220-ect00N4gnO0697A">硬核！30 张图解 HTTP 常见的面试题&lt;/a>」，本篇文章默认大家已经具备了这些知识。&lt;/p>
&lt;h1 id="tls-握手过程">TLS 握手过程&lt;/h1>
&lt;p>HTTP 由于是明文传输，所谓的明文，就是说客户端与服务端通信的信息都是肉眼可见的，随意使用一个抓包工具都可以截获通信的内容。&lt;/p>
&lt;p>所以安全上存在以下三个风险：&lt;/p>
&lt;ul>
&lt;li>&lt;em>窃听风险&lt;/em>，比如通信链路上可以获取通信内容，用户号容易没。&lt;/li>
&lt;li>&lt;em>篡改风险&lt;/em>，比如强制植入垃圾广告，视觉污染，用户眼容易瞎。&lt;/li>
&lt;li>&lt;em>冒充风险&lt;/em>，比如冒充淘宝网站，用户钱容易没。&lt;/li>
&lt;/ul>
&lt;p>HTTPS 在 HTTP 与 TCP 层之间加入了 TLS 协议，来解决上述的风险。&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/udi7ae/1616161091237-b99e9ec3-2c6b-439b-8176-cfbeae42a6f7.jpeg" alt="">&lt;/p>
&lt;p>TLS 协议是如何解决 HTTP 的风险的呢？&lt;/p>
&lt;ul>
&lt;li>&lt;em>信息加密&lt;/em>：HTTP 交互信息是被加密的，第三方就无法被窃取；&lt;/li>
&lt;li>&lt;em>校验机制&lt;/em>：校验信息传输过程中是否有被第三方篡改过，如果被篡改过，则会有警告提示；&lt;/li>
&lt;li>&lt;em>身份证书&lt;/em>：证明淘宝是真的淘宝网；&lt;/li>
&lt;/ul>
&lt;p>可见，有了 TLS 协议，能保证 HTTP 通信是安全的了，那么在进行 HTTP 通信前，需要先进行 TLS 握手。TLS 的握手过程，如下图：&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/udi7ae/1616161091232-869775d0-542d-47bc-9415-06a89c321a0a.png" alt="">&lt;/p>
&lt;p>上图简要概述来 TLS 的握手过程，其中每一个「框」都是一个记录（&lt;em>record&lt;/em>），记录是 TLS 收发数据的基本单位，类似于 TCP 里的 segment。多个记录可以组合成一个 TCP 包发送，所以&lt;strong>通常经过「四个消息」就可以完成 TLS 握手，也就是需要 2 个 RTT 的时延&lt;/strong>，然后就可以在安全的通信环境里发送 HTTP 报文，实现 HTTPS 协议。&lt;/p>
&lt;p>所以可以发现，HTTPS 是应用层协议，需要先完成 TCP 连接建立，然后走 TLS 握手过程后，才能建立通信安全的连接。&lt;/p>
&lt;p>事实上，不同的密钥交换算法，TLS 的握手过程可能会有一些区别。&lt;/p>
&lt;p>这里先简单介绍下密钥交换算法，因为考虑到性能的问题，所以双方在加密应用信息时使用的是对称加密密钥，而对称加密密钥是不能被泄漏的，为了保证对称加密密钥的安全性，所以使用非对称加密的方式来保护对称加密密钥的协商，这个工作就是密钥交换算法负责的。&lt;/p>
&lt;p>接下来，我们就以最简单的 &lt;code>RSA&lt;/code> 密钥交换算法，来看看它的 TLS 握手过程。&lt;/p>
&lt;h1 id="rsa-算法握手过程">RSA 算法握手过程&lt;/h1>
&lt;p>传统的 TLS 握手基本都是使用 RSA 算法来实现密钥交换的，在将 TLS 证书部署服务端时，证书文件中包含一对公私钥，其中公钥会在 TLS 握手阶段传递给客户端，私钥则一直留在服务端，一定要确保私钥不能被窃取。&lt;/p>
&lt;p>在 RSA 密钥协商算法中，客户端会生成随机密钥，并使用服务端的公钥加密后再传给服务端。根据非对称加密算法，公钥加密的消息仅能通过私钥解密，这样服务端解密后，双方就得到了相同的密钥，再用它加密应用消息。&lt;/p>
&lt;p>我用 Wireshark 工具抓了用 RSA 密钥交换的 TLS 握手过程，你可以从下面看到，一共经历来四次握手：&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/udi7ae/1616161091227-617dff70-97a1-4db1-a290-7b7148af1b06.png" alt="">&lt;/p>
&lt;p>对应 Wireshark 的抓包，我也画了一幅图，你可以从下图很清晰地看到该过程：&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/udi7ae/1616161091235-90f13da3-66fe-48fd-bfd3-4e2a8600cc95.png" alt="">&lt;/p>
&lt;p>那么，接下来针对每一个 TLS 握手做进一步的介绍。&lt;/p>
&lt;h2 id="tls-第一次握手">TLS 第一次握手&lt;/h2>
&lt;p>客户端首先会发一个「&lt;strong>Client Hello&lt;/strong>」消息，字面意思我们也能理解到，这是跟服务器「打招呼」。&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/udi7ae/1616161091237-d3daea27-ccfe-49e9-812e-a20f2f246a7d.png" alt="">&lt;/p>
&lt;p>消息里面有客户端使用的 TLS 版本号、支持的密码套件列表，以及生成的&lt;strong>随机数（***&lt;strong>Client Random&lt;/strong>*&lt;/strong>）**，这个随机数会被服务端保留，它是生成对称加密密钥的材料之一。&lt;/p>
&lt;h2 id="tls-第二次握手">TLS 第二次握手&lt;/h2>
&lt;p>当服务端收到客户端的「Client Hello」消息后，会确认 TLS 版本号是否支持，和从密码套件列表中选择一个密码套件，以及生成&lt;strong>随机数（***&lt;strong>Server Random&lt;/strong>*&lt;/strong>）**。&lt;/p>
&lt;p>接着，返回「&lt;strong>Server Hello&lt;/strong>」消息，消息里面有服务器确认的 TLS 版本号，也给出了随机数（Server Random），然后从客户端的密码套件列表选择了一个合适的密码套件。&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/udi7ae/1616161091236-50739c65-1ccb-4f8c-92fa-aae4c5ecd3a0.png" alt="">&lt;/p>
&lt;p>可以看到，服务端选择的密码套件是 “Cipher Suite: TLS_RSA_WITH_AES_128_GCM_SHA256”。&lt;/p>
&lt;p>这个密码套件看起来真让人头晕，好一大串，但是其实它是有固定格式和规范的。基本的形式是「&lt;strong>密钥交换算法 + 签名算法 + 对称加密算法 + 摘要算法&lt;/strong>」， 一般 WITH 单词前面有两个单词，第一个单词是约定密钥交换的算法，第二个单词是约定证书的验证算法。比如刚才的密码套件的意思就是：&lt;/p>
&lt;ul>
&lt;li>由于 WITH 单词只有一个 RSA，则说明握手时密钥交换算法和签名算法都是使用 RSA；&lt;/li>
&lt;li>握手后的通信使用 AES 对称算法，密钥长度 128 位，分组模式是 GCM；&lt;/li>
&lt;li>摘要算法 SHA384 用于消息认证和产生随机数；&lt;/li>
&lt;/ul>
&lt;p>就前面这两个客户端和服务端相互「打招呼」的过程，客户端和服务端就已确认了 TLS 版本和使用的密码套件，而且你可能发现客户端和服务端都会各自生成一个随机数，并且还会把随机数传递给对方。&lt;/p>
&lt;p>那这个随机数有啥用呢？其实这两个随机数是后续作为生成「会话密钥」的条件，所谓的会话密钥就是数据传输时，所使用的对称加密密钥。&lt;/p>
&lt;p>然后，服务端为了证明自己的身份，会发送「&lt;strong>Server Certificate&lt;/strong>」给客户端，这个消息里含有数字证书。&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/udi7ae/1616161091288-f8cf8f4b-afa3-4f36-8f34-595fd9f3a832.png" alt="">&lt;/p>
&lt;p>随后，服务端发了「&lt;strong>Server Hello Done&lt;/strong>」消息，目的是告诉客户端，我已经把该给你的东西都给你了，本次打招呼完毕。&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/udi7ae/1616161091257-6f83e7e9-62a9-4975-b627-967dde3b7744.png" alt="">&lt;/p>
&lt;h2 id="客户端验证证书">客户端验证证书&lt;/h2>
&lt;p>在这里刹个车，客户端拿到了服务端的数字证书后，要怎么校验该数字证书是真实有效的呢？&lt;/p>
&lt;h3 id="数字证书和-ca-机构">&lt;strong>数字证书和 CA 机构&lt;/strong>&lt;/h3>
&lt;p>在说校验数字证书是否可信的过程前，我们先来看看数字证书是什么，一个数字证书通常包含了：&lt;/p>
&lt;ul>
&lt;li>公钥；&lt;/li>
&lt;li>持有者信息；&lt;/li>
&lt;li>证书认证机构（CA）的信息；&lt;/li>
&lt;li>CA 对这份文件的数字签名及使用的算法；&lt;/li>
&lt;li>证书有效期；&lt;/li>
&lt;li>还有一些其他额外信息；&lt;/li>
&lt;/ul>
&lt;p>那数字证书的作用，是用来认证公钥持有者的身份，以防止第三方进行冒充。说简单些，证书就是用来告诉客户端，该服务端是否是合法的，因为只有证书合法，才代表服务端身份是可信的。&lt;/p>
&lt;p>我们用证书来认证公钥持有者的身份（服务端的身份），那证书又是怎么来的？又该怎么认证证书呢？&lt;/p>
&lt;p>为了让服务端的公钥被大家信任，服务端的证书都是由 CA （&lt;em>Certificate Authority&lt;/em>，证书认证机构）签名的，CA 就是网络世界里的公安局、公证中心，具有极高的可信度，所以由它来给各个公钥签名，信任的一方签发的证书，那必然证书也是被信任的。&lt;/p>
&lt;p>之所以要签名，是因为签名的作用可以避免中间人在获取证书时对证书内容的篡改。&lt;/p>
&lt;h3 id="数字证书签发和验证流程">数字证书签发和验证流程&lt;/h3>
&lt;p>如下图图所示，为数字证书签发和验证流程：&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/udi7ae/1616161091349-49d23cec-ab20-44c7-b339-11660cb1f4c6.png" alt="">&lt;/p>
&lt;p>CA 签发证书的过程，如上图左边部分：&lt;/p>
&lt;ul>
&lt;li>首先 CA 会把持有者的公钥、用途、颁发者、有效时间等信息打成一个包，然后对这些信息进行 Hash 计算，得到一个 Hash 值；&lt;/li>
&lt;li>然后 CA 会使用自己的私钥将该 Hash 值加密，生成 Certificate Signature，也就是 CA 对证书做了签名；&lt;/li>
&lt;li>最后将 Certificate Signature 添加在文件证书上，形成数字证书；&lt;/li>
&lt;/ul>
&lt;p>客户端校验服务端的数字证书的过程，如上图右边部分：&lt;/p>
&lt;ul>
&lt;li>首先客户端会使用同样的 Hash 算法获取该证书的 Hash 值 H1；&lt;/li>
&lt;li>通常浏览器和操作系统中集成了 CA 的公钥信息，浏览器收到证书后可以使用 CA 的公钥解密 Certificate Signature 内容，得到一个 Hash 值 H2 ；&lt;/li>
&lt;li>最后比较 H1 和 H2，如果值相同，则为可信赖的证书，否则则认为证书不可信。&lt;/li>
&lt;/ul>
&lt;h3 id="证书链">证书链&lt;/h3>
&lt;p>但事实上，证书的验证过程中还存在一个证书信任链的问题，因为我们向 CA 申请的证书一般不是根证书签发的，而是由中间证书签发的，比如百度的证书，从下图你可以看到，证书的层级有三级：&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/udi7ae/1616161091261-64484a59-fa0d-4e8f-bd65-1e21b9a2a21a.png" alt="">&lt;/p>
&lt;p>对于这种三级层级关系的证书的验证过程如下：&lt;/p>
&lt;ul>
&lt;li>客户端收到 baidu.com 的证书后，发现这个证书的签发者不是根证书，就无法根据本地已有的根证书中的公钥去验证 baidu.com 证书是否可信。于是，客户端根据 baidu.com 证书中的签发者，找到该证书的颁发机构是 “GlobalSign Organization Validation CA - SHA256 - G2”，然后向 CA 请求该中间证书。&lt;/li>
&lt;li>请求到证书后发现 “GlobalSign Organization Validation CA - SHA256 - G2” 证书是由 “GlobalSign Root CA” 签发的，由于 “GlobalSign Root CA” 没有再上级签发机构，说明它是根证书，也就是自签证书。应用软件会检查此证书有否已预载于根证书清单上，如果有，则可以利用根证书中的公钥去验证 “GlobalSign Organization Validation CA - SHA256 - G2” 证书，如果发现验证通过，就认为该中间证书是可信的。&lt;/li>
&lt;li>“GlobalSign Organization Validation CA - SHA256 - G2” 证书被信任后，可以使用 “GlobalSign Organization Validation CA - SHA256 - G2” 证书中的公钥去验证 baidu.com 证书的可信性，如果验证通过，就可以信任 baidu.com 证书。&lt;/li>
&lt;/ul>
&lt;p>在这四个步骤中，最开始客户端只信任根证书 GlobalSign Root CA 证书的，然后 “GlobalSign Root CA” 证书信任 “GlobalSign Organization Validation CA - SHA256 - G2” 证书，而 “GlobalSign Organization Validation CA - SHA256 - G2” 证书又信任 baidu.com 证书，于是客户端也信任 baidu.com 证书。&lt;/p>
&lt;p>总括来说，由于用户信任 GlobalSign，所以由 GlobalSign 所担保的 baidu.com 可以被信任，另外由于用户信任操作系统或浏览器的软件商，所以由软件商预载了根证书的 GlobalSign 都可被信任。&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/udi7ae/1616161091318-809bae64-fa0d-43d1-afe4-f661122a0d98.png" alt="">&lt;/p>
&lt;p>操作系统里一般都会内置一些根证书，比如我的 MAC 电脑里内置的根证书有这么多：&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/udi7ae/1616161091259-de5a6043-af08-4d6d-9c4f-b4a058fbfdb2.png" alt="">&lt;/p>
&lt;p>这样的一层层地验证就构成了一条信任链路，整个证书信任链验证流程如下图所示：&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/udi7ae/1616161091295-62aa78be-4d1e-4f6b-a3f0-3b3fabba02bc.png" alt="">&lt;/p>
&lt;p>最后一个问题，为什么需要证书链这么麻烦的流程？Root CA 为什么不直接颁发证书，而是要搞那么多中间层级呢？&lt;/p>
&lt;p>这是为了确保根证书的绝对安全性，将根证书隔离地越严格越好，不然根证书如果失守了，那么整个信任链都会有问题。&lt;/p>
&lt;h2 id="tls-第三次握手">TLS 第三次握手&lt;/h2>
&lt;p>客户端验证完证书后，认为可信则继续往下走。接着，客户端就会生成一个新的&lt;strong>随机数 (***&lt;strong>pre-master&lt;/strong>*&lt;/strong>)**，用服务器的 RSA 公钥加密该随机数，通过「**Change Cipher Key Exchange**」消息传给服务端。&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/udi7ae/1616161091269-3925f66e-1b80-4cb4-ab73-d285a983c320.png" alt="">&lt;/p>
&lt;p>服务端收到后，用 RSA 私钥解密，得到客户端发来的随机数 (pre-master)。&lt;/p>
&lt;p>至此，&lt;strong>客户端和服务端双方都共享了三个随机数，分别是 Client Random、Server Random、pre-master&lt;/strong>。&lt;/p>
&lt;p>于是，双方根据已经得到的三个随机数，生成&lt;strong>会话密钥（Master Secret）&lt;/strong>，它是对称密钥，用于对后续的 HTTP 请求/响应的数据加解密。&lt;/p>
&lt;p>生成完会话密钥后，然后客户端发一个「&lt;strong>Change Cipher Spec&lt;/strong>」，告诉服务端开始使用加密方式发送消息。&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/udi7ae/1616161091272-a6d1ed2b-37bd-4867-a998-6d62b1f9c9af.png" alt="">&lt;/p>
&lt;p>然后，客户端再发一个「&lt;strong>Encrypted Handshake Message（Finishd）&lt;/strong>」消息，把之前所有发送的数据做个摘要，再用会话密钥（master secret）加密一下，让服务器做个验证，验证加密通信是否可用和之前握手信息是否有被中途篡改过。&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/udi7ae/1616161091287-31494766-9b3d-4b15-a1c4-8ec5eda314e6.png" alt="">&lt;/p>
&lt;p>可以发现，「Change Cipher Spec」之前传输的 TLS 握手数据都是明文，之后都是对称密钥加密的密文。&lt;/p>
&lt;h2 id="tls-第四次握手">TLS 第四次握手&lt;/h2>
&lt;p>服务器也是同样的操作，发「&lt;strong>Change Cipher Spec&lt;/strong>」和「&lt;strong>Encrypted Handshake Message&lt;/strong>」消息，如果双方都验证加密和解密没问题，那么握手正式完成。&lt;/p>
&lt;p>最后，就用「会话密钥」加解密 HTTP 请求和响应了。&lt;/p>
&lt;h1 id="rsa-算法的缺陷">RSA 算法的缺陷&lt;/h1>
&lt;p>&lt;strong>使用 RSA 密钥协商算法的最大问题是不支持前向保密&lt;/strong>。因为客户端传递随机数（用于生成对称加密密钥的条件之一）给服务端时使用的是公钥加密的，服务端收到到后，会用私钥解密得到随机数。所以一旦服务端的私钥泄漏了，过去被第三方截获的所有 TLS 通讯密文都会被破解。&lt;/p>
&lt;p>为了解决这一问题，于是就有了 DH 密钥协商算法，这里简单介绍它的工作流程。&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/udi7ae/1616161091265-ee398110-3868-463d-bba9-77318753bec2.png" alt="">&lt;/p>
&lt;p>客户端和服务端各自会生成随机数，并以此作为私钥，然后根据公开的 DH 计算公示算出各自的公钥，通过 TLS 握手双方交换各自的公钥，这样双方都有自己的私钥和对方的公钥，然后双方根据各自持有的材料算出一个随机数，这个随机数的值双方都是一样的，这就可以作为后续对称加密时使用的密钥。&lt;/p>
&lt;p>DH 密钥交换过程中，&lt;strong>即使第三方截获了 TLS 握手阶段传递的公钥，在不知道的私钥的情况下，也是无法计算出密钥的，而且每一次对称加密密钥都是实时生成的，实现前向保密&lt;/strong>。&lt;/p>
&lt;p>但因为 DH 算法的计算效率问题，后面出现了 ECDHE 密钥协商算法，我们现在大多数网站使用的正是 ECDHE 密钥协商算法，关于 ECDHE 握手的过程，将在下一篇揭晓，尽情期待哦。&lt;/p></description></item><item><title>Docs: IP</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/4.%E6%95%B0%E6%8D%AE%E9%80%9A%E4%BF%A1/%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/3_4.tcp_ip/ip/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/4.%E6%95%B0%E6%8D%AE%E9%80%9A%E4%BF%A1/%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/3_4.tcp_ip/ip/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://datatracker.ietf.org/doc/html/rfc791">RFC,791&lt;/a>(IP 规范)&lt;/li>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Internet_Protocol">Wiki,Internet Protocol&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/IPv4">Wiki,IPv4&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Mask_(computing)">Wiki,Mask(掩码)&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Classful_network">Wiki,Classful Network(分类网络)&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.iana.org/assignments/ipv4-address-space/ipv4-address-space.xhtml">IANA,IPv4 地址空间分配情况&lt;/a>
&lt;ul>
&lt;li>&lt;a href="https://www.apnic.net/">APNIC&lt;/a>(管理亚太地区的 IP 地址注册机构)
&lt;ul>
&lt;li>&lt;a href="https://ftp.apnic.net/stats/apnic/">APNIC,帮助-FTP 数据库&lt;/a>(亚太地区所有分配的 IP 地址信息)&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;a href="https://www.iana.org/assignments/iana-ipv4-special-registry/iana-ipv4-special-registry.xhtml">IANA,IPv4 特殊用途地址注册表&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>**Internet Protocol(互联网协议，简称 IP) ** 是&lt;a href="https://en.wikipedia.org/wiki/Internet_protocol_suite">互联网协议套件&lt;/a>(其中包含 TCP/IP)中的主要通信协议，用于跨网络边界中继数据报。它的路由功能可实现互联网络，并实质上建立了 Internet。&lt;/p>
&lt;blockquote>
&lt;p>&lt;strong>Internet protocol suite(互联网协议套件)&lt;/strong> 是互联网和类似计算机网络中使用的概念模型和通信协议集。由于该套件中的基本协议是 &lt;strong>TCP(传输控制协议)&lt;/strong> 和 &lt;strong>IP(互联网协议)&lt;/strong>，因此通常被称为 &lt;strong>TCP/IP&lt;/strong>。在其开发过程中，其版本被称为国防部（DoD）模型，因为联网方法的开发是由美国国防部通过 DARPA 资助的。它的实现是一个协议栈。&lt;/p>
&lt;/blockquote>
&lt;p>IP 基于数据包的 Header 中的 IP 地址，将数据包从源主机发送到目标主机。基于此目的，IP 还定义了数据包的封装结构、以及一种寻址方法。寻址方法用来使用源和目标的信息标记数据报。&lt;/p>
&lt;p>从历史上看，IP 是在 1974 年由 Vint Cerf 和 Bob Kahn 引入的原始 **Transmission Control Program(传输控制程序) **中的&lt;a href="https://en.wikipedia.org/wiki/Connectionless_communication">无连接&lt;/a>数据报服务。该服务由一项面向连接的服务补充，成为 &lt;a href="https://desistdaydream.github.io/docs/IT%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/4.%E6%95%B0%E6%8D%AE%E9%80%9A%E4%BF%A1/%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/3_4.TCP_IP/TCP.md">&lt;strong>Transmission Control Protocol(传输控制协议，简称 TCP)&lt;/strong>&lt;/a> 的基础。因此 IP 套件通常称为 TCP/IP。IP 的第一个版本是 IPv4，继任者是 IPv6&lt;/p>
&lt;h1 id="ipv4-地址">IPv4 地址&lt;/h1>
&lt;p>IPv4 地址最多使用 32 bit 表示，即最多 32 个 1，这 32 bit 以 &lt;code>点&lt;/code> 分割为 4 组，每组 8 bit，在使用时，使用十进制表示。比如：&lt;code>192.168.0.1&lt;/code>。
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/nahgxm/1633534934848-ca44c51a-c787-47e7-a82b-589b6f78124b.jpeg" alt="">&lt;/p>
&lt;h2 id="ipv4-地址结构">IPv4 地址结构&lt;/h2>
&lt;p>IPv4 地址的这 32 bit 可以分为两部分&lt;/p>
&lt;ul>
&lt;li>网络位 # n bit&lt;/li>
&lt;li>主机位 # 32 - n bit&lt;/li>
&lt;/ul>
&lt;p>这两个部分通过 &lt;strong>Subnet Mast(子网掩码)&lt;/strong> 来区分，子网掩码由一连串的 1 和 0 组成，遵从以下规则：&lt;/p>
&lt;ul>
&lt;li>1 对应网络位&lt;/li>
&lt;li>0 对应主机位&lt;/li>
&lt;li>1 和 0 不能交叉出现&lt;/li>
&lt;/ul>
&lt;p>将子网掩码和 IP 地址作“与”操作后，IP 地址的主机部分将被丢弃，剩余的是网络地址和子网地址。&lt;/p>
&lt;p>例如：一个 IP 地址为 10.2.45.1，子网掩码为 255.255.252.0，“与” 运算得到：10.2.44.0，则网络设备认为该 IP 地址的网络号与子网号为 10.2.44.0，属于 10.2.44.0/22 网络，其中/22 表示子网掩码长度为 22 位，即从前向后连续的 22 个 1。&lt;/p>
&lt;p>00001010.00000010.00101101.00000001
与运算
11111111.11111111.11111100.00000000
结果为
00001010.00000010.00101100.00000001 即 10.2.44.0&lt;/p>
&lt;h2 id="ipv4-地址分类">IPv4 地址分类&lt;/h2>
&lt;ul>
&lt;li>
&lt;p>&lt;strong>单播地址&lt;/strong>&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>类&lt;/th>
&lt;th>开头的 bit&lt;/th>
&lt;th>网络位 bit 数&lt;/th>
&lt;th>主机位 bit 数&lt;/th>
&lt;th>子网数量&lt;/th>
&lt;th>每个子网的地址数&lt;/th>
&lt;th>总地址数&lt;/th>
&lt;th>起始地址&lt;/th>
&lt;th>结束地址&lt;/th>
&lt;th>默认子网掩码&lt;/th>
&lt;th>&lt;a href="https://en.wikipedia.org/wiki/CIDR_notation">CIDR&lt;/a>&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>Class A&lt;/td>
&lt;td>0&lt;/td>
&lt;td>8&lt;/td>
&lt;td>24&lt;/td>
&lt;td>128 (27)&lt;/td>
&lt;td>16,777,216 (224)&lt;/td>
&lt;td>2,147,483,648 (231)&lt;/td>
&lt;td>0.0.0.0&lt;/td>
&lt;td>127.255.255.255&lt;a href="https://en.wikipedia.org/wiki/Classful_network#cite_note-5">[a]&lt;/a>&lt;/td>
&lt;td>255.0.0.0&lt;/td>
&lt;td>/8&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Class B&lt;/td>
&lt;td>10&lt;/td>
&lt;td>16&lt;/td>
&lt;td>16&lt;/td>
&lt;td>16,384 (214)&lt;/td>
&lt;td>65,536 (216)&lt;/td>
&lt;td>1,073,741,824 (230)&lt;/td>
&lt;td>128.0.0.0&lt;/td>
&lt;td>191.255.255.255&lt;/td>
&lt;td>255.255.0.0&lt;/td>
&lt;td>/16&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Class C&lt;/td>
&lt;td>110&lt;/td>
&lt;td>24&lt;/td>
&lt;td>8&lt;/td>
&lt;td>2,097,152 (221)&lt;/td>
&lt;td>256 (28)&lt;/td>
&lt;td>536,870,912 (229)&lt;/td>
&lt;td>192.0.0.0&lt;/td>
&lt;td>223.255.255.255&lt;/td>
&lt;td>255.255.255.0&lt;/td>
&lt;td>/24&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>组播地址&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>&lt;strong>D 类 224-239 224.0.0.0 ~ 239.255.255.255&lt;/strong>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>保留地址&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>&lt;strong>E 类 240 - 254 240.0.0.0 ~ 255.255.255.255&lt;/strong>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>特殊地址&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>&lt;strong>网络地址&lt;/strong> # 网络位不变，主机位全为 0 的 IP 地址代表网络本身&lt;/li>
&lt;li>&lt;strong>Broadcast Address(广播地址)&lt;/strong> # 网络位不变，主机位全为 1 的 IP 地址代表本网络的广播。是专门用于同时向网络中所有&lt;a href="https://baike.baidu.com/item/%E5%B7%A5%E4%BD%9C%E7%AB%99/217955">工作站&lt;/a>进行发送的一个&lt;strong>地址&lt;/strong>。在使用&lt;a href="https://baike.baidu.com/item/TCP%2FIP%20%E5%8D%8F%E8%AE%AE/2116790">TCP/IP 协议&lt;/a>的网络中，&lt;a href="https://baike.baidu.com/item/%E4%B8%BB%E6%9C%BA/455151">主机&lt;/a>&lt;a href="https://baike.baidu.com/item/%E6%A0%87%E8%AF%86/6396929">标识&lt;/a>段 host ID 为全 1 的 IP 地址为广播地址，广播的分组传送给 host ID 段所涉及的所有&lt;a href="https://baike.baidu.com/item/%E8%AE%A1%E7%AE%97%E6%9C%BA/140338">计算机&lt;/a>。例如，对于 10.1.1.0 （255.0.0.0 ）网段，其直播&lt;a href="https://baike.baidu.com/item/%E5%B9%BF%E6%92%AD/656406">广播&lt;/a>地址为 10.255.255.255 （255 即为 2 进制的 11111111 ），当发出一个目的地址为 10.255.255.255 的分组（&lt;a href="https://baike.baidu.com/item/%E5%B0%81%E5%8C%85/2017669">封包&lt;/a>）时，它将被分发给该&lt;a href="https://baike.baidu.com/item/%E7%BD%91%E6%AE%B5/11026985">网段&lt;/a>上的所有计算机。&lt;/li>
&lt;li>&lt;strong>Link Local(链路本地地址)&lt;/strong> # 169.254.0.0 ~ 169.254.255.255。用于&lt;a href="https://en.wikipedia.org/wiki/Link-local_address">链路本地地址&lt;/a>&lt;a href="https://en.wikipedia.org/wiki/IPv4#cite_note-rfc3927-9">[9]&lt;/a>两台主机之间的单个链路上时，否则指定 IP 地址，如将有通常被从检索到的&lt;a href="https://en.wikipedia.org/wiki/DHCP">DHCP&lt;/a>服务器。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>Private Network(私人网络地址)&lt;/strong>&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>名称&lt;/th>
&lt;th>&lt;a href="https://en.wikipedia.org/wiki/Classless_Inter-Domain_Routing">CIDR&lt;/a>&lt;/th>
&lt;th>地址范围&lt;/th>
&lt;th>地址数量&lt;/th>
&lt;th>描述&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>24-bit block&lt;/td>
&lt;td>10.0.0.0/8&lt;/td>
&lt;td>10.0.0.0 – 10.255.255.255&lt;/td>
&lt;td>16777216&lt;/td>
&lt;td>一个完整的 A 类地址 Single Class A.&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>20-bit block&lt;/td>
&lt;td>172.16.0.0/12&lt;/td>
&lt;td>172.16.0.0 – 172.31.255.255&lt;/td>
&lt;td>1048576&lt;/td>
&lt;td>Contiguous range of 16 Class B blocks.&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>16-bit block&lt;/td>
&lt;td>192.168.0.0/16&lt;/td>
&lt;td>192.168.0.0 – 192.168.255.255&lt;/td>
&lt;td>65536&lt;/td>
&lt;td>Contiguous range of 256 Class C blocks.&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;/li>
&lt;/ul>
&lt;h1 id="ipv4-datagram-结构">IPv4 Datagram 结构&lt;/h1>
&lt;p>IPv4 数据报被封装在链路层的 Frame 中&lt;/p>
&lt;p>IPv4 数据报首部共 14 个字段，其中 13 个是必须的，第 14 个是可选的。前 13 个字段长度固定为 20 Bytes，即 160 bit；第 14 个字段长度在 0 ~ 40 Bytes 之间。
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/nahgxm/1633533991076-2a9cb606-463a-4dd4-89c8-c3aae590c113.jpeg" alt="">
对照 WireShark 中展示的内容看，排除 &lt;code>[]&lt;/code> 中的内容，每一行就是首部中的一个字段
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/nahgxm/1633532862295-9b420f37-7a97-43b9-85c8-1e973ea1aa59.png" alt="image.png">&lt;/p>
&lt;ul>
&lt;li>&lt;strong>Version(版本)&lt;/strong> # IP 协议的版本号。IPv4 其版本号为 4，因此在这个字段上的值为“6”。&lt;/li>
&lt;li>&lt;strong>Internet Header Length(首部长度，简称 IHL)&lt;/strong> # 由于 Options 字段的长度是可变的。所以 IPv4 的首部长度也是可变的。该字段的值在 5 ~ 15 之间(该字段只有 4 bits，1111 即为 15)
&lt;ul>
&lt;li>首部长度的计算方式如下：&lt;code>IHL * 32 bits&lt;/code>。
&lt;ul>
&lt;li>若 IHL 的值为 5，也就是说 Options 字段为 0，那么 IPv4 首部长度就是 5 * 32 bits = 160 bits = 20 Bytes&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>就像上面的 IPv4 的 Datagram 结构图一样，每行都是 32 bit，不算 Options 字段和 Payload，那么刚好是 5 行。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>Differentiated Services Field&lt;/strong> # 差异化的服务字段，基本没啥用。。。。o(╯□╰)o
&lt;ul>
&lt;li>&lt;strong>Differentiated Services Code Point&lt;/strong> # 最初定义为 Type Of Service(服务类型，简称 TOS)，&lt;/li>
&lt;li>&lt;strong>Explicit Congestion Notification&lt;/strong> # 该字段定义在 RFC3168 中，&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>Total Length&lt;/strong> # 定义了整个 IP 数据报的大小，最小为 20 字节(Payload 字段无内容)，最大为 65535 字节。&lt;/li>
&lt;li>**Identification **# 主要用于唯一标识单个 IP 数据报的片段组。
&lt;ul>
&lt;li>一些实验工作建议将 ID 字段用于其他目的，例如添加数据包跟踪信息以帮助跟踪具有欺骗源地址的数据报，[31] 但 RFC 6864 现在禁止任何此类使用。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>**Flags **# 用来控制或识别 IP 分片之后的每个片段，这 3 个 bit 分别表示不同的含义，若字段值为 0 表示未设置，值为 1 表示设置，类似 TCP 首部中 Flags 字段的用法。
&lt;ul>
&lt;li>第一个 # Reserved，保留字段，必须为 0&lt;/li>
&lt;li>第二个 # Don&amp;rsquo;t Fragment(DF)&lt;/li>
&lt;li>第三个 # More Fragment(MF)&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>Fragment Offset(分片偏移)&lt;/strong> # IP 分片之后的偏移量&lt;/li>
&lt;li>&lt;strong>Time To Live(存活时间，简称 TTL)&lt;/strong> # 其实用 Hop Limit 的描述更准确，封包每经过一个路由器，怎会将 TTL 字段的值减 1，减到 0 是，该包将会被丢弃。&lt;/li>
&lt;li>**Protocol **# 封装 IP 数据报的上层协议，比如 6 表示 TCP、1 表示 ICMP
&lt;ul>
&lt;li>每种协议根据 &lt;a href="https://datatracker.ietf.org/doc/html/rfc1700">RFC 1700&lt;/a> 都分配了一个固定的编号，该 RFC 1700 最终被 RFC 3232 废弃，并将协议编号的维护工作，转到&lt;a href="https://www.iana.org/assignments/protocol-numbers/protocol-numbers.xhtml"> IANA 的在线数据库&lt;/a>中&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>Header Checksum&lt;/strong> # 当数据包到达路由器时，路由器会计算标头的校验和，并将其与校验和字段进行比较。如果值不匹配，则路由器会丢弃该数据包。&lt;/li>
&lt;li>&lt;strong>Source Address(源地址)&lt;/strong> # 发送端 IP 地址。&lt;/li>
&lt;li>&lt;strong>Destination Address(目标地址)&lt;/strong> # 接收端 IP 地址。&lt;/li>
&lt;li>**Options(选项) **# 可变长度，0-40 Bytes。&lt;/li>
&lt;/ul>
&lt;h1 id="ipv4-fragment">IPv4 Fragment&lt;/h1>
&lt;p>IP Fragment(分片) 主要通过首部中的 Identification、Flags、Fragment Offset 这三个字段对每一个分片进行唯一标识&lt;/p>
&lt;h1 id="ip-地址分配机制">IP 地址分配机制&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://www.iana.org/numbers">IANA,号码资源&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.eet-china.com/mp/a54338.html">面包板，你知道中国大陆一共有多少 IPv4 地址吗？&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://mp.weixin.qq.com/s/GHYYgZwAuEV4qPCwdI8Bjg">公众号，k8s 中文社区-居然还有 2 亿多 IPv4 地址未分配&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://wq.apnic.net/static/search.html">APNIC,搜索&lt;/a>(通过给定的 IP 地址搜索谁拥有这个 IP)&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>IPv4 和 IPv6 地址通常以分层方式分配。&lt;strong>ISP(互联网服务提供商)&lt;/strong> 为用户分配 IP 地址。ISP 从 &lt;strong>LIR(本地互联网注册机构)&lt;/strong> 或 &lt;strong>NIR(国家互联网注册机构)&lt;/strong> 或 &lt;strong>RIR(相应的区域互联网注册机构)&lt;/strong> 获取 IP 地址分配
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/nahgxm/1646384624162-21c9bca1-0960-45e4-87bb-3802eca96278.svg" alt="">&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>登记处&lt;/th>
&lt;th>覆盖面积&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>&lt;a href="http://www.afrinic.net/">AFRINIC&lt;/a>&lt;/td>
&lt;td>Africa Region(非洲地区)&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;a href="http://www.apnic.net/">APNIC&lt;/a>&lt;/td>
&lt;td>Asia/Pacific Region(亚洲/太平洋地区，亚太地区)&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;a href="http://www.arin.net/">ARIN&lt;/a>&lt;/td>
&lt;td>Canada, USA, and some Caribbean Islands(加拿大、美国、一些加勒比岛屿)&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;a href="http://www.lacnic.net/">LACNIC&lt;/a>&lt;/td>
&lt;td>Latin America and some Caribbean Islands(拉丁美洲、一些加勒比岛屿)&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;a href="http://www.ripe.net/">RIPE NCC&lt;/a>&lt;/td>
&lt;td>Europe, the Middle East, and Central Asia(欧洲、中东、中亚)&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>&lt;a href="http://www.icann.org/en/general/global-addressing-policies.html">对 IP 地址的主要作用是根据全球政策&lt;/a>所述的需求将未分配地址池分配给 RIR，并记录 &lt;a href="http://www.ietf.org/">IETF&lt;/a> 所做的协议分配。当 RIR 需要在其区域内分配或分配更多 IP 地址时，我们会向 RIR 进行额外分配。我们不会直接向 ISP 或最终用户进行分配，除非在特定情况下，例如分配多播地址或其他协议特定需求。&lt;/p>
&lt;p>APNIC 是全球 5 个地区级的 Internet 注册机构（RIR）之一，负责亚太地区的以下事务：
1、分配 IPv4 和 IPv6 地址空间，AS 号；
2、为亚太地区维护 Whois 数据库；
3、反向 DNS 指派；
4、在全球范围内作为亚太地区的 Internet 社区的代表。
所以，中国大陆境内的地址都会登记在 APNIC 的地址库内。地址库获取方式：&lt;a href="http://ftp.apnic.net/apnic/stats/apnic/delegated-apnic-latest">http://ftp.apnic.net/apnic/stats/apnic/delegated-apnic-latest&lt;/a>
例如在 Linux 系统中，使用 wget 命令可以拉取文件。
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/nahgxm/1646295854669-69e90c43-6765-415a-be08-ba15cdf1f6c3.png" alt="image.png">
文件内容条目参考如下：
apnic|JP|asn|173|1|20020801|allocated
apnic|ID|ipv4|43.240.228.0|1024|20140818|allocated
apnic|HK|ipv6|2001:df5:b800::|48|20140514|assigned
条目格式如下：
注册机构|国家代码|类型|起始位|长度|分配日期|状态&lt;/p>
&lt;ul>
&lt;li>&lt;strong>注册机构&lt;/strong>：亚太地区一般为 apnic&lt;/li>
&lt;li>&lt;strong>国家代码&lt;/strong>：ISO-3166 定义的两位国家或地区代码，如中国为 CN&lt;/li>
&lt;li>&lt;strong>类型&lt;/strong>：asn（Autonomous System Number，自治系统编号），也就是 BGP 的 AS 编号；ipv4，IPv4 地址；ipv6，IPv6 地址&lt;/li>
&lt;li>&lt;strong>起始位&lt;/strong>：第一个 ASN 编号或 IP 地址&lt;/li>
&lt;li>&lt;strong>长度&lt;/strong>：从第一个起始位开始，申请分配多少的编号或地址&lt;/li>
&lt;li>&lt;strong>分配日期&lt;/strong>：国家或地区向 APNIC 申请的日期&lt;/li>
&lt;li>&lt;strong>状态&lt;/strong>：allocated 和 assigned，都是已分配&lt;/li>
&lt;/ul>
&lt;p>所以，需要将 delegated-apnic-latest 文件中所有国家为 CN、且类型为 ipv4 的条目导出，并转换为静态路由格式。
例如使用命令将符合条件的条目导入到 china 文件中。
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/nahgxm/1646295854726-90496001-56ba-4bbb-9e7c-48568a601999.png" alt="image.png">
可以查看文件行数，代表有多少条明细条目。
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/nahgxm/1646295854636-89ef24bb-cb5c-4832-a3af-bcc97cffc042.png" alt="image.png">
然后根据起始位和长度，转换出静态路由所需的目的地址和掩码即可。在 excel 中通过对长度进行函数运算，可以得到掩码长度，如：=32-LOG(E2,2)，代入 2048 的话，可得到掩码长度为 21。操作后得到类似下图的表格：
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/nahgxm/1646295854710-c698ce59-e5fb-4e59-97cc-77a1a81bfc81.png" alt="image.png">
先将表格内容复制到记事本中，再从记事本粘贴到 Word 中，即可得到带有内容字段、tab 制表符和段落标记的内容。如下：
1.0.1.0 CN 24 apnic
1.0.2.0 CN 23 apnic
1.0.8.0 CN 21 apnic
这就简单了，使用 Word 的替换功能，对对应字段进行替换就可以得到形如下文的配置：
int loop 1
ip add 1.12.0.1 14
int loop 2
ip add 1.24.0.1 13
int loop 3
ip add 1.48.0.1 15
int loop 4
ip add 1.56.0.1 13
int loop 5
ip add 1.68.0.1 14
再把配置分别刷入到 11 台设备当中，配置好 OSPF 和 BGP 就可以了。
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/nahgxm/1646295854663-30f55fe1-a908-42e8-8b91-e95b33552417.png" alt="image.png">&lt;/p>
&lt;h2 id="ip-应用场景">IP 应用场景&lt;/h2>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>标记&lt;/th>
&lt;th>中文&lt;/th>
&lt;th>描述&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>ANY&lt;/td>
&lt;td>任播网络&lt;/td>
&lt;td>属于数据中心的一部分，任播网络；如：8.8.8.8&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>CDN&lt;/td>
&lt;td>内容分发&lt;/td>
&lt;td>属于数据中心的一部分，内容分发网络&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>COM&lt;/td>
&lt;td>商业公司&lt;/td>
&lt;td>以盈利为目的的公司&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>DNS&lt;/td>
&lt;td>域名解析&lt;/td>
&lt;td>用户提供域名解析服务的 IP；如：8.8.8.8，114.114.114.114&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>EDU&lt;/td>
&lt;td>教育机构&lt;/td>
&lt;td>学校/教育机构使用的 IP&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>GTW&lt;/td>
&lt;td>企业专线&lt;/td>
&lt;td>固定 IP，中大型公司专线上网的 IP&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>GOV&lt;/td>
&lt;td>政府机构&lt;/td>
&lt;td>政府单位使用的 IP&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>DYN&lt;/td>
&lt;td>动态 IP&lt;/td>
&lt;td>家庭住宅用户使用的 IP&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>IDC&lt;/td>
&lt;td>数据中心&lt;/td>
&lt;td>机房/云服务商使用的 IP&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>IXP&lt;/td>
&lt;td>交换中心&lt;/td>
&lt;td>网络交换中心使用的 IP&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>MOB&lt;/td>
&lt;td>移动网络&lt;/td>
&lt;td>基站出口 IP（2G/3G/4G/5G）&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>NET&lt;/td>
&lt;td>基础设施&lt;/td>
&lt;td>网络设备骨干路由使用的 IP&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>ORG&lt;/td>
&lt;td>组织机构&lt;/td>
&lt;td>非营利性组织机构&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>SAT&lt;/td>
&lt;td>卫星通信&lt;/td>
&lt;td>通过卫星上网的出口 IP&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>VPN&lt;/td>
&lt;td>代理网络&lt;/td>
&lt;td>属于数据中心的一部分，专门做 VPN 业务的&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table></description></item><item><title>Docs: IPv6</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/4.%E6%95%B0%E6%8D%AE%E9%80%9A%E4%BF%A1/%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/3_4.tcp_ip/ip/ipv6/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/4.%E6%95%B0%E6%8D%AE%E9%80%9A%E4%BF%A1/%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/3_4.tcp_ip/ip/ipv6/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/IPv6">Wiki,IPv6&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://datatracker.ietf.org/doc/html/rfc8200">RFC,8200&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.iana.org/assignments/ipv6-address-space/ipv6-address-space.xhtml">IANA,IPv6 地址空间分配情况&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://github.com/IPv6-CN/ipv6-cn.github.io">GitHub 项目，IPv6-CN/ipv6cn.github.io&lt;/a>(这个资料。。。怎么说呢。。。)&lt;/li>
&lt;li>&lt;a href="https://www.bilibili.com/video/BV1J7411c7ae">https://www.bilibili.com/video/BV1J7411c7ae&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.bilibili.com/video/BV1aF411v7hU">https://www.bilibili.com/video/BV1aF411v7hU&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.zhihu.com/question/361275417">https://www.zhihu.com/question/361275417&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://cloud.tencent.com/developer/article/1468099">https://cloud.tencent.com/developer/article/1468099&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>&lt;strong>Internet Protocol version 6(互联网协议版本 6，简称 IPv6)&lt;/strong> 是 Internet Protocol(互联网协议，简称 IP) 的最新版本(截止 2022 年 1 月 28 日)，该协议为网络上的计算机提供识别和定位系统并通过 Internet 路由流量。IPv6 由 Internet Engineering Task Force(互联网工程任务组，简称 IETF) 开发，旨在解决 IPv4 地址耗尽的问题。1998 年 12 月，IPv6 成为 IETF 的标准草案，2017 年 7 月 14 日将其批准为互联网标准。
&lt;a href="https://www.bilibili.com/video/BV1J7411c7ae">
&lt;/a>&lt;/p>
&lt;h2 id="困扰-1-ipv4-和-ipv6-只有地址格式不同吗">困扰 1. IPv4 和 IPv6 只有地址格式不同吗&lt;/h2>
&lt;p>除了地址格式不同，IPv4 与 IPv6 协议栈也不同，他们在逻辑上是&lt;strong>完全不同的 2 个世界&lt;/strong>
以下实践中经常会遇到的 4 个不同之处：
▷ &lt;strong>基本通讯过程&lt;/strong>：ND 替代 ARP、多播替代广播、fe80 地址成为标配、ICMP 成为通讯核心
▷ &lt;strong>IP 配置方式&lt;/strong>：客户端以无状态自动配置 IP 成为主流，弱化 DHCP
▷ &lt;strong>DNS&lt;/strong>&lt;a href="https://cloud.tencent.com/product/cns?from=10680">域名解析&lt;/a>：AAAA 记录替代 IPv4 的 A 记录、对应用存在优先级问题（优先解析 AAAA 还是 A）
▷ &lt;strong>应用层适应性&lt;/strong>：socket 编程中 AF_INET 仅支持 IPv4，AF_INET6 仅支持 IPv6&lt;/p>
&lt;hr>
&lt;h2 id="困扰-2-ipv4-到-ipv6-对应用程序是透明无感知的吗">困扰 2. IPv4 到 IPv6 对应用程序是透明无感知的吗&lt;/h2>
&lt;p>&lt;strong>错，是有感知的&lt;/strong>，上层应用程序需要进行改造。
举个例子，当访问 fzxiaomange.com 时候，是要优先解析 IPv6 地址（AAAA）还是 IPv4 地址（A），因为总得选一条线路来发送请求。现在许多框架会优先选择 IPv6。
注意：如果解析出 AAAA 记录，即使本机没有可路由 IPv6 地址，也有可能&lt;strong>依然尝试通过 IPv6 进行请求，导致请求失败&lt;/strong>。
还有一个典型的例子，是程序会在&lt;strong>应用层里交互底层 IP 地址&lt;/strong>，比如 FTP 主动模式会在应用层里交互 IPv4 地址，而如果实际可用的是 IPv6 地址，就可能导致后续连接的异常。
&lt;strong>无法做到透明无感知，是导致产生 IPv4 到 IPv6 的部分过渡方案的原因之一。&lt;/strong>&lt;/p>
&lt;hr>
&lt;h2 id="困扰-3-提供-web-服务需要每台服务器都配置-ipv6-地址吗">困扰 3. 提供 WEB 服务，需要每台服务器都配置 IPv6 地址吗&lt;/h2>
&lt;p>现在有一种言论，说“IPv6 地址无限多，每台服务器都可以配一个 IP 地址，不用做 NAT”。
&lt;strong>这很容易误导人，具体如何使用 IPv6，还得根据场景而定&lt;/strong>。比如笔者的个人博客 fzxiaomange.com，由 nginx-&amp;gt;php-&amp;gt;mysql 组成，分别位于 3 台服务器上，那只需要在 nginx 上配置 IPv6 地址，并在 DNS 上添加一条 AAAA 记录指向 L7 的 IPv6 地址即可。完全没必要在 php、mysql 服务器上配置 IPv6 地址，而且一旦配置了，就直接暴露内网了。
每个设备都配置 IPv6，主要适用于&lt;strong>偏客户端以及地址需求量大的场景&lt;/strong>，诸如物联网设备、手机 4G、家庭宽带等。
另外，&lt;strong>IPv6 有 NAT&lt;/strong>，适用于办公 PC、机房服务器等需要访问 IPv6 网络，而不想被别人主动访问的场景。&lt;/p>
&lt;hr>
&lt;h2 id="困扰-4-ipv4-和-ipv6-要配在同一张网卡上吗">困扰 4. IPv4 和 IPv6 要配在同一张网卡上吗&lt;/h2>
&lt;p>都可以，首先需要先了解 2 个词**“Single-Stack(单栈)”&lt;strong>和&lt;/strong>“Dual-Stack(双栈)”**：
&lt;strong>以节点为角度&lt;/strong>（通用的解释）：&lt;/p>
&lt;ul>
&lt;li>单栈：表示一个 IPv6 节点，也就是一台服务器，或一部手机，仅有 IPv6 地址，或仅有 IPv4 地址，前者叫做**“IPv6 单栈”&lt;strong>或&lt;/strong>“IPv6-Only”&lt;strong>，后者叫&lt;/strong>“IPv4 单栈”&lt;strong>或&lt;/strong>“IPv4-Only”**。&lt;/li>
&lt;li>双栈：表示一个 IPv6 节点，同时拥有 IPv6 地址和 IPv4 地址&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>以网卡为角度&lt;/strong>：
▷ 单栈：表示一张网卡仅有 IPv6 地址，或仅有 IPv4 地址，示意图如下
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/mzn9uc/1643343522816-f045574f-93d4-4ed9-9356-4045d7acaa38.png" alt="image.png">
▷ 双栈：表示一张网卡同时拥有 IPv6 地址和 IPv4 地址
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/mzn9uc/1643343532878-4cb46010-1684-4e57-88f5-29e2472d56d2.png" alt="image.png">
IPv4 和 IPv6 在逻辑上是两个完全不相交的世界。如果终端处位于同一个物理层，比如同一个 VLAN，那么网卡就只能同时配置 IPv6 地址和 IPv4 地址；反之，就必须一张网卡配置 IPv6，另一张网卡配置 IPv4。所以，&lt;strong>关键看网络架构是如何设计，各有利弊&lt;/strong>。比如放同一张网卡上，就可以做到带宽共享，而放不同网卡，可以做到带宽分别限制与计费。&lt;/p>
&lt;hr>
&lt;h2 id="困扰-5-我的网卡有-fe80-开头的地址可以用来上公网吗">困扰 5. 我的网卡有 fe80 开头的地址，可以用来上公网吗&lt;/h2>
&lt;p>当网卡启动的时候，会自动生成**“链路本地地址”（Link-Local Address）&lt;strong>，这是一个&lt;/strong>fe80::/10&lt;strong>的单播地址。“链路本地地址”用于&lt;/strong>IP 自动配置**、&lt;strong>邻居发现&lt;/strong>等。
&lt;strong>注意事项&lt;/strong>：
▷ 核心：每张网卡都会存在“链路本地地址”，这是 IPv6 协议通讯的核心，不应当删掉
▷ 范围：仅在同一个二层范围内进行传播，不会被路由器做转发
▷ 地址：“链路本地地址”的算法不统一，有的操作系统会根据 mac 地址计算而来（EUI-64），而有的则是随机或其他某种算法计算而来
▷ 服务：“链路本地地址”虽然可以在二层内互通，但主要用于核心通讯以及某些网络高级协议。不适用于上层应用业务之间的通讯。因此不能用来上公网，也不能用于对外提供服务&lt;/p>
&lt;hr>
&lt;h2 id="困扰-8-ipv6-使用多播替代广播需要做哪些改造">困扰 8. IPv6 使用多播替代广播，需要做哪些改造&lt;/h2>
&lt;p>IPv6 使用多播替代了广播，多播的特点是不会像广播那样完全泛洪，而是数据包只发送给加入了多播组的机器。
但是，这有个前提，就是&lt;strong>交换机要能识别并维护多播组的信息&lt;/strong>，主流交换机都具备此功能，然而并不都是默认开启的。对于二层交换机来说，需要开启&lt;strong>MLDv2 Snooping&lt;/strong>。
顾名思义，就是交换机会识别**“MLDv2 成员报告”**报文从哪个端口发来的，并记录下来，之后当交换机收到多播包后，会先查找其多播地址是否能在缓存里匹配上
▷ 匹配成功：仅会将数据包从相应的端口发出
▷ 匹配失败：就会泛洪，此时和广播毫无差异&lt;/p>
&lt;hr>
&lt;h2 id="困扰-9-ipv6-真的安全吗">困扰 9. IPv6 真的安全吗&lt;/h2>
&lt;p>&lt;strong>理想很美好&lt;/strong>，IPv6 从设计之初，就进行了大量的安全方面的设计，“完整的”IPv6 在安全方面有至少以下 3 个优势：
▷ 原生支持的端到端加密
▷ 安全的邻居发现（&lt;strong>Secure Neighbor Discovery，简称 SEND&lt;/strong>）
▷ 更大的地址空间
&lt;strong>现实很残酷&lt;/strong>，只有第 3 点发挥了作用，更大的地址空间，减少了被非法扫描到的概率。而第 1、2 点并没真正普及起来，因为&lt;strong>协议本身就很复杂、学习难度很大、实现起来也很不容易&lt;/strong>。因此 IETF 为了加速 IPv6 的普及，&lt;strong>对安全性不再强制要求&lt;/strong>。这也导致了 IPv6 实际上并没有预期中的那么安全，在 IPv4 里存在的地址欺骗、虚假网关等情况，在 IPv6 里依然存在。&lt;/p>
&lt;hr>
&lt;h2 id="困扰-10-如何学习-ipv6">困扰 10. 如何学习 IPv6&lt;/h2>
&lt;p>网上能找到非常多的 IPv6 教程，其中有很多教程都是通篇讲 IPv6 地址、IP 包格式、ICMP 包格式，这很容易让初学者打退堂鼓。笔者虽然不是专业的网工，但愿能抛砖引玉，推荐的学习步骤如下：
1️⃣ IPv6 的历史、设计理念
2️⃣ IPv6 的地址格式、分类、前缀计算，以及与 IPv4 的对比
3️⃣ IP 地址、网关路由的配置与查看
4️⃣ 服务端实践，尝试给自己的网站增加 IPv6
5️⃣ 客户端实践，让自己的 PC 访问 IPv6 互联网
6️⃣ 应用层实践，自己写一对 C/S 程序，能同时支持 IPv4 与 IPv6
7️⃣ IPv6 通讯原理，抓包分析每个包，熟悉 ND、DHCPv6 等
8️⃣ IPv4 与 IPv6 的互访、过渡
9️⃣ IPv6 安全
🔟 具体领域的 IPv6，例如移动 IPv6[&lt;/p>
&lt;p>](https://www.bilibili.com/video/BV1J7411c7ae)&lt;/p>
&lt;h1 id="ipv6-地址">IPv6 地址&lt;/h1>
&lt;p>IPv6 地址最多使用 128 bit 表示，即最多 128 个 1，这 128 bit 以 &lt;code>冒号&lt;/code> 分割为 8 组，每组 16 bit，在使用时，使用十六进制表示。比如：&lt;code>2031:0000:130F:0000:0000:09C0:876A:130B&lt;/code>。
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/mzn9uc/1631498641648-aa666528-2155-4dfb-8969-d44a5eee7e35.jpeg" alt="">
为了书写方便，IPv6 的十六进制表示方法，可以进行压缩，具体压缩规则为：&lt;/p>
&lt;ul>
&lt;li>每组的前导 &lt;code>0&lt;/code> 可以省略，所以上面的例子可以写为：&lt;code>2031:0:130F:0:0:9C0:876A:130B&lt;/code>&lt;/li>
&lt;li>地址中包含的连续两个或多个均为 0 的组，可以用 &lt;code>::&lt;/code>(双冒号) 代替，所以上面的例子可以进一步简写为：&lt;code>2031:0:130F::9C0:876A:130B&lt;/code>
&lt;ul>
&lt;li>注意：一个 IPv6 地址中，只能使用一次双冒号，否则当计算机将压缩后的地址恢复成 128 bit 时，无法确定每段中 0 的个数。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h2 id="ipv6-地址结构">IPv6 地址结构&lt;/h2>
&lt;p>IPv6 地址的这 128 bit 可以分为两部分：&lt;/p>
&lt;ul>
&lt;li>&lt;strong>Network prefix(网络前缀)&lt;/strong> # n bit，相当于 IPv4 地址中的网络 ID。
&lt;ul>
&lt;li>网络前缀由 IANA 一层层分配。IANA 组织当前划定的单播地址是 &lt;code>2000::/3&lt;/code>。也就是说从 &lt;code>2000::&lt;/code> 到 &lt;code>3FFF:FFFF:FFFF:FFFF:FFFF:FFFF:FFFF:FFFF&lt;/code>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>Interface Identify(接口标识)&lt;/strong> # 128-n bit，相当于 IPv4 地址中的主机 ID&lt;/li>
&lt;li>&lt;strong>Prefix length(前缀长度)&lt;/strong> # IPv6 没有子网掩码，通过在地址后面添加 &lt;code>/NUM&lt;/code> 来区分一个地址的 网络前缀 和 接口表示，比如 &lt;code>/64&lt;/code> 表示前 64 位是网络前缀，后 64 位为接口标识&lt;/li>
&lt;/ul>
&lt;p>接口标识可以通过三种方式生成&lt;/p>
&lt;ul>
&lt;li>&lt;strong>手动配置&lt;/strong> #&lt;/li>
&lt;li>&lt;strong>通过软件自动生成&lt;/strong> # 在有的地方称为有状态配置&lt;/li>
&lt;li>&lt;strong>通过 IEEE 的 EUI-64 规范生成&lt;/strong> # 这是最常用的方式。在有的地方，也称为无状态配置&lt;/li>
&lt;/ul>
&lt;p>IEEE EUI-64 规范是将网络设备的 MAC 地址转换为 IPv6 接口标识的过程，如下图所示，MAC 地址的前 24 位（用 c 表示的部分）为公司标识，后 24 位（用 m 表示的部分）为扩展标识符。高 7 位是 0 表示了 MAC 地址本地唯一。转换的第一步将 FFFE 插入 MAC 地址的公司标识和扩展标识符之间， 第二步将高 7 位的 0 改为 1 表示此接口标识全球唯一。
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/mzn9uc/1631458464439-6142be5c-2a5e-4c08-8aa2-87abcc2ba854.png" alt="image.png">
例如：MAC 地址：&lt;code>00-0E-0C-82-C4-D4&lt;/code>；转换后：&lt;code>020E:0CFF:FE:82:C4D4&lt;/code>。
这种由 MAC 地址产生 IPv6 地址接口标识的方法可以减少配置的工作量，尤其是当采用无状态地址自动配置时，只需要获取一个 IPv6 前缀就可以与接口标识形成 IPv6 地址。但是使用这种方式最大的缺点是任何人都可以通过二层 MAC 地址推算出三层 IPv6 地址。&lt;/p>
&lt;h2 id="ipv6-地址分类">IPv6 地址分类&lt;/h2>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/mzn9uc/1631432277341-adbd47b9-16b3-4918-91d3-b473806fe36e.png" alt="image.png">
IPv6 没有广播地址(以更丰富的组播地址代替)，分类如下&lt;/p>
&lt;ul>
&lt;li>&lt;strong>Unicast Address(单播地址)&lt;/strong> # 全局单播地址可以分配给任何一个想要接入互联网的设备。
&lt;ul>
&lt;li>&lt;strong>共有地址&lt;/strong>
&lt;ul>
&lt;li>**Global Unicast Address(全局单播地址) **# 前缀为 &lt;code>2000::/3&lt;/code>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>私有地址&lt;/strong> #
&lt;ul>
&lt;li>&lt;strong>Link-local Address(链路本地地址)&lt;/strong> # 前缀为 &lt;code>FE80::/10&lt;/code>。当两个支持 IPv6 特性的设备直连时，直连的接口会自动给自己分配一个链路本地地址，用来在没有管理员的配置下设备之间就能相互通信，并完成邻居发现等工作。这类地址的前 10 bit 是 &lt;code>FE80&lt;/code>，后 54 bit 全是 0，最后 64 bit 是 EUI-64 地址，所以，上面例子中的链路本地地址是 &lt;code>FE80::0000:09C0:876A:130B&lt;/code>。
&lt;ul>
&lt;li>IPv4 中的 169.254.0.0/8 就是链路本地地址。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>Unique Local Address(唯一本地地址)&lt;/strong> # 前缀为 &lt;code>FC00::/7&lt;/code>。与链路本地地址一样，区别在于链路本地地址只能用于共享链路上的设备，而站点本地地址可以用于站点内部，获得站点本地地址的设备是不能将数据包路由到站点之外的，也就是说，站点本地地址将限制数据包的传递。
&lt;ul>
&lt;li>&lt;strong>Site-local Address(站点本地地址)&lt;/strong> # 在 RFC 3879 中阐述了站点本地地址会产生的问题，于 2004 年 9 月被启用，使用 Unique Local Address 代替。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>loopbak(环回地址)&lt;/strong> # 前缀为 &lt;code>::1/128&lt;/code>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>Anycat Address(任意播地址)&lt;/strong> #&lt;/li>
&lt;li>&lt;strong>Multicast Address(组播地址)&lt;/strong> # 前缀为 &lt;code>FF00::/8&lt;/code>，作用和 IPv4 的组播相同
&lt;ul>
&lt;li>被请求节点组播地址 # 前缀为 &lt;code>FF02::1FF00:0000/104&lt;/code>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;blockquote>
&lt;p>备注：&lt;/p>
&lt;ul>
&lt;li>为什么这里叫做“全局单播地址”，而“唯一本地地址”却不叫做“唯一本地单播地址”，好吧，其实都是简称，在 RFC 里是这么定义的：“Global Unicast Addresses”、“Link-Local IPv6 Unicast Addresses”。其实“全局单播地址”是可以叫做“全局地址”的，只是这样显得有点别扭。&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>这是一个设备上 IPv6 的地址&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>以太网适配器 以太网:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> 连接特定的 DNS 后缀 . . . . . . . : lan
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> IPv6 地址 . . . . . . . . . . . . : 2408:8210:3c36:c1c0::a2a
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> IPv6 地址 . . . . . . . . . . . . : 2408:8210:3c36:c1c0:42e:b860:ccb3:81e9
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> 临时 IPv6 地址. . . . . . . . . . : 2408:8210:3c36:c1c0:f4ba:1e1e:cc62:938a
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> 本地链接 IPv6 地址. . . . . . . . : fe80::42e:b860:ccb3:81e9%10
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> IPv4 地址 . . . . . . . . . . . . : 192.168.254.245
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> 子网掩码 . . . . . . . . . . . . : 255.255.255.0
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> 默认网关. . . . . . . . . . . . . : fe80::ded8:7cff:fe11:ebdf%10
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> 192.168.254.1
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="全局单播地址">全局单播地址&lt;/h2>
&lt;p>当我们需要给设备配置 IPv6 地址时，与 IPv4 公网地址类似，分为这么几部分：&lt;/p>
&lt;ul>
&lt;li>网络前缀&lt;/li>
&lt;li>子网 ID&lt;/li>
&lt;li>接口标识&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/mzn9uc/1631505253266-7dddac0e-c557-4e7d-973a-ea776134ef66.png" alt="image.png">
IANA 组织当前划定的单播地址是 &lt;code>2000::/3&lt;/code>，这个地址段占整个 IPv6 地址空间的 1/8，然后再将这个地址段逐级分下去。&lt;code>/23&lt;/code> 是注册机构前缀，&lt;code>/32&lt;/code> 是 ISP(运营商) 前缀，&lt;code>/48&lt;/code> 是站点前缀，&lt;code>/64&lt;/code> 是子网前缀。&lt;/p>
&lt;ul>
&lt;li>根据 &lt;a href="https://www.rfc-editor.org/rfc/rfc4291.html#section-2.5.1">RFC 4191-2.5.1&lt;/a> 中的描述，对于 IPv6 所有单播地址，如果地址的前 3 bit 不是 000，则接口标识必须为 64 bit；如果地址前 3 bit 是 000，则没有此限制。
&lt;ul>
&lt;li>这里前 3 bit 为 0，也就意味着，IP 地址从 &lt;code>2000::&lt;/code> 开始，如果是小于 &lt;code>2000::&lt;/code> 的话，前 3 bit 肯定是 0。所以，这里的规定也与 &lt;code>2000::&lt;/code> 开始的地址都是单播地址这个规定对应上了。&lt;/li>
&lt;li>并且，通常来说，单播地址都是 &lt;code>/64&lt;/code> 的。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>前 64 bit
&lt;ul>
&lt;li>前 48 位由互联网网络提供商(IANA、RIR、ISP 等)分配&lt;/li>
&lt;li>后面 16 是个人根据前 48 位而划分的子网&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>后 64 bit
&lt;ul>
&lt;li>就是子网下的主机了&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>在 IPv6 地址空间中的脚注中，可以看到很多 IANA 保留的全局单播地址前缀：&lt;/p>
&lt;ul>
&lt;li>&lt;strong>2001:0::/23&lt;/strong> # 为 IETF 协议分配 [ RFC2928 ] 保留。&lt;/li>
&lt;li>&lt;strong>2001:0::/32&lt;/strong> # 为 TEREDO [ RFC4380 ] 保留。&lt;/li>
&lt;li>&lt;strong>2001:2::/48&lt;/strong> # 保留用于基准测试 [ RFC5180 ][ RFC Errata 1752 ]。&lt;/li>
&lt;li>&lt;strong>2001:3::/32&lt;/strong> # 为 AMT [ RFC7450 ] 保留。&lt;/li>
&lt;li>&lt;strong>2001:4:112::/48&lt;/strong> # 为 AS112-v6 [ RFC7535 ] 保留。&lt;/li>
&lt;li>&lt;strong>2001:10::/28&lt;/strong> # 已弃用（以前称为 ORCHID）[ RFC4843 ]。&lt;/li>
&lt;li>&lt;strong>2001:20::/28&lt;/strong> # 为 ORCHIDv2 [ RFC7343 ] 保留。&lt;/li>
&lt;li>&lt;strong>2001:db8::/32&lt;/strong> # 为文档保留，也就是说在书籍、文档等地方使用 IPv6 地址示例时，使用这个前缀的地址。参考：&lt;a href="https://www.iana.org/go/rfc3849">RFC3849&lt;/a>。&lt;/li>
&lt;li>&lt;strong>2002::/16&lt;/strong> # 为 6to4 [ RFC3056 ] 保留。&lt;/li>
&lt;/ul>
&lt;h1 id="ipv6-地址的配置方式">IPv6 地址的配置方式&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://github.com/radvd-project">GitHub 组织，radvd-project&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://datatracker.ietf.org/doc/html/rfc4862">RFC 4862，IPv6 Stateless Address Autoconfiguration&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>与 IPv4 一样，在 IPv6 里，任何单播地址都可以自动生成，也可以手工配置固定 IP，具体看应用场景：&lt;/p>
&lt;ul>
&lt;li>客户端：如果我想访问 ipv6 互联网，而不对外提供服务，那么使用自动生成即可，无需使用固定的 ip 地址&lt;/li>
&lt;li>服务端：如果需要对外提供服务，那么 ip 地址就需要固定了，不能使用自动生成&lt;/li>
&lt;/ul>
&lt;p>自动配置地址的场景，在 IPv6 里分为 2 种方法：“有状态”与“无状态”&lt;/p>
&lt;ul>
&lt;li>&lt;strong>Stateful(有状态)&lt;/strong> # 地址由 DHCPv6 Server 统一管理，DHCPv6 Client 从中获得一个可用的 IP 地址&lt;/li>
&lt;li>&lt;strong>Stateless(无状态)&lt;/strong> # 路由器发出“路由通告”报文（Router Advertisement，简称 RA），报文内包含了 IPv6 地址的前缀信息。当收到 RA 包后，就会根据其中前缀信息，自动生成一个或多个 IP 地址&lt;/li>
&lt;/ul>
&lt;h2 id="stateless无状态">Stateless(无状态)&lt;/h2>
&lt;p>**Stateless Address Autoconfiguration(无状态地址自动配置，简称 SLAAC) **是 IPv6 中用于自动生成 IPv6 地址的策略。&lt;/p>
&lt;p>在操作系统启动时，会自动在每个启用 IPv6 的接口上创建“链路本地地址”，当连接到网络时，会执行冲突解决。这个地址默认使用 &lt;code>fe80::/64&lt;/code> 作为前缀。该行为使用 &lt;strong>Neighbor Discovery Protocol(邻居发现协议，简称 DNP)&lt;/strong> 的一个组件，通过 SLAAC 独立进行&lt;/p>
&lt;blockquote>
&lt;p>当自动生成的链路本地地址在网络上冲突时，该 IP 地址的状态会提示 &lt;a href="#VNOuu">tentative noprefixroute dadfailed&lt;/a>&lt;/p>
&lt;/blockquote>
&lt;p>除了“链路本地地址”，路由器会通过 &lt;strong>Router Advertisement(路由通过，简称 RA)&lt;/strong> 提供给主机一个网络前缀，以便操作系统自动配置一个 IPv6 “单播地址”。所以，尽管存在 DHCPv6，但是 IPv6 主机通常都是使用 RA 来自动创建全局可路由的单播地址。&lt;/p>
&lt;p>与 IPv4 一样，IPv6 支持全球唯一的 IP 地址。 IPv6 的设计旨在通过淘汰网络地址转换，重新强调网络设计的端到端原则，该原则最初是在早期 Internet 建立期间构想的。因此，网络上的每个设备都可以直接从任何其他设备全局寻址。&lt;/p>
&lt;p>一个稳定的、唯一的、全球可寻址的 IP 地址将有助于跨网络跟踪设备。因此，对于笔记本电脑和手机等移动设备而言，此类地址是一个特殊的隐私问题。为了解决这些隐私问题，SLAAC 协议包括通常称为“隐私地址”或更准确地说是 &lt;strong>Temporary Addresses(临时地址)&lt;/strong> 的内容，编入 RFC 4941，“IPv6 中无状态地址自动配置的隐私扩展”。临时地址是随机且不稳定的。典型的消费设备每天都会生成一个新的临时地址，一周后会忽略发往旧地址的流量。 Windows 自 XP SP1 起默认使用临时地址，macOS 自 (Mac OS X) 10.7 起，Android 自 4.0 起，iOS 自 4.3 版起默认使用。 Linux 发行版对临时地址的使用各不相同。&lt;/p>
&lt;h3 id="neighbor-discovery-protocol邻居发现协议">Neighbor Discovery Protocol(邻居发现协议)&lt;/h3>
&lt;p>ARP 协议是 IPv4 用于解析目标 MAC 地址的协议，而在 IPv6 里，解析地址采用的是&lt;strong>邻居发现（Neighbor Discovery Protocol，简称 NDP 或 ND）&lt;/strong>&lt;/p>
&lt;p>ND 不是一个具体协议，而是用来描述多个相关功能的协议的&lt;strong>抽象集合&lt;/strong>，所涵盖的所有协议均是基于 ICMPv6。其中有 2 种报文与解析 MAC 地址有关：&lt;/p>
&lt;ul>
&lt;li>&lt;strong>邻居请求报文 NS（Neighbor Solicitation）&lt;/strong>：请求解析&lt;/li>
&lt;li>&lt;strong>邻居通告报文 NA（Neighbor Advertisement）&lt;/strong>：响应解析&lt;/li>
&lt;/ul>
&lt;p>这与 ping 是非常类似的：&lt;/p>
&lt;ul>
&lt;li>ping：发送 icmp 的 echo request 报文，对端响应 icmp 的 echo reply 报文&lt;/li>
&lt;li>地址解析：发送 icmp 的 ns 报文，对端响应 icmp 的 na 报文&lt;/li>
&lt;/ul>
&lt;p>更多详情见《[ARP 与 NDP](✏IT 学习笔记/🌐4.数据通信/通信协议/2.ARP%20 与%20NDP.md 与 NDP.md)》&lt;/p>
&lt;h3 id="router-advertisement路由通告">Router Advertisement(路由通告)&lt;/h3>
&lt;p>&lt;strong>Router Advertisement(路由通告，简称 RA)&lt;/strong>&lt;/p>
&lt;p>在 Linux 中，有一个名为 &lt;a href="https://github.com/radvd-project">radvd&lt;/a> 的程序，可以让服务器发送 RA 报文。&lt;/p>
&lt;h3 id="temporary-addresses临时地址">Temporary addresses(临时地址)&lt;/h3>
&lt;p>无状态地址自动配置使用全局唯一和静态 MAC 地址来创建接口标识符，提供了跟踪用户设备（跨时间和 IPv6 网络前缀更改）以及用户的机会。&lt;/p>
&lt;blockquote>
&lt;p>因为知道了 MAC，就可以推导出来 IPv6 地址&lt;/p>
&lt;/blockquote>
&lt;p>为了减少用户身份永久绑定到 IPv6 地址部分的可能性，节点可以创建具有基于随时间变化的随机位字符串和相对较短的生命周期（数小时到数天）的接口标识符的临时地址，之后它们替换为新地址。&lt;/p>
&lt;p>临时地址可用作发起连接的源地址，而外部主机通过查询域名系统使用公共地址。&lt;/p>
&lt;p>默认情况下，为 IPv6 配置的网络接口在 OS X Lion 和更高版本的 Apple 系统以及 Windows Vista、Windows 2008 Server 和更高版本的 Microsoft 系统中使用临时地址。&lt;/p>
&lt;h2 id="常用-ipv6-地址">常用 IPv6 地址&lt;/h2>
&lt;p>运营商前缀&lt;/p>
&lt;ul>
&lt;li>电信为 240e::/20&lt;/li>
&lt;li>移动为 2409:8000::/20&lt;/li>
&lt;li>联通为 2408:8000::/20&lt;/li>
&lt;/ul>
&lt;p>2001:db8:0:1::/64 # 通常使用这个网段的地址，很多网站(比如 Redhat、ISC-DHCP 等)的例子都是这个段，比如：&lt;/p>
&lt;ul>
&lt;li>2001:db8:0:1::1&lt;/li>
&lt;li>2001:db8:0:1::2&lt;/li>
&lt;li>&amp;hellip;&amp;hellip;&lt;/li>
&lt;li>2001:db8:42:1::&lt;/li>
&lt;li>&amp;hellip;&amp;hellip;&lt;/li>
&lt;li>2001:db8:0:1::fffe&lt;/li>
&lt;/ul>
&lt;h1 id="ipv6-datagram-结构">IPv6 Datagram 结构&lt;/h1>
&lt;p>IPv6 数据报被封装在链路层的 Frame 中&lt;/p>
&lt;p>首部长度固定为 40 Bytes，即 320 bit。
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/mzn9uc/1631514605323-4532e443-754c-44ce-8c4f-70c31b7065e8.jpeg" alt="">&lt;/p>
&lt;ul>
&lt;li>&lt;strong>Version(版本)&lt;/strong> # 和 IPv4 一样，由 4 比特构成。IPv6 其版本号为 6，因此在这个字段上的值为“6”。&lt;/li>
&lt;li>&lt;strong>Traffic Class(通信类)&lt;/strong> # 相当于 IPv4 的 Type Of Service(TOS) 字段，也由 8 bit 构成。但 TOS 在 IPv4 中几乎没有什么建树，未能成为卓有成效的技术，本来计划在 IPv6 中删掉这个字段，不过出于今后研究的考虑还是保留了该字段。&lt;/li>
&lt;li>&lt;strong>Flow Label(流标签)&lt;/strong> # 由 20 bit 构成，准备用于 Quality Of Service(服务质量，简称 QOS) 控制。使用这个字段提供怎样的服务已经成为未来研究的课题。不适用 Qos 时每一位可以全部设置为 0。 在进行服务质量控制的时，将流标号设置为一个随机数，然后利用一种可以设置流的协议 RSVP（Resource Reservation Protocol ）在路由器上进行 Qos 设置。当某个包在发送途中需要 Qos 时，需要附上 RSVP 预想的流标号。路由器接收到这样的 IP 包后现先将流标号作为查找关键字，迅速从服务质量控制信息中查找并做相应处理。此外，只有流标号、源地址以及目标地址三项完全一致时，才被认为是一个流。&lt;/li>
&lt;li>&lt;strong>Payload Length(有效荷载长度)&lt;/strong> # 上层 PDU 与 扩展首部的和，单位是字节。 IPv4 的 TL(Total Length) 是指包含首部在内的所有长度。然而 IPv6 中的这个 Playload Length 不包括首部，只表示数据部分的长度。由于 IPv6 的可选项是指连接 IPv6 首部的数据，只有当有可选项时，此处包含可选项数据的所有长度就是 Playload Length。&lt;/li>
&lt;li>&lt;strong>Next Header(下一个首部)&lt;/strong> # 相当于 IPv4 中的协议字段。由 8 比特构成。通常表示 IP 的上一层协议是 TCP 或 UDP。不过在有 IPv6 扩展首部的情况下，该字段表示后面第一个扩展首部的协议类。&lt;/li>
&lt;li>&lt;strong>Hop Limit(跳数限制)&lt;/strong> # 由 8 bit 构成。与 IPv4 中的 TTL 意思相同。为了强调“可通过路由器个数”这个概念，才将名字改为 Hop Limit。数据每经过一次路由器就减 1，减到 0 则丢弃数据。&lt;/li>
&lt;li>&lt;strong>Source Address(源地址)&lt;/strong> # 由 128 bit 构成，表示发送端 IP 地址。&lt;/li>
&lt;li>&lt;strong>Destination Address(目标地址)&lt;/strong> # 由 128 bit 构成，表示接收端 IP 地址。&lt;/li>
&lt;li>&lt;strong>Extension Head(扩展首部)&lt;/strong> # IPv6 的首部长度固定，无法将可选项将入其中，取而代之的是通过扩展首部对功能进行了有效扩展。 扩展首部通常介于 IPv6 首部与 TCP/UDP 首部中间。在 IPv4 中可选项长度固定为 40 字节，但是在 IPv6 中没有这样的限制。也就是说，IPv6 的扩展首部可以是任意长度。扩展首部当中还可以包含扩展首部协议以及下一个扩展首部字段。
&lt;ul>
&lt;li>IPv6 的分片机制，也是通过 IPv6 的扩展首部来实现的。不再像 IPv4 一样，通过首部中的 标示、标志和偏移字段 进行分片识别。IPv6 网络中的中间路由器不再处理分片，只在产生数据包的源节点处理分片。&lt;/li>
&lt;li>IPv6 数据报中包含 0 个、1 个或多个扩展首部。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h2 id="ipv6-扩展首部">IPv6 扩展首部&lt;/h2>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/mzn9uc/1631515308493-c6b27a8f-9a24-4c8e-b6c7-f5e8caaa9ab6.png" alt="image.png">&lt;/p>
&lt;h1 id="ipv6-问题总结">IPv6 问题总结&lt;/h1>
&lt;p>使用 WireGuard 时，如果中继服务器的两端的 Peer，一个是 IPv4、一个是 IPv6，那么交互时，如果使用 ps -ef 这种命令，显示将会卡住，无法刷出后半部分内容。&lt;/p>
&lt;h2 id="tentative-noprefixroute-dadfailed-状态">tentative noprefixroute dadfailed 状态&lt;/h2>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/mzn9uc/1643038958219-72693ffb-e644-42ac-b20f-320e6bb6c9eb.png" alt="image.png">
可能的原因是 IP 地址冲突，比如虚拟机的 MAC 相同了，生成的 IPv6 就会相同&lt;/p>
&lt;p>如果不换 MAC，还可以修改内核参数解决&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>net.ipv6.conf.all.accept_dad &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>net.ipv6.conf.default.accept_dad &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>net.ipv6.conf.all.use_tempaddr &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>net.ipv6.conf.default.use_tempaddr &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h1 id="ipv6-地址的分配机制">IPv6 地址的分配机制&lt;/h1>
&lt;p>网络前缀由 IANA 一层层分配。&lt;a href="https://www.iana.org/assignments/ipv6-address-space/ipv6-address-space.xhtml">IPv6 地址空间&lt;/a> 中包含了当前 IPv6 地址的总体分配情况，&lt;a href="https://www.iana.org/assignments/ipv6-unicast-address-assignments/ipv6-unicast-address-assignments.xhtml">IPv6 全局单播地址分配&lt;/a>中，则是单播地址的分配情况。&lt;/p>
&lt;p>详见&lt;a href=".md">《IP》章节的 Ip 地址分配机制&lt;/a>部分&lt;/p>
&lt;h2 id="isp-分配机制">ISP 分配机制&lt;/h2>
&lt;p>ISP 给我们分配 IPv6 时，会同时分配两个不同网段的 IPv6 地址&lt;/p>
&lt;ul>
&lt;li>唯一地址 # 为光猫分配的地址，不会作下行分配(即，光猫内的设备不用使用这个地址进行访问)&lt;/li>
&lt;li>前缀地址 # 为光猫内部设备分配地址的地址段&lt;/li>
&lt;/ul>
&lt;p>按照 IPv6 的分配规则，前缀地址必须在/60 位以内。目前中国的运营商有两种前缀，一个是 56 位，一个是 60 位。电信多是 56，联通移动多是 60 的。&lt;/p>
&lt;blockquote>
&lt;p>电信为 240e::/18
移动为 2409:8000::/20
联通为 2408:8000::/20&lt;/p>
&lt;/blockquote>
&lt;p>当然，这个长度没有好与坏，不管是 56 还是 60，你获得的剩余地址量都是用不完的，哪怕是给你家里每一粒灰尘都分配上公网 IP。
问题就在于，运营商只会给你分配一次前缀地址，当你的路由器获取到前缀地址后，你其它的设备都会通过这个前缀地址向下分配剩余的地址。打个比方，通过 PPPoE 拨号，你将会获取到 WAN 口 IP 地址，这个机制和 IPv4 是一样的：
&lt;code>2408:8210:4703:130b:9032:f35a:a8ab:fdf1/64&lt;/code>
然后你还可以获取到一个前缀 IP 地址：
&lt;code>2408:8210:3c36:c1c0::1/56&lt;/code>
当你的手机连接 WIFI 的时候，路由器就会按照这个前缀地址给你的手机向下分配剩余的地址，如：
&lt;code>2408:8210:3c36:c1c0:XXXX:XXXX:XXXX:XXXX&lt;/code>
[&lt;/p>
&lt;p>](https://cloud.tencent.com/developer/article/1468099)&lt;/p>
&lt;h2 id="heading">&lt;/h2></description></item><item><title>Docs: NAT</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/4.%E6%95%B0%E6%8D%AE%E9%80%9A%E4%BF%A1/nat/nat/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/4.%E6%95%B0%E6%8D%AE%E9%80%9A%E4%BF%A1/nat/nat/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Network_address_translation">Wiki,Network Address Translation&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.rfc-editor.org/rfc/rfc4787.html">RFC 4787&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.rfc-editor.org/rfc/rfc5382.html">RFC 5382,TCP 的 NAT 行为要求&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.rfc-editor.org/rfc/rfc5508.html">RFC 5508,ICMP 的 NAT 行为要求&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://mp.weixin.qq.com/s/IzdUBvnRze4GGC6yCqmJwA">公众号,云原生实验室-NAT 穿透是如何工作的：技术原理及企业级实践&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>&lt;strong>Network address translation(网络地址转换，简称 NAT)&lt;/strong> 是一种通过修改数据包的 IP 报头中的网络地址信息，将一个 IP 地址空间重新映射到另一个 IP 地址空间的方法，同时它们在流量路由设备中传输。[1] 该技术最初用作快捷方式，以避免在移动网络时重新寻址每个主机。面对 IPv4 地址耗尽，它已成为保护全球地址空间的流行和必不可少的工具。NAT 网关的一个可互联网路由的 IP 地址可用于整个专用网络。&lt;/p>
&lt;p>IP 伪装是一种隐藏整个 IP 地址空间的技术，通常由私有 IP 地址组成，位于另一个 IP 地址的后面，通常是公共地址空间。必须隐藏的地址被更改为单个（公共）IP 地址作为传出 IP 数据包的“新”源地址，因此它看起来不是来自隐藏主机而是来自路由设备本身。由于这种技术的普及，以节省 IPv4 地址空间，术语 NAT 实际上已成为 IP 伪装的同义词。&lt;/p>
&lt;p>由于网络地址转换修改了数据包中的 IP 地址信息，因此对 Internet 连接的质量产生严重影响，需要特别注意其实现的细节。NAT 实现在各种寻址情况下的特定行为及其对网络流量的影响方面差异很大。包含 NAT 实现的设备供应商通常不记录 NAT 行为的细节。&lt;/p>
&lt;h1 id="nat-实现分类">NAT 实现分类&lt;/h1>
&lt;p>NAT 按照 **NAT 映射行为 **和 &lt;strong>有状态防火墙行为&lt;/strong> 可以分为多种类型&lt;/p>
&lt;ul>
&lt;li>Full-cone&lt;/li>
&lt;li>Retricted-cone&lt;/li>
&lt;li>Port-restricted cone&lt;/li>
&lt;li>Symmetric&lt;/li>
&lt;/ul>
&lt;p>但对于 NAT 穿透来说根本不需要关心这么多类型，只需要看 &lt;strong>NAT 或者有状态防火墙是否会严格检查目标 Endpoint&lt;/strong>，根据这个因素，可以将 NAT 分为 &lt;strong>Easy NAT&lt;/strong> 和 &lt;strong>Hard NAT&lt;/strong>。&lt;/p>
&lt;ul>
&lt;li>&lt;strong>Easy NAT&lt;/strong> 及其变种称为 “Endpoint-Independent Mapping” (&lt;strong>EIM，终点无关的映射&lt;/strong>) 这里的 Endpoint 指的是目标 Endpoint，也就是说，有状态防火墙只要看到有客户端自己发起的出向包，就会允许相应的入向包进入，&lt;strong>不管这个入向包是谁发进来的都可以&lt;/strong>。&lt;/li>
&lt;li>&lt;strong>hard NAT&lt;/strong> 以及变种称为 “Endpoint-Dependent Mapping”（&lt;strong>EDM，终点相关的映射&lt;/strong>） 这种 NAT 会针对每个目标 Endpoint 来生成一条相应的映射关系。在这样的设备上，如果客户端向某个目标 Endpoint 发起了出向包，假设客户端的公网 IP 是 2.2.2.2，那么有状态防火墙就会打开一个端口，假设是 4242。那么只有来自该目标 Endpoint 的入向包才允许通过 2.2.2.2:4242，其他客户端一律不允许。这种 NAT 更加严格，所以叫 Hard NAT。&lt;/li>
&lt;/ul></description></item><item><title>Docs: NAT 穿透是如何工作的：技术原理及企业级实践</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/4.%E6%95%B0%E6%8D%AE%E9%80%9A%E4%BF%A1/nat/nat-%E7%A9%BF%E9%80%8F%E6%98%AF%E5%A6%82%E4%BD%95%E5%B7%A5%E4%BD%9C%E7%9A%84%E6%8A%80%E6%9C%AF%E5%8E%9F%E7%90%86%E5%8F%8A%E4%BC%81%E4%B8%9A%E7%BA%A7%E5%AE%9E%E8%B7%B5/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/4.%E6%95%B0%E6%8D%AE%E9%80%9A%E4%BF%A1/nat/nat-%E7%A9%BF%E9%80%8F%E6%98%AF%E5%A6%82%E4%BD%95%E5%B7%A5%E4%BD%9C%E7%9A%84%E6%8A%80%E6%9C%AF%E5%8E%9F%E7%90%86%E5%8F%8A%E4%BC%81%E4%B8%9A%E7%BA%A7%E5%AE%9E%E8%B7%B5/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://arthurchiao.art/blog/how-nat-traversal-works-zh/">arthurchiao 博客，NAT 穿透是如何工作的：技术原理及企业级实践&lt;/a>
&lt;ul>
&lt;li>&lt;a href="https://mp.weixin.qq.com/s/IzdUBvnRze4GGC6yCqmJwA">公众号,云原生实验室-NAT 穿透是如何工作的：技术原理及企业级实践&lt;/a>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;h2 id="译者序">译者序&lt;/h2>
&lt;p>本文翻译自 2020 年的一篇英文博客：How NAT traversal works[1]。&lt;/p>
&lt;p>设想这样一个问题：在北京和上海各有一台&lt;strong>局域网的机器&lt;/strong>（例如一台是家里的台式机，一 台是连接到星巴克 WiFi 的笔记本），二者都是私网 IP 地址，但可以访问公网， &lt;strong>如何让这两台机器通信呢？&lt;/strong>&lt;/p>
&lt;p>既然二者都能访问公网，那最简单的方式当然是在公网上架设一个中继服务器：两台机器分别连接到中继服务，后者完成双向转发。这种方式显然有很大的性能开销，而 且中继服务器很容易成为瓶颈。&lt;/p>
&lt;p>有没有办法不用中继，让&lt;strong>两台机器直接通信&lt;/strong>呢？&lt;/p>
&lt;p>如果有一定的网络和协议基础，就会明白这事儿是可能的。Tailscale 的这篇&lt;strong>史诗级长文&lt;/strong>由浅入深地展示了这种 “可能”，如果完全实现本文所 介绍的技术，你将得到一个企业级的 NAT / 防火墙穿透工具。此外，如作者所说，&lt;strong>去中心化软件&lt;/strong>领域中的许多有趣想法，简化之后其实都变成了 &lt;strong>跨过公网（互联网）实现端到端直连&lt;/strong> 这一问题，因此本文的意义并不仅限于 NAT 穿透本身。&lt;/p>
&lt;p>&lt;strong>由于译者水平有限，本文不免存在遗漏或错误之处。如有疑问，请查阅原文。&lt;/strong>&lt;/p>
&lt;p>以下是译文。&lt;/p>
&lt;hr>
&lt;p>在前一篇文章 How Tailscale Works[2] 中， 我们已经用较长篇幅介绍了 Tailscale 是如何工作的。但其中并没有详细描述我们是 &lt;strong>如何穿透 NAT 设备，从而实现终端设备直连的&lt;/strong> —— 不管这些终端之间 有什么设备（防火墙、NAT 等），以及有多少设备。本文试图补足这一内容。&lt;/p>
&lt;h2 id="1-引言">1 引言&lt;/h2>
&lt;h3 id="11-背景ipv4-地址短缺引入-nat">1.1 背景：IPv4 地址短缺，引入 NAT&lt;/h3>
&lt;p>全球 IPv4 地址早已不够用，因此人们发明了 NAT（网络地址转换）来缓解这个问题。&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/1d06e237-bda9-4955-bc7d-9f1595c7ec8d/0" alt="">&lt;/p>
&lt;p>&lt;strong>云原生实验室&lt;/strong>&lt;/p>
&lt;p>本公众号研究云原生领域相关技术，包括但不限于 Kubernetes、Envoy、Prometheus、Docker、Istio 等，同时还会分享一些资源整合、xx 上网以及各种你想象不到的奇技淫巧。&lt;/p>
&lt;p>120 篇原创内容&lt;/p>
&lt;p>公众号&lt;/p>
&lt;p>简单来说，大部分机器都使用&lt;strong>私有 IP 地址&lt;/strong>，如果它们需要访问公网服务，那么，&lt;/p>
&lt;ul>
&lt;li>出向流量：需要经过一台 NAT 设备，它会对流量进行 SNAT，将私有 srcIP+Port 转 换成 NAT 设备的公网 IP+Port（这样应答包才能回来），然后再将包发出去；&lt;/li>
&lt;li>应答流量（入向）：到达 NAT 设备后进行相反的转换，然后再转发给客户端。&lt;/li>
&lt;/ul>
&lt;p>整个过程对双方透明。&lt;/p>
&lt;blockquote>
&lt;p>更多关于 NAT 的内容，可参考 (译) NAT - 网络地址转换（2016）[3]。译注。&lt;/p>
&lt;/blockquote>
&lt;p>以上是本文所讨论问题的&lt;strong>基本背景&lt;/strong>。&lt;/p>
&lt;h3 id="12-需求两台经过-nat-的机器建立点对点连接">1.2 需求：两台经过 NAT 的机器建立点对点连接&lt;/h3>
&lt;p>在以上所描述的 NAT 背景下，我们从最简单的问题开始：如何在两台经过 NAT 的机器之间建立 &lt;strong>点对点连接&lt;/strong>（直连）。如下图所示：&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/1d06e237-bda9-4955-bc7d-9f1595c7ec8d/640" alt="">&lt;/p>
&lt;p>直接用机器的 IP 互连显然是不行的，因为它们都是私有 IP（例如 &lt;code>192.168.1.x&lt;/code>）。在 Tailscale 中，我们会建立一个 &lt;strong>WireGuard® 隧道&lt;/strong> 来解决这个问题 —— 但这并不是太重要，因为我们将&lt;strong>过去几代人努力&lt;/strong>都整合到了一个工具集， &lt;strong>这些技术广泛适用于各种场景&lt;/strong>。例如，&lt;/p>
&lt;ol>
&lt;li>WebRTC[4] 使用这些技术在浏览器之间完成 peer-to-peer 语音、视频和数据传输，&lt;/li>
&lt;li>&lt;strong>VoIP 电话和一些视频游戏&lt;/strong>也使用类似机制，虽然不是所有情况下都很成功。&lt;/li>
&lt;/ol>
&lt;p>接下来，本文将&lt;strong>在一般意义上讨论这些技术&lt;/strong>，并在合适的地方拿 Tailscale 和其他一些东西作为例子。&lt;/p>
&lt;h3 id="13-方案nat-穿透">1.3 方案：NAT 穿透&lt;/h3>
&lt;h4 id="131-两个必备前提udp--能直接控制-socket">1.3.1 两个必备前提：UDP + 能直接控制 socket&lt;/h4>
&lt;p>如果想&lt;strong>设计自己的协议来实现 NAT 穿透&lt;/strong>，那必须满足以下两个条件：&lt;/p>
&lt;ol>
&lt;li>&lt;strong>协议应该基于 UDP&lt;/strong>。
理论上用 TCP 也能实现，但它会给本已相当复杂的问题再增加一层复杂性， 甚至还需要定制化内核 —— 取决于你想实现到什么程度。本文接下来都将关注在 UDP 上。
如果考虑 TCP 是想在 NAT 穿透时获得&lt;strong>面向流的连接&lt;/strong>（ stream-oriented connection），可以考虑用 &lt;strong>QUIC&lt;/strong> 来替代，它构 建在 UDP 之上，因此我们能将关注点放在 UDP NAT 穿透，而仍然能获得一个 很好的流协议（stream protocol）。&lt;/li>
&lt;li>对收发包的 &lt;strong>socket 有直接控制权&lt;/strong>。
例如，从经验上来说，无法基于某个现有的网络库实现 NAT 穿透，因为我们 &lt;strong>必须在使用的 “主要” 协议之外，发送和接收额外的数据包&lt;/strong>。
某些协议（例如  WebRTC）将 NAT 穿透与其他部分紧密集成。但如果你在构建自己的协议， &lt;strong>建议将 NAT 穿透作为一个独立实体，与主协议并行运行&lt;/strong>，二者仅 仅是共享 socket 的关系，如下图所示，这将带来很大帮助：
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/1d06e237-bda9-4955-bc7d-9f1595c7ec8d/640" alt="">&lt;/li>
&lt;/ol>
&lt;h4 id="132-保底方式中继">1.3.2 保底方式：中继&lt;/h4>
&lt;p>在某些场景中，直接访问 socket 这一条件可能很难满足。&lt;/p>
&lt;p>退而求其次的一个方式是设置一个 local proxy（本地代理），主协议与这个 proxy 通信 ，后者来完成 NAT 穿透，将包中继（relay）给对端。这种方式增加了一个额外的间接层 ，但好处是：&lt;/p>
&lt;ol>
&lt;li>仍然能获得 NAT 穿透，&lt;/li>
&lt;li>&lt;strong>不需要对已有的应用程序做任何改动&lt;/strong>。&lt;/li>
&lt;/ol>
&lt;h3 id="14-挑战有状态防火墙和-nat-设备">1.4 挑战：有状态防火墙和 NAT 设备&lt;/h3>
&lt;p>有了以上铺垫，下面就从最基本的原则开始，一步步看如何实现一个企业级的 NAT 穿透方案。&lt;/p>
&lt;p>我们的&lt;strong>目标&lt;/strong>是：&lt;strong>在两个设备之间通过 UDP 实现双向通信&lt;/strong>， 有了这个基础，上层的其他协议（WireGuard, QUIC, WebRTC 等）就能做一些更酷的事情。&lt;/p>
&lt;p>但即便这个看似最基本的功能，在实现上也要解决&lt;strong>两个障碍&lt;/strong>：&lt;/p>
&lt;ol>
&lt;li>有状态防火墙&lt;/li>
&lt;li>NAT 设备&lt;/li>
&lt;/ol>
&lt;h2 id="2-穿透防火墙">2 穿透防火墙&lt;/h2>
&lt;p>有状态防火墙是以上两个问题中相对比较容易解决的。实际上，&lt;strong>大部分 NAT 设备都自带了一个有状态防火墙&lt;/strong>， 因此要解决第二个问题，必须先解决有第一个问题。&lt;/p>
&lt;p>有状态防火墙具体有很多种类型，有些你可能见过：&lt;/p>
&lt;ul>
&lt;li>Windows Defender firewall&lt;/li>
&lt;li>Ubuntu’s ufw (using iptables/nftables)&lt;/li>
&lt;li>BSD/macOS &lt;code>pf&lt;/code>&lt;/li>
&lt;li>AWS Security Groups（&lt;strong>安全组&lt;/strong>）&lt;/li>
&lt;/ul>
&lt;h3 id="21-有状态防火墙">2.1 有状态防火墙&lt;/h3>
&lt;h4 id="211-默认行为策略">2.1.1 默认行为（策略）&lt;/h4>
&lt;p>以上防火墙的配置都是很灵活的，但大部分配置默认都是如下行为：&lt;/p>
&lt;ol>
&lt;li>&lt;strong>允许所有出向连接&lt;/strong>（allows all “outbound” connections）&lt;/li>
&lt;li>&lt;strong>禁止所有入向连接&lt;/strong>（blocks all “inbound” connections）&lt;/li>
&lt;/ol>
&lt;p>可能有少量例外规则，例如 allowing inbound SSH。&lt;/p>
&lt;h4 id="212-如何区分入向和出向包">2.1.2 如何区分入向和出向包&lt;/h4>
&lt;p>连接（connection）和方向（direction）都是协议设计者头脑中的概念，到了 &lt;strong>物理传输层，每个连接都是双向的&lt;/strong>；允许所有的包双向传输。那&lt;strong>防火墙是如何区分哪些是入向包、哪些是出向包的呢&lt;/strong>？这就要回到**“有状态”（stateful）**这三个字了：有状态防火墙会记录它 看到的每个包，当收到下一个包时，会利用这些信息（状态）来判断应该做什么。&lt;/p>
&lt;p>对 UDP 来说，规则很简单：如果防火墙之前看到过一个出向包（outbound），就会允许 相应的入向包（inbound）通过，以下图为例：&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/1d06e237-bda9-4955-bc7d-9f1595c7ec8d/640" alt="">&lt;/p>
&lt;p>笔记本电脑中自带了一个防火墙，当该防火墙看到从这台机器出去的 &lt;code>2.2.2.2:1234 -&amp;gt; 5.5.5.5:5678&lt;/code> 包时，就会记录一下：&lt;code>5.5.5.5:5678 -&amp;gt; 2.2.2.2:1234&lt;/code> 入向包应该放行。&lt;strong>这里的逻辑&lt;/strong>是：我们信任的世界（即笔记本）想主动与 &lt;code>5.5.5.5:5678&lt;/code> 通信，因此应该放行（allow）其回包路径。&lt;/p>
&lt;blockquote>
&lt;p>某些&lt;strong>非常&lt;/strong>宽松的防火墙只要看到有从 &lt;code>2.2.2.2:1234&lt;/code> 出去的包，就 会允许所有从外部进入 &lt;code>2.2.2.2:1234&lt;/code> 的流量。这种防火墙对我们的 NAT 穿透来说非 常友好，但已经越来越少见了。&lt;/p>
&lt;/blockquote>
&lt;h3 id="22-防火墙朝向face-off与穿透方案">2.2 防火墙朝向（face-off）与穿透方案&lt;/h3>
&lt;h4 id="221-防火墙朝向相同">2.2.1 防火墙朝向相同&lt;/h4>
&lt;h5 id="场景特点服务端-ip-可直接访问">场景特点：服务端 IP 可直接访问&lt;/h5>
&lt;p>在 NAT 穿透场景中，以上默认规则对 UDP 流量的影响不大 —— 只要&lt;strong>路径上所有防火墙的 “朝向” 是一样的&lt;/strong>。一般来说，从内网访问公网上的某个服务器都属于这种情况。&lt;/p>
&lt;p>我们唯一的要求是：&lt;strong>连接必须是由防火墙后面的机器发起的&lt;/strong>。这是因为 在它主动和别人通信之前，没人能主动和它通信，如下图所示：&lt;/p>
&lt;h5 id="穿透方案客户端直连服务端或-hub-and-spoke-拓扑">穿透方案：客户端直连服务端，或 hub-and-spoke 拓扑&lt;/h5>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/1d06e237-bda9-4955-bc7d-9f1595c7ec8d/640" alt="">&lt;/p>
&lt;p>但上图是&lt;strong>假设了&lt;/strong>通信双方中，其中一端**（服务端）是能直接访问到的**。在 VPN 场景中，这就形成了所谓的 &lt;strong>hub-and-spoke 拓扑&lt;/strong>：中心的 hub 没有任何防火墙策略，谁都能访问到；防火墙后面的 spokes 连接到 hub。如下图所示：&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/1d06e237-bda9-4955-bc7d-9f1595c7ec8d/640" alt="">&lt;/p>
&lt;h4 id="222-防火墙朝向不同">2.2.2 防火墙朝向不同&lt;/h4>
&lt;h5 id="场景特点服务端-ip-不可直接访问">场景特点：服务端 IP 不可直接访问&lt;/h5>
&lt;p>但如果两个 “客户端” 想直连，以上方式就不行了，此时两边的防火墙相向而立，如下图所示：&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/1d06e237-bda9-4955-bc7d-9f1595c7ec8d/640" alt="">&lt;/p>
&lt;p>根据前面的讨论，这种情况意味着：&lt;strong>两边要同时发起连接请求&lt;/strong>，但也意味着 两边都无法发起有效请求，因为对方先发起请求才能在它的防火墙上打开一条缝让我们进去！如何破解这个问题呢？一种方式是&lt;strong>让用户重新配置一边或两边的防火墙，打开一个端口&lt;/strong>， 允许对方的流量进来。&lt;/p>
&lt;ol>
&lt;li>这显然对用户不友好，在像 Tailscale 这样的 mesh 网络中的扩展性也不好，在 mesh 网络中，我们假设对端会以一定的粒度在公网上移动。&lt;/li>
&lt;li>此外，在很多情况下用户也没有防火墙的控制权限：例如在咖啡馆或机场中，连接的路 由器是不受你控制的（否则你可能就有麻烦了）。&lt;/li>
&lt;/ol>
&lt;p>因此，我们需要寻找一种不用重新配置防火墙的方式。&lt;/p>
&lt;h5 id="穿透方案两边同时主动建连在本地防火墙为对方打开一个洞">穿透方案：两边同时主动建连，在本地防火墙为对方打开一个洞&lt;/h5>
&lt;p>解决的思路还是先重新审视前面提到的有状态防火墙规则：&lt;/p>
&lt;ul>
&lt;li>对于 UDP，其规则（逻辑）是：&lt;strong>包必须先出去才能进来&lt;/strong>（packets must flow out before packets can flow back in）。&lt;/li>
&lt;li>注意，这里除了要满足包的 IP 和端口要匹配这一条件之外，&lt;strong>并没有要求包必须是相关的&lt;/strong>（related）。换句话说，只要某些包带着正确的源和目的地址出去了，&lt;strong>任何看起来像是响应的包都会被防火墙放进来&lt;/strong> —— 即使对端根本没收到你发出去的包。&lt;/li>
&lt;/ul>
&lt;p>因此，要穿透这些有状态防火墙，我们只需要&lt;strong>共享一些信息：让两端提前知道对方使用的 ip:port&lt;/strong>：&lt;/p>
&lt;ul>
&lt;li>手动静态配置是一种方式，但显然扩展性不好；&lt;/li>
&lt;li>我们开发了一个 coordination server[5]， 以灵活、安全的方式来同步 &lt;code>ip:port&lt;/code> 信息。&lt;/li>
&lt;/ul>
&lt;p>有了对方的 &lt;code>ip:port&lt;/code> 信息之后，两端开始给对方发送 UDP 包。在这个过程中，我们预 料到某些包将会被丢弃。因此，双方&lt;strong>必须要接受某些包会丢失的事实&lt;/strong>， 因此如果是重要信息，你必须自己准备好重传。对 UDP 来说丢包是可接受的，但这里尤其需要接受。&lt;/p>
&lt;p>来看一下具体建连（穿透）过程：&lt;/p>
&lt;ol>
&lt;li>如图所示，笔记本出去的第一包，&lt;code>2.2.2.2:1234 -&amp;gt; 7.7.7.7:5678&lt;/code>，穿过 Windows Defender 防火墙进入到公网。
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/1d06e237-bda9-4955-bc7d-9f1595c7ec8d/640" alt="">
对方的防火墙会将这个包拦截掉，因为它没有 &lt;code>7.7.7.7:5678 -&amp;gt; 2.2.2.2:1234&lt;/code> 的流量记录。但另一方面，Windows Defender 此时已经记录了出向连接，因此会允许 &lt;code>7.7.7.7:5678 -&amp;gt; 2.2.2.2:1234&lt;/code> 的应答包进来。&lt;/li>
&lt;li>接着，第一个 &lt;code>7.7.7.7:5678 -&amp;gt; 2.2.2.2:1234&lt;/code> 穿过它自己的防火墙到达公网。
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/1d06e237-bda9-4955-bc7d-9f1595c7ec8d/640" alt="">
到达客户端侧时，Windows Defender &lt;strong>认为这是刚才出向包的应答包，因此就放行它进入了！&lt;/strong> 此外，右侧的防火墙此时也记录了：&lt;code>2.2.2.2:1234 -&amp;gt; 7.7.7.7:5678&lt;/code> 的包应该放行。&lt;/li>
&lt;li>笔记本收到服务器发来的包之后，发送一个包作为应答。这个包穿过 Windows Defender 防火墙   和服务端防火墙（因为这是对服务端发送的包的应答包），达到服务端。
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/1d06e237-bda9-4955-bc7d-9f1595c7ec8d/640" alt="">&lt;/li>
&lt;/ol>
&lt;p>成功！这样我们就建立了一个&lt;strong>穿透两个相向防火墙&lt;/strong>的双向通信连接。而初看之下，这项任务似乎是不可能完成的。&lt;/p>
&lt;h3 id="23-关于穿透防火墙的一些思考">2.3 关于穿透防火墙的一些思考&lt;/h3>
&lt;p>穿透防火墙并非永远这么轻松，有时会受一些第三方系统的间接影响，需要仔细处理。那穿透防火墙需要注意什么呢？重要的一点是：&lt;strong>通信双方必须几乎同时发起通信&lt;/strong>， 这样才能在路径上的防火墙打开一条缝，而且两端还都是活着的。&lt;/p>
&lt;h4 id="231-双向主动建连旁路信道">2.3.1 双向主动建连：旁路信道&lt;/h4>
&lt;p>如何实现 “同时” 呢？一种方式是两端不断重试，但显然这种方式很浪费资源。假如双方都 知道何时开始建连就好了。&lt;/p>
&lt;ul>
&lt;li>这听上去是&lt;strong>鸡生蛋蛋生鸡的问题&lt;/strong>了：&lt;strong>双方想要通信，必须先提前通个信&lt;/strong>。&lt;/li>
&lt;li>但实际上，我们可以通过&lt;strong>旁路信道&lt;/strong>（side channel）来达到这个目的 ，并且这个旁路信道并不需要很 fancy：它可以有几秒钟的延迟、只需要传送几 KB 的 信息，因此即使是一个配置非常低的虚拟机，也能为几千台机器提供这样的旁路通信服务。&lt;/li>
&lt;li>在遥远的过去，我曾用  XMPP 聊天消息作为旁路，效果非常不错。&lt;/li>
&lt;li>另一个例子是 WebRTC，它需要你提供一个自己的 “信令信道”（signalling channel， 这个词也暗示了 WebRTC 的 IP telephony ancestry），并将其配置到 WebRTC API。&lt;/li>
&lt;li>在 Tailscale，我们的协调服务器（coordination server）和 DERP (Detour Encrypted Routing Protocol) 服务器集群是我们的旁路信道。&lt;/li>
&lt;/ul>
&lt;h4 id="232-非活跃连接被防火墙清理">2.3.2 非活跃连接被防火墙清理&lt;/h4>
&lt;p>有状态防火墙内存通常比较有限，因此会定期清理不活跃的连接（UDP 常见的是 30s）， 因此要保持连接 alive 的话需要定期通信，否则就会被防火墙关闭，为避免这个问题， 我们，&lt;/p>
&lt;ol>
&lt;li>要么定期向对方发包来 keepalive，&lt;/li>
&lt;li>要么有某种带外方式来按需重建连接。&lt;/li>
&lt;/ol>
&lt;h4 id="233-问题都解决了不挑战刚刚开始">2.3.3 问题都解决了？不，挑战刚刚开始&lt;/h4>
&lt;p>对于防火墙穿透来说， 我们&lt;strong>并不需要关心路径上有几堵墙&lt;/strong> —— 只要它们是有状态防火墙且允许出 向连接，这种同时发包（simultaneous transmission）机制就能穿透任意多层防火墙。这一点对我们来说非常友好，因为只需要实现一个逻辑，然后能适用于任何地方了。&lt;/p>
&lt;p>… 对吗？&lt;/p>
&lt;p>其实，&lt;strong>不完全对&lt;/strong>。这个机制有效的前提是：我们能&lt;strong>提前知道对方的 ip:port&lt;/strong>。而这就涉及到了我们今天的主题：NAT，它会使前面我们刚获得的一点满足感顿时消失。&lt;/p>
&lt;p>下面，&lt;strong>进入本文正题&lt;/strong>。&lt;/p>
&lt;h2 id="3-nat-的本质">3 NAT 的本质&lt;/h2>
&lt;h3 id="31-nat-设备与有状态防火墙">3.1 NAT 设备与有状态防火墙&lt;/h3>
&lt;p>可以认为 NAT 设备是一个&lt;strong>增强版的有状态防火墙&lt;/strong>，虽然它的增强功能 对于本文场景来说并不受欢迎：除了前面提到的有状态拦截 / 放行功能之外，它们还会在数据包经过时修改这些包。&lt;/p>
&lt;h3 id="32-nat-穿透与-snatdnat">3.2 NAT 穿透与 SNAT/DNAT&lt;/h3>
&lt;p>具体来说，NAT 设备能完成某种类型的网络地址转换，例如，替换源或目的 IP 地址或端口。&lt;/p>
&lt;ul>
&lt;li>&lt;strong>讨论连接问题和 NAT 穿透问题时&lt;/strong>，我们&lt;strong>只会受 source NAT —— SNAT 的影响&lt;/strong>。&lt;/li>
&lt;li>DNAT 不会影响 NAT 穿透。&lt;/li>
&lt;/ul>
&lt;h3 id="33-snat-的意义解决-ipv4-地址短缺问题">3.3 SNAT 的意义：解决 IPv4 地址短缺问题&lt;/h3>
&lt;p>SNAT 最常见的使用场景是&lt;strong>将很多设备连接到公网，而只使用少数几个公网 IP&lt;/strong>。例如对于消费级路由器，会将所有设备的（私有） IP 地址映射为&lt;strong>单个&lt;/strong>连接到公网的 IP 地址。&lt;/p>
&lt;p>这种方式存在的意义是：我们有远多于可用公网 IP 数量的设备需要连接到公网，（至少 对 IPv4 来说如此，IPv6 的情况后面会讨论）。NAT 使多个设备能共享同一 IP 地址，因 此即使面临 IPv4 地址短缺的问题，我们仍然能不断扩张互联网的规模。&lt;/p>
&lt;h3 id="34-snat-过程以家用路由器为例">3.4 SNAT 过程：以家用路由器为例&lt;/h3>
&lt;p>假设你的笔记本连接到家里的 WiFi，下面看一下它连接到公网某个服务器时的情形：&lt;/p>
&lt;ol>
&lt;li>笔记本发送 UDP packet &lt;code>192.168.0.20:1234 -&amp;gt; 7.7.7.7:5678&lt;/code>。
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/1d06e237-bda9-4955-bc7d-9f1595c7ec8d/640" alt="">
这一步就好像笔记本有一个公网 IP 一样，但源地址 &lt;code>192.168.0.20&lt;/code> 是私有地址， 只能出现在私有网络，公网不认，收到这样的包时它不知道如何应答。&lt;/li>
&lt;li>家用路由器出场，执行 SNAT。
包经过路由器时，路由器发现这是一个它没有见过的新会话（session）。它知道 &lt;code>192.168.0.20&lt;/code> 是私有 IP，公网无法给这样的地址回包，但它有办法解决：
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/1d06e237-bda9-4955-bc7d-9f1595c7ec8d/640" alt="">&lt;/li>
&lt;li>在它&lt;strong>自己的公网 IP 上挑一个可用的 UDP 端口&lt;/strong>，例如 &lt;code>2.2.2.2:4242&lt;/code>，&lt;/li>
&lt;li>然后创建一个 &lt;em>NAT mapping&lt;/em>：&lt;code>192.168.0.20:1234&lt;/code> &lt;code>&amp;lt;--&amp;gt;&lt;/code> &lt;code>2.2.2.2:4242&lt;/code>，&lt;/li>
&lt;li>然后将包发到公网，此时源地址变成了 &lt;code>2.2.2.2:4242&lt;/code> 而不是原来的 &lt;code>192.168.0.20:1234&lt;/code>。因此服务端看到的是转换之后地址，&lt;/li>
&lt;li>接下来，每个能匹配到这条映射规则的包，都会被路由器改写 IP 和 端口。&lt;/li>
&lt;li>反向路径是类似的，路由器会执行相反的地址转换，将 &lt;code>2.2.2.2:4242&lt;/code> 变回  &lt;code>192.168.0.20:1234&lt;/code>。对于笔记本来说，它根本感知不知道这正反两次变换过程。&lt;/li>
&lt;/ol>
&lt;p>这里是拿家用路由器作为例子，但&lt;strong>办公网的原理是一样的&lt;/strong>。不同之处在 于，办公网的 NAT 可能有多台设备组成（高可用、容量等目的），而且它们有不止一个公 网 IP 地址可用，因此在选择可用的公网 &lt;code>ip:port&lt;/code> 来做映射时，选择空间更大，能支持 更多客户端。&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/1d06e237-bda9-4955-bc7d-9f1595c7ec8d/640" alt="">&lt;/p>
&lt;h3 id="35-snat-给穿透带来的挑战">3.5 SNAT 给穿透带来的挑战&lt;/h3>
&lt;p>现在我们遇到了与前面有状态防火墙类似的情况，但这次是 NAT 设备：&lt;strong>通信双方 不知道对方的 ip:port 是什么&lt;/strong>，因此&lt;strong>无法主动建连&lt;/strong>，如下图所示：&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/1d06e237-bda9-4955-bc7d-9f1595c7ec8d/640" alt="">&lt;/p>
&lt;p>但这次比有状态防火墙更糟糕，严格来说，&lt;strong>在双方发包之前，根本无法确定（自己及对方的）ip:port 信息&lt;/strong>，因为 &lt;strong>只有出向包经过路由器之后才会产生 NAT mapping&lt;/strong>（即，可以被对方连接的 &lt;code>ip:port&lt;/code> 信息）。&lt;/p>
&lt;p>因此我们又回到了与防火墙遇到的问题，并且情况更糟糕：&lt;strong>双方都需要主动和对 方建连，但又不知道对方的公网地址是多少&lt;/strong>，只有当对方先说话之后，我们才能拿到它的地址信息。&lt;/p>
&lt;p>如何破解以上死锁呢？这就轮到 STUN[6] 登场了。&lt;/p>
&lt;h2 id="4-穿透-nat--防火墙stun-session-traversal-utilities-for-nat-协议">4 穿透 “NAT + 防火墙”：STUN (Session Traversal Utilities for NAT) 协议&lt;/h2>
&lt;p>STUN[7]   既是一些对 NAT 设备行为的详细研究，也是一种协助 NAT 穿透的协议。本文主要关注 STUN 协议。&lt;/p>
&lt;h3 id="41-stun-原理">4.1 STUN 原理&lt;/h3>
&lt;p>&lt;strong>STUN 基于一个简单的观察&lt;/strong>：从一个会被 NAT 的客户端访问公网服务器时， 服务器看到的是 &lt;strong>NAT 设备的公网 ip:port 地址&lt;/strong>，而非该 &lt;strong>客户端的局域网 ip:port 地址&lt;/strong>。&lt;/p>
&lt;p>也就是说，服务器能告诉客户端&lt;strong>它看到的客户端的 ip:port 是什么&lt;/strong>。因此，只要将这个信息以某种方式告诉通信对端（peer），后者就知道该和哪个地址建连了！这样就又&lt;strong>简化为前面的防火墙穿透问题了&lt;/strong>。&lt;/p>
&lt;p>本质上这就是 &lt;strong>STUN 协议的工作原理&lt;/strong>，如下图所示：&lt;/p>
&lt;ul>
&lt;li>笔记本向 STUN 服务器发送一个请求：“从你的角度看，我的地址什么？”&lt;/li>
&lt;li>STUN 服务器返回一个响应：“我看到你的 UDP 包是从这个地址来的：&lt;code>ip:port&lt;/code>”。&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/1d06e237-bda9-4955-bc7d-9f1595c7ec8d/640" alt="">&lt;/p>
&lt;blockquote>
&lt;p>The STUN protocol has a bunch more stuff in it — there’s a way of obfuscating the &lt;code>ip:port&lt;/code> in the response to stop really broken NATs from mangling the packet’s payload, and a whole authentication mechanism that only really gets used by TURN and ICE, sibling protocols to STUN that we’ll talk about in a bit. We can ignore all of that stuff for address discovery.&lt;/p>
&lt;/blockquote>
&lt;h3 id="42-为什么-nat-穿透逻辑和主协议要共享同一个-socket">4.2 为什么 NAT 穿透逻辑和主协议要共享同一个 socket&lt;/h3>
&lt;p>理解了 STUN 原理，也就能理解为什么我们在文章开头说，如果 &lt;strong>要实现自己的 NAT 穿透逻辑和主协议，就必须让二者共享同一个 socket&lt;/strong>：&lt;/p>
&lt;ol>
&lt;li>每个 socket 在 NAT 设备上都对应一个映射关系（私网地址 -&amp;gt; 公网地址），&lt;/li>
&lt;li>STUN 服务器只是&lt;strong>辅助&lt;/strong>穿透的基础设施，&lt;/li>
&lt;li>与 STUN 服务器通信之后，在 NAT 及防火墙设备上打开了一个连接，允许入向包进来（回忆前面内容，  &lt;strong>只要目的地址对，UDP 包就能进来&lt;/strong>，不管这些包是不是从 STUN 服务器来的），&lt;/li>
&lt;li>因此，接下来只要将这个地址告诉我们的通信对端（peer），让它往这个地址发包，就能实现穿透了。&lt;/li>
&lt;/ol>
&lt;h3 id="43-stun-的问题不能穿透所有-nat-设备例如企业级-nat-网关">4.3 STUN 的问题：不能穿透所有 NAT 设备（例如企业级 NAT 网关）&lt;/h3>
&lt;p>有了 STUN，我们的&lt;strong>穿透目的似乎已经实现了&lt;/strong>：每台机器都通过 STUN 来获取自己的私网 socket 对应的公网 &lt;code>ip:port&lt;/code>，然后把这个信息告诉对端，然后两端 同时发起穿透防火墙的尝试，后面的过程就和上一节介绍的防火墙穿透一样了，&lt;strong>对吗&lt;/strong>？&lt;/p>
&lt;p>答案是：&lt;strong>看情况&lt;/strong>。某些情况下确实如此，但有些情况下却不行。通常来说，&lt;/p>
&lt;ul>
&lt;li>对于大部分&lt;strong>家用路由器场景&lt;/strong>，这种方式是没问题的；&lt;/li>
&lt;li>但对于一些&lt;strong>企业级 NAT 网关&lt;/strong>来说，这种方式无法奏效。&lt;/li>
&lt;/ul>
&lt;p>NAT 设备的说明书上越强调它的安全性，STUN 方式失败的可能性就越高。（但注意，从实际意义上来说， &lt;strong>NAT 设备在任何方面都并不会增强网络的安全性&lt;/strong>，但这不是本文重点，因此不展开。）&lt;/p>
&lt;h3 id="44-重新审视-stun-的前提">4.4 重新审视 STUN 的前提&lt;/h3>
&lt;p>再次审视前面&lt;strong>关于 STUN 的假设&lt;/strong>：当 STUN 服务器告诉客户端在公网看来它的地址是 &lt;code>2.2.2.2:4242&lt;/code> 时，那所有目的地址是 &lt;code>2.2.2.2:4242&lt;/code> 的包就都能穿透防火墙到达该客户端。&lt;/p>
&lt;p>这也正是问题所在：&lt;strong>这一点并不总是成立&lt;/strong>。&lt;/p>
&lt;ul>
&lt;li>某些 NAT 设备的行为与我们假设的一致，它们的有状态防火墙组件只要看到有客户端自己 发起的出向包，就会允许相应的入向包进入；因此只要利用 STUN 功能，再加上两端同时 发起防火墙穿透，就能把连接打通；&lt;/li>
&lt;/ul>
&lt;blockquote>
&lt;p>in theory, there are also NAT devices that are super relaxed, and don’t ship with stateful firewall stuff at all. In those, you don’t even need simultaneous transmission, the STUN request gives you an internet &lt;code>ip:port&lt;/code> that anyone can connect to with no further ceremony. If such devices do still exist, they’re increasingly rare.&lt;/p>
&lt;/blockquote>
&lt;ul>
&lt;li>另外一些 NAT 设备就要困难很多了，它会&lt;strong>针对每个目的地址来生成一条相应的映射关系&lt;/strong>。在这样的设备上，如果我们用相同的 socket 来分别发送数据包到 &lt;code>5.5.5.5:1234&lt;/code> and &lt;code>7.7.7.7:2345&lt;/code>，我们就会得到 &lt;code>2.2.2.2&lt;/code> 上的两个不同的端口，每个目的地址对应一个。如果反向包的端口用的不对，包就无法通过防火墙。如下图所示：
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/1d06e237-bda9-4955-bc7d-9f1595c7ec8d/640" alt="">&lt;/li>
&lt;/ul>
&lt;h2 id="5-中场补课nat-正式术语">5 中场补课：NAT 正式术语&lt;/h2>
&lt;p>知道 NAT 设备的行为并不是完全一样之后，我们来引入一些正式术语。&lt;/p>
&lt;h3 id="51-早期术语">5.1 早期术语&lt;/h3>
&lt;p>如果之前接触过 NAT 穿透，可能会听说过下面这些名词：&lt;/p>
&lt;ul>
&lt;li>“Full Cone”&lt;/li>
&lt;li>“Restricted Cone”&lt;/li>
&lt;li>“Port-Restricted Cone”&lt;/li>
&lt;li>“Symmetric” NATs&lt;/li>
&lt;/ul>
&lt;p>这些都是 NAT 穿透领域的早期术语。&lt;/p>
&lt;p>但其实这些术语&lt;strong>相当让人困惑&lt;/strong>。我每次都要 查一下 Restricted Cone NAT 是什么意思。从实际经验来看，我并不是唯一对此感到困惑的人。例如，如今互联网上将 “easy” NAT 归类为 Full Cone，而实际上它们更应该归类为 Port-Restricted Cone。&lt;/p>
&lt;h3 id="52-近期研究与新术语">5.2 近期研究与新术语&lt;/h3>
&lt;p>最近的一些研究和 RFC 已经提出了一些更准确的术语。&lt;/p>
&lt;ul>
&lt;li>首先，它们明确了如下事实：&lt;strong>NAT 设备的行为差异表现在多个维度&lt;/strong>， 而并非只有早期研究中所说的 “cone” 这一个维度，因此&lt;strong>基于 “cone” 来划分类别并不是很有帮助&lt;/strong>。&lt;/li>
&lt;li>其次，新研究和新术语能&lt;strong>更准确地描述 NAT 在做什么&lt;/strong>。&lt;/li>
&lt;/ul>
&lt;p>前面提到的所谓 &lt;strong>&amp;ldquo;easy&amp;rdquo; 和 &amp;ldquo;hard&amp;rdquo; NAT，只在一个维度有不同&lt;/strong>：NAT 映射是否考虑到目的地址信息。RFC 4787[8] 中，&lt;/p>
&lt;ul>
&lt;li>将 &lt;strong>easy NAT 及其变种&lt;/strong>称为 “Endpoint-Independent Mapping” (&lt;strong>EIM，终点无关的映射&lt;/strong>)
但是，从**“命名很难”**这一程序员界的伟大传统来说，EIM 这个词其实   也并不是 100% 准确，因为这种 NAT 仍然依赖 endpoint，只不过依赖的是源 endpoint：每个 source  &lt;code>ip:port&lt;/code> 对应一个映射 —— 否则你的包就会和别人的包混在一起，导致混乱。
严格来说，EIM 应该称为 “Destination Endpoint Independent Mapping” (DEIM?)，   但这个名字太拗口了，而且按照惯例，Endpoint 永远指的是 Destination Endpoint。&lt;/li>
&lt;li>将 &lt;strong>hard NAT 以及变种&lt;/strong>称为 “Endpoint-Dependent Mapping”（&lt;strong>EDM，终点相关的映射&lt;/strong>） 。
EDM 中还有一个子类型，依据是只根据 dst_ip 做映射，还是根据 dst_ip + dst_port 做映射。对于 NAT 穿透来说，这种区分对来说是一样的：它们&lt;strong>都会导致 STUN 方式不可用&lt;/strong>。&lt;/li>
&lt;/ul>
&lt;h3 id="53-老的-cone-类型划分">5.3 老的 cone 类型划分&lt;/h3>
&lt;p>你可能会有疑问：根据是否依赖 endpoint 这一条件，只能组合出两种可能，那为什么传 统分类中会有四种 cone 类型呢？答案是 &lt;strong>cone 包含了两个正交维度的 NAT 行为&lt;/strong>：&lt;/p>
&lt;ul>
&lt;li>&lt;strong>NAT 映射行为&lt;/strong>：前面已经介绍过了，&lt;/li>
&lt;li>&lt;strong>有状态防火墙行为&lt;/strong>：与前者类似，也是分为与 endpoint 相关还是无关两种类型。&lt;/li>
&lt;/ul>
&lt;p>因此最终组合如下：&lt;/p>
&lt;p>NAT Cone Types&lt;/p>
&lt;p>|&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>&lt;strong>Endpoint 无关 NAT mapping&lt;/strong>&lt;/th>
&lt;th>&lt;strong>Endpoint 相关 NAT mapping (all types)&lt;/strong>&lt;/th>
&lt;th>&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>&lt;strong>Endpoint 无关防火墙&lt;/strong>&lt;/td>
&lt;td>Full Cone NAT&lt;/td>
&lt;td>N/A*&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;strong>Endpoint 相关防火墙 (dst. IP only)&lt;/strong>&lt;/td>
&lt;td>Restricted Cone NAT&lt;/td>
&lt;td>N/A*&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;strong>Endpoint 相关防火墙 (dst. IP+port)&lt;/strong>&lt;/td>
&lt;td>Port-Restricted Cone NAT&lt;/td>
&lt;td>Symmetric NAT&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>分解到这种程度之后就可以看出，&lt;strong>cone 类型对 NAT 穿透场景来说并没有什么意义&lt;/strong>。我们关心的只有一点：是否是 Symmetric —— 换句话说，一个 NAT 设备是 EIM 还是 EDM 类型的。&lt;/p>
&lt;h3 id="54-针对-nat-穿透场景简化-nat-分类">5.4 针对 NAT 穿透场景：简化 NAT 分类&lt;/h3>
&lt;p>以上讨论可知，虽然理解防火墙的具体行为很重要，但对于编写 NAT 穿透代码来说，这一点并不重要。我们的&lt;strong>两端同时发包&lt;/strong>方式（simultaneous transmission trick）能 &lt;strong>有效穿透以上三种类型的防火墙&lt;/strong>。在真实场景中， 我们主要在处理的是 IP-and-port endpoint-dependent 防火墙。&lt;/p>
&lt;p>因此，对于实际 NAT 穿透实现，我们可以将以上分类简化成：&lt;/p>
&lt;p>|&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>Endpoint-Independent NAT mapping&lt;/th>
&lt;th>Endpoint-Dependent NAT mapping (dst. IP only)&lt;/th>
&lt;th>&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>&lt;strong>Firewall is yes&lt;/strong>&lt;/td>
&lt;td>Easy NAT&lt;/td>
&lt;td>Hard NAT&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="55-更多-nat-规范rfc">5.5 更多 NAT 规范（RFC）&lt;/h3>
&lt;p>想了解更多新的 NAT 术语，可参考&lt;/p>
&lt;ul>
&lt;li>RFC 4787[9] (NAT Behavioral Requirements for UDP)&lt;/li>
&lt;li>RFC 5382[10] (for TCP)&lt;/li>
&lt;li>RFC 5508[11] (for ICMP)&lt;/li>
&lt;/ul>
&lt;p>如果自己实现 NAT，那应该（should）遵循这些 RFC 的规范，这样才能使你的 NAT 行为符合业界惯例，与其他厂商的设备或软件良好兼容。&lt;/p>
&lt;h2 id="6-穿透-nat--防火墙stun-不可用时fallback-到中继模式">6 穿透 NAT + 防火墙：STUN 不可用时，fallback 到中继模式&lt;/h2>
&lt;h3 id="61-问题回顾与保底方式中继">6.1 问题回顾与保底方式（中继）&lt;/h3>
&lt;p>补完基础知识（尤其是定义了什么是 hard NAT）之后，回到我们的 NAT 穿透主题。&lt;/p>
&lt;ul>
&lt;li>第 1~4 节已经解决了 STUN 和防火墙穿透的问题，&lt;/li>
&lt;li>但 &lt;strong>hard NAT 对我们来说是个大问题&lt;/strong>，只要路径上出现一个这种设备，前面的方案就行不通了。&lt;/li>
&lt;/ul>
&lt;p>准备放弃了吗？这才&lt;strong>进入 NAT 真正有挑战的部分&lt;/strong>：如果已经试过了前面介绍的所有方式 仍然不能穿透，我们该怎么办呢？&lt;/p>
&lt;ul>
&lt;li>实际上，确实有很多 NAT 实现在这种情况下都会选择放弃，向用户报一个**“无法连接”**之类的错误。&lt;/li>
&lt;li>但对我们来说，这么快就放弃显然是不可接受的 —— 解决不了连通性问题，Tailscale 就没有存在的意义。&lt;/li>
&lt;/ul>
&lt;p>我们的保底解决方式是：创建一个&lt;strong>中继连接&lt;/strong>（relay）实现双方的无障碍地通信。但是，中继方式性能不是很差吗？这要看具体情况：&lt;/p>
&lt;ul>
&lt;li>如果能直连，那显然没必要用中继方式；&lt;/li>
&lt;li>但如果无法直连，而中继路径又非常接近双方直连的真实路径，并且带宽足够大，那中 继方式并不会明显降低通信质量。延迟肯定会增加一点，带宽会占用一些，但 &lt;strong>相比完全连接不上，还是更能让用户接受的&lt;/strong>。&lt;/li>
&lt;/ul>
&lt;p>不过要注意：我们只有在无法直连时才会选择中继方式。实际场景中，&lt;/p>
&lt;ol>
&lt;li>对于大部分网络，我们都能通过前面介绍的方式实现直连，&lt;/li>
&lt;li>剩下的长尾用中继方式来解决，并不算一个很糟的方式。&lt;/li>
&lt;/ol>
&lt;p>此外，某些网络会阻止 NAT 穿透，其影响比这种 hard NAT 大多了。例如，我们观察到 UC Berkeley guest WiFi 禁止除 DNS 流量之外的所有 outbound UDP 流量。不管用什么 NAT 黑科技，都无法绕过这个拦截。因此我们终归还是需要一些可靠的 fallback 机制。&lt;/p>
&lt;h3 id="62-中继协议turnderp">6.2 中继协议：TURN、DERP&lt;/h3>
&lt;p>有多种中继实现方式。&lt;/p>
&lt;ol>
&lt;li>&lt;strong>TURN&lt;/strong> (Traversal Using Relays around NAT)：经典方式，核心理念是
Tailscale 并不使用 TURN。这种协议&lt;strong>用起来并不是很好&lt;/strong>，而且与 STUN 不同， 它没有真正的交互性，因为互联网上并没有公开的 TURN 服务器。&lt;/li>
&lt;li>&lt;strong>用户&lt;/strong>（人）先去公网上的 TURN 服务器认证，成功后后者会告诉你：“我已经为你分配了 ip:port，接下来将为你中继流量”，&lt;/li>
&lt;li>然后将这个 ip:port 地址告诉对方，让它去连接这个地址，接下去就是非常简单的客户端 / 服务器通信模型了。&lt;/li>
&lt;li>DERP (Detoured Encrypted Routing Protocol)
这是我们创建的一个协议，DERP[12]，
前面也简单提到过，DERP 既是我们在 NAT 穿透失败时的保底通信方式（此时的角色 与 TURN 类似），也是在其他一些场景下帮助我们完成 NAT 穿透的旁路信道。换句话说，它既是我们的保底方式，也是有更好的穿透链路时，帮助我们进行连接升 级（upgrade to a peer-to-peer connection）的基础设施。&lt;/li>
&lt;li>它是一个&lt;strong>通用目的包中继协议，运行在 HTTP 之上&lt;/strong>，而大部分网络都是允许 HTTP 通信的。&lt;/li>
&lt;li>它根据目的公钥（destination’s public key）来中继加密的流量（encrypted payloads）。&lt;/li>
&lt;/ol>
&lt;h3 id="63-小结">6.3 小结&lt;/h3>
&lt;p>有了 “中继” 这种保底方式之后，我们穿透的成功率大大增加了。如果此时不再阅读本文接下来的内容，而是把上面介绍的穿透方式都实现了，我预计：&lt;/p>
&lt;ul>
&lt;li>90% 的情况下，你都能实现直连穿透；&lt;/li>
&lt;li>剩下的 10% 里，用中继方式能穿透&lt;strong>一些&lt;/strong>（some）；&lt;/li>
&lt;/ul>
&lt;p>这已经算是一个 “足够好” 的穿透实现了。&lt;/p>
&lt;h2 id="7-穿透-nat--防火墙企业级改进">7 穿透 NAT + 防火墙：企业级改进&lt;/h2>
&lt;p>如果你并不满足于 “足够好”，那我们可以做的事情还有很多！&lt;/p>
&lt;p>本节将介绍一些五花八门的 tricks，在某些特殊场景下会帮到我们。单独使用这项技术都 无法解决 NAT 穿透问题，但将它们巧妙地组合起来，我们能更加接近 100% 的穿透成功率。&lt;/p>
&lt;h3 id="71-穿透-hard-nat暴力端口扫描">7.1 穿透 hard NAT：暴力端口扫描&lt;/h3>
&lt;p>回忆 hard NAT 中遇到的问题，如下图所示，关键问题是：easy NAT 不知道该往 hard NAT 方的哪个 &lt;code>ip:port&lt;/code> 发包。&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/1d06e237-bda9-4955-bc7d-9f1595c7ec8d/640" alt="">&lt;/p>
&lt;p>但&lt;strong>必须&lt;/strong>要往正确的 &lt;code>ip:port&lt;/code> 发包，才能穿透防火墙，实现双向互通。怎么办呢？&lt;/p>
&lt;ol>
&lt;li>首先，我们能知道 hard NAT 的&lt;strong>一些&lt;/strong> &lt;code>ip:port&lt;/code>，因为我们有 STUN 服务器。
这里先假设我们获得的这些 IP 地址都是正确的（这一点并不总是成立，但这里先这么假 设。而实际上，大部分情况下这一点都是成立的，如果对此有兴趣，可以参考 REQ-2 in RFC 4787[13]）。&lt;/li>
&lt;li>IP 地址确定了，剩下的就是端口了。总共有 65535 中可能，我们能&lt;strong>遍历这个端口范围&lt;/strong>吗？
如果发包速度是 100 packets/s，那最坏情况下，需要 &lt;strong>10 分钟&lt;/strong>来找到正确的端口。还是那句话，这虽然不是最优的，但总比连不上好。
这很像是端口扫描（事实上，确实是），实际中可能会触发对方的网络入侵检测软件。&lt;/li>
&lt;/ol>
&lt;h3 id="72-基于生日悖论改进暴力扫描hard-side-多开端口--easy-side-随机探测">7.2 基于生日悖论改进暴力扫描：hard side 多开端口 + easy side 随机探测&lt;/h3>
&lt;p>利用 birthday paradox[14] 算法， 我们能对端口扫描进行改进。&lt;/p>
&lt;ul>
&lt;li>上一节的基本前提是：hard side 只打开一个端口，然后 easy side 暴力扫描 65535 个端口来寻找这个端口；&lt;/li>
&lt;li>这里的改进是：在 hard size 开多个端口，例如 256 个（即同时打开 256 个 socket，目的地址都是 easy side 的 &lt;code>ip:port&lt;/code>）， 然后 easy side 随机探测这边的端口。&lt;/li>
&lt;/ul>
&lt;p>这里省去算法的数学模型，如果你对实现干兴趣，可以看看我写的  python calculator[15]。计算过程是 “经典” 生日悖论的一个小变种。下面是随着 easy side random probe 次数（假设 hard size 256 个端口）的变化，两边打开的端口有重合（即通信成功）的概率：&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>随机探测次数&lt;/th>
&lt;th>成功概率&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>174&lt;/td>
&lt;td>50%&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>256&lt;/td>
&lt;td>64%&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>1024&lt;/td>
&lt;td>98%&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>2048&lt;/td>
&lt;td>99.9%&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>根据以上结果，如果还是假设 100 ports/s 这样相当温和的探测速率，那 &lt;strong>2 秒钟就有约 50% 的成功概率&lt;/strong>。即使非常不走运，我们仍然能在 &lt;strong>20s 时几乎 100% 穿透成功&lt;/strong>，而此时&lt;strong>只探测了总端口空间的 4%&lt;/strong>。&lt;/p>
&lt;p>非常好！虽然这种 hard NAT 给我们带来了严重的穿透延迟，但最终结果仍然是成功的。那么，如果是两个 hard NAT，我们还能处理吗？&lt;/p>
&lt;h3 id="73-双-hard-nat-场景">7.3 双 hard NAT 场景&lt;/h3>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/1d06e237-bda9-4955-bc7d-9f1595c7ec8d/640" alt="">&lt;/p>
&lt;p>这种情况下仍然可以用前面的 &lt;strong>多端口 + 随机探测&lt;/strong> 方式，但成功概率要低很多了：&lt;/p>
&lt;ul>
&lt;li>每次通过一台 hard NAT 去探测对方的端口（目的端口）时，我们&lt;strong>自己同时也生成了一个随机源端口&lt;/strong>，&lt;/li>
&lt;li>这意味着我们的搜索空间变成了二维 &lt;code>{src port, dst port}&lt;/code> 对，而不再是之前的一维 dst port 空间。&lt;/li>
&lt;/ul>
&lt;p>这里我们也不就具体计算展开，只告诉结果：仍然&lt;strong>假设目的端打开 256 个端口，从源端发起 2048 次（20 秒）&lt;/strong>， 成功的概率是：&lt;strong>0.01%&lt;/strong>。&lt;/p>
&lt;p>如果你之前学过生日悖论，就并不会对这个结果感到惊讶。理论上来说，&lt;/p>
&lt;ul>
&lt;li>要达到 &lt;strong>99.9% 的成功率&lt;/strong>，我们需要两边各进行&lt;strong>170,000 次&lt;/strong>探测 —— 如果还是以 100 packets/sec 的速度，就需要 &lt;strong>28 分钟&lt;/strong>。&lt;/li>
&lt;li>要达到 &lt;strong>50% 的成功率&lt;/strong>，“只” 需要 54,000 packets，也就是 &lt;strong>9 分钟&lt;/strong>。&lt;/li>
&lt;li>如果不使用生日悖论方式，而且&lt;strong>暴力穷举，需要 1.2 年时间&lt;/strong>！&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>对于某些应用来说，28 分钟可能仍然是一个可接受的时间&lt;/strong>。用半个小时暴力穿透 NAT 之后， 这个连接就可以一直用着 —— 除非 NAT 设备重启，那样就需要再次花半个小时穿透建个新连接。但对于 交互式应用来说，这样显然是不可接受的。&lt;/p>
&lt;p>更糟糕的是，如果去看常见的办公网路由器，你会震惊于它的 active session low limit 有多么低。例如，一台 Juniper SRX 300 &lt;strong>最多支持 64,000 active sessions&lt;/strong>。也就是说，&lt;/p>
&lt;ul>
&lt;li>如果我们想创建&lt;strong>一个&lt;/strong>成功的穿透连接，&lt;strong>就会把它的整张 session 表打爆&lt;/strong> （因为我们要暴力探测 65535 个端口，每次探测都是一条新连接记录）！这显然要求这台路由器能&lt;strong>从容优雅地处理过载的情况&lt;/strong>。&lt;/li>
&lt;li>这只是创建一条连接带来的影响！如果 20 台机器同时对这台路由器发起穿透呢？&lt;strong>绝对的灾难！&lt;/strong>&lt;/li>
&lt;/ul>
&lt;p>至此，我们通过这种方式穿透了比之前更难一些的网络拓扑。这是一个很大的成就，因为 &lt;strong>家用路由器一般都是 easy NAT，hard NAT 一般都是办公网路由器或云 NAT 网关&lt;/strong>。这意味着这种方式能帮我们解决&lt;/p>
&lt;ul>
&lt;li>home-to-office（家 -&amp;gt; 办公室）&lt;/li>
&lt;li>home-to-cloud （家 -&amp;gt; 云）&lt;/li>
&lt;/ul>
&lt;p>的场景，以及一部分&lt;/p>
&lt;ul>
&lt;li>office-to-cloud （办公室 -&amp;gt; 云）&lt;/li>
&lt;li>cloud-to-cloud （云 -&amp;gt; 办公室）&lt;/li>
&lt;/ul>
&lt;p>场景。&lt;/p>
&lt;h3 id="74-控制端口映射port-mapping过程upnpnat-pmppcp-协议">7.4 控制端口映射（port mapping）过程：UPnP/NAT-PMP/PCP 协议&lt;/h3>
&lt;p>如果我们能&lt;strong>让 NAT 设备的行为简单点&lt;/strong>，不要把事情搞这么复杂，那建 立连接（穿透）就会简单很多。真有这样的好事吗？还真有，有专门的一种协议叫 &lt;strong>端口映射协议&lt;/strong>（port mapping protocols）。通过这种协议禁用掉前面 遇到的那些乱七八糟的东西之后，我们将得到一个非常简单的 “请求 - 响应”。&lt;/p>
&lt;p>下面是三个具体的端口映射协议：&lt;/p>
&lt;ol>
&lt;li>UPnP IGD[16] (Universal Plug’n’Play Internet Gateway Device)
最老的端口控制协议， 诞生于 1990s 晚期，因此使用了很多上世纪 90 年代的技术 （XML、SOAP、&lt;strong>multicast HTTP over UDP —— 对，HTTP over UDP&lt;/strong> ），而且很难准确和安全地实现这个协议。但以前很多路由器都内置了 UPnP 协议， 现在仍然很多。
请求和响应：&lt;/li>
&lt;/ol>
&lt;ul>
&lt;li>“你好，请将我的 &lt;code>lan-ip:port&lt;/code> 转发到公网（WAN）”，&lt;/li>
&lt;li>“好的，我已经为你分配了一个公网映射 &lt;code>wan-ip:port&lt;/code> ”。&lt;/li>
&lt;/ul>
&lt;ol start="3">
&lt;li>NAT-PMP
UPnP IGD 出来几年之后，Apple 推出了一个功能类似的协议，名为 NAT-PMP[17] (NAT Port Mapping Protocol)。
但与 UPnP 不同，这个协议&lt;strong>只&lt;/strong>做端口转发，不管是在客户端还是服务端，实现起来都非常简单。&lt;/li>
&lt;li>PCP
稍后一点，又出现了 NAT-PMP v2 版，并起了个新名字 PCP[18] (Port Control Protocol)。&lt;/li>
&lt;/ol>
&lt;p>因此要更好地实现穿透，可以&lt;/p>
&lt;ol>
&lt;li>&lt;strong>先判断本地的默认网关上是否启用了 UPnP IGD, NAT-PMP and PCP&lt;/strong>，&lt;/li>
&lt;li>如果探测发现其中任何一种协议有响应，我们就&lt;strong>申请一个公网端口映射&lt;/strong>，
可以将这理解为一个&lt;strong>加强版 STUN&lt;/strong>：我们不仅能发现自己的公网 &lt;code>ip:port&lt;/code>，而且能指示我们的 NAT 设备对我们的通信对端友好一些 —— 但并不是为这个端口修改或添加防火墙规则。&lt;/li>
&lt;li>接下来，任何到达我们 NAT 设备的、地址是我们申请的端口的包，都会被设备转发到我们。&lt;/li>
&lt;/ol>
&lt;p>但我们&lt;strong>不能假设这个协议一定可用&lt;/strong>：&lt;/p>
&lt;ol>
&lt;li>本地 NAT 设备可能不支持这个协议；&lt;/li>
&lt;li>设备支持但默认禁用了，或者没人知道还有这么个功能，因此从来没开过；&lt;/li>
&lt;li>安全策略要求关闭这个特性。
这一点非常常见，因为 UPnP 协议曾曝出一些高危漏洞（后面都修复了，因此如果是较新的设备，可以安全地使用 UPnP —— 如果实现没问题）。不幸的是，某些设备的配置中，UPnP, NAT-PMP，PCP 是放在一个开关里的（可能 统称为 “UPnP” 功能），一开全开，一关全关。因此如果有人担心 UPnP 的安全性，他连另 外两个也用不了。&lt;/li>
&lt;/ol>
&lt;p>最后，终归来说，&lt;strong>只要这种协议可用，就能有效地减少一次 NAT&lt;/strong>，大大方便建连过程。但接下来看一些不常见的场景。&lt;/p>
&lt;h3 id="75-多-nat-协商negotiating-numerous-nats">7.5 多 NAT 协商（Negotiating numerous NATs）&lt;/h3>
&lt;p>目前为止，我们看到的客户端和服务端都各只有一个 NAT 设备。如果有多个 NAT 设备会 怎么样？例如下面这种拓扑：&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/1d06e237-bda9-4955-bc7d-9f1595c7ec8d/640" alt="">&lt;/p>
&lt;p>这个例子比较简单，不会给穿透带来太大问题。包从客户端 A &lt;strong>经过多次 NAT&lt;/strong> 到达公网的过程，与前面分析的&lt;strong>穿过多层有状态防火墙&lt;/strong>是一样的：&lt;/p>
&lt;ul>
&lt;li>额外的这层（NAT 设备）&lt;strong>对客户端和服务端来说都不可见&lt;/strong>，我们的穿 透技术也不关心中间到底经过了多少层设备。&lt;/li>
&lt;li>&lt;strong>真正有影响的其实只是最后一层设备&lt;/strong>，因为对端需要在这一层设备上 找到入口让包进来。&lt;/li>
&lt;/ul>
&lt;p>具体来说，真正有影响的是端口转发协议。&lt;/p>
&lt;ol>
&lt;li>客户端使用这种协议分配端口时，为我们分配端口的是最靠近客户端的这层 NAT 设备；&lt;/li>
&lt;li>而我们期望的是让最离客户端最远的那层 NAT 来分配，否则我们得到的就是一个网络中间层分配的 &lt;code>ip:port&lt;/code>，对端是用不了的；&lt;/li>
&lt;li>不幸的是，&lt;strong>这几种协议都不能递归地&lt;/strong>告诉我们下一层 NAT 设备是多少 ——   虽然可以用 traceroute 之类的工具来探测网络路径，再加上   猜路上的设备是不是 NAT 设备（尝试发送 NAT 请求） —— 但这个就看运气了。&lt;/li>
&lt;/ol>
&lt;p>这就是为什么互联网上充斥着大量的文章说 &lt;strong>double-NAT 有多糟糕&lt;/strong>，以 及警告用户为保持后向兼容不要使用 double-NAT。但实际上，double-NAT &lt;strong>对于绝大部分 互联网应用来说都是不可见的（透明的）&lt;/strong>，因为大部分应用并不需要主动地做这种 NAT 穿 透。&lt;/p>
&lt;p>但我也绝不是在建议你在自己的网络中设置 double-NAT。&lt;/p>
&lt;ol>
&lt;li>破坏了端口映射协议之后，某些视频游戏的多人（multiplayer）模式就会无法使用，&lt;/li>
&lt;li>也可能会使你的 IPv6 网络无法派上用场，后者是不用 NAT 就能双向直连的一个好方案。&lt;/li>
&lt;/ol>
&lt;p>但如果 double-NAT 并不是你能控制的，那除了不能用到这种端口映射协议之外，其他大部分东西都是不受影响的。&lt;/p>
&lt;p>double-NAT 的故事到这里就结束了吗？—— 并没有，而且更大型的 double-NAT 场景将展现在我们面前。&lt;/p>
&lt;h3 id="76-运营商级-nat-带来的问题">7.6 运营商级 NAT 带来的问题&lt;/h3>
&lt;p>即使用 NAT 来解决 IPv4 地址不够的问题，地址仍然是不够用的，ISP（互联网服务提供商） 显然 无法为每个家庭都分配一个公网 IP 地址。那怎么解决这个问题呢？ISP 的做法是&lt;strong>不够了就再嵌套一层 NAT&lt;/strong>：&lt;/p>
&lt;ol>
&lt;li>家用路由器将你的客户端 SNAT 到一个 “intermediate” IP 然后发送到运营商网络，&lt;/li>
&lt;li>ISP’s network 中的 NAT 设备再将这些 intermediate IPs 映射到少量的公网 IP。&lt;/li>
&lt;/ol>
&lt;p>后面这种 NAT 就称为 “运营商级 NAT”（&lt;strong>carrier-grade NAT&lt;/strong>，或称电信级 NAT），缩写 CGNAT。如下图所示：&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/1d06e237-bda9-4955-bc7d-9f1595c7ec8d/640" alt="">&lt;/p>
&lt;p>CGNAT 对 NAT 穿透来说是一个大麻烦。&lt;/p>
&lt;ul>
&lt;li>在此之前，办公网用户要快速实现 NAT 穿透，只需在他们的路由器上手动设置端口映射就行了。&lt;/li>
&lt;li>但有了 CGNAT 之后就不管用了，因为你无法控制运营商的 CGNAT！&lt;/li>
&lt;/ul>
&lt;p>好消息是：这其实是 double-NAT 的一个小变种，因此前面介绍的解决方式大部分还仍然是适用的。某些东西可能会无法按预期工作，但只要肯给 ISP 交钱，这些也都能解决。除了 port mapping protocols，其他我们已经介绍的所有东西在 CGNAT 里都是适用的。&lt;/p>
&lt;h4 id="新挑战同一-cgnat-侧直连stun-不可用">新挑战：同一 CGNAT 侧直连，STUN 不可用&lt;/h4>
&lt;p>但我们确实遇到了一个新挑战：如何直连两个在同一 CGNAT 但不同家用路由器中的对端呢？如下图所示：&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/1d06e237-bda9-4955-bc7d-9f1595c7ec8d/640" alt="">&lt;/p>
&lt;p>&lt;strong>在这种情况下，STUN 就无法正常工作了&lt;/strong>：STUN 看到的是客户端在公网（CGNAT 后面）看到的地址， 而我们想获得的是在 “middle network” 中的 &lt;code>ip:port&lt;/code>，这才是对端真正需要的地址，&lt;/p>
&lt;h4 id="解决方案如果端口映射协议能用一端做端口映射">解决方案：如果端口映射协议能用：一端做端口映射&lt;/h4>
&lt;p>怎么办呢？&lt;/p>
&lt;p>如果你想到了端口映射协议，那恭喜，答对了！&lt;strong>如果 peer 中任何一个 NAT 支持端口映射协议&lt;/strong>， 对我们就能实现穿透，因为它分配的 &lt;code>ip:port&lt;/code> 正是对端所需要的信息。&lt;/p>
&lt;p>这里讽刺的是：double-NAT（指 CGNAT）破坏了端口映射协议，但在这里又救了我们！当然，我们假设这些协议一定可用，因为 CGNAT ISP 倾向于在它们的家用路由器侧关闭 这些功能，已避免软件得到 “错误的” 结果，产生混淆。&lt;/p>
&lt;h4 id="解决方案如果端口映射协议不能用nat-hairpin-模式">解决方案：如果端口映射协议不能用：NAT hairpin 模式&lt;/h4>
&lt;p>如果不走运，NAT 上没有端口映射功能怎么办？&lt;/p>
&lt;p>让我们回到基于 STUN 的技术，看会发生什么。两端在 CGNAT 的同一侧，假设 STUN 告诉我们 A 的地址是 &lt;code>2.2.2.2:1234&lt;/code>，B 的地址是 &lt;code>2.2.2.2:5678&lt;/code>。&lt;/p>
&lt;p>那么接下来的问题是：如果 A 向 &lt;code>2.2.2.2:5678&lt;/code> 发包会怎么样？期望的 CGNAT 行为是：&lt;/p>
&lt;ol>
&lt;li>执行 A 的 NAT 映射规则，即对 &lt;code>2.2.2.2:1234 -&amp;gt; 2.2.2.2:5678&lt;/code> 进行 SNAT。&lt;/li>
&lt;li>注意到目的地址 &lt;code>2.2.2.2:5678&lt;/code> 匹配到的是 B 的入向 NAT 映射，因此接着对这个包执行 DNAT，将目的 IP 改成 B 的私有地址。&lt;/li>
&lt;li>通过  CGNAT 的 internal 接口（而不是 public 接口，对应公网）将包发给 B。&lt;/li>
&lt;/ol>
&lt;p>这种 NAT 行为有个专门的术语，叫 &lt;strong>hairpinning&lt;/strong>（直译为发卡，意思 是像发卡一样，沿着一边上去，然后从另一边绕回来），&lt;/p>
&lt;p>大家应该猜到的一个事实是：&lt;strong>不是所以 NAT 都支持 hairpin 模式&lt;/strong>。实际上，大量 well-behaved NAT 设备都不支持 hairpin 模式，&lt;/p>
&lt;ul>
&lt;li>因为它们都有 &lt;strong>“只有 src_ip 是私有地址且 dst_ip 是公网地址的包才会经过我”&lt;/strong> 之类的假设。&lt;/li>
&lt;li>因此对于这种目的地址不是公网、需要让路由器把包再转回内网的包，它们会&lt;strong>直接丢弃&lt;/strong>。&lt;/li>
&lt;li>这些逻辑甚至是直接实现在路由芯片中的，因此除非升级硬件，否则单靠软件编程无法改变这种行为。&lt;/li>
&lt;/ul>
&lt;p>Hairpin 是所有 NAT 设备的特性（支持或不支持），并不是 CGNAT 独有的。&lt;/p>
&lt;ol>
&lt;li>在大部分情况下，这个特性对我们的 NAT 穿透目的来说都是无所谓的，因为我们期望中  &lt;strong>两个 LAN NAT 设备会直接通信，不会再向上绕到它们的默认网关 CGNAT 来解决这个问题&lt;/strong>。
Hairpin 特性可有可无这件事有点遗憾，这可能也是为什么 hairpin 功能经常 broken 的原因。&lt;/li>
&lt;li>一旦必须涉及到 CGNAT，那 hairpinning 对连接性来说就至关重要了。
Hairpinning 使内网连接的行为与公网连接的行为完成一致，因此我们无需关心目的 地址类型，也不用知晓自己是否在一台 CGNAT 后面。&lt;/li>
&lt;/ol>
&lt;p>&lt;strong>如果 hairpinning 和 port mapping protocols 都不可用，那只能降级到中继模式了&lt;/strong>。&lt;/p>
&lt;h3 id="77-全-ipv6-网络理想之地但并非问题全无">7.7 全 IPv6 网络：理想之地，但并非问题全无&lt;/h3>
&lt;p>行文至此，一些读者可能已经对着屏幕咆哮：&lt;strong>不要再用 IPv4 了！&lt;/strong> 花这么多时间精力解决这些没意义的东西，还不如直接换成 IPv6！&lt;/p>
&lt;ul>
&lt;li>的确，之所以有这些乱七八糟的东西，就是因为 IPv4 地址不够了，我们&lt;strong>一直在用越来越复杂的 NAT 来给 IPv4 续命&lt;/strong>。&lt;/li>
&lt;li>如果 IP 地址够用，无需 NAT 就能让世界上的每个设备都有一个自己的公网 IP 地址，这些问题不就解决了吗？&lt;/li>
&lt;/ul>
&lt;p>简单来说，是的，这也正是 IPv6 能做的事情。但是，也只说对了一半：在理想的全 IPv6 世界中，所有这些东西会变得更加简单，但我们面临的&lt;strong>问题并不会完全消失&lt;/strong> —— 因为&lt;strong>有状态防火墙仍然还是存在的&lt;/strong>。&lt;/p>
&lt;ul>
&lt;li>办公室中的电脑可能有一个公网 IPv6 地址，但你们公司肯定会架设一个防火墙，只允许 你的电脑主动访问公网，而不允许反向主动建连。&lt;/li>
&lt;li>其他设备上的防火墙也仍然存在，应用类似的规则。&lt;/li>
&lt;/ul>
&lt;p>因此，我们仍然会用到&lt;/p>
&lt;ol>
&lt;li>本文最开始介绍的防火墙穿透技术，以及&lt;/li>
&lt;li>帮助我们获取自己的公网 &lt;code>ip:port&lt;/code> 信息的旁路信道&lt;/li>
&lt;li>仍然需要在某些场景下 fallback 到中继模式，例如 fallback 到最通用的 HTTP 中继 协议，以绕过某些网络禁止 outbound UDP 的问题。&lt;/li>
&lt;/ol>
&lt;p>但我们现在可以抛弃 &lt;strong>STUN、生日悖论、端口映射协议、hairpin&lt;/strong> 等等东西了。这是一个好消息！&lt;/p>
&lt;h4 id="全球-ipv4ipv6-部署现状">全球 IPv4/IPv6 部署现状&lt;/h4>
&lt;p>另一个更加严峻的现实问题是：当前并不是一个全 IPv6 世界。目前世界上&lt;/p>
&lt;ul>
&lt;li>大部分还是 IPv4，&lt;/li>
&lt;li>大约 33% 是 IPv6[19]，而且分布极度不均匀，因此某些 通信对所在的可能是 100% IPv6，也可能是 0%，或二者之间。&lt;/li>
&lt;/ul>
&lt;p>不幸的是，这意味着，IPv6 &lt;strong>还&lt;/strong>无法作为我们的解决方案。就目前来说，它只是我们的工具箱中的一个备选。对于某些 peer 来说，它简直是完美工 具，但对其他 peer 来说，它是用不了的。如果目标是 “任何情况下都能穿透（连接） 成功”，那我们就仍然需要 IPv4+NAT 那些东西。&lt;/p>
&lt;h4 id="新场景nat64dns64">新场景：NAT64/DNS64&lt;/h4>
&lt;p>IPv4/IPv6 共存也引出了一个新的场景：NAT64 设备。&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/1d06e237-bda9-4955-bc7d-9f1595c7ec8d/640" alt="">&lt;/p>
&lt;p>前面介绍的都是 NAT44 设备：它们将一个 IPv4 地址转换成另一 IPv4 地址。NAT64 从名字可以看出，是将一个内侧 IPv6 地址转换成一个外侧 IPv4 地址。利用 DNS64 设备，我们能将 IPv4 DNS 应答给 IPv6 网络，这样对终端来说，它看到的就是一个 全 IPv6 网络，而仍然能访问 IPv4 公网。&lt;/p>
&lt;blockquote>
&lt;p>Incidentally, you can extend this naming scheme indefinitely. There have been some experiments with NAT46; you could deploy NAT66 if you enjoy chaos; and some RFCs use NAT444 for carrier-grade NAT.&lt;/p>
&lt;/blockquote>
&lt;p>如果需要处理 DNS 问题，那这种方式工作良好。例如，如果连接到 google.com，将这个域名解析成 IP 地址的过程会涉及到 DNS64 设备，它又会进一步 involve NAT64 设备，但后一步对用户来说是无感知的。&lt;/p>
&lt;p>但&lt;strong>对于 NAT 和防火墙穿透来说，我们会关心每个具体的 IP 地址和端口&lt;/strong>。&lt;/p>
&lt;h4 id="解决方案clat-customer-side-translator">解决方案：CLAT (Customer-side transLATor)&lt;/h4>
&lt;p>如果设备支持 CLAT (Customer-side translator — from Customer XLAT)，那我们就很幸运：&lt;/p>
&lt;ul>
&lt;li>&lt;strong>CLAT 假装操作系统有直接 IPv4 连接，而背后使用的是 NAT64&lt;/strong>，以对应用程序无感知。在有 CLAT 的设备上，我们无需做任何特殊的事情。&lt;/li>
&lt;li>CLAT &lt;strong>在移动设备上非常常见&lt;/strong>，但在桌面电脑、笔记本和服务器上非常少见， 因此在后者上，必须自己做 CLAT 做的事情：检测 NAT64+DNS64 的存在，然后正确地使用它们。&lt;/li>
&lt;/ul>
&lt;h4 id="解决方案clat-不存在时手动穿透-nat64-设备">解决方案：CLAT 不存在时，手动穿透 NAT64 设备&lt;/h4>
&lt;ol>
&lt;li>首先检测是否存在 NAT64+DNS64。
方法很简单：向 &lt;code>ipv4only.arpa.&lt;/code> 发送一个 DNS 请求。这个域名会解析 到一个已知的、固定的 IPv4 地址，而且是&lt;strong>纯 IPv4 地址&lt;/strong>。如果得到的 是一个 IPv6 地址，就可以判断有 DNS64 服务器做了转换，而它必然会用到 NAT64。这样 就能判断出 NAT64 的前缀是多少。&lt;/li>
&lt;li>此后，要向 IPv4 地址发包时，发送格式为&lt;code>{NAT64 prefix + IPv4 address}&lt;/code> 的 IPv6 包。类似地，收到来源格式为 &lt;code>{NAT64 prefix + IPv4 address}&lt;/code> 的包时，就是 IPv4 流量。&lt;/li>
&lt;li>接下来，通过 NAT64 网络与 STUN 通信来获取自己在 NAT64 上的公网 &lt;code>ip:port&lt;/code>，接 下来就回到经典的 NAT 穿透问题了 —— 除了需要多做一点点事情。&lt;/li>
&lt;/ol>
&lt;p>幸运的是，如今的大部分 v6-only 网络都是移动运营商网络，而几乎所有手机都支持 CLAT。运营 v6-only 网络的 ISPs 会在他们给你的路由器上部署 CLAT，因此最后你其实不需要做什么事情。但如果想实现 100% 穿透，就需要解决这种边边角角的问题，即必须显式支持从 v6-only 网络连接 v4-only 对端。&lt;/p>
&lt;h3 id="78-将所有解决方式集成到-ice-协议">7.8 将所有解决方式集成到 ICE 协议&lt;/h3>
&lt;h4 id="针对具体场景该选择哪种穿透方式">针对具体场景，该选择哪种穿透方式？&lt;/h4>
&lt;p>至此，我们的 NAT 穿透之旅终于快结束了。我们已经覆盖了有状态防火墙、简单和高级 NAT、IPv4 和 IPv6。只要将以上解决方式都实现了，NAT 穿透的目的就达到了！&lt;/p>
&lt;p>但是，&lt;/p>
&lt;ul>
&lt;li>对于给定的 peer，如何判断改用哪种方式呢？&lt;/li>
&lt;li>如何判断这是一个简单有状态防火墙的场景，还是该用到生日悖论算法，还是需要手动处理 NAT64 呢？&lt;/li>
&lt;li>还是通信双方在一个 WiFi 网络下，连防火墙都没有，因此不需要任何操作呢？&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>早期 NAT 穿透&lt;/strong>比较简单，能让我们&lt;strong>精确判断出 peer 之间的路径特点&lt;/strong>，然后针对性地采用相应的解决方式。但后面，网络工程师和 NAT 设备开发工程师引入了一些新理念，给路径判断造成很大困难。因此 我们需要简化客户端侧的思考（判断逻辑）。&lt;/p>
&lt;p>这就要提到 Interactive Connectivity Establishment (ICE，交换式连接建立) 协议了。与 STUN/TURN 类似，ICE 来自&lt;strong>电信领域&lt;/strong>，因此其 RFC 充满了 SIP、SDP、信令会话、拨号等等电话术语。但如果忽略这些领域术语，我们会看到它&lt;strong>描述了一个极其优雅的判断最佳连接路径的算法&lt;/strong>。&lt;/p>
&lt;p>真的？这个算法是：&lt;strong>每种方法都试一遍，然后选择最佳的那个方法&lt;/strong>。就是这个算法，惊喜吗？&lt;/p>
&lt;p>来更深入地看一下这个算法。&lt;/p>
&lt;h4 id="ice-interactive-connectivity-establishment-算法">ICE (Interactive Connectivity Establishment) 算法&lt;/h4>
&lt;p>这里的讨论不会严格遵循 ICE spec，因此如果是在自己实现一个可互操作的 ICE 客户端，应该通读 RFC 8445[20], 根据它的描述来实现。这里忽略所有电信术语，只关注核心的算法逻辑， 并提供几个在 ICE 规范允许范围的灵活建议。&lt;/p>
&lt;ol>
&lt;li>为实现和某个 peer 的通信，首先需要确定我们自己用的（客户端侧）这个 socket 的地址，   这是一个列表，至少应该包括：&lt;/li>
&lt;li>我们自己的 IPv6 &lt;code>ip:ports&lt;/code>&lt;/li>
&lt;li>我们自己的 IPv4 LAN &lt;code>ip:ports&lt;/code>（局域网地址）&lt;/li>
&lt;li>通过 STUN 服务器获取到的我们自己的 IPv4 WAN &lt;code>ip:ports&lt;/code>（&lt;strong>公网地址&lt;/strong>，可能会经过 NAT64 转换）&lt;/li>
&lt;li>通过端口映射协议获取到的我们自己的 IPv4 WAN &lt;code>ip:port&lt;/code>（NAT 设备的&lt;strong>端口映射协议分配的公网地址&lt;/strong>）&lt;/li>
&lt;li>运营商提供给我们的 endpoints（例如，&lt;strong>静态配置的端口转发&lt;/strong>）&lt;/li>
&lt;li>通过旁路信道与 peer 互换这个列表。两边都拿到对方的列表后，就开始互相探测对方提供的地址。 &lt;strong>列表中地址没有优先级&lt;/strong>，也就是说，如果对方给的了 15 个地址，那我们应该把这 15 个地址都探测一遍。
这些&lt;strong>探测包有两个目的&lt;/strong>：&lt;/li>
&lt;li>&lt;strong>打开防火墙，穿透 NAT&lt;/strong>，也就是本文一直在介绍的内容；&lt;/li>
&lt;li>&lt;strong>健康检测&lt;/strong>。我们在不断交换（最好是已认证的）“ping/pong” 包，来检测某个特定的路径是不是端到端通的。&lt;/li>
&lt;li>最后，一小会儿之后，从可用的备选地址中（根据某些条件）选择 “最佳” 的那个，任务完成！&lt;/li>
&lt;/ol>
&lt;p>这个算法的优美之处在于：只要选择最佳线路（地址）的算法是正确的，那就总能获得最佳路径。&lt;/p>
&lt;ul>
&lt;li>ICE 会预先对这些备选地址进行排序（通常：LAN &amp;gt; WAN &amp;gt; WAN+NAT），但用户也可以自己指定这个排序行为。&lt;/li>
&lt;li>从 v0.100.0 开始，Tailscale 从原来的 hardcode 优先级切换成了根据 round-trip latency 的方式，它大部分情况下排序的结果和 &lt;code>LAN &amp;gt; WAN &amp;gt; WAN+NAT&lt;/code> 是一致的。但相比于静态排序，我们是动态计算每条路径应该属于哪个类别。&lt;/li>
&lt;/ul>
&lt;p>ICE spec 将协议组织为两个阶段：&lt;/p>
&lt;ol>
&lt;li>探测阶段&lt;/li>
&lt;li>通信阶段&lt;/li>
&lt;/ol>
&lt;p>但不一定要严格遵循这两个步骤的顺序。在 Tailscale，&lt;/p>
&lt;ul>
&lt;li>我们发现更优的路径之后就会自动切换过去，&lt;/li>
&lt;li>所有的连接都是先选择 DERP 模式（中继模式）。这意味着连接立即就能建立（&lt;strong>优先级最低但 100% 能成功的模式&lt;/strong>），用户不用任何等待，&lt;/li>
&lt;li>然后并行进行路径发现。通常几秒钟之后，我们就能发现一条更优路径，然后将现有连接透明升级（upgrade）过去。&lt;/li>
&lt;/ul>
&lt;p>但有一点需要关心：非对称路径。ICE 花了一些精力来保证通信双方选择的是相同的网络 路径，这样才能保证这条路径上有双向流量，能保持防火墙和 NAT 设备的连接一直处于 open 状态。自己实现的话，其实并不需要花同样大的精力来实现这个保证，但需要确保你所有使用的所有路径上，都有双向流量。这个目标就很简单了，只需要定期在所有已使用的路径上发 ping/pong 就行了。&lt;/p>
&lt;h4 id="健壮性与降级">健壮性与降级&lt;/h4>
&lt;p>要实现健壮性，还需要检测当前已选择的路径是否已经失败了（例如，NAT 设备维护清掉了所有状态）， 如果失败了就要&lt;strong>降级（downgrade）到其他路径&lt;/strong>。这里有两种方式：&lt;/p>
&lt;ol>
&lt;li>持续探测所有路径，维护一个降级时会用的备用地址列表；&lt;/li>
&lt;li>&lt;strong>直接降级到保底的中继模式&lt;/strong>，然后再通过路径探测升级到更好的路径。
考虑到发生降级的概率是非常小的，因此这种方式可能是&lt;strong>更经济&lt;/strong>的。&lt;/li>
&lt;/ol>
&lt;h3 id="79-安全">7.9 安全&lt;/h3>
&lt;p>最后需要提到安全。&lt;/p>
&lt;p>本文的所有内容都假设：我们使用的&lt;strong>上层协议已经有了自己的安全机制&lt;/strong>（ 例如 QUIC 协议有 TLS 证书，WireGuard 协议有自己的公钥）。如果还没有安全机制，那显然是要立即补上的。一旦动态切换路径，&lt;strong>基于 IP 的安全机制就是无用的了&lt;/strong> （IP 协议最开始就没怎么考虑安全性），至少要有&lt;strong>端到端的认证&lt;/strong>。&lt;/p>
&lt;ul>
&lt;li>严格来说，如果上层协议有安全机制，那即使收到是欺骗性的 ping/pong 流量，问题都不大， 最坏的情况也就是&lt;strong>攻击者诱导两端通过他们的系统来中继流量&lt;/strong>。而有了端到端安全机制，这并不是一个大问题（取决于你的威胁模型）。&lt;/li>
&lt;li>但出于谨慎考虑，最好还是对路径发现的包也做认证和加密。具体如何做可以咨询你们的应用安全工程师。&lt;/li>
&lt;/ul>
&lt;h2 id="8-结束语">8 结束语&lt;/h2>
&lt;p>我们终于完成了 NAT 穿透的目标！&lt;/p>
&lt;p>如果实现了以上提到的所有技术，你将得到一个业内领先的 NAT 穿透软件，能在绝大多数场景下实现端到端直连。如果直连不了，还可以降级到保底的中继模式（对于长尾来说只能靠中继了）。&lt;/p>
&lt;p>但这些工作相当复杂！其中一些问题研究起来很有意思，但很难做到完全正确，尤其是那些 非常边边角角的场景，真正出现的概率极小，但解决它们所需花费的经历又极大。不过，这种工作只需要做一次，一旦解决了，你就具备了某种超级能力：探索令人激动的、相对还比较崭新的&lt;strong>端到端应用&lt;/strong>（peer-to-peer applications）世界。&lt;/p>
&lt;h3 id="81-跨公网-端到端直连">8.1 跨公网 端到端直连&lt;/h3>
&lt;p>&lt;strong>去中心化软件&lt;/strong>领域中的许多有趣想法，简化之后其实都变成了 &lt;strong>跨过公网（互联网）实现端到端直连&lt;/strong> 这一问题，开始时可能觉得很简单，但真正做才 发现比想象中难多了。现在知道如何解决这个问题了，动手开做吧！&lt;/p>
&lt;h3 id="82-结束语之-tl-dr">8.2 结束语之 TL; DR&lt;/h3>
&lt;p>实现健壮的 NAT 穿透需要下列基础：&lt;/p>
&lt;ol>
&lt;li>一种基于 UDP 的协议；&lt;/li>
&lt;li>能在程序内直接访问 socket；&lt;/li>
&lt;li>有一个与 peer 通信的旁路信道；&lt;/li>
&lt;li>若干 STUN 服务器；&lt;/li>
&lt;li>一个保底用的中继网络（可选，但强烈推荐）&lt;/li>
&lt;/ol>
&lt;p>然后需要：&lt;/p>
&lt;ol>
&lt;li>遍历所有的 &lt;code>ip:port&lt;/code>；&lt;/li>
&lt;li>查询 STUN 服务器来获取自己的公网 &lt;code>ip:port&lt;/code> 信息，以及判断自己这一侧的 NAT 的 “难度”（difficulty）；&lt;/li>
&lt;li>使用 port mapping 协议来获取更多的公网 &lt;code>ip:ports&lt;/code>；&lt;/li>
&lt;li>检查 NAT64，通过它获取自己的公网 &lt;code>ip:port&lt;/code>；&lt;/li>
&lt;li>将自己的所有公网 &lt;code>ip:ports&lt;/code> 信息通过旁路信道与 peer 交换，以及某些加密秘钥来保证通信安全；&lt;/li>
&lt;li>通过保底的中继方式与对方开始通信（可选，这样连接能快速建立）&lt;/li>
&lt;li>如果有必要 / 想这么做，探测对方的提供的所有 &lt;code>ip:port&lt;/code>，以及执行生日攻击（birthday attacks）来穿透 harder NAT；&lt;/li>
&lt;li>发现更优路径之后，透明升级到该路径；&lt;/li>
&lt;li>如果当前路径断了，降级到其他可用的路径；&lt;/li>
&lt;li>确保所有东西都是加密的，并且有端到端认证。&lt;/li>
&lt;/ol>
&lt;h3 id="引用链接">引用链接&lt;/h3>
&lt;p>[1]&lt;/p>
&lt;p>How NAT traversal works: &lt;a href="https://tailscale.com/blog/how-nat-traversal-works/">&lt;em>https://tailscale.com/blog/how-nat-traversal-works/&lt;/em>&lt;/a>&lt;/p>
&lt;p>[2]&lt;/p>
&lt;p>How Tailscale Works: &lt;a href="https://tailscale.com/blog/how-tailscale-works/">&lt;em>https://tailscale.com/blog/how-tailscale-works/&lt;/em>&lt;/a>&lt;/p>
&lt;p>[3]&lt;/p>
&lt;p>(译) NAT - 网络地址转换（2016）: &lt;a href="https://arthurchiao.art/blog/nat-zh/">&lt;em>https://arthurchiao.art/blog/nat-zh/&lt;/em>&lt;/a>&lt;/p>
&lt;p>[4]&lt;/p>
&lt;p>WebRTC: &lt;a href="https://webrtc.org/">&lt;em>https://webrtc.org/&lt;/em>&lt;/a>&lt;/p>
&lt;p>[5]&lt;/p>
&lt;p>coordination server: &lt;a href="https://tailscale.com/blog/how-tailscale-works/#the-control-plane-key-exchange-and-coordination">&lt;em>https://tailscale.com/blog/how-tailscale-works/#the-control-plane-key-exchange-and-coordination&lt;/em>&lt;/a>&lt;/p>
&lt;p>[6]&lt;/p>
&lt;p>STUN: &lt;a href="https://en.wikipedia.org/wiki/STUN">&lt;em>https://en.wikipedia.org/wiki/STUN&lt;/em>&lt;/a>&lt;/p>
&lt;p>[7]&lt;/p>
&lt;p>STUN: &lt;a href="https://en.wikipedia.org/wiki/STUN">&lt;em>https://en.wikipedia.org/wiki/STUN&lt;/em>&lt;/a>&lt;/p>
&lt;p>[8]&lt;/p>
&lt;p>RFC 4787: &lt;a href="https://tools.ietf.org/html/rfc4787">&lt;em>https://tools.ietf.org/html/rfc4787&lt;/em>&lt;/a>&lt;/p>
&lt;p>[9]&lt;/p>
&lt;p>4787: &lt;a href="https://tools.ietf.org/html/rfc4787">&lt;em>https://tools.ietf.org/html/rfc4787&lt;/em>&lt;/a>&lt;/p>
&lt;p>[10]&lt;/p>
&lt;p>5382: &lt;a href="https://tools.ietf.org/html/rfc5382">&lt;em>https://tools.ietf.org/html/rfc5382&lt;/em>&lt;/a>&lt;/p>
&lt;p>[11]&lt;/p>
&lt;p>5508: &lt;a href="https://tools.ietf.org/html/rfc5508">&lt;em>https://tools.ietf.org/html/rfc5508&lt;/em>&lt;/a>&lt;/p>
&lt;p>[12]&lt;/p>
&lt;p>DERP: &lt;a href="https://tailscale.com/blog/how-tailscale-works/#encrypted-tcp-relays-derp">&lt;em>https://tailscale.com/blog/how-tailscale-works/#encrypted-tcp-relays-derp&lt;/em>&lt;/a>&lt;/p>
&lt;p>[13]&lt;/p>
&lt;p>RFC 4787: &lt;a href="https://tools.ietf.org/html/rfc4787">&lt;em>https://tools.ietf.org/html/rfc4787&lt;/em>&lt;/a>&lt;/p>
&lt;p>[14]&lt;/p>
&lt;p>birthday paradox: &lt;a href="https://en.wikipedia.org/wiki/Birthday_problem">&lt;em>https://en.wikipedia.org/wiki/Birthday_problem&lt;/em>&lt;/a>&lt;/p>
&lt;p>[15]&lt;/p>
&lt;p>python calculator: &lt;a href="https://github.com/danderson/nat-birthday-paradox">&lt;em>https://github.com/danderson/nat-birthday-paradox&lt;/em>&lt;/a>&lt;/p>
&lt;p>[16]&lt;/p>
&lt;p>UPnP IGD: &lt;a href="https://openconnectivity.org/developer/specifications/upnp-resources/upnp/internet-gateway-device-igd-v-2-0/">&lt;em>https://openconnectivity.org/developer/specifications/upnp-resources/upnp/internet-gateway-device-igd-v-2-0/&lt;/em>&lt;/a>&lt;/p>
&lt;p>[17]&lt;/p>
&lt;p>NAT-PMP: &lt;a href="https://tools.ietf.org/html/rfc6886">&lt;em>https://tools.ietf.org/html/rfc6886&lt;/em>&lt;/a>&lt;/p>
&lt;p>[18]&lt;/p>
&lt;p>PCP: &lt;a href="https://tools.ietf.org/html/rfc6887">&lt;em>https://tools.ietf.org/html/rfc6887&lt;/em>&lt;/a>&lt;/p>
&lt;p>[19]&lt;/p>
&lt;p>大约 33% 是 IPv6: &lt;a href="https://www.google.com/intl/en/ipv6/statistics.html">&lt;em>https://www.google.com/intl/en/ipv6/statistics.html&lt;/em>&lt;/a>&lt;/p>
&lt;p>[20]&lt;/p>
&lt;p>RFC 8445: &lt;a href="https://tools.ietf.org/html/rfc8445">&lt;em>https://tools.ietf.org/html/rfc8445&lt;/em>&lt;/a>&lt;/p></description></item><item><title>Docs: Network Socket</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/4.%E6%95%B0%E6%8D%AE%E9%80%9A%E4%BF%A1/%E6%95%B0%E6%8D%AE%E9%80%9A%E4%BF%A1/network-socket/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/4.%E6%95%B0%E6%8D%AE%E9%80%9A%E4%BF%A1/%E6%95%B0%E6%8D%AE%E9%80%9A%E4%BF%A1/network-socket/</guid><description>
&lt;p>参考：&lt;a href="https://www.yuque.com/go/doc/33222667">Socket 概述&lt;/a>&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/zvw5dg/1616161399168-31d4bf21-49d1-45dc-993e-83ea35d7a7f2.jpeg" alt="">&lt;/p>
&lt;p>面向连接服务（TCP 协议）：是电话系统服务模式的抽象，即每一次完整的数据传输都要经过建立连接，使用连接，终止连接的过程。在数据传输过程中，各数据分组不携带目的地址，而使用连接号（connect ID）。本质上，连接是一个管道，收发数据不但顺序一致，而且内容相同。TCP 协议提供面向连接的虚电路。例如&lt;/p>
&lt;ol>
&lt;li>文件传输 FTP&lt;/li>
&lt;li>远程登录 SSH&lt;/li>
&lt;li>数字语音&lt;/li>
&lt;li>等&lt;/li>
&lt;/ol>
&lt;p>无连接服务（UDP 协议）：是邮政系统服务的抽象，每个分组都携带完整的目的地址，各分组在系统中独立传送。无连接服务不能保证分组的先后顺序，不进行分组出错的恢复与重传，不保证传输的可靠性。UDP 协议提供无连接的数据报服务。例如：&lt;/p>
&lt;ol>
&lt;li>电子邮件&lt;/li>
&lt;li>电子邮件中的挂号信&lt;/li>
&lt;li>网络数据库查询&lt;/li>
&lt;li>等&lt;/li>
&lt;/ol>
&lt;p>TCP/IP 的 socket 提供下列三种类型套接字。&lt;/p>
&lt;ol>
&lt;li>流式套接字（SOCK_STREAM）：TCP Socket&lt;/li>
&lt;li>提供了一个面向连接、可靠的数据传输服务，数据无差错、无重复地发送，且按发送顺序接收。内设流量控制，避免数据流超限；数据被看作是字节流，无长度限制。文件传送协议（FTP）即使用流式套接字。&lt;/li>
&lt;li>数据报式套接字（SOCK_DGRAM）：UDP Socket&lt;/li>
&lt;li>提供了一个无连接服务（UDP）。数据包以独立包形式被发送，不提供无错保证数据可能丢失或重复，并且接收顺序混乱。网络文件系统（NFS）使用数据报式套接字。&lt;/li>
&lt;li>原始式套接字（SOCK_RAW） ：裸 Socket&lt;/li>
&lt;li>从应用层直接封装网络层报文，跳过传输层的协议.该接口允许对较低层协议，如 IP、ICMP 直接访问。常用于检验新的协议实现或访问现有服务中配置的新设备。&lt;/li>
&lt;/ol>
&lt;p>Socket Domain 套接字域，根据其所有使用的地址进行分类&lt;/p>
&lt;ol>
&lt;li>AF_INET：Address Family，IPv4&lt;/li>
&lt;li>AF_INET6：同上，IPv6&lt;/li>
&lt;li>AF_UNIX：同一主机上不同进程之间通信时使用&lt;/li>
&lt;/ol>
&lt;p>每类套接字至少提供了两种 socket：流，数据报&lt;/p>
&lt;p>tcp：传输控制协议，面向连接的协议，通信钱需要建立虚拟链路，结束后拆除链路&lt;/p>
&lt;p>udp:User Datagram Protocol，无连接的协议&lt;/p>
&lt;ol>
&lt;li>流：可靠的传递，面向连接，无边界&lt;/li>
&lt;li>数据报：不可靠的传递，有边界，无连接&lt;/li>
&lt;/ol>
&lt;p>套接字相关的系统调用&lt;/p>
&lt;ul>
&lt;li>socket()：创建一个套接字&lt;/li>
&lt;li>bind():绑定&lt;/li>
&lt;li>listen()：监听&lt;/li>
&lt;li>connect():请求连接建立&lt;/li>
&lt;li>write()：发送数据&lt;/li>
&lt;li>read()：接收数据&lt;/li>
&lt;/ul>
&lt;h2 id="socket-通信流程">Socket 通信流程&lt;/h2>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/zvw5dg/1616161399174-a6270b36-8bb5-48a4-ba3c-1ee812d450fe.png" alt="">&lt;/p></description></item><item><title>Docs: OSI 模型概念图</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/4.%E6%95%B0%E6%8D%AE%E9%80%9A%E4%BF%A1/%E6%95%B0%E6%8D%AE%E9%80%9A%E4%BF%A1/osi-%E6%A8%A1%E5%9E%8B%E6%A6%82%E5%BF%B5%E5%9B%BE/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/4.%E6%95%B0%E6%8D%AE%E9%80%9A%E4%BF%A1/%E6%95%B0%E6%8D%AE%E9%80%9A%E4%BF%A1/osi-%E6%A8%A1%E5%9E%8B%E6%A6%82%E5%BF%B5%E5%9B%BE/</guid><description>
&lt;h1 id="osi-介绍">OSI 介绍&lt;/h1>
&lt;p>开放式系统互联模型（英语：Open System Interconnection Model，缩写：OSI；简称为 OSI 模型）是一种概念模型，由国际标准化组织提出，一个试图使各种计算机在世界范围内互连为网络的标准框架。定义于 ISO/IEC 7498-1。&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/tudqyb/1616161546435-bc8ba6d0-bb9a-4fc8-819e-6108035f2d1a.jpeg" alt="">&lt;/p>
&lt;h1 id="osi-模型背景编辑">OSI 模型背景[编辑]&lt;/h1>
&lt;p>在制定计算机网络标准方面，起着重大作用的两大国际组织是：国际电信联盟电信标准化部门，与国际标准组织（ISO），虽然它们工作领域不同，但随着科学技术的发展，通信与信息处理之间的界限开始变得比较模糊，这也成了国际电信联盟电信标准化部门和 ISO 共同关心的领域。1984 年，ISO 发布了著名的 ISO/IEC 7498 标准，它定义了网络互联的 7 层框架，也就是开放式系统互联参考模型。&lt;/p>
&lt;p>层次划分[编辑]&lt;/p>
&lt;p>根据建议 X.200，OSI 将计算机网络体系结构划分为以下七层，标有 1 ～ 7，第 1 层在底部。 现“OSI/RM”是英文“Open Systems Interconnection Reference Model”的缩写。&lt;/p>
&lt;p>第 7 层 应用层[编辑]&lt;/p>
&lt;p>主条目：应用层&lt;/p>
&lt;p>应用层（Application Layer）提供为应用软件而设的接口，以设置与另一应用软件之间的通信。例如: HTTP，HTTPS，FTP，TELNET，SSH，SMTP，POP3.HTML.等。&lt;/p>
&lt;p>第 6 层 表达层[编辑]&lt;/p>
&lt;p>主条目：表达层&lt;/p>
&lt;p>表达层（Presentation Layer）把数据转换为能与接收者的系统格式兼容并适合传输的格式。&lt;/p>
&lt;p>第 5 层 会话层[编辑]&lt;/p>
&lt;p>主条目：会话层&lt;/p>
&lt;p>会话层（Session Layer）负责在数据传输中设置和维护电脑网络中两台电脑之间的通信连接。&lt;/p>
&lt;p>第 4 层 传输层[编辑]&lt;/p>
&lt;p>主条目：传输层&lt;/p>
&lt;p>传输层（Transport Layer）把传输表头（TH）加至数据以形成数据包。传输表头包含了所使用的协议等发送信息。例如:传输控制协议（TCP）等。&lt;/p>
&lt;p>第 3 层 网络层[编辑]&lt;/p>
&lt;p>主条目：网络层&lt;/p>
&lt;p>网络层（Network Layer）决定数据的路径选择和转寄，将网络表头（NH）加至数据包，以形成报文。网络表头包含了网络数据。例如:互联网协议（IP）等。&lt;/p>
&lt;p>第 2 层 数据链路层[编辑]&lt;/p>
&lt;p>主条目：数据链路层&lt;/p>
&lt;p>数据链路层（Data Link Layer）负责网络寻址、错误侦测和改错。当表头和表尾被加至数据包时，会形成帧。数据链表头（DLH）是包含了物理地址和错误侦测及改错的方法。数据链表尾（DLT）是一串指示数据包末端的字符串。例如以太网、无线局域网（Wi-Fi）和通用分组无线服务（GPRS）等。&lt;/p>
&lt;p>分为两个子层：逻辑链路控制（logical link control，LLC）子层和介质访问控制（Medium access control，MAC）子层。&lt;/p>
&lt;p>第 1 层 物理层[编辑]&lt;/p>
&lt;p>主条目：物理层&lt;/p>
&lt;p>物理层（Physical Layer）在局部局域网上传送数据帧（data frame），它负责管理电脑通信设备和网络媒体之间的互通。包括了针脚、电压、线缆规范、集线器、中继器、网卡、主机接口卡等。&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>&lt;/th>
&lt;th>&lt;/th>
&lt;th>&lt;/th>
&lt;th>&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>OSI 七层网络模型&lt;/td>
&lt;td>TCP/IP 四层概念模型&lt;/td>
&lt;td>对应网络协议&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>应用层（Application）&lt;/td>
&lt;td>应用层&lt;/td>
&lt;td>HTTP、TFTP, FTP, NFS, WAIS、SMTP&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>表示层（Presentation）&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;td>Telnet, Rlogin, SNMP, Gopher&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>会话层（Session）&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;td>SMTP, DNS&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>传输层（Transport）&lt;/td>
&lt;td>传输层&lt;/td>
&lt;td>TCP, UDP&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>网络层（Network）&lt;/td>
&lt;td>网络层&lt;/td>
&lt;td>IP, ICMP, ARP, RARP, AKP, UUCP&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>数据链路层（Data Link）&lt;/td>
&lt;td>数据链路层&lt;/td>
&lt;td>FDDI, Ethernet, Arpanet, PDN, SLIP, PPP、VLAN、VxLAN&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>物理层（Physical）&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;td>IEEE 802.1A, IEEE 802.2 到 IEEE 802.11&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table></description></item><item><title>Docs: pptp(VPN)协议及其实现</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/4.%E6%95%B0%E6%8D%AE%E9%80%9A%E4%BF%A1/tunneling-protocol%E9%9A%A7%E9%81%93%E5%8D%8F%E8%AE%AE/pptpvpn%E5%8D%8F%E8%AE%AE%E5%8F%8A%E5%85%B6%E5%AE%9E%E7%8E%B0/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/4.%E6%95%B0%E6%8D%AE%E9%80%9A%E4%BF%A1/tunneling-protocol%E9%9A%A7%E9%81%93%E5%8D%8F%E8%AE%AE/pptpvpn%E5%8D%8F%E8%AE%AE%E5%8F%8A%E5%85%B6%E5%AE%9E%E7%8E%B0/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;p>Note：pptpd 存在安全隐患，详情可参考&lt;a href="http://pptpclient.sourceforge.net/protocol-security.phtml">这里&lt;/a>&lt;/p>
&lt;p>The PPTP Server for Linux&lt;/p>
&lt;h1 id="poptop-介绍">Poptop 介绍&lt;/h1>
&lt;p>官方网址：&lt;a href="http://poptop.sourceforge.net/">http://poptop.sourceforge.net/&lt;/a>&lt;/p>
&lt;h2 id="poptop-的安装">Poptop 的安装&lt;/h2>
&lt;p>需要 epel 源&lt;/p>
&lt;p>yum install pptpd&lt;/p>
&lt;h2 id="poptop-关联文件与配置">Poptop 关联文件与配置&lt;/h2>
&lt;p>/etc/pptpd.conf #pptpd 主程序的主配置文件&lt;/p>
&lt;p>localip IP #当远程客户端连接到本地服务时，服务端建立虚拟网卡所用的 ip&lt;/p>
&lt;p>remoteip IP-Range #远程客户端连接到本地服务后，可以分配的给客户端的 ip 范围&lt;/p>
&lt;p>Note：这俩配置完成后，当客户端连接时，就会出现下面虚拟网卡。&lt;/p>
&lt;pre>&lt;code>4: ppp0: &amp;lt;POINTOPOINT,MULTICAST,NOARP,UP,LOWER_UP&amp;gt; mtu 1396 qdisc pfifo_fast state UNKNOWN group default qlen 3
link/ppp
inet 192.168.0.1 peer 192.168.0.234/32 scope global ppp0
valid_lft forever preferred_lft forever
&lt;/code>&lt;/pre>
&lt;p>/etc/ppp/options.pptpd #pptpd 主程序运行时参数&lt;/p>
&lt;p>ms-dns IP #配置 DNS&lt;/p>
&lt;p>/etc/ppp/chap-secrets #配置客户端连接时所用的用户名、密码、协议&lt;/p>
&lt;pre>&lt;code># Secrets for authentication using CHAP
# client server secret IP addresses
lichenhao pptpd lichenhao *
&lt;/code>&lt;/pre>
&lt;p>client #指定用户名&lt;/p>
&lt;p>server #指定该用户连接时所用的协议&lt;/p>
&lt;p>secret #指定该用户密码&lt;/p>
&lt;p>IP addresses #所用的 ip,ip 可以用*表示该用户可用所有 ip&lt;/p>
&lt;h2 id="其他系统配置">其他系统配置&lt;/h2>
&lt;p>添加路由转发功能&lt;/p>
&lt;ol>
&lt;li>cat &amp;raquo; /etc/sysctl.conf &amp;laquo; EOF&lt;/li>
&lt;li>net.ipv4.ip_forward = 1&lt;/li>
&lt;li>EOF&lt;/li>
&lt;li>sysctl -p&lt;/li>
&lt;/ol>
&lt;p>配置防火墙&lt;/p>
&lt;p>iptables -t nat -A POSTROUTING -s 192.168.0.0/24 -o eth0 -j MASQUERADE&lt;/p>
&lt;p>VPN iptables NAT 配置&lt;/p>
&lt;p>iptables -t nat -A POSTROUTING -s 10.254.13.0/24 ! -d 10.254.13.0/24 -j SNAT &amp;ndash;to-source 123.151.161.92&lt;/p>
&lt;p>iptables -t nat -A POSTROUTING -s 192.168.16.0/20 -j MASQUERADE&lt;/p>
&lt;p>windows 配置&lt;/p></description></item><item><title>Docs: Resource Record(资源记录)</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/4.%E6%95%B0%E6%8D%AE%E9%80%9A%E4%BF%A1/dns/resource-record%E8%B5%84%E6%BA%90%E8%AE%B0%E5%BD%95/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/4.%E6%95%B0%E6%8D%AE%E9%80%9A%E4%BF%A1/dns/resource-record%E8%B5%84%E6%BA%90%E8%AE%B0%E5%BD%95/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;h2 id="参考">参考：&lt;/h2>
&lt;/blockquote>
&lt;p>RR 定义的格式：NAME [TTL] CLASS RR-TYPE VALUE（注意：格式中的域名都要带根域名，即域名最后都要加一个 . ）&lt;/p>
&lt;ol>
&lt;li>NAME 和 VALUE # 不同的 RR-TYPE 有不同的格式&lt;/li>
&lt;li>CLASS：IN&lt;/li>
&lt;li>TYPE 资源记录类型：A，AAAA，PTR，SOA，NS，CNAME，MX 等：
&lt;ol>
&lt;li>SRV 格式：域名系统中用于指定服务器提供服务的位置（如主机名和端口）
&lt;ol>
&lt;li>name：_服务._协议.名称.&lt;/li>
&lt;li>value：优先级 权重 端口 主机.&lt;/li>
&lt;/ol>
&lt;/li>
&lt;li>SOA 格式：Start Of Authority：起始授权记录，一个区域解析库有且只能有一个 SOA 记录，而且必须为解析库第一条记录
&lt;ol>
&lt;li>name：当前区域的名字，例如”baidu.com.“&lt;/li>
&lt;li>value (属性)
&lt;ol>
&lt;li>当前区域的主 DNS 服务器的 FQDN，也可以使用当前区域的名字&lt;/li>
&lt;li>当前区域管理员的邮箱地址，但是地址中不能用@符号，@符号用.替换&lt;/li>
&lt;li>（主从服务协调属性的定义以及否定结果的统一的 TTL）&lt;/li>
&lt;/ol>
&lt;/li>
&lt;/ol>
&lt;/li>
&lt;li>NS 格式：Name Server：专用于标明当前区域的 DNS 服务器
&lt;ol>
&lt;li>name：当前区域的名字&lt;/li>
&lt;li>value：当前区域的某 DNS 服务器的名字，例如 ns.baidu.com.;(一个区域可以有多个 NS 记录)&lt;/li>
&lt;/ol>
&lt;/li>
&lt;li>MX 格式：Mail eXchanger：邮件交换器
&lt;ol>
&lt;li>TTL 可以从全局继承&lt;/li>
&lt;/ol>
&lt;/li>
&lt;li>A/AAAA 格式：Address，A 格式用于实现将 FQDN 解析为 IPv4(AAAA 格式用于将 FQDN 解析为 IPv6)
&lt;ol>
&lt;li>name:&lt;/li>
&lt;li>value:&lt;/li>
&lt;/ol>
&lt;/li>
&lt;li>PTR 格式：PoinTeR，用于将 IP 解析为 FQDN
&lt;ol>
&lt;li>name：IP，特殊格式，反写 IP，比如 1.2.3.4 要写成 4.3.2.1，跟后缀 in-addr.arpa.&lt;/li>
&lt;li>value:FQDN&lt;/li>
&lt;/ol>
&lt;/li>
&lt;li>CNAME 格式：Canonical Name，别名记录
&lt;ol>
&lt;li>name：别名的 FQDN&lt;/li>
&lt;li>value：正式名字的 FQDN&lt;/li>
&lt;/ol>
&lt;/li>
&lt;/ol>
&lt;/li>
&lt;li>注意：
&lt;ol>
&lt;li>@可用于引用当前区域的名字&lt;/li>
&lt;li>相邻的两个资源记录的 name 相同时，后续的可省略&lt;/li>
&lt;li>同一个名字可以通过多条记录定义多个不同的值，此时 DNS 服务器会轮循响应&lt;/li>
&lt;li>同一个值也有可能有多个不同的定义名字，通过多个不同的名字指向同一个&lt;/li>
&lt;/ol>
&lt;/li>
&lt;/ol>
&lt;h3 id="example">EXAMPLE&lt;/h3>
&lt;pre>&lt;code>baidu.com 86499 IN SOA ns.baidu.com. lichenhao.qq.com. （
2018072001 #序列号，当序列号变化时，即代表资源有变化，主DNS会主动同步数据给备
2H #刷新时间，2小时
10M #重试时间，10分钟
1W #过期时间，1周
1D ） #否定结果的TTL值，1天
baidu.com. IN NS ns1.baidu.com
ns1.baidu.com IN A 1.1.1.0
www.baidu.com IN A 1.1.1.1
IN A 1.1.1.2
baidu.com. IN MX 10 mx1.baidu.com
IN MX 20 mx2.baidu.com
4.3.2.1.in-addr.arpa. IN PTR www.baidu.com
web.baidu.com. IN CNAME www.baidu.com.
&lt;/code>&lt;/pre>
&lt;p>子域授权：每个域的 DNS 服务器，都是通过在其上级 DNS 服务器中的解析库添加该域的 DNS 服务器信息进行授权&lt;/p>
&lt;p>EXAMPLE，在根域的 DNS 服务器中，记录了.com.域的资源记录，类似下面的方式，不是绝对的
.com. IN NS ns1.com. 定义.com.域的域名服务器为 ns1.com.
.com. IN NS ns2.com.
ns1.com. IN A 2.2.2.1 定于.com.域中的域名服务器 ns1.com.的 IP 地址为 2.2.2.1
ns2.com. IN A 2.2.2.2&lt;/p>
&lt;p>当www.baidu.com.的DNS请求到根的DNS服务器的时候，根的DNS服务器查找自己解析库中.com的域中的DNS服务器资源，然后看到该DNS服务器所对应的IP，然后把该请求转发到.com域中的DNS服务器进行下一步解析，然后.com域的DNS服务器在从解析库中找到baidu的资源再转发到baidu的DNS服务器上(或者直接返回baidu的IP地址)&lt;/p>
&lt;p>以上例子是.com 域在.根域中解析库中的资源记录，如果还有 baidu.com 的域名，则该域的资源记录写在.com 域中的解析库，以此类推&lt;/p>
&lt;p>反向区域：&lt;/p>
&lt;p>区域名称：网络地址反写.in-addr-arpa.&lt;/p>
&lt;p>EXAMPLE：172.16.100. 写成 100.16.172.in-addr-arpa.&lt;/p></description></item><item><title>Docs: SDN(软件定义网路)</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/4.%E6%95%B0%E6%8D%AE%E9%80%9A%E4%BF%A1/sdn%E8%BD%AF%E4%BB%B6%E5%AE%9A%E4%B9%89%E7%BD%91%E8%B7%AF/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/4.%E6%95%B0%E6%8D%AE%E9%80%9A%E4%BF%A1/sdn%E8%BD%AF%E4%BB%B6%E5%AE%9A%E4%B9%89%E7%BD%91%E8%B7%AF/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Software-defined_networking">Wiki,Software-defined networking&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>&lt;strong>Software Defined Networking(软件定义网络，简称 SDN)&lt;/strong> 技术是一种&lt;a href="https://en.wikipedia.org/wiki/Network_management">网络管理&lt;/a>方法，它支持动态的、以编程方式高效的网络配置，以提高网络性能和监控，使其更像&lt;a href="https://en.wikipedia.org/wiki/Cloud_computing">云计算，而&lt;/a>不是传统的网络管理。&lt;a href="https://en.wikipedia.org/wiki/Software-defined_networking#cite_note-ReferenceA-1">[1]&lt;/a> SDN 旨在解决传统网络的静态架构分散且复杂的事实，而当前网络需要更多的灵活性和易于故障排除。SDN 试图通过将&lt;a href="https://en.wikipedia.org/wiki/Network_packet">网络数据包&lt;/a>的转发过程（数据平面）与路由过程（控制平面）分离，将网络智能集中在一个网络组件中。&lt;a href="https://en.wikipedia.org/wiki/Software-defined_networking#cite_note-2">[2]&lt;/a>该&lt;a href="https://en.wikipedia.org/wiki/Control_plane">控制平面&lt;/a>由一个或多个控制器组成，这些控制器被认为是包含整个智能的 SDN 网络的大脑。然而，智能中心化在安全性、&lt;a href="https://en.wikipedia.org/wiki/Software-defined_networking#cite_note-ReferenceA-1">[1]&lt;/a>可扩展性和弹性&lt;a href="https://en.wikipedia.org/wiki/Software-defined_networking#cite_note-ReferenceA-1">[1]&lt;/a>方面有其自身的缺点，这是 SDN 的主要问题。&lt;/p>
&lt;p>自&lt;a href="https://en.wikipedia.org/wiki/OpenFlow">OpenFlow&lt;/a>协议于 2011 年出现以来，SDN 通常与&lt;a href="https://en.wikipedia.org/wiki/OpenFlow">OpenFlow&lt;/a>协议（用于与网络平面元素进行远程通信，以确定&lt;a href="https://en.wikipedia.org/wiki/Network_packet">网络数据包&lt;/a>通过&lt;a href="https://en.wikipedia.org/wiki/Network_switch">网络交换机&lt;/a>的路径）相关联。然而，自 2012 年&lt;a href="https://en.wikipedia.org/wiki/Software-defined_networking#cite_note-TechTarget:_SDN_is_not_OpenFlow-3">[3] &lt;/a>&lt;a href="https://en.wikipedia.org/wiki/Software-defined_networking#cite_note-TechTarget:_OpenFlow_not_the_only_show_in_town-4">[4]&lt;/a> OpenFlow 对于许多公司不再是独家解决方案，他们增加了专有技术。其中包括&lt;a href="https://en.wikipedia.org/wiki/Cisco_Systems">Cisco Systems&lt;/a>的开放网络环境和&lt;a href="https://en.wikipedia.org/wiki/Nicira">Nicira&lt;/a>的&lt;a href="https://en.wikipedia.org/wiki/Network_virtualization_platform">网络虚拟化平台&lt;/a>。
&lt;a href="https://en.wikipedia.org/wiki/SD-WAN">SD-WAN&lt;/a>将类似技术应用于&lt;a href="https://en.wikipedia.org/wiki/Wide_area_network">广域网&lt;/a>(WAN)。&lt;a href="https://en.wikipedia.org/wiki/Software-defined_networking#cite_note-5">[5]&lt;/a>&lt;/p>
&lt;p>SDN 技术目前可用于需要极快故障转移的工业控制应用，称为操作技术 (OT) 软件定义网络 (SDN)。OT SDN 技术是一种在关键基础设施网络的环境强化硬件上管理网络访问控制和以太网数据包交付的方法。OT SDN 将控制平面的管理从集中在流控制器中的交换机抽象出来，并将 SDN 应用为交换机中的底层控制平面。去除了传统控制平面，简化了交换机，同时集中控制平面管理。OT SDN 中使用的通用控制平面标准是 OpenFlow，使其可与其他 SDN 解决方案互操作，不同之处在于 OpenFlow 是交换机中唯一的控制平面，并且交换机在电源循环期间保留流量，并且所有流量和冗余都经过主动流量工程设计因此交换机可以执行转发，它们被配置为在有或没有在线流量控制器的情况下执行。OT SDN 在性能、网络安全和态势感知方面为工业网络提供了优势。性能优势是通过使用 OpenFlow 中的快速故障转移组的主动流量工程意外事件实现的，从而在微秒内从链路或交换机故障中恢复网络，而不是像生成树技术那样的毫秒级。另一个性能优势是环路缓解是通过流量工程路径规划完成的，而不是阻塞端口，允许系统所有者主动使用所有端口。OT SDN 的网络安全优势在于交换机默认拒绝，流是允许流量转发的规则。这提供了强大的网络访问控制，可以在每一跳从 OSI 模型的第 1 层到第 4 层检查数据包。由于旧控制平面不再存在，因此移除了旧控制平面安全漏洞。MAC 表欺骗和 BPDU 欺骗不再可能，因为两者都不存在于 OT SDN 交换机中。旋转和网络侦察不再适用于适当的流编程，因为仅允许转发结合物理位置和路径与虚拟数据包过滤的流量。OT SDN 的态势感知优势使网络所有者能够了解其网络上有哪些设备，哪些对话可以和正在发生，以及这些对话可以在谁之间发生。OT SDN 网络技术允许以太网满足关键基础设施测量和控制的苛刻通信消息交换要求，并简单地为系统所有者提供对哪些设备可以连接到网络、这些设备可以连接到哪里以及每个设备可以进行哪些对话的控制有。OT SDN 的态势感知优势使网络所有者能够了解其网络上有哪些设备，哪些对话可以和正在发生，以及这些对话可以在谁之间发生。OT SDN 网络技术允许以太网满足关键基础设施测量和控制的苛刻通信消息交换要求，并简单地为系统所有者提供对哪些设备可以连接到网络、这些设备可以连接到哪里以及每个设备可以进行哪些对话的控制有。OT SDN 的态势感知优势使网络所有者能够了解其网络上有哪些设备，哪些对话可以和正在发生，以及这些对话可以在谁之间发生。OT SDN 网络技术允许以太网满足关键基础设施测量和控制的苛刻通信消息交换要求，并简单地为系统所有者提供对哪些设备可以连接到网络、这些设备可以连接到哪里以及每个设备可以进行哪些对话的控制有。&lt;/p>
&lt;p>SDN 的研究仍在继续，因为许多&lt;a href="https://en.wikipedia.org/wiki/Emulator">仿真器&lt;/a>正在开发用于研究目的，例如 vSDNEmul、&lt;a href="https://en.wikipedia.org/wiki/Software-defined_networking#cite_note-6">[6]&lt;/a> EstiNet、&lt;a href="https://en.wikipedia.org/wiki/Software-defined_networking#cite_note-7">[7]&lt;/a> Mininet &lt;a href="https://en.wikipedia.org/wiki/Software-defined_networking#cite_note-8">[8]&lt;/a>等。&lt;/p></description></item><item><title>Docs: Session 与 Cookie</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/4.%E6%95%B0%E6%8D%AE%E9%80%9A%E4%BF%A1/%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/7.http/http-%E7%9A%84-%E6%8C%81%E4%B9%85%E5%8C%96-%E4%B8%8E-%E8%AE%A4%E8%AF%81_%E6%8E%88%E6%9D%83/session-%E4%B8%8E-cookie/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/4.%E6%95%B0%E6%8D%AE%E9%80%9A%E4%BF%A1/%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/7.http/http-%E7%9A%84-%E6%8C%81%E4%B9%85%E5%8C%96-%E4%B8%8E-%E8%AE%A4%E8%AF%81_%E6%8E%88%E6%9D%83/session-%E4%B8%8E-cookie/</guid><description>
&lt;p>Cookie&lt;/p>
&lt;p>背景&lt;/p>
&lt;ul>
&lt;li>
&lt;p>HTTP 是无状态协议，服务器不能记录浏览器的访问状态，也就是说服务器不能区分两次请求是否由同一个客户端发出&lt;/p>
&lt;/li>
&lt;li>
&lt;p>**Cookie(小甜饼) **就是解决 HTTP 协议无状态的方案之一&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Cookie 实际上就是服务器保存再浏览器上的一段信息。浏览器有了 Cookie 之后，每次向服务器发送请求时都会同时将该信息发送给服务器，服务器收到请求后，就可以根据该信息处理请求&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Cookie 由服务器创建，并发送给浏览器，最终由浏览器保存&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/qpvk57/1616161168269-5454b393-dbe3-4518-a3e0-480ab5358176.png" alt="">&lt;/p>
&lt;p>Cookie 的用途&lt;/p>
&lt;ul>
&lt;li>
&lt;p>保持用户登陆状态，由于不够安全，现在有其他方式替代&lt;/p>
&lt;/li>
&lt;li>
&lt;p>京东未登录的状态下，使用 Cookie 存储购物车中的物品的&lt;/p>
&lt;/li>
&lt;/ul>
&lt;blockquote>
&lt;p>淘宝不是这么实现的，淘宝必须登录才能浏览详细商品&lt;/p>
&lt;/blockquote>
&lt;ul>
&lt;li>
&lt;p>上一次连接时打开的页面&lt;/p>
&lt;/li>
&lt;li>
&lt;p>与某个账号关联&lt;/p>
&lt;/li>
&lt;li>
&lt;p>等等&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h2 id="cookie-的属性">Cookie 的属性&lt;/h2>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/qpvk57/1623676019731-6e1d1e07-4c5a-4d22-a396-32d3e541c07f.png" alt="image.png">&lt;/p>
&lt;p>一个 cookie 将会具有如下字段：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>&lt;strong>name&lt;/strong> # cookie 的名称&lt;/p>
&lt;/li>
&lt;li>
&lt;p>**value **# cookie 的值&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>domain&lt;/strong> # 可以访问此 cookie 的域名&lt;/p>
&lt;/li>
&lt;li>
&lt;p>**path **# 可以访问此 cookie 的页面路径。比如 domain 是 desistdaydream.ltd，path 是 /cookie，那么只有访问 &lt;a href="http://desistdaydream.ltd/cookie">http://desistdaydream.ltd/cookie&lt;/a> 路径下的页面时，才可以读取此 cookie&lt;/p>
&lt;/li>
&lt;li>
&lt;p>**MaxAge **或 &lt;strong>Expires&lt;/strong> # 设置 cookie 持久化时的过期时长&lt;/p>
&lt;ul>
&lt;li>注意：Expires 是老式的过期方法， 如果可以，应该使用 MaxAge 设置过期时间，但有些老版本的浏览器不支持 MaxAge。 如果要支持所有浏览器，要么使用 Expires，要么同时使用 MaxAge 和 Expires。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>size&lt;/strong> # cookie 的大小&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>httpOnly&lt;/strong> # 是否允许别人通过 js 获取自己的 cookie&lt;/p>
&lt;ul>
&lt;li>httpOnly 属性限制了 cookie 对 HTTP 请求的作用范围。特别的，该属性指示用户代理忽略那些通过&amp;quot;非 HTTP&amp;quot; 方式对 cookie 的访问（比如浏览器暴露给 js 的接口）。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>secure&lt;/strong> # 是否只能通过 https 访问&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>注意：&lt;/p>
&lt;ul>
&lt;li>HttpOnly 属性和 Secure 属性相互独立：一个 cookie 既可以是 HttpOnly 的也可以有 Secure 属性。 在前段时间的项目中我就用 js 去读取一个 cookie，结果怎么都取不到这个值，最后查证这个 cookie 是 httpOnly 的，花了近 2 个小时，悲剧了。&lt;/li>
&lt;/ul>
&lt;p>Cookie 的缺点&lt;/p>
&lt;ul>
&lt;li>
&lt;p>不安全，明文&lt;/p>
&lt;/li>
&lt;li>
&lt;p>增加带宽消耗&lt;/p>
&lt;/li>
&lt;li>
&lt;p>可以在客户端手动禁用&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Cookie 是有上限的，最大 4096 字节&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>Session&lt;/p>
&lt;p>背景&lt;/p>
&lt;p>Cookie 虽然在一定程度上解决了 &amp;ldquo;保持状态&amp;rdquo; 的需求，但是由于 Cookie 本身最大支持 4096 字节，以及 Cookie 本身保存在客户端，可能被拦截或窃取，因此就需要有一种新的东西，它能支持更多的字节，并且他保存在服务器，有较高的安全性，这，就是 &lt;strong>Session(会话)&lt;/strong>。&lt;/p>
&lt;p>但是这时，问题又来了，基于 HTTP 协议的无状态特征，服务器根本不知道访问者是谁。又如何保存呢？此时，Cookie 又来了，起到了一个桥接的作用。&lt;/p>
&lt;p>用户登录成功之后，我们在服务端为每个用户创建一个特定的 **SessionData **和 &lt;strong>SessionID&lt;/strong>，他们一一对应。其中：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>SessionData 是在服务端保存的一个数据结构，用来跟踪用户的状态，这个数据可以保存在集群、数据库、文件中&lt;/p>
&lt;ul>
&lt;li>这个 SessionData 的数据结构一般都是 KEY/VALUE 类型的结构，相当于一个 **大 map。**可以保存在内存中、关系型数据库、Rdis、文件、等等地方&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>SessionID 作为唯一标识符，通常会写入到用户的 Cookie 中。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>所以，&lt;strong>Session 必须依赖于 Cookie 才能使用&lt;/strong>，生成一个 SessionID 放在 Cookie 里传给客户端即可。&lt;/p>
&lt;p>在互联网早期，访问一个网站为了持久化，将用户名和密码放在 cookie 里，一条信息就对应一条 cookie。&lt;/p>
&lt;p>比如访问 baidu.com 后，浏览器记录了这么几个 cookie：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>username: DesistDaydream&lt;/p>
&lt;/li>
&lt;li>
&lt;p>password: mypassword&lt;/p>
&lt;/li>
&lt;li>
&lt;p>XXX: XXXX&lt;/p>
&lt;/li>
&lt;li>
&lt;p>YYY: YYY&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&amp;hellip;..等等&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>而使用了 Session 之后，Cookie 不再记录这些敏感信息，只保存一个 ID 用来标识这个 Session：&lt;/p>
&lt;ul>
&lt;li>sessionID: DesistDaydream&lt;/li>
&lt;/ul>
&lt;p>剩下的信息一般都保存在服务器本地，根据 sessionID 找到对应信息即可&lt;/p>
&lt;p>Session 逻辑&lt;/p>
&lt;p>这是一个简单的 Session 处理请求的逻辑&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/qpvk57/1616161168291-de47fffb-605b-41a5-ae65-aa3004c78762.png" alt="">&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/qpvk57/1616161168320-400fd569-42fc-41ba-a439-6556a456a72e.png" alt="">&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/qpvk57/1616161168293-4d7ef534-5772-4f15-8eaf-ccf0aa43f1db.png" alt="">&lt;/p>
&lt;h2 id="session-设计思路">Session 设计思路&lt;/h2>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/qpvk57/1616161168286-70f4c25f-49bd-4b84-8b50-f0bca0900dd1.png" alt="">&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/qpvk57/1616161168270-49a7f14e-1cf0-4e50-8ddc-3cc8d9537544.png" alt="">&lt;/p>
&lt;p>Session 本质上是一个 K/V ，通过 key 进行增删改查。可以存储在 RAM 或者 Redis 中。&lt;/p>
&lt;ul>
&lt;li>
&lt;p>一般有多个 Session，所以需要一个管理器统一管理&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Session 一般作为中间件，所以需要暴露结构给其他代码使用&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>Session 接口设计&lt;/p>
&lt;ul>
&lt;li>
&lt;p>Set()&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Get()&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Del()&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Save() # 持久存储&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>SessionMgr 接口设计&lt;/p>
&lt;ul>
&lt;li>
&lt;p>Init() # 初始化，加载 RAM 或 Redis &lt;/p>
&lt;/li>
&lt;li>
&lt;p>CreateSession() # 创建一个新的 Session&lt;/p>
&lt;/li>
&lt;li>
&lt;p>GetSession() # 通过 SessionID 获取对应的 Session 对象&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>RAM Session 设计&lt;/p>
&lt;ul>
&lt;li>
&lt;p>定义 RAM Session 对象&lt;/p>
&lt;ul>
&lt;li>
&lt;p>SessionID&lt;/p>
&lt;/li>
&lt;li>
&lt;p>存 K/V 的 map&lt;/p>
&lt;/li>
&lt;li>
&lt;p>读写锁&lt;/p>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>构造函数，为了获取对象&lt;/p>
&lt;ul>
&lt;li>
&lt;p>Set()&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Get()&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Del()&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Save()&lt;/p>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>RAM SessionMgr 设计&lt;/p>
&lt;ul>
&lt;li>
&lt;p>定义 Memory SessionMgr 对象&lt;/p>
&lt;ul>
&lt;li>
&lt;p>存放所有 Session 的 map&lt;/p>
&lt;/li>
&lt;li>
&lt;p>读写锁&lt;/p>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>构造函数&lt;/p>
&lt;ul>
&lt;li>
&lt;p>Init()&lt;/p>
&lt;/li>
&lt;li>
&lt;p>CreateSession()&lt;/p>
&lt;/li>
&lt;li>
&lt;p>GetSession()&lt;/p>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>Redis Session 设计&lt;/p>
&lt;ul>
&lt;li>
&lt;p>定义 RedisSession 对象&lt;/p>
&lt;ul>
&lt;li>
&lt;p>SessionID&lt;/p>
&lt;/li>
&lt;li>
&lt;p>存 K/V 的 map&lt;/p>
&lt;/li>
&lt;li>
&lt;p>读写锁&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Redis 连接池&lt;/p>
&lt;/li>
&lt;li>
&lt;p>记录内存中 map 是否被修改的编辑&lt;/p>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>构造函数&lt;/p>
&lt;ul>
&lt;li>
&lt;p>Set()&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Get()&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Del()&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Save()&lt;/p>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>Redis SessionMgr 设计&lt;/p>
&lt;ul>
&lt;li>
&lt;p>定义 Redis SessionMgr 对象&lt;/p>
&lt;ul>
&lt;li>
&lt;p>Redis 地址、密码、连接池、读写锁&lt;/p>
&lt;/li>
&lt;li>
&lt;p>存放所有 Session 的 map&lt;/p>
&lt;/li>
&lt;li>
&lt;p>读写锁&lt;/p>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>构造函数&lt;/p>
&lt;ul>
&lt;li>
&lt;p>Init()&lt;/p>
&lt;/li>
&lt;li>
&lt;p>CreateSession()&lt;/p>
&lt;/li>
&lt;li>
&lt;p>GetSession()&lt;/p>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul></description></item><item><title>Docs: Tailscale</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/4.%E6%95%B0%E6%8D%AE%E9%80%9A%E4%BF%A1/tunneling-protocol%E9%9A%A7%E9%81%93%E5%8D%8F%E8%AE%AE/tailscale/tailscale/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/4.%E6%95%B0%E6%8D%AE%E9%80%9A%E4%BF%A1/tunneling-protocol%E9%9A%A7%E9%81%93%E5%8D%8F%E8%AE%AE/tailscale/tailscale/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://github.com/tailscale/tailscale">GitHub 项目，tailscale/tailscale&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://tailscale.com/">官网&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>&lt;a href="https://github.com/juanfont/headscale">https://github.com/juanfont/headscale&lt;/a> # 自建 Tailscale 控制台&lt;/p></description></item><item><title>Docs: Tailscale ACL 访问控制策略</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/4.%E6%95%B0%E6%8D%AE%E9%80%9A%E4%BF%A1/tunneling-protocol%E9%9A%A7%E9%81%93%E5%8D%8F%E8%AE%AE/tailscale/tailscale-acl-%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6%E7%AD%96%E7%95%A5/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/4.%E6%95%B0%E6%8D%AE%E9%80%9A%E4%BF%A1/tunneling-protocol%E9%9A%A7%E9%81%93%E5%8D%8F%E8%AE%AE/tailscale/tailscale-acl-%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6%E7%AD%96%E7%95%A5/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://mp.weixin.qq.com/s/JIbKEWJBDzP3mjWzlZ1DIA">公众号-云原生实验室，ailscale ACL 访问控制策略完全指南！&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>大家好，我是米开朗基杨。&lt;/p>
&lt;p>前面几篇文章给大家给介绍了 Tailscale 和 Headscale，包括 &lt;a href="https://mp.weixin.qq.com/s?__biz=MzU1MzY4NzQ1OA==&amp;amp;mid=2247504037&amp;amp;idx=1&amp;amp;sn=b059e0ed24be4ae39a25e5724700ff54&amp;amp;scene=21#wechat_redirect">👉Headscale 的安装部署和各个平台客户端的接入，以及如何打通各个节点所在的局域网&lt;/a>。同时还介绍了&lt;a href="https://mp.weixin.qq.com/s?__biz=MzU1MzY4NzQ1OA==&amp;amp;mid=2247504288&amp;amp;idx=1&amp;amp;sn=93d74eb52ac6d1bb176c1599b3c27962&amp;amp;scene=21#wechat_redirect">👉 如何自建私有的 DERP 服务器，并让 Tailscale 使用我们自建的 DERP 服务器&lt;/a>。&lt;/p>
&lt;p>今天我们来探索一下更复杂的场景。想象有这么一个场景，我系统通过 Tailscale 方便的连接一台不完全属于我的设备， 这台设备可能还有其他人也在使用。如果我仅仅是安装一个 Tailscale， 那么所有能登录这台设备的人都可以通过 Tailscale 连接我所有的设备。&lt;/p>
&lt;p>我能不能实现这样一种需求：&lt;strong>我可以连接这台节点，但是这台节点不能连接我的其他节点？&lt;/strong>&lt;/p>
&lt;p>这就是 Tailscale ACL（Access Control List）干的事情。ACL 可以严格限制特定用户或设备在 Tailscale 网络上访问的内容。&lt;/p>
&lt;blockquote>
&lt;p>❝ 虽然 Headscale 兼容 Tailscale 的 ACL，但还是有些许差异的。&lt;strong>本文所讲的 ACL 只适用于 Headscale&lt;/strong>，如果你使用的是官方的控制服务器，有些地方可能跟预期不符，请自行参考 Tailscale 的官方文档。&lt;/p>
&lt;/blockquote>
&lt;p>Tailscale/Headscale 的默认访问规则是 &lt;code>default deny&lt;/code>，也就是黑名单模式，只有在访问规则明确允许的情况下设备之间才能通信。所以 Tailscale/Headscale 默认会使用 &lt;code>allowall&lt;/code> 访问策略进行初始化，该策略允许加入到 Tailscale 网络的所有设备之间可以相互访问。&lt;/p>
&lt;p>Tailscale/Headscale 通过使用 group 这种概念，可以&lt;strong>只用非常少的规则就能表达大部分安全策略&lt;/strong>。除了 group 之外，还可以为设备打 tag 来进一步扩展访问策略。结合 group 和 tag 就可以构建出强大的基于角色的访问控制（RBAC）策略。&lt;/p>
&lt;p>关于 Tailscale 访问控制系统的详情可以参考这篇文章：基于角色的访问控制（RBAC）：演进历史、设计理念及简洁实现[1]。这篇文章深入探讨了访问控制系统的历史，从设计层面分析了 &lt;code>DAC -&amp;gt; MAC -&amp;gt; RBAC -&amp;gt; ABAC&lt;/code>  的演进历程及各模型的优缺点、适用场景等， 然后从实际需求出发，一步步地设计出一个实用、简洁、真正符合 RBAC 理念的访问控制系统。&lt;/p>
&lt;h2 id="tailscale-acl-语法">Tailscale ACL 语法&lt;/h2>
&lt;p>Tailscale ACL 需要保存为 HuJSON 格式，也就是 human JSON[2]。HuJSON 是 JSON 的超集，允许添加注释以及结尾处添加逗号。这种格式更易于维护，对人类和机器都很友好。&lt;/p>
&lt;blockquote>
&lt;p>❝Headscale 除了支持 HuJSON 之外，还支持使用 YAML 来编写 ACL。本文如不作特殊说明，默认都使用 YAML 格式。&lt;/p>
&lt;/blockquote>
&lt;p>Headscale 的 ACL 策略主要包含以下几个部分：&lt;/p>
&lt;ul>
&lt;li>&lt;code>acls&lt;/code>：ACL 策略定义。&lt;/li>
&lt;li>&lt;code>groups&lt;/code>：用户的集合。Tailscale 官方控制器的“用户”指的是登录名，必须是邮箱格式。而 &lt;strong>Headscale 的用户就是 namesapce&lt;/strong>。&lt;/li>
&lt;li>&lt;code>hosts&lt;/code>：定义 IP 地址或者 CIDR 的别名。&lt;/li>
&lt;li>&lt;code>tagOwners&lt;/code>：指定哪些用户有权限给设备打 tag。&lt;/li>
&lt;li>&lt;code>autoApprovers&lt;/code>：允许哪些用户不需要控制端确认就可以宣告 Subnet 路由和 Exit Node。&lt;/li>
&lt;/ul>
&lt;h3 id="acl-规则">ACL 规则&lt;/h3>
&lt;p>acls 部分是 ACL 规则主体，每个规则都是一个 HuJSON 对象，它授予从一组访问来源到一组访问目标的访问权限。&lt;/p>
&lt;p>所有的 ACL 规则最终表示的都是&lt;strong>允许从特定源 IP 地址到特定目标 IP 地址和端口的流量&lt;/strong>。虽然可以直接使用 IP 地址来编写 ACL 规则，但为了可读性以及方便维护，建议使用用户、Group 以及 tag 来编写规则，Tailscale 最终会将其转换为具体的 IP 地址和端口。&lt;/p>
&lt;p>每一个 ACL 访问规则长这个样子：&lt;/p>
&lt;p>&lt;code>- action: accept     src:       - xxx       - xxx       - ...     dst:       - xxx       - xxx       - ...     proto: protocol # 可选参数&lt;/code>&lt;/p>
&lt;p>Tailscale/Headscale 的默认访问规则是 &lt;code>default deny&lt;/code>，也就是黑名单模式，只有在访问规则明确允许的情况下设备之间才能通信。所以 ACL 规则中的 &lt;code>action&lt;/code> 值一般都写 &lt;code>accept&lt;/code>，毕竟默认是 deny 嘛。&lt;/p>
&lt;p>&lt;code>src&lt;/code> 字段表示访问来源列表，该字段可以填的值都在这个表格里：&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>类型&lt;/th>
&lt;th>示例&lt;/th>
&lt;th>含义&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>Any&lt;/td>
&lt;td>*&lt;/td>
&lt;td>无限制（即所有来源）&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>用户(Namespace)&lt;/td>
&lt;td>dev1&lt;/td>
&lt;td>Headscale namespace 中的所有设备&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Group (ref)[3]&lt;/td>
&lt;td>group:example&lt;/td>
&lt;td>Group 中的所有用户&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Tailscale IP&lt;/td>
&lt;td>100.101.102.103&lt;/td>
&lt;td>拥有给定 Tailscale IP 的设备&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Subnet CIDR (ref)[4]&lt;/td>
&lt;td>192.168.1.0/24&lt;/td>
&lt;td>CIDR 中的任意 IP&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Hosts (ref)[5]&lt;/td>
&lt;td>my-host&lt;/td>
&lt;td>&lt;code>hosts&lt;/code>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td> 字段中定义的任意 IP&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Tags (ref)[6]&lt;/td>
&lt;td>tag:production&lt;/td>
&lt;td>分配指定 tag 的所有设备&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Tailnet members&lt;/td>
&lt;td>autogroup:members&lt;/td>
&lt;td>Tailscale 网络中的任意成员（设备）&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>&lt;code>proto&lt;/code> 字段是可选的，指定允许访问的协议。如歌不指定，默认可以访问所有 TCP 和 UDP 流量。&lt;/p>
&lt;p>&lt;code>proto&lt;/code> 可以指定为 IANA IP 协议编号[7] 1-255（例如 16）或以下命名别名之一（例如 sctp）：&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>协议&lt;/th>
&lt;th>proto&lt;/th>
&lt;th>IANA 协议编号&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>Internet Group Management (IGMP)&lt;/td>
&lt;td>igmp&lt;/td>
&lt;td>2&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>IPv4 encapsulation&lt;/td>
&lt;td>ipv4, ip-in-ip&lt;/td>
&lt;td>4&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Transmission Control (TCP)&lt;/td>
&lt;td>tcp&lt;/td>
&lt;td>6&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Exterior Gateway Protocol (EGP)&lt;/td>
&lt;td>egp&lt;/td>
&lt;td>8&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Any private interior gateway&lt;/td>
&lt;td>igp&lt;/td>
&lt;td>9&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>User Datagram (UDP)&lt;/td>
&lt;td>udp&lt;/td>
&lt;td>17&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Generic Routing Encapsulation (GRE)&lt;/td>
&lt;td>gre&lt;/td>
&lt;td>47&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Encap Security Payload (ESP)&lt;/td>
&lt;td>esp&lt;/td>
&lt;td>50&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Authentication Header (AH)&lt;/td>
&lt;td>ah&lt;/td>
&lt;td>51&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Stream Control Transmission Protocol (SCTP)&lt;/td>
&lt;td>sctp&lt;/td>
&lt;td>132&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>只有 TCP、UDP 和 SCTP 流量支持指定端口，其他协议的端口必须指定为 &lt;code>*&lt;/code>。&lt;/p>
&lt;p>dst 字段表示访问目标列表，列表中的每个元素都用 &lt;code>hosts:ports&lt;/code> 来表示。hosts 的取值范围如下：&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>类型&lt;/th>
&lt;th>示例&lt;/th>
&lt;th>含义&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>Any&lt;/td>
&lt;td>*&lt;/td>
&lt;td>无限制（即所有访问目标）&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>用户（Namespace）&lt;/td>
&lt;td>dev1&lt;/td>
&lt;td>Headscale namespace 中的所有设备&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Group (ref)[8]&lt;/td>
&lt;td>group:example&lt;/td>
&lt;td>Group 中的所有用户&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Tailscale IP&lt;/td>
&lt;td>100.101.102.103&lt;/td>
&lt;td>拥有给定 Tailscale IP 的设备&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Hosts (ref)[9]&lt;/td>
&lt;td>my-host&lt;/td>
&lt;td>&lt;code>hosts&lt;/code>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td> 字段中定义的任意 IP&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Subnet CIDR (ref)[10]&lt;/td>
&lt;td>192.168.1.0/24&lt;/td>
&lt;td>CIDR 中的任意 IP&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Tags (ref)[11]&lt;/td>
&lt;td>tag:production&lt;/td>
&lt;td>分配指定 tag 的所有设备&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Internet access (ref)[12]&lt;/td>
&lt;td>autogroup:internet&lt;/td>
&lt;td>通过 Exit Node 访问互联网&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Own devices&lt;/td>
&lt;td>autogroup:self&lt;/td>
&lt;td>允许 src 中定义的来源访问自己（不包含分配了 tag 的设备）&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Tailnet devices&lt;/td>
&lt;td>autogroup:members&lt;/td>
&lt;td>Tailscale 网络中的任意成员（设备）&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>&lt;code>ports&lt;/code> 的取值范围：&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>类型&lt;/th>
&lt;th>示例&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>Any&lt;/td>
&lt;td>*&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Single&lt;/td>
&lt;td>22&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Multiple&lt;/td>
&lt;td>80,443&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Range&lt;/td>
&lt;td>1000-2000&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="groups">Groups&lt;/h3>
&lt;p>groups 定义了一组用户的集合，YAML 格式示例配置如下：&lt;/p>
&lt;p>&lt;code>groups:   group:admin:     - &amp;quot;admin1&amp;quot;   group:dev:     - &amp;quot;dev1&amp;quot;     - &amp;quot;dev2&amp;quot;&lt;/code>&lt;/p>
&lt;p>huJSON 格式：&lt;/p>
&lt;p>&lt;code>&amp;quot;groups&amp;quot;: {   &amp;quot;group:admin&amp;quot;: [&amp;quot;admin1&amp;quot;],   &amp;quot;group:dev&amp;quot;: [&amp;quot;dev1&amp;quot;, &amp;quot;dev2&amp;quot;], },&lt;/code>&lt;/p>
&lt;p>每个 Group 必须以 &lt;code>group:&lt;/code> 开头，Group 之间也不能相互嵌套。&lt;/p>
&lt;h3 id="autogroups">Autogroups&lt;/h3>
&lt;p>autogroup 是一个特殊的 group，它自动包含具有相同属性的用户或者访问目标，可以在 ACL 规则中调用 autogroup。&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>Autogroup&lt;/th>
&lt;th>允许在 ACL 的哪个字段调用&lt;/th>
&lt;th>含义&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>autogroup:internet&lt;/td>
&lt;td>dst&lt;/td>
&lt;td>用来允许任何用户通过任意 Exit Node 访问你的 Tailscale 网络&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>autogroup:members&lt;/td>
&lt;td>src 或者 dst&lt;/td>
&lt;td>用来允许 Tailscale 网络中的任意成员（设备）访问别人或者被访问&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>autogroup:self&lt;/td>
&lt;td>dst&lt;/td>
&lt;td>用来允许 src 中定义的来源访问自己&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>示例配置：&lt;/p>
&lt;p>&lt;code>acls:   # 允许所有员工访问自己的设备   - action: accept     src:       - &amp;quot;autogroup:members&amp;quot;     dst:       - &amp;quot;autogroup:self:*&amp;quot;   # 允许所有员工访问打了标签 tag:corp 的设备   - action: accept     src:       - &amp;quot;autogroup:members&amp;quot;     dst:       - &amp;quot;tag:corp:*&amp;quot;&lt;/code>&lt;/p>
&lt;h3 id="hosts">Hosts&lt;/h3>
&lt;p>Hosts 用来定义 IP 地址或者 CIDR 的别名，使 ACL 可读性更强。示例配置：&lt;/p>
&lt;p>&lt;code>hosts:   example-host-1: &amp;quot;100.100.100.100&amp;quot;   example-network-1: &amp;quot;100.100.101.100/24&lt;/code>&lt;/p>
&lt;h3 id="tag-owners">Tag Owners&lt;/h3>
&lt;p>&lt;code>tagOwners&lt;/code> 定义了哪些用户有权限给设备分配指定的 tag。示例配置：&lt;/p>
&lt;p>&lt;code>tagOwners:   tag:webserver:     - group:engineering   tag:secure-server:     - group:security-admins     - dev1   tag:corp:     - autogroup:members&lt;/code>&lt;/p>
&lt;p>这里表示的是允许 Group &lt;code>group:engineering&lt;/code> 给设备添加 tag &lt;code>tag:webserver&lt;/code>；允许 Group &lt;code>group:security-admins&lt;/code> 和用户（也就是 namespace）dev1 给设备添加 tag &lt;code>tag:secure-server&lt;/code>；允许 Tailscale 网络中的任意成员（设备）给设备添加 tag &lt;code>tag:corp&lt;/code>。&lt;/p>
&lt;p>每个 tag 名称必须以 &lt;code>tag:&lt;/code> 开头，每个 tag 的所有者可以是用户、Group 或者 &lt;code>autogroup:members&lt;/code>。&lt;/p>
&lt;h3 id="auto-approvers">Auto Approvers&lt;/h3>
&lt;p>&lt;code>autoApprovers&lt;/code> 定义了&lt;strong>无需 Headscale 控制端批准即可执行某些操作&lt;/strong>的用户列表，包括宣告特定的子网路由或者 Exit Node。&lt;/p>
&lt;p>当然了，即使可以通过 &lt;code>autoApprovers&lt;/code> 自动批准，Headscale 控制端仍然可以禁用路由或者 Exit Node，但不推荐这种做法，因为控制端只能临时修改，&lt;code>autoApprovers&lt;/code> 中定义的用户列表仍然可以继续宣告路由或 Exit Node，所以正确的做法应该是修改 &lt;code>autoApprovers&lt;/code> 中的用户列表来控制宣告的路由或者 Exit Node。&lt;/p>
&lt;p>autoApprovers 示例配置：&lt;/p>
&lt;p>&lt;code>autoApprovers:   exitNode:     - &amp;quot;default&amp;quot;     - &amp;quot;tag:bar&amp;quot;   routes:     &amp;quot;10.0.0.0/24&amp;quot;:       - &amp;quot;group:engineering&amp;quot;       - &amp;quot;dev1&amp;quot;       - &amp;quot;tag:foo&amp;quot;&lt;/code>&lt;/p>
&lt;p>这里表示允许 &lt;code>default&lt;/code> namespace 中的设备（以及打上标签 &lt;code>tag:bar&lt;/code> 的设备）将自己宣告为 Exit Node；允许 Group &lt;code>group:engineering&lt;/code> 中的设备（以及 dev1 namespace 中的设备和打上标签 &lt;code>tag:foo&lt;/code> 的设备）宣告子网 &lt;code>10.0.0.0/24&lt;/code> 的路由。&lt;/p>
&lt;h2 id="headscale-配置-acl-的方法">Headscale 配置 ACL 的方法&lt;/h2>
&lt;p>要想在 Headscale 中配置 ACL，只需使用 HuJSON 或者 YAML 编写相应的 ACL 规则（HuJSON 格式的文件名后缀为 hujson），然后在 Headscale 的配置文件中引用 ACL 规则文件即可。&lt;/p>
&lt;p>&lt;code># Path to a file containg ACL policies. # ACLs can be defined as YAML or HUJSON. # https://tailscale.com/kb/1018/acls/ acl_policy_path: &amp;quot;./acl.yaml&amp;quot;&lt;/code>&lt;/p>
&lt;h2 id="acl-规则示例">ACL 规则示例&lt;/h2>
&lt;h3 id="允许所有流量">允许所有流量&lt;/h3>
&lt;p>默认的 ACL 规则允许所有访问流量，规则内容如下：&lt;/p>
&lt;p>&lt;code># acl.yaml acls:   - action: accept     src:       - &amp;quot;*&amp;quot;     dst:       - &amp;quot;*:*&amp;quot;&lt;/code>&lt;/p>
&lt;h3 id="允许特定-ns-访问所有流量">允许特定 ns 访问所有流量&lt;/h3>
&lt;p>假设 Headscale 有两个 namesapce：&lt;code>default&lt;/code> 和 &lt;code>guest&lt;/code>。管理员的设备都在 &lt;code>default&lt;/code> namespace 中，访客的设备都在 &lt;code>guest&lt;/code> namespace 中。&lt;/p>
&lt;p>`$ headscale ns ls
ID | Name    | Created
1  | default | 2022-08-20 06:15:17
2  | guest   | 2022-11-27 09:20:25&lt;/p>
&lt;p>$ headscale -n default node ls
ID | Hostname               | Name                            | NodeKey | Namespace | IP addresses | Ephemeral | Last seen           | Online  | Expired
2  | OpenWrt                | openwrt-njprohi0                | [7LdVc] | default   | 10.1.0.2,    | false     | 2022-08-26 04:18:43 | offline | no
5  | tailscale              | tailscale-home                  | [pwlFE] | default   | 10.1.0.5,    | false     | 2022-11-27 10:02:35 | online  | no
10 | k3s-worker05           | share                           | [5Z38M] | default   | 10.1.0.9,    | false     | 2022-11-22 18:49:25 | offline | no
11 | Galaxy a52s            | galaxy-a52s-arg5owsh            | [U+0qY] | default   | 10.1.0.1,    | false     | 2022-11-27 10:02:34 | online  | no&lt;/p>
&lt;p>$ headscale -n guest node ls
ID | Hostname  | Name      | NodeKey | Namespace | IP addresses | Ephemeral | Last seen           | Online | Expired
12 | guest-1 | guest-1 | [75qSK] | guest     | 10.1.0.10,   | false     | 2022-11-27 10:05:33 | online | no
13 | guest-2 | guest-2 | [8lONp] | guest     | 10.1.0.11,   | false     | 2022-11-27 10:05:31 | online | no&lt;/p>
&lt;p>`&lt;/p>
&lt;p>现在我想让 &lt;code>default&lt;/code> namespace 中的设备可以访问所有设备，而 &lt;code>guest&lt;/code> namespace 中的设备只能访问 &lt;code>guest&lt;/code> namespace 中的设备，那么规则应该这么写：&lt;/p>
&lt;p>&lt;code># acl.yaml acls:   - action: accept     src:       - &amp;quot;default&amp;quot;     dst:       - &amp;quot;*:*&amp;quot;       - &amp;quot;guest:*&amp;quot;   - action: accept     src:       - &amp;quot;guest&amp;quot;     dst:       - &amp;quot;guest:*&amp;quot;&lt;/code>&lt;/p>
&lt;p>在 &lt;code>guest-1&lt;/code> 上查看 Tailscale 状态：&lt;/p>
&lt;p>&lt;code>$ tailscale status 10.1.0.10       ks-node-2            guest        linux   -                 desktop-aoulurh-j7dfnsul.default.example.com default      windows offline                 galaxy-a52s-arg5owsh.default.example.com default      android active; relay &amp;quot;hs&amp;quot;, tx 12112 rx 11988                 guest-3            guest        linux   active; direct 172.31.73.176:41641, tx 2552 rx 2440                 openwrt-njprohi0.default.example.com default      linux   offline                 tailscale-home.default.example.com default      linux   active; direct 60.184.243.56:41641, tx 3416 rx 25576&lt;/code>&lt;/p>
&lt;p>看起来 &lt;code>guest-1&lt;/code> 可以看到所有的设备，但事实上它只能 ping 通 &lt;code>guest-2&lt;/code>，我们来验证一下：&lt;/p>
&lt;p>&lt;code>$ ping 10.1.0.1 PING 10.1.0.1 (10.1.0.1) 56(84) bytes of data. ^C --- 10.1.0.1 ping statistics --- 9 packets transmitted, 0 received, 100% packet loss, time 8169ms&lt;/code>&lt;/p>
&lt;p>果然是 ping 不通的。但是 10.1.0.1 这个设备是&lt;strong>可以反向 ping 通&lt;/strong> guest-1 的：&lt;/p>
&lt;p>&lt;code># 在 10.1.0.1 所在的设备操作 $ ping 10.1.0.10 PING 10.1.0.10 (10.1.0.10) 56(84) bytes of data. 64 bytes from 10.1.0.10: icmp_seq=1 ttl=64 time=68.9 ms 64 bytes from 10.1.0.10: icmp_seq=2 ttl=64 time=91.5 ms 64 bytes from 10.1.0.10: icmp_seq=3 ttl=64 time=85.3 ms 64 bytes from 10.1.0.10: icmp_seq=4 ttl=64 time=79.7 ms ^C --- 10.1.0.10 ping statistics --- 4 packets transmitted, 4 received, 0% packet loss, time 3005ms rtt min/avg/max/mdev = 68.967/81.389/91.551/8.306 ms&lt;/code>&lt;/p>
&lt;p>ssh 测试一下：&lt;/p>
&lt;p>&lt;code>$ ssh root@10.1.0.10 root@10.1.0.10's password:&lt;/code>&lt;/p>
&lt;p>完美。&lt;/p>
&lt;p>下面再来看看 &lt;code>guest-1&lt;/code> 能不能 ping 通 &lt;code>guest-2&lt;/code>：&lt;/p>
&lt;p>&lt;code># 在 guest-1 设备上操作 $ ping 10.1.0.11 PING 10.1.0.11 (10.1.0.11) 56(84) bytes of data. 64 bytes from 10.1.0.11: icmp_seq=1 ttl=64 time=2.93 ms 64 bytes from 10.1.0.11: icmp_seq=2 ttl=64 time=1.33 ms ^C --- 10.1.0.11 ping statistics --- 2 packets transmitted, 2 received, 0% packet loss, time 1001ms rtt min/avg/max/mdev = 1.325/2.128/2.931/0.803 ms&lt;/code>&lt;/p>
&lt;p>和我在上面预测的效果一样，ACL 规则生效了。&lt;/p>
&lt;h3 id="神奇的-tag">神奇的 tag&lt;/h3>
&lt;p>tag 有一个非常神奇的功效：它可以让 &lt;code>src&lt;/code> 和 &lt;code>dst&lt;/code> 中的元素失效。具体什么意思呢？&lt;strong>假设你的 src 或 dst 中指定了 namespace 或者 group，那么这个规则只对这个 namespace 或者 group 中（没有分配 tag 的设备）生效。&lt;/strong>&lt;/p>
&lt;p>举个例子你就明白了，现在我给 guest-2 打上一个 tag：&lt;/p>
&lt;p>`$ headscale node tag -i 13 -t tag:test
Machine updated&lt;/p>
&lt;p>$ headscale -n guest node ls -t
ID | Hostname  | Name      | NodeKey | Namespace | IP addresses | Ephemeral | Last seen           | Online | Expired | ForcedTags | InvalidTags | ValidTags
12 | ks-node-2 | ks-node-2 | [75qSK] | guest     | 10.1.0.10,   | false     | 2022-11-27 10:18:35 | online | no      |            |             |
13 | ks-node-3 | ks-node-3 | [8lONp] | guest     | 10.1.0.11,   | false     | 2022-11-27 10:18:31 | online | no      | tag:test   |             |&lt;/p>
&lt;p>`&lt;/p>
&lt;p>此时 guest-1 就 ping 不通 guest-2 了：&lt;/p>
&lt;p>&lt;code># 在 guest-1 设备上操作 $ ping 10.1.0.11 PING 10.1.0.11 (10.1.0.11) 56(84) bytes of data. ^C --- 10.1.0.11 ping statistics --- 4 packets transmitted, 0 received, 100% packet loss, time 3070ms&lt;/code>&lt;/p>
&lt;p>这就说明 guest-2 并不包含在 &lt;code>guest:*&lt;/code> 这个访问目标中，也就是说打了 tag 的设备并不包含在 &lt;code>guest:*&lt;/code> 这个访问目标中。&lt;/p>
&lt;p>此时其他设备如果还想继续 guest-2，必须在 dst 中指定 &lt;code>tag:test&lt;/code>：&lt;/p>
&lt;p>&lt;code>acls:   - action: accept     src:       - &amp;quot;default&amp;quot;     dst:       - &amp;quot;*:*&amp;quot;       - &amp;quot;guest:*&amp;quot;       - &amp;quot;tag:test:*&amp;quot;   - action: accept     src:       - &amp;quot;guest&amp;quot;     dst:       - &amp;quot;guest:*&amp;quot;       - &amp;quot;tag:test:*&amp;quot;&lt;/code>&lt;/p>
&lt;p>再次测试访问：&lt;/p>
&lt;p>&lt;code># 在 guest-1 设备上操作 $ ping 10.1.0.11 PING 10.1.0.11 (10.1.0.11) 56(84) bytes of data. 64 bytes from 10.1.0.11: icmp_seq=1 ttl=64 time=1.31 ms 64 bytes from 10.1.0.11: icmp_seq=2 ttl=64 time=3.40 ms ^C --- 10.1.0.11 ping statistics --- 2 packets transmitted, 2 received, 0% packet loss, time 1002ms rtt min/avg/max/mdev = 1.314/2.355/3.397/1.041 ms&lt;/code>&lt;/p>
&lt;p>果然可以 ping 通了。&lt;/p>
&lt;h2 id="总结">总结&lt;/h2>
&lt;p>Tailscale/Headscale 的 ACL 非常强大，你可以基于 ACL 实现各种各样的访问控制策略，本文只是给出了几个关键示例，帮助大家理解其用法，更多功能大家可以自行探索（比如 group 等）。下篇文章将会给大家介绍如何配置 Headscale 的 Exit Node，以及各个设备如何使用 Exit Node，届时会用到 ACL 里面的 &lt;code>autoApprovers&lt;/code>，敬请期待！&lt;/p>
&lt;h3 id="引用链接">引用链接&lt;/h3>
&lt;p>[1]基于角色的访问控制（RBAC）：演进历史、设计理念及简洁实现: &lt;a href="http://arthurchiao.art/blog/rbac-as-it-meant-to-be-zh/">&lt;em>http://arthurchiao.art/blog/rbac-as-it-meant-to-be-zh/&lt;/em>&lt;/a>
[2]human JSON: &lt;a href="https://github.com/tailscale/hujson">&lt;em>https://github.com/tailscale/hujson&lt;/em>&lt;/a>
&lt;a href="ref">3&lt;/a>: &lt;a href="https://tailscale.com/kb/1018/acls/#groups">&lt;em>https://tailscale.com/kb/1018/acls/#groups&lt;/em>&lt;/a>
&lt;a href="ref">4&lt;/a>: &lt;a href="https://tailscale.com/kb/1019/subnets">&lt;em>https://tailscale.com/kb/1019/subnets&lt;/em>&lt;/a>
&lt;a href="ref">5&lt;/a>: &lt;a href="https://tailscale.com/kb/1018/acls/#hosts">&lt;em>https://tailscale.com/kb/1018/acls/#hosts&lt;/em>&lt;/a>
&lt;a href="ref">6&lt;/a>: &lt;a href="https://tailscale.com/kb/1068/acl-tags">&lt;em>https://tailscale.com/kb/1068/acl-tags&lt;/em>&lt;/a>
[7]IANA IP 协议编号: &lt;a href="https://www.iana.org/assignments/protocol-numbers/protocol-numbers.xhtml">&lt;em>https://www.iana.org/assignments/protocol-numbers/protocol-numbers.xhtml&lt;/em>&lt;/a>
&lt;a href="ref">8&lt;/a>: &lt;a href="https://tailscale.com/kb/1018/acls/#groups">&lt;em>https://tailscale.com/kb/1018/acls/#groups&lt;/em>&lt;/a>
&lt;a href="ref">9&lt;/a>: &lt;a href="https://tailscale.com/kb/1018/acls/#hosts">&lt;em>https://tailscale.com/kb/1018/acls/#hosts&lt;/em>&lt;/a>
&lt;a href="ref">10&lt;/a>: &lt;a href="https://tailscale.com/kb/1019/subnets">&lt;em>https://tailscale.com/kb/1019/subnets&lt;/em>&lt;/a>
&lt;a href="ref">11&lt;/a>: &lt;a href="https://tailscale.com/kb/1068/acl-tags">&lt;em>https://tailscale.com/kb/1068/acl-tags&lt;/em>&lt;/a>
&lt;a href="ref">12&lt;/a>: &lt;a href="https://tailscale.com/kb/1103/exit-nodes">&lt;em>https://tailscale.com/kb/1103/exit-nodes&lt;/em>&lt;/a>&lt;/p></description></item><item><title>Docs: TCP</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/4.%E6%95%B0%E6%8D%AE%E9%80%9A%E4%BF%A1/%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/3_4.tcp_ip/tcp/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/4.%E6%95%B0%E6%8D%AE%E9%80%9A%E4%BF%A1/%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/3_4.tcp_ip/tcp/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://datatracker.ietf.org/doc/html/rfc675">RFC,675&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://datatracker.ietf.org/doc/html/rfc793">RFC,793&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Transmission_Control_Protocol">Wiki,TCP&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://time.geekbang.org/column/intro/100007101">极客时间,趣谈网络协议&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.jianshu.com/p/1118f497a425">https://www.jianshu.com/p/1118f497a425&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.jianshu.com/p/3c7a0771b67e">https://www.jianshu.com/p/3c7a0771b67e&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://mp.weixin.qq.com/s/WG1Is0HMAHYMgRvJQpd3KA">通过动图学习 TCP 的滑动窗口和流量控制的工作方式&lt;/a>
&lt;ul>
&lt;li>&lt;a href="https://www2.tkn.tu-berlin.de/teaching/rn/animations/gbn_sr/">https://www2.tkn.tu-berlin.de/teaching/rn/animations/gbn_sr/&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www2.tkn.tu-berlin.de/teaching/rn/animations/flow/">https://www2.tkn.tu-berlin.de/teaching/rn/animations/flow/&lt;/a>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>&lt;strong>Transmission Control Protocol(传输控制协议，简称 TCP)&lt;/strong> 是&lt;a href="https://en.wikipedia.org/wiki/Internet_protocol_suite">互联网协议套件&lt;/a>的最主要协议之一。它起源于最初的网络实现，补充了 Internet Protocol。因此整个套件通常称为 &lt;strong>TCP/IP&lt;/strong>。&lt;/p>
&lt;p>IP 地址后面的端口的作用：当从外部访问该 IP 地址的机器时候，是通过该 IP 地址的端口来访问这台机器的某个程序，然后程序向访问者提供该程序所具有的功能（服务）。web 界面默认是 80 端口，那么当你访问一个网页的时候，这个 IP 就会带你访问该机器的占用 80 端口的程序，然后该程序去调用首页脚本本间展示给访问者&lt;/p>
&lt;p>例如：你通过远程 SSH 访问一台设备 192.168.0.1 的话，那么需要设置一下这台机器 SSH 服务程序所占用的端口号，比如 22，那么你就是通过 192.168.0.1:22 这个来访问这台机器的 SSH 进程。&lt;/p>
&lt;p>上面的描述，就是一个基本的 TCP。&lt;/p>
&lt;p>TCP 天然认为网络环境是恶劣的，丢包、乱序、重传，拥塞都是常有的事情，一言不合就可能送达不了，因而要从算法层面来保证可靠性。TCP 是靠谱的协议，但是这不能说明它面临的网络环境好。从 IP 层面来讲，如果网络状况的确那么差，是没有任何可靠性保证的，而作为 IP 的上一层 TCP 也无能为力，唯一能做的就是更加努力，不断重传，通过各种算法保证。也就是说，对于 TCP 来讲，IP 层你丢不丢包，我管不着，但是我在我的层面上，会努力保证可靠性。这有点像如果你在北京，和客户约十点见面，那么你应该清楚堵车是常态，你干预不了，也控制不了，你唯一能做的就是早走。打车不行就改乘地铁，尽力不失约。&lt;/p>
&lt;h2 id="总结">总结&lt;/h2>
&lt;p>通过对 TCP 头的解析，我们知道要掌握 TCP 协议，重点应该关注以下几个问题：&lt;/p>
&lt;ul>
&lt;li>顺序问题 ，稳重不乱；&lt;/li>
&lt;li>丢包问题，承诺靠谱；&lt;/li>
&lt;li>连接维护，有始有终；&lt;/li>
&lt;li>流量控制，把握分寸；&lt;/li>
&lt;li>拥塞控制，知进知退。&lt;/li>
&lt;/ul>
&lt;h1 id="tcp-segment-结构">TCP Segment 结构&lt;/h1>
&lt;p>TCP 段被封装在 IP 数据报中
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/tvcktp/1628820358483-a9e565df-371d-4e47-b0d0-0f1fb6077945.png" alt="image.png">
首部长度：一般为 20 字节，选项最多 40 字节，限制 60 字节。下图中的位，即代表 bit，也就是说，首部一共 160 bit，即 20 Byte。
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/tvcktp/1629791940018-704af85e-5ccf-4ded-90b4-a824d60c3726.jpeg" alt="">
对照在 WireShark 中展示的内容看，排除 &lt;code>[]&lt;/code> 中的内容，WireShark 中展示的一个 SYN TCP 段的内容，每一行就是包头中的一个内容
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/tvcktp/1628819589583-6eb31754-8352-45b6-b4b9-b7a61d26433e.png" alt="image.png">&lt;/p>
&lt;ul>
&lt;li>&lt;strong>Source Port(源端口号)&lt;/strong> #&lt;/li>
&lt;li>**Destination Port(目的端口号) **#
&lt;ul>
&lt;li>每个 TCP 报文段都包含源和目的的端口号，这两个端口号用于寻找发送端与接收端的应用进程。这两个值加上 IP 首部中的源和目的的 IP 地址，&lt;strong>组成 TCP 四元组，用于确定唯一一个 TCP 连接&lt;/strong>。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>Sequence Number(序号，简称 SeqNum)&lt;/strong> # TCP 报文段的唯一标识符，该标识符具有先后顺序。如果不为每一个包编号，则没法确认哪个包先来哪个包后来。
&lt;ul>
&lt;li>&lt;strong>SeqNum 用来解决网络包乱序的问题。&lt;/strong>&lt;/li>
&lt;li>&lt;strong>Initial Sequence Number(初始序号，简称 ISN)&lt;/strong> # TCP 交互的两端，有一个初始的 SeqNum，就是 A 发送给 B 或者 B 发送给 A 的第一个 TCP 段，这第一个 TCP 段的 SeqNum 就是 ISN。&lt;/li>
&lt;li>注意：TCP 为应用层提供全双工服务，这意味着数据能在两个方向上独立进行传输。因此，一个 TCP 连接的两端都会有自己独立的 SeqNum。所以首次建立连接时客户端和服务端都会生成一个 ISN。ISN 是一个随机生成的数。&lt;/li>
&lt;li>SeqNum 最大值为 232-1，到达最大值后，回到 0 开始。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>**Acknowledgment Number(确认序号，简称 AckNum) **# 下一次期望收到数据中报文段的 SeqNum。发出去的包应该有确认，要不然怎么知道对方有没有收到呢？如果没有收到就应该重新发送，直到送达。
&lt;ul>
&lt;li>&lt;strong>AckNum 用来解决不丢包的问题&lt;/strong>。&lt;/li>
&lt;li>AckNum 可以用来确认上次发送的数据大小。
&lt;ul>
&lt;li>假如 172.19.42.244 向 172.19.42.248 发送了一个 PSH,ACK 的报文段，其中 SeqNum=x1,AckNum=y1，发送了 90Bytes 的数据，&lt;/li>
&lt;li>那么 172.19.42.248 向 172.19.42.244 就会发送一个 ACK 的报文段，其中 SeqNum=x2,AckNum=x1+90&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>Header Length(首部长度)&lt;/strong> #&lt;/li>
&lt;li>&lt;strong>Flag — TCP 标志&lt;/strong> # 用来定义当前 TCP 报文段的类型。&lt;/li>
&lt;li>&lt;strong>Window size value(窗口大小)&lt;/strong> # TCP 流量控制。通信双方各声明一个窗口，标识自己当前能够的处理能力，别发送的太快，撑死我，也别发的太慢，饿死我。&lt;/li>
&lt;li>&lt;strong>Chceksum(校验和)&lt;/strong> #&lt;/li>
&lt;li>&lt;strong>Urgent pointer(紧急指针)&lt;/strong> #&lt;/li>
&lt;li>&lt;strong>Options(选项)&lt;/strong> # 告诉对方本次传输的一些限制。比如 MSS、SACK 等等&lt;/li>
&lt;li>&lt;strong>TCP Payload(数据)&lt;/strong> # 这个字段需要在 HTTP 包中才可以看到，TCP 的有效载荷就是当前传输的数据&lt;/li>
&lt;/ul>
&lt;h2 id="seqnum-与-acknum-的计算">SeqNum 与 AckNum 的计算&lt;/h2>
&lt;p>由于 TCP 的全双工机制，所以 TCP 交互的两端都有独立的 SeqNum，其两端的 SeqNum 互相之间没有绝对的关联关系，只有一端的 SeqNum 与对端的 AckNum 有关系。&lt;/p>
&lt;p>现在假设有 A 和 B 两个系统想要建立 TCP 连接并进行数据交互,并且通信环境正常可以正常建立连接，且以数字表示 A 发送给 B 或者 B 发送给 A 的第几号数据包。&lt;/p>
&lt;p>那么：&lt;/p>
&lt;ul>
&lt;li>A 发送给 B 的第 N 号 TCP 段中 SeqNum 的值等于 &lt;code>A 的 N-1 号 TCP 段中发送的数据大小(Bytes)&lt;/code> 与 &lt;code>A 的 N-1 号 TCP 段的 SeqNum&lt;/code> 之和。即：
&lt;ul>
&lt;li>&lt;code>A_N_SeqNum = A_ISN + A_N-1_TCPPlayload + A_N-1_SeqNum&lt;/code>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>B 响应给 A 的第 N 号 TCP 段中 AckNum 的值等于&lt;code> A 的 N 号 TCP 段中发送的数据大小(Bytes)&lt;/code> 与 &lt;code> A 的 N 号 TCP 段中的 SeqNum&lt;/code> 之和。即：
&lt;ul>
&lt;li>&lt;code>B_N_AckNum = A_N_TCPPlayload + A_N_SeqNum&lt;/code>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>反之亦然：&lt;/p>
&lt;ul>
&lt;li>&lt;code>A_N_AckNum = B_N_TCPPlayload + B_N_SeqNum&lt;/code>&lt;/li>
&lt;li>&lt;code>B_N_SeqNum = B_ISN + B_N-1_TCPPlayload + B_N-1_SeqNum&lt;/code>&lt;/li>
&lt;/ul>
&lt;h2 id="tcp-flag">TCP Flag&lt;/h2>
&lt;p>TCP 报文段的标志内容，将会包含所有标志通过设置标志的值来启用或禁用这些标志(1 表示设置(即.启用)，0 表示未设置(即.禁用))。一个 TCP 报文段中，可以同时启用多个 TCP 标志。下图就是一个 TCP 三次握手中，第二次交互的 TCP 标志内容。
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/tvcktp/1628827678903-275e8388-c654-4656-b321-d5d501ff2803.png" alt="image.png">
当前可用的 TCP 标志有如下几个：&lt;/p>
&lt;ul>
&lt;li>&lt;strong>ACK(Acknowledgement)&lt;/strong> # 确认、响应
&lt;ul>
&lt;li>除了第一个 SYN 报文段意外，其余报文段都要启用 ACK。因为除了建立连接时，发送的第一个报文段，其余所有的报文段都需要响应发送给自己的报文段，用来表示已收到消息。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>CWR&lt;/strong> # 拥塞窗口减少&lt;/li>
&lt;li>&lt;strong>ECE&lt;/strong> # 显式拥塞提醒回应&lt;/li>
&lt;li>&lt;strong>FIN&lt;/strong> # 终止、关闭连接
&lt;ul>
&lt;li>用于释放连接，表示此报文段的发送方数据已发送完毕并要求释放连接&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>PSH(Push&lt;/strong>) # 推送、数据传输
&lt;ul>
&lt;li>当应用程序双方进行交互式通信时，若一端希望在键入命令后就能收到对方响应。此时可采用推送操作。发送方将会立即创建一个报文段并发送出去，接收方接收到 PSH=1 的报文段会进快递交付，而不会等到整个缓存都填满后在向上交付。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>RST&lt;/strong> # 复位、连接重置。
&lt;ul>
&lt;li>表示连接中出现严重错误必须释放连接再重新建立传输连接，也可用来拒绝一个非法报文段或拒绝打开一个连接。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>**SYN(Synchronize) **# 同步、建立连接
&lt;ul>
&lt;li>SYN 是 TCP/IP 建立连接时使用的握手信号，SYN 仅在三次握手建立 TCP 连接时有效。&lt;/li>
&lt;li>客户端和服务端建立连接时，客户端首先会发出一个 SYN 报文段用来建立连接，服务端使用 SYN+ACK 应答表示接收到该消息，最后客户端再以 ACK 消息进行响应。&lt;/li>
&lt;li>SYN 用于请求和建立连接，也可用于设备间的 SEQ 序列号同步，SYN=1 表示是一个连接请求或连接接收的报文段，当 SYN=1 且 ACK=0 表示连接请求报文段，若对方同意则响应 SYN=1 且 ACK=1。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>URG&lt;/strong> # 紧急
&lt;ul>
&lt;li>表示报文段中有紧急数据应尽快发送，不要按原来的排队顺序来传送。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h1 id="tcp-状态">TCP 状态&lt;/h1>
&lt;p>一个 TCP 连接在它的声明周期内会有不同的状态。下图说明了 TCP 连接可能会有的状态，以及基于事件的状态转换。事件中有的是应用程序的操作，有的是接收到了网络发过来的请求。
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/tvcktp/1628824939321-772e1691-86d4-4ca9-b65c-7a3db704ff9b.png" alt="image.png">&lt;/p>
&lt;ul>
&lt;li>LISTEN # 服务端。等待来自远程的 TCP 请求&lt;/li>
&lt;li>SYN-SENT # TCP 第一次握手后客户端所处的状态。发送连接请求后，等待来自服务端的确认。
&lt;ul>
&lt;li>TCP 默认 SYN 报文最大 retry 5 次，每次超时了翻倍，1s -&amp;gt; 3s -&amp;gt; 7s -&amp;gt; 15s -&amp;gt; 31s -&amp;gt; 63s。&lt;a href="https://blog.csdn.net/u010039418/article/details/78234570">参考资料&lt;/a>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>SYN-RECEIVED # TCP 第二次握手后服务端所处的状态。服务端已经接收到连接请求并发送确认。服务端正在等待最终确认。&lt;/li>
&lt;li>ESTABLISHED # TCP 第三次握手后服务端与客户端所处的状态。代表连接已经建立起来了。这是连接数据传输阶段的正常状态。&lt;/li>
&lt;li>FIN-WAIT-1 # 等待来自远程 TCP 的终止连接请求或终止请求的确认&lt;/li>
&lt;li>FIN-WAIT-2 # 在此端点发送终止连接请求后，等待来自远程 TCP 的连接终止请求&lt;/li>
&lt;li>CLOSE_WAIT # 该端点已经收到来自远程端点的关闭请求，此 TCP 正在等待本地应用程序的连接终止请求&lt;/li>
&lt;li>CLOSING # 等待来自远程 TCP 的连接终止请求确认&lt;/li>
&lt;li>LAST_ACK # 等待先前发送到远程 TCP 的连接终止请求的确认&lt;/li>
&lt;li>TIME-WAIT # 主动断开连接一方的状态。等待足够的时间来确保远程 TCP 接收到其连接终止请求的确认
&lt;ul>
&lt;li>TCP 主动关闭连接的一方在发送最后一个 ACK 后进入  &lt;code>TIME_AWAIT&lt;/code>  状态，再等待 2 个 MSL 时间后才会关闭(因为如果 server 没收到 client 第四次挥手确认报文，server 会重发第三次挥手 FIN 报文，所以 client 需要停留 2 MSL 的时长来处理可能会重复收到的报文段；同时等待 2 MSL 也可以让由于网络不通畅产生的滞留报文失效，避免新建立的连接收到之前旧连接的报文)，了解更详细的过程请参考 TCP 四次挥手。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h1 id="tcp-行为的过程">TCP 行为的过程&lt;/h1>
&lt;h2 id="tcp-三次握手">TCP 三次握手&lt;/h2>
&lt;p>参考：&lt;a href="https://hit-alibaba.github.io/interview/basic/network/TCP.html">https://hit-alibaba.github.io/interview/basic/network/TCP.html&lt;/a>
三次握手的过程的示意图如下：
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/tvcktp/1628831488474-13bf079c-3419-4f9d-b92d-ca1620d7b6a7.png" alt="image.png">
所谓三次握手(Three-way Handshake)，是指建立一个 TCP 连接时，需要客户端和服务器总共发送 3 个包。三次握手的目的是连接服务器指定端口，建立 TCP 连接，并同步连接双方的序列号和确认号，交换 TCP 窗口大小信息。&lt;/p>
&lt;p>在 socket 编程中，客户端执行 connect() 时。将触发三次握手：&lt;/p>
&lt;ul>
&lt;li>&lt;strong>第一次握手(SYN，SeqNum=client_isn)&lt;/strong> # 客户端请求同步，发送 SYN 报文段
&lt;ul>
&lt;li>客户端生成一个随机数 client_isn&lt;/li>
&lt;li>设置 TCP 首部字段
&lt;ul>
&lt;li>将 client_isn 填入到 Sequence Number 字段中。&lt;/li>
&lt;li>将 TCP 标志中 SYN 的值设为 1。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>发送完毕后，客户端进入 SYN_SEND 状态。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>第二次握手(SYN,ACK，SeqNum=server_isn，AckNum=client_isn+1)&lt;/strong> # 服务端回应并请求同步，发送 SYN + ACK 报文段
&lt;ul>
&lt;li>服务端收到客户端的 SYN 报文段后，生成一个随机数 server_isn&lt;/li>
&lt;li>设置 TCP 首部字段
&lt;ul>
&lt;li>将 server_isn 填入 Sequence Number 字段中&lt;/li>
&lt;li>将 client_isn+1 填入 Acknowledgement Number 字段中。&lt;/li>
&lt;li>将 TCP 标志中的 SYN 和 ACK 的值设为 1。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>发送完毕后，服务器端进入 SYN_RCVD 状态。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>第三次握手(ACK，SeqNum=client_isn+1，AckNum=server_isn+1)&lt;/strong> # 客户端回应确认，建立连接。发送 ACK 报文段
&lt;ul>
&lt;li>客户端收到服务端报文后，还需要向服务端回应最后一个 ACK 报文段&lt;/li>
&lt;li>设置 TCP 首部字段
&lt;ul>
&lt;li>将 server_isn+1 填入 Acknowledgement Number 字段中。&lt;/li>
&lt;li>将 TCP 标志中的 ACK 的值设为 1。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>发送完毕后，客户端进入 ESTABLISHED 状态，当服务器端接收到这个包时，也进入 ESTABLISHED 状态，TCP 握手结束。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>注意：&lt;/p>
&lt;ul>
&lt;li>第三次握手时，此时客户端已经处于 ESTABLISHED 状态。对于客户端来说，他已经建立起连接了，并且已经知道服务器的接收和发送能力是正常的。所以也就可以携带数据了。&lt;/li>
&lt;li>但是第一次握手是不可以带数据发送给服务端的，因为还不知道对方的窗口大小，并且也容易让客户端发起大量数据进行攻击。&lt;/li>
&lt;/ul>
&lt;h2 id="tcp-四次挥手">TCP 四次挥手&lt;/h2>
&lt;p>四次挥手的示意图如下：
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/tvcktp/1616161421390-7655ce0e-3e07-436c-93b1-708b3389996d.jpeg" alt="">
TCP 的连接的拆除需要发送四个包，因此称为四次挥手(Four-way handshake)，也叫做改进的三次握手。客户端或服务器均可主动发起挥手动作，在 socket 编程中，任何一方执行 close() 操作即可产生挥手操作。&lt;/p>
&lt;p>第一次挥手(FIN=1，seq=x)&lt;/p>
&lt;ul>
&lt;li>假设客户端想要关闭连接，客户端发送一个 FIN 标志位置为 1 的包，表示自己已经没有数据可以发送了，但是仍然可以接受数据。&lt;/li>
&lt;li>发送完毕后，客户端进入 FIN_WAIT_1 状态。&lt;/li>
&lt;/ul>
&lt;p>第二次挥手(ACK=1，ACKnum=x+1)&lt;/p>
&lt;ul>
&lt;li>服务器端确认客户端的 FIN 包，发送一个确认包，表明自己接受到了客户端关闭连接的请求，但还没有准备好关闭连接。&lt;/li>
&lt;li>发送完毕后，服务器端进入 CLOSE_WAIT 状态，客户端接收到这个确认包之后，进入 FIN_WAIT_2 状态，等待服务器端关闭连接。&lt;/li>
&lt;/ul>
&lt;p>第三次挥手(FIN=1，seq=y)&lt;/p>
&lt;ul>
&lt;li>服务器端准备好关闭连接时，向客户端发送结束连接请求，FIN 置为 1。&lt;/li>
&lt;li>发送完毕后，服务器端进入 LAST_ACK 状态，等待来自客户端的最后一个 ACK。&lt;/li>
&lt;/ul>
&lt;p>第四次挥手(ACK=1，ACKnum=y+1)&lt;/p>
&lt;ul>
&lt;li>客户端接收到来自服务器端的关闭请求，发送一个确认包，并进入 TIME_WAIT 状态，等待可能出现的要求重传的 ACK 包。&lt;/li>
&lt;li>服务器端接收到这个确认包之后，关闭连接，进入 CLOSED 状态。&lt;/li>
&lt;li>客户端等待了某个固定时间（两个最大段生命周期，2MSL，2 Maximum Segment Lifetime）之后，没有收到服务器端的 ACK ，认为服务器端已经正常关闭连接，于是自己也关闭连接，进入 CLOSED 状态。&lt;/li>
&lt;/ul>
&lt;h2 id="数据传输">数据传输&lt;/h2>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/tvcktp/1628842098522-1dc9dcc9-026c-4e88-a288-cd0e73613e77.png" alt="image.png">
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/tvcktp/1628841642687-befcb683-4d7e-41b2-849d-14b028d2a170.png" alt="image.png">&lt;/p></description></item><item><title>Docs: TCP 异常处理</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/4.%E6%95%B0%E6%8D%AE%E9%80%9A%E4%BF%A1/%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/3_4.tcp_ip/tcp-%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/4.%E6%95%B0%E6%8D%AE%E9%80%9A%E4%BF%A1/%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/3_4.tcp_ip/tcp-%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/</guid><description>
&lt;h1 id="tcp-rst">TCP RST&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://www.cnblogs.com/JohnABC/p/6323046.html">博客园-John_ABC，Linux-TCG 出现 RST 的几种情况&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://segmentfault.com/a/1190000038463522">https://segmentfault.com/a/1190000038463522&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>TCP RST 引起的常见报错：&lt;/p>
&lt;ul>
&lt;li>Connection reset&lt;/li>
&lt;li>Connection reset by peer&lt;/li>
&lt;/ul>
&lt;p>TCP 连接和释放时还有许多细节，比如半连接状态、半关闭状态等。详情请参考这方面的巨著《TCP/IP 详解》和《UNIX 网络编程》。
前面说到出现“Connection reset”的原因是服务器关闭了 Connection[调用了 Socket.close()方法]。大家可能有疑问了：服务器关闭了 Connection 为什么会返回“RST”而不是返回“FIN”标志。原因在于 Socket.close()方法的语义和 TCP 的“FIN”标志语义不一样：发送 TCP 的“FIN”标志表示我不再发送数据了，而 Socket.close()表示我不在发送也不接受数据了。问题就出在“我不接受数据” 上，如果此时客户端还往服务器发送数据，服务器内核接收到数据，但是发现此时 Socket 已经 close 了，则会返回“RST”标志给客户端。当然，此时客户端就会提示：“Connection reset”。详细说明可以参考 oracle 的有关文档：http://docs.oracle.com/javase/1.5.0/docs/guide/net/articles/connection_release.html。
另一个可能导致的“Connection reset”的原因是服务器设置了 Socket.setLinger (true, 0)。但我检查过线上的 tomcat 配置，是没有使用该设置的，而且线上的服务器都使用了 nginx 进行反向代理，所以并不是该原因导致的。关于该原因上面的 oracle 文档也谈到了并给出了解释。
此外啰嗦一下，另外还有一种比较常见的错误“Connection reset by peer”，该错误和“Connection reset”是有区别的：
服务器返回了“RST”时，如果此时客户端正在从 Socket 套接字的输出流中读数据则会提示 Connection reset”；
服务器返回了“RST”时，如果此时客户端正在往 Socket 套接字的输入流中写数据则会提示“Connection reset by peer”。
“Connection reset by peer”如下图所示：&lt;/p>
&lt;p>前面谈到了导致“Connection reset”的原因，而具体的解决方案有如下几种：
出错了重试；
客户端和服务器统一使用 TCP 长连接；
客户端和服务器统一使用 TCP 短连接。
首先是出错了重试：这种方案可以简单防止“Connection reset”错误，然后如果服务不是“幂等”的则不能使用该方法；比如提交订单操作就不是幂等的，如果使用重试则可能造成重复提单。
然后是客户端和服务器统一使用 TCP 长连接：客户端使用 TCP 长连接很容易配置（直接设置 HttpClient 就好），而服务器配置长连接就比较麻烦了，就拿 tomcat 来说，需要设置 tomcat 的 maxKeepAliveRequests、connectionTimeout 等参数。另外如果使用了 nginx 进行反向代理或负载均衡，此时也需要配置 nginx 以支持长连接（nginx 默认是对客户端使用长连接，对服务器使用短连接）。
使用长连接可以避免每次建立 TCP 连接的三次握手而节约一定的时间，但是我这边由于是内网，客户端和服务器的 3 次握手很快，大约只需 1ms。ping 一下大约 0.93ms（一次往返）；三次握手也是一次往返（第三次握手不用返回）。根据 80/20 原理，1ms 可以忽略不计；又考虑到长连接的扩展性不如短连接好、修改 nginx 和 tomcat 的配置代价很大（所有后台服务都需要修改）；所以这里并没有使用长连接。&lt;/p>
&lt;p>正常情况 tcp 四层握手关闭连接，rst 基本都是异常情况，整理如下： 0.使用 ping 可以看到丢包情况
1. GFW
2. 对方端口未打开，发生在连接建立
如果对方 sync_backlog 满了的话，sync 简单被丢弃，表现为超时，而不会 rst
3. close Socket 时 recv buffer 不为空
例如，客户端发了两个请求，服务器只从 buffer 读取第一个请求处理完就关闭连接，tcp 层认为数据没有正确提交到应用，使用 rst 关闭连接。
3. 移动链路
移动网络下，国内是有 5 分钟后就回收信令，也就是 IM 产品，如果心跳&amp;gt;5 分钟后服务器再给客户端发消息，就会收到 rst。也要查移动网络下 IM 保持&amp;lt;5min 心跳。
4. 负载等设备
负载设备需要维护连接转发策略，长时间无流量，连接也会被清除，而且很多都不告诉两层机器，新的包过来时才通告 rst。
Apple push 服务也有这个问题，而且是不可预期的偶发性连接被 rst；rst 前第一个消息 write 是成功的，而第二条写才会告诉你连接被重置，
曾经被它折腾没辙，因此打开每 2 秒一次 tcp keepalive，固定 5 分钟 tcp 连接回收，而且发现连接出错时，重发之前 10s 内消息。
5. SO_LINGER 应用强制使用 rst 关闭
该选项会直接丢弃未发送完毕的 send buffer，可能造成业务错误，慎用； 当然内网服务间 http client 在收到应该时主动关闭，使用改选项，会节省资源。
好像曾经测试过 haproxy 某种配置下，会使用 rst 关闭连接，少了网络交互而且没有 TIME_WAIT 问题
6. 超过超时重传次数、网络暂时不可达
7. TIME_WAIT 状态
tw_recycle = 1 时，sync timestamps 比上次小时，会被 rst
7. 设置 connect_timeout
应用设置了连接超时，sync 未完成时超时了，会发送 rst 终止连接。
8. 非正常包
连接已经关闭，seq 不正确等
9. keepalive 超时
公网服务 tcp keepalive 最好别打开；移动网络下会增加网络负担，切容易掉线；非移动网络核心 ISP 设备也不一定都支持 keepalive，曾经也发现过广州那边有个核心节点就不支持。
10. 数据错误，不是按照既定序列号发送数据 11.在一个已关闭的 socket 上接收数据 12.服务器关闭或异常终止了连接，由于网络问题，客户端没有收到服务器的关闭请求，这称为 TCP 半打开连接。就算重启服务器，也没有连接信息。如果客户端向提其写入数据，对方就会回应一个 RST 报文段。&lt;/p>
&lt;h1 id="三次握手与四次挥手异常处理">三次握手与四次挥手异常处理&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>原文链接：&lt;a href="https://mp.weixin.qq.com/s/CTqag_TxAHLuUwLvbrmlnw">公众号-小林 coding，TCP 才不傻！&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>大家好，我是小林。&lt;/p>
&lt;p>之前收到个读者的问题，对于 TCP 三次握手和四次挥手的一些疑问：&lt;/p>
&lt;ul>
&lt;li>第一次握手，如果客户端发送的 SYN 一直都传不到被服务器，那么客户端是一直重发 SYN 到永久吗？客户端停止重发 SYN 的时机是什么？&lt;/li>
&lt;li>第三次握手，如果服务器永远不会收到 ACK，服务器就永远都留在 Syn-Recv 状态了吗？退出此状态的时机是什么？&lt;/li>
&lt;li>第三次挥手，如果客户端永远收不到 FIN,ACK，客户端永远停留在 Fin-Wait-2 状态了吗？退出此状态时机是什么时候呢？&lt;/li>
&lt;li>第四次挥手，如果服务器永远收不到 ACK，服务器永远停留在 Last-Ack 状态了吗？退出此状态的时机是什么呢？&lt;/li>
&lt;li>如果客户端 在 2SML 内依旧没收到 FIN,ACK，会关闭链接吗？服务器那边怎么办呢，是怎么关闭链接的呢？&lt;/li>
&lt;/ul>
&lt;p>可以看到，这些问题都是关于 &lt;strong>TCP 是如何处理这些异常场景&lt;/strong>的，我们在学 TCP 连接建立和断开的时候，总是以为这些过程能如期完成。&lt;/p>
&lt;p>&lt;strong>可惜理想很丰满，现实很骨感，事实预料呀&lt;/strong>。&lt;/p>
&lt;p>&lt;strong>TCP 当然不傻&lt;/strong>，对以上这些异常场景都是有做处理的。&lt;/p>
&lt;p>这些内容在我的「图解网络 PDF」 也有说过。&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/24e305c7-9ba8-4113-9be1-44404948d366/640" alt="">&lt;/p>
&lt;p>当时也用做实验的方式带大家看 TCP 是如何处理这些异常场景的。&lt;/p>
&lt;blockquote>
&lt;p>如果新读者还不知道小林的图解网络 PDF，可以到我公众号后台回复「图解」获取就行。&lt;/p>
&lt;/blockquote>
&lt;p>不过，当时这些知识分散到了多个章节，这次就针对读者问的这一系列问题，来详细说说 TCP 是怎么处理这些异常的？&lt;/p>
&lt;p>这些异常场景共分为两大类，第一类是 TCP 三次握手期间的异常，第二类是 TCP 四次挥手期间的异常。&lt;/p>
&lt;h3 id="tcp-三次握手期间的异常">TCP 三次握手期间的异常&lt;/h3>
&lt;p>我们先来看看 TCP 三次握手是怎样的。&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/24e305c7-9ba8-4113-9be1-44404948d366/640" alt="">&lt;/p>
&lt;h4 id="第一次握手丢失了会发生什么">第一次握手丢失了，会发生什么？&lt;/h4>
&lt;p>当客户端想和服务端建立 TCP 连接的时候，首先第一个发的就是 SYN 报文，然后进入到 &lt;code>SYN_SENT&lt;/code> 状态。&lt;/p>
&lt;p>在这之后，如果客户端迟迟收不到服务端的 SYN-ACK 报文（第二次握手），就会触发超时重传机制。&lt;/p>
&lt;p>不同版本的操作系统可能超时时间不同，有的 1 秒的，也有 3 秒的，这个超时时间是写死在内核里的，如果想要更改则需要重新编译内核，比较麻烦。&lt;/p>
&lt;p>当客户端在 1 秒后没收到服务端的 SYN-ACK 报文后，客户端就会重发 SYN 报文，那到底重发几次呢？&lt;/p>
&lt;p>在 Linux 里，客户端的 SYN 报文最大重传次数由 &lt;code>tcp_syn_retries&lt;/code>内核参数控制，这个参数是可以自定义的，默认值一般是 5。&lt;/p>
&lt;p>通常，第一次超时重传是在 1 秒后，第二次超时重传是在 2 秒，第三次超时重传是在 4 秒后，第四次超时重传是在 8 秒后，第五次是在超时重传 16 秒后。没错，&lt;strong>每次超时的时间是上一次的 2 倍&lt;/strong>。&lt;/p>
&lt;p>当第五次超时重传后，会继续等待 32 秒，如果服务端仍然没有回应 ACK，客户端就不再发送 SYN 包，然后断开 TCP 连接。&lt;/p>
&lt;p>所以，总耗时是 1+2+4+8+16+32=63 秒，大约 1 分钟左右。&lt;/p>
&lt;h4 id="第二次握手丢失了会发生什么">第二次握手丢失了，会发生什么？&lt;/h4>
&lt;p>当服务端收到客户端的第一次握手后，就会回 SYN-ACK 报文给客户端，这个就是第二次握手，此时服务端会进入 &lt;code>SYN_RCVD&lt;/code> 状态。&lt;/p>
&lt;p>第二次握手的 &lt;code>SYN-ACK&lt;/code> 报文其实有两个目的 ：&lt;/p>
&lt;ul>
&lt;li>第二次握手里的 ACK， 是对第一次握手的确认报文；&lt;/li>
&lt;li>第二次握手里的 SYN，是服务端发起建立 TCP 连接的报文；&lt;/li>
&lt;/ul>
&lt;p>所以，如果第二次握手丢了，就会发送比较有意思的事情，具体会怎么样呢？&lt;/p>
&lt;p>因为第二次握手报文里是包含对客户端的第一次握手的 ACK 确认报文，所以，如果客户端迟迟没有收到第二次握手，那么客户端就觉得可能自己的 SYN 报文（第一次握手）丢失了，于是&lt;strong>客户端就会触发超时重传机制，重传 SYN 报文&lt;/strong>。&lt;/p>
&lt;p>然后，因为第二次握手中包含服务端的 SYN 报文，所以当客户端收到后，需要给服务端发送 ACK 确认报文（第三次握手），服务端才会认为该 SYN 报文被客户端收到了。&lt;/p>
&lt;p>那么，如果第二次握手丢失了，服务端就收不到第三次握手，于是&lt;strong>服务端这边会触发超时重传机制，重传 SYN-ACK 报文&lt;/strong>。&lt;/p>
&lt;p>在 Linux 下，SYN-ACK 报文的最大重传次数由 &lt;code>tcp_synack_retries&lt;/code>内核参数决定，默认值是 5。&lt;/p>
&lt;p>因此，当第二次握手丢失了，客户端和服务端都会重传：&lt;/p>
&lt;ul>
&lt;li>客户端会重传 SYN 报文，也就是第一次握手，最大重传次数由 &lt;code>tcp_syn_retries&lt;/code>内核参数决定。；&lt;/li>
&lt;li>服务端会重传 SYN-AKC 报文，也就是第二次握手，最大重传次数由 &lt;code>tcp_synack_retries&lt;/code>   内核参数决定。&lt;/li>
&lt;/ul>
&lt;h4 id="第三次握手丢失了会发生什么">第三次握手丢失了，会发生什么？&lt;/h4>
&lt;p>客户端收到服务端的 SYN-ACK 报文后，就会给服务端回一个 ACK 报文，也就是第三次握手，此时客户端状态进入到 &lt;code>ESTABLISH&lt;/code> 状态。&lt;/p>
&lt;p>因为这个第三次握手的 ACK 是对第二次握手的 SYN 的确认报文，所以当第三次握手丢失了，如果服务端那一方迟迟收不到这个确认报文，就会触发超时重传机制，重传 SYN-ACK 报文，直到收到第三次握手，或者达到最大重传次数。&lt;/p>
&lt;p>注意，&lt;strong>ACK 报文是不会有重传的，当 ACK 丢失了，就由对方重传对应的报文&lt;/strong>。&lt;/p>
&lt;h3 id="tcp-四次挥手期间的异常">TCP 四次挥手期间的异常&lt;/h3>
&lt;p>我们再来看看 TCP 四次挥手的过程。&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/24e305c7-9ba8-4113-9be1-44404948d366/640" alt="">&lt;/p>
&lt;h4 id="第一次挥手丢失了会发生什么">第一次挥手丢失了，会发生什么？&lt;/h4>
&lt;p>当客户端（主动关闭方）调用 close 函数后，就会向服务端发送 FIN 报文，试图与服务端断开连接，此时客户端的连接进入到 &lt;code>FIN_WAIT_1&lt;/code> 状态。&lt;/p>
&lt;p>正常情况下，如果能及时收到服务端（被动关闭方）的 ACK，则会很快变为 &lt;code>FIN_WAIT2&lt;/code> 状态。&lt;/p>
&lt;p>如果第一次挥手丢失了，那么客户端迟迟收不到被动方的 ACK 的话，也就会触发超时重传机制，重传 FIN 报文，重发次数由 &lt;code>tcp_orphan_retries&lt;/code> 参数控制。&lt;/p>
&lt;p>当客户端重传 FIN 报文的次数超过 &lt;code>tcp_orphan_retries&lt;/code>   后，就不再发送 FIN 报文，直接进入到 &lt;code>close&lt;/code> 状态。&lt;/p>
&lt;h4 id="第二次挥手丢失了会发生什么">第二次挥手丢失了，会发生什么？&lt;/h4>
&lt;p>当服务端收到客户端的第一次挥手后，就会先回一个 ACK 确认报文，此时服务端的连接进入到 &lt;code>CLOSE_WAIT&lt;/code> 状态。&lt;/p>
&lt;p>在前面我们也提了，ACK 报文是不会重传的，所以如果服务端的第二次挥手丢失了，客户端就会触发超时重传机制，重传 FIN 报文，直到收到服务端的第二次挥手，或者达到最大的重传次数。&lt;/p>
&lt;p>这里提一下，当客户端收到第二次挥手，也就是收到服务端发送的 ACK 报文后，客户端就会处于 &lt;code>FIN_WAIT2&lt;/code> 状态，在这个状态需要等服务端发送第三次挥手，也就是服务端的 FIN 报文。&lt;/p>
&lt;p>对于 close 函数关闭的连接，由于无法再发送和接收数据，所以&lt;code>FIN_WAIT2&lt;/code> 状态不可以持续太久，而  &lt;code>tcp_fin_timeout&lt;/code> 控制了这个状态下连接的持续时长，默认值是 60 秒。&lt;/p>
&lt;p>这意味着对于调用 close 关闭的连接，如果在 60 秒后还没有收到 FIN 报文，客户端（主动关闭方）的连接就会直接关闭。&lt;/p>
&lt;h4 id="第三次挥手丢失了会发生什么">第三次挥手丢失了，会发生什么？&lt;/h4>
&lt;p>当服务端（被动关闭方）收到客户端（主动关闭方）的 FIN 报文后，内核会自动回复 ACK，同时连接处于 &lt;code>CLOSE_WAIT&lt;/code> 状态，顾名思义，它表示等待应用进程调用 close 函数关闭连接。&lt;/p>
&lt;p>此时，内核是没有权利替代进程关闭连接，必须由进程主动调用 close 函数来触发服务端发送 FIN 报文。&lt;/p>
&lt;p>服务端处于 CLOSE_WAIT 状态时，调用了 close 函数，内核就会发出 FIN 报文，同时连接进入 LAST_ACK 状态，等待客户端返回 ACK 来确认连接关闭。&lt;/p>
&lt;p>如果迟迟收不到这个 ACK，服务端就会重发 FIN 报文，重发次数仍然由 &lt;code>tcp_orphan_retrie&lt;/code>s 参数控制，这与客户端重发 FIN 报文的重传次数控制方式是一样的。&lt;/p>
&lt;h4 id="第四次挥手丢失了会发生什么">第四次挥手丢失了，会发生什么？&lt;/h4>
&lt;p>当客户端收到服务端的第三次挥手的 FIN 报文后，就会回 ACK 报文，也就是第四次挥手，此时客户端连接进入 &lt;code>TIME_WAIT&lt;/code> 状态。&lt;/p>
&lt;p>在 Linux 系统，TIME_WAIT 状态会持续 60 秒后才会进入关闭状态。&lt;/p>
&lt;p>然后，服务端（被动关闭方）没有收到 ACK 报文前，还是处于 LAST_ACK 状态。&lt;/p>
&lt;p>如果第四次挥手的 ACK 报文没有到达服务端，服务端就会重发 FIN 报文，重发次数仍然由前面介绍过的 &lt;code>tcp_orphan_retries&lt;/code> 参数控制。&lt;/p>
&lt;hr>
&lt;p>是吧，TCP 聪明着很！&lt;/p></description></item><item><title>Docs: TCP 与 HTTP</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/4.%E6%95%B0%E6%8D%AE%E9%80%9A%E4%BF%A1/%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/tcp-%E4%B8%8E-http/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/4.%E6%95%B0%E6%8D%AE%E9%80%9A%E4%BF%A1/%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/tcp-%E4%B8%8E-http/</guid><description>
&lt;h1 id="tcp-与-http-的-keep-alive">TCP 与 HTTP 的 Keep-Alive&lt;/h1>
&lt;p>原文链接：&lt;a href="https://mp.weixin.qq.com/s/25atTs4b-vORIx525ur_aw">https://mp.weixin.qq.com/s/25atTs4b-vORIx525ur_aw&lt;/a>&lt;/p>
&lt;p>大致问题是，&lt;strong>TCP 的 Keepalive 和 HTTP 的 Keep-Alive 是一个东西吗？&lt;/strong>
这是个好问题，应该有不少人都会搞混，因为这两个东西看上去太像了，很容易误以为是同一个东西。
事实上，&lt;strong>这两个完全是两样不同东西&lt;/strong>，实现的层面也不同：&lt;/p>
&lt;ul>
&lt;li>HTTP 的 Keep-Alive，是由&lt;strong>应用层（用户态）&lt;/strong> 实现的，称为 HTTP 长连接；&lt;/li>
&lt;li>TCP 的 Keepalive，是由 &lt;strong>TCP 层（内核态）&lt;/strong> 实现的，称为 TCP 保活机制；&lt;/li>
&lt;/ul>
&lt;p>接下来，分别说说它们。&lt;/p>
&lt;h3 id="http-的-keep-alive">HTTP 的 Keep-Alive&lt;/h3>
&lt;p>HTTP 协议采用的是「请求-应答」的模式，也就是客户端发起了请求，服务端才会返回响应，一来一回这样子。
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/aqay4l/1625643072489-5556e712-c824-499b-8a85-9df5b8de00a2.png" alt="">请求-应答
由于 HTTP 是基于 TCP 传输协议实现的，客户端与服务端要进行 HTTP 通信前，需要先建立 TCP 连接，然后客户端发送 HTTP   请求，服务端收到后就返回响应，至此「请求-应答」的模式就完成了，随后就会释放 TCP 连接。
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/aqay4l/1625643072516-f1e8278b-3248-4e10-b9a0-f1858df8238d.png" alt="">一个 HTTP 请求
如果每次请求都要经历这样的过程：建立 TCP -&amp;gt; 请求资源 -&amp;gt; 响应资源 -&amp;gt; 释放连接，那么此方式就是 &lt;strong>HTTP 短连接&lt;/strong>，如下图：
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/aqay4l/1625643072462-fff13ee3-a399-4f41-bfe9-443e85f007b1.png" alt="">HTTP 短连接
这样实在太累人了，一次连接只能请求一次资源。
能不能在第一个 HTTP 请求完后，先不断开 TCP 连接，让后续的 HTTP 请求继续使用此连接？
当然可以，HTTP 的 Keep-Alive 就是实现了这个功能，可以使用同一个 TCP 连接来发送和接收多个 HTTP 请求/应答，避免了连接建立和释放的开销，这个方法称为 &lt;strong>HTTP 长连接&lt;/strong>。
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/aqay4l/1625643072505-c0e7c75c-925f-4b8a-a791-1b44484decf0.png" alt="">HTTP 长连接
HTTP 长连接的特点是，只要任意一端没有明确提出断开连接，则保持 TCP 连接状态。
怎么才能使用 HTTP 的 Keep-Alive 功能？
在 HTTP 1.0 中默认是关闭的，如果浏览器要开启 Keep-Alive，它必须在请求的包头中添加：&lt;/p>
&lt;pre>&lt;code>Connection: Keep-Alive
&lt;/code>&lt;/pre>
&lt;p>然后当服务器收到请求，作出回应的时候，它也添加一个头在响应中：&lt;/p>
&lt;pre>&lt;code>Connection: Keep-Alive
&lt;/code>&lt;/pre>
&lt;p>这样做，连接就不会中断，而是保持连接。当客户端发送另一个请求时，它会使用同一个连接。这一直继续到客户端或服务器端提出断开连接。
&lt;strong>从 HTTP 1.1 开始， 就默认是开启了 Keep-Alive&lt;/strong>，如果要关闭 Keep-Alive，需要在 HTTP 请求的包头里添加：&lt;/p>
&lt;pre>&lt;code>Connection:close
&lt;/code>&lt;/pre>
&lt;p>现在大多数浏览器都默认是使用 HTTP/1.1，所以 Keep-Alive 都是默认打开的。一旦客户端和服务端达成协议，那么长连接就建立好了。
HTTP 长连接不仅仅减少了 TCP 连接资源的开销，而且这给 &lt;strong>HTTP 流水线&lt;/strong>技术提供了可实现的基础。
所谓的 HTTP 流水线，是&lt;strong>客户端可以先一次性发送多个请求，而在发送过程中不需先等待服务器的回应&lt;/strong>，可以减少整体的响应时间。
举例来说，客户端需要请求两个资源。以前的做法是，在同一个 TCP 连接里面，先发送 A 请求，然后等待服务器做出回应，收到后再发出 B 请求。HTTP 流水线机制则允许客户端同时发出 A 请求和 B 请求。
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/aqay4l/1625643072531-ffeb1c68-b44d-4176-888a-81045ac28a0a.webp" alt="">
右边为 HTTP 流水线机制
但是&lt;strong>服务器还是按照顺序响应&lt;/strong>，先回应 A 请求，完成后再回应 B 请求。
而且要等服务器响应完客户端第一批发送的请求后，客户端才能发出下一批的请求，也就说如果服务器响应的过程发生了阻塞，那么客户端就无法发出下一批的请求，此时就造成了「队头阻塞」的问题。
可能有的同学会问，如果使用了 HTTP 长连接，如果客户端完成一个 HTTP 请求后，就不再发起新的请求，此时这个 TCP 连接一直占用着不是挺浪费资源的吗？
对没错，所以为了避免资源浪费的情况，web 服务软件一般都会提供 &lt;code>keepalive_timeout&lt;/code> 参数，用来指定 HTTP 长连接的超时时间。
比如设置了 HTTP 长连接的超时时间是 60 秒，web 服务软件就会&lt;strong>启动一个定时器&lt;/strong>，如果客户端在完后一个 HTTP 请求后，在 60 秒内都没有再发起新的请求，&lt;strong>定时器的时间一到，就会触发回调函数来释放该连接。&lt;/strong>
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/aqay4l/1625643072526-84366250-09a5-4292-b738-0fc547c395cd.png" alt="">HTTP 长连接超时&lt;/p>
&lt;h3 id="tcp-的-keepalive">TCP 的 Keepalive&lt;/h3>
&lt;p>TCP 的 Keepalive 这东西其实就是 &lt;strong>TCP 的保活机制&lt;/strong>，它的工作原理我之前的文章写过，这里就直接贴下以前的内容。
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/aqay4l/1625643072529-348d0a2d-5281-4f91-8d76-88d983c3da06.png" alt="">
如果两端的 TCP 连接一直没有数据交互，达到了触发 TCP 保活机制的条件，那么内核里的 TCP 协议栈就会发送探测报文。&lt;/p>
&lt;ul>
&lt;li>如果对端程序是正常工作的。当 TCP 保活的探测报文发送给对端, 对端会正常响应，这样 &lt;strong>TCP 保活时间会被重置&lt;/strong>，等待下一个 TCP 保活时间的到来。&lt;/li>
&lt;li>如果对端主机崩溃，或对端由于其他原因导致报文不可达。当 TCP 保活的探测报文发送给对端后，石沉大海，没有响应，连续几次，达到保活探测次数后，&lt;strong>TCP 会报告该 TCP 连接已经死亡&lt;/strong>。&lt;/li>
&lt;/ul>
&lt;p>所以，TCP 保活机制可以在双方没有数据交互的情况，通过探测报文，来确定对方的 TCP 连接是否存活，这个工作是在内核完成的。
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/aqay4l/1625643072539-7c6779d8-119f-43d0-9307-990c29756ac7.png" alt="">TCP 保活机制
注意，应用程序若想使用 TCP 保活机制需要通过 socket 接口设置 &lt;code>SO_KEEPALIVE&lt;/code> 选项才能够生效，如果没有设置，那么就无法使用 TCP 保活机制。&lt;/p>
&lt;h3 id="总结">总结&lt;/h3>
&lt;p>HTTP 的 Keep-Alive 也叫 HTTP 长连接，该功能是由「应用程序」实现的，可以使得用同一个 TCP 连接来发送和接收多个 HTTP 请求/应答，减少了 HTTP 短连接带来的多次 TCP 连接建立和释放的开销。
TCP 的 Keepalive 也叫 TCP 保活机制，该功能是由「内核」实现的，当客户端和服务端长达一定时间没有进行数据交互时，内核为了确保该连接是否还有效，就会发送探测报文，来检测对方是否还在线，然后来决定是否要关闭该连接。&lt;/p></description></item><item><title>Docs: TCP/IP 管理工具</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/4.%E6%95%B0%E6%8D%AE%E9%80%9A%E4%BF%A1/%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/3_4.tcp_ip/tcp_ip-%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/4.%E6%95%B0%E6%8D%AE%E9%80%9A%E4%BF%A1/%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/3_4.tcp_ip/tcp_ip-%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;h1 id="获取本机公网-ip">获取本机公网 IP&lt;/h1>
&lt;h2 id="ipify">ipify&lt;/h2>
&lt;p>&lt;a href="https://geo.ipify.org/docs">https://geo.ipify.org/docs&lt;/a>&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">func&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">res&lt;/span>, &lt;span style="color:#a6e22e">_&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">http&lt;/span>.&lt;span style="color:#a6e22e">Get&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;https://api.ipify.org&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">ip&lt;/span>, &lt;span style="color:#a6e22e">_&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">ioutil&lt;/span>.&lt;span style="color:#a6e22e">ReadAll&lt;/span>(&lt;span style="color:#a6e22e">res&lt;/span>.&lt;span style="color:#a6e22e">Body&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">os&lt;/span>.&lt;span style="color:#a6e22e">Stdout&lt;/span>.&lt;span style="color:#a6e22e">Write&lt;/span>(&lt;span style="color:#a6e22e">ip&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="其他">其他&lt;/h2>
&lt;p>&lt;a href="https://ip.netarm.com">https://ip.netarm.com&lt;/a>
&lt;a href="http://ip.cip.cc">http://ip.cip.cc&lt;/a>
&lt;a href="http://ip.sb">http://ip.sb&lt;/a>
&lt;a href="https://geo.ipify.org/docs">
&lt;/a>&lt;/p></description></item><item><title>Docs: TCPDump</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/4.%E6%95%B0%E6%8D%AE%E9%80%9A%E4%BF%A1/%E6%95%B0%E6%8D%AE%E5%8C%85%E5%88%86%E6%9E%90/tcpdump/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/4.%E6%95%B0%E6%8D%AE%E9%80%9A%E4%BF%A1/%E6%95%B0%E6%8D%AE%E5%8C%85%E5%88%86%E6%9E%90/tcpdump/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://www.tcpdump.org/">官网&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.tcpdump.org/manpages/tcpdump.1.html">Manual(手册),tcpdump(1)&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.tcpdump.org/manpages/pcap-filter.7.html">Manual(手册),PCAP-FILTER&lt;/a>，主要描述过滤表达式的语法&lt;/li>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Tcpdump">Wiki,tcpdump&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.middlewareinventory.com/blog/tcpdump-capture-http-get-post-requests-apache-weblogic-websphere/">https://www.middlewareinventory.com/blog/tcpdump-capture-http-get-post-requests-apache-weblogic-websphere/&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>TCPDump 是一个在命令行界面下的 Packet Analyzer(数据包分析程序)。tcpdump 适用于大多数&lt;a href="https://en.wikipedia.org/wiki/Unix-like">类 Unix&lt;/a> &lt;a href="https://en.wikipedia.org/wiki/Operating_system">操作系统&lt;/a>，在这些系统中，tcpdump 使用 &lt;a href="https://en.wikipedia.org/wiki/Libpcap">libpcap&lt;/a> 库来捕获数据包。对于 Windows 操作系统来说，tcpdump 使用的 pcap API 是 &lt;a href="https://en.wikipedia.org/wiki/WinPcap">WinPcap&lt;/a>(即 libpcap 的 Windows 版本)。&lt;/p>
&lt;p>tcpdump 最初由&lt;a href="https://en.wikipedia.org/wiki/Van_Jacobson">Van Jacobson&lt;/a>、&lt;a href="https://en.wikipedia.org/wiki/Sally_Floyd">Sally Floyd&lt;/a>、&lt;a href="https://en.wikipedia.org/wiki/Vern_Paxson">Vern Paxson&lt;/a>和&lt;a href="https://en.wikipedia.org/w/index.php?title=Steven_McCanne&amp;amp;action=edit&amp;amp;redlink=1">Steven McCanne&lt;/a>于 1988 年编写，他们当时在&lt;a href="https://en.wikipedia.org/wiki/Lawrence_Berkeley_Laboratory">劳伦斯伯克利实验室&lt;/a>网络研究小组工作。到 1990 年代后期，有许多版本的 tcpdump 作为各种操作系统的一部分分发，以及许多没有很好协调的补丁。 &lt;a href="https://en.wikipedia.org/w/index.php?title=Michael_Richardson_(mcr)&amp;amp;action=edit&amp;amp;redlink=1">Michael Richardson (mcr)&lt;/a>和&lt;a href="https://en.wikipedia.org/w/index.php?title=Bill_Fenner&amp;amp;action=edit&amp;amp;redlink=1">Bill Fenner&lt;/a>于 1999 年创建了&lt;a href="https://www.tcpdump.org/">www.tcpdump.org&lt;/a>。&lt;/p>
&lt;p>说明：Dump 有 **转出，倾卸；转储；内容全部打印 **的含义，在官方文档中，通过 TCPDump 程序输出的数据包，通常称为 dump line，转储的行。说白了就是程序抓到的包，每个包都是一行~~~~~&lt;/p>
&lt;h1 id="syntax语法">Syntax(语法)&lt;/h1>
&lt;p>&lt;strong>tcpdump [OPTIONS] [Filter-Expression]&lt;/strong>&lt;/p>
&lt;h2 id="options">OPTIONS&lt;/h2>
&lt;ul>
&lt;li>&lt;strong>-c &lt;!-- raw HTML omitted -->&lt;/strong> # 指定程序将会捕获的数据包数量。&lt;/li>
&lt;li>&lt;strong>-D, &amp;ndash;list-interfaces&lt;/strong> # 列出可用于抓包的接口。将会列出接口的数值编号和接口名，它们都可以用于&amp;quot;-i&amp;quot;后&lt;/li>
&lt;li>&lt;strong>-e&lt;/strong> # 在每条 dump 出来的行上显示二层头信息。这个选项可以输出 以太网 和 IEEE802.11 等协议的 MAC 层信息。
&lt;ul>
&lt;li>通常用来抓取 VLAN 的 Tag。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>-F &lt;!-- raw HTML omitted -->&lt;/strong> # 指定一个包含 Filter-Expression 语法的文件。程序将会使用该文件的内容作为过滤表达式，并忽略命令行给出的过滤表达式。&lt;/li>
&lt;li>&lt;strong>-i, &amp;ndash;interface &lt;!-- raw HTML omitted -->&lt;/strong> # 抓取指定网卡 DEV 的包，&lt;code>默认值：any&lt;/code>，即抓取所有设备
&lt;ul>
&lt;li>注意：在有 Bond 的服务器上，不要抓所有设备的包，否则使用 Wireshark 读取抓包文件时，会显示出很多乱序和重传，这是因为 Bond 设备和 Bond Salve 设备的包是相同的，但是咱都抓了。相同的包，时间不同，Wireshark 就识别成乱序了。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>-l # 使用标准输出列的缓冲区；&lt;/li>
&lt;li>&lt;strong>-n&lt;/strong> # 不把主机的网络地址转换成 IP&lt;/li>
&lt;li>-O # 不将数据包编码最佳化&lt;/li>
&lt;li>-p # 不让网络界面进入混杂模式&lt;/li>
&lt;li>-q # 快速输出，仅列出少数的传输协议信息&lt;/li>
&lt;li>&lt;strong>-r &lt;!-- raw HTML omitted -->&lt;/strong> # 从 FILE 读取数据包。FILE 是通过 -w 选项保存的文件，或者任何使用 pcap API 的应用程序生成的文件。&lt;/li>
&lt;li>-s &amp;lt;数据包大小&amp;gt; # 设置每个数据包的大小；&lt;/li>
&lt;li>&lt;strong>-S, &amp;ndash;absolute-tcp-sequence-numbers&lt;/strong> # 输出 TCP sequence 号的绝对值，而不是相对值&lt;/li>
&lt;li>&lt;strong>-tt&lt;/strong> # 显示每个抓到的包的时间戳(自 1970 年 1 月 1 日 00:00:00 以来)&lt;/li>
&lt;li>&lt;strong>-tttt&lt;/strong> # 显示每个抓到的包的绝对时间&lt;/li>
&lt;li>&lt;strong>-ttttt&lt;/strong> # 显示每个抓到的包的相对时间，单位微妙，第一个包是 &lt;code>00:00:00.000000&lt;/code>，&lt;/li>
&lt;li>-T &amp;lt;数据包类型&amp;gt; # 强制将表达方式所指定的数据包转译成设置的数据包类型；&lt;/li>
&lt;li>&lt;strong>-v[vv]&lt;/strong> # 从一个 v 开始，每多一个 v 则抓出的包的信息则做出一部分最多 3 个 v，包信息最多&lt;/li>
&lt;li>&lt;strong>-w &amp;lt;/Path/FILE&amp;gt;&lt;/strong> # 把数据包数据写入指定的文件&lt;/li>
&lt;/ul>
&lt;h2 id="filter-expression过滤表达式--用于过滤抓取到的数据包">Filter-Expression(过滤表达式) # 用于过滤抓取到的数据包&lt;/h2>
&lt;p>&lt;strong>Filter Expression(过滤表达式)&lt;/strong> 可以让 tcpdump 程序只输出通过表达式匹配到的数据包。&lt;/p>
&lt;p>过滤表达式由一个或多个 &lt;strong>Primitives(原语)&lt;/strong> 组成。原语通常是一个具有一个或多个 &lt;strong>Qualifiers(限定词)&lt;/strong> 的 ID。ID 就是 端口号、主机名、IP 地址 等等&lt;/p>
&lt;h3 id="qualifiers限定词">Qualifiers(限定词)&lt;/h3>
&lt;p>一共有三种类型的限定词：&lt;/p>
&lt;ul>
&lt;li>&lt;strong>TYPE&lt;/strong> # 类型限定词。指定 ID 的类型。默认值：&lt;code>host&lt;/code>
&lt;ul>
&lt;li>**host **# 匹配主机名称或 IP 地址&lt;/li>
&lt;li>**net **# 匹配网段，CIDR 模式。比如：1.2.3.0/24&lt;/li>
&lt;li>**port **# 匹配端口号&lt;/li>
&lt;li>**portrange **# 匹配端口号的范围。两个端口号中间以 &lt;code>-&lt;/code> 连接&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>DIR&lt;/strong> # direction(方向) 限定词。指定 ID 的传输方向。默认值：&lt;code>src or dst&lt;/code>
&lt;ul>
&lt;li>&lt;strong>src&lt;/strong>&lt;/li>
&lt;li>&lt;strong>dst&lt;/strong>&lt;/li>
&lt;li>&lt;strong>&amp;hellip;&amp;hellip; 等等&lt;/strong>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>PROTO&lt;/strong> # 协议限定词。指定要匹配的协议
&lt;ul>
&lt;li>&lt;strong>icmp&lt;/strong>&lt;/li>
&lt;li>&lt;strong>ip&lt;/strong>&lt;/li>
&lt;li>&lt;strong>ip6&lt;/strong>&lt;/li>
&lt;li>&lt;strong>arp&lt;/strong>&lt;/li>
&lt;li>&lt;strong>tcp&lt;/strong>&lt;/li>
&lt;li>&lt;strong>udp&lt;/strong>&lt;/li>
&lt;li>&lt;strong>&amp;hellip;&amp;hellip;等等&lt;/strong>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>不同类型的限定符之间可以互相组合&lt;/strong>，以实现更复杂的描述，比如：&lt;/p>
&lt;ul>
&lt;li>类型匹配和方向匹配组合
&lt;ul>
&lt;li>src host 1.1.1.1 # 匹配源主机为 1.1.1.1 的数据包&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>类型匹配、方向匹配、协议匹配全部组合在一起
&lt;ul>
&lt;li>udp dst portrange 100-400 # 匹配 目的端口范围在 100-400 之间的 UDP 协议的数据包&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>相同类型的限定符之间也可以互相组合&lt;/strong>，但是需要使用逻辑表达式 &lt;strong>and、or、not&lt;/strong>(或者用符号表示 &lt;code>&amp;amp;&amp;amp;&lt;/code>、&lt;code>||&lt;/code>、&lt;code>!&lt;/code>) 来连接两个限定符，比如：&lt;/p>
&lt;ul>
&lt;li>icmp or tcp # 匹配 icmp 或 tcp 的数据包&lt;/li>
&lt;li>ip host 1.1.1.1 and ! 2.2.2.2 # 匹配 1.1.1.1 主机，但不包括 2.2.2.2 主机之间的通信&lt;/li>
&lt;li>src and dst port 1111 # 匹配 源端口 和 目的端口 都是 1111 的数据包&lt;/li>
&lt;li>tcp src or dst portrange 1111-2222 # 匹配 源 或者 目的 任意一个方向的端口范围在 1111-2222 之间的 TCP 协议的数据包&lt;/li>
&lt;li>注意：为了节省输入，可以**省略相同的限定符，**下面两个表达式的作用完全相同：
&lt;ul>
&lt;li>tcp dst port 21 or 22 or 23&lt;/li>
&lt;li>tcp dst port 21 or tcp dst port 22 or tcp dst port 33&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>icmp or tcp dst port 23 and host 1.1.1.1 # 匹配 icmp 或 tcp，目的端口为 23 且主机为 1.1.1.1 的数据包&lt;/li>
&lt;/ul>
&lt;p>对于比较复杂的过滤器表达式，为了逻辑的清晰，可以使用括号。不过默认情况下，tcpdump 把 () 当做特殊的字符，所以必须使用单引号 &amp;rsquo; 来消除歧义：&lt;/p>
&lt;ul>
&lt;li>tcpdump -nvv -c 20 &amp;lsquo;src 10.0.2.4 and (dat port 3389 or 22)&amp;rsquo;&lt;/li>
&lt;/ul>
&lt;!-- raw HTML omitted -->
&lt;p>协议限定词扩展语法如下：&lt;/p>
&lt;ul>
&lt;li>&lt;strong>PROTO[EXPR:SIZE]&lt;/strong>
&lt;ul>
&lt;li>PROTO # 协议名&lt;/li>
&lt;li>EXPR # 表达式&lt;/li>
&lt;li>SIZE #&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>简单示例：&lt;/p>
&lt;ul>
&lt;li>匹配 TCP 头中标志为 tcp-syn 的包
&lt;ul>
&lt;li>&lt;strong>&amp;rsquo;tcp[tcpflags] &amp;amp; tcp-syn != 0&amp;rsquo;&lt;/strong>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>匹配 TCP 头中标志为 SYN 或 FIN 的包。也就是说一个 TCP 会话的开始和结束的包。
&lt;ul>
&lt;li>&lt;strong>tcp[tcpflags] &amp;amp; (tcp-syn|tcp-fin) != 0&lt;/strong>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h1 id="应用示例">应用示例&lt;/h1>
&lt;ul>
&lt;li>抓取 http 的包
&lt;ul>
&lt;li>tcpdump -XvvennSs 0 -i any tcp[20:2]=0x4745 or tcp[20:2]=0x4854&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>从 bond0 网卡抓取 源地址为 10.10.10.10 且 端口号为 18999 的 UDP 的包，每个包大小为 500
&lt;ul>
&lt;li>tcpdump -i bond0 udp port 18999 and src host 10.10.10.10 -s 500 0nvvvSe -T snmp&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>抓取 eth9 网卡，到 111.30.199.159 的包，记录到/tmp/srcIP 中
&lt;ul>
&lt;li>tcpdump -i eth9 host 111.30.199.159 -Avns 0 -w /tmp/srcIP&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>tcpdump -i eth0 -tnn dst port 80 -c 1000 | awk -F”.” &amp;lsquo;{print $1&amp;quot;.&amp;quot;$2&amp;quot;.&amp;quot;$3&amp;quot;.&amp;quot;$4&amp;quot;.&amp;quot;}&amp;rsquo; | sort |uniq -c | sort -nr | head-5&lt;/li>
&lt;li>获取 vnet1 网卡的 icmp 的包，i.e.抓 ping 命令的包
&lt;ul>
&lt;li>tcpdump icmp -i vnet1&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>在 eth0 上抓取目的端口是 53 的 udp 包
&lt;ul>
&lt;li>tcpdump -i eth0 udp dst port 53&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>抓取多个 host 的数据包
&lt;ul>
&lt;li>tcpdump -i any host 172.19.42.202 or 172.19.42.201 -nn&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>从 192.168 网段到 10 或者 172.16 网段的数据报
&lt;ul>
&lt;li>tcpdump -nvX src net 192.168.0.0/16 and dat net 10.0.0.0/8 or 172.16.0.0/16&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>匹配所有传入的 HTTP 的 GET 请求的包
&lt;ul>
&lt;li>tcpdump -s 0 -A &amp;rsquo;tcp[((tcp[12:1] &amp;amp; 0xf0) &amp;raquo; 2):4] = 0x47455420&amp;rsquo;
&lt;ul>
&lt;li>tcp[((tcp[12:1] &amp;amp; 0xf0) &amp;raquo; 2):4] # 首先确定我们感兴趣的字节的位置 (在 TCP 头之后)，然后选择我们希望匹配的 4 个字节。&lt;/li>
&lt;li>0x47455420 # 0x 表示 16 进制，47455420 是 ASCII 中以 16 进制表示的 &lt;code>GET &lt;/code> 这四个字符(G、E、T、空格)。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>匹配所有传入的 HTTP 的 GET 或 POST 请求的包
&lt;ul>
&lt;li>tcpdump -s 0 -A &amp;rsquo;tcp[((tcp[12:1] &amp;amp; 0xf0) &amp;raquo; 2):4] = 0x47455420 or tcp[((tcp[12:1] &amp;amp; 0xf0) &amp;raquo; 2):4] = 0x504F5354'&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>匹配 TCP 标志为 RST 的所有包。
&lt;ul>
&lt;li>意思就是数据包的包头中，tcpflags 字段的 tcp-rst 的值为 1&lt;/li>
&lt;li>tcpdump &amp;rsquo;tcp[tcpflags] &amp;amp; (tcp-rst) != 0&amp;rsquo; -nn&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>抓取 LACP 包，是否有用待验证？
&lt;ul>
&lt;li>tcpdump -i bond1 ether host 01:80:c2:00:00:02&lt;/li>
&lt;li>注意：ether 只能在某些设备上运行，需要指定具体网络设备，不能用 any&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>使用 tcpdump 截取数据报文的时候，默认会打印到屏幕的默认输出，你会看到按照顺序和格式，很多的数据一行行快速闪过，根本来不及看清楚所有的内容。不过，tcpdump 提供了把截取的数据保存到文件的功能，以便后面使用其他图形工具（比如 wireshark，Snort）来分析。&lt;/p>
&lt;p>-r 可以读取文件里的数据报文，显示到屏幕上。&lt;/p>
&lt;h1 id="tcpdump--nxr-capture_filepcap-host-web30">tcpdump -nXr capture_file.pcap host web30&lt;/h1>
&lt;p>NOTE：保存到文件的数据不是屏幕上看到的文件信息，而是包含了额外信息的固定格式 pcap，需要特殊的软件来查看，使用 vim 或者 cat 命令会出现乱码。&lt;/p>
&lt;p>从 Mars 或者 Pluto 发出的数据报，并且目的端口不是 22&lt;/p>
&lt;p>tcpdump -vv src mars or pluto and not dat port 22&lt;/p>
&lt;h1 id="tcpdump-输出内容详解">tcpdump 输出内容详解&lt;/h1>
&lt;p>截取数据只是第一步，第二步就是理解这些数据，下面就解释一下 tcpdump 命令输出各部分的意义。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>21:27:06.995846 IP &lt;span style="color:#f92672">(&lt;/span>tos 0x0, ttl 64, id 45646, offset 0, flags &lt;span style="color:#f92672">[&lt;/span>DF&lt;span style="color:#f92672">]&lt;/span>, proto TCP &lt;span style="color:#f92672">(&lt;/span>6&lt;span style="color:#f92672">)&lt;/span>, length 64&lt;span style="color:#f92672">)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> 192.168.1.106.56166 &amp;gt; 124.192.132.54.80: Flags &lt;span style="color:#f92672">[&lt;/span>S&lt;span style="color:#f92672">]&lt;/span>, cksum 0xa730 &lt;span style="color:#f92672">(&lt;/span>correct&lt;span style="color:#f92672">)&lt;/span>, seq 992042666, win 65535, options &lt;span style="color:#f92672">[&lt;/span>mss 1460,nop,wscale 4,nop,nop,TS val &lt;span style="color:#ae81ff">663433143&lt;/span> ecr 0,sackOK,eol&lt;span style="color:#f92672">]&lt;/span>, length &lt;span style="color:#ae81ff">0&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>21:27:07.030487 IP &lt;span style="color:#f92672">(&lt;/span>tos 0x0, ttl 51, id 0, offset 0, flags &lt;span style="color:#f92672">[&lt;/span>DF&lt;span style="color:#f92672">]&lt;/span>, proto TCP &lt;span style="color:#f92672">(&lt;/span>6&lt;span style="color:#f92672">)&lt;/span>, length 44&lt;span style="color:#f92672">)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> 124.192.132.54.80 &amp;gt; 192.168.1.106.56166: Flags &lt;span style="color:#f92672">[&lt;/span>S.&lt;span style="color:#f92672">]&lt;/span>, cksum 0xedc0 &lt;span style="color:#f92672">(&lt;/span>correct&lt;span style="color:#f92672">)&lt;/span>, seq 2147006684, ack 992042667, win 14600, options &lt;span style="color:#f92672">[&lt;/span>mss 1440&lt;span style="color:#f92672">]&lt;/span>, length &lt;span style="color:#ae81ff">0&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>21:27:07.030527 IP &lt;span style="color:#f92672">(&lt;/span>tos 0x0, ttl 64, id 59119, offset 0, flags &lt;span style="color:#f92672">[&lt;/span>DF&lt;span style="color:#f92672">]&lt;/span>, proto TCP &lt;span style="color:#f92672">(&lt;/span>6&lt;span style="color:#f92672">)&lt;/span>, length 40&lt;span style="color:#f92672">)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> 192.168.1.106.56166 &amp;gt; 124.192.132.54.80: Flags &lt;span style="color:#f92672">[&lt;/span>.&lt;span style="color:#f92672">]&lt;/span>, cksum 0x3e72 &lt;span style="color:#f92672">(&lt;/span>correct&lt;span style="color:#f92672">)&lt;/span>, ack 2147006685, win 65535, length &lt;span style="color:#ae81ff">0&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>最基本也是最重要的信息就是数据报的源地址/端口和目的地址/端口，上面的例子第一条数据报中，源地址 ip 是 192.168.1.106，源端口是 56166，目的地址是 124.192.132.54，目的端口是 80。 &amp;gt; 符号代表数据的方向。&lt;/p>
&lt;p>此外，上面的三条数据还是 tcp 协议的三次握手过程，第一条就是 SYN 报文，这个可以通过 Flags [S] 看出。下面是常见的 TCP 报文的 Flags:&lt;/p>
&lt;ul>
&lt;li>&lt;strong>[S]&lt;/strong> # SYN（开始连接）&lt;/li>
&lt;li>&lt;strong>[.]&lt;/strong> # 没有 Flag&lt;/li>
&lt;li>&lt;strong>[P]&lt;/strong> # PSH（推送数据）&lt;/li>
&lt;li>&lt;strong>[F]&lt;/strong> # FIN （结束连接）&lt;/li>
&lt;li>&lt;strong>[R]&lt;/strong> # RST（重置连接）&lt;/li>
&lt;/ul>
&lt;p>而第二条数据的 [S.] 表示 SYN-ACK，就是 SYN 报文的应答报文。&lt;/p>
&lt;p>tcpdump 很详细的 &lt;a href="http://blog.chinaunix.net/uid-11242066-id-4084382.html">http://blog.chinaunix.net/uid-11242066-id-4084382.html&lt;/a>&lt;/p>
&lt;p>&lt;a href="http://www.cnblogs.com/ggjucheng/archive/2012/01/14/2322659.html">http://www.cnblogs.com/ggjucheng/archive/2012/01/14/2322659.html&lt;/a> Linux tcpdump 命令详解&lt;/p>
&lt;p>Tcpdump usage examples（推荐） &lt;a href="http://www.rationallyparanoid.com/articles/tcpdump.html">http://www.rationallyparanoid.com/articles/tcpdump.html&lt;/a>&lt;/p>
&lt;p>使用 TCPDUMP 抓取 HTTP 状态头信息 &lt;a href="http://blog.sina.com.cn/s/blog_7475811f0101f6j5.html">http://blog.sina.com.cn/s/blog_7475811f0101f6j5.html&lt;/a>&lt;/p></description></item></channel></rss>