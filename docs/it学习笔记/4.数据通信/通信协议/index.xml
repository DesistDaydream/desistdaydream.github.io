<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>断念梦 – 通信协议</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/4.%E6%95%B0%E6%8D%AE%E9%80%9A%E4%BF%A1/%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/</link><description>Recent content in 通信协议 on 断念梦</description><generator>Hugo -- gohugo.io</generator><atom:link href="https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/4.%E6%95%B0%E6%8D%AE%E9%80%9A%E4%BF%A1/%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/index.xml" rel="self" type="application/rss+xml"/><item><title>Docs: 2.ARP 与 NDP</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/4.%E6%95%B0%E6%8D%AE%E9%80%9A%E4%BF%A1/%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/2.arp-%E4%B8%8E-ndp/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/4.%E6%95%B0%E6%8D%AE%E9%80%9A%E4%BF%A1/%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/2.arp-%E4%B8%8E-ndp/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Address_Resolution_Protocol">Wiki,ARP&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Neighbor_Discovery_Protocol">Wiki,NDP&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.rfc-editor.org/rfc/rfc826.html">RFC 826&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://mp.weixin.qq.com/s/_5Wgsx4mEoDZgwv9-yHYEA">公众号,36 张图详解 ARP&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>**Address Resolution Protoco(地址解析协议，简称 ARP) **是一种通信协议，该协议可以通过给定的网络层地址(通常是 IPv4 地址)，发现与之相关联的链路层地址(通常你是 MAC 地址)。ARP 于 1982 年在 &lt;a href="https://www.rfc-editor.org/rfc/rfc826.html">RFC 826&lt;/a> 中定义。说白了，就是根据 IP 地址查询对应 MAC 地址的协议。&lt;/p>
&lt;p>注意：在 IPv6 网络环境下，APR 的功能已经被 NDP 替代&lt;/p>
&lt;p>对应关系：一个 ip 地址对应一个 MAC 地址。多个 ip 地址可以对应一个 MAC 地址(e.g.一个网卡上配置两个 ip)&lt;/p>
&lt;h2 id="arp-报文">ARP 报文&lt;/h2>
&lt;p>在抓包时，可以抓到如下几种 ARP 包&lt;/p>
&lt;ol>
&lt;li>ARP, Request who-has 10.10.100.254 tell 10.10.100.101, length 28
&lt;ol>
&lt;li>在局域网中询问谁有 10.10.100.254，告诉自己，自己就是 10.10.100.101&lt;/li>
&lt;/ol>
&lt;/li>
&lt;li>ARP, Reply 10.10.100.254 is-at 00:0f:e2:ff:05:92, length 46
&lt;ol>
&lt;li>当 10.10.100.254 收到 arp 广播包之后，就会进行 reply(响应)，10.10.100.254 的 mac 地址是 00:0f:e2:ff:05:92&lt;/li>
&lt;/ol>
&lt;/li>
&lt;li>这时候 10.10.100.101 就会更新自己的 arp 表，记录下来 10.10.100.254 与 00:0f:e2:ff:05:92 的对应关系&lt;/li>
&lt;/ol>
&lt;p>ARP 报文分为 &lt;strong>ARP 请求报文&lt;/strong>和 &lt;strong>ARP 应答报文&lt;/strong>，它们的报文格式相同，但是各个字段的取值不同。
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/nguycm/1623911614198-6f1cde9d-cf37-4711-b6ce-cd9b8b1ccdd5.png" alt="">ARP 报文格式
ARP 报文中各个字段的含义如下。
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/nguycm/1623911614222-e8fe87d5-ca7b-494c-99c1-b8b1be472301.png" alt="">&lt;/p>
&lt;h1 id="arp-原理">ARP 原理&lt;/h1>
&lt;p>ARP 是通过 **ARP Request(请求) **和 **ARP Reply(响应) **报文确定 MAC 地址的。
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/nguycm/1623910582328-062e8f26-c6da-4ee5-97e4-857507dbb707.png" alt="">&lt;/p>
&lt;h2 id="同网段交互流程">同网段交互流程&lt;/h2>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>root@lichenhao:~# tcpdump -i any host 172.19.42.202
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>tcpdump: verbose output suppressed, use -v or -vv &lt;span style="color:#66d9ef">for&lt;/span> full protocol decode
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>listening on any, link-type LINUX_SLL &lt;span style="color:#f92672">(&lt;/span>Linux cooked v1&lt;span style="color:#f92672">)&lt;/span>, capture size &lt;span style="color:#ae81ff">262144&lt;/span> bytes
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>14:13:38.036170 ARP, Request who-has 172.19.42.202 tell lichenhao.bj-test, length &lt;span style="color:#ae81ff">28&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>14:13:38.036549 ARP, Reply 172.19.42.202 is-at 00:be:d5:ef:24:4e &lt;span style="color:#f92672">(&lt;/span>oui Unknown&lt;span style="color:#f92672">)&lt;/span>, length &lt;span style="color:#ae81ff">46&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>14:13:38.036583 IP lichenhao.bj-test &amp;gt; 172.19.42.202: ICMP echo request, id 3, seq 1, length &lt;span style="color:#ae81ff">64&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>14:13:38.036821 IP 172.19.42.202 &amp;gt; lichenhao.bj-test: ICMP echo reply, id 3, seq 1, length &lt;span style="color:#ae81ff">64&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>如上所示，当前主机没有 172.19.42.202 主机的 arp 关系表，当我们向 172.19.42.202 发送 icmp 请求时，数据包将会经历如下过程：&lt;/p>
&lt;p>假如主机 A 向同一网段上的主机 B 发送数据。主机 A 的 IP 地址为 &lt;code>10.0.0.1&lt;/code> ，主机 B 的 IP 地址为 &lt;code>10.0.0.2&lt;/code> ，主机 C 的 IP 地址为 &lt;code>10.0.0.3&lt;/code> 。它们都不知道对方的 MAC 地址。ARP 地址解析过程如下：
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/nguycm/1623910652117-bd47d4a3-1fb2-4f50-9b4f-bc8e5c2a1b2b.png" alt="">&lt;/p>
&lt;ol>
&lt;li>&lt;strong>主机 A&lt;/strong> 首先查看自己的 ARP 表（即 ARP 缓存表），确定是否有主机 B 的 IP 地址对应表项。如果有，则直接使用表项中的 MAC 地址进行封装，封装成帧后发送给主机 B 。&lt;/li>
&lt;/ol>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/nguycm/1623910669257-9b3f2f80-ddd3-4501-807e-96acfe414c20.png" alt="">&lt;/p>
&lt;ol start="2">
&lt;li>如果&lt;strong>主机 A&lt;/strong> 的 ARP 表没有对应的表项，就发送一个广播帧，源 IP 和源 MAC 地址是主机 A ，目的 IP 地址是主机 B ，目的 MAC 地址是广播 MAC 地址，即 &lt;code>FFFF-FFFF-FFFF&lt;/code> 。这就是 &lt;strong>ARP 请求报文&lt;/strong>。&lt;/li>
&lt;/ol>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/nguycm/1623910669279-c6354c1b-c098-4974-b4cd-22e93fc54efe.png" alt="">&lt;/p>
&lt;ol start="3">
&lt;li>ARP 请求是广播报文，同一个网段的所有主机都能收到。只有主机 B 发现报文中的目的 IP 地址是自己，于是&lt;strong>主机 B&lt;/strong> 发送响应报文给主机 A ，源 MAC 地址和源 IP 地址是主机 B ，目的 MAC 地址和目的 IP 地址是主机 A ，这个报文就叫 &lt;strong>ARP 响应报文&lt;/strong>。同时，主机 B 的 ARP 表记录主机 A 的映射关系，即主机 A 的 IP 地址和 MAC 地址的对应关系。&lt;/li>
&lt;/ol>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/nguycm/1623910669203-16790059-e9ef-45f9-9c9b-28f5f835c556.png" alt="">&lt;/p>
&lt;ol start="4">
&lt;li>&lt;strong>主机 C&lt;/strong> 也收到了 ARP 请求报文，但目的 IP 地址不是自己，所以不会进行响应。于是主机 C 添加主机 A 的映射关系到 ARP 表，并丢弃 ARP 请求报文。&lt;/li>
&lt;/ol>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/nguycm/1623910669305-20a3b990-6012-45d5-8462-176106ad6dd6.png" alt="">&lt;/p>
&lt;ol start="5">
&lt;li>主机 A 收到 ARP 响应报文后，添加主机 B 的映射关系，同时用主机 B 的 MAC 地址做为目的地址封装成帧，并发送给主机 B 。&lt;/li>
&lt;/ol>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/nguycm/1623910669300-be2dccaa-122c-41d2-92b6-3b035e70335d.png" alt="">
如果每发送一个 IP 报文就要进行一次 ARP 请求，来确定 MAC 地址，那将会造成不必要的网络流量，通常的做法是用 ARP 表记录 IP 地址和 MAC 地址的映射关系。主机发送报文时，首先会查看它的 &lt;strong>ARP 表&lt;/strong>，目的是为了确定是否是已知的设备 MAC 地址。如果有，就直接使用；如果没有，就发起 ARP 请求获取。不过，缓存是有一定期限的。ARP 表项在&lt;strong>老化时间&lt;/strong>（ &lt;code>aging time&lt;/code> ）内是有效的，如果老化时间内未被使用，表项就会被删除。
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/nguycm/1623910669502-4614b748-fac7-4301-bc85-68ccec45c91a.png" alt="">
ARP 表项分为&lt;strong>动态 ARP 表项&lt;/strong>和&lt;strong>静态 ARP 表项&lt;/strong>：&lt;/p>
&lt;ul>
&lt;li>&lt;strong>动态 ARP 表项&lt;/strong>由 ARP 动态获取，因此在网络通信中，无需事先知道 MAC 地址，只要有 IP 地址即可。如果老化时间内未被使用，表项就会被自动删除。&lt;/li>
&lt;li>&lt;strong>静态 ARP 表项&lt;/strong>是手工配置，不会老化。静态 ARP 表项的优先级高于动态 ARP 表项，可以将相应的动态 ARP 表项覆盖。&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/nguycm/1623910669307-374038c8-0ab6-4a06-ad5a-b55240326db1.png" alt="">&lt;/p>
&lt;h2 id="跨网段交互流程">跨网段交互流程&lt;/h2>
&lt;ol>
&lt;li>在 client 向 server 发送数据时，内核会在该数据包外封装 源 IP、源 MAC、目的 IP，由于目的 MAC 未知，所以不填&lt;/li>
&lt;li>数据包经过交换、路由等设备后，到达 server 前的交换机，交换机根据自身的 arp 表，找到目的 IP 与哪个口的 mac 地址相关联，则把数据包交给响应的网口，以便顺利到达 server。&lt;/li>
&lt;li>server 收到数据包后，内核会把最外层的 IP 与 MAC 都玻璃，并交给相对应的用户空间内的程序，处理完成后，再发送数据响应 client&lt;/li>
&lt;li>此时 server 已经有个 client 的 MAC 与 IP，所以在内核封装的时候，会填写源 IP、源 MAC、目的 IP、目的 MAC。&lt;/li>
&lt;li>之后数据包到达 client 前面的交换机时，交换机发现目的 IP 与 MAC，则更新或者保持不变 arp 表，并把数据包交给 MAC 为目的 MAC 的端口，以便数据送达 client&lt;/li>
&lt;li>这样就完成了两台设备之间的互相通信以及数据报文的完整封装&lt;/li>
&lt;li>否则第一次发送数据的时候，如果是不在本网段的地址，则目的 MAC 一般都是未知的，除非已经建立连接之后，才能根据数据包的源 MAC 知道响应的时候目的 MAC 填什么&lt;/li>
&lt;/ol>
&lt;h1 id="免费-arp-广播-与-一般-arp-广播">免费 ARP 广播 与 一般 ARP 广播&lt;/h1>
&lt;ul>
&lt;li>&lt;strong>免费 arp 广播&lt;/strong> # 在设备首次接通网线之后，会进行 arp 广播，告诉大家自己的 IP 与 MAC 对应关系。当局域网内的设备收到这个免费的 arp 广播时，没有该 arp 记录则会添加，如果该 arp 记录改变了则会更新。&lt;/li>
&lt;li>&lt;strong>一般 arp 广播&lt;/strong> # 在对本机未知同网段的设备发送数据时，会进行 arp 广播，询问该设备在哪里。&lt;/li>
&lt;li>“免费 arp 广播”与“一般 arp 广播”的区别：
&lt;ol>
&lt;li>普通的 arp 请求如果目的地址不是本机，则本机就直接丢弃了，但是免费的 arp 广播，则会在本机保留或者更新。&lt;/li>
&lt;/ol>
&lt;/li>
&lt;/ul>
&lt;p>如果目的 IP 不在本网段，则不会进行 arp 广播，因为目的地址不在本网段的设备，发送出去直接就到网关了，而网关在接入的时候、每隔 N 时间，都会发送 arp 来询问网关在哪。至于交换机测，也是同样的道理，本网段的设备，在需要发送数据包的时候，如果 arp 表里没有，则会先进行 arp 广播再发送。因为这些都是通过 mac 地址来进行二层发送的。&lt;/p>
&lt;p>&lt;strong>免费 ARP&lt;/strong> 是一种特殊的 ARP 请求，它并非通过 IP 找到对应的 MAC 地址，而是当主机启动的时候，发送一个免费 ARP 请求，即请求自己的 IP 地址的 MAC 地址。
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/nguycm/1623911576682-1a99a60a-4fa9-4480-8061-cec725fe9073.webp" alt="">
与普通 ARP 请求报文的区别在于报文中的目标 IP 地址。普通 ARP 报文中的目标 IP 地址是其它主机的 IP 地址；而免费 ARP 的请求报文中，&lt;strong>目标 IP 地址是自己的 IP 地址&lt;/strong>。
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/nguycm/1623911577030-243f8668-60e2-4952-bac9-beef00f9cba4.png" alt="">
免费 ARP 的作用：&lt;/p>
&lt;ul>
&lt;li>起到一个&lt;strong>宣告&lt;/strong>作用。它以广播的形式将数据包发送出去，不需要得到回应，只为了告诉其它主机自己的 IP 地址和 MAC 地址。&lt;/li>
&lt;li>可用于&lt;strong>检测 IP 地址冲突&lt;/strong>。当一台主机发送了免费 ARP 请求报文后，如果收到了 ARP 响应报文，则说明网络内已经存在使用该 IP 地址的主机。&lt;/li>
&lt;li>可用于&lt;strong>更新&lt;/strong>其它主机的 ARP 缓存表。如果该主机更换了网卡，而其它主机的 ARP 缓存表仍然保留着原来的 MAC 地址。这时，通过免费的 ARP 数据包，更新其它主机的 ARP 缓存表。&lt;/li>
&lt;/ul>
&lt;h1 id="ndp">NDP&lt;/h1></description></item><item><title>Docs: 3_4.TCP_IP</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/4.%E6%95%B0%E6%8D%AE%E9%80%9A%E4%BF%A1/%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/3_4.tcp_ip/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/4.%E6%95%B0%E6%8D%AE%E9%80%9A%E4%BF%A1/%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/3_4.tcp_ip/</guid><description/></item><item><title>Docs: 3.BGP</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/4.%E6%95%B0%E6%8D%AE%E9%80%9A%E4%BF%A1/%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/3.bgp/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/4.%E6%95%B0%E6%8D%AE%E9%80%9A%E4%BF%A1/%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/3.bgp/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;p>**Border Gateway Protocol(边界网关协议，简称 BFP) **是一个 Linux 内核原生就支持的、专门用在大规模数据中心里维护不同的“自治系统”之间路由信息的、无中心的路由协议。
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/pzl1r1/1616161506385-ecfc3cc9-11e3-4188-adfe-c551023cf332.jpeg" alt="">
在这个图中，我们有两个自治系统（Autonomous System，简称为 AS）：AS 1 和 AS 2。而所谓的一个自治系统，指的是一个组织管辖下的所有 IP 网络和路由器的全体。你可以把它想象成一个小公司里的所有主机和路由器。在正常情况下，自治系统之间不会有任何“来往”。&lt;/p>
&lt;p>但是，如果这样两个自治系统里的主机，要通过 IP 地址直接进行通信，我们就必须使用路由器把这两个自治系统连接起来。&lt;/p>
&lt;p>比如，AS 1 里面的主机 10.10.0.2，要访问 AS 2 里面的主机 172.17.0.3 的话。它发出的 IP 包，就会先到达自治系统 AS 1 上的路由器 Router 1。&lt;/p>
&lt;p>而在此时，Router 1 的路由表里，有这样一条规则，即：目的地址是 172.17.0.2 包，应该经过 Router 1 的 C 接口，发往网关 Router 2（即：自治系统 AS 2 上的路由器）。&lt;/p>
&lt;p>所以 IP 包就会到达 Router 2 上，然后经过 Router 2 的路由表，从 B 接口出来到达目的主机 172.17.0.3。&lt;/p>
&lt;p>但是反过来，如果主机 172.17.0.3 要访问 10.10.0.2，那么这个 IP 包，在到达 Router 2 之后，就不知道该去哪儿了。因为在 Router 2 的路由表里，并没有关于 AS 1 自治系统的任何路由规则。&lt;/p>
&lt;p>所以这时候，网络管理员就应该给 Router 2 也添加一条路由规则，比如：目标地址是 10.10.0.2 的 IP 包，应该经过 Router 2 的 C 接口，发往网关 Router 1。&lt;/p>
&lt;p>像上面这样负责把自治系统连接在一起的路由器，我们就把它形象地称为：边界网关。它跟普通路由器的不同之处在于，它的路由表里拥有其他自治系统里的主机路由信息。&lt;/p>
&lt;p>上面的这部分原理，相信你理解起来应该很容易。毕竟，路由器这个设备本身的主要作用，就是连通不同的网络。但是，你可以想象一下，假设我们现在的网络拓扑结构非常复杂，每个自治系统都有成千上万个&lt;/p>
&lt;p>主机、无数个路由器，甚至是由多个公司、多个网络提供商、多个自治系统组成的复合自治系统呢？&lt;/p>
&lt;p>这时候，如果还要依靠人工来对边界网关的路由表进行配置和维护，那是绝对不现实的。而这种情况下，BGP 大显身手的时刻就到了。在使用了 BGP 之后，你可以认为，在每个边界网关上都会运行着一个小程序，它们会将各自的路由表信息，通过 TCP 传输给其他的边界网关。而其他边界网关上的这个小程序，则会对收到的这些数据进行分析，然后将需要的信息添加到自己的路由表里。这样，图 2 中 Router 2 的路由表里，就会自动出现 10.10.0.2 和 10.10.0.3 对应的路由规则了。&lt;/p>
&lt;p>所以说，所谓 BGP，就是在大规模网络中实现节点路由信息共享的一种协议。而 BGP 的这个能力，正好可以取代 Flannel 维护主机上路由表的功能。而且，BGP 这种原生就是为大规模网络环境而实现的协议，其可靠性和可扩展性，远非 Flannel 自己的方案可比。&lt;/p>
&lt;p>Note：BGP 协议实际上是最复杂的一种路由协议。我在这里的讲述和所举的例子，仅是为了能够帮助你建立对 BGP 的感性认识，并不代表 BGP 真正的实现方式。&lt;/p></description></item><item><title>Docs: 3.ICMP</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/4.%E6%95%B0%E6%8D%AE%E9%80%9A%E4%BF%A1/%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/3.icmp/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/4.%E6%95%B0%E6%8D%AE%E9%80%9A%E4%BF%A1/%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/3.icmp/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://mp.weixin.qq.com/s/AKiUyMbsGhOZi7cDAhSGkg">公众号,24 张图搞定 ICMP&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;h3 id="icmp">ICMP&lt;/h3>
&lt;p>&lt;strong>IP&lt;/strong> 是尽力传输的网络协议，提供的数据传输服务是&lt;strong>不可靠&lt;/strong>的、无连接的，不能保证数据包能成功到达目的地。那么问题来了：如何确定数据包成功到达目的地？
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/boov5o/1622087956279-d468d429-a172-4d1d-8296-bd855385f80b.png" alt="">不可靠传输
这需要一个网络层协议，提供错误检测功能和报告机制功能，于是出现了 &lt;strong>ICMP&lt;/strong>（互联网控制消息协议）。ICMP 的主要功能是，&lt;strong>确认 IP 包是否成功送达目的地址&lt;/strong>，&lt;strong>通知发送过程中 IP 包被丢弃的原因&lt;/strong>。有了这些功能，就可以检查网络是否正常、网络配置是否正确、设备是否异常等信息，方便进行&lt;strong>网络问题诊断&lt;/strong>。
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/boov5o/1622087956391-eae4cc3c-7eb0-47aa-875a-154dec57c1cf.png" alt="">ICMP 网络诊断功能
&lt;strong>举个栗子&lt;/strong>：如果在传输过程中，发生了某个错误，设备便会向源设备返回一条 ICMP 消息，告诉它发生的错误类型。
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/boov5o/1622087956489-289bd365-0f3c-4891-b798-016dcab13bb4.png" alt="">ICMP 举例
ICMP 消息是通过 IP 进行传输，但它的目的并不是让 IP 成为一种可靠的协议，而是对传输中发生的问题进行反馈。ICMP 消息的传输同样得不到可靠性保证，也有可能在传输过程中丢失。因此 ICMP 不是传输层的补充，应该把它当做&lt;strong>网络层协议&lt;/strong>。&lt;/p>
&lt;h4 id="icmp-消息封装">ICMP 消息封装&lt;/h4>
&lt;p>ICMP 消息使用 IP 来封装，&lt;strong>封装格式&lt;/strong>如下图。
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/boov5o/1622087956425-eb063720-58a0-4b78-bfa8-39c2e96d569d.png" alt="">ICMP 封装格式
其中 &lt;strong>type&lt;/strong>（类型）字段表示 ICMP 消息的类型，&lt;strong>code&lt;/strong>（代码）字段表示 ICMP 消息的具体含义。例如：type 值为 3 表示目的不可达消息（ Destination Unreachable Message ），若 code 值为 0 表示目的网络不可达（ Network Unreachable ）。常见的 ICMP 消息类型如下图。
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/boov5o/1622087956257-cc3d7e06-5c0f-4f20-9026-48917ba962ee.png" alt="">ICMP 消息类型
从功能上，ICMP 的消息可分为两类：一类是通知出错原因的&lt;strong>错误消息&lt;/strong>，另一类是用于诊断的&lt;strong>查询消息&lt;/strong>。
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/boov5o/1622087956583-0a4b1076-322c-4b5f-bd43-8b5364ce42a4.png" alt="">错误消息和查询消息&lt;/p>
&lt;h4 id="常见的-icmp-消息类型">常见的 ICMP 消息类型&lt;/h4>
&lt;ul>
&lt;li>&lt;strong>回送请求消息&lt;/strong>（ Echo Request ）：是由源设备（主机或路由器等）向一个指定的目的设备发出的请求。这种消息用来测试目的地是否可达。&lt;/li>
&lt;li>&lt;strong>回送响应消息&lt;/strong>（ Echo Reply ）：对 Echo Request 的响应。目的设备发送 Echo Reply 来响应收到的 Echo Request 。最常用的 ping 命令就是使用 Echo Request 和 Echo Reply 来实现的。&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/boov5o/1622087956612-4e223795-e42d-4c78-8be6-48000ccc7632.png" alt="">回送消息&lt;/p>
&lt;ul>
&lt;li>&lt;strong>目的不可达&lt;/strong>（ Destination Unreachable ）：路由器无法将 IP 包发送给目的地址时，会给源设备返回一个 Destination Unreachable 消息，并在消息中显示不可达的具体原因。
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/boov5o/1622087956380-16033d96-d332-4f13-9a3a-3d24a50b113d.png" alt="">目的不可达实际情况下，经常会遇到的错误代码是 1 ，表示主机不可达，它是指路由表中没有目的设备的信息，或目的设备没有连接到网络。&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/boov5o/1622087956460-afdf7e80-77ee-4e32-8e0d-749e9bc5c483.png" alt="">目的不可达类型&lt;/p>
&lt;ul>
&lt;li>&lt;strong>参数问题&lt;/strong>（ Parameter Problem ）：路由器发现 IP 包头出现错误或非法值后，向源设备发送一个 Parameter Problem 消息。这个消息包含有问题的 IP 头，或错误字段的提示信息。&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/boov5o/1622087956530-5dcf521e-a938-4961-b7b1-00d735a998b6.png" alt="">参数问题消息&lt;/p>
&lt;ul>
&lt;li>&lt;strong>重定向&lt;/strong>（ Redirect ）：如果路由器发现一条更优的路径发送数据，那么它就会返回一个 Redirect 消息给主机。这个消息包含了最合适的路由信息和源数据。
实际情况下，这种 Redirect 消息会引发路由问题，所以不进行这种设置。比如：路由器的路由表不准确时，ICMP 有可能就无法正常工作。&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/boov5o/1622087956439-255f3c69-1653-431d-81a4-9592520ed469.png" alt="">重定向&lt;/p>
&lt;ul>
&lt;li>&lt;strong>超时&lt;/strong>（ Time Exceeded ）：IP 包中有一个字段是 TTL（生存周期），它的值每经过一次路由器就减 1 ，直到减到 0 时 IP 包会被丢弃。这时，路由器会发送一个 Time Exceeded 消息给源设备，并通知 IP 包已被丢弃。
设置 TTL 的主要目的，是当路由发生环路时，避免 IP 包无休止的在网络上转发。还可以用 TTL 控制 IP 包的可达范围，比如设置一个较小的 TTL 值。&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/boov5o/1622087956563-69d4450f-834a-4f6e-9ae0-f54f6ad81866.png" alt="">超时&lt;/p>
&lt;ul>
&lt;li>&lt;strong>时间戳请求/时间戳响应&lt;/strong>（ Timestamp Request / Timestamp Reply ）：时间戳可以记录 ICMP 消息一次往返所需的时间。源设备发送一个带有发送时间的 Timestamp Request 消息，目的设备收到后，发送一个带有原设备发送时间、目的设备接收时间以及目的设备发送时间的 Timestamp Reply 消息。源设备收到 Timestamp Reply 时，并同时记录到达时间。这些时间戳可以估计网络上的传输时间。&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/boov5o/1622087956537-0334836c-2e44-4f22-83c5-b81cf4d3031a.png" alt="">时间戳&lt;/p>
&lt;h3 id="icmp-的应用">ICMP 的应用&lt;/h3>
&lt;p>ICMP 被广泛应用于网络测试，最常用的 &lt;strong>ping&lt;/strong> 和 &lt;strong>tracert&lt;/strong> 网络测试工具，都是使用 ICMP 协议实现的。&lt;/p>
&lt;h4 id="ping">ping&lt;/h4>
&lt;p>ping 是 ICMP 最著名的一个应用，通过 ping 可以&lt;strong>测试网络的可达性&lt;/strong>，即网络上的报文能否成功到达目的地。使用 ping 命令时，源设备向目的设备发送 &lt;em>Echo request&lt;/em> 消息，目的地址是目的设备的 IP 地址。目的设备收到 &lt;em>Echo request&lt;/em> 消息后，向源设备回应一个 &lt;em>Echo reply&lt;/em> 消息，可知目的设备是可达的。也可以通过 ping 命令来判断目标主机是否启用。
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/boov5o/1622087956406-67c2d46c-ad49-4904-8ead-569eaeb0ef80.png" alt="">ping
如果中间某个路由器没有到达目的网络的路由，便会向源设备回应一个 &lt;em>Destination Unreachable&lt;/em> 消息，告知目的设备不可达。
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/boov5o/1622087956546-e4b22038-cd77-4ba6-a18a-8f58b0961db2.png" alt="">ping 目的不可达
如果源主机在一定时间内无法收到回应报文，就认为目的设备不可达，并显示超时。
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/boov5o/1622087956386-8c862599-839b-4eba-a995-b9267f202d65.png" alt="">超时
需要注意的是 ping 过程是双向的消息通信，只有双向都成功传输时，才能说明通信是正常的。另外主机也可能因为防火墙拦截，导致 ping 不通。&lt;/p>
&lt;h4 id="tracert">tracert&lt;/h4>
&lt;p>ping 工具只能测试目的设备的连通性，但是看不到数据包的传输路径。所以在网络不通的情况下，无法知道网络问题发生在哪个位置。tracert 工具可以查看数据包的&lt;strong>整条传输路径&lt;/strong>，包括途中经过的&lt;strong>中间设备&lt;/strong>。
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/boov5o/1622087956431-46f8e00a-d012-428d-8bcc-247f97e0b7a6.png" alt="">tracert
IP 头部的 &lt;strong>TTL&lt;/strong> 字段是为避免数据包循环转发而设计的。每经过一个路由器，数据包头中的 TTL 值减 1 。如果 TTL 值为 0 则丢弃报文，并向源设备回应一个 Time Exceeded 消息，告知错误类型。tracert 就是基于 TTL 字段和 ICMP 协议实现的。在 Windows 中命令是 &lt;strong>tracert&lt;/strong> ，在 Unix 、MacOS 中命令是 &lt;strong>traceroute&lt;/strong> 。
使用 tracert 命令时，源设备的 tracert &lt;strong>逐跳发送数据包&lt;/strong>，并等待每一个响应报文。发送第一个数据包时，TTL 值设为 1 。第一个路由器收到数据包后 TTL 值减 1 ，随即丢弃数据包，并返回一个 &lt;em>Time Exceeded&lt;/em> 消息。源设备的 tracert 收到响应报文后，取出源 IP 地址，即路径上的第一个路由器地址。然后 tracert 发送一个 TTL 值为 2 的数据包。第一个路由器将 TTL 值减 1 ，并转发数据包。第二个路由器再将 TTL 值减 1 ，丢弃数据包并返回一个 &lt;em>Time Exceeded&lt;/em> 消息。tracert 收到响应报文后，取出源 IP 地址，即路径上的第二个路由器地址。类似步骤，tracert 逐跳获得每一个路由器的地址，并探测到目的设备的可达性。
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/boov5o/1622087956576-de3f09ef-891d-4830-bef8-c84ef221aac4.png" alt="">tracert
tracert 过程也是双向的消息通信，只有双向都成功传输时，才能正确探测路径。另外主机安装了防火墙，也可能造成路径探测失败。&lt;/p>
&lt;h3 id="网络实战">网络实战&lt;/h3>
&lt;h4 id="ping-1">ping&lt;/h4>
&lt;p>在 Windows 电脑上使用 &lt;strong>ping&lt;/strong> 命令，并查看返回信息。
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/boov5o/1622087956590-14d0d35c-c869-48f1-be86-6ffd13a9591e.png" alt="">ping 命令
同步&lt;strong>抓包&lt;/strong>进行验证。
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/boov5o/1622087956373-656b7067-8cd6-4d87-9fcf-f18863eae6ec.png" alt="">ping 抓包
还可以直接使用 ping 命令，查看 ping 命令的&lt;strong>使用方法&lt;/strong>。
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/boov5o/1622087956428-2fb4954b-c839-4523-b3a2-ff3565ba6188.png" alt="">ping 命令用法&lt;/p>
&lt;h4 id="tracert-1">tracert&lt;/h4>
&lt;p>在 Windows 电脑上使用 &lt;strong>tracert&lt;/strong> 命令，并查看返回信息。
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/boov5o/1622087956498-ede48849-269f-4fe6-883e-1ed11215e544.png" alt="">tracert 命令
同步&lt;strong>抓包&lt;/strong>进行验证。
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/boov5o/1622087956533-997964bf-42cb-4306-92bc-11b97ccd05e9.png" alt="">tracert 抓包
也可以直接使用 tracert 命令，查看 tracert 命令的&lt;strong>使用方法&lt;/strong>。
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/boov5o/1622087956443-84a5971e-0af1-4287-b740-d0160533e903.png" alt="">tracert 用法&lt;/p>
&lt;hr>
&lt;p>&lt;strong>饮水思源：&lt;/strong>
TCP/IP 详解 卷 1：协议 - Kevin R.Fall
网络基础 - 田果
图解 TCP/IP - 竹下隆史
路由交换技术 - 杭州华三通信技术有限公司&lt;/p>
&lt;h1 id="icmpv6">ICMPv6&lt;/h1>
&lt;p>ICMPv6 是 IPv6 的基础协议之一，定义在 RFC 2463 中。用来传递报文转发中产生的信息或者错误。ICMPv6 定义的报文被广泛地应用在其他协议中，包括 NDP(邻居发现协议)、PathMTU 发现机制 等等。&lt;/p></description></item><item><title>Docs: 3.VRRP</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/4.%E6%95%B0%E6%8D%AE%E9%80%9A%E4%BF%A1/%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/3.vrrp/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/4.%E6%95%B0%E6%8D%AE%E9%80%9A%E4%BF%A1/%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/3.vrrp/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;p>&lt;strong>Virtual Router Redundancy Protocol(虚拟路由冗余协议，简称 VRRP)&lt;/strong> 是一种容错协议，其主要目的是解决路由单点故障的问题。VRRP 协议将局域网内的一组路由器虚拟为单个路由，通常将其称为一个路由备份组， 而这组路由器内包括一个 Master 路由（ 即活动路由器）和若干个 Backup 路由（即备份路由器）， VRRP 虚拟路由示意图如图 3-3 所示。在图 3-3 中 RouterA 、RouterB 和 RouterC 属于同一个 VRRP 组，组成一个虚拟路由器，而由 VRRP 协议虚拟出来的路由器拥有自己的 IP 地址 10.110.10.1 ，而备份组内的路由器也有自己的 IP 地址（如 Master 的 IP 地址为 10.110.10.5, Backup 的 IP 地址为 10.110.10.6 和 10.110.10.7）。&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/cv6gcm/1616161487047-bb1bc9ee-9e3e-40a2-9a92-403553eb3520.jpeg" alt="">&lt;/p>
&lt;ol>
&lt;li>
&lt;p>虚拟 IP：VIP，Virtual IP Address，在实际使用中，局域网内的主机仅仅知道这命虚拟路由器的 IP 地址 10 .110.10.1，而并不知道具体的 Master 路由器的 IP 地址以及 Backup 路由器的 IP 地址。局域网内的主机将自己的默认路由下一跳地址设置为该虚拟路由器的 IP 地址 10.110.10.1 之后，网络内的主机就通过这个虚拟的路由器来与其他网络进行通信。在通信过程中，如果备份组内的 Master 路由器故障，则 Backup 路由器将会通过选举机制重新选出一个新的 Master 路由器，从而继续向网络内的主机提供路由服务，最终实现了路由功能的高可用。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>此外，虚拟 IP 可以配置多个，比如 RouteA,B,C 的各个端口 1 绑定成一个 VIP1，RouteA,B,C 的各个端口 2 绑定成另一个 VIP2，RouteA,B,C 的各个端口 3 绑定成另一个 VIP3 以此类推，一组 VRRP 中，可以有多个 VIP，VIP1 的主路由是 Route1，VIP2 的主路由是 Route2，VIP3 的主路由是 Route3，各个 VIP 坏了，都可以有另外两台 Route 来代替工作，这样也解决了资源闲置问题，所有设备都是主，另外两台也是各个主设备的备设备&lt;/p>
&lt;/li>
&lt;li>
&lt;p>虚拟 MAC 地址：如果某一时刻 VIP 在 RouteA 上，当 A 坏了之后，VIP 自动转移到了 RouteB 上，但是对于后端的 Host 来说，该 VIP 所对应的 MAC 地址已经改变了，是该 VIP 所配置的物理网卡的 MAC 地址，这意味着之前 Host 已经缓存下来了这个对应规则，则再发送数据的时候，还会使用原来的 MAC，发送给坏了的 RouteA。为了解决这个情况，则可以使用虚拟 MAC 地址的方案,使用一个虚拟的 MAC 与 VIP 绑定&lt;/p>
&lt;/li>
&lt;li>
&lt;p>ARP 欺骗：当一台新设备接入网络后，可以使用自问自答方式，广播问一下“网关在哪里”，然后自己广播回答“网关在这里”，这时候，这台设备就可以拿到网关的 IP 所对应的自己的端口的 MAC 地址了&lt;/p>
&lt;/li>
&lt;li>
&lt;p>优先级：路由器开启 VRRP 功能后，会根据设定的优先级确定自己在备份组中的角色。优先级高的路由器成为 Master 路由器，优先级低的成为 Backup 路由器，并且 Master 路由器定期发送 VRRP 通告报文，通知备份组内的其他 Backup 路由器自己工作正常， 而备用路由器则启动定时器等待通告报文的到来。（如何判断 Master 路由器是否正常工作？）如果 Backup 路由器的定时器超时后仍未收到 Master 路由器发送来的 VRRP 通告报文， 则认为 Master 路由器已经故障，此时 Backup 路由器会认为自己是主用路由器（备份组内的路由器会根据优先级选举出新的 Master 路由器），并对外发送 VRRP 通告报文。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>此外， VRRP 在提高路由可靠性的同时，还简化了主机的路由配置， 在具有多播或广播能力的局域网中，借助 VRRP 能在某台路由器出现故障时仍然提供高可靠的默认链路，有效避免单一链路发生故障后网络中断的问题，并且无需修改主机动态路由协议、路由发现协议等配置信息。&lt;/p>
&lt;/li>
&lt;/ol>
&lt;h1 id="试验">试验：&lt;/h1>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/cv6gcm/1616161487021-bdc76b76-08cd-4480-b281-3230f6e829a3.jpeg" alt="">&lt;/p>
&lt;p>PC11 在 VLAN10 中 192.168.10.11，PC21 在 VLAN20 中 192.168.20.21，如果让两台设备互通，那么需要通过三层路由实现&lt;/p>
&lt;p>为了实现路由冗余，在网关所在设备启 VRRP 协议，保证一个路由（网关）坏掉的情况，可以有另一个代替。&lt;/p>
&lt;p>那么首先需要在 VRRP master 和 VRRPbackup 设备上配置 VLAN10 和 VLAN20 的虚拟网关 IP，以及给每个 VLAN 配置一个 IP 以启动该 VLAN 接口，如图所示 （需要设置优先级 priority 以确保其中一台设备始终为 MASTER，优先级默认为 100）&lt;/p>
&lt;p>VRRPmaster 的配置&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/cv6gcm/1616161487070-34b33cb9-f96b-4142-934b-ad1261217e5d.jpeg" alt="">&lt;/p>
&lt;p>VRRPbackup 的配置&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/cv6gcm/1616161487028-8f6c1dca-c7d6-4dda-92cb-d00a1251a495.jpeg" alt="">&lt;/p>
&lt;p>其余基础配置：&lt;/p>
&lt;ol>
&lt;li>
&lt;p>port link-type trunk&lt;/p>
&lt;pre>&lt;code> port trunk allow-pass vlan 10 20 交换机互联端口为trunk切允许相应vlan通过
&lt;/code>&lt;/pre>
&lt;/li>
&lt;li>
&lt;p>port link-type access&lt;/p>
&lt;pre>&lt;code> port default vlan 10 指定接入层交换机接入设备端口的VLAN以实现隔离
&lt;/code>&lt;/pre>
&lt;/li>
&lt;/ol>
&lt;p>两个路由之间互相发送报文保证双方是主还是备（注：当 VRRP 两个设备互相无法收到验证报文的时候，会出现两台都是 MASTER 的情况）&lt;/p>
&lt;p>为了实现更高的冗余效果，可以在两台 VRRP 设备上增加级联线（即互联两台设备）该极连线采取链路聚合原则（上图的 23，24 口），具体配置如下：&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/cv6gcm/1616161487040-d85f0bfa-26c8-45f4-85a8-a7ab3a98234f.jpeg" alt="">&lt;/p>
&lt;p>并且使用 interface eth-trunk 1&lt;/p>
&lt;pre>&lt;code> trunkport gigabitethernet 0/0/x to 0/0/y 该命令，创建聚合端口并且把X到Y的端口都加到聚合组里去
&lt;/code>&lt;/pre></description></item><item><title>Docs: 3/4.TCP/IP</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/4.%E6%95%B0%E6%8D%AE%E9%80%9A%E4%BF%A1/%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/3_4.tcp_ip/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/4.%E6%95%B0%E6%8D%AE%E9%80%9A%E4%BF%A1/%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/3_4.tcp_ip/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://datatracker.ietf.org/doc/html/rfc791">RFC,791&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;h2 id="封装">封装&lt;/h2>
&lt;p>当应用程序用 TCP 传输数据时，数据被送入协议栈中，然后逐个通过每一层直到被当做一串比特流送入网络。其中每一层对收到的数据都要增加一些首部信息(有时还需要增加尾部信息)，过程如图所示：
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/oc8ill/1628821300980-52f384b2-d2c9-4227-a1c5-6481d6cbf20e.png" alt="image.png">
以太网帧的帧头和帧尾下面所标注的数字是典型以太网帧首部的字节查高难度。以太网数据帧的物理特性是其查高难度必须在 &lt;strong>46~1500 字节之间(也就是 MTU 的长度)&lt;/strong>&lt;/p>
&lt;blockquote>
&lt;p>注意：所有的 Internet 标准和大多数有关 TCP/IP 的书都使用 octe 这个术语来表示字节。使用这个过分雕琢的术语是有历史原因的，因为 TCP/IP 的很多工作都是在 DEC-10 系统上进行的，但是它并不使用 8bit 的字节。由于现在几乎所有的计算机系统都采用 8bit 的字节，因此我们在本书中使用 Byte(字节) 这个术语。&lt;/p>
&lt;/blockquote>
&lt;p>由于应用数据受 MSS 长度限制，IP 首部 + TCP 首部 + 应用数据受 MTU 长度限制。所以，当一个 IP 报文超过 MTU 时就会进行 &lt;strong>Packet(分片/分组)&lt;/strong>。分组既可以是一个 IP 数据报，也可以是 IP 数据报的一个 &lt;strong>Fragment(片段)&lt;/strong>。&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/oc8ill/1628821542180-6dae0209-e7ac-494e-b6f3-715ce143c6d5.png" alt="image.png">&lt;/p></description></item><item><title>Docs: 5.SSL 与 TLS</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/4.%E6%95%B0%E6%8D%AE%E9%80%9A%E4%BF%A1/%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/5.ssl-%E4%B8%8E-tls/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/4.%E6%95%B0%E6%8D%AE%E9%80%9A%E4%BF%A1/%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/5.ssl-%E4%B8%8E-tls/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Transport_Layer_Security">Wiki,TLS&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>为了解决人类在互联网世界信息的安全性，所研究出来的相关技术&lt;/p>
&lt;p>安全机制：加密、数字签名、访问控制、数据完整性、认证交换、流量填充、路由控制、公证&lt;/p>
&lt;p>安全服务：认证、访问控制、数据保密性(连接保密性、无连接保密性、选择与保密性、流量保密性)、数据完整性、不可否认性&lt;/p>
&lt;h2 id="ssltls-介绍">SSL/TLS 介绍&lt;/h2>
&lt;p>&lt;strong>Secure Socket Layer(安全的套接字层，简称 SSL)&lt;/strong> # 一个安全协议&lt;/p>
&lt;p>**Transport Layer Security(传输层安全，简称 TLS) **# SSL3.0 的升级版&lt;/p>
&lt;p>SSL/TLS 就是在应用层与传输层中间又加了半层，应用层协议可以自行决定改层的功能，比如 http 协议用了这半层，就是 https。&lt;/p>
&lt;p>SSL/TLS 的分层设计&lt;/p>
&lt;ol>
&lt;li>最底层，基础算法原语的实现，比如 aes，rsa，md5 等&lt;/li>
&lt;li>各种算法的实现&lt;/li>
&lt;li>组合算法实现的半成品&lt;/li>
&lt;li>用各种组件拼装而成的各种成品密码学协议/软件，tls,ssh 等 openssh 也是用 openssl 实现的软件&lt;/li>
&lt;/ol>
&lt;p>&lt;strong>key(密钥)&lt;/strong> # 在密码学中，是指某个用来完成加密、解密、完整性验证等密码学应用的秘密信息。对于加密算法，key 指定明文转换成密文；对于解密算法，key 指定密文转换成明文&lt;/p>
&lt;ul>
&lt;li>&lt;strong>Plaintext or Cleartext(明文)&lt;/strong> # 在密码学中，明文是未加密的信息，可以供人类和计算机读取的信息&lt;/li>
&lt;li>**Ciphertext or Cyphertext(密文) **# 在密码学中，密文是明文通过加密算法计算后生成的人类或计算器无法读取的一种信息&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>PKI：Public Key Infrastructure(公开密钥基础建设，简称 PKI)&lt;/strong>，又称公开密钥基础架构、公钥基础建设、公钥基础设施、公开密码匙基础建设或公钥基础架构，是一组由硬件、软件、参与者、管理政策与流程组成的基础架构，其目的在于创造、管理、分配、使用、存储以及撤销数字证书。&lt;/p>
&lt;p>PKI 是借助 CA（权威数字证书颁发/认证机构）将用户的个人身份跟公开密钥链接在一起，它能够确保每个用户身份的唯一性，这种链接关系是通过注册和发布过程实现，并且根据担保级别，链接关系可能由 CA 和各种软件或在人为监督下完成。PKI 用来确定链接关系的这一角色称为 RA（Registration Authority, 注册管理中心），RA 能够确保公开密钥和个人身份链接，可以防抵赖，防篡改。在微软的公钥基础建设下，RA 又被称为 CA，目前大多数称为 CA。&lt;/p>
&lt;p>PKI 组成要素
从上面可以得知 PKI 的几个主要组成要素，用户（使用 PKI 的人或机构），认证机构（CA，颁发证书的人或机构），仓库（保存证书的数据库）等。&lt;/p>
&lt;ol>
&lt;li>签证机构：CA(Certificate authority)证书权威机构&lt;/li>
&lt;li>注册机构：RA&lt;/li>
&lt;li>证书吊销列表:CRL&lt;/li>
&lt;li>证书存取库：&lt;/li>
&lt;li>x.509：一种证书格式规范&lt;/li>
&lt;/ol>
&lt;h1 id="通信加密安全实例">通信加密安全实例：&lt;/h1>
&lt;p>甲要发送数据给乙，甲为了只让乙看到&lt;/p>
&lt;ol>
&lt;li>首先，甲用单向加密算法提取数据的特征码，然后用自己的私钥加密这段特征码，并附加在这段数据的后面。&lt;/li>
&lt;li>甲用对称密钥，把整个数据加密。再用乙的公钥加密这个对称密钥，并附加在特征码后面&lt;/li>
&lt;li>乙先用自己的私钥解密出来对称密钥是什么。再使用对称加密机制，用解密出来的对称密钥解密整个数据和加密的特征码。&lt;/li>
&lt;li>乙再对方的公钥解密特征码，得到特征码，使用同样的单向加密算法计算特征码是否一样，则说明数据完整&lt;/li>
&lt;/ol>
&lt;p>密钥交换：IKE，DH&lt;/p>
&lt;p>openSSL 与 gpg(pgp 协议)&lt;/p>
&lt;h1 id="关联文件">关联文件&lt;/h1>
&lt;p>Linux 发行版中，有一个目录会保存一些常见的 CA 证书，称之为[信任仓库](✏IT 学习笔记/🔐7.信息安全/Cryptography(密码学)/公开密钥加密/证书%20 与%20PKI.md 与 PKI.md)：&lt;/p>
&lt;ul>
&lt;li>CentOS 发行版
&lt;ul>
&lt;li>&lt;strong>/etc/pki/ca-trust/extracted/openssl/ca-bundle.trust.crt&lt;/strong> # 包含所有证书，每个证书前一行有注释&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Ubuntu 发行版
&lt;ul>
&lt;li>&lt;strong>/etc/ssl/certs/*&lt;/strong> # 该目录中一个证书一个文件&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul></description></item><item><title>Docs: 7.DHCP</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/4.%E6%95%B0%E6%8D%AE%E9%80%9A%E4%BF%A1/%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/7.dhcp/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/4.%E6%95%B0%E6%8D%AE%E9%80%9A%E4%BF%A1/%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/7.dhcp/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Dynamic_Host_Configuration_Protocol">Wiki,DHCP&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>&lt;strong>Dynamic Host Configuration Protocol(动态主机设置协议，简称 DHCP)&lt;/strong> 主要用于由一部主机来自动的分配所有的网络参数给指定网段内的所有设备。&lt;/p>
&lt;p>DHCP 可以分配的网络参数有 IP 地址、掩码、网关、DNS 等&lt;/p>
&lt;p>DHCP 的运作方式：
他主要由客户端发送广播包给整个物理网段内的所有主机， 若该网段内有 DHCP 服务器时，就会响应客户端的 DHCP 请求。所以，DHCP 服务器与客户端是应该要在同一个物理网段内的，如果想跨网段提供 DHCP 服务，需要在对应网段启用 dhcrelay 服务。&lt;/p>
&lt;p>至于整个 DHCP 封包在服务器与客户端的来来回回情况如右图，具体有 4 个步骤
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/sc7lh2/1616161468691-c82332ec-254e-485f-861d-9186e60a3dd8.jpeg" alt="">&lt;/p>
&lt;ul>
&lt;li>&lt;strong>DISCOVER(发现)&lt;/strong> # 客户端利用广播封包发送搜索 DHCP 服务器的封包：
&lt;ul>
&lt;li>若客户端网络设定使用 DHCP 协议取得 IP (在 Windows 内为『自动取得 IP』)，则当客户端开机或者是重新启动网络卡时， 客户端主机会发送出搜寻 DHCP 服务器的 UDP 封包给所有物理网段内的计算机。此封包的目标 IP 会是 255.255.255.255， 所以一般主机接收到这个封包后会直接予以丢弃，但若局域网络内有 DHCP 服务器时，则会开始进行后续行为。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>OFFER(提供)&lt;/strong> # DHCP 服务端提供客户端网络相关的租约以供选择
&lt;ul>
&lt;li>DHCP 服务器在接收到这个客户端的要求后，会针对这个客户端的硬件地址 (MAC) 与本身的设定数据来进行下列工作：
&lt;ul>
&lt;li>到服务器的登录文件中寻找该用户之前是否曾经用过某个 IP ，若有且该 IP 目前无人使用，则提供此 IP 给客户端；&lt;/li>
&lt;li>若配置文件针对该 MAC 提供额外的固定 IP (static IP) 时，则提供该固定 IP 给客户端；&lt;/li>
&lt;li>若不符合上述两个条件，则随机取用目前没有被使用的 IP 参数给客户端，并记录下来。&lt;/li>
&lt;li>总之，服务器端会针对客户端的要求提供一组网络参数租约给客户端选择，由于此时客户端尚未有 IP ，因此服务器端响应的封包信息中， 主要是针对客户端的 MAC 来给予回应。此时服务器端会保留这个租约然后开始等待客户端的回应。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>REQUEST(请求)&lt;/strong> # 客户端决定选择的 DHCP 服务器提供的网络参数租约并回报服务器
&lt;ul>
&lt;li>由于局域网络内可能并非仅有一部 DHCP 服务器，但客户端仅能接受一组网络参数的租约。 因此客户端必需要选择是否要认可该服务器提供的相关网络参数的租约。当决定好使用此服务器的网络参数租约后， 客户端便开始使用这组网络参数来设定自己的网络环境。此外，客户端也会发送一个广播封包给所有物理网段内的主机， 告知已经接受该服务器的租约。此时若有第二台以上的 DHCP 服务器，则这些没有被接受的服务器会收回该 IP 租约。至于被接受的 DHCP 服务器会继续进行底下的动作。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>Acknowledge(确认，ACK)&lt;/strong> # 服务端记录该次租约行为并回报客户端已确认的响应封包信息
- 当服务器端收到客户端的确认选择后，服务器会回传确认的响应封包，并且告知客户端这个网络参数租约的期限， 并且开始租约计时喔！那么该次租约何时会到期而被解约，可以这样想：
- 客户端脱机：不论是关闭网络接口 (ifdown)、重新启动 (reboot)、关机 (shutdown) 等行为，皆算是脱机状态，这个时候 Server 端就会将该 IP 回收，并放到 Server 自己的备用区中，等待未来的使用；
- 客户端租约到期：前面提到 DHCP server 端发放的 IP 有使用的期限，客户端使用这个 IP 到达期限规定的时间，而且没有重新提出 DHCP 的申请时，就需要将 IP 缴回去！这个时候就会造成断线。但用户也可以再向 DHCP 服务器要求再次分配 IP 啰。&lt;/li>
&lt;/ul>
&lt;p>这四个步骤也称为 DHCP 分配地址时的需要进行的 DORA 进程&lt;/p>
&lt;h2 id="dhcp-租约">DHCP 租约&lt;/h2>
&lt;p>每次 DHCP 服务给客户端提供网络参数时，同时会提供一个有效时间，该有效时间表示客户端使用这些参数的有效时间，当有效时间过了之后，客户端则不再拥有这些网络参数。租约是由客户端发起请求具体租用时间，然后服务器回应是否可以给客户端租用这些时间。&lt;/p>
&lt;p>DHCP 提供的租约信息保存在 /var/lib/dhcpd/dhcpd.lesses 文件中，租约中包括这些参数：提供的 IP，客户端 MAC，租赁时长&lt;/p>
&lt;h1 id="isc-dhcp">ISC-DHCP&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://www.isc.org/dhcp/">ISC DHCP 官网&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://access.redhat.com/documentation/zh-cn/red_hat_enterprise_linux/8/html/configuring_and_managing_networking/providing-dhcp-services_configuring-and-managing-networking#setting-up-the-dhcp-service-for-subnets-directly-connected-to-the-dhcp-server_providing-dhcp-services">https://access.redhat.com/documentation/zh-cn/red_hat_enterprise_linux/8/html/configuring_and_managing_networking/providing-dhcp-services_configuring-and-managing-networking#setting-up-the-dhcp-service-for-subnets-directly-connected-to-the-dhcp-server_providing-dhcp-services&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>ISC-DHCP 提供了一个完整的开源解决方案，用来实现 DHCP 服务端、DHCP 客户端、DHCP 中继代理 这几种 DHCP 服务，可以将 ISC-DHCP 看作一个&lt;strong>程序的集合&lt;/strong>。ISC DHCP 支持 IPv4 和 IPv6，适用于大批量和高可靠性的应用&lt;/p>
&lt;p>CentOS 和 Ubuntu 安装的都是 ISC 分发的 DCHP 程序，不过 ISC 官方已经推荐使用 Kea DHCP 替代 ISC DHCP
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/sc7lh2/1643021582679-beb6a411-3391-4577-a658-295acbd0f2a5.png" alt="image.png">&lt;/p>
&lt;p>注意：&lt;/p>
&lt;ul>
&lt;li>在为 IPv6 分配地址时，通常需要与 radvd 程序一起运行，详见 &lt;a href="#NMGBa">DHCPv6 与 radvd 章节&lt;/a>&lt;/li>
&lt;/ul>
&lt;h2 id="安装">安装&lt;/h2>
&lt;h3 id="centos">CentOS&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>yum install dhcp
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>CentOS 的包是真的不更新。。。囧。。。。好多这种情况了。。。包中写的网址都是错误的。。。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">[&lt;/span>root@test ~&lt;span style="color:#f92672">]&lt;/span>&lt;span style="color:#75715e"># yum info dhcp&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Loaded plugins: fastestmirror, product-id, search-disabled-repos, subscription-manager
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>This system is not registered with an entitlement server. You can use subscription-manager to register.
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Loading mirror speeds from cached hostfile
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> * base: mirrors.tuna.tsinghua.edu.cn
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> * epel: mirrors.tuna.tsinghua.edu.cn
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> * extras: mirrors.tuna.tsinghua.edu.cn
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> * updates: mirrors.tuna.tsinghua.edu.cn
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Available Packages
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Name : dhcp
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Arch : x86_64
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Epoch : &lt;span style="color:#ae81ff">12&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Version : 4.2.5
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Release : 83.el7.centos.1
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Size : &lt;span style="color:#ae81ff">515&lt;/span> k
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Repo : updates/7/x86_64
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Summary : Dynamic host configuration protocol software
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>URL : http://isc.org/products/DHCP/ // 在 ISC 官网。。。这个页面已经没了。。。。。
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>License : ISC
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Description : DHCP &lt;span style="color:#f92672">(&lt;/span>Dynamic Host Configuration Protocol&lt;span style="color:#f92672">)&lt;/span> is a protocol which allows
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> : individual devices on an IP network to get their own network
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> : configuration information &lt;span style="color:#f92672">(&lt;/span>IP address, subnetmask, broadcast address,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> : etc.&lt;span style="color:#f92672">)&lt;/span> from a DHCP server. The overall purpose of DHCP is to make it
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> : easier to administer a large network.
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> :
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> : To use DHCP on your network, install a DHCP service &lt;span style="color:#f92672">(&lt;/span>or relay agent&lt;span style="color:#f92672">)&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> : and on clients run a DHCP client daemon. The dhcp package provides
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> : the ISC DHCP service and relay agent.
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="ubunt">Ubunt&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>apt install isc-dhcp-server
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>包的信息&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>root@common-ubuntu-test:/etc/dhcp# apt-cache show isc-dhcp-server
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Package: isc-dhcp-server
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Architecture: amd64
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Version: 4.4.1-2.1ubuntu5.20.04.2
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Priority: optional
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Section: net
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Source: isc-dhcp
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Origin: Ubuntu
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Maintainer: Ubuntu Developers &amp;lt;ubuntu-devel-discuss@lists.ubuntu.com&amp;gt;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Original-Maintainer: Debian ISC DHCP Maintainers &amp;lt;isc-dhcp@packages.debian.org&amp;gt;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Bugs: https://bugs.launchpad.net/ubuntu/+filebug
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Installed-Size: &lt;span style="color:#ae81ff">1503&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Depends: debconf &lt;span style="color:#f92672">(&lt;/span>&amp;gt;&lt;span style="color:#f92672">=&lt;/span> 0.5&lt;span style="color:#f92672">)&lt;/span> | debconf-2.0, libc6 &lt;span style="color:#f92672">(&lt;/span>&amp;gt;&lt;span style="color:#f92672">=&lt;/span> 2.15&lt;span style="color:#f92672">)&lt;/span>, libdns-export1109, libirs-export161, libisc-export1105, debianutils &lt;span style="color:#f92672">(&lt;/span>&amp;gt;&lt;span style="color:#f92672">=&lt;/span> 2.8.2&lt;span style="color:#f92672">)&lt;/span>, lsb-base, adduser
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Recommends: isc-dhcp-common
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Suggests: policykit-1, isc-dhcp-server-ldap, policycoreutils
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Breaks: isc-dhcp-common &lt;span style="color:#f92672">(=&lt;/span> 4.3.3-1&lt;span style="color:#f92672">)&lt;/span>, logcheck-database &lt;span style="color:#f92672">(=&lt;/span> 1.3.17~&lt;span style="color:#f92672">)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Replaces: isc-dhcp-common &lt;span style="color:#f92672">(=&lt;/span> 4.3.3-1&lt;span style="color:#f92672">)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Filename: pool/main/i/isc-dhcp/isc-dhcp-server_4.4.1-2.1ubuntu5.20.04.2_amd64.deb
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Size: &lt;span style="color:#ae81ff">454712&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>MD5sum: 92a2ec90073e62f5fe65ecb840e2fcd9
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>SHA1: 1f1253f7bcd4a8d3bec5d9736d4238115635df21
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>SHA256: b537b40e5c35054d8d3f82060936de737b08f1daa48e731652aa230170f0b21a
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>SHA512: f00f30b52b085dcf9737c7cd5d37095ecdbcf9750e7bf1e5ca1f80591d1ad9f24d5b29b2c89d40dee639803b7e1e90b92f8b3396d8976a1171321eef5d960559
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Homepage: http://www.isc.org
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Description-en: ISC DHCP server &lt;span style="color:#66d9ef">for&lt;/span> automatic IP address assignment
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> This is the Internet Software Consortium&lt;span style="color:#960050;background-color:#1e0010">&amp;#39;&lt;/span>s DHCP server.
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Dynamic Host Configuration Protocol &lt;span style="color:#f92672">(&lt;/span>DHCP&lt;span style="color:#f92672">)&lt;/span> is a protocol like BOOTP
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">(&lt;/span>actually dhcpd includes much of the functionality of bootpd&lt;span style="color:#f92672">)&lt;/span>. It
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> gives client machines &lt;span style="color:#e6db74">&amp;#34;leases&amp;#34;&lt;/span> &lt;span style="color:#66d9ef">for&lt;/span> IP addresses and can
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> automatically set their network configuration.
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> This server can handle multiple ethernet interfaces.
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Description-md5: 38647f497f13c9a0a99f9d9cf772d70d
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="dhcp-程序关联文件">dhcp 程序关联文件&lt;/h2>
&lt;p>/etc/default/isc-dhcp-server #
/etc/dhcp/dhcpd.conf # dhcpd 程序运行时行为的配置文件
/var/lib/dhcpd/dhcpd.leases 与 /var/lib/dhcpd/dhcpd.leases~ # DHCP 的客户端租约的缓存文件&lt;/p>
&lt;ul>
&lt;li>所有从 DHCP 服务器获取 IP 的客户端信息都会记录在这个文件里&lt;/li>
&lt;li>并且 dhcp 服务会探测所能分配的 IP 是否被占用，所有被占用的记录也会记在这个文件里&lt;/li>
&lt;li>注意：当 DHCP 无法按照预想的样子分配 IP 的时候，可以尝试清除该文件里的内容，让其重新获取信息&lt;/li>
&lt;/ul>
&lt;h3 id="配置文件样例">配置文件样例&lt;/h3>
&lt;p>dhcp4&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-nginx" data-lang="nginx">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">ddns-update-style&lt;/span> &lt;span style="color:#e6db74">interim&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">allow&lt;/span> &lt;span style="color:#e6db74">booting&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">allow&lt;/span> &lt;span style="color:#e6db74">bootp&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">ignore&lt;/span> &lt;span style="color:#e6db74">client-updates&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">set&lt;/span> &lt;span style="color:#e6db74">vendorclass&lt;/span> = &lt;span style="color:#e6db74">option&lt;/span> &lt;span style="color:#e6db74">vendor-class-identifier&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">option&lt;/span> &lt;span style="color:#e6db74">pxe-system-type&lt;/span> &lt;span style="color:#e6db74">code&lt;/span> &lt;span style="color:#ae81ff">93&lt;/span> = &lt;span style="color:#e6db74">unsigned&lt;/span> &lt;span style="color:#e6db74">integer&lt;/span> &lt;span style="color:#ae81ff">16&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#以下是dhcp服务所能租赁的具体网段的IP信息
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">subnet&lt;/span> &lt;span style="color:#ae81ff">192&lt;/span>&lt;span style="color:#e6db74">.168.10.0&lt;/span> &lt;span style="color:#e6db74">netmask&lt;/span> &lt;span style="color:#ae81ff">255&lt;/span>&lt;span style="color:#e6db74">.255.255.0&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e"># 指定要分配的网关
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#f92672">option&lt;/span> &lt;span style="color:#e6db74">routers&lt;/span> &lt;span style="color:#ae81ff">192&lt;/span>&lt;span style="color:#e6db74">.168.10.1&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e"># 指定要分配的DNS地址
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#f92672">option&lt;/span> &lt;span style="color:#e6db74">domain-name-servers&lt;/span> &lt;span style="color:#ae81ff">114&lt;/span>&lt;span style="color:#e6db74">.114.114.114&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e"># 指定要分配的子网掩码
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#f92672">option&lt;/span> &lt;span style="color:#e6db74">subnet-mask&lt;/span> &lt;span style="color:#ae81ff">255&lt;/span>&lt;span style="color:#e6db74">.255.255.0&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e"># 指定可分配的IP地址范围是从哪到哪
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#f92672">range&lt;/span> &lt;span style="color:#e6db74">dynamic-bootp&lt;/span> &lt;span style="color:#ae81ff">192&lt;/span>&lt;span style="color:#e6db74">.168.10.100&lt;/span> &lt;span style="color:#ae81ff">192&lt;/span>&lt;span style="color:#e6db74">.168.10.254&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e"># 默认租赁时间，如果客户端没有请求租约，则提供默认时间，数值单位为秒
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#f92672">default-lease-time&lt;/span> &lt;span style="color:#ae81ff">21600&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e"># 最大租赁时间，可以提供给客户端租用网络参数的最大时间，数值单位为秒
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#f92672">max-lease-time&lt;/span> &lt;span style="color:#ae81ff">43200&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e"># PXE环境下指定的提供引导程序的服务器。i.e.该参数的值为PEX服务端的设备IP或HostName。
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#75715e"># 比如cobbler服务所在的服务器地址，或者tftp服务所在服务地址等等
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#f92672">next-server&lt;/span> &lt;span style="color:#ae81ff">10&lt;/span>&lt;span style="color:#e6db74">.10.17.15&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">class&lt;/span> &lt;span style="color:#e6db74">&amp;#34;pxeclients&amp;#34;&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">match&lt;/span> &lt;span style="color:#e6db74">if&lt;/span> &lt;span style="color:#e6db74">substring&lt;/span> &lt;span style="color:#e6db74">(option&lt;/span> &lt;span style="color:#e6db74">vendor-class-identifier,&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>&lt;span style="color:#e6db74">,&lt;/span> &lt;span style="color:#ae81ff">9&lt;/span>&lt;span style="color:#e6db74">)&lt;/span> = &lt;span style="color:#e6db74">&amp;#34;PXEClient&amp;#34;&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">if&lt;/span> &lt;span style="color:#e6db74">option&lt;/span> &lt;span style="color:#e6db74">pxe-system-type&lt;/span> = 00:&lt;span style="color:#ae81ff">02&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">filename&lt;/span> &lt;span style="color:#e6db74">&amp;#34;ia64/elilo.efi&amp;#34;&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> } &lt;span style="color:#f92672">else&lt;/span> &lt;span style="color:#e6db74">if&lt;/span> &lt;span style="color:#e6db74">option&lt;/span> &lt;span style="color:#e6db74">pxe-system-type&lt;/span> = 00:&lt;span style="color:#ae81ff">06&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">filename&lt;/span> &lt;span style="color:#e6db74">&amp;#34;grub/grub-x86.efi&amp;#34;&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> } &lt;span style="color:#f92672">else&lt;/span> &lt;span style="color:#e6db74">if&lt;/span> &lt;span style="color:#e6db74">option&lt;/span> &lt;span style="color:#e6db74">pxe-system-type&lt;/span> = 00:&lt;span style="color:#ae81ff">07&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">filename&lt;/span> &lt;span style="color:#e6db74">&amp;#34;grub/grub-x86_64.efi&amp;#34;&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> } &lt;span style="color:#f92672">else&lt;/span> &lt;span style="color:#e6db74">if&lt;/span> &lt;span style="color:#e6db74">option&lt;/span> &lt;span style="color:#e6db74">pxe-system-type&lt;/span> = 00:&lt;span style="color:#ae81ff">09&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">filename&lt;/span> &lt;span style="color:#e6db74">&amp;#34;grub/grub-x86_64.efi&amp;#34;&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> } &lt;span style="color:#f92672">else&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">filename&lt;/span> &lt;span style="color:#e6db74">&amp;#34;pxelinux.0&amp;#34;&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># group for Cobbler DHCP tag: default
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">group&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#当有其余网段需要分配时，可以继续添加相关信息
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">subnet&lt;/span> &lt;span style="color:#ae81ff">10&lt;/span>&lt;span style="color:#e6db74">.10.17.0&lt;/span> &lt;span style="color:#e6db74">netmask&lt;/span> &lt;span style="color:#ae81ff">255&lt;/span>&lt;span style="color:#e6db74">.255.255.0&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">option&lt;/span> &lt;span style="color:#e6db74">domain-name-servers&lt;/span> &lt;span style="color:#ae81ff">114&lt;/span>&lt;span style="color:#e6db74">.114.114.114&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">option&lt;/span> &lt;span style="color:#e6db74">routers&lt;/span> &lt;span style="color:#ae81ff">10&lt;/span>&lt;span style="color:#e6db74">.10.17.1&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">range&lt;/span> &lt;span style="color:#e6db74">dynamic-bootp&lt;/span> &lt;span style="color:#ae81ff">10&lt;/span>&lt;span style="color:#e6db74">.10.17.15&lt;/span> &lt;span style="color:#ae81ff">10&lt;/span>&lt;span style="color:#e6db74">.10.17.22&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">option&lt;/span> &lt;span style="color:#e6db74">subnet-mask&lt;/span> &lt;span style="color:#ae81ff">255&lt;/span>&lt;span style="color:#e6db74">.255.255.0&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">next-server&lt;/span> &lt;span style="color:#ae81ff">10&lt;/span>&lt;span style="color:#e6db74">.10.17.15&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">default-lease-time&lt;/span> &lt;span style="color:#ae81ff">21600&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">max-lease-time&lt;/span> &lt;span style="color:#ae81ff">43200&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>dhcp6&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-properties" data-lang="properties">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">default-lease-time&lt;/span> &lt;span style="color:#e6db74">600;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">max-lease-time&lt;/span> &lt;span style="color:#e6db74">7200;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">log-facility&lt;/span> &lt;span style="color:#e6db74">local7;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">subnet6&lt;/span> &lt;span style="color:#e6db74">2001:db8:0:1::/64 {&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e"># 可以分配的地址范围&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">range6&lt;/span> &lt;span style="color:#e6db74">2001:db8:0:1::129 2001:db8:0:1::254;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e"># 为客户端分配的临时地址&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">range6&lt;/span> &lt;span style="color:#e6db74">2001:db8:0:1::/64 temporary;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e"># Prefix range for delegation to sub-routers&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">prefix6&lt;/span> &lt;span style="color:#e6db74">2001:db8:0:100:: 2001:db8:0:f00:: /56;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e"># 一些可选的配置&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">option&lt;/span> &lt;span style="color:#e6db74">dhcp6.name-servers fec0:0:0:1::1;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">option&lt;/span> &lt;span style="color:#e6db74">dhcp6.domain-search &amp;#34;domain.example&amp;#34;;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e"># 将 IP 地址与 MAC 绑定的示例&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">host&lt;/span> &lt;span style="color:#e6db74">specialclient {&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">host-identifier&lt;/span> &lt;span style="color:#e6db74">option dhcp6.client-id 00:01:00:01:4a:1f:ba:e3:60:b9:1f:01:23:45;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">fixed-address6&lt;/span> &lt;span style="color:#e6db74">2001:db8:0:1::127;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#960050;background-color:#1e0010"> }&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#960050;background-color:#1e0010">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h1 id="kea-dhcp">Kea-DHCP&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://www.isc.org/kea/">Kea DHCP 官网&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;h1 id="dhcrelaydhcp-中继器简介">DhcRelay(DHCP 中继器)简介&lt;/h1>
&lt;p>DHCP Relay，DHCP 中继器，用于从没有 DHCP 服务的子网中连接到其他子网上的一个或多个 DHCP 服务器，来中继(代理、转发)DHCP 和 BOOTP 请求。它支持 DHCPv4 / BOOTP 和 DHCPv6 协议。实际应用：e.g.我有两个网段 192.168.10.0/24 和 192.168.20.0/24，在 10 网段有 DHCP 服务器，但是 20 网段没有，这时候就可以在 20 网段的设备上开启 dhcrelay 服务，然后指定一个 DHCP 服务器，来为 20 网段进行 DHCP 服务。&lt;/p>
&lt;h2 id="dhcrelay-的使用方法">dhcrelay 的使用方法&lt;/h2>
&lt;h2 id="dhcrelay-命令">dhcrelay 命令&lt;/h2>
&lt;p>语法格式：&lt;/p>
&lt;ul>
&lt;li>dhcrelay [ -4 ] [ -dqaD ] [ -p port ] [ -c count ] [ -A length ] [ -pf pid-file ] [ &amp;ndash;no-pid ] [ -m append | replace | forward | dis‐card ] [ -i interface0 [ &amp;hellip; -i interfaceN ] ] server0 [ &amp;hellip;serverN ]&lt;/li>
&lt;li>dhcrelay -6 [ -dqI ] [ -p port ] [ -c count ] [ -pf pid-file ] [ &amp;ndash;no-pid ] -l lower0 [ &amp;hellip; -l lowerN ] -u upper0 [ &amp;hellip; -u upperN ]&lt;/li>
&lt;/ul>
&lt;p>OPTIONS&lt;/p>
&lt;ul>
&lt;li>-i #在指定网络接口上监听 DHCPv4 / BOOTP 查询。&lt;/li>
&lt;/ul>
&lt;p>EXAMPLE&lt;/p>
&lt;ul>
&lt;li>dhcrelay 192.168.10.12 # 在本机开启 dhcp 中继代理，指定目的 DHCP 服务器 IP 为 192.168.10.12&lt;/li>
&lt;/ul>
&lt;h1 id="dhcpv6-与-radvd">DHCPv6 与 radvd&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://access.redhat.com/documentation/zh-cn/red_hat_enterprise_linux/8/html/configuring_and_managing_networking/providing-dhcp-services_configuring-and-managing-networking#comparison-of-dhcpv6-to-radvd_providing-dhcp-services">https://access.redhat.com/documentation/zh-cn/red_hat_enterprise_linux/8/html/configuring_and_managing_networking/providing-dhcp-services_configuring-and-managing-networking#comparison-of-dhcpv6-to-radvd_providing-dhcp-services&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>在 IPv6 网络中，只有路由器广告信息在 IPv6 默认网关上提供信息。因此，如果您要在需要默认网关设置的子网中使用 DHCPv6，还必须配置路由器广告服务，如 Router Advertisement Daemon（radvd）。&lt;/p>
&lt;p>radvd 服务使用路由器广告数据包中的标记声明 DHCPv6 服务器可用。&lt;/p>
&lt;p>路由器广告守护进程（radvd）发送路由器公告信息，这是 IPv6 无状态自动配置所需的。这可让用户根据这些公告自动配置其地址、设置、路由和选择默认路由器。
本节中的步骤解释了如何配置 radvd。
&lt;strong>先决条件&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>您以 root 用户身份登录。&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>流程&lt;/strong>&lt;/p>
&lt;ol>
&lt;li>安装 radvd 软件包：# yum install radvd&lt;/li>
&lt;li>编辑 /etc/radvd.conf 文件并添加以下配置：&lt;/li>
&lt;/ol>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-properties" data-lang="properties">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">interface&lt;/span> &lt;span style="color:#e6db74">ens3&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#960050;background-color:#1e0010">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">AdvSendAdvert&lt;/span> &lt;span style="color:#e6db74">on;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">AdvManagedFlag&lt;/span> &lt;span style="color:#e6db74">on;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">AdvOtherConfigFlag&lt;/span> &lt;span style="color:#e6db74">on;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">prefix&lt;/span> &lt;span style="color:#e6db74">2001:db8:0:1::/64 {&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#960050;background-color:#1e0010"> };&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#960050;background-color:#1e0010">};&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ol start="3">
&lt;li>这些设置将 radvd 配置为在 enp1s0 设备中为 2001:db8:0:1::/64 子网发送路由器广告信息。AdvManagedFlag on 设置定义客户端应该从 DHCP 服务器接收 IP 地址，AdvOtherConfigFlag 参数设置为 on 定义客户端也应该从 DHCP 服务器接收非地址信息。&lt;/li>
&lt;li>（可选）配置 radvd 会在系统引导时自动启动：# systemctl enable radvd&lt;/li>
&lt;li>启动 radvd 服务：# systemctl start radvd&lt;/li>
&lt;li>另外，还可显示路由器公告软件包的内容和配置的值 radvd 发送：# radvdump&lt;/li>
&lt;/ol>
&lt;p>&lt;strong>其它资源&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>有关配置 radvd 的详情，请查看 radvd.conf(5) man page。&lt;/li>
&lt;li>如需 radvd 的示例配置，请参阅 /usr/share/doc/radvd/radvd.conf.example 文件。&lt;/li>
&lt;/ul></description></item><item><title>Docs: 7.FTP</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/4.%E6%95%B0%E6%8D%AE%E9%80%9A%E4%BF%A1/%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/7.ftp/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/4.%E6%95%B0%E6%8D%AE%E9%80%9A%E4%BF%A1/%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/7.ftp/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;p>&lt;strong>File Transfer Protocol(文件传输协议，简称 FTP)&lt;/strong> 是因特网网络上历史最悠久的网络工具，从 1971 年由 A KBHUSHAN 提出第一个 FTP 的 RFC（RFC114） [2] 至今近半个世纪来，FTP 凭借其独特的优势一直都是因特网中最重要、最广泛的服务之一。 [3]&lt;/p>
&lt;p>FTP 的目标是提高文件的共享性，提供非直接使用远程计算机，使存储介质对用户透明和可靠高效地传送数据。它能操作任何类型的文件而不需要进一步处理，就像 MIME 或 Unicode 一样。但是，FTP 有着极高的延时，这意味着，从开始请求到第一次接收需求数据之间的时间，会非常长；并且不时的必须执行一些冗长的登录进程。 [4-5]&lt;/p></description></item><item><title>Docs: 7.HTTP</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/4.%E6%95%B0%E6%8D%AE%E9%80%9A%E4%BF%A1/%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/7.http/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/4.%E6%95%B0%E6%8D%AE%E9%80%9A%E4%BF%A1/%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/7.http/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://tools.ietf.org/html/rfc2616">RFC 2616&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://developer.mozilla.org/en-US/docs/Web/HTTP">Mozilla 官方 HTTP 开发文档&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://mp.weixin.qq.com/s/bUy220-ect00N4gnO0697A">公众号-小林 coding，硬核！30 张图解 HTTP 常见的面试题&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://mp.weixin.qq.com/s/WQpxfwLArltKEjEAdOO2Pw">公众号-码海，51 张图助你彻底掌握 HTTP 协议&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>&lt;strong>HyperText Transfer Protocol(超文本传输协议，简称 HTTP)&lt;/strong>。是基于 TCP 的用于分布式、协作式、超媒体的信息系统的应用层协议。HTTP 是 &lt;a href="https://en.wikipedia.org/wiki/World_Wide_Web">World Wide Web(万维网,简称 WWW.就是我们俗称的 Web)&lt;/a> 的数据通信基础。&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/rlkp9t/1616161240441-f2958719-b738-4698-9fca-64d90f3471ba.png" alt="">&lt;/p>
&lt;h2 id="http-标准的演化">HTTP 标准的演化&lt;/h2>
&lt;blockquote>
&lt;p>参考：&lt;a href="https://www.infoq.cn/article/2014/06/http-11-updated">InfoQ 中的消息&lt;/a>&lt;/p>
&lt;/blockquote>
&lt;p>在 2014 年之前，HTTP/1.1 版本的标准为 &lt;a href="https://tools.ietf.org/html/rfc2616">RFC 2616&lt;/a>，但由于&lt;a href="https://tools.ietf.org/html/rfc7230#appendix-A.2">某些原因&lt;/a>，为了让标准更规范，HTTP/1.1 被拆分成了 6 个部分：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://tools.ietf.org/html/rfc7230">RFC7230 - HTTP/1.1&lt;/a>: Message Syntax and Routing(消息语法和路由)。这里包含 低级的消息解析 和 链接管理。&lt;/li>
&lt;li>&lt;a href="https://tools.ietf.org/html/rfc7231">RFC7231 - HTTP/1.1&lt;/a>: Semantics and Content(语意和内容)。这里面包含了 Methods、Status Codes、Headers&lt;/li>
&lt;li>RFC7232 - HTTP/1.1: Conditional Requests - e.g., If-Modified-Since&lt;/li>
&lt;li>RFC7233 - HTTP/1.1: Range Requests - getting partial content&lt;/li>
&lt;li>RFC7234 - HTTP/1.1: Caching - browser and intermediary caches&lt;/li>
&lt;li>RFC7235 - HTTP/1.1: Authentication - a framework for HTTP authentication&lt;/li>
&lt;/ul>
&lt;h2 id="http-三个部分">HTTP 三个部分&lt;/h2>
&lt;h3 id="1-协议">1. 「协议」&lt;/h3>
&lt;p>在生活中，我们也能随处可见「协议」，例如：&lt;/p>
&lt;ul>
&lt;li>刚毕业时会签一个「三方协议」；&lt;/li>
&lt;li>找房子时会签一个「租房协议」；&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/rlkp9t/1616161240448-b1263f75-a700-4431-9d6b-a99b36a58214.png" alt="">
三方协议和租房协议&lt;/p>
&lt;p>生活中的协议，本质上与计算机中的协议是相同的，协议的特点:&lt;/p>
&lt;ul>
&lt;li>「&lt;strong>协&lt;/strong>」字，代表的意思是必须有&lt;strong>两个以上的参与者&lt;/strong>。例如三方协议里的参与者有三个：你、公司、学校三个；租房协议里的参与者有两个：你和房东。&lt;/li>
&lt;li>「&lt;strong>议&lt;/strong>」字，代表的意思是对参与者的一种&lt;strong>行为约定和规范&lt;/strong>。例如三方协议里规定试用期期限、毁约金等；租房协议里规定租期期限、每月租金金额、违约如何处理等。&lt;/li>
&lt;/ul>
&lt;p>针对 HTTP &lt;strong>协议&lt;/strong>，我们可以这么理解。&lt;/p>
&lt;p>HTTP 是一个用在计算机世界里的&lt;strong>协议&lt;/strong>。它使用计算机能够理解的语言确立了一种计算机之间交流通信的规范（&lt;strong>两个以上的参与者&lt;/strong>），以及相关的各种控制和错误处理方式（&lt;strong>行为约定和规范&lt;/strong>）。&lt;/p>
&lt;h3 id="2-传输">2. 「传输」&lt;/h3>
&lt;p>所谓的「传输」，很好理解，就是把一堆东西从 A 点搬到 B 点，或者从 B 点 搬到 A 点。&lt;/p>
&lt;p>别轻视了这个简单的动作，它至少包含两项重要的信息。&lt;/p>
&lt;p>HTTP 协议是一个&lt;strong>双向协议&lt;/strong>。&lt;/p>
&lt;p>我们在上网冲浪时，浏览器是请求方 A ，百度网站就是应答方 B。双方约定用 HTTP 协议来通信，于是浏览器把请求数据发送给网站，网站再把一些数据返回给浏览器，最后由浏览器渲染在屏幕，就可以看到图片、视频了。
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/rlkp9t/1616161240434-514ef4d5-6830-46f1-9674-7c6564798dfd.png" alt="">
Request(请求) - (Response)应答&lt;/p>
&lt;p>数据虽然是在 A 和 B 之间传输，但允许中间有&lt;strong>中转或接力&lt;/strong>。&lt;/p>
&lt;p>就好像第一排的同学想传递纸条给最后一排的同学，那么传递的过程中就需要经过好多个同学（中间人），这样的传输方式就从「A &amp;lt; &amp;mdash; &amp;gt; B」，变成了「A &amp;lt;-&amp;gt; N &amp;lt;-&amp;gt; M &amp;lt;-&amp;gt; B」。&lt;/p>
&lt;p>而在 HTTP 里，需要中间人遵从 HTTP 协议，只要不打扰基本的数据传输，就可以添加任意额外的东西。&lt;/p>
&lt;p>针对&lt;strong>传输&lt;/strong>，我们可以进一步理解了 HTTP。&lt;/p>
&lt;p>HTTP 是一个在计算机世界里专门用来在&lt;strong>两点之间传输数据&lt;/strong>的约定和规范。&lt;/p>
&lt;h3 id="3-超文本">3. 「超文本」&lt;/h3>
&lt;p>HTTP 传输的内容是「超文本」。&lt;/p>
&lt;p>我们先来理解「文本」，在互联网早期的时候只是简单的字符文字，但现在「文本」的涵义已经可以扩展为图片、视频、压缩包等，在 HTTP 眼里这些都算作「文本」。&lt;/p>
&lt;p>再来理解「超文本」，它就是&lt;strong>超越了普通文本的文本&lt;/strong>，它是文字、图片、视频等的混合体，最关键有超链接，能从一个超文本跳转到另外一个超文本。&lt;/p>
&lt;p>HTML 格式的文件就是最常见的超文本了，它本身只是纯文字文件，但内部用很多标签定义了图片、视频等的链接，再经过浏览器的解释，呈现给我们的就是一个文字、有画面的网页了。&lt;/p>
&lt;h2 id="总结">总结&lt;/h2>
&lt;p>OK，经过了对 HTTP 里这三个名词的详细解释，就可以给出比「超文本传输协议」这七个字更准确更有技术含量的答案：&lt;/p>
&lt;p>&lt;strong>HTTP 是一个在计算机世界里专门在「两点」之间「传输」文字、图片、音频、视频等「超文本」数据的「约定和规范」。&lt;/strong>&lt;/p>
&lt;blockquote>
&lt;p>这里的两点可以是服务器到本地电脑，本地电脑到服务器、服务器到服务器、电脑到电脑，等等。&lt;/p>
&lt;/blockquote>
&lt;h1 id="http-请求过程概述">HTTP 请求过程概述&lt;/h1>
&lt;p>HTTP 事务由一次 &lt;strong>Client 的 Request(请求)&lt;/strong> 和 &lt;strong>Server 的 Response(响应)&lt;/strong> 组成。即 HTTP 协议是 Stateless(无状态)。(因为连接一次后就断开了，不会持久化存储任何数据)&lt;/p>
&lt;p>比如一个用户(Client 客户端)向服务器发起了一个请求，请求一个页面，在该页面输入完用户名和密码后进行登录后，如果刷新页面，那么就需要重新输入用户名和密码，因为 client 向 server 只请求了一个页面，请求完成后，连接就断开了，后续的请求是新的，没法再用以前的信息。这时候为了解决该问题，引用了 Cookie 和 Session 保持 的概念。&lt;/p>
&lt;p>相关技术&lt;/p>
&lt;ol>
&lt;li>Cookie：类似于 Token，相当于一个令牌，当访问一个 web server 的时候，server 发给 client 一个 Cookie，让 client 保存在本地，再次访问的时候，即可通过该 Cookie 识别身份&lt;/li>
&lt;li>Session(会话)保持：关联至 Cookie：当你在动态网页上访问了一些信息，比如购物车，在购物车添加一件物品，即通过 Session 功能来保存该信息，以便下次登录还能使用。否则下次登录购物车中的东西就没了&lt;/li>
&lt;/ol>
&lt;h2 id="流程简述">流程简述&lt;/h2>
&lt;ul>
&lt;li>建立或处理连接，接收请求或拒绝请求
&lt;ul>
&lt;li>建立 TCP 连接，WEB 浏览器向 Web 服务器发送请求&lt;/li>
&lt;li>web 浏览器发送请求头部信息
&lt;ul>
&lt;li>建立连接后，客户机发送一个请求给服务器，请求方式的格式为：URL、协议版本号、后面是 MIME 信息包括请求修饰符、客户机信息和可能得内容&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Server 接收请求，并应答
&lt;ul>
&lt;li>WEB 服务器接收到请求后，给予相应的响应信息，其格式为一个状态行，包括信息的协议版本号、一个成功或错误的代码，后边是 MIME 信息包括服务器信息、实体信息和可能得内容&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Server 处理请求
&lt;ul>
&lt;li>Web 服务器发送应答头信息&lt;/li>
&lt;li>Web 服务器向浏览器发送数据&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Client 访问资源
&lt;ul>
&lt;li>WEB 服务器关闭 TCP 连接&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>构建响应报文&lt;/li>
&lt;li>发送响应报文&lt;/li>
&lt;li>记录日志&lt;/li>
&lt;/ul>
&lt;h1 id="http-报文格式">HTTP 报文格式&lt;/h1>
&lt;h2 id="request-与-response-报文">Request 与 Response 报文&lt;/h2>
&lt;h3 id="request-请求报文">Request 请求报文&lt;/h3>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/rlkp9t/1616161240468-d9f13310-3f67-43b8-b5b7-b48dde683170.png" alt="">&lt;/p>
&lt;ul>
&lt;li>&lt;strong>Method&lt;/strong> # 请求方法，用于表明 Client 希望 Server 对 Resource 执行的动作。常用：GET、POST、DELETE&lt;/li>
&lt;li>&lt;strong>URL&lt;/strong> # HTTP 请求的 URL。
&lt;ul>
&lt;li>&lt;strong>Params&lt;/strong> # URL 参数。就是 URL 中的 Query 部分&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>Version&lt;/strong> # 发送给 Server 的请求的 HTTP 协议版本。&lt;/li>
&lt;li>**Headers **# 请求头。&lt;/li>
&lt;li>**Body **# 请求体。&lt;/li>
&lt;/ul>
&lt;blockquote>
&lt;p>这里面有一个要注意的地方，就是 Params 与 Headers，&lt;strong>Params 是 URL 的一部分&lt;/strong>，但是 Headers 不是。虽然两者的作用类似，都是用来定义这个请求中应该发送给对方的一些基本信息、认证信息 等等。但是在一个 HTTP 的请求中，两者所处的位置是不一样，用于不同场景。&lt;/p>
&lt;/blockquote>
&lt;p>&lt;strong>Authorization&lt;/strong> # 认证信息。这是一个比较特殊的东西，可以存在于 URL 的 Params 中、Headers 中、Body 中。请求报文的各个部分，都可以填写认证信息。&lt;/p>
&lt;ul>
&lt;li>当 Server 需要一个认证信息时，就需要在 HTTP 请求中加入认证相关的信息。&lt;/li>
&lt;/ul>
&lt;h4 id="example">EXAMPLE&lt;/h4>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/rlkp9t/1616161240442-63d3fc7f-80c2-43e4-bec5-50061f2e02f2.png" alt="">&lt;/p>
&lt;h3 id="response-响应报文">Response 响应报文&lt;/h3>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/rlkp9t/1616161240462-a29c9d65-119a-4b70-993f-bd1a4cfbbd7e.png" alt="">&lt;/p>
&lt;ul>
&lt;li>&lt;strong>Version&lt;/strong> # 响应给 Client 的 HTTP 版本。&lt;/li>
&lt;li>&lt;strong>Status&lt;/strong> # HTTP 响应状态。用来标记请求过程中发生的情况，由 server 告诉 client。响应状态由两部分组成&lt;/li>
&lt;li>&lt;strong>StatusCode&lt;/strong> # 状态码。统一为 3 位的数字。
&lt;ul>
&lt;li>各个状态码的含义，见&lt;a href="https://www.yuque.com/go/doc/33218939">状态码详解章节&lt;/a>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>**ReasonPhrase **# 原因短语。用来表示产生该状态的原因的简要说明&lt;/li>
&lt;li>&lt;strong>Headers&lt;/strong> # 响应头。&lt;/li>
&lt;li>&lt;strong>Body&lt;/strong> # 响应体。实体部分，请求时附加的数据或响应时附加的数据&lt;/li>
&lt;/ul>
&lt;h4 id="example-1">EXAMPLE&lt;/h4>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/rlkp9t/1616161240440-85fac56c-d3ed-44dc-94f3-20d60017e622.png" alt="">&lt;/p>
&lt;h2 id="http-header">HTTP Header&lt;/h2>
&lt;blockquote>
&lt;p>参考：&lt;a href="https://tools.ietf.org/html/rfc2616">RFC 2616&lt;/a>&lt;/p>
&lt;/blockquote>
&lt;p>HTTP 请求和响应报文的 Header(头) 基本都是 Key/Value(键值) 格式，Key 与 Value 以冒号分隔，此外，除了标准的头部字段之外，还可以添加自定义头，这就给 HTTP 带来了无限的扩展可能。注意，Value 不区分大小写。&lt;/p>
&lt;p>HTTP 协议规定了非常多的 Header 字段，可以实现各种各样的功能，但基本上可以分为以下四类&lt;/p>
&lt;ol>
&lt;li>&lt;strong>General Header(通用头)&lt;/strong> # 在请求头和响应头里都可以出现；&lt;/li>
&lt;li>&lt;strong>Request Header(请求头)&lt;/strong> # 仅能出现在请求头里，进一步说明请求信息或者额外的附加条件；&lt;/li>
&lt;li>&lt;strong>Response Header(响应头)&lt;/strong> # 仅能出现在响应头里，补充说明响应报文的信息；&lt;/li>
&lt;li>&lt;strong>Entity Header(实体头)&lt;/strong> # 它实际上属于通用字段，但专门描述 body 的额外信息。&lt;/li>
&lt;li>&lt;strong>Extension Header(扩展头)&lt;/strong> # 不在标准规范中，可以通过自定义头实现更多定制化需求的 Header 信息。&lt;/li>
&lt;/ol>
&lt;p>&lt;strong>对 HTTP 报文的解析和处理其实本质上就是对头字段的处理&lt;/strong>，HTTP 的连接管理，缓存控制，内容协商等都是通过头字段来处理的，&lt;strong>理解了头字段，基本上也就理解了 HTTP&lt;/strong>，所以理解头字段非常重要。&lt;/p>
&lt;p>详见：&lt;a href="https://www.yuque.com/go/doc/33218949">HTTP 协议头部字段详解&lt;/a>&lt;/p>
&lt;p>注意：这种分类是在 RFC 2616 标准中定义的，在新的 RFC 7231 中，已经看不到这种分类了&lt;/p>
&lt;h2 id="http-的请求-method方法">HTTP 的请求 Method(方法)&lt;/h2>
&lt;p>根据 HTTP 标准，HTTP 请求可以使用多种请求方法。 HTTP 的 1.0 版本中只有三种请求方法： GET, POST 和 HEAD 方法。到了 1.1 版本时，新增加了五种请求方法：OPTIONS, PUT, DELETE, TRACE 和 CONNECT 方法。&lt;/p>
&lt;ul>
&lt;li>&lt;strong>GET&lt;/strong> # 从服务器获取了资源
&lt;ul>
&lt;li>请求指定的页面信息，并返回实体主体。&lt;/li>
&lt;li>GET 请求请提交的数据放置在 HTTP 请求协议头中，GET 方法通过 URL 请求来传递用户的输入，GET 方式的提交你需要用 Request.QueryString 来取得变量的值。&lt;/li>
&lt;li>GET 方法提交数据，可能会带来安全性的问题，数据被浏览器缓存。&lt;/li>
&lt;li>GET 请求有长度限制。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>HEAD&lt;/strong> # 只从 server 获取文档的响应首部（报文中的 Headers）
&lt;ul>
&lt;li>类似于 get 请求，只不过返回的响应中没有具体的内容，用于获取报头。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>POST&lt;/strong> # 向 server 发送要处理的数据
&lt;ul>
&lt;li>向指定资源提交数据进行处理请求（例如提交表单或者上传文件）。&lt;/li>
&lt;li>POST 请求可能会导致新的资源的建立和/或已有资源的修改。&lt;/li>
&lt;li>POST 方式提交时，你必须通过 Request.Form 来访问提交的内容&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>PUT&lt;/strong> # 将请求的主体存储在 server 上
&lt;ul>
&lt;li>从客户端向服务器传送的数据取代指定的文档的内容。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>DELETE&lt;/strong> # 请求删除 server 上通过 URL 指定的文档，DELETE 请求一般返回 3 种码
&lt;ul>
&lt;li>200（OK）——删除成功，同时返回已经删除的资源。&lt;/li>
&lt;li>202（Accepted）——删除请求已经接受，但没有被立即执行（资源也许已经被转移到了待删除区域）。&lt;/li>
&lt;li>204（No Content）——删除请求已经被执行，但是没有返回资源（也许是请求删除不存在的资源造成的）。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>OPTIONS&lt;/strong> #** **请求服务器返回对指定资源支持使用的请求方法
&lt;ul>
&lt;li>允许客户端查看服务器的性能。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>TRACE&lt;/strong> # 追踪请求到达 server 中间经过的 server agent
&lt;ul>
&lt;li>回显服务器收到的请求，主要用于测试或诊断。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h3 id="get-与-post">GET 与 POST&lt;/h3>
&lt;p>&lt;code>Get&lt;/code> 方法的含义是请求&lt;strong>从服务器获取资源&lt;/strong>，这个资源可以是静态的文本、页面、图片视频等。&lt;/p>
&lt;p>比如，你打开我的文章，浏览器就会发送 GET 请求给服务器，服务器就会返回文章的所有文字及资源。
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/rlkp9t/1649668233003-6c01ab91-90f8-4ea8-8095-5448302146e8.jpeg" alt="">
而&lt;code>POST&lt;/code> 方法则是相反操作，它向 &lt;code>URI&lt;/code> 指定的资源提交数据，数据就放在报文的 body 里。&lt;/p>
&lt;p>比如，你在我文章底部，敲入了留言后点击「提交」（&lt;strong>暗示你们留言&lt;/strong>），浏览器就会执行一次 POST 请求，把你的留言文字放进了报文 body 里，然后拼接好 POST 请求头，通过 TCP 协议发送给服务器。
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/rlkp9t/1649668232954-1a090cec-1a9c-4c11-a370-d49b4156cac3.jpeg" alt="">
GET 和 POST 方法都是安全和幂等的吗？&lt;/p>
&lt;p>先说明下安全和幂等的概念：&lt;/p>
&lt;ul>
&lt;li>在 HTTP 协议里，所谓的「安全」是指请求方法不会「破坏」服务器上的资源。&lt;/li>
&lt;li>所谓的「幂等」，意思是多次执行相同的操作，结果都是「相同」的。&lt;/li>
&lt;/ul>
&lt;p>那么很明显 &lt;strong>GET 方法就是安全且幂等的&lt;/strong>，因为它是「只读」操作，无论操作多少次，服务器上的数据都是安全的，且每次的结果都是相同的。&lt;/p>
&lt;p>&lt;strong>POST&lt;/strong> 因为是「新增或提交数据」的操作，会修改服务器上的资源，所以是&lt;strong>不安全&lt;/strong>的，且多次提交数据就会创建多个资源，所以&lt;strong>不是幂等&lt;/strong>的。&lt;/p></description></item><item><title>Docs: 7.HTTP</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/4.%E6%95%B0%E6%8D%AE%E9%80%9A%E4%BF%A1/%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/7.http/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/4.%E6%95%B0%E6%8D%AE%E9%80%9A%E4%BF%A1/%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/7.http/</guid><description/></item><item><title>Docs: 7.NTP</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/4.%E6%95%B0%E6%8D%AE%E9%80%9A%E4%BF%A1/%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/7.ntp/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/4.%E6%95%B0%E6%8D%AE%E9%80%9A%E4%BF%A1/%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/7.ntp/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;p>&lt;strong>Network Time Protocol(网络时间协议，简称 NTP)&lt;/strong> 是在数据网络潜伏时间可变的计算机系统之间通过分组交换进行时钟同步的一个网络协议，位于 OSI 模型的应用层。自 1985 年以来，NTP 是目前仍在使用的最古老的互联网协议之一。NTP 由特拉华大学的 David L. Mills 设计。&lt;/p>
&lt;p>NTP 意图将所有参与计算机的协调世界时（UTC）时间同步到几毫秒的误差内。[1]:3 它使用 Marzullo 算法的修改版来选择准确的时间服务器，其设计旨在减轻可变网络延迟造成的影响。NTP 通常可以在公共互联网保持几十毫秒的误差，并且在理想的局域网环境中可以实现超过 1 毫秒的精度。不对称路由和拥塞控制可能导致 100 毫秒（或更高）的错误。[2][3]&lt;/p>
&lt;p>该协议通常描述为一种主从式架构，但它也可以用在点对点网络中，对等体双方可将另一端认定为潜在的时间源。[1]:20 发送和接收时间戳采用用户数据报协议（UDP）的端口 123 实现。[4][5]这也可以使用广播或多播，其中的客户端在最初的往返校准交换后被动地监听时间更新。[3]NTP 提供一个即将到来闰秒调整的警告，但不会传输有关本地时区或夏时制的信息。[2][3]&lt;/p>
&lt;p>当前协议为版本 4（NTPv4），这是一个 RFC 5905 文档中的建议标准。它向下兼容指定于 RFC 1305 的版本 3。&lt;/p>
&lt;p>目录&lt;/p>
&lt;ul>
&lt;li>1 历史&lt;/li>
&lt;li>2 时钟层&lt;/li>
&lt;li>3 时间戳&lt;/li>
&lt;li>4 时钟同步算法&lt;/li>
&lt;li>5 软件实现&lt;/li>
&lt;li>5.1 参考实现&lt;/li>
&lt;li>5.2SNTP&lt;/li>
&lt;li>5.3Windows 时间服务&lt;/li>
&lt;li>5.4Ntimed&lt;/li>
&lt;li>6 闰秒&lt;/li>
&lt;li>72038 年问题&lt;/li>
&lt;li>8 安全问题&lt;/li>
&lt;li>9 参见&lt;/li>
&lt;li>10 备注&lt;/li>
&lt;li>11 参考资料&lt;/li>
&lt;li>12 拓展阅读&lt;/li>
&lt;li>13 外部链接&lt;/li>
&lt;/ul>
&lt;p>历史[编辑]&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/lqlu60/1616161444690-ae048176-3985-441b-86bb-8fcaf5569d90.jpeg" alt="">&lt;/p>
&lt;p>NTP 的设计者 David L. Mills。&lt;/p>
&lt;p>1979 年，网络时间同步技术在纽约的国家计算机会议上于运行在跨大西洋卫星网络的互联网服务上公开演示，这可能是该技术的首次公开演示。该技术后在 1981 年互联网工程笔记（IEN）173 中描述，并根据 RFC 778 文档开发为一个公开协议。该技术首先被部署在一个本地网络，作为 Hello 路由协议的一部分，并在 Fuzzball（一个用于网络原型的实验操作系统，已运行多年）中实现。&lt;/p>
&lt;p>现在还有其他的相关网络工具。这包括 Daytime 和 Time 协议用以记录事件时间，以及互联网控制消息协议和 IP 时间戳选项（RFC 781）。更多完整的同步系统，虽然缺乏 NTP 的数据分析和时钟规律算法，包括 Unix 守护进程 timed 在内的软件其使用选举算法为所有客户端指定服务器。以及数字时间同步服务（Digital Time Synchronization Service，DTSS）使用类似构 NTP 阶层模型的服务器层次结构。&lt;/p>
&lt;p>1985 年，NTPv0 被实现于 Fuzzball 和 Unix，文档化于 RFC 958 的 NTP 数据包头、和往返延迟和偏移计算都被留存至 NTPv4。尽管当时可用的计算机和网络相对较慢，但在跨大西洋链路上也获取了优于 100 毫秒的精度，在以太网网络上准确度为几十毫秒。&lt;/p>
&lt;p>1988 年，一个更完整的 NTPv1 协议规范及相关的算法发表在 RFC 1059。它利用了 RFC 956 的文献中的实验结果和时钟滤波算法，并是第一个描述客户端-服务器和点对点网络模型的版本。1991 年，NTPv1 架构、协议和算法通过 David L. Mills 在 IEEE Transactions on Communications 发布的一篇文章得到了工程学界的更广泛关注。&lt;/p>
&lt;p>1989 年，RFC 1119 发布通过有限状态机定义的 NTPv2，使用伪代码来描述其操作。它引入了一个管理协议和加密认证方案，它们留存至 NTPv4。社区批评 NTP 的设计缺乏形式正确性原则。他们的替代设计包括 Marzullo 算法，其修改版本已及时添加到 NTP。这个时代的大多数算法也大部分留存至 NTPv4。&lt;/p>
&lt;p>1992 年，RFC 1305 定义了 NTPv3。该 RFC 包括一个对所有错误来源的分析，从参考时钟至最终客户端，这使帮助度量和选择最佳服务器成为可能（在其中几个候选者反对的情况下）。广播模式被引入。&lt;/p>
&lt;p>在接下来的几年里，随着新特性的添加和算法的改进，显然还需要一个新的协议版本。[6]2010 年，RFC 5905 发布了一个对 NTPv4 的建议规范，但该协议自那时以来已经显著改变，截至 2014 年，更新的 RFC 尚未发布。[7]在 Mills 从特拉华大学退休后，该参考实现目前由 Harlan Stenn 保持为一个开放源代码项目。[8][9]&lt;/p>
&lt;p>时钟层[编辑]&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/lqlu60/1616161444688-dd02f9db-d4f3-4ba6-b2a1-10daf2c80df3.jpeg" alt="">&lt;/p>
&lt;p>美国海军天文台备用主时钟 Schriever AFB (Colorado)是一个第 0 层的 NTP 源&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/lqlu60/1616161444707-1f04a452-f5ae-4d30-abaa-6646e633ffa0.jpeg" alt="">&lt;/p>
&lt;p>黄色箭头表示直接连接；红色箭头表示网络连接。&lt;/p>
&lt;p>NTP 使用一个分层、半分层的时间源系统。该层次的每个级别被称为“stratum”，顶层分配为数字 0。一个通过阶层 n 同步的服务器将运行在阶层 n + 1。数字表示与参考时钟的距离，用于防止层次结构中的循环依赖性。阶层并不总是指示质量或可靠性；在阶层 3 的时间源得到比阶层 2 时间源更高的时间质量也很常见。电信系统对时钟层使用不同的定义。以下提供了阶层 0、1、2、3 的简要描述。&lt;/p>
&lt;p>阶层 0（Stratum 0）&lt;/p>
&lt;p>这些是高精度计时设备，例如原子钟（如铯、铷）、GPS 时钟或其他无线电时钟。它们生成非常精确的脉冲秒信号，触发所连接计算机上的中断和时间戳。阶层 0 设备也称为参考（基准）时钟。&lt;/p>
&lt;p>阶层 1&lt;/p>
&lt;p>这些与阶层 0 设备相连、在几微秒误差内同步系统时钟的计算机。阶层 1 服务器可能与其他阶层 1 服务器对等相连，以进行完整性检查和备份。[10]它们也被称为主要（primary）时间服务器。[2][3]&lt;/p>
&lt;p>阶层 2&lt;/p>
&lt;p>这些计算机通过网络与阶层 1 服务器同步。提供阶层 2 的计算机将查询多个阶层 1 服务器。阶层 2 计算机也可能与其他阶层 2 计算机对等相连，为对等组中的所有设备提供更健全稳定的时间。&lt;/p>
&lt;p>阶层 3&lt;/p>
&lt;p>这些计算机与阶层 2 的服务器同步。它们使用与阶层 2 相同的算法进行对等和数据采样，并可以自己作为服务器担任阶层 4 计算机，以此类推。&lt;/p>
&lt;p>阶层的上限为 15；阶层 16 被用于标识设备未同步。每台计算机上的 NTP 算法相互构造一个贝尔曼-福特算法最短路径生成树，以最小化所有客户端到阶层 1 服务器的累积往返延迟。[1]:20&lt;/p>
&lt;p>时间戳[编辑]&lt;/p>
&lt;p>NTP 使用 64 比特的时间戳，其中 32 位表示秒，32 位表示秒的小数，给出一个每 232 秒（136 年）才会翻转的时间尺度，理论分辨率 2−32 秒（233 皮秒）。NTP 以 1900 年 1 月 1 日作为开始时间，因此第一次翻转将在 2036 年 2 月 7 日发生。[11][12]&lt;/p>
&lt;p>NTP 的未来版本可能将时间表示扩展到 128 位：其中 64 位表示秒，64 位表示秒的小数。当前的 NTPv4 格式支持“时代数字”（Era Number）和“时代偏移”（Era Offset），正确使用它们应该有助于解决日期翻转问题。据 Mills 称：“64 位的秒小数足以分辨光子以光速通过电子所需的时间。64 位的秒足以提供明确的时间表示，直到宇宙变暗。”[13][note 1]&lt;/p>
&lt;p>时钟同步算法[编辑]&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/lqlu60/1616161444690-fed573bb-2fbf-45f7-b1db-69f4d664acee.jpeg" alt="">&lt;/p>
&lt;p>往返延迟时间 δ&lt;/p>
&lt;p>典型的 NTP 客户端将定期轮询不同网络上的三个或更多服务器。为同步其时钟，客户端必须计算其时间偏移量和来回通信延迟。时间偏移“θ”定义为：&lt;/p>
&lt;p>&lt;img src="" alt="">&lt;/p>
&lt;p>，&lt;/p>
&lt;p>往返延迟“δ”为：&lt;/p>
&lt;p>&lt;img src="" alt="">&lt;/p>
&lt;p>，&lt;/p>
&lt;p>其中：&lt;/p>
&lt;p>t0 是请求数据包传输的客户端时间戳，&lt;/p>
&lt;p>t1 是请求数据包回复的服务器时间戳，&lt;/p>
&lt;p>t2 是响应数据包传输的服务器时间戳&lt;/p>
&lt;p>t3 是响应数据包回复的客户端时间戳。[1]:19&lt;/p>
&lt;p>“θ”和“δ”的值通过过滤器并进行统计分析。异常值被剔除，并从最好的三个剩余候选中导出估算的时间偏移。然后调整时钟频率以逐渐减小偏移，创建一个反馈回路。[1]:20&lt;/p>
&lt;p>当客户端和服务器之间的输入和输出路由都具有对称的标称延迟时，同步是正确的。如果路由没有共同的标称延迟，则将差异取半作为测量误差。[14]&lt;/p>
&lt;p>软件实现[编辑]&lt;/p>
&lt;p>&lt;img src="" alt="">&lt;/p>
&lt;p>查询第二层服务器状态的 NTP 管理协议实用工具 ntpq。&lt;/p>
&lt;p>参考实现[编辑]&lt;/p>
&lt;p>NTP 参考实现连同协议的开发已持续发展了 20 多年。随着新功能的添加，向后兼容性仍保持不变。它包含几个敏感的算法，尤其是时钟规律，在同步到使用不同算法的服务器时可能会发生错误。该软件已移植到几乎各个计算平台，包括个人计算机。[1]:13 它在 Unix 上运行名为 ntpd 的守护进程，或在 Windows 上运行为一个 Windows 服务。[1]:15 支持参考时钟，并且以与远程服务器相同的方式对偏移进行过滤和分析，尽管它们通常更频繁地轮询。[1]:19&lt;/p>
&lt;p>SNTP[编辑]&lt;/p>
&lt;p>一个不太复杂的 NTP 实现，使用相同的协议但不需要存储较长时间的状态[15]，也称简单网络时间协议（Simple Network Time Protocol，SNTP）。它使用在某些嵌入式系统和不需要高精度时间的应用中。[16][17]&lt;/p>
&lt;p>Windows 时间服务[编辑]&lt;/p>
&lt;p>从 Windows 2000 起的所有 Microsoft Windows 版本都包括 Windows 时间服务（W32Time），[18]其具有将计算机时钟同步到 NTP 服务器的能力。&lt;/p>
&lt;p>W32Time 服务最初是为实现 Kerberos 第五版的身份验证协议，它需要误差 5 分钟内正确时间值以防止重放攻击。Windows 2000 和 Windows XP 中只实现了简单的 NTP，并在几个方面违反了 NTP 第 3 版的标准。[19]从 Windows Server 2003 和 Windows Vista 开始，已包括符合完整 NTP 的实现。[20]微软称 W32Time 服务不能可靠地将同步时间保持在 1 至 2 秒的范围内。[21]如果需要更高的精度，微软建议使用其他 NTP 实现。[22]&lt;/p>
&lt;p>Windows Server 2016 现在在某些操作条件下支持 1ms 的时间精度。[23]&lt;/p>
&lt;p>Ntimed[编辑]&lt;/p>
&lt;p>一个新的 NTP 客户端 ntimed 由 Poul-Henning Kamp 在 2014 年开始编写。[24]新的实现由 Linux 基金会赞助，作为参考实现的一个替代，因为它决定更容易地从头开始编写新的实现，而不是修复现有大型代码库的现有问题。截至 2015 年 6 月，它尚未正式发布，但 ntimed 可以可靠地同步时钟。[25]ntimed 在 Debian 和 FreeBSD 上工作，但也被移植到 Windows 和 Mac OS。[26]&lt;/p>
&lt;p>闰秒[编辑]&lt;/p>
&lt;p>在闰秒事件的当天，ntpd 从配置文件、附加参考时钟或远程服务器收到通知。因为时间必须是单调递增，所以闰秒的插入方式为：23:59:59、23:59:60、00:00:00。虽然时钟实际上在事件期间停止，但任何查询系统时间的进程都会使它增加微小的量，以保持事件的顺序。如果必要，在序列中删除闰秒的形式为：23:59:58、00:00:00，跳过 23:59:59。[27]&lt;/p>
&lt;p>2038 年问题[编辑]&lt;/p>
&lt;p>安全问题[编辑]&lt;/p>
&lt;p>2014 年底，几个安全问题被发现。在以前，研究人员发现 NTP 服务器可能受到中间人攻击的影响，除非数据包被加密和签名以验证身份。[28]但这所涉及的计算量在繁忙的服务器上可能是不切实际的，尤其是容易遭遇拒绝服务攻击。[29]NTP 消息欺骗可以被用来偏移客户端计算机上的时钟，并配合过期的加密密钥来完成其他攻击。[30]可能受到伪造 NTP 消息影响的服务包括 TLS、DNSSEC、各类缓存方案（例如 DNS 缓存）、比特币以及许多持久登录方案。[31][32]&lt;/p>
&lt;p>有着 25 年以上历史的 NTP 代码库中的参考实现中只发现了几个其他的安全问题，但最近[何时？]出现的几个引起了人们的强烈关注。[33][34]该协议正在对其整个历史进行修订和审查。截至 2011 年 1 月，在 NTP 规范中没有安全修订，也没有在 CERT 的报告。[35]几年来，该参考实现的当前代码库已经被多个来源进行安全审计，在当前发布的软件中没有已知的高风险漏洞。[36]&lt;/p>
&lt;p>多种 NTP 服务器误用和滥用实践的存在导致了对网络时间协议（NTP）服务器的破坏或劣化。&lt;/p>
&lt;p>NTP 已经被用于分布式拒绝服务（DDoS）攻击，[37][38]方法是将一个具有伪造的返回地址的小的查询发送到 NTP 服务器。类似 DNS 放大攻击，服务器将以比攻击者发送数据量大很多倍的数据量回复给伪造的目标。为了避免参与攻击，服务器可以配置为忽略外部查询，或者升级到 4.2.7p26 或更高版本。[39]&lt;/p>
&lt;p>一个缓存溢出漏洞已经被发现，并自 2014 年 12 月 19 日提供补丁。漏洞覆盖 NTP 第四版所有版本，自 4.2.8 修复。[40]苹果公司首次使用自动更新功能解决该问题[41]，不过这只适用最近的 MacOS 版本。在 10.6.8 版本中，用户可以手动修复服务器版本，以及普通用户可以在系统首选项-日期和时间中关闭自动更新时间。[42]研究人员认为该协议的设计是相当好的，缺陷出现在协议的实现中。某些错误很基础，例如例程中缺少返回语句，这可能导致某些运行在 root 权限下的 NTP 版本被利用以无限制的访问系统。守护进程不使用 root 权限的系统（例如 BSD）不受此缺陷的影响。[43]&lt;/p></description></item><item><title>Docs: 7.WebSocket</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/4.%E6%95%B0%E6%8D%AE%E9%80%9A%E4%BF%A1/%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/7.websocket/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/4.%E6%95%B0%E6%8D%AE%E9%80%9A%E4%BF%A1/%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/7.websocket/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/WebSocket">Wiki,WebSocket&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://mp.weixin.qq.com/s/TtRKkVxS6H-miQ8luQgY1A">公众号-小林 coding，有了 HTTP 协议，为什么还要有 websocket 协议？&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>WebSocket 是一种计算机通信协议，通过单个 TCP 连接提供&lt;strong>全双工&lt;/strong>通信通道。&lt;/p>
&lt;p>WebSocket 与 HTTP 不同。这两种协议都位于&lt;a href="https://en.wikipedia.org/wiki/OSI_model">OSI 模型的&lt;/a>&lt;a href="https://en.wikipedia.org/wiki/Layer_7">第 7 层&lt;/a>，并依赖于第 4 层的 TCP。尽管它们不同，但 &lt;a href="https://en.wikipedia.org/wiki/RFC_(identifier)">RFC&lt;/a>&lt;a href="https://datatracker.ietf.org/doc/html/rfc6455">6455&lt;/a> 指出 WebSocket“旨在通过 HTTP 端口 443 和 80 工作，并支持 HTTP 代理和中介” ，从而使其与 HTTP 兼容。为了实现兼容性，WebSocket &lt;a href="https://en.wikipedia.org/wiki/Handshaking">握手&lt;/a>使用 &lt;a href="https://en.wikipedia.org/wiki/HTTP/1.1_Upgrade_header">HTTP Upgrade 头&lt;/a>从 HTTP 协议更改为 WebSocket 协议。&lt;/p>
&lt;p>WebSocket 协议支持 &lt;a href="https://en.wikipedia.org/wiki/Web_browser">Web 浏览器&lt;/a>（或其他客户端应用程序）和 &lt;a href="https://en.wikipedia.org/wiki/Web_server">Web 服务器&lt;/a>之间的交互，其开销比半双工替代方案（例如 HTTP&lt;a href="https://en.wikipedia.org/wiki/Polling_(computer_science)">轮询）低&lt;/a>，从而促进从服务器到服务器的实时数据传输。这是通过为服务器提供一种标准化的方式来向客户端发送内容而无需客户端首先请求，并允许消息在保持连接打开的同时来回传递而实现的。通过这种方式，可以在客户端和服务器之间进行双向正在进行的对话。通信通常通过 TCP&lt;a href="https://en.wikipedia.org/wiki/Port_(computer_networking)">端口&lt;/a>完成数字 443（或在不安全连接的情况下为 80），这对于使用&lt;a href="https://en.wikipedia.org/wiki/Firewall_(computing)">防火墙&lt;/a>阻止非网络 Internet 连接的环境有益。类似的浏览器-服务器双向双向通信已经使用&lt;a href="https://en.wikipedia.org/wiki/Comet_(programming)">Comet&lt;/a>或&lt;a href="https://en.wikipedia.org/wiki/Adobe_Flash_Player">Adobe Flash Player&lt;/a>等临时技术以非标准化方式实现。&lt;a href="https://en.wikipedia.org/wiki/WebSocket#cite_note-2">[2]&lt;/a>&lt;/p>
&lt;p>大多数浏览器都支持该协议，包括&lt;a href="https://en.wikipedia.org/wiki/Google_Chrome">Google Chrome&lt;/a>、&lt;a href="https://en.wikipedia.org/wiki/Firefox">Firefox&lt;/a>、&lt;a href="https://en.wikipedia.org/wiki/Microsoft_Edge">Microsoft Edge&lt;/a>、&lt;a href="https://en.wikipedia.org/wiki/Internet_Explorer">Internet Explorer&lt;/a>、&lt;a href="https://en.wikipedia.org/wiki/Safari_(web_browser)">Safari&lt;/a>和&lt;a href="https://en.wikipedia.org/wiki/Opera_web_browser">Opera&lt;/a>。&lt;a href="https://en.wikipedia.org/wiki/WebSocket#cite_note-3">[3]&lt;/a>
与 HTTP 不同，WebSocket 提供全双工通信。&lt;a href="https://en.wikipedia.org/wiki/WebSocket#cite_note-4">[4]&lt;/a>&lt;a href="https://en.wikipedia.org/wiki/WebSocket#cite_note-quantum-5">[5]&lt;/a> 此外，WebSocket 支持基于 TCP 的消息流。TCP 单独处理字节流，而没有消息的固有概念。在 WebSocket 之前，使用&lt;a href="https://en.wikipedia.org/wiki/Comet_(programming)">Comet&lt;/a>通道可以实现端口 80 全双工通信；然而，Comet 的实现并不简单，并且由于 TCP 握手和 HTTP 标头开销，对于小消息来说效率低下。WebSocket 协议旨在在不损害 Web 安全假设的情况下解决这些问题。&lt;/p>
&lt;p>WebSocket 协议规范将 ws(WebSocket) 和 wss(WebSocket Secure) 定义为两种新的&lt;a href="https://en.wikipedia.org/wiki/Uniform_resource_identifier">统一资源标识符&lt;/a>(URI) 方案&lt;a href="https://en.wikipedia.org/wiki/WebSocket#cite_note-6">[6]&lt;/a>，分别用于未加密和加密连接。除了方案名称和&lt;a href="https://en.wikipedia.org/wiki/Fragment_identifier">片段&lt;/a>（即#不支持），其余的 URI 组件被定义为使用&lt;a href="https://en.wikipedia.org/wiki/Path_segment">URI 通用语法&lt;/a>。&lt;a href="https://en.wikipedia.org/wiki/WebSocket#cite_note-7">[7]&lt;/a>
使用浏览器开发人员工具，开发人员可以检查 WebSocket 握手以及 WebSocket 帧。&lt;a href="https://en.wikipedia.org/wiki/WebSocket#cite_note-8">[8]&lt;/a>&lt;/p>
&lt;h1 id="其他文章">其他文章&lt;/h1>
&lt;blockquote>
&lt;p>&lt;a href="https://mp.weixin.qq.com/s/38hgQ2zDBfl09tSruiwtDA">https://mp.weixin.qq.com/s/38hgQ2zDBfl09tSruiwtDA&lt;/a>&lt;/p>
&lt;/blockquote>
&lt;p>随着科技发展，人们需求越来越多，生活的方方面面都离不开一些实时信息。比如：疫情期间在家协同办公、疫情监控目标人的实时运动轨迹、社交中的实时消息、多玩家互动游戏、每秒瞬息万变的股市基金报价、体育实况播放、音视频聊天、视频会议、在线教育等等，都可以借用 WebSocket TCP 链接可以让数据飞起来。下面就聊一下 WebSocket 协议。&lt;/p>
&lt;p>WebSocket 是 HTML5 开始提供的一种浏览器与服务器间进行全双工通讯的网络技术,一种基于 TCP 连接上进行全双工通信的协议，相对于 HTTP 这种非持久的协议来说，WebSocket 是一个持久化网络通信的协议。依靠这种技术可以实现客户端和服务器端的长连接，双向实时通信。&lt;/p>
&lt;p>它不仅可以实现客户端请求服务器，同时可以允许服务端主动向客户端推送数据。是真正的双向平等对话，属于服务器推送技术的一种。在 WebSocket API 中，客户端和服务器只需要完成一次握手，两者之间就直接可以创建持久性的连接，并进行双向数据传输。&lt;/p>
&lt;p>&lt;strong>「其他特点包括：」&lt;/strong>&lt;/p>
&lt;blockquote>
&lt;ul>
&lt;li>建立在 TCP 协议之上，服务器端的实现比较容易。&lt;/li>
&lt;li>与 HTTP 协议有着良好的兼容性。默认端口也是 80 和 443，并且握手阶段采用 HTTP 协议，因此握手时不容易屏蔽，能通过各种 HTTP 代理服务器。&lt;/li>
&lt;li>数据格式比较轻量，性能开销小，通信高效。&lt;/li>
&lt;li>可以发送文本，也可以发送二进制数据。&lt;/li>
&lt;li>没有同源限制，客户端可以与任意服务器通信。&lt;/li>
&lt;li>协议标识符是 ws（如果加密，则为 wss），服务器网址就是 URL。&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>协议标识符是 ws（如果加密，则为 wss），服务器网址就是 URL&lt;/p>
&lt;p>&lt;code>ws://xxx.ayunw.cn:80/some/path wss://xxx.ayunw.cn:443/some/path&lt;/code>&lt;/p>
&lt;p>另外客户端不只是浏览器，只要实现了 ws 或者 wss 协议的客户端 socket 都可以和服务器进行通信。&lt;/p>
&lt;h3 id="先说一下为什么需要-websocket-协议">先说一下为什么需要 WebSocket 协议?&lt;/h3>
&lt;p>在 Web 应用架构中，连接由 HTTP/1.0 和 HTTP/1.1 处理。HTTP 是客户端/服务器模式中 请求一响应 所用的协议，在这种模式中，客户端(一般是浏览器)向服务器提交 HTTP 请求，服务器响应请求的资源(例如 HTML 页面)。&lt;/p>
&lt;p>HTTP 是无状态的，也就是说，它将每个请求当成唯一和独立的。无状态协议具有一些优势，例如，服务器不需要保存有关会话的信息，从而不需要存储数据。但是，这也意味着在每次 HTTP 请求和响应中都会发送关于请求的冗余信息，比如使用 Cookie 进行用户状态的验证。&lt;/p>
&lt;p>随着客户端和服务器之间交互的增加，HTTP 协议在客户端和服务器之间通信所需要的信息量快速增加。&lt;/p>
&lt;p>从根本上讲，HTTP 还是 半双工 的协议，也就是说，在同一时刻信息的流向只能单向的：客户端向服务器发送请求(单向)，然后服务器响应请求(单向)。半双工方式的通信效率是非常低的。&lt;/p>
&lt;p>同时 HTTP 协议有一个缺陷：通信只能由客户端发起。&lt;/p>
&lt;p>这种单向请求的特点，注定了如果服务器有状态变化，是无法主动通知客户端的。&lt;/p>
&lt;p>为了能够及时的获取服务器的变化，我们尝试过各种各样的方式：&lt;/p>
&lt;blockquote>
&lt;ul>
&lt;li>轮询(polling)：每隔一段时间，就发出一个请求，了解服务器有没有新的信息。不精准，有延时，大量无效数据交换。&lt;/li>
&lt;li>长轮询( long polling)：客户端向服务器请求信息，并在设定的时间段内保持连接。直到服务器有新消息响应，或者连接超时，这种技术常常称作“挂起 GET”或“搁置 POST”。占用服务器资源，相对轮询并没有优势，没有标准化。&lt;/li>
&lt;li>流化技术：在流化技术中，客户端发送一个请求，服务器发送并维护一个持续更新和保持打开(可以是无限或者规定的时间段)的开放响应。每当服务器有需要交付给客户端的信息时，它就更新响应。服务器从不发出完成 HTTP 响应。代理和防火墙可能缓存响应，导致信息交付的延迟增加。&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>上述方法提供了近乎实时的通信，但是它们也涉及 HTTP 请求和响应首标，包含了许多附加和不必要的首标数据与延迟。此外，在每一种情况下，客户端都必须等待请求返回，才能发出后续的请求，而这显著地增加了延退。同时也极大地增加了服务器的压力。&lt;/p>
&lt;h3 id="什么是-websocket-协议">什么是 websocket 协议?&lt;/h3>
&lt;p>Websocket 其实是一个新协议，借用了 HTTP 的协议来完成一部分握手，只是为了兼容现有浏览器的握手规范而已。Websocket 是一种自然的全双工、双向、单套接字连接，解决了 HTTP 协议中不适合于实时通信的问题。&lt;/p>
&lt;p>&lt;strong>「一个典型的 Websocket 握手如下：」&lt;/strong>&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>GET /chat HTTP/1.1
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Host: server.example.com
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Upgrade: websocket
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Connection: Upgrade
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Sec-WebSocket-Key: x3JJHMbDL1EzLkh9GBhXDw&lt;span style="color:#f92672">==&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Sec-WebSocket-Protocol: chat, superchat
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Sec-WebSocket-Version: &lt;span style="color:#ae81ff">13&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Origin: http://example.com
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>其中 Websocket 的核心如下，它告诉 Apache、Nginx 等服务器：注意，我发起的是 Websocket 协议，快点帮我找到对应的助理处理而不是那个老土的 HTTP。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>Upgrade: websocket
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Connection: Upgrade
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;strong>「服务器返回如下：」&lt;/strong>&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>HTTP/1.1 &lt;span style="color:#ae81ff">101&lt;/span> Switching Protocols
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Upgrade: websocket
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Connection: Upgrade
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Sec-WebSocket-Accept: HSmrc0sMlYUkAGmm5OPpG2HaGWk&lt;span style="color:#f92672">=&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Sec-WebSocket-Protocol: chat
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>至此，HTTP 已经完成它所有工作了，接下来就是完全按照 Websocket 协议进行了。&lt;/p>
&lt;h1 id="tcp-segment-结构">TCP Segment 结构&lt;/h1>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/xgaggc/1669021238963-8fd674c5-92c0-408a-9c39-a1df68ed7e24.png" alt="">&lt;/p></description></item><item><title>Docs: 7.WebSocket</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/4.%E6%95%B0%E6%8D%AE%E9%80%9A%E4%BF%A1/%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/7.websocket/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/4.%E6%95%B0%E6%8D%AE%E9%80%9A%E4%BF%A1/%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/7.websocket/</guid><description/></item><item><title>Docs: TCP 与 HTTP</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/4.%E6%95%B0%E6%8D%AE%E9%80%9A%E4%BF%A1/%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/tcp-%E4%B8%8E-http/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/4.%E6%95%B0%E6%8D%AE%E9%80%9A%E4%BF%A1/%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/tcp-%E4%B8%8E-http/</guid><description>
&lt;h1 id="tcp-与-http-的-keep-alive">TCP 与 HTTP 的 Keep-Alive&lt;/h1>
&lt;p>原文链接：&lt;a href="https://mp.weixin.qq.com/s/25atTs4b-vORIx525ur_aw">https://mp.weixin.qq.com/s/25atTs4b-vORIx525ur_aw&lt;/a>&lt;/p>
&lt;p>大致问题是，&lt;strong>TCP 的 Keepalive 和 HTTP 的 Keep-Alive 是一个东西吗？&lt;/strong>
这是个好问题，应该有不少人都会搞混，因为这两个东西看上去太像了，很容易误以为是同一个东西。
事实上，&lt;strong>这两个完全是两样不同东西&lt;/strong>，实现的层面也不同：&lt;/p>
&lt;ul>
&lt;li>HTTP 的 Keep-Alive，是由&lt;strong>应用层（用户态）&lt;/strong> 实现的，称为 HTTP 长连接；&lt;/li>
&lt;li>TCP 的 Keepalive，是由 &lt;strong>TCP 层（内核态）&lt;/strong> 实现的，称为 TCP 保活机制；&lt;/li>
&lt;/ul>
&lt;p>接下来，分别说说它们。&lt;/p>
&lt;h3 id="http-的-keep-alive">HTTP 的 Keep-Alive&lt;/h3>
&lt;p>HTTP 协议采用的是「请求-应答」的模式，也就是客户端发起了请求，服务端才会返回响应，一来一回这样子。
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/aqay4l/1625643072489-5556e712-c824-499b-8a85-9df5b8de00a2.png" alt="">请求-应答
由于 HTTP 是基于 TCP 传输协议实现的，客户端与服务端要进行 HTTP 通信前，需要先建立 TCP 连接，然后客户端发送 HTTP   请求，服务端收到后就返回响应，至此「请求-应答」的模式就完成了，随后就会释放 TCP 连接。
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/aqay4l/1625643072516-f1e8278b-3248-4e10-b9a0-f1858df8238d.png" alt="">一个 HTTP 请求
如果每次请求都要经历这样的过程：建立 TCP -&amp;gt; 请求资源 -&amp;gt; 响应资源 -&amp;gt; 释放连接，那么此方式就是 &lt;strong>HTTP 短连接&lt;/strong>，如下图：
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/aqay4l/1625643072462-fff13ee3-a399-4f41-bfe9-443e85f007b1.png" alt="">HTTP 短连接
这样实在太累人了，一次连接只能请求一次资源。
能不能在第一个 HTTP 请求完后，先不断开 TCP 连接，让后续的 HTTP 请求继续使用此连接？
当然可以，HTTP 的 Keep-Alive 就是实现了这个功能，可以使用同一个 TCP 连接来发送和接收多个 HTTP 请求/应答，避免了连接建立和释放的开销，这个方法称为 &lt;strong>HTTP 长连接&lt;/strong>。
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/aqay4l/1625643072505-c0e7c75c-925f-4b8a-a791-1b44484decf0.png" alt="">HTTP 长连接
HTTP 长连接的特点是，只要任意一端没有明确提出断开连接，则保持 TCP 连接状态。
怎么才能使用 HTTP 的 Keep-Alive 功能？
在 HTTP 1.0 中默认是关闭的，如果浏览器要开启 Keep-Alive，它必须在请求的包头中添加：&lt;/p>
&lt;pre>&lt;code>Connection: Keep-Alive
&lt;/code>&lt;/pre>
&lt;p>然后当服务器收到请求，作出回应的时候，它也添加一个头在响应中：&lt;/p>
&lt;pre>&lt;code>Connection: Keep-Alive
&lt;/code>&lt;/pre>
&lt;p>这样做，连接就不会中断，而是保持连接。当客户端发送另一个请求时，它会使用同一个连接。这一直继续到客户端或服务器端提出断开连接。
&lt;strong>从 HTTP 1.1 开始， 就默认是开启了 Keep-Alive&lt;/strong>，如果要关闭 Keep-Alive，需要在 HTTP 请求的包头里添加：&lt;/p>
&lt;pre>&lt;code>Connection:close
&lt;/code>&lt;/pre>
&lt;p>现在大多数浏览器都默认是使用 HTTP/1.1，所以 Keep-Alive 都是默认打开的。一旦客户端和服务端达成协议，那么长连接就建立好了。
HTTP 长连接不仅仅减少了 TCP 连接资源的开销，而且这给 &lt;strong>HTTP 流水线&lt;/strong>技术提供了可实现的基础。
所谓的 HTTP 流水线，是&lt;strong>客户端可以先一次性发送多个请求，而在发送过程中不需先等待服务器的回应&lt;/strong>，可以减少整体的响应时间。
举例来说，客户端需要请求两个资源。以前的做法是，在同一个 TCP 连接里面，先发送 A 请求，然后等待服务器做出回应，收到后再发出 B 请求。HTTP 流水线机制则允许客户端同时发出 A 请求和 B 请求。
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/aqay4l/1625643072531-ffeb1c68-b44d-4176-888a-81045ac28a0a.webp" alt="">
右边为 HTTP 流水线机制
但是&lt;strong>服务器还是按照顺序响应&lt;/strong>，先回应 A 请求，完成后再回应 B 请求。
而且要等服务器响应完客户端第一批发送的请求后，客户端才能发出下一批的请求，也就说如果服务器响应的过程发生了阻塞，那么客户端就无法发出下一批的请求，此时就造成了「队头阻塞」的问题。
可能有的同学会问，如果使用了 HTTP 长连接，如果客户端完成一个 HTTP 请求后，就不再发起新的请求，此时这个 TCP 连接一直占用着不是挺浪费资源的吗？
对没错，所以为了避免资源浪费的情况，web 服务软件一般都会提供 &lt;code>keepalive_timeout&lt;/code> 参数，用来指定 HTTP 长连接的超时时间。
比如设置了 HTTP 长连接的超时时间是 60 秒，web 服务软件就会&lt;strong>启动一个定时器&lt;/strong>，如果客户端在完后一个 HTTP 请求后，在 60 秒内都没有再发起新的请求，&lt;strong>定时器的时间一到，就会触发回调函数来释放该连接。&lt;/strong>
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/aqay4l/1625643072526-84366250-09a5-4292-b738-0fc547c395cd.png" alt="">HTTP 长连接超时&lt;/p>
&lt;h3 id="tcp-的-keepalive">TCP 的 Keepalive&lt;/h3>
&lt;p>TCP 的 Keepalive 这东西其实就是 &lt;strong>TCP 的保活机制&lt;/strong>，它的工作原理我之前的文章写过，这里就直接贴下以前的内容。
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/aqay4l/1625643072529-348d0a2d-5281-4f91-8d76-88d983c3da06.png" alt="">
如果两端的 TCP 连接一直没有数据交互，达到了触发 TCP 保活机制的条件，那么内核里的 TCP 协议栈就会发送探测报文。&lt;/p>
&lt;ul>
&lt;li>如果对端程序是正常工作的。当 TCP 保活的探测报文发送给对端, 对端会正常响应，这样 &lt;strong>TCP 保活时间会被重置&lt;/strong>，等待下一个 TCP 保活时间的到来。&lt;/li>
&lt;li>如果对端主机崩溃，或对端由于其他原因导致报文不可达。当 TCP 保活的探测报文发送给对端后，石沉大海，没有响应，连续几次，达到保活探测次数后，&lt;strong>TCP 会报告该 TCP 连接已经死亡&lt;/strong>。&lt;/li>
&lt;/ul>
&lt;p>所以，TCP 保活机制可以在双方没有数据交互的情况，通过探测报文，来确定对方的 TCP 连接是否存活，这个工作是在内核完成的。
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/aqay4l/1625643072539-7c6779d8-119f-43d0-9307-990c29756ac7.png" alt="">TCP 保活机制
注意，应用程序若想使用 TCP 保活机制需要通过 socket 接口设置 &lt;code>SO_KEEPALIVE&lt;/code> 选项才能够生效，如果没有设置，那么就无法使用 TCP 保活机制。&lt;/p>
&lt;h3 id="总结">总结&lt;/h3>
&lt;p>HTTP 的 Keep-Alive 也叫 HTTP 长连接，该功能是由「应用程序」实现的，可以使得用同一个 TCP 连接来发送和接收多个 HTTP 请求/应答，减少了 HTTP 短连接带来的多次 TCP 连接建立和释放的开销。
TCP 的 Keepalive 也叫 TCP 保活机制，该功能是由「内核」实现的，当客户端和服务端长达一定时间没有进行数据交互时，内核为了确保该连接是否还有效，就会发送探测报文，来检测对方是否还在线，然后来决定是否要关闭该连接。&lt;/p></description></item><item><title>Docs: TCP 与 HTTP</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/4.%E6%95%B0%E6%8D%AE%E9%80%9A%E4%BF%A1/%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/tcp-%E4%B8%8E-http/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/4.%E6%95%B0%E6%8D%AE%E9%80%9A%E4%BF%A1/%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/tcp-%E4%B8%8E-http/</guid><description/></item><item><title>Docs: 通信协议</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/4.%E6%95%B0%E6%8D%AE%E9%80%9A%E4%BF%A1/%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/4.%E6%95%B0%E6%8D%AE%E9%80%9A%E4%BF%A1/%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Communication_protocol">Wiki,Communication Protocol&lt;/a>(通信协议)&lt;/li>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Encapsulation_(networking)">Wiki,Encapsulation&lt;/a>(封装)&lt;/li>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Protocol_data_unit">Wiki,PDU&lt;/a>
&lt;ul>
&lt;li>注：Wiki 中将网络层 PDU 描述为 Packet 不够准确，详见 RFC 1325&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Service_data_unit">Wiki,SDU&lt;/a>&lt;/li>
&lt;li>RFC,&lt;a href="https://datatracker.ietf.org/doc/html/rfc1325">1325&lt;/a>、&lt;a href="https://datatracker.ietf.org/doc/html/rfc1594">1594&lt;/a>、&lt;a href="https://datatracker.ietf.org/doc/html/rfc2664">2664&lt;/a>
&lt;ul>
&lt;li>这几个 RFC 是一些关于互联网的仅供参考的常见问答，里面包含一些名词解释，2664 是最新版&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;h1 id="网络系统的分层架构">网络系统的分层架构&lt;/h1>
&lt;p>因特网是一个极为复杂的系统，这个系统有许多部分：大量的应用程序和协议、各种类型的端系统、分组交换机和各种类型的链路级媒体 等等等等。面对这种巨大的复杂性，我们迫切得需要组织整个网络体系结构。&lt;/p>
&lt;p>网络设计者以 &lt;strong>Layer(分层)&lt;/strong> 的方式组织协议以及实现这些协议的硬件/软件。每个协议属于这些层次之一，各层的所有协议被统称为 &lt;strong>Protocol Stack(协议栈)&lt;/strong>。
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/bdmhzx/1628914014057-a14c5659-364a-4bfb-ad46-0dbec7375997.png" alt="image.png">&lt;/p>
&lt;h2 id="encapsulation封装">Encapsulation(封装)&lt;/h2>
&lt;p>&lt;strong>Encapsulation(封装)&lt;/strong> 是一种设计模块化通信协议的方法，是将上层数据经过处理，变为下层数据的过程。处理完成后的实体称为 &lt;strong>Protocol Data Unit(协议数据单元，简称 PDU) &lt;strong>或&lt;/strong> Service Data Unit(服务数据单元，简称 SDU)&lt;/strong>。&lt;/p>
&lt;blockquote>
&lt;p>PDU 与 SDU 通常来说可以一起理解，楞要说区别，可有有以下几点&lt;/p>
&lt;ul>
&lt;li>SDU 并不会跨主机，可以说，比如说同一个主机应用层往传输层发送的内容。而 PDU 则是两个不同主机，由 A 主机应用层发送到 B 主机应用层的内容。&lt;/li>
&lt;li>SDU 是 PDU 的一个子集&lt;/li>
&lt;li>SDU 是 PDU 中的一个 Payload(有效载荷)&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>比如，主机 A 要向主机 B 发送一条信息。这条信息就称为 &lt;strong>Data(数据)/Payload(有效载荷)&lt;/strong>。这条消息从主机 A 发送出去之前，会被各种协议进行处理，这个处理的过程，就是 Encapsulation(封装)，封装之后的产物就是 PDU，不同网络层的 PDU 叫法不同：&lt;/p>
&lt;ul>
&lt;li>**Message(报文) # **应用层的协议封装的 PDU
&lt;ul>
&lt;li>比如 HTTP Message(HTTP 报文)&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>**Segment(段) # **传输层的协议封装的 PDU
&lt;ul>
&lt;li>比如 TCP Segment(TCP 段)。为什么称为 Segment(段) 呢，可以想象，从应用层接收到的数据通常会大于 MSS(1460 Bytes)，只要大于 MSS 的数据，都会被分为一段一段的，逐一发送。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>**Datagram(数据报) # **网络层的协议封装的 PDU
&lt;ul>
&lt;li>比如 IP Datagram(IP 数据报)。当 IP Datagram 的大小超过 MTU 时，将会被 &lt;strong>Fragment(分片(动词))&lt;/strong>，被拆分的每一个部分称为 &lt;strong>Fragment(片(名词))&lt;/strong>
&lt;ul>
&lt;li>每一个 Framment 在很场景和日常交流中，也被称为 &lt;strong>Packet(包)&lt;/strong>，所以很多文档也将网络层协议封装的 PDU 称为 Packet&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>**Frame(帧) # **链路层的协议封装的 PDU&lt;/li>
&lt;li>**bit(比特) # **物理层的协议封装的 PDU&lt;/li>
&lt;/ul>
&lt;p>还有一个名词 &lt;strong>Packet(包)&lt;/strong> 具有更广泛和更严格的意义，甚至，可以把 Packet 当做 PDU 来看。这个术语使用松散，虽然某些互联网文献使用它来专门指，通过物理网络发送的数据，但很多其他文献将互联网视为分组交换网络，并将 IP Datagram 描述为 Packet(这一段描述可以在 &lt;a href="https://datatracker.ietf.org/doc/html/rfc1325#page-30">RFC1325-术语&lt;/a>中找到)。&lt;/p>
&lt;p>其实，Message、Segment，Datagram，Packet，Frame 是存在于同条记录中的，是基于所在协议层不同而取了不同的名字。我们可以用一个形象的例子对数据包的概念加以说明：我们在邮局邮寄产品时，虽然产品本身带有自己的包装盒，但是在邮寄的时候只用产品原包装盒来包装显然是不行的。必须把内装产品的包装盒放到一个邮局指定的专用纸箱里，这样才能够邮寄。这里，产品包装盒相当于数据包，里面放着的产品相当于可用的数据，而专用纸箱就相当于帧，且一个帧中通常只有一个数据包。&lt;/p>
&lt;h3 id="封装内的字段结构">封装内的字段结构&lt;/h3>
&lt;p>一个完整的 PDU 由两个字段组成&lt;/p>
&lt;ul>
&lt;li>&lt;strong>Header(首部)&lt;/strong> # 用来定义数据要传输的目标
&lt;ul>
&lt;li>不同协议的首部信息各不相同。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>Payload(有效载荷)&lt;/strong> # 需要传输的数据
&lt;ul>
&lt;li>可以表示为最原本的数据，从下层协议来看，也可以把上层协议封装而成的 SDU 当做 Payload。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>通过抓包工具，抓出来的包，在 Wireshark 上查看，就可以看到各种协议封装后，PDU 中的信息。这里以一个 HTTP 的响应包为例
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/bdmhzx/1629077712291-6d02d74d-54f4-494b-9b6f-1a850d99005e.png" alt="image.png">
可以看到每一层的封装信息，我们现在展开传输层，可以看到如下内容
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/bdmhzx/1629077829616-4487b427-08b0-4799-8d16-37e6e3717286.png" alt="image.png">&lt;/p>
&lt;p>如果展开网络层，则可以看到如下内容：
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/bdmhzx/1629078088587-4b67122f-443c-4e5e-a08b-41f438267ffb.png" alt="image.png">
这里就是 IP Datagram 首部的所有信息&lt;/p>
&lt;p>在 各个协议的详解中，可以看到各种首部的所有信息，与抓包显示出来的都是可以一一对上的。&lt;/p></description></item><item><title>Docs: 通信协议通用概念</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/4.%E6%95%B0%E6%8D%AE%E9%80%9A%E4%BF%A1/%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE%E9%80%9A%E7%94%A8%E6%A6%82%E5%BF%B5/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/4.%E6%95%B0%E6%8D%AE%E9%80%9A%E4%BF%A1/%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE%E9%80%9A%E7%94%A8%E6%A6%82%E5%BF%B5/</guid><description>
&lt;h1 id="mtu-与-mss">MTU 与 MSS&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Maximum_transmission_unit">Wiki,MTU&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Maximum_segment_size">Wiki,MSS&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>&lt;strong>Maximum Transmission Unit(即最大传输单元，简称 MTU)&lt;/strong> 是一个二层的概念；以太网最大的 mtu 就是 1500（它是不包含二层头部的，加上头部应该为 1518 bytes，2bit 的以太网类型+6bit 的 DMAC+6bit 的 SMAC+4bit 的 FCS），每个以太网帧都有最小的大小 64bytes，最大不能超过 1518bytes&lt;/p>
&lt;p>注：&lt;/p>
&lt;ol>
&lt;li>小于 64Bytes 的数据帧一般是由于以太网冲突产生的 “碎片”或者线路干扰或者坏的以太网接口产生的，对于大于 1518Bytes 的数据帧我们一般把它叫做 Giant 帧，这种一般是由于线路干扰或者坏的以太网口产生&lt;/li>
&lt;li>以太网 EthernetII 最大的数据帧是 1518Bytes，是指包含以太网帧的帧头（DMAC 目的 MAC 地址 48bit=6Bytes+SMAC 源 MAC 地址 48bit=6Bytes+Type 域 2bytes）14Bytes 和帧尾 CRC 校验部分 4Bytes （这个部份有时候大家也把它叫做 FCS）&lt;/li>
&lt;/ol>
&lt;p>IP MTU 是一个三层概念，它包含了三层头部及所有载荷，根据下层为上层服务的，上层基于下层才能做进一步的扩展的原则，尽管 IP MTU 的变化范围很大（68-65535），但也不得不照顾以太网 MTU 的限制,说白了就是 ip 对以太网的妥协。&lt;/p>
&lt;p>网络层 IP 协议会检查每个从上层协议下来的数据包的大小，并根据本机 MTU 的大小决定是否作“分片”处理&lt;/p>
&lt;p>&lt;strong>Maximum Segment Size(最大段长度，简称 MSS)&lt;/strong> 是 TCP 里面的一个概念，它是 TCP 数据包每次能够传输的最大数据分段，不包含包头部分，它与 IP MTU 满足如下关系：&lt;/p>
&lt;p>IP MTU=MSS+20bytes（IP 包头）+20bytes（TCP 包头）&lt;/p>
&lt;p>当然，如果传输的时候还承载有其他协议，还要加些包头在前面。&lt;/p>
&lt;p>注：为了达到最佳的传输效能，TCP 协议在建立连接的时候通常要协商双方的 MSS 值，这个值 TCP 协议在实现的时候往往用 MTU 值代替（需要减去 IP 数据包报头的大小 20Bytes 和 TCP 数据段的包头 20Bytes），所以往往 MSS 为 1460。通讯双方会根据双方提供的 MSS 值得最小值确定为这次连接的最大 MSS 值。&lt;/p>
&lt;p>4.简言之，mtu 就是总的最后发出去的报文大小，MSS 就是需要发出去的数据大小，比如 PPPoE，就是在以太网上承载 PPP 协议（点到点连接协议），它包括 6bytes 的 PPPoE 头部和 2bytes 的 PPP 协议 ID 号，此时，由于以太网的 MTU 值为 1500，所以上层 PPP 负载数据不能超过 1492 字节，也就是相当于在 PPPOE 环境下的 MTU 是 1492 字节，MSS 是 1452 字节（1492 字节-20-20）。&lt;/p>
&lt;p>重点：
MTU 不包含 帧头（18byte） 指帧头后面的所有负载，与 ip mtu 的区别就是在帧头和 ip 头之间可能会有其他协议头（比如 GRE 头、pppoe 头、MPLS 标签，这些协议头都是在帧头后 ip 头前）&lt;/p>
&lt;p>ip MTU 包含 ip 头（20byte） 指 ip 头本身及后面的所有负载，一个普通的以太网数据包 mtu=ip mut，只有封装了其他协议头部时 mtu=ip mut+其他协议头部+负载（tcp 头+tcp-mss）&lt;/p>
&lt;p>TCP-MSS 不包含 tcp 头（20byte） 指 tcp 头后面的所有负载&lt;/p>
&lt;p>IP MTU=tcp-MSS+20bytes（IP 包头）+20bytes（TCP 包头）&lt;/p>
&lt;p>&lt;a href="https://serverfault.com/questions/500448/mysterious-fragmentation-required-rejections-from-gateway-vm">https://serverfault.com/questions/500448/mysterious-fragmentation-required-rejections-from-gateway-vm&lt;/a>&lt;/p>
&lt;h1 id="mslrttttl">MSL、RTT、TTL&lt;/h1>
&lt;p>原文链接：&lt;a href="https://my.oschina.net/vbird/blog/1525869">https://my.oschina.net/vbird/blog/1525869&lt;/a>&lt;/p>
&lt;p>在&lt;a href="https://my.oschina.net/vbird/blog/1507479">《TCP 关闭状态分析》&lt;/a>一文中，段落“TIME_WAIT”中提到：
之后等待 2 个最大的报文存活周期（这是因为：一是保证残留网络报文不会被新连接接收而产生数据错乱，由于自己上一次发送的数据报文可能还残留在网络中，等待&lt;strong>2MSL&lt;/strong>时间可以保证所有残留的网络报文在自己关闭前都已经超时。二是确保自己最后 ACK 发送到对端，因为 ACK 发送也可能会发送失败，这时对端会重新发送 FIN，如果已经 CLOSED 了那么对端将收到 RST 而不是 ACK 了，这不符合 TCP 可靠关闭的策略。）
本文就从&lt;strong>MSL&lt;/strong>展开，再记录一些小知识点。&lt;/p>
&lt;h2 id="msl">MSL&lt;/h2>
&lt;p>Maximum Segment Lifetime 缩写，译为“报文最大生存时间”。它指的是任何报文在网络上存在的最长时间，超过这个时间的报文将会被丢弃。标准规范中规定 MSL 为 2 分钟，实际应用中常用的是 30s，1min 和 2min 等。
2MSL 即两倍的 MSL，TCP 的 TIME_WAIT 状态也称为&lt;strong>2MSL 等待状态&lt;/strong>，当 TCP 的一端发起主动关闭，在发出最后一个 ACK 包后，即第 3 次挥手完成后发送了第四次挥手的 ACK 包后就进入了 TIME_WAIT 状态，必须在此状态上停留两倍的 MSL 时间，等待 2MSL 时间主要目的是怕最后一个 ACK 包对方没收到，那么对方在超时后将重发第三次挥手的 FIN 包，主动关闭端接到重发的 FIN 包后可以再发一个 ACK 应答包。在 TIME_WAIT 状态时两端的端口不能使用，要等到 2MSL 时间结束才可继续使用。当连接处于 2MSL 等待阶段时任何迟到的报文段都将被丢弃。不过在实际应用中可以通过设置 &lt;strong>SO_REUSEADDR&lt;/strong>选项达到不必等待 2MSL 时间结束再使用此端口。&lt;/p>
&lt;p>在 &lt;a href="https://github.com/torvalds/linux/blob/v5.12/include/net/tcp.h#L121">Linux Kernel 5.12 版本的源码码&lt;/a> 可以看到默认值是 60&lt;/p>
&lt;h2 id="rtt">RTT&lt;/h2>
&lt;blockquote>
&lt;p>To this end, we define the** round-trip time (RTT)**, which is the time it takes for a small packet to travel from client to server and then back to the client.&lt;/p>
&lt;/blockquote>
&lt;p>&lt;strong>Round-Trip Time(往返时间，简称 RTT)&lt;/strong>，简单理解的话，RTT 指的是客户端到服务端往返所花费的时间。其实 RTT 的定义是一个很小的分组(这里的很小也就是说对于发送方来说“开始发送”和“发送完”是同一个时刻。换句话说这个分组是没有长度的，传输时延可以忽略不计)，从客户端发送到接收端再返回客户端的时间。TCP 三次握手中发送的 SYN、ACK 以及四次挥手中使用到的 FIN 的交换就是这样的例子，ping 命令使用的也是这么一个非常小的包来试探网络的情况。如果是长度不可忽略的分组，接收方在接收到最后一比特数据后才会发送 ACK，实际也等价于发送最后一 bit 到接收到 ACK 的时间间隔。
TCP 含有动态估算 RTT 的算法。TCP 还持续估算一个给定连接的 RTT，这是因为 RTT 受网络传输拥塞程序的变化而变化。&lt;/p>
&lt;h2 id="ttl">TTL&lt;/h2>
&lt;p>&lt;strong>Time To Live(存活时间，简称 TTL)&lt;/strong>。这个生存时间是由源主机设置（IP 头里有一个 TTL 域）初始值但不是存的具体时间，而是存储了一个 IP 数据报可以经过最大路由数，每经过一个处理它的路由器此值就减 1，当此值为 0 则数据报将被丢弃，同时发送 ICMP 报文通知源主机。
**注意：**域名也有 TTL 的概念，只是这里的 TTL 指的是 Time- To-Live，简单的说它表示一条域名解析记录在 DNS 服务器上缓存时间。当各地的 DNS 服务器接受到解析请求时，就会向域名指定的 DNS 服务器发出解析请求从而获得解析记录。在获得这个记录之后，记录会在 DNS 服务器中保存一段时间，这段时间内如果再接到这个域名的解析请求，DNS 服务器将不再向 DNS 服务器发出请求，而是直接返回刚才获得的记录。而这个记录在 DNS 服务器上保留的时间，就是 TTL 值。&lt;/p>
&lt;h1 id="heading">&lt;/h1>
&lt;h1 id="dmz-与-upnp">DMZ 与 UPnP&lt;/h1>
&lt;p>DMZ 主机的作用：设置 DMZ 主机，就是让一台内网电脑完全暴露在外网，也就是任何由外部发起的连接到路由的数据都会被转发到设定的内网主机。这样做的坏处就是路由无法提供自身的防火墙来保护内网的这台机器，存在一定的风险，一般情况下不推荐。&lt;/p></description></item></channel></rss>