<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>断念梦 – 3_4.TCP_IP</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/4.%E6%95%B0%E6%8D%AE%E9%80%9A%E4%BF%A1/%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/3_4.tcp_ip/</link><description>Recent content in 3_4.TCP_IP on 断念梦</description><generator>Hugo -- gohugo.io</generator><atom:link href="https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/4.%E6%95%B0%E6%8D%AE%E9%80%9A%E4%BF%A1/%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/3_4.tcp_ip/index.xml" rel="self" type="application/rss+xml"/><item><title>Docs: 3/4.TCP/IP</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/4.%E6%95%B0%E6%8D%AE%E9%80%9A%E4%BF%A1/%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/3_4.tcp_ip/3_4.tcp_ip/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/4.%E6%95%B0%E6%8D%AE%E9%80%9A%E4%BF%A1/%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/3_4.tcp_ip/3_4.tcp_ip/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://datatracker.ietf.org/doc/html/rfc791">RFC,791&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;h2 id="封装">封装&lt;/h2>
&lt;p>当应用程序用 TCP 传输数据时，数据被送入协议栈中，然后逐个通过每一层直到被当做一串比特流送入网络。其中每一层对收到的数据都要增加一些首部信息(有时还需要增加尾部信息)，过程如图所示：
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/oc8ill/1628821300980-52f384b2-d2c9-4227-a1c5-6481d6cbf20e.png" alt="image.png">
以太网帧的帧头和帧尾下面所标注的数字是典型以太网帧首部的字节查高难度。以太网数据帧的物理特性是其查高难度必须在 &lt;strong>46~1500 字节之间(也就是 MTU 的长度)&lt;/strong>&lt;/p>
&lt;blockquote>
&lt;p>注意：所有的 Internet 标准和大多数有关 TCP/IP 的书都使用 octe 这个术语来表示字节。使用这个过分雕琢的术语是有历史原因的，因为 TCP/IP 的很多工作都是在 DEC-10 系统上进行的，但是它并不使用 8bit 的字节。由于现在几乎所有的计算机系统都采用 8bit 的字节，因此我们在本书中使用 Byte(字节) 这个术语。&lt;/p>
&lt;/blockquote>
&lt;p>由于应用数据受 MSS 长度限制，IP 首部 + TCP 首部 + 应用数据受 MTU 长度限制。所以，当一个 IP 报文超过 MTU 时就会进行 &lt;strong>Packet(分片/分组)&lt;/strong>。分组既可以是一个 IP 数据报，也可以是 IP 数据报的一个 &lt;strong>Fragment(片段)&lt;/strong>。&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/oc8ill/1628821542180-6dae0209-e7ac-494e-b6f3-715ce143c6d5.png" alt="image.png">&lt;/p></description></item><item><title>Docs: IP</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/4.%E6%95%B0%E6%8D%AE%E9%80%9A%E4%BF%A1/%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/3_4.tcp_ip/ip/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/4.%E6%95%B0%E6%8D%AE%E9%80%9A%E4%BF%A1/%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/3_4.tcp_ip/ip/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://datatracker.ietf.org/doc/html/rfc791">RFC,791&lt;/a>(IP 规范)&lt;/li>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Internet_Protocol">Wiki,Internet Protocol&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/IPv4">Wiki,IPv4&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Mask_(computing)">Wiki,Mask(掩码)&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Classful_network">Wiki,Classful Network(分类网络)&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.iana.org/assignments/ipv4-address-space/ipv4-address-space.xhtml">IANA,IPv4 地址空间分配情况&lt;/a>
&lt;ul>
&lt;li>&lt;a href="https://www.apnic.net/">APNIC&lt;/a>(管理亚太地区的 IP 地址注册机构)
&lt;ul>
&lt;li>&lt;a href="https://ftp.apnic.net/stats/apnic/">APNIC,帮助-FTP 数据库&lt;/a>(亚太地区所有分配的 IP 地址信息)&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;a href="https://www.iana.org/assignments/iana-ipv4-special-registry/iana-ipv4-special-registry.xhtml">IANA,IPv4 特殊用途地址注册表&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>**Internet Protocol(互联网协议，简称 IP) ** 是&lt;a href="https://en.wikipedia.org/wiki/Internet_protocol_suite">互联网协议套件&lt;/a>(其中包含 TCP/IP)中的主要通信协议，用于跨网络边界中继数据报。它的路由功能可实现互联网络，并实质上建立了 Internet。&lt;/p>
&lt;blockquote>
&lt;p>&lt;strong>Internet protocol suite(互联网协议套件)&lt;/strong> 是互联网和类似计算机网络中使用的概念模型和通信协议集。由于该套件中的基本协议是 &lt;strong>TCP(传输控制协议)&lt;/strong> 和 &lt;strong>IP(互联网协议)&lt;/strong>，因此通常被称为 &lt;strong>TCP/IP&lt;/strong>。在其开发过程中，其版本被称为国防部（DoD）模型，因为联网方法的开发是由美国国防部通过 DARPA 资助的。它的实现是一个协议栈。&lt;/p>
&lt;/blockquote>
&lt;p>IP 基于数据包的 Header 中的 IP 地址，将数据包从源主机发送到目标主机。基于此目的，IP 还定义了数据包的封装结构、以及一种寻址方法。寻址方法用来使用源和目标的信息标记数据报。&lt;/p>
&lt;p>从历史上看，IP 是在 1974 年由 Vint Cerf 和 Bob Kahn 引入的原始 **Transmission Control Program(传输控制程序) **中的&lt;a href="https://en.wikipedia.org/wiki/Connectionless_communication">无连接&lt;/a>数据报服务。该服务由一项面向连接的服务补充，成为 &lt;a href="https://desistdaydream.github.io/docs/IT%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/4.%E6%95%B0%E6%8D%AE%E9%80%9A%E4%BF%A1/%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/3_4.TCP_IP/TCP.md">&lt;strong>Transmission Control Protocol(传输控制协议，简称 TCP)&lt;/strong>&lt;/a> 的基础。因此 IP 套件通常称为 TCP/IP。IP 的第一个版本是 IPv4，继任者是 IPv6&lt;/p>
&lt;h1 id="ipv4-地址">IPv4 地址&lt;/h1>
&lt;p>IPv4 地址最多使用 32 bit 表示，即最多 32 个 1，这 32 bit 以 &lt;code>点&lt;/code> 分割为 4 组，每组 8 bit，在使用时，使用十进制表示。比如：&lt;code>192.168.0.1&lt;/code>。
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/nahgxm/1633534934848-ca44c51a-c787-47e7-a82b-589b6f78124b.jpeg" alt="">&lt;/p>
&lt;h2 id="ipv4-地址结构">IPv4 地址结构&lt;/h2>
&lt;p>IPv4 地址的这 32 bit 可以分为两部分&lt;/p>
&lt;ul>
&lt;li>网络位 # n bit&lt;/li>
&lt;li>主机位 # 32 - n bit&lt;/li>
&lt;/ul>
&lt;p>这两个部分通过 &lt;strong>Subnet Mast(子网掩码)&lt;/strong> 来区分，子网掩码由一连串的 1 和 0 组成，遵从以下规则：&lt;/p>
&lt;ul>
&lt;li>1 对应网络位&lt;/li>
&lt;li>0 对应主机位&lt;/li>
&lt;li>1 和 0 不能交叉出现&lt;/li>
&lt;/ul>
&lt;p>将子网掩码和 IP 地址作“与”操作后，IP 地址的主机部分将被丢弃，剩余的是网络地址和子网地址。&lt;/p>
&lt;p>例如：一个 IP 地址为 10.2.45.1，子网掩码为 255.255.252.0，“与” 运算得到：10.2.44.0，则网络设备认为该 IP 地址的网络号与子网号为 10.2.44.0，属于 10.2.44.0/22 网络，其中/22 表示子网掩码长度为 22 位，即从前向后连续的 22 个 1。&lt;/p>
&lt;p>00001010.00000010.00101101.00000001
与运算
11111111.11111111.11111100.00000000
结果为
00001010.00000010.00101100.00000001 即 10.2.44.0&lt;/p>
&lt;h2 id="ipv4-地址分类">IPv4 地址分类&lt;/h2>
&lt;ul>
&lt;li>
&lt;p>&lt;strong>单播地址&lt;/strong>&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>类&lt;/th>
&lt;th>开头的 bit&lt;/th>
&lt;th>网络位 bit 数&lt;/th>
&lt;th>主机位 bit 数&lt;/th>
&lt;th>子网数量&lt;/th>
&lt;th>每个子网的地址数&lt;/th>
&lt;th>总地址数&lt;/th>
&lt;th>起始地址&lt;/th>
&lt;th>结束地址&lt;/th>
&lt;th>默认子网掩码&lt;/th>
&lt;th>&lt;a href="https://en.wikipedia.org/wiki/CIDR_notation">CIDR&lt;/a>&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>Class A&lt;/td>
&lt;td>0&lt;/td>
&lt;td>8&lt;/td>
&lt;td>24&lt;/td>
&lt;td>128 (27)&lt;/td>
&lt;td>16,777,216 (224)&lt;/td>
&lt;td>2,147,483,648 (231)&lt;/td>
&lt;td>0.0.0.0&lt;/td>
&lt;td>127.255.255.255&lt;a href="https://en.wikipedia.org/wiki/Classful_network#cite_note-5">[a]&lt;/a>&lt;/td>
&lt;td>255.0.0.0&lt;/td>
&lt;td>/8&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Class B&lt;/td>
&lt;td>10&lt;/td>
&lt;td>16&lt;/td>
&lt;td>16&lt;/td>
&lt;td>16,384 (214)&lt;/td>
&lt;td>65,536 (216)&lt;/td>
&lt;td>1,073,741,824 (230)&lt;/td>
&lt;td>128.0.0.0&lt;/td>
&lt;td>191.255.255.255&lt;/td>
&lt;td>255.255.0.0&lt;/td>
&lt;td>/16&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Class C&lt;/td>
&lt;td>110&lt;/td>
&lt;td>24&lt;/td>
&lt;td>8&lt;/td>
&lt;td>2,097,152 (221)&lt;/td>
&lt;td>256 (28)&lt;/td>
&lt;td>536,870,912 (229)&lt;/td>
&lt;td>192.0.0.0&lt;/td>
&lt;td>223.255.255.255&lt;/td>
&lt;td>255.255.255.0&lt;/td>
&lt;td>/24&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>组播地址&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>&lt;strong>D 类 224-239 224.0.0.0 ~ 239.255.255.255&lt;/strong>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>保留地址&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>&lt;strong>E 类 240 - 254 240.0.0.0 ~ 255.255.255.255&lt;/strong>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>特殊地址&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>&lt;strong>网络地址&lt;/strong> # 网络位不变，主机位全为 0 的 IP 地址代表网络本身&lt;/li>
&lt;li>&lt;strong>Broadcast Address(广播地址)&lt;/strong> # 网络位不变，主机位全为 1 的 IP 地址代表本网络的广播。是专门用于同时向网络中所有&lt;a href="https://baike.baidu.com/item/%E5%B7%A5%E4%BD%9C%E7%AB%99/217955">工作站&lt;/a>进行发送的一个&lt;strong>地址&lt;/strong>。在使用&lt;a href="https://baike.baidu.com/item/TCP%2FIP%20%E5%8D%8F%E8%AE%AE/2116790">TCP/IP 协议&lt;/a>的网络中，&lt;a href="https://baike.baidu.com/item/%E4%B8%BB%E6%9C%BA/455151">主机&lt;/a>&lt;a href="https://baike.baidu.com/item/%E6%A0%87%E8%AF%86/6396929">标识&lt;/a>段 host ID 为全 1 的 IP 地址为广播地址，广播的分组传送给 host ID 段所涉及的所有&lt;a href="https://baike.baidu.com/item/%E8%AE%A1%E7%AE%97%E6%9C%BA/140338">计算机&lt;/a>。例如，对于 10.1.1.0 （255.0.0.0 ）网段，其直播&lt;a href="https://baike.baidu.com/item/%E5%B9%BF%E6%92%AD/656406">广播&lt;/a>地址为 10.255.255.255 （255 即为 2 进制的 11111111 ），当发出一个目的地址为 10.255.255.255 的分组（&lt;a href="https://baike.baidu.com/item/%E5%B0%81%E5%8C%85/2017669">封包&lt;/a>）时，它将被分发给该&lt;a href="https://baike.baidu.com/item/%E7%BD%91%E6%AE%B5/11026985">网段&lt;/a>上的所有计算机。&lt;/li>
&lt;li>&lt;strong>Link Local(链路本地地址)&lt;/strong> # 169.254.0.0 ~ 169.254.255.255。用于&lt;a href="https://en.wikipedia.org/wiki/Link-local_address">链路本地地址&lt;/a>&lt;a href="https://en.wikipedia.org/wiki/IPv4#cite_note-rfc3927-9">[9]&lt;/a>两台主机之间的单个链路上时，否则指定 IP 地址，如将有通常被从检索到的&lt;a href="https://en.wikipedia.org/wiki/DHCP">DHCP&lt;/a>服务器。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>Private Network(私人网络地址)&lt;/strong>&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>名称&lt;/th>
&lt;th>&lt;a href="https://en.wikipedia.org/wiki/Classless_Inter-Domain_Routing">CIDR&lt;/a>&lt;/th>
&lt;th>地址范围&lt;/th>
&lt;th>地址数量&lt;/th>
&lt;th>描述&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>24-bit block&lt;/td>
&lt;td>10.0.0.0/8&lt;/td>
&lt;td>10.0.0.0 – 10.255.255.255&lt;/td>
&lt;td>16777216&lt;/td>
&lt;td>一个完整的 A 类地址 Single Class A.&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>20-bit block&lt;/td>
&lt;td>172.16.0.0/12&lt;/td>
&lt;td>172.16.0.0 – 172.31.255.255&lt;/td>
&lt;td>1048576&lt;/td>
&lt;td>Contiguous range of 16 Class B blocks.&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>16-bit block&lt;/td>
&lt;td>192.168.0.0/16&lt;/td>
&lt;td>192.168.0.0 – 192.168.255.255&lt;/td>
&lt;td>65536&lt;/td>
&lt;td>Contiguous range of 256 Class C blocks.&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;/li>
&lt;/ul>
&lt;h1 id="ipv4-datagram-结构">IPv4 Datagram 结构&lt;/h1>
&lt;p>IPv4 数据报被封装在链路层的 Frame 中&lt;/p>
&lt;p>IPv4 数据报首部共 14 个字段，其中 13 个是必须的，第 14 个是可选的。前 13 个字段长度固定为 20 Bytes，即 160 bit；第 14 个字段长度在 0 ~ 40 Bytes 之间。
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/nahgxm/1633533991076-2a9cb606-463a-4dd4-89c8-c3aae590c113.jpeg" alt="">
对照 WireShark 中展示的内容看，排除 &lt;code>[]&lt;/code> 中的内容，每一行就是首部中的一个字段
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/nahgxm/1633532862295-9b420f37-7a97-43b9-85c8-1e973ea1aa59.png" alt="image.png">&lt;/p>
&lt;ul>
&lt;li>&lt;strong>Version(版本)&lt;/strong> # IP 协议的版本号。IPv4 其版本号为 4，因此在这个字段上的值为“6”。&lt;/li>
&lt;li>&lt;strong>Internet Header Length(首部长度，简称 IHL)&lt;/strong> # 由于 Options 字段的长度是可变的。所以 IPv4 的首部长度也是可变的。该字段的值在 5 ~ 15 之间(该字段只有 4 bits，1111 即为 15)
&lt;ul>
&lt;li>首部长度的计算方式如下：&lt;code>IHL * 32 bits&lt;/code>。
&lt;ul>
&lt;li>若 IHL 的值为 5，也就是说 Options 字段为 0，那么 IPv4 首部长度就是 5 * 32 bits = 160 bits = 20 Bytes&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>就像上面的 IPv4 的 Datagram 结构图一样，每行都是 32 bit，不算 Options 字段和 Payload，那么刚好是 5 行。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>Differentiated Services Field&lt;/strong> # 差异化的服务字段，基本没啥用。。。。o(╯□╰)o
&lt;ul>
&lt;li>&lt;strong>Differentiated Services Code Point&lt;/strong> # 最初定义为 Type Of Service(服务类型，简称 TOS)，&lt;/li>
&lt;li>&lt;strong>Explicit Congestion Notification&lt;/strong> # 该字段定义在 RFC3168 中，&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>Total Length&lt;/strong> # 定义了整个 IP 数据报的大小，最小为 20 字节(Payload 字段无内容)，最大为 65535 字节。&lt;/li>
&lt;li>**Identification **# 主要用于唯一标识单个 IP 数据报的片段组。
&lt;ul>
&lt;li>一些实验工作建议将 ID 字段用于其他目的，例如添加数据包跟踪信息以帮助跟踪具有欺骗源地址的数据报，[31] 但 RFC 6864 现在禁止任何此类使用。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>**Flags **# 用来控制或识别 IP 分片之后的每个片段，这 3 个 bit 分别表示不同的含义，若字段值为 0 表示未设置，值为 1 表示设置，类似 TCP 首部中 Flags 字段的用法。
&lt;ul>
&lt;li>第一个 # Reserved，保留字段，必须为 0&lt;/li>
&lt;li>第二个 # Don&amp;rsquo;t Fragment(DF)&lt;/li>
&lt;li>第三个 # More Fragment(MF)&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>Fragment Offset(分片偏移)&lt;/strong> # IP 分片之后的偏移量&lt;/li>
&lt;li>&lt;strong>Time To Live(存活时间，简称 TTL)&lt;/strong> # 其实用 Hop Limit 的描述更准确，封包每经过一个路由器，怎会将 TTL 字段的值减 1，减到 0 是，该包将会被丢弃。&lt;/li>
&lt;li>**Protocol **# 封装 IP 数据报的上层协议，比如 6 表示 TCP、1 表示 ICMP
&lt;ul>
&lt;li>每种协议根据 &lt;a href="https://datatracker.ietf.org/doc/html/rfc1700">RFC 1700&lt;/a> 都分配了一个固定的编号，该 RFC 1700 最终被 RFC 3232 废弃，并将协议编号的维护工作，转到&lt;a href="https://www.iana.org/assignments/protocol-numbers/protocol-numbers.xhtml"> IANA 的在线数据库&lt;/a>中&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>Header Checksum&lt;/strong> # 当数据包到达路由器时，路由器会计算标头的校验和，并将其与校验和字段进行比较。如果值不匹配，则路由器会丢弃该数据包。&lt;/li>
&lt;li>&lt;strong>Source Address(源地址)&lt;/strong> # 发送端 IP 地址。&lt;/li>
&lt;li>&lt;strong>Destination Address(目标地址)&lt;/strong> # 接收端 IP 地址。&lt;/li>
&lt;li>**Options(选项) **# 可变长度，0-40 Bytes。&lt;/li>
&lt;/ul>
&lt;h1 id="ipv4-fragment">IPv4 Fragment&lt;/h1>
&lt;p>IP Fragment(分片) 主要通过首部中的 Identification、Flags、Fragment Offset 这三个字段对每一个分片进行唯一标识&lt;/p>
&lt;h1 id="ip-地址分配机制">IP 地址分配机制&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://www.iana.org/numbers">IANA,号码资源&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.eet-china.com/mp/a54338.html">面包板，你知道中国大陆一共有多少 IPv4 地址吗？&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://mp.weixin.qq.com/s/GHYYgZwAuEV4qPCwdI8Bjg">公众号，k8s 中文社区-居然还有 2 亿多 IPv4 地址未分配&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://wq.apnic.net/static/search.html">APNIC,搜索&lt;/a>(通过给定的 IP 地址搜索谁拥有这个 IP)&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>IPv4 和 IPv6 地址通常以分层方式分配。&lt;strong>ISP(互联网服务提供商)&lt;/strong> 为用户分配 IP 地址。ISP 从 &lt;strong>LIR(本地互联网注册机构)&lt;/strong> 或 &lt;strong>NIR(国家互联网注册机构)&lt;/strong> 或 &lt;strong>RIR(相应的区域互联网注册机构)&lt;/strong> 获取 IP 地址分配
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/nahgxm/1646384624162-21c9bca1-0960-45e4-87bb-3802eca96278.svg" alt="">&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>登记处&lt;/th>
&lt;th>覆盖面积&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>&lt;a href="http://www.afrinic.net/">AFRINIC&lt;/a>&lt;/td>
&lt;td>Africa Region(非洲地区)&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;a href="http://www.apnic.net/">APNIC&lt;/a>&lt;/td>
&lt;td>Asia/Pacific Region(亚洲/太平洋地区，亚太地区)&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;a href="http://www.arin.net/">ARIN&lt;/a>&lt;/td>
&lt;td>Canada, USA, and some Caribbean Islands(加拿大、美国、一些加勒比岛屿)&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;a href="http://www.lacnic.net/">LACNIC&lt;/a>&lt;/td>
&lt;td>Latin America and some Caribbean Islands(拉丁美洲、一些加勒比岛屿)&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;a href="http://www.ripe.net/">RIPE NCC&lt;/a>&lt;/td>
&lt;td>Europe, the Middle East, and Central Asia(欧洲、中东、中亚)&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>&lt;a href="http://www.icann.org/en/general/global-addressing-policies.html">对 IP 地址的主要作用是根据全球政策&lt;/a>所述的需求将未分配地址池分配给 RIR，并记录 &lt;a href="http://www.ietf.org/">IETF&lt;/a> 所做的协议分配。当 RIR 需要在其区域内分配或分配更多 IP 地址时，我们会向 RIR 进行额外分配。我们不会直接向 ISP 或最终用户进行分配，除非在特定情况下，例如分配多播地址或其他协议特定需求。&lt;/p>
&lt;p>APNIC 是全球 5 个地区级的 Internet 注册机构（RIR）之一，负责亚太地区的以下事务：
1、分配 IPv4 和 IPv6 地址空间，AS 号；
2、为亚太地区维护 Whois 数据库；
3、反向 DNS 指派；
4、在全球范围内作为亚太地区的 Internet 社区的代表。
所以，中国大陆境内的地址都会登记在 APNIC 的地址库内。地址库获取方式：&lt;a href="http://ftp.apnic.net/apnic/stats/apnic/delegated-apnic-latest">http://ftp.apnic.net/apnic/stats/apnic/delegated-apnic-latest&lt;/a>
例如在 Linux 系统中，使用 wget 命令可以拉取文件。
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/nahgxm/1646295854669-69e90c43-6765-415a-be08-ba15cdf1f6c3.png" alt="image.png">
文件内容条目参考如下：
apnic|JP|asn|173|1|20020801|allocated
apnic|ID|ipv4|43.240.228.0|1024|20140818|allocated
apnic|HK|ipv6|2001:df5:b800::|48|20140514|assigned
条目格式如下：
注册机构|国家代码|类型|起始位|长度|分配日期|状态&lt;/p>
&lt;ul>
&lt;li>&lt;strong>注册机构&lt;/strong>：亚太地区一般为 apnic&lt;/li>
&lt;li>&lt;strong>国家代码&lt;/strong>：ISO-3166 定义的两位国家或地区代码，如中国为 CN&lt;/li>
&lt;li>&lt;strong>类型&lt;/strong>：asn（Autonomous System Number，自治系统编号），也就是 BGP 的 AS 编号；ipv4，IPv4 地址；ipv6，IPv6 地址&lt;/li>
&lt;li>&lt;strong>起始位&lt;/strong>：第一个 ASN 编号或 IP 地址&lt;/li>
&lt;li>&lt;strong>长度&lt;/strong>：从第一个起始位开始，申请分配多少的编号或地址&lt;/li>
&lt;li>&lt;strong>分配日期&lt;/strong>：国家或地区向 APNIC 申请的日期&lt;/li>
&lt;li>&lt;strong>状态&lt;/strong>：allocated 和 assigned，都是已分配&lt;/li>
&lt;/ul>
&lt;p>所以，需要将 delegated-apnic-latest 文件中所有国家为 CN、且类型为 ipv4 的条目导出，并转换为静态路由格式。
例如使用命令将符合条件的条目导入到 china 文件中。
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/nahgxm/1646295854726-90496001-56ba-4bbb-9e7c-48568a601999.png" alt="image.png">
可以查看文件行数，代表有多少条明细条目。
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/nahgxm/1646295854636-89ef24bb-cb5c-4832-a3af-bcc97cffc042.png" alt="image.png">
然后根据起始位和长度，转换出静态路由所需的目的地址和掩码即可。在 excel 中通过对长度进行函数运算，可以得到掩码长度，如：=32-LOG(E2,2)，代入 2048 的话，可得到掩码长度为 21。操作后得到类似下图的表格：
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/nahgxm/1646295854710-c698ce59-e5fb-4e59-97cc-77a1a81bfc81.png" alt="image.png">
先将表格内容复制到记事本中，再从记事本粘贴到 Word 中，即可得到带有内容字段、tab 制表符和段落标记的内容。如下：
1.0.1.0 CN 24 apnic
1.0.2.0 CN 23 apnic
1.0.8.0 CN 21 apnic
这就简单了，使用 Word 的替换功能，对对应字段进行替换就可以得到形如下文的配置：
int loop 1
ip add 1.12.0.1 14
int loop 2
ip add 1.24.0.1 13
int loop 3
ip add 1.48.0.1 15
int loop 4
ip add 1.56.0.1 13
int loop 5
ip add 1.68.0.1 14
再把配置分别刷入到 11 台设备当中，配置好 OSPF 和 BGP 就可以了。
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/nahgxm/1646295854663-30f55fe1-a908-42e8-8b91-e95b33552417.png" alt="image.png">&lt;/p>
&lt;h2 id="ip-应用场景">IP 应用场景&lt;/h2>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>标记&lt;/th>
&lt;th>中文&lt;/th>
&lt;th>描述&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>ANY&lt;/td>
&lt;td>任播网络&lt;/td>
&lt;td>属于数据中心的一部分，任播网络；如：8.8.8.8&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>CDN&lt;/td>
&lt;td>内容分发&lt;/td>
&lt;td>属于数据中心的一部分，内容分发网络&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>COM&lt;/td>
&lt;td>商业公司&lt;/td>
&lt;td>以盈利为目的的公司&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>DNS&lt;/td>
&lt;td>域名解析&lt;/td>
&lt;td>用户提供域名解析服务的 IP；如：8.8.8.8，114.114.114.114&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>EDU&lt;/td>
&lt;td>教育机构&lt;/td>
&lt;td>学校/教育机构使用的 IP&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>GTW&lt;/td>
&lt;td>企业专线&lt;/td>
&lt;td>固定 IP，中大型公司专线上网的 IP&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>GOV&lt;/td>
&lt;td>政府机构&lt;/td>
&lt;td>政府单位使用的 IP&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>DYN&lt;/td>
&lt;td>动态 IP&lt;/td>
&lt;td>家庭住宅用户使用的 IP&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>IDC&lt;/td>
&lt;td>数据中心&lt;/td>
&lt;td>机房/云服务商使用的 IP&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>IXP&lt;/td>
&lt;td>交换中心&lt;/td>
&lt;td>网络交换中心使用的 IP&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>MOB&lt;/td>
&lt;td>移动网络&lt;/td>
&lt;td>基站出口 IP（2G/3G/4G/5G）&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>NET&lt;/td>
&lt;td>基础设施&lt;/td>
&lt;td>网络设备骨干路由使用的 IP&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>ORG&lt;/td>
&lt;td>组织机构&lt;/td>
&lt;td>非营利性组织机构&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>SAT&lt;/td>
&lt;td>卫星通信&lt;/td>
&lt;td>通过卫星上网的出口 IP&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>VPN&lt;/td>
&lt;td>代理网络&lt;/td>
&lt;td>属于数据中心的一部分，专门做 VPN 业务的&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table></description></item><item><title>Docs: IP</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/4.%E6%95%B0%E6%8D%AE%E9%80%9A%E4%BF%A1/%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/3_4.tcp_ip/ip/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/4.%E6%95%B0%E6%8D%AE%E9%80%9A%E4%BF%A1/%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/3_4.tcp_ip/ip/</guid><description/></item><item><title>Docs: TCP</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/4.%E6%95%B0%E6%8D%AE%E9%80%9A%E4%BF%A1/%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/3_4.tcp_ip/tcp/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/4.%E6%95%B0%E6%8D%AE%E9%80%9A%E4%BF%A1/%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/3_4.tcp_ip/tcp/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://datatracker.ietf.org/doc/html/rfc675">RFC,675&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://datatracker.ietf.org/doc/html/rfc793">RFC,793&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Transmission_Control_Protocol">Wiki,TCP&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://time.geekbang.org/column/intro/100007101">极客时间,趣谈网络协议&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.jianshu.com/p/1118f497a425">https://www.jianshu.com/p/1118f497a425&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.jianshu.com/p/3c7a0771b67e">https://www.jianshu.com/p/3c7a0771b67e&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://mp.weixin.qq.com/s/WG1Is0HMAHYMgRvJQpd3KA">通过动图学习 TCP 的滑动窗口和流量控制的工作方式&lt;/a>
&lt;ul>
&lt;li>&lt;a href="https://www2.tkn.tu-berlin.de/teaching/rn/animations/gbn_sr/">https://www2.tkn.tu-berlin.de/teaching/rn/animations/gbn_sr/&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www2.tkn.tu-berlin.de/teaching/rn/animations/flow/">https://www2.tkn.tu-berlin.de/teaching/rn/animations/flow/&lt;/a>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>&lt;strong>Transmission Control Protocol(传输控制协议，简称 TCP)&lt;/strong> 是&lt;a href="https://en.wikipedia.org/wiki/Internet_protocol_suite">互联网协议套件&lt;/a>的最主要协议之一。它起源于最初的网络实现，补充了 Internet Protocol。因此整个套件通常称为 &lt;strong>TCP/IP&lt;/strong>。&lt;/p>
&lt;p>IP 地址后面的端口的作用：当从外部访问该 IP 地址的机器时候，是通过该 IP 地址的端口来访问这台机器的某个程序，然后程序向访问者提供该程序所具有的功能（服务）。web 界面默认是 80 端口，那么当你访问一个网页的时候，这个 IP 就会带你访问该机器的占用 80 端口的程序，然后该程序去调用首页脚本本间展示给访问者&lt;/p>
&lt;p>例如：你通过远程 SSH 访问一台设备 192.168.0.1 的话，那么需要设置一下这台机器 SSH 服务程序所占用的端口号，比如 22，那么你就是通过 192.168.0.1:22 这个来访问这台机器的 SSH 进程。&lt;/p>
&lt;p>上面的描述，就是一个基本的 TCP。&lt;/p>
&lt;p>TCP 天然认为网络环境是恶劣的，丢包、乱序、重传，拥塞都是常有的事情，一言不合就可能送达不了，因而要从算法层面来保证可靠性。TCP 是靠谱的协议，但是这不能说明它面临的网络环境好。从 IP 层面来讲，如果网络状况的确那么差，是没有任何可靠性保证的，而作为 IP 的上一层 TCP 也无能为力，唯一能做的就是更加努力，不断重传，通过各种算法保证。也就是说，对于 TCP 来讲，IP 层你丢不丢包，我管不着，但是我在我的层面上，会努力保证可靠性。这有点像如果你在北京，和客户约十点见面，那么你应该清楚堵车是常态，你干预不了，也控制不了，你唯一能做的就是早走。打车不行就改乘地铁，尽力不失约。&lt;/p>
&lt;h2 id="总结">总结&lt;/h2>
&lt;p>通过对 TCP 头的解析，我们知道要掌握 TCP 协议，重点应该关注以下几个问题：&lt;/p>
&lt;ul>
&lt;li>顺序问题 ，稳重不乱；&lt;/li>
&lt;li>丢包问题，承诺靠谱；&lt;/li>
&lt;li>连接维护，有始有终；&lt;/li>
&lt;li>流量控制，把握分寸；&lt;/li>
&lt;li>拥塞控制，知进知退。&lt;/li>
&lt;/ul>
&lt;h1 id="tcp-segment-结构">TCP Segment 结构&lt;/h1>
&lt;p>TCP 段被封装在 IP 数据报中
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/tvcktp/1628820358483-a9e565df-371d-4e47-b0d0-0f1fb6077945.png" alt="image.png">
首部长度：一般为 20 字节，选项最多 40 字节，限制 60 字节。下图中的位，即代表 bit，也就是说，首部一共 160 bit，即 20 Byte。
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/tvcktp/1629791940018-704af85e-5ccf-4ded-90b4-a824d60c3726.jpeg" alt="">
对照在 WireShark 中展示的内容看，排除 &lt;code>[]&lt;/code> 中的内容，WireShark 中展示的一个 SYN TCP 段的内容，每一行就是包头中的一个内容
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/tvcktp/1628819589583-6eb31754-8352-45b6-b4b9-b7a61d26433e.png" alt="image.png">&lt;/p>
&lt;ul>
&lt;li>&lt;strong>Source Port(源端口号)&lt;/strong> #&lt;/li>
&lt;li>**Destination Port(目的端口号) **#
&lt;ul>
&lt;li>每个 TCP 报文段都包含源和目的的端口号，这两个端口号用于寻找发送端与接收端的应用进程。这两个值加上 IP 首部中的源和目的的 IP 地址，&lt;strong>组成 TCP 四元组，用于确定唯一一个 TCP 连接&lt;/strong>。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>Sequence Number(序号，简称 SeqNum)&lt;/strong> # TCP 报文段的唯一标识符，该标识符具有先后顺序。如果不为每一个包编号，则没法确认哪个包先来哪个包后来。
&lt;ul>
&lt;li>&lt;strong>SeqNum 用来解决网络包乱序的问题。&lt;/strong>&lt;/li>
&lt;li>&lt;strong>Initial Sequence Number(初始序号，简称 ISN)&lt;/strong> # TCP 交互的两端，有一个初始的 SeqNum，就是 A 发送给 B 或者 B 发送给 A 的第一个 TCP 段，这第一个 TCP 段的 SeqNum 就是 ISN。&lt;/li>
&lt;li>注意：TCP 为应用层提供全双工服务，这意味着数据能在两个方向上独立进行传输。因此，一个 TCP 连接的两端都会有自己独立的 SeqNum。所以首次建立连接时客户端和服务端都会生成一个 ISN。ISN 是一个随机生成的数。&lt;/li>
&lt;li>SeqNum 最大值为 232-1，到达最大值后，回到 0 开始。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>**Acknowledgment Number(确认序号，简称 AckNum) **# 下一次期望收到数据中报文段的 SeqNum。发出去的包应该有确认，要不然怎么知道对方有没有收到呢？如果没有收到就应该重新发送，直到送达。
&lt;ul>
&lt;li>&lt;strong>AckNum 用来解决不丢包的问题&lt;/strong>。&lt;/li>
&lt;li>AckNum 可以用来确认上次发送的数据大小。
&lt;ul>
&lt;li>假如 172.19.42.244 向 172.19.42.248 发送了一个 PSH,ACK 的报文段，其中 SeqNum=x1,AckNum=y1，发送了 90Bytes 的数据，&lt;/li>
&lt;li>那么 172.19.42.248 向 172.19.42.244 就会发送一个 ACK 的报文段，其中 SeqNum=x2,AckNum=x1+90&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>Header Length(首部长度)&lt;/strong> #&lt;/li>
&lt;li>&lt;strong>Flag — TCP 标志&lt;/strong> # 用来定义当前 TCP 报文段的类型。&lt;/li>
&lt;li>&lt;strong>Window size value(窗口大小)&lt;/strong> # TCP 流量控制。通信双方各声明一个窗口，标识自己当前能够的处理能力，别发送的太快，撑死我，也别发的太慢，饿死我。&lt;/li>
&lt;li>&lt;strong>Chceksum(校验和)&lt;/strong> #&lt;/li>
&lt;li>&lt;strong>Urgent pointer(紧急指针)&lt;/strong> #&lt;/li>
&lt;li>&lt;strong>Options(选项)&lt;/strong> # 告诉对方本次传输的一些限制。比如 MSS、SACK 等等&lt;/li>
&lt;li>&lt;strong>TCP Payload(数据)&lt;/strong> # 这个字段需要在 HTTP 包中才可以看到，TCP 的有效载荷就是当前传输的数据&lt;/li>
&lt;/ul>
&lt;h2 id="seqnum-与-acknum-的计算">SeqNum 与 AckNum 的计算&lt;/h2>
&lt;p>由于 TCP 的全双工机制，所以 TCP 交互的两端都有独立的 SeqNum，其两端的 SeqNum 互相之间没有绝对的关联关系，只有一端的 SeqNum 与对端的 AckNum 有关系。&lt;/p>
&lt;p>现在假设有 A 和 B 两个系统想要建立 TCP 连接并进行数据交互,并且通信环境正常可以正常建立连接，且以数字表示 A 发送给 B 或者 B 发送给 A 的第几号数据包。&lt;/p>
&lt;p>那么：&lt;/p>
&lt;ul>
&lt;li>A 发送给 B 的第 N 号 TCP 段中 SeqNum 的值等于 &lt;code>A 的 N-1 号 TCP 段中发送的数据大小(Bytes)&lt;/code> 与 &lt;code>A 的 N-1 号 TCP 段的 SeqNum&lt;/code> 之和。即：
&lt;ul>
&lt;li>&lt;code>A_N_SeqNum = A_ISN + A_N-1_TCPPlayload + A_N-1_SeqNum&lt;/code>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>B 响应给 A 的第 N 号 TCP 段中 AckNum 的值等于&lt;code> A 的 N 号 TCP 段中发送的数据大小(Bytes)&lt;/code> 与 &lt;code> A 的 N 号 TCP 段中的 SeqNum&lt;/code> 之和。即：
&lt;ul>
&lt;li>&lt;code>B_N_AckNum = A_N_TCPPlayload + A_N_SeqNum&lt;/code>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>反之亦然：&lt;/p>
&lt;ul>
&lt;li>&lt;code>A_N_AckNum = B_N_TCPPlayload + B_N_SeqNum&lt;/code>&lt;/li>
&lt;li>&lt;code>B_N_SeqNum = B_ISN + B_N-1_TCPPlayload + B_N-1_SeqNum&lt;/code>&lt;/li>
&lt;/ul>
&lt;h2 id="tcp-flag">TCP Flag&lt;/h2>
&lt;p>TCP 报文段的标志内容，将会包含所有标志通过设置标志的值来启用或禁用这些标志(1 表示设置(即.启用)，0 表示未设置(即.禁用))。一个 TCP 报文段中，可以同时启用多个 TCP 标志。下图就是一个 TCP 三次握手中，第二次交互的 TCP 标志内容。
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/tvcktp/1628827678903-275e8388-c654-4656-b321-d5d501ff2803.png" alt="image.png">
当前可用的 TCP 标志有如下几个：&lt;/p>
&lt;ul>
&lt;li>&lt;strong>ACK(Acknowledgement)&lt;/strong> # 确认、响应
&lt;ul>
&lt;li>除了第一个 SYN 报文段意外，其余报文段都要启用 ACK。因为除了建立连接时，发送的第一个报文段，其余所有的报文段都需要响应发送给自己的报文段，用来表示已收到消息。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>CWR&lt;/strong> # 拥塞窗口减少&lt;/li>
&lt;li>&lt;strong>ECE&lt;/strong> # 显式拥塞提醒回应&lt;/li>
&lt;li>&lt;strong>FIN&lt;/strong> # 终止、关闭连接
&lt;ul>
&lt;li>用于释放连接，表示此报文段的发送方数据已发送完毕并要求释放连接&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>PSH(Push&lt;/strong>) # 推送、数据传输
&lt;ul>
&lt;li>当应用程序双方进行交互式通信时，若一端希望在键入命令后就能收到对方响应。此时可采用推送操作。发送方将会立即创建一个报文段并发送出去，接收方接收到 PSH=1 的报文段会进快递交付，而不会等到整个缓存都填满后在向上交付。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>RST&lt;/strong> # 复位、连接重置。
&lt;ul>
&lt;li>表示连接中出现严重错误必须释放连接再重新建立传输连接，也可用来拒绝一个非法报文段或拒绝打开一个连接。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>**SYN(Synchronize) **# 同步、建立连接
&lt;ul>
&lt;li>SYN 是 TCP/IP 建立连接时使用的握手信号，SYN 仅在三次握手建立 TCP 连接时有效。&lt;/li>
&lt;li>客户端和服务端建立连接时，客户端首先会发出一个 SYN 报文段用来建立连接，服务端使用 SYN+ACK 应答表示接收到该消息，最后客户端再以 ACK 消息进行响应。&lt;/li>
&lt;li>SYN 用于请求和建立连接，也可用于设备间的 SEQ 序列号同步，SYN=1 表示是一个连接请求或连接接收的报文段，当 SYN=1 且 ACK=0 表示连接请求报文段，若对方同意则响应 SYN=1 且 ACK=1。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>URG&lt;/strong> # 紧急
&lt;ul>
&lt;li>表示报文段中有紧急数据应尽快发送，不要按原来的排队顺序来传送。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h1 id="tcp-状态">TCP 状态&lt;/h1>
&lt;p>一个 TCP 连接在它的声明周期内会有不同的状态。下图说明了 TCP 连接可能会有的状态，以及基于事件的状态转换。事件中有的是应用程序的操作，有的是接收到了网络发过来的请求。
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/tvcktp/1628824939321-772e1691-86d4-4ca9-b65c-7a3db704ff9b.png" alt="image.png">&lt;/p>
&lt;ul>
&lt;li>LISTEN # 服务端。等待来自远程的 TCP 请求&lt;/li>
&lt;li>SYN-SENT # TCP 第一次握手后客户端所处的状态。发送连接请求后，等待来自服务端的确认。
&lt;ul>
&lt;li>TCP 默认 SYN 报文最大 retry 5 次，每次超时了翻倍，1s -&amp;gt; 3s -&amp;gt; 7s -&amp;gt; 15s -&amp;gt; 31s -&amp;gt; 63s。&lt;a href="https://blog.csdn.net/u010039418/article/details/78234570">参考资料&lt;/a>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>SYN-RECEIVED # TCP 第二次握手后服务端所处的状态。服务端已经接收到连接请求并发送确认。服务端正在等待最终确认。&lt;/li>
&lt;li>ESTABLISHED # TCP 第三次握手后服务端与客户端所处的状态。代表连接已经建立起来了。这是连接数据传输阶段的正常状态。&lt;/li>
&lt;li>FIN-WAIT-1 # 等待来自远程 TCP 的终止连接请求或终止请求的确认&lt;/li>
&lt;li>FIN-WAIT-2 # 在此端点发送终止连接请求后，等待来自远程 TCP 的连接终止请求&lt;/li>
&lt;li>CLOSE_WAIT # 该端点已经收到来自远程端点的关闭请求，此 TCP 正在等待本地应用程序的连接终止请求&lt;/li>
&lt;li>CLOSING # 等待来自远程 TCP 的连接终止请求确认&lt;/li>
&lt;li>LAST_ACK # 等待先前发送到远程 TCP 的连接终止请求的确认&lt;/li>
&lt;li>TIME-WAIT # 主动断开连接一方的状态。等待足够的时间来确保远程 TCP 接收到其连接终止请求的确认
&lt;ul>
&lt;li>TCP 主动关闭连接的一方在发送最后一个 ACK 后进入  &lt;code>TIME_AWAIT&lt;/code>  状态，再等待 2 个 MSL 时间后才会关闭(因为如果 server 没收到 client 第四次挥手确认报文，server 会重发第三次挥手 FIN 报文，所以 client 需要停留 2 MSL 的时长来处理可能会重复收到的报文段；同时等待 2 MSL 也可以让由于网络不通畅产生的滞留报文失效，避免新建立的连接收到之前旧连接的报文)，了解更详细的过程请参考 TCP 四次挥手。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h1 id="tcp-行为的过程">TCP 行为的过程&lt;/h1>
&lt;h2 id="tcp-三次握手">TCP 三次握手&lt;/h2>
&lt;p>参考：&lt;a href="https://hit-alibaba.github.io/interview/basic/network/TCP.html">https://hit-alibaba.github.io/interview/basic/network/TCP.html&lt;/a>
三次握手的过程的示意图如下：
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/tvcktp/1628831488474-13bf079c-3419-4f9d-b92d-ca1620d7b6a7.png" alt="image.png">
所谓三次握手(Three-way Handshake)，是指建立一个 TCP 连接时，需要客户端和服务器总共发送 3 个包。三次握手的目的是连接服务器指定端口，建立 TCP 连接，并同步连接双方的序列号和确认号，交换 TCP 窗口大小信息。&lt;/p>
&lt;p>在 socket 编程中，客户端执行 connect() 时。将触发三次握手：&lt;/p>
&lt;ul>
&lt;li>&lt;strong>第一次握手(SYN，SeqNum=client_isn)&lt;/strong> # 客户端请求同步，发送 SYN 报文段
&lt;ul>
&lt;li>客户端生成一个随机数 client_isn&lt;/li>
&lt;li>设置 TCP 首部字段
&lt;ul>
&lt;li>将 client_isn 填入到 Sequence Number 字段中。&lt;/li>
&lt;li>将 TCP 标志中 SYN 的值设为 1。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>发送完毕后，客户端进入 SYN_SEND 状态。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>第二次握手(SYN,ACK，SeqNum=server_isn，AckNum=client_isn+1)&lt;/strong> # 服务端回应并请求同步，发送 SYN + ACK 报文段
&lt;ul>
&lt;li>服务端收到客户端的 SYN 报文段后，生成一个随机数 server_isn&lt;/li>
&lt;li>设置 TCP 首部字段
&lt;ul>
&lt;li>将 server_isn 填入 Sequence Number 字段中&lt;/li>
&lt;li>将 client_isn+1 填入 Acknowledgement Number 字段中。&lt;/li>
&lt;li>将 TCP 标志中的 SYN 和 ACK 的值设为 1。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>发送完毕后，服务器端进入 SYN_RCVD 状态。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>第三次握手(ACK，SeqNum=client_isn+1，AckNum=server_isn+1)&lt;/strong> # 客户端回应确认，建立连接。发送 ACK 报文段
&lt;ul>
&lt;li>客户端收到服务端报文后，还需要向服务端回应最后一个 ACK 报文段&lt;/li>
&lt;li>设置 TCP 首部字段
&lt;ul>
&lt;li>将 server_isn+1 填入 Acknowledgement Number 字段中。&lt;/li>
&lt;li>将 TCP 标志中的 ACK 的值设为 1。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>发送完毕后，客户端进入 ESTABLISHED 状态，当服务器端接收到这个包时，也进入 ESTABLISHED 状态，TCP 握手结束。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>注意：&lt;/p>
&lt;ul>
&lt;li>第三次握手时，此时客户端已经处于 ESTABLISHED 状态。对于客户端来说，他已经建立起连接了，并且已经知道服务器的接收和发送能力是正常的。所以也就可以携带数据了。&lt;/li>
&lt;li>但是第一次握手是不可以带数据发送给服务端的，因为还不知道对方的窗口大小，并且也容易让客户端发起大量数据进行攻击。&lt;/li>
&lt;/ul>
&lt;h2 id="tcp-四次挥手">TCP 四次挥手&lt;/h2>
&lt;p>四次挥手的示意图如下：
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/tvcktp/1616161421390-7655ce0e-3e07-436c-93b1-708b3389996d.jpeg" alt="">
TCP 的连接的拆除需要发送四个包，因此称为四次挥手(Four-way handshake)，也叫做改进的三次握手。客户端或服务器均可主动发起挥手动作，在 socket 编程中，任何一方执行 close() 操作即可产生挥手操作。&lt;/p>
&lt;p>第一次挥手(FIN=1，seq=x)&lt;/p>
&lt;ul>
&lt;li>假设客户端想要关闭连接，客户端发送一个 FIN 标志位置为 1 的包，表示自己已经没有数据可以发送了，但是仍然可以接受数据。&lt;/li>
&lt;li>发送完毕后，客户端进入 FIN_WAIT_1 状态。&lt;/li>
&lt;/ul>
&lt;p>第二次挥手(ACK=1，ACKnum=x+1)&lt;/p>
&lt;ul>
&lt;li>服务器端确认客户端的 FIN 包，发送一个确认包，表明自己接受到了客户端关闭连接的请求，但还没有准备好关闭连接。&lt;/li>
&lt;li>发送完毕后，服务器端进入 CLOSE_WAIT 状态，客户端接收到这个确认包之后，进入 FIN_WAIT_2 状态，等待服务器端关闭连接。&lt;/li>
&lt;/ul>
&lt;p>第三次挥手(FIN=1，seq=y)&lt;/p>
&lt;ul>
&lt;li>服务器端准备好关闭连接时，向客户端发送结束连接请求，FIN 置为 1。&lt;/li>
&lt;li>发送完毕后，服务器端进入 LAST_ACK 状态，等待来自客户端的最后一个 ACK。&lt;/li>
&lt;/ul>
&lt;p>第四次挥手(ACK=1，ACKnum=y+1)&lt;/p>
&lt;ul>
&lt;li>客户端接收到来自服务器端的关闭请求，发送一个确认包，并进入 TIME_WAIT 状态，等待可能出现的要求重传的 ACK 包。&lt;/li>
&lt;li>服务器端接收到这个确认包之后，关闭连接，进入 CLOSED 状态。&lt;/li>
&lt;li>客户端等待了某个固定时间（两个最大段生命周期，2MSL，2 Maximum Segment Lifetime）之后，没有收到服务器端的 ACK ，认为服务器端已经正常关闭连接，于是自己也关闭连接，进入 CLOSED 状态。&lt;/li>
&lt;/ul>
&lt;h2 id="数据传输">数据传输&lt;/h2>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/tvcktp/1628842098522-1dc9dcc9-026c-4e88-a288-cd0e73613e77.png" alt="image.png">
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/tvcktp/1628841642687-befcb683-4d7e-41b2-849d-14b028d2a170.png" alt="image.png">&lt;/p></description></item><item><title>Docs: TCP</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/4.%E6%95%B0%E6%8D%AE%E9%80%9A%E4%BF%A1/%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/3_4.tcp_ip/tcp/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/4.%E6%95%B0%E6%8D%AE%E9%80%9A%E4%BF%A1/%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/3_4.tcp_ip/tcp/</guid><description/></item><item><title>Docs: TCP 异常处理</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/4.%E6%95%B0%E6%8D%AE%E9%80%9A%E4%BF%A1/%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/3_4.tcp_ip/tcp-%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/4.%E6%95%B0%E6%8D%AE%E9%80%9A%E4%BF%A1/%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/3_4.tcp_ip/tcp-%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/</guid><description>
&lt;h1 id="tcp-rst">TCP RST&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://www.cnblogs.com/JohnABC/p/6323046.html">博客园-John_ABC，Linux-TCG 出现 RST 的几种情况&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://segmentfault.com/a/1190000038463522">https://segmentfault.com/a/1190000038463522&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>TCP RST 引起的常见报错：&lt;/p>
&lt;ul>
&lt;li>Connection reset&lt;/li>
&lt;li>Connection reset by peer&lt;/li>
&lt;/ul>
&lt;p>TCP 连接和释放时还有许多细节，比如半连接状态、半关闭状态等。详情请参考这方面的巨著《TCP/IP 详解》和《UNIX 网络编程》。
前面说到出现“Connection reset”的原因是服务器关闭了 Connection[调用了 Socket.close()方法]。大家可能有疑问了：服务器关闭了 Connection 为什么会返回“RST”而不是返回“FIN”标志。原因在于 Socket.close()方法的语义和 TCP 的“FIN”标志语义不一样：发送 TCP 的“FIN”标志表示我不再发送数据了，而 Socket.close()表示我不在发送也不接受数据了。问题就出在“我不接受数据” 上，如果此时客户端还往服务器发送数据，服务器内核接收到数据，但是发现此时 Socket 已经 close 了，则会返回“RST”标志给客户端。当然，此时客户端就会提示：“Connection reset”。详细说明可以参考 oracle 的有关文档：http://docs.oracle.com/javase/1.5.0/docs/guide/net/articles/connection_release.html。
另一个可能导致的“Connection reset”的原因是服务器设置了 Socket.setLinger (true, 0)。但我检查过线上的 tomcat 配置，是没有使用该设置的，而且线上的服务器都使用了 nginx 进行反向代理，所以并不是该原因导致的。关于该原因上面的 oracle 文档也谈到了并给出了解释。
此外啰嗦一下，另外还有一种比较常见的错误“Connection reset by peer”，该错误和“Connection reset”是有区别的：
服务器返回了“RST”时，如果此时客户端正在从 Socket 套接字的输出流中读数据则会提示 Connection reset”；
服务器返回了“RST”时，如果此时客户端正在往 Socket 套接字的输入流中写数据则会提示“Connection reset by peer”。
“Connection reset by peer”如下图所示：&lt;/p>
&lt;p>前面谈到了导致“Connection reset”的原因，而具体的解决方案有如下几种：
出错了重试；
客户端和服务器统一使用 TCP 长连接；
客户端和服务器统一使用 TCP 短连接。
首先是出错了重试：这种方案可以简单防止“Connection reset”错误，然后如果服务不是“幂等”的则不能使用该方法；比如提交订单操作就不是幂等的，如果使用重试则可能造成重复提单。
然后是客户端和服务器统一使用 TCP 长连接：客户端使用 TCP 长连接很容易配置（直接设置 HttpClient 就好），而服务器配置长连接就比较麻烦了，就拿 tomcat 来说，需要设置 tomcat 的 maxKeepAliveRequests、connectionTimeout 等参数。另外如果使用了 nginx 进行反向代理或负载均衡，此时也需要配置 nginx 以支持长连接（nginx 默认是对客户端使用长连接，对服务器使用短连接）。
使用长连接可以避免每次建立 TCP 连接的三次握手而节约一定的时间，但是我这边由于是内网，客户端和服务器的 3 次握手很快，大约只需 1ms。ping 一下大约 0.93ms（一次往返）；三次握手也是一次往返（第三次握手不用返回）。根据 80/20 原理，1ms 可以忽略不计；又考虑到长连接的扩展性不如短连接好、修改 nginx 和 tomcat 的配置代价很大（所有后台服务都需要修改）；所以这里并没有使用长连接。&lt;/p>
&lt;p>正常情况 tcp 四层握手关闭连接，rst 基本都是异常情况，整理如下： 0.使用 ping 可以看到丢包情况
1. GFW
2. 对方端口未打开，发生在连接建立
如果对方 sync_backlog 满了的话，sync 简单被丢弃，表现为超时，而不会 rst
3. close Socket 时 recv buffer 不为空
例如，客户端发了两个请求，服务器只从 buffer 读取第一个请求处理完就关闭连接，tcp 层认为数据没有正确提交到应用，使用 rst 关闭连接。
3. 移动链路
移动网络下，国内是有 5 分钟后就回收信令，也就是 IM 产品，如果心跳&amp;gt;5 分钟后服务器再给客户端发消息，就会收到 rst。也要查移动网络下 IM 保持&amp;lt;5min 心跳。
4. 负载等设备
负载设备需要维护连接转发策略，长时间无流量，连接也会被清除，而且很多都不告诉两层机器，新的包过来时才通告 rst。
Apple push 服务也有这个问题，而且是不可预期的偶发性连接被 rst；rst 前第一个消息 write 是成功的，而第二条写才会告诉你连接被重置，
曾经被它折腾没辙，因此打开每 2 秒一次 tcp keepalive，固定 5 分钟 tcp 连接回收，而且发现连接出错时，重发之前 10s 内消息。
5. SO_LINGER 应用强制使用 rst 关闭
该选项会直接丢弃未发送完毕的 send buffer，可能造成业务错误，慎用； 当然内网服务间 http client 在收到应该时主动关闭，使用改选项，会节省资源。
好像曾经测试过 haproxy 某种配置下，会使用 rst 关闭连接，少了网络交互而且没有 TIME_WAIT 问题
6. 超过超时重传次数、网络暂时不可达
7. TIME_WAIT 状态
tw_recycle = 1 时，sync timestamps 比上次小时，会被 rst
7. 设置 connect_timeout
应用设置了连接超时，sync 未完成时超时了，会发送 rst 终止连接。
8. 非正常包
连接已经关闭，seq 不正确等
9. keepalive 超时
公网服务 tcp keepalive 最好别打开；移动网络下会增加网络负担，切容易掉线；非移动网络核心 ISP 设备也不一定都支持 keepalive，曾经也发现过广州那边有个核心节点就不支持。
10. 数据错误，不是按照既定序列号发送数据 11.在一个已关闭的 socket 上接收数据 12.服务器关闭或异常终止了连接，由于网络问题，客户端没有收到服务器的关闭请求，这称为 TCP 半打开连接。就算重启服务器，也没有连接信息。如果客户端向提其写入数据，对方就会回应一个 RST 报文段。&lt;/p>
&lt;h1 id="三次握手与四次挥手异常处理">三次握手与四次挥手异常处理&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>原文链接：&lt;a href="https://mp.weixin.qq.com/s/CTqag_TxAHLuUwLvbrmlnw">公众号-小林 coding，TCP 才不傻！&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>大家好，我是小林。&lt;/p>
&lt;p>之前收到个读者的问题，对于 TCP 三次握手和四次挥手的一些疑问：&lt;/p>
&lt;ul>
&lt;li>第一次握手，如果客户端发送的 SYN 一直都传不到被服务器，那么客户端是一直重发 SYN 到永久吗？客户端停止重发 SYN 的时机是什么？&lt;/li>
&lt;li>第三次握手，如果服务器永远不会收到 ACK，服务器就永远都留在 Syn-Recv 状态了吗？退出此状态的时机是什么？&lt;/li>
&lt;li>第三次挥手，如果客户端永远收不到 FIN,ACK，客户端永远停留在 Fin-Wait-2 状态了吗？退出此状态时机是什么时候呢？&lt;/li>
&lt;li>第四次挥手，如果服务器永远收不到 ACK，服务器永远停留在 Last-Ack 状态了吗？退出此状态的时机是什么呢？&lt;/li>
&lt;li>如果客户端 在 2SML 内依旧没收到 FIN,ACK，会关闭链接吗？服务器那边怎么办呢，是怎么关闭链接的呢？&lt;/li>
&lt;/ul>
&lt;p>可以看到，这些问题都是关于 &lt;strong>TCP 是如何处理这些异常场景&lt;/strong>的，我们在学 TCP 连接建立和断开的时候，总是以为这些过程能如期完成。&lt;/p>
&lt;p>&lt;strong>可惜理想很丰满，现实很骨感，事实预料呀&lt;/strong>。&lt;/p>
&lt;p>&lt;strong>TCP 当然不傻&lt;/strong>，对以上这些异常场景都是有做处理的。&lt;/p>
&lt;p>这些内容在我的「图解网络 PDF」 也有说过。&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/24e305c7-9ba8-4113-9be1-44404948d366/640" alt="">&lt;/p>
&lt;p>当时也用做实验的方式带大家看 TCP 是如何处理这些异常场景的。&lt;/p>
&lt;blockquote>
&lt;p>如果新读者还不知道小林的图解网络 PDF，可以到我公众号后台回复「图解」获取就行。&lt;/p>
&lt;/blockquote>
&lt;p>不过，当时这些知识分散到了多个章节，这次就针对读者问的这一系列问题，来详细说说 TCP 是怎么处理这些异常的？&lt;/p>
&lt;p>这些异常场景共分为两大类，第一类是 TCP 三次握手期间的异常，第二类是 TCP 四次挥手期间的异常。&lt;/p>
&lt;h3 id="tcp-三次握手期间的异常">TCP 三次握手期间的异常&lt;/h3>
&lt;p>我们先来看看 TCP 三次握手是怎样的。&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/24e305c7-9ba8-4113-9be1-44404948d366/640" alt="">&lt;/p>
&lt;h4 id="第一次握手丢失了会发生什么">第一次握手丢失了，会发生什么？&lt;/h4>
&lt;p>当客户端想和服务端建立 TCP 连接的时候，首先第一个发的就是 SYN 报文，然后进入到 &lt;code>SYN_SENT&lt;/code> 状态。&lt;/p>
&lt;p>在这之后，如果客户端迟迟收不到服务端的 SYN-ACK 报文（第二次握手），就会触发超时重传机制。&lt;/p>
&lt;p>不同版本的操作系统可能超时时间不同，有的 1 秒的，也有 3 秒的，这个超时时间是写死在内核里的，如果想要更改则需要重新编译内核，比较麻烦。&lt;/p>
&lt;p>当客户端在 1 秒后没收到服务端的 SYN-ACK 报文后，客户端就会重发 SYN 报文，那到底重发几次呢？&lt;/p>
&lt;p>在 Linux 里，客户端的 SYN 报文最大重传次数由 &lt;code>tcp_syn_retries&lt;/code>内核参数控制，这个参数是可以自定义的，默认值一般是 5。&lt;/p>
&lt;p>通常，第一次超时重传是在 1 秒后，第二次超时重传是在 2 秒，第三次超时重传是在 4 秒后，第四次超时重传是在 8 秒后，第五次是在超时重传 16 秒后。没错，&lt;strong>每次超时的时间是上一次的 2 倍&lt;/strong>。&lt;/p>
&lt;p>当第五次超时重传后，会继续等待 32 秒，如果服务端仍然没有回应 ACK，客户端就不再发送 SYN 包，然后断开 TCP 连接。&lt;/p>
&lt;p>所以，总耗时是 1+2+4+8+16+32=63 秒，大约 1 分钟左右。&lt;/p>
&lt;h4 id="第二次握手丢失了会发生什么">第二次握手丢失了，会发生什么？&lt;/h4>
&lt;p>当服务端收到客户端的第一次握手后，就会回 SYN-ACK 报文给客户端，这个就是第二次握手，此时服务端会进入 &lt;code>SYN_RCVD&lt;/code> 状态。&lt;/p>
&lt;p>第二次握手的 &lt;code>SYN-ACK&lt;/code> 报文其实有两个目的 ：&lt;/p>
&lt;ul>
&lt;li>第二次握手里的 ACK， 是对第一次握手的确认报文；&lt;/li>
&lt;li>第二次握手里的 SYN，是服务端发起建立 TCP 连接的报文；&lt;/li>
&lt;/ul>
&lt;p>所以，如果第二次握手丢了，就会发送比较有意思的事情，具体会怎么样呢？&lt;/p>
&lt;p>因为第二次握手报文里是包含对客户端的第一次握手的 ACK 确认报文，所以，如果客户端迟迟没有收到第二次握手，那么客户端就觉得可能自己的 SYN 报文（第一次握手）丢失了，于是&lt;strong>客户端就会触发超时重传机制，重传 SYN 报文&lt;/strong>。&lt;/p>
&lt;p>然后，因为第二次握手中包含服务端的 SYN 报文，所以当客户端收到后，需要给服务端发送 ACK 确认报文（第三次握手），服务端才会认为该 SYN 报文被客户端收到了。&lt;/p>
&lt;p>那么，如果第二次握手丢失了，服务端就收不到第三次握手，于是&lt;strong>服务端这边会触发超时重传机制，重传 SYN-ACK 报文&lt;/strong>。&lt;/p>
&lt;p>在 Linux 下，SYN-ACK 报文的最大重传次数由 &lt;code>tcp_synack_retries&lt;/code>内核参数决定，默认值是 5。&lt;/p>
&lt;p>因此，当第二次握手丢失了，客户端和服务端都会重传：&lt;/p>
&lt;ul>
&lt;li>客户端会重传 SYN 报文，也就是第一次握手，最大重传次数由 &lt;code>tcp_syn_retries&lt;/code>内核参数决定。；&lt;/li>
&lt;li>服务端会重传 SYN-AKC 报文，也就是第二次握手，最大重传次数由 &lt;code>tcp_synack_retries&lt;/code>   内核参数决定。&lt;/li>
&lt;/ul>
&lt;h4 id="第三次握手丢失了会发生什么">第三次握手丢失了，会发生什么？&lt;/h4>
&lt;p>客户端收到服务端的 SYN-ACK 报文后，就会给服务端回一个 ACK 报文，也就是第三次握手，此时客户端状态进入到 &lt;code>ESTABLISH&lt;/code> 状态。&lt;/p>
&lt;p>因为这个第三次握手的 ACK 是对第二次握手的 SYN 的确认报文，所以当第三次握手丢失了，如果服务端那一方迟迟收不到这个确认报文，就会触发超时重传机制，重传 SYN-ACK 报文，直到收到第三次握手，或者达到最大重传次数。&lt;/p>
&lt;p>注意，&lt;strong>ACK 报文是不会有重传的，当 ACK 丢失了，就由对方重传对应的报文&lt;/strong>。&lt;/p>
&lt;h3 id="tcp-四次挥手期间的异常">TCP 四次挥手期间的异常&lt;/h3>
&lt;p>我们再来看看 TCP 四次挥手的过程。&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/24e305c7-9ba8-4113-9be1-44404948d366/640" alt="">&lt;/p>
&lt;h4 id="第一次挥手丢失了会发生什么">第一次挥手丢失了，会发生什么？&lt;/h4>
&lt;p>当客户端（主动关闭方）调用 close 函数后，就会向服务端发送 FIN 报文，试图与服务端断开连接，此时客户端的连接进入到 &lt;code>FIN_WAIT_1&lt;/code> 状态。&lt;/p>
&lt;p>正常情况下，如果能及时收到服务端（被动关闭方）的 ACK，则会很快变为 &lt;code>FIN_WAIT2&lt;/code> 状态。&lt;/p>
&lt;p>如果第一次挥手丢失了，那么客户端迟迟收不到被动方的 ACK 的话，也就会触发超时重传机制，重传 FIN 报文，重发次数由 &lt;code>tcp_orphan_retries&lt;/code> 参数控制。&lt;/p>
&lt;p>当客户端重传 FIN 报文的次数超过 &lt;code>tcp_orphan_retries&lt;/code>   后，就不再发送 FIN 报文，直接进入到 &lt;code>close&lt;/code> 状态。&lt;/p>
&lt;h4 id="第二次挥手丢失了会发生什么">第二次挥手丢失了，会发生什么？&lt;/h4>
&lt;p>当服务端收到客户端的第一次挥手后，就会先回一个 ACK 确认报文，此时服务端的连接进入到 &lt;code>CLOSE_WAIT&lt;/code> 状态。&lt;/p>
&lt;p>在前面我们也提了，ACK 报文是不会重传的，所以如果服务端的第二次挥手丢失了，客户端就会触发超时重传机制，重传 FIN 报文，直到收到服务端的第二次挥手，或者达到最大的重传次数。&lt;/p>
&lt;p>这里提一下，当客户端收到第二次挥手，也就是收到服务端发送的 ACK 报文后，客户端就会处于 &lt;code>FIN_WAIT2&lt;/code> 状态，在这个状态需要等服务端发送第三次挥手，也就是服务端的 FIN 报文。&lt;/p>
&lt;p>对于 close 函数关闭的连接，由于无法再发送和接收数据，所以&lt;code>FIN_WAIT2&lt;/code> 状态不可以持续太久，而  &lt;code>tcp_fin_timeout&lt;/code> 控制了这个状态下连接的持续时长，默认值是 60 秒。&lt;/p>
&lt;p>这意味着对于调用 close 关闭的连接，如果在 60 秒后还没有收到 FIN 报文，客户端（主动关闭方）的连接就会直接关闭。&lt;/p>
&lt;h4 id="第三次挥手丢失了会发生什么">第三次挥手丢失了，会发生什么？&lt;/h4>
&lt;p>当服务端（被动关闭方）收到客户端（主动关闭方）的 FIN 报文后，内核会自动回复 ACK，同时连接处于 &lt;code>CLOSE_WAIT&lt;/code> 状态，顾名思义，它表示等待应用进程调用 close 函数关闭连接。&lt;/p>
&lt;p>此时，内核是没有权利替代进程关闭连接，必须由进程主动调用 close 函数来触发服务端发送 FIN 报文。&lt;/p>
&lt;p>服务端处于 CLOSE_WAIT 状态时，调用了 close 函数，内核就会发出 FIN 报文，同时连接进入 LAST_ACK 状态，等待客户端返回 ACK 来确认连接关闭。&lt;/p>
&lt;p>如果迟迟收不到这个 ACK，服务端就会重发 FIN 报文，重发次数仍然由 &lt;code>tcp_orphan_retrie&lt;/code>s 参数控制，这与客户端重发 FIN 报文的重传次数控制方式是一样的。&lt;/p>
&lt;h4 id="第四次挥手丢失了会发生什么">第四次挥手丢失了，会发生什么？&lt;/h4>
&lt;p>当客户端收到服务端的第三次挥手的 FIN 报文后，就会回 ACK 报文，也就是第四次挥手，此时客户端连接进入 &lt;code>TIME_WAIT&lt;/code> 状态。&lt;/p>
&lt;p>在 Linux 系统，TIME_WAIT 状态会持续 60 秒后才会进入关闭状态。&lt;/p>
&lt;p>然后，服务端（被动关闭方）没有收到 ACK 报文前，还是处于 LAST_ACK 状态。&lt;/p>
&lt;p>如果第四次挥手的 ACK 报文没有到达服务端，服务端就会重发 FIN 报文，重发次数仍然由前面介绍过的 &lt;code>tcp_orphan_retries&lt;/code> 参数控制。&lt;/p>
&lt;hr>
&lt;p>是吧，TCP 聪明着很！&lt;/p></description></item><item><title>Docs: TCP/IP 管理工具</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/4.%E6%95%B0%E6%8D%AE%E9%80%9A%E4%BF%A1/%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/3_4.tcp_ip/tcp_ip-%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/4.%E6%95%B0%E6%8D%AE%E9%80%9A%E4%BF%A1/%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/3_4.tcp_ip/tcp_ip-%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;h1 id="获取本机公网-ip">获取本机公网 IP&lt;/h1>
&lt;h2 id="ipify">ipify&lt;/h2>
&lt;p>&lt;a href="https://geo.ipify.org/docs">https://geo.ipify.org/docs&lt;/a>&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">func&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">res&lt;/span>, &lt;span style="color:#a6e22e">_&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">http&lt;/span>.&lt;span style="color:#a6e22e">Get&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;https://api.ipify.org&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">ip&lt;/span>, &lt;span style="color:#a6e22e">_&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">ioutil&lt;/span>.&lt;span style="color:#a6e22e">ReadAll&lt;/span>(&lt;span style="color:#a6e22e">res&lt;/span>.&lt;span style="color:#a6e22e">Body&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">os&lt;/span>.&lt;span style="color:#a6e22e">Stdout&lt;/span>.&lt;span style="color:#a6e22e">Write&lt;/span>(&lt;span style="color:#a6e22e">ip&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="其他">其他&lt;/h2>
&lt;p>&lt;a href="https://ip.netarm.com">https://ip.netarm.com&lt;/a>
&lt;a href="http://ip.cip.cc">http://ip.cip.cc&lt;/a>
&lt;a href="http://ip.sb">http://ip.sb&lt;/a>
&lt;a href="https://geo.ipify.org/docs">
&lt;/a>&lt;/p></description></item><item><title>Docs: UDP</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/4.%E6%95%B0%E6%8D%AE%E9%80%9A%E4%BF%A1/%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/3_4.tcp_ip/udp/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/4.%E6%95%B0%E6%8D%AE%E9%80%9A%E4%BF%A1/%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/3_4.tcp_ip/udp/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;/blockquote>
&lt;h2 id="udp-介绍">UDP 介绍&lt;/h2>
&lt;p>&lt;strong>User Datagram Protocol (用户数据报协议，简称 UDP)&lt;/strong>。&lt;/p>
&lt;p>不保证数据报文是否安全可靠的到达对方&lt;/p></description></item></channel></rss>