<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>断念梦 – Docker</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/10.%E4%BA%91%E5%8E%9F%E7%94%9F/2.2.%E5%AE%9E%E7%8E%B0%E5%AE%B9%E5%99%A8%E7%9A%84%E5%B7%A5%E5%85%B7/docker/</link><description>Recent content in Docker on 断念梦</description><generator>Hugo -- gohugo.io</generator><atom:link href="https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/10.%E4%BA%91%E5%8E%9F%E7%94%9F/2.2.%E5%AE%9E%E7%8E%B0%E5%AE%B9%E5%99%A8%E7%9A%84%E5%B7%A5%E5%85%B7/docker/index.xml" rel="self" type="application/rss+xml"/><item><title>Docs: Docker</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/10.%E4%BA%91%E5%8E%9F%E7%94%9F/2.2.%E5%AE%9E%E7%8E%B0%E5%AE%B9%E5%99%A8%E7%9A%84%E5%B7%A5%E5%85%B7/docker/docker/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/10.%E4%BA%91%E5%8E%9F%E7%94%9F/2.2.%E5%AE%9E%E7%8E%B0%E5%AE%B9%E5%99%A8%E7%9A%84%E5%B7%A5%E5%85%B7/docker/docker/</guid><description/></item><item><title>Docs: Docker API</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/10.%E4%BA%91%E5%8E%9F%E7%94%9F/2.2.%E5%AE%9E%E7%8E%B0%E5%AE%B9%E5%99%A8%E7%9A%84%E5%B7%A5%E5%85%B7/docker/docker-api/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/10.%E4%BA%91%E5%8E%9F%E7%94%9F/2.2.%E5%AE%9E%E7%8E%B0%E5%AE%B9%E5%99%A8%E7%9A%84%E5%B7%A5%E5%85%B7/docker/docker-api/</guid><description>
&lt;p>Docker API 官方文档：&lt;a href="https://docs.docker.com/engine/api/latest/">https://docs.docker.com/engine/api/latest/&lt;/a>&lt;/p></description></item><item><title>Docs: Docker Compose</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/10.%E4%BA%91%E5%8E%9F%E7%94%9F/2.2.%E5%AE%9E%E7%8E%B0%E5%AE%B9%E5%99%A8%E7%9A%84%E5%B7%A5%E5%85%B7/docker/docker-compose/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/10.%E4%BA%91%E5%8E%9F%E7%94%9F/2.2.%E5%AE%9E%E7%8E%B0%E5%AE%B9%E5%99%A8%E7%9A%84%E5%B7%A5%E5%85%B7/docker/docker-compose/</guid><description>
&lt;p>参考：&lt;a href="https://docs.docker.com/compose/">官方文档&lt;/a>、&lt;a href="https://compose-spec.io/">菜鸟教程&lt;/a>、&lt;a href="https://compose-spec.io/">Compose 规范&lt;/a>&lt;/p>
&lt;h1 id="docker-compose-简介">Docker Compose 简介&lt;/h1>
&lt;p>Compose 是用于定义和运行多容器 Docker 应用程序的工具。通过 Compose，您可以使用 YML 文件来配置应用程序需要的所有服务。然后，使用一个命令，就可以通过该配置文件创建并启动所有服务。&lt;/p>
&lt;p>Compose 使用的三个步骤：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>使用 Dockerfile 定义应用程序的环境。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>使用 docker-compose.yml 定义构成应用程序的服务，这样它们可以在隔离环境中一起运行。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>最后，执行 docker-compose up 命令来启动并运行整个应用程序。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>docker-compose.yml 的配置案例如下（配置参数参考下文）：&lt;/p>
&lt;h2 id="实例">实例&lt;/h2>
&lt;pre>&lt;code># yaml 配置实例
version: '3'
services:
web:
build: .
ports:
- &amp;quot;5000:5000&amp;quot;
volumes:
- .:/code
- logvolume01:/var/log
links:
- redis
redis:
image: redis
volumes:
logvolume01: {}
&lt;/code>&lt;/pre>
&lt;h1 id="compose-安装">Compose 安装&lt;/h1>
&lt;p>Linux 上我们可以从 Github 上下载它的二进制包来使用，最新发行的版本地址：&lt;a href="https://github.com/docker/compose/releases">https://github.com/docker/compose/releases&lt;/a>。&lt;/p>
&lt;p>运行以下命令以下载 Docker Compose 的当前稳定版本：&lt;/p>
&lt;pre>&lt;code>$ sudo curl -L &amp;quot;https://github.com/docker/compose/releases/download/1.27.4/docker-compose-$(uname -s)-$(uname -m)&amp;quot; -o /usr/local/bin/docker-compose
&lt;/code>&lt;/pre>
&lt;p>要安装其他版本的 Compose，请替换 1.24.1。&lt;/p>
&lt;p>将可执行权限应用于二进制文件：&lt;/p>
&lt;pre>&lt;code>$ sudo chmod +x /usr/local/bin/docker-compose
&lt;/code>&lt;/pre>
&lt;p>测试是否安装成功：&lt;/p>
&lt;pre>&lt;code>$ docker-compose version
docker-compose version 1.27.4, build 40524192
docker-py version: 4.3.1
CPython version: 3.7.7
OpenSSL version: OpenSSL 1.1.0l 10 Sep 2019
&lt;/code>&lt;/pre>
&lt;p>&lt;strong>注意&lt;/strong>： 对于 alpine，需要以下依赖包： py-pip，python-dev，libffi-dev，openssl-dev，gcc，libc-dev，和 make。&lt;/p>
&lt;p>使用&lt;/p>
&lt;h3 id="1准备xa">1、准备
&lt;/h3>
&lt;p>创建一个测试目录：&lt;/p>
&lt;pre>&lt;code>$ mkdir composetest
$ cd composetest
&lt;/code>&lt;/pre>
&lt;p>在测试目录中创建一个名为 app.py 的文件，并复制粘贴以下内容：&lt;/p>
&lt;p>composetest/app.py 文件代码&lt;/p>
&lt;pre>&lt;code>import time
import redis
from flask import Flask
app = Flask(__name__)
cache = redis.Redis(host='redis', port=6379)
def get_hit_count():
retries = 5
while True:
try:
return cache.incr('hits')
except redis.exceptions.ConnectionError as exc:
if retries == 0:
raise exc
retries -= 1
time.sleep(0.5)
@app.route('/')
def hello():
count = get_hit_count()
return 'Hello World! I have been seen {} times.\n'.format(count)
&lt;/code>&lt;/pre>
&lt;p>在此示例中，redis 是应用程序网络上的 redis 容器的主机名，该主机使用的端口为 6379。&lt;/p>
&lt;p>在 composetest 目录中创建另一个名为 requirements.txt 的文件，内容如下：&lt;/p>
&lt;pre>&lt;code>flask
redis
&lt;/code>&lt;/pre>
&lt;h3 id="2创建-dockerfile-文件">2、创建 Dockerfile 文件&lt;/h3>
&lt;p>在 composetest 目录中，创建一个名为的文件 Dockerfile，内容如下：&lt;/p>
&lt;pre>&lt;code>FROM python:3.7-alpine
WORKDIR /code
ENV FLASK_APP app.py
ENV FLASK_RUN_HOST 0.0.0.0
RUN apk add --no-cache gcc musl-dev linux-headers
COPY requirements.txt requirements.txt
RUN pip install -r requirements.txt
COPY . .
CMD [&amp;quot;flask&amp;quot;, &amp;quot;run&amp;quot;]
&lt;/code>&lt;/pre>
&lt;p>&lt;strong>Dockerfile 内容解释：&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>
&lt;p>&lt;strong>FROM python:3.7-alpine&lt;/strong>: 从 Python 3.7 映像开始构建镜像。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>WORKDIR /code&lt;/strong>: 将工作目录设置为 /code。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>ENV FLASK_APP app.pyENV FLASK_RUN_HOST 0.0.0.0 设置 flask 命令使用的环境变量。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>RUN apk add &amp;ndash;no-cache gcc musl-dev linux-headers&lt;/strong>: 安装 gcc，以便诸如 MarkupSafe 和 SQLAlchemy 之类的 Python 包可以编译加速。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>COPY requirements.txt requirements.txtRUN pip install -r requirements.txt 复制 requirements.txt 并安装 Python 依赖项。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>COPY . .&lt;/strong>: 将 . 项目中的当前目录复制到 . 镜像中的工作目录。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>CMD [&amp;ldquo;flask&amp;rdquo;, &amp;ldquo;run&amp;rdquo;]&lt;/strong>: 容器提供默认的执行命令为：flask run。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h3 id="3创建-docker-composeyml">3、创建 docker-compose.yml&lt;/h3>
&lt;p>在测试目录中创建一个名为 docker-compose.yml 的文件，然后粘贴以下内容：&lt;/p>
&lt;h2 id="docker-composeyml-配置文件">docker-compose.yml 配置文件&lt;/h2>
&lt;pre>&lt;code># yaml 配置
version: '3'
services:
web:
build: .
ports:
- &amp;quot;5000:5000&amp;quot;
redis:
image: &amp;quot;redis:alpine&amp;quot;
&lt;/code>&lt;/pre>
&lt;p>该 Compose 文件定义了两个服务：web 和 redis。&lt;/p>
&lt;ul>
&lt;li>
&lt;p>&lt;strong>web&lt;/strong>：该 web 服务使用从 Dockerfile 当前目录中构建的镜像。然后，它将容器和主机绑定到暴露的端口 5000。此示例服务使用 Flask Web 服务器的默认端口 5000 。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>redis&lt;/strong>：该 redis 服务使用 Docker Hub 的公共 Redis 映像。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h3 id="4使用-compose-命令构建和运行您的应用">4、使用 Compose 命令构建和运行您的应用&lt;/h3>
&lt;p>在测试目录中，执行以下命令来启动应用程序：&lt;/p>
&lt;pre>&lt;code>docker-compose up
&lt;/code>&lt;/pre>
&lt;p>如果你想在后台执行该服务可以加上 -d 参数：&lt;/p>
&lt;pre>&lt;code>docker-compose up -d
&lt;/code>&lt;/pre></description></item><item><title>Docs: Docker Compose</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/10.%E4%BA%91%E5%8E%9F%E7%94%9F/2.2.%E5%AE%9E%E7%8E%B0%E5%AE%B9%E5%99%A8%E7%9A%84%E5%B7%A5%E5%85%B7/docker/docker-compose/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/10.%E4%BA%91%E5%8E%9F%E7%94%9F/2.2.%E5%AE%9E%E7%8E%B0%E5%AE%B9%E5%99%A8%E7%9A%84%E5%B7%A5%E5%85%B7/docker/docker-compose/</guid><description/></item><item><title>Docs: Docker Image</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/10.%E4%BA%91%E5%8E%9F%E7%94%9F/2.2.%E5%AE%9E%E7%8E%B0%E5%AE%B9%E5%99%A8%E7%9A%84%E5%B7%A5%E5%85%B7/docker/docker-image/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/10.%E4%BA%91%E5%8E%9F%E7%94%9F/2.2.%E5%AE%9E%E7%8E%B0%E5%AE%B9%E5%99%A8%E7%9A%84%E5%B7%A5%E5%85%B7/docker/docker-image/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://segmentfault.com/a/1190000009309347">https://segmentfault.com/a/1190000009309347&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>在虚拟化中，运行程序的地方是一个虚拟的操作系统。而容器技术中，运行程序的地方是一个容器 image(镜像)。&lt;/p>
&lt;p>容器的镜像与虚拟机的虚拟系统有异曲同工之妙，基本原理相似，只不过虚拟系统可以像正常安装系统一样进行安装，而容器镜像，则是一个已经打包好的操作系统，可以开箱即用。&lt;/p>
&lt;p>由于这种构造，docker 公司研究出一种技术，就是联合文件系统(UnionFS(Union File System))。可以将镜像分为多层(layers)，每层附加一个功能。&lt;/p>
&lt;p>实现联合文件系统的驱动程序：docker 本身支持 overlay，overlay2，aufs，btrfs，devicemapper，vfs 等&lt;/p>
&lt;h2 id="container-image-的分层结构httpwwwcnblogscomcloudman6p6806193html联合文件系统">&lt;a href="http://www.cnblogs.com/CloudMan6/p/6806193.html">Container Image 的分层结构&lt;/a>(联合文件系统)&lt;/h2>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/ma1cb7/1616121959962-5b74016a-126f-4a55-a37f-f93631fd335c.png" alt="">
Container Image 采用分层结构，最底层为 bootfs，其它为 rootfs&lt;/p>
&lt;ol>
&lt;li>bootfs：用于系统引导的文件系统，包括 bootloader 和 kernel，Container 启动完成后会被卸载以节约内存资源&lt;/li>
&lt;li>rootfs：位于 bootfs 之上，表现为 Container 的根文件系统；
&lt;ol>
&lt;li>传统模式中，系统启动时，内核挂载 rootfs 时会先将其挂载为只读模式，完整性自检完成后将其重新挂载为读写模式。&lt;/li>
&lt;li>docker 中，rootfs 由内核挂载为“只读”模式，然后通过“联合挂载”技术额外挂载一个“可写(writable)”层。&lt;/li>
&lt;/ol>
&lt;/li>
&lt;/ol>
&lt;p>可以这么理解：&lt;/p>
&lt;ol>
&lt;li>通过一个 Base Image 启动了一个 Container，然后安装一个 vim 编辑器，commit 这个 container，生成的新镜像就是两层，第一层是系统，第二层是 vim。&lt;/li>
&lt;li>这时候用这个这个新的 image 启动一个 Container 后，再安装一个 Nginx，然后 commit 这个 Container，生成的新镜像就是三层，1 系统、2vim、3nginx。&lt;/li>
&lt;li>以此类推，每一次 Container 的变化被 commit 后都可以当作一层。&lt;/li>
&lt;li>对 Container 的操作产生的变化，是在可写的容器层中进行的&lt;/li>
&lt;/ol>
&lt;h2 id="可写writable的层layers">可写(writable)的层(layers)&lt;/h2>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/ma1cb7/1616121959993-37ba6cb0-18ec-495b-84c0-72e941c5a240.png" alt="">
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/ma1cb7/1616121960020-2c73e0a5-a7e5-4e71-9907-d098c5233d30.png" alt="">
当容器启动时，一个新的“可读写”层被加载到镜像的顶部。这一层通常被称作“容器层”，“容器层”之下的都叫“镜像层”。位于下层的 image 称为父镜像(parent image)，最底层的称为基础镜像(base image)&lt;/p>
&lt;p>所有对容器的改动 - 无论添加、删除、还是修改文件都只会发生在容器层中。&lt;/p>
&lt;p>只有容器层是“可读写”的，容器层下面的所有镜像层都是“只读”的。&lt;/p>
&lt;p>镜像层数量可能会很多，所有镜像层会联合在一起组成一个统一的文件系统。如果不同层中有一个相同路径的文件，比如 /a，上层的 /a 会覆盖下层的 /a，也就是说用户只能访问到上层中的文件 /a。在容器层中，用户看到的是一个叠加之后的文件系统。&lt;/p>
&lt;ol>
&lt;li>添加文件：在容器中创建文件时，新文件被添加到容器层中。&lt;/li>
&lt;li>读取文件 ：在容器中读取某个文件时，Docker 会从上往下依次在各镜像层中查找此文件。一旦找到，打开并读入内存。&lt;/li>
&lt;li>修改文件 ：在容器中修改已存在的文件时，Docker 会从上往下依次在各镜像层中查找此文件。一旦找到，立即将其复制到容器层，然后修改之。&lt;/li>
&lt;li>删除文件 ：在容器中删除文件时，Docker 也是从上往下依次在镜像层中查找此文件。找到后，会在容器层中记录下此删除操作。&lt;/li>
&lt;/ol>
&lt;p>只有当需要修改时才复制一份数据，这种特性被称作 Copy-on-Write。可见，容器层保存的是镜像变化的部分，不会对镜像本身进行任何修改；所以，如果多个容器共享一份基础镜像，当某个容器修改了基础镜像的内容，比如 /etc 下的文件，这时其他容器的 /etc 不会被修改，因为修改的只是容器层那个变化的地方，底下的镜像层是不变的&lt;/p>
&lt;p>为什么 Docker Image 要采用这种分层结构呢？&lt;/p>
&lt;p>最大的一个好处就是 - 共享资源。&lt;/p>
&lt;p>比如：有多个镜像都从相同的 base 镜像构建而来，那么 Docker Host 只需在磁盘上保存一份 base 镜像；同时内存中也只需加载一份 base 镜像，就可以为所有容器服务了。而且镜像的每一层都可以被共享。&lt;/p>
&lt;p>比如当我获取一个镜像时，可以看到下面的信息&lt;/p>
&lt;pre>&lt;code>[root@master overlay2]# docker pull lchdzh/network-test:v2.0
v2.0: Pulling from lchdzh/network-test
f34b00c7da20: Pull complete # 镜像第一层
b248a5455a16: Pull complete # 镜像第二层
beaf4c6c50c6: Pull complete # 镜像第三层
Digest: sha256:b27d98887f62c0cf28bc8707ee2de39f8c753afbd047e910e6f1cf2670ae141b
Status: Downloaded newer image for lchdzh/network-test:v2.0
docker.io/lchdzh/network-test:v2.0
&lt;/code>&lt;/pre>
&lt;p>在获取镜像时可以看到，一共有三个层的镜像需要下载。&lt;/p>
&lt;p>而当容器运行时，我们通过 mount 命令可以看到如下内容&lt;/p>
&lt;pre>&lt;code>overlay on /var/lib/docker/overlay2/XXXXXXX/merged type overlay (rw,relatime,lowerdir=/var/lib/docker/overlay2/l/XFVMRG3WBD4RLHJ73V5DQHSCZ5:/var/lib/docker/overlay2/l/PZG7BURXDF2DQ4FF54XUEGZE6A:/var/lib/docker/overlay2/l/L4GF2CGQ7LA6LAACXSSE5CMC4P:/var/lib/docker/overlay2/l/6XYKKSJHBNHYSTQMCETDRWL2AA,upperdir=/var/lib/docker/overlay2/7b64f08bef3ca5ab8a2aa0fa0b124b4e55f3f98f421d0cfe7dab271447cb77a2/diff,workdir=/var/lib/docker/overlay2/7b64f08bef3ca5ab8a2aa0fa0b124b4e55f3f98f421d0cfe7dab271447cb77a2/work)
&lt;/code>&lt;/pre>
&lt;p>这就是那个读写层，这就说明当一个容器运行的时候，会在 docker 的存储类型(这里是 overlay2)目录中，创建一个 XXX/merged 的目录，如果通过 docker exec 进入容器的话，会发现容器中的目录内容与该目录一模一样，并且如果在宿主机上的挂载目录修改文件，同样会影响到容器中。&lt;/p>
&lt;h1 id="docker-image-的管理标准oci-标准介绍">Docker Image 的管理标准(OCI 标准)介绍&lt;/h1>
&lt;p>OCI 规范详见：&lt;a href="https://www.yuque.com/go/doc/33996191">OCI 标准介绍&lt;/a>&lt;/p>
&lt;h2 id="docker-pull-命令的大概过程">docker pull 命令的大概过程&lt;/h2>
&lt;p>如果对 Image manifest，Image Config 和 Filesystem Layers 等概念不是很了解，请先参考 image(镜像)是什么。&lt;/p>
&lt;p>拉取 image 的大概过程如下：&lt;/p>
&lt;ul>
&lt;li>docker 发送 image 的名称+tag（或者 digest）给 registry 服务器，服务器根据收到的 image 的名称+tag（或者 digest），找到相应 image 的 manifest，然后将 manifest 返回给 docker&lt;/li>
&lt;li>docker 得到 manifest 后，读取里面 image 配置文件的 digest(sha256)，这个 sha256 码就是 image 的 ID&lt;/li>
&lt;li>根据 ID 在本地找有没有存在同样 ID 的 image，有的话就不用继续下载了&lt;/li>
&lt;li>如果没有，那么会给 registry 服务器发请求（里面包含配置文件的 sha256 和 media type），拿到 image 的配置文件（Image Config）&lt;/li>
&lt;li>根据配置文件中的 diff_ids（每个 diffid 对应一个 layer tar 包的 sha256，tar 包相当于 layer 的原始格式），在本地找对应的 layer 是否存在&lt;/li>
&lt;li>如果 layer 不存在，则根据 manifest 里面 layer 的 sha256 和 media type 去服务器拿相应的 layer（相当去拿压缩格式的包）。&lt;/li>
&lt;li>拿到后进行解压，并检查解压后 tar 包的 sha256 能否和配置文件（Image Config）中的 diff_id 对的上，对不上说明有问题，下载失败&lt;/li>
&lt;li>根据 docker 所用的后台文件系统类型，解压 tar 包并放到指定的目录&lt;/li>
&lt;li>等所有的 layer 都下载完成后，整个 image 下载完成，就可以使用了&lt;/li>
&lt;/ul>
&lt;p>注意： 对于 layer 来说，config 文件中 diffid 是 layer 的 tar 包的 sha256，而 manifest 文件中的 digest 依赖于 media type，比如 media type 是 tar+gzip，那 digest 就是 layer 的 tar 包经过 gzip 压缩后的内容的 sha256，如果 media type 就是 tar 的话，diffid 和 digest 就会一样。&lt;/p>
&lt;p>dockerd 和 registry 服务器之间的协议为 Registry HTTP API V2。&lt;/p>
&lt;h2 id="oci-image-中的各种标识符xxxid">OCI Image 中的各种标识符(XXXID)&lt;/h2>
&lt;p>在上述四部分中，有多个 XXXID 来标识 docker image 的各种信息&lt;/p>
&lt;ol>
&lt;li>&lt;strong>imageID&lt;/strong> # 镜像的唯一标志，根据镜像的元数据配置文件采用 sha256 算法计算获得
&lt;ol>
&lt;li>imageID 一般可以在 ${DockerRootDir}/image/${StorageDriver}/repositories.json 文件中找到&lt;/li>
&lt;li>镜像的 configuration 文件就是以 imageID 命名，一般保存在 ${DockerRootDir}/image/${StorageDriver}/imagedb/content/sha256/ 目录下&lt;/li>
&lt;/ol>
&lt;/li>
&lt;li>&lt;strong>diffID&lt;/strong> # 镜像层的校验 ID，根据该镜像层的打包文件校验获得
&lt;ol>
&lt;li>diffID 一般在 configuration 文件的 .rootfs.diff_ids 字段中找到&lt;/li>
&lt;/ol>
&lt;/li>
&lt;li>&lt;strong>chainID&lt;/strong> # docker 内容寻址机制采用的索引 ID，其值根据当前层和所有父层的 diffID(或父层的 chainID) 计算获得
&lt;ol>
&lt;li>chainID 计算完成后，一般可以在 ${DockerRootDir}/image/${StorageDriver}/layerdb/sha256/ 目录中找到 chainID 的同名目录&lt;/li>
&lt;/ol>
&lt;/li>
&lt;li>**cacheID **# 下载 layer 时、创建容器后产生可写 layers 时，随机生成的 uuid，用于索引镜像层
&lt;ol>
&lt;li>在 chainID 的目录中，可以找到 image 的 cache-id 文件，文件内容就是 cacheID。&lt;/li>
&lt;li>然后在 ${DockerRootDir}/${StorageDriver}/ 目录中找到与 cacheID 同名的目录，这些目录中存储了镜像层的所有数据&lt;/li>
&lt;li>至于创建容器后生成的可写 layers 的 cacheID 信息，一般是保存在容器相关的信息文件中的，比如容器的状态文件、容器的可写层的信息、系统的 mount 信息等等地方，都会有相关记录&lt;/li>
&lt;/ol>
&lt;/li>
&lt;li>&lt;strong>digest&lt;/strong> # 对于某些 image 来说，可能在发布之后还会做一些更新，比如安全方面的，这时虽然镜像的内容变了，但镜像的名称和 tag 没有变，所以会造成前后两次通过同样的名称和 tag 从服务器得到不同的两个镜像的问题，于是 docker 引入了镜像的 digest 的概念，一个镜像的 digest 就是镜像的 manifes 文件的 sha256 码，当镜像的内容发生变化的时候，即镜像的 layer 发生变化，从而 layer 的 sha256 发生变化，而 manifest 里面包含了每一个 layer 的 sha256，所以 manifest 的 sha256 也会发生变化，即镜像的 digest 发生变化，这样就保证了 digest 能唯一的对应一个镜像&lt;/li>
&lt;/ol>
&lt;h1 id="docker-image-本地路径存放规则">Docker Image 本地路径存放规则&lt;/h1>
&lt;p>现在通过命令 docker pull ubuntu 获取一个镜像(官方提供的最新 ubuntu 镜像，对应的完整名称为 docker.io/library/ubuntu:latest)&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">[&lt;/span>root@lichenhao ~&lt;span style="color:#f92672">]&lt;/span>&lt;span style="color:#75715e"># docker pull ubuntu&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Using default tag: latest
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>latest: Pulling from library/ubuntu
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>a4a2a29f9ba4: Pull complete
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>127c9761dcba: Pull complete
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>d13bf203e905: Pull complete
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>4039240d2e0b: Pull complete
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Digest: sha256:35c4a2c15539c6c1e4e5fa4e554dac323ad0107d8eb5c582d6ff386b383b7dce
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Status: Downloaded newer image &lt;span style="color:#66d9ef">for&lt;/span> ubuntu:latest
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>docker.io/library/ubuntu:latest
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>在 /var/lib/docker/ 目录中，存放着关于 docker image 的所有信息&lt;/p>
&lt;p>首先需要先在 docker 保存 image 的元数据目录(/var/lib/docker/image/)中查找相关信息&lt;/p>
&lt;h2 id="查找镜像的基础信息iamge-id-与-digest">查找镜像的基础信息，IAMGE ID 与 DIGEST&lt;/h2>
&lt;p>/var/lib/docker/image/overlay2/repositories.json 文件中记录了和本地 image 相关的 repository 信息，主要是和 image 的名字和 ID 的对应关系。当 image 从 registry 上被 pull 下来之后，就会更新该文件&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>~&lt;span style="color:#f92672">]&lt;/span>&lt;span style="color:#75715e"># cat repositories.json | jq .&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#34;Repositories&amp;#34;&lt;/span>: &lt;span style="color:#f92672">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e"># 仓库名&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#34;ubuntu&amp;#34;&lt;/span>: &lt;span style="color:#f92672">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e"># IMAGE NAME ，以及 IMAGE ID(在 docker images 命令中，只显示ID的前12位)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#34;ubuntu:latest&amp;#34;&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;sha256:74435f89ab7825e19cf8c92c7b5c5ebd73ae2d0a2be16f49b3fb81c9062ab303&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e"># IMAGE 的 DIGEST，以及 IMAGE ID&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#34;ubuntu@sha256:35c4a2c15539c6c1e4e5fa4e554dac323ad0107d8eb5c582d6ff386b383b7dce&amp;#34;&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;sha256:74435f89ab7825e19cf8c92c7b5c5ebd73ae2d0a2be16f49b3fb81c9062ab303&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>~&lt;span style="color:#f92672">]&lt;/span>&lt;span style="color:#75715e"># docker images --digests&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>REPOSITORY TAG DIGEST IMAGE ID CREATED SIZE
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>ubuntu latest sha256:35c4a2c15539c6c1e4e5fa4e554dac323ad0107d8eb5c582d6ff386b383b7dce 74435f89ab78 &lt;span style="color:#ae81ff">4&lt;/span> days ago 73.9MB
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>~&lt;span style="color:#f92672">]&lt;/span>&lt;span style="color:#75715e"># docker images&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>REPOSITORY TAG IMAGE ID CREATED SIZE
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>ubuntu latest 74435f89ab78 &lt;span style="color:#ae81ff">4&lt;/span> days ago 73.9MB
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="根据基础信息查找镜像层layer的元数据">根据基础信息查找镜像层(layer)的元数据&lt;/h2>
&lt;p>根据 repositories.json 文件中的 IMAGE ID ，可以在如下路径中找到该 image 的 Image Configuration 文件&lt;/p>
&lt;p>/var/lib/docker/image/overlay2/imagedb/content/sha256/74435f89ab7825e19cf8c92c7b5c5ebd73ae2d0a2be16f49b3fb81c9062ab303 文件就是 OCI 标准的 Image Configuration 文件，从该配置文件的 rootfs 字段中，可以看到该 image 包含 4 个镜像层，从上到下依次是底层到顶层的 diffID&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-json" data-lang="json">&lt;span style="display:flex;">&lt;span> &lt;span style="color:#960050;background-color:#1e0010">.....&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#34;rootfs&amp;#34;&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">:&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;type&amp;#34;&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;layers&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;diff_ids&amp;#34;&lt;/span>: [
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#34;sha256:e1c75a5e0bfa094c407e411eb6cc8a159ee8b060cbd0398f1693978b4af9af10&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#34;sha256:9e97312b63ff63ad98bb1f3f688fdff0721ce5111e7475b02ab652f10a4ff97d&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#34;sha256:ec1817c93e7c08d27bfee063f0f1349185a558b87b2d806768af0a8fbbf5bc11&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#34;sha256:05f3b67ed530c5b55f6140dfcdfb9746cdae7b76600de13275197d009086bb3d&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#960050;background-color:#1e0010">....&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Note：该对应关系对查找镜像的存储路径没有绝对关系。在 /var/lib/docker/image/overlay2/distribution/ 目录中，保存了镜像层的 digest 与 diffid 对应关系。&lt;/p>
&lt;ul>
&lt;li>diffid-by-digest： 存放 digest 到 diffid 的对应关系&lt;/li>
&lt;li>v2metadata-by-diffid： 存放 diffid 到 digest 的对应关系&lt;/li>
&lt;/ul>
&lt;p>/var/lib/docker/image/overlay2/layerdb/ 目录下存放了所有镜像层的元数据信息，在 /var/lib/docker/image/overlay2/layerdb/sha256/* 目录下，以镜像层的 chaind 命名。根据 OCI 默认规则，最底下的镜像层 chainid 与 diffid 相同&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">[&lt;/span>root@lichenhao sha256&lt;span style="color:#f92672">]&lt;/span>&lt;span style="color:#75715e"># pwd&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>/var/lib/docker/image/overlay2/layerdb/sha256
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">[&lt;/span>root@lichenhao sha256&lt;span style="color:#f92672">]&lt;/span>&lt;span style="color:#75715e"># ll -h&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>total &lt;span style="color:#ae81ff">0&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>drwx------ &lt;span style="color:#ae81ff">2&lt;/span> root root &lt;span style="color:#ae81ff">85&lt;/span> Jun &lt;span style="color:#ae81ff">21&lt;/span> 19:26 27d46ebb54384edbc8c807984f9eb065321912422b0e6c49d6a9cd8c8b7d8ffc
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>drwx------ &lt;span style="color:#ae81ff">2&lt;/span> root root &lt;span style="color:#ae81ff">85&lt;/span> Jun &lt;span style="color:#ae81ff">21&lt;/span> 19:26 8a8d1f0b34041a66f09e49bdc03e75c2190f606b0db7e08b75eb6747f7b49e11
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>drwx------ &lt;span style="color:#ae81ff">2&lt;/span> root root &lt;span style="color:#ae81ff">71&lt;/span> Jun &lt;span style="color:#ae81ff">21&lt;/span> 19:26 e1c75a5e0bfa094c407e411eb6cc8a159ee8b060cbd0398f1693978b4af9af10
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>drwx------ &lt;span style="color:#ae81ff">2&lt;/span> root root &lt;span style="color:#ae81ff">85&lt;/span> Jun &lt;span style="color:#ae81ff">21&lt;/span> 19:26 f1b8f74eff975ae600be0345aaac8f0a3d16680c2531ffc72f77c5e17cbfeeee
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># echo -n &amp;#34;sha256:父层chainID sha256:本层diffID&amp;#34; | sha256sum -&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># 根据该命令得出本层的 chainID&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># 下面根据最低镜像层计算第二层镜像的 chainid&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">[&lt;/span>root@lichenhao sha256&lt;span style="color:#f92672">]&lt;/span>&lt;span style="color:#75715e"># echo -n &amp;#34;sha256:e1c75a5e0bfa094c407e411eb6cc8a159ee8b060cbd0398f1693978b4af9af10 sha256:9e97312b63ff63ad98bb1f3f688fdff0721ce5111e7475b02ab652f10a4ff97d&amp;#34; | sha256sum -&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>27d46ebb54384edbc8c807984f9eb065321912422b0e6c49d6a9cd8c8b7d8ffc -
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>在每个镜像层的目录中，包含了如下几种信息&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>~&lt;span style="color:#f92672">]&lt;/span>&lt;span style="color:#75715e"># cd /var/lib/docker/image/overlay2/layerdb/sha256 &amp;amp;&amp;amp; ls&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>27d46ebb54384edbc8c807984f9eb065321912422b0e6c49d6a9cd8c8b7d8ffc
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>~&lt;span style="color:#f92672">]&lt;/span>&lt;span style="color:#75715e"># cd 27d46ebb54384edbc8c807984f9eb065321912422b0e6c49d6a9cd8c8b7d8ffc&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>27d46ebb54384edbc8c807984f9eb065321912422b0e6c49d6a9cd8c8b7d8ffc&lt;span style="color:#f92672">]&lt;/span>&lt;span style="color:#75715e"># ls&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>cache-id diff parent size tar-split.json.gz
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># cache-id 是 docker 在下载镜像层时随机生成的 uuid。也就是说，该文件内容指向了真正存放镜像层文件的地方。&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>27d46ebb54384edbc8c807984f9eb065321912422b0e6c49d6a9cd8c8b7d8ffc&lt;span style="color:#f92672">]&lt;/span>&lt;span style="color:#75715e"># cat cache-id&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>5de7ac8af2fb0a5fb0be4244aa07685bfcfcfc4c4b1c149bc753eb044d7f4a12
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># diff 文件存放镜像层的 diffid&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>27d46ebb54384edbc8c807984f9eb065321912422b0e6c49d6a9cd8c8b7d8ffc&lt;span style="color:#f92672">]&lt;/span>&lt;span style="color:#75715e"># cat diff&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>sha256:9e97312b63ff63ad98bb1f3f688fdff0721ce5111e7475b02ab652f10a4ff97d
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># parent 文件存放 当前layer 的 父layer 的 diffid。注意：对于最底层的 layer 来说，由于没有 父layer，所以没有这个文件&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>27d46ebb54384edbc8c807984f9eb065321912422b0e6c49d6a9cd8c8b7d8ffc&lt;span style="color:#f92672">]&lt;/span>&lt;span style="color:#75715e"># cat parent&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>sha256:e1c75a5e0bfa094c407e411eb6cc8a159ee8b060cbd0398f1693978b4af9af10
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># size 文件存放当前镜像层的大小，单位是字节&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>27d46ebb54384edbc8c807984f9eb065321912422b0e6c49d6a9cd8c8b7d8ffc&lt;span style="color:#f92672">]&lt;/span>&lt;span style="color:#75715e"># cat size&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">1006717&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># tar-split.json.gz，layer 压缩包的 split 文件，通过这个文件可以还原 layer 的 tar 包，&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># 在 docker save 导出 image 的时候会用到&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># 详情可参考 https://github.com/vbatts/tar-split&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="根据-cache-id-查找到存放镜像层的路径">根据 cache-id 查找到存放镜像层的路径&lt;/h2>
&lt;p>/var/lib/docker/overlay2/ 目录存放了所有镜像层的数据。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">[&lt;/span>root@lichenhao overlay2&lt;span style="color:#f92672">]&lt;/span>&lt;span style="color:#75715e"># pwd&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>/var/lib/docker/overlay2
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">[&lt;/span>root@lichenhao overlay2&lt;span style="color:#f92672">]&lt;/span>&lt;span style="color:#75715e"># ll -h&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>total &lt;span style="color:#ae81ff">0&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>drwx------ &lt;span style="color:#ae81ff">4&lt;/span> root root &lt;span style="color:#ae81ff">72&lt;/span> Jun &lt;span style="color:#ae81ff">21&lt;/span> 19:26 113a9d8407c2db3892944c17beba7a635ea39aa5108c7f716088466ea302a7e3
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># 根据 cache-id 中显示的信息，ubuntu 第二层镜像就是在这个目录中&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>drwx------ &lt;span style="color:#ae81ff">4&lt;/span> root root &lt;span style="color:#ae81ff">72&lt;/span> Jun &lt;span style="color:#ae81ff">21&lt;/span> 19:26 5de7ac8af2fb0a5fb0be4244aa07685bfcfcfc4c4b1c149bc753eb044d7f4a12
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>drwx------ &lt;span style="color:#ae81ff">4&lt;/span> root root &lt;span style="color:#ae81ff">72&lt;/span> Jun &lt;span style="color:#ae81ff">21&lt;/span> 19:28 7704e53a9392b092479707d38b2b183b17bbe2cc220e2283cead9493e19aa651
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># 根据 cache-id 中显示的信息，ubuntu 最底层的镜像就是在这个目录中&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>drwx------ &lt;span style="color:#ae81ff">3&lt;/span> root root &lt;span style="color:#ae81ff">47&lt;/span> Jun &lt;span style="color:#ae81ff">21&lt;/span> 19:26 8f377ae99a442b37f5a831724951ce1cf8bfc7b874843c97d09e8027c3dd19e6
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>drwx------ &lt;span style="color:#ae81ff">2&lt;/span> root root &lt;span style="color:#ae81ff">142&lt;/span> Jun &lt;span style="color:#ae81ff">21&lt;/span> 21:01 l
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h1 id="怎样修改-docker-容器-hosts-文件的内容">怎样修改 docker 容器 hosts 文件的内容？&lt;/h1>
&lt;p>这就要了解 docker 镜像的分层结构了，其中有一个叫 Init 的层，该层专门用来存储一些配置文件，比如：/etc/hosts、/etc/resolv.conf 等信息的，该层并不会跟随镜像一起提交，所以如果我们直接在 Dockerfile 中去覆盖 /etc/hosts 文件的话是不会生效的，要解决这个问题可以有几种方法：
1. 启动容器的时候(docker run)添加参数—add-host machine:ip 可以实现 hosts 修改，缺点就是如果很多个节点的话命令会很长
2. 修改容器 hosts de 查找目录，我们可以让容器启动的时候不去找 /etc/hosts 文件，而是去查找我们自己定义的 hosts 文件，下面是一个 Dockerfile 实例：&lt;/p>
&lt;pre>&lt;code>FROM ubuntu:14.04
RUN cp /etc/hosts /tmp/hosts # 路径长度最好保持一致
RUN mkdir -p -- /lib-override &amp;amp;&amp;amp; cp /lib/x86_64-linux-gnu/libnss_files.so.2 /lib-override
RUN sed -i 's:/etc/hosts:/tmp/hosts:g' /lib-override/libnss_files.so.2
ENV LD_LIBRARY_PATH /lib-override
RUN echo &amp;quot;192.168.0.1 node1&amp;quot; &amp;amp;gt;&amp;amp;gt; /tmp/hosts # 可以随意修改/tmp/hosts了
...
&lt;/code>&lt;/pre>
&lt;ol start="3">
&lt;li>
&lt;p>在 dockerfile 中，使用脚本作为镜像入口，然后利用脚本运行修改 hosts 文件的命令以及真正的应用程序入口，下面是一个 Dockerfile 实例：&lt;/p>
&lt;p>FROM centos:6
RUN mkdir /data
COPY run.sh /data/
COPY myhosts /data/
RUN chmod +x /data/run.sh
ENTRYPOINT /bin/sh -c /data/run.sh&lt;/p>
&lt;/li>
&lt;/ol>
&lt;p>其中 run.sh 示例：
#!/bin/bash
cat /data/myhosts &amp;raquo; /etc/hosts # 向 hosts 文件追加内容&lt;/p>
&lt;h1 id="binbash--保留终端防止容器自动退出">其他命令
/bin/bash # 保留终端，防止容器自动退出&lt;/h1>
&lt;p>然后在 myhosts 文件中添加上你需要添加的 hosts 映射，然后镜像构建完成后，执行 docker run 指令运行容器，查看 /etc/hosts 配置是否生效。&lt;/p>
&lt;p>这个问题最重要的就是要理解 docker 镜像的分层结构，由只读层+可读写层+ init 层组成。
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/ma1cb7/1616121959946-c34b9fbf-7490-4ef8-919e-433e1c41f5b8.png" alt="">&lt;/p></description></item><item><title>Docs: Docker Runtime</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/10.%E4%BA%91%E5%8E%9F%E7%94%9F/2.2.%E5%AE%9E%E7%8E%B0%E5%AE%B9%E5%99%A8%E7%9A%84%E5%B7%A5%E5%85%B7/docker/docker-runtime/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/10.%E4%BA%91%E5%8E%9F%E7%94%9F/2.2.%E5%AE%9E%E7%8E%B0%E5%AE%B9%E5%99%A8%E7%9A%84%E5%B7%A5%E5%85%B7/docker/docker-runtime/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;p>Runtime 和 Image 一样，也有标准，也由 OCI 维护，官方详解地址为：runtime-spec。现阶段 Docker 的 1.19 版本使用 runc 作为 Runtime&lt;/p>
&lt;p>OCI Runtime 旨在指定 Container 的配置、执行环境和生命周期。&lt;/p>
&lt;p>容器的配置被指定为 config.json ，并详细说明了可以创建容器的字段。指定执行环境是为了确保容器内运行的应用程序在运行时之间具有一致的环境，以及为容器的生命周期定义的常见操作。&lt;/p>
&lt;p>runtime 规范有如下几个，所有人必须遵守该规范来使用 runtime 。&lt;/p>
&lt;ol>
&lt;li>Filesystem Bundle # 文件系统捆绑。bundle 是以某种方式组织的一组文件，包含了容器所需要的所有信息，有了这个 bundle 后，符合 runtime 标准的程序(e.g.runc)就可以根据 bundle 启动容器了(哪怕没有 docker，也可以启动一个容器)。&lt;/li>
&lt;li>Runtime and Lifecycle #&lt;/li>
&lt;li>Linux-specific Runtime and Lifecycle # 这是关于 linux 平台的 Runtime 与 Lifecycle&lt;/li>
&lt;li>Configuration # Configuration 包含对容器执行标准操作(比如 create、start、stop 等)所必须的元数据。这包括要运行的过程、要注入的环境变量、要使用的沙盒功能等等。不同平台(linux、window 等)，有不同的规范。&lt;/li>
&lt;li>Linux-specific configuration #这是关于 linux 平台的 Configuration&lt;/li>
&lt;/ol>
&lt;h1 id="docker-create">Docker create&lt;/h1>
&lt;p>有了 image 之后，就可以使用 image 来创建并启动 container 了。&lt;/p>
&lt;p>docker run 命令直接创建并运行一个容器，它的背后其实包含独立的两步，一步是 docker create 创建容器，另一步是 docker start 启动容器，先介绍在 docker create 这一步中，docker 做了哪些事情。&lt;/p>
&lt;p>简单点来说，dockerd 在收到客户端的创建容器请求后，做了两件事情&lt;/p>
&lt;ol>
&lt;li>
&lt;p>准备容器所需的 layer&lt;/p>
&lt;/li>
&lt;li>
&lt;p>检查客户端传过来的参数，并和 image 配置文件中的参数进行合并，然后存储成容器的配置文件。&lt;/p>
&lt;h1 id="创建容器前的-layers">创建容器前的 layers&lt;/h1>
&lt;p>[root@lichenhao overlay2]# ls
113a9d8407c2db3892944c17beba7a635ea39aa5108c7f716088466ea302a7e3 7704e53a9392b092479707d38b2b183b17bbe2cc220e2283cead9493e19aa651 l
5de7ac8af2fb0a5fb0be4244aa07685bfcfcfc4c4b1c149bc753eb044d7f4a12 8f377ae99a442b37f5a831724951ce1cf8bfc7b874843c97d09e8027c3dd19e6&lt;/p>
&lt;h1 id="创建容器后的-layers多了两个">创建容器后的 layers，多了两个&lt;/h1>
&lt;p>[root@lichenhao overlay2]# docker create -it &amp;ndash;name docker_runtime_test ubuntu:latest
28f5bed704dc80bed6dbaa8af514d2191d8d4ab0339bb3a663e66609ccd34c10
[root@lichenhao overlay2]# ls
113a9d8407c2db3892944c17beba7a635ea39aa5108c7f716088466ea302a7e3 8f377ae99a442b37f5a831724951ce1cf8bfc7b874843c97d09e8027c3dd19e6 l
5de7ac8af2fb0a5fb0be4244aa07685bfcfcfc4c4b1c149bc753eb044d7f4a12 d976eddf7575a3464486d92539229146f3df66080a3265195791ebb0d24b24dd
7704e53a9392b092479707d38b2b183b17bbe2cc220e2283cead9493e19aa651 d976eddf7575a3464486d92539229146f3df66080a3265195791ebb0d24b24dd-init&lt;/p>
&lt;h1 id="这俩-layers-的元数据在-dockerrootdirimagestoragedriverlayerdbmounts目录中">这俩 layers 的元数据在 ${DockerRootDir}/image/${StorageDriver}/layerdb/mounts目录中&lt;/h1>
&lt;p>[root@lichenhao 28f5bed704dc80bed6dbaa8af514d2191d8d4ab0339bb3a663e66609ccd34c10]# pwd
/var/lib/docker/image/overlay2/layerdb/mounts/28f5bed704dc80bed6dbaa8af514d2191d8d4ab0339bb3a663e66609ccd34c10
[root@lichenhao 28f5bed704dc80bed6dbaa8af514d2191d8d4ab0339bb3a663e66609ccd34c10]# ls
init-id mount-id parent&lt;/p>
&lt;h1 id="init-id-文件包含了-init-layer-的-cacheid">init-id 文件包含了 init layer 的 cacheID&lt;/h1>
&lt;h1 id="init-layer-的-cacheid-就是在-mount-layer-的-cacheid-后面加上了一个-init">init layer 的 cacheid 就是在 mount layer 的 cacheID 后面加上了一个“-init”&lt;/h1>
&lt;p>[root@lichenhao 28f5bed704dc80bed6dbaa8af514d2191d8d4ab0339bb3a663e66609ccd34c10]# cat init-id
d976eddf7575a3464486d92539229146f3df66080a3265195791ebb0d24b24dd-init&lt;/p>
&lt;h1 id="mount-id-文件包含了-mount-layer-的-cacheid">mount-id 文件包含了 mount layer 的 cacheID&lt;/h1>
&lt;p>[root@lichenhao 28f5bed704dc80bed6dbaa8af514d2191d8d4ab0339bb3a663e66609ccd34c10]# cat mount-id
d976eddf7575a3464486d92539229146f3df66080a3265195791ebb0d24b24dd&lt;/p>
&lt;h1 id="parent-里面包含的是-image-的最上-layer-的-chainid">parent 里面包含的是 image 的最上 layer 的 chainID&lt;/h1>
&lt;h1 id="表示这个容器的-init-layer-的父-layer-是-image-的最顶层-layer">表示这个容器的 init layer 的父 layer 是 image 的最顶层 layer&lt;/h1>
&lt;p>[root@lichenhao 28f5bed704dc80bed6dbaa8af514d2191d8d4ab0339bb3a663e66609ccd34c10]# cat parent
sha256:8a8d1f0b34041a66f09e49bdc03e75c2190f606b0db7e08b75eb6747f7b49e11&lt;/p>
&lt;/li>
&lt;/ol>
&lt;p>Note:&lt;/p>
&lt;ol>
&lt;li>新加的这两层 layer 比较特殊，元数据只保存在 layerdb/mounts 下面，在 layerdb/sha256 目录下没有相关信息，说明 docker 将 container 的 layer 和 image 的 layer 的元数据放在了不同的两个目录中。&lt;/li>
&lt;li>根据元数据中的信息，就可以通过 mount 信息中的 cacheID 来查找该 mount 信息来源于哪个容器，从而定位问题，参考：最后 docker 使用技巧 中 mount 信息章节&lt;/li>
&lt;/ol>
&lt;p>从上面的文章可以看到，每个创建完的容器都会新增两个层&lt;/p>
&lt;ol>
&lt;li>
&lt;p>mount layer #供容器写数据的层，如果容器仅创建而没运行的话，那么该层的目录中，没有 merged 目录，并且其余目录也是空的&lt;/p>
&lt;p>[root@lichenhao d976eddf7575a3464486d92539229146f3df66080a3265195791ebb0d24b24dd]# tree
.
├── diff
├── link
├── lower
└── work
└── work&lt;/p>
&lt;/li>
&lt;li>
&lt;p>init layer #包含了 docker 为容器所预先准备的文件&lt;/p>
&lt;p>[root@lichenhao d976eddf7575a3464486d92539229146f3df66080a3265195791ebb0d24b24dd-init]# tree
.
├── committed
├── diff
│ ├── dev
│ │ ├── console
│ │ ├── pts
│ │ └── shm
│ └── etc
│ ├── hostname
│ ├── hosts
│ ├── mtab -&amp;gt; /proc/mounts
│ └── resolv.conf
├── link
├── lower
└── work
└── work&lt;/p>
&lt;/li>
&lt;/ol>
&lt;p>init layer 里面的文件有什么作用呢？从下面的结果可以看出，除了 mtab 文件是指向/proc/mounts 的软连接之外，其他的都是空的普通文件。&lt;/p>
&lt;p>这几个文件都是 Linux 运行时必须的文件，如果缺少的话会导致某些程序或者库出现异常，所以 docker 需要为容器准备好这些文件：&lt;/p>
&lt;ul>
&lt;li>/dev/console: 在 Linux 主机上，该文件一般指向主机的当前控制台，有些程序会依赖该文件。在容器启动的时候，docker 会为容器创建一个 pts，然后通过 bind mount 的方式将 pts 绑定到容器里面的/dev/console 上，这样在容器里面往这个文件里面写东西就相当于往容器的控制台上打印数据。这里创建一个空文件相当于占个坑，作为后续 bind mount 的目的路径。&lt;/li>
&lt;li>hostname，hosts，resolv.conf：对于每个容器来说，容器内的这几个文件内容都有可能不一样，这里也只是占个坑，等着 docker 在外面生成这几个文件，然后通过 bind mount 的方式将这些文件绑定到容器中的这些位置，即这些文件都会被宿主机中的文件覆盖掉。&lt;/li>
&lt;li>/etc/mtab：这个文件在新的 Linux 发行版中都指向/proc/mounts，里面包含了当前 mount namespace 中的所有挂载信息，很多程序和库会依赖这个文件。&lt;/li>
&lt;/ul>
&lt;p>注意： 这里 mtab 指向的路径是固定的，但内容是变化的，取决于你从哪里打开这个文件，当在宿主机上打开时，是宿主机上/proc/mounts 的内容，当启动并进入容器后，在容器中打开看到的就是容器中/proc/mounts 的内容。&lt;/p>
&lt;h2 id="容器的元数据">容器的元数据&lt;/h2>
&lt;p>容器创建完成后，就会生成容器的元数据信息，包括默认配置、运行时配置等等，文件在 ${DockerRootDir}/containers/ContainerID/* 目录下&lt;/p>
&lt;p>Note：容器启动后，该目录还会有新的文件产生。&lt;/p>
&lt;pre>&lt;code>[root@lichenhao containers]# pwd
/var/lib/docker/containers
[root@lichenhao containers]# ls
28f5bed704dc80bed6dbaa8af514d2191d8d4ab0339bb3a663e66609ccd34c10
[root@lichenhao containers]# tree
.
├── checkpoints
├── config.v2.json # 通用的配置，如容器名称、启动后要执行的命令等等
└── hostconfig.json # 该容器关于docker 宿主机的配置，日志驱动、是否自动删除、cgroup的配置等等
&lt;/code>&lt;/pre>
&lt;h1 id="docker-start">Docker start&lt;/h1>
&lt;p>容器启动简单流程&lt;/p>
&lt;ul>
&lt;li>docker（client）发送启动容器命令给 dockerd&lt;/li>
&lt;li>dockerd 收到请求后，准备好 rootfs，以及一些其它的配置文件，然后通过 grpc 的方式通知 containerd 启动容器&lt;/li>
&lt;li>containerd 根据收到的请求以及配置文件位置，创建容器运行时需要的 bundle，然后启动 shim 进程，让它来启动容器&lt;/li>
&lt;li>shim 进程启动后，做一些准备工作，然后调用 runc 启动容器&lt;/li>
&lt;/ul>
&lt;p>容器启动后，会在下面几个目录中生成容器运行所需的内容：&lt;/p>
&lt;ul>
&lt;li>/run/docker/runtime-runc/ # 容器状态 json 文件&lt;/li>
&lt;li>/run/docker/containerd/ # 容器的 IO 文件&lt;/li>
&lt;li>/run/containerd/io.containerd.runtime.v1.linux/moby/ # 容器的 bundle 文件、pid 号&lt;/li>
&lt;li>/var/lib/containerd/io.containerd.runtime.v1.linux/moby/ # shim.stderr.log 与 shim.stdout.log&lt;/li>
&lt;/ul>
&lt;p>Note：这些目录在容器停止后，会自动删除&lt;/p>
&lt;pre>&lt;code>[root@lichenhao containerd]# find / -name &amp;quot;28f5bed704dc*&amp;quot;
/run/docker/runtime-runc/moby/28f5bed704dc80bed6dbaa8af514d2191d8d4ab0339bb3a663e66609ccd34c10
/run/docker/containerd/28f5bed704dc80bed6dbaa8af514d2191d8d4ab0339bb3a663e66609ccd34c10
/run/containerd/io.containerd.runtime.v1.linux/moby/28f5bed704dc80bed6dbaa8af514d2191d8d4ab0339bb3a663e66609ccd34c10
/var/lib/containerd/io.containerd.runtime.v1.linux/moby/28f5bed704dc80bed6dbaa8af514d2191d8d4ab0339bb3a663e66609ccd34c10
/var/lib/docker/containers/28f5bed704dc80bed6dbaa8af514d2191d8d4ab0339bb3a663e66609ccd34c10
/var/lib/docker/containers/28f5bed704dc80bed6dbaa8af514d2191d8d4ab0339bb3a663e66609ccd34c10/28f5bed704dc80bed6dbaa8af514d2191d8d4ab0339bb3a663e66609ccd34c10-json.log
/var/lib/docker/image/overlay2/layerdb/mounts/28f5bed704dc80bed6dbaa8af514d2191d8d4ab0339bb3a663e66609ccd34c10
[root@lichenhao docker]# docker stop docker_runtime_test
docker_runtime_test
[root@lichenhao docker]# find / -name &amp;quot;28f5bed704dc*&amp;quot;
/var/lib/docker/containers/28f5bed704dc80bed6dbaa8af514d2191d8d4ab0339bb3a663e66609ccd34c10
/var/lib/docker/containers/28f5bed704dc80bed6dbaa8af514d2191d8d4ab0339bb3a663e66609ccd34c10/28f5bed704dc80bed6dbaa8af514d2191d8d4ab0339bb3a663e66609ccd34c10-json.log
/var/lib/docker/image/overlay2/layerdb/mounts/28f5bed704dc80bed6dbaa8af514d2191d8d4ab0339bb3a663e66609ccd34c10
&lt;/code>&lt;/pre>
&lt;h2 id="准备-rootfs">准备 rootfs&lt;/h2>
&lt;pre>&lt;code># 容器运行后，在没有 mount layer 中，会多出来一个 merged 的目录，这就是当前已经启动容器的可读写层，所有变化都会在这里。
# 并且当容器停止后，merged 目录也会随之消失
[root@lichenhao overlay2]# ls d976eddf7575a3464486d92539229146f3df66080a3265195791ebb0d24b24dd
diff link lower merged work
[root@lichenhao overlay2]# ls d976eddf7575a3464486d92539229146f3df66080a3265195791ebb0d24b24dd-init/
committed diff link lower work
# 当在容器中创建一个文件时，该变化会同时应用到 mount layer 的 diff 和 merged 目录
[root@lichenhao overlay2]# docker start docker_runtime_test
docker_runtime_test
[root@lichenhao overlay2]# docker exec -it docker_runtime_test /bin/bash
root@28f5bed704dc:/# ls
bin boot dev etc home lib lib32 lib64 libx32 media mnt opt proc root run sbin srv sys tmp usr var
root@28f5bed704dc:/# touch home/lichenhao
[root@lichenhao overlay2]# tree d976eddf7575a3464486d92539229146f3df66080a3265195791ebb0d24b24dd/diff/
d976eddf7575a3464486d92539229146f3df66080a3265195791ebb0d24b24dd/diff/
├── home
│ └── lichenhao
└── root
[root@lichenhao overlay2]# tree d976eddf7575a3464486d92539229146f3df66080a3265195791ebb0d24b24dd/merged/home/
d976eddf7575a3464486d92539229146f3df66080a3265195791ebb0d24b24dd/merged/home/
└── lichenhao
# 容器停止后，merged 的目录消失，但是 diff 目录还在，所有对容器的操作产生的变化，都会在diff目录中永久保存，直到该容器被删除。
&lt;/code>&lt;/pre>
&lt;p>可以通过 mount 命令看到如下信息&lt;/p>
&lt;pre>&lt;code>overlay on /var/lib/docker/overlay2/d976eddf7575a3464486d92539229146f3df66080a3265195791ebb0d24b24dd/merged type overlay
(rw,relatime,lowerdir=
/var/lib/docker/overlay2/l/QNYNLXQAPEKTOMU3TO27ITE3YO:
/var/lib/docker/overlay2/l/2EP6BMP6AI5RGGBLLTGZURP72X:
/var/lib/docker/overlay2/l/OLJPRTJOMYVHG3OZOMYZMBAEMQ:
/var/lib/docker/overlay2/l/FWHKA7CXM7LSCGUQLDTAJSZFPE:
/var/lib/docker/overlay2/l/KVQ7AO63OIRUAHZTZAS474Y3VT,
upperdir=/var/lib/docker/overlay2/d976eddf7575a3464486d92539229146f3df66080a3265195791ebb0d24b24dd/diff,
workdir=/var/lib/docker/overlay2/d976eddf7575a3464486d92539229146f3df66080a3265195791ebb0d24b24dd/work)
&lt;/code>&lt;/pre>
&lt;p>通过 overlay 联合挂载技术，将多个 layer 挂载到该容器的 mount layer 的 merged 目录中&lt;/p>
&lt;ol>
&lt;li>lower(下层挂载) #用启动该容器的 image 的所有 layers 作为 lowerdir&lt;/li>
&lt;li>upperdir(上层挂在) #用容器 mount layer 的 diff 目录作为 upperdir&lt;/li>
&lt;/ol>
&lt;p>所有在 merged 目录的变化，会同步到 diff 目录中，这样在容器停止，merged 目录消失后，所有变化依然得以保留在 diff 目录中，这样后续再启动容器的时候，上次的操作还能看到。&lt;/p>
&lt;h2 id="容器元数据目录的变化">容器元数据目录的变化&lt;/h2>
&lt;p>rootfs 准备好之后，dockerd 接着会准备一些容器里面需要用的配置文件，下面是容器元数据目录的变化&lt;/p>
&lt;pre>&lt;code>[root@lichenhao 28f5bed704dc80bed6dbaa8af514d2191d8d4ab0339bb3a663e66609ccd34c10]# tree
.
├── 28f5bed704dc80bed6dbaa8af514d2191d8d4ab0339bb3a663e66609ccd34c10-json.log
├── checkpoints
├── config.v2.json
├── hostconfig.json
├── hostname
├── hosts
├── mounts
├── resolv.conf
└── resolv.conf.hash
&lt;/code>&lt;/pre>
&lt;p>容器启动后多了几个文件，这几个文件时 docker 动态生成的&lt;/p>
&lt;ul>
&lt;li>28f5bed704dc80bed6dbaa8af514d2191d8d4ab0339bb3a663e66609ccd34c10-json.log #容器的日志文件，后续容器的 stdout 和 stderr 都会输出到这个目录。当然如果配置了其它的日志插件的话，日志就会写到别的地方。&lt;/li>
&lt;li>hostname：里面是容器的主机名，来自于 config.v2.json，由 docker create 命令的-h 参数指定，如果没指定的话，就是容器 ID 的前 12 位，这里即为 28f5bed704dc&lt;/li>
&lt;li>resolv.conf：里面包含了 DNS 服务器的 IP，来自于 hostconfig.json，由 docker create 命令的&amp;ndash;dns 参数指定，没有指定的话，docker 会根据容器的网络类型生成一个默认的，一般是主机配置的 DNS 服务器或者是 docker bridge 的 IP。&lt;/li>
&lt;li>resolv.conf.hash：resolv.conf 文件的校验码&lt;/li>
&lt;/ul>
&lt;p>Note：除了日志文件外，其它文件在每次容器启动的时候都会自动生成，所以修改他们的内容后只会在当前容器运行的时候生效，容器重启后，配置又都会恢复到默认的状态&lt;/p>
&lt;h2 id="准备-oci-所需的-bundle">准备 OCI 所需的 bundle&lt;/h2>
&lt;p>bundle 被 docker 放在 /run/containerd/ 目录下，展示如下：&lt;/p>
&lt;pre>&lt;code>[root@lichenhao containerd]# pwd
/run/containerd
[root@lichenhao containerd]# tree
.
├── containerd.sock
├── io.containerd.runtime.v1.linux
│ └── moby
│ └── 28f5bed704dc80bed6dbaa8af514d2191d8d4ab0339bb3a663e66609ccd34c10
│ ├── config.json
│ ├── init.pid
│ ├── log.json
│ └── rootfs
└── io.containerd.runtime.v2.task
&lt;/code>&lt;/pre>
&lt;h2 id="准备-io-文件">准备 IO 文件&lt;/h2>
&lt;p>容器运行所需的 IO 文件被 docker 放在 /run/docker/containerd/* 目录下&lt;/p>
&lt;pre>&lt;code>[root@lichenhao containerd]# pwd
/run/docker/containerd
[root@lichenhao containerd]# tree
.
└── 28f5bed704dc80bed6dbaa8af514d2191d8d4ab0339bb3a663e66609ccd34c10
├── init-stdin
└── init-stdout
&lt;/code>&lt;/pre>
&lt;p>init-stdin 文件用来向容器的 stdin 中写数据，init-stdout 用来接受容器的 stdout。如果使用 echo &amp;ldquo;XXX&amp;rdquo; &amp;gt; init-stdin 向容器的标准输入写入内容，则容器会接收该命令，并返回执行结果给 init-stdout。与此同时 cat init-stdout 的话，在宿主机就可以显示容器内在标准输出的内容。&lt;/p>
&lt;p>docker exec 命令就是通过这两个文件，来让宿主机与容器进行交互，效果如下：
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/xgxt2w/1616121764249-a0867491-440e-4f2d-a52d-186aceee3136.png" alt="">&lt;/p>
&lt;h2 id="正常启动容器">正常启动容器&lt;/h2>
&lt;p>容器正常启动后，会在 /run/docker/runtime-runc/moby/* 目录中创建该容器的状态文件 state.json 。该文件包含当前容器详细的配置及状态信息。其中也包括 bundle 路径等等。&lt;/p>
&lt;pre>&lt;code>[root@lichenhao moby]# pwd
/run/docker/runtime-runc/moby
[root@lichenhao moby]# tree
.
└── 28f5bed704dc80bed6dbaa8af514d2191d8d4ab0339bb3a663e66609ccd34c10
└── state.json
[root@lichenhao moby]# cat 28f5bed704dc80bed6dbaa8af514d2191d8d4ab0339bb3a663e66609ccd34c10/state.json | jq .
{
&amp;quot;id&amp;quot;: &amp;quot;28f5bed704dc80bed6dbaa8af514d2191d8d4ab0339bb3a663e66609ccd34c10&amp;quot;,
&amp;quot;init_process_pid&amp;quot;: 32221,
&amp;quot;init_process_start&amp;quot;: 355109292,
&amp;quot;created&amp;quot;: &amp;quot;2020-06-24T04:03:19.300399652Z&amp;quot;,
&amp;quot;config&amp;quot;: {
&amp;quot;no_pivot_root&amp;quot;: false,
&amp;quot;parent_death_signal&amp;quot;: 0,
&amp;quot;rootfs&amp;quot;: &amp;quot;/var/lib/docker/overlay2/d976eddf7575a3464486d92539229146f3df66080a3265195791ebb0d24b24dd/merged&amp;quot;,
&amp;quot;readonlyfs&amp;quot;: false,
&amp;quot;rootPropagation&amp;quot;: 0,
&amp;quot;mounts&amp;quot;: [
{
.......
},
.....
&amp;quot;bundle=/run/containerd/io.containerd.runtime.v1.linux/moby/28f5bed704dc80bed6dbaa8af514d2191d8d4ab0339bb3a663e66609ccd34c10&amp;quot;
......
}
&lt;/code>&lt;/pre></description></item><item><title>Docs: Docker 部署</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/10.%E4%BA%91%E5%8E%9F%E7%94%9F/2.2.%E5%AE%9E%E7%8E%B0%E5%AE%B9%E5%99%A8%E7%9A%84%E5%B7%A5%E5%85%B7/docker/docker-%E9%83%A8%E7%BD%B2/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/10.%E4%BA%91%E5%8E%9F%E7%94%9F/2.2.%E5%AE%9E%E7%8E%B0%E5%AE%B9%E5%99%A8%E7%9A%84%E5%B7%A5%E5%85%B7/docker/docker-%E9%83%A8%E7%BD%B2/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;a href="https://docs.docker.com/engine/install/">官方文档&lt;/a>、&lt;a href="https://docs.docker.com/engine/install/centos/">Centos 安装&lt;/a>、&lt;a href="https://docs.docker.com/engine/install/ubuntu/#install-using-the-repository">Ubuntu 安装&lt;/a>&lt;/p>
&lt;/blockquote>
&lt;h1 id="安装-docker-套件">安装 Docker 套件&lt;/h1>
&lt;h2 id="方法-1使用-linux-的包管理器安装">方法 1：使用 Linux 的包管理器安装&lt;/h2>
&lt;h3 id="使用包管理器安装">使用包管理器安装&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># centos&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>yum install -y yum-utils device-mapper-persistent-data lvm2
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>yum-config-manager --add-repo http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>yum install -y docker-ce
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># ubuntu&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>sudo apt-get -y install apt-transport-https ca-certificates curl gnupg-agent software-properties-common
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>curl -fsSL https://repo.huaweicloud.com/docker-ce/linux/ubuntu/gpg | sudo apt-key add -
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>sudo add-apt-repository &lt;span style="color:#e6db74">&amp;#34;deb [arch=amd64] https://repo.huaweicloud.com/docker-ce/linux/ubuntu &lt;/span>&lt;span style="color:#66d9ef">$(&lt;/span>lsb_release -cs&lt;span style="color:#66d9ef">)&lt;/span>&lt;span style="color:#e6db74"> stable&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>sudo apt-get -y update
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>sudo apt-get -y install docker-ce
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;blockquote>
&lt;p>若 centos8 提示无法安装 contained.io ,则执行如下指令安装
yum install -y &lt;a href="https://mirrors.aliyun.com/docker-ce/linux/centos/7/x86_64/edge/Packages/containerd.io-1.2.13-3.2.el7.x86_64.rpm">https://mirrors.aliyun.com/docker-ce/linux/centos/7/x86_64/edge/Packages/containerd.io-1.2.13-3.2.el7.x86_64.rpm&lt;/a>&lt;/p>
&lt;/blockquote>
&lt;h3 id="配置-unit-文件">配置 Unit 文件&lt;/h3>
&lt;p>docker 自 1.13 版起会自动设置 iptables 的 FORWARD 默认策略为 DROP，这可能会影响 Kubernetes 集群依赖的报文转发功能，因此，需要在 docker 服务启动后，重新将 FORWARD 链的默认策略设备为 ACCEPT&lt;/p>
&lt;ul>
&lt;li>sed -i &amp;ldquo;14i ExecStartPost=/usr/sbin/iptables -P FORWARD ACCEPT&amp;rdquo; /usr/lib/systemd/system/docker.service&lt;/li>
&lt;/ul>
&lt;h2 id="方法-2直接安装二进制文件">方法 2：直接安装二进制文件&lt;/h2>
&lt;p>以 20.10.6 版本为例&lt;/p>
&lt;h3 id="获取并部署二进制文件">获取并部署二进制文件&lt;/h3>
&lt;p>在 &lt;a href="https://download.docker.com/linux/static/stable/x86_64/">https://download.docker.com/linux/static/stable/x86_64/&lt;/a> 页面下载 &lt;a href="https://download.docker.com/linux/static/stable/x86_64/docker-20.10.6.tgz">20.10.6&lt;/a> 版本的二进制程序
解压并将二进制程序放到 $PATH 中&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>tar -zxvf docker-20.10.6.tgz
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>cp docker/* /usr/bin/
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="配置-unit-文件-1">配置 Unit 文件&lt;/h3>
&lt;h4 id="containerdservice">containerd.service&lt;/h4>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>cat &amp;gt; /usr/lib/systemd/system/containerd.service &lt;span style="color:#e6db74">&amp;lt;&amp;lt; EOF
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">[Unit]
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">Description=containerd container runtime
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">Documentation=https://containerd.io
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">After=network.target local-fs.target
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">[Service]
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">ExecStartPre=-/sbin/modprobe overlay
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">ExecStart=/usr/bin/containerd
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">Type=notify
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">Delegate=yes
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">KillMode=process
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">Restart=always
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">RestartSec=5
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74"># Having non-zero Limit*s causes performance problems due to accounting overhead
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74"># in the kernel. We recommend using cgroups to do container-local accounting.
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">LimitNPROC=infinity
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">LimitCORE=infinity
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">LimitNOFILE=1048576
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74"># Comment TasksMax if your systemd version does not supports it.
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74"># Only systemd 226 and above support this version.
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">TasksMax=infinity
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">OOMScoreAdjust=-999
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">[Install]
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">WantedBy=multi-user.target
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">EOF&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h4 id="dockerservice">docker.service&lt;/h4>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>cat &amp;gt; /usr/lib/systemd/system/docker.service &lt;span style="color:#e6db74">&amp;lt;&amp;lt;EOF
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">[Unit]
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">Description=Docker Application Container Engine
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">Documentation=https://docs.docker.com
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">After=network-online.target firewalld.service containerd.service
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">Wants=network-online.target
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">Requires=containerd.service
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">[Service]
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">Type=notify
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74"># the default is not to use systemd for cgroups because the delegate issues still
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74"># exists and systemd currently does not support the cgroup feature set required
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74"># for containers run by docker
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">ExecStartPost=/usr/sbin/iptables -P FORWARD ACCEPT
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">ExecStart=/usr/bin/dockerd --containerd=/run/containerd/containerd.sock
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">ExecReload=/bin/kill -s HUP $MAINPID
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">TimeoutSec=0
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">RestartSec=2
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">Restart=always
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74"># Note that StartLimit* options were moved from &amp;#34;Service&amp;#34; to &amp;#34;Unit&amp;#34; in systemd 229.
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74"># Both the old, and new location are accepted by systemd 229 and up, so using the old location
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74"># to make them work for either version of systemd.
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">StartLimitBurst=3
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74"># Note that StartLimitInterval was renamed to StartLimitIntervalSec in systemd 230.
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74"># Both the old, and new name are accepted by systemd 230 and up, so using the old name to make
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74"># this option work for either version of systemd.
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">StartLimitInterval=60s
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74"># Having non-zero Limit*s causes performance problems due to accounting overhead
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74"># in the kernel. We recommend using cgroups to do container-local accounting.
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">LimitNOFILE=infinity
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">LimitNPROC=infinity
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">LimitCORE=infinity
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74"># Comment TasksMax if your systemd version does not support it.
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74"># Only systemd 226 and above support this option.
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">TasksMax=infinity
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74"># set delegate yes so that systemd does not reset the cgroups of docker containers
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">Delegate=yes
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74"># kill only the docker process, not all processes in the cgroup
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">KillMode=process
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">OOMScoreAdjust=-500
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">[Install]
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">WantedBy=multi-user.target
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">EOF&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h1 id="配置并启动-docker">配置并启动 Docker&lt;/h1>
&lt;h2 id="添加-dockerd-配置文件">添加 dockerd 配置文件&lt;/h2>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>sudo mkdir -p /etc/docker
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>sudo cat &amp;gt; /etc/docker/daemon.json &lt;span style="color:#e6db74">&amp;lt;&amp;lt;EOF
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">{
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74"> &amp;#34;registry-mirrors&amp;#34;: [&amp;#34;https://ac1rmo5p.mirror.aliyuncs.com&amp;#34;],
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74"> &amp;#34;exec-opts&amp;#34;: [&amp;#34;native.cgroupdriver=systemd&amp;#34;],
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74"> &amp;#34;live-restore&amp;#34;: true,
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74"> &amp;#34;log-driver&amp;#34;: &amp;#34;json-file&amp;#34;,
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74"> &amp;#34;log-opts&amp;#34;: {
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74"> &amp;#34;max-size&amp;#34;: &amp;#34;5m&amp;#34;,
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74"> &amp;#34;max-file&amp;#34;: &amp;#34;5&amp;#34;
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74"> },
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74"> &amp;#34;storage-driver&amp;#34;: &amp;#34;overlay2&amp;#34;,
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74"> &amp;#34;storage-opts&amp;#34;: [
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74"> &amp;#34;overlay2.override_kernel_check=true&amp;#34;
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74"> ]
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">}
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">EOF&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="修改内核参数">修改内核参数&lt;/h2>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>cat &amp;gt; /etc/sysctl.d/docker.conf &lt;span style="color:#e6db74">&amp;lt;&amp;lt; EOF
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">net.ipv4.ip_forward = 1
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">EOF&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>sysctl -p /etc/sysctl.d/*
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="启动-docker">启动 docker&lt;/h2>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>systemctl daemon-reload
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>systemctl enable docker --now
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div></description></item><item><title>Docs: Docker 存储</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/10.%E4%BA%91%E5%8E%9F%E7%94%9F/2.2.%E5%AE%9E%E7%8E%B0%E5%AE%B9%E5%99%A8%E7%9A%84%E5%B7%A5%E5%85%B7/docker/docker-%E5%AD%98%E5%82%A8/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/10.%E4%BA%91%E5%8E%9F%E7%94%9F/2.2.%E5%AE%9E%E7%8E%B0%E5%AE%B9%E5%99%A8%E7%9A%84%E5%B7%A5%E5%85%B7/docker/docker-%E5%AD%98%E5%82%A8/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://docs.docker.com/storage/">官方文档，在生产环境运行你的应用-管理应用数据-存储概述&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>当关闭并重启 Container 的时候，其内的数据不受影响；但删除 Docker 容器后，则其内对最上面的可写层操作的内容则全部丢失，这时候会存在几个问题&lt;/p>
&lt;ul>
&lt;li>存储于联合文件系统中，不易于宿主机访问&lt;/li>
&lt;li>容器间数据共享不便&lt;/li>
&lt;li>删除容器会使数据丢失&lt;/li>
&lt;/ul>
&lt;p>为了解决这些问题，可以通过三种 Storage 方式来将文件存储于宿主机中&lt;/p>
&lt;ul>
&lt;li>&lt;strong>volume&lt;/strong>
&lt;ul>
&lt;li>volume 类型的 storage 是通过 docker volume 命令显式得创建一个抽象的内容，创建完一个 volume 会，会在 /var/lib/docker/volumes/* 目录下生成与 volume 同名的目录，在将 volume 挂载进 Container 中时，也就是将 /var/lib/docker/volmes/XXX 目录挂载进去。非 Docker 进程不应修改文件系统的这一部分。卷是在 Docker 中持久保存数据的最佳方法。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>bind mounts&lt;/strong>
&lt;ul>
&lt;li>可以存储在主机系统上的任何位置。它们甚至可能是重要的系统文件或目录。Docker 主机或 Docker 容器上的非 Docker 进程可以随时对其进行修改。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>tmpfs mount&lt;/strong>
&lt;ul>
&lt;li>仅存储在主机系统的内存中，并且永远不会写入主机系统的文件系统中。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>无论使用哪种方式，目的都是让宿主机上的某个“目录或者文件”绕过联合文件系统，与 Container 中的一个或多个“目录或文件”绑定，对目录中的操作，在 Container 和 Host 中都能看到(i.e.在宿主机目录中创建一个文件，Container 中对应的目录也会看到这个文件)，一个 Volume 可以绑定到多个 Container 上去。&lt;/p>
&lt;p>这三种方式唯一的差异就是数据在 docker 宿主机上的位置，bind mount 和 volume 会在宿主机的文件系统中、而 tmpfs mount 则在宿主机的内存中。如下图所示：
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/tg0ypk/1616121977852-96ae1080-9144-4e1d-9e6a-1f06b7f5a73c.png" alt="">
Note：merged(可读写层) 的目录内无法看到这三种存储方式关联到容器中的任何数据，只能从这些存储类型的源目录看到。&lt;/p>
&lt;p>数据卷挂载之后的可见性&lt;/p>
&lt;h2 id="volume">Volume&lt;/h2>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://docs.docker.com/storage/volumes/">官方文档，在生产环境运行你的应用-管理应用数据-卷&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>卷是一个逻辑概念，需要手动创建出来之后才能使用，创建出来的卷会关联到一个目录上，对卷的操作就是对该目录的操作，创建出来的卷数据保存在 /var/lib/docker/volumes/* 路径下，其内目录目录名为卷的名字。&lt;/p>
&lt;p>我们可以通过 docker volume 子命令创建卷&lt;/p>
&lt;h3 id="syntax语法">Syntax(语法)&lt;/h3>
&lt;p>&lt;strong>docker volume COMMAND [OPTIONS]&lt;/strong>
COMMAND：&lt;/p>
&lt;ul>
&lt;li>create # 创建一个 volume,若不指定 VolumeName，则会自动生成一串一堆字符为名的 volume name&lt;/li>
&lt;li>inspect # 显示一个或多个卷的详细信息&lt;/li>
&lt;li>ls # 列出所有 volume&lt;/li>
&lt;li>prune # 删除所有未使用的 volumes&lt;/li>
&lt;li>rm # 删除一个或多个 volumes&lt;/li>
&lt;/ul>
&lt;h3 id="inspect">inspect&lt;/h3>
&lt;p>&lt;strong>docker volume inspect [OPTIONS] [VoumeName]&lt;/strong>
显示的信息示例如下：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-json" data-lang="json">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#960050;background-color:#1e0010">~]#&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">docker&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">volume&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">inspect&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">volume-test&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>[
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;CreatedAt&amp;#34;&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;2020-06-29T13:40:14+08:00&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;Driver&amp;#34;&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;local&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;Labels&amp;#34;&lt;/span>: {},
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#960050;background-color:#1e0010">#&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">卷的挂载点。也就是在容器引用该卷时，所能使用的目录&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;Mountpoint&amp;#34;&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;/var/lib/docker/volumes/volume-test/_data&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;Name&amp;#34;&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;volume-test&amp;#34;&lt;/span>, &lt;span style="color:#960050;background-color:#1e0010">#&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">卷的名称&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;Options&amp;#34;&lt;/span>: {},
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;Scope&amp;#34;&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;local&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>]
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="bind-mount">bind mount&lt;/h2>
&lt;blockquote>
&lt;p>官方文档：&lt;a href="https://docs.docker.com/storage/bind-mounts/">https://docs.docker.com/storage/bind-mounts/&lt;/a>&lt;/p>
&lt;/blockquote>
&lt;p>bind mount 可以将宿主机上任意目录或者文件，与 Container 共享&lt;/p>
&lt;p>就像这个类型的名字一样，将 docker 目录与宿主机目录绑定&lt;/p>
&lt;h2 id="tmpfs-mount">tmpfs mount&lt;/h2>
&lt;blockquote>
&lt;p>官方文档：&lt;a href="https://docs.docker.com/storage/tmpfs/">https://docs.docker.com/storage/tmpfs/&lt;/a>&lt;/p>
&lt;/blockquote>
&lt;h1 id="三种类型的-storage-应用在容器中的方法">三种类型的 Storage 应用在容器中的方法&lt;/h1>
&lt;p>使用 docker run|create 命令时，使用 -v 或者 &amp;ndash;mount ，则可以将 3 种 Storage 应用在 Container 中&lt;/p>
&lt;p>&lt;strong>docker run &amp;ndash;mount type=TYPE,src=SRC,dst=DST[,OPTIONS] &amp;hellip;&lt;/strong> # 以 IMAGE 启动运行一个容器，并将 SRC 指定的目录绑定或者挂载到容器内的 DST 目录上。Note：src 还可以写成 source，dst 还可以写成 destination、target。&lt;/p>
&lt;ul>
&lt;li>TYPE # 挂载类型。可用的有 volume、bind、tmpfs 三种&lt;/li>
&lt;li>SRC # 宿主机路径(/HOST/PATH) 或者容器卷名称(VolumeName)。
&lt;ul>
&lt;li>若不指定 SRC，则 docker 会自动创建一个。若指定路径在宿主机上不存在，则默认在 /var/lib/docker/volumes/ 路径下创建 volume 所用的目录&lt;/li>
&lt;li>挂载文件时，若指定的 SRC 不存在，则会在本机自动创建一个同名目录。&lt;/li>
&lt;li>tmpfs 不用指定 SRC&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>DST # 容器内的路径 /CONTAINER/PATH&lt;/li>
&lt;/ul>
&lt;p>OPTIONS # 以逗号分隔的选项列表，以 KEY=VALUE 的方式表示。&lt;/p>
&lt;ul>
&lt;li>ro=true | false(default) # 指定该 Stroage 是否是只读模式(默认为 false。i.e. rw(读写)模式)。Note: setting readonly for a bind mount does not make its submounts。read-only on the current Linux implementation. See also bind-nonrecursive.&lt;/li>
&lt;li>适用于 bind 类型 Storage 的选项
&lt;ul>
&lt;li>bind-propagation=shared | slave | private | rshared | rslave | rprivate(default) #&lt;/li>
&lt;li>consistency=consistent(default) | cached | delegated # 该选项目前仅对 mac 版 docker 有用。&lt;/li>
&lt;li>bind-nonrecursive=true | false(default). 如果为 true，则子挂载不会递归挂载。这个 OPT 对于只读模式很有用&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>适用于 volume 类型 Storage 的选项
&lt;ul>
&lt;li>volume-driver: Name of the volume-driver plugin.&lt;/li>
&lt;li>volume-label: Custom metadata.&lt;/li>
&lt;li>volume-nocopy=true(default) | false. If set to false, the Engine copies existing files and directories under the mount-path into the volume,allowing the host to access them.如果设置为 false，则引擎会将安装路径下的现有文件和目录复制到该卷中，使主机可以访问它们。&lt;/li>
&lt;li>volume-opt: specific to a given volume driver.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>适用于 tmpfs 类型 Storage 的选项
&lt;ul>
&lt;li>tmpfs-size=SIZE # tmpfs 类型 Storage 的大小。在 Linux 中默认是无限的。&lt;/li>
&lt;li>tmpfs-mode=MODE # tmpfs 类型 Storage 的文件模式(e.g. 700 or 0700.)。Linux 中默认为 1777&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>EXAMPLE&lt;/p>
&lt;ul>
&lt;li>type=bind,source=/path/on/host,destination=/path/in/container&lt;/li>
&lt;li>type=volume,source=my-volume,destination=/path/in/container,volume-label=&amp;ldquo;color=red&amp;rdquo;,volume-label=&amp;ldquo;shape=round&amp;rdquo;&lt;/li>
&lt;li>type=tmpfs,tmpfs-size=512M,destination=/path/in/container&lt;/li>
&lt;/ul>
&lt;p>docker run -v [SRC:]DST[:OPTS] &amp;hellip; # 原始应用 Storage 的语法，新版本推荐使用 &amp;ndash;mount 选项。&lt;/p>
&lt;p>-v 和 &amp;ndash;mount 行为之间的区别&lt;/p>
&lt;p>由于 -v 和 &amp;ndash;volume 标志已经很长时间成为 Docker 的一部分，因此它们的行为无法更改。这意味着 -v 和 &amp;ndash;mount 之间存在一种不同的行为。&lt;/p>
&lt;p>如果使用 -v 或 &amp;ndash;volume 绑定安装 Docker 主机上尚不存在的文件或目录，请 -v 为您创建端点。始终将其创建为目录。&lt;/p>
&lt;p>如果使用 &amp;ndash;mount 绑定贴装尚不泊坞窗主机上存在的文件或目录，码头工人也不会自动为您创建它，但会产生一个错误。&lt;/p>
&lt;p>Note：在使用 -v 方式应用 Storage，并且指定 SRC 为宿主机上的具体路径 ，则该 Storage 信息会记录在 /var/lib/docker/containers/ID/hostconfig.json 文件的 &lt;code>.HostConfig.Binds&lt;/code> 字段下，通过 docker inspect ID 命令查看的容器信息中，也会显示在 .HostConfig.Binds 字段下面。&lt;/p>
&lt;p>而使用 &amp;ndash;mount 方式应用的 Storage，则会将信息记录在 hostconfig.json 文件的 &lt;code>.HostConfig.Mounts&lt;/code> 下。&lt;/p>
&lt;p>挂载一个单独文件的方法&lt;/p>
&lt;p>docker run -v /HOST/PATH/FILE:/CONTAINER/PATH/FILE #这样就把 host 上的 FILE 挂载到 container 指定路径下的 FILE 上去了。FILE 可以不同名&lt;/p>
&lt;h1 id="修改-docker--v-挂载的文件时遇到的问题">修改 docker -v 挂载的文件时遇到的问题&lt;/h1>
&lt;p>在启动 docker 容器时，为了保证一些基础配置与宿主机保持同步，通常需要将这些配置文件挂载进 docker 容器，例如/etc/resolv.conf、/etc/hosts、/etc/localtime 等文件。&lt;/p>
&lt;p>当这些配置变化时，我们通常会修改这些文件。但是此时遇到了一个问题：&lt;/p>
&lt;ul>
&lt;li>当在宿主机上修改这些文件后，docker 容器内查看时，这些文件并未发生对应的修改。&lt;/li>
&lt;/ul>
&lt;p>然后通过查阅相关资料，发现该问题是由 docker -v 挂载文件和某些编辑器存储文件的行为共同导致 的。&lt;/p>
&lt;ul>
&lt;li>docker 挂载文件时，并不是挂载了某个文件的路径，而是实打实的挂载了对应的文件，即挂载了某 个指定的 inode 文件。&lt;/li>
&lt;li>某些编辑器(vi)在编辑保存文件时，采用了备份、替换的策略，即编辑过程中，将变更写入新文件， 保存时，再将备份文件替换原文件，此时会导致文件的 inode 发生变化。&lt;/li>
&lt;li>原 inode 对应的文件其实并没有发生修改。&lt;/li>
&lt;/ul>
&lt;p>因此，我们从宿主机上修改这些文件时，应该采用 echo 重定向等操作，避免文件的 inode 发生变化。&lt;/p></description></item><item><title>Docs: Docker 介绍</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/10.%E4%BA%91%E5%8E%9F%E7%94%9F/2.2.%E5%AE%9E%E7%8E%B0%E5%AE%B9%E5%99%A8%E7%9A%84%E5%B7%A5%E5%85%B7/docker/docker-%E4%BB%8B%E7%BB%8D/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/10.%E4%BA%91%E5%8E%9F%E7%94%9F/2.2.%E5%AE%9E%E7%8E%B0%E5%AE%B9%E5%99%A8%E7%9A%84%E5%B7%A5%E5%85%B7/docker/docker-%E4%BB%8B%E7%BB%8D/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://docs.docker.com/get-started/overview/">官方文档&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>Docker 是一个基于容器技术的开放式平台，可以 开发、分享、运行应用程序。Docker 分为两个版本&lt;/p>
&lt;ul>
&lt;li>Docker-CE # 社区版&lt;/li>
&lt;li>Docker-EE # 商业版&lt;/li>
&lt;/ul>
&lt;p>Docker 为了解决 LXC 无法批量管理、复刻容器等问题应运而生，简化用户对容器的应用。Docker 是 Docker.inc 公司开源的一个基于 LXC 技术之上构建的 Container 容器引擎，不再使用模板技术，而是使用了 image 文件的方式来创建。image 是放在统一的互联网仓库中，当需要使用 Container 的时候，直接 run 或者 creat 等即可从仓库中下载到该 image，然后基于该 image 再运行 Container。&lt;/p>
&lt;p>Note：一开始，docker 在 linux 上实现容器技术的后端使用的是 lxc，后来使用 runc 来代替。&lt;/p>
&lt;h1 id="docker-的工作模式">Docker 的工作模式&lt;/h1>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/qqh0gm/1616122015472-3e6bcce1-e878-485c-859b-057a2eaf98c6.png" alt="">
Docker 对使用者来讲是一个 C/S 模式的架构，而 Docker 的后端是一个非常松耦合的架构，模块各司其职，并有机组合，支撑 Docker 的运行。&lt;/p>
&lt;p>用户是使用 Docker Client 与 Docker Daemon 建立通信，并发送请求给后者。&lt;/p>
&lt;p>而 Docker Daemon 作为 Docker 架构中的主体部分，首先提供 Server 的功能使其可以接受 Docker Client 的请求；而后 Engine 执行 Docker 内部的一系列工作，每一项工作都是以一个 Job 的形式的存在。
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/qqh0gm/1616122015445-eda7a719-b2a0-4fd6-8c61-b8d450d2dc3d.png" alt="">
当利用 docker run 来创建容器时，Docker 在后台运行的标准操作包括：&lt;/p>
&lt;ol>
&lt;li>检查本地是否存在指定的镜像，不存在就从公有仓库下载&lt;/li>
&lt;li>利用镜像创建并启动一个容器&lt;/li>
&lt;li>分配一个文件系统，并在只读的镜像层外面挂在一层可读写层&lt;/li>
&lt;li>从宿主主机配置的网桥接口中桥接一个虚拟接口到容器中去&lt;/li>
&lt;li>从地址池配置一个 ip 地址给容器&lt;/li>
&lt;li>执行用户指定的应用程序&lt;/li>
&lt;li>执行完毕后 Container 被终止&lt;/li>
&lt;li>docker 容器默认会把容器内部第一个进程，也就是 pid=1 的程序作为 docker 容器是否正在运行的依据，如果 docker 容器 pid 挂了，那么 docker 容器便会直接退出。&lt;/li>
&lt;li>如果不想让 Container 运行完程序就终止，那么需要让 PID 为 1 的程序始终运行，比如 nginx 使用 daemon off 选项，或者其余任何可以让程序运行在前台的方法&lt;/li>
&lt;/ol>
&lt;h1 id="docker-关联文件">Docker 关联文件&lt;/h1>
&lt;p>Note：目录名中的 overlay2 指的是 docker 当前 Storage Driver 类型，使用不同的存储驱动，则目录名字也不同，如果我使用 aufs 驱动，那么目录名就会变为 aufs
由于 Docker 为 C/S 架构，所以 客户端与服务端分别有各自的配置&lt;/p>
&lt;ul>
&lt;li>客户端就是 docker 程序，也可以称为 docker-cli、docker 命令行工具&lt;/li>
&lt;li>服务端就是 dockerd 程序&lt;/li>
&lt;/ul>
&lt;h2 id="dockerd-程序关联文件">dockerd 程序关联文件&lt;/h2>
&lt;p>&lt;strong>/etc/docker/daemon.json&lt;/strong> # dockerd 服务运行时配置文件。该目录与文件需要自行创建，默认不存在，以 JSON 格式为守护程序设置任何配置选项。
&lt;strong>/run/docker/*&lt;/strong> # container 的状态文件(state.json)、IO 文件 、netns 文件保存路径。&lt;/p>
&lt;ul>
&lt;li>&lt;strong>containerd/*&lt;/strong> # container 的 IO 文件(init-stdin、init-stdout)保存路径。其内目录名为 &lt;strong>ContainerID&lt;/strong>。&lt;/li>
&lt;li>&lt;strong>netns/*&lt;/strong> # 网络名称空间保存路径。&lt;/li>
&lt;li>&lt;strong>runtime-runc/moby/*&lt;/strong> # container 的运行时状态文件保存路径。其内目录名为 &lt;strong>ContainerID&lt;/strong>。&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>/run/containerd/*&lt;/strong> # container 的 bundle 以及 containerd.sock 文件保存路径&lt;/p>
&lt;ul>
&lt;li>&lt;strong>io.containerd.runtime.v1.linux/moby/*&lt;/strong> # 容器启动后生成的 bundle 文件保存路径，其内目录名为 &lt;strong>ContainerID&lt;/strong>。&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>/var/lib/docker/*&lt;/strong> # docker 管理的 网络、镜像、容器 等信息的保存路径。该路径为默认路径，可以通过配置修改。&lt;/p>
&lt;ul>
&lt;li>**./containers/* **# 所有 container 的元数据保存路径(其中包括容器日志文件、容器运行配置等)。其内目录名为 &lt;strong>ContainerID&lt;/strong>&lt;/li>
&lt;li>&lt;strong>./image/overlay2/*&lt;/strong> # docker images 以及 所有 layers 的元数据保存路径。
&lt;ul>
&lt;li>&lt;strong>./imagedb/*&lt;/strong> # images 的元数据保存路径
&lt;ul>
&lt;li>&lt;strong>./content/sha256/*&lt;/strong> # 所有 images 的 Image Configuration 文件保存路径。其内文件名为 &lt;strong>ImageID&lt;/strong>。&lt;/li>
&lt;li>&lt;strong>./metadata/sha256/*&lt;/strong> # 所有 images 的 创建时间、更新时间、父镜像的 Image Configuration 文件名 等信息保存路径，其内目录名为 &lt;strong>ImageID&lt;/strong>。
&lt;ul>
&lt;li>注意：好像只有自己在本地构建的镜像才会在该目录中记录。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>./layerdb&lt;/strong> # 所有 layers 的元数据保存路径。
&lt;ul>
&lt;li>&lt;strong>./mounts/*&lt;/strong> # container layers 元数据保存路径，其内目录名为 ContainerID。容器创建完后，该容器的可读写层的元数据保存在此。包括可读写层父层的 chainID、可读写层的 cacheID(目录内的 mount-id 文件内容就是 &lt;strong>cacheID&lt;/strong>)。&lt;/li>
&lt;li>&lt;strong>./sha256/*&lt;/strong> # images layers 元数据保存路径，其内目录名为 chainID。包括 layer 的 &lt;strong>cacheID&lt;/strong>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>./overlay2/*&lt;/strong> # 所有 layers 的数据保存路径，其内目录名为 cacheID。docker run 的时候，是通过该目录中镜像层来启动的。创建容器后生成的可写层，也会保存在该目录，直到容器被删除。&lt;/li>
&lt;li>&lt;strong>./volumes/*&lt;/strong> # docker 创建的 volume 信息保存在该目录，如果是自动自动创建的 volume 则名为一串随机数&lt;/li>
&lt;/ul>
&lt;h2 id="docker-程序关联文件">docker 程序关联文件&lt;/h2>
&lt;p>&lt;strong>/root/.docker/config.json&lt;/strong> # docker login 后的信息都保存在此处，用户名和密码通过 base64 格式保存在其中。&lt;/p>
&lt;h1 id="docker-日志介绍">Docker 日志介绍&lt;/h1>
&lt;p>容器日志指的是每个容器打到 stdout 和 stderr 的日志，而不是容器内部的日志文件。docker 管理所有容器打到 stdout 和 stderr 的日志，其他来源的日志不归 docker 管理。我们通过 docker logs 命令查看容器日志都是读取容器打到 stdout 和 stderr 的日志。&lt;/p>
&lt;p>基于日志驱动（loging driver）的日志管理机制&lt;/p>
&lt;p>Docker 提供了一套通用、灵活的日志管理机制，Docker 将所有容器打到 stdout 和 stderr 的日志都统一通过日志驱动重定向到某个地方。&lt;/p>
&lt;p>Docker 支持的日志驱动有很多，比如 local、json-file、syslog、journald 等等，类似插件一样，不同的日志驱动可以将日志重定向到不同的地方，这体现了 Docker 日志管理的灵活性，以热插拔的方式实现日志不同目的地的输出。&lt;/p>
&lt;p>Dokcer 默认的日志日志驱动是 json-file，该驱动将将来自容器的 stdout 和 stderr 日志都统一以 json 的形式存储到本地磁盘。日志存储路径格式为：/var/lib/docker/containers/&amp;lt;容器 id&amp;gt;/&amp;lt;容器 id&amp;gt;-json.log。所以可以看出在 json-file 日志驱动下，Docker 将所有容器日志都统一重定向到了 /var/lib/docker/containers/ 目录下，这为日志收集提供了很大的便利。&lt;/p>
&lt;p>注意：只有日志驱动为：local、json-file 或者 journald 时，docker logs 命令才能查看到容器打到 stdout/stderr 的日志。&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/qqh0gm/1616122015494-8bc7a655-2804-40b9-b3d4-0e541a93359b.png" alt="">&lt;/p>
&lt;p>下面为官方支持的日志驱动列表：
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/qqh0gm/1616122015440-06e63de1-bbb8-4d6c-9271-b37947d483ae.png" alt="">&lt;/p>
&lt;h2 id="docker-日志驱动loging-driver配置">Docker 日志驱动（loging driver）配置&lt;/h2>
&lt;p>上面我们已经知道 Docker 支持多种日志驱动类型，我们可以修改默认的日志驱动配置。日志驱动可以全局配置，也可以给特定容器配置。&lt;/p>
&lt;ul>
&lt;li>
&lt;p>查看 Docker 当前的日志驱动配置&lt;/p>
&lt;p>$ docker info |grep &amp;ldquo;Logging Driver&amp;rdquo;&lt;/p>
&lt;/li>
&lt;li>
&lt;p>查看单个容器的设置的日志驱动&lt;/p>
&lt;p>$ docker inspect -f &amp;lsquo;{{.HostConfig.LogConfig.Type}}&amp;rsquo; 容器id&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Docker 日志驱动全局配置，全局配置意味所有容器都生效，编辑 /etc/docker/daemon.json 文件（如果文件不存在新建一个），添加日志驱动配置。示例：配置 Docker 引擎日志驱动为 syslog&lt;/p>
&lt;p>{
&amp;ldquo;log-driver&amp;rdquo;: &amp;ldquo;syslog&amp;rdquo;
}&lt;/p>
&lt;/li>
&lt;li>
&lt;p>给特定容器配置日志驱动，在启动容器时指定日志驱动 &amp;ndash;log-driver 参数。示例：启动 nginx 容器，日志驱动指定为 journald&lt;/p>
&lt;p>$ docker run &amp;ndash;name nginx -d &amp;ndash;log-driver journald nginx&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h2 id="docker-默认的日志驱动-json-file">Docker 默认的日志驱动 json-file&lt;/h2>
&lt;p>json-file 日志驱动记录所有容器的 STOUT/STDERR 的输出 ，用 JSON 的格式写到文件中，每一条 json 日志中默认包含 log, stream, time 三个字段，示例日志如下：文件路径为： /var/lib/docker/containers/40f1851f5eb9e684f0b0db216ea19542529e0a2a2e7d4d8e1d69f3591a573c39/40f1851f5eb9e684f0b0db216ea19542529e0a2a2e7d4d8e1d69f3591a573c39-json.log&lt;/p>
&lt;pre>&lt;code>{&amp;quot;log&amp;quot;:&amp;quot;14:C 25 Jul 2019 12:27:04.072 * DB saved on disk\n&amp;quot;,&amp;quot;stream&amp;quot;:&amp;quot;stdout&amp;quot;,&amp;quot;time&amp;quot;:&amp;quot;2019-07-25T12:27:04.072712524Z&amp;quot;}
&lt;/code>&lt;/pre>
&lt;p>那么打到磁盘的 json 文件该如何配置轮替，防止撑满磁盘呢？每种 Docker 日志驱动都有相应的配置项日志轮转，比如根据单个文件大小和日志文件数量配置轮转。json-file 日志驱动支持的配置选项如下：&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/qqh0gm/1616122015431-a74f2c52-7a4b-443a-b6ec-d7031a967089.png" alt="">&lt;/p>
&lt;h1 id="heading">&lt;/h1></description></item><item><title>Docs: Docker 介绍</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/10.%E4%BA%91%E5%8E%9F%E7%94%9F/2.2.%E5%AE%9E%E7%8E%B0%E5%AE%B9%E5%99%A8%E7%9A%84%E5%B7%A5%E5%85%B7/docker/docker-%E4%BB%8B%E7%BB%8D/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/10.%E4%BA%91%E5%8E%9F%E7%94%9F/2.2.%E5%AE%9E%E7%8E%B0%E5%AE%B9%E5%99%A8%E7%9A%84%E5%B7%A5%E5%85%B7/docker/docker-%E4%BB%8B%E7%BB%8D/</guid><description/></item><item><title>Docs: Docker 命令行工具</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/10.%E4%BA%91%E5%8E%9F%E7%94%9F/2.2.%E5%AE%9E%E7%8E%B0%E5%AE%B9%E5%99%A8%E7%9A%84%E5%B7%A5%E5%85%B7/docker/docker-%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%B7%A5%E5%85%B7/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/10.%E4%BA%91%E5%8E%9F%E7%94%9F/2.2.%E5%AE%9E%E7%8E%B0%E5%AE%B9%E5%99%A8%E7%9A%84%E5%B7%A5%E5%85%B7/docker/docker-%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%B7%A5%E5%85%B7/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>官方文档：&lt;a href="https://docs.docker.com/engine/reference/commandline/docker/">https://docs.docker.com/engine/reference/commandline/docker/&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;h1 id="syntax语法">Syntax(语法)&lt;/h1>
&lt;p>&lt;strong>docker [OPTIONS] COMMAND [ARG&amp;hellip;]&lt;/strong>&lt;/p>
&lt;h2 id="options">OPTIONS:&lt;/h2>
&lt;ul>
&lt;li>--config=~/.docker #Location of client config files #客户端配置文件的位置&lt;/li>
&lt;li>-D, &amp;ndash;debug=false #Enable debug mode #启用 Debug 调试模式&lt;/li>
&lt;li>-H, &amp;ndash;host=[] #Daemon socket(s) to connectto #守护进程的套接字（Socket）连接&lt;/li>
&lt;li>-l, &amp;ndash;log-level=info #Set the logging level #设置日志级别&lt;/li>
&lt;li>--tls=false #Use TLS; implied by&amp;ndash;tlsverify #&lt;/li>
&lt;li>--tlscacert=~/.docker/ca.pem #Trust certs signed only by this CA #信任证书签名 CA&lt;/li>
&lt;li>--tlscert=~/.docker/cert.pem #Path to TLS certificate file #TLS 证书文件路径&lt;/li>
&lt;li>--tlskey=~/.docker/key.pem #Path to TLS key file #TLS 密钥文件路径&lt;/li>
&lt;li>--tlsverify=false #Use TLS and verify theremote #使用 TLS 验证远程&lt;/li>
&lt;/ul>
&lt;h1 id="management-commands">Management Commands&lt;/h1>
&lt;p>management command 在使用的时候，当后面还需要跟其子命令的时候，是可省的。直接使用子命令就表示对其执行，但是有的管理命令不行，比如 create，对于 container 可省，对于 network 不可省&lt;/p>
&lt;h2 id="container--容器管理">container # 容器管理&lt;/h2>
&lt;p>attach cp diff export kill ls port rename rm start stop unpause wait&lt;/p>
&lt;p>commit create exec inspect logs pause prune restart run stats top update&lt;/p>
&lt;p>对容器的操作说明：docker 的 container 相关操作命令有一些关于如何进入容器操作的命令&lt;/p>
&lt;p>其更本思想为：&lt;/p>
&lt;ol>
&lt;li>连接标准输入，输入到 host 上的内容同样输入到 container 中&lt;/li>
&lt;li>连接标准输出，输出到 container 中的同样输出到 host 上&lt;/li>
&lt;li>可以分配一个终端(shell)给 container，以便操作更便捷&lt;/li>
&lt;/ol>
&lt;p>注意：有的 Container 在启动的时候，会自带命令去执行一些操作，该操作会自动输出一些内容，当连接到该 Container 的标准输入和输出上之后，可能没法对其进行输入操作，因为该 Container 正在其前台运行某程序(就好像平时用 linux 的 tailf 命令似的)(有的程序有输出内容，有的程序没有输出内容)，前台运行程序的时候，是没法输入的。&lt;/p>
&lt;p>&lt;strong>docker container [OPTIONS]&lt;/strong>&lt;/p>
&lt;p>EXAMPLE&lt;/p>
&lt;ol>
&lt;li>docker container prune -a #清理所有已经停止的 container&lt;/li>
&lt;/ol>
&lt;h2 id="image--docker-镜像的管理命令-docker-image-命令note">image # docker 镜像的管理命令 docker image 命令.note&lt;/h2>
&lt;p>build history import inspect load ls prune pull push rm save tag&lt;/p>
&lt;p>&lt;strong>docker image [OPTIONS]&lt;/strong>
EXAMPLE&lt;/p>
&lt;ol>
&lt;li>docker image prune -a #清理所有没有使用的 image&lt;/li>
&lt;/ol>
&lt;h2 id="network--docker-网络的管理命令-docker-networkdocker-网络管理命令note">network # docker 网络的管理命令 docker network，docker 网络管理命令.note&lt;/h2>
&lt;h2 id="plugin-manage-plugins">plugin Manage plugins&lt;/h2>
&lt;h2 id="secret-manage-docker-secrets">secret Manage Docker secrets&lt;/h2>
&lt;h2 id="service-manage-services">service Manage services&lt;/h2>
&lt;h2 id="stack-manage-docker-stacks">stack Manage Docker stacks&lt;/h2>
&lt;h2 id="system--docker-系统管理">system # docker 系统管理&lt;/h2>
&lt;p>&lt;strong>docker system COMMAND&lt;/strong>&lt;/p>
&lt;p>COMMAND:&lt;/p>
&lt;ul>
&lt;li>
&lt;p>df # 显示 docker 系统的磁盘使用情况，效果如下：&lt;/p>
&lt;p>[root@master-1 ~]# docker system df
TYPE TOTAL ACTIVE SIZE RECLAIMABLE
Images 11 10 1.043GB 96.12MB (9%)
Containers 34 18 4.588kB 2.294kB (50%)
Local Volumes 2 2 152.8MB 0B (0%)
Build Cache 0 0 0B 0B&lt;/p>
&lt;/li>
&lt;li>
&lt;p>events # Get real time events from the server&lt;/p>
&lt;/li>
&lt;li>
&lt;p>info # 等同于 docker info 命令&lt;/p>
&lt;/li>
&lt;li>
&lt;p>prune # 删除未使用的数据。删除内容如下&lt;/p>
&lt;p>[root@lichenhao ~]# docker system prune
WARNING! This will remove:
- all stopped containers
- all networks not used by at least one container
- all dangling images
- all dangling build cache&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>EXAMPLE&lt;/p>
&lt;h2 id="volume--管理-docker-的卷">volume # 管理 docker 的卷&lt;/h2>
&lt;p>详见 《[Docker 存储](/docs/IT学习笔记/10.云原生/2.2.实现容器的工具/Docker/Docker%20 存储.md 存储.md)》&lt;/p>
&lt;h1 id="commands">COMMANDS&lt;/h1>
&lt;h2 id="attach--当前-shell-下-attach连接到指定运行中的镜像">attach # 当前 shell 下 attach(连接)到指定运行中的镜像&lt;/h2>
&lt;p>Attach local standard input, output, and error streams to a running container #把本地终端上的标准输入、输出和错误数据流连接到一个运行中的容器(即从一个运行中的容器剥离了其终端，再重新连接到其终端)&lt;/p>
&lt;h2 id="build--通过-dockerfile-定制镜像">build # 通过 Dockerfile 定制镜像&lt;/h2>
&lt;p>docker build [OPTIONS] PATH # 使用 dockerfile 文件自动创建镜像&lt;/p>
&lt;p>注：PATH 是 build context 创建环境的位置，从创建环境中搜索 Dockerfile 文件来使用。PATH 也可以是一个 URL，通过网上下载镜像。&lt;/p>
&lt;p>OPTIONS：&lt;/p>
&lt;ul>
&lt;li>-t &lt;!-- raw HTML omitted --> # 自己定义一个创建完成后的镜像名 NAME&lt;/li>
&lt;li>-f &lt;!-- raw HTML omitted --> # 指定使用创建环境中哪个 NAME 文件作为 Dockerfile,默认使用文件名为 Dockerfile 的文件&lt;/li>
&lt;li>--no-cache # 创建镜像时不使用缓存&lt;/li>
&lt;/ul>
&lt;p>EXAMPLE&lt;/p>
&lt;ul>
&lt;li>docker build ./ #从当前目录下查找名为 Dockerfile 的文件进行 Image 的创建&lt;/li>
&lt;li>docker build -t ubuntu-vi -f test /dockerfile/ #使用 dockerfile 目录，并使用该目录中的 test 文件作为 dockerfile 文件，创建一个名为 ubuntu-vi 的 Image&lt;/li>
&lt;/ul>
&lt;h2 id="commit--从容器的变化中创建一个新的-image提交当前容器为新的镜像">commit # 从容器的变化中创建一个新的 image。提交当前容器为新的镜像&lt;/h2>
&lt;p>docker commit [OPTIONS] CONTAINER [REPOSITORY[:TAG]]&lt;/p>
&lt;p>使用 docker commit ContainerName NewName 命令创建新镜像&lt;/p>
&lt;p>(ContainerName 为正在运行的容器名 NewName 为需要创建的镜像名，自己定)&lt;/p>
&lt;p>每一次 commit 就相当于把当前的可写入层变成 image 的一层&lt;/p>
&lt;h2 id="cp--copy-filesfolders-from-a-container-to-a-hostdir-or-to-stdout-从容器中拷贝指定文件或者目录到宿主机中">cp # Copy files/folders from a container to a HOSTDIR or to STDOUT #从容器中拷贝指定文件或者目录到宿主机中&lt;/h2>
&lt;h2 id="create--create-a-new-container-创建一个新的容器同-run-但不启动容器">create # Create a new container #创建一个新的容器，同 run 但不启动容器&lt;/h2>
&lt;h2 id="diff--inspect-changes-on-a-containers-filesystem-查看-docker-容器变化">diff # Inspect changes on a container&amp;rsquo;s filesystem #查看 docker 容器变化&lt;/h2>
&lt;h2 id="events--get-real-time-events-from-the-server-从-docker-服务获取容器实时事件">events # Get real time events from the server #从 docker 服务获取容器实时事件&lt;/h2>
&lt;h2 id="exec--run-a-command-in-a-running-container-在运行中的容器上执行命令">exec # Run a command in a running container #在运行中的容器上执行命令&lt;/h2>
&lt;h2 id="export--export-a-containers-filesystem-as-a-tar-archive-导出容器的内容流作为一个-tar-归档文件对应-import">export # Export a container&amp;rsquo;s filesystem as a tar archive #导出容器的内容流作为一个 tar 归档文件(对应 import)&lt;/h2>
&lt;h2 id="history--展示一个镜像形成历史">history # 展示一个镜像形成历史&lt;/h2>
&lt;p>docker history [OPTIONS] IMAGE&lt;/p>
&lt;p>OPTIONS&lt;/p>
&lt;ol>
&lt;li>--no-trunc #不要截断输出 i.e.每列显示的内容都是完整内容，不会被截断&lt;/li>
&lt;/ol>
&lt;p>EXAMPLE&lt;/p>
&lt;h2 id="images--列出系统当前镜像">images # 列出系统当前镜像&lt;/h2>
&lt;p>OPTIONS&lt;/p>
&lt;ul>
&lt;li>--all , -a # Show all images (default hides intermediate images)&lt;/li>
&lt;li>--digests #Show digests&lt;/li>
&lt;li>--filter , -f # Filter output based on conditions provided&lt;/li>
&lt;li>--format # Pretty-print images using a Go template
&lt;ul>
&lt;li>可用的 Go 模板占位符详见：&lt;a href="https://docs.docker.com/engine/reference/commandline/images/#format-the-output">https://docs.docker.com/engine/reference/commandline/images/#format-the-output&lt;/a>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>--no-trunc # Don’t truncate output&lt;/li>
&lt;li>--quiet , -q # Only show numeric IDs&lt;/li>
&lt;/ul>
&lt;p>EXAMPLE&lt;/p>
&lt;ul>
&lt;li>docker images #查看本地 images，效果如图&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/urb4r9/1616121613241-36e0f6eb-bee7-4db6-a9ed-d02ca5cd679d.png" alt="">&lt;/p>
&lt;h2 id="import--import-the-contents-from-a-tarball-to-create-a-filesystem-image-从-tar-包中的内容创建一个新的文件系统映像对应-export">import # Import the contents from a tarball to create a filesystem image #从 tar 包中的内容创建一个新的文件系统映像(对应 export)&lt;/h2>
&lt;h2 id="info--与-docker-system-info-命令效果相同">info # 与 docker system info 命令效果相同&lt;/h2>
&lt;h2 id="inspect--返回有关容器或镜像的底层信息">inspect # 返回有关容器或镜像的底层信息&lt;/h2>
&lt;p>显示 docker 所能管理的所有 object 的详细信息，object 包括 image，container，network 等等
&lt;strong>docker [OBJECT] inspect [OPTIONS]&lt;/strong>&lt;/p>
&lt;p>OPTIONS&lt;/p>
&lt;p>EXAMPLE&lt;/p>
&lt;ul>
&lt;li>获取 snmp_exporter 容器 merged 目录的绝对路径
&lt;ul>
&lt;li>&lt;strong>docker inspect snmp_exporter | jq .[0].GraphDriver.Data.MergedDir | tr -d &amp;ldquo;&amp;rdquo;&amp;quot;&lt;/strong>&lt;/li>
&lt;li>&lt;strong>docker inspect snmp_exporter &amp;ndash;format=&amp;rsquo;{{.GraphDriver.Data.MergedDir}}&amp;rsquo;&lt;/strong>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h2 id="kill-kill-一个运行中的容器">kill #kill 一个运行中的容器&lt;/h2>
&lt;h2 id="load-从-tar-包-或标准输入中加载一个镜像对应-save">load #从 tar 包 或标准输入中加载一个镜像(对应 save)&lt;/h2>
&lt;p>&lt;strong>docker load [OPTIONS]FILE&lt;/strong>&lt;/p>
&lt;p>OPTIONS&lt;/p>
&lt;ul>
&lt;li>-i #从 tar 存档文件读取，而不是 STDIN&lt;/li>
&lt;/ul>
&lt;p>EXAMPLE&lt;/p>
&lt;ul>
&lt;li>docker load -i kubernetes.tar&lt;/li>
&lt;/ul>
&lt;h2 id="login--注册或者登录到一个-docker-registry">login # 注册或者登录到一个 Docker Registry&lt;/h2>
&lt;h2 id="logout--从当前-docker-registry-登出">logout # 从当前 Docker Registry 登出&lt;/h2>
&lt;h2 id="logs--获取容器得日志">logs # 获取容器得日志&lt;/h2>
&lt;p>&lt;strong>docker logs [OPTIONS] CONTAINER&lt;/strong>
OPTIONS&lt;/p>
&lt;ul>
&lt;li>--details # Show extra details provided to logs&lt;/li>
&lt;li>**-f, &amp;ndash;follow **# 跟踪日志的输出&lt;/li>
&lt;li>--since string Show logs since timestamp (e.g. 2013-01-02T13:23:37Z) or relative (e.g. 42m for 42 minutes)&lt;/li>
&lt;li>**-n, &amp;ndash;tail STRING **# 从日志末尾开始显示日志的指定行数。&lt;code>默认值：all&lt;/code>&lt;/li>
&lt;li>&lt;strong>-t, &amp;ndash;timestamps&lt;/strong> # 在每行日志行首显示时间戳&lt;/li>
&lt;li>--until string # Show logs before a timestamp (e.g. 2013-01-02T13:23:37Z) or relative (e.g. 42m for 42 minutes)&lt;/li>
&lt;/ul>
&lt;h2 id="pause--pause-all-processes-within-a-container-暂停一个-container-中的所有进程">pause # Pause all processes within a container #暂停一个 Container 中的所有进程&lt;/h2>
&lt;h2 id="port--list-port-mappings-or-a-specific-mapping-for-the-container-查看映射端口对应的容器内部源端口">port # List port mappings or a specific mapping for the CONTAINER #查看映射端口对应的容器内部源端口&lt;/h2>
&lt;p>docker port CONTAINER [PRIVATE_PORT[/PROTO]]&lt;/p>
&lt;p>EXAMPLE&lt;/p>
&lt;ol>
&lt;li>docker port nginx1 #查看名为 nginx1 这个 Container 的端口映射情况&lt;/li>
&lt;/ol>
&lt;h2 id="ps--list-containers-列出容器">ps # List containers #列出容器。&lt;/h2>
&lt;p>详见：docker ps 命令，可以查看很多容器信息&lt;/p>
&lt;h2 id="pull--从-registry-拉取指定镜像或者镜像仓库">pull # 从 Registry 拉取指定镜像或者镜像仓库&lt;/h2>
&lt;p>&lt;strong>docker pull [REGISTRY][:Port]/[NAMESPACE/]&lt;!-- raw HTML omitted -->:[TAG]&lt;/strong>
如果不加 registry，则默认从 hub.docker.com 拉取 image；如果不设置 namespace，则默认从指定的 registry 中的顶层仓库拉取镜像，如果使用了 namespace，则从该用户仓库拉取镜像；如果不指定 TAG，则默认拉取 lastest 版的 image&lt;/p>
&lt;p>EXAMPLE&lt;/p>
&lt;ul>
&lt;li>docker pull quay.io/coreos/flannel&lt;/li>
&lt;/ul>
&lt;h2 id="push-推送指定镜像或者库镜像至-docker-源服务器">push #推送指定镜像或者库镜像至 docker 源服务器&lt;/h2>
&lt;h2 id="rename-重命名容器">rename #重命名容器&lt;/h2>
&lt;h2 id="restart--重启运行的容器">restart # 重启运行的容器&lt;/h2>
&lt;h2 id="rm--移除一个或者多个容器">rm # 移除一个或者多个容器&lt;/h2>
&lt;ol>
&lt;li>EXAMPLE&lt;/li>
&lt;li>docker rm &lt;code>docker ps -a | grep &amp;quot;Exited&amp;quot; | awk '{print $NF}'&lt;/code> #移除所以已经停止的容器&lt;/li>
&lt;/ol>
&lt;h2 id="rmi--移除一个或多个镜像无容器使用该镜像才可以删除否则需要删除相关容器才可以继续或者-f-强制删除">rmi # 移除一个或多个镜像(无容器使用该镜像才可以删除，否则需要删除相关容器才可以继续或者-f 强制删除)&lt;/h2>
&lt;h2 id="run--创建一个新的容器并运行一个命令">run # 创建一个新的容器并运行一个命令&lt;/h2>
&lt;p>docker run [OPTIONS] IMAGE [COMMAND] [ARG&amp;hellip;]&lt;/p>
&lt;p>具体用法见笔记：[docker run 运行容器](/docs/IT学习笔记/10.云原生/2.2.实现容器的工具/Docker/Docker%20 命令行工具/run%20 运行容器.md 命令行工具/run 运行容器.md)&lt;/p>
&lt;h2 id="save--保存一个或多个镜像为一个-tar-包对应-load">save # 保存一个或多个镜像为一个 tar 包(对应 load)&lt;/h2>
&lt;p>docker save [OPTIONS] Image1 Image2 &amp;hellip; ImageN /PATH/FILE&lt;/p>
&lt;p>OPTIONS&lt;/p>
&lt;ul>
&lt;li>-o #save 的时候写入文件，而不是 STDOUT&lt;/li>
&lt;/ul>
&lt;p>EXAMPLE&lt;/p>
&lt;ul>
&lt;li>docker save k8s.gcr.io/kube-proxy:v1.12.1 -o kubernetes.tar #保存 k8s.gcr.io/kube-proxy:v1.12.1 这个 image 到 kubernetes.tar 这个文件中&lt;/li>
&lt;li>docker save -o XXXX.tar $(docker images | awk &amp;lsquo;{print $1,$2}&amp;rsquo; OFS=&amp;quot;:&amp;quot; | awk &amp;lsquo;NR!=1{print}&amp;rsquo;) #保存全部镜像到 XXX.tar 文件中&lt;/li>
&lt;/ul>
&lt;h2 id="search-search-the-docker-hub-for-images--在-dockerhub-中搜索镜像">search Search the Docker Hub for images # 在 dockerhub 中搜索镜像&lt;/h2>
&lt;p>docker search [OPTIONS] TERM&lt;/p>
&lt;p>EXAMPLE&lt;/p>
&lt;ol>
&lt;li>docker search centos #搜索所有 centos 的 docker 镜像&lt;/li>
&lt;/ol>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/urb4r9/1616121613281-5ce787a3-8986-43c9-926a-680de555c36e.png" alt="">&lt;/p>
&lt;h2 id="start-start-one-or-more-stopped-containers--启动容器">start Start one or more stopped containers # 启动容器&lt;/h2>
&lt;h2 id="stats--显示实时的容器资源使用情况统计流">stats # 显示实时的容器资源使用情况统计流&lt;/h2>
&lt;p>命令用法详见：容器状态查看命令&lt;/p>
&lt;h2 id="stop-停止容器">stop #停止容器&lt;/h2>
&lt;h2 id="tag-在一个-repostiory-中标记一个-image">tag #在一个 repostiory 中标记一个 image&lt;/h2>
&lt;p>docker tag SOURCE_IMAGE[:TAG] TARGET_IMAGE[:TAG]&lt;/p>
&lt;h2 id="top-查看容器中运行的进程信息">top #查看容器中运行的进程信息&lt;/h2>
&lt;p>EXAMPLE&lt;/p>
&lt;ol>
&lt;li>docker top prometheus #查看 prometheus 这个 container 运行的程序，该信息的格式为 ps 命令所输出的内容&lt;/li>
&lt;/ol>
&lt;h2 id="unpause-unpause-all-processes-within-a-container-取消暂停容器">unpause Unpause all processes within a container #取消暂停容器&lt;/h2>
&lt;h2 id="version-show-the-docker-version-information-展示-docker-版本信息">version Show the Docker version information #展示 Docker 版本信息&lt;/h2>
&lt;h2 id="wait-block-until-a-container-stops-then-print-its-exit-code-截取容器停止时的退出状态值">wait Block until a container stops, then print its exit code #截取容器停止时的退出状态值&lt;/h2></description></item><item><title>Docs: Docker 命令行工具</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/10.%E4%BA%91%E5%8E%9F%E7%94%9F/2.2.%E5%AE%9E%E7%8E%B0%E5%AE%B9%E5%99%A8%E7%9A%84%E5%B7%A5%E5%85%B7/docker/docker-%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%B7%A5%E5%85%B7/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/10.%E4%BA%91%E5%8E%9F%E7%94%9F/2.2.%E5%AE%9E%E7%8E%B0%E5%AE%B9%E5%99%A8%E7%9A%84%E5%B7%A5%E5%85%B7/docker/docker-%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%B7%A5%E5%85%B7/</guid><description/></item><item><title>Docs: Docker 配置详解</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/10.%E4%BA%91%E5%8E%9F%E7%94%9F/2.2.%E5%AE%9E%E7%8E%B0%E5%AE%B9%E5%99%A8%E7%9A%84%E5%B7%A5%E5%85%B7/docker/docker-%E9%85%8D%E7%BD%AE%E8%AF%A6%E8%A7%A3/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/10.%E4%BA%91%E5%8E%9F%E7%94%9F/2.2.%E5%AE%9E%E7%8E%B0%E5%AE%B9%E5%99%A8%E7%9A%84%E5%B7%A5%E5%85%B7/docker/docker-%E9%85%8D%E7%BD%AE%E8%AF%A6%E8%A7%A3/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>官方文档：&lt;a href="https://docs.docker.com/engine/reference/commandline/dockerd/#/linux-configuration-file">https://docs.docker.com/engine/reference/commandline/dockerd/#/linux-configuration-file&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://blog.csdn.net/u013948858/article/details/79974796">https://blog.csdn.net/u013948858/article/details/79974796&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>Docker 的守护进程为 dockerd，dockerd 可以通过两种方式配置运行时行为&lt;/p>
&lt;ol>
&lt;li>通过配置文件 /etc/docker/daemon.json 进行配置&lt;/li>
&lt;li>使用 dockerd 命令的 flags 进行配置，可以将 flags 添加到 dockerd.service 中。&lt;/li>
&lt;/ol>
&lt;p>Note：&lt;/p>
&lt;ol>
&lt;li>配置文件中的配置，也可以通过 dockerd 的命令行参数(也就是 flags)指定，比如配置文件中的 data-root 字段，对应的 dockerd flags 为 &amp;ndash;data-root STRING。&lt;/li>
&lt;/ol>
&lt;h2 id="配置文件示例">配置文件示例&lt;/h2>
&lt;p>dockerd 配置文件是 JSON 格式，基本常用的配置内容如下。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-json" data-lang="json">&lt;span style="display:flex;">&lt;span>{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 指定 docker pull 时，首先去连接的 registry。
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#f92672">&amp;#34;registry-mirrors&amp;#34;&lt;/span>: [
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#34;http://172.38.40.180&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#34;https://ac1rmo5p.mirror.aliyuncs.com&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ],
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 指定运行 docker 操作的不安全的 registry 的列表
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#f92672">&amp;#34;insecure-registries&amp;#34;&lt;/span>: [&lt;span style="color:#e6db74">&amp;#34;http://172.38.40.180&amp;#34;&lt;/span>],
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 指定 docker 运行时其他的选项，这里面指定 docker 的 cgroupdriver 为 systemd
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#f92672">&amp;#34;exec-opts&amp;#34;&lt;/span>: [&lt;span style="color:#e6db74">&amp;#34;native.cgroupdriver=systemd&amp;#34;&lt;/span>],
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 指定 docker 的日志驱动为 json-file
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#f92672">&amp;#34;log-driver&amp;#34;&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;json-file&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 指定 docker 记录容器日志的参数，这里指定容器日志文件大小最大为100m
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#f92672">&amp;#34;log-opts&amp;#34;&lt;/span>: {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;max-size&amp;#34;&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;100m&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> },
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 指定 docker 的存储驱动类型为 overlay2
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#f92672">&amp;#34;storage-driver&amp;#34;&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;overlay2&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 指定 docker 存储驱动的其他选项
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#f92672">&amp;#34;storage-opts&amp;#34;&lt;/span>: [&lt;span style="color:#e6db74">&amp;#34;overlay2.override_kernel_check=true&amp;#34;&lt;/span>]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h1 id="命令行标志详解">命令行标志详解&lt;/h1>
&lt;p>参考[配置文件详解](/docs/IT学习笔记/10.云原生/2.2.实现容器的工具/Docker/Docker%20 配置详解.md 配置详解.md)，将配置文件中的字段转成 &amp;ndash;OPTIONS 即可。&lt;/p>
&lt;h1 id="配置文件详解">配置文件详解&lt;/h1>
&lt;h2 id="data-root-string">data-root: STRING&lt;/h2>
&lt;p>配置 docker info 命令中的 Docker Root Dir，也就是 docker 存储数据的路径。&lt;/p>
&lt;h2 id="features">features:&lt;/h2>
&lt;p>一些新的特性可以通过配置该字段来启动或停止&lt;/p>
&lt;h2 id="hosts---指定-docker-守护进程监听的端口">hosts: [] # 指定 docker 守护进程监听的端口&lt;/h2>
&lt;p>可以从其他机器使用 docker -H URL 命令对该设备进行 docker 操作&lt;/p>
&lt;h2 id="live-restore-bool">live-restore: BOOL&lt;/h2>
&lt;p>在 docker.service 守护程序停止期间，保持容器状态，说白了就是重启 docker 的时候 Containers 不重启。
开启该参数后，就算重启 dockerd 服务也不会更改 default-address-pools 参数执行的地址范围&lt;/p>
&lt;h2 id="log-driver-string--指定-docker-的日志驱动">log-driver: STRING # 指定 docker 的日志驱动&lt;/h2>
&lt;h2 id="log-opts---指定-docker-记录容器日志的参数">log-opts: {} # 指定 docker 记录容器日志的参数&lt;/h2>
&lt;h2 id="registry-mirrors---指定-pullpush-镜像时候的加速器地址">registry-mirrors: [] # 指定 pull、push 镜像时候的加速器地址&lt;/h2>
&lt;h2 id="下面是官网给的配置文件中所有可用字段的说明httpsdocsdockercomenginereferencecommandlinedockerddaemon-configuration-file">下面是&lt;a href="https://docs.docker.com/engine/reference/commandline/dockerd/#daemon-configuration-file">官网给的配置文件中所有可用字段的说明&lt;/a>：&lt;/h2>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-json" data-lang="json">&lt;span style="display:flex;">&lt;span>{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;authorization-plugins&amp;#34;&lt;/span>: [],
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;data-root&amp;#34;&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;dns&amp;#34;&lt;/span>: [],
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;dns-opts&amp;#34;&lt;/span>: [],
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;dns-search&amp;#34;&lt;/span>: [],
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;exec-opts&amp;#34;&lt;/span>: [],
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;exec-root&amp;#34;&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;experimental&amp;#34;&lt;/span>: &lt;span style="color:#66d9ef">false&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;features&amp;#34;&lt;/span>: {},
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;storage-driver&amp;#34;&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;storage-opts&amp;#34;&lt;/span>: [],
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;labels&amp;#34;&lt;/span>: [],
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;live-restore&amp;#34;&lt;/span>: &lt;span style="color:#66d9ef">true&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;log-driver&amp;#34;&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;json-file&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;log-opts&amp;#34;&lt;/span>: {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;max-size&amp;#34;&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;10m&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;max-file&amp;#34;&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;5&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;labels&amp;#34;&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;somelabel&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;env&amp;#34;&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;os,customer&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> },
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;mtu&amp;#34;&lt;/span>: &lt;span style="color:#ae81ff">0&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;pidfile&amp;#34;&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;cluster-store&amp;#34;&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;cluster-store-opts&amp;#34;&lt;/span>: {},
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;cluster-advertise&amp;#34;&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;max-concurrent-downloads&amp;#34;&lt;/span>: &lt;span style="color:#ae81ff">3&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;max-concurrent-uploads&amp;#34;&lt;/span>: &lt;span style="color:#ae81ff">5&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;default-shm-size&amp;#34;&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;64M&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;shutdown-timeout&amp;#34;&lt;/span>: &lt;span style="color:#ae81ff">15&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;debug&amp;#34;&lt;/span>: &lt;span style="color:#66d9ef">true&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 指定docker守护进程监听的端口，可以从其他机器使用docker -H URL命令对该设备进行docker操作
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#f92672">&amp;#34;hosts&amp;#34;&lt;/span>: [],
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;log-level&amp;#34;&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;tls&amp;#34;&lt;/span>: &lt;span style="color:#66d9ef">true&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;tlsverify&amp;#34;&lt;/span>: &lt;span style="color:#66d9ef">true&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;tlscacert&amp;#34;&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;tlscert&amp;#34;&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;tlskey&amp;#34;&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;swarm-default-advertise-addr&amp;#34;&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;api-cors-header&amp;#34;&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;selinux-enabled&amp;#34;&lt;/span>: &lt;span style="color:#66d9ef">false&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;userns-remap&amp;#34;&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;group&amp;#34;&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;cgroup-parent&amp;#34;&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;default-ulimits&amp;#34;&lt;/span>: {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;nofile&amp;#34;&lt;/span>: {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;Name&amp;#34;&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;nofile&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;Hard&amp;#34;&lt;/span>: &lt;span style="color:#ae81ff">64000&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;Soft&amp;#34;&lt;/span>: &lt;span style="color:#ae81ff">64000&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> },
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;init&amp;#34;&lt;/span>: &lt;span style="color:#66d9ef">false&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;init-path&amp;#34;&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;/usr/libexec/docker-init&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;ipv6&amp;#34;&lt;/span>: &lt;span style="color:#66d9ef">false&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;iptables&amp;#34;&lt;/span>: &lt;span style="color:#66d9ef">false&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;ip-forward&amp;#34;&lt;/span>: &lt;span style="color:#66d9ef">false&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;ip-masq&amp;#34;&lt;/span>: &lt;span style="color:#66d9ef">false&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;userland-proxy&amp;#34;&lt;/span>: &lt;span style="color:#66d9ef">false&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;userland-proxy-path&amp;#34;&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;/usr/libexec/docker-proxy&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;ip&amp;#34;&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;0.0.0.0&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;bridge&amp;#34;&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 指定 docker0 桥的 IP
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#f92672">&amp;#34;bip&amp;#34;&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;fixed-cidr&amp;#34;&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;fixed-cidr-v6&amp;#34;&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;default-gateway&amp;#34;&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;default-gateway-v6&amp;#34;&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;icc&amp;#34;&lt;/span>: &lt;span style="color:#66d9ef">false&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;raw-logs&amp;#34;&lt;/span>: &lt;span style="color:#66d9ef">false&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;allow-nondistributable-artifacts&amp;#34;&lt;/span>: [],
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;registry-mirrors&amp;#34;&lt;/span>: [],
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;seccomp-profile&amp;#34;&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 指定不安全仓库，docker 默认无法连接 http 协议的仓库，将仓库的 URL 添加到该字段后，docker 即可连接
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#f92672">&amp;#34;insecure-registries&amp;#34;&lt;/span>: [],
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;no-new-privileges&amp;#34;&lt;/span>: &lt;span style="color:#66d9ef">false&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;default-runtime&amp;#34;&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;runc&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;oom-score-adjust&amp;#34;&lt;/span>: &lt;span style="color:#ae81ff">-500&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;node-generic-resources&amp;#34;&lt;/span>: [&lt;span style="color:#e6db74">&amp;#34;NVIDIA-GPU=UUID1&amp;#34;&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;NVIDIA-GPU=UUID2&amp;#34;&lt;/span>],
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;runtimes&amp;#34;&lt;/span>: {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;cc-runtime&amp;#34;&lt;/span>: {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;path&amp;#34;&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;/usr/bin/cc-runtime&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> },
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;custom&amp;#34;&lt;/span>: {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;path&amp;#34;&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;/usr/local/bin/my-runc-replacement&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;runtimeArgs&amp;#34;&lt;/span>: [&lt;span style="color:#e6db74">&amp;#34;--debug&amp;#34;&lt;/span>]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> },
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;default-address-pools&amp;#34;&lt;/span>: [
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> { &lt;span style="color:#f92672">&amp;#34;base&amp;#34;&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;172.80.0.0/16&amp;#34;&lt;/span>, &lt;span style="color:#f92672">&amp;#34;size&amp;#34;&lt;/span>: &lt;span style="color:#ae81ff">24&lt;/span> },
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> { &lt;span style="color:#f92672">&amp;#34;base&amp;#34;&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;172.90.0.0/16&amp;#34;&lt;/span>, &lt;span style="color:#f92672">&amp;#34;size&amp;#34;&lt;/span>: &lt;span style="color:#ae81ff">24&lt;/span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div></description></item><item><title>Docs: Docker 权限管理</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/10.%E4%BA%91%E5%8E%9F%E7%94%9F/2.2.%E5%AE%9E%E7%8E%B0%E5%AE%B9%E5%99%A8%E7%9A%84%E5%B7%A5%E5%85%B7/docker/docker-%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/10.%E4%BA%91%E5%8E%9F%E7%94%9F/2.2.%E5%AE%9E%E7%8E%B0%E5%AE%B9%E5%99%A8%E7%9A%84%E5%B7%A5%E5%85%B7/docker/docker-%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;h1 id="docker-capabilities">Docker Capabilities&lt;/h1>
&lt;p>Capabilities 详见 [Linux Capabilities 权限管理章节](/docs/IT学习笔记/1.操作系统/5.登录%20Linux%20 与%20 访问控制/Access%20Control(访问控制)/Capabilities(能力)%20 管理.md Linux 与 访问控制/Access Control(访问控制)/Capabilities(能力) 管理.md)&lt;/p>
&lt;p>我们说 Docker 容器本质上就是一个进程，所以理论上容器就会和进程一样会有一些默认的开放权限，默认情况下 Docker 会删除必须的 &lt;code>capabilities&lt;/code> 之外的所有 &lt;code>capabilities&lt;/code>，因为在容器中我们经常会以 root 用户来运行，使用 &lt;code>capabilities&lt;/code> 现在后，容器中的使用的 root 用户权限就比我们平时在宿主机上使用的 root 用户权限要少很多了，这样即使出现了安全漏洞，也很难破坏或者获取宿主机的 root 权限，所以 Docker 支持 &lt;code>Capabilities&lt;/code> 对于容器的安全性来说是非常有必要的。
不过我们在运行容器的时候可以通过指定 &lt;code>--privileded&lt;/code> 参数来开启容器的超级权限，这个参数一定要慎用，因为他会获取系统 root 用户所有能力赋值给容器，并且会扫描宿主机的所有设备文件挂载到容器内部，所以是非常危险的操作。
但是如果你确实需要一些特殊的权限，我们可以通过 &lt;code>--cap-add&lt;/code> 和 &lt;code>--cap-drop&lt;/code> 这两个参数来动态调整，可以最大限度地保证容器的使用安全。下面表格中列出的 &lt;code>Capabilities&lt;/code> 是 Docker 默认给容器添加的，我们可以通过 &lt;code>--cap-drop&lt;/code> 去除其中一个或者多个：
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/hlragi/1621522556084-0aa763d8-6f2d-4e2f-8f69-1953f75511be.png" alt="">docker capabilities
下面表格中列出的 &lt;code>Capabilities&lt;/code> 是 Docker 默认删除的，我们可以通过&lt;code>--cap-add&lt;/code>添加其中一个或者多个：
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/hlragi/1621522556093-902979da-99b9-479e-8b11-db55a3d83605.png" alt="">docker drop capabilities&lt;/p>
&lt;blockquote>
&lt;p>&lt;code>--cap-add&lt;/code>和&lt;code>--cap-drop&lt;/code> 这两参数都支持&lt;code>ALL&lt;/code>值，比如如果你想让某个容器拥有除了&lt;code>MKNOD&lt;/code>之外的所有内核权限，那么可以执行下面的命令： &lt;code>$ sudo docker run --cap-add=ALL --cap-drop=MKNOD ...&lt;/code>&lt;/p>
&lt;/blockquote>
&lt;p>比如现在我们需要修改网络接口数据，默认情况下是没有权限的，因为需要的 &lt;code>NET_ADMIN&lt;/code> 这个 &lt;code>Capabilities&lt;/code> 默认被移除了：&lt;/p>
&lt;pre>&lt;code>$ docker run -it --rm busybox /bin/sh
/ # ip link add dummy0 type dummy
ip: RTNETLINK answers: Operation not permitted
/ #
&lt;/code>&lt;/pre>
&lt;p>所以在不使用 &lt;code>--privileged&lt;/code> 的情况下（不建议）我们可以使用 &lt;code>--cap-add=NET_ADMIN&lt;/code> 将这个 &lt;code>Capabilities&lt;/code> 添加回来：&lt;/p>
&lt;pre>&lt;code>$ docker run -it --rm --cap-add=NET_ADMIN busybox /bin/sh
/ # ip link add dummy0 type dummy
/ #
&lt;/code>&lt;/pre>
&lt;p>可以看到已经 OK 了。&lt;/p></description></item><item><title>Docs: 在Docker中使用GPU</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/10.%E4%BA%91%E5%8E%9F%E7%94%9F/2.2.%E5%AE%9E%E7%8E%B0%E5%AE%B9%E5%99%A8%E7%9A%84%E5%B7%A5%E5%85%B7/docker/%E5%9C%A8docker%E4%B8%AD%E4%BD%BF%E7%94%A8gpu/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/10.%E4%BA%91%E5%8E%9F%E7%94%9F/2.2.%E5%AE%9E%E7%8E%B0%E5%AE%B9%E5%99%A8%E7%9A%84%E5%B7%A5%E5%85%B7/docker/%E5%9C%A8docker%E4%B8%AD%E4%BD%BF%E7%94%A8gpu/</guid><description>
&lt;h3 id="docker-1903增加了对--gpus-选项的支持我们在-docker-里面想读取-nvidia-显卡再也不需要额外的安装-nvidia-docker-了下面开始实战">Docker 19.03，增加了对&amp;ndash;gpus 选项的支持，我们在 docker 里面想读取 nvidia 显卡再也不需要额外的安装 nvidia-docker 了，下面开始实战&lt;/h3>
&lt;ol>
&lt;li>安装 nvidia-container-runtime：&lt;/li>
&lt;/ol>
&lt;p>查看官网（&lt;a href="https://links.jianshu.com/go?to=https%3A%2F%2Fnvidia.github.io%2Fnvidia-container-runtime">https://nvidia.github.io/nvidia-container-runtime&lt;/a>）得知基于 RHEL 的发行版添加源的方式为：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># Centos&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>distribution&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#66d9ef">$(&lt;/span>. /etc/os-release;echo $ID$VERSION_ID&lt;span style="color:#66d9ef">)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>curl -s -L https://nvidia.github.io/nvidia-container-runtime/$distribution/nvidia-container-runtime.repo | &lt;span style="color:#ae81ff">\
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">&lt;/span> sudo tee /etc/yum.repos.d/nvidia-container-runtime.repo
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># Ubuntu&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>curl -s -L https://nvidia.github.io/nvidia-container-runtime/gpgkey | &lt;span style="color:#ae81ff">\
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">&lt;/span> sudo apt-key add -
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>distribution&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#66d9ef">$(&lt;/span>. /etc/os-release;echo $ID$VERSION_ID&lt;span style="color:#66d9ef">)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>curl -s -L https://nvidia.github.io/nvidia -container-runtime/$distribution/nvidia-container-runtime.list | &lt;span style="color:#ae81ff">\
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">&lt;/span> sudo tee /etc/apt/sources.list.d/nvidia-container-runtime.list
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>sudo apt-get update
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>添加源后直接 yum 安装：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># centos&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>yum install nvidia-container-runtime
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># Ubuntu&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>apt-get install nvidia-container-runtime
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ol start="2">
&lt;li>安装 docker-19.03&lt;/li>
&lt;/ol>
&lt;p>在新主机上首次安装 Docker Engine-Community 之前，需要设置 Docker 存储库。之后，您可以从存储库安装和更新 Docker。&lt;/p>
&lt;ul>
&lt;li>2.1 安装所需的软件包。yum-utils 提供了 yum-config-manager 效用，并 device-mapper-persistent-data 和 lvm2 由需要 devicemapper 存储驱动程序。&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>yum install -y yum-utils &lt;span style="color:#ae81ff">\
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">&lt;/span> device-mapper-persistent-data &lt;span style="color:#ae81ff">\
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">&lt;/span> lvm2
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ul>
&lt;li>2.2 使用以下命令来设置稳定的存储库。&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-csharp" data-lang="csharp">&lt;span style="display:flex;">&lt;span>yum-config-manager \
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> --&lt;span style="color:#66d9ef">add&lt;/span>-repo \
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> https:&lt;span style="color:#75715e">//download.docker.com/linux/centos/docker-ce.repo&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ul>
&lt;li>2.3 开启 Docker 服务&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>systemctl start docker &lt;span style="color:#f92672">&amp;amp;&amp;amp;&lt;/span> systemctl enable docker
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ul>
&lt;li>2.4 验证 docker 版本是否安装正常&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>$ docker version
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Client: Docker Engine - Community
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Version: 19.03.3
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> API version: 1.40
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Go version: go1.12.10
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Git commit: a872fc2f86
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Built: Tue Oct &lt;span style="color:#ae81ff">8&lt;/span> 00:58:10 &lt;span style="color:#ae81ff">2019&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> OS/Arch: linux/amd64
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Experimental: false
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Server: Docker Engine - Community
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Engine:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Version: 19.03.2
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> API version: 1.40 &lt;span style="color:#f92672">(&lt;/span>minimum version 1.12&lt;span style="color:#f92672">)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Go version: go1.12.8
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Git commit: 6a30dfc
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Built: Thu Aug &lt;span style="color:#ae81ff">29&lt;/span> 05:27:34 &lt;span style="color:#ae81ff">2019&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> OS/Arch: linux/amd64
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Experimental: false
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> containerd:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Version: 1.2.10
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> GitCommit: b34a5c8af56e510852c35414db4c1f4fa6172339
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> runc:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Version: 1.0.0-rc8+dev
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> GitCommit: 3e425f80a8c931f88e6d94a8c831b9d5aa481657
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> docker-init:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Version: 0.18.0
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> GitCommit: fec3683
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ol start="3">
&lt;li>启动容器&lt;/li>
&lt;/ol>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>docker run -d -it -p 1518:1518 --name&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;centos&amp;#34;&lt;/span> --gpus all nvidia/cuda:9.1-cudnn7-runtime-centos7 /bin/bash
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># 启动导出器&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>docker run -d --name nvidia --restart always --gpus all -p 9400:9400 nvidia/dcgm-exporter:2.0.13-2.1.1-ubuntu18.04
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>进入容器&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>docker exec -it centos /bin/bash
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>查看显卡&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>$ nvidia-smi
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Mon Oct &lt;span style="color:#ae81ff">21&lt;/span> 02:15:19 &lt;span style="color:#ae81ff">2019&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>+-----------------------------------------------------------------------------+
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>| NVIDIA-SMI 390.59 Driver Version: 390.59 |
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>|-------------------------------+----------------------+----------------------+
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>| GPU Name Persistence-M| Bus-Id Disp.A | Volatile Uncorr. ECC |
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>| Fan Temp Perf Pwr:Usage/Cap| Memory-Usage | GPU-Util Compute M. |
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>|&lt;span style="color:#f92672">===============================&lt;/span>+&lt;span style="color:#f92672">======================&lt;/span>+&lt;span style="color:#f92672">======================&lt;/span>|
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>| &lt;span style="color:#ae81ff">0&lt;/span> GeForce GTX 108... Off | 00000000:00:08.0 Off | N/A |
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>| 29% 33C P0 58W / 250W | 0MiB / 11178MiB | 0% Default |
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>+-------------------------------+----------------------+----------------------+
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>| &lt;span style="color:#ae81ff">1&lt;/span> GeForce GTX 108... Off | 00000000:00:09.0 Off | N/A |
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>| 29% 28C P5 12W / 250W | 0MiB / 11178MiB | 0% Default |
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>+-------------------------------+----------------------+----------------------+
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>| &lt;span style="color:#ae81ff">2&lt;/span> GeForce GTX 108... Off | 00000000:00:0A.0 Off | N/A |
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>| 29% 27C P5 12W / 250W | 0MiB / 11178MiB | 0% Default |
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>+-------------------------------+----------------------+----------------------+
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>| &lt;span style="color:#ae81ff">3&lt;/span> GeForce GTX 108... Off | 00000000:00:0B.0 Off | N/A |
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>| 29% 30C P5 12W / 250W | 0MiB / 11178MiB | 0% Default |
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>+-------------------------------+----------------------+----------------------+
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>| &lt;span style="color:#ae81ff">4&lt;/span> GeForce GTX 108... Off | 00000000:00:0C.0 Off | N/A |
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>| 29% 31C P0 58W / 250W | 0MiB / 11178MiB | 0% Default |
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>+-------------------------------+----------------------+----------------------+
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>| &lt;span style="color:#ae81ff">5&lt;/span> GeForce GTX 108... Off | 00000000:00:0D.0 Off | N/A |
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>| 29% 23C P5 12W / 250W | 0MiB / 11178MiB | 0% Default |
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>+-------------------------------+----------------------+----------------------+
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>| &lt;span style="color:#ae81ff">6&lt;/span> GeForce GTX 108... Off | 00000000:00:0E.0 Off | N/A |
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>| 29% 27C P5 12W / 250W | 0MiB / 11178MiB | 0% Default |
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>+-------------------------------+----------------------+----------------------+
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>| &lt;span style="color:#ae81ff">7&lt;/span> GeForce GTX 108... Off | 00000000:00:0F.0 Off | N/A |
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>| 29% 27C P5 12W / 250W | 0MiB / 11178MiB | 3% Default |
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>+-------------------------------+----------------------+----------------------+
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>+-----------------------------------------------------------------------------+
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>| Processes: GPU Memory |
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>| GPU PID Type Process name Usage |
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>|&lt;span style="color:#f92672">=============================================================================&lt;/span>|
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>| No running processes found |
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>+-----------------------------------------------------------------------------+
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div></description></item></channel></rss>