<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>断念梦 – Docker Compose</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/10.%E4%BA%91%E5%8E%9F%E7%94%9F/2.2.%E5%AE%9E%E7%8E%B0%E5%AE%B9%E5%99%A8%E7%9A%84%E5%B7%A5%E5%85%B7/docker/docker-compose/</link><description>Recent content in Docker Compose on 断念梦</description><generator>Hugo -- gohugo.io</generator><atom:link href="https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/10.%E4%BA%91%E5%8E%9F%E7%94%9F/2.2.%E5%AE%9E%E7%8E%B0%E5%AE%B9%E5%99%A8%E7%9A%84%E5%B7%A5%E5%85%B7/docker/docker-compose/index.xml" rel="self" type="application/rss+xml"/><item><title>Docs: Compose 文件规范</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/10.%E4%BA%91%E5%8E%9F%E7%94%9F/2.2.%E5%AE%9E%E7%8E%B0%E5%AE%B9%E5%99%A8%E7%9A%84%E5%B7%A5%E5%85%B7/docker/docker-compose/compose-%E6%96%87%E4%BB%B6%E8%A7%84%E8%8C%83/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/10.%E4%BA%91%E5%8E%9F%E7%94%9F/2.2.%E5%AE%9E%E7%8E%B0%E5%AE%B9%E5%99%A8%E7%9A%84%E5%B7%A5%E5%85%B7/docker/docker-compose/compose-%E6%96%87%E4%BB%B6%E8%A7%84%E8%8C%83/</guid><description>
&lt;p>参考：&lt;a href="https://docs.docker.com/compose/compose-file/">官方文档&lt;/a>、&lt;a href="https://docs.docker.com/compose/compose-file/compose-file-v3/">v3 版本规范&lt;/a>&lt;/p>
&lt;h1 id="version">version&lt;/h1>
&lt;p>指定本 yml 依从的 compose 哪个版本制定的。&lt;/p>
&lt;h3 id="build">build&lt;/h3>
&lt;p>指定为构建镜像上下文路径：&lt;/p>
&lt;p>例如 webapp 服务，指定为从上下文路径 ./dir/Dockerfile 所构建的镜像：&lt;/p>
&lt;pre>&lt;code>version: &amp;quot;3.7&amp;quot;
services:
webapp:
build: ./dir
&lt;/code>&lt;/pre>
&lt;p>或者，作为具有在上下文指定的路径的对象，以及可选的 Dockerfile 和 args：&lt;/p>
&lt;pre>&lt;code>version: &amp;quot;3.7&amp;quot;
services:
webapp:
build:
context: ./dir
dockerfile: Dockerfile-alternate
args:
buildno: 1
labels:
- &amp;quot;com.example.description=Accounting webapp&amp;quot;
- &amp;quot;com.example.department=Finance&amp;quot;
- &amp;quot;com.example.label-with-empty-value&amp;quot;
target: prod
&lt;/code>&lt;/pre>
&lt;ul>
&lt;li>context：上下文路径。&lt;/li>
&lt;li>dockerfile：指定构建镜像的 Dockerfile 文件名。&lt;/li>
&lt;li>args：添加构建参数，这是只能在构建过程中访问的环境变量。&lt;/li>
&lt;li>labels：设置构建镜像的标签。&lt;/li>
&lt;li>target：多层构建，可以指定构建哪一层。&lt;/li>
&lt;/ul>
&lt;h3 id="cap_addcap_drop">cap_add，cap_drop&lt;/h3>
&lt;p>添加或删除容器拥有的宿主机的内核功能。等价于 docker CLI 的 &amp;ndash;cap-add 标志&lt;/p>
&lt;pre>&lt;code>cap_add:
- ALL # 开启全部权限
cap_drop:
- SYS_PTRACE # 关闭 ptrace权限
&lt;/code>&lt;/pre>
&lt;h3 id="cgroup_parent">cgroup_parent&lt;/h3>
&lt;p>为容器指定父 cgroup 组，意味着将继承该组的资源限制。&lt;/p>
&lt;pre>&lt;code>cgroup_parent: m-executor-abcd
&lt;/code>&lt;/pre>
&lt;h3 id="command">command&lt;/h3>
&lt;p>覆盖容器启动的默认命令。&lt;/p>
&lt;pre>&lt;code>command: [&amp;quot;bundle&amp;quot;, &amp;quot;exec&amp;quot;, &amp;quot;thin&amp;quot;, &amp;quot;-p&amp;quot;, &amp;quot;3000&amp;quot;]
&lt;/code>&lt;/pre>
&lt;h3 id="container_name">container_name&lt;/h3>
&lt;p>指定自定义容器名称，而不是生成的默认名称。&lt;/p>
&lt;pre>&lt;code>container_name: my-web-container
&lt;/code>&lt;/pre>
&lt;h3 id="depends_on">depends_on&lt;/h3>
&lt;p>设置依赖关系。&lt;/p>
&lt;ul>
&lt;li>
&lt;p>docker-compose up ：以依赖性顺序启动服务。在以下示例中，先启动 db 和 redis ，才会启动 web。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>docker-compose up SERVICE ：自动包含 SERVICE 的依赖项。在以下示例中，docker-compose up web 还将创建并启动 db 和 redis。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>docker-compose stop ：按依赖关系顺序停止服务。在以下示例中，web 在 db 和 redis 之前停止。&lt;/p>
&lt;p>version: &amp;ldquo;3.7&amp;rdquo;
services:
web:
build: .
depends_on:
- db
- redis
redis:
image: redis
db:
image: postgres&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>注意：web 服务不会等待 redis db 完全启动 之后才启动。&lt;/p>
&lt;h3 id="devices">devices&lt;/h3>
&lt;p>指定设备映射列表。&lt;/p>
&lt;pre>&lt;code>devices:
- &amp;quot;/dev/ttyUSB0:/dev/ttyUSB0&amp;quot;
&lt;/code>&lt;/pre>
&lt;p>1
2
Plain Text&lt;/p>
&lt;h3 id="dns">dns&lt;/h3>
&lt;p>自定义 DNS 服务器，可以是单个值或列表的多个值。&lt;/p>
&lt;pre>&lt;code>dns: 8.8.8.8
dns:
- 8.8.8.8
- 9.9.9.9
&lt;/code>&lt;/pre>
&lt;h3 id="dns_search">dns_search&lt;/h3>
&lt;p>自定义 DNS 搜索域。可以是单个值或列表。&lt;/p>
&lt;pre>&lt;code>dns_search: example.com
dns_search:
- dc1.example.com
- dc2.example.com
&lt;/code>&lt;/pre>
&lt;h3 id="entrypoint">entrypoint&lt;/h3>
&lt;p>覆盖容器默认的 entrypoint。&lt;/p>
&lt;pre>&lt;code>entrypoint: /code/entrypoint.sh
&lt;/code>&lt;/pre>
&lt;p>也可以是以下格式：&lt;/p>
&lt;pre>&lt;code>entrypoint:
- php
- -d
- zend_extension=/usr/local/lib/php/extensions/no-debug-non-zts-20100525/xdebug.so
- -d
- memory_limit=-1
- vendor/bin/phpunit
&lt;/code>&lt;/pre>
&lt;h3 id="env_file">env_file&lt;/h3>
&lt;p>从文件添加环境变量。可以是单个值或列表的多个值。&lt;/p>
&lt;pre>&lt;code>env_file: .env
&lt;/code>&lt;/pre>
&lt;p>也可以是列表格式：&lt;/p>
&lt;pre>&lt;code>env_file:
- ./common.env
- ./apps/web.env
- /opt/secrets.env
&lt;/code>&lt;/pre>
&lt;h3 id="environment">environment&lt;/h3>
&lt;p>添加环境变量。您可以使用数组或字典、任何布尔值，布尔值需要用引号引起来，以确保 YML 解析器不会将其转换为 True 或 False。&lt;/p>
&lt;pre>&lt;code>environment:
RACK_ENV: development
SHOW: 'true'
&lt;/code>&lt;/pre>
&lt;h3 id="expose">expose&lt;/h3>
&lt;p>暴露端口，但不映射到宿主机，只被连接的服务访问。&lt;/p>
&lt;p>仅可以指定内部端口为参数：&lt;/p>
&lt;pre>&lt;code>expose:
- &amp;quot;3000&amp;quot;
- &amp;quot;8000&amp;quot;
&lt;/code>&lt;/pre>
&lt;h3 id="extra_hosts">extra_hosts&lt;/h3>
&lt;p>添加主机名映射。类似 docker client &amp;ndash;add-host。&lt;/p>
&lt;pre>&lt;code>extra_hosts:
- &amp;quot;somehost:162.242.195.82&amp;quot;
- &amp;quot;otherhost:50.31.209.229&amp;quot;
&lt;/code>&lt;/pre>
&lt;p>以上会在此服务的内部容器中 /etc/hosts 创建一个具有 ip 地址和主机名的映射关系：&lt;/p>
&lt;pre>&lt;code>162.242.195.82 somehost
50.31.209.229 otherhost
&lt;/code>&lt;/pre>
&lt;h3 id="healthcheck">healthcheck&lt;/h3>
&lt;p>用于检测 docker 服务是否健康运行。&lt;/p>
&lt;pre>&lt;code>healthcheck:
test: [&amp;quot;CMD&amp;quot;, &amp;quot;curl&amp;quot;, &amp;quot;-f&amp;quot;, &amp;quot;http://localhost&amp;quot;] # 设置检测程序
interval: 1m30s # 设置检测间隔
timeout: 10s # 设置检测超时时间
retries: 3 # 设置重试次数
start_period: 40s # 启动后，多少秒开始启动检测程序
&lt;/code>&lt;/pre>
&lt;h3 id="image">image&lt;/h3>
&lt;p>指定容器运行的镜像。以下格式都可以：&lt;/p>
&lt;pre>&lt;code>image: redis
image: ubuntu:14.04
image: tutum/influxdb
image: example-registry.com:4000/postgresql
image: a4bc65fd # 镜像id
&lt;/code>&lt;/pre>
&lt;h3 id="logging">logging&lt;/h3>
&lt;p>服务的日志记录配置。
driver：指定服务容器的日志记录驱动程序，默认值为 json-file。有以下三个选项&lt;/p>
&lt;pre>&lt;code>driver: &amp;quot;json-file&amp;quot;
driver: &amp;quot;syslog&amp;quot;
driver: &amp;quot;none&amp;quot;
&lt;/code>&lt;/pre>
&lt;p>仅在 json-file 驱动程序下，可以使用以下参数，限制日志得数量和大小。&lt;/p>
&lt;pre>&lt;code>logging:
driver: json-file
options:
max-size: &amp;quot;200k&amp;quot; # 单个文件大小为200k
max-file: &amp;quot;10&amp;quot; # 最多10个文件
&lt;/code>&lt;/pre>
&lt;p>当达到文件限制上限，会自动删除旧得文件。&lt;/p>
&lt;p>syslog 驱动程序下，可以使用 syslog-address 指定日志接收地址。&lt;/p>
&lt;pre>&lt;code>logging:
driver: syslog
options:
syslog-address: &amp;quot;tcp://192.168.0.42:123&amp;quot;
&lt;/code>&lt;/pre>
&lt;h3 id="network_mode">network_mode&lt;/h3>
&lt;p>设置网络模式。&lt;/p>
&lt;pre>&lt;code>network_mode: &amp;quot;bridge&amp;quot;
network_mode: &amp;quot;host&amp;quot;
network_mode: &amp;quot;none&amp;quot;
network_mode: &amp;quot;service:[service name]&amp;quot;
network_mode: &amp;quot;container:[container name/id]&amp;quot;
&lt;/code>&lt;/pre>
&lt;h3 id="networks">networks&lt;/h3>
&lt;p>配置容器连接的网络，引用顶级 networks 下的条目 。&lt;/p>
&lt;pre>&lt;code>services:
some-service:
networks:
some-network:
aliases:
- alias1
other-network:
aliases:
- alias2
networks:
some-network:
# Use a custom driver
driver: custom-driver-1
other-network:
# Use a custom driver which takes special options
driver: custom-driver-2
&lt;/code>&lt;/pre>
&lt;p>&lt;strong>aliases&lt;/strong> ：同一网络上的其他容器可以使用服务名称或此别名来连接到对应容器的服务。&lt;/p>
&lt;h3 id="restart">restart&lt;/h3>
&lt;ul>
&lt;li>
&lt;p>no：是默认的重启策略，在任何情况下都不会重启容器。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>always：容器总是重新启动。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>on-failure：在容器非正常退出时（退出状态非 0），才会重启容器。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>unless-stopped：在容器退出时总是重启容器，但是不考虑在 Docker 守护进程启动时就已经停止了的容器&lt;/p>
&lt;p>restart: &amp;ldquo;no&amp;rdquo;
restart: always
restart: on-failure
restart: unless-stopped&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>注：swarm 集群模式，请改用 restart_policy。&lt;/p>
&lt;h3 id="secrets">secrets&lt;/h3>
&lt;p>存储敏感数据，例如密码：&lt;/p>
&lt;pre>&lt;code>version: &amp;quot;3.1&amp;quot;
services:
mysql:
image: mysql
environment:
MYSQL_ROOT_PASSWORD_FILE: /run/secrets/my_secret
secrets:
- my_secret
secrets:
my_secret:
file: ./my_secret.txt
&lt;/code>&lt;/pre>
&lt;h3 id="security_opt">security_opt&lt;/h3>
&lt;p>修改容器默认的 schema 标签。&lt;/p>
&lt;pre>&lt;code>security-opt：
- label:user:USER # 设置容器的用户标签
- label:role:ROLE # 设置容器的角色标签
- label:type:TYPE # 设置容器的安全策略标签
- label:level:LEVEL # 设置容器的安全等级标签
&lt;/code>&lt;/pre>
&lt;h3 id="stop_grace_period">stop_grace_period&lt;/h3>
&lt;p>指定在容器无法处理 SIGTERM (或者任何 stop_signal 的信号)，等待多久后发送 SIGKILL 信号关闭容器。&lt;/p>
&lt;pre>&lt;code>stop_grace_period: 1s # 等待 1 秒
stop_grace_period: 1m30s # 等待 1 分 30 秒
&lt;/code>&lt;/pre>
&lt;p>默认的等待时间是 10 秒。&lt;/p>
&lt;h3 id="stop_signal">stop_signal&lt;/h3>
&lt;p>设置停止容器的替代信号。默认情况下使用 SIGTERM 。&lt;/p>
&lt;p>以下示例，使用 SIGUSR1 替代信号 SIGTERM 来停止容器。&lt;/p>
&lt;pre>&lt;code>stop_signal: SIGUSR1
&lt;/code>&lt;/pre>
&lt;h3 id="sysctls">sysctls&lt;/h3>
&lt;p>设置容器中的内核参数，可以使用数组或字典格式。&lt;/p>
&lt;pre>&lt;code>sysctls:
net.core.somaxconn: 1024
net.ipv4.tcp_syncookies: 0
sysctls:
- net.core.somaxconn=1024
- net.ipv4.tcp_syncookies=0
&lt;/code>&lt;/pre>
&lt;h3 id="tmpfs">tmpfs&lt;/h3>
&lt;p>在容器内安装一个临时文件系统。可以是单个值或列表的多个值。&lt;/p>
&lt;pre>&lt;code>tmpfs: /run
tmpfs:
- /run
- /tmp
&lt;/code>&lt;/pre>
&lt;h3 id="ulimits">ulimits&lt;/h3>
&lt;p>覆盖容器默认的 ulimit。&lt;/p>
&lt;pre>&lt;code>ulimits:
nproc: 65535
nofile:
soft: 20000
hard: 40000
&lt;/code>&lt;/pre>
&lt;h2 id="volumes">volumes&lt;/h2>
&lt;p>将主机的数据卷或着文件挂载到容器里。&lt;/p>
&lt;pre>&lt;code>version: &amp;quot;3.7&amp;quot;
services:
db:
image: postgres:latest
volumes:
- &amp;quot;/localhost/postgres.sock:/var/run/postgres/postgres.sock&amp;quot;
- &amp;quot;/localhost/data:/var/lib/postgresql/data&amp;quot;
&lt;/code>&lt;/pre></description></item><item><title>Docs: docker-compose 命令行工具</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/10.%E4%BA%91%E5%8E%9F%E7%94%9F/2.2.%E5%AE%9E%E7%8E%B0%E5%AE%B9%E5%99%A8%E7%9A%84%E5%B7%A5%E5%85%B7/docker/docker-compose/docker-compose-%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%B7%A5%E5%85%B7/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/10.%E4%BA%91%E5%8E%9F%E7%94%9F/2.2.%E5%AE%9E%E7%8E%B0%E5%AE%B9%E5%99%A8%E7%9A%84%E5%B7%A5%E5%85%B7/docker/docker-compose/docker-compose-%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%B7%A5%E5%85%B7/</guid><description>
&lt;p>参考：&lt;a href="https://docs.docker.com/compose/reference/">官方文档&lt;/a>
通过 run 命令，可以在容器启动失败时，进行调试&lt;/p>
&lt;p>docker-compose -f docker-compose-backup.yaml run keepalived bash&lt;/p>
&lt;p>这样会启动 keepalived 容器，并分配一个终端。&lt;/p></description></item></channel></rss>