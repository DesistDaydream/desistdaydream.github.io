<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>断念梦 – 容器管理</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/10.%E4%BA%91%E5%8E%9F%E7%94%9F/2.2.%E5%AE%9E%E7%8E%B0%E5%AE%B9%E5%99%A8%E7%9A%84%E5%B7%A5%E5%85%B7/%E5%AE%B9%E5%99%A8%E7%AE%A1%E7%90%86/</link><description>Recent content in 容器管理 on 断念梦</description><generator>Hugo -- gohugo.io</generator><atom:link href="https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/10.%E4%BA%91%E5%8E%9F%E7%94%9F/2.2.%E5%AE%9E%E7%8E%B0%E5%AE%B9%E5%99%A8%E7%9A%84%E5%B7%A5%E5%85%B7/%E5%AE%B9%E5%99%A8%E7%AE%A1%E7%90%86/index.xml" rel="self" type="application/rss+xml"/><item><title>Docs: 容器镜像管理</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/10.%E4%BA%91%E5%8E%9F%E7%94%9F/2.2.%E5%AE%9E%E7%8E%B0%E5%AE%B9%E5%99%A8%E7%9A%84%E5%B7%A5%E5%85%B7/%E5%AE%B9%E5%99%A8%E7%AE%A1%E7%90%86/%E5%AE%B9%E5%99%A8%E9%95%9C%E5%83%8F%E7%AE%A1%E7%90%86/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/10.%E4%BA%91%E5%8E%9F%E7%94%9F/2.2.%E5%AE%9E%E7%8E%B0%E5%AE%B9%E5%99%A8%E7%9A%84%E5%B7%A5%E5%85%B7/%E5%AE%B9%E5%99%A8%E7%AE%A1%E7%90%86/%E5%AE%B9%E5%99%A8%E9%95%9C%E5%83%8F%E7%AE%A1%E7%90%86/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考:&lt;/p>
&lt;ul>
&lt;li>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;h1 id="skopeo">Skopeo&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://github.com/containers/skopeo">GitHub 项目，containers/skopeo&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.modb.pro/db/251368">https://www.modb.pro/db/251368&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://blog.k8s.li/skopeo.html">https://blog.k8s.li/skopeo.html&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>Skopeo 是一个命令行客户端应用程序，可以对容器镜像和镜像存储库执行各种操作。Skopeo 是一个命令行客户端应用程序，可以对容器镜像和镜像存储库执行各种操作。Skopeo 是一个命令行客户端应用程序，可以对容器镜像和镜像存储库执行各种操作。Skopeo 是一个命令行客户端应用程序，可以对容器镜像和镜像存储库执行各种操作。Skopeo 是一个命令行客户端应用程序，可以对容器镜像和镜像存储库执行各种操作。&lt;/p>
&lt;h2 id="syntax语法">Syntax(语法)&lt;/h2>
&lt;p>&lt;strong>skopeo [FLAGS] COMMAND&lt;/strong>&lt;/p>
&lt;h2 id="list-tags--列出指定镜像的所有-tags">list-tags # 列出指定镜像的所有 Tags&lt;/h2>
&lt;h2 id="sync--同步一个或多个镜像从一个位置到另一个位置">sync # 同步一个或多个镜像从一个位置到另一个位置&lt;/h2>
&lt;p>sync 子命令可以将容器镜像从一个地方拷贝到另一个地方。&lt;/p>
&lt;h3 id="syntax语法-1">Syntax(语法)&lt;/h3>
&lt;p>&lt;strong>skopeo sync [FLAGS] &amp;ndash;src TRANSPORT &amp;ndash;dest TRANSPORT SOURCE DESTINATION&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>&lt;strong>TRANSPORT&lt;/strong> # 传输类型，就是指定获取镜像源和镜像目的方式。可用的类型有如下几种：
&lt;ul>
&lt;li>&lt;strong>docker&lt;/strong> # 从镜像的注册中心获取镜像&lt;/li>
&lt;li>&lt;strong>dir&lt;/strong> # 从本地目录获取镜像&lt;/li>
&lt;li>&lt;strong>yaml&lt;/strong> # 从一个 YAML 格式的文件中获取镜像&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>比如 &lt;code>skopeo sync --src docker --dest dir --scoped docker.io/busybox:1 ~/test_dir/&lt;/code> 就是可以将 &lt;code>docker.io/busybox:1&lt;/code> 镜像的所有数据下载到本地的 &lt;code>~/test_dir/&lt;/code> 目录中。&lt;/p>
&lt;h4 id="flags">FLAGS&lt;/h4>
&lt;ul>
&lt;li>**-d, &amp;ndash;dest &lt;!-- raw HTML omitted --> **# 指定 DESTINATION 的传输类型，可用的值有 docker、dir&lt;/li>
&lt;li>&lt;strong>-s, &amp;ndash;src &lt;!-- raw HTML omitted -->&lt;/strong> # 指定 SOURCE 的传输类型，可用的值有 docker、dir、yaml&lt;/li>
&lt;/ul>
&lt;h2 id="最佳实践">最佳实践&lt;/h2>
&lt;ul>
&lt;li>skopeo copy docker://debian:stretch oci:debian:stretch&lt;/li>
&lt;/ul>
&lt;h1 id="image-syncer">image-syncer&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://github.com/AliyunContainerService/image-syncer">GitHub 项目，AliyunContainerService/image-syncer&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote></description></item><item><title>Docs: 容器运行时管理</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/10.%E4%BA%91%E5%8E%9F%E7%94%9F/2.2.%E5%AE%9E%E7%8E%B0%E5%AE%B9%E5%99%A8%E7%9A%84%E5%B7%A5%E5%85%B7/%E5%AE%B9%E5%99%A8%E7%AE%A1%E7%90%86/%E5%AE%B9%E5%99%A8%E8%BF%90%E8%A1%8C%E6%97%B6%E7%AE%A1%E7%90%86/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/10.%E4%BA%91%E5%8E%9F%E7%94%9F/2.2.%E5%AE%9E%E7%8E%B0%E5%AE%B9%E5%99%A8%E7%9A%84%E5%B7%A5%E5%85%B7/%E5%AE%B9%E5%99%A8%E7%AE%A1%E7%90%86/%E5%AE%B9%E5%99%A8%E8%BF%90%E8%A1%8C%E6%97%B6%E7%AE%A1%E7%90%86/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;/blockquote>
&lt;p>容器运行时通常都是由实现容器的工具自己管理的，如果要说真正通用的管理，可能只有 runc 了，而 runc 本质就是通过类似 unshare、nsenter 等工具完成容器运行时的功能。&lt;/p>
&lt;h1 id="unshare--创建-namesapce">unshare # 创建 namesapce&lt;/h1>
&lt;h1 id="nsenter--使用其他进程的名称空间运行程序">nsenter # 使用其他进程的名称空间运行程序&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://man7.org/linux/man-pages/man1/nsenter.1.html">Manual(手册),nsenter(1)&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>就像这个工具的名字一样，nsenter(namespace enter)。进入一个或多个其他进程的名称空间，然后运行指定的程序。如果没有给出指定的程序(语法中的 PROGRAM)，则运行默认的 &lt;code>${SHELL}&lt;/code>。&lt;/p>
&lt;h2 id="syntax语法">Syntax(语法)&lt;/h2>
&lt;p>&lt;strong>nsenter [OPTIONS] [PROGRAM[ARGUMENTS]]&lt;/strong>&lt;/p>
&lt;p>&lt;strong>OPTIONS:&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>&lt;strong>-a, &amp;ndash;all&lt;/strong> # 进入所有名称空间&lt;/li>
&lt;li>&lt;strong>-t, &amp;ndash;target &lt;!-- raw HTML omitted -->&lt;/strong> # 指定要进入命名空间的目标进程的 PID&lt;/li>
&lt;li>-m, &amp;ndash;mount[=file]：进入 mount 命令空间。如果指定了 file，则进入 file 的命令空间&lt;/li>
&lt;li>-u, &amp;ndash;uts[=file]：进入 uts 命令空间。如果指定了 file，则进入 file 的命令空间&lt;/li>
&lt;li>-i, &amp;ndash;ipc[=file]：进入 ipc 命令空间。如果指定了 file，则进入 file 的命令空间&lt;/li>
&lt;li>-n, &amp;ndash;net[=file]：进入 net 命令空间。如果指定了 file，则进入 file 的命令空间&lt;/li>
&lt;li>-p, &amp;ndash;pid[=file]：进入 pid 命令空间。如果指定了 file，则进入 file 的命令空间&lt;/li>
&lt;li>-U, &amp;ndash;user[=file]：进入 user 命令空间。如果指定了 file，则进入 file 的命令空间&lt;/li>
&lt;li>-G, &amp;ndash;setgid gid：设置运行程序的 gid&lt;/li>
&lt;li>-S, &amp;ndash;setuid uid：设置运行程序的 uid&lt;/li>
&lt;li>-r, &amp;ndash;root[=directory]：设置根目录&lt;/li>
&lt;li>-w, &amp;ndash;wd[=directory]：设置工作目录&lt;/li>
&lt;/ul>
&lt;h2 id="example">EXAMPLE&lt;/h2>
&lt;ul>
&lt;li>从普通用户进入到 root 用户空间
&lt;ul>
&lt;li>&lt;strong>sudo nsenter -t 1 -n&lt;/strong>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>获取到容器的 PID
&lt;ul>
&lt;li>&lt;strong>docker inspect &amp;ndash;format &amp;ldquo;{{.State.Pid}}&amp;rdquo; ContainerID&lt;/strong>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>进入到 8514 进程的网络名称空间中
&lt;ul>
&lt;li>&lt;strong>nsenter -n -t 8514&lt;/strong>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>进入 15928 进程的多个名称空间中
&lt;ul>
&lt;li>&lt;strong>nsenter -p -n -u -i -m -t 15928&lt;/strong>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>进入 node-exporter 容器的 mount 名称空间中，并执行 /bin/sh 命令
&lt;ul>
&lt;li>nsenter -m -t $(docker container inspect node-exporter &amp;ndash;format &amp;lsquo;{{.State.Pid}}&amp;rsquo;) /bin/sh&lt;/li>
&lt;li>这条命令可以直接查看容器内的文件系统，效果如下&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>~&lt;span style="color:#f92672">]&lt;/span>&lt;span style="color:#75715e"># nsenter -m -t $(docker container inspect node-exporter --format &amp;#39;{{.State.Pid}}&amp;#39;) /bin/sh&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>~&lt;span style="color:#f92672">]&lt;/span>&lt;span style="color:#75715e"># ls&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>bin dev etc home host lib proc root sys tmp usr var
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>~&lt;span style="color:#f92672">]&lt;/span>&lt;span style="color:#75715e"># which node_exporter&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>/bin/node_exporter
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ul>
&lt;li>注意：进入 mount 名称空间时所指定的 /bin/sh 命令必须要在容器内真是有这个程序，才能实现类似于 “进入” 名称空间的效果。否则，若该容器本身不提供任何 shell 程序，则无法实现进入效果。&lt;/li>
&lt;/ul>
&lt;h1 id="lsns--列出名称空间包括-ns-type-nprocs-pid-user-command-字段">lsns # 列出名称空间，包括 NS TYPE NPROCS PID USER COMMAND 字段&lt;/h1>
&lt;h2 id="syntax语法-1">Syntax(语法)&lt;/h2>
&lt;p>&lt;strong>lsns [OPTIONS] [NAMESPACE]&lt;/strong>&lt;/p>
&lt;p>OPTIONS：&lt;/p>
&lt;h2 id="example-1">EXAMPLE&lt;/h2>
&lt;ul>
&lt;li>lsns # 列出所有名称空间信息&lt;/li>
&lt;/ul></description></item><item><title>Docs: 容器运行时管理</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/10.%E4%BA%91%E5%8E%9F%E7%94%9F/2.2.%E5%AE%9E%E7%8E%B0%E5%AE%B9%E5%99%A8%E7%9A%84%E5%B7%A5%E5%85%B7/%E5%AE%B9%E5%99%A8%E7%AE%A1%E7%90%86/%E5%AE%B9%E5%99%A8%E8%BF%90%E8%A1%8C%E6%97%B6%E7%AE%A1%E7%90%86/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/10.%E4%BA%91%E5%8E%9F%E7%94%9F/2.2.%E5%AE%9E%E7%8E%B0%E5%AE%B9%E5%99%A8%E7%9A%84%E5%B7%A5%E5%85%B7/%E5%AE%B9%E5%99%A8%E7%AE%A1%E7%90%86/%E5%AE%B9%E5%99%A8%E8%BF%90%E8%A1%8C%E6%97%B6%E7%AE%A1%E7%90%86/</guid><description/></item><item><title>Docs: 使用 Tini 清理 Docker 容器僵死进程</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/10.%E4%BA%91%E5%8E%9F%E7%94%9F/2.2.%E5%AE%9E%E7%8E%B0%E5%AE%B9%E5%99%A8%E7%9A%84%E5%B7%A5%E5%85%B7/%E5%AE%B9%E5%99%A8%E7%AE%A1%E7%90%86/%E4%BD%BF%E7%94%A8-tini-%E6%B8%85%E7%90%86-docker-%E5%AE%B9%E5%99%A8%E5%83%B5%E6%AD%BB%E8%BF%9B%E7%A8%8B/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/10.%E4%BA%91%E5%8E%9F%E7%94%9F/2.2.%E5%AE%9E%E7%8E%B0%E5%AE%B9%E5%99%A8%E7%9A%84%E5%B7%A5%E5%85%B7/%E5%AE%B9%E5%99%A8%E7%AE%A1%E7%90%86/%E4%BD%BF%E7%94%A8-tini-%E6%B8%85%E7%90%86-docker-%E5%AE%B9%E5%99%A8%E5%83%B5%E6%AD%BB%E8%BF%9B%E7%A8%8B/</guid><description>
&lt;p>&lt;a href="https://mp.weixin.qq.com/s/Ktd56YQsU8pP6kUs3_uU4Q">使用 Tini 清理 Docker 容器僵死进程&lt;/a>&lt;/p>
&lt;blockquote>
&lt;p>最近在 Tini 的仓库下看到作者对 Tini 优势的精彩回复，搬运过来，粗糙翻译，献给拥有同样疑惑的你。&lt;/p>
&lt;/blockquote>
&lt;h2 id="写在前面">写在前面&lt;/h2>
&lt;p>我们在查看一些大项目的 Dockerfile 时经常发现，它们的 ENTRYPOINT 中往往都有 tini 的身影：&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/635f36ef-00c6-4161-bed8-02cbbf17e561/640" alt="">&lt;/p>
&lt;p>Rancher 官方镜像&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/635f36ef-00c6-4161-bed8-02cbbf17e561/640" alt="">&lt;/p>
&lt;p>Jenkins 官方镜像&lt;/p>
&lt;p>那 Tini 到底是什么？为什么大家都喜欢在镜像中使用它呢？&lt;/p>
&lt;h2 id="开发者的疑问">开发者的疑问&lt;/h2>
&lt;p>我注意到 Jenkins 的官方镜像中使用了 Tini，所以我很好奇它是什么。它看起来一定很有用，可能解决了一些我不知道的问题。你能用 “说人话” 的方式简单解释一下 Tini 相对于直接以 CMD 运行 shell 脚本的优势吗？&lt;/p>
&lt;p>我的几个容器的 ENTRYPOINT 都设置了一个 docker-entrypoint.sh 脚本，里面基本上都是以 “exec &amp;ldquo;$@&amp;quot;” 的方式在运行，我应该使用 Tini 来代替吗？&lt;/p>
&lt;h2 id="来自作者的回复">来自作者的回复&lt;/h2>
&lt;p>问得好！但这解释可能有点长，所以请耐心听我说（我知道你要求简短，但我真的做不到，捂脸~）。&lt;/p>
&lt;p>首先，我们先简单聊聊 Jenkins。当您运行 Docker 容器时，Docker 会将它与系统的其他部分隔离开来。这种隔离发生在不同的级别（例如网络、文件系统、进程）。&lt;/p>
&lt;p>但 Tini 并不真正关注网络或文件系统，所以让我们把注意力放在 Tini 的一个重要概念上：进程。&lt;/p>
&lt;p>每个 Docker 容器都是一个 PID 命名空间，这意味着容器中的进程与主机上的其他进程是隔离的。PID 命名空间是一棵树，从 PID 1 开始，通常称为 init。&lt;/p>
&lt;p>注意：当你运行一个 Docker 容器时，镜像的 ENTRYPOINT 就是你的根进程，即 PID 1（如果你没有 ENTRYPOINT，那么 CMD 就会作为根进程，你可能配置了一个 shell 脚本，或其他的可执行程序，容器的根进程具体是什么，完全取决于你的配置）。&lt;/p>
&lt;p>与其他进程不同的是，PID 1 有一个独特的职责，那就是收割 “僵尸进程”。&lt;/p>
&lt;p>那何为 “僵尸进程” 呢？&lt;/p>
&lt;p>“僵尸进程” 是指：&lt;/p>
&lt;ul>
&lt;li>已经退出。&lt;/li>
&lt;li>没有被其父进程 wait（wait 是指 syscall 父进程用于检索其子进程的退出代码）。&lt;/li>
&lt;li>父进程已丢失（也就是说，它们的父进程已经不存在了)，这意味着他们永远不会被其父进程处理。&lt;/li>
&lt;/ul>
&lt;p>当 “僵尸进程” 被创建时（也就是说，一旦它的父进程非正常退出了，它也就跟着无法正常退出了），它会继承成为 PID 1 的子级，最后 PID 1 会负责关闭它。&lt;/p>
&lt;p>换句话说，有人必须在 “不负责任” 的父进程离开后，对这些 “孤儿” 进行清理，这是 PID 1 的作用。&lt;/p>
&lt;p>请注意，创建 “僵尸进程” 通常是不被允许的（也就是说，理想情况下，您应该修复代码，这样就不会创建“僵尸进程”），但是对于像 Jenkins 这种应用来说，它们是不可避免的：因为 Jenkins 通常运行的代码不是由 Jenkins 维护者编写的（也就是您的 Jenkins 构建脚本），所以他们也无法“修复代码”。&lt;/p>
&lt;p>这就是 Jenkins 使用 Tini 的原因：在构建了创建 “僵尸进程” 的脚本后进行清理。&lt;/p>
&lt;hr>
&lt;p>但其实 Bash 实际上也做同样的事情（收割 “僵尸进程”），所以你可能会想：为什么不把 Bash 当作 PID 1 呢？&lt;/p>
&lt;p>第一个问题是，如果您将 Bash 作为 PID 1 运行，那么您发送到 Docker 容器的所有信号（例如，使用 docker stop 或 docker kill）最终都会发送到 Bash，Bash 默认不会将它们转发到任何地方（除非您自己编写代码实现）。换句话说，如果你使用 Bash 来运行 Jenkins，那么当你运行 docker stop 的时候，Jenkins 将永远收不到停止信号！&lt;/p>
&lt;p>而 Tini 通过 “信号转发” 解决了这个问题：如果你向 Tini 发送信号，那么它也会向你的子进程发送同样的信号（在你的例子中是 Jenkins）。&lt;/p>
&lt;p>第二个问题是，一旦您的进程退出，Bash 也会继续退出。如果您不小心，Bash 可能会退出，退出代码为 0，而您的进程实际上崩溃了（但 0 表示 “一切正常”；这将导致 Docker 重启策略不符合您的预期）。因为您真正想要的可能是 Bash 返回与您的进程相同的退出代码。&lt;/p>
&lt;p>请注意，您可以通过在 Bash 中创建信号处理程序来实际执行转发，并返回适当的退出代码来解决这个问题。另一方面，这需要做更多的工作，而添加 Tini 只是文档中的几行。&lt;/p>
&lt;hr>
&lt;p>其实还有另一个解决方案可以将 Jenkins 作为 PID 1 运行，即在 Jenkins 中添加另一个线程来负责收割 “僵尸进程”。&lt;/p>
&lt;p>但这也不理想，原因有二：&lt;/p>
&lt;p>首先，如果将 Jenkins 以 PID 1 的身份运行，那么很难区分继承给 Jenkins 的进程（应该被收割）和 Jenkins 自己产生的进程（不应该被收割，因为还有其他代码已经在等待它们执行）。我相信你可以用代码来解决这个问题，但还是要问一遍：当你可以把 Tini 放进去的时候，为什么还要写呢？&lt;/p>
&lt;p>其次，如果 Jenkins 以 PID 1 运行，那么它可能不会接收到您发送的信号！&lt;/p>
&lt;p>这是 PID 1 进程中的微妙之处。与其他进程不同的是，PID 1 没有默认的信号处理程序，这意味着如果 Jenkins 没有明确地为 SIGTERM 安装信号处理程序，那么该信号在发送时将被丢弃（而默认行为是终止该过程）。&lt;/p>
&lt;p>Tini 确实安装了显式信号处理程序（顺便说一下，是为了转发信号），所以这些信号不再被丢弃。相反，它们被发送到 Jenkins，Jenkins 并不像 PID 1（Tini ）那样运行，因此有默认的信号处理程序（注意：这不是 Jenkins 使用 Tini 的原因，Jenkins 使用它来获取信号，但在 RabbitMQ 的镜像中是这个作用）。&lt;/p>
&lt;hr>
&lt;p>请注意，Tini 中还有一些额外的功能，在 Bash 或 Java 中很难实现（例如，Tini 可以注册为 “子收割者”，因此它实际上不需要作为 PID 1 运行来完成“僵尸进程” 收割工作），但是这些功能对于一些高级应用场景来说非常有用。&lt;/p>
&lt;p>希望以上内容对你有所帮助！&lt;/p>
&lt;p>如果您有兴趣了解更多，以下是一些可供参考的资料：&lt;/p>
&lt;ul>
&lt;li>僵尸进程详解：&lt;a href="https://blog.phusion.nl/2015/01/20/docker-and-the-pid-1-zombie-reaping-problem/">https://blog.phusion.nl/2015/01/20/docker-and-the-pid-1-zombie-reaping-problem/&lt;/a>&lt;/li>
&lt;li>更简洁的解释：&lt;a href="https://github.com/docker-library/official-images#init">https://github.com/docker-library/official-images#init&lt;/a>&lt;/li>
&lt;/ul>
&lt;p>最后，请注意 Tini 还有更多的选择（比如 Phusion 的基础镜像）。&lt;/p>
&lt;p>Tini 的主要特性是：&lt;/p>
&lt;ul>
&lt;li>做 PID 1 需要做的一切，而不做其他任何事情。像读取环境文件、改变用户、过程监控等事情不在 Tini 的范围内（还有其他更好的工具）；&lt;/li>
&lt;li>零配置就能上手（如果运行不正常，Tini &amp;gt;= 0.6 也会警告您）；&lt;/li>
&lt;li>它有丰富的测试。&lt;/li>
&lt;/ul>
&lt;h2 id="原文链接">原文链接&lt;/h2>
&lt;ul>
&lt;li>&lt;code>What is advantage of Tini?&lt;/code>：&lt;a href="https://github.com/krallin/tini/issues/8#issuecomment-146135930">https://github.com/krallin/tini/issues/8#issuecomment-146135930&lt;/a>&lt;/li>
&lt;li>&lt;code>译文来源&lt;/code>：&lt;a href="https://zhuanlan.zhihu.com/p/59796137">https://zhuanlan.zhihu.com/p/59796137&lt;/a>&lt;/li>
&lt;/ul>
&lt;h1 id="docker-容器中进程管理工具">Docker 容器中进程管理工具&lt;/h1>
&lt;p>为了防止容器中直接使用 ENTRYPOINT 或 CMD 指令启动命令或应用程序产生 PID 为 1 的进程无法处理传递信号给子进程或者无法接管孤儿进程，进而导致产生大量的僵尸进程。对于没有能力处理以上两个进程问题的 PID 进程，建议使用 dumb-int 或 tini 这种第三方工具来充当 1 号进程。&lt;/p>
&lt;p>Linux 系统中，PID 为 1 的进程需要担任两个重要的使命：&lt;/p>
&lt;ol>
&lt;li>&lt;strong>传递信号给子进程&lt;/strong>
如果 pid 为 1 的进程，无法向其子进程传递信号，可能导致容器发送 SIGTERM 信号之后，父进程等待子进程退出。此时，如果父进程不能将信号传递到子进程，则整个容器就将无法正常退出，除非向父进程发送 SIGKILL 信号，使其强行退出，这就会导致一些退出前的操作无法正常执行，例如关闭数据库连接、关闭输入输出流等。&lt;/li>
&lt;li>&lt;strong>接管孤儿进程，防止出现僵尸进程&lt;/strong>
如果一个进程中 A 运行了一个子进程 B，而这个子进程 B 又创建了一个子进程 C，若子进程 B 非正常退出（通过 SIGKILL 信号，并不会传递 SIGKILL 信号给进程 C），那么子进程 C 就会由进程 A 接管，一般情况下，我们在进程 A 中并不会处理对进程 C 的托管操作（进程 A 不会传递 SIGTERM 和 SIGKILL 信号给进程 C），结果就导致了进程 B 结束了，倒是并没有回收其子进程 C，子进程 C 就变成了僵尸进程。&lt;/li>
&lt;/ol>
&lt;p>在 docker 中，&lt;code>docker stop&lt;/code>命令会发送&lt;code>SIGTERM&lt;/code>信号给容器的主进程来处理。如果主进程没有处理这个信号，docker 会在等待一段优雅 grace 的时间后，发送&lt;code>SIGKILL&lt;/code>信号来强制终止&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/635f36ef-00c6-4161-bed8-02cbbf17e561/images" alt="">&lt;/p>
&lt;p>详情参考：&lt;/p>
&lt;p>1、&lt;a href="https://blog.phusion.nl/2015/01/20/docker-and-the-pid-1-zombie-reaping-problem/">https://blog.phusion.nl/2015/01/20/docker-and-the-pid-1-zombie-reaping-problem/&lt;/a>&lt;/p>
&lt;p>2、&lt;a href="https://medium.com/@gchudnov/trapping-signals-in-docker-containers-7a57fdda7d86">https://medium.com/@gchudnov/trapping-signals-in-docker-containers-7a57fdda7d86&lt;/a>&lt;/p>
&lt;p>Github：&lt;a href="https://github.com/Yelp/dumb-init">https://github.com/Yelp/dumb-init&lt;/a>&lt;/p>
&lt;p>dumb-int 是一个用 C 写的轻量级进程管理工具。类似于一个初始化系统，&lt;/p>
&lt;p>它充当 PID 1，并立即以子进程的形式允许您的命令，注意在接收到信号时正确处理和转发它们&lt;/p>
&lt;p>dumb-init 解决上述两个问题：向子进程代理发送信号和接管子进程。&lt;/p>
&lt;p>默认情况下，dumb-init 会向子进程的进程组发送其收到的信号。原因也很简单，前面已经提到过，像 bash 这样的应用，自己接收到信号之后，不会向子进程发送信号。当然，dumb-init 也可以通过设置环境变量&lt;code>DUMB_INIT_SETSID=0&lt;/code>来控制只向它的直接子进程发送信号。&lt;/p>
&lt;p>另外 dumb-init 也会接管失去父进程的进程，确保其能正常退出。&lt;/p>
&lt;h2 id="安装">安装&lt;/h2>
&lt;ul>
&lt;li>Alpine 镜像的 APK 可以直接安装
&lt;code>FROM alpine:3.11.5 RUN sed -i &amp;quot;s/dl-cdn.alpinelinux.org/mirrors.aliyun.com/g&amp;quot; /etc/apk/repositories \ &amp;amp;&amp;amp; apk add --no-cache dumb-init ENTRYPOINT [&amp;quot;dumb-init&amp;quot;, &amp;quot;--&amp;quot;] CMD [&amp;quot;/usr/local/bin/docker-entrypoint.sh&amp;quot;]&lt;/code>&lt;/li>
&lt;li>二进制安装
&lt;code>RUN version=v1.2.2 &amp;amp;&amp;amp; \ wget -O /usr/local/bin/dumb-init https://github.com/Yelp/dumb-init/releases/download/$version/dumb-init_$version_amd64 &amp;amp;&amp;amp; \ chmod +x /usr/local/bin/dumb-init&lt;/code>&lt;/li>
&lt;li>DEB/RPM 安装
&lt;code>RUN version=v1.2.2 &amp;amp;&amp;amp; \&amp;lt;br /&amp;gt;wget [https://github.com/Yelp/dumb-init/releases/download/](https://github.com/Yelp/dumb-init/releases/download/)![](https://g.yuque.com/gr/latex?version%2Fdumb-init_#card=math&amp;amp;code=version%2Fdumb-init_&amp;amp;id=aIRwW)version_amd64.deb | dpkg -i&amp;lt;br /&amp;gt;apt-get instal dumb-init&amp;lt;br /&amp;gt;&lt;/code>&lt;/li>
&lt;li>pip 安装
&lt;code>pip install dumb-init&lt;/code>&lt;/li>
&lt;/ul>
&lt;p>Github：&lt;a href="https://github.com/krallin/tini">https://github.com/krallin/tini&lt;/a>&lt;/p>
&lt;h2 id="安装-1">安装&lt;/h2>
&lt;p>Alpine 镜像的 APK 可以直接安装&lt;/p>
&lt;p>`FROM alpine:3.11.5
RUN sed -i &amp;ldquo;s/dl-cdn.alpinelinux.org/mirrors.aliyun.com/g&amp;rdquo; /etc/apk/repositories &amp;lt;br /&amp;gt;&amp;amp;&amp;amp; apk add &amp;ndash;no-cache tini&lt;/p>
&lt;p>ENTRYPOINT [&amp;ldquo;tini&amp;rdquo;, &amp;ldquo;&amp;ndash;&amp;rdquo;]
CMD [&amp;quot;/your/program&amp;rdquo;, &amp;ldquo;-and&amp;rdquo;, &amp;ldquo;-its&amp;rdquo;, &amp;ldquo;arguments&amp;rdquo;]&lt;/p>
&lt;p>`&lt;/p>
&lt;h2 id="1php-fpm-进程的接管">1、php-fpm 进程的接管&lt;/h2>
&lt;p>针对 php 应用，通常采用&lt;code>nginx+php-fpm&lt;/code>的架构来处理请求。为了保证 php-fpm 进程出现意外故障能够自动恢复，通常使用 supervisor 进程管理工具进行守护。php-fpm 的进程管理类也类似于 nginx，由 master，worker 进程组成。master 进程不处理请求，而是由 worker 进程处理！master 进程只负责管理 worker 进程。&lt;/p>
&lt;p>master 进程负责监听子进程的状态，子进程挂掉之后，会发信号给 master 进程，然后 master 进程重新启一个新的 worker 进程。&lt;/p>
&lt;p>&lt;code>进程号 父进程号 进程 21 10 master 22 21 |----worker1 23 21 |----worker2&lt;/code>&lt;/p>
&lt;p>使用 Supervisor 启动、守护 php-fpm 进程时的进程树&lt;/p>
&lt;p>`进程号 父进程号 进程
10    9       supervisor
21 10 |&amp;mdash;master
22 21 |&amp;mdash;-worker1
23 21 |&amp;mdash;-worker2&lt;/p>
&lt;h1 id="使用-supervisor-启动守护的是-php-fpm-的-master-进程然后-master-进程再根据配置启动对应数量的-worker-进程">使用 supervisor 启动、守护的是 php-fpm 的 master 进程，然后 master 进程再根据配置启动对应数量的 worker 进程。&lt;/h1>
&lt;p>`&lt;/p>
&lt;p>当 php-fpm 的 master 进程意外退出后的进程树&lt;/p>
&lt;p>`进程号 父进程号 进程
10    9       supervisor
22 1  worker1
23 1  worker2&lt;/p>
&lt;h1 id="此时-worker-进程成为僵尸进程被-1-号进程接管">此时 worker 进程成为僵尸进程，被 1 号进程接管&lt;/h1>
&lt;p>`&lt;/p>
&lt;p>此时 supervisor 检测到 php-fpm master 进程不存在就会在重新创建一个新的 php-fpm master 进程。但是会因为原先的 php-fpm worker 没有被杀掉，成为僵尸进程、依旧占用着端口而失败。本以为 php-fpm 会&lt;/p>
&lt;ol>
&lt;li>&lt;a href="https://www.infoq.cn/article/2016/01/dumb-init-Docker">https://www.infoq.cn/article/2016/01/dumb-init-Docker&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://blog.phusion.nl/2015/01/20/docker-and-the-pid-1-zombie-reaping-problem/">https://blog.phusion.nl/2015/01/20/docker-and-the-pid-1-zombie-reaping-problem/&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://medium.com/@gchudnov/trapping-signals-in-docker-containers-7a57fdda7d86">https://medium.com/@gchudnov/trapping-signals-in-docker-containers-7a57fdda7d86&lt;/a>&lt;/li>
&lt;/ol>
&lt;blockquote>
&lt;p>原文出处：&lt;a href="https://gitbook.curiouser.top/origin/docker-process-manager.html">https://gitbook.curiouser.top/origin/docker-process-manager.html&lt;/a>&lt;/p>
&lt;/blockquote></description></item><item><title>Docs: 性能优化与故障处理</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/10.%E4%BA%91%E5%8E%9F%E7%94%9F/2.2.%E5%AE%9E%E7%8E%B0%E5%AE%B9%E5%99%A8%E7%9A%84%E5%B7%A5%E5%85%B7/%E5%AE%B9%E5%99%A8%E7%AE%A1%E7%90%86/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E4%B8%8E%E6%95%85%E9%9A%9C%E5%A4%84%E7%90%86/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/10.%E4%BA%91%E5%8E%9F%E7%94%9F/2.2.%E5%AE%9E%E7%8E%B0%E5%AE%B9%E5%99%A8%E7%9A%84%E5%B7%A5%E5%85%B7/%E5%AE%B9%E5%99%A8%E7%AE%A1%E7%90%86/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E4%B8%8E%E6%95%85%E9%9A%9C%E5%A4%84%E7%90%86/</guid><description>
&lt;h1 id="容器无法启动时如何排查">容器无法启动时，如何排查&lt;/h1>
&lt;p>场景：有些时候我们用一个官方的容器直接启动，会报错，或者说效果不是我们想要的，我们大概知道如何排查，比如改改容器里面的配置文件，重新启动什么的，那么问题来了，容器起不来我怎么进去？&lt;/p>
&lt;p>如下实例，启动一个 consul 容器报错&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">[&lt;/span>root@10-222-32-122 ~&lt;span style="color:#f92672">]&lt;/span>&lt;span style="color:#75715e"># docker run -d --name=consul --net=host gliderlabs/consul-server -bootstrap&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">[&lt;/span>root@10-222-32-122 ~&lt;span style="color:#f92672">]&lt;/span>&lt;span style="color:#75715e"># docker ps -a --no-trunc&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>88f8ca844420937fc57c7f46b3b99222a7fdd47591e8a14da34c4110fe3f5c29 gliderlabs/consul-server &lt;span style="color:#e6db74">&amp;#34;/bin/consul agent -server -config-dir=/config -bootstrap&amp;#34;&lt;/span> &lt;span style="color:#ae81ff">3&lt;/span> minutes ago Exited &lt;span style="color:#f92672">(&lt;/span>1&lt;span style="color:#f92672">)&lt;/span> &lt;span style="color:#ae81ff">3&lt;/span> minutes ago consul
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">[&lt;/span>root@10-222-32-122 ~&lt;span style="color:#f92672">]&lt;/span>&lt;span style="color:#75715e"># docker logs consul&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">==&lt;/span>&amp;gt; WARNING: Bootstrap mode enabled! Do not enable unless necessary
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">==&lt;/span>&amp;gt; Starting Consul agent...
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">==&lt;/span>&amp;gt; Error starting agent: Failed to get advertise address: Multiple private IPs found. Please configure one.
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">[&lt;/span>root@10-222-32-122 ~&lt;span style="color:#f92672">]&lt;/span>&lt;span style="color:#75715e"># hostname -I&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>10.222.32.122 172.17.0.1
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>我们可以通过下面的方法，让容器先夯住，让后进入容器调试&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">[&lt;/span>root@10-222-32-122 ~&lt;span style="color:#f92672">]&lt;/span>&lt;span style="color:#75715e"># docker rm -fv consul&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">[&lt;/span>root@10-222-32-122 ~&lt;span style="color:#f92672">]&lt;/span>&lt;span style="color:#75715e"># docker run --rm --entrypoint &amp;#34;ls&amp;#34; --name=consul --net=host gliderlabs/consul-server /config&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>agent.json
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>server.json
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">[&lt;/span>root@10-222-32-122 ~&lt;span style="color:#f92672">]&lt;/span>&lt;span style="color:#75715e"># docker run -d --entrypoint tail --name=consul --net=host gliderlabs/consul-server -F /tmp/tmp.txt&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">[&lt;/span>root@10-222-32-122 ~&lt;span style="color:#f92672">]&lt;/span>&lt;span style="color:#75715e"># docker exec -it consul sh&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h1 id="docker-比较不错的-image-推荐">docker 比较不错的 image 推荐&lt;/h1>
&lt;p>&lt;a href="https://hub.docker.com/r/polinux/stress/">https://hub.docker.com/r/polinux/stress/&lt;/a> #一个非常好用的压测容器，可以对容器指定其所使用的内存和 cpu 等资源的大小。当创建完资源配合等资源限制的对象后，可以通过该容器来测试资源限制是否生效。&lt;/p>
&lt;p>使用示例如下：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>docker run &lt;span style="color:#ae81ff">\
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">&lt;/span> -ti &lt;span style="color:#ae81ff">\
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">&lt;/span> --rm &lt;span style="color:#ae81ff">\
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">&lt;/span> polinux/stress stress &lt;span style="color:#ae81ff">\
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">&lt;/span> --cpu &lt;span style="color:#ae81ff">1&lt;/span> &lt;span style="color:#ae81ff">\
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">&lt;/span> --io &lt;span style="color:#ae81ff">1&lt;/span> &lt;span style="color:#ae81ff">\
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">&lt;/span> --vm &lt;span style="color:#ae81ff">1&lt;/span> &lt;span style="color:#ae81ff">\
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">&lt;/span> --vm-bytes 128M &lt;span style="color:#ae81ff">\
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">&lt;/span> --timeout 1s &lt;span style="color:#ae81ff">\
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">&lt;/span> --verbose
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;a href="https://hub.docker.com/r/containous/whoami">https://hub.docker.com/r/containous/whoami&lt;/a> #一个 go 语言编写的 web 服务器，当请求该容器时，可以输出操作系统信息和 HTTP 请求等，信息如下所示：包括当前容器的 ip 地址，容器的主机名等等&lt;/p>
&lt;h1 id="如何运行一个容器并启动-bash">如何运行一个容器并启动 bash&lt;/h1>
&lt;p>由于容器中的进行执行完成后就会自动退出，所以每次 docker run 之后，有一部分容器无法持久运行，比如 centos 镜像，这时候可以使用下面的方式让容器镜像持续输出任意内容而不会因进程完成而自动退出了&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>docker create -it -d --name test centos:latest &lt;span style="color:#f92672">&amp;amp;&amp;amp;&lt;/span> docker start test
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h1 id="通过-host-的-veth-设备查找对端-container-的-ip">通过 host 的 veth 设备查找对端 container 的 ip&lt;/h1>
&lt;p>for i in &lt;code>docker ps -q&lt;/code>; do pid=$(docker inspect &amp;ndash;format &amp;lsquo;{{.State.Pid}}&amp;rsquo; $i); nsenter -t $pid &amp;ndash;net ip addr | grep -A 2 if40; done&lt;/p>
&lt;p>注意命令中 grep 筛选的 if40 中的 40 是宿主机上查到的 veth 设备的序号，通过 ip link show 即可获得设备需要，&lt;strong>在屏幕最左侧&lt;/strong>。而 if40 则是容器网络设备所关联对端网络设备名称。下面示例可以看到，155 对应 if155，if154 对应 154&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># 宿主机网络设备信息&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">[&lt;/span>root@lichenhao ~&lt;span style="color:#f92672">]&lt;/span>&lt;span style="color:#75715e"># ip a&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>....
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>155: veth74d05e8@if154: &amp;lt;BROADCAST,MULTICAST,UP,LOWER_UP&amp;gt; mtu &lt;span style="color:#ae81ff">1500&lt;/span> qdisc noqueue master docker0 state UP group default
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> link/ether 0a:9e:19:c3:98:b7 brd ff:ff:ff:ff:ff:ff link-netnsid &lt;span style="color:#ae81ff">0&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> inet6 fe80::89e:19ff:fec3:98b7/64 scope link
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> valid_lft forever preferred_lft forever
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># 容器内网络设备信息&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">[&lt;/span>root@lichenhao network-scripts&lt;span style="color:#f92672">]&lt;/span>&lt;span style="color:#75715e"># nsenter -n -t 3039&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">[&lt;/span>root@lichenhao network-scripts&lt;span style="color:#f92672">]&lt;/span>&lt;span style="color:#75715e"># ip a&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>....
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>154: eth0@if155: &amp;lt;BROADCAST,MULTICAST,UP,LOWER_UP&amp;gt; mtu &lt;span style="color:#ae81ff">1500&lt;/span> qdisc noqueue state UP group default
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> link/ether 02:42:ac:11:00:02 brd ff:ff:ff:ff:ff:ff link-netnsid &lt;span style="color:#ae81ff">0&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> inet 172.17.0.2/16 brd 172.17.255.255 scope global eth0
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> valid_lft forever preferred_lft forever
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h1 id="通过各种系统信息查找目标容器">通过各种系统信息查找目标容器&lt;/h1>
&lt;p>在管理 Kubernetes 集群的过程中，我们经常会遇到这样一种情况：在某台节点上发现某个进程资源占用量很高，却又不知道是哪个容器里的进程。有没有办法可以根据 PID 快速找到 Pod 名称呢？&lt;/p>
&lt;p>要获取容器的 ID，通过在 PID 对应的 cgroup 信息中即可查到(比如进程号 32000 的 cgroup 信息在 /proc/32000/cgroup 文件中。该文件内容每行的最后一个段落就是 容器的 ID。)&lt;/p>
&lt;h2 id="通过-pid-查找容器">通过 PID 查找容器&lt;/h2>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#!/bin/bash
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>pid&lt;span style="color:#f92672">=&lt;/span>$1
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>CID&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">`&lt;/span>cat /proc/&lt;span style="color:#e6db74">${&lt;/span>pid&lt;span style="color:#e6db74">}&lt;/span>/cgroup | head -1 | awk -F &lt;span style="color:#e6db74">&amp;#39;/&amp;#39;&lt;/span> &lt;span style="color:#e6db74">&amp;#39;{print $5}&amp;#39;&lt;/span>&lt;span style="color:#e6db74">`&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>CID&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#66d9ef">$(&lt;/span>echo &lt;span style="color:#e6db74">${&lt;/span>CID:7:15&lt;span style="color:#e6db74">}&lt;/span>&lt;span style="color:#66d9ef">)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>sudo docker inspect $CID | jq &lt;span style="color:#e6db74">&amp;#39;.[0].Config.Labels.&amp;#34;io.kubernetes.pod.name&amp;#34;&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>而想要反查，那么通过 docker top CONTAINER 命令即可直接获取改容器的 PID&lt;/p>
&lt;h2 id="通过-mount-信息查找目标容器">通过 mount 信息查找目标容器&lt;/h2>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/ou0feg/1635215387580-a2da5aed-f711-4313-8977-86137662f7fd.png" alt="image.png">
通过 mount 信息中的 layer 信息中的 cacheID，去 layer 的元数据目录中筛选包含该 cacheID 的文件&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">[&lt;/span>root@lichenhao mounts&lt;span style="color:#f92672">]&lt;/span>&lt;span style="color:#75715e"># pwd&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>/var/lib/docker/image/overlay2/layerdb/mounts
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">[&lt;/span>root@lichenhao mounts&lt;span style="color:#f92672">]&lt;/span>&lt;span style="color:#75715e"># grep -r d976eddf7575a3464486d92539229146f3df66080a3265195791ebb0d24b24dd ./&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>./mounts/28f5bed704dc80bed6dbaa8af514d2191d8d4ab0339bb3a663e66609ccd34c10/mount-id:d976eddf7575a3464486d92539229146f3df66080a3265195791ebb0d24b24dd
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>./mounts/28f5bed704dc80bed6dbaa8af514d2191d8d4ab0339bb3a663e66609ccd34c10/init-id:d976eddf7575a3464486d92539229146f3df66080a3265195791ebb0d24b24dd-init
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>可以看到该 layer 所属的 ContainerID 为 28f5bed704dc80bed6dbaa8af514d2191d8d4ab0339bb3a663e66609ccd34c10&lt;/p>
&lt;p>这时候通过 docker ps 命令，筛选 ID 前几位，就可以找到该容器了&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">[&lt;/span>root@lichenhao layerdb&lt;span style="color:#f92672">]&lt;/span>&lt;span style="color:#75715e"># docker ps --all | grep 28f5bed704&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>28f5bed704dc ubuntu:latest &lt;span style="color:#e6db74">&amp;#34;/bin/bash&amp;#34;&lt;/span> &lt;span style="color:#ae81ff">2&lt;/span> hours ago Up &lt;span style="color:#ae81ff">4&lt;/span> minutes docker_runtime_test
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="通过-netns-信息查找容器">通过 netns 信息查找容器&lt;/h2>
&lt;p>failed to get sandbox ip: check network namespace closed: remove netns: unlinkat /var/run/netns/XXXXXX: device or resource busy。参考：&lt;a href="https://github.com/containerd/containerd/issues/3667">https://github.com/containerd/containerd/issues/3667&lt;/a>&lt;/p>
&lt;p>有时候 pod 在删除时，会卡在 terminating 状态，并在日志中显示无法删除某个 /var/run/netns/ 目录下的 netns，根据这个 netns 的名称，可以找到容器&lt;/p>
&lt;p>grep -l XXX /proc/*/mountinfo # 该命令会显示正在使用 XXX 这个 netns 的进程。然后根据进程号找到容器，重启它即可。&lt;/p>
&lt;h1 id="docker-容器时间与宿主机同步">Docker 容器时间与宿主机同步&lt;/h1>
&lt;p>在我们平时使用 docker，运行我们的应用的时候，访问应用页面的时间与现在相差 8 个小时。无法结合时间点去判断当时服务的异常。同样，当我们在 docker 上运行某些服务时，需要时间与宿主机同步，否则会发生异常&lt;/p>
&lt;p>为了保证容器和宿主机之间的时间同步，可以使用以下几种办法：&lt;/p>
&lt;h2 id="1docker-run">1.Docker run&lt;/h2>
&lt;p>使用 docker run 运行容器时，添加参数 &lt;code>-v /etc/localtime:/etc/localtime:ro&lt;/code>&lt;/p>
&lt;h2 id="2dockerfile">2.DockerFile&lt;/h2>
&lt;p>在 Docker File 中添加如下参数：将时区配置添加到环境变量，并使用软连接，并将时区配置文件覆盖&lt;/p>
&lt;blockquote>
&lt;p>注意：需要保证所使用的基础镜像具有 tzdata 包，否则不会加载 /etc/localtime 文件以更新时区&lt;/p>
&lt;/blockquote>
&lt;pre>&lt;code>RUN apk add --no-caceh tzdata
ENV TimeZone=Asia/Shanghai
RUN ln -snf /usr/share/zoneinfo/$TimeZone /etc/localtime &amp;amp;&amp;amp; echo $TimeZone &amp;gt;/etc/timezone
&lt;/code>&lt;/pre>
&lt;p>实例 DockerFile 如下：&lt;/p>
&lt;blockquote>
&lt;p>设置变量与创建软链接这两个方法任选其一即可&lt;/p>
&lt;/blockquote>
&lt;pre>&lt;code>FROM alpine # Centos 基础镜像
RUN apk add --no-caceh tzdata
ENV TimeZone=Asia/Shanghai # 添加时区环境变量，亚洲，上海
RUN ln -snf /usr/share/zoneinfo/$TimeZone /etc/localtime &amp;amp;&amp;amp; echo $TimeZone &amp;gt;/etc/timezone # 使用软连接，并且将时区配置覆盖/etc/timezone
&lt;/code>&lt;/pre>
&lt;p>构建镜像&lt;/p>
&lt;pre>&lt;code>docker build -t alpine:time .
&lt;/code>&lt;/pre>
&lt;p>正在运行的容器，时间如何同步？&lt;/p>
&lt;p>这种方式同样适用于，构造镜像完成后，时间不同步的状况&lt;/p>
&lt;blockquote>
&lt;p>但是，同样需要保证容器中具有 tzdata 包&lt;/p>
&lt;/blockquote>
&lt;p>在宿主机执行命令如下：&lt;/p>
&lt;pre>&lt;code> docker cp /usr/share/zoneinfo/Asia/Shanghai &amp;lt;容器名&amp;gt;:/etc/localtime
&lt;/code>&lt;/pre></description></item><item><title>Docs: 性能优化与故障处理</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/10.%E4%BA%91%E5%8E%9F%E7%94%9F/2.2.%E5%AE%9E%E7%8E%B0%E5%AE%B9%E5%99%A8%E7%9A%84%E5%B7%A5%E5%85%B7/%E5%AE%B9%E5%99%A8%E7%AE%A1%E7%90%86/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E4%B8%8E%E6%95%85%E9%9A%9C%E5%A4%84%E7%90%86/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/10.%E4%BA%91%E5%8E%9F%E7%94%9F/2.2.%E5%AE%9E%E7%8E%B0%E5%AE%B9%E5%99%A8%E7%9A%84%E5%B7%A5%E5%85%B7/%E5%AE%B9%E5%99%A8%E7%AE%A1%E7%90%86/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E4%B8%8E%E6%95%85%E9%9A%9C%E5%A4%84%E7%90%86/</guid><description/></item></channel></rss>