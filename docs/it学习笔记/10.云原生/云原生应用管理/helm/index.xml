<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>断念梦 – Helm</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/10.%E4%BA%91%E5%8E%9F%E7%94%9F/%E4%BA%91%E5%8E%9F%E7%94%9F%E5%BA%94%E7%94%A8%E7%AE%A1%E7%90%86/helm/</link><description>Recent content in Helm on 断念梦</description><generator>Hugo -- gohugo.io</generator><atom:link href="https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/10.%E4%BA%91%E5%8E%9F%E7%94%9F/%E4%BA%91%E5%8E%9F%E7%94%9F%E5%BA%94%E7%94%A8%E7%AE%A1%E7%90%86/helm/index.xml" rel="self" type="application/rss+xml"/><item><title>Docs: Charts</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/10.%E4%BA%91%E5%8E%9F%E7%94%9F/%E4%BA%91%E5%8E%9F%E7%94%9F%E5%BA%94%E7%94%A8%E7%AE%A1%E7%90%86/helm/charts/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/10.%E4%BA%91%E5%8E%9F%E7%94%9F/%E4%BA%91%E5%8E%9F%E7%94%9F%E5%BA%94%E7%94%A8%E7%AE%A1%E7%90%86/helm/charts/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://helm.sh/docs/topics/charts/">官方文档，主题-charts&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>Helm 管理的安装包称为 &lt;strong>Charts(图表)&lt;/strong>。就好比 Cento 的安装包是 rpm、Windows 的安装包是 exe、Ubuntu 的安装包是 deb。&lt;/p>
&lt;p>Charts 是描述 Kubernete 资源的一组 manifests 集合，被有规则得放在特定的目录树中。这些 Charts 可以打包成 &lt;strong>archives&lt;/strong>。&lt;/p>
&lt;p>Chart 也有&lt;strong>海图&lt;/strong>的概念，就好像 Helm 代表舵柄一样，当人们手握 Helm 在大海中航行时，可以查看 Charts，来观察地图，以便决定我们如何航行。&lt;/p>
&lt;h1 id="chart-file-structure图表文件结构">Chart File Structure(图表文件结构)&lt;/h1>
&lt;blockquote>
&lt;p>官方文档：&lt;a href="https://helm.sh/docs/topics/charts/">&lt;strong>https://helm.sh/docs/topics/charts/&lt;/strong>&lt;/a>&lt;/p>
&lt;/blockquote>
&lt;p>一个 Chart 保存在一个目录中，目录名就是 Chart 的名称(没有版本信息)。比如 myapp 这个 chart 就放在 ./mapp/ 这个目录中&lt;/p>
&lt;p>在这个目录中，一般由以下内容组成：&lt;/p>
&lt;blockquote>
&lt;p>带有 OPTIONAL 表示不是必须的，可选的内容就算不存在，该 chart 也可正常使用&lt;/p>
&lt;/blockquote>
&lt;ul>
&lt;li>&lt;strong>Chart.yaml&lt;/strong> # 用来做 Chart 的初始化的文件，记录该 Chart 的名称、版本、维护者等元数据信息&lt;/li>
&lt;li>&lt;strong>LICENSE&lt;/strong> # (OPTIONAL)一个 chart 许可证的纯文本文件。&lt;/li>
&lt;li>&lt;strong>README.md&lt;/strong> # (OPTIONAL)一个易于阅读的自述文件。&lt;/li>
&lt;li>&lt;strong>values.yaml&lt;/strong> # 用于给 templates 目录下的各个 manifests 模板设定默认值。values.yaml 文件的说明详见 &lt;a href="https://www.teambition.com/project/5f90e312755d8a00446050eb/app/5eba5fba6a92214d420a3219/workspaces/5f90e312c800160016ea22fb/docs/5f9a633937398300016bed65?scroll-to-block=5f9a6348246f30cbbdf35c5a">&lt;strong>Helm Template 章节&lt;/strong>&lt;/a>&lt;/li>
&lt;li>&lt;strong>values.yaml.json&lt;/strong> # (OPTIONAL)用于在 values.yaml 文件上强加结构的 JSON 模式&lt;/li>
&lt;li>&lt;strong>charts/&lt;/strong> # (OPTIONAL)包含该 Chart 所依赖的其他 Chart (这种被依赖的其他 Chart 称为 &lt;a href="https://thoughts.teambition.com/workspaces/603b04c9f83f2a00428f7321/docs/5fae78274cc5830001b9bbd6?scroll-to-block=6040f2c3a4b1ca00462d7837">&lt;strong>Subcharts 子图表&lt;/strong>&lt;/a>)。&lt;/li>
&lt;li>&lt;strong>crds/&lt;/strong> # (OPTIONAL)CRD 文件。该目录下的资源将会首先创建，其他资源等待 crds 资源 running 后，再创建。&lt;/li>
&lt;li>&lt;strong>templates/&lt;/strong> # 模板目录，与 values.yaml 相结合将生成有效的 kubernetes manifest 文件。
&lt;ul>
&lt;li>该目录下包含支撑 chart 的 manifests 文件，是各种 yaml 文件，只不过这些 yaml 文件是以模板形式存在的。&lt;/li>
&lt;li>&lt;a href="https://www.teambition.com/project/5f90e312755d8a00446050eb/app/5eba5fba6a92214d420a3219/workspaces/5f90e312c800160016ea22fb/docs/5f9a633937398300016bed65">&lt;strong>模板详解见此处&lt;/strong>&lt;/a>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>templates/NOTES.txt&lt;/strong> # (OPTIONAL)生成 release 后给用户的提示信息&lt;/li>
&lt;li>&lt;strong>ci/&lt;/strong> # 存放自定义的 values.yaml。这是非官方推荐的目录，只不过大家都这么用。&lt;/li>
&lt;/ul>
&lt;p>当使用 helm create mychart 命令创建一个本地 chart 目录是，helm 会默认自动生成下列信息：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">[&lt;/span>root@master helm&lt;span style="color:#f92672">]&lt;/span>&lt;span style="color:#75715e"># helm create mychart&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Creating mychart
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">[&lt;/span>root@master helm&lt;span style="color:#f92672">]&lt;/span>&lt;span style="color:#75715e"># tree mychart/&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>mychart/
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>├── charts
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>├── Chart.yaml
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>├── templates
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>│ ├── deployment.yaml
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>│ ├── _helpers.tpl
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>│ ├── hpa.yaml
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>│ ├── ingress.yaml
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>│ ├── NOTES.txt
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>│ ├── serviceaccount.yaml
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>│ ├── service.yaml.
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>│ └── tests
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>│ └── test-connection.yaml
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>└── values.yaml
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h1 id="chartyaml-文件">Chart.yaml 文件&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;a href="https://helm.sh/docs/topics/charts/#the-chartyaml-file">&lt;strong>官方文档&lt;/strong>&lt;/a>&lt;/p>
&lt;/blockquote>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-yaml" data-lang="yaml">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">apiVersion&lt;/span>: &lt;span style="color:#75715e"># (必须的)Chart 的 API 版本，有 v1、v2&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">name&lt;/span>: &lt;span style="color:#75715e"># (必须的)Chart 的名字&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">version&lt;/span>: &lt;span style="color:#75715e"># (必须的)Chart 的版本号，必须符合 SemVer2 标准。&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">kubeVersion&lt;/span>: &lt;span style="color:#75715e"># (可选的)Chart 兼容的 Kubernetes 版本号，必须符合 SemVer 标准。&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">description&lt;/span>: &lt;span style="color:#75715e"># (可选的)Chart 的简要描述&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">type&lt;/span>: &lt;span style="color:#ae81ff">(可选的)The type of the chart&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">keywords&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#ae81ff">(可选的)A list of keywords about this project&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">home&lt;/span>: &lt;span style="color:#ae81ff">(可选的)The URL of this projects home page&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">sources&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#ae81ff">(可选的)A list of URLs to source code for this project&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">dependencies&lt;/span>: &lt;span style="color:#75715e"># (可选的)Chart 所依赖的其他 Charts 列表。也就是 SubCharts&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#f92672">name&lt;/span>: &lt;span style="color:#75715e"># SubChart 的名字&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">version&lt;/span>: &lt;span style="color:#75715e"># SubChart 的版本号&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">repository&lt;/span>: &lt;span style="color:#75715e"># The repository URL (&amp;#34;https://example.com/charts&amp;#34;) or alias (&amp;#34;@repo-name&amp;#34;)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">condition&lt;/span>: &lt;span style="color:#75715e"># (可选的)根据条件控制这个 Chart 是否与上层 Chart 一起被安装。这个条件可以在 values.yaml 中定义(e.g. subchart1.enabled )&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">tags&lt;/span>: &lt;span style="color:#75715e"># (可选的)该字段可以用来将 SubCharts 分组，以便统一启用或禁用&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#ae81ff">XXXXX&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">enabled&lt;/span>: &lt;span style="color:#75715e"># (可选的)控制这个 Chart 是否与上层 Chart 一起被安装&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">import-values&lt;/span>: &lt;span style="color:#75715e"># (可选的)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#ae81ff">ImportValues holds the mapping of source values to parent key to be imported. Each item can be a string or pair of child/parent sublist items.&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">alias&lt;/span>: &lt;span style="color:#ae81ff">(可选的) Alias to be used for the chart. Useful when you have to add the same chart multiple times&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">maintainers&lt;/span>: &lt;span style="color:#75715e"># (可选的)Chart 维护者的信息。&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#f92672">name&lt;/span>: &lt;span style="color:#ae81ff">The maintainers name (required for each maintainer)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">email&lt;/span>: &lt;span style="color:#ae81ff">The maintainers email (optional for each maintainer)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">url&lt;/span>: &lt;span style="color:#ae81ff">A URL for the maintainer (optional for each maintainer)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">icon&lt;/span>: &lt;span style="color:#75715e"># (可选的)Chart 的 Logo，值必须是 URL。需要 helm 自动从 URL 中获取图片&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">appVersion&lt;/span>: &lt;span style="color:#75715e"># (可选的)Chart 中包含的应用程序的版本。&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">deprecated&lt;/span>: &lt;span style="color:#75715e"># (可选的)标识该图表是否已弃用。可用的值是 true 和 false&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">annotations&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">example&lt;/span>: &lt;span style="color:#ae81ff">(可选的)A list of annotations keyed by name.&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="各种-version-字段">各种 version 字段&lt;/h2>
&lt;h3 id="apiversion">apiVersion&lt;/h3>
&lt;p>这个其实就像 kubernetes 中的 apiVersion 概念，用来定义如何解析 Charts 文件的。不同的版本，Charts 中包含的内容不同，Chart.yaml 文件中的字段也不同。&lt;/p>
&lt;h3 id="version">version&lt;/h3>
&lt;p>这个就是 Chart 本身的版本。只不过这个版本号的格式必须符合 &lt;a href="https://semver.org/">&lt;strong>SemVer2&lt;/strong>&lt;/a>。&lt;/p>
&lt;p>SemVer2 格式大体是这样的：&lt;code>X.Y.Z&lt;/code>&lt;/p>
&lt;h3 id="kubeversion">kubeVersion&lt;/h3>
&lt;p>待整理&lt;/p>
&lt;h3 id="appversion">appVersion&lt;/h3>
&lt;p>用来定义 Chart 中包含的应用程序的版本，如果有多个应用程序，就自己选择用哪个，版本号格式随意。&lt;/p>
&lt;h2 id="dependencies-字段">dependencies 字段&lt;/h2>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://helm.sh/zh/docs/topics/charts/#chart-dependency">官方文档，主题-charts-chart 依赖&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>Helm 中，Chart 可以依赖其他任意数量的 Chart，这些可以被依赖的 Chart 可以通过 Chart.yaml 文件中的 dependencies 字段来控制。&lt;/p>
&lt;ul>
&lt;li>&lt;strong>name: STRING&lt;/strong> # SubChart 的名字&lt;/li>
&lt;li>&lt;strong>version: STRING&lt;/strong> # SubChart 的版本号&lt;/li>
&lt;li>&lt;strong>repository: STRING&lt;/strong> # The repository URL (&amp;ldquo;&lt;a href="https://example.com/charts%22">https://example.com/charts&amp;quot;&lt;/a>) or alias (&amp;quot;@repo-name&amp;rdquo;)&lt;/li>
&lt;li>&lt;strong>condition: STRING&lt;/strong> # (可选的)根据条件控制这个 Chart 是否与上层 Chart 一起被安装。这个条件可以在 values.yaml 中定义(e.g. subchart1.enabled)
&lt;ul>
&lt;li>该字段非常重要与常见，假如我们定义 condition：&lt;code>condition: abc.enabled&lt;/code>&lt;/li>
&lt;li>然后我们可以在父 Chart 的 values.yaml 中定义字段 &lt;code>abc.enabled&lt;/code>，若 &lt;code>abc.enabled&lt;/code> 为 true 则该 Chart 将会与 父 Chart 一起被安装。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>tags: []STRING&lt;/strong> # (可选的)该字段可以用来将 SubCharts 分组，以便统一启用或禁用&lt;/li>
&lt;li>&lt;strong>enabled: true|false&lt;/strong> # (可选的)控制这个 Chart 是否与上层 Chart 一起被安装&lt;/li>
&lt;li>&lt;strong>import-values: []&lt;/strong> # (可选的)ImportValues holds the mapping of source values to parent key to be imported. Each item can be a string or pair of child/parent sublist items.&lt;/li>
&lt;li>&lt;strong>alias: STRING&lt;/strong> # (可选的)为该 Chart 起一个别名。若一个 Chart 需要被多次依赖时非常有用&lt;/li>
&lt;/ul>
&lt;h3 id="为什么需要-chart-dependencies">为什么需要 Chart Dependencies&lt;/h3>
&lt;blockquote>
&lt;p>首先需要明确一点，官方用 Dependencies 这个词不太准确，用 &lt;strong>SubCharts(子图表)&lt;/strong> 这个词更准确，因为依赖不是绝对的。&lt;/p>
&lt;/blockquote>
&lt;p>比如我想安装三个 Chart，分别为 A、B、C，如果要逐一安装是非常麻烦也不便于管理的，所以，我们需要把这些 Charts 整合起来，而整合的前提是，必须要存在一个 Chart。所以，我们可以这么做&lt;/p>
&lt;ul>
&lt;li>&lt;code>helm create mychart&lt;/code> 首先创建一个 Chart&lt;/li>
&lt;li>&lt;code>cd mychart/charts&lt;/code> 进入刚创建的 Chart 目录，逐一创建其他 Chart。&lt;code>for i in A B C; do helm create subchart${i}; done&lt;/code>&lt;/li>
&lt;/ul>
&lt;p>此时该 Chart 目录结构如下&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>root@lichenhao:~/testDir# tree -L &lt;span style="color:#ae81ff">2&lt;/span> mychart/
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>mychart/
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>├── charts
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>│   ├── subchartA
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>│   ├── subchartB
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>│   └── subchartC
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>├── Chart.yaml
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>├── templates
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>│   ├── deployment.yaml
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>│   ├── _helpers.tpl
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>│   ├── hpa.yaml
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>│   ├── ingress.yaml
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>│   ├── NOTES.txt
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>│   ├── serviceaccount.yaml
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>│   ├── service.yaml
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>│   └── tests
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>└── values.yaml
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>这些当我安装 mychart 时，subchartA、subchartB、subchartC 这三个 Charts 也就一起被安装了。&lt;/p>
&lt;p>这时，我又有新的需求了，由于某些原因，我不想 subchartC 跟随 mychart 一起安装，而是根据某些规则来启动。所以，这些 Charts 就可以根据 Chart.yaml 文件中的 &lt;code>dependencies.enabled&lt;/code> 或 &lt;code>dependencies.condition&lt;/code> 字段来控制。&lt;/p>
&lt;p>由于这种不是强依赖的关系，所以用 &lt;strong>SubCharts(子图表)&lt;/strong> 这个词描述这个功能更为准确，而 mychart 这种就称为 &lt;strong>ParentChart(父图表)&lt;/strong>。而跟随父图表一起安装的行为称为 &lt;strong>Enabling(启用图表)&lt;/strong>，反之则称为 &lt;strong>Disabling(禁用图表)&lt;/strong>。&lt;/p>
&lt;h3 id="subcharts-的启用时机">SubCharts 的启用时机&lt;/h3>
&lt;p>SubCharts 与 Charts 关于 values.yaml 文件的使用还有一些注意事项，详见 &lt;a href="https://www.yuque.com/go/doc/33981940">Subcharts 与 Global Values 章节&lt;/a>&lt;/p>
&lt;p>Chart.yaml 文件中的 &lt;code>dependencies.condition&lt;/code> 与 &lt;code>dependencies.tags&lt;/code> 字段可以控制子图表安装的时机。&lt;/p>
&lt;ul>
&lt;li>condition # 该字段包含一个或多个 YAML 路径（用逗号分隔）。 如果这个路径在上层 values 中已存在并解析为布尔值，chart 会基于布尔值启用或禁用 chart。 只会使用列表中找到的第一个有效路径，如果路径为未找到则条件无效。&lt;/li>
&lt;li>tags - 该字段是与 chart 关联的 YAML 格式的标签列表。在顶层 value 中，通过指定 tag 和布尔值，可以启用或禁用所有的带 tag 的 chart。&lt;/li>
&lt;/ul>
&lt;p>假如现在有这么一个 Chart.yaml 文件：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-yaml" data-lang="yaml">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">apiVersion&lt;/span>: &lt;span style="color:#ae81ff">v2&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">name&lt;/span>: &lt;span style="color:#ae81ff">mychart&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">description&lt;/span>: &lt;span style="color:#ae81ff">A Helm chart for Kubernetes&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">type&lt;/span>: &lt;span style="color:#ae81ff">application&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">version&lt;/span>: &lt;span style="color:#ae81ff">0.1.0&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">appVersion&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;1.16.0&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">dependencies&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#f92672">name&lt;/span>: &lt;span style="color:#ae81ff">subchart1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">repository&lt;/span>: &lt;span style="color:#ae81ff">http://localhost:10191&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">version&lt;/span>: &lt;span style="color:#ae81ff">0.1.0&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">condition&lt;/span>: &lt;span style="color:#ae81ff">subchart1.enabled, global.subchart1.enabled&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">tags&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#ae81ff">front-end&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#ae81ff">subchart1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#f92672">name&lt;/span>: &lt;span style="color:#ae81ff">subchart2&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">repository&lt;/span>: &lt;span style="color:#ae81ff">http://localhost:10191&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">version&lt;/span>: &lt;span style="color:#ae81ff">0.1.0&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">condition&lt;/span>: &lt;span style="color:#ae81ff">subchart2.enabled,global.subchart2.enabled&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">tags&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#ae81ff">back-end&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#ae81ff">subchart2&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>下面是 values.yaml 文件&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-yaml" data-lang="yaml">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">subchart1&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">enabled&lt;/span>: &lt;span style="color:#66d9ef">true&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">tags&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">front-end&lt;/span>: &lt;span style="color:#66d9ef">false&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">back-end&lt;/span>: &lt;span style="color:#66d9ef">true&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>在上面的例子中，所有带 &lt;code>front-end&lt;/code>tag 的 chart 都会被禁用，但只要上层的 value 中 &lt;code>subchart1.enabled&lt;/code> 路径被设置为 &amp;rsquo;true&amp;rsquo;，该条件会覆盖 &lt;code>front-end&lt;/code>标签且 &lt;code>subchart1&lt;/code> 会被启用。&lt;/p>
&lt;p>一旦 &lt;code>subchart2&lt;/code>使用了&lt;code>back-end&lt;/code>标签并被设置为了 &lt;code>true&lt;/code>，&lt;code>subchart2&lt;/code>就会被启用。 也要注意尽管&lt;code>subchart2&lt;/code> 指定了一个条件字段， 但是上层 value 没有相应的路径和 value，因此这个条件不会生效。&lt;/p>
&lt;h1 id="crds-目录">crds 目录&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>官方文档：&lt;a href="https://helm.sh/docs/topics/charts/#limitations-on-crds">&lt;strong>https://helm.sh/docs/topics/charts/#limitations-on-crds&lt;/strong>&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>crds 目录下的资源将会在其他资源安装之前，进行安装。并且无法在卸载 release 时，卸载 crds 目录下的资源。&lt;/p>
&lt;p>&lt;strong>crds 目录下的文件不能是模板&lt;/strong>，必须是普通的 YAML 文件。&lt;/p>
&lt;p>当 Helm 安装一个新 Chart 时，首先会安装 crds 目录下的资源，直到 API 服务器可以正常提供 crd，然后再启动模板引擎开始渲染模板，并安装 Chart 中的其余资源。&lt;/p>
&lt;p>由于 CRD 资源属于全局的，不受 namespace 限制，所以 Helm 在管理 CRD 时非常谨慎&lt;/p>
&lt;ul>
&lt;li>更新 Chart 时，无论如何都不会更新 crds 目录下的资源。只有当 crds 目录下的资源不存在时， Helm 才会创建它们&lt;/li>
&lt;li>卸载 Chart 时，不会删除 crds 目录下的资源。也就是说，只要第一次安装 Chart 时，创建了 crds 目录下的资源，则后续都不会&lt;/li>
&lt;li>也就是说，crds 目录下的资源永远不会被删除&lt;/li>
&lt;/ul>
&lt;p>删除 CRD 会自动删除集群中所有命名空间中 CRD 的所有内容。Helm 鼓励想要升级或删除 CRD 的维护人员手动操作，并格外注意&lt;/p>
&lt;h1 id="ci-目录">ci 目录&lt;/h1>
&lt;p>这是一个非官方的目录，我们在使用 Charts 时，经常会需要一些自定义的 values.yaml 文件，大家通常都将这些自定义的值文件放在 Charts 根目录下的 ci 目录中。&lt;/p></description></item><item><title>Docs: Charts</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/10.%E4%BA%91%E5%8E%9F%E7%94%9F/%E4%BA%91%E5%8E%9F%E7%94%9F%E5%BA%94%E7%94%A8%E7%AE%A1%E7%90%86/helm/charts/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/10.%E4%BA%91%E5%8E%9F%E7%94%9F/%E4%BA%91%E5%8E%9F%E7%94%9F%E5%BA%94%E7%94%A8%E7%AE%A1%E7%90%86/helm/charts/</guid><description/></item><item><title>Docs: Helm</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/10.%E4%BA%91%E5%8E%9F%E7%94%9F/%E4%BA%91%E5%8E%9F%E7%94%9F%E5%BA%94%E7%94%A8%E7%AE%A1%E7%90%86/helm/helm/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/10.%E4%BA%91%E5%8E%9F%E7%94%9F/%E4%BA%91%E5%8E%9F%E7%94%9F%E5%BA%94%E7%94%A8%E7%AE%A1%E7%90%86/helm/helm/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://github.com/helm/helm">GitHub 项目，helm/helm&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://helm.sh/docs/">官方文档&lt;/a>&lt;/li>
&lt;li>其他后期发现的文章
&lt;ul>
&lt;li>&lt;a href="https://www.cnblogs.com/liugp/p/16659802.html">https://www.cnblogs.com/liugp/p/16659802.html&lt;/a>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>&lt;strong>Helm&lt;/strong> 是 Kubernetes 的 &lt;strong>Package Manager(包管理器)&lt;/strong>。Kubernetes 在希腊语中，意为舵手或飞行员，是一个蓝色的舵轮图标。所以 Helm 就以类似的概念命名，Helm 称为舵柄，图标与 Kubernetes 类似，寓意把握着 Kubernetes 航行的方向。&lt;/p>
&lt;h2 id="主要概念">主要概念&lt;/h2>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://helm.sh/docs/intro/using_helm/">官方文档，介绍-使用 Helm&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>Helm 与 Kubernetes 的关系，就好比 yum 与 RedHat，apt 与 Ubuntu 一样，是一个 Kubernetes 专用的包管理器，安装专用于 k8s 集群之上的软件包。Helm 使用 Chart 帮助我们管理应用，Chart 就像 RPM 一样，里面描述了应用及其依赖关系。&lt;/p>
&lt;p>&lt;strong>Chart(图表)&lt;/strong> 是由 Helm 管理的应用部署包。Chart 是在一个结构相对固定的目录中，包含用于描述一个应用的一组 manifests 文件。&lt;/p>
&lt;ol>
&lt;li>Chart Archive(图标归档) # 是一个将 Chart 打包成 .tgz 格式的压缩文件。&lt;/li>
&lt;li>实际上，Chart 就是很多 &lt;a href="https://kubernetes.io/docs/reference/glossary/?all=true#term-manifest">&lt;strong>manifests&lt;/strong>&lt;/a> 的集合，里面有一个应用程序所需的 yaml 文件。而对于 kubernetes 来说，所谓的应用程序(软件包)也就是一堆 manifests，每个 manifest 代表一种资源(比如 deployment、service、ingress、configmap 等等)，这些 manifests 组合起来，就构成了一个应用。&lt;/li>
&lt;li>&lt;strong>Chart 包&lt;/strong> 就像 &lt;strong>RPM 包&lt;/strong>一样。这不过没有类似 rpm 的命令，而是直接使用类似 yum 的 helm 命令来管理这些包。并且，Chart 包 也和 RPM 包一样，具有依赖关系。&lt;/li>
&lt;/ol>
&lt;p>&lt;strong>Release(发布)&lt;/strong> 是将 Chart 部署到 Kubernets 集群中运行的实例，每一次 helm install CHART 就会生成一个 Release&lt;/p>
&lt;ol>
&lt;li>Chart 是基础包，通过 config 赋值，生成 release。一般 config 来自于 chart archive 包中的 values.yaml 文件&lt;/li>
&lt;/ol>
&lt;p>chart 与 release 的关系就像 windows 中的 .exe 的安装文件与安装完成后在添加删除程序中看到的应用程序。chart 就是安装文件，release 就是程序。只不过 chart 可以是压缩包或者文件夹或者 url；helm list 命令就相当于打开了添加删除程序，可以看到已经安装好的 release。&lt;/p>
&lt;p>&lt;strong>Repository(仓库)&lt;/strong> 是存放 Charts 的地方，就是类似于 yum 源的概念。Helm 添加一个仓库 URL，就可以查看或安装该仓库下的 Charts。&lt;/p>
&lt;p>基于上述概念，可以这么描述他们：Helm 安装 Charts 到 kubernetes 中，并为每个安装创建一个新的 Release。如果想要找到新的 Charts，可以使用 Helm 搜索 Repository&lt;/p>
&lt;h3 id="在安装前自定义-charthttpshelmshdocsintrousing_helmcustomizing-the-chart-before-installing">&lt;a href="https://helm.sh/docs/intro/using_helm/#customizing-the-chart-before-installing">&lt;strong>在安装前自定义 Chart&lt;/strong>&lt;/a>&lt;/h3>
&lt;p>在我们使用 yum 安装应用时，一般都是安装完成后，再对配置文件进行编辑，以改变应用的运行行为。&lt;/p>
&lt;p>但是使用 Helm 则不能这么做，因为 Helm 直接将应用部署到 Kubernetes 集群中，部署完成后，再改变运行行为的方式是不优雅，且不方便的。所以，我们需要 &lt;strong>Customizing the Chart Before Installing(在安装前自定义图表)&lt;/strong>。&lt;/p>
&lt;p>要查看图表上可配置的选项，使用&lt;code>helm show values&lt;/code>命令。&lt;/p>
&lt;h2 id="charts-repository图表仓库">Charts Repository(图表仓库)&lt;/h2>
&lt;p>通常来说，我们可以直接使用别人已经做好的 Chart，就跟使用 Docker 镜像，或者使用 yum 安装一样。并且，Helm 社区在早期已经维护了一个 &lt;a href="https://github.com/helm/charts">&lt;strong>Helm Charts Hub&lt;/strong>&lt;/a>，这个 Hub 里包含丰富的 Charts。随着云原生应用的发展，这个仓库需要处理的 PR 越来越多，维护非常困难，所以 Helm 逐步把 Charts Hub 中的内容移动到 &lt;a href="https://artifacthub.io/">Artifact Hub&lt;/a> 中(Charts Hub 维护期持续 1 年)。&lt;a href="https://artifacthub.io/">&lt;strong>Arifact Hub&lt;/strong>&lt;/a> 是一个基于 Web 的应用程序，可用于查找，安装和发布 CNCF 项目的软件包和配置。例如，这可能包括 Helm 图表，Falco 配置，开放策略代理（OPA）策略和 OLM 运算符。&lt;/p>
&lt;p>Artifact Hub 中，除了包含 Helm Charts Hub 中的各种资源外，还有各种开源软件官方维护的 Charts，以及 &lt;a href="https://bitnami.com/stacks/helm">&lt;strong>Bitnami 中适用于 kubernetes 的 Charts&lt;/strong>&lt;/a>。&lt;/p>
&lt;p>&lt;a href="https://bitnami.com/">&lt;strong>Bitnami&lt;/strong>&lt;/a> 使我们可以轻松地在任何平台上启动并运行您我们喜爱的开源软件，包括笔记本电脑，Kubernetes 和所有主要云。除了流行的社区产品之外，Bitnami 现在是 VMware 的一部分，它为 IT 组织提供安全，合规，连续维护和可根据组织策略自定义的企业产品。&lt;/p>
&lt;h1 id="helm-的安装">Helm 的安装&lt;/h1>
&lt;p>注意：Helm 使用时，会读取 /root/.kube/config 文件来连接 Kubernetes 集群。&lt;/p>
&lt;ul>
&lt;li>下载 &lt;a href="https://github.com/helm/helm/releases">helm 的 linux 压缩文件&lt;/a>，解压后把 helm 的二进制文件移动到 /usr/bin 目录下，即可直接使用 helm 命令&lt;/li>
&lt;li>配置命令补全
&lt;ul>
&lt;li>echo &amp;ldquo;source &amp;lt;(helm completion bash)&amp;rdquo; &amp;raquo; /root/.bashrc&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>安装 push 插件
&lt;ul>
&lt;li>helm plugin install &lt;a href="https://github.com/chartmuseum/helm-push.git">https://github.com/chartmuseum/helm-push.git&lt;/a>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>当创建一个 Release 的时候，会先把 Chart 的数据存档(.tgz 格式)文件下载到 Helm 配置目录的 archive 目录下，然后再安装&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/henxmt/311ze074e9a719d120b4c409baf70e517c00" alt="">&lt;/p>
&lt;h1 id="helm-关联文件与配置">Helm 关联文件与配置&lt;/h1>
&lt;p>&lt;strong>~/.cache/helm/*&lt;/strong> # helm 缓存路径&lt;/p>
&lt;ul>
&lt;li>&lt;strong>./plugin/*&lt;/strong> # helm 插件安装路径&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>/root/.local/share/helm/plugins/*&lt;/strong> #&lt;/p>
&lt;h1 id="helm-安装资源的顺序">Helm 安装资源的顺序&lt;/h1>
&lt;ul>
&lt;li>Namespace&lt;/li>
&lt;li>NetworkPolicy&lt;/li>
&lt;li>ResourceQuota&lt;/li>
&lt;li>LimitRange&lt;/li>
&lt;li>PodSecurityPolicy&lt;/li>
&lt;li>PodDisruptionBudget&lt;/li>
&lt;li>ServiceAccount&lt;/li>
&lt;li>Secret&lt;/li>
&lt;li>SecretList&lt;/li>
&lt;li>ConfigMap&lt;/li>
&lt;li>StorageClass&lt;/li>
&lt;li>PersistentVolume&lt;/li>
&lt;li>PersistentVolumeClaim&lt;/li>
&lt;li>CustomResourceDefinition&lt;/li>
&lt;li>ClusterRole&lt;/li>
&lt;li>ClusterRoleList&lt;/li>
&lt;li>ClusterRoleBinding&lt;/li>
&lt;li>ClusterRoleBindingList&lt;/li>
&lt;li>Role&lt;/li>
&lt;li>RoleList&lt;/li>
&lt;li>RoleBinding&lt;/li>
&lt;li>RoleBindingList&lt;/li>
&lt;li>Service&lt;/li>
&lt;li>DaemonSet&lt;/li>
&lt;li>Pod&lt;/li>
&lt;li>ReplicationController&lt;/li>
&lt;li>ReplicaSet&lt;/li>
&lt;li>Deployment&lt;/li>
&lt;li>HorizontalPodAutoscaler&lt;/li>
&lt;li>StatefulSet&lt;/li>
&lt;li>Job&lt;/li>
&lt;li>CronJob&lt;/li>
&lt;li>Ingress&lt;/li>
&lt;li>APIService&lt;/li>
&lt;/ul></description></item><item><title>Docs: Helm Template</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/10.%E4%BA%91%E5%8E%9F%E7%94%9F/%E4%BA%91%E5%8E%9F%E7%94%9F%E5%BA%94%E7%94%A8%E7%AE%A1%E7%90%86/helm/helm-template/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/10.%E4%BA%91%E5%8E%9F%E7%94%9F/%E4%BA%91%E5%8E%9F%E7%94%9F%E5%BA%94%E7%94%A8%E7%AE%A1%E7%90%86/helm/helm-template/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://helm.sh/docs/chart_template_guide/">官方文档&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>Helm 的 &lt;a href="https://helm.sh/docs/chart_template_guide/getting_started/">Template(模板)&lt;/a> 可以生成 manifests 文件，这些文件是 kuberntes 用于描述资源的 yaml 。&lt;/p>
&lt;h2 id="template-背景">Template 背景&lt;/h2>
&lt;p>helm 作为 kuberntes 的包管理器，用来在 k8s 集群中安装应用程序。众所周知，对于 k8s 来说，一个应用不应该是一个简单的 pod，应该包含该 pod 的运行方式(比如 deployment)、pod 的配置文件(configmip)、这个程序如何对外提供服务(service、ingress)等等等一系列的信息。这些信息都是通过 yaml 来描述如何工作的。可以想象，如果一个应用程序，其实是一堆 yaml 文件的话，那么 helm 本质上就是管理这些 yaml 文件的。而一个应用程序想要让用户来使用，必然还涉及到自定义的问题。比如应用程序的名字、配置文件中的内容、对外提供服务所要暴露的端口等等信息。&lt;/p>
&lt;p>既然有这样的需求，那么为了让一个应用程序可以自定义，template 就应运而生。template 就是可以将这些 yaml 文件中的 value 变成一种变量的形式，然后通过其他方式(helm 命令行 &amp;ndash;set 标志或者 value.yaml 文件等)来对这些变量进行赋值，来实现应用程序自定义的效果。&lt;/p>
&lt;p>helm templete 使用 &lt;a href="https://pkg.go.dev/text/template">go template&lt;/a> 来实现。而 go template 具有丰富的功能，除了可以普通赋值以外，还可以使用控制结构(比如 if&amp;hellip;else、range 等)来将赋值的过程更具体和多次赋值。&lt;/p>
&lt;p>注意：
当我们谈论“ Helm 模板语言”时，就好像它是特定于 Helm 一样，但它实际上是 Go 模板语言，一些额外功能以及各种包装程序的组合，以将某些对象暴露给模板。当您了解模板时，Go 模板上的许多资源可能会有所帮助。&lt;/p>
&lt;h2 id="基本示例">基本示例&lt;/h2>
&lt;p>首先通过官方的 &lt;a href="https://helm.sh/docs/chart_template_guide/getting_started/">hello world&lt;/a> 示例来看一下 helm 模板的基本功能。通过示例，可以看到，yaml 中的 &lt;code>{{ .Release.Name }}&lt;/code> 被替换为了 release 的名字。这就相当于把 release 名字传递给了&lt;code>{{ .Release.Name }}&lt;/code>。&lt;/p>
&lt;p>&lt;code>{{ }}&lt;/code>符号当中的内容称为 &lt;strong>Template Directive(模板指令)&lt;/strong>，&lt;code>{{ }}&lt;/code>符号中的内容，类似于一个简单的 shell 脚本。一个 **Template Directive(模板指令) **可以包含多种内容，比如：&lt;/p>
&lt;ol>
&lt;li>&lt;strong>引用对象&lt;/strong> # 赋值功能。用于从外部传递值到模板文件中。&lt;/li>
&lt;li>&lt;strong>控制结构&lt;/strong> # 通过类似 if&amp;hellip;else 这种语句来丰富模板中的赋值功能&lt;/li>
&lt;li>&lt;strong>使用变量&lt;/strong> # 声明一个变量并赋值，可以在后续引用。&lt;/li>
&lt;li>&lt;strong>使用函数&lt;/strong> # 通过函数来执行高级操作，比如将值进行大小写转换等等&lt;/li>
&lt;li>&lt;strong>等等等&amp;hellip;&amp;hellip;&lt;/strong>&lt;/li>
&lt;/ol>
&lt;p>Note：如果想要测试模板渲染的效果，可以使用 helm install &amp;ndash;debug &amp;ndash;dry-run mychart ./mychart 这种命令来渲染模板，但是不会真的安装 chart&lt;/p>
&lt;h1 id="objects-介绍">Objects 介绍&lt;/h1>
&lt;p>上面基本示例中的 **.Release.Name 指令 **就是在 &lt;strong>引用 objects(对象)&lt;/strong> 。&lt;/p>
&lt;h2 id="关于这个符号的理解">关于&lt;code>.&lt;/code>这个符号的理解&lt;/h2>
&lt;p>而 object 开头的&lt;code>.&lt;/code>表示当前作用域的顶级对象(有点类似 DNS 中的根域名)，可以在顶级对象下直接引用的对象称为 &lt;a href="https://helm.sh/docs/chart_template_guide/builtin_objects/">Built-in Objects(内置对象)&lt;/a>，Release 就是一个内置对象。&lt;/p>
&lt;p>在上面的 &lt;a href="https://helm.sh/docs/chart_template_guide/getting_started/">hello world&lt;/a> 示例中，从顶层对象开始，找到 Release 对象，在 Release 对象中找到 Name 对象，并将 Name 对象的值传递进模板里。（这种写法特别像 DNS 中的写法，通过点 . 来区分域名的级别，在 helm 模板中也有类似的概念，通过点 . 来区分对象之间级别，上级对象包含其内所有的下级对象）&lt;/p>
&lt;p>官方对于 &lt;code>**.**&lt;/code> 这个符号称之为 &lt;strong>scope(范围)&lt;/strong>，比如下图，圆形就代表了一个范围，最外层就是一个 &lt;code>**.**&lt;/code> 符号。一个 . 范围的内置对象有 Values、Release 等等，而 &lt;strong>.Values 范围&lt;/strong>下还有各种 &lt;strong>.Values.XXX 范围&lt;/strong>，直到范围内的对象下没有新的范围。&lt;strong>scope(范围)&lt;/strong> 常用来约束或指定模板指令的作用范围，或作为参数传递给函数来告知函数其可操作的范围有多大。比如 &lt;a href="https://www.yuque.com/go/doc/33981927">Named Templates(命名模板)&lt;/a> 中，就将范围作为参数传递给 template，告知 Named Templates 内引用对象时使用的范围是多大。
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/nladcy/1617243339047-b1ddaebb-7a5d-41b2-a83e-5f6e9c1c52f0.png" alt="">
可以这么说，这个 &lt;code>.&lt;/code> 符号有两重含义：1、限定范围。2、引用。&lt;/p>
&lt;p>这个 scope(范围) 还可以这么理解。通过 helm 的控制结构语句 range 可以以另一种方式来理解 {{ . }} 的行为，详见：&lt;a href="https://www.yuque.com/go/doc/33982814">控制结构与变量&lt;/a> 章节中的 《通过 range 来梳理 . 范围内的对象》段落来加深理解&lt;/p>
&lt;p>实际上，说了这么多概念，其实 &lt;code>.&lt;/code> 符号就是代表一个值。这个值可以是一个单独的字符串出或者数字、也可以是一个 map 或者 array。&lt;/p>
&lt;p>根据上面模板的介绍可以看到，在模板中，对象就是起到类似变量的用作(但不是变量)，用来传递值的。object(对象) 通过 template engin(模板引擎) 将值传递到模板中。而且，在模板中，可以创建新的 object 。&lt;/p>
&lt;p>Objects 可以很简单，只有一个值。也可以包含其他对象或者功能。比如 Release 对象包含 Release.Name 对象。而 Files 对象，则具有一些功能(比如将文件进行 base64 编码、将文件内容传递到模板中、遍历一个文件)&lt;/p>
&lt;h2 id="helm-里自带的内置-objects">Helm 里自带的内置 Objects&lt;/h2>
&lt;ol>
&lt;li>Release # 该 Object 用来描述 release。其内部还有如下几个对象
&lt;ol>
&lt;li>Release.Name # 该 release 的名字&lt;/li>
&lt;li>Release.Namespace # 该 release 所在的 k8s 的 namesapce 名称&lt;/li>
&lt;li>Release.IsUpgrade # 如果当前操作是升级或回滚，则该对象的值为 true&lt;/li>
&lt;li>Release.IsInstall # 如果当前操作是安装，则该对象的值为 true&lt;/li>
&lt;li>Release.Revision # The revision number for this release. On install, this is 1, and it is incremented with each upgrade and rollback.&lt;/li>
&lt;li>Release.Service # The service that is rendering the present template. On Helm, this is always Helm.&lt;/li>
&lt;/ol>
&lt;/li>
&lt;li>Values # 该 Object 从 &lt;code>values.yaml 文件&lt;/code> 和 &lt;code>helm 命令的 --values和--set 标志&lt;/code> 中提取值，并传递到模板中。默认情况下，Values 为空&lt;/li>
&lt;li>Chart # 该 Object 从 &lt;code>Chart.yaml 文件&lt;/code>中提取值，并传递到模板中。格式与 Values 对象一致
&lt;ol>
&lt;li>Note：Chart.yaml 文件中可用的字段详见：&lt;a href="https://helm.sh/docs/topics/charts/#the-chartyaml-file">Charts Guide 中的 The Chart.yaml File 章节&lt;/a>。&lt;/li>
&lt;/ol>
&lt;/li>
&lt;li>Files # 该 Object 可以将 chart 中的文件传递到模板中。
&lt;ol>
&lt;li>Files.Get # 该 Object 通过文件的名字，将指定的文件传递到模板中。 (比如：.Files.Get config.ini，就是将 conifg.ini 文件传递进模板)&lt;/li>
&lt;li>Files.GetBytes is a function for getting the contents of a file as an array of bytes instead of as a string. This is useful for things like images.&lt;/li>
&lt;li>Files.Glob is a function that returns a list of files whose names match the given shell glob pattern.&lt;/li>
&lt;li>Files.Lines is a function that reads a file line-by-line. This is useful for iterating over each line in a file.&lt;/li>
&lt;li>Files.AsSecrets is a function that returns the file bodies as Base 64 encoded strings.&lt;/li>
&lt;li>Files.AsConfig is a function that returns file bodies as a YAML map.&lt;/li>
&lt;/ol>
&lt;/li>
&lt;li>Capabilities # 这提供了有关 Kubernetes 集群支持的能力信息。This provides information about what capabilities the Kubernetes cluster supports.
&lt;ol>
&lt;li>Capabilities.APIVersions is a set of versions.&lt;/li>
&lt;li>Capabilities.APIVersions.Has $version indicates whether a version (e.g., batch/v1) or resource (e.g., apps/v1/Deployment) is available on the cluster.&lt;/li>
&lt;li>Capabilities.KubeVersion and Capabilities.KubeVersion.Version is the Kubernetes version.&lt;/li>
&lt;li>Capabilities.KubeVersion.Major is the Kubernetes major version.&lt;/li>
&lt;li>Capabilities.KubeVersion.Minor is the Kubernetes minor version.&lt;/li>
&lt;/ol>
&lt;/li>
&lt;li>Template # Contains information about the current template that is being executed
&lt;ol>
&lt;li>Name: A namespaced file path to the current template (e.g. mychart/templates/mytemplate.yaml)&lt;/li>
&lt;li>BasePath: The namespaced path to the templates directory of the current chart (e.g. mychart/templates).&lt;/li>
&lt;/ol>
&lt;/li>
&lt;/ol>
&lt;p>Note：内置对象始终以大写字母开头。这符合 Go 的命名约定。创建自己的名称时，可以自由使用适合您的团队的约定。一些团队（例如 Kubernetes Charts 团队）选择仅使用首字母小写，以区分本地名称和内置名称。在本指南中，我们遵循该约定。&lt;/p>
&lt;h1 id="values-对象介绍">Values 对象介绍&lt;/h1>
&lt;p>官方文档：&lt;a href="https://helm.sh/docs/chart_template_guide/values_files/">https://helm.sh/docs/chart_template_guide/values_files/&lt;/a>&lt;/p>
&lt;p>Values 顶层对象下的对象，一般是自定义的&lt;/p>
&lt;p>比如现在有这样一个模板&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-yaml" data-lang="yaml">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">apiVersion&lt;/span>: &lt;span style="color:#ae81ff">v1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">kind&lt;/span>: &lt;span style="color:#ae81ff">Service&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">metadata&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">labels&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">app&lt;/span>: { { &lt;span style="color:#ae81ff">.Release.Name } }&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">name&lt;/span>: { { &lt;span style="color:#ae81ff">.Release.Name } }&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">spec&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">ports&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#f92672">name&lt;/span>: &lt;span style="color:#ae81ff">http&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">port&lt;/span>: { { &lt;span style="color:#ae81ff">.Values.service.port } }&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">targetPort&lt;/span>: &lt;span style="color:#ae81ff">80&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">nodePort&lt;/span>: { { &lt;span style="color:#ae81ff">.Values.service.nodePort } }&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">type&lt;/span>: { { &lt;span style="color:#ae81ff">.Values.service.type } }&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">selector&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">app&lt;/span>: { { &lt;span style="color:#ae81ff">.Release.Name } }&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="通过-valuesyaml-文件为指定对象的值">通过 values.yaml 文件为指定对象的值&lt;/h2>
&lt;pre>&lt;code>[root@master myapp]# cat values.yaml
service:
type: NodePort
port: 80
nodePort: 30080
&lt;/code>&lt;/pre>
&lt;p>则 {{.Values.service.port}} 这个对象的值为 80，以此类推&lt;/p>
&lt;p>当我们使用 helm install &amp;ndash;dry-run &amp;ndash;debug myapp ./myapp 命令后，可以看到，这个模板被渲染成了这个样子：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-yaml" data-lang="yaml">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># Source: myapp/templates/service.yaml&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">apiVersion&lt;/span>: &lt;span style="color:#ae81ff">v1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">kind&lt;/span>: &lt;span style="color:#ae81ff">Service&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">metadata&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">labels&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">app&lt;/span>: &lt;span style="color:#ae81ff">myapp&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">name&lt;/span>: &lt;span style="color:#ae81ff">myapp&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">spec&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">ports&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#f92672">name&lt;/span>: &lt;span style="color:#ae81ff">http&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">port&lt;/span>: &lt;span style="color:#ae81ff">80&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">targetPort&lt;/span>: &lt;span style="color:#ae81ff">80&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">nodePort&lt;/span>: &lt;span style="color:#ae81ff">30080&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">type&lt;/span>: &lt;span style="color:#ae81ff">NodePort&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">selector&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">app&lt;/span>: &lt;span style="color:#ae81ff">myapp&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Note：在 charts 目录中的 values.yaml 文件为默认的值文件，还可以通过 helm &amp;ndash;values(或 -f) 标志指定其他 yaml 文件来对模板中的对象赋值。&lt;/p>
&lt;h2 id="通过命令行-helm---set-标签指定对象的值">通过命令行 helm &amp;ndash;set 标签指定对象的值。&lt;/h2>
&lt;p>还是用 {{.Values.service.port}} 这个对象举例。如果想通过命令行来指定该对象的值，则可以这么写： helm install &amp;ndash;set service.port=81&lt;/p>
&lt;h1 id="files-对象介绍">Files 对象介绍&lt;/h1>
&lt;p>&lt;strong>注意：本章节内容推荐看完控制结构和函数章节再来看&lt;/strong>&lt;/p>
&lt;p>官方文档：&lt;a href="https://helm.sh/docs/chart_template_guide/accessing_files/">https://helm.sh/docs/chart_template_guide/accessing_files/&lt;/a>&lt;/p>
&lt;p>Files 内置对象用来将文件中的内容直接传递到模板当中。&lt;/p>
&lt;p>Files 下的子对象也可以称为函数的一种，各种子对象的用处各不相同。&lt;/p>
&lt;h3 id="filesget--通过文件的名字将指定的文件传递到模板中-比如filesget-configini就是将-conifgini-文件内容传递进模板">Files.Get # 通过文件的名字，将指定的文件传递到模板中。 (比如：.Files.Get &amp;ldquo;config.ini&amp;rdquo;，就是将 conifg.ini 文件内容传递进模板)&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-yaml" data-lang="yaml">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">apiVersion&lt;/span>: &lt;span style="color:#ae81ff">v1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">kind&lt;/span>: &lt;span style="color:#ae81ff">ConfigMap&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">metadata&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">name&lt;/span>: {{ &lt;span style="color:#ae81ff">.Release.Name }}-configmap&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">data&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">nginx.conf&lt;/span>: |-&lt;span style="color:#e6db74">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74"> &lt;/span> {{- &lt;span style="color:#ae81ff">.Files.Get &amp;#34;nginx.conf&amp;#34; | nindent 4 }}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>注意：上面示例中的 {{- .Files.Get &amp;ldquo;nginx.conf&amp;rdquo; | nindent 4 }} 里的 nindent 4 是必须的，没有其他写法。因为 yam 语言中 |- 符号后面有两个要求：&lt;/p>
&lt;ol>
&lt;li>必须跟一个换行符&lt;/li>
&lt;li>必须为 |- 符号所在字段的子字段(也就是说，文件中的内容必须都为 nginx.conf: |- 字段的子字段，在这里缩进 4 个空格)&lt;/li>
&lt;/ol>
&lt;p>如果写成 nindent 2 ,则缩进错误，报错：Error: YAML parse error on test/templates/test.yaml: error converting YAML to JSON: yaml: line 8: could not find expected &amp;lsquo;:&amp;rsquo;&lt;/p>
&lt;p>如果写成 indent 4 ，则无换行符，报错：Error: YAML parse error on test/templates/test.yaml: error converting YAML to JSON: yaml: line 6: did not find expected comment or line break&lt;/p>
&lt;p>nginx.conf 内容如下&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-nginx" data-lang="nginx">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">user&lt;/span> &lt;span style="color:#e6db74">nginx&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">worker_processes&lt;/span> &lt;span style="color:#e6db74">auto&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">error_log&lt;/span> &lt;span style="color:#e6db74">/var/log/nginx/error.log&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">pid&lt;/span> &lt;span style="color:#e6db74">/run/nginx.pid&lt;/span>;
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>渲染结果如下：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-yaml" data-lang="yaml">&lt;span style="display:flex;">&lt;span>[&lt;span style="color:#ae81ff">root@master-1 test]# helm template test .&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>---
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># Source: test/templates/test.yaml&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">apiVersion&lt;/span>: &lt;span style="color:#ae81ff">v1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">kind&lt;/span>: &lt;span style="color:#ae81ff">ConfigMap&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">metadata&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">name&lt;/span>: &lt;span style="color:#ae81ff">test-configmap&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">data&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">nginx.conf&lt;/span>: |-&lt;span style="color:#e6db74">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74"> user nginx;
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74"> worker_processes auto;
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74"> error_log /var/log/nginx/error.log;
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74"> pid /run/nginx.pid;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="filesgetbytes-is-a-function-for-getting-the-contents-of-a-file-as-an-array-of-bytes-instead-of-as-a-string-this-is-useful-for-things-like-images">Files.GetBytes is a function for getting the contents of a file as an array of bytes instead of as a string. This is useful for things like images.&lt;/h3>
&lt;h3 id="filesglob-is-a-function-that-returns-a-list-of-files-whose-names-match-the-given-shell-glob-pattern">Files.Glob is a function that returns a list of files whose names match the given shell glob pattern.&lt;/h3>
&lt;h3 id="fileslines-is-a-function-that-reads-a-file-line-by-line-this-is-useful-for-iterating-over-each-line-in-a-file">Files.Lines is a function that reads a file line-by-line. This is useful for iterating over each line in a file.&lt;/h3>
&lt;h3 id="filesassecrets-is-a-function-that-returns-the-file-bodies-as-base-64-encoded-strings">Files.AsSecrets is a function that returns the file bodies as Base 64 encoded strings.&lt;/h3>
&lt;h3 id="filesasconfig-is-a-function-that-returns-file-bodies-as-a-yaml-map">Files.AsConfig is a function that returns file bodies as a YAML map.&lt;/h3>
&lt;h1 id="数据类型">数据类型&lt;/h1>
&lt;ol>
&lt;li>
&lt;p>map 数据用 map[] 符号表示&lt;/p>
&lt;ol>
&lt;li>注意：在其他语言中，map 类型数据一般用 {} 符号表示，但是在 helm 中，则使用 map[] 这种标志来表示。map[] 这种标志中的 [] 符号，仅仅是一个无意义的标识符，将 [] 内的数据合起来，以便让程序直到这几个键值对是同一个 map 下的，并没有 array 的含义。&lt;/li>
&lt;/ol>
&lt;/li>
&lt;li>
&lt;p>array 数据用 [] 符号表示&lt;/p>
&lt;ol>
&lt;li>index 函数用来获取 array 中的指定索引号的元素的值，index 函数语法为&lt;/li>
&lt;/ol>
&lt;p>{{ index PIPELINE NUM }}&lt;/p>
&lt;/li>
&lt;/ol>
&lt;ul>
&lt;li>PIPELINE 产生的数据类型必须为 array，NUM 为该数组元素的索引号。&lt;/li>
&lt;/ul></description></item><item><title>Docs: Helm Template</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/10.%E4%BA%91%E5%8E%9F%E7%94%9F/%E4%BA%91%E5%8E%9F%E7%94%9F%E5%BA%94%E7%94%A8%E7%AE%A1%E7%90%86/helm/helm-template/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/10.%E4%BA%91%E5%8E%9F%E7%94%9F/%E4%BA%91%E5%8E%9F%E7%94%9F%E5%BA%94%E7%94%A8%E7%AE%A1%E7%90%86/helm/helm-template/</guid><description/></item><item><title>Docs: Helm 命令行工具</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/10.%E4%BA%91%E5%8E%9F%E7%94%9F/%E4%BA%91%E5%8E%9F%E7%94%9F%E5%BA%94%E7%94%A8%E7%AE%A1%E7%90%86/helm/helm-%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%B7%A5%E5%85%B7/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/10.%E4%BA%91%E5%8E%9F%E7%94%9F/%E4%BA%91%E5%8E%9F%E7%94%9F%E5%BA%94%E7%94%A8%E7%AE%A1%E7%90%86/helm/helm-%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%B7%A5%E5%85%B7/</guid><description>
&lt;h1 id="helm-命令行工具详解">helm 命令行工具详解&lt;/h1>
&lt;h1 id="helm-commands-flags">&lt;strong>helm COMMANDS [FLAGS]&lt;/strong>&lt;/h1>
&lt;p>Flags 与 Options 一样，是标志、标记的意思，就是指该命令的各个选项&lt;/p>
&lt;h1 id="flags全局-flags">&lt;strong>FLAGS：全局 Flags&lt;/strong>&lt;/h1>
&lt;ul>
&lt;li>--add-dir-header                   If true, adds the file directory to the header&lt;/li>
&lt;li>--alsologtostderr                  log to standard error as well as files&lt;/li>
&lt;li>&lt;strong>&amp;ndash;debug&lt;/strong> # 开启详细的输出信息&lt;/li>
&lt;li>-h, &amp;ndash;help                             help for helm&lt;/li>
&lt;li>--kube-context string              name of the kubeconfig context to use&lt;/li>
&lt;li>--kubeconfig STRING # 指定 helm 运行所需的 kubeconfig 文件路径为 STRING。默认为 /root/.kube/config&lt;/li>
&lt;li>--log-backtrace-at traceLocation   when logging hits line file:N, emit a stack trace (default :0)&lt;/li>
&lt;li>--log-dir string                   If non-empty, write log files in this directory&lt;/li>
&lt;li>--log-file string                  If non-empty, use this log file&lt;/li>
&lt;li>--log-file-max-size uint           Defines the maximum size a log file can grow to. Unit is megabytes. If the value is 0, the maximum file size is unlimited. (default 1800)&lt;/li>
&lt;li>--logtostderr                      log to standard error instead of files (default true)&lt;/li>
&lt;li>&lt;strong>-n, &amp;ndash;namespace string&lt;/strong> # 指定当前命令要在哪个 namespace 下执行&lt;/li>
&lt;li>--registry-config string           path to the registry config file (default &amp;ldquo;/root/.config/helm/registry.json&amp;rdquo;)&lt;/li>
&lt;li>--repository-cache string          path to the file containing cached repository indexes (default &amp;ldquo;/root/.cache/helm/repository&amp;rdquo;)&lt;/li>
&lt;li>--repository-config string         path to the file containing repository names and URLs (default &amp;ldquo;/root/.config/helm/repositories.yaml&amp;rdquo;)&lt;/li>
&lt;li>--skip-headers                     If true, avoid header prefixes in the log messages&lt;/li>
&lt;li>--skip-log-headers                 If true, avoid headers when opening log files&lt;/li>
&lt;li>--stderrthreshold severity         logs at or above this threshold go to stderr (default 2)&lt;/li>
&lt;li>-v, &amp;ndash;v Level                          number for the log level verbosity&lt;/li>
&lt;li>--vmodule moduleSpec               comma-separated list of pattern=N settings for file-filtered logging&lt;/li>
&lt;/ul>
&lt;h1 id="可用的子命令如下">可用的子命令如下：&lt;/h1>
&lt;h2 id="completion--为指定的-shellbash-或-zsh生成命令自动补全脚本">completion # 为指定的 shell（bash 或 zsh）生成命令自动补全脚本&lt;/h2>
&lt;p>helm completion SHELL [FLAGS]&lt;/p>
&lt;p>EXAMPLE&lt;/p>
&lt;ol>
&lt;li>echo &amp;lsquo;source &amp;lt;(helm completion bash)&amp;rsquo; &amp;raquo; ~/.bashrc # 为 bash shell 生成命令补全脚本，并添加到 /root/.bashrc 文件中&lt;/li>
&lt;/ol>
&lt;h2 id="create--用给定的名字创建一个新的-chart">create # 用给定的名字创建一个新的 chart&lt;/h2>
&lt;p>创建完成后会创建一个 chart 目录，该目录包含基本的可用文件，然后自己可以自定义其中内容&lt;/p>
&lt;h2 id="dependency--管理一个-chart-的依赖性">dependency # 管理一个 chart 的依赖性&lt;/h2>
&lt;p>env # Helm client environment information&lt;/p>
&lt;h2 id="get--获取指定-release-的扩展信息">get # 获取指定 release 的扩展信息&lt;/h2>
&lt;p>详见：&lt;a href="https://www.yuque.com/go/doc/33978659">&lt;strong>helm 查询相关命令&lt;/strong>&lt;/a>&lt;/p>
&lt;h2 id="history--获取-release-的历史版本">history # 获取 release 的历史版本&lt;/h2>
&lt;h2 id="install--安装一个-chart-archive可以创建出来一个-release">install # 安装一个 chart archive(可以创建出来一个 release)&lt;/h2>
&lt;p>详见：&lt;a href="https://www.yuque.com/go/doc/33978637">&lt;strong>helm install&lt;/strong>&lt;/a>&lt;/p>
&lt;h2 id="lint--检查一个-chart看看可能出现的问题examines-a-chart-for-possible-issues">lint # 检查一个 chart，看看可能出现的问题。examines a chart for possible issues&lt;/h2>
&lt;h2 id="list--列出所有-release">list # 列出所有 release&lt;/h2>
&lt;p>helm list [FLAGS] [FILTER]&lt;/p>
&lt;ol>
&lt;li>FLAGS
&lt;ol>
&lt;li>-a # 列出所有状态的的 release&lt;/li>
&lt;/ol>
&lt;/li>
&lt;li>EXAMPLE
&lt;ol>
&lt;li>helm list -A # 列出所有名称空间下已经部署的或者失败的所有 release&lt;/li>
&lt;/ol>
&lt;/li>
&lt;/ol>
&lt;h2 id="package--打包一个-chart-到定好版本的-chart-archive-文件中">package # 打包一个 chart 到定好版本的 chart archive 文件中。&lt;/h2>
&lt;p>该命令会查找指定路径下的 Chart.yaml 文件，然后打包该目录，如果目录中没有 Chart.yaml 文件则无法打包&lt;/p>
&lt;p>helm package [CHART_PATH] [&amp;hellip;] [FALGS]&lt;/p>
&lt;p>EXAMPLE&lt;/p>
&lt;ol>
&lt;li>helm package myapp/ # 将 myapp 目录下的内容打包成一个 charts archive&lt;/li>
&lt;/ol>
&lt;h2 id="plugin--安装显示卸载-helm-的插件">plugin # 安装、显示、卸载 helm 的插件&lt;/h2>
&lt;h2 id="pull--从-repository-中下载指定的-chartnote下载的是压缩包可以解压修改其中内容">pull # 从 repository 中下载指定的 chart。Note：下载的是压缩包，可以解压修改其中内容&lt;/h2>
&lt;h2 id="repo--创建列出移除更新索引-chart-的所有仓库">repo # 创建、列出、移除、更新、索引 chart 的所有仓库&lt;/h2>
&lt;p>helm repo [SubCommand]&lt;/p>
&lt;p>SubCommand&lt;/p>
&lt;ol>
&lt;li>add # 添加一个 charts 仓库
&lt;ol>
&lt;li>helm repo add [FLAGS] NAME URL #添加一个名为 Name,url 为 URL 的仓库&lt;/li>
&lt;li>EXAMPLE
&lt;ol>
&lt;li>helm repo add lichenhao &lt;a href="https://www.lichenhao.com">https://www.lichenhao.com&lt;/a>&lt;/li>
&lt;/ol>
&lt;/li>
&lt;/ol>
&lt;/li>
&lt;li>index       generate an index file given a directory containing packaged charts&lt;/li>
&lt;li>list        list chart repositories
&lt;ol>
&lt;li>EXAMPLE
&lt;ol>
&lt;li>helm repo list&lt;/li>
&lt;/ol>
&lt;/li>
&lt;/ol>
&lt;/li>
&lt;li>remove      remove a chart repository&lt;/li>
&lt;li>update      update information of available charts locally from chart repositories&lt;/li>
&lt;/ol>
&lt;h2 id="rollback--回滚一个-release-到以前的版本">rollback # 回滚一个 release 到以前的版本&lt;/h2>
&lt;h2 id="search--在可以存储-helm-图表的各种地方进行搜索以显示可用的-helm-charts">search # 在可以存储 Helm 图表的各种地方进行搜索，以显示可用的 helm charts&lt;/h2>
&lt;p>&lt;strong>helm search [COMMAND]&lt;/strong>&lt;/p>
&lt;h3 id="hub--在-helm-hub-或-monocular-实例中搜索-charts">hub # 在 helm hub 或 Monocular 实例中搜索 charts&lt;/h3>
&lt;p>FLAGS&lt;/p>
&lt;ol>
&lt;li>--endpoint string      monocular instance to query for charts (default &amp;ldquo;&lt;a href="https://hub.helm.sh">https://hub.helm.sh&lt;/a>&amp;rdquo;)&lt;/li>
&lt;li>--max-col-width uint   maximum column width for output table (default 50)&lt;/li>
&lt;li>-o, &amp;ndash;output format        prints the output in the specified format. Allowed values: table, json, yaml (default table)&lt;/li>
&lt;/ol>
&lt;h3 id="repo--在已添加的所有-repoistories-中搜索-charts">repo # 在已添加的所有 repoistories 中搜索 charts&lt;/h3>
&lt;p>&lt;strong>helm search repo [KEYWORD] [FLAGS]&lt;/strong>&lt;/p>
&lt;p>FLAGS&lt;/p>
&lt;ol>
&lt;li>--devel # 搜索结果包含开发版等效于 &amp;ndash;version 标志的值&amp;rsquo;&amp;gt;0.0.0-0&amp;rsquo;。如果设置了 &amp;ndash;version 标志，则忽略该标志。&lt;/li>
&lt;li>--max-col-width UINT # 输出表的每列的最大宽度为 UINT。(默认为 50)&lt;/li>
&lt;li>-o, &amp;ndash;output FORMAT # 以指定的格式打印输出。 允许的值：table，json，yaml（默认表）&lt;/li>
&lt;li>-r, &amp;ndash;regexp               use regular expressions for searching repositories you have added&lt;/li>
&lt;li>--version string       search using semantic versioning constraints on repositories you have added&lt;/li>
&lt;li>-l, &amp;ndash;versions             show the long listing, with each version of each chart on its own line, for repositories you have added&lt;/li>
&lt;/ol>
&lt;p>EXAMPLE&lt;/p>
&lt;h2 id="show--显示一个-chart-的信息多种信息可以使用子命令来控制要输出的-chart-信息">show # 显示一个 chart 的信息多种信息，可以使用子命令来控制要输出的 chart 信息&lt;/h2>
&lt;h2 id="status--显示指定名字的-release-状态信息">status # 显示指定名字的 release 状态信息&lt;/h2>
&lt;p>&lt;strong>helm status ReleaseName [FLAGS]&lt;/strong>&lt;/p>
&lt;p>FLAGS&lt;/p>
&lt;ol>
&lt;li>-o, &amp;ndash;output FORMAT # 以指定的格式输出内容。&lt;code>默认值：table&lt;/code>。可用的值有 table、json、yaml
&lt;ol>
&lt;li>注意：yaml 格式可以显示该 release 的所有资源&lt;/li>
&lt;/ol>
&lt;/li>
&lt;li>--revision INT # 显示指定历史版本的信息&lt;/li>
&lt;/ol>
&lt;h2 id="template--在本地渲染-chart-模板并展示输出">template # 在本地渲染 chart 模板，并展示输出&lt;/h2>
&lt;p>详见：&lt;a href="https://www.yuque.com/go/doc/33978645">helm template 模板相关命令&lt;/a>&lt;/p>
&lt;h2 id="test--test-a-release">test # test a release&lt;/h2>
&lt;h2 id="uninstall--卸载指定的-release">uninstall # 卸载指定的 release&lt;/h2>
&lt;p>helm uninstall [FLAGS] RELEASE_NAME [&amp;hellip;]&lt;/p>
&lt;ol>
&lt;li>FLAGS
&lt;ol>
&lt;li>--purge #从 store 移除 release 以便让 release 的名字空出来为以后使用。&lt;/li>
&lt;/ol>
&lt;/li>
&lt;li>EXAMPLE&lt;/li>
&lt;/ol>
&lt;h2 id="upgrade--升级一个-release">upgrade # 升级一个 release&lt;/h2>
&lt;h2 id="verify--verify-that-a-chart-at-the-given-path-has-been-signed-and-is-valid">verify # verify that a chart at the given path has been signed and is valid&lt;/h2>
&lt;h2 id="version--打印-helm-的客户端和服务端的版本信息">version # 打印 helm 的客户端和服务端的版本信息&lt;/h2></description></item><item><title>Docs: Helm 命令行工具</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/10.%E4%BA%91%E5%8E%9F%E7%94%9F/%E4%BA%91%E5%8E%9F%E7%94%9F%E5%BA%94%E7%94%A8%E7%AE%A1%E7%90%86/helm/helm-%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%B7%A5%E5%85%B7/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/10.%E4%BA%91%E5%8E%9F%E7%94%9F/%E4%BA%91%E5%8E%9F%E7%94%9F%E5%BA%94%E7%94%A8%E7%AE%A1%E7%90%86/helm/helm-%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%B7%A5%E5%85%B7/</guid><description/></item></channel></rss>