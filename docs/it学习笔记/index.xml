<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>断念梦 – IT学习笔记</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</link><description>Recent content in IT学习笔记 on 断念梦</description><generator>Hugo -- gohugo.io</generator><atom:link href="https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/index.xml" rel="self" type="application/rss+xml"/><item><title>Docs: 💻0.计算机</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/0.%E8%AE%A1%E7%AE%97%E6%9C%BA/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/0.%E8%AE%A1%E7%AE%97%E6%9C%BA/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Computer">Wiki,Computer&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Von_Neumann_architecture">Wiki,Von Neumann Architecture(冯·诺依曼架构)&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Xia_Peisu">Wiki,Xia_Peisu&lt;/a>(夏培肃，中国计算机之母)&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>世界上公认的第一台数字电子计算机于 1946 年问世，人们通常按照计算机元器件的演变，把计算机的发展过程分为如下几个阶段：&lt;/p>
&lt;ul>
&lt;li>第一代：1946 ~ 1958 年 # 电子管&lt;/li>
&lt;li>第二代：1958 ~ 1964 年 # 晶体管&lt;/li>
&lt;li>第三代：1964 ~ 1974 年 # 小规模集成电路&lt;/li>
&lt;li>第四代：1974 ~ 至今 # 大规模集成电路&lt;/li>
&lt;/ul>
&lt;h1 id="x86">X86&lt;/h1>
&lt;p>&lt;strong>x86&lt;/strong>是一个术语，用于描述与 Intel 8086 及其后续产品兼容的 CPU 指令集，包括 Pentium 和 Intel 及其他公司制造的其他产品。这是大多数台式机和笔记本电脑中使用的 CPU 架构。许多 21 世纪的工作站和服务器也使用 x86 处理器。1985 年，随着 i386 处理器的推出，最初的 16 位 x86 架构扩展到 32 位。随着 AMD Opteron 处理器的推出，它在 2003 年再次扩展到 64 位。&lt;/p>
&lt;p>英特尔在 2004 年采用了 64 位计算位架构和更高版本的 Prescott Pentium 4.不同版本是向后兼容的，这意味着 32 位 x86(x86-32)CPU 可以运行 32 位或 16 位操作系统，64 位 x86(x86-64)CPU 可以运行 16 位，32 位或 64 位操作系统。所有 x86 CPU（除了嵌入式系统中使用的某些 Intel CPU 的极少例外）都以 16 位实模式启动。在引导内核之前，现代操作系统（或有时是引导加载程序）将 CPU 切换为 32 位保护模式或 64 位长模式。&lt;/p>
&lt;h1 id="32-bit-与-64-bit32-位与-64-位">32-bit 与 64-bit(32 位与 64 位)&lt;/h1>
&lt;p>CPU 的位是指一次性可处理的数据量是多少，1 字节=8 位，32 位处理器可以一次性处理 4 个字节的数据量，,64 位处理器可以一次性处理 8 个字节的数据量。依次类推。32 位操作系统针对的 32 位的 CPU 设计。&lt;/p>
&lt;p>可以吧 1bit 理解为一个 0 或者一个 1，所以 4 字节就是 32bit，也就是说最大数为 11111111111111111111111111111111，换算成 10 进制就是 4294967295bit，由于 1024bit=1kb，1024kb=1m，以此类推的话，32 位处理器一次性处理 3.99G 的数据量，大于这个的数据，则无法被处理。&lt;/p>
&lt;p>在使用内存的时候，需要使用 16 进制来表示内存的地址位置 32 个 0 表示内存的第一个位置，32 个 1 表示内存地址的最后一个。&lt;/p>
&lt;h1 id="计算机为什么叫计算机">计算机为什么叫计算机&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://www.ximalaya.com/keji/246622/30260075">原来是这样-150 期&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>计算机本质就是用来计算的&lt;/p>
&lt;h1 id="冯诺依曼架构">冯·诺依曼架构&lt;/h1>
&lt;h1 id="bios-与-uefi">BIOS 与 UEFI&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://mp.weixin.qq.com/s/jTQu14SuoIj-c2L7hEiYzg">公众号-OSC 开源社区，用户极力反对，Fedora 重新讨论 BIOS 未来&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote></description></item><item><title>Docs: 📄1.操作系统</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/</guid><description/></item><item><title>Docs: 👨‍💻2.编程</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/2.%E7%BC%96%E7%A8%8B/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/2.%E7%BC%96%E7%A8%8B/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Computer_programming">Wiki,Computer Programming&lt;/a>(计算机编程)&lt;/li>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Programming_language">Wiki,Programmig Language(编程语言)&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>Programming(编程)&lt;/p>
&lt;p>无论处于上层的软件多么的高级, 想要在 CPU 执行, 就必须被翻译成“机器码”， 翻译这个工作由编译器来执行. 编译器在这个过程中, 要经过“编译”，“汇编”，“链接”几个步骤, 最后生成“&lt;a href="https://so.csdn.net/so/search?q=%E5%8F%AF%E6%89%A7%E8%A1%8C%E6%96%87%E4%BB%B6&amp;amp;spm=1001.2101.3001.7020">可执行文件&lt;/a>”. 可执行文件中保存的是二进制机器码. 这串机器码可以直接被 CPU 读取和执行。&lt;/p>
&lt;h1 id="编程学习资料">编程学习资料&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://mp.weixin.qq.com/s/WdTRq31CRjy90KiN88dwtw">公众号，微软带头打了 30 年，这场屏幕的大乱斗，终于要结束了&lt;/a>(前端浏览器的历史)&lt;/li>
&lt;li>&lt;a href="http://www.manongjc.com/">码农教程&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;h2 id="菜鸟教程">菜鸟教程&lt;/h2>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://www.runoob.com/">官网&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>&lt;a href="https://www.runoob.com/">菜鸟教程&lt;/a>提供了基础编程技术教程。
菜鸟教程的 Slogan 为：学的不仅是技术，更是梦想！
记住：再牛逼的梦想也抵不住傻逼似的坚持！
本站域名为 runoob.com, runoob 为 Running Noob 的缩写，意为：奔跑吧！菜鸟。
本站包括了 HTML、CSS、Javascript、PHP、C、Python 等各种基础编程教程。
同时本站中也提供了大量的在线实例，通过实例，您可以更好地学习如何建站。
本站致力于推广各种编程语言技术，所有资源是完全免费的，并且会根据当前互联网的变化实时更新本站内容。
同时本站内容如果有不足的地方，也欢迎广大编程爱好者在本站留言提供意见。&lt;/p>
&lt;h2 id="w3school">W3school&lt;/h2>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://www.w3schools.com/">官网&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.w3school.com.cn/about/about_us.asp">W3school 中文&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>开发者资源网站(各种语言的教程、各种参考手册等等)&lt;/p>
&lt;h2 id="mdn">MDN&lt;/h2>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/MDN_Web_Docs">Wiki,MDN&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://github.com/mdn/">GitHub MDN 组织&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>&lt;a href="https://developer.mozilla.org">Mozilla Developer Network(Mozilla 开发者网络，简称 MDN) 官网&lt;/a>，这是一个汇集了众多 Mozilla 基金会产品和网络技术开发文档的网站。
该网站都是前端所需要的东西&lt;/p>
&lt;h1 id="代码类型">代码类型&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Source_code">Wiki,Source code&lt;/a>(源码)&lt;/li>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Assembly_language">Wiki,Assembly code&lt;/a>(汇编码)，也可以称为 Assembly language(汇编语言)&lt;/li>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Machine_code">Wiki,Machine code&lt;/a>(机器码)
&lt;ul>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Opcode">Wiki,Operation code&lt;/a>(操作码)&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Bytecode">Wiki,Bytecode&lt;/a>(字节码)&lt;/li>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Microcode">Wiki,Microcode&lt;/a>(微码)&lt;/li>
&lt;li>&lt;a href="https://juejin.cn/post/6946382168641765412">掘金，机器码和计算机指令到底是怎么回事&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>所有的 &lt;strong>Code(代码)&lt;/strong>，都可以看作是 &lt;strong>Instructions(指令)&lt;/strong> 的&lt;strong>集合&lt;/strong>。&lt;/p>
&lt;ul>
&lt;li>C、Go 等高级语言编写的代码是源码，源码通过编译器，将源码转换为汇编码&lt;/li>
&lt;li>各种类型的汇编语言编写的代码是汇编码，汇编码通过汇编器，将汇编码转换为机器码&lt;/li>
&lt;/ul>
&lt;h2 id="source-code源码">Source Code(源码)&lt;/h2>
&lt;p>在计算机编程中，&lt;strong>Soure Code(源码)&lt;/strong> 是使用人类可读的编程语言编写的任何&lt;strong>代码指令的集合&lt;/strong>。程序的源代码是专门为方便计算机程序员的工作而设计的，他们主要通过编写源代码来指定计算机要执行的操作。源代码通常由汇编器或编译器转换为可由计算机执行的二进制机器代码。然后可能会存储机器代码以供稍后执行。或者，源代码可以被解释并因此立即执行。&lt;/p>
&lt;h2 id="machine-code机器码">Machine Code(机器码)&lt;/h2>
&lt;p>在计算机编程中，&lt;strong>Machine Code(机器码)&lt;/strong> 是任何符合 &lt;a href="#NKiSr">ISA&lt;/a>(指令集架构) 的 &lt;strong>Machine Instruction(机器指令)&lt;strong>的&lt;/strong>集合&lt;/strong>，用于控制对应 ISA 标准下的 CPU。其中的每条指令都会使 CPU 执行一项具体的任务。例如对 CPU 寄存器中的一个或多个数据单元进行 加载、存储、调准、算数逻辑单元 等操作。&lt;/p>
&lt;blockquote>
&lt;p>Machhine Code(机器码) 也可以称为 Machine Instruction(机器指令)&lt;/p>
&lt;/blockquote>
&lt;p>比如，MIPS 架构为每条机器指令始终是 32 bit 长的机器码提供了一个特定的示例：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ae81ff">6&lt;/span> &lt;span style="color:#ae81ff">5&lt;/span> &lt;span style="color:#ae81ff">5&lt;/span> &lt;span style="color:#ae81ff">5&lt;/span> &lt;span style="color:#ae81ff">5&lt;/span> &lt;span style="color:#ae81ff">6&lt;/span> bits
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">[&lt;/span> op | rs | rt | rd |shamt| funct&lt;span style="color:#f92672">]&lt;/span> R-type
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">[&lt;/span> op | rs | rt | address/immediate&lt;span style="color:#f92672">]&lt;/span> I-type
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">[&lt;/span> op | target address &lt;span style="color:#f92672">]&lt;/span> J-type
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>MIPS 架构中将所有机器指令分为 3 类：&lt;/p>
&lt;ul>
&lt;li>&lt;strong>R-type(Register 寄存器)&lt;/strong> # 一般用来执行算术逻辑操作，里面有读取和写入数据寄存器的地址，如果是逻辑位移操作，还有位移量，最后的 funct 是功能码，用以补充操作码&lt;/li>
&lt;li>&lt;strong>I-type(Immediate 立即)&lt;/strong> # 通常用来执行数据传输、条件分支、立即数操作。&lt;/li>
&lt;li>&lt;strong>J-type(Jump 跳转)&lt;/strong> # 通常用来执行无条件跳转操作。每条指令后面通常都会接一条跳转指令以便 CPU 可以跳转到下一个位置执行后面的指令。&lt;/li>
&lt;/ul>
&lt;p>每种类型的机器指令最高由 32 bit 表示，不同类型的指令中每个 bit 所表示的含义是不一样的，通常前 6 bit 都是 op，用以表示这条指令具体需要执行的行为是什么。后面的 bits 则根据指令的不同而有所区别&lt;/p>
&lt;ul>
&lt;li>&lt;strong>op&lt;/strong> # &lt;strong>Operation Code(操作码，简称 opcode)&lt;/strong> 也称为 Instruction machine code(指令机器码)、Instruction code(指令码)、Instruction syllable()、Instruction parcel、opstring。op 代表这条指令具体是一条什么样的指令。
&lt;ul>
&lt;li>op 码 与 实际行为 的对应关系，需要参考各个 ISA 规范&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>rs、rt、rd&lt;/strong> # 寄存器 XX
&lt;ul>
&lt;li>R 指令中 rd 是存放结果的目的寄存器&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>immediate&lt;/strong> 或 **address **# 需要操作的“数”。
&lt;ul>
&lt;li>可以是一个“具体的可以直接操作的数”或“存放数的地址”&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>target address&lt;/strong> # 目标地址&lt;/li>
&lt;/ul>
&lt;p>若一个 CPU 是 32 位 或 64 位，那寄存器中可以存储的 bit 数即为 32 bit 或 64 bit
比如我们可以通过 I-type 指令将数据存储到指定的寄存器中，然后通过 R-type 指令计算指定寄存器中的数据，并将结果放到另一个寄存器中，最后通过 J-type 指令跳转到下一个位置继续执行后续的指令。
简单示例：
将寄存器 1 和 2 相加并将结果放入寄存器 6 的编码如下：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">[&lt;/span> op | rs | rt | rd |shamt| funct&lt;span style="color:#f92672">]&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ae81ff">0&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span> &lt;span style="color:#ae81ff">2&lt;/span> &lt;span style="color:#ae81ff">6&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span> &lt;span style="color:#ae81ff">32&lt;/span> 十进制表示
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ae81ff">000000&lt;/span> &lt;span style="color:#ae81ff">00001&lt;/span> &lt;span style="color:#ae81ff">00010&lt;/span> &lt;span style="color:#ae81ff">00110&lt;/span> &lt;span style="color:#ae81ff">00000&lt;/span> &lt;span style="color:#ae81ff">100000&lt;/span> 二进制表示
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> 0X???? 十六进制表示。怎么转换还没找到资料
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>将一个值加载到寄存器 8 中，该值取自寄存器 3 中列出的位置之后的存储单元 68 个单元：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">[&lt;/span> op | rs | rt | address/immediate&lt;span style="color:#f92672">]&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ae81ff">35&lt;/span> &lt;span style="color:#ae81ff">3&lt;/span> &lt;span style="color:#ae81ff">8&lt;/span> &lt;span style="color:#ae81ff">68&lt;/span> 十进制表示
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ae81ff">100011&lt;/span> &lt;span style="color:#ae81ff">00011&lt;/span> &lt;span style="color:#ae81ff">01000&lt;/span> &lt;span style="color:#ae81ff">00000&lt;/span> &lt;span style="color:#ae81ff">00001&lt;/span> &lt;span style="color:#ae81ff">000100&lt;/span> 二进制表示
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> 0X???? 十六进制表示。怎么转换还没找到资料
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>跳转到地址 1024：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">[&lt;/span> op | target address &lt;span style="color:#f92672">]&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ae81ff">2&lt;/span> &lt;span style="color:#ae81ff">1024&lt;/span> 十进制表示
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ae81ff">000010&lt;/span> &lt;span style="color:#ae81ff">00000&lt;/span> &lt;span style="color:#ae81ff">00000&lt;/span> &lt;span style="color:#ae81ff">00000&lt;/span> &lt;span style="color:#ae81ff">10000&lt;/span> &lt;span style="color:#ae81ff">000000&lt;/span> 二进制表示
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> 0X???? 十六进制表示。怎么转换还没找到资料
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="总结">总结&lt;/h3>
&lt;p>机器码的结构其实和各种协议的封装结构非常类似，都是通过某些规范，将 bits 划分为几块，每块 bits 数表示的含义是不一样的
而决定机器码结构的，就是 &lt;a href="#NKiSr">ISA(指令集架构)&lt;/a> 了，根据 ISA 生产的 CPU 在处理机器码时，会根据自身的 ISA 来解析这些机器码，隔几 bit 识别一次，然后执行识别到的结果，若是 CPU 在识别机器码时发现是在自己的 ISA 规范中，那么这条机器码将会被转成微码并在 CPU 内流动，若机器码错了，那么是没法通过 CPU 的译码阶段，控制点路将会报错。这时如果是 windows 系统往往就会蓝屏，因为 CPU 无法识别机器码中的指令，不知道自己应该执行什么。
机器码与源码最大的区别在于&lt;/p>
&lt;ul>
&lt;li>源码可以用多种高级语言编写；而每条机器码是与每行汇编码是一一对应的&lt;/li>
&lt;li>源码是人类可读的；机器码人类读不懂&lt;/li>
&lt;li>源码通常都是文本；机器码是 0 和 1 数字的集合(当然，二进制也可以通过某些规则，编码为 10 进制、16 进制等，用于传播与存储)&lt;/li>
&lt;/ul>
&lt;p>最后说一点：&lt;/p>
&lt;ul>
&lt;li>&lt;strong>源码是与人交互的，需要符合人的规矩，也就是各种高级编程语言的格式&lt;/strong>&lt;/li>
&lt;li>&lt;strong>机器码是与机器交互的，需要符合机器的规矩，也就是各种指令集架构&lt;/strong>&lt;/li>
&lt;/ul>
&lt;p>所以，就算是好多好多 0 和 1 的数字，也需要符合某些规范，才可以被 CPU 识别。当 CPU 识别时，假如现在我规定，每隔 10 bit 识别一次，然后发现 10 个 01 组成的数字，在自己的规范中没有任何描述，那么这 CPU 也就执行不下去了。这也是一个程序无法在多种架构的 CPU 上执行的原因。因为当一个程序经过汇编之后，01 的排列是以一种架构实现的，这种排列方式在其他架构上是识别不出来的~~~~&lt;/p>
&lt;h3 id="机器码与汇编码">机器码与汇编码&lt;/h3>
&lt;p>由于机器码对人类来说非常不可读，所以早期人们创造了汇编语言，汇编语言的作用就是使用人类可读的汇编码与机器码建立一一对应的关系，这样，人们在编写程序时，就不用一直编写 01 了，而是使用单词来描述一条指令。
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/cr7gm9/1653022184400-445fedc6-a6d6-4b0a-9e61-269ae5aff029.webp" alt="">
以上 C 语言编译成汇编语言，再由汇编语言翻译成机器码，也就是 0 和 1 的机器语言。一条条的 16 进制数字，就是机器能读懂的计算机指令
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/cr7gm9/1653020400830-d392e057-dc98-4605-bf86-043f243c7779.webp" alt="">
linux 系统上可以使用 gcc 和 objdump，把汇编码和机器码都打印出来。汇编代码和机器码是一一对应的，一条汇编对应一条机器码。
可以说，汇编码就是给“给人看的机器码”
通常，同一个 ISA 规范下，每条机器码，通常都对应一行汇编代码~~&lt;/p>
&lt;h2 id="bytecode字节码">Bytecode(字节码)&lt;/h2>
&lt;p>&lt;strong>Bytecode(字节码)&lt;/strong> 也称为 &lt;strong>p-code(p 码)&lt;/strong>，是一种特殊的可以被执行的机器码 ** **，只不过被虚拟机执行。之所以称之为字节码，是指这里面的操作码(opcode)是—个字节长。一般机器指令由操作码和操作数组成，字节码(虚拟的机器码)也是由操作码(opcode)和操作数(op)组成。对于字节码，它是按照一套虚机指令集格式来组织。&lt;/p>
&lt;h1 id="指令--指令集--指令集架构">指令 &amp;amp; 指令集 &amp;amp; 指令集架构&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Instruction_set_architecture">Wiki,InstructionSetArchitecture&lt;/a>(指令集架构)&lt;/li>
&lt;li>&lt;a href="https://picture.iczhiku.com/weixin/message1583925567196.html">https://picture.iczhiku.com/weixin/message1583925567196.html&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://a-suozhang.xyz/2019/09/27/ISA/">https://a-suozhang.xyz/2019/09/27/ISA/&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>&lt;strong>Instruction set architecture(指令集架构，简称 ISA)&lt;/strong> 是软件和硬件之间的接口，是一套&lt;strong>标准规范&lt;/strong>，并不具备实体，我们可以根据这套规范去设计 CPU 和对应的软件系统，并最终形成产品。
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/cr7gm9/1652863904250-81b4f27e-82b5-446b-bba7-4ca408b4fb4c.png" alt="image.png">
常见的指令集如&lt;/p>
&lt;ul>
&lt;li>X86&lt;/li>
&lt;li>ARM&lt;/li>
&lt;li>RISC-V&lt;/li>
&lt;li>等&lt;/li>
&lt;/ul>
&lt;p>如果把软件和硬件看成螺母和螺钉，那么 ISA 就是螺母和螺钉之间对接的规范(e.g.尺寸、螺纹 之类的)。螺母和螺钉都按照相同的尺寸(i.e.相同的规范)去设计，即使是由不同的厂商来生产，也可以保证最终所有的螺钉都能拧到螺母上。
指令集向上承载的是整个软件生态，向下则规范了以处理器芯片为代表的整个硬件生态。根据一份指令集规范，设计一款处理器，其上可以运行同样遵循该指令集规范所编写的软件代码。&lt;strong>故而，我们在提到指令集的时候，有时候也指的是其背后的整个软硬件生态系统，包括外围芯片、操作系统、编译器和诸多应用软件（浏览器、游戏软件等）&lt;/strong>。事实证明，每一种芯片在市场竞争中要取得成功，很大程度上取决于其&lt;strong>生态系统&lt;/strong>。&lt;/p>
&lt;h1 id="crud增删改查">CRUD(增删改查)&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Create,_read,_update_and_delete">Wiki,CRUD&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>在计算机编程中，&lt;strong>Create、Read、Update、Delete(创建、读取、更新、删除，简称 增删改查(CRUD))&lt;/strong> 是持久性存储的四个基本操作。[1] CRUD 有时也用于描述用户界面约定，这些约定便于使用基于计算机的表单和报告查看、搜索和更改信息。这个词很可能是詹姆斯·马丁 (James Martin) 在他的 1983 著作《管理数据库环境》中首次推广的。
are the four basic operations of &lt;a href="https://en.wikipedia.org/wiki/Persistent_storage">persistent storage&lt;/a>.&lt;a href="https://en.wikipedia.org/wiki/Create,_read,_update_and_delete#cite_note-james-martin-1">[1]&lt;/a> CRUD is also sometimes used to describe &lt;a href="https://en.wikipedia.org/wiki/User_interface">user interface&lt;/a> conventions that facilitate viewing, searching, and changing information using computer-based &lt;a href="https://en.wikipedia.org/wiki/Form_(document)">forms&lt;/a> and &lt;a href="https://en.wikipedia.org/wiki/Report">reports&lt;/a>. The term was likely first popularized by &lt;a href="https://en.wikipedia.org/wiki/James_Martin_(author)">James Martin&lt;/a> in his 1983 book &lt;em>Managing the Data-base environment&lt;/em>.&lt;/p>
&lt;h1 id="projects项目">Projects(项目)&lt;/h1>
&lt;p>项目一般就是指开发一个程序。
从写代码的角度看，一个项目就是一个文件夹，该文件夹中包含该项目所需要依赖的第三方库，项目主体的代码，可执行文件等。&lt;/p>
&lt;h1 id="前端与后端">前端与后端&lt;/h1>
&lt;p>后端：一般是用来处理客户端发送的请求，并将前端写的 页面代码 文件，发送给客户端；或者从数据库获取数据，并填充到前端页面中；等等
前端：一般用来展示的，客户端收到的页面文件(比如输入用户名和密码的框，下拉框等等)，都是由前端工程师来写的，一般是 html 等。&lt;/p>
&lt;h2 id="前后端交互">前后端交互&lt;/h2>
&lt;p>前端与后端之间的交互取决于是前后端分离还不分离&lt;/p>
&lt;ul>
&lt;li>前后端不分离时，通常由后端代码渲染 html 等静态资源文件，&lt;strong>此时客户端访问的是由后端代码监听的端口&lt;/strong>&lt;/li>
&lt;li>前后端分离时，又分多种情况
&lt;ul>
&lt;li>将 html 等静态资源放在 Nginx 等可以提供 HTTP 服务的程序中，然后通过后端提供的 API 进行交互，&lt;strong>此时客户端访问的是由提供 HTTP 服务程序监听的端口&lt;/strong>&lt;/li>
&lt;li>将 html 等静态资源与后端代码放在一起，这种行为通常称为“XX 语言嵌入静态资源”，&lt;strong>此时客户端访问的是由后端程序监听的端口&lt;/strong>
&lt;ul>
&lt;li>比如 Go 语言在 1.16 版本中推出的 embed 库即可实现该效果&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h2 id="前端">前端&lt;/h2>
&lt;p>&lt;strong>htmx&lt;/strong> # 不使用 JavaScript 也可以和浏览器进行交互&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://mp.weixin.qq.com/s/oGk8QtvHwvPDDkOpR5dLzQ">https://mp.weixin.qq.com/s/oGk8QtvHwvPDDkOpR5dLzQ&lt;/a>&lt;/li>
&lt;/ul>
&lt;h1 id="库标准库第三方库与框架">库、标准库、第三方库与框架&lt;/h1>
&lt;p>每种编程语言都具有最基本的功能，比如输入、输出等，这些都属于基本库。比如我使用 print 想输出一些内容，则是调用输出所用的库来实现这个效果。这些基本库都是内置在各个编程语言当中的，可以直接调用。
但是有时候会有很复杂的需求， 比如对系统的某些程序进行操作、对数据库进行操作、写出来的程序如何设置子命令和参数等等等。这些复杂的需求，如果使用基本的编程语言来实现，是非常麻烦的，这时候如果有人可以提前使用编程语言的基本功能来创作一个可以实现某个具体功能的程序就好了。
这个创作出来的基本程序就可以称之为“库或者框架”
至于库和框架的区别：库的英语为 Library ( 简写 Lib )，框架的英语为 Framework。库和框架都是一种有别于软件、面向程序开发者的产品形式。正因为如此，也有很多人误以为库就是框架，或者认为指定语言的库就是框架。&lt;/p>
&lt;ul>
&lt;li>库：库是将代码集合成的一个产品，供程序员调用。面向对象的代码组织形式而成的库也叫类库。面向过程的代码组织形式而成的库也叫函数库。在函数库中的可直接使用的函数叫库函数。开发者在使用库的时候，只需要使用库的一部分类或函数，然后继续实现自己的功能。
&lt;ul>
&lt;li>标准库：就是各种语言自带的库，比如 go 里的 fmt 库，用来输出。这些标准库与语言的关键字构成了编程语言的基本功能。&lt;/li>
&lt;li>第三方库：是对编程语言的扩展，比如一种语言需要更多丰富的功能，而不仅有标准库的功能的时候，可以导入第三方库并使用它们。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>框架：框架则是为解决一个(一类)问题而开发的产品，框架用户一般只需要使用框架提供的类或函数，即可实现全部功能。可以说，框架是库的升级版。开发者在使用框架的时候，必须使用这个框架的全部代码。&lt;/li>
&lt;/ul>
&lt;p>库更像一个一个小的功能，比如使代码可以操作数据库这个功能，使代码可以监听在设备的某个端口上等等。
而框架则更像一个还没完成的程序，只有一些大体框架，其中具体的内容，可以根据自己的喜好去填充，说白了，就是一种规范，只要根据这个规范，就可以实现自己的某个程序。比如想开发一个 web 程序，就可以使用一个 web 框架，这个框架会给开发者直接提供一个基本的后端，至于其中的内容，开发者再去详细填写就好了
框架和库的比较可以想像为:
假如我们要买一台电脑：电脑内的每个部件就是编程语言的一个个关键字&lt;/p>
&lt;ol>
&lt;li>框架为我们提供了已经装好的电脑，我们只要买回来就能用，但你必须把整个电脑买回来。这样用户自然轻松许多，但会导致很多人用一样的电脑，或你想自定义某个部件将需要修改这个框架。&lt;/li>
&lt;li>库就如自己组装的电脑。库为我们提供了很多部件，我们需要自己组装，如果某个部件库未提供，我们也可以自己做。库的使用非常灵活，但没有框架方便。&lt;/li>
&lt;/ol>
&lt;p>然后通过对库和框架的使用，可以使该电脑实现我们自己想要的功能，比如玩游戏、办公、看电影等等。
程序开发中的框架(例如 1000 万+行的 Qt)往往是对常见功能的封装(类似于成语对常用含义的代指，不同点在于应用框架最终对 CPU 表达含义时候会把成语替换为原本含义-通过函数调用),抛开框架，程序会变得因缺少一些&amp;rsquo;固定成语&amp;rsquo;(函数)的&amp;rsquo;释义&amp;rsquo;(函数实现)而变得无法执行。
所以，程序框架理解为基础或者机械标准件(例如螺丝螺母这些有明确标准的机械部件)更为贴切。
这样理解，假如你要造一辆马车，在没有框架的情况下，你需要自己去伐木，去把木头做成木板，木棍，然后组成轮子，门，等部件，然后组装起来，但如果你用了框架，就相当于你有现成的轮子，门等部件，你只需要组装一下就可以了。
可以说，一个框架是一个可复用的设计构件，它规定了应用的体系结构，阐明了整个设计、协作构件之间的依赖关系、责任分配和控制流程，表现为一组抽象类以及其实例之间协作的方法，它为构件复用提供了上下文(Context)关系。因此构件库的大规模重用也需要框架。
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/cr7gm9/1616163790618-a4887423-a11b-4cfa-be93-a852be8c838f.jpeg" alt="">
拓展资料：
框架（Framework）是整个或部分系统的可重用设计，表现为一组抽象构件及构件实例间交互的方法;另一种定义认为，框架是可被应用开发者定制的应用骨架。前者是从应用方面而后者是从目的方面给出的定义。&lt;/p>
&lt;h2 id="例子">例子&lt;/h2>
&lt;p>拿 go 语言举例，当获取完一个第三方库之后(比如通过 go get 命令安装)，有时候会有一个命令行工具，比如 cobra，所以，也可以把库当做一个应用程序。而大部分时候，是不会出现一个命令行工具的，在获取完库之后，需要在 import 代码中进行引用，即可使用库中的相关函数。&lt;/p>
&lt;h1 id="编程规范">编程规范&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://mp.weixin.qq.com/s/EFMhFazZGVAoKkfwegm_TQ">无法忍受不做单元测试和内卷，我离开了这家在美中国企业&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;h2 id="method-stub">Method Stub&lt;/h2>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Method_stub">Wiki,Method stub&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>在软件开发中，&lt;strong>Method stub(方法存根)&lt;/strong> 是一段代码，用于代替某些其他编程功能&lt;/p></description></item><item><title>Docs: ✨3.集群与分布式</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/3.%E9%9B%86%E7%BE%A4%E4%B8%8E%E5%88%86%E5%B8%83%E5%BC%8F/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/3.%E9%9B%86%E7%BE%A4%E4%B8%8E%E5%88%86%E5%B8%83%E5%BC%8F/</guid><description/></item><item><title>Docs: 🌐4.数据通信</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/4.%E6%95%B0%E6%8D%AE%E9%80%9A%E4%BF%A1/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/4.%E6%95%B0%E6%8D%AE%E9%80%9A%E4%BF%A1/</guid><description/></item><item><title>Docs: 📼5.数据存储</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/5.%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/5.%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;h2 id="参考">参考：&lt;/h2>
&lt;/blockquote>
&lt;p>Data Storage(数据存储)&lt;/p>
&lt;h1 id="metadata元数据">Metadata(元数据)&lt;/h1>
&lt;p>又称中介数据、中继数据，为描述数据的数据（data about data），主要是描述数据属性（property）的信息，用来支持如指示存储位置、历史数据、资源查找、文件记录等功能。元数据算是一种电子式目录，为了达到编制目录的目的，必须在描述并收藏数据的内容或特色，进而达成协助数据检索的目的。都柏林核心集（Dublin Core Metadata Initiative，DCMI）是元数据的一种应用，是 1995 年 2 月由国际图书馆电脑中心（OCLC）和美国国家超级计算应用中心（National Center for Supercomputing Applications，NCSA）所联合赞助的研讨会，在邀请 52 位来自图书馆员、电脑专家，共同制定规格，创建一套描述网络上电子文件之特征。&lt;/p>
&lt;p>例：一个文件的创建日期，所在位置等，除了文件内容以外的东西都可以称之为元数据。&lt;/p>
&lt;h1 id="备份和归档的区别">备份和归档的区别&lt;/h1>
&lt;ol>
&lt;li>
&lt;p>不同的过程会导致不同的结果。归档最通用的定义是存储有组织的数据。归档的目的是长时间存放有组织的数据集，确保其将来能够被精细地检索。改进的磁带是这种应用最理想的方式。FujiFilm 对它的新一代 BaFe 磁带产品的弹性测试证明其数据保存能力很强，可以存储 30 年以上。 相比之下，磁盘的故障率比其制造商说的还要高，几年前 Carnegie Mellon University 和 Google 的研究记录证明了这一点。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>备份是短时间存储那些频繁更换或更新的数据的副本。这相当于一批廉价的离线介质上的数据副本。通过这种方式，可以把数据与那些基于磁盘的数据中断事件隔离开，以免同时遭到损坏，这样，如果原始数据或存储平台损坏的话，数据就可以恢复到任何磁盘阵列。在磁盘到磁盘复制解决方案中，复制只能发生在两个完全相同的设备中。此外，复制过程还可以中断，这样你就可以检查在主数据存储和镜像仓库之间的增量或差异。不过，最好别这样做，因为它可能会导致在磁盘到磁盘的复制过程中产生很多不易察觉的错误。 很遗憾，我发现你在努力保护你的数据时，它已经在阵列之间移动了，而你只镜像复制了一个空白空间&lt;/p>
&lt;/li>
&lt;/ol>
&lt;p>TechTarget 中国原创内容，原文链接： &lt;a href="https://searchstorage.techtarget.com.cn/6-23590/">https://searchstorage.techtarget.com.cn/6-23590/&lt;/a>&lt;/p></description></item><item><title>Docs: 👀6.可观测性</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/6.%E5%8F%AF%E8%A7%82%E6%B5%8B%E6%80%A7/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/6.%E5%8F%AF%E8%A7%82%E6%B5%8B%E6%80%A7/</guid><description/></item><item><title>Docs: 🔐7.信息安全</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/7.%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/7.%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8/</guid><description/></item><item><title>Docs: 📐8.通用技术</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/8.%E9%80%9A%E7%94%A8%E6%8A%80%E6%9C%AF/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/8.%E9%80%9A%E7%94%A8%E6%8A%80%E6%9C%AF/</guid><description/></item><item><title>Docs: 🛠️9.运维</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/9.%E8%BF%90%E7%BB%B4/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/9.%E8%BF%90%E7%BB%B4/</guid><description/></item><item><title>Docs: ☁️10.云原生</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/10.%E4%BA%91%E5%8E%9F%E7%94%9F/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/10.%E4%BA%91%E5%8E%9F%E7%94%9F/</guid><description/></item><item><title>Docs: 📹11.多媒体</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/11_%E5%A4%9A%E5%AA%92%E4%BD%93/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/11_%E5%A4%9A%E5%AA%92%E4%BD%93/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;h2 id="参考">参考：&lt;/h2>
&lt;/blockquote></description></item><item><title>Docs: 🤖12.人工智能</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/12.%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/12.%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;p>NovelAI # &lt;a href="https://novelai.net/">https://novelai.net/&lt;/a> 写故事、作图&lt;/p>
&lt;h1 id="chatgpt">ChatGPT&lt;/h1>
&lt;p>&lt;a href="https://github.com/wangrongding/wechat-bot">https://github.com/wangrongding/wechat-bot&lt;/a>
&lt;a href="https://github.com/fuergaosi233/wechat-chatgpt">https://github.com/fuergaosi233/wechat-chatgpt&lt;/a>&lt;/p>
&lt;p>注册 ChatGPT # &lt;a href="https://zblogs.top/how-to-register-openai-chatgpt-in-china/">https://zblogs.top/how-to-register-openai-chatgpt-in-china/&lt;/a>&lt;/p>
&lt;p>使用虚拟号码接收短信验证码：https://sms-activate.org/&lt;/p>
&lt;h2 id="基于-chatgpt-的项目">基于 ChatGPT 的项目&lt;/h2>
&lt;p>Chrom 插件&lt;/p>
&lt;p>&lt;a href="https://github.com/wong2/chat-gpt-google-extension">https://github.com/wong2/chat-gpt-google-extension&lt;/a>&lt;/p>
&lt;p>&lt;a href="https://github.com/gragland/chatgpt-chrome-extension">https://github.com/gragland/chatgpt-chrome-extension&lt;/a>&lt;/p>
&lt;p>逆向&lt;/p>
&lt;p>&lt;a href="https://github.com/acheong08/ChatGPT">https://github.com/acheong08/ChatGPT&lt;/a>&lt;/p>
&lt;p>微信接入&lt;/p>
&lt;p>&lt;a href="https://github.com/fuergaosi233/wechat-chatgpt">https://github.com/fuergaosi233/wechat-chatgpt&lt;/a>&lt;/p>
&lt;ul>
&lt;li>用法：&lt;a href="https://mp.weixin.qq.com/s/dLzemMUcIfjvWd_AF_yDJw">https://mp.weixin.qq.com/s/dLzemMUcIfjvWd_AF_yDJw&lt;/a>&lt;/li>
&lt;/ul>
&lt;p>&lt;a href="https://github.com/AutumnWhj/ChatGPT-wechat-bot">https://github.com/AutumnWhj/ChatGPT-wechat-bot&lt;/a>&lt;/p>
&lt;p>接入 GitLab&lt;/p>
&lt;p>&lt;a href="https://mp.weixin.qq.com/s/y_ppQdKVXWZPNyP9BxGWpg">https://mp.weixin.qq.com/s/y_ppQdKVXWZPNyP9BxGWpg&lt;/a>&lt;/p></description></item><item><title>Docs: 🧊区块链</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%8C%BA%E5%9D%97%E9%93%BE/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%8C%BA%E5%9D%97%E9%93%BE/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://www.bilibili.com/video/BV1T34y117Y9">B 站，汪杰解惑 NFT-02&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>2008 年 10 月 31 日 《Bitconi: A Peer-to-Peer Electronic Cash System 》&lt;/p>
&lt;ul>
&lt;li>保证信息的完整性和真实性&lt;/li>
&lt;li>保证信息的不可否认性&lt;/li>
&lt;/ul>
&lt;h1 id="数字加密货币">数字加密货币&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>如何把狗狗币|柴犬币 shib|放在 imtoken 钱包和 metamask 狐狸钱包中？
&lt;ul>
&lt;li>这里教如何添加代币，如何添加钱包中的网络&lt;/li>
&lt;li>&lt;a href="https://www.youtube.com/watch?v=Gn4FCh5DEvg">https://www.youtube.com/watch?v=Gn4FCh5DEvg&lt;/a>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>【狐狸钱包】一分钟学会，如何一键添加各种主网？
&lt;ul>
&lt;li>&lt;a href="https://www.youtube.com/watch?v=f1JU8TGImA0">https://www.youtube.com/watch?v=f1JU8TGImA0&lt;/a>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>钱包&lt;/p>
&lt;ul>
&lt;li>MetaMask 钱包&lt;/li>
&lt;li>Coinbase Wallet 钱包&lt;/li>
&lt;li>imtoken 钱包&lt;/li>
&lt;/ul>
&lt;p>NFT 交易平台&lt;/p>
&lt;ul>
&lt;li>OpenSea&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>Percentage Fee(版税)&lt;/strong> # 即提成的百分比。每次 NFT 交易时，最初的创建者会获得交易额的百分比的收入。
**Gas Fee(气体费) **# 铸造一个 NFT 是有成本的，需要向矿工支付 Gas Fee&lt;/p>
&lt;p>钱包中的网络：就是“链”也就是“区块链”的链。在各种链上，可以搜索在当钱链上的交易记录。&lt;/p>
&lt;h2 id="eth">ETH&lt;/h2>
&lt;p>&lt;strong>Etherscan 是&lt;/strong>以太坊网络的区块链浏览器。 该网站可用于搜索交易、区块、钱包地址、智能合约以及其它链上数据，属于最热门的以太坊区块链浏览器之一，免费向用户开放。 使用&lt;strong>Etherscan&lt;/strong>即可详细了解如何与区块链、其他钱包以及 DAapp 进行交互&lt;/p>
&lt;p>&lt;a href="https://etherscan.io/address/0xED783c0ee7444435d31555f0Ab23E30ac2d0a9Eb">https://etherscan.io/address/0xED783c0ee7444435d31555f0Ab23E30ac2d0a9Eb&lt;/a>&lt;/p>
&lt;h2 id="链">链&lt;/h2>
&lt;ul>
&lt;li>HECO # 火币的链
&lt;ul>
&lt;li>火币的“区块链浏览器”&lt;a href="https://hecoinfo.com/">https://hecoinfo.com/&lt;/a>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Etherscan # 以太坊的链
&lt;ul>
&lt;li>以太坊的“区块链浏览器”&lt;a href="https://etherscan.io/">https://etherscan.io/&lt;/a>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h2 id="应用示例">应用示例&lt;/h2>
&lt;p>当我们从交易所中将各种数字货币提取到钱包中后，虽然可以看到交易已完成，但是我们在钱包中却看不到。&lt;/p>
&lt;p>这是因为，在我们提币时，需要填写一个“提币网络”，这个“提币网络”其实就是指的区块链中的“链”，对应的就是各个钱包中的“网络”。&lt;/p>
&lt;p>所以我们首先应该先为钱包添加对应交易的“链”。&lt;/p>
&lt;h3 id="添加链">添加链&lt;/h3>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/lddbaw/1647499683695-dd622c13-b54a-4ff3-b643-63f616244c4e.png" alt="image.png">
从对应的“链”找到其 URL，这里以火币的 HECO 链为例，从&lt;a href="https://hecoinfo.com/apis#rpc">这里&lt;/a>可以找到 HECO 的 Endpoint 与 链 ID
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/lddbaw/1647499855988-a4357488-abd5-436f-abb8-805f64774e9f.png" alt="image.png">
然后将 Endpoint 和 链 ID 填入，即可在钱包中添加“链”
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/lddbaw/1647499879301-9ec3af5b-4d36-495b-ade5-41710057a624.png" alt="image.png">
后续提币的操作时，我们选择的“提币网络”也要与“链”对应上才行，交易记录通常都是保存在交易双方所在的链上。&lt;/p>
&lt;h3 id="获取交易记录-h">获取交易记录 h&lt;/h3>
&lt;p>在火币交易记录查到 &lt;code>交易ID&lt;/code>
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/lddbaw/1647498496139-aa024459-ea29-47f5-b918-400007cd2539.png" alt="image.png">&lt;/p>
&lt;h3 id="获取代币的合约地址">获取代币的合约地址&lt;/h3>
&lt;p>在&lt;a href="https://hecoinfo.com/">火币链&lt;/a>页面搜索该交易
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/lddbaw/1647498548140-52d38f6c-0e7b-4a3b-89d8-2907bea8d3c9.png" alt="image.png">
可以获取到交易细节，然后查看 Tokens Transferred 中的 &lt;code>For&lt;/code> 信息
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/lddbaw/1647498734107-01e68293-ec25-4b4d-9db8-1c5ca84a8552.png" alt="image.png">
然后就可以获取到交易代币的合约地址
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/lddbaw/1647498797213-df1d9e0c-c2b7-466c-8936-58f930d053ab.png" alt="image.png">
这个地址就是钱包中，添加自定义代币时，所使用的地址。&lt;/p>
&lt;ul>
&lt;li>USDT: 0xa71edc38d189767582c38a3145b5873052c3e47a&lt;/li>
&lt;li>DOGE: 0x40280E26A572745B1152A54D1D44F365DaA51618&lt;/li>
&lt;/ul>
&lt;h3 id="导入代币">导入代币&lt;/h3>
&lt;p>填入地址后，代币符号与小数精度将会自动出现
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/lddbaw/1647498857327-a04a31ff-ff5c-4e32-8809-8bcc8582bdd2.png" alt="image.png">&lt;/p></description></item><item><title>Docs: 🧰实用工具</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%AE%9E%E7%94%A8%E5%B7%A5%E5%85%B7/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%AE%9E%E7%94%A8%E5%B7%A5%E5%85%B7/</guid><description>
&lt;h1 id="实用工具">实用工具&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://mp.weixin.qq.com/s/FER8XiGizhNOwAXf7cQbRQ">公众号-差评，我从三百条留言中，筛选出了差友们推荐的好用软件&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>360 文件夹 # 包含类似 Everythiny 的功能，完美代替 windows 自带的资源管理器。&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://bbs.360.cn/thread-16040300-1-1.html">https://bbs.360.cn/thread-16040300-1-1.html&lt;/a>&lt;/li>
&lt;/ul>
&lt;p>Geek Uninstaller # 彻底写在软件&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://geekuninstaller.com/">https://geekuninstaller.com/&lt;/a>&lt;/li>
&lt;/ul>
&lt;h2 id="windows-磁盘空间管理工具">Windows 磁盘空间管理工具&lt;/h2>
&lt;p>SpaceSniffer
官网：&lt;a href="http://www.uderzo.it/main_products/space_sniffer/">http://www.uderzo.it/main_products/space_sniffer/&lt;/a>&lt;/p>
&lt;p>Dism++
&lt;a href="https://github.com/Chuyu-Team/Dism-Multi-language">https://github.com/Chuyu-Team/Dism-Multi-language&lt;/a>&lt;/p>
&lt;h2 id="everything">Everything&lt;/h2>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://www.voidtools.com/">官网&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>适用于 Windows 的全局搜索工具，非常小巧好用！！！&lt;/p>
&lt;h2 id="esearch">eSearch&lt;/h2>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://github.com/xushengfeng/eSearch">GitHub 项目，xushengfeng/eSearch&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://esearch-app.netlify.app/">官网&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>截屏、离线 OCR、搜索翻译、以图搜图、贴图、录屏、滚动截屏&lt;/p>
&lt;h1 id="樱桃键盘">樱桃键盘&lt;/h1>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/na3u1y/1654068821514-75ee0957-87fb-44b4-bcbf-c635517dc6fc.png" alt="image.png">&lt;/p>
&lt;h1 id="国外产品">国外产品&lt;/h1>
&lt;p>Facebook
Twitter
Google
Spotify
Snapchat
Instagram
Shopify
Reddit
Twitch
Youtube
TikTok
Pinterest&lt;/p></description></item><item><title>Docs: 📚标准化术语</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/x_%E6%A0%87%E5%87%86%E5%8C%96%E6%9C%AF%E8%AF%AD/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/x_%E6%A0%87%E5%87%86%E5%8C%96%E6%9C%AF%E8%AF%AD/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;h2 id="参考">参考：&lt;/h2>
&lt;/blockquote>
&lt;p>StandardizedGlossary(标准化术语)&lt;/p>
&lt;h1 id="黑盒学习-与-白盒学习">黑盒学习 与 白盒学习&lt;/h1>
&lt;p>学习过程分两种&lt;/p>
&lt;ul>
&lt;li>黑盒 # 看看这个知识点与周围其他系统之间的关系，以及互相作用的效果。了解基本工作逻辑&lt;/li>
&lt;li>白盒 # 打开待学习的知识点，直接学习知识点的原理&lt;/li>
&lt;/ul>
&lt;p>要掌握一个学科的精髓，不能从细枝末节开始。人脑的能力很大程度上受限于信念。一个人不相信自己的时候，他就做不到本来可能的事。信心是很重要的，信心却容易被挫败。如果只见树木不见森林，人会失去信心，以为要到猴年马月才能掌握一个学科。&lt;/p>
&lt;p>所以我们不从 “树木” 开始，而是引导读者一起来探索这背后的“森林”，把计算机科学最根本的概念用浅显的例子解释，让读者领会到它们的本质。把这些概念稍作发展，你就得到逐渐完整的把握。你一开头就掌握着整个学科，而且一直掌握着它，只不过增添更多细节而已。这就像画画，先勾勒出轮廓，一遍遍的增加细节，日臻完善，却不失去对大局的把握。&lt;/p>
&lt;h1 id="bare-metal裸金属">Bare metal(裸金属)&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Bare_machine">Wiki,Bare machine&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>在计算机科学中，&lt;strong>Bare metal(裸金属)&lt;/strong> 也称为 &lt;strong>Bare machine(裸机)&lt;/strong>，是指在没有介入操作系统的逻辑硬件上执行指令的计算机。&lt;/p>
&lt;p>在很多软件的部署文档中，Bare metal 经常作为部署方式的一种，但是这时候裸金属部署，并不是真的在没有操作系统的服务器上安装软件，而是指在没有其他通用平台上安装，说白了，就是指&lt;strong>原始安装&lt;/strong>&lt;/p></description></item></channel></rss>