<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>断念梦 – PromQL</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/6.%E5%8F%AF%E8%A7%82%E6%B5%8B%E6%80%A7/%E7%9B%91%E6%8E%A7%E7%B3%BB%E7%BB%9F/prometheus/promql/</link><description>Recent content in PromQL on 断念梦</description><generator>Hugo -- gohugo.io</generator><atom:link href="https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/6.%E5%8F%AF%E8%A7%82%E6%B5%8B%E6%80%A7/%E7%9B%91%E6%8E%A7%E7%B3%BB%E7%BB%9F/prometheus/promql/index.xml" rel="self" type="application/rss+xml"/><item><title>Docs: Aggregation Operators(聚合运算符)</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/6.%E5%8F%AF%E8%A7%82%E6%B5%8B%E6%80%A7/%E7%9B%91%E6%8E%A7%E7%B3%BB%E7%BB%9F/prometheus/promql/aggregation-operators%E8%81%9A%E5%90%88%E8%BF%90%E7%AE%97%E7%AC%A6/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/6.%E5%8F%AF%E8%A7%82%E6%B5%8B%E6%80%A7/%E7%9B%91%E6%8E%A7%E7%B3%BB%E7%BB%9F/prometheus/promql/aggregation-operators%E8%81%9A%E5%90%88%E8%BF%90%E7%AE%97%E7%AC%A6/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://prometheus.io/docs/prometheus/latest/querying/operators/#aggregation-operators">官方文档,Prometheus-查询-运算符-聚合运算符&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>Prometheus 还提供了下列内置的聚合运算符，这些运算符仅作用于瞬时向量。可以将瞬时表达式返回的样本数据进行聚合，形成一个新的时间序列。&lt;/p>
&lt;ul>
&lt;li>sum (求和)&lt;/li>
&lt;li>min (最小值)&lt;/li>
&lt;li>max (最大值)&lt;/li>
&lt;li>avg (平均值)&lt;/li>
&lt;li>stddev (标准差)&lt;/li>
&lt;li>stdvar (标准差异)&lt;/li>
&lt;li>count (计数)&lt;/li>
&lt;li>count_values (对 value 进行计数)&lt;/li>
&lt;li>bottomk (后 n 条时序)&lt;/li>
&lt;li>topk (前 n 条时序)&lt;/li>
&lt;li>quantile (分布统计)&lt;/li>
&lt;/ul>
&lt;h2 id="syntax语法">Syntax(语法)&lt;/h2>
&lt;p>&lt;strong>[AggregationOperators] [without|by (LabelName,&amp;hellip;.)] ([Parameter,&amp;hellip;] VectorExpression)&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>&lt;strong>Aggregation Operators&lt;/strong> # 聚合运算符&lt;/li>
&lt;li>&lt;strong>without|by (LabelName,&amp;hellip;)&lt;/strong> # 若不指定该选项，则聚合全部数据的值。如果指定了，则按照指定的 LabelName 进行聚合。通过 without 和 by 可以按照样本的问题对数据进行聚合。该用法的示例图详见文末
&lt;ul>
&lt;li>&lt;strong>by&lt;/strong> # 聚合 by 后面指定的 LabelName 样本数据，并将聚合以外的标签的移除&lt;/li>
&lt;li>&lt;strong>without&lt;/strong> # 与 by 相反，聚合 without 后面没有指定的 LabelName 样本数据。并将聚合以外的标签的移除&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>Parameter #&lt;/strong> 参数，其中只有 count_values, quantile, topk, bottomk 支持&lt;/li>
&lt;li>&lt;strong>VectorExpression&lt;/strong> # 向量表达式。详见 &lt;a href="https://desistdaydream.github.io/docs/IT%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/6.%E5%8F%AF%E8%A7%82%E6%B5%8B%E6%80%A7/%E7%9B%91%E6%8E%A7%E7%B3%BB%E7%BB%9F/Prometheus/PromQL/PromQL.md">PromQL&lt;/a> 章节&lt;/li>
&lt;/ul>
&lt;h1 id="sum-与-min-与-max-与-avg-详解">sum 与 min 与 max 与 avg 详解&lt;/h1>
&lt;h1 id="count-与-count_values-详解">count 与 count_values 详解&lt;/h1>
&lt;p>EXAMPLE&lt;/p>
&lt;ul>
&lt;li>计算 up 序列 的值为 1 的序列总数
&lt;ul>
&lt;li>count by(job, namespace, service) (up == 1)&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h1 id="quantile-详解">quantile 详解&lt;/h1>
&lt;p>参考：
&lt;a href="https://cloud.tencent.com/developer/news/319419">https://cloud.tencent.com/developer/news/319419&lt;/a>
&lt;a href="https://www.zhihu.com/question/20575291">https://www.zhihu.com/question/20575291&lt;/a>&lt;/p>
&lt;p>其实，在 Prometheus 中，把 quantile(分位数)改为 percentile(百分位数)更准确&lt;/p>
&lt;p>在这么一组数中&lt;/p>
&lt;p>18,6,250,4,21,10,1,1,4274,5,102,15,5,3,10,1,5,3,177,5,34,45,1,5,15&lt;/p>
&lt;p>quantile(0.5,上述所有数的集合)，如果使用该公式计算 0.5 百分位数，则值为 6。也就是说，比 6 大数的有 50%，比 6 小的数有 50%&lt;/p>
&lt;p>quantile(0.99,上述所有数的集合)，如果使用该公式计算 0.99 百分位数，则值为 3308.239999999992。比 3308 大的数有 1%，比 3308 小的有 99%&lt;/p>
&lt;p>如果使用响应时间来举例，那么，0.99 百分位的值为 10，意味着：在此时此刻，所有请求的响应时间中，有 99%都是 10 以上秒，剩下的不到 10 秒&lt;/p>
&lt;h1 id="example">Example&lt;/h1>
&lt;p>如果 http_requests_total 指标一共有 3 个 label，分别是 application、instance、group。那么下面的两种运算方式得出的结果是一样的&lt;/p>
&lt;ul>
&lt;li>sum without (instance) (http_requests_total)&lt;/li>
&lt;li>等价于&lt;/li>
&lt;li>sum by (code,handler,job,method) (http_requests_total)&lt;/li>
&lt;/ul>
&lt;p>如果只需要计算整个应用的 HTTP 请求总量，可以直接使用表达式&lt;/p>
&lt;ul>
&lt;li>sum(http_requests_total)&lt;/li>
&lt;/ul>
&lt;p>count_values 用于时间序列中每一个样本值出现的次数。count_values 会为每一个唯一的样本值输出一个时间序列，并且每一个时间序列包含一个额外的标签。&lt;/p>
&lt;ul>
&lt;li>count_values(&amp;ldquo;count&amp;rdquo;, http_requests_total)&lt;/li>
&lt;/ul>
&lt;p>topk 和 bottomk 则用于对样本值进行排序，返回当前样本值前 n 位，或者后 n 位的时间序列。获取 HTTP 请求数前 5 位的时序样本数据，可以使用表达式：&lt;/p>
&lt;ul>
&lt;li>topk(5, http_requests_total)&lt;/li>
&lt;/ul>
&lt;p>quantile 用于计算当前样本数据值的分布情况 quantile(φ, express)其中 0 ≤ φ ≤ 1。例如，当 φ 为 0.5 时，即表示找到当前样本数据中的中位数&lt;/p>
&lt;ul>
&lt;li>quantile(0.5, http_requests_total)&lt;/li>
&lt;/ul>
&lt;h1 id="效果示例图">效果示例图&lt;/h1>
&lt;p>不进行聚合运算的数据
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/fybu67/1616069162982-ceaed866-8e18-4a11-ba5b-a248b397ef1d.jpeg" alt="">
不使用 by 或者 without，聚合运算所有数据，得出唯一一个值
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/fybu67/1616069162971-82c3f7c8-4fd3-4e75-be31-b7c41e43b2d5.jpeg" alt="">
使用 by，聚合具有相同 namespace 的样本值，得出一个或多个值
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/fybu67/1660618023658-45664731-5ddb-455f-8a7b-42ad1c3c3dfa.png" alt="image.png">&lt;/p></description></item><item><title>Docs: Binary Operators(二元运算符)</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/6.%E5%8F%AF%E8%A7%82%E6%B5%8B%E6%80%A7/%E7%9B%91%E6%8E%A7%E7%B3%BB%E7%BB%9F/prometheus/promql/binary-operators%E4%BA%8C%E5%85%83%E8%BF%90%E7%AE%97%E7%AC%A6/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/6.%E5%8F%AF%E8%A7%82%E6%B5%8B%E6%80%A7/%E7%9B%91%E6%8E%A7%E7%B3%BB%E7%BB%9F/prometheus/promql/binary-operators%E4%BA%8C%E5%85%83%E8%BF%90%E7%AE%97%E7%AC%A6/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://prometheus.io/docs/prometheus/latest/querying/operators/#binary-operators">官方文档&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>PromQL 支持基本的 逻辑 和 算术 运算符。 对于两个即时向量之间的运算，可以修改匹配行为。&lt;/p>
&lt;p>使用 PromQL 除了能够方便的按照查询和过滤时间序列以外，PromQL 还支持丰富的运算符，用户可以使用这些运算符对进一步的对事件序列进行二次加工。这些运算符包括：数学运算符，逻辑运算符，布尔运算符等等。&lt;/p>
&lt;p>&lt;strong>官方文档中，将时间序列中的标签称为 element(元素)&lt;/strong>&lt;/p>
&lt;h1 id="arithmetic算术-二元运算符">Arithmetic(算术) 二元运算符&lt;/h1>
&lt;p>PromQL 支持以下算术二元运算符：&lt;/p>
&lt;ul>
&lt;li>
&lt;ul>
&lt;li>(加法)&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;ul>
&lt;li>(减法)&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;ul>
&lt;li>(乘法)&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>/ (除法)&lt;/li>
&lt;li>% (求余)&lt;/li>
&lt;li>^ (幂运算)&lt;/li>
&lt;/ul>
&lt;p>算术二元运算符可以实现如下三种类型的运算：&lt;/p>
&lt;ul>
&lt;li>&lt;strong>Between two scalars(标量与标量)&lt;/strong>&lt;/li>
&lt;li>**Between an instant vector and a scalar(即时向量与标量) **&lt;/li>
&lt;li>&lt;strong>Between two instant vectors(即时向量与即时向量)&lt;/strong>&lt;/li>
&lt;/ul>
&lt;h2 id="between-two-scalars标量与标量">Between two scalars(标量与标量)&lt;/h2>
&lt;p>就是普通的数学运算，类似于 1+1、2*3 等等，直接获取一个标量结果&lt;/p>
&lt;h2 id="between-an-instant-vector-and-a-scalar即时向量与标量">Between an instant vector and a scalar(即时向量与标量)&lt;/h2>
&lt;p>当瞬时向量与标量之间进行数学运算时，数学运算符会依次作用域瞬时向量中的每一个样本值，从而得到一组新的时间序列。
与 标量之间 的二元运算一样，只不过将即时向量表达式获取到的所有时间序列的值与标量进行运算，效果如下：
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/zpuhbm/1626438137638-8b462402-4042-4c0d-b030-fc186973d5ab.png" alt="image.png">
经过运算后：
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/zpuhbm/1626438160237-51de2eda-a03a-494a-8b86-16ffdaeb0551.png" alt="image.png">&lt;/p>
&lt;h2 id="between-two-instant-vectors即时向量与即时向量">Between two instant vectors(即时向量与即时向量)&lt;/h2>
&lt;p>如果是即时向量与即时向量之间进行数学运算时，过程会相对复杂一点。 例如，如果我们想根据 node_disk_bytes_written 和 node_disk_bytes_read 获取主机磁盘 IO 的总量，可以使用如下表达式：&lt;/p>
&lt;pre>&lt;code>node_disk_read_bytes_total + node_disk_written_bytes_total
&lt;/code>&lt;/pre>
&lt;p>那这个表达式是如何工作的呢？依次找到与左边向量表达式的标签完全匹配的右边向量表示，并将两者进行进行运算。同时新的时间序列将不会包含指标名称。 该表达式返回结果的示例如下所示：
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/zpuhbm/1626440024200-621fc788-29f8-4455-b933-4dbc3fa3a881.png" alt="image.png">
如果运算符左右两边的向量表达式没有匹配到，则直接丢弃，效果如下：
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/zpuhbm/1626440170722-a5bee3be-4df9-4553-9525-3aadd8c193f0.png" alt="image.png">&lt;/p>
&lt;h1 id="comparison比较-运算符">Comparison(比较) 运算符&lt;/h1>
&lt;p>目前，Prometheus 支持以下布尔运算符如下：&lt;/p>
&lt;ul>
&lt;li>== (相等)&lt;/li>
&lt;li>!= (不相等)&lt;/li>
&lt;li>
&lt;blockquote>
&lt;p>(大于)&lt;/p>
&lt;/blockquote>
&lt;/li>
&lt;li>&amp;lt; (小于)&lt;/li>
&lt;li>
&lt;blockquote>
&lt;p>= (大于等于)&lt;/p>
&lt;/blockquote>
&lt;/li>
&lt;li>&amp;lt;= (小于等于)&lt;/li>
&lt;/ul>
&lt;p>在 PromQL 通过标签匹配模式，用户可以根据时间序列的特征维度对其进行查询。而 比较运算 则支持用户根据时间序列中样本的值，对时间序列进行过滤。&lt;/p>
&lt;p>比如有这么一种场景：&lt;/p>
&lt;ul>
&lt;li>通过数学运算符我们可以很方便的计算出，当前所有主机节点的内存使用率：
&lt;ul>
&lt;li>(node_memory_bytes_total - node_memory_free_bytes_total) / node_memory_bytes_total&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>而系统管理员在排查问题的时候可能只想知道当前内存使用率超过 95%的主机呢？通过使用比较运算，就可以方便的获取到该结果：
&lt;ul>
&lt;li>(node_memory_bytes_total - node_memory_free_bytes_total) / node_memory_bytes_total &amp;gt; 0.95&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>即时向量与标量进行布尔运算时，PromQL 依次比较向量中的所有时间序列样本的值，如果比较结果为 true 则保留，反之丢弃。&lt;/p>
&lt;p>即时向量与即时向量直接进行布尔运算时，同样遵循默认的匹配模式：依次找到与左边向量元素匹配（标签完全一致）的右边向量元素进行相应的运算，如果没找到匹配元素，则直接丢弃。&lt;/p>
&lt;h2 id="使用-bool-修饰符改变比较运算符的行为">使用 bool 修饰符改变比较运算符的行为&lt;/h2>
&lt;p>布尔运算符的默认行为是对时序数据进行过滤。而在其它的情况下我们可能需要的是真正的布尔结果。例如，只需要知道当前模块的 HTTP 请求量是否&amp;gt;=1000，如果大于等于 1000 则返回 1（true）否则返回 0（false）。这时可以使用 bool 修饰符改变布尔运算的默认行为。 例如：&lt;/p>
&lt;pre>&lt;code>http_requests_total &amp;gt; bool 1000
&lt;/code>&lt;/pre>
&lt;p>使用 bool 修改符后，布尔运算不会对时间序列进行过滤，而是直接依次瞬时向量中的各个样本数据与标量的比较结果 0 或者 1。从而形成一条新的时间序列。&lt;/p>
&lt;pre>&lt;code>http_requests_total{code=&amp;quot;200&amp;quot;,handler=&amp;quot;query&amp;quot;,instance=&amp;quot;localhost:9090&amp;quot;,job=&amp;quot;prometheus&amp;quot;,method=&amp;quot;get&amp;quot;} 1
http_requests_total{code=&amp;quot;200&amp;quot;,handler=&amp;quot;query_range&amp;quot;,instance=&amp;quot;localhost:9090&amp;quot;,job=&amp;quot;prometheus&amp;quot;,method=&amp;quot;get&amp;quot;} 0
&lt;/code>&lt;/pre>
&lt;p>同时需要注意的是，如果是在两个标量之间使用布尔运算，则必须使用 bool 修饰符&lt;/p>
&lt;p>2 == bool 2 # 结果为 1&lt;/p>
&lt;h1 id="logical逻辑-运算符">Logical(逻辑) 运算符&lt;/h1>
&lt;p>目前，Prometheus 支持以下逻辑运算符(这些运算符只能作用在瞬时向量上)：&lt;/p>
&lt;ul>
&lt;li>and (并且)&lt;/li>
&lt;li>or (或者)&lt;/li>
&lt;li>unless (排除)&lt;/li>
&lt;/ul>
&lt;p>使用即时向量表达式能够获取到一个包含多个时间序列的集合，我们称为瞬时向量。 通过集合运算，可以在两个瞬时向量与瞬时向量之间进行相应的集合操作。&lt;/p>
&lt;p>vector1 and vector2 会产生一个由 vector1 的元素组成的新的向量。该向量包含 vector1 中完全匹配 vector2 中的元素组成。&lt;/p>
&lt;p>vector1 or vector2 会产生一个新的向量，该向量包含 vector1 中所有的样本数据，以及 vector2 中没有与 vector1 匹配到的样本数据。&lt;/p>
&lt;p>vector1 unless vector2 会产生一个新的向量，新向量中的元素由 vector1 中没有与 vector2 匹配的元素组成。&lt;/p>
&lt;h1 id="运算符优先级">运算符优先级&lt;/h1>
&lt;p>对于复杂类型的表达式，需要了解运算操作的运行优先级&lt;/p>
&lt;p>例如，查询主机的 CPU 使用率，可以使用表达式：&lt;/p>
&lt;pre>&lt;code>100 * (1 - avg (irate(node_cpu{mode='idle'}[5m])) by(job) )
&lt;/code>&lt;/pre>
&lt;p>其中 irate 是 PromQL 中的内置函数，用于计算区间向量中时间序列每秒的即时增长率。关于内置函数的部分，会在下一节详细介绍。&lt;/p>
&lt;p>在 PromQL 操作符中优先级由高到低依次为：&lt;/p>
&lt;ol>
&lt;li>^&lt;/li>
&lt;li>*, /, %&lt;/li>
&lt;li>+, -&lt;/li>
&lt;li>==, !=, &amp;lt;=, &amp;lt;, &amp;gt;=, &amp;gt;&lt;/li>
&lt;li>and, unless&lt;/li>
&lt;li>or&lt;/li>
&lt;/ol></description></item><item><title>Docs: PromQL</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/6.%E5%8F%AF%E8%A7%82%E6%B5%8B%E6%80%A7/%E7%9B%91%E6%8E%A7%E7%B3%BB%E7%BB%9F/prometheus/promql/promql/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/6.%E5%8F%AF%E8%A7%82%E6%B5%8B%E6%80%A7/%E7%9B%91%E6%8E%A7%E7%B3%BB%E7%BB%9F/prometheus/promql/promql/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://prometheus.io/docs/prometheus/latest/querying/basics/">官方文档，Prometheus-查询-基础&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>**Prometheus Query Language(Prometheus 查询语言，简称 PromQL) **是一种提供了查询功能的编程语言，用来实时选择和汇总 &lt;a href="https://www.yuque.com/go/doc/33147376">&lt;strong>TimeSeries(时间序列)&lt;/strong>&lt;/a> 数据。通过 PromQL 可以对监控数据进行筛选、过滤、组合等等操作。使用 PromQL 编写的语句也可以称为 &lt;strong>Expression(表达式)&lt;/strong>，表达式的结果可以通过其他方式显示为图形。&lt;/p>
&lt;h2 id="promql-体验">PromQL 体验&lt;/h2>
&lt;p>在 graph 页面，可以在红框位置输入表达式
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/lfubxg/1616069073146-722bd1dd-2647-4bf9-84ed-4c2cbf694785.png" alt="">
点击红框内的对话框 并输入关键字，系统会自动弹出可用的 metrics name
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/lfubxg/1616069073181-bbf09f64-c80f-4e9f-9644-2916ce031358.jpeg" alt="">
表达式直接使用 MetricsName，则展示此时此刻的以 node_cpu_seconds_total 为指标名的所有 TimeSeries(时间序列) 数据
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/lfubxg/1616069073159-7b2a2e59-5866-478c-a87e-a9c6e42a65d5.png" alt="">
如果需要筛选则可以输入如下图实例的表达式：node_cpu_seconds_total{job=~&amp;ldquo;external.*&amp;rdquo;}&lt;/p>
&lt;p>筛选出来 job 名开头是 external 的 cpu 情况。允许使用正则表达式，=~表示的就是用过正则来匹配后面的值
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/lfubxg/1616069073186-857243c7-7acb-4a2a-9787-ecd8dabbf732.jpeg" alt="">
Prometheus 通过 MetricsName(指标名称) 及其对应的一组 LabelSet(标签集) 定义唯一的一条时间序列。指标名称反映了监控样本的基本标识，而 label 则在这个基本特征上为采集到的数据提供了多种特征维度。用户可以基于这些特征维度过滤，聚合，统计从而产生新的计算后的一条时间序列。&lt;/p>
&lt;p>PromQL 是 Prometheus 内置的数据查询语言，其提供对时间序列数据丰富的查询，聚合以及逻辑运算能力的支持。并且被广泛应用在 Prometheus 的日常应用当中，包括对数据查询、可视化、告警处理当中。可以这么说，PromQL 是 Prometheus 所有应用场景的基础，理解和掌握 PromQL 是 Prometheus 入门的第一课。&lt;/p>
&lt;h1 id="promql-基本语法">PromQL 基本语法&lt;/h1>
&lt;p>PromQL 没有绝对通用的语法，在不同场景查询条件下，语法也不同。但是，语法必须要有语句，这种语句就称为 &lt;strong>Expression(表达式)&lt;/strong>，Expression 可以是简单的字符串，也可以是一个指标名称，甚至是一串基于指标的复杂语法。&lt;/p>
&lt;p>在 PromQL 中，任何 &lt;strong>Expression(表达式)&lt;/strong> 或者 &lt;strong>subExpression(子表达式)&lt;/strong> 都可以归为四种类型：&lt;/p>
&lt;ul>
&lt;li>&lt;strong>Instant Vector Selectors(即时向量选择器)&lt;/strong> # 包含每个时间序列的单个样本的一组时间序列，共享相同的时间戳。
&lt;ul>
&lt;li>&lt;strong>即时向量&lt;/strong> 在有的地方也被翻译为 &lt;strong>瞬时向量&lt;/strong>，都是同一个意思。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>Range Vector Selectors(范围向量选择器)&lt;/strong> # 包含每个时间序列随时间变化的数据点的一组时间序列。&lt;/li>
&lt;li>&lt;strong>String(字符串)&lt;/strong> # 一个简单的字符串值(目前未被使用)&lt;/li>
&lt;li>&lt;strong>Scalar(标量)&lt;/strong> # 一个简单的数字浮点值&lt;/li>
&lt;/ul>
&lt;p>在这四种表达式中，我们还可以通过 &lt;strong>Operators(操作符)&lt;/strong> 和 &lt;strong>Functions(函数)&lt;/strong> 来对获取到的时间序列数据，进行加工。&lt;/p>
&lt;p>这四种类型，又可以进行统一分类&lt;/p>
&lt;ul>
&lt;li>Instant Vector Selectors 和 Range Vector Selectors 统称为 &lt;strong>TimeSeries Selectors(时间序列选择器)&lt;/strong>
&lt;ul>
&lt;li>这种表达式会根据 Metrics 来获取指定的时间序列。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>String 和 Scalar 统称为 &lt;a href="https://en.wikipedia.org/wiki/Literal_(computer_programming)">&lt;strong>Literals&lt;/strong>&lt;/a>**(字面量)**
&lt;ul>
&lt;li>给定不同类型的 &lt;a href="https://en.wikipedia.org/wiki/Literal_(computer_programming)">Literals&lt;/a>，就返回对应类型的的值，Prom 里只支持 string 和 scalar 这两种类型&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h1 id="expression表达式">Expression(表达式)&lt;/h1>
&lt;h2 id="instant-vector-selectors即时向量选择器">Instant Vector Selectors(即时向量选择器)&lt;/h2>
&lt;p>即时向量选择器就是获取通过 Metric 来获取当前最新时间戳上的值，这就是即时的含义(指的是当前最新的值)&lt;/p>
&lt;h3 id="根据-metricname-选择时间序列数据">根据 MetricName 选择时间序列数据&lt;/h3>
&lt;p>当我们直接使用 Metrics 查询时，可以查询该 Metrics 下的所有时间序列数据。如：&lt;/p>
&lt;p>&lt;strong>promhttp_metric_handler_requests_total&lt;/strong> # 该表达式会返回指标名称为 promhttp_metric_handler_requests_total 的所有时间序列数据：&lt;/p>
&lt;pre>&lt;code>promhttp_metric_handler_requests_total{code=&amp;quot;200&amp;quot;, instance=&amp;quot;172.38.40.250:9090&amp;quot;, job=&amp;quot;prometheus&amp;quot;}=(98@1518096812.326)
promhttp_metric_handler_requests_total{code=&amp;quot;500&amp;quot;, instance=&amp;quot;172.38.40.250:9090&amp;quot;, job=&amp;quot;prometheus&amp;quot;}=(0@1518096812.326)
promhttp_metric_handler_requests_total{code=&amp;quot;503&amp;quot;, instance=&amp;quot;172.38.40.250:9090&amp;quot;, job=&amp;quot;prometheus&amp;quot;}=(0@1518096812.326)
&lt;/code>&lt;/pre>
&lt;h3 id="过滤选择到的时间序列数据">过滤选择到的时间序列数据&lt;/h3>
&lt;p>如果想要过滤查询结果，可以根据 metric 中的 Label 来进行匹配，通过在 &lt;code>{ }&lt;/code> 符号中使用一组 Label 来进一步过滤这些时间序列数据，支持两种匹配模式：完全匹配和正则匹配。可以使用 4 种用于标签匹配的操作符&lt;/p>
&lt;ul>
&lt;li>&lt;code>=&lt;/code> # 完全匹配。通过使用 &lt;code>Label=&amp;quot;Value&amp;quot;&lt;/code> 可以选择那些标签值满足表达式定义的时间序列；&lt;/li>
&lt;li>&lt;code>!=&lt;/code> # 完全不匹配。反之使用 &lt;code>Label!=&amp;quot;Value&amp;quot;&lt;/code> 则可以根据标签值匹配排除时间序列；&lt;/li>
&lt;li>&lt;code>=~&lt;/code> # 正则匹配。使用 &lt;code>Label=~&amp;quot;RegEx&amp;quot;&lt;/code> 表示选择那些标签符合正则表达式定义的时间序列；&lt;/li>
&lt;li>&lt;code>!~&lt;/code> # 正则不匹配。反之使用 &lt;code>Label!~&amp;quot;RegEx&amp;quot;&lt;/code> 进行排除；
&lt;ul>
&lt;li>正则匹配中，多个表达式之间使用 &lt;code>|&lt;/code> 进行分隔：&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>例如，如果我们只需要查询所有 promhttp_metric_handler_requests_total 指标中满足标签 code 的值为 200 的时间序列，则可以使用如下表达式：&lt;/p>
&lt;p>promhttp_metric_handler_requests_total{code=&amp;ldquo;200&amp;rdquo;}&lt;/p>
&lt;p>反之使用 code!=&amp;ldquo;200&amp;rdquo; 则可以排除这些时间序列：&lt;/p>
&lt;p>promhttp_metric_handler_requests_total{code!=&amp;ldquo;200&amp;rdquo;}
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/lfubxg/1616069073195-72aba6c2-dabb-47d8-960b-b26cdf73e04a.png" alt="">
如果想查询多个环节下的时间序列序列可以使用如下表达式：&lt;/p>
&lt;p>promhttp_metric_handler_requests_total{code=~&amp;ldquo;200|500&amp;rdquo;}&lt;/p>
&lt;h3 id="根据-label-选择时间序列数据">根据 Label 选择时间序列数据&lt;/h3>
&lt;p>我们可以把 Label 当作表达式来获取所有具有这些 Label 的 Metrics 的时间序列数据
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/lfubxg/1616069073324-a1b41ace-fb9a-4f25-af64-b18536239692.png" alt="">
在 Label 中还可以使用原始标签
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/lfubxg/1616069073217-6f22cfb6-c05c-44ef-b079-6d91f6e295a2.png" alt="">&lt;/p>
&lt;h2 id="range-vector-selectors范围向量选择器">&lt;strong>Range Vector Selectors(范围向量选择器)&lt;/strong>&lt;/h2>
&lt;p>直接通过表达式 http_requests_total 查询时间序列时，返回值中只会包含该时间序列中的最新的一个样本值，这样的返回结果我们称之为瞬时向量。而相应的这样的表达式称之为&lt;strong>瞬时向量表达式&lt;/strong>。&lt;/p>
&lt;p>而如果我们想要获取过去一段时间范围内的样本数据时，我们则需要使用&lt;strong>范围向量表达式&lt;/strong>。范围向量表达式 和 瞬时向量表达式 基本一样，唯一的区别在于，范围向量表达式 中我们需要定义时间选择的范围，时间范围通过 &lt;code>[ ]&lt;/code> (这个符号表示：&lt;strong>时间范围选择器&lt;/strong>) 进行定义。&lt;/p>
&lt;p>例如：
promhttp_metric_handler_requests_total{}[1m] #该表达式将会返回查询到的时间序列中最近 1 分钟的所有样本数据：数据如下&lt;/p>
&lt;p>Note：&lt;/p>
&lt;ul>
&lt;li>这种查询方式只可以获取到值，并不能生成图表，因为图表中的一条向量是由很多个点组成的，每个点的位置由横轴是 time、纵轴是 value 互相确认得到的。但是这种查询结果会使每个点由多个 time 与多个 value 组成，一个点怎么可能由多个点合成一个呢？这在二维图标上是没法显示出来的。&lt;/li>
&lt;li>由于有多个值而且还没法展示，所以范围向量一般不会单独使用，而是与 irate()等函数一起使用。以便让多个值根据指定的函数规则聚合成唯一的一个值。&lt;/li>
&lt;/ul>
&lt;!-- raw HTML omitted -->
&lt;pre>&lt;code>promhttp_metric_handler_requests_total{code=&amp;quot;200&amp;quot;, instance=&amp;quot;172.38.40.250:9090&amp;quot;, job=&amp;quot;prometheus&amp;quot;}=[
223@1518096812.326
224@1518096817.326
225@1518096822.326
226@1518096827.326
]
promhttp_metric_handler_requests_total{code=&amp;quot;200&amp;quot;, instance=&amp;quot;172.38.40.250:9090&amp;quot;, job=&amp;quot;prometheus&amp;quot;}=[
0@1518096812.326
0@1518096817.326
0@1518096822.326
0@1518096827.326
]
&lt;/code>&lt;/pre>
&lt;p>除了使用 m 表示分钟以外，PromQL 的时间范围选择器支持其它时间单位：&lt;/p>
&lt;ul>
&lt;li>ms # 毫秒&lt;/li>
&lt;li>s # 秒&lt;/li>
&lt;li>m # 分钟&lt;/li>
&lt;li>h # 小时&lt;/li>
&lt;li>d # 天&lt;/li>
&lt;li>w # 周&lt;/li>
&lt;li>y # 年&lt;/li>
&lt;/ul>
&lt;h3 id="时间位移操作">&lt;strong>时间位移操作&lt;/strong>&lt;/h3>
&lt;p>在瞬时向量表达式或者范围向量表达式中，都是以当前时间为基准：&lt;/p>
&lt;p>http_request_total{} # 瞬时向量表达式，选择当前最新的数据&lt;/p>
&lt;p>http_request_total{}[5m] #范围向量表达式，选择以当前时间为基准，5 分钟内的数据&lt;/p>
&lt;p>而如果我们想查询，5 分钟前的瞬时样本数据，或昨天一天的区间内的样本数据呢? 这个时候我们就可以使用位移操作，位移操作的关键字为 offset。&lt;/p>
&lt;p>可以使用 offset 时间位移操作：&lt;/p>
&lt;p>http_request_total{} offset 5m #&lt;/p>
&lt;p>http_request_total{}[1d] offset 1d #&lt;/p>
&lt;h2 id="string字符串-表达式">String(字符串) 表达式&lt;/h2>
&lt;p>直接使用字符串，作为 PromQL 表达式，则会直接返回字符串。&lt;/p>
&lt;pre>&lt;code>&amp;quot;this is a string&amp;quot;
'these are unescaped: \n \\ \t'
`these are not unescaped: \n ' &amp;quot; \t`
&lt;/code>&lt;/pre>
&lt;p>比如下图：
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/lfubxg/1616069073187-d54f3195-edf1-4215-af6d-97b1132832f6.png" alt="">
如果通过 API，则是这种样子：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>~&lt;span style="color:#f92672">]&lt;/span>&lt;span style="color:#75715e"># curl &amp;#34;http://172.38.40.244:30001/api/v1/query?query=%22HelloWorld%22&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">{&lt;/span>&lt;span style="color:#e6db74">&amp;#34;status&amp;#34;&lt;/span>:&lt;span style="color:#e6db74">&amp;#34;success&amp;#34;&lt;/span>,&lt;span style="color:#e6db74">&amp;#34;data&amp;#34;&lt;/span>:&lt;span style="color:#f92672">{&lt;/span>&lt;span style="color:#e6db74">&amp;#34;resultType&amp;#34;&lt;/span>:&lt;span style="color:#e6db74">&amp;#34;string&amp;#34;&lt;/span>,&lt;span style="color:#e6db74">&amp;#34;result&amp;#34;&lt;/span>:&lt;span style="color:#f92672">[&lt;/span>1610673038.083,&lt;span style="color:#e6db74">&amp;#34;HelloWorld&amp;#34;&lt;/span>&lt;span style="color:#f92672">]}}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="scalar标量-表达式">Scalar(标量) 表达式&lt;/h2>
&lt;p>除了使用瞬时向量表达式和区间向量表达式以外，PromQL 还直接支持用户使用标量(Scalar)和字符串(String)。&lt;/p>
&lt;p>标量只有一个数字，没有时序。&lt;/p>
&lt;p>例如：&lt;/p>
&lt;p>10
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/lfubxg/1616069073229-d7297a02-c472-4d5d-a21f-0265ecc5ca63.png" alt="">
需要注意的是，当使用表达式 count(http_requests_total)，返回的数据类型，依然是瞬时向量。用户可以通过内置函数 scalar()将单个瞬时向量转换为标量。&lt;/p>
&lt;h2 id="operators运算符">Operators(运算符)&lt;/h2>
&lt;p>Prometheus 支持许多二进制和聚合运算符。详见《[PromQL Operators](/docs/IT学习笔记/6.可观测性/监控系统/Prometheus/PromQL/PromQL%20Operators(运算符).md Operators(运算符).md)》章节&lt;/p>
&lt;h2 id="functions函数">Functions(函数)&lt;/h2>
&lt;p>Prometheus 支持多种对数据进行操作的函数。详见《[PromQL Functions](/docs/IT学习笔记/6.可观测性/监控系统/Prometheus/PromQL/PromQL%20Functions(函数).md Functions(函数).md)》章节&lt;/p>
&lt;h1 id="表达式样例">表达式样例&lt;/h1>
&lt;p>所有的 PromQL 表达式都必须至少包含一个指标名称(例如 http_request_total)，或者一个不会匹配到空字符串的标签过滤器(例如{code=&amp;ldquo;200&amp;rdquo;})。&lt;/p>
&lt;p>因此以下两种方式，均为合法的表达式：
合法的表达式：&lt;/p>
&lt;ul>
&lt;li>http_request_total&lt;/li>
&lt;li>http_request_total{}&lt;/li>
&lt;li>{method=&amp;ldquo;get&amp;rdquo;}&lt;/li>
&lt;/ul>
&lt;p>不合法的表达式：&lt;/p>
&lt;ul>
&lt;li>{job=~&amp;quot;.*&amp;quot;}
&lt;ol>
&lt;li>注意，可以使用&amp;rsquo;{job=~&amp;quot;..*&amp;quot;}&amp;lsquo;来匹配所有 job 的 metric，但是官方不建议这么用，防止意外情况发生&lt;/li>
&lt;/ol>
&lt;/li>
&lt;/ul>
&lt;p>同时，除了使用{label=value}的形式以外，我们还可以使用内置的__name__标签来指定监控指标名称：
{&lt;strong>name&lt;/strong>=~&amp;ldquo;http_request_total&amp;rdquo;} # 合法
{&lt;strong>name&lt;/strong>=~&amp;ldquo;node_disk_bytes_read|node_disk_bytes_written&amp;rdquo;} # 合法&lt;/p>
&lt;h2 id="即时向量查询结果的示意图">即时向量查询结果的示意图&lt;/h2>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/lfubxg/1616069073170-822867a1-8a50-4fa6-ae70-e34c802af202.jpeg" alt="">&lt;/p>
&lt;h2 id="范围向量查询结果示意图">范围向量查询结果示意图&lt;/h2>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/lfubxg/1616069073260-b6507c67-3c3c-4c52-bf34-773772f11743.jpeg" alt="">&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/lfubxg/1616069073175-af75032f-496c-4fe2-bfbf-4bd44d56e836.jpeg" alt="">&lt;/p></description></item><item><title>Docs: PromQL Functions(函数)</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/6.%E5%8F%AF%E8%A7%82%E6%B5%8B%E6%80%A7/%E7%9B%91%E6%8E%A7%E7%B3%BB%E7%BB%9F/prometheus/promql/promql-functions%E5%87%BD%E6%95%B0/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/6.%E5%8F%AF%E8%A7%82%E6%B5%8B%E6%80%A7/%E7%9B%91%E6%8E%A7%E7%B3%BB%E7%BB%9F/prometheus/promql/promql-functions%E5%87%BD%E6%95%B0/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://prometheus.io/docs/prometheus/latest/querying/functions/">官方文档,Prometheus-查询-函数&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://fuckcloudnative.io/prometheus/3-prometheus/functions.html">fuckcloudnative.io&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://mp.weixin.qq.com/s/7z8n3abX9k39YL5kCopJqQ">公众号,k8s 技术圈-PromQL 查询之 rate 函数的使用&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://ihac.xyz/2018/12/11/Prometheus-Extrapolation%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/">Prometheus Extrapolation 原理解析，delta、increase 函数的解析&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>Prometheus 提供了其它大量的内置函数，可以对时序数据进行丰富的处理。在代码 &lt;code>[promql/functions.go](https://github.com/prometheus/prometheus/blob/release-2.39/promql/functions.go#L1078)&lt;/code> 中可以看到当前所有可用的 PromQL 函数。&lt;/p>
&lt;h2 id="函数的语法">函数的语法&lt;/h2>
&lt;p>某些函数有默认的参数，例如：&lt;code>year(v=vector(time()) instant-vector)&lt;/code>。这是一个标准的函数结构 &lt;code>函数名(形参 形参的类型)&lt;/code>&lt;/p>
&lt;ul>
&lt;li>&lt;strong>instant-vector&lt;/strong> # 表示参数类型，该类型表示一个瞬时向量表达式
&lt;ul>
&lt;li>range-vector 表示一个范围向量表达式&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>v&lt;/strong> # 表示这是 year 函数中，instant-vector 类型的形参
&lt;ul>
&lt;li>&lt;strong>vector(time())&lt;/strong> # 表示参数 v 的默认值。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>比如 &lt;code>absent(up)&lt;/code> 这个表达式中，up 就是传递给参数 v 的值，是一个瞬时向量表达式。absent 表示该函数的功能。&lt;/p>
&lt;h1 id="prometheus-内置函数">Prometheus 内置函数&lt;/h1>
&lt;h2 id="abs--绝对值">abs() # 绝对值&lt;/h2>
&lt;p>&lt;code>abs(v instant-vector)&lt;/code> 返回输入向量的所有样本的 &lt;strong>Absolute Value(绝对值)&lt;/strong>。&lt;/p>
&lt;h2 id="absent--判断表达式是否可以获取到序列">absent() # 判断表达式是否可以获取到序列&lt;/h2>
&lt;p>&lt;code>absent(v instant-vector)&lt;/code> 返回值有两种&lt;/p>
&lt;ul>
&lt;li>&lt;strong>空向量&lt;/strong> # 如果传递给它的向量参数具有样本数据，返回空向量，就是不返回任何时间序列的意思。&lt;/li>
&lt;li>&lt;strong>1&lt;/strong> # 如果传递的向量参数没有样本数据，则返回不带度量指标名称且带有标签的时间序列，且样本值为 1。&lt;/li>
&lt;/ul>
&lt;p>效果如下：
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/hdmkl5/1617374161523-a63251fa-c9cc-4f90-ba6d-1eb30bc48a07.png" alt="image.png">
absent() 函数特别适用于告警，比如当采集器出现问题时，无法采集到数据了，那么可以通过该函数进行判断，如果值为 1，就产生告警。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># 这里提供的向量有样本数据&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>absent&lt;span style="color:#f92672">(&lt;/span>http_requests_total&lt;span style="color:#f92672">{&lt;/span>method&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;get&amp;#34;&lt;/span>&lt;span style="color:#f92672">})&lt;/span> &lt;span style="color:#f92672">=&lt;/span>&amp;gt; no data
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>absent&lt;span style="color:#f92672">(&lt;/span>sum&lt;span style="color:#f92672">(&lt;/span>http_requests_total&lt;span style="color:#f92672">{&lt;/span>method&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;get&amp;#34;&lt;/span>&lt;span style="color:#f92672">}))&lt;/span> &lt;span style="color:#f92672">=&lt;/span>&amp;gt; no data
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># 由于不存在指标 nonexistent，所以 返回不带度量指标名称且带有标签的时间序列，且样本值为1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>absent&lt;span style="color:#f92672">(&lt;/span>nonexistent&lt;span style="color:#f92672">{&lt;/span>job&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;myjob&amp;#34;&lt;/span>&lt;span style="color:#f92672">})&lt;/span> &lt;span style="color:#f92672">=&lt;/span>&amp;gt; &lt;span style="color:#f92672">{&lt;/span>job&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;myjob&amp;#34;&lt;/span>&lt;span style="color:#f92672">}&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># 正则匹配的 instance 不作为返回 labels 中的部分&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>absent&lt;span style="color:#f92672">(&lt;/span>nonexistent&lt;span style="color:#f92672">{&lt;/span>job&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;myjob&amp;#34;&lt;/span>,instance&lt;span style="color:#f92672">=&lt;/span>~&lt;span style="color:#e6db74">&amp;#34;.*&amp;#34;&lt;/span>&lt;span style="color:#f92672">})&lt;/span> &lt;span style="color:#f92672">=&lt;/span>&amp;gt; &lt;span style="color:#f92672">{&lt;/span>job&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;myjob&amp;#34;&lt;/span>&lt;span style="color:#f92672">}&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># sum 函数返回的时间序列不带有标签，且没有样本数据&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>absent&lt;span style="color:#f92672">(&lt;/span>sum&lt;span style="color:#f92672">(&lt;/span>nonexistent&lt;span style="color:#f92672">{&lt;/span>job&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;myjob&amp;#34;&lt;/span>&lt;span style="color:#f92672">}))&lt;/span> &lt;span style="color:#f92672">=&lt;/span>&amp;gt; &lt;span style="color:#f92672">{}&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="ceil">ceil()&lt;/h2>
&lt;p>&lt;code>ceil(v instant-vector)&lt;/code> 将 v 中所有元素的样本值向上四舍五入到最接近的整数。例如：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>node_load5&lt;span style="color:#f92672">{&lt;/span>instance&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;192.168.1.75:9100&amp;#34;&lt;/span>&lt;span style="color:#f92672">}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># 结果为 2.79ceil(node_load5{instance=&amp;#34;192.168.1.75:9100&amp;#34;})# 结果为 3&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="changes">changes()&lt;/h2>
&lt;p>changes(v range-vector) 输入一个区间向量， 返回这个区间向量内每个样本数据值变化的次数（瞬时向量）。例如：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># 如果样本数据值没有发生变化，则返回结果为 1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>changes&lt;span style="color:#f92672">(&lt;/span>node_load5&lt;span style="color:#f92672">{&lt;/span>instance&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;192.168.1.75:9100&amp;#34;&lt;/span>&lt;span style="color:#f92672">}[&lt;/span>1m&lt;span style="color:#f92672">])&lt;/span> &lt;span style="color:#75715e"># 结果为 1&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="clamp_max">clamp_max()&lt;/h2>
&lt;p>clamp_max(v instant-vector, max scalar) 函数，输入一个瞬时向量和最大值，样本数据值若大于 max，则改为 max，否则不变。例如：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>node_load5&lt;span style="color:#f92672">{&lt;/span>instance&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;192.168.1.75:9100&amp;#34;&lt;/span>&lt;span style="color:#f92672">}&lt;/span> &lt;span style="color:#75715e"># 结果为 2.79&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>clamp_max&lt;span style="color:#f92672">(&lt;/span>node_load5&lt;span style="color:#f92672">{&lt;/span>instance&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;192.168.1.75:9100&amp;#34;&lt;/span>&lt;span style="color:#f92672">}&lt;/span>, 2&lt;span style="color:#f92672">)&lt;/span> &lt;span style="color:#75715e"># 结果为 2&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ol start="6">
&lt;li>clamp_min()
clamp_min(v instant-vector, min scalar) 函数，输入一个瞬时向量和最小值，样本数据值若小于 min，则改为 min，否则不变。例如：&lt;/li>
&lt;/ol>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>node_load5&lt;span style="color:#f92672">{&lt;/span>instance&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;192.168.1.75:9100&amp;#34;&lt;/span>&lt;span style="color:#f92672">}&lt;/span> &lt;span style="color:#75715e"># 结果为 2.79&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>clamp_min&lt;span style="color:#f92672">(&lt;/span>node_load5&lt;span style="color:#f92672">{&lt;/span>instance&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;192.168.1.75:9100&amp;#34;&lt;/span>&lt;span style="color:#f92672">}&lt;/span>, 3&lt;span style="color:#f92672">)&lt;/span> &lt;span style="color:#75715e"># 结果为 3&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="变化量相关">变化量相关&lt;/h2>
&lt;p>下面三个函数，在代码中的实现逻辑都是由同一个方法实现的
&lt;code>./prometheus/promql/functions.go&lt;/code>&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// extrapolatedRate rate、increase、delta 函数功能的具体实现
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 该函数计算速率，如果第一个或最后一个样本接近所选范围的边界，则 extrapolates，并以每秒或整体返回结果
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 如果 isCounter 参数为 true，则允许计数器重置。
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 如果 isRate 参数为 true，则返回结果以每秒作为单位
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">func&lt;/span> &lt;span style="color:#a6e22e">extrapolatedRate&lt;/span>(&lt;span style="color:#a6e22e">vals&lt;/span> []&lt;span style="color:#a6e22e">parser&lt;/span>.&lt;span style="color:#a6e22e">Value&lt;/span>, &lt;span style="color:#a6e22e">args&lt;/span> &lt;span style="color:#a6e22e">parser&lt;/span>.&lt;span style="color:#a6e22e">Expressions&lt;/span>, &lt;span style="color:#a6e22e">enh&lt;/span> &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">EvalNodeHelper&lt;/span>, &lt;span style="color:#a6e22e">isCounter&lt;/span> &lt;span style="color:#66d9ef">bool&lt;/span>, &lt;span style="color:#a6e22e">isRate&lt;/span> &lt;span style="color:#66d9ef">bool&lt;/span>) &lt;span style="color:#a6e22e">Vector&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">......&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// === delta(Matrix parser.ValueTypeMatrix) Vector ===
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">func&lt;/span> &lt;span style="color:#a6e22e">funcDelta&lt;/span>(&lt;span style="color:#a6e22e">vals&lt;/span> []&lt;span style="color:#a6e22e">parser&lt;/span>.&lt;span style="color:#a6e22e">Value&lt;/span>, &lt;span style="color:#a6e22e">args&lt;/span> &lt;span style="color:#a6e22e">parser&lt;/span>.&lt;span style="color:#a6e22e">Expressions&lt;/span>, &lt;span style="color:#a6e22e">enh&lt;/span> &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">EvalNodeHelper&lt;/span>) &lt;span style="color:#a6e22e">Vector&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#a6e22e">extrapolatedRate&lt;/span>(&lt;span style="color:#a6e22e">vals&lt;/span>, &lt;span style="color:#a6e22e">args&lt;/span>, &lt;span style="color:#a6e22e">enh&lt;/span>, &lt;span style="color:#66d9ef">false&lt;/span>, &lt;span style="color:#66d9ef">false&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// === rate(node parser.ValueTypeMatrix) Vector ===
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">func&lt;/span> &lt;span style="color:#a6e22e">funcRate&lt;/span>(&lt;span style="color:#a6e22e">vals&lt;/span> []&lt;span style="color:#a6e22e">parser&lt;/span>.&lt;span style="color:#a6e22e">Value&lt;/span>, &lt;span style="color:#a6e22e">args&lt;/span> &lt;span style="color:#a6e22e">parser&lt;/span>.&lt;span style="color:#a6e22e">Expressions&lt;/span>, &lt;span style="color:#a6e22e">enh&lt;/span> &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">EvalNodeHelper&lt;/span>) &lt;span style="color:#a6e22e">Vector&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#a6e22e">extrapolatedRate&lt;/span>(&lt;span style="color:#a6e22e">vals&lt;/span>, &lt;span style="color:#a6e22e">args&lt;/span>, &lt;span style="color:#a6e22e">enh&lt;/span>, &lt;span style="color:#66d9ef">true&lt;/span>, &lt;span style="color:#66d9ef">true&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// === increase(node parser.ValueTypeMatrix) Vector ===
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">func&lt;/span> &lt;span style="color:#a6e22e">funcIncrease&lt;/span>(&lt;span style="color:#a6e22e">vals&lt;/span> []&lt;span style="color:#a6e22e">parser&lt;/span>.&lt;span style="color:#a6e22e">Value&lt;/span>, &lt;span style="color:#a6e22e">args&lt;/span> &lt;span style="color:#a6e22e">parser&lt;/span>.&lt;span style="color:#a6e22e">Expressions&lt;/span>, &lt;span style="color:#a6e22e">enh&lt;/span> &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">EvalNodeHelper&lt;/span>) &lt;span style="color:#a6e22e">Vector&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#a6e22e">extrapolatedRate&lt;/span>(&lt;span style="color:#a6e22e">vals&lt;/span>, &lt;span style="color:#a6e22e">args&lt;/span>, &lt;span style="color:#a6e22e">enh&lt;/span>, &lt;span style="color:#66d9ef">true&lt;/span>, &lt;span style="color:#66d9ef">false&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>区别&lt;/p>
&lt;ul>
&lt;li>delta() 与 rate() 的区别在于 isCounter 和 isRate 参数&lt;/li>
&lt;li>delta() 与 increase() 的区别在于 isCounter 参数&lt;/li>
&lt;li>rate() 与 increase() 的区别在于 isRate 参数&lt;/li>
&lt;/ul>
&lt;h3 id="delta--增量差量">delta() # 增量/差量&lt;/h3>
&lt;p>&lt;code>delta(v range-vector)&lt;/code> 计算范围向量 &lt;code>v&lt;/code> 中，所有时间序列元素的第一个和最后一个值之间的差异。由于这个值被外推到指定的整个时间范围，所以即使样本值都是整数，你仍然可能会得到一个非整数值。&lt;/p>
&lt;ul>
&lt;li>函数返回值：一个瞬时向量。&lt;/li>
&lt;/ul>
&lt;p>注意：该函数只能用于 Gauges 类型的时间序列数据。&lt;/p>
&lt;p>例如，下面的例子返回过去两小时的 CPU 温度差：
&lt;code>delta(cpu_temp_celsius{host=&amp;quot;zeus&amp;quot;}[2h])&lt;/code>&lt;/p>
&lt;h3 id="increase">increase()&lt;/h3>
&lt;p>&lt;code>increase(v range-vector)&lt;/code> 计算范围向量 &lt;code>v&lt;/code> 中，第一个和最后一个样本并返回其增长量, 它会在单调性发生变化时(如由于采样目标重启引起的计数器复位)自动中断。由于这个值被外推到指定的整个时间范围，所以即使样本值都是整数，你仍然可能会得到一个非整数值。&lt;/p>
&lt;ul>
&lt;li>函数返回值：类型只能是计数器类型，主要作用是增加图表和数据的可读性。使用 rate 函数记录规则的使用率，以便持续跟踪数据样本值的变化。&lt;/li>
&lt;/ul>
&lt;p>例如，以下表达式返回区间向量中每个时间序列过去 5 分钟内 HTTP 请求数的增长数：
&lt;code>increase(http_requests_total{job=&amp;quot;apiserver&amp;quot;}[5m])&lt;/code>&lt;/p>
&lt;h3 id="rate">rate()&lt;/h3>
&lt;p>&lt;code>rate(v range-vector)&lt;/code> 函数可以直接计算区间向量 v 在时间窗口内平均增长速率，它会在单调性发生变化时(如由于采样目标重启引起的计数器复位)自动中断。该函数的返回结果不带有度量指标，只有标签列表。&lt;/p>
&lt;p>例如，以下表达式返回区间向量中每个时间序列过去 5 分钟内 HTTP 请求数的每秒增长率：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>rate&lt;span style="color:#f92672">(&lt;/span>http_requests_total&lt;span style="color:#f92672">[&lt;/span>5m&lt;span style="color:#f92672">])&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>结果：
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">{&lt;/span>code&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;200&amp;#34;&lt;/span>,handler&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;label_values&amp;#34;&lt;/span>,instance&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;120.77.65.193:9090&amp;#34;&lt;/span>,job&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;prometheus&amp;#34;&lt;/span>,method&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;get&amp;#34;&lt;/span>&lt;span style="color:#f92672">}&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">{&lt;/span>code&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;200&amp;#34;&lt;/span>,handler&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;query_range&amp;#34;&lt;/span>,instance&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;120.77.65.193:9090&amp;#34;&lt;/span>,job&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;prometheus&amp;#34;&lt;/span>,method&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;get&amp;#34;&lt;/span>&lt;span style="color:#f92672">}&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">{&lt;/span>code&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;200&amp;#34;&lt;/span>,handler&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;prometheus&amp;#34;&lt;/span>,instance&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;120.77.65.193:9090&amp;#34;&lt;/span>,job&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;prometheus&amp;#34;&lt;/span>,method&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;get&amp;#34;&lt;/span>&lt;span style="color:#f92672">}&lt;/span> 0.2
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>...
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>rate() 函数返回值类型只能用计数器，在长期趋势分析或者告警中推荐使用这个函数。&lt;/p>
&lt;p>注意&lt;/p>
&lt;p>当将 rate() 函数与聚合运算符（例如 sum()）或随时间聚合的函数（任何以 _over_time 结尾的函数）一起使用时，必须先执行 rate 函数，然后再进行聚合操作，否则当采样目标重新启动时 rate() 无法检测到计数器是否被重置。&lt;/p>
&lt;ol start="11">
&lt;li>deriv()
deriv(v range-vector) 的参数是一个区间向量,返回一个瞬时向量。它使用简单的线性回归计算区间向量 v 中各个时间序列的导数。&lt;/li>
&lt;/ol>
&lt;p>这个函数一般只用在 Gauge 类型的时间序列上。&lt;/p>
&lt;ol start="12">
&lt;li>exp()
exp(v instant-vector) 函数，输入一个瞬时向量，返回各个样本值的 e 的指数值，即 e 的 N 次方。当 N 的值足够大时会返回 +Inf。特殊情况为：&lt;/li>
&lt;/ol>
&lt;ul>
&lt;li>Exp(+Inf) = +Inf&lt;/li>
&lt;li>Exp(NaN) = NaN&lt;/li>
&lt;/ul>
&lt;ol start="13">
&lt;li>
&lt;p>floor()
floor(v instant-vector) 函数与 ceil() 函数相反，将 v 中所有元素的样本值向下四舍五入到最接近的整数。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>histogram_quantile()&lt;/p>
&lt;/li>
&lt;/ol>
&lt;p>histogram_quantile(φ float, b instant-vector) 从 bucket 类型的向量 b 中计算 φ (0 ≤ φ ≤ 1) 分位数（百分位数的一般形式）的样本的最大值。（有关 φ 分位数的详细说明以及直方图指标类型的使用，请参阅直方图和摘要）。向量 b 中的样本是每个 bucket 的采样点数量。每个样本的 labels 中必须要有 le 这个 label 来表示每个 bucket 的上边界，没有 le 标签的样本会被忽略。直方图指标类型自动提供带有 _bucket 后缀和相应标签的时间序列。&lt;/p>
&lt;p>可以使用 rate() 函数来指定分位数计算的时间窗口。&lt;/p>
&lt;p>例如，一个直方图指标名称为 employee_age_bucket_bucket，要计算过去 10 分钟内 第 90 个百分位数，请使用以下表达式：&lt;/p>
&lt;p>histogram_quantile(0.9, rate(employee_age_bucket_bucket[10m]))&lt;/p>
&lt;p>返回：&lt;/p>
&lt;p>{instance=&amp;ldquo;10.0.86.71:8080&amp;rdquo;,job=&amp;ldquo;prometheus&amp;rdquo;} 35.714285714285715&lt;/p>
&lt;p>这表示最近 10 分钟之内 90% 的样本的最大值为 35.714285714285715。&lt;/p>
&lt;p>这个计算结果是每组标签组合成一个时间序列。我们可能不会对所有这些维度（如 job、instance 和 method）感兴趣，并希望将其中的一些维度进行聚合，则可以使用 sum() 函数。例如，以下表达式根据 job 标签来对第 90 个百分位数进行聚合：&lt;/p>
&lt;h1 id="histogram_quantile-函数必须包含-le-标签-histogram_quantile09-sumrateemployee_age_bucket_bucket10m-by-job-le">histogram_quantile() 函数必须包含 le 标签 histogram_quantile(0.9, sum(rate(employee_age_bucket_bucket[10m])) by (job, le))&lt;/h1>
&lt;p>如果要聚合所有的标签，则使用如下表达式：&lt;/p>
&lt;p>histogram_quantile(0.9,sum(rate(employee_age_bucket_bucket[10m])) by (le))&lt;/p>
&lt;p>注意&lt;/p>
&lt;p>histogram_quantile 这个函数是根据假定每个区间内的样本分布是线性分布来计算结果值的(也就是说它的结果未必准确)，最高的 bucket 必须是 le=&amp;quot;+Inf&amp;quot; (否则就返回 NaN)。&lt;/p>
&lt;p>如果分位数位于最高的 bucket（+Inf） 中，则返回第二个最高的 bucket 的上边界。如果该 bucket 的上边界大于 0，则假设最低的 bucket 的的下边界为 0，这种情况下在该 bucket 内使用常规的线性插值。&lt;/p>
&lt;p>如果分位数位于最低的 bucket 中，则返回最低 bucket 的上边界。&lt;/p>
&lt;p>如果 b 含有少于 2 个 buckets，那么会返回 NaN，如果 φ &amp;lt; 0 会返回 -Inf，如果 φ &amp;gt; 1 会返回 +Inf。&lt;/p>
&lt;ol start="15">
&lt;li>holt_winters()
holt_winters(v range-vector, sf scalar, tf scalar) 函数基于区间向量 v，生成时间序列数据平滑值。平滑因子 sf 越低, 对旧数据的重视程度越高。趋势因子 tf 越高，对数据的趋势的考虑就越多。其中，0&amp;lt; sf, tf &amp;lt;=1。&lt;/li>
&lt;/ol>
&lt;p>holt_winters 仅适用于 Gauge 类型的时间序列。&lt;/p>
&lt;ol start="17">
&lt;li>idelta()
idelta(v range-vector) 的参数是一个区间向量, 返回一个瞬时向量。它计算最新的 2 个样本值之间的差值。&lt;/li>
&lt;/ol>
&lt;p>这个函数一般只用在 Gauge 类型的时间序列上。&lt;/p>
&lt;h2 id="irate">irate()&lt;/h2>
&lt;p>irate(v range-vector) 函数用于计算区间向量的增长率，但是其反应出的是瞬时增长率。irate 函数是通过区间向量中最后两个两本数据来计算区间向量的增长速率，它会在单调性发生变化时(如由于采样目标重启引起的计数器复位)自动中断。这种方式可以避免在时间窗口范围内的“长尾问题”，并且体现出更好的灵敏度，通过 irate 函数绘制的图标能够更好的反应样本数据的瞬时变化状态。&lt;/p>
&lt;p>例如，以下表达式返回区间向量中每个时间序列过去 5 分钟内最后两个样本数据的 HTTP 请求数的增长率：&lt;/p>
&lt;p>irate(http_requests_total{job=&amp;ldquo;api-server&amp;rdquo;}[5m])&lt;/p>
&lt;p>irate 只能用于绘制快速变化的计数器，在长期趋势分析或者告警中更推荐使用 rate 函数。因为使用 irate 函数时，速率的简短变化会重置 FOR 语句，形成的图形有很多波峰，难以阅读。&lt;/p>
&lt;p>注意&lt;/p>
&lt;p>当将 irate() 函数与聚合运算符（例如 sum()）或随时间聚合的函数（任何以 _over_time 结尾的函数）一起使用时，必须先执行 irate 函数，然后再进行聚合操作，否则当采样目标重新启动时 irate() 无法检测到计数器是否被重置。&lt;/p>
&lt;ol start="20">
&lt;li>label_join()
label_join(v instant-vector, dst_label string, separator string, src_label_1 string, src_label_2 string, &amp;hellip;) 函数可以将时间序列 v 中多个标签 src_label 的值，通过 separator 作为连接符写入到一个新的标签 dst_label 中。可以有多个 src_label 标签。&lt;/li>
&lt;/ol>
&lt;p>例如，以下表达式返回的时间序列多了一个 foo 标签，标签值为 etcd,etcd-k8s：&lt;/p>
&lt;p>up{endpoint=&amp;ldquo;api&amp;rdquo;,instance=&amp;ldquo;192.168.123.248:2379&amp;rdquo;,job=&amp;ldquo;etcd&amp;rdquo;,namespace=&amp;ldquo;monitoring&amp;rdquo;,service=&amp;ldquo;etcd-k8s&amp;rdquo;}=&amp;gt; up{endpoint=&amp;ldquo;api&amp;rdquo;,instance=&amp;ldquo;192.168.123.248:2379&amp;rdquo;,job=&amp;ldquo;etcd&amp;rdquo;,namespace=&amp;ldquo;monitoring&amp;rdquo;,service=&amp;ldquo;etcd-k8s&amp;rdquo;} 1label_join(up{endpoint=&amp;ldquo;api&amp;rdquo;,instance=&amp;ldquo;192.168.123.248:2379&amp;rdquo;,job=&amp;ldquo;etcd&amp;rdquo;,namespace=&amp;ldquo;monitoring&amp;rdquo;,service=&amp;ldquo;etcd-k8s&amp;rdquo;}, &amp;ldquo;foo&amp;rdquo;, &amp;ldquo;,&amp;rdquo;, &amp;ldquo;job&amp;rdquo;, &amp;ldquo;service&amp;rdquo;)=&amp;gt; up{endpoint=&amp;ldquo;api&amp;rdquo;,foo=&amp;ldquo;etcd,etcd-k8s&amp;rdquo;,instance=&amp;ldquo;192.168.123.248:2379&amp;rdquo;,job=&amp;ldquo;etcd&amp;rdquo;,namespace=&amp;ldquo;monitoring&amp;rdquo;,service=&amp;ldquo;etcd-k8s&amp;rdquo;} 1&lt;/p>
&lt;ol start="21">
&lt;li>label_replace()
为了能够让客户端的图标更具有可读性，可以通过 label_replace 函数为时间序列添加额外的标签。label_replace 的具体参数如下：&lt;/li>
&lt;/ol>
&lt;p>label_replace(v instant-vector, dst_label string, replacement string, src_label string, regex string)&lt;/p>
&lt;p>该函数会依次对 v 中的每一条时间序列进行处理，通过 regex 匹配 src_label 的值，并将匹配部分 relacement 写入到 dst_label 标签中。如下所示：&lt;/p>
&lt;p>label&lt;em>replace(up, &amp;ldquo;host&amp;rdquo;, &amp;ldquo;$1&amp;rdquo;, &amp;ldquo;instance&amp;rdquo;, &amp;ldquo;(.&lt;/em>):._&amp;rdquo;)&lt;/p>
&lt;p>函数处理后，时间序列将包含一个 host 标签，host 标签的值为 Exporter 实例的 IP 地址：&lt;/p>
&lt;p>up{host=&amp;ldquo;localhost&amp;rdquo;,instance=&amp;ldquo;localhost:8080&amp;rdquo;,job=&amp;ldquo;cadvisor&amp;rdquo;} 1up{host=&amp;ldquo;localhost&amp;rdquo;,instance=&amp;ldquo;localhost:9090&amp;rdquo;,job=&amp;ldquo;prometheus&amp;rdquo;} 1up{host=&amp;ldquo;localhost&amp;rdquo;,instance=&amp;ldquo;localhost:9100&amp;rdquo;,job=&amp;ldquo;node&amp;rdquo;} 1&lt;/p>
&lt;ol start="22">
&lt;li>ln()
ln(v instant-vector) 计算瞬时向量 v 中所有样本数据的自然对数。特殊情况：&lt;/li>
&lt;/ol>
&lt;ul>
&lt;li>ln(+Inf) = +Inf&lt;/li>
&lt;li>ln(0) = -Inf&lt;/li>
&lt;li>ln(x &amp;lt; 0) = NaN&lt;/li>
&lt;li>ln(NaN) = NaN&lt;/li>
&lt;/ul>
&lt;ol start="23">
&lt;li>
&lt;p>log2()
log2(v instant-vector) 函数计算瞬时向量 v 中所有样本数据的二进制对数。特殊情况同上。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>log10()
log10(v instant-vector) 计算瞬时向量 v 中所有样本数据的十进制对数。特殊情况同上。&lt;/p>
&lt;/li>
&lt;/ol>
&lt;h2 id="predict_linear--线性预测">predict_linear() # 线性预测&lt;/h2>
&lt;p>&lt;code>predict_linear(v range-vector, t scalar)&lt;/code> 预测时间序列 v 在 t 秒后的值。它基于简单线性回归的方式，对时间窗口内的样本数据进行统计，从而可以对时间序列的变化趋势做出预测。该函数的返回结果不带有度量指标，只有标签列表。&lt;/p>
&lt;p>例如，基于 2 小时的样本数据，来预测主机可用磁盘空间的是否在 4 个小时候被占满，可以使用如下表达式：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>predict_linear&lt;span style="color:#f92672">(&lt;/span>node_filesystem_free&lt;span style="color:#f92672">{&lt;/span>job&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;node&amp;#34;&lt;/span>&lt;span style="color:#f92672">}[&lt;/span>2h&lt;span style="color:#f92672">]&lt;/span>, &lt;span style="color:#ae81ff">4&lt;/span> * 3600&lt;span style="color:#f92672">)&lt;/span>&amp;lt; &lt;span style="color:#ae81ff">0&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>通过下面的例子来观察返回值：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>predict_linear&lt;span style="color:#f92672">(&lt;/span>http_requests_total&lt;span style="color:#f92672">{&lt;/span>code&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;200&amp;#34;&lt;/span>,instance&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;120.77.65.193:9090&amp;#34;&lt;/span>,job&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;prometheus&amp;#34;&lt;/span>,method&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;get&amp;#34;&lt;/span>&lt;span style="color:#f92672">}[&lt;/span>5m&lt;span style="color:#f92672">]&lt;/span>, 5&lt;span style="color:#f92672">)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>结果：
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">{&lt;/span>code&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;200&amp;#34;&lt;/span>,handler&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;query_range&amp;#34;&lt;/span>,instance&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;120.77.65.193:9090&amp;#34;&lt;/span>,job&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;prometheus&amp;#34;&lt;/span>,method&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;get&amp;#34;&lt;/span>&lt;span style="color:#f92672">}&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">{&lt;/span>code&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;200&amp;#34;&lt;/span>,handler&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;prometheus&amp;#34;&lt;/span>,instance&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;120.77.65.193:9090&amp;#34;&lt;/span>,job&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;prometheus&amp;#34;&lt;/span>,method&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;get&amp;#34;&lt;/span>&lt;span style="color:#f92672">}&lt;/span> 4283.449995397104
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">{&lt;/span>code&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;200&amp;#34;&lt;/span>,handler&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;static&amp;#34;&lt;/span>,instance&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;120.77.65.193:9090&amp;#34;&lt;/span>,job&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;prometheus&amp;#34;&lt;/span>,method&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;get&amp;#34;&lt;/span>&lt;span style="color:#f92672">}&lt;/span> 22.99999999999999
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>...
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>这个函数一般只用在 Gauge 类型的时间序列上。&lt;/p>
&lt;h2 id="resets">resets()&lt;/h2>
&lt;p>resets(v range-vector) 的参数是一个区间向量。对于每个时间序列，它都返回一个计数器重置的次数。两个连续样本之间的值的减少被认为是一次计数器重置。&lt;/p>
&lt;p>这个函数一般只用在计数器类型的时间序列上。&lt;/p>
&lt;ol start="30">
&lt;li>
&lt;p>round()
round(v instant-vector, to_nearest=1 scalar) 函数与 ceil 和 floor 函数类似，返回向量中所有样本值的最接近的整数。to_nearest 参数是可选的,默认为 1,表示样本返回的是最接近 1 的整数倍的值。你也可以将该参数指定为任意值（也可以是小数），表示样本返回的是最接近它的整数倍的值。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>scalar()
scalar(v instant-vector) 函数的参数是一个单元素的瞬时向量,它返回其唯一的时间序列的值作为一个标量。如果度量指标的样本数量大于 1 或者等于 0, 则返回 NaN。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>sort()
sort(v instant-vector) 函数对向量按元素的值进行升序排序，返回结果：key: value = 度量指标：样本值[升序排列]。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>sort_desc()
sort(v instant-vector) 函数对向量按元素的值进行降序排序，返回结果：key: value = 度量指标：样本值[降序排列]。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>sqrt()
sqrt(v instant-vector) 函数计算向量 v 中所有元素的平方根。&lt;/p>
&lt;/li>
&lt;/ol>
&lt;h2 id="时间相关">时间相关&lt;/h2>
&lt;h3 id="day_of_month">day_of_month()&lt;/h3>
&lt;p>day_of_month(v=vector(time()) instant-vector) 函数，返回被给定 UTC 时间所在月的第几天。返回值范围：1~31。&lt;/p>
&lt;h3 id="day_of_week">day_of_week()&lt;/h3>
&lt;p>day_of_week(v=vector(time()) instant-vector) 函数，返回被给定 UTC 时间所在周的第几天。返回值范围：0~6，0 表示星期天。&lt;/p>
&lt;h3 id="days_in_month">days_in_month()&lt;/h3>
&lt;p>days_in_month(v=vector(time()) instant-vector) 函数，返回当月一共有多少天。返回值范围：28~31。&lt;/p>
&lt;h3 id="hour">hour()&lt;/h3>
&lt;p>hour(v=vector(time()) instant-vector) 函数返回被给定 UTC 时间的当前第几个小时，时间范围：0~23。&lt;/p>
&lt;h3 id="minute">minute()&lt;/h3>
&lt;p>minute(v=vector(time()) instant-vector) 函数返回给定 UTC 时间当前小时的第多少分钟。结果范围：0~59。&lt;/p>
&lt;h3 id="month">month()&lt;/h3>
&lt;p>month(v=vector(time()) instant-vector) 函数返回给定 UTC 时间当前属于第几个月，结果范围：0~12。&lt;/p>
&lt;h3 id="time">time()&lt;/h3>
&lt;p>time() 函数返回从 1970-01-01 到现在的秒数。注意：它不是直接返回当前时间，而是时间戳。&lt;/p>
&lt;p>通常与 &lt;strong>process_start_time_seconds&lt;/strong> 之类的指标同时使用，以 &lt;code>time() - process_start_time_seconds{}&lt;/code> 即可计算出程序已经运行了多长时间&lt;/p>
&lt;blockquote>
&lt;p>这个减法的意思是：当前时间减去程序启动时的时间，就是程序知道现在已经运行了多长时间。&lt;/p>
&lt;/blockquote>
&lt;h3 id="timestamp">timestamp()&lt;/h3>
&lt;p>timestamp(v instant-vector) 函数返回向量 v 中的每个样本的时间戳（从 1970-01-01 到现在的秒数）。&lt;/p>
&lt;h3 id="year">year()&lt;/h3>
&lt;p>year(v=vector(time()) instant-vector) 函数返回被给定 UTC 时间的当前年份。&lt;/p>
&lt;ol start="37">
&lt;li>vector()
vector(s scalar) 函数将标量 s 作为没有标签的向量返回，即返回结果为：key: value= {}, s。&lt;/li>
&lt;/ol>
&lt;h2 id="范围向量">范围向量&lt;/h2>
&lt;h3 id="xxx_over_time">XXX_over_time()&lt;/h3>
&lt;p>下面的函数列表允许传入一个区间向量，它们会聚合每个时间序列的范围，并返回一个瞬时向量：&lt;/p>
&lt;ul>
&lt;li>avg_over_time(range-vector) : 范围向量内所有度量指标的平均值。&lt;/li>
&lt;li>min_over_time(range-vector) : 范围向量内所有度量指标的最小值。&lt;/li>
&lt;li>max_over_time(range-vector) : 范围向量内所有度量指标的最大值。&lt;/li>
&lt;li>sum_over_time(range-vector) : 范围向量内所有度量指标的求和。&lt;/li>
&lt;li>count_over_time(range-vector) : 范围向量内所有度量指标的样本数据个数。&lt;/li>
&lt;li>quantile_over_time(scalar, range-vector) : 范围向量内所有度量指标的样本数据值分位数，φ-quantile (0 ≤ φ ≤ 1)。&lt;/li>
&lt;li>stddev_over_time(range-vector) : 范围向量内所有度量指标的总体标准差。&lt;/li>
&lt;li>stdvar_over_time(range-vector) : 范围向量内所有度量指标的总体标准方差。&lt;/li>
&lt;li>last_over_time(RangeVector) # 范围向量内，最新时间点的值&lt;/li>
&lt;li>present_over_time(RangeVector) # 没懂&lt;/li>
&lt;/ul>
&lt;p>注意
即使范围向量内的值分布不均匀，它们在聚合时的权重也是相同的。&lt;/p>
&lt;h1 id="应用示例">应用示例&lt;/h1>
&lt;h2 id="计算-counter-指标增长率">计算 Counter 指标增长率&lt;/h2>
&lt;p>我们知道 Counter 类型的监控指标其特点是只增不减，在没有发生重置（如服务器重启，应用重启）的情况下其样本值应该是不断增大的。为了能够更直观的表示样本数据的变化剧烈情况，需要计算样本的增长速率。&lt;/p>
&lt;p>如下图所示，样本增长率反映出了样本变化的剧烈程度：&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/hdmkl5/1616069150695-27301a07-484c-4875-80c5-b2c095f8f707.jpeg" alt="">&lt;/p>
&lt;p>通过增长率表示样本的变化情况&lt;/p>
&lt;p>increase(v range-vector)函数是 PromQL 中提供的众多内置函数之一。其中参数 v 是一个区间向量，increase 函数获取区间向量中的第一个后最后一个样本并返回其增长量。因此，可以通过以下表达式 Counter 类型指标的增长率：&lt;/p>
&lt;ul>
&lt;li>increase(node_cpu[2m]) / 120&lt;/li>
&lt;/ul>
&lt;p>这里通过 node_cpu[2m]获取时间序列最近两分钟的所有样本，increase 计算出最近两分钟的增长量，最后除以时间 120 秒得到 node_cpu 样本在最近两分钟的平均增长率。并且这个值也近似于主机节点最近两分钟内的平均 CPU 使用率。&lt;/p>
&lt;p>rate(v range-vector)函数，rate 函数可以直接计算区间向量 v 在时间窗口内平均增长速率。因此，通过以下表达式可以得到与 increase 函数相同的结果：&lt;/p>
&lt;ul>
&lt;li>rate(node_cpu[2m])&lt;/li>
&lt;/ul>
&lt;p>需要注意的是使用 rate 或者 increase 函数去计算样本的平均增长速率，容易陷入“长尾问题”当中，其无法反应在时间窗口内样本数据的突发变化。 例如，对于主机而言在 2 分钟的时间窗口内，可能在某一个由于访问量或者其它问题导致 CPU 占用 100%的情况，但是通过计算在时间窗口内的平均增长率却无法反应出该问题。&lt;/p>
&lt;p>为了解决该问题，PromQL 提供了另外一个灵敏度更高的函数 irate(v range-vector)。&lt;/p>
&lt;p>irate(v range-vector)函数同样用于计算区间向量的计算率，但是其反应出的是瞬时增长率。irate 函数是通过区间向量中最后两个两本数据来计算区间向量的增长速率。这种方式可以避免在时间窗口范围内的“长尾问题”，并且体现出更好的灵敏度，通过 irate 函数绘制的图标能够更好的反应样本数据的瞬时变化状态。&lt;/p>
&lt;ul>
&lt;li>irate(node_cpu[2m])&lt;/li>
&lt;/ul>
&lt;p>irate 函数相比于 rate 函数提供了更高的灵敏度，不过当需要分析长期趋势或者在告警规则中，irate 的这种灵敏度反而容易造成干扰。因此在长期趋势分析或者告警中更推荐使用 rate 函数。&lt;/p>
&lt;h2 id="预测-gauge-指标变化趋势">预测 Gauge 指标变化趋势&lt;/h2>
&lt;p>在一般情况下，系统管理员为了确保业务的持续可用运行，会针对服务器的资源设置相应的告警阈值。例如，当磁盘空间只剩 512MB 时向相关人员发送告警通知。 这种基于阈值的告警模式对于当资源用量是平滑增长的情况下是能够有效的工作的。 但是如果资源不是平滑变化的呢？ 比如有些某些业务增长，存储空间的增长速率提升了高几倍。这时，如果基于原有阈值去触发告警，当系统管理员接收到告警以后可能还没来得及去处理问题，系统就已经不可用了。 因此阈值通常来说不是固定的，需要定期进行调整才能保证该告警阈值能够发挥去作用。 那么还有没有更好的方法吗？&lt;/p>
&lt;p>PromQL 中内置的 predict_linear(v range-vector, t scalar) 函数可以帮助系统管理员更好的处理此类情况，predict_linear 函数可以预测时间序列 v 在 t 秒后的值。它基于简单线性回归的方式，对时间窗口内的样本数据进行统计，从而可以对时间序列的变化趋势做出预测。例如，基于 2 小时的样本数据，来预测主机可用磁盘空间的是否在 4 个小时候被占满，可以使用如下表达式&lt;/p>
&lt;ul>
&lt;li>predict_linear(node_filesystem_free{job=&amp;ldquo;node&amp;rdquo;}[2h], 4 * 3600) &amp;lt; 0&lt;/li>
&lt;/ul>
&lt;h2 id="统计-histogram-指标的分位数">统计 Histogram 指标的分位数&lt;/h2>
&lt;p>在本章的第 2 小节中，我们介绍了 Prometheus 的四种监控指标类型，其中 Histogram 和 Summary 都可以同于统计和分析数据的分布情况。区别在于 Summary 是直接在客户端计算了数据分布的分位数情况。而 Histogram 的分位数计算需要通过 histogram_quantile(φ float, b instant-vector)函数进行计算。其中 φ（0&amp;lt;φ&amp;lt;1）表示需要计算的分位数，如果需要计算中位数 φ 取值为 0.5，以此类推即可。&lt;/p>
&lt;p>以指标 http_request_duration_seconds_bucket 为例：&lt;/p>
&lt;pre>&lt;code># HELP http_request_duration_seconds request duration histogram
# TYPE http_request_duration_seconds histogram
http_request_duration_seconds_bucket{le=&amp;quot;0.5&amp;quot;} 0
http_request_duration_seconds_bucket{le=&amp;quot;1&amp;quot;} 1
http_request_duration_seconds_bucket{le=&amp;quot;2&amp;quot;} 2
http_request_duration_seconds_bucket{le=&amp;quot;3&amp;quot;} 3
http_request_duration_seconds_bucket{le=&amp;quot;5&amp;quot;} 3
http_request_duration_seconds_bucket{le=&amp;quot;+Inf&amp;quot;} 3
http_request_duration_seconds_sum 6
http_request_duration_seconds_count 3
&lt;/code>&lt;/pre>
&lt;p>当计算 9 分位数时，使用如下表达式：&lt;/p>
&lt;p>histogram_quantile(0.5, http_request_duration_seconds_bucket)&lt;/p>
&lt;p>通过对 Histogram 类型的监控指标，用户可以轻松获取样本数据的分布情况。同时分位数的计算，也可以非常方便的用于评判当前监控指标的服务水平。&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/hdmkl5/1616069150712-8975307f-3088-43f4-940f-4589d86af58a.jpeg" alt="">&lt;/p>
&lt;p>获取分布直方图的中位数&lt;/p>
&lt;p>需要注意的是通过 histogram_quantile 计算的分位数，并非为精确值，而是通过 http_request_duration_seconds_bucket 和 http_request_duration_seconds_sum 近似计算的结果。&lt;/p>
&lt;h3 id="动态标签替换">动态标签替换&lt;/h3>
&lt;p>一般来说来说，使用 PromQL 查询到时间序列后，可视化工具会根据时间序列的标签来渲染图表。例如通过 up 指标可以获取到当前所有运行的 Exporter 实例以及其状态：&lt;/p>
&lt;pre>&lt;code>up{instance=&amp;quot;localhost:8080&amp;quot;,job=&amp;quot;cadvisor&amp;quot;} 1
up{instance=&amp;quot;localhost:9090&amp;quot;,job=&amp;quot;prometheus&amp;quot;} 1
up{instance=&amp;quot;localhost:9100&amp;quot;,job=&amp;quot;node&amp;quot;} 1
&lt;/code>&lt;/pre>
&lt;p>这是可视化工具渲染图标时可能根据，instance 和 job 的值进行渲染，为了能够让客户端的图标更具有可读性，可以通过 label_replace 标签为时间序列添加额外的标签。label_replace 的具体参数如下：&lt;/p>
&lt;p>label_replace(v instant-vector, dst_label string, replacement string, src_label string, regex string)&lt;/p>
&lt;p>该函数会依次对 v 中的每一条时间序列进行处理，通过 regex 匹配 src_label 的值，并将匹配部分 relacement 写入到 dst_label 标签中。如下所示：&lt;/p>
&lt;p>label&lt;em>replace(up, &amp;ldquo;host&amp;rdquo;, &amp;ldquo;$1&amp;rdquo;, &amp;ldquo;instance&amp;rdquo;, &amp;ldquo;(.&lt;/em>):._&amp;rdquo;)&lt;/p>
&lt;p>函数处理后，时间序列将包含一个 host 标签，host 标签的值为 Exporter 实例的 IP 地址：&lt;/p>
&lt;pre>&lt;code>up{host=&amp;quot;localhost&amp;quot;,instance=&amp;quot;localhost:8080&amp;quot;,job=&amp;quot;cadvisor&amp;quot;} 1
up{host=&amp;quot;localhost&amp;quot;,instance=&amp;quot;localhost:9090&amp;quot;,job=&amp;quot;prometheus&amp;quot;} 1
up{host=&amp;quot;localhost&amp;quot;,instance=&amp;quot;localhost:9100&amp;quot;,job=&amp;quot;node&amp;quot;} 1
&lt;/code>&lt;/pre>
&lt;p>除了 label_replace 以外，Prometheus 还提供了 label_join 函数，该函数可以将时间序列中 v 多个标签 src_label 的值，通过 separator 作为连接符写入到一个新的标签 dst_label 中:&lt;/p>
&lt;p>label_join(v instant-vector, dst_label string, separator string, src_label_1 string, src_label_2 string, &amp;hellip;)&lt;/p>
&lt;p>label_replace 和 label_join 函数提供了对时间序列标签的自定义能力，从而能够更好的于客户端或者可视化工具配合。&lt;/p></description></item><item><title>Docs: PromQL Operators(运算符)</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/6.%E5%8F%AF%E8%A7%82%E6%B5%8B%E6%80%A7/%E7%9B%91%E6%8E%A7%E7%B3%BB%E7%BB%9F/prometheus/promql/promql-operators%E8%BF%90%E7%AE%97%E7%AC%A6/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/6.%E5%8F%AF%E8%A7%82%E6%B5%8B%E6%80%A7/%E7%9B%91%E6%8E%A7%E7%B3%BB%E7%BB%9F/prometheus/promql/promql-operators%E8%BF%90%E7%AE%97%E7%AC%A6/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://prometheus.io/docs/prometheus/latest/querying/operators/">官方文档，Prometheus-查询-运算符&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;!-- raw HTML omitted -->
&lt;p>使用 PromQL 除了能够方便的按照查询和过滤时间序列以外，PromQL 还支持丰富的运算符，用户可以使用这些运算符对进一步的对事件序列进行二次加工。这些运算符包括：数学运算符，逻辑运算符，布尔运算符等等。&lt;/p>
&lt;p>详见《[二元运算符](/docs/IT学习笔记/6.可观测性/监控系统/Prometheus/PromQL/Binary%20Operators(二元运算符).md Operators(二元运算符).md)》章节&lt;/p>
&lt;h2 id="vector-matching向量匹配">Vector Matching(向量匹配)&lt;/h2>
&lt;p>向量与向量之间进行运算操作时会基于默认的匹配规则：&lt;/p>
&lt;ul>
&lt;li>右边向量表达式获取到的时间序列与左边向量表达式获取到的时间序列的标签进行一一匹配，完全匹配到的两个时间序列进行运算，没有匹配到的直接丢弃&lt;/li>
&lt;/ul>
&lt;p>说白话就是，两条时间序列要想进行二元运算，他们的标签必须完全相同才可以。&lt;/p>
&lt;p>**这时就产生问题了，如果我想让两条标签不同的序列进行二元运行，怎么办呢？这时候就需要使用 Vector Matching(向量匹配) 来扩展二元运算的功能。**通过 Vector Matching，我们可以根据标签的匹配规则，选择出来符合要求的时间序列进行二元运算。&lt;/p>
&lt;p>接下来将介绍在 PromQ L 中有两种典型的匹配模式：一对一(one-to-one)、多对一(many-to-one)、一对多(one-to-many)。&lt;/p>
&lt;p>向量匹配常用于生成新的时间序列&lt;/p>
&lt;h3 id="一对一匹配">一对一匹配&lt;/h3>
&lt;p>一对一匹配模式会从操作符两边表达式获取的瞬时向量依次比较并找到唯一匹配(标签完全一致)的样本值，然后进行二元运算。&lt;/p>
&lt;h4 id="syntax语法">Syntax(语法)&lt;/h4>
&lt;p>&lt;strong>&lt;!-- raw HTML omitted --> &lt;!-- raw HTML omitted --> ignoring(LabelList) &lt;!-- raw HTML omitted -->&lt;/strong>
&lt;strong>&lt;!-- raw HTML omitted --> &lt;!-- raw HTML omitted --> on(LabelList) &lt;!-- raw HTML omitted -->&lt;/strong>&lt;/p>
&lt;p>on 与 ignoring 关键字会将其左右两侧表达式中标签进行匹配，根据其指定的 LabelList 来匹配标签，匹配到的序列将会执行二元运算&lt;/p>
&lt;ul>
&lt;li>&lt;strong>ignoreing(LabelList)&lt;/strong> # 匹配不包含 LabelList 的序列。&lt;/li>
&lt;li>&lt;strong>on(LabelList)&lt;/strong> # 匹配包含 LabelList 的序列。&lt;/li>
&lt;/ul>
&lt;p>例如当存在样本：&lt;/p>
&lt;pre>&lt;code>method_code:http_errors:rate5m{method=&amp;quot;get&amp;quot;, code=&amp;quot;500&amp;quot;} 24
method_code:http_errors:rate5m{method=&amp;quot;get&amp;quot;, code=&amp;quot;404&amp;quot;} 30
method_code:http_errors:rate5m{method=&amp;quot;put&amp;quot;, code=&amp;quot;501&amp;quot;} 3
method_code:http_errors:rate5m{method=&amp;quot;post&amp;quot;, code=&amp;quot;500&amp;quot;} 6
method_code:http_errors:rate5m{method=&amp;quot;post&amp;quot;, code=&amp;quot;404&amp;quot;} 21
method:http_requests:rate5m{method=&amp;quot;get&amp;quot;} 600
method:http_requests:rate5m{method=&amp;quot;del&amp;quot;} 34
method:http_requests:rate5m{method=&amp;quot;post&amp;quot;} 120
&lt;/code>&lt;/pre>
&lt;p>使用 PromQL 表达式：&lt;/p>
&lt;pre>&lt;code>method_code:http_errors:rate5m{code=&amp;quot;500&amp;quot;} / ignoring(code) method:http_requests:rate5m
或者
method_code:http_errors:rate5m{code=&amp;quot;500&amp;quot;} / on(method) method:http_requests:rate5m
&lt;/code>&lt;/pre>
&lt;p>该表达式会返回在过去 5 分钟内，HTTP 请求状态码为 500 的在所有请求中的比例。如果没有使用 ignoring(code)，操作符两边表达式返回的瞬时向量中将找不到任何一个标签完全相同的匹配项。&lt;/p>
&lt;p>因此结果如下：&lt;/p>
&lt;pre>&lt;code>{method=&amp;quot;get&amp;quot;} 0.04 // 值就是 24 / 600 得到的结果
{method=&amp;quot;post&amp;quot;} 0.05 // 值就是 6 / 120 得到的结果
&lt;/code>&lt;/pre>
&lt;p>同时由于 method 为 put 和 del 的样本找不到匹配项，因此不会出现在结果当中。&lt;/p>
&lt;h3 id="多对一--一对多">多对一 &amp;amp;&amp;amp; 一对多&lt;/h3>
&lt;p>多对一 和 一对多 两种匹配模式指的是“一”侧的每一个向量元素可以与&amp;quot;多&amp;quot;侧的多个元素匹配的情况。这里所谓的 &lt;code>一&lt;/code> 和 &lt;code>多&lt;/code>，其实就是相对表达式中，&lt;code>左侧向量表达式&lt;/code> 和 &lt;code>右侧向量表达式&lt;/code>。在这种情况下，通过 group_left 或者 group_right 这两个修饰符来确定 &lt;code>左边/右边&lt;/code> 哪边的表达式充当“多”的角色(也就指拥有更高的基数(higher cardinality))。&lt;/p>
&lt;p>多对一 和 一对多 两种模式一定是出现在操作符两侧表达式返回的向量标签不一致的情况。因此需要使用 ignoring 和 on 修饰符来排除或者限定匹配的标签列表。&lt;/p>
&lt;h4 id="syntax语法-1">Syntax(语法)&lt;/h4>
&lt;p>&lt;strong>&lt;!-- raw HTML omitted --> &lt;!-- raw HTML omitted --> ignoring(LabelList) group_left(LabelList) &lt;!-- raw HTML omitted -->&lt;/strong>
&lt;strong>&lt;!-- raw HTML omitted --> &lt;!-- raw HTML omitted --> ignoring(LabelList) group_right(LabelList) &lt;!-- raw HTML omitted -->&lt;/strong>
&lt;strong>&lt;!-- raw HTML omitted --> &lt;!-- raw HTML omitted --> on(LabelList) group_left(LabelList) &lt;!-- raw HTML omitted -->&lt;/strong>
&lt;strong>&lt;!-- raw HTML omitted --> &lt;!-- raw HTML omitted --> on(LabelList) group_right(LabelList) &lt;!-- raw HTML omitted -->&lt;/strong>&lt;/p>
&lt;p>group_left 与 group_right 修饰符用来指定以左边或右边的向量表达式为主：&lt;/p>
&lt;ul>
&lt;li>&lt;strong>group_left(LabelList)&lt;/strong> # 表示以&lt;strong>左边的 VectorExpr1 为主&lt;/strong>，生成的新序列将会包含 &lt;strong>左侧序列&lt;/strong> 中的所有标签以及 LabelList 里指定的标签&lt;/li>
&lt;li>&lt;strong>group_right(LabelList)&lt;/strong> # 表示以&lt;strong>右边的 VectorExpr2 为主&lt;/strong>，生成的新序列将会包含 &lt;strong>右侧序列&lt;/strong> 中的所有标签以及 LabelList 里指定的标签&lt;/li>
&lt;/ul>
&lt;p>例如,使用表达式：&lt;/p>
&lt;pre>&lt;code>method_code:http_errors:rate5m / on(method) group_left method:http_requests:rate5m
&lt;/code>&lt;/pre>
&lt;p>该表达式中，左向量 method_code:http_errors:rate5m 包含两个标签 method 和 code。而右向量 method:http_requests:rate5m 中只包含一个标签 method，因此匹配时需要使用 ignoring 限定匹配的标签为 method。 在限定匹配标签后，右向量中的元素可能匹配到多个左向量中的元素 因此该表达式的匹配模式为多对一，需要使用 group_left 修饰符指定左向量具有更好的基数。&lt;/p>
&lt;p>最终的运算结果如下：&lt;/p>
&lt;pre>&lt;code>{method=&amp;quot;get&amp;quot;, code=&amp;quot;500&amp;quot;} 0.04 // 24 / 600
{method=&amp;quot;get&amp;quot;, code=&amp;quot;404&amp;quot;} 0.05 // 30 / 600
{method=&amp;quot;post&amp;quot;, code=&amp;quot;500&amp;quot;} 0.05 // 6 / 120
{method=&amp;quot;post&amp;quot;, code=&amp;quot;404&amp;quot;} 0.175 // 21 / 120
&lt;/code>&lt;/pre>
&lt;p>提醒：group 修饰符只能在比较和数学运算符中使用。在逻辑运算 and,unless 和 or 才注意操作中默认与右向量中的所有元素进行匹配。&lt;/p>
&lt;h1 id="aggregation-operators聚合运算符">Aggregation Operators(聚合运算符)&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;a href="https://prometheus.io/docs/prometheus/latest/querying/operators/#aggregation-operators">官方文档&lt;/a>&lt;/p>
&lt;/blockquote>
&lt;p>聚合运算符可以聚合单个即时向量的元素，从而产生一个包含较少元素且具有聚合值得新向量。&lt;/p>
&lt;p>聚合运算符既可以用于聚合所有标签维度，也可以通过包含一个 without 或 by 子句来保留不同的维度。这些从句可以用在短语的前面或后面。&lt;/p>
&lt;p>详见：&lt;a href="https://www.yuque.com/go/doc/33147028">聚合运算章节&lt;/a>&lt;/p></description></item></channel></rss>