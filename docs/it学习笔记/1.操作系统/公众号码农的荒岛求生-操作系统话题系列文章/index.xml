<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>断念梦 – 公众号,码农的荒岛求生-操作系统话题系列文章</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E5%85%AC%E4%BC%97%E5%8F%B7%E7%A0%81%E5%86%9C%E7%9A%84%E8%8D%92%E5%B2%9B%E6%B1%82%E7%94%9F-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%9D%E9%A2%98%E7%B3%BB%E5%88%97%E6%96%87%E7%AB%A0/</link><description>Recent content in 公众号,码农的荒岛求生-操作系统话题系列文章 on 断念梦</description><generator>Hugo -- gohugo.io</generator><atom:link href="https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E5%85%AC%E4%BC%97%E5%8F%B7%E7%A0%81%E5%86%9C%E7%9A%84%E8%8D%92%E5%B2%9B%E6%B1%82%E7%94%9F-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%9D%E9%A2%98%E7%B3%BB%E5%88%97%E6%96%87%E7%AB%A0/index.xml" rel="self" type="application/rss+xml"/><item><title>Docs: CPU 是如何读写内存的？</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E5%85%AC%E4%BC%97%E5%8F%B7%E7%A0%81%E5%86%9C%E7%9A%84%E8%8D%92%E5%B2%9B%E6%B1%82%E7%94%9F-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%9D%E9%A2%98%E7%B3%BB%E5%88%97%E6%96%87%E7%AB%A0/cpu-%E6%98%AF%E5%A6%82%E4%BD%95%E8%AF%BB%E5%86%99%E5%86%85%E5%AD%98%E7%9A%84/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E5%85%AC%E4%BC%97%E5%8F%B7%E7%A0%81%E5%86%9C%E7%9A%84%E8%8D%92%E5%B2%9B%E6%B1%82%E7%94%9F-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%9D%E9%A2%98%E7%B3%BB%E5%88%97%E6%96%87%E7%AB%A0/cpu-%E6%98%AF%E5%A6%82%E4%BD%95%E8%AF%BB%E5%86%99%E5%86%85%E5%AD%98%E7%9A%84/</guid><description>
&lt;p>&lt;a href="https://mp.weixin.qq.com/s/S3Cn6KsDGKqxxP58y2m67Q">https://mp.weixin.qq.com/s/S3Cn6KsDGKqxxP58y2m67Q&lt;/a>&lt;/p>
&lt;p>如果你觉得这是一个非常简单的问题，那么你真应该好好读读本文，&lt;strong>我敢保证这个问题绝没有你想象的那么简单&lt;/strong>。注意，一定要完本文，&lt;strong>否则可能会得出错误的结论&lt;/strong>。闲话少说，让我们来看看 CPU 在读写内存时底层究竟发生了什么。&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/ogei92/1625466494695-3520afa8-7698-4bb7-b054-63d8593e6183.png" alt="">
&lt;strong>谁来告诉 CPU 读写内存&lt;/strong>
我们第一个要搞清楚的问题是：谁来告诉 CPU 去读写内存？答案很明显，是程序员，更具体的是编译器。CPU 只是按照指令按部就班的执行，机器指令从哪里来的呢？是编译器生成的，程序员通过高级语言编写程序，编译器将其翻译为机器指令，机器指令来告诉 CPU 去读写内存。在精简指令集架构下会有特定的机器指令，Load/Store 指令来读写内存，以 x86 为代表的复杂指令集架构下没有特定的访存指令。精简指令集下，一条机器指令操作的数据必须来存放在寄存器中，不能直接操作内存数据，因此 RISC 下，数据必须先从内存搬运到寄存器，这就是为什么 RISC 下会有特定的 Load/Store 访存指令，明白了吧。&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/ogei92/1625466494595-c823fd37-ed5d-4ac8-bbb8-1a31ed3045a6.gif" alt="">而 x86 下无此限制，一条机器指令操作的数据可以来自于寄存器也可以来自内存，因此这样一条机器指令在执行过程中会首先从内存中读取数据。关于复杂指令集以及精简指令集你可以参考这两篇文章《&lt;a href="http://mp.weixin.qq.com/s?__biz=Mzg4OTYzODM4Mw==&amp;amp;mid=2247485740&amp;amp;idx=1&amp;amp;sn=5e21003aa245c64516225cbdec30fc25&amp;amp;chksm=cfe995acf89e1cbaf208a25999d6c9b08e505ea8b8a49564e08c63a819b0a4fa1160893a8047&amp;amp;scene=21#wechat_redirect">CPU 进化论：复杂指令集&lt;/a>》与《&lt;a href="http://mp.weixin.qq.com/s?__biz=Mzg4OTYzODM4Mw==&amp;amp;mid=2247485741&amp;amp;idx=1&amp;amp;sn=45afcce8e8e8ec198a9b09c32c1e6aa8&amp;amp;chksm=cfe995adf89e1cbb833ca61741028bee6ccfeb1e928efe60a3a8fcf1fa01da3df4ef49a063de&amp;amp;scene=21#wechat_redirect">不懂精简指令集还敢说自己是程序员？&lt;/a>》&lt;/p>
&lt;h5 id="两种内存读写">&lt;strong>两种内存读写&lt;/strong>&lt;/h5>
&lt;p>现在我们知道了，是特定的机器指令告诉 CPU 要去访问内存。不过，值得注意的是，不管是 RISC 下特定的 Load/Store 指令还是 x86 下包含在一条指令内部的访存操作，这里读写的都是内存中的数据，除此之外还要意识到，CPU 除了从内存中读写数据外，还要从内存中读取下一条要执行的机器指令。毕竟，我们的计算设备都遵从冯诺依曼架构：&lt;strong>程序和数据一视同仁，都可以存放在内存中&lt;/strong>。&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/ogei92/1625466494722-62b1ce8b-3e11-48ac-bc69-66d8c2d7cf28.png" alt="">现在，我们清楚了 CPU 读写内存其实是由两个因素来驱动的：&lt;/p>
&lt;ol>
&lt;li>
&lt;p>程序执行过程中需要读写来自内存中的数据&lt;/p>
&lt;/li>
&lt;li>
&lt;p>CPU 需要访问内存读取下一条要执行的机器指令&lt;/p>
&lt;/li>
&lt;/ol>
&lt;p>然后 CPU 根据机器指令中包含的内存地址或者 PC 寄存器中下一条机器指令的地址访问内存。这不就完了吗？有了内存地址，CPU 利用硬件通路直接读内存就好了，你可能也是这样的想的。真的是这样吗？别着急，我们接着往下看，这两节只是开胃菜，正餐才刚刚开始。&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/ogei92/1625466494648-fe04d9ee-fbc6-4b6f-b939-b7c4f24dbe63.webp" alt="">&lt;/p>
&lt;h5 id="急性子吃货-vs-慢性子厨师">&lt;strong>急性子吃货 VS 慢性子厨师&lt;/strong>&lt;/h5>
&lt;p>假设你是一个整天无所事事的吃货，整天无所事事，唯一的爱好就是找一家餐厅吃吃喝喝，由于你是职业吃货，因此吃起来非常职业，1 分钟就能吃完一道菜，但这里的厨师就没有那么职业了，炒一道菜速度非常慢，大概需要 1 小时 40 分钟才能炒出一道菜，速度比你慢了 100 倍，如果你是这个吃货，大概率会疯掉的。而 CPU 恰好就是这样一个吃货，内存就是这样一个慢吞吞的厨师，而且随着时间的推移这两者的速度差异正在越来越大：&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/ogei92/1625466494714-c2e50753-c4e8-43d1-afa6-3c923c6807d2.webp" alt="">在这种速度差异下，CPU 执行一条涉及内存读写指令时需要等**“很长一段时间“&lt;strong>数据才能&lt;/strong>”缓缓的“&lt;strong>从内存读取到 CPU 中，在这种情况&lt;/strong>你还认为 CPU 应该直接读写内存吗**？&lt;/p>
&lt;h5 id="无处不在的-28-定律">&lt;strong>无处不在的 28 定律&lt;/strong>&lt;/h5>
&lt;p>28 定律我想就不用多介绍了吧，在《&lt;a href="https://notes-learning.oss-cn-beijing.aliyuncs.com/ogei92/1625466494774-8e88aec6-cda9-4df8-bc4a-c6b0721656b0.png">不懂精简指令集还敢说自己是程序员&lt;/a>集中起来然后呢？放到哪里呢？当然是放到一种比内存速度更快的存储介质上，这种介质就是我们熟悉的 SRAM，普通内存一般是 DRAM，这种读写速度更快的介质充当 CPU 和内存之间的 Cache，这就是所谓的缓存。&lt;/p>
&lt;h5 id="四两拨千斤">&lt;strong>四两拨千斤&lt;/strong>&lt;/h5>
&lt;p>我们把经常用到的数据放到 cache 中存储，CPU 访问内存时首先查找 cache，如果能找到，也就是命中，那么就赚到了，直接返回即可，找不到再去查找内存并更新 cache。我们可以看到，&lt;strong>有了 cache，CPU 不再直接与内存打交道了&lt;/strong>。&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/ogei92/1625466494726-1c190d71-806e-4781-bce8-ae233a4881b9.png" alt="">但 cache 的快速读写能力是有代价的，代价就是 Money，造价不菲，&lt;strong>因此我们不能把内存完全替换成 cache 的 SRAM，那样的计算机你我都是买不起的&lt;/strong>。因此 cache 的容量不会很大，但由于程序局部性原理，&lt;strong>因此很小的 cache 也能有很高的命中率&lt;/strong>，从而带来性能的极大提升，有个词叫&lt;strong>四两拨千斤&lt;/strong>，用到 cache 这里再合适不过。&lt;/p>
&lt;h5 id="天下没有免费的午餐">&lt;strong>天下没有免费的午餐&lt;/strong>&lt;/h5>
&lt;p>虽然小小的 cache 能带来性能的极大提升，但，这也是有代价的。这个代价出现在写内存时。当 CPU 需要写内存时该怎么办呢？现在有了 cache，CPU 不再直接与内存打交道，因此 CPU 直接写 cache，但此时就会有一个问题，那就是 cache 中的值更新了，但内存中的值还是旧的，这就是所谓的不一致问题，inconsistent.就像下图这样，cache 中变量的值是 4，但内存中的值是 2。&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/ogei92/1625466494764-74ebde75-ea0b-4c97-9d10-32cf9cdd2be4.png" alt="">&lt;/p>
&lt;h5 id="同步缓存更新">&lt;strong>同步缓存更新&lt;/strong>&lt;/h5>
&lt;p>常用 redis 的同学应该很熟悉这个问题，&lt;strong>可是你知道吗？这个问题早就在你读这篇文章用的计算设备其包含的 CPU 中已经遇到并已经解决了。&lt;strong>最简单的方法是这样的，当我们更新 cache 时一并把内存也更新了，这种方法被称为 write-through，很形象吧。可是如果当 CPU 写 cache 时，cache 中没有相应的内存数据该怎么呢？这就有点麻烦了，首先我们需要把该数据从内存加载到 cache 中，然后更新 cache，再然后更新内存。&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/ogei92/1625466494833-7d54bed1-0b2b-4dec-925f-f816342ede57.png" alt="">这种实现方法虽然简单，但有一个问题，那就是性能问题，在这种方案下&lt;/strong>写内存就不得不访问内存&lt;/strong>，上文也提到过 CPU 和内存可是有很大的速度差异哦，因此这种方案性能比较差。有办法解决吗？答案是肯定的。&lt;/p>
&lt;h5 id="异步更新缓存">&lt;strong>异步更新缓存&lt;/strong>&lt;/h5>
&lt;p>这种方法性能差不是因为写内存慢，写内存确实是慢，更重要的原因是 CPU 在同步等待，因此很自然的，这类问题的统一解法就是把同步改为异步。关于同步和异步的话题，你可以参考这篇文章《&lt;a href="https://notes-learning.oss-cn-beijing.aliyuncs.com/ogei92/1625466494782-5d7755ab-d9a8-428d-b1ad-3f898aa5cdc4.png">从小白到高手，你需要理解同步和异步&lt;/a>现在你应该能看到，添加 cache 后会带来一系列问题，更不用说 cache 的替换算法，毕竟 cache 的容量有限，当 cache 已满时，增加一项新的数据就要剔除一项旧的数据，那么该剔除谁就是一个非常关键的问题，限于篇幅就不在这里详细讲述了，你可以参考《深入理解操作系统》第 7 章有关于该策略的讲解。&lt;/p>
&lt;h5 id="多级-cache">&lt;strong>多级 cache&lt;/strong>&lt;/h5>
&lt;p>现代 CPU 为了增加 CPU 读写内存性能，已经在 CPU 和内存之间增加了多级 cache，典型的有三级，L1、L2 和 L3，CPU 读内存时首先从 L1 cache 找起，能找到直接返回，否则就要在 L2 cache 中找，L2 cache 中找不到就要到 L3 cache 中找，还找不到就不得不访问内存了。因此我们可以看到，&lt;strong>现代计算机系统 CPU 和内存之间其实是有一个 cache 的层级结构的&lt;/strong>。&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/ogei92/1625466494897-db05b255-a5ca-42e7-beb9-e4b976167d71.png" alt="">你以为这就完了吗？哈哈，哪有这么容易的，否则也不会是终面题目了。那么当 CPU 读写内存时除了面临上述问题外还需要处理哪些问题呢？&lt;/p>
&lt;h5 id="多核多问题">&lt;strong>多核，多问题&lt;/strong>&lt;/h5>
&lt;p>当摩尔定律渐渐失效后鸡贼的人类换了另一种提高 CPU 性能的方法，既然单个 CPU 性能不好提升了，我们还可以堆数量啊，这样，CPU 进入多核时代，程序员开始进入苦逼时代。拥有一堆核心的 CPU 其实是没什么用的，&lt;strong>关键需要有配套的多线程程序才能真正发挥多核的威力&lt;/strong>，但写过多线程程序的程序员都知道，能写出来不容易，能写出来并且能正确运行更不容易，关于多线程与多线程编程的详细阐述请参见《深入理解操作系统》第 5、6 两章(关注公众号“码农的荒岛求生”并回复“操作系统”)。CPU 开始拥有多个核心后不但苦逼了软件工程师，硬件工程师也不能幸免。前文提到过，为提高 CPU 访存性能，CPU 和内存之间会有一个层 cache，但当 CPU 有多个核心后新的问题来了：&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/ogei92/1625466494753-a8075ddc-1b20-4c77-ad15-d71c3d78ac07.png" alt="">
看出问题在哪里了吗？一个初始值为 2 的变量，在分别+2 和+4 后正确的结果应该是 2+2+4 = 8，但从上图可以看出&lt;strong>内存中 X 的值却为 6&lt;/strong>，问题出在哪了呢？&lt;/p>
&lt;h5 id="多核-cache-一致性">&lt;strong>多核 cache 一致性&lt;/strong>&lt;/h5>
&lt;p>有的同学可能已经发现了，问题出在了内存中一个 X 变量&lt;strong>在 C1 和 C2 的 cache 中有共计两个副本，当 C1 更新 cache 时没有同步修改 C2 cache 中 X 的值&lt;/strong>。&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/ogei92/1625466494851-f1847fc5-1967-4cf7-9c17-f589ca806aaf.png" alt="">解决方法是什么呢？显然，如果一个 cache 中待更新的变量同样存在于其它核心的 cache，那么你需要一并将其它 cache 也更新好。现在你应该看到，CPU 更新变量时不再简单的只关心自己的 cache 和内存，&lt;strong>你还需要知道这个变量是不是同样存在于其它核心中的 cache&lt;/strong>，如果存在需要一并更新。当然，这还只是简单的读，写就更加复杂了，实际上，现代 CPU 中有一套协议来专门维护缓存的一致性，比较经典的包括 MESI 协议等。为什么程序员需要关心这个问题呢？原因很简单，&lt;strong>你最好写出对 cache 一致性协议友好的程序&lt;/strong>，&lt;strong>因为 cache 频繁维护一致性也是有性能代价的&lt;/strong>。同样的，限于篇幅，这个话题不再详细阐述，该主题同样值得单独成篇，敬请期待。&lt;/p>
&lt;h5 id="够复杂了吧">&lt;strong>够复杂了吧！&lt;/strong>&lt;/h5>
&lt;p>怎么样？到目前为止，是不是 CPU 读写内存没有看上去那么简单？现代计算机中 CPU 和内存之间有多级 cache，&lt;strong>CPU 读写内存时不但要维护 cache 和内存的一致性，同样需要维护多核间 cache 的一致性&lt;/strong>。&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/ogei92/1625466494804-e27375bb-5047-4f46-aefe-0f5667fddf60.webp" alt="">你以为这就完了，NONO，最大的谜团其实是接下来要讲的。&lt;/p>
&lt;h5 id="你以为的不是你以为的">&lt;strong>你以为的不是你以为的&lt;/strong>&lt;/h5>
&lt;p>现代程序员写程序基本上不需要关心&lt;strong>内存是不是足够这个问题&lt;/strong>，但这个问题在远古时代绝对是困扰程序员的一大难题。如果你去想一想，其实现代计算机内存也没有足够大的让我们随便申请的地步，&lt;strong>但是你在写程序时是不是基本上没有考虑过内存不足该怎么办？&lt;strong>为什么我们在内存资源依然处于匮乏的现代可以做到申请内存时却进入内存极大丰富的共产主义理想社会了呢？原来这背后的功臣是我们熟悉的&lt;/strong>操作系统&lt;/strong>。操作系统对每个进程都维护一个假象，即，每个进程独占系统内存资源；同时给程序员一个承诺，让程序员可以认为在写程序时有一大块连续的内存可以使用。这当然是不可能不现实的，因此操作系统给进程的地址空间必然不是真的，但我们又不好将其称之为“&lt;strong>假的地址空间&lt;/strong>”，这会让人误以为计算机科学界里骗子横行，因此就换了一个好听的名字，&lt;strong>虚拟内存&lt;/strong>，一个“&lt;strong>假的地址空间&lt;/strong>”更高级的叫法。&lt;strong>进程其实一直活在操作系统精心维护的幻觉当中&lt;/strong>，就像《盗梦空间》一样，关于虚拟内存的详尽阐述请参见《深入理解操作系统》第七章(关注公众号“码农的荒岛求生”并回复“操作系统”)。&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/ogei92/1625466494790-0d313ab7-571e-40a4-8135-4915c01d9d6f.webp" alt="">从这个角度看，其实最擅长包装的是计算机科学界，哦，对了，他们不但擅长包装还擅长抽象。&lt;/p>
&lt;h5 id="天真的-cpu">&lt;strong>天真的 CPU&lt;/strong>&lt;/h5>
&lt;p>CPU 真的是很傻很天真的存在。上一节讲的操作系统施加的障眼法把 CPU 也蒙在鼓里。CPU 执行机器指令时，指令指示 CPU 从内存地址 A 中取出数据，然后 CPU 执行机器指令时下发命令：“给我从地址 A 中取出数据”，尽管真的能从地址 A 中取出数据，但这个地址 A 不是真的，不是真的，不是真的。因为这个地址 A 属于虚拟内存，也就是那个“假的地址空间”，现代 CPU 内部有一个叫做 MMU 的模块将这假的地址 A 转换为真的地址 B，将地址 A 转换为真实的地址 B 之后才是本文之前讲述的关于 cache 的那一部分。&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/ogei92/1625466494784-5941f257-6712-42f8-9a22-444bf53854d1.png" alt="">你以为这终于应该讲完了吧！NONO！CPU 给出内存地址，此后该地址被转为真正的物理内存地址，接下来查 L1 cache，L1 cache 不命中查 L2 cache，L2 cache 不命中查 L3 cache，L3 cache 不能命中查内存。各单位注意，各单位注意，到查内存时还不算完，现在有了虚拟内存，&lt;strong>内存其实也是一层 cache，是磁盘的 cache，也就是说查内存也有可能不会命中&lt;/strong>，因为内存中的数据可能被虚拟内存系统放到磁盘中了，&lt;strong>如果内存也不能命中就要查磁盘&lt;/strong>。So crazy，限于篇幅这个过程不再展开，《深入理解操作系统》第七章有完整的讲述。至此，CPU 读写内存时完整的过程阐述完毕。&lt;/p>
&lt;h5 id="总结">&lt;strong>总结&lt;/strong>&lt;/h5>
&lt;p>现在你还认为 CPU 读写内存非常简单吗？这一过程涉及到的硬件以及硬件逻辑包括：L1 cache、L2 cache、L3 cache、多核缓存一致性协议、MMU、内存、磁盘；软件主要包括操作系统。&lt;strong>这一看似简单的操作涉及几乎所有计算机系统中的核心组件，需要软件以及硬件密切配合才能完成&lt;/strong>。这个过程给程序员的启示是：1)，现代计算机系统是非常复杂的；2),&lt;strong>你需要写出对 cache 友好的程序&lt;/strong>。我是小风哥，希望这篇文章对大家理解 CPU 以及内存读写有所帮助。***参考资料***&lt;strong>1,《深入理解操作系统》第七章&lt;/strong>，&lt;strong>关注公众号“码农的荒岛求生”并回复“操作系统”即可阅读&lt;/strong>。&lt;a href="http://mp.weixin.qq.com/s?__biz=Mzg4OTYzODM4Mw==&amp;amp;mid=2247485740&amp;amp;idx=1&amp;amp;sn=5e21003aa245c64516225cbdec30fc25&amp;amp;chksm=cfe995acf89e1cbaf208a25999d6c9b08e505ea8b8a49564e08c63a819b0a4fa1160893a8047&amp;amp;scene=21#wechat_redirect">&lt;strong>2，CPU 进化论：复杂指令集的诞生&lt;/strong>&lt;/a>&lt;a href="http://mp.weixin.qq.com/s?__biz=Mzg4OTYzODM4Mw==&amp;amp;mid=2247485741&amp;amp;idx=1&amp;amp;sn=45afcce8e8e8ec198a9b09c32c1e6aa8&amp;amp;chksm=cfe995adf89e1cbb833ca61741028bee6ccfeb1e928efe60a3a8fcf1fa01da3df4ef49a063de&amp;amp;scene=21#wechat_redirect">**3，不懂精简指令集还敢说自己是程序员？**&lt;/a>&lt;/p></description></item><item><title>Docs: 程序员应如何理解内存：上篇</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E5%85%AC%E4%BC%97%E5%8F%B7%E7%A0%81%E5%86%9C%E7%9A%84%E8%8D%92%E5%B2%9B%E6%B1%82%E7%94%9F-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%9D%E9%A2%98%E7%B3%BB%E5%88%97%E6%96%87%E7%AB%A0/%E7%A8%8B%E5%BA%8F%E5%91%98%E5%BA%94%E5%A6%82%E4%BD%95%E7%90%86%E8%A7%A3%E5%86%85%E5%AD%98%E4%B8%8A%E7%AF%87/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E5%85%AC%E4%BC%97%E5%8F%B7%E7%A0%81%E5%86%9C%E7%9A%84%E8%8D%92%E5%B2%9B%E6%B1%82%E7%94%9F-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%9D%E9%A2%98%E7%B3%BB%E5%88%97%E6%96%87%E7%AB%A0/%E7%A8%8B%E5%BA%8F%E5%91%98%E5%BA%94%E5%A6%82%E4%BD%95%E7%90%86%E8%A7%A3%E5%86%85%E5%AD%98%E4%B8%8A%E7%AF%87/</guid><description>
&lt;p>&lt;a href="https://mp.weixin.qq.com/s/U7F5LyzZ07KVOFYJF74LtQ">https://mp.weixin.qq.com/s/U7F5LyzZ07KVOFYJF74LtQ&lt;/a>
本节是操作系统系列教程的第三篇文章，属于操作系统第一章即基础篇，在真正开始操作系统相关章节前在这一部分回顾一些重要的主题，算是温故知新吧，以下是目录，由于本文篇幅较多因此接下来会分三次发布，目录中黑体为本篇内容。&lt;/p>
&lt;hr>
&lt;p>&lt;strong>什么是内存&lt;/strong>&lt;/p>
&lt;p>&lt;strong>C/C++ 内存模型&lt;/strong>&lt;/p>
&lt;p>堆区与栈区的本质&lt;/p>
&lt;p>Java、Python 等内存模型&lt;/p>
&lt;p>Java 内存模型&lt;/p>
&lt;p>Jave 中的堆区与栈区是如何实现的&lt;/p>
&lt;p>Python 内存模型&lt;/p>
&lt;p>指针与引用&lt;/p>
&lt;p>进程的内存模型&lt;/p>
&lt;p>幻想大师 - 操作系统&lt;/p>
&lt;p>总结&lt;/p>
&lt;hr>
&lt;h5 id="什么是内存">什么是内存&lt;/h5>
&lt;p>0 和 1 这两个简单的数字能做什么？在其它学科中也许什么都做不了，但是在计算机科学中这就是全部。精彩纷呈的计算机世界正是构筑在这样两个简单数字之上。&lt;/p>
&lt;p>内存本身其实非常简单，内存的作用就是用来装数字 0 和数字 1 的，如图所示，图中的一个盒子就是内存的一个基本单元，装的不是 0 就是装的 1。&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/2db7a6af-6c98-44c4-8b4b-1615bb23c340/640" alt="">&lt;/p>
&lt;p>内存由一大堆的 “盒子” 组成，每个盒子中要么是 0 要么是 1，其中 8 个盒子被称之为一个“字节”，每 8 个盒子也就是一个字节都有一个编号，这些编号就是简单的从 0 开始依次累加的，这个编号就被称之为“&lt;strong>内存地址&lt;/strong>”。如图所示，你可以把内存理解为下面这张图，其中左边的数字是内存地址，每一排是一个字节，图中展示的就是一个 8 字节大小的内存。&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/2db7a6af-6c98-44c4-8b4b-1615bb23c340/640" alt="">&lt;/p>
&lt;p>而对于我们平时使用的比如 2G、4G 甚至 8G 大小的内存来说，只不过就是 “盒子” 多一点能装的 01 多一点而已，本质上和我们在这里展示的 8 字节大小的内存没有任何区别。&lt;/p>
&lt;p>在后面的章节中我将用右图来表示内存，但是你的大脑里一定要有左图这样一个概念。当计算机在执行我们的程序时，无论是我们的机器指令还是机器指令操作的数据，都需要存放在这些小盒子中 (内存)。&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/2db7a6af-6c98-44c4-8b4b-1615bb23c340/640" alt="">&lt;/p>
&lt;p>以上就是从硬件角度来看内存，那么从编程语言上来看，程序员应该如何理解内存呢？&lt;/p>
&lt;h5 id="cc-内存模型">C/C++ 内存模型&lt;/h5>
&lt;p>对于 C/C++ 程序员来说，常用的 int，char 等变量都被装在盒子中，char 值只需要一排盒子就能装下 (8bit)，一个 int 值一般需要四排盒子才能装得下。连续几排装有同样类型变量的盒子就是数组 (array)，连续几排装有不同类型变量的盒子就是结构体 (struct)，C/C++ 语言中不管多么复杂的数据结构都是在此基础上构建出来的，都需要装在这些盒子里，没什么大不了的。&lt;/p>
&lt;p>现在你已经知道了对于 C/C++ 程序员来说，我们使用的变量是直接放在内存中的 (盒子)，&lt;strong>每一排盒子的地址就是我们熟知的 “指针”&lt;/strong>，请记住，指针就是你使用的变量在内存中的地址，仅此而已。&lt;/p>
&lt;p>C/C++ 程序在被执行时，需要在内存中划出两段区域用于存放数据，这两个区域就是我们熟悉的堆 (Heap) 和栈(Stack)，也称堆区和栈区，如图所示，其中数据段和代码段我们已经熟悉了(不熟悉的同学请参见&lt;a href="http://mp.weixin.qq.com/s?__biz=MzU2NTYyOTQ4OQ==&amp;amp;mid=2247483677&amp;amp;idx=1&amp;amp;sn=09212e8e7ecf7d58bfee53fa04e74911&amp;amp;chksm=fcb98643cbce0f5503916804ffe95bdd30917c9829429bb7fca7191b84f8171409db83e6e28c&amp;amp;scene=21#wechat_redirect">链接器系列&lt;/a>文章)，在这里我们将进一步完善 C/C++ 程序在内存中的样子，如图所示，其中堆区紧邻数据段，在数据段之上，而栈在最上方，栈和堆之间是尚未被使用的内存，随着程序的运行，当程序申请内存时栈区和堆区之间的空隙会减小，当程序释放内存后空隙会扩大，这就是 C/C++ 程序的内存模型。&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/2db7a6af-6c98-44c4-8b4b-1615bb23c340/640" alt="">&lt;/p>
&lt;p>每个函数运行时都会在栈区上占用一块内存，这块内存中保存的是调用函数的参数以及函数中的定义的局部变量，这些变量在函数调用完成后会被释放。从这里可以看出栈上的变量无需程序员关心其释放问题，当函数调用完毕后会&lt;strong>自动&lt;/strong>释放所占用的空间。&lt;/p>
&lt;p>和栈上的变量不同的是，堆上分配的内存不会像栈一样被自动释放，在堆上分配的内存需要程序员手动释放，如果程序员在堆上分配了一块内存，但在使用完后忘记释放，这种情况就被称之为 “内存泄漏”，所谓“内存泄漏” 就是使用完毕后的内存没有释放掉，但是这块内存也不能被用作其它地方从而导致堆占用的内存不断增大，表现出来的就是如果我们去检测程序所占用的内存，会发现程序所占用的内存不断增大，当操作系统是不可能坐视某个进程不断吞噬掉系统内存的，当出现系统内存资源不足时将触发操作系统的保护机制，这在 Linux 中就是著名的 OOM Killer，即 Out Of Memory Killer，OOM Killer 会根据一些策略 Killer 有问题的进程，这个进程通常都是占用内存最多的那个。&lt;/p>
&lt;p>下面我们用一小段 C 代码来实际演示一变量是如何在堆区栈区上分配的，不用担心，这段代码非常简单：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>include &lt;span style="color:#f92672">&amp;lt;&lt;/span>stdlib.h&lt;span style="color:#f92672">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">void&lt;/span> f2() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> c;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span>&lt;span style="color:#f92672">*&lt;/span> heap;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> c &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">3&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> heap &lt;span style="color:#f92672">=&lt;/span> (&lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#f92672">*&lt;/span>)malloc(&lt;span style="color:#66d9ef">sizeof&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span>));
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">*&lt;/span>heap &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">4&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">f1&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> b;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> b &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">2&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> f2();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> a;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> a &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> f1();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>如图所示，这就是以上代码运行过程中的样子，你会发现，每个函数在被执行的时候都在栈区上占有一小段，在这一小段中存放当前函数中定义的局部变量和传入函数的参数。每个函数所占用的这一段内存有一个很形象的名字，叫做 “栈帧 (stack frame)”，原因就在于栈是随着函数调用一帧一帧增加的，每个函数在被调用时都会在栈上分配一帧，所以就叫栈帧。这个词请大家不必去深究，每个被调函数在栈区上做占用的内存总要有个名字，栈帧只不过比较形象而已。&lt;/p>
&lt;p>这段代码中，main 函数会调用函数 f1，f1 会调用函数 f2()，其中变量 a，b，c 以及 heap 依次被放在各自函数的栈帧中，值得注意的一点在于，&lt;strong>heap 这个变量本身是在栈上的，但是 heap 所指向的内存是分配在堆上的&lt;/strong>，heap 本身仅仅保存的是 4 这个值在内存中的&lt;strong>位置&lt;/strong>，比如这里的 0x10，表示的就是 4 这个值放在了内存 0x10 的这个位置上，heap 就是 C/C++ 语言中所谓的指针。如图所示：&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/2db7a6af-6c98-44c4-8b4b-1615bb23c340/640" alt="">&lt;/p>
&lt;p>你会发现随着函数的调用，栈是不断在扩大的，当 f2，f1 执行完毕返回 main 时就是如下图所示的样子。&lt;/p>
&lt;p>从图中我们可以看出，f2 在执行完毕后，f2 所占用的内存就被回收了，所谓 “回收” 就是这块内存又可以用作其它用途了。f1 执行完毕后所占用的内存同样也被回收，这样我们就又回到了 main()函数中。&lt;/p>
&lt;p>这个过程中我们还会发现一个很有意思的现象就是最先被使用的栈帧其实是最后才被释放的，这种先进后出的性质就被称之为 “栈”，如下图所示。所以你会看到 “栈 “这个词更多的是指顺序上的先进后出，只不过函数调用时所占用的内存在使用方式上也是先进后出的，所以这块内存就被称之为栈区了。&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/2db7a6af-6c98-44c4-8b4b-1615bb23c340/640" alt="">&lt;/p>
&lt;p>在讲解完栈之后，我们来看看堆，不同于像 a，b，c 这样存在于栈区上的变量，栈区上的变量可以在函数执行完成后被自动释放掉，在堆区上的分配内存除非程序员&lt;strong>手动&lt;/strong>调用 free,delete 明确的告知内存使用完毕，否则这块内存就会一直被占用而不能用作其它用途，这就是堆区。&lt;/p>
&lt;p>你可能会问，什么样的变量在需要在堆上分配呢，我们知道，函数调用完成后栈上的分配的局部变量会因为栈帧被释放而不再可用，堆区的存在就是为了解决这个问题，堆区中申请的内存不会因为栈帧的释放而不再可用，使得变量的生命周期不再局限于某个函数，其生命周期是靠程序员用 malloc(new) 以及 free(delete) 来控制的，这样的变量在使用时可以跨越函数调用。&lt;/p>
&lt;p>另外一点值得注意的是，f2 函数中我们在堆上申请了一块内存用来存放整数，但是 f2 执行完成后并没有去释放这块内存，根据堆的性质我们知道这块函数在接下来的运行过程中无法再被使用，就好像这块内存被遗忘了一样，这就是内存泄漏。&lt;/p>
&lt;p>接下来的内容将在《程序员应如何理解内存：中篇》继续。&lt;/p>
&lt;hr>
&lt;p>&lt;strong>操作系统系列&lt;/strong>
&lt;a href="https://mp.weixin.qq.com/s/U7F5LyzZ07KVOFYJF74LtQ">https://mp.weixin.qq.com/s/U7F5LyzZ07KVOFYJF74LtQ&lt;/a>&lt;/p></description></item><item><title>Docs: 程序员应如何理解内存：下篇</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E5%85%AC%E4%BC%97%E5%8F%B7%E7%A0%81%E5%86%9C%E7%9A%84%E8%8D%92%E5%B2%9B%E6%B1%82%E7%94%9F-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%9D%E9%A2%98%E7%B3%BB%E5%88%97%E6%96%87%E7%AB%A0/%E7%A8%8B%E5%BA%8F%E5%91%98%E5%BA%94%E5%A6%82%E4%BD%95%E7%90%86%E8%A7%A3%E5%86%85%E5%AD%98%E4%B8%8B%E7%AF%87/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E5%85%AC%E4%BC%97%E5%8F%B7%E7%A0%81%E5%86%9C%E7%9A%84%E8%8D%92%E5%B2%9B%E6%B1%82%E7%94%9F-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%9D%E9%A2%98%E7%B3%BB%E5%88%97%E6%96%87%E7%AB%A0/%E7%A8%8B%E5%BA%8F%E5%91%98%E5%BA%94%E5%A6%82%E4%BD%95%E7%90%86%E8%A7%A3%E5%86%85%E5%AD%98%E4%B8%8B%E7%AF%87/</guid><description>
&lt;p>&lt;a href="https://mp.weixin.qq.com/s/Uu8z7GIiPnrfRhDTj93UZQ">https://mp.weixin.qq.com/s/Uu8z7GIiPnrfRhDTj93UZQ&lt;/a>
本节是操作系统系列教程的第三篇文章，属于操作系统第一章即基础篇，在真正开始操作系统相关章节前在这一部分回顾一些重要的主题，以下是目录，由于本文篇幅较多因此按&lt;a href="http://mp.weixin.qq.com/s?__biz=MzU2NTYyOTQ4OQ==&amp;amp;mid=2247483829&amp;amp;idx=1&amp;amp;sn=b9c32f56e95bdc229315e2b5ffd365cd&amp;amp;chksm=fcb986ebcbce0ffdc6c087775b895f6a0c0b83c72a91ee5614e253bea005509de8abfab6fc0e&amp;amp;scene=21#wechat_redirect">上篇&lt;/a>、&lt;a href="http://mp.weixin.qq.com/s?__biz=MzU2NTYyOTQ4OQ==&amp;amp;mid=2247483839&amp;amp;idx=1&amp;amp;sn=20276b1966b76530890e9f09c6f41892&amp;amp;chksm=fcb986e1cbce0ff73c50f1a3f943bf182d8db666b27b4e55d20bd7cbbdea3fadbfbcb7c68f26&amp;amp;scene=21#wechat_redirect">中篇&lt;/a>、下篇三次发布，目录中黑体为本篇内容，本文为该主题最后一篇。&lt;/p>
&lt;hr>
&lt;p>什么是内存&lt;/p>
&lt;p>C/C++ 内存模型&lt;/p>
&lt;p>堆区与栈区的本质&lt;/p>
&lt;p>Java、Python 等内存模型&lt;/p>
&lt;p>Java 内存模型&lt;/p>
&lt;p>Jave 中的堆区与栈区是如何实现的&lt;/p>
&lt;p>Python 内存模型&lt;/p>
&lt;p>&lt;strong>指针与引用&lt;/strong>&lt;/p>
&lt;p>&lt;strong>进程的内存模型&lt;/strong>&lt;/p>
&lt;p>&lt;strong>幻想大师 - 操作系统&lt;/strong>&lt;/p>
&lt;p>&lt;strong>总结&lt;/strong>&lt;/p>
&lt;hr>
&lt;p>指针与引用&lt;/p>
&lt;p>在各种编程语言中我们应该经常听到两个词，那就是引用或者指针。这两个词都是和内存相关的，指针和引用的作用都是 “如何找到存放在内存上的数据”。&lt;/p>
&lt;p>C/C++ 中有 “指针” 这样一个概念，而其它语言比如 Java、Python 有的只是 “引用” 这样一个概念。这两者有什么区别呢？我们打个比方你就能理解了。&lt;/p>
&lt;p>“引用”就好比一个人的外号一样，就好有个程序员叫令狐冲，但是令狐冲同学在 A 公司的英文名可能是 “Tom”，在 B 公司中可能又叫“Jerry”，那么在 A 公司中你只需要喊一声“Tom” 就能找到令狐冲同学。&lt;/p>
&lt;p>而 “指针” 强调的是位置，比如令狐冲在 A 公司的工位是“10 排第二个”，在 B 公司中的工位是“8 排第六个”，下班后回的位置在“中关村”。&lt;/p>
&lt;p>这个例子当中的令狐冲同学就好比程序语言中的对象，令狐冲的各种外号就好比对象的引用，令狐冲当前所在的位置就好比对象的指针。&lt;/p>
&lt;p>虽然通过 “引用” 和“指针”都能找到令狐冲同学，但是寻找的方式是不一样的。&lt;/p>
&lt;p>只有 C/C++ 这样的编译型语言才会有 “指针” 这样一个概念，指的是当前的对象放在了内存中的哪个位置上了。在比如 Java、Python 等语言中只有 “引用” 这样一个概念。在 C/C++ 语言中，我们可以通过指针直接找到一个对象，因为你知道这个对象就在内存中指针所指向的位置，但在 Java、Python 等语言中，当你利用引用找到对象时基本上是冲着解释器喊一句“Hey，解释器，帮我找到令狐冲这个对象”，解释器通过记录查找到这个对象，注意解释器是知道对象在内存中的真正位置的，由于直接管理内存是一项非常繁琐容易出错的事情(C/C++ 程序员一定对此有深刻体会)，因此解释器就接手了对内存直接管理，&lt;strong>Java、Python 等程序员是没有必要知道对象在内存中的真正位置的&lt;/strong>，没有指针也可以开心的写程序而且程序更加健壮，何乐不为呢，因此这些语言中是没有指针这样一个概念。&lt;/p>
&lt;p>Sun 的一篇论文中提到了为什么 Java 里没有指针。&lt;/p>
&lt;blockquote>
&lt;p>Most studies agree that pointers are one of the primary features that enable programmers to inject bugs into their code. Given that structures are gone, and arrays and strings are objects, the need for pointers to these constructs goes away. Thus, Java has no pointer data types. &amp;hellip;
You no longer have dangling pointers and trashing of memory because of incorrect pointers, because there are no pointers in Java.&lt;/p>
&lt;/blockquote>
&lt;p>大意是 Java 设计者认为指针太有技巧性以至于很容易出错，因此 Java 中没有指针。其实不只是 Java，流行的语言当中除了 C/C++ 之外几乎都没有指针。&lt;/p>
&lt;p>在这一节中，你只需要理解以下两点就可以啦。&lt;/p>
&lt;ul>
&lt;li>指针：直接在内存中找到变量所在位置。所以指针是实实在在的内存地址。&lt;/li>
&lt;li>引用：告诉解释器你想使用的变量，然后解释器再去内存中找到变量的位置。所以引用只是解释器的一个&lt;strong>承诺&lt;/strong>，只要这个变量存在，解释器就承诺能找到这个变量，程序员就可以使用这个变量，至于这个变量在内存中的什么地方是不需要程序员关心的。&lt;/li>
&lt;/ul>
&lt;h5 id="进程的内存模型">进程的内存模型&lt;/h5>
&lt;p>我们已经在前面几个小节中研究了 C/C++ 以及 Java、Python 程序的内存模型，接下来让我们回到操作系统。&lt;/p>
&lt;p>我们已经知道了，不管什么语言，最后操作系统看到的都是 C 程序，C 程序在内存运行起来就是进程。而在前面的小节当中我们已经知道进程在内存中的样子，但那里的描述其实是不完整的，也是不准确的。接下里我们就来看一下，操作系统中的进程在内存中到底是什么样子的，如下图所示 (注意这幅图描述的是 32 位操作系统下进程在内存中是什么样子的)，我们需要注意以下几点：&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/07215dae-d84d-4cc5-b26c-dae1419ad03a/640" alt="">&lt;/p>
&lt;ol>
&lt;li>在上图中多出了一块内存，注意，这块内存就是操作系统在运行的时候所占用的内存。&lt;/li>
&lt;li>每个进程独占一个连续的 4G 大小的内存，从内存地址 0 开始，一直到 0xffffffff，其中最上方的 1G 留给了操作系统使用，下方的 3G 是留给进程自己使用的，其中程序员可以操作的区域就是图中的堆区和栈区。&lt;/li>
&lt;li>你会发现代码段下方也有一点空隙没有使用，其实这是有特殊目的的，具体用途会在后面的章节中讲解。&lt;/li>
&lt;/ol>
&lt;p>现在你已经知道了进程在内存中的样子，你一定会有疑问吧，&lt;/p>
&lt;p>为什么每个进程认为自己占用的是 4G 内存呢？&lt;strong>如果我的 PC 上只有 2G 内存，进程还是认为自己拥有 4G 内存吗&lt;/strong>？&lt;/p>
&lt;p>操作系统上不是可以同时运行很多进程吗，内存是有限的，假如只有 2G，&lt;strong>每个进程都认为自己拥有 4G 内存，这不会有问题吗&lt;/strong>？&lt;/p>
&lt;p>我们首先来回答第一个问题：是的，每个进程都认为计算机上的真实内存就是 4G，而且是进程自己独占的，即使真正的物理内存只有 256MB。&lt;/p>
&lt;p>第二个问题：很显然，不管你现在看这篇文章用的电脑，iPad，安卓手机还是 iPhone，这些计算设备中的进程都是这么认为的，你能看到这篇文章说明进程认为自己拥有 4G 内存是不会出现问题的。&lt;/p>
&lt;p>在这里需要再次强调的是：&lt;/p>
&lt;p>每个进程都认为真实的内存就是 4G，其中 1G 被操作系统使用，剩余部分被进程使用，也就是可以被程序员使用。&lt;strong>注意这是不受真实物理内存限制的&lt;/strong>，也就是说，即使真实的物理只有 256MB，进程同样认为在内存是 4G，其中 1G 是操作系统的，剩余 3G 是进程自己独占的，程序员依然可以按照内存大小是 3G 来写程序。所以在大小 256MB 的真实物理内存上，程序员依然可以一次性申请超过 256MB 的内存而且可以申请成功，后续内存的使用也不受影响。&lt;/p>
&lt;p>就像我第一次知道这种魔法时一样，你肯定也会惊呼这怎么可能呢？&lt;strong>我们怎么能在 256MB 大小的内存上申请超过 256MB 的内存呢&lt;/strong>？但事实就是如此，你可以在物理内存大小为 256MB 的内存上面申请超过 256MB 的内存，而且无论物理内存大小，每个进程都认为自己拥有 4G 内存，而且是独占内存。&lt;/p>
&lt;p>这真的是太神奇了，这就是本课程的主角 - 操作系统带来的神奇魔法。&lt;/p>
&lt;h5 id="幻象大师操作系统">幻象大师——操作系统&lt;/h5>
&lt;p>这种魔法确实是真实的，这个魔法就来自我们的幻象大师 -&lt;strong>操作系统&lt;/strong>，其实进程看到的内存是操作系统制造的幻觉。操作系统让每个进程都认为内存就只有两部分，一部分是操作系统的一部分是自己的，这种魔法就称之为虚拟内存。后面的章节中会重点介绍操作系统是如何实现这种魔法的。&lt;/p>
&lt;p>&lt;strong>在虚拟内存上程序员分配内存不受真实物理内存大小的限制&lt;/strong>。&lt;/p>
&lt;p>但这仅仅是进程自己这么认为，这是操作系统给进程制造的幻觉，所以被称之为虚拟内存。虚拟内存是操作系统中极为重要的概念，和进程一样，对虚拟内存的深刻理解也是编程高手的标志之一。我会在后续文章中来为大家透彻讲解操作系统是如何做到的。&lt;/p>
&lt;h5 id="总结">总结&lt;/h5>
&lt;p>哈哈，这真是比较长的一节，希望你能坚持学到这里，没办法，内存真的是非常重要的，&lt;strong>要想学好操作系统，对内存的透彻理解是必不可少的&lt;/strong>。&lt;/p>
&lt;p>在这一节中我们认识到了其实内存仅仅就是一堆装 0 或 1 的小盒子组成，是没有什么神秘的。我们也了解了 C/C++、Java、Python 程序的内存模型，也知道了操作系统中的进程在内存中是什么样子的。同时操作系统中被被称为虚拟内存的神奇魔法也着实让人惊叹，想学习这么魔法请继续关注操作系统系列文章。&lt;/p>
&lt;p>完整阅读《程序员应如何理解内存》一文请参见下方的操作系统系列目录。&lt;/p>
&lt;hr>
&lt;p>&lt;strong>操作系统系列&lt;/strong>&lt;/p>
&lt;p>PS：我才知道原来从&lt;strong>去年三月份以后申请的公众号已经没有留言功能了&lt;/strong>，还在想为什么一直没有留言，这个问题目前还没有一个很好的解决方法，如果你有问题欢迎暂时&lt;strong>直接在我的公众号里发送消息&lt;/strong>，发送消息时注明针对哪篇文章，后面如果大家疑问较多我会建一个技术群供大家学习交流，对此如果你有其它好的想法也欢迎直接在公众号里发送消息，目的就是希望这个公众号能更好的帮到大家！如果你喜欢这类文章也请多多转发，不胜感激，今天周五，预祝大家周末愉快 :)
&lt;a href="https://mp.weixin.qq.com/s/Uu8z7GIiPnrfRhDTj93UZQ">https://mp.weixin.qq.com/s/Uu8z7GIiPnrfRhDTj93UZQ&lt;/a>&lt;/p></description></item><item><title>Docs: 程序员应如何理解内存：中篇</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E5%85%AC%E4%BC%97%E5%8F%B7%E7%A0%81%E5%86%9C%E7%9A%84%E8%8D%92%E5%B2%9B%E6%B1%82%E7%94%9F-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%9D%E9%A2%98%E7%B3%BB%E5%88%97%E6%96%87%E7%AB%A0/%E7%A8%8B%E5%BA%8F%E5%91%98%E5%BA%94%E5%A6%82%E4%BD%95%E7%90%86%E8%A7%A3%E5%86%85%E5%AD%98%E4%B8%AD%E7%AF%87/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E5%85%AC%E4%BC%97%E5%8F%B7%E7%A0%81%E5%86%9C%E7%9A%84%E8%8D%92%E5%B2%9B%E6%B1%82%E7%94%9F-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%9D%E9%A2%98%E7%B3%BB%E5%88%97%E6%96%87%E7%AB%A0/%E7%A8%8B%E5%BA%8F%E5%91%98%E5%BA%94%E5%A6%82%E4%BD%95%E7%90%86%E8%A7%A3%E5%86%85%E5%AD%98%E4%B8%AD%E7%AF%87/</guid><description>
&lt;p>&lt;a href="https://mp.weixin.qq.com/s/x52e0aGl0fC1KhXhai6MPg">https://mp.weixin.qq.com/s/x52e0aGl0fC1KhXhai6MPg&lt;/a>
本节是操作系统系列教程的第三篇文章，属于操作系统第一章即基础篇，在真正开始操作系统相关章节前在这一部分回顾一些重要的主题，以下是目录，由于本文篇幅较多因此会按&lt;a href="http://mp.weixin.qq.com/s?__biz=MzU2NTYyOTQ4OQ==&amp;amp;mid=2247483829&amp;amp;idx=1&amp;amp;sn=b9c32f56e95bdc229315e2b5ffd365cd&amp;amp;chksm=fcb986ebcbce0ffdc6c087775b895f6a0c0b83c72a91ee5614e253bea005509de8abfab6fc0e&amp;amp;scene=21#wechat_redirect">上篇&lt;/a>、中篇、下篇三次发布，目录中黑体为本篇内容。&lt;/p>
&lt;hr>
&lt;p>什么是内存&lt;/p>
&lt;p>C/C++ 内存模型&lt;/p>
&lt;p>&lt;strong>堆区与栈区的本质&lt;/strong>&lt;/p>
&lt;p>&lt;strong>Java、Python 等内存模型&lt;/strong>&lt;/p>
&lt;p>&lt;strong>Java 内存模型&lt;/strong>&lt;/p>
&lt;p>&lt;strong>Jave 中的堆区与栈区是如何实现的&lt;/strong>&lt;/p>
&lt;p>&lt;strong>Python 内存模型&lt;/strong>&lt;/p>
&lt;p>指针与引用&lt;/p>
&lt;p>进程的内存模型&lt;/p>
&lt;p>幻想大师 - 操作系统&lt;/p>
&lt;p>总结&lt;/p>
&lt;hr>
&lt;h5 id="堆与栈的本质是什么">堆与栈的本质是什么&lt;/h5>
&lt;p>在编程语言中，堆区和栈区本质上都是内存，因此二者在本质上没有任何区别，只不过这两块内存的&lt;strong>使用方式&lt;/strong>是不一样的。&lt;/p>
&lt;p>在数据结构与算法中，我们也有堆和栈的概念，但那里指的不是内存，而是两种数据结构。&lt;/p>
&lt;p>你可能会想，我们为什么要费尽心力的提出堆和栈这两个概念呢？之所以需要区分两种内存用法，根源在于：&lt;strong>内存是有限的&lt;/strong>。&lt;/p>
&lt;p>如果计算机内存是无限的，那么我们根本就不用这么麻烦的给内存划分两个区域，在其中的一个区域中这样使用内存，另一区域那样使用内存，这些都是不需要的。即使在今天 PC 内存普遍都在 8G、16G，这依然是不够的，因此我们需要合理的来安排内存的使用，堆和栈就是为达到这一目的而采用的技术。&lt;/p>
&lt;p>你会发现栈其实是一种非常巧妙的内存使用方法。函数调用完成后，函数运行过程中占用的内存就会被释放掉，这样，只要程序员代码写的合理 (栈帧不至于过大)，那我们程序就可以一直运行下去，而不会出现内存不足的现象。程序员在栈区不需要担心内存分配释放问题，因为这一切都是自动进行的。而如果程序员想自己控制内存，那么可以选择在堆上进行内存分配。因此这里提供了两种选择，一种是 “自动的”，一种是 “手动的”，目的都是在合理使用内存的同时提供给程序员最大的灵活性。&lt;/p>
&lt;p>堆和栈是计算机科学中很优秀的设计思想，这种设计思想充分的体现了计算机如何&lt;strong>合理且灵活&lt;/strong>的使用有限资源。&lt;/p>
&lt;p>堆区和栈区对 C/C++ 程序员来说就是实实在在的内存，而对于 Java、Python 等语言的程序员来说又该如何理解内存呢?&lt;/p>
&lt;h5 id="javapython-等内存模型">Java、Python 等内存模型&lt;/h5>
&lt;p>当 Java、Python 等语言的程序在执行时其解释器的内存布局同样如下图所示，我们之前讲过，解释器也是一个 C/C++ 程序，因此这里的代码段包含的是解释器的实现代码而不是 Java、Python 等代码，这一点大家一定要注意。&lt;/p>
&lt;p>&amp;ldquo;C/C++ 程序员面对的是实实在在的物理内存，Java、Python 等程序面对的是解释器。&amp;rdquo;&lt;/p>
&lt;p>C/C++ 分配内存是直接在物理内存中进行的，而 Java、Python 等程序是将内存分配请求交给解释器，解释器再去物理内存上进行分配。希望大家务必理解这一点。&lt;/p>
&lt;p>Java、Python 等程序员是看不到如下图所示的内存布局的，因为这一切都是解释器才能看到的，解释器对 Java、Python 等程序员屏蔽了这些。Java、Python 等程序员也无需关心解释器的内存布局。&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/20f93fbf-ca56-4444-9809-2d24fd93a6f0/640" alt="">&lt;/p>
&lt;p>Java、Python 等程序的一大优点就是内存的自动化管理，而 C/C++ 程序员需要自己来管理从堆上分配的内存。内存管理这一项工作在 Java、Python 等程序中被解释器接管了，解释器的这项功能被称为 “垃圾回收器”。&lt;/p>
&lt;p>在非 C/C++ 语言中，我们来看两个有代表性的语言，首先我们看一下 Java。&lt;/p>
&lt;h6 id="java-内存模型">Java 内存模型&lt;/h6>
&lt;p>Java 的内存模型中同样有栈和堆这样的概念，如下图所示，在 Java 函数中我们定义的内置数据类型比如 int a = 0，是直接存放在栈上的，引用类型，也就是用 new 关键字定义的变量是分配在堆上的。和 C/C++ 一样，每个 Java 函数在执行时都有自己的栈帧。随着函数的调用，栈不断的扩大。当函数调用完毕后栈帧被回收，在堆上分配的变量依然可以被后续函数使用。Java 程序员无需像 C/C++ 程序员一样需要关心内存回收的问题，这一切都是 Java 的解释器 JVM 来管理的。&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/20f93fbf-ca56-4444-9809-2d24fd93a6f0/640" alt="">&lt;/p>
&lt;p>在用法上 Java 中的堆和栈和 C/C++ 是一样的，只不过 Java 程序员无需关心内存的释放问题。但是好奇的同学可能会问，C/C++ 中的堆和栈我已经清楚了，因为 C/C++ 程序运行时在内存中的样子已经在《C/C++ 内存模型》这一小节中详细的讲述了，那么 Java 中的堆和栈在内存中是什么样子的呢，就是和上图一样吗？要回答这个问题，就要涉及到 Java 中的堆和栈是如何实现的。&lt;/p>
&lt;h6 id="java-中的堆和栈是如何实现的">Java 中的堆和栈是如何实现的&lt;/h6>
&lt;p>如果你自己设计过一门语言的话，你应该会很清楚这个问题。&lt;/p>
&lt;p>我们先回答上一节中提到的问题，那就是 Java 中的堆和栈就是如上图所示的那样吗？是这样的，作为 Java 程序员在写代码时脑海里有上面这张图基本上就够用了。但是，Java 中的堆和栈不同于 C/C++ 当中的堆和栈。&lt;/p>
&lt;p>我们已经知道 Java 中的内存管理其实是解释器 JVM 来搞定的，作为 C/C++ 程序，JVM 的内存布局就如下图所示。&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/20f93fbf-ca56-4444-9809-2d24fd93a6f0/640" alt="">&lt;/p>
&lt;p>一般情况下，当 JVM 运行一个 Java 函数时需要在堆上创建出 Java 函数的栈帧，然后把这些栈帧放入栈中 (这里的栈指的是具有先进后出性质的数据结构)。希望大家不要被这句话绕晕，这里出现了两个 “栈”，但是含义完全不同。&lt;/p>
&lt;ul>
&lt;li>Java 栈帧：指的是上图中我们看到的栈。&lt;/li>
&lt;li>栈帧放入到栈：我们在数据结构课程中都学过栈，栈有 push 和 pop 两种操作，把栈帧放入栈指的是把栈帧 push 到 JVM 所持有的栈这种数据结构当中，以此来模拟 C/C++ 程序执行过程中函数栈帧先进后出的这种性质，当一个 Java 函数被执行完毕后，JVM pop 掉该函数的栈帧。
如果你想在代码级别来理解这个过程，大体上可以参考下面的代码，注意 JVM 是 C/C++ 程序，这里的代码是一个极其简单的描述。&lt;strong>你可以看到如何组织栈帧完全是 JVM 设计者来决定的，只要栈帧具备先进后出的性质就可以。&lt;/strong>&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">RunJavaFunction&lt;/span>(JVM&lt;span style="color:#f92672">*&lt;/span> jvm&lt;span style="color:#960050;background-color:#1e0010">，&lt;/span> string javaFunction) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> stackFrame&lt;span style="color:#f92672">*&lt;/span> frame &lt;span style="color:#f92672">=&lt;/span> (stackFrame&lt;span style="color:#f92672">*&lt;/span>) malloc(&lt;span style="color:#66d9ef">sizeof&lt;/span>(stackFrame));
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> jvm&lt;span style="color:#f92672">-&amp;gt;&lt;/span>stack&lt;span style="color:#f92672">-&amp;gt;&lt;/span>push(frame);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> run(javaFunction, frame);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> jvm&lt;span style="color:#f92672">-&amp;gt;&lt;/span>stack&lt;span style="color:#f92672">-&amp;gt;&lt;/span>pop();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>JVM 会在自己的堆中为用 new 修饰的对象创建内存，这里的堆就是如上图所示的堆，是可以要记住 JVM 是一个 C/C++ 程序，JVM 看到的堆才是如上图所示的那样。所以你会发现，一般情况下，&lt;strong>Java 中的栈和 Java 对象都是 JVM 在自己的堆上分配出来的&lt;/strong>，这就是 Java 中堆和栈是如何实现的。&lt;/p>
&lt;p>在讲解完 Java 的内存模型后，我们来看一下 Python 的。&lt;/p>
&lt;h6 id="python-内存模型">&lt;strong>Python 内存模型&lt;/strong>&lt;/h6>
&lt;p>Python 的内存模型和 Java 其实是类似的，Java 程序员脑海中的那张图同样适用于 Python 程序员。&lt;/p>
&lt;p>Python 语言中的解释器比较多，比如 CPython，PyPy 等，在这里我们以 Python 默认的解释器 CPython 为例来说明，我们已经知道了解释器其实也是一个 C 程序，CPython 也不例外，下图左侧就是我们已经熟悉的 C/C++ 内存布局，我们把堆区放大，如下图右侧所示。我们可以看到 Python 的解释器把自己的堆区划分成了两部分，分别是 Object-specific memory 区域，以及 Python core 区域：&lt;/p>
&lt;p>Object-specific memory 这个区域专门用来存放 PyObject。你也许已经知道了，Python 中所有的数据类型比如 int，dict，str 等都是一个对象，叫做 PyObject。当我们在 Python 中创建一个变量比如 dict 时，CPython 就会在堆区的上半部分 (Object-specific memory) 中分配一块内存，创建一个 PyObject，这个 PyObject 用来存放我们的 dict。&lt;/p>
&lt;p>Python core：所有非 PyObject 的内存请求都在这里分配的。&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/20f93fbf-ca56-4444-9809-2d24fd93a6f0/640" alt="">&lt;/p>
&lt;p>所以你会发现，Python 中所有的内存同样是解释器在自己的堆上分配的。&lt;/p>
&lt;p>&lt;em>本文最后一部分将在《程序员应如何理解内存：下篇》中继续。&lt;/em>&lt;/p>
&lt;hr>
&lt;p>&lt;strong>操作系统系列&lt;/strong>
&lt;a href="https://mp.weixin.qq.com/s/x52e0aGl0fC1KhXhai6MPg">https://mp.weixin.qq.com/s/x52e0aGl0fC1KhXhai6MPg&lt;/a>&lt;/p></description></item><item><title>Docs: 公众号,码农的荒岛求生-操作系统话题系列文章</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E5%85%AC%E4%BC%97%E5%8F%B7%E7%A0%81%E5%86%9C%E7%9A%84%E8%8D%92%E5%B2%9B%E6%B1%82%E7%94%9F-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%9D%E9%A2%98%E7%B3%BB%E5%88%97%E6%96%87%E7%AB%A0/%E5%85%AC%E4%BC%97%E5%8F%B7%E7%A0%81%E5%86%9C%E7%9A%84%E8%8D%92%E5%B2%9B%E6%B1%82%E7%94%9F-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%9D%E9%A2%98%E7%B3%BB%E5%88%97%E6%96%87%E7%AB%A0/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E5%85%AC%E4%BC%97%E5%8F%B7%E7%A0%81%E5%86%9C%E7%9A%84%E8%8D%92%E5%B2%9B%E6%B1%82%E7%94%9F-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%9D%E9%A2%98%E7%B3%BB%E5%88%97%E6%96%87%E7%AB%A0/%E5%85%AC%E4%BC%97%E5%8F%B7%E7%A0%81%E5%86%9C%E7%9A%84%E8%8D%92%E5%B2%9B%E6%B1%82%E7%94%9F-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%9D%E9%A2%98%E7%B3%BB%E5%88%97%E6%96%87%E7%AB%A0/</guid><description>
&lt;p>&lt;a href="https://mp.weixin.qq.com/mp/appmsgalbum?__biz=Mzg4OTYzODM4Mw==&amp;amp;action=getalbum&amp;amp;album_id=1923404049802985480&amp;amp;scene=173&amp;amp;from_msgid=2247485655&amp;amp;from_itemidx=1&amp;amp;count=3&amp;amp;nolastread=1#wechat_redirect">系列文章目录&lt;/a>&lt;/p></description></item><item><title>Docs: 函数运行时在内存中是什么样子？</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E5%85%AC%E4%BC%97%E5%8F%B7%E7%A0%81%E5%86%9C%E7%9A%84%E8%8D%92%E5%B2%9B%E6%B1%82%E7%94%9F-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%9D%E9%A2%98%E7%B3%BB%E5%88%97%E6%96%87%E7%AB%A0/%E5%87%BD%E6%95%B0%E8%BF%90%E8%A1%8C%E6%97%B6%E5%9C%A8%E5%86%85%E5%AD%98%E4%B8%AD%E6%98%AF%E4%BB%80%E4%B9%88%E6%A0%B7%E5%AD%90/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E5%85%AC%E4%BC%97%E5%8F%B7%E7%A0%81%E5%86%9C%E7%9A%84%E8%8D%92%E5%B2%9B%E6%B1%82%E7%94%9F-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%9D%E9%A2%98%E7%B3%BB%E5%88%97%E6%96%87%E7%AB%A0/%E5%87%BD%E6%95%B0%E8%BF%90%E8%A1%8C%E6%97%B6%E5%9C%A8%E5%86%85%E5%AD%98%E4%B8%AD%E6%98%AF%E4%BB%80%E4%B9%88%E6%A0%B7%E5%AD%90/</guid><description>
&lt;blockquote>
&lt;p>参考：&lt;a href="https://mp.weixin.qq.com/s/CIK6oYeAtjXyh9oCfCFnxA">公众号,码农的荒岛求生&lt;/a>&lt;/p>
&lt;/blockquote>
&lt;p>在开始本篇的内容前，我们先来思考几个问题。&lt;/p>
&lt;ol>
&lt;li>
&lt;p>我们先来看一段简单的代码：&lt;/p>
&lt;p>void func(int a) {
if (a &amp;gt; 100000000) return;
int arr[100] = {0};
func(a + 1);
}&lt;/p>
&lt;/li>
&lt;/ol>
&lt;p>你能看出这段代码会有什么问题吗？&lt;/p>
&lt;ol start="2">
&lt;li>
&lt;p>我们在上一篇文章《&lt;strong>高性能高并发服务器是如何实现的&lt;/strong>》中提到了一项关键技术——协程，你知道协程的本质是什么吗？有的同学可能会说是用户态线程，那么什么是用户态线程，这是怎么实现的？&lt;/p>
&lt;/li>
&lt;li>
&lt;p>函数运行起来后在内存中是什么样子？&lt;/p>
&lt;/li>
&lt;/ol>
&lt;p>这几个问题看似没什么关联，但这背后都指向一样东西，这就是所谓的函数&lt;strong>运行时栈&lt;/strong>，&lt;strong>run time stack&lt;/strong>。&lt;/p>
&lt;p>接下来我们就好好看看到底什么是函数运行时栈，为什么彻底理解函数运行时栈对程序员来说非常重要。&lt;/p>
&lt;p>&lt;strong>从进程、线程到函数调用&lt;/strong>&lt;/p>
&lt;p>汽车在高速上行驶时有很多信息，像速度、位置等等，通过这些信息我们可以直观的感受汽车的运行时状态。&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/wid7ue/1616167863819-23f4e86d-49f6-4ae3-bc42-2d6b58e4b526.png" alt="">&lt;/p>
&lt;p>同样的，程序在运行时也有很多信息，像有哪些程序正在运行、这些程序执行到了哪里等等，通过这些信息我们可以直观的感受系统中程序运行的状态。&lt;/p>
&lt;p>其中，我们创造了进程、线程这样的概念来记录有哪些程序正在运行，关于进程和线程的概念请参见《&lt;strong>看完这篇还不懂进程、线程与线程池你来打我&lt;/strong>》。&lt;/p>
&lt;p>&lt;strong>进程和线程的运行体现在函数执行上&lt;/strong>，函数的执行除了函数内部执行的顺序执行还有子函数调用的控制转移以及子函数执行完毕的返回。其中函数内部的顺序执行乏善可陈，重点是函数的调用。&lt;/p>
&lt;p>因此接下来我们的视角将从宏观的进程和线程拉近到微观下的函数调用，重点来讨论一下函数调用是怎样实现的。&lt;/p>
&lt;p>&lt;strong>函数执行的活动轨迹：栈&lt;/strong>&lt;/p>
&lt;p>玩过游戏的同学应该知道，有时你为了完成一项主线任务不得不去打一些支线的任务，支线任务中可能还有支线任务，当一个支线任务完成后退回到前一个支线任务，这是什么意思呢，举个例子你就明白了。&lt;/p>
&lt;p>假设主线任务西天取经 A 依赖支线任务收服孙悟空 B 和收服猪八戒 C，也就是说收服孙悟空 B 和收服猪八戒 C 完成后才能继续主线任务西天取经 A；&lt;/p>
&lt;p>支线任务收服孙悟空 B 依赖任务拿到紧箍咒 D，只有当任务 D 完成后才能回到任务 B；&lt;/p>
&lt;p>整个任务的依赖关系如图所示：&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/wid7ue/1616167863816-401e714c-969d-4c84-809d-da6dbda9afd5.png" alt="">&lt;/p>
&lt;p>现在我们来模拟一下任务完成过程。&lt;/p>
&lt;p>首先我们来到任务 A，执行主线任务：&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/wid7ue/1616167863838-f93491ad-74b3-4a4d-b08d-25d9696c481f.png" alt="">&lt;/p>
&lt;p>执行任务 A 的过程中我们发现任务 A 依赖任务 B，这时我们暂停任务 A 去执行任务 B：&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/wid7ue/1616167863822-2de8c022-ddff-4ed8-baa2-0f25fb36ccd2.png" alt="">&lt;/p>
&lt;p>执行任务 B 的时候，我们又发现依赖任务 D：&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/wid7ue/1616167863845-17cae4f5-01ec-424e-ae6e-917c687207e5.png" alt="">&lt;/p>
&lt;p>执行任务 D 的时候我们发现该任务不再依赖任何其它任务，因此 C 完成后我们可以会退到前一个任务，也就是 B：&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/wid7ue/1616167863842-63a7ee82-9067-443a-a905-0f89e32625f4.png" alt="">&lt;/p>
&lt;p>任务 B 除了依赖任务 C 外不再依赖其它任务，这样任务 B 完成后就可以回到任务 A：&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/wid7ue/1616167863837-23f565d8-34ab-4b12-81b3-e95e1cb5c5eb.png" alt="">&lt;/p>
&lt;p>现在我们回到了主线任务 A，依赖的任务 B 执行完成，接下来是任务 C：&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/wid7ue/1616167863822-9b6d5976-5e0b-4b48-b2c9-c74286a5a3bd.png" alt="">&lt;/p>
&lt;p>和任务 D 一样，C 不依赖任何其它其它任务，任务 C 完成后就可以再次回到任务 A，再之后任务 A 执行完毕，整个任务执行完成。&lt;/p>
&lt;p>让我们来看一下整个任务的活动轨迹：&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/wid7ue/1616167863834-ae1821d1-8421-46e4-b2d9-fd695b0faabf.png" alt="">&lt;/p>
&lt;p>仔细观察，实际上你会发现这是一个 First In Last Out 的顺序，天然适用于栈这种数据结构来处理。&lt;/p>
&lt;p>再仔细看一下栈顶的轨迹，也就是 A、B、D、B、A、C、A，&lt;strong>实际上你会发现这里的轨迹就是任务依赖树的遍历过程&lt;/strong>，是不是很神奇，这也是为什么树这种数据结构的遍历除了可以用递归也可以用栈来实现的原因。&lt;/p>
&lt;p>&lt;strong>A Box&lt;/strong>&lt;/p>
&lt;p>函数调用也是同样的道理，你把上面的 ABCD 换成函数 ABCD，本质不变。&lt;/p>
&lt;p>因此，现在我们知道了，使用栈这种结构就可以用来保存函数调用信息。&lt;/p>
&lt;p>和游戏中的每个任务一样，当函数在运行时每个函数也要有自己的一个“小盒子”，&lt;strong>这个小盒子中保存了函数运行时的各种信息&lt;/strong>，这些小盒子通过栈这种结构组织起来，这个小盒子就被称为栈帧，stack frames，也有的称之为 call stack，不管用什么命名方式，总之，就是这里所说的小盒子，这个小盒子就是函数运行起来后占用的内存，&lt;strong>这些小盒子构成了我们通常所说的栈区&lt;/strong>。关于栈区详细的讲解你可以参考《&lt;strong>深入理解操作系统：程序员应如何理解内存&lt;/strong>》一文。&lt;/p>
&lt;p>那么函数调用时都有哪些信息呢？&lt;/p>
&lt;p>&lt;strong>控制转移&lt;/strong>&lt;/p>
&lt;p>我们知道当函数 A 调用函数 B 的时候，控制从 A 转移到了 B，所谓控制其实就是指 CPU 执行属于哪个函数的机器指令，CPU 从开始执行属于函数 A 的指令切换到执行属于函数 B 的指令，我们就说控制从函数 A 转移到了函数 B。&lt;/p>
&lt;p>控制从函数 A 转移到函数 B，那么我们需要有这样两个信息：&lt;/p>
&lt;ul>
&lt;li>我从哪里来 (返回)&lt;/li>
&lt;li>要到去哪里 (跳转)&lt;/li>
&lt;/ul>
&lt;p>是不是很简单，就好比你出去旅游，你需要知道去哪里，还需要记住回家的路。&lt;/p>
&lt;p>函数调用也是同样的道理。&lt;/p>
&lt;p>当函数 A 调用函数 B 时，我们只要知道：&lt;/p>
&lt;ul>
&lt;li>函数 A 对于的机器指令执行到了哪里 (我从哪里来，返回)&lt;/li>
&lt;li>函数 B 第一条机器指令所在的地址 (要到哪里去，跳转)&lt;/li>
&lt;/ul>
&lt;p>有这两条信息就足以让 CPU 开始执行函数 B 对应的机器指令，当函数 B 执行完毕后跳转回函数 A。&lt;/p>
&lt;p>那么这些信息是怎么获取并保持的呢？&lt;/p>
&lt;p>现在我们就可以打开这个小盒子，看看是怎么使用的了。&lt;/p>
&lt;p>假设函数 A 调用函数 B，如图所示：&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/wid7ue/1616167863830-03b8519b-e4cf-487c-ace0-4898c498f187.png" alt="">&lt;/p>
&lt;p>当前，CPU 执行函数 A 的机器指令，该指令的地址为 0x400564，接下来 CPU 将执行下一条机器指令也就是:&lt;/p>
&lt;pre>&lt;code>call 0x400540
&lt;/code>&lt;/pre>
&lt;p>1
Plain Text&lt;/p>
&lt;p>这条机器指令是什么意思呢？&lt;/p>
&lt;p>这条机器指令对应的就是我们在代码中所写的函数调用，注意 call 后有一条机器指令地址，注意观察上图你会看到，&lt;strong>该地址就是函数 B 的第一条机器指令&lt;/strong>，从这条机器指令后 CPU 将跳转到函数 B。&lt;/p>
&lt;p>现在我们已经解决了控制跳转的“要到哪里去”问题，当函数 B 执行完毕后怎么跳转回来呢？&lt;/p>
&lt;p>原来，call 指令除了给出跳转地址之外还有这样一个作用，也就是&lt;strong>把 call 指令的下一条指令的地址，也就是 0x40056a push 到函数 A 的栈帧中&lt;/strong>，如图所示：&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/wid7ue/1616167863876-d1603ae8-ef26-4c08-9ac2-b726e0bcd29d.png" alt="">&lt;/p>
&lt;p>现在，函数 A 的小盒子变大了一些，因为装入了返回地址：&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/wid7ue/1616167863851-cab15852-0eac-40e6-a7f5-4a90c7945322.png" alt="">&lt;/p>
&lt;p>现在 CPU 开始执行函数 B 对应的机器指令，注意观察，函数 B 也有一个属于自己的小盒子(栈帧)，可以往里面扔一些必要的信息。&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/wid7ue/1616167863856-d73384c9-8f41-4d32-9b45-6444bb58fa6f.png" alt="">&lt;/p>
&lt;p>如果函数 B 中又调用了其它函数呢？&lt;/p>
&lt;p>道理和函数 A 调用函数 B 是一样的。&lt;/p>
&lt;p>让我们来看一下函数 B 最后一条机器指令 ret，这条机器指令的作用是告诉 CPU 跳转到函数 A 保存在栈帧上的返回地址，这样当函数 B 执行完毕后就可以跳转到函数 A 继续执行了。&lt;/p>
&lt;p>至此，我们解决了控制转移中“我从哪里来”的问题。&lt;/p>
&lt;p>&lt;strong>传递参数与获取返回值&lt;/strong>&lt;/p>
&lt;p>函数调用与返回使得我们可以编写函数，进行函数调用。但调用函数除了提供函数名称之外还需要传递参数以及获取返回值，那么这又是怎样实现的呢？&lt;/p>
&lt;p>在 x86-64 中，多数情况下参数的传递与获取返回值是通过&lt;strong>寄存器&lt;/strong>来实现的。&lt;/p>
&lt;p>假设函数 A 调用了函数 B，函数 A 将一些参数写入相应的寄存器，当 CPU 执行函数 B 时就可以从这些寄存器中获取参数了。&lt;/p>
&lt;p>同样的，函数 B 也可以将返回值写入寄存器，当函数 B 执行结束后函数 A 从该寄存器中就可以读取到返回值了。&lt;/p>
&lt;p>我们知道寄存器的数量是有限的，当传递的参数个数多于寄存器的数量该怎么办呢？&lt;/p>
&lt;p>这时那个属于函数的小盒子也就是栈帧又能发挥作用了。&lt;/p>
&lt;p>原来，当参数个数多于寄存器数量时剩下的参数直接放到栈帧中，这样被调函数就可以&lt;strong>从前一个函数的栈帧中获取到参数了&lt;/strong>。&lt;/p>
&lt;p>现在栈帧的样子又可以进一步丰富了，如图所示：&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/wid7ue/1616167863886-677bf64d-2fed-494a-9752-f05d4c190543.png" alt="">&lt;/p>
&lt;p>从图中我们可以看到，调用函数 B 时有部分参数放到了函数 A 的栈帧中，同时函数 A 栈帧的顶部依然保存的是返回地址。&lt;/p>
&lt;p>&lt;strong>局部变量&lt;/strong>&lt;/p>
&lt;p>我们知道在函数内部定义的变量被称为局部变量，这些变量在函数运行时被放在了哪里呢？&lt;/p>
&lt;p>原来，这些变量同样可以放在寄存器中，但是当局部变量的数量超过寄存器的时候这些变量就必须放到栈帧中了。&lt;/p>
&lt;p>因此，我们的栈帧内容又一步丰富了。&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/wid7ue/1616167863839-6619e28e-de13-488e-8a5e-cea1eac87441.png" alt="">&lt;/p>
&lt;p>细心的同学可能会有这样的疑问，我们知道寄存器是共享资源可以被所有函数使用，既然可以将函数 A 的局部变量写入寄存器，那么当函数 A 调用函数 B 时，函数 B 的局部变量也可以写到寄存器，这样的话当函数 B 执行完毕回到函数 A 时寄存器的值已经被函数 B 修改过了，这样会有问题吧。&lt;/p>
&lt;p>这样的确会有问题，因此我们在向寄存器中写入局部变量之前，&lt;strong>一定要先将寄存器中开始的值保存起来&lt;/strong>，当寄存器使用完毕后再恢复原值就可以了。&lt;/p>
&lt;p>那么我们要将寄存器中的原始值保存在哪里呢？&lt;/p>
&lt;p>有的同学可能已经猜到了，没错，依然是函数的栈帧中。&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/wid7ue/1616167863856-bcf721f0-0db5-4faa-9eae-99683999d194.png" alt="">&lt;/p>
&lt;p>最终，我们的小盒子就变成了如图所示的样子，当寄存器使用完毕后根据栈帧中保存的初始值恢复其内容就可以了。&lt;/p>
&lt;p>现在你应该知道函数在运行时到底是什么样子了吧，以上就是问题 3 的答案。&lt;/p>
&lt;p>&lt;strong>Big Picture&lt;/strong>&lt;/p>
&lt;p>需要再次强调的一点就是，上述讨论的栈帧就位于我们常说的栈区。&lt;/p>
&lt;p>栈区，属于进程地址空间的一部分，如图所示，我们将栈区放大就是图左边的样子。&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/wid7ue/1616167863877-0efea1a4-debc-473e-88a6-977d82c4969f.png" alt="">&lt;/p>
&lt;p>关于栈区详细的讲解你可以参考《&lt;strong>深入理解操作系统：程序员应如何理解内存&lt;/strong>》这篇。&lt;/p>
&lt;p>最后，让我们回到文章开始的这段简单代码：&lt;/p>
&lt;pre>&lt;code>void func(int a) {
if (a &amp;gt; 100000000) return;
int arr[100] = {0};
func(a + 1);
}
void main(){
func(0);
}
&lt;/code>&lt;/pre>
&lt;p>1
2
3
4
5
6
7
8
9
10
Plain Text&lt;/p>
&lt;p>想一想这段代码会有什么问题？&lt;/p>
&lt;p>原来，&lt;strong>栈区是有大小限制的&lt;/strong>，当超过限制后就会出现著名的&lt;strong>栈溢出&lt;/strong>问题，显然上述代码会导致这一问题的出现。&lt;/p>
&lt;p>因此：&lt;/p>
&lt;ol>
&lt;li>不要创建过大的局部变量&lt;/li>
&lt;li>函数栈帧，也就是调用层次不能太多&lt;/li>
&lt;/ol>
&lt;p>&lt;strong>总结&lt;/strong>&lt;/p>
&lt;p>本章我们从几个看似没什么关联的问题出发，详细讲解了函数运行时栈是怎么一回事，为什么我们不能创建过多的局部变量。细心的同学会发现第 2 个问题我们没有解答，这个问题的讲解放到下一篇，也就是协程中讲解。&lt;/p>
&lt;p>希望这篇文章能对大家理解函数运行时栈有所帮助。&lt;/p></description></item><item><title>Docs: 神秘！申请内存时底层发生了什么？</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E5%85%AC%E4%BC%97%E5%8F%B7%E7%A0%81%E5%86%9C%E7%9A%84%E8%8D%92%E5%B2%9B%E6%B1%82%E7%94%9F-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%9D%E9%A2%98%E7%B3%BB%E5%88%97%E6%96%87%E7%AB%A0/%E7%A5%9E%E7%A7%98%E7%94%B3%E8%AF%B7%E5%86%85%E5%AD%98%E6%97%B6%E5%BA%95%E5%B1%82%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E5%85%AC%E4%BC%97%E5%8F%B7%E7%A0%81%E5%86%9C%E7%9A%84%E8%8D%92%E5%B2%9B%E6%B1%82%E7%94%9F-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%9D%E9%A2%98%E7%B3%BB%E5%88%97%E6%96%87%E7%AB%A0/%E7%A5%9E%E7%A7%98%E7%94%B3%E8%AF%B7%E5%86%85%E5%AD%98%E6%97%B6%E5%BA%95%E5%B1%82%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88/</guid><description>
&lt;blockquote>
&lt;p>参考：&lt;a href="https://mp.weixin.qq.com/s/DN-ckM1YrPMeicN7P9FvXg">公众号,码农的荒岛求生&lt;/a>&lt;/p>
&lt;/blockquote>
&lt;p>内存的申请释放对程序员来说就像空气一样自然，你几乎不怎么能意识到，有时你意识不到的东西却无比重要，申请过这么多内存，&lt;strong>你知道申请内存时底层都发生什么了吗&lt;/strong>？&lt;/p>
&lt;p>大家都喜欢听故事，我们就从神话故事开始吧。&lt;/p>
&lt;h1 id="三界">三界&lt;/h1>
&lt;p>中国古代的神话故事通常有 “三界” 之说，一般指的是天、地、人三界，天界是神仙所在的地方，凡人无法企及；人界说的是就是人间；地界说的是阎罗王所在的地方，孙悟空上天入地无所不能就是说可以在这三界自由出入。&lt;/p>
&lt;p>有的同学可能会问，这和计算机有什么关系呢？&lt;/p>
&lt;p>原来，我们的代码也是分三六九等的，程序运行起来后也是有 “三界” 之说的，程序运行起来的 “三界” 就是这样的：&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/3ee0c566-76fb-4b04-b794-ee46baf1d822/640" alt="">&lt;/p>
&lt;p>x86 CPU 提供了 “四界”：0,1,2,3，&lt;strong>这几个数字其实就是指 CPU 的几种工作状态&lt;/strong>，数字越小表示 CPU 的特权越大，0 号状态下 CPU 特权最大，可以执行任何指令，数字越大表示 CPU 特权越小，3 号状态下 CPU 特权最小，不能执行一些特权指令。&lt;/p>
&lt;p>一般情况下系统只使用 0 和 3，因此确切的说是 “两界”，这两界可不是说天、地，这两界指的是“用户态(3)” 以及“内核态(0)”，接下来我们看看什么是内核态、什么是用户态。&lt;/p>
&lt;h2 id="内核态">内核态&lt;/h2>
&lt;p>什么是内核态？当 CPU 执行操作系统代码时就处于内核态，&lt;strong>在内核态下 CPU 可以执行任何机器指令、访问所有地址空间、不受限制的访问任何硬件&lt;/strong>，可以简单的认为内核态就是 “天界”，在这里的代码(操作系统代码) 无所不能。&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/3ee0c566-76fb-4b04-b794-ee46baf1d822/640" alt="">&lt;/p>
&lt;h2 id="用户态">用户态&lt;/h2>
&lt;p>什么是用户态？当 CPU 执行我们写的 “普通” 代码 (非操作系统、驱动程序员) 时就处于用户态，粗糙的划分方法就是除了操作系统之外的代码，就像我们写的 HelloWorld 程序。&lt;/p>
&lt;p>用户态就好比 “人界”，在用户态我们的代码处处受限，不能直接访问硬件、不能访问特定地址空间，否则神仙(操作系统) 直接将你 kill 掉，这就是著名的 Segmentation fault、不能执行特权指令，等等。&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/3ee0c566-76fb-4b04-b794-ee46baf1d822/640" alt="">&lt;/p>
&lt;p>关于这一部分的详细讲解，请参见《&lt;a href="https://mp.weixin.qq.com/mp/appmsgalbum?__biz=MzU2NTYyOTQ4OQ==&amp;amp;action=getalbum&amp;amp;album_id=1433368223499796481#wechat_redirect">深入理解操作系统&lt;/a>》系列文章。&lt;/p>
&lt;h2 id="跨界">跨界&lt;/h2>
&lt;p>孙悟空神通广大，一个跟斗就能从人间跑到天上去骂玉帝老儿，程序员就没有这个本领了。普通程序永远也去不了内核态，只能以通信的方式从用户态往内核态传递信息。&lt;/p>
&lt;p>操作系统为普通程序员留了一些特定的暗号，这些暗号就和普通函数一样，程序员通过调用这些暗号就能向操作系统请求服务了，这些像普通函数一样的暗号就被称为&lt;a href="http://mp.weixin.qq.com/s?__biz=MzU2NTYyOTQ4OQ==&amp;amp;mid=2247483880&amp;amp;idx=1&amp;amp;sn=26ab417ffdd46b2956e5dc07516477af&amp;amp;chksm=fcb986b6cbce0fa0e0959341ec9c7a0c2db0acd9f5a1250e5cbe33306da2f10f1f3cd08152aa&amp;amp;scene=21#wechat_redirect">&lt;strong>系统调用&lt;/strong>&lt;/a>，System Call，通过系统调用我们可以让操作系统代替我们完成一些事情，像打开文件、网络通信等等。&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/3ee0c566-76fb-4b04-b794-ee46baf1d822/640" alt="">&lt;/p>
&lt;p>你可能有些疑惑，什么，还有系统调用这种东西，为什么我没调用过也可以打开文件、进行网络通信？&lt;/p>
&lt;h2 id="标准库">标准库&lt;/h2>
&lt;p>虽然我们可以通过系统让操作系统替我们完成一些特定任务，但这些系统调用都是和操作系统强相关的，Linux 和 Windows 的系统调用就完全不同。&lt;/p>
&lt;p>如果你直接使用系统调用的话，那么 Linux 版本的程序就没有办法在 Windows 上运行，因此我们需要某种标准，该标准对程序员屏蔽底层差异，这样程序员写的程序就无需修改的在不同操作系统上运行了。&lt;/p>
&lt;p>在 C 语言中，这就是所谓的&lt;strong>标准库&lt;/strong>。&lt;/p>
&lt;p>注意，标准库代码也是运行在用户态的，并不是神仙 (操作系统)，一般来说，我们调用标准库去打开文件、网络通信等等，标准库再根据操作系统选择对应的系统调用。&lt;/p>
&lt;p>从分层的角度看，我们的程序一般都是这样的汉堡包类型：&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/3ee0c566-76fb-4b04-b794-ee46baf1d822/640" alt="">&lt;/p>
&lt;p>最上层是应用程序，应用程序一般只和标准库打交道 (当然，我们也可以绕过标准库)，标准库通过系统调用和操作系统交互，操作系统管理底层硬件。&lt;/p>
&lt;p>&lt;strong>这就是为什么在 C 语言下同样的 open 函数既能在 Linux 下打开文件也能在 Windows 下打开文件的原因&lt;/strong>。&lt;/p>
&lt;p>说了这么多，这和 malloc 又有什么关系呢？&lt;/p>
&lt;h1 id="主角登场">主角登场&lt;/h1>
&lt;p>原来，我们分配内存时使用的 malloc 函数其实不是实现在操作系统里的，而是在标准库中实现的。&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/3ee0c566-76fb-4b04-b794-ee46baf1d822/640" alt="">&lt;/p>
&lt;p>现在我们知道了，malloc 是标准库的一部分，当我们调用 malloc 时实际上是标准库在为我们申请内存。&lt;/p>
&lt;p>这里值得注意的是，我们平时在 C 语言中使用 malloc 只是内存分配器的一种，实际上有很多内存分配器，像 tcmalloc，jemalloc 等等，它们都有各自适用的场景，对于高性能程序来说使用满足特定要求的内存分配器是至关重要的。&lt;/p>
&lt;p>那么接下来的问题就是 malloc 又是怎么工作的呢？&lt;/p>
&lt;h2 id="malloc-是如何工作的">malloc 是如何工作的&lt;/h2>
&lt;p>实际上你可以把 malloc 的工作理解为去停车场找停车位，停车场就是一片 malloc 持有的内存，可用的停车位就是可供 malloc 支配的空闲内存，停在停车场占用的车位就是已经分配出去的内存，特殊点在于停在该停车场的车宽度大小不一，malloc 需要回答这样一个问题：当有一辆车来到停车场后该停到哪里？&lt;/p>
&lt;p>通过上面的类比你应该能大体理解工作原理了，具体分析详见《&lt;a href="http://mp.weixin.qq.com/s?__biz=MzU2NTYyOTQ4OQ==&amp;amp;mid=2247485171&amp;amp;idx=1&amp;amp;sn=d93f2f5e9d61b00515c043776d2f7330&amp;amp;chksm=fcb981adcbce08bb39d120d7bfd097308371fb4b4e4369ba9502ae4e4243028b450bd0fe3110&amp;amp;scene=21#wechat_redirect">自己动手实现一个 malloc 内存分配器&lt;/a>》。&lt;/p>
&lt;p>但是，请注意，&lt;strong>上面这 **&lt;strong>篇文章并不是故事的全部&lt;/strong>，在这篇文章中有一个问题我们故意忽略了，这个问题就是&lt;/strong>如果内存分配器中的空闲内存块不够用了该怎么办呢 **？&lt;/p>
&lt;p>在上面这篇文章中我们总是假定自己实现的 malloc 总能找到一块空闲内存，但实际上并不是这样的。&lt;/p>
&lt;h2 id="内存不够该怎么办">内存不够该怎么办？&lt;/h2>
&lt;p>让我们再来看一下程序在内存中是什么样的：&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/3ee0c566-76fb-4b04-b794-ee46baf1d822/640" alt="">&lt;/p>
&lt;p>我们已经知道了，malloc 管理的是堆区，注意，在堆区和栈区之间有一片空白区域，这片空白区域的目的是什么呢？&lt;/p>
&lt;p>原来，栈区其实是可以增长的，随着调用深度的增加，相应的栈区占用的内存也会增加，关于栈区这一主题，你可以参考《&lt;a href="http://mp.weixin.qq.com/s?__biz=MzU2NTYyOTQ4OQ==&amp;amp;mid=2247484963&amp;amp;idx=1&amp;amp;sn=542d3bec57c6a9dfc17c83005fd2c030&amp;amp;chksm=fcb9817dcbce086b10cb44cad7c9777b0088fb8d9d6baf71ae36a9b03e1f8ef5bec62b79d6f7&amp;amp;scene=21#wechat_redirect">函数运行时在内存中是什么样子&lt;/a>》这篇文章。&lt;/p>
&lt;p>栈区的增长就需要占用原来的空白区域。&lt;/p>
&lt;p>相应的，堆区也可以增长：&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/3ee0c566-76fb-4b04-b794-ee46baf1d822/640" alt="">&lt;/p>
&lt;p>堆区增长后占用的内存就会变多，这就解决了内存分配器空闲内存不足的问题，那么很自然的，malloc 该怎样让堆区增长呢？&lt;/p>
&lt;p>原来 malloc 内存不足时要向操作系统申请内存，&lt;strong>操作系统才是真大佬&lt;/strong>，malloc 不过是小弟，对每个进程，操作系统 (类 Unix 系统) 都维护了一个叫做 brk 的变量，brk 发音 break，这个 brk 指向了堆区的顶部。&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/3ee0c566-76fb-4b04-b794-ee46baf1d822/640" alt="">&lt;/p>
&lt;p>将 brk 上移后堆区增大，那么我们该怎么样让堆区增大呢？&lt;/p>
&lt;p>这就涉及到我们刚提到的系统调用了。&lt;/p>
&lt;h2 id="向操作系统申请内存">向操作系统申请内存&lt;/h2>
&lt;p>操作系统专门提供了一个叫做 brk 的系统调用，还记得刚提到堆的顶部吧，这个 brk() 系统调用就是用来增加或者减小堆区的。&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/3ee0c566-76fb-4b04-b794-ee46baf1d822/640" alt="">&lt;/p>
&lt;p>实际上不只 brk 系统调用，sbr、mmap 系统调用也可以实现同样的目的，mmap 也更为灵活，但该函数并不是本文重点，就不在这里详细讨论了。&lt;/p>
&lt;p>现在我们知道了，如果 malloc 自己维护的内存空间不足将通过 brk 系统调用向操作系统申请内存。这样 malloc 就可以把这些从操作系统申请到的内存当做新的空闲内存块分配出去。&lt;/p>
&lt;h1 id="看起来已经讲完的故事">看起来已经讲完的故事&lt;/h1>
&lt;p>现在我就可以简单总结一下了，当我们申请内存时，经历这样几个步骤：&lt;/p>
&lt;ol>
&lt;li>程序调用 malloc 申请内存，注意 malloc 实现在标准库中&lt;/li>
&lt;li>malloc 开始搜索空闲内存块，如果能找到一块大小合适的就分配出去，前两个步骤都是发生在用户态&lt;/li>
&lt;li>如果 malloc 没有找到空闲内存块那么就像操作系统发出请求来增大堆区，这是通过系统调用 brk(sbrk、mmap 也可以) 实现的，注意，brk 是操作系统的一部分，因此当 brk 开始执行时，此时就进入内核态了。brk 增大进程的堆区后返回，malloc 的空闲内存块增加，此时 malloc 又一次能找到合适的空闲内存块然后分配出去。&lt;/li>
&lt;/ol>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/3ee0c566-76fb-4b04-b794-ee46baf1d822/640" alt="">&lt;/p>
&lt;p>故事就到这里了吗？&lt;/p>
&lt;h1 id="冰山之下">冰山之下&lt;/h1>
&lt;p>实际上到目前为止，我们接触到的仅仅是冰山一角。&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/3ee0c566-76fb-4b04-b794-ee46baf1d822/640" alt="">&lt;/p>
&lt;p>我们看到的冰山是这样的：我们向 malloc 申请内存，malloc 内存不够时向操作系统申请内存，之后 malloc 找到一块空闲内存返回给调用者。&lt;/p>
&lt;p>但是，你知道吗，&lt;strong>上述过程根本就没有涉及到哪怕一丁点物理内存&lt;/strong>！！！&lt;/p>
&lt;p>我们确实向 malloc 申请到内存了，malloc 不够也确实从操作系统申请到内存了，但这些内存都不是真的物理内存，&lt;strong>NOT REAL&lt;/strong>。&lt;/p>
&lt;p>实际上，进程看到的内存都是假的，是操作系统给进程的一个幻象，这个幻象就是由著名的&lt;strong>虚拟内存&lt;/strong>系统来维护的，我们经常说的这张图就是进程的虚拟内存。&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/3ee0c566-76fb-4b04-b794-ee46baf1d822/640" alt="">&lt;/p>
&lt;p>所谓虚拟内存就是假的、不是真正的物理内存，虚拟内存是给进程用的，操作系统维护了虚拟内存到物理内存的映射，当 malloc 返回后，程序员申请到的内存就是虚拟内存。&lt;/p>
&lt;p>注意，&lt;strong>此时操作系统根本就没有真正的分配物理内存，程序员从 malloc 拿到的内存目前还只是一张空头支票&lt;/strong>。&lt;/p>
&lt;p>那么这张空头支票什么时候才能兑现呢？也就是什么时候操作系统才会真正的分配物理内存呢？&lt;/p>
&lt;p>答案是当我们真正使用这段内存时，当我们真正使用这段内存时，这时会产生一个缺页错误，操作系统捕捉到该错误后开始真正的分配物理内存，操作系统处理完该错误后我们的程序才能真正的读写这块内存。&lt;/p>
&lt;p>这里只是简略的提到了虚拟内存，实际上虚拟内存是当前操作系统内部极其重要的一部分，关于虚拟内存的工作原理将在《&lt;a href="https://mp.weixin.qq.com/mp/appmsgalbum?__biz=MzU2NTYyOTQ4OQ==&amp;amp;action=getalbum&amp;amp;album_id=1433368223499796481#wechat_redirect">深入理解操作系统&lt;/a>》系列文章中详细讨论。&lt;/p>
&lt;h1 id="完整的故事">完整的故事&lt;/h1>
&lt;p>现在，这个故事就可以完整讲出来了，当我们调用 malloc 申请内存时：&lt;/p>
&lt;ol>
&lt;li>malloc 开始搜索空闲内存块，如果能找到一块大小合适的就分配出去&lt;/li>
&lt;li>如果 malloc 找不到一块合适的空闲内存，那么调用 brk 等系统调用扩大堆区从而获得更多的空闲内存&lt;/li>
&lt;li>malloc 调用 brk 后开始转入内核态，此时操作系统中的虚拟内存系统开始工作，扩大进程的堆区，注意额外扩大的这一部分内存仅仅是虚拟内存，操作系统并没有为此分配真正的物理内存&lt;/li>
&lt;li>brk 执行结束后返回到 malloc，从内核态切换到用户态，malloc 找到一块合适的空闲内存后返回&lt;/li>
&lt;li>程序员拿到新申请的内存，程序继续&lt;/li>
&lt;li>当有代码读写新申请的内存时系统内部出现缺页中断，此时再次由用户态切换到内核态，操作系统此时真正的分配物理内存，之后再次由内核态切换回用户态，程序继续。&lt;/li>
&lt;/ol>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/3ee0c566-76fb-4b04-b794-ee46baf1d822/640" alt="">&lt;/p>
&lt;p>以上就是一次内存申请的完整过程，可以看到一次内存申请过程是非常复杂的。&lt;/p>
&lt;h1 id="总结">总结&lt;/h1>
&lt;p>怎么样，程序员申请内存使用的 malloc 虽然表面看上去非常简单，简单到就一行代码，但这行代码背后是非常复杂的。&lt;/p>
&lt;p>有的同学可能会问，为什么我们要理解这背后的原理呢？理解了原理后我才能知道内存申请的复杂性，对于高性能程序来讲频繁的调用 malloc 对系统性能是有影响的，那么很自然的一个问题就是我们能否避免 malloc？&lt;/p>
&lt;p>这个问题我们将在接下来的文章中讲解。&lt;/p>
&lt;p>希望本篇对大家理解内存分配的底层原理有所帮助。&lt;/p>
&lt;p>最后的最后，如果觉得文章对你有帮助的话，请多多&lt;strong>分享&lt;/strong>、&lt;strong>转发&lt;/strong>、&lt;strong>在看&lt;/strong>。&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/3ee0c566-76fb-4b04-b794-ee46baf1d822/640" alt="">&lt;/p>
&lt;p>**长按关注 ****码农的荒岛求生 **&lt;/p>
&lt;p>&lt;strong>往期精选&lt;/strong>&lt;/p>
&lt;p>&lt;a href="http://mp.weixin.qq.com/s?__biz=MzU2NTYyOTQ4OQ==&amp;amp;mid=2247484768&amp;amp;idx=1&amp;amp;sn=049db350af9e5eea5cf3523ceb83f447&amp;amp;chksm=fcb9823ecbce0b28ca28d021e68c78138cde4a1b86ea7209c0c667d3d544d223d8b2aecbccec&amp;amp;scene=21#wechat_redirect">&lt;strong>看完这篇还不懂线程与线程池你来打我&lt;/strong>&lt;/a>&lt;/p>
&lt;p>&lt;a href="http://mp.weixin.qq.com/s?__biz=MzU2NTYyOTQ4OQ==&amp;amp;mid=2247484788&amp;amp;idx=1&amp;amp;sn=e2a084694bedf9b148bbcd5570747add&amp;amp;chksm=fcb9822acbce0b3cba63913ff6de1e37c133b878f02035bc816f7f2ec8423d908bd8560d3605&amp;amp;scene=21#wechat_redirect">&lt;strong>读取文件时，程序经历了什么？&lt;/strong>&lt;/a>&lt;/p>
&lt;p>&lt;strong>&lt;a href="http://mp.weixin.qq.com/s?__biz=MzU2NTYyOTQ4OQ==&amp;amp;mid=2247484825&amp;amp;idx=1&amp;amp;sn=0c2304dda01b698d2d461bd55185d9a2&amp;amp;chksm=fcb982c7cbce0bd1335595031ef2801cbae3b5fdbad67e9a0d953fa9337d5377aea22b069192&amp;amp;scene=21#wechat_redirect">一文彻底理解 I/O 多路复用&lt;/a>&lt;/strong>&lt;/p>
&lt;p>&lt;a href="http://mp.weixin.qq.com/s?__biz=MzU2NTYyOTQ4OQ==&amp;amp;mid=2247484851&amp;amp;idx=1&amp;amp;sn=30d68a28f926b3e8b53f4d86e5630b60&amp;amp;chksm=fcb982edcbce0bfbb213afdb2f0996f11771b21b940b535171c5d974c6b0b882a9b8bb3ef192&amp;amp;scene=21#wechat_redirect">&lt;strong>从小白到高手，你需要理解同步与异步&lt;/strong>&lt;/a>&lt;/p>
&lt;p>&lt;a href="http://mp.weixin.qq.com/s?__biz=MzU2NTYyOTQ4OQ==&amp;amp;mid=2247484916&amp;amp;idx=1&amp;amp;sn=6b19b4b3277ab0ecfffcf388a96f138a&amp;amp;chksm=fcb982aacbce0bbc5419c4329e160e3f9fce2103adaa3128e6f8138d9a8cd0e306fbe68f62f4&amp;amp;scene=21#wechat_redirect">&lt;strong>程序员应如何彻底理解回调函数&lt;/strong>&lt;/a>&lt;/p>
&lt;p>&lt;strong>&lt;a href="http://mp.weixin.qq.com/s?__biz=MzU2NTYyOTQ4OQ==&amp;amp;mid=2247484933&amp;amp;idx=1&amp;amp;sn=c4112a54f5751f38e841baf3e3cc35bd&amp;amp;chksm=fcb9815bcbce084de2823467d3ba9d3e835663a6bb69df1fc7f71677aef099584f93b0e01809&amp;amp;scene=21#wechat_redirect">高性能高并发服务器是如何实现的&lt;/a>&lt;/strong>&lt;/p>
&lt;p>&lt;strong>&lt;a href="http://mp.weixin.qq.com/s?__biz=MzU2NTYyOTQ4OQ==&amp;amp;mid=2247484963&amp;amp;idx=1&amp;amp;sn=542d3bec57c6a9dfc17c83005fd2c030&amp;amp;chksm=fcb9817dcbce086b10cb44cad7c9777b0088fb8d9d6baf71ae36a9b03e1f8ef5bec62b79d6f7&amp;amp;scene=21#wechat_redirect">函数运行时在内存中是什么样子&lt;/a>&lt;/strong>&lt;/p>
&lt;p>&lt;a href="http://mp.weixin.qq.com/s?__biz=MzU2NTYyOTQ4OQ==&amp;amp;mid=2247484986&amp;amp;idx=1&amp;amp;sn=80c673b4bb0ce7ae235db990ed6c2604&amp;amp;chksm=fcb98164cbce0872e0669f7299cd645146ad05837e4391c88554d18aea902334ee54a701945e&amp;amp;scene=21#wechat_redirect">&lt;strong>程序员应如何理解协程&lt;/strong>&lt;/a>&lt;/p>
&lt;p>*&lt;strong>*&lt;a href="http://mp.weixin.qq.com/s?__biz=MzU2NTYyOTQ4OQ==&amp;amp;mid=2247485059&amp;amp;idx=1&amp;amp;sn=c798550fb3eda73c6f66440659bdcd8d&amp;amp;chksm=fcb981ddcbce08cb74b6ea9412720ce827231c2e67e57811dbfcaac78c0e7af55e0596b72a7f&amp;amp;scene=21#wechat_redirect">线程间到底共享了哪些进程资源？&lt;/a>**&lt;/strong>&lt;/p>
&lt;p>&lt;a href="http://mp.weixin.qq.com/s?__biz=MzU2NTYyOTQ4OQ==&amp;amp;mid=2247485094&amp;amp;idx=1&amp;amp;sn=317bb31042c4432652a555ad91223541&amp;amp;chksm=fcb981f8cbce08ee2b5d28faa5627ce8a1a8cf74f62c6b7c4e8db4ae3dd0f27b2796151a9272&amp;amp;scene=21#wechat_redirect">*&lt;strong>* 线程安全代码到底是怎么编写的？**&lt;/strong>&lt;/a>&lt;/p>
&lt;p>&lt;a href="http://mp.weixin.qq.com/s?__biz=MzU2NTYyOTQ4OQ==&amp;amp;mid=2247485171&amp;amp;idx=1&amp;amp;sn=d93f2f5e9d61b00515c043776d2f7330&amp;amp;chksm=fcb981adcbce08bb39d120d7bfd097308371fb4b4e4369ba9502ae4e4243028b450bd0fe3110&amp;amp;scene=21#wechat_redirect">*&lt;strong>* 自己动手实现一个 malloc 内存分配器 **&lt;/strong>&lt;/a>&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/3ee0c566-76fb-4b04-b794-ee46baf1d822/640" alt="">&lt;/p>
&lt;p>&lt;strong>码农的荒岛求生&lt;/strong>
&lt;a href="https://mp.weixin.qq.com/s/DN-ckM1YrPMeicN7P9FvXg">https://mp.weixin.qq.com/s/DN-ckM1YrPMeicN7P9FvXg&lt;/a>&lt;/p></description></item></channel></rss>