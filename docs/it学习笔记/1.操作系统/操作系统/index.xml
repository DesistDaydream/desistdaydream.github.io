<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>断念梦 – 操作系统</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/</link><description>Recent content in 操作系统 on 断念梦</description><generator>Hugo -- gohugo.io</generator><atom:link href="https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/index.xml" rel="self" type="application/rss+xml"/><item><title>Docs: Alpine</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E7%B1%BB-unix-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/alpine/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E7%B1%BB-unix-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/alpine/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://www.alpinelinux.org/">官网&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://github.com/alpinelinux/docker-alpine">GitHub 项目,docker-alpine&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://hub.docker.com/_/alpine">DockerHub&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://mp.weixin.qq.com/s/Qt8ASPefVG-9bZe6FO_YQw">https://mp.weixin.qq.com/s/Qt8ASPefVG-9bZe6FO_YQw&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;h1 id="apk--包管理器">APK # 包管理器&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://docs.alpinelinux.org/user-handbook/0.1a/Working/apk.html">官方文档&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>&lt;strong>Alpine Package Keeper(Alpine 包管理圆，简称 APK)&lt;/strong> 是 Alpine 发行版的包管理工具。&lt;/p>
&lt;h2 id="关联文件">关联文件&lt;/h2>
&lt;p>&lt;strong>/etc/apk/repositories&lt;/strong> # 包仓库的配置文件&lt;/p>
&lt;ul>
&lt;li>阿里仓库
&lt;ul>
&lt;li>sed -i &amp;rsquo;s/dl-cdn.alpinelinux.org/mirrors.aliyun.com/g&amp;rsquo; /etc/apk/repositories&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>中科大仓库
&lt;ul>
&lt;li>sed -i &amp;rsquo;s/dl-cdn.alpinelinux.org/mirrors.ustc.edu.cn/g&amp;rsquo; /etc/apk/repositories&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>/var/cache/apk/*&lt;/strong> # APK 程序运行时产生的缓存文件保存路径&lt;/p>
&lt;h2 id="apk-命令行工具">apk 命令行工具&lt;/h2>
&lt;h3 id="syntax语法">Syntax(语法)&lt;/h3>
&lt;p>&lt;strong>apk [Global OPTIONS] COMMAND [COMMAND OPTIONS]&lt;/strong>
Global OPTIONS&lt;/p>
&lt;ul>
&lt;li>--no-cache # 不在 /var/cache/apk/ 目录下生成缓存，并且也不使用该目录下的缓存。&lt;/li>
&lt;/ul>
&lt;p>COMMAND&lt;/p>
&lt;ul>
&lt;li>安装和移除包命令
&lt;ul>
&lt;li>&lt;strong>add&lt;/strong> # 为正在运行的系统添加新包或升级包&lt;/li>
&lt;li>&lt;strong>del&lt;/strong> # 从正在运行的系统中删除包&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>系统维护命令(管理包的元数据)
&lt;ul>
&lt;li>cache Maintenance operations for locally cached package repository&lt;/li>
&lt;li>&lt;strong>fix&lt;/strong> # 尝试修复或升级已安装的包&lt;/li>
&lt;li>update Update the index of available packages&lt;/li>
&lt;li>upgrade Upgrade the currently installed packages&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>查询包的信息
&lt;ul>
&lt;li>dot Create a graphviz graph description for a given package&lt;/li>
&lt;li>info # Prints information about installed or available packages&lt;/li>
&lt;li>list # List packages by PATTERN and other criteria&lt;/li>
&lt;li>policy Display the repository that updates a given package, plus repositories that also offer the package&lt;/li>
&lt;li>search Search for packages or descriptions with wildcard patterns&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>仓库管理命令(管理包源)
&lt;ul>
&lt;li>**fetch **# 下载包，但是不安装它。&lt;/li>
&lt;li>index create a repository index from a list of packages&lt;/li>
&lt;li>verify Verify a package signature&lt;/li>
&lt;li>stats Display statistics, including number of packages installed and available, number of directories and files, etc.&lt;/li>
&lt;li>manifest Display checksums for files contained in a given package&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>del OPTIONS&lt;/p>
&lt;ul>
&lt;li>&lt;strong>-r, &amp;ndash;rdepends&lt;/strong> # 递归删除所有顶级反向依赖项&lt;/li>
&lt;/ul>
&lt;h1 id="alpine-容器镜像">Alpine 容器镜像&lt;/h1>
&lt;p>alpine 是基于 Alpine Linux 发型版的最小容器映像，具有完整的软件包索引，大小仅为 5 MB！Alpine 采用了 musl libc 和 busybox 以减小系统的体积和运行时的资源消耗。同时，Alpine 具有自己的&lt;strong>包管理器 APK&lt;/strong>。可以在 &lt;a href="https://pkgs.alpinelinux.org/packages">https://pkgs.alpinelinux.org/packages&lt;/a> 查询到所有包的信息，并且可以直接通过 &lt;code>apk&lt;/code> 命令查询和安装各种软件。&lt;/p>
&lt;h2 id="添加时区">添加时区&lt;/h2>
&lt;p>安装 tzdata 包，后，配置 TZ 环境变量或者创建 /etc/localtime 软链接文件即可。示例如下：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>FROM alpine
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># 设置时区为上海&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>RUN sed -i &lt;span style="color:#e6db74">&amp;#39;s/dl-cdn.alpinelinux.org/mirrors.aliyun.com/g&amp;#39;&lt;/span> /etc/apk/repositories &lt;span style="color:#f92672">&amp;amp;&amp;amp;&lt;/span> &lt;span style="color:#ae81ff">\
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">&lt;/span> apk update &lt;span style="color:#f92672">&amp;amp;&amp;amp;&lt;/span> &lt;span style="color:#ae81ff">\
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">&lt;/span> apk add --no-cache tzdata &lt;span style="color:#f92672">&amp;amp;&amp;amp;&lt;/span> &lt;span style="color:#ae81ff">\
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">&lt;/span> ln -sf /usr/share/zoneinfo/Asia/Shanghai /etc/localtime
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="设置系统语言防止中文乱码">设置系统语言，防止中文乱码&lt;/h2>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>FROM alpine:3.11.5
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>ENV LANG&lt;span style="color:#f92672">=&lt;/span>en_US.UTF-8 &lt;span style="color:#ae81ff">\
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">&lt;/span> LANGUAGE&lt;span style="color:#f92672">=&lt;/span>en_US.UTF-8
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="常见问题">常见问题&lt;/h2>
&lt;h3 id="golang-在-alpine-镜像下-hosts-定义的域名不生效-及解决-x509certificates">golang 在 alpine 镜像下 hosts 定义的域名不生效-及解决 x509certificates&lt;/h3>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://github.com/golang/go/issues/22846">Go Issue #22846&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://blog.csdn.net/huangruifeng/article/details/96594065">CSDN&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://cloud.tencent.com/developer/article/1756065">腾讯云文章&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>golang 在 alpine 镜像下 hosts 定义的域名不生效&lt;/p>
&lt;p>解决方案&lt;/p>
&lt;pre>&lt;code>echo &amp;quot;hosts: files dns&amp;quot; &amp;gt; /etc/nsswitch.conf
&lt;/code>&lt;/pre>
&lt;blockquote>
&lt;p>参考：&lt;a href="https://github.com/golang/go/issues/22846">https://github.com/golang/go/issues/22846&lt;/a>&lt;/p>
&lt;/blockquote>
&lt;p>以下为调整后的 Dockerfile&lt;/p>
&lt;pre>&lt;code>FROM alpine
RUN apk update #解决 apk下载失败问题 ERROR: unsatisfiable constraints
RUN apk add --no-cache ca-certificates #在go程序中无法访问https链接，解决x509certificates
RUN echo &amp;quot;hosts: files dns&amp;quot; &amp;gt; /etc/nsswitch.conf #go程序在alpine下不解析hosts文件
&lt;/code>&lt;/pre></description></item><item><title>Docs: Android 操作系统</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E7%B1%BB-unix-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/android-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E7%B1%BB-unix-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/android-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;h2 id="参考">参考：&lt;/h2>
&lt;/blockquote>
&lt;p>旧版本微信、QQ 接收文件存储路径为存储根目录的 Tencent 目录下，而新版微信接收文件路径切换到了 &lt;code>Android/data/com.tencent.mm/MicroMsg/Download&lt;/code> 目录下
QQ 接收的文件也切换到了 &lt;code>Android/data/com.tencent.mobileqq/Tencent/QQfile_recv&lt;/code> 目录下&lt;/p>
&lt;h1 id="目录结构">目录结构&lt;/h1>
&lt;p>安卓的目录结构与 [Linux 内核的目录结构](✏IT 学习笔记/📄1.操作系统/2.Kernel(内核)/6.File%20System%20 管理/FHS(文件系统层次标准).md System 管理/FHS(文件系统层次标准).md)类似，但是有一些约定俗成的用于保存各类数据的目录&lt;/p>
&lt;h2 id="data--">/data # ？&lt;/h2>
&lt;ul>
&lt;li>/data/app/ # ?&lt;/li>
&lt;li>/data/data/ # ?&lt;/li>
&lt;/ul>
&lt;h2 id="sdcard--与-storageemulated0-目录一样这俩谁是谁的软链接">/sdcard # 与 /storage/emulated/0 目录一样，这俩谁是谁的软链接？&lt;/h2>
&lt;h2 id="storageemulated0">/storage/emulated/0/&lt;/h2>
&lt;ul>
&lt;li>.&lt;strong>/Android/data/${应用的包名}/&lt;/strong> # 应用的缓存和临时目录？&lt;/li>
&lt;/ul></description></item><item><title>Docs: Debian 与 Ubuntu</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E7%B1%BB-unix-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/debian-%E4%B8%8E-ubuntu/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E7%B1%BB-unix-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/debian-%E4%B8%8E-ubuntu/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://manpages.debian.org/">Debian 官方 Manual(手册)&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>groupadd wheel
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>usermod -G wheel lichenhao
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>tee /etc/sudoers.d/lichenhao &amp;gt; /dev/null &lt;span style="color:#e6db74">&amp;lt;&amp;lt;EOF
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">%wheel ALL=(ALL) NOPASSWD: ALL
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">EOF&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>~/.bashrc&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">if&lt;/span> &lt;span style="color:#f92672">[&lt;/span> &lt;span style="color:#e6db74">&amp;#34;&lt;/span>$color_prompt&lt;span style="color:#e6db74">&amp;#34;&lt;/span> &lt;span style="color:#f92672">=&lt;/span> yes &lt;span style="color:#f92672">]&lt;/span>; &lt;span style="color:#66d9ef">then&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e"># PS1=&amp;#39;${debian_chroot:+($debian_chroot)}\[\033[01;32m\]\u@\h\[\033[00m\]:\[\033[01;34m\]\w\[\033[00m\]\$ &amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> PS1&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#39;${debian_chroot:+($debian_chroot)}[\[\e[34;1m\]\u@\[\e[0m\]\[\e[32;1m\]\H\[\e[0m\] \[\e[31;1m\]\w\[\e[0m\]]\\$ &amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">else&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e"># PS1=&amp;#39;${debian_chroot:+($debian_chroot)}\u@\h:\w\$ &amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> PS1&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#39;${debian_chroot:+($debian_chroot)}[\[\e[34;1m\]\u@\[\e[0m\]\[\e[32;1m\]\H\[\e[0m\] \[\e[31;1m\]\w\[\e[0m\]]\\$ &amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">fi&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div></description></item><item><title>Docs: Linux Torvalds 采访</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E7%B1%BB-unix-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/linux-torvalds-%E9%87%87%E8%AE%BF/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E7%B1%BB-unix-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/linux-torvalds-%E9%87%87%E8%AE%BF/</guid><description>
&lt;p>&lt;a href="https://mp.weixin.qq.com/s/mVo3S_F0RoxCToawrTCnlA">https://mp.weixin.qq.com/s/mVo3S_F0RoxCToawrTCnlA&lt;/a>
作者丨 Jeremy Andrews译者丨屠灵策划丨蔡芳芳Linux 诞生于 1991 年，距今已经 30 年了。虽然它一开始只是 Linus 的一个个人项目，而非出于要开发一个新操作系统的伟大梦想，但如今的 Linux 早已无处不在。
30 年前，当 Linus Torvalds 第一次发布 Linux 内核时，他还是赫尔辛基大学的一名 21 岁的学生。他宣布说：“我正在开发一个（免费的）操作系统（这只是个爱好，不会做得很大，也不会很专业……）”。30 年后，500 强超级计算机和 70% 以上的智能手机都在运行 Linux。很显然，Linux 不仅大，而且很专业。
30 年来，Linus Torvalds 一直在领导着 Linux 内核的开发，启发了无数开发者和开源项目。2005 年，Linus 开发了 Git，用来管理内核开发过程。Git 现在已经成为最流行的版本控制系统，受到无数开源和私有项目的信任。
正值 Linux 诞生 30 周年之际，Linus Torvalds 通过电子邮件回复了 Tag 1 咨询公司的创始合伙人 / 首席执行官 Jeremy Andrews 的访谈问题（《An Interview With Linus Torvalds: Linux and Git - Part 1》），回顾并总结了过去这些年他在领导大型开源项目过程中得到的真知灼见。本文着重介绍 Linux 内核开发和 Git。InfoQ 对访谈内容进行了翻译，以飨读者。
Linux 内核开发
&lt;strong>Jeremy Andrews：Linux 无处不在，它是整个开源世界的灵感源泉。当然，事情并不是从一开始就这样的。1991 年，你在 comp.os.minix Usenet 新闻组中发布了一个 Linux 内核。十年后，你写了一本书，叫作“Just for Fun: The Story of an Accidental Revolutionary”（中译名：《只是为了好玩：Linux 之父林纳斯自传》），对那段历史进行了深度回顾。今年 8 月，Linux 将迎来它的 30 周年纪念日！在这个过程中，你是在什么时候开始意识到 Linux 并不仅仅是一个“爱好”的？&lt;/strong>
**Linus Torvalds：**这听起来可能有点荒谬，实际上我很早就开始意识到了。在 1991 年末（以及 1992 年初），Linux 已经比我预想的要大得多。
那时候可能只有几百个用户（确切地说不是“用户”，因为人们还要不断地对它进行修修补补），从没想过 Linux 后来能够发展壮大。在我看来，最大的转折点是当我意识到其他人正在使用它，并对它感兴趣，它开始有了自己的生命。人们开始发送补丁，这个系统能做的事情比我最初预想的要多得多。
1992 年 4 月的某个时候，X11 被移植到 Linux 上（其实我也记不太清具体时间了，毕竟那是很久以前的事了），这是一个重大进步，Linux 系统突然间有了 GUI 和一系列全新的功能。
我一开始并没有什么大计划。这只是一个个人项目，并不是出于要开发一个新操作系统的伟大梦想。我当时只是想了解我的新 PC 硬件的来龙去脉。
所以，在发布第一个版本时，实际上更多的是想“看看自己都做了些什么”。当然，我希望其他人会觉得它有趣，但它并不是一个真正可用的操作系统。它更多的是一种概念验证，而且只是一个我在当时做了几个月的个人项目。
从“个人项目”到其他人开始使用它、给我反馈（和 bug 报告）和发送补丁，对我来说是一个巨大的转变。
举个最基本的例子：最初的版权许可是“你可以以源代码的形式发布它，但不能用它赚钱”。
对于当时的我来说，商业版 Unix 太贵了（作为穷学生，我已经为了买新 PC 花光了所有钱），所以我希望这个操作系统的源代码是公开可用的（这样人们就可以提供补丁），我希望将它开放给像我这样负担不起昂贵电脑和操作系统的人。
1991 年末（或是 1992 年初），我把许可改为 GPLv2，因为有人想把它以软盘的形式分发给本地 Unix 用户组，但又想收回软盘的成本，并补偿他们拷贝软盘所花费的时间。我觉得这很合理，因为“免费”与否并不是最重要的，最重要的是要“公开源码”。
最终的结果是：人们不仅在 Unix 用户组中发布它，在几个月之内还出现了 SLS 和 Slackware 的软盘发行版。
与最初的那些根本性的变化相比，后来的一切都是“增量式”的。当然，有些增量式的变化也是大跨步（IBM 的加入、Oracle 数据库的移植、Red Hat 的首次公开募股，Android 在手机上的应用，等等），但在我看来，它们仍然不如最初的“我不认识的人都在使用 Linux”那样具有革命性。
&lt;strong>Jeremy Andrews：你是否曾经后悔修改了许可协议？或者说，其他人或公司用你开发的系统赚了很多钱，你因此感到后悔吗？&lt;/strong>
**Linus Torvalds：**我从来没有后悔过。
首先，我过得还不错。我不是特别富有，但我是一个薪水很高的软件工程师，可以按照自己的节奏做我喜欢做的事情。
关键是我百分之百认为这个许可是 Linux（以及 Git）取得成功的重要原因。我认为，当所有人都认为他们有平等的权利，没有人在这方面有特权的时候，他们才会变得更快乐。
有很多项目采用了“双重许可”，一方面，原作者保留了商业许可（“只要你支付了许可费用，就可以使用它”），另一方面，项目也可以在 GPL 许可下开源。
我认为要在这种情况下建立好的社区是非常困难的，因为开源那一方知道自己是“二等公民”。另外，为了让享有特权的那一方一直享有特殊的权利，需要做很多许可文书工作，这给项目带来了额外的阻力。
另一方面，我见过很多基于 BSD（或 MIT 等类似的许可）许可的开源项目，当它们变得足够强大，大到具备商业价值时，它们就开始分裂，相关的公司不可避免地会将自己的那部分变成专有的。
我认为 GPLv2 能够在“每个人都处于相同的规则之下”和“要求人们回馈社区”之间取得完美的平衡。每个人都知道，所有参与者都受到相同的规则的约束，所以这是非常公平的。
当然，你的投入总会得到回报。如果你只是想轻度参与项目，或者只是想作为一名用户，那也是可以的。如果你真的只是这样，就也无法控制这个项目。如果你真的只需要一个基本的操作系统，而 Linux 已经具备你想要的所有功能，那也完全没有问题。但如果你有特殊的需求，想要为这个项目做一点事情，那么唯一的方法就是参与其中。
这让每个人都秉持诚实的态度，包括我在内。任何人都可以 fork 这个项目，用他们自己的方式，然后说“再见了，Linus，我要维护自己的 Linux 版本”。我之所以“特别”，仅仅是因为人们相信我能把工作做好。
“任何人都可以维护自己的 Linux 版本”，这让一些人对 GPLv2 产生了怀疑，但我认为这是一种优势，而不是劣势。我认为，这实际上是避免 Linux 出现分裂的原因：每个人都可以创建自己的项目分支。事实上，这也是“Git”的核心设计原则之一——代码库的每一个克隆都是一个分支，人们（和公司）再 fork 出自己的版本，完成开发工作。
所以，分支不是问题，只要你能把好的部分合并回来。这就是 GPLv2 发挥作用的地方。能够拉取分支，并按照自己的方式修改代码，拥有这些权利很重要，但另一方面也同样重要——当一个分支被证明取得了成功，有权利把它合并回去。
另一个问题是，除了要有支持这种工作流的工具，也要有可以支持它的心态。合并分支的一大障碍不仅是许可问题，还有“嫌隙”问题。如果分支是源于对立，那么要合并两个分支就非常困难——不是因为许可或技术方面的原因，而是因为分支之间太过对立。我认为 Linux 避免了这种情况的发生，主要是因为我们一直认为分支是一件很自然的事情。而且，当一些开发工作被证明取得了成功，尝试将其合并回来也是很自然的。
虽然这个答案有点偏离正题，但我认为它很重要——我不后悔修改了许可，因为我真的认为 GPLv2 是 Linux 取得成功的一个重要原因。
金钱不是一种很好的激励方式，它无法让人们团结在一起。我认为，参与一个共同的项目，并感觉到自己可以成为这个项目的合作伙伴，这样才能激励人们。
&lt;strong>Jeremy Andrews：现在，人们基于 GPLv2 发布源代码通常是因为 Linux。你当时是怎么找到这个许可的？你在调研其他许可方面又投入了多少时间和精力呢？&lt;/strong>
**Linus Torvalds：**那个时候，有关 BSD 和 GPL 的争论非常激烈。我在阅读各种新闻组（比如 comp.arch、comp.os.minix 等）时看到了一些有关许可的讨论。
其中两个最主要的原因可能是 gcc 和 Lars Wirzenius。gcc 对 Linux 的发展起到了很大作用，因为我肯定需要一个 C 语言编译器。Lars Wirzenius 是我在念大学时另一个说瑞典语（瑞典语在芬兰是小语种）的计算机系学生。
Lasu 比我更喜欢讨论与许可相关的事情。
在我看来，选择 GPLv2 并不算是什么重大的政治问题，主要是因为我最初在选择许可时太过仓促，后来需要做出修改。况且，我很感恩有 gcc，并且 GPLv2 更符合我对“你必须把源代码合并回来”这种想法的期望。
因此，与其另起炉灶新建一个许可，不如选择一个人们已经知道并且有一些律师参与其中的许可。
&lt;strong>Jeremy Andrews：通常情况下，你的一天是怎么过的？其中有多少时间花在写代码上，多少花在评审代码上，多少花在电子邮件上？你如何平衡个人生活和 Linux 内核开发工作？&lt;/strong>
Linus Torvalds：我现在写的代码很少，而且已经很久没写了。再要写代码，通常是因为人们对某些特定的问题存在争议。我修改代码，并将其作为补丁发布出去，作为对解决方案的解释说明。
换句话说，我写的大部分代码更多的是作为解决方案的示例，而补丁是一种非常具体的例子。人们很容易陷入理论讨论的陷阱，而我发现描述解决方案最好的方式是写代码片段，不一定要完整的程序，只要让解决方案具体化一些即可。
我的工作时间都花在电子邮件上了。主要是沟通，而不是写代码。事实上，我认为这种与记者和技术博主之间的交流就是我工作的一部分——它可能比技术讨论优先级低一些，但我也花了相当多的时间在这类事情上。
当然，我也会花一些时间在代码评审上。但老实说，当我收到一个 PR 时，有问题的代码通常已经被其他人评审过了。所以，虽然我仍然会看一下补丁，但实际上会更多地去关注注解，以及补丁的演化过程。但对于那些与我共事很久的人，我不会这么做：他们是自己子系统的维护者，我不需要对他们的工作指手画脚。
所以，很多时候，我的主要工作就是“待在那里”，执行管理和发布任务。换句话说，我的工作通常更多地是关于维护过程，而不是底层代码。
&lt;strong>Jeremy Andrews：你的工作环境是怎样的？比如，你是喜欢黑暗、不会受人打扰的房间，还是喜欢能看到风景的房间？你喜欢在安静的环境下工作，还是喜欢一边听音乐一边工作？你通常使用哪种硬件？你是在终端上使用 vi 来评审代码，还是使用某种奇特的 IDE？你是否有偏爱的 Linux 发行版作为开发环境？&lt;/strong>
**Linus Torvalds：**我的房间并不“暗”，但我确实把桌子旁边窗户上的百叶窗关上了，因为我不想要强烈的阳光。所以，我的房间没有什么风景视野，只有一张（凌乱的）桌子，配了两个 4k 显示器，桌子下面有一台强劲的电脑主机。还有几台笔记本电脑供我测试和在路上用。
我喜欢安静地工作。我很讨厌机械硬盘的滴答声，所以我把它们扔进了垃圾桶，现在只使用 SSD。这样已经 10 多年了。嘈杂的 CPU 风扇声也是不可接受的。
代码评审都是在传统的终端上完成的，不过我没有使用 vi。我使用的是“micro-emacs”这个令人讨厌的东西。它与 GNU emacs 完全没有关系，只是有些键绑定与它相似。我在赫尔辛基大学时就习惯用它了，到现在还没改掉这个习惯。几年前，我给它增加了（非常有限的）utf-8 支持，但它确实很老旧了，所有的迹象都表明它是在 80 年代开发的，我使用的版本是一个自 90 年代中期以来就没有更新过的分支。
赫尔辛基大学选择了这个工具，因为它可以在 DOS、VAX/VMS 和 Unix 上运行，这也是为什么我也会用它。到现在，我的手指已经对它形成肌肉记忆了。我真的需要换个有人维护并支持 utf-8 的工具，只是我增强的那部分功能用起来还好，所以一直没有强迫我的手指去接受新的工具。
我的工作桌面相当简单：几个文本终端，一个打开了电子邮箱的浏览器（还打开了其他几个标签，主要是新闻和科技网站）。我喜欢大的桌面空间，因为我习惯使用大终端窗口（100x40 是我的默认初始大小），并且并排打开好几个。我使用了两个 4k 显示器。
我在所有的机器上都安装了 Fedora 发行版，并不是因为我偏爱它，而是因为我习惯了。我并不太关心使用哪个发行版——对于我来说，选择发行版只是在机器上安装 Linux 和开发工具的一种方式。
&lt;strong>Jeremy Andrews：Linux 内核邮件组（&lt;a href="https://lore.kernel.org/lkml/">https://lore.kernel.org/lkml/&lt;/a>）是人们公开交流内核开发的地方，流量非常高。你是怎么处理这么多电子邮件的？你尝试过邮件组之外的其他协作和沟通解决方案吗？或者说，这种简单的邮件组对你的工作来说足够好吗？&lt;/strong>
&lt;strong>Linus Torvalds&lt;/strong>：我没有直接阅读内核邮件组里的邮件，而且好几年都没有。邮件太多了。
内核邮件组里的邮件会被抄送到所有的讨论当中。当新人加入讨论时，他们可以通过查看内核邮件组来了解相关的历史和背景。
过去我会订阅邮件组，让所有没有抄送给我的电子邮件自动归档，默认不看它们。当一些问题需要我介入时，我可以找到所有相关的讨论，因为它们都在我的电子邮件里，只是在需要时才会出现在我的收件箱里。
现在，我使用的是 lore.kernel.org 提供的功能，因为它很好用，而且我们还基于它开发了一些工具。这样就不需要让邮件自动归档了，我们换了一种讨论方式，但基本的工作流程是一样的。
但很显然，我仍然会收到很多邮件——但从很多方面来看，这些年来情况变得越来越好，而不是越来越糟。其中很大一部分原因是 Git 和内核发布流程的改进：我们过去在代码流程和工具方面存在很多问题。在本世纪初是最为糟糕的，当时我们仍然在处理巨大的补丁炸弹，我们的开发流程存在严重的可伸缩性问题。
邮件组模式确实运作得很好，但并不是说人们就不使用除电子邮件之外的其他沟通方式了：有些人喜欢各种实时聊天工具（比如传统的 IRC）。虽然我不是很喜欢这样，但很显然有些人喜欢用它们来进行头脑风暴。但这种“邮件组存档”模式运作得非常好，并且能够无缝地与“开发者之间以邮件的形式发送补丁”和“以邮件的形式发送问题报告”相结合。
所以电子邮件仍然是主要的沟通渠道，并且因为邮件中可以包含补丁，我们可以更容易地讨论技术问题。而且邮件可以跨越时区，当参与者分布在不同地区时，这一点非常重要。
&lt;strong>Jeremy Andrews：我密切关注内核开发大约有 10 年了，并在 KernelTrap 上写与内核有关的博文，大概是在 3.0 内核发布时停止更新博客。3.0 内核的发布与 2.6.x 内核的发布相隔了 8 年。请总结一下自 3.0 版本以来内核开发中发生的一些有趣的事情。&lt;/strong>
&lt;strong>Linus Torvalds&lt;/strong>：那是很久以前的事了，我不知道该从哪里开始总结。从 3.0 版本到现在已经 10 年了，在这 10 年中发生了很多技术上的变化。ARM 已经发展成熟，ARM64 已经成为我们的主要架构之一，并出现了大量新的驱动程序和核心功能。
如果说过去 10 年有什么有趣的事情，那一定是我们努力保持开发模式的稳定，以及那些没有发生改变的东西。
在过去的几十年里，我们经历了多种不同的版本号方案和不同的开发模式，3.0 版本最终确定了后来一直使用的模式。它让“基于时间发布，版本号只是数字，与特性无关”这一说法落地了。
在 2.6.x 版本中，我们就有了基于时间的发布模式，所以它并不是什么新东西，但 3.0 版本确实是让这种模式板上钉钉的至关重要的一步。
我们以前使用随机编号方案（主要是在 1.0 版本之前），然后用“奇数表示开发版内核，偶数表示稳定的生产就绪版内核”，然后在 2.6.x 版本中，我们开始进入基于时间的发布模式。但人们仍然对“什么时候需要增加主版本号”存在疑问。3.0 版本正式发布后，宣告了主版本号没有任何意义，我们尽量简化数字，不要让它们变得太大。
因此，在过去的 10 年里，我们做了巨大的改变（有了 Git，就可以很容易地得到一些数字统计数据：超过 1.7 万人提交了大约 75 万次代码），但开发模式仍然相当稳定。
但并非一直都是这样的，内核开发的前 20 年经历了相当痛苦的开发模式变更，只是在过去 10 年中，发布可预测性才得到大幅提升。
&lt;strong>Jeremy Andrews：目前，最新的版本是 5.12-rc5。现在的发布流程标准是怎样的？例如，-rc1 和 -rc2 有什么不同？你会在什么情况下决定正式发布其中一个给定的版本？如果在正式发布之后出现了大量的回归会怎样？这种情况发生的频率是怎样的？这些年来，这个过程是如何演变的？&lt;/strong>
&lt;strong>Linus Torvalds&lt;/strong>：我之前提到过，这个过程本身是很标准的，并且在过去十年里一直如此。在此之前，它经历了几次演变，但实际上从 3.0 开始它就像时钟一样走得很稳定。
到现在为止，我们的发布节奏是这样的：先是两周的合并时间窗口，然后是大约 6 到 8 周的候选版本，然后是最终版本。这样子差不多 15 年了。
规则一直都是一样的，尽管它们并不总是被完全严格执行：合并时间窗口是针对那些被认为已经“经过测试和准备就绪”的新代码，然后在接下来的大约两个月里进行修复，以确保所有的问题都得到解决。有时候，那些所谓的“就绪”代码会在发布之前会被禁用或完全推翻。
这个过程会重复，所以我们大约每 10 周发布一次。
达到可以发布的标准是我对候选版本有足够的信心，而这是以各种问题报告为基础的。如果某些方面在 rc 后期仍然会出问题，我就极力推翻这些内容，并建议将其放在后续的版本中。但总体而言，很少会出现这种情况。
这样就完全没有问题了吗？不是的。一旦内核发布了，就会有新用户，他们会发现一些在 rc 版本中没有被发现的问题。这几乎是不可避免的。这也是为什么我们需要“稳定内核”树。在发布之后，我们可以继续修复代码。一些稳定内核比其他版本内核维护的时间更长，被称为 LTS（“Long Term Support”）版本。
所有这些在过去十年里都没有什么变化，尽管后来有了更多的自动化流程。一般来说，内核测试自动化是很困难的——因为很多内核是驱动程序，十分依赖硬件的可用性。不过，我们有几个测试场同时进行引导和性能测试，以及各种随机负载测试。这些在这几年有了很大的改善。
&lt;strong>Jeremy Andrews：去年 11 月，有人说你对苹果公司在部分新款电脑中使用的 ARM64 芯片十分感兴趣。Linux 会支持它们吗？我看到一些代码被合并到 for-next。即将到来的 5.13 内核有可能在苹果 MacBook 上启动吗？你有可能是它的早期采用者吗？ARM64 有什么重大的意义？&lt;/strong>
&lt;strong>Linus Torvalds&lt;/strong>：我偶尔会跟进一下，但现在说这些还为时过早。正如你所说的，早期支持可能会被合并到 5.13 中，但这只是一个开始，并不能说明 Linux 和苹果电脑将来会怎样。
主要问题不是 arm64 架构，而是与之相关的所有硬件驱动程序（特别是 SSD 和 GPU）。到目前为止，一些底层的东西得到了支持，但除了可以启用硬件之外，没有任何有用的结果。要想达到可以被人们使用的程度，还需要一些时间。
不仅仅是苹果的硬件得到了改进——arm64 架构总体上也已经成长了很多，内核在服务器领域也更具竞争力了。不久前，arm64 在服务器领域的竞争力还很弱，但亚马逊的 Graviton2 和安培的 Altra 处理器——都是基于改进后的 ARM Neoverse IP——比几年前的产品要好很多。
我已经等了十多年都没能等到一个可用的 ARM 机器，可能还要继续等下去，但情况明显比以前好了一些。
事实上，我很早之前就想要一台 ARM 机器。当我还是个少年，我真正想要的是一台 Acorn Archimedes，但可用性和价格让我最终选择了 Sinclair QL（M68008 处理器），然后几年后换成了 i386。
所以，这个想法已经酝酿了几十年。但到现在它们还没有被广泛使用，而且对于我来说，它们在价格和性能方面都不具竞争力。希望在不久的将来，这个想法能够变成现实。
&lt;strong>Jeremy Andrews：内核中有什么东西需要进行完全的重写才能达到最优的吗？或者说，内核已经有 30 年的历史了，知识、编程语言和硬件在这 30 年里发生了很大的变化：如果现在让你从头开始重写，你会做出哪些改变？&lt;/strong>
&lt;strong>Linus Torvalds&lt;/strong>：如果有必要的话我们会这么做的。我们真的很擅长重写，那些本来会造成灾难的东西很久以前就被我们重写了。
我们有很多“兼容”层，不过它们一般不会造成太大问题。如果从头开始重写，这些兼容层是否要去掉，我们还不清楚——它们存在的目的是为了与旧二进制文件向后兼容（通常是与旧架构向后兼容，例如在 x86-64 上运行 32 位的 x86 应用程序）。因为我认为向后兼容是非常重要的，所以即使重写，我也希望保留这些兼容层。
所以很明显，有很多东西并不是最优的，毕竟任何东西都有改进的空间。但就你提的这个问题，我不得不说，我不鄙视任何东西。有一些遗留驱动程序，可能没有人关心，也没有人去清理，会做一些丑陋的事情，但这主要是因为“没有人关心”。这些在过去不是问题，而一旦成为问题，我们就会积极把这些没人关心的东西移除掉。多年来，我们已经移除了很多驱动程序，当维护不再有任何意义时，我们会放弃整个架构支持。
“重写”的主要原因是：整个架构不再有意义，但仍然存在一些应用场景。最有可能的情况是，一些小型嵌入式系统并不需要 Linux 提供的所有东西，它们的硬件很小，需要的是更简单、更少的系统功能。
Linux 已经有了长足的发展。现在，即使是小硬件（比如手机等）也比当初开发 Linux 所使用的机器强大得多。
&lt;strong>Jeremy Andrews：如果用 Rust 来重写一部分系统会怎样？在这方面还有改进的余地吗？在内核开发方面，你觉得是否有可能用另一种语言（比如 Rust）来取代 C 语言？&lt;/strong>
**Linus Torvalds：**我不认为我们会用 Rust 取代 C 语言来开发内核，但可能会用来开发一些驱动程序，也许是整个驱动子系统，也许是文件系统。所以不是“取代 C 语言”，而是“在一些有意义的地方扩展我们的 C 代码”。
当然，驱动程序几乎占了内核的一半代码，有非常大的重写空间，但我不认为所有人都会很期待使用 Rust 全盘重写现有的驱动程序。可能“有些人会用 Rust 开发新驱动程序，或者适当地重写一部分旧驱动程序”。
现在更多的是“人们在尝试和体验”Rust，仅此而已。Rust 优势的背后肯定存在复杂性，所以我会采取观望的态度，看看这些优势是否真的奏效。
&lt;strong>Jeremy Andrews：内核中是否有你个人感到最自豪的部分？&lt;/strong>
&lt;strong>Linus Torvalds&lt;/strong>：我最想说的是 VFS 层（虚拟文件系统，特别是路径名查找）和 VM。前者是因为 Linux 在做一些基础任务（在操作系统中查找文件名确实是一个核心的操作）时比其他系统都要好得多，后者主要是因为我们支持 20 多种架构，但仍然在使用一个基本统一的 VM 层，我认为这一点很了不起。
但与此同时，这很大程度上取决于“你最关注内核的哪一部分”。内核很大，不同的开发者（和不同的用户）会关注不同的方面。有些人认为调度是内核中最令人感到兴奋的部分，有些人则关注设备驱动程序的细节（我们有很多这样的驱动程序）。我个人在 VM 和 VFS 这两个方面参与得更多，所以自然会提到它们。
&lt;strong>Jeremy Andrews：我看了这个关于路径名查找的描述（&lt;a href="https://www.kernel.org/doc/html/latest/filesystems/path-lookup.html">https://www.kernel.org/doc/html/latest/filesystems/path-lookup.html&lt;/a>），它比我预想的要复杂。是什么让 Linux 在这方面比其他操作系统做得更好？你说的“更好”是什么意思？&lt;/strong>
&lt;strong>Linus Torvalds&lt;/strong>：路径名查找是一个非常常见和基础的任务，以至于大多数非内核开发者不认为它会是一个问题：他们只知道打开文件，并认为这是理所当然的。
但要做好其实是相当复杂的。确切地说，因为几乎所有地方都在用路径名查找，所以对性能要求很高，而且大家都希望它在 SMP 环境中具有良好的伸缩性，而在锁定方面又很复杂。你不想发生 IO，那么缓存就非常重要。路径名查找是如此的重要，以至于你不能把它留给底层的文件系统，因为我们有 20 多种不同的文件系统，让它们各自拥有自己的缓存和锁定机制将是一场彻头彻尾的灾难。
所以，VFS 层的一个主要任务是处理所有路径名组件的锁定和缓存问题，以及所有的序列化和挂载点遍历问题，这些都是通过无锁算法（RCU）来完成的，但也会有一些非常智能的锁（Linux 内核的“lockref”锁是一种非常特殊的“带有引用计数的自旋锁”，表面上看是为 dcache 缓存而设计的，但本质上是一个专门的锁感知引用计数，可以在某些常见情况下消除锁）。
最终结果是：底层文件系统仍然需要对未缓存的内容进行查找，但它们不需要关心缓存和一致性规则以及与路径名查找相关的原子性规则。VFS 会为它们处理好所有这些问题。
而且它的性能比任何其他操作系统都要好，基本上可以在拥有数千个 CPU 的机器上完美运行。
所以不仅仅是“更好”，而是“大写”的更好。没有什么能与之相提并论的了。Linux dcache 是独一无二的。
&lt;strong>Jeremy Andrews：过去的一年对全世界来说是艰难的一年。新冠疫情对内核开发进程带来了哪些影响？&lt;/strong>
&lt;strong>Linus Torvalds&lt;/strong>：实际上，得益于我们一直以来的工作方式，它的影响非常小。电子邮件真的是一个很好的工具，我们并不依赖面对面的会议。
是的，它确实影响了去年的年度内核峰会（今年的峰会仍悬而未决），大多数会议被取消或转为线上进行。以前在办公室工作的人大都开始在家里工作（但很多核心内核维护者在之前已经这么做了）。所以，周围的很多东西都发生了改变，但内核开发还是像以前一样。
很显然，新冠疫情在其他方面影响了我们所有人的生活，但总的来说，作为几乎完全通过电子邮件进行交流的内核开发人员，我们可能是受影响最小的。
版本控制系统 Git
&lt;strong>Jeremy Andrews：Linux 只是你对开源做出的众多贡献中的一个。在 2005 年，你还创建了 Git，一个非常流行的分布式源代码控制系统。你快速地将 Linux 内核源代码树从专有的 Bitkeeper 迁移到开源的 Git 系统中，并在同年将维护工作移交给了 Junio Hamano。这里有很多有趣的故事，是什么原因促使你这么快就将项目的领导权移交了出来，你是如何找到并选择了 Junio 的？&lt;/strong>
&lt;strong>Linus Torvalds&lt;/strong>：答案可以分为两个部分。
首先，我并不想创建一个新的源代码控制系统。开发 Linux 是因为硬件和软件之间的底层接口很吸引我——基本上是出于个人的热爱和兴趣。相反，开发 Git 是因为确实有这个需要：不是因为我觉得源代码控制很有趣，而是因为我十分鄙视市面上的大多数源代码控制系统。而我觉得最合适的、在 Linux 开发当中很好用的 BitKeeper 已经无法维持下去了。
我开发 Linux 已经超过 30 年了（距离第一个版本的周年纪念还有几个月，但在 30 年前我就开始研究 Linux 的“前身”了），并且一直在维护它。但 Git 呢？我从来没有想过我真的想要长期维护它。我喜欢用它，而且在某种程度上，我认为它是最好的 SCM，但它并不是我的兴趣所在。
所以我总是希望别人来为我维护 SCM——事实上，如果当初我不用自己开发这个 SCM，我会很开心。
以上就是故事的背景。
至于 Junio，他实际上是最早加入 Git 开发队伍的人员之一。他在我将 Git 的第一个非常粗糙的版本公开后的几天内提交了第一次变更代码，所以 Junio 在 Git 一开始就参与其中了。
但我之所以把项目交给 Junio，并不是因为他是第一批参与项目的人。在维护了 Git 几个月之后，让我决定将项目交给 Junio 维护者的真正原因是“好品味”——一个很难描述的概念。我真的想不到还有什么更好的描述：编程主要是为了解决技术问题，但如何解决这些问题以及如何思考也很重要。随着时间的推移，你开始意识到：有些人就有这种“好品味”，他总能选择正确的解决方案。
我不想将编程说成是一门艺术，因为它实际上主要是关于“好的工程”。我很喜欢托马斯·爱迪生的那句“天才是百分之一的灵感加上百分之九十九的汗水”：编程涉及的几乎都是细枝末节的东西和日常繁重的工作。但是，那百分之一的“灵感”，也就是“好品味”，不仅要解决问题，而且要干净、漂亮地解决。
Junio 就有那种“好品味”。
每次提到 Git，我都想试着讲清楚：我在一开始提出了 Git 的核心思想，并经常因为这部分工作而获得太多荣誉。Git 的这 15 年，我也只是在第一年真正参与了项目。Junio 是一个优秀的维护者，是他让 Git 变成现在的样子。
顺便说一下，关于“好品味”，以及找到拥有好品味的人，并信任他们——不仅仅 Git 是这样，Linux 也是这样。与 Git 不一样的是，Linux 这个项目我仍然在积极维护，但与 Git 一样的是，Linux 也是一个有很多人共同参与的项目。我认为，Linux 的一大成功是它拥有数百名维护者，他们都具备了“好品味”，并维护着内核的不同部分。
&lt;strong>Jeremy Andrews：你有没有过这样的经历：把控制权交给维护者，然后发现这是一个错误的决定？&lt;/strong>
&lt;strong>Linus Torvalds&lt;/strong>：我们的维护体系从来就不是非黑即白的，所以不会出现这种情况。事实上，我们甚至没有将维护权正式记录下来：我们确实有一个 MAINTAINERS 文件，但那只是为了让你在遇到问题时能够找到对的人，并不是某种排他所有权的标志。
所以，“谁负责什么东西”更像是一种流动的指南，以及“这个人很活跃，工作做得很好”，而不是“我们把所有权给了那个人，然后他搞砸了”。
从某种意义上说，我们的维护体系也是流动的。假设你是某个子系统的维护者，如果你需要另一个子系统的东西，是可以跨界的。通常人们在这样做之前都会进行广泛的沟通，而且这种事情确实发生了。这并不是“你只能动这个文件”之类的硬性规定。
实际上，这与前面讨论的有关许可的事情有些联系。“Git”的另一个设计原则是“每个人都有自己的代码树，但没有哪一个代码树是特殊的”。
因为很多其他项目都使用了工具——比如 CVS 或 SVN——这些工具会让一些人变得“特殊”，赋予了他们某种“所有权”。在 BSD 世界里，他们称之为“commit bit”：给一个维护者“commit bit”意味着他可以将代码提交到中央代码库。
我一直很讨厌这种模式，因为它会不可避免地导致政治“小团体”的出现。在这种模式下，总有一些人是特殊、隐性受信任的。问题的关键甚至不在于“隐性受信任”，而在于硬币的另一面——其他人不被信任，他们被定义成局外人，必须受制于监护者。
同样，在 Git 开发中也不存在这种情况。每个人都是平等的，任何人都可以克隆代码，做自己的开发，做好了，就可以合并回来。
所以，没有必要给人们特权，也不需要“commit bit”。这样就可以避免出现政治“小团体”，也不需要“隐性信任”。如果他们做得不好——或者更常见的是，最终消失了，并转向了另一个兴趣——他们的代码就不会被合并回来，也不会阻碍其他有新想法的人。
&lt;strong>Jeremy Andrews：Git 有没有哪些新特性让你印象深刻，并成为你工作流的一部分？还有哪些特性是你想要增加的？&lt;/strong>
&lt;strong>Linus Torvalds&lt;/strong>：我对 Git 的需求总是最早得到满足的，所以，对于我来说，Git 没有“新”特性。
这些年来，Git 确实有很大的改进，有一些在我的工作流中已经体现出来了。例如，Git 的速度一直都很快——毕竟这是我的设计目标之一——但它的大部分特性最初是围绕 shell 脚本而构建的。多年来，大多数 shell 脚本都已经消失了，这意味着我可以比原来更快地应用 Andrew Morton 的补丁。这一点令人感到欣慰，因为这实际上是我早期用于性能测试的基准之一。
所以，Git 对我来说一直都很好，而且变得越来越好。
Git 最大的改进在于“普通用户”的使用体验变得更好了。一部分原因是人们在学习 Git 工作流的过程中逐渐习惯了它，但更多的是因为 Git 本身变得更易于使用。&lt;/p></description></item><item><title>Docs: POSIX</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/posix/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/posix/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/POSIX">Wiki,POSIX&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://cloud.tencent.com/developer/ask/26856">腾讯云,什么是 POSIX&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>&lt;strong>Portable Operating System Interface(便携式操作系统接口，POSIX)&lt;/strong> 是 IEEE 计算机协会指定的一系列标准，用于维护操作系统之间的兼容性。 POSIX 定义了应用程序编程接口 (API)，以及命令行 shell 和实用程序接口，以实现与 类 Unix 操作系统 和 其他操作系统的软件兼容性。&lt;/p>
&lt;p>一般情况下，应用程序通过应用编程接口(API)而不是直接通过系统调用来编程。这点很重要，因为应用程序使用的这种编程接口实际上并不需要和内核 提供的系统调用对应。一个 API 定义了一组应用程序使用的编程接口。它们可以实现成一个系统调用，也可以通过调用多个系统调用来实现，而完全不使用任何系 统调用也不存在问题。实际上，API 可以在各种不同的操作系统上实现，给应用程序提供完全相同的接口，而它们本身在这些系统上的实现却可能迥异。&lt;/p>
&lt;p>在 Unix 世界中，最流行的应用编程接口是基于 POSIX 标准的。从纯技术的角度看，POSIX 是由 IEEE 的一组标准组成，其目标是提供一套大体上基于 Unix 的可移植操作系统标准。Linux 是与 POSIX 兼容的。&lt;/p>
&lt;p>POSIX 是说明 API 和系统调用之间关系的一个极好例子。在大多数 Unix 系统上，根据 POSIX 而定义的 API 函数和系统调用之间有着直接关 系。实际上，POSIX 标准就是仿照早期 Unix 系统的界面建立的。另一方面，许多操作系统，像 Windows NT，尽管和 Unix 没有什么关系，也提供了与 POSIX 兼容的库。&lt;/p>
&lt;p>Linux 的系统调用像大多数 Unix 系统一样，作为 C 库的一部分提供如图 5-1 所示。如图 5-1 所示 C 库实现了 Unix 系统的主要 API，包括标 准 C 库函数和系统调用。所有的 C 程序都可以使用 C 库，而由于 C 语言本身的特点，其他语言也可以很方便地把它们封装起来使用。此外，C 库提供了 POSIX 的绝大部分 API。&lt;/p>
&lt;p>从程序员的角度看，系统调用无关紧要；他们只需要跟 API 打交道就可以了。相反，内核只跟系统调用打交道；库函数及应用程序是怎么使用系统调用不是内核所关心的。
-&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;ndash;这是分割线&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;ndash;
简单总结：
完成同一功能，不同内核提供的系统调用（也就是一个函数）是不同的，例如创建进程，linux 下是 fork 函数，windows 下是 creatprocess 函数。好，我现在在 linux 下写一个程序，用到 fork 函数，那么这个程序该怎么往 windows 上移植？我需要把源代码里的 fork 通通改成 creatprocess，然后重新编译&amp;hellip;&lt;/p>
&lt;p>POSIX 标准的出现就是为了解决这个问题。linux 和 windows 都要实现基本的 POSIX 标准，Linux 把 fork 函数封装成 posix_fork（随便说的），windows 把 creatprocess 函数也封装成 posix_fork，都声明在 unistd.h 里。这样，程序员编写普通应用时候，只用包含 unistd.h，调用 posix_fork 函数，程序就在源代码级别可移植了&lt;/p></description></item><item><title>Docs: RedHat 与 CentOS</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E7%B1%BB-unix-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/redhat-%E4%B8%8E-centos/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E7%B1%BB-unix-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/redhat-%E4%B8%8E-centos/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://access.redhat.com/products/red-hat-enterprise-linux/#knowledge">RedHat 官方文档&lt;/a>(在这里点击 Product Documentation)&lt;/li>
&lt;li>&lt;a href="https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/7">RedHat7 生产环境文档&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/8">RedHat8 生产环境文档&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.centos.org/legal/">CentOS 官方，法律&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>&lt;a href="https://mp.weixin.qq.com/s/heX7Qtc7Fizx43EgGkIiMQ">CentOS: 永远有多远就离它多远&lt;/a>
&lt;a href="https://mp.weixin.qq.com/s/DUUYW_OBV_wUu1wZaP6gAg">CentOS7 好日子到头了，如何优雅的抛弃 CentOS7？&lt;/a>
&lt;a href="https://mp.weixin.qq.com/s/FMvNx-kzz7DZZqGGpxjbuw">CentOS 8 退役倒计时，开发者们又吵起来了&lt;/a>&lt;/p>
&lt;p>CentOS 居然还用 python2
装 Python3 很费劲
装 python-libvirt 很费劲&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/wlni0v/1654840849145-f536a3be-b969-40b8-813d-959985b4f429.jpeg" alt="41212703dee962f84b5c4a49a80707d.jpg">&lt;/p>
&lt;h1 id="安装-centos">安装 CentOS&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://github.com/rhinstaller/anaconda">GitHub 项目，rhinstaller/anaconda&lt;/a>(RedHat 相关发行版的操作系统安装器)&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>RedHat 系列的 .iso 安装文件中包含了 Anaconda 安装器。&lt;/p>
&lt;h2 id="注意事项">注意事项&lt;/h2>
&lt;p>/bin,/dev,/sbin,/etc,/lib,/root, /mnt, lost+found, /proc 这些目录不能创建单独的分区并挂载，只能创建一个 / 以包含这些目录&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://unix.stackexchange.com/questions/121318/this-mount-point-is-invalid-the-root-directory-must-be-on-file-system">https://unix.stackexchange.com/questions/121318/this-mount-point-is-invalid-the-root-directory-must-be-on-file-system&lt;/a>&lt;/li>
&lt;li>代码：&lt;a href="https://github.com/rhinstaller/anaconda/blob/rhel6-branch/storage/__init__.py#L1084">https://github.com/rhinstaller/anaconda/blob/rhel6-branch/storage/&lt;strong>init&lt;/strong>.py#L1084&lt;/a>&lt;/li>
&lt;li>高于 6 版本的分之代码将这个行为封装了
&lt;ul>
&lt;li>&lt;a href="https://github.com/rhinstaller/anaconda/blob/rhel-9/pyanaconda/modules/storage/checker/utils.py#L31">https://github.com/rhinstaller/anaconda/blob/rhel-9/pyanaconda/modules/storage/checker/utils.py#L31&lt;/a>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h1 id="关联文件">关联文件&lt;/h1>
&lt;p>&lt;strong>/etc/sysconfig/*&lt;/strong> # Red Hat Linux 发行版的各种系统配置文件&lt;/p>
&lt;h1 id="centos-法律">CentOS 法律&lt;/h1>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/wlni0v/1647171407465-5e7ad5f3-913d-4c93-a893-e3334b09bfbb.png" alt="image.png">&lt;/p>
&lt;h1 id="centos-变为上游项目">Centos 变为上游项目&lt;/h1>
&lt;p>Centos 的创始人新建了一个 &lt;a href="https://github.com/rocky-linux/rocky">&lt;strong>Rocky 项目&lt;/strong>&lt;/a>，旨在作为 RedHat 下游 Linux 发行版&lt;/p>
&lt;p>Frequently Asked Questions&lt;/p>
&lt;blockquote>
&lt;p>&lt;strong>Q:&lt;/strong> What do you mean, &amp;ldquo;CentOS has shifted direction?&amp;rdquo;&lt;/p>
&lt;/blockquote>
&lt;p>The CentOS project recently announced a shift in strategy for CentOS. Whereas previously CentOS existed as a &lt;em>downstream&lt;/em> build of its upstream vendor (it receives patches and updates after the upstream vendor does), it will be shifting to an &lt;em>upstream&lt;/em> build (testing patches and updates &lt;em>before&lt;/em> inclusion in the upstream vendor).&lt;/p>
&lt;p>Additionally, support for CentOS Linux 8 has been cut short, from May 31, 2029 to December 31, 2021.&lt;/p>
&lt;blockquote>
&lt;p>&lt;strong>Q:&lt;/strong> So where does Rocky Linux come in?&lt;/p>
&lt;/blockquote>
&lt;p>Rocky Linux aims to function as a downstream build as CentOS had done previously, building releases after they have been added to the upstream vendor, not before.&lt;/p>
&lt;blockquote>
&lt;p>&lt;strong>Q:&lt;/strong> When will it be released?&lt;/p>
&lt;/blockquote>
&lt;p>There is not currently an ETA for release.&lt;/p>
&lt;blockquote>
&lt;p>&lt;strong>Q:&lt;/strong> What is the vision for Rocky Linux?&lt;/p>
&lt;/blockquote>
&lt;p>A &lt;strong>solid&lt;/strong>, &lt;strong>stable&lt;/strong>, and &lt;strong>transparent&lt;/strong> alternative for production environments, developed &lt;em>by&lt;/em> the community &lt;em>for&lt;/em> the community.&lt;/p>
&lt;blockquote>
&lt;p>&lt;strong>Q:&lt;/strong> Who drives Rocky Linux?&lt;/p>
&lt;/blockquote>
&lt;p>We all do, Rocky Linux is a community-driven project and always will be. Rocky Linux will not be sold or driven by corporate interest.&lt;/p>
&lt;blockquote>
&lt;p>&lt;strong>Q:&lt;/strong> How can I get involved?&lt;/p>
&lt;/blockquote>
&lt;p>Please view the contributing section below.&lt;/p>
&lt;h1 id="centos-stream-问题汇总">Centos Stream 问题汇总&lt;/h1>
&lt;p>CentOS Stream 使用了别人已经用了很久的 system-resolved.service 服务，但是从 centos8 升级到 centos stream 后，服务有了，但是却并没有自动启动该服务，也就导致了没有 /run/systemd/resolve/resolv.conf 文件，很多程序在发现 system-resolved.service 后，会去读取这个文件，比如 kubelet 程序。&lt;/p></description></item><item><title>Docs: Windows 操作系统</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/windows-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/windows-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;h1 id="文件系统管理">文件系统管理&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://www.howtogeek.com/318177/what-is-the-appdata-folder-in-windows/">https://www.howtogeek.com/318177/what-is-the-appdata-folder-in-windows/&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>&lt;strong>C:\Users&amp;lt;USER&amp;gt;\AppData*&lt;/strong> #&lt;/p>
&lt;ul>
&lt;li>&lt;strong>.\Local*&lt;/strong> #&lt;/li>
&lt;li>&lt;strong>.\LocalLow*&lt;/strong> #&lt;/li>
&lt;li>&lt;strong>.\Roaming*&lt;/strong> #&lt;/li>
&lt;/ul>
&lt;h1 id="注册表">注册表&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://mp.weixin.qq.com/s/5ZcvRNG7GvvopcQWWdXNaw">公众号-差评，所有电脑管家都叫你清理的注册表，竟然能偷偷控制你的电脑！&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;h2 id="注册表前身">注册表前身&lt;/h2>
&lt;p>其实，注册表也不是一开始就存在于 Windows 上。
在 Windows 95 之前，微软通过一种叫 “ 配置文件 ” 的东西，来实现如今注册表的作用。
这里面存储的，就是一些软件的&lt;strong>基本信息&lt;/strong>。比如说配置一些文件的打开路径在哪里，或者是软件要用哪些字体来读取。
通常通过 ini 格式的文件，配置文件会趁着咱们安装各种软件的时候，把自己丢在系统的各种文件夹里。想修改一些配置的时候，咱们可以直接去这个软件的安装目录里找 ini 文件就行。
看上去挺方便，不过这 ini 文件最大的问题吧，就是太容易修改了，甚至可以简单到直接用记事本给打开。
到时候手一抖改几个字，可能一个软件就打不开了。
比如把一个 5 行的行间距手一抖改成复数，软件当场就寻思我哪见过这个？不当场宕机就不错了。万一改的还是系统配置文件，电脑指不定也得抽两抽。
而且，当年大家用的还都是机械硬盘。。。考虑到 ini 文件分散在系统的各种犄角旮旯，&lt;strong>读取起来太麻烦，打开也嫌慢，更不方便维护。&lt;/strong>
微软后来就一寻思，干脆把这些乱的到处都是的 ini 文件功能给&lt;strong>整合了起来。&lt;strong>通过一个统一的，系统级别的分层&lt;/strong>数据库&lt;/strong>来起到过去 “ 配置文件 ” 做的事情。这个库里面装的呢，就是咱们电脑里哪些花里胡哨，乱七八糟的配置。
举个例子，我们鼠标右键的每次点击，到底会弹出来哪些菜单选项，以及具体要弹的多长。&lt;strong>都得让注册表来告诉它才行。&lt;/strong>
而且吧，比起过去各自为战，互相之间看不对眼的配置文件。注册表还能起到一个&lt;strong>系统级别的调度功能，&lt;strong>可以把这些软件之间的信息共享给其它软件，。
当有新的软件安装的时候，也会优先把自己能干什么，自己需要什么的消息给写入注册表里。
就像咱们现在能用 WPS 软件来打开 word 文档，中间还得靠注册表这个 “传话筒” 来沟通才行。想让系统能弄清楚，我们得把&lt;/strong> “ wps 可以打开 word ” 文档这件事情，写到注册表里。&lt;/strong>
借助当时更为先进的数据库结构，注册表还能够实现**多用户配置和多线程读写等功能。**别看咱们现在嫌弃注册表长的丑，&lt;strong>要知道当年，这可是少有的图形可视化界面。&lt;/strong>&lt;/p>
&lt;h2 id="注册表小解">注册表小解&lt;/h2>
&lt;p>按 win + R，在对话框里输入 “ regedit ” 来打开注册表编辑器。
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/qnpbng/1660293598735-fcf30cc1-e1be-40a6-91da-e8cf808c68a0.png" alt="">
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/qnpbng/1660293605253-91760000-23a0-4ee2-9b36-816624680ff5.png" alt="">&lt;/p>
&lt;h3 id="备份注册表">备份注册表&lt;/h3>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/qnpbng/1660294119487-0956a3de-ee96-4771-9584-b5e4e473ab0a.png" alt="image.png">&lt;/p>
&lt;h2 id="应用示例">应用示例&lt;/h2>
&lt;h3 id="在鼠标右键菜单上添加内容">在鼠标右键菜单上添加内容&lt;/h3>
&lt;p>打开注册表后，在表上的地址栏里输入这个：&lt;code>HKEY_CLASSES_ROOT\Directory\Background\shell&lt;/code>
在 shell 中“添加项”，添加的项名就是右键菜单中的功能名
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/qnpbng/1660293800817-e8b7c6ec-a7e6-4cdc-af1b-fba835707b2f.png" alt="image.png">
不过这回还没给它加上功能，直接点击的话会报错。
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/qnpbng/1660293861254-00b77fdd-b0d2-4f40-b5a1-59f215198b70.png" alt="">
在 “lichenhao”项下添加 “command”项；修改 command 项中的默认值为想要运行进程的绝对路径
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/qnpbng/1660294056508-703dab2f-1fad-4a5e-a9ec-3ae07245dd93.png" alt="image.png">
此时右键的 “lichenhao”就可以运行 Python 了。&lt;/p>
&lt;h1 id="查看崩溃信息">查看崩溃信息&lt;/h1>
&lt;p>&lt;a href="https://its401.com/article/CRJ297486/120602345">https://its401.com/article/CRJ297486/120602345&lt;/a>
特别生气！！！！某一天突然发现拖拽文件拖拽到其他文件夹就会导致资源管理器卡死，然后还以为是自己拖错了，然后越来越频繁。
然后疯狂百度 1.打开控制面板
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/qnpbng/1654348939190-57e80915-99a7-4521-992f-683029eff444.png" alt="image.png"> 2.再进入安全和维护
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/qnpbng/1654348939189-d155d75e-ee86-4dce-8ddf-66eb077b7138.png" alt="image.png"> 3.点击维护查看可靠性历史记录
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/qnpbng/1654348939189-f0bf328c-11eb-449c-91d7-a67f2d7c6e84.png" alt="image.png"> 4.点击关键信息随便个事件进去可以看见因为啥文件导致卡死的。
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/qnpbng/1654348939160-131bfda2-8f0e-466b-b0d9-941a4542d9c0.png" alt="image.png">
我是因为 wps 的某个文件，把 wps 卸了就好了。 5.如果还没解决的话，可以试试利用 Dism 修复系统
管理员打开 cmd 命令行。
直接输入这两条就好了
DISM /Online /Cleanup-image /ScanHealth //这一条指令用来扫描全部系统文件，并扫描计算机中映像文件与官方系统不一致的情况。 DISM /Online /Cleanup-image /RestoreHealth //计算机必须联网，这种命令的好处在于可以在修复时，系统未损坏部分可以继续运行&lt;/p></description></item><item><title>Docs: 分时系统 与 实时系统</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E5%88%86%E6%97%B6%E7%B3%BB%E7%BB%9F-%E4%B8%8E-%E5%AE%9E%E6%97%B6%E7%B3%BB%E7%BB%9F/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E5%88%86%E6%97%B6%E7%B3%BB%E7%BB%9F-%E4%B8%8E-%E5%AE%9E%E6%97%B6%E7%B3%BB%E7%BB%9F/</guid><description>
&lt;h1 id="time-sharing-system分时系统">Time Sharing System(分时系统)&lt;/h1>
&lt;h2 id="概述">概述&lt;/h2>
&lt;p>**Time Sharing Operating System(分时操作系统，简称 TSOS) **的出现是为了弥补批处理方式不能向用户提供交互式快速服务的缺点而发展起来的，并且成为了当今(2021 年) 的主流操作系统。&lt;/p>
&lt;p>在分时系统中，一台计算机主机连接了多个终端，每个终端可由一个用户使用。用户通过终端交互式地向系统发出命令请求，系统接受用户的命令之后，采用时间片轮转方式处理服务请求，并通过交互方式在终端上向用户显示结果。&lt;/p>
&lt;p>这样的系统现在(2021 年)仍然占据着大量的市场，Windos、MacOS，Linux 都属于分时操作系统。分时系统的典型代表就是 UNIX，它对后续操作系统的设计产生了重大影响。&lt;/p>
&lt;p>分时共享是出于这样的认识而开发的：即尽管任何单个用户都会低效地使用计算机，但一大群用户在一起却不会。这是由于交互模式所致: 通常，单个用户会输入大量信息，然后进行长时间的暂停，但是一组用户同时工作将意味着一个用户的暂停将被其他用户的活动所填补。给定最佳的群体规模，整个过程可能非常有效。同样，可以将等待磁盘，磁带或网络输入所花费的一小部分时间授予其他用户。&lt;/p>
&lt;h2 id="分时的概念与实现">分时的概念与实现&lt;/h2>
&lt;p>分时操作系统将 CPU 的运行时间划分为若干个小片段，称为 &lt;strong>Time slice(时间片)。Time slice(时间片)&lt;/strong> 是系统规定进程一次使用 CPU 的最长时间(时间片的长短可以因不同系统而异)。&lt;/p>
&lt;p>最开始，时间片通常是 100ms 左右，这是一个实验统计值(不能太大也不能太小)。另外，在硬件方面设立一个中断时钟，它每过时间片便向 CPU 发一次中断信号。于是，假设现在有多个用户程序 A、B、C，CPU 在一个 A 执行完一个时间片后便被中断，然后去执行 B 一个时间片，再执行 C 一个时间片，一次循环，直到 A、B、C 三个程序全部执行完成。操作系统会保护被中断程序的运行现场，转去执行另一个用户程序。&lt;/p>
&lt;p>就这样，操作系统可以把 CPU 按时间片依次分配给系统中的各个用户程序。由于系统中用户程序的数目是有限的，所以，只要时间片大小选取合适，就能给用户以独占系统资源的感觉，可以使每个用户能及时与自己的作业交互，使用户的请求得到及时响应。其实，为了实现人机交互，分时操作系统对早起批处理系统的运行方式进行了两大改进：一是作业直接进内存；二是作业不能长期占用 CPU，而是以时间片为单位交替使用 CPU。&lt;/p>
&lt;p>分时系统的原理，同样也适用于多任务上，当系统中 1 个用户同时运行了多个程序时，也可以使用时间片的概念，让多个程序形成逻辑上的“并行”执行。&lt;/p>
&lt;p>UNIX 就是典型的通用的分时操作系统。&lt;/p>
&lt;h1 id="real-time-system实时操作系统">Real Time System(实时操作系统)&lt;/h1>
&lt;h2 id="概述-1">概述&lt;/h2>
&lt;blockquote>
&lt;p>参考：&lt;a href="https://en.wikipedia.org/wiki/Real-time_operating_system">Wiki,Real-time OS&lt;/a>&lt;/p>
&lt;/blockquote>
&lt;p>&lt;strong>Real Time Operating System(实时操作系统，简称 RTOS)&lt;/strong> 是一种操作系统 (OS)，旨在为实时应用程序提供服务，这些应用程序通常在没有缓冲区延迟的情况下处理数据。处理时间要求 (包括任何 OS 延迟) 以十分之一秒或更短的时间增量来衡量。实时系统是具有明确定义的固定时间约束的有时限的系统。处理必须在定义的约束条件下完成，否则系统将失败。它们要么是事件驱动的，要么是分时的。事件驱动系统根据任务的优先级在任务之间切换，而分时系统根据时钟中断切换任务。大多数 RTOS 使用先发制人的调度算法。&lt;/p>
&lt;p>实时操作系统主要有两类：&lt;/p>
&lt;ul>
&lt;li>硬实时系统 # 对关键外部时间的响应和处理时间有这极其严格的要求，系统必须满足这种严格的时间要求，否则会产生严重的不良后果。
&lt;ul>
&lt;li>火箭和导弹控制、机器人控制、核反应堆控制等都是硬实时系统应用的典型领域。飞行控制系统就是硬实时的。这种时间精确度通常会要求在微秒以下。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>软实时系统 # 对时间的响应和处理时间有一定的时间范围要求，不能满足相关的要求会影响系统的服务质量，但是通常不会引发灾难性的后果。如视频信息处理、电信、银行、飞机订票等领域的信息处理。&lt;/li>
&lt;/ul>
&lt;h1 id="总结">总结&lt;/h1>
&lt;p>实际上，Time Sharing 与 Real Time 都是一种任务处理的方式，只要一个操作系统实现了这种方式，就可以称为 TSOS 或 RTOS，LInux 的进程调度系统，随着时间的发展，也逐渐具备了两种方式。&lt;/p></description></item><item><title>Docs: 类 Unix 操作系统</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E7%B1%BB-unix-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E7%B1%BB-unix-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E7%B1%BB-unix-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E7%B1%BB-unix-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Unix">Wiki,Unix&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://man7.org/linux/man-pages/man5/os-release.5.html">Manual(手册),os-release&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://distrowatch.com/">DistroWatch&lt;/a>(类 UNIX 系统的资讯网站)&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>Unix 是一系列多任务、多用户计算机操作系统的统称。&lt;/p>
&lt;p>最初打算在&lt;a href="https://en.wikipedia.org/wiki/Bell_System">贝尔系统&lt;/a>内部使用，AT&amp;amp;T 在 1970 年代后期&lt;a href="https://en.wikipedia.org/wiki/License">将&lt;/a>Unix&lt;a href="https://en.wikipedia.org/wiki/License">授权&lt;/a>给外部各方，导致来自&lt;a href="https://en.wikipedia.org/wiki/University_of_California,_Berkeley">加利福尼亚大学伯克利分校&lt;/a>( &lt;a href="https://en.wikipedia.org/wiki/Berkeley_Software_Distribution">BSD&lt;/a> )、&lt;a href="https://en.wikipedia.org/wiki/Microsoft">微软&lt;/a>( &lt;a href="https://en.wikipedia.org/wiki/Xenix">Xenix&lt;/a> )、&lt;a href="https://en.wikipedia.org/wiki/Sun_Microsystems">Sun Microsystems 等&lt;/a>供应商的各种学术和商业 Unix 变体( &lt;a href="https://en.wikipedia.org/wiki/SunOS">SunOS&lt;/a> / &lt;a href="https://en.wikipedia.org/wiki/Solaris_(operating_system)">Solaris&lt;/a> )、&lt;a href="https://en.wikipedia.org/wiki/Hewlett-Packard">HP&lt;/a> / &lt;a href="https://en.wikipedia.org/wiki/Hewlett_Packard_Enterprise">HPE&lt;/a> ( &lt;a href="https://en.wikipedia.org/wiki/HP-UX">HP-UX&lt;/a> ) 和&lt;a href="https://en.wikipedia.org/wiki/IBM">IBM&lt;/a> ( &lt;a href="https://en.wikipedia.org/wiki/AIX">AIX&lt;/a> )。在 1990 年代初期，AT&amp;amp;T 将其在 Unix 中的权利出售给了&lt;a href="https://en.wikipedia.org/wiki/Novell">Novell&lt;/a>，&lt;a href="https://en.wikipedia.org/wiki/Novell">Novell&lt;/a>随后将其 Unix 业务出售给了&lt;a href="https://en.wikipedia.org/wiki/Santa_Cruz_Operation">Santa Cruz Operation&lt;/a> (SCO) 于 1995 年。&lt;a href="https://en.wikipedia.org/wiki/Unix#cite_note-4">[4]&lt;/a> UNIX 商标转让给了&lt;a href="https://en.wikipedia.org/wiki/The_Open_Group">The Open Group&lt;/a>，这是一个成立于 1996 年的行业联盟，允许将该标志用于符合&lt;a href="https://en.wikipedia.org/wiki/Single_UNIX_Specification">单一 UNIX 规范&lt;/a>(SUS) 的认证操作系统。但是，Novell 继续拥有 Unix 版权，&lt;a href="https://en.wikipedia.org/wiki/SCO_Group,_Inc._v._Novell,_Inc.">SCO Group, Inc. 诉 Novell, Inc.&lt;/a>法庭案件 (2010) 证实了这一点。&lt;/p>
&lt;p>Unix 系统的特点是&lt;a href="https://en.wikipedia.org/wiki/Modular_design">模块化设计&lt;/a>，有时被称为“ &lt;a href="https://en.wikipedia.org/wiki/Unix_philosophy">Unix 哲学&lt;/a>”。根据这一理念，操作系统应该提供一组简单的工具，每个工具都执行有限的、定义明确的功能。&lt;a href="https://en.wikipedia.org/wiki/Unix#cite_note-5">[5]&lt;/a>统一的&lt;a href="https://en.wikipedia.org/wiki/Filesystem">文件系统&lt;/a>（&lt;a href="https://en.wikipedia.org/wiki/Unix_filesystem">Unix 文件系统&lt;/a>）和称为“&lt;a href="https://en.wikipedia.org/wiki/Pipeline_(Unix)">管道&lt;/a>”&lt;a href="https://en.wikipedia.org/wiki/Inter-process_communication">的进程间通信&lt;/a>机制作为主要通信手段，&lt;a href="https://en.wikipedia.org/wiki/Unix#cite_note-Ritchie-3">[3]&lt;/a>和&lt;a href="https://en.wikipedia.org/wiki/Shell_(computing)">shell&lt;/a>脚本和命令语言（&lt;a href="https://en.wikipedia.org/wiki/Unix_shell">Unix shell&lt;/a>）用于结合执行复杂工作流程的工具。&lt;/p>
&lt;p>作为第一个&lt;a href="https://en.wikipedia.org/wiki/Software_portability">可移植&lt;/a>操作系统，Unix 与其前辈不同：几乎整个操作系统都是用&lt;a href="https://en.wikipedia.org/wiki/C_(programming_language)">C 编程语言&lt;/a>编写的，这使得 Unix 可以在众多平台上运行。&lt;/p>
&lt;h2 id="类-unix-操作系统">类 Unix 操作系统&lt;/h2>
&lt;p>1983 年，&lt;a href="https://en.wikipedia.org/wiki/Richard_Stallman">Richard Stallman&lt;/a>宣布了&lt;a href="https://en.wikipedia.org/wiki/GNU">GNU&lt;/a>（“GNU&amp;rsquo;s Not Unix”的缩写）项目，这是一项雄心勃勃的努力，旨在创建一个&lt;a href="https://en.wikipedia.org/wiki/Unix-like">类似 Unix&lt;/a>的&lt;a href="https://en.wikipedia.org/wiki/Free_software">自由软件&lt;/a> 系统；“免费”是指每个收到副本的人都可以免费使用、研究、修改和重新分发它。GNU 项目自己的内核开发项目&lt;a href="https://en.wikipedia.org/wiki/GNU_Hurd">GNU Hurd&lt;/a>尚未生产出可运行的内核，但在 1991 年，&lt;a href="https://en.wikipedia.org/wiki/Linus_Torvalds">Linus Torvalds&lt;/a>在&lt;a href="https://en.wikipedia.org/wiki/GNU_General_Public_License">GNU 通用公共许可证&lt;/a>下发布了内核&lt;a href="https://en.wikipedia.org/wiki/Linux_kernel">Linux&lt;/a>作为自由软件。除了在&lt;a href="https://en.wikipedia.org/wiki/GNU">GNU&lt;/a>操作系统中使用之外，许多 GNU 软件包——例如&lt;a href="https://en.wikipedia.org/wiki/GNU_Compiler_Collection">GNU Compiler Collection&lt;/a>（以及其余的&lt;a href="https://en.wikipedia.org/wiki/GNU_toolchain">GNU 工具链&lt;/a>）、&lt;a href="https://en.wikipedia.org/wiki/Glibc">GNU C 库&lt;/a>和&lt;a href="https://en.wikipedia.org/wiki/Coreutils">GNU 核心实用程序&lt;/a> ——也继续在其他自由 Unix 系统中发挥核心作用。&lt;/p>
&lt;p>由 Linux 内核和大量兼容软件组成的&lt;a href="https://en.wikipedia.org/wiki/Linux_distribution">Linux 发行&lt;/a>版在个人用户和企业中都很受欢迎。流行的发行版包括&lt;a href="https://en.wikipedia.org/wiki/Red_Hat_Enterprise_Linux">Red Hat Enterprise Linux&lt;/a>、&lt;a href="https://en.wikipedia.org/wiki/Fedora_(operating_system)">Fedora&lt;/a>、&lt;a href="https://en.wikipedia.org/wiki/SUSE_Linux">SUSE Linux Enterprise&lt;/a>、&lt;a href="https://en.wikipedia.org/wiki/OpenSUSE">openSUSE&lt;/a>、&lt;a href="https://en.wikipedia.org/wiki/Debian">Debian GNU/Linux&lt;/a>、&lt;a href="https://en.wikipedia.org/wiki/Ubuntu_(operating_system)">Ubuntu&lt;/a>、&lt;a href="https://en.wikipedia.org/wiki/Linux_Mint">Linux Mint&lt;/a>、&lt;a href="https://en.wikipedia.org/wiki/Mandriva_Linux">Mandriva Linux&lt;/a>、&lt;a href="https://en.wikipedia.org/wiki/Slackware_Linux">Slackware Linux&lt;/a>、&lt;a href="https://en.wikipedia.org/wiki/Arch_Linux">Arch Linux&lt;/a>和&lt;a href="https://en.wikipedia.org/wiki/Gentoo_Linux">Gentoo&lt;/a>。&lt;a href="https://en.wikipedia.org/wiki/Unix#cite_note-26">[26]&lt;/a>&lt;/p>
&lt;p>&lt;a href="https://en.wikipedia.org/wiki/BSD">BSD&lt;/a> Unix 的免费衍生产品&lt;a href="https://en.wikipedia.org/wiki/386BSD">386BSD&lt;/a>于 1992 年发布，引发了&lt;a href="https://en.wikipedia.org/wiki/NetBSD">NetBSD&lt;/a>和&lt;a href="https://en.wikipedia.org/wiki/FreeBSD">FreeBSD&lt;/a>项目。1994 年，&lt;a href="https://en.wikipedia.org/wiki/Unix_System_Laboratories">Unix 系统实验室&lt;/a>对加州大学和伯克利软件设计公司（&lt;a href="https://en.wikipedia.org/wiki/USL_v._BSDi">&lt;em>USL 诉 BSDi&lt;/em>&lt;/a>）提起的诉讼达成和解，澄清了伯克利有权免费分发 BSD Unix，如果它愿意的话。从那时起，BSD Unix 已经在几个不同的产品分支中开发，包括&lt;a href="https://en.wikipedia.org/wiki/OpenBSD">OpenBSD&lt;/a>和&lt;a href="https://en.wikipedia.org/wiki/DragonFly_BSD">DragonFly BSD&lt;/a>。&lt;/p>
&lt;p>Linux 和 BSD 越来越多地满足传统上由专有 Unix 操作系统提供服务的市场需求，并扩展到新市场，如消费桌面和移动和嵌入式设备。由于 Unix 模型的模块化设计，共享组件比较常见；因此，大多数或所有 Unix 和类 Unix 系统至少包含一些 BSD 代码，一些系统还在其发行版中包含 GNU 实用程序。&lt;/p>
&lt;p>在 1999 年的一次采访中，Dennis Ritchie 表达了他的观点，即 Linux 和 BSD 操作系统是 Unix 设计基础的延续，是 Unix 的衍生物：&lt;a href="https://en.wikipedia.org/wiki/Unix#cite_note-Interview_1999-27">[27]&lt;/a>&lt;/p>
&lt;blockquote>
&lt;p>我认为 Linux 现象非常令人愉快，因为它强烈地依赖于 Unix 提供的基础。Linux 似乎是最健康的直接 Unix 衍生产品之一，尽管也有各种 BSD 系统以及来自工作站和大型机制造商的更多官方产品。&lt;/p>
&lt;/blockquote>
&lt;p>在同一次采访中，他表示他认为 Unix 和 Linux 都是“多年前由 Ken 和我以及许多其他人发起的想法的延续”。&lt;a href="https://en.wikipedia.org/wiki/Unix#cite_note-Interview_1999-27">[27]&lt;/a>&lt;/p>
&lt;p>&lt;a href="https://en.wikipedia.org/wiki/OpenSolaris">OpenSolaris&lt;/a>是&lt;a href="https://en.wikipedia.org/wiki/Sun_Microsystems">Sun Microsystems&lt;/a>开发的&lt;a href="https://en.wikipedia.org/wiki/Solaris_(operating_system)">Solaris&lt;/a>的&lt;a href="https://en.wikipedia.org/wiki/Free_software">免费软件&lt;/a>对应物，其中包括&lt;a href="https://en.wikipedia.org/wiki/CDDL">CDDL&lt;/a>许可的内核和主要的&lt;a href="https://en.wikipedia.org/wiki/GNU">GNU&lt;/a>用户空间。然而，&lt;a href="https://en.wikipedia.org/wiki/Oracle_Corporation">甲骨文&lt;/a>在收购 Sun 后停止了该项目，这促使一群前 Sun 员工和 OpenSolaris 社区成员将 OpenSolaris 分叉到&lt;a href="https://en.wikipedia.org/wiki/Illumos">illumos&lt;/a>内核中。截至 2014 年，illumos 仍然是唯一活跃的开源 System V 衍生产品。&lt;/p>
&lt;h1 id="关联文件">关联文件&lt;/h1>
&lt;p>**/etc/os-release **# 操作系统标识。该文件是 /usr/lib/os-release 文件的软链接&lt;/p>
&lt;p>注意：&lt;/p>
&lt;ul>
&lt;li>不同的 Linux 发行版，都会有一些自身特有的配置，比如 /etc/sysconfg 目录，只会在 RedHat 相关发行版(比如.CentOS)中出现，Ubuntu 并没有这个目录。&lt;/li>
&lt;/ul>
&lt;h2 id="os-release-详解">os-release 详解&lt;/h2>
&lt;p>/etc/os-release 是本身是 &lt;a href="https://www.yuque.com/desistdaydream/learning/sa1uqi">systemd&lt;/a> 的一部分，包含了操作系统的识别数据。在&lt;a href="http://0pointer.de/blog/projects/os-release">这篇文章&lt;/a>里，详解描述了为什么需要这个文件。该文件通常是操作系统供应商定义的，不应该手动修改。&lt;/p>
&lt;p>os-release 是一个以换行符分隔的类似环境的 shell 兼容变量赋值列表。示例如下：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>~# cat /etc/os-release
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>NAME&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;Ubuntu&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>VERSION&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;20.04.2 LTS (Focal Fossa)&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>ID&lt;span style="color:#f92672">=&lt;/span>ubuntu
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>ID_LIKE&lt;span style="color:#f92672">=&lt;/span>debian
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>PRETTY_NAME&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;Ubuntu 20.04.2 LTS&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>VERSION_ID&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;20.04&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>HOME_URL&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;https://www.ubuntu.com/&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>SUPPORT_URL&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;https://help.ubuntu.com/&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>BUG_REPORT_URL&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;https://bugs.launchpad.net/ubuntu/&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>PRIVACY_POLICY_URL&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;https://www.ubuntu.com/legal/terms-and-policies/privacy-policy&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>VERSION_CODENAME&lt;span style="color:#f92672">=&lt;/span>focal
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>UBUNTU_CODENAME&lt;span style="color:#f92672">=&lt;/span>focal
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>这个文件可以很方便得让各种 shell 脚本获取到操作系统的信息，只需要脚本中执行 &lt;code>source /etc/os-release&lt;/code> 命令即可。&lt;/p>
&lt;h1 id="ubuntu-与-centos-的异同">Ubuntu 与 CentOS 的异同&lt;/h1>
&lt;h2 id="安装镜像">安装镜像&lt;/h2>
&lt;p>CentOS 的 iso 中包含了所有基础环境所需的软件包，但是 iso 文件过大，7 是 4G 多，8 有 9G 多
Ubuntu 的 iso 中只有一点软件包，虚拟化环境的都没有，但是 iso 文件很小，只有不到 1G&lt;/p>
&lt;h2 id="网络配置">网络配置&lt;/h2>
&lt;p>CentOS 对 NetworkManager 改动较大
Ubuntu 对 NetworkManager 改动几乎没有&lt;/p></description></item><item><title>Docs: 系统启动流程</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E7%B3%BB%E7%BB%9F%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E7%B3%BB%E7%BB%9F%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://mp.weixin.qq.com/s/hItVJbvxN2DHkb1rwYSltA">公众号，马哥 Linux 运维-Linux 系统开机加电后发生了什么？&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://mp.weixin.qq.com/s/QDjAIzas5EXQ24-NfTU3TQ">公众号，码农的荒岛求生-操作系统是如何启动起来的？&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>操作系统被称为 The first programme(第一个程序)，原因很简单，只有当操作系统启动起来后才能运行我们编写的程序，那么操作系统是怎样启动起来的呢？&lt;strong>实际上这个过程就像发射火箭一样有趣&lt;/strong>&lt;/p>
&lt;h2 id="操作系统也是普通程序">操作系统也是普通程序&lt;/h2>
&lt;p>首先我们必须意识到这样两点：&lt;/p>
&lt;ul>
&lt;li>CPU 执行的是机器指令，编译器将程序翻译后成了机器指令&lt;/li>
&lt;li>操作系统本身也是一个程序，这个程序被编译后也会生成一大堆机器指令&lt;/li>
&lt;/ul>
&lt;p>现在我们知道了，操作系统本身其实也是一大堆机器指令，既然是机器指令那么它必须得存放在什么地方。&lt;/p>
&lt;p>存放在哪里呢？&lt;/p>
&lt;p>想想我们编写的程序，编译后生成的是可执行文件，也就是说是以“文件”的形式存放的，并且存放在硬盘上，而操作系统也没什么不同，编译后生成的机器指令同样是以文件的形式存放的，存放在哪里呢？可以存放在任何能存储数据的介质，像 CD、磁盘之类都可以。&lt;/p>
&lt;p>我们编写的程序在启动时被加载器——也就是 loader，加载到内存，加载器也是一个程序，这是一个加载其它程序的程序；这么说可能有点拗口，但计算机系统中有大量类似的程序，编译器是一个翻译程序的程序、操作系统是一个运行其它程序的程序、链接器是一个链接程序的程序、解释器是一个执行脚本程序的程序等等。
&lt;strong>鸡生蛋蛋生鸡的问题&lt;/strong>&lt;/p>
&lt;p>回到我们的主题，我们写的代码是 loader 加载到内存后运行的，那么操作系统这个程序是也同样的道理，必须得有个什么东西也要把操作系统加载到内存中运行才可以，这个东西不叫 loader，而是叫 boot loader，其本身也是一个程序，&lt;strong>它的任务就是加载一个更大的程序&lt;/strong>，就像这里的操作系统。&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/id9gn1/1648429100745-ceca564f-ccaf-4249-83c4-03637c50eb6f.png" alt="">&lt;/p>
&lt;p>此时这里会出现一个鸡生蛋蛋生鸡的，既然我们的程序是被加载器 loader(操作系统的一部分)加载到内存中，而操作系统又是被 boot loader 这个加载程序加载到内存中的，那么又是什么加载器把 boot loader 这个加载程序加载到内存中呢？而又又是什么加载器把上一句中的什么加载器加载内存中呢？而又又又是什么。。？&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/id9gn1/1648429100748-550bd283-9b49-4e33-9791-a47013d74bca.png" alt="">&lt;/p>
&lt;p>你会发现这个一个没有出口的无穷递归啊有没有，总得有个什么把前一个程序加载到内存，&lt;strong>就好比今天的前一天是昨天、昨天的前一天是前天、前天的前一天是大前天，如果一直这样思考下去那么时间到底在哪里开始的呢&lt;/strong>？时间到底有没有开始(参考时间简史或相对论)？&lt;/p>
&lt;p>时间有没有开始这个问题我不清楚，但操作系统启动的这个问题我知道。&lt;/p>
&lt;p>上述关于加载器以及加载加载器等问题全部指向了内存，让我们好好想一想内存有什么特殊性？&lt;/p>
&lt;h2 id="内存断电后是无法保存数据">内存断电后是无法保存数据&lt;/h2>
&lt;p>程序员都知道内存只有在加电的情况下才可以保存数据(关于内存的实现原理你可以参考这篇《&lt;a href="http://mp.weixin.qq.com/s?__biz=Mzg4OTYzODM4Mw==&amp;amp;mid=2247485736&amp;amp;idx=1&amp;amp;sn=a70558b5200e840ef251e19a2eef099b&amp;amp;chksm=cfe995a8f89e1cbe8fab1240515f35ec90fb520d122ec60761b71a8664ae3af390689be370aa&amp;amp;scene=21#wechat_redirect">你管这破玩意叫 CPU？&lt;/a>》)，那么很显然，&lt;strong>当断电后内存中的内容就丢失了&lt;/strong>，那么又很显然的，当你在按下计算机开关通电时，内存中的内容是未被初始化的，也就是说内存中的内容是无效的，&lt;strong>此时的内存里还是一片荒芜&lt;/strong>，这里没有任何东西可供 CPU 来执行，这就好比大爆炸之前的宇宙。
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/id9gn1/1648429100787-22b14442-38f8-43b5-9e92-0cd8bc048d40.png" alt="">
但我们的计算机总是能启动起来，CPU 必须得执行“一段什么程序”把第一个 boot loader 加载到内存中，&lt;strong>由于此时内存中还什么都没有，那么这段程序一定被保存在了其它地方&lt;/strong>。&lt;/p>
&lt;p>保存在了哪里呢？&lt;/p>
&lt;p>没错，这段程序就被保存在了 BIOS 的非易失性存储 ROM 或者 flash 存储中了，这里的代码在即使断电后也会保存下来，加电后 CPU 开始执行这里代码，把 boot loader 加载到内存中，现在你应该明白第一个 boot loader 是怎样被加载到内存的了吧。
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/id9gn1/1648429100774-74b706fc-5218-4dda-b30c-eeb9ab95e7a7.png" alt="">
在早期的计算机上甚至专门有一个按钮，让用户自己选择该从哪里，比如打孔纸带、打孔卡片或者硬盘，加载一个更复杂的程序来运行，操作面板上的旋钮可以控制把这些程序加载到内存的什么位置上去：
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/id9gn1/1648429100742-3d35999a-6920-47f7-afd0-07403a3ba21c.jpeg" alt="">&lt;/p>
&lt;h2 id="火箭与操作系统启动">火箭与操作系统启动&lt;/h2>
&lt;p>然而现实情况比较复杂，我们刚才提到的 boot loader 这段小程序功能实在是太弱了，此时其能访问的磁盘地址空间有限，不能把完整的内核全部加载到操作系统中，该怎么办呢？&lt;/p>
&lt;p>既然 boot loader 比较弱那么就换一个比较牛的 loader 程序来，就这样出现了二阶 boot loader，second stage loader：
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/id9gn1/1648429101226-b5e1f5bb-da1d-43a2-932d-10265a2f2bb1.png" alt="">
二阶 boot loader 功能更为丰富，比如对硬件进行检查、给用户提供选项加载哪个操作系统等等，安装多系统的同学应该知道，启动时会给你一个选项到底是启动 windows 还是 linux，这就是二阶 boot loader 的作用。
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/id9gn1/1648429101278-dd790173-0a36-429f-9be3-be5699d90f5a.png" alt="">
最终，操作系统被二阶 boot loader 加载到内存中开始运行。&lt;/p>
&lt;p>你会发现这个过程就和发射三级火箭一样，最初一级火箭启动，燃料用尽后二级火箭启动，二级火箭完成使命后三级火箭启动，最终把卫星送到太空，而计算机的启动过程也类似。&lt;/p>
&lt;p>最初是 CPU 运行 BIOS 中的一段代码把一级 boot loader 加载到内存中运行，该程序又会把二级 boot loader 加载到内存运行，而二级 boot loader 又会把操作系统加载到内存中，此后控制权被转移到操作系统，(所谓控制权是指 CPU 跳转到操作系统的代码)，操作系统开始运行，经过一系列的初始化，比如硬件检测、开启必要的后台进程等等，最终图形界面或者命令行界面呈现出来。
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/id9gn1/1648429101302-750c6a86-5693-4248-858e-d0e1a3884a8e.png" alt="">
接下来我们把这个过程细化一下。&lt;/p>
&lt;h2 id="更详细的启动过程">更详细的启动过程&lt;/h2>
&lt;p>你在按下电源的瞬间相当于火箭点火，此时一级发动机开始工作。&lt;/p>
&lt;p>加电 CPU 重置后开始在地址 0xffff0 处开始执行指令，这个地址其实是 BIOS ROM 的末尾处，该位置其实是一个跳转指令，跳转到 ROM 的一段启动代码上，该代码会进行必要的自检，Power-on self-test (POST)，展示 BIOS 启动界面等等，最重要的一步是找到启动设备，所谓启动设备就是指从哪里加载操作系统，比如 CD-ROM、或者磁盘、甚至 U 盘等都可以作为启动设备，早些年流行用 U 盘重新安装系统，其实就是告诉 BIOS 的这段代码从 U 盘中加载操作系统。&lt;/p>
&lt;p>通常 BIOS 会把磁盘当做启动设备(大部分情况下)，此时 BIOS 中的这段代码开始将磁盘的第 0 号块加载到内存中，那么这第 0 号块中有什么呢？没错，就是第一阶段 boot loader 程序，这第 0 号块也被称之为 Master Boot Record，MBR，肯定有不少同学听说过。&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/id9gn1/1648429101348-dbe515f5-8c00-4f46-91c8-b8944d6a12d9.png" alt="">&lt;/p>
&lt;p>到这里，火箭的一级发动机燃料用尽，二级发动机开始点火，BIOS 中的这段代码把控制权交给加载到内存 boot loader，所谓控制权就是跳转到 boot loader 程序，这样 CPU 终于开始直接与内存交互了，CPU 开始从内存中取出指令然后执行。&lt;/p>
&lt;p>MBR 中除了包含一段可执行代码之外还有一个分区表，partition table，这个表的中的每一个条目本质上在说：“操作系统是否在我这个分区，我这个分区有多大”，CPU 在执行 MBR 中的代码时会去检查操作系统存在哪个分区中，定位后开始从相应分区的起始位置读取磁盘数据到内存中，这时的磁盘数据中保存的就是二阶 boot loader，second-stage boot loader，此时一阶 boot loader 把控制权转交给二阶 boot loader，火箭三级发动机开始工作。&lt;/p>
&lt;p>2_boot loader 的主要工作将操作系统加载到内存中，此后控制权转交给操作系统，火箭的三级发动机完成使命，&lt;strong>到这一时刻，操作系统开始接管计算机&lt;/strong>，操作系统经过一系列自身的初始化后创建出若干必要进程，至此计算机启动完毕，卫星被成功送到了外太空中。&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/id9gn1/1648429101351-eb22ccb7-7957-4f8c-b88e-854522e1a60c.png" alt="">&lt;/p>
&lt;p>然而限于篇幅这里依然没有过多涉及细节，操作系统本身的初始化也是一个比较复杂的过程，感兴趣的同学可以去翻阅相关操作系统的资料。&lt;/p>
&lt;h1 id="系统启动流程">系统启动流程&lt;/h1>
&lt;ul>
&lt;li>&lt;strong>Power-on self-test(POST)&lt;/strong> # 加电自检通过 ROM 芯片来检测&lt;/li>
&lt;li>&lt;strong>ROM 芯片&lt;/strong> # CMOS 然后启动 BIOS 程序&lt;/li>
&lt;li>&lt;strong>Basic Input and Output System(BIOS)&lt;/strong> # 基本输出输出系统&lt;/li>
&lt;li>&lt;strong>Boot Sequence&lt;/strong> # 按次序查找各引导设备，第一个有引导程序的设备准备本次启动用到的设备，不管该引导程序是否执行成功，只要有引导程序，就不再找下一个设备了。
&lt;ul>
&lt;li>读取硬盘的第一个扇区，这个扇区被称为 MBR．这个扇区中存储了一个小程序，叫做 boot loader．MBR 很小，只有 446B. 最常见的一种 boot loader 叫 grub.&lt;/li>
&lt;li>MBR，前 446 字节为 bootloader，后面 64 字节为 fat(磁盘分区表)，后面 2 字节为 55AA 标记&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>Bootloader&lt;/strong> # 引导加载器，这是一个程序。功能：提供一个菜单，供用户选择要启动的系统或不同的内核版本，把用户选定的内核装载到内存中的特定空间中，解压，展开，并把系统控制权移交给内核
&lt;ul>
&lt;li>boot loader 程序主要做两件事，一个是将内核加载到内存中，另一个是启动一个虚拟文件系统．内核文件是 /boot/vmlinuz*,虚拟文件系统文件是 /boot/initrd*．&lt;/li>
&lt;li>GRUB(GRand Uniform BootLoader)用来找到操作系统所在的磁盘分区，把内核加载至内存中，还能把控制权正常转交给内核的程序
&lt;ul>
&lt;li>GRUB 0.x 版：GRUB Legacy&lt;/li>
&lt;li>GRUB 1.X 版：GRUB2&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Kernel
&lt;ul>
&lt;li>初始化：
&lt;ul>
&lt;li>探测硬件&lt;/li>
&lt;li>装载硬件的驱动程序(有可能会借助于 ramdisk 加载驱动程序)&lt;/li>
&lt;li>挂载根文件系统到 / 目录下&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>运行用户空间的第一个应用程序
&lt;ul>
&lt;li>init(初始化)程序的类型
&lt;ul>
&lt;li>SysV：第一个进程名 init 早期的系统用的这个程序，通过脚本启动程序，一个启动完了才能启动下一个&lt;/li>
&lt;li>配置文件/etc/inittab&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Upstart：第一个进程名 init
&lt;ul>
&lt;li>配置文件/etc/inittab、/etc/init/*.conf&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Systemd：第一个进程名 systemd 所有程序可以并行同时启动
&lt;ul>
&lt;li>配置文件：/lib/systemd/system，/etc/systemd/system&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>ramdisk&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>POST &amp;ndash;&amp;gt; BootSequence(BIOS) &amp;ndash;&amp;gt; Bootloader(MBR) &amp;ndash;&amp;gt; kernel(ramdisk) &amp;ndash;&amp;gt; rootfs &amp;ndash;&amp;gt; init(systemd)&lt;/p>
&lt;h2 id="上电引导">上电、引导&lt;/h2>
&lt;p>按下开关键，触发主板引脚，开启电源，为主板通电&lt;/p>
&lt;h2 id="装载内核">装载内核&lt;/h2>
&lt;p>vmlinuz 分析
a. mkdir /tmp/vmlinuz&amp;amp;&amp;amp;cp /boot/vmlinuz-4.4.0-21-generic  /tmp/vmlinuz/
b. cd /tmp/vmlinuz/
c. od -t x1 -A d vmlinuz-4.4.0-21-generic | grep &amp;ldquo;1f 8b 08&amp;rdquo;
本质上，vmlinuz-4.4.0-21-generic  是一个 gzip 压缩文件，但是不能直接用 gzip 指令解压，因为在这个文件的开头嵌入了 gzip 的代码．
所以首先用指令 c 找到真正的压缩文件的头部．这个指令的输出形如:
0018864 ac fe ff ff 1f 8b 08 00 00 00 00 00 02 03 ec fd
然后执行下面的指令，其中的 18868 就是 18864+4，这里 4 是指 1f 8b 08 前面有 4 个字节．
dd if=vmlinuz-4.4.0-21-generic bs=1 skip=18868 | zcat &amp;gt; vmlinuz-gakki
objdump -D vmlinuz-gakki &amp;raquo; result
我们可以看到，最终得到的 result 就是一个汇编文件．而 vmlinuz-gakki 文件本质上是一个可执行程序．可以尝试
执行他，chmod +x vmlinuz-gakki &amp;amp;&amp;amp;./vmlinuz-gakki ．
显示 Segmentation fault&lt;/p>
&lt;p>intrid 分析
首先将/boot/intird.img 文件复制到/tmp 文件夹下
执行 file /tmp/initrd.img-4.4.0-21-generic，得到的结果如下：
/tmp/initrd.img-4.4.0-21-generic: gzip compressed data, last modified: Fri Jun 15 13:57:43 2018, from Unix
可以看到本质上这是一个 gzip 格式的压缩文件
cd /tmp
mv initrd.img-4.4.0-21-generic initrd.img-4.4.0-21-generic.gz
gzip -d initrd.img-4.4.0-21-generic.gz
file initrd.img-4.4.0-21-generic
得到的结果为：
initrd.img-4.4.0-21-generic: ASCII cpio archive (SVR4 with no CRC)
这是一个 cpio 文件
执行 cpio -idmv &amp;lt; initrd.img-4.4.0-21-generic
这样，我们可以看到它最终生成了一个小型的文件系统．&lt;/p>
&lt;h2 id="systemd-运行">Systemd 运行&lt;/h2>
&lt;p>详见 《[Systemd 运行流程](✏IT 学习笔记/📄1.操作系统/3.Systemd%20 系统守护程序/Systemd%20 运行流程.md 系统守护程序/Systemd 运行流程.md)》章节&lt;/p></description></item></channel></rss>