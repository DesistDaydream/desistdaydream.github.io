<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>断念梦 – fio</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/x.linux-%E7%AE%A1%E7%90%86/%E6%80%A7%E8%83%BD%E8%AF%84%E4%BC%B0%E4%B8%8E%E6%95%85%E9%9A%9C%E5%A4%84%E7%90%86/%E6%80%A7%E8%83%BD%E8%AF%84%E4%BC%B0/%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/fio-#-%E7%A3%81%E7%9B%98%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/</link><description>Recent content in fio on 断念梦</description><generator>Hugo -- gohugo.io</generator><atom:link href="https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/x.linux-%E7%AE%A1%E7%90%86/%E6%80%A7%E8%83%BD%E8%AF%84%E4%BC%B0%E4%B8%8E%E6%95%85%E9%9A%9C%E5%A4%84%E7%90%86/%E6%80%A7%E8%83%BD%E8%AF%84%E4%BC%B0/%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/fio-#-%E7%A3%81%E7%9B%98%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/index.xml" rel="self" type="application/rss+xml"/><item><title>Docs: fio # 磁盘性能测试工具</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/x.linux-%E7%AE%A1%E7%90%86/%E6%80%A7%E8%83%BD%E8%AF%84%E4%BC%B0%E4%B8%8E%E6%95%85%E9%9A%9C%E5%A4%84%E7%90%86/%E6%80%A7%E8%83%BD%E8%AF%84%E4%BC%B0/%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/fio-#-%E7%A3%81%E7%9B%98%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/fio-%23-%E7%A3%81%E7%9B%98%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/x.linux-%E7%AE%A1%E7%90%86/%E6%80%A7%E8%83%BD%E8%AF%84%E4%BC%B0%E4%B8%8E%E6%95%85%E9%9A%9C%E5%A4%84%E7%90%86/%E6%80%A7%E8%83%BD%E8%AF%84%E4%BC%B0/%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/fio-#-%E7%A3%81%E7%9B%98%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/fio-%23-%E7%A3%81%E7%9B%98%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>项目地址：&lt;a href="https://github.com/axboe/fio">https://github.com/axboe/fio&lt;/a>
官方文档：&lt;a href="https://fio.readthedocs.io/en/latest/">https://fio.readthedocs.io/en/latest/&lt;/a>&lt;/p>
&lt;/blockquote>
&lt;p>注意：！！当使用 fio 的 filename 参数指定某个要测试的裸设备（硬盘或分区），切勿在系统分区做测试，会破坏系统分区，从而导致系统崩溃。若一定要测试系统分区较为安全的方法是：在根目录下创建一个空目录，在测试命令中使用 directory 参数指定该目录，而不使用 filename 参数。现在假设 /dev/vda3 设备挂载在 / 目录下，那么不要执行 fil &amp;ndash;filename=/dev/vda 这种操作！！&lt;/p>
&lt;h2 id="1-性能的基本概念">1 性能的基本概念&lt;/h2>
&lt;h3 id="11-什么是一个-io">1.1 什么是一个 IO&lt;/h3>
&lt;p>IO 即 Input 和 Output，可以分为读 IO 和写 IO。读 IO，就是发指令，从磁盘读取某段扇区的内容。指令一般是通知磁盘开始扇区的位置，然后给出需要从这个初始扇区往后读取的连续扇区个数，同时给出的动作是读，还是写。磁盘收到这条指令，就会按照指令的要求，读或者写数据。控制器发出的这种指令+数据，就是一次 IO，读或者写。&lt;/p>
&lt;h3 id="12-顺序-io-和随机-io">1.2 顺序 IO 和随机 IO&lt;/h3>
&lt;p>顺序和随机，可以简单地理解为本次 IO 给出的初始扇区地址，和上一次 IO 的结束扇区地址，是否是按顺序的，如果相差很大，就算一次随机 IO。&lt;/p>
&lt;h3 id="13-io-大小">1.3 IO 大小&lt;/h3>
&lt;p>一次 IO 需要读或者写的数据块大小。&lt;/p>
&lt;h3 id="14-带宽">1.4 带宽&lt;/h3>
&lt;p>每秒读出或写入的数据量。常用单位包括 KB/s、MB/s、GB/s 等。&lt;/p>
&lt;h3 id="15-延时">1.5 延时&lt;/h3>
&lt;p>客户端发出 IO 请求直到收到请求并响应是需要一段时间的，这段时间就是 IO 延时。IO 延 时一般都是毫秒级的。随着 IO 压力的增大，IO 延时也会随之增大。对于存储来说，由于写 是前台操作，而读是后台操作，因此通常写的 IO 延时要低于读。相同 IO 模型下，IO 延时越小，存储性能越好。一般，IO 延时如果超过 30ms 就说明存储已经比较吃力了。&lt;/p>
&lt;h3 id="16-iops">1.6 IOPS&lt;/h3>
&lt;p>每秒收到的 IO 响应数。读写比例、队列深度、随机度和块大小描述了 IO 模型。在这个模型下，每个 IO 的延时最终体现了 IO 性能。IOPS 和 带宽从两个不同的方面反映了存储性能。&lt;/p>
&lt;h3 id="17-队列深度">1.7 队列深度&lt;/h3>
&lt;p>IO 队列使得 IO 可以并行处理，为何要对磁盘 IO 进行并行处理呢？主要目的是提高磁盘处理 IO 的效率。这一点对于多物理磁盘组成的虚拟磁盘（或 LUN）显得尤为重要。如果 一次提交一个 IO，虽然响应时间较短，但系统的带宽很小。相比较而言，一次提交多个 IO 既缩短了磁头移动距离（通过电梯算法），同时也能够提升 IOPS。&lt;/p>
&lt;h2 id="fio-的工作方式">fio 的工作方式&lt;/h2>
&lt;p>想要运行 fio 可以通过两种方式&lt;/p>
&lt;ol>
&lt;li>给定一个或多个 job files&lt;/li>
&lt;li>直接使用命令行参数&lt;/li>
&lt;/ol>
&lt;p>如果 job file 中仅包含一个作业，则最好只在命令行中提供参数。命令行参数与作业参数相同，还有一些额外的参数可控制全局参数。这里面提到的 job file 中的擦书，其实也可以理解为指令、关键字、字段等等。就是一个配置文件中用来描述程序运行行为的东西。&lt;/p>
&lt;ol>
&lt;li>例如，对于 job files 中的参数 iodepth = 2，在命令行选项为&amp;ndash;iodepth 2 或&amp;ndash;iodepth = 2。&lt;/li>
&lt;li>还可以使用命令行来提供多个作业条目。对于 fio 看到的每个&amp;ndash;name 选项，它将使用该名称开始一个新作业。 &amp;ndash;name 条目之后的命令行条目将应用于该作业，直到没有更多的条目或看到新的&amp;ndash;name 条目为止。这类似于作业文件选项，其中每个选项都适用于当前作业，直到看到新的 [] 作业条目为止。&lt;/li>
&lt;/ol>
&lt;p>开始模拟 I/O 工作负载的第一步，是编写一个描述特定配置的 job file。作业文件可以包含任何数量的线程和/或文件-作业文件的典型内容是定义共享参数的全局部分，以及一个或多个描述所涉及作业的作业部分。运行时，fio 会分析该文件并按照说明进行所有设置。如果我们从上到下分解一个 job ，它包含以下基本参数：&lt;/p>
&lt;ol>
&lt;li>I/O type # 定义发布给文件的 I / O 模式。我们可能只从该文件中顺序读取，或者我们可能在随机写入。甚至顺序或随机混合读写。我们应该执行缓冲 I / O 还是直接/原始 I / O？&lt;/li>
&lt;li>Block size # 指定模拟 I/O 数据流时，每次 I/O 的块大小。可以是单个值，也可以描述块大小的范围。&lt;/li>
&lt;li>I/O size # 指定本次 job 将要读取或写入多少数据&lt;/li>
&lt;li>I/O engine # 定义如何向文件发出 I/O。我们可以使用内存映射文件，可以使用常规读/写，可以使用拼接，异步 I / O 甚至是 SG（SCSI 通用 sg）&lt;/li>
&lt;li>I/O depth # 定义在 I/O engine 是异步的时，我们要保持多大的队列深度&lt;/li>
&lt;li>Target file/device # How many files are we spreading the workload over.&lt;/li>
&lt;li>Threads, processes and job synchronization # How many threads or processes should we spread this workload over.&lt;/li>
&lt;/ol>
&lt;h1 id="job-file-格式">Job File 格式&lt;/h1>
&lt;p>Job file 参数详见：fio 参数详解&lt;/p>
&lt;p>如前所述，fio 接受一个或多个描述该操作的作业文件。作业文件格式是经典的 ini 文件，其中[]括号中的名称定义了作业名称。您可以随意使用任何所需的 ASCII 名称，但具有特殊含义的 global 除外。作业名称后面是零个或多个参数的序列，每行一个，用于定义作业的行为。如果一行中的第一个字符是“;”或“＃”，则整行都将作为注释被丢弃。&lt;/p>
&lt;p>全局部分为该文件中描述的作业设置默认值。作业可以覆盖全局节参数，并且如果需要的话，作业文件甚至可以具有多个全局节。作业仅受位于其上方的全局部分影响。&lt;/p>
&lt;p>因此，让我们看一个非常简单的作业文件，该文件定义了两个过程，每个过程都随机读取 128MiB 文件：&lt;/p>
&lt;pre>&lt;code>; -- start job file --
[global]
rw=randread
size=128m
[job1]
[job2]
; -- end job file --
&lt;/code>&lt;/pre>
&lt;p>如您所见，作业文件部分本身为空，因为所有描述的参数都是共享的。由于未提供文件名选项，因此，fio 会为每个作业组成一个合适的文件名。在命令行上，此作业如下所示：&lt;/p>
&lt;pre>&lt;code>$ fio --name=global --rw=randread --size=128m --name=job1 --name=job2
&lt;/code>&lt;/pre>
&lt;p>让我们看一个示例，其中有许多进程随机写入文件：&lt;/p>
&lt;pre>&lt;code>; -- start job file --
[random-writers]
ioengine=libaio
iodepth=4
rw=randwrite
bs=32k
direct=0
size=64m
numjobs=4
; -- end job file --
&lt;/code>&lt;/pre>
&lt;p>这里我们没有全局部分，因为我们只定义了一项工作。我们想在这里使用异步 I / O，每个文件的深度为 4。我们还将缓冲区大小增加到 32KiB，并将 numjobs 定义为 4，以分叉 4 个相同的作业。结果是 4 个进程，每个进程随机写入其自己的 64MiB 文件。您可以在命令行上指定参数，而不使用上面的作业文件。对于这种情况，您可以指定：&lt;/p>
&lt;pre>&lt;code>$ fio --name=random-writers --ioengine=libaio --iodepth=4 --rw=randwrite --bs=32k --direct=0 --size=64m --numjobs=4
&lt;/code>&lt;/pre>
&lt;h1 id="fio-命令行工具">fio 命令行工具&lt;/h1>
&lt;h2 id="fio-options-job-options-job-files">fio [OPTIONS] [JOB OPTIONS] [job file(s)]&lt;/h2>
&lt;p>OPTIONS&lt;/p>
&lt;p>JOB OPTIONS&lt;/p>
&lt;ol>
&lt;li>由于 Jobfile 中的参数与命令行选项基本保持一一对应的关系，所以对于 fio 的命令行参数，参考 Job file 参数即可 fio 参数详解&lt;/li>
&lt;/ol>
&lt;p>EXAMPLE&lt;/p>
&lt;ol>
&lt;li>注意，下面两条命令直接对整块磁盘进行写操作，会破坏文件，谨慎操作
&lt;ol>
&lt;li>fio -filename=/dev/vdb1 -direct=1 -iodepth 64 -thread -rw=randwrite -ioengine=libaio -bs=4K -numjobs=8 -runtime=60 -group_reporting -name=test1&lt;/li>
&lt;li>fio -filename=/dev/vdb3 -direct=1 -iodepth 64 -thread -rw=write -ioengine=libaio -bs=512K -numjobs=8 -runtime=60 -group_reporting -name=test2&lt;/li>
&lt;/ol>
&lt;/li>
&lt;li>&lt;strong>fio &amp;ndash;rw=write &amp;ndash;ioengine=sync &amp;ndash;fdatasync=1 &amp;ndash;directory=/var/lib/etcd &amp;ndash;size=22m &amp;ndash;bs=2300 &amp;ndash;name=&amp;ldquo;fioEtcdTest&amp;rdquo; &amp;ndash;time_based &amp;ndash;runtime=2m&lt;/strong>&lt;/li>
&lt;li>&lt;strong>fio &amp;ndash;rw=write &amp;ndash;ioengine=libaio &amp;ndash;iodepth=4 &amp;ndash;direct=1 &amp;ndash;filename=fiotest &amp;ndash;size=2G &amp;ndash;bs=4k &amp;ndash;name=&amp;ldquo;Max throughput&amp;rdquo; &amp;ndash;time_based &amp;ndash;runtime=60&lt;/strong>&lt;/li>
&lt;/ol>
&lt;h2 id="结果分析">结果分析&lt;/h2>
&lt;p>官方文档：&lt;a href="https://fio.readthedocs.io/en/latest/fio_doc.html#interpreting-the-output">https://fio.readthedocs.io/en/latest/fio_doc.html#interpreting-the-output&lt;/a>&lt;/p>
&lt;p>使用 fio -ioengine=libaio -bs=4k -direct=1 -thread -rw=write -size=2G -filename=test -name=&amp;ldquo;Max throughput&amp;rdquo; -iodepth=4 -runtime=60 命令得到如下结果&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># 前面几行是命令运行时，实时显示的信息&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># 名为 Max throughput 的 Job 基本信息&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Max throughput: &lt;span style="color:#f92672">(&lt;/span>g&lt;span style="color:#f92672">=&lt;/span>0&lt;span style="color:#f92672">)&lt;/span>: rw&lt;span style="color:#f92672">=&lt;/span>write, bs&lt;span style="color:#f92672">=(&lt;/span>R&lt;span style="color:#f92672">)&lt;/span> 4096B-4096B, &lt;span style="color:#f92672">(&lt;/span>W&lt;span style="color:#f92672">)&lt;/span> 4096B-4096B, &lt;span style="color:#f92672">(&lt;/span>T&lt;span style="color:#f92672">)&lt;/span> 4096B-4096B, ioengine&lt;span style="color:#f92672">=&lt;/span>libaio, iodepth&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">4&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>fio-3.7
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e"># fio 版本号&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Starting &lt;span style="color:#ae81ff">1&lt;/span> thread
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e"># 本次此时启动了 1 个线程&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># 1 表示运行的IO线程数；[W(1)] 表示使用的模式；[100.0%] 表示当前命令的执行进度；[r=0KiB/s,w=137MiB/s] 表示瞬时吞吐率；&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># [r=0,w=35.0k IOPS] 表示 IOPS 瞬时值；[eta 00m:00s] 表示持续时间&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># 该行内容在命令执行期间，可以看到值在实时变化&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Jobs: &lt;span style="color:#ae81ff">1&lt;/span> &lt;span style="color:#f92672">(&lt;/span>f&lt;span style="color:#f92672">=&lt;/span>1&lt;span style="color:#f92672">)&lt;/span>: &lt;span style="color:#f92672">[&lt;/span>W&lt;span style="color:#f92672">(&lt;/span>1&lt;span style="color:#f92672">)][&lt;/span>100.0%&lt;span style="color:#f92672">][&lt;/span>r&lt;span style="color:#f92672">=&lt;/span>0KiB/s,w&lt;span style="color:#f92672">=&lt;/span>137MiB/s&lt;span style="color:#f92672">][&lt;/span>r&lt;span style="color:#f92672">=&lt;/span>0,w&lt;span style="color:#f92672">=&lt;/span>35.0k IOPS&lt;span style="color:#f92672">][&lt;/span>eta 00m:00s&lt;span style="color:#f92672">]&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># 从本行开始为命令执行完成后每个 Job 的统计信息。&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># Job名称：(当前的GID,Job个数)：错误个数：本次Job的PID，本次Job的结束时间&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Max throughput: &lt;span style="color:#f92672">(&lt;/span>groupid&lt;span style="color:#f92672">=&lt;/span>0, jobs&lt;span style="color:#f92672">=&lt;/span>1&lt;span style="color:#f92672">)&lt;/span>: err&lt;span style="color:#f92672">=&lt;/span> 0: pid&lt;span style="color:#f92672">=&lt;/span>7767: Thu Nov &lt;span style="color:#ae81ff">12&lt;/span> 16:09:04 &lt;span style="color:#ae81ff">2020&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># 本次Job的测试模式(这里是写入)，IOPS平均值，带宽平均值，(带宽最大值)(数据总量/运行总时间)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># BW 是 BandWidth 的缩写。2048MiB 就是指的 -size 参数指定的 大小，是本次测试读/写的数据总量&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> write: IOPS&lt;span style="color:#f92672">=&lt;/span>34.3k, BW&lt;span style="color:#f92672">=&lt;/span>134MiB/s &lt;span style="color:#f92672">(&lt;/span>140MB/s&lt;span style="color:#f92672">)(&lt;/span>2048MiB/15289msec&lt;span style="color:#f92672">)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># latency(延迟)相关信息。(单位是：微妙)。注意后面信息括号中的单位会改变，fio 会根据本次测试结果得出的时间，合理给出一个单位。msec毫秒，usec微秒，nsec纳秒&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># slat 是 Submission latency(提交延迟)，就是提交到实际执行 I/O 的时间&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> slat &lt;span style="color:#f92672">(&lt;/span>usec&lt;span style="color:#f92672">)&lt;/span>: min&lt;span style="color:#f92672">=&lt;/span>3, max&lt;span style="color:#f92672">=&lt;/span>6347, avg&lt;span style="color:#f92672">=&lt;/span> 6.09, stdev&lt;span style="color:#f92672">=&lt;/span>12.68
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># clat 是 Completion latency(完成延迟)，就是从提交到完成的时间&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> clat &lt;span style="color:#f92672">(&lt;/span>usec&lt;span style="color:#f92672">)&lt;/span>: min&lt;span style="color:#f92672">=&lt;/span>57, max&lt;span style="color:#f92672">=&lt;/span>74949, avg&lt;span style="color:#f92672">=&lt;/span>108.13, stdev&lt;span style="color:#f92672">=&lt;/span>230.83
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># lat 是 Total latency(总延迟)，就是 fio 从创建这个 I/O 单元到完成的总时间&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> lat &lt;span style="color:#f92672">(&lt;/span>usec&lt;span style="color:#f92672">)&lt;/span>: min&lt;span style="color:#f92672">=&lt;/span>63, max&lt;span style="color:#f92672">=&lt;/span>74954, avg&lt;span style="color:#f92672">=&lt;/span>114.80, stdev&lt;span style="color:#f92672">=&lt;/span>231.22
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># 完成延迟的百分位数(单位是：微妙)，比如99.00th=[ 149] 表示这组样本的 99 百分位的延迟的值为 149&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> clat percentiles &lt;span style="color:#f92672">(&lt;/span>usec&lt;span style="color:#f92672">)&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> | 1.00th&lt;span style="color:#f92672">=[&lt;/span> 86&lt;span style="color:#f92672">]&lt;/span>, 5.00th&lt;span style="color:#f92672">=[&lt;/span> 92&lt;span style="color:#f92672">]&lt;/span>, 10.00th&lt;span style="color:#f92672">=[&lt;/span> 94&lt;span style="color:#f92672">]&lt;/span>, 20.00th&lt;span style="color:#f92672">=[&lt;/span> 97&lt;span style="color:#f92672">]&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> | 30.00th&lt;span style="color:#f92672">=[&lt;/span> 99&lt;span style="color:#f92672">]&lt;/span>, 40.00th&lt;span style="color:#f92672">=[&lt;/span> 101&lt;span style="color:#f92672">]&lt;/span>, 50.00th&lt;span style="color:#f92672">=[&lt;/span> 103&lt;span style="color:#f92672">]&lt;/span>, 60.00th&lt;span style="color:#f92672">=[&lt;/span> 106&lt;span style="color:#f92672">]&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> | 70.00th&lt;span style="color:#f92672">=[&lt;/span> 109&lt;span style="color:#f92672">]&lt;/span>, 80.00th&lt;span style="color:#f92672">=[&lt;/span> 113&lt;span style="color:#f92672">]&lt;/span>, 90.00th&lt;span style="color:#f92672">=[&lt;/span> 119&lt;span style="color:#f92672">]&lt;/span>, 95.00th&lt;span style="color:#f92672">=[&lt;/span> 125&lt;span style="color:#f92672">]&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> | 99.00th&lt;span style="color:#f92672">=[&lt;/span> 149&lt;span style="color:#f92672">]&lt;/span>, 99.50th&lt;span style="color:#f92672">=[&lt;/span> 192&lt;span style="color:#f92672">]&lt;/span>, 99.90th&lt;span style="color:#f92672">=[&lt;/span> 330&lt;span style="color:#f92672">]&lt;/span>, 99.95th&lt;span style="color:#f92672">=[&lt;/span> 988&lt;span style="color:#f92672">]&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> | 99.99th&lt;span style="color:#f92672">=[&lt;/span> 5276&lt;span style="color:#f92672">]&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># 基于一组样本的带宽信息(单位是 KiB/s):最小值，最大值，该线程在其组中接收的总聚合带宽的大约百分比，平均值，标准偏差，本次采样的样本总数&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> bw &lt;span style="color:#f92672">(&lt;/span> KiB/s&lt;span style="color:#f92672">)&lt;/span>: min&lt;span style="color:#f92672">=&lt;/span>113928, max&lt;span style="color:#f92672">=&lt;/span>149024, per&lt;span style="color:#f92672">=&lt;/span>99.98%, avg&lt;span style="color:#f92672">=&lt;/span>137137.07, stdev&lt;span style="color:#f92672">=&lt;/span>7370.84, samples&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">30&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># 基于一组样本的IOPS信息，与 bw 一样&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> iops : min&lt;span style="color:#f92672">=&lt;/span>28482, max&lt;span style="color:#f92672">=&lt;/span>37256, avg&lt;span style="color:#f92672">=&lt;/span>34284.27, stdev&lt;span style="color:#f92672">=&lt;/span>1842.71, samples&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">30&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># I/O 完成延迟的分布，这里的信息适用于一组报告的所有 I/O&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># 500=0.27% 表示 0.27% 的 I/O 在 500 微妙以内完成&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> lat &lt;span style="color:#f92672">(&lt;/span>usec&lt;span style="color:#f92672">)&lt;/span> : 100&lt;span style="color:#f92672">=&lt;/span>34.55%, 250&lt;span style="color:#f92672">=&lt;/span>65.12%, 500&lt;span style="color:#f92672">=&lt;/span>0.27%, 750&lt;span style="color:#f92672">=&lt;/span>0.01%, 1000&lt;span style="color:#f92672">=&lt;/span>0.01%
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> lat &lt;span style="color:#f92672">(&lt;/span>msec&lt;span style="color:#f92672">)&lt;/span> : 2&lt;span style="color:#f92672">=&lt;/span>0.01%, 4&lt;span style="color:#f92672">=&lt;/span>0.02%, 10&lt;span style="color:#f92672">=&lt;/span>0.02%, 20&lt;span style="color:#f92672">=&lt;/span>0.01%, 100&lt;span style="color:#f92672">=&lt;/span>0.01%
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># cpu 使用率&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> cpu : usr&lt;span style="color:#f92672">=&lt;/span>10.24%, sys&lt;span style="color:#f92672">=&lt;/span>23.20%, ctx&lt;span style="color:#f92672">=&lt;/span>189677, majf&lt;span style="color:#f92672">=&lt;/span>0, minf&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># IO 深度在整个工作周期中分布&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> IO depths : 1&lt;span style="color:#f92672">=&lt;/span>0.1%, 2&lt;span style="color:#f92672">=&lt;/span>0.1%, 4&lt;span style="color:#f92672">=&lt;/span>100.0%, 8&lt;span style="color:#f92672">=&lt;/span>0.0%, 16&lt;span style="color:#f92672">=&lt;/span>0.0%, 32&lt;span style="color:#f92672">=&lt;/span>0.0%, &amp;gt;&lt;span style="color:#f92672">=&lt;/span>64&lt;span style="color:#f92672">=&lt;/span>0.0%
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># 一个提交调用中要提交多少IO&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> submit : 0&lt;span style="color:#f92672">=&lt;/span>0.0%, 4&lt;span style="color:#f92672">=&lt;/span>100.0%, 8&lt;span style="color:#f92672">=&lt;/span>0.0%, 16&lt;span style="color:#f92672">=&lt;/span>0.0%, 32&lt;span style="color:#f92672">=&lt;/span>0.0%, 64&lt;span style="color:#f92672">=&lt;/span>0.0%, &amp;gt;&lt;span style="color:#f92672">=&lt;/span>64&lt;span style="color:#f92672">=&lt;/span>0.0%
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># 一个完成调用中要完成多少IO&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> complete : 0&lt;span style="color:#f92672">=&lt;/span>0.0%, 4&lt;span style="color:#f92672">=&lt;/span>100.0%, 8&lt;span style="color:#f92672">=&lt;/span>0.0%, 16&lt;span style="color:#f92672">=&lt;/span>0.0%, 32&lt;span style="color:#f92672">=&lt;/span>0.0%, 64&lt;span style="color:#f92672">=&lt;/span>0.0%, &amp;gt;&lt;span style="color:#f92672">=&lt;/span>64&lt;span style="color:#f92672">=&lt;/span>0.0%
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># 发出的读取/写入/修剪请求的数量，以及其中有多少个请求被缩短或丢弃。&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> issued rwts: total&lt;span style="color:#f92672">=&lt;/span>0,524288,0,0 short&lt;span style="color:#f92672">=&lt;/span>0,0,0,0 dropped&lt;span style="color:#f92672">=&lt;/span>0,0,0,0
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> latency : target&lt;span style="color:#f92672">=&lt;/span>0, window&lt;span style="color:#f92672">=&lt;/span>0, percentile&lt;span style="color:#f92672">=&lt;/span>100.00%, depth&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">4&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># 在上面将所有 Job 的统计信息都列出来之后，这下面显示所有 Job 最终的统计信息。这些数据是所有 Job 的平均值。&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Run status group &lt;span style="color:#ae81ff">0&lt;/span> &lt;span style="color:#f92672">(&lt;/span>all jobs&lt;span style="color:#f92672">)&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># 本次测试的模式(写测试)：带宽平均值，带宽最小值-带宽最大值，io(i.e.读写数据的总量)，运行时间&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># 括号外的值是2的幂的格式，括号中的值是10的幂的等效值&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> WRITE: bw&lt;span style="color:#f92672">=&lt;/span>134MiB/s &lt;span style="color:#f92672">(&lt;/span>140MB/s&lt;span style="color:#f92672">)&lt;/span>, 134MiB/s-134MiB/s &lt;span style="color:#f92672">(&lt;/span>140MB/s-140MB/s&lt;span style="color:#f92672">)&lt;/span>, io&lt;span style="color:#f92672">=&lt;/span>2048MiB &lt;span style="color:#f92672">(&lt;/span>2147MB&lt;span style="color:#f92672">)&lt;/span>, run&lt;span style="color:#f92672">=&lt;/span>15289-15289msec
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># 当前测试数据所在磁盘的统计信息&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># ios 表示所有组执行的 I/O 数，ios就是 I/Os。&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># merge 表示 I/O 调度程序执行的合并数。&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># ticks 表示我们保持磁盘活跃的 ticks 数。&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># in_queue 表示在磁盘队列中花费的总时间&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># util 表示磁盘利用率。在命令执行期间 100％表示我们使磁盘一直处于繁忙状态，而50％的磁盘将有一半的时间处于空闲状态&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># aggr 前缀的信息官方没有说明,应该是聚合的意思&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Disk stats &lt;span style="color:#f92672">(&lt;/span>read/write&lt;span style="color:#f92672">)&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> dm-0: ios&lt;span style="color:#f92672">=&lt;/span>0/519394, merge&lt;span style="color:#f92672">=&lt;/span>0/0, ticks&lt;span style="color:#f92672">=&lt;/span>0/47273, in_queue&lt;span style="color:#f92672">=&lt;/span>47273, util&lt;span style="color:#f92672">=&lt;/span>97.70%, aggrios&lt;span style="color:#f92672">=&lt;/span>0/524290, aggrmerge&lt;span style="color:#f92672">=&lt;/span>0/0, aggrticks&lt;span style="color:#f92672">=&lt;/span>0/48534, aggrin_queue&lt;span style="color:#f92672">=&lt;/span>1310, aggrutil&lt;span style="color:#f92672">=&lt;/span>97.56%
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> vda: ios&lt;span style="color:#f92672">=&lt;/span>0/524290, merge&lt;span style="color:#f92672">=&lt;/span>0/0, ticks&lt;span style="color:#f92672">=&lt;/span>0/48534, in_queue&lt;span style="color:#f92672">=&lt;/span>1310, util&lt;span style="color:#f92672">=&lt;/span>97.56%
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>可以看到，在一个非常强悍的 Optane 盘上面，使用 sync engine，每次都 sync 写盘，性能还是很差的，吞吐不到 300 MB，其他的盘可能就更差了。我们主要关注几个指标：&lt;/p>
&lt;p>slat/clat/lat：这几个是 latency 指标，slat 就是 Submission latency，也就是提交到实际执行 I/O 的时间，在 sync 测试里面这个是没有的，因为 slat 就是 clat。clat 就是 Completion latency，也就是从提交到完成的时间。lat 就是 Total latency，包括 fio 从创建这个 I/O 单元到完成的总的时间。&lt;/p>
&lt;p>另外需要关注的指标就是 BW，和 IOPS，这两这个很直观了，就不解释了。最下面是 ios，也就是总的 I/O 操作次数，merge 就是被 I/O 调度合并的次数，ticks 就是让磁盘保持忙碌的次数，in_queue 就是总的在磁盘队列里面的耗时，而 util 则是磁盘的利用率。&lt;/p>
&lt;h2 id="其他测试命令">其他测试命令&lt;/h2>
&lt;p>fio &amp;ndash;filename=/dev/vdb -direct=1 -bs=1M -rw=randwrite -ioengine=libaio -size=50g -numjobs=32 -iodepth=32  -group_reporting -name=mytest -thread &amp;ndash;time_based &amp;ndash;runtime=120&lt;/p>
&lt;p>&lt;a href="https://mp.weixin.qq.com/s/zpkheD6Izn0RsipSukHA5Q">https://mp.weixin.qq.com/s/zpkheD6Izn0RsipSukHA5Q&lt;/a>&lt;/p></description></item><item><title>Docs: fio 参数详解</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/x.linux-%E7%AE%A1%E7%90%86/%E6%80%A7%E8%83%BD%E8%AF%84%E4%BC%B0%E4%B8%8E%E6%95%85%E9%9A%9C%E5%A4%84%E7%90%86/%E6%80%A7%E8%83%BD%E8%AF%84%E4%BC%B0/%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/fio-#-%E7%A3%81%E7%9B%98%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/fio-%E5%8F%82%E6%95%B0%E8%AF%A6%E8%A7%A3/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/x.linux-%E7%AE%A1%E7%90%86/%E6%80%A7%E8%83%BD%E8%AF%84%E4%BC%B0%E4%B8%8E%E6%95%85%E9%9A%9C%E5%A4%84%E7%90%86/%E6%80%A7%E8%83%BD%E8%AF%84%E4%BC%B0/%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/fio-#-%E7%A3%81%E7%9B%98%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/fio-%E5%8F%82%E6%95%B0%E8%AF%A6%E8%A7%A3/</guid><description>
&lt;h1 id="fio-job-file-参数详解">fio Job file 参数详解&lt;/h1>
&lt;p>官方文档：&lt;a href="https://fio.readthedocs.io/en/latest/fio_doc.html#job-file-parameters">https://fio.readthedocs.io/en/latest/fio_doc.html#job-file-parameters&lt;/a>&lt;/p>
&lt;h2 id="参数类型">参数类型：&lt;/h2>
&lt;p>Job file 的参数有多种类型，每种类型的参数的值可用的类型各不相同，比如时间类型的参数的值就需要填写时间相关的值。&lt;/p>
&lt;p>str # 字符串类型。值为字符数字字符序列&lt;/p>
&lt;p>time # 时间类型。值为带时间后缀的整数。时间的默认单位是秒(seconds)。可以指定其他单位： 天(d)、小时(h)、分钟(m)、毫秒(ms 或 msec)、微秒(us 或 usec)。e.g.使用 10m 表示 10 分钟。&lt;/p>
&lt;p>int # 整数类型。整数值，可以包含整数前缀和整数后缀：&lt;/p>
&lt;p>bool # 布尔类型。通常解析为整数，但是仅定义为 true 和 false（1 和 0）&lt;/p>
&lt;p>irange # 范围类型。带后缀的整数范围。允许给出值范围，例如 1024-4096。冒号也可以用作分隔符，例如。 1k：4k。如果该选项允许两组范围，则可以使用“，”或“ /”定界符来指定它们：1k-4k / 8k-32k。另请参见 int.&lt;/p>
&lt;p>float_list # 浮点列表类型。浮点数列表，以&amp;rsquo;：&amp;lsquo;字符分隔。&lt;/p>
&lt;h1 id="描述-job-的相关参数">描述 JOB 的相关参数&lt;/h1>
&lt;p>name=STR # 这可以用来覆盖由 fio 为该作业打印的名称。否则，使用作业名称。在命令行上，此参数的特殊目的还用于发信号通知新作业的开始。&lt;/p>
&lt;h1 id="时间相关参数">时间相关参数&lt;/h1>
&lt;p>官方文档：&lt;a href="https://fio.readthedocs.io/en/latest/fio_doc.html#time-related-parameters">https://fio.readthedocs.io/en/latest/fio_doc.html#time-related-parameters&lt;/a>&lt;/p>
&lt;p>runtime=TIME # 指定 Job 运行的时间(默认单位：秒)。到时间后，不管指定的 size 大小有没有读写完。&lt;/p>
&lt;p>time_based # 如果设置，则 fio 将在 &lt;code>runtime 的值&lt;/code>这个时间内内运行，即使已完全读取或写入文件。它会在运行时允许的情况下简单地循环相同的工作负载。&lt;/p>
&lt;blockquote>
&lt;p>该参数一般配合 runtime 一起使用，单独使用没有效果。&lt;/p>
&lt;/blockquote>
&lt;h1 id="要测试的目标文件设备相关参数">要测试的目标文件/设备相关参数&lt;/h1>
&lt;p>directory=STR # 测试目录。&lt;/p>
&lt;p>filename=STR # 测试文件名称。通常选择需要测试的盘的 data 目录&lt;/p>
&lt;p>注意：！！当使用 fio 的 filename 参数指定某个要测试的裸设备（硬盘或分区），切勿在系统分区做测试，会破坏系统分区，而导致系统崩溃。若一定要测试系统分区较为安全的方法是：在根目录下创建一个空目录，在测试命令中使用 directory 参数指定该目录，而不使用 filename 参数。现在假设 /dev/vda3 设备挂载在 / 目录下，那么不要执行 fil &amp;ndash;filename=/dev/vda 这种操作&lt;/p>
&lt;h1 id="io-type-相关参数">I/O TYPE 相关参数&lt;/h1>
&lt;p>官方文档：&lt;a href="https://fio.readthedocs.io/en/latest/fio_doc.html#i-o-type">https://fio.readthedocs.io/en/latest/fio_doc.html#i-o-type&lt;/a>&lt;/p>
&lt;p>direct=BOOL # 测试过程绕过系统的 buffer。使测试结果更真实。&lt;code>默认值：false&lt;/code>i.e.使用缓存。&lt;/p>
&lt;p>rw=STR # 测试时的 I/O 模式。默认为 read。可用的模式有：&lt;/p>
&lt;ol>
&lt;li>
&lt;p>read # 顺序读&lt;/p>
&lt;/li>
&lt;li>
&lt;p>write # 顺序写&lt;/p>
&lt;/li>
&lt;li>
&lt;p>randread # 随机读&lt;/p>
&lt;/li>
&lt;li>
&lt;p>randwrite # 随机写&lt;/p>
&lt;/li>
&lt;li>
&lt;p>randrw # 随机混合读和写&lt;/p>
&lt;/li>
&lt;li>
&lt;p>等&amp;hellip;..其余模式见官方文档&lt;/p>
&lt;/li>
&lt;/ol>
&lt;p>fdatasync=INT # 与 fsync 类似，但使用 fdatasync(2)只同步数据而不同步元数据块。在 Windows, FreeBSD, DragonFlyBSD 或 OSX 中没有 fdatasync(2)，所以这就回到使用 fsync(2)。默认值为 0，这意味着 fio 不会定期发出问题，并等待数据同步完成。&lt;/p>
&lt;h1 id="block-大小相关参数">Block 大小相关参数&lt;/h1>
&lt;p>官方文档：&lt;a href="https://fio.readthedocs.io/en/latest/fio_doc.html#block-size">https://fio.readthedocs.io/en/latest/fio_doc.html#block-size&lt;/a>&lt;/p>
&lt;p>bs=INT # 单次 I/O 的块文件大小&lt;/p>
&lt;p>bsrange=iRANGE # 与 bs 参数类似，只不过是指定一个块文件大小的范围&lt;/p>
&lt;h1 id="buffers-and-memory-相关参数">Buffers and memory 相关参数&lt;/h1>
&lt;p>zero_buffers # 用 0 初始化系统 buffer&lt;/p>
&lt;h1 id="io-size-相关参数">I/O Size 相关参数&lt;/h1>
&lt;p>size=INT # 本次的测试文件大小为 INT。fio 程序将持续运行，直到传输了 INT 这些数据。&lt;/p>
&lt;h1 id="io-engine引擎-相关参数">I/O engine(引擎) 相关参数&lt;/h1>
&lt;p>ioengine=STR # 告诉 fio 使用什么样的方式去测试 I/O。有如下方式可用：&lt;/p>
&lt;ol>
&lt;li>
&lt;p>sync # 也就是最通常的 read/write 操作。基本的读(2)或写(2)I/O。lseek(2)用于定位 I/O 位置。请参阅 fsync 和 fdatasync 来同步写 I/O。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>psync # 基本的 pread(2)或 pwrite(2) I/O。除 Windows 外，所有支持的操作系统都是默认值。&lt;/p>
&lt;/li>
&lt;/ol>
&lt;blockquote>
&lt;p>pvsync / pvsync2 - 对应的 preadv / pwritev，以及 preadv2 / p writev2&lt;/p>
&lt;/blockquote>
&lt;ol>
&lt;li>
&lt;p>vsync # 使用 readv / writev，主要是会将相邻的 I/O 进行合并&lt;/p>
&lt;/li>
&lt;li>
&lt;p>libaio # Linux 原生的异步 I/O，这也是通常我们这边用的最多的测试盘吞吐和延迟的方法&lt;/p>
&lt;ol>
&lt;li>对于 libaio engine 来说，还需要考虑设置 iodepth&lt;/li>
&lt;/ol>
&lt;/li>
&lt;/ol>
&lt;p>测试多了，就会很悲催的发现，libaio 很容易就把盘给打死，但 sync 这些还需要启动几个线程。。。&lt;/p>
&lt;p>并且对于 fio &amp;ndash;rw=write &amp;ndash;ioengine=XXXX &amp;ndash;filename=fiotest &amp;ndash;direct=1 &amp;ndash;size=2G &amp;ndash;bs=4k &amp;ndash;name=&amp;ldquo;Max throughput&amp;rdquo; &amp;ndash;iodepth=4 命令，sync 引擎测试结果只有 libaio 引擎测试结果的三分之一。&lt;/p>
&lt;h1 id="io-engine引擎-特定参数">I/O engine(引擎) 特定参数&lt;/h1>
&lt;p>官方文档：&lt;a href="https://fio.readthedocs.io/en/latest/fio_doc.html#i-o-engine-specific-parameters">https://fio.readthedocs.io/en/latest/fio_doc.html#i-o-engine-specific-parameters&lt;/a>&lt;/p>
&lt;h1 id="io-depth深度-相关参数">I/O depth(深度) 相关参数&lt;/h1>
&lt;p>官方文档：&lt;a href="https://fio.readthedocs.io/en/latest/fio_doc.html#i-o-depth">https://fio.readthedocs.io/en/latest/fio_doc.html#i-o-depth&lt;/a>&lt;/p>
&lt;p>iodepth=INT # 针对文件保留的 I/O 单元数。 &lt;code>默认值：1&lt;/code>。&lt;/p>
&lt;blockquote>
&lt;p>请注意，将 iodepth 增加到 1 以上不会影响同步 ioengine(使用 verify_async 时的小角度除外)。 甚至异步引擎也可能会施加 OS 限制，从而导致无法实现所需的深度。 在 Linux 上使用 libaio 且未设置 direct = 1 时可能会发生这种情况，因为在该 OS 上缓冲的 I / O 并不异步。 密切注意 fio 输出中的 I / O 深度分布，以验证所达到的深度是否符合预期。&lt;/p>
&lt;/blockquote>
&lt;h1 id="io-rate-相关参数">I/O rate 相关参数&lt;/h1>
&lt;p>官方文档：&lt;a href="https://fio.readthedocs.io/en/latest/fio_doc.html#i-o-rate">https://fio.readthedocs.io/en/latest/fio_doc.html#i-o-rate&lt;/a>&lt;/p>
&lt;h1 id="io-latency">I/O latency&lt;/h1>
&lt;p>官方文档：&lt;a href="https://fio.readthedocs.io/en/latest/fio_doc.html#i-o-latency">https://fio.readthedocs.io/en/latest/fio_doc.html#i-o-latency&lt;/a>&lt;/p>
&lt;h1 id="io-replay">I/O replay&lt;/h1>
&lt;p>官方文档：&lt;a href="https://fio.readthedocs.io/en/latest/fio_doc.html#i-o-replay">https://fio.readthedocs.io/en/latest/fio_doc.html#i-o-replay&lt;/a>&lt;/p>
&lt;h1 id="线程进程job-同步相关参数">线程、进程、Job 同步相关参数&lt;/h1>
&lt;p>官方文档：&lt;a href="https://fio.readthedocs.io/en/latest/fio_doc.html#threads-processes-and-job-synchronization">https://fio.readthedocs.io/en/latest/fio_doc.html#threads-processes-and-job-synchronization&lt;/a>&lt;/p>
&lt;p>thead # 如果指定了此选项，则 fio 将使用 POSIX Threads 的函数 pthread_create(3) 创建线程来创建作业。Fio 默认使用 fork 创建 Job。i.e.使用进程来执行 Job&lt;/p>
&lt;blockquote>
&lt;p>使用 thread 在一定程度上可以节省系统开销&lt;/p>
&lt;/blockquote>
&lt;h1 id="认证参数">认证参数&lt;/h1>
&lt;p>官方文档：&lt;a href="https://fio.readthedocs.io/en/latest/fio_doc.html#verification">https://fio.readthedocs.io/en/latest/fio_doc.html#verification&lt;/a>&lt;/p>
&lt;h1 id="steady-state">Steady state&lt;/h1>
&lt;p>官方文档：&lt;a href="https://fio.readthedocs.io/en/latest/fio_doc.html#steady-state">https://fio.readthedocs.io/en/latest/fio_doc.html#steady-state&lt;/a>&lt;/p>
&lt;h1 id="测量和报告相关参数">测量和报告相关参数&lt;/h1>
&lt;p>官方文档：&lt;a href="https://fio.readthedocs.io/en/latest/fio_doc.html#measurements-and-reporting">https://fio.readthedocs.io/en/latest/fio_doc.html#measurements-and-reporting&lt;/a>&lt;/p>
&lt;h1 id="错误处理相关参数">错误处理相关参数&lt;/h1>
&lt;p>官方文档：&lt;a href="https://fio.readthedocs.io/en/latest/fio_doc.html#error-handling">https://fio.readthedocs.io/en/latest/fio_doc.html#error-handling&lt;/a>&lt;/p>
&lt;p>rwmixwrite=30 # 在混合读写的模式下，写占 30%&lt;/p>
&lt;p>group_reporting # 关于显示结果的，汇总每个进程的信息&lt;/p>
&lt;p>lockmem=1G # 只使用 1g 内存进行测试&lt;/p>
&lt;p>nrfiles=8 # 每个进程生成文件的数量&lt;/p>
&lt;p>numjobs=30 # 本次的测试线程为 30 个&lt;/p></description></item></channel></rss>