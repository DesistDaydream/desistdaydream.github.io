<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>断念梦 – 性能优化 与 故障处理</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/x.linux-%E7%AE%A1%E7%90%86/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E4%B8%8E%E6%95%85%E9%9A%9C%E5%A4%84%E7%90%86/</link><description>Recent content in 性能优化 与 故障处理 on 断念梦</description><generator>Hugo -- gohugo.io</generator><atom:link href="https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/x.linux-%E7%AE%A1%E7%90%86/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E4%B8%8E%E6%95%85%E9%9A%9C%E5%A4%84%E7%90%86/index.xml" rel="self" type="application/rss+xml"/><item><title>Docs: 60,000 毫秒内对 Linux 的性能诊断</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/x.linux-%E7%AE%A1%E7%90%86/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E4%B8%8E%E6%95%85%E9%9A%9C%E5%A4%84%E7%90%86/60000-%E6%AF%AB%E7%A7%92%E5%86%85%E5%AF%B9-linux-%E7%9A%84%E6%80%A7%E8%83%BD%E8%AF%8A%E6%96%AD/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/x.linux-%E7%AE%A1%E7%90%86/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E4%B8%8E%E6%95%85%E9%9A%9C%E5%A4%84%E7%90%86/60000-%E6%AF%AB%E7%A7%92%E5%86%85%E5%AF%B9-linux-%E7%9A%84%E6%80%A7%E8%83%BD%E8%AF%8A%E6%96%AD/</guid><description>
&lt;h3 id="60000-毫秒内对-linux-的性能诊断httpssegmentfaultcoma1190000004104493">&lt;a href="https://segmentfault.com/a/1190000004104493">60,000 毫秒内对 Linux 的性能诊断&lt;/a>&lt;/h3>
&lt;p>&lt;a href="https://netflixtechblog.com/linux-performance-analysis-in-60-000-milliseconds-accc10403c55?gi=cd96c338a83b">英文原文&lt;/a>&lt;/p>
&lt;p>当你为了解决一个性能问题登录到一台 Linux 服务器：在第一分钟你应该检查些什么？&lt;/p>
&lt;p>在 Netflix，我们有一个巨大的 EC2 Linux 云，以及大量的性能分析工具来监控和诊断其性能。其中包括用于云监控的 &lt;a href="http://techblog.netflix.com/2014/12/introducing-atlas-netflixs-primary.html">Atlas&lt;/a>，以及用于按需实例分析的 &lt;a href="http://techblog.netflix.com/2015/04/introducing-vector-netflixs-on-host.html">Vector&lt;/a>。虽然这些工具可以帮助我们解决大多数问题，但我们有时仍需要登录到一个服务器实例，并运行一些标准 Linux 性能工具。&lt;/p>
&lt;p>在这篇文章中，Netflix Performance Engineering 团队将会向你讲解在命令行中进行一次最佳的性能分析的前 60 秒要做的事，使用的是你应该可以得到的标准 Linux 工具。&lt;/p>
&lt;h3 id="前六十秒总览">前六十秒：总览&lt;/h3>
&lt;p>通过运行下面十个命令，你就能在六十秒内粗略地了解系统正在运行的进程及资源使用情况。通过查看这些命令输出的错误信息和资源饱和度（它们都很容易看懂），你可以接下来对资源进行优化。饱和是指某个资源的负载超出了其能够处理的限度。一旦出现饱和，它通常会在请求队列的长度或等待时间上暴露出来。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-json" data-lang="json">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#960050;background-color:#1e0010">uptime&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#960050;background-color:#1e0010">dmesg | tail&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#960050;background-color:#1e0010">vmstat &lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#960050;background-color:#1e0010">mpstat -P ALL &lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#960050;background-color:#1e0010">pidstat &lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#960050;background-color:#1e0010">iostat -xz &lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#960050;background-color:#1e0010">free -m&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#960050;background-color:#1e0010">sar -n DEV &lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#960050;background-color:#1e0010">sar -n TCP,ETCP &lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#960050;background-color:#1e0010">top&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>其中某些命令需要预先安装  sysstat 软件包。这些命令展示出来的信息能够帮你实施&lt;a href="http://www.brendangregg.com/usemethod.html">USE 方法&lt;/a>（一种用于定位性能瓶颈的方法），比如检查各种资源（如 CPU、内存、磁盘等）的使用率、饱和度和错误信息。另外在定位问题的过程中，你可以通过使用这些命令来排除某些导致问题的可能性，帮助你缩小检查范围，为下一步检查指明方向。&lt;/p>
&lt;p>下面的章节将以在一个生产环境上执行这些命令作为例子，简单介绍这些命令。若想详细了解这些工具的使用方法，请参考它们的 man 文档。&lt;/p>
&lt;h3 id="1-uptime">1. uptime&lt;/h3>
&lt;pre>&lt;code>$ uptime
 23:51:26 up 21:31,  1 user,  load average: 30.02, 26.43, 19.02
&lt;/code>&lt;/pre>
&lt;p>这是一种用来快速查看系统平均负载的方法，它表明了系统中有多少要运行的任务（进程）。在 Linux 系统中，这些数字包含了需要在 CPU 中运行的进程以及正在等待 I/O（通常是磁盘 I/O）的进程。它仅仅是对系统负载的一个粗略展示，稍微看下即可。你还需要其他工具来进一步了解具体情况。&lt;/p>
&lt;p>这三个数字展示的是一分钟、五分钟和十五分钟内系统的负载总量平均值按照指数比例压缩得到的结果。从中我们可以看到系统的负载是如何随时间变化的。比方你在检查一个问题，然后看到 1 分钟对应的值远小于 15 分钟的值，那么可能说明这个问题已经过去了，你没能及时观察到。&lt;/p>
&lt;p>在上面这个例子中，系统负载在随着时间增加，因为最近一分钟的负载值超过了 30，而 15 分钟的平均负载则只有 19。这样显著的差距包含了很多含义，比方 CPU 负载。若要进一步确认的话，则要运行 vmstat 或 mpstat 命令，这两个命令请参考后面的第 3 和第 4 章节。&lt;/p>
&lt;h3 id="2-dmesg--tail">2. dmesg | tail&lt;/h3>
&lt;pre>&lt;code>$ dmesg | tail
[1880957.563150] perl invoked oom-killer: gfp_mask=0x280da, order=0, oom_score_adj=0
[...]
[1880957.563400] Out of memory: Kill process 18694 (perl) score 246 or sacrifice child
[1880957.563408] Killed process 18694 (perl) total-vm:1972392kB, anon-rss:1953348kB, file-rss:0kB
[2320864.954447] TCP: Possible SYN flooding on port 7001. Dropping request. Check SNMP counters.
&lt;/code>&lt;/pre>
&lt;p>这条命令显式了最近的 10 条系统消息，如果它们存在的话。查找能够导致性能问题的错误。上面的例子包含了 oom-killer，以及 TCP 丢弃一个请求。&lt;/p>
&lt;p>千万不要错过这一步！dmesg 命令永远值得一试。&lt;/p>
&lt;h3 id="3-vmstat-1">3. vmstat 1&lt;/h3>
&lt;pre>&lt;code>$ vmstat 1procs \---------memory---------- \---swap-- \-----io---- \-system-- \------cpu-----
 r  b swpd   free   buff  cache   si   so    bi    bo   in   cs us sy id wa st
34  0    0 200889792  73708 591828    0    0     0     5    6   10 96  1  3  0  0
32  0    0 200889920  73708 591860    0    0     0   592 13284 4282 98  1  1  0  0
32  0    0 200890112  73708 591860    0    0     0     0 9501 2154 99  1  0  0  0
32  0    0 200889568  73712 591856    0    0     0    48 11900 2459 99  0  0  0  0
32  0    0 200890208  73712 591860    0    0     0     0 15898 4840 98  1  1  0  0
^C
&lt;/code>&lt;/pre>
&lt;p>vmstat(8) 是虚拟内存统计的简称，其是一个常用工具（几十年前为了 BSD 所创建）。其在每行打印一条关键的服务器的统计摘要。&lt;/p>
&lt;p>vmstat 命令指定一个参数 1 运行，来打印每一秒的统计摘要。（这个版本的 vmstat）输出的第一行的那些列，显式的是开机以来的平均值，而不是前一秒的值。现在，我们跳过第一行，除非你想要了解并记住每一列。&lt;/p>
&lt;p>检查这些列：&lt;/p>
&lt;ul>
&lt;li>&lt;strong>r&lt;/strong>：CPU 中正在运行和等待运行的进程的数量。其提供了一个比平均负载更好的信号来确定 CPU 是否饱和，因为其不包含 I/O。解释：“r” 的值大于了 CPU 的数量就表示已经饱和了。&lt;/li>
&lt;li>&lt;strong>free&lt;/strong>：以 kb 为单位显式的空闲内存。如果数字位数很多，说明你有足够的空闲内存。“free -m” 命令，是下面的第七个命令，其可以更好的说明空闲内存的状态。&lt;/li>
&lt;li>&lt;strong>si, so&lt;/strong>：Swap-ins 和 swap-outs。如果它们不是零，则代表你的内存不足了。&lt;/li>
&lt;li>&lt;strong>us, sy, id, wa, st&lt;/strong>：这些都是平均了所有 CPU 的 CPU 分解时间。它们分别是用户时间（user）、系统时间（内核）（system）、空闲（idle）、等待 I/O（wait）、以及占用时间（stolen）（被其他访客，或使用 Xen，访客自己独立的驱动域）。&lt;/li>
&lt;/ul>
&lt;p>CPU 分解时间将会通过用户时间加系统时间确认 CPU 是否为忙碌状态。等待 I/O 的时间一直不变则表明了一个磁盘瓶颈；这就是 CPU 的闲置，因为任务都阻塞在等待挂起磁盘 I/O 上了。你可以把等待 I/O 当成是 CPU 闲置的另一种形式，其给出了为什么 CPU 闲置的一个线索。&lt;/p>
&lt;p>对于 I/O 处理来说，系统时间是很重要的。一个高于 20% 的平均系统时间，可以值得进一步的探讨：也许内核在处理 I/O 时效率太低了。&lt;/p>
&lt;p>在上面的例子中，CPU 时间几乎完全花在了用户级，表明应用程序占用了太多 CPU 时间。而 CPU 的平均使用率也在 90% 以上。这不一定是一个问题；检查一下 “r” 列中的饱和度。&lt;/p>
&lt;h3 id="4-mpstat--p-all-1">4. mpstat -P ALL 1&lt;/h3>
&lt;pre>&lt;code>$ mpstat -P ALL 1
Linux 3.13.0-49-generic (titanclusters-xxxxx) 07/14/2015 _x86_64_ (32 CPU)
07:38:49 PM CPU %usr %nice %sys %iowait %irq %soft %steal %guest %gnice %idle
07:38:50 PM all 98.47 0.00 0.75 0.00 0.00 0.00 0.00 0.00 0.00 0.78
07:38:50 PM 0 96.04 0.00 2.97 0.00 0.00 0.00 0.00 0.00 0.00 0.99
07:38:50 PM 1 97.00 0.00 1.00 0.00 0.00 0.00 0.00 0.00 0.00 2.00
07:38:50 PM 2 98.00 0.00 1.00 0.00 0.00 0.00 0.00 0.00 0.00 1.00
07:38:50 PM 3 96.97 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 3.03
[...]
&lt;/code>&lt;/pre>
&lt;p>这个命令打印每个 CPU 的 CPU 分解时间，其可用于对一个不均衡的使用情况进行检查。一个单独 CPU 很忙碌则代表了正在运行一个单线程的应用程序。&lt;/p>
&lt;h3 id="5-pidstat-1">5. pidstat 1&lt;/h3>
&lt;pre>&lt;code>$ pidstat 1
Linux 3.13.0-49-generic (titanclusters-xxxxx) 07/14/2015 _x86_64_ (32 CPU)
07:41:02 PM UID PID %usr %system %guest %CPU CPU Command
07:41:03 PM 0 9 0.00 0.94 0.00 0.94 1 rcuos/0
07:41:03 PM 0 4214 5.66 5.66 0.00 11.32 15 mesos-slave
07:41:03 PM 0 4354 0.94 0.94 0.00 1.89 8 java
07:41:03 PM 0 6521 1596.23 1.89 0.00 1598.11 27 java
07:41:03 PM 0 6564 1571.70 7.55 0.00 1579.25 28 java
07:41:03 PM 60004 60154 0.94 4.72 0.00 5.66 9 pidstat
07:41:03 PM UID PID %usr %system %guest %CPU CPU Command
07:41:04 PM 0 4214 6.00 2.00 0.00 8.00 15 mesos-slave
07:41:04 PM 0 6521 1590.00 1.00 0.00 1591.00 27 java
07:41:04 PM 0 6564 1573.00 10.00 0.00 1583.00 28 java
07:41:04 PM 108 6718 1.00 0.00 0.00 1.00 0 snmp-pass
07:41:04 PM 60004 60154 1.00 4.00 0.00 5.00 9 pidstat
^C
&lt;/code>&lt;/pre>
&lt;p>pidstat 命令有点像 top 命令对每个进程的统计摘要，但循环打印一个滚动的统计摘要来代替 top 的刷屏。其可用于实时查看，同时也可将你所看到的东西（复制粘贴）到你的调查记录中。&lt;/p>
&lt;p>上面的例子表明两个 Java 进程正在消耗 CPU。%CPU 这列是所有 CPU 合计的；1591% 表示这个 Java 进程消耗了将近 16 个 CPU。&lt;/p>
&lt;h3 id="6-iostat--xz-1">6. iostat -xz 1&lt;/h3>
&lt;pre>&lt;code>$ iostat -xz 1
Linux 3.13.0-49-generic (titanclusters-xxxxx) 07/14/2015 _x86_64_ (32 CPU)
avg-cpu: %user %nice %system %iowait %steal %idle
73.96 0.00 3.73 0.03 0.06 22.21
Device: rrqm/s wrqm/s r/s w/s rkB/s wkB/s avgrq-sz avgqu-sz await r_await w_await svctm %util
xvda 0.00 0.23 0.21 0.18 4.52 2.08 34.37 0.00 9.98 13.80 5.42 2.44 0.09
xvdb 0.01 0.00 1.02 8.94 127.97 598.53 145.79 0.00 0.43 1.78 0.28 0.25 0.25
xvdc 0.01 0.00 1.02 8.86 127.79 595.94 146.50 0.00 0.45 1.82 0.30 0.27 0.26
dm-0 0.00 0.00 0.69 2.32 10.47 31.69 28.01 0.01 3.23 0.71 3.98 0.13 0.04
dm-1 0.00 0.00 0.00 0.94 0.01 3.78 8.00 0.33 345.84 0.04 346.81 0.01 0.00
dm-2 0.00 0.00 0.09 0.07 1.35 0.36 22.50 0.00 2.55 0.23 5.62 1.78 0.03
[...]
^C
&lt;/code>&lt;/pre>
&lt;p>这是用于查看块设备（磁盘）情况的一个很棒的工具，无论是对工作负载还是性能表现来说。查看个列：&lt;/p>
&lt;ul>
&lt;li>&lt;strong>r/s, w/s, rkB/s, wkB/s&lt;/strong>：这些分别代表该设备每秒的读次数、写次数、读取 kb 数，和写入 kb 数。这些用于描述工作负载。性能问题可能仅仅是由于施加了过大的负载。&lt;/li>
&lt;li>&lt;strong>await&lt;/strong>：以毫秒为单位的 I/O 平均消耗时间。这是应用程序消耗的实际时间，因为它包括了排队时间和处理时间。比预期更大的平均时间可能意味着设备的饱和，或设备出了问题。&lt;/li>
&lt;li>&lt;strong>avgqu-sz&lt;/strong>：向设备发出的请求的平均数量。值大于 1 说明已经饱和了（虽说设备可以并行处理请求，尤其是由多个磁盘组成的虚拟设备。）&lt;/li>
&lt;li>&lt;strong>%util&lt;/strong>：设备利用率。这个值是一个显示出该设备在工作时每秒处于忙碌状态的百分比。若值大于 60％，通常表明性能不佳（可以从 await 中看出），虽然它取决于设备本身。值接近   100% 通常意味着已饱和。&lt;/li>
&lt;/ul>
&lt;p>如果该存储设备是一个面向很多后端磁盘的逻辑磁盘设备，则 100% 利用率可能只是意味着当前正在处理某些 I/O 占用，然而，后端磁盘可能远未饱和，并且可能能够处理更多的工作。&lt;/p>
&lt;p>请记住，磁盘 I/O 性能较差不一定是程序的问题。许多技术通常是异步 I/O，使应用程序不会被阻塞并遭受延迟（例如，预读，以及写缓冲）。&lt;/p>
&lt;h3 id="7-free--m">7. free -m&lt;/h3>
&lt;pre>&lt;code>$ free -m
total used free shared buffers cached
Mem: 245998 24545 221453 83 59 541
-/+ buffers/cache: 23944 222053
Swap: 0 0 0
&lt;/code>&lt;/pre>
&lt;p>右边的两列显式：&lt;/p>
&lt;ul>
&lt;li>&lt;strong>buffers&lt;/strong>：用于块设备 I/O 的缓冲区缓存。&lt;/li>
&lt;li>&lt;strong>cached&lt;/strong>：用于文件系统的页面缓存。&lt;/li>
&lt;/ul>
&lt;p>我们只是想要检查这些不接近零的大小，其可能会导致更高磁盘 I/O（使用 iostat 确认），和更糟糕的性能。上面的例子看起来还不错，每一列均有很多 M 个大小。&lt;/p>
&lt;p>比起第一行，-/+ buffers/cache 提供的内存使用量会更加准确些。Linux 会把暂时用不上的内存用作缓存，一旦应用需要的时候就立刻重新分配给它。所以部分被用作缓存的内存其实也算是空闲的内存。为了解释这一点， 甚至有人专门建了个网站： &lt;a href="http://www.linuxatemyram.com/">linuxatemyram&lt;/a>。&lt;/p>
&lt;p>如果你在 Linux 上安装了 ZFS，这一点会变得更加困惑，因为 ZFS 它自己的文件系统缓存不算入 free -m。有时候发现系统已经没有多少空闲内存可用了，其实内存却都待在 ZFS 的缓存里。&lt;/p>
&lt;h3 id="8-sar--n-dev-1">8. sar -n DEV 1&lt;/h3>
&lt;pre>&lt;code>$ sar \-n DEV 1
Linux 3.13.0\-49\-generic (titanclusters-xxxxx)  07/14/2015     \_x86\_64\_    (32 CPU)
12:16:48 AM     IFACE   rxpck/s   txpck/s    rxkB/s    txkB/s   rxcmp/s   txcmp/s  rxmcst/s   %ifutil
12:16:49 AM      eth0  18763.00   5032.00  20686.42    478.30      0.00      0.00      0.00      0.00
12:16:49 AM        lo     14.00     14.00      1.36      1.36      0.00      0.00      0.00      0.00
12:16:49 AM   docker0      0.00      0.00      0.00      0.00      0.00      0.00      0.00      0.00
12:16:49 AM     IFACE   rxpck/s   txpck/s    rxkB/s    txkB/s   rxcmp/s   txcmp/s  rxmcst/s   %ifutil
12:16:50 AM      eth0  19763.00   5101.00  21999.10    482.56      0.00      0.00      0.00      0.00
12:16:50 AM        lo     20.00     20.00      3.25      3.25      0.00      0.00      0.00      0.00
12:16:50 AM   docker0      0.00      0.00      0.00      0.00      0.00      0.00      0.00      0.00
^C
&lt;/code>&lt;/pre>
&lt;p>这个工具可以被用来检查网络接口的吞吐量：rxkB/s 和 txkB/s，以及是否达到限额。上面的例子中，eth0 接收的流量达到 22Mbytes/s，也即 176Mbits/sec（限额是 1Gbit/sec）&lt;/p>
&lt;p>我们用的版本中还提供了 %ifutil 作为设备使用率（接收和发送的最大值）的指标。我们也可以用 Brendan 的 &lt;a href="https://github.com/scotte/nicstat">nicstat 工具&lt;/a>计量这个值。一如 nicstat，sar 显示的这个值是很难精确取得的，在这个例子里面，它就没在正常的工作（0.00）。&lt;/p>
&lt;h3 id="9-sar--n-tcpetcp-1">9. sar -n TCP,ETCP 1&lt;/h3>
&lt;pre>&lt;code>$ sar -n TCP,ETCP 1
Linux 3.13.0-49-generic (titanclusters-xxxxx) 07/14/2015 _x86_64_ (32 CPU)
12:17:19 AM active/s passive/s iseg/s oseg/s
12:17:20 AM 1.00 0.00 10233.00 18846.00
12:17:19 AM atmptf/s estres/s retrans/s isegerr/s orsts/s
12:17:20 AM 0.00 0.00 0.00 0.00 0.00
12:17:20 AM active/s passive/s iseg/s oseg/s
12:17:21 AM 1.00 0.00 8359.00 6039.00
12:17:20 AM atmptf/s estres/s retrans/s isegerr/s orsts/s
12:17:21 AM 0.00 0.00 0.00 0.00 0.00
^C
&lt;/code>&lt;/pre>
&lt;p>这是一些关键的 TCP 指标的汇总视图。这些包括：&lt;/p>
&lt;ul>
&lt;li>&lt;strong>active/s&lt;/strong>：每秒本地发起 TCP 连接数（例如，通过 connect()）。&lt;/li>
&lt;li>&lt;strong>passive/s&lt;/strong>：每秒远程发起的 TCP 连接数（例如，通过 accept()）。&lt;/li>
&lt;li>&lt;strong>retrans/s&lt;/strong>：每秒重传 TCP 次数。&lt;/li>
&lt;/ul>
&lt;p>active 和 passive 的连接数往往对于描述一个粗略衡量服务器负载是非常有用的：新接受的连接数（passive），下行连接数（active）。可以理解为 active 连接是对外的，而 passive 连接是对内的，虽然严格来说并不完全正确（例如，一个 localhost 到 localhost 的连接）。&lt;/p>
&lt;p>重传是出现一个网络和服务器问题的一个征兆。其可能是由于一个不可靠的网络（例如，公网）造成的，或许也有可能是由于服务器过载并丢包。上面的例子显示了每秒只有一个新的 TCP 连接。&lt;/p>
&lt;h3 id="10-top">10. top&lt;/h3>
&lt;pre>&lt;code>$ top
top - 00:15:40 up 21:56, 1 user, load average: 31.09, 29.87, 29.92
Tasks: 871 total, 1 running, 868 sleeping, 0 stopped, 2 zombie
%Cpu(s): 96.8 us, 0.4 sy, 0.0 ni, 2.7 id, 0.1 wa, 0.0 hi, 0.0 si, 0.0 st
KiB Mem: 25190241+total, 24921688 used, 22698073+free, 60448 buffers
KiB Swap: 0 total, 0 used, 0 free. 554208 cached Mem
PID USER PR NI VIRT RES SHR S %CPU %MEM TIME+ COMMAND
20248 root 20 0 0.227t 0.012t 18748 S 3090 5.2 29812:58 java
4213 root 20 0 2722544 64640 44232 S 23.5 0.0 233:35.37 mesos-slave
66128 titancl+ 20 0 24344 2332 1172 R 1.0 0.0 0:00.07 top
5235 root 20 0 38.227g 547004 49996 S 0.7 0.2 2:02.74 java
4299 root 20 0 20.015g 2.682g 16836 S 0.3 1.1 33:14.42 java
1 root 20 0 33620 2920 1496 S 0.0 0.0 0:03.82 init
2 root 20 0 0 0 0 S 0.0 0.0 0:00.02 kthreadd
3 root 20 0 0 0 0 S 0.0 0.0 0:05.35 ksoftirqd/0
5 root 0 -20 0 0 0 S 0.0 0.0 0:00.00 kworker/0:0H
6 root 20 0 0 0 0 S 0.0 0.0 0:06.94 kworker/u256:0
8 root 20 0 0 0 0 S 0.0 0.0 2:38.05 rcu_sched
&lt;/code>&lt;/pre>
&lt;p>top 命令包含了很多我们之前已经检查过的指标。可以方便的执行它来查看相比于之前的命令输出的结果有很大不同，这表明负载是可变的。&lt;/p>
&lt;p>top 的一个缺点是，很难看到数据随时间变动的趋势。vmstat 和 pidstat 提供的滚动输出会更清楚一些。如果你不以足够快的速度暂停输出（Ctrl-S 暂停，Ctrl-Q 继续），一些间歇性问题的线索也可能由于被清屏而丢失。&lt;/p>
&lt;h3 id="后续的分析">后续的分析&lt;/h3>
&lt;p>还有更多命令和方法可以用于更深入的分析。查看 Brendan 在 Velocity 2015 大会上的 &lt;a href="http://techblog.netflix.com/2015/08/netflix-at-velocity-2015-linux.html">Linux 性能工具教程&lt;/a>，其中包含了超过 40 个命令，涵盖了可观测性、标杆管理、调优、静态性能调优、分析，和跟踪等方面。&lt;/p>
&lt;p>在全网规模应对系统的可靠性和性能问题是我们的爱好之一。如果你想要加入我们来一起应对这种挑战，我们正在招聘！
&lt;a href="https://www.oschina.net/translate/linux-performance-analysis-in-60s?print">https://www.oschina.net/translate/linux-performance-analysis-in-60s?print&lt;/a>&lt;/p></description></item><item><title>Docs: CPU 性能优化</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/x.linux-%E7%AE%A1%E7%90%86/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E4%B8%8E%E6%95%85%E9%9A%9C%E5%A4%84%E7%90%86/cpu-%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/x.linux-%E7%AE%A1%E7%90%86/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E4%B8%8E%E6%95%85%E9%9A%9C%E5%A4%84%E7%90%86/cpu-%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/</guid><description/></item><item><title>Docs: Linux 的紧急模式或救援模式</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/x.linux-%E7%AE%A1%E7%90%86/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E4%B8%8E%E6%95%85%E9%9A%9C%E5%A4%84%E7%90%86/linux-%E7%9A%84%E7%B4%A7%E6%80%A5%E6%A8%A1%E5%BC%8F%E6%88%96%E6%95%91%E6%8F%B4%E6%A8%A1%E5%BC%8F/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/x.linux-%E7%AE%A1%E7%90%86/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E4%B8%8E%E6%95%85%E9%9A%9C%E5%A4%84%E7%90%86/linux-%E7%9A%84%E7%B4%A7%E6%80%A5%E6%A8%A1%E5%BC%8F%E6%88%96%E6%95%91%E6%8F%B4%E6%A8%A1%E5%BC%8F/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;p>Linux 系统难免出现问题，下面总结了一些在出现问题时，可以用到的修复方式。&lt;/p>
&lt;p>比如 单用户模式、GRUB 命令操作、Linux 救援模式 的故障修复案例。&lt;/p>
&lt;p>一般的故障修复，都是通过进入一个微型系统，并在微型系统中关联正常系统，来实现对正常系统进行修复操作的。这种微型系统可以存在于内核中，通过内核来启动\；也可以通过外部挂载(光盘、usb 等)的方式来启动。&lt;/p>
&lt;h1 id="emergency紧急-模式">Emergency(紧急) 模式&lt;/h1>
&lt;p>Linux 系统提供了紧急模式(类似 Windows 安全模式)，该模式镶嵌在内核中。可以在最小环境中(仅仅运行系统所需的必要程序)进行系统维护。在紧急模式中，Linux 引导进入根 shell，网络被禁用，只有少数进程运行。紧急模式可以用来修改文件系统损坏、还原配置文件、移动用户数据等。&lt;/p>
&lt;h2 id="启动紧急模式">启动紧急模式&lt;/h2>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/ewdpso/1616163959565-28b07db0-d297-4c04-bdf7-b31a43af0106.jpeg" alt="">
在该界面选中想要使用的内核后，按 e 键 ，进入编辑启动参数界面
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/ewdpso/1616163959592-6d0be599-731a-4f6c-b6b1-9e195991cfb9.jpeg" alt="">
在上图红框位置将 ro 改为 rw init=/sysroot/bin/sh 。然后按 ctrl+x 来启动。这时候，就进入了紧急模式，紧急模式的界面是像下图这样的
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/ewdpso/1616163959556-b1d3734e-d706-47fc-a83c-131c6f049baa.jpeg" alt="">
这是一个 sh 的 shell(也可以启动其他 shell，比如 bash 等)，可以执行一些基本命令，目录结构如下&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>:/# ls
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>bin dev dracut-state.sh etc init lib lib64 proc root run sbin shutdown sys sysroot tmp usr var
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>其中 &lt;code>sysroot&lt;/code> 目录，就是我们正常启动系统时，所看到的 &lt;code>/&lt;/code> 目录&lt;/p>
&lt;p>在这种模式下，可以看到，仅有个别进程在运行，/init rhgb 是该系统模式下的第一个进程，与正常系统不同。
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/ewdpso/1616163959562-5047fe7d-4089-43e3-933c-0eb9ab6c80d4.jpeg" alt="">
sh 进程是因为我们需要一个可以操作的 shell，所以在修改启动项时添加的。&lt;/p>
&lt;p>实际上，所谓的紧急模式，就是在安装 linux 系统时，内核中内置的一个微型系统，进入该微型系统后，咱正常系统的根目录，就被挂载到微型系统的/sysroot 下了，由于没有挂载其他物理磁盘，也没有任何多余进程运行，所以只要内核是好的，那么紧急模式是可以正常进入的。&lt;/p>
&lt;p>该模式可以用来修复一些与非内核错误的一些故障&lt;/p>
&lt;h1 id="rescue救援-模式">Rescue(救援) 模式&lt;/h1>
&lt;p>当紧急模式不可用时，说明内核或者内核相关出现问题，这时候，我们就需要使用救援模式了。&lt;/p>
&lt;p>救援模式并不在已经安装的系统或者内核上，而是通过外部挂载 linux 系统镜像来启动。相当于通过外挂的系统镜像来启动一个微型系统，来诊断并修复当前系统&lt;/p>
&lt;h2 id="启动救援模式">启动救援模式&lt;/h2>
&lt;p>首先需要将系统镜像挂载到设备上，物理机直接插入光盘或者 U 盘，并修改启动项；虚拟机的话同理，将 linux 系统镜像挂载进虚拟机然后通过该系统镜像启动系统。
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/ewdpso/1616163959557-c45d87ec-9d2c-4296-b14a-fdd3f7b710e1.jpeg" alt="">
在上图选择 Troubleshooting 后，选择 Rescue a CentOS system（救援一个 centos 系统）
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/ewdpso/1616163959573-28e0e935-14ef-4a12-8d1f-20ad9d79a274.jpeg" alt="">
在上图蓝线上半部分，选择 1 继续之后。将会启动一个微型系统，并进入一个 shell，其中会提示我们，设备上正常系统的 / 目录被挂载到 /mnt/sysimage ，该情况与 紧急模式 一样，只是正常系统的跟目录被挂载的路径不同罢了。&lt;/p>
&lt;p>通过光盘启动的微型系统，明显比紧急模式的微型系统 功能更加完善，可以看到有很多进程
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/ewdpso/1616163959579-0a7e5ff3-ae98-4560-8a00-c3b58808a04d.jpeg" alt="">
同样也是一个 sh 的 shell。可以在该 shell 下，进入 /mnt/sysimage 目录来对正常的系统进行修复&lt;/p>
&lt;h2 id="这类模式常见使用方式">这类模式常见使用方式&lt;/h2>
&lt;p>由于进入这类救援模式后，原本系统的 &lt;code>/&lt;/code> 被挂载到微型系统的的其他目录，这之后直接使用 chroot /PATH/DIR 命令，即可将当前 / 目录转变到原本系统上，然后就可以更方便的定位问题了，如果不进行 chroot，那么操作目录的时候，其实挺不方便的~~~~&lt;/p>
&lt;h2 id="ubuntu-的-rescue-模式">Ubuntu 的 Rescue 模式&lt;/h2>
&lt;p>网上充斥着大量的垃圾信息，并没有明确指导如何通过挂盘来进入 Rescue 模式，实际上，Ubuntu Server 版的 ISO 并没有提供这个功能，那么有两种方式来实现：&lt;/p>
&lt;ul>
&lt;li>使用 Ubuntu Desktop 的 ISO，进入界面后选择 &lt;strong>Try Ubuntu&lt;/strong>，也就是网上常说的 &lt;strong>Live CD&lt;/strong> 模式。只不过这是图形界面，进入后配置好 root 密码，可以使用 &lt;code>ctrl + alt + f3&lt;/code> 来切换 TTY，并在 CLI 下进行修复工作&lt;/li>
&lt;li>使用 CentOS 的 ISO 进入 Rescue 模式，同样可以修复挂载 Ubuntu 的分区到指定的目录。&lt;/li>
&lt;/ul>
&lt;h1 id="如何在-centos-8-上启动到紧急模式">如何在 CentOS 8 上启动到紧急模式&lt;/h1>
&lt;p>原文链接：&lt;a href="https://linuxhint.com/boot-emergency-mode-centos-8/">https://linuxhint.com/boot-emergency-mode-centos-8/&lt;/a>
在最新的 CentOS 中，即 CentOS 8 紧急模式和救援模式已经取代了运行级别的概念。运行级别是用于各种任务的不同模式。在 CentOS 8 中，Rescue 模式相当于单用户模式，而紧急启动模式提供了一个最小的环境来修复您的系统。
今天我们将学习如何将 CentOS 8 启动到救援和紧急模式。&lt;/p>
&lt;h2 id="如何启动进入救援模式">如何启动进入救援模式&lt;/h2>
&lt;p>救援模式需要 root 密码进行身份验证，并允许您在正常启动过程不起作用时恢复系统。救援模式将尝试设置所有本地文件系统并启动一些基本系统服务。救援模式不启动网络接口，也不允许多个用户登录。
启动计算机并等待 GRUB 菜单出现。
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/ewdpso/1630379281707-861e3e5b-49c3-4721-9e4e-d2f0dd9239cc.png" alt="image.png">
现在按“e”打开编辑菜单：
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/ewdpso/1630379281756-579ed222-fa5a-48c6-9182-5a19adc12983.png" alt="image.png">
现在，找到以下面的屏幕截图所示的“Linux”关键字开头的行：
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/ewdpso/1630379280843-f87b7899-36d3-4049-8ba5-38f918926497.png" alt="image.png">
使用键盘上的终点按钮转到线的末尾，并在行结束时添加以下参数：
systemd.Unit = Rescue.target.
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/ewdpso/1630379280876-d0125040-66ac-4757-abde-e5089a4c1b4e.png" alt="image.png">
按 Ctrl + X 启动系统，但此时使用新参数将让您输入救援模式。
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/ewdpso/1630379280860-c9be44a2-22e8-4fa5-a6c7-4dc77dffa729.png" alt="image.png">
操作系统会要求 root 密码。在提供密码后，您将进入救援模式。
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/ewdpso/1630379281433-ed1c7906-6118-4f92-a7cc-1dc556b445a6.png" alt="image.png">
现在，您可以在救援模式下修复系统。
完成救援模式后，您可以通过运行“退出”命令来退出救援/紧急模式。&lt;/p>
&lt;h2 id="启动进入紧急模式">启动进入紧急模式&lt;/h2>
&lt;p>紧急模式甚至救援模式不起作用时，恢复系统的最小环境。紧急将根文件安装为只读，并不尝试挂载本地文件系统。紧急模式也没有启动网络接口。&lt;/p>
&lt;p>将系统启动到紧急模式的过程与救援模式相同。
首先，启动计算机并等待 GRUB 菜单显示：
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/ewdpso/1630379281944-4f628d77-411e-4319-af8c-1a1557c7e8ce.png" alt="image.png">
现在按“E”打开编辑菜单：
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/ewdpso/1630379282293-94e66990-034a-4b85-8cfa-7e9262ade0a8.png" alt="image.png">
现在定位以“Linux”关键字开头的行，如下屏幕截图所示：
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/ewdpso/1630379282273-c76fcd43-02db-4a14-b7e3-52b4ca27cb3e.png" alt="image.png">
使用键盘上的终点按钮转到线的末尾，并在行结束时添加以下参数：
systemd.unit = Encrasst.target.
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/ewdpso/1630379283117-bf48ec7a-b48c-4d23-bd05-b284dce0dcb3.png" alt="image.png">
按 Ctrl + X 启动系统，但此时使用新参数将让您输入紧急模式。
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/ewdpso/1630379283276-16043784-d87e-4a63-8c3b-95c4c030fd98.png" alt="image.png">
提供密码后，您将进入紧急模式。
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/ewdpso/1630379283239-886da796-8374-441c-a133-2e28b376336d.png" alt="image.png">
现在，即使救援模式不起作用，您也可以在紧急模式下修复系统。&lt;/p>
&lt;p>完成紧急模式后，您可以通过运行“退出”命令来退出救援/紧急模式。&lt;/p></description></item><item><title>Docs: Redhat 优化</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/x.linux-%E7%AE%A1%E7%90%86/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E4%B8%8E%E6%95%85%E9%9A%9C%E5%A4%84%E7%90%86/redhat-%E4%BC%98%E5%8C%96/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/x.linux-%E7%AE%A1%E7%90%86/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E4%B8%8E%E6%95%85%E9%9A%9C%E5%A4%84%E7%90%86/redhat-%E4%BC%98%E5%8C%96/</guid><description>
&lt;p>Redhat 官方文档：&lt;a href="https://access.redhat.com/documentation/zh-CN/Red_Hat_Enterprise_Linux/7/html/Performance_Tuning_Guide/">https://access.redhat.com/documentation/zh-CN/Red_Hat_Enterprise_Linux/7/html/Performance_Tuning_Guide/&lt;/a>&lt;/p>
&lt;p>参考文章：&lt;a href="https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/8/html/monitoring_and_managing_system_status_and_performance/index">https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/8/html/monitoring_and_managing_system_status_and_performance/index&lt;/a>&lt;/p>
&lt;p>Tuned 概述&lt;/p>
&lt;p>Tuned 是一项服务，可监视您的系统并在某些工作负载下优化性能。Tuned 的核心是配置文件，它们可以针对不同的用例调整您的系统。&lt;/p>
&lt;p>针对许多用例，已分发 Tuned 并附带了许多预定义的配置文件：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>High throughput&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Low latency&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Saving power&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>可以修改为每个配置文件定义的规则，并自定义如何调整特定设备。当您切换到另一个配置文件或停用 Tuned 时，以前的配置文件对系统设置所做的所有更改都将恢复为原始状态。&lt;/p>
&lt;p>您还可以配置“Tuned”以对设备使用情况的变化做出反应，并调整设置以提高活动设备的性能并降低非活动设备的功耗。&lt;/p>
&lt;p>配置文件&lt;/p>
&lt;p>/usr/lib/tuned/_ #特定于发行版的概要文件存储在目录中。每个配置文件都有其自己的目录。该配置文件由名为 tuned.conf 的主要配置文件以及其他文件（例如帮助程序脚本）组成。
/etc/tuned/_ #如果需要定制概要文件，请将概要文件目录复制到用于定制概要文件的目录中。如果有两个同名的配置文件，则使用 /etc/tuned/ 中的自定义配置文件。&lt;/p>
&lt;p>tuned-adm 命令行工具&lt;/p>
&lt;p>usage: tuned-adm [-h] [&amp;ndash;version] [&amp;ndash;debug] [&amp;ndash;async] [&amp;ndash;timeout TIMEOUT]&lt;/p>
&lt;pre>&lt;code> [--loglevel LOGLEVEL]
{list,active,off,profile,profile_info,recommend,verify,auto_profile,profile_mode}
...
&lt;/code>&lt;/pre>
&lt;p>positional arguments:&lt;/p>
&lt;ol>
&lt;li>
&lt;p>{list,active,off,profile,profile_info,recommend,verify,auto_profile,profile_mode}&lt;/p>
&lt;/li>
&lt;li>
&lt;p>list list available profiles or plugins (by default profiles)&lt;/p>
&lt;/li>
&lt;li>
&lt;p>active show active profile&lt;/p>
&lt;/li>
&lt;li>
&lt;p>off switch off all tunings&lt;/p>
&lt;/li>
&lt;li>
&lt;p>profile switch to a given profile, or list available profiles if no profile is given&lt;/p>
&lt;/li>
&lt;li>
&lt;p>profile_info show information/description of given profile or current profile if no profile is specified&lt;/p>
&lt;/li>
&lt;li>
&lt;p>recommend recommend profile&lt;/p>
&lt;/li>
&lt;li>
&lt;p>verify verify profile&lt;/p>
&lt;/li>
&lt;li>
&lt;p>auto_profile enable automatic profile selection mode, switch to the recommended profile&lt;/p>
&lt;/li>
&lt;li>
&lt;p>profile_mode show current profile selection mode&lt;/p>
&lt;/li>
&lt;/ol>
&lt;p>optional arguments:&lt;/p>
&lt;ol>
&lt;li>
&lt;p>-h, &amp;ndash;help show this help message and exit&lt;/p>
&lt;/li>
&lt;li>
&lt;p>--version, -v show program&amp;rsquo;s version number and exit&lt;/p>
&lt;/li>
&lt;li>
&lt;p>--debug, -d show debug messages&lt;/p>
&lt;/li>
&lt;li>
&lt;p>--async, -a with dbus do not wait on commands completion and return immediately&lt;/p>
&lt;/li>
&lt;li>
&lt;p>--timeout TIMEOUT, -t TIMEOUT with sync operation use specific timeout instead of the default 600 second(s)&lt;/p>
&lt;/li>
&lt;li>
&lt;p>--loglevel LOGLEVEL, -l LOGLEVEL level of log messages to capture (one of debug, info,warn, error, console, none). Default: console&lt;/p>
&lt;/li>
&lt;/ol></description></item><item><title>Docs: 故障处理案例</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/x.linux-%E7%AE%A1%E7%90%86/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E4%B8%8E%E6%95%85%E9%9A%9C%E5%A4%84%E7%90%86/%E6%95%85%E9%9A%9C%E5%A4%84%E7%90%86%E6%A1%88%E4%BE%8B/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/x.linux-%E7%AE%A1%E7%90%86/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E4%B8%8E%E6%95%85%E9%9A%9C%E5%A4%84%E7%90%86/%E6%95%85%E9%9A%9C%E5%A4%84%E7%90%86%E6%A1%88%E4%BE%8B/</guid><description/></item><item><title>Docs: 网络性能优化</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/x.linux-%E7%AE%A1%E7%90%86/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E4%B8%8E%E6%95%85%E9%9A%9C%E5%A4%84%E7%90%86/%E7%BD%91%E7%BB%9C%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/x.linux-%E7%AE%A1%E7%90%86/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E4%B8%8E%E6%95%85%E9%9A%9C%E5%A4%84%E7%90%86/%E7%BD%91%E7%BB%9C%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/</guid><description/></item><item><title>Docs: 性能测试</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/x.linux-%E7%AE%A1%E7%90%86/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E4%B8%8E%E6%95%85%E9%9A%9C%E5%A4%84%E7%90%86/%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/x.linux-%E7%AE%A1%E7%90%86/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E4%B8%8E%E6%95%85%E9%9A%9C%E5%A4%84%E7%90%86/%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95/</guid><description/></item><item><title>Docs: 性能优化 与 故障处理</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/x.linux-%E7%AE%A1%E7%90%86/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E4%B8%8E%E6%95%85%E9%9A%9C%E5%A4%84%E7%90%86/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96-%E4%B8%8E-%E6%95%85%E9%9A%9C%E5%A4%84%E7%90%86/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/x.linux-%E7%AE%A1%E7%90%86/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E4%B8%8E%E6%95%85%E9%9A%9C%E5%A4%84%E7%90%86/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96-%E4%B8%8E-%E6%95%85%E9%9A%9C%E5%A4%84%E7%90%86/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://time.geekbang.org/column/intro/100020901">极客时间,Linux 性能优化实战&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://mp.weixin.qq.com/s/Tnerf7M_a6HUC4ucaOWzeg">公众号,刘超的通俗云计算-读完这篇文章，就再也不怕遇到网络问题啦&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;h1 id="常见问题简述">常见问题简述&lt;/h1>
&lt;p>当你发现某台机器无论做什么都慢, 而 cpu 和内核却不是瓶颈的时候, 那有可能是内核慢了。机器上定时任务的执行过多, 内核缓存一直增加, 导致内核速度变慢了. 它一变慢, 引发了 tcp 握手时间变长, 最后造成用户体验下降. 既然发现了问题, 解决方案也比较容易搜索到了, 增加任务, 检查内核是否变慢, 慢了的话就清理一次：&lt;code>sync &amp;amp;&amp;amp; echo 3 &amp;gt; /proc/sys/vm/drop_caches&lt;/code>
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/behafi/1647529106727-4e5af00a-e6ee-4b86-9b82-cec9262f4601.png" alt="image.png">
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/behafi/1647529081502-9a4d7eae-e062-48bb-bdf7-24a6ffef8d67.png" alt="image.png">
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/behafi/1647529150105-9e34e168-1ad1-4896-a501-9cb77aa38661.png" alt="image.png">&lt;/p></description></item><item><title>Docs: 一台 Linux 服务器最多能支撑多少个 TCP 连接？</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/x.linux-%E7%AE%A1%E7%90%86/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E4%B8%8E%E6%95%85%E9%9A%9C%E5%A4%84%E7%90%86/%E4%B8%80%E5%8F%B0-linux-%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%9C%80%E5%A4%9A%E8%83%BD%E6%94%AF%E6%92%91%E5%A4%9A%E5%B0%91%E4%B8%AA-tcp-%E8%BF%9E%E6%8E%A5/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/x.linux-%E7%AE%A1%E7%90%86/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E4%B8%8E%E6%95%85%E9%9A%9C%E5%A4%84%E7%90%86/%E4%B8%80%E5%8F%B0-linux-%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%9C%80%E5%A4%9A%E8%83%BD%E6%94%AF%E6%92%91%E5%A4%9A%E5%B0%91%E4%B8%AA-tcp-%E8%BF%9E%E6%8E%A5/</guid><description>
&lt;p>原文链接：&lt;a href="https://mp.weixin.qq.com/s/RpR62dm2idxMqBc2-DMxUw">https://mp.weixin.qq.com/s/RpR62dm2idxMqBc2-DMxUw&lt;/a>&lt;/p>
&lt;h2 id="困惑很多人的并发问题">困惑很多人的并发问题&lt;/h2>
&lt;p>在网络开发中，我发现有很多同学对一个基础问题始终是没有彻底搞明白。那就是一台服务器最大究竟能支持多少个网络连接？我想我有必要单独发一篇文章来好好说一下这个问题。
很多同学看到这个问题的第一反应是 65535。原因是：“听说端口号最多有 65535 个，那长连接就最多保持 65535 个了”。是这样的吗？还有的人说：“应该受 TCP 连接里四元组的空间大小限制，算起来是 200 多万亿个！”
如果你对这个问题也是理解的不够彻底，那么今天讲个故事讲给你听！&lt;/p>
&lt;h2 id="一次关于服务器端并发的聊天">一次关于服务器端并发的聊天&lt;/h2>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/dzqw9g/1623916595417-6a1934cd-4209-42b2-b62d-4f1f455f033e.webp" alt="">&lt;/p>
&lt;blockquote>
&lt;p>&amp;ldquo;TCP 连接四元组是源 IP 地址、源端口、目的 IP 地址和目的端口。任意一个元素发生了改变，那么就代表的是一条完全不同的连接了。拿我的 Nginx 举例，它的端口是固定使用 80。另外我的 IP 也是固定的，这样目的 IP 地址、目的端口都是固定的。剩下源 IP 地址、源端口是可变的。所以理论上我的 Nginx 上最多可以建立 2 的 32 次方（ip 数）×2 的 16 次方（port 数）个连接。这是两百多万亿的一个大数字！！&amp;rdquo;&lt;/p>
&lt;/blockquote>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/dzqw9g/1623916595228-a7ffc123-26fd-4ebe-aae0-278aab15d412.webp" alt="">&lt;/p>
&lt;blockquote>
&lt;p>&amp;ldquo;进程每打开一个文件（linux 下一切皆文件，包括 socket），都会消耗一定的内存资源。如果有不怀好心的人启动一个进程来无限的创建和打开新的文件，会让服务器崩溃。所以 linux 系统出于安全角度的考虑，在多个位置都限制了可打开的文件描述符的数量，包括系统级、用户级、进程级。这三个限制的含义和修改方式如下：&amp;rdquo;&lt;/p>
&lt;/blockquote>
&lt;ul>
&lt;li>系统级：当前系统可打开的最大数量，通过 fs.file-max 参数可修改&lt;/li>
&lt;li>用户级：指定用户可打开的最大数量，修改/etc/security/limits.conf&lt;/li>
&lt;li>进程级：单个进程可打开的最大数量，通过 fs.nr_open 参数可修改&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/dzqw9g/1623916595289-e55c6cb4-0cd3-4e62-ba07-f25d31738a93.webp" alt="">&lt;/p>
&lt;blockquote>
&lt;p>&amp;ldquo;我的接收缓存区大小是可以配置的，通过 sysctl 命令就可以查看。&amp;rdquo;&lt;/p>
&lt;/blockquote>
&lt;pre>&lt;code>$ sysctl -a | grep rmem
net.ipv4.tcp_rmem = 4096 87380 8388608
net.core.rmem_default = 212992
net.core.rmem_max = 8388608
&lt;/code>&lt;/pre>
&lt;blockquote>
&lt;p>&amp;ldquo;其中在 tcp_rmem&amp;quot;中的第一个值是为你们的 TCP 连接所需分配的最少字节数。该值默认是 4K，最大的话 8MB 之多。也就是说你们有数据发送的时候我需要至少为对应的 socket 再分配 4K 内存，甚至可能更大。&amp;rdquo;&lt;/p>
&lt;/blockquote>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/dzqw9g/1623916595216-ccd84846-b2b3-4024-bbd2-615d1e3e280f.png" alt="">&lt;/p>
&lt;blockquote>
&lt;p>&amp;ldquo;TCP 分配发送缓存区的大小受参数 net.ipv4.tcp_wmem 配置影响。&amp;rdquo;&lt;/p>
&lt;/blockquote>
&lt;pre>&lt;code>$ sysctl -a | grep wmem
net.ipv4.tcp_wmem = 4096 65536 8388608
net.core.wmem_default = 212992
net.core.wmem_max = 8388608
&lt;/code>&lt;/pre>
&lt;blockquote>
&lt;p>&amp;ldquo;在 net.ipv4.tcp_wmem&amp;quot;中的第一个值是发送缓存区的最小值，默认也是 4K。当然了如果数据很大的话，该缓存区实际分配的也会比默认值大。&amp;rdquo;&lt;/p>
&lt;/blockquote>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/dzqw9g/1623916595282-77a36d76-26b0-4f8e-9b5c-d1547c5ea9e9.webp" alt="">&lt;/p>
&lt;h2 id="服务端百万连接达成记">服务端百万连接达成记&lt;/h2>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/dzqw9g/1623916595444-0f303b1b-4f33-4a0e-8d82-364c574c74e7.png" alt="">&lt;/p>
&lt;blockquote>
&lt;p>“准备啥呢，还记得前面说过 Linux 对最大文件对象数量有限制，所以要想完成这个实验，得在用户级、系统级、进程级等位置把这个上限加大。我们实验目的是 100W，这里都设置成 110W，这个很重要！因为得保证做实验的时候其它基础命令例如 ps，vi 等是可用的。“&lt;/p>
&lt;/blockquote>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/dzqw9g/1623916595250-8062dc1b-fbea-4a75-84ac-2fcf130aefc1.png" alt="">
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/dzqw9g/1623916595345-2df3bf61-7fcd-46a6-bbb6-c1329148546c.png" alt="">
活动连接数量确实达到了 100W：&lt;/p>
&lt;pre>&lt;code>$ ss -n | grep ESTAB | wc -l
1000024
&lt;/code>&lt;/pre>
&lt;p>当前机器内存总共是 3.9GB，其中内核 Slab 占用了 3.2GB 之多。MemFree 和 Buffers 加起来也只剩下 100 多 MB 了：&lt;/p>
&lt;pre>&lt;code>$ cat /proc/meminfo
MemTotal: 3922956 kB
MemFree: 96652 kB
MemAvailable: 6448 kB
Buffers: 44396 kB
......
Slab: 3241244KB kB
&lt;/code>&lt;/pre>
&lt;p>通过 slabtop 命令可以查看到 densty、flip、sock_inode_cache、TCP 四个内核对象都分别有 100W 个：
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/dzqw9g/1623916595455-641be971-3832-4c18-bc3b-fddc72e78e31.png" alt="">
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/dzqw9g/1623916595263-15e8790c-b344-4afe-b28c-b7fadfd07f32.png" alt="">&lt;/p>
&lt;h2 id="结语">结语&lt;/h2>
&lt;p>互联网后端的业务特点之一就是高并发. 但是一台服务器最大究竟能支持多少个 TCP 连接，这个问题似乎却又在困惑着很多同学。希望今天过后，你能够将这个问题踩在脚下摩擦！
学习是一件痛苦的事情，尤其咱们号里很多读者朋友都是工作满一天了再来看我的技术号的文章的。我一直都在琢磨到底怎么样组织技术内容形式，能让大家理解起来更能省一点脑细胞呢。这篇服务器的最大并发数的文章是早就想发的，但是写了两三个版本都不满意。今天终于想出了一种让大家更容易理解的方式，算过了自己这关了。
如果您喜欢我的文章、并觉得它有用，期望您能不吝把它转发到你的朋友圈，技术群。或者哪怕是点个赞，点个再看都可以。触达更多的技术同学并收获大家的反馈将极大地提升彦飞的创作动力！
改天再讲客户端，敬请期待！！&lt;/p></description></item></channel></rss>