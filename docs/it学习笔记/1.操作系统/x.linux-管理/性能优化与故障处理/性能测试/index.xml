<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>断念梦 – 性能测试</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/x.linux-%E7%AE%A1%E7%90%86/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E4%B8%8E%E6%95%85%E9%9A%9C%E5%A4%84%E7%90%86/%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95/</link><description>Recent content in 性能测试 on 断念梦</description><generator>Hugo -- gohugo.io</generator><atom:link href="https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/x.linux-%E7%AE%A1%E7%90%86/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E4%B8%8E%E6%95%85%E9%9A%9C%E5%A4%84%E7%90%86/%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95/index.xml" rel="self" type="application/rss+xml"/><item><title>Docs: ApacheBench # Apache HTTP服务器基准测试工具</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/x.linux-%E7%AE%A1%E7%90%86/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E4%B8%8E%E6%95%85%E9%9A%9C%E5%A4%84%E7%90%86/%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95/apachebench-#-apache-http%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%9F%BA%E5%87%86%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/x.linux-%E7%AE%A1%E7%90%86/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E4%B8%8E%E6%95%85%E9%9A%9C%E5%A4%84%E7%90%86/%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95/apachebench-#-apache-http%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%9F%BA%E5%87%86%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/</guid><description>
&lt;h1 id="heading">&lt;/h1>
&lt;h1 id="apachebench-介绍">ApacheBench 介绍&lt;/h1>
&lt;p>ApacheBench，简称 ab。ab 是用于对 Apache 超文本传输协议（HTTP）服务器进行基准测试的工具。它旨在使您对当前的 Apache 安装方式有一个印象。这尤其向您显示 Apache 安装每秒能够处理多少个请求。&lt;/p>
&lt;h1 id="apachebench-的安装与使用">ApacheBench 的安装与使用&lt;/h1>
&lt;p>ab 工具包含在 httpd-tools 软件包中，直接安装 httpd-tools 即可&lt;/p>
&lt;h1 id="apachebench-测试结果参数解析">ApacheBench 测试结果参数解析&lt;/h1></description></item><item><title>Docs: fio</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/x.linux-%E7%AE%A1%E7%90%86/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E4%B8%8E%E6%95%85%E9%9A%9C%E5%A4%84%E7%90%86/%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95/fio-#-%E7%A3%81%E7%9B%98%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/x.linux-%E7%AE%A1%E7%90%86/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E4%B8%8E%E6%95%85%E9%9A%9C%E5%A4%84%E7%90%86/%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95/fio-#-%E7%A3%81%E7%9B%98%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/</guid><description/></item><item><title>Docs: fio # 磁盘性能测试工具</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/x.linux-%E7%AE%A1%E7%90%86/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E4%B8%8E%E6%95%85%E9%9A%9C%E5%A4%84%E7%90%86/%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95/fio-#-%E7%A3%81%E7%9B%98%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/x.linux-%E7%AE%A1%E7%90%86/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E4%B8%8E%E6%95%85%E9%9A%9C%E5%A4%84%E7%90%86/%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95/fio-#-%E7%A3%81%E7%9B%98%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>项目地址：&lt;a href="https://github.com/axboe/fio">https://github.com/axboe/fio&lt;/a>
官方文档：&lt;a href="https://fio.readthedocs.io/en/latest/">https://fio.readthedocs.io/en/latest/&lt;/a>&lt;/p>
&lt;/blockquote>
&lt;p>注意：！！当使用 fio 的 filename 参数指定某个要测试的裸设备（硬盘或分区），切勿在系统分区做测试，会破坏系统分区，从而导致系统崩溃。若一定要测试系统分区较为安全的方法是：在根目录下创建一个空目录，在测试命令中使用 directory 参数指定该目录，而不使用 filename 参数。现在假设 /dev/vda3 设备挂载在 / 目录下，那么不要执行 fil &amp;ndash;filename=/dev/vda 这种操作！！&lt;/p>
&lt;h2 id="1-性能的基本概念">1 性能的基本概念&lt;/h2>
&lt;h3 id="11-什么是一个-io">1.1 什么是一个 IO&lt;/h3>
&lt;p>IO 即 Input 和 Output，可以分为读 IO 和写 IO。读 IO，就是发指令，从磁盘读取某段扇区的内容。指令一般是通知磁盘开始扇区的位置，然后给出需要从这个初始扇区往后读取的连续扇区个数，同时给出的动作是读，还是写。磁盘收到这条指令，就会按照指令的要求，读或者写数据。控制器发出的这种指令+数据，就是一次 IO，读或者写。&lt;/p>
&lt;h3 id="12-顺序-io-和随机-io">1.2 顺序 IO 和随机 IO&lt;/h3>
&lt;p>顺序和随机，可以简单地理解为本次 IO 给出的初始扇区地址，和上一次 IO 的结束扇区地址，是否是按顺序的，如果相差很大，就算一次随机 IO。&lt;/p>
&lt;h3 id="13-io-大小">1.3 IO 大小&lt;/h3>
&lt;p>一次 IO 需要读或者写的数据块大小。&lt;/p>
&lt;h3 id="14-带宽">1.4 带宽&lt;/h3>
&lt;p>每秒读出或写入的数据量。常用单位包括 KB/s、MB/s、GB/s 等。&lt;/p>
&lt;h3 id="15-延时">1.5 延时&lt;/h3>
&lt;p>客户端发出 IO 请求直到收到请求并响应是需要一段时间的，这段时间就是 IO 延时。IO 延 时一般都是毫秒级的。随着 IO 压力的增大，IO 延时也会随之增大。对于存储来说，由于写 是前台操作，而读是后台操作，因此通常写的 IO 延时要低于读。相同 IO 模型下，IO 延时越小，存储性能越好。一般，IO 延时如果超过 30ms 就说明存储已经比较吃力了。&lt;/p>
&lt;h3 id="16-iops">1.6 IOPS&lt;/h3>
&lt;p>每秒收到的 IO 响应数。读写比例、队列深度、随机度和块大小描述了 IO 模型。在这个模型下，每个 IO 的延时最终体现了 IO 性能。IOPS 和 带宽从两个不同的方面反映了存储性能。&lt;/p>
&lt;h3 id="17-队列深度">1.7 队列深度&lt;/h3>
&lt;p>IO 队列使得 IO 可以并行处理，为何要对磁盘 IO 进行并行处理呢？主要目的是提高磁盘处理 IO 的效率。这一点对于多物理磁盘组成的虚拟磁盘（或 LUN）显得尤为重要。如果 一次提交一个 IO，虽然响应时间较短，但系统的带宽很小。相比较而言，一次提交多个 IO 既缩短了磁头移动距离（通过电梯算法），同时也能够提升 IOPS。&lt;/p>
&lt;h2 id="fio-的工作方式">fio 的工作方式&lt;/h2>
&lt;p>想要运行 fio 可以通过两种方式&lt;/p>
&lt;ol>
&lt;li>给定一个或多个 job files&lt;/li>
&lt;li>直接使用命令行参数&lt;/li>
&lt;/ol>
&lt;p>如果 job file 中仅包含一个作业，则最好只在命令行中提供参数。命令行参数与作业参数相同，还有一些额外的参数可控制全局参数。这里面提到的 job file 中的擦书，其实也可以理解为指令、关键字、字段等等。就是一个配置文件中用来描述程序运行行为的东西。&lt;/p>
&lt;ol>
&lt;li>例如，对于 job files 中的参数 iodepth = 2，在命令行选项为&amp;ndash;iodepth 2 或&amp;ndash;iodepth = 2。&lt;/li>
&lt;li>还可以使用命令行来提供多个作业条目。对于 fio 看到的每个&amp;ndash;name 选项，它将使用该名称开始一个新作业。 &amp;ndash;name 条目之后的命令行条目将应用于该作业，直到没有更多的条目或看到新的&amp;ndash;name 条目为止。这类似于作业文件选项，其中每个选项都适用于当前作业，直到看到新的 [] 作业条目为止。&lt;/li>
&lt;/ol>
&lt;p>开始模拟 I/O 工作负载的第一步，是编写一个描述特定配置的 job file。作业文件可以包含任何数量的线程和/或文件-作业文件的典型内容是定义共享参数的全局部分，以及一个或多个描述所涉及作业的作业部分。运行时，fio 会分析该文件并按照说明进行所有设置。如果我们从上到下分解一个 job ，它包含以下基本参数：&lt;/p>
&lt;ol>
&lt;li>I/O type # 定义发布给文件的 I / O 模式。我们可能只从该文件中顺序读取，或者我们可能在随机写入。甚至顺序或随机混合读写。我们应该执行缓冲 I / O 还是直接/原始 I / O？&lt;/li>
&lt;li>Block size # 指定模拟 I/O 数据流时，每次 I/O 的块大小。可以是单个值，也可以描述块大小的范围。&lt;/li>
&lt;li>I/O size # 指定本次 job 将要读取或写入多少数据&lt;/li>
&lt;li>I/O engine # 定义如何向文件发出 I/O。我们可以使用内存映射文件，可以使用常规读/写，可以使用拼接，异步 I / O 甚至是 SG（SCSI 通用 sg）&lt;/li>
&lt;li>I/O depth # 定义在 I/O engine 是异步的时，我们要保持多大的队列深度&lt;/li>
&lt;li>Target file/device # How many files are we spreading the workload over.&lt;/li>
&lt;li>Threads, processes and job synchronization # How many threads or processes should we spread this workload over.&lt;/li>
&lt;/ol>
&lt;h1 id="job-file-格式">Job File 格式&lt;/h1>
&lt;p>Job file 参数详见：fio 参数详解&lt;/p>
&lt;p>如前所述，fio 接受一个或多个描述该操作的作业文件。作业文件格式是经典的 ini 文件，其中[]括号中的名称定义了作业名称。您可以随意使用任何所需的 ASCII 名称，但具有特殊含义的 global 除外。作业名称后面是零个或多个参数的序列，每行一个，用于定义作业的行为。如果一行中的第一个字符是“;”或“＃”，则整行都将作为注释被丢弃。&lt;/p>
&lt;p>全局部分为该文件中描述的作业设置默认值。作业可以覆盖全局节参数，并且如果需要的话，作业文件甚至可以具有多个全局节。作业仅受位于其上方的全局部分影响。&lt;/p>
&lt;p>因此，让我们看一个非常简单的作业文件，该文件定义了两个过程，每个过程都随机读取 128MiB 文件：&lt;/p>
&lt;pre>&lt;code>; -- start job file --
[global]
rw=randread
size=128m
[job1]
[job2]
; -- end job file --
&lt;/code>&lt;/pre>
&lt;p>如您所见，作业文件部分本身为空，因为所有描述的参数都是共享的。由于未提供文件名选项，因此，fio 会为每个作业组成一个合适的文件名。在命令行上，此作业如下所示：&lt;/p>
&lt;pre>&lt;code>$ fio --name=global --rw=randread --size=128m --name=job1 --name=job2
&lt;/code>&lt;/pre>
&lt;p>让我们看一个示例，其中有许多进程随机写入文件：&lt;/p>
&lt;pre>&lt;code>; -- start job file --
[random-writers]
ioengine=libaio
iodepth=4
rw=randwrite
bs=32k
direct=0
size=64m
numjobs=4
; -- end job file --
&lt;/code>&lt;/pre>
&lt;p>这里我们没有全局部分，因为我们只定义了一项工作。我们想在这里使用异步 I / O，每个文件的深度为 4。我们还将缓冲区大小增加到 32KiB，并将 numjobs 定义为 4，以分叉 4 个相同的作业。结果是 4 个进程，每个进程随机写入其自己的 64MiB 文件。您可以在命令行上指定参数，而不使用上面的作业文件。对于这种情况，您可以指定：&lt;/p>
&lt;pre>&lt;code>$ fio --name=random-writers --ioengine=libaio --iodepth=4 --rw=randwrite --bs=32k --direct=0 --size=64m --numjobs=4
&lt;/code>&lt;/pre>
&lt;h1 id="fio-命令行工具">fio 命令行工具&lt;/h1>
&lt;h2 id="fio-options-job-options-job-files">fio [OPTIONS] [JOB OPTIONS] [job file(s)]&lt;/h2>
&lt;p>OPTIONS&lt;/p>
&lt;p>JOB OPTIONS&lt;/p>
&lt;ol>
&lt;li>由于 Jobfile 中的参数与命令行选项基本保持一一对应的关系，所以对于 fio 的命令行参数，参考 Job file 参数即可 fio 参数详解&lt;/li>
&lt;/ol>
&lt;p>EXAMPLE&lt;/p>
&lt;ol>
&lt;li>注意，下面两条命令直接对整块磁盘进行写操作，会破坏文件，谨慎操作
&lt;ol>
&lt;li>fio -filename=/dev/vdb1 -direct=1 -iodepth 64 -thread -rw=randwrite -ioengine=libaio -bs=4K -numjobs=8 -runtime=60 -group_reporting -name=test1&lt;/li>
&lt;li>fio -filename=/dev/vdb3 -direct=1 -iodepth 64 -thread -rw=write -ioengine=libaio -bs=512K -numjobs=8 -runtime=60 -group_reporting -name=test2&lt;/li>
&lt;/ol>
&lt;/li>
&lt;li>&lt;strong>fio &amp;ndash;rw=write &amp;ndash;ioengine=sync &amp;ndash;fdatasync=1 &amp;ndash;directory=/var/lib/etcd &amp;ndash;size=22m &amp;ndash;bs=2300 &amp;ndash;name=&amp;ldquo;fioEtcdTest&amp;rdquo; &amp;ndash;time_based &amp;ndash;runtime=2m&lt;/strong>&lt;/li>
&lt;li>&lt;strong>fio &amp;ndash;rw=write &amp;ndash;ioengine=libaio &amp;ndash;iodepth=4 &amp;ndash;direct=1 &amp;ndash;filename=fiotest &amp;ndash;size=2G &amp;ndash;bs=4k &amp;ndash;name=&amp;ldquo;Max throughput&amp;rdquo; &amp;ndash;time_based &amp;ndash;runtime=60&lt;/strong>&lt;/li>
&lt;/ol>
&lt;h2 id="结果分析">结果分析&lt;/h2>
&lt;p>官方文档：&lt;a href="https://fio.readthedocs.io/en/latest/fio_doc.html#interpreting-the-output">https://fio.readthedocs.io/en/latest/fio_doc.html#interpreting-the-output&lt;/a>&lt;/p>
&lt;p>使用 fio -ioengine=libaio -bs=4k -direct=1 -thread -rw=write -size=2G -filename=test -name=&amp;ldquo;Max throughput&amp;rdquo; -iodepth=4 -runtime=60 命令得到如下结果&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># 前面几行是命令运行时，实时显示的信息&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># 名为 Max throughput 的 Job 基本信息&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Max throughput: &lt;span style="color:#f92672">(&lt;/span>g&lt;span style="color:#f92672">=&lt;/span>0&lt;span style="color:#f92672">)&lt;/span>: rw&lt;span style="color:#f92672">=&lt;/span>write, bs&lt;span style="color:#f92672">=(&lt;/span>R&lt;span style="color:#f92672">)&lt;/span> 4096B-4096B, &lt;span style="color:#f92672">(&lt;/span>W&lt;span style="color:#f92672">)&lt;/span> 4096B-4096B, &lt;span style="color:#f92672">(&lt;/span>T&lt;span style="color:#f92672">)&lt;/span> 4096B-4096B, ioengine&lt;span style="color:#f92672">=&lt;/span>libaio, iodepth&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">4&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>fio-3.7
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e"># fio 版本号&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Starting &lt;span style="color:#ae81ff">1&lt;/span> thread
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e"># 本次此时启动了 1 个线程&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># 1 表示运行的IO线程数；[W(1)] 表示使用的模式；[100.0%] 表示当前命令的执行进度；[r=0KiB/s,w=137MiB/s] 表示瞬时吞吐率；&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># [r=0,w=35.0k IOPS] 表示 IOPS 瞬时值；[eta 00m:00s] 表示持续时间&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># 该行内容在命令执行期间，可以看到值在实时变化&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Jobs: &lt;span style="color:#ae81ff">1&lt;/span> &lt;span style="color:#f92672">(&lt;/span>f&lt;span style="color:#f92672">=&lt;/span>1&lt;span style="color:#f92672">)&lt;/span>: &lt;span style="color:#f92672">[&lt;/span>W&lt;span style="color:#f92672">(&lt;/span>1&lt;span style="color:#f92672">)][&lt;/span>100.0%&lt;span style="color:#f92672">][&lt;/span>r&lt;span style="color:#f92672">=&lt;/span>0KiB/s,w&lt;span style="color:#f92672">=&lt;/span>137MiB/s&lt;span style="color:#f92672">][&lt;/span>r&lt;span style="color:#f92672">=&lt;/span>0,w&lt;span style="color:#f92672">=&lt;/span>35.0k IOPS&lt;span style="color:#f92672">][&lt;/span>eta 00m:00s&lt;span style="color:#f92672">]&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># 从本行开始为命令执行完成后每个 Job 的统计信息。&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># Job名称：(当前的GID,Job个数)：错误个数：本次Job的PID，本次Job的结束时间&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Max throughput: &lt;span style="color:#f92672">(&lt;/span>groupid&lt;span style="color:#f92672">=&lt;/span>0, jobs&lt;span style="color:#f92672">=&lt;/span>1&lt;span style="color:#f92672">)&lt;/span>: err&lt;span style="color:#f92672">=&lt;/span> 0: pid&lt;span style="color:#f92672">=&lt;/span>7767: Thu Nov &lt;span style="color:#ae81ff">12&lt;/span> 16:09:04 &lt;span style="color:#ae81ff">2020&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># 本次Job的测试模式(这里是写入)，IOPS平均值，带宽平均值，(带宽最大值)(数据总量/运行总时间)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># BW 是 BandWidth 的缩写。2048MiB 就是指的 -size 参数指定的 大小，是本次测试读/写的数据总量&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> write: IOPS&lt;span style="color:#f92672">=&lt;/span>34.3k, BW&lt;span style="color:#f92672">=&lt;/span>134MiB/s &lt;span style="color:#f92672">(&lt;/span>140MB/s&lt;span style="color:#f92672">)(&lt;/span>2048MiB/15289msec&lt;span style="color:#f92672">)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># latency(延迟)相关信息。(单位是：微妙)。注意后面信息括号中的单位会改变，fio 会根据本次测试结果得出的时间，合理给出一个单位。msec毫秒，usec微秒，nsec纳秒&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># slat 是 Submission latency(提交延迟)，就是提交到实际执行 I/O 的时间&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> slat &lt;span style="color:#f92672">(&lt;/span>usec&lt;span style="color:#f92672">)&lt;/span>: min&lt;span style="color:#f92672">=&lt;/span>3, max&lt;span style="color:#f92672">=&lt;/span>6347, avg&lt;span style="color:#f92672">=&lt;/span> 6.09, stdev&lt;span style="color:#f92672">=&lt;/span>12.68
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># clat 是 Completion latency(完成延迟)，就是从提交到完成的时间&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> clat &lt;span style="color:#f92672">(&lt;/span>usec&lt;span style="color:#f92672">)&lt;/span>: min&lt;span style="color:#f92672">=&lt;/span>57, max&lt;span style="color:#f92672">=&lt;/span>74949, avg&lt;span style="color:#f92672">=&lt;/span>108.13, stdev&lt;span style="color:#f92672">=&lt;/span>230.83
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># lat 是 Total latency(总延迟)，就是 fio 从创建这个 I/O 单元到完成的总时间&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> lat &lt;span style="color:#f92672">(&lt;/span>usec&lt;span style="color:#f92672">)&lt;/span>: min&lt;span style="color:#f92672">=&lt;/span>63, max&lt;span style="color:#f92672">=&lt;/span>74954, avg&lt;span style="color:#f92672">=&lt;/span>114.80, stdev&lt;span style="color:#f92672">=&lt;/span>231.22
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># 完成延迟的百分位数(单位是：微妙)，比如99.00th=[ 149] 表示这组样本的 99 百分位的延迟的值为 149&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> clat percentiles &lt;span style="color:#f92672">(&lt;/span>usec&lt;span style="color:#f92672">)&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> | 1.00th&lt;span style="color:#f92672">=[&lt;/span> 86&lt;span style="color:#f92672">]&lt;/span>, 5.00th&lt;span style="color:#f92672">=[&lt;/span> 92&lt;span style="color:#f92672">]&lt;/span>, 10.00th&lt;span style="color:#f92672">=[&lt;/span> 94&lt;span style="color:#f92672">]&lt;/span>, 20.00th&lt;span style="color:#f92672">=[&lt;/span> 97&lt;span style="color:#f92672">]&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> | 30.00th&lt;span style="color:#f92672">=[&lt;/span> 99&lt;span style="color:#f92672">]&lt;/span>, 40.00th&lt;span style="color:#f92672">=[&lt;/span> 101&lt;span style="color:#f92672">]&lt;/span>, 50.00th&lt;span style="color:#f92672">=[&lt;/span> 103&lt;span style="color:#f92672">]&lt;/span>, 60.00th&lt;span style="color:#f92672">=[&lt;/span> 106&lt;span style="color:#f92672">]&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> | 70.00th&lt;span style="color:#f92672">=[&lt;/span> 109&lt;span style="color:#f92672">]&lt;/span>, 80.00th&lt;span style="color:#f92672">=[&lt;/span> 113&lt;span style="color:#f92672">]&lt;/span>, 90.00th&lt;span style="color:#f92672">=[&lt;/span> 119&lt;span style="color:#f92672">]&lt;/span>, 95.00th&lt;span style="color:#f92672">=[&lt;/span> 125&lt;span style="color:#f92672">]&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> | 99.00th&lt;span style="color:#f92672">=[&lt;/span> 149&lt;span style="color:#f92672">]&lt;/span>, 99.50th&lt;span style="color:#f92672">=[&lt;/span> 192&lt;span style="color:#f92672">]&lt;/span>, 99.90th&lt;span style="color:#f92672">=[&lt;/span> 330&lt;span style="color:#f92672">]&lt;/span>, 99.95th&lt;span style="color:#f92672">=[&lt;/span> 988&lt;span style="color:#f92672">]&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> | 99.99th&lt;span style="color:#f92672">=[&lt;/span> 5276&lt;span style="color:#f92672">]&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># 基于一组样本的带宽信息(单位是 KiB/s):最小值，最大值，该线程在其组中接收的总聚合带宽的大约百分比，平均值，标准偏差，本次采样的样本总数&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> bw &lt;span style="color:#f92672">(&lt;/span> KiB/s&lt;span style="color:#f92672">)&lt;/span>: min&lt;span style="color:#f92672">=&lt;/span>113928, max&lt;span style="color:#f92672">=&lt;/span>149024, per&lt;span style="color:#f92672">=&lt;/span>99.98%, avg&lt;span style="color:#f92672">=&lt;/span>137137.07, stdev&lt;span style="color:#f92672">=&lt;/span>7370.84, samples&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">30&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># 基于一组样本的IOPS信息，与 bw 一样&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> iops : min&lt;span style="color:#f92672">=&lt;/span>28482, max&lt;span style="color:#f92672">=&lt;/span>37256, avg&lt;span style="color:#f92672">=&lt;/span>34284.27, stdev&lt;span style="color:#f92672">=&lt;/span>1842.71, samples&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">30&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># I/O 完成延迟的分布，这里的信息适用于一组报告的所有 I/O&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># 500=0.27% 表示 0.27% 的 I/O 在 500 微妙以内完成&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> lat &lt;span style="color:#f92672">(&lt;/span>usec&lt;span style="color:#f92672">)&lt;/span> : 100&lt;span style="color:#f92672">=&lt;/span>34.55%, 250&lt;span style="color:#f92672">=&lt;/span>65.12%, 500&lt;span style="color:#f92672">=&lt;/span>0.27%, 750&lt;span style="color:#f92672">=&lt;/span>0.01%, 1000&lt;span style="color:#f92672">=&lt;/span>0.01%
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> lat &lt;span style="color:#f92672">(&lt;/span>msec&lt;span style="color:#f92672">)&lt;/span> : 2&lt;span style="color:#f92672">=&lt;/span>0.01%, 4&lt;span style="color:#f92672">=&lt;/span>0.02%, 10&lt;span style="color:#f92672">=&lt;/span>0.02%, 20&lt;span style="color:#f92672">=&lt;/span>0.01%, 100&lt;span style="color:#f92672">=&lt;/span>0.01%
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># cpu 使用率&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> cpu : usr&lt;span style="color:#f92672">=&lt;/span>10.24%, sys&lt;span style="color:#f92672">=&lt;/span>23.20%, ctx&lt;span style="color:#f92672">=&lt;/span>189677, majf&lt;span style="color:#f92672">=&lt;/span>0, minf&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># IO 深度在整个工作周期中分布&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> IO depths : 1&lt;span style="color:#f92672">=&lt;/span>0.1%, 2&lt;span style="color:#f92672">=&lt;/span>0.1%, 4&lt;span style="color:#f92672">=&lt;/span>100.0%, 8&lt;span style="color:#f92672">=&lt;/span>0.0%, 16&lt;span style="color:#f92672">=&lt;/span>0.0%, 32&lt;span style="color:#f92672">=&lt;/span>0.0%, &amp;gt;&lt;span style="color:#f92672">=&lt;/span>64&lt;span style="color:#f92672">=&lt;/span>0.0%
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># 一个提交调用中要提交多少IO&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> submit : 0&lt;span style="color:#f92672">=&lt;/span>0.0%, 4&lt;span style="color:#f92672">=&lt;/span>100.0%, 8&lt;span style="color:#f92672">=&lt;/span>0.0%, 16&lt;span style="color:#f92672">=&lt;/span>0.0%, 32&lt;span style="color:#f92672">=&lt;/span>0.0%, 64&lt;span style="color:#f92672">=&lt;/span>0.0%, &amp;gt;&lt;span style="color:#f92672">=&lt;/span>64&lt;span style="color:#f92672">=&lt;/span>0.0%
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># 一个完成调用中要完成多少IO&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> complete : 0&lt;span style="color:#f92672">=&lt;/span>0.0%, 4&lt;span style="color:#f92672">=&lt;/span>100.0%, 8&lt;span style="color:#f92672">=&lt;/span>0.0%, 16&lt;span style="color:#f92672">=&lt;/span>0.0%, 32&lt;span style="color:#f92672">=&lt;/span>0.0%, 64&lt;span style="color:#f92672">=&lt;/span>0.0%, &amp;gt;&lt;span style="color:#f92672">=&lt;/span>64&lt;span style="color:#f92672">=&lt;/span>0.0%
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># 发出的读取/写入/修剪请求的数量，以及其中有多少个请求被缩短或丢弃。&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> issued rwts: total&lt;span style="color:#f92672">=&lt;/span>0,524288,0,0 short&lt;span style="color:#f92672">=&lt;/span>0,0,0,0 dropped&lt;span style="color:#f92672">=&lt;/span>0,0,0,0
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> latency : target&lt;span style="color:#f92672">=&lt;/span>0, window&lt;span style="color:#f92672">=&lt;/span>0, percentile&lt;span style="color:#f92672">=&lt;/span>100.00%, depth&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">4&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># 在上面将所有 Job 的统计信息都列出来之后，这下面显示所有 Job 最终的统计信息。这些数据是所有 Job 的平均值。&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Run status group &lt;span style="color:#ae81ff">0&lt;/span> &lt;span style="color:#f92672">(&lt;/span>all jobs&lt;span style="color:#f92672">)&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># 本次测试的模式(写测试)：带宽平均值，带宽最小值-带宽最大值，io(i.e.读写数据的总量)，运行时间&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># 括号外的值是2的幂的格式，括号中的值是10的幂的等效值&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> WRITE: bw&lt;span style="color:#f92672">=&lt;/span>134MiB/s &lt;span style="color:#f92672">(&lt;/span>140MB/s&lt;span style="color:#f92672">)&lt;/span>, 134MiB/s-134MiB/s &lt;span style="color:#f92672">(&lt;/span>140MB/s-140MB/s&lt;span style="color:#f92672">)&lt;/span>, io&lt;span style="color:#f92672">=&lt;/span>2048MiB &lt;span style="color:#f92672">(&lt;/span>2147MB&lt;span style="color:#f92672">)&lt;/span>, run&lt;span style="color:#f92672">=&lt;/span>15289-15289msec
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># 当前测试数据所在磁盘的统计信息&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># ios 表示所有组执行的 I/O 数，ios就是 I/Os。&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># merge 表示 I/O 调度程序执行的合并数。&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># ticks 表示我们保持磁盘活跃的 ticks 数。&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># in_queue 表示在磁盘队列中花费的总时间&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># util 表示磁盘利用率。在命令执行期间 100％表示我们使磁盘一直处于繁忙状态，而50％的磁盘将有一半的时间处于空闲状态&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># aggr 前缀的信息官方没有说明,应该是聚合的意思&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Disk stats &lt;span style="color:#f92672">(&lt;/span>read/write&lt;span style="color:#f92672">)&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> dm-0: ios&lt;span style="color:#f92672">=&lt;/span>0/519394, merge&lt;span style="color:#f92672">=&lt;/span>0/0, ticks&lt;span style="color:#f92672">=&lt;/span>0/47273, in_queue&lt;span style="color:#f92672">=&lt;/span>47273, util&lt;span style="color:#f92672">=&lt;/span>97.70%, aggrios&lt;span style="color:#f92672">=&lt;/span>0/524290, aggrmerge&lt;span style="color:#f92672">=&lt;/span>0/0, aggrticks&lt;span style="color:#f92672">=&lt;/span>0/48534, aggrin_queue&lt;span style="color:#f92672">=&lt;/span>1310, aggrutil&lt;span style="color:#f92672">=&lt;/span>97.56%
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> vda: ios&lt;span style="color:#f92672">=&lt;/span>0/524290, merge&lt;span style="color:#f92672">=&lt;/span>0/0, ticks&lt;span style="color:#f92672">=&lt;/span>0/48534, in_queue&lt;span style="color:#f92672">=&lt;/span>1310, util&lt;span style="color:#f92672">=&lt;/span>97.56%
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>可以看到，在一个非常强悍的 Optane 盘上面，使用 sync engine，每次都 sync 写盘，性能还是很差的，吞吐不到 300 MB，其他的盘可能就更差了。我们主要关注几个指标：&lt;/p>
&lt;p>slat/clat/lat：这几个是 latency 指标，slat 就是 Submission latency，也就是提交到实际执行 I/O 的时间，在 sync 测试里面这个是没有的，因为 slat 就是 clat。clat 就是 Completion latency，也就是从提交到完成的时间。lat 就是 Total latency，包括 fio 从创建这个 I/O 单元到完成的总的时间。&lt;/p>
&lt;p>另外需要关注的指标就是 BW，和 IOPS，这两这个很直观了，就不解释了。最下面是 ios，也就是总的 I/O 操作次数，merge 就是被 I/O 调度合并的次数，ticks 就是让磁盘保持忙碌的次数，in_queue 就是总的在磁盘队列里面的耗时，而 util 则是磁盘的利用率。&lt;/p>
&lt;h2 id="其他测试命令">其他测试命令&lt;/h2>
&lt;p>fio &amp;ndash;filename=/dev/vdb -direct=1 -bs=1M -rw=randwrite -ioengine=libaio -size=50g -numjobs=32 -iodepth=32  -group_reporting -name=mytest -thread &amp;ndash;time_based &amp;ndash;runtime=120&lt;/p>
&lt;p>&lt;a href="https://mp.weixin.qq.com/s/zpkheD6Izn0RsipSukHA5Q">https://mp.weixin.qq.com/s/zpkheD6Izn0RsipSukHA5Q&lt;/a>&lt;/p></description></item><item><title>Docs: Httperf # Web 压力测试</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/x.linux-%E7%AE%A1%E7%90%86/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E4%B8%8E%E6%95%85%E9%9A%9C%E5%A4%84%E7%90%86/%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95/httperf-#-web-%E5%8E%8B%E5%8A%9B%E6%B5%8B%E8%AF%95/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/x.linux-%E7%AE%A1%E7%90%86/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E4%B8%8E%E6%95%85%E9%9A%9C%E5%A4%84%E7%90%86/%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95/httperf-#-web-%E5%8E%8B%E5%8A%9B%E6%B5%8B%E8%AF%95/</guid><description>
&lt;h1 id="heading">&lt;/h1>
&lt;p>Web 压力测试 - Httperf&lt;/p>
&lt;p>Httperf 比 ab 更强大，能测试出 web 服务能承载的最大服务量及发现潜在问题；比如：内存使用、稳定性。最大优势：可以指定规律进行压力测试，模拟真实环境。&lt;/p>
&lt;p>下载：&lt;a href="http://code.google.com/p/httperf/downloads/list">http://code.google.com/p/httperf/downloads/list&lt;/a>&lt;/p>
&lt;ol>
&lt;li>[root@localhost ~]# tar zxvf httperf-0.9.0.tar.gz&lt;/li>
&lt;li>[root@localhost ~]# cd httperf-0.9.0&lt;/li>
&lt;li>[root@localhost httperf-0.9.0]# ./configure&lt;/li>
&lt;li>[root@localhost httperf-0.9.0]# make &amp;amp;&amp;amp; make install&lt;/li>
&lt;li>[root@localhost ~]# httperf &amp;ndash;hog &amp;ndash;server=192.168.0.202 &amp;ndash;uri=/index.html &amp;ndash;num-conns=10000 &amp;ndash;wsess=10,10,0.1&lt;/li>
&lt;/ol>
&lt;p>参数说明：&lt;/p>
&lt;ul>
&lt;li>--hog：让 httperf 尽可能多产生连接，httperf 会根据硬件配置，有规律的产生访问连接&lt;/li>
&lt;li>--num-conns：连接数量，总发起 10000 请求&lt;/li>
&lt;li>--wsess：用户打开网页时间规律模拟，第一个 10 表示产生 10 个会话连接，第二个 10 表示每个会话连接进行 10 次请求，0.1 表示每个会话连接请求之间的间隔时间 / s&lt;/li>
&lt;/ul></description></item><item><title>Docs: iperf 网络性能测量和调整工具</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/x.linux-%E7%AE%A1%E7%90%86/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E4%B8%8E%E6%95%85%E9%9A%9C%E5%A4%84%E7%90%86/%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95/iperf-%E7%BD%91%E7%BB%9C%E6%80%A7%E8%83%BD%E6%B5%8B%E9%87%8F%E5%92%8C%E8%B0%83%E6%95%B4%E5%B7%A5%E5%85%B7/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/x.linux-%E7%AE%A1%E7%90%86/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E4%B8%8E%E6%95%85%E9%9A%9C%E5%A4%84%E7%90%86/%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95/iperf-%E7%BD%91%E7%BB%9C%E6%80%A7%E8%83%BD%E6%B5%8B%E9%87%8F%E5%92%8C%E8%B0%83%E6%95%B4%E5%B7%A5%E5%85%B7/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://iperf.fr/">官网&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>在 server 端监听某个端口，然后 client 用同样的 iperf 访问服务端，来进行性能测试&lt;/p>
&lt;p>所以该工具需要在两台设备之间一同使用，其中一台作为服务端，另外一台作为客户端，两端互相通信，才可测试网络性能。而命令行的 OPTIONS 也是分为全局、服务端特定、客户端特定 这三类&lt;/p>
&lt;h1 id="syntax语法">Syntax(语法)&lt;/h1>
&lt;p>&lt;strong>iperf3 &amp;lt;-s | -c HOST&amp;gt; [OPTIONS]&lt;/strong>&lt;/p>
&lt;p>&lt;strong>通用选项&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>&lt;strong>-p, &amp;ndash;port&lt;/strong> # 指定服务端监听的端口或者客户端要连接的端口&lt;/li>
&lt;li>&lt;strong>-f, &amp;ndash;format [kmgKMG]&lt;/strong> # 指定输出格式。可以是：Kbits, Mbits, KBytes, MBytes&lt;/li>
&lt;li>&lt;strong>-i, &amp;ndash;interval&lt;/strong> # 指定每次带宽报告间隔的秒数。i.e.每隔几秒输出一次数据。默认每 1 秒报告一次&lt;/li>
&lt;li>-F, &amp;ndash;file name # xmit/recv the specified file&lt;/li>
&lt;li>-A, &amp;ndash;affinity n/n,m # set CPU affinity&lt;/li>
&lt;li>-B, &amp;ndash;bind &lt;!-- raw HTML omitted --> # bind to a specific interface&lt;/li>
&lt;li>-V, &amp;ndash;verbose # more detailed output&lt;/li>
&lt;li>-J, &amp;ndash;json # output in JSON format&lt;/li>
&lt;li>--logfile f # send output to a log file&lt;/li>
&lt;li>--forceflush # force flushing output at every interval&lt;/li>
&lt;li>-d, &amp;ndash;debug # emit debugging output&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>服务端的特定选项&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>&lt;strong>-s, &amp;ndash;server&lt;/strong> # 在服务器模式下运行 iperf3，默认程序监听在 5201 端口上&lt;/li>
&lt;li>&lt;strong>-D, &amp;ndash;daemon&lt;/strong> # 以守护进程的形式运行服务端&lt;/li>
&lt;li>-I, &amp;ndash;pidfile file # write PID file&lt;/li>
&lt;li>-1, &amp;ndash;one-off # handle one client connection then exit&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>客户端的特定选项&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>&lt;strong>-c, &amp;ndash;client &lt;!-- raw HTML omitted -->&lt;/strong> # 在客户端模式下运行 iperf3，并连接到指定的服务端主机 HOST&lt;/li>
&lt;li>&lt;strong>-u, &amp;ndash;udp&lt;/strong> # 使用 UPD 模式进行测试。默认为 TCP&lt;/li>
&lt;li>&lt;strong>-b, &amp;ndash;bandwidth &lt;!-- raw HTML omitted -->&lt;/strong> # 指定目标带宽上限，单位是 bits/s（0 表示无限制）（UDP 默认为 1 Mbit / sec，TCP 无限制）
&lt;ul>
&lt;li>该选项为每个线程的带宽上限，比如我如果 -P 选项为 2，-b 为 100M ，那么当前测试每个线程的带宽上限为 100M，总上限 200M&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>--fq-rate #[KMG]enable fair-queuing based socket pacing in bits/sec (Linux only)&lt;/li>
&lt;li>&lt;strong>-t, &amp;ndash;time&lt;/strong> # 指定传输数据的总时间。(默认为 10 秒)&lt;/li>
&lt;li>&lt;strong>-n, &amp;ndash;bytes [KMG]&lt;/strong> # 要传输的字节数 (不可与 -t 选项同用)&lt;/li>
&lt;li>-k, &amp;ndash;blockcount [KMG] # number of blocks (packets) to transmit (instead of -t or -n)&lt;/li>
&lt;li>-l, &amp;ndash;len [KMG] # length of buffer to read or write (default 128 KB for TCP, dynamic or 1 for UDP)&lt;/li>
&lt;li>--cport &lt;!-- raw HTML omitted --> # bind to a specific client port (TCP and UDP, default: ephemeral port)&lt;/li>
&lt;li>&lt;strong>-P, &amp;ndash;parallel &lt;!-- raw HTML omitted -->&lt;/strong> # 并发数&lt;/li>
&lt;li>-R, &amp;ndash;reverse # run in reverse mode (server sends, client receives)&lt;/li>
&lt;li>-w, &amp;ndash;window [KMG] # set window size / socket buffer size&lt;/li>
&lt;li>-C, &amp;ndash;congestion &lt;!-- raw HTML omitted --> #set TCP congestion control algorithm (Linux and FreeBSD only)&lt;/li>
&lt;li>-M, &amp;ndash;set-mss # set TCP/SCTP maximum segment size (MTU - 40 bytes)&lt;/li>
&lt;li>-N, &amp;ndash;no-delay # set TCP/SCTP no delay, disabling Nagle&amp;rsquo;s Algorithm&lt;/li>
&lt;li>-4, &amp;ndash;version4 only use IPv4&lt;/li>
&lt;li>-6, &amp;ndash;version6 only use IPv6&lt;/li>
&lt;li>-S, &amp;ndash;tos N set the IP &amp;rsquo;type of service'&lt;/li>
&lt;li>-L, &amp;ndash;flowlabel N set the IPv6 flow label (only supported on Linux)&lt;/li>
&lt;li>-Z, &amp;ndash;zerocopy use a &amp;lsquo;zero copy&amp;rsquo; method of sending data&lt;/li>
&lt;li>-O, &amp;ndash;omit N omit the first n seconds&lt;/li>
&lt;li>-T, &amp;ndash;title str prefix every output line with this string&lt;/li>
&lt;li>--get-server-output get results from server&lt;/li>
&lt;li>--udp-counters-64bit use 64-bit counters in UDP test packets&lt;/li>
&lt;/ul>
&lt;h1 id="应用实例">应用实例&lt;/h1>
&lt;h2 id="基础用法">基础用法&lt;/h2>
&lt;p>服务端命令：iperf3 -s
客户端命令：iperf3 -c 10.10.100.250&lt;/p>
&lt;p>这时候服务端的 iperf3 程序会监听在 5201 端口上，客户端会访问服务端(这里 ip 是 10.10.100.250)的 2501 端口进行网络测试，测试效果如图
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/fdemaq/1616164267994-3d8e4e2d-0c26-4b52-8054-12aeac917398.png" alt="">
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/fdemaq/1616164268013-f44eee21-25f2-48a5-acad-07b32cf7af7a.png" alt="">
客户端每秒会往服务端发送一次数据，Interval 表示时间间隔，Transfer 表示传输的数据量，Bandwidth 表示带宽的大小，Retr 表示重传次数&lt;/p>
&lt;p>在客户端的最后两行表示 10 秒钟的传送的总数据量，以及平均带宽，第一行是发送的，第二行是接收的。这次测试结果就是两台服务器之间最大带宽是 20G&lt;/p>
&lt;h2 id="查看网络丢包率和延迟">查看网络丢包率和延迟&lt;/h2>
&lt;p>服务端命令：iperf3 -s
客户端命令：iperf3 -c 10.10.100.250 -u -b 10M -t 10 -i 1 -P 100
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/fdemaq/1616164268023-89190ba4-c7a7-4587-b4f7-389086f5d465.png" alt="">
Jitter 表示抖动 i.e.数据包延迟时间。Lost/Total Datagrams 表示“丢失/总数据包”的数量，扩内的百分比为丢包率。&lt;/p>
&lt;h2 id="吞吐测试">吞吐测试&lt;/h2>
&lt;p>服务端命令：iperf3 -s -i 1 -p 10000
客户端命令：iperf3 -c 172.19.42.221 -p 10000 -b 1G -t 15 -P 2&lt;/p>
&lt;pre>&lt;code>[ ID] Interval Transfer Bandwidth Retr
[ 4] 0.00-15.00 sec 781 MBytes 437 Mbits/sec 4856 sender
[ 4] 0.00-15.00 sec 779 MBytes 436 Mbits/sec receiver
[ 6] 0.00-15.00 sec 876 MBytes 490 Mbits/sec 7074 sender
[ 6] 0.00-15.00 sec 874 MBytes 489 Mbits/sec receiver
[SUM] 0.00-15.00 sec 1.62 GBytes 927 Mbits/sec 11930 sender
[SUM] 0.00-15.00 sec 1.61 GBytes 925 Mbits/sec receiver
&lt;/code>&lt;/pre>
&lt;p>TCP 吞吐(带宽)大概为 900+M，也就是千兆基本 能跑慢&lt;/p></description></item><item><title>Docs: K6</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/x.linux-%E7%AE%A1%E7%90%86/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E4%B8%8E%E6%95%85%E9%9A%9C%E5%A4%84%E7%90%86/%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95/k6/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/x.linux-%E7%AE%A1%E7%90%86/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E4%B8%8E%E6%95%85%E9%9A%9C%E5%A4%84%E7%90%86/%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95/k6/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://github.com/grafana/k6">GitHub 项目，grafana/k6&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://k6.io/">官网&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://mp.weixin.qq.com/s/jb8-8Uo3UBla6whiUEWdqw">公众号，MoeLove-Grafana k6 的上手实践&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>使用 Go 和 JavaScript 语言实现的现代负载测试工具。&lt;/p>
&lt;h2 id="背景">背景&lt;/h2>
&lt;p>2016 年 8 月，k6 在 GitHub 上发布了第一个版本，至此，一个出色的开源负载压测工具进入了人们的视野。&lt;/p>
&lt;p>2021 年的 6 月，对于 Grafana 和 k6 来讲是个大日子，Grafana Labs 收购了 k6 。&lt;/p>
&lt;p>而事实上， Grafana 与 k6 的缘分还要追溯到更早的 2 年前。&lt;/p>
&lt;p>2019 年，在进行 Grafana 6.0 的短期令牌刷新行为的压测时，Grafana Labs 进行了一系列的技术选型。&lt;/p>
&lt;p>由于 Grafana Labs 的大部分后端软件是使用 Go 来实现的，恰巧 k6 满足 OSS 和 Go 需求，并且负载测试是使用 JS 编写（Grafana 前端框架及 UI 都在使用）。这使得 k6 自 Grafana 6.0 版本开始，不断地为 Grafana 开发者及测试者完成追踪 bug 的使命。&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/9ca3cf4f-fa39-421c-bd25-ca04a9d9d9d4/640" alt="">&lt;/p>
&lt;p>img&lt;/p>
&lt;p>图 1 ，k6 加入 Grafana Labs&lt;/p>
&lt;h2 id="多样的压测工具">多样的压测工具&lt;/h2>
&lt;p>一个称心应手的自动化负载压测工具会极大的提升程序开发人员的代码质量及效率。&lt;/p>
&lt;p>下图中是一些比较常见的用于负载压测的工具，我们可以在 GitHub 上看到，目前，更新比较频繁、活跃的项目主要有：Gatling, Jmeter 和 k6 。&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/9ca3cf4f-fa39-421c-bd25-ca04a9d9d9d4/640" alt="">&lt;/p>
&lt;p>img&lt;/p>
&lt;p>图 2 ，压测工具们&lt;/p>
&lt;p>如何从中选择，简单的讲就是工具效率的比拼。主要从以下两个方面来考量：&lt;/p>
&lt;ul>
&lt;li>工具性能&lt;/li>
&lt;li>工具使用体验&lt;/li>
&lt;/ul>
&lt;p>下图对以上工具进行了一些简单的对比。&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/9ca3cf4f-fa39-421c-bd25-ca04a9d9d9d4/640" alt="">&lt;/p>
&lt;p>img&lt;/p>
&lt;p>这里我主要对比下其中较为活跃的 3 个项目。&lt;/p>
&lt;ul>
&lt;li>JMeter - 熟悉 Java 的小伙伴可能比较了解这个工具。由于存在时间久，JMeter 的功能是这之中最全面的，并且集成、附加组件做的较好。基于它构建的 SaaS 服务 Blazemeter，相信大家也都熟识。这也导致了一个极大的问题，使用的复杂性高及不够轻量级；&lt;/li>
&lt;li>Gatling - Gatling 也有着 SaaS 产品 Gatling Frontline。就使用门槛来讲，JS 要比 Scala 要低很多；&lt;/li>
&lt;li>k6 - k6 最初是由 SaaS 服务 Load Impact 的几名员工开发维护。使用门槛低（JS），参数化更简单，并且 “负载测试即代码” 的理念也让他的维护成本更低。未来可期。&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/9ca3cf4f-fa39-421c-bd25-ca04a9d9d9d4/640" alt="">&lt;/p>
&lt;p>img&lt;/p>
&lt;p>图 3 ，3 种热门工具比一比&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/9ca3cf4f-fa39-421c-bd25-ca04a9d9d9d4/640" alt="">&lt;/p>
&lt;p>img&lt;/p>
&lt;p>或者这样：&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/9ca3cf4f-fa39-421c-bd25-ca04a9d9d9d4/640" alt="">&lt;/p>
&lt;p>img&lt;/p>
&lt;p>k6 是用 Go 语言开发的，要安装 k6 步骤很简单，只要直接在其 GitHub 的 Release 页面下载二进制文件即可。比如：&lt;/p>
&lt;p>&lt;code>(MoeLove) ➜ wget -q https://github.com/grafana/k6/releases/download/v0.35.0/k6-v0.35.0-linux-amd64.tar.gz  (MoeLove) ➜ tar -xzf k6-v0.35.0-linux-amd64.tar.gz  (MoeLove) ➜ ls k6-v0.35.0-linux-amd64  k6-v0.35.0-linux-amd64.tar.gz (MoeLove) ➜ mv ./k6-v0.35.0-linux-amd64/k6 ~/bin/k6 (MoeLove) ➜ k6 version k6 v0.35.0 (2021-11-17T09:53:18+0000/1c44b2d, go1.17.3, linux/amd64)&lt;/code>&lt;/p>
&lt;p>或者也可以直接使用它的 Docker 镜像：&lt;/p>
&lt;p>&lt;code>➜  ~ docker run  --rm loadimpact/k6  version    k6 v0.35.0 (2021-11-17T09:53:03+0000/1c44b2d, go1.17.3, linux/amd64)&lt;/code>&lt;/p>
&lt;p>在 k6 中并没有太多的概念。其中最主要的就是用来执行测试的  virtual users (VUs) ，它的本质就是并发执行任务的次数。&lt;/p>
&lt;p>在使用 k6 执行测试的时候，可以通过 &lt;code>--vus&lt;/code>或者 &lt;code>-u&lt;/code>进行指定，默认是 1 。&lt;/p>
&lt;p>我个人感觉 k6 在目前的这些主流压测工具中算用户体验比较好的一个。它使用 JS（ES6）作为配置语言，还是比较方便的，我们来做一些示例。&lt;/p>
&lt;h2 id="简单请求">简单请求&lt;/h2>
&lt;p>如果对于进行 HTTP 请求的时候，我们只需要从 &lt;code>k6/http&lt;/code> 导入 &lt;code>http&lt;/code>即可。&lt;/p>
&lt;p>注意在 k6 中，默认情况下必须得有个作为入口的 &lt;code>default&lt;/code>函数，这类似我们常用的 &lt;code>main&lt;/code>函数。&lt;/p>
&lt;p>`import http from &amp;ldquo;k6/http&amp;rdquo;;&lt;/p>
&lt;p>export default function(){
  http.get(&amp;quot;&lt;a href="https://test-api.k6.io/public/crocodiles/">https://test-api.k6.io/public/crocodiles/&lt;/a>&amp;quot;)
}&lt;/p>
&lt;p>`&lt;/p>
&lt;p>执行后效果如下：&lt;/p>
&lt;p>`(MoeLove) ➜ k6 run simple_http_get.js&lt;/p>
&lt;p>/\      |‾‾| /‾‾/   /‾‾/   
     /\  /  \     |  |/  /   /  /    
    /  /    \    |     (   /   ‾‾\  
   /          \   |  |\  \ |  (‾)  | 
  / ** \  |**| __\ _/ .io&lt;/p>
&lt;p>execution: local
     script: simple_http_get.js
     output: -&lt;/p>
&lt;p>scenarios: (100.00%) 1 scenario, 1 max VUs, 10m30s max duration (incl. graceful stop):
           * default: 1 iterations for each of 1 VUs (maxDuration: 10m0s, gracefulStop: 30s)&lt;/p>
&lt;p>running (00m01.1s), 0/1 VUs, 1 complete and 0 interrupted iterations
default ✓ [======================================] 1 VUs  00m01.1s/10m0s  1/1 iters, 1 per VU&lt;/p>
&lt;p>data_received&amp;hellip;&amp;hellip;&amp;hellip;&amp;hellip;&amp;hellip;&amp;hellip;: 6.3 kB 5.7 kB/s
     data_sent&amp;hellip;&amp;hellip;&amp;hellip;&amp;hellip;&amp;hellip;&amp;hellip;&amp;hellip;.: 634 B  578 B/s
     http_req_blocked&amp;hellip;&amp;hellip;&amp;hellip;&amp;hellip;&amp;hellip;: avg=848.34ms min=848.34ms med=848.34ms max=848.34ms p(90)=848.34ms p(95)=848.34ms
     http_req_connecting&amp;hellip;&amp;hellip;&amp;hellip;&amp;hellip;: avg=75.59µs  min=75.59µs  med=75.59µs  max=75.59µs  p(90)=75.59µs  p(95)=75.59µs 
     http_req_duration&amp;hellip;&amp;hellip;&amp;hellip;&amp;hellip;..: avg=247.46ms min=247.46ms med=247.46ms max=247.46ms p(90)=247.46ms p(95)=247.46ms
       { expected_response:true }&amp;hellip;: avg=247.46ms min=247.46ms med=247.46ms max=247.46ms p(90)=247.46ms p(95)=247.46ms
     http_req_failed&amp;hellip;&amp;hellip;&amp;hellip;&amp;hellip;&amp;hellip;.: 0.00%  ✓ 0        ✗ 1  
     http_req_receiving&amp;hellip;&amp;hellip;&amp;hellip;&amp;hellip;.: avg=455.24µs min=455.24µs med=455.24µs max=455.24µs p(90)=455.24µs p(95)=455.24µs
     http_req_sending&amp;hellip;&amp;hellip;&amp;hellip;&amp;hellip;&amp;hellip;: avg=103.77µs min=103.77µs med=103.77µs max=103.77µs p(90)=103.77µs p(95)=103.77µs
     http_req_tls_handshaking&amp;hellip;&amp;hellip;.: avg=848.07ms min=848.07ms med=848.07ms max=848.07ms p(90)=848.07ms p(95)=848.07ms
     http_req_waiting&amp;hellip;&amp;hellip;&amp;hellip;&amp;hellip;&amp;hellip;: avg=246.9ms  min=246.9ms  med=246.9ms  max=246.9ms  p(90)=246.9ms  p(95)=246.9ms 
     http_reqs&amp;hellip;&amp;hellip;&amp;hellip;&amp;hellip;&amp;hellip;&amp;hellip;&amp;hellip;.: 1      0.911502/s
     iteration_duration&amp;hellip;&amp;hellip;&amp;hellip;&amp;hellip;.: avg=1.09s    min=1.09s    med=1.09s    max=1.09s    p(90)=1.09s    p(95)=1.09s   
     iterations&amp;hellip;&amp;hellip;&amp;hellip;&amp;hellip;&amp;hellip;&amp;hellip;&amp;hellip;: 1      0.911502/s
     vus&amp;hellip;&amp;hellip;&amp;hellip;&amp;hellip;&amp;hellip;&amp;hellip;&amp;hellip;&amp;hellip;&amp;hellip;.: 1      min=1      max=1
     vus_max&amp;hellip;&amp;hellip;&amp;hellip;&amp;hellip;&amp;hellip;&amp;hellip;&amp;hellip;&amp;hellip;: 1      min=1      max=1&lt;/p>
&lt;p>`&lt;/p>
&lt;p>k6 默认会将执行后的结果输出到终端。同时它自带了一些指标会同时输出。&lt;/p>
&lt;p>这些指标基本上都是语义化的，看名字就可以理解其含义，这里就不一一介绍了。&lt;/p>
&lt;h2 id="带检查的请求">带检查的请求&lt;/h2>
&lt;p>我们可以在请求中同时增加一些测试，判断接口的响应值是否符合我们的预期。如下：&lt;/p>
&lt;p>`import http from &amp;ldquo;k6/http&amp;rdquo;;
import { check, group } from &amp;ldquo;k6&amp;rdquo;;&lt;/p>
&lt;p>export default function() {&lt;/p>
&lt;p>group(&amp;ldquo;GET&amp;rdquo;, function() {
        let res = http.get(&amp;quot;&lt;a href="http://httpbin.org/get?verb=get">http://httpbin.org/get?verb=get&lt;/a>&amp;quot;);
        check(res, {
            &amp;ldquo;status is 200&amp;rdquo;: (r) =&amp;gt; r.status === 200,
            &amp;ldquo;is verb correct&amp;rdquo;: (r) =&amp;gt; r.json().args.verb === &amp;ldquo;get&amp;rdquo;,
        });
    });
}&lt;/p>
&lt;p>`&lt;/p>
&lt;p>通过引入了 &lt;code>check&lt;/code>函数，来执行一些判断的逻辑，当然上述的 &lt;code>==&amp;gt;&lt;/code> 其实是 ES6 中的一种简写，将其展开为正常的函数也可以。比如：&lt;/p>
&lt;p>`import http from &amp;ldquo;k6/http&amp;rdquo;;
import { check, group } from &amp;ldquo;k6&amp;rdquo;;&lt;/p>
&lt;p>export default function() {&lt;/p>
&lt;p>group(&amp;ldquo;GET&amp;rdquo;, function() {
        let res = http.get(&amp;quot;&lt;a href="http://httpbin.org/get?verb=get">http://httpbin.org/get?verb=get&lt;/a>&amp;quot;);
        check(res, {
          &amp;ldquo;status is 200&amp;rdquo;: function(r){
             return r.status === 200
          },
            &amp;ldquo;is verb correct&amp;rdquo;: (r) =&amp;gt; r.json().args.verb === &amp;ldquo;get&amp;rdquo;,
        });
    });
}&lt;/p>
&lt;p>`&lt;/p>
&lt;p>使用 k6 执行此脚本后，得到的输出相比之前的多了如下内容：&lt;/p>
&lt;p>`     █ GET&lt;/p>
&lt;p>✓ status is 200
       ✓ is verb correct&lt;/p>
&lt;p>checks&amp;hellip;&amp;hellip;&amp;hellip;&amp;hellip;&amp;hellip;&amp;hellip;&amp;hellip;&amp;hellip;.: 100.00% ✓ 2        ✗ 0&lt;/p>
&lt;p>`&lt;/p>
&lt;p>从这里可以看到我们当前请求接口的测试是否通过（也可以用来判断当前接口是否能正常提供服务）。&lt;/p>
&lt;h2 id="自定义指标输出">自定义指标输出&lt;/h2>
&lt;p>接下来我们尝试下在压测过程中定义一些自己定的指标。只需要从 &lt;code>k6/metrics&lt;/code>中导入一些不同类型的指标即可。这和在 Prometheus 中的类型基本一致。&lt;/p>
&lt;p>这里我增加了两个 metric。一个 &lt;code>testCounter&lt;/code>用于统计一共执行了多少次测试， &lt;code>passedRate&lt;/code>计算通过率。&lt;/p>
&lt;p>`import http from &amp;ldquo;k6/http&amp;rdquo;;
import { Counter, Rate } from &amp;ldquo;k6/metrics&amp;rdquo;;
import { check, group } from &amp;ldquo;k6&amp;rdquo;;&lt;/p>
&lt;p>let testCounter = new Counter(&amp;ldquo;test_counter&amp;rdquo;);
let passedRate = new Rate(&amp;ldquo;passed_rate&amp;rdquo;);&lt;/p>
&lt;p>export default function() {&lt;/p>
&lt;p>group(&amp;ldquo;GET&amp;rdquo;, function() {
        let res = http.get(&amp;quot;&lt;a href="http://httpbin.org/get?verb=get">http://httpbin.org/get?verb=get&lt;/a>&amp;quot;);
        let passed = check(res, {
            &amp;ldquo;status is 200&amp;rdquo;: (r) =&amp;gt; r.status === 200,
            &amp;ldquo;is verb correct&amp;rdquo;: (r) =&amp;gt; r.json().args.verb === &amp;ldquo;get&amp;rdquo;,
        });&lt;/p>
&lt;p>testCounter.add(1);
        passedRate.add(passed);
    });
}&lt;/p>
&lt;p>`&lt;/p>
&lt;p>这里我们设置了 2 个 VU， 以及设置了执行过程为 &lt;code>10s&lt;/code> 执行后的输出如下：&lt;/p>
&lt;p>&lt;code>(MoeLove) ➜ k6 run -u 2 -d 10s  simple_custom_metrics.js...  execution: local     script: simple_custom_metrics.js     output: -  scenarios: (100.00%) 1 scenario, 2 max VUs, 40s max duration (incl. graceful stop):           * default: 2 looping VUs for 10s (gracefulStop: 30s)running (10.4s), 0/2 VUs, 36 complete and 0 interrupted iterationsdefault ✓ [======================================] 2 VUs  10s     █ GET       ✓ status is 200       ✓ is verb correct     checks.........................: 100.00% ✓ 72       ✗ 0       data_received..................: 18 kB   1.7 kB/s     data_sent......................: 3.9 kB  372 B/s     group_duration.................: avg=567.35ms min=440.56ms med=600.52ms max=738.73ms p(90)=620.88ms p(95)=655.17ms     http_req_blocked...............: avg=266.72µs min=72.33µs  med=135.14µs max=776.66µs p(90)=644.4µs  p(95)=719.96µs     http_req_connecting............: avg=170.04µs min=45.51µs  med=79.9µs   max=520.69µs p(90)=399.41µs p(95)=463.55µs     http_req_duration..............: avg=566.82ms min=439.69ms med=600.31ms max=738.16ms p(90)=620.52ms p(95)=654.61ms       { expected_response:true }...: avg=566.82ms min=439.69ms med=600.31ms max=738.16ms p(90)=620.52ms p(95)=654.61ms     http_req_failed................: 0.00%   ✓ 0        ✗ 36      http_req_receiving.............: avg=309.13µs min=122.4µs  med=231.72µs max=755.3µs  p(90)=597.95µs p(95)=641.92µs     http_req_sending...............: avg=80.69µs  min=20.47µs  med=38.91µs  max=235.1µs  p(90)=197.87µs p(95)=214.79µs     http_req_tls_handshaking.......: avg=0s       min=0s       med=0s       max=0s       p(90)=0s       p(95)=0s           http_req_waiting...............: avg=566.43ms min=439.31ms med=600.16ms max=737.8ms  p(90)=620.19ms p(95)=654.18ms     http_reqs......................: 36      3.472534/s     iteration_duration.............: avg=567.38ms min=440.62ms med=600.53ms max=738.75ms p(90)=620.89ms p(95)=655.2ms      iterations.....................: 36      3.472534/s     passed_rate....................: 100.00% ✓ 36       ✗ 0       test_counter...................: 36      3.472534/s     vus............................: 2       min=2      max=2     vus_max........................: 2       min=2      max=2&lt;/code>&lt;/p>
&lt;p>可以看到在输出中多了两行：&lt;/p>
&lt;p>&lt;code>passed_rate....................: 100.00% ✓ 36       ✗ 0        test_counter...................: 36      3.472534/s&lt;/code>&lt;/p>
&lt;p>与我们的预期相符。&lt;/p>
&lt;p>不过这样看起来不够直观，我们可以尝试使用 k6 Cloud 来展示结果。登陆后，只要在执行 k6 时，通过 &lt;code>-o cloud&lt;/code>的方式将输出指定到 cloud 就可以在 cloud 上看到所有的指标了&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/9ca3cf4f-fa39-421c-bd25-ca04a9d9d9d4/640" alt="">&lt;/p>
&lt;p>img&lt;/p>
&lt;p>本篇主要是在介绍一个现代化的用户体验相对较好的压测工具 k6 。我目前正在计划将其引入到我们项目的 CI 中，以便了解每次核心部分的变更对项目性能的影响。&lt;/p>
&lt;p>后续推进顺利的话，会再分享 k6 如何应用到 CI 环境中，敬请期待。&lt;/p>
&lt;hr>
&lt;p>欢迎订阅我的文章公众号【MoeLove】&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/9ca3cf4f-fa39-421c-bd25-ca04a9d9d9d4/640" alt="">&lt;/p>
&lt;p>TheMoeLove&lt;/p></description></item><item><title>Docs: pktgen 内核自带的高性能网络测试工具</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/x.linux-%E7%AE%A1%E7%90%86/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E4%B8%8E%E6%95%85%E9%9A%9C%E5%A4%84%E7%90%86/%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95/pktgen-%E5%86%85%E6%A0%B8%E8%87%AA%E5%B8%A6%E7%9A%84%E9%AB%98%E6%80%A7%E8%83%BD%E7%BD%91%E7%BB%9C%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/x.linux-%E7%AE%A1%E7%90%86/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E4%B8%8E%E6%95%85%E9%9A%9C%E5%A4%84%E7%90%86/%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95/pktgen-%E5%86%85%E6%A0%B8%E8%87%AA%E5%B8%A6%E7%9A%84%E9%AB%98%E6%80%A7%E8%83%BD%E7%BD%91%E7%BB%9C%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/</guid><description>
&lt;h1 id="heading">&lt;/h1>
&lt;h1 id="pktgen-内核自带的高性能网络测试工具">pktgen 内核自带的高性能网络测试工具&lt;/h1>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>modprobe pktgen
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>cat &amp;gt; /usr/local/bin/pgset &lt;span style="color:#e6db74">&amp;lt;&amp;lt;EOF
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">local result
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">echo $1 &amp;gt; $PGDEV
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">result=`cat $PGDEV | fgrep &amp;#34;Result: OK:&amp;#34;`
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">if [ &amp;#34;$result&amp;#34; = &amp;#34;&amp;#34; ]; then
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74"> cat $PGDEV | fgrep Result:
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">fi
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">EOF&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>chmod &lt;span style="color:#ae81ff">755&lt;/span> /usr/local/bin/pgset
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># 为0号线程绑定 eth0 网卡&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>export PGDEV&lt;span style="color:#f92672">=&lt;/span>/proc/net/pktgen/kpktgend_0
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>pgset &lt;span style="color:#e6db74">&amp;#34;rem_device_all&amp;#34;&lt;/span> &lt;span style="color:#75715e"># 清空网卡绑定&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>pgset &lt;span style="color:#e6db74">&amp;#34;add_device eth0&amp;#34;&lt;/span> &lt;span style="color:#75715e"># 添加 eth0 网卡&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># 配置 eth0 网卡的测试选项&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>export PGDEV&lt;span style="color:#f92672">=&lt;/span>/proc/net/pktgen/eth0
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>pgset &lt;span style="color:#e6db74">&amp;#34;count 1000000&amp;#34;&lt;/span> &lt;span style="color:#75715e"># 总发包数量&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>pgset &lt;span style="color:#e6db74">&amp;#34;delay 5000&amp;#34;&lt;/span> &lt;span style="color:#75715e"># 不同包之间的发送延迟 (单位纳秒)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>pgset &lt;span style="color:#e6db74">&amp;#34;clone_skb 0&amp;#34;&lt;/span> &lt;span style="color:#75715e"># SKB 包复制&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>pgset &lt;span style="color:#e6db74">&amp;#34;pkt_size 64&amp;#34;&lt;/span> &lt;span style="color:#75715e"># 网络包大小&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>pgset &lt;span style="color:#e6db74">&amp;#34;dst 192.168.0.30&amp;#34;&lt;/span> &lt;span style="color:#75715e"># 目的 IP&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>pgset &lt;span style="color:#e6db74">&amp;#34;dst_mac 11:11:11:11:11:11&amp;#34;&lt;/span> &lt;span style="color:#75715e"># 目的 MAC&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># 启动测试&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>export PGDEV&lt;span style="color:#f92672">=&lt;/span>/proc/net/pktgen/pgctrl
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>pgset &lt;span style="color:#e6db74">&amp;#34;start&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>$ cat /proc/net/pktgen/eth0
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Params: count &lt;span style="color:#ae81ff">1000000&lt;/span> min_pkt_size: &lt;span style="color:#ae81ff">64&lt;/span> max_pkt_size: &lt;span style="color:#ae81ff">64&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> frags: &lt;span style="color:#ae81ff">0&lt;/span> delay: &lt;span style="color:#ae81ff">0&lt;/span> clone_skb: &lt;span style="color:#ae81ff">0&lt;/span> ifname: eth0
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> flows: &lt;span style="color:#ae81ff">0&lt;/span> flowlen: &lt;span style="color:#ae81ff">0&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>...
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Current:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> pkts-sofar: &lt;span style="color:#ae81ff">1000000&lt;/span> errors: &lt;span style="color:#ae81ff">0&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> started: 1534853256071us stopped: 1534861576098us idle: 70673us
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>...
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Result: OK: 8320027&lt;span style="color:#f92672">(&lt;/span>c8249354+d70673&lt;span style="color:#f92672">)&lt;/span> usec, &lt;span style="color:#ae81ff">1000000&lt;/span> &lt;span style="color:#f92672">(&lt;/span>64byte,0frags&lt;span style="color:#f92672">)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> 120191pps 61Mb/sec &lt;span style="color:#f92672">(&lt;/span>61537792bps&lt;span style="color:#f92672">)&lt;/span> errors: &lt;span style="color:#ae81ff">0&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>测试报告主要分为三个部分：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>第一部分的 Params 是测试选项；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>第二部分的 Current 是测试进度，其中，packts so far（pkts-sofar）表示已经发送了 100 万个包，也就表明测试已完成。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>第三部分的 Result 是测试结果，包含测试所用时间、网络包数量和分片、PPS、吞吐量以及错误数。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>PPS，是 Packet Per Second（包 / 秒）的缩写&lt;/p></description></item><item><title>Docs: stress-ng 系统压力测试工具</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/x.linux-%E7%AE%A1%E7%90%86/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E4%B8%8E%E6%95%85%E9%9A%9C%E5%A4%84%E7%90%86/%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95/stress-ng-%E7%B3%BB%E7%BB%9F%E5%8E%8B%E5%8A%9B%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/x.linux-%E7%AE%A1%E7%90%86/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E4%B8%8E%E6%95%85%E9%9A%9C%E5%A4%84%E7%90%86/%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95/stress-ng-%E7%B3%BB%E7%BB%9F%E5%8E%8B%E5%8A%9B%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;h1 id="syntax语法">Syntax(语法)&lt;/h1>
&lt;p>OPTIONS&lt;/p>
&lt;ul>
&lt;li>-c, &amp;ndash;cpu &lt;!-- raw HTML omitted --> # 指定要测试的 CPU 数量，测几个就起几个进程。&lt;/li>
&lt;li>-i &lt;!-- raw HTML omitted -->, &amp;ndash;io &lt;!-- raw HTML omitted --> # 启动 N 个工作程序，连续调用 sync(2) 将缓冲区高速缓存提交到磁盘。 可以与 &amp;ndash;hdd 选项结合使用。&lt;/li>
&lt;li>-d &amp;lt;&amp;gt;N, &amp;ndash;hdd &lt;!-- raw HTML omitted --> # 开始 N 个工作人员不断写入，读取和删除临时文件。 默认模式是对顺序写入和读取进行压力测试。 如果启用了&amp;ndash;ggressive 选项，而没有任何&amp;ndash;hdd-opts 选项，则 hdd Stressor 将一个接一个地处理所有&amp;ndash;hdd-opt 选项，以涵盖一系列 I / O 选项。&lt;/li>
&lt;li>--timeout &lt;!-- raw HTML omitted --> # 指定程序运行时间&lt;/li>
&lt;/ul>
&lt;p>EXAMPLE&lt;/p>
&lt;ul>
&lt;li>stress-ng -c 1 &amp;ndash;timeout 600 # 模拟 CPU 使用，导致 us 升高&lt;/li>
&lt;li>stress-ng -i 1 &amp;ndash;hdd 1 &amp;ndash;timeout 600 # 模拟磁盘 io，会导致 wa 升高&lt;/li>
&lt;/ul></description></item><item><title>Docs: sysbench</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/x.linux-%E7%AE%A1%E7%90%86/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E4%B8%8E%E6%95%85%E9%9A%9C%E5%A4%84%E7%90%86/%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95/sysbench/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/x.linux-%E7%AE%A1%E7%90%86/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E4%B8%8E%E6%95%85%E9%9A%9C%E5%A4%84%E7%90%86/%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95/sysbench/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://github.com/akopytov/sysbench">Github,akopytov/sysbench&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>脚本数据库和系统性能基准&lt;/p>
&lt;h1 id="syntax语法">Syntax(语法)&lt;/h1>
&lt;p>&lt;strong>sysbench [OPTIONS] [TestName] [COMMAND]&lt;/strong>&lt;/p>
&lt;p>TestName&lt;/p>
&lt;ul>
&lt;li>**fileio **# 文件 I/O 测试&lt;/li>
&lt;li>&lt;strong>cpu&lt;/strong> # CPU 性能测试&lt;/li>
&lt;li>&lt;strong>memory&lt;/strong> # 内存功能速度测试&lt;/li>
&lt;li>&lt;strong>threads&lt;/strong> # 线程子系统性能测试&lt;/li>
&lt;li>&lt;strong>mutex&lt;/strong> # 互斥体性能测试&lt;/li>
&lt;/ul>
&lt;h2 id="general-options">General OPTIONS&lt;/h2>
&lt;ul>
&lt;li>&lt;strong>&amp;ndash;threads &lt;!-- raw HTML omitted -->&lt;/strong> # 要创建的工作线程总数&lt;/li>
&lt;li>&lt;strong>&amp;ndash;time &lt;!-- raw HTML omitted -->&lt;/strong> # 运行持续时间。单位：秒。&lt;code>默认值：0&lt;/code>。0 表示没有限制。&lt;/li>
&lt;/ul>
&lt;h1 id="example">Example&lt;/h1>
&lt;ul>
&lt;li>以 10 个线程运行 5 分钟的线程子系统性能测试。常用来模拟多线程切换的问题
&lt;ul>
&lt;li>&lt;strong>sysbench &amp;ndash;threads=10 &amp;ndash;time=300 threads run&lt;/strong>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul></description></item><item><title>Docs: wrk # HTTP基准测试小型工具</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/x.linux-%E7%AE%A1%E7%90%86/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E4%B8%8E%E6%95%85%E9%9A%9C%E5%A4%84%E7%90%86/%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95/wrk-#-http%E5%9F%BA%E5%87%86%E6%B5%8B%E8%AF%95%E5%B0%8F%E5%9E%8B%E5%B7%A5%E5%85%B7/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/x.linux-%E7%AE%A1%E7%90%86/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E4%B8%8E%E6%95%85%E9%9A%9C%E5%A4%84%E7%90%86/%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95/wrk-#-http%E5%9F%BA%E5%87%86%E6%B5%8B%E8%AF%95%E5%B0%8F%E5%9E%8B%E5%B7%A5%E5%85%B7/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://github.com/wg/wrk">GitHub 项目,wrk&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>wrk 是一种现代 HTTP 基准测试工具，当在单个多核 CPU 上运行时，能够产生大量负载。它结合了多线程设计和可扩展的事件通知系统，例如 epoll 和 kqueue。&lt;/p>
&lt;p>可选的 LuaJIT 脚本可以执行 HTTP 请求生成，响应处理和自定义报告。详细信息可在 SCRIPTING 中找到，几个示例位于 scripts /中&lt;/p>
&lt;h2 id="wrk2">Wrk2&lt;/h2>
&lt;blockquote>
&lt;p>参考&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://github.com/giltene/wrk2">GitHub 项目,wrk2&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.wangbo.im/posts/usage-of-benchmarking-tool-wrk-and-wrk2/">https://www.wangbo.im/posts/usage-of-benchmarking-tool-wrk-and-wrk2/&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;h1 id="wrk-的安装">Wrk 的安装&lt;/h1>
&lt;p>安装 wrk 需要从项目上 clone 项目然后编译获取二进制文件&lt;/p>
&lt;ol>
&lt;li>yum groupinstall &amp;lsquo;Development Tools&amp;rsquo; -y&lt;/li>
&lt;li>yum install openssl-devel git -y&lt;/li>
&lt;li>git clone &lt;a href="https://github.com/wg/wrk">https://github.com/wg/wrk&lt;/a>&lt;/li>
&lt;li>cd wrk&lt;/li>
&lt;li>make&lt;/li>
&lt;li>cp wrk /usr/local/bin&lt;/li>
&lt;/ol>
&lt;p>clone 和编译时间较长，这里给一个编译好的文件&lt;/p>
&lt;h1 id="wrk-命令行工具使用方法">Wrk 命令行工具使用方法&lt;/h1>
&lt;p>wrk [OPTIONS] URL
OPTIONS&lt;/p>
&lt;ul>
&lt;li>&lt;strong>-c,&amp;ndash;connections NUM&lt;/strong> # 指定总的 http 并发数。默认 10 个并发连接&lt;/li>
&lt;li>&lt;strong>-d,&amp;ndash;duration NUM&lt;/strong> # 指定压测的持续时间。默认 10s&lt;/li>
&lt;li>&lt;strong>-H,&amp;ndash;header STRING&lt;/strong> # 使用指定的头信息作为请求 header&lt;/li>
&lt;li>&lt;strong>-t,&amp;ndash;threads NUM&lt;/strong> # 指定总线程数。默认 2 个线程&lt;/li>
&lt;li>&lt;strong>&amp;ndash;latency&lt;/strong> # 输出延迟统计情况&lt;/li>
&lt;/ul>
&lt;p>EXAMPLE&lt;/p>
&lt;ol>
&lt;li>wrk -t 12 -c 400 -d 30s http://127.0.0.1:8080/index.html #使用 12 个线程运行 30 秒，模拟 400 个并发请求本地 8080 端口的 index.html&lt;/li>
&lt;li>wrk -t 80 -d 60s -c 16000 -T 3s &amp;ndash;latency http://10.10.9.60:80/ #&lt;/li>
&lt;/ol>
&lt;h1 id="wrk-结果解读">WRK 结果解读&lt;/h1>
&lt;p>下面是一个最基本的测试结果&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>Running 1m test @ http://10.10.100.107:30000/
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ae81ff">12&lt;/span> threads and &lt;span style="color:#ae81ff">10000&lt;/span> connections
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Thread Stats Avg Stdev Max +/- Stdev
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> 线程信息 平均值 标准差 最大值 正负一个标准差所占比例
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Latency 1.28s 509.20ms 2.00s 76.80% &lt;span style="color:#75715e"># 延时、执行时间&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Req/Sec 70.18 74.26 717.00 88.88% &lt;span style="color:#75715e"># 每个线程每秒钟执行的连接数&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Latency Distribution &lt;span style="color:#75715e">#延迟分布。如果使用--latency参数，则会出现该字段信息&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> 50% 1.40s
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> 75% 1.60s
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> 90% 1.79s
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> 99% 1.99s
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ae81ff">31631&lt;/span> requests in 1.00m, 8.87MB read
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Socket errors: connect 0, read 2745465, write 0, timeout &lt;span style="color:#ae81ff">17902&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Requests/sec: 526.31 &lt;span style="color:#75715e">#平均每秒处理完成请求的个数。每秒请求数(QPS)，等于总请求数/测试总耗时&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Transfer/sec: 151.11KB &lt;span style="color:#75715e">#平均每秒读取数据的值&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h1 id="并发测试案例">并发测试案例&lt;/h1>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>root@lichenhao:/usr/local/bin# wrk -t &lt;span style="color:#ae81ff">8&lt;/span> -c &lt;span style="color:#ae81ff">1000&lt;/span> -d 30s --latency -H &lt;span style="color:#e6db74">&amp;#34;Host: desistdaydream.ltd&amp;#34;&lt;/span> http://172.19.42.217/robots.txt
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Running 30s test @ http://172.19.42.217/robots.txt
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ae81ff">8&lt;/span> threads and &lt;span style="color:#ae81ff">1000&lt;/span> connections
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Thread Stats Avg Stdev Max +/- Stdev
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Latency 94.66ms 75.27ms 1.21s 47.54%
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Req/Sec 1.36k 235.57 1.98k 68.50%
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Latency Distribution
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> 50% 102.70ms
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> 75% 161.72ms
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> 90% 189.77ms
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> 99% 230.97ms
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ae81ff">324797&lt;/span> requests in 30.08s, 97.56MB read
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Requests/sec: 10797.85
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Transfer/sec: 3.24MB
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>root@lichenhao:/usr/local/bin#
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>root@lichenhao:/usr/local/bin#
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>root@lichenhao:/usr/local/bin#
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>root@lichenhao:/usr/local/bin#
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>root@lichenhao:/usr/local/bin# wrk -t &lt;span style="color:#ae81ff">8&lt;/span> -c &lt;span style="color:#ae81ff">1000&lt;/span> -d 30s --latency -H &lt;span style="color:#e6db74">&amp;#34;Host: desistdaydream.ltd&amp;#34;&lt;/span> http://172.19.42.217
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Running 30s test @ http://172.19.42.217
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ae81ff">8&lt;/span> threads and &lt;span style="color:#ae81ff">1000&lt;/span> connections
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Thread Stats Avg Stdev Max +/- Stdev
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Latency 2.00s 0.00us 2.00s 100.00%
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Req/Sec 23.36 20.77 121.00 77.18%
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Latency Distribution
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> 50% 2.00s
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> 75% 2.00s
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> 90% 2.00s
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> 99% 2.00s
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ae81ff">2629&lt;/span> requests in 30.09s, 118.62MB read
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Socket errors: connect 0, read 0, write 0, timeout &lt;span style="color:#ae81ff">2628&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Requests/sec: 87.37
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Transfer/sec: 3.94MB
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div></description></item><item><title>Docs: 性能测试</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/x.linux-%E7%AE%A1%E7%90%86/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E4%B8%8E%E6%95%85%E9%9A%9C%E5%A4%84%E7%90%86/%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95/%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/x.linux-%E7%AE%A1%E7%90%86/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E4%B8%8E%E6%95%85%E9%9A%9C%E5%A4%84%E7%90%86/%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95/%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;/blockquote>
&lt;p>&lt;strong>Virtual Users(虚拟用户，简称 VUs)&lt;/strong> 是在性能测试领域常见的术语。VUs Generator(虚拟用户生成器) 使得测试人员能创建虚拟用户，以增加被测试应用程序的负载。用人话说，就是发起请求的&lt;strong>并发数&lt;/strong>。性能测试程序，其实就是一个虚拟用户生成器。&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/bmq8rk/1616164331685-d98197f5-3930-4bd8-9dc8-837f1a8a38fe.png" alt="">&lt;/p></description></item></channel></rss>