<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>断念梦 – X.Linux 管理</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/x.linux-%E7%AE%A1%E7%90%86/</link><description>Recent content in X.Linux 管理 on 断念梦</description><generator>Hugo -- gohugo.io</generator><atom:link href="https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/x.linux-%E7%AE%A1%E7%90%86/index.xml" rel="self" type="application/rss+xml"/><item><title>Docs: /boot目录被清空下物理机无法开机的一次救援 · zhangguanzhang's Blog</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/x.linux-%E7%AE%A1%E7%90%86/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96-%E4%B8%8E-%E6%95%85%E9%9A%9C%E5%A4%84%E7%90%86/%E6%95%85%E9%9A%9C%E5%A4%84%E7%90%86%E6%A1%88%E4%BE%8B/boot%E7%9B%AE%E5%BD%95%E8%A2%AB%E6%B8%85%E7%A9%BA%E4%B8%8B%E7%89%A9%E7%90%86%E6%9C%BA%E6%97%A0%E6%B3%95%E5%BC%80%E6%9C%BA%E7%9A%84%E4%B8%80%E6%AC%A1%E6%95%91%E6%8F%B4-zhangguanzhangs-blog/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/x.linux-%E7%AE%A1%E7%90%86/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96-%E4%B8%8E-%E6%95%85%E9%9A%9C%E5%A4%84%E7%90%86/%E6%95%85%E9%9A%9C%E5%A4%84%E7%90%86%E6%A1%88%E4%BE%8B/boot%E7%9B%AE%E5%BD%95%E8%A2%AB%E6%B8%85%E7%A9%BA%E4%B8%8B%E7%89%A9%E7%90%86%E6%9C%BA%E6%97%A0%E6%B3%95%E5%BC%80%E6%9C%BA%E7%9A%84%E4%B8%80%E6%AC%A1%E6%95%91%E6%8F%B4-zhangguanzhangs-blog/</guid><description>
&lt;p>今天下午到公司被通知苏州一个节点的客户的裸金属无法开机，14:00 上去到 16:50 终于给整好了，这里记录下笔记分享下&lt;/p>
&lt;h2 id="故障现象">故障现象&lt;/h2>
&lt;p>物理机裸金属，连上跳板机通过带外连上去 (等同于现场接了一个显示屏 + 键盘一样) 错误为&lt;/p>
&lt;pre>&lt;code>errorL file `/grub2/i386-pc/normal.mod' not found.
Entering rescue mode...
grub rescue&amp;gt;
&lt;/code>&lt;/pre>
&lt;p>这个物理机是 grub2，这个错误和类似的&lt;code>/grub/i386-pc/normal.mod&lt;/code>本质上都是文件丢失，但是也分情况，网上的一些恢复步骤都是在丢失部分文件的情况下恢复的
查看分区&lt;/p>
&lt;pre>&lt;code>grub rescue&amp;gt;ls
(hd0) (hd0,msdos2) (hd0,msdos1)
grub rescue&amp;gt;ls (hd0,msdos1)/
./ ../
grub rescue&amp;gt;ls (hd0,msdos2)/
error: unknown filesystem
&lt;/code>&lt;/pre>
&lt;p>这里是等同于你实际的分区，我们这基本是一个 / boot 和一个根，看到&lt;code>(hd0,msdos1)&lt;/code>是 / boot 分区，文件是完全丢失的，&lt;code>(hd0,msdos2)/&lt;/code>报错未知文件系统是因为这个是 lvm，正常乐观下来讲只是丢失部分文件的话，可以参考下面步骤去恢复&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://www.youtube.com/watch?v=RqRm1bEXO9M">https://www.youtube.com/watch?v=RqRm1bEXO9M&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://blog.csdn.net/qq_20545159/article/details/50810089">https://blog.csdn.net/qq_20545159/article/details/50810089&lt;/a>&lt;/li>
&lt;/ul>
&lt;h2 id="救援">救援&lt;/h2>
&lt;h3 id="livecd-进入-rescue-救援">livecd 进入 rescue 救援&lt;/h3>
&lt;p>这里我是完全丢失，我利用带外远程挂载了一个 centos7.6 的 iso(最好和目标系统版本一样)，重启物理机进入 cdrom，选择&lt;code>Troubleshooting&lt;/code> –&amp;gt; &lt;code>Rescue a CentOS Linux system&lt;/code>&lt;/p>
&lt;p>下面我引用下别人的图，如果图被拦截了请看文字吧
&lt;a href="https://notes-learning.oss-cn-beijing.aliyuncs.com/dd979e87-2201-4df4-890e-d122c4681296/troubleshooting-option-boot-RHEL-CentOS-7-into-rescue-mode.png">
&lt;/a>
&lt;a href="https://notes-learning.oss-cn-beijing.aliyuncs.com/dd979e87-2201-4df4-890e-d122c4681296/rescue-CentOS-RHEL-7-system.png">
&lt;/a>
&lt;a href="https://notes-learning.oss-cn-beijing.aliyuncs.com/dd979e87-2201-4df4-890e-d122c4681296/find-linux-installation-for-rescue-mode-RHEL-7-reinstall-GRUB2.png">
&lt;/a>
选择 1 后然后回车会得到一个交互式 shell，查看下分区信息&lt;/p>
&lt;pre>&lt;code>sh-4.2# lsblk
NAME MAJ:MIN RM SIZE RO TYPE MOUNTPOINT
sda 8:0 1 558G 0 disk
├─sda1 8:1 1 1G 0 part /mnt/sysimage/boot
└─sda2 8:2 1 557G 0 part
├─centos-root 253:0 0 550G 0 lvm /mnt/sysimage
└─centos-swap 253:1 0 4G 0 lvm [SWAP]
sr0 11:0 1 4.3G 0 rom /run/install/repo
sr1 11:1 1 107.2M 0 rom
loop0 7:1 0 432.4M 1 loop
loop1 7:1 0 2G 1 loop
├─live-rw 253:0 0 2G 0 dm /
└─live-base 253:1 0 2G 1 dm
loop2 7:2 0 512M 1 loop
└─live-rw 253:0 0 2G 0 dm /
&lt;/code>&lt;/pre>
&lt;p>根被挂载到&lt;code>/mnt/sysimage&lt;/code>,boot 被挂载到&lt;code>/mnt/sysimage/boot&lt;/code>，iso 被挂载到&lt;code>/run/install/repo&lt;/code>
最开始我是 chroot /mnt/sysimage 后 grub2-install /dev/sda，然后重启后进入&lt;/p>
&lt;pre>&lt;code> Minimal BASH_like line editing is supported. For the first word,
...
..
grub&amp;gt;
&lt;/code>&lt;/pre>
&lt;p>出现这个一般是缺少&lt;code>grub.cfg&lt;/code>，然后再进去光盘的 rescue 里去 chroot 进去&lt;code>grub2-mkconfig -o /boot/grub2/grub.cfg&lt;/code>还是不行。因为实际上 / boot 都被清空了，grub2-install 和 mkconfig 只是生成了&lt;code>/boot/grub2&lt;/code>下面一些文件，因为开机需要的 vmlinuz 和 kernel 都没有.&lt;/p>
&lt;h3 id="复制同样机器同样系统的--boot">复制同样机器同样系统的 / boot&lt;/h3>
&lt;p>正确姿势来整的话，考虑到 / boot 下面的相关文件被清理了，叫同事找同样物理机和系统的裸金属上去看看&lt;code>/boot/&lt;/code>目录，然后叫他把 / boot 打包成 iso，我在带外挂载上去。
         中间他直接复制到 windows 的，权限信息丢失了。我叫他直接 Linux 上 tar 打包了后再在 win 上打包 iso。
可以先在 rescue 模式里看&lt;code>/mnt/sysimage/etc/redhat-release&lt;/code>查看系统信息，然后正常物理机的同样系统上的 / boot 信息为&lt;/p>
&lt;pre>&lt;code>$ ll
total 110920
-rw-r--r--. 1 root root 151918 Nov 9 2018 config-3.10.0-957.el7.x86_64
drwxr-xr-x. 3 root root 17 Feb 26 2019 efi
drwxr-xr-x. 2 root root 27 Feb 26 2019 grub
drwx------. 5 root root 97 Feb 26 2019 grub2
-rw-------. 1 root root 59891363 Feb 26 2019 initramfs-0-rescue-cd270b115cc741328f7812c0be97041d.img
-rw-------. 1 root root 22834950 Feb 26 2019 initramfs-3.10.0-957.el7.x86_64.img
-rw-------. 1 root root 13548147 Oct 11 16:32 initramfs-3.10.0-957.el7.x86_64kdump.img
-rw-r--r--. 1 root root 314036 Nov 9 2018 symvers-3.10.0-957.el7.x86_64.gz
-rw-------. 1 root root 3543471 Nov 9 2018 System.map-3.10.0-957.el7.x86_64
-rwxr-xr-x. 1 root root 6639904 Feb 26 2019 vmlinuz-0-rescue-cd270b115cc741328f7812c0be97041d
-rwxr-xr-x. 1 root root 6639904 Nov 9 2018 vmlinuz-3.10.0-957.el7.x86_64
&lt;/code>&lt;/pre>
&lt;p>现在步骤开始是实际有效的步骤，前提是挂载了 centos 的 iso 和 boot 文件的 iso
下面我第一个光驱是 iso，第二个是 boot，所以是&lt;code>/dev/sr1&lt;/code>&lt;/p>
&lt;pre>&lt;code>sh-4.2# chroot /mnt/sysimage
bash-4.2# alias ll='ls -l'
bash-4.2# mkdir -p /media/tmp
bash-4.2# mount /dev/sr1 /media/tmp/
mount: /dev/sr1 is write-protected, mounting read-only
bash-4.2# cd /media
bash-4.2# tar zxf /media/tmp/boot.tar.gz
bash-4.2# cp -a boot/* /boot/
&lt;/code>&lt;/pre>
&lt;p>这里有一个点不确定，但是为了保险起见我是操作了，有条件的人可以自己去测下看看下面步骤不执行有影响不, 删除 uuid 文件 (我对比了下实际上 MD5 是一样的，有条件可以测下下面这几个步骤不执行看看正常不)&lt;/p>
&lt;pre>&lt;code>bash-4.2# cd /boot
bash-4.2# ll /media/boot/*cd270b11*
-rw-------. 1 root root 59891363 Feb 26 2019 /media/boot/initramfs-0-rescue-cd270b115cc741328f7812c0be97041d.img
-rwxr-xr-x. 1 root root 6639904 Feb 26 2019 /media/boot/vmlinuz-0-rescue-cd270b115cc741328f7812c0be97041d
bash-4.2# rm -f *cd270b11*
bash-4.2# /etc/kernel/postinst.d/51-dracut-rescue-postinst.sh $(uname -r) /boot/vmlinuz-$(uname -r)
&lt;/code>&lt;/pre>
&lt;p>grub 配置文件里有硬盘分区的 uuid，这里需要重新生成&lt;code>grub.cfg&lt;/code>&lt;/p>
&lt;pre>&lt;code>bash-4.2# mv /boot/grub2/grub.cfg{,.bak}
bash-4.2# grub2-mkconfig -o /boot/grub2/grub.cfg
&lt;/code>&lt;/pre>
&lt;p>如果报错&lt;code>grub-probe: error: cannot find a device for / (is /dev mounted?)&lt;/code>
则在 chroot 之前用 bind mount 相关目录&lt;/p>
&lt;pre>&lt;code>mount -o bind /dev /mnt/sysimage/dev
mount -o bind /proc /mnt/sysimage/proc
mount -o bind /run /mnt/sysimage/run
mount -o bind /sys /mnt/sysimage/sys
&lt;/code>&lt;/pre>
&lt;h3 id="重启">重启&lt;/h3>
&lt;p>重启测试&lt;/p>
&lt;pre>&lt;code>bash-4.2# exit
sh-4.2# init 6
&lt;/code>&lt;/pre>
&lt;p>结果是进入了&lt;code>emergency mode&lt;/code>
&lt;a href="https://notes-learning.oss-cn-beijing.aliyuncs.com/dd979e87-2201-4df4-890e-d122c4681296/emergencyMode.png">
&lt;/a>
这个模式进来了大多数原因是有个非系统的分区无法挂载，输入 root 密码进去后，先查看下&lt;code>systemctl failed&lt;/code>发现&lt;code>/home&lt;/code>无法被挂载&lt;/p>
&lt;pre>&lt;code>[root@cn19 ~]# systemctl --failed
UNIT LOAD ACTIVE SUB DESCRIPTION
● home.mount loaded failed failed /home
● auditd.service loaded failed failed Security Auditing Service
LOAD = Reflects whether the unit definition was properly loaded.
ACTIVE = The high-level unit activation state, i.e. generalization of SUB.
SUB = The low-level unit activation state, values depend on unit type.
2 loaded units listed. Pass --all to see loaded but inactive units, too.
To show all installed unit files use 'systemctl list-unit-files'.
[root@cn19 ~]# grep -Pv '^#|^$' /etc/fstab
/dev/mapper/centos-root / xfs defaults 0 0
UUID=71b43bbc-819c-4420-9ba8-9c85110999dd /boot xfs defaults 0 0
/dev/mapper/centos-swap swap swap defaults 0 0
[root@cn19 ~]# lvs
LV VG Attr LSize Pool Origin Data% Meta% Move Log Cpy%Sync Convert
home centos -wi-a----- 2.00g
root centos -wi-ao---- 550.00g
swap centos -wi-ao---- 4.00g
&lt;/code>&lt;/pre>
&lt;p>尝试修复无果&lt;/p>
&lt;pre>&lt;code>[root@cn19 ~]# xfs_repair /dev/mapper/centos-home
Phase 1 - find and verify superblock...
bad primary superblock - bad magic number !!!
attempting to find secondary superblock...
......................Sorry, could not find valid secondary superblock
Exiting now.
&lt;/code>&lt;/pre>
&lt;p>询问了用户&lt;code>/home&lt;/code>目录不重要，直接取消 fstab 取消 / home 的挂载然后 reboot 恢复正常
&lt;a href="https://notes-learning.oss-cn-beijing.aliyuncs.com/dd979e87-2201-4df4-890e-d122c4681296/right.png">
&lt;/a>&lt;/p>
&lt;h2 id="参考">参考：&lt;/h2>
&lt;p>&lt;a href="https://www.tecmint.com/recover-or-rescue-corrupted-grub-boot-loader-in-centos-7/">https://www.tecmint.com/recover-or-rescue-corrupted-grub-boot-loader-in-centos-7/&lt;/a>
rescue mode 安装 kernel: &lt;a href="https://www.thegeekdiary.com/centos-rhel-7-how-to-install-kernel-from-rescue-mode/">https://www.thegeekdiary.com/centos-rhel-7-how-to-install-kernel-from-rescue-mode/&lt;/a>
rescue mode 生成 vmlinuz 和 initramfs: &lt;a href="https://www.thegeekdiary.com/how-to-re-generate-initramfs-and-vmlinuz-for-rescue-kernel-with-current-kernel-in-centos-rhel-7/">https://www.thegeekdiary.com/how-to-re-generate-initramfs-and-vmlinuz-for-rescue-kernel-with-current-kernel-in-centos-rhel-7/&lt;/a>
&lt;a href="https://zhangguanzhang.github.io/2019/10/12/boot-grub-rescue/">https://zhangguanzhang.github.io/2019/10/12/boot-grub-rescue/&lt;/a>&lt;/p></description></item><item><title>Docs: 60,000 毫秒内对 Linux 的性能诊断</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/x.linux-%E7%AE%A1%E7%90%86/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96-%E4%B8%8E-%E6%95%85%E9%9A%9C%E5%A4%84%E7%90%86/60000-%E6%AF%AB%E7%A7%92%E5%86%85%E5%AF%B9-linux-%E7%9A%84%E6%80%A7%E8%83%BD%E8%AF%8A%E6%96%AD/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/x.linux-%E7%AE%A1%E7%90%86/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96-%E4%B8%8E-%E6%95%85%E9%9A%9C%E5%A4%84%E7%90%86/60000-%E6%AF%AB%E7%A7%92%E5%86%85%E5%AF%B9-linux-%E7%9A%84%E6%80%A7%E8%83%BD%E8%AF%8A%E6%96%AD/</guid><description>
&lt;h3 id="60000-毫秒内对-linux-的性能诊断httpssegmentfaultcoma1190000004104493">&lt;a href="https://segmentfault.com/a/1190000004104493">60,000 毫秒内对 Linux 的性能诊断&lt;/a>&lt;/h3>
&lt;p>&lt;a href="https://netflixtechblog.com/linux-performance-analysis-in-60-000-milliseconds-accc10403c55?gi=cd96c338a83b">英文原文&lt;/a>&lt;/p>
&lt;p>当你为了解决一个性能问题登录到一台 Linux 服务器：在第一分钟你应该检查些什么？&lt;/p>
&lt;p>在 Netflix，我们有一个巨大的 EC2 Linux 云，以及大量的性能分析工具来监控和诊断其性能。其中包括用于云监控的 &lt;a href="http://techblog.netflix.com/2014/12/introducing-atlas-netflixs-primary.html">Atlas&lt;/a>，以及用于按需实例分析的 &lt;a href="http://techblog.netflix.com/2015/04/introducing-vector-netflixs-on-host.html">Vector&lt;/a>。虽然这些工具可以帮助我们解决大多数问题，但我们有时仍需要登录到一个服务器实例，并运行一些标准 Linux 性能工具。&lt;/p>
&lt;p>在这篇文章中，Netflix Performance Engineering 团队将会向你讲解在命令行中进行一次最佳的性能分析的前 60 秒要做的事，使用的是你应该可以得到的标准 Linux 工具。&lt;/p>
&lt;h3 id="前六十秒总览">前六十秒：总览&lt;/h3>
&lt;p>通过运行下面十个命令，你就能在六十秒内粗略地了解系统正在运行的进程及资源使用情况。通过查看这些命令输出的错误信息和资源饱和度（它们都很容易看懂），你可以接下来对资源进行优化。饱和是指某个资源的负载超出了其能够处理的限度。一旦出现饱和，它通常会在请求队列的长度或等待时间上暴露出来。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-json" data-lang="json">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#960050;background-color:#1e0010">uptime&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#960050;background-color:#1e0010">dmesg | tail&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#960050;background-color:#1e0010">vmstat &lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#960050;background-color:#1e0010">mpstat -P ALL &lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#960050;background-color:#1e0010">pidstat &lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#960050;background-color:#1e0010">iostat -xz &lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#960050;background-color:#1e0010">free -m&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#960050;background-color:#1e0010">sar -n DEV &lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#960050;background-color:#1e0010">sar -n TCP,ETCP &lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#960050;background-color:#1e0010">top&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>其中某些命令需要预先安装  sysstat 软件包。这些命令展示出来的信息能够帮你实施&lt;a href="http://www.brendangregg.com/usemethod.html">USE 方法&lt;/a>（一种用于定位性能瓶颈的方法），比如检查各种资源（如 CPU、内存、磁盘等）的使用率、饱和度和错误信息。另外在定位问题的过程中，你可以通过使用这些命令来排除某些导致问题的可能性，帮助你缩小检查范围，为下一步检查指明方向。&lt;/p>
&lt;p>下面的章节将以在一个生产环境上执行这些命令作为例子，简单介绍这些命令。若想详细了解这些工具的使用方法，请参考它们的 man 文档。&lt;/p>
&lt;h3 id="1-uptime">1. uptime&lt;/h3>
&lt;pre>&lt;code>$ uptime
 23:51:26 up 21:31,  1 user,  load average: 30.02, 26.43, 19.02
&lt;/code>&lt;/pre>
&lt;p>这是一种用来快速查看系统平均负载的方法，它表明了系统中有多少要运行的任务（进程）。在 Linux 系统中，这些数字包含了需要在 CPU 中运行的进程以及正在等待 I/O（通常是磁盘 I/O）的进程。它仅仅是对系统负载的一个粗略展示，稍微看下即可。你还需要其他工具来进一步了解具体情况。&lt;/p>
&lt;p>这三个数字展示的是一分钟、五分钟和十五分钟内系统的负载总量平均值按照指数比例压缩得到的结果。从中我们可以看到系统的负载是如何随时间变化的。比方你在检查一个问题，然后看到 1 分钟对应的值远小于 15 分钟的值，那么可能说明这个问题已经过去了，你没能及时观察到。&lt;/p>
&lt;p>在上面这个例子中，系统负载在随着时间增加，因为最近一分钟的负载值超过了 30，而 15 分钟的平均负载则只有 19。这样显著的差距包含了很多含义，比方 CPU 负载。若要进一步确认的话，则要运行 vmstat 或 mpstat 命令，这两个命令请参考后面的第 3 和第 4 章节。&lt;/p>
&lt;h3 id="2-dmesg--tail">2. dmesg | tail&lt;/h3>
&lt;pre>&lt;code>$ dmesg | tail
[1880957.563150] perl invoked oom-killer: gfp_mask=0x280da, order=0, oom_score_adj=0
[...]
[1880957.563400] Out of memory: Kill process 18694 (perl) score 246 or sacrifice child
[1880957.563408] Killed process 18694 (perl) total-vm:1972392kB, anon-rss:1953348kB, file-rss:0kB
[2320864.954447] TCP: Possible SYN flooding on port 7001. Dropping request. Check SNMP counters.
&lt;/code>&lt;/pre>
&lt;p>这条命令显式了最近的 10 条系统消息，如果它们存在的话。查找能够导致性能问题的错误。上面的例子包含了 oom-killer，以及 TCP 丢弃一个请求。&lt;/p>
&lt;p>千万不要错过这一步！dmesg 命令永远值得一试。&lt;/p>
&lt;h3 id="3-vmstat-1">3. vmstat 1&lt;/h3>
&lt;pre>&lt;code>$ vmstat 1procs \---------memory---------- \---swap-- \-----io---- \-system-- \------cpu-----
 r  b swpd   free   buff  cache   si   so    bi    bo   in   cs us sy id wa st
34  0    0 200889792  73708 591828    0    0     0     5    6   10 96  1  3  0  0
32  0    0 200889920  73708 591860    0    0     0   592 13284 4282 98  1  1  0  0
32  0    0 200890112  73708 591860    0    0     0     0 9501 2154 99  1  0  0  0
32  0    0 200889568  73712 591856    0    0     0    48 11900 2459 99  0  0  0  0
32  0    0 200890208  73712 591860    0    0     0     0 15898 4840 98  1  1  0  0
^C
&lt;/code>&lt;/pre>
&lt;p>vmstat(8) 是虚拟内存统计的简称，其是一个常用工具（几十年前为了 BSD 所创建）。其在每行打印一条关键的服务器的统计摘要。&lt;/p>
&lt;p>vmstat 命令指定一个参数 1 运行，来打印每一秒的统计摘要。（这个版本的 vmstat）输出的第一行的那些列，显式的是开机以来的平均值，而不是前一秒的值。现在，我们跳过第一行，除非你想要了解并记住每一列。&lt;/p>
&lt;p>检查这些列：&lt;/p>
&lt;ul>
&lt;li>&lt;strong>r&lt;/strong>：CPU 中正在运行和等待运行的进程的数量。其提供了一个比平均负载更好的信号来确定 CPU 是否饱和，因为其不包含 I/O。解释：“r” 的值大于了 CPU 的数量就表示已经饱和了。&lt;/li>
&lt;li>&lt;strong>free&lt;/strong>：以 kb 为单位显式的空闲内存。如果数字位数很多，说明你有足够的空闲内存。“free -m” 命令，是下面的第七个命令，其可以更好的说明空闲内存的状态。&lt;/li>
&lt;li>&lt;strong>si, so&lt;/strong>：Swap-ins 和 swap-outs。如果它们不是零，则代表你的内存不足了。&lt;/li>
&lt;li>&lt;strong>us, sy, id, wa, st&lt;/strong>：这些都是平均了所有 CPU 的 CPU 分解时间。它们分别是用户时间（user）、系统时间（内核）（system）、空闲（idle）、等待 I/O（wait）、以及占用时间（stolen）（被其他访客，或使用 Xen，访客自己独立的驱动域）。&lt;/li>
&lt;/ul>
&lt;p>CPU 分解时间将会通过用户时间加系统时间确认 CPU 是否为忙碌状态。等待 I/O 的时间一直不变则表明了一个磁盘瓶颈；这就是 CPU 的闲置，因为任务都阻塞在等待挂起磁盘 I/O 上了。你可以把等待 I/O 当成是 CPU 闲置的另一种形式，其给出了为什么 CPU 闲置的一个线索。&lt;/p>
&lt;p>对于 I/O 处理来说，系统时间是很重要的。一个高于 20% 的平均系统时间，可以值得进一步的探讨：也许内核在处理 I/O 时效率太低了。&lt;/p>
&lt;p>在上面的例子中，CPU 时间几乎完全花在了用户级，表明应用程序占用了太多 CPU 时间。而 CPU 的平均使用率也在 90% 以上。这不一定是一个问题；检查一下 “r” 列中的饱和度。&lt;/p>
&lt;h3 id="4-mpstat--p-all-1">4. mpstat -P ALL 1&lt;/h3>
&lt;pre>&lt;code>$ mpstat -P ALL 1
Linux 3.13.0-49-generic (titanclusters-xxxxx) 07/14/2015 _x86_64_ (32 CPU)
07:38:49 PM CPU %usr %nice %sys %iowait %irq %soft %steal %guest %gnice %idle
07:38:50 PM all 98.47 0.00 0.75 0.00 0.00 0.00 0.00 0.00 0.00 0.78
07:38:50 PM 0 96.04 0.00 2.97 0.00 0.00 0.00 0.00 0.00 0.00 0.99
07:38:50 PM 1 97.00 0.00 1.00 0.00 0.00 0.00 0.00 0.00 0.00 2.00
07:38:50 PM 2 98.00 0.00 1.00 0.00 0.00 0.00 0.00 0.00 0.00 1.00
07:38:50 PM 3 96.97 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 3.03
[...]
&lt;/code>&lt;/pre>
&lt;p>这个命令打印每个 CPU 的 CPU 分解时间，其可用于对一个不均衡的使用情况进行检查。一个单独 CPU 很忙碌则代表了正在运行一个单线程的应用程序。&lt;/p>
&lt;h3 id="5-pidstat-1">5. pidstat 1&lt;/h3>
&lt;pre>&lt;code>$ pidstat 1
Linux 3.13.0-49-generic (titanclusters-xxxxx) 07/14/2015 _x86_64_ (32 CPU)
07:41:02 PM UID PID %usr %system %guest %CPU CPU Command
07:41:03 PM 0 9 0.00 0.94 0.00 0.94 1 rcuos/0
07:41:03 PM 0 4214 5.66 5.66 0.00 11.32 15 mesos-slave
07:41:03 PM 0 4354 0.94 0.94 0.00 1.89 8 java
07:41:03 PM 0 6521 1596.23 1.89 0.00 1598.11 27 java
07:41:03 PM 0 6564 1571.70 7.55 0.00 1579.25 28 java
07:41:03 PM 60004 60154 0.94 4.72 0.00 5.66 9 pidstat
07:41:03 PM UID PID %usr %system %guest %CPU CPU Command
07:41:04 PM 0 4214 6.00 2.00 0.00 8.00 15 mesos-slave
07:41:04 PM 0 6521 1590.00 1.00 0.00 1591.00 27 java
07:41:04 PM 0 6564 1573.00 10.00 0.00 1583.00 28 java
07:41:04 PM 108 6718 1.00 0.00 0.00 1.00 0 snmp-pass
07:41:04 PM 60004 60154 1.00 4.00 0.00 5.00 9 pidstat
^C
&lt;/code>&lt;/pre>
&lt;p>pidstat 命令有点像 top 命令对每个进程的统计摘要，但循环打印一个滚动的统计摘要来代替 top 的刷屏。其可用于实时查看，同时也可将你所看到的东西（复制粘贴）到你的调查记录中。&lt;/p>
&lt;p>上面的例子表明两个 Java 进程正在消耗 CPU。%CPU 这列是所有 CPU 合计的；1591% 表示这个 Java 进程消耗了将近 16 个 CPU。&lt;/p>
&lt;h3 id="6-iostat--xz-1">6. iostat -xz 1&lt;/h3>
&lt;pre>&lt;code>$ iostat -xz 1
Linux 3.13.0-49-generic (titanclusters-xxxxx) 07/14/2015 _x86_64_ (32 CPU)
avg-cpu: %user %nice %system %iowait %steal %idle
73.96 0.00 3.73 0.03 0.06 22.21
Device: rrqm/s wrqm/s r/s w/s rkB/s wkB/s avgrq-sz avgqu-sz await r_await w_await svctm %util
xvda 0.00 0.23 0.21 0.18 4.52 2.08 34.37 0.00 9.98 13.80 5.42 2.44 0.09
xvdb 0.01 0.00 1.02 8.94 127.97 598.53 145.79 0.00 0.43 1.78 0.28 0.25 0.25
xvdc 0.01 0.00 1.02 8.86 127.79 595.94 146.50 0.00 0.45 1.82 0.30 0.27 0.26
dm-0 0.00 0.00 0.69 2.32 10.47 31.69 28.01 0.01 3.23 0.71 3.98 0.13 0.04
dm-1 0.00 0.00 0.00 0.94 0.01 3.78 8.00 0.33 345.84 0.04 346.81 0.01 0.00
dm-2 0.00 0.00 0.09 0.07 1.35 0.36 22.50 0.00 2.55 0.23 5.62 1.78 0.03
[...]
^C
&lt;/code>&lt;/pre>
&lt;p>这是用于查看块设备（磁盘）情况的一个很棒的工具，无论是对工作负载还是性能表现来说。查看个列：&lt;/p>
&lt;ul>
&lt;li>&lt;strong>r/s, w/s, rkB/s, wkB/s&lt;/strong>：这些分别代表该设备每秒的读次数、写次数、读取 kb 数，和写入 kb 数。这些用于描述工作负载。性能问题可能仅仅是由于施加了过大的负载。&lt;/li>
&lt;li>&lt;strong>await&lt;/strong>：以毫秒为单位的 I/O 平均消耗时间。这是应用程序消耗的实际时间，因为它包括了排队时间和处理时间。比预期更大的平均时间可能意味着设备的饱和，或设备出了问题。&lt;/li>
&lt;li>&lt;strong>avgqu-sz&lt;/strong>：向设备发出的请求的平均数量。值大于 1 说明已经饱和了（虽说设备可以并行处理请求，尤其是由多个磁盘组成的虚拟设备。）&lt;/li>
&lt;li>&lt;strong>%util&lt;/strong>：设备利用率。这个值是一个显示出该设备在工作时每秒处于忙碌状态的百分比。若值大于 60％，通常表明性能不佳（可以从 await 中看出），虽然它取决于设备本身。值接近   100% 通常意味着已饱和。&lt;/li>
&lt;/ul>
&lt;p>如果该存储设备是一个面向很多后端磁盘的逻辑磁盘设备，则 100% 利用率可能只是意味着当前正在处理某些 I/O 占用，然而，后端磁盘可能远未饱和，并且可能能够处理更多的工作。&lt;/p>
&lt;p>请记住，磁盘 I/O 性能较差不一定是程序的问题。许多技术通常是异步 I/O，使应用程序不会被阻塞并遭受延迟（例如，预读，以及写缓冲）。&lt;/p>
&lt;h3 id="7-free--m">7. free -m&lt;/h3>
&lt;pre>&lt;code>$ free -m
total used free shared buffers cached
Mem: 245998 24545 221453 83 59 541
-/+ buffers/cache: 23944 222053
Swap: 0 0 0
&lt;/code>&lt;/pre>
&lt;p>右边的两列显式：&lt;/p>
&lt;ul>
&lt;li>&lt;strong>buffers&lt;/strong>：用于块设备 I/O 的缓冲区缓存。&lt;/li>
&lt;li>&lt;strong>cached&lt;/strong>：用于文件系统的页面缓存。&lt;/li>
&lt;/ul>
&lt;p>我们只是想要检查这些不接近零的大小，其可能会导致更高磁盘 I/O（使用 iostat 确认），和更糟糕的性能。上面的例子看起来还不错，每一列均有很多 M 个大小。&lt;/p>
&lt;p>比起第一行，-/+ buffers/cache 提供的内存使用量会更加准确些。Linux 会把暂时用不上的内存用作缓存，一旦应用需要的时候就立刻重新分配给它。所以部分被用作缓存的内存其实也算是空闲的内存。为了解释这一点， 甚至有人专门建了个网站： &lt;a href="http://www.linuxatemyram.com/">linuxatemyram&lt;/a>。&lt;/p>
&lt;p>如果你在 Linux 上安装了 ZFS，这一点会变得更加困惑，因为 ZFS 它自己的文件系统缓存不算入 free -m。有时候发现系统已经没有多少空闲内存可用了，其实内存却都待在 ZFS 的缓存里。&lt;/p>
&lt;h3 id="8-sar--n-dev-1">8. sar -n DEV 1&lt;/h3>
&lt;pre>&lt;code>$ sar \-n DEV 1
Linux 3.13.0\-49\-generic (titanclusters-xxxxx)  07/14/2015     \_x86\_64\_    (32 CPU)
12:16:48 AM     IFACE   rxpck/s   txpck/s    rxkB/s    txkB/s   rxcmp/s   txcmp/s  rxmcst/s   %ifutil
12:16:49 AM      eth0  18763.00   5032.00  20686.42    478.30      0.00      0.00      0.00      0.00
12:16:49 AM        lo     14.00     14.00      1.36      1.36      0.00      0.00      0.00      0.00
12:16:49 AM   docker0      0.00      0.00      0.00      0.00      0.00      0.00      0.00      0.00
12:16:49 AM     IFACE   rxpck/s   txpck/s    rxkB/s    txkB/s   rxcmp/s   txcmp/s  rxmcst/s   %ifutil
12:16:50 AM      eth0  19763.00   5101.00  21999.10    482.56      0.00      0.00      0.00      0.00
12:16:50 AM        lo     20.00     20.00      3.25      3.25      0.00      0.00      0.00      0.00
12:16:50 AM   docker0      0.00      0.00      0.00      0.00      0.00      0.00      0.00      0.00
^C
&lt;/code>&lt;/pre>
&lt;p>这个工具可以被用来检查网络接口的吞吐量：rxkB/s 和 txkB/s，以及是否达到限额。上面的例子中，eth0 接收的流量达到 22Mbytes/s，也即 176Mbits/sec（限额是 1Gbit/sec）&lt;/p>
&lt;p>我们用的版本中还提供了 %ifutil 作为设备使用率（接收和发送的最大值）的指标。我们也可以用 Brendan 的 &lt;a href="https://github.com/scotte/nicstat">nicstat 工具&lt;/a>计量这个值。一如 nicstat，sar 显示的这个值是很难精确取得的，在这个例子里面，它就没在正常的工作（0.00）。&lt;/p>
&lt;h3 id="9-sar--n-tcpetcp-1">9. sar -n TCP,ETCP 1&lt;/h3>
&lt;pre>&lt;code>$ sar -n TCP,ETCP 1
Linux 3.13.0-49-generic (titanclusters-xxxxx) 07/14/2015 _x86_64_ (32 CPU)
12:17:19 AM active/s passive/s iseg/s oseg/s
12:17:20 AM 1.00 0.00 10233.00 18846.00
12:17:19 AM atmptf/s estres/s retrans/s isegerr/s orsts/s
12:17:20 AM 0.00 0.00 0.00 0.00 0.00
12:17:20 AM active/s passive/s iseg/s oseg/s
12:17:21 AM 1.00 0.00 8359.00 6039.00
12:17:20 AM atmptf/s estres/s retrans/s isegerr/s orsts/s
12:17:21 AM 0.00 0.00 0.00 0.00 0.00
^C
&lt;/code>&lt;/pre>
&lt;p>这是一些关键的 TCP 指标的汇总视图。这些包括：&lt;/p>
&lt;ul>
&lt;li>&lt;strong>active/s&lt;/strong>：每秒本地发起 TCP 连接数（例如，通过 connect()）。&lt;/li>
&lt;li>&lt;strong>passive/s&lt;/strong>：每秒远程发起的 TCP 连接数（例如，通过 accept()）。&lt;/li>
&lt;li>&lt;strong>retrans/s&lt;/strong>：每秒重传 TCP 次数。&lt;/li>
&lt;/ul>
&lt;p>active 和 passive 的连接数往往对于描述一个粗略衡量服务器负载是非常有用的：新接受的连接数（passive），下行连接数（active）。可以理解为 active 连接是对外的，而 passive 连接是对内的，虽然严格来说并不完全正确（例如，一个 localhost 到 localhost 的连接）。&lt;/p>
&lt;p>重传是出现一个网络和服务器问题的一个征兆。其可能是由于一个不可靠的网络（例如，公网）造成的，或许也有可能是由于服务器过载并丢包。上面的例子显示了每秒只有一个新的 TCP 连接。&lt;/p>
&lt;h3 id="10-top">10. top&lt;/h3>
&lt;pre>&lt;code>$ top
top - 00:15:40 up 21:56, 1 user, load average: 31.09, 29.87, 29.92
Tasks: 871 total, 1 running, 868 sleeping, 0 stopped, 2 zombie
%Cpu(s): 96.8 us, 0.4 sy, 0.0 ni, 2.7 id, 0.1 wa, 0.0 hi, 0.0 si, 0.0 st
KiB Mem: 25190241+total, 24921688 used, 22698073+free, 60448 buffers
KiB Swap: 0 total, 0 used, 0 free. 554208 cached Mem
PID USER PR NI VIRT RES SHR S %CPU %MEM TIME+ COMMAND
20248 root 20 0 0.227t 0.012t 18748 S 3090 5.2 29812:58 java
4213 root 20 0 2722544 64640 44232 S 23.5 0.0 233:35.37 mesos-slave
66128 titancl+ 20 0 24344 2332 1172 R 1.0 0.0 0:00.07 top
5235 root 20 0 38.227g 547004 49996 S 0.7 0.2 2:02.74 java
4299 root 20 0 20.015g 2.682g 16836 S 0.3 1.1 33:14.42 java
1 root 20 0 33620 2920 1496 S 0.0 0.0 0:03.82 init
2 root 20 0 0 0 0 S 0.0 0.0 0:00.02 kthreadd
3 root 20 0 0 0 0 S 0.0 0.0 0:05.35 ksoftirqd/0
5 root 0 -20 0 0 0 S 0.0 0.0 0:00.00 kworker/0:0H
6 root 20 0 0 0 0 S 0.0 0.0 0:06.94 kworker/u256:0
8 root 20 0 0 0 0 S 0.0 0.0 2:38.05 rcu_sched
&lt;/code>&lt;/pre>
&lt;p>top 命令包含了很多我们之前已经检查过的指标。可以方便的执行它来查看相比于之前的命令输出的结果有很大不同，这表明负载是可变的。&lt;/p>
&lt;p>top 的一个缺点是，很难看到数据随时间变动的趋势。vmstat 和 pidstat 提供的滚动输出会更清楚一些。如果你不以足够快的速度暂停输出（Ctrl-S 暂停，Ctrl-Q 继续），一些间歇性问题的线索也可能由于被清屏而丢失。&lt;/p>
&lt;h3 id="后续的分析">后续的分析&lt;/h3>
&lt;p>还有更多命令和方法可以用于更深入的分析。查看 Brendan 在 Velocity 2015 大会上的 &lt;a href="http://techblog.netflix.com/2015/08/netflix-at-velocity-2015-linux.html">Linux 性能工具教程&lt;/a>，其中包含了超过 40 个命令，涵盖了可观测性、标杆管理、调优、静态性能调优、分析，和跟踪等方面。&lt;/p>
&lt;p>在全网规模应对系统的可靠性和性能问题是我们的爱好之一。如果你想要加入我们来一起应对这种挑战，我们正在招聘！
&lt;a href="https://www.oschina.net/translate/linux-performance-analysis-in-60s?print">https://www.oschina.net/translate/linux-performance-analysis-in-60s?print&lt;/a>&lt;/p></description></item><item><title>Docs: ApacheBench # Apache HTTP服务器基准测试工具</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/x.linux-%E7%AE%A1%E7%90%86/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96-%E4%B8%8E-%E6%95%85%E9%9A%9C%E5%A4%84%E7%90%86/%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95/apachebench-#-apache-http%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%9F%BA%E5%87%86%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/x.linux-%E7%AE%A1%E7%90%86/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96-%E4%B8%8E-%E6%95%85%E9%9A%9C%E5%A4%84%E7%90%86/%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95/apachebench-#-apache-http%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%9F%BA%E5%87%86%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/</guid><description>
&lt;h1 id="heading">&lt;/h1>
&lt;h1 id="apachebench-介绍">ApacheBench 介绍&lt;/h1>
&lt;p>ApacheBench，简称 ab。ab 是用于对 Apache 超文本传输协议（HTTP）服务器进行基准测试的工具。它旨在使您对当前的 Apache 安装方式有一个印象。这尤其向您显示 Apache 安装每秒能够处理多少个请求。&lt;/p>
&lt;h1 id="apachebench-的安装与使用">ApacheBench 的安装与使用&lt;/h1>
&lt;p>ab 工具包含在 httpd-tools 软件包中，直接安装 httpd-tools 即可&lt;/p>
&lt;h1 id="apachebench-测试结果参数解析">ApacheBench 测试结果参数解析&lt;/h1></description></item><item><title>Docs: awk</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/x.linux-%E7%AE%A1%E7%90%86/linux-%E6%96%87%E6%9C%AC%E5%A4%84%E7%90%86/awk/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/x.linux-%E7%AE%A1%E7%90%86/linux-%E6%96%87%E6%9C%AC%E5%A4%84%E7%90%86/awk/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://www.gnu.org/software/gawk/">官网&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.gnu.org/software/gawk/manual/gawkinet/">官方文档&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>awk 以字段为单位进行处理&lt;/p>
&lt;p>其实就是把一行的数据分割,然后对每个字段进行处理,包含 cut 等命令)，支持变量，条件判断，循环，数组等编程基本语言&lt;/p>
&lt;h1 id="syntax语法">Syntax(语法)&lt;/h1>
&lt;p>&lt;strong>awk [OPTIONS] &amp;lsquo;COMMAND&amp;rsquo; FILE&lt;/strong>
&lt;strong>awk [OPTIONS] &amp;lsquo;PATTERN1{ACTION1} PATTERN2{ACTION2}&amp;hellip;.&amp;rsquo; FILE&lt;/strong>&lt;/p>
&lt;p>OPTIONS：&lt;/p>
&lt;ul>
&lt;li>&lt;strong>-f FILE&lt;/strong> # 指定要使用的 awk 代码文件。&lt;/li>
&lt;li>&lt;strong>-F [“[分隔符]”]&lt;/strong> # 指定分隔符，默认分隔符为一个或多个的“空格键”或者“tab 键”，也可以具体指定一个或多个
&lt;ul>
&lt;li>e.g.当使用-F “ [/:]”的时候即是空格、/、:这三个符号出现任意一个都算作一个分隔符&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h1 id="awk-语言">AWK 语言&lt;/h1>
&lt;p>awk 其实本质上可以看作编程语言，只不过这个语言只是用来处理文本的而已。在使用命令时，可以使用 &lt;code>-f&lt;/code> 选项指定要使用的代码文件。&lt;/p>
&lt;h2 id="awk-语言的基本结构">awk 语言的基本结构&lt;/h2>
&lt;p>awk 代码由 &lt;code>PATTERN {ACTION}&lt;/code> 组成，PATTERN 是可省略的。&lt;/p>
&lt;ul>
&lt;li>PATTERN 用来进行匹配的模式，匹配到的内容将会执行 ACTION 中定义的操作
&lt;ul>
&lt;li>/搜索模式/&lt;/li>
&lt;li>判断模式&lt;/li>
&lt;li>BEGIN 执行 ACTION 前的准备工作，比如给 awk 中的自带变量赋值,在 print 前在屏幕输出点内容&lt;/li>
&lt;li>END 执行 ACTION 后的收尾工作&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>ACTION 用来执行具体的动作
&lt;ul>
&lt;li>print $NUM &amp;ldquo;输出内容&amp;rdquo; $NUM&amp;hellip;&amp;hellip; # 在屏幕输出哪几个字段以及哪些内容，内容可以是各种分隔符&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>一个最简单的 awk 代码如下：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">{&lt;/span>print $0&lt;span style="color:#f92672">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>这里省略的匹配模式，也就是说匹配所有内容。直接使用一个 ACTION，输出文件中的所有内容了。&lt;/p>
&lt;h3 id="特殊的-begin-与-end-模式">特殊的 BEGIN 与 END 模式&lt;/h3>
&lt;p>BEGIN 与 END 与正常的模式不同，不用于匹配输入记录。通常用来为本次 awk 的运行提供启动和清理操作。&lt;/p>
&lt;blockquote>
&lt;p>BEGIN 模式通常用来进行变量复制。END 模式通常用来清理数据&lt;/p>
&lt;/blockquote>
&lt;h2 id="hello-world">Hello World&lt;/h2>
&lt;p>假设现在有如下文件：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>Hello World Text
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>awk 代码如下：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>BEGIN &lt;span style="color:#f92672">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> string &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#34;Hello World&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> printf&lt;span style="color:#f92672">(&lt;/span>&lt;span style="color:#e6db74">&amp;#34;%s%s&amp;#34;&lt;/span>,string,RS&lt;span style="color:#f92672">)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> printf&lt;span style="color:#f92672">(&lt;/span>&lt;span style="color:#e6db74">&amp;#34;%s%s&amp;#34;&lt;/span>,$0,RS&lt;span style="color:#f92672">)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>输出结果：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># 可以直接执行 BEGIN 模式中的动作&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>root@lichenhao:~/test_dir# awk -f helloworld.awk
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Hello World
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>^C
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># 需要指定待处理文件，才可以执行匹配模式中的动作&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>root@lichenhao:~/test_dir# awk -f helloworld.awk text
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Hello World
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Hello World Text
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="awk-中的变量">awk 中的变量&lt;/h2>
&lt;p>引用 awd 中的内置变量时不用 &lt;code>$&lt;/code> 符号&lt;/p>
&lt;ul>
&lt;li>&lt;strong>$0&lt;/strong> # 全部输入&lt;/li>
&lt;li>&lt;strong>ARGC&lt;/strong> #&lt;/li>
&lt;li>&lt;strong>FS&lt;/strong> # 字段分隔字符，&lt;code>默认值：空格&lt;/code>&lt;/li>
&lt;li>&lt;strong>NF&lt;/strong> # 每一行拥有的字段总数(当每行字段数不一样，可以 print NF 来打印每行的最后一个字段)&lt;/li>
&lt;li>&lt;strong>NR&lt;/strong> # 目前 awk 所处理的是第几行的数据&lt;/li>
&lt;li>&lt;strong>OFS&lt;/strong> # 当前输出内容 print 的时候使用的分隔符，默认为空白，print 中以逗号分隔每个字段&lt;/li>
&lt;li>&lt;strong>RS&lt;/strong> # 分隔符。&lt;code>默认值：\n&lt;/code>，即换行符&lt;/li>
&lt;/ul>
&lt;h2 id="应用示例">应用示例&lt;/h2>
&lt;h3 id="简单示例">简单示例&lt;/h3>
&lt;ul>
&lt;li>输出文本最后一行
&lt;ul>
&lt;li>awk &amp;lsquo;END {print}&amp;rsquo;&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>从 FILE 文件中，删除每行第一列，输出剩余的
&lt;ul>
&lt;li>awk &amp;lsquo;{ $1=&amp;quot;&amp;quot;; print $0 }&amp;rsquo; FILE&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>查找 hcs 的 access 实时日志的带 HIT 字符的行，取出第五段内容然后排序总结，该日志可以实时查看用户的命中情况以及访问的资源
&lt;ul>
&lt;li>cat accesslog | grep &amp;lsquo;HIT&amp;rsquo; | awk &amp;lsquo;{print $5}&amp;rsquo; | sort | uniq -c&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>在/etc/passwd 文件中，每行以:为分隔符，打印 username:这几个字符，后面跟以:分割的第一个字段内容，后面跟换行(\n)然后 uid:这几个字符，再跟第三个字段内容,效果如右图所示
&lt;ul>
&lt;li>awk -F&amp;quot;:&amp;quot; &amp;lsquo;{ print &amp;ldquo;username:&amp;rdquo; $1 &amp;ldquo;\nuid:&amp;rdquo; $3 }&amp;rsquo; /etc/passwd&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>搜索模式以冒号为分隔符,找到第七个字段以 bash 结尾的所有行,输出每行的第一个和第三个字段(注意：这里面的~在 shell 环境中是用=~表示的)
&lt;ul>
&lt;li>cat /etc/passwd | awk -F : &amp;lsquo;$7~/bash$/{print $1,$3}&amp;rsquo;
&lt;ul>
&lt;li>还可以写成判断模式，判断第七字段的字符是否等于/bin/bash，&lt;/li>
&lt;li>cat /etc/passwd | awk -F : &amp;lsquo;$7==&amp;quot;/bin/bash&amp;quot;/{print $1,$3}&amp;rsquo;&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>以冒号为分隔符的第三个字段数小于 10 的那些行，输出其中的第一和第三个字段
&lt;ul>
&lt;li>cat /etc/passwd | awk -F : &amp;lsquo;$3&amp;lt;10{print $1,$3}&amp;rsquo;&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;!-- raw HTML omitted -->
&lt;/li>
&lt;li>以=号为分隔符，不包含开头带#或者空白行的所有行，显示这些行的第一个字段,判断模式与搜索模式并用
&lt;ul>
&lt;li>awk -F = &amp;lsquo;!/^#|^$/{print $1}&amp;rsquo; /etc/sysctl.conf
&lt;ul>
&lt;li>awk -F = &amp;lsquo;/^[^#]/{print $1}&amp;rsquo; /etc/sysctl.conf #不含#的行&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>查看当前的普通用户个数
&lt;ul>
&lt;li>cat /etc/passwd | awk -F : &amp;lsquo;$3&amp;gt;1000 &amp;amp;&amp;amp; $7==&amp;quot;/bin/bash&amp;quot;{print $1,$3}&amp;rsquo;&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>其他
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/aokdnm/1616166312890-e4478d40-8a1b-4f08-a348-81ee7c69c9e0.jpeg" alt="">&lt;/p>
&lt;h3 id="procsoftirqs-文件处理示例">/proc/softirqs 文件处理示例&lt;/h3>
&lt;p>由于 /proc/softirqs 文件中第一行与其他行，前面少了一些内容，所有第一行系列要多空出来一些字符&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>BEGIN&lt;span style="color:#f92672">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> cpucount &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">6&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># 处理第一行&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>NR &lt;span style="color:#f92672">==&lt;/span> 1&lt;span style="color:#f92672">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> num &lt;span style="color:#f92672">=&lt;/span> 5;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e"># 由于第一行少了一列，所以让第一列与第二行的第二列对其&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> printf&lt;span style="color:#f92672">(&lt;/span>&lt;span style="color:#e6db74">&amp;#34;%30s&amp;#34;&lt;/span>,$1&lt;span style="color:#f92672">)&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e"># 从第二列开始循环，每隔15个字符便输出一列&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span> &lt;span style="color:#f92672">(&lt;/span>i&lt;span style="color:#f92672">=&lt;/span>2;i&amp;lt;&lt;span style="color:#f92672">=&lt;/span>cpucount;i++&lt;span style="color:#f92672">)&lt;/span> &lt;span style="color:#f92672">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> printf&lt;span style="color:#f92672">(&lt;/span>&lt;span style="color:#e6db74">&amp;#34;%15s\t&amp;#34;&lt;/span>,$i&lt;span style="color:#f92672">)&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> printf&lt;span style="color:#f92672">(&lt;/span>RS&lt;span style="color:#f92672">)&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># 处理第二行及以后的行&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>NR &amp;gt; 1&lt;span style="color:#f92672">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e"># 通过循环，每隔15个字符便输出一列。输出完成后换行。&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span> &lt;span style="color:#f92672">(&lt;/span>i&lt;span style="color:#f92672">=&lt;/span>1;i&amp;lt;&lt;span style="color:#f92672">=&lt;/span>cpucount+1;i++&lt;span style="color:#f92672">)&lt;/span> &lt;span style="color:#f92672">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> printf&lt;span style="color:#f92672">(&lt;/span>&lt;span style="color:#e6db74">&amp;#34;%15s\t&amp;#34;&lt;/span>,$i&lt;span style="color:#f92672">)&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> printf&lt;span style="color:#f92672">(&lt;/span>RS&lt;span style="color:#f92672">)&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="聚合一个文件中指定字段的数字求和">聚合一个文件中指定字段的数字，求和&lt;/h3>
&lt;ul>
&lt;li>文件中的内容如下&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">[&lt;/span>root@dengrui test_dir&lt;span style="color:#f92672">]&lt;/span>&lt;span style="color:#75715e"># cat strace.file&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">31090&lt;/span> pread64&lt;span style="color:#f92672">(&lt;/span>227, &lt;span style="color:#e6db74">&amp;#34;&amp;#34;&lt;/span>..., 16384, 81920&lt;span style="color:#f92672">)&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">16384&lt;/span> &amp;lt;0.000991&amp;gt;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">31090&lt;/span> pread64&lt;span style="color:#f92672">(&lt;/span>227, &lt;span style="color:#e6db74">&amp;#34;&amp;#34;&lt;/span>..., 16384, 65536&lt;span style="color:#f92672">)&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">16384&lt;/span> &amp;lt;0.001292&amp;gt;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">31090&lt;/span> pread64&lt;span style="color:#f92672">(&lt;/span>227, &lt;span style="color:#e6db74">&amp;#34;&amp;#34;&lt;/span>..., 16384, 98304&lt;span style="color:#f92672">)&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">16384&lt;/span> &amp;lt;0.000176&amp;gt;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">31090&lt;/span> pread64&lt;span style="color:#f92672">(&lt;/span>129, &lt;span style="color:#e6db74">&amp;#34;&amp;#34;&lt;/span>..., 16384, 131072&lt;span style="color:#f92672">)&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">16384&lt;/span> &amp;lt;0.002121&amp;gt;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">31090&lt;/span> pread64&lt;span style="color:#f92672">(&lt;/span>129, &lt;span style="color:#e6db74">&amp;#34;&amp;#34;&lt;/span>..., 16384, 16384&lt;span style="color:#f92672">)&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">16384&lt;/span> &amp;lt;0.000932&amp;gt;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">31090&lt;/span> pread64&lt;span style="color:#f92672">(&lt;/span>128, &lt;span style="color:#e6db74">&amp;#34;&amp;#34;&lt;/span>..., 16384, 49152&lt;span style="color:#f92672">)&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">16384&lt;/span> &amp;lt;0.001072&amp;gt;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">31090&lt;/span> pread64&lt;span style="color:#f92672">(&lt;/span>128, &lt;span style="color:#e6db74">&amp;#34;&amp;#34;&lt;/span>..., 16384, 16384&lt;span style="color:#f92672">)&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">16384&lt;/span> &amp;lt;0.000820&amp;gt;
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ul>
&lt;li>通过 awk 命令，聚合系统调用中的第三个参数&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>awk -F, &lt;span style="color:#e6db74">&amp;#39;{print $3}&amp;#39;&lt;/span> test.file | awk &lt;span style="color:#e6db74">&amp;#39;{sum += $1} END {print sum}&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div></description></item><item><title>Docs: BCC 工具集</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/x.linux-%E7%AE%A1%E7%90%86/linux-%E7%B3%BB%E7%BB%9F%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/bcc-%E5%B7%A5%E5%85%B7%E9%9B%86/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/x.linux-%E7%AE%A1%E7%90%86/linux-%E7%B3%BB%E7%BB%9F%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/bcc-%E5%B7%A5%E5%85%B7%E9%9B%86/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://iovisor.github.io/bcc/">官网&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://github.com/iovisor/bcc">GitHub 项目,iovisor/bcc&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>&lt;strong>BPF Compiler Collection(BPF 编译器合集，简称 BCC)&lt;/strong> 是用于创建有效的内核跟踪和操作程序的工具包。BCC 是 Linux 基金会旗下的 IO Visor 项目组做出来的基于 eBPF 的产品。BBC 主要用来为 Linux 提供 &lt;strong>Dynamic Tracing(动态追踪)&lt;/strong> 功能的实现。
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/ng174l/1619076409581-b90915a0-9bcb-4aa7-8ea4-4f0d66048ddd.png" alt="image.png">&lt;/p>
&lt;h1 id="bcc-安装">BCC 安装&lt;/h1>
&lt;h2 id="通过-linux-包管理器安装">通过 Linux 包管理器安装&lt;/h2>
&lt;h3 id="ubuntu">Ubuntu&lt;/h3>
&lt;p>标准的 Ubuntu Universe 仓库 与 iovisor 的 PPA 仓库中都可以用来安装 BCC 工具，但是包的名称不同。Ubuntu 安装完的程序，其名称会在最后加上 &lt;code>-bpfcc&lt;/code>。&lt;/p>
&lt;ul>
&lt;li>使用 Ubuntu 仓库安装&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>sudo apt-get install bpfcc-tools linux-headers-&lt;span style="color:#66d9ef">$(&lt;/span>uname -r&lt;span style="color:#66d9ef">)&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ul>
&lt;li>使用 iovisor 仓库安装&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>sudo apt-key adv --keyserver keyserver.ubuntu.com --recv-keys 4052245BD4284CDD
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>echo &lt;span style="color:#e6db74">&amp;#34;deb https://repo.iovisor.org/apt/&lt;/span>&lt;span style="color:#66d9ef">$(&lt;/span>lsb_release -cs&lt;span style="color:#66d9ef">)&lt;/span>&lt;span style="color:#e6db74"> &lt;/span>&lt;span style="color:#66d9ef">$(&lt;/span>lsb_release -cs&lt;span style="color:#66d9ef">)&lt;/span>&lt;span style="color:#e6db74"> main&amp;#34;&lt;/span> | sudo tee /etc/apt/sources.list.d/iovisor.list
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>sudo apt-get update
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>sudo apt-get install bcc-tools libbcc-examples linux-headers-&lt;span style="color:#66d9ef">$(&lt;/span>uname -r&lt;span style="color:#66d9ef">)&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="centos">CentOS&lt;/h3>
&lt;h1 id="bcc-工具概述">BCC 工具概述&lt;/h1>
&lt;p>命名规则
XXXsnoop 这类工具的名字通常用来追踪指定对象，snoop 有窥探之意。比如 opensnoop 工具用来追踪 open() 系统调用、execsnoop 工具用来追踪 exec() 系统调用 等等。&lt;/p>
&lt;p>&lt;strong>syscount&lt;/strong> # 追踪系统调用，并统计次数
&lt;strong>tcpconnect&lt;/strong> # 追踪活动的 TCP 连接，即 &lt;code>connect()&lt;/code> 系统调用。
&lt;strong>tcptracer&lt;/strong> # 追踪&lt;/p>
&lt;h3 id="heading">&lt;/h3></description></item><item><title>Docs: bpftrace 工具</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/x.linux-%E7%AE%A1%E7%90%86/linux-%E7%B3%BB%E7%BB%9F%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/bpftrace-%E5%B7%A5%E5%85%B7/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/x.linux-%E7%AE%A1%E7%90%86/linux-%E7%B3%BB%E7%BB%9F%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/bpftrace-%E5%B7%A5%E5%85%B7/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://github.com/iovisor/bpftrace">GitHub 项目&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>bpftrace 是用于 Linux 增强型 eBPF 的高级跟踪语言，可在最近的 Linux 内核 (4.x) 中使用。 bpftrace 使用 LLVM 作为后端，将脚本编译为 BPF 字节码，并利用 BCC 与 Linux BPF 系统交互，以及现有的 Linux 跟踪功能：内核动态跟踪（kprobes）、用户级动态跟踪（uprobes）、和跟踪点。 bpftrace 语言的灵感来自 awk 和 C，以及 DTrace 和 SystemTap 等前身跟踪器。 bpftrace 是由 Alastair Robertson 创建的。、&lt;/p>
&lt;p>&lt;strong>简单示例&lt;/strong>&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># Files opened by process&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>bpftrace -e &lt;span style="color:#e6db74">&amp;#39;tracepoint:syscalls:sys_enter_open { printf(&amp;#34;%s %s\n&amp;#34;, comm, str(args-&amp;gt;filename)); }&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># Syscall count by program&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>bpftrace -e &lt;span style="color:#e6db74">&amp;#39;tracepoint:raw_syscalls:sys_enter { @[comm] = count(); }&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># Read bytes by process:&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>bpftrace -e &lt;span style="color:#e6db74">&amp;#39;tracepoint:syscalls:sys_exit_read /args-&amp;gt;ret/ { @[comm] = sum(args-&amp;gt;ret); }&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># Read size distribution by process:&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>bpftrace -e &lt;span style="color:#e6db74">&amp;#39;tracepoint:syscalls:sys_exit_read { @[comm] = hist(args-&amp;gt;ret); }&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># Show per-second syscall rates:&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>bpftrace -e &lt;span style="color:#e6db74">&amp;#39;tracepoint:raw_syscalls:sys_enter { @ = count(); } interval:s:1 { print(@); clear(@); }&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># Trace disk size by process&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>bpftrace -e &lt;span style="color:#e6db74">&amp;#39;tracepoint:block:block_rq_issue { printf(&amp;#34;%d %s %d\n&amp;#34;, pid, comm, args-&amp;gt;bytes); }&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># Count page faults by process&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>bpftrace -e &lt;span style="color:#e6db74">&amp;#39;software:faults:1 { @[comm] = count(); }&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># Count LLC cache misses by process name and PID (uses PMCs):&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>bpftrace -e &lt;span style="color:#e6db74">&amp;#39;hardware:cache-misses:1000000 { @[comm, pid] = count(); }&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># Profile user-level stacks at 99 Hertz, for PID 189:&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>bpftrace -e &lt;span style="color:#e6db74">&amp;#39;profile:hz:99 /pid == 189/ { @[ustack] = count(); }&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># Files opened, for processes in the root cgroup-v2&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>bpftrace -e &lt;span style="color:#e6db74">&amp;#39;tracepoint:syscalls:sys_enter_openat /cgroup == cgroupid(&amp;#34;/sys/fs/cgroup/unified/mycg&amp;#34;)/ { printf(&amp;#34;%s\n&amp;#34;, str(args-&amp;gt;filename)); }&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div></description></item><item><title>Docs: C10K 与 C100K 问题</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/x.linux-%E7%AE%A1%E7%90%86/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96-%E4%B8%8E-%E6%95%85%E9%9A%9C%E5%A4%84%E7%90%86/%E7%BD%91%E7%BB%9C%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/c10k-%E4%B8%8E-c100k-%E9%97%AE%E9%A2%98/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/x.linux-%E7%AE%A1%E7%90%86/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96-%E4%B8%8E-%E6%95%85%E9%9A%9C%E5%A4%84%E7%90%86/%E7%BD%91%E7%BB%9C%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/c10k-%E4%B8%8E-c100k-%E9%97%AE%E9%A2%98/</guid><description>
&lt;p>你好，我是倪朋飞。&lt;/p>
&lt;p>前面内容，我们学习了 Linux 网络的基础原理以及性能观测方法。简单回顾一下，Linux 网络基于 TCP/IP 模型，构建了其网络协议栈，把繁杂的网络功能划分为应用层、传输层、网络层、网络接口层等四个不同的层次，既解决了网络环境中设备异构的问题，也解耦了网络协议的复杂性。&lt;/p>
&lt;p>基于 TCP/IP 模型，我们还梳理了 Linux 网络收发流程和相应的性能指标。在应用程序通过套接字接口发送或者接收网络包时，这些网络包都要经过协议栈的逐层处理。我们通常用带宽、吞吐、延迟、PPS 等来衡量网络性能。&lt;/p>
&lt;p>今天，我们主要来回顾下经典的 C10K 和 C1000K 问题，以更好理解 Linux 网络的工作原理，并进一步分析，如何做到单机支持 C10M。&lt;/p>
&lt;p>注意，C10K 和 C1000K 的首字母 C 是 Client 的缩写。C10K 就是单机同时处理 1 万个请求（并发连接 1 万）的问题，而 C1000K 也就是单机支持处理 100 万个请求（并发连接 100 万）的问题。&lt;/p>
&lt;h2 id="c10k">C10K&lt;/h2>
&lt;p>C10K 问题最早由 Dan Kegel 在 1999 年提出。那时的服务器还只是 32 位系统，运行着 Linux 2.2 版本（后来又升级到了 2.4 和 2.6，而 2.6 才支持 x86_64），只配置了很少的内存（2GB）和千兆网卡。&lt;/p>
&lt;p>怎么在这样的系统中支持并发 1 万的请求呢？&lt;/p>
&lt;p>从资源上来说，对 2GB 内存和千兆网卡的服务器来说，同时处理 10000 个请求，只要每个请求处理占用不到 200KB（2GB/10000）的内存和 100Kbit （1000Mbit/10000）的网络带宽就可以。所以，物理资源是足够的，接下来自然是软件的问题，特别是网络的 I/O 模型问题。&lt;/p>
&lt;p>说到 I/O 的模型，我在文件系统的原理中，曾经介绍过文件 I/O，其实网络 I/O 模型也类似。在 C10K 以前，Linux 中网络处理都用同步阻塞的方式，也就是每个请求都分配一个进程或者线程。请求数只有 100 个时，这种方式自然没问题，但增加到 10000 个请求时，10000 个进程或线程的调度、上下文切换乃至它们占用的内存，都会成为瓶颈。&lt;/p>
&lt;p>既然每个请求分配一个线程的方式不合适，那么，为了支持 10000 个并发请求，这里就有两个问题需要我们解决。&lt;/p>
&lt;p>第一，怎样在一个线程内处理多个请求，也就是要在一个线程内响应多个网络 I/O。以前的同步阻塞方式下，一个线程只能处理一个请求，到这里不再适用，是不是可以用非阻塞 I/O 或者异步 I/O 来处理多个网络请求呢？&lt;/p>
&lt;p>第二，怎么更节省资源地处理客户请求，也就是要用更少的线程来服务这些请求。是不是可以继续用原来的 100 个或者更少的线程，来服务现在的 10000 个请求呢？&lt;/p>
&lt;p>当然，事实上，现在 C10K 的问题早就解决了，在继续学习下面的内容前，你可以先自己思考一下这两个问题。结合前面学过的内容，你是不是已经有了解决思路呢？&lt;/p>
&lt;h3 id="io-模型优化">I/O 模型优化&lt;/h3>
&lt;p>异步、非阻塞 I/O 的解决思路，你应该听说过，其实就是我们在网络编程中经常用到的 I/O 多路复用（I/O Multiplexing）。I/O 多路复用是什么意思呢？&lt;/p>
&lt;p>别急，详细了解前，我先来讲两种 I/O 事件通知的方式：水平触发和边缘触发，它们常用在套接字接口的文件描述符中。&lt;/p>
&lt;p>水平触发：只要文件描述符可以非阻塞地执行 I/O ，就会触发通知。也就是说，应用程序可以随时检查文件描述符的状态，然后再根据状态，进行 I/O 操作。&lt;/p>
&lt;p>边缘触发：只有在文件描述符的状态发生改变（也就是 I/O 请求达到）时，才发送一次通知。这时候，应用程序需要尽可能多地执行 I/O，直到无法继续读写，才可以停止。如果 I/O 没执行完，或者因为某种原因没来得及处理，那么这次通知也就丢失了。&lt;/p>
&lt;p>接下来，我们再回过头来看 I/O 多路复用的方法。这里其实有很多实现方法，我带你来逐个分析一下。&lt;/p>
&lt;p>第一种，使用非阻塞 I/O 和水平触发通知，比如使用 select 或者 poll。&lt;/p>
&lt;p>根据刚才水平触发的原理，select 和 poll 需要从文件描述符列表中，找出哪些可以执行 I/O ，然后进行真正的网络 I/O 读写。由于 I/O 是非阻塞的，一个线程中就可以同时监控一批套接字的文件描述符，这样就达到了单线程处理多请求的目的。&lt;/p>
&lt;p>所以，这种方式的最大优点，是对应用程序比较友好，它的 API 非常简单。&lt;/p>
&lt;p>但是，应用软件使用 select 和 poll 时，需要对这些文件描述符列表进行轮询，这样，请求数多的时候就会比较耗时。并且，select 和 poll 还有一些其他的限制。&lt;/p>
&lt;p>select 使用固定长度的位相量，表示文件描述符的集合，因此会有最大描述符数量的限制。比如，在 32 位系统中，默认限制是 1024。并且，在 select 内部，检查套接字状态是用轮询的方法，再加上应用软件使用时的轮询，就变成了一个 O(n^2) 的关系。&lt;/p>
&lt;p>而 poll 改进了 select 的表示方法，换成了一个没有固定长度的数组，这样就没有了最大描述符数量的限制（当然还会受到系统文件描述符限制）。但应用程序在使用 poll 时，同样需要对文件描述符列表进行轮询，这样，处理耗时跟描述符数量就是 O(N) 的关系。&lt;/p>
&lt;p>除此之外，应用程序每次调用 select 和 poll 时，还需要把文件描述符的集合，从用户空间传入内核空间，由内核修改后，再传出到用户空间中。这一来一回的内核空间与用户空间切换，也增加了处理成本。&lt;/p>
&lt;p>有没有什么更好的方式来处理呢？答案自然是肯定的。&lt;/p>
&lt;p>第二种，使用非阻塞 I/O 和边缘触发通知，比如 epoll。&lt;/p>
&lt;p>既然 select 和 poll 有那么多的问题，就需要继续对其进行优化，而 epoll 就很好地解决了这些问题。&lt;/p>
&lt;p>epoll 使用红黑树，在内核中管理文件描述符的集合，这样，就不需要应用程序在每次操作时都传入、传出这个集合。&lt;/p>
&lt;p>epoll 使用事件驱动的机制，只关注有 I/O 事件发生的文件描述符，不需要轮询扫描整个集合。&lt;/p>
&lt;p>不过要注意，epoll 是在 Linux 2.6 中才新增的功能（2.4 虽然也有，但功能不完善）。由于边缘触发只在文件描述符可读或可写事件发生时才通知，那么应用程序就需要尽可能多地执行 I/O，并要处理更多的异常事件。&lt;/p>
&lt;p>第三种，使用异步 I/O（Asynchronous I/O，简称为 AIO）。在前面文件系统原理的内容中，我曾介绍过异步 I/O 与同步 I/O 的区别。异步 I/O 允许应用程序同时发起很多 I/O 操作，而不用等待这些操作完成。而在 I/O 完成后，系统会用事件通知（比如信号或者回调函数）的方式，告诉应用程序。这时，应用程序才会去查询 I/O 操作的结果。&lt;/p>
&lt;p>异步 I/O 也是到了 Linux 2.6 才支持的功能，并且在很长时间里都处于不完善的状态，比如 glibc 提供的异步 I/O 库，就一直被社区诟病。同时，由于异步 I/O 跟我们的直观逻辑不太一样，想要使用的话，一定要小心设计，其使用难度比较高。&lt;/p>
&lt;h3 id="工作模型优化">工作模型优化&lt;/h3>
&lt;p>了解了 I/O 模型后，请求处理的优化就比较直观了。使用 I/O 多路复用后，就可以在一个进程或线程中处理多个请求，其中，又有下面两种不同的工作模型。&lt;/p>
&lt;p>第一种，主进程 + 多个 worker 子进程，这也是最常用的一种模型。这种方法的一个通用工作模式就是：&lt;/p>
&lt;p>主进程执行 bind() + listen() 后，创建多个子进程；&lt;/p>
&lt;p>然后，在每个子进程中，都通过 accept() 或 epoll_wait() ，来处理相同的套接字。&lt;/p>
&lt;p>比如，最常用的反向代理服务器 Nginx 就是这么工作的。它也是由主进程和多个 worker 进程组成。主进程主要用来初始化套接字，并管理子进程的生命周期；而 worker 进程，则负责实际的请求处理。我画了一张图来表示这个关系。&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/uh4s9o/1616999713216-626cf375-436a-4a06-9287-dbaeed9b9101.png" alt="">&lt;/p>
&lt;p>这里要注意，accept() 和 epoll_wait() 调用，还存在一个惊群的问题。换句话说，当网络 I/O 事件发生时，多个进程被同时唤醒，但实际上只有一个进程来响应这个事件，其他被唤醒的进程都会重新休眠。&lt;/p>
&lt;p>其中，accept() 的惊群问题，已经在 Linux 2.6 中解决了；&lt;/p>
&lt;p>而 epoll 的问题，到了 Linux 4.5 ，才通过 EPOLLEXCLUSIVE 解决。&lt;/p>
&lt;p>为了避免惊群问题， Nginx 在每个 worker 进程中，都增加一个了全局锁（accept_mutex）。这些 worker 进程需要首先竞争到锁，只有竞争到锁的进程，才会加入到 epoll 中，这样就确保只有一个 worker 子进程被唤醒。&lt;/p>
&lt;p>不过，根据前面 CPU 模块的学习，你应该还记得，进程的管理、调度、上下文切换的成本非常高。那为什么使用多进程模式的 Nginx ，却具有非常好的性能呢？&lt;/p>
&lt;p>这里最主要的一个原因就是，这些 worker 进程，实际上并不需要经常创建和销毁，而是在没任务时休眠，有任务时唤醒。只有在 worker 由于某些异常退出时，主进程才需要创建新的进程来代替它。&lt;/p>
&lt;p>当然，你也可以用线程代替进程：主线程负责套接字初始化和子线程状态的管理，而子线程则负责实际的请求处理。由于线程的调度和切换成本比较低，实际上你可以进一步把 epoll_wait() 都放到主线程中，保证每次事件都只唤醒主线程，而子线程只需要负责后续的请求处理。&lt;/p>
&lt;p>第二种，监听到相同端口的多进程模型。在这种方式下，所有的进程都监听相同的接口，并且开启 SO_REUSEPORT 选项，由内核负责将请求负载均衡到这些监听进程中去。这一过程如下图所示。&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/uh4s9o/1616999713254-1d358231-cc74-46b8-b62f-04f2eb87dc95.png" alt="">&lt;/p>
&lt;p>由于内核确保了只有一个进程被唤醒，就不会出现惊群问题了。比如，Nginx 在 1.9.1 中就已经支持了这种模式。&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/uh4s9o/1616999713255-f203326e-69a2-41da-9801-f87cef627ecb.png" alt="">&lt;/p>
&lt;p>不过要注意，想要使用 SO_REUSEPORT 选项，需要用 Linux 3.9 以上的版本才可以。&lt;/p>
&lt;h2 id="c1000k">C1000K&lt;/h2>
&lt;p>基于 I/O 多路复用和请求处理的优化，C10K 问题很容易就可以解决。不过，随着摩尔定律带来的服务器性能提升，以及互联网的普及，你并不难想到，新兴服务会对性能提出更高的要求。&lt;/p>
&lt;p>很快，原来的 C10K 已经不能满足需求，所以又有了 C100K 和 C1000K，也就是并发从原来的 1 万增加到 10 万、乃至 100 万。从 1 万到 10 万，其实还是基于 C10K 的这些理论，epoll 配合线程池，再加上 CPU、内存和网络接口的性能和容量提升。大部分情况下，C100K 很自然就可以达到。&lt;/p>
&lt;p>那么，再进一步，C1000K 是不是也可以很容易就实现呢？这其实没有那么简单了。&lt;/p>
&lt;p>首先从物理资源使用上来说，100 万个请求需要大量的系统资源。比如，&lt;/p>
&lt;p>假设每个请求需要 16KB 内存的话，那么总共就需要大约 15 GB 内存。&lt;/p>
&lt;p>而从带宽上来说，假设只有 20% 活跃连接，即使每个连接只需要 1KB/s 的吞吐量，总共也需要 1.6 Gb/s 的吞吐量。千兆网卡显然满足不了这么大的吞吐量，所以还需要配置万兆网卡，或者基于多网卡 Bonding 承载更大的吞吐量。&lt;/p>
&lt;p>其次，从软件资源上来说，大量的连接也会占用大量的软件资源，比如文件描述符的数量、连接状态的跟踪（CONNTRACK）、网络协议栈的缓存大小（比如套接字读写缓存、TCP 读写缓存）等等。&lt;/p>
&lt;p>最后，大量请求带来的中断处理，也会带来非常高的处理成本。这样，就需要多队列网卡、中断负载均衡、CPU 绑定、RPS/RFS（软中断负载均衡到多个 CPU 核上），以及将网络包的处理卸载（Offload）到网络设备（如 TSO/GSO、LRO/GRO、VXLAN OFFLOAD）等各种硬件和软件的优化。&lt;/p>
&lt;p>C1000K 的解决方法，本质上还是构建在 epoll 的非阻塞 I/O 模型上。只不过，除了 I/O 模型之外，还需要从应用程序到 Linux 内核、再到 CPU、内存和网络等各个层次的深度优化，特别是需要借助硬件，来卸载那些原来通过软件处理的大量功能。&lt;/p>
&lt;h2 id="c10m">C10M&lt;/h2>
&lt;p>显然，人们对于性能的要求是无止境的。再进一步，有没有可能在单机中，同时处理 1000 万的请求呢？这也就是 C10M 问题。&lt;/p>
&lt;p>实际上，在 C1000K 问题中，各种软件、硬件的优化很可能都已经做到头了。特别是当升级完硬件（比如足够多的内存、带宽足够大的网卡、更多的网络功能卸载等）后，你可能会发现，无论你怎么优化应用程序和内核中的各种网络参数，想实现 1000 万请求的并发，都是极其困难的。&lt;/p>
&lt;p>究其根本，还是 Linux 内核协议栈做了太多太繁重的工作。从网卡中断带来的硬中断处理程序开始，到软中断中的各层网络协议处理，最后再到应用程序，这个路径实在是太长了，就会导致网络包的处理优化，到了一定程度后，就无法更进一步了。&lt;/p>
&lt;p>要解决这个问题，最重要就是跳过内核协议栈的冗长路径，把网络包直接送到要处理的应用程序那里去。这里有两种常见的机制，DPDK 和 XDP。&lt;/p>
&lt;h3 id="dpdk">DPDK&lt;/h3>
&lt;p>第一种机制，DPDK，是用户态网络的标准。它跳过内核协议栈，直接由用户态进程通过轮询的方式，来处理网络接收。&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/uh4s9o/1616999713236-7a546eb7-d877-45db-94d6-ea0681033b58.png" alt="">&lt;/p>
&lt;p>说起轮询，你肯定会下意识认为它是低效的象征，但是进一步反问下自己，它的低效主要体现在哪里呢？是查询时间明显多于实际工作时间的情况下吧！那么，换个角度来想，如果每时每刻都有新的网络包需要处理，轮询的优势就很明显了。比如：&lt;/p>
&lt;p>在 PPS 非常高的场景中，查询时间比实际工作时间少了很多，绝大部分时间都在处理网络包；&lt;/p>
&lt;p>而跳过内核协议栈后，就省去了繁杂的硬中断、软中断再到 Linux 网络协议栈逐层处理的过程，应用程序可以针对应用的实际场景，有针对性地优化网络包的处理逻辑，而不需要关注所有的细节。&lt;/p>
&lt;p>此外，DPDK 还通过大页、CPU 绑定、内存对齐、流水线并发等多种机制，优化网络包的处理效率。&lt;/p>
&lt;h3 id="xdp">XDP&lt;/h3>
&lt;p>第二种机制，XDP（eXpress Data Path），则是 Linux 内核提供的一种高性能网络数据路径。它允许网络包，在进入内核协议栈之前，就进行处理，也可以带来更高的性能。XDP 底层跟我们之前用到的 bcc-tools 一样，都是基于 Linux 内核的 eBPF 机制实现的。&lt;/p>
&lt;p>XDP 的原理如下图所示：&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/uh4s9o/1616999713237-6ddf3486-8389-46ca-bbd9-37aa80c74c16.png" alt="">&lt;/p>
&lt;p>你可以看到，XDP 对内核的要求比较高，需要的是 Linux 4.8 以上版本，并且它也不提供缓存队列。基于 XDP 的应用程序通常是专用的网络应用，常见的有 IDS（入侵检测系统）、DDoS 防御、 cilium 容器网络插件等。&lt;/p>
&lt;h2 id="小结">小结&lt;/h2>
&lt;p>今天我带你回顾了经典的 C10K 问题，并进一步延伸到了 C1000K 和 C10M 问题。&lt;/p>
&lt;p>C10K 问题的根源，一方面在于系统有限的资源；另一方面，也是更重要的因素，是同步阻塞的 I/O 模型以及轮询的套接字接口，限制了网络事件的处理效率。Linux 2.6 中引入的 epoll ，完美解决了 C10K 的问题，现在的高性能网络方案都基于 epoll。&lt;/p>
&lt;p>从 C10K 到 C100K ，可能只需要增加系统的物理资源就可以满足；但从 C100K 到 C1000K ，就不仅仅是增加物理资源就能解决的问题了。这时，就需要多方面的优化工作了，从硬件的中断处理和网络功能卸载、到网络协议栈的文件描述符数量、连接状态跟踪、缓存队列等内核的优化，再到应用程序的工作模型优化，都是考虑的重点。&lt;/p>
&lt;p>再进一步，要实现 C10M ，就不只是增加物理资源，或者优化内核和应用程序可以解决的问题了。这时候，就需要用 XDP 的方式，在内核协议栈之前处理网络包；或者用 DPDK 直接跳过网络协议栈，在用户空间通过轮询的方式直接处理网络包。&lt;/p>
&lt;p>当然了，实际上，在大多数场景中，我们并不需要单机并发 1000 万的请求。通过调整系统架构，把这些请求分发到多台服务器中来处理，通常是更简单和更容易扩展的方案。&lt;/p>
&lt;h2 id="思考">思考&lt;/h2>
&lt;p>最后，我想请你来聊聊，你所理解的 C10K 和 C1000K 问题。你碰到过哪些网络并发相关的性能瓶颈？你又是怎么样来分析它们的呢？你可以结合今天学到的网络知识，提出自己的观点。&lt;/p>
&lt;p>欢迎在留言区和我讨论，也欢迎你把这篇文章分享给你的同事、朋友。我们一起在实战中演练，在交流中进步。
&lt;a href="https://time.geekbang.org/column/article/81268">https://time.geekbang.org/column/article/81268&lt;/a>&lt;/p></description></item><item><title>Docs: Cockpit # 基于 Web 的 Linux 服务器管理工具</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/x.linux-%E7%AE%A1%E7%90%86/linux-%E7%B3%BB%E7%BB%9F%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/cockpit-#-%E5%9F%BA%E4%BA%8E-web-%E7%9A%84-linux-%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/x.linux-%E7%AE%A1%E7%90%86/linux-%E7%B3%BB%E7%BB%9F%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/cockpit-#-%E5%9F%BA%E4%BA%8E-web-%E7%9A%84-linux-%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/</guid><description/></item><item><title>Docs: Cockpit 介绍</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/x.linux-%E7%AE%A1%E7%90%86/linux-%E7%B3%BB%E7%BB%9F%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/cockpit-#-%E5%9F%BA%E4%BA%8E-web-%E7%9A%84-linux-%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/cockpit-%E4%BB%8B%E7%BB%8D/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/x.linux-%E7%AE%A1%E7%90%86/linux-%E7%B3%BB%E7%BB%9F%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/cockpit-#-%E5%9F%BA%E4%BA%8E-web-%E7%9A%84-linux-%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/cockpit-%E4%BB%8B%E7%BB%8D/</guid><description>
&lt;p>概述&lt;/p>
&lt;p>官网：&lt;a href="https://cockpit-project.org/">https://cockpit-project.org/&lt;/a>&lt;/p>
&lt;p>cockpit 是一个基于 web 的 Linxu 服务器管理工具。可以通过 web 端管理服务器上的虚拟机、容器、服务、网络、存储等等。还可以提供一个 web 版的控制台。&lt;/p>
&lt;p>Cockpit 配置&lt;/p>
&lt;p>&lt;strong>/etc/cockpit/*&lt;/strong> # &lt;/p>
&lt;ol>
&lt;li>&lt;strong>./ws-certs.d/*&lt;/strong> # https 证书保存目录。cockpit 第一次启动时，会在该目录生成 https 所需的 证书与私钥&lt;/li>
&lt;/ol></description></item><item><title>Docs: CPU 管理工具</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/x.linux-%E7%AE%A1%E7%90%86/linux-%E7%B3%BB%E7%BB%9F%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/cpu-%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/x.linux-%E7%AE%A1%E7%90%86/linux-%E7%B3%BB%E7%BB%9F%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/cpu-%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;h2 id="参考">参考：&lt;/h2>
&lt;/blockquote></description></item><item><title>Docs: CPU 性能优化</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/x.linux-%E7%AE%A1%E7%90%86/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96-%E4%B8%8E-%E6%95%85%E9%9A%9C%E5%A4%84%E7%90%86/cpu-%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/x.linux-%E7%AE%A1%E7%90%86/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96-%E4%B8%8E-%E6%95%85%E9%9A%9C%E5%A4%84%E7%90%86/cpu-%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/</guid><description>
&lt;h2 id="系统性能调优之绑定-cpu">系统性能调优之绑定 cpu&lt;/h2>
&lt;p>&lt;a href="https://mp.weixin.qq.com/s/jiQz01hg8DiA1zucqjMZkQ">https://mp.weixin.qq.com/s/jiQz01hg8DiA1zucqjMZkQ&lt;/a>&lt;/p></description></item><item><title>Docs: CPU 硬件管理工具</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/x.linux-%E7%AE%A1%E7%90%86/linux-%E7%A1%AC%E4%BB%B6%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/cpu-%E7%A1%AC%E4%BB%B6%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/x.linux-%E7%AE%A1%E7%90%86/linux-%E7%A1%AC%E4%BB%B6%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/cpu-%E7%A1%AC%E4%BB%B6%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;h2 id="参考">参考：&lt;/h2>
&lt;/blockquote>
&lt;h1 id="linux-环境查看-cpu-信息">Linux 环境查看 CPU 信息&lt;/h1>
&lt;p>/proc/stat # 参见：&lt;a href="https://www.yuque.com/desistdaydream/learning/rsm2ly#e87jG">VFS 虚拟文件系统&lt;/a>&lt;/p>
&lt;p>通过 cat /proc/cpuinfo 命令，可以查看 CPU 相关的信息：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>~&lt;span style="color:#f92672">]&lt;/span>&lt;span style="color:#75715e"># cat /proc/cpuinfo&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>processor : &lt;span style="color:#ae81ff">0&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>vendor_id : GenuineIntel
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>cpu family : &lt;span style="color:#ae81ff">6&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>model : &lt;span style="color:#ae81ff">44&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>model name : Intel&lt;span style="color:#f92672">(&lt;/span>R&lt;span style="color:#f92672">)&lt;/span> Xeon&lt;span style="color:#f92672">(&lt;/span>R&lt;span style="color:#f92672">)&lt;/span> CPU E5620 @ 2.40GHz
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>stepping : &lt;span style="color:#ae81ff">2&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>cpu MHz : 1596.000
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>cache size : &lt;span style="color:#ae81ff">12288&lt;/span> KB
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>physical id : &lt;span style="color:#ae81ff">0&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>siblings : &lt;span style="color:#ae81ff">8&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>core id : &lt;span style="color:#ae81ff">0&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>cpu cores : &lt;span style="color:#ae81ff">4&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>apicid : &lt;span style="color:#ae81ff">0&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>initial apicid : &lt;span style="color:#ae81ff">0&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>fpu : yes
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>fpu_exception : yes
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>cpuid level : &lt;span style="color:#ae81ff">11&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>wp : yes
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>flags : fpu vme de pse tsc msr pae mce cx8 apic sep mtrr pge mca cmov pat pse36 clflush dts acpi mmx fxsr sse sse2 ss ht tm pbe syscall nx pdpe1gb rdtscp lm constant_tsc arch_perfmon pebs bts rep_good xtopology nonstop_tsc aperfmperf pni pclmulqdq dtes64 monitor ds_cpl vmx smx est tm2 ssse3 cx16 xtpr pdcm pcid dca sse4_1 sse4_2 popcnt aes lahf_lm arat epb dts tpr_shadow vnmi flexpriority ept vpid
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>bogomips : 4800.15
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>clflush size : &lt;span style="color:#ae81ff">64&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>cache_alignment : &lt;span style="color:#ae81ff">64&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>address sizes : &lt;span style="color:#ae81ff">40&lt;/span> bits physical, &lt;span style="color:#ae81ff">48&lt;/span> bits virtual
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>power management:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>......
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="cpu-核心数相关信息">CPU 核心数相关信息&lt;/h2>
&lt;p>在查看到的相关信息中，通常有些信息比较让人迷惑，这里列出一些解释：&lt;/p>
&lt;ul>
&lt;li>&lt;strong>physical id&lt;/strong> # 指的是物理封装的处理器的 id。&lt;/li>
&lt;li>&lt;strong>cpu cores&lt;/strong> # 位于相同物理封装的处理器中的内核数量。&lt;/li>
&lt;li>**core id **# 每个内核的 id (不一定是按顺序排列的数字) 。&lt;/li>
&lt;li>&lt;strong>siblings&lt;/strong> # 位于相同物理封装的处理器中的逻辑处理器的数量。&lt;/li>
&lt;li>&lt;strong>processor&lt;/strong> # 逻辑处理器的 id。&lt;/li>
&lt;/ul>
&lt;p>我们通常可以用下面这些命令获得这些参数的信息：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>~&lt;span style="color:#f92672">]&lt;/span>&lt;span style="color:#75715e"># cat /proc/cpuinfo | grep &amp;#34;physical id&amp;#34; | sort|uniq&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>physical id : &lt;span style="color:#ae81ff">0&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>physical id : &lt;span style="color:#ae81ff">1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>~&lt;span style="color:#f92672">]&lt;/span>&lt;span style="color:#75715e"># cat /proc/cpuinfo | grep &amp;#34;cpu cores&amp;#34; | sort|uniq&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>cpu cores : &lt;span style="color:#ae81ff">4&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>~&lt;span style="color:#f92672">]&lt;/span>&lt;span style="color:#75715e"># cat /proc/cpuinfo | grep &amp;#34;core id&amp;#34; | sort|uniq&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>core id : &lt;span style="color:#ae81ff">0&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>core id : &lt;span style="color:#ae81ff">1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>core id : &lt;span style="color:#ae81ff">10&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>core id : &lt;span style="color:#ae81ff">9&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>~&lt;span style="color:#f92672">]&lt;/span>&lt;span style="color:#75715e"># cat /proc/cpuinfo | grep &amp;#34;siblings&amp;#34; | sort|uniq&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>siblings : &lt;span style="color:#ae81ff">8&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>~&lt;span style="color:#f92672">]&lt;/span>&lt;span style="color:#75715e"># cat /proc/cpuinfo | grep &amp;#34;processor&amp;#34; | sort -n -k 2 -t: | uniq&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>processor : &lt;span style="color:#ae81ff">0&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>processor : &lt;span style="color:#ae81ff">1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>processor : &lt;span style="color:#ae81ff">2&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>processor : &lt;span style="color:#ae81ff">3&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>processor : &lt;span style="color:#ae81ff">4&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>processor : &lt;span style="color:#ae81ff">5&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>processor : &lt;span style="color:#ae81ff">6&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>processor : &lt;span style="color:#ae81ff">7&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>processor : &lt;span style="color:#ae81ff">8&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>processor : &lt;span style="color:#ae81ff">9&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>processor : &lt;span style="color:#ae81ff">10&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>processor : &lt;span style="color:#ae81ff">11&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>processor : &lt;span style="color:#ae81ff">12&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>processor : &lt;span style="color:#ae81ff">13&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>processor : &lt;span style="color:#ae81ff">14&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>processor : &lt;span style="color:#ae81ff">15&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>通过上面的结果，可以看出这台机器：&lt;/p>
&lt;ol>
&lt;li>physical id # 有 2 个物理处理器(i.e.装在主板上的 CPU)（有 2 个）&lt;/li>
&lt;li>cpu cores # 每个物理处理器有 4 个内核（为 4）&lt;/li>
&lt;li>siblings # 每个物理处理器有 8 个逻辑处理器（为 8）
&lt;ol>
&lt;li>可见台机器的处理器开启了&lt;strong>超线程技术&lt;/strong>，每个内核（core）被划分为了 2 个逻辑处理器（processor）&lt;/li>
&lt;/ol>
&lt;/li>
&lt;li>processor # 总共有 16 个逻辑处理器（有 16 个）&lt;/li>
&lt;/ol>
&lt;p>&lt;strong>超线程技术&lt;/strong>：超线程技术就是利用特殊的硬件指令，把两个逻辑处理器模拟成两个物理芯片，让单个处理器都能使用线程级并行计算，进而兼容多线程操作系统和软件，减少了 CPU 的闲置时间，提高的 CPU 的运行效率。&lt;/p></description></item><item><title>Docs: cURL</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/x.linux-%E7%AE%A1%E7%90%86/linux-%E7%BD%91%E7%BB%9C%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/curl/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/x.linux-%E7%AE%A1%E7%90%86/linux-%E7%BD%91%E7%BB%9C%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/curl/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://curl.se/">官网&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://man.cx/curl">manual(手册)&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>cURL 是一个用于 URLs 传输的命令行工具和库，始于 1998 年。&lt;/p>
&lt;p>早在 20 世纪 90 年代中期，当时互联网还处于萌芽阶段，瑞典程序员 Daniel Stenberg 开始了一个项目，这个项目最终发展成了我们今天所知道的 curl 程序。&lt;/p>
&lt;p>最初，他的目标是开发一种机器人，可以定期从网页上下载货币汇率，并向 IRC 用户提供等值的瑞典克朗美元。这个项目蓬勃发展，在这个过程中添加了几个协议和特性——剩下的就是历史了。&lt;/p>
&lt;p>curl 是常用的命令行工具，用来请求 Web 服务器。它的名字就是“客户端(client)的 URL ”工具的意思。&lt;/p>
&lt;blockquote>
&lt;p>注意：curl 最常见是通过网络 URL 来传输数据。但是，curl 还可以通过 Socket 的 URL 来传输数据，只需要使用 &amp;ndash;unix-socket 选项指定 Socket 路径即可。&lt;/p>
&lt;/blockquote>
&lt;h1 id="syntax语法">Syntax(语法)&lt;/h1>
&lt;p>&lt;strong>curl [OPTIONS] URL&amp;hellip;.&lt;/strong>
如果没有另外说明，curl 将接收到的数据写入标准输出。可以使用 -o、&amp;ndash;output 或 -O、&amp;ndash;remote-name 选项将该数据保存到本地文件中。如果 curl 被赋予多个 URL 以在命令行上传输，它同样需要多个选项来保存它们。curl 不会解析或以其他方式“理解”它作为输出获取或写入的内容。它不进行编码或解码，除非使用专用命令行选项明确要求。&lt;/p>
&lt;h2 id="options">OPTIONS&lt;/h2>
&lt;p>由于 curl 程序支持多种协议，可以使用各种不同的协议向指定的 URL 发起请求，所以，并不是所有选项都适用于所有协议。在下面的笔记中，每个选项后面会添加一个 &lt;code>()&lt;/code>，括号中说明此选项支持的协议，多个协议以空格分割；没有 &lt;code>()&lt;/code> 的表示该选项适用于所有协议。若括号内为 TLS 则表示使用安全的各种协议，比如 https、ftps、imaps 等等&lt;/p>
&lt;ul>
&lt;li>&lt;strong>&amp;ndash;compressed&lt;/strong> # (HTTP)使用 curl 支持的算法之一请求压缩响应，并自动解压缩响应体。
&lt;ul>
&lt;li>在有 Sever 端会将响应体压缩，若不使用该选项，则响应体是无法输出到标准输出的，且会出现如下报错：&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>Warning: Binary output can mess up your terminal. Use &lt;span style="color:#e6db74">&amp;#34;--output -&amp;#34;&lt;/span> to tell
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Warning: curl to output it to your terminal anyway, or consider &lt;span style="color:#e6db74">&amp;#34;--output
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">Warning: &amp;lt;FILE&amp;gt;&amp;#34;&lt;/span> to save to a file.
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ul>
&lt;li>&lt;strong>-d,&amp;ndash;data &lt;!-- raw HTML omitted -->&lt;/strong> # (HTTP MQTT)使用 POST 请求将指定数据作为请求体。
&lt;ul>
&lt;li>与 &lt;code>Content-Type: application/x-www-form-urlencoded&lt;/code> 头信息配合，发送的 DATA 是 x-www-form-urlencoded 类型的请求体数据。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>&amp;ndash;data-urlencode &lt;!-- raw HTML omitted -->&lt;/strong> # (HTTP)与 -d 选项类似，发起 POST 请求，但是它执行 URL 编码。(urlencode 就是 URL Encode)&lt;/li>
&lt;li>&lt;strong>-f,&amp;ndash;fail&lt;/strong> # (HTTP)连接失败时不显示 HTTP 错误信息&lt;/li>
&lt;li>&lt;strong>-g, &amp;ndash;globoff&lt;/strong> # 关闭 &lt;code>URL Globbing Parser(URL全局解析器)&lt;/code>。设置此选项，则 URL 中可以包含 &lt;code>{}&lt;/code> 和 &lt;code>[]&lt;/code> 符号，这些符号将被当做字符。
&lt;ul>
&lt;li>该选项常用来配合 IPv6 使用&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>**-H,&amp;ndash;header &lt;!-- raw HTML omitted --> **# (HTTP)使用指定的 STRING 作为请求 header 发送给服务器
&lt;ul>
&lt;li>STRING 可以使用 @FILE 格式来通过文件传递请求头信息。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>**-I,&amp;ndash;head **# (HTTP FTP FILE)只显示本次请求的 Header 信息。当用于 FTP 或 FILE 时，则只显示文件大小和最后修改时间。&lt;/li>
&lt;li>&lt;strong>-k,&amp;ndash;insecure&lt;/strong> # (TLS)此选项表示此次 curl 请求允许&amp;quot;不安全&amp;quot;的 SSL 连接和传输。也就是说对于 https 请求，可以允许私有证书。如果使用 curl 进行 https 请求的时候，不使用该参数的话，服务端使用的私有证书或自建 CA 的证书，则有可能产生如下报错
&lt;ul>
&lt;li>curl: (60) Peer&amp;rsquo;s certificate issuer has been marked as not trusted by the user.&lt;/li>
&lt;li>curl: (60) Peer&amp;rsquo;s Certificate issuer is not recognized.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>-L, &amp;ndash;location&lt;/strong> # (HTTP)如果服务器报告所请求的页面已移动到其他位置（用 Location：标题和 3XX 响应代码表示），则此选项将使 curl 重做新位置的请求。
&lt;ul>
&lt;li>Note:如果下载文件出错之后，发现文件大小异常，则说明该文件被移动到其他链接下了，需要使用-L 与-O 配合使用才能正确下载&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>** &amp;ndash;limit-rate &lt;!-- raw HTML omitted -->** # 限制现在时的速率，NMU 为每秒下载速度，单位可以使 K、M、G&lt;/li>
&lt;li>**-m, &amp;ndash;max-time &lt;!-- raw HTML omitted --> **# 指定 curl 不管访问成功还是失败，最大消耗时间为 TIME。TIME 时间后服务端未响应，则视为无法连接。&lt;/li>
&lt;li>**-O, &amp;ndash;remote-name **# 将输入写入的一个文件中，默认的文件名与请求的资源的名称一样。i.e.下载文件
&lt;ul>
&lt;li>curl -O &lt;a href="https://www.example.com/foo/bar.html">https://www.example.com/foo/bar.html&lt;/a> #将服务器回应保存成文件，文件名为 bar.html。&lt;/li>
&lt;li>可以在一条命令中多次使用 -O 来下载多个文件&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>-o, &amp;ndash;output &lt;!-- raw HTML omitted -->&lt;/strong> #与 -O 一样，下载文件，只不过可以自己制定下载到本地后的文件名。可以重定向到 /dev/null，以便隐藏输出。&lt;/li>
&lt;li>&lt;strong>&amp;ndash;resolve DN:PORT:IP,IP&amp;hellip;&lt;/strong> # 指定将 DN(域名)解析成哪个 IP。DN 可以使用通配符&lt;/li>
&lt;li>&lt;strong>-s, &amp;ndash;silent&lt;/strong> # 静默模式。将不输出错误和进度信息,但是会正常显示运行结果。&lt;/li>
&lt;li>**&amp;ndash;trace **# 与-v 类似也可以用于调试，还会输出原始的二进制数据。&lt;/li>
&lt;li>&lt;strong>-u, &amp;ndash;user &lt;a href="USER:%5BPASSWORD%5D">USER:[PASSWORD]&lt;/a>&lt;/strong> # 指定发起请求时，所使用的基本认证信息。若省略 PASSWORD，则会以交互方式，在执行命令之后输入。&lt;/li>
&lt;li>&lt;strong>&amp;ndash;unix-socket &lt;!-- raw HTML omitted -->&lt;/strong> # (HTTP)通过 Unix 套接字连接，而不使用网络。&lt;/li>
&lt;li>&lt;strong>-v, &amp;ndash;verbose&lt;/strong> # 输出通信的整个过程，用于调试。&lt;/li>
&lt;li>&lt;strong>-w, &amp;ndash;write-out &lt;!-- raw HTML omitted -->&lt;/strong> # 指定在 curl 完成后，输出的信息，详细介绍可以参考&lt;a href="https://desistdaydream.github.io/docs/IT%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/X.Linux%20%E7%AE%A1%E7%90%86/Linux%20%E7%BD%91%E7%BB%9C%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/cURL.md">样例&lt;/a>&lt;/li>
&lt;li>**-X, &amp;ndash;request &lt;!-- raw HTML omitted --> **# (HTTP)指定 HTTP 请求的方法。&lt;/li>
&lt;/ul>
&lt;h3 id="-w---write-out-选项详解">-w, &amp;ndash;write-out 选项详解&lt;/h3>
&lt;p>-w, &amp;ndash;write-out 选项可以根据指定格式输出本次请求的一些统计信息。简单的效果如下所示：&lt;/p>
&lt;pre>&lt;code>~# curl -o /dev/null -s -w &amp;quot;DNS解析时间：&amp;quot;%{time_namelookup}&amp;quot;\n&amp;quot;\
&amp;quot;TCP建立时间:&amp;quot;%{time_connect}&amp;quot;\n&amp;quot;\
&amp;quot;响应第一个字节时间:&amp;quot;%{time_starttransfer}&amp;quot;\n&amp;quot;\
&amp;quot;总时间:&amp;quot;%{time_total}&amp;quot;\n&amp;quot;\
&amp;quot;下载速度:&amp;quot;%{speed_download}&amp;quot;\n&amp;quot; \
&amp;quot;http://www.taobao.com&amp;quot;
# 下面是命令结果
DNS解析时间：0.534294
TCP建立时间:0.551090
响应第一个字节时间:0.569936
总时间:0.570050
下载速度:487.000
&lt;/code>&lt;/pre>
&lt;p>FORMAT 中可用字段：&lt;/p>
&lt;ul>
&lt;li>time_namelookup # DNS 解析域名[www.taobao.com]的时间&lt;/li>
&lt;li>time_commect # client 和 server 端建立 TCP 连接的时间&lt;/li>
&lt;li>time_starttransfer # 从 client 发出请求；到 web 的 server 响应第一个字节的时间&lt;/li>
&lt;li>time_total # client 发出请求；到 web 的 server 发送会所有的相应数据的时间&lt;/li>
&lt;li>speed_download # 下载速度 单位 byte/s&lt;/li>
&lt;li>http_code # 本次请求的 http 响应状态码。&lt;/li>
&lt;li>content_type # 显示在 Header 里面使用 Content-Type 来表示的具体请求中的媒体类型信息；&lt;/li>
&lt;li>time_namelookup # 从请求开始，到 DNS 解析完成所使用的时间，经常用来排除 DNS 解析的问题；&lt;/li>
&lt;li>time_redirect # 重定向的时间；&lt;/li>
&lt;li>time_pretransfer # 从开始到准备传输的时间；&lt;/li>
&lt;li>time_connect # 连接时间，从开始到 TCP 三次握手完成时间，这里面包括 DNS 解析的时候，如果想求连接时间，需要减去上面的解析时间；&lt;/li>
&lt;li>time_starttransfer # 开始传输时间，从发起请求开始，到服务器返回第一个字段的时间；&lt;/li>
&lt;li>time_total # 总时间；&lt;/li>
&lt;li>speed_download # 经常使用它来测试网速度，下载速度，单位是字节每秒；&lt;/li>
&lt;li>size_request # 请求头的大小；&lt;/li>
&lt;li>size_header # 下载的 header 的大小；&lt;/li>
&lt;li>等等&lt;/li>
&lt;/ul>
&lt;h1 id="example">EXAMPLE&lt;/h1>
&lt;ul>
&lt;li>基本示例。不带有任何参数时，curl 就是发出 GET 请求。命令向 &lt;a href="https://www.baidu.com">www.baidu.com&lt;/a> 发出 GET 请求，服务器返回的内容会在命令行输出。
&lt;ul>
&lt;li>curl &lt;a href="https://www.baidu.com">https://www.baidu.com&lt;/a>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>使用 curl 访问 IPv6
&lt;ul>
&lt;li>curl -g -6 &amp;lsquo;http://[2408:8210:3c3c:35e0:7df1:783c:ce23:e958]:8080&amp;rsquo;&lt;/li>
&lt;li>curl &amp;ndash;ipv6 &amp;lsquo;http://2408:8210:3c3c:35e0:7df1:783c:ce23:e958:8080&amp;rsquo;&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>下载指定的件
&lt;ul>
&lt;li>curl -LO &lt;a href="https://github.com/goharbor/harbor/releases/download/v1.9.3/harbor-online-installer-v1.9.3.tgz">https://github.com/goharbor/harbor/releases/download/v1.9.3/harbor-online-installer-v1.9.3.tgz&lt;/a>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>请求一个域名时，指定要解析的 IP
&lt;ul>
&lt;li>curl &lt;a href="http://myapp.example.com/myapp">http://myapp.example.com/myapp&lt;/a> &amp;ndash;resolv &amp;lsquo;myapp.example.com:80:172.19.42.217&amp;rsquo;&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>修改请求头的 Head 信息来发送请求
&lt;ul>
&lt;li>curl -v -H&amp;quot;Host: gw-test.wisetv.com.cn&amp;quot; http://10.10.100.116/app-node/monitor&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>通过文件下载多个 URL
&lt;ul>
&lt;li>xargs -n 1 curl -O &amp;lt; wenjianlisturls.txt #从 wenjianlisturls.txt 中的 url 列表下载文件&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>不去验证目标证书直接获取 /healthz
&lt;ul>
&lt;li>curl &amp;ndash;insecure https://localhost:6443/healthz&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>通过 docker 的 socket 文件获取容器信息
&lt;ul>
&lt;li>&lt;strong>curl &amp;ndash;unix-socket /var/run/docker.sock http://localhost/containers/json&lt;/strong>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>使用或不使用身份验证将文件上载到 FTP 服务器。要使用 curl 将名为 wodewenjian.tar.gz 的本地文件上载到 ftp://ftpserver，请执行以下操作：
&lt;ul>
&lt;li>&lt;strong>curl -u username:password -T wodewenjian.tar.gz ftp://ftpserver&lt;/strong>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>存储 Cookie。使用以下命令将它们保存到 linuxidccookies.txt。然后，您可以使用 cat 命令查看该文件。
&lt;ul>
&lt;li>&lt;strong>curl &amp;ndash;cookie-jar linuxidcookies.txt &lt;a href="https://www.linuxidc.com/index.htm">https://www.linuxidc.com/index.htm&lt;/a> -O&lt;/strong>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>使用 Cookie 发起请求。
&lt;ul>
&lt;li>&lt;strong>curl &amp;ndash;cookie cnncookies.txt &lt;a href="https://www.linuxidc.com">https://www.linuxidc.com&lt;/a>&lt;/strong>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>使用 -d 参数以后，HTTP 请求会自动加上标头 Content-Type : application/x-www-form-urlencoded。并且会自动将请求转为 POST 方法，因此可以省略 -X POST。
&lt;ul>
&lt;li>curl -d&amp;rsquo;login=emma＆password=123&amp;rsquo;-X POST &lt;a href="https://google.com/login">https://google.com/login&lt;/a>&lt;/li>
&lt;li>curl -d &amp;rsquo;login=emma&amp;rsquo; -d &amp;lsquo;password=123&amp;rsquo; -X POST &lt;a href="https://google.com/login">https://google.com/login&lt;/a>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h2 id="-d---data-选项示例">-d, &amp;ndash;data 选项示例&lt;/h2>
&lt;ul>
&lt;li>读取 data.txt 文件的内容，作为请求体向服务器发送。
&lt;ul>
&lt;li>curl -d &amp;lsquo;@data.txt&amp;rsquo; &lt;a href="https://google.com/login">https://google.com/login&lt;/a>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>--data-urlencode 参数等同于 -d，发送 POST 请求的数据体，区别在于会自动将发送的数据进行 URL 编码。下面代码中，发送的数据 hello world 之间有一个空格，需要进行 URL 编码。
&lt;ul>
&lt;li>curl &amp;ndash;data-urlencode &amp;lsquo;comment=hello world&amp;rsquo; &lt;a href="https://google.com/login">https://google.com/login&lt;/a>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h2 id="-w---write-out-选项示例">-w, &amp;ndash;write-out 选项示例&lt;/h2>
&lt;ul>
&lt;li>获取请求 &lt;a href="https://www.baidu.com">www.baidu.com&lt;/a> 总共花费的时间
&lt;ul>
&lt;li>curl -o /dev/null -s -w &amp;lsquo;%{time_total}\n&amp;rsquo; &lt;a href="https://www.baidu.com">https://www.baidu.com&lt;/a>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>只显示响应的状态码。
&lt;ul>
&lt;li>curl -s -o /dev/null -w %{http_code}&amp;quot;\n&amp;quot; &lt;a href="http://www.baidu.com">http://www.baidu.com&lt;/a>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h1 id="复杂应用实例">复杂应用实例&lt;/h1>
&lt;h2 id="从-chrome-浏览器的请求中获取-curl-参数">从 Chrome 浏览器的请求中，获取 curl 参数&lt;/h2>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/fwy2as/1616165084827-164a7bfc-f35f-43a4-8580-9a8eb3856784.png" alt="">&lt;/p>
&lt;h1 id="可能是东半球最好的-curl-学习指南">可能是东半球最好的 Curl 学习指南&lt;/h1>
&lt;p>-A&lt;/p>
&lt;p>-A 参数指定客户端的用户代理标头，即 User-Agent。curl 的默认用户代理字符串是 curl/[version]。&lt;/p>
&lt;p>$ curl -A &amp;lsquo;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/76.0.3809.100 Safari/537.36&amp;rsquo; &lt;a href="https://google.com">https://google.com&lt;/a>&lt;/p>
&lt;p>上面命令将 User-Agent 改成 Chrome 浏览器。&lt;/p>
&lt;p>$ curl -A &amp;rsquo;&amp;rsquo; &lt;a href="https://google.com">https://google.com&lt;/a>&lt;/p>
&lt;p>上面命令会移除 User-Agent 标头。你也可以通过 -H 参数直接指定标头，更改 User-Agent。&lt;/p>
&lt;p>$ curl -H &amp;lsquo;User-Agent: php/1.0&amp;rsquo; &lt;a href="https://google.com">https://google.com&lt;/a>&lt;/p>
&lt;p>-b&lt;/p>
&lt;p>-b 参数用来向服务器发送 Cookie。&lt;/p>
&lt;p>$ curl -b &amp;lsquo;foo=bar&amp;rsquo; &lt;a href="https://google.com">https://google.com&lt;/a>&lt;/p>
&lt;p>上面命令会生成一个标头 Cookie: foo=bar，向服务器发送一个名为 foo、值为 bar 的 Cookie。&lt;/p>
&lt;p>$ curl -b &amp;lsquo;foo1=bar&amp;rsquo; -b &amp;lsquo;foo2=baz&amp;rsquo; &lt;a href="https://google.com">https://google.com&lt;/a>&lt;/p>
&lt;p>上面命令发送两个 Cookie。&lt;/p>
&lt;p>$ curl -b cookies.txt &lt;a href="https://www.google.com">https://www.google.com&lt;/a>&lt;/p>
&lt;p>上面命令读取本地文件 cookies.txt，里面是服务器设置的 Cookie（参见 -c 参数），将其发送到服务器。&lt;/p>
&lt;p>-c&lt;/p>
&lt;p>-c 参数将服务器设置的 Cookie 写入一个文件。&lt;/p>
&lt;p>$ curl -c cookies.txt &lt;a href="https://www.google.com">https://www.google.com&lt;/a>&lt;/p>
&lt;p>上面命令将服务器的 HTTP 回应所设置 Cookie 写入文本文件 cookies.txt。&lt;/p>
&lt;p>-e&lt;/p>
&lt;p>-e 参数用来设置 HTTP 的标头 Referer，表示请求的来源。&lt;/p>
&lt;p>$ curl -e &amp;lsquo;&lt;a href="https://google.com?q=example'">https://google.com?q=example'&lt;/a> &lt;a href="https://www.example.com">https://www.example.com&lt;/a>&lt;/p>
&lt;p>上面命令将 Referer 标头设为 &lt;a href="https://google.com?q=example">https://google.com?q=example&lt;/a>。&lt;/p>
&lt;p>-H 参数可以通过直接添加标头 Referer，达到同样效果。&lt;/p>
&lt;p>$ curl -H &amp;lsquo;Referer: &lt;a href="https://google.com?q=example'">https://google.com?q=example'&lt;/a> &lt;a href="https://www.example.com">https://www.example.com&lt;/a>&lt;/p>
&lt;p>-F&lt;/p>
&lt;p>-F 参数用来向服务器上传二进制文件。&lt;/p>
&lt;p>$ curl -F &amp;lsquo;&lt;a href="mailto:file=@photo.png">file=@photo.png&lt;/a>&amp;rsquo; &lt;a href="https://google.com/profile">https://google.com/profile&lt;/a>&lt;/p>
&lt;p>上面命令会给 HTTP 请求加上标头 Content-Type: multipart/form-data，然后将文件 photo.png 作为 file 字段上传。&lt;/p>
&lt;p>-F 参数可以指定 MIME 类型。&lt;/p>
&lt;p>$ curl -F &amp;lsquo;&lt;a href="mailto:file=@photo.png">file=@photo.png&lt;/a>;type=image/png&amp;rsquo; &lt;a href="https://google.com/profile">https://google.com/profile&lt;/a>&lt;/p>
&lt;p>上面命令指定 MIME 类型为 image/png，否则 curl 会把 MIME 类型设为 application/octet-stream。&lt;/p>
&lt;p>-F 参数也可以指定文件名。&lt;/p>
&lt;p>$ curl -F &amp;lsquo;&lt;a href="mailto:file=@photo.png">file=@photo.png&lt;/a>;filename=me.png&amp;rsquo; &lt;a href="https://google.com/profile">https://google.com/profile&lt;/a>&lt;/p>
&lt;p>上面命令中，原始文件名为 photo.png，但是服务器接收到的文件名为 me.png。&lt;/p>
&lt;p>-G&lt;/p>
&lt;p>-G 参数用来构造 URL 的查询字符串。&lt;/p>
&lt;p>$ curl -G -d &amp;lsquo;q=kitties&amp;rsquo; -d &amp;lsquo;count=20&amp;rsquo; &lt;a href="https://google.com/search">https://google.com/search&lt;/a>&lt;/p>
&lt;p>上面命令会发出一个 GET 请求，实际请求的 URL 为 &lt;a href="https://google.com/search?q=kitties&amp;amp;count=20">https://google.com/search?q=kitties&amp;amp;count=20&lt;/a>。如果省略 &amp;ndash;G，会发出一个 POST 请求。&lt;/p>
&lt;p>如果数据需要 URL 编码，可以结合 &amp;ndash;data&amp;ndash;urlencode 参数。&lt;/p>
&lt;p>$ curl -G &amp;ndash;data-urlencode &amp;lsquo;comment=hello world&amp;rsquo; &lt;a href="https://www.example.com">https://www.example.com&lt;/a>&lt;/p>
&lt;p>-H&lt;/p>
&lt;p>-H 参数添加 HTTP 请求的标头。&lt;/p>
&lt;p>$ curl -H &amp;lsquo;Accept-Language: en-US&amp;rsquo; &lt;a href="https://google.com">https://google.com&lt;/a>&lt;/p>
&lt;p>上面命令添加 HTTP 标头 Accept-Language: en-US。&lt;/p>
&lt;p>$ curl -H &amp;lsquo;Accept-Language: en-US&amp;rsquo; -H &amp;lsquo;Secret-Message: xyzzy&amp;rsquo; &lt;a href="https://google.com">https://google.com&lt;/a>&lt;/p>
&lt;p>上面命令添加两个 HTTP 标头。&lt;/p>
&lt;p>$ curl -d &amp;lsquo;{&amp;ldquo;login&amp;rdquo;: &amp;ldquo;emma&amp;rdquo;, &amp;ldquo;pass&amp;rdquo;: &amp;ldquo;123&amp;rdquo;}&amp;rsquo; -H &amp;lsquo;Content-Type: application/json&amp;rsquo; &lt;a href="https://google.com/login">https://google.com/login&lt;/a>&lt;/p>
&lt;p>上面命令添加 HTTP 请求的标头是 Content-Type: application/json，然后用 -d 参数发送 JSON 数据。&lt;/p>
&lt;p>-i&lt;/p>
&lt;p>-i 参数打印出服务器回应的 HTTP 标头。&lt;/p>
&lt;p>$ curl -i &lt;a href="https://www.example.com">https://www.example.com&lt;/a>&lt;/p>
&lt;p>上面命令收到服务器回应后，先输出服务器回应的标头，然后空一行，再输出网页的源码。&lt;/p>
&lt;p>-s&lt;/p>
&lt;p>-s 参数将不输出错误和进度信息。&lt;/p>
&lt;p>$ curl -s &lt;a href="https://www.example.com">https://www.example.com&lt;/a>&lt;/p>
&lt;p>上面命令一旦发生错误，不会显示错误信息。不发生错误的话，会正常显示运行结果。&lt;/p>
&lt;p>如果想让 curl 不产生任何输出，可以使用下面的命令。&lt;/p>
&lt;p>$ curl -s -o /dev/null &lt;a href="https://google.com">https://google.com&lt;/a>&lt;/p>
&lt;p>-S&lt;/p>
&lt;p>-S 参数指定只输出错误信息，通常与 -s 一起使用。&lt;/p>
&lt;p>$ curl -s -o /dev/null &lt;a href="https://google.com">https://google.com&lt;/a>&lt;/p>
&lt;p>上面命令没有任何输出，除非发生错误。&lt;/p>
&lt;p>-u&lt;/p>
&lt;p>-u 参数用来设置服务器认证的用户名和密码。&lt;/p>
&lt;p>$ curl -u &amp;lsquo;bob:12345&amp;rsquo; &lt;a href="https://google.com/login">https://google.com/login&lt;/a>&lt;/p>
&lt;p>上面命令设置用户名为 bob，密码为 12345，然后将其转为 HTTP 标头 Authorization: Basic Ym9iOjEyMzQ1。&lt;/p>
&lt;p>curl 能够识别 URL 里面的用户名和密码。&lt;/p>
&lt;p>$ curl &lt;a href="https://bob:12345@google.com/login">https://bob:12345@google.com/login&lt;/a>&lt;/p>
&lt;p>上面命令能够识别 URL 里面的用户名和密码，将其转为上个例子里面的 HTTP 标头。&lt;/p>
&lt;p>$ curl -u &amp;lsquo;bob&amp;rsquo; &lt;a href="https://google.com/login">https://google.com/login&lt;/a>&lt;/p>
&lt;p>上面命令只设置了用户名，执行后，curl 会提示用户输入密码。&lt;/p>
&lt;p>-x&lt;/p>
&lt;p>-x 参数指定 HTTP 请求的代理。&lt;/p>
&lt;p>$ curl -x socks5://james:cats@myproxy.com:8080 &lt;a href="https://www.example.com">https://www.example.com&lt;/a>&lt;/p>
&lt;p>上面命令指定 HTTP 请求通过 myproxy.com:8080 的 socks5 代理发出。&lt;/p>
&lt;p>如果没有指定代理协议，默认为 HTTP。&lt;/p>
&lt;p>$ curl -x james:cats@myproxy.com:8080 &lt;a href="https://www.example.com">https://www.example.com&lt;/a>&lt;/p>
&lt;p>上面命令中，请求的代理使用 HTTP 协议。&lt;/p></description></item><item><title>Docs: dd 生成指定大小的文件</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/x.linux-%E7%AE%A1%E7%90%86/linux-%E7%B3%BB%E7%BB%9F%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/%E7%A3%81%E7%9B%98-%E4%B8%8E-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7%E9%9B%86/dd-%E7%94%9F%E6%88%90%E6%8C%87%E5%AE%9A%E5%A4%A7%E5%B0%8F%E7%9A%84%E6%96%87%E4%BB%B6/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/x.linux-%E7%AE%A1%E7%90%86/linux-%E7%B3%BB%E7%BB%9F%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/%E7%A3%81%E7%9B%98-%E4%B8%8E-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7%E9%9B%86/dd-%E7%94%9F%E6%88%90%E6%8C%87%E5%AE%9A%E5%A4%A7%E5%B0%8F%E7%9A%84%E6%96%87%E4%BB%B6/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;h1 id="dd-命令使用说明">dd 命令使用说明&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;a href="https://blog.csdn.net/menogen/article/details/38059671">https://blog.csdn.net/menogen/article/details/38059671&lt;/a>&lt;/p>
&lt;/blockquote>
&lt;p>&lt;strong>dd [OPTIONS[=FLAGS]]&lt;/strong>
OPTIONS&lt;/p>
&lt;ul>
&lt;li>bs=BYTES #每次读取和写入的字节数&lt;/li>
&lt;li>cbs=BYTES #convert BYTES bytes at a time&lt;/li>
&lt;li>conv=CONVS #convert the file as per the comma separated symbol list&lt;/li>
&lt;li>count=N #读取的 block 数，block 的大小由 ibs 指定（只针对输入参数）&lt;/li>
&lt;li>ibs=BYTES #read up to BYTES bytes at a time (default: 512)&lt;/li>
&lt;li>if=FILE #指定输入文件。默认从标准输入读取。
&lt;ul>
&lt;li>/dev/zero 是 Linux 的一个伪文件，它可以产生连续不断的 null 流（二进制的 0）&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>iflag=FLAGS #使用 FLAGS 来控制输入(读取数据)时的行为特征。多个 FLAG 以 , 分隔&lt;/li>
&lt;li>obs=BYTES #write BYTES bytes at a time (default: 512)&lt;/li>
&lt;li>of=FILE #指定输出文件。默认输出到标准输出。&lt;/li>
&lt;li>oflag=FLAGS #使用 iflag 来控制输出(写入数据)时的行为特征。多个 FLAG 以 , 分隔&lt;/li>
&lt;li>seek=N #skip N obs-sized blocks at start of output&lt;/li>
&lt;li>skip=N #skip N ibs-sized blocks at start of input&lt;/li>
&lt;li>status=LEVEL #The LEVEL of information to print to stderr; &amp;rsquo;none&amp;rsquo; suppresses everything but error messages, &amp;rsquo;noxfer&amp;rsquo; suppresses the final transfer statistics, &amp;lsquo;progress&amp;rsquo; shows periodic transfer statistics&lt;/li>
&lt;/ul>
&lt;p>FLAGS&lt;/p>
&lt;ul>
&lt;li>append # 追加模式(仅对输出有意义；隐含了 conv=notrunc)&lt;/li>
&lt;li>direct # 使用直接 I/O 存取模式，即跳过缓存，不操作内存，而是直接操作磁盘&lt;/li>
&lt;li>directory # 除非是目录，否则 directory 失败&lt;/li>
&lt;li>dsync # 使用同步 I/O 存取模式&lt;/li>
&lt;li>sync #与上者类似，但同时也对元数据生效&lt;/li>
&lt;li>fullblock # 为输入积累完整块(仅 iflag)&lt;/li>
&lt;li>nonblock # 使用无阻塞 I/O 存取模式&lt;/li>
&lt;li>noatime # 不更新存取时间&lt;/li>
&lt;li>nocache # 丢弃缓存数据&lt;/li>
&lt;li>noctty # 不根据文件指派控制终端&lt;/li>
&lt;li>nofollow # 不跟随链接文件&lt;/li>
&lt;/ul>
&lt;h1 id="example">EXAMPLE&lt;/h1>
&lt;ul>
&lt;li>测试当前磁盘 写入文件 的速度
&lt;ul>
&lt;li>**dd if=/dev/zero of=testdd bs=1M count=1000 **&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>测试当前磁盘 纯写入文件 的速度，即不使用缓存
&lt;ul>
&lt;li>&lt;strong>dd if=/dev/zero of=testdd bs=1M count=1024 oflag=sync,direct,nonblock&lt;/strong>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>测试当前磁盘 纯读取文件 的速度，即不使用缓存
&lt;ul>
&lt;li>&lt;strong>dd if=testdd of=/dev/null bs=1M count=1024 iflag=sync,direct,nonblock&lt;/strong>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>测试 sdb 磁盘 的 写入速度。注意：要使用一块空盘，否则数据没了
&lt;ul>
&lt;li>&lt;strong>dd if=/dev/urandom of=/dev/sdb1 bs=1M count=1024&lt;/strong>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>测试 sdb 磁盘 的读取速度
&lt;ul>
&lt;li>&lt;strong>dd if=/dev/sdb1 of=/dev/null bs=1M count=1024&lt;/strong>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul></description></item><item><title>Docs: dmidecode</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/x.linux-%E7%AE%A1%E7%90%86/linux-%E7%A1%AC%E4%BB%B6%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/dmidecode/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/x.linux-%E7%AE%A1%E7%90%86/linux-%E7%A1%AC%E4%BB%B6%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/dmidecode/</guid><description>
&lt;p>dmidecode 命令可以让你在 Linux 系统下获取有关硬件方面的信息。dmidecode 的作用是将 DMI 数据库中的信息解码，以可读的文本方式显示。由于 DMI 信息可以人为修改，因此里面的信息不一定是系统准确的信息。dmidecode 遵循 SMBIOS/DMI 标准，其输出的信息包括BIOS、系统、主板、处理器、内存、缓存等等。&lt;/p>
&lt;p>DMI（Desktop Management Interface,DMI）就是帮助收集电脑系统信息的管理系统，DMI 信息的收集必须在严格遵照SMBIOS规范的前提下进行。SMBIOS（System Management BIOS）是主板或系统制造者以标准格式显示产品管理信息所需遵循的统一规范。SMBIOS和DMI是由行业指导机构Desktop Management Task Force(DMTF)起草的开放性的技术标准，其中DMI设计适用于任何的平台和操作系统。&lt;/p>
&lt;p>DMI充当了管理工具和系统层之间接口的角色。它建立了标准的可管理系统更加方便了电脑厂商和用户对系统的了解。DMI的主要组成部分是Management Information Format(MIF)数据库。这个数据库包括了所有有关电脑系统和配件的信息。通过DMI，用户可以获取序列号、电脑厂商、串口信息以及其它系统配件信息。&lt;/p></description></item><item><title>Docs: ecs 中毒的一次处理过程</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/x.linux-%E7%AE%A1%E7%90%86/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96-%E4%B8%8E-%E6%95%85%E9%9A%9C%E5%A4%84%E7%90%86/%E6%95%85%E9%9A%9C%E5%A4%84%E7%90%86%E6%A1%88%E4%BE%8B/ecs-%E4%B8%AD%E6%AF%92%E7%9A%84%E4%B8%80%E6%AC%A1%E5%A4%84%E7%90%86%E8%BF%87%E7%A8%8B/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/x.linux-%E7%AE%A1%E7%90%86/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96-%E4%B8%8E-%E6%95%85%E9%9A%9C%E5%A4%84%E7%90%86/%E6%95%85%E9%9A%9C%E5%A4%84%E7%90%86%E6%A1%88%E4%BE%8B/ecs-%E4%B8%AD%E6%AF%92%E7%9A%84%E4%B8%80%E6%AC%A1%E5%A4%84%E7%90%86%E8%BF%87%E7%A8%8B/</guid><description>
&lt;p>原文：&lt;a href="https://zhangguanzhang.github.io/2022/04/21/ecs-xmrig/">张馆长博客，ecs 中毒的一次处理过程&lt;/a>
一次客户 ecs 中毒的处理过程，可以给读者参考下中毒的处理过程。&lt;/p>
&lt;h2 id="由来">由来&lt;/h2>
&lt;p>客户机器中毒了，pm 找我来让处理下，记录下，给其他人做个处理过程的参考。&lt;/p>
&lt;h2 id="处理过程">处理过程&lt;/h2>
&lt;p>机器是 centos ，先利用 &lt;code>rpm -V &amp;lt;pkg_name&amp;gt;&lt;/code> 确认基础的排查命令没被修改过：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>$ rpm -qf &lt;span style="color:#e6db74">`&lt;/span>which ps&lt;span style="color:#e6db74">`&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>procps-ng-3.3.10-23.el7.x86_64
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>$ rpm -V procps-ng
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>$ rpm -qf &lt;span style="color:#e6db74">`&lt;/span>which top&lt;span style="color:#e6db74">`&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>procps-ng-3.3.10-23.el7.x86_64
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>top 看到异常 cpu 的进程占用 cpu 很高：&lt;/p>
&lt;pre>&lt;code>$ top
top - 19:44:29 up 34 days, 5:08, 4 users, load average: 612.03, 617.15, 482.75
Tasks: 2014 total, 66 running, 1946 sleeping, 0 stopped, 2 zombie
%Cpu(s): 96.6 us, 3.1 sy, 0.0 ni, 0.0 id, 0.0 wa, 0.0 hi, 0.3 si, 0.0 st
KiB Mem : 13186040+total, 2722452 free, 48820448 used, 80317504 buff/cache
KiB Swap: 0 total, 0 free, 0 used. 78946784 avail Mem
PID USER PR NI VIRT RES SHR S %CPU %MEM TIME+ COMMAND
1206 root 20 0 5251748 2.3g 3584 S 2956 1.8 465:37.77 ld-linux-x86-64
&lt;/code>&lt;/pre>
&lt;p>给它 &lt;code>STOP&lt;/code> 信号不让 cpu 切换到它，而不是直接 kill 掉它：&lt;/p>
&lt;pre>&lt;code>$ kill -STOP 1206
&lt;/code>&lt;/pre>
&lt;p>查看来源和清理：&lt;/p>
&lt;pre>&lt;code>$ ll /proc/1206/exe
lrwxrwxrwx 1 root root 0 Apr 21 19:44 /proc/1206/exe -&amp;gt; /dev/shm/.x/stak/ld-linux-x86-64.so.2
&lt;/code>&lt;/pre>
&lt;h3 id="清理定时任务">清理定时任务&lt;/h3>
&lt;p>排查定时任务，发现有内容，清理掉， crond 的子目录也看下，文件内容和多了的子文件也处理下&lt;/p>
&lt;pre>&lt;code>$ crontab -l
* * * * * /dev/shm/.x/upd &amp;gt;/dev/null 2&amp;gt;&amp;amp;1
@reboot /dev/shm/.x/upd &amp;gt;/dev/null 2&amp;gt;&amp;amp;1
[root@p-96b7-dndl etc]# find /etc/cron.* -type f
/etc/cron.d/0hourly
/etc/cron.d/sysstat
/etc/cron.daily/logrotate
/etc/cron.daily/man-db.cron
/etc/cron.deny
/etc/cron.hourly/0anacron
&lt;/code>&lt;/pre>
&lt;p>查看下进程树，是否有父进程拉起 &lt;code>1206&lt;/code>:&lt;/p>
&lt;pre>&lt;code>$ pstree -sp 1206
systemd(1)───ld-linux-x86-64(1206)─┬─{ld-linux-x86-64}(1209)
├─{ld-linux-x86-64}(1211)
├─{ld-linux-x86-64}(1216)
├─{ld-linux-x86-64}(1217)
├─{ld-linux-x86-64}(1218)
├─{ld-linux-x86-64}(6436)
├─{ld-linux-x86-64}(6437)
├─{ld-linux-x86-64}(6439)
├─{ld-linux-x86-64}(6440)
├─{ld-linux-x86-64}(6441)
├─{ld-linux-x86-64}(6443)
├─{ld-linux-x86-64}(6471)
├─{ld-linux-x86-64}(6472)
├─{ld-linux-x86-64}(6476)
├─{ld-linux-x86-64}(6484)
├─{ld-linux-x86-64}(6489)
├─{ld-linux-x86-64}(6495)
├─{ld-linux-x86-64}(6501)
├─{ld-linux-x86-64}(6504)
├─{ld-linux-x86-64}(6505)
├─{ld-linux-x86-64}(6508)
├─{ld-linux-x86-64}(6509)
├─{ld-linux-x86-64}(6511)
├─{ld-linux-x86-64}(6523)
├─{ld-linux-x86-64}(6527)
├─{ld-linux-x86-64}(6529)
├─{ld-linux-x86-64}(6531)
├─{ld-linux-x86-64}(6535)
├─{ld-linux-x86-64}(6547)
├─{ld-linux-x86-64}(6554)
├─{ld-linux-x86-64}(6563)
├─{ld-linux-x86-64}(6567)
├─{ld-linux-x86-64}(6568)
├─{ld-linux-x86-64}(6569)
├─{ld-linux-x86-64}(6572)
├─{ld-linux-x86-64}(6579)
└─{ld-linux-x86-64}(6580)
&lt;/code>&lt;/pre>
&lt;p>发现并没有，查看下进程的 &lt;code>cmdline&lt;/code>:&lt;/p>
&lt;pre>&lt;code>$ xargs -0 &amp;lt; /proc/1206/cmdline
xmrig
--library-path stak stak/xmrig -o 185.82.200.52:443 -k
&lt;/code>&lt;/pre>
&lt;h3 id="检查系统的-so-和开机启动项">检查系统的 so 和开机启动项&lt;/h3>
&lt;p>搜了下这个 ip 是外国的，查看下 ld 的 so 导入配置文件，看看是否有被加入额外的 so 导入：&lt;/p>
&lt;pre>&lt;code>$ rpm -qf /etc/ld.so.conf
glibc-2.17-260.el7.x86_64
# glibc 也提供了很多基础的 so，这部同时也可以看出来
# 基础的 so 有被替换不
$ rpm -V glibc
&lt;/code>&lt;/pre>
&lt;p>同理查看下 systemd 的&lt;/p>
&lt;pre>&lt;code>$ rpm -V systemd
.M....... c /etc/machine-id
SM5....T. c /etc/rc.d/rc.local # 这个文件也记得查下
S.5....T. c /etc/systemd/system.conf
.M....... g /etc/udev/hwdb.bin
.M....... g /var/lib/systemd/random-seed
.M....G.. g /var/log/journal
.M....G.. g /var/log/wtmp
.M....G.. g /var/run/utmp
# 查看下有没有被添加 systemd 的开机启动任务
$ systemctl list-units
&lt;/code>&lt;/pre>
&lt;h3 id="清理进程相关">清理进程相关&lt;/h3>
&lt;p>我们环境是 k8s 和 docker 的，etcd 没证书，kubelet 的 http 可写，docker 开网络端口不 tls，redis 无密码这种现象是不存在的。看了下我们配置的部署配置文件，初步怀疑是一个有 sudo 的弱密码用户被爆破导致的中毒，查看了具有 sudo 权限和 root 的 &lt;code>~/.ssh/authorized_keys&lt;/code> 也没被添加别人的公钥（有的话记得清理下），开始删除挖矿进程的目录：&lt;/p>
&lt;pre>&lt;code>rm -rf /dev/shm/.x/
kill -9 1206
&lt;/code>&lt;/pre>
&lt;h3 id="排查网络">排查网络&lt;/h3>
&lt;p>看看是否还有其他后台进程上报或者下载的，看了下 udp 的正常，所以提取所有活跃的 tcp 连接 ip 看看有异常的 IP 没：&lt;/p>
&lt;pre>&lt;code>$ netstat -ant |&amp;amp; grep -Po '(\d{1,3}\.){3}\d{1,3}' | sort | grep -v 10.187.0 | uniq -c
49 0.0.0.0
2 119.82.135.65
111 127.0.0.1
4 169.254.169.254
2271 192.168.0.235
13 2xx.1xx.15.161
1 3x.1xx.2x.7
27 4x.x.1xx.x3
1 xx.1xx.6x.x54
$ netstat -ant | grep 119.82.135.65
tcp 0 1281 192.168.0.235:22 119.82.135.65:38525 LAST_ACK
tcp 0 1 192.168.0.235:22 119.82.135.65:54598 LAST_ACK
$ lsof -nPi :38525
$ lsof -nPi :54598
$
&lt;/code>&lt;/pre>
&lt;p>看了下只有不断被外国 IP 暴力 ssh 的 IP，其余几个 IP 是我和客户那边的人员 IP。让客户改密码后再观察下。&lt;/p></description></item><item><title>Docs: ethtool</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/x.linux-%E7%AE%A1%E7%90%86/linux-%E7%BD%91%E7%BB%9C%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/ethtool/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/x.linux-%E7%AE%A1%E7%90%86/linux-%E7%BD%91%E7%BB%9C%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/ethtool/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://man7.org/linux/man-pages/man8/ethtool.8.html">Manual(手册),ethtool(8)&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>ethtool 是一个工具，用来查询或控制网络驱动程序和硬件设备&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>~&lt;span style="color:#f92672">]&lt;/span>&lt;span style="color:#75715e"># ethtool em1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Settings &lt;span style="color:#66d9ef">for&lt;/span> em1:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Supported ports: &lt;span style="color:#f92672">[&lt;/span> TP &lt;span style="color:#f92672">]&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Supported link modes: 10baseT/Half 10baseT/Full
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> 100baseT/Half 100baseT/Full
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> 1000baseT/Half 1000baseT/Full
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Supported pause frame use: No
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Supports auto-negotiation: Yes
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Supported FEC modes: Not reported
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Advertised link modes: 10baseT/Half 10baseT/Full
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> 100baseT/Half 100baseT/Full
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> 1000baseT/Half 1000baseT/Full
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Advertised pause frame use: Symmetric
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Advertised auto-negotiation: Yes
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Advertised FEC modes: Not reported
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Link partner advertised link modes: 10baseT/Full
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> 100baseT/Full
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> 1000baseT/Full
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Link partner advertised pause frame use: No
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Link partner advertised auto-negotiation: Yes
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Link partner advertised FEC modes: Not reported
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Speed: 1000Mb/s
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Duplex: Full
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Port: Twisted Pair
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> PHYAD: &lt;span style="color:#ae81ff">1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Transceiver: internal
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Auto-negotiation: on
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> MDI-X: on
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Supports Wake-on: g
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Wake-on: d
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Current message level: 0x000000ff &lt;span style="color:#f92672">(&lt;/span>255&lt;span style="color:#f92672">)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> drv probe link timer ifdown ifup rx_err tx_err
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Link detected: yes
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h1 id="syntax语法">Syntax(语法)&lt;/h1>
&lt;p>&lt;strong>ethtool [OPTIONS] DeviceName&lt;/strong>&lt;/p>
&lt;h2 id="options">OPTIONS&lt;/h2>
&lt;h3 id="查询选项">查询选项&lt;/h3>
&lt;ul>
&lt;li>**-l, &amp;ndash;show-channels **#显示指定网络设备的通道数。通道是一个 IRQ，是可以触发该 IRQ 的队列集。&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>~&lt;span style="color:#f92672">]&lt;/span>&lt;span style="color:#75715e"># ethtool -l ens4f0&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Channel parameters &lt;span style="color:#66d9ef">for&lt;/span> ens4f0:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Pre-set maximums:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>RX: &lt;span style="color:#ae81ff">0&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>TX: &lt;span style="color:#ae81ff">0&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Other: &lt;span style="color:#ae81ff">1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Combined: &lt;span style="color:#ae81ff">63&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Current hardware settings:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>RX: &lt;span style="color:#ae81ff">0&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>TX: &lt;span style="color:#ae81ff">0&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Other: &lt;span style="color:#ae81ff">1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Combined: &lt;span style="color:#ae81ff">32&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ul>
&lt;li>&lt;strong>-m, &amp;ndash;dump-module-eeprom, &amp;ndash;module-info&lt;/strong> # 从 “EEPROM 插件模块”检索并解码硬件信息。比如 SFP+、QSFP。如果驱动程序和模块支持它，光学诊断信息也会被读取和解码。如果指定了 page、bank 或 i2c 参数之一，则仅允许转储单个页面或其部分。在这种情况下，偏移和长度参数相对于 EEPROM 页面边界进行处理。
&lt;ul>
&lt;li>“插件模块”，就是指网卡口插的模块。通常情况下来说，都是光模块。
&lt;ul>
&lt;li>光模块能显示的信息详见下文“&lt;a href="#yVQY0">光模块插件信息&lt;/a>”&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>这种信息一般只存在于具有模块网卡的物理机上。虚拟机或者无法插模块的网卡，是没有这种信息的，这时候获取信息，将会出现如下报错：&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>~&lt;span style="color:#f92672">]&lt;/span>&lt;span style="color:#75715e"># ethtool -m enp25s0f0&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Cannot get module EEPROM information: Invalid argument
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ul>
&lt;li>&lt;strong>-S, &amp;ndash;statistics&lt;/strong> # 获得特定于 NIC 和 驱动程序 的统计信息。&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>~&lt;span style="color:#f92672">]&lt;/span>&lt;span style="color:#75715e"># ethtool -S ens4f0&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>NIC statistics:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> rx_packets: &lt;span style="color:#ae81ff">100463573&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> tx_packets: &lt;span style="color:#ae81ff">59794837&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> rx_bytes: &lt;span style="color:#ae81ff">74687073845&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> tx_bytes: &lt;span style="color:#ae81ff">7381975533&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> rx_pkts_nic: &lt;span style="color:#ae81ff">100463561&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> tx_pkts_nic: &lt;span style="color:#ae81ff">59794820&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> rx_bytes_nic: &lt;span style="color:#ae81ff">75088927199&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> tx_bytes_nic: &lt;span style="color:#ae81ff">7672892990&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ......略
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="其他选项">其他选项&lt;/h3>
&lt;ul>
&lt;li>&lt;strong>-p, &amp;ndash;identify&lt;/strong> # 可以让指定网络设备关联的网卡上的 led 灯闪烁。&lt;strong>常用来在机房中识别机器网卡&lt;/strong>。&lt;/li>
&lt;li>&lt;strong>-s,&amp;ndash;change &lt;!-- raw HTML omitted -->&lt;/strong> # 允许更改指定网络设备的部分或全部设置。 以下所有选项仅在指定了-s 时适用。
&lt;ul>
&lt;li>&lt;strong>speed N&lt;/strong> # 用 Mb/s 作为单位设置网卡速率。Set speed in Mb/s. ethtool with just the device name as an argument will show you the supported device speeds.&lt;/li>
&lt;li>**duplex {half|full} **# 设置全双工或半双工模式&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h1 id="example">EXAMPLE&lt;/h1>
&lt;p>显示 veth1.1 对的状态信息，可以在 container 或 namespace 中查看绑定的另一半 veth 在 Host 上的网卡号&lt;/p>
&lt;ul>
&lt;li>ethtool -S veth1.1&lt;/li>
&lt;/ul>
&lt;p>设置 eth0 网卡速率为 100Mb/s，全双工&lt;/p>
&lt;ul>
&lt;li>ethtool -s eth0 speed 100 duplex full&lt;/li>
&lt;/ul>
&lt;h2 id="-m-选项信息">-m 选项信息&lt;/h2>
&lt;h3 id="光模块插件信息">光模块插件信息&lt;/h3>
&lt;ul>
&lt;li>&lt;strong>Identifier&lt;/strong> # 标识符。即该口上所插的模块信息。示例值：&lt;code>**0x03 (SFP)**&lt;/code>&lt;/li>
&lt;li>**Extended identifier **# 扩展标识符。模块的扩展信息。示例值：&lt;code>**0x04 (GBIC/SFP defined by 2-wire interface ID)**&lt;/code>&lt;/li>
&lt;li>**Connector **# 连接器信息。即. 示例值：&lt;code>**0x07 (LC)**&lt;/code>&lt;/li>
&lt;li>&lt;strong>Transceiver codes : 0x10 0x00 0x00 0x00 0x00 0x00 0x00 0x00&lt;/strong>&lt;/li>
&lt;li>**Transceiver type **# 收发器类型。示例值：&lt;code>**10G Ethernet: 10G Base-SR**&lt;/code>&lt;/li>
&lt;li>&lt;strong>Encoding : 0x06 (64B/66B)&lt;/strong>&lt;/li>
&lt;li>&lt;strong>BR, Nominal : 10300MBd&lt;/strong>&lt;/li>
&lt;li>&lt;strong>Rate identifier : 0x00 (unspecified)&lt;/strong>&lt;/li>
&lt;li>&lt;strong>Length (SMF,km) : 0km&lt;/strong>&lt;/li>
&lt;li>&lt;strong>Length (SMF) : 0m&lt;/strong>&lt;/li>
&lt;li>&lt;strong>Length (50um) : 80m&lt;/strong>&lt;/li>
&lt;li>&lt;strong>Length (62.5um) : 20m&lt;/strong>&lt;/li>
&lt;li>&lt;strong>Length (Copper) : 0m&lt;/strong>&lt;/li>
&lt;li>&lt;strong>Length (OM3) : 300m&lt;/strong>&lt;/li>
&lt;li>&lt;strong>Laser wavelength : 850nm&lt;/strong>&lt;/li>
&lt;li>&lt;strong>Vendor name : Hisense&lt;/strong>&lt;/li>
&lt;li>&lt;strong>Vendor OUI : 00:00:00&lt;/strong>&lt;/li>
&lt;li>&lt;strong>Vendor PN : LTF8502-BC+-H3C&lt;/strong>&lt;/li>
&lt;li>&lt;strong>Vendor rev : 1&lt;/strong>&lt;/li>
&lt;li>&lt;strong>Option values : 0x00 0x1a&lt;/strong>&lt;/li>
&lt;li>&lt;strong>Option : RX_LOS implemented&lt;/strong>&lt;/li>
&lt;li>**Option : TX_FAULT implemented **&lt;/li>
&lt;li>**Option : TX_DISABLE implemented **&lt;/li>
&lt;li>&lt;strong>BR margin, max : 20%&lt;/strong>&lt;/li>
&lt;li>&lt;strong>BR margin, min : 20%&lt;/strong>&lt;/li>
&lt;li>&lt;strong>Vendor SN : U8AA7H05H97&lt;/strong>&lt;/li>
&lt;li>&lt;strong>Date code : 200727__&lt;/strong>&lt;/li>
&lt;li>&lt;strong>Optical diagnostics support : Yes&lt;/strong>&lt;/li>
&lt;li>&lt;strong>光模块特有信息&lt;/strong>
&lt;ul>
&lt;li>**Laser bias current **# 激光偏置电流。示例值：&lt;code>**5.762 mA**&lt;/code>&lt;/li>
&lt;li>&lt;strong>Laser output power&lt;/strong> # 激光输出功率(光模块发送功率)。示例值：&lt;code>**0.5240 mW / -2.81 dBm**&lt;/code>&lt;/li>
&lt;li>**Receiver signal average optical power **# 接收信号的平均光功率(光模块接收功率)。示例值：&lt;code>**0.4646 mW / -3.33 dBm**&lt;/code>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>Module temperature : 26.32 degrees C / 79.38 degrees F&lt;/strong>&lt;/li>
&lt;li>&lt;strong>Module voltage : 3.3360 V&lt;/strong>&lt;/li>
&lt;li>&lt;strong>模块告警开关&lt;/strong>
&lt;ul>
&lt;li>&lt;strong>Alarm/warning flags implemented : Yes&lt;/strong>&lt;/li>
&lt;li>&lt;strong>Laser bias current high alarm : Off&lt;/strong>&lt;/li>
&lt;li>&lt;strong>Laser bias current low alarm : Off&lt;/strong>&lt;/li>
&lt;li>&lt;strong>Laser bias current high warning : Off&lt;/strong>&lt;/li>
&lt;li>&lt;strong>Laser bias current low warning : Off&lt;/strong>&lt;/li>
&lt;li>&lt;strong>Laser output power high alarm : Off&lt;/strong>&lt;/li>
&lt;li>&lt;strong>Laser output power low alarm : Off&lt;/strong>&lt;/li>
&lt;li>&lt;strong>Laser output power high warning : Off&lt;/strong>&lt;/li>
&lt;li>&lt;strong>Laser output power low warning : Off&lt;/strong>&lt;/li>
&lt;li>&lt;strong>Module temperature high alarm : Off&lt;/strong>&lt;/li>
&lt;li>&lt;strong>Module temperature low alarm : Off&lt;/strong>&lt;/li>
&lt;li>&lt;strong>Module temperature high warning : Off&lt;/strong>&lt;/li>
&lt;li>&lt;strong>Module temperature low warning : Off&lt;/strong>&lt;/li>
&lt;li>&lt;strong>Module voltage high alarm : Off&lt;/strong>&lt;/li>
&lt;li>&lt;strong>Module voltage low alarm : Off&lt;/strong>&lt;/li>
&lt;li>&lt;strong>Module voltage high warning : `Off&lt;/strong>&lt;/li>
&lt;li>&lt;strong>Module voltage low warning : Off&lt;/strong>&lt;/li>
&lt;li>&lt;strong>Laser rx power high alarm : Off&lt;/strong>&lt;/li>
&lt;li>&lt;strong>Laser rx power low alarm : Off&lt;/strong>&lt;/li>
&lt;li>&lt;strong>Laser rx power high warning : Off&lt;/strong>&lt;/li>
&lt;li>&lt;strong>Laser rx power low warning : Off&lt;/strong>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>模块告警阈值&lt;/strong>
&lt;ul>
&lt;li>&lt;strong>Laser bias current high alarm threshold : 16.500 mA&lt;/strong>&lt;/li>
&lt;li>&lt;strong>Laser bias current low alarm threshold : 1.000 mA&lt;/strong>&lt;/li>
&lt;li>&lt;strong>Laser bias current high warning threshold : 15.000 mA&lt;/strong>&lt;/li>
&lt;li>&lt;strong>Laser bias current low warning threshold : 1.000 mA&lt;/strong>&lt;/li>
&lt;li>&lt;strong>Laser output power high alarm threshold : 1.2589 mW / 1.00 dBm&lt;/strong>&lt;/li>
&lt;li>&lt;strong>Laser output power low alarm threshold : 0.0933 mW / -10.30 dBm&lt;/strong>&lt;/li>
&lt;li>&lt;strong>Laser output power high warning threshold : 0.7943 mW / -1.00 dBm&lt;/strong>&lt;/li>
&lt;li>&lt;strong>Laser output power low warning threshold : 0.1862 mW / -7.30 dBm&lt;/strong>&lt;/li>
&lt;li>&lt;strong>Module temperature high alarm threshold : 81.00 degrees C / 177.80 degrees F&lt;/strong>&lt;/li>
&lt;li>&lt;strong>Module temperature low alarm threshold : 0.00 degrees C / 32.00 degrees F&lt;/strong>&lt;/li>
&lt;li>&lt;strong>Module temperature high warning threshold : 78.00 degrees C / 172.40 degrees F&lt;/strong>&lt;/li>
&lt;li>&lt;strong>Module temperature low warning threshold : 3.00 degrees C / 37.40 degrees F&lt;/strong>&lt;/li>
&lt;li>&lt;strong>Module voltage high alarm threshold : 3.7950 V&lt;/strong>&lt;/li>
&lt;li>&lt;strong>Module voltage low alarm threshold : 2.8050 V&lt;/strong>&lt;/li>
&lt;li>&lt;strong>Module voltage high warning threshold : 3.5000 V&lt;/strong>&lt;/li>
&lt;li>&lt;strong>Module voltage low warning threshold : 3.1000 V&lt;/strong>&lt;/li>
&lt;li>&lt;strong>Laser rx power high alarm threshold : 1.2589 mW / 1.00 dBm&lt;/strong>&lt;/li>
&lt;li>&lt;strong>Laser rx power low alarm threshold : 0.0646 mW / -11.90 dBm&lt;/strong>&lt;/li>
&lt;li>&lt;strong>Laser rx power high warning threshold : 0.7943 mW / -1.00 dBm&lt;/strong>&lt;/li>
&lt;li>&lt;strong>Laser rx power low warning threshold : 0.1023 mW / -9.90 dBm&lt;/strong>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul></description></item><item><title>Docs: find whereis which 查询工具</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/x.linux-%E7%AE%A1%E7%90%86/linux-%E7%B3%BB%E7%BB%9F%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/%E7%A3%81%E7%9B%98-%E4%B8%8E-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7%E9%9B%86/find-whereis-which-%E6%9F%A5%E8%AF%A2%E5%B7%A5%E5%85%B7/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/x.linux-%E7%AE%A1%E7%90%86/linux-%E7%B3%BB%E7%BB%9F%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/%E7%A3%81%E7%9B%98-%E4%B8%8E-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7%E9%9B%86/find-whereis-which-%E6%9F%A5%E8%AF%A2%E5%B7%A5%E5%85%B7/</guid><description>
&lt;h1 id="which-查看可执行文件的位置">which 查看可执行文件的位置&lt;/h1>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>root@lichenhao:~# which ls
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>/usr/bin/ls
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h1 id="whereis-查看文件的位置-如-whereis-ls">whereis 查看文件的位置， 如 whereis ls&lt;/h1>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>root@lichenhao:~# whereis ls
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>ls: /usr/bin/ls /usr/share/man/man1/ls.1.gz
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h1 id="find--在目录中搜索文件">find # 在目录中搜索文件&lt;/h1>
&lt;h2 id="syntax语法">Syntax(语法)&lt;/h2>
&lt;p>&lt;strong>find [OPTIONS] [PATH&amp;hellip;] [EXPRESSION]&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>PATH # 路径名，不写上默认表示在当前路径下搜索&lt;/li>
&lt;li>OPTIONS 与 EXPRESSION # 详见下文，PATH 可以指定一个或多个想要搜索的路径。&lt;/li>
&lt;/ul>
&lt;p>如果没有给出 PATH，则使用当前目录；如果未给出任何表达式，则使用表达式 -print&lt;/p>
&lt;h3 id="options">OPTIONS&lt;/h3>
&lt;p>-H，-L 和-P 选项控制 find 处理符号链接的行为。这些参数之后的命令行参数将被视为要检查的文件或目录的名称，直到以 - 开头的第一个参数或参数 ( 或 ! 。符号链接的概念详见：ln 链接&lt;/p>
&lt;ul>
&lt;li>**-P **# 不跟踪符号链接。该选项为 find 的默认行为。当 find 检查或打印文件信息时，该文件是符号链接，则所使用的信息应取自符号链接本身的属性。&lt;/li>
&lt;li>&lt;strong>-L&lt;/strong> # 跟踪符号链接。与 -type l 同时使用时仅搜索失效的符号链接。当 find 检查或打印有关文件的信息时，所使用的信息应从链接指向的文件的属性中获取，而不是从链接本身获取（除非它是断开的符号链接，或者 find 无法检查与之相关的文件）链接点）。使用此选项意味着-noleaf。如果以后使用-P 选项，则-noleaf 仍然有效。如果-L 有效，并且 find 在搜索过程中发现到子目录的符号链接，则将搜索该符号链接所指向的子目录。
&lt;ul>
&lt;li>当-L 选项生效时，-type 谓词将始终与符号链接指向的文件类型匹配，而不是与链接本身匹配（除非符号链接断开）。使用-L 会使-lname 和-ilname 谓词始终返回 false。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>-H&lt;/strong> # 除了处理命令行参数时，不要跟随符号链接。当 find 检查或打印有关文件的信息时，所使用的信息应取自符号链接本身的属性。唯一的例外情况是在命令行上指定的文件是符号链接并且可以解析该链接时，这种情况下，使用的信息取自链接指向的任何位置（即跟随该链接） ）。如果无法检查符号链接指向的文件，则有关链接本身的信息将用作备用。如果-H 有效，并且在命令行上指定的路径之一是指向目录的符号链接，则将检查该目录的内容（尽管-maxdepth 0 当然可以防止此情况）。&lt;/li>
&lt;li>&lt;strong>-D debugoptions&lt;/strong> # Print diagnostic information; this can be helpful to diagnose problems with why find is not doing what you want. The list of debug options should be comma separated. Compatibility of the debug options is not guaranteed between releases of findutils. For a complete list of valid debug options, see the output of find -D help. Valid debug options include&lt;/li>
&lt;li>&lt;strong>-Olevel&lt;/strong> # Enables query optimisation. The find program reorders tests to speed up execution while preserving the overall effect; that is, predicates with side effects are not reordered relative to each other. The optimisations performed at each optimisation level are as follows.&lt;/li>
&lt;/ul>
&lt;p>注意：&lt;/p>
&lt;ol>
&lt;li>上述五个 OPTIONS 必须出现在第一个 PATH 之前。&lt;/li>
&lt;li>下面 EXPRESSIONS(表达式)中的 OPTIONS，用来控制 find 的行为，与上述这些 OPTIONS 不同。并且表达式中的 OPTIONS 需要在第一个 PATH 之后指定。&lt;/li>
&lt;li>find 默认将在当前目录下查找子目录与文件。并且将查找到的子目录和文件全部进行显示&lt;/li>
&lt;/ol>
&lt;h3 id="expressions表达式">EXPRESSIONS(表达式)&lt;/h3>
&lt;p>EXPRESSIONS 由以下几部分组成&lt;/p>
&lt;ul>
&lt;li>OPTIONS 选项 #（这会影响整体操作，而不是特定文件的处理，并且始终返回 true）&lt;/li>
&lt;li>TESTS 测试 #（返回正确或错误的值）&lt;/li>
&lt;li>ACTIONS 动作 #（具有副作用并返回 true 或 false 值）&lt;/li>
&lt;/ul>
&lt;p>上述三部分表达式由运算符分隔。如果表达式除-prune 之外不包含其他任何动作，则对表达式为 true 的所有文件执行-print。&lt;/p>
&lt;p>OPTIONS：&lt;/p>
&lt;ul>
&lt;li>&lt;strong>-type&lt;/strong> # 根据文件类型查找 （find PATH -type 类型参数）
&lt;ul>
&lt;li>参数类型包括：f 普通文件，l 软连接文件，d 目录文件等&lt;/li>
&lt;li>例: find -type l #查找当前目录下的软连接文件&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>-name&lt;/strong> # 根据文件名查找 （* 任意多个字符）（? 1 个字符）（[] 指范围值，外侧加引号）
&lt;ul>
&lt;li>例：find /var –name &amp;ldquo;*.log&amp;rdquo; #查找/var 目录下，所有文件名最后字符是.log 的文件&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>-iname&lt;/strong> # 不区分大小写根据文件名查找&lt;/li>
&lt;li>&lt;strong>-inum&lt;/strong> # 根据 inode 号查找&lt;/li>
&lt;li>&lt;strong>-size&lt;/strong> # 根据大小查找
&lt;ul>
&lt;li>例:find /etc -size -10k -size +20k #查找/etc 目录下小于 10k 大于 20k 的文件&lt;/li>
&lt;li>注意+-号，如果没有，是精确这么大，通常都会带上+或-号，表示一个范围&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>-user&lt;/strong> # 根据所有者查找 （user 可改成 group 则查找属组为 lisi 的文件）
&lt;ul>
&lt;li>例:find /home -user lisi #查找/home 目录下，属主为 lisi 的文件&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>-perm&lt;/strong> # 根据文件权限查找
&lt;ul>
&lt;li>例:find /boot -perm 644 #查找/boot 文件加下，权限为 644 的文件&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>**-TIME {+|-}NUM **# 根据时间查找
&lt;ul>
&lt;li>
&lt;ul>
&lt;li>表示该时间之前，-表示该时间之内&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>TIME 分为两部分
&lt;ul>
&lt;li>第一部分，# 表示 ctime，atime，mtime；time 天，min 分钟
&lt;ul>
&lt;li>&lt;strong>c&lt;/strong> # change #表示属性被修改过：所有者、所属组、权限&lt;/li>
&lt;li>&lt;strong>a&lt;/strong> # access #被访问过(被查看过)&lt;/li>
&lt;li>&lt;strong>m&lt;/strong> # modify #表示内容被修改过&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>第二部分
&lt;ul>
&lt;li>&lt;strong>time&lt;/strong> # 天&lt;/li>
&lt;li>&lt;strong>min&lt;/strong> # 分钟&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>逻辑连接符 #-a （and 逻辑与），-o （or 逻辑或)例：&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>-maxdepth &lt;!-- raw HTML omitted -->&lt;/strong> # 设置最大目录层级
&lt;ul>
&lt;li>例：find /home -maxdepth 1 -name *.log #查找/home 目录下 1 层的以.log 结尾的文件（即只查找当前目录，不查找当前目录下的子目录中的内容）&lt;/li>
&lt;li>-ls 假设 find 指令的回传值为 Ture，就将文件或目录名称列出到标准输出&lt;/li>
&lt;li>例：find /home -type d -ls #查找/home 目录下的文件夹，并列出这些文件夹的详细信息&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>ACTIONS 动作
&lt;strong>[ -exec 或者-ok command ] {} [];&lt;/strong>&lt;/p>
&lt;ol>
&lt;li>&lt;strong>-delete&lt;/strong> # 删除找到的文件。使用-delete 会自动打开“ -depth”选项。&lt;/li>
&lt;li>&lt;strong>-exec &lt;!-- raw HTML omitted -->&lt;/strong> # 假设 find 指令的回传值为 True，就执行该指令；-ok 与-exec 类似，只不过是交互型。
&lt;ol>
&lt;li>格式:find PATH 选项 选项内容 -exec COMMAND {} ;&lt;/li>
&lt;li>该格式的意思是使用 find 查找出来的内容放到{}中，再对{}中的内容逐条执行 COMMAND 命令&lt;/li>
&lt;li>它的终止是以;为结束标志的，所以这句命令后面的分号是不可缺少的，考虑到各个系统中分号会有不同的意义，所以前面加反斜杠。（反斜杠的意思参考正则表达式）&lt;/li>
&lt;li>{} 花括号里面存放前面 find 查找出来的文件名。&lt;/li>
&lt;li>注意：固定格式，只能这样写。注意中间的空格。&lt;/li>
&lt;/ol>
&lt;/li>
&lt;li>&lt;strong>-ok&lt;/strong> #&lt;/li>
&lt;/ol>
&lt;p>注意该语法格式中不要少了最后的分好和最后大括号周围的空格，-ok 为会询问，交互式&lt;/p>
&lt;h2 id="example">EXAMPLE&lt;/h2>
&lt;ul>
&lt;li>删除 /var/log/pods 目录下失效的符号链接
&lt;ul>
&lt;li>find -L /var/log/pods -type l -delete&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>找到/home 目录下的 samlee 用户的所有文件并删除
&lt;ul>
&lt;li>find /home -user samlee -exec rm –r {} ;&lt;/li>
&lt;li>注：rm -r 连带目录一起删除。报错原因：-exec 不适合大量传输，速率慢导致。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>查看当前目录下两天之前修改过得并且 10 分钟之内查看过得文件
&lt;ul>
&lt;li>find -mtime +2 -amin -10&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>查看当前目录下 7 天之内并且 2 天之前的文件
&lt;ul>
&lt;li>find -mtime -7 -a -mtime +2&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>在 etc 目录下查找大于 1k 并且小于 10k 的文件
&lt;ul>
&lt;li>find /etc -size +1k -a -size -10k&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>-inum 根据文件 i 节点查询
&lt;ul>
&lt;li>find ./ -inum 2310630 -exec rm {} ; #有一些文件的硬链接数量很多，有相同的 i 节点，查找其中一个文件的 i 节点号，一次性删除。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>find -maxdepth 1 -mtime +1 -exec ls -l {} ; #查找出来的如果是文件夹，那么就对这个文件夹执行该命命令，如下图所示，查找出来./test 等 3 个文件夹，那么就这三个文件夹执行 ls -l 的命令，即
&lt;ul>
&lt;li>ls -l ./test&lt;/li>
&lt;li>ls -l ./lichenhao&lt;/li>
&lt;li>ls -l ./lost+found&lt;/li>
&lt;li>注：查找出来的文字，一字不差的全部放在后面的{}中，等待 COMMAND 执行，所以没法列出目录的详细信息&lt;/li>
&lt;li>注意与-ls 参数的区别&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/idlpqz/1616166302372-29738c6b-f92a-43b5-9243-9aa5483629ca.jpeg" alt="">&lt;/p>
&lt;h3 id="查找重复文件">查找重复文件&lt;/h3>
&lt;p>在工作生活当中，我们很可能会遇到查找重复文件的问题。比如从某游戏提取的游戏文本有重复的，我们希望找出所有重复的文本，让翻译只翻译其中一份，而其他的直接替换。那么这个问题该怎么做呢？当然方法多种多样，而且无论那种方法应该都不会太难，但笔者第一次遇到这个问题的时候第一反应是是用 Linux 的 Shell 脚本，所以文本介绍这种方式。
先上代码：
&lt;code>find -not -empty -type f -printf &amp;quot;%sn&amp;quot; | sort -rn |uniq -d | xargs -I{} -n1 find -type f -size {}c -print0 | xargs -0 md5sum | sort | uniq -w32 --all-repeated=separate | cut -b 36-&lt;/code>
大家先 cd 到自己想要查找重复文件的文件夹，然后 copy 上面代码就可以了，系统会对当前文件夹及子文件夹内的所有文件进行查重。
下面分析一下上面的命令。
首先看第一句：
&lt;code>find -not -empty -type f -printf &amp;quot;%sn&amp;quot;&lt;/code>
find 是查找命令；-not -empty 是要寻找非空文件；-type f 是指寻找常规文件；-printf “%sn”比较具有迷惑性，这里的%s 并非 C 语言中的输出字符串，它实际表示的是文件的大小，单位为 bytes（不懂就 man，man 一下 find，就可以看到了），n 是换行符。所以这句话的意思是输出所有非空文件的大小。
通过管道，上面的结果被传到第二句：
&lt;code>sort -rn&lt;/code>
sort 是排序，-n 是指按大小排序，-r 是指从大到小排序（逆序 reverse）。
第三句：
&lt;code>uniq -d&lt;/code>
uniq 是把重复的只输出一次，而-d 指只输出重复的部分（如 9 出现了 5 次，那么就输出 1 个 9，而 2 只出现了 1 次，并非重复出现的数字，故不输出）。
第四句：
&lt;code>xargs -I{} -n1 find -type f -size {}c -print0&lt;/code>
这一部分分两部分看，第一部分是 xargs -I{} -n1，xargs 命令将之前的结果转化为参数，供后面的 find 调用，其中-I{}是指把参数写成{}，而-n1 是指将之前的结果一个一个输入给下一个命令（-n8 就是 8 个 8 个输入给下一句，不写-n 就是把之前的结果一股脑的给下一句）。后半部分是 find -type f -size {}c -print0，find 指令我们前面见过，-size{}是指找出大小为{}bytes 的文件，而-print0 则是为了防止文件名里带空格而写的参数。
第五句：
&lt;code>xargs -0 md5sum&lt;/code>
xargs 我们之前说过，是将前面的结果转化为输入，那么这个-0 又是什么意思？man 一下 xargs，我们看到-0 表示读取参数的时候以 null 为分隔符读取，这也不难理解，毕竟 null 的二进制表示就是 00。后面的 md5sum 是指计算输入的 md5 值。
第六句：sort 是排序，这个我们前面也见过。
第七句：
&lt;code>uniq -w32 --all-repeated=separate&lt;/code>
uniq -w32 是指寻找前 32 个字符相同的行，原因在于 md5 值一定是 32 位的，而后面的&amp;ndash;all-repeated=separate 是指将重复的部分放在一类，分类输出。
第八句：
&lt;code>cut -b 36-&lt;/code>
由于我们的结果带着 md5 值，不是很好看，所以我们截取 md5 值后面的部分，cut 是文本处理函数，这里-b 36-是指只要每行 36 个字符之后的部分。
我们将上述每个命令用管道链接起来，存入 result.txt：
&lt;code>find -not -empty -type f -printf &amp;quot;%sn&amp;quot; | sort -rn |uniq -d | xargs -I{} -n1 find -type f -size {}c -print0 | xargs -0 md5sum | sort | uniq -w32 --all-repeated=separate | cut -b 36- &amp;gt;result.txt&lt;/code>
虽然结果很好看，但是有一个问题，这是在 Linux 下很好看，实际上如果有朋友把输出文件放到 Windows 上，就会发现换行全没了，这是由于 Linux 下的换行是 n，而 windows 要求 nr，为了解决这个问题，我们最后执行一条指令，将 n 转换为 nr：
&lt;code>cat result.txt | cut -c 36- | tr -s 'n'&lt;/code>&lt;/p></description></item><item><title>Docs: fio # 磁盘性能测试工具</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/x.linux-%E7%AE%A1%E7%90%86/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96-%E4%B8%8E-%E6%95%85%E9%9A%9C%E5%A4%84%E7%90%86/%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95/fio-#-%E7%A3%81%E7%9B%98%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/x.linux-%E7%AE%A1%E7%90%86/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96-%E4%B8%8E-%E6%95%85%E9%9A%9C%E5%A4%84%E7%90%86/%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95/fio-#-%E7%A3%81%E7%9B%98%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>项目地址：&lt;a href="https://github.com/axboe/fio">https://github.com/axboe/fio&lt;/a>
官方文档：&lt;a href="https://fio.readthedocs.io/en/latest/">https://fio.readthedocs.io/en/latest/&lt;/a>&lt;/p>
&lt;/blockquote>
&lt;p>注意：！！当使用 fio 的 filename 参数指定某个要测试的裸设备（硬盘或分区），切勿在系统分区做测试，会破坏系统分区，从而导致系统崩溃。若一定要测试系统分区较为安全的方法是：在根目录下创建一个空目录，在测试命令中使用 directory 参数指定该目录，而不使用 filename 参数。现在假设 /dev/vda3 设备挂载在 / 目录下，那么不要执行 fil &amp;ndash;filename=/dev/vda 这种操作！！&lt;/p>
&lt;h2 id="1-性能的基本概念">1 性能的基本概念&lt;/h2>
&lt;h3 id="11-什么是一个-io">1.1 什么是一个 IO&lt;/h3>
&lt;p>IO 即 Input 和 Output，可以分为读 IO 和写 IO。读 IO，就是发指令，从磁盘读取某段扇区的内容。指令一般是通知磁盘开始扇区的位置，然后给出需要从这个初始扇区往后读取的连续扇区个数，同时给出的动作是读，还是写。磁盘收到这条指令，就会按照指令的要求，读或者写数据。控制器发出的这种指令+数据，就是一次 IO，读或者写。&lt;/p>
&lt;h3 id="12-顺序-io-和随机-io">1.2 顺序 IO 和随机 IO&lt;/h3>
&lt;p>顺序和随机，可以简单地理解为本次 IO 给出的初始扇区地址，和上一次 IO 的结束扇区地址，是否是按顺序的，如果相差很大，就算一次随机 IO。&lt;/p>
&lt;h3 id="13-io-大小">1.3 IO 大小&lt;/h3>
&lt;p>一次 IO 需要读或者写的数据块大小。&lt;/p>
&lt;h3 id="14-带宽">1.4 带宽&lt;/h3>
&lt;p>每秒读出或写入的数据量。常用单位包括 KB/s、MB/s、GB/s 等。&lt;/p>
&lt;h3 id="15-延时">1.5 延时&lt;/h3>
&lt;p>客户端发出 IO 请求直到收到请求并响应是需要一段时间的，这段时间就是 IO 延时。IO 延 时一般都是毫秒级的。随着 IO 压力的增大，IO 延时也会随之增大。对于存储来说，由于写 是前台操作，而读是后台操作，因此通常写的 IO 延时要低于读。相同 IO 模型下，IO 延时越小，存储性能越好。一般，IO 延时如果超过 30ms 就说明存储已经比较吃力了。&lt;/p>
&lt;h3 id="16-iops">1.6 IOPS&lt;/h3>
&lt;p>每秒收到的 IO 响应数。读写比例、队列深度、随机度和块大小描述了 IO 模型。在这个模型下，每个 IO 的延时最终体现了 IO 性能。IOPS 和 带宽从两个不同的方面反映了存储性能。&lt;/p>
&lt;h3 id="17-队列深度">1.7 队列深度&lt;/h3>
&lt;p>IO 队列使得 IO 可以并行处理，为何要对磁盘 IO 进行并行处理呢？主要目的是提高磁盘处理 IO 的效率。这一点对于多物理磁盘组成的虚拟磁盘（或 LUN）显得尤为重要。如果 一次提交一个 IO，虽然响应时间较短，但系统的带宽很小。相比较而言，一次提交多个 IO 既缩短了磁头移动距离（通过电梯算法），同时也能够提升 IOPS。&lt;/p>
&lt;h2 id="fio-的工作方式">fio 的工作方式&lt;/h2>
&lt;p>想要运行 fio 可以通过两种方式&lt;/p>
&lt;ol>
&lt;li>给定一个或多个 job files&lt;/li>
&lt;li>直接使用命令行参数&lt;/li>
&lt;/ol>
&lt;p>如果 job file 中仅包含一个作业，则最好只在命令行中提供参数。命令行参数与作业参数相同，还有一些额外的参数可控制全局参数。这里面提到的 job file 中的擦书，其实也可以理解为指令、关键字、字段等等。就是一个配置文件中用来描述程序运行行为的东西。&lt;/p>
&lt;ol>
&lt;li>例如，对于 job files 中的参数 iodepth = 2，在命令行选项为&amp;ndash;iodepth 2 或&amp;ndash;iodepth = 2。&lt;/li>
&lt;li>还可以使用命令行来提供多个作业条目。对于 fio 看到的每个&amp;ndash;name 选项，它将使用该名称开始一个新作业。 &amp;ndash;name 条目之后的命令行条目将应用于该作业，直到没有更多的条目或看到新的&amp;ndash;name 条目为止。这类似于作业文件选项，其中每个选项都适用于当前作业，直到看到新的 [] 作业条目为止。&lt;/li>
&lt;/ol>
&lt;p>开始模拟 I/O 工作负载的第一步，是编写一个描述特定配置的 job file。作业文件可以包含任何数量的线程和/或文件-作业文件的典型内容是定义共享参数的全局部分，以及一个或多个描述所涉及作业的作业部分。运行时，fio 会分析该文件并按照说明进行所有设置。如果我们从上到下分解一个 job ，它包含以下基本参数：&lt;/p>
&lt;ol>
&lt;li>I/O type # 定义发布给文件的 I / O 模式。我们可能只从该文件中顺序读取，或者我们可能在随机写入。甚至顺序或随机混合读写。我们应该执行缓冲 I / O 还是直接/原始 I / O？&lt;/li>
&lt;li>Block size # 指定模拟 I/O 数据流时，每次 I/O 的块大小。可以是单个值，也可以描述块大小的范围。&lt;/li>
&lt;li>I/O size # 指定本次 job 将要读取或写入多少数据&lt;/li>
&lt;li>I/O engine # 定义如何向文件发出 I/O。我们可以使用内存映射文件，可以使用常规读/写，可以使用拼接，异步 I / O 甚至是 SG（SCSI 通用 sg）&lt;/li>
&lt;li>I/O depth # 定义在 I/O engine 是异步的时，我们要保持多大的队列深度&lt;/li>
&lt;li>Target file/device # How many files are we spreading the workload over.&lt;/li>
&lt;li>Threads, processes and job synchronization # How many threads or processes should we spread this workload over.&lt;/li>
&lt;/ol>
&lt;h1 id="job-file-格式">Job File 格式&lt;/h1>
&lt;p>Job file 参数详见：fio 参数详解&lt;/p>
&lt;p>如前所述，fio 接受一个或多个描述该操作的作业文件。作业文件格式是经典的 ini 文件，其中[]括号中的名称定义了作业名称。您可以随意使用任何所需的 ASCII 名称，但具有特殊含义的 global 除外。作业名称后面是零个或多个参数的序列，每行一个，用于定义作业的行为。如果一行中的第一个字符是“;”或“＃”，则整行都将作为注释被丢弃。&lt;/p>
&lt;p>全局部分为该文件中描述的作业设置默认值。作业可以覆盖全局节参数，并且如果需要的话，作业文件甚至可以具有多个全局节。作业仅受位于其上方的全局部分影响。&lt;/p>
&lt;p>因此，让我们看一个非常简单的作业文件，该文件定义了两个过程，每个过程都随机读取 128MiB 文件：&lt;/p>
&lt;pre>&lt;code>; -- start job file --
[global]
rw=randread
size=128m
[job1]
[job2]
; -- end job file --
&lt;/code>&lt;/pre>
&lt;p>如您所见，作业文件部分本身为空，因为所有描述的参数都是共享的。由于未提供文件名选项，因此，fio 会为每个作业组成一个合适的文件名。在命令行上，此作业如下所示：&lt;/p>
&lt;pre>&lt;code>$ fio --name=global --rw=randread --size=128m --name=job1 --name=job2
&lt;/code>&lt;/pre>
&lt;p>让我们看一个示例，其中有许多进程随机写入文件：&lt;/p>
&lt;pre>&lt;code>; -- start job file --
[random-writers]
ioengine=libaio
iodepth=4
rw=randwrite
bs=32k
direct=0
size=64m
numjobs=4
; -- end job file --
&lt;/code>&lt;/pre>
&lt;p>这里我们没有全局部分，因为我们只定义了一项工作。我们想在这里使用异步 I / O，每个文件的深度为 4。我们还将缓冲区大小增加到 32KiB，并将 numjobs 定义为 4，以分叉 4 个相同的作业。结果是 4 个进程，每个进程随机写入其自己的 64MiB 文件。您可以在命令行上指定参数，而不使用上面的作业文件。对于这种情况，您可以指定：&lt;/p>
&lt;pre>&lt;code>$ fio --name=random-writers --ioengine=libaio --iodepth=4 --rw=randwrite --bs=32k --direct=0 --size=64m --numjobs=4
&lt;/code>&lt;/pre>
&lt;h1 id="fio-命令行工具">fio 命令行工具&lt;/h1>
&lt;h2 id="fio-options-job-options-job-files">fio [OPTIONS] [JOB OPTIONS] [job file(s)]&lt;/h2>
&lt;p>OPTIONS&lt;/p>
&lt;p>JOB OPTIONS&lt;/p>
&lt;ol>
&lt;li>由于 Jobfile 中的参数与命令行选项基本保持一一对应的关系，所以对于 fio 的命令行参数，参考 Job file 参数即可 fio 参数详解&lt;/li>
&lt;/ol>
&lt;p>EXAMPLE&lt;/p>
&lt;ol>
&lt;li>注意，下面两条命令直接对整块磁盘进行写操作，会破坏文件，谨慎操作
&lt;ol>
&lt;li>fio -filename=/dev/vdb1 -direct=1 -iodepth 64 -thread -rw=randwrite -ioengine=libaio -bs=4K -numjobs=8 -runtime=60 -group_reporting -name=test1&lt;/li>
&lt;li>fio -filename=/dev/vdb3 -direct=1 -iodepth 64 -thread -rw=write -ioengine=libaio -bs=512K -numjobs=8 -runtime=60 -group_reporting -name=test2&lt;/li>
&lt;/ol>
&lt;/li>
&lt;li>&lt;strong>fio &amp;ndash;rw=write &amp;ndash;ioengine=sync &amp;ndash;fdatasync=1 &amp;ndash;directory=/var/lib/etcd &amp;ndash;size=22m &amp;ndash;bs=2300 &amp;ndash;name=&amp;ldquo;fioEtcdTest&amp;rdquo; &amp;ndash;time_based &amp;ndash;runtime=2m&lt;/strong>&lt;/li>
&lt;li>&lt;strong>fio &amp;ndash;rw=write &amp;ndash;ioengine=libaio &amp;ndash;iodepth=4 &amp;ndash;direct=1 &amp;ndash;filename=fiotest &amp;ndash;size=2G &amp;ndash;bs=4k &amp;ndash;name=&amp;ldquo;Max throughput&amp;rdquo; &amp;ndash;time_based &amp;ndash;runtime=60&lt;/strong>&lt;/li>
&lt;/ol>
&lt;h2 id="结果分析">结果分析&lt;/h2>
&lt;p>官方文档：&lt;a href="https://fio.readthedocs.io/en/latest/fio_doc.html#interpreting-the-output">https://fio.readthedocs.io/en/latest/fio_doc.html#interpreting-the-output&lt;/a>&lt;/p>
&lt;p>使用 fio -ioengine=libaio -bs=4k -direct=1 -thread -rw=write -size=2G -filename=test -name=&amp;ldquo;Max throughput&amp;rdquo; -iodepth=4 -runtime=60 命令得到如下结果&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># 前面几行是命令运行时，实时显示的信息&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># 名为 Max throughput 的 Job 基本信息&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Max throughput: &lt;span style="color:#f92672">(&lt;/span>g&lt;span style="color:#f92672">=&lt;/span>0&lt;span style="color:#f92672">)&lt;/span>: rw&lt;span style="color:#f92672">=&lt;/span>write, bs&lt;span style="color:#f92672">=(&lt;/span>R&lt;span style="color:#f92672">)&lt;/span> 4096B-4096B, &lt;span style="color:#f92672">(&lt;/span>W&lt;span style="color:#f92672">)&lt;/span> 4096B-4096B, &lt;span style="color:#f92672">(&lt;/span>T&lt;span style="color:#f92672">)&lt;/span> 4096B-4096B, ioengine&lt;span style="color:#f92672">=&lt;/span>libaio, iodepth&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">4&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>fio-3.7
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e"># fio 版本号&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Starting &lt;span style="color:#ae81ff">1&lt;/span> thread
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e"># 本次此时启动了 1 个线程&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># 1 表示运行的IO线程数；[W(1)] 表示使用的模式；[100.0%] 表示当前命令的执行进度；[r=0KiB/s,w=137MiB/s] 表示瞬时吞吐率；&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># [r=0,w=35.0k IOPS] 表示 IOPS 瞬时值；[eta 00m:00s] 表示持续时间&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># 该行内容在命令执行期间，可以看到值在实时变化&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Jobs: &lt;span style="color:#ae81ff">1&lt;/span> &lt;span style="color:#f92672">(&lt;/span>f&lt;span style="color:#f92672">=&lt;/span>1&lt;span style="color:#f92672">)&lt;/span>: &lt;span style="color:#f92672">[&lt;/span>W&lt;span style="color:#f92672">(&lt;/span>1&lt;span style="color:#f92672">)][&lt;/span>100.0%&lt;span style="color:#f92672">][&lt;/span>r&lt;span style="color:#f92672">=&lt;/span>0KiB/s,w&lt;span style="color:#f92672">=&lt;/span>137MiB/s&lt;span style="color:#f92672">][&lt;/span>r&lt;span style="color:#f92672">=&lt;/span>0,w&lt;span style="color:#f92672">=&lt;/span>35.0k IOPS&lt;span style="color:#f92672">][&lt;/span>eta 00m:00s&lt;span style="color:#f92672">]&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># 从本行开始为命令执行完成后每个 Job 的统计信息。&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># Job名称：(当前的GID,Job个数)：错误个数：本次Job的PID，本次Job的结束时间&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Max throughput: &lt;span style="color:#f92672">(&lt;/span>groupid&lt;span style="color:#f92672">=&lt;/span>0, jobs&lt;span style="color:#f92672">=&lt;/span>1&lt;span style="color:#f92672">)&lt;/span>: err&lt;span style="color:#f92672">=&lt;/span> 0: pid&lt;span style="color:#f92672">=&lt;/span>7767: Thu Nov &lt;span style="color:#ae81ff">12&lt;/span> 16:09:04 &lt;span style="color:#ae81ff">2020&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># 本次Job的测试模式(这里是写入)，IOPS平均值，带宽平均值，(带宽最大值)(数据总量/运行总时间)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># BW 是 BandWidth 的缩写。2048MiB 就是指的 -size 参数指定的 大小，是本次测试读/写的数据总量&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> write: IOPS&lt;span style="color:#f92672">=&lt;/span>34.3k, BW&lt;span style="color:#f92672">=&lt;/span>134MiB/s &lt;span style="color:#f92672">(&lt;/span>140MB/s&lt;span style="color:#f92672">)(&lt;/span>2048MiB/15289msec&lt;span style="color:#f92672">)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># latency(延迟)相关信息。(单位是：微妙)。注意后面信息括号中的单位会改变，fio 会根据本次测试结果得出的时间，合理给出一个单位。msec毫秒，usec微秒，nsec纳秒&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># slat 是 Submission latency(提交延迟)，就是提交到实际执行 I/O 的时间&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> slat &lt;span style="color:#f92672">(&lt;/span>usec&lt;span style="color:#f92672">)&lt;/span>: min&lt;span style="color:#f92672">=&lt;/span>3, max&lt;span style="color:#f92672">=&lt;/span>6347, avg&lt;span style="color:#f92672">=&lt;/span> 6.09, stdev&lt;span style="color:#f92672">=&lt;/span>12.68
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># clat 是 Completion latency(完成延迟)，就是从提交到完成的时间&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> clat &lt;span style="color:#f92672">(&lt;/span>usec&lt;span style="color:#f92672">)&lt;/span>: min&lt;span style="color:#f92672">=&lt;/span>57, max&lt;span style="color:#f92672">=&lt;/span>74949, avg&lt;span style="color:#f92672">=&lt;/span>108.13, stdev&lt;span style="color:#f92672">=&lt;/span>230.83
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># lat 是 Total latency(总延迟)，就是 fio 从创建这个 I/O 单元到完成的总时间&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> lat &lt;span style="color:#f92672">(&lt;/span>usec&lt;span style="color:#f92672">)&lt;/span>: min&lt;span style="color:#f92672">=&lt;/span>63, max&lt;span style="color:#f92672">=&lt;/span>74954, avg&lt;span style="color:#f92672">=&lt;/span>114.80, stdev&lt;span style="color:#f92672">=&lt;/span>231.22
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># 完成延迟的百分位数(单位是：微妙)，比如99.00th=[ 149] 表示这组样本的 99 百分位的延迟的值为 149&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> clat percentiles &lt;span style="color:#f92672">(&lt;/span>usec&lt;span style="color:#f92672">)&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> | 1.00th&lt;span style="color:#f92672">=[&lt;/span> 86&lt;span style="color:#f92672">]&lt;/span>, 5.00th&lt;span style="color:#f92672">=[&lt;/span> 92&lt;span style="color:#f92672">]&lt;/span>, 10.00th&lt;span style="color:#f92672">=[&lt;/span> 94&lt;span style="color:#f92672">]&lt;/span>, 20.00th&lt;span style="color:#f92672">=[&lt;/span> 97&lt;span style="color:#f92672">]&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> | 30.00th&lt;span style="color:#f92672">=[&lt;/span> 99&lt;span style="color:#f92672">]&lt;/span>, 40.00th&lt;span style="color:#f92672">=[&lt;/span> 101&lt;span style="color:#f92672">]&lt;/span>, 50.00th&lt;span style="color:#f92672">=[&lt;/span> 103&lt;span style="color:#f92672">]&lt;/span>, 60.00th&lt;span style="color:#f92672">=[&lt;/span> 106&lt;span style="color:#f92672">]&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> | 70.00th&lt;span style="color:#f92672">=[&lt;/span> 109&lt;span style="color:#f92672">]&lt;/span>, 80.00th&lt;span style="color:#f92672">=[&lt;/span> 113&lt;span style="color:#f92672">]&lt;/span>, 90.00th&lt;span style="color:#f92672">=[&lt;/span> 119&lt;span style="color:#f92672">]&lt;/span>, 95.00th&lt;span style="color:#f92672">=[&lt;/span> 125&lt;span style="color:#f92672">]&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> | 99.00th&lt;span style="color:#f92672">=[&lt;/span> 149&lt;span style="color:#f92672">]&lt;/span>, 99.50th&lt;span style="color:#f92672">=[&lt;/span> 192&lt;span style="color:#f92672">]&lt;/span>, 99.90th&lt;span style="color:#f92672">=[&lt;/span> 330&lt;span style="color:#f92672">]&lt;/span>, 99.95th&lt;span style="color:#f92672">=[&lt;/span> 988&lt;span style="color:#f92672">]&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> | 99.99th&lt;span style="color:#f92672">=[&lt;/span> 5276&lt;span style="color:#f92672">]&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># 基于一组样本的带宽信息(单位是 KiB/s):最小值，最大值，该线程在其组中接收的总聚合带宽的大约百分比，平均值，标准偏差，本次采样的样本总数&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> bw &lt;span style="color:#f92672">(&lt;/span> KiB/s&lt;span style="color:#f92672">)&lt;/span>: min&lt;span style="color:#f92672">=&lt;/span>113928, max&lt;span style="color:#f92672">=&lt;/span>149024, per&lt;span style="color:#f92672">=&lt;/span>99.98%, avg&lt;span style="color:#f92672">=&lt;/span>137137.07, stdev&lt;span style="color:#f92672">=&lt;/span>7370.84, samples&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">30&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># 基于一组样本的IOPS信息，与 bw 一样&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> iops : min&lt;span style="color:#f92672">=&lt;/span>28482, max&lt;span style="color:#f92672">=&lt;/span>37256, avg&lt;span style="color:#f92672">=&lt;/span>34284.27, stdev&lt;span style="color:#f92672">=&lt;/span>1842.71, samples&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">30&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># I/O 完成延迟的分布，这里的信息适用于一组报告的所有 I/O&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># 500=0.27% 表示 0.27% 的 I/O 在 500 微妙以内完成&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> lat &lt;span style="color:#f92672">(&lt;/span>usec&lt;span style="color:#f92672">)&lt;/span> : 100&lt;span style="color:#f92672">=&lt;/span>34.55%, 250&lt;span style="color:#f92672">=&lt;/span>65.12%, 500&lt;span style="color:#f92672">=&lt;/span>0.27%, 750&lt;span style="color:#f92672">=&lt;/span>0.01%, 1000&lt;span style="color:#f92672">=&lt;/span>0.01%
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> lat &lt;span style="color:#f92672">(&lt;/span>msec&lt;span style="color:#f92672">)&lt;/span> : 2&lt;span style="color:#f92672">=&lt;/span>0.01%, 4&lt;span style="color:#f92672">=&lt;/span>0.02%, 10&lt;span style="color:#f92672">=&lt;/span>0.02%, 20&lt;span style="color:#f92672">=&lt;/span>0.01%, 100&lt;span style="color:#f92672">=&lt;/span>0.01%
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># cpu 使用率&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> cpu : usr&lt;span style="color:#f92672">=&lt;/span>10.24%, sys&lt;span style="color:#f92672">=&lt;/span>23.20%, ctx&lt;span style="color:#f92672">=&lt;/span>189677, majf&lt;span style="color:#f92672">=&lt;/span>0, minf&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># IO 深度在整个工作周期中分布&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> IO depths : 1&lt;span style="color:#f92672">=&lt;/span>0.1%, 2&lt;span style="color:#f92672">=&lt;/span>0.1%, 4&lt;span style="color:#f92672">=&lt;/span>100.0%, 8&lt;span style="color:#f92672">=&lt;/span>0.0%, 16&lt;span style="color:#f92672">=&lt;/span>0.0%, 32&lt;span style="color:#f92672">=&lt;/span>0.0%, &amp;gt;&lt;span style="color:#f92672">=&lt;/span>64&lt;span style="color:#f92672">=&lt;/span>0.0%
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># 一个提交调用中要提交多少IO&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> submit : 0&lt;span style="color:#f92672">=&lt;/span>0.0%, 4&lt;span style="color:#f92672">=&lt;/span>100.0%, 8&lt;span style="color:#f92672">=&lt;/span>0.0%, 16&lt;span style="color:#f92672">=&lt;/span>0.0%, 32&lt;span style="color:#f92672">=&lt;/span>0.0%, 64&lt;span style="color:#f92672">=&lt;/span>0.0%, &amp;gt;&lt;span style="color:#f92672">=&lt;/span>64&lt;span style="color:#f92672">=&lt;/span>0.0%
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># 一个完成调用中要完成多少IO&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> complete : 0&lt;span style="color:#f92672">=&lt;/span>0.0%, 4&lt;span style="color:#f92672">=&lt;/span>100.0%, 8&lt;span style="color:#f92672">=&lt;/span>0.0%, 16&lt;span style="color:#f92672">=&lt;/span>0.0%, 32&lt;span style="color:#f92672">=&lt;/span>0.0%, 64&lt;span style="color:#f92672">=&lt;/span>0.0%, &amp;gt;&lt;span style="color:#f92672">=&lt;/span>64&lt;span style="color:#f92672">=&lt;/span>0.0%
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># 发出的读取/写入/修剪请求的数量，以及其中有多少个请求被缩短或丢弃。&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> issued rwts: total&lt;span style="color:#f92672">=&lt;/span>0,524288,0,0 short&lt;span style="color:#f92672">=&lt;/span>0,0,0,0 dropped&lt;span style="color:#f92672">=&lt;/span>0,0,0,0
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> latency : target&lt;span style="color:#f92672">=&lt;/span>0, window&lt;span style="color:#f92672">=&lt;/span>0, percentile&lt;span style="color:#f92672">=&lt;/span>100.00%, depth&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">4&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># 在上面将所有 Job 的统计信息都列出来之后，这下面显示所有 Job 最终的统计信息。这些数据是所有 Job 的平均值。&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Run status group &lt;span style="color:#ae81ff">0&lt;/span> &lt;span style="color:#f92672">(&lt;/span>all jobs&lt;span style="color:#f92672">)&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># 本次测试的模式(写测试)：带宽平均值，带宽最小值-带宽最大值，io(i.e.读写数据的总量)，运行时间&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># 括号外的值是2的幂的格式，括号中的值是10的幂的等效值&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> WRITE: bw&lt;span style="color:#f92672">=&lt;/span>134MiB/s &lt;span style="color:#f92672">(&lt;/span>140MB/s&lt;span style="color:#f92672">)&lt;/span>, 134MiB/s-134MiB/s &lt;span style="color:#f92672">(&lt;/span>140MB/s-140MB/s&lt;span style="color:#f92672">)&lt;/span>, io&lt;span style="color:#f92672">=&lt;/span>2048MiB &lt;span style="color:#f92672">(&lt;/span>2147MB&lt;span style="color:#f92672">)&lt;/span>, run&lt;span style="color:#f92672">=&lt;/span>15289-15289msec
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># 当前测试数据所在磁盘的统计信息&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># ios 表示所有组执行的 I/O 数，ios就是 I/Os。&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># merge 表示 I/O 调度程序执行的合并数。&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># ticks 表示我们保持磁盘活跃的 ticks 数。&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># in_queue 表示在磁盘队列中花费的总时间&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># util 表示磁盘利用率。在命令执行期间 100％表示我们使磁盘一直处于繁忙状态，而50％的磁盘将有一半的时间处于空闲状态&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># aggr 前缀的信息官方没有说明,应该是聚合的意思&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Disk stats &lt;span style="color:#f92672">(&lt;/span>read/write&lt;span style="color:#f92672">)&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> dm-0: ios&lt;span style="color:#f92672">=&lt;/span>0/519394, merge&lt;span style="color:#f92672">=&lt;/span>0/0, ticks&lt;span style="color:#f92672">=&lt;/span>0/47273, in_queue&lt;span style="color:#f92672">=&lt;/span>47273, util&lt;span style="color:#f92672">=&lt;/span>97.70%, aggrios&lt;span style="color:#f92672">=&lt;/span>0/524290, aggrmerge&lt;span style="color:#f92672">=&lt;/span>0/0, aggrticks&lt;span style="color:#f92672">=&lt;/span>0/48534, aggrin_queue&lt;span style="color:#f92672">=&lt;/span>1310, aggrutil&lt;span style="color:#f92672">=&lt;/span>97.56%
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> vda: ios&lt;span style="color:#f92672">=&lt;/span>0/524290, merge&lt;span style="color:#f92672">=&lt;/span>0/0, ticks&lt;span style="color:#f92672">=&lt;/span>0/48534, in_queue&lt;span style="color:#f92672">=&lt;/span>1310, util&lt;span style="color:#f92672">=&lt;/span>97.56%
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>可以看到，在一个非常强悍的 Optane 盘上面，使用 sync engine，每次都 sync 写盘，性能还是很差的，吞吐不到 300 MB，其他的盘可能就更差了。我们主要关注几个指标：&lt;/p>
&lt;p>slat/clat/lat：这几个是 latency 指标，slat 就是 Submission latency，也就是提交到实际执行 I/O 的时间，在 sync 测试里面这个是没有的，因为 slat 就是 clat。clat 就是 Completion latency，也就是从提交到完成的时间。lat 就是 Total latency，包括 fio 从创建这个 I/O 单元到完成的总的时间。&lt;/p>
&lt;p>另外需要关注的指标就是 BW，和 IOPS，这两这个很直观了，就不解释了。最下面是 ios，也就是总的 I/O 操作次数，merge 就是被 I/O 调度合并的次数，ticks 就是让磁盘保持忙碌的次数，in_queue 就是总的在磁盘队列里面的耗时，而 util 则是磁盘的利用率。&lt;/p>
&lt;h2 id="其他测试命令">其他测试命令&lt;/h2>
&lt;p>fio &amp;ndash;filename=/dev/vdb -direct=1 -bs=1M -rw=randwrite -ioengine=libaio -size=50g -numjobs=32 -iodepth=32  -group_reporting -name=mytest -thread &amp;ndash;time_based &amp;ndash;runtime=120&lt;/p>
&lt;p>&lt;a href="https://mp.weixin.qq.com/s/zpkheD6Izn0RsipSukHA5Q">https://mp.weixin.qq.com/s/zpkheD6Izn0RsipSukHA5Q&lt;/a>&lt;/p></description></item><item><title>Docs: fio 参数详解</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/x.linux-%E7%AE%A1%E7%90%86/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96-%E4%B8%8E-%E6%95%85%E9%9A%9C%E5%A4%84%E7%90%86/%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95/fio-#-%E7%A3%81%E7%9B%98%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/fio-%E5%8F%82%E6%95%B0%E8%AF%A6%E8%A7%A3/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/x.linux-%E7%AE%A1%E7%90%86/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96-%E4%B8%8E-%E6%95%85%E9%9A%9C%E5%A4%84%E7%90%86/%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95/fio-#-%E7%A3%81%E7%9B%98%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/fio-%E5%8F%82%E6%95%B0%E8%AF%A6%E8%A7%A3/</guid><description>
&lt;h1 id="fio-job-file-参数详解">fio Job file 参数详解&lt;/h1>
&lt;p>官方文档：&lt;a href="https://fio.readthedocs.io/en/latest/fio_doc.html#job-file-parameters">https://fio.readthedocs.io/en/latest/fio_doc.html#job-file-parameters&lt;/a>&lt;/p>
&lt;h2 id="参数类型">参数类型：&lt;/h2>
&lt;p>Job file 的参数有多种类型，每种类型的参数的值可用的类型各不相同，比如时间类型的参数的值就需要填写时间相关的值。&lt;/p>
&lt;p>str # 字符串类型。值为字符数字字符序列&lt;/p>
&lt;p>time # 时间类型。值为带时间后缀的整数。时间的默认单位是秒(seconds)。可以指定其他单位： 天(d)、小时(h)、分钟(m)、毫秒(ms 或 msec)、微秒(us 或 usec)。e.g.使用 10m 表示 10 分钟。&lt;/p>
&lt;p>int # 整数类型。整数值，可以包含整数前缀和整数后缀：&lt;/p>
&lt;p>bool # 布尔类型。通常解析为整数，但是仅定义为 true 和 false（1 和 0）&lt;/p>
&lt;p>irange # 范围类型。带后缀的整数范围。允许给出值范围，例如 1024-4096。冒号也可以用作分隔符，例如。 1k：4k。如果该选项允许两组范围，则可以使用“，”或“ /”定界符来指定它们：1k-4k / 8k-32k。另请参见 int.&lt;/p>
&lt;p>float_list # 浮点列表类型。浮点数列表，以&amp;rsquo;：&amp;lsquo;字符分隔。&lt;/p>
&lt;h1 id="描述-job-的相关参数">描述 JOB 的相关参数&lt;/h1>
&lt;p>name=STR #这可以用来覆盖由 fio 为该作业打印的名称。否则，使用作业名称。在命令行上，此参数的特殊目的还用于发信号通知新作业的开始。&lt;/p>
&lt;h1 id="时间相关参数">时间相关参数&lt;/h1>
&lt;p>官方文档：&lt;a href="https://fio.readthedocs.io/en/latest/fio_doc.html#time-related-parameters">https://fio.readthedocs.io/en/latest/fio_doc.html#time-related-parameters&lt;/a>&lt;/p>
&lt;p>runtime=TIME # 指定 Job 运行的时间(默认单位：秒)。到时间后，不管指定的 size 大小有没有读写完。&lt;/p>
&lt;p>time_based # 如果设置，则 fio 将在 &lt;code>runtime 的值&lt;/code>这个时间内内运行，即使已完全读取或写入文件。它会在运行时允许的情况下简单地循环相同的工作负载。&lt;/p>
&lt;blockquote>
&lt;p>该参数一般配合 runtime 一起使用，单独使用没有效果。&lt;/p>
&lt;/blockquote>
&lt;h1 id="要测试的目标文件设备相关参数">要测试的目标文件/设备相关参数&lt;/h1>
&lt;p>directory=STR # 测试目录。&lt;/p>
&lt;p>filename=STR # 测试文件名称。通常选择需要测试的盘的 data 目录&lt;/p>
&lt;p>注意：！！当使用 fio 的 filename 参数指定某个要测试的裸设备（硬盘或分区），切勿在系统分区做测试，会破坏系统分区，而导致系统崩溃。若一定要测试系统分区较为安全的方法是：在根目录下创建一个空目录，在测试命令中使用 directory 参数指定该目录，而不使用 filename 参数。现在假设 /dev/vda3 设备挂载在 / 目录下，那么不要执行 fil &amp;ndash;filename=/dev/vda 这种操作&lt;/p>
&lt;h1 id="io-type-相关参数">I/O TYPE 相关参数&lt;/h1>
&lt;p>官方文档：&lt;a href="https://fio.readthedocs.io/en/latest/fio_doc.html#i-o-type">https://fio.readthedocs.io/en/latest/fio_doc.html#i-o-type&lt;/a>&lt;/p>
&lt;p>direct=BOOL # 测试过程绕过系统的 buffer。使测试结果更真实。&lt;code>默认值：false&lt;/code>i.e.使用缓存。&lt;/p>
&lt;p>rw=STR # 测试时的 I/O 模式。默认为 read。可用的模式有：&lt;/p>
&lt;ol>
&lt;li>
&lt;p>read # 顺序读&lt;/p>
&lt;/li>
&lt;li>
&lt;p>write # 顺序写&lt;/p>
&lt;/li>
&lt;li>
&lt;p>randread # 随机读&lt;/p>
&lt;/li>
&lt;li>
&lt;p>randwrite # 随机写&lt;/p>
&lt;/li>
&lt;li>
&lt;p>randrw # 随机混合读和写&lt;/p>
&lt;/li>
&lt;li>
&lt;p>等&amp;hellip;..其余模式见官方文档&lt;/p>
&lt;/li>
&lt;/ol>
&lt;p>fdatasync=INT # 与 fsync 类似，但使用 fdatasync(2)只同步数据而不同步元数据块。在 Windows, FreeBSD, DragonFlyBSD 或 OSX 中没有 fdatasync(2)，所以这就回到使用 fsync(2)。默认值为 0，这意味着 fio 不会定期发出问题，并等待数据同步完成。&lt;/p>
&lt;h1 id="block-大小相关参数">Block 大小相关参数&lt;/h1>
&lt;p>官方文档：&lt;a href="https://fio.readthedocs.io/en/latest/fio_doc.html#block-size">https://fio.readthedocs.io/en/latest/fio_doc.html#block-size&lt;/a>&lt;/p>
&lt;p>bs=INT # 单次 I/O 的块文件大小&lt;/p>
&lt;p>bsrange=iRANGE # 与 bs 参数类似，只不过是指定一个块文件大小的范围&lt;/p>
&lt;h1 id="buffers-and-memory-相关参数">Buffers and memory 相关参数&lt;/h1>
&lt;p>zero_buffers # 用 0 初始化系统 buffer&lt;/p>
&lt;h1 id="io-size-相关参数">I/O Size 相关参数&lt;/h1>
&lt;p>size=INT # 本次的测试文件大小为 INT。fio 程序将持续运行，直到传输了 INT 这些数据。&lt;/p>
&lt;h1 id="io-engine引擎-相关参数">I/O engine(引擎) 相关参数&lt;/h1>
&lt;p>ioengine=STR # 告诉 fio 使用什么样的方式去测试 I/O。有如下方式可用：&lt;/p>
&lt;ol>
&lt;li>
&lt;p>sync # 也就是最通常的 read/write 操作。基本的读(2)或写(2)I/O。lseek(2)用于定位 I/O 位置。请参阅 fsync 和 fdatasync 来同步写 I/O。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>psync # 基本的 pread(2)或 pwrite(2) I/O。除 Windows 外，所有支持的操作系统都是默认值。&lt;/p>
&lt;/li>
&lt;/ol>
&lt;blockquote>
&lt;p>pvsync / pvsync2 - 对应的 preadv / pwritev，以及 preadv2 / p writev2&lt;/p>
&lt;/blockquote>
&lt;ol>
&lt;li>
&lt;p>vsync # 使用 readv / writev，主要是会将相邻的 I/O 进行合并&lt;/p>
&lt;/li>
&lt;li>
&lt;p>libaio # Linux 原生的异步 I/O，这也是通常我们这边用的最多的测试盘吞吐和延迟的方法&lt;/p>
&lt;ol>
&lt;li>对于 libaio engine 来说，还需要考虑设置 iodepth&lt;/li>
&lt;/ol>
&lt;/li>
&lt;/ol>
&lt;p>测试多了，就会很悲催的发现，libaio 很容易就把盘给打死，但 sync 这些还需要启动几个线程。。。&lt;/p>
&lt;p>并且对于 fio &amp;ndash;rw=write &amp;ndash;ioengine=XXXX &amp;ndash;filename=fiotest &amp;ndash;direct=1 &amp;ndash;size=2G &amp;ndash;bs=4k &amp;ndash;name=&amp;ldquo;Max throughput&amp;rdquo; &amp;ndash;iodepth=4 命令，sync 引擎测试结果只有 libaio 引擎测试结果的三分之一。&lt;/p>
&lt;h1 id="io-engine引擎-特定参数">I/O engine(引擎) 特定参数&lt;/h1>
&lt;p>官方文档：&lt;a href="https://fio.readthedocs.io/en/latest/fio_doc.html#i-o-engine-specific-parameters">https://fio.readthedocs.io/en/latest/fio_doc.html#i-o-engine-specific-parameters&lt;/a>&lt;/p>
&lt;h1 id="io-depth深度-相关参数">I/O depth(深度) 相关参数&lt;/h1>
&lt;p>官方文档：&lt;a href="https://fio.readthedocs.io/en/latest/fio_doc.html#i-o-depth">https://fio.readthedocs.io/en/latest/fio_doc.html#i-o-depth&lt;/a>&lt;/p>
&lt;p>iodepth=INT # 针对文件保留的 I/O 单元数。 &lt;code>默认值：1&lt;/code>。&lt;/p>
&lt;blockquote>
&lt;p>请注意，将 iodepth 增加到 1 以上不会影响同步 ioengine(使用 verify_async 时的小角度除外)。 甚至异步引擎也可能会施加 OS 限制，从而导致无法实现所需的深度。 在 Linux 上使用 libaio 且未设置 direct = 1 时可能会发生这种情况，因为在该 OS 上缓冲的 I / O 并不异步。 密切注意 fio 输出中的 I / O 深度分布，以验证所达到的深度是否符合预期。&lt;/p>
&lt;/blockquote>
&lt;h1 id="io-rate-相关参数">I/O rate 相关参数&lt;/h1>
&lt;p>官方文档：&lt;a href="https://fio.readthedocs.io/en/latest/fio_doc.html#i-o-rate">https://fio.readthedocs.io/en/latest/fio_doc.html#i-o-rate&lt;/a>&lt;/p>
&lt;h1 id="io-latency">I/O latency&lt;/h1>
&lt;p>官方文档：&lt;a href="https://fio.readthedocs.io/en/latest/fio_doc.html#i-o-latency">https://fio.readthedocs.io/en/latest/fio_doc.html#i-o-latency&lt;/a>&lt;/p>
&lt;h1 id="io-replay">I/O replay&lt;/h1>
&lt;p>官方文档：&lt;a href="https://fio.readthedocs.io/en/latest/fio_doc.html#i-o-replay">https://fio.readthedocs.io/en/latest/fio_doc.html#i-o-replay&lt;/a>&lt;/p>
&lt;h1 id="线程进程job-同步相关参数">线程、进程、Job 同步相关参数&lt;/h1>
&lt;p>官方文档：&lt;a href="https://fio.readthedocs.io/en/latest/fio_doc.html#threads-processes-and-job-synchronization">https://fio.readthedocs.io/en/latest/fio_doc.html#threads-processes-and-job-synchronization&lt;/a>&lt;/p>
&lt;p>thead # 如果指定了此选项，则 fio 将使用 POSIX Threads 的函数 pthread_create(3) 创建线程来创建作业。Fio 默认使用 fork 创建 Job。i.e.使用进程来执行 Job&lt;/p>
&lt;blockquote>
&lt;p>使用 thread 在一定程度上可以节省系统开销&lt;/p>
&lt;/blockquote>
&lt;h1 id="认证参数">认证参数&lt;/h1>
&lt;p>官方文档：&lt;a href="https://fio.readthedocs.io/en/latest/fio_doc.html#verification">https://fio.readthedocs.io/en/latest/fio_doc.html#verification&lt;/a>&lt;/p>
&lt;h1 id="steady-state">Steady state&lt;/h1>
&lt;p>官方文档：&lt;a href="https://fio.readthedocs.io/en/latest/fio_doc.html#steady-state">https://fio.readthedocs.io/en/latest/fio_doc.html#steady-state&lt;/a>&lt;/p>
&lt;h1 id="测量和报告相关参数">测量和报告相关参数&lt;/h1>
&lt;p>官方文档：&lt;a href="https://fio.readthedocs.io/en/latest/fio_doc.html#measurements-and-reporting">https://fio.readthedocs.io/en/latest/fio_doc.html#measurements-and-reporting&lt;/a>&lt;/p>
&lt;h1 id="错误处理相关参数">错误处理相关参数&lt;/h1>
&lt;p>官方文档：&lt;a href="https://fio.readthedocs.io/en/latest/fio_doc.html#error-handling">https://fio.readthedocs.io/en/latest/fio_doc.html#error-handling&lt;/a>&lt;/p>
&lt;p>rwmixwrite=30 # 在混合读写的模式下，写占 30%&lt;/p>
&lt;p>group_reporting # 关于显示结果的，汇总每个进程的信息&lt;/p>
&lt;p>lockmem=1G # 只使用 1g 内存进行测试&lt;/p>
&lt;p>nrfiles=8 # 每个进程生成文件的数量&lt;/p>
&lt;p>numjobs=30 # 本次的测试线程为 30 个&lt;/p></description></item><item><title>Docs: GNU C Library 管理工具</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/x.linux-%E7%AE%A1%E7%90%86/gnu-c-library-%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/x.linux-%E7%AE%A1%E7%90%86/gnu-c-library-%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;p>CentOS 与 Ubuntu 中关于 glibc 的管理工具包的名称不太一样&lt;/p>
&lt;ul>
&lt;li>CentOS 为 glibc-common&lt;/li>
&lt;li>Ubuntu 为 libc-bin、libc-dev-bin&lt;/li>
&lt;/ul>
&lt;h1 id="ldd">ldd&lt;/h1>
&lt;p>这个命令可以显示一个可执行文件所使用的动态链接库。如：&lt;/p>
&lt;pre>&lt;code>[root@centos8 bin]# ldd ls
linux-vdso.so.1 (0x00007ffe2f157000)
libselinux.so.1 =&amp;gt; /lib64/libselinux.so.1 (0x00007f7d953a3000)
libcap.so.2 =&amp;gt; /lib64/libcap.so.2 (0x00007f7d9519d000)
libc.so.6 =&amp;gt; /lib64/libc.so.6 (0x00007f7d94ddb000)
libpcre2-8.so.0 =&amp;gt; /lib64/libpcre2-8.so.0 (0x00007f7d94b57000)
libdl.so.2 =&amp;gt; /lib64/libdl.so.2 (0x00007f7d94953000)
/lib64/ld-linux-x86-64.so.2 (0x00007f7d957f1000)
libpthread.so.0 =&amp;gt; /lib64/libpthread.so.0 (0x00007f7d94733000)
&lt;/code>&lt;/pre>
&lt;h1 id="ldconfig">ldconfig&lt;/h1>
&lt;p>lbconfig 是一个动态链接库的管理命令。可以创建必要的链接并缓存到指定文件中&lt;/p>
&lt;h3 id="配置">配置&lt;/h3>
&lt;p>&lt;strong>/lib64/ld-linux.so.*&lt;/strong> # 运行时链接器/加载器
&lt;strong>/etc/ld.so.conf&lt;/strong> # 从配置文件中指定的目录中搜索库
&lt;strong>/etc/ld.so.conf.d/*&lt;/strong> # 从配置文件中指定的目录中搜索库
&lt;strong>/etc/ld.so.cache&lt;/strong> # 搜索到的库列表被缓存到该文件中&lt;/p>
&lt;h3 id="syntax语法">Syntax(语法)&lt;/h3>
&lt;p>OPTIONS&lt;/p>
&lt;ul>
&lt;li>&lt;strong>-p, &amp;ndash;print-cache&lt;/strong> # 输出当前系统已经加载的动态库&lt;/li>
&lt;/ul></description></item><item><title>Docs: grep</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/x.linux-%E7%AE%A1%E7%90%86/linux-%E6%96%87%E6%9C%AC%E5%A4%84%E7%90%86/grep/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/x.linux-%E7%AE%A1%E7%90%86/linux-%E6%96%87%E6%9C%AC%E5%A4%84%E7%90%86/grep/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;a href="https://man.cx/grep">man 手册&lt;/a>&lt;/p>
&lt;/blockquote>
&lt;p>grep 是文本搜索工具，可以使用正则表达式在文件内查找符合条件的字串行&lt;/p>
&lt;h1 id="syntax语法">Syntax(语法)&lt;/h1>
&lt;p>&lt;strong>grep [OPTIONS] PATTERNS [FILE&amp;hellip;]&lt;/strong>&lt;/p>
&lt;p>grep 根据 PATTERNS(模式) 过滤给定的内容。其实就是使用正则表达式，过滤内容。&lt;/p>
&lt;h2 id="options">OPTIONS：&lt;/h2>
&lt;h3 id="pattern-syntaz模式语法">Pattern Syntaz(模式语法)&lt;/h3>
&lt;p>用于定义过滤时所解析的正则表达式语法&lt;/p>
&lt;ul>
&lt;li>&lt;strong>-E, &amp;ndash;extended-regexp&lt;/strong> # 将 PATTERNS 解释为扩展的正则表达式（ERE，请参见下文）。&lt;/li>
&lt;li>&lt;strong>-P,&amp;ndash;perl-regexp&lt;/strong> # 将 PATTERNS 解释为与 Perl 兼容的正则表达式(PCREs)。与-z（&amp;ndash;null-data）选项结合使用时，此选项是实验性的，并且 grep -P 可能会警告未实现的功能。&lt;/li>
&lt;/ul>
&lt;h3 id="matching-control配置控制">Matching Control(配置控制)&lt;/h3>
&lt;ul>
&lt;li>**-i **# 忽略大小写&lt;/li>
&lt;li>**-v, &amp;ndash;invert-match **# 反向选择，选择没有要匹配的字符串的行&lt;/li>
&lt;/ul>
&lt;h3 id="general-output-control通用输出控制-选项">General Output Control(通用输出控制) 选项&lt;/h3>
&lt;ul>
&lt;li>&lt;strong>-c, &amp;ndash;count&lt;/strong> # 计算找到的符合行的次数&lt;/li>
&lt;li>&lt;strong>&amp;ndash;color=auto&lt;/strong> # 把查找到内容自动表上默认颜色，auto 可改成别的颜色英文&lt;/li>
&lt;li>&lt;strong>-l,&amp;ndash;files-with-matches&lt;/strong> # 在筛选时，只输出文件名。常用来在一堆文件中，筛选指定内容，只查看哪些文件有指定的内容。&lt;/li>
&lt;li>&lt;strong>-o, &amp;ndash;only-matching&lt;/strong> # 仅显示被匹配到的字符串，不显示整行&lt;/li>
&lt;li>&lt;strong>-s, &amp;ndash;no-messages&lt;/strong> # 不显示错误信息&lt;/li>
&lt;/ul>
&lt;h3 id="output-line-prefix-control控制输出行的前缀">Output Line Prefix Control(控制输出行的前缀)&lt;/h3>
&lt;ul>
&lt;li>&lt;strong>-n&lt;/strong> # 顺便输出行号&lt;/li>
&lt;/ul>
&lt;h3 id="context-line-control控制输出内容的上下行">Context Line Control(控制输出内容的上下行)&lt;/h3>
&lt;ul>
&lt;li>&lt;strong>-A NUM, &amp;ndash;after-context=NUM&lt;/strong> # 打印出查找到的行的下面 NUM 行&lt;/li>
&lt;li>&lt;strong>-B NUM, &amp;ndash;before-context=NUM&lt;/strong> # 打印出查找到的行的上面 NUM 行&lt;/li>
&lt;li>&lt;strong>-C NUM, &amp;ndash;context=NUM&lt;/strong> # -A 与 -B 选项的结合体，控制输出内容的 上面 和下面 NUM 行&lt;/li>
&lt;/ul>
&lt;h3 id="file-and-directory-selection文件和目录选择">File and Directory Selection(文件和目录选择)&lt;/h3>
&lt;ul>
&lt;li>&lt;strong>-a, &amp;ndash;text&lt;/strong> # 像对待文本一样处理二进制文件；这等效于&amp;ndash;binary-files = text 选项。&lt;/li>
&lt;li>&lt;strong>-R, &amp;ndash;dereference-recursive&lt;/strong> # 递归地阅读每个目录下的所有文件并进行 grep 操作;该选项相当于-d recurse&lt;/li>
&lt;/ul>
&lt;h2 id="example">EXAMPLE&lt;/h2>
&lt;ul>
&lt;li>查看 accesslog 文件的实时更新，并筛选出不包含两个字符串的行
&lt;ul>
&lt;li>tailf accesslog | grep -vE &amp;lsquo;(miguvideo|mgtv)&amp;rsquo;&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>grep &amp;ndash;color=auto -i R.*h ./boot.log | grep -Evi &amp;ldquo;star|net&amp;rdquo; #不区分大小写搜索 boot.log 文件中包含 Rh 中间含有任意字符的，并且不包含 Star 或 net 的所有行，并以高亮颜色显示搜索的字符串，|表示或的关系，正则表达式扩展内容，选项必须有 E 才能生效。&lt;/li>
&lt;li>grep -i &amp;lsquo;/bin/bash&amp;rsquo; /etc/passwd | sort -n -t: -k3 | tail -1|cut -d: -f1 #取出默认 shell 为 bash 且其 ID 号最大的用户&lt;/li>
&lt;li>grep &amp;ldquo;^#[[:space:]]{1,}[^[:space:]]{1,}&amp;rdquo; /etc/X #取出/etc/x 文件中井号开头后最少一个空白字符后最少一个非空白字符的行&lt;/li>
&lt;li>ifconfig | egrep &amp;ndash;color=auto -n &amp;lsquo;[0-9]{1,3}.[0-9]{1,3}.[0-9]{1,3}.[0-9]{1,3}&amp;rsquo;&lt;/li>
&lt;li>egrep &amp;ndash;color=auto -n &amp;lsquo;[0-9]+.[0-9]+.[0-9]+.[0-9]+&amp;rsquo; #匹配 ifconfig 中的所有 IP 地址，带匹配高亮，带行号（egrep 就是 grep -E）&lt;/li>
&lt;li>egrep &amp;ndash;color=auto -n &amp;lsquo;&amp;lt;[0-9]{2}&amp;gt;.[0-9]+.[0-9]+.[0-9]+&amp;rsquo; #可以搜索第一段是两位数的 IP，比如 10.0.0.0 网段&lt;/li>
&lt;li>grep -i &amp;ndash;color=auto &amp;lsquo;[0-9]+.[0-9]+.[0-9]+.[0-9]+&amp;rsquo; ./interfaces #不适用 egrep 的方法&lt;/li>
&lt;/ul>
&lt;p>应用示例&lt;/p>
&lt;h2 id="筛选---之间的内容">筛选 &lt;code>{{ }}&lt;/code> 之间的内容&lt;/h2>
&lt;pre>&lt;code>hi,hello {{A1}}
{{B0B}}test{{CC_CC}}
@{{D-DD}}
{{E#@EEE}}
&lt;/code>&lt;/pre>
&lt;h3 id="筛选后文本xa">筛选后文本
&lt;/h3>
&lt;p>&lt;strong>cat content.txt | grep -oP &amp;ldquo;(?&amp;lt;={{)(\w|-|#|@)+(?=}})&amp;rdquo;&lt;/strong>&lt;/p>
&lt;pre>&lt;code>A1
B0B
CC_CC
D-DD
E#@EEE
&lt;/code>&lt;/pre>
&lt;p>&lt;strong>cat content.txt | grep -oE &amp;ldquo;{{(\w|-|#|@)+}}&amp;rdquo;&lt;/strong>&lt;/p>
&lt;p>&lt;strong>cat content.txt | grep -oP &amp;ldquo;{{(\w|-|#|@)+}}&amp;rdquo;&lt;/strong>&lt;/p>
&lt;pre>&lt;code>{{A1}}
{{B0B}}
{{CC_CC}}
{{D-DD}}
{{E#@EEE}}
&lt;/code>&lt;/pre></description></item><item><title>Docs: Httperf # Web 压力测试</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/x.linux-%E7%AE%A1%E7%90%86/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96-%E4%B8%8E-%E6%95%85%E9%9A%9C%E5%A4%84%E7%90%86/%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95/httperf-#-web-%E5%8E%8B%E5%8A%9B%E6%B5%8B%E8%AF%95/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/x.linux-%E7%AE%A1%E7%90%86/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96-%E4%B8%8E-%E6%95%85%E9%9A%9C%E5%A4%84%E7%90%86/%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95/httperf-#-web-%E5%8E%8B%E5%8A%9B%E6%B5%8B%E8%AF%95/</guid><description>
&lt;h1 id="heading">&lt;/h1>
&lt;p>Web 压力测试 - Httperf&lt;/p>
&lt;p>Httperf 比 ab 更强大，能测试出 web 服务能承载的最大服务量及发现潜在问题；比如：内存使用、稳定性。最大优势：可以指定规律进行压力测试，模拟真实环境。&lt;/p>
&lt;p>下载：&lt;a href="http://code.google.com/p/httperf/downloads/list">http://code.google.com/p/httperf/downloads/list&lt;/a>&lt;/p>
&lt;ol>
&lt;li>[root@localhost ~]# tar zxvf httperf-0.9.0.tar.gz&lt;/li>
&lt;li>[root@localhost ~]# cd httperf-0.9.0&lt;/li>
&lt;li>[root@localhost httperf-0.9.0]# ./configure&lt;/li>
&lt;li>[root@localhost httperf-0.9.0]# make &amp;amp;&amp;amp; make install&lt;/li>
&lt;li>[root@localhost ~]# httperf &amp;ndash;hog &amp;ndash;server=192.168.0.202 &amp;ndash;uri=/index.html &amp;ndash;num-conns=10000 &amp;ndash;wsess=10,10,0.1&lt;/li>
&lt;/ol>
&lt;p>参数说明：&lt;/p>
&lt;ul>
&lt;li>--hog：让 httperf 尽可能多产生连接，httperf 会根据硬件配置，有规律的产生访问连接&lt;/li>
&lt;li>--num-conns：连接数量，总发起 10000 请求&lt;/li>
&lt;li>--wsess：用户打开网页时间规律模拟，第一个 10 表示产生 10 个会话连接，第二个 10 表示每个会话连接进行 10 次请求，0.1 表示每个会话连接请求之间的间隔时间 / s&lt;/li>
&lt;/ul></description></item><item><title>Docs: inode 已满解决方法</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/x.linux-%E7%AE%A1%E7%90%86/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96-%E4%B8%8E-%E6%95%85%E9%9A%9C%E5%A4%84%E7%90%86/%E6%95%85%E9%9A%9C%E5%A4%84%E7%90%86%E6%A1%88%E4%BE%8B/inode-%E5%B7%B2%E6%BB%A1%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/x.linux-%E7%AE%A1%E7%90%86/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96-%E4%B8%8E-%E6%95%85%E9%9A%9C%E5%A4%84%E7%90%86/%E6%95%85%E9%9A%9C%E5%A4%84%E7%90%86%E6%A1%88%E4%BE%8B/inode-%E5%B7%B2%E6%BB%A1%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/</guid><description>
&lt;h2 id="问题描述">问题描述&lt;/h2>
&lt;p>在 Linux 系统的云服务器 ECS 实例内创建文件时，出现类似如下空间不足的提示。&lt;/p>
&lt;pre>&lt;code>No space left on device …
&lt;/code>&lt;/pre>
&lt;h2 id="问题原因">问题原因&lt;/h2>
&lt;p>导致该问题的可能原因如下所示：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>磁盘分区空间使用率达到百分之百。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>磁盘分区 inode 使用率达到百分之百。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>存在僵尸文件。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>挂载点覆盖。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h2 id="解决方案">解决方案&lt;/h2>
&lt;blockquote>
&lt;p>阿里云提醒您：&lt;/p>
&lt;/blockquote>
&lt;p>要解决该问题，请根据不同的问题原因，通过以下方式进行处理：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>分区容量满&lt;/p>
&lt;/li>
&lt;li>
&lt;p>inode 容量满&lt;/p>
&lt;/li>
&lt;li>
&lt;p>修改 inode 数量&lt;/p>
&lt;/li>
&lt;li>
&lt;p>僵尸文件分析删除&lt;/p>
&lt;/li>
&lt;li>
&lt;p>挂载点覆盖&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h3 id="分区容量满的处理">分区容量满的处理&lt;/h3>
&lt;ul>
&lt;li>
&lt;p>登录服务器，使用&lt;code>df -h&lt;/code>命令查看磁盘使用率，其中的&lt;strong>Mounted on&lt;/strong>指挂载的目录。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>进入根目录，执行 &lt;code>du -sh *&lt;/code> 指令，逐级查看哪个目录占用磁盘空间较大，进入相应的目录，直到找到最精确的文件或目录。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>最后，结合业务情况等判断对相关文件或目录进行删除，或者购买更大的数据盘分担处理。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h3 id="inode-容量满的处理">inode 容量满的处理&lt;/h3>
&lt;p>通过如下操作，解决 inode 容量满的问题。&lt;/p>
&lt;p>&lt;strong>查询 inode 使用情况&lt;/strong>&lt;/p>
&lt;p>Linux 的 inode 节点中，记录了文件的类型、大小、权限、所有者、文件连接的数目、创建时间与更新时间等重要的信息，还有一个比较重要的内容就是指向数据块的指针。一般情况不需要特殊配置，如果存放文件很多，则需要配置。有时磁盘空间有剩余但是不能存放文件，可能是由于 inode 耗尽所致。&lt;/p>
&lt;ol>
&lt;li>
&lt;p>执行&lt;code>df -i&lt;/code>命令，可以查询 inode 的使用情况。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>如果 inode 使用率达到或者接近 100%，可以通过以下两种方式进行处理：&lt;/p>
&lt;/li>
&lt;li>
&lt;p>清除 inode 占用高的文件或者目录。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>修改 inode 数量。&lt;/p>
&lt;/li>
&lt;/ol>
&lt;p>&lt;strong>清除 inode 占用高的文件或者目录&lt;/strong>&lt;/p>
&lt;p>如果不方便格式化磁盘以增加 inode 数量，可以参考以下步骤，清理 inode 占用量高的文件或者目录。&lt;/p>
&lt;ol>
&lt;li>
&lt;p>登录服务器，执行以下命令，分析根目录下的每个二级目录下有多少个文件。&lt;code>for i in /*; do echo $i; find $i | wc -l; done&lt;/code>。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>然后，逐层进入 inode 占用最高的目录，继续执行上述指令，逐步定位占用过高空间的文件或目录，最后进行相应清理。&lt;/p>
&lt;/li>
&lt;/ol>
&lt;p>&lt;strong>修改 inode 数量&lt;/strong>&lt;/p>
&lt;p>如果不允许清理磁盘中的文件，或者清理后 inode 使用率仍然较高，则需要通过以下步骤，增加 inode 节点数量。&lt;/p>
&lt;blockquote>
&lt;p>&lt;strong>说明&lt;/strong>：inode 的调整需要重新格式化磁盘，请确保数据已经得到有效备份后，再进行以下操作。&lt;/p>
&lt;/blockquote>
&lt;ol>
&lt;li>
&lt;p>执行以下命令，卸载系统文件。&lt;code>umount /home&lt;/code>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>执行以下命令，重新建立文件系统，指定 inode 节点数。&lt;code>mkfs.ext3 /dev/xvdb -N 1638400&lt;/code>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>执行以下命令，修改 fstab 文件。&lt;code>vim /etc/fstab&lt;/code>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>执行以下命令，查看修改后的 inode 节点数。&lt;code>dumpe2fs -h /dev/xvdb | grep node&lt;/code>。&lt;/p>
&lt;/li>
&lt;/ol>
&lt;h3 id="僵尸文件分析与删除">僵尸文件分析与删除&lt;/h3>
&lt;p>如果磁盘和 inode 都没有问题，则需要查看是否存在未被清除句柄的僵尸文件。这些文件实际上已经被删除，但是有服务程序在使用这些文件，导致这些文件一直被占用，无法释放磁盘空间。如果这些文件过多，会占用很大的磁盘空间。参考以下步骤查看并删除僵尸文件。&lt;/p>
&lt;ol>
&lt;li>
&lt;p>远程登录服务器。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>执行以下命令，安装 lsof。&lt;code>yum install lsof -y&lt;/code>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>执行以下命令，查看僵尸文件占用情况。&lt;code>lsof |grep delete | more&lt;/code>系统显示类似如下。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>如果僵尸文件过多，会占用很大的磁盘空间。可以通过以下方法释放句柄，以清除僵尸文件。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>重启服务器，验证效果。重启服务器，系统会退出现有的进程，开机后重新加载。该过程会释放调用的 deleted 文件的句柄。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>根据&lt;code>lsof&lt;/code>命令列出的 pid 进程号，使用&lt;code>kill&lt;/code>命令正常停止或结束占用这些文件的服务进程。&lt;/p>
&lt;/li>
&lt;/ol>
&lt;h3 id="挂载点覆盖">挂载点覆盖&lt;/h3>
&lt;p>先取消磁盘挂载，再检查原挂载目录下的空间占用情况。&lt;/p>
&lt;h2 id="适用于">适用于&lt;/h2>
&lt;ul>
&lt;li>云服务器 ECS&lt;/li>
&lt;/ul>
&lt;p>find / -xdev -printf &amp;lsquo;%h\n&amp;rsquo; | sort | uniq -c | sort -k 1 -n&lt;/p>
&lt;p>今天 login server 的一个网站，发现 login 后没有生成 session。根据以往经验，一般是空间已满导致 session 文件生成失败。&lt;/p>
&lt;pre>&lt;code>df -h
Filesystem Size Used Avail Use% Mounted on
/dev/mapper/dev01-root 75G 58G 14G 82% /
udev 2.0G 4.0K 2.0G 1% /dev
tmpfs 396M 292K 396M 1% /run
none 5.0M 0 5.0M 0% /run/lock
none 2.0G 4.0K 2.0G 1% /run/shm
/dev/sda1 228M 149M 68M 69% /boot
&lt;/code>&lt;/pre>
&lt;p>空间剩余 14G，可以排除空间已满的情况。导致文件生成失败还有另一个原因，就是文件索引节点 inode 已满。&lt;/p>
&lt;pre>&lt;code>df -i
Filesystem Inodes IUsed IFree IUse% Mounted on
/dev/mapper/dev01-root 4964352 4964352 0 100% /
udev 503779 440 503339 1% /dev
tmpfs 506183 353 505830 1% /run
none 506183 5 506178 1% /run/lock
none 506183 2 506181 1% /run/shm
/dev/sda1 124496 255 124241 1% /boot
&lt;/code>&lt;/pre>
&lt;p>inodes 占用 100%，果然是这个问题。&lt;/p>
&lt;p>解决方法：删除无用的临时文件，释放 inode。&lt;/p>
&lt;p>查找发现 /tmp 目录下有很多 sess_xxxxx 的 session 临时文件。&lt;/p>
&lt;p>ls -lt /tmp | wc -l4011517&lt;/p>
&lt;p>进入/tmp 目录，执行 find -exec 命令&lt;/p>
&lt;p>sudo find /tmp -type f -exec rm {} ;&lt;/p>
&lt;p>如果使用 rm *，有可能因为文件数量太多而出现 Argument list too long 错误，关于 Argument list too long 错误可以参考《linux Argument list too long 错误解决方法》&lt;/p>
&lt;p>除了/tmp 的临时文件外，0 字节的文件也会占用 inode，应该也释放。&lt;/p>
&lt;p>遍历寻找 0 字节的文件，并删除。&lt;/p>
&lt;p>sudo find /home -type f -size 0 -exec rm {} ;&lt;/p>
&lt;p>删除后，inode 的使用量减少为 19%，可以正常使用了。&lt;/p>
&lt;pre>&lt;code>df -i
Filesystem Inodes IUsed IFree IUse% Mounted on
/dev/mapper/dev01-root 4964352 940835 4023517 19% /
udev 503779 440 503339 1% /dev
tmpfs 506183 353 505830 1% /run
none 506183 5 506178 1% /run/lock
none 506183 2 506181 1% /run/shm
/dev/sda1 124496 255 124241 1% /boot
&lt;/code>&lt;/pre></description></item><item><title>Docs: ip 命令行工具</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/x.linux-%E7%AE%A1%E7%90%86/linux-%E7%BD%91%E7%BB%9C%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/iproute-%E5%B7%A5%E5%85%B7%E5%8C%85/ip-%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%B7%A5%E5%85%B7/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/x.linux-%E7%AE%A1%E7%90%86/linux-%E7%BD%91%E7%BB%9C%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/iproute-%E5%B7%A5%E5%85%B7%E5%8C%85/ip-%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%B7%A5%E5%85%B7/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://man7.org/linux/man-pages/man8/ip.8.html">Manual(手册),ip(8)&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>ip 命令行工具可以控制各种 &lt;strong>Object(对象)&lt;/strong>，这些对象包括：路由、网络设备、接口、隧道 等&lt;/p>
&lt;h1 id="syntax语法">Syntax(语法)&lt;/h1>
&lt;p>&lt;strong>ip [Global OPTIONS] OBJECT [COMMAND]&lt;/strong>&lt;/p>
&lt;p>ip 程序的语法有点复杂，对 Object 控制的命令中，有非常多的参数，不像普通命令一样，把参数称为 FLAGS 或 OPTIONS，且都是以 &lt;code>-&lt;/code> 或者 &lt;code>--&lt;/code> 符号开头的。&lt;/p>
&lt;p>这里我们使用 **大写字母 **来描述 &lt;strong>一个参数&lt;/strong> 或 &lt;strong>一个具体的值&lt;/strong>。参数中还可以包含一个或多个其他参数，每个参数的值，同样使用大写字母表示。&lt;/p>
&lt;p>在后面的文章中，凡是这种复杂的参数，都使用这类格式表示：&lt;code>参数 := 参数 | 值&lt;/code>，这就有点像编程中初始化&lt;strong>变量&lt;/strong>一样。在这里就是等于是定义一个参数，并为参数赋值。比如 &lt;code>ip link&lt;/code> 命令中，就有这种样子的写法：
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/us4bal/1638423450051-14c93955-fbe9-425a-9d96-eaf14b140241.png" alt="image.png">
这里面有一个 IFADDR 表示一个参数，IFADDR 参数又是由 PREFIX、SCOPE-ID 等参数组成，而 SCOPE-ID 则表示有具体含义的值。其实，本质上，命令行工具的参数，就是要传入代码的 Function 中的的实际参数。&lt;/p>
&lt;h2 id="global-opitons">Global OPITONS&lt;/h2>
&lt;p>注意：这里的 OPTIONS 是全局选项，要用在 ip 与 OBJECT 之间，比如：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>root@lichenhao:~# ip -c route
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>default via 172.19.42.1 dev ens3 proto static metric &lt;span style="color:#ae81ff">100&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>10.19.0.0/24 dev docker0 proto kernel scope link src 10.19.0.1 linkdown
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>172.19.42.0/24 dev ens3 proto kernel scope link src 172.19.42.248 metric &lt;span style="color:#ae81ff">100&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>root@lichenhao:~# ip route -c
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Command &lt;span style="color:#e6db74">&amp;#34;-c&amp;#34;&lt;/span> is unknown, try &lt;span style="color:#e6db74">&amp;#34;ip route help&amp;#34;&lt;/span>.
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>可以看到，-c 选项用在 OBJECT 后面是无效的。&lt;/p>
&lt;ul>
&lt;li>&lt;strong>-d, -details&lt;/strong> # 输出更详细的信息,主要显示该网络设备的类型等&lt;/li>
&lt;li>&lt;strong>-f, -family &lt;!-- raw HTML omitted -->&lt;/strong> # 指定要使用的协议族。协议族标识符可以是 inet、inet6、bridge、mpls、link 中的一种。如果不存在此选项，则从其他参数中猜测协议族。如果命令行的其余部分没有提供足够的信息来猜测该系列，则 ip 会退回到默认值，通常是 inet 或任何其他值。链接是一个特殊的系列标识符，表示不涉及网络协议。
&lt;ul>
&lt;li>&lt;strong>-4&lt;/strong> # &lt;code>-family inet&lt;/code> 的简写&lt;/li>
&lt;li>&lt;strong>-6&lt;/strong> # &lt;code>-family inet6&lt;/code> 的简写&lt;/li>
&lt;li>&lt;strong>-B&lt;/strong> # &lt;code>-family bridge&lt;/code> 的简写&lt;/li>
&lt;li>&lt;strong>-M&lt;/strong> # &lt;code>-family mpls&lt;/code> 的简写&lt;/li>
&lt;li>&lt;strong>-0&lt;/strong> # &lt;code>-family link&lt;/code> 的简写&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>**-o, -oneline **# 在一行中输出每条记录，并用&amp;rsquo;&amp;lsquo;字符替换换行符。在使用 wc(1) 对记录进行计数 或 对输出进行 grep(1) 时，这非常方便。
&lt;ul>
&lt;li>注意，使用 -o 选项时，不会打印没有 IP 地址的网络设备&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>-s, -stats&lt;/strong> # 显示更详细的信息,主要显示该网络设备的接收、发送、错误、丢弃的数据包信息&lt;/li>
&lt;/ul>
&lt;h2 id="arguments">ARGUMENTS&lt;/h2>
&lt;p>&lt;strong>OBJECT := { link | address | addrlabel | route | rule | neigh | ntable | tunnel | tuntap | maddress | mroute | mrule | monitor | xfrm | netns | l2tp | tcp_metrics | token | macsec | vrf | mptcp }&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>注意：OBJECT(对象)选项用来指定 ip 程序想要控制的网络栈中的实体。&lt;/li>
&lt;li>比如：
&lt;ul>
&lt;li>link(链路)&lt;/li>
&lt;li>address(地址)&lt;/li>
&lt;li>route(路由条目)&lt;/li>
&lt;li>等&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>ip 命令可以对这些网络对象进行相关操作，选定 object 后，后面执行相关 command 进行操作&lt;/li>
&lt;/ul>
&lt;h2 id="command">COMMAND&lt;/h2>
&lt;p>主要都是对各个 Object 的 add | delete | set | show | list 等类似增删改查的命令，还有各个 Object 独自的子命令&lt;/p>
&lt;h1 id="object-命令详解">OBJECT 命令详解&lt;/h1>
&lt;h2 id="link--网络设备配置">link # 网络设备配置&lt;/h2>
&lt;p>详见：
[link](✏IT 学习笔记/📄1.操作系统/X.Linux%20 管理/Linux%20 网络管理工具/Iproute%20 工具包/ip%20 命令行工具/link.md 命令行工具/link.md)&lt;/p>
&lt;h2 id="address--ipv4-或-ipv6-地址管理">address # IPv4 或 IPv6 地址管理&lt;/h2>
&lt;h3 id="syntax语法-1">Syntax(语法)&lt;/h3>
&lt;p>&lt;strong>ip [OPTIONS] address [COMMAND]&lt;/strong>&lt;/p>
&lt;p>&lt;strong>COMMAND：&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>add | del | change | replace | show&lt;/li>
&lt;li>save | flush&lt;/li>
&lt;li>showdump | restore&lt;/li>
&lt;/ul>
&lt;h3 id="example">EXAMPLE&lt;/h3>
&lt;ul>
&lt;li>简略显示网络设备信息
&lt;ul>
&lt;li>ip -4 -o a s&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;!-- raw HTML omitted -->
&lt;pre>&lt;code>root@lichenhao:~/projects/kubeappsops# ip -4 -o a s
1: lo inet 127.0.0.1/8 scope host lo\ valid_lft forever preferred_lft forever
2: ens3 inet 172.19.42.248/24 brd 172.19.42.255 scope global ens3\ valid_lft forever preferred_lft forever
3: docker0 inet 172.17.0.1/16 brd 172.17.255.255 scope global docker0\ valid_lft forever preferred_lft forever
&lt;/code>&lt;/pre>
&lt;ul>
&lt;li>筛选满足 IP 地址格式的网卡信息
&lt;ul>
&lt;li>ip a s up | egrep &amp;ndash;color=auto -n &amp;lsquo;[0-9]+.[0-9]+.[0-9]+.[0-9]+&amp;rsquo;&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>显示[已经启动的]网卡 ip 信息,类似于 ifconfig 命令,可简写为 ip a s up
&lt;ul>
&lt;li>ip address show [up]&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>以详细信息显示 ens33 的网卡关于地址的信息，包括收发包的状态等
&lt;ul>
&lt;li>ip -s addr show ens33&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>给 eth0 网卡添加一个临时的 IP 地址
&lt;ul>
&lt;li>ip addr add 192.168.0.1/24 dev eth0&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>ip addr add 10.0.0.101/24 broadcast 10.0.0.255 dev eth0 label eth0:0&lt;/li>
&lt;/ul>
&lt;p>Note：在 ip address show 命令中列出的网络设备，可能包含这样的名称 eth0.2@eth0 。其实设备名就是 eth0.2(其中 2 表示 vlan 号)，至于后面的&lt;code>@&lt;/code>则是一个关联同等级网络设备的符号，表示 eth0.2 这个设备是与 eth0 关联的。如果是 bridge 和 bond 之类的网络设备，则没有&lt;code>@&lt;/code>符号，因为和 bridge 或者 bond 关联的设备都是属于下级设备。&lt;/p>
&lt;h2 id="route--路由条目管理">route # 路由条目管理&lt;/h2>
&lt;p>详见：
[rule 与 route](✏IT 学习笔记/📄1.操作系统/X.Linux%20 管理/Linux%20 网络管理工具/Iproute%20 工具包/ip%20 命令行工具/rule%20 与%20route.md 命令行工具/rule 与 route.md)&lt;/p>
&lt;h2 id="rule--路由策略数据库管理">rule # 路由策略数据库管理&lt;/h2>
&lt;p>详见：
[rule 与 route](✏IT 学习笔记/📄1.操作系统/X.Linux%20 管理/Linux%20 网络管理工具/Iproute%20 工具包/ip%20 命令行工具/rule%20 与%20route.md 命令行工具/rule 与 route.md)&lt;/p>
&lt;h2 id="neighbor-管理-arp-或-ndisc-缓存条目">neighbor #管理 ARP 或 NDISC 缓存条目&lt;/h2>
&lt;p>&lt;strong>ip [OPTIONS] neighbor [COMMAND]&lt;/strong>&lt;/p>
&lt;p>EXAMPLE&lt;/p>
&lt;ol>
&lt;li>ip neighbor list # 显示邻居和 arp 表，即学到的 IP 地址，可显示该 IP 是否可达等状态，以及是从哪个端口学到的&lt;/li>
&lt;li>ip neigh flush dev eth0 # 移除 eth0 设备上的邻居条目（i.e.清空 arp）&lt;/li>
&lt;/ol>
&lt;h2 id="tuntap--tuntap-网络设备的管理">tuntap # tun/tap 网络设备的管理&lt;/h2>
&lt;p>&lt;strong>ip tuntap COMMAND mode { tun | tap } [ dev PHYS_DEV ] [ user USER ] [ group GROUP ] [ one_queue ] [ pi ] [ vnet_hdr ] [ multi_queue ] [ name NAME ]&lt;/strong>&lt;/p>
&lt;p>EXAMPLE&lt;/p>
&lt;ol>
&lt;li>ip tuntap add dev vnet3 mode tun # 创建一个 tun 类型，名为 vnet3 的网络设备&lt;/li>
&lt;/ol>
&lt;h2 id="netns--进程网络命名空间管理">netns # 进程网络命名空间管理&lt;/h2>
&lt;p>&lt;strong>ip [OPTIONS] netns [COMMAND]&lt;/strong>
是在 linux 中提供网络虚拟化的一个项目，使用 netns 网络空间虚拟化可以在本地虚拟化出多个网络环境，目前 netns 在 lxc 容器中被用来为容器提供网络(注意:可以查看 openstack、docker 各个节点上的虚拟网络设备并进行操作)。&lt;/p>
&lt;p>COMMAND
add、delete、set、list 增删改查通用命令&lt;/p>
&lt;p>EXAMPLE&lt;/p>
&lt;ul>
&lt;li>ip netns add r1 #创建名字为 r1 的 namespace&lt;/li>
&lt;li>ip netns list #列出 net namespace，显示名称&lt;/li>
&lt;/ul>
&lt;p>identify&lt;/p>
&lt;p>pids&lt;/p>
&lt;p>exec&lt;/p>
&lt;p>**ip netns exec NAME COMMAND&amp;hellip;. **# 对 NAME 这个 namesapce 执行 COMMAND 命令&lt;/p>
&lt;p>EXAMPLE&lt;/p>
&lt;ul>
&lt;li>ip netns exec r1 bash #进入 r1 这个 namesapce 的空间中，相当于启动了一个单独的关于该 namespace 的 shell，可以使用 exit 退出&lt;/li>
&lt;li>ip netns exec r1 ip a s #显示 r1 这个 namespace 的网路信息&lt;/li>
&lt;li>ip netns exec r1 ip link set veth1.1 name eth0 #设定 r1 这个 namespace 中的 veth1.1 网卡的名字为 eth0&lt;/li>
&lt;/ul>
&lt;p>monitor&lt;/p></description></item><item><title>Docs: iperf 网络性能测量和调整工具</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/x.linux-%E7%AE%A1%E7%90%86/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96-%E4%B8%8E-%E6%95%85%E9%9A%9C%E5%A4%84%E7%90%86/%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95/iperf-%E7%BD%91%E7%BB%9C%E6%80%A7%E8%83%BD%E6%B5%8B%E9%87%8F%E5%92%8C%E8%B0%83%E6%95%B4%E5%B7%A5%E5%85%B7/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/x.linux-%E7%AE%A1%E7%90%86/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96-%E4%B8%8E-%E6%95%85%E9%9A%9C%E5%A4%84%E7%90%86/%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95/iperf-%E7%BD%91%E7%BB%9C%E6%80%A7%E8%83%BD%E6%B5%8B%E9%87%8F%E5%92%8C%E8%B0%83%E6%95%B4%E5%B7%A5%E5%85%B7/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://iperf.fr/">官网&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>在 server 端监听某个端口，然后 client 用同样的 iperf 访问服务端，来进行性能测试&lt;/p>
&lt;p>所以该工具需要在两台设备之间一同使用，其中一台作为服务端，另外一台作为客户端，两端互相通信，才可测试网络性能。而命令行的 OPTIONS 也是分为全局、服务端特定、客户端特定 这三类&lt;/p>
&lt;h1 id="syntax语法">Syntax(语法)&lt;/h1>
&lt;p>&lt;strong>iperf3 &amp;lt;-s | -c HOST&amp;gt; [OPTIONS]&lt;/strong>&lt;/p>
&lt;p>&lt;strong>通用选项&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>&lt;strong>-p, &amp;ndash;port&lt;/strong> # 指定服务端监听的端口或者客户端要连接的端口&lt;/li>
&lt;li>&lt;strong>-f, &amp;ndash;format [kmgKMG]&lt;/strong> # 指定输出格式。可以是：Kbits, Mbits, KBytes, MBytes&lt;/li>
&lt;li>&lt;strong>-i, &amp;ndash;interval&lt;/strong> # 指定每次带宽报告间隔的秒数。i.e.每隔几秒输出一次数据。默认每 1 秒报告一次&lt;/li>
&lt;li>-F, &amp;ndash;file name # xmit/recv the specified file&lt;/li>
&lt;li>-A, &amp;ndash;affinity n/n,m # set CPU affinity&lt;/li>
&lt;li>-B, &amp;ndash;bind &lt;!-- raw HTML omitted --> # bind to a specific interface&lt;/li>
&lt;li>-V, &amp;ndash;verbose # more detailed output&lt;/li>
&lt;li>-J, &amp;ndash;json # output in JSON format&lt;/li>
&lt;li>--logfile f # send output to a log file&lt;/li>
&lt;li>--forceflush # force flushing output at every interval&lt;/li>
&lt;li>-d, &amp;ndash;debug # emit debugging output&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>服务端的特定选项&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>&lt;strong>-s, &amp;ndash;server&lt;/strong> # 在服务器模式下运行 iperf3，默认程序监听在 5201 端口上&lt;/li>
&lt;li>&lt;strong>-D, &amp;ndash;daemon&lt;/strong> # 以守护进程的形式运行服务端&lt;/li>
&lt;li>-I, &amp;ndash;pidfile file # write PID file&lt;/li>
&lt;li>-1, &amp;ndash;one-off # handle one client connection then exit&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>客户端的特定选项&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>&lt;strong>-c, &amp;ndash;client &lt;!-- raw HTML omitted -->&lt;/strong> # 在客户端模式下运行 iperf3，并连接到指定的服务端主机 HOST&lt;/li>
&lt;li>&lt;strong>-u, &amp;ndash;udp&lt;/strong> # 使用 UPD 模式进行测试。默认为 TCP&lt;/li>
&lt;li>&lt;strong>-b, &amp;ndash;bandwidth &lt;!-- raw HTML omitted -->&lt;/strong> # 指定目标带宽上限，单位是 bits/s（0 表示无限制）（UDP 默认为 1 Mbit / sec，TCP 无限制）
&lt;ul>
&lt;li>该选项为每个线程的带宽上限，比如我如果 -P 选项为 2，-b 为 100M ，那么当前测试每个线程的带宽上限为 100M，总上限 200M&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>--fq-rate #[KMG]enable fair-queuing based socket pacing in bits/sec (Linux only)&lt;/li>
&lt;li>&lt;strong>-t, &amp;ndash;time&lt;/strong> # 指定传输数据的总时间。(默认为 10 秒)&lt;/li>
&lt;li>&lt;strong>-n, &amp;ndash;bytes [KMG]&lt;/strong> # 要传输的字节数 (不可与 -t 选项同用)&lt;/li>
&lt;li>-k, &amp;ndash;blockcount [KMG] # number of blocks (packets) to transmit (instead of -t or -n)&lt;/li>
&lt;li>-l, &amp;ndash;len [KMG] # length of buffer to read or write (default 128 KB for TCP, dynamic or 1 for UDP)&lt;/li>
&lt;li>--cport &lt;!-- raw HTML omitted --> # bind to a specific client port (TCP and UDP, default: ephemeral port)&lt;/li>
&lt;li>&lt;strong>-P, &amp;ndash;parallel &lt;!-- raw HTML omitted -->&lt;/strong> # 并发数&lt;/li>
&lt;li>-R, &amp;ndash;reverse # run in reverse mode (server sends, client receives)&lt;/li>
&lt;li>-w, &amp;ndash;window [KMG] # set window size / socket buffer size&lt;/li>
&lt;li>-C, &amp;ndash;congestion &lt;!-- raw HTML omitted --> #set TCP congestion control algorithm (Linux and FreeBSD only)&lt;/li>
&lt;li>-M, &amp;ndash;set-mss # set TCP/SCTP maximum segment size (MTU - 40 bytes)&lt;/li>
&lt;li>-N, &amp;ndash;no-delay # set TCP/SCTP no delay, disabling Nagle&amp;rsquo;s Algorithm&lt;/li>
&lt;li>-4, &amp;ndash;version4 only use IPv4&lt;/li>
&lt;li>-6, &amp;ndash;version6 only use IPv6&lt;/li>
&lt;li>-S, &amp;ndash;tos N set the IP &amp;rsquo;type of service'&lt;/li>
&lt;li>-L, &amp;ndash;flowlabel N set the IPv6 flow label (only supported on Linux)&lt;/li>
&lt;li>-Z, &amp;ndash;zerocopy use a &amp;lsquo;zero copy&amp;rsquo; method of sending data&lt;/li>
&lt;li>-O, &amp;ndash;omit N omit the first n seconds&lt;/li>
&lt;li>-T, &amp;ndash;title str prefix every output line with this string&lt;/li>
&lt;li>--get-server-output get results from server&lt;/li>
&lt;li>--udp-counters-64bit use 64-bit counters in UDP test packets&lt;/li>
&lt;/ul>
&lt;h1 id="应用实例">应用实例&lt;/h1>
&lt;h2 id="基础用法">基础用法&lt;/h2>
&lt;p>服务端命令：iperf3 -s
客户端命令：iperf3 -c 10.10.100.250&lt;/p>
&lt;p>这时候服务端的 iperf3 程序会监听在 5201 端口上，客户端会访问服务端(这里 ip 是 10.10.100.250)的 2501 端口进行网络测试，测试效果如图
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/fdemaq/1616164267994-3d8e4e2d-0c26-4b52-8054-12aeac917398.png" alt="">
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/fdemaq/1616164268013-f44eee21-25f2-48a5-acad-07b32cf7af7a.png" alt="">
客户端每秒会往服务端发送一次数据，Interval 表示时间间隔，Transfer 表示传输的数据量，Bandwidth 表示带宽的大小，Retr 表示重传次数&lt;/p>
&lt;p>在客户端的最后两行表示 10 秒钟的传送的总数据量，以及平均带宽，第一行是发送的，第二行是接收的。这次测试结果就是两台服务器之间最大带宽是 20G&lt;/p>
&lt;h2 id="查看网络丢包率和延迟">查看网络丢包率和延迟&lt;/h2>
&lt;p>服务端命令：iperf3 -s
客户端命令：iperf3 -c 10.10.100.250 -u -b 10M -t 10 -i 1 -P 100
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/fdemaq/1616164268023-89190ba4-c7a7-4587-b4f7-389086f5d465.png" alt="">
Jitter 表示抖动 i.e.数据包延迟时间。Lost/Total Datagrams 表示“丢失/总数据包”的数量，扩内的百分比为丢包率。&lt;/p>
&lt;h2 id="吞吐测试">吞吐测试&lt;/h2>
&lt;p>服务端命令：iperf3 -s -i 1 -p 10000
客户端命令：iperf3 -c 172.19.42.221 -p 10000 -b 1G -t 15 -P 2&lt;/p>
&lt;pre>&lt;code>[ ID] Interval Transfer Bandwidth Retr
[ 4] 0.00-15.00 sec 781 MBytes 437 Mbits/sec 4856 sender
[ 4] 0.00-15.00 sec 779 MBytes 436 Mbits/sec receiver
[ 6] 0.00-15.00 sec 876 MBytes 490 Mbits/sec 7074 sender
[ 6] 0.00-15.00 sec 874 MBytes 489 Mbits/sec receiver
[SUM] 0.00-15.00 sec 1.62 GBytes 927 Mbits/sec 11930 sender
[SUM] 0.00-15.00 sec 1.61 GBytes 925 Mbits/sec receiver
&lt;/code>&lt;/pre>
&lt;p>TCP 吞吐(带宽)大概为 900+M，也就是千兆基本 能跑慢&lt;/p></description></item><item><title>Docs: Iproute 工具包</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/x.linux-%E7%AE%A1%E7%90%86/linux-%E7%BD%91%E7%BB%9C%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/iproute-%E5%B7%A5%E5%85%B7%E5%8C%85/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/x.linux-%E7%AE%A1%E7%90%86/linux-%E7%BD%91%E7%BB%9C%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/iproute-%E5%B7%A5%E5%85%B7%E5%8C%85/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>官方文档：&lt;a href="https://wiki.linuxfoundation.org/networking/iproute2">https://wiki.linuxfoundation.org/networking/iproute2&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Iproute2">Wiki,Iproute2&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>Iprtoue2 是一组应用程序的集合，用于管理 Linux 网络栈。可以控制、监控 LInux 内核中网络栈的各个方面，包括路由、网络接口、隧道、流量控制、与网络相关的设备驱动程序。&lt;/p>
&lt;p>iproute2 基于 Linux 的 &lt;a href="https://www.yuque.com/go/doc/44482585">Netlink 接口&lt;/a> 与 LInux 内核通信，以实现网络栈管理功能。&lt;/p>
&lt;h2 id="该工具包包含如下工具">该工具包包含如下工具&lt;/h2>
&lt;ol>
&lt;li>
&lt;p>arpd&lt;/p>
&lt;/li>
&lt;li>
&lt;p>bridge # 显示或操纵 Linux 网桥 地址和设备&lt;/p>
&lt;/li>
&lt;li>
&lt;p>cbq&lt;/p>
&lt;/li>
&lt;li>
&lt;p>ctstat&lt;/p>
&lt;/li>
&lt;li>
&lt;p>devlink&lt;/p>
&lt;/li>
&lt;li>
&lt;p>genl&lt;/p>
&lt;/li>
&lt;li>
&lt;p>ifcfg&lt;/p>
&lt;/li>
&lt;li>
&lt;p>ifstat&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://www.yuque.com/go/doc/33221919">ip&lt;/a> # 显示或操纵 routing, devices, policy routing and tunnels&lt;/p>
&lt;/li>
&lt;li>
&lt;p>lnstat&lt;/p>
&lt;/li>
&lt;li>
&lt;p>nstat&lt;/p>
&lt;/li>
&lt;li>
&lt;p>rdma&lt;/p>
&lt;/li>
&lt;li>
&lt;p>routef&lt;/p>
&lt;/li>
&lt;li>
&lt;p>routel&lt;/p>
&lt;/li>
&lt;li>
&lt;p>rtacct&lt;/p>
&lt;/li>
&lt;li>
&lt;p>rtmon&lt;/p>
&lt;/li>
&lt;li>
&lt;p>rtpr&lt;/p>
&lt;/li>
&lt;li>
&lt;p>rtstat&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://www.yuque.com/go/doc/33221911">ss&lt;/a> # 转存 Socket 信息&lt;/p>
&lt;/li>
&lt;li>
&lt;p>tipc # &lt;/p>
&lt;/li>
&lt;li>
&lt;p>tc # 实现 &lt;a href="https://www.yuque.com/go/doc/34380573">TC 模块&lt;/a>进行流量控制的程序&lt;/p>
&lt;/li>
&lt;/ol>
&lt;h1 id="配置">配置&lt;/h1>
&lt;p>**/etc/iproute2/* **#&lt;/p></description></item><item><title>Docs: jq 命令行工具</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/x.linux-%E7%AE%A1%E7%90%86/linux-%E6%96%87%E6%9C%AC%E5%A4%84%E7%90%86/jq-%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%B7%A5%E5%85%B7/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/x.linux-%E7%AE%A1%E7%90%86/linux-%E6%96%87%E6%9C%AC%E5%A4%84%E7%90%86/jq-%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%B7%A5%E5%85%B7/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>官方文档：&lt;a href="https://stedolan.github.io/jq/">https://stedolan.github.io/jq/&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>jq 是轻量级且灵活的处理 JSON 数据的 shell 命令行工具&lt;/p>
&lt;p>&lt;a href="https://jqplay.org/">这里是官方提供的 jq 命令在线测试工具&lt;/a>，提供原始 JSON 内容，会自动根据 表达式 输出结果。&lt;/p>
&lt;h1 id="jq-用法详解">jq 用法详解&lt;/h1>
&lt;p>官方文档：&lt;a href="https://stedolan.github.io/jq/manual/">https://stedolan.github.io/jq/manual/&lt;/a>&lt;/p>
&lt;p>jq 程序是一个&lt;code>过滤器&lt;/code>，接收一个输入，并产生一个输出。&lt;/p>
&lt;h1 id="基础过滤">基础过滤&lt;/h1>
&lt;p>官方文档：&lt;a href="https://stedolan.github.io/jq/manual/#Basicfilters">https://stedolan.github.io/jq/manual/#Basicfilters&lt;/a>&lt;/p>
&lt;p>下面的 jq 用法，都是用下面这个 json 文件作为演示&lt;/p>
&lt;pre>&lt;code>{&amp;quot;favorite&amp;quot;:{&amp;quot;drink&amp;quot;:&amp;quot;water&amp;quot;,&amp;quot;food&amp;quot;:&amp;quot;sushi&amp;quot;,&amp;quot;game&amp;quot;:&amp;quot;WOW &amp;amp; PAL&amp;quot;},&amp;quot;sushiKinds&amp;quot;:[&amp;quot;sashimi&amp;quot;,{&amp;quot;name&amp;quot;:&amp;quot;hot&amp;quot;},{&amp;quot;name&amp;quot;:&amp;quot;handRoll&amp;quot;,&amp;quot;rice&amp;quot;:&amp;quot;more&amp;quot;},{&amp;quot;name&amp;quot;:null}],&amp;quot;arrayBrowser&amp;quot;:[{&amp;quot;name&amp;quot;:&amp;quot;360&amp;quot;,&amp;quot;url&amp;quot;:&amp;quot;http://www.so.com&amp;quot;},{&amp;quot;name&amp;quot;:&amp;quot;bing&amp;quot;,&amp;quot;url&amp;quot;:&amp;quot;http://www.bing.com&amp;quot;}]}
&lt;/code>&lt;/pre>
&lt;p>格式化后的内容如下，格式化内容仅作参考对照，因为 jq 命令本身就可以实现格式化的 json 的作用。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-json" data-lang="json">&lt;span style="display:flex;">&lt;span>{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;favorite&amp;#34;&lt;/span>: {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;drink&amp;#34;&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;water&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;food&amp;#34;&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;sushi&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;game&amp;#34;&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;WOW &amp;amp; PAL&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> },
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;sushiKinds&amp;#34;&lt;/span>: [
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#34;sashimi&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;name&amp;#34;&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;hot&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> },
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;name&amp;#34;&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;handRoll&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;rice&amp;#34;&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;more&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> },
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;name&amp;#34;&lt;/span>: &lt;span style="color:#66d9ef">null&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ],
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;arrayBrowser&amp;#34;&lt;/span>: [
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;name&amp;#34;&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;360&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;url&amp;#34;&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;http://www.so.com&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> },
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;name&amp;#34;&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;bing&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;url&amp;#34;&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;http://www.bing.com&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="点符号">点&lt;code>.&lt;/code>符号&lt;/h2>
&lt;p>点&lt;code>.&lt;/code>符号与 go 模板中的点作用一样，表示&lt;strong>当前作用域&lt;/strong>的&lt;strong>对象&lt;/strong>。对于 jq 来说，所有给 jq 输入的内容，都是当前作用域的对象。比如&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-json" data-lang="json">&lt;span style="display:flex;">&lt;span>[&lt;span style="color:#960050;background-color:#1e0010">root@host&lt;/span>&lt;span style="color:#ae81ff">-3&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">~&lt;/span>]&lt;span style="color:#960050;background-color:#1e0010">#&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">cat&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">demo.json&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>{&lt;span style="color:#f92672">&amp;#34;favorite&amp;#34;&lt;/span>:{&lt;span style="color:#f92672">&amp;#34;drink&amp;#34;&lt;/span>:&lt;span style="color:#e6db74">&amp;#34;water&amp;#34;&lt;/span>,&lt;span style="color:#f92672">&amp;#34;food&amp;#34;&lt;/span>:&lt;span style="color:#e6db74">&amp;#34;sushi&amp;#34;&lt;/span>,&lt;span style="color:#f92672">&amp;#34;game&amp;#34;&lt;/span>:&lt;span style="color:#e6db74">&amp;#34;WOW &amp;amp; PAL&amp;#34;&lt;/span>},&lt;span style="color:#f92672">&amp;#34;sushiKinds&amp;#34;&lt;/span>:[&lt;span style="color:#e6db74">&amp;#34;sashimi&amp;#34;&lt;/span>,{&lt;span style="color:#f92672">&amp;#34;name&amp;#34;&lt;/span>:&lt;span style="color:#e6db74">&amp;#34;hot&amp;#34;&lt;/span>},{&lt;span style="color:#f92672">&amp;#34;name&amp;#34;&lt;/span>:&lt;span style="color:#e6db74">&amp;#34;handRoll&amp;#34;&lt;/span>,&lt;span style="color:#f92672">&amp;#34;rice&amp;#34;&lt;/span>:&lt;span style="color:#e6db74">&amp;#34;more&amp;#34;&lt;/span>},{&lt;span style="color:#f92672">&amp;#34;name&amp;#34;&lt;/span>:&lt;span style="color:#66d9ef">null&lt;/span>}],&lt;span style="color:#f92672">&amp;#34;arrayBrowser&amp;#34;&lt;/span>:[{&lt;span style="color:#f92672">&amp;#34;name&amp;#34;&lt;/span>:&lt;span style="color:#e6db74">&amp;#34;360&amp;#34;&lt;/span>,&lt;span style="color:#f92672">&amp;#34;url&amp;#34;&lt;/span>:&lt;span style="color:#e6db74">&amp;#34;http://www.so.com&amp;#34;&lt;/span>},{&lt;span style="color:#f92672">&amp;#34;name&amp;#34;&lt;/span>:&lt;span style="color:#e6db74">&amp;#34;bing&amp;#34;&lt;/span>,&lt;span style="color:#f92672">&amp;#34;url&amp;#34;&lt;/span>:&lt;span style="color:#e6db74">&amp;#34;http://www.bing.com&amp;#34;&lt;/span>}]}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>[&lt;span style="color:#960050;background-color:#1e0010">root@host&lt;/span>&lt;span style="color:#ae81ff">-3&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">~&lt;/span>]&lt;span style="color:#960050;background-color:#1e0010">#&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">cat&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">demo.json&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">|&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">jq&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">.&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;favorite&amp;#34;&lt;/span>: {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;drink&amp;#34;&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;water&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;food&amp;#34;&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;sushi&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;game&amp;#34;&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;WOW &amp;amp; PAL&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> },
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;sushiKinds&amp;#34;&lt;/span>: [
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#34;sashimi&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;name&amp;#34;&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;hot&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> },
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;name&amp;#34;&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;handRoll&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;rice&amp;#34;&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;more&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> },
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;name&amp;#34;&lt;/span>: &lt;span style="color:#66d9ef">null&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ],
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;arrayBrowser&amp;#34;&lt;/span>: [
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;name&amp;#34;&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;360&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;url&amp;#34;&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;http://www.so.com&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> },
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;name&amp;#34;&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;bing&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;url&amp;#34;&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;http://www.bing.com&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="获取-map-的值">获取 map 的值&lt;/h2>
&lt;p>给定 map 的名称，获取其值。&lt;code>.foo.bar&lt;/code>与&lt;code>.foo|.bar&lt;/code>作用相同。如果 map 名称中包含特殊字符或以数字开头，则需要适用双引号将其括起来，例如&lt;/p>
&lt;pre>&lt;code>[root@host-3 ~]# cat demo.json | jq '.favorite.food'
&amp;quot;sushi&amp;quot;
&lt;/code>&lt;/pre>
&lt;h2 id="获取-array-的值">获取 array 的值&lt;/h2>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-json" data-lang="json">&lt;span style="display:flex;">&lt;span>[&lt;span style="color:#960050;background-color:#1e0010">root@host&lt;/span>&lt;span style="color:#ae81ff">-3&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">~&lt;/span>]&lt;span style="color:#960050;background-color:#1e0010">#&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">cat&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">demo.json&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">|&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">jq&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">.arrayBrowser&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>[
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;name&amp;#34;&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;360&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;url&amp;#34;&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;http://www.so.com&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> },
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;name&amp;#34;&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;bing&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;url&amp;#34;&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;http://www.bing.com&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>[&lt;span style="color:#960050;background-color:#1e0010">root@host&lt;/span>&lt;span style="color:#ae81ff">-3&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">~&lt;/span>]&lt;span style="color:#960050;background-color:#1e0010">#&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">cat&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">demo.json&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">|&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">jq&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">.arrayBrowser&lt;/span>[]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;name&amp;#34;&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;360&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;url&amp;#34;&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;http://www.so.com&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;name&amp;#34;&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;bing&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;url&amp;#34;&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;http://www.bing.com&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>[&lt;span style="color:#960050;background-color:#1e0010">root@host&lt;/span>&lt;span style="color:#ae81ff">-3&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">~&lt;/span>]&lt;span style="color:#960050;background-color:#1e0010">#&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">cat&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">demo.json&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">|&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">jq&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">.arrayBrowser&lt;/span>[]&lt;span style="color:#960050;background-color:#1e0010">.name&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">&amp;#34;360&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">&amp;#34;bing&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>[&lt;span style="color:#960050;background-color:#1e0010">root@host&lt;/span>&lt;span style="color:#ae81ff">-3&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">~&lt;/span>]&lt;span style="color:#960050;background-color:#1e0010">#&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">cat&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">demo.json&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">|&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">jq&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">.arrayBrowser&lt;/span>[&lt;span style="color:#ae81ff">1&lt;/span>]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;name&amp;#34;&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;bing&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;url&amp;#34;&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;http://www.bing.com&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div></description></item><item><title>Docs: K6</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/x.linux-%E7%AE%A1%E7%90%86/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96-%E4%B8%8E-%E6%95%85%E9%9A%9C%E5%A4%84%E7%90%86/%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95/k6/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/x.linux-%E7%AE%A1%E7%90%86/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96-%E4%B8%8E-%E6%95%85%E9%9A%9C%E5%A4%84%E7%90%86/%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95/k6/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://github.com/grafana/k6">GitHub 项目，grafana/k6&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://k6.io/">官网&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://mp.weixin.qq.com/s/jb8-8Uo3UBla6whiUEWdqw">公众号，MoeLove-Grafana k6 的上手实践&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>使用 Go 和 JavaScript 语言实现的现代负载测试工具。&lt;/p>
&lt;h2 id="背景">背景&lt;/h2>
&lt;p>2016 年 8 月，k6 在 GitHub 上发布了第一个版本，至此，一个出色的开源负载压测工具进入了人们的视野。&lt;/p>
&lt;p>2021 年的 6 月，对于 Grafana 和 k6 来讲是个大日子，Grafana Labs 收购了 k6 。&lt;/p>
&lt;p>而事实上， Grafana 与 k6 的缘分还要追溯到更早的 2 年前。&lt;/p>
&lt;p>2019 年，在进行 Grafana 6.0 的短期令牌刷新行为的压测时，Grafana Labs 进行了一系列的技术选型。&lt;/p>
&lt;p>由于 Grafana Labs 的大部分后端软件是使用 Go 来实现的，恰巧 k6 满足 OSS 和 Go 需求，并且负载测试是使用 JS 编写（Grafana 前端框架及 UI 都在使用）。这使得 k6 自 Grafana 6.0 版本开始，不断地为 Grafana 开发者及测试者完成追踪 bug 的使命。&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/9ca3cf4f-fa39-421c-bd25-ca04a9d9d9d4/640" alt="">&lt;/p>
&lt;p>img&lt;/p>
&lt;p>图 1 ，k6 加入 Grafana Labs&lt;/p>
&lt;h2 id="多样的压测工具">多样的压测工具&lt;/h2>
&lt;p>一个称心应手的自动化负载压测工具会极大的提升程序开发人员的代码质量及效率。&lt;/p>
&lt;p>下图中是一些比较常见的用于负载压测的工具，我们可以在 GitHub 上看到，目前，更新比较频繁、活跃的项目主要有：Gatling, Jmeter 和 k6 。&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/9ca3cf4f-fa39-421c-bd25-ca04a9d9d9d4/640" alt="">&lt;/p>
&lt;p>img&lt;/p>
&lt;p>图 2 ，压测工具们&lt;/p>
&lt;p>如何从中选择，简单的讲就是工具效率的比拼。主要从以下两个方面来考量：&lt;/p>
&lt;ul>
&lt;li>工具性能&lt;/li>
&lt;li>工具使用体验&lt;/li>
&lt;/ul>
&lt;p>下图对以上工具进行了一些简单的对比。&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/9ca3cf4f-fa39-421c-bd25-ca04a9d9d9d4/640" alt="">&lt;/p>
&lt;p>img&lt;/p>
&lt;p>这里我主要对比下其中较为活跃的 3 个项目。&lt;/p>
&lt;ul>
&lt;li>JMeter - 熟悉 Java 的小伙伴可能比较了解这个工具。由于存在时间久，JMeter 的功能是这之中最全面的，并且集成、附加组件做的较好。基于它构建的 SaaS 服务 Blazemeter，相信大家也都熟识。这也导致了一个极大的问题，使用的复杂性高及不够轻量级；&lt;/li>
&lt;li>Gatling - Gatling 也有着 SaaS 产品 Gatling Frontline。就使用门槛来讲，JS 要比 Scala 要低很多；&lt;/li>
&lt;li>k6 - k6 最初是由 SaaS 服务 Load Impact 的几名员工开发维护。使用门槛低（JS），参数化更简单，并且 “负载测试即代码” 的理念也让他的维护成本更低。未来可期。&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/9ca3cf4f-fa39-421c-bd25-ca04a9d9d9d4/640" alt="">&lt;/p>
&lt;p>img&lt;/p>
&lt;p>图 3 ，3 种热门工具比一比&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/9ca3cf4f-fa39-421c-bd25-ca04a9d9d9d4/640" alt="">&lt;/p>
&lt;p>img&lt;/p>
&lt;p>或者这样：&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/9ca3cf4f-fa39-421c-bd25-ca04a9d9d9d4/640" alt="">&lt;/p>
&lt;p>img&lt;/p>
&lt;p>k6 是用 Go 语言开发的，要安装 k6 步骤很简单，只要直接在其 GitHub 的 Release 页面下载二进制文件即可。比如：&lt;/p>
&lt;p>&lt;code>(MoeLove) ➜ wget -q https://github.com/grafana/k6/releases/download/v0.35.0/k6-v0.35.0-linux-amd64.tar.gz  (MoeLove) ➜ tar -xzf k6-v0.35.0-linux-amd64.tar.gz  (MoeLove) ➜ ls k6-v0.35.0-linux-amd64  k6-v0.35.0-linux-amd64.tar.gz (MoeLove) ➜ mv ./k6-v0.35.0-linux-amd64/k6 ~/bin/k6 (MoeLove) ➜ k6 version k6 v0.35.0 (2021-11-17T09:53:18+0000/1c44b2d, go1.17.3, linux/amd64)&lt;/code>&lt;/p>
&lt;p>或者也可以直接使用它的 Docker 镜像：&lt;/p>
&lt;p>&lt;code>➜  ~ docker run  --rm loadimpact/k6  version    k6 v0.35.0 (2021-11-17T09:53:03+0000/1c44b2d, go1.17.3, linux/amd64)&lt;/code>&lt;/p>
&lt;p>在 k6 中并没有太多的概念。其中最主要的就是用来执行测试的  virtual users (VUs) ，它的本质就是并发执行任务的次数。&lt;/p>
&lt;p>在使用 k6 执行测试的时候，可以通过 &lt;code>--vus&lt;/code>或者 &lt;code>-u&lt;/code>进行指定，默认是 1 。&lt;/p>
&lt;p>我个人感觉 k6 在目前的这些主流压测工具中算用户体验比较好的一个。它使用 JS（ES6）作为配置语言，还是比较方便的，我们来做一些示例。&lt;/p>
&lt;h2 id="简单请求">简单请求&lt;/h2>
&lt;p>如果对于进行 HTTP 请求的时候，我们只需要从 &lt;code>k6/http&lt;/code> 导入 &lt;code>http&lt;/code>即可。&lt;/p>
&lt;p>注意在 k6 中，默认情况下必须得有个作为入口的 &lt;code>default&lt;/code>函数，这类似我们常用的 &lt;code>main&lt;/code>函数。&lt;/p>
&lt;p>`import http from &amp;ldquo;k6/http&amp;rdquo;;&lt;/p>
&lt;p>export default function(){
  http.get(&amp;quot;&lt;a href="https://test-api.k6.io/public/crocodiles/">https://test-api.k6.io/public/crocodiles/&lt;/a>&amp;quot;)
}&lt;/p>
&lt;p>`&lt;/p>
&lt;p>执行后效果如下：&lt;/p>
&lt;p>`(MoeLove) ➜ k6 run simple_http_get.js&lt;/p>
&lt;p>/\      |‾‾| /‾‾/   /‾‾/   
     /\  /  \     |  |/  /   /  /    
    /  /    \    |     (   /   ‾‾\  
   /          \   |  |\  \ |  (‾)  | 
  / ** \  |**| __\ _/ .io&lt;/p>
&lt;p>execution: local
     script: simple_http_get.js
     output: -&lt;/p>
&lt;p>scenarios: (100.00%) 1 scenario, 1 max VUs, 10m30s max duration (incl. graceful stop):
           * default: 1 iterations for each of 1 VUs (maxDuration: 10m0s, gracefulStop: 30s)&lt;/p>
&lt;p>running (00m01.1s), 0/1 VUs, 1 complete and 0 interrupted iterations
default ✓ [======================================] 1 VUs  00m01.1s/10m0s  1/1 iters, 1 per VU&lt;/p>
&lt;p>data_received&amp;hellip;&amp;hellip;&amp;hellip;&amp;hellip;&amp;hellip;&amp;hellip;: 6.3 kB 5.7 kB/s
     data_sent&amp;hellip;&amp;hellip;&amp;hellip;&amp;hellip;&amp;hellip;&amp;hellip;&amp;hellip;.: 634 B  578 B/s
     http_req_blocked&amp;hellip;&amp;hellip;&amp;hellip;&amp;hellip;&amp;hellip;: avg=848.34ms min=848.34ms med=848.34ms max=848.34ms p(90)=848.34ms p(95)=848.34ms
     http_req_connecting&amp;hellip;&amp;hellip;&amp;hellip;&amp;hellip;: avg=75.59µs  min=75.59µs  med=75.59µs  max=75.59µs  p(90)=75.59µs  p(95)=75.59µs 
     http_req_duration&amp;hellip;&amp;hellip;&amp;hellip;&amp;hellip;..: avg=247.46ms min=247.46ms med=247.46ms max=247.46ms p(90)=247.46ms p(95)=247.46ms
       { expected_response:true }&amp;hellip;: avg=247.46ms min=247.46ms med=247.46ms max=247.46ms p(90)=247.46ms p(95)=247.46ms
     http_req_failed&amp;hellip;&amp;hellip;&amp;hellip;&amp;hellip;&amp;hellip;.: 0.00%  ✓ 0        ✗ 1  
     http_req_receiving&amp;hellip;&amp;hellip;&amp;hellip;&amp;hellip;.: avg=455.24µs min=455.24µs med=455.24µs max=455.24µs p(90)=455.24µs p(95)=455.24µs
     http_req_sending&amp;hellip;&amp;hellip;&amp;hellip;&amp;hellip;&amp;hellip;: avg=103.77µs min=103.77µs med=103.77µs max=103.77µs p(90)=103.77µs p(95)=103.77µs
     http_req_tls_handshaking&amp;hellip;&amp;hellip;.: avg=848.07ms min=848.07ms med=848.07ms max=848.07ms p(90)=848.07ms p(95)=848.07ms
     http_req_waiting&amp;hellip;&amp;hellip;&amp;hellip;&amp;hellip;&amp;hellip;: avg=246.9ms  min=246.9ms  med=246.9ms  max=246.9ms  p(90)=246.9ms  p(95)=246.9ms 
     http_reqs&amp;hellip;&amp;hellip;&amp;hellip;&amp;hellip;&amp;hellip;&amp;hellip;&amp;hellip;.: 1      0.911502/s
     iteration_duration&amp;hellip;&amp;hellip;&amp;hellip;&amp;hellip;.: avg=1.09s    min=1.09s    med=1.09s    max=1.09s    p(90)=1.09s    p(95)=1.09s   
     iterations&amp;hellip;&amp;hellip;&amp;hellip;&amp;hellip;&amp;hellip;&amp;hellip;&amp;hellip;: 1      0.911502/s
     vus&amp;hellip;&amp;hellip;&amp;hellip;&amp;hellip;&amp;hellip;&amp;hellip;&amp;hellip;&amp;hellip;&amp;hellip;.: 1      min=1      max=1
     vus_max&amp;hellip;&amp;hellip;&amp;hellip;&amp;hellip;&amp;hellip;&amp;hellip;&amp;hellip;&amp;hellip;: 1      min=1      max=1&lt;/p>
&lt;p>`&lt;/p>
&lt;p>k6 默认会将执行后的结果输出到终端。同时它自带了一些指标会同时输出。&lt;/p>
&lt;p>这些指标基本上都是语义化的，看名字就可以理解其含义，这里就不一一介绍了。&lt;/p>
&lt;h2 id="带检查的请求">带检查的请求&lt;/h2>
&lt;p>我们可以在请求中同时增加一些测试，判断接口的响应值是否符合我们的预期。如下：&lt;/p>
&lt;p>`import http from &amp;ldquo;k6/http&amp;rdquo;;
import { check, group } from &amp;ldquo;k6&amp;rdquo;;&lt;/p>
&lt;p>export default function() {&lt;/p>
&lt;p>group(&amp;ldquo;GET&amp;rdquo;, function() {
        let res = http.get(&amp;quot;&lt;a href="http://httpbin.org/get?verb=get">http://httpbin.org/get?verb=get&lt;/a>&amp;quot;);
        check(res, {
            &amp;ldquo;status is 200&amp;rdquo;: (r) =&amp;gt; r.status === 200,
            &amp;ldquo;is verb correct&amp;rdquo;: (r) =&amp;gt; r.json().args.verb === &amp;ldquo;get&amp;rdquo;,
        });
    });
}&lt;/p>
&lt;p>`&lt;/p>
&lt;p>通过引入了 &lt;code>check&lt;/code>函数，来执行一些判断的逻辑，当然上述的 &lt;code>==&amp;gt;&lt;/code> 其实是 ES6 中的一种简写，将其展开为正常的函数也可以。比如：&lt;/p>
&lt;p>`import http from &amp;ldquo;k6/http&amp;rdquo;;
import { check, group } from &amp;ldquo;k6&amp;rdquo;;&lt;/p>
&lt;p>export default function() {&lt;/p>
&lt;p>group(&amp;ldquo;GET&amp;rdquo;, function() {
        let res = http.get(&amp;quot;&lt;a href="http://httpbin.org/get?verb=get">http://httpbin.org/get?verb=get&lt;/a>&amp;quot;);
        check(res, {
          &amp;ldquo;status is 200&amp;rdquo;: function(r){
             return r.status === 200
          },
            &amp;ldquo;is verb correct&amp;rdquo;: (r) =&amp;gt; r.json().args.verb === &amp;ldquo;get&amp;rdquo;,
        });
    });
}&lt;/p>
&lt;p>`&lt;/p>
&lt;p>使用 k6 执行此脚本后，得到的输出相比之前的多了如下内容：&lt;/p>
&lt;p>`     █ GET&lt;/p>
&lt;p>✓ status is 200
       ✓ is verb correct&lt;/p>
&lt;p>checks&amp;hellip;&amp;hellip;&amp;hellip;&amp;hellip;&amp;hellip;&amp;hellip;&amp;hellip;&amp;hellip;.: 100.00% ✓ 2        ✗ 0&lt;/p>
&lt;p>`&lt;/p>
&lt;p>从这里可以看到我们当前请求接口的测试是否通过（也可以用来判断当前接口是否能正常提供服务）。&lt;/p>
&lt;h2 id="自定义指标输出">自定义指标输出&lt;/h2>
&lt;p>接下来我们尝试下在压测过程中定义一些自己定的指标。只需要从 &lt;code>k6/metrics&lt;/code>中导入一些不同类型的指标即可。这和在 Prometheus 中的类型基本一致。&lt;/p>
&lt;p>这里我增加了两个 metric。一个 &lt;code>testCounter&lt;/code>用于统计一共执行了多少次测试， &lt;code>passedRate&lt;/code>计算通过率。&lt;/p>
&lt;p>`import http from &amp;ldquo;k6/http&amp;rdquo;;
import { Counter, Rate } from &amp;ldquo;k6/metrics&amp;rdquo;;
import { check, group } from &amp;ldquo;k6&amp;rdquo;;&lt;/p>
&lt;p>let testCounter = new Counter(&amp;ldquo;test_counter&amp;rdquo;);
let passedRate = new Rate(&amp;ldquo;passed_rate&amp;rdquo;);&lt;/p>
&lt;p>export default function() {&lt;/p>
&lt;p>group(&amp;ldquo;GET&amp;rdquo;, function() {
        let res = http.get(&amp;quot;&lt;a href="http://httpbin.org/get?verb=get">http://httpbin.org/get?verb=get&lt;/a>&amp;quot;);
        let passed = check(res, {
            &amp;ldquo;status is 200&amp;rdquo;: (r) =&amp;gt; r.status === 200,
            &amp;ldquo;is verb correct&amp;rdquo;: (r) =&amp;gt; r.json().args.verb === &amp;ldquo;get&amp;rdquo;,
        });&lt;/p>
&lt;p>testCounter.add(1);
        passedRate.add(passed);
    });
}&lt;/p>
&lt;p>`&lt;/p>
&lt;p>这里我们设置了 2 个 VU， 以及设置了执行过程为 &lt;code>10s&lt;/code> 执行后的输出如下：&lt;/p>
&lt;p>&lt;code>(MoeLove) ➜ k6 run -u 2 -d 10s  simple_custom_metrics.js...  execution: local     script: simple_custom_metrics.js     output: -  scenarios: (100.00%) 1 scenario, 2 max VUs, 40s max duration (incl. graceful stop):           * default: 2 looping VUs for 10s (gracefulStop: 30s)running (10.4s), 0/2 VUs, 36 complete and 0 interrupted iterationsdefault ✓ [======================================] 2 VUs  10s     █ GET       ✓ status is 200       ✓ is verb correct     checks.........................: 100.00% ✓ 72       ✗ 0       data_received..................: 18 kB   1.7 kB/s     data_sent......................: 3.9 kB  372 B/s     group_duration.................: avg=567.35ms min=440.56ms med=600.52ms max=738.73ms p(90)=620.88ms p(95)=655.17ms     http_req_blocked...............: avg=266.72µs min=72.33µs  med=135.14µs max=776.66µs p(90)=644.4µs  p(95)=719.96µs     http_req_connecting............: avg=170.04µs min=45.51µs  med=79.9µs   max=520.69µs p(90)=399.41µs p(95)=463.55µs     http_req_duration..............: avg=566.82ms min=439.69ms med=600.31ms max=738.16ms p(90)=620.52ms p(95)=654.61ms       { expected_response:true }...: avg=566.82ms min=439.69ms med=600.31ms max=738.16ms p(90)=620.52ms p(95)=654.61ms     http_req_failed................: 0.00%   ✓ 0        ✗ 36      http_req_receiving.............: avg=309.13µs min=122.4µs  med=231.72µs max=755.3µs  p(90)=597.95µs p(95)=641.92µs     http_req_sending...............: avg=80.69µs  min=20.47µs  med=38.91µs  max=235.1µs  p(90)=197.87µs p(95)=214.79µs     http_req_tls_handshaking.......: avg=0s       min=0s       med=0s       max=0s       p(90)=0s       p(95)=0s           http_req_waiting...............: avg=566.43ms min=439.31ms med=600.16ms max=737.8ms  p(90)=620.19ms p(95)=654.18ms     http_reqs......................: 36      3.472534/s     iteration_duration.............: avg=567.38ms min=440.62ms med=600.53ms max=738.75ms p(90)=620.89ms p(95)=655.2ms      iterations.....................: 36      3.472534/s     passed_rate....................: 100.00% ✓ 36       ✗ 0       test_counter...................: 36      3.472534/s     vus............................: 2       min=2      max=2     vus_max........................: 2       min=2      max=2&lt;/code>&lt;/p>
&lt;p>可以看到在输出中多了两行：&lt;/p>
&lt;p>&lt;code>passed_rate....................: 100.00% ✓ 36       ✗ 0        test_counter...................: 36      3.472534/s&lt;/code>&lt;/p>
&lt;p>与我们的预期相符。&lt;/p>
&lt;p>不过这样看起来不够直观，我们可以尝试使用 k6 Cloud 来展示结果。登陆后，只要在执行 k6 时，通过 &lt;code>-o cloud&lt;/code>的方式将输出指定到 cloud 就可以在 cloud 上看到所有的指标了&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/9ca3cf4f-fa39-421c-bd25-ca04a9d9d9d4/640" alt="">&lt;/p>
&lt;p>img&lt;/p>
&lt;p>本篇主要是在介绍一个现代化的用户体验相对较好的压测工具 k6 。我目前正在计划将其引入到我们项目的 CI 中，以便了解每次核心部分的变更对项目性能的影响。&lt;/p>
&lt;p>后续推进顺利的话，会再分享 k6 如何应用到 CI 环境中，敬请期待。&lt;/p>
&lt;hr>
&lt;p>欢迎订阅我的文章公众号【MoeLove】&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/9ca3cf4f-fa39-421c-bd25-ca04a9d9d9d4/640" alt="">&lt;/p>
&lt;p>TheMoeLove&lt;/p></description></item><item><title>Docs: link</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/x.linux-%E7%AE%A1%E7%90%86/linux-%E7%BD%91%E7%BB%9C%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/iproute-%E5%B7%A5%E5%85%B7%E5%8C%85/ip-%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%B7%A5%E5%85%B7/link/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/x.linux-%E7%AE%A1%E7%90%86/linux-%E7%BD%91%E7%BB%9C%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/iproute-%E5%B7%A5%E5%85%B7%E5%8C%85/ip-%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%B7%A5%E5%85%B7/link/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;p>一个 &lt;strong>link&lt;/strong> 代表一个 &lt;strong>network device(网络设备)&lt;/strong>。link 对象及其相应的命令集，可以查看和操纵网络设备(增删改查等)。主要通过其自身的子命令来实现本身的功能。&lt;/p>
&lt;h1 id="syntax语法">Syntax(语法)&lt;/h1>
&lt;p>&lt;strong>ip [OPTIONS] link [COMMAND] # 网络设备配置&lt;/strong>
&lt;strong>COMMAND：&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>&lt;strong>add|delete|set|show&lt;/strong> # 增|删|改|查 一个虚拟 link&lt;/li>
&lt;li>&lt;strong>xstats&lt;/strong> #&lt;/li>
&lt;li>&lt;strong>afstats&lt;/strong> #&lt;/li>
&lt;li>&lt;strong>property&lt;/strong> #&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>OPTIONS：&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>&lt;strong>-4&lt;/strong> # 指定使用的网络层协议是 IPV4&lt;/li>
&lt;li>&lt;strong>-r&lt;/strong> # 显示主机时，不使用 IP，而是使用主机的域名&lt;/li>
&lt;/ul>
&lt;h1 id="add--添加网络设备">add # 添加网络设备&lt;/h1>
&lt;p>&lt;strong>ip link add [link DEVICE] [ name ] NAME [ARGS] type TYPE [ ARGS ]&lt;/strong>
添加虚拟链路
&lt;strong>DEVICE&lt;/strong> # 要操作的物理设备
**NAME **# 要操作的设备的名称
**ARGS **# 这个参数可以设定设备的 IP 地址、网络地址、MTU 等
**TYPE # **设备类型&lt;/p>
&lt;ul>
&lt;li>&lt;strong>bridge&lt;/strong> # 以太网网桥设备&lt;/li>
&lt;li>&lt;strong>bond&lt;/strong> # Bonding(绑定)设备&lt;/li>
&lt;li>&lt;strong>dummy&lt;/strong> # 虚拟网络接口&lt;/li>
&lt;li>hsr - High-availability Seamless Redundancy device&lt;/li>
&lt;li>ifb - Intermediate Functional Block device&lt;/li>
&lt;li>ipoib - IP over Infiniband device&lt;/li>
&lt;li>macvlan - Virtual interface base on link layer address (MAC)&lt;/li>
&lt;li>macvtap - Virtual interface based on link layer address (MAC) and TAP.&lt;/li>
&lt;li>vcan - Virtual Controller Area Network interface&lt;/li>
&lt;li>vxcan - Virtual Controller Area Network tunnel interface&lt;/li>
&lt;li>&lt;strong>veth&lt;/strong> # Virtual ethernet interface(虚拟以太网接口)设备&lt;/li>
&lt;li>&lt;strong>vlan&lt;/strong> # 802.1q tagged virtual LAN interface&lt;/li>
&lt;li>&lt;strong>vxlan&lt;/strong> # Virtual eXtended LAN&lt;/li>
&lt;li>ip6tnl - Virtual tunnel interface IPv4|IPv6 over IPv6&lt;/li>
&lt;li>ipip - Virtual tunnel interface IPv4 over IPv4&lt;/li>
&lt;li>sit - Virtual tunnel interface IPv6 over IPv4&lt;/li>
&lt;li>gre - Virtual tunnel interface GRE over IPv4&lt;/li>
&lt;li>gretap - Virtual L2 tunnel interface GRE over IPv4&lt;/li>
&lt;li>erspan - Encapsulated Remote SPAN over GRE and IPv4&lt;/li>
&lt;li>ip6gre - Virtual tunnel interface GRE over IPv6&lt;/li>
&lt;li>ip6gretap - Virtual L2 tunnel interface GRE over IPv6&lt;/li>
&lt;li>ip6erspan - Encapsulated Remote SPAN over GRE and IPv6&lt;/li>
&lt;li>vti - Virtual tunnel interface&lt;/li>
&lt;li>nlmon - Netlink monitoring device&lt;/li>
&lt;li>ipvlan # - Interface for L3 (IPv6/IPv4) based VLANs&lt;/li>
&lt;li>ipvtap - Interface for L3 (IPv6/IPv4) based VLANs and TAP&lt;/li>
&lt;li>lowpan - Interface for 6LoWPAN (IPv6) over IEEE 802.15.4 / Bluetooth&lt;/li>
&lt;li>geneve - GEneric NEtwork Virtualization Encapsulation&lt;/li>
&lt;li>macsec - Interface for IEEE 802.1AE MAC Security (MACsec)&lt;/li>
&lt;li>vrf - Interface for L3 VRF domains&lt;/li>
&lt;li>netdevsim - Interface for netdev API tests&lt;/li>
&lt;li>rmnet - Qualcomm rmnet device&lt;/li>
&lt;li>xfrm - Virtual xfrm interface&lt;/li>
&lt;/ul>
&lt;h1 id="set--改变设备属性">set # 改变设备属性&lt;/h1>
&lt;blockquote>
&lt;p>注意: 如果请求多个参数更改，则在任何更改失败后，ip 立即中止。当 ip 可以将系统移动到不可预测的状态时，这是唯一的情况。解决方案是避免使用一个 ip 链路集调用更改几个参数。修饰符更改等效于 set。&lt;/p>
&lt;/blockquote>
&lt;p>&lt;strong>ip link set { DEVICE | group GROUP } [ { up | down } ]&lt;/strong>
** [ type ETYPE TYPE_ARGS ]**
** [ arp { on | off } ]**
** [ dynamic { on | off } ]**
** [ multicast { on | off } ]**
** [ allmulticast { on | off } ]**
** [ promisc { on | off } ]**
** [ protodown { on | off } ]**
** [ trailers { on | off } ]**
** [ txqueuelen PACKETS ]**
** [ name NEWNAME ]**
** [ address LLADDR ]**
** [ broadcast LLADDR ]**
** [ mtu MTU ]**
** [ netns { PID | NETNSNAME } ]**
** [ link-netnsid ID ]**
** [ alias NAME ]**
** [ vf NUM [ mac LLADDR ]**
** [ VFVLAN-LIST ]**
** [ rate TXRATE ]**
** [ max_tx_rate TXRATE ]**
** [ min_tx_rate TXRATE ]**
** [ spoofchk { on | off } ]**
** [ query_rss { on | off } ]**
** [ state { auto | enable | disable } ]**
** [ trust { on | off } ]**
** [ node_guid eui64 ]**
** [ port_guid eui64 ] ]**
** [ { xdp | xdpgeneric | xdpdrv | xdpoffload } { off |**
** object FILE [ section NAME ] [ verbose ] |**
** pinned FILE } ]**
** [ master DEVICE ]**
** [ nomaster ]**
** [ vrf NAME ]**
** [ addrgenmode { eui64 | none | stable_secret | random } ]**
** [ macaddr [ MACADDR ]**
** [ { flush | add | del } MACADDR ]**
** [ set MACADDR ] ]**&lt;/p>
&lt;h1 id="show--显示设备属性">show # 显示设备属性&lt;/h1>
&lt;p>&lt;strong>ip link show [ DEVICE | group GROUP ] [ up ] [ master DEVICE ] [ type ETYPE ] [ vrf NAME ]&lt;/strong>&lt;/p>
&lt;h1 id="应用示例">应用示例&lt;/h1>
&lt;ul>
&lt;li>显示链路详细信息，包括接收与发送的数据包数以及错误数，丢弃数等
&lt;ul>
&lt;li>ip -s link show&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>启动或者停止 eth0 网卡，可以简写为 &lt;code>ip l s eth0 up&lt;/code>
&lt;ul>
&lt;li>ip link set dev eth0 up|down&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>添加名字为 veth1.1 的链路，类型为 veth，veth 的另一半名字为 veth1.2
&lt;ul>
&lt;li>ip link add veth1.1 type veth peer name veth1.2&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>把 veth1.1 这个设备绑定到名为 r1 的 namespace 上(注意：一个网络设备只能绑定到一个 namespace 上，一个 namesapce 可以绑定多个网络设备)
&lt;ul>
&lt;li>ip link set veth1.1 netns r1&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>将 vnet0 设备绑定到 br0 桥上
&lt;ul>
&lt;li>ip link set dev vnet0 master br0&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>查看所有 bridge 类型的网络设备
&lt;ul>
&lt;li>ip link show type bridge&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>创建 Bond 类型网络设备
&lt;ul>
&lt;li>创建 802.3ad 模式的 Bond 类型网络设备
&lt;ul>
&lt;li>ip link add bond1 type bond mod 802.3ad&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>将物理网卡关联到的网络设备先关掉，再添加到 Bond 网络设备中
&lt;ul>
&lt;li>ip link set enp6s0f0 master down&lt;/li>
&lt;li>ip link set enp6s0f0 down&lt;/li>
&lt;li>ip link set enp6s0f0 master bond1&lt;/li>
&lt;li>ip link set enp6s0f1 down&lt;/li>
&lt;li>ip link set enp6s0f1 master bond1&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul></description></item><item><title>Docs: Linux 代理配置</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/x.linux-%E7%AE%A1%E7%90%86/linux-%E7%BD%91%E7%BB%9C%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/linux-%E4%BB%A3%E7%90%86%E9%85%8D%E7%BD%AE/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/x.linux-%E7%AE%A1%E7%90%86/linux-%E7%BD%91%E7%BB%9C%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/linux-%E4%BB%A3%E7%90%86%E9%85%8D%E7%BD%AE/</guid><description>
&lt;h1 id="heading">&lt;/h1>
&lt;h1 id="linux-代理服务相关变量">Linux 代理服务相关变量：&lt;/h1>
&lt;ul>
&lt;li>http_proxy |https_proxy | ftp_proxy |all_proxy # 此变量值用于所有 http、https、ftp 或者所有流量&lt;/li>
&lt;li>socks_proxy # 在大多数情况下，它用于 TCP 和 UDP 流量。其值通常采用 socks：// address：port 格式。&lt;/li>
&lt;li>rsync_proxy # 这用于 rsync 流量，尤其是在 Gentoo 和 Arch 等发行版中。&lt;/li>
&lt;li>no_proxy # 以逗号分隔的域名或 IP 列表，应绕过代理。该本地主机就是一个很好的例子。一个例子是 localhost，127.0.0.1。&lt;/li>
&lt;/ul>
&lt;p>语法格式&lt;/p>
&lt;p>XXXX_proxy=&amp;lsquo;http://[USER:PASSWORD@]ServerIP:PORT/&amp;rsquo; #需要设置用户名，密码，代理服务器的 IP 和端口，用户名和密码可省&lt;/p>
&lt;p>EXAMPLE&lt;/p>
&lt;ul>
&lt;li>
&lt;p>http_proxy=&amp;ldquo;http://tom:secret@10.23.42.11:8080/&amp;rdquo; #设置本机的 http 代理服务器为 10.23.42.11:8080，用户名是 tom，密码是 secret&lt;/p>
&lt;/li>
&lt;li>
&lt;p>同时设置 3 种类型代理，没有用户名和密码，代理服务器是 192.168.19.79:1080&lt;/p>
&lt;ul>
&lt;li>export {https,ftp,http}_proxy=&amp;ldquo;127.0.0.1:8889&amp;rdquo;&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>all_proxy=&amp;ldquo;socks5://localhost:10808&amp;rdquo; #使用本地 10808 端口的 socks 协议代理所有流量(e.g.安装完 v2ray 客户端并配置好启动后，即可使用该变量来让设备使用代理进行翻墙)&lt;/p>
&lt;/li>
&lt;li>
&lt;p>no_proxy=&amp;ldquo;10.&lt;em>.&lt;/em>.&lt;em>,192.168.&lt;/em>.&lt;em>,&lt;/em>.local,localhost,127.0.0.1&amp;rdquo; #忽略指定 ip 的代理&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>注意：通过 Systemd 启动的进程，无法识别这些环境变量，只能通过 Unit File 中的 [Service] 部分的 Environment 指令指定代理信息。&lt;/strong>&lt;/p>
&lt;h1 id="linux-bash-终端设置代理proxy访问">Linux bash 终端设置代理（proxy）访问&lt;/h1>
&lt;p>Linux 是开源操作系统，有很多软件包需要从国外网站上下载，而其中大部分国外网站是被墙的，这时我们需要通过代理来访问这些网站。下面我们介绍 Linux bash shell 终端代理设置方法，包括 socks 代理，http 代理。&lt;/p>
&lt;p>一、linux shell 终端代理设置方法：&lt;/p>
&lt;p>linux 要在 shell 终端为 http、https、ftp 协议设置代理，值需要设置对应的环境变量即可。下面是一些关于代理的环境变量：&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>&lt;/th>
&lt;th>&lt;/th>
&lt;th>&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>环境变量&lt;/td>
&lt;td>描述&lt;/td>
&lt;td>值示例&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>http_proxy&lt;/td>
&lt;td>为 http 网站设置代理；&lt;/td>
&lt;td>10.0.0.51:8080;&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>user:pass@10.0.0.10:8080
socks4://10.0.0.51:1080
socks5://192.168.1.1:1080 |
| https_proxy | 为 https 网站设置代理； | 同上 |
| ftp_proxy | 为 ftp 协议设置代理； | socks5://192.168.1.1:1080 |
| no_proxy | 无需代理的主机或域名；
可以使用通配符；
多个时使用“,”号分隔； | &lt;em>.aiezu.com,10.&lt;/em>.&lt;em>.&lt;/em>,192.168.&lt;em>.&lt;/em>,
*.local,localhost,127.0.0.1 |&lt;/p>
&lt;p>可以将上面 4 个环境变量设置项放于~/.bashrc 文件尾部，这样用户打开 bash shell 终端时会自动调用此脚本，读入它们。&lt;/p>
&lt;p>二、linux bash 为 http 站点设置代理：&lt;/p>
&lt;p>根据代理类型，将下面对应的设置项添加到~/.bashrc 文件末尾，然后运行&amp;quot;. ~/.bashrc&amp;quot;（前面是一个“.”号）命令使用之在当前环境生效。&lt;/p>
&lt;p>1、为 http 站点设置 http 代理（默认）：&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>&lt;/th>
&lt;th>&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>1&lt;/td>
&lt;td>export http_proxy=10.0.0.52:8080&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>2、为 http 站点设置 sock4、sock5 代理：&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>&lt;/th>
&lt;th>&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;/table>
&lt;p>| 1
2
3
4
5
6 | # 设置 socks 代理，自动识别 socks 版本
export http_proxy=socks://10.0.0.52:1080
# 设置 socks4 代理
export http_proxy=socks4://10.0.0.52:1080
# 设置 socks5 代理
export http_proxy=socks5://10.0.0.52:1080 |&lt;/p>
&lt;p>3、代理使用用户名密码认证：&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>&lt;/th>
&lt;th>&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>1&lt;/td>
&lt;td>export http_proxy=user:pass@192.158.8.8:8080&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>三、linux bash 为 https 站点设置代理：&lt;/p>
&lt;p>如果需要为 https 网站设置代理，设置 https_proxy 环境变量即可；设置方法完全与 http_proxy 环境变量相同：&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>&lt;/th>
&lt;th>&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;/table>
&lt;p>| 1
2
3
4
5
6 | # 任意使用一项
export https_proxy=10.0.0.52:8080
export https_proxy=user:pass@192.158.8.8:8080
export https_proxy=socks://10.0.0.52:1080
export https_proxy=socks4://10.0.0.52:1080
export https_proxy=socks5://10.0.0.52:1080 |&lt;/p>
&lt;p>四、举例：&lt;/p>
&lt;p>现在我们要设置 http、https 网站都使用 socks5 代理 10.0.0.52:1080，下面为完整设置方法：&lt;/p>
&lt;p>1、vim ~/.bashrc，在文件尾部添加下面内容：&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>&lt;/th>
&lt;th>&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;/table>
&lt;p>| 1
2
3 | export http_proxy=socks5://10.0.0.52:1080
export https_proxy=socks5://10.0.0.52:1080
export no_proxy=&amp;quot;&lt;em>.aiezu.com,10.&lt;/em>.&lt;em>.&lt;/em>,192.168.&lt;em>.&lt;/em>,*.local,localhost,127.0.0.1&amp;quot; |&lt;/p>
&lt;p>2、加载设置:&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>&lt;/th>
&lt;th>&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;/table>
&lt;p>| 1
2
3
4
5 | [root@aiezu.com ~]# . ~/.bashrc
[root@aiezu.com ~]# echo $http_proxy
socks5://10.0.0.52:1080
[root@aiezu.com ~]# echo $https_proxy
socks5://10.0.0.52:1080 |&lt;/p>
&lt;p>3、测试代理：&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>&lt;/th>
&lt;th>&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;/table>
&lt;p>| 1
2
3
4
5
6
7
8
9
10 | [root@aiezu.com ~]# curl -I &lt;a href="http://www.fackbook.com">http://www.fackbook.com&lt;/a>
HTTP/1.1 200 OK
Content-Length: 2423
Content-Type: text/html
Last-Modified: Mon, 14 Nov 2016 22:03:32 GMT
Accept-Ranges: bytes
ETag: &amp;ldquo;0521af0c23ed21:0&amp;rdquo;
Server: Microsoft-IIS/7.5
X-Powered-By: ASP.NET
Date: Sun, 11 Dec 2016 13:21:33 GMT |&lt;/p>
&lt;h1 id="proxychains">proxychains&lt;/h1>
&lt;p>项目地址：&lt;a href="https://github.com/haad/proxychains">https://github.com/haad/proxychains&lt;/a>&lt;/p>
&lt;p>凡是通过 proxychains 程序运行的程序都会通过 proxychains 配置文件中设置的代理配置来发送数据包。&lt;/p>
&lt;p>apt install proxychains 即可&lt;/p>
&lt;p>修改配置文件&lt;/p>
&lt;p>sock5 127.0.0.1 10808 #指定本地代理服务所监听的地址&lt;/p>
&lt;p>proxychains /opt/google/chrome/chrome #即可通过代理打开 chrome 浏览器&lt;/p>
&lt;p>proxychains curl -I &lt;a href="https://www.google.com">https://www.google.com&lt;/a> 会成功&lt;/p></description></item><item><title>Docs: Linux 的紧急模式或救援模式</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/x.linux-%E7%AE%A1%E7%90%86/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96-%E4%B8%8E-%E6%95%85%E9%9A%9C%E5%A4%84%E7%90%86/linux-%E7%9A%84%E7%B4%A7%E6%80%A5%E6%A8%A1%E5%BC%8F%E6%88%96%E6%95%91%E6%8F%B4%E6%A8%A1%E5%BC%8F/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/x.linux-%E7%AE%A1%E7%90%86/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96-%E4%B8%8E-%E6%95%85%E9%9A%9C%E5%A4%84%E7%90%86/linux-%E7%9A%84%E7%B4%A7%E6%80%A5%E6%A8%A1%E5%BC%8F%E6%88%96%E6%95%91%E6%8F%B4%E6%A8%A1%E5%BC%8F/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;p>Linux 系统难免出现问题，下面总结了一些在出现问题时，可以用到的修复方式。&lt;/p>
&lt;p>比如 单用户模式、GRUB 命令操作、Linux 救援模式 的故障修复案例。&lt;/p>
&lt;p>一般的故障修复，都是通过进入一个微型系统，并在微型系统中关联正常系统，来实现对正常系统进行修复操作的。这种微型系统可以存在于内核中，通过内核来启动\；也可以通过外部挂载(光盘、usb 等)的方式来启动。&lt;/p>
&lt;h1 id="emergency紧急-模式">Emergency(紧急) 模式&lt;/h1>
&lt;p>Linux 系统提供了紧急模式(类似 Windows 安全模式)，该模式镶嵌在内核中。可以在最小环境中(仅仅运行系统所需的必要程序)进行系统维护。在紧急模式中，Linux 引导进入根 shell，网络被禁用，只有少数进程运行。紧急模式可以用来修改文件系统损坏、还原配置文件、移动用户数据等。&lt;/p>
&lt;h2 id="启动紧急模式">启动紧急模式&lt;/h2>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/ewdpso/1616163959565-28b07db0-d297-4c04-bdf7-b31a43af0106.jpeg" alt="">
在该界面选中想要使用的内核后，按 e 键 ，进入编辑启动参数界面
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/ewdpso/1616163959592-6d0be599-731a-4f6c-b6b1-9e195991cfb9.jpeg" alt="">
在上图红框位置将 ro 改为 rw init=/sysroot/bin/sh 。然后按 ctrl+x 来启动。这时候，就进入了紧急模式，紧急模式的界面是像下图这样的
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/ewdpso/1616163959556-b1d3734e-d706-47fc-a83c-131c6f049baa.jpeg" alt="">
这是一个 sh 的 shell(也可以启动其他 shell，比如 bash 等)，可以执行一些基本命令，目录结构如下&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>:/# ls
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>bin dev dracut-state.sh etc init lib lib64 proc root run sbin shutdown sys sysroot tmp usr var
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>其中 &lt;code>sysroot&lt;/code> 目录，就是我们正常启动系统时，所看到的 &lt;code>/&lt;/code> 目录&lt;/p>
&lt;p>在这种模式下，可以看到，仅有个别进程在运行，/init rhgb 是该系统模式下的第一个进程，与正常系统不同。
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/ewdpso/1616163959562-5047fe7d-4089-43e3-933c-0eb9ab6c80d4.jpeg" alt="">
sh 进程是因为我们需要一个可以操作的 shell，所以在修改启动项时添加的。&lt;/p>
&lt;p>实际上，所谓的紧急模式，就是在安装 linux 系统时，内核中内置的一个微型系统，进入该微型系统后，咱正常系统的根目录，就被挂载到微型系统的/sysroot 下了，由于没有挂载其他物理磁盘，也没有任何多余进程运行，所以只要内核是好的，那么紧急模式是可以正常进入的。&lt;/p>
&lt;p>该模式可以用来修复一些与非内核错误的一些故障&lt;/p>
&lt;h1 id="rescue救援-模式">Rescue(救援) 模式&lt;/h1>
&lt;p>当紧急模式不可用时，说明内核或者内核相关出现问题，这时候，我们就需要使用救援模式了。&lt;/p>
&lt;p>救援模式并不在已经安装的系统或者内核上，而是通过外部挂载 linux 系统镜像来启动。相当于通过外挂的系统镜像来启动一个微型系统，来诊断并修复当前系统&lt;/p>
&lt;h2 id="启动救援模式">启动救援模式&lt;/h2>
&lt;p>首先需要将系统镜像挂载到设备上，物理机直接插入光盘或者 U 盘，并修改启动项；虚拟机的话同理，将 linux 系统镜像挂载进虚拟机然后通过该系统镜像启动系统。
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/ewdpso/1616163959557-c45d87ec-9d2c-4296-b14a-fdd3f7b710e1.jpeg" alt="">
在上图选择 Troubleshooting 后，选择 Rescue a CentOS system（救援一个 centos 系统）
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/ewdpso/1616163959573-28e0e935-14ef-4a12-8d1f-20ad9d79a274.jpeg" alt="">
在上图蓝线上半部分，选择 1 继续之后。将会启动一个微型系统，并进入一个 shell，其中会提示我们，设备上正常系统的 / 目录被挂载到 /mnt/sysimage ，该情况与 紧急模式 一样，只是正常系统的跟目录被挂载的路径不同罢了。&lt;/p>
&lt;p>通过光盘启动的微型系统，明显比紧急模式的微型系统 功能更加完善，可以看到有很多进程
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/ewdpso/1616163959579-0a7e5ff3-ae98-4560-8a00-c3b58808a04d.jpeg" alt="">
同样也是一个 sh 的 shell。可以在该 shell 下，进入 /mnt/sysimage 目录来对正常的系统进行修复&lt;/p>
&lt;h2 id="这类模式常见使用方式">这类模式常见使用方式&lt;/h2>
&lt;p>由于进入这类救援模式后，原本系统的 &lt;code>/&lt;/code> 被挂载到微型系统的的其他目录，这之后直接使用 chroot /PATH/DIR 命令，即可将当前 / 目录转变到原本系统上，然后就可以更方便的定位问题了，如果不进行 chroot，那么操作目录的时候，其实挺不方便的~~~~&lt;/p>
&lt;h2 id="ubuntu-的-rescue-模式">Ubuntu 的 Rescue 模式&lt;/h2>
&lt;p>网上充斥着大量的垃圾信息，并没有明确指导如何通过挂盘来进入 Rescue 模式，实际上，Ubuntu Server 版的 ISO 并没有提供这个功能，那么有两种方式来实现：&lt;/p>
&lt;ul>
&lt;li>使用 Ubuntu Desktop 的 ISO，进入界面后选择 &lt;strong>Try Ubuntu&lt;/strong>，也就是网上常说的 &lt;strong>Live CD&lt;/strong> 模式。只不过这是图形界面，进入后配置好 root 密码，可以使用 &lt;code>ctrl + alt + f3&lt;/code> 来切换 TTY，并在 CLI 下进行修复工作&lt;/li>
&lt;li>使用 CentOS 的 ISO 进入 Rescue 模式，同样可以修复挂载 Ubuntu 的分区到指定的目录。&lt;/li>
&lt;/ul>
&lt;h1 id="如何在-centos-8-上启动到紧急模式">如何在 CentOS 8 上启动到紧急模式&lt;/h1>
&lt;p>原文链接：&lt;a href="https://linuxhint.com/boot-emergency-mode-centos-8/">https://linuxhint.com/boot-emergency-mode-centos-8/&lt;/a>
在最新的 CentOS 中，即 CentOS 8 紧急模式和救援模式已经取代了运行级别的概念。运行级别是用于各种任务的不同模式。在 CentOS 8 中，Rescue 模式相当于单用户模式，而紧急启动模式提供了一个最小的环境来修复您的系统。
今天我们将学习如何将 CentOS 8 启动到救援和紧急模式。&lt;/p>
&lt;h2 id="如何启动进入救援模式">如何启动进入救援模式&lt;/h2>
&lt;p>救援模式需要 root 密码进行身份验证，并允许您在正常启动过程不起作用时恢复系统。救援模式将尝试设置所有本地文件系统并启动一些基本系统服务。救援模式不启动网络接口，也不允许多个用户登录。
启动计算机并等待 GRUB 菜单出现。
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/ewdpso/1630379281707-861e3e5b-49c3-4721-9e4e-d2f0dd9239cc.png" alt="image.png">
现在按“e”打开编辑菜单：
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/ewdpso/1630379281756-579ed222-fa5a-48c6-9182-5a19adc12983.png" alt="image.png">
现在，找到以下面的屏幕截图所示的“Linux”关键字开头的行：
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/ewdpso/1630379280843-f87b7899-36d3-4049-8ba5-38f918926497.png" alt="image.png">
使用键盘上的终点按钮转到线的末尾，并在行结束时添加以下参数：
systemd.Unit = Rescue.target.
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/ewdpso/1630379280876-d0125040-66ac-4757-abde-e5089a4c1b4e.png" alt="image.png">
按 Ctrl + X 启动系统，但此时使用新参数将让您输入救援模式。
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/ewdpso/1630379280860-c9be44a2-22e8-4fa5-a6c7-4dc77dffa729.png" alt="image.png">
操作系统会要求 root 密码。在提供密码后，您将进入救援模式。
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/ewdpso/1630379281433-ed1c7906-6118-4f92-a7cc-1dc556b445a6.png" alt="image.png">
现在，您可以在救援模式下修复系统。
完成救援模式后，您可以通过运行“退出”命令来退出救援/紧急模式。&lt;/p>
&lt;h2 id="启动进入紧急模式">启动进入紧急模式&lt;/h2>
&lt;p>紧急模式甚至救援模式不起作用时，恢复系统的最小环境。紧急将根文件安装为只读，并不尝试挂载本地文件系统。紧急模式也没有启动网络接口。&lt;/p>
&lt;p>将系统启动到紧急模式的过程与救援模式相同。
首先，启动计算机并等待 GRUB 菜单显示：
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/ewdpso/1630379281944-4f628d77-411e-4319-af8c-1a1557c7e8ce.png" alt="image.png">
现在按“E”打开编辑菜单：
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/ewdpso/1630379282293-94e66990-034a-4b85-8cfa-7e9262ade0a8.png" alt="image.png">
现在定位以“Linux”关键字开头的行，如下屏幕截图所示：
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/ewdpso/1630379282273-c76fcd43-02db-4a14-b7e3-52b4ca27cb3e.png" alt="image.png">
使用键盘上的终点按钮转到线的末尾，并在行结束时添加以下参数：
systemd.unit = Encrasst.target.
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/ewdpso/1630379283117-bf48ec7a-b48c-4d23-bd05-b284dce0dcb3.png" alt="image.png">
按 Ctrl + X 启动系统，但此时使用新参数将让您输入紧急模式。
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/ewdpso/1630379283276-16043784-d87e-4a63-8c3b-95c4c030fd98.png" alt="image.png">
提供密码后，您将进入紧急模式。
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/ewdpso/1630379283239-886da796-8374-441c-a133-2e28b376336d.png" alt="image.png">
现在，即使救援模式不起作用，您也可以在紧急模式下修复系统。&lt;/p>
&lt;p>完成紧急模式后，您可以通过运行“退出”命令来退出救援/紧急模式。&lt;/p></description></item><item><title>Docs: Linux 管理案例</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/x.linux-%E7%AE%A1%E7%90%86/linux-%E7%AE%A1%E7%90%86%E6%A1%88%E4%BE%8B/linux-%E7%AE%A1%E7%90%86%E6%A1%88%E4%BE%8B/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/x.linux-%E7%AE%A1%E7%90%86/linux-%E7%AE%A1%E7%90%86%E6%A1%88%E4%BE%8B/linux-%E7%AE%A1%E7%90%86%E6%A1%88%E4%BE%8B/</guid><description>
&lt;h1 id="重置-linux-的-root-密码">重置 Linux 的 root 密码&lt;/h1>
&lt;h2 id="进入紧急模式">进入紧急模式&lt;/h2>
&lt;p>详见《[Linux 的紧急模式或救援模式](✏IT 学习笔记/📄1.操作系统/X.Linux%20 管理/性能优化%20 与%20 故障处理/Linux%20 的紧急模式或救援模式.md 与 故障处理/Linux 的紧急模式或救援模式.md)》&lt;/p>
&lt;h2 id="修改密码">修改密码&lt;/h2>
&lt;ul>
&lt;li>切换到原系统执行：&lt;code>chroot /sysroot/&lt;/code>&lt;/li>
&lt;li>更改 root 密码：&lt;code>passwd root&lt;/code>&lt;/li>
&lt;li>在/目录下创建一个.autorelabel 文件，而有这个文件存在，系统在重启时就会对整个文件系统进行 relabeling
&lt;ul>
&lt;li>&lt;code>touch /.autorelabel&lt;/code>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;code>exit&lt;/code>&lt;/li>
&lt;li>&lt;code>reboot&lt;/code>&lt;/li>
&lt;/ul>
&lt;h1 id="修改网卡名">修改网卡名&lt;/h1>
&lt;p>centos 系统&lt;/p>
&lt;ul>
&lt;li>vi /etc/default/grub
&lt;ul>
&lt;li>GRUB_CMDLINE_LINUX=&amp;ldquo;net.ifnames=0 biosdevname=0 crashkernel=auto rd.lvm.lv=myvg/root rd.lvm.lv=myvg/swap rhgb quiet&amp;rdquo;&lt;/li>
&lt;li>注意，标红位置改为自己的 lvm 中 volume group 的名字&lt;/li>
&lt;li>主要就是添加紫色内容的字符串&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>grub2-mkconfig -o /boot/grub2/grub.cfg&lt;/li>
&lt;li>mv /etc/sysconfig/network-scripts/ifcfg-ens33 /etc/sysconfig/network-scripts/ifcfg-eth0&lt;/li>
&lt;li>sed -i &amp;ldquo;s/ens33/eth0/g&amp;rdquo; /etc/sysconfig/network-scripts/ifcfg-eth0&lt;/li>
&lt;/ul>
&lt;p>ubuntu 系统&lt;/p>
&lt;ul>
&lt;li>修改 grub 文件
&lt;ul>
&lt;li>vim /etc/default/grub&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>查找
&lt;ul>
&lt;li>GRUB_CMDLINE_LINUX=&amp;quot;&amp;quot;&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>修改为
&lt;ul>
&lt;li>GRUB_CMDLINE_LINUX=&amp;ldquo;net.ifnames=0 biosdevname=0&amp;rdquo;&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>重新生成 grub 引导配置文件
&lt;ul>
&lt;li>grub-mkconfig -o /boot/grub/grub.cfg&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>修改网络配置 ens32 为 eth0
&lt;ul>
&lt;li>vim /etc/netplan/01-netcfg.yaml&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/gvagsg/1616163849544-f4eac668-9a60-40ef-b291-c28f82e1e661.jpeg" alt="">&lt;/p></description></item><item><title>Docs: Linux 内核管理工具</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/x.linux-%E7%AE%A1%E7%90%86/linux-%E5%86%85%E6%A0%B8%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/linux-%E5%86%85%E6%A0%B8%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/x.linux-%E7%AE%A1%E7%90%86/linux-%E5%86%85%E6%A0%B8%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/linux-%E5%86%85%E6%A0%B8%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/</guid><description>
&lt;h1 id="sysctl-控制内核参数">sysctl 控制内核参数&lt;/h1>
&lt;p>详见：&lt;a href="https://www.yuque.com/go/doc/33221566">procps-ng 工具集&lt;/a> 章节中 sysctl 工具介绍&lt;/p>
&lt;h1 id="dmesg--打印或控制内核环形缓冲区">dmesg # 打印或控制内核环形缓冲区&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://man7.org/linux/man-pages/man1/dmesg.1.html">Manual(手册)，dmesg(1)&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>dmesg 命令是用来在 Unix-like 系统中显示内核的相关信息的。dmesg 全称是 display message (or display driver)，即显示信息。默认操作是显示来自内核环形缓冲区的所有消息。&lt;/p>
&lt;p>实际上，dmesg 命令是从内核环形缓冲区中获取数据的。当我们在 Linux 上排除故障时，dmesg 命令会十分方便，它能很好地帮我们鉴别硬件相关的 error 和 warning。除此之外，dmesg 命令还能打印出守护进程相关的信息，已帮助我们 debug。&lt;/p>
&lt;h2 id="dmesg-options">dmesg [OPTIONS]&lt;/h2>
&lt;p>&lt;strong>OPTIONS&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>&lt;strong>-L, &amp;ndash;color&lt;/strong> # 输入内容带上颜色。&lt;/li>
&lt;li>&lt;strong>-l, &amp;ndash;level LIST&lt;/strong> # 指定输出的级别，多个级别以逗号分隔。可用的级别有以下几种
&lt;ul>
&lt;li>emerg - system is unusable&lt;/li>
&lt;li>alert - action must be taken immediately&lt;/li>
&lt;li>crit - critical conditions&lt;/li>
&lt;li>err - error conditions&lt;/li>
&lt;li>warn - warning conditions&lt;/li>
&lt;li>notice - normal but significant condition&lt;/li>
&lt;li>info - informational&lt;/li>
&lt;li>debug - debug-level messages&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>-f, &amp;ndash;facility LIST&lt;/strong> # 指定要输出的 &lt;a href="../../%F0%9F%91%806.%E5%8F%AF%E8%A7%82%E6%B5%8B%E6%80%A7/%E6%97%A5%E5%BF%97%E7%B3%BB%E7%BB%9F.md">Facility(设施)&lt;/a>，多个设施以逗号分隔。可用的 Facility 有&lt;a href="https://desistdaydream.github.io/docs/IT%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/6.%E5%8F%AF%E8%A7%82%E6%B5%8B%E6%80%A7/%E6%97%A5%E5%BF%97%E7%B3%BB%E7%BB%9F/%E6%97%A5%E5%BF%97%E7%B3%BB%E7%BB%9F.md">Facility(设施)&lt;/a>ser - random user-level messages
&lt;ul>
&lt;li>mail - mail system&lt;/li>
&lt;li>daemon - system daemons&lt;/li>
&lt;li>auth - security/authorization messages&lt;/li>
&lt;li>syslog - messages generated internally by syslogd&lt;/li>
&lt;li>lpr - line printer subsystem&lt;/li>
&lt;li>news - network news subsystem&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>-H, &amp;ndash;human&lt;/strong> # 启用人类可读的输出。是 &lt;code>--color、--reltime、--nopager&lt;/code> 这三个选项的结合&lt;/li>
&lt;li>&lt;strong>-T, &amp;ndash;ctime&lt;/strong> # 打印人类可读的时间戳。
&lt;ul>
&lt;li>请注意，时间戳记可能不正确！挂起/恢复系统后，用于日志的时间源不会更新。根据引导时间和单调时钟之间的当前增量调整时间戳，这仅适用于上次恢复后打印的消息。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>EXAMPLE&lt;/strong>&lt;/p>
&lt;h1 id="heading">&lt;/h1></description></item><item><title>Docs: Linux 文本处理</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/x.linux-%E7%AE%A1%E7%90%86/linux-%E6%96%87%E6%9C%AC%E5%A4%84%E7%90%86/linux-%E6%96%87%E6%9C%AC%E5%A4%84%E7%90%86/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/x.linux-%E7%AE%A1%E7%90%86/linux-%E6%96%87%E6%9C%AC%E5%A4%84%E7%90%86/linux-%E6%96%87%E6%9C%AC%E5%A4%84%E7%90%86/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;/blockquote>
&lt;p>文本处理三剑客：&lt;/p>
&lt;ul>
&lt;li>grep&lt;/li>
&lt;li>sed&lt;/li>
&lt;li>awk&lt;/li>
&lt;/ul>
&lt;h1 id="cat用于把标准输入的内容输出到屏幕上">cat：用于把标准输入的内容输出到屏幕上&lt;/h1>
&lt;p>Note:如果标准输入的内容是一个文件，那么就把文件中的内容当作标准输入发送给 cat 命令，然后再输出到屏幕上&lt;/p>
&lt;p>执行完 cat 命令后，屏幕上会等待我输入内容，当我输入完成按回车后，会在屏幕上输出同样的内容，这就是 cat 最基本的作用，效果如下图，第一行是我主动输入的，按下回车后，自动输出内容
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/gi5hfh/1616166386092-a6649d83-8e1d-4878-b609-cd9c6c5f90de.jpeg" alt="">&lt;/p>
&lt;h2 id="syntax语法">Syntax(语法)&lt;/h2>
&lt;p>&lt;strong>cat [OPTIONS] [FILE]&lt;/strong>&lt;/p>
&lt;p>OPTIONS&lt;/p>
&lt;ul>
&lt;li>**-A, &amp;ndash;show-all **# 与 -vET 选项的效果相同&lt;/li>
&lt;li>-b, &amp;ndash;number-nonblank # number nonempty output lines, overrides -n&lt;/li>
&lt;li>&lt;strong>-e&lt;/strong> # 与 -vE 选项的效果相同&lt;/li>
&lt;li>&lt;strong>-E, &amp;ndash;show-ends&lt;/strong> # 在每行末尾显示 $。&lt;/li>
&lt;li>&lt;strong>-n, &amp;ndash;number&lt;/strong> # 显示行号。&lt;/li>
&lt;li>-&lt;strong>s, &amp;ndash;squeeze-blank&lt;/strong> # suppress repeated empty output lines&lt;/li>
&lt;li>&lt;strong>-t&lt;/strong> # equivalent to -vT&lt;/li>
&lt;li>&lt;strong>-T, &amp;ndash;show-tabs&lt;/strong> # 将 TAB 字符显示为 ^|。TAB 字符就是按下键盘 TAB 键产生的内容，是一个制表符。也就是说将空白的制表符以 ^| 形式显示&lt;/li>
&lt;li>-u (ignored)&lt;/li>
&lt;li>&lt;strong>-v, &amp;ndash;show-nonprinting&lt;/strong> # 常用于查看该文件的换行符是否是 windows 下的 ^M。use ^ and M- notation, except for LFD and TAB&lt;/li>
&lt;/ul>
&lt;p>EXAMPLE&lt;/p>
&lt;ul>
&lt;li>cat -T tab&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">[&lt;/span>root@centos8 ~&lt;span style="color:#f92672">]&lt;/span>&lt;span style="color:#75715e"># cat tab&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>123 &lt;span style="color:#ae81ff">123&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">[&lt;/span>root@centos8 ~&lt;span style="color:#f92672">]&lt;/span>&lt;span style="color:#75715e"># cat -T tab&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>123^I123
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ul>
&lt;li>将多个文件的内容合并到一个文件
&lt;ul>
&lt;li>cat /data/users_* &amp;gt; users.sql&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>cat 命令可以与输入输出重定向配合向文件中写入内容，效果如下&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">[&lt;/span>root@lichenhao ~&lt;span style="color:#f92672">]&lt;/span>&lt;span style="color:#75715e"># cat test&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">123&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">[&lt;/span>root@lichenhao ~&lt;span style="color:#f92672">]&lt;/span>&lt;span style="color:#75715e"># cat &amp;gt;&amp;gt; test &amp;lt;&amp;lt; EOF&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&amp;gt; &lt;span style="color:#ae81ff">234&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&amp;gt; $456
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&amp;gt; &lt;span style="color:#ae81ff">\$&lt;/span>&lt;span style="color:#f92672">{&lt;/span>456&lt;span style="color:#f92672">}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&amp;gt; EOF
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">[&lt;/span>root@lichenhao ~&lt;span style="color:#f92672">]&lt;/span>&lt;span style="color:#75715e"># cat test&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">123&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">234&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">56&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">${&lt;/span>456&lt;span style="color:#e6db74">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Note：如果想要写入变量，则需要加上转义符号\，否则会出现引用变量效果，而如果变量没定义，则引用位置为空&lt;/p>
&lt;h1 id="tail--输出文件的最后一部分内容">tail # 输出文件的最后一部分内容&lt;/h1>
&lt;p>&lt;strong>tail [OPTIONS]&lt;/strong>&lt;/p>
&lt;p>EXAMPLE&lt;/p>
&lt;ul>
&lt;li>tail -f # 实时查看文件尾部的行，有新增的也显示出来，用于监控日志的新增内容&lt;/li>
&lt;/ul>
&lt;h1 id="column-将标准输出格式化为多个列">column 将标准输出格式化为多个列&lt;/h1>
&lt;p>column 工具将其输入格式化为多个列。 行在列之前填充。 输入来自文件，或者默认情况下来自标准输入。 空行将被忽略。&lt;/p>
&lt;h2 id="syntax语法-1">Syntax(语法)&lt;/h2>
&lt;p>&lt;strong>column [OPTIONS] FILE&amp;hellip;&lt;/strong>&lt;/p>
&lt;p>OPTIONS&lt;/p>
&lt;ul>
&lt;li>&lt;strong>-c, &amp;ndash;columns width&lt;/strong> # Output is formatted to a width specified as number of characters.&lt;/li>
&lt;li>&lt;strong>-t, &amp;ndash;table&lt;/strong> # Determine the number of columns the input contains and create a table. Columns are delimited with whitespace, by default, or with the characters supplied using the separator. Table output is useful pretty-printing.&lt;/li>
&lt;li>&lt;strong>-s, &amp;ndash;separator separators&lt;/strong> # Specify possible table delimiters (default is whitespace).&lt;/li>
&lt;li>&lt;strong>-o, &amp;ndash;output-separator separators&lt;/strong> # Specify table output delimiter (default is two whitespaces).&lt;/li>
&lt;li>&lt;strong>-x, &amp;ndash;fillrows&lt;/strong> # Fill columns before filling rows.&lt;/li>
&lt;/ul>
&lt;h2 id="example">EXAMPLE&lt;/h2>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>~&lt;span style="color:#f92672">]&lt;/span>&lt;span style="color:#75715e"># docker ps --format {{.Image}}\\t{{.Names}}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>goharbor/harbor-jobservice:v1.9.3 harbor-jobservice
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>goharbor/nginx-photon:v1.9.3 nginx
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>goharbor/harbor-core:v1.9.3 harbor-core
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>goharbor/harbor-registryctl:v1.9.3 registryctl
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>goharbor/registry-photon:v2.7.1-patch-2819-2553-v1.9.3 registry
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>~&lt;span style="color:#f92672">]&lt;/span>&lt;span style="color:#75715e"># docker ps --format {{.Image}}\\t{{.Names}} | column -t&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>goharbor/harbor-jobservice:v1.9.3 harbor-jobservice
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>goharbor/nginx-photon:v1.9.3 nginx
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>goharbor/harbor-core:v1.9.3 harbor-core
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>goharbor/harbor-registryctl:v1.9.3 registryctl
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>goharbor/registry-photon:v2.7.1-patch-2819-2553-v1.9.3 registry
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h1 id="wc-行数统计">wc #行数统计&lt;/h1>
&lt;p>&lt;strong>wc[OPTIONS] FILE&lt;/strong>
OPTIONS&lt;/p>
&lt;ul>
&lt;li>-l # 统计行数&lt;/li>
&lt;li>-L # 统计字符数&lt;/li>
&lt;li>-w # 统计单词数&lt;/li>
&lt;li>-c # 统计字节&lt;/li>
&lt;/ul>
&lt;h1 id="tr--转换或删除字符">tr # 转换或删除字符&lt;/h1>
&lt;p>转换，压缩和/或删除标准输入中的字符，写入标准输出。&lt;/p>
&lt;h2 id="syntax语法-2">Syntax(语法)&lt;/h2>
&lt;p>&lt;strong>tr [OPTION]&amp;hellip; SET1 [SET2]&lt;/strong>
默认情况，不加任何参数的话，tr 命令会把 SET1 转换为 SET2&lt;/p>
&lt;p>OPTIONS&lt;/p>
&lt;ul>
&lt;li>&lt;strong>-d,&amp;ndash;delete&lt;/strong> # 删除 SET1 中的字符，不转换他们&lt;/li>
&lt;/ul>
&lt;p>EXAMPLE&lt;/p>
&lt;ul>
&lt;li>把 echo 输出内容的所有大写字母转换成小写字母
&lt;ul>
&lt;li>echo &amp;ldquo;HELLO WORLD&amp;rdquo; | tr &amp;lsquo;A-Z&amp;rsquo; &amp;lsquo;a-z&amp;rsquo;&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>删除 JoinNodeCMD 变量中的 \r 的换行符。
&lt;ul>
&lt;li>echo ${JoinNodeCMD} | tr -d &amp;ldquo;\r&amp;rdquo;&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>删除结果中的 &lt;code>&amp;quot;&lt;/code> 双引号
&lt;ul>
&lt;li>docker inspect snmp-exporter | jq .[0].GraphDriver.Data.MergedDir | tr -d &amp;quot;&amp;quot;&amp;quot;&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/gi5hfh/1616166386079-058c4b7f-d68f-4896-9f61-307cc928833b.jpeg" alt="">&lt;/p>
&lt;ul>
&lt;li>以默认分隔符展示每 3 个 ARGS 为一行，替换空格符为冒号&lt;/li>
&lt;/ul>
&lt;h1 id="cut--根据制定的分隔符切片并显示出需要显示的片">cut # 根据制定的分隔符切片，并显示出需要显示的片&lt;/h1>
&lt;h2 id="syntax语法-3">Syntax(语法)&lt;/h2>
&lt;p>OPTIONS&lt;/p>
&lt;ul>
&lt;li>&lt;strong>-d&amp;lt;分隔符&amp;gt;&lt;/strong> # 指定分隔符是什么&lt;/li>
&lt;li>&lt;strong>-f&amp;lt;数字&amp;gt;&lt;/strong> # 指定要显示的字段是分隔符分割成的第几个字段&lt;/li>
&lt;li>单个数字 # 一个字段&lt;/li>
&lt;li>多个离散字段 # 逗号分隔&lt;/li>
&lt;li>多个连续字段 # -分隔&lt;/li>
&lt;/ul>
&lt;h2 id="example-1">EXAMPLE&lt;/h2>
&lt;ul>
&lt;li>显示 passwd 文件中，以冒号为分隔符的第一个字段的内容
&lt;ul>
&lt;li>cut -d: -f1 /etc/passwd&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h1 id="sort--按字符进行比较">sort # 按字符进行比较&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://man7.org/linux/man-pages/man1/sort.1.html">Manual(手册),sort(1)&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;h2 id="syntax语法-4">Syntax(语法)&lt;/h2>
&lt;p>&lt;strong>sort[OPTIONS] FILE&lt;/strong>
OPTIONS:&lt;/p>
&lt;ul>
&lt;li>&lt;strong>-f, &amp;ndash;ignore-case&lt;/strong> # 忽略大小写&lt;/li>
&lt;li>&lt;strong>-h, &amp;ndash;human-numeric-sort&lt;/strong> # 带单位进行比较，比如 2K、1G 等等&lt;/li>
&lt;li>&lt;strong>-n, &amp;ndash;numeric-sort&lt;/strong> # 对数字进行排序（如果没有数字则需要后面的选项指定出来数字，按照以分隔符分割的行中的第几个字段比较）&lt;/li>
&lt;li>&lt;strong>-r, &amp;ndash;reverse&lt;/strong> # 以相反的顺序排序&lt;/li>
&lt;li>&lt;strong>-t, &amp;ndash;field-separator &lt;!-- raw HTML omitted -->&lt;/strong> # 指定分隔符为 SEQ。&lt;code>默认值：空白字符&lt;/code>&lt;/li>
&lt;li>&lt;strong>-k, &amp;ndash;key &amp;lt;开始字段数[.该段第几字符,结束字段数，该段第几字符]&amp;gt;&lt;/strong> # 指定分隔后进行比较的第几字段,默认根据第一个字段的第一个字符(即行首)进行排序
&lt;ul>
&lt;li>用法如下图，蓝色框是第一字段，红色框是第一字段的第二个字符,以：作为分隔符&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/gi5hfh/1616166387159-12db238c-77dd-4d89-823d-fdd075b49b9a.jpeg" alt="">&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>-u, &amp;ndash;unique&lt;/strong> # 重复的行，只显示一行&lt;/li>
&lt;/ul>
&lt;h1 id="uniq--移除重复的行">uniq # 移除重复的行&lt;/h1>
&lt;p>OPTIONS&lt;/p>
&lt;ul>
&lt;li>&lt;strong>-c&lt;/strong> # 统计每一行出现的次数（靠着的行）&lt;/li>
&lt;li>&lt;strong>-d&lt;/strong> # 仅显示出现最少两次的行&lt;/li>
&lt;li>&lt;strong>-u&lt;/strong> # 仅显示不重复的行&lt;/li>
&lt;/ul>
&lt;h1 id="split--文件切割">split # 文件切割&lt;/h1>
&lt;h2 id="syntax语法-5">Syntax(语法)&lt;/h2>
&lt;p>&lt;strong>split [-a] [-d] [-l &amp;lt;行数&amp;gt;] [-b &amp;lt;字节&amp;gt;] [-C &amp;lt;字节&amp;gt;] [要切割的文件] [输出文件名]&lt;/strong>&lt;/p>
&lt;p>&lt;strong>OPTIONS&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>**-a **# 指定输出文件名的后缀长度(默认为 2 个:aa,ab&amp;hellip;)&lt;/li>
&lt;li>&lt;strong>-d&lt;/strong> # 指定输出文件名的后缀用数字代替&lt;/li>
&lt;li>&lt;strong>-l&lt;/strong> # 行数分割模式(指定每多少行切成一个小文件;默认行数是 1000 行)&lt;/li>
&lt;li>&lt;strong>-b&lt;/strong> # 二进制分割模式(支持单位:k/m)&lt;/li>
&lt;li>**-C **# 文件大小分割模式(切割时尽量维持每行的完整性)&lt;/li>
&lt;/ul>
&lt;p>EXAMPLE&lt;/p>
&lt;ul>
&lt;li>行切割文件
&lt;ul>
&lt;li>split -l 300000 users.sql /data/users_&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>使用数字后缀
&lt;ul>
&lt;li>split -d -l 300000 users.sql /data/users_&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>按字节大小分割
&lt;ul>
&lt;li>split -d -b 100m users.sql /data/users_&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>如果你有一个很大的文件，你想把其分割成一些小的文件，那么这个命令就是干这件事的了。&lt;/p>
&lt;p>[hchen@RHELSVR5 applebak]# ls -l largefile.tar.gz-rw-r&amp;ndash;r&amp;ndash; 1 hchen hchen 436774774 04-17 02:00 largefile.tar.gz&lt;/p>
&lt;p>[hchen@RHELSVR5 applebak]# split -b 50m largefile.tar.gz LF_&lt;/p>
&lt;p>[hchen@RHELSVR5]# ls -l LF_*-rw-r&amp;ndash;r&amp;ndash; 1 hchen hchen 52428800 05-10 18:34 LF_aa-rw-r&amp;ndash;r&amp;ndash; 1 hchen hchen 52428800 05-10 18:34 LF_ab-rw-r&amp;ndash;r&amp;ndash; 1 hchen hchen 52428800 05-10 18:34 LF_ac-rw-r&amp;ndash;r&amp;ndash; 1 hchen hchen 52428800 05-10 18:34 LF_ad-rw-r&amp;ndash;r&amp;ndash; 1 hchen hchen 52428800 05-10 18:34 LF_ae-rw-r&amp;ndash;r&amp;ndash; 1 hchen hchen 52428800 05-10 18:35 LF_af-rw-r&amp;ndash;r&amp;ndash; 1 hchen hchen 52428800 05-10 18:35 LF_ag-rw-r&amp;ndash;r&amp;ndash; 1 hchen hchen 52428800 05-10 18:35 LF_ah-rw-r&amp;ndash;r&amp;ndash; 1 hchen hchen 17344374 05-10 18:35 LF_ai&lt;/p>
&lt;p>文件合并只需要使用简单的合并就行了，如：&lt;/p>
&lt;p>[hchen@RHELSVR5]# cat LF_* &amp;gt;largefile.tar.gz&lt;/p></description></item><item><title>Docs: Linux 硬件信息获取</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/x.linux-%E7%AE%A1%E7%90%86/linux-%E7%A1%AC%E4%BB%B6%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/linux-%E7%A1%AC%E4%BB%B6%E4%BF%A1%E6%81%AF%E8%8E%B7%E5%8F%96/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/x.linux-%E7%AE%A1%E7%90%86/linux-%E7%A1%AC%E4%BB%B6%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/linux-%E7%A1%AC%E4%BB%B6%E4%BF%A1%E6%81%AF%E8%8E%B7%E5%8F%96/</guid><description>
&lt;blockquote>
&lt;p>参考：&lt;a href="https://jouyouyun.github.io/post/linux_hardware_info/">原文&lt;/a>&lt;/p>
&lt;/blockquote>
&lt;h1 id="linux-硬件信息获取">Linux 硬件信息获取&lt;/h1>
&lt;p>在 &lt;code>linux&lt;/code> 上可以通过 &lt;code>dmidecode&lt;/code> 或是 &lt;code>lshw&lt;/code> 来获取硬件信息，能够方便的查看系统配置。但它们的输出信息过多，解析起来有些麻烦，另外 &lt;code>lshw&lt;/code> 对 &lt;code>usb&lt;/code> 接口的网卡支持不好，显示的信息不够，所以在此整理下通过读文件或是一些简单命令来获取硬件信息的方法。&lt;/p>
&lt;h2 id="dmi">DMI&lt;/h2>
&lt;p>一般情况下内核默认加载了 &lt;code>dmi sysfs&lt;/code> ，路径是 &lt;code>/sys/class/dmi&lt;/code> 。里面包含了 &lt;code>bios&lt;/code> ， &lt;code>board&lt;/code> ， &lt;code>product&lt;/code> 等信息。&lt;/p>
&lt;h3 id="bios">Bios&lt;/h3>
&lt;p>通过命令 &lt;code>ls -l /sys/class/dmi/id/bios_*&lt;/code> 可以看到支持的 &lt;code>bios&lt;/code> 字段，如下：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">[&lt;/span>root@host-3 ~&lt;span style="color:#f92672">]&lt;/span>&lt;span style="color:#75715e"># ls -l /sys/class/dmi/id/bios_*&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>-r--r--r-- &lt;span style="color:#ae81ff">1&lt;/span> root root &lt;span style="color:#ae81ff">4096&lt;/span> Feb &lt;span style="color:#ae81ff">3&lt;/span> 10:45 /sys/class/dmi/id/bios_date
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>-r--r--r-- &lt;span style="color:#ae81ff">1&lt;/span> root root &lt;span style="color:#ae81ff">4096&lt;/span> Feb &lt;span style="color:#ae81ff">3&lt;/span> 10:45 /sys/class/dmi/id/bios_vendor
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>-r--r--r-- &lt;span style="color:#ae81ff">1&lt;/span> root root &lt;span style="color:#ae81ff">4096&lt;/span> Feb &lt;span style="color:#ae81ff">3&lt;/span> 10:45 /sys/class/dmi/id/bios_version
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>直接读文件即可获取对应值。&lt;/p>
&lt;h3 id="board">Board&lt;/h3>
&lt;p>通过命令 &lt;code>ls -l /sys/class/dmi/id/board_*&lt;/code> 可以看到支持的 &lt;code>board&lt;/code> 字段，如下：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">[&lt;/span>root@host-3 ~&lt;span style="color:#f92672">]&lt;/span>&lt;span style="color:#75715e"># ls -l /sys/class/dmi/id/board_*&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>-r--r--r-- &lt;span style="color:#ae81ff">1&lt;/span> root root &lt;span style="color:#ae81ff">4096&lt;/span> Mar &lt;span style="color:#ae81ff">21&lt;/span> 20:28 /sys/class/dmi/id/board_asset_tag
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>-r--r--r-- &lt;span style="color:#ae81ff">1&lt;/span> root root &lt;span style="color:#ae81ff">4096&lt;/span> Mar &lt;span style="color:#ae81ff">21&lt;/span> 20:28 /sys/class/dmi/id/board_name
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>-r-------- &lt;span style="color:#ae81ff">1&lt;/span> root root &lt;span style="color:#ae81ff">4096&lt;/span> Mar &lt;span style="color:#ae81ff">21&lt;/span> 20:28 /sys/class/dmi/id/board_serial
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>-r--r--r-- &lt;span style="color:#ae81ff">1&lt;/span> root root &lt;span style="color:#ae81ff">4096&lt;/span> Mar &lt;span style="color:#ae81ff">21&lt;/span> 20:28 /sys/class/dmi/id/board_vendor
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>-r--r--r-- &lt;span style="color:#ae81ff">1&lt;/span> root root &lt;span style="color:#ae81ff">4096&lt;/span> Mar &lt;span style="color:#ae81ff">21&lt;/span> 20:28 /sys/class/dmi/id/board_version
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>直接读文件即可获取对应值，但有些文件需要 &lt;code>root&lt;/code> 权限。&lt;/p>
&lt;h3 id="product">Product&lt;/h3>
&lt;p>通过命令 &lt;code>ls -l /sys/class/dmi/id/product_*&lt;/code> 可以看到支持的 &lt;code>product&lt;/code> 字段，如下：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">[&lt;/span>root@host-3 ~&lt;span style="color:#f92672">]&lt;/span>&lt;span style="color:#75715e"># ls -l /sys/class/dmi/id/product_*&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>-r--r--r-- &lt;span style="color:#ae81ff">1&lt;/span> root root &lt;span style="color:#ae81ff">4096&lt;/span> Feb &lt;span style="color:#ae81ff">3&lt;/span> 10:45 /sys/class/dmi/id/product_name
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>-r-------- &lt;span style="color:#ae81ff">1&lt;/span> root root &lt;span style="color:#ae81ff">4096&lt;/span> Feb &lt;span style="color:#ae81ff">3&lt;/span> 10:45 /sys/class/dmi/id/product_serial
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>-r-------- &lt;span style="color:#ae81ff">1&lt;/span> root root &lt;span style="color:#ae81ff">4096&lt;/span> Mar &lt;span style="color:#ae81ff">21&lt;/span> 20:28 /sys/class/dmi/id/product_uuid
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>-r--r--r-- &lt;span style="color:#ae81ff">1&lt;/span> root root &lt;span style="color:#ae81ff">4096&lt;/span> Feb &lt;span style="color:#ae81ff">3&lt;/span> 10:45 /sys/class/dmi/id/product_version
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>直接读文件即可获取对应值，但有些文件需要 &lt;code>root&lt;/code> 权限。
其中 &lt;code>product_uuid&lt;/code> 可作为机器的唯一 &lt;code>ID&lt;/code> 。&lt;/p>
&lt;h2 id="cpu">CPU&lt;/h2>
&lt;p>通过读取文件 &lt;code>/proc/cpuinfo&lt;/code> 可获取 &lt;code>cpu&lt;/code> 的信息，一般 &lt;code>model name&lt;/code> 字段为 &lt;code>cpu&lt;/code> 名称，如：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">[&lt;/span>root@host-3 ~&lt;span style="color:#f92672">]&lt;/span>&lt;span style="color:#75715e"># cat /proc/cpuinfo|grep &amp;#39;model name&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>model name : Intel&lt;span style="color:#f92672">(&lt;/span>R&lt;span style="color:#f92672">)&lt;/span> Xeon&lt;span style="color:#f92672">(&lt;/span>R&lt;span style="color:#f92672">)&lt;/span> Gold &lt;span style="color:#ae81ff">5218&lt;/span> CPU @ 2.30GHz
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>model name : Intel&lt;span style="color:#f92672">(&lt;/span>R&lt;span style="color:#f92672">)&lt;/span> Xeon&lt;span style="color:#f92672">(&lt;/span>R&lt;span style="color:#f92672">)&lt;/span> Gold &lt;span style="color:#ae81ff">5218&lt;/span> CPU @ 2.30GHz
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>model name : Intel&lt;span style="color:#f92672">(&lt;/span>R&lt;span style="color:#f92672">)&lt;/span> Xeon&lt;span style="color:#f92672">(&lt;/span>R&lt;span style="color:#f92672">)&lt;/span> Gold &lt;span style="color:#ae81ff">5218&lt;/span> CPU @ 2.30GHz
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>model name : Intel&lt;span style="color:#f92672">(&lt;/span>R&lt;span style="color:#f92672">)&lt;/span> Xeon&lt;span style="color:#f92672">(&lt;/span>R&lt;span style="color:#f92672">)&lt;/span> Gold &lt;span style="color:#ae81ff">5218&lt;/span> CPU @ 2.30GHz
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>model name : Intel&lt;span style="color:#f92672">(&lt;/span>R&lt;span style="color:#f92672">)&lt;/span> Xeon&lt;span style="color:#f92672">(&lt;/span>R&lt;span style="color:#f92672">)&lt;/span> Gold &lt;span style="color:#ae81ff">5218&lt;/span> CPU @ 2.30GHz
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>model name : Intel&lt;span style="color:#f92672">(&lt;/span>R&lt;span style="color:#f92672">)&lt;/span> Xeon&lt;span style="color:#f92672">(&lt;/span>R&lt;span style="color:#f92672">)&lt;/span> Gold &lt;span style="color:#ae81ff">5218&lt;/span> CPU @ 2.30GHz
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>......
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;strong>但在龙芯，申威上可能不是这个字段，需要根据文件内容确定。&lt;/strong>&lt;/p>
&lt;h2 id="memory">Memory&lt;/h2>
&lt;p>通过读取文件 &lt;code>/proc/meminfo&lt;/code> 可获取内存总大小，字段是 &lt;code>MemTotal&lt;/code> ，如：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">[&lt;/span>root@host-3 ~&lt;span style="color:#f92672">]&lt;/span>&lt;span style="color:#75715e"># cat /proc/meminfo |grep MemTotal&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>MemTotal: &lt;span style="color:#ae81ff">263570816&lt;/span> kB
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;strong>对于内存厂商等信息还未找到获取方法，待以后补全。&lt;/strong>&lt;/p>
&lt;h2 id="disk">Disk&lt;/h2>
&lt;p>硬盘信息这里使用 &lt;code>lsblk&lt;/code> 来获取，通过指定它的参数来获取，如：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-json" data-lang="json">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#960050;background-color:#1e0010">$&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">lsblk&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">-J&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">-bno&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">NAME,SERIAL,TYPE,SIZE,VENDOR,MODEL,MOUNTPOINT,UUID&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;blockdevices&amp;#34;&lt;/span>: [
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {&lt;span style="color:#f92672">&amp;#34;name&amp;#34;&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;sda&amp;#34;&lt;/span>, &lt;span style="color:#f92672">&amp;#34;serial&amp;#34;&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;TF0500WE0GAV0V&amp;#34;&lt;/span>, &lt;span style="color:#f92672">&amp;#34;type&amp;#34;&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;disk&amp;#34;&lt;/span>, &lt;span style="color:#f92672">&amp;#34;size&amp;#34;&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;500107862016&amp;#34;&lt;/span>, &lt;span style="color:#f92672">&amp;#34;vendor&amp;#34;&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;ATA &amp;#34;&lt;/span>, &lt;span style="color:#f92672">&amp;#34;model&amp;#34;&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;HGST HTS725050A7&amp;#34;&lt;/span>, &lt;span style="color:#f92672">&amp;#34;mountpoint&amp;#34;&lt;/span>: &lt;span style="color:#66d9ef">null&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;children&amp;#34;&lt;/span>: [
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {&lt;span style="color:#f92672">&amp;#34;name&amp;#34;&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;sda1&amp;#34;&lt;/span>, &lt;span style="color:#f92672">&amp;#34;serial&amp;#34;&lt;/span>: &lt;span style="color:#66d9ef">null&lt;/span>, &lt;span style="color:#f92672">&amp;#34;type&amp;#34;&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;part&amp;#34;&lt;/span>, &lt;span style="color:#f92672">&amp;#34;size&amp;#34;&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;4294967296&amp;#34;&lt;/span>, &lt;span style="color:#f92672">&amp;#34;vendor&amp;#34;&lt;/span>: &lt;span style="color:#66d9ef">null&lt;/span>, &lt;span style="color:#f92672">&amp;#34;model&amp;#34;&lt;/span>: &lt;span style="color:#66d9ef">null&lt;/span>, &lt;span style="color:#f92672">&amp;#34;mountpoint&amp;#34;&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;/boot&amp;#34;&lt;/span>},
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {&lt;span style="color:#f92672">&amp;#34;name&amp;#34;&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;sda2&amp;#34;&lt;/span>, &lt;span style="color:#f92672">&amp;#34;serial&amp;#34;&lt;/span>: &lt;span style="color:#66d9ef">null&lt;/span>, &lt;span style="color:#f92672">&amp;#34;type&amp;#34;&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;part&amp;#34;&lt;/span>, &lt;span style="color:#f92672">&amp;#34;size&amp;#34;&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;4294967296&amp;#34;&lt;/span>, &lt;span style="color:#f92672">&amp;#34;vendor&amp;#34;&lt;/span>: &lt;span style="color:#66d9ef">null&lt;/span>, &lt;span style="color:#f92672">&amp;#34;model&amp;#34;&lt;/span>: &lt;span style="color:#66d9ef">null&lt;/span>, &lt;span style="color:#f92672">&amp;#34;mountpoint&amp;#34;&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;[SWAP]&amp;#34;&lt;/span>},
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {&lt;span style="color:#f92672">&amp;#34;name&amp;#34;&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;sda3&amp;#34;&lt;/span>, &lt;span style="color:#f92672">&amp;#34;serial&amp;#34;&lt;/span>: &lt;span style="color:#66d9ef">null&lt;/span>, &lt;span style="color:#f92672">&amp;#34;type&amp;#34;&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;part&amp;#34;&lt;/span>, &lt;span style="color:#f92672">&amp;#34;size&amp;#34;&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;1024&amp;#34;&lt;/span>, &lt;span style="color:#f92672">&amp;#34;vendor&amp;#34;&lt;/span>: &lt;span style="color:#66d9ef">null&lt;/span>, &lt;span style="color:#f92672">&amp;#34;model&amp;#34;&lt;/span>: &lt;span style="color:#66d9ef">null&lt;/span>, &lt;span style="color:#f92672">&amp;#34;mountpoint&amp;#34;&lt;/span>: &lt;span style="color:#66d9ef">null&lt;/span>},
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {&lt;span style="color:#f92672">&amp;#34;name&amp;#34;&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;sda5&amp;#34;&lt;/span>, &lt;span style="color:#f92672">&amp;#34;serial&amp;#34;&lt;/span>: &lt;span style="color:#66d9ef">null&lt;/span>, &lt;span style="color:#f92672">&amp;#34;type&amp;#34;&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;part&amp;#34;&lt;/span>, &lt;span style="color:#f92672">&amp;#34;size&amp;#34;&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;107374182400&amp;#34;&lt;/span>, &lt;span style="color:#f92672">&amp;#34;vendor&amp;#34;&lt;/span>: &lt;span style="color:#66d9ef">null&lt;/span>, &lt;span style="color:#f92672">&amp;#34;model&amp;#34;&lt;/span>: &lt;span style="color:#66d9ef">null&lt;/span>, &lt;span style="color:#f92672">&amp;#34;mountpoint&amp;#34;&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;/Data&amp;#34;&lt;/span>},
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {&lt;span style="color:#f92672">&amp;#34;name&amp;#34;&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;sda6&amp;#34;&lt;/span>, &lt;span style="color:#f92672">&amp;#34;serial&amp;#34;&lt;/span>: &lt;span style="color:#66d9ef">null&lt;/span>, &lt;span style="color:#f92672">&amp;#34;type&amp;#34;&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;part&amp;#34;&lt;/span>, &lt;span style="color:#f92672">&amp;#34;size&amp;#34;&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;64424509440&amp;#34;&lt;/span>, &lt;span style="color:#f92672">&amp;#34;vendor&amp;#34;&lt;/span>: &lt;span style="color:#66d9ef">null&lt;/span>, &lt;span style="color:#f92672">&amp;#34;model&amp;#34;&lt;/span>: &lt;span style="color:#66d9ef">null&lt;/span>, &lt;span style="color:#f92672">&amp;#34;mountpoint&amp;#34;&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;/&amp;#34;&lt;/span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>参数的含义通过 &lt;code>lsblk -h&lt;/code> 命令查看。
&lt;strong>只有 &lt;strong>&lt;code>**type**&lt;/code>&lt;/strong> 为 &lt;strong>&lt;code>**disk**&lt;/code>&lt;/strong> 时才表示为一块硬盘，其它如 &lt;strong>&lt;code>**loop**&lt;/code>&lt;/strong> 则应该过滤掉。&lt;/strong> 每块硬盘中的 &lt;code>children&lt;/code> 表示它下面的分区，通过 &lt;code>mountpoint&lt;/code> 可确定硬盘在此系统上的使用情况。&lt;/p>
&lt;p>&lt;code>lsscsi&lt;/code>&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">[&lt;/span>root@host-2 ~&lt;span style="color:#f92672">]&lt;/span>&lt;span style="color:#75715e"># lsscsi&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">[&lt;/span>0:0:16:0&lt;span style="color:#f92672">]&lt;/span> enclosu MSCC SXP 36x12G RevB -
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">[&lt;/span>0:2:0:0&lt;span style="color:#f92672">]&lt;/span> disk AVAGO MR9361-8i 4.68 /dev/sda
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">[&lt;/span>0:2:1:0&lt;span style="color:#f92672">]&lt;/span> disk AVAGO MR9361-8i 4.68 /dev/sdb
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="network">Network&lt;/h2>
&lt;p>简单直接：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>lspci | grep -i Ethernet
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>这里是先获取系统上的网络接口，这包括了物理网卡和虚拟网卡(如 &lt;code>docker&lt;/code> 创建的)。
~~所以要先过滤，过滤顺序如下：~~
~~1. 按名字过滤~~
~~过滤掉 &lt;del>&lt;code>~~lo~~&lt;/code>
~~2. 按驱动过滤&lt;/del>
~~过滤掉驱动为 &lt;del>&lt;code>~~dummy, veth, vboxnet, vmnet, vmxnet, vmxnet2, vmxnet3~~&lt;/code>&lt;/del> 的网卡, 虚拟机中的~~
~~3. 按网卡类型过滤~~
~~过滤掉 &lt;del>&lt;code>~~bridge~~&lt;/code>&lt;/del> 类型的网卡~~
如果网卡接口同时存在于 &lt;code>/sys/class/net/&lt;/code> 和 &lt;code>/sys/devices/virtual/net/&lt;/code> 中，则需要过滤掉。
接下来分别给出网卡信息获取的方法：&lt;/p>
&lt;h4 id="interface-name">&lt;strong>Interface Name&lt;/strong>&lt;/h4>
&lt;p>即是上面的目录下的子目录名&lt;/p>
&lt;h4 id="mac-address">&lt;strong>Mac Address&lt;/strong>&lt;/h4>
&lt;p>读取文件 &lt;code>/sys/class/net/&amp;lt;iface name&amp;gt;/address&lt;/code> 可得到&lt;/p>
&lt;h4 id="ip">&lt;strong>IP&lt;/strong>&lt;/h4>
&lt;p>通过调用 &lt;code>ioctl&lt;/code> 来获取指定 &lt;code>iface name&lt;/code> 的 &lt;code>ip&lt;/code> ，代码大致如下：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-c" data-lang="c">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">char&lt;/span>&lt;span style="color:#f92672">*&lt;/span> &lt;span style="color:#a6e22e">get_ip_for_iface&lt;/span>(&lt;span style="color:#66d9ef">char&lt;/span> &lt;span style="color:#f92672">*&lt;/span>iface)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> fd;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">struct&lt;/span> ifreq ifr;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> fd &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#a6e22e">socket&lt;/span>(AF_INET, SOCK_DGRAM, &lt;span style="color:#ae81ff">0&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (fd &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#f92672">-&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">fprintf&lt;/span>(stderr, &lt;span style="color:#e6db74">&amp;#34;open socket failed: %s&amp;#34;&lt;/span>, &lt;span style="color:#a6e22e">strerror&lt;/span>(errno));
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// must init ifr
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#a6e22e">memset&lt;/span>(&lt;span style="color:#f92672">&amp;amp;&lt;/span>ifr, &lt;span style="color:#ae81ff">0&lt;/span>, &lt;span style="color:#66d9ef">sizeof&lt;/span>(ifr));
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ifr.ifr_addr.sa_family &lt;span style="color:#f92672">=&lt;/span> AF_INET;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">strncpy&lt;/span>(ifr.ifr_name, name.&lt;span style="color:#a6e22e">c_str&lt;/span>(), IFNAMSIZ &lt;span style="color:#f92672">-&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">ioctl&lt;/span>(fd, SIOCGIFADDR, &lt;span style="color:#f92672">&amp;amp;&lt;/span>ifr);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">close&lt;/span>(fd);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">char&lt;/span> &lt;span style="color:#f92672">*&lt;/span>c_addr &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#a6e22e">inet_ntoa&lt;/span>(((&lt;span style="color:#66d9ef">struct&lt;/span> sockaddr_in &lt;span style="color:#f92672">*&lt;/span>)&lt;span style="color:#f92672">&amp;amp;&lt;/span>ifr.ifr_addr)&lt;span style="color:#f92672">-&amp;gt;&lt;/span>sin_addr);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">char&lt;/span> &lt;span style="color:#f92672">*&lt;/span>ip &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#a6e22e">calloc&lt;/span>(&lt;span style="color:#a6e22e">strlen&lt;/span>(c_addr)&lt;span style="color:#f92672">+&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>, &lt;span style="color:#66d9ef">sizeof&lt;/span>(&lt;span style="color:#66d9ef">char&lt;/span>));
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">memcpy&lt;/span>(ip, c_addr, &lt;span style="color:#a6e22e">strlen&lt;/span>(c_addr));
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> ip;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;code>ipv6&lt;/code> 的暂未测试。&lt;/p>
&lt;h4 id="model">&lt;strong>Model&lt;/strong>&lt;/h4>
&lt;p>网卡一般在 &lt;code>pci&lt;/code> 接口上，但也有些实在 &lt;code>usb&lt;/code> 接口上，要分别获取。
不过都要先读取文件 &lt;code>/sys/class/net/enp0s25/device/uevent&lt;/code> ，然后分别处理。&lt;/p>
&lt;ul>
&lt;li>&lt;strong>pci&lt;/strong>
&lt;code>uevent&lt;/code> 内容如：&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>DRIVER&lt;span style="color:#f92672">=&lt;/span>e1000e
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>PCI_CLASS&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">20000&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>PCI_ID&lt;span style="color:#f92672">=&lt;/span>8086:1502
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>PCI_SUBSYS_ID&lt;span style="color:#f92672">=&lt;/span>17AA:21F3
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>PCI_SLOT_NAME&lt;span style="color:#f92672">=&lt;/span>0000:00:19.0
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>MODALIAS&lt;span style="color:#f92672">=&lt;/span>pci:v00008086d00001502sv000017AAsd000021F3bc02sc00i00
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ul>
&lt;li>取到其中的 &lt;code>PCI_SLOT_NAME&lt;/code> ，然后执行 &lt;code>lspci -k -s &amp;lt;PCI_SLOT_NAME&amp;gt;&lt;/code> 来获取 &lt;code>model&lt;/code> 信息，如：&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>$ lspci -k -s 0000:00:19.0
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>00:19.0 Ethernet controller: Intel Corporation 82579LM Gigabit Network Connection &lt;span style="color:#f92672">(&lt;/span>Lewisville&lt;span style="color:#f92672">)&lt;/span> &lt;span style="color:#f92672">(&lt;/span>rev 04&lt;span style="color:#f92672">)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Subsystem: Lenovo 82579LM Gigabit Network Connection
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Kernel driver in use: e1000e
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Kernel modules: e1000e
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ul>
&lt;li>其中 &lt;code>Subsystem&lt;/code> 之后的即是 &lt;code>model&lt;/code> 信息。&lt;/li>
&lt;li>&lt;strong>usb&lt;/strong>
&lt;code>uevent&lt;/code> 内容如：&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>DEVTYPE&lt;span style="color:#f92672">=&lt;/span>usb_interface
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>DRIVER&lt;span style="color:#f92672">=&lt;/span>ath9k_htc
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>PRODUCT&lt;span style="color:#f92672">=&lt;/span>cf3/9271/108
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>TYPE&lt;span style="color:#f92672">=&lt;/span>255/255/255
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>INTERFACE&lt;span style="color:#f92672">=&lt;/span>255/0/0
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>MODALIAS&lt;span style="color:#f92672">=&lt;/span>usb:v0CF3p9271d0108dcFFdscFFdpFFicFFisc00ip00in00
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ul>
&lt;li>取到其中的 &lt;code>PRODUCT&lt;/code> ，然后将 &lt;code>/&lt;/code> 替换为 &lt;code>:&lt;/code> ，然后执行 &lt;code>lsusb -d &amp;lt;product&amp;gt;&lt;/code> 来获取 &lt;code>model&lt;/code> 信息，如：&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># 可以不要最后的 &amp;#39;108&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>$ lsusb -d cf3:9271:108
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Bus &lt;span style="color:#ae81ff">001&lt;/span> Device 007: ID 0cf3:9271 Atheros Communications, Inc. AR9271 802.11n
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ul>
&lt;li>其中 &lt;code>Subsystem&lt;/code> 之后的即是 &lt;code>model&lt;/code> 信息。&lt;/li>
&lt;/ul>
&lt;h2 id="bluetooth">Bluetooth&lt;/h2>
&lt;p>在 &lt;code>/sys/class/bluetooth/&lt;/code> 下是蓝牙设备，与 &lt;strong>网卡&lt;/strong> 一样，根据 &lt;code>/sys/class/bluetooth/&amp;lt;hciX&amp;gt;/device/uevent&lt;/code> 的内容使用 &lt;code>lspci&lt;/code> 或 &lt;code>lsusb&lt;/code> 来获取 &lt;code>model&lt;/code> 信息。
如：&lt;/p>
&lt;p>| ```
1
2
3
4
5
6
7&lt;/p>
&lt;pre>&lt;code> | ```
$ cat /sys/class/bluetooth/hci0/device/uevent
DEVTYPE=usb_interface
DRIVER=btusb
PRODUCT=a5c/21e6/112
TYPE=255/1/1
INTERFACE=255/1/1
MODALIAS=usb:v0A5Cp21E6d0112dcFFdsc01dp01icFFisc01ip01in00
&lt;/code>&lt;/pre>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>&lt;/th>
&lt;th>&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;/table>
&lt;p>这就是一个 &lt;code>usb&lt;/code> 接口的设备，所以使用 &lt;code>lsusb&lt;/code> 来获取 &lt;code>model&lt;/code> 信息，如：&lt;/p>
&lt;p>| ```
1
2&lt;/p>
&lt;pre>&lt;code> | ```
$ lsusb -d a5c:21e6:112
Bus 001 Device 003: ID 0a5c:21e6 Broadcom Corp. BCM20702 Bluetooth 4.0 [ThinkPad]
&lt;/code>&lt;/pre>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>&lt;/th>
&lt;th>&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;/table>
&lt;h2 id="graphic">Graphic&lt;/h2>
&lt;p>显卡信息在 &lt;code>/sys/class/drm/&lt;/code> 下，里面还包含了显卡支持输出接口，但只有 &lt;code>card+integer&lt;/code> 组成的目录才是显卡的，如本机的信息：&lt;/p>
&lt;p>| ```
1
2&lt;/p>
&lt;pre>&lt;code> | ```
$ ls /sys/class/drm/
card0@ card0-DP-1@ card0-DP-2@ card0-DP-3@ card0-HDMI-A-1@ card0-HDMI-A-2@ card0-HDMI-A-3@ card0-LVDS-1@ card0-VGA-1@ renderD128@ version
&lt;/code>&lt;/pre>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>&lt;/th>
&lt;th>&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;/table>
&lt;p>根据输出可知只有一块显卡 &lt;code>card0&lt;/code> ，通过读取文件 &lt;code>card0/device/uevent&lt;/code> 获取设备类型，然后同 &lt;strong>网卡&lt;/strong> 一样查询 &lt;code>model&lt;/code> 信息，如：&lt;/p>
&lt;p>| ```
1
2
3
4
5
6
7
8
9
10
11
12
13&lt;/p>
&lt;pre>&lt;code> | ```
$ cat /sys/class/drm/card0/device/uevent
DRIVER=i915
PCI_CLASS=30000
PCI_ID=8086:0166
PCI_SUBSYS_ID=17AA:21FA
PCI_SLOT_NAME=0000:00:02.0
MODALIAS=pci:v00008086d00000166sv000017AAsd000021FAbc03sc00i00
$ lspci -k -s 0000:00:02.0
00:02.0 VGA compatible controller: Intel Corporation 3rd Gen Core processor Graphics Controller (rev 09)
Subsystem: Lenovo 3rd Gen Core processor Graphics Controller
Kernel driver in use: i915
Kernel modules: i915
&lt;/code>&lt;/pre>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>&lt;/th>
&lt;th>&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;/table>
&lt;p>另外 &lt;code>/sys/class/hwmon/&lt;/code> 和 &lt;code>/sys/class/graphics/&lt;/code> 下有当前使用中的显卡设备，也是对应子目录下的 &lt;code>device/uevent&lt;/code> 来获取信息。
若无 &lt;code>device&lt;/code> 目录或是 &lt;code>device/uevent&lt;/code> 中的内容既没有 &lt;code>pci&lt;/code> 信息也没有 &lt;code>usb&lt;/code> 信息，则过滤掉，有就如下所示获取：
&lt;code>**hwmon**&lt;/code>&lt;/p>
&lt;p>| ```
1
2
3
4
5
6
7
8
9
10
11
12
13&lt;/p>
&lt;pre>&lt;code> | ```
$ cat /sys/class/hwmon/hwmon2/device/uevent
DRIVER=nouveau
PCI_CLASS=30000
PCI_ID=10DE:0A75
PCI_SUBSYS_ID=17AA:3957
PCI_SLOT_NAME=0000:02:00.0
MODALIAS=pci:v000010DEd00000A75sv000017AAsd00003957bc03sc00i00
$ lspci -k -s 0000:02:00.0
02:00.0 VGA compatible controller: NVIDIA Corporation GT218M [GeForce 310M] (rev a2)
Subsystem: Lenovo GT218M [GeForce 310M]
Kernel driver in use: nouveau
Kernel modules: nouveau
&lt;/code>&lt;/pre>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>&lt;/th>
&lt;th>&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;/table>
&lt;p>&lt;code>**graphics**&lt;/code>&lt;/p>
&lt;p>| ```
1
2
3
4
5
6
7
8
9
10
11
12
13&lt;/p>
&lt;pre>&lt;code> | ```
$ cat /sys/class/graphics/fb0/device/uevent
DRIVER=i915
PCI_CLASS=30000
PCI_ID=8086:0166
PCI_SUBSYS_ID=17AA:21FA
PCI_SLOT_NAME=0000:00:02.0
MODALIAS=pci:v00008086d00000166sv000017AAsd000021FAbc03sc00i00
$ lspci -k -s 0000:00:02.0
00:02.0 VGA compatible controller: Intel Corporation 3rd Gen Core processor Graphics Controller (rev 09)
Subsystem: Lenovo 3rd Gen Core processor Graphics Controller
Kernel driver in use: i915
Kernel modules: i915
&lt;/code>&lt;/pre>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>&lt;/th>
&lt;th>&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;/table>
&lt;h4 id="display-monitor">Display Monitor&lt;/h4>
&lt;p>显示器的信息目前是从 &lt;code>edid&lt;/code> 中获取，先确定显示器连接的显卡端口，然后使用 &lt;code>edid-decode&lt;/code> (需要安装)解析其的 &lt;code>edid&lt;/code> 文件，就可得到详细信息。如本机是 &lt;code>card0-LVDS-1&lt;/code> ：&lt;/p>
&lt;p>| ```
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40&lt;/p>
&lt;pre>&lt;code> | ```
$ cat /sys/class/drm/card0-LVDS-1/edid|edid-decode
Extracted contents:
header: 00 ff ff ff ff ff ff 00
serial number: 06 af 6c 10 00 00 00 00 00 14
version: 01 04
basic params: 90 1c 10 78 02
chroma info: 20 e5 92 55 54 92 28 25 50 54
established: 00 00 00
standard: 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01
descriptor 1: 12 1b 56 58 50 00 19 30 30 20 36 00 15 9c 10 00 00 18
descriptor 2: 00 00 00 0f 00 00 00 00 00 00 00 00 00 00 00 00 00 20
descriptor 3: 00 00 00 fe 00 41 55 4f 0a 20 20 20 20 20 20 20 20 20
descriptor 4: 00 00 00 fe 00 42 31 32 35 58 57 30 31 20 56 30 20 0a
extensions: 00
checksum: ec
Manufacturer: AUO Model 106c Serial Number 0
Made week 0 of 2010
EDID version: 1.4
Digital display
6 bits per primary color channel
Digital interface is not defined
Maximum image size: 28 cm x 16 cm
Gamma: 2.20
Supported color formats: RGB 4:4:4
First detailed timing is preferred timing
Established timings supported:
Standard timings supported:
Detailed mode: Clock 69.300 MHz, 277 mm x 156 mm
1366 1414 1446 1454 hborder 0
768 771 777 793 vborder 0
-hsync -vsync
Manufacturer-specified data, tag 15
ASCII string: AUO
ASCII string: B125XW01
Checksum: 0xec (valid)
EDID block does NOT conform to EDID 1.3!
Missing name descriptor
Missing monitor ranges
Detailed block string not properly terminated
&lt;/code>&lt;/pre>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>&lt;/th>
&lt;th>&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;/table>
&lt;h2 id="sound">Sound&lt;/h2>
&lt;p>声卡设备在 &lt;code>/sys/class/sound&lt;/code> 目录下，目录名一般是 &lt;code>card+integer&lt;/code> 组成，如本机的信息：&lt;/p>
&lt;p>| ```
1
2&lt;/p>
&lt;pre>&lt;code> | ```
$ ls /sys/class/sound/
card0@ controlC0@ hwC0D0@ hwC0D3@ pcmC0D0c@ pcmC0D0p@ pcmC0D3p@ pcmC0D7p@ pcmC0D8p@ timer@
&lt;/code>&lt;/pre>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>&lt;/th>
&lt;th>&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;/table>
&lt;p>就只有一块声卡 &lt;code>card0&lt;/code> ，通过读取文件 &lt;code>card0/device/uevent&lt;/code> 获取设备类型，然后同 &lt;strong>网卡&lt;/strong> 一样查询 &lt;code>model&lt;/code> 信息，如：&lt;/p>
&lt;p>| ```
1
2
3
4
5
6
7
8
9
10
11
12
13&lt;/p>
&lt;pre>&lt;code> | ```
$ cat /sys/class/sound/card0/device/uevent
DRIVER=snd_hda_intel
PCI_CLASS=40300
PCI_ID=8086:1E20
PCI_SUBSYS_ID=17AA:21FA
PCI_SLOT_NAME=0000:00:1b.0
MODALIAS=pci:v00008086d00001E20sv000017AAsd000021FAbc04sc03i00
$ lspci -k -s 0000:00:1b.0
00:1b.0 Audio device: Intel Corporation 7 Series/C216 Chipset Family High Definition Audio Controller (rev 04)
Subsystem: Lenovo 7 Series/C216 Chipset Family High Definition Audio Controller
Kernel driver in use: snd_hda_intel
Kernel modules: snd_hda_intel
&lt;/code>&lt;/pre>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>&lt;/th>
&lt;th>&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;/table>
&lt;h2 id="inputoutput-device">Input/Output Device&lt;/h2>
&lt;p>输入设备的信息可以从 &lt;code>/proc/bus/input/devices&lt;/code> 文件中获取，如：&lt;/p>
&lt;p>| ```
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34&lt;/p>
&lt;pre>&lt;code> | ```
I: Bus=0019 Vendor=0000 Product=0005 Version=0000
N: Name=&amp;quot;Lid Switch&amp;quot;
P: Phys=PNP0C0D/button/input0
S: Sysfs=/devices/LNXSYSTM:00/LNXSYBUS:00/PNP0C0D:00/input/input0
U: Uniq=
H: Handlers=event0
B: PROP=0
B: EV=21
B: SW=1
I: Bus=0011 Vendor=0001 Product=0001 Version=ab54
N: Name=&amp;quot;AT Translated Set 2 keyboard&amp;quot;
P: Phys=isa0060/serio0/input0
S: Sysfs=/devices/platform/i8042/serio0/input/input3
U: Uniq=
H: Handlers=sysrq kbd event3 leds
B: PROP=0
B: EV=120013
B: KEY=10000 0 0 0 1000402000000 3803078f800d001 feffffdfffefffff fffffffffffffffe
B: MSC=10
B: LED=7
I: Bus=0011 Vendor=0002 Product=0007 Version=01b1
N: Name=&amp;quot;SynPS/2 Synaptics TouchPad&amp;quot;
P: Phys=isa0060/serio1/input0
S: Sysfs=/devices/platform/i8042/serio1/input/input5
U: Uniq=
H: Handlers=mouse0 event5
B: PROP=5
B: EV=b
B: KEY=e520 10000 0 0 0 0
B: ABS=660800011000003
...
&lt;/code>&lt;/pre>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>&lt;/th>
&lt;th>&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;/table>
&lt;p>由于内容太多，这里就只显示部分内容。
另外也可通过 &lt;code>xinput&lt;/code> 命令获取，如：&lt;/p>
&lt;p>| ```
1
2
3
4
5
6
7
8
9
10
11
12
13&lt;/p>
&lt;pre>&lt;code> | ```
$ xinput
⎡ Virtual core pointer id=2 [master pointer (3)]
⎜ ↳ Virtual core XTEST pointer id=4 [slave pointer (2)]
⎜ ↳ SynPS/2 Synaptics TouchPad id=11 [slave pointer (2)]
⎜ ↳ TPPS/2 IBM TrackPoint id=12 [slave pointer (2)]
⎣ Virtual core keyboard id=3 [master keyboard (2)]
↳ Virtual core XTEST keyboard id=5 [slave keyboard (3)]
↳ Power Button id=6 [slave keyboard (3)]
↳ Video Bus id=7 [slave keyboard (3)]
↳ Sleep Button id=8 [slave keyboard (3)]
↳ Integrated Camera: Integrated C id=9 [slave keyboard (3)]
↳ AT Translated Set 2 keyboard id=10 [slave keyboard (3)]
↳ ThinkPad Extra Buttons id=13 [slave keyboard (3)]
&lt;/code>&lt;/pre>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>&lt;/th>
&lt;th>&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;/table>
&lt;p>使用 &lt;code>xinput list-prop &amp;lt;device id&amp;gt;&lt;/code> 可以查看设备的属性。&lt;/p>
&lt;h2 id="battery">Battery&lt;/h2>
&lt;p>电池信息可以从 &lt;code>/sys/class/power_supply/&amp;lt;name&amp;gt;/uevent&lt;/code> 文件中获取，电池的名称一般以 &lt;code>BAT&lt;/code> 开头。如本机的信息：&lt;/p>
&lt;p>| ```
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17&lt;/p>
&lt;pre>&lt;code> | ```
$ cat /sys/class/power_supply/BAT0/uevent
POWER_SUPPLY_NAME=BAT0
POWER_SUPPLY_STATUS=Full
POWER_SUPPLY_PRESENT=1
POWER_SUPPLY_TECHNOLOGY=Li-ion
POWER_SUPPLY_CYCLE_COUNT=0
POWER_SUPPLY_VOLTAGE_MIN_DESIGN=11100000
POWER_SUPPLY_VOLTAGE_NOW=12226000
POWER_SUPPLY_POWER_NOW=0
POWER_SUPPLY_ENERGY_FULL_DESIGN=57720000
POWER_SUPPLY_ENERGY_FULL=48000000
POWER_SUPPLY_ENERGY_NOW=48000000
POWER_SUPPLY_CAPACITY=100
POWER_SUPPLY_CAPACITY_LEVEL=Full
POWER_SUPPLY_MODEL_NAME=45N1023
POWER_SUPPLY_MANUFACTURER=SANYO
POWER_SUPPLY_SERIAL_NUMBER=15921
&lt;/code>&lt;/pre>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>&lt;/th>
&lt;th>&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;/table>
&lt;h2 id="backlight">Backlight&lt;/h2>
&lt;p>&lt;code>/sys/class/backlight/&lt;/code> 目录下的是背光设备，如显示屏，背光键盘等，可以更改文件内容来调节这些设备的亮度。如：&lt;/p>
&lt;p>| ```
1
2&lt;/p>
&lt;pre>&lt;code> | ```
$ ls /sys/class/backlight/intel_backlight/
actual_brightness bl_power brightness device@ max_brightness power/ subsystem@ type uevent
&lt;/code>&lt;/pre>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>&lt;/th>
&lt;th>&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;/table>
&lt;ul>
&lt;li>&lt;strong>brightness&lt;/strong>
更改这个文件可以修改此设备的当前亮度&lt;/li>
&lt;li>&lt;strong>max_brightness&lt;/strong>
这个文件显示的是此设备支持的最大亮度&lt;/li>
&lt;/ul>
&lt;p>另外背光设备 &lt;code>device&lt;/code> 可能只想真实的显卡设备，一般是子目录中包含 &lt;code>video&lt;/code> 的。&lt;/p>
&lt;h2 id="camera">Camera&lt;/h2>
&lt;p>&lt;code>/sys/class/video4linux/&lt;/code> 下是摄像头设备，不同子目录中的设备可能是同一个，也是读取 &lt;code>device/uevent&lt;/code> 文件来选择 &lt;code>lspci&lt;/code> 或 &lt;code>lsusb&lt;/code> 获取设备信息，如：&lt;/p>
&lt;p>| ```
1
2
3
4
5
6
7
8
9
10&lt;/p>
&lt;pre>&lt;code> | ```
$ cat /sys/class/video4linux/video0/device/uevent
DEVTYPE=usb_interface
DRIVER=uvcvideo
PRODUCT=5986/2d2/11
TYPE=239/2/1
INTERFACE=14/1/0
MODALIAS=usb:v5986p02D2d0011dcEFdsc02dp01ic0Eisc01ip00in00
$ lsusb -d 5986:2d2:11
Bus 001 Device 004: ID 5986:02d2 Acer, Inc
&lt;/code>&lt;/pre>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>&lt;/th>
&lt;th>&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;/table>
&lt;h2 id="printer">Printer&lt;/h2>
&lt;p>打印机应该是在 &lt;code>/sys/class/printer&lt;/code> 下，信息获取方法应该与上文一致，本人手中没有打印机就不给出示例了。&lt;/p>
&lt;h2 id="fingerprint">Fingerprint&lt;/h2>
&lt;p>指纹的功能目前是由 &lt;code>libfprint&lt;/code> 项目提供，调用其提供的接口来获取。
如使用 &lt;code>qdbus&lt;/code> 来获取：&lt;/p>
&lt;p>| ```
1
2&lt;/p>
&lt;pre>&lt;code> | ```
$ qdbus --system --literal net.reactivated.Fprint /net/reactivated/Fprint/Manager net.reactivated.Fprint.Manager.GetDevices
[Argument: ao {}]
&lt;/code>&lt;/pre>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>&lt;/th>
&lt;th>&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;/table>
&lt;p>输出可知本机没有指纹设备。&lt;/p>
&lt;h1 id="实现">实现&lt;/h1>
&lt;p>这里用 &lt;code>Go&lt;/code> 实现了 &lt;code>hardware&lt;/code> ，见此： &lt;a href="https://github.com/jouyouyun/hardware">hardware&lt;/a>&lt;/p></description></item><item><title>Docs: Load 高/CPU 使用率 问题及实用脚本</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/x.linux-%E7%AE%A1%E7%90%86/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96-%E4%B8%8E-%E6%95%85%E9%9A%9C%E5%A4%84%E7%90%86/cpu-%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/load-%E9%AB%98_cpu-%E4%BD%BF%E7%94%A8%E7%8E%87-%E9%97%AE%E9%A2%98%E5%8F%8A%E5%AE%9E%E7%94%A8%E8%84%9A%E6%9C%AC/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/x.linux-%E7%AE%A1%E7%90%86/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96-%E4%B8%8E-%E6%95%85%E9%9A%9C%E5%A4%84%E7%90%86/cpu-%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/load-%E9%AB%98_cpu-%E4%BD%BF%E7%94%A8%E7%8E%87-%E9%97%AE%E9%A2%98%E5%8F%8A%E5%AE%9E%E7%94%A8%E8%84%9A%E6%9C%AC/</guid><description>
&lt;h1 id="linux-资源瓶颈分析概述">Linux 资源&amp;amp;瓶颈分析概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://mp.weixin.qq.com/s/fzLcAkYwKhj-9hgoVkTzaw">公众号,CPU 飙高，系统性能问题如何排查？&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;blockquote>
&lt;ul>
&lt;li>&lt;a href="https://developer.aliyun.com/topic/download?id=143">阿里云,ECS 运维指南之 LInux 系统诊断-找到 Linux 虚机 Load 高的元凶&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>Load Average 和 CPU 使用率 可被细分为不同的子域指标，指向不同的资源瓶颈。总体来说，指标与资源瓶颈的对应关系基本如下图所示。&lt;/p>
&lt;p>注意：Load 与 CPU 使用率 之间没有必然的联系。有可能 Load 很高，而 CPU 使用率很低；也有可能 Load 很低而 CPU 使用率很高。具体原因详见 CPU 管理 与 Process 进程管理 章节中关于 Load 与 CPU 使用率的概念。简单说就是因为 Load Average 在计算时，包含了对 I/O 的统计&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/go9krg/1616164005685-f19dcd0b-9837-42cb-aeaa-a48586cf1cca.jpeg" alt="">&lt;/p>
&lt;h2 id="load-高--cpu-高">Load 高 &amp;amp; CPU 高&lt;/h2>
&lt;p>这是我们最常遇到的一类情况，即 load 上涨是 CPU 负载上升导致。根据 CPU 具体资源分配表现，可分为以下几类：&lt;/p>
&lt;p>&lt;strong>CPU sys 高&lt;/strong>
这种情况 CPU 主要开销在于系统内核，可进一步查看上下文切换情况。&lt;/p>
&lt;ul>
&lt;li>如果非自愿上下文切换较多，说明 CPU 抢占较为激烈，大量进程由于时间片已到等原因，被系统强制调度，进而发生的上下文切换。&lt;/li>
&lt;li>如果自愿上下文切换较多，说明可能存在 I/O、内存等系统资源瓶颈，大量进程无法获取所需资源，导致的上下文切换。&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>CPU si 高&lt;/strong>
这种情况 CPU 大量消耗在软中断，可进一步查看软中断类型。一般而言，网络 I/O 或者线程调度引起软中断最为常见：&lt;/p>
&lt;ul>
&lt;li>NET_TX &amp;amp; NET_RX。NET_TX 是发送网络数据包的软中断，NET_RX 是接收网络数据包的软中断，这两种类型的软中断较高时，系统存在网络 I/O 瓶颈可能性较大。&lt;/li>
&lt;li>SCHED。SCHED 为进程调度以及负载均衡引起的中断，这种中断出现较多时，系统存在较多进程切换，一般与非自愿上下文切换高同时出现，可能存在 CPU 瓶颈。&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>CPU us 高&lt;/strong>
这种情况说明资源主要消耗在应用进程，可能引发的原因有以下几类：&lt;/p>
&lt;ul>
&lt;li>死循环或代码中存在 CPU 密集计算。这种情况多核 CPU us 会同时上涨。&lt;/li>
&lt;li>内存问题，导致大量 FULLGC，阻塞线程。这种情况一般只有一核 CPU us 上涨。&lt;/li>
&lt;li>资源等待造成线程池满，连带引发 CPU 上涨。这种情况下，线程池满等异常会同时出现。&lt;/li>
&lt;/ul>
&lt;h2 id="load-高--cpu-低">Load 高 &amp;amp; CPU 低&lt;/h2>
&lt;p>这种情况出现的根本原因在于不可中断睡眠态(TASK_UNINTERRUPTIBLE)进程数较多，即 CPU 负载不高，但 I/O 负载较高。可进一步定位是磁盘 I/O 还是网络 I/O 导致。&lt;/p>
&lt;h1 id="排查策略">排查策略&lt;/h1>
&lt;p>利用现有常用的工具，我们常用的排查策略基本如下图所示：
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/go9krg/1616164005644-f386b76a-e4ac-447e-b4fc-185c5393c19f.jpeg" alt="">&lt;/p>
&lt;p>从问题发现到最终定位，基本可分为四个阶段：&lt;/p>
&lt;h2 id="资源瓶颈定位">资源瓶颈定位&lt;/h2>
&lt;p>这一阶段通过全局性能检测工具，初步定位资源消耗异常位点。&lt;/p>
&lt;p>常用的工具有：&lt;/p>
&lt;ul>
&lt;li>top、vmstat、tsar(历史)&lt;/li>
&lt;li>中断：/proc/softirqs、/proc/interrupts&lt;/li>
&lt;li>I/O：iostat、dstat&lt;/li>
&lt;/ul>
&lt;h2 id="热点进程定位">热点进程定位&lt;/h2>
&lt;p>定位到资源瓶颈后，可进一步分析具体进程资源消耗情况，找到热点进程。&lt;/p>
&lt;p>常用工具有：&lt;/p>
&lt;ul>
&lt;li>上下文切换：pidstat -w&lt;/li>
&lt;li>CPU：pidstat -u&lt;/li>
&lt;li>I/O：iotop、pidstat -d&lt;/li>
&lt;li>僵尸进程：ps&lt;/li>
&lt;/ul>
&lt;h2 id="线程进程内部资源定位">线程&amp;amp;进程内部资源定位&lt;/h2>
&lt;p>找到具体进程后，可细化分析进程内部资源开销情况。&lt;/p>
&lt;p>常用工具有：&lt;/p>
&lt;ul>
&lt;li>上下文切换：pidstat -w -p [pid]&lt;/li>
&lt;li>CPU：pidstat -u -p [pid]&lt;/li>
&lt;li>I/O: lsof&lt;/li>
&lt;/ul>
&lt;h2 id="热点事件方法分析">热点事件&amp;amp;方法分析&lt;/h2>
&lt;p>获取到热点线程后，我们可用 trace 或者 dump 工具，将线程反向关联，将问题范围定位到具体方法&amp;amp;堆栈。&lt;/p>
&lt;p>常用的工具有：&lt;/p>
&lt;ul>
&lt;li>perf：Linux 自带性能分析工具，功能类似 hotmethod，基于事件采样原理，以性能事件为基础，支持针对处理器相关性能指标与操作系统相关性能指标的性能剖析。&lt;/li>
&lt;li>jstack
&lt;ul>
&lt;li>结合 ps -Lp 或者 pidstat -p 一起使用，可初步定位热点线程。&lt;/li>
&lt;li>结合 zprofile-threaddump 一起使用，可统计线程分布、等锁情况，常用与线程数增加分析。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>strace：跟踪进程执行时的系统调用和所接收的信号。&lt;/li>
&lt;li>tcpdump：抓包分析，常用于网络 I/O 瓶颈定位。&lt;/li>
&lt;/ul>
&lt;h1 id="实用脚本">实用脚本&lt;/h1>
&lt;h2 id="找出系统中-load-高时处于运行队列的进程">找出系统中 Load 高时处于运行队列的进程&lt;/h2>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#!/bin/bash
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>LANG&lt;span style="color:#f92672">=&lt;/span>C
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>PATH&lt;span style="color:#f92672">=&lt;/span>/sbin:/usr/sbin:/bin:/usr/bin
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>interval&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>length&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">86400&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">for&lt;/span> i in &lt;span style="color:#66d9ef">$(&lt;/span>seq &lt;span style="color:#ae81ff">1&lt;/span> &lt;span style="color:#66d9ef">$(&lt;/span>expr &lt;span style="color:#e6db74">${&lt;/span>length&lt;span style="color:#e6db74">}&lt;/span> / &lt;span style="color:#e6db74">${&lt;/span>interval&lt;span style="color:#e6db74">}&lt;/span>&lt;span style="color:#66d9ef">))&lt;/span>;&lt;span style="color:#66d9ef">do&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>date
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>LANG&lt;span style="color:#f92672">=&lt;/span>C ps -eTo stat,pid,tid,ppid,comm --no-header | sed -e &lt;span style="color:#e6db74">&amp;#39;s/^ *//&amp;#39;&lt;/span> |
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>perl -nE &lt;span style="color:#e6db74">&amp;#39;chomp;say if (m!^\S*[RD]+\S*!)&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>date
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>cat /proc/loadavg
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>echo -e &lt;span style="color:#e6db74">&amp;#34;\n&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>sleep &lt;span style="color:#e6db74">${&lt;/span>interval&lt;span style="color:#e6db74">}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">done&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="查-cpu-使用率高的线程">查 CPU 使用率高的线程&lt;/h2>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#!/bin/bash
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>LANG&lt;span style="color:#f92672">=&lt;/span>C
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>PATH&lt;span style="color:#f92672">=&lt;/span>/sbin:/usr/sbin:/bin:/usr/bin
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>interval&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>length&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">86400&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">for&lt;/span> i in &lt;span style="color:#66d9ef">$(&lt;/span>seq &lt;span style="color:#ae81ff">1&lt;/span> &lt;span style="color:#66d9ef">$(&lt;/span>expr &lt;span style="color:#e6db74">${&lt;/span>length&lt;span style="color:#e6db74">}&lt;/span> / &lt;span style="color:#e6db74">${&lt;/span>interval&lt;span style="color:#e6db74">}&lt;/span>&lt;span style="color:#66d9ef">))&lt;/span>;&lt;span style="color:#66d9ef">do&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>date
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>LANG&lt;span style="color:#f92672">=&lt;/span>C ps -eT -o%cpu,pid,tid,ppid,comm | grep -v CPU | sort -n -r | head -20
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>date
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>LANG&lt;span style="color:#f92672">=&lt;/span>C cat /proc/loadavg
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">{&lt;/span> LANG&lt;span style="color:#f92672">=&lt;/span>C ps -eT -o%cpu,pid,tid,ppid,comm | sed -e &lt;span style="color:#e6db74">&amp;#39;s/^ *//&amp;#39;&lt;/span> | tr -s &lt;span style="color:#e6db74">&amp;#39; &amp;#39;&lt;/span> |
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>grep -v CPU | sort -n -r | cut -d &lt;span style="color:#e6db74">&amp;#39; &amp;#39;&lt;/span> -f &lt;span style="color:#ae81ff">1&lt;/span> | xargs -I&lt;span style="color:#f92672">{}&lt;/span> echo -n &lt;span style="color:#e6db74">&amp;#34;{} + &amp;#34;&lt;/span> &lt;span style="color:#f92672">&amp;amp;&amp;amp;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>echo &lt;span style="color:#e6db74">&amp;#39;0&amp;#39;&lt;/span>; &lt;span style="color:#f92672">}&lt;/span> | bc -l
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>sleep &lt;span style="color:#e6db74">${&lt;/span>interval&lt;span style="color:#e6db74">}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">done&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>fuser -k $0
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div></description></item><item><title>Docs: lsof 列出打开的文件</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/x.linux-%E7%AE%A1%E7%90%86/linux-%E7%B3%BB%E7%BB%9F%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/%E7%A3%81%E7%9B%98-%E4%B8%8E-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7%E9%9B%86/lsof-%E5%88%97%E5%87%BA%E6%89%93%E5%BC%80%E7%9A%84%E6%96%87%E4%BB%B6/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/x.linux-%E7%AE%A1%E7%90%86/linux-%E7%B3%BB%E7%BB%9F%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/%E7%A3%81%E7%9B%98-%E4%B8%8E-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7%E9%9B%86/lsof-%E5%88%97%E5%87%BA%E6%89%93%E5%BC%80%E7%9A%84%E6%96%87%E4%BB%B6/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://man.cx/lsof(8)">Manual(手册)&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>该工具以文件为主体，用于列出打开文件的进程，进程打开的端口(TCP、UDP)等、找回/恢复删除的文件。是十分方便的系统监视工具，因为 lsof 需要访问核心内存和各种文件，所以需要 root 用户执行。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">[&lt;/span>root@master0 ~&lt;span style="color:#f92672">]&lt;/span>&lt;span style="color:#75715e"># lsof | more&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>COMMAND PID TID USER FD TYPE DEVICE SIZE/OFF NODE NAME
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>systemd &lt;span style="color:#ae81ff">1&lt;/span> root cwd DIR 253,0 &lt;span style="color:#ae81ff">238&lt;/span> &lt;span style="color:#ae81ff">64&lt;/span> /
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>systemd &lt;span style="color:#ae81ff">1&lt;/span> root rtd DIR 253,0 &lt;span style="color:#ae81ff">238&lt;/span> &lt;span style="color:#ae81ff">64&lt;/span> /
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>systemd &lt;span style="color:#ae81ff">1&lt;/span> root txt REG 253,0 &lt;span style="color:#ae81ff">1612152&lt;/span> &lt;span style="color:#ae81ff">17149941&lt;/span> /usr/lib/systemd/systemd
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>......
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>kthreadd &lt;span style="color:#ae81ff">2&lt;/span> root cwd DIR 253,0 &lt;span style="color:#ae81ff">238&lt;/span> &lt;span style="color:#ae81ff">64&lt;/span> /
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>kthreadd &lt;span style="color:#ae81ff">2&lt;/span> root rtd DIR 253,0 &lt;span style="color:#ae81ff">238&lt;/span> &lt;span style="color:#ae81ff">64&lt;/span> /
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>kthreadd &lt;span style="color:#ae81ff">2&lt;/span> root txt unknown /proc/2/exe
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>......
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>lsof &lt;span style="color:#ae81ff">1893&lt;/span> root mem REG 253,0 &lt;span style="color:#ae81ff">155784&lt;/span> &lt;span style="color:#ae81ff">72860&lt;/span> /usr/lib64/libselinux.so.1
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>lsof &lt;span style="color:#ae81ff">1893&lt;/span> root mem REG 253,0 &lt;span style="color:#ae81ff">164240&lt;/span> &lt;span style="color:#ae81ff">41015&lt;/span> /usr/lib64/ld-2.17.so
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>lsof &lt;span style="color:#ae81ff">1893&lt;/span> root 4r FIFO 0,9 0t0 &lt;span style="color:#ae81ff">37707&lt;/span> pipe
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>lsof &lt;span style="color:#ae81ff">1893&lt;/span> root 7w FIFO 0,9 0t0 &lt;span style="color:#ae81ff">37708&lt;/span> pipe
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>每行显示一个打开的文件，若不指定条件默认将显示所有进程打开的所有文件。lsof 输出各列信息的意义如下：&lt;/p>
&lt;p>COMMAND 进程的名称 | PID 进程标识符 | USER 进程所有者 | FD 文件描述符 | TYPE 文件类型 | DEVICE 磁盘的名称 | SIZE 文件的大小 | NODE 索引节点 | NAME 文件的绝对路径&lt;/p>
&lt;h2 id="fd--表示该文件被打开的-fd-号或其他信息">FD # 表示该文件被打开的 FD 号或其他信息&lt;/h2>
&lt;ul>
&lt;li>cwd：表示 current work dirctory，即：应用程序的当前工作目录，这是该应用程序启动的目录，除非它本身对这个目录进行更改&lt;/li>
&lt;li>txt # 该类型的文件是程序代码，如应用程序二进制文件本身或共享库，如上列表中显示的 /sbin/init 程序&lt;/li>
&lt;li>er # FD 信息错误(参考 NAME 列);&lt;/li>
&lt;li>ltx：shared library text (code and data);&lt;/li>
&lt;li>mxx ：hex memory-mapped type number xx.&lt;/li>
&lt;li>mem # 内存映射文件&lt;/li>
&lt;li>mmap # memory-mapped device;&lt;/li>
&lt;li>pd # 父目录&lt;/li>
&lt;li>rtd # root 目录&lt;/li>
&lt;li>v86 VP/ix mapped file;&lt;/li>
&lt;li>0：表示标准输出&lt;/li>
&lt;li>1：表示标准输入&lt;/li>
&lt;li>2：表示标准错误&lt;/li>
&lt;/ul>
&lt;blockquote>
&lt;p>一般在标准输出、标准错误、标准输入后还跟着文件状态模式：r、w、u 等&lt;/p>
&lt;/blockquote>
&lt;ul>
&lt;li>u：表示该文件被打开并处于读取/写入模式&lt;/li>
&lt;li>r：表示该文件被打开并处于只读模式&lt;/li>
&lt;li>w：表示该文件被打开并处于&lt;/li>
&lt;li>空格 # 表示该文件的状态模式为 unknow，且没有锁定&lt;/li>
&lt;li>
&lt;ul>
&lt;li>
&lt;h1 id="表示该文件的状态模式为-unknow且被锁定">表示该文件的状态模式为 unknow，且被锁定&lt;/h1>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>同时在文件状态模式后面，还跟着相关的锁&lt;/p>
&lt;ul>
&lt;li>N：for a Solaris NFS lock of unknown type;&lt;/li>
&lt;li>r：for read lock on part of the file;&lt;/li>
&lt;li>R：for a read lock on the entire file;&lt;/li>
&lt;li>w：for a write lock on part of the file;（文件的部分写锁）&lt;/li>
&lt;li>W：for a write lock on the entire file;（整个文件的写锁）&lt;/li>
&lt;li>u：for a read and write lock of any length;&lt;/li>
&lt;li>U：for a lock of unknown type;&lt;/li>
&lt;li>x：for an SCO OpenServer Xenix lock on part of the file;&lt;/li>
&lt;li>X：for an SCO OpenServer Xenix lock on the entire file;&lt;/li>
&lt;li>space：if there is no lock.&lt;/li>
&lt;/ul>
&lt;h2 id="type--文件类型">TYPE # 文件类型&lt;/h2>
&lt;ul>
&lt;li>DIR：表示目录&lt;/li>
&lt;li>CHR：表示字符类型&lt;/li>
&lt;li>BLK：块设备类型&lt;/li>
&lt;li>UNIX： UNIX 域套接字&lt;/li>
&lt;li>FIFO：先进先出 (FIFO) 队列&lt;/li>
&lt;li>IPv4：网际协议 (IP) 套接字&lt;/li>
&lt;li>&amp;hellip;&amp;hellip;.&lt;/li>
&lt;/ul>
&lt;h1 id="syntax语法">Syntax(语法)&lt;/h1>
&lt;p>&lt;strong>lsof [ -?abChKlnNOPRtUvVX ] [ -A A ] [ -c c ] [ +c c ] [ +|-d d ] [ +|-D D ] [ +|-e s ] [ +|-f [cfgGn] ] [ -F [f] ] [ -g [s] ] [ -i [i] ] [ -k k] [ +|-L [l] ] [ +|-m m ] [ +|-M ] [ -o [o] ] [ -p s ] [ +|-r [t[m&lt;!-- raw HTML omitted -->]] ] [ -s [p:s] ] [ -S [t] ] [ -T [t] ] [ -u s ] [ +|-w ] [ -x [fl] ] [ -z [z] ] [ -Z [Z] ] [ &amp;ndash; ] [names]&lt;/strong>&lt;/p>
&lt;h2 id="options">OPTIONS&lt;/h2>
&lt;ul>
&lt;li>&lt;strong>-a&lt;/strong> # 过滤选项之间进行 AND 运算。比如我使用 -d 和 -p，则结果要两个筛选都满足才可以。默认情况是 或 运算。列出满足任意过滤选项的所有结果。
&lt;ul>
&lt;li>说白了，这 -a 选项就是个逻辑运算符。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>-c &lt;!-- raw HTML omitted -->&lt;/strong> # 列出以 STRING 字符开头的命令的进程的文件列表。其实就是通过进程名筛选&lt;/li>
&lt;li>&lt;strong>+d &lt;!-- raw HTML omitted -->&lt;/strong> # 列出目录下被打开的文件&lt;/li>
&lt;li>&lt;strong>-d &lt;!-- raw HTML omitted -->&lt;/strong> # 列出占用指定文件描述符的进程。可以使用 2-10 这种方式来列出 2 到 10 号描述符的文件。&lt;/li>
&lt;li>&lt;strong>+D &lt;!-- raw HTML omitted -->&lt;/strong> # 递归列出目录下被打开的文件&lt;/li>
&lt;li>&lt;strong>-g &lt;!-- raw HTML omitted -->&lt;/strong> # 列出 GID 号进程详情&lt;/li>
&lt;li>&lt;strong>-i [&lt;!-- raw HTML omitted -->]&lt;/strong> # 列出符合条件的网络连接相关。（4、6、协议、:PORT、 @IP ）&lt;/li>
&lt;li>&lt;strong>-n&lt;/strong> # 直接显示 IP 而不是主机名&lt;/li>
&lt;li>&lt;strong>-N &lt;!-- raw HTML omitted -->&lt;/strong> # 列出使用 NFS 的文件&lt;/li>
&lt;li>&lt;strong>-p &amp;lt;PID[,PID,PID&amp;hellip;.]&amp;gt;&lt;/strong> # 列出指定进程号所打开的文件。多个 PID 以逗号分隔&lt;/li>
&lt;li>&lt;strong>-P&lt;/strong> # 直接显示端口号，而不是端口号的名称&lt;/li>
&lt;li>&lt;strong>-u &lt;!-- raw HTML omitted -->&lt;/strong> # 列出指定用户所打开的文件&lt;/li>
&lt;li>&lt;strong>-w&lt;/strong> # 关闭程序运行中产生的警告信息。&lt;/li>
&lt;/ul>
&lt;h2 id="example">EXAMPLE&lt;/h2>
&lt;ul>
&lt;li>查看谁正在使用某个文件，也就是说查找某个文件相关的进程
&lt;ul>
&lt;li>**lsof /bin/bash **&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>显示除了 root 用户下的 sshd 进程所用的文件
&lt;ul>
&lt;li>&lt;strong>lsof -u ^root -c sshd&lt;/strong>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>列出目前连接主机 peida.linux 上端口为：20，21，22，25，53，80 相关的所有文件信息，且每隔 3 秒不断的执行 lsof 指令
&lt;ul>
&lt;li>&lt;strong>lsof -i @peida.linux:20,21,22,25,53,80 -r 3&lt;/strong>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>列出所有的网络连接
&lt;ul>
&lt;li>&lt;strong>lsof -i&lt;/strong>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>列出所有 tcp 网络连接信息
&lt;ul>
&lt;li>lsof -i tcp&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>列出正在使用 3306 端口的进程信息
&lt;ul>
&lt;li>lsof -i :3306&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>列出 9267 号进程打开的文件描述符为 132 的文件
&lt;ul>
&lt;li>lsof -p 9267 -d 132 -a&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>列出 9267 号进程打开的所有文件，以及文件描述符为 132 的所有文件
&lt;ul>
&lt;li>lsof -p 9267 -d 13&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>列出谁在使用某个特定的 udp 端口
&lt;ul>
&lt;li>lsof -i udp:55&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>列出某个用户的所有活跃的网络端口
&lt;ul>
&lt;li>lsof -a -u test -i&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul></description></item><item><title>Docs: Memory 管理工具</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/x.linux-%E7%AE%A1%E7%90%86/linux-%E7%B3%BB%E7%BB%9F%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/memory-%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/x.linux-%E7%AE%A1%E7%90%86/linux-%E7%B3%BB%E7%BB%9F%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/memory-%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;h1 id="概述-1">概述&lt;/h1>
&lt;blockquote>
&lt;h2 id="参考">参考：&lt;/h2>
&lt;/blockquote>
&lt;h1 id="查看-memory-的使用情况">查看 Memory 的使用情况&lt;/h1>
&lt;p>我们可以通过多种方式查看 Memory 信息。&lt;/p>
&lt;h2 id="procmemory-文件">/proc/memory 文件&lt;/h2>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://access.redhat.com/solutions/406773">RedHat 官方给的解释&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>该文件报告有关系统上内存使用情况的统计信息。 free 命令使用该文件来报告系统上的可用内存和已使用内存（物理内存和交换内存）以及内核使用的共享内存和缓冲区的数量。该文件是以 &lt;code>:&lt;/code> 符号分割的 &lt;strong>Key/Value pair(键/值对)&lt;/strong> 格式。可用参数及其详解如下：&lt;/p>
&lt;h3 id="memtotal">MemTotal&lt;/h3>
&lt;p>总可用 Memory。即.物理 RAM 减去一些保留的 bits 和内核二进制代码所用的量&lt;/p>
&lt;h3 id="memfree">MemFree&lt;/h3>
&lt;p>空闲的 Memory。LowFree 与 HighFree 两个参数的值的和&lt;/p>
&lt;h3 id="memavailable">MemAvailable&lt;/h3>
&lt;p>可用的 Memory。估算值，估计有多少内存可用于启动新的应用程序&lt;/p>
&lt;h3 id="buffers-与-cached">Buffers 与 Cached&lt;/h3>
&lt;p>详见：《[Memory 的缓存机制](✏IT 学习笔记/📄1.操作系统/2.Kernel(内核)/5.Memory%20 管理/Memory%20 的缓存机制.md 管理/Memory 的缓存机制.md)》&lt;/p>
&lt;h3 id="active">Active&lt;/h3>
&lt;p>最近使用过的 Memory。除非必要，否则通常不会回收。&lt;/p>
&lt;h3 id="inactive">Inactive&lt;/h3>
&lt;p>最近使用比较收的 Memory。这些内存会被优先回收。&lt;/p>
&lt;h3 id="slab">Slab&lt;/h3>
&lt;p>内核数据结构缓存。dentry、inode_cache 等&lt;/p>
&lt;h3 id="sreclaimable">SReclaimable&lt;/h3>
&lt;p>Slab Reclaimable。Slab 的一部分，可以被 reclaimed(回收)。例如 dentry、inode 的缓存等等。&lt;/p>
&lt;h3 id="sunreclaim">SUnreclaim&lt;/h3>
&lt;p>Slab UnReclaim。Slab 的一部分，不可以被 reclaimed(回收)。即使内存有压力也无法回收&lt;/p>
&lt;h3 id="commitlimit">CommitLimit&lt;/h3>
&lt;p>提交限制。当前可以分配的内存上限。只有当 [/proc/sys/vm/overcommit_memory](net(网络相关参数).md Kernel/Kernel 参数/net(网络相关参数).md) 的参数值为 2 的时候，该限制才生效。这个上限是指当程序向系统申请内存时，如果申请的内存加上现在已经分配的内存，超过了 commitlimit 的值，则该申请将会失败。&lt;/p>
&lt;p>该值通过如下公式：
&lt;code>CommitLimit = (total_RAM - total_huge_TLB) * overcommit_ratio / 100 + total_swap&lt;/code>&lt;/p>
&lt;ul>
&lt;li>totaol_RAM # 系统内存总量(就是物理内存)&lt;/li>
&lt;li>total_huge_TLB # 为 huge pages 保留的内存量，一般没有保留，都是 0&lt;/li>
&lt;li>overcommit_ratio # /proc/sys/vm/overcommit_ratio 内核参数的值。&lt;/li>
&lt;li>total_swap # swap 空间的总量&lt;/li>
&lt;/ul>
&lt;h3 id="committed_as">Committed_AS&lt;/h3>
&lt;blockquote>
&lt;p>Allocated Size(已经分配的大小，简称 AS)&lt;/p>
&lt;/blockquote>
&lt;p>当前已经分配的内存总量。注意：不是正在使用的，而是已经分配的。&lt;/p>
&lt;p>当 overcommit_memory 参数的值为 2 时，该值不能超过 CommitLimit 的值。其余时候该值可以无限大。&lt;/p>
&lt;h2 id="free-命令">free 命令&lt;/h2>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>~&lt;span style="color:#f92672">]&lt;/span>&lt;span style="color:#75715e"># free -h&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> total used free shared buff/cache available
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Mem: 3.8Gi 846Mi 506Mi 1.0Mi 2.5Gi 2.9Gi
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Swap: 0B 0B 0B
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Mem：设备上的真实内存&lt;/p>
&lt;ul>
&lt;li>total # 总计。该设备的总内存大小&lt;/li>
&lt;li>used # 已使用的。linux 对内存的使用量&lt;/li>
&lt;li>free # 空闲的。还剩多少内存可用&lt;/li>
&lt;li>shared # 共享内存&lt;/li>
&lt;li>buff # 缓冲区(buffer)。保存一些将要写入到硬盘中的数据。&lt;/li>
&lt;li>cache # 缓存。从硬盘中读出的数据存放到内存中，以便再次读取相同数据时速度更快。&lt;/li>
&lt;li>availabel # 可用的。free+buff/cache 合起来就是可用的。&lt;/li>
&lt;/ul>
&lt;h2 id="free-命令-与-procmeminfo-文件中信息的对应关系">free 命令 与 /proc/meminfo 文件中信息的对应关系。&lt;/h2>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>free 命令输出&lt;/th>
&lt;th>&lt;code>/proc/meminfo&lt;/code>文件的字段&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>&lt;code>Mem: total&lt;/code>&lt;/td>
&lt;td>&lt;code>MemTotal&lt;/code>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>Mem: used&lt;/code>&lt;/td>
&lt;td>&lt;code>MemTotal - MemFree - Buffers - Cached - SReclaimable&lt;/code>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>Mem: free&lt;/code>&lt;/td>
&lt;td>&lt;code>MemFree&lt;/code>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>Mem: shared&lt;/code>&lt;/td>
&lt;td>&lt;code>Shmem&lt;/code>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>Mem: buff/cache&lt;/code>&lt;/td>
&lt;td>&lt;code>Buffers + Cached + Slab&lt;/code>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>Mem:available&lt;/code>&lt;/td>
&lt;td>&lt;code>MemAvailable&lt;/code>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>Swap: total&lt;/code>&lt;/td>
&lt;td>&lt;code>SwapTotal&lt;/code>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>Swap: used&lt;/code>&lt;/td>
&lt;td>&lt;code>SwapTotal - SwapFree&lt;/code>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>Swap: free&lt;/code>&lt;/td>
&lt;td>&lt;code>SwapFree&lt;/code>&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h1 id="一个可以消耗-linux-内存的-shell-脚本">一个可以消耗 Linux 内存的 Shell 脚本&lt;/h1>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#!/bin/bash
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>mkdir /tmp/memory
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>mount -t tmpfs -o size&lt;span style="color:#f92672">=&lt;/span>1024M tmpfs /tmp/memory
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>dd &lt;span style="color:#66d9ef">if&lt;/span>&lt;span style="color:#f92672">=&lt;/span>/dev/zero of&lt;span style="color:#f92672">=&lt;/span>/tmp/memory/block
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>sleep &lt;span style="color:#ae81ff">3600&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>rm /tmp/memory/block
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>umount /tmp/memory
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>rmdir /tmp/memory
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div></description></item><item><title>Docs: Memory 硬件管理工具</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/x.linux-%E7%AE%A1%E7%90%86/linux-%E7%A1%AC%E4%BB%B6%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/memory-%E7%A1%AC%E4%BB%B6%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/x.linux-%E7%AE%A1%E7%90%86/linux-%E7%A1%AC%E4%BB%B6%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/memory-%E7%A1%AC%E4%BB%B6%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;h2 id="参考">参考：&lt;/h2>
&lt;/blockquote>
&lt;h1 id="看内存的品牌及型号">看内存的品牌及型号&lt;/h1>
&lt;p>背景：想加个内存，Mysql 服务器上的内存不够了，就算可以插(插槽都有，现在是 4 条 4G 内存，还有空闲八个槽。)，不知道兼不兼容，否则不稳定的,不兼容的话，死的更惨,这个不一定了，停产了，就没有办法了。怎么办?得看内存的品牌及型号。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">[&lt;/span>root@jackxiang ~&lt;span style="color:#f92672">]&lt;/span>&lt;span style="color:#75715e"># rpm -qa|grep dmidecode&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>dmidecode-2.11-2.el6.x86_64
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">[&lt;/span>root@jackxiang ~&lt;span style="color:#f92672">]&lt;/span>&lt;span style="color:#75715e"># dmidecode&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>查看服务器型号、序列号：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">[&lt;/span>root@jackxiang ~&lt;span style="color:#f92672">]&lt;/span>&lt;span style="color:#75715e"># dmidecode|grep &amp;#34;System Information&amp;#34; -A9|egrep &amp;#34;Manufacturer|Product|Serial&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Manufacturer: VMware, Inc.
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Product Name: VMware Virtual Platform
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Serial Number: VMware-42 &lt;span style="color:#ae81ff">18&lt;/span> c8 &lt;span style="color:#ae81ff">32&lt;/span> &lt;span style="color:#ae81ff">77&lt;/span> c6 ec 16-3f &lt;span style="color:#ae81ff">31&lt;/span> &lt;span style="color:#ae81ff">94&lt;/span> e9 d0 &lt;span style="color:#ae81ff">34&lt;/span> a6 ac
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Linux 查看内存的插槽数,已经使用多少插槽.每条内存多大：&lt;/p>
&lt;pre>&lt;code>[root@jackxiang ~]# dmidecode|grep -A5 &amp;quot;Memory Device&amp;quot;|grep Size|grep -v Range
Size: 4096 MB
Size: 2048 MB
Size: No Module Installed
Size: No Module Installed
&lt;/code>&lt;/pre>
&lt;p>Linux 查看内存的频率：&lt;/p>
&lt;pre>&lt;code>[root@localhost htdocs]# dmidecode|grep -A16 &amp;quot;Memory Device&amp;quot;|grep 'Speed'
Speed: 667 MHz (1.5 ns)
Speed: 667 MHz (1.5 ns)
Speed: 667 MHz (1.5 ns)
Speed: 667 MHz (1.5 ns)
Speed: Unknown
&lt;/code>&lt;/pre>
&lt;p>在 linux 查看内存型号的命令：&lt;/p>
&lt;pre>&lt;code>dmidecode -t memory
&lt;/code>&lt;/pre>
&lt;p>查看主板型号：&lt;/p>
&lt;pre>&lt;code>dmidecode |grep -A16 &amp;quot;System Information$&amp;quot;
&lt;/code>&lt;/pre>
&lt;p>内存槽及内存条：&lt;/p>
&lt;pre>&lt;code>dmidecode |grep -A16 &amp;quot;Memory Device$&amp;quot;
&lt;/code>&lt;/pre>
&lt;p>硬盘：&lt;/p>
&lt;pre>&lt;code>fdisk -l
smartctl -a /dev/sda
&lt;/code>&lt;/pre>
&lt;p>网卡：&lt;/p>
&lt;pre>&lt;code>mii-tool
&lt;/code>&lt;/pre>
&lt;!-- raw HTML omitted -->
&lt;pre>&lt;code>dmidecode|grep -P 'Maximum\s+Capacity' //最大支持几G内存
# dmidecode |grep &amp;quot;Product Name&amp;quot; //查看服务器品牌和型号
# dmidecode|grep -P -A5 &amp;quot;Memory\s+Device&amp;quot;|grep Size|grep -v Range //总共几个插槽，已使用几个插槽
Size: 1024 MB //此插槽有1根1G内存
Size: 1024 MB //此插槽有1根1G内存
Size: 1024 MB //此插槽有1根1G内存
Size: 1024 MB //此插槽有1根1G内存
Size: No Module Installed //此插槽未使用
Size: No Module Installed //此插槽未使用
&lt;/code>&lt;/pre>
&lt;!-- raw HTML omitted -->
&lt;pre>&lt;code># dmidecode -t 17 //数字17是dmidecode的参数，本文最后有其他数字参数
&lt;/code>&lt;/pre>
&lt;!-- raw HTML omitted -->
&lt;pre>&lt;code># dmidecode 2.7
SMBIOS 2.4 present.
Handle 0x0015, DMI type 17, 27 bytes.
Memory Device
Array Handle: 0x0013
Error Information Handle: Not Provided
Total Width: 72 bits
Data Width: 64 bits
Size: 2048 MB 【插槽1有1条2GB内存】
Form Factor: DIMM
Set: None
Locator: DIMM00
Bank Locator: BANK
Type: Other
Type Detail: Other
Speed: 667 MHz (1.5 ns)
Manufacturer:
Serial Number: BZACSKZ001
Asset Tag: RAM82
Part Number: MT9HTF6472FY-53EA2
Handle 0x0017, DMI type 17, 27 bytes.
Memory Device
Array Handle: 0x0013
Error Information Handle: Not Provided
Total Width: 72 bits
Data Width: 64 bits
Size: 2048 MB 【插槽2有1条2GB内存】
Form Factor: DIMM
Set: None
Locator: DIMM10
Bank Locator: BANK
Type: Other
Type Detail: Other
Speed: 667 MHz (1.5 ns)
Manufacturer:
Serial Number: BZACSKZ001
Asset Tag: RAM83
Part Number: MT9HTF6472FY-53EA2
Handle 0x0019, DMI type 17, 27 bytes.
Memory Device
Array Handle: 0x0013
Error Information Handle: Not Provided
Total Width: 72 bits
Data Width: 64 bits
Size: 2048 MB 【插槽3有1条2GB内存】
Form Factor: DIMM
Set: None
Locator: DIMM20
Bank Locator: BANK
Type: Other
Type Detail: Other
Speed: 667 MHz (1.5 ns)
Manufacturer:
Serial Number: BZACSKZ001
Asset Tag: RAM84
Part Number: MT9HTF6472FY-53EA2
Handle 0x001B, DMI type 17, 27 bytes.
Memory Device
Array Handle: 0x0013
Error Information Handle: Not Provided
Total Width: 72 bits
Data Width: 64 bits
Size: 2048 MB 【插槽4有1条2GB内存】
Form Factor: DIMM
Set: None
Locator: DIMM30
Bank Locator: BANK
Type: Other
Type Detail: Other
Speed: 667 MHz (1.5 ns)
Manufacturer:
Serial Number: BZACSKZ001
Asset Tag: RAM85
Part Number: MT9HTF6472FY-53EA2
&lt;/code>&lt;/pre>
&lt;p>实践来源：&lt;/p>
&lt;p>&lt;a href="http://www.jbxue.com/LINUXjishu/10053.html">http://www.jbxue.com/LINUXjishu/10053.html&lt;/a>&lt;/p>
&lt;p>&lt;a href="http://www.linuxsir.org/bbs/thread309696.html">http://www.linuxsir.org/bbs/thread309696.html&lt;/a>&lt;/p>
&lt;p>&lt;a href="http://xclinux.diandian.com/post/2013-04-16/40049844350">http://xclinux.diandian.com/post/2013-04-16/40049844350&lt;/a>作者：justwinit@向东博客 专注 WEB 应用 构架之美 &amp;mdash; 构架之美，在于尽态极妍 | 应用之美，在于药到病除&lt;/p>
&lt;p>地址：&lt;a href="http://www.justwinit.cn/post/7496/">http://www.justwinit.cn/post/7496/&lt;/a>&lt;/p></description></item><item><title>Docs: Netcat</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/x.linux-%E7%AE%A1%E7%90%86/linux-%E7%BD%91%E7%BB%9C%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/netcat/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/x.linux-%E7%AE%A1%E7%90%86/linux-%E7%BD%91%E7%BB%9C%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/netcat/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Netcat">Wike,Netcat&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://nmap.org/">Nmap 官网&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://nmap.org/ncat/">Nmap 官网-Ncat&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://nmap.org/book/ncat-man.html">Ncat Manual(手册)&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://man.openbsd.org/nc">OpenBSD-nc Manual(手册)&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://zhuanlan.zhihu.com/p/83959309">https://zhuanlan.zhihu.com/p/83959309&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>Netcat 是一个简单的实用程序通过 TCP 或 UDP 网络连接读取和写入数据。它旨在成为一个可靠的后端工具，可直接使用或轻松由其他程序和脚本驱动。同时，它还是一个功能丰富的网络调试和探索工具，因为它几乎可以创建您需要的任何类型的连接，包括端口绑定以接受传入连接。&lt;/p>
&lt;p>由于 Netcat 的设计理念和功能，被人亲切的亲切得称为 &lt;strong>网络工具中的瑞士军刀&lt;/strong>&lt;/p>
&lt;p>最初的 Netcat 是由霍比特人于 1995 年&lt;a href="http://seclists.org/bugtraq/1995/Oct/0028.html">发布&lt;/a>的，尽管它很受欢迎，但它并没有得到维护。有时甚至很难找到&lt;a href="http://download.insecure.org/stf/nc110.tgz">v1.10 源代码的副本&lt;/a>。该工具的灵活性和实用性促使 Nmap 项目产生&lt;a href="http://nmap.org/ncat/">Ncat&lt;/a>，这是一种支持 SSL、IPv6、SOCKS 和 http 代理、连接代理等的现代重新实现。除了 Nmap 项目重新了 Netcat，还有很多重写甚至扩展了 Netcat 的工具&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://sectools.org/tool/socat/">Socat&lt;/a>&lt;/li>
&lt;li>&lt;a href="http://www.openbsd.org/cgi-bin/cvsweb/src/usr.bin/nc/">OpenBSD 的 Netcat&lt;/a>&lt;/li>
&lt;li>&lt;a href="http://cryptcat.sourceforge.net/">Cryptcat&lt;/a>&lt;/li>
&lt;li>&lt;a href="http://www.deepspace6.net/projects/netcat6.html">Netcat6&lt;/a>&lt;/li>
&lt;li>&lt;a href="http://stromberg.dnsalias.org/~strombrg/pnetcat.html">pnetcat&lt;/a>&lt;/li>
&lt;li>&lt;a href="http://cycom.se/dl/sbd">SBD&lt;/a>&lt;/li>
&lt;li>所谓的&lt;a href="http://netcat.sourceforge.net/">GNU Netcat&lt;/a>&lt;/li>
&lt;/ul>
&lt;p>如需下载和更多信息， &lt;a href="http://en.wikipedia.org/wiki/Netcat">访问 Netcat 主页&lt;/a>。&lt;/p>
&lt;h2 id="ncat">Ncat&lt;/h2>
&lt;p>Ncat 是一个功能丰富的网络实用程序，它可以从命令行跨网络读取和写入数据。Ncat 由 Nmap 项目编写的，是对古老的 &lt;a href="http://sectools.org/tool/netcat/">Netcat&lt;/a> 的大大改进的重新实现。它同时使用 TCP 和 UDP 进行通信，并被设计为一种可靠的后端工具，可立即为其他应用程序和用户提供网络连接。Ncat 不仅适用于 IPv4 和 IPv6，还为用户提供了几乎无限的潜在用途。&lt;/p>
&lt;p>在 Ncat 的众多功能中，包括将 Ncat 链接在一起、将 TCP 和 UDP 端口重定向到其他站点、SSL 支持以及通过 SOCKS4 或 HTTP（CONNECT 方法）代理（以及可选的代理身份验证）进行代理连接的能力。一些通用原则适用于大多数应用程序，从而使您能够立即向通常不支持它的软件添加网络支持。&lt;/p>
&lt;p>Ncat 与 Nmap 集成，可在 Nmap 下载页面提供的标准 Nmap 下载包（包括源代码和 Linux、Windows 和 Mac 二进制文件）中找到。。您也可以在我们的&lt;a href="http://nmap.org/book/install.html#inst-svn">SVN 源代码存储库中&lt;/a>找到它。&lt;/p>
&lt;p>许多用户要求提供一个静态编译的 ncat.exe 版本，他们可以将其放在 Windows 系统上并使用，而无需运行任何安装程序或复制额外的库文件。我们已经构建了一个静态编译的 Windows 二进制版本的 Ncat 5.59BETA1。您可以在&lt;a href="http://nmap.org/dist/ncat-portable-5.59BETA1.zip">此处&lt;/a>下载 zip 文件。为确保文件未被篡改，您可以检查&lt;a href="http://nmap.org/book/install.html#inst-integrity">加密签名&lt;/a>。如果您需要更新的 Ncat 版本的便携版本，请参阅&lt;a href="https://secwiki.org/w/Nmap/Ncat_Portable">Ncat 便携编译说明&lt;/a>。&lt;/p>
&lt;p>该&lt;a href="https://nmap.org/ncat/guide/index.html">NCAT 用户指南&lt;/a>包含完整的文档，包括很多技巧，窍门和实用现实生活的例子！还有一个&lt;a href="https://nmap.org/book/ncat-man.html">Ncat 手册页&lt;/a>用于快速使用摘要。&lt;/p>
&lt;h2 id="openbsd-netcat">OpenBSD Netcat&lt;/h2>
&lt;h1 id="netcat-安装">Netcat 安装&lt;/h1>
&lt;h2 id="ubuntu">Ubuntu&lt;/h2>
&lt;p>Ubuntu 使用 OpenBSD 的 Netcat 作为 Netcat 的替代品
安装 netcat-openbsd 包即可，安装完成后，nc 命令本质上是 nc.openbsd 命令的软链接
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/nnt66u/1626359398275-d7639c00-614d-4ff7-8b10-3e49b50eb576.png" alt="image.png">&lt;/p>
&lt;h2 id="centos">CentOS&lt;/h2>
&lt;p>CentOS 使用 Nmap 的 Ncat 作为 Netcat 的替代品
安装 nmap-ncat 包即可，安装完成后，nc 命令本质上是 ncat 命令的软链接
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/nnt66u/1626359200164-165e5748-0a31-433b-bd62-0dcd3c157cf3.png" alt="image.png">&lt;/p>
&lt;h1 id="syntax语法">Syntax(语法)&lt;/h1>
&lt;p>&lt;strong>nc [ &lt;!-- raw HTML omitted --> &amp;hellip;] [ &lt;!-- raw HTML omitted --> ] [ &lt;!-- raw HTML omitted --> ]&lt;/strong>&lt;/p>
&lt;h2 id="options">OPTIONS&lt;/h2>
&lt;ul>
&lt;li>**-k, &amp;ndash;keep-open **# 通常与 -l 选项配合使用。在监听模式下接受多个连接。若不使用 -k 选项，则第一个连接断开后，监听也就结束了。&lt;/li>
&lt;li>&lt;strong>-l, &amp;ndash;listen &lt;!-- raw HTML omitted -->&lt;/strong> # 让程序监听指定的端口&lt;/li>
&lt;li>**-u, &amp;ndash;udp **# 使用 UDP，而不是默认的 TCP&lt;/li>
&lt;/ul>
&lt;p>Ncat 与 OpenBSD-nc 这两个程序的选项有不同的地方&lt;/p>
&lt;h3 id="ncat-options">Ncat OPTIONS&lt;/h3>
&lt;ul>
&lt;li>&lt;strong>&amp;ndash;proxy &lt;a href="ADDRESS:%5BPORT%5D">ADDRESS:[PORT]&lt;/a>&lt;/strong> # 连接目的地时所使用代理 IP 和 PORT。&lt;/li>
&lt;li>&lt;strong>&amp;ndash;proxy-type &lt;!-- raw HTML omitted -->&lt;/strong> # 连接目的地时所使用的代理类型(也就是代理协议)。可用的值有：
&lt;ul>
&lt;li>socks4 # 表示 SOCKS v.4&lt;/li>
&lt;li>socks5 # 表示 SOCKS v.5。默认值&lt;/li>
&lt;li>http # 表示 HTTP&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h3 id="openbsd-nc-options">OpenBSD-nc OPTIONS&lt;/h3>
&lt;ul>
&lt;li>&lt;strong>-x &amp;lt;ADDRESS[:PORT]&amp;gt;&lt;/strong> # 连接目的地时所使用代理 IP 和 PORT。代理不能与 -LsuU 这些选项一起使用。&lt;/li>
&lt;li>&lt;strong>-X &lt;!-- raw HTML omitted -->&lt;/strong> # 连接目的地时所使用的代理协议。可用的值有：
&lt;ul>
&lt;li>4 # 表示 SOCKS v.4&lt;/li>
&lt;li>5 # 表示 SOCKS v.5。默认值&lt;/li>
&lt;li>connect # 表示 HTTP&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h1 id="应用示例">应用示例&lt;/h1>
&lt;ul>
&lt;li>测试本地 323/udp 端口
&lt;ul>
&lt;li>nc -uvz localhost 323&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>测试本地 22/tcp 端口
&lt;ul>
&lt;li>nc -vz localhost 22&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>执行效果如下：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>root@lichenhao:~# nc -vz localhost &lt;span style="color:#ae81ff">22&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Connection to localhost &lt;span style="color:#ae81ff">22&lt;/span> port &lt;span style="color:#f92672">[&lt;/span>tcp/ssh&lt;span style="color:#f92672">]&lt;/span> succeeded!
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>root@lichenhao:~# nc -uvz localhost &lt;span style="color:#ae81ff">323&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Connection to localhost &lt;span style="color:#ae81ff">323&lt;/span> port &lt;span style="color:#f92672">[&lt;/span>udp/*&lt;span style="color:#f92672">]&lt;/span> succeeded!
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>测试两台机器之间的 8080/udp 连接是否正常&lt;/p>
&lt;ul>
&lt;li>在主机 A 上监听 8080/udp
&lt;ul>
&lt;li>nc -u -l 8080&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>在主机 B 上测试主机 A 的 8080/udp 是否正常
&lt;ul>
&lt;li>nc -u 172.19.42.248 8080&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>然后在任意主机输入任意内容，只要另一个主机能看到相同内容，即表示连接正常&lt;/li>
&lt;/ul>
&lt;h1 id="常见问题">常见问题&lt;/h1>
&lt;p>在 Windows 使用 ncat 通过代理连接 ssh，报错 &lt;code>ssh_exchange_identification: Connection closed by remote host&lt;/code>
问题 issue：&lt;a href="https://github.com/nmap/nmap/issues/2149">https://github.com/nmap/nmap/issues/2149&lt;/a>
解决：下载 7.80 版本即可，将下载连接的版本号改为 7.80 即可下载。&lt;/p>
&lt;h1 id="nmap">Nmap&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://nmap.org/book/man.html">Manual(手册),NMAP(1)&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>&lt;strong>Network Mapper(网络映射器，简称 Nmap)&lt;/strong> 是一个用于网络探索和安全审计的开源工具。旨在快速扫描大型网络。&lt;/p>
&lt;h2 id="syntax语法-1">Syntax(语法)&lt;/h2>
&lt;p>&lt;strong>nmap [Scan Type&amp;hellip;] [OPTIONS] {TARGET}&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>&lt;strong>Scan Type(扫描类型)&lt;/strong> #&lt;/li>
&lt;li>**TARGET **# 扫描目标&lt;/li>
&lt;/ul>
&lt;p>直接使用 &lt;code>nmap IP&lt;/code> 即可开始一个简单的扫描任务&lt;/p>
&lt;h2 id="example">EXAMPLE&lt;/h2></description></item><item><title>Docs: opensuse的一次救援</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/x.linux-%E7%AE%A1%E7%90%86/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96-%E4%B8%8E-%E6%95%85%E9%9A%9C%E5%A4%84%E7%90%86/%E6%95%85%E9%9A%9C%E5%A4%84%E7%90%86%E6%A1%88%E4%BE%8B/opensuse%E7%9A%84%E4%B8%80%E6%AC%A1%E6%95%91%E6%8F%B4/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/x.linux-%E7%AE%A1%E7%90%86/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96-%E4%B8%8E-%E6%95%85%E9%9A%9C%E5%A4%84%E7%90%86/%E6%95%85%E9%9A%9C%E5%A4%84%E7%90%86%E6%A1%88%E4%BE%8B/opensuse%E7%9A%84%E4%B8%80%E6%AC%A1%E6%95%91%E6%8F%B4/</guid><description>
&lt;p>昨晚吃完晚饭回到办公室，右边同事在控制台看着一个 suse 起不来一直启动的时候卡在 suse 的蜥蜴 logo 背景图那。见我来了叫我看下，他们已经尝试过恢复快照，但是还不行，应该是很久之前损坏的，只不过因为没重启没发现，我叫他重启下看看卡在哪，重启后进入内核后显示背景图那按下 esc 然后看卡在 / sysroot 挂载那。目测分区损坏了，经历了 ubuntu 的安装 iso 的 rescue mode 就是渣渣后，我还是信任 centos 的 iso。&lt;/p>
&lt;h2 id="处理">处理&lt;/h2>
&lt;h3 id="先备份和准备工作">先备份和准备工作&lt;/h3>
&lt;p>关闭虚机，后台拷贝下系统盘的卷先备份下。然后给虚机的 IDE 光驱挂载了个 centos 7.5 DVD 的 iso，修改虚机启动顺序到 ISO，进&lt;code>Troubleshooting&lt;/code> –&amp;gt; &lt;code>Rescue a CentOS Linux system&lt;/code>
一般损坏的都不建议选 1，因为挂载不上，所以是选 3 手动处理&lt;/p>
&lt;h3 id="device-or-resource-busy">Device or resource busy&lt;/h3>
&lt;pre>&lt;code>1) Continue
2) Read-only mount
3) Skip to shell
4) Quit (Reboot)
Please make a selection from the above: 3
&lt;/code>&lt;/pre>
&lt;p>最开始我 lsblk 和看了下硬盘的分区表，最后&lt;code>vgchange -a y&lt;/code>激活 lvm 后&lt;code>xfs_repair /dev/mapper/suse-lv_root&lt;/code>的时候提示该设备繁忙，遂查看了下&lt;/p>
&lt;pre>&lt;code>sh-4.2# lsof /dev/mapper/suse-lv_root
sh-4.2# ps aux | less
&lt;/code>&lt;/pre>
&lt;p>lsof 和 fuser 都是返回空的，最后就&lt;code>ps aux&lt;/code>一个个看，发现了个 mount 进程一直 hung 在那&lt;/p>
&lt;pre>&lt;code>sh-4.2# ps aux | grep moun[t]
root 6126 0.0 0.0 19940 840 pts/0 D+ 11:56 0:00 /usr/bin/mount -t xfs -o defaults,ro /dev/mapper/suse-lv_root /mnt/sysimage
&lt;/code>&lt;/pre>
&lt;p>这个进程尝试过了，死活杀不掉，进 rescue mode 的时候选的&lt;code>Skip to shell&lt;/code>，以为是 iso 的版本 bug，换了一个 7.6 minimal 的 iso 进入 rescue mode 后不选择直接&lt;code>ctrl+alt+F2&lt;/code>进到 tty 还是一样会自动挂载，于是想下从父进程的角度上看看能不能处理&lt;/p>
&lt;pre>&lt;code>[anaconda root@localhost /]# ps aux | grep moun[t]
root 6113 0.0 0.0 19940 840 pts/0 D+ 12:02 0:00 /usr/bin/mount -t xfs -o defaults,ro /dev/mapper/suse-lv_root /mnt/sysimage
[anaconda root@localhost /]# ps -Al | grep mount
4 D 0 6113 5862 0 80 0 - 4985 xfs_bu pts/0 00:00:00 mount
[anaconda root@localhost /]# ps aux | grep 586[2]
root 5862 0.0 0.0 19940 840 pts/0 D+ 12:02 0:00 python anaconda
&lt;/code>&lt;/pre>
&lt;p>找到了该 mount 的父进程是 anaconda，也就是我们进入 rescue mode 的第一个 tty 提供交互，直接杀掉它，mount 终止&lt;/p>
&lt;pre>&lt;code>[anaconda root@localhost /]# kill -9 5862;kill 6113
bash: kill: (6113) - No such process
&lt;/code>&lt;/pre>
&lt;p>但是还是 busy，发现该 mount 又 tm 的起来了，最终想了个骚套路，进入 rescue mode，然后 4 个选项不选择，直接&lt;code>ctrl+alt+F2&lt;/code>进到 tty 后杀掉 mount 的进程后把 mount 命名改名，执行下面&lt;/p>
&lt;pre>&lt;code>[anaconda root@localhost /]# mv /usr/bin/mount{,.bak} #先改名，再杀进程
[anaconda root@localhost /]# ps aux | grep moun[t]
root 6128 0.3 0.0 19940 844 pts/0 D+ 12:06 0:00 /usr/bin/mount -t xfs -o defaults,ro /dev/mapper/suse-lv_root /mnt/sysimage
[anaconda root@localhost /]# ps -Al | grep mount
4 D 0 6128 5877 0 80 0 - 4985 xfs_bu pts/0 00:00:00 mount
[anaconda root@localhost /]# kill -9 5877;kill 6128
bash: kill: (6128) - No such process
[anaconda root@localhost /]# ps aux | grep moun[t] #然后再也没mount进程
&lt;/code>&lt;/pre>
&lt;h3 id="修复">修复&lt;/h3>
&lt;p>接着前面的，激活 lvm，这里不详细说，可以自己去&lt;code>lsblk&lt;/code>和&lt;code>fdisk -l /dev/vdx&lt;/code>去看相关分区信息&lt;/p>
&lt;pre>&lt;code>[anaconda root@localhost /]# vgchange -a y
1 logical volume(s) in volume group &amp;quot;suse&amp;quot; now active
4 logical volume(s) in volume group &amp;quot;vgsap&amp;quot; now active
&lt;/code>&lt;/pre>
&lt;!-- raw HTML omitted -->
&lt;pre>&lt;code>[anaconda root@localhost /]# xfs_repair /dev/mapper/suse-lv_root
ERROR: The filesystem has valuable metadata changes in a log which needs to
be replayed. Mount the filesystem to replay the log, and unmount it before
re-running xfs_repair. If you are unable to mount the filesystem, then use
the -L option to destroy the log and attempt a repair.
Note that destroying the log may cause corruption -- please attempt a mount
of the filesystem before doing this.
&lt;/code>&lt;/pre>
&lt;p>该报错大致意思是: 文件系统的 log 需要在 repair 之前先 mount 它来触发回放 log，如果无法挂载，使用&lt;code>xfs_repair&lt;/code>带上&lt;code>-L&lt;/code>选项摧毁 log 强制修复
正确姿势是先使用&lt;code>xfs_metadump&lt;/code>导出 metadata，见文章 &lt;a href="https://serverfault.com/questions/777299/proper-way-to-deal-with-corrupt-xfs-filesystems">https://serverfault.com/questions/777299/proper-way-to-deal-with-corrupt-xfs-filesystems&lt;/a>
这里因为已经损坏了，没必要测试 mount 了，并且我未导出 metadata，直接 - L 修复的，下次遇到了相似场景可以试下&lt;code>xfs_metadump&lt;/code>&lt;/p>
&lt;pre>&lt;code>[anaconda root@localhost /]# xfs_repair -L /dev/mapper/suse-lv_root
&lt;/code>&lt;/pre>
&lt;p>漫长的等待修复，然后卡在了一个 inode 那，等待了 20 分钟直接&lt;code>ctrl c&lt;/code>取消再来，然当这次不需要带&lt;code>-L&lt;/code>选项&lt;/p>
&lt;pre>&lt;code>[anaconda root@localhost /]# xfs_repair /dev/mapper/suse-lv_root
...
...
resetting inode 15847758 nlinks from 0 to 2
resetting inode 16180728 nlinks from 0 to 2
resetting inode 16500950 nlinks from 0 to 2
resetting inode 17347042 nlinks from 0 to 2
resetting inode 19414733 nlinks from 0 to 2
Metadata corruption detected at xfs_dir3_block block 0x2a09ba8/0x1000
libxfs_writebufr: write verufer failed on xfs_dur3_block bno 0x2a09ba8/0x1000
Metadata corruption detected at xfs_dir3_block block 0x145ce28/0x1000
libxfs_writebufr: write verufer failed on xfs_dur3_block bno 0x145ce28/0x1000
...
...
Maximum metadata LSN (1919513701:1600352110) is ahead of log (1:2).
Format log to cycle 1919513704.
releasing dirty buffer (bulk) to free list!releasing dirty buffer (bulk) to free list!releasing dirty buffer (bulk) to free list!releasing dirty buffer (bulk) to free list!releasing dirty buffer (bulk) to free list!releasing dirty buffer (bulk) to free list!releasing dirty buffer (bulk) to free list!releasing dirty buffer (bulk) to free list!releasing dirty buffer (bulk) to free list!releasing dirty buffer (bulk) to free list!done
&lt;/code>&lt;/pre>
&lt;p>然后再次修复&lt;/p>
&lt;pre>&lt;code>[anaconda root@localhost /]# xfs_repair /dev/mapper/suse-lv_root
Phase 1 - find and verify superblock...
Phase 2 - using internal log
- zero log...
- scan filesystem freespace and inode maps...
- found root inode chunk
Phase 3 - for each AG...
- scan and clear agi unlinked lists...
- process known inodes and perfrom inode discovery...
- agno = 0
...
- setting up duplicate extent list...
- check for inodes claiming duplicate blocks...
- agno = 1
- agno = 0
- agno = 2
- agno = 3
Phase 5 - rebuild AG headers and trees...
- reset superblock...
Phase 6 - check inode connectivity...
- resetting contents of realtime bitmap and summary inodes
- traversing filesystem ...
- traversal finished ...
- moveing disconnected inodes to lost_found ...
Phase 7 - verify and correct link counts...
resetting inode 64 nlinks from 25 to 24
done
&lt;/code>&lt;/pre>
&lt;p>然后挂载试试&lt;/p>
&lt;pre>&lt;code>[anaconda root@localhost /]# mount /dev/mapper/suse-lv_root /mnt/sysimage
bash： mount: command not found
[anaconda root@localhost /]# mount.bak /dev/mapper/suse-lv_root /mnt/sysimage #漫长等待，大概30多秒
[anaconda root@localhost /]# ls -l /mnt/sysimage
total 40296
drwxr-xr-x 2 root root 4096 Aug 6 2018 bin
drwxr-xr-x 3 root root 6 Aug 6 2018 boot
drwxr-xr-x 22 root root 6 Aug 6 22:19 dev
drwxr-xr-x 131 root root 8192 Nov 30 04:05 etc
drwxr-xr-x 5 root root 46 Oct 18 2018 home
drwxr-xr-x 12 root root 8192 Nov 30 04:04 lib
drwxr-xr-x 7 root root 8192 Aug 6 2018 lib64
drwxr-xr-x 2270 root root 27242496 Dec 4 20:47 lost+found
drwxr-xr-x 2 root root 6 Jun 27 2017 mnt
drwxr-xr-x 2 root root 6 Jun 27 2017 opt
dr-xr-xr-x 190 root root 6 Aug 6 2018 proc
drwx------ 21 root root 4096 Nov 30 04:39 root
drwxr-xr-x 31 root root 6 Aug 6 2018 run
drwxr-xr-x 4 root sapsys 6 Oct 11 2018 sapmnt
drwxr-xr-x 2 root root 8192 Oct 11 2018 sbin
drwxr-xr-x 2 root root 6 Jun 27 2017 selinux
drwxr-xr-x 9 root root 4096 Oct 11 2018 software
drwxr-xr-x 4 root root 28 Aug 6 2018 srv
dr-xr-xr-x 13 root root 0 Dec 4 22:16 sys
drwxrwxrwt 31 root root 4096 Dec 3 22:18 tmp
drwxr-xr-x 14 root root 182 Nov 30 04:37 usr
drwxr-xr-x 13 root root 201 Nov 30 04:37 var
&lt;/code>&lt;/pre>
&lt;p>然后取消光驱挂载，修改启动顺序重启，能进到登陆，直接&lt;code>ctrl+alt+F2&lt;/code>进到 tty 登陆，发现没有网络，查看了下失败的启动，控制台观察的，输出不能被复制，下面命令输出大致的写下&lt;/p>
&lt;pre>&lt;code>$ systemctl --failed
UNIT LOAD ACTIVE SUB DESCRIPTION
● cryptctl-auto-unlock@sys-devices-pci0000:00-0000:00:08.0-virtio3-block-vda.service
● cryptctl-auto-unlock@aD7Wov-Krfg-KPbq-Dnf6-1dAj-e9dM-N7dUir.service
● cryptctl-auto-unlock@abd69e01-d874-4658-b738-1107d33cd84c.service
● cryptctl-auto-unlock@abd69e01-d874-4658-b738-1107d33cd84c.service
● cryptctl-auto-unlock@0zSmA1-nPGR-FuVE-ZIvq-vxhl-2WdX-eh58e2.service
● postfix.service loaded failed failed Postfix Mail Transport Agent
● wicked.service loaded failed failed wicked managed network interfaces
● wickedd-auto4.service loaded failed failed wicked AutoIPv4 supplicant service
● wickedd-dhcp4.service loaded failed failed wicked DHCPv4 supplicant service
● wickedd-dhcp6.service loaded failed failed wicked DHCPv6 supplicant service
● wickedd.service loaded failed failed wicked network management service daemon
LOAD = Reflects whether the unit definition was properly loaded.
ACTIVE = The high-level unit activation state, i.e. generalization of SUB.
SUB = The low-level unit activation state, values depend on unit type.
&lt;/code>&lt;/pre>
&lt;p>查看了下系统日志&lt;/p>
&lt;pre>&lt;code>vi /var/log/messages
2019-12-04T21:42:56.401177+08:00 bpcprdascs1 cryptctl[1506]: open /etc/sysconfig/cryptctl-client: no such file or directory
2019-12-04T21:42:56.403110+08:00 bpcprdascs1 cryptctl[1515]: open /etc/sysconfig/cryptctl-client: no such file or directory
2019-12-04T21:42:56.408475+08:00 bpcprdascs1 cryptctl[1495]: open /etc/sysconfig/cryptctl-client: no such file or directory
2019-12-04T21:42:56.408634+08:00 bpcprdascs1 cryptctl[1529]: open /etc/sysconfig/cryptctl-client: no such file or directory
2019-12-04T21:42:56.408807+08:00 bpcprdascs1 cryptctl[1508]: open /etc/sysconfig/cryptctl-client: no such file or directory
2019-12-04T21:42:56.414068+08:00 bpcprdascs1 systemd[1]: cryptctl-auto-unlock@sys-devices-pci0000:00-0000:00:08.0-virtio3-block-vda.service: Main process exited, code=exited, status=1/FAILURE
2019-12-04T21:42:56.414237+08:00 bpcprdascs1 systemd[1]: cryptctl-auto-unlock@sys-devices-pci0000:00-0000:00:08.0-virtio3-block-vda.service: Unit entered failed state.
2019-12-04T21:42:56.414319+08:00 bpcprdascs1 systemd[1]: cryptctl-auto-unlock@sys-devices-pci0000:00-0000:00:08.0-virtio3-block-vda.service: Failed with result 'exit-code'.
2019-12-04T21:42:56.414403+08:00 bpcprdascs1 systemd[1]: cryptctl-auto-unlock@aD7Wov-Krfg-KPbq-Dnf6-1dAj-e9dM-N7dUir.service: Main process exited, code=exited, status=1/FAILURE
2019-12-04T21:42:56.414467+08:00 bpcprdascs1 systemd[1]: cryptctl-auto-unlock@aD7Wov-Krfg-KPbq-Dnf6-1dAj-e9dM-N7dUir.service: Unit entered failed state.
2019-12-04T21:42:56.414528+08:00 bpcprdascs1 systemd[1]: cryptctl-auto-unlock@aD7Wov-Krfg-KPbq-Dnf6-1dAj-e9dM-N7dUir.service: Failed with result 'exit-code'.
2019-12-04T21:42:56.414596+08:00 bpcprdascs1 systemd[1]: cryptctl-auto-unlock@abd69e01-d874-4658-b738-1107d33cd84c.service: Main process exited, code=exited, status=1/FAILURE
2019-12-04T21:42:56.414657+08:00 bpcprdascs1 systemd[1]: cryptctl-auto-unlock@abd69e01-d874-4658-b738-1107d33cd84c.service: Unit entered failed state.
2019-12-04T21:42:56.414735+08:00 bpcprdascs1 systemd[1]: cryptctl-auto-unlock@abd69e01-d874-4658-b738-1107d33cd84c.service: Failed with result 'exit-code'.
2019-12-04T21:42:56.414794+08:00 bpcprdascs1 systemd[1]: cryptctl-auto-unlock@0zSmA1-nPGR-FuVE-ZIvq-vxhl-2WdX-eh58e2.service: Main process exited, code=exited, status=1/FAILURE
2019-12-04T21:42:56.414851+08:00 bpcprdascs1 systemd[1]: cryptctl-auto-unlock@0zSmA1-nPGR-FuVE-ZIvq-vxhl-2WdX-eh58e2.service: Unit entered failed state.
2019-12-04T21:42:56.414907+08:00 bpcprdascs1 systemd[1]: cryptctl-auto-unlock@0zSmA1-nPGR-FuVE-ZIvq-vxhl-2WdX-eh58e2.service: Failed with result 'exit-code'.
&lt;/code>&lt;/pre>
&lt;p>发现该文件丢失，同样系统的机器上去把内容手动创建，然后重启只剩下这些&lt;/p>
&lt;pre>&lt;code>● wicked.service loaded failed failed wicked managed network interfaces
● wickedd-auto4.service loaded failed failed wicked AutoIPv4 supplicant service
● wickedd-dhcp4.service loaded failed failed wicked DHCPv4 supplicant service
● wickedd-dhcp6.service loaded failed failed wicked DHCPv6 supplicant service
● wickedd.service loaded failed failed wicked network management service daemon
&lt;/code>&lt;/pre>
&lt;p>找到相关日志，或者手动启动 wicked 或者网卡也报错下面类似&lt;/p>
&lt;pre>&lt;code>2019-12-04T21:54:50.170654+08:00 bpcprdascs1 wickedd[1399]: Failed to register dbus bus name &amp;quot;org.opensuse.Network&amp;quot; (Connection &amp;quot;:1.2&amp;quot; is not allowed to own the service &amp;quot;org.opensuse.Network&amp;quot; due to security policies in the configuration file)
2019-12-04T21:54:50.170657+08:00 bpcprdascs1 wickedd[1399]: unable to initialize dbus service
2019-12-04T21:54:50.170659+08:00 bpcprdascs1 systemd[1]: wickedd.service: Main process exited, code=exited, status=1/FAILURE
2019-12-04T21:54:50.170661+08:00 bpcprdascs1 systemd[1]: Failed to start wicked network management service daemon.
...
2019-12-04T22:02:05.868058+08:00 bpcprdascs1 wicked: /org/opensuse/Network/Interface.getManagedObjects failed. Server responds:
2019-12-04T22:02:05.868883+08:00 bpcprdascs1 wicked: org.freedesktop.DBus.Error.ServiceUnknown: The name org.opensuse.Network was not provided by any .service files
&lt;/code>&lt;/pre>
&lt;p>这个错误找了一圈都没正确的解决办法，还是自己突发奇想在&lt;code>/etc/dbus-1/&lt;/code>对比了下发现文件丢失
正常机器上&lt;/p>
&lt;pre>&lt;code>bpcprdascs2:/etc/dbus-1/system.d # find /etc/dbus-1/ -type f
/etc/dbus-1/system.d/org.opensuse.Snapper.conf
/etc/dbus-1/system.d/org.freedesktop.hostname1.conf
/etc/dbus-1/system.d/org.freedesktop.import1.conf
/etc/dbus-1/system.d/org.freedesktop.locale1.conf
/etc/dbus-1/system.d/org.freedesktop.login1.conf
/etc/dbus-1/system.d/org.freedesktop.machine1.conf
/etc/dbus-1/system.d/org.freedesktop.systemd1.conf
/etc/dbus-1/system.d/org.freedesktop.timedate1.conf
/etc/dbus-1/system.d/com.redhat.PrinterDriversInstaller.conf
/etc/dbus-1/system.d/org.freedesktop.UPower.conf
/etc/dbus-1/system.d/org.freedesktop.GeoClue2.Agent.conf
/etc/dbus-1/system.d/org.freedesktop.GeoClue2.conf
/etc/dbus-1/system.d/bluetooth.conf
/etc/dbus-1/system.d/com.redhat.tuned.conf
/etc/dbus-1/system.d/org.freedesktop.PolicyKit1.conf
/etc/dbus-1/system.d/org.freedesktop.UDisks2.conf
/etc/dbus-1/system.d/org.freedesktop.RealtimeKit1.conf
/etc/dbus-1/system.d/org.freedesktop.Accounts.conf
/etc/dbus-1/system.d/org.opensuse.Network.AUTO4.conf
/etc/dbus-1/system.d/org.opensuse.Network.DHCP4.conf
/etc/dbus-1/system.d/org.opensuse.Network.DHCP6.conf
/etc/dbus-1/system.d/org.opensuse.Network.Nanny.conf
/etc/dbus-1/system.d/org.opensuse.Network.conf
/etc/dbus-1/system.d/pulseaudio-system.conf
/etc/dbus-1/system.d/org.freedesktop.PackageKit.conf
/etc/dbus-1/system.d/cups.conf
/etc/dbus-1/system.d/org.opensuse.CupsPkHelper.Mechanism.conf
/etc/dbus-1/system.d/gdm.conf
/etc/dbus-1/session.conf
/etc/dbus-1/system.conf
&lt;/code>&lt;/pre>
&lt;p>该故障机器上&lt;/p>
&lt;pre>&lt;code>bpcprdascs1:/var/log # find /etc/dbus-1/ -type f
/etc/dbus-1/system.d/org.opensuse.Snapper.conf
/etc/dbus-1/system.d/org.freedesktop.hostname1.conf
/etc/dbus-1/system.d/org.freedesktop.import1.conf
/etc/dbus-1/system.d/org.freedesktop.locale1.conf
/etc/dbus-1/system.d/org.freedesktop.login1.conf
/etc/dbus-1/system.d/org.freedesktop.machine1.conf
/etc/dbus-1/system.d/org.freedesktop.systemd1.conf
/etc/dbus-1/system.d/org.freedesktop.timedate1.conf
/etc/dbus-1/system.d/com.redhat.PrinterDriversInstaller.conf
/etc/dbus-1/system.d/org.freedesktop.UPower.conf
/etc/dbus-1/system.d/org.freedesktop.GeoClue2.Agent.conf
/etc/dbus-1/system.d/org.freedesktop.GeoClue2.conf
/etc/dbus-1/system.d/bluetooth.conf
/etc/dbus-1/system.d/com.redhat.tuned.conf
/etc/dbus-1/system.d/org.freedesktop.PolicyKit1.conf
/etc/dbus-1/system.d/org.freedesktop.RealtimeKit1.conf
/etc/dbus-1/session.conf
/etc/dbus-1/system.conf
&lt;/code>&lt;/pre>
&lt;p>因为故障机器的网络无法启动，即使手动&lt;code>ip addr add&lt;/code>也报错 dbus，所以无法通过网络 scp。于是在后台正常机器给添加了一个数据盘，把该目录的文件拷贝到数据盘上，再把数据盘挂载到故障机器上。然后 cp 拷贝完重启，然后网络起来了
只剩下故障&lt;/p>
&lt;pre>&lt;code>$ systemctl --failed
UNIT LOAD ACTIVE SUB DESCRIPTION
● wickedd-auto4.service loaded failed failed wicked AutoIPv4 supplicant service
● wickedd-dhcp4.service loaded failed failed wicked DHCPv4 supplicant service
● wickedd-dhcp6.service loaded failed failed wicked DHCPv6 supplicant service
&lt;/code>&lt;/pre>
&lt;p>上面三个通过系统日志可以找到是文件丢失，其他机器上去拷贝就行了，当然也不是只有这三个服务的文件丢失，其他服务的文件也丢失了，自行看下系统日志处理下&lt;/p>
&lt;pre>&lt;code>2019-12-04T21:54:50.170648+08:00 bpcprdascs1 display-manager[1429]: /usr/lib/X11/display-manager: line 17: /etc/sysconfig/displaymanager: No such file or directory
2019-12-04T22:18:03.689878+08:00 bpcprdascs1 systemd[1395]: wickedd-dhcp6.service: Failed at step EXEC spawning /usr/lib/wicked/bin/wickedd-dhcp6: No such file or directory
...
2019-12-04T22:18:03.689884+08:00 bpcprdascs1 systemd[1396]: wickedd-dhcp4.service: Failed at step EXEC spawning /usr/lib/wicked/bin/wickedd-dhcp4: No such file or directory
...
2019-12-04T22:18:03.689897+08:00 bpcprdascs1 systemd[1403]: wickedd-auto4.service: Failed at step EXEC spawning /usr/lib/wicked/bin/wickedd-auto4: No such file or directory
&lt;/code>&lt;/pre>
&lt;p>&lt;a href="https://zhangguanzhang.github.io/2019/12/05/suse-fix-data-but-device-busy/">https://zhangguanzhang.github.io/2019/12/05/suse-fix-data-but-device-busy/&lt;/a>&lt;/p></description></item><item><title>Docs: perf 性能分析工具</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/x.linux-%E7%AE%A1%E7%90%86/linux-%E7%B3%BB%E7%BB%9F%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/perf-%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/x.linux-%E7%AE%A1%E7%90%86/linux-%E7%B3%BB%E7%BB%9F%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/perf-%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://github.com/torvalds/linux/tree/master/tools/perf">GitHub 项目&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://perf.wiki.kernel.org/index.php/Main_Page">Kernel Wiki,perf&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://qastack.cn/unix/326621/what-are-kernel-pmu-event-s-in-perf-events-list">PMU 是什么？&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>&lt;strong>Linux Performance Events(Linux 性能事件，简称 LPE)&lt;/strong> 是用来分析 Linux 性能的工具，通常称为 &lt;strong>perf&lt;/strong>。perf 随 Kernel 2.6+ 一同发布。通过它，应用程序可以利用 PMU，tracepoint 和内核中的特殊计数器来进行性能统计。它不但可以分析指定应用程序的性能问题 (per thread)，也可以用来分析内核的性能问题，当然也可以同时分析应用代码和内核，从而全面理解应用程序中的性能瓶颈。&lt;/p>
&lt;p>perf 主要是通过 &lt;strong>Tracing(追踪)&lt;/strong> 的方式来实现性能数据的采集。&lt;/p>
&lt;h1 id="perf-安装">perf 安装&lt;/h1>
&lt;p>&lt;strong>Ubuntu&lt;/strong>&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>sudo apt install -y linux-tools-generic linux-tools-&lt;span style="color:#66d9ef">$(&lt;/span>uname -r&lt;span style="color:#66d9ef">)&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;blockquote>
&lt;p>注意：linux-tools-generic 会安装 linux-tools-common 包，perf 二进制文件在这个包中。&lt;/p>
&lt;/blockquote>
&lt;p>&lt;strong>CentOS&lt;/strong>&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>yum install -y perf
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h1 id="perf-工具使用详解">perf 工具使用详解&lt;/h1>
&lt;p>&lt;strong>perf [OPTIONS] COMMAND [ARGS]&lt;/strong>
perf 主要由多个子命令来提供常用功能&lt;/p>
&lt;h2 id="record--追踪指定的进程并记录它的-profile-到-perfdata-文件中">record # 追踪指定的进程，并记录它的 profile 到 perf.data 文件中&lt;/h2>
&lt;blockquote>
&lt;p>参考：&lt;a href="https://man7.org/linux/man-pages/man1/perf-record.1.html">man 手册&lt;/a>&lt;/p>
&lt;/blockquote>
&lt;p>record 子命令将会跟踪指定命令或进程，并采集运行期间的 profile，然后默认将这些数据写入到 perf.data 文件中。**profile **这个词在这个语境中，可以理解为 &lt;strong>性能分析&lt;/strong>，详见 &lt;a href="https://www.yuque.com/go/doc/44354412">火焰图章节&lt;/a>&lt;/p>
&lt;p>&lt;strong>perf record [OPTIONS] [COMMAND]&lt;/strong>
&lt;strong>COMMAND&lt;/strong> # 可以指定一个命令，以便采集指定命令运行时的性能数据。或者省略 COMMAND，则采集当前系统下的所有进程。&lt;/p>
&lt;hr>
&lt;p>OPTIONS&lt;/p>
&lt;ul>
&lt;li>&lt;strong>-a, &amp;ndash;all-cpus&lt;/strong> # 从所有 CPU 采集数据&lt;/li>
&lt;li>**-g **# 启动调用关系分析&lt;/li>
&lt;li>**-p, &amp;ndash;pid &lt;!-- raw HTML omitted --> **# 指定要采集数据的进程的 PID&lt;/li>
&lt;/ul>
&lt;p>EXAMPLE&lt;/p>
&lt;ul>
&lt;li>&lt;strong>perf record -a -g -p 5958 &amp;ndash; sleep 30&lt;/strong>&lt;/li>
&lt;/ul>
&lt;h2 id="report--读取-perfdata-文件中记录的内容并展示">report # 读取 perf.data 文件中记录的内容并展示&lt;/h2>
&lt;h2 id="script--读取-perfdata-文件中记录的内容并展示追踪效果的数据">script # 读取 perf.data 文件中记录的内容，并展示追踪效果的数据&lt;/h2>
&lt;h2 id="top--系统分析工具">top # 系统分析工具&lt;/h2>
&lt;p>可以实时显示占用 CPU 时钟最多得函数或进程。以 Symbol 为中心，显示指定 Symbol 的相关信息&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>Samples: 2K of event &lt;span style="color:#e6db74">&amp;#39;cpu-clock:pppH&amp;#39;&lt;/span>, &lt;span style="color:#ae81ff">4000&lt;/span> Hz, Event count &lt;span style="color:#f92672">(&lt;/span>approx.&lt;span style="color:#f92672">)&lt;/span>: &lt;span style="color:#ae81ff">317933941&lt;/span> lost: 0/0 drop: 0/0
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Overhead Shared Object Symbol
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>16.96% perf &lt;span style="color:#f92672">[&lt;/span>.&lt;span style="color:#f92672">]&lt;/span> __symbols__insert
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>7.12% perf &lt;span style="color:#f92672">[&lt;/span>.&lt;span style="color:#f92672">]&lt;/span> rb_next
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>3.92% &lt;span style="color:#f92672">[&lt;/span>kernel&lt;span style="color:#f92672">]&lt;/span> &lt;span style="color:#f92672">[&lt;/span>k&lt;span style="color:#f92672">]&lt;/span> kallsyms_expand_symbol.constprop.1
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>第一行：&lt;/p>
&lt;ol>
&lt;li>Samples # 样本数&lt;/li>
&lt;li>event # 事件类型&lt;/li>
&lt;li>event count # 事件总数&lt;/li>
&lt;/ol>
&lt;p>第二行&lt;/p>
&lt;ol>
&lt;li>Overhead # Symbol 的性能事件在所有样本中的百分比&lt;/li>
&lt;li>Shared # Symbol 所在的动态共享对象(Dynamic Shared Object)。如 内核、进程名、动态链接库名、内核模块等等&lt;/li>
&lt;li>Object # 动态共享对象的类型。比如 [.] 表示用户空间的可执行程序、或动态链接库，而 [k] 则表示内核空间&lt;/li>
&lt;li>Symbol # 符号名。即函数名。当函数名未知时，用十六进制的地址来表示。&lt;/li>
&lt;/ol>
&lt;p>&lt;strong>perf top [OPTIONS]&lt;/strong>&lt;/p>
&lt;p>OPTIONS&lt;/p>
&lt;ul>
&lt;li>&lt;strong>-g&lt;/strong> # 开启调用关系分析&lt;/li>
&lt;li>&lt;strong>-p &lt;!-- raw HTML omitted -->&lt;/strong> # 分析指定进程的事件，PID 可以是使用 逗号 分隔的多个 PID&lt;/li>
&lt;/ul>
&lt;p>EXAMPLE&lt;/p>
&lt;ul>
&lt;li>&lt;/li>
&lt;/ul>
&lt;h1 id="生成火焰图">生成火焰图&lt;/h1>
&lt;p>获取火焰图生成工具&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>git clone https://github.com/brendangregg/FlameGraph
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>cd FlameGraph
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>将 perf record 抓到的记录转换成可读的采样记录
&lt;code>perf script -i /root/test_dir/perf.data&lt;/code>
合并调用栈信息
&lt;code>./stackcollapse-perf.pl&lt;/code>
生成火焰图
&lt;code>./flamegraph.pl&lt;/code>
上述命令合并一下：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>perf script -i /root/test_dir/perf.data | ./stackcollapse-perf.pl --all | ./flamegraph.pl &amp;gt; /root/test_dir/flame.svg
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div></description></item><item><title>Docs: pktgen 内核自带的高性能网络测试工具</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/x.linux-%E7%AE%A1%E7%90%86/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96-%E4%B8%8E-%E6%95%85%E9%9A%9C%E5%A4%84%E7%90%86/%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95/pktgen-%E5%86%85%E6%A0%B8%E8%87%AA%E5%B8%A6%E7%9A%84%E9%AB%98%E6%80%A7%E8%83%BD%E7%BD%91%E7%BB%9C%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/x.linux-%E7%AE%A1%E7%90%86/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96-%E4%B8%8E-%E6%95%85%E9%9A%9C%E5%A4%84%E7%90%86/%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95/pktgen-%E5%86%85%E6%A0%B8%E8%87%AA%E5%B8%A6%E7%9A%84%E9%AB%98%E6%80%A7%E8%83%BD%E7%BD%91%E7%BB%9C%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/</guid><description>
&lt;h1 id="heading">&lt;/h1>
&lt;h1 id="pktgen-内核自带的高性能网络测试工具">pktgen 内核自带的高性能网络测试工具&lt;/h1>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>modprobe pktgen
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>cat &amp;gt; /usr/local/bin/pgset &lt;span style="color:#e6db74">&amp;lt;&amp;lt;EOF
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">local result
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">echo $1 &amp;gt; $PGDEV
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">result=`cat $PGDEV | fgrep &amp;#34;Result: OK:&amp;#34;`
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">if [ &amp;#34;$result&amp;#34; = &amp;#34;&amp;#34; ]; then
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74"> cat $PGDEV | fgrep Result:
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">fi
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">EOF&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>chmod &lt;span style="color:#ae81ff">755&lt;/span> /usr/local/bin/pgset
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># 为0号线程绑定 eth0 网卡&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>export PGDEV&lt;span style="color:#f92672">=&lt;/span>/proc/net/pktgen/kpktgend_0
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>pgset &lt;span style="color:#e6db74">&amp;#34;rem_device_all&amp;#34;&lt;/span> &lt;span style="color:#75715e"># 清空网卡绑定&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>pgset &lt;span style="color:#e6db74">&amp;#34;add_device eth0&amp;#34;&lt;/span> &lt;span style="color:#75715e"># 添加 eth0 网卡&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># 配置 eth0 网卡的测试选项&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>export PGDEV&lt;span style="color:#f92672">=&lt;/span>/proc/net/pktgen/eth0
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>pgset &lt;span style="color:#e6db74">&amp;#34;count 1000000&amp;#34;&lt;/span> &lt;span style="color:#75715e"># 总发包数量&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>pgset &lt;span style="color:#e6db74">&amp;#34;delay 5000&amp;#34;&lt;/span> &lt;span style="color:#75715e"># 不同包之间的发送延迟 (单位纳秒)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>pgset &lt;span style="color:#e6db74">&amp;#34;clone_skb 0&amp;#34;&lt;/span> &lt;span style="color:#75715e"># SKB 包复制&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>pgset &lt;span style="color:#e6db74">&amp;#34;pkt_size 64&amp;#34;&lt;/span> &lt;span style="color:#75715e"># 网络包大小&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>pgset &lt;span style="color:#e6db74">&amp;#34;dst 192.168.0.30&amp;#34;&lt;/span> &lt;span style="color:#75715e"># 目的 IP&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>pgset &lt;span style="color:#e6db74">&amp;#34;dst_mac 11:11:11:11:11:11&amp;#34;&lt;/span> &lt;span style="color:#75715e"># 目的 MAC&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># 启动测试&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>export PGDEV&lt;span style="color:#f92672">=&lt;/span>/proc/net/pktgen/pgctrl
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>pgset &lt;span style="color:#e6db74">&amp;#34;start&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>$ cat /proc/net/pktgen/eth0
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Params: count &lt;span style="color:#ae81ff">1000000&lt;/span> min_pkt_size: &lt;span style="color:#ae81ff">64&lt;/span> max_pkt_size: &lt;span style="color:#ae81ff">64&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> frags: &lt;span style="color:#ae81ff">0&lt;/span> delay: &lt;span style="color:#ae81ff">0&lt;/span> clone_skb: &lt;span style="color:#ae81ff">0&lt;/span> ifname: eth0
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> flows: &lt;span style="color:#ae81ff">0&lt;/span> flowlen: &lt;span style="color:#ae81ff">0&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>...
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Current:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> pkts-sofar: &lt;span style="color:#ae81ff">1000000&lt;/span> errors: &lt;span style="color:#ae81ff">0&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> started: 1534853256071us stopped: 1534861576098us idle: 70673us
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>...
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Result: OK: 8320027&lt;span style="color:#f92672">(&lt;/span>c8249354+d70673&lt;span style="color:#f92672">)&lt;/span> usec, &lt;span style="color:#ae81ff">1000000&lt;/span> &lt;span style="color:#f92672">(&lt;/span>64byte,0frags&lt;span style="color:#f92672">)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> 120191pps 61Mb/sec &lt;span style="color:#f92672">(&lt;/span>61537792bps&lt;span style="color:#f92672">)&lt;/span> errors: &lt;span style="color:#ae81ff">0&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>测试报告主要分为三个部分：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>第一部分的 Params 是测试选项；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>第二部分的 Current 是测试进度，其中，packts so far（pkts-sofar）表示已经发送了 100 万个包，也就表明测试已完成。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>第三部分的 Result 是测试结果，包含测试所用时间、网络包数量和分片、PPS、吞吐量以及错误数。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>PPS，是 Packet Per Second（包 / 秒）的缩写&lt;/p></description></item><item><title>Docs: printf 与 echo 文本输出命令</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/x.linux-%E7%AE%A1%E7%90%86/linux-%E6%96%87%E6%9C%AC%E5%A4%84%E7%90%86/printf-%E4%B8%8E-echo-%E6%96%87%E6%9C%AC%E8%BE%93%E5%87%BA%E5%91%BD%E4%BB%A4/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/x.linux-%E7%AE%A1%E7%90%86/linux-%E6%96%87%E6%9C%AC%E5%A4%84%E7%90%86/printf-%E4%B8%8E-echo-%E6%96%87%E6%9C%AC%E8%BE%93%E5%87%BA%E5%91%BD%E4%BB%A4/</guid><description>
&lt;h1 id="heading">&lt;/h1>
&lt;p>printf, fprintf, sprintf, snprintf, vprintf, vfprintf, vsprintf, vsnprintf - 格式化输出转换&lt;/p>
&lt;h1 id="printf-命令格式化并且打印数据-format-and-print-data">printf 命令：格式化并且打印数据 format and print data&lt;/h1>
&lt;p>主要用于对 ARGUMENTs 进行格式化输出，ARGUMENTs 可以是字符串、数值等等，甚至可以通过变量引用；FORMAT 主要是对 ARGUMENTs 里的各种数据进行格式化输出，e.g.每个 ARGUMENT 是什么类型的(字符、整数、2 进制、16 进制等等)，各个 ARGUMENT 中间使用什么分隔符、是否换行等等。&lt;/p>
&lt;h2 id="语法格式printf-format-argument">语法格式：printf FORMAT [ARGUMENT&amp;hellip;]&lt;/h2>
&lt;p>主要用于按照 FORMAT 定义的格式来输出 ARGUMENT&amp;hellip;给出的内容&lt;/p>
&lt;h3 id="format-包括格式替代符自定义内容格式控制符这-3-个在使用的时候没有先后顺序">FORMAT 包括：格式替代符，自定义内容，格式控制符，这 3 个在使用的时候没有先后顺序。&lt;/h3>
&lt;p>格式替代符 #用于控制输出的每个 Argument 的类型。一个“格式替代符”对应后面一个 Argument，如果想要输出的类型与 Argument 给定的类型不符，则进行类型转换后输出 e.g.Argument 给了一个整数 100，而格式替代符使用的是%X,则会输出 64；若 Argument 不够 FORMAT 的个数，则以空白补充。一般情况格式替代符使用双引号引起来&lt;/p>
&lt;ol>
&lt;li>
&lt;p>%b #相对应的参数被视为含有要被处理的转义序列之字符串。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>%c #ASCII 字符。显示相对应参数的第一个字符&lt;/p>
&lt;/li>
&lt;li>
&lt;p>%d, %i #十进制整数&lt;/p>
&lt;/li>
&lt;li>
&lt;p>%e, %E, %f #浮点格式&lt;/p>
&lt;/li>
&lt;li>
&lt;p>%g #%e 或%f 转换，看哪一个较短，则删除结尾的零&lt;/p>
&lt;/li>
&lt;li>
&lt;p>%G #%E 或%f 转换，看哪一个较短，则删除结尾的零&lt;/p>
&lt;/li>
&lt;li>
&lt;p>%o #不带正负号的八进制值&lt;/p>
&lt;/li>
&lt;li>
&lt;p>%s #字符串&lt;/p>
&lt;/li>
&lt;li>
&lt;p>%u #不带正负号的十进制值&lt;/p>
&lt;/li>
&lt;li>
&lt;p>%x #不带正负号的十六进制值，使用 a 至 f 表示 10 至 15&lt;/p>
&lt;/li>
&lt;li>
&lt;p>%X #不带正负号的十六进制值，使用 A 至 F 表示 10 至 15&lt;/p>
&lt;/li>
&lt;li>
&lt;p>%% #字面意义的%&lt;/p>
&lt;/li>
&lt;/ol>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/nfqmgm/1616166371965-2e43b313-e44b-4fbe-a44b-254e0e0b37fb.jpeg" alt="">&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/nfqmgm/1616166371962-7d50c11b-356a-4098-acab-15272005b08a.jpeg" alt="">&lt;/p>
&lt;p>自定义内容 #在输出内容的格式中，可以自己添加任务字符串&lt;/p>
&lt;p>格式控制符 #用于控制输出内容整体的格式。i.e.每个参数有之间有多少空白符，在哪里换行等等&lt;/p>
&lt;ol>
&lt;li>
&lt;p>\a #警告字符，通常为 ASCII 的 BEL 字符&lt;/p>
&lt;/li>
&lt;li>
&lt;p>\b #后退&lt;/p>
&lt;/li>
&lt;li>
&lt;p>\c #抑制（不显示）输出结果中任何结尾的换行字符（只在%b 格式指示符控制下的参数字符串中有效），而且，任何留在参数里的字符、任何接下来的参数以及任何留在格式字符串中的字符，都被忽略&lt;/p>
&lt;/li>
&lt;li>
&lt;p>\f #换页（formfeed)&lt;/p>
&lt;/li>
&lt;li>
&lt;p>\n #换行&lt;/p>
&lt;/li>
&lt;li>
&lt;p>\r #回车（Carriage return）&lt;/p>
&lt;/li>
&lt;li>
&lt;p>\t #水平制表符 i.e.tab&lt;/p>
&lt;/li>
&lt;li>
&lt;p>\v #垂直制表符&lt;/p>
&lt;/li>
&lt;li>
&lt;p>\ #一个字面上的反斜杠字符&lt;/p>
&lt;/li>
&lt;li>
&lt;p>\ddd #表示 1 到 3 位数八进制值的字符。仅在格式字符串中有效&lt;/p>
&lt;/li>
&lt;li>
&lt;p>\0ddd #表示 1 到 3 位的八进制值字符&lt;/p>
&lt;/li>
&lt;/ol>
&lt;h3 id="arguments-包括各种想要输出的具体内容可以是字符串整数等甚至可以引用变量">ARGUMENTs 包括各种想要输出的具体内容，可以是字符串、整数等、甚至可以引用变量&lt;/h3>
&lt;p>每个 Argument 使用空格进行分割，一个 Argument 中的内容传递给 FORMAT 中的“格式替代符”&lt;/p>
&lt;p>EXAMPLE&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">[&lt;/span>root@node3 ~&lt;span style="color:#f92672">]&lt;/span>&lt;span style="color:#75715e"># printf &amp;#34;%-10s %-8s %-4s\n&amp;#34; 姓名 性别 体重kg; printf &amp;#34;%-10s %-8s %-4.2f\n&amp;#34; 郭靖 男 66.1234;printf &amp;#34;%-10s %-8s %-4.2f\n&amp;#34; 杨过 男 48.6543;printf &amp;#34;%-10s %-8s %-4.2f\n&amp;#34; 郭芙 女 47.9876&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>姓名 性别 体重kg
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>郭靖 男 66.12
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>杨过 男 48.65
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>郭芙 女 47.99
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>%s %c %d %f 都是格式替代符&lt;/p>
&lt;p>%-10s 指一个宽度为 10 个字符（-表示左对齐，没有则表示右对齐），任何字符都会被显示在 10 个字符宽的字符内，如果不足则自动以空格填充，超过也会将内容全部显示出来。&lt;/p>
&lt;p>%-4.2f 指格式化为小数，其中.2 指保留 2 位小数。&lt;/p>
&lt;p>\n 表示“换行符”，i.e.输出完这一段就换行，否则每个 printf 输出的内容都在一行了&lt;/p>
&lt;p>hi 是自定义内容，可以随便写&lt;/p>
&lt;h1 id="echo--显示文本">Echo # 显示文本&lt;/h1>
&lt;p>Bash 脚本是非常流行的最简单的脚本语言。 与任何编程或脚本语言一样，您会在终端上遇到打印文本。 这可能发生在许多场景中，例如当您想要输出文件的内容或检查变量的值时。 程序员还可以通过在控制台上打印变量值来调试应用程序。 因此，在我们深入研究另一个教程的 bash 脚本之前，让我们看一下在终端中输出文本的不同方式。&lt;/p>
&lt;p>为了在终端上输出文本，Echo 是您需要知道的最重要的命令。 正如名称本身所示，echo 在终端的标准输出上显示数字或字符串。 它还有许多选项，如下表所示。&lt;/p>
&lt;p>根据 Linux 文档，以下是 echo 命令的语法。&lt;/p>
&lt;p>echo [OPTIONS] [ARG&amp;hellip;.]&lt;/p>
&lt;p>OPTIONS&lt;/p>
&lt;ol>
&lt;li>
&lt;p>-n # 不打印后面的换行符&lt;/p>
&lt;/li>
&lt;li>
&lt;p>-E # 禁用反斜杠转义字符的解释，默认自带选项。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>-e # 启用反斜杠转义的解释&lt;/p>
&lt;/li>
&lt;/ol>
&lt;p>输出 args，以空格分隔，后跟换行符。返回状态始终为 0。 -E 选项禁用这些转义符的解释，即使在默认情况下已解释它们的系统上也是如此。 xpg_echo shell 选项可用于动态确定 echo 默认情况下是否扩展这些转义字符。回声并不意味着选项的结束。 echo 解释以下转义序列&lt;/p>
&lt;p>如果给出-e 选项，则启用对以下反斜杠转义字符的解释：&lt;/p>
&lt;ol>
&lt;li>
&lt;p>\a 显示警告字符&lt;/p>
&lt;/li>
&lt;li>
&lt;p>\b 退格符。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>\c 在输出中禁止另外跟在最终参数后面的换行字符。所有跟在 \c 序列后的字符都被忽略。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>\e Escape&lt;/p>
&lt;/li>
&lt;li>
&lt;p>\E&lt;/p>
&lt;/li>
&lt;li>
&lt;p>\f 换页&lt;/p>
&lt;/li>
&lt;li>
&lt;p>\n 新行&lt;/p>
&lt;/li>
&lt;li>
&lt;p>\r 回车&lt;/p>
&lt;/li>
&lt;li>
&lt;p>\t 水平选项卡&lt;/p>
&lt;/li>
&lt;li>
&lt;p>\v 垂直制表符&lt;/p>
&lt;/li>
&lt;li>
&lt;p>\ backslash&lt;/p>
&lt;/li>
&lt;/ol>
&lt;p>发送文本到标准输出&lt;/p>
&lt;p>要输出终端上的任何字符串、数字或文本，请键入以下命令并按 enter。&lt;/p>
&lt;p>echo &amp;ldquo;Hello World Linux 公社www.linuxidc.com&amp;rdquo;&lt;/p>
&lt;p>以下输出将显示在终端上&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/nfqmgm/1616166371980-9a7c412a-4bdc-4673-a511-ed9283a06d8b.jpeg" alt="">&lt;/p>
&lt;p>打印一个变量&lt;/p>
&lt;p>让我们声明一个变量并在终端上打印它的值。假设 x 是我们在 160 处初始化的一个变量。&lt;/p>
&lt;p>x=160&lt;/p>
&lt;p>现在，我们将在终端上输出变量的值。&lt;/p>
&lt;p>echo $x&lt;/p>
&lt;p>终端将打印 160。同样，您也可以将字符串存储在变量中并将其输出到终端。&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/nfqmgm/1616166371967-852dae9b-770e-40c9-b132-2ca2788f3e60.jpeg" alt="">&lt;/p>
&lt;p>试一试，让我们知道这对你来说是否容易。&lt;/p>
&lt;p>删除单词之间的空格&lt;/p>
&lt;p>这是我最喜欢的 echo 选项之一，因为它消除了句子中不同单词之间的所有空格，并将它们混在一起。在这个特性中，我们将使用表 1 中提到的两个选项。&lt;/p>
&lt;p>echo -e &amp;ldquo;欢迎来到 \bLinux \b 公社 \bwww \b.linuxidc \b.com&amp;rdquo;&lt;/p>
&lt;p>显示：欢迎来到 Linux 公社www.linuxidc.com&lt;/p>
&lt;p>从上面的示例中可以看到，我们正在启用反斜杠转义的解释以及添加退格。输出如下所示。&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/nfqmgm/1616166372007-65bfcc66-1d0b-4927-b69e-7f065e1cb924.jpeg" alt="">&lt;/p>
&lt;p>以新行输出单词&lt;/p>
&lt;p>在使用 bash 脚本时，echo 的这个选项非常方便。大多数情况下，你需要在完成后移动到下一行。因此，这是最好的选择。&lt;/p>
&lt;p>echo -e &amp;ldquo;欢迎来到 \nLinux \n 公社 \nwww \n.linuxidc \n.com&amp;rdquo;&lt;/p>
&lt;p>输出将在单独的一行中显示每个单词，如下面的屏幕截图所示。&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/nfqmgm/1616166371988-02f5d8d5-7ae2-4475-8cdd-659b85c73f30.jpeg" alt="">&lt;/p>
&lt;p>输出带声音的文本&lt;/p>
&lt;p>这是一个使用 bell 或 alert 输出文本的简单选项。为此，键入以下命令。&lt;/p>
&lt;p>echo -e &amp;ldquo;hello \a 欢迎来到 Linux 公社www.linuxidc.com&amp;rdquo;&lt;/p>
&lt;p>确保系统的音量足够大，以便在终端输出文本时能够听到微小的铃声。&lt;/p>
&lt;p>删除后面新行&lt;/p>
&lt;p>echo 的另一个选项是删除后面的换行符，以便在同一行输出所有内容。为此，我们使用“\c”选项，如下图所示。&lt;/p>
&lt;p>echo -e &amp;ldquo;欢迎来到 Linux 公社www.linuxidc.com \c 你是谁你是谁&amp;rdquo;&lt;/p>
&lt;p>显示以下输出&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/nfqmgm/1616166371985-a27b4bd3-aca2-4074-992f-721954070d00.jpeg" alt="">&lt;/p>
&lt;p>将回车符添加到输出中&lt;/p>
&lt;p>要在输出中添加特定的回车符，我们有“\r”选项。&lt;/p>
&lt;p>echo -e &amp;ldquo;Linux 公社www.linuxidc.com \r 欢迎您的来到&amp;rdquo;&lt;/p>
&lt;p>在终端上显示以下输出。&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/nfqmgm/1616166372027-a7366654-9e20-413e-bfae-f13e15fc6616.jpeg" alt="">&lt;/p>
&lt;p>在输出中使用选项卡&lt;/p>
&lt;p>在终端上打印输出时，您也可以添加水平和垂直标签。 这些产品可以用于更清洁的产品。 要添加水平制表符，您必须添加“\t”，对于垂直制表符，请添加“\v”。 我们将为这些中的每一个做一个样本，然后组合一个。&lt;/p>
&lt;p>echo -e &amp;ldquo;&lt;a href="https://www.linuxidc.com">www.linuxidc.com&lt;/a> \t 欢迎来到 Linux 公社&amp;rdquo;&lt;/p>
&lt;p>这个命令的输出如下所示&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/nfqmgm/1616166372029-9dcd1465-f711-418d-9414-46e2511d9b37.jpeg" alt="">&lt;/p>
&lt;p>echo -e &amp;ldquo;&lt;a href="https://www.linuxidc.com">www.linuxidc.com&lt;/a> \v 欢迎来到 Linux 公社&amp;rdquo;&lt;/p>
&lt;p>这个命令的输出如下所示&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/nfqmgm/1616166372005-1aca898b-377c-4bd4-82d2-70fd41a3985a.jpeg" alt="">&lt;/p>
&lt;p>这就是在终端上打印文本的所有选项。这是一个需要学习的重要特性，因为当您开始使用 bash 脚本时，它将进一步帮助您。确保你实现了每一个选项并努力练习。如果本教程帮助您解决了问题，请告诉我们。&lt;/p></description></item><item><title>Docs: procps 工具集</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/x.linux-%E7%AE%A1%E7%90%86/linux-%E7%B3%BB%E7%BB%9F%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/procps-%E5%B7%A5%E5%85%B7%E9%9B%86/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/x.linux-%E7%AE%A1%E7%90%86/linux-%E7%B3%BB%E7%BB%9F%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/procps-%E5%B7%A5%E5%85%B7%E9%9B%86/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://gitlab.com/procps-ng/procps">GitLab 项目，procps-ng/procps&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>procps 是一组命令行和全屏实用程序，它们从伪文件系统(/proc)获取信心，该文件系统为内核数据结构提供了一个简单的接口。procps 程序通常集中在描述系统上运行的进程的结构上。包括以下程序(每个标题都是一个程序)&lt;/p>
&lt;p>Note：该工具集就算是最小化安装的 linux 发行版系统也是默认包含的~&lt;/p>
&lt;h1 id="free显示系统中可用和已用的内存量">free：显示系统中可用和已用的内存量&lt;/h1>
&lt;h1 id="kill---send-a-signal-to-a-process-based-on-pid">kill - Send a signal to a process based on PID&lt;/h1>
&lt;h1 id="pgreppkillpidwait--根据名字或其他属性列出进程发送信号暂停进程">pgrep，pkill，pidwait # 根据名字或其他属性列出进程、发送信号、暂停进程&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://man7.org/linux/man-pages/man1/pgrep.1.html">Manual(手册),pgrep(1)&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>pgrep 查看当前正在运行的进程，并列出所有符合匹配模式的进程 ID。比如：&lt;code>pgrep -u root sshd&lt;/code> 命令将会列出由 root 用户运行的进程命令中包含 &lt;code>sshd&lt;/code> 字符串的进程 ID。效果如下：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>~&lt;span style="color:#f92672">]&lt;/span>&lt;span style="color:#75715e"># pgrep -u root sshd -a&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">1521&lt;/span> sshd: /usr/sbin/sshd -D &lt;span style="color:#f92672">[&lt;/span>listener&lt;span style="color:#f92672">]&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span> of 10-100 startups
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">16257&lt;/span> sshd: root@pts/1
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">26155&lt;/span> sshd: root@pts/2
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">26266&lt;/span> sshd: root@notty
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="syntax语法">Syntax(语法)&lt;/h2>
&lt;p>&lt;strong>pgrep [OPTIONS] PATTERN&lt;/strong>
&lt;strong>pkill [OPTIONS] PATTERN&lt;/strong>
&lt;strong>pidwait [OPTIONS] PATTERN&lt;/strong>&lt;/p>
&lt;p>PATTERN(模式) 代指正则表达式的匹配模式。比如 pgrep 根据 PATTERN 中的内容匹配进程&lt;/p>
&lt;p>&lt;strong>OPTIONS：&lt;/strong>
&lt;code>()&lt;/code> 表示该选项所适用的工具，若没有括号，则说明选项适用于所有三个工具&lt;/p>
&lt;ul>
&lt;li>**-SIGNAL, &amp;ndash;signal SIGNAL **# (pkill)指定要发送的信号。可以使用数字或信号名称。&lt;/li>
&lt;li>&lt;strong>-f, &amp;ndash;full&lt;/strong> # 这三个程序通常只会对进程名称进行匹配。加上 -f 之后，会对进程的完整命令行进行匹配。
&lt;ul>
&lt;li>比如 &lt;code>pgrep -f containerd&lt;/code> 将会出现 &lt;code>3313 /usr/bin/dockerd --containerd=/run/containerd/containerd.sock&lt;/code> 这种结果。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>-l, &amp;ndash;list-full&lt;/strong> # (pgrep)显示出完整的命令行以及进程 ID&lt;/li>
&lt;li>&lt;strong>-t, &amp;ndash;terminal &amp;lt;TERM,&amp;hellip;&amp;gt;&lt;/strong> # 仅匹配使用指定终端的进程。终端名称不用使用绝对路径。&lt;/li>
&lt;li>&lt;strong>-x, &amp;ndash;exact&lt;/strong> # 精确匹配。PATTERN 必须与 进程名称 或 进程命令行 完全对应上才会被匹配到。&lt;/li>
&lt;/ul>
&lt;h2 id="example">EXAMPLE&lt;/h2>
&lt;ul>
&lt;li>列出名字中包含 docker 的进程号
&lt;ul>
&lt;li>&lt;strong>pgrep docker&lt;/strong>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>列出 containerd 进程的进程号
&lt;ul>
&lt;li>&lt;strong>pgrep -x containerd&lt;/strong>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>踢掉 TTY 为 pts/1 的用户
&lt;ul>
&lt;li>&lt;strong>pkill -kill -t pts/1&lt;/strong>&lt;/li>
&lt;li>注意：想要获取一个用户所使用的终端，可以通过 &lt;a href="#hq2tD">procps 包中的 w 工具&lt;/a>即可&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h1 id="pmap---report-memory-map-of-a-process">pmap - Report memory map of a process&lt;/h1>
&lt;h1 id="ps--process-status进程状态报告进程的信息">ps # process status(进程状态)，报告进程的信息&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://man.cx/ps">Manual(手册)&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>Note：该命令显示出来的带 &lt;code>[]&lt;/code> 的进程为内核线程，一般不用关注。出现这种情况一般是因为 ps 命令无法获取进程的命令参数，所以会将命令名称放入括号中。毕竟用户态的 ps 命令怎么可能会获得内核内部程序的参数呢~~~&lt;/p>
&lt;p>ps 命令输出的内容中部分字段的含义说明：&lt;/p>
&lt;ol>
&lt;li>PID # Process ID(进程标识符)&lt;/li>
&lt;li>PPID # Parent Process ID(父进程标识符)，父进程是创建一个或多个子进程的进程。&lt;/li>
&lt;li>VSZ # Virtual Memory Size(虚拟内存大小)，包括进程可以访问的所有内存，包括进入交换分区的内容，以及共享库占用的内存。有的地方也称为 total_vm、VIRT&lt;/li>
&lt;li>RRS # Resident Set Size(实际内存用量)，不包括进入交换分区的内存。RSS 包括共享库占用的内存（只要共享库在内存中）。RSS 包括所有分配的栈内存和堆内存。&lt;/li>
&lt;li>LWP # 线程 ID&lt;/li>
&lt;li>NLWP # 线程数量&lt;/li>
&lt;li>STAT # 进程的当前状态
&lt;ol>
&lt;li>D # 不可中断的休眠。通常是 IO。&lt;/li>
&lt;li>R # 运行。正在运行或者在运行队列中等待。&lt;/li>
&lt;li>S # 休眠。在等待某个事件，信号。&lt;/li>
&lt;li>T # 停止。进程接收到信息 SIGSTOP，SIGSTP，SIGTIN，SIGTOU 信号。&lt;/li>
&lt;li>X # 死掉的进程，不应该出现。&lt;/li>
&lt;li>Z # 僵死进程。
&lt;ol>
&lt;li>通常还会跟随如下字母表示更详细的状态。
&lt;ol>
&lt;li>&amp;lt; 高优先级&lt;/li>
&lt;li>N 低优先级&lt;/li>
&lt;li>L 有 pages 在内存中 locked。用于实时或者自定义 IO。&lt;/li>
&lt;li>s 进程领导者，其有子进程。&lt;/li>
&lt;li>l 多线程&lt;/li>
&lt;li>
&lt;ul>
&lt;li>位于前台进程组。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ol>
&lt;/li>
&lt;/ol>
&lt;/li>
&lt;/ol>
&lt;/li>
&lt;/ol>
&lt;p>可以使用 **-o FORMAT **选项来自定义输出的格式(就是字段)。 FORMAT 是单个参数，格式为空格分隔或逗号分隔的列表，它提供了一种指定单个输出列的方法。 可以在 man 手册的 &lt;a href="https://man7.org/linux/man-pages/man1/ps.1.html#STANDARD_FORMAT_SPECIFIERS">STANDARD FORMAT SPECIFIERS(标准格式说明符)&lt;/a> 部分中找到所有可用的关键字。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># 标题可以根据需要重命名&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">[&lt;/span>root@lichenhao ~&lt;span style="color:#f92672">]&lt;/span>&lt;span style="color:#75715e"># ps -o pid,ruser=RealUser -o comm=Command&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> PID RealUser Command
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ae81ff">4652&lt;/span> root bash
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ae81ff">4774&lt;/span> root ps
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># 可以不输出标题行。&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">[&lt;/span>root@lichenhao ~&lt;span style="color:#f92672">]&lt;/span>&lt;span style="color:#75715e"># ps -o pid= -o comm=&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ae81ff">4652&lt;/span> bash
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ae81ff">4787&lt;/span> ps
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># 列宽将根据宽标题增加； 这可以用来加宽WCHAN等列&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">[&lt;/span>root@lichenhao ~&lt;span style="color:#f92672">]&lt;/span>&lt;span style="color:#75715e"># ps -o pid,wchan=WIDE-WCHAN-COLUMN -o comm&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> PID WIDE-WCHAN-COLUMN COMMAND
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ae81ff">4652&lt;/span> - bash
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ae81ff">4789&lt;/span> - ps
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># 可以也提供显式宽度控制&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">[&lt;/span>root@lichenhao ~&lt;span style="color:#f92672">]&lt;/span>&lt;span style="color:#75715e"># ps opid,wchan:42,cmd&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> PID WCHAN CMD
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ae81ff">881&lt;/span> core_sys_select /sbin/agetty -o -p -- &lt;span style="color:#ae81ff">\u&lt;/span> --noclear tty1 linux
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ae81ff">4652&lt;/span> - -bash
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ae81ff">4790&lt;/span> - ps opid,wchan:42,cmd
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># 行为因人格而异； 输出可能是名为“ X，comm = Y”的一列或名为“ X”和“ Y”的两列。如有疑问，请使用多个-o选项。&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">[&lt;/span>root@lichenhao ~&lt;span style="color:#f92672">]&lt;/span>&lt;span style="color:#75715e"># ps -o pid=X,comm=Y&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> X Y
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ae81ff">4652&lt;/span> bash
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ae81ff">4791&lt;/span> ps
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># 仅输出 启动总时长、PID、进程命令 这三列&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>root@lichenhao:~# ps -p &lt;span style="color:#ae81ff">38095&lt;/span> -o etime,pid,cmd
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ELAPSED PID CMD
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>10-03:22:51 &lt;span style="color:#ae81ff">38095&lt;/span> /bin/prometheus --web.console.templates&lt;span style="color:#f92672">=&lt;/span>/etc/prometheus/consoles --web.console.libraries&lt;span style="color:#f92672">=&lt;/span>/etc/prometheus/console_libraries --config.file&lt;span style="color:#f92672">=&lt;/span>/etc/prometheus/config_out/prometheus.yml
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>可用的 SPECIFIERS 有很多，下面仅列出常用的几个&lt;/p>
&lt;ul>
&lt;li>etime # 进程启动的总时长，格式为&lt;code>d-h:m:s&lt;/code>&lt;/li>
&lt;li>etimes # 进程启动的总时长，以秒为单位&lt;/li>
&lt;/ul>
&lt;h2 id="syntax语法-1">Syntax(语法)&lt;/h2>
&lt;p>&lt;strong>ps [OPTIONS]&lt;/strong>
默认操作显示该 shell 环境下的所有进程&lt;/p>
&lt;h3 id="options">OPTIONS&lt;/h3>
&lt;h4 id="process-selectionhttpsmancxpsheading5进程选择">&lt;a href="https://man.cx/ps#heading5">PROCESS SELECTION&lt;/a>(进程选择)&lt;/h4>
&lt;p>一共有两种选择进程的方式，且两种方式互相冲突，比如使用 -e 选项后， -p 选项则毫无意义，依然会输出所有进程&lt;/p>
&lt;ul>
&lt;li>整体选择
&lt;ul>
&lt;li>&lt;strong>-e, -A&lt;/strong> # 选择所有进程，包括不在本 shell 环境下的进程进行展示&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>按列表选择
&lt;ul>
&lt;li>&lt;strong>-p, &amp;ndash;pid &lt;!-- raw HTML omitted -->&lt;/strong> # 选择 PIDList 中列出来的进程。多个 PID 以逗号分隔&lt;/li>
&lt;li>&lt;strong>&amp;ndash;ppid &lt;!-- raw HTML omitted -->&lt;/strong> # 选择 PIDList 中列出来的进程的子进程。多个 PID 以逗号分割&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>通用选择
&lt;ul>
&lt;li>**-N, &amp;ndash;deselect ** # 取消选择。也可以理解为 反向选择。即，选择“通过 整体选择 与 按列表选择 中选择到的”进程以外的所有进程&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h4 id="output-format-controlhttpsmancxpsheading7输出格式控制">&lt;a href="https://man.cx/ps#heading7">OUTPUT FORMAT CONTROL&lt;/a>(输出格式控制)&lt;/h4>
&lt;ul>
&lt;li>&lt;strong>-f&lt;/strong> # 更多显示信息&lt;/li>
&lt;li>&lt;strong>-l&lt;/strong> # 显示进程的详细信息&lt;/li>
&lt;li>&lt;strong>-o &lt;!-- raw HTML omitted -->&lt;/strong> # 使用指定的格式输出。&lt;/li>
&lt;li>&lt;strong>-ww&lt;/strong> # 更宽的输出，让输出的内容不受屏幕限制，可以换行显示&lt;/li>
&lt;/ul>
&lt;h4 id="output-modifiershttpsmancxpsheading8输出模式">&lt;a href="https://man.cx/ps#heading8">OUTPUT MODIFIERS&lt;/a>(输出模式)&lt;/h4>
&lt;ul>
&lt;li>&lt;strong>f,&amp;ndash;forest&lt;/strong> # 以树状结构显示输出结果。与显示线程的选项冲突&lt;/li>
&lt;li>**-o &lt;!-- raw HTML omitted --> **# 以自定义的格式 FORMAT 输出信息。FORMAT 是以逗号或空格分隔的参数列表，详见前文&lt;/li>
&lt;/ul>
&lt;h4 id="thread-displayhttpsmancxpsheading9线程显示">&lt;a href="https://man.cx/ps#heading9">THREAD DISPLAY&lt;/a>(线程显示)&lt;/h4>
&lt;p>显示线程的选项与 -f, &amp;ndash;forest 选项不可同时使用。&lt;/p>
&lt;ul>
&lt;li>&lt;strong>-T&lt;/strong> # 显示线程，会多出 SPID 列，这列为 线程 号&lt;/li>
&lt;/ul>
&lt;h2 id="example-1">EXAMPLE&lt;/h2>
&lt;ul>
&lt;li>不显示内核进程，以树状格式显示。
&lt;ul>
&lt;li>ps -N -p 2 &amp;ndash;ppid 2 -f f&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">[&lt;/span>root@common-centos-test ~&lt;span style="color:#f92672">]&lt;/span>&lt;span style="color:#75715e"># ps --deselect -p 2 --ppid 2 -f f&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>UID PID PPID C STIME TTY STAT TIME CMD
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>root &lt;span style="color:#ae81ff">1&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span> Oct19 ? Ss 0:16 /usr/lib/systemd/systemd --switched-root --system --deserialize &lt;span style="color:#ae81ff">22&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>root &lt;span style="color:#ae81ff">478&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span> Oct19 ? Ss 0:03 /usr/lib/systemd/systemd-journald
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>root &lt;span style="color:#ae81ff">496&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span> Oct19 ? Ss 0:00 /usr/sbin/lvmetad -f
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>root &lt;span style="color:#ae81ff">502&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span> Oct19 ? Ss 0:00 /usr/lib/systemd/systemd-udevd
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>root &lt;span style="color:#ae81ff">630&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span> Oct19 ? S&amp;lt;sl 0:00 /sbin/auditd
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>polkitd &lt;span style="color:#ae81ff">653&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span> Oct19 ? Ssl 0:01 /usr/lib/polkit-1/polkitd --no-debug
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>root &lt;span style="color:#ae81ff">654&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span> Oct19 ? Ss 0:00 /usr/bin/qemu-ga --method&lt;span style="color:#f92672">=&lt;/span>virtio-serial --path&lt;span style="color:#f92672">=&lt;/span>/dev/virtio-ports/org.qemu.guest_agent.0 --blacklist&lt;span style="color:#f92672">=&lt;/span>guest-file-open,guest-file-close,guest-file-read,guest-file-write,guest-file-seek,guest-file-flush,guest-exec,guest-
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>root &lt;span style="color:#ae81ff">655&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span> Oct19 ? Ss 0:04 /usr/lib/systemd/systemd-logind
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>root &lt;span style="color:#ae81ff">657&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span> Oct19 ? Ss 0:16 /usr/sbin/irqbalance --foreground
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>dbus &lt;span style="color:#ae81ff">658&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span> Oct19 ? Ssl 0:06 /usr/bin/dbus-daemon --system --address&lt;span style="color:#f92672">=&lt;/span>systemd: --nofork --nopidfile --systemd-activation
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>root &lt;span style="color:#ae81ff">670&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span> Oct19 ? Ss 0:02 /usr/sbin/crond -n
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>chrony &lt;span style="color:#ae81ff">679&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span> Oct19 ? S 0:00 /usr/sbin/chronyd
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>root &lt;span style="color:#ae81ff">689&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span> Oct19 ? Ssl 1:14 /usr/sbin/NetworkManager --no-daemon
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>root &lt;span style="color:#ae81ff">990&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span> Oct19 ? Ssl 0:47 /usr/bin/python2 -Es /usr/sbin/tuned -l -P
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>root &lt;span style="color:#ae81ff">992&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span> Oct19 ? Ssl 0:24 /usr/sbin/rsyslogd -n
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>root &lt;span style="color:#ae81ff">14438&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span> Oct21 tty1 Ss+ 0:00 /sbin/agetty --noclear tty1 linux
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>root &lt;span style="color:#ae81ff">14445&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span> Oct21 ttyS0 Ss+ 0:00 /sbin/agetty --keep-baud 115200,38400,9600 ttyS0 vt220
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>root &lt;span style="color:#ae81ff">15151&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span> Oct21 ? Ss 0:00 sshd: /usr/sbin/sshd &lt;span style="color:#f92672">[&lt;/span>listener&lt;span style="color:#f92672">]&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span> of 10-100 startups
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>root &lt;span style="color:#ae81ff">17321&lt;/span> &lt;span style="color:#ae81ff">15151&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span> 09:18 ? Ss 0:00 &lt;span style="color:#ae81ff">\_&lt;/span> sshd: root@pts/0
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>root &lt;span style="color:#ae81ff">17325&lt;/span> &lt;span style="color:#ae81ff">17321&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span> 09:18 pts/0 Ss 0:00 &lt;span style="color:#ae81ff">\_&lt;/span> -bash
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>root &lt;span style="color:#ae81ff">17365&lt;/span> &lt;span style="color:#ae81ff">17325&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span> 09:23 pts/0 R+ 0:00 &lt;span style="color:#ae81ff">\_&lt;/span> ps --deselect -p &lt;span style="color:#ae81ff">2&lt;/span> --ppid &lt;span style="color:#ae81ff">2&lt;/span> -f f
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>bash&lt;/p>
&lt;ul>
&lt;li>ps -elf&lt;/li>
&lt;/ul>
&lt;!-- raw HTML omitted -->
&lt;pre>&lt;code>[root@master0 ~]# ps -elf
F S UID PID PPID C PRI NI ADDR SZ WCHAN STIME TTY TIME CMD
4 S root 1 0 0 80 0 - 32013 ep_pol 15:16 ? 00:00:01 /usr/lib/systemd/systemd --switched-root --system --deserialize 2
1 S root 2 0 0 80 0 - 0 kthrea 15:16 ? 00:00:00 [kthreadd]
&lt;/code>&lt;/pre>
&lt;ul>
&lt;li>ps -aux&lt;/li>
&lt;/ul>
&lt;!-- raw HTML omitted -->
&lt;pre>&lt;code>[root@master0 ~]# ps aux
USER PID %CPU %MEM VSZ RSS TTY STAT START TIME COMMAND
root 1 0.0 0.4 128052 6596 ? Ss 15:16 0:01 /usr/lib/systemd/systemd --switched-root --system --deserialize 22
root 2 0.0 0.0 0 0 ? S 15:16 0:00 [kthreadd]
&lt;/code>&lt;/pre>
&lt;ul>
&lt;li>ps -efww #显示 ps 的完整内容，不受 COMMAND 命令有字符限制影响&lt;/li>
&lt;li>ps -ef f #以树状形式显示，且带中括号的内核进程将会放在最上面，与下面的系统进程分开，显示较为直观，效果如下&lt;/li>
&lt;/ul>
&lt;!-- raw HTML omitted -->
&lt;pre>&lt;code>root 1 0 0 Dec24 ? Ss 0:04 /usr/lib/systemd/systemd --switched-root --system --deserialize 22
.......
root 2827 1 0 Dec24 ? Ss 0:00 /usr/sbin/sshd -D
root 6400 2827 0 10:51 ? Ss 0:00 \_ sshd: root@pts/0
root 6402 6400 0 10:51 pts/0 Ss 0:00 \_ -bash
root 6720 6402 0 10:52 pts/0 R+ 0:00 \_ ps -ef f
&lt;/code>&lt;/pre>
&lt;ul>
&lt;li>ps -eo rss,pid,user,command | sort -rn | head -10 | awk &amp;lsquo;{ hr[1024&lt;strong>2]=&amp;ldquo;GB&amp;rdquo;; hr[1024]=&amp;ldquo;MB&amp;rdquo;;for (x=1024&lt;/strong>3; x&amp;gt;=1024; x/=1024) { if ($1&amp;gt;=x) { printf (&amp;quot;%-6.2f %s &amp;ldquo;, $1/x, hr[x]); break }} } { printf (&amp;rdquo;%-6s %-10s &amp;ldquo;, $2, $3) }{ for ( x=4 ; x&amp;lt;=NF ; x++ ) { printf (&amp;quot;%s &amp;ldquo;,$x) } print (&amp;quot;\n&amp;rdquo;) }&amp;rsquo;&lt;/li>
&lt;/ul>
&lt;!-- raw HTML omitted -->
&lt;pre>&lt;code>15.94 MB 627 root /usr/bin/python3 /usr/bin/networkd-dispatcher --run-startup-triggers
15.18 MB 683 root /usr/bin/python3 /usr/share/unattended-upgrades/unattended-upgrade-shutdown --wait-for-signal
&lt;/code>&lt;/pre>
&lt;h1 id="pwdx---report-current-directory-of-a-process">pwdx - Report current directory of a process&lt;/h1>
&lt;h1 id="skill---obsolete-version-of-pgreppkill">skill - Obsolete version of pgrep/pkill&lt;/h1>
&lt;h1 id="slabtop---display-kernel-slab-cache-information-in-real-time">slabtop - Display kernel slab cache information in real time&lt;/h1>
&lt;h1 id="snice---renice-a-process">snice - Renice a process&lt;/h1>
&lt;h1 id="sysctl--在运行时读取或写入内核参数">sysctl # 在运行时读取或写入内核参数&lt;/h1>
&lt;p>&lt;strong>sysctl [OPTIONS] [VARIABLE[=VALUE]] [&amp;hellip;]&lt;/strong>
在运行环境中配置内核参数。VARIABLE 为内核的一个变量&lt;/p>
&lt;p>OPTIONS&lt;/p>
&lt;ul>
&lt;li>&lt;strong>-a&lt;/strong> #显示所有变量&lt;/li>
&lt;li>&lt;strong>-p [/PATH/TO/FILE]&lt;/strong> #从文件中读取值,默认文件为/etc/sysctl.conf。可以指定从哪个文件来读取参数，可使用通配符。&lt;/li>
&lt;li>&lt;strong>-w&lt;/strong> # 允许写一个值到变量中&lt;/li>
&lt;/ul>
&lt;h2 id="example-2">EXAMPLE&lt;/h2>
&lt;ul>
&lt;li>sysctl -w net.ipv4.ip_forward=1 #开启 IP 转发模式&lt;/li>
&lt;li>sysctl -p /etc/sysctl.d/* #从 sysctl.d 目录中读取所有文件的内容加载到内核中&lt;/li>
&lt;/ul>
&lt;h1 id="tload---graphical-representation-of-system-load-average">tload - Graphical representation of system load average&lt;/h1>
&lt;h1 id="top运行中的进程的实时动态视图">top：运行中的进程的实时动态视图&lt;/h1>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>top - 14:06:23 up &lt;span style="color:#ae81ff">70&lt;/span> days, 16:44, &lt;span style="color:#ae81ff">2&lt;/span> users, load average: 1.25, 1.32, 1.35
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Tasks: &lt;span style="color:#ae81ff">206&lt;/span> total, &lt;span style="color:#ae81ff">1&lt;/span> running, &lt;span style="color:#ae81ff">205&lt;/span> sleeping, &lt;span style="color:#ae81ff">0&lt;/span> stopped, &lt;span style="color:#ae81ff">0&lt;/span> zombie
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Cpu&lt;span style="color:#f92672">(&lt;/span>s&lt;span style="color:#f92672">)&lt;/span>: 5.9%us, 3.4%sy, 0.0%ni, 90.4%id, 0.0%wa, 0.0%hi, 0.2%si, 0.0%st
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Mem: 32949016k total, 14411180k used, 18537836k free, 169884k buffers
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Swap: 32764556k total, 0k used, 32764556k free, 3612636k cached
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> PID USER PR NI VIRT RES SHR S %CPU %MEM TIME+ COMMAND
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">28894&lt;/span> root &lt;span style="color:#ae81ff">22&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span> 1501m 405m 10m S 52.2 1.3 2534:16 java
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">18249&lt;/span> root &lt;span style="color:#ae81ff">18&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span> 3201m 1.9g 11m S 35.9 6.0 569:39.41 java
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>第一行解析：任务队列信息，同 uptime 命令的执行结果，具体参数说明情况如下：&lt;/p>
&lt;ol>
&lt;li>14:06:23 # 当前系统时间&lt;/li>
&lt;li>up 70 days, 16:44 # 系统已经运行了 70 天 16 小时 44 分钟&lt;/li>
&lt;li>2 users #当前有 2 个用户登录系统&lt;/li>
&lt;li>load average: 1.25, 1.32, 1.35 #load average 后面的三个数分别是 1 分钟、5 分钟、15 分钟的负载情况。
&lt;ol>
&lt;li>load average 数据是每隔 5 秒钟检查一次活跃的进程数，然后按特定算法计算出的数值。如果这个数除以逻辑 CPU 的数量，结果高于 5 的时候就表明系统在超负荷运转了。&lt;/li>
&lt;li>关于 load average 的说明详见：理解 load average—Linux 系统负荷&lt;/li>
&lt;/ol>
&lt;/li>
&lt;/ol>
&lt;p>第二行解析：Tasks #任务（进程），具体信息说明如下：&lt;/p>
&lt;ol>
&lt;li>total # 系统全部的进程数。现在共有 206 个进程&lt;/li>
&lt;li>running # 运行状态的进程数&lt;/li>
&lt;li>sleeping # 睡眠状态的进程数&lt;/li>
&lt;li>stoped # 已经停止的状态的进程数&lt;/li>
&lt;li>zombie # 僵尸状态的进程数。&lt;/li>
&lt;/ol>
&lt;p>第三行解析：cpu 状态信息，显示了基于上次刷新时间间隔内，CPU 使用率的百分比。如果 top 命令每 1 秒刷新一次，则下面的信息为 1 秒时间内，CPU 被占用时间的百分比（也就意味着 us 占用 0.059 秒，sy 占用 0.034 秒，空闲了 0.904 秒，st 占用了 0.002 秒）。
具体属性说明如下：(且所有参数的值加起来应为 100%)&lt;/p>
&lt;ol>
&lt;li>5.9%us # user cpu time，未改变过 nice 值的用户空间进程的运行时间&lt;/li>
&lt;li>3.4% sy # system cpu time，内核空间进程的运行时间&lt;/li>
&lt;li>0.0% ni # user nice cpu time，已改变过 nice 值的用户空间进程的运行时间&lt;/li>
&lt;li>90.4% id # idle cpu time，CPU 空闲时间。&lt;/li>
&lt;li>0.0% wa # io wait cpu time，等待磁盘写入完成的时间。该值较高时，说明 IO 等待比较严重，这可能磁盘大量作随机访问造成的，也可能是磁盘性能出现了瓶颈。&lt;/li>
&lt;li>0.0% hi # hardware irq，硬中断（Hardware Interrupts）花费的时间&lt;/li>
&lt;li>0.2% si # software irq，软中断（Software Interrupts）花费的时间&lt;/li>
&lt;li>0.0% st # steal time，使用 hypervisor 管理的虚拟机偷取的时间&lt;/li>
&lt;/ol>
&lt;p>第四行解析：内存状态，具体信息如下：&lt;/p>
&lt;ol>
&lt;li>32949016k total — 物理内存总量（32GB）&lt;/li>
&lt;li>14411180k used — 使用中的内存总量（14GB）&lt;/li>
&lt;li>18537836k free — 空闲内存总量（18GB）&lt;/li>
&lt;li>169884k buffers — 缓存的内存量 （169M）&lt;/li>
&lt;/ol>
&lt;p>第五行解析：swap 交换分区信息，具体信息说明如下：&lt;/p>
&lt;ol>
&lt;li>32764556k total — 交换区总量（32GB）&lt;/li>
&lt;li>0k used — 使用的交换区总量（0K）&lt;/li>
&lt;li>32764556k free — 空闲交换区总量（32GB）&lt;/li>
&lt;li>3612636k cached — 缓冲的交换区总量（3.6GB）&lt;/li>
&lt;/ol>
&lt;p>第六行解析：以下各进程（任务）的状态监控，项目列信息说明如下：&lt;/p>
&lt;ol>
&lt;li>&lt;strong>PID&lt;/strong> # 进程 id&lt;/li>
&lt;li>&lt;strong>USER&lt;/strong> # 进程所有者&lt;/li>
&lt;li>&lt;strong>PR&lt;/strong> # 进程优先级&lt;/li>
&lt;li>&lt;strong>NI&lt;/strong> # nice 值。负值表示高优先级，正值表示低优先级&lt;/li>
&lt;li>&lt;strong>VIRT&lt;/strong> # 进程的虚拟内存总量，单位 KiB。即便还没有真正分配物理内存，也会计算在内。&lt;/li>
&lt;li>&lt;strong>RES&lt;/strong> # 进程常驻内存的大小，单位 KiB。是进程实际使用的物理内存的大小，但不包括 Swap 和 共享内存&lt;/li>
&lt;li>&lt;strong>SHR&lt;/strong> # 共享内存大小，单位 KiB。与其他进程共同使用的共享内存、加载的动态链接库、程序的代码段等等。&lt;/li>
&lt;li>&lt;strong>S&lt;/strong> # 进程状态。D=不可中断的睡眠状态 R=运行 S=睡眠 T=跟踪/停止 Z=僵尸进程&lt;/li>
&lt;li>&lt;strong>%CPU&lt;/strong> # 上次更新到现在的 CPU 时间占用百分比。注意：这个 CPU 的使用百分比为所有逻辑 CPU 的使用率总和，所有对于多核 CPU 的设备来说，该值很有可能会超过 100%&lt;/li>
&lt;li>&lt;strong>%MEM&lt;/strong> # 进程使用的物理内存百分比&lt;/li>
&lt;li>&lt;strong>TIME+&lt;/strong> # 进程使用的 CPU 时间总计，单位 1/100 秒&lt;/li>
&lt;li>&lt;strong>COMMAND&lt;/strong> # 进程名称（命令名/命令行）&lt;/li>
&lt;/ol>
&lt;h2 id="syntax语法-2">Syntax(语法)&lt;/h2>
&lt;p>&lt;strong>top [OPTIONS]&lt;/strong>
除了标注选项，当 top 运行时，可以通过快捷键进行一些操作&lt;/p>
&lt;ul>
&lt;li>&lt;strong>P&lt;/strong> # 按照 CPU 使用率排序&lt;/li>
&lt;li>&lt;strong>M&lt;/strong> # 按照内存使用率排序&lt;/li>
&lt;/ul>
&lt;p>OPTIONS&lt;/p>
&lt;ul>
&lt;li>&lt;strong>-d &lt;!-- raw HTML omitted -->&lt;/strong> # 设定整个进程视图更新的秒数，默认为 5 秒更新一次&lt;/li>
&lt;li>**-H **# 显示线程。 如果没有此命令行选项，则显示每个进程中所有线程的总和。 稍后，可以使用“ H”交互式命令来更改它。&lt;/li>
&lt;li>&lt;strong>-p &lt;!-- raw HTML omitted -->&lt;/strong> # 指定 PID 进程进行观察&lt;/li>
&lt;/ul>
&lt;p>EXAMPLE&lt;/p>
&lt;ul>
&lt;li>1 # 展开第三行的 CPU，显示每个逻辑 CPU 的状态信息&lt;/li>
&lt;li>b # 高亮显示处于 Running 状态的进程&lt;/li>
&lt;li>f # 管理所要展示的字段(i.e.第六行的内容)以及按照指定的字段排序。
&lt;ul>
&lt;li>按 ↑↓ 选择要操作的字段&lt;/li>
&lt;li>按空格表示显示或不显示当前字段&lt;/li>
&lt;li>按 → 选中当前行，然后按 ↑↓ 将选中的行移动，以便变更该字段所在位置&lt;/li>
&lt;li>按 ← 取消选中当前行&lt;/li>
&lt;li>按 s 选择光标所在的行作为 排序 标准&lt;/li>
&lt;li>按 q 退出当前编辑界面。i.e.再次显示 top 面板&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>R # 按照 f 命令里指定的字段进行排序，倒序或者顺序&lt;/li>
&lt;li>查看 744 进程及其线程的动态试图
&lt;ul>
&lt;li>top -p 744 -H&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h1 id="uptime显示系统运行了多长时间">uptime：显示系统运行了多长时间&lt;/h1>
&lt;h1 id="vmstat报告虚拟内存状态还有-io系统cpu-等信息">vmstat：报告虚拟内存状态，还有 io、系统、cpu 等信息&lt;/h1>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">[&lt;/span>root@ansible ~&lt;span style="color:#f92672">]&lt;/span>&lt;span style="color:#75715e"># vmstat -w&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>procs -----------------------memory---------------------- ---swap-- -----io---- -system-- --------cpu--------
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> r b swpd free buff cache si so bi bo in cs us sy id wa st
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ae81ff">0&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span> &lt;span style="color:#ae81ff">7282784&lt;/span> &lt;span style="color:#ae81ff">2148&lt;/span> &lt;span style="color:#ae81ff">463980&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span> &lt;span style="color:#ae81ff">8&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span> &lt;span style="color:#ae81ff">33&lt;/span> &lt;span style="color:#ae81ff">39&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span> &lt;span style="color:#ae81ff">100&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;strong>顶部字段说明：&lt;/strong>
procs&lt;/p>
&lt;ul>
&lt;li>r # 可运行的进程数(正在运行或等待运行)。即就绪队列的长度&lt;/li>
&lt;li>b # 等待 I/O 完成时阻塞(blocked)的进程数。即不可中断睡眠状态的进程数。&lt;/li>
&lt;/ul>
&lt;p>memory&lt;/p>
&lt;ul>
&lt;li>详见 内存管理。(单位是 KiB)&lt;/li>
&lt;/ul>
&lt;p>swap&lt;/p>
&lt;ul>
&lt;li>si # 每秒从 swap 到内存的大小。(单位是 KiB)&lt;/li>
&lt;li>so # 每秒从内存到 swap 的大小。(单位是 KiB)&lt;/li>
&lt;/ul>
&lt;p>io&lt;/p>
&lt;ul>
&lt;li>bi # 每秒从块设备接收的块数。即磁盘读取速度。&lt;/li>
&lt;li>bo # 每秒发送到块设备的块数。即磁盘写入速度。&lt;/li>
&lt;li>注意：bi 与 bo 的单位为&lt;code>块/秒&lt;/code>。因为 Linux 中块的大小是 1 KiB，所以这个单位也就等价于 KiB/s&lt;/li>
&lt;/ul>
&lt;p>system&lt;/p>
&lt;ul>
&lt;li>in # 每秒中断的次数。包括时钟的中断&lt;/li>
&lt;li>cs # 每秒上下文切换次数&lt;/li>
&lt;/ul>
&lt;p>cpu&lt;/p>
&lt;ul>
&lt;li>详见：CPU 使用率。(单位是百分比)&lt;/li>
&lt;/ul>
&lt;h2 id="syntax语法-3">Syntax(语法)&lt;/h2>
&lt;p>&lt;strong>vmstat [OTIONS] [DELAY [COUNT]]&lt;/strong>
DELAY # 延迟时间(单位是秒)。指定 DELAY 后，程序每隔 DELAY 时间运行一次。如果未指定 DELAY，则值输出一行结果，其中包含自 vmstat 启动到结束的平均值。&lt;/p>
&lt;ol>
&lt;li>**COUNT **# 每隔 DELAY 时间，程序运行的次数。若不指定则一直运行。&lt;/li>
&lt;/ol>
&lt;p>OPTIONS&lt;/p>
&lt;ol>
&lt;li>&lt;strong>-w&lt;/strong> # 格式化输出。如果不加 -w ,则输出非常紧凑，不利于人们观察，且每行最大 80 字符。&lt;/li>
&lt;/ol>
&lt;p>EXAMPLE&lt;/p>
&lt;ul>
&lt;li>每隔一秒输出一行信息，一共输出 5 次
&lt;ul>
&lt;li>vmstat 1 5&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h1 id="w--报告已经登录的用户和这些用户正在执行的命令">w # 报告已经登录的用户和这些用户正在执行的命令&lt;/h1>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>root@lichenhao:~# w
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> 09:22:37 up 22:46, &lt;span style="color:#ae81ff">1&lt;/span> user, load average: 0.00, 0.00, 0.00
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>USER TTY FROM LOGIN@ IDLE JCPU PCPU WHAT
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>root pts/0 172.19.42.203 09:06 0.00s 0.21s 0.01s w
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ul>
&lt;li>USER：用哪个用户登录的&lt;/li>
&lt;li>TTY：为该用户开启的终端名&lt;/li>
&lt;li>FROM：该登录用户从哪个 IP 登录的&lt;/li>
&lt;li>LOGIN@：用户登录的时间&lt;/li>
&lt;li>IDLE：用户登录&lt;/li>
&lt;li>WHAT：该用户当前正在执行的命令&lt;/li>
&lt;/ul>
&lt;p>获取到的用户信息中，TTY 的信息可以被 pkill 工具使用，以踢掉用户，让其下线&lt;/p>
&lt;h1 id="watch--定期执行程序在全部屏幕上显示输出结果">watch # 定期执行程序，在全部屏幕上显示输出结果&lt;/h1>
&lt;p>该工具就是持续执行同一个命令，并实时显示&lt;/p></description></item><item><title>Docs: psmisc 工具集</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/x.linux-%E7%AE%A1%E7%90%86/linux-%E7%B3%BB%E7%BB%9F%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/psmisc-%E5%B7%A5%E5%85%B7%E9%9B%86/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/x.linux-%E7%AE%A1%E7%90%86/linux-%E7%B3%BB%E7%BB%9F%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/psmisc-%E5%B7%A5%E5%85%B7%E9%9B%86/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：项目地址：&lt;a href="https://gitlab.com/psmisc/psmisc">https://gitlab.com/psmisc/psmisc&lt;/a>&lt;/p>
&lt;/blockquote>
&lt;p>psmisc 是一个小型的应用程序集合，与 procps-ng 工具集类似，都是使用伪文件系统(/proc)内的信息来展示系统信息&lt;/p>
&lt;p>该工具集包含包含以下程序(每个标题都是一个)&lt;/p>
&lt;h1 id="fuser--显示正在使用指定-文件-或-sockets-的进程">fuser # 显示正在使用指定 文件 或 sockets 的进程&lt;/h1>
&lt;p>fuser 使用指定的文件或文件系统显示进程的 PID。 在默认的显示模式下，每个文件名后都有一个字母，表示访问类型：&lt;/p>
&lt;ol>
&lt;li>c # 当前目录。&lt;/li>
&lt;li>e # 一个可执行文件正在运行。&lt;/li>
&lt;li>f # 打开文件。 在默认显示模式下省略 f。&lt;/li>
&lt;li>F # 打开文件进行写入。 默认显示模式下省略 F。&lt;/li>
&lt;li>r # 根目录。&lt;/li>
&lt;li>m # 映射文件或共享库。&lt;/li>
&lt;/ol>
&lt;h2 id="fuser-options">fuser [OPTIONS]&lt;/h2>
&lt;p>OPTIONS&lt;/p>
&lt;ul>
&lt;li>&lt;strong>-m&lt;/strong> # 显示使用命名文件系统或块设备的所有进程&lt;/li>
&lt;/ul>
&lt;h1 id="killall--通过进程名称向指定进程发送信号">killall # 通过进程名称向指定进程发送信号&lt;/h1>
&lt;p>与 kill 命令类似，但是不像 kill 只能指定进程的 PID，而是可以通过进程的名称来发送信号&lt;/p>
&lt;p>EXAMPLE：&lt;/p>
&lt;ol>
&lt;li>killall -0 nginx #向名为 nginx 的进程发送 0 信号&lt;/li>
&lt;/ol>
&lt;h1 id="peekfd--shows-the-data-travelling-over-a-file-descriptor">peekfd # shows the data travelling over a file descriptor&lt;/h1>
&lt;h1 id="prtstat--输出一个进程的统计信息">prtstat # 输出一个进程的统计信息&lt;/h1>
&lt;h1 id="pslog---prints-log-paths-of-a-process">pslog - prints log path(s) of a process&lt;/h1>
&lt;h1 id="pstree---以树状显示当前正在运行的进程">pstree - 以树状显示当前正在运行的进程&lt;/h1>
&lt;p>该命令与 ps 类似，但是不会像 ps -ef 一样显示内核态进程&lt;/p>
&lt;p>pstree [OPTIONS] [USER or PID]&lt;/p>
&lt;p>OPTIONS:&lt;/p>
&lt;ol>
&lt;li>-p #显示进程的 PID&lt;/li>
&lt;li>-a #显示进程运行的命令行参数&lt;/li>
&lt;li>-c #禁用相同分支的合并&lt;/li>
&lt;li>-h #高亮显示当前进程及其父进程&lt;/li>
&lt;li>-H PID #高亮显示指定进程&lt;/li>
&lt;li>-t #显示完整的进程名称&lt;/li>
&lt;li>-s #显示指定进程的父进程&lt;/li>
&lt;li>-n #按 PID 排序&lt;/li>
&lt;li>-g #显示 PGID。i.e 一个或多个进程组 ID&lt;/li>
&lt;/ol>
&lt;p>EXAPMLE:&lt;/p>
&lt;ol>
&lt;li>pstree -n #&lt;/li>
&lt;/ol>
&lt;p>以最简单的形式调用时没有任何选项或参数，&lt;code>pstree&lt;/code> 命令将显示所有正在运行的进程的分层树结构。&lt;/p>
&lt;pre>&lt;code>$ pstree
systemd─┬─VBoxService───7*[{VBoxService}]
├─accounts-daemon───2*[{accounts-daemon}]
├─2*[agetty]
├─atd
├─cron
├─dbus-daemon
├─irqbalance───{irqbalance}
├─2*[iscsid]
├─lvmetad
├─lxcfs───2*[{lxcfs}]
├─networkd-dispat───{networkd-dispat}
├─nginx───2*[nginx]
&lt;/code>&lt;/pre></description></item><item><title>Docs: pt-ioprofile</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/x.linux-%E7%AE%A1%E7%90%86/linux-%E7%B3%BB%E7%BB%9F%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/%E7%A3%81%E7%9B%98-%E4%B8%8E-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7%E9%9B%86/pt-ioprofile/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/x.linux-%E7%AE%A1%E7%90%86/linux-%E7%B3%BB%E7%BB%9F%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/%E7%A3%81%E7%9B%98-%E4%B8%8E-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7%E9%9B%86/pt-ioprofile/</guid><description>
&lt;h2 id="概述">概述&lt;/h2>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://www.percona.com/doc/percona-toolkit/LATEST/pt-ioprofile.html#environment">官方文档&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>pt-ioprofile 是 &lt;a href="https://www.percona.com/">Percona &lt;/a>出的 IO 查看工具。Percona 用来监视进程 IO 并打印文件和 I/O 活动表。&lt;/p>
&lt;p>&lt;strong>pt-ioprofile&lt;/strong> 本质上就是一个 shell 脚本，只做两件事：&lt;/p>
&lt;ol>
&lt;li>通过 lsof 和 strace 两个工具获取指定进程的一段时间的数据，并保存到文件中&lt;/li>
&lt;li>使用 awk 等工具聚合两个文件的内容。&lt;/li>
&lt;/ol>
&lt;p>&lt;strong>pt-ioprofile&lt;/strong> 使用 strace 和 lsof 工具监视进程的 IO 并打印出一个文件和 I/O 活动表。默认情况下，它监视 mysqld 进程 30 秒。输出如下：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>Tue Dec &lt;span style="color:#ae81ff">27&lt;/span> 15:33:57 PST &lt;span style="color:#ae81ff">2011&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Tracing process ID &lt;span style="color:#ae81ff">1833&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> total read write lseek ftruncate filename
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> 0.000150 0.000029 0.000068 0.000038 0.000015 /tmp/ibBE5opS
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ul>
&lt;li>read：从文件中读出数据。要读取的文件用文件描述符标识，数据读入一个事先定义好的缓冲区。&lt;/li>
&lt;li>write：把缓冲区的数据写入文件中。&lt;/li>
&lt;li>pread：由于 lseek 和 read 调用之间，内核可能会临时挂起进程，所以对同步问题造成了问题，调用 pread 相当于顺序调用了 lseek 和 read，这两个操作相当于一个捆绑的原子操作。&lt;/li>
&lt;li>pwrite：由于 lseek 和 write 调用之间，内核可能会临时挂起进程，所以对同步问题造成了问题，调用 pwrite 相当于顺序调用了 lseek 和 write，这两个操作相当于一个捆绑的原子操作。&lt;/li>
&lt;li>fsync：确保文件所有已修改的内容已经正确同步到硬盘上，该调用会阻塞等待直到设备报告 IO 完成。&lt;/li>
&lt;li>open：打开一个文件，并返回这个文件的描述符。&lt;/li>
&lt;li>close：close 系统调用用于“关闭”一个文件，close 调用终止一个文件描述符以其文件之间的关联。文件描述符被释放，并能够重新使用。&lt;/li>
&lt;li>lseek：对文件描述符指定文件的读写指针进行设置，也就是说，它可以设置文件的下一个读写位置。&lt;/li>
&lt;li>fcntl：针对(文件)描述符提供控制。&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>pt-ioprofile&lt;/strong> 通过使用 附加&lt;code>strace&lt;/code>到进程来工作&lt;code>ptrace()&lt;/code>，这将使其运行非常缓慢，直到&lt;code>strace&lt;/code>分离。除了冻结服务器之外，还有一些风险，即进程在与服务器&lt;code>strace&lt;/code>分离后崩溃或性能不佳，或者&lt;code>strace&lt;/code>没有完全分离并使进程处于睡眠状态。因此，这应该被视为一种侵入性工具，除非您对此感到满意，否则不应在生产服务器上使用。&lt;/p>
&lt;p>&lt;strong>WARNING&lt;/strong>: &lt;strong>pt-ioprofile&lt;/strong> freezes the server and may crash the process, or make it perform badly after detaching, or leave it in a sleeping state! Before using this tool, please:&lt;/p>
&lt;ul>
&lt;li>Read the tool’s documentation&lt;/li>
&lt;li>Review the tool’s known “BUGS”&lt;/li>
&lt;li>Test the tool on a non-production server&lt;/li>
&lt;li>Backup your production server and verify the backups&lt;/li>
&lt;/ul>
&lt;blockquote>
&lt;p>&lt;strong>pt-ioprofile&lt;/strong> should be considered an intrusive tool, and should not be used on production servers unless you understand and accept the risks.&lt;/p>
&lt;/blockquote>
&lt;h2 id="安装">安装&lt;/h2>
&lt;p>从 &lt;a href="https://www.percona.com/downloads/percona-toolkit/LATEST/">https://www.percona.com/downloads/percona-toolkit/LATEST/&lt;/a> 选择指定环境下的指定版本下载安装包&lt;/p>
&lt;h2 id="syntax语法">Syntax(语法)&lt;/h2>
&lt;p>&lt;strong>pt-ioprofile [OPTIONS] [FILE]&lt;/strong>&lt;/p>
&lt;p>&lt;strong>OPTIONS&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>&lt;strong>&amp;ndash;aggregate, -a&lt;/strong> # 聚合结果的方式，可用的值有 sum 与 avg。&lt;code>默认值：sum&lt;/code>&lt;/li>
&lt;li>如果求和，则每个单元格将包含其中的值的总和。如果 avg，则每个单元格将包含其中值的平均值。&lt;/li>
&lt;li>&lt;strong>&amp;ndash;cell, -c &lt;!-- raw HTML omitted -->&lt;/strong> # 统计的数据。&lt;code>默认值：times&lt;/code>
&lt;ul>
&lt;li>count  # I/O 次数&lt;/li>
&lt;li>sizes  # I/O 大小&lt;/li>
&lt;li>times  # I/O 时间&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>&amp;ndash;group-by, -g &lt;!-- raw HTML omitted -->&lt;/strong> # 对输出结果进行分组 &lt;code>默认值：filename&lt;/code>
&lt;ul>
&lt;li>all # 所有输出都在一行&lt;/li>
&lt;li>filename # 每个文件名输出一行&lt;/li>
&lt;li>pid # 每个进程 ID 输出一行&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>&amp;ndash;profile-pid &lt;!-- raw HTML omitted -->&lt;/strong> # 指定要分析的进程的 PID，该值会覆盖 &amp;ndash;profile-process 选项。&lt;/li>
&lt;li>&lt;strong>&amp;ndash;profile-process &lt;!-- raw HTML omitted -->&lt;/strong> # 指定要分析的进程名称。&lt;code>默认值：mysqld&lt;/code>&lt;/li>
&lt;li>&lt;strong>&amp;ndash;run-time &lt;!-- raw HTML omitted -->&lt;/strong> # 程序运行时长，单位秒。&lt;code>默认值：30&lt;/code>&lt;/li>
&lt;li>&lt;strong>&amp;ndash;save-samples &lt;!-- raw HTML omitted -->&lt;/strong> # 将 strace 与 lsof 的输出结果保存到指定的 FILE 中。&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>EXAMPLE&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>pt-ioprofile -p=9267 &amp;ndash;cell=sizes&lt;/li>
&lt;/ul>
&lt;h2 id="问题">问题&lt;/h2>
&lt;p>原文：&lt;a href="https://tusundong.top/post/centos7-pt-ioprofile.html">https://tusundong.top/post/centos7-pt-ioprofile.html&lt;/a>
最近在排查 io wait 需要使用到 pt-ioprofile，结果发现在 CentOS7.8 下执行没有结果。
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/zgyenr/1622780378714-e4fa5820-6042-4558-9cbd-51fc885b6dc0.png" alt="">
最后在大神&lt;code>@轻松的鱼&lt;/code>指导下，修改源码，编辑 /usr/bin/pt-ioprofile 文件，添加此行&lt;/p>
&lt;pre>&lt;code>• /^strace: Process/ { mode = &amp;quot;strace&amp;quot;; }
&lt;/code>&lt;/pre>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/zgyenr/1622780378720-19f72459-84e1-448e-81d2-7fe581bdb917.png" alt="">&lt;/p></description></item><item><title>Docs: Redhat 优化</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/x.linux-%E7%AE%A1%E7%90%86/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96-%E4%B8%8E-%E6%95%85%E9%9A%9C%E5%A4%84%E7%90%86/redhat-%E4%BC%98%E5%8C%96/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/x.linux-%E7%AE%A1%E7%90%86/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96-%E4%B8%8E-%E6%95%85%E9%9A%9C%E5%A4%84%E7%90%86/redhat-%E4%BC%98%E5%8C%96/</guid><description>
&lt;p>Redhat 官方文档：&lt;a href="https://access.redhat.com/documentation/zh-CN/Red_Hat_Enterprise_Linux/7/html/Performance_Tuning_Guide/">https://access.redhat.com/documentation/zh-CN/Red_Hat_Enterprise_Linux/7/html/Performance_Tuning_Guide/&lt;/a>&lt;/p>
&lt;p>参考文章：&lt;a href="https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/8/html/monitoring_and_managing_system_status_and_performance/index">https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/8/html/monitoring_and_managing_system_status_and_performance/index&lt;/a>&lt;/p>
&lt;p>Tuned 概述&lt;/p>
&lt;p>Tuned 是一项服务，可监视您的系统并在某些工作负载下优化性能。Tuned 的核心是配置文件，它们可以针对不同的用例调整您的系统。&lt;/p>
&lt;p>针对许多用例，已分发 Tuned 并附带了许多预定义的配置文件：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>High throughput&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Low latency&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Saving power&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>可以修改为每个配置文件定义的规则，并自定义如何调整特定设备。当您切换到另一个配置文件或停用 Tuned 时，以前的配置文件对系统设置所做的所有更改都将恢复为原始状态。&lt;/p>
&lt;p>您还可以配置“Tuned”以对设备使用情况的变化做出反应，并调整设置以提高活动设备的性能并降低非活动设备的功耗。&lt;/p>
&lt;p>配置文件&lt;/p>
&lt;p>/usr/lib/tuned/_ #特定于发行版的概要文件存储在目录中。每个配置文件都有其自己的目录。该配置文件由名为 tuned.conf 的主要配置文件以及其他文件（例如帮助程序脚本）组成。
/etc/tuned/_ #如果需要定制概要文件，请将概要文件目录复制到用于定制概要文件的目录中。如果有两个同名的配置文件，则使用 /etc/tuned/ 中的自定义配置文件。&lt;/p>
&lt;p>tuned-adm 命令行工具&lt;/p>
&lt;p>usage: tuned-adm [-h] [&amp;ndash;version] [&amp;ndash;debug] [&amp;ndash;async] [&amp;ndash;timeout TIMEOUT]&lt;/p>
&lt;pre>&lt;code> [--loglevel LOGLEVEL]
{list,active,off,profile,profile_info,recommend,verify,auto_profile,profile_mode}
...
&lt;/code>&lt;/pre>
&lt;p>positional arguments:&lt;/p>
&lt;ol>
&lt;li>
&lt;p>{list,active,off,profile,profile_info,recommend,verify,auto_profile,profile_mode}&lt;/p>
&lt;/li>
&lt;li>
&lt;p>list list available profiles or plugins (by default profiles)&lt;/p>
&lt;/li>
&lt;li>
&lt;p>active show active profile&lt;/p>
&lt;/li>
&lt;li>
&lt;p>off switch off all tunings&lt;/p>
&lt;/li>
&lt;li>
&lt;p>profile switch to a given profile, or list available profiles if no profile is given&lt;/p>
&lt;/li>
&lt;li>
&lt;p>profile_info show information/description of given profile or current profile if no profile is specified&lt;/p>
&lt;/li>
&lt;li>
&lt;p>recommend recommend profile&lt;/p>
&lt;/li>
&lt;li>
&lt;p>verify verify profile&lt;/p>
&lt;/li>
&lt;li>
&lt;p>auto_profile enable automatic profile selection mode, switch to the recommended profile&lt;/p>
&lt;/li>
&lt;li>
&lt;p>profile_mode show current profile selection mode&lt;/p>
&lt;/li>
&lt;/ol>
&lt;p>optional arguments:&lt;/p>
&lt;ol>
&lt;li>
&lt;p>-h, &amp;ndash;help show this help message and exit&lt;/p>
&lt;/li>
&lt;li>
&lt;p>--version, -v show program&amp;rsquo;s version number and exit&lt;/p>
&lt;/li>
&lt;li>
&lt;p>--debug, -d show debug messages&lt;/p>
&lt;/li>
&lt;li>
&lt;p>--async, -a with dbus do not wait on commands completion and return immediately&lt;/p>
&lt;/li>
&lt;li>
&lt;p>--timeout TIMEOUT, -t TIMEOUT with sync operation use specific timeout instead of the default 600 second(s)&lt;/p>
&lt;/li>
&lt;li>
&lt;p>--loglevel LOGLEVEL, -l LOGLEVEL level of log messages to capture (one of debug, info,warn, error, console, none). Default: console&lt;/p>
&lt;/li>
&lt;/ol></description></item><item><title>Docs: rule 与 route</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/x.linux-%E7%AE%A1%E7%90%86/linux-%E7%BD%91%E7%BB%9C%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/iproute-%E5%B7%A5%E5%85%B7%E5%8C%85/ip-%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%B7%A5%E5%85%B7/rule-%E4%B8%8E-route/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/x.linux-%E7%AE%A1%E7%90%86/linux-%E7%BD%91%E7%BB%9C%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/iproute-%E5%B7%A5%E5%85%B7%E5%8C%85/ip-%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%B7%A5%E5%85%B7/rule-%E4%B8%8E-route/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://man7.org/linux/man-pages/man8/ip-route.8.html">Manual(手册),ip-route(8)&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://man7.org/linux/man-pages/man8/ip-rule.8.html">Manual(手册),ip-rule(8)&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;h1 id="route--路由条目管理">route # 路由条目管理&lt;/h1>
&lt;p>route 可以操作内核路由表中的&lt;strong>条目&lt;/strong>。直接使用命令可以列出 main 路由表中的条目：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>root@lichenhao:~# ip route
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>default via 172.19.42.1 dev ens3 proto static
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>172.19.42.0/24 dev ens3 proto kernel scope link src 172.19.42.248
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;blockquote>
&lt;p>注意：如果默认网关已由 DHCP 分配，并且配置文件中指定了具有相同度量的同一网关，则在启动或启动接口时将发生错误。可能会显示以下错误消息：&lt;code>RTNETLINK answers:File exists&lt;/code>。可以忽略此错误。&lt;/p>
&lt;/blockquote>
&lt;p>| 目的地址 | via
下一跳 | dev
网络设备 | proto
生成路由条目的方式 | scope
覆盖范围 | src&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>源地址&lt;/th>
&lt;th>&lt;/th>
&lt;th>&lt;/th>
&lt;th>&lt;/th>
&lt;th>&lt;/th>
&lt;th>&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>default&lt;/td>
&lt;td>172.19.42.1&lt;/td>
&lt;td>ens3&lt;/td>
&lt;td>static&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>172.19.42.0/24&lt;/td>
&lt;td>&lt;/td>
&lt;td>ens3&lt;/td>
&lt;td>kernel&lt;/td>
&lt;td>link&lt;/td>
&lt;td>172.19.42.248&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>&lt;strong>Route Type(路由类型)&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>unicast&lt;/li>
&lt;li>unreachable&lt;/li>
&lt;li>blackhole&lt;/li>
&lt;li>prohibit&lt;/li>
&lt;li>local&lt;/li>
&lt;li>broadcast&lt;/li>
&lt;li>throw&lt;/li>
&lt;li>nat&lt;/li>
&lt;li>anycast&lt;/li>
&lt;li>multicast&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>Route Tables(路由表)&lt;/strong>
Linux-2.x 版本内核以后，可以根据 &lt;strong>SELECTOR(选择器)&lt;/strong> 将数据包交给不同的路由表进行路由处理。这些路由表由 1 到 232 范围内的数字表示(/etc/iproute2/rt_tables 文件中可以为数字起一个别名)。默认情况下，所有普通路由规则都会插入名为 main 的路由表中(main 路由表的 ID 为 254)。ip rule 命令可以对路由表进行控制。&lt;/p>
&lt;h2 id="syntax语法">Syntax(语法)&lt;/h2>
&lt;p>&lt;strong>ip [Global OPTIONS] route [COMMAND]&lt;/strong>
&lt;strong>ip [Global OPTIONS] route { show | flush } [to] SELECTOR&lt;/strong>
&lt;strong>ip [Global OPTIONS] route get ROUTE_GET_FLAGS ADDRESS [ from ADDRESS iif STRING ] [ oif STRING ] [ mark MARK ] [ tos TOS ] [ vrf NAME ] [ ipproto PROTOCOL ] [ sport NUMBER ] [ dport NUMBER ]&lt;/strong>
&lt;strong>ip [Global OPTIONS] route {add|del|change|append|replace} ROUTE&lt;/strong>&lt;/p>
&lt;h3 id="arguments">ARGUMENTS&lt;/h3>
&lt;p>&lt;strong>SELECTOR = [ root PREFIX ] [ match PREFIX ] [ exact PREFIX ] [ table TABLE_ID ] [ vrf NAME ] [ proto RTPROTO ] [ type TYPE ] [ scope SCOPE ]&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>**table &amp;lt;TABLE_ID&amp;gt; **# 指定路由表的标识符&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>ROUTE = NODE_SPEC [ INFO_SPEC ]&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>NODE_SPEC = [ TYPE ] PREFIX [ tos TOS ] [ table TABLE_ID ] [ proto RTPROTO ] [ scope SCOPE ] [ metric METRIC ] [ ttl-propagate { enabled | disabled } ]&lt;/li>
&lt;li>INFO_SPEC = { NH | nhid ID } OPTIONS FLAGS [ nexthop NH ] &amp;hellip;
&lt;ul>
&lt;li>NH := [ encap ENCAP ] [ via [ FAMILY ] ADDRESS ] [ dev STRING ] [weight NUMBER ] NHFLAGS&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>FAMILY := [ inet | inet6 | mpls | bridge | link ]&lt;/strong>&lt;/p>
&lt;p>&lt;strong>RTPROTO = [ STRING | NUMBER ]&lt;/strong> # 生成本路由条目时所使用的 Routing Protocol(路由协议，简称 RTPROTO) 的标识符。RTPROTO 的值来自于 /etc/iproute2/rt_protos 文件中数字或字符串。&lt;/p>
&lt;blockquote>
&lt;p>注意：此协议不是指传统意义上的 http、tcp 这种协议，而是指，生成路由条目的方式、或者说生成路由条目的实体。比如我们可以说内核自己生成了一个路由条目；也可以说通过 dhcp 获取 IP 时生成了路由条目；还可以说通过人为手动创建了一个路由条目；等等。&lt;/p>
&lt;/blockquote>
&lt;ul>
&lt;li>boot # 默认 RTPROTO。该路由条目在 bootup sequence 期间生成的。且路由守护进程启动时，这些条目将被删除
&lt;ul>
&lt;li>不太理解这个官方的解释？？用人话说，就是 ip 命令默认添加的路由条目在机器重启后会被删除。但是这个类型兜底是啥子意思哦？~&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>kernel # 该路由条目在内核自动配置期间生成。&lt;/li>
&lt;li>dhcp #&lt;/li>
&lt;li>static # 该路由条目由管理员手动添加以覆盖动态路由。路由守护进程会尊重它们，甚至可能将它们通告给它的 peers。&lt;/li>
&lt;li>ra # 该路由条目由 Router Discovery Protocol(路由发现协议) 生成。通常只出现在 IPv6 中&lt;/li>
&lt;li>等等&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>TABLE_ID := [ local| main | default | all | NUMBER ]&lt;/strong> #&lt;/p>
&lt;p>&lt;strong>SCOPE := [ STRING | NUMBER ]&lt;/strong> # 目的地址覆盖的范围。即路由数据包之前，从哪些地方找目的地址。SCOPE 的值来自于 /etc/iproute2/rt_scopes 文件中的数字或字符串。如果省略此参数，则 ip 程序默认 unicast(单播) 类型的路由范围为 global、local 类型的路由范围为 host、unicast 和 broadcst 类型的路由范围为 link。
用人话说：为数据包选择路由条目前，还需要判断目的地址的有效性。也就是说，目的地址在哪里才是可以被路由的。&lt;/p>
&lt;ul>
&lt;li>host # 目的地址仅在本主机上有效&lt;/li>
&lt;li>link # 目的地址仅在本网络设备上有效&lt;/li>
&lt;li>global # 目的地址全局有效&lt;/li>
&lt;/ul>
&lt;h2 id="ip-route-show">ip route show&lt;/h2>
&lt;p>显示路由表的内容或按某些标准选择的路由。&lt;/p>
&lt;ul>
&lt;li>&lt;strong>to &lt;!-- raw HTML omitted -->&lt;/strong> #&lt;/li>
&lt;li>&lt;strong>protocol &lt;!-- raw HTML omitted -->&lt;/strong> # 显示指定协议标识符的路由条目&lt;/li>
&lt;/ul>
&lt;h2 id="example">EXAMPLE&lt;/h2>
&lt;ul>
&lt;li>查看名为 local 的路由表的条目
&lt;ul>
&lt;li>ip route show table local&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>查看该 IP 从哪里过来
&lt;ul>
&lt;li>ip route get 192.168.0.1&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>添加默认路由条目，经过 ens3 网络设备，下一跳是 172.19.42.1
&lt;ul>
&lt;li>ip route add default via 172.19.42.1 dev ens3&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>添加路由条目，目的地址是 10.10.10.0/24 网段的数据包的下一跳地址是 192.168.0.2 使用 eth0 网络设备
&lt;ul>
&lt;li>ip route add 10.10.10.0/24 via 192.168.0.2 dev eth0&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h1 id="rule--路由策略数据库管理">rule # 路由策略数据库管理&lt;/h1>
&lt;p>rule 可以操作路由策略数据库中的规则，控制路由选择算法。说白了就是可以&lt;strong>控制路由表，&lt;strong>而 ip route 则是控制&lt;/strong>路由表的条目。&lt;/strong>&lt;/p>
&lt;p>在互联网上，传统的路由算法仅基于数据包的目标地址做出路由选择。但是在某些情况下，我们希望路由数据包的策略，而不仅仅取决于目标地址，还可以通过源地址、IP 协议、传输协议、端口、甚至数据包的 payload 等等信息来对数据包的路由进行选择。这种方式，称为 &lt;strong>Policy Routing(策略路由)&lt;/strong>。&lt;/p>
&lt;p>为了解决上面的问题，传统的基于目的地址的 &lt;strong>Routing table(路由表)&lt;/strong> 被替换为 &lt;strong>Routing policy database(路由策略数据库，简称 RPDB)&lt;/strong>。RPDB 通过执行一些 **Rule(规则) **来选择路由表。&lt;/p>
&lt;p>每个路由策略规则由以下两部分组成：&lt;/p>
&lt;ul>
&lt;li>&lt;strong>Selector(选择器)&lt;/strong> # 通过一些规则，对数据包进行匹配，匹配到的数据包，将会执行 Action 定义的动作。&lt;/li>
&lt;li>**Action(动作) **# 匹配到的数据包将要执行的动作。
&lt;ul>
&lt;li>比如有一个动作叫 lookup，用来指定要查找路由条目的路由表 ID。意思就是指，根据指定路由表中的路由条目，来决定 Selector 匹配到的数据包应该被路由到哪里&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>RPDB 按照优先级递减的顺序注意扫描这些规则(数字越小，优先级越高)。&lt;/p>
&lt;p>在启动时，内核将会配置三个规则组成默认的 RPDB 条目：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>root@lichenhao:~# ip rule
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>0: from all lookup local
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>32766: from all lookup main
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>32767: from all lookup default
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ul>
&lt;li>0: from all lookup local
&lt;ul>
&lt;li>**local 路由表(ID 255) # **是包含用于本地和广播地址的高优先级控制路由的特殊路由表。&lt;/li>
&lt;li>Priority(优先级) # 0&lt;/li>
&lt;li>Selector(选择器) # 匹配所有&lt;/li>
&lt;li>Action(动作) # 查找名为 local 的路由表。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>32766: from all lookup main
&lt;ul>
&lt;li>&lt;strong>main 路由表(ID 254)&lt;/strong> # 是包含所有非策略路由的正常路由表。可以通过管理员删除和/或覆盖此规则。我们平时配置的路由条目都是在这个表中配置的。&lt;/li>
&lt;li>Priority(优先级) # 32766&lt;/li>
&lt;li>Selector(选择器) # 匹配所有&lt;/li>
&lt;li>Action(动作) # 查找名为 local 的路由表。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>32767: from all lookup default
&lt;ul>
&lt;li>&lt;strong>default 路由表(ID 253)&lt;/strong> # 为空。如果未选择先前的默认规则，则保留某些后处理。也可以删除此规则。&lt;/li>
&lt;li>Priority(优先级) # 327667&lt;/li>
&lt;li>Selector(选择器) # 匹配所有&lt;/li>
&lt;li>Action(动作) # 查找名为 local 的路由表。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>每个 RPDB 条目都有附加属性。每个规则都有一个指向某个路由表的指针。 NAT 和伪装规则有一个属性来选择要转换/伪装的新 IP 地址。除此之外，规则还有一些可选属性，路由也有，即领域。这些值不会覆盖路由表中包含的值。它们仅在路由未选择任何属性时使用。&lt;/p>
&lt;h2 id="syntax语法-1">Syntax(语法)&lt;/h2>
&lt;p>&lt;strong>ip [OPTIONS] rule { COMMAND | help }&lt;/strong>
&lt;strong>ip [OPTIONS] rule [ list [ SELECTOR ]]&lt;/strong>
&lt;strong>ip [OPTIONS] rule { add | del } SELECTOR ACTION&lt;/strong>&lt;/p>
&lt;p>&lt;strong>SELECTOR&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>
&lt;p>&lt;strong>from PREFIX&lt;/strong> # 选择要匹配的源地址。&lt;code>默认值：all&lt;/code>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>**to PREFIX **# 选择要匹配的目的地址。&lt;code>默认值：all&lt;/code>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>priority NUM&lt;/strong> # 策略规则的优先级。&lt;code>默认值:当前数字最大的优先级逐一减 1&lt;/code>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>ACTION&lt;/strong>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>lookup TABLEID&lt;/strong> # 根据 SELECTOR 匹配到的查找路由表，根据指定的 TABLEID 路由表来处理数据包的路由。&lt;code>默认值：254&lt;/code>&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h2 id="example-1">EXAMPLE&lt;/h2>
&lt;ul>
&lt;li>添加优先级为 1，ID 为 2 的路由表，所有源地址是 192.168.0.0/24 网段的数据包都根据该路由表的规则进行路由。
&lt;ul>
&lt;li>&lt;strong>ip rule add priority 1  from 192.168.0.0/24 table 2&lt;/strong>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul></description></item></channel></rss>