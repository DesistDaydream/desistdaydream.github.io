<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>断念梦 – Linux 系统管理工具</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/x.linux-%E7%AE%A1%E7%90%86/linux-%E7%B3%BB%E7%BB%9F%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/</link><description>Recent content in Linux 系统管理工具 on 断念梦</description><generator>Hugo -- gohugo.io</generator><atom:link href="https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/x.linux-%E7%AE%A1%E7%90%86/linux-%E7%B3%BB%E7%BB%9F%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/index.xml" rel="self" type="application/rss+xml"/><item><title>Docs: BCC 工具集</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/x.linux-%E7%AE%A1%E7%90%86/linux-%E7%B3%BB%E7%BB%9F%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/bcc-%E5%B7%A5%E5%85%B7%E9%9B%86/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/x.linux-%E7%AE%A1%E7%90%86/linux-%E7%B3%BB%E7%BB%9F%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/bcc-%E5%B7%A5%E5%85%B7%E9%9B%86/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://iovisor.github.io/bcc/">官网&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://github.com/iovisor/bcc">GitHub 项目,iovisor/bcc&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>&lt;strong>BPF Compiler Collection(BPF 编译器合集，简称 BCC)&lt;/strong> 是用于创建有效的内核跟踪和操作程序的工具包。BCC 是 Linux 基金会旗下的 IO Visor 项目组做出来的基于 eBPF 的产品。BBC 主要用来为 Linux 提供 &lt;strong>Dynamic Tracing(动态追踪)&lt;/strong> 功能的实现。
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/ng174l/1619076409581-b90915a0-9bcb-4aa7-8ea4-4f0d66048ddd.png" alt="image.png">&lt;/p>
&lt;h1 id="bcc-安装">BCC 安装&lt;/h1>
&lt;h2 id="通过-linux-包管理器安装">通过 Linux 包管理器安装&lt;/h2>
&lt;h3 id="ubuntu">Ubuntu&lt;/h3>
&lt;p>标准的 Ubuntu Universe 仓库 与 iovisor 的 PPA 仓库中都可以用来安装 BCC 工具，但是包的名称不同。Ubuntu 安装完的程序，其名称会在最后加上 &lt;code>-bpfcc&lt;/code>。&lt;/p>
&lt;ul>
&lt;li>使用 Ubuntu 仓库安装&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>sudo apt-get install bpfcc-tools linux-headers-&lt;span style="color:#66d9ef">$(&lt;/span>uname -r&lt;span style="color:#66d9ef">)&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ul>
&lt;li>使用 iovisor 仓库安装&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>sudo apt-key adv --keyserver keyserver.ubuntu.com --recv-keys 4052245BD4284CDD
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>echo &lt;span style="color:#e6db74">&amp;#34;deb https://repo.iovisor.org/apt/&lt;/span>&lt;span style="color:#66d9ef">$(&lt;/span>lsb_release -cs&lt;span style="color:#66d9ef">)&lt;/span>&lt;span style="color:#e6db74"> &lt;/span>&lt;span style="color:#66d9ef">$(&lt;/span>lsb_release -cs&lt;span style="color:#66d9ef">)&lt;/span>&lt;span style="color:#e6db74"> main&amp;#34;&lt;/span> | sudo tee /etc/apt/sources.list.d/iovisor.list
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>sudo apt-get update
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>sudo apt-get install bcc-tools libbcc-examples linux-headers-&lt;span style="color:#66d9ef">$(&lt;/span>uname -r&lt;span style="color:#66d9ef">)&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="centos">CentOS&lt;/h3>
&lt;h1 id="bcc-工具概述">BCC 工具概述&lt;/h1>
&lt;p>命名规则
XXXsnoop 这类工具的名字通常用来追踪指定对象，snoop 有窥探之意。比如 opensnoop 工具用来追踪 open() 系统调用、execsnoop 工具用来追踪 exec() 系统调用 等等。&lt;/p>
&lt;p>&lt;strong>syscount&lt;/strong> # 追踪系统调用，并统计次数
&lt;strong>tcpconnect&lt;/strong> # 追踪活动的 TCP 连接，即 &lt;code>connect()&lt;/code> 系统调用。
&lt;strong>tcptracer&lt;/strong> # 追踪&lt;/p></description></item><item><title>Docs: bpftrace 工具</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/x.linux-%E7%AE%A1%E7%90%86/linux-%E7%B3%BB%E7%BB%9F%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/bpftrace-%E5%B7%A5%E5%85%B7/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/x.linux-%E7%AE%A1%E7%90%86/linux-%E7%B3%BB%E7%BB%9F%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/bpftrace-%E5%B7%A5%E5%85%B7/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://github.com/iovisor/bpftrace">GitHub 项目&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>bpftrace 是用于 Linux 增强型 eBPF 的高级跟踪语言，可在最近的 Linux 内核 (4.x) 中使用。 bpftrace 使用 LLVM 作为后端，将脚本编译为 BPF 字节码，并利用 BCC 与 Linux BPF 系统交互，以及现有的 Linux 跟踪功能：内核动态跟踪（kprobes）、用户级动态跟踪（uprobes）、和跟踪点。 bpftrace 语言的灵感来自 awk 和 C，以及 DTrace 和 SystemTap 等前身跟踪器。 bpftrace 是由 Alastair Robertson 创建的。、&lt;/p>
&lt;p>&lt;strong>简单示例&lt;/strong>&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># Files opened by process&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>bpftrace -e &lt;span style="color:#e6db74">&amp;#39;tracepoint:syscalls:sys_enter_open { printf(&amp;#34;%s %s\n&amp;#34;, comm, str(args-&amp;gt;filename)); }&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># Syscall count by program&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>bpftrace -e &lt;span style="color:#e6db74">&amp;#39;tracepoint:raw_syscalls:sys_enter { @[comm] = count(); }&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># Read bytes by process:&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>bpftrace -e &lt;span style="color:#e6db74">&amp;#39;tracepoint:syscalls:sys_exit_read /args-&amp;gt;ret/ { @[comm] = sum(args-&amp;gt;ret); }&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># Read size distribution by process:&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>bpftrace -e &lt;span style="color:#e6db74">&amp;#39;tracepoint:syscalls:sys_exit_read { @[comm] = hist(args-&amp;gt;ret); }&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># Show per-second syscall rates:&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>bpftrace -e &lt;span style="color:#e6db74">&amp;#39;tracepoint:raw_syscalls:sys_enter { @ = count(); } interval:s:1 { print(@); clear(@); }&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># Trace disk size by process&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>bpftrace -e &lt;span style="color:#e6db74">&amp;#39;tracepoint:block:block_rq_issue { printf(&amp;#34;%d %s %d\n&amp;#34;, pid, comm, args-&amp;gt;bytes); }&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># Count page faults by process&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>bpftrace -e &lt;span style="color:#e6db74">&amp;#39;software:faults:1 { @[comm] = count(); }&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># Count LLC cache misses by process name and PID (uses PMCs):&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>bpftrace -e &lt;span style="color:#e6db74">&amp;#39;hardware:cache-misses:1000000 { @[comm, pid] = count(); }&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># Profile user-level stacks at 99 Hertz, for PID 189:&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>bpftrace -e &lt;span style="color:#e6db74">&amp;#39;profile:hz:99 /pid == 189/ { @[ustack] = count(); }&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># Files opened, for processes in the root cgroup-v2&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>bpftrace -e &lt;span style="color:#e6db74">&amp;#39;tracepoint:syscalls:sys_enter_openat /cgroup == cgroupid(&amp;#34;/sys/fs/cgroup/unified/mycg&amp;#34;)/ { printf(&amp;#34;%s\n&amp;#34;, str(args-&amp;gt;filename)); }&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div></description></item><item><title>Docs: Cockpit</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/x.linux-%E7%AE%A1%E7%90%86/linux-%E7%B3%BB%E7%BB%9F%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/cockpit-#-%E5%9F%BA%E4%BA%8E-web-%E7%9A%84-linux-%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/x.linux-%E7%AE%A1%E7%90%86/linux-%E7%B3%BB%E7%BB%9F%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/cockpit-#-%E5%9F%BA%E4%BA%8E-web-%E7%9A%84-linux-%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/</guid><description/></item><item><title>Docs: Cockpit # 基于 Web 的 Linux 服务器管理工具</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/x.linux-%E7%AE%A1%E7%90%86/linux-%E7%B3%BB%E7%BB%9F%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/cockpit-#-%E5%9F%BA%E4%BA%8E-web-%E7%9A%84-linux-%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/x.linux-%E7%AE%A1%E7%90%86/linux-%E7%B3%BB%E7%BB%9F%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/cockpit-#-%E5%9F%BA%E4%BA%8E-web-%E7%9A%84-linux-%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/</guid><description/></item><item><title>Docs: CPU 管理工具</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/x.linux-%E7%AE%A1%E7%90%86/linux-%E7%B3%BB%E7%BB%9F%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/cpu-%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/x.linux-%E7%AE%A1%E7%90%86/linux-%E7%B3%BB%E7%BB%9F%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/cpu-%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;h2 id="参考">参考：&lt;/h2>
&lt;/blockquote></description></item><item><title>Docs: Memory 管理工具</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/x.linux-%E7%AE%A1%E7%90%86/linux-%E7%B3%BB%E7%BB%9F%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/memory-%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/x.linux-%E7%AE%A1%E7%90%86/linux-%E7%B3%BB%E7%BB%9F%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/memory-%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;h1 id="概述-1">概述&lt;/h1>
&lt;blockquote>
&lt;h2 id="参考">参考：&lt;/h2>
&lt;/blockquote>
&lt;h1 id="查看-memory-的使用情况">查看 Memory 的使用情况&lt;/h1>
&lt;p>我们可以通过多种方式查看 Memory 信息。&lt;/p>
&lt;h2 id="procmemory-文件">/proc/memory 文件&lt;/h2>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://access.redhat.com/solutions/406773">RedHat 官方给的解释&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>该文件报告有关系统上内存使用情况的统计信息。 free 命令使用该文件来报告系统上的可用内存和已使用内存（物理内存和交换内存）以及内核使用的共享内存和缓冲区的数量。该文件是以 &lt;code>:&lt;/code> 符号分割的 &lt;strong>Key/Value pair(键/值对)&lt;/strong> 格式。可用参数及其详解如下：&lt;/p>
&lt;h3 id="memtotal">MemTotal&lt;/h3>
&lt;p>总可用 Memory。即.物理 RAM 减去一些保留的 bits 和内核二进制代码所用的量&lt;/p>
&lt;h3 id="memfree">MemFree&lt;/h3>
&lt;p>空闲的 Memory。LowFree 与 HighFree 两个参数的值的和&lt;/p>
&lt;h3 id="memavailable">MemAvailable&lt;/h3>
&lt;p>可用的 Memory。估算值，估计有多少内存可用于启动新的应用程序&lt;/p>
&lt;h3 id="buffers-与-cached">Buffers 与 Cached&lt;/h3>
&lt;p>详见：《[Memory 的缓存机制](✏IT 学习笔记/📄1.操作系统/2.Kernel(内核)/5.Memory%20 管理/Memory%20 的缓存机制.md 管理/Memory 的缓存机制.md)》&lt;/p>
&lt;h3 id="active">Active&lt;/h3>
&lt;p>最近使用过的 Memory。除非必要，否则通常不会回收。&lt;/p>
&lt;h3 id="inactive">Inactive&lt;/h3>
&lt;p>最近使用比较收的 Memory。这些内存会被优先回收。&lt;/p>
&lt;h3 id="slab">Slab&lt;/h3>
&lt;p>内核数据结构缓存。dentry、inode_cache 等&lt;/p>
&lt;h3 id="sreclaimable">SReclaimable&lt;/h3>
&lt;p>Slab Reclaimable。Slab 的一部分，可以被 reclaimed(回收)。例如 dentry、inode 的缓存等等。&lt;/p>
&lt;h3 id="sunreclaim">SUnreclaim&lt;/h3>
&lt;p>Slab UnReclaim。Slab 的一部分，不可以被 reclaimed(回收)。即使内存有压力也无法回收&lt;/p>
&lt;h3 id="commitlimit">CommitLimit&lt;/h3>
&lt;p>提交限制。当前可以分配的内存上限。只有当 [/proc/sys/vm/overcommit_memory](net(网络相关参数).md Kernel/Kernel 参数/net(网络相关参数).md) 的参数值为 2 的时候，该限制才生效。这个上限是指当程序向系统申请内存时，如果申请的内存加上现在已经分配的内存，超过了 commitlimit 的值，则该申请将会失败。&lt;/p>
&lt;p>该值通过如下公式：
&lt;code>CommitLimit = (total_RAM - total_huge_TLB) * overcommit_ratio / 100 + total_swap&lt;/code>&lt;/p>
&lt;ul>
&lt;li>totaol_RAM # 系统内存总量(就是物理内存)&lt;/li>
&lt;li>total_huge_TLB # 为 huge pages 保留的内存量，一般没有保留，都是 0&lt;/li>
&lt;li>overcommit_ratio # /proc/sys/vm/overcommit_ratio 内核参数的值。&lt;/li>
&lt;li>total_swap # swap 空间的总量&lt;/li>
&lt;/ul>
&lt;h3 id="committed_as">Committed_AS&lt;/h3>
&lt;blockquote>
&lt;p>Allocated Size(已经分配的大小，简称 AS)&lt;/p>
&lt;/blockquote>
&lt;p>当前已经分配的内存总量。注意：不是正在使用的，而是已经分配的。&lt;/p>
&lt;p>当 overcommit_memory 参数的值为 2 时，该值不能超过 CommitLimit 的值。其余时候该值可以无限大。&lt;/p>
&lt;h2 id="free-命令">free 命令&lt;/h2>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>~&lt;span style="color:#f92672">]&lt;/span>&lt;span style="color:#75715e"># free -h&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> total used free shared buff/cache available
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Mem: 3.8Gi 846Mi 506Mi 1.0Mi 2.5Gi 2.9Gi
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Swap: 0B 0B 0B
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Mem：设备上的真实内存&lt;/p>
&lt;ul>
&lt;li>total # 总计。该设备的总内存大小&lt;/li>
&lt;li>used # 已使用的。linux 对内存的使用量&lt;/li>
&lt;li>free # 空闲的。还剩多少内存可用&lt;/li>
&lt;li>shared # 共享内存&lt;/li>
&lt;li>buff # 缓冲区(buffer)。保存一些将要写入到硬盘中的数据。&lt;/li>
&lt;li>cache # 缓存。从硬盘中读出的数据存放到内存中，以便再次读取相同数据时速度更快。&lt;/li>
&lt;li>availabel # 可用的。free+buff/cache 合起来就是可用的。&lt;/li>
&lt;/ul>
&lt;h2 id="free-命令-与-procmeminfo-文件中信息的对应关系">free 命令 与 /proc/meminfo 文件中信息的对应关系。&lt;/h2>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>free 命令输出&lt;/th>
&lt;th>&lt;code>/proc/meminfo&lt;/code>文件的字段&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>&lt;code>Mem: total&lt;/code>&lt;/td>
&lt;td>&lt;code>MemTotal&lt;/code>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>Mem: used&lt;/code>&lt;/td>
&lt;td>&lt;code>MemTotal - MemFree - Buffers - Cached - SReclaimable&lt;/code>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>Mem: free&lt;/code>&lt;/td>
&lt;td>&lt;code>MemFree&lt;/code>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>Mem: shared&lt;/code>&lt;/td>
&lt;td>&lt;code>Shmem&lt;/code>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>Mem: buff/cache&lt;/code>&lt;/td>
&lt;td>&lt;code>Buffers + Cached + Slab&lt;/code>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>Mem:available&lt;/code>&lt;/td>
&lt;td>&lt;code>MemAvailable&lt;/code>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>Swap: total&lt;/code>&lt;/td>
&lt;td>&lt;code>SwapTotal&lt;/code>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>Swap: used&lt;/code>&lt;/td>
&lt;td>&lt;code>SwapTotal - SwapFree&lt;/code>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>Swap: free&lt;/code>&lt;/td>
&lt;td>&lt;code>SwapFree&lt;/code>&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h1 id="一个可以消耗-linux-内存的-shell-脚本">一个可以消耗 Linux 内存的 Shell 脚本&lt;/h1>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#!/bin/bash
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>mkdir /tmp/memory
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>mount -t tmpfs -o size&lt;span style="color:#f92672">=&lt;/span>1024M tmpfs /tmp/memory
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>dd &lt;span style="color:#66d9ef">if&lt;/span>&lt;span style="color:#f92672">=&lt;/span>/dev/zero of&lt;span style="color:#f92672">=&lt;/span>/tmp/memory/block
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>sleep &lt;span style="color:#ae81ff">3600&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>rm /tmp/memory/block
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>umount /tmp/memory
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>rmdir /tmp/memory
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div></description></item><item><title>Docs: perf 性能分析工具</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/x.linux-%E7%AE%A1%E7%90%86/linux-%E7%B3%BB%E7%BB%9F%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/perf-%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/x.linux-%E7%AE%A1%E7%90%86/linux-%E7%B3%BB%E7%BB%9F%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/perf-%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://github.com/torvalds/linux/tree/master/tools/perf">GitHub 项目&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://perf.wiki.kernel.org/index.php/Main_Page">Kernel Wiki,perf&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://qastack.cn/unix/326621/what-are-kernel-pmu-event-s-in-perf-events-list">PMU 是什么？&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>&lt;strong>Linux Performance Events(Linux 性能事件，简称 LPE)&lt;/strong> 是用来分析 Linux 性能的工具，通常称为 &lt;strong>perf&lt;/strong>。perf 随 Kernel 2.6+ 一同发布。通过它，应用程序可以利用 PMU，tracepoint 和内核中的特殊计数器来进行性能统计。它不但可以分析指定应用程序的性能问题 (per thread)，也可以用来分析内核的性能问题，当然也可以同时分析应用代码和内核，从而全面理解应用程序中的性能瓶颈。&lt;/p>
&lt;p>perf 主要是通过 &lt;strong>Tracing(追踪)&lt;/strong> 的方式来实现性能数据的采集。&lt;/p>
&lt;h1 id="perf-安装">perf 安装&lt;/h1>
&lt;p>&lt;strong>Ubuntu&lt;/strong>&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>sudo apt install -y linux-tools-generic linux-tools-&lt;span style="color:#66d9ef">$(&lt;/span>uname -r&lt;span style="color:#66d9ef">)&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;blockquote>
&lt;p>注意：linux-tools-generic 会安装 linux-tools-common 包，perf 二进制文件在这个包中。&lt;/p>
&lt;/blockquote>
&lt;p>&lt;strong>CentOS&lt;/strong>&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>yum install -y perf
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h1 id="perf-工具使用详解">perf 工具使用详解&lt;/h1>
&lt;p>&lt;strong>perf [OPTIONS] COMMAND [ARGS]&lt;/strong>
perf 主要由多个子命令来提供常用功能&lt;/p>
&lt;h2 id="record--追踪指定的进程并记录它的-profile-到-perfdata-文件中">record # 追踪指定的进程，并记录它的 profile 到 perf.data 文件中&lt;/h2>
&lt;blockquote>
&lt;p>参考：&lt;a href="https://man7.org/linux/man-pages/man1/perf-record.1.html">man 手册&lt;/a>&lt;/p>
&lt;/blockquote>
&lt;p>record 子命令将会跟踪指定命令或进程，并采集运行期间的 profile，然后默认将这些数据写入到 perf.data 文件中。**profile **这个词在这个语境中，可以理解为 &lt;strong>性能分析&lt;/strong>，详见 &lt;a href="https://www.yuque.com/go/doc/44354412">火焰图章节&lt;/a>&lt;/p>
&lt;p>&lt;strong>perf record [OPTIONS] [COMMAND]&lt;/strong>
&lt;strong>COMMAND&lt;/strong> # 可以指定一个命令，以便采集指定命令运行时的性能数据。或者省略 COMMAND，则采集当前系统下的所有进程。&lt;/p>
&lt;hr>
&lt;p>OPTIONS&lt;/p>
&lt;ul>
&lt;li>&lt;strong>-a, &amp;ndash;all-cpus&lt;/strong> # 从所有 CPU 采集数据&lt;/li>
&lt;li>**-g **# 启动调用关系分析&lt;/li>
&lt;li>**-p, &amp;ndash;pid &lt;!-- raw HTML omitted --> **# 指定要采集数据的进程的 PID&lt;/li>
&lt;/ul>
&lt;p>EXAMPLE&lt;/p>
&lt;ul>
&lt;li>&lt;strong>perf record -a -g -p 5958 &amp;ndash; sleep 30&lt;/strong>&lt;/li>
&lt;/ul>
&lt;h2 id="report--读取-perfdata-文件中记录的内容并展示">report # 读取 perf.data 文件中记录的内容并展示&lt;/h2>
&lt;h2 id="script--读取-perfdata-文件中记录的内容并展示追踪效果的数据">script # 读取 perf.data 文件中记录的内容，并展示追踪效果的数据&lt;/h2>
&lt;h2 id="top--系统分析工具">top # 系统分析工具&lt;/h2>
&lt;p>可以实时显示占用 CPU 时钟最多得函数或进程。以 Symbol 为中心，显示指定 Symbol 的相关信息&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>Samples: 2K of event &lt;span style="color:#e6db74">&amp;#39;cpu-clock:pppH&amp;#39;&lt;/span>, &lt;span style="color:#ae81ff">4000&lt;/span> Hz, Event count &lt;span style="color:#f92672">(&lt;/span>approx.&lt;span style="color:#f92672">)&lt;/span>: &lt;span style="color:#ae81ff">317933941&lt;/span> lost: 0/0 drop: 0/0
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Overhead Shared Object Symbol
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>16.96% perf &lt;span style="color:#f92672">[&lt;/span>.&lt;span style="color:#f92672">]&lt;/span> __symbols__insert
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>7.12% perf &lt;span style="color:#f92672">[&lt;/span>.&lt;span style="color:#f92672">]&lt;/span> rb_next
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>3.92% &lt;span style="color:#f92672">[&lt;/span>kernel&lt;span style="color:#f92672">]&lt;/span> &lt;span style="color:#f92672">[&lt;/span>k&lt;span style="color:#f92672">]&lt;/span> kallsyms_expand_symbol.constprop.1
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>第一行：&lt;/p>
&lt;ol>
&lt;li>Samples # 样本数&lt;/li>
&lt;li>event # 事件类型&lt;/li>
&lt;li>event count # 事件总数&lt;/li>
&lt;/ol>
&lt;p>第二行&lt;/p>
&lt;ol>
&lt;li>Overhead # Symbol 的性能事件在所有样本中的百分比&lt;/li>
&lt;li>Shared # Symbol 所在的动态共享对象(Dynamic Shared Object)。如 内核、进程名、动态链接库名、内核模块等等&lt;/li>
&lt;li>Object # 动态共享对象的类型。比如 [.] 表示用户空间的可执行程序、或动态链接库，而 [k] 则表示内核空间&lt;/li>
&lt;li>Symbol # 符号名。即函数名。当函数名未知时，用十六进制的地址来表示。&lt;/li>
&lt;/ol>
&lt;p>&lt;strong>perf top [OPTIONS]&lt;/strong>&lt;/p>
&lt;p>OPTIONS&lt;/p>
&lt;ul>
&lt;li>&lt;strong>-g&lt;/strong> # 开启调用关系分析&lt;/li>
&lt;li>&lt;strong>-p &lt;!-- raw HTML omitted -->&lt;/strong> # 分析指定进程的事件，PID 可以是使用 逗号 分隔的多个 PID&lt;/li>
&lt;/ul>
&lt;p>EXAMPLE&lt;/p>
&lt;ul>
&lt;li>&lt;/li>
&lt;/ul>
&lt;h1 id="生成火焰图">生成火焰图&lt;/h1>
&lt;p>获取火焰图生成工具&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>git clone https://github.com/brendangregg/FlameGraph
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>cd FlameGraph
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>将 perf record 抓到的记录转换成可读的采样记录
&lt;code>perf script -i /root/test_dir/perf.data&lt;/code>
合并调用栈信息
&lt;code>./stackcollapse-perf.pl&lt;/code>
生成火焰图
&lt;code>./flamegraph.pl&lt;/code>
上述命令合并一下：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>perf script -i /root/test_dir/perf.data | ./stackcollapse-perf.pl --all | ./flamegraph.pl &amp;gt; /root/test_dir/flame.svg
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div></description></item><item><title>Docs: perf 性能分析工具</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/x.linux-%E7%AE%A1%E7%90%86/linux-%E7%B3%BB%E7%BB%9F%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/perf-%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/x.linux-%E7%AE%A1%E7%90%86/linux-%E7%B3%BB%E7%BB%9F%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/perf-%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7/</guid><description/></item><item><title>Docs: procps 工具集</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/x.linux-%E7%AE%A1%E7%90%86/linux-%E7%B3%BB%E7%BB%9F%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/procps-%E5%B7%A5%E5%85%B7%E9%9B%86/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/x.linux-%E7%AE%A1%E7%90%86/linux-%E7%B3%BB%E7%BB%9F%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/procps-%E5%B7%A5%E5%85%B7%E9%9B%86/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://gitlab.com/procps-ng/procps">GitLab 项目，procps-ng/procps&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>procps 是一组命令行和全屏实用程序，它们从伪文件系统(/proc)获取信心，该文件系统为内核数据结构提供了一个简单的接口。procps 程序通常集中在描述系统上运行的进程的结构上。包括以下程序(每个标题都是一个程序)&lt;/p>
&lt;p>Note：该工具集就算是最小化安装的 linux 发行版系统也是默认包含的~&lt;/p>
&lt;h1 id="free显示系统中可用和已用的内存量">free：显示系统中可用和已用的内存量&lt;/h1>
&lt;h1 id="kill---send-a-signal-to-a-process-based-on-pid">kill - Send a signal to a process based on PID&lt;/h1>
&lt;h1 id="pgreppkillpidwait--根据名字或其他属性列出进程发送信号暂停进程">pgrep，pkill，pidwait # 根据名字或其他属性列出进程、发送信号、暂停进程&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://man7.org/linux/man-pages/man1/pgrep.1.html">Manual(手册),pgrep(1)&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>pgrep 查看当前正在运行的进程，并列出所有符合匹配模式的进程 ID。比如：&lt;code>pgrep -u root sshd&lt;/code> 命令将会列出由 root 用户运行的进程命令中包含 &lt;code>sshd&lt;/code> 字符串的进程 ID。效果如下：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>~&lt;span style="color:#f92672">]&lt;/span>&lt;span style="color:#75715e"># pgrep -u root sshd -a&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">1521&lt;/span> sshd: /usr/sbin/sshd -D &lt;span style="color:#f92672">[&lt;/span>listener&lt;span style="color:#f92672">]&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span> of 10-100 startups
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">16257&lt;/span> sshd: root@pts/1
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">26155&lt;/span> sshd: root@pts/2
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">26266&lt;/span> sshd: root@notty
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="syntax语法">Syntax(语法)&lt;/h2>
&lt;p>&lt;strong>pgrep [OPTIONS] PATTERN&lt;/strong>
&lt;strong>pkill [OPTIONS] PATTERN&lt;/strong>
&lt;strong>pidwait [OPTIONS] PATTERN&lt;/strong>&lt;/p>
&lt;p>PATTERN(模式) 代指正则表达式的匹配模式。比如 pgrep 根据 PATTERN 中的内容匹配进程&lt;/p>
&lt;p>&lt;strong>OPTIONS：&lt;/strong>
&lt;code>()&lt;/code> 表示该选项所适用的工具，若没有括号，则说明选项适用于所有三个工具&lt;/p>
&lt;ul>
&lt;li>**-SIGNAL, &amp;ndash;signal SIGNAL **# (pkill)指定要发送的信号。可以使用数字或信号名称。&lt;/li>
&lt;li>&lt;strong>-f, &amp;ndash;full&lt;/strong> # 这三个程序通常只会对进程名称进行匹配。加上 -f 之后，会对进程的完整命令行进行匹配。
&lt;ul>
&lt;li>比如 &lt;code>pgrep -f containerd&lt;/code> 将会出现 &lt;code>3313 /usr/bin/dockerd --containerd=/run/containerd/containerd.sock&lt;/code> 这种结果。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>-l, &amp;ndash;list-full&lt;/strong> # (pgrep)显示出完整的命令行以及进程 ID&lt;/li>
&lt;li>&lt;strong>-t, &amp;ndash;terminal &amp;lt;TERM,&amp;hellip;&amp;gt;&lt;/strong> # 仅匹配使用指定终端的进程。终端名称不用使用绝对路径。&lt;/li>
&lt;li>&lt;strong>-x, &amp;ndash;exact&lt;/strong> # 精确匹配。PATTERN 必须与 进程名称 或 进程命令行 完全对应上才会被匹配到。&lt;/li>
&lt;/ul>
&lt;h2 id="example">EXAMPLE&lt;/h2>
&lt;ul>
&lt;li>列出名字中包含 docker 的进程号
&lt;ul>
&lt;li>&lt;strong>pgrep docker&lt;/strong>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>列出 containerd 进程的进程号
&lt;ul>
&lt;li>&lt;strong>pgrep -x containerd&lt;/strong>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>踢掉 TTY 为 pts/1 的用户
&lt;ul>
&lt;li>&lt;strong>pkill -kill -t pts/1&lt;/strong>&lt;/li>
&lt;li>注意：想要获取一个用户所使用的终端，可以通过 &lt;a href="#hq2tD">procps 包中的 w 工具&lt;/a>即可&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h1 id="pmap---report-memory-map-of-a-process">pmap - Report memory map of a process&lt;/h1>
&lt;h1 id="ps--process-status进程状态报告进程的信息">ps # process status(进程状态)，报告进程的信息&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://man.cx/ps">Manual(手册)&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>Note：该命令显示出来的带 &lt;code>[]&lt;/code> 的进程为内核线程，一般不用关注。出现这种情况一般是因为 ps 命令无法获取进程的命令参数，所以会将命令名称放入括号中。毕竟用户态的 ps 命令怎么可能会获得内核内部程序的参数呢~~~&lt;/p>
&lt;p>ps 命令输出的内容中部分字段的含义说明：&lt;/p>
&lt;ol>
&lt;li>PID # Process ID(进程标识符)&lt;/li>
&lt;li>PPID # Parent Process ID(父进程标识符)，父进程是创建一个或多个子进程的进程。&lt;/li>
&lt;li>VSZ # Virtual Memory Size(虚拟内存大小)，包括进程可以访问的所有内存，包括进入交换分区的内容，以及共享库占用的内存。有的地方也称为 total_vm、VIRT&lt;/li>
&lt;li>RRS # Resident Set Size(实际内存用量)，不包括进入交换分区的内存。RSS 包括共享库占用的内存（只要共享库在内存中）。RSS 包括所有分配的栈内存和堆内存。&lt;/li>
&lt;li>LWP # 线程 ID&lt;/li>
&lt;li>NLWP # 线程数量&lt;/li>
&lt;li>STAT # 进程的当前状态
&lt;ol>
&lt;li>D # 不可中断的休眠。通常是 IO。&lt;/li>
&lt;li>R # 运行。正在运行或者在运行队列中等待。&lt;/li>
&lt;li>S # 休眠。在等待某个事件，信号。&lt;/li>
&lt;li>T # 停止。进程接收到信息 SIGSTOP，SIGSTP，SIGTIN，SIGTOU 信号。&lt;/li>
&lt;li>X # 死掉的进程，不应该出现。&lt;/li>
&lt;li>Z # 僵死进程。
&lt;ol>
&lt;li>通常还会跟随如下字母表示更详细的状态。
&lt;ol>
&lt;li>&amp;lt; 高优先级&lt;/li>
&lt;li>N 低优先级&lt;/li>
&lt;li>L 有 pages 在内存中 locked。用于实时或者自定义 IO。&lt;/li>
&lt;li>s 进程领导者，其有子进程。&lt;/li>
&lt;li>l 多线程&lt;/li>
&lt;li>
&lt;ul>
&lt;li>位于前台进程组。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ol>
&lt;/li>
&lt;/ol>
&lt;/li>
&lt;/ol>
&lt;/li>
&lt;/ol>
&lt;p>可以使用 **-o FORMAT **选项来自定义输出的格式(就是字段)。 FORMAT 是单个参数，格式为空格分隔或逗号分隔的列表，它提供了一种指定单个输出列的方法。 可以在 man 手册的 &lt;a href="https://man7.org/linux/man-pages/man1/ps.1.html#STANDARD_FORMAT_SPECIFIERS">STANDARD FORMAT SPECIFIERS(标准格式说明符)&lt;/a> 部分中找到所有可用的关键字。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># 标题可以根据需要重命名&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">[&lt;/span>root@lichenhao ~&lt;span style="color:#f92672">]&lt;/span>&lt;span style="color:#75715e"># ps -o pid,ruser=RealUser -o comm=Command&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> PID RealUser Command
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ae81ff">4652&lt;/span> root bash
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ae81ff">4774&lt;/span> root ps
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># 可以不输出标题行。&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">[&lt;/span>root@lichenhao ~&lt;span style="color:#f92672">]&lt;/span>&lt;span style="color:#75715e"># ps -o pid= -o comm=&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ae81ff">4652&lt;/span> bash
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ae81ff">4787&lt;/span> ps
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># 列宽将根据宽标题增加； 这可以用来加宽WCHAN等列&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">[&lt;/span>root@lichenhao ~&lt;span style="color:#f92672">]&lt;/span>&lt;span style="color:#75715e"># ps -o pid,wchan=WIDE-WCHAN-COLUMN -o comm&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> PID WIDE-WCHAN-COLUMN COMMAND
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ae81ff">4652&lt;/span> - bash
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ae81ff">4789&lt;/span> - ps
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># 可以也提供显式宽度控制&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">[&lt;/span>root@lichenhao ~&lt;span style="color:#f92672">]&lt;/span>&lt;span style="color:#75715e"># ps opid,wchan:42,cmd&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> PID WCHAN CMD
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ae81ff">881&lt;/span> core_sys_select /sbin/agetty -o -p -- &lt;span style="color:#ae81ff">\u&lt;/span> --noclear tty1 linux
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ae81ff">4652&lt;/span> - -bash
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ae81ff">4790&lt;/span> - ps opid,wchan:42,cmd
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># 行为因人格而异； 输出可能是名为“ X，comm = Y”的一列或名为“ X”和“ Y”的两列。如有疑问，请使用多个-o选项。&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">[&lt;/span>root@lichenhao ~&lt;span style="color:#f92672">]&lt;/span>&lt;span style="color:#75715e"># ps -o pid=X,comm=Y&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> X Y
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ae81ff">4652&lt;/span> bash
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ae81ff">4791&lt;/span> ps
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># 仅输出 启动总时长、PID、进程命令 这三列&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>root@lichenhao:~# ps -p &lt;span style="color:#ae81ff">38095&lt;/span> -o etime,pid,cmd
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ELAPSED PID CMD
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>10-03:22:51 &lt;span style="color:#ae81ff">38095&lt;/span> /bin/prometheus --web.console.templates&lt;span style="color:#f92672">=&lt;/span>/etc/prometheus/consoles --web.console.libraries&lt;span style="color:#f92672">=&lt;/span>/etc/prometheus/console_libraries --config.file&lt;span style="color:#f92672">=&lt;/span>/etc/prometheus/config_out/prometheus.yml
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>可用的 SPECIFIERS 有很多，下面仅列出常用的几个&lt;/p>
&lt;ul>
&lt;li>etime # 进程启动的总时长，格式为&lt;code>d-h:m:s&lt;/code>&lt;/li>
&lt;li>etimes # 进程启动的总时长，以秒为单位&lt;/li>
&lt;/ul>
&lt;h2 id="syntax语法-1">Syntax(语法)&lt;/h2>
&lt;p>&lt;strong>ps [OPTIONS]&lt;/strong>
默认操作显示该 shell 环境下的所有进程&lt;/p>
&lt;h3 id="options">OPTIONS&lt;/h3>
&lt;h4 id="process-selectionhttpsmancxpsheading5进程选择">&lt;a href="https://man.cx/ps#heading5">PROCESS SELECTION&lt;/a>(进程选择)&lt;/h4>
&lt;p>一共有两种选择进程的方式，且两种方式互相冲突，比如使用 -e 选项后， -p 选项则毫无意义，依然会输出所有进程&lt;/p>
&lt;ul>
&lt;li>整体选择
&lt;ul>
&lt;li>&lt;strong>-e, -A&lt;/strong> # 选择所有进程，包括不在本 shell 环境下的进程进行展示&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>按列表选择
&lt;ul>
&lt;li>&lt;strong>-p, &amp;ndash;pid &lt;!-- raw HTML omitted -->&lt;/strong> # 选择 PIDList 中列出来的进程。多个 PID 以逗号分隔&lt;/li>
&lt;li>&lt;strong>&amp;ndash;ppid &lt;!-- raw HTML omitted -->&lt;/strong> # 选择 PIDList 中列出来的进程的子进程。多个 PID 以逗号分割&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>通用选择
&lt;ul>
&lt;li>**-N, &amp;ndash;deselect ** # 取消选择。也可以理解为 反向选择。即，选择“通过 整体选择 与 按列表选择 中选择到的”进程以外的所有进程&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h4 id="output-format-controlhttpsmancxpsheading7输出格式控制">&lt;a href="https://man.cx/ps#heading7">OUTPUT FORMAT CONTROL&lt;/a>(输出格式控制)&lt;/h4>
&lt;ul>
&lt;li>&lt;strong>-f&lt;/strong> # 更多显示信息&lt;/li>
&lt;li>&lt;strong>-l&lt;/strong> # 显示进程的详细信息&lt;/li>
&lt;li>&lt;strong>-o &lt;!-- raw HTML omitted -->&lt;/strong> # 使用指定的格式输出。&lt;/li>
&lt;li>&lt;strong>-ww&lt;/strong> # 更宽的输出，让输出的内容不受屏幕限制，可以换行显示&lt;/li>
&lt;/ul>
&lt;h4 id="output-modifiershttpsmancxpsheading8输出模式">&lt;a href="https://man.cx/ps#heading8">OUTPUT MODIFIERS&lt;/a>(输出模式)&lt;/h4>
&lt;ul>
&lt;li>&lt;strong>f,&amp;ndash;forest&lt;/strong> # 以树状结构显示输出结果。与显示线程的选项冲突&lt;/li>
&lt;li>**-o &lt;!-- raw HTML omitted --> **# 以自定义的格式 FORMAT 输出信息。FORMAT 是以逗号或空格分隔的参数列表，详见前文&lt;/li>
&lt;/ul>
&lt;h4 id="thread-displayhttpsmancxpsheading9线程显示">&lt;a href="https://man.cx/ps#heading9">THREAD DISPLAY&lt;/a>(线程显示)&lt;/h4>
&lt;p>显示线程的选项与 -f, &amp;ndash;forest 选项不可同时使用。&lt;/p>
&lt;ul>
&lt;li>&lt;strong>-T&lt;/strong> # 显示线程，会多出 SPID 列，这列为 线程 号&lt;/li>
&lt;/ul>
&lt;h2 id="example-1">EXAMPLE&lt;/h2>
&lt;ul>
&lt;li>不显示内核进程，以树状格式显示。
&lt;ul>
&lt;li>ps -N -p 2 &amp;ndash;ppid 2 -f f&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">[&lt;/span>root@common-centos-test ~&lt;span style="color:#f92672">]&lt;/span>&lt;span style="color:#75715e"># ps --deselect -p 2 --ppid 2 -f f&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>UID PID PPID C STIME TTY STAT TIME CMD
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>root &lt;span style="color:#ae81ff">1&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span> Oct19 ? Ss 0:16 /usr/lib/systemd/systemd --switched-root --system --deserialize &lt;span style="color:#ae81ff">22&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>root &lt;span style="color:#ae81ff">478&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span> Oct19 ? Ss 0:03 /usr/lib/systemd/systemd-journald
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>root &lt;span style="color:#ae81ff">496&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span> Oct19 ? Ss 0:00 /usr/sbin/lvmetad -f
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>root &lt;span style="color:#ae81ff">502&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span> Oct19 ? Ss 0:00 /usr/lib/systemd/systemd-udevd
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>root &lt;span style="color:#ae81ff">630&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span> Oct19 ? S&amp;lt;sl 0:00 /sbin/auditd
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>polkitd &lt;span style="color:#ae81ff">653&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span> Oct19 ? Ssl 0:01 /usr/lib/polkit-1/polkitd --no-debug
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>root &lt;span style="color:#ae81ff">654&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span> Oct19 ? Ss 0:00 /usr/bin/qemu-ga --method&lt;span style="color:#f92672">=&lt;/span>virtio-serial --path&lt;span style="color:#f92672">=&lt;/span>/dev/virtio-ports/org.qemu.guest_agent.0 --blacklist&lt;span style="color:#f92672">=&lt;/span>guest-file-open,guest-file-close,guest-file-read,guest-file-write,guest-file-seek,guest-file-flush,guest-exec,guest-
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>root &lt;span style="color:#ae81ff">655&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span> Oct19 ? Ss 0:04 /usr/lib/systemd/systemd-logind
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>root &lt;span style="color:#ae81ff">657&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span> Oct19 ? Ss 0:16 /usr/sbin/irqbalance --foreground
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>dbus &lt;span style="color:#ae81ff">658&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span> Oct19 ? Ssl 0:06 /usr/bin/dbus-daemon --system --address&lt;span style="color:#f92672">=&lt;/span>systemd: --nofork --nopidfile --systemd-activation
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>root &lt;span style="color:#ae81ff">670&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span> Oct19 ? Ss 0:02 /usr/sbin/crond -n
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>chrony &lt;span style="color:#ae81ff">679&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span> Oct19 ? S 0:00 /usr/sbin/chronyd
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>root &lt;span style="color:#ae81ff">689&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span> Oct19 ? Ssl 1:14 /usr/sbin/NetworkManager --no-daemon
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>root &lt;span style="color:#ae81ff">990&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span> Oct19 ? Ssl 0:47 /usr/bin/python2 -Es /usr/sbin/tuned -l -P
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>root &lt;span style="color:#ae81ff">992&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span> Oct19 ? Ssl 0:24 /usr/sbin/rsyslogd -n
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>root &lt;span style="color:#ae81ff">14438&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span> Oct21 tty1 Ss+ 0:00 /sbin/agetty --noclear tty1 linux
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>root &lt;span style="color:#ae81ff">14445&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span> Oct21 ttyS0 Ss+ 0:00 /sbin/agetty --keep-baud 115200,38400,9600 ttyS0 vt220
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>root &lt;span style="color:#ae81ff">15151&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span> Oct21 ? Ss 0:00 sshd: /usr/sbin/sshd &lt;span style="color:#f92672">[&lt;/span>listener&lt;span style="color:#f92672">]&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span> of 10-100 startups
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>root &lt;span style="color:#ae81ff">17321&lt;/span> &lt;span style="color:#ae81ff">15151&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span> 09:18 ? Ss 0:00 &lt;span style="color:#ae81ff">\_&lt;/span> sshd: root@pts/0
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>root &lt;span style="color:#ae81ff">17325&lt;/span> &lt;span style="color:#ae81ff">17321&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span> 09:18 pts/0 Ss 0:00 &lt;span style="color:#ae81ff">\_&lt;/span> -bash
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>root &lt;span style="color:#ae81ff">17365&lt;/span> &lt;span style="color:#ae81ff">17325&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span> 09:23 pts/0 R+ 0:00 &lt;span style="color:#ae81ff">\_&lt;/span> ps --deselect -p &lt;span style="color:#ae81ff">2&lt;/span> --ppid &lt;span style="color:#ae81ff">2&lt;/span> -f f
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>bash&lt;/p>
&lt;ul>
&lt;li>ps -elf&lt;/li>
&lt;/ul>
&lt;!-- raw HTML omitted -->
&lt;pre>&lt;code>[root@master0 ~]# ps -elf
F S UID PID PPID C PRI NI ADDR SZ WCHAN STIME TTY TIME CMD
4 S root 1 0 0 80 0 - 32013 ep_pol 15:16 ? 00:00:01 /usr/lib/systemd/systemd --switched-root --system --deserialize 2
1 S root 2 0 0 80 0 - 0 kthrea 15:16 ? 00:00:00 [kthreadd]
&lt;/code>&lt;/pre>
&lt;ul>
&lt;li>ps -aux&lt;/li>
&lt;/ul>
&lt;!-- raw HTML omitted -->
&lt;pre>&lt;code>[root@master0 ~]# ps aux
USER PID %CPU %MEM VSZ RSS TTY STAT START TIME COMMAND
root 1 0.0 0.4 128052 6596 ? Ss 15:16 0:01 /usr/lib/systemd/systemd --switched-root --system --deserialize 22
root 2 0.0 0.0 0 0 ? S 15:16 0:00 [kthreadd]
&lt;/code>&lt;/pre>
&lt;ul>
&lt;li>ps -efww #显示 ps 的完整内容，不受 COMMAND 命令有字符限制影响&lt;/li>
&lt;li>ps -ef f #以树状形式显示，且带中括号的内核进程将会放在最上面，与下面的系统进程分开，显示较为直观，效果如下&lt;/li>
&lt;/ul>
&lt;!-- raw HTML omitted -->
&lt;pre>&lt;code>root 1 0 0 Dec24 ? Ss 0:04 /usr/lib/systemd/systemd --switched-root --system --deserialize 22
.......
root 2827 1 0 Dec24 ? Ss 0:00 /usr/sbin/sshd -D
root 6400 2827 0 10:51 ? Ss 0:00 \_ sshd: root@pts/0
root 6402 6400 0 10:51 pts/0 Ss 0:00 \_ -bash
root 6720 6402 0 10:52 pts/0 R+ 0:00 \_ ps -ef f
&lt;/code>&lt;/pre>
&lt;ul>
&lt;li>ps -eo rss,pid,user,command | sort -rn | head -10 | awk &amp;lsquo;{ hr[1024&lt;strong>2]=&amp;ldquo;GB&amp;rdquo;; hr[1024]=&amp;ldquo;MB&amp;rdquo;;for (x=1024&lt;/strong>3; x&amp;gt;=1024; x/=1024) { if ($1&amp;gt;=x) { printf (&amp;quot;%-6.2f %s &amp;ldquo;, $1/x, hr[x]); break }} } { printf (&amp;rdquo;%-6s %-10s &amp;ldquo;, $2, $3) }{ for ( x=4 ; x&amp;lt;=NF ; x++ ) { printf (&amp;quot;%s &amp;ldquo;,$x) } print (&amp;quot;\n&amp;rdquo;) }&amp;rsquo;&lt;/li>
&lt;/ul>
&lt;!-- raw HTML omitted -->
&lt;pre>&lt;code>15.94 MB 627 root /usr/bin/python3 /usr/bin/networkd-dispatcher --run-startup-triggers
15.18 MB 683 root /usr/bin/python3 /usr/share/unattended-upgrades/unattended-upgrade-shutdown --wait-for-signal
&lt;/code>&lt;/pre>
&lt;h1 id="pwdx---report-current-directory-of-a-process">pwdx - Report current directory of a process&lt;/h1>
&lt;h1 id="skill---obsolete-version-of-pgreppkill">skill - Obsolete version of pgrep/pkill&lt;/h1>
&lt;h1 id="slabtop---display-kernel-slab-cache-information-in-real-time">slabtop - Display kernel slab cache information in real time&lt;/h1>
&lt;h1 id="snice---renice-a-process">snice - Renice a process&lt;/h1>
&lt;h1 id="sysctl--在运行时读取或写入内核参数">sysctl # 在运行时读取或写入内核参数&lt;/h1>
&lt;p>&lt;strong>sysctl [OPTIONS] [VARIABLE[=VALUE]] [&amp;hellip;]&lt;/strong>
在运行环境中配置内核参数。VARIABLE 为内核的一个变量&lt;/p>
&lt;p>OPTIONS&lt;/p>
&lt;ul>
&lt;li>&lt;strong>-a&lt;/strong> #显示所有变量&lt;/li>
&lt;li>&lt;strong>-p [/PATH/TO/FILE]&lt;/strong> #从文件中读取值,默认文件为/etc/sysctl.conf。可以指定从哪个文件来读取参数，可使用通配符。&lt;/li>
&lt;li>&lt;strong>-w&lt;/strong> # 允许写一个值到变量中&lt;/li>
&lt;/ul>
&lt;h2 id="example-2">EXAMPLE&lt;/h2>
&lt;ul>
&lt;li>sysctl -w net.ipv4.ip_forward=1 #开启 IP 转发模式&lt;/li>
&lt;li>sysctl -p /etc/sysctl.d/* #从 sysctl.d 目录中读取所有文件的内容加载到内核中&lt;/li>
&lt;/ul>
&lt;h1 id="tload---graphical-representation-of-system-load-average">tload - Graphical representation of system load average&lt;/h1>
&lt;h1 id="top运行中的进程的实时动态视图">top：运行中的进程的实时动态视图&lt;/h1>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>top - 14:06:23 up &lt;span style="color:#ae81ff">70&lt;/span> days, 16:44, &lt;span style="color:#ae81ff">2&lt;/span> users, load average: 1.25, 1.32, 1.35
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Tasks: &lt;span style="color:#ae81ff">206&lt;/span> total, &lt;span style="color:#ae81ff">1&lt;/span> running, &lt;span style="color:#ae81ff">205&lt;/span> sleeping, &lt;span style="color:#ae81ff">0&lt;/span> stopped, &lt;span style="color:#ae81ff">0&lt;/span> zombie
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Cpu&lt;span style="color:#f92672">(&lt;/span>s&lt;span style="color:#f92672">)&lt;/span>: 5.9%us, 3.4%sy, 0.0%ni, 90.4%id, 0.0%wa, 0.0%hi, 0.2%si, 0.0%st
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Mem: 32949016k total, 14411180k used, 18537836k free, 169884k buffers
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Swap: 32764556k total, 0k used, 32764556k free, 3612636k cached
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> PID USER PR NI VIRT RES SHR S %CPU %MEM TIME+ COMMAND
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">28894&lt;/span> root &lt;span style="color:#ae81ff">22&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span> 1501m 405m 10m S 52.2 1.3 2534:16 java
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">18249&lt;/span> root &lt;span style="color:#ae81ff">18&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span> 3201m 1.9g 11m S 35.9 6.0 569:39.41 java
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>第一行解析：任务队列信息，同 uptime 命令的执行结果，具体参数说明情况如下：&lt;/p>
&lt;ol>
&lt;li>14:06:23 # 当前系统时间&lt;/li>
&lt;li>up 70 days, 16:44 # 系统已经运行了 70 天 16 小时 44 分钟&lt;/li>
&lt;li>2 users #当前有 2 个用户登录系统&lt;/li>
&lt;li>load average: 1.25, 1.32, 1.35 #load average 后面的三个数分别是 1 分钟、5 分钟、15 分钟的负载情况。
&lt;ol>
&lt;li>load average 数据是每隔 5 秒钟检查一次活跃的进程数，然后按特定算法计算出的数值。如果这个数除以逻辑 CPU 的数量，结果高于 5 的时候就表明系统在超负荷运转了。&lt;/li>
&lt;li>关于 load average 的说明详见：理解 load average—Linux 系统负荷&lt;/li>
&lt;/ol>
&lt;/li>
&lt;/ol>
&lt;p>第二行解析：Tasks #任务（进程），具体信息说明如下：&lt;/p>
&lt;ol>
&lt;li>total # 系统全部的进程数。现在共有 206 个进程&lt;/li>
&lt;li>running # 运行状态的进程数&lt;/li>
&lt;li>sleeping # 睡眠状态的进程数&lt;/li>
&lt;li>stoped # 已经停止的状态的进程数&lt;/li>
&lt;li>zombie # 僵尸状态的进程数。&lt;/li>
&lt;/ol>
&lt;p>第三行解析：cpu 状态信息，显示了基于上次刷新时间间隔内，CPU 使用率的百分比。如果 top 命令每 1 秒刷新一次，则下面的信息为 1 秒时间内，CPU 被占用时间的百分比（也就意味着 us 占用 0.059 秒，sy 占用 0.034 秒，空闲了 0.904 秒，st 占用了 0.002 秒）。
具体属性说明如下：(且所有参数的值加起来应为 100%)&lt;/p>
&lt;ol>
&lt;li>5.9%us # user cpu time，未改变过 nice 值的用户空间进程的运行时间&lt;/li>
&lt;li>3.4% sy # system cpu time，内核空间进程的运行时间&lt;/li>
&lt;li>0.0% ni # user nice cpu time，已改变过 nice 值的用户空间进程的运行时间&lt;/li>
&lt;li>90.4% id # idle cpu time，CPU 空闲时间。&lt;/li>
&lt;li>0.0% wa # io wait cpu time，等待磁盘写入完成的时间。该值较高时，说明 IO 等待比较严重，这可能磁盘大量作随机访问造成的，也可能是磁盘性能出现了瓶颈。&lt;/li>
&lt;li>0.0% hi # hardware irq，硬中断（Hardware Interrupts）花费的时间&lt;/li>
&lt;li>0.2% si # software irq，软中断（Software Interrupts）花费的时间&lt;/li>
&lt;li>0.0% st # steal time，使用 hypervisor 管理的虚拟机偷取的时间&lt;/li>
&lt;/ol>
&lt;p>第四行解析：内存状态，具体信息如下：&lt;/p>
&lt;ol>
&lt;li>32949016k total — 物理内存总量（32GB）&lt;/li>
&lt;li>14411180k used — 使用中的内存总量（14GB）&lt;/li>
&lt;li>18537836k free — 空闲内存总量（18GB）&lt;/li>
&lt;li>169884k buffers — 缓存的内存量 （169M）&lt;/li>
&lt;/ol>
&lt;p>第五行解析：swap 交换分区信息，具体信息说明如下：&lt;/p>
&lt;ol>
&lt;li>32764556k total — 交换区总量（32GB）&lt;/li>
&lt;li>0k used — 使用的交换区总量（0K）&lt;/li>
&lt;li>32764556k free — 空闲交换区总量（32GB）&lt;/li>
&lt;li>3612636k cached — 缓冲的交换区总量（3.6GB）&lt;/li>
&lt;/ol>
&lt;p>第六行解析：以下各进程（任务）的状态监控，项目列信息说明如下：&lt;/p>
&lt;ol>
&lt;li>&lt;strong>PID&lt;/strong> # 进程 id&lt;/li>
&lt;li>&lt;strong>USER&lt;/strong> # 进程所有者&lt;/li>
&lt;li>&lt;strong>PR&lt;/strong> # 进程优先级&lt;/li>
&lt;li>&lt;strong>NI&lt;/strong> # nice 值。负值表示高优先级，正值表示低优先级&lt;/li>
&lt;li>&lt;strong>VIRT&lt;/strong> # 进程的虚拟内存总量，单位 KiB。即便还没有真正分配物理内存，也会计算在内。&lt;/li>
&lt;li>&lt;strong>RES&lt;/strong> # 进程常驻内存的大小，单位 KiB。是进程实际使用的物理内存的大小，但不包括 Swap 和 共享内存&lt;/li>
&lt;li>&lt;strong>SHR&lt;/strong> # 共享内存大小，单位 KiB。与其他进程共同使用的共享内存、加载的动态链接库、程序的代码段等等。&lt;/li>
&lt;li>&lt;strong>S&lt;/strong> # 进程状态。D=不可中断的睡眠状态 R=运行 S=睡眠 T=跟踪/停止 Z=僵尸进程&lt;/li>
&lt;li>&lt;strong>%CPU&lt;/strong> # 上次更新到现在的 CPU 时间占用百分比。注意：这个 CPU 的使用百分比为所有逻辑 CPU 的使用率总和，所有对于多核 CPU 的设备来说，该值很有可能会超过 100%&lt;/li>
&lt;li>&lt;strong>%MEM&lt;/strong> # 进程使用的物理内存百分比&lt;/li>
&lt;li>&lt;strong>TIME+&lt;/strong> # 进程使用的 CPU 时间总计，单位 1/100 秒&lt;/li>
&lt;li>&lt;strong>COMMAND&lt;/strong> # 进程名称（命令名/命令行）&lt;/li>
&lt;/ol>
&lt;h2 id="syntax语法-2">Syntax(语法)&lt;/h2>
&lt;p>&lt;strong>top [OPTIONS]&lt;/strong>
除了标注选项，当 top 运行时，可以通过快捷键进行一些操作&lt;/p>
&lt;ul>
&lt;li>&lt;strong>P&lt;/strong> # 按照 CPU 使用率排序&lt;/li>
&lt;li>&lt;strong>M&lt;/strong> # 按照内存使用率排序&lt;/li>
&lt;/ul>
&lt;p>OPTIONS&lt;/p>
&lt;ul>
&lt;li>&lt;strong>-d &lt;!-- raw HTML omitted -->&lt;/strong> # 设定整个进程视图更新的秒数，默认为 5 秒更新一次&lt;/li>
&lt;li>**-H **# 显示线程。 如果没有此命令行选项，则显示每个进程中所有线程的总和。 稍后，可以使用“ H”交互式命令来更改它。&lt;/li>
&lt;li>&lt;strong>-p &lt;!-- raw HTML omitted -->&lt;/strong> # 指定 PID 进程进行观察&lt;/li>
&lt;/ul>
&lt;p>EXAMPLE&lt;/p>
&lt;ul>
&lt;li>1 # 展开第三行的 CPU，显示每个逻辑 CPU 的状态信息&lt;/li>
&lt;li>b # 高亮显示处于 Running 状态的进程&lt;/li>
&lt;li>f # 管理所要展示的字段(i.e.第六行的内容)以及按照指定的字段排序。
&lt;ul>
&lt;li>按 ↑↓ 选择要操作的字段&lt;/li>
&lt;li>按空格表示显示或不显示当前字段&lt;/li>
&lt;li>按 → 选中当前行，然后按 ↑↓ 将选中的行移动，以便变更该字段所在位置&lt;/li>
&lt;li>按 ← 取消选中当前行&lt;/li>
&lt;li>按 s 选择光标所在的行作为 排序 标准&lt;/li>
&lt;li>按 q 退出当前编辑界面。i.e.再次显示 top 面板&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>R # 按照 f 命令里指定的字段进行排序，倒序或者顺序&lt;/li>
&lt;li>查看 744 进程及其线程的动态试图
&lt;ul>
&lt;li>top -p 744 -H&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h1 id="uptime显示系统运行了多长时间">uptime：显示系统运行了多长时间&lt;/h1>
&lt;h1 id="vmstat报告虚拟内存状态还有-io系统cpu-等信息">vmstat：报告虚拟内存状态，还有 io、系统、cpu 等信息&lt;/h1>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">[&lt;/span>root@ansible ~&lt;span style="color:#f92672">]&lt;/span>&lt;span style="color:#75715e"># vmstat -w&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>procs -----------------------memory---------------------- ---swap-- -----io---- -system-- --------cpu--------
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> r b swpd free buff cache si so bi bo in cs us sy id wa st
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ae81ff">0&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span> &lt;span style="color:#ae81ff">7282784&lt;/span> &lt;span style="color:#ae81ff">2148&lt;/span> &lt;span style="color:#ae81ff">463980&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span> &lt;span style="color:#ae81ff">8&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span> &lt;span style="color:#ae81ff">33&lt;/span> &lt;span style="color:#ae81ff">39&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span> &lt;span style="color:#ae81ff">100&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;strong>顶部字段说明：&lt;/strong>
procs&lt;/p>
&lt;ul>
&lt;li>r # 可运行的进程数(正在运行或等待运行)。即就绪队列的长度&lt;/li>
&lt;li>b # 等待 I/O 完成时阻塞(blocked)的进程数。即不可中断睡眠状态的进程数。&lt;/li>
&lt;/ul>
&lt;p>memory&lt;/p>
&lt;ul>
&lt;li>详见 内存管理。(单位是 KiB)&lt;/li>
&lt;/ul>
&lt;p>swap&lt;/p>
&lt;ul>
&lt;li>si # 每秒从 swap 到内存的大小。(单位是 KiB)&lt;/li>
&lt;li>so # 每秒从内存到 swap 的大小。(单位是 KiB)&lt;/li>
&lt;/ul>
&lt;p>io&lt;/p>
&lt;ul>
&lt;li>bi # 每秒从块设备接收的块数。即磁盘读取速度。&lt;/li>
&lt;li>bo # 每秒发送到块设备的块数。即磁盘写入速度。&lt;/li>
&lt;li>注意：bi 与 bo 的单位为&lt;code>块/秒&lt;/code>。因为 Linux 中块的大小是 1 KiB，所以这个单位也就等价于 KiB/s&lt;/li>
&lt;/ul>
&lt;p>system&lt;/p>
&lt;ul>
&lt;li>in # 每秒中断的次数。包括时钟的中断&lt;/li>
&lt;li>cs # 每秒上下文切换次数&lt;/li>
&lt;/ul>
&lt;p>cpu&lt;/p>
&lt;ul>
&lt;li>详见：CPU 使用率。(单位是百分比)&lt;/li>
&lt;/ul>
&lt;h2 id="syntax语法-3">Syntax(语法)&lt;/h2>
&lt;p>&lt;strong>vmstat [OTIONS] [DELAY [COUNT]]&lt;/strong>
DELAY # 延迟时间(单位是秒)。指定 DELAY 后，程序每隔 DELAY 时间运行一次。如果未指定 DELAY，则值输出一行结果，其中包含自 vmstat 启动到结束的平均值。&lt;/p>
&lt;ol>
&lt;li>**COUNT **# 每隔 DELAY 时间，程序运行的次数。若不指定则一直运行。&lt;/li>
&lt;/ol>
&lt;p>OPTIONS&lt;/p>
&lt;ol>
&lt;li>&lt;strong>-w&lt;/strong> # 格式化输出。如果不加 -w ,则输出非常紧凑，不利于人们观察，且每行最大 80 字符。&lt;/li>
&lt;/ol>
&lt;p>EXAMPLE&lt;/p>
&lt;ul>
&lt;li>每隔一秒输出一行信息，一共输出 5 次
&lt;ul>
&lt;li>vmstat 1 5&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h1 id="w--报告已经登录的用户和这些用户正在执行的命令">w # 报告已经登录的用户和这些用户正在执行的命令&lt;/h1>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>root@lichenhao:~# w
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> 09:22:37 up 22:46, &lt;span style="color:#ae81ff">1&lt;/span> user, load average: 0.00, 0.00, 0.00
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>USER TTY FROM LOGIN@ IDLE JCPU PCPU WHAT
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>root pts/0 172.19.42.203 09:06 0.00s 0.21s 0.01s w
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ul>
&lt;li>USER：用哪个用户登录的&lt;/li>
&lt;li>TTY：为该用户开启的终端名&lt;/li>
&lt;li>FROM：该登录用户从哪个 IP 登录的&lt;/li>
&lt;li>LOGIN@：用户登录的时间&lt;/li>
&lt;li>IDLE：用户登录&lt;/li>
&lt;li>WHAT：该用户当前正在执行的命令&lt;/li>
&lt;/ul>
&lt;p>获取到的用户信息中，TTY 的信息可以被 pkill 工具使用，以踢掉用户，让其下线&lt;/p>
&lt;h1 id="watch--定期执行程序在全部屏幕上显示输出结果">watch # 定期执行程序，在全部屏幕上显示输出结果&lt;/h1>
&lt;p>该工具就是持续执行同一个命令，并实时显示&lt;/p></description></item><item><title>Docs: psmisc 工具集</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/x.linux-%E7%AE%A1%E7%90%86/linux-%E7%B3%BB%E7%BB%9F%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/psmisc-%E5%B7%A5%E5%85%B7%E9%9B%86/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/x.linux-%E7%AE%A1%E7%90%86/linux-%E7%B3%BB%E7%BB%9F%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/psmisc-%E5%B7%A5%E5%85%B7%E9%9B%86/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：项目地址：&lt;a href="https://gitlab.com/psmisc/psmisc">https://gitlab.com/psmisc/psmisc&lt;/a>&lt;/p>
&lt;/blockquote>
&lt;p>psmisc 是一个小型的应用程序集合，与 procps-ng 工具集类似，都是使用伪文件系统(/proc)内的信息来展示系统信息&lt;/p>
&lt;p>该工具集包含包含以下程序(每个标题都是一个)&lt;/p>
&lt;h1 id="fuser--显示正在使用指定-文件-或-sockets-的进程">fuser # 显示正在使用指定 文件 或 sockets 的进程&lt;/h1>
&lt;p>fuser 使用指定的文件或文件系统显示进程的 PID。 在默认的显示模式下，每个文件名后都有一个字母，表示访问类型：&lt;/p>
&lt;ol>
&lt;li>c # 当前目录。&lt;/li>
&lt;li>e # 一个可执行文件正在运行。&lt;/li>
&lt;li>f # 打开文件。 在默认显示模式下省略 f。&lt;/li>
&lt;li>F # 打开文件进行写入。 默认显示模式下省略 F。&lt;/li>
&lt;li>r # 根目录。&lt;/li>
&lt;li>m # 映射文件或共享库。&lt;/li>
&lt;/ol>
&lt;h2 id="fuser-options">fuser [OPTIONS]&lt;/h2>
&lt;p>OPTIONS&lt;/p>
&lt;ul>
&lt;li>&lt;strong>-m&lt;/strong> # 显示使用命名文件系统或块设备的所有进程&lt;/li>
&lt;/ul>
&lt;h1 id="killall--通过进程名称向指定进程发送信号">killall # 通过进程名称向指定进程发送信号&lt;/h1>
&lt;p>与 kill 命令类似，但是不像 kill 只能指定进程的 PID，而是可以通过进程的名称来发送信号&lt;/p>
&lt;p>EXAMPLE：&lt;/p>
&lt;ol>
&lt;li>killall -0 nginx #向名为 nginx 的进程发送 0 信号&lt;/li>
&lt;/ol>
&lt;h1 id="peekfd--shows-the-data-travelling-over-a-file-descriptor">peekfd # shows the data travelling over a file descriptor&lt;/h1>
&lt;h1 id="prtstat--输出一个进程的统计信息">prtstat # 输出一个进程的统计信息&lt;/h1>
&lt;h1 id="pslog---prints-log-paths-of-a-process">pslog - prints log path(s) of a process&lt;/h1>
&lt;h1 id="pstree---以树状显示当前正在运行的进程">pstree - 以树状显示当前正在运行的进程&lt;/h1>
&lt;p>该命令与 ps 类似，但是不会像 ps -ef 一样显示内核态进程&lt;/p>
&lt;p>pstree [OPTIONS] [USER or PID]&lt;/p>
&lt;p>OPTIONS:&lt;/p>
&lt;ol>
&lt;li>-p #显示进程的 PID&lt;/li>
&lt;li>-a #显示进程运行的命令行参数&lt;/li>
&lt;li>-c #禁用相同分支的合并&lt;/li>
&lt;li>-h #高亮显示当前进程及其父进程&lt;/li>
&lt;li>-H PID #高亮显示指定进程&lt;/li>
&lt;li>-t #显示完整的进程名称&lt;/li>
&lt;li>-s #显示指定进程的父进程&lt;/li>
&lt;li>-n #按 PID 排序&lt;/li>
&lt;li>-g #显示 PGID。i.e 一个或多个进程组 ID&lt;/li>
&lt;/ol>
&lt;p>EXAPMLE:&lt;/p>
&lt;ol>
&lt;li>pstree -n #&lt;/li>
&lt;/ol>
&lt;p>以最简单的形式调用时没有任何选项或参数，&lt;code>pstree&lt;/code> 命令将显示所有正在运行的进程的分层树结构。&lt;/p>
&lt;pre>&lt;code>$ pstree
systemd─┬─VBoxService───7*[{VBoxService}]
├─accounts-daemon───2*[{accounts-daemon}]
├─2*[agetty]
├─atd
├─cron
├─dbus-daemon
├─irqbalance───{irqbalance}
├─2*[iscsid]
├─lvmetad
├─lxcfs───2*[{lxcfs}]
├─networkd-dispat───{networkd-dispat}
├─nginx───2*[nginx]
&lt;/code>&lt;/pre></description></item><item><title>Docs: strace 工具</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/x.linux-%E7%AE%A1%E7%90%86/linux-%E7%B3%BB%E7%BB%9F%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/strace-%E5%B7%A5%E5%85%B7/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/x.linux-%E7%AE%A1%E7%90%86/linux-%E7%B3%BB%E7%BB%9F%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/strace-%E5%B7%A5%E5%85%B7/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://man7.org/linux/man-pages/man1/strace.1.html">Manual(手册),strace(1)&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://github.com/strace/strace">GitHub 项目，strace/strace&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://strace.io/">官网&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>**strace **是一个用来跟踪 &lt;strong>system calls(系统调用)&lt;/strong> 和 &lt;strong>signals(信号)&lt;/strong> 的工具。&lt;/p>
&lt;p>在最简单的情况下，strace 会运行指定的命令，直到退出为止。 它截获并记录 &lt;strong>由进程调用的系统调用&lt;/strong> 和 &lt;strong>由进程接收的信号&lt;/strong>。 每个系统调用的名称，其参数及其返回值都会在 标准错误 或使用 -o 选项指定的文件上显示。&lt;/p>
&lt;p>strace 是有用的诊断，说明和调试工具。系统管理员，诊断人员和疑难解答人员将发现，对于不容易获取源代码的程序而言，这是无价的，因为它们无需重新编译即可跟踪它们。学生，黑客和过于好奇的人会发现，即使跟踪普通程序，也可以学到很多有关系统及其系统调用的知识。而且程序员会发现，由于系统调用和信号是在用户/内核界面上发生的事件，因此仔细检查此边界对于错误隔离，健全性检查和尝试捕获竞争状况非常有用。&lt;/p>
&lt;h2 id="strace-输出内容介绍">strace 输出内容介绍&lt;/h2>
&lt;h3 id="追踪到系统调用时输出的信息">追踪到系统调用时输出的信息&lt;/h3>
&lt;p>下面是一个最基本，最简单的追踪，strace 程序执行时，输出的每一行内容都是一个 syscall(系统调用)。基本格式如下：
&lt;code>**SyscallName(Parameter) = ReturnValue**&lt;/code>
假如我追踪 cat /dev/null 命令，则输出中有这么一段：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># 使用了 openat 这个系统调用，参数为 &amp;#34;/dev/null&amp;#34;,O_RDONLY，返回值为 3&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>openat&lt;span style="color:#f92672">(&lt;/span>AT_FDCWD, &lt;span style="color:#e6db74">&amp;#34;/dev/null&amp;#34;&lt;/span>, O_RDONLY&lt;span style="color:#f92672">)&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">3&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>如果命令出现错误，通常 ReturenVale 为 -1，并附加 errno 符号和错误信息&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>openat&lt;span style="color:#f92672">(&lt;/span>AT_FDCWD, &lt;span style="color:#e6db74">&amp;#34;123&amp;#34;&lt;/span>, O_RDONLY&lt;span style="color:#f92672">)&lt;/span> &lt;span style="color:#f92672">=&lt;/span> -1 ENOENT &lt;span style="color:#f92672">(&lt;/span>No such file or directory&lt;span style="color:#f92672">)&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="追踪到信号时输出的信息">追踪到信号时输出的信息&lt;/h3>
&lt;p>如果追踪到信号，则输出内容的基本格式如下：
&lt;code>--- SignalName{si_signo=SignalName, si_code=SI_USER, si_pid=PID, ...} ---&lt;/code>
假如我同时最总两个进程，并像其中一个进程发送了 SIGTERM 信号，则输出中有这么一段：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">[&lt;/span>pid 5314&lt;span style="color:#f92672">]&lt;/span> --- SIGTERM &lt;span style="color:#f92672">{&lt;/span>si_signo&lt;span style="color:#f92672">=&lt;/span>SIGTERM, si_code&lt;span style="color:#f92672">=&lt;/span>SI_USER, si_pid&lt;span style="color:#f92672">=&lt;/span>27467, si_uid&lt;span style="color:#f92672">=&lt;/span>0&lt;span style="color:#f92672">}&lt;/span> ---
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h1 id="starce-语法">starce 语法&lt;/h1>
&lt;p>strace [-ACdffhikqrtttTvVxxy] [-I n] [-b execve] [-e expr]&amp;hellip; [-a column] [-o file] [-s strsize] [-X format] [-P path]&amp;hellip; [-p pid]&amp;hellip; { -p pid | [-D] [-E var[=val]]&amp;hellip; [-u username] COMMAND [args] }&lt;/p>
&lt;p>strace -c [-df] [-I n] [-b execve] [-e expr]&amp;hellip; [-O overhead] [-S sortby] [-P path]&amp;hellip; [-p pid]&amp;hellip; { -p pid | [-D] [-E var[=val]]&amp;hellip; [-u username] COMMAND [args] }&lt;/p>
&lt;h2 id="options">OPTIONS&lt;/h2>
&lt;h3 id="general-通用选项">General 通用选项&lt;/h3>
&lt;p>&lt;strong>-e EXPR&lt;/strong> # 用来指定要追踪的事件以及如何追踪。
EXPR(表达式) 的格式为 &lt;code>QUALIFIER=[!]VALUE[,VALUE...]&lt;/code>&lt;/p>
&lt;ul>
&lt;li>&lt;strong>QUALIFIER(限定词)&lt;/strong> # 可用的限定词有 trace、abbrev、verbose、raw、signal、read、write、fault、inject、status、quiet、decode-fds、kvm。&lt;code>默认值：trace&lt;/code>。&lt;/li>
&lt;li>&lt;strong>VALUE&lt;/strong> # 是与 qualifier 相关的字符串或数字。&lt;/li>
&lt;/ul>
&lt;p>Note：&lt;/p>
&lt;ul>
&lt;li>由于 QUALIFIER 的默认值为 trace。所以 -e trace=sendto,read 也可以写成 -e sendto,read。&lt;/li>
&lt;li>QUALIFIER 限定词根据功能不通，在 filtering、tampering、Output format 等选项中，有具体的使用说明。&lt;/li>
&lt;li>使用 &lt;code>!&lt;/code> 会否定该组值。比如，-e trace=open 表示仅追踪 open 系统调用；而 -e trace=&amp;rsquo;!open&amp;rsquo; 表示追踪除了 open 以外的所有系统调用
&lt;ul>
&lt;li>注意加单引号，否则无法识别，并报错提示：&lt;code>-bash: !XXXX: event not found&lt;/code>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h3 id="startup-启动选项">Startup 启动选项&lt;/h3>
&lt;ul>
&lt;li>&lt;strong>-p PID&lt;/strong> # 追踪指定 PID 的进程的系统调用。&lt;/li>
&lt;/ul>
&lt;h3 id="tracing-跟踪选项">Tracing 跟踪选项&lt;/h3>
&lt;ul>
&lt;li>&lt;strong>-f&lt;/strong> # 跟踪子进程，并显示 PID 号。些子进程是由 fork(2)，vfork(2) 和 clone(2) 系统调用而由当前跟踪的进程创建的。&lt;/li>
&lt;/ul>
&lt;h3 id="filtering-过滤选项">Filtering 过滤选项&lt;/h3>
&lt;ul>
&lt;li>&lt;strong>-e trace=SYSCALL_SET&lt;/strong> # 指定要追踪的系统调用。
&lt;ul>
&lt;li>可用的 SYSCALL_SET 有如下这些
&lt;ul>
&lt;li>**SYSCALL1[,SYSCALL2,&amp;hellip;] **# 直接指定系统调用的名称，多个名称以逗号分隔。&lt;/li>
&lt;li>&lt;strong>/REGEX&lt;/strong> # 前面加上 &lt;code>/&lt;/code> ，后面可以使用正则表达式进行匹配，来匹配系统调用的名称。&lt;/li>
&lt;li>&lt;strong>%SyscallSet&lt;/strong> # 前面加上 &lt;code>%&lt;/code>，就会追踪一类系统调用的集合。比如：
&lt;ul>
&lt;li>%clock    Trace all system calls that read or modify system clocks.&lt;/li>
&lt;li>%creds    Trace all system calls that read or modify user and group identifiers or capability sets.&lt;/li>
&lt;li>%desc     Trace all file descriptor related system calls.&lt;/li>
&lt;li>&lt;strong>%file&lt;/strong> # 追踪所有以文件名为参数的系统调用。可以看作是 -e trace=open,stat,chmod,unlink,&amp;hellip;.. 的简写。&lt;/li>
&lt;li>%fstat    Trace fstat and fstatat syscall variants.&lt;/li>
&lt;li>%fstatfs  Trace fstatfs, fstatfs64, fstatvfs, osf_fstatfs, and osf_fstatfs64 system calls.&lt;/li>
&lt;li>%ipc      Trace all IPC related system calls.&lt;/li>
&lt;li>%lstat    Trace lstat syscall variants.&lt;/li>
&lt;li>%memory   Trace all memory mapping related system calls.&lt;/li>
&lt;li>%network  Trace all the network related system calls.&lt;/li>
&lt;li>%process  Trace all system calls which involve process management.&lt;/li>
&lt;li>%pure     Trace syscalls that always succeed and have no arguments.&lt;/li>
&lt;li>**%signal **# 追踪所有与信号相关的系统调用。&lt;/li>
&lt;li>%stat     Trace stat syscall variants.&lt;/li>
&lt;li>%statfs   Trace statfs, statfs64, statvfs, osf_statfs, and osf_statfs64 system calls.&lt;/li>
&lt;li>%%stat    Trace syscalls used for requesting file status.&lt;/li>
&lt;li>%%statfs  Trace syscalls related to file system statistic&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&amp;hellip;&amp;hellip;..等等&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>-e signal=SIGNAL_SET&lt;/strong> # 指定要追踪的信号。&lt;/li>
&lt;li>&lt;strong>-e status=STATUS_SET&lt;/strong> # 指定要追踪的系统调用的返回码&lt;/li>
&lt;/ul>
&lt;h3 id="output-format-输出格式选项">Output format 输出格式选项&lt;/h3>
&lt;ul>
&lt;li>&lt;strong>-a COLUMN&lt;/strong> # 设定列的间隔为 COLUMN，默认为 40。i.e. &lt;code>=&lt;/code> 与前面的间隔&lt;/li>
&lt;li>**-o, &amp;ndash;output &lt;!-- raw HTML omitted --> **# 将追踪结果输出到文件中(默认标准错误)。
&lt;ul>
&lt;li>与 -ff 参数一起使用时，会把每个线程的追踪写到单独的文件中，以 FileName.PID 格式命名。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>-s, &amp;ndash;string-limit &lt;!-- raw HTML omitted -->&lt;/strong> # 设定要输出的最大字符串长度为 STRSIZE。&lt;code>默认值：32&lt;/code>。Note:文件名不作为字符串，并始终完整打印。
&lt;ul>
&lt;li>示例如下，在 sendto 和 read 系统调用中，参数只显示了 32 个字符。当指定 -s 选项后，可以输出更多字符。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">[&lt;/span>root@dr-02 keepalived&lt;span style="color:#f92672">]&lt;/span>&lt;span style="color:#75715e"># strace -p 22863 -e trace=sendto,read&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>sendto&lt;span style="color:#f92672">(&lt;/span>6, &lt;span style="color:#e6db74">&amp;#34;GET / HTTP/1.0\r\nUser-Agent: Keep&amp;#34;&lt;/span>..., 71, 0, NULL, 0&lt;span style="color:#f92672">)&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">71&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>read&lt;span style="color:#f92672">(&lt;/span>6, &lt;span style="color:#e6db74">&amp;#34;HTTP/1.1 426 Upgrade Required\r\nd&amp;#34;&lt;/span>..., 4096&lt;span style="color:#f92672">)&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">129&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">[&lt;/span>root@dr-02 keepalived&lt;span style="color:#f92672">]&lt;/span>&lt;span style="color:#75715e"># strace -p 22863 -s 1000 -e trace=sendto,read&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>strace: Process &lt;span style="color:#ae81ff">22863&lt;/span> attached
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>sendto&lt;span style="color:#f92672">(&lt;/span>7, &lt;span style="color:#e6db74">&amp;#34;GET / HTTP/1.0\r\nUser-Agent: KeepAliveClient\r\nHost: 10.0.9.213:50080\r\n\r\n&amp;#34;&lt;/span>, 71, 0, NULL, 0&lt;span style="color:#f92672">)&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">71&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>read&lt;span style="color:#f92672">(&lt;/span>7, &lt;span style="color:#e6db74">&amp;#34;HTTP/1.1 426 Upgrade Required\r\ndate: Fri, 24 Jul 2020 07:53:01 GMT\r\nserver: istio-envoy\r\nconnection: close\r\ncontent-length: 0\r\n\r\n&amp;#34;&lt;/span>, 4096&lt;span style="color:#f92672">)&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">129&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ul>
&lt;li>&lt;strong>-t, -tt, -ttt&lt;/strong> # 显示追踪时间(在输出的行开头显示)。2 个 t 显示微秒，3 个 t 显示时间戳&lt;/li>
&lt;li>&lt;strong>-T&lt;/strong> # 显示追踪花费的时间(在输出的行末尾显示)&lt;/li>
&lt;li>&lt;strong>-y, -yy&lt;/strong> # 打印与文件描述符参数相关联的路径。2 个 y，打印与套接字文件描述符相关的特定协议信息，以及与设备文件描述符相关的块/字符设备号。&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># 这是一个建立 http 连接的系统调用追踪&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># 不加 -y，只显示数字 3，表示当前文件描述符的编号为3&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">[&lt;/span>pid 8675&lt;span style="color:#f92672">]&lt;/span> write&lt;span style="color:#f92672">(&lt;/span>3, &lt;span style="color:#e6db74">&amp;#34;POST /api/v1/auth/tokens:login HTTP/1.1\r\nHost: 10.20.5.98:8056\r\nUser-Agent: Go-http-client/1.1\r\nContent-Length: 44\r\nContent-Type: application/json\r\nAccept-Encoding: gzip\r\n\r\n{\&amp;#34;auth\&amp;#34;:{\&amp;#34;name\&amp;#34;:\&amp;#34;admin\&amp;#34;,\&amp;#34;password\&amp;#34;:\&amp;#34;admin\&amp;#34;}}&amp;#34;&lt;/span>, 217&lt;span style="color:#f92672">)&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">217&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># 使用 -y 参数，显示编号为3的文件描述符的路径&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">[&lt;/span>pid 8667&lt;span style="color:#f92672">]&lt;/span> write&lt;span style="color:#f92672">(&lt;/span>3&amp;lt;socket:&lt;span style="color:#f92672">[&lt;/span>80219&lt;span style="color:#f92672">]&lt;/span>&amp;gt;, &lt;span style="color:#e6db74">&amp;#34;POST /api/v1/auth/tokens:login HTTP/1.1\r\nHost: 10.20.5.98:8056\r\nUser-Agent: Go-http-client/1.1\r\nContent-Length: 44\r\nContent-Type: application/json\r\nAccept-Encoding: gzip\r\n\r\n{\&amp;#34;auth\&amp;#34;:{\&amp;#34;name\&amp;#34;:\&amp;#34;admin\&amp;#34;,\&amp;#34;password\&amp;#34;:\&amp;#34;admin\&amp;#34;}}&amp;#34;&lt;/span>, 217&lt;span style="color:#f92672">)&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">217&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># 使用 -yy 参数，显示3号文件描述符的Socket的具体信息(源和目的地址)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">[&lt;/span>pid 8623&lt;span style="color:#f92672">]&lt;/span> write&lt;span style="color:#f92672">(&lt;/span>3&amp;lt;TCP:&lt;span style="color:#f92672">[&lt;/span>172.38.40.250:27436-&amp;gt;10.20.5.98:8056&lt;span style="color:#f92672">]&lt;/span>&amp;gt;, &lt;span style="color:#e6db74">&amp;#34;POST /api/v1/auth/tokens:login HTTP/1.1\r\nHost: 10.20.5.98:8056\r\nUser-Agent: Go-http-client/1.1\r\nContent-Length: 44\r\nContent-Type: application/json\r\nAccept-Encoding: gzip\r\n\r\n{\&amp;#34;auth\&amp;#34;:{\&amp;#34;name\&amp;#34;:\&amp;#34;admin\&amp;#34;,\&amp;#34;password\&amp;#34;:\&amp;#34;admin\&amp;#34;}}&amp;#34;&lt;/span>, 217&lt;span style="color:#f92672">)&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">217&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># 查看一下这个进程的3号文件描述符&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">[&lt;/span>root@ansible fd&lt;span style="color:#f92672">]&lt;/span>&lt;span style="color:#75715e"># ll /proc/8685/fd/3&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>lrwx------ &lt;span style="color:#ae81ff">1&lt;/span> root root &lt;span style="color:#ae81ff">64&lt;/span> Jan &lt;span style="color:#ae81ff">24&lt;/span> 10:55 /proc/8675/fd/3 -&amp;gt; &lt;span style="color:#e6db74">&amp;#39;socket:[80219]&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">[&lt;/span>root@ansible fdinfo&lt;span style="color:#f92672">]&lt;/span>&lt;span style="color:#75715e"># cat /proc/net/tcp&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># 从这里查看socket号为80219的连接信息，16进制转换过去就是 172.38.40.250:27436 与 10.20.5.98:8056&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="statistics-统计选项">Statistics 统计选项&lt;/h3>
&lt;ul>
&lt;li>&lt;strong>-c&lt;/strong> # 统计每一次系统调用的执行时间、次数、错误次数。输出效果如下：
&lt;ul>
&lt;li>-c 参数常用来在排障之前，查看当前进程使用了哪些系统调用，然后在后续排障中单独追踪指定的系统调用&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">[&lt;/span>root@dr-02 keepalived&lt;span style="color:#f92672">]&lt;/span>&lt;span style="color:#75715e"># strace -p 22863 -c&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>strace: Process &lt;span style="color:#ae81ff">22863&lt;/span> attached
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>% time seconds usecs/call calls errors syscall
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>------ ----------- ----------- --------- --------- ----------------
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> 39.04 0.002437 &lt;span style="color:#ae81ff">32&lt;/span> &lt;span style="color:#ae81ff">76&lt;/span> &lt;span style="color:#66d9ef">select&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> 16.42 0.001025 &lt;span style="color:#ae81ff">6&lt;/span> &lt;span style="color:#ae81ff">147&lt;/span> fcntl
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> 14.48 0.000904 &lt;span style="color:#ae81ff">69&lt;/span> &lt;span style="color:#ae81ff">13&lt;/span> &lt;span style="color:#ae81ff">13&lt;/span> connect
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> 9.55 0.000596 &lt;span style="color:#ae81ff">59&lt;/span> &lt;span style="color:#ae81ff">10&lt;/span> close
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> 7.59 0.000474 &lt;span style="color:#ae81ff">36&lt;/span> &lt;span style="color:#ae81ff">13&lt;/span> sendto
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> 4.37 0.000273 &lt;span style="color:#ae81ff">11&lt;/span> &lt;span style="color:#ae81ff">23&lt;/span> read
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> 3.57 0.000223 &lt;span style="color:#ae81ff">8&lt;/span> &lt;span style="color:#ae81ff">26&lt;/span> getsockopt
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> 3.22 0.000201 &lt;span style="color:#ae81ff">15&lt;/span> &lt;span style="color:#ae81ff">13&lt;/span> socket
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> 1.75 0.000109 &lt;span style="color:#ae81ff">8&lt;/span> &lt;span style="color:#ae81ff">13&lt;/span> setsockopt
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>------ ----------- ----------- --------- --------- ----------------
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>100.00 0.006242 &lt;span style="color:#ae81ff">334&lt;/span> &lt;span style="color:#ae81ff">13&lt;/span> total
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ul>
&lt;li>&lt;strong>-o FILE&lt;/strong> #将追踪的输出写入 FILE。 如果提供了-ff 选项，则使用 filename.pid 格式。 如果参数以“ |”开头 或“！”，则将其余参数视为命令，并将所有输出通过管道传递给它。 这对于将调试输出管道传输到程序而不影响已执行程序的重定向非常方便。 后者当前与 -ff 选项不兼容。&lt;/li>
&lt;/ul>
&lt;h3 id="tampering-干预选项">Tampering 干预选项&lt;/h3>
&lt;ul>
&lt;li>**-e inject=SYSCALL_SET **#&lt;/li>
&lt;/ul>
&lt;h3 id="miscellaneous-选项">Miscellaneous 选项&lt;/h3>
&lt;h1 id="应用示例">应用示例&lt;/h1>
&lt;ul>
&lt;li>追踪 ls 命令的系统调用情况。
&lt;ul>
&lt;li>&lt;strong>starce ls&lt;/strong>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>统计 df 命令的系统调用信息。
&lt;ul>
&lt;li>&lt;strong>strace -c df&lt;/strong>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>追踪 22863 进程的系统调用，只追踪网络与 read 相关的系统调用。输出更多信息，扩大输出字符串到 1000。
&lt;ul>
&lt;li>&lt;strong>strace -p 22863 -s 1000 -e trace=%network,read&lt;/strong>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>追踪新编译的 main 程序，显示时间、追踪线程、扩大输出字符、追踪 write()、追踪 SIGHUP 信号
&lt;ul>
&lt;li>&lt;strong>strace -t -f -s 1000 -e trace=write -e signal=&amp;lsquo;SIGHUP&amp;rsquo; ./main &amp;ndash;xsky-pass=admin&lt;/strong>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>分析进程 I/O 情况&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>追踪 1234 进程及其子进程，去掉所有字符串，在末尾显示花费的时间，将结果保存到 strace.file 文件中
&lt;ul>
&lt;li>&lt;strong>strace -T -s 0 -f -p 1234 -o strace.file&lt;/strong>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>文件中的内容如下&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">[&lt;/span>root@dengrui test_dir&lt;span style="color:#f92672">]&lt;/span>&lt;span style="color:#75715e"># cat strace.file&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">31090&lt;/span> pread64&lt;span style="color:#f92672">(&lt;/span>227, &lt;span style="color:#e6db74">&amp;#34;&amp;#34;&lt;/span>..., 16384, 81920&lt;span style="color:#f92672">)&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">16384&lt;/span> &amp;lt;0.000991&amp;gt;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">31090&lt;/span> pread64&lt;span style="color:#f92672">(&lt;/span>227, &lt;span style="color:#e6db74">&amp;#34;&amp;#34;&lt;/span>..., 16384, 65536&lt;span style="color:#f92672">)&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">16384&lt;/span> &amp;lt;0.001292&amp;gt;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">31090&lt;/span> pread64&lt;span style="color:#f92672">(&lt;/span>227, &lt;span style="color:#e6db74">&amp;#34;&amp;#34;&lt;/span>..., 16384, 98304&lt;span style="color:#f92672">)&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">16384&lt;/span> &amp;lt;0.000176&amp;gt;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">31090&lt;/span> pread64&lt;span style="color:#f92672">(&lt;/span>129, &lt;span style="color:#e6db74">&amp;#34;&amp;#34;&lt;/span>..., 16384, 131072&lt;span style="color:#f92672">)&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">16384&lt;/span> &amp;lt;0.002121&amp;gt;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">31090&lt;/span> pread64&lt;span style="color:#f92672">(&lt;/span>129, &lt;span style="color:#e6db74">&amp;#34;&amp;#34;&lt;/span>..., 16384, 16384&lt;span style="color:#f92672">)&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">16384&lt;/span> &amp;lt;0.000932&amp;gt;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">31090&lt;/span> pread64&lt;span style="color:#f92672">(&lt;/span>128, &lt;span style="color:#e6db74">&amp;#34;&amp;#34;&lt;/span>..., 16384, 49152&lt;span style="color:#f92672">)&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">16384&lt;/span> &amp;lt;0.001072&amp;gt;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">31090&lt;/span> pread64&lt;span style="color:#f92672">(&lt;/span>128, &lt;span style="color:#e6db74">&amp;#34;&amp;#34;&lt;/span>..., 16384, 16384&lt;span style="color:#f92672">)&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">16384&lt;/span> &amp;lt;0.000820&amp;gt;
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ul>
&lt;li>通过 awk 命令，聚合系统调用中的第三个参数，即可得出来追踪这一段时间，这个程序从磁盘中读取了多少数据&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>awk -F, &lt;span style="color:#e6db74">&amp;#39;{print $3}&amp;#39;&lt;/span> test.file | awk &lt;span style="color:#e6db74">&amp;#39;{sum += $1} END {print sum}&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div></description></item><item><title>Docs: sysstat 工具集</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/x.linux-%E7%AE%A1%E7%90%86/linux-%E7%B3%BB%E7%BB%9F%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/sysstat-%E5%B7%A5%E5%85%B7%E9%9B%86/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/x.linux-%E7%AE%A1%E7%90%86/linux-%E7%B3%BB%E7%BB%9F%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/sysstat-%E5%B7%A5%E5%85%B7%E9%9B%86/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://github.com/sysstat/sysstat">GitHub 项目&lt;/a>&lt;/li>
&lt;li>&lt;a href="http://sebastien.godard.pagesperso-orange.fr/">官网&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://man7.org/linux/man-pages/man1/pidstat.1.html">Manual(手册),pidstat(1)&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://man7.org/linux/man-pages/man1/sar.1.html">Manual(手册),sar(1)&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>sysstat 包包含很多类 UNIX 的应用程序，用以监控系统性能和使用活动。&lt;/p>
&lt;h1 id="cifsiostat">cifsiostat&lt;/h1>
&lt;h1 id="iostat--报告设备和分区的-io-统计数据">iostat # 报告设备和分区的 I/O 统计数据&lt;/h1>
&lt;p>iostat 命令用于通过观察设备活动的时间及其平均传输速率来监视系统 I/O 设备的负载。 iostat 命令生成可用于更改系统配置的报告，以更好地平衡物理磁盘之间的输入/输出负载。&lt;/p>
&lt;p>iostat 命令生成两种类型的报告，即 CPU 利用率报告和设备利用率报告。&lt;/p>
&lt;p>CPU 利用率报告&lt;/p>
&lt;p>Device 利用率报告&lt;/p>
&lt;pre>&lt;code>[root@ansible ~]# iostat -xd
Linux 4.18.0-193.19.1.el8_2.x86_64 (ansible.tj-test) 11/24/2020 _x86_64_ (4 CPU)
Device r/s w/s rkB/s wkB/s rrqm/s wrqm/s %rrqm %wrqm r_await w_await aqu-sz rareq-sz wareq-sz svctm %util
sda 0.04 0.17 1.56 11.25 0.00 0.26 0.19 60.08 10.57 54.93 0.01 40.14 65.48 0.97 0.02
scd0 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 6.41 0.00 0.00 38.52 0.00 1.00 0.00
dm-0 0.04 0.43 1.51 11.25 0.00 0.00 0.00 0.00 9.71 108.32 0.05 40.01 26.33 0.44 0.02
dm-1 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 1.69 0.00 0.00 21.57 0.00 0.39 0.00
&lt;/code>&lt;/pre>
&lt;ul>
&lt;li>%util # 向设备发出 I/O 请求所占时间的百分比(设备的带宽利用率)。其实就是磁盘 I/O 使用率&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/bremrf/1616164910414-5cadf78b-954f-4409-8dfc-e7f9f5b950b3.png" alt="">&lt;/p>
&lt;h1 id="iostat--显示-io-状态信息">iostat # 显示 I/O 状态信息&lt;/h1>
&lt;p>&lt;strong>iostat [OPTIONS] [INTERVAL [COUNT]]&lt;/strong>
INTERVAL # 间隔时间，单位是秒，指定 INTERVAL 时，mpstat 根据该时间每隔 INTERVAL 秒输出一次信息，并在最后输出平均值。&lt;/p>
&lt;ul>
&lt;li>COUNT # 每隔 INTERVAL 时间，输出信息的数量。若不指定 CONUNT，则 mpstat 会根据间隔时间持续输出统计信息。&lt;/li>
&lt;/ul>
&lt;p>OPTIONS&lt;/p>
&lt;ul>
&lt;li>&lt;strong>-c&lt;/strong> # 只显示 CPU 利用率报告&lt;/li>
&lt;li>&lt;strong>-d&lt;/strong> # 只显示磁盘利用率报告&lt;/li>
&lt;li>**-x **# 显示扩展信息。输出更多的统计信息&lt;/li>
&lt;/ul>
&lt;p>EXAMPLE&lt;/p>
&lt;h1 id="mpstat--显示处理器相关的统计信息">mpstat # 显示处理器相关的统计信息&lt;/h1>
&lt;p>&lt;strong>mpstat [OPTIONS] [INTERVAL [COUNT]]&lt;/strong>
INTERVAL # 间隔时间，单位是秒。指定 INTERVAL 时，mpstat 根据该时间每隔 INTERVAL 秒输出一次信息，并在最后输出平均值。&lt;/p>
&lt;ul>
&lt;li>COUNT # 每隔 INTERVAL 时间，输出信息的数量。若不指定 CONUNT，则 mpstat 会根据间隔时间持续输出统计信息。&lt;/li>
&lt;/ul>
&lt;p>OPTIONS&lt;/p>
&lt;ul>
&lt;li>&lt;strong>-A&lt;/strong> # 此选项等效于 -u -I ALL -P ALL&lt;/li>
&lt;li>&lt;strong>-P&lt;/strong> **&amp;lt;CPU[,CPU2&amp;hellip;.]&amp;gt; **# 指定要监控的 CPU，ALL 为监控所有 CPU&lt;/li>
&lt;/ul>
&lt;p>EXAMPLE&lt;/p>
&lt;ul>
&lt;li>显示所有 CPU 的统计信息。每隔 5 秒输出 1 次信息，总共输出 2 次。
&lt;ul>
&lt;li>**mpstat -P ALL 5 2 **&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h1 id="nfsiostat-sysstat">nfsiostat-sysstat&lt;/h1>
&lt;h1 id="pidstat--显示-linux-进程的统计信息">pidstat # 显示 Linux 进程的统计信息&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;a href="https://man.cx/pidstat">man 手册&lt;/a>&lt;/p>
&lt;/blockquote>
&lt;p>pidstat 是一个以 Task(任务) 为主体，显示 Task 相关系统使用情况的工具。&lt;/p>
&lt;blockquote>
&lt;p>Task(任务) 是 进程、线程 之类的统称。&lt;/p>
&lt;/blockquote>
&lt;p>根据命令的不同选项，显示进程的不同信息。&lt;/p>
&lt;h2 id="-d--报告-io-统计信息">-d # 报告 I/O 统计信息&lt;/h2>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">[&lt;/span>lichenhao@hw-cloud-xngy-jump-server-linux-2 ~&lt;span style="color:#f92672">]&lt;/span>$ pidstat -d &lt;span style="color:#ae81ff">1&lt;/span> --human
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Linux 5.4.0-88-generic &lt;span style="color:#f92672">(&lt;/span>hw-cloud-xngy-jump-server-linux-2&lt;span style="color:#f92672">)&lt;/span> 10/03/2021 _x86_64_ &lt;span style="color:#f92672">(&lt;/span>&lt;span style="color:#ae81ff">2&lt;/span> CPU&lt;span style="color:#f92672">)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>10:27:48 PM UID PID kB_rd/s kB_wr/s kB_ccwr/s iodelay Command
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>10:27:49 PM UID PID kB_rd/s kB_wr/s kB_ccwr/s iodelay Command
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>10:27:50 PM &lt;span style="color:#ae81ff">1000&lt;/span> &lt;span style="color:#ae81ff">16829&lt;/span> 0.0B 4.0k 0.0B &lt;span style="color:#ae81ff">0&lt;/span> bash
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>10:27:50 PM UID PID kB_rd/s kB_wr/s kB_ccwr/s iodelay Command
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>^C
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Average: UID PID kB_rd/s kB_wr/s kB_ccwr/s iodelay Command
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Average: &lt;span style="color:#ae81ff">1000&lt;/span> &lt;span style="color:#ae81ff">16829&lt;/span> 0.0B 1.3k 0.0B &lt;span style="color:#ae81ff">0&lt;/span> bash
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="-u--默认选项报告进程的-cpu-利用率">-u # 默认选项。报告进程的 CPU 利用率&lt;/h2>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">[&lt;/span>root@ansible ~&lt;span style="color:#f92672">]&lt;/span>&lt;span style="color:#75715e"># pidstat&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Linux 4.18.0-193.19.1.el8_2.x86_64 &lt;span style="color:#f92672">(&lt;/span>ansible.tj-test&lt;span style="color:#f92672">)&lt;/span> 10/27/2020 _x86_64_ &lt;span style="color:#f92672">(&lt;/span>&lt;span style="color:#ae81ff">4&lt;/span> CPU&lt;span style="color:#f92672">)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>09:51:15 PM UID PID %usr %system %guest %wait %CPU CPU Command
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>09:51:15 PM &lt;span style="color:#ae81ff">0&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span> 0.00 0.01 0.00 0.00 0.02 &lt;span style="color:#ae81ff">1&lt;/span> systemd
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>09:51:15 PM &lt;span style="color:#ae81ff">0&lt;/span> &lt;span style="color:#ae81ff">2&lt;/span> 0.00 0.00 0.00 0.00 0.00 &lt;span style="color:#ae81ff">0&lt;/span> kthreadd
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="-w--报告进程的上下文切换情况">-w # 报告进程的上下文切换情况&lt;/h2>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">[&lt;/span>root@ansible ~&lt;span style="color:#f92672">]&lt;/span>&lt;span style="color:#75715e"># pidstat -w&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Linux 4.18.0-193.19.1.el8_2.x86_64 &lt;span style="color:#f92672">(&lt;/span>ansible.tj-test&lt;span style="color:#f92672">)&lt;/span> 10/27/2020 _x86_64_ &lt;span style="color:#f92672">(&lt;/span>&lt;span style="color:#ae81ff">4&lt;/span> CPU&lt;span style="color:#f92672">)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>10:00:14 PM UID PID cswch/s nvcswch/s Command
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>10:00:14 PM &lt;span style="color:#ae81ff">0&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span> 0.11 0.03 systemd
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>10:00:14 PM &lt;span style="color:#ae81ff">0&lt;/span> &lt;span style="color:#ae81ff">2&lt;/span> 0.02 0.00 kthreadd
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ul>
&lt;li>**cswch/s **# 每秒自愿上下文切换(voluntary context switches)的次数&lt;/li>
&lt;li>&lt;strong>nvcswch&lt;/strong> # 每秒非自愿上下文切换(non voluntary context switches)的次数&lt;/li>
&lt;/ul>
&lt;h2 id="-r--报告进程的内存使用情况统计信息">-r # 报告进程的内存使用情况统计信息&lt;/h2>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">[&lt;/span>root@lichenhao ~&lt;span style="color:#f92672">]&lt;/span>&lt;span style="color:#75715e"># pidstat -r&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Linux 4.18.0-193.28.1.el8_2.x86_64 &lt;span style="color:#f92672">(&lt;/span>lichenhao.bj-net&lt;span style="color:#f92672">)&lt;/span> 11/18/2020 _x86_64_ &lt;span style="color:#f92672">(&lt;/span>&lt;span style="color:#ae81ff">2&lt;/span> CPU&lt;span style="color:#f92672">)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>09:58:16 PM UID PID minflt/s majflt/s VSZ RSS %MEM Command
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>09:58:16 PM &lt;span style="color:#ae81ff">0&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span> 5.57 0.05 &lt;span style="color:#ae81ff">176812&lt;/span> &lt;span style="color:#ae81ff">10844&lt;/span> 0.28 systemd
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>09:58:16 PM &lt;span style="color:#ae81ff">0&lt;/span> &lt;span style="color:#ae81ff">664&lt;/span> 0.43 0.00 &lt;span style="color:#ae81ff">91980&lt;/span> &lt;span style="color:#ae81ff">8980&lt;/span> 0.23 systemd-journal
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ul>
&lt;li>&lt;strong>minflt/s&lt;/strong> #每秒任务执行的次要故障总数，即不需要从磁盘加载内存页面的次要故障总数。&lt;/li>
&lt;li>&lt;strong>majflt/s&lt;/strong> # 每秒任务执行的主要故障总数，即需要从磁盘加载内存页面的主要故障总数。&lt;/li>
&lt;li>&lt;strong>VSZ&lt;/strong> # Virtual Size(虚拟大小)。整个任务的虚拟内存使用量，以千字节为单位。&lt;/li>
&lt;li>&lt;strong>RSS&lt;/strong> # Resident Set Size(常驻集大小)。任务使用的未交换的物理内存，以千字节为单位。&lt;/li>
&lt;/ul>
&lt;h2 id="-d--报告进程的磁盘-io-统计信息">-d # 报告进程的磁盘 I/O 统计信息&lt;/h2>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">[&lt;/span>root@lichenhao ~&lt;span style="color:#f92672">]&lt;/span>&lt;span style="color:#75715e"># pidstat -d&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Linux 4.18.0-193.28.1.el8_2.x86_64 &lt;span style="color:#f92672">(&lt;/span>lichenhao.bj-net&lt;span style="color:#f92672">)&lt;/span> 11/18/2020 _x86_64_ &lt;span style="color:#f92672">(&lt;/span>&lt;span style="color:#ae81ff">2&lt;/span> CPU&lt;span style="color:#f92672">)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>09:58:37 PM UID PID kB_rd/s kB_wr/s kB_ccwr/s iodelay Command
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>09:58:37 PM &lt;span style="color:#ae81ff">0&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span> 56.46 0.18 0.01 &lt;span style="color:#ae81ff">33&lt;/span> systemd
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>09:58:37 PM &lt;span style="color:#ae81ff">0&lt;/span> &lt;span style="color:#ae81ff">7&lt;/span> 0.18 0.00 0.00 &lt;span style="color:#ae81ff">0&lt;/span> kworker/u4:0-events_unbound
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="syntax语法">Syntax(语法)&lt;/h2>
&lt;p>&lt;strong>pidstat [OPTIONS] [INTERVAL [COUNT]]&lt;/strong>
INTERVAL 是间隔时间，单位是秒，指定 INTERVAL 时，mpstat 根据该时间每隔 INTERVAL 秒输出一次信息，并在最后输出平均值。&lt;/p>
&lt;ul>
&lt;li>&lt;strong>COUNT&lt;/strong> # 每隔 INTERVAL 时间，输出信息的数量。若不指定 CONUNT，则 mpstat 会根据间隔时间持续输出统计信息。&lt;/li>
&lt;/ul>
&lt;p>OPTIONS&lt;/p>
&lt;ol>
&lt;li>&lt;strong>-C STRING&lt;/strong> # 仅显示 Task 名称包含 STRING 的任务。该字符串可以是正则表达式。就是根据进程名过滤。&lt;/li>
&lt;li>&lt;strong>-p &amp;lt;PID[,PID2&amp;hellip;.]&amp;gt;&lt;/strong> # 只显示指定的一个或多个进程的信息。默认关键字为 ALL，显示所有信息。可以用 SELF 关键字来只显示自身的信息&lt;/li>
&lt;li>&lt;strong>-t&lt;/strong> # 显示进程所关联的线程的统计信息。&lt;/li>
&lt;/ol>
&lt;p>EXAMPLE&lt;/p>
&lt;ol>
&lt;li>&lt;strong>pidstat -u 5 1&lt;/strong> #&lt;/li>
&lt;/ol>
&lt;h1 id="sadf--以多种格式显示-sar-工具收集到的数据">sadf # 以多种格式显示 sar 工具收集到的数据&lt;/h1>
&lt;h1 id="sar--系统活动报告">sar # 系统活动报告&lt;/h1>
&lt;p>&lt;strong>system activity report(系统活动报告，简称 SAR)&lt;/strong>。sar 是以系统为主体，报告系统相关信息的工具，包括 CPU 使用率、RAM 使用情况、磁盘 IO、网络活动状态等等。&lt;/p>
&lt;p>根据命令的不同选项，显示不同信息。&lt;/p>
&lt;h2 id="-b--报告-io-和传输速率的统计信息">-b # 报告 I/O 和传输速率的统计信息。&lt;/h2>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">[&lt;/span>lichenhao@hw-cloud-xngy-jump-server-linux-2 ~&lt;span style="color:#f92672">]&lt;/span>$ sar --human -b &lt;span style="color:#ae81ff">1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Linux 5.4.0-88-generic &lt;span style="color:#f92672">(&lt;/span>hw-cloud-xngy-jump-server-linux-2&lt;span style="color:#f92672">)&lt;/span> 10/03/2021 _x86_64_ &lt;span style="color:#f92672">(&lt;/span>&lt;span style="color:#ae81ff">2&lt;/span> CPU&lt;span style="color:#f92672">)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>10:07:46 PM tps rtps wtps dtps bread/s bwrtn/s bdscd/s
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>10:07:47 PM 0.00 0.00 0.00 0.00 0.00 0.00 0.00
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>10:07:48 PM 0.00 0.00 0.00 0.00 0.00 0.00 0.00
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>10:07:49 PM 0.00 0.00 0.00 0.00 0.00 0.00 0.00
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>10:07:50 PM 2.00 0.00 2.00 0.00 0.00 16.00 0.00
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>^CAverage: 0.50 0.00 0.50 0.00 0.00 3.99 0.00
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ul>
&lt;li>**tpc **# Transfers Per Second(每秒传输总数)，即每秒发送到物理设备的传输总数。也就是物理设备的 I/O 请求数。比如上面的例子，就是在 10 点 07 分 49 秒时，发起的两次 I/O 请求，这里面并不关心 I/O 的传输总量，或者具体是读还是写，仅记录次数。&lt;/li>
&lt;li>&lt;strong>rtps&lt;/strong> # Read TPS，每秒向物理设备发送的读请求总数&lt;/li>
&lt;li>&lt;strong>wtps&lt;/strong> # Write TPS，每秒向物理设备发送的写请求总数&lt;/li>
&lt;li>&lt;strong>dtps&lt;/strong> # Discard TPS，每秒向物理设备发送的丢弃请求总数&lt;/li>
&lt;li>&lt;strong>bread/s&lt;/strong> # Black Read，每秒从设备中读取的数据总量(以块为单位)&lt;/li>
&lt;li>**bwrtn/s **# Black Written，每秒写入设备的数据总量(以块为单位)&lt;/li>
&lt;li>&lt;strong>bdscd/s&lt;/strong> # Black Discarded，每秒为设备丢弃的丢弃的数据总量(以块为单位)&lt;/li>
&lt;/ul>
&lt;h2 id="-n-keyword--报告网络统计信息">-n KEYWORD # 报告网络统计信息&lt;/h2>
&lt;p>KEYWORD 可用的值有 DEV、EDEV、NFS、NFSD、SOCK、IP、EIP、ICMP、EICMP、TCP、ETCP、UDP、SOCK6、IP6、EIP6、ICMP6、EICMP6、UDP6。当然，也可以用使用 ALL 来报告所有的网络统计信息&lt;/p>
&lt;h3 id="dev--报告指定网络设备的统计信息">DEV # 报告指定网络设备的统计信息&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">[&lt;/span>root@lichenhao ~&lt;span style="color:#f92672">]&lt;/span>&lt;span style="color:#75715e"># sar -n DEV 1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Linux 4.18.0-193.28.1.el8_2.x86_64 &lt;span style="color:#f92672">(&lt;/span>lichenhao.bj-net&lt;span style="color:#f92672">)&lt;/span> 11/18/2020 _x86_64_ &lt;span style="color:#f92672">(&lt;/span>&lt;span style="color:#ae81ff">2&lt;/span> CPU&lt;span style="color:#f92672">)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>10:18:38 PM IFACE rxpck/s txpck/s rxkB/s txkB/s rxcmp/s txcmp/s rxmcst/s %ifutil
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>10:18:39 PM docker0 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>10:18:39 PM ens3 4.00 1.00 0.23 0.10 0.00 0.00 0.00 0.00
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>10:18:39 PM lo 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ul>
&lt;li>&lt;strong>rxpck/s&lt;/strong> 和** txpck/s** 分别表示每秒接收、发送的网络帧数，也就是 PPS&lt;/li>
&lt;li>&lt;strong>rxkB/s&lt;/strong> 和 &lt;strong>txkB/s&lt;/strong> 分别表示每秒接收、发送的千字节数，也就是 BPS&lt;/li>
&lt;li>&lt;strong>rxcmp/s&lt;/strong> 和 &lt;strong>txcmp/s&lt;/strong>  分别表示每秒接收、发送的压缩数据包&lt;/li>
&lt;li>&lt;strong>rxmcst/s&lt;/strong> # 表示每秒接收的多播数据包&lt;/li>
&lt;/ul>
&lt;h3 id="tcp--报告-tcpv4-网络流量的统计信息">TCP # 报告 TCPv4 网络流量的统计信息。&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">[&lt;/span>lichenhao@hw-cloud-xngy-jump-server-linux-2 ~&lt;span style="color:#f92672">]&lt;/span>$ sar -n TCP &lt;span style="color:#ae81ff">1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Linux 5.4.0-88-generic &lt;span style="color:#f92672">(&lt;/span>hw-cloud-xngy-jump-server-linux-2&lt;span style="color:#f92672">)&lt;/span> 10/03/2021 _x86_64_ &lt;span style="color:#f92672">(&lt;/span>&lt;span style="color:#ae81ff">2&lt;/span> CPU&lt;span style="color:#f92672">)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>09:46:03 PM active/s passive/s iseg/s oseg/s
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>09:46:04 PM 0.00 0.00 2.00 2.00
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>09:46:05 PM 0.00 0.00 2.00 3.00
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>09:46:06 PM 0.00 0.00 2.00 2.00
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>09:46:07 PM 0.00 0.00 2.00 2.00
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>^C
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Average: 0.00 0.00 2.00 2.25
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ul>
&lt;li>&lt;strong>active/s&lt;/strong> # TCP 连接每秒从 CLOSED 状态直接转换到 SYN-SENT 状态的次数。
&lt;ul>
&lt;li>每秒本地发起 TCP 连接数，例如通过 connect() 系统调用。(待确认描述)&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>passive/s&lt;/strong> # TCP 连接每秒从 LISTEN 状态直接转换到 SYN-RCVD 状态的次数。
&lt;ul>
&lt;li>每秒远程发起的 TCP 连接数，例如通过 accept() 系统调用。(待确认描述)&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>iseg/s&lt;/strong> # 每秒接受的 TCP segments 总数，包括错误的。
&lt;ul>
&lt;li>也就是每秒收到了多少个 TCP 包&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>oseg/s&lt;/strong> # 每秒发送的 TCP segments 总数。不包括重传的。
&lt;ul>
&lt;li>也就是每秒发送了多少个 TCP 包&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h2 id="syntax语法-1">Syntax(语法)&lt;/h2>
&lt;p>&lt;strong>sar [OPTIONS] [INTERVAL [COUNT]]&lt;/strong>
INTERVAL # 间隔时间，单位是秒。指定 INTERVAL 时，mpstat 根据该时间每隔 INTERVAL 秒输出一次信息，并在最后输出平均值。&lt;/p>
&lt;ul>
&lt;li>COUNT # 每隔 INTERVAL 时间，输出信息的数量。若不指定 CONUNT，则 mpstat 会根据间隔时间持续输出统计信息。&lt;/li>
&lt;/ul>
&lt;p>OPTIONS&lt;/p>
&lt;ul>
&lt;li>&lt;strong>-p &amp;lt;CPU[,CPU2&amp;hellip;.]&amp;gt;&lt;/strong> # 只显示指定的一个或多个 CPU 的信息，以需要表示，多个 CPU 以逗号分割。&lt;/li>
&lt;/ul>
&lt;p>EXAMPLE&lt;/p>
&lt;ol>
&lt;li>输出 1，3，5，7 这 4 个 CPU 中，idle 小于 10 的 CPU
&lt;ol>
&lt;li>&lt;strong>sar -P 1,3,5,7 1 | tail -n+3 | awk &amp;lsquo;$NF&amp;lt;10 {print $0}&amp;rsquo;&lt;/strong>&lt;/li>
&lt;/ol>
&lt;/li>
&lt;/ol>
&lt;h1 id="tapestat">&lt;strong>tapestat&lt;/strong>&lt;/h1></description></item><item><title>Docs: 磁盘 与 文件系统管理工具集</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/x.linux-%E7%AE%A1%E7%90%86/linux-%E7%B3%BB%E7%BB%9F%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/%E7%A3%81%E7%9B%98-%E4%B8%8E-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7%E9%9B%86/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/x.linux-%E7%AE%A1%E7%90%86/linux-%E7%B3%BB%E7%BB%9F%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/%E7%A3%81%E7%9B%98-%E4%B8%8E-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7%E9%9B%86/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;h2 id="参考">参考：&lt;/h2>
&lt;/blockquote>
&lt;h1 id="磁盘分区管理工具">磁盘分区管理工具&lt;/h1>
&lt;h2 id="parted">Parted&lt;/h2>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="http://www.gnu.org/software/parted">GNU 官网-软件-parted&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://man7.org/linux/man-pages/man8/parted.8.html">Manual(手册),parted(8)&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>Parted 是一个 &lt;strong>partition(分区)&lt;/strong> 操作程序，支持对 2T 以上硬盘的分区，支持 GTP 分区表，如果直接输入 parted 命令则进入 parted 工具，以交互式方式对 DEVICE 进行操作。&lt;/p>
&lt;p>Parted 程序在 CentOS 和 Ubuntu 中都属于 parted 包，这个包中有两个程序，&lt;code>parted&lt;/code> 与 &lt;code>partprobe&lt;/code>&lt;/p>
&lt;p>parted 程序可以在交互模式中运行，当 parted 运行在交互模式中时，对磁盘进行的操作，只有在执行 &lt;code>quit&lt;/code> 命令后，才会将更新通知给 Linux 内核&lt;/p>
&lt;h3 id="syntax语法">Syntax(语法)&lt;/h3>
&lt;p>&lt;strong>parted [OPTIONS] [DEVICE [COMMAND [ARGUMENT&amp;hellip;]&amp;hellip;]]&lt;/strong>&lt;/p>
&lt;p>&lt;strong>OPTIONS&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>&lt;strong>-a, &amp;ndash;align=[none|cyl|min|opt]&lt;/strong> # alignment for new partitions&lt;/li>
&lt;li>&lt;strong>-l, &amp;ndash;list&lt;/strong> # 列出所有块设备上的分区布局，i.e.列出所有磁盘的分区&lt;/li>
&lt;li>&lt;strong>-m, &amp;ndash;machine&lt;/strong> # 与 -l 选项配合， 显示出机器可以解析的输出内容&lt;/li>
&lt;li>&lt;strong>-s, &amp;ndash;script&lt;/strong> # never prompts for user intervention&lt;/li>
&lt;/ul>
&lt;h4 id="command">COMMAND&lt;/h4>
&lt;p>&lt;strong>align-check &lt;!-- raw HTML omitted --> &lt;!-- raw HTML omitted -->&lt;/strong> # 检查指定分区是否对齐&lt;/p>
&lt;ul>
&lt;li>ALIGN-TYPE
&lt;ul>
&lt;li>minimal #&lt;/li>
&lt;li>optimal #&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>select &lt;!-- raw HTML omitted -->&lt;/strong> # 选择对 DEVICE 磁盘进行操作&lt;/p>
&lt;p>&lt;strong>mklable &lt;!-- raw HTML omitted -->&lt;/strong> # 创建一个新的 Disk Label(磁盘标签)。
Disk Label 其实就是 Partition Table(分区表)，也有的人称为 Partition Map(分区图)
这个行为会虽然不会导致磁盘所有数据丢失，但是却无法使用这些数据，如果想要恢复，可以通过恢复模式，参考&lt;a href="https://www.gnu.org/software/parted/manual/parted.html#Related-information">这里&lt;/a>进行恢复。当为一个已经有磁盘标签的磁盘创建标签时，将会出现如下提示：
&lt;code>Warning: The existing disk label on /dev/vdb will be destroyed and all data on this disk will be lost. Do you want to continue?&lt;/code>&lt;/p>
&lt;ul>
&lt;li>LABEL-TYPE
&lt;ul>
&lt;li>bsd&lt;/li>
&lt;li>loop # 这个标签通常用于 LVM 类型的磁盘上，带有这种标签的磁盘，其实是没有分区表的。&lt;/li>
&lt;li>gpt # 这个类型的标签就是 GPT 分区表&lt;/li>
&lt;li>msdos # 这个类型的标签就是 MBR 分区表&lt;/li>
&lt;li>pc98&lt;/li>
&lt;li>sun&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>Model: Virtio Block Device &lt;span style="color:#f92672">(&lt;/span>virtblk&lt;span style="color:#f92672">)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Disk /dev/vdb: 21.5GB
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Sector size &lt;span style="color:#f92672">(&lt;/span>logical/physical&lt;span style="color:#f92672">)&lt;/span>: 512B/512B
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Partition Table: gpt
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Disk Flags:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Number Start End Size File system Name Flags
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Model: Virtio Block Device &lt;span style="color:#f92672">(&lt;/span>virtblk&lt;span style="color:#f92672">)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Disk /dev/vda: 107GB
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Sector size &lt;span style="color:#f92672">(&lt;/span>logical/physical&lt;span style="color:#f92672">)&lt;/span>: 512B/512B
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Partition Table: msdos
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Disk Flags:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Number Start End Size Type File system Flags
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ae81ff">1&lt;/span> 1049kB 107GB 107GB primary ext4 boot
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>不同类型的分区表，其显示的内容也不同，比如 GPT 分区别没有 Type 列，有 Name 列；而 msdos 有 Type 列却没有 Name 列。所以不同的分区表类型，会影响 mkpart 等命令的参数。&lt;/p>
&lt;p>&lt;strong>mkpart [PART-TYPE NAME FS-TYPE] &lt;!-- raw HTML omitted --> &lt;!-- raw HTML omitted -->&lt;/strong> # 创建一个新的分区。&lt;/p>
&lt;ul>
&lt;li>&lt;strong>PART-TYPE&lt;/strong> # 分区类型
&lt;ul>
&lt;li>注意：该参数仅适用于分区表类型为 msdos 和 dvh 的磁盘&lt;/li>
&lt;li>extended # 扩展分区&lt;/li>
&lt;li>logical # 逻辑分区&lt;/li>
&lt;li>primary # 主分区&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>NAME&lt;/strong> # 分区表的名字
&lt;ul>
&lt;li>注意：分区表类型为 GPT 的磁盘必须指定 NAME 参数。如果是在交互模式中，可以设定一个空名字~~~o(╯□╰)o&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>FS-TYPE&lt;/strong> # 为分区添加文件系统类型的签名，通常都是在该分区的 offset 0 处添加签名。注意：仅仅是添加签名，并不是真的创建一个文件系统，想要创建文件系统，使用单独的 &lt;code>mkfs&lt;/code> 等命令
&lt;ul>
&lt;li>btrfs&lt;/li>
&lt;li>ext2、ext3、ext4&lt;/li>
&lt;li>fat16、fat32&lt;/li>
&lt;li>hfs、hfs+&lt;/li>
&lt;li>linux-swap&lt;/li>
&lt;li>ntfs&lt;/li>
&lt;li>reiserfs&lt;/li>
&lt;li>udf&lt;/li>
&lt;li>xfs&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>name &lt;!-- raw HTML omitted --> &lt;!-- raw HTML omitted -->&lt;/strong> # 设置 NUMBER 号分区的名称为 NAME。仅对 GPT、Mac、MIPS、PC98 磁盘类型下的分区有效。&lt;/p>
&lt;p>&lt;strong>print [NUMBER]&lt;/strong> # 显示磁盘的分区信息，或者显示指定分区的信息&lt;/p>
&lt;p>&lt;strong>rescure START END&lt;/strong> # 救援一个丢失的分区。好像没什么用~~o(╯□╰)o?????????????????&lt;/p>
&lt;p>&lt;strong>resizepart &lt;!-- raw HTML omitted --> &lt;!-- raw HTML omitted -->&lt;/strong> # 移动指定分区的结束位置，即.调整分区的容量大小。注意：这不会修改分区中的任何文件系统，如果需要调整文件系统，则需要使用 resize2fs 之类的程序。&lt;/p>
&lt;p>&lt;strong>rm &lt;!-- raw HTML omitted -->&lt;/strong> # 删除指定的分区&lt;/p>
&lt;p>&lt;strong>select&lt;/strong> &lt;strong>&lt;!-- raw HTML omitted -->&lt;/strong> # 在交互模式中选择要编辑的磁盘设备。DEVICE 可以是 Linux 硬盘设备、分区、软 RAID 设备、LVM&lt;/p>
&lt;p>&lt;strong>set &lt;!-- raw HTML omitted --> &lt;!-- raw HTML omitted --> &lt;!-- raw HTML omitted -->&lt;/strong> # 设置分区的 Flag。这命令有啥用？~~囧???????????&lt;/p>
&lt;p>&lt;strong>unit &lt;!-- raw HTML omitted -->&lt;/strong> # 设定 parted 程序在显示磁盘信息时所使用的默认单位。
当我们使用 &lt;code>%&lt;/code> 给磁盘分区后，过了一段时间我们往往忘记了每个分区具体都占了磁盘的百分比，这时候，使用 &lt;code>unit %&lt;/code> 指令就可以看到这些信息了。o(∩_∩)o&lt;/p>
&lt;h3 id="example">EXAMPLE&lt;/h3>
&lt;ul>
&lt;li>检查 /dev/vda 磁盘的 1 号分区是否对齐
&lt;ul>
&lt;li>parted /dev/vda align-check optimal 1&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>设置 /dev/vdb 磁盘的分区表为 msdos 格式
&lt;ul>
&lt;li>parted /dev/vdb mktable msdos&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>设置/dev/vdb 磁盘的第一个分区的 FLAG 为 lvm
&lt;ul>
&lt;li>parted /dev/vdb set 1 lvm on&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;/li>
&lt;/ul>
&lt;h2 id="partprobe--探测分区">partprobe # 探测分区&lt;/h2>
&lt;p>当创建完分区而无法用 mkfs 创建文件系统的时候，用该命令，让内核重新读取分区情况以便让新增加的分区可以在不重启的情况下使用&lt;/p>
&lt;h2 id="fdisk--与-parted-工具类似分为交互式命令与非交互式命令">fdisk # 与 parted 工具类似，分为交互式命令与非交互式命令&lt;/h2>
&lt;h3 id="syntax语法-1">Syntax(语法)&lt;/h3>
&lt;p>**fdisk [/Path/DEV] **&lt;/p>
&lt;p>EXAMPLE&lt;/p>
&lt;ul>
&lt;li>fdisk -l # 查看当前磁盘分区详情&lt;/li>
&lt;/ul>
&lt;h1 id="文件系统管理工具">文件系统管理工具&lt;/h1>
&lt;h2 id="mkfs">mkfs&lt;/h2>
&lt;p>&lt;strong>mkfs [OPTIONS]&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>OPTIONS
&lt;ul>
&lt;li>&lt;strong>-t&lt;/strong> # 指定创建的文件系统的类型&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>EXAMPLE
&lt;ul>
&lt;li>mkfs -t ext4 /dev/myvg/lv1 # 对 lv1 磁盘创建 ext2 的文件系统&lt;/li>
&lt;li>mkfs.xfs /dev/vdb1 # 以 xfs 类型文件系统格式化 /dev/sdb1 分区&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h2 id="mke2fs">mke2fs&lt;/h2>
&lt;p>&lt;strong>mke2fs [OPTIONS]&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>OPTIONS
&lt;ul>
&lt;li>-t 指定文件系统格式&lt;/li>
&lt;li>-b 指定 block 的大小(支持 1024,2048,4096 三种)&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>EXAMPLE&lt;/li>
&lt;/ul>
&lt;h2 id="xfs_info--显示-xfs-文件系统的几何信息">xfs_info # 显示 XFS 文件系统的几何信息&lt;/h2>
&lt;p>xfs_info 显示有关现有 XFS 文件系统的几何信息。挂载点参数是挂载文件系统的目录的路径名。块设备或文件映像包含原始 XFS 文件系统。文件系统的现有内容不受干扰。&lt;/p>
&lt;h1 id="磁盘查询命令">磁盘查询命令&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://man7.org/linux/man-pages/man1/df.1.html">manual,df&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://man7.org/linux/man-pages/man1/du.1.html">manual,du&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://man7.org/linux/man-pages/man8/lsblk.8.html">manual,lsblk&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;h2 id="df--查看已经格式化成文件系统的整体容量挂载点位置">df # 查看已经格式化成文件系统的整体容量[挂载点位置]&lt;/h2>
&lt;h3 id="syntax语法-2">Syntax(语法)&lt;/h3>
&lt;p>&lt;strong>df [OPTIONS]&amp;hellip; [FILE]&amp;hellip;&lt;/strong>
OPTIONS&lt;/p>
&lt;ul>
&lt;li>**-h, &amp;ndash;human-readable **# 以人类可读的方式输出信息。磁盘容量以 1024 为除数。效果如下：
&lt;ul>
&lt;li>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/zqtob4/1625708279949-ac083715-d7e8-4271-800e-6c5791aa3573.png" alt="image.png">&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>-i, &amp;ndash;inodes&lt;/strong> # 列出 inode 信息&lt;/li>
&lt;li>&lt;strong>-T, &amp;ndash;print-type&lt;/strong> # 输出文件系统类型&lt;/li>
&lt;li>&lt;strong>-t, &amp;ndash;type &lt;!-- raw HTML omitted -->&lt;/strong> # 仅列出指定类型的文件系统。(文件系统类型可以通过 -T 选项看到)&lt;/li>
&lt;/ul>
&lt;h3 id="example-1">EXAMPLE&lt;/h3>
&lt;ul>
&lt;li>&lt;strong>df -h /&lt;/strong> # 以人类易读的方式显示挂载在/下的信息，可以显示容量是 M 还是 G 还是 K&lt;/li>
&lt;/ul>
&lt;h2 id="du--查看文件系统下当前目录以及子目录的容量">du # 查看文件系统下当前目录以及子目录的容量&lt;/h2>
&lt;h3 id="syntax语法-3">Syntax(语法)&lt;/h3>
&lt;p>OPTIONS&lt;/p>
&lt;ul>
&lt;li>&lt;strong>-a&lt;/strong> # 包括目录下的文件大小也一起显示&lt;/li>
&lt;li>&lt;strong>-s&lt;/strong> # 仅列出当前目录的容量总计，不显示子目录&lt;/li>
&lt;li>&lt;strong>-h&lt;/strong> # 把容量大小转换为人类易读的格式&lt;/li>
&lt;li>&lt;strong>-d, &amp;ndash;maxdepth &lt;!-- raw HTML omitted -->&lt;/strong> # 仅列出目录深度 1 层的信息，即当前目录下的目录的大小，不往下列出子目录&lt;/li>
&lt;/ul>
&lt;p>EXAMPLE&lt;/p>
&lt;ul>
&lt;li>du -d 1 | sort -rn | head -n 2 #列出不含子目录的当前目录下的目录大小，并以数字进行降序排列，且只显示前两行&lt;/li>
&lt;/ul>
&lt;h2 id="ncdu--比-du-更快的工具">ncdu # 比 du 更快的工具&lt;/h2>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://code.blicky.net/yorhel/ncdu/src/branch/zig/src">https://code.blicky.net/yorhel/ncdu/src/branch/zig/src&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://dev.yorhel.nl/ncdu">官网&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;h2 id="sn--比-du-更快的工具">sn # 比 du 更快的工具&lt;/h2>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://github.com/vmchale/tin-summer">GitHub 项目，vmchale/tin-summer&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;h3 id="syntax语法-4">Syntax(语法)&lt;/h3>
&lt;p>&lt;strong>sn &lt;!-- raw HTML omitted -->&lt;/strong>
sn 工具完全通过子命令来执行具体操作
SUBCOMMAND&lt;/p>
&lt;ul>
&lt;li>sort #&lt;/li>
&lt;/ul>
&lt;p>OPTIONS：&lt;/p>
&lt;ul>
&lt;li>&lt;strong>-d, &amp;ndash;depth &lt;!-- raw HTML omitted -->&lt;/strong> # 目录深度&lt;/li>
&lt;/ul>
&lt;h3 id="example-2">EXAMPLE&lt;/h3>
&lt;ul>
&lt;li>显示根目录下一层深度的容量大小，并排序
&lt;ul>
&lt;li>sn sort -d 1 /&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h2 id="lsblk--list-block-devices-列出块设备信息">lsblk # list block devices 列出块设备信息&lt;/h2>
&lt;p>lsblk 列出有关所有可用或指定的块设备的信息。 lsblk 命令读取 &lt;code>sysfs文件系统&lt;/code> 和 &lt;code>udev db&lt;/code> 来收集信息。&lt;/p>
&lt;p>默认情况下，该命令以树形格式打印所有块设备(除了 RAM 磁盘)。效果如下：&lt;/p>
&lt;pre>&lt;code>[root@lichenhao ~]# lsblk
NAME MAJ:MIN RM SIZE RO TYPE MOUNTPOINT
sr0 11:0 1 1024M 0 rom
vda 252:0 0 500G 0 disk
├─vda1 252:1 0 2M 0 part
├─vda2 252:2 0 500M 0 part /boot
└─vda3 252:3 0 499.5G 0 part
└─vg1-root 253:0 0 499.5G 0 lvm /
&lt;/code>&lt;/pre>
&lt;p>除了上面例子中的 6 列信息，lsblk 还会提供很多其他信息，使用 lsblk &amp;ndash;help 命令获取所有可用列的列表。&lt;/p>
&lt;ol>
&lt;li>NAME # 块设备名称&lt;/li>
&lt;li>KNAME # 该块设备在内核内的名称。&lt;/li>
&lt;li>MAJ:MIN # major(主要):minor(次要) 的块设备编号
&lt;ol>
&lt;li>MIN 就是 /dev/dm-X 设备后面那个 X 的编号&lt;/li>
&lt;/ol>
&lt;/li>
&lt;li>RM # 该设备是否是可移动设备&lt;/li>
&lt;li>SIZE # 块设备大小&lt;/li>
&lt;li>RO #&lt;/li>
&lt;li>TYPE # 块设备类型&lt;/li>
&lt;li>MOUNTPOINT # 该块设备的挂载路径&lt;/li>
&lt;/ol>
&lt;p>**lsblk [OPTIONS] [DEVICE&amp;hellip;] **
OPTIONS&lt;/p>
&lt;ol>
&lt;li>-J, &amp;ndash;json # 使用 JSON 格式输出内容。&lt;/li>
&lt;li>-o, &amp;ndash;output &lt;!-- raw HTML omitted --> # 指定要打印的输出列。 使用&amp;ndash;help 获取所有受支持列的列表。如果以+LIST 格式（例如 lsblk -o + UUID）指定 LIST，则可以扩展默认的列表。&lt;/li>
&lt;li>-p, &amp;ndash;paths # 显示块设备所在位置的绝对路径&lt;/li>
&lt;/ol>
&lt;p>EXAMPLE&lt;/p>
&lt;ol>
&lt;li>**lsblk **# 以树状结构列出块设备信息&lt;/li>
&lt;li>&lt;strong>lsblk &amp;ndash;output NAME,KNAME,TYPE,SIZE,MOUNTPOINT&lt;/strong> #&lt;/li>
&lt;/ol>
&lt;h2 id="blkid--查看块设备-uuid">blkid # 查看块设备 UUID&lt;/h2>
&lt;p>效果如下：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">[&lt;/span>root@lichenhao ~&lt;span style="color:#f92672">]&lt;/span>&lt;span style="color:#75715e"># blkid&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>/dev/vda1: PARTUUID&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;155ebb92-01&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>/dev/vda2: UUID&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;6c780e7d-7d0d-4e87-a3a3-77bd9a6ff9d5&amp;#34;&lt;/span> TYPE&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;ext4&amp;#34;&lt;/span> PARTUUID&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;155ebb92-02&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>/dev/vda3: UUID&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;SADfxz-bqhC-QdUe-ogW1-diaM-1Fr8-TppSou&amp;#34;&lt;/span> TYPE&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;LVM2_member&amp;#34;&lt;/span> PARTUUID&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;155ebb92-03&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>/dev/mapper/vg1-root: UUID&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;47af4ed5-64c5-405f-bef1-c65dc2984e21&amp;#34;&lt;/span> TYPE&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;xfs&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h1 id="lvm">LVM&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://github.com/lvmteam/lvm2">GitHub 项目,lvmteam/lvm2&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://man7.org/linux/man-pages/man8/lvm.8.html">Manual(手册),lvm(8)&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>&lt;strong>Logical Volume Manager(逻辑卷管理器，简称 LVM)&lt;/strong> 提供了从物理设备创建 &lt;strong>Virtual Block Devices(虚拟块设备)&lt;/strong> 的&lt;strong>工具&lt;/strong>。虚拟设备比物理设备更易于管理，并且可以具有超出物理设备自身提供的功能的能力。&lt;/p>
&lt;ul>
&lt;li>&lt;strong>Volume Group(卷组，简称 VG)&lt;/strong> 是一个或多个物理设备的集合，每个设备称为 &lt;strong>Physical Volume(物理卷，简称 PV)&lt;/strong>&lt;/li>
&lt;li>&lt;strong>Logical Volume(逻辑卷，简称 LV)&lt;/strong> 从 VG 中创建，是可由系统或应用直接使用的虚拟块设备。
&lt;ul>
&lt;li>根据内核中 &lt;strong>Device Mapper(设备映射，简称 DM)&lt;/strong> 实现的算法，LV 中的每个数据块都存储在 VG 中的一个或多个 PV 上。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>LVM 创建的 LV 本质上是相当于创建了一个新的物理磁盘，这不说是逻辑上的磁盘。所以称为逻辑卷。在 Linux 中，LVM 表现为一种 device-mapper 类型的磁盘。
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/zqtob4/1640420060047-c8503823-746d-41d5-8db8-3c4c5bd218da.png" alt="image.png">
上图中，虽然 testvg1-testlv 磁盘是一个 LVM，并且是通过 /dev/sdb 磁盘的分区创建的，但是从整个磁盘管理的角度来看，一个 LV 就是一个物理磁盘，只不过类型不同罢了。&lt;/p>
&lt;h2 id="syntax语法-5">Syntax(语法)&lt;/h2>
&lt;p>&lt;strong>lvm [ COMMAND | FILE ]&lt;/strong>&lt;/p>
&lt;h2 id="example-3">Example&lt;/h2>
&lt;p>创建 LVM 顺序：&lt;/p>
&lt;ol>
&lt;li>Physical Volume：PV 物理卷(相当于一块一块真实的物理磁盘)&lt;/li>
&lt;li>Volume Group：VG 卷组(把多块物理磁盘组合在一起形成一个组，并在创建 VG 时把整个组的空间划分为一个个默认大小为 4M 的 PE，VG 就相当于一个存储池子，里面有好多好多 PE 块组成了一个大的磁盘空间供 LV 使用)&lt;/li>
&lt;li>Pysical Extent：PE 物理区域(把真实的物理磁盘的空间切分为一个个固定大小的块，每个块就是 PE)&lt;/li>
&lt;li>Logical Volume：LV 逻辑卷(从 VG 中拿出多个 PE 组成逻辑上的磁盘空间，可以把 LV 当成一个分区)&lt;/li>
&lt;/ol>
&lt;p>创建逻辑卷的步骤：&lt;/p>
&lt;ol>
&lt;li>创建分区，并使之可用
&lt;ol>
&lt;li>pvcreate /dev/sda{1,2}&lt;/li>
&lt;li>vgcreate testvg1 /dev/sda{1,2}&lt;/li>
&lt;li>lvcreate -L 10G -n testlv testvg1&lt;/li>
&lt;/ol>
&lt;/li>
&lt;/ol>
&lt;p>扩展逻辑卷的步骤：&lt;/p>
&lt;ol>
&lt;li>确定扩展的大小，并确保 lv 所属的 vg 有足够的剩余空间
&lt;ol>
&lt;li>pvcreate /DEV/PATH&lt;/li>
&lt;li>vgextend VG /DEV/PATH&lt;/li>
&lt;/ol>
&lt;/li>
&lt;li>扩展 lv 大小，执行 lvextend 命令，第二条为扩展所有剩余空间到逻辑卷
&lt;ol>
&lt;li>lvextend -L [+]SIZE LvPath&lt;/li>
&lt;li>lvextend -l+100%FREE /dev/mapper/vg0-root&lt;/li>
&lt;/ol>
&lt;/li>
&lt;li>扩展系统文件大小，执行 resize2fs 命令
&lt;ol>
&lt;li>xfs_growfs LvPath&lt;/li>
&lt;/ol>
&lt;/li>
&lt;/ol>
&lt;p>缩减逻辑卷的步骤&lt;/p>
&lt;ol>
&lt;li>卸载卷 umount，并执行强制检测
&lt;ol>
&lt;li>e2fsck -f LvPath&lt;/li>
&lt;/ol>
&lt;/li>
&lt;li>缩减文件系统大小
&lt;ol>
&lt;li>resize2fs LvPath SIZE&lt;/li>
&lt;/ol>
&lt;/li>
&lt;li>缩减 lv 大小
&lt;ol>
&lt;li>lvreduce -L [-]Siza LvPath&lt;/li>
&lt;/ol>
&lt;/li>
&lt;/ol>
&lt;h2 id="pv--物理卷管理命令">pv # 物理卷管理命令&lt;/h2>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>Manual(),pvcreate()&lt;/li>
&lt;li>&lt;a href="https://man7.org/linux/man-pages/man8/pvresize.8.html">Manual(手册),pvresize(8)&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;h3 id="syntax语法-6">Syntax(语法)&lt;/h3>
&lt;p>&lt;strong>pvcreate POSITION [OPTIONS] # 初始化物理卷以供 PVM 使用&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>POSITION #&lt;/li>
&lt;/ul>
&lt;p>pvcreat 创建 PV&lt;/p>
&lt;ol>
&lt;li>OPTIONS&lt;/li>
&lt;li>EXAMPLE
&lt;ol>
&lt;li>pvcreate /dev/sdb1&lt;/li>
&lt;li>pvcreate /dev/sdb{1,2}&lt;/li>
&lt;/ol>
&lt;/li>
&lt;/ol>
&lt;p>pvremove 删除 PV&lt;/p>
&lt;p>pvscan 扫描 PV&lt;/p>
&lt;p>pvs 简要显示 PV&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/zqtob4/1616167609644-770f62f5-144e-44cb-8b06-feceb8309f0f.jpeg" alt="">&lt;/p>
&lt;ul>
&lt;li>PV：物理卷名称 VG：PV 所属的卷组 Fmt：物理卷格式 Attr： PSize：物理卷大小 PFree：物理卷空余大小&lt;/li>
&lt;/ul>
&lt;p>pvdisplay # 详细显示 PV
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/zqtob4/1616167609649-9587c471-5e11-4e45-a7b6-0046a8d2030b.jpeg" alt="">&lt;/p>
&lt;ul>
&lt;li>PV Name：物理卷名称&lt;/li>
&lt;li>VG Name：PV 所属的卷组名称&lt;/li>
&lt;li>PV Size：物理卷占用多少空间&lt;/li>
&lt;li>Allocatable：是否可分配&lt;/li>
&lt;li>PE Size：每个 PE 占用的空间容量&lt;/li>
&lt;li>Total PE：合计有多少个 PE&lt;/li>
&lt;li>Free PE：有多少空余的 PE&lt;/li>
&lt;li>Allocated PE：分配了多少 PE&lt;/li>
&lt;li>PV UUID：PV 的 UUID 号&lt;/li>
&lt;/ul>
&lt;p>pvmove 把一个 pv 上的数据挪动到另一个 pv 上&lt;/p>
&lt;h2 id="vg--卷组管理命令">vg # 卷组管理命令&lt;/h2>
&lt;p>vgcreat,vgs,vgdisplay,vgextend,vgreduce,vgremove,vgrename&lt;/p>
&lt;p>vgcreat&lt;/p>
&lt;ol>
&lt;li>语法格式：vgcreat VgName PvPath
&lt;ol>
&lt;li>创建 vg 自定义 vg 名 需要加入 VG 的 PV 路径&lt;/li>
&lt;/ol>
&lt;/li>
&lt;li>选项
&lt;ol>
&lt;li>-s # 指定 PE 大小，默认 4M&lt;/li>
&lt;/ol>
&lt;/li>
&lt;li>应用范例
&lt;ol>
&lt;li>vgcreate myvg /dev/sda{1,2} #以 sdb1 和 sdb2 组合起来创建一个名叫 myvg 的 VG&lt;/li>
&lt;/ol>
&lt;/li>
&lt;/ol>
&lt;p>vgs&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/zqtob4/1616167609659-c21d1b79-70bd-4975-a150-6348c5f0bd1e.jpeg" alt="">&lt;/p>
&lt;ol>
&lt;li>#PV：该卷组中物理卷的个数 #LV：逻辑卷的个数&lt;/li>
&lt;/ol>
&lt;p>vgdisplay&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/zqtob4/1616167609663-ebeba7a4-5acb-4d14-ba10-6eddf182d96e.jpeg" alt="">&lt;/p>
&lt;p>vgextend 扩大卷组&lt;/p>
&lt;ol>
&lt;li>语法格式：vgextend VgName PvPath&lt;/li>
&lt;li>选项&lt;/li>
&lt;li>应用实例
&lt;ol>
&lt;li>vgextend myvg /dev/sdc1 #为卷组 myvg 添加一个/dev/sdc1 的物理卷&lt;/li>
&lt;/ol>
&lt;/li>
&lt;/ol>
&lt;p>vgreduce 缩小卷组(注：缩减卷组前，要把要缩减掉的 pv 上的数据用 pvmove 挪走)&lt;/p>
&lt;h2 id="lv--逻辑卷管理命令">lv # 逻辑卷管理命令&lt;/h2>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>Manual(手册),lvcreate(8)&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>lvcreat,lvdisplay,lvs,lvextend,lvreduce,lvremove&lt;/p>
&lt;p>lvcreat&lt;/p>
&lt;ol>
&lt;li>语法格式：lvcreat [OPTIONS] VgName [PvPath]
&lt;ol>
&lt;li>创建 lv 从哪个 vg 中创建&lt;/li>
&lt;/ol>
&lt;/li>
&lt;li>选项
&lt;ol>
&lt;li>&lt;strong>-n&lt;/strong> # 指定 lv 名字&lt;/li>
&lt;li>&lt;strong>-L&lt;/strong> # 指定 lv 的空间大小&lt;/li>
&lt;li>&lt;strong>-p&lt;/strong> # 指定访问权限&lt;/li>
&lt;li>&lt;strong>-s&lt;/strong> # 创建 lv 的快照 snapshot&lt;/li>
&lt;/ol>
&lt;/li>
&lt;li>实际范例
&lt;ol>
&lt;li>lvcreate -L 3G -n lv1 myvg # congmyvg 卷组中创建名为 Imyvg 大小为 3G 的 LV&lt;/li>
&lt;li>lvcreate -s -L3G -n lv1snapshot -p r /dev/myvg/lv1 # 创建名为 lv1snapshot，只有读权限，3G 大小的 lv1 的快照&lt;/li>
&lt;/ol>
&lt;/li>
&lt;/ol>
&lt;p>lvdisplay&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/zqtob4/1616167609656-34a3e1a7-1885-42e0-99db-234afc6e1061.jpeg" alt="">&lt;/p>
&lt;p>lvextend&lt;/p>
&lt;ol>
&lt;li>lvextend [OPTIONS] LvPath [PvPath]
&lt;ol>
&lt;li>增加 lv 增加哪个 LV [可以指定从哪个 PV 里给该 LV 增加]&lt;/li>
&lt;/ol>
&lt;/li>
&lt;li>OPTIONS
&lt;ol>
&lt;li>-L #指定要增加的空间，增加到 5G 则是-L 5G，增加了 5G 则是-L +5G&lt;/li>
&lt;/ol>
&lt;/li>
&lt;li>EXAMPLE
&lt;ol>
&lt;li>lvextend -L 5G /dev/myvg/lv1 扩展 lv1 这个逻辑卷到 5G 的容量&lt;/li>
&lt;li>lvextend -L +5G /dev/myvg/lv1 sdc1 #扩展 lv1 逻辑卷多出 5G 的空间，从 sdc1 中给 lv 提供空间&lt;/li>
&lt;li>lvextend -l+100%FREE /dev/mapper/vg0-root #扩展卷组中所有空间给 vg0-root 这个逻辑卷&lt;/li>
&lt;/ol>
&lt;/li>
&lt;/ol>
&lt;h2 id="resize2fs如果是-xfs-文件系统则使用-xfs_growfs-命令用来增大或者收缩未加载的-ext-文件系统的大小如果文件系统是处于-mount-状态下那么它只能做到扩容">resize2fs(如果是 xfs 文件系统，则使用 xfs_growfs 命令)用来增大或者收缩未加载的 ext 文件系统的大小。如果文件系统是处于 mount 状态下，那么它只能做到扩容&lt;/h2>
&lt;p>注意：在 lv 扩容完成后，还需要对文件系统进行扩容，否则无法使用&lt;/p>
&lt;ol>
&lt;li>语法格式&lt;/li>
&lt;li>OPTIONS&lt;/li>
&lt;li>EXAMPLE
&lt;ol>
&lt;li>resize2fs /dev/myvg/lv1 #&lt;/li>
&lt;/ol>
&lt;/li>
&lt;/ol>
&lt;h2 id="snapshot-快照卷">snapshot 快照卷&lt;/h2>
&lt;p>注意：lvm 创建的快照是基于原始卷来运行的，原始卷修改了多少内容，其修改之前的内容就会被自动复制到快照卷里，快照是按照 PE 复制的，每个 PE 的改变，原始 PE 都会自动备份到快照当中，当快照卷的容量满了，就失去了快照卷了，注意 lvm 创建的快照与 openstack 的实例创建的快照还有 VMware 创建的快照的区别&lt;/p>
&lt;h1 id="最佳实践">最佳实践&lt;/h1>
&lt;h2 id="最基本的新硬盘操作">最基本的新硬盘操作&lt;/h2>
&lt;ul>
&lt;li>创建 GPT 格式的分区表
&lt;ul>
&lt;li>parted /dev/vdb mktable gpt&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>为 /dev/vdb 创建一个主分区，大小是该磁盘的 0% 到 100%，设置名称为 data1
&lt;ul>
&lt;li>parted /dev/vdb mkpart data1 0% 100%&lt;/li>
&lt;li>注意：尽量使用 &lt;code>%&lt;/code> 来标识磁盘分区大小，否则会提示磁盘分区未对齐。若是显示命令无法显示百分比，则通过 &lt;code>unit&lt;/code> 子命令将单位转换为 &lt;code>%&lt;/code>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>为 /dev/vdb1 创建 xfs 文件系统
&lt;ul>
&lt;li>mkfs.xfs /dev/vdb1&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>挂载文件系统
&lt;ul>
&lt;li>mount /dev/vdb1 /mnt/test&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h2 id="为新磁盘创建-lvm">为新磁盘创建 LVM&lt;/h2>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># 创建 GPT 格式的分区表&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>parted /dev/vdb mktable gpt
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># 为/dev/vdb分一个主分区，大小是该磁盘的0%到100%&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>parted /dev/vdb mkpart lvm 0% 100%
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># 创建 PV&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>pvcreate /dev/vdb1
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># 创建 VG&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>vgcreate vg-data /dev/vdb1
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># 创建 LV&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>lvcreate -l 100%FREE -n lv0 vg-data
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># 为 /dev/mapper/vg--data-lv0 创建 xfs 文件系统&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>mkfs.xfs /dev/mapper/vg--data-lv0
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># 挂载文件系统&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>mount /dev/mapper/vg--data-lv0 /mnt/test
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="为虚拟机磁盘扩容">为虚拟机磁盘扩容&lt;/h2>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://support.huaweicloud.com/usermanual-evs/evs_01_0109.html">华为云文档,云硬盘 EVS-用户指南-扩容云硬盘-扩展磁盘分区和文件系统(Iinux)&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;h3 id="前提条件">前提条件&lt;/h3>
&lt;p>确保分区表正常&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">[&lt;/span>root@hw-cloud-xngy-jump-server-linux-2 ~&lt;span style="color:#f92672">]&lt;/span>&lt;span style="color:#75715e"># lsblk&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>NAME MAJ:MIN RM SIZE RO TYPE MOUNTPOINT
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>vda 252:0 &lt;span style="color:#ae81ff">0&lt;/span> 100G &lt;span style="color:#ae81ff">0&lt;/span> disk
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>└─vda1 252:1 &lt;span style="color:#ae81ff">0&lt;/span> 100G &lt;span style="color:#ae81ff">0&lt;/span> part /
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>vdb 252:16 &lt;span style="color:#ae81ff">0&lt;/span> 30G &lt;span style="color:#ae81ff">0&lt;/span> disk
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>└─vdb1 252:17 &lt;span style="color:#ae81ff">0&lt;/span> 20G &lt;span style="color:#ae81ff">0&lt;/span> part
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> └─vg--data-lv0 253:0 &lt;span style="color:#ae81ff">0&lt;/span> 20G &lt;span style="color:#ae81ff">0&lt;/span> lvm
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">[&lt;/span>root@hw-cloud-xngy-jump-server-linux-2 ~&lt;span style="color:#f92672">]&lt;/span>&lt;span style="color:#75715e"># parted /dev/vdb print&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Warning: Not all of the space available to /dev/vdb appears to be used, you can fix the GPT to use all of the space &lt;span style="color:#f92672">(&lt;/span>an extra &lt;span style="color:#ae81ff">20971520&lt;/span> blocks&lt;span style="color:#f92672">)&lt;/span> or &lt;span style="color:#66d9ef">continue&lt;/span> with the current setting?
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>警告：似乎并未使用 /dev/vdb 的所有可用空间，您可以修复 GPT 以使用所有空间（额外的 &lt;span style="color:#ae81ff">20971520&lt;/span> 个块）还是继续当前设置？
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Fix/Ignore?
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;blockquote>
&lt;p>注意：&lt;/p>
&lt;ul>
&lt;li>虚拟机中的一个磁盘被扩容后，如果是 GPT 分区表的磁盘，当我们使用 &lt;code>parted DEVICE print&lt;/code> 指令查看信息时，将会弹出警告&lt;/li>
&lt;li>这是因为 GPT 分区表信息存储在磁盘开头，为了减少分区表损坏的风险，同时在磁盘末尾会备份一份。当磁盘容量扩大后，末尾位置也会随之变化，因此需要根据系统提示输入“Fix”，将分区表信息的备份文件挪到新的磁盘末尾位置。&lt;/li>
&lt;li>此时直接输入 Fix 即可自动修复&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;h3 id="虚拟机磁盘使用-lvm-的扩容方案">虚拟机磁盘使用 LVM 的扩容方案&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># 扩容分区&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>$ growpart /dev/vdb &lt;span style="color:#ae81ff">1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>CHANGED: partition&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span> start&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">2048&lt;/span> old: size&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">62912479&lt;/span> end&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">62914527&lt;/span> new: size&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">73398239&lt;/span> end&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">73400287&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># 扩容分区对应的 PV&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>$ pvresize /dev/vdb1
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Physical volume &lt;span style="color:#e6db74">&amp;#34;/dev/vdb1&amp;#34;&lt;/span> changed
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ae81ff">1&lt;/span> physical volume&lt;span style="color:#f92672">(&lt;/span>s&lt;span style="color:#f92672">)&lt;/span> resized or updated / &lt;span style="color:#ae81ff">0&lt;/span> physical volume&lt;span style="color:#f92672">(&lt;/span>s&lt;span style="color:#f92672">)&lt;/span> not resized
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># 扩容 LV&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>$ lvextend -l +100%FREE /dev/mapper/vg--data-lv0
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Size of logical volume vg-data/lv0 changed from &amp;lt;30.00 GiB &lt;span style="color:#f92672">(&lt;/span>&lt;span style="color:#ae81ff">7679&lt;/span> extents&lt;span style="color:#f92672">)&lt;/span> to &amp;lt;35.00 GiB &lt;span style="color:#f92672">(&lt;/span>&lt;span style="color:#ae81ff">8959&lt;/span> extents&lt;span style="color:#f92672">)&lt;/span>.
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Logical volume vg-data/lv0 successfully resized.
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># 扩容文件系统&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>$ xfs_growfs /dev/mapper/vg--data-lv0
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>meta-data&lt;span style="color:#f92672">=&lt;/span>/dev/mapper/vg--data-lv0 isize&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">512&lt;/span> agcount&lt;span style="color:#f92672">=&lt;/span>4, agsize&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">1310464&lt;/span> blks
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">=&lt;/span> sectsz&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">512&lt;/span> attr&lt;span style="color:#f92672">=&lt;/span>2, projid32bit&lt;span style="color:#f92672">=&lt;/span>1
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">=&lt;/span> crc&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span> finobt&lt;span style="color:#f92672">=&lt;/span>1, sparse&lt;span style="color:#f92672">=&lt;/span>1, rmapbt&lt;span style="color:#f92672">=&lt;/span>0
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">=&lt;/span> reflink&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>data &lt;span style="color:#f92672">=&lt;/span> bsize&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">4096&lt;/span> blocks&lt;span style="color:#f92672">=&lt;/span>5241856, imaxpct&lt;span style="color:#f92672">=&lt;/span>25
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">=&lt;/span> sunit&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">0&lt;/span> swidth&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">0&lt;/span> blks
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>naming &lt;span style="color:#f92672">=&lt;/span>version &lt;span style="color:#ae81ff">2&lt;/span> bsize&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">4096&lt;/span> ascii-ci&lt;span style="color:#f92672">=&lt;/span>0, ftype&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>log &lt;span style="color:#f92672">=&lt;/span>internal log bsize&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">4096&lt;/span> blocks&lt;span style="color:#f92672">=&lt;/span>2560, version&lt;span style="color:#f92672">=&lt;/span>2
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">=&lt;/span> sectsz&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">512&lt;/span> sunit&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">0&lt;/span> blks, lazy-count&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>realtime &lt;span style="color:#f92672">=&lt;/span>none extsz&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">4096&lt;/span> blocks&lt;span style="color:#f92672">=&lt;/span>0, rtextents&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">0&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>data blocks changed from &lt;span style="color:#ae81ff">5241856&lt;/span> to &lt;span style="color:#ae81ff">9174016&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="虚拟机磁盘不使用-lvm-的扩容方案">虚拟机磁盘不使用 LVM 的扩容方案&lt;/h3>
&lt;p>比较简单，两步解决&lt;/p>
&lt;ul>
&lt;li>扩容分区
&lt;ul>
&lt;li>&lt;strong>growpart /dev/vdb 1&lt;/strong>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>扩容文件系统
&lt;ul>
&lt;li>ext* 类型
&lt;ul>
&lt;li>&lt;strong>resize2fs /dev/vdb1&lt;/strong>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>xfs 类型
&lt;ul>
&lt;li>&lt;strong>xfs_growfs /dev/vdb1&lt;/strong>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>这种方式通常都是在公有云上这么搞~&lt;/p></description></item><item><title>Docs: 磁盘 与 文件系统管理工具集</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/x.linux-%E7%AE%A1%E7%90%86/linux-%E7%B3%BB%E7%BB%9F%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/%E7%A3%81%E7%9B%98-%E4%B8%8E-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7%E9%9B%86/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/x.linux-%E7%AE%A1%E7%90%86/linux-%E7%B3%BB%E7%BB%9F%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/%E7%A3%81%E7%9B%98-%E4%B8%8E-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7%E9%9B%86/</guid><description/></item></channel></rss>