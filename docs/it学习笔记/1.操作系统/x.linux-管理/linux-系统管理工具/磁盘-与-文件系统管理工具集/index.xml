<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>断念梦 – 磁盘 与 文件系统管理工具集</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/x.linux-%E7%AE%A1%E7%90%86/linux-%E7%B3%BB%E7%BB%9F%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/%E7%A3%81%E7%9B%98-%E4%B8%8E-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7%E9%9B%86/</link><description>Recent content in 磁盘 与 文件系统管理工具集 on 断念梦</description><generator>Hugo -- gohugo.io</generator><atom:link href="https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/x.linux-%E7%AE%A1%E7%90%86/linux-%E7%B3%BB%E7%BB%9F%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/%E7%A3%81%E7%9B%98-%E4%B8%8E-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7%E9%9B%86/index.xml" rel="self" type="application/rss+xml"/><item><title>Docs: dd 生成指定大小的文件</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/x.linux-%E7%AE%A1%E7%90%86/linux-%E7%B3%BB%E7%BB%9F%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/%E7%A3%81%E7%9B%98-%E4%B8%8E-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7%E9%9B%86/dd-%E7%94%9F%E6%88%90%E6%8C%87%E5%AE%9A%E5%A4%A7%E5%B0%8F%E7%9A%84%E6%96%87%E4%BB%B6/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/x.linux-%E7%AE%A1%E7%90%86/linux-%E7%B3%BB%E7%BB%9F%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/%E7%A3%81%E7%9B%98-%E4%B8%8E-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7%E9%9B%86/dd-%E7%94%9F%E6%88%90%E6%8C%87%E5%AE%9A%E5%A4%A7%E5%B0%8F%E7%9A%84%E6%96%87%E4%BB%B6/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;h1 id="dd-命令使用说明">dd 命令使用说明&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;a href="https://blog.csdn.net/menogen/article/details/38059671">https://blog.csdn.net/menogen/article/details/38059671&lt;/a>&lt;/p>
&lt;/blockquote>
&lt;p>&lt;strong>dd [OPTIONS[=FLAGS]]&lt;/strong>
OPTIONS&lt;/p>
&lt;ul>
&lt;li>bs=BYTES # 每次读取和写入的字节数&lt;/li>
&lt;li>cbs=BYTES # convert BYTES bytes at a time&lt;/li>
&lt;li>conv=CONVS # convert the file as per the comma separated symbol list&lt;/li>
&lt;li>count=N # 读取的 block 数，block 的大小由 ibs 指定（只针对输入参数）&lt;/li>
&lt;li>ibs=BYTES # read up to BYTES bytes at a time (default: 512)&lt;/li>
&lt;li>if=FILE # 指定输入文件。默认从标准输入读取。
&lt;ul>
&lt;li>/dev/zero 是 Linux 的一个伪文件，它可以产生连续不断的 null 流（二进制的 0）&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>iflag=FLAGS # 使用 FLAGS 来控制输入(读取数据)时的行为特征。多个 FLAG 以 , 分隔&lt;/li>
&lt;li>obs=BYTES # write BYTES bytes at a time (default: 512)&lt;/li>
&lt;li>of=FILE # 指定输出文件。默认输出到标准输出。&lt;/li>
&lt;li>oflag=FLAGS # 使用 iflag 来控制输出(写入数据)时的行为特征。多个 FLAG 以 , 分隔&lt;/li>
&lt;li>seek=N # skip N obs-sized blocks at start of output&lt;/li>
&lt;li>skip=N # skip N ibs-sized blocks at start of input&lt;/li>
&lt;li>status=LEVEL # The LEVEL of information to print to stderr; &amp;rsquo;none&amp;rsquo; suppresses everything but error messages, &amp;rsquo;noxfer&amp;rsquo; suppresses the final transfer statistics, &amp;lsquo;progress&amp;rsquo; shows periodic transfer statistics&lt;/li>
&lt;/ul>
&lt;p>FLAGS&lt;/p>
&lt;ul>
&lt;li>append # 追加模式(仅对输出有意义；隐含了 conv=notrunc)&lt;/li>
&lt;li>direct # 使用直接 I/O 存取模式，即跳过缓存，不操作内存，而是直接操作磁盘&lt;/li>
&lt;li>directory # 除非是目录，否则 directory 失败&lt;/li>
&lt;li>dsync # 使用同步 I/O 存取模式&lt;/li>
&lt;li>sync # 与上者类似，但同时也对元数据生效&lt;/li>
&lt;li>fullblock # 为输入积累完整块(仅 iflag)&lt;/li>
&lt;li>nonblock # 使用无阻塞 I/O 存取模式&lt;/li>
&lt;li>noatime # 不更新存取时间&lt;/li>
&lt;li>nocache # 丢弃缓存数据&lt;/li>
&lt;li>noctty # 不根据文件指派控制终端&lt;/li>
&lt;li>nofollow # 不跟随链接文件&lt;/li>
&lt;/ul>
&lt;h1 id="example">EXAMPLE&lt;/h1>
&lt;ul>
&lt;li>测试当前磁盘 写入文件 的速度
&lt;ul>
&lt;li>**dd if=/dev/zero of=testdd bs=1M count=1000 **&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>测试当前磁盘 纯写入文件 的速度，即不使用缓存
&lt;ul>
&lt;li>&lt;strong>dd if=/dev/zero of=testdd bs=1M count=1024 oflag=sync,direct,nonblock&lt;/strong>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>测试当前磁盘 纯读取文件 的速度，即不使用缓存
&lt;ul>
&lt;li>&lt;strong>dd if=testdd of=/dev/null bs=1M count=1024 iflag=sync,direct,nonblock&lt;/strong>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>测试 sdb 磁盘 的 写入速度。注意：要使用一块空盘，否则数据没了
&lt;ul>
&lt;li>&lt;strong>dd if=/dev/urandom of=/dev/sdb1 bs=1M count=1024&lt;/strong>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>测试 sdb 磁盘 的读取速度
&lt;ul>
&lt;li>&lt;strong>dd if=/dev/sdb1 of=/dev/null bs=1M count=1024&lt;/strong>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul></description></item><item><title>Docs: find whereis which 查询工具</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/x.linux-%E7%AE%A1%E7%90%86/linux-%E7%B3%BB%E7%BB%9F%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/%E7%A3%81%E7%9B%98-%E4%B8%8E-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7%E9%9B%86/find-whereis-which-%E6%9F%A5%E8%AF%A2%E5%B7%A5%E5%85%B7/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/x.linux-%E7%AE%A1%E7%90%86/linux-%E7%B3%BB%E7%BB%9F%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/%E7%A3%81%E7%9B%98-%E4%B8%8E-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7%E9%9B%86/find-whereis-which-%E6%9F%A5%E8%AF%A2%E5%B7%A5%E5%85%B7/</guid><description>
&lt;h1 id="which-查看可执行文件的位置">which 查看可执行文件的位置&lt;/h1>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>root@lichenhao:~# which ls
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>/usr/bin/ls
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h1 id="whereis-查看文件的位置-如-whereis-ls">whereis 查看文件的位置， 如 whereis ls&lt;/h1>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>root@lichenhao:~# whereis ls
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>ls: /usr/bin/ls /usr/share/man/man1/ls.1.gz
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h1 id="find--在目录中搜索文件">find # 在目录中搜索文件&lt;/h1>
&lt;h2 id="syntax语法">Syntax(语法)&lt;/h2>
&lt;p>&lt;strong>find [OPTIONS] [PATH&amp;hellip;] [EXPRESSION]&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>PATH # 路径名，不写上默认表示在当前路径下搜索&lt;/li>
&lt;li>OPTIONS 与 EXPRESSION # 详见下文，PATH 可以指定一个或多个想要搜索的路径。&lt;/li>
&lt;/ul>
&lt;p>如果没有给出 PATH，则使用当前目录；如果未给出任何表达式，则使用表达式 -print&lt;/p>
&lt;h3 id="options">OPTIONS&lt;/h3>
&lt;p>-H，-L 和-P 选项控制 find 处理符号链接的行为。这些参数之后的命令行参数将被视为要检查的文件或目录的名称，直到以 - 开头的第一个参数或参数 ( 或 ! 。符号链接的概念详见：ln 链接&lt;/p>
&lt;ul>
&lt;li>**-P **# 不跟踪符号链接。该选项为 find 的默认行为。当 find 检查或打印文件信息时，该文件是符号链接，则所使用的信息应取自符号链接本身的属性。&lt;/li>
&lt;li>&lt;strong>-L&lt;/strong> # 跟踪符号链接。与 -type l 同时使用时仅搜索失效的符号链接。当 find 检查或打印有关文件的信息时，所使用的信息应从链接指向的文件的属性中获取，而不是从链接本身获取（除非它是断开的符号链接，或者 find 无法检查与之相关的文件）链接点）。使用此选项意味着-noleaf。如果以后使用-P 选项，则-noleaf 仍然有效。如果-L 有效，并且 find 在搜索过程中发现到子目录的符号链接，则将搜索该符号链接所指向的子目录。
&lt;ul>
&lt;li>当-L 选项生效时，-type 谓词将始终与符号链接指向的文件类型匹配，而不是与链接本身匹配（除非符号链接断开）。使用-L 会使-lname 和-ilname 谓词始终返回 false。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>-H&lt;/strong> # 除了处理命令行参数时，不要跟随符号链接。当 find 检查或打印有关文件的信息时，所使用的信息应取自符号链接本身的属性。唯一的例外情况是在命令行上指定的文件是符号链接并且可以解析该链接时，这种情况下，使用的信息取自链接指向的任何位置（即跟随该链接） ）。如果无法检查符号链接指向的文件，则有关链接本身的信息将用作备用。如果-H 有效，并且在命令行上指定的路径之一是指向目录的符号链接，则将检查该目录的内容（尽管-maxdepth 0 当然可以防止此情况）。&lt;/li>
&lt;li>&lt;strong>-D debugoptions&lt;/strong> # Print diagnostic information; this can be helpful to diagnose problems with why find is not doing what you want. The list of debug options should be comma separated. Compatibility of the debug options is not guaranteed between releases of findutils. For a complete list of valid debug options, see the output of find -D help. Valid debug options include&lt;/li>
&lt;li>&lt;strong>-Olevel&lt;/strong> # Enables query optimisation. The find program reorders tests to speed up execution while preserving the overall effect; that is, predicates with side effects are not reordered relative to each other. The optimisations performed at each optimisation level are as follows.&lt;/li>
&lt;/ul>
&lt;p>注意：&lt;/p>
&lt;ol>
&lt;li>上述五个 OPTIONS 必须出现在第一个 PATH 之前。&lt;/li>
&lt;li>下面 EXPRESSIONS(表达式)中的 OPTIONS，用来控制 find 的行为，与上述这些 OPTIONS 不同。并且表达式中的 OPTIONS 需要在第一个 PATH 之后指定。&lt;/li>
&lt;li>find 默认将在当前目录下查找子目录与文件。并且将查找到的子目录和文件全部进行显示&lt;/li>
&lt;/ol>
&lt;h3 id="expressions表达式">EXPRESSIONS(表达式)&lt;/h3>
&lt;p>EXPRESSIONS 由以下几部分组成&lt;/p>
&lt;ul>
&lt;li>OPTIONS 选项 #（这会影响整体操作，而不是特定文件的处理，并且始终返回 true）&lt;/li>
&lt;li>TESTS 测试 #（返回正确或错误的值）&lt;/li>
&lt;li>ACTIONS 动作 #（具有副作用并返回 true 或 false 值）&lt;/li>
&lt;/ul>
&lt;p>上述三部分表达式由运算符分隔。如果表达式除-prune 之外不包含其他任何动作，则对表达式为 true 的所有文件执行-print。&lt;/p>
&lt;p>OPTIONS：&lt;/p>
&lt;ul>
&lt;li>&lt;strong>-type&lt;/strong> # 根据文件类型查找 （find PATH -type 类型参数）
&lt;ul>
&lt;li>参数类型包括：f 普通文件，l 软连接文件，d 目录文件等&lt;/li>
&lt;li>例: find -type l #查找当前目录下的软连接文件&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>-name&lt;/strong> # 根据文件名查找 （* 任意多个字符）（? 1 个字符）（[] 指范围值，外侧加引号）
&lt;ul>
&lt;li>例：find /var –name &amp;ldquo;*.log&amp;rdquo; #查找/var 目录下，所有文件名最后字符是.log 的文件&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>-iname&lt;/strong> # 不区分大小写根据文件名查找&lt;/li>
&lt;li>&lt;strong>-inum&lt;/strong> # 根据 inode 号查找&lt;/li>
&lt;li>&lt;strong>-size&lt;/strong> # 根据大小查找
&lt;ul>
&lt;li>例:find /etc -size -10k -size +20k #查找/etc 目录下小于 10k 大于 20k 的文件&lt;/li>
&lt;li>注意+-号，如果没有，是精确这么大，通常都会带上+或-号，表示一个范围&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>-user&lt;/strong> # 根据所有者查找 （user 可改成 group 则查找属组为 lisi 的文件）
&lt;ul>
&lt;li>例:find /home -user lisi #查找/home 目录下，属主为 lisi 的文件&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>-perm&lt;/strong> # 根据文件权限查找
&lt;ul>
&lt;li>例:find /boot -perm 644 #查找/boot 文件加下，权限为 644 的文件&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>**-TIME {+|-}NUM **# 根据时间查找
&lt;ul>
&lt;li>
&lt;ul>
&lt;li>表示该时间之前，-表示该时间之内&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>TIME 分为两部分
&lt;ul>
&lt;li>第一部分，# 表示 ctime，atime，mtime；time 天，min 分钟
&lt;ul>
&lt;li>&lt;strong>c&lt;/strong> # change #表示属性被修改过：所有者、所属组、权限&lt;/li>
&lt;li>&lt;strong>a&lt;/strong> # access #被访问过(被查看过)&lt;/li>
&lt;li>&lt;strong>m&lt;/strong> # modify #表示内容被修改过&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>第二部分
&lt;ul>
&lt;li>&lt;strong>time&lt;/strong> # 天&lt;/li>
&lt;li>&lt;strong>min&lt;/strong> # 分钟&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>逻辑连接符 #-a （and 逻辑与），-o （or 逻辑或)例：&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>-maxdepth &lt;!-- raw HTML omitted -->&lt;/strong> # 设置最大目录层级
&lt;ul>
&lt;li>例：find /home -maxdepth 1 -name *.log #查找/home 目录下 1 层的以.log 结尾的文件（即只查找当前目录，不查找当前目录下的子目录中的内容）&lt;/li>
&lt;li>-ls 假设 find 指令的回传值为 Ture，就将文件或目录名称列出到标准输出&lt;/li>
&lt;li>例：find /home -type d -ls #查找/home 目录下的文件夹，并列出这些文件夹的详细信息&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>ACTIONS 动作
&lt;strong>[ -exec 或者-ok command ] {} [];&lt;/strong>&lt;/p>
&lt;ol>
&lt;li>&lt;strong>-delete&lt;/strong> # 删除找到的文件。使用-delete 会自动打开“ -depth”选项。&lt;/li>
&lt;li>&lt;strong>-exec &lt;!-- raw HTML omitted -->&lt;/strong> # 假设 find 指令的回传值为 True，就执行该指令；-ok 与-exec 类似，只不过是交互型。
&lt;ol>
&lt;li>格式:find PATH 选项 选项内容 -exec COMMAND {} ;&lt;/li>
&lt;li>该格式的意思是使用 find 查找出来的内容放到{}中，再对{}中的内容逐条执行 COMMAND 命令&lt;/li>
&lt;li>它的终止是以;为结束标志的，所以这句命令后面的分号是不可缺少的，考虑到各个系统中分号会有不同的意义，所以前面加反斜杠。（反斜杠的意思参考正则表达式）&lt;/li>
&lt;li>{} 花括号里面存放前面 find 查找出来的文件名。&lt;/li>
&lt;li>注意：固定格式，只能这样写。注意中间的空格。&lt;/li>
&lt;/ol>
&lt;/li>
&lt;li>&lt;strong>-ok&lt;/strong> #&lt;/li>
&lt;/ol>
&lt;p>注意该语法格式中不要少了最后的分好和最后大括号周围的空格，-ok 为会询问，交互式&lt;/p>
&lt;h2 id="example">EXAMPLE&lt;/h2>
&lt;ul>
&lt;li>删除 /var/log/pods 目录下失效的符号链接
&lt;ul>
&lt;li>find -L /var/log/pods -type l -delete&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>找到/home 目录下的 samlee 用户的所有文件并删除
&lt;ul>
&lt;li>find /home -user samlee -exec rm –r {} ;&lt;/li>
&lt;li>注：rm -r 连带目录一起删除。报错原因：-exec 不适合大量传输，速率慢导致。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>查看当前目录下两天之前修改过得并且 10 分钟之内查看过得文件
&lt;ul>
&lt;li>find -mtime +2 -amin -10&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>查看当前目录下 7 天之内并且 2 天之前的文件
&lt;ul>
&lt;li>find -mtime -7 -a -mtime +2&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>在 etc 目录下查找大于 1k 并且小于 10k 的文件
&lt;ul>
&lt;li>find /etc -size +1k -a -size -10k&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>-inum 根据文件 i 节点查询
&lt;ul>
&lt;li>find ./ -inum 2310630 -exec rm {} ; #有一些文件的硬链接数量很多，有相同的 i 节点，查找其中一个文件的 i 节点号，一次性删除。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>find -maxdepth 1 -mtime +1 -exec ls -l {} ; #查找出来的如果是文件夹，那么就对这个文件夹执行该命命令，如下图所示，查找出来./test 等 3 个文件夹，那么就这三个文件夹执行 ls -l 的命令，即
&lt;ul>
&lt;li>ls -l ./test&lt;/li>
&lt;li>ls -l ./lichenhao&lt;/li>
&lt;li>ls -l ./lost+found&lt;/li>
&lt;li>注：查找出来的文字，一字不差的全部放在后面的{}中，等待 COMMAND 执行，所以没法列出目录的详细信息&lt;/li>
&lt;li>注意与-ls 参数的区别&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/idlpqz/1616166302372-29738c6b-f92a-43b5-9243-9aa5483629ca.jpeg" alt="">&lt;/p>
&lt;h3 id="查找重复文件">查找重复文件&lt;/h3>
&lt;p>在工作生活当中，我们很可能会遇到查找重复文件的问题。比如从某游戏提取的游戏文本有重复的，我们希望找出所有重复的文本，让翻译只翻译其中一份，而其他的直接替换。那么这个问题该怎么做呢？当然方法多种多样，而且无论那种方法应该都不会太难，但笔者第一次遇到这个问题的时候第一反应是是用 Linux 的 Shell 脚本，所以文本介绍这种方式。
先上代码：
&lt;code>find -not -empty -type f -printf &amp;quot;%sn&amp;quot; | sort -rn |uniq -d | xargs -I{} -n1 find -type f -size {}c -print0 | xargs -0 md5sum | sort | uniq -w32 --all-repeated=separate | cut -b 36-&lt;/code>
大家先 cd 到自己想要查找重复文件的文件夹，然后 copy 上面代码就可以了，系统会对当前文件夹及子文件夹内的所有文件进行查重。
下面分析一下上面的命令。
首先看第一句：
&lt;code>find -not -empty -type f -printf &amp;quot;%sn&amp;quot;&lt;/code>
find 是查找命令；-not -empty 是要寻找非空文件；-type f 是指寻找常规文件；-printf “%sn”比较具有迷惑性，这里的%s 并非 C 语言中的输出字符串，它实际表示的是文件的大小，单位为 bytes（不懂就 man，man 一下 find，就可以看到了），n 是换行符。所以这句话的意思是输出所有非空文件的大小。
通过管道，上面的结果被传到第二句：
&lt;code>sort -rn&lt;/code>
sort 是排序，-n 是指按大小排序，-r 是指从大到小排序（逆序 reverse）。
第三句：
&lt;code>uniq -d&lt;/code>
uniq 是把重复的只输出一次，而-d 指只输出重复的部分（如 9 出现了 5 次，那么就输出 1 个 9，而 2 只出现了 1 次，并非重复出现的数字，故不输出）。
第四句：
&lt;code>xargs -I{} -n1 find -type f -size {}c -print0&lt;/code>
这一部分分两部分看，第一部分是 xargs -I{} -n1，xargs 命令将之前的结果转化为参数，供后面的 find 调用，其中-I{}是指把参数写成{}，而-n1 是指将之前的结果一个一个输入给下一个命令（-n8 就是 8 个 8 个输入给下一句，不写-n 就是把之前的结果一股脑的给下一句）。后半部分是 find -type f -size {}c -print0，find 指令我们前面见过，-size{}是指找出大小为{}bytes 的文件，而-print0 则是为了防止文件名里带空格而写的参数。
第五句：
&lt;code>xargs -0 md5sum&lt;/code>
xargs 我们之前说过，是将前面的结果转化为输入，那么这个-0 又是什么意思？man 一下 xargs，我们看到-0 表示读取参数的时候以 null 为分隔符读取，这也不难理解，毕竟 null 的二进制表示就是 00。后面的 md5sum 是指计算输入的 md5 值。
第六句：sort 是排序，这个我们前面也见过。
第七句：
&lt;code>uniq -w32 --all-repeated=separate&lt;/code>
uniq -w32 是指寻找前 32 个字符相同的行，原因在于 md5 值一定是 32 位的，而后面的&amp;ndash;all-repeated=separate 是指将重复的部分放在一类，分类输出。
第八句：
&lt;code>cut -b 36-&lt;/code>
由于我们的结果带着 md5 值，不是很好看，所以我们截取 md5 值后面的部分，cut 是文本处理函数，这里-b 36-是指只要每行 36 个字符之后的部分。
我们将上述每个命令用管道链接起来，存入 result.txt：
&lt;code>find -not -empty -type f -printf &amp;quot;%sn&amp;quot; | sort -rn |uniq -d | xargs -I{} -n1 find -type f -size {}c -print0 | xargs -0 md5sum | sort | uniq -w32 --all-repeated=separate | cut -b 36- &amp;gt;result.txt&lt;/code>
虽然结果很好看，但是有一个问题，这是在 Linux 下很好看，实际上如果有朋友把输出文件放到 Windows 上，就会发现换行全没了，这是由于 Linux 下的换行是 n，而 windows 要求 nr，为了解决这个问题，我们最后执行一条指令，将 n 转换为 nr：
&lt;code>cat result.txt | cut -c 36- | tr -s 'n'&lt;/code>&lt;/p></description></item><item><title>Docs: lsof 列出打开的文件</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/x.linux-%E7%AE%A1%E7%90%86/linux-%E7%B3%BB%E7%BB%9F%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/%E7%A3%81%E7%9B%98-%E4%B8%8E-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7%E9%9B%86/lsof-%E5%88%97%E5%87%BA%E6%89%93%E5%BC%80%E7%9A%84%E6%96%87%E4%BB%B6/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/x.linux-%E7%AE%A1%E7%90%86/linux-%E7%B3%BB%E7%BB%9F%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/%E7%A3%81%E7%9B%98-%E4%B8%8E-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7%E9%9B%86/lsof-%E5%88%97%E5%87%BA%E6%89%93%E5%BC%80%E7%9A%84%E6%96%87%E4%BB%B6/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://man7.org/linux/man-pages/man8/lsof.8.html">Manual(手册)，lsof(8)&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>该工具以文件为主体，用于列出打开文件的进程，进程打开的端口(TCP、UDP)等、找回/恢复删除的文件。是十分方便的系统监视工具，因为 lsof 需要访问核心内存和各种文件，所以需要 root 用户执行。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">[&lt;/span>root@master0 ~&lt;span style="color:#f92672">]&lt;/span>&lt;span style="color:#75715e"># lsof | more&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>COMMAND PID TID USER FD TYPE DEVICE SIZE/OFF NODE NAME
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>systemd &lt;span style="color:#ae81ff">1&lt;/span> root cwd DIR 253,0 &lt;span style="color:#ae81ff">238&lt;/span> &lt;span style="color:#ae81ff">64&lt;/span> /
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>systemd &lt;span style="color:#ae81ff">1&lt;/span> root rtd DIR 253,0 &lt;span style="color:#ae81ff">238&lt;/span> &lt;span style="color:#ae81ff">64&lt;/span> /
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>systemd &lt;span style="color:#ae81ff">1&lt;/span> root txt REG 253,0 &lt;span style="color:#ae81ff">1612152&lt;/span> &lt;span style="color:#ae81ff">17149941&lt;/span> /usr/lib/systemd/systemd
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>......
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>kthreadd &lt;span style="color:#ae81ff">2&lt;/span> root cwd DIR 253,0 &lt;span style="color:#ae81ff">238&lt;/span> &lt;span style="color:#ae81ff">64&lt;/span> /
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>kthreadd &lt;span style="color:#ae81ff">2&lt;/span> root rtd DIR 253,0 &lt;span style="color:#ae81ff">238&lt;/span> &lt;span style="color:#ae81ff">64&lt;/span> /
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>kthreadd &lt;span style="color:#ae81ff">2&lt;/span> root txt unknown /proc/2/exe
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>......
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>lsof &lt;span style="color:#ae81ff">1893&lt;/span> root mem REG 253,0 &lt;span style="color:#ae81ff">155784&lt;/span> &lt;span style="color:#ae81ff">72860&lt;/span> /usr/lib64/libselinux.so.1
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>lsof &lt;span style="color:#ae81ff">1893&lt;/span> root mem REG 253,0 &lt;span style="color:#ae81ff">164240&lt;/span> &lt;span style="color:#ae81ff">41015&lt;/span> /usr/lib64/ld-2.17.so
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>lsof &lt;span style="color:#ae81ff">1893&lt;/span> root 4r FIFO 0,9 0t0 &lt;span style="color:#ae81ff">37707&lt;/span> pipe
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>lsof &lt;span style="color:#ae81ff">1893&lt;/span> root 7w FIFO 0,9 0t0 &lt;span style="color:#ae81ff">37708&lt;/span> pipe
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>每行显示一个打开的文件，若不指定条件默认将显示所有进程打开的所有文件。lsof 输出各列信息的意义如下：&lt;/p>
&lt;p>COMMAND 进程的名称 | PID 进程标识符 | USER 进程所有者 | FD 文件描述符 | TYPE 文件类型 | DEVICE 磁盘的名称 | SIZE 文件的大小 | NODE 索引节点 | NAME 文件的绝对路径&lt;/p>
&lt;h2 id="fd--表示该文件被打开的-fd-号或其他信息">FD # 表示该文件被打开的 FD 号或其他信息&lt;/h2>
&lt;ul>
&lt;li>cwd：表示 current work dirctory，即：应用程序的当前工作目录，这是该应用程序启动的目录，除非它本身对这个目录进行更改&lt;/li>
&lt;li>txt # 该类型的文件是程序代码，如应用程序二进制文件本身或共享库，如上列表中显示的 /sbin/init 程序&lt;/li>
&lt;li>er # FD 信息错误(参考 NAME 列);&lt;/li>
&lt;li>ltx：shared library text (code and data);&lt;/li>
&lt;li>mxx ：hex memory-mapped type number xx.&lt;/li>
&lt;li>mem # 内存映射文件&lt;/li>
&lt;li>mmap # memory-mapped device;&lt;/li>
&lt;li>pd # 父目录&lt;/li>
&lt;li>rtd # root 目录&lt;/li>
&lt;li>v86 VP/ix mapped file;&lt;/li>
&lt;li>0：表示标准输出&lt;/li>
&lt;li>1：表示标准输入&lt;/li>
&lt;li>2：表示标准错误&lt;/li>
&lt;/ul>
&lt;blockquote>
&lt;p>一般在标准输出、标准错误、标准输入后还跟着文件状态模式：r、w、u 等&lt;/p>
&lt;/blockquote>
&lt;ul>
&lt;li>u：表示该文件被打开并处于读取/写入模式&lt;/li>
&lt;li>r：表示该文件被打开并处于只读模式&lt;/li>
&lt;li>w：表示该文件被打开并处于&lt;/li>
&lt;li>空格 # 表示该文件的状态模式为 unknow，且没有锁定&lt;/li>
&lt;li>&lt;code>-&lt;/code> # 表示该文件的状态模式为 unknow，且被锁定&lt;/li>
&lt;/ul>
&lt;p>同时在文件状态模式后面，还跟着相关的锁&lt;/p>
&lt;ul>
&lt;li>N：for a Solaris NFS lock of unknown type;&lt;/li>
&lt;li>r：for read lock on part of the file;&lt;/li>
&lt;li>R：for a read lock on the entire file;&lt;/li>
&lt;li>w：for a write lock on part of the file;（文件的部分写锁）&lt;/li>
&lt;li>W：for a write lock on the entire file;（整个文件的写锁）&lt;/li>
&lt;li>u：for a read and write lock of any length;&lt;/li>
&lt;li>U：for a lock of unknown type;&lt;/li>
&lt;li>x：for an SCO OpenServer Xenix lock on part of the file;&lt;/li>
&lt;li>X：for an SCO OpenServer Xenix lock on the entire file;&lt;/li>
&lt;li>space：if there is no lock.&lt;/li>
&lt;/ul>
&lt;h2 id="type--文件类型">TYPE # 文件类型&lt;/h2>
&lt;ul>
&lt;li>DIR：表示目录&lt;/li>
&lt;li>CHR：表示字符类型&lt;/li>
&lt;li>BLK：块设备类型&lt;/li>
&lt;li>UNIX： UNIX 域套接字&lt;/li>
&lt;li>FIFO：先进先出 (FIFO) 队列&lt;/li>
&lt;li>IPv4：网际协议 (IP) 套接字&lt;/li>
&lt;li>&amp;hellip;&amp;hellip;.&lt;/li>
&lt;/ul>
&lt;h1 id="syntax语法">Syntax(语法)&lt;/h1>
&lt;p>&lt;strong>lsof [ -?abChKlnNOPRtUvVX ] [ -A A ] [ -c c ] [ +c c ] [ +|-d d ] [ +|-D D ] [ +|-e s ] [ +|-f [cfgGn] ] [ -F [f] ] [ -g [s] ] [ -i [i] ] [ -k k] [ +|-L [l] ] [ +|-m m ] [ +|-M ] [ -o [o] ] [ -p s ] [ +|-r [t[m&amp;lt;fmt&amp;gt;]] ] [ -s [p:s] ] [ -S [t] ] [ -T [t] ] [ -u s ] [ +|-w ] [ -x [fl] ] [ -z [z] ] [ -Z [Z] ] [ &amp;ndash; ] [names]&lt;/strong>&lt;/p>
&lt;h2 id="options">OPTIONS&lt;/h2>
&lt;ul>
&lt;li>&lt;strong>-a&lt;/strong> # 过滤选项之间进行 AND 运算。比如我使用 -d 和 -p，则结果要两个筛选都满足才可以。默认情况是 或 运算。列出满足任意过滤选项的所有结果。
&lt;ul>
&lt;li>说白了，这 -a 选项就是个逻辑运算符。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>-c &amp;lt;STRING&amp;gt;&lt;/strong> # 列出以 STRING 字符开头的命令的进程的文件列表。其实就是通过进程名筛选&lt;/li>
&lt;li>&lt;strong>+d &amp;lt;DIR&amp;gt;&lt;/strong> # 列出目录下被打开的文件&lt;/li>
&lt;li>&lt;strong>-d &amp;lt;FD&amp;gt;&lt;/strong> # 列出占用指定文件描述符的进程。可以使用 2-10 这种方式来列出 2 到 10 号描述符的文件。&lt;/li>
&lt;li>&lt;strong>+D &amp;lt;DIR&amp;gt;&lt;/strong> # 递归列出目录下被打开的文件&lt;/li>
&lt;li>&lt;strong>-g &amp;lt;GroupID&amp;gt;&lt;/strong> # 列出 GID 号进程详情&lt;/li>
&lt;li>&lt;strong>-i &amp;lt;STRING&amp;gt;&lt;/strong> # 列出符合条件的网络连接相关。（4、6、协议、:PORT、 @IP ）&lt;/li>
&lt;li>&lt;strong>-N &amp;lt;DIR&amp;gt;&lt;/strong> # 列出使用 NFS 的文件&lt;/li>
&lt;li>&lt;strong>-p &amp;lt;PID[,PID,PID&amp;hellip;.]&amp;gt;&lt;/strong> # 列出指定进程号所打开的文件。多个 PID 以逗号分隔&lt;/li>
&lt;li>&lt;strong>-u &amp;lt;USERNAME&amp;gt;&lt;/strong> # 列出指定用户所打开的文件&lt;/li>
&lt;li>&lt;strong>-w&lt;/strong> # 关闭程序运行中产生的警告信息。&lt;/li>
&lt;/ul>
&lt;p>输出格式化&lt;/p>
&lt;ul>
&lt;li>&lt;strong>-n&lt;/strong> # 直接显示 IP 而不是主机名&lt;/li>
&lt;li>&lt;strong>-P&lt;/strong> # 直接显示端口号，而不是端口号的名称&lt;/li>
&lt;li>&lt;strong>-t&lt;/strong> # 仅输出进程的 PID&lt;/li>
&lt;/ul>
&lt;h1 id="example">EXAMPLE&lt;/h1>
&lt;ul>
&lt;li>查看谁正在使用某个文件，也就是说查找某个文件相关的进程
&lt;ul>
&lt;li>&lt;strong>lsof /bin/bash&lt;/strong>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>显示除了 root 用户下的 sshd 进程所用的文件
&lt;ul>
&lt;li>&lt;strong>lsof -u ^root -c sshd&lt;/strong>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>列出目前连接主机 peida.linux 上端口为：20，21，22，25，53，80 相关的所有文件信息，且每隔 3 秒不断的执行 lsof 指令
&lt;ul>
&lt;li>&lt;strong>lsof -i @peida.linux:20,21,22,25,53,80 -r 3&lt;/strong>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>列出所有的网络连接
&lt;ul>
&lt;li>&lt;strong>lsof -i&lt;/strong>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>列出所有 tcp 网络连接信息
&lt;ul>
&lt;li>&lt;strong>lsof -i tcp&lt;/strong>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>列出正在使用 3306 端口的进程信息
&lt;ul>
&lt;li>lsof -i :3306&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>列出 9267 号进程打开的文件描述符为 132 的文件
&lt;ul>
&lt;li>lsof -p 9267 -d 132 -a&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>列出 9267 号进程打开的所有文件，以及文件描述符为 132 的所有文件
&lt;ul>
&lt;li>lsof -p 9267 -d 13&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>列出谁在使用某个特定的 udp 端口
&lt;ul>
&lt;li>lsof -i udp:55&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>列出某个用户的所有活跃的网络端口
&lt;ul>
&lt;li>lsof -a -u test -i&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul></description></item><item><title>Docs: pt-ioprofile</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/x.linux-%E7%AE%A1%E7%90%86/linux-%E7%B3%BB%E7%BB%9F%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/%E7%A3%81%E7%9B%98-%E4%B8%8E-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7%E9%9B%86/pt-ioprofile/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/x.linux-%E7%AE%A1%E7%90%86/linux-%E7%B3%BB%E7%BB%9F%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/%E7%A3%81%E7%9B%98-%E4%B8%8E-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7%E9%9B%86/pt-ioprofile/</guid><description>
&lt;h2 id="概述">概述&lt;/h2>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://www.percona.com/doc/percona-toolkit/LATEST/pt-ioprofile.html#environment">官方文档&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>pt-ioprofile 是 &lt;a href="https://www.percona.com/">Percona &lt;/a>出的 IO 查看工具。Percona 用来监视进程 IO 并打印文件和 I/O 活动表。&lt;/p>
&lt;p>&lt;strong>pt-ioprofile&lt;/strong> 本质上就是一个 shell 脚本，只做两件事：&lt;/p>
&lt;ol>
&lt;li>通过 lsof 和 strace 两个工具获取指定进程的一段时间的数据，并保存到文件中&lt;/li>
&lt;li>使用 awk 等工具聚合两个文件的内容。&lt;/li>
&lt;/ol>
&lt;p>&lt;strong>pt-ioprofile&lt;/strong> 使用 strace 和 lsof 工具监视进程的 IO 并打印出一个文件和 I/O 活动表。默认情况下，它监视 mysqld 进程 30 秒。输出如下：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>Tue Dec &lt;span style="color:#ae81ff">27&lt;/span> 15:33:57 PST &lt;span style="color:#ae81ff">2011&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Tracing process ID &lt;span style="color:#ae81ff">1833&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> total read write lseek ftruncate filename
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> 0.000150 0.000029 0.000068 0.000038 0.000015 /tmp/ibBE5opS
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ul>
&lt;li>read：从文件中读出数据。要读取的文件用文件描述符标识，数据读入一个事先定义好的缓冲区。&lt;/li>
&lt;li>write：把缓冲区的数据写入文件中。&lt;/li>
&lt;li>pread：由于 lseek 和 read 调用之间，内核可能会临时挂起进程，所以对同步问题造成了问题，调用 pread 相当于顺序调用了 lseek 和 read，这两个操作相当于一个捆绑的原子操作。&lt;/li>
&lt;li>pwrite：由于 lseek 和 write 调用之间，内核可能会临时挂起进程，所以对同步问题造成了问题，调用 pwrite 相当于顺序调用了 lseek 和 write，这两个操作相当于一个捆绑的原子操作。&lt;/li>
&lt;li>fsync：确保文件所有已修改的内容已经正确同步到硬盘上，该调用会阻塞等待直到设备报告 IO 完成。&lt;/li>
&lt;li>open：打开一个文件，并返回这个文件的描述符。&lt;/li>
&lt;li>close：close 系统调用用于“关闭”一个文件，close 调用终止一个文件描述符以其文件之间的关联。文件描述符被释放，并能够重新使用。&lt;/li>
&lt;li>lseek：对文件描述符指定文件的读写指针进行设置，也就是说，它可以设置文件的下一个读写位置。&lt;/li>
&lt;li>fcntl：针对(文件)描述符提供控制。&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>pt-ioprofile&lt;/strong> 通过使用 附加&lt;code>strace&lt;/code>到进程来工作&lt;code>ptrace()&lt;/code>，这将使其运行非常缓慢，直到&lt;code>strace&lt;/code>分离。除了冻结服务器之外，还有一些风险，即进程在与服务器&lt;code>strace&lt;/code>分离后崩溃或性能不佳，或者&lt;code>strace&lt;/code>没有完全分离并使进程处于睡眠状态。因此，这应该被视为一种侵入性工具，除非您对此感到满意，否则不应在生产服务器上使用。&lt;/p>
&lt;p>&lt;strong>WARNING&lt;/strong>: &lt;strong>pt-ioprofile&lt;/strong> freezes the server and may crash the process, or make it perform badly after detaching, or leave it in a sleeping state! Before using this tool, please:&lt;/p>
&lt;ul>
&lt;li>Read the tool’s documentation&lt;/li>
&lt;li>Review the tool’s known “BUGS”&lt;/li>
&lt;li>Test the tool on a non-production server&lt;/li>
&lt;li>Backup your production server and verify the backups&lt;/li>
&lt;/ul>
&lt;blockquote>
&lt;p>&lt;strong>pt-ioprofile&lt;/strong> should be considered an intrusive tool, and should not be used on production servers unless you understand and accept the risks.&lt;/p>
&lt;/blockquote>
&lt;h2 id="安装">安装&lt;/h2>
&lt;p>从 &lt;a href="https://www.percona.com/downloads/percona-toolkit/LATEST/">https://www.percona.com/downloads/percona-toolkit/LATEST/&lt;/a> 选择指定环境下的指定版本下载安装包&lt;/p>
&lt;h2 id="syntax语法">Syntax(语法)&lt;/h2>
&lt;p>&lt;strong>pt-ioprofile [OPTIONS] [FILE]&lt;/strong>&lt;/p>
&lt;p>&lt;strong>OPTIONS&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>&lt;strong>&amp;ndash;aggregate, -a&lt;/strong> # 聚合结果的方式，可用的值有 sum 与 avg。&lt;code>默认值：sum&lt;/code>&lt;/li>
&lt;li>如果求和，则每个单元格将包含其中的值的总和。如果 avg，则每个单元格将包含其中值的平均值。&lt;/li>
&lt;li>&lt;strong>&amp;ndash;cell, -c &lt;!-- raw HTML omitted -->&lt;/strong> # 统计的数据。&lt;code>默认值：times&lt;/code>
&lt;ul>
&lt;li>count  # I/O 次数&lt;/li>
&lt;li>sizes  # I/O 大小&lt;/li>
&lt;li>times  # I/O 时间&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>&amp;ndash;group-by, -g &lt;!-- raw HTML omitted -->&lt;/strong> # 对输出结果进行分组 &lt;code>默认值：filename&lt;/code>
&lt;ul>
&lt;li>all # 所有输出都在一行&lt;/li>
&lt;li>filename # 每个文件名输出一行&lt;/li>
&lt;li>pid # 每个进程 ID 输出一行&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>&amp;ndash;profile-pid &lt;!-- raw HTML omitted -->&lt;/strong> # 指定要分析的进程的 PID，该值会覆盖 &amp;ndash;profile-process 选项。&lt;/li>
&lt;li>&lt;strong>&amp;ndash;profile-process &lt;!-- raw HTML omitted -->&lt;/strong> # 指定要分析的进程名称。&lt;code>默认值：mysqld&lt;/code>&lt;/li>
&lt;li>&lt;strong>&amp;ndash;run-time &lt;!-- raw HTML omitted -->&lt;/strong> # 程序运行时长，单位秒。&lt;code>默认值：30&lt;/code>&lt;/li>
&lt;li>&lt;strong>&amp;ndash;save-samples &lt;!-- raw HTML omitted -->&lt;/strong> # 将 strace 与 lsof 的输出结果保存到指定的 FILE 中。&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>EXAMPLE&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>pt-ioprofile -p=9267 &amp;ndash;cell=sizes&lt;/li>
&lt;/ul>
&lt;h2 id="问题">问题&lt;/h2>
&lt;p>原文：&lt;a href="https://tusundong.top/post/centos7-pt-ioprofile.html">https://tusundong.top/post/centos7-pt-ioprofile.html&lt;/a>
最近在排查 io wait 需要使用到 pt-ioprofile，结果发现在 CentOS7.8 下执行没有结果。
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/zgyenr/1622780378714-e4fa5820-6042-4558-9cbd-51fc885b6dc0.png" alt="">
最后在大神&lt;code>@轻松的鱼&lt;/code>指导下，修改源码，编辑 /usr/bin/pt-ioprofile 文件，添加此行&lt;/p>
&lt;pre>&lt;code>• /^strace: Process/ { mode = &amp;quot;strace&amp;quot;; }
&lt;/code>&lt;/pre>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/zgyenr/1622780378720-19f72459-84e1-448e-81d2-7fe581bdb917.png" alt="">&lt;/p></description></item><item><title>Docs: tar与gzip</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/x.linux-%E7%AE%A1%E7%90%86/linux-%E7%B3%BB%E7%BB%9F%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/%E7%A3%81%E7%9B%98-%E4%B8%8E-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7%E9%9B%86/tar%E4%B8%8Egzip/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/x.linux-%E7%AE%A1%E7%90%86/linux-%E7%B3%BB%E7%BB%9F%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/%E7%A3%81%E7%9B%98-%E4%B8%8E-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7%E9%9B%86/tar%E4%B8%8Egzip/</guid><description>
&lt;h1 id="tar">tar&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://man7.org/linux/man-pages/man1/tar.1.html">Manual(手册),tar(1)&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>tar 是一个归档工具&lt;/p>
&lt;h2 id="syntax语法">Syntax(语法)&lt;/h2>
&lt;p>&lt;strong>tar [OPTIONS] /PATH/FILE&lt;/strong>
OPTIONS:&lt;/p>
&lt;ul>
&lt;li>**-f **# 指定被处理的文件（在所有选项里一定要放最后一个，否则会报错）&lt;/li>
&lt;li>&lt;strong>-x&lt;/strong> # 解包文件&lt;/li>
&lt;li>&lt;strong>-c&lt;/strong> # 打包文件&lt;/li>
&lt;li>**-C, &amp;ndash;directory=&amp;lt;DIR&amp;gt; **# 解包到指定目录&lt;/li>
&lt;li>**-v **# 显示执行命令时的详细过程&lt;/li>
&lt;li>&lt;strong>-t&lt;/strong> # 查看已经打包的文件中的内容&lt;/li>
&lt;li>&lt;strong>-z&lt;/strong> # 通过 gzip 指令处理打包的文件；&lt;/li>
&lt;li>&lt;strong>&amp;ndash;strip-components=NUM&lt;/strong> # 去除前缀目录，i.e.默认会自动创建与压缩包同名的目录来存放压缩包内的文件，当 NUM 为 1 时，则不再创建该目录，直接将压缩包内的文件全部解压到当前目录&lt;/li>
&lt;/ul>
&lt;p>EXAMPLE:&lt;/p>
&lt;ul>
&lt;li>tar -zcvf xxx.tar.gz /tmp/test/* # 把/tmp/test/下所有的文件和目录都打包并压缩成 xxx.tar.gz&lt;/li>
&lt;li>tar -zxvf xxx.tar.gz [-C /XXX] # 解压 xxx.tar.gz 文件（加-C /tmp/test2/ 指定解压缩的路径，解压缩到/tmp/test2/目录下）&lt;/li>
&lt;li>tar -tvf xxx.tar.gz # 不解包查看压缩文件里有哪些文件和目录&lt;/li>
&lt;li>zcat xxx.tar.gz # 读取打包文件的内容等详细信息&lt;/li>
&lt;/ul>
&lt;h1 id="gzip">gzip&lt;/h1>
&lt;p>命令用来压缩文件。gzip 是个使用广泛的压缩程序，文件经它压缩过后，其名称后面会多处“.gz”扩展名。&lt;/p>
&lt;p>gzip 是在 Linux 系统中经常使用的一个对文件进行压缩和解压缩的命令，既方便又好用。gzip 不仅可以用来压缩大的、较少使用的文件以节省磁盘空间，还可以和 tar 命令一起构成 Linux 操作系统中比较流行的压缩文件格式。据统计，gzip 命令对文本文件有 60%～ 70%的压缩率。减少文件大小有两个明显的好处，一是可以减少存储空间，二是通过网络传输文件时，可以减少传输的时间。&lt;/p>
&lt;h2 id="syntax语法-1">Syntax(语法)&lt;/h2>
&lt;p>&lt;strong>gzip [OPTIONS] /PATH/FILE&lt;/strong>&lt;/p>
&lt;p>&lt;strong>OPTINOS&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>&lt;strong>-l&lt;/strong> # 列出压缩文件的详细信息&lt;/li>
&lt;li>&lt;strong>-d&lt;/strong> # 解开压缩文件&lt;/li>
&lt;li>&lt;strong>-n&lt;/strong> # 压缩文件时，不保存原来的文件名称及时间戳记；&lt;/li>
&lt;li>&lt;strong>-N&lt;/strong> # 压缩文件时，保存原来的文件名称及时间戳记&lt;/li>
&lt;li>**-r **# 递归处理，将指定目录下的所有文件及子目录一并处理，该处理方式是把文件夹下的每一个文件都压缩成一个新的文件，不是对目录整体进行，注意与 tar 的区别&lt;/li>
&lt;li>&lt;strong>-v&lt;/strong> # 显示指令执行过程&lt;/li>
&lt;li>-&amp;lt;压缩效率&amp;gt;：压缩效率是一个介于 1~9 的数值，默认值为 6，指定越大的数值，压缩效率就会越高&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>EXAMPLE&lt;/strong>
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/xft64c/1616166289989-3b7ed972-966f-410f-a3e8-78d2e6836881.jpeg" alt="">&lt;/p>
&lt;ul>
&lt;li>gzip -r .backup # 递归压缩.backup 目录下的所有文件以及子目录的文件，效果如右图所示，压缩只能对单个文件压缩，注意与 tar 打包命令的区别&lt;/li>
&lt;/ul>
&lt;h1 id="常见问题">常见问题&lt;/h1>
&lt;p>当我们在 Linux 中使用绝对路径归档文件时，会出现如下提示：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>$ tar -zcvf test.tar.gz /mnt/d/Projects/DesistDaydream/go-learning/test_files
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>tar: Removing leading &lt;span style="color:#e6db74">`&lt;/span>/&lt;span style="color:#960050;background-color:#1e0010">&amp;#39;&lt;/span> from member names
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>tar 工具会提示我们将开头的 &lt;code>/&lt;/code> 移除，这是出于安全考虑，如果我们使用绝对路径归档文件，当我们提取这些文件时，就会覆盖原本的文件，这有可能会产生很严重的影响&lt;/p>
&lt;h1 id="通过其他工具查看-targz-中的内容">通过其他工具查看 tar.gz 中的内容&lt;/h1>
&lt;p>得益于 Linux 社区，有很多命令行工具可以来达成上面的目标。下面就让我们来看看使用它们的一些示例。&lt;/p>
&lt;h2 id="使用-vim-工具">使用 vim 工具&lt;/h2>
&lt;p>vim 不只是一个编辑器，使用它我们可以干很多事情。下面的命令展示的是在没有解压的情况下使用 vim 查看一个压缩的归档文件的内容：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">&amp;#34; tar.vim version v29
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span> Browsing tarfile /root/projects/keepalived-ehualu-2.0.20.tar.gz
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">&amp;#34; Select a file with cursor and press ENTER
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">keepalived/
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">keepalived/config/
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">keepalived/config/check_ports.sh
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">keepalived/config/keepalived.conf
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">keepalived/docker-compose-backup.yaml
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">keepalived/docker-compose-master.yaml
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">keepalived/README.md
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>无需解压如何查看一个归档或压缩文件的内容无需解压如何查看一个归档或压缩文件的内容&lt;/p>
&lt;p>你甚至还可以浏览归档文件的内容，打开其中的文本文件（假如有的话）。要打开一个文本文件，只需要用方向键将鼠标的游标放置到文件的前面，然后敲 ENTER 键来打开它。&lt;/p>
&lt;h2 id="使用-tar-命令">使用 tar 命令&lt;/h2>
&lt;p>为了列出一个 tar 归档文件的内容，可以运行：&lt;/p>
&lt;p>$ tar -tf ostechnix.tar
ostechnix/
ostechnix/image.jpg
ostechnix/file.pdf
ostechnix/song.mp3&lt;/p>
&lt;p>或者使用-v 选项来查看归档文件的具体属性，例如它的文件所有者、属组、创建日期等等。
$ tar -tvf ostechnix.tar
drwxr-xr-x sk/users 0 2018-07-02 19:30 ostechnix/
-rw-r&amp;ndash;r&amp;ndash; sk/users 53632 2018-06-29 15:57 ostechnix/image.jpg
-rw-r&amp;ndash;r&amp;ndash; sk/users 156831 2018-06-04 12:37 ostechnix/file.pdf
-rw-r&amp;ndash;r&amp;ndash; sk/users 9702219 2018-04-25 20:35 ostechnix/song.mp3&lt;/p>
&lt;h2 id="使用-rar-命令">使用 rar 命令&lt;/h2>
&lt;p>要查看一个 rar 文件的内容，只需要执行：
$ rar v ostechnix.rar
RAR 5.60 Copyright (c) 1993-2018 Alexander Roshal 24 Jun 2018
Trial version Type &amp;lsquo;rar -?&amp;rsquo; for help
Archive: ostechnix.rar
Details: RAR 5
Attributes Size Packed Ratio Date Time Checksum Name
-&amp;mdash;&amp;mdash;&amp;mdash;- &amp;mdash;&amp;mdash;&amp;mdash; &amp;mdash;&amp;mdash;&amp;ndash; &amp;mdash;&amp;ndash; &amp;mdash;&amp;mdash;&amp;mdash;- &amp;mdash;&amp;ndash; &amp;mdash;&amp;mdash;&amp;ndash; &amp;mdash;-
rw-r&amp;ndash;r&amp;ndash; 53632 52166 97% 2018-06-29 15:57 70260AC4 ostechnix/image.jpg
-rw-r&amp;ndash;r&amp;ndash; 156831 139094 88% 2018-06-04 12:37 C66C545E ostechnix/file.pdf
-rw-r&amp;ndash;r&amp;ndash; 9702219 9658527 99% 2018-04-25 20:35 DD875AC4 ostechnix/song.mp3
-&amp;mdash;&amp;mdash;&amp;mdash; &amp;mdash;&amp;mdash;&amp;mdash; &amp;mdash;&amp;mdash;&amp;ndash; &amp;mdash;&amp;ndash; &amp;mdash;&amp;mdash;&amp;mdash;- &amp;mdash;&amp;ndash; &amp;mdash;&amp;mdash;&amp;ndash; &amp;mdash;-
9912682 9849787 99% 3&lt;/p>
&lt;h2 id="使用-unrar-命令">使用 unrar 命令&lt;/h2>
&lt;p>你也可以使用带有 l 选项的 unrar 来做到与上面相同的事情，展示如下：
$ unrar l ostechnix.rar
UNRAR 5.60 freeware Copyright (c) 1993-2018 Alexander Roshal
Archive: ostechnix.rar
Details: RAR 5
Attributes Size Date Time Name
-&amp;mdash;&amp;mdash;&amp;mdash;- &amp;mdash;&amp;mdash;&amp;mdash; &amp;mdash;&amp;mdash;&amp;mdash;- &amp;mdash;&amp;ndash; &amp;mdash;-
rw-r&amp;ndash;r&amp;ndash; 53632 2018-06-29 15:57 ostechnix/image.jpg
-rw-r&amp;ndash;r&amp;ndash; 156831 2018-06-04 12:37 ostechnix/file.pdf
-rw-r&amp;ndash;r&amp;ndash; 9702219 2018-04-25 20:35 ostechnix/song.mp3
-&amp;mdash;&amp;mdash;&amp;mdash;- &amp;mdash;&amp;mdash;&amp;mdash; &amp;mdash;&amp;mdash;&amp;mdash;- &amp;mdash;&amp;ndash; &amp;mdash;-
9912682 3&lt;/p>
&lt;h2 id="使用-zip-命令">使用 zip 命令&lt;/h2>
&lt;p>为了查看一个 zip 文件的内容而无需解压它，可以使用下面的 zip 命令：
$ zip -sf ostechnix.zip
Archive contains:
Life advices.jpg
Total 1 entries (597219 bytes)&lt;/p>
&lt;h2 id="使用-unzip-命令">使用 unzip 命令&lt;/h2>
&lt;p>你也可以像下面这样使用 -l 选项的 unzip 命令来呈现一个 zip 文件的内容：
$ unzip -l ostechnix.zip
Archive: ostechnix.zip
Length Date Time Name
-&amp;mdash;&amp;mdash;&amp;ndash; &amp;mdash;&amp;mdash;&amp;mdash;- &amp;mdash;&amp;ndash; &amp;mdash;-
597219 2018-04-09 12:48 Life advices.jpg
-&amp;mdash;&amp;mdash;- &amp;mdash;&amp;mdash;-
597219 1 file&lt;/p>
&lt;h2 id="使用-zipinfo-命令">使用 zipinfo 命令&lt;/h2>
&lt;p>$ zipinfo ostechnix.zip
Archive: ostechnix.zip
Zip file size: 584859 bytes, number of entries: 1
-rw-r&amp;ndash;r&amp;ndash; 6.3 unx 597219 bx defN 18-Apr-09 12:48 Life advices.jpg
1 file, 597219 bytes uncompressed, 584693 bytes compressed: 2.1%&lt;/p>
&lt;p>如你所见，上面的命令展示了一个 zip 文件的内容、它的权限、创建日期和压缩百分比等等信息。&lt;/p>
&lt;h2 id="使用-zcat-命令">使用 zcat 命令&lt;/h2>
&lt;p>要一个压缩的归档文件的内容而不解压它，使用 zcat 命令，我们可以得到：
$ zcat ostechnix.tar.gz
zcat 和 gunzip -c 命令相同。所以你可以使用下面的命令来查看归档或者压缩文件的内容：
$ gunzip -c ostechnix.tar.gz&lt;/p>
&lt;h2 id="使用-zless-命令">使用 zless 命令&lt;/h2>
&lt;p>要使用 zless 命令来查看一个归档或者压缩文件的内容，只需：
$ zless ostechnix.tar.gz&lt;/p>
&lt;p>这个命令类似于 less 命令，它将一页一页地展示其输出。&lt;/p>
&lt;h2 id="使用-less-命令">使用 less 命令&lt;/h2>
&lt;p>可能你已经知道 less 命令可以打开文件来交互式地阅读它，并且它支持滚动和搜索。&lt;/p>
&lt;p>运行下面的命令来使用 less 命令查看一个归档或者压缩文件的内容：&lt;/p>
&lt;p>$ less ostechnix.tar.gz&lt;/p></description></item><item><title>Docs: 磁盘与文件系统管理工具集</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/x.linux-%E7%AE%A1%E7%90%86/linux-%E7%B3%BB%E7%BB%9F%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/%E7%A3%81%E7%9B%98-%E4%B8%8E-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7%E9%9B%86/%E7%A3%81%E7%9B%98%E4%B8%8E%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7%E9%9B%86/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/x.linux-%E7%AE%A1%E7%90%86/linux-%E7%B3%BB%E7%BB%9F%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/%E7%A3%81%E7%9B%98-%E4%B8%8E-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7%E9%9B%86/%E7%A3%81%E7%9B%98%E4%B8%8E%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7%E9%9B%86/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;/blockquote>
&lt;h1 id="磁盘分区管理工具">磁盘分区管理工具&lt;/h1>
&lt;h2 id="parted">Parted&lt;/h2>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="http://www.gnu.org/software/parted">GNU 官网-软件-parted&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://man7.org/linux/man-pages/man8/parted.8.html">Manual(手册),parted(8)&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>Parted 是一个 &lt;strong>partition(分区)&lt;/strong> 操作程序，支持对 2T 以上硬盘的分区，支持 GTP 分区表，如果直接输入 parted 命令则进入 parted 工具，以交互式方式对 DEVICE 进行操作。&lt;/p>
&lt;p>Parted 程序在 CentOS 和 Ubuntu 中都属于 parted 包，这个包中有两个程序，&lt;code>parted&lt;/code> 与 &lt;code>partprobe&lt;/code>&lt;/p>
&lt;p>parted 程序可以在交互模式中运行，当 parted 运行在交互模式中时，对磁盘进行的操作，只有在执行 &lt;code>quit&lt;/code> 命令后，才会将更新通知给 Linux 内核&lt;/p>
&lt;h3 id="syntax语法">Syntax(语法)&lt;/h3>
&lt;p>&lt;strong>parted [OPTIONS] [DEVICE [COMMAND [ARGUMENT&amp;hellip;]&amp;hellip;]]&lt;/strong>&lt;/p>
&lt;p>&lt;strong>OPTIONS&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>&lt;strong>-a, &amp;ndash;align=[none|cyl|min|opt]&lt;/strong> # alignment for new partitions&lt;/li>
&lt;li>&lt;strong>-l, &amp;ndash;list&lt;/strong> # 列出所有块设备上的分区布局，i.e.列出所有磁盘的分区&lt;/li>
&lt;li>&lt;strong>-m, &amp;ndash;machine&lt;/strong> # 与 -l 选项配合， 显示出机器可以解析的输出内容&lt;/li>
&lt;li>&lt;strong>-s, &amp;ndash;script&lt;/strong> # never prompts for user intervention&lt;/li>
&lt;/ul>
&lt;h4 id="command">COMMAND&lt;/h4>
&lt;p>&lt;strong>align-check &amp;lt;ALIGN-TYPE&amp;gt; &amp;lt;DEVICE&amp;gt;&lt;/strong> # 检查指定分区是否对齐&lt;/p>
&lt;ul>
&lt;li>ALIGN-TYPE
&lt;ul>
&lt;li>minimal #&lt;/li>
&lt;li>optimal #&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>select &amp;lt;DEVICE&amp;gt;&lt;/strong> # 选择对 DEVICE 磁盘进行操作&lt;/p>
&lt;p>&lt;strong>mklable &amp;lt;LABEL-TYPE&amp;gt;&lt;/strong> # 创建一个新的 Disk Label(磁盘标签)。
Disk Label 其实就是 Partition Table(分区表)，也有的人称为 Partition Map(分区图)
这个行为会虽然不会导致磁盘所有数据丢失，但是却无法使用这些数据，如果想要恢复，可以通过恢复模式，参考&lt;a href="https://www.gnu.org/software/parted/manual/parted.html#Related-information">这里&lt;/a>进行恢复。当为一个已经有磁盘标签的磁盘创建标签时，将会出现如下提示：
&lt;code>Warning: The existing disk label on /dev/vdb will be destroyed and all data on this disk will be lost. Do you want to continue?&lt;/code>&lt;/p>
&lt;ul>
&lt;li>LABEL-TYPE
&lt;ul>
&lt;li>bsd&lt;/li>
&lt;li>loop # 这个标签通常用于 LVM 类型的磁盘上，带有这种标签的磁盘，其实是没有分区表的。&lt;/li>
&lt;li>gpt # 这个类型的标签就是 GPT 分区表&lt;/li>
&lt;li>msdos # 这个类型的标签就是 MBR 分区表&lt;/li>
&lt;li>pc98&lt;/li>
&lt;li>sun&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>Model: Virtio Block Device &lt;span style="color:#f92672">(&lt;/span>virtblk&lt;span style="color:#f92672">)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Disk /dev/vdb: 21.5GB
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Sector size &lt;span style="color:#f92672">(&lt;/span>logical/physical&lt;span style="color:#f92672">)&lt;/span>: 512B/512B
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Partition Table: gpt
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Disk Flags:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Number Start End Size File system Name Flags
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Model: Virtio Block Device &lt;span style="color:#f92672">(&lt;/span>virtblk&lt;span style="color:#f92672">)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Disk /dev/vda: 107GB
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Sector size &lt;span style="color:#f92672">(&lt;/span>logical/physical&lt;span style="color:#f92672">)&lt;/span>: 512B/512B
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Partition Table: msdos
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Disk Flags:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Number Start End Size Type File system Flags
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ae81ff">1&lt;/span> 1049kB 107GB 107GB primary ext4 boot
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>不同类型的分区表，其显示的内容也不同，比如 GPT 分区别没有 Type 列，有 Name 列；而 msdos 有 Type 列却没有 Name 列。所以不同的分区表类型，会影响 mkpart 等命令的参数。&lt;/p>
&lt;p>&lt;strong>mkpart [PART-TYPE NAME FS-TYPE] &amp;lt;START&amp;gt; &amp;lt;END&amp;gt;&lt;/strong> # 创建一个新的分区。&lt;/p>
&lt;ul>
&lt;li>&lt;strong>PART-TYPE&lt;/strong> # 分区类型
&lt;ul>
&lt;li>注意：该参数仅适用于分区表类型为 msdos 和 dvh 的磁盘&lt;/li>
&lt;li>extended # 扩展分区&lt;/li>
&lt;li>logical # 逻辑分区&lt;/li>
&lt;li>primary # 主分区&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>NAME&lt;/strong> # 分区表的名字
&lt;ul>
&lt;li>注意：分区表类型为 GPT 的磁盘必须指定 NAME 参数。如果是在交互模式中，可以设定一个空名字~~~o(╯□╰)o&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>FS-TYPE&lt;/strong> # 为分区添加文件系统类型的签名，通常都是在该分区的 offset 0 处添加签名。注意：仅仅是添加签名，并不是真的创建一个文件系统，想要创建文件系统，使用单独的 &lt;code>mkfs&lt;/code> 等命令
&lt;ul>
&lt;li>btrfs&lt;/li>
&lt;li>ext2、ext3、ext4&lt;/li>
&lt;li>fat16、fat32&lt;/li>
&lt;li>hfs、hfs+&lt;/li>
&lt;li>linux-swap&lt;/li>
&lt;li>ntfs&lt;/li>
&lt;li>reiserfs&lt;/li>
&lt;li>udf&lt;/li>
&lt;li>xfs&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>name &amp;lt;NUMBER&amp;gt; &amp;lt;NAME&amp;gt;&lt;/strong> # 设置 NUMBER 号分区的名称为 NAME。仅对 GPT、Mac、MIPS、PC98 磁盘类型下的分区有效。&lt;/p>
&lt;p>&lt;strong>print [NUMBER]&lt;/strong> # 显示磁盘的分区信息，或者显示指定分区的信息&lt;/p>
&lt;p>&lt;strong>rescure START END&lt;/strong> # 救援一个丢失的分区。好像没什么用~~o(╯□╰)o?????????????????&lt;/p>
&lt;p>&lt;strong>resizepart &amp;lt;NUMBER&amp;gt; &amp;lt;END&amp;gt;&lt;/strong> # 移动指定分区的结束位置，即.调整分区的容量大小。注意：这不会修改分区中的任何文件系统，如果需要调整文件系统，则需要使用 resize2fs 之类的程序。&lt;/p>
&lt;p>&lt;strong>rm &amp;lt;NUMBER&amp;gt;&lt;/strong> # 删除指定的分区&lt;/p>
&lt;p>&lt;strong>select * &amp;lt;DEVICE&amp;gt;&lt;/strong> # 在交互模式中选择要编辑的磁盘设备。DEVICE 可以是 Linux 硬盘设备、分区、软 RAID 设备、LVM&lt;/p>
&lt;p>&lt;strong>set &amp;lt;NUMBER&amp;gt; &amp;lt;FLAG&amp;gt; &amp;lt;STATE&amp;gt;&lt;/strong> # 设置分区的 Flag。这命令有啥用？~~囧???????????&lt;/p>
&lt;p>&lt;strong>unit &amp;lt;UNIT&amp;gt;&lt;/strong> # 设定 parted 程序在显示磁盘信息时所使用的默认单位。
当我们使用 &lt;code>%&lt;/code> 给磁盘分区后，过了一段时间我们往往忘记了每个分区具体都占了磁盘的百分比，这时候，使用 &lt;code>unit %&lt;/code> 指令就可以看到这些信息了。o(∩_∩)o&lt;/p>
&lt;h3 id="example">EXAMPLE&lt;/h3>
&lt;ul>
&lt;li>检查 /dev/vda 磁盘的 1 号分区是否对齐
&lt;ul>
&lt;li>parted /dev/vda align-check optimal 1&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>设置 /dev/vdb 磁盘的分区表为 msdos 格式
&lt;ul>
&lt;li>parted /dev/vdb mktable msdos&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>设置/dev/vdb 磁盘的第一个分区的 FLAG 为 lvm
&lt;ul>
&lt;li>parted /dev/vdb set 1 lvm on&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;/li>
&lt;/ul>
&lt;h2 id="partprobe--探测分区">partprobe # 探测分区&lt;/h2>
&lt;p>当创建完分区而无法用 mkfs 创建文件系统的时候，用该命令，让内核重新读取分区情况以便让新增加的分区可以在不重启的情况下使用&lt;/p>
&lt;h2 id="fdisk--与-parted-工具类似分为交互式命令与非交互式命令">fdisk # 与 parted 工具类似，分为交互式命令与非交互式命令&lt;/h2>
&lt;h3 id="syntax语法-1">Syntax(语法)&lt;/h3>
&lt;p>**fdisk [/Path/DEV] **&lt;/p>
&lt;p>EXAMPLE&lt;/p>
&lt;ul>
&lt;li>fdisk -l # 查看当前磁盘分区详情&lt;/li>
&lt;/ul>
&lt;h1 id="文件系统管理工具">文件系统管理工具&lt;/h1>
&lt;h2 id="mkfs">mkfs&lt;/h2>
&lt;p>&lt;strong>mkfs [OPTIONS]&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>OPTIONS
&lt;ul>
&lt;li>&lt;strong>-t&lt;/strong> # 指定创建的文件系统的类型&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>EXAMPLE
&lt;ul>
&lt;li>mkfs -t ext4 /dev/myvg/lv1 # 对 lv1 磁盘创建 ext2 的文件系统&lt;/li>
&lt;li>mkfs.xfs /dev/vdb1 # 以 xfs 类型文件系统格式化 /dev/sdb1 分区&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h2 id="mke2fs">mke2fs&lt;/h2>
&lt;p>&lt;strong>mke2fs [OPTIONS]&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>OPTIONS
&lt;ul>
&lt;li>-t 指定文件系统格式&lt;/li>
&lt;li>-b 指定 block 的大小(支持 1024,2048,4096 三种)&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>EXAMPLE&lt;/li>
&lt;/ul>
&lt;h2 id="xfs_info--显示-xfs-文件系统的几何信息">xfs_info # 显示 XFS 文件系统的几何信息&lt;/h2>
&lt;p>xfs_info 显示有关现有 XFS 文件系统的几何信息。挂载点参数是挂载文件系统的目录的路径名。块设备或文件映像包含原始 XFS 文件系统。文件系统的现有内容不受干扰。&lt;/p>
&lt;h1 id="磁盘查询命令">磁盘查询命令&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://man7.org/linux/man-pages/man1/df.1.html">manual,df&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://man7.org/linux/man-pages/man1/du.1.html">manual,du&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://man7.org/linux/man-pages/man8/lsblk.8.html">manual,lsblk&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;h2 id="df--查看已经格式化成文件系统的整体容量挂载点位置">df # 查看已经格式化成文件系统的整体容量[挂载点位置]&lt;/h2>
&lt;h3 id="syntax语法-2">Syntax(语法)&lt;/h3>
&lt;p>&lt;strong>df [OPTIONS]&amp;hellip; [FILE]&amp;hellip;&lt;/strong>
OPTIONS&lt;/p>
&lt;ul>
&lt;li>**-h, &amp;ndash;human-readable **# 以人类可读的方式输出信息。磁盘容量以 1024 为除数。效果如下：
&lt;ul>
&lt;li>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/zqtob4/1625708279949-ac083715-d7e8-4271-800e-6c5791aa3573.png" alt="image.png">&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>-i, &amp;ndash;inodes&lt;/strong> # 列出 inode 信息&lt;/li>
&lt;li>&lt;strong>-T, &amp;ndash;print-type&lt;/strong> # 输出文件系统类型&lt;/li>
&lt;li>&lt;strong>-t, &amp;ndash;type &amp;lt;TYPE&amp;gt;&lt;/strong> # 仅列出指定类型的文件系统。(文件系统类型可以通过 -T 选项看到)&lt;/li>
&lt;/ul>
&lt;h3 id="example-1">EXAMPLE&lt;/h3>
&lt;ul>
&lt;li>&lt;strong>df -h /&lt;/strong> # 以人类易读的方式显示挂载在/下的信息，可以显示容量是 M 还是 G 还是 K&lt;/li>
&lt;/ul>
&lt;h2 id="du--查看文件系统下当前目录以及子目录的容量">du # 查看文件系统下当前目录以及子目录的容量&lt;/h2>
&lt;h3 id="syntax语法-3">Syntax(语法)&lt;/h3>
&lt;p>OPTIONS&lt;/p>
&lt;ul>
&lt;li>&lt;strong>-a&lt;/strong> # 包括目录下的文件大小也一起显示&lt;/li>
&lt;li>&lt;strong>-s&lt;/strong> # 仅列出当前目录的容量总计，不显示子目录&lt;/li>
&lt;li>&lt;strong>-h&lt;/strong> # 把容量大小转换为人类易读的格式&lt;/li>
&lt;li>&lt;strong>-d, &amp;ndash;maxdepth &amp;lt;NUM&amp;gt;&lt;/strong> # 仅列出目录深度 1 层的信息，即当前目录下的目录的大小，不往下列出子目录&lt;/li>
&lt;/ul>
&lt;p>EXAMPLE&lt;/p>
&lt;ul>
&lt;li>du -d 1 | sort -rn | head -n 2 #列出不含子目录的当前目录下的目录大小，并以数字进行降序排列，且只显示前两行&lt;/li>
&lt;/ul>
&lt;h2 id="ncdu--比-du-更快的工具">ncdu # 比 du 更快的工具&lt;/h2>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://code.blicky.net/yorhel/ncdu/src/branch/zig/src">https://code.blicky.net/yorhel/ncdu/src/branch/zig/src&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://dev.yorhel.nl/ncdu">官网&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;h2 id="sn--比-du-更快的工具">sn # 比 du 更快的工具&lt;/h2>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://github.com/vmchale/tin-summer">GitHub 项目，vmchale/tin-summer&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;h3 id="syntax语法-4">Syntax(语法)&lt;/h3>
&lt;p>&lt;strong>sn &amp;lt;SUBCOMMAND&amp;gt;&lt;/strong>
sn 工具完全通过子命令来执行具体操作
SUBCOMMAND&lt;/p>
&lt;ul>
&lt;li>sort #&lt;/li>
&lt;/ul>
&lt;p>OPTIONS：&lt;/p>
&lt;ul>
&lt;li>&lt;strong>-d, &amp;ndash;depth &amp;lt;NUMBER&amp;gt;&lt;/strong> # 目录深度&lt;/li>
&lt;/ul>
&lt;h3 id="example-2">EXAMPLE&lt;/h3>
&lt;ul>
&lt;li>显示根目录下一层深度的容量大小，并排序
&lt;ul>
&lt;li>sn sort -d 1 /&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h2 id="lsblk--list-block-devices-列出块设备信息">lsblk # list block devices 列出块设备信息&lt;/h2>
&lt;p>lsblk 列出有关所有可用或指定的块设备的信息。 lsblk 命令读取 &lt;code>sysfs文件系统&lt;/code> 和 &lt;code>udev db&lt;/code> 来收集信息。&lt;/p>
&lt;p>默认情况下，该命令以树形格式打印所有块设备(除了 RAM 磁盘)。效果如下：&lt;/p>
&lt;pre>&lt;code>[root@lichenhao ~]# lsblk
NAME MAJ:MIN RM SIZE RO TYPE MOUNTPOINT
sr0 11:0 1 1024M 0 rom
vda 252:0 0 500G 0 disk
├─vda1 252:1 0 2M 0 part
├─vda2 252:2 0 500M 0 part /boot
└─vda3 252:3 0 499.5G 0 part
└─vg1-root 253:0 0 499.5G 0 lvm /
&lt;/code>&lt;/pre>
&lt;p>除了上面例子中的 6 列信息，lsblk 还会提供很多其他信息，使用 lsblk &amp;ndash;help 命令获取所有可用列的列表。&lt;/p>
&lt;ol>
&lt;li>NAME # 块设备名称&lt;/li>
&lt;li>KNAME # 该块设备在内核内的名称。&lt;/li>
&lt;li>MAJ:MIN # major(主要):minor(次要) 的块设备编号
&lt;ol>
&lt;li>MIN 就是 /dev/dm-X 设备后面那个 X 的编号&lt;/li>
&lt;/ol>
&lt;/li>
&lt;li>RM # 该设备是否是可移动设备&lt;/li>
&lt;li>SIZE # 块设备大小&lt;/li>
&lt;li>RO #&lt;/li>
&lt;li>TYPE # 块设备类型&lt;/li>
&lt;li>MOUNTPOINT # 该块设备的挂载路径&lt;/li>
&lt;/ol>
&lt;p>**lsblk [OPTIONS] [DEVICE&amp;hellip;] **
OPTIONS&lt;/p>
&lt;ol>
&lt;li>-J, &amp;ndash;json # 使用 JSON 格式输出内容。&lt;/li>
&lt;li>-o, &amp;ndash;output &amp;lt;LIST&amp;gt; # 指定要打印的输出列。 使用&amp;ndash;help 获取所有受支持列的列表。如果以+LIST 格式（例如 lsblk -o + UUID）指定 LIST，则可以扩展默认的列表。&lt;/li>
&lt;li>-p, &amp;ndash;paths # 显示块设备所在位置的绝对路径&lt;/li>
&lt;/ol>
&lt;p>EXAMPLE&lt;/p>
&lt;ol>
&lt;li>**lsblk **# 以树状结构列出块设备信息&lt;/li>
&lt;li>&lt;strong>lsblk &amp;ndash;output NAME,KNAME,TYPE,SIZE,MOUNTPOINT&lt;/strong> #&lt;/li>
&lt;/ol>
&lt;h2 id="blkid--查看块设备-uuid">blkid # 查看块设备 UUID&lt;/h2>
&lt;p>效果如下：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">[&lt;/span>root@lichenhao ~&lt;span style="color:#f92672">]&lt;/span>&lt;span style="color:#75715e"># blkid&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>/dev/vda1: PARTUUID&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;155ebb92-01&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>/dev/vda2: UUID&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;6c780e7d-7d0d-4e87-a3a3-77bd9a6ff9d5&amp;#34;&lt;/span> TYPE&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;ext4&amp;#34;&lt;/span> PARTUUID&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;155ebb92-02&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>/dev/vda3: UUID&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;SADfxz-bqhC-QdUe-ogW1-diaM-1Fr8-TppSou&amp;#34;&lt;/span> TYPE&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;LVM2_member&amp;#34;&lt;/span> PARTUUID&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;155ebb92-03&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>/dev/mapper/vg1-root: UUID&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;47af4ed5-64c5-405f-bef1-c65dc2984e21&amp;#34;&lt;/span> TYPE&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;xfs&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h1 id="lvm">LVM&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://github.com/lvmteam/lvm2">GitHub 项目,lvmteam/lvm2&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://man7.org/linux/man-pages/man8/lvm.8.html">Manual(手册),lvm(8)&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>&lt;strong>Logical Volume Manager(逻辑卷管理器，简称 LVM)&lt;/strong> 提供了从物理设备创建 &lt;strong>Virtual Block Devices(虚拟块设备)&lt;/strong> 的&lt;strong>工具&lt;/strong>。虚拟设备比物理设备更易于管理，并且可以具有超出物理设备自身提供的功能的能力。&lt;/p>
&lt;ul>
&lt;li>&lt;strong>Volume Group(卷组，简称 VG)&lt;/strong> 是一个或多个物理设备的集合，每个设备称为 &lt;strong>Physical Volume(物理卷，简称 PV)&lt;/strong>&lt;/li>
&lt;li>&lt;strong>Logical Volume(逻辑卷，简称 LV)&lt;/strong> 从 VG 中创建，是可由系统或应用直接使用的虚拟块设备。
&lt;ul>
&lt;li>根据内核中 &lt;strong>Device Mapper(设备映射，简称 DM)&lt;/strong> 实现的算法，LV 中的每个数据块都存储在 VG 中的一个或多个 PV 上。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>LVM 创建的 LV 本质上是相当于创建了一个新的物理磁盘，这不说是逻辑上的磁盘。所以称为逻辑卷。在 Linux 中，LVM 表现为一种 device-mapper 类型的磁盘。
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/zqtob4/1640420060047-c8503823-746d-41d5-8db8-3c4c5bd218da.png" alt="image.png">
上图中，虽然 testvg1-testlv 磁盘是一个 LVM，并且是通过 /dev/sdb 磁盘的分区创建的，但是从整个磁盘管理的角度来看，一个 LV 就是一个物理磁盘，只不过类型不同罢了。&lt;/p>
&lt;h2 id="syntax语法-5">Syntax(语法)&lt;/h2>
&lt;p>&lt;strong>lvm [ COMMAND | FILE ]&lt;/strong>&lt;/p>
&lt;h2 id="example-3">Example&lt;/h2>
&lt;p>创建 LVM 顺序：&lt;/p>
&lt;ol>
&lt;li>Physical Volume：PV 物理卷(相当于一块一块真实的物理磁盘)&lt;/li>
&lt;li>Volume Group：VG 卷组(把多块物理磁盘组合在一起形成一个组，并在创建 VG 时把整个组的空间划分为一个个默认大小为 4M 的 PE，VG 就相当于一个存储池子，里面有好多好多 PE 块组成了一个大的磁盘空间供 LV 使用)&lt;/li>
&lt;li>Pysical Extent：PE 物理区域(把真实的物理磁盘的空间切分为一个个固定大小的块，每个块就是 PE)&lt;/li>
&lt;li>Logical Volume：LV 逻辑卷(从 VG 中拿出多个 PE 组成逻辑上的磁盘空间，可以把 LV 当成一个分区)&lt;/li>
&lt;/ol>
&lt;p>创建逻辑卷的步骤：&lt;/p>
&lt;ol>
&lt;li>创建分区，并使之可用
&lt;ol>
&lt;li>pvcreate /dev/sda{1,2}&lt;/li>
&lt;li>vgcreate testvg1 /dev/sda{1,2}&lt;/li>
&lt;li>lvcreate -L 10G -n testlv testvg1&lt;/li>
&lt;/ol>
&lt;/li>
&lt;/ol>
&lt;p>扩展逻辑卷的步骤：&lt;/p>
&lt;ol>
&lt;li>确定扩展的大小，并确保 lv 所属的 vg 有足够的剩余空间
&lt;ol>
&lt;li>pvcreate /DEV/PATH&lt;/li>
&lt;li>vgextend VG /DEV/PATH&lt;/li>
&lt;/ol>
&lt;/li>
&lt;li>扩展 lv 大小，执行 lvextend 命令，第二条为扩展所有剩余空间到逻辑卷
&lt;ol>
&lt;li>lvextend -L [+]SIZE LvPath&lt;/li>
&lt;li>lvextend -l+100%FREE /dev/mapper/vg0-root&lt;/li>
&lt;/ol>
&lt;/li>
&lt;li>扩展系统文件大小，执行 resize2fs 命令
&lt;ol>
&lt;li>xfs_growfs LvPath&lt;/li>
&lt;/ol>
&lt;/li>
&lt;/ol>
&lt;p>缩减逻辑卷的步骤&lt;/p>
&lt;ol>
&lt;li>卸载卷 umount，并执行强制检测
&lt;ol>
&lt;li>e2fsck -f LvPath&lt;/li>
&lt;/ol>
&lt;/li>
&lt;li>缩减文件系统大小
&lt;ol>
&lt;li>resize2fs LvPath SIZE&lt;/li>
&lt;/ol>
&lt;/li>
&lt;li>缩减 lv 大小
&lt;ol>
&lt;li>lvreduce -L [-]Siza LvPath&lt;/li>
&lt;/ol>
&lt;/li>
&lt;/ol>
&lt;h2 id="pv--物理卷管理命令">pv # 物理卷管理命令&lt;/h2>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>Manual(),pvcreate()&lt;/li>
&lt;li>&lt;a href="https://man7.org/linux/man-pages/man8/pvresize.8.html">Manual(手册),pvresize(8)&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;h3 id="syntax语法-6">Syntax(语法)&lt;/h3>
&lt;p>&lt;strong>pvcreate POSITION [OPTIONS] # 初始化物理卷以供 PVM 使用&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>POSITION #&lt;/li>
&lt;/ul>
&lt;p>pvcreat 创建 PV&lt;/p>
&lt;ol>
&lt;li>OPTIONS&lt;/li>
&lt;li>EXAMPLE
&lt;ol>
&lt;li>pvcreate /dev/sdb1&lt;/li>
&lt;li>pvcreate /dev/sdb{1,2}&lt;/li>
&lt;/ol>
&lt;/li>
&lt;/ol>
&lt;p>pvremove 删除 PV&lt;/p>
&lt;p>pvscan 扫描 PV&lt;/p>
&lt;p>pvs 简要显示 PV&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/zqtob4/1616167609644-770f62f5-144e-44cb-8b06-feceb8309f0f.jpeg" alt="">&lt;/p>
&lt;ul>
&lt;li>PV：物理卷名称 VG：PV 所属的卷组 Fmt：物理卷格式 Attr： PSize：物理卷大小 PFree：物理卷空余大小&lt;/li>
&lt;/ul>
&lt;p>pvdisplay # 详细显示 PV
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/zqtob4/1616167609649-9587c471-5e11-4e45-a7b6-0046a8d2030b.jpeg" alt="">&lt;/p>
&lt;ul>
&lt;li>PV Name：物理卷名称&lt;/li>
&lt;li>VG Name：PV 所属的卷组名称&lt;/li>
&lt;li>PV Size：物理卷占用多少空间&lt;/li>
&lt;li>Allocatable：是否可分配&lt;/li>
&lt;li>PE Size：每个 PE 占用的空间容量&lt;/li>
&lt;li>Total PE：合计有多少个 PE&lt;/li>
&lt;li>Free PE：有多少空余的 PE&lt;/li>
&lt;li>Allocated PE：分配了多少 PE&lt;/li>
&lt;li>PV UUID：PV 的 UUID 号&lt;/li>
&lt;/ul>
&lt;p>pvmove 把一个 pv 上的数据挪动到另一个 pv 上&lt;/p>
&lt;h2 id="vg--卷组管理命令">vg # 卷组管理命令&lt;/h2>
&lt;p>vgcreat,vgs,vgdisplay,vgextend,vgreduce,vgremove,vgrename&lt;/p>
&lt;p>vgcreat&lt;/p>
&lt;ol>
&lt;li>语法格式：vgcreat VgName PvPath
&lt;ol>
&lt;li>创建 vg 自定义 vg 名 需要加入 VG 的 PV 路径&lt;/li>
&lt;/ol>
&lt;/li>
&lt;li>选项
&lt;ol>
&lt;li>-s # 指定 PE 大小，默认 4M&lt;/li>
&lt;/ol>
&lt;/li>
&lt;li>应用范例
&lt;ol>
&lt;li>vgcreate myvg /dev/sda{1,2} #以 sdb1 和 sdb2 组合起来创建一个名叫 myvg 的 VG&lt;/li>
&lt;/ol>
&lt;/li>
&lt;/ol>
&lt;p>vgs&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/zqtob4/1616167609659-c21d1b79-70bd-4975-a150-6348c5f0bd1e.jpeg" alt="">&lt;/p>
&lt;ol>
&lt;li>#PV：该卷组中物理卷的个数 #LV：逻辑卷的个数&lt;/li>
&lt;/ol>
&lt;p>vgdisplay&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/zqtob4/1616167609663-ebeba7a4-5acb-4d14-ba10-6eddf182d96e.jpeg" alt="">&lt;/p>
&lt;p>vgextend 扩大卷组&lt;/p>
&lt;ol>
&lt;li>语法格式：vgextend VgName PvPath&lt;/li>
&lt;li>选项&lt;/li>
&lt;li>应用实例
&lt;ol>
&lt;li>vgextend myvg /dev/sdc1 #为卷组 myvg 添加一个/dev/sdc1 的物理卷&lt;/li>
&lt;/ol>
&lt;/li>
&lt;/ol>
&lt;p>vgreduce 缩小卷组(注：缩减卷组前，要把要缩减掉的 pv 上的数据用 pvmove 挪走)&lt;/p>
&lt;h2 id="lv--逻辑卷管理命令">lv # 逻辑卷管理命令&lt;/h2>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>Manual(手册),lvcreate(8)&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>lvcreat,lvdisplay,lvs,lvextend,lvreduce,lvremove&lt;/p>
&lt;p>lvcreat&lt;/p>
&lt;ol>
&lt;li>语法格式：lvcreat [OPTIONS] VgName [PvPath]
&lt;ol>
&lt;li>创建 lv 从哪个 vg 中创建&lt;/li>
&lt;/ol>
&lt;/li>
&lt;li>选项
&lt;ol>
&lt;li>&lt;strong>-n&lt;/strong> # 指定 lv 名字&lt;/li>
&lt;li>&lt;strong>-L&lt;/strong> # 指定 lv 的空间大小&lt;/li>
&lt;li>&lt;strong>-p&lt;/strong> # 指定访问权限&lt;/li>
&lt;li>&lt;strong>-s&lt;/strong> # 创建 lv 的快照 snapshot&lt;/li>
&lt;/ol>
&lt;/li>
&lt;li>实际范例
&lt;ol>
&lt;li>lvcreate -L 3G -n lv1 myvg # congmyvg 卷组中创建名为 Imyvg 大小为 3G 的 LV&lt;/li>
&lt;li>lvcreate -s -L3G -n lv1snapshot -p r /dev/myvg/lv1 # 创建名为 lv1snapshot，只有读权限，3G 大小的 lv1 的快照&lt;/li>
&lt;/ol>
&lt;/li>
&lt;/ol>
&lt;p>lvdisplay&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/zqtob4/1616167609656-34a3e1a7-1885-42e0-99db-234afc6e1061.jpeg" alt="">&lt;/p>
&lt;p>lvextend&lt;/p>
&lt;ol>
&lt;li>lvextend [OPTIONS] LvPath [PvPath]
&lt;ol>
&lt;li>增加 lv 增加哪个 LV [可以指定从哪个 PV 里给该 LV 增加]&lt;/li>
&lt;/ol>
&lt;/li>
&lt;li>OPTIONS
&lt;ol>
&lt;li>-L #指定要增加的空间，增加到 5G 则是-L 5G，增加了 5G 则是-L +5G&lt;/li>
&lt;/ol>
&lt;/li>
&lt;li>EXAMPLE
&lt;ol>
&lt;li>lvextend -L 5G /dev/myvg/lv1 扩展 lv1 这个逻辑卷到 5G 的容量&lt;/li>
&lt;li>lvextend -L +5G /dev/myvg/lv1 sdc1 #扩展 lv1 逻辑卷多出 5G 的空间，从 sdc1 中给 lv 提供空间&lt;/li>
&lt;li>lvextend -l+100%FREE /dev/mapper/vg0-root #扩展卷组中所有空间给 vg0-root 这个逻辑卷&lt;/li>
&lt;/ol>
&lt;/li>
&lt;/ol>
&lt;h2 id="resize2fs如果是-xfs-文件系统则使用-xfs_growfs-命令用来增大或者收缩未加载的-ext-文件系统的大小如果文件系统是处于-mount-状态下那么它只能做到扩容">resize2fs(如果是 xfs 文件系统，则使用 xfs_growfs 命令)用来增大或者收缩未加载的 ext 文件系统的大小。如果文件系统是处于 mount 状态下，那么它只能做到扩容&lt;/h2>
&lt;p>注意：在 lv 扩容完成后，还需要对文件系统进行扩容，否则无法使用&lt;/p>
&lt;ol>
&lt;li>语法格式&lt;/li>
&lt;li>OPTIONS&lt;/li>
&lt;li>EXAMPLE
&lt;ol>
&lt;li>resize2fs /dev/myvg/lv1 #&lt;/li>
&lt;/ol>
&lt;/li>
&lt;/ol>
&lt;h2 id="snapshot-快照卷">snapshot 快照卷&lt;/h2>
&lt;p>注意：lvm 创建的快照是基于原始卷来运行的，原始卷修改了多少内容，其修改之前的内容就会被自动复制到快照卷里，快照是按照 PE 复制的，每个 PE 的改变，原始 PE 都会自动备份到快照当中，当快照卷的容量满了，就失去了快照卷了，注意 lvm 创建的快照与 openstack 的实例创建的快照还有 VMware 创建的快照的区别&lt;/p>
&lt;h1 id="最佳实践">最佳实践&lt;/h1>
&lt;h2 id="最基本的新硬盘操作">最基本的新硬盘操作&lt;/h2>
&lt;ul>
&lt;li>创建 GPT 格式的分区表
&lt;ul>
&lt;li>parted /dev/vdb mktable gpt&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>为 /dev/vdb 创建一个主分区，大小是该磁盘的 0% 到 100%，设置名称为 data1
&lt;ul>
&lt;li>parted /dev/vdb mkpart data1 0% 100%&lt;/li>
&lt;li>注意：尽量使用 &lt;code>%&lt;/code> 来标识磁盘分区大小，否则会提示磁盘分区未对齐。若是显示命令无法显示百分比，则通过 &lt;code>unit&lt;/code> 子命令将单位转换为 &lt;code>%&lt;/code>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>为 /dev/vdb1 创建 xfs 文件系统
&lt;ul>
&lt;li>mkfs.xfs /dev/vdb1&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>挂载文件系统
&lt;ul>
&lt;li>mount /dev/vdb1 /mnt/test&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h2 id="为新磁盘创建-lvm">为新磁盘创建 LVM&lt;/h2>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># 创建 GPT 格式的分区表&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>parted /dev/vdb mktable gpt
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># 为/dev/vdb分一个主分区，大小是该磁盘的0%到100%&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>parted /dev/vdb mkpart lvm 0% 100%
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># 创建 PV&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>pvcreate /dev/vdb1
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># 创建 VG&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>vgcreate vg-data /dev/vdb1
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># 创建 LV&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>lvcreate -l 100%FREE -n lv0 vg-data
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># 为 /dev/mapper/vg--data-lv0 创建 xfs 文件系统&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>mkfs.xfs /dev/mapper/vg--data-lv0
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># 挂载文件系统&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>mount /dev/mapper/vg--data-lv0 /mnt/test
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="为虚拟机磁盘扩容">为虚拟机磁盘扩容&lt;/h2>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://support.huaweicloud.com/usermanual-evs/evs_01_0109.html">华为云文档,云硬盘 EVS-用户指南-扩容云硬盘-扩展磁盘分区和文件系统(Iinux)&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;h3 id="前提条件">前提条件&lt;/h3>
&lt;p>确保分区表正常&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">[&lt;/span>root@hw-cloud-xngy-jump-server-linux-2 ~&lt;span style="color:#f92672">]&lt;/span>&lt;span style="color:#75715e"># lsblk&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>NAME MAJ:MIN RM SIZE RO TYPE MOUNTPOINT
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>vda 252:0 &lt;span style="color:#ae81ff">0&lt;/span> 100G &lt;span style="color:#ae81ff">0&lt;/span> disk
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>└─vda1 252:1 &lt;span style="color:#ae81ff">0&lt;/span> 100G &lt;span style="color:#ae81ff">0&lt;/span> part /
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>vdb 252:16 &lt;span style="color:#ae81ff">0&lt;/span> 30G &lt;span style="color:#ae81ff">0&lt;/span> disk
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>└─vdb1 252:17 &lt;span style="color:#ae81ff">0&lt;/span> 20G &lt;span style="color:#ae81ff">0&lt;/span> part
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> └─vg--data-lv0 253:0 &lt;span style="color:#ae81ff">0&lt;/span> 20G &lt;span style="color:#ae81ff">0&lt;/span> lvm
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">[&lt;/span>root@hw-cloud-xngy-jump-server-linux-2 ~&lt;span style="color:#f92672">]&lt;/span>&lt;span style="color:#75715e"># parted /dev/vdb print&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Warning: Not all of the space available to /dev/vdb appears to be used, you can fix the GPT to use all of the space &lt;span style="color:#f92672">(&lt;/span>an extra &lt;span style="color:#ae81ff">20971520&lt;/span> blocks&lt;span style="color:#f92672">)&lt;/span> or &lt;span style="color:#66d9ef">continue&lt;/span> with the current setting?
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>警告：似乎并未使用 /dev/vdb 的所有可用空间，您可以修复 GPT 以使用所有空间（额外的 &lt;span style="color:#ae81ff">20971520&lt;/span> 个块）还是继续当前设置？
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Fix/Ignore?
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;blockquote>
&lt;p>注意：&lt;/p>
&lt;ul>
&lt;li>虚拟机中的一个磁盘被扩容后，如果是 GPT 分区表的磁盘，当我们使用 &lt;code>parted DEVICE print&lt;/code> 指令查看信息时，将会弹出警告&lt;/li>
&lt;li>这是因为 GPT 分区表信息存储在磁盘开头，为了减少分区表损坏的风险，同时在磁盘末尾会备份一份。当磁盘容量扩大后，末尾位置也会随之变化，因此需要根据系统提示输入“Fix”，将分区表信息的备份文件挪到新的磁盘末尾位置。&lt;/li>
&lt;li>此时直接输入 Fix 即可自动修复&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;h3 id="虚拟机磁盘使用-lvm-的扩容方案">虚拟机磁盘使用 LVM 的扩容方案&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># 扩容分区&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>$ growpart /dev/vdb &lt;span style="color:#ae81ff">1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>CHANGED: partition&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span> start&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">2048&lt;/span> old: size&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">62912479&lt;/span> end&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">62914527&lt;/span> new: size&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">73398239&lt;/span> end&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">73400287&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># 扩容分区对应的 PV&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>$ pvresize /dev/vdb1
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Physical volume &lt;span style="color:#e6db74">&amp;#34;/dev/vdb1&amp;#34;&lt;/span> changed
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ae81ff">1&lt;/span> physical volume&lt;span style="color:#f92672">(&lt;/span>s&lt;span style="color:#f92672">)&lt;/span> resized or updated / &lt;span style="color:#ae81ff">0&lt;/span> physical volume&lt;span style="color:#f92672">(&lt;/span>s&lt;span style="color:#f92672">)&lt;/span> not resized
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># 扩容 LV&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>$ lvextend -l +100%FREE /dev/mapper/vg--data-lv0
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Size of logical volume vg-data/lv0 changed from &amp;lt;30.00 GiB &lt;span style="color:#f92672">(&lt;/span>&lt;span style="color:#ae81ff">7679&lt;/span> extents&lt;span style="color:#f92672">)&lt;/span> to &amp;lt;35.00 GiB &lt;span style="color:#f92672">(&lt;/span>&lt;span style="color:#ae81ff">8959&lt;/span> extents&lt;span style="color:#f92672">)&lt;/span>.
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Logical volume vg-data/lv0 successfully resized.
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># 扩容文件系统&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>$ xfs_growfs /dev/mapper/vg--data-lv0
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>meta-data&lt;span style="color:#f92672">=&lt;/span>/dev/mapper/vg--data-lv0 isize&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">512&lt;/span> agcount&lt;span style="color:#f92672">=&lt;/span>4, agsize&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">1310464&lt;/span> blks
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">=&lt;/span> sectsz&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">512&lt;/span> attr&lt;span style="color:#f92672">=&lt;/span>2, projid32bit&lt;span style="color:#f92672">=&lt;/span>1
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">=&lt;/span> crc&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span> finobt&lt;span style="color:#f92672">=&lt;/span>1, sparse&lt;span style="color:#f92672">=&lt;/span>1, rmapbt&lt;span style="color:#f92672">=&lt;/span>0
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">=&lt;/span> reflink&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>data &lt;span style="color:#f92672">=&lt;/span> bsize&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">4096&lt;/span> blocks&lt;span style="color:#f92672">=&lt;/span>5241856, imaxpct&lt;span style="color:#f92672">=&lt;/span>25
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">=&lt;/span> sunit&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">0&lt;/span> swidth&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">0&lt;/span> blks
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>naming &lt;span style="color:#f92672">=&lt;/span>version &lt;span style="color:#ae81ff">2&lt;/span> bsize&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">4096&lt;/span> ascii-ci&lt;span style="color:#f92672">=&lt;/span>0, ftype&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>log &lt;span style="color:#f92672">=&lt;/span>internal log bsize&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">4096&lt;/span> blocks&lt;span style="color:#f92672">=&lt;/span>2560, version&lt;span style="color:#f92672">=&lt;/span>2
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">=&lt;/span> sectsz&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">512&lt;/span> sunit&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">0&lt;/span> blks, lazy-count&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>realtime &lt;span style="color:#f92672">=&lt;/span>none extsz&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">4096&lt;/span> blocks&lt;span style="color:#f92672">=&lt;/span>0, rtextents&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">0&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>data blocks changed from &lt;span style="color:#ae81ff">5241856&lt;/span> to &lt;span style="color:#ae81ff">9174016&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="虚拟机磁盘不使用-lvm-的扩容方案">虚拟机磁盘不使用 LVM 的扩容方案&lt;/h3>
&lt;p>比较简单，两步解决&lt;/p>
&lt;ul>
&lt;li>扩容分区
&lt;ul>
&lt;li>&lt;strong>growpart /dev/vdb 1&lt;/strong>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>扩容文件系统
&lt;ul>
&lt;li>ext* 类型
&lt;ul>
&lt;li>&lt;strong>resize2fs /dev/vdb1&lt;/strong>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>xfs 类型
&lt;ul>
&lt;li>&lt;strong>xfs_growfs /dev/vdb1&lt;/strong>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>这种方式通常都是在公有云上这么搞~&lt;/p></description></item><item><title>Docs: 文件与文件系统管理工具</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/x.linux-%E7%AE%A1%E7%90%86/linux-%E7%B3%BB%E7%BB%9F%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/%E7%A3%81%E7%9B%98-%E4%B8%8E-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7%E9%9B%86/%E6%96%87%E4%BB%B6%E4%B8%8E%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/x.linux-%E7%AE%A1%E7%90%86/linux-%E7%B3%BB%E7%BB%9F%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/%E7%A3%81%E7%9B%98-%E4%B8%8E-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7%E9%9B%86/%E6%96%87%E4%BB%B6%E4%B8%8E%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/</guid><description>
&lt;h1 id="ls--列出有关文件的信息默认情况下为当前目录所有文件">ls # 列出有关文件的信息(默认情况下为当前目录所有文件)&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://man7.org/linux/man-pages/man1/ls.1.html">Manual(手册)，ls(1)&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://man7.org/linux/man-pages/man1/ls.1p.html">Manual(手册)，ls(1p)&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.gnu.org/software/coreutils/manual/html_node/ls-invocation.html">GNU 官方文档，软件-coreutils-手册-10 目录列表-ls&lt;/a>&lt;/li>
&lt;li>包含在 &lt;a href="https://desistdaydream.github.io/docs/IT%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/X.Linux%20%E7%AE%A1%E7%90%86/Linux%E7%AE%A1%E7%90%86.md#Coreutils">Coreutils &lt;/a>工具集&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;h2 id="syntax语法">Syntax(语法)&lt;/h2>
&lt;p>&lt;strong>ls [OPTIONS]&amp;hellip; [FILE]&amp;hellip;&lt;/strong>&lt;/p>
&lt;h3 id="options">OPTIONS&lt;/h3>
&lt;p>影响列出哪些文件的选项&lt;/p>
&lt;blockquote>
&lt;p>参考：&lt;a href="https://www.gnu.org/software/coreutils/manual/html_node/Which-files-are-listed.html">https://www.gnu.org/software/coreutils/manual/html_node/Which-files-are-listed.html&lt;/a>&lt;/p>
&lt;/blockquote>
&lt;ul>
&lt;li>**-a, &amp;ndash;all **# 不要忽略以 &lt;code>.&lt;/code> 符号开头的条目&lt;/li>
&lt;/ul>
&lt;p>影响列出的文件包含哪些信息的选项&lt;/p>
&lt;blockquote>
&lt;p>参考：&lt;a href="https://www.gnu.org/software/coreutils/manual/html_node/What-information-is-listed.html">https://www.gnu.org/software/coreutils/manual/html_node/What-information-is-listed.html&lt;/a>&lt;/p>
&lt;/blockquote>
&lt;ul>
&lt;li>&lt;strong>&amp;ndash;full-time&lt;/strong> # 显示时间的完整格式&lt;/li>
&lt;li>&lt;strong>-h, &amp;ndash;human-readable&lt;/strong> # 将 size 列信息变为人类可读的格式。&lt;/li>
&lt;li>&lt;strong>-i, &amp;ndash;inode&lt;/strong> # 显示文件的 inode 号。显示在最左侧。&lt;/li>
&lt;li>&lt;strong>-l&lt;/strong> # 输出更多的信息。每列信息所代表的含义详见 《&lt;a href="docs/IT%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2.Kernel(%E5%86%85%E6%A0%B8)/6.File_System_%E7%AE%A1%E7%90%86/%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86/%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86.md">文件管理&lt;/a>》章节&lt;/li>
&lt;li>&lt;strong>-Z, &amp;ndash;context&lt;/strong> # 显示 SELinux 安全上下文，若该文件不受 SELinux 影响，则显示 &lt;code>?&lt;/code>。&lt;/li>
&lt;/ul>
&lt;p>对输出的信息进行排序的选项&lt;/p>
&lt;blockquote>
&lt;p>参考：&lt;a href="https://www.gnu.org/software/coreutils/manual/html_node/Sorting-the-output.html">https://www.gnu.org/software/coreutils/manual/html_node/Sorting-the-output.html&lt;/a>&lt;/p>
&lt;/blockquote>
&lt;ul>
&lt;li>**-r **# 对列出的内容反向排序&lt;/li>
&lt;li>&lt;strong>&amp;ndash;sort=WORD&lt;/strong> # 按照 WORD 排序，而不是以文件的名称排序。
&lt;ul>
&lt;li>size # 以文件大小排序。等同于 -S 选项&lt;/li>
&lt;li>time # 以时间排序。等同于 -t 选项&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>**-c **# 显示文件的 ctime，并按照 ctime 排序&lt;/li>
&lt;li>**-u **# 显示文件的 atime，并按照 atime 排序&lt;/li>
&lt;/ul>
&lt;p>影响输出信息的格式&lt;/p>
&lt;blockquote>
&lt;p>参考：&lt;a href="https://www.gnu.org/software/coreutils/manual/html_node/General-output-formatting.html">https://www.gnu.org/software/coreutils/manual/html_node/General-output-formatting.html&lt;/a>&lt;/p>
&lt;/blockquote>
&lt;ul>
&lt;li>&lt;strong>&amp;ndash;color[=WHEN]&lt;/strong> # 用色彩辨别文件类型。WHEN 可以是&amp;rsquo;never&amp;rsquo;、&amp;lsquo;always&amp;rsquo;或&amp;rsquo;auto&amp;rsquo;其中之一
&lt;ul>
&lt;li>白色：表示普通文件&lt;/li>
&lt;li>蓝色：表示目录&lt;/li>
&lt;li>绿色：表示可执行文件&lt;/li>
&lt;li>红色：表示压缩文件&lt;/li>
&lt;li>浅蓝色：链接文件&lt;/li>
&lt;li>红色闪烁：表示链接的文件有问题&lt;/li>
&lt;li>黄色：表示设备文件&lt;/li>
&lt;li>灰色：表示其它文件&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h2 id="example">EXAMPLE&lt;/h2>
&lt;ul>
&lt;li>查看文件夹下的文件个数(当前目录的文件数)
&lt;ul>
&lt;li>** ls -l | grep &amp;ldquo;^-&amp;rdquo; | wc -l**&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h1 id="stat--显示文件或文件系统的状态">stat # 显示文件或文件系统的状态&lt;/h1>
&lt;pre>&lt;code>[root@lichenhao ~]# stat anaconda-ks.cfg
File: ‘anaconda-ks.cfg’
Size: 1594 Blocks: 8 IO Block: 4096 regular file
Device: fd00h/64768d Inode: 67155554 Links: 1
Access: (0600/-rw-------) Uid: ( 0/ root) Gid: ( 0/ root)
Access: 2019-05-24 09:01:18.293000000 +0800
Modify: 2019-05-24 09:01:18.296000000 +0800
Change: 2019-05-24 09:01:18.296000000 +0800 Birth: -
&lt;/code>&lt;/pre>
&lt;h1 id="ln--在文件之间建立软硬链接">ln # 在文件之间建立(软/硬)链接&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://man7.org/linux/man-pages/man1/ln.1.html">Manual(手册)，ln(1)&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>ln 工具用来在文件之间建立 links(链接)&lt;/p>
&lt;h2 id="syntax语法-1">Syntax(语法)&lt;/h2>
&lt;p>&lt;strong>ln [OPTIONS] SourceFILE DestinationFILE&lt;/strong>&lt;/p>
&lt;p>OPTIONS&lt;/p>
&lt;ul>
&lt;li>&lt;strong>-s, &amp;ndash;symbolic&lt;/strong> # 使用软连接。默认为硬连接&lt;/li>
&lt;/ul>
&lt;h2 id="example-1">EXAMPLE&lt;/h2>
&lt;ul>
&lt;li>ln -s /bin /usr/bin&lt;/li>
&lt;/ul>
&lt;h1 id="file--检查并显示文件的类型">file # 检查并显示文件的类型&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://man7.org/linux/man-pages/man1/file.1.html">Manual(手册)，file(1)&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;h2 id="syntax语法-2">Syntax(语法)&lt;/h2>
&lt;p>&lt;strong>file [-bchiklLNnprsvz0] [&amp;ndash;apple] [&amp;ndash;mime-encoding] [&amp;ndash;mime-type] [-e testname] [-F separator] [-f namefile] [-m magicfiles] file &amp;hellip;&lt;/strong>
&lt;strong>file -C [-m magicfiles]&lt;/strong>
&lt;strong>file [&amp;ndash;help]&lt;/strong>&lt;/p>
&lt;p>&lt;strong>OPTIONS&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>-&lt;strong>s, &amp;ndash;special-files&lt;/strong> # 通常，file 仅尝试读取和确定 stat(2) 报告为普通文件的参数文件的类型。这可以防止出现问题，因为读取特殊文件可能会产生特殊的后果。指定 -s 选项会导致 file 还读取作为块或字符特殊文件的参数文件。
&lt;ul>
&lt;li>&lt;strong>这对于确定原始磁盘分区中数据的文件系统类型非常有用(blkid 命令也可以获取文件系统类型)&lt;/strong>，这些数据是块特殊文件。此选项还会导致 file 忽略 stat(2) 报告的文件大小，因为在某些系统上它报告原始磁盘分区的大小为零。效果如下：&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">[&lt;/span>root@kzt241 mnt&lt;span style="color:#f92672">]&lt;/span>&lt;span style="color:#75715e"># file /dev/dm-2&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>/dev/dm-2: block special &lt;span style="color:#f92672">(&lt;/span>253/2&lt;span style="color:#f92672">)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">[&lt;/span>root@kzt241 mnt&lt;span style="color:#f92672">]&lt;/span>&lt;span style="color:#75715e"># file -s /dev/dm-2&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>/dev/dm-2: SGI XFS filesystem data &lt;span style="color:#f92672">(&lt;/span>blksz 4096, inosz 512, v2 dirs&lt;span style="color:#f92672">)&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="example-2">EXAMPLE&lt;/h2>
&lt;ul>
&lt;li>检查并显示当前目录下所有文件
&lt;ul>
&lt;li>&lt;strong>file *&lt;/strong>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h1 id="cp--复制文件和目录">cp # 复制文件和目录&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://man7.org/linux/man-pages/man1/cp.1.html">Manual(手册)，cp(1)&lt;/a>&lt;/li>
&lt;li>包含在 &lt;a href="https://desistdaydream.github.io/docs/IT%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/X.Linux%20%E7%AE%A1%E7%90%86/Linux%E7%AE%A1%E7%90%86.md#Coreutils">Coreutils&lt;/a> 工具集&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>&lt;strong>cp [OPTIONS] SOURCE DEST&lt;/strong>&lt;/p>
&lt;p>将 SOURCE 复制到 DEST&lt;/p>
&lt;p>OPTIONS&lt;/p>
&lt;ul>
&lt;li>&lt;strong>-a, &amp;ndash;archive&lt;/strong> # 等同于 &lt;code>-dR --presserver=all&lt;/code> 这几个选项的集合体&lt;/li>
&lt;li>&lt;strong>-d&lt;/strong> # 与 &amp;ndash;no-dereference &amp;ndash;preserve=links 相同&lt;/li>
&lt;li>&lt;strong>-P, &amp;ndash;no-dereference&lt;/strong> # 不追踪符号链接。也就是复制符号链接时，复制其本身，而不复制链接目标。&lt;/li>
&lt;li>&lt;strong>&amp;ndash;preserve &amp;lt;ATTR&amp;gt;&lt;/strong> # 保留 SOURCE 的指定属性，多个属性以逗号分隔。&lt;code>默认值：mode,ownership,timestamps&lt;/code>。
&lt;ul>
&lt;li>ATTR 还可以有 context、links、xattr、all。all 表示表示保留所有属性&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>-r, -R, &amp;ndash;recursive&lt;/strong> # 递归得复制目录&lt;/li>
&lt;li>&lt;strong>-v, &amp;ndash;verbose&lt;/strong> # 显示复制进度&lt;/li>
&lt;li>&lt;strong>-x, &amp;ndash;one-file-system&lt;/strong> # 留在这个文件系统上&lt;/li>
&lt;/ul>
&lt;p>EXAMPLE&lt;/p>
&lt;ul>
&lt;li>完全全复制，包括源文件的属性、权限等等
&lt;ul>
&lt;li>&lt;strong>cp -ax&lt;/strong>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h1 id="mv">mv&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://man7.org/linux/man-pages/man1/mv.1.html">Manual(手册)，mv(1)&lt;/a>&lt;/li>
&lt;li>包含在 &lt;a href="https://desistdaydream.github.io/docs/IT%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/X.Linux%20%E7%AE%A1%E7%90%86/Linux%E7%AE%A1%E7%90%86.md#Coreutils">Coreutils&lt;/a> 工具集&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;h2 id="syntax语法-3">Syntax(语法)&lt;/h2>
&lt;p>mv [OPTION]&amp;hellip; [-T] SOURCE DEST
mv [OPTION]&amp;hellip; SOURCE&amp;hellip; DIRECTORY
mv [OPTION]&amp;hellip; -t DIRECTORY SOURCE&amp;hellip;&lt;/p>
&lt;p>&lt;strong>OPTIONS&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>&lt;/li>
&lt;/ul>
&lt;h1 id="tree--以树状格式列出目录的内容">tree # 以树状格式列出目录的内容&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://github.com/Old-Man-Programmer/tree">GitHab 项目，Old-Man-Programmer/tree&lt;/a>&lt;/li>
&lt;li>&lt;a href="http://mama.indstate.edu/users/ice/tree/tree.1.html">官方 Manual，tree(1)&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>安装方式：&lt;strong>yum install -y tree&lt;/strong>&lt;/p>
&lt;h2 id="syntax语法-4">Syntax(语法)&lt;/h2>
&lt;p>&lt;strong>tree [-acdfghilnpqrstuvxACDFQNSUX] [-L level [-R]] [-H baseHREF] [-T title] [-o filename] [&amp;ndash;nolinks] [-P pattern] [-I pattern] [&amp;ndash;inodes] [&amp;ndash;device] [&amp;ndash;noreport] [&amp;ndash;dirsfirst] [&amp;ndash;version] [&amp;ndash;help] [&amp;ndash;filelimit #] [&amp;ndash;si] [&amp;ndash;prune] [&amp;ndash;du] [&amp;ndash;timefmt format] [directory &amp;hellip;]&lt;/strong>&lt;/p>
&lt;p>&lt;strong>OPTIONS&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>&lt;strong>-d&lt;/strong> # 仅列出目录&lt;/li>
&lt;li>&lt;strong>-F&lt;/strong> #&lt;/li>
&lt;li>-**L INT **# 目录树的最大显示深度是 NUM 层。NUM 为 1 则只显示指定目录下的文件信息，为 2 则包括第一层子目录下的信息的也显示，以此类推&lt;/li>
&lt;/ul>
&lt;h2 id="example-3">EXAMPLE&lt;/h2></description></item></channel></rss>