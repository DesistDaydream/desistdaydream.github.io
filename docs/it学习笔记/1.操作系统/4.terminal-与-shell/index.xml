<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>断念梦 – 4.Terminal 与 Shell</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/4.terminal-%E4%B8%8E-shell/</link><description>Recent content in 4.Terminal 与 Shell on 断念梦</description><generator>Hugo -- gohugo.io</generator><atom:link href="https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/4.terminal-%E4%B8%8E-shell/index.xml" rel="self" type="application/rss+xml"/><item><title>Docs: Bash 变量</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/4.terminal-%E4%B8%8E-shell/bash-%E5%8F%98%E9%87%8F/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/4.terminal-%E4%B8%8E-shell/bash-%E5%8F%98%E9%87%8F/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://www.man7.org/linux/man-pages/man1/bash.1.html#PARAMETERS">Manual(手册),bash(1)-参数&lt;/a>-Shell 变量&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>环境变量是对当前环境起作用的变量，在日常操作中，我们最常用的就是 bash 这个 shell。&lt;/p>
&lt;h1 id="bash-自带的变量">Bash 自带的变量&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://www.man7.org/linux/man-pages/man1/bash.1.html#PARAMETERS">手册，参数-&lt;/a>Shell 变量&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>&lt;strong>EDITOR=STRING&lt;/strong> # 当 Bash 需要调用编辑器时，使用该变量指定的编辑器。
&lt;strong>IFS=STRING&lt;/strong> # (Internal Field Separator)输入字段分隔符。&lt;code>默认值：IFS 包含空格、制表符和回车&lt;/code>。
Bash 会根据 IFS 中定义的字符来进行字符串拆分。效果如下：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>~&lt;span style="color:#f92672">]&lt;/span>&lt;span style="color:#75715e"># map=(a,b c)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>~&lt;span style="color:#f92672">]&lt;/span>&lt;span style="color:#75715e"># echo ${map[0]}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>a,b
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>~&lt;span style="color:#f92672">]&lt;/span>&lt;span style="color:#75715e"># IFS=, &amp;amp;&amp;amp; echo ${map[0]}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>a b
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;strong>PATH=&lt;!-- raw HTML omitted -->&lt;/strong> # 命令的搜索路径。以 &lt;code>:&lt;/code> 分隔的目录列表，bash 执行命令时将会从 $PATH 中查找用户输入的命令，以便执行这些命令，如果在 $PATH 中无法找到，则无法执行。&lt;code>默认值：取决于操作系统&lt;/code>，通常都是 &lt;code>/usr/local/bin:/usr/local/sbin:/usr/bin:/usr/sbin:/bin:/sbin&lt;/code>&lt;/p>
&lt;ul>
&lt;li>在 bash 的源码(&lt;code>[./config-top.h](https://git.savannah.gnu.org/cgit/bash.git/tree/config-top.h)&lt;/code>)中，我们可以看到 PATH 变量的默认值由 DEFAULT_PATH_VALUE 定义：&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-c" data-lang="c">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">/* The default value of the PATH variable. */&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#ifndef DEFAULT_PATH_VALUE
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#define DEFAULT_PATH_VALUE \
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> &amp;#34;/usr/local/bin:/usr/local/sbin:/usr/bin:/usr/sbin:/bin:/sbin:.&amp;#34;
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#endif
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ul>
&lt;li>我们也可以在系统中通过 &lt;code>env -i bash -c 'echo &amp;quot;$PATH&amp;quot;'&lt;/code> 命令获取 bash 的 $PATH 变量的默认值&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>TMOUT=INT&lt;/strong> # Bash 在指定 INT 秒后未操作，则自动登出。&lt;code>默认值：空&lt;/code>&lt;/p>
&lt;ul>
&lt;li>如果设置为大于零的值，则 TMOUT 被视为读取内置的默认超时。当输入来自终端时，如果输入在指定的 X 秒后仍未到达，则 select 命令终止。在交互式 shell 中，该值被解释为发出主提示后等待一行输入的秒数。如果完整的输入行未到达，则 Bash 在等待该秒数后终止。&lt;/li>
&lt;/ul>
&lt;h2 id="历史记录相关变量">历史记录相关变量&lt;/h2>
&lt;p>&lt;strong>HISTTIMEFORMAT=STRING&lt;/strong> # 历史记录的格式
&lt;strong>HISTSIZE=INT&lt;/strong> # 历史记录可以保留的最大命令数
&lt;strong>HISTFILESIZE=INT&lt;/strong> # 历史记录可以保留的最大行数
&lt;strong>HISTCONTROL=STRING&lt;/strong> #&lt;/p>
&lt;h2 id="提示符相关变量">提示符相关变量&lt;/h2>
&lt;h3 id="ps1默认提示符">PS1——默认提示符&lt;/h3>
&lt;p>如下所示，可以通过修改 Linux 下的默认提示符，使其更加实用。在下面的例子中，默认的 PS1 的值是“\s-\v$”,显示出了 shell 的名称的版本。我们通过修改，可以使其显示用户名、主机名和当前工作目录。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>-bash-3.2$ export PS1&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;\u@\h \w&amp;gt; &amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>ramesh@dev-db ~&amp;gt; cd /etc/mail
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>ramesh@dev-db /etc/mail&amp;gt;
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>[注: 提示符修改为 &amp;ldquo;username@hostname current-dir&amp;gt;的形式]&lt;/p>
&lt;p>本例中 PS1 使用的一些代码如下：
&lt;strong>\u&lt;/strong> # 用户名
&lt;strong>\h&lt;/strong> # 主机名 建议在\h 值之后有一个空格。从个人角度来讲，使用这个空格可以增加一定的可读性。
&lt;strong>\w&lt;/strong> # 当前目录的完整路径。请注意当你在主目录下的时候，如上面所示只会显示～&lt;/p>
&lt;p>EXAMPLE&lt;/p>
&lt;ul>
&lt;li>&lt;strong>export PS1=&amp;rdquo;[[\e[34;1m]\u@[\e[0m][\e[32;1m]\H[\e[0m] [\e[31;1m]\w[\e[0m]]\$ &amp;ldquo;&lt;/strong> # 好看的提示符样式
&lt;ul>
&lt;li>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/ic2gz0/1628044442278-702aab5e-f50e-40f9-924a-e00528d1dbff.png" alt="image.png">&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h3 id="ps2再谈提示符">PS2——再谈提示符&lt;/h3>
&lt;p>一个非常长的命令可以通过在末尾加“\”使其分行显示。多行命令的默认提示符是“&amp;gt;”。 我们可以通过修改 PS2 ，将提示符修改为&amp;quot;ABC&amp;rdquo; 。&lt;/p>
&lt;pre>&lt;code>[root@lichenhao ~]# ls \
&amp;gt; ^C
[root@lichenhao ~]# PS2=&amp;quot;ABC&amp;quot;
[root@lichenhao ~]# ls \
ABC^C
&lt;/code>&lt;/pre>
&lt;p>当用“\”使长命令分行显示，我发现非常易读。当然我也见过有的人不喜欢分行显示命令&lt;/p>
&lt;h3 id="ps3--shell-脚本中使用-select-时的提示符">PS3 # Shell 脚本中使用 select 时的提示符&lt;/h3>
&lt;p>你可以像下面示范的那样，用环境变量 PS3 定制 shell 脚本的 select 提示：&lt;/p>
&lt;p>不使用 PS3 的脚本输出:&lt;/p>
&lt;p>cat ps3.sh&lt;/p>
&lt;p>执行脚本如下==&amp;gt;&lt;/p>
&lt;p>[注: 缺省的提示符是 #?]&lt;/p>
&lt;p>使用 PS3 的脚本输出：&lt;/p>
&lt;p>加了一句提示脚本,更加的友好了&lt;/p>
&lt;h3 id="ps4--ps4-set--x用来修改跟踪输出的前缀">PS4 # PS4-“set -x&amp;quot;用来修改跟踪输出的前缀&lt;/h3>
&lt;p>如果你像下面那样在调试模式下的脚本中，PS4 环境变量可以定制提示信息：&lt;/p>
&lt;p>没有设置 PS4 时的 shell 脚本输出:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">[&lt;/span>root@localhost functions&lt;span style="color:#f92672">]&lt;/span>&lt;span style="color:#75715e"># cat ps4.sh&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>set -x
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>echo &lt;span style="color:#e6db74">&amp;#34;PS4 demo script&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>ls -l /root/|wc -l
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>[注: 当使用 sex -x 跟踪输出时的提示符为 ++]&lt;/p>
&lt;p>设置 PS4 后的脚本输出:&lt;/p>
&lt;p>PS4 在 ps.sh 中定义了下面两个变量&lt;/p>
&lt;p>o $0 显示当前的脚本名&lt;/p>
&lt;p>o $LINENO 显示的当前的行号&lt;/p>
&lt;p>在 ps4.sh 脚本最顶层加一行这个==========&amp;gt;&lt;/p>
&lt;p>输出的效果如下===&amp;gt;&lt;/p>
&lt;p>如下图所示效果==&amp;gt;&lt;/p>
&lt;p>[注: 使用 PS4 后使 &amp;ldquo;{script-name}.{line-number}+&amp;rdquo; 成为 set –x 的命令提示符]&lt;/p></description></item><item><title>Docs: Bash 操作历史记录</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/4.terminal-%E4%B8%8E-shell/bash-%E6%93%8D%E4%BD%9C%E5%8E%86%E5%8F%B2%E8%AE%B0%E5%BD%95/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/4.terminal-%E4%B8%8E-shell/bash-%E6%93%8D%E4%BD%9C%E5%8E%86%E5%8F%B2%E8%AE%B0%E5%BD%95/</guid><description>
&lt;h1 id="history-工具">history 工具&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://www.man7.org/linux/man-pages/man3/history.3.html">Manual(手册),history&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://blog.csdn.net/m0_38020436/article/details/78730631">https://blog.csdn.net/m0_38020436/article/details/78730631&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://blog.csdn.net/sz_bdqn/article/details/46527021">https://blog.csdn.net/sz_bdqn/article/details/46527021&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>history 工具可以通过如下几个 Bash 的环境变量来配置运行方式&lt;/p>
&lt;ul>
&lt;li>&lt;strong>HISTTIMEFORMAT&lt;/strong> # 历史记录的格式&lt;/li>
&lt;li>&lt;strong>HISTSIZE&lt;/strong> # 历史记录可以保留的最大命令数&lt;/li>
&lt;li>&lt;strong>HISTFILESIZE&lt;/strong> # 历史记录可以保留的最大行数&lt;/li>
&lt;li>&lt;strong>HISTCONTROL&lt;/strong> #&lt;/li>
&lt;/ul>
&lt;h2 id="应用示例">应用示例&lt;/h2>
&lt;ul>
&lt;li>export HISTTIMEFORMAT=&amp;quot;%Y-%m-%d:%H-%M-%S:&lt;code>whoami&lt;/code>: &amp;quot;&lt;/li>
&lt;li>持久化&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span> cat &amp;gt; /etc/profile.d/custom_ops.sh &lt;span style="color:#e6db74">&amp;lt;&amp;lt;END
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">export HISTTIMEFORMAT=&amp;#34;%Y-%m-%d %H:%M:%S `whoami` &amp;#34;
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">END&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h1 id="谁动了我的主机-之活用-history-命令">谁动了我的主机? 之活用 History 命令&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="http://lab.xmirror.cn/2017/05/26/sdlwdzj/">http://lab.xmirror.cn/2017/05/26/sdlwdzj/&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>Linux 系统下可通过 history 命令查看用户所有的历史操作记录，在安全应急响应中起着非常重要的作用，但在未进行附加配置情况下，history 命令只能查看用户历史操作记录，并不能区分用户以及操作时间，不便于审计分析。&lt;/p>
&lt;p>当然，一些不好的操作习惯也可能通过命令历史泄露敏感信息。&lt;/p>
&lt;p>下面我们来介绍如何让 history 日志记录更细化，更便于我们审计分析。&lt;/p>
&lt;h3 id="1命令历史记录中加时间">1、命令历史记录中加时间&lt;/h3>
&lt;p>默认情况下如下图所示，没有命令执行时间，不利于审计分析。
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/ieek6o/1616165148137-f9789cc5-18b7-4fef-9319-70bcf57795e7.jpeg" alt="">
通过设置 export HISTTIMEFORMAT=&amp;rsquo;%F %T &amp;lsquo;，让历史记录中带上命令执行时间。&lt;/p>
&lt;p>注意”%T”和后面的”’”之间有空格，不然查看历史记录的时候，时间和命令之间没有分割。&lt;/p>
&lt;p>要一劳永逸，这个配置可以写在/etc/profile 中，当然如果要对指定用户做配置，这个配置可以写在/home/$USER/.bash_profile 中。&lt;/p>
&lt;p>本文将以/etc/profile 为例进行演示。
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/ieek6o/1616165148161-a02cf695-ebc3-4678-83bf-0dbb6a605411.jpeg" alt="">
要使配置立即生效请执行 source /etc/profile，我们再查看 history 记录，可以看到记录中带上了命令执行时间。
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/ieek6o/1616165148125-d672b6e4-155b-43e0-90cf-4c34f4b15fd7.jpeg" alt="">
如果想要实现更细化的记录，比如登陆过系统的用户、IP 地址、操作命令以及操作时间一一对应，可以通过在/etc/profile 里面加入以下代码实现&lt;/p>
&lt;p>export HISTTIMEFORMAT=&amp;quot;%F %T&lt;code>who -u am i 2&amp;gt;/dev/null| awk '{print $NF}'|sed -e 's/[()]//g'whoami&lt;/code> &amp;ldquo;，注意空格都是必须的。
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/ieek6o/1616165148147-39797dc0-8f2b-4481-8a11-521ad0d3be06.jpeg" alt="">
修改/etc/profile 并加载后，history 记录如下，时间、IP、用户及执行的命令都一一对应。&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/ieek6o/1616165148143-0955f121-58ad-4cc4-a350-c2103b8cb990.jpeg" alt="">&lt;/p>
&lt;p>通过以上配置，我们基本上可以满足日常的审计工作了，但了解系统的朋友应该很容易看出来，这种方法只是设置了环境变量，攻击者 unset 掉这个环境变量，或者直接删除命令历史，对于安全应急来说，这无疑是一个灾难。&lt;/p>
&lt;p>针对这样的问题，我们应该如何应对，下面才是我们今天的重点，通过修改 bash 源码，让 history 记录通过 syslog 发送到远程 logserver 中，大大增加了攻击者对 history 记录完整性破坏的难度。&lt;/p>
&lt;h3 id="2修改-bash-源码支持-syslog-记录">2、修改 bash 源码，支持 syslog 记录&lt;/h3>
&lt;p>首先下载 bash 源码，可以从 gnu.org 下载，这里不做详细说明了，系统需要安装 gcc 等编译环境。我们用 bash4.4 版本做演示。&lt;/p>
&lt;p>修改源码：bashhist.c
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/ieek6o/1616165148122-2898b5a5-b861-491b-ac1a-201aa6403243.jpeg" alt="">
修改源码 config-top.h，取消/#define SYSLOG_HISTORY/这行的注释
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/ieek6o/1616165148162-6b252c51-d8d8-4f98-9ad2-a67e574db7f6.jpeg" alt="">
编译安装，编译过程不做详细说明，本文中使用的编译参数为： ./configure &amp;ndash;prefix=/usr/local/bash，安装成功后对应目录如下：
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/ieek6o/1616165148144-a4bcb15d-3f39-477d-bd7f-1167d58f615d.jpeg" alt="">
此时可以修改/etc/passwd 中用户 shell 环境，也可以用编译好的文件直接替换原有的 bash 二进制文件，但最好对原文件做好备份。&lt;/p>
&lt;p>替换时要注意两点:&lt;/p>
&lt;blockquote>
&lt;p>1、一定要给可执行权限，默认是有的，不过有时候下载到 windows 系统后，再上传就没有可执行权限了，这里一定要确定，不然你会后悔的；2、替换时原 bash 被占用，可以修改原用户的 bash 环境后再进行替换。&lt;/p>
&lt;/blockquote>
&lt;p>查看效果，我们发现 history 记录已经写到了/var/log/message 中。
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/ieek6o/1616165148170-cb8d9280-1422-4701-95f3-2cdd4da96b59.jpeg" alt="">
如果要写到远程 logserver，需要配置 syslog 服务，具体配置这里不做详细讲解，大家自己研究，发送到远端 logserver 效果如下图所示。
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/ieek6o/1616165148152-c4072293-34eb-489d-ba93-70e05632e218.jpeg" alt="">
通过以上手段，可以有效保证 history 记录的完整性，避免攻击者登录系统后，通过取消环境变量、删除 history 记录等方式抹掉操作行为，为安全审计、应急响应等提供了完整的原始数据。&lt;/p>
&lt;h1 id="linux-系统监控记录用户操作轨迹谁动过服务器">linux 系统监控：记录用户操作轨迹，谁动过服务器&lt;/h1>
&lt;blockquote>
&lt;p>&lt;strong>参考：&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://blog.51cto.com/ganbing/2053636">https://blog.51cto.com/ganbing/2053636&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>&lt;strong>1、前言&lt;/strong>&lt;/p>
&lt;p>我们在实际工作当中，都碰到过误操作、误删除、误修改过配置文件等等事件。对于没有堡垒机的公司来说，要在 linux 系统上深究到底谁做过配置文件的修改、做过误删除是很头疼的事情，特别是遇到删库跑路的事件，更头大了。当然你可以通过 history 来查看历史命令记录，如果把 history 记录涂抹掉了，是不是啥也看不到了，如果你想查看在某个时间段到底是谁通过 vim 编辑过某个文件呢？&lt;/p>
&lt;p>那么，有什么办法可以看见这些操作呢，答案是一定有的，具体怎么实现呢，linux script 命令正有如此强大的功能，可以满足我们的需求，script 可以记录终端会话，只要是 linux6.3 以上的系统，都会自带 script 命令，下面我用 centos 7 系统来测试一下。&lt;/p>
&lt;p>&lt;strong>2、配置&lt;/strong>&lt;/p>
&lt;p>&lt;strong>2.1 验证 script 命令（我这里是有的）&lt;/strong>&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">[&lt;/span>root@localhost ~&lt;span style="color:#f92672">]&lt;/span>&lt;span style="color:#75715e"># which script&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>/usr/bin/script
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;strong>2.2 配置 profile 文件，在末尾添加如下内容：&lt;/strong>&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">[&lt;/span>root@localhost ~&lt;span style="color:#f92672">]&lt;/span>&lt;span style="color:#75715e"># vim /etc/profile&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">if&lt;/span> &lt;span style="color:#f92672">[&lt;/span> $UID -ge &lt;span style="color:#ae81ff">0&lt;/span> &lt;span style="color:#f92672">]&lt;/span>; &lt;span style="color:#66d9ef">then&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> exec /usr/bin/script -t 2&amp;gt;/var/log/script/$USER-$UID-&lt;span style="color:#e6db74">`&lt;/span>date +%Y%m%d%H%M&lt;span style="color:#e6db74">`&lt;/span>.date -a -f -q /var/log/script/$USER-$UID-&lt;span style="color:#e6db74">`&lt;/span>date +%Y%m%d%H%M&lt;span style="color:#e6db74">`&lt;/span>.log
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">fi&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>  -t　　　 指明输出录制的时间数据
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>    -f     如果需要在输出到日志文件的同时，也可以查看日志文件的内容，可以使用 -f 参数。PS:可以用于教学,两个命令行接-f可以实时演示
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>    -a     输出录制的文件，在现有内容上追加新的内容
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>    -q     可以使script命令以静默模式运行
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>如下图所示：&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/ieek6o/1647416324069-ae3a5928-f2d8-417c-a761-082d0c58a7fd.png" alt="image.png">&lt;/p>
&lt;p>说明：&lt;/p>
&lt;p>用户登录执行的操作都会记录到/var/log/script/*.log  里（保存日志的目录根据你自己定义），我们可以通过 more、vi 等命令查看目录里的日志。&lt;/p>
&lt;p>注意：&lt;/p>
&lt;ul>
&lt;li>我这里把用户 ID 大于 0 的都记录下来了，你可以重新登录用户，随便操作一些命令，查看生成的文件。&lt;/li>
&lt;li>root 用户的 ID 为 0，新建普通用户的 UID 是从 500 开始的(通过 cat /etc/password 可以查看用户的 UID)，如果你不想记录 root 用户的操作，你把 if 里面的值改成 500：  if [ $UID - ge 500 ];&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>2.3 创建目录、赋予权限&lt;/strong>&lt;/p>
&lt;p>你是不是以为写了这条 if 语句在/etc/profile 文件中就完事了，目录都没创建呢：&lt;/p>
&lt;p>&lt;strong>2.4 使环境生效&lt;/strong>&lt;/p>
&lt;p>3、验证&lt;/p>
&lt;p>好了，你可以退出 linux 终端，在重新登录一下，然后随便敲几个命令来看看。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">[&lt;/span>root@localhost ~&lt;span style="color:#f92672">]&lt;/span>&lt;span style="color:#75715e"># cd /var/log/script/&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">[&lt;/span>root@localhost script&lt;span style="color:#f92672">]&lt;/span>&lt;span style="color:#75715e"># ll&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>total &lt;span style="color:#ae81ff">16&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>-rw-r--r-- &lt;span style="color:#ae81ff">1&lt;/span> root root &lt;span style="color:#ae81ff">68&lt;/span> Dec &lt;span style="color:#ae81ff">22&lt;/span> 15:46 root-0-201712221545.date
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>-rw-r--r-- &lt;span style="color:#ae81ff">1&lt;/span> root root &lt;span style="color:#ae81ff">111&lt;/span> Dec &lt;span style="color:#ae81ff">22&lt;/span> 15:46 root-0-201712221545.log
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>-rw-r--r-- &lt;span style="color:#ae81ff">1&lt;/span> root root &lt;span style="color:#ae81ff">0&lt;/span> Dec &lt;span style="color:#ae81ff">22&lt;/span> 15:46 root-0-201712221546.date
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>-rw-r--r-- &lt;span style="color:#ae81ff">1&lt;/span> root root &lt;span style="color:#ae81ff">5693&lt;/span> Dec &lt;span style="color:#ae81ff">22&lt;/span> 15:46 root-0-201712221546.log
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>从上图可以看到，在/var/log/script 目录中，已经产生了 log 和 data 为后缀的文件，并且还看到了 root 用户和 UID 号 0。&lt;/p>
&lt;p>.log：记录了操作&lt;/p>
&lt;p>.data：可以回放操作&lt;/p>
&lt;p>我们用 scriptreplay 来回放一下操作，看下效果如何：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">[&lt;/span>root@localhost script&lt;span style="color:#f92672">]&lt;/span>&lt;span style="color:#75715e"># scriptreplay root-0-201712221545.date root-0-201712221545.log&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;strong>注意：&lt;/strong> 先指定“时间文件 .data”，然后是“命令文件 .log”，不要颠倒了。&lt;/p>
&lt;p>以上就完也了记录用户的所有操作，并且还可以随时查看，相当于有回放功能，像录像一样，以后定位是谁的问题就好找原因了。&lt;/p></description></item><item><title>Docs: Bash 快捷键</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/4.terminal-%E4%B8%8E-shell/bash-%E5%BF%AB%E6%8D%B7%E9%94%AE/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/4.terminal-%E4%B8%8E-shell/bash-%E5%BF%AB%E6%8D%B7%E9%94%AE/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;p>快速编辑命令高效率输入&lt;/p>
&lt;p>并非大型软件或者 IDE 才有快捷键,shell 也有,如果能够熟练使用快捷键,做起事情来且不事半功倍。&lt;/p>
&lt;p>网上流传的快捷键在 xshell 下可能和菜单的快捷键 alt 啥的冲突&lt;/p>
&lt;p>我只说下 xshell 下和用的最多的&lt;/p>
&lt;p>光标部分总的来说就是移动,最常用的就四个:&lt;/p>
&lt;p>移动到行首和行尾部&lt;/p>
&lt;p>ctrl + a 行首&lt;/p>
&lt;p>ctrl + e 行末&lt;/p>
&lt;p>然后单词移动,xshell 下 alt 不起作用,esc+b/f 可以前后&lt;/p>
&lt;p>但是 ctrl+左/右也可以,所以建议单词之间移动使用:&lt;/p>
&lt;p>ctrl + ← 光标移动到前一个单词开头&lt;/p>
&lt;p>ctrl + → 光标移动到后一个单词结尾&lt;/p>
&lt;p>配合下面的 ctrl+w 或者 esc+d 来删除前后单词&lt;/p>
&lt;p>删除部分&lt;/p>
&lt;p>ctrl + u 删除当前光标左边所有内容&lt;/p>
&lt;p>ctrl + k 删除当前光标右边所有内容&lt;/p>
&lt;p>ctrl + w 删除当前光标到左边最近的一个空格(通常用来删除一个单词)&lt;/p>
&lt;p>esc + d 删除当前光标到右边最近的一个空格(通常用来删除一个单词)&lt;/p>
&lt;p>ctrl + y 粘贴上面删除的部分&lt;/p>
&lt;p>编辑部分&lt;/p>
&lt;p>esc + t 互换相邻的两个单词&lt;/p>
&lt;p>esc + u 大写当前单词&lt;/p>
&lt;p>esc + l 小写当前单词&lt;/p>
&lt;p>esc + c 大写当前字母&lt;/p>
&lt;p>esc + . 当前位置插入上一条命令的最后一个参数&lt;/p>
&lt;p>另外熟悉 vim 的话可以把 bash 的默认编辑器设置为 vim,set -o vi 后按下 esc 进入命令模式和 vim 一样操作&lt;/p>
&lt;p>默认的编辑器是 emacs,如果不是请 set -o emacs 设置回来&lt;/p>
&lt;p>还有关于感叹号的妙用,&lt;/p>
&lt;p>!xyz:3 表示上一条 xyz 命令的第三个参数&lt;/p></description></item><item><title>Docs: Bash 命令行补全</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/4.terminal-%E4%B8%8E-shell/bash-%E5%91%BD%E4%BB%A4%E8%A1%8C%E8%A1%A5%E5%85%A8/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/4.terminal-%E4%B8%8E-shell/bash-%E5%91%BD%E4%BB%A4%E8%A1%8C%E8%A1%A5%E5%85%A8/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;a href="https://en.wikipedia.org/wiki/Command-line_completion">Wiki,CommandLineCompletion&lt;/a>&lt;/p>
&lt;/blockquote>
&lt;p>&lt;strong>Command Line Completion(命令行补全)&lt;/strong> 也称为 &lt;strong>tab completion&lt;/strong>，是命令行解释器的常见功能，在命令行中的程序，可以自动填充部分需要手动输入的命令。&lt;/p>
&lt;h1 id="配置">配置&lt;/h1>
&lt;h2 id="bash-completion">bash-completion&lt;/h2>
&lt;p>**/usr/share/bash-completion/completions/* **# 各种程序补全功能所需文件的保存目录。&lt;/p></description></item><item><title>Docs: exec,xargs,管道符等组合命令</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/4.terminal-%E4%B8%8E-shell/execxargs%E7%AE%A1%E9%81%93%E7%AC%A6%E7%AD%89%E7%BB%84%E5%90%88%E5%91%BD%E4%BB%A4/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/4.terminal-%E4%B8%8E-shell/execxargs%E7%AE%A1%E9%81%93%E7%AC%A6%E7%AD%89%E7%BB%84%E5%90%88%E5%91%BD%E4%BB%A4/</guid><description>
&lt;h1 id="管道符把前面的标准输出内容当作后面的标准输入内容">&lt;code>|&lt;/code>(管道符)：把|前面的标准输出内容当作|后面的标准输入内容&lt;/h1>
&lt;ol>
&lt;li>EXAMPLE&lt;/li>
&lt;/ol>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/sl7f9m/1616165959227-38b8c228-113d-4a87-a335-22560fdc396b.jpeg" alt="">&lt;/p>
&lt;ul>
&lt;li>echo “&amp;ndash;help” | cat #把&amp;ndash;help 当作 cat 的标准输入输出到屏幕上，如图所示，注意与 xargs 应用实例 a 的区别&lt;/li>
&lt;/ul>
&lt;h1 id="exec">exec&lt;/h1>
&lt;p>exec [-cl] [-a name] [COMMAND [ARGUMENTS&amp;hellip;]] #如果指定了 command，它将替换 shell。 没有创建新进程。 参数成为命令的参数。 如果提供了-l 选项，则 shell 会在传递给 command 的第 0 个参数的开头放置一个破折号。 这是 login（1）的作用。 -c 选项导致命令在空环境中执行。 如果提供了-a，则 shell 将 name 作为第 0 个参数传递给执行的命令。 如果由于某种原因无法执行命令，则会退出非交互式 shell，除非启用了 shell 选项 execfail，在这种情况下它将返回失败。 如果无法执行文件，则交互式 shell 将返回失败。 如果未指定 command，则任何重定向在当前 shell 中生效，返回状态为 0.如果存在重定向错误，则返回状态为 1&lt;/p>
&lt;p>通过 exec 来执行的命令会顶替掉当前 shell 的进程，但是进程 PID 保持不变&lt;/p>
&lt;h1 id="xargs--把从前面获得的输入内容当成-xargs-后面的命令的选项或者参数来执行">xargs # 把从|前面获得的输入内容，当成 xargs 后面的命令的选项或者参数来执行&lt;/h1>
&lt;p>xargs [OPTIONS] COMMAND #不指定 COMMAND 则默认输出到屏幕上&lt;/p>
&lt;p>OPTIONS：&lt;/p>
&lt;ol>
&lt;li>
&lt;p>-d 指定获得输入内容的分隔符，默认分隔符为空白或换行&lt;/p>
&lt;/li>
&lt;li>
&lt;p>-n 每次传递 NUM 个字符给|后的内容&lt;/p>
&lt;/li>
&lt;/ol>
&lt;p>EXAMPLE：&lt;/p>
&lt;ul>
&lt;li>echo “&amp;ndash;help” | xargs cat #把&amp;ndash;help 当作 cat 的选项或者参数，如图所示，注意与管道符的应用实例 a 中的区别&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/sl7f9m/1616165959237-c4a1a831-c6a0-4c52-ba6f-9f071cb59ba3.jpeg" alt="">&lt;/p>
&lt;ul>
&lt;li>ls /var/run/docker/netns | xargs -I {} nsenter &amp;ndash;net=/var/run/docker/netns/{} ip addr #遍历 netns 目录下的所有文件,通过 xargs 命令把所有文件名传递给后面命令，作为后面命令的参数&lt;/li>
&lt;/ul></description></item><item><title>Docs: Job(任务)控制</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/4.terminal-%E4%B8%8E-shell/job%E4%BB%BB%E5%8A%A1%E6%8E%A7%E5%88%B6/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/4.terminal-%E4%B8%8E-shell/job%E4%BB%BB%E5%8A%A1%E6%8E%A7%E5%88%B6/</guid><description>
&lt;h2 id="job-control--在同一个-shell-下执行多个任务的控制">Job Control # 在同一个 Shell 下，执行多个任务的控制&lt;/h2>
&lt;p>在前台执行的程序为前台 JOB，前台程序占用一个 shell，执行该程序后，shell 无法再进行别的操作&lt;/p>
&lt;p>在后台执行的程序为后台 JOB，后台程序不占用 shell，可以在该 shell 下继续执行其余任务，不受 ctrl+c 的影响&lt;/p>
&lt;p>语法格式：&lt;/p>
&lt;ul>
&lt;li>ctrl+z # 在正在运行的 porcess 中使用这个组合键，可以让前台进程暂停&lt;/li>
&lt;li>fg %JobNumber # 让后台的进程在前台工作&lt;/li>
&lt;li>bg %JobNumber # 让前台的工作在后台工作&lt;/li>
&lt;li>nohup COMMAND # 让命令触发的进程不随 shell 关闭而停止&lt;/li>
&lt;li>COMMAND &amp;amp; # 让命令触发的进程直接在后台运行&lt;/li>
&lt;/ul>
&lt;p>**jobs [OPTIONS] **# 查看 jobs
OPTIONS：&lt;/p>
&lt;ul>
&lt;li>-l # 查看 jobs 的详细信息&lt;/li>
&lt;/ul></description></item><item><title>Docs: Redirection(重定向)</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/4.terminal-%E4%B8%8E-shell/redirection%E9%87%8D%E5%AE%9A%E5%90%91/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/4.terminal-%E4%B8%8E-shell/redirection%E9%87%8D%E5%AE%9A%E5%90%91/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;p>在执行命令之前，可以使用由 Shell 的特殊符号来重定向其输入和输出。 重定向还可以用于打开和关闭当前 Shell 执行环境的文件。 重定向操作符可以出现在简单命令的前面，也可以出现在命令的后面。重定向按照它们出现的顺序进行处理。 重定向按照从左到右的顺序显示。&lt;/p>
&lt;p>用一个简单的例子来理解一下什么是重定向&lt;/p>
&lt;pre>&lt;code>[root@ansible ~]# ls
anaconda-ks.cfg playbook scripts
[root@ansible ~]# ls &amp;gt; dirlist
[root@ansible ~]# cat dirlist
anaconda-ks.cfg
dirlist
playbook
scripts
&lt;/code>&lt;/pre>
&lt;p>这个例子就是将 ls 命令的标准输出的内容，重定向到 dirlist 文件中。(默认一个命令执行时，输出内容会打印在屏幕上，但是重定向后，将内容写入文件中)&lt;/p>
&lt;p>每个程序在运行后，都会至少打开三个 文件描述符，分别是&lt;/p>
&lt;ul>
&lt;li>0：标准输入&lt;/li>
&lt;li>1：标准输出&lt;/li>
&lt;li>2：标准错误&lt;/li>
&lt;/ul>
&lt;p>文件描述符介绍详见：文件描述符与打开文件之间的关系&lt;/p>
&lt;p>所以，shell 可以实现重定向，就是这 3 者其中之一，或者全部三者。&lt;/p>
&lt;h1 id="重定向的种类">重定向的种类&lt;/h1>
&lt;p>在下面各种重定向的语法中，n 表示文件描述符&lt;/p>
&lt;h2 id="redirecting-input-重定向输入">Redirecting Input 重定向输入&lt;/h2>
&lt;p>输入的重定向将打开名称为 WORD 的文件，以便在文件描述符 n 下打开标准输入，n 默认为 0。&lt;/p>
&lt;p>语法：COMMAND [n]&amp;lt; WORD&lt;/p>
&lt;p>EXAMPLE&lt;/p>
&lt;h2 id="redirecting-output-重定向输出">Redirecting Output 重定向输出&lt;/h2>
&lt;p>输出重定向将打开名称为 WORD 的文件，以便在文件描述符 n 上进行写操作，n 默认为 1。 如果 WORD 文件不存在，则创建该文件； 如果存在，则将其截断为零大小。&lt;/p>
&lt;p>语法：COMMAND [n]&amp;gt; WORD&lt;/p>
&lt;p>EXAMPLE&lt;/p>
&lt;pre>&lt;code># 将某个程序产生的标准输出和标注错误分别重定向到不同文件
[root@ansible te]# ls a.txt b.txt
ls: cannot access b.txt: No such file or directory
a.txt
[root@ansible te]# ls a.txt b.txt 1&amp;gt; stdout.log 2&amp;gt; errout.log
[root@ansible te]# ls
a.txt errout.log stdout.log
[root@ansible te]# cat errout.log
ls: cannot access b.txt: No such file or directory
[root@ansible te]# cat stdout.log
a.txt
&lt;/code>&lt;/pre>
&lt;h2 id="appending-redirected-output-重定向输出追加方式">Appending Redirected Output 重定向输出(追加方式)&lt;/h2>
&lt;p>语法：COMMAND [n]&amp;raquo; WORD&lt;/p>
&lt;h2 id="redirecting-standard-output-and-standard-error-重定向标准输出和标准错误">Redirecting Standard Output and Standard Error 重定向标准输出和标准错误&lt;/h2>
&lt;p>此结构允许将标准输出（文件描述符 1）和标准错误输出（文件描述符 2）都重定向到名称为 word 扩展的文件。&lt;/p>
&lt;p>语法：&lt;/p>
&lt;p>COMMAND &amp;gt; WORD 2&amp;gt;&amp;amp;1 #标准错误的信息传递给标准输出通道。&amp;amp;1 表示 标注输出通道。同理 1&amp;gt;&amp;amp;2 反过来理解即可。&lt;/p>
&lt;p>EXAMPLE&lt;/p>
&lt;pre>&lt;code># 与重定向输入的例子类似，这种符号可以理解为将 ls 命令的标准输出重定向到 out.log 文件中
# 而该命令的 标准错误 则传递到 标注输出 中，与标准输出一起重定向到 out.log 文件中
[root@ansible te]# ls a.txt b.txt
ls: cannot access b.txt: No such file or directory
a.txt
[root@ansible te]# ls a.txt b.txt &amp;gt; out.log 2&amp;gt;&amp;amp;1
[root@ansible te]# cat out.log
ls: cannot access b.txt: No such file or directory
a.txt
&lt;/code>&lt;/pre>
&lt;h2 id="here-documenttag-的重定向模式">Here Document（&amp;lt;&amp;lt;TAG 的重定向模式&lt;/h2>
&lt;p>&lt;strong>Here Document(简称 Heredoc)&lt;/strong> 是 shell 中的一种特殊重定向方式，用来将输入重定向到一个交互式的 shell 脚本或程序。&lt;/p>
&lt;p>语法：&lt;/p>
&lt;pre>&lt;code>COMMAND [n] &amp;lt;&amp;lt; TAG
Document
TAG
&lt;/code>&lt;/pre>
&lt;p>它的作用是将两个 TAG 之间的内容（docuemnt）作为输入传递给 n。&lt;/p>
&lt;p>注意：&lt;/p>
&lt;ul>
&lt;li>结尾的 TAG 一定要顶头写，前面不能有任何字符，后面也不能有任何字符，包括空格和 tab 缩进。&lt;/li>
&lt;li>开始的前后的空格不要被忽略掉。&lt;/li>
&lt;li>TAG 这三个字符可以用任意字符代替，日常常用 EOF 来标识，只要开头与结尾的字符相同即可&lt;/li>
&lt;/ul>
&lt;p>实例：
在命令行中通过 wc -l 命令计算 Here Document 的行数&lt;/p>
&lt;pre>&lt;code>wc -l &amp;lt;&amp;lt; EOF
学习使用shell 编程
www.xuhaoblog.com
EOF
&lt;/code>&lt;/pre>
&lt;p>输出的结果为 2。&lt;/p>
&lt;p>我们也可以将 Here Document 用在脚本中，例如：&lt;/p>
&lt;pre>&lt;code>#!/bin/bash
cat &amp;lt;&amp;lt; EOF
学习使用shell脚本编程
www.xuhaoblog.com
EOF
&lt;/code>&lt;/pre>
&lt;p>注意！！！：&lt;/p>
&lt;ul>
&lt;li>EOF 如果在写入内容时，想要防止将变量替换成值的话，需要在第一行 EOF 之前加 &lt;code>\&lt;/code> 或 &lt;code>-&lt;/code>，否则写入内容中如果有执行命令或者变量，则无法以文本写入。&lt;/li>
&lt;/ul>
&lt;p>效果如下&lt;/p>
&lt;pre>&lt;code>[root@lichenhao ~]# cat &amp;gt; 123 &amp;lt;&amp;lt; EOF
&amp;gt; $123
&amp;gt; EOF
[root@lichenhao ~]# cat 123
23
[root@lichenhao ~]# cat &amp;gt; 123 &amp;lt;&amp;lt; \EOF
&amp;gt; $123
&amp;gt; EOF
[root@lichenhao ~]# cat 123
$123
&lt;/code>&lt;/pre>
&lt;h2 id="here-strings">Here Strings&lt;/h2>
&lt;h2 id="duplicating-file-descriptors">Duplicating File Descriptors&lt;/h2>
&lt;pre>&lt;code> The redirection operator [n]&amp;lt;&amp;amp;word is used to duplicate input file descriptors. If word expands to one or more digits, the file descriptor denoted by n is made to be a copy of that file descriptor. If the digits in word do not specify a file descriptor open for input, a redirection error occurs. If word evaluates to -, file descriptor n is closed. If n is not specified, the standard input (file descriptor 0) is used. The operator [n]&amp;gt;&amp;amp;word is used similarly to duplicate output file descriptors. If n is not specified, the standard output (file descriptor 1) is used. If the digits in word do not specify a file descriptor open for output, a redirection error occurs. If word evaluates to -, file descriptor n is closed. As a special case, if n is omitted, and word does not expand to one or more digits or -, the standard output and standard error are redirected as described previously.
&lt;/code>&lt;/pre>
&lt;h2 id="moving-file-descriptors">Moving File Descriptors&lt;/h2>
&lt;pre>&lt;code> The redirection operator [n]&amp;lt;&amp;amp;digit- moves the file descriptor digit to file descriptor n, or the standard input (file descriptor 0) if n is not specified. digit is closed after being duplicated to n. Similarly, the redirection operator [n]&amp;gt;&amp;amp;digit- moves the file descriptor digit to file descriptor n, or the standard output (file descriptor 1) if n is not specified.
&lt;/code>&lt;/pre>
&lt;h2 id="opening-file-descriptors-for-reading-and-writing">Opening File Descriptors for Reading and Writing&lt;/h2>
&lt;p>The redirection operator [n]&amp;lt;&amp;gt;word causes the file whose name is the expansion of word to be opened for both reading and writing on file descriptor n, or on file descriptor 0 if n is not specified. If the file does not exist, it is created.&lt;/p>
&lt;h1 id="简单总结">简单总结&lt;/h1>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>命令&lt;/th>
&lt;th>说明&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>command &amp;gt; file&lt;/td>
&lt;td>将输出重定向到 file。&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>command &amp;lt; file&lt;/td>
&lt;td>将输入重定向到 command。&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>command &amp;raquo; file&lt;/td>
&lt;td>将输出以追加的方式重定向到 file。&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>n &amp;gt; file&lt;/td>
&lt;td>将文件描述符为 n 的文件重定向到 file。&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>n &amp;raquo; file&lt;/td>
&lt;td>将文件描述符为 n 的文件以追加的方式重定向到 file。&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>n &amp;gt;&amp;amp; m&lt;/td>
&lt;td>将输出文件 m 和 n 合并。&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>n &amp;lt;&amp;amp; m&lt;/td>
&lt;td>将输入文件 m 和 n 合并。&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&amp;laquo; tag&lt;/td>
&lt;td>将开始标记 tag 和结束标记 tag 之间的内容作为输入。&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h1 id="如何理解-linux-shell-中重定向">如何理解 Linux shell 中重定向&lt;/h1>
&lt;p>前言&lt;/p>
&lt;p>有时候我们常看到类似这样的脚本调用：&lt;/p>
&lt;p>./test.sh &amp;gt; log.txt 2&amp;gt;&amp;amp;1&lt;/p>
&lt;p>这里的 2&amp;gt;&amp;amp;1 是什么意思？该如何理解？&lt;/p>
&lt;p>先说结论：上面的调用表明将./test.sh 的输出重定向到 log.txt 文件中，同时将标准错误也重定向到 log.txt 文件中。&lt;/p>
&lt;p>有何妙用&lt;/p>
&lt;p>（如果已经明白是什么作用，可跳过此小节）&lt;/p>
&lt;p>上面到底是什么意思呢？我们来看下面的例子，假如有脚本 test.sh：&lt;/p>
&lt;p>#!/bin/bashdate #打印当前时间 while true #死循环 do #每隔 2 秒打印一次 sleep 2 whatthis #不存在的命令 echo -e &amp;ldquo;std output&amp;quot;done&lt;/p>
&lt;p>脚本中先打印当前日期，然后每隔 2 秒执行 whatthis 并打印一段字符。由于系统中不存在 whatthis 命令，因此执行会报错。&lt;/p>
&lt;p>假如我们想保存该脚本的打印结果，只需将 test.sh 的结果重定向到 log.txt 中即可：&lt;/p>
&lt;p>./test.sh &amp;gt; log.txt&lt;/p>
&lt;p>执行结果如下：&lt;/p>
&lt;p>ubuntu$ ./test.sh &amp;gt;log.txt./test.sh: 行 7: whatthis: 未找到命令&lt;/p>
&lt;p>我们明明将打印内容重定向到 log.txt 中了，但是这条错误信息却没有重定向到 log.txt 中。如果你是使用程序调用该脚本，当查看脚本日志的时候，将会完全看不到这条错误信息。而使用下面的方式则会将出错信息也重定向到 log.txt 中：&lt;/p>
&lt;p>./test.sh &amp;gt; log.txt 2&amp;gt;&amp;amp;1&lt;/p>
&lt;p>以这样的方式调用脚本，可以很好的将错误信息保存，帮助我们定位问题。&lt;/p>
&lt;p>如何理解&lt;/p>
&lt;p>每个程序在运行后，都会至少打开三个文件描述符，分别是 0：标准输入；1：标准输出；2：标准错误。&lt;/p>
&lt;p>例如，对于前面的 test.sh 脚本，我们通过下面的步骤看到它至少打开了三个文件描述符：&lt;/p>
&lt;p>./test.sh #运行脚本 ps -ef|grep test.sh #重新打开命令串口，使用 ps 命令找到 test.sh 的 pidhyb 5270 4514 0 19:20 pts/7 00:00:00 /bin/bash ./test.shhyb 5315 5282 0 19:20 pts/11 00:00:00 grep &amp;ndash;color=auto test.sh&lt;/p>
&lt;p>可以看到 test.sh 的 pid 为 5270，进入到相关 fd 目录：&lt;/p>
&lt;p>cd /proc/5270/fd #进程 5270 所有打开的文件描述符信息都在此 ls -l #列出目录下的内容 0 -&amp;gt; /dev/pts/7 1 -&amp;gt; /dev/pts/7 2 -&amp;gt; /dev/pts/7 255 -&amp;gt; /home/hyb/workspaces/shell/test.sh&lt;/p>
&lt;p>可以看到，test.sh 打开了 0，1，2 三个文件描述符。同样的，如果有兴趣，也可以查看其他运行进程的文件描述符打开情况，除非关闭了否则都会有这三个文件描述符。&lt;/p>
&lt;p>那么现在就容易理解前面的疑问了，2&amp;gt;&amp;amp;1 表明将文件描述 2（标准错误输出）的内容重定向到文件描述符 1（标准输出），为什么 1 前面需要&amp;amp;？当没有&amp;amp;时，1 会被认为是一个普通的文件，有&amp;amp;表示重定向的目标不是一个文件，而是一个文件描述符。在前面我们知道，test.sh &amp;gt;log.txt 又将文件描述符 1 的内容重定向到了文件 log.txt，那么最终标准错误也会重定向到 log.txt。我们同样通过前面的方法，可以看到 test.sh 进程的文件描述符情况如下：&lt;/p>
&lt;p>0 -&amp;gt; /dev/pts/7 1 -&amp;gt; /home/hyb/workspaces/shell/log.txt 2 -&amp;gt; /home/hyb/workspaces/shell/log.txt 255 -&amp;gt; /home/hyb/workspaces/shell/test.sh&lt;/p>
&lt;p>我们可以很明显地看到，文件描述符 1 和 2 都指向了 log.txt 文件，也就得到了我们最终想要的效果：将标准错误输出重定向到文件中。&lt;/p>
&lt;p>它们还有两种等价写法：&lt;/p>
&lt;p>./test.sh &amp;gt;&amp;amp; log.txt./test.sh &amp;amp;&amp;gt; log.txt&lt;/p>
&lt;p>总结&lt;/p>
&lt;p>我们总结一下前面的内容：&lt;/p>
&lt;ul>
&lt;li>程序运行后会打开三个文件描述符，分别是标准输入，标准输出和标准错误输出。&lt;/li>
&lt;li>在调用脚本时，可使用 2&amp;gt;&amp;amp;1 来将标准错误输出重定向。&lt;/li>
&lt;li>只需要查看脚本的错误时，可将标准输出重定向到文件，而标准错误会打印在控制台，便于查看。&lt;/li>
&lt;li>
&lt;blockquote>
&lt;blockquote>
&lt;p>log.txt 会将重定向内容追加到 log.txt 文件末尾。&lt;/p>
&lt;/blockquote>
&lt;/blockquote>
&lt;/li>
&lt;li>通过查看/proc/进程 id/fd 下的内容，可了解进程打开的文件描述符信息。&lt;/li>
&lt;/ul>
&lt;h1 id="重定向应用示例">重定向应用示例&lt;/h1>
&lt;h2 id="一般来说-1-通常可以省略成-">一般来说, &amp;ldquo;1&amp;gt;&amp;rdquo; 通常可以省略成 &amp;ldquo;&amp;gt;&amp;rdquo;.&lt;/h2>
&lt;p>即可以把如上命令写成: ls a.txt b.txt &amp;gt;file.out 2&amp;gt;file.err&lt;/p>
&lt;p>有了这些认识才能理解 &amp;ldquo;1&amp;gt;&amp;amp;2&amp;rdquo; 和 &amp;ldquo;2&amp;gt;&amp;amp;1&amp;rdquo;.&lt;/p>
&lt;p>1&amp;gt;&amp;amp;2 正确返回值传递给 2 输出通道 &amp;amp;2 表示 2 输出通道&lt;/p>
&lt;p>如果此处错写成 1&amp;gt;2, 就表示把 1 输出重定向到文件 2 中.&lt;/p>
&lt;p>2&amp;gt;&amp;amp;1 错误返回值传递给 1 输出通道, 同样&amp;amp;1 表示 1 输出通道.&lt;/p>
&lt;p>举个例子.&lt;/p>
&lt;p>[root@redhat box]# ls a.txt b.txt 1&amp;gt;file.out 2&amp;gt;&amp;amp;1&lt;/p>
&lt;p>[root@redhat box]# cat file.out&lt;/p>
&lt;p>ls: b.txt: No such file or directory&lt;/p>
&lt;p>a.txt&lt;/p>
&lt;p>现在, 正确的输出和错误的输出都定向到了 file.out 这个文件中, 而不显示在前端.&lt;/p>
&lt;p>补充下, 输出不只 1 和 2, 还有其他的类型, 这两种只是最常用和最基本的.&lt;/p>
&lt;p>例如：&lt;/p>
&lt;p>rm -f $(find / -name core) &amp;amp;&amp;gt; /dev/null，/dev/null 是一个文件，这个文件比较特殊，所有传给它的东西它都丢弃掉。&lt;/p>
&lt;p>例如：&lt;/p>
&lt;p>注意，为了方便理解，必须设置一个环境使得执行 grep da *命令会有正常输出和错误输出，然后分别使用下面的命令生成三个文件：&lt;/p>
&lt;p>grep da * &amp;gt; greplog1&lt;/p>
&lt;p>grep da * &amp;gt; greplog2 1&amp;gt;&amp;amp;2&lt;/p>
&lt;p>grep da _ &amp;gt; greplog3 2&amp;gt;&amp;amp;1 //grep da _ 2&amp;gt; greplog4 1&amp;gt;&amp;amp;2 结果一样&lt;/p>
&lt;p>#查看 greplog1 会发现里面只有正常输出内容&lt;/p>
&lt;p>#查看 greplog2 会发现里面什么都没有#查看 greplog3 会发现里面既有正常输出内容又有错误输出内容&lt;/p>
&lt;h1 id="tee-命令">tee 命令&lt;/h1>
&lt;p>在非 root 用户时，重定向总是会提示权限不够，这时候，可以使用 tee 命令来代替重定向符号
比如
&lt;code>containerd config default | sudo tee /etc/containerd/config.toml&lt;/code>
等效于
&lt;code>containerd config default &amp;gt; /etc/containerd/config.toml&lt;/code>&lt;/p>
&lt;p>还可以这么用&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>sudo tee ~/test_dir/test.sh &lt;span style="color:#e6db74">&amp;lt;&amp;lt;EOF
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">${abc}
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">EOF&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>若要让写入文件中的内容，将 &lt;code>$&lt;/code> 等符号当做字符串处理的话，则这么用：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>sudo tee ~/test_dir/test.sh &amp;lt;&amp;lt;-&lt;span style="color:#e6db74">&amp;#34;EOF&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">${&lt;/span>abc&lt;span style="color:#e6db74">}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>EOF
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="syntax语法">Syntax(语法)&lt;/h2>
&lt;p>&lt;strong>tee [OPTIONS] FILE&lt;/strong>&lt;/p>
&lt;p>OPTIONS&lt;/p>
&lt;ul>
&lt;li>**-a, &amp;ndash;append **# 将读取到内容追加到文件中，而不是覆盖。等效于 &lt;code>&amp;gt;&amp;gt;&lt;/code> 符号&lt;/li>
&lt;/ul></description></item><item><title>Docs: set 命令</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/4.terminal-%E4%B8%8E-shell/shell-%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/set-%E5%91%BD%E4%BB%A4/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/4.terminal-%E4%B8%8E-shell/shell-%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/set-%E5%91%BD%E4%BB%A4/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://www.gnu.org/software/bash/manual/html_node/The-Set-Builtin.html">GNU 文档，Bash 参考手册-Shell 内置命令-修改 Shell 行为-Set 内置命令&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://morven.life/posts/how-to-write-robust-shell-script/">https://morven.life/posts/how-to-write-robust-shell-script/&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;h2 id="前言">前言&lt;/h2>
&lt;p>Shell 脚本会有各种坑，经常导致 Shell 脚本因为各种原因不能正常执行成功。实际上，编写健壮可靠的 Shell 脚本也是有一定的技巧的。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># 在执行Shell脚本的时候，通常都会创建一个新的Shell，比如，当我们执行：&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>bash script.sh
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Bash 会创建一个新的 Shell 来执行 script.sh，同时也默认给定了这个执行环境的各种参数。set 命令可以用来修改 Shell 环境的运行参数，不带任何参数的 set 命令，会显示所有的环境变量和 Shell 函数。我们重点介绍其中最常用的四个。&lt;/p>
&lt;p>set -euxo pipefail&lt;/p>
&lt;h2 id="set--x">set -x&lt;/h2>
&lt;p>默认情况下，Shell 脚本执行后只显示运行结果，不会展示结果是哪一行代码的输出，如果多个命令连续执行，它们的运行结果就会连续输出，导致很难分清一串结果是什么命令产生的。
set -x 用来在运行结果之前，先输出执行的那一行命令，行首以+表示是命令而非命令输出，同时，每个命令的参数也会展开，我们可以清晰地看到每个命令的运行实参，这对于 Shell 的 debug 来说非常友好。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#!/bin/bash
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>set -x
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>v&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">5&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>echo $v
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>echo &lt;span style="color:#e6db74">&amp;#34;hello&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># output:&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># + v=5&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># + echo 5&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># 5&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># + echo hello&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># hello&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>实际上，set -x 还有另一种写法 set -o xtrace。&lt;/p>
&lt;h2 id="set--u">set -u&lt;/h2>
&lt;p>Shell 脚本不像其他高级语言，如 Python, Ruby 等，Shell 脚本默认不提供安全机制，举个简单的例子，Ruby 脚本尝试去读取一个没有初始化的变量的内容的时候会报错，而 Shell 脚本默认不会有任何提示，只是简单地忽略。&lt;/p>
&lt;pre>&lt;code>#!/bin/bash
echo $v
echo &amp;quot;hello&amp;quot;
# output:
#
# hello
&lt;/code>&lt;/pre>
&lt;p>可以看到，echo $v 输出了一个空行，Bash完全忽略了不存在的$v 继续执行后面的命令 echo &amp;ldquo;hello&amp;rdquo;。这其实并不是开发者想要的行为，对于不存在的变量，脚本应该报错且停止执行来防止错误的叠加。set -u 就用来改变这种默认忽略未定义变量行为，脚本在头部加上它，遇到不存在的变量就会报错，并停止执行。&lt;/p>
&lt;pre>&lt;code>#!/bin/bash
set -u
echo $a
echo bar
# output:
# ./script.sh: line 4: v: unbound variable
&lt;/code>&lt;/pre>
&lt;p>set -u 另一种写法是 set -o nounset&lt;/p>
&lt;h2 id="set--e">set -e&lt;/h2>
&lt;p>对于默认的 Shell 脚本运行环境，有运行失败的命令（返回值非 0），Bash 会继续执行后面的命令：&lt;/p>
&lt;pre>&lt;code>#!/bin/bash
unknowncmd
echo &amp;quot;hello&amp;quot;
# output:
# ./script.sh: line 3: unknowncmd: command not found
# hello
&lt;/code>&lt;/pre>
&lt;p>可以看到，Bash 只是显示有错误，接着继续执行 Shell 脚本，这种行为很不利于脚本安全和排错。实际开发中，如果某个命令失败，往往需要脚本停止&lt;/p>
&lt;p>set -e 从根本上解决了这个问题，它使得脚本只要发生错误，就终止执行：&lt;/p>
&lt;pre>&lt;code>#!/bin/bash
set -e
unknowncmd
echo &amp;quot;hello&amp;quot;
# output:
# ./script.sh: line 4: unknowncmd: command not found
&lt;/code>&lt;/pre>
&lt;p>可以看到，第 4 行执行失败以后，脚本就终止执行了。&lt;/p>
&lt;p>set -e 根据命令的返回值来判断命令是否运行失败。但是，某些命令的非零返回值可能不表示失败，或者开发者希望在命令失败的情况下，脚本继续执行下去：&lt;/p>
&lt;pre>&lt;code>#!/bin/bash
set -e
$(ls foobar)
echo &amp;quot;hello&amp;quot;
# output:
# ls: cannot access 'foobar': No such file or directory
&lt;/code>&lt;/pre>
&lt;p>可以看到，打开 set -e 之后，即使 ls 是一个已存在的命令，但因为 ls 命令的运行参数 foobar 实际上并不存在导致命令的返回非 0 值，这有时候并不是我们看到的。&lt;/p>
&lt;p>可以暂时关闭 set -e，该命令执行结束后，再重新打开 set -e：&lt;/p>
&lt;pre>&lt;code>#!/bin/bash
set -e
set +e
$(ls foobar)
set -e
echo &amp;quot;hello&amp;quot;
# output:
# ls: cannot access 'foobar': No such file or directory
# hello
&lt;/code>&lt;/pre>
&lt;p>上面代码中，set +e 表示关闭-e 选项，set -e 表示重新打开-e 选项。&lt;/p>
&lt;p>还有一种方法是使用 command || true，使得该命令即使执行失败，脚本也不会终止执行。&lt;/p>
&lt;p>set -e 还有另一种写法 set -o errexit。&lt;/p>
&lt;h2 id="set--o-pipefail">set -o pipefail&lt;/h2>
&lt;p>set -e 有一个例外情况，就是不适用于管道命令。对于管道命令，Bash 会把最后一个子命令的返回值作为整个命令的返回值。也就是说，只要最后一个子命令不失败，管道命令总是会执行成功，因此它后面命令依然会执行，set -e 就失效了。&lt;/p>
&lt;p>请看下面这个例子。&lt;/p>
&lt;pre>&lt;code>#!/bin/bash
set -e
foo | echo &amp;quot;bar&amp;quot;
echo &amp;quot;hello&amp;quot;
# output:
# ./script.sh: line 4: foo: command not found
# bar
# hello
&lt;/code>&lt;/pre>
&lt;p>可以看到，foo 是一个不存在的命令，但是 foo | echo bar 这个管道命令还是会执行成功，导致后面的 echo hello 会继续执行。&lt;/p>
&lt;p>set -o pipefail 用来解决这种情况，只要一个子命令失败，整个管道命令就失败，脚本就会终止执行：&lt;/p>
&lt;pre>&lt;code>#!/bin/bash
set -e
set -o pipefail
foo | echo &amp;quot;bar&amp;quot;
echo &amp;quot;hello&amp;quot;
# output:
# ./script.sh: line 5: foo: command not found
# bar
&lt;/code>&lt;/pre>
&lt;p>可以看到，echo hello 命令并没有执行。&lt;/p>
&lt;p>合并四个参数&lt;/p>
&lt;p>对于上面提到的四个 set 命令参数，一般都放在一起使用。&lt;/p>
&lt;h1 id="写法一-set--euxo-pipefail-写法二-set--euxset--o-pipefail">写法一 set -euxo pipefail# 写法二 set -euxset -o pipefail&lt;/h1>
&lt;p>这两种写法任选其一放在所有 Shell 脚本的头部。&lt;/p>
&lt;p>当然，也可以在在执行 Shell 脚本的时候，从 Bash 命令行传入这些参数：&lt;/p>
&lt;p>bash -euxo pipefail script.sh&lt;/p>
&lt;h1 id="shell-脚本防御式编程">Shell 脚本防御式编程&lt;/h1>
&lt;p>编写 Shell 脚本的时候应该考虑不可预期的程序输入，如文件不存在或者目录没有创建成功…其实 Shell 命令有很多选项可以解决这类问题，例如，使用 mkdir 创建目录的时候，如果父目录不存在，mkdir 默认返回错误，但如果加上-p 选项，mkdir 在父目录不存在的情况下先创建父目录；rm 在删除一个不存在的文件会失败，但如果加上-f 选项，即使文件不能存在也能执行成功。&lt;/p>
&lt;p>注意字符串中的空格&lt;/p>
&lt;p>我们必须时刻注意字符串中的空格字符，如文件名中的空格，命令参数中的空格等等，对于这些空格字符安全的最佳时实践是使用&amp;quot;括住相应的字符串：&lt;/p>
&lt;h1 id="will-fail-if-filename-contains-spacesif--filename--foo--will-success-even-if-filename-contains-spacesif--filename--foo-">will fail if $filename contains spacesif [ $filename = &amp;ldquo;foo&amp;rdquo; ];# will success even if $filename contains spacesif [ &amp;ldquo;$filename&amp;rdquo; = &amp;ldquo;foo&amp;rdquo; ];&lt;/h1>
&lt;p>Someone will always use spaces in filenames or command line arguments and you should keep this in mind when writing shell scripts. In particular you should use quotes around variables.&lt;/p>
&lt;p>if [ $filename = “foo” ]; will fail if $filename contains a space. This can be fixed by using:&lt;/p>
&lt;p>if [ “$filename” = “foo” ];&lt;/p>
&lt;p>类似的情况是，我们在使用$@或者其他包含由空格分割的多个字符串也要注意使用&amp;quot;括住相应的变量，实际上，使用&amp;quot;括住相应的变量没有任何副作用，只会是我们的 Shell 脚本更加健壮：&lt;/p>
&lt;p>foo() { for i in $@; do printf &amp;ldquo;%s\n&amp;rdquo; &amp;ldquo;$i&amp;rdquo;; done }; foo bar &amp;ldquo;baz quux&amp;quot;barbazquuxfoo() { for i in &amp;ldquo;$@&amp;rdquo;; do printf &amp;ldquo;%s\n&amp;rdquo; &amp;ldquo;$i&amp;rdquo;; done }; foo bar &amp;ldquo;baz quux&amp;quot;barbaz quux&lt;/p>
&lt;h1 id="使用-trap-命令">使用 trap 命令&lt;/h1>
&lt;p>关于 Shell 脚本一个常见的情况是，脚本执行失败导致文件系统处于不一致的状态，比如文件锁、临时文件或者 Shell 脚本的错误只更新了部分文件。为了达到“事务的完整性”我们需要解决这些不一致的问题，要么删除文件锁、临时文件，要么将状态恢复到更新之前的状态。实际上，Shell 脚本确实提供了一种在捕捉到特定的 unix 信号的情况下执行一段命令或者函数的功能：&lt;/p>
&lt;p>trap command signal [signal &amp;hellip;]&lt;/p>
&lt;p>其实 Shell 脚本可以捕捉很多类型的信号（完整信号列表可以使用 kill -l 命令获取），但是我们通常只关心在问题发生之后用来恢复现场的三种信号：INT，TERM 和 EXIT&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>&lt;/th>
&lt;th>&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>Signal&lt;/td>
&lt;td>Description&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>INT&lt;/td>
&lt;td>Interrupt – this signal is sent when someone kills the script by pressing ctrl-c&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>TERM&lt;/td>
&lt;td>Terminate – this signal is sent when someone sends the TERM signal using the kill command&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>EXIT&lt;/td>
&lt;td>Exit – this is a pseudo-signal and is triggered when your script exits, either through reaching the end of the script, an exit command or by a command failing when using set -e&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>一般情况下，我们在操作对应的共享区之前先创建文件锁：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">if&lt;/span> &lt;span style="color:#f92672">[&lt;/span> ! -e $lockfile &lt;span style="color:#f92672">]&lt;/span>; &lt;span style="color:#66d9ef">then&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> touch $lockfile
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> critical-section
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> rm $lockfile
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">else&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> echo &lt;span style="color:#e6db74">&amp;#34;critical-section is already running&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">fi&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>但是当 Shell 脚本操作对应的共享区的时候有人手动 Kill 掉对应的 Shell 脚本进程，这个时候文件锁的存在会导致 Shell 脚本不能再次操作对应的共享区。使用 trap 我们可以捕捉到对应的 Kill 信号并做相应的恢复操作：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">if&lt;/span> &lt;span style="color:#f92672">[&lt;/span> ! -e $lockfile &lt;span style="color:#f92672">]&lt;/span>; &lt;span style="color:#66d9ef">then&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> trap &lt;span style="color:#e6db74">&amp;#34;rm -f &lt;/span>$lockfile&lt;span style="color:#e6db74">; exit&amp;#34;&lt;/span> INT TErm EXIT
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> touch $lockfile
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> $lockfile
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> rm $lockfile
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> trap - INT TErm EXIT
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">else&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> echo &lt;span style="color:#e6db74">&amp;#34;critical-section is already running&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">fi&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>有了上面这段 trap 命令，即使当 Shell 脚本操作对应的共享区的时候有人手动 Kill 掉对应的 Shell 脚本进程，文件锁也会被清理干净。需要注意的是，我们在捕捉到 Kill 信号之后删除完文件锁之后直接退出而不是继续执行&lt;/p>
&lt;p>。&lt;/p>
&lt;p>Be Atomic&lt;/p>
&lt;p>很多时候我们需要一次更新一批文件，但是有可能在更新了一半之后 Shell 脚本出错或者有人 kill 掉了 Shell 脚本的进程。你可能会想到，就使用刚才学到的 trap 知识，同时对就文件做备份，一旦捕捉到出错的信号，就恢复备份。这看起来没错，但是很多时候只能解决一部分的问题。例如，我们要把一个网站里面的 URL 从www.example.org全部更新为www.example.com，Shell脚本的主要逻辑类似于这样：&lt;/p>
&lt;p>for file in $(find /var/www -type f -name &amp;ldquo;*.html&amp;rdquo;); do perl -pi -e &amp;rsquo;s/www.example.org/www.example.com/&amp;rsquo; $filedone&lt;/p>
&lt;p>正确的做法是尽量使更新操作原子化，实现操作的“事务一致性”：1. 拷贝旧目录；2. 在拷贝的目录中进行更新操作；3. 替换原目录&lt;/p>
&lt;p>cp -a /var/www /var/www-tmpfor file in $(find /var/www-tmp -type f -name &amp;ldquo;*.html&amp;rdquo;); do perl -pi -e &amp;rsquo;s/www.example.org/www.example.com/&amp;rsquo; $filedonemv /var/www /var/www-oldmv /var/www-tmp /var/www&lt;/p>
&lt;p>在类 Unix 文件系统上进行最后的两次 mv 操作是非常快的（因为只需要替换两个目录的 inode，而不用执行实际的拷贝操作），换句话说，容易出错的地方是批量的更新操作，而我们将更新操作全部在拷贝的目录中执行，这样，更新操作即使出错，也不会影响原目录。这里的技巧是，使用双倍的硬盘空间来进行操作，任何是需要长时间打开文件的操作都是在备份目录中进行。事实上，保持一系列操作的原子性对于某些容易出错的 Shell 脚本来说非常重要，同时操作前备份文件也是一个好的编程习惯。&lt;/p></description></item><item><title>Docs: Shell 编程语言</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/4.terminal-%E4%B8%8E-shell/shell-%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/4.terminal-%E4%B8%8E-shell/shell-%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://wangdoc.com/bash/index.html">https://wangdoc.com/bash/index.html&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>&lt;strong>Shell Programming Language(shell 编程语言)&lt;/strong> 不是编译型的语言，而是一种脚本语言。&lt;/p>
&lt;h1 id="shell-的基本结构与要素">Shell 的基本结构与要素&lt;/h1>
&lt;p>shell 语言的运行环境依赖于其所使用的 shell，是 bash、sh 还是 zsh 等等。想要执行 shell 语言，并不需要下载一个编译器，直接在指定的 shell 中执行代码即可。&lt;/p>
&lt;p>脚本式的语言是编写完代码之后，一条一条执行，所以可以把平时在 Linux 上操作的 Bash Shell 想象成一个大型的文本编辑器，每输入一条命令，就相当于一行代码，直接通过这个 Bash 的 shell 就执行了，而把很多命令组合起来，放在一个文件里，直接运行该文件，与在界面输入很多内容，有异曲同工之妙。&lt;/p>
&lt;p>由于 Shell 语言不需要编译器，所以 Shell 代码的第一行，必须指定其内的代码使用什么 Shell 来运行。&lt;/p>
&lt;h2 id="hello-world">Hello World&lt;/h2>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#!/bin/bash # 告诉内该脚本用什么shell运行，必须是脚本第一行
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>printf &lt;span style="color:#e6db74">&amp;#39;Hello World!&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>其实如果是在某个系统下运行代码，第一行也是可以省略的，第一行的意思其实就是代表运行后续命令的环境，而第一行其实也是调用系统 /bin/ 目录下的 bash 二进制文件，来执行后续的代码。&lt;/p>
&lt;h2 id="shell-语言中的关键字">Shell 语言中的关键字&lt;/h2>
&lt;p>Shell 语言中的关键字，就是该 Shell 所在系统下的可用命令+该 Shell 自带的一些命令。比如 bash Shell 会自带 if&amp;hellip;else&amp;hellip;fi 这种控制结构的关键字(虽然没有不带的。。。我就是这么一说。。。)。所以在 Shell 的 代码中，大部分的关键字都是一个个的 Linux 命令。而那些非系统自带的命令(或者说工具)，可以理解为 Shell 编程语言的第三方库。&lt;/p>
&lt;h1 id="shell-中特殊符号的说明">Shell 中特殊符号的说明&lt;/h1>
&lt;p>这些特殊符号的作用，一般是在对 Linux 和 shell 有一定了解的基础上，才能明白其作用。&lt;/p>
&lt;h2 id="--和--单引号-和-双引号">&lt;code>' '&lt;/code> 和 &lt;code>&amp;quot; &amp;quot;&lt;/code>(单引号 和 双引号)&lt;/h2>
&lt;p>首先，单引号和双引号，都是为了解决中间有空格的问题。&lt;/p>
&lt;p>因为空格在 Shell 中时作为一个很典型的分隔符，比如 string1=this is astring，这样执行就会报错。为了避免这个问题，因此就产生了单引号和双引号。&lt;/p>
&lt;p>单引号引用的内容，所见即所得。即将单引号内的内容原样输出，或者描述为单引号里面看到的是什么就会输出什么。单引号是全引用，被单引号括起的内容不管是常量还是变量都不会发生替换。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">[&lt;/span>root@lichenhao ~&lt;span style="color:#f92672">]&lt;/span>&lt;span style="color:#75715e"># var=dablelv&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">[&lt;/span>root@lichenhao ~&lt;span style="color:#f92672">]&lt;/span>&lt;span style="color:#75715e"># echo &amp;#39;$var&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>$var
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>双引号引用的内容，所见非所得。如果内容中有命令、变量等，会先把变量、命令解析出结果，然后在输出最终内容。双引号是部分引用，被双引号括起的内容常量还是常量，变量则会发生替换，替换成变量内容。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">[&lt;/span>root@lichenhao ~&lt;span style="color:#f92672">]&lt;/span>&lt;span style="color:#75715e"># var=dablelv&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">[&lt;/span>root@lichenhao ~&lt;span style="color:#f92672">]&lt;/span>&lt;span style="color:#75715e"># echo &amp;#34;$var&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>dablelv
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>无引号不使用引号定义字符串时，字符串不能包含空白字符（如 Space 或 Tab），需要该加引号，一般连续的字符串，数字，路径等可以不加引号。如果内容中有命令、变量等，会先把变量、命令解析出结果，然后在输出最终内容。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">[&lt;/span>root@lichenhao ~&lt;span style="color:#f92672">]&lt;/span>&lt;span style="color:#75715e"># str3=test String&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>-bash: String: 未找到命令
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">[&lt;/span>root@lichenhao ~&lt;span style="color:#f92672">]&lt;/span>&lt;span style="color:#75715e"># echo $str3&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">[&lt;/span>root@lichenhao ~&lt;span style="color:#f92672">]&lt;/span>&lt;span style="color:#75715e">#&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>可见，字符串中包含有空格时不实用引号括起来，将无法正常输出。&lt;/p>
&lt;h2 id="-和---用于命令替换">&lt;code>$()&lt;/code> 和 &lt;code> &lt;/code> 用于命令替换&lt;/h2>
&lt;p>在 bash shell 中，$( ) 与&lt;code> &lt;/code> (反引号) 都是用来做命令替换用(command substitution)的。&lt;/p>
&lt;p>例如：version=$(uname -r) 和 version=&lt;code>uname -r&lt;/code> 都可以使 version 得到内核的版本号&lt;/p>
&lt;p>各自的优缺点：&lt;/p>
&lt;ol>
&lt;li>&lt;code> &lt;/code> 基本上可用在全部的 unix shell 中使用，若写成 shell script ，其移植性比较高。但反单引号容易打错或看错。&lt;/li>
&lt;li>$( ) 并不是所有 shell 都支持。&lt;/li>
&lt;/ol>
&lt;h2 id="-和-">&lt;code>$[]&lt;/code> 和 &lt;code>$(())&lt;/code>&lt;/h2>
&lt;p>它们是一样的，都是进行数学运算的。支持+ - * / %：分别为 “加、减、乘、除、取模”。但是注意，bash 只能作整数运算，对于浮点数是当作字符串处理的。
例：$ a=5; b=7; c=2$ echo $(( a+b*c ))19$ echo $(( (a+b)/c ))6$ echo $(( (a*b)%c))1&lt;/p>
&lt;p>在 $(( )) 中的变量名称，可于其前面加 $ 符号来替换，也可以不用，如：&lt;/p>
&lt;p>$(( $a + $b * $c)) 也可得到 19 的结果&lt;/p>
&lt;p>此外，$(( )) 还可作不同进位(如二进制、八进位、十六进制)作运算呢，只是，输出结果皆为十进制而已：&lt;/p>
&lt;p>echo $((16#2a)) 结果为 42 (16 进位转十进制)&lt;/p>
&lt;h2 id="--test-命令的另一种形式">&lt;code>[ ]&lt;/code> &lt;code>test&lt;/code> 命令的另一种形式。&lt;/h2>
&lt;p>注意：&lt;/p>
&lt;ul>
&lt;li>你必须在左括号的右侧和右括号的左侧各加一个空格，否则会报错。&lt;/li>
&lt;li>test 命令使用标准的数学比较符号来表示字符串的比较，而用文本符号来表示数值的比较。很多人会记反了。使用反了，shell 可能得不到正确的结果。&lt;/li>
&lt;li>大于符号或小于符号必须要转义，否则会被理解成重定向。
&lt;ul>
&lt;li>bash 的内部命令，[和 test 是等同的。如果我们不用绝对路径指明，通常我们用的都是 bash 自带的命令。if/test 结构中的左中括号是调用 test 的命令标识，右中括号是关闭条件判断的。这个命令把它的参数作为比较表达式或者作为文件测试，并且根据比较的结果来返回一个退出状态码。if/test 结构中并不是必须右中括号，但是新版的 Bash 中要求必须这样。&lt;/li>
&lt;li>Test 和[]中可用的比较运算符只有==和!=，两者都是用于字符串比较的，不可用于整数比较，整数比较只能使用-eq，-gt 这种形式。无论是字符串比较还是整数比较都不支持大于号小于号。如果实在想用，对于字符串比较可以使用转义形式，如果比较&amp;quot;ab&amp;quot;和&amp;quot;bc&amp;quot;：[ ab &amp;lt; bc ]，结果为真，也就是返回状态为 0。[ ]中的逻辑与和逻辑或使用-a 和-o 表示。&lt;/li>
&lt;li>字符范围。用作正则表达式的一部分，描述一个匹配的字符范围。作为 test 用途的中括号内不能使用正则。&lt;/li>
&lt;li>在一个 array 结构的上下文中，中括号用来引用数组中每个元素的编号。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h2 id="--和--">&lt;code>(( ))&lt;/code> 和 &lt;code>[[ ]]&lt;/code>&lt;/h2>
&lt;p>它们分别是[ ]的针对数学比较表达式和字符串表达式的加强版。&lt;/p>
&lt;p>注意：[[]]会把 0 开头的整型数字当成 8 进制数来处理，所以以 0 开头的整型数如果想要按照 10 进制处理需要使用[]来处理&lt;/p>
&lt;p>其中(( ))，不需要再将表达式里面的大小于符号转义，除了可以使用标准的数学运算符外，还增加了以下符号：&lt;/p>
&lt;p>①[[是 bash 程序语言的关键字。并不是一个命令，[[ ]] 结构比[ ]结构更加通用。在[[和]]之间所有的字符都不会发生文件名扩展或者单词分割，但是会发生参数扩展和命令替换。&lt;/p>
&lt;pre>&lt;code>②支持字符串的模式匹配，使用=~操作符时甚至支持shell的正则表达式。字符串比较时可以把右边的作为一个模式，而不仅仅是一个字符串，比如[[ hello == hell? ]]，结果为真。[[ ]] 中匹配字符串或通配符，不需要引号。
③使用[[ ... ]]条件判断结构，而不是[ ... ]，能够防止脚本中的许多逻辑错误。比如，&amp;amp;&amp;amp;、||、&amp;lt;和&amp;gt; 操作符能够正常存在于[[ ]]条件判断结构中，但是如果出现在[ ]结构中的话，会报错。比如可以直接使用if [[ $a != 1 &amp;amp;&amp;amp; $a != 2 ]], 如果不适用双括号, 则为if [ $a -ne 1] &amp;amp;&amp;amp; [ $a != 2 ]或者if [ $a -ne 1 -a $a != 2 ]。
④bash把双中括号中的表达式看作一个单独的元素，并返回一个退出状态码。
&lt;/code>&lt;/pre>
&lt;h1 id="脚本执行规则">脚本执行规则：&lt;/h1>
&lt;ol>
&lt;li>顺序执行：默认原则，逐一执行写的每条语句&lt;/li>
&lt;li>选择执行：条件判断，符合条件的进行执行&lt;/li>
&lt;li>循环执行：将同一段代码反复执行，必须有结束条件，否则循环无法结束。&lt;/li>
&lt;/ol></description></item><item><title>Docs: Shell 命令行参数处理</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/4.terminal-%E4%B8%8E-shell/shell-%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/shell-%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%8F%82%E6%95%B0%E5%A4%84%E7%90%86/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/4.terminal-%E4%B8%8E-shell/shell-%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/shell-%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%8F%82%E6%95%B0%E5%A4%84%E7%90%86/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://www.cnblogs.com/klb561/p/9211222.html">https://www.cnblogs.com/klb561/p/9211222.html&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://blog.csdn.net/qq_22203741/article/details/77671379">https://blog.csdn.net/qq_22203741/article/details/77671379&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;h1 id="shell-代码命令行选项与修传入参数处理">shell 代码命令行选项与修传入参数处理&lt;/h1>
&lt;p>在编写 shell 程序时经常需要处理命令行参数，本文描述在 bash 下的命令行处理方式。&lt;/p>
&lt;p>选项与参数：&lt;/p>
&lt;p>如下命令行：&lt;/p>
&lt;p>./test.sh -f config.conf -v &amp;ndash;prefix=/home&lt;/p>
&lt;ol>
&lt;li>-f 为选项，它需要一个参数，即 config.conf&lt;/li>
&lt;li>-v 也是一个选项，但它不需要参数。&lt;/li>
&lt;li>--prefix 我们称之为一个长选项，即选项本身多于一个字符，它也需要一个参数，用等号连接，当然等号不是必须的，/home 可以直接写在&amp;ndash;prefix 后面，即&amp;ndash;prefix/home,更多的限制后面具体会讲到。&lt;/li>
&lt;/ol>
&lt;p>在 bash 中，可以用以下三种方式来处理命令行参数，每种方式都有自己的应用场景。&lt;/p>
&lt;ol>
&lt;li>通过位置变量手工处理参数 # 参考变量与环境变量 文章中的位置变量&lt;/li>
&lt;li>getopts # 简单工具&lt;/li>
&lt;li>getopt # 复杂工具&lt;/li>
&lt;/ol>
&lt;p>依次讨论这三种处理方式。&lt;/p>
&lt;h1 id="通过位置变量手工处理参数">通过位置变量手工处理参数&lt;/h1>
&lt;p>在手工处理方式中，首先要知道几个变量，还是以上面的命令行为例：&lt;/p>
&lt;p>代码如下:&lt;/p>
&lt;ul>
&lt;li>
&lt;p>$0 ： ./test.sh,即命令本身，相当于 c/c++中的 argv[0]&lt;/p>
&lt;/li>
&lt;li>
&lt;p>$1 ： -f,第一个参数.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>$2 ： config.conf&lt;/p>
&lt;/li>
&lt;li>
&lt;p>$3, $4 &amp;hellip; ：类推。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>$# 参数的个数，不包括命令本身，上例中$#为 4.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>$@ ：参数本身的列表，也不包括命令本身，如上例为 -f config.conf -v &amp;ndash;prefix=/home&lt;/p>
&lt;/li>
&lt;li>
&lt;p>$* ：和$@相同，但&amp;quot;$&lt;em>&amp;quot; 和 &amp;ldquo;$@&amp;quot;(加引号)并不同，&amp;quot;$&lt;/em>&amp;ldquo;将所有的参数解释成一个字符串，而&amp;rdquo;$@&amp;ldquo;是一个参数数组。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>例子：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#!/bin/bash
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">for&lt;/span> arg in &lt;span style="color:#e6db74">&amp;#34;&lt;/span>$*&lt;span style="color:#e6db74">&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">do&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> echo $arg
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">done&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">for&lt;/span> arg in &lt;span style="color:#e6db74">&amp;#34;&lt;/span>$@&lt;span style="color:#e6db74">&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">do&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> echo $arg
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">done&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>执行./test.sh -f config.conf -n 10 会打印：&lt;/p>
&lt;pre>&lt;code>-f config.conf -n 10 #这是&amp;quot;$*&amp;quot;的输出
-f #以下为$@的输出
config.conf
-n
10
&lt;/code>&lt;/pre>
&lt;p>所以，手工处理的方式即对这些变量的处理。因为手工处理高度依赖于你在命令行上所传参数的位置，所以一般都只用来处理较简单的参数。&lt;/p>
&lt;p>例如：&lt;/p>
&lt;p>./test.sh 10&lt;/p>
&lt;p>而很少使用./test -n 10 这种带选项的方式。 典型用法为：&lt;/p>
&lt;pre>&lt;code>#!/bin/bash
if [ x$1 != x ]
then
#...有参数
else
then
#...没有参数
fi
&lt;/code>&lt;/pre>
&lt;p>为什么要使用 x$1 != x 这种方式来比较呢？想像一下这种方式比较：&lt;/p>
&lt;p>if [ -n $1 ] #$1 不为空&lt;/p>
&lt;p>但如果用户不传参数的时候，$1 为空，这时 就会变成 [ -n ] ,所以需要加一个辅助字符串来进行比较。&lt;/p>
&lt;p>手工处理方式能满足大多数的简单需求，配合 shift 使用也能构造出强大的功能，但在要处理复杂选项的时候建议用下面的两种方法。&lt;/p>
&lt;h1 id="getoptsgetopt-工具">getopts/getopt 工具&lt;/h1>
&lt;p>处理命令行参数是一个相似而又复杂的事情，为此 go 语言提供 cobra 库来实现，c++ 的 boost 提供了 options 库。&lt;/p>
&lt;p>在 shell 中，处理此事的是 getopts 和 getopt 工具。&lt;/p>
&lt;p>getopts 和 getopt 功能相似但又不完全相同，其中 getopt 是独立的可执行文件，而 getopts 是由 bash 内置的。&lt;/p>
&lt;p>先来看看参数传递的典型用法:&lt;/p>
&lt;pre>&lt;code>* ./test.sh -a -b -c ： 短选项，各选项不需参数
* ./test.sh -abc ： 短选项，和上一种方法的效果一样，只是将所有的选项写在一起。
* ./test.sh -a args -b -c ：短选项，其中-a需要参数，而-b -c不需参数。
* ./test.sh --a-long=args --b-long ：长选项
&lt;/code>&lt;/pre>
&lt;p>先来看 getopts,它不支持长选项。&lt;/p>
&lt;p>使用 getopts 非常简单，代码如下:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#test.sh&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#!/bin/bash&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">while&lt;/span> getopts &lt;span style="color:#e6db74">&amp;#34;a:bc&amp;#34;&lt;/span> arg; &lt;span style="color:#66d9ef">do&lt;/span> &lt;span style="color:#75715e">#选项后面的冒号表示该选项需要参数&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">case&lt;/span> $arg in
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> a&lt;span style="color:#f92672">)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> echo &lt;span style="color:#e6db74">&amp;#34;a&amp;#39;s arg:&lt;/span>$optarg&lt;span style="color:#e6db74">&amp;#34;&lt;/span> &lt;span style="color:#75715e">#参数存在$optarg中&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> b&lt;span style="color:#f92672">)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> echo &lt;span style="color:#e6db74">&amp;#34;b&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> c&lt;span style="color:#f92672">)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> echo &lt;span style="color:#e6db74">&amp;#34;c&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ?&lt;span style="color:#f92672">)&lt;/span> &lt;span style="color:#75715e">#当有不认识的选项的时候arg为?&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> echo &lt;span style="color:#e6db74">&amp;#34;unkonw argument&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>exit &lt;span style="color:#ae81ff">1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">esac&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">done&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>现在就可以使用：
./test.sh -a arg -b -c
或
./test.sh -a arg -bc
来加载了。&lt;/p>
&lt;p>应该说绝大多数脚本使用该函数就可以了，如果需要支持长选项以及可选参数，那么就需要使用 getopt.&lt;/p>
&lt;h1 id="getopt">getopt&lt;/h1>
&lt;h2 id="syntax语法">Syntax(语法)&lt;/h2>
&lt;p>** getopt optstring parameters**
** getopt [OPTIONS] [&amp;ndash;] optstring parameters**
** getopt [OPTIONS] -o|&amp;ndash;options optstring [options] [&amp;ndash;] parameters**&lt;/p>
&lt;p>OPTIONS&lt;/p>
&lt;ul>
&lt;li>-a, &amp;ndash;alternative Allow long options starting with single -&lt;/li>
&lt;li>-h, &amp;ndash;help This small usage guide&lt;/li>
&lt;li>-l, &amp;ndash;longoptions &lt;!-- raw HTML omitted --> # 要被识别的长选项&lt;/li>
&lt;li>-n, &amp;ndash;name &lt;!-- raw HTML omitted --> The name under which errors are reported&lt;/li>
&lt;li>-o, &amp;ndash;options &lt;!-- raw HTML omitted --> # 要被识别的短选项&lt;/li>
&lt;li>-q, &amp;ndash;quiet Disable error reporting by getopt(3)&lt;/li>
&lt;li>-Q, &amp;ndash;quiet-output No normal output&lt;/li>
&lt;li>-s, &amp;ndash;shell &lt;!-- raw HTML omitted --> Set shell quoting conventions&lt;/li>
&lt;li>-T, &amp;ndash;test Test for getopt(1) version&lt;/li>
&lt;li>-u, &amp;ndash;unquoted Do not quote the output&lt;/li>
&lt;li>-V, &amp;ndash;version Output version information&lt;/li>
&lt;/ul>
&lt;p>getopt 工具基本使用示例&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#!/bin/bash
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#75715e"># 请注意，我们使用 &amp;#34;$@&amp;#34; 来使每个命令行参数扩展为一个单独的单词。 $@ 周围的引号是必不可少的！&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># -o表示短选项，两个冒号表示该选项有一个可选参数，可选参数必须紧贴选项&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># 如-carg 而不能是-c arg&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># -l或--long选项后面接可接受的长选项，每个选项用逗号分开，冒号的意义同短选项。&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># -n:出错时的信息&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># -- ：举一个例子比较好理解：&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#我们要创建一个名字为 &amp;#34;-f&amp;#34;的目录你会怎么办？&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># mkdir -f #不成功，因为-f会被mkdir当作选项来解析，这时就可以使用&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># mkdir -- -f 这样-f就不会被作为选项。&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># 我们需要使用 temp 作为`eval set-`来抵消getopt的返回值。&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>temp&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">`&lt;/span>getopt -o ab:c:: --long a-long,b-long:,c-long:: &lt;span style="color:#ae81ff">\
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">&lt;/span> -n &lt;span style="color:#e6db74">&amp;#39;example.bash&amp;#39;&lt;/span> -- &lt;span style="color:#e6db74">&amp;#34;&lt;/span>$@&lt;span style="color:#e6db74">&amp;#34;&lt;/span>&lt;span style="color:#e6db74">`&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">if&lt;/span> &lt;span style="color:#f92672">[&lt;/span> $? !&lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span> &lt;span style="color:#f92672">]&lt;/span> ; &lt;span style="color:#66d9ef">then&lt;/span> echo &lt;span style="color:#e6db74">&amp;#34;terminating...&amp;#34;&lt;/span> &amp;gt;&amp;amp;&lt;span style="color:#ae81ff">2&lt;/span> ; exit &lt;span style="color:#ae81ff">1&lt;/span> ; &lt;span style="color:#66d9ef">fi&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># 注意 $temp 周围的引号：它们是必不可少的！&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># set 会重新排列参数的顺序，也就是改变$1,$2...$n的值，这些值在getopt中重新排列过了&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>eval set -- &lt;span style="color:#e6db74">&amp;#34;&lt;/span>$temp&lt;span style="color:#e6db74">&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># 经过getopt的处理，下面处理具体选项。&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">while&lt;/span> true ; &lt;span style="color:#66d9ef">do&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">case&lt;/span> &lt;span style="color:#e6db74">&amp;#34;&lt;/span>$1&lt;span style="color:#e6db74">&amp;#34;&lt;/span> in
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> -a|--a-long&lt;span style="color:#f92672">)&lt;/span> echo &lt;span style="color:#e6db74">&amp;#34;option a&amp;#34;&lt;/span> ; shift ;;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> -b|--b-long&lt;span style="color:#f92672">)&lt;/span> echo &lt;span style="color:#e6db74">&amp;#34;option b, argument \`&lt;/span>$2&lt;span style="color:#e6db74">&amp;#39;&amp;#34;&lt;/span> ; shift &lt;span style="color:#ae81ff">2&lt;/span> ;;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> -c|--c-long&lt;span style="color:#f92672">)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e"># c 有一个可选参数。 由于我们处于引用模式，如果找不到可选参数，则会生成一个空参数。&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">case&lt;/span> &lt;span style="color:#e6db74">&amp;#34;&lt;/span>$2&lt;span style="color:#e6db74">&amp;#34;&lt;/span> in
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#34;&amp;#34;&lt;/span>&lt;span style="color:#f92672">)&lt;/span> echo &lt;span style="color:#e6db74">&amp;#34;option c, no argument&amp;#34;&lt;/span>; shift &lt;span style="color:#ae81ff">2&lt;/span> ;;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> *&lt;span style="color:#f92672">)&lt;/span> echo &lt;span style="color:#e6db74">&amp;#34;option c, argument \`&lt;/span>$2&lt;span style="color:#e6db74">&amp;#39;&amp;#34;&lt;/span> ; shift &lt;span style="color:#ae81ff">2&lt;/span> ;;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">esac&lt;/span> ;;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> --&lt;span style="color:#f92672">)&lt;/span> shift ; break ;;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> *&lt;span style="color:#f92672">)&lt;/span> echo &lt;span style="color:#e6db74">&amp;#34;internal error!&amp;#34;&lt;/span> ; exit &lt;span style="color:#ae81ff">1&lt;/span> ;;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">esac&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">done&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>echo &lt;span style="color:#e6db74">&amp;#34;remaining arguments:&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">for&lt;/span> arg &lt;span style="color:#66d9ef">do&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> echo &lt;span style="color:#e6db74">&amp;#39;--&amp;gt; &amp;#39;&lt;/span>&lt;span style="color:#e6db74">&amp;#34;\`&lt;/span>$arg&lt;span style="color:#e6db74">&amp;#39;&amp;#34;&lt;/span> ;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">done&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>上述代码会循环处理参数，每处理一个参数，就用 shift 命令剔除，直到所有参数全部处理完，则跳出循环&lt;/p>
&lt;p>执行效果如下：&lt;/p>
&lt;pre>&lt;code>./parse.bash -a par1 'another arg' --c-long 'wow!*\?' -cmore -b &amp;quot; very long &amp;quot;
option a
option c, no argument
option c, argument `more'
option b, argument ` very long '
remaining arguments:
--&amp;gt; `par1'
--&amp;gt; `another arg'
--&amp;gt; `wow!*\?'
&lt;/code>&lt;/pre>
&lt;p>比如使用&lt;/p>
&lt;p>./test -a -b arg arg1 -c&lt;/p>
&lt;p>你可以看到,命令行中多了个 arg1 参数，在经过 getopt 和 set 之后，命令行会变为：&lt;/p>
&lt;p>-a -b arg -c &amp;ndash; arg1&lt;/p>
&lt;p>$1 指向 -a,$2 指向 -b,$3 指向 arg,$4 指向 -c,$5 指向 &amp;ndash;,而多出的 arg1 则被放到了最后。&lt;/p>
&lt;p>3，总结&lt;/p>
&lt;p>一般小脚本手工处理也就够了，getopts 能处理绝大多数的情况，getopt 较复杂，功能也更强大!/bin/bash&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">function&lt;/span> Help&lt;span style="color:#f92672">(){&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> echo &lt;span style="color:#e6db74">&amp;#39; ================================================================ &amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> echo &lt;span style="color:#e6db74">&amp;#39; 请使用下列 flags 来运行脚本，若无需改变默认值，使用 ./test.sh -- 即可；&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> echo &lt;span style="color:#e6db74">&amp;#39; 如果环境无互联网，则安装的docker版本根据离线包的版本决定，dockerversion参数无用；&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> echo &lt;span style="color:#e6db74">&amp;#39; --cgroupdriver: 指定 cgroupdrive 的类型，默认为 systemd；&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> echo &lt;span style="color:#e6db74">&amp;#39; --dockerversion: 指定要安装的 docer-ce 版本，默认为 19.03.11；&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> echo &lt;span style="color:#e6db74">&amp;#39; 使用示例:&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> echo &lt;span style="color:#e6db74">&amp;#39; ./test.sh --cgroupdriver=systemd --dockerversion=19.03.11&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> echo &lt;span style="color:#e6db74">&amp;#39; ================================================================&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">case&lt;/span> &lt;span style="color:#e6db74">&amp;#34;&lt;/span>$1&lt;span style="color:#e6db74">&amp;#34;&lt;/span> in
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> -h|--help&lt;span style="color:#f92672">)&lt;/span> Help; exit;;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">esac&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">if&lt;/span> &lt;span style="color:#f92672">[[&lt;/span> $1 &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#e6db74">&amp;#39;&amp;#39;&lt;/span> &lt;span style="color:#f92672">||&lt;/span> ! $1 &lt;span style="color:#f92672">=&lt;/span>~ &lt;span style="color:#e6db74">&amp;#39;--&amp;#39;&lt;/span> &lt;span style="color:#f92672">]]&lt;/span>;&lt;span style="color:#66d9ef">then&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Help;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> exit;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">fi&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>CMDFLAGS&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>$*&lt;span style="color:#e6db74">&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">for&lt;/span> FLAGS in $CMDFLAGS;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">do&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> key&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#66d9ef">$(&lt;/span>echo &lt;span style="color:#e6db74">${&lt;/span>FLAGS&lt;span style="color:#e6db74">}&lt;/span> | awk -F&lt;span style="color:#e6db74">&amp;#34;=&amp;#34;&lt;/span> &lt;span style="color:#e6db74">&amp;#39;{print $1}&amp;#39;&lt;/span> &lt;span style="color:#66d9ef">)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> value&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#66d9ef">$(&lt;/span>echo &lt;span style="color:#e6db74">${&lt;/span>FLAGS&lt;span style="color:#e6db74">}&lt;/span> | awk -F&lt;span style="color:#e6db74">&amp;#34;=&amp;#34;&lt;/span> &lt;span style="color:#e6db74">&amp;#39;{print $2}&amp;#39;&lt;/span> &lt;span style="color:#66d9ef">)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">case&lt;/span> &lt;span style="color:#e6db74">&amp;#34;&lt;/span>$key&lt;span style="color:#e6db74">&amp;#34;&lt;/span> in
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> --cgroupdriver&lt;span style="color:#f92672">)&lt;/span> CgroupDriver&lt;span style="color:#f92672">=&lt;/span>$value ;;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> --dockerversion&lt;span style="color:#f92672">)&lt;/span> DockerVersion&lt;span style="color:#f92672">=&lt;/span>$value ;;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">esac&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">done&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># Docker 配置&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>CgroupDriver&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">${&lt;/span>CgroupDriver&lt;span style="color:#66d9ef">:-&lt;/span>systemd&lt;span style="color:#e6db74">}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>DockerVersion&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">${&lt;/span>DockerVersion&lt;span style="color:#66d9ef">:-&lt;/span>19.03.11&lt;span style="color:#e6db74">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div></description></item><item><title>Docs: source，sh，bash 等执行命令的工具</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/4.terminal-%E4%B8%8E-shell/sourceshbash-%E7%AD%89%E6%89%A7%E8%A1%8C%E5%91%BD%E4%BB%A4%E7%9A%84%E5%B7%A5%E5%85%B7/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/4.terminal-%E4%B8%8E-shell/sourceshbash-%E7%AD%89%E6%89%A7%E8%A1%8C%E5%91%BD%E4%BB%A4%E7%9A%84%E5%B7%A5%E5%85%B7/</guid><description>
&lt;h1 id="source-程序在当前-shell-环境中从指定文件中读取并执行命令">source 程序：在当前 shell 环境中从指定文件中读取并执行命令&lt;/h1>
&lt;p>注意：该命令可以使当前环境的配置文件在此环境中立刻生效而不用重启机器&lt;/p>
&lt;p>作用：&lt;/p>
&lt;ol>
&lt;li>
&lt;p>这个命令其实只是简单地读取脚本里面的语句依次在当前 shell 里面执行，没有建立新的子 shell。那么脚本里面所有新建、改变变量的语句都会保存在当前 shell 里面&lt;/p>
&lt;/li>
&lt;li>
&lt;p>source 命令(从 C Shell 而来)是 bash shell 的内置命令。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>source(或点)命令通常用于重新执行刚修改的初始化文档。&lt;/p>
&lt;/li>
&lt;/ol>
&lt;p>应用实例：一般用于写在 shell 脚本中，通过 source 执行外部文件中是变量赋值，这样不建立子 shell 的话，外部文件中的变量就可以在该脚本启动的 shell 中引用&lt;/p>
&lt;p>source [选项] FILENAME # 使环境变量立刻生效&lt;/p>
&lt;p>在当前 bash 环境下读取并执行 FileName 中的命令。该 filename 文件可以“无执行权限”&lt;/p>
&lt;ol>
&lt;li>
&lt;p>EXAMPLE：&lt;/p>
&lt;ol>
&lt;li>
&lt;p>source openrc admin admin #运行 openrc 这个配置文件，把第一个参数 admin 和第二个参数 admin 送给 openrc 文件中的$1 和$2&lt;/p>
&lt;/li>
&lt;li>
&lt;p>source .bash_profile #&lt;/p>
&lt;/li>
&lt;/ol>
&lt;/li>
&lt;/ol>
&lt;p>sh 和 bash 程序：&lt;/p>
&lt;p>实际上，执行 sh 或者 bash 就是相当于打开新的子 shell，并在新的 shell 中执行后续的命令。只不过 bash 与 sh 是不同的 shell，内置的功能有一些细微的区别。&lt;/p>
&lt;p>作用:&lt;/p>
&lt;ol>
&lt;li>
&lt;p>开启一个新的 shell，读取并执行 File 中的命令。该 file 可以“无执行权限”&lt;/p>
&lt;/li>
&lt;li>
&lt;p>注：两者在执行文件时的不同，是分别用自己的 shell 来跑文件。&lt;/p>
&lt;ol>
&lt;li>
&lt;p>sh 使用“-n”选项进行 shell 脚本的语法检查，使用“-x”选项实现 shell 脚本逐条语句的跟踪&lt;/p>
&lt;/li>
&lt;li>
&lt;p>可以巧妙地利用 shell 的内置变量增强“-x”选项的输出信息等。&lt;/p>
&lt;/li>
&lt;/ol>
&lt;/li>
&lt;/ol>
&lt;p>&lt;strong>bash [OPTIONS] [File]&lt;/strong> #&lt;/p>
&lt;p>OPTIONS&lt;/p>
&lt;ol>
&lt;li>
&lt;p>-n #对指定文件进行语法检查&lt;/p>
&lt;/li>
&lt;li>
&lt;p>-x #打印出执行脚本的过程&lt;/p>
&lt;/li>
&lt;/ol>
&lt;h1 id="-的命令用法">./ 的命令用法：&lt;/h1>
&lt;p>作用:&lt;/p>
&lt;ol>
&lt;li>
&lt;p>打开一个子 shell 来读取并执行 FileName 中命令。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>注：运行一个 shell 脚本时会启动另一个命令解释器.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>每个 shell 脚本有效地运行在父 shell(parent shell)的一个子进程里. 这个父 shell 是指在一个控制终端或在一个 xterm 窗口中给你命令指示符的进程.shell 脚本也可以启动他自已的子进程. 这些子 shell(即子进程)使脚本并行地，有效率地地同时运行脚本内的多个子任务.&lt;/p>
&lt;/li>
&lt;/ol>
&lt;p>语法格式：./FileName&lt;/p></description></item><item><title>Docs: 变量</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/4.terminal-%E4%B8%8E-shell/shell-%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/%E5%8F%98%E9%87%8F/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/4.terminal-%E4%B8%8E-shell/shell-%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/%E5%8F%98%E9%87%8F/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;p>&lt;strong>Variable(变量，简称 var)&lt;/strong> 是一个可以改变内容的固定规定，比如我定义“这台电脑的名字”叫“XXX”，“这台电脑的名字”就是不变的内容，“XXX”就是可以改变的内容，给不变的内容定义不同的内容&lt;/p>
&lt;ol>
&lt;li>比如 X=1，X=2，X=3 等等，X 就是不变的，1，2，3 等等都是可变的，X 就是一个变量，可以被赋予某些内容&lt;/li>
&lt;li>环境变量就是在当前环境下所定义的内容，比如 linux 启动了一个 shell，在 shell 这个环境下，有一些规定被定义了，这些规定就是环境变量；不在这个 shell 下变量就不生效&lt;/li>
&lt;li>比如：LANG 是一个语言的规定，你赋予他一个内容，就相当于定义了这个 shell 环境下所显示的语言，比如 LANG=US，LANG=CN 等等。LANG 这叫定义语言，这是不变的，可变的是后面的自定义内容，语言(不变)=英语、汉语、日语(可变)。&lt;/li>
&lt;li>再比如我执行一条命令，linux 执行的命令，就是运行某个定义好的相对应的该命令的文件（注意：linux 中一切皆文件）&lt;/li>
&lt;/ol>
&lt;p>实际例子：当我输入 ls -al /etc 这个命令的时候有以下几步&lt;/p>
&lt;ol>
&lt;li>需要定义我输入的内容是什么样的结构，以空格分隔的字段，每一段都进行什么操作
&lt;ol>
&lt;li>第一段为命令段 ls，需要有一个环境变量定义去哪里执行这条命令对应的文件(一个命令是通过一个文件中写的各种代码来实现的)，这个环境变量就是 PATH，PATH 可以寻找该命令文件的目录，让 shell 去这些目录中找 ls 文件，然后执行。&lt;/li>
&lt;li>第二段是 -al，是 ls 命令的第一个参数，具体实行方法需要参考 ls 命令的说明文档&lt;/li>
&lt;li>第三段 /etc，是 ls 命令的第二个参数，具体实行方法需要参考 ls 命令的说明文档&lt;/li>
&lt;/ol>
&lt;/li>
&lt;li>根据整体变量，ls 的变量等输出最终结果&lt;/li>
&lt;/ol>
&lt;h2 id="变量的生效范围类型">变量的生效范围类型&lt;/h2>
&lt;p>重要用途，改变一处，多出用到该变量的地方都可以跟随变化。尤其是在一个脚本中，定义变量尤其重要&lt;/p>
&lt;ul>
&lt;li>本地变量：只对当前 shell 进程有效，对其子 shell 以及其它 shell 都无效（VarName 为自己定义的变量名，Value 为给变量定义的内容）&lt;/li>
&lt;li>局部变量：仅对局部代码生效，比如在函数体内定义的变量，该变量只在该函数内生效，该变量不对整个脚本生效，使用 local VAR 来定义局部函数&lt;/li>
&lt;li>环境变量：对当前环境起作用的变量，使用 export VarName=&amp;ldquo;Value&amp;rdquo; 命令让变量对当前 shell 及其子 shell 有效
&lt;ul>
&lt;li>注意：如果想让环境变量永久生效,则需要在当前用户的目录下，找到该用户的环境配置文件，把 export VarName=&amp;ldquo;Value&amp;rdquo; 命令写到该用户下的配置文件中即可&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>位置变量：&lt;code>$0&lt;/code> 该脚本所在的绝对路径 &lt;code>$1&lt;/code> 脚本的第一个参数 &lt;code>$2&lt;/code>&amp;hellip;..等等
&lt;ul>
&lt;li>$数字 # 是位置参数的用法。如果运行脚本的时候带参数，那么可以在脚本里通过 $1 获取第一个参数，$2 获取第二个参数&amp;hellip;&amp;hellip;依此类推，一共可以直接获取 9 个参数（称为位置参数）。$0 用于获取脚本名称。相应地，如果 $+数字 用在函数里，那么表示获取函数的传入参数，$0 表示函数名。
&lt;ul>
&lt;li>&lt;code>$0&lt;/code> # 该脚本所在的绝对路径&lt;/li>
&lt;li>&lt;code>$1&lt;/code> # 脚本的第一个参数&lt;/li>
&lt;li>&lt;code>$2&lt;/code> # 脚本的第二个参数&lt;/li>
&lt;li>&amp;hellip;..等等&lt;/li>
&lt;li>比如：
&lt;ul>
&lt;li>./test.sh a b c # 运行该脚本时候，a 就是变量 $1(第一个参数)，b 就是变量 $2(第二个参数)，变量 $# 为 3,一共 3 个位置参数&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>其他位置参数：
&lt;ul>
&lt;li>&lt;code>$#&lt;/code> # 位置变量的个数&lt;/li>
&lt;li>&lt;code>$*&lt;/code> # 引用所有的位置参数，引用后就是显示或者执行引用的字符串&lt;/li>
&lt;li>&lt;code>$@&lt;/code> # 引用所有的位置参数，引用后就是显示或者执行引用的字符串&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>特殊变量:
&lt;ul>
&lt;li>$? # 上一条命令执行的结果的返回值，成功为 0，失败为不为 0&lt;/li>
&lt;li>$$ # 当前 shell 的 PID 号&lt;/li>
&lt;li>$! # Shell 最后运行的后台进程的 PID&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>给变量赋予默认值：&lt;/li>
&lt;li>VarName=${VarName:=VALUE} #如果 VarName 不空，则其值不变；否则，VarName 会使用 VALUE 作为其默认值&lt;/li>
&lt;/ul>
&lt;h2 id="变量的基本类型">变量的基本类型&lt;/h2>
&lt;ul>
&lt;li>Numbers(数字型)。格式化标识符&lt;code>%d&lt;/code>
&lt;ul>
&lt;li>Integers 整数型。简写为&lt;code>int&lt;/code>&lt;/li>
&lt;li>Floating Point Numbers 浮点数型&lt;/li>
&lt;li>complex 复数共两种复数，complex64 和 complex128，分别对应 float32 和 float64 两种浮点数精度。内置的 complex 函数用于构建复数，内建的 real 和 imag 函数分别返回复数的实部和虚部&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Strings(字符型)。格式化标识符&lt;code>%s&lt;/code>&lt;/li>
&lt;li>Booleans 布尔型
&lt;ul>
&lt;li>注意：很多时候，Booleans 类型的值可以用数字表示
&lt;ul>
&lt;li>1 表示 true(真)&lt;/li>
&lt;li>0 表示 false(假)&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>等等&lt;/li>
&lt;/ul>
&lt;h1 id="声明变量取消变量">声明变量，取消变量&lt;/h1>
&lt;p>&lt;strong>export [OPTIONS] [VarName[=VALUE] &amp;hellip;]&lt;/strong> # 设置或显示环境变量(export 的效力仅作用于该次登陆操作)。&lt;/p>
&lt;p>用户创建的变量仅可用于当前 Shell，子 Shell 默认读取不到父 Shell 定义的变量。为了把变量传递给子 Shell，需要使用 export 命令。这样输出的变量，对于子 Shell 来说就是环境变量。&lt;/p>
&lt;p>OPTIONS&lt;/p>
&lt;ul>
&lt;li>&lt;strong>-f&lt;/strong> # 代表[NAME]中为函数名称&lt;/li>
&lt;li>&lt;strong>-n&lt;/strong> # 删除指定的变量。变量实际上并未删除，只是不会输出到后续指令的执行环境中&lt;/li>
&lt;li>&lt;strong>-p&lt;/strong> # 列出所有的 shell 赋予程序的环境变量。&lt;/li>
&lt;/ul>
&lt;p>EXAMPLE&lt;/p>
&lt;ul>
&lt;li>export VarName=&amp;ldquo;Value&amp;rdquo; #&lt;/li>
&lt;li>VarName=&amp;ldquo;Value&amp;rdquo; #&lt;/li>
&lt;li>export VarName #&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>[set] VarName=&amp;ldquo;Value&amp;rdquo;&lt;/strong>
EXAMLE&lt;/p>
&lt;ul>
&lt;li>test=&amp;ldquo;test.test&amp;rdquo; #设定一个名为 test 的变量的值为 test.test&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>unset VarName&lt;/strong>
EXAMPLE&lt;/p>
&lt;ul>
&lt;li>unset test #取消名为 test 的变量的值&lt;/li>
&lt;/ul>
&lt;p>注意：如果想要给$PATH变量增加内容，则需要用命令PATH=$PATH:/NAME/NAME,如果前面不加$PATH,那么这个变量就等于被改写成/NAME/NAME，这点在修改变量时候尤为重要，必须要在定义PATH的引入本身已经定义好的$PATH&lt;/p>
&lt;p>&lt;strong>declare #声明 shell 变量&lt;/strong>&lt;/p>
&lt;p>declare 为 shell 命令，在第一种语法中可用来声明变量并设置变量的属性，在第二种语法中可用来显示 shell 函数。若不加上任何参数，则会显示全部的 shell 变量与函数(与执行 set 指令的效果相同)。&lt;/p>
&lt;p>语法格式：
declare [+/-][OPTIONS] VarName&lt;/p>
&lt;p>OPTIONS&lt;/p>
&lt;ul>
&lt;li>&lt;strong>-&lt;/strong> # 给变量添加类型属性&lt;/li>
&lt;li>&lt;strong>+&lt;/strong> # 取消变量的类型属性&lt;/li>
&lt;li>&lt;strong>-a&lt;/strong> # 将变量声明为数组型&lt;/li>
&lt;li>&lt;strong>-i&lt;/strong> # 将变量声明为整型&lt;/li>
&lt;li>&lt;strong>-x&lt;/strong> # 将变量声明为环境变量&lt;/li>
&lt;li>&lt;strong>-r&lt;/strong> # 将变量声明为只读变量&lt;/li>
&lt;li>&lt;strong>-p&lt;/strong> # 查看变量的被声明的类型&lt;/li>
&lt;li>&lt;strong>-f&lt;/strong> #&lt;/li>
&lt;/ul>
&lt;h2 id="引用变量">引用变量&lt;/h2>
&lt;p>定义变量。[set] name=&amp;ldquo;hello Desist Daydream&amp;rdquo;&lt;/p>
&lt;pre>&lt;code>[root@lichenhao ~]# name='hello Desist Daydream!'
&lt;/code>&lt;/pre>
&lt;p>引用变量有两种写法 &amp;ldquo;$变量名&amp;rdquo; 或者 ${变量名} ，推荐使用第二种方法，两种方法的差别如下&lt;/p>
&lt;pre>&lt;code>[root@lichenhao ~]# name='hello Desist Daydream!'; name=&amp;quot;$nameceshi&amp;quot;; echo $name
# 这里输出为空，不是手打的回车
[root@lichenhao ~]# name='hello Desist Daydream!'; name=&amp;quot;${name}ceshi&amp;quot;; echo $name
hello Desist Daydream!ceshi
&lt;/code>&lt;/pre>
&lt;p>我们还可以把命令的执行结果赋值给变量,使用$(命令)&lt;/p>
&lt;pre>&lt;code>[root@lichenhao ~]# time=$(date)
[root@lichenhao ~]# echo $time
2020年 08月 28日 星期五 12:44:46 CST
&lt;/code>&lt;/pre>
&lt;p>变量的拼接&lt;/p>
&lt;pre>&lt;code>[root@lichenhao ~]# name=&amp;quot;小明&amp;quot;
[root@lichenhao ~]# echo $name
小明
[root@lichenhao ~]# name=$name&amp;quot;和老王&amp;quot;
[root@lichenhao ~]# echo $name
小明和老王
[root@lichenhao ~]# name=&amp;quot;${name}在一起&amp;quot;
[root@lichenhao ~]# echo $name
小明和老王在一起
&lt;/code>&lt;/pre>
&lt;p>删除变量&lt;/p>
&lt;pre>&lt;code>[root@lichenhao ~]# name='hello Desist Daydream!'
[root@lichenhao ~]# echo ${name}
hello Desist Daydream!
[root@lichenhao ~]# unset name
[root@lichenhao ~]# echo ${name}
[root@lichenhao ~]#
&lt;/code>&lt;/pre>
&lt;h1 id="操作变量的高级技巧">操作变量的高级技巧&lt;/h1>
&lt;h2 id="使用-符号的功能来处理变量中的字符串">使用&lt;code>${ }&lt;/code>符号的功能来处理变量中的字符串&lt;/h2>
&lt;p>在日常使用变量中，经常会需要对变量中的值进行操作，比如删除、替换、截取等等。通过&lt;code>${ }&lt;/code>符号，就可以对指定变量中的值进行各种操作&lt;/p>
&lt;p>想要处理字符串，通常有如下几种方式：&lt;/p>
&lt;ol>
&lt;li>从指定位置截取字符串
&lt;ol>
&lt;li>${VARIABLE:START:LENGTH} # 从 VARIABLE 值的 左边 起第 START 个字符开始，向右截取 LENGTH 个字符&lt;/li>
&lt;li>${VARIABLE:0-START:LENGTH} # 从 VARIABLE 值的 右边 起第 START 个字符开始，向右截取 LENGTH 个字符&lt;/li>
&lt;li>Note：
&lt;ol>
&lt;li>:LENGTH 可省略。省略的话表示截取到变量值的末尾&lt;/li>
&lt;li>从左边开始计数时，起始数字是 0（这符合程序员思维）；从右边开始计数时，起始数字是 1（这符合常人思维）。计数方向不同，起始数字也不同。&lt;/li>
&lt;li>左数和右数的区别就是其实位置那个位置有没有 0- 这个标识符&lt;/li>
&lt;li>不管从哪边开始计数，截取方向都是从左到右。&lt;/li>
&lt;/ol>
&lt;/li>
&lt;/ol>
&lt;/li>
&lt;li>从指定字符串处截取字符串
&lt;ol>
&lt;li>${VARIABLE#*CHARS} # 从左边开始到第一个 CHARS 为止的字符全部忽略，只留下右边的所有字符&lt;/li>
&lt;li>${VARIABLE##*CHARS} # 从左边开始到最后一个 CHARS 为止的字符全部忽略，只留下右边的所有字符&lt;/li>
&lt;li>${VARIABLE%CHARS*} # 从右边开始到第一个 CHARS 为止的字符全部忽略，只留下左边的所有字符&lt;/li>
&lt;li>${VARIABLE%%CHARS*} # 从右边开始到最后一个 CHARS 为止的字符全部忽略，只留下左边的所有字符&lt;/li>
&lt;li>Note:
&lt;ol>
&lt;li>截取时，CHARS 不被包含在内。CHARS 可以是一个字符，也可以是一个字符串，当作一个整体看待，不要把 CHARS 拆开。当 CHARS 为字符时，则在计数开始时，表示从出现该字符串整体开始算。&lt;/li>
&lt;li>
&lt;ul>
&lt;li>符号只是一个通配符，可以省略。上面的语法中的 * 就是表示 CHARS 左侧或者右侧的所有字符&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>比如 ${VARIABLE%%CHARS*} 其实就是删掉从右数最后一个 CHARS 右侧的所有字符&lt;/li>
&lt;li>这种截取方式无法指定字符串长度。&lt;/li>
&lt;/ol>
&lt;/li>
&lt;/ol>
&lt;/li>
&lt;li>替换变量中匹配到的字符串
&lt;ol>
&lt;li>${VARIABLE/OldChars/NewChars} # 将 VARIABLE 值中匹配到第一个的 OldChars 替换为 NewChars&lt;/li>
&lt;li>${VARIABLE//OldChars/NewChars} # 将 VARIABLE 值中匹配到所有的 OldChars 替换为 NewChars&lt;/li>
&lt;/ol>
&lt;/li>
&lt;li>获取变量值的长度
&lt;ol>
&lt;li>${#VARIABLE} # 变量名前加 # 符号&lt;/li>
&lt;/ol>
&lt;/li>
&lt;/ol>
&lt;p>EXAMPLE：&lt;/p>
&lt;ol>
&lt;li>从指定位置截取字符串
&lt;ol>
&lt;li>split=&amp;lsquo;&lt;a href="https://www.desistdaydream.com">www.desistdaydream.com&lt;/a>&amp;rsquo; # 这个例子就是从第四位字符开始(包括第四位)，一共截取 14 个字符。由于第一个字符是 0 号位置，所以第四位字符，按照人类的理解应该是第五个字符。&lt;/li>
&lt;li>echo ${url:4:14}&lt;/li>
&lt;li>输出结果：desistdaydream&lt;/li>
&lt;li>split=&amp;lsquo;&lt;a href="https://www.desistdaydream.com">www.desistdaydream.com&lt;/a>&amp;rsquo; #省略 length，截取到字符串末尾&lt;/li>
&lt;li>echo ${url:4}&lt;/li>
&lt;li>输出结果：desistdaydream.com&lt;/li>
&lt;li>split=&amp;lsquo;&lt;a href="https://www.desistdaydream.com">www.desistdaydream.com&lt;/a>&amp;rsquo; #(从右边数，b 是第 13 个字符。)&lt;/li>
&lt;li>echo ${url: 0-18: 14}&lt;/li>
&lt;li>输出结果：desistdaydream&lt;/li>
&lt;li>split=&amp;ldquo;&lt;a href="https://www.desistdaydream.com">www.desistdaydream.com&lt;/a>&amp;rdquo;&lt;/li>
&lt;li>echo ${url: 0-18} #省略 length，直接截取到字符串末尾&lt;/li>
&lt;li>输出结果：desistdaydream.com&lt;/li>
&lt;/ol>
&lt;/li>
&lt;li>从指定字符串处截取字符串
&lt;ol>
&lt;li>split=&amp;ldquo;&lt;a href="http://www.desistdaydream.com/index.html%22">http://www.desistdaydream.com/index.html&amp;quot;&lt;/a>&lt;/li>
&lt;li>echo ${split#*/} #也可以写为 ${split#*p:/} 或 ${split#http:/}，效果相同。注意带 _ 和不带 _ 的区别。&lt;/li>
&lt;li>输出结果：/www.desistdaydream.com/index.html&lt;/li>
&lt;li>split=&amp;ldquo;&lt;a href="http://www.desistdaydream.com/index.html%22">http://www.desistdaydream.com/index.html&amp;quot;&lt;/a>&lt;/li>
&lt;li>echo ${split##*/}&lt;/li>
&lt;li>输出结果：index.html&lt;/li>
&lt;li>split=&amp;ldquo;&lt;a href="http://www.desistdaydream.com/index.html%22">http://www.desistdaydream.com/index.html&amp;quot;&lt;/a>&lt;/li>
&lt;li>echo ${split%/*}&lt;/li>
&lt;li>输出结果：&lt;a href="http://www.desistdaydream.com">http://www.desistdaydream.com&lt;/a>&lt;/li>
&lt;li>split=&amp;ldquo;&lt;a href="http://www.desistdaydream.com/index.html%22">http://www.desistdaydream.com/index.html&amp;quot;&lt;/a>&lt;/li>
&lt;li>echo ${split%%/*}&lt;/li>
&lt;li>输出结果：http:&lt;/li>
&lt;/ol>
&lt;/li>
&lt;/ol>
&lt;h2 id="使用-eval-命令让变量的值作为另一个变量的变量名">使用 eval 命令让变量的值作为另一个变量的变量名&lt;/h2>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>root@lichenhao:~# varname&lt;span style="color:#f92672">=&lt;/span>name
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>root@lichenhao:~# name&lt;span style="color:#f92672">=&lt;/span>lichenhao
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>root@lichenhao:~# echo $$varname
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>209409varname
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>root@lichenhao:~# echo &lt;span style="color:#e6db74">&amp;#39;$&amp;#39;&lt;/span>$varname
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>$name
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>root@lichenhao:~# eval echo &lt;span style="color:#e6db74">&amp;#39;$&amp;#39;&lt;/span>$varname
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>lichenhao
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div></description></item><item><title>Docs: 函数</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/4.terminal-%E4%B8%8E-shell/shell-%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/%E5%87%BD%E6%95%B0/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/4.terminal-%E4%B8%8E-shell/shell-%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/%E5%87%BD%E6%95%B0/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;p>&lt;strong>Function(函数)&lt;/strong> 就是代码块，函数中表示了一堆代码的集合，当调用函数的时候，则会执行函数中函数体内的命令&lt;/p>
&lt;p>语法格式：&lt;/p>
&lt;pre>&lt;code>function NAME(){
函数体
}
###或者
NAME() {
函数体
}
&lt;/code>&lt;/pre>
&lt;p>调用方式：在 shell 脚本中，函数并不会执行，只有在调用的时候，才会执行函数体中的命令&lt;/p>
&lt;ol>
&lt;li>直接使用函数名即可调用，函数名出现的地方，会被自动替换为函数体中的命令&lt;/li>
&lt;li>在调用函数时，传递参数给函数体，在函数名后面以空白分隔指定的参数列表即可。e.g.FunctionName ARG1 ARG2 &amp;hellip;ARGn
&lt;ol>
&lt;li>每个参数可以在函数体中使用位置参数进行引用，i.e.ARG1 在函数体中就是$1 的值，ARG2 在函数体中就是$2 的值，以此类推&lt;/li>
&lt;/ol>
&lt;/li>
&lt;/ol>
&lt;p>函数的生命周期：被调用时创建，返回时终止&lt;/p>
&lt;p>使用 return 命令返回自定义状态结果
0：成功
1-255：失败&lt;/p>
&lt;p>函数中的变量：在函数体内定义的变量只对该函数生效，当函数生命周期结束时，变量失效。&lt;/p>
&lt;p>注意：在函数体中，可以修改全局变量的值&lt;/p>
&lt;h1 id="函数的递归函数直接或间接调用自身">函数的递归：函数直接或间接调用自身&lt;/h1>
&lt;p>函数递归的应用实例：&lt;/p>
&lt;h2 id="阶乘nnn-1n-21">阶乘：N!=N(n-1)(n-2)&amp;hellip;1&lt;/h2>
&lt;pre>&lt;code> #/bin/bashfact() { if [ $1 -eq 0 -o $1 -eq 1 ]; then echo 1 else echo $[$1*$(fact $[$1-1])] fi}fact $1
&lt;/code>&lt;/pre>
&lt;p>步骤：比如给 fact 传递参数 5&lt;/p>
&lt;ol>
&lt;li>如果 5 大于 0 或者大于 1，那么使用 5*fact 函数，且再次调用函数时参数为 5-1&lt;/li>
&lt;li>再次调用函数的时候，不但有 4，还有函数，i.e.5&lt;em>4&lt;/em>fact 函数，直到函数的参数值为 1 或 0&lt;/li>
&lt;/ol>
&lt;h2 id="斐波那契数列1-1-2-3-5-8--每个数都是前两个数之和">斐波那契数列：1 1 2 3 5 8 &amp;hellip;.. #每个数都是前两个数之和&lt;/h2></description></item><item><title>Docs: 控制结构</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/4.terminal-%E4%B8%8E-shell/shell-%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/%E6%8E%A7%E5%88%B6%E7%BB%93%E6%9E%84/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/4.terminal-%E4%B8%8E-shell/shell-%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/%E6%8E%A7%E5%88%B6%E7%BB%93%E6%9E%84/</guid><description>
&lt;h1 id="控制结构-介绍">控制结构 介绍&lt;/h1>
&lt;p>每一个程序如何运行，其中的数据是如何进行传递的，是通过控制结构来实现的，程序的控制结构是指以某种顺序执行的一系列动作，用于解决某个问题。无论多么复杂的算法，均可通过顺序、选择、循环 3 中基本机构构造出来。每种结构仅有一个执行开始的入口以及执行结束的出口。由着 3 中基本机构组成的多层嵌套程序称为结构化程序&lt;/p>
&lt;p>控制结构中的“条件语句”详见 &lt;a href="https://www.yuque.com/go/doc/33222054">条件语句与运算&lt;/a>&lt;/p>
&lt;h1 id="一顺序结构">一：顺序结构&lt;/h1>
&lt;p>按照语句编写的顺序自上到下主句执行就是顺序结构&lt;/p>
&lt;h1 id="二选择结构">二：选择结构&lt;/h1>
&lt;h2 id="ifthenfi-选择结构">if&amp;hellip;;then&amp;hellip;;fi 选择结构&lt;/h2>
&lt;p>对某语句进行判断，判断完成后执行某动作。i.e.如果条件语句 1 为真,那么执行分支 1 语句,否则执行条件语句 2,如果条件语句 2 为真,那么执行分支 2 语句,否则执行条件语句 3,如果条件语句 3 为真,那么执行分支 3 语句,&amp;hellip;&amp;hellip;&amp;hellip;.(可无限循环),否则执行分支 n 语句&lt;/p>
&lt;p>语法结构：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">###单分支：如果“条件语句”为真，则执行“分支”&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">if&lt;/span> 条件语句;&lt;span style="color:#66d9ef">then&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> 分支
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">fi&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">###双分支：如果“条件语句”为真，则执行“分支1”，否则执行“分支2”&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">if&lt;/span> 条件语句; &lt;span style="color:#66d9ef">then&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> 分支1
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">else&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> 分支2
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">fi&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">###多分支：如果“条件语句”为真，则执行“分支1”，否则如果“条件语句2”为真，则执行“分支2”...以此类推&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">if&lt;/span> 条件语句1; &lt;span style="color:#66d9ef">then&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> 分支1
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">elif&lt;/span> 条件语句2; &lt;span style="color:#66d9ef">then&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> 分支2
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">elif&lt;/span> 条件语句3; &lt;span style="color:#66d9ef">then&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> 分支3
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>...
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">else&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> 分支n;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">fi&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="case-判断结构">case 判断结构&lt;/h2>
&lt;p>给定一个变量，当变量的值为某值时，执行某程序&lt;/p>
&lt;p>语法结构：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">case&lt;/span> $参数变量 in
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>“变量值1”） &lt;span style="color:#75715e"># 变量值用双引号括起来，关键字用小括号括起来&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> 程序段1 &lt;span style="color:#75715e"># 对应的逻辑&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>;; &lt;span style="color:#75715e"># 每个类别结尾使用两个连续的分号来处理&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>“变量值2”）
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> 程序段2
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>;;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>“变量值3”）
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> 程序段3
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>;;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>*&lt;span style="color:#f92672">)&lt;/span> &lt;span style="color:#75715e"># 最后一个位置参数值会用*来代替所有其他值&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> 程序段4
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>;;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">esac&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h1 id="三循环控制语句">三：循环控制语句&lt;/h1>
&lt;h2 id="for-循环结构">for 循环结构&lt;/h2>
&lt;p>持续对一个变量赋值之后并执行相关命令，直到变量使用完所有给定的值&lt;/p>
&lt;p>语法结构&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">for&lt;/span> VAR in VALs;&lt;span style="color:#66d9ef">do&lt;/span> &lt;span style="color:#75715e"># do表示循环开始，VALs的内容逐个赋值给VAR变量&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> 循环体 &lt;span style="color:#75715e"># 语句1，语句2。。。。等等，可以引用VAR变量&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">done&lt;/span> &lt;span style="color:#75715e"># done表示循环结束。&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>可以简写为：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">for&lt;/span> VAR in VALs; &lt;span style="color:#66d9ef">do&lt;/span> 循环体; &lt;span style="color:#66d9ef">done&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>VALs 是一个列表，默认以空格分割，每个 VAL 赋值给变量 VAR 一次，就执行一次循环体任务，直到列表中的值全部赋值完成，则结束循环。&lt;/p>
&lt;p>VALs 的取值方式：&lt;/p>
&lt;ul>
&lt;li>Val1 Val2&amp;hellip;..ValN #每个值中间以空格分割&lt;/li>
&lt;li>&lt;code>seq NUM1 NUM2&lt;/code> #使用 seq 命令打印出从 NUM1 到 NUM2 两个数之间的所有整数作为列表中的值，NUM 可以使用变量。如果运行脚本时候带参数了，则 NUM 变为参数的位置，引用第 NUM1 个位置到第 NUM2 个位置的参数
&lt;ul>
&lt;li>语法格式：&lt;code>seq [options] NUM1 增量 NUM2&lt;/code> # 用法见下面 shift 命令讲解&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>{NUM1..NUM2} #从 NUM1 到 NUM2 之间的所有整数作为值，NUM 不可以使用变量&lt;/li>
&lt;li>$*或$@ #通过位置变量来使用 VALs。列表中的内容可以在运行脚本的时候就给定，比如./XXX.sh 5 10 11，其中 5,10,11 就是脚本的参数然后通过位置变量在列表中引用&lt;/li>
&lt;li>/XX/YY/* #/XX/YY 目录下的所有文件&lt;/li>
&lt;/ul>
&lt;p>EXAMPLE:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">for&lt;/span> userName in lichenhao zhangna;&lt;span style="color:#66d9ef">do&lt;/span> &lt;span style="color:#75715e">#如果需要换行的语句写在一行上，中间需要加;分好&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> useradd -m $userName &lt;span style="color:#75715e">#给变量赋值lichenhao，然后执行useradd命令，再给变量赋值zhangna，然后执行useradd命令，列表内容全部赋值完成，结束循环。&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">done&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="while-循环结构">while 循环结构&lt;/h2>
&lt;p>条件语句为真(即 0)，则执行循环体，直到条件语句为假(即非 0)，则退出循环(注意:while 的循环体中最好加上一行代码，对条件语句中的变量赋值，以便每次执行循环之后，条件测试中的变量变成一个新值，否则极有可能陷入无限循环)循环体中可以使用 elif 进行多分支管理&lt;/p>
&lt;p>语法结构 1&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">while&lt;/span> 条件语句；do
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> 循环体
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">done&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>EXAMPLE&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">while&lt;/span> &lt;span style="color:#f92672">[&lt;/span> $i -le &lt;span style="color:#ae81ff">100&lt;/span> &lt;span style="color:#f92672">]&lt;/span>;&lt;span style="color:#66d9ef">do&lt;/span> &lt;span style="color:#75715e">#判断$i是否小于等于100,如果判断结果$?的值为0那么执行下面两行代码,否则执行done语句退出循环&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> let sum&lt;span style="color:#f92672">+=&lt;/span>$i &lt;span style="color:#75715e">#给sum变量赋值,值为$sum+$i&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> let i++ &lt;span style="color:#75715e">#i值+1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">done&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>echo $sum &lt;span style="color:#75715e">#输出1到100的和&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>语法结构 2 #read 通过输入重定向，把 FILE 文件内的的第一行所有的内容赋值给变量 VAR，循环体内的命令一般包含对变量 VAR 的处理；然后循环处理第二行、第三行。。。一直到最后一行。当 read 从文件 FILE 中读到内容时，退出状态为 0，循环继续执行,当 read 从文件中读完最后一行后，下次便没有内容可读了，此时 read 的退出状态为非 0，循环才会退出。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">while&lt;/span> read VAR; &lt;span style="color:#66d9ef">do&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> 循环体
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">done&lt;/span> &amp;lt; FILE
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>EXAMPLE #取出来 passwd 文件中的每一行，cut 出来每一行的第一个字段&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">while&lt;/span> read line; &lt;span style="color:#66d9ef">do&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> cut -d: -f1 $line
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">done&lt;/span> &amp;lt; /etc/passwd
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>语法结构 3 #COMMAND 命令的输出作为变量 VAR 的值，通过 read 循环的输入&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>COMMAND | &lt;span style="color:#66d9ef">while&lt;/span> read VAR; &lt;span style="color:#66d9ef">do&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> 循环体
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">done&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>EXAMPLE #取出来 passwd 文件中的每一行，cut 出来每一行的第一个字段&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>cat /etc/passwd | &lt;span style="color:#66d9ef">while&lt;/span> read line; &lt;span style="color:#66d9ef">do&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> cut -d: -f1 $line
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">done&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>for 和 while 的区别&lt;/p>
&lt;ul>
&lt;li>for：
&lt;ul>
&lt;li>列表中的数值赋值一次执行一次循环，直到列表全部赋值完毕&lt;/li>
&lt;li>循环体对以空格为分隔符的字符串进行操作&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>while：
&lt;ul>
&lt;li>条件语句判断一次，执行一次循环，直到条件判断为假&lt;/li>
&lt;li>循环体对每一行进行操作&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h2 id="select-循环结构">select 循环结构&lt;/h2>
&lt;p>select in 循环用来增强交互性，它可以显示出带编号的菜单，用户输入不同的编号就可以选择不同的菜单，并执行不同的功能。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">select&lt;/span> VAR in ValueList; &lt;span style="color:#66d9ef">do&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> 循环体
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">done&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>运行到 select 语句后，ValueList(值列表) 中的内容会以菜单的形式显示出来，用户输入菜单编号，就表示选中了某个值，这个值就会赋给变量 VAR，然后再执行循环体中的语句。&lt;/p>
&lt;p>每次循环时 select 都会要求用户输入菜单编号，并使用环境变量 ${PS3} 的值作为提示符，${PS3} 的默认值为#?，修改 PS3 的值就可以修改提示符。&lt;/p>
&lt;p>如果用户输入的菜单编号不在范围之内，或者输入一个空值（什么也不输入，直接回车），那么就会给 VAR 赋一个空值，并且重新显示一遍菜单。&lt;/p>
&lt;p>Note：select 是无限循环（死循环），输入空值，或者输入的值无效，都不会结束循环，只有遇到 break 语句，或者按下 Ctrl+D 组合键才能结束循环&lt;/p>
&lt;p>select in 通常和 case in 一起使用，在用户输入不同的编号时可以做出不同的反应。&lt;/p>
&lt;p>EXAMPLE&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#!/bin/bash
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>echo &lt;span style="color:#e6db74">&amp;#34;What is your favourite OS?&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">select&lt;/span> name in &lt;span style="color:#e6db74">&amp;#34;Linux&amp;#34;&lt;/span> &lt;span style="color:#e6db74">&amp;#34;Windows&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">do&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> echo $name
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">done&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>echo &lt;span style="color:#e6db74">&amp;#34;You have selected &lt;/span>$name&lt;span style="color:#e6db74">&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>运行效果：&lt;/p>
&lt;pre>&lt;code>[root@lichenhao ~]# bash select.sh
What is your favourite OS?
1) Linux
2) Windows
#? 1
Linux
#? ^d
You have selected Linux
&lt;/code>&lt;/pre>
&lt;p>#? 用来提示用户输入菜单编号；^D 表示按下 Ctrl+D 组合键，它的作用是结束 select in 循环。&lt;/p>
&lt;h2 id="until-循环结构可有可无">until 循环结构(可有可无)&lt;/h2>
&lt;p>条件测试为假，则执行循环体，与 while 循环相反，其余内容一样&lt;/p>
&lt;h1 id="四其余相关知识点">四、其余相关知识点&lt;/h1>
&lt;h2 id="shift位置参数轮替在运行脚本的时候输入-n-个参数每使用一次-shift-就舍弃掉一个位置参数参数就是-for-循环中列表的内容">shift：位置参数轮替，在运行脚本的时候输入 N 个参数，每使用一次 shift 就舍弃掉一个位置参数，参数就是 for 循环中列表的内容&lt;/h2>
&lt;p>例：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>./XXX.sh &lt;span style="color:#ae81ff">5&lt;/span> &lt;span style="color:#ae81ff">10&lt;/span> &lt;span style="color:#ae81ff">8&lt;/span> 4 &lt;span style="color:#75715e">#实现5+10+8+4求和&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#!/bin/bash&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>declare -i sum&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">0&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">for&lt;/span> i in &lt;span style="color:#e6db74">`&lt;/span>seq &lt;span style="color:#ae81ff">1&lt;/span> $#&lt;span style="color:#e6db74">`&lt;/span>;&lt;span style="color:#66d9ef">do&lt;/span> &lt;span style="color:#75715e">#列表中的内容是运行脚本的时候输入的参数的第1个数到第4个数，$#用于显示一共有几个参数&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> sum&lt;span style="color:#f92672">+=&lt;/span>$1 &lt;span style="color:#75715e">#$1引用5 10 8 4 中的第一个参数，计算sum=sum+运行脚本时候输入的第一个参数&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> shift &lt;span style="color:#75715e">#把第一个位置的参数踢掉，让第二位参数变成第一位&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">done&lt;/span> &lt;span style="color:#75715e">#执行完一次循环之后第一位置参数5被踢掉，10变成第一位参数，以此类推&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>echo $sum
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="exit-命令退出模式直接输入-exit-x表示该脚本直接结束返回执行状态代码-x">exit 命令退出模式：直接输入 exit X（表示该脚本直接结束，返回执行状态代码 X）&lt;/h2>
&lt;h2 id="read-命令">read 命令&lt;/h2>
&lt;p>该命令可以一次读取多个变量的值，变量和输入的值都需要使用空格隔开。在 read 命令后面，如果没有指定变量名，读取的数据将被自动赋值给特定的变量 REPLY&lt;/p>
&lt;p>**read [选项] VarName1 VarName2 **#从键盘读取变量的值，通常用在 shell 脚本中与用户进行交互的场合。
OPTIONS&lt;/p>
&lt;ol start="2">
&lt;li>-t：指定读取值时等待的时间（秒）&lt;/li>
&lt;li>-p：指定读取值时的提示符&lt;/li>
&lt;/ol>
&lt;p>EXAMPLE&lt;/p>
&lt;ol start="4">
&lt;li>read -p &amp;ldquo;输入一个数:&amp;rdquo; first last #输入完整个命令后，界面显示“输入一个数:”，然后可以自行输入信息，输入的第一个信息赋值给 first 变量，空格后的其余信息赋值给 last 变量。如图所示&lt;/li>
&lt;/ol>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/nruoca/1616166048474-f9d1744e-716b-4474-b848-4268d300493c.jpeg" alt="">&lt;/p></description></item><item><title>Docs: 数组</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/4.terminal-%E4%B8%8E-shell/shell-%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/%E6%95%B0%E7%BB%84/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/4.terminal-%E4%B8%8E-shell/shell-%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/%E6%95%B0%E7%BB%84/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;p>&lt;strong>Array(数组)&lt;/strong> 也是一种变量，数组中可以存放多个值，每个值都称为该数组的元素。Bash Shell 只支持一维数组（不支持多维数组），初始化时不需要定义数组大小（与 PHP 类似）。&lt;/p>
&lt;p>与大部分编程语言类似，数组元素的下标由 0 开始。&lt;/p>
&lt;p>Shell 数组用括号来表示，元素用&amp;quot;空格&amp;quot;符号分割开，&lt;/p>
&lt;p>定义数组的方式：&lt;code>ArrayName=(Value1 ... ValueN)&lt;/code>&lt;/p>
&lt;h2 id="数组的赋值">数组的赋值&lt;/h2>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#!/bin/bash
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>my_array&lt;span style="color:#f92672">=(&lt;/span>A B &lt;span style="color:#e6db74">&amp;#34;C&amp;#34;&lt;/span> D&lt;span style="color:#f92672">)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>我们也可以使用下标来定义数组:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>array_name&lt;span style="color:#f92672">[&lt;/span>0&lt;span style="color:#f92672">]=&lt;/span>value0
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>array_name&lt;span style="color:#f92672">[&lt;/span>1&lt;span style="color:#f92672">]=&lt;/span>value1
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>array_name&lt;span style="color:#f92672">[&lt;/span>2&lt;span style="color:#f92672">]=&lt;/span>value2
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="数组的引用">数组的引用&lt;/h2>
&lt;p>通过数组的下标来获取数组的值，数组中的第一位下标是 0，第二位下标是 2&amp;hellip;&amp;hellip;以此类推&lt;/p>
&lt;p>引用数组元素值的一般格式是：${array_name[index]} #index 是下标的数字&lt;/p>
&lt;p>实例&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#!/bin/bash
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>my_array&lt;span style="color:#f92672">=(&lt;/span>A B &lt;span style="color:#e6db74">&amp;#34;C&amp;#34;&lt;/span> D&lt;span style="color:#f92672">)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>echo &lt;span style="color:#e6db74">&amp;#34;第一个元素为: &lt;/span>&lt;span style="color:#e6db74">${&lt;/span>my_array[0]&lt;span style="color:#e6db74">}&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>echo &lt;span style="color:#e6db74">&amp;#34;第二个元素为: &lt;/span>&lt;span style="color:#e6db74">${&lt;/span>my_array[1]&lt;span style="color:#e6db74">}&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>echo &lt;span style="color:#e6db74">&amp;#34;第三个元素为: &lt;/span>&lt;span style="color:#e6db74">${&lt;/span>my_array[2]&lt;span style="color:#e6db74">}&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>echo &lt;span style="color:#e6db74">&amp;#34;第四个元素为: &lt;/span>&lt;span style="color:#e6db74">${&lt;/span>my_array[3]&lt;span style="color:#e6db74">}&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>执行脚本，输出结果如下所示：
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>$ chmod +x test.sh
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>$ ./test.sh
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>第一个元素为: A
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>第二个元素为: B
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>第三个元素为: C
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>第四个元素为: D
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="引用数组中指定的元素">引用数组中指定的元素&lt;/h3>
&lt;p>参考 变量与系统环境配置详解 中变量的高级技巧一节，可以通过 ${ } 来截取数组中的元素&lt;/p>
&lt;pre>&lt;code># 该示例通过 ${VARIABLE:START:LENGTH} 方式，将数组左边起第一个元素开始，向右截取到末尾的所有元素，并 echo 出来。
my_arrays=(a b c d)
echo ${my_arrays[@]:1}
b c d
&lt;/code>&lt;/pre>
&lt;h3 id="引用数组中的所有元素">引用数组中的所有元素&lt;/h3>
&lt;p>使用@ 或 * 可以获取数组中的所有元素，例如：&lt;/p>
&lt;pre>&lt;code>my_arrays=(A B C D)
echo &amp;quot;数组的元素为: ${my_arrays[*]}&amp;quot;
数组的元素为: A B C D
echo &amp;quot;数组的元素为: ${my_arrays[@]}&amp;quot;
数组的元素为: A B C D
&lt;/code>&lt;/pre>
&lt;p>Note：&lt;/p>
&lt;ol>
&lt;li>
&lt;ul>
&lt;li>#当变量加上 “” 会当成一串字符串处理.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>@ #变量加上 “” 依然当做数组处理.&lt;/li>
&lt;li>在没有加上 “” 的情况下 效果是等效的.&lt;/li>
&lt;/ol>
&lt;p>效果如下：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">[&lt;/span>root@centos-8-init scripts&lt;span style="color:#f92672">]&lt;/span>&lt;span style="color:#75715e"># cat array.sh&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#!/bin/bash&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>array&lt;span style="color:#f92672">=(&lt;/span>&lt;span style="color:#e6db74">&amp;#34;li chen hao&amp;#34;&lt;/span> &lt;span style="color:#e6db74">&amp;#34;zhang_na&amp;#34;&lt;/span>&lt;span style="color:#f92672">)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">for&lt;/span> i in &lt;span style="color:#e6db74">${&lt;/span>array[@]&lt;span style="color:#e6db74">}&lt;/span>; &lt;span style="color:#66d9ef">do&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>echo &lt;span style="color:#e6db74">&amp;#34;@符号无双引号:&amp;#34;&lt;/span>&lt;span style="color:#e6db74">${&lt;/span>i&lt;span style="color:#e6db74">}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">done&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>echo ------------
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">for&lt;/span> i in &lt;span style="color:#e6db74">&amp;#34;&lt;/span>&lt;span style="color:#e6db74">${&lt;/span>array[@]&lt;span style="color:#e6db74">}&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>; &lt;span style="color:#66d9ef">do&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>echo &lt;span style="color:#e6db74">&amp;#34;@符号有双引号:&amp;#34;&lt;/span>&lt;span style="color:#e6db74">${&lt;/span>i&lt;span style="color:#e6db74">}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">done&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>echo ------------
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">for&lt;/span> i in &lt;span style="color:#e6db74">${&lt;/span>array[*]&lt;span style="color:#e6db74">}&lt;/span>; &lt;span style="color:#66d9ef">do&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> echo &lt;span style="color:#e6db74">&amp;#34;*符号无双引号:&amp;#34;&lt;/span>&lt;span style="color:#e6db74">${&lt;/span>i&lt;span style="color:#e6db74">}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">done&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>echo ------------
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">for&lt;/span> i in &lt;span style="color:#e6db74">&amp;#34;&lt;/span>&lt;span style="color:#e6db74">${&lt;/span>array[*]&lt;span style="color:#e6db74">}&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>; &lt;span style="color:#66d9ef">do&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> echo &lt;span style="color:#e6db74">&amp;#34;*符号有双引号:&amp;#34;&lt;/span>&lt;span style="color:#e6db74">${&lt;/span>i&lt;span style="color:#e6db74">}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">done&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">[&lt;/span>root@centos-8-init scripts&lt;span style="color:#f92672">]&lt;/span>&lt;span style="color:#75715e"># bash array.sh&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>@符号无双引号:li
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>@符号无双引号:chen
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>@符号无双引号:hao
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>@符号无双引号:zhang_na
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>------------
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>@符号有双引号:li chen hao
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>@符号有双引号:zhang_na
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>------------
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>*符号无双引号:li
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>*符号无双引号:chen
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>*符号无双引号:hao
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>*符号无双引号:zhang_na
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>------------
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>*符号有双引号:li chen hao zhang_na
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="获取数组的长度">获取数组的长度&lt;/h2>
&lt;p>数组的长度分两种情况，一种是数组元素的个数，另一种事数组元素的所有索引号&lt;/p>
&lt;pre>&lt;code>my_arrays=(A B C D)
echo &amp;quot;数组元素个数为: ${#my_arrays[*]}&amp;quot;
数组元素个数为: 4
echo &amp;quot;数组元素个数为: ${#my_arrays[@]}&amp;quot;
数组元素个数为: 4
echo &amp;quot;数组元素的索引号为: ${!my_arrays[@]}&amp;quot;
数组元素的索引号为: 0 1 2 3
&lt;/code>&lt;/pre>
&lt;h2 id="向数组中添加元素">向数组中添加元素&lt;/h2>
&lt;pre>&lt;code># 在数组末尾添加元素
[root@lichenhao ~]# abc=(a b c)
[root@lichenhao ~]# echo ${abc[@]}
a b c
[root@lichenhao ~]# abc+=(d)
[root@lichenhao ~]# echo ${abc[@]}
a b c d
# 向指定 index 位置添加元素
[root@master ~]# arrays=(a b c d)
[root@master ~]# arrays[5]=f
[root@master ~]# echo ${arrays[@]}
a b c d f
[root@master ~]# echo ${!arrays[@]}
0 1 2 3 5
&lt;/code>&lt;/pre>
&lt;h2 id="删除数组中的元素">删除数组中的元素&lt;/h2>
&lt;pre>&lt;code>[root@master ~]# arrays=(a b c d)
[root@master ~]# echo $arrays
a b c d
[root@master ~]# unset arrays[2]
[root@master ~]# echo ${arrays[@]}
a b d
[root@master ~]# echo ${!arrays[@]}
0 1 3
[root@master ~]# arrays+=(c)
[root@master ~]# echo ${!arrays[@]}
0 1 3 4
[root@master ~]# echo ${arrays[@]}
a b d c
[root@master ~]# arrays[2]=c
[root@master ~]# echo ${arrays[@]}
&lt;/code>&lt;/pre>
&lt;p>Note:&lt;/p>
&lt;ol>
&lt;li>某个元素删除后，其余元素的 index 号不变&lt;/li>
&lt;li>如果对删除元素的数组添加新元素，则新元素的 index 号向后递增&lt;/li>
&lt;/ol>
&lt;h1 id="数组的应用实例">数组的应用实例&lt;/h1>
&lt;h2 id="对数组中的元素排序">对数组中的元素排序&lt;/h2>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># 原始数组：B=(20 9 01 5 11 4 6 14 12 14 0808)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>b&lt;span style="color:#f92672">=(&lt;/span>&lt;span style="color:#66d9ef">$(&lt;/span>printf &lt;span style="color:#e6db74">&amp;#39;%s\n&amp;#39;&lt;/span> &lt;span style="color:#e6db74">&amp;#34;&lt;/span>&lt;span style="color:#e6db74">${&lt;/span>B[@]&lt;span style="color:#e6db74">}&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>|sort -n&lt;span style="color:#66d9ef">)&lt;/span>&lt;span style="color:#f92672">)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># 排序后的数组：b=(01 4 5 6 9 11 12 14 14 20 0808)&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="数组的遍历在-for-循环中的应用">数组的遍历，在 for 循环中的应用&lt;/h2>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#!/bin/bash
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#75715e">#&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>b&lt;span style="color:#f92672">=(&lt;/span>&lt;span style="color:#ae81ff">01&lt;/span> &lt;span style="color:#ae81ff">4&lt;/span> &lt;span style="color:#ae81ff">5&lt;/span> &lt;span style="color:#ae81ff">06&lt;/span> &lt;span style="color:#ae81ff">9&lt;/span> &lt;span style="color:#ae81ff">11&lt;/span> &lt;span style="color:#ae81ff">12&lt;/span> &lt;span style="color:#ae81ff">14&lt;/span> &lt;span style="color:#ae81ff">14&lt;/span> &lt;span style="color:#ae81ff">20&lt;/span> 0808&lt;span style="color:#f92672">)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>let max&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">${#&lt;/span>b[@]&lt;span style="color:#e6db74">}&lt;/span>-1
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">for&lt;/span> Subscript in &lt;span style="color:#e6db74">`&lt;/span>seq &lt;span style="color:#ae81ff">0&lt;/span> &lt;span style="color:#e6db74">${&lt;/span>max&lt;span style="color:#e6db74">}&lt;/span>&lt;span style="color:#e6db74">`&lt;/span>;&lt;span style="color:#66d9ef">do&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> echo &lt;span style="color:#e6db74">${&lt;/span>b[&lt;span style="color:#e6db74">${&lt;/span>Subscript&lt;span style="color:#e6db74">}&lt;/span>]&lt;span style="color:#e6db74">}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">done&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>可以遍历数组并输出数组中每一个值
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div></description></item><item><title>Docs: 条件语句与运算</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/4.terminal-%E4%B8%8E-shell/shell-%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/%E6%8E%A7%E5%88%B6%E7%BB%93%E6%9E%84/%E6%9D%A1%E4%BB%B6%E8%AF%AD%E5%8F%A5%E4%B8%8E%E8%BF%90%E7%AE%97/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/4.terminal-%E4%B8%8E-shell/shell-%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/%E6%8E%A7%E5%88%B6%E7%BB%93%E6%9E%84/%E6%9D%A1%E4%BB%B6%E8%AF%AD%E5%8F%A5%E4%B8%8E%E8%BF%90%E7%AE%97/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Operator_(computer_programming)">Wiki,Operator(运算)&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.tutorialspoint.com/unix/unix-basic-operators.htm">https://www.tutorialspoint.com/unix/unix-basic-operators.htm&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>使用运算符操作一个或多个内容，然后得到另一个内容，这个过程就是运算。要操作的内容可以是一个具体的数值、字符串、变量等。&lt;/p>
&lt;p>在编程中使用运算可以得到一个具体的值，或者进行一次判断以得出“真”或者“假”的结果，以这个结果作为执行某些操作的依据。&lt;/p>
&lt;p>EXAMPLE：&lt;/p>
&lt;ul>
&lt;li>2+3，进行算数运算，求和。2 和 3 是两个内容，+是运算符，运算后的值为 5。&lt;/li>
&lt;li>[ test1 = test2 ]，进行判断运算，判断运算符两边的内容是否一样，并得出“是”或者“否”这两种结论其中一个。test1 与 test2 是两个内容，=是运算符，运算后的结果是假，i.e.test1 不等于 test2。一般情况，当结果为真或者假之后，就可以执行某些操作，详见 3.Shell 控制结构.note&lt;/li>
&lt;/ul>
&lt;ol>
&lt;li>判断命令运行结果：shell 中的 if 语句会运行“条件语句”中给定的命令，如果该命令的退出状态码(详见下文红字)是 0，则“分支”中给定的命令就会被执行。如果该命令的退出状态码非 0，则“分支”中给定的命令不被执行，且会继续执行该脚本中下一个命令。
&lt;ol>
&lt;li>比如下面这种
&lt;ol>
&lt;li>if ! COMMAND; then echo &amp;ldquo;command failed&amp;rdquo;; exit 1; fi&lt;/li>
&lt;/ol>
&lt;/li>
&lt;/ol>
&lt;/li>
&lt;li>使用 test 命令进行判断：“条件语句”中除了运行命令判断退出状态码，还可以通过 test 命令来进行运算判断，然后通过运算结果得出状态码是 0 还是 1 来进行条件判断(e.g.1 是否大于 2，文件是否存在，字符串是否一样等运算)。当运算结果为真时退出码为 0，否则运算结果非假则退出码非 0。运算方式以及命令详见下文的运算
&lt;ol>
&lt;li>语法结构：test CONDITION
&lt;ol>
&lt;li>EXAMPLE
&lt;ol>
&lt;li>test 1 -gt 2 #判断 1 是否大于 2，使用 echo $?输出结果为 1，表示判断结果为错误，非 0&lt;/li>
&lt;/ol>
&lt;/li>
&lt;/ol>
&lt;/li>
&lt;li>在 shell 中，test 命令可以通过 [ 条件 ] 与 [[ 条件 ]] 来进行表示(e.g.[[ 1 -gt 2 ]]) 。这种表示方式与使用 test 命令效果相同&lt;/li>
&lt;/ol>
&lt;/li>
&lt;/ol>
&lt;p>其实上述两种，说白了，都是判断命令运行结果，因为&lt;code>[[ ]]&lt;/code>符号也相当于命令，判断括号中的内容执行是否成功。所以，在日常使用中，第一种判断命令运行结果，也经常放在&lt;code>[[ ]]&lt;/code>来执行，比如 if [[ $(ls | grep test) ]]; then echo &amp;ldquo;搜到了&amp;rdquo;; fi 这种&lt;/p>
&lt;p>注意：linux 命令执行完成后一共有两个输出内容&lt;/p>
&lt;ul>
&lt;li>命令执行结果：当命令执行完成后直接看到的屏幕输出的内容就是执行结果，&lt;/li>
&lt;li>命令执行状态：命令执行完成后还有有一个执行状态值，表示该命令是否执行成功，以及失败的状态值。该值是隐藏的，命令执行完成后不会显示该值，可以通过 echo $?查看。命令状态值可以通过脚本中命令 exit 来定义，以下是命令状态值的两种分类&lt;/li>
&lt;li>0：数字 0 表示执行状态成功，命令正确，条件判断为真&lt;/li>
&lt;li>非 0：表示命令执行失败，会返回非 0 的值，不同的值表示不同的失败问题，条件判断为假&lt;/li>
&lt;li>条件语句中只有一种判断方法：判断该命令执行的状态返回值，0 为真，非 0 为假，即返回值为 0 时，执行分支 1 语句，返回值为非 0 时执行分支 2 语句&lt;/li>
&lt;/ul>
&lt;p>注意：[[ ]] 中的语句是会真实执行的，并且一个完整的控制结构中，不管判断中的语句是否执行成功，其返回值都是 0，因为这个控制结构代码成功了。&lt;/p>
&lt;pre>&lt;code>[root@master ~]# if [[ $(mkdir test) ]]; then echo ok;fi
ok
[root@master ~]# if [[ $(mkdir test) ]]; then echo ok;fi
mkdir: cannot create directory ‘test’: File exists
[root@master ~]# echo $?
0
&lt;/code>&lt;/pre>
&lt;h1 id="运算">运算&lt;/h1>
&lt;p>按照运算所得结果来分类的话，总共分为两大类：&lt;/p>
&lt;ul>
&lt;li>Boolean Operators(逻辑运算) # 之所以被称为逻辑运算符是因为它们的运算结果总是为布尔值 bool，不是 true 就是 false。e.g.1 是否等于 2、语句是否执行成功、是否有返回值、条件一成立且条件二失败结果四 true 还是 false&lt;/li>
&lt;li>Arithmetic Operators(算数运算) # 最后的运算结果必然是数学概念上的整数、小数等。e.g.1+2=3、2*3=6 等&lt;/li>
&lt;li>Relational Operators(关系运算)&lt;/li>
&lt;li>String Operators(字符串运算)&lt;/li>
&lt;li>File Test Operators(文件测试运算)&lt;/li>
&lt;/ul>
&lt;h2 id="算术运算符">算术运算符&lt;/h2>
&lt;p>下表列出了常用的算术运算符，假定变量 a 为 10，变量 b 为 20：&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>运算符&lt;/th>
&lt;th>说明&lt;/th>
&lt;th>举例&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>+&lt;/td>
&lt;td>加法&lt;/td>
&lt;td>&lt;code>expr $a + $b&lt;/code> 结果为 30。&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>-&lt;/td>
&lt;td>减法&lt;/td>
&lt;td>&lt;code>expr $a - $b&lt;/code> 结果为 -10。&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>*&lt;/td>
&lt;td>乘法&lt;/td>
&lt;td>&lt;code>expr $a \* $b&lt;/code> 结果为 200。&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>/&lt;/td>
&lt;td>除法&lt;/td>
&lt;td>&lt;code>expr $b / $a&lt;/code> 结果为 2。&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>%&lt;/td>
&lt;td>取余&lt;/td>
&lt;td>&lt;code>expr $b % $a&lt;/code> 结果为 0。&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>=&lt;/td>
&lt;td>赋值&lt;/td>
&lt;td>a=$b 将把变量 b 的值赋给 a。&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>==&lt;/td>
&lt;td>相等。用于比较两个数字，相同则返回 true。&lt;/td>
&lt;td>[ $a == $b ] 返回 false。&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>!=&lt;/td>
&lt;td>不相等。用于比较两个数字，不相同则返回 true。&lt;/td>
&lt;td>[ $a != $b ] 返回 true。&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>注意：条件表达式要放在方括号之间，并且要有空格，例如: [$a==$b] 是错误的，必须写成 [ $a == $b ]。&lt;/p>
&lt;ul>
&lt;li>算数运算
&lt;ul>
&lt;li>if (( 1 + 2 == 3 )); then&amp;hellip;.. # 如果 1+2 等于 3，那么执行后面的语句&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h3 id="算数运算的相关命令">算数运算的相关命令&lt;/h3>
&lt;h4 id="expr-expression">expr Expression&lt;/h4>
&lt;p>Expression(表达式) 为数值 算数运算符 数值&lt;/p>
&lt;p>EXAMPLE&lt;/p>
&lt;ul>
&lt;li>expr 3 + 7 # 输出结果为 10&lt;/li>
&lt;/ul>
&lt;p>VarName=$[算术表达式]&lt;/p>
&lt;p>VarName=$((算术表达式))&lt;/p>
&lt;h4 id="let-命令">let 命令&lt;/h4>
&lt;p>let VarName=算数表达式 &amp;amp;&amp;amp; echo $VarName&lt;/p>
&lt;p>EXAMPLE&lt;/p>
&lt;ul>
&lt;li>let sum=3+8; echo $sum # 输出结果为 11&lt;/li>
&lt;/ul>
&lt;h4 id="--与---符号">&lt;code>$[ ]&lt;/code> 与 &lt;code>$(( ))&lt;/code> 符号&lt;/h4>
&lt;p>EXAMPLE&lt;/p>
&lt;ul>
&lt;li>echo $[1+2] # 输出结果为 3&lt;/li>
&lt;/ul>
&lt;h2 id="布尔运算符">布尔运算符&lt;/h2>
&lt;p>逻辑运算符，有的地方也称为 &lt;strong>Boolean(布尔)&lt;/strong> 运算符，假定变量 a 为 10，变量 b 为 20:&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>运算符&lt;/th>
&lt;th>说明&lt;/th>
&lt;th>举例&lt;/th>
&lt;th>&lt;/th>
&lt;th>&lt;/th>
&lt;th>&lt;/th>
&lt;th>&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>&amp;amp;&amp;amp;&lt;/td>
&lt;td>逻辑的 AND&lt;/td>
&lt;td>[[ $a -lt 100 &amp;amp;&amp;amp; $b -gt 100 ]] 返回 false&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>-a&lt;/td>
&lt;td>与运算，两个表达式都为 true 才返回 true。&lt;/td>
&lt;td>[ $a -lt 20 -a $b -gt 100 ] 返回 false。&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;td>或运算，有一个表达式为 true 则返回 true。&lt;/td>
&lt;td>[[ $a -lt 100&lt;/td>
&lt;td>&lt;/td>
&lt;td>$b -gt 100 ]] 返回 true&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>-o&lt;/td>
&lt;td>或运算，有一个表达式为 true 则返回 true。&lt;/td>
&lt;td>[ $a -lt 20 -o $b -gt 100 ] 返回 true。&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>!&lt;/td>
&lt;td>非运算，表达式为 true 则返回 false，否则返回 true。&lt;/td>
&lt;td>[ ! false ] 返回 true。&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="syntax语法">Syntax(语法)&lt;/h3>
&lt;p>&lt;strong>逻辑运算(布尔运算，只有真，假两种)&lt;/strong> # （即条件语句的是否执行成功，成功为真，不成功为假，非真）&lt;/p>
&lt;ul>
&lt;li>与运算：&lt;code>&amp;amp;&amp;amp;&lt;/code> (或者用-a)(条件一$$条件二=结果)
&lt;ul>
&lt;li>真&amp;amp;&amp;amp;真=真&lt;/li>
&lt;li>真&amp;amp;&amp;amp;假=假&lt;/li>
&lt;li>假&amp;amp;&amp;amp;假=假
&lt;ul>
&lt;li>条件一为假，结果即为假，条件二就不会执行&lt;/li>
&lt;li>条件一为真，则最终结果无法判断，那么条件二必须执行&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>或运算：&lt;code>||&lt;/code> (或者用-o)(条件一||条件二=结果)
&lt;ul>
&lt;li>真||真=真&lt;/li>
&lt;li>真||假=真&lt;/li>
&lt;li>假||假=假
&lt;ul>
&lt;li>第一个条件为真，结果即为真&lt;/li>
&lt;li>条件一为真，结果即为真，条件二不会执行&lt;/li>
&lt;li>条件一为假，结果无法判断，那么条件二必须执行&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>非运算：&lt;code>!&lt;/code>
&lt;ul>
&lt;li>!真=假&lt;/li>
&lt;li>!假=真&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>EXAMP LE：
&lt;ul>
&lt;li>id $name &amp;amp;&amp;gt; /dev/null &amp;amp;&amp;amp; echo &amp;ldquo;exist&amp;rdquo; || echo &amp;ldquo;not exist&amp;rdquo; #如果 id $name 结果为真，那么输出 exist 否则输出 not exist，因为与运算优先级更高，先判断 命令执行状态是否为真，如果为真，则必须执行第二条，如果为假，那么第二条不会执行，就直接进行或运算，第一条命令状态为假的话，就必须执行或运算中的第二条命令，即总体的第三条。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h2 id="关系运算符">关系运算符&lt;/h2>
&lt;p>在编程领域中&lt;/p>
&lt;ul>
&lt;li>真 可以用 true 或者 1 来表示&lt;/li>
&lt;li>假 可以用 false 或者 0 来表示&lt;/li>
&lt;/ul>
&lt;p>关系运算符只支持数字，不支持字符串，除非字符串的值是数字。&lt;/p>
&lt;p>下表列出了常用的关系运算符，假定变量 a 为 10，变量 b 为 20：&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>运算符&lt;/th>
&lt;th>说明&lt;/th>
&lt;th>举例&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>-eq&lt;/td>
&lt;td>检测两个数是否相等，相等返回 true。&lt;/td>
&lt;td>[ $a -eq $b ] 返回 false。&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>-ne&lt;/td>
&lt;td>检测两个数是否不相等，不相等返回 true。&lt;/td>
&lt;td>[ $a -ne $b ] 返回 true。&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>-gt&lt;/td>
&lt;td>检测左边的数是否大于右边的，如果是，则返回 true。&lt;/td>
&lt;td>[ $a -gt $b ] 返回 false。&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>-lt&lt;/td>
&lt;td>检测左边的数是否小于右边的，如果是，则返回 true。&lt;/td>
&lt;td>[ $a -lt $b ] 返回 true。&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>-ge&lt;/td>
&lt;td>检测左边的数是否大于等于右边的，如果是，则返回 true。&lt;/td>
&lt;td>[ $a -ge $b ] 返回 false。&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>-le&lt;/td>
&lt;td>检测左边的数是否小于等于右边的，如果是，则返回 true。&lt;/td>
&lt;td>[ $a -le $b ] 返回 true。&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="syntax语法-1">Syntax(语法)&lt;/h3>
&lt;p>**[ NUM1 比较符 NUM2 ] **# num1 与 num2 为具体数字,注意括号中的空格不要忘了&lt;/p>
&lt;ul>
&lt;li>比较符说明：
&lt;ul>
&lt;li>-gt # 大于&lt;/li>
&lt;li>-lt # 小于&lt;/li>
&lt;li>-ge # 大于等于&lt;/li>
&lt;li>-le # 小于等于&lt;/li>
&lt;li>-ne # 不等于&lt;/li>
&lt;li>-eq # 等于&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>EXAMPLE
&lt;ul>
&lt;li>[ 1 -ge 2 ] # 判断 1 是否大于 2，如果成功$?返回值为0，否则返回值为1，该命令$?的值为 1&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h2 id="字符串运算符">字符串运算符&lt;/h2>
&lt;p>下表列出了常用的字符串运算符，假定变量 a 为 &amp;ldquo;abc&amp;rdquo;，变量 b 为 &amp;ldquo;efg&amp;rdquo;：&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>运算符&lt;/th>
&lt;th>说明&lt;/th>
&lt;th>举例&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>=&lt;/td>
&lt;td>检测两个字符串是否相等，相等返回 true。&lt;/td>
&lt;td>[ $a = $b ] 返回 false。&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>!=&lt;/td>
&lt;td>检测两个字符串是否相等，不相等返回 true。&lt;/td>
&lt;td>[ $a != $b ] 返回 true。&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>-z&lt;/td>
&lt;td>检测字符串长度是否为 0，为 0 返回 true。&lt;/td>
&lt;td>[ -z $a ] 返回 false。&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>-n&lt;/td>
&lt;td>检测字符串长度是否为 0，不为 0 返回 true。&lt;/td>
&lt;td>[ -n &amp;ldquo;$a&amp;rdquo; ] 返回 true。&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>STR&lt;/td>
&lt;td>检测字符串 STR 是否为空，不为空返回 true。等效于 -n&lt;/td>
&lt;td>[ $a ] 返回 true。&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;!-- raw HTML omitted -->
&lt;ul>
&lt;li>比较符：
&lt;ul>
&lt;li>== 是否等于&lt;/li>
&lt;li>!= 是否不等于&lt;/li>
&lt;li>=~ 判定左侧的字符串能否被右侧的模式所匹配,通常只在[[]]中使用&lt;/li>
&lt;li>&amp;lt; 是否小于&lt;/li>
&lt;li>
&lt;blockquote>
&lt;p>是否大于（注意：大于小于号前需要加,否则脚本当成重定向符号）&lt;/p>
&lt;/blockquote>
&lt;/li>
&lt;li>[ -n str ] 检查 str 的长度是否非 0&lt;/li>
&lt;li>[ -z str ] 检查 str 的长度是否为 0&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>EXAMPLE&lt;/li>
&lt;/ul>
&lt;h2 id="文件测试运算符">文件测试运算符&lt;/h2>
&lt;p>文件测试运算符用于检测 Unix 文件的各种属性。属性检测描述如下：&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>操作符&lt;/th>
&lt;th>说明&lt;/th>
&lt;th>举例&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>-b FILE&lt;/td>
&lt;td>检测文件是否是块设备文件，如果是，则返回 true。&lt;/td>
&lt;td>[ -b $file ] 返回 false。&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>-c FILE&lt;/td>
&lt;td>检测文件是否是字符设备文件，如果是，则返回 true。&lt;/td>
&lt;td>[ -c $file ] 返回 false。&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>-d FILE&lt;/td>
&lt;td>检测文件是否是目录，如果是，则返回 true。&lt;/td>
&lt;td>[ -d $file ] 返回 false。&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>-f FILE&lt;/td>
&lt;td>检测文件是否是普通文件（既不是目录，也不是设备文件），如果是，则返回 true。&lt;/td>
&lt;td>[ -f $file ] 返回 true。&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>-g FILE&lt;/td>
&lt;td>检测文件是否设置了 SGID 位，如果是，则返回 true。&lt;/td>
&lt;td>[ -g $file ] 返回 false。&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>-k FILE&lt;/td>
&lt;td>检测文件是否设置了粘着位(Sticky Bit)，如果是，则返回 true。&lt;/td>
&lt;td>[ -k $file ] 返回 false。&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>-p FILE&lt;/td>
&lt;td>检测文件是否是有名管道，如果是，则返回 true。&lt;/td>
&lt;td>[ -p $file ] 返回 false。&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>-u FILE&lt;/td>
&lt;td>检测文件是否设置了 SUID 位，如果是，则返回 true。&lt;/td>
&lt;td>[ -u $file ] 返回 false。&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>-r FILE&lt;/td>
&lt;td>检测文件是否可读，如果是，则返回 true。&lt;/td>
&lt;td>[ -r $file ] 返回 true。&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>-w FILE&lt;/td>
&lt;td>检测文件是否可写，如果是，则返回 true。&lt;/td>
&lt;td>[ -w $file ] 返回 true。&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>-x FILE&lt;/td>
&lt;td>检测文件是否可执行，如果是，则返回 true。&lt;/td>
&lt;td>[ -x $file ] 返回 true。&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>-s FILE&lt;/td>
&lt;td>检测文件是否为空（文件大小是否大于 0），不为空返回 true。&lt;/td>
&lt;td>[ -s $file ] 返回 true。&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>-e FILE&lt;/td>
&lt;td>检测文件（包括目录）是否存在，如果是，则返回 true。&lt;/td>
&lt;td>[ -e $file ] 返回 true。&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>运算符按照操作格式分类：&lt;/p>
&lt;ul>
&lt;li>一元运算符：就是只需要一个操作数，如 a&amp;ndash;、a++、 !a、 ~a 等&lt;/li>
&lt;li>二元运算符：就是需要两个操作数才能完成运算 如典型的 a+b、 a-b、 a*b、 a/b 等&lt;/li>
&lt;li>三元运算符：:?唯一一个三元运算符&lt;/li>
&lt;/ul>
&lt;h3 id="syntax语法-2">Syntax(语法)&lt;/h3>
&lt;p>**[ FileTestOperator &amp;ldquo;FILENAME&amp;rdquo; ] **# 为了防止文件名 FILENAME 中出现空格等特殊字符，所以用双引号引起来以防出现意外&lt;/p>
&lt;ul>
&lt;li>**FileTestOperator # **所有选项检查前提都是含有隐含意义，就是默认先检查是否存在再检查其余特殊情况
&lt;ul>
&lt;li>-e # 检查文件是否存在&lt;/li>
&lt;li>-d # 检查文件是否存在且为目录&lt;/li>
&lt;li>-f # 检查是否为文件&lt;/li>
&lt;li>-n # 是否为数字&lt;/li>
&lt;li>-r(w)(x) # 检查是否可读(写)(执行)&lt;/li>
&lt;li>-s # 检查是否为空&lt;/li>
&lt;li>-O # 是否属于当前用户&lt;/li>
&lt;li>-G # 是否默认组与当前用户相同&lt;/li>
&lt;li>[ FILE1 -nt FILE ] 检查文件 1 是否新于文件 2&lt;/li>
&lt;li>[ FILE1 -ot FILE2 ] 检查文件 1 是否旧于文件 2&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>EXAMPLE
&lt;ul>
&lt;li>if [ ! -f file.txt ] #如果 file.txt 存在且为文件&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h1 id="heading">&lt;/h1></description></item></channel></rss>