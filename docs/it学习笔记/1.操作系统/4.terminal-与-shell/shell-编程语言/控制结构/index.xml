<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>断念梦 – 控制结构</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/4.terminal-%E4%B8%8E-shell/shell-%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/%E6%8E%A7%E5%88%B6%E7%BB%93%E6%9E%84/</link><description>Recent content in 控制结构 on 断念梦</description><generator>Hugo -- gohugo.io</generator><atom:link href="https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/4.terminal-%E4%B8%8E-shell/shell-%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/%E6%8E%A7%E5%88%B6%E7%BB%93%E6%9E%84/index.xml" rel="self" type="application/rss+xml"/><item><title>Docs: 条件语句与运算</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/4.terminal-%E4%B8%8E-shell/shell-%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/%E6%8E%A7%E5%88%B6%E7%BB%93%E6%9E%84/%E6%9D%A1%E4%BB%B6%E8%AF%AD%E5%8F%A5%E4%B8%8E%E8%BF%90%E7%AE%97/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/4.terminal-%E4%B8%8E-shell/shell-%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/%E6%8E%A7%E5%88%B6%E7%BB%93%E6%9E%84/%E6%9D%A1%E4%BB%B6%E8%AF%AD%E5%8F%A5%E4%B8%8E%E8%BF%90%E7%AE%97/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Operator_(computer_programming)">Wiki,Operator(运算)&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.tutorialspoint.com/unix/unix-basic-operators.htm">https://www.tutorialspoint.com/unix/unix-basic-operators.htm&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>使用运算符操作一个或多个内容，然后得到另一个内容，这个过程就是运算。要操作的内容可以是一个具体的数值、字符串、变量等。&lt;/p>
&lt;p>在编程中使用运算可以得到一个具体的值，或者进行一次判断以得出“真”或者“假”的结果，以这个结果作为执行某些操作的依据。&lt;/p>
&lt;p>EXAMPLE：&lt;/p>
&lt;ul>
&lt;li>2+3，进行算数运算，求和。2 和 3 是两个内容，+是运算符，运算后的值为 5。&lt;/li>
&lt;li>[ test1 = test2 ]，进行判断运算，判断运算符两边的内容是否一样，并得出“是”或者“否”这两种结论其中一个。test1 与 test2 是两个内容，=是运算符，运算后的结果是假，i.e.test1 不等于 test2。一般情况，当结果为真或者假之后，就可以执行某些操作，详见 3.Shell 控制结构.note&lt;/li>
&lt;/ul>
&lt;ol>
&lt;li>判断命令运行结果：shell 中的 if 语句会运行“条件语句”中给定的命令，如果该命令的退出状态码(详见下文红字)是 0，则“分支”中给定的命令就会被执行。如果该命令的退出状态码非 0，则“分支”中给定的命令不被执行，且会继续执行该脚本中下一个命令。
&lt;ol>
&lt;li>比如下面这种
&lt;ol>
&lt;li>if ! COMMAND; then echo &amp;ldquo;command failed&amp;rdquo;; exit 1; fi&lt;/li>
&lt;/ol>
&lt;/li>
&lt;/ol>
&lt;/li>
&lt;li>使用 test 命令进行判断：“条件语句”中除了运行命令判断退出状态码，还可以通过 test 命令来进行运算判断，然后通过运算结果得出状态码是 0 还是 1 来进行条件判断(e.g.1 是否大于 2，文件是否存在，字符串是否一样等运算)。当运算结果为真时退出码为 0，否则运算结果非假则退出码非 0。运算方式以及命令详见下文的运算
&lt;ol>
&lt;li>语法结构：test CONDITION
&lt;ol>
&lt;li>EXAMPLE
&lt;ol>
&lt;li>test 1 -gt 2 #判断 1 是否大于 2，使用 echo $?输出结果为 1，表示判断结果为错误，非 0&lt;/li>
&lt;/ol>
&lt;/li>
&lt;/ol>
&lt;/li>
&lt;li>在 shell 中，test 命令可以通过 [ 条件 ] 与 [[ 条件 ]] 来进行表示(e.g.[[ 1 -gt 2 ]]) 。这种表示方式与使用 test 命令效果相同&lt;/li>
&lt;/ol>
&lt;/li>
&lt;/ol>
&lt;p>其实上述两种，说白了，都是判断命令运行结果，因为&lt;code>[[ ]]&lt;/code>符号也相当于命令，判断括号中的内容执行是否成功。所以，在日常使用中，第一种判断命令运行结果，也经常放在&lt;code>[[ ]]&lt;/code>来执行，比如 if [[ $(ls | grep test) ]]; then echo &amp;ldquo;搜到了&amp;rdquo;; fi 这种&lt;/p>
&lt;p>注意：linux 命令执行完成后一共有两个输出内容&lt;/p>
&lt;ul>
&lt;li>命令执行结果：当命令执行完成后直接看到的屏幕输出的内容就是执行结果，&lt;/li>
&lt;li>命令执行状态：命令执行完成后还有有一个执行状态值，表示该命令是否执行成功，以及失败的状态值。该值是隐藏的，命令执行完成后不会显示该值，可以通过 echo $?查看。命令状态值可以通过脚本中命令 exit 来定义，以下是命令状态值的两种分类&lt;/li>
&lt;li>0：数字 0 表示执行状态成功，命令正确，条件判断为真&lt;/li>
&lt;li>非 0：表示命令执行失败，会返回非 0 的值，不同的值表示不同的失败问题，条件判断为假&lt;/li>
&lt;li>条件语句中只有一种判断方法：判断该命令执行的状态返回值，0 为真，非 0 为假，即返回值为 0 时，执行分支 1 语句，返回值为非 0 时执行分支 2 语句&lt;/li>
&lt;/ul>
&lt;p>注意：[[ ]] 中的语句是会真实执行的，并且一个完整的控制结构中，不管判断中的语句是否执行成功，其返回值都是 0，因为这个控制结构代码成功了。&lt;/p>
&lt;pre>&lt;code>[root@master ~]# if [[ $(mkdir test) ]]; then echo ok;fi
ok
[root@master ~]# if [[ $(mkdir test) ]]; then echo ok;fi
mkdir: cannot create directory ‘test’: File exists
[root@master ~]# echo $?
0
&lt;/code>&lt;/pre>
&lt;h1 id="运算">运算&lt;/h1>
&lt;p>按照运算所得结果来分类的话，总共分为两大类：&lt;/p>
&lt;ul>
&lt;li>Boolean Operators(逻辑运算) # 之所以被称为逻辑运算符是因为它们的运算结果总是为布尔值 bool，不是 true 就是 false。e.g.1 是否等于 2、语句是否执行成功、是否有返回值、条件一成立且条件二失败结果四 true 还是 false&lt;/li>
&lt;li>Arithmetic Operators(算数运算) # 最后的运算结果必然是数学概念上的整数、小数等。e.g.1+2=3、2*3=6 等&lt;/li>
&lt;li>Relational Operators(关系运算)&lt;/li>
&lt;li>String Operators(字符串运算)&lt;/li>
&lt;li>File Test Operators(文件测试运算)&lt;/li>
&lt;/ul>
&lt;h2 id="算术运算符">算术运算符&lt;/h2>
&lt;p>下表列出了常用的算术运算符，假定变量 a 为 10，变量 b 为 20：&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>运算符&lt;/th>
&lt;th>说明&lt;/th>
&lt;th>举例&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>+&lt;/td>
&lt;td>加法&lt;/td>
&lt;td>&lt;code>expr $a + $b&lt;/code> 结果为 30。&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>-&lt;/td>
&lt;td>减法&lt;/td>
&lt;td>&lt;code>expr $a - $b&lt;/code> 结果为 -10。&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>*&lt;/td>
&lt;td>乘法&lt;/td>
&lt;td>&lt;code>expr $a \* $b&lt;/code> 结果为 200。&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>/&lt;/td>
&lt;td>除法&lt;/td>
&lt;td>&lt;code>expr $b / $a&lt;/code> 结果为 2。&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>%&lt;/td>
&lt;td>取余&lt;/td>
&lt;td>&lt;code>expr $b % $a&lt;/code> 结果为 0。&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>=&lt;/td>
&lt;td>赋值&lt;/td>
&lt;td>a=$b 将把变量 b 的值赋给 a。&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>==&lt;/td>
&lt;td>相等。用于比较两个数字，相同则返回 true。&lt;/td>
&lt;td>[ $a == $b ] 返回 false。&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>!=&lt;/td>
&lt;td>不相等。用于比较两个数字，不相同则返回 true。&lt;/td>
&lt;td>[ $a != $b ] 返回 true。&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>注意：条件表达式要放在方括号之间，并且要有空格，例如: [$a==$b] 是错误的，必须写成 [ $a == $b ]。&lt;/p>
&lt;ul>
&lt;li>算数运算
&lt;ul>
&lt;li>if (( 1 + 2 == 3 )); then&amp;hellip;.. # 如果 1+2 等于 3，那么执行后面的语句&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h3 id="算数运算的相关命令">算数运算的相关命令&lt;/h3>
&lt;h4 id="expr-expression">expr Expression&lt;/h4>
&lt;p>Expression(表达式) 为数值 算数运算符 数值&lt;/p>
&lt;p>EXAMPLE&lt;/p>
&lt;ul>
&lt;li>expr 3 + 7 # 输出结果为 10&lt;/li>
&lt;/ul>
&lt;p>VarName=$[算术表达式]&lt;/p>
&lt;p>VarName=$((算术表达式))&lt;/p>
&lt;h4 id="let-命令">let 命令&lt;/h4>
&lt;p>let VarName=算数表达式 &amp;amp;&amp;amp; echo $VarName&lt;/p>
&lt;p>EXAMPLE&lt;/p>
&lt;ul>
&lt;li>let sum=3+8; echo $sum # 输出结果为 11&lt;/li>
&lt;/ul>
&lt;h4 id="--与---符号">&lt;code>$[ ]&lt;/code> 与 &lt;code>$(( ))&lt;/code> 符号&lt;/h4>
&lt;p>EXAMPLE&lt;/p>
&lt;ul>
&lt;li>echo $[1+2] # 输出结果为 3&lt;/li>
&lt;/ul>
&lt;h2 id="布尔运算符">布尔运算符&lt;/h2>
&lt;p>逻辑运算符，有的地方也称为 &lt;strong>Boolean(布尔)&lt;/strong> 运算符，假定变量 a 为 10，变量 b 为 20:&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>运算符&lt;/th>
&lt;th>说明&lt;/th>
&lt;th>举例&lt;/th>
&lt;th>&lt;/th>
&lt;th>&lt;/th>
&lt;th>&lt;/th>
&lt;th>&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>&amp;amp;&amp;amp;&lt;/td>
&lt;td>逻辑的 AND&lt;/td>
&lt;td>[[ $a -lt 100 &amp;amp;&amp;amp; $b -gt 100 ]] 返回 false&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>-a&lt;/td>
&lt;td>与运算，两个表达式都为 true 才返回 true。&lt;/td>
&lt;td>[ $a -lt 20 -a $b -gt 100 ] 返回 false。&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;td>或运算，有一个表达式为 true 则返回 true。&lt;/td>
&lt;td>[[ $a -lt 100&lt;/td>
&lt;td>&lt;/td>
&lt;td>$b -gt 100 ]] 返回 true&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>-o&lt;/td>
&lt;td>或运算，有一个表达式为 true 则返回 true。&lt;/td>
&lt;td>[ $a -lt 20 -o $b -gt 100 ] 返回 true。&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>!&lt;/td>
&lt;td>非运算，表达式为 true 则返回 false，否则返回 true。&lt;/td>
&lt;td>[ ! false ] 返回 true。&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="syntax语法">Syntax(语法)&lt;/h3>
&lt;p>&lt;strong>逻辑运算(布尔运算，只有真，假两种)&lt;/strong> # （即条件语句的是否执行成功，成功为真，不成功为假，非真）&lt;/p>
&lt;ul>
&lt;li>与运算：&lt;code>&amp;amp;&amp;amp;&lt;/code> (或者用-a)(条件一$$条件二=结果)
&lt;ul>
&lt;li>真&amp;amp;&amp;amp;真=真&lt;/li>
&lt;li>真&amp;amp;&amp;amp;假=假&lt;/li>
&lt;li>假&amp;amp;&amp;amp;假=假
&lt;ul>
&lt;li>条件一为假，结果即为假，条件二就不会执行&lt;/li>
&lt;li>条件一为真，则最终结果无法判断，那么条件二必须执行&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>或运算：&lt;code>||&lt;/code> (或者用-o)(条件一||条件二=结果)
&lt;ul>
&lt;li>真||真=真&lt;/li>
&lt;li>真||假=真&lt;/li>
&lt;li>假||假=假
&lt;ul>
&lt;li>第一个条件为真，结果即为真&lt;/li>
&lt;li>条件一为真，结果即为真，条件二不会执行&lt;/li>
&lt;li>条件一为假，结果无法判断，那么条件二必须执行&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>非运算：&lt;code>!&lt;/code>
&lt;ul>
&lt;li>!真=假&lt;/li>
&lt;li>!假=真&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>EXAMP LE：
&lt;ul>
&lt;li>id $name &amp;amp;&amp;gt; /dev/null &amp;amp;&amp;amp; echo &amp;ldquo;exist&amp;rdquo; || echo &amp;ldquo;not exist&amp;rdquo; #如果 id $name 结果为真，那么输出 exist 否则输出 not exist，因为与运算优先级更高，先判断 命令执行状态是否为真，如果为真，则必须执行第二条，如果为假，那么第二条不会执行，就直接进行或运算，第一条命令状态为假的话，就必须执行或运算中的第二条命令，即总体的第三条。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h2 id="关系运算符">关系运算符&lt;/h2>
&lt;p>在编程领域中&lt;/p>
&lt;ul>
&lt;li>真 可以用 true 或者 1 来表示&lt;/li>
&lt;li>假 可以用 false 或者 0 来表示&lt;/li>
&lt;/ul>
&lt;p>关系运算符只支持数字，不支持字符串，除非字符串的值是数字。&lt;/p>
&lt;p>下表列出了常用的关系运算符，假定变量 a 为 10，变量 b 为 20：&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>运算符&lt;/th>
&lt;th>说明&lt;/th>
&lt;th>举例&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>-eq&lt;/td>
&lt;td>检测两个数是否相等，相等返回 true。&lt;/td>
&lt;td>[ $a -eq $b ] 返回 false。&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>-ne&lt;/td>
&lt;td>检测两个数是否不相等，不相等返回 true。&lt;/td>
&lt;td>[ $a -ne $b ] 返回 true。&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>-gt&lt;/td>
&lt;td>检测左边的数是否大于右边的，如果是，则返回 true。&lt;/td>
&lt;td>[ $a -gt $b ] 返回 false。&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>-lt&lt;/td>
&lt;td>检测左边的数是否小于右边的，如果是，则返回 true。&lt;/td>
&lt;td>[ $a -lt $b ] 返回 true。&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>-ge&lt;/td>
&lt;td>检测左边的数是否大于等于右边的，如果是，则返回 true。&lt;/td>
&lt;td>[ $a -ge $b ] 返回 false。&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>-le&lt;/td>
&lt;td>检测左边的数是否小于等于右边的，如果是，则返回 true。&lt;/td>
&lt;td>[ $a -le $b ] 返回 true。&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="syntax语法-1">Syntax(语法)&lt;/h3>
&lt;p>**[ NUM1 比较符 NUM2 ] **# num1 与 num2 为具体数字,注意括号中的空格不要忘了&lt;/p>
&lt;ul>
&lt;li>比较符说明：
&lt;ul>
&lt;li>-gt # 大于&lt;/li>
&lt;li>-lt # 小于&lt;/li>
&lt;li>-ge # 大于等于&lt;/li>
&lt;li>-le # 小于等于&lt;/li>
&lt;li>-ne # 不等于&lt;/li>
&lt;li>-eq # 等于&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>EXAMPLE
&lt;ul>
&lt;li>[ 1 -ge 2 ] # 判断 1 是否大于 2，如果成功$?返回值为0，否则返回值为1，该命令$?的值为 1&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h2 id="字符串运算符">字符串运算符&lt;/h2>
&lt;p>下表列出了常用的字符串运算符，假定变量 a 为 &amp;ldquo;abc&amp;rdquo;，变量 b 为 &amp;ldquo;efg&amp;rdquo;：&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>运算符&lt;/th>
&lt;th>说明&lt;/th>
&lt;th>举例&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>=&lt;/td>
&lt;td>检测两个字符串是否相等，相等返回 true。&lt;/td>
&lt;td>[ $a = $b ] 返回 false。&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>!=&lt;/td>
&lt;td>检测两个字符串是否相等，不相等返回 true。&lt;/td>
&lt;td>[ $a != $b ] 返回 true。&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>-z&lt;/td>
&lt;td>检测字符串长度是否为 0，为 0 返回 true。&lt;/td>
&lt;td>[ -z $a ] 返回 false。&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>-n&lt;/td>
&lt;td>检测字符串长度是否为 0，不为 0 返回 true。&lt;/td>
&lt;td>[ -n &amp;ldquo;$a&amp;rdquo; ] 返回 true。&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>STR&lt;/td>
&lt;td>检测字符串 STR 是否为空，不为空返回 true。等效于 -n&lt;/td>
&lt;td>[ $a ] 返回 true。&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="syntax语法-2">Syntax(语法)&lt;/h3>
&lt;p>&lt;strong>[ str1 比较符 str2 ]&lt;/strong> # str1，str2为具体字符串，注意写括号中的空格&lt;/p>
&lt;ul>
&lt;li>比较符：
&lt;ul>
&lt;li>== 是否等于&lt;/li>
&lt;li>!= 是否不等于&lt;/li>
&lt;li>=~ 判定左侧的字符串能否被右侧的模式所匹配,通常只在[[]]中使用&lt;/li>
&lt;li>&amp;lt; 是否小于&lt;/li>
&lt;li>
&lt;blockquote>
&lt;p>是否大于（注意：大于小于号前需要加,否则脚本当成重定向符号）&lt;/p>
&lt;/blockquote>
&lt;/li>
&lt;li>[ -n str ] 检查 str 的长度是否非 0&lt;/li>
&lt;li>[ -z str ] 检查 str 的长度是否为 0&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>EXAMPLE&lt;/li>
&lt;/ul>
&lt;h2 id="文件测试运算符">文件测试运算符&lt;/h2>
&lt;p>文件测试运算符用于检测 Unix 文件的各种属性。属性检测描述如下：&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>操作符&lt;/th>
&lt;th>说明&lt;/th>
&lt;th>举例&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>-b FILE&lt;/td>
&lt;td>检测文件是否是块设备文件，如果是，则返回 true。&lt;/td>
&lt;td>[ -b $file ] 返回 false。&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>-c FILE&lt;/td>
&lt;td>检测文件是否是字符设备文件，如果是，则返回 true。&lt;/td>
&lt;td>[ -c $file ] 返回 false。&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>-d FILE&lt;/td>
&lt;td>检测文件是否是目录，如果是，则返回 true。&lt;/td>
&lt;td>[ -d $file ] 返回 false。&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>-f FILE&lt;/td>
&lt;td>检测文件是否是普通文件（既不是目录，也不是设备文件），如果是，则返回 true。&lt;/td>
&lt;td>[ -f $file ] 返回 true。&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>-g FILE&lt;/td>
&lt;td>检测文件是否设置了 SGID 位，如果是，则返回 true。&lt;/td>
&lt;td>[ -g $file ] 返回 false。&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>-k FILE&lt;/td>
&lt;td>检测文件是否设置了粘着位(Sticky Bit)，如果是，则返回 true。&lt;/td>
&lt;td>[ -k $file ] 返回 false。&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>-p FILE&lt;/td>
&lt;td>检测文件是否是有名管道，如果是，则返回 true。&lt;/td>
&lt;td>[ -p $file ] 返回 false。&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>-u FILE&lt;/td>
&lt;td>检测文件是否设置了 SUID 位，如果是，则返回 true。&lt;/td>
&lt;td>[ -u $file ] 返回 false。&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>-r FILE&lt;/td>
&lt;td>检测文件是否可读，如果是，则返回 true。&lt;/td>
&lt;td>[ -r $file ] 返回 true。&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>-w FILE&lt;/td>
&lt;td>检测文件是否可写，如果是，则返回 true。&lt;/td>
&lt;td>[ -w $file ] 返回 true。&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>-x FILE&lt;/td>
&lt;td>检测文件是否可执行，如果是，则返回 true。&lt;/td>
&lt;td>[ -x $file ] 返回 true。&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>-s FILE&lt;/td>
&lt;td>检测文件是否为空（文件大小是否大于 0），不为空返回 true。&lt;/td>
&lt;td>[ -s $file ] 返回 true。&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>-e FILE&lt;/td>
&lt;td>检测文件（包括目录）是否存在，如果是，则返回 true。&lt;/td>
&lt;td>[ -e $file ] 返回 true。&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>运算符按照操作格式分类：&lt;/p>
&lt;ul>
&lt;li>一元运算符：就是只需要一个操作数，如 a&amp;ndash;、a++、 !a、 ~a 等&lt;/li>
&lt;li>二元运算符：就是需要两个操作数才能完成运算 如典型的 a+b、 a-b、 a*b、 a/b 等&lt;/li>
&lt;li>三元运算符：:?唯一一个三元运算符&lt;/li>
&lt;/ul>
&lt;h3 id="syntax语法-3">Syntax(语法)&lt;/h3>
&lt;p>**[ FileTestOperator &amp;ldquo;FILENAME&amp;rdquo; ] **# 为了防止文件名 FILENAME 中出现空格等特殊字符，所以用双引号引起来以防出现意外&lt;/p>
&lt;ul>
&lt;li>**FileTestOperator # **所有选项检查前提都是含有隐含意义，就是默认先检查是否存在再检查其余特殊情况
&lt;ul>
&lt;li>-e # 检查文件是否存在&lt;/li>
&lt;li>-d # 检查文件是否存在且为目录&lt;/li>
&lt;li>-f # 检查是否为文件&lt;/li>
&lt;li>-n # 是否为数字&lt;/li>
&lt;li>-r(w)(x) # 检查是否可读(写)(执行)&lt;/li>
&lt;li>-s # 检查是否为空&lt;/li>
&lt;li>-O # 是否属于当前用户&lt;/li>
&lt;li>-G # 是否默认组与当前用户相同&lt;/li>
&lt;li>[ FILE1 -nt FILE ] 检查文件 1 是否新于文件 2&lt;/li>
&lt;li>[ FILE1 -ot FILE2 ] 检查文件 1 是否旧于文件 2&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>EXAMPLE
&lt;ul>
&lt;li>if [ ! -f file.txt ] #如果 file.txt 存在且为文件&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h1 id="heading">&lt;/h1></description></item></channel></rss>