<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>断念梦 – 📄1.操作系统</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/</link><description>Recent content in 📄1.操作系统 on 断念梦</description><generator>Hugo -- gohugo.io</generator><atom:link href="https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/index.xml" rel="self" type="application/rss+xml"/><item><title>Docs: 0_操作系统</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/0_%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/0_%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Operating_system">Wiki.Operating System&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://ebook.hep.com.cn/ebooks/index.html#/read?id=693031822086377472">高教书苑,操作系统原理(2020 年版)-全国计算机等级考试四级教程&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://ebook.hep.com.cn/ebooks/index.html#/read?id=685438574224478208">高教书苑,操作系统原理与实训教程(第 3 版)&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://mp.weixin.qq.com/s/sEv8_o2FABGVtULOGUv3ZQ">公众号-码农的荒岛求生，没有操作系统，程序可以运行起来吗？&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>&lt;strong>Operating System(操作系统，简称 OS)&lt;/strong> 是一个&lt;a href="https://en.wikipedia.org/wiki/System_software">系统软件&lt;/a>，由很多程序模块组成，用以组织计算机的工作流程、有效得控制和管理计算机系统的各类(软件/硬件)资源，并向用户提供各种服务功能(操作接口)，使用户能够灵活、方便、有效地使用计算机。&lt;/p>
&lt;p>白话说，&lt;strong>OS 是计算机系统的&lt;/strong>&lt;code>**管家**&lt;/code>&lt;strong>，是硬件最亲密的&lt;/strong>&lt;code>**伙伴**&lt;/code>&lt;strong>，是人机之间的&lt;/strong>&lt;code>**桥梁**&lt;/code>&lt;strong>，是其他应用软件的&lt;/strong>&lt;code>**基石**&lt;/code>&lt;strong>。&lt;/strong>&lt;/p>
&lt;p>计算机起初是为了代替人类计算产生的，一台设备只能执行一个程序。如果一台计算机上需要同时运行三个程序，那么会有如下问题产生：&lt;/p>
&lt;ol>
&lt;li>三道程序在内存中如何存放？&lt;/li>
&lt;li>什么时候让某个程序占用 CPU？&lt;/li>
&lt;li>怎样有序地输出各个程序的运算结果？&lt;/li>
&lt;/ol>
&lt;p>对这些问题的解决都必须求助于操作系统。也就是说操作系统必须对内存进行管理，对 CPU 进行管理，对外设机型管理，对存放在磁盘上的文件更是要精心组织和管理。不仅如此，操作系统对这些资源进行管理的基础上，还要给用户提供良好的接口，以便用户可能在某种程度上使用或者操纵这些资源。因此，从操作系统设计者的角度考虑，一个操作系统必须包含以下几个部分&lt;/p>
&lt;ol>
&lt;li>操作系统接口&lt;/li>
&lt;li>CPU 管理&lt;/li>
&lt;li>内存管理&lt;/li>
&lt;li>设备管理&lt;/li>
&lt;li>文件管理&lt;/li>
&lt;/ol>
&lt;p>操作系统就是一个大型的软件而已，与运行在操作系统之上的各种程序基本一样。&lt;/p>
&lt;ol>
&lt;li>操作系统=内核+系统程序&lt;/li>
&lt;li>系统程序=编译环境+API(应用程序接口)+AUI(用户接口)&lt;/li>
&lt;li>编译环境=编译程序+连接程序+装载程序&lt;/li>
&lt;li>API=系统调用+语言库函数(C、C++、Java 等)&lt;/li>
&lt;li>AUI=shell+系统服务例程+应用程序(浏览器、字处理、编辑器等)&lt;/li>
&lt;/ol>
&lt;p>一个名为 test 程序执行的简单过程：&lt;/p>
&lt;ol>
&lt;li>用户通过交互界面(shell)告诉操作系统执行 test 程序&lt;/li>
&lt;li>操作系统通过文件名在磁盘找到该程序&lt;/li>
&lt;li>检查可执行代码首部，找出代码和数据存放的地址&lt;/li>
&lt;li>文件系统找到第一个磁盘块&lt;/li>
&lt;li>操作系统建立程序的执行环境&lt;/li>
&lt;li>操作系统把程序从磁盘装入内存，并跳到程序开始出执行&lt;/li>
&lt;li>操作系统检查字符串的位置是否正确&lt;/li>
&lt;li>操作系统找到字符串被送往的设备&lt;/li>
&lt;li>操作系统将字符串送往输出设备窗口系统确定这是一个合法的操作，然后将字符串转换成像素&lt;/li>
&lt;li>窗口系统将像素写入存储映像区&lt;/li>
&lt;li>视频硬件将像素表示转换成一组模拟信号控制显示器&lt;/li>
&lt;li>显示器发射电子束，最后在屏幕上看到程序执行的结果。&lt;/li>
&lt;/ol>
&lt;p>Linux 系统结构详解
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/nm71yz/1616168594662-a90f0c59-7c9b-49ee-ba91-d7065227bfcd.png" alt="">&lt;/p>
&lt;p>Linux 系统一般有 4 个主要部分：&lt;/p>
&lt;ol>
&lt;li>内核&lt;/li>
&lt;li>shell、进程&lt;/li>
&lt;li>文件系统&lt;/li>
&lt;li>应用程序。&lt;/li>
&lt;/ol>
&lt;p>内核、shell 和文件系统一起形成了基本的操作系统结构，它们使得用户可以运行程序、管理文件并使用系统。部分层次结构&lt;/p>
&lt;h1 id="操作系统分类">操作系统分类&lt;/h1>
&lt;p>对 OS 进行分类的方法有很多，从不同的角度可以得到不同的划分。&lt;/p>
&lt;h2 id="按照计算机硬件和结构与规模分类">按照计算机硬件和结构与规模分类&lt;/h2>
&lt;ul>
&lt;li>大型机操作系统&lt;/li>
&lt;li>中型机操作系统&lt;/li>
&lt;li>小型机操作系统&lt;/li>
&lt;li>微型机操作系统&lt;/li>
&lt;li>&lt;strong>(Networking)网络&lt;/strong> 操作系统&lt;/li>
&lt;li>&lt;strong>(Embedded)嵌入式&lt;/strong> 操作系统&lt;/li>
&lt;li>等等&lt;/li>
&lt;/ul>
&lt;h2 id="按照系统所能同时响应的用户与任务分类">按照系统所能同时响应的用户与任务分类&lt;/h2>
&lt;ul>
&lt;li>&lt;strong>(Single-user/Multi-user)单用户 或 多用户&lt;/strong> 操作系统
&lt;ul>
&lt;li>单用户操作系统不具有区分用户的功能，但可以允许多个程序串联运行。&lt;a href="https://en.wikipedia.org/wiki/Operating_system#cite_note-8">[8]&lt;/a>阿&lt;a href="https://en.wikipedia.org/wiki/Multi-user">多用户&lt;/a>操作系统延伸的与设施识别过程和资源，例如磁盘空间，属于多个用户的多任务处理的基本概念，并且该系统允许多个用户在同一时间与系统进行交互。分时操作系统调度任务以有效使用系统，并且还可以包括用于将处理器时间，大容量存储，打印和其他资源的成本分配给多个用户的计费软件。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>(Single-tasking/Multi-tasking)单任务 或 多任务&lt;/strong> 操作系统
&lt;ul>
&lt;li>单任务系统一次只能运行一个程序，而&lt;a href="https://en.wikipedia.org/wiki/Computer_multitasking">多任务&lt;/a>操作系统允许&lt;a href="https://en.wikipedia.org/wiki/Concurrent_computing">并发&lt;/a>运行多个程序。这是通过 &lt;strong>Time-shring(&lt;/strong>&lt;a href="https://en.wikipedia.org/wiki/Time-sharing">&lt;strong>分时&lt;/strong>&lt;/a>&lt;strong>) &lt;strong>实现的，其中可用的处理器时间在多个进程之间分配。这些进程每个都在一个 &lt;strong>time slices(&lt;/strong>&lt;a href="https://en.wikipedia.org/wiki/Time_slice">&lt;strong>时间片&lt;/strong>&lt;/a>&lt;/strong>)&lt;/strong> 中被操作系统的任务计划子系统反复中断。多任务可以以抢占式和合作式为特征。在&lt;a href="https://en.wikipedia.org/wiki/Preemption_(computing)">抢占式&lt;/a>多任务处理中，操作系统会减少&lt;a href="https://en.wikipedia.org/wiki/Central_processing_unit">CPU&lt;/a>时间，并为每个程序分配一个插槽。&lt;a href="https://en.wikipedia.org/wiki/Unix-like">类似于 Unix 的&lt;/a> 操作系统，例如 &lt;a href="https://en.wikipedia.org/wiki/Solaris_(operating_system)">Solaris&lt;/a> 和&lt;a href="https://en.wikipedia.org/wiki/Linux">Linux&lt;/a> 以及非 Unix 操作系统(例如&lt;a href="https://en.wikipedia.org/wiki/AmigaOS">AmigaOS)均&lt;/a>支持抢占式多任务处理。通过依靠每个过程以定义的方式向其他过程提供时间来实现协作式多任务处理。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>通过 用户 和 任务 的组合，可以组合出三种：单用户单任务、单用户多任务、多用户多任务。&lt;/p>
&lt;h2 id="按照系统处理任务的方式分类更加广泛的分类">按照系统处理任务的方式分类(更加广泛的分类)&lt;/h2>
&lt;ul>
&lt;li>&lt;strong>多道批处理&lt;/strong>操作系统 #&lt;/li>
&lt;li>**(Time-shring)分时 **操作系统 #
&lt;ul>
&lt;li>UNIX&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>**(Real-time)实时 **操作系统 #&lt;/li>
&lt;li>**(Distributed)分布式 **操作系统 #&lt;/li>
&lt;li>等等&lt;/li>
&lt;/ul>
&lt;h2 id="其他分类">其他分类&lt;/h2>
&lt;ul>
&lt;li>个人操作系统&lt;/li>
&lt;li>等等&lt;/li>
&lt;/ul>
&lt;h1 id="发展史">发展史&lt;/h1>
&lt;p>&lt;a href="https://en.wikipedia.org/wiki/CP/M">CP/M&lt;/a> 第一个微型机的操作系统&lt;/p>
&lt;h1 id="查看操作系统信息">查看操作系统信息&lt;/h1>
&lt;p>&lt;strong>/etc/os-release&lt;/strong>
&lt;strong>/etc/issue&lt;/strong>&lt;/p></description></item><item><title>Docs: 1.Bootloader</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/1.bootloader/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/1.bootloader/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Bootloader">Wiki,Bootloader&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>&lt;strong>Bootloader(引导加载程序)&lt;/strong> 是负责 &lt;a href="https://en.wikipedia.org/wiki/Booting">booting(引导)&lt;/a> 计算器的软件。通常也被称为 Bootstrap Loader、Bootstrap。&lt;/p>
&lt;p>当计算机关闭时，操作系统、应用程序代码和数据 ‍‌ 仍存储在非易失性存储器中。当计算机开机时，它通常没有操作系统或其随机存取存储器 (RAM) 中的加载程序。计算机首先执行存储在只读存储器（ROM，以及后来的 EEPROM、NOR 闪存）中的相对较小的程序以及一些需要的数据，以初始化 RAM（特别是在 x86 系统上），访问非易失性设备（通常是块设备，例如 NAND 闪存）或可以将操作系统程序和数据加载到 RAM 中的设备。&lt;/p>
&lt;h1 id="配置">配置&lt;/h1>
&lt;p>&lt;strong>/boot/*&lt;/strong> # 所有关于系统引导启动的配置信息，都在该目录下
&lt;strong>/boot/grub2/*&lt;/strong> #
&lt;strong>/etc/default/grub&lt;/strong> #&lt;/p>
&lt;h1 id="引导管理命令行工具">引导管理命令行工具&lt;/h1>
&lt;p>grub2-*
grubby
grub2-mkconfig&lt;/p></description></item><item><title>Docs: 2.Kernel(内核)</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2.kernel%E5%86%85%E6%A0%B8/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2.kernel%E5%86%85%E6%A0%B8/</guid><description>
&lt;h2 id="操作系统-os-与内核-kernel-有什么区别">操作系统 OS 与内核 Kernel 有什么区别？&lt;/h2>
&lt;p>原文链接：&lt;a href="https://mp.weixin.qq.com/s/-5tDn2-IS6Xo6DwQJN4c3Q">https://mp.weixin.qq.com/s/-5tDn2-IS6Xo6DwQJN4c3Q&lt;/a>&lt;/p>
&lt;p>&lt;strong>通用底盘技术&lt;/strong>
Canoo 公司有一项核心技术专利，这就是它们的通用电动底盘技术，长得是这个样子，非常像一个滑板：
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/egzxwb/1624588718457-99ed8a8e-d53b-465e-8d99-4345935ad5a4.webp" alt="">
这个带轮子、有电池、能动的滑板已经包含了一辆车&lt;strong>最核心&lt;/strong>的组件，差的就是一个外壳。这个看起来像滑板的东西就是所谓的电池系统和底盘一体化技术，Canoo 公司在它们的通用底盘上加装不同的外壳就能制造出不同的车型。
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/egzxwb/1624588718511-01fe725d-cd0d-48d1-a4e8-1010d7d5a69b.png" alt="">&lt;/p>
&lt;h5 id="什么是内核">&lt;strong>什么是内核？&lt;/strong>&lt;/h5>
&lt;p>在上面这个示例中，&lt;strong>包含轮子以及电池系统的底盘就好比内核，而套上外壳加上椅子以及内饰后的整体成品就好比操作系统&lt;/strong>。内核仅仅是操作系统的一部分，是真正与硬件交互的那部分软件，与硬件交互包括读写硬盘、读写网盘、读写内存以及任何连接到系统中的硬件。除了与硬件交互外，内核还负责分配资源，分配什么资源呢？所谓资源就是硬件，比如 CPU 时间、内存、IO 等等，这些都是资源。&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/egzxwb/1624588718454-36e25783-bbc0-49ec-a620-26d8580cee9d.png" alt="">因此，内核的职责就是以进程的形式来分配 CPU 时间，以虚拟内存的形式来分配物理内存，以文件的形式来管理 IO 设备。&lt;/p>
&lt;h5 id="什么是操作系统">&lt;strong>什么是操作系统？&lt;/strong>&lt;/h5>
&lt;p>然而只有一个内核实际上是做不了什么真正有用的事情，就像上面示例中那个通用底盘一样，这个底盘确实能跑起来，但你没办法开着这样一个底盘出去浪，因为这个底盘很难用。因此，你不得不加装上方向盘、座椅以及车身外壳等，同样的道理，内核是给人用的，为了与内核交互，发明了命令行以及图形界面 GUI。&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/egzxwb/1624588718509-9945a71c-556e-4b5a-be9f-8a123c68473c.png" alt="">在 Windows 平台就是给程序员提供编程接口的是 Windows API，这层 API 包罗万象，不但包括上文提到对系统调用的封装，还包括其它功能，像创建带有图形界面的应用程序等等。&lt;strong>但在 Linux 世界你找不到一种类似 Windows API 的东西&lt;/strong>，毕竟 Windows 是微软自家产品，什么都可以打包起来，Linux 只是一个开源的内核，如果一定要找一个类似的东西话那就是 libc，也就是 C 标准库，这里同样包括了对系统调用的封装以及一些库函数，但 libc 不包含创建带有图形界面应用程序的功能。现在我们知道了，操作系统需要提供两种接口：&lt;/p>
&lt;ul>
&lt;li>给用户提供操作接口。&lt;/li>
&lt;li>给程序员提供编程接口。&lt;/li>
&lt;/ul>
&lt;p>这些就是好比汽车的外壳，我们(用户和程序员)看得见摸得着，外壳加上底盘——也就是内核，才是功能完善的操作系统。&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/egzxwb/1624588718491-8aabc98e-8938-4b52-95fd-265d5f7d95b8.webp" alt="">&lt;/p>
&lt;h5 id="各种各样的操作系统">&lt;strong>各种各样的操作系统&lt;/strong>&lt;/h5>
&lt;p>实际上我们熟悉的 Linux 只是内核而不能称得上是操作系统，Ubuntu 则可以认为是操作系统，其内核是 Linux；RedHat 也是操作系统，其内核同样是 Linux；我们可以看到，尽管 Ubuntu 和 RedHat 是不同的操作系统，但其内核可以是相同的。这就好比它们可以基于同样的底盘打造出不同的车型。而我们熟悉的 Windows 也是操作系统，其内核是 Windows NT 内核。&lt;/p>
&lt;h5 id="总结">&lt;strong>总结&lt;/strong>&lt;/h5>
&lt;p>内核就像本文开头提到的电动底盘，包含了一个汽车的最核心元素；但这样一个底盘并没有什么实际用处，当搭配上外壳以及座椅后才是一辆真正有用的车，这就好比操作系统。值得注意的是，不同的操作系统可以有相同的内核。&lt;/p>
&lt;h1 id="宏内核与微内核">宏内核与微内核&lt;/h1>
&lt;p>原文链接：&lt;a href="https://mp.weixin.qq.com/s/jIuLkapBssGnBn1IoIdWQQ">公众号-码农的荒岛求生，操作系统的实现：什么是宏内核、微内核&lt;/a>&lt;/p>
&lt;h2 id="大一统全部运行在内核态">大一统，全部运行在内核态&lt;/h2>
&lt;p>&lt;strong>最简单的划分就是没有划分&lt;/strong>，我们可以把所有内核代码放在内核态，内核中的任何代码都拥有控制硬件的全部特权，显然这种设计方法非常简单，因为操作系统设计者不用费心去想哪一部分该放在内核态。&lt;/p>
&lt;p>由于全部内核程序都运行在内核态，编译好的内核程序就是一个单独的二进制可执行文件，这时的操作系统运行起来后就是一个大进程，所有内核代码运行在一个单独的地址空间中，这和我们实现的稍微复杂的单进程应用程序类似，这种大一统的设计就是所谓的宏内核，monolithic kernel，个人认为叫“一体化内核”更形象些。&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/egzxwb/1650439475125-4fe94b34-90ba-43d8-8a9b-3c5860730e20.png" alt="">&lt;/p>
&lt;p>这种组织方式和 TCP/IP 协议栈的分层实现有点类似。&lt;/p>
&lt;p>现在内核代码已经组织好了，毕竟内核是为上层应用提供服务的，那么上层应用该怎样调用内核代码呢？这就是系统调用的作用，system call。&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/egzxwb/1650439474086-a1f789d1-05e4-4c7c-9c39-d6274ac2b0aa.png" alt="">&lt;/p>
&lt;p>上层应用程序通过系统调用与内核进行交互。&lt;/p>
&lt;p>由于内核代码唯一同一个地址空间中，因此内核中各部分的交互极为简单，就是普通的函数调用，文件系统中的某块 cache 可以非常容易的被虚拟内存系统共享使用。&lt;/p>
&lt;p>但宏内核也是有缺点的，由于内核代码位于同一个地址空间，代码趋于复杂化，复杂就容易出错，但内核和普通程序不同，一旦内核中某一模块出现 bug 将导致整个内核崩溃，底层的内核崩溃后上层的应用程序就无法继续正常推进，整个系统就下图一样。。crash&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/egzxwb/1650439474129-b3976f1b-3567-4d8a-b82d-2e5fd9e647cd.gif" alt="">&lt;/p>
&lt;p>当然也有人不在乎在这一点，Linus 认为内核中有 bug 正常，&lt;strong>有 bug 就找到它、修复它而不是用某种机制试图忽略它&lt;/strong>，没错，C++中的异常就是试图忽略 bug 的机制，这就是为什么很多公司的规范中禁止使用异常的原因。&lt;/p>
&lt;p>总之，内核崩溃后就必须重启计算机。&lt;/p>
&lt;h4 id="heading">&lt;/h4>
&lt;h2 id="保留核心非必要不留在内核">保留核心，非必要不留在内核&lt;/h2>
&lt;p>为减少内核崩溃的风险，一个简单的办法就是让内核尽量精简，只保留核心部分运行在内核态，其它代码以用户态进程的形式运行，就像这样：&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/egzxwb/1650439474079-a7429422-8348-4fe1-b423-79e30fe7763d.png" alt="">&lt;/p>
&lt;p>运行在用户态的操作系统程序被称为 server，像负责文件操作的 File Server 等，此时用户进程想要使用操作系统提供的服务的话就必须借助进程间通信，inter-process communication，即 IPC，借助内核，消息从一个进程发送到另一个进程然后等待返回。&lt;/p>
&lt;p>这样，内核只需要对上层应用提供一些简单的接口即可，像创建进程、发送消息等，这种实现方式可以让内核尽可能简单，因为大部分内核程序都运行在用户态，且运行在不同的地址空间中，此时设备驱动中的 bug 不会影响到内核，这种操作系统的实现方式就被称为微内核， micro kernel。&lt;/p>
&lt;p>就像宏内核那样，微内核也有自己的缺点，那就是性能。由于宏内核的代码都在同一个地址空间中，因此模块间的交互可以非常简单，简单的函数调用即可，但模块间交互对微内核来说则可能涉及进程间通信，看上图，如果某个应用程序需要请求使用 File Server，这条链路涉及到：&lt;/p>
&lt;pre>&lt;code>请求：应用程序 -&amp;gt; 内核 -&amp;gt; File server
返回：Filer server -&amp;gt; 内核 -&amp;gt; 应用程序
&lt;/code>&lt;/pre>
&lt;p>每一个&amp;quot;-&amp;gt;&amp;ldquo;都涉及上下文切换，而这对宏内核来说则简单很多。&lt;/p>
&lt;h4 id="heading-1">&lt;/h4>
&lt;p>&lt;strong>现实中是什么样子？&lt;/strong>&lt;/p>
&lt;p>现实的操作系统中两种实现方式都很常见，Linux 以及许多 Unix 就是典型的宏内核，而 Mac OS X 以及 Windows NT 则一般认为是微内核，华为的鸿蒙 Harmony OS 则宣传是微内核。&lt;/p></description></item><item><title>Docs: 3.Systemd 系统守护程序</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/3.systemd-%E7%B3%BB%E7%BB%9F%E5%AE%88%E6%8A%A4%E7%A8%8B%E5%BA%8F/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/3.systemd-%E7%B3%BB%E7%BB%9F%E5%AE%88%E6%8A%A4%E7%A8%8B%E5%BA%8F/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://github.com/systemd/systemd">GitHub 项目&lt;/a>&lt;/li>
&lt;li>&lt;a href="http://www.jinbuguo.com/systemd/systemd.index.html">Systemd 中文手册,金步国&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://man.cx/systemd">Manual(手册),systemd&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>&lt;strong>System daemon(系统守护进程，简称 systemd)&lt;/strong> 实质上：启动一个服务，就是启动一个程序，可以给该程序添加一些参数，也可以不添加，该程序的可执行文件一般是放在 /usr/lib/systemd/system/ 目录下的&lt;/p>
&lt;p>历史上，Linux 的启动一直采用 init 进程。这种命令 &lt;code>/etc/init.d/apache2 start 或者 service apache2 start&lt;/code>，就是用来启动服务。&lt;/p>
&lt;p>这种方法有两个缺点。&lt;/p>
&lt;ol>
&lt;li>启动时间长。init 进程是串行启动，只有前一个进程启动完，才会启动下一个进程。&lt;/li>
&lt;li>启动脚本复杂。init 进程只是执行启动脚本，不管其他事情。脚本需要自己处理各种情况，这往往使得脚本变得很长。&lt;/li>
&lt;/ol>
&lt;p>Systemd 就是为了解决这些问题而诞生的。它的设计目标是，为系统的启动和管理提供一套完整的解决方案。&lt;/p>
&lt;p>根据 Linux 惯例，字母 d 是 daemon(守护进程) 的缩写。 Systemd 这个名字的含义，就是它要守护整个系统。&lt;/p>
&lt;p>使用了 Systemd，就不需要再用 init 了。Systemd 取代了 initd，成为系统的第一个进程(PID 等于 1)，其他进程都是它的子进程。&lt;/p>
&lt;p>Systemd 的优点是功能强大，使用方便，缺点是体系庞大，非常复杂。事实上，现在还有很多人反对使用 Systemd，理由就是它过于复杂，与操作系统的其他部分强耦合，违反&amp;quot;keep simple, keep stupid&amp;quot;的 Unix 哲学。&lt;/p>
&lt;p>注意：Systemd 启动的程序无法获取 shell 中的变量，需要通过在 Unit 的配置文件中设置环境变量。&lt;/p>
&lt;h2 id="unit单元">Unit(单元)&lt;/h2>
&lt;p>Systemd 将各种操作系统启动和运行的相关对象，抽象多种类型的 &lt;strong>Units(单元)&lt;/strong>，并且提供了 Units 之间的依赖关系。&lt;strong>大多数 Units 是通过 Unit File(单元文件) 创建的&lt;/strong>，没有 Unit File，也就不会存在所谓的 Units。&lt;strong>可以这么说，在特定目录创建了一个符合 Unit File 格式的文件，也就创建了一个 Unit&lt;/strong>。&lt;/p>
&lt;blockquote>
&lt;p>单元：比如以前上学总说：第一单元、第二单元，这种理解&lt;/p>
&lt;/blockquote>
&lt;p>现阶段有如下几种 Units：&lt;/p>
&lt;ol>
&lt;li>&lt;strong>Automoount unit&lt;/strong> # 自动挂载点&lt;/li>
&lt;li>&lt;strong>Device unit&lt;/strong> # 硬件设备&lt;/li>
&lt;li>&lt;strong>Mount unit&lt;/strong> # 文件系统挂载点&lt;/li>
&lt;li>&lt;strong>Path unit&lt;/strong> # 文件或路径&lt;/li>
&lt;li>&lt;strong>Scope unit&lt;/strong> # 与 Service unit 类似，但是由 systemd 根据 D-bus 接口接收到的信息自动创建， 可用于管理外部创建的进程。&lt;/li>
&lt;li>&lt;strong>Service unit&lt;/strong> # 用于启动和控制守护进程以及他们所包含的进程&lt;/li>
&lt;li>&lt;strong>Slice unit&lt;/strong> # 用于控制特定 CGroup 内(例如一组 service 与 scope 单元)所有进程的总体资源占用。&lt;/li>
&lt;li>&lt;strong>Socket nuit&lt;/strong> # 进程间通信的 socket&lt;/li>
&lt;li>&lt;strong>Swap unit&lt;/strong> # 关于 swap 文件&lt;/li>
&lt;li>&lt;strong>Target nuit&lt;/strong> # 是一群 Unit 的集合&lt;/li>
&lt;li>&lt;strong>Timer unit&lt;/strong> # 定时器&lt;/li>
&lt;/ol>
&lt;p>&lt;strong>Unit 的名称&lt;/strong>。Unit 的名称由 Unit File 的名称决定。比如一个 crond.service 文件，将会创建出来一个类型为 Service，名为 crond.service 的 Unit。
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/glcff3/1616167393721-79076d3b-2c04-48e9-a4a0-8ee4bfb69284.jpeg" alt="">
&lt;strong>Unit 的依赖&lt;/strong>。Systemd 能够处理 Units 之间的依赖关系，通过依赖关系，我们可以确定 Unit 之间启动的先后顺序、以及 Unit 之间是否可以同时运行。
&lt;strong>Unit 的状态&lt;/strong>。 Unit 既可以处于活动(active)状态也可以处于停止(inactive)状态， 当然也可以处于启动中(activating)或停止中(deactivating)的状态。 还有一个特殊的失败(failed)状态， 意思是单元以某种方式失败了 (退出时返回了错误代码、进程崩溃、操作超时、触碰启动频率限制)。 当进入失败(failed)状态时， 导致故障的原因 将被记录到日志中以方便日后排查。 需要注意的是， 不同的单元可能还会有各自不同的&amp;quot;子状态&amp;quot;， 但它们都被映射到上述五种状态之一。通过 &lt;code>systemctl list-units --all&lt;/code> 命令可以查看每个 Unit 的状态。&lt;/p>
&lt;h1 id="systemd-配置">Systemd 配置&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>man 手册：&lt;a href="https://man7.org/linux/man-pages/man5/systemd-system.conf.5.html">https://man7.org/linux/man-pages/man5/systemd-system.conf.5.html&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>&lt;strong>/etc/systemd/*&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>**./system.conf **# Systemd 程序运行时配置文件&lt;/li>
&lt;li>**./system.conf.d/*.conf **# Systemd 程序运行时配置文件&lt;/li>
&lt;li>&lt;strong>./user.conf&lt;/strong> # Systemd 以普通用户身份运行时的配置文件&lt;/li>
&lt;li>&lt;strong>./user.conf.d/*.conf&lt;/strong> # Systemd 以普通用户身份运行时的配置文件&lt;/li>
&lt;/ul>
&lt;p>**/run/systemd/* **#&lt;/p>
&lt;ul>
&lt;li>&lt;strong>./system.conf.d/*.conf&lt;/strong> # Systemd 程序运行时配置文件&lt;/li>
&lt;li>&lt;strong>./user.conf.d/*.conf&lt;/strong> # Systemd 以普通用户身份运行时的配置文件&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>/usr/lib/systemd/*&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>&lt;strong>./system.conf.d/*.conf&lt;/strong> # Systemd 程序运行时配置文件&lt;/li>
&lt;li>&lt;strong>./user.conf.d/*.conf&lt;/strong> # Systemd 以普通用户身份运行时的配置文件&lt;/li>
&lt;/ul>
&lt;p>/etc、/run、/usr/lib 这三个目录的优先级从左至右由高到低。Systemd 会从最低优先级的目录 /usr/lib/_ 下开始加载配置，注意加载其中的文件，直到最高优先级的目录 /etc/systemd/_ 为止。&lt;/p>
&lt;h2 id="units-配置">Units 配置&lt;/h2>
&lt;p>Units 配置就是指 Unit File。Systemd 会从多个目录中加载 Unit File，以生成 Unit。下面列出的路径，优先级从上往下越来越低。也就是说，高优先级目录中的文件，将会覆盖低优先级目录中的同名文件。不同的 Systemd 运行方式，加载 Unit File 的路径不同。&lt;/p>
&lt;h3 id="使用---system-参数以系统实例运行-systemd">使用 &amp;ndash;system 参数，以系统实例运行 systemd&lt;/h3>
&lt;p>通过 pkg-config systemd &amp;ndash;variable=systemdsystemunitdir** &lt;strong>命令可以查看包管理器安装完程序后，生成 Unit File 的目录
通过 pkg-config systemd &amp;ndash;variable=systemdsystemconfdir&lt;/strong> **命令可以查看优先级最高的存放 Unit File 的目录&lt;/p>
&lt;ul>
&lt;li>&lt;strong>/etc/systemd/system.control&lt;/strong> # 通过 dbus API 创建的永久系统单元&lt;/li>
&lt;li>&lt;strong>/run/systemd/system.control&lt;/strong> # 通过 dbus API 创建的临时系统单元&lt;/li>
&lt;li>&lt;strong>/run/systemd/transient&lt;/strong> # 动态配置的临时单元(系统与全局用户共用)&lt;/li>
&lt;li>&lt;strong>/run/systemd/generator.early&lt;/strong> # 生成的高优先级单元(系统与全局用户共用)(参见 systemd.generator(7) 手册中对 early-dir 的说明)&lt;/li>
&lt;li>&lt;strong>/etc/systemd/system/*&lt;/strong> # 人类根据需求，手动创建的 Unit File 所在路径。且当使用 systemctl enable UNIT 命令的时候，会自动在该目录中创建软连接到 /usr/lib/systemd/system/ 目录中的 Unit File
&lt;ul>
&lt;li>./UnitFileName.d/*.conf # 嵌入式单元文件 存放路径&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>/run/systemd/system/*&lt;/strong> # 程序运行时自动生成的 Unit File 所在路径。
&lt;ul>
&lt;li>./UnitFileName.d/*.conf # 嵌入式单元文件 存放路径&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>/run/systemd/generator&lt;/strong> # 生成的中优先级系统单元(参见 systemd.generator(7) 手册中对 normal-dir 的说明)&lt;/li>
&lt;li>&lt;strong>/usr/local/lib/systemd/system&lt;/strong> # 本地软件包安装的系统单元&lt;/li>
&lt;li>&lt;strong>/usr/lib/systemd/system/*&lt;/strong> # 通过系统的包管理器安装程序时，生成的 Unit File 所在路径。
&lt;ul>
&lt;li>./UnitFileName.d/*.conf # 嵌入式单元文件 存放路径&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>/run/systemd/generator.late&lt;/strong> # 生成的低优先级系统单元(参见 systemd.generator(7) 手册中对 late-dir 的说明)&lt;/li>
&lt;/ul>
&lt;h3 id="使用---user-参数以用户实例运行-systemd">使用 &amp;ndash;user 参数，以用户实例运行 systemd&lt;/h3>
&lt;ul>
&lt;li>&lt;strong>$XDG_CONFIG_HOME/systemd/user.control 或 ~/.config/systemd/user.control&lt;/strong> # 通过 dbus API 创建的永久私有用户单元(仅在未设置 $XDG_CONFIG_HOME 时才使用 ~/.config 来替代)&lt;/li>
&lt;li>$XDG_RUNTIME_DIR/systemd/user.control # 通过 dbus API 创建的临时私有用户单元&lt;/li>
&lt;li>/run/systemd/transient 动态配置的临时单元(系统与全局用户共用)&lt;/li>
&lt;li>/run/systemd/generator.early 生成的高优先级单元(系统与全局用户共用)(参见 systemd.generator(7) 手册中对 early-dir 的说明)&lt;/li>
&lt;li>$XDG_CONFIG_HOME/systemd/user 或 $HOME/.config/systemd/user 用户配置的私有用户单元(仅在未设置 $XDG_CONFIG_HOME 时才使用 ~/.config 来替代)&lt;/li>
&lt;li>/etc/systemd/user 本地配置的全局用户单元&lt;/li>
&lt;li>$XDG_RUNTIME_DIR/systemd/user 运行时配置的私有用户单元(仅当 $XDG_RUNTIME_DIR 已被设置时有效)&lt;/li>
&lt;li>/run/systemd/user 运行时配置的全局用户单元&lt;/li>
&lt;li>$XDG_RUNTIME_DIR/systemd/generator 生成的中优先级私有用户单元(参见 systemd.generator(7) 手册中对 normal-dir 的说明)&lt;/li>
&lt;li>$XDG_DATA_HOME/systemd/user 或 $HOME/.local/share/systemd/user 软件包安装在用户家目录中的私有用户单元(仅在未设置 $XDG_DATA_HOME 时才使用 ~/.local/share 来替代)&lt;/li>
&lt;li>$dir/systemd/user(对应 $XDG_DATA_DIRS 中的每一个目录($dir)) 额外安装的全局用户单元，对应 $XDG_DATA_DIRS(默认值=&amp;quot;/usr/local/share/:/usr/share/&amp;quot;) 中的每一个目录。&lt;/li>
&lt;li>/usr/local/lib/systemd/user 本地软件包安装的全局用户单元&lt;/li>
&lt;li>/usr/lib/systemd/user 发行版软件包安装的全局用户单元&lt;/li>
&lt;li>$XDG_RUNTIME_DIR/systemd/generator.late 生成的低优先级私有用户单元(参见 systemd.generator(7) 手册中对 late-dir 的说明)&lt;/li>
&lt;/ul>
&lt;p>可以使用环境变量来 扩充或更改 systemd 用户实例(&lt;code>--user&lt;/code>)的单元文件加载路径。 环境变量可以通过环境变量生成器(详见 &lt;a href="http://www.jinbuguo.com/systemd/systemd.environment-generator.html#">systemd.environment-generator(7)&lt;/a> 手册)来设置。特别地， &lt;code>$XDG_DATA_HOME&lt;/code> 与 &lt;code>$XDG_DATA_DIRS&lt;/code> 可以方便的通过 &lt;a href="http://www.jinbuguo.com/systemd/systemd-environment-d-generator.html#">systemd-environment-d-generator(8)&lt;/a> 来设置。这样，上表中列出的单元目录正好就是默认值。 要查看实际使用的、基于编译选项与当前环境变量的单元目录列表，可以使用 &lt;code>systemd-analyze --user unit-paths&lt;/code>&lt;/p>
&lt;p>此外，还可以通过 &lt;a href="http://www.jinbuguo.com/systemd/systemctl.html#">systemctl(1)&lt;/a> 的 &lt;strong>link&lt;/strong> 命令 向上述单元目录中添加额外的单元(不在上述常规单元目录中的单元)。&lt;/p></description></item><item><title>Docs: 4.Terminal 与 Shell</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/4.terminal-%E4%B8%8E-shell/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/4.terminal-%E4%B8%8E-shell/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Shell_(computing)">Wiki,Shell&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.man7.org/linux/man-pages/man1/bash.1.html">Manual(手册),bash&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://blog.csdn.net/kangkanglou/article/details/82698177">https://blog.csdn.net/kangkanglou/article/details/82698177&lt;/a>&lt;/li>
&lt;li>&lt;a href="http://feihu.me/blog/2014/env-problem-when-ssh-executing-command-on-remote/">http://feihu.me/blog/2014/env-problem-when-ssh-executing-command-on-remote/&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.jianshu.com/p/0c7ea235b473">https://www.jianshu.com/p/0c7ea235b473&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://mp.weixin.qq.com/s/RxpcqBGhUT-5z4N5kRXvBg">公众号，阿里技术-一种命令行解析的新思路&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>**Shell(也称为壳层) **是一种计算机程序，向人类用户或其他程序公开操作系统的服务。通常，操作系统的 Shell 程序会根据计算机的角色和特定操作，分为两类：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Command-line_interface">&lt;strong>command-line interface&lt;/strong>&lt;/a>&lt;strong>(命令行界面，简称 CLI)&lt;/strong>&lt;/li>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Graphical_user_interface">&lt;strong>graphical user interface&lt;/strong>&lt;/a>&lt;strong>(图形用户界面，简称 GUI)&lt;/strong>&lt;/li>
&lt;/ul>
&lt;p>Shell 在计算机科学中指“为用户提供用户界面”的软件，通常指的是命令行界面的解析器。一般来说，这个词是指操作系统中提供访问内核所提供之服务的程序。Shell 也用于泛指所有为用户提供操作界面的程序，也就是程序和用户交互的接口。因此与之相对的是 Kernel(内核)，内核不提供和用户的交互功能。&lt;/p>
&lt;p>用白话讲：人类操作计算机的地方就是 Shell ，可以是一个输入命令的地方(CLI)，也可以是一个用户用鼠标点点点的图形界面(GUI)。Shell 也是一类程序的统称，实际上，当输入完用户名和密码登录系统的时候，就是 Linux 系统后台自动启动了一个名叫 Bash 的 Shell 程序，来让用户输入指令对计算机进行操作&lt;/p>
&lt;p>所以，一个 Shell 也会有一个进程号，在该 Shell 执行的程序的父进程号都是该 Shell 的进程号&lt;/p>
&lt;p>如下所示，[登录系统](/docs/IT学习笔记/1.操作系统/5.登录%20Linux%20 与%20 访问控制/5.登录%20Linux%20 与%20 访问控制.md Linux 与 访问控制.md)时，会启动一个进程标识当前登录的用户，并启动一个子进程，该子进程就是 Shell 的类型，这示例里的 Shell 为 Bash，并且会为该 Shell 分配一个&lt;a href="#c0DF2">终端&lt;/a>来与用户进行交互(这里的终端名是 tty1)&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>root &lt;span style="color:#ae81ff">1067&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span> 11:20 ? Ss 0:00 login -- root
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>root &lt;span style="color:#ae81ff">9622&lt;/span> &lt;span style="color:#ae81ff">1067&lt;/span> &lt;span style="color:#ae81ff">2&lt;/span> 13:19 tty1 Ss+ 0:00 &lt;span style="color:#ae81ff">\_&lt;/span> -bash
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>所有命令都是在这个 shell 下运行的，如下所使，在 bash 下执行了一个 cat 命令&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>root &lt;span style="color:#ae81ff">1067&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span> 11:20 ? Ss 0:00 login -- root
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>root &lt;span style="color:#ae81ff">9622&lt;/span> &lt;span style="color:#ae81ff">1067&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span> 13:19 tty1 Ss 0:00 &lt;span style="color:#ae81ff">\_&lt;/span> -bash
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>root &lt;span style="color:#ae81ff">11198&lt;/span> &lt;span style="color:#ae81ff">9622&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span> 13:22 tty1 S+ 0:00 &lt;span style="color:#ae81ff">\_&lt;/span> cat
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Note：&lt;/p>
&lt;ul>
&lt;li>有一点需要明确，系统下的任何程序运行都需要一个用户，哪怕在刚装完系统第一次启动，所有进程也是基于 root 用户来运行的，所以脱离用户讨论 shell 是不对的。&lt;/li>
&lt;li>&lt;strong>由于 linux 常用的 shell 为 bash，下面主要描述的都是关于 bash shell 的配置&lt;/strong>&lt;/li>
&lt;/ul>
&lt;h2 id="terminal终端">Terminal(终端)&lt;/h2>
&lt;blockquote>
&lt;p>参考： - &lt;a href="https://en.wikipedia.org/wiki/Computer_terminal">Wiki,Computer Terminal&lt;/a>&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Teleprinter">Wiki,TTY&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Tty_(unix)">Wiki,TTY(Unix)&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Pseudoterminal">Wiki,Psedoterminal&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Terminal_emulator">Wiki,Terminal emulator&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://askubuntu.com/questions/481906/what-does-tty-stand-for">TTY 代表什么&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://man7.org/linux/man-pages/man7/pty.7.html">Manual(手册),pty(7)&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://man7.org/linux/man-pages/man4/pts.4.html">Manual(手册),pts(4)&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>&lt;strong>Computer Terminal(计算机终端)&lt;/strong> 是一种 Electronic(电子) 或 Electromechanical(机电) 硬件设备，可用于将数据输入计算机或计算机系统，以及从计算机或计算机系统中转录数据。&lt;strong>Teletype(电传打字机，简称 TTY)&lt;/strong> 是早期硬件拷贝终端的一个例子，并且比计算机屏幕的使用早了几十年。早期的终端是廉价设备，与用于输入的打孔卡或纸带相比速度非常慢，但随着技术的改进和视频显示器的引用，终端将这些旧的交互形式推向整个行业，分时系统的发展，弥补了低效的用户打字能力，能够支持统一机器上的多个用户，每个用户都在自己的终端上操作。所以，现代我们将 &lt;strong>TTY 表示为终端&lt;/strong>，是那种最基础的终端。&lt;/p>
&lt;p>除了传统的硬件终端以外，我们还可以通过计算机程序模拟出硬件终端，这种功能称为 &lt;strong>Terminal Emulator(终端模拟器)&lt;/strong>，而很多时候也称为 &lt;strong>Psedoterminal/Pseudotty(伪终端，简称 PTY)&lt;/strong>。PTY 是一对提供双向通信通道的虚拟字符设备，通道的一端称为 master(&lt;strong>简称 PTMX&lt;/strong>)，另一端称为 slave(&lt;strong>简称 PTS&lt;/strong>)。Linux 通过 devpts 文件提供了对 PTS 功能的完整支持。&lt;/p>
&lt;p>终端也分为多种类型，有多种程序可以为用户分配一个指定类型的终端&lt;/p>
&lt;ul>
&lt;li>TTY&lt;/li>
&lt;li>Psedoterminal(伪终端)&lt;/li>
&lt;li>CLI&lt;/li>
&lt;li>TUI&lt;/li>
&lt;/ul>
&lt;p>名词有很多，但是至今位置没有一个明确的标准定义，大家都是拿起来就用~&lt;/p>
&lt;h2 id="cli-的-argsflagoptions">CLI 的 Args、Flag、Options&lt;/h2>
&lt;p>关于 CLI 的术语有很多，比如 Argument(参数)、Flag(标志)、Option(选项) 等&lt;/p>
&lt;p>本质上，命令及其参数只是一个字符串而已，字符串的含义是由 Shell 来解释的，对于 Shell 来说，命令和参数、参数和参数之间是由空白符分割的。除此之外，什么父命令、子命令、本地参数、单横线、双横线 还是其他字符开头都没关系，就仅仅是字符串而已，这些字符串由 Shell 传递给将要执行的程序中。&lt;/p>
&lt;ul>
&lt;li>Argument(参数) # 就是对命令后面一串空白符分割的字符串的称呼&lt;/li>
&lt;li>Flag(标志) # 这种类型的参数可以将某个值跟代码中的某个变量关联起来。&lt;/li>
&lt;li>Option(选项) # Flag 赋予了我们通过 CLI 直接给代码中某个变量赋值的能力。那么如果我没有给这个变量赋值呢，程序还能运行下去么？如果不能运行，则这个 Flag 就是必选的，否则就是可选的。那么这些 Flag 或者 Argument 从这种角度将可以称为 Option。也就是可选的 Flag；或者称为可选的 Argument。&lt;/li>
&lt;/ul>
&lt;h1 id="bash-关联文件">Bash 关联文件&lt;/h1>
&lt;h2 id="全局配置文件对所有用户生效的配置">全局配置文件，对所有用户生效的配置&lt;/h2>
&lt;p>**/etc/profile **# 任何用户使用 shell 时都会加载的配置。linux 不推荐直接修改该文件。加载该配置时自动加载 /etc/profile.d/&lt;em>.sh 的所有文件
**/etc/bashrc **# 常用于设置登录功能和命令别名。linux 不推荐直接修改该文件。加载该配置时自动加载 /etc/profile.d/&lt;/em>.sh 的所有文件
**/etc/profile.d/*.sh **# 类似于 include 的效果。通常用来创建自定义配置。
在 &lt;strong>/etc/profile&lt;/strong> 和 &lt;strong>/etc/bashrc&lt;/strong> 中都会有如下代码块&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">for&lt;/span> i in /etc/profile.d/*.sh /etc/profile.d/sh.local ; &lt;span style="color:#66d9ef">do&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> &lt;span style="color:#f92672">[&lt;/span> -r &lt;span style="color:#e6db74">&amp;#34;&lt;/span>$i&lt;span style="color:#e6db74">&amp;#34;&lt;/span> &lt;span style="color:#f92672">]&lt;/span>; &lt;span style="color:#66d9ef">then&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> &lt;span style="color:#f92672">[&lt;/span> &lt;span style="color:#e6db74">&amp;#34;&lt;/span>&lt;span style="color:#e6db74">${&lt;/span>-#*i&lt;span style="color:#e6db74">}&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span> !&lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#34;&lt;/span>$-&lt;span style="color:#e6db74">&amp;#34;&lt;/span> &lt;span style="color:#f92672">]&lt;/span>; &lt;span style="color:#66d9ef">then&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> . &lt;span style="color:#e6db74">&amp;#34;&lt;/span>$i&lt;span style="color:#e6db74">&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">else&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> . &lt;span style="color:#e6db74">&amp;#34;&lt;/span>$i&lt;span style="color:#e6db74">&amp;#34;&lt;/span> &amp;gt;/dev/null
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">fi&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">fi&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">done&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>这段脚本的大致意思就是：遍历 /etc/profile.d 目录下所有以 .sh 结尾的文件和 sh.local 文件。判断它们是否可读（[ -r &amp;ldquo;$i&amp;rdquo;]），如果可读，判断当前 Shell启动方式是不是交互式（$- 中包含 i）的，如果是交互式的，在当前 Shell 进程中执行该脚本（. &amp;ldquo;$i&amp;rdquo;，source &amp;ldquo;$i&amp;rdquo; 的简写， Shell 的模块化方式），否则，也在当前 Shell 进程中执行该脚本，只不过将输出重定向到了 /dev/null 中。&lt;/p>
&lt;blockquote>
&lt;p>${-#*i} 这个表达式的意思是：从左向右，在 - 变量中找到第一个 i ，并截取 i 之后的子串。&lt;/p>
&lt;/blockquote>
&lt;h2 id="用户配置文件对部分用户生效的配置">用户配置文件，对部分用户生效的配置&lt;/h2>
&lt;blockquote>
&lt;p>这些配置文件一般都定义在用户的家目录当中，所以当某一用户使用 shell 时，就会在其家目录中加载这些配置文件。&lt;/p>
&lt;/blockquote>
&lt;p>**~/.bash_profile **# 仅对当前用户有效。该配置文件会对 ~/.bashrc 进行判断，如果存在，则加载 ~/.bashrc。
**~/.bashrc **# 仅对当前用户有效。该配置文件会对 /etc/bashrc 进行判断，如果存在，则加载 /etc/bashrc。
**~/.bash_login **# 仅对当前用户有效。
**~/.profile **# 仅对当前用户有效。&lt;/p>
&lt;p>Note：&lt;/p>
&lt;ul>
&lt;li>仅在登录的第一次读取一次 bash 这些配置文件，如果在里面加了内容想让其实现，需要重新登录或者用 source FILE 命令来让更改的内容生效）&lt;/li>
&lt;li>用户登录时逐一加载 ~/.bash_profile、~/.bashrc、~/.bash_login、~/.profile。当任何一个文件存在时，都不再加载其余文件。&lt;/li>
&lt;li>为什么配置文件会有这么多分类呢？详见 《shell 的四种模式》章节。不同模式，加载的配置文件是不同的&lt;/li>
&lt;/ul>
&lt;h2 id="四种登录与交互模式">四种登录与交互模式&lt;/h2>
&lt;p>这里面的概念推荐有一定 Linux 基础了之，尤其是得真正明白 Shell 到底是什么之后再来看。&lt;/p>
&lt;p>首先，有几种对登录类型的描述：&lt;/p>
&lt;ul>
&lt;li>交互式：一个个地输入命令并及时查看它们的输出结果，整个过程都在跟 Shell 不停地互动。&lt;/li>
&lt;li>非交互式：运行一个 Shell 脚本 文件，让所有命令批量化、一次性地执行。&lt;/li>
&lt;li>登录式：需要输入用户名和密码才能使用。&lt;/li>
&lt;li>非登录式：直接可以使用。&lt;/li>
&lt;/ul>
&lt;p>这几种类型的不通组合，决定了运行 Shell 的模式&lt;/p>
&lt;p>当我们运行一个 Shell 之后，Shell 会选择下面 4 中模式之一，作为运行本次 Shell 的模式，&lt;strong>不同的模式，加载的配置文件是不同的&lt;/strong>。&lt;/p>
&lt;ul>
&lt;li>&lt;strong>login + interactive # 登录交互。&lt;/strong>
&lt;ul>
&lt;li>首先读取并执行 /etc/profile。&lt;/li>
&lt;li>然后逐一加载 ~/.bash_profile、~/.bash_login、~/.profile。当任何一个文件存在时，都不再加载其余文件。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>login + non-interactive # 登录不交互。&lt;/strong>
&lt;ul>
&lt;li>与 登录交互 模式相同。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>non-login + interactive # 不登陆交互&lt;/strong>
&lt;ul>
&lt;li>直接加载 ~/.bashrc 文件&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>non-login + non-interactive # 不登陆不交互&lt;/strong>
&lt;ul>
&lt;li>与 不登录交互 模式相同&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h3 id="如何判断是否为交互式-shell-有两种方式">如何判断是否为交互式 Shell? 有两种方式&lt;/h3>
&lt;p>查看特殊变量 &lt;code>-&lt;/code> ，如果输出的值包含 &lt;code>i&lt;/code>，则是交互式，否则是非交互式&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>echo $-
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># 比如下面的情况&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>root@lichenhao:~# ssh 172.19.42.248
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>root@lichenhao:~# echo $-
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>himBHs
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># 当使用 ssh 登录时，使用 -T 参数不分配终端，则 $- 没有 i&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>root@lichenhao:~# ssh -T 172.19.42.248
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>echo $-
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>hBs
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>查看变量 PS1 是否为空，如果不为空，则是交互式，否则为非交互式&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>echo $PS1
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Note：这里需要对“交互式”这三个字进行一下说明。与平时理解的所谓交互式不太一样，这里面虽然人类还是可以与设备交互，但是依然称为“非交互式”。&lt;/p>
&lt;p>如何判断是否为登录式 Shell ?&lt;/p>
&lt;p>执行命令 shopt login_shell，如果 login_shell 的值为 on 表示登录式，为 off 表示非登录式。&lt;/p>
&lt;pre>&lt;code>[root@master ~]# shopt login_shell
login_shell on
&lt;/code>&lt;/pre>
&lt;h2 id="典型登录模式总结">典型登录模式总结&lt;/h2>
&lt;ul>
&lt;li>登陆机器后的第一个 shell：登录 + 交互&lt;/li>
&lt;li>通过 ssh 登陆到远程主机：登录 + 交互&lt;/li>
&lt;li>新启动一个 shell 进程，如运行 bash ：不登陆 + 交互&lt;/li>
&lt;li>执行脚本，如 bash script.sh ：不登陆 + 不交互&lt;/li>
&lt;li>运行头部有如 #!/usr/bin/env bash 的可执行文件，如 ./executable ：不登陆 + 不交互&lt;/li>
&lt;li>远程执行脚本，如 ssh user@remote script.sh ：不登陆 + 不交互&lt;/li>
&lt;li>远程执行脚本，同时请求控制台，如 ssh user@remote -t &amp;rsquo;echo $PWD&amp;rsquo; ：不登陆 + 交互&lt;/li>
&lt;li>在图形化界面中打开 terminal：不登陆 + 交互&lt;/li>
&lt;/ul>
&lt;h2 id="登录系统后可自动执行的配置文件">登录系统后可自动执行的配置文件&lt;/h2>
&lt;p>/etc/rc.local&lt;/p>
&lt;ul>
&lt;li>注意：centos7 的 rc.local 没有可执行权限，需要添加权限(chmod +x /etc/rc.d/rc.local)，否则无法使用&lt;/li>
&lt;li>官方推荐使用 systemd 来管理启动脚本。而不是这种方式&lt;/li>
&lt;/ul></description></item><item><title>Docs: 5.登录 Linux 与 访问控制</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/5.%E7%99%BB%E5%BD%95-linux-%E4%B8%8E-%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/5.%E7%99%BB%E5%BD%95-linux-%E4%B8%8E-%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;/blockquote>
&lt;p>想要登录 Linux，必须通过 [&lt;strong>Terminal(终端)&lt;/strong>](/docs/IT学习笔记/1.操作系统/4.Terminal%20 与%20Shell/4.Terminal%20 与%20Shell.md 与 Shell.md)，我们才可以与操作系统进行交互。&lt;/p>
&lt;p>本质上，想要登录 Linux，必然需要调用某些程序(比如 Shell)，以便分配一个终端。通常，我们有多种方式可供选择：&lt;/p>
&lt;ul>
&lt;li>本地命令行登录&lt;/li>
&lt;li>远程命令行登录&lt;/li>
&lt;li>图形界面登录&lt;/li>
&lt;/ul>
&lt;p>Linux 操作系统是一个多用户操作系统，所以除了 &lt;strong>Terminal(终端)&lt;/strong> 以外，还需 &lt;strong>Account(账户)&lt;/strong> 才可以登录上去，Linux 操作系统允许多个用户访问安装在一台机器上的单个系统。每个 &lt;strong>User(用户)&lt;/strong> 都在自己的 &lt;strong>Account(账户)&lt;/strong> 下操作。因此，Account Manager 代表了 Linux 系统管理的核心要素。&lt;/p>
&lt;h1 id="登录-linux">登录 Linux&lt;/h1>
&lt;p>我们可以通过多种方式登录 Linux&lt;/p>
&lt;ul>
&lt;li>本地登录&lt;/li>
&lt;li>远程登录&lt;/li>
&lt;/ul>
&lt;h2 id="通过本地-tty-登陆-linux-系统">通过本地 TTY 登陆 Linux 系统&lt;/h2>
&lt;p>登录 Linux 最基本的方式，就是使用 &lt;code>login&lt;/code> 程序。&lt;/p>
&lt;h3 id="login-程序">login 程序&lt;/h3>
&lt;p>由于历史原因，&lt;code>login&lt;/code> 可能被包含在两个包中：&lt;/p>
&lt;ul>
&lt;li>util-linux&lt;/li>
&lt;li>shadow-utils&lt;/li>
&lt;/ul>
&lt;h4 id="login-的登录行为">login 的登录行为&lt;/h4>
&lt;p>当我们刚刚安装完操作系统，systemd-logind.service 服务会让我们看到这样的画面
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/gwpmr6/1634785246289-3a353c73-2899-4b6c-8341-ffc4a02008ef.png" alt="image.png">
想要在服务器本地登录系统，则需要进行认证，在输入用户名之后，实际上是调用了 &lt;code>login&lt;/code> 这个二进制程序，看到：
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/gwpmr6/1634785206973-885fa7fb-3dfb-4fb1-80c8-1c56cb903974.png" alt="image.png">
此时我们通过远程方式(如果可以的话)登录服务器，查看进程，将会看到名为 login 的进程&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>~&lt;span style="color:#f92672">]&lt;/span>$ pgrep login -alf
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">600&lt;/span> /lib/systemd/systemd-logind
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">1476&lt;/span> /bin/login -p --
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>当我们输入完密码，经过[访问控制](/docs/IT学习笔记/1.操作系统/5.登录%20Linux%20 与%20 访问控制/Access%20Control(访问控制).md Linux 与 访问控制/Access Control(访问控制).md)相关程序的认证之后，login 工具会为我们分配一个 ttyX 的终端设备，然后我们就可以通过 tty 所关联的 Shell(通常是 bash)，与系统进行交互
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/gwpmr6/1634785329507-0cb1fcec-8c6e-4fd0-a99f-005a2b19807e.png" alt="image.png">&lt;/p>
&lt;h4 id="login-关联文件与配置">login 关联文件与配置&lt;/h4>
&lt;p>&lt;strong>/etc/login.defs&lt;/strong> # shadow 与 password 套件的配置文件。
&lt;strong>/etc/pam.d/login&lt;/strong> #&lt;/p>
&lt;h2 id="通过远程的方式来登陆-linux-系统">通过远程的方式来登陆 Linux 系统&lt;/h2>
&lt;h3 id="ssh-程序">ssh 程序&lt;/h3>
&lt;p>详见：&lt;a href="https://www.yuque.com/go/doc/33222417">Secure Shell(SSH) 安全外壳协议&lt;/a>&lt;/p>
&lt;pre>&lt;code>root 981 1 0 Jul08 ? Ss 0:00 /usr/sbin/sshd -D
root 1947 981 0 09:05 ? Ss 0:00 \_ sshd: root@pts/0
root 1949 1947 1 09:05 pts/0 Ss 0:00 \_ -bash
root 1970 1949 0 09:05 pts/0 R+ 0:00 \_ ps -ef f
&lt;/code>&lt;/pre>
&lt;p>OpenSSH 会为用户分配一个 Pseudoterminal(伪终端，即 pts) 以便用户可以与操作系统进行交互。&lt;/p>
&lt;h1 id="登录提示信息">登录提示信息&lt;/h1>
&lt;p>通过 &lt;code>touch ~/.hushlogin&lt;/code> 命令可以为当前用户禁用欢迎信息。&lt;/p>
&lt;h2 id="motd">MOTD&lt;/h2>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Motd_(Unix)">Wiki:MOTD&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://man7.org/linux/man-pages/man5/motd.5.html">Manual(手册),MOTD&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>&lt;strong>Message of the day(每日消息，简称 MOTD)&lt;/strong> 是一种比向所有用户发送一个邮件更有效的发送共同的信息的方式&lt;/p>
&lt;h4 id="motd-关联文件">MOTD 关联文件&lt;/h4>
&lt;p>**/etc/default/motd-news **# 动态 MOTD 新闻信息配置，新闻信息主要是互联网相关的
**/etc/update-motd.d/* **# MOTD 执行脚本保存路径
&lt;strong>~/.hushlogin&lt;/strong> # 该文件存在时，将为当前用户禁用 MOTD 消息
&lt;strong>/etc/pam.d/sshd&lt;/strong> # PAM 模块中可以为 sshd 配置 MOTD。&lt;/p>
&lt;h1 id="访问控制">访问控制&lt;/h1>
&lt;p>Linux 的登录与访问控制是相辅相成的，一个用户想要登录 Linux，通常来说都需要经过访问控制系统对其所使用的账户进行认证，只有认证通过后，才可以正常登录。&lt;/p>
&lt;p>一个正常的 Linux 发行版操作系统，通常都提供了多种方式&lt;/p>
&lt;ul>
&lt;li>密码&lt;/li>
&lt;li>会话&lt;/li>
&lt;li>账户锁定&lt;/li>
&lt;li>等等&amp;hellip;&amp;hellip;&lt;/li>
&lt;/ul>
&lt;h2 id="account-manager账户管理">Account Manager(账户管理)&lt;/h2>
&lt;p>详见 [Account Manager(账户管理)](/docs/IT学习笔记/1.操作系统/5.登录%20Linux%20 与%20 访问控制/Account%20Manager(账户管理).md Linux 与 访问控制/Account Manager(账户管理).md)&lt;/p></description></item><item><title>Docs: 6.Package 管理</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/6.package-%E7%AE%A1%E7%90%86/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/6.package-%E7%AE%A1%E7%90%86/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;/blockquote>
&lt;p>在 Linux 操作系统中，Package 就是指应用程序的安装包。保存 Package 的地方(网站、ISO 等)称为 &lt;strong>Repository(简称 Repo)&lt;/strong>，我们可以从各种 Linux 发行版的官方 Repo 中下载对应的可用的 Package，以安装到这些发行版的 Linux 系统中。&lt;/p>
&lt;blockquote>
&lt;p>注意：哪怕两个发行版的包管理器相同，也不代表他们的 Package 是可以公用的，比如 CentOS 和 OpenEuler 都用 yum，但是 CentOS 的 Package 是无法装在 OpenEuler 上的，安装时将会报错(比如包与包之间 &lt;strong>conflict(冲突)&lt;/strong>)&lt;/p>
&lt;/blockquote>
&lt;h1 id="linux-各发行版的官方-repo-站点">Linux 各发行版的官方 Repo 站点&lt;/h1>
&lt;ul>
&lt;li>包含很多发行版的 Repo 站点: &lt;a href="https://pkgs.org/">https://pkgs.org/&lt;/a>&lt;/li>
&lt;li>OpenEuler: &lt;a href="https://repo.openeuler.org/">https://repo.openeuler.org/&lt;/a>&lt;/li>
&lt;li>CentOS: &lt;a href="https://centos.pkgs.org/">https://centos.pkgs.org/&lt;/a>&lt;/li>
&lt;li>Ubuntu: &lt;a href="https://packages.ubuntu.com/">https://packages.ubuntu.com/&lt;/a>
&lt;ul>
&lt;li>在这里可以找到 jammy 版本(20.04 TLS)的所有软件包列表: &lt;a href="https://packages.ubuntu.com/jammy/allpackages">https://packages.ubuntu.com/jammy/allpackages&lt;/a>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul></description></item><item><title>Docs: 7.时间管理</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/7.%E6%97%B6%E9%97%B4%E7%AE%A1%E7%90%86/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/7.%E6%97%B6%E9%97%B4%E7%AE%A1%E7%90%86/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://www.nim.ac.cn/520/node/4.html">中国计量科学研究院,SI 基本单位&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>1983 年，国际计量打会讨论决定，把 1 米的定义修改为光在 1/299792458 秒内走过的距离
1967 年，国际计量大会定义：1 秒是铯 133 原子基态的两个超精细能量间跃迁对应辐射的 9192631770 个周期的持续时间。&lt;/p>
&lt;h1 id="实现-ntp-协议的工具">实现 NTP 协议的工具&lt;/h1>
&lt;p>ntpd #在 centos8 中已不再支持，推荐使用新工具 chrony 来实现 ntp 协议
chrony #&lt;/p>
&lt;h1 id="其他管理系统时间工具">其他管理系统时间工具&lt;/h1>
&lt;h2 id="date--打印或设置系统日期和时间">date # 打印或设置系统日期和时间&lt;/h2>
&lt;h3 id="syntax语法">Syntax(语法)&lt;/h3>
&lt;p>&lt;strong>date [OPTIONS]&amp;hellip; [+FORMAT]&lt;/strong>
可以通过 FORMAT 设置显示时间的格式&lt;/p>
&lt;p>OPTIONS&lt;/p>
&lt;ul>
&lt;li>-&lt;strong>s&lt;/strong> # 从给定的字符串中设定时间。i.e.设置时间&lt;/li>
&lt;li>&lt;strong>-d&lt;/strong> # 从给定的字符串中显示时间，而不是显示现在的时间。常用于判断给定的数字是否符合时间日期的格式 e.g.date -d 9999 +%H%M 不合法，date -d 1011 +%H%M 合法&lt;/li>
&lt;/ul>
&lt;p>FORMAT:&lt;/p>
&lt;ul>
&lt;li>&lt;code>%F&lt;/code> 年月日(年-月-日)&lt;/li>
&lt;li>&lt;code>%Y&lt;/code> 年&lt;/li>
&lt;li>&lt;code>%m&lt;/code> 月&lt;/li>
&lt;li>&lt;code>%d&lt;/code> 日&lt;/li>
&lt;li>&lt;code>%H&lt;/code> 小时&lt;/li>
&lt;li>&lt;code>%M&lt;/code> 分钟&lt;/li>
&lt;li>&lt;code>%S&lt;/code> 秒&lt;/li>
&lt;li>%s #从 1970-01-01 00:00:00 UTC 时间开始经过的秒。&lt;/li>
&lt;/ul>
&lt;p>EXAMPLE&lt;/p>
&lt;ul>
&lt;li>&lt;strong>date -s 2008/05/06&lt;/strong> #&lt;/li>
&lt;li>&lt;strong>date -s 18:40:00&lt;/strong>&lt;/li>
&lt;li>**date +%H:%M **# 显示当前小时与分钟&lt;/li>
&lt;li>&lt;strong>date -d 1011 +%H%M&lt;/strong> # 显示给定的小时与分钟&lt;/li>
&lt;li>&lt;strong>date +%x &amp;ndash;&amp;gt; 10/21/2009&lt;/strong> #&lt;/li>
&lt;li>&lt;strong>date +%m/%d/%Y&lt;/strong> # 10/21/2009&lt;/li>
&lt;li>2009-10-21 15:18:17
&lt;ul>
&lt;li>**date &amp;ldquo;+%Y-%m-%d %H:%M:%S&amp;rdquo; **#&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>2021-12-20_15:41
&lt;ul>
&lt;li>&lt;strong>date +%F_%H:%M&lt;/strong>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h2 id="timedatectl-options-command--控制系统时间和日期">timedatectl [OPTIONS] [COMMAND] # 控制系统时间和日期&lt;/h2>
&lt;p>若不加任何子命令和选项，则显示日期与时间相关信息
&lt;strong>COMMAND：&lt;/strong>
&lt;strong>status # 显示当前时间设定。(默认 COMMAND)&lt;/strong>&lt;/p>
&lt;p>&lt;strong>set-time TIME # 设置系统时间。&lt;/strong>
这也将相应地更新 RTC 时间。时间可以以 “2012-10-30 18:17:16” 格式指定。&lt;/p>
&lt;ul>
&lt;li>EXAMPLE
&lt;ul>
&lt;li>&lt;strong>timedatectl set-time &amp;ldquo;2020-11-5 18:17:16&amp;rdquo;&lt;/strong> # 将系统时间设置为 2020 年 11 月 5 日 18 点 17 分 16 秒&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>set-timezone ZONE # 设置系统的时区&lt;/strong>&lt;/p>
&lt;p>&lt;strong>list-timezones Show known time zones&lt;/strong>&lt;/p>
&lt;p>&lt;strong>set-local-rtc &amp;lt;true|false&amp;gt; # Control whether RTC is in local tim&lt;/strong>e&lt;/p>
&lt;p>&lt;strong>set-ntp &amp;lt;true|false&amp;gt; #控制是否启用 NTP。&lt;/strong>&lt;/p>
&lt;h2 id="hwclock--rw--查看硬件时间bios-的">hwclock [-rw] # 查看硬件时间(BIOS 的)&lt;/h2>
&lt;p>OPTIONS&lt;/p>
&lt;ul>
&lt;li>**-r **# 查看现有 BIOS 时间，默认为－r 参数&lt;/li>
&lt;li>&lt;strong>-w&lt;/strong> # 将现在的 linux 系统时间写入 BIOS 中&lt;/li>
&lt;/ul>
&lt;p>当我们进行完 Linux 时间的校时后，还需要以 hwclock -w 来更新 BIOS 的时间，因为每次开机的时候，系统会重新由 BIOS 将时间读出来，所以， BIOS 才是重要的时间依据。&lt;/p>
&lt;h1 id="linux-校时">Linux 校时&lt;/h1>
&lt;p>调整 linux 系统时间和时区与 Internet 时间同步&lt;/p>
&lt;p>一、修改时区：&lt;/p>
&lt;p>rm -f /etc/localtime&lt;/p>
&lt;p>ln -s /usr/share/zoneinfo/Asia/Shanghai /etc/localtime&lt;/p>
&lt;p>修改为中国的东八区&lt;/p>
&lt;h1 id="vi-etcsysconfigclock">vi /etc/sysconfig/clock&lt;/h1>
&lt;p>ZONE=&amp;ldquo;Asia/Shanghai&amp;rdquo;&lt;/p>
&lt;p>UTC=false&lt;/p>
&lt;p>ARC=false&lt;/p>
&lt;p>同步 BIOS 时钟，强制把系统时间写入 CMOS：&lt;/p>
&lt;h1 id="clock--w">clock -w&lt;/h1>
&lt;p>三、实现 Internet 时间同步（这里可以忽略上面两步）&lt;/p>
&lt;p>方法 1. 开机的时候自动网络校时：&lt;/p>
&lt;p>vi /etc/rc.d/rc.local&lt;/p>
&lt;p>/usr/sbin/ntpdate -u 192.168.0.2 192.168.0.3 192.168.0.4; /sbin/hwclock -w&lt;/p>
&lt;p>方法 2. 设定计划任务&lt;/p>
&lt;p>crontab 格式如下：&lt;/p>
&lt;h1 id="for-details-see-man-4-crontabs">For details see man 4 crontabs&lt;/h1>
&lt;h1 id="example-of-job-definition">Example of job definition:&lt;/h1>
&lt;h1 id="-----------------minute-0---59">.&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;- minute (0 - 59)&lt;/h1>
&lt;h1 id="---------------hour-0---23">| .&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;- hour (0 - 23)&lt;/h1>
&lt;h1 id="-------------day-of-month-1---31">| | .&amp;mdash;&amp;mdash;&amp;mdash;- day of month (1 - 31)&lt;/h1>
&lt;h1 id="-----------month-1---12-or-janfebmarapr-">| | | .&amp;mdash;&amp;mdash;- month (1 - 12) OR jan,feb,mar,apr &amp;hellip;&lt;/h1>
&lt;h1 id="---------day-of-week-0---6-sunday0-or-7-or-sunmontuewedthufrisat">| | | | .&amp;mdash;- day of week (0 - 6) (Sunday=0 or 7) OR sun,mon,tue,wed,thu,fri,sat&lt;/h1>
&lt;h1 id="----">| | | | |&lt;/h1>
&lt;h1 id="-----command-to-be-executed">* * * * * command to be executed&lt;/h1>
&lt;p>设定 crontab 计划任务也有两种方式：&lt;/p>
&lt;p>1、写在/etc/crontab 里&lt;/p>
&lt;p>代码:&lt;/p>
&lt;p>00 11 * * * root ntpdate 210.72.145.44&lt;/p>
&lt;p>每天 11 点与中国国家授时中心同步时间&lt;/p>
&lt;p>每天 11 点与中国国家授时中心同步时间&lt;/p>
&lt;p>当然前提是&lt;/p>
&lt;p>apt-get install ntpdate&lt;/p>
&lt;p>代码也可是&lt;/p>
&lt;p>00 11 * * * root ntpdate us.pool.ntp.org&lt;/p>
&lt;p>2、使用命令 crontab -e&lt;/p>
&lt;p>crontab -e&lt;/p>
&lt;p>10 5 * * * root ntpdate us.pool.ntp.org;hwclock -w&lt;/p>
&lt;p>这样每天 5:10 自动进行网络校时，并同时更新 BIOS 的时间&lt;/p>
&lt;p>################################&lt;/p>
&lt;p>同步网络时间：输入 ntpdate time.nist.gov 同步网络时间&lt;/p>
&lt;p>[root@localhost ~]# ntpdate time.nist.gov&lt;/p>
&lt;p>12 Oct 17:25:01 ntpdate[2784]: step time server 132.163.4.103 offset 1147751.472254 sec&lt;/p>
&lt;p>##出现以上信息说明同步成功##&lt;/p>
&lt;p>注：如提示命令不存在，直接输入：yum install ntp -y 安装 ntp 软件包&lt;/p></description></item><item><title>Docs: 系统审计</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E7%B3%BB%E7%BB%9F%E5%AE%A1%E8%AE%A1/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E7%B3%BB%E7%BB%9F%E5%AE%A1%E8%AE%A1/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/7/html/security_guide/chap-system_auditing">红帽产品文档，RedHat7-安全指南-第 7 章 系统审计&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>Linux 审计系统提供了一种方式来跟踪系统中的安全相关信息。根据预配置的规则，审计会生成日志条目，以记录有关系统上发生事件的尽可能多的信息。对于关键任务环境而言，此信息对于确定安全策略的违反者及其执行的操作至关重要。Audit 不会为您的系统提供额外的安全性，而是可用于发现系统上使用的安全策略违规。通过 SELinux 等其他安全措施可以进一步阻止这些冲突。
以下列表总结了审计可以在其日志文件中记录的一些信息：&lt;/p>
&lt;ul>
&lt;li>事件的日期和时间、类型和结果.&lt;/li>
&lt;li>主题和对象的敏感度标签。&lt;/li>
&lt;li>事件与触发事件的用户的身份相关联。&lt;/li>
&lt;li>对 Audit 配置的所有修改，并尝试访问 Audit 日志文件。&lt;/li>
&lt;li>所有身份验证机制的使用，如 SSH 和 Kerberos 等。&lt;/li>
&lt;li>对任何受信任数据库的更改，如 /etc/passwd.&lt;/li>
&lt;li>尝试从系统导入或导出信息.&lt;/li>
&lt;li>根据用户身份、主题和对象标签以及其他属性，包含或排除事件。&lt;/li>
&lt;/ul>
&lt;p>使用审计系统也是许多安全相关认证的一项要求。审计旨在满足或超过以下认证或合规指南的要求：&lt;/p>
&lt;ul>
&lt;li>受控访问保护配置文件(CAPP)&lt;/li>
&lt;li>标记的安全保护配置文件(LSPP)&lt;/li>
&lt;li>规则集基本访问控制(RSBAC)&lt;/li>
&lt;li>国家工业安全计划操作手册(NISPOM)&lt;/li>
&lt;li>联邦信息安全管理法案(FISMA)&lt;/li>
&lt;li>支付卡行业 - 数据安全标准(PCI-DSS)&lt;/li>
&lt;li>安全技术实施指南(STIG)&lt;/li>
&lt;/ul>
&lt;p>审计还包括：&lt;/p>
&lt;ul>
&lt;li>由国家信息保障合作伙伴(NIAP)和最佳安全行业(BSI)评估。&lt;/li>
&lt;li>通过红帽企业 Linux 5 上的 LSPP/CAPP/RSBAC/EAL4+ 认证.&lt;/li>
&lt;li>红帽企业 Linux 6 上经过操作系统保护配置文件/评估保证级别 4+(OSPP/EAL4+)认证.&lt;/li>
&lt;/ul>
&lt;h3 id="使用案例">使用案例&lt;/h3>
&lt;p>&lt;strong>监视文件访问&lt;/strong> # 审计可以跟踪文件或目录是否已访问、修改、执行或文件属性是否已更改。例如，这可用于检测对重要文件的访问，并在其中一个文件损坏时提供审计跟踪。
&lt;strong>监控系统调用&lt;/strong> # 可将审计配置为在每次使用特定系统调用时生成日志条目。例如，这可用于通过监控 settimeofday、clock_adjtime 和其他时间相关系统调用来跟踪系统时间的更改。
&lt;strong>记录用户运行的命令&lt;/strong> # 审计可以跟踪文件是否已执行，因此可以定义规则以记录特定命令的每次执行。例如，可以为 /bin 目录中的每个可执行文件定义规则。然后，可以按用户 ID 搜索生成的日志条目，以生成每个用户所执行命令的审计跟踪。
&lt;strong>记录系统路径名称的执行&lt;/strong> # 除了观察在规则调用时转换索引节点路径的文件访问之外，审计现在还可以观察路径的执行，即使路径在规则调用中不存在，或者在规则调用后替换了文件。这允许规则在升级程序可执行文件或甚至安装之前继续运行。
&lt;strong>记录安全事件&lt;/strong> # pam_faillock 身份验证模块能够记录失败的登录尝试。也可以将审计设置为记录失败的登录尝试，并提供试图登录的用户的附加信息。
&lt;strong>搜索事件&lt;/strong> # Audit 提供 ausearch 实用程序，可用于过滤日志条目并根据多个条件提供完整的审计跟踪。
&lt;strong>运行摘要报告&lt;/strong> # aureport 实用程序可用于生成记录的事件的日常报告等。然后，系统管理员可以分析这些报告，并进一步调查可疑活动。
&lt;strong>监控网络访问&lt;/strong> # iptables 和 ebtables 实用程序可以配置为触发审计事件，使系统管理员能够监控网络访问。&lt;/p></description></item><item><title>Docs: X.Linux 管理</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/x.linux-%E7%AE%A1%E7%90%86/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/x.linux-%E7%AE%A1%E7%90%86/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;ul>
&lt;li>&lt;a href="https://www.gnu.org/manual/">GNU Manual(手册)&lt;/a> — Linux 中很多核心程序，都是 GNU 组织下的软件。&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>系统管理员可以通过 一系列用户空间的二进制应用程序来管理 Linux 操作系统。Linux 内核自带了一个名为 coreutils 包，包含了很多最基本的管理工具。&lt;/p>
&lt;p>除了 Coreutils 包，还有很多很多的应用程序，一起组成了一套工具栈，系统管理员可以根据自身的需求，有选择得安装并使用它们。&lt;/p>
&lt;h1 id="coreutils">Coreutils&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/GNU_Core_Utilities">Wiki,GNU Core Utilies&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.gnu.org/software/coreutils/manual/">官方文档&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>GNU Core Utilities 是 GNU 操作系统的基本文件、Shell、文本操作的实用程序。同时，也是现在绝大部分 Linux 发行版内置的实用程序。&lt;/p>
&lt;p>Coreutils 通常可以通过各种 Linux 发行版的包管理器直接安装。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>root@lichenhao:~/downloads# apt-cache show coreutils
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Package: coreutils
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Architecture: amd64
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Version: 8.30-3ubuntu2
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Multi-Arch: foreign
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Priority: required
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Essential: yes
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Section: utils
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Origin: Ubuntu
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Maintainer: Ubuntu Developers &amp;lt;ubuntu-devel-discuss@lists.ubuntu.com&amp;gt;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Original-Maintainer: Michael Stone &amp;lt;mstone@debian.org&amp;gt;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Bugs: https://bugs.launchpad.net/ubuntu/+filebug
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Installed-Size: &lt;span style="color:#ae81ff">7196&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Pre-Depends: libacl1 &lt;span style="color:#f92672">(&lt;/span>&amp;gt;&lt;span style="color:#f92672">=&lt;/span> 2.2.23&lt;span style="color:#f92672">)&lt;/span>, libattr1 &lt;span style="color:#f92672">(&lt;/span>&amp;gt;&lt;span style="color:#f92672">=&lt;/span> 1:2.4.44&lt;span style="color:#f92672">)&lt;/span>, libc6 &lt;span style="color:#f92672">(&lt;/span>&amp;gt;&lt;span style="color:#f92672">=&lt;/span> 2.28&lt;span style="color:#f92672">)&lt;/span>, libselinux1 &lt;span style="color:#f92672">(&lt;/span>&amp;gt;&lt;span style="color:#f92672">=&lt;/span> 2.1.13&lt;span style="color:#f92672">)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Filename: pool/main/c/coreutils/coreutils_8.30-3ubuntu2_amd64.deb
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Size: &lt;span style="color:#ae81ff">1249368&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>MD5sum: e8e201b6d1b7f39776da07f6713e1675
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>SHA1: 1d4ab60c729a361d46a90d92defaca518b2918d2
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>SHA256: 99aa50af84de1737735f2f51e570d60f5842aa1d4a3129527906e7ffda368853
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Homepage: http://gnu.org/software/coreutils
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Description-en: GNU core utilities
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> This package contains the basic file, shell and text manipulation
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> utilities which are expected to exist on every operating system.
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Specifically, this package includes:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> arch base64 basename cat chcon chgrp chmod chown chroot cksum comm cp
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> csplit cut date dd df dir dircolors dirname du echo env expand expr
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> factor false flock fmt fold groups head hostid id install join link ln
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> logname ls md5sum mkdir mkfifo mknod mktemp mv nice nl nohup nproc numfmt
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> od paste pathchk pinky pr printenv printf ptx pwd readlink realpath rm
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> rmdir runcon sha*sum seq shred sleep sort split stat stty sum sync tac
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> tail tee test timeout touch tr true truncate tsort tty uname unexpand
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> uniq unlink users vdir wc who whoami yes
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Description-md5: d0d975dec3625409d24be1238cede238
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Task: minimal
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>这个包中，通常包含如下应用程序&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>arch base64 basename cat chcon chgrp chmod chown chroot cksum comm cp csplit cut date dd df dir dircolors dirname du echo env expand expr factor false flock fmt fold groups head hostid id install join link ln logname ls md5sum mkdir mkfifo mknod mktemp mv nice nl nohup nproc numfmt od paste pathchk pinky pr printenv printf ptx pwd readlink realpath rm rmdir runcon sha*sum seq shred sleep sort split stat stty sum sync tac tail tee test timeout touch tr true truncate tsort tty uname unexpand uniq unlink users vdir wc who whoami yes
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>可以发现，这些命令就是我们日常经常使用那些~&lt;/p>
&lt;h1 id="util-linux">Util-linux&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://github.com/util-linux/util-linux">GitHub 项目，util-linux/util-linux&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Util-linux">Wiki,Util-linux&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>util-linux 是由 Linux 内核组织分发的标准软件包，用作 Linux 操作系统的一部分。一个分支 util-linux-ng（ng 的意思是“下一代”）是在开发停滞时创建的，但截至 2011 年 1 月，它已重命名为 util-linux，并且是该软件包的正式版本。&lt;/p>
&lt;p>Util-linux 包中通常包含如下程序：&lt;/p>
&lt;ul>
&lt;li>addpart&lt;/li>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Getty_(Unix)">agetty&lt;/a>&lt;/li>
&lt;li>blkdiscard&lt;/li>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Blkid">blkid&lt;/a>&lt;/li>
&lt;li>blkzone&lt;/li>
&lt;li>&lt;a href="https://en.wikipedia.org/w/index.php?title=Blockdev&amp;amp;action=edit&amp;amp;redlink=1">blockdev&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Cal_(command)">cal&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Cfdisk">cfdisk&lt;/a>&lt;/li>
&lt;li>chcpu&lt;/li>
&lt;li>chfn&lt;/li>
&lt;li>chmem&lt;/li>
&lt;li>choom&lt;/li>
&lt;li>chrt&lt;/li>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Chsh">chsh&lt;/a>&lt;/li>
&lt;li>col (legacy)&lt;/li>
&lt;li>colcrt&lt;/li>
&lt;li>colrm&lt;/li>
&lt;li>column&lt;/li>
&lt;li>ctrlaltdel&lt;/li>
&lt;li>delpart&lt;/li>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Dmesg">dmesg&lt;/a>&lt;/li>
&lt;li>eject&lt;/li>
&lt;li>fallocate&lt;/li>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Fdformat">fdformat&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Fdisk">fdisk&lt;/a>&lt;/li>
&lt;li>fincore&lt;/li>
&lt;li>findfs&lt;/li>
&lt;li>findmnt&lt;/li>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/File_locking">flock&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Fsck">fsck&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Fsck">fsck&lt;/a>.&lt;a href="https://en.wikipedia.org/wiki/Cramfs">cramfs&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Fsck">fsck&lt;/a>.&lt;a href="https://en.wikipedia.org/wiki/MINIX_file_system">minix&lt;/a>&lt;/li>
&lt;li>fsfreeze&lt;/li>
&lt;li>fstrim&lt;/li>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Getopt">getopt&lt;/a>&lt;/li>
&lt;li>hardlink&lt;/li>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Hex_dump#od_and_hexdump">hexdump&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://en.wikipedia.org/w/index.php?title=Hwclock&amp;amp;action=edit&amp;amp;redlink=1">hwclock&lt;/a> (query and set the hardware clock (RTC))&lt;/li>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Ionice">ionice&lt;/a>&lt;/li>
&lt;li>ipcmk&lt;/li>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Ipcrm">ipcrm&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Ipcs">ipcs&lt;/a>&lt;/li>
&lt;li>irqtop&lt;/li>
&lt;li>isosize&lt;/li>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Kill_(Unix)">kill&lt;/a>&lt;/li>
&lt;li>last&lt;/li>
&lt;li>ldattach&lt;/li>
&lt;li>line (legacy)&lt;/li>
&lt;li>logger&lt;/li>
&lt;li>login&lt;/li>
&lt;li>look&lt;/li>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Losetup">losetup&lt;/a>&lt;/li>
&lt;li>lsblk&lt;/li>
&lt;li>lscpu&lt;a href="https://en.wikipedia.org/wiki/Util-linux#cite_note-8">[8]&lt;/a>&lt;/li>
&lt;li>lsfd&lt;/li>
&lt;li>lsipc&lt;/li>
&lt;li>lsirq&lt;a href="https://en.wikipedia.org/wiki/Util-linux#cite_note-9">[9]&lt;/a>&lt;/li>
&lt;li>lslocks&lt;/li>
&lt;li>lslogins&lt;/li>
&lt;li>lsmem&lt;/li>
&lt;li>lsns&lt;/li>
&lt;li>mcookie&lt;/li>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Mesg">mesg&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Mkfs">mkfs&lt;/a> (legacy)&lt;/li>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Mkfs">mkfs&lt;/a>.&lt;a href="https://en.wikipedia.org/wiki/Boot_File_System">bfs&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Mkfs">mkfs&lt;/a>.&lt;a href="https://en.wikipedia.org/wiki/Cramfs">cramfs&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Mkfs">mkfs&lt;/a>.&lt;a href="https://en.wikipedia.org/wiki/MINIX_file_system">minix&lt;/a>&lt;/li>
&lt;li>mkswap&lt;/li>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/More_(command)">more&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Mount_(Unix)">mount&lt;/a>&lt;/li>
&lt;li>mountpoint&lt;/li>
&lt;li>namei&lt;/li>
&lt;li>newgrp&lt;/li>
&lt;li>nologin&lt;/li>
&lt;li>nsenter&lt;/li>
&lt;li>partx&lt;/li>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Pg_(Unix)">pg&lt;/a> (legacy)&lt;/li>
&lt;li>pivot_root&lt;/li>
&lt;li>prlimit&lt;a href="https://en.wikipedia.org/wiki/Util-linux#cite_note-10">[10]&lt;/a>&lt;/li>
&lt;li>raw&lt;/li>
&lt;li>readprofile&lt;/li>
&lt;li>rename&lt;/li>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Nice_(Unix)">renice&lt;/a>&lt;/li>
&lt;li>reset (legacy)&lt;/li>
&lt;li>resizepart&lt;/li>
&lt;li>rev&lt;/li>
&lt;li>rfkill&lt;/li>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/RTC_Alarm">rtcwake&lt;/a>&lt;/li>
&lt;li>runuser&lt;/li>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Script_(Unix)">script&lt;/a>&lt;/li>
&lt;li>scriptlive&lt;/li>
&lt;li>scriptreplay&lt;/li>
&lt;li>setarch (including architecture symlinks such as i386, linux32, linux64, x86_64, etc.)&lt;/li>
&lt;li>setpriv&lt;/li>
&lt;li>setsid&lt;/li>
&lt;li>setterm&lt;/li>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Sfdisk">sfdisk&lt;/a>&lt;/li>
&lt;li>su&lt;/li>
&lt;li>sulogin&lt;/li>
&lt;li>swaplabel&lt;/li>
&lt;li>swapoff&lt;/li>
&lt;li>swapon&lt;/li>
&lt;li>switch_root&lt;/li>
&lt;li>taskset&lt;/li>
&lt;li>tunelp (deprecated)&lt;a href="https://en.wikipedia.org/wiki/Util-linux#cite_note-11">[11]&lt;/a>&lt;/li>
&lt;li>ul&lt;/li>
&lt;li>umount&lt;/li>
&lt;li>unshare&lt;/li>
&lt;li>utmpdump&lt;/li>
&lt;li>uuidd&lt;/li>
&lt;li>uuidgen&lt;/li>
&lt;li>uuidparse&lt;/li>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Vipw">vipw&lt;/a> (including symlink to vigr)&lt;/li>
&lt;li>wall&lt;/li>
&lt;li>wdctl&lt;/li>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Whereis">whereis&lt;/a>&lt;/li>
&lt;li>wipefs&lt;/li>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Write_(Unix)">write&lt;/a>&lt;/li>
&lt;li>zramctl&lt;/li>
&lt;/ul>
&lt;h3 id="removed">Removed&lt;/h3>
&lt;p>Utilities formerly included, but removed as of 1 July 2015:&lt;/p>
&lt;ul>
&lt;li>arch&lt;a href="https://en.wikipedia.org/wiki/Util-linux#cite_note-12">[12]&lt;/a>&lt;/li>
&lt;li>chkdupexe&lt;a href="https://en.wikipedia.org/wiki/Util-linux#cite_note-13">[13]&lt;/a>&lt;/li>
&lt;li>clock&lt;a href="https://en.wikipedia.org/wiki/Util-linux#cite_note-14">[14]&lt;/a>&lt;/li>
&lt;li>cytune&lt;a href="https://en.wikipedia.org/wiki/Util-linux#cite_note-15">[15]&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Ddate">ddate&lt;/a> (removed from default build&lt;a href="https://en.wikipedia.org/wiki/Util-linux#cite_note-16">[16]&lt;/a> before being removed&lt;a href="https://en.wikipedia.org/wiki/Util-linux#cite_note-17">[17]&lt;/a> altogether)&lt;/li>
&lt;li>elvtune&lt;a href="https://en.wikipedia.org/wiki/Util-linux#cite_note-18">[18]&lt;/a>&lt;/li>
&lt;li>fastboot&lt;a href="https://en.wikipedia.org/wiki/Util-linux#cite_note-simpleinit-19">[19]&lt;/a>&lt;/li>
&lt;li>fasthalt&lt;a href="https://en.wikipedia.org/wiki/Util-linux#cite_note-simpleinit-19">[19]&lt;/a>&lt;/li>
&lt;li>halt&lt;a href="https://en.wikipedia.org/wiki/Util-linux#cite_note-simpleinit-19">[19]&lt;/a>&lt;/li>
&lt;li>initctl&lt;a href="https://en.wikipedia.org/wiki/Util-linux#cite_note-simpleinit-19">[19]&lt;/a>&lt;/li>
&lt;li>ramsize (formerly a symlink to rdev)&lt;a href="https://en.wikipedia.org/wiki/Util-linux#cite_note-rdev-20">[20]&lt;/a>&lt;/li>
&lt;li>rdev&lt;a href="https://en.wikipedia.org/wiki/Util-linux#cite_note-rdev-20">[20]&lt;/a>&lt;/li>
&lt;li>reboot&lt;a href="https://en.wikipedia.org/wiki/Util-linux#cite_note-simpleinit-19">[19]&lt;/a>&lt;/li>
&lt;li>rootflags (formerly a symlink to rdev)&lt;a href="https://en.wikipedia.org/wiki/Util-linux#cite_note-rdev-20">[20]&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Shutdown_(command)">shutdown&lt;/a>&lt;a href="https://en.wikipedia.org/wiki/Util-linux#cite_note-simpleinit-19">[19]&lt;/a>&lt;/li>
&lt;li>simpleinit&lt;a href="https://en.wikipedia.org/wiki/Util-linux#cite_note-simpleinit-19">[19]&lt;/a>&lt;/li>
&lt;li>tailf&lt;a href="https://en.wikipedia.org/wiki/Util-linux#cite_note-tailf-21">[21]&lt;/a>&lt;/li>
&lt;li>vidmode (formerly a symlink to rdev)&lt;a href="https://en.wikipedia.org/wiki/Util-linux#cite_note-rdev-20">[20]&lt;/a>&lt;/li>
&lt;/ul></description></item><item><title>Docs: Y.Windows 管理工具</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/y.windows-%E7%AE%A1%E7%90%86/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/y.windows-%E7%AE%A1%E7%90%86/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;/blockquote>
&lt;h1 id="服务管理工具">服务管理工具&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://docs.microsoft.com/zh-cn/dotnet/framework/windows-services/">https://docs.microsoft.com/zh-cn/dotnet/framework/windows-services/&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://docs.microsoft.com/zh-cn/powershell/scripting/samples/managing-services?view=powershell-7.2">https://docs.microsoft.com/zh-cn/powershell/scripting/samples/managing-services?view=powershell-7.2&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>Get-Service # 列出所有服务&lt;/p>
&lt;h1 id="链接文件管理">链接文件管理&lt;/h1>
&lt;h2 id="mklink">mklink&lt;/h2>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://learn.microsoft.com/en-us/windows-server/administration/windows-commands/mklink">官方文档&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;h3 id="syntax语法">Syntax(语法)&lt;/h3>
&lt;p>&lt;strong>mklink [[/d] | [/h] | [/j]] &amp;lt;link&amp;gt; &amp;lt;target&amp;gt;&lt;/strong>&lt;/p>
&lt;p>为 target 创建一个名为 link 的链接文件。即 link 是要创建的新文件&lt;/p>
&lt;h3 id="example">EXAMPLE&lt;/h3>
&lt;ul>
&lt;li>创建链接
&lt;ul>
&lt;li>mklink /D C:/Users/DesistDaydream/AppData/Roaming/yuzu E:/yuzu/user&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h1 id="电源管理">电源管理&lt;/h1>
&lt;h2 id="powercfg">powercfg&lt;/h2>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://learn.microsoft.com/en-us/windows-hardware/design/device-experiences/powercfg-command-line-options">官方文档-Windows硬件开发人员，学习-Windows-设计-设备体验-Powercfg 命令行选项&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>powercfg 工具可以控制电源计划（也称为电源方案）以使用可用的睡眠状态、控制单个设备的电源状态以及分析系统的常见能效和电池寿命问题。&lt;/p>
&lt;h3 id="syntax语法-1">Syntax(语法)&lt;/h3>
&lt;p>&lt;strong>powercfg OPTIONS [arguments] [/?]&lt;/strong>&lt;/p>
&lt;p>OPTIONS&lt;/p>
&lt;ul>
&lt;li>&lt;strong>/devicequery QueryFlag&lt;/strong> # 根据 QueryFlag(查询标志) 列出设备。可用的 QueryFlag 列表如下
&lt;ul>
&lt;li>&lt;strong>all_devices&lt;/strong> # 列出所有设备&lt;/li>
&lt;li>&lt;strong>wake_armed&lt;/strong> # 列出可以唤醒系统的设备&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>/deviceenablewake &amp;lt;DeviceName&amp;gt;&lt;/strong> # 指定设备启用唤醒系统功能&lt;/li>
&lt;li>&lt;strong>/devicedisablewake &amp;lt;DeviceName&amp;gt;&lt;/strong> # 指定设备禁用唤醒系统功能&lt;/li>
&lt;li>&lt;strong>/lastwake&lt;/strong> # 查看系统最后一次被唤醒的信息&lt;/li>
&lt;/ul>
&lt;h3 id="example-1">EXAMPLE&lt;/h3>
&lt;ul>
&lt;li>查找可以唤醒电脑的设备
&lt;ul>
&lt;li>powercfg /devicequery wake_armed&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>禁用 NVIDIA USB Type-C Port Policy Controller 这个设备唤醒系统
&lt;ul>
&lt;li>powercfg /devicedisablewake &amp;lsquo;NVIDIA USB Type-C Port Policy Controller&amp;rsquo;&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul></description></item><item><title>Docs: Linux 源码解析</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/linux-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/linux-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://elixir.bootlin.com/linux/latest/C/ident/disasm_state">源码快查网站&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote></description></item><item><title>Docs: 公众号,码农的荒岛求生-操作系统话题系列文章</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E5%85%AC%E4%BC%97%E5%8F%B7%E7%A0%81%E5%86%9C%E7%9A%84%E8%8D%92%E5%B2%9B%E6%B1%82%E7%94%9F-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%9D%E9%A2%98%E7%B3%BB%E5%88%97%E6%96%87%E7%AB%A0/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E5%85%AC%E4%BC%97%E5%8F%B7%E7%A0%81%E5%86%9C%E7%9A%84%E8%8D%92%E5%B2%9B%E6%B1%82%E7%94%9F-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%9D%E9%A2%98%E7%B3%BB%E5%88%97%E6%96%87%E7%AB%A0/</guid><description/></item></channel></rss>