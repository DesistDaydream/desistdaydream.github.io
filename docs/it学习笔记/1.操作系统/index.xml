<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>断念梦 – 📄1.操作系统</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/</link><description>Recent content in 📄1.操作系统 on 断念梦</description><generator>Hugo -- gohugo.io</generator><atom:link href="https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/index.xml" rel="self" type="application/rss+xml"/><item><title>Docs: 0_操作系统</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/0_%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/0_%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Operating_system">Wiki.Operating System&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://ebook.hep.com.cn/ebooks/index.html#/read?id=693031822086377472">高教书苑,操作系统原理(2020 年版)-全国计算机等级考试四级教程&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://ebook.hep.com.cn/ebooks/index.html#/read?id=685438574224478208">高教书苑,操作系统原理与实训教程(第 3 版)&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://mp.weixin.qq.com/s/sEv8_o2FABGVtULOGUv3ZQ">公众号-码农的荒岛求生，没有操作系统，程序可以运行起来吗？&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>&lt;strong>Operating System(操作系统，简称 OS)&lt;/strong> 是一个&lt;a href="https://en.wikipedia.org/wiki/System_software">系统软件&lt;/a>，由很多程序模块组成，用以组织计算机的工作流程、有效得控制和管理计算机系统的各类(软件/硬件)资源，并向用户提供各种服务功能(操作接口)，使用户能够灵活、方便、有效地使用计算机。&lt;/p>
&lt;p>白话说，&lt;strong>OS 是计算机系统的&lt;/strong>&lt;code>**管家**&lt;/code>&lt;strong>，是硬件最亲密的&lt;/strong>&lt;code>**伙伴**&lt;/code>&lt;strong>，是人机之间的&lt;/strong>&lt;code>**桥梁**&lt;/code>&lt;strong>，是其他应用软件的&lt;/strong>&lt;code>**基石**&lt;/code>&lt;strong>。&lt;/strong>&lt;/p>
&lt;p>计算机起初是为了代替人类计算产生的，一台设备只能执行一个程序。如果一台计算机上需要同时运行三个程序，那么会有如下问题产生：&lt;/p>
&lt;ol>
&lt;li>三道程序在内存中如何存放？&lt;/li>
&lt;li>什么时候让某个程序占用 CPU？&lt;/li>
&lt;li>怎样有序地输出各个程序的运算结果？&lt;/li>
&lt;/ol>
&lt;p>对这些问题的解决都必须求助于操作系统。也就是说操作系统必须对内存进行管理，对 CPU 进行管理，对外设机型管理，对存放在磁盘上的文件更是要精心组织和管理。不仅如此，操作系统对这些资源进行管理的基础上，还要给用户提供良好的接口，以便用户可能在某种程度上使用或者操纵这些资源。因此，从操作系统设计者的角度考虑，一个操作系统必须包含以下几个部分&lt;/p>
&lt;ol>
&lt;li>操作系统接口&lt;/li>
&lt;li>CPU 管理&lt;/li>
&lt;li>内存管理&lt;/li>
&lt;li>设备管理&lt;/li>
&lt;li>文件管理&lt;/li>
&lt;/ol>
&lt;p>操作系统就是一个大型的软件而已，与运行在操作系统之上的各种程序基本一样。&lt;/p>
&lt;ol>
&lt;li>操作系统=内核+系统程序&lt;/li>
&lt;li>系统程序=编译环境+API(应用程序接口)+AUI(用户接口)&lt;/li>
&lt;li>编译环境=编译程序+连接程序+装载程序&lt;/li>
&lt;li>API=系统调用+语言库函数(C、C++、Java 等)&lt;/li>
&lt;li>AUI=shell+系统服务例程+应用程序(浏览器、字处理、编辑器等)&lt;/li>
&lt;/ol>
&lt;p>一个名为 test 程序执行的简单过程：&lt;/p>
&lt;ol>
&lt;li>用户通过交互界面(shell)告诉操作系统执行 test 程序&lt;/li>
&lt;li>操作系统通过文件名在磁盘找到该程序&lt;/li>
&lt;li>检查可执行代码首部，找出代码和数据存放的地址&lt;/li>
&lt;li>文件系统找到第一个磁盘块&lt;/li>
&lt;li>操作系统建立程序的执行环境&lt;/li>
&lt;li>操作系统把程序从磁盘装入内存，并跳到程序开始出执行&lt;/li>
&lt;li>操作系统检查字符串的位置是否正确&lt;/li>
&lt;li>操作系统找到字符串被送往的设备&lt;/li>
&lt;li>操作系统将字符串送往输出设备窗口系统确定这是一个合法的操作，然后将字符串转换成像素&lt;/li>
&lt;li>窗口系统将像素写入存储映像区&lt;/li>
&lt;li>视频硬件将像素表示转换成一组模拟信号控制显示器&lt;/li>
&lt;li>显示器发射电子束，最后在屏幕上看到程序执行的结果。&lt;/li>
&lt;/ol>
&lt;p>Linux 系统结构详解
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/nm71yz/1616168594662-a90f0c59-7c9b-49ee-ba91-d7065227bfcd.png" alt="">&lt;/p>
&lt;p>Linux 系统一般有 4 个主要部分：&lt;/p>
&lt;ol>
&lt;li>内核&lt;/li>
&lt;li>shell、进程&lt;/li>
&lt;li>文件系统&lt;/li>
&lt;li>应用程序。&lt;/li>
&lt;/ol>
&lt;p>内核、shell 和文件系统一起形成了基本的操作系统结构，它们使得用户可以运行程序、管理文件并使用系统。部分层次结构&lt;/p>
&lt;h1 id="操作系统分类">操作系统分类&lt;/h1>
&lt;p>对 OS 进行分类的方法有很多，从不同的角度可以得到不同的划分。&lt;/p>
&lt;h2 id="按照计算机硬件和结构与规模分类">按照计算机硬件和结构与规模分类&lt;/h2>
&lt;ul>
&lt;li>大型机操作系统&lt;/li>
&lt;li>中型机操作系统&lt;/li>
&lt;li>小型机操作系统&lt;/li>
&lt;li>微型机操作系统&lt;/li>
&lt;li>&lt;strong>(Networking)网络&lt;/strong> 操作系统&lt;/li>
&lt;li>&lt;strong>(Embedded)嵌入式&lt;/strong> 操作系统&lt;/li>
&lt;li>等等&lt;/li>
&lt;/ul>
&lt;h2 id="按照系统所能同时响应的用户与任务分类">按照系统所能同时响应的用户与任务分类&lt;/h2>
&lt;ul>
&lt;li>&lt;strong>(Single-user/Multi-user)单用户 或 多用户&lt;/strong> 操作系统
&lt;ul>
&lt;li>单用户操作系统不具有区分用户的功能，但可以允许多个程序串联运行。&lt;a href="https://en.wikipedia.org/wiki/Operating_system#cite_note-8">[8]&lt;/a>阿&lt;a href="https://en.wikipedia.org/wiki/Multi-user">多用户&lt;/a>操作系统延伸的与设施识别过程和资源，例如磁盘空间，属于多个用户的多任务处理的基本概念，并且该系统允许多个用户在同一时间与系统进行交互。分时操作系统调度任务以有效使用系统，并且还可以包括用于将处理器时间，大容量存储，打印和其他资源的成本分配给多个用户的计费软件。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>(Single-tasking/Multi-tasking)单任务 或 多任务&lt;/strong> 操作系统
&lt;ul>
&lt;li>单任务系统一次只能运行一个程序，而&lt;a href="https://en.wikipedia.org/wiki/Computer_multitasking">多任务&lt;/a>操作系统允许&lt;a href="https://en.wikipedia.org/wiki/Concurrent_computing">并发&lt;/a>运行多个程序。这是通过 &lt;strong>Time-shring(&lt;/strong>&lt;a href="https://en.wikipedia.org/wiki/Time-sharing">&lt;strong>分时&lt;/strong>&lt;/a>&lt;strong>) &lt;strong>实现的，其中可用的处理器时间在多个进程之间分配。这些进程每个都在一个 &lt;strong>time slices(&lt;/strong>&lt;a href="https://en.wikipedia.org/wiki/Time_slice">&lt;strong>时间片&lt;/strong>&lt;/a>&lt;/strong>)&lt;/strong> 中被操作系统的任务计划子系统反复中断。多任务可以以抢占式和合作式为特征。在&lt;a href="https://en.wikipedia.org/wiki/Preemption_(computing)">抢占式&lt;/a>多任务处理中，操作系统会减少&lt;a href="https://en.wikipedia.org/wiki/Central_processing_unit">CPU&lt;/a>时间，并为每个程序分配一个插槽。&lt;a href="https://en.wikipedia.org/wiki/Unix-like">类似于 Unix 的&lt;/a> 操作系统，例如 &lt;a href="https://en.wikipedia.org/wiki/Solaris_(operating_system)">Solaris&lt;/a> 和&lt;a href="https://en.wikipedia.org/wiki/Linux">Linux&lt;/a> 以及非 Unix 操作系统(例如&lt;a href="https://en.wikipedia.org/wiki/AmigaOS">AmigaOS)均&lt;/a>支持抢占式多任务处理。通过依靠每个过程以定义的方式向其他过程提供时间来实现协作式多任务处理。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>通过 用户 和 任务 的组合，可以组合出三种：单用户单任务、单用户多任务、多用户多任务。&lt;/p>
&lt;h2 id="按照系统处理任务的方式分类更加广泛的分类">按照系统处理任务的方式分类(更加广泛的分类)&lt;/h2>
&lt;ul>
&lt;li>&lt;strong>多道批处理&lt;/strong>操作系统 #&lt;/li>
&lt;li>**(Time-shring)分时 **操作系统 #
&lt;ul>
&lt;li>UNIX&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>**(Real-time)实时 **操作系统 #&lt;/li>
&lt;li>**(Distributed)分布式 **操作系统 #&lt;/li>
&lt;li>等等&lt;/li>
&lt;/ul>
&lt;h2 id="其他分类">其他分类&lt;/h2>
&lt;ul>
&lt;li>个人操作系统&lt;/li>
&lt;li>等等&lt;/li>
&lt;/ul>
&lt;h1 id="发展史">发展史&lt;/h1>
&lt;p>&lt;a href="https://en.wikipedia.org/wiki/CP/M">CP/M&lt;/a> 第一个微型机的操作系统&lt;/p>
&lt;h1 id="查看操作系统信息">查看操作系统信息&lt;/h1>
&lt;p>&lt;strong>/etc/os-release&lt;/strong>
&lt;strong>/etc/issue&lt;/strong>&lt;/p></description></item><item><title>Docs: 1.Bootloader</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/1.bootloader/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/1.bootloader/</guid><description/></item><item><title>Docs: 2.Kernel(内核)</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2.kernel%E5%86%85%E6%A0%B8/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2.kernel%E5%86%85%E6%A0%B8/</guid><description/></item><item><title>Docs: 3.Systemd 系统守护程序</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/3.systemd-%E7%B3%BB%E7%BB%9F%E5%AE%88%E6%8A%A4%E7%A8%8B%E5%BA%8F/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/3.systemd-%E7%B3%BB%E7%BB%9F%E5%AE%88%E6%8A%A4%E7%A8%8B%E5%BA%8F/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://github.com/systemd/systemd">GitHub 项目&lt;/a>&lt;/li>
&lt;li>&lt;a href="http://www.jinbuguo.com/systemd/systemd.index.html">Systemd 中文手册,金步国&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://man.cx/systemd">Manual(手册),systemd&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>&lt;strong>System daemon(系统守护进程，简称 systemd)&lt;/strong> 实质上：启动一个服务，就是启动一个程序，可以给该程序添加一些参数，也可以不添加，该程序的可执行文件一般是放在 /usr/lib/systemd/system/ 目录下的&lt;/p>
&lt;p>历史上，Linux 的启动一直采用 init 进程。这种命令 &lt;code>/etc/init.d/apache2 start 或者 service apache2 start&lt;/code>，就是用来启动服务。&lt;/p>
&lt;p>这种方法有两个缺点。&lt;/p>
&lt;ol>
&lt;li>启动时间长。init 进程是串行启动，只有前一个进程启动完，才会启动下一个进程。&lt;/li>
&lt;li>启动脚本复杂。init 进程只是执行启动脚本，不管其他事情。脚本需要自己处理各种情况，这往往使得脚本变得很长。&lt;/li>
&lt;/ol>
&lt;p>Systemd 就是为了解决这些问题而诞生的。它的设计目标是，为系统的启动和管理提供一套完整的解决方案。&lt;/p>
&lt;p>根据 Linux 惯例，字母 d 是 daemon(守护进程) 的缩写。 Systemd 这个名字的含义，就是它要守护整个系统。&lt;/p>
&lt;p>使用了 Systemd，就不需要再用 init 了。Systemd 取代了 initd，成为系统的第一个进程(PID 等于 1)，其他进程都是它的子进程。&lt;/p>
&lt;p>Systemd 的优点是功能强大，使用方便，缺点是体系庞大，非常复杂。事实上，现在还有很多人反对使用 Systemd，理由就是它过于复杂，与操作系统的其他部分强耦合，违反&amp;quot;keep simple, keep stupid&amp;quot;的 Unix 哲学。&lt;/p>
&lt;p>注意：Systemd 启动的程序无法获取 shell 中的变量，需要通过在 Unit 的配置文件中设置环境变量。&lt;/p>
&lt;h2 id="unit单元">Unit(单元)&lt;/h2>
&lt;p>Systemd 将各种操作系统启动和运行的相关对象，抽象多种类型的 &lt;strong>Units(单元)&lt;/strong>，并且提供了 Units 之间的依赖关系。&lt;strong>大多数 Units 是通过 Unit File(单元文件) 创建的&lt;/strong>，没有 Unit File，也就不会存在所谓的 Units。&lt;strong>可以这么说，在特定目录创建了一个符合 Unit File 格式的文件，也就创建了一个 Unit&lt;/strong>。&lt;/p>
&lt;blockquote>
&lt;p>单元：比如以前上学总说：第一单元、第二单元，这种理解&lt;/p>
&lt;/blockquote>
&lt;p>现阶段有如下几种 Units：&lt;/p>
&lt;ol>
&lt;li>&lt;strong>Automoount unit&lt;/strong> # 自动挂载点&lt;/li>
&lt;li>&lt;strong>Device unit&lt;/strong> # 硬件设备&lt;/li>
&lt;li>&lt;strong>Mount unit&lt;/strong> # 文件系统挂载点&lt;/li>
&lt;li>&lt;strong>Path unit&lt;/strong> # 文件或路径&lt;/li>
&lt;li>&lt;strong>Scope unit&lt;/strong> # 与 Service unit 类似，但是由 systemd 根据 D-bus 接口接收到的信息自动创建， 可用于管理外部创建的进程。&lt;/li>
&lt;li>&lt;strong>Service unit&lt;/strong> # 用于启动和控制守护进程以及他们所包含的进程&lt;/li>
&lt;li>&lt;strong>Slice unit&lt;/strong> # 用于控制特定 CGroup 内(例如一组 service 与 scope 单元)所有进程的总体资源占用。&lt;/li>
&lt;li>&lt;strong>Socket nuit&lt;/strong> # 进程间通信的 socket&lt;/li>
&lt;li>&lt;strong>Swap unit&lt;/strong> # 关于 swap 文件&lt;/li>
&lt;li>&lt;strong>Target nuit&lt;/strong> # 是一群 Unit 的集合&lt;/li>
&lt;li>&lt;strong>Timer unit&lt;/strong> # 定时器&lt;/li>
&lt;/ol>
&lt;p>&lt;strong>Unit 的名称&lt;/strong>。Unit 的名称由 Unit File 的名称决定。比如一个 crond.service 文件，将会创建出来一个类型为 Service，名为 crond.service 的 Unit。
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/glcff3/1616167393721-79076d3b-2c04-48e9-a4a0-8ee4bfb69284.jpeg" alt="">
&lt;strong>Unit 的依赖&lt;/strong>。Systemd 能够处理 Units 之间的依赖关系，通过依赖关系，我们可以确定 Unit 之间启动的先后顺序、以及 Unit 之间是否可以同时运行。
&lt;strong>Unit 的状态&lt;/strong>。 Unit 既可以处于活动(active)状态也可以处于停止(inactive)状态， 当然也可以处于启动中(activating)或停止中(deactivating)的状态。 还有一个特殊的失败(failed)状态， 意思是单元以某种方式失败了 (退出时返回了错误代码、进程崩溃、操作超时、触碰启动频率限制)。 当进入失败(failed)状态时， 导致故障的原因 将被记录到日志中以方便日后排查。 需要注意的是， 不同的单元可能还会有各自不同的&amp;quot;子状态&amp;quot;， 但它们都被映射到上述五种状态之一。通过 &lt;code>systemctl list-units --all&lt;/code> 命令可以查看每个 Unit 的状态。&lt;/p>
&lt;h1 id="systemd-配置">Systemd 配置&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>man 手册：&lt;a href="https://man7.org/linux/man-pages/man5/systemd-system.conf.5.html">https://man7.org/linux/man-pages/man5/systemd-system.conf.5.html&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>&lt;strong>/etc/systemd/*&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>**./system.conf **# Systemd 程序运行时配置文件&lt;/li>
&lt;li>**./system.conf.d/*.conf **# Systemd 程序运行时配置文件&lt;/li>
&lt;li>&lt;strong>./user.conf&lt;/strong> # Systemd 以普通用户身份运行时的配置文件&lt;/li>
&lt;li>&lt;strong>./user.conf.d/*.conf&lt;/strong> # Systemd 以普通用户身份运行时的配置文件&lt;/li>
&lt;/ul>
&lt;p>**/run/systemd/* **#&lt;/p>
&lt;ul>
&lt;li>&lt;strong>./system.conf.d/*.conf&lt;/strong> # Systemd 程序运行时配置文件&lt;/li>
&lt;li>&lt;strong>./user.conf.d/*.conf&lt;/strong> # Systemd 以普通用户身份运行时的配置文件&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>/usr/lib/systemd/*&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>&lt;strong>./system.conf.d/*.conf&lt;/strong> # Systemd 程序运行时配置文件&lt;/li>
&lt;li>&lt;strong>./user.conf.d/*.conf&lt;/strong> # Systemd 以普通用户身份运行时的配置文件&lt;/li>
&lt;/ul>
&lt;p>/etc、/run、/usr/lib 这三个目录的优先级从左至右由高到低。Systemd 会从最低优先级的目录 /usr/lib/_ 下开始加载配置，注意加载其中的文件，直到最高优先级的目录 /etc/systemd/_ 为止。&lt;/p>
&lt;h2 id="units-配置">Units 配置&lt;/h2>
&lt;p>Units 配置就是指 Unit File。Systemd 会从多个目录中加载 Unit File，以生成 Unit。下面列出的路径，优先级从上往下越来越低。也就是说，高优先级目录中的文件，将会覆盖低优先级目录中的同名文件。不同的 Systemd 运行方式，加载 Unit File 的路径不同。&lt;/p>
&lt;h3 id="使用---system-参数以系统实例运行-systemd">使用 &amp;ndash;system 参数，以系统实例运行 systemd&lt;/h3>
&lt;p>通过 pkg-config systemd &amp;ndash;variable=systemdsystemunitdir** &lt;strong>命令可以查看包管理器安装完程序后，生成 Unit File 的目录
通过 pkg-config systemd &amp;ndash;variable=systemdsystemconfdir&lt;/strong> **命令可以查看优先级最高的存放 Unit File 的目录&lt;/p>
&lt;ul>
&lt;li>&lt;strong>/etc/systemd/system.control&lt;/strong> # 通过 dbus API 创建的永久系统单元&lt;/li>
&lt;li>&lt;strong>/run/systemd/system.control&lt;/strong> # 通过 dbus API 创建的临时系统单元&lt;/li>
&lt;li>&lt;strong>/run/systemd/transient&lt;/strong> # 动态配置的临时单元(系统与全局用户共用)&lt;/li>
&lt;li>&lt;strong>/run/systemd/generator.early&lt;/strong> # 生成的高优先级单元(系统与全局用户共用)(参见 systemd.generator(7) 手册中对 early-dir 的说明)&lt;/li>
&lt;li>&lt;strong>/etc/systemd/system/*&lt;/strong> # 人类根据需求，手动创建的 Unit File 所在路径。且当使用 systemctl enable UNIT 命令的时候，会自动在该目录中创建软连接到 /usr/lib/systemd/system/ 目录中的 Unit File
&lt;ul>
&lt;li>./UnitFileName.d/*.conf # 嵌入式单元文件 存放路径&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>/run/systemd/system/*&lt;/strong> # 程序运行时自动生成的 Unit File 所在路径。
&lt;ul>
&lt;li>./UnitFileName.d/*.conf # 嵌入式单元文件 存放路径&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>/run/systemd/generator&lt;/strong> # 生成的中优先级系统单元(参见 systemd.generator(7) 手册中对 normal-dir 的说明)&lt;/li>
&lt;li>&lt;strong>/usr/local/lib/systemd/system&lt;/strong> # 本地软件包安装的系统单元&lt;/li>
&lt;li>&lt;strong>/usr/lib/systemd/system/*&lt;/strong> # 通过系统的包管理器安装程序时，生成的 Unit File 所在路径。
&lt;ul>
&lt;li>./UnitFileName.d/*.conf # 嵌入式单元文件 存放路径&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>/run/systemd/generator.late&lt;/strong> # 生成的低优先级系统单元(参见 systemd.generator(7) 手册中对 late-dir 的说明)&lt;/li>
&lt;/ul>
&lt;h3 id="使用---user-参数以用户实例运行-systemd">使用 &amp;ndash;user 参数，以用户实例运行 systemd&lt;/h3>
&lt;ul>
&lt;li>&lt;strong>$XDG_CONFIG_HOME/systemd/user.control 或 ~/.config/systemd/user.control&lt;/strong> # 通过 dbus API 创建的永久私有用户单元(仅在未设置 $XDG_CONFIG_HOME 时才使用 ~/.config 来替代)&lt;/li>
&lt;li>$XDG_RUNTIME_DIR/systemd/user.control # 通过 dbus API 创建的临时私有用户单元&lt;/li>
&lt;li>/run/systemd/transient 动态配置的临时单元(系统与全局用户共用)&lt;/li>
&lt;li>/run/systemd/generator.early 生成的高优先级单元(系统与全局用户共用)(参见 systemd.generator(7) 手册中对 early-dir 的说明)&lt;/li>
&lt;li>$XDG_CONFIG_HOME/systemd/user 或 $HOME/.config/systemd/user 用户配置的私有用户单元(仅在未设置 $XDG_CONFIG_HOME 时才使用 ~/.config 来替代)&lt;/li>
&lt;li>/etc/systemd/user 本地配置的全局用户单元&lt;/li>
&lt;li>$XDG_RUNTIME_DIR/systemd/user 运行时配置的私有用户单元(仅当 $XDG_RUNTIME_DIR 已被设置时有效)&lt;/li>
&lt;li>/run/systemd/user 运行时配置的全局用户单元&lt;/li>
&lt;li>$XDG_RUNTIME_DIR/systemd/generator 生成的中优先级私有用户单元(参见 systemd.generator(7) 手册中对 normal-dir 的说明)&lt;/li>
&lt;li>$XDG_DATA_HOME/systemd/user 或 $HOME/.local/share/systemd/user 软件包安装在用户家目录中的私有用户单元(仅在未设置 $XDG_DATA_HOME 时才使用 ~/.local/share 来替代)&lt;/li>
&lt;li>$dir/systemd/user(对应 $XDG_DATA_DIRS 中的每一个目录($dir)) 额外安装的全局用户单元，对应 $XDG_DATA_DIRS(默认值=&amp;quot;/usr/local/share/:/usr/share/&amp;quot;) 中的每一个目录。&lt;/li>
&lt;li>/usr/local/lib/systemd/user 本地软件包安装的全局用户单元&lt;/li>
&lt;li>/usr/lib/systemd/user 发行版软件包安装的全局用户单元&lt;/li>
&lt;li>$XDG_RUNTIME_DIR/systemd/generator.late 生成的低优先级私有用户单元(参见 systemd.generator(7) 手册中对 late-dir 的说明)&lt;/li>
&lt;/ul>
&lt;p>可以使用环境变量来 扩充或更改 systemd 用户实例(&lt;code>--user&lt;/code>)的单元文件加载路径。 环境变量可以通过环境变量生成器(详见 &lt;a href="http://www.jinbuguo.com/systemd/systemd.environment-generator.html#">systemd.environment-generator(7)&lt;/a> 手册)来设置。特别地， &lt;code>$XDG_DATA_HOME&lt;/code> 与 &lt;code>$XDG_DATA_DIRS&lt;/code> 可以方便的通过 &lt;a href="http://www.jinbuguo.com/systemd/systemd-environment-d-generator.html#">systemd-environment-d-generator(8)&lt;/a> 来设置。这样，上表中列出的单元目录正好就是默认值。 要查看实际使用的、基于编译选项与当前环境变量的单元目录列表，可以使用 &lt;code>systemd-analyze --user unit-paths&lt;/code>&lt;/p>
&lt;p>此外，还可以通过 &lt;a href="http://www.jinbuguo.com/systemd/systemctl.html#">systemctl(1)&lt;/a> 的 &lt;strong>link&lt;/strong> 命令 向上述单元目录中添加额外的单元(不在上述常规单元目录中的单元)。&lt;/p></description></item><item><title>Docs: 4.Terminal 与 Shell</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/4.terminal-%E4%B8%8E-shell/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/4.terminal-%E4%B8%8E-shell/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Shell_(computing)">Wiki,Shell&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.man7.org/linux/man-pages/man1/bash.1.html">Manual(手册),bash&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://blog.csdn.net/kangkanglou/article/details/82698177">https://blog.csdn.net/kangkanglou/article/details/82698177&lt;/a>&lt;/li>
&lt;li>&lt;a href="http://feihu.me/blog/2014/env-problem-when-ssh-executing-command-on-remote/">http://feihu.me/blog/2014/env-problem-when-ssh-executing-command-on-remote/&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.jianshu.com/p/0c7ea235b473">https://www.jianshu.com/p/0c7ea235b473&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://mp.weixin.qq.com/s/RxpcqBGhUT-5z4N5kRXvBg">公众号，阿里技术-一种命令行解析的新思路&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>**Shell(也称为壳层) **是一种计算机程序，向人类用户或其他程序公开操作系统的服务。通常，操作系统的 Shell 程序会根据计算机的角色和特定操作，分为两类：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Command-line_interface">&lt;strong>command-line interface&lt;/strong>&lt;/a>&lt;strong>(命令行界面，简称 CLI)&lt;/strong>&lt;/li>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Graphical_user_interface">&lt;strong>graphical user interface&lt;/strong>&lt;/a>&lt;strong>(图形用户界面，简称 GUI)&lt;/strong>&lt;/li>
&lt;/ul>
&lt;p>Shell 在计算机科学中指“为用户提供用户界面”的软件，通常指的是命令行界面的解析器。一般来说，这个词是指操作系统中提供访问内核所提供之服务的程序。Shell 也用于泛指所有为用户提供操作界面的程序，也就是程序和用户交互的接口。因此与之相对的是 Kernel(内核)，内核不提供和用户的交互功能。&lt;/p>
&lt;p>用白话讲：人类操作计算机的地方就是 Shell ，可以是一个输入命令的地方(CLI)，也可以是一个用户用鼠标点点点的图形界面(GUI)。Shell 也是一类程序的统称，实际上，当输入完用户名和密码登录系统的时候，就是 Linux 系统后台自动启动了一个名叫 Bash 的 Shell 程序，来让用户输入指令对计算机进行操作&lt;/p>
&lt;p>所以，一个 Shell 也会有一个进程号，在该 Shell 执行的程序的父进程号都是该 Shell 的进程号&lt;/p>
&lt;p>如下所示，[登录系统](/docs/IT学习笔记/1.操作系统/5.登录%20Linux%20 与%20 访问控制/5.登录%20Linux%20 与%20 访问控制.md Linux 与 访问控制.md)时，会启动一个进程标识当前登录的用户，并启动一个子进程，该子进程就是 Shell 的类型，这示例里的 Shell 为 Bash，并且会为该 Shell 分配一个&lt;a href="#c0DF2">终端&lt;/a>来与用户进行交互(这里的终端名是 tty1)&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>root &lt;span style="color:#ae81ff">1067&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span> 11:20 ? Ss 0:00 login -- root
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>root &lt;span style="color:#ae81ff">9622&lt;/span> &lt;span style="color:#ae81ff">1067&lt;/span> &lt;span style="color:#ae81ff">2&lt;/span> 13:19 tty1 Ss+ 0:00 &lt;span style="color:#ae81ff">\_&lt;/span> -bash
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>所有命令都是在这个 shell 下运行的，如下所使，在 bash 下执行了一个 cat 命令&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>root &lt;span style="color:#ae81ff">1067&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span> 11:20 ? Ss 0:00 login -- root
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>root &lt;span style="color:#ae81ff">9622&lt;/span> &lt;span style="color:#ae81ff">1067&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span> 13:19 tty1 Ss 0:00 &lt;span style="color:#ae81ff">\_&lt;/span> -bash
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>root &lt;span style="color:#ae81ff">11198&lt;/span> &lt;span style="color:#ae81ff">9622&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span> 13:22 tty1 S+ 0:00 &lt;span style="color:#ae81ff">\_&lt;/span> cat
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Note：&lt;/p>
&lt;ul>
&lt;li>有一点需要明确，系统下的任何程序运行都需要一个用户，哪怕在刚装完系统第一次启动，所有进程也是基于 root 用户来运行的，所以脱离用户讨论 shell 是不对的。&lt;/li>
&lt;li>&lt;strong>由于 linux 常用的 shell 为 bash，下面主要描述的都是关于 bash shell 的配置&lt;/strong>&lt;/li>
&lt;/ul>
&lt;h2 id="terminal终端">Terminal(终端)&lt;/h2>
&lt;blockquote>
&lt;p>参考： - &lt;a href="https://en.wikipedia.org/wiki/Computer_terminal">Wiki,Computer Terminal&lt;/a>&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Teleprinter">Wiki,TTY&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Tty_(unix)">Wiki,TTY(Unix)&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Pseudoterminal">Wiki,Psedoterminal&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Terminal_emulator">Wiki,Terminal emulator&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://askubuntu.com/questions/481906/what-does-tty-stand-for">TTY 代表什么&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://man7.org/linux/man-pages/man7/pty.7.html">Manual(手册),pty(7)&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://man7.org/linux/man-pages/man4/pts.4.html">Manual(手册),pts(4)&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>&lt;strong>Computer Terminal(计算机终端)&lt;/strong> 是一种 Electronic(电子) 或 Electromechanical(机电) 硬件设备，可用于将数据输入计算机或计算机系统，以及从计算机或计算机系统中转录数据。&lt;strong>Teletype(电传打字机，简称 TTY)&lt;/strong> 是早期硬件拷贝终端的一个例子，并且比计算机屏幕的使用早了几十年。早期的终端是廉价设备，与用于输入的打孔卡或纸带相比速度非常慢，但随着技术的改进和视频显示器的引用，终端将这些旧的交互形式推向整个行业，分时系统的发展，弥补了低效的用户打字能力，能够支持统一机器上的多个用户，每个用户都在自己的终端上操作。所以，现代我们将 &lt;strong>TTY 表示为终端&lt;/strong>，是那种最基础的终端。&lt;/p>
&lt;p>除了传统的硬件终端以外，我们还可以通过计算机程序模拟出硬件终端，这种功能称为 &lt;strong>Terminal Emulator(终端模拟器)&lt;/strong>，而很多时候也称为 &lt;strong>Psedoterminal/Pseudotty(伪终端，简称 PTY)&lt;/strong>。PTY 是一对提供双向通信通道的虚拟字符设备，通道的一端称为 master(&lt;strong>简称 PTMX&lt;/strong>)，另一端称为 slave(&lt;strong>简称 PTS&lt;/strong>)。Linux 通过 devpts 文件提供了对 PTS 功能的完整支持。&lt;/p>
&lt;p>终端也分为多种类型，有多种程序可以为用户分配一个指定类型的终端&lt;/p>
&lt;ul>
&lt;li>TTY&lt;/li>
&lt;li>Psedoterminal(伪终端)&lt;/li>
&lt;li>CLI&lt;/li>
&lt;li>TUI&lt;/li>
&lt;/ul>
&lt;p>名词有很多，但是至今位置没有一个明确的标准定义，大家都是拿起来就用~&lt;/p>
&lt;h2 id="cli-的-argsflagoptions">CLI 的 Args、Flag、Options&lt;/h2>
&lt;p>关于 CLI 的术语有很多，比如 Argument(参数)、Flag(标志)、Option(选项) 等&lt;/p>
&lt;p>本质上，命令及其参数只是一个字符串而已，字符串的含义是由 Shell 来解释的，对于 Shell 来说，命令和参数、参数和参数之间是由空白符分割的。除此之外，什么父命令、子命令、本地参数、单横线、双横线 还是其他字符开头都没关系，就仅仅是字符串而已，这些字符串由 Shell 传递给将要执行的程序中。&lt;/p>
&lt;ul>
&lt;li>Argument(参数) # 就是对命令后面一串空白符分割的字符串的称呼&lt;/li>
&lt;li>Flag(标志) # 这种类型的参数可以将某个值跟代码中的某个变量关联起来。&lt;/li>
&lt;li>Option(选项) # Flag 赋予了我们通过 CLI 直接给代码中某个变量赋值的能力。那么如果我没有给这个变量赋值呢，程序还能运行下去么？如果不能运行，则这个 Flag 就是必选的，否则就是可选的。那么这些 Flag 或者 Argument 从这种角度将可以称为 Option。也就是可选的 Flag；或者称为可选的 Argument。&lt;/li>
&lt;/ul>
&lt;h1 id="bash-关联文件">Bash 关联文件&lt;/h1>
&lt;h2 id="全局配置文件对所有用户生效的配置">全局配置文件，对所有用户生效的配置&lt;/h2>
&lt;p>**/etc/profile **# 任何用户使用 shell 时都会加载的配置。linux 不推荐直接修改该文件。加载该配置时自动加载 /etc/profile.d/&lt;em>.sh 的所有文件
**/etc/bashrc **# 常用于设置登录功能和命令别名。linux 不推荐直接修改该文件。加载该配置时自动加载 /etc/profile.d/&lt;/em>.sh 的所有文件
**/etc/profile.d/*.sh **# 类似于 include 的效果。通常用来创建自定义配置。
在 &lt;strong>/etc/profile&lt;/strong> 和 &lt;strong>/etc/bashrc&lt;/strong> 中都会有如下代码块&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">for&lt;/span> i in /etc/profile.d/*.sh /etc/profile.d/sh.local ; &lt;span style="color:#66d9ef">do&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> &lt;span style="color:#f92672">[&lt;/span> -r &lt;span style="color:#e6db74">&amp;#34;&lt;/span>$i&lt;span style="color:#e6db74">&amp;#34;&lt;/span> &lt;span style="color:#f92672">]&lt;/span>; &lt;span style="color:#66d9ef">then&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> &lt;span style="color:#f92672">[&lt;/span> &lt;span style="color:#e6db74">&amp;#34;&lt;/span>&lt;span style="color:#e6db74">${&lt;/span>-#*i&lt;span style="color:#e6db74">}&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span> !&lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#34;&lt;/span>$-&lt;span style="color:#e6db74">&amp;#34;&lt;/span> &lt;span style="color:#f92672">]&lt;/span>; &lt;span style="color:#66d9ef">then&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> . &lt;span style="color:#e6db74">&amp;#34;&lt;/span>$i&lt;span style="color:#e6db74">&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">else&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> . &lt;span style="color:#e6db74">&amp;#34;&lt;/span>$i&lt;span style="color:#e6db74">&amp;#34;&lt;/span> &amp;gt;/dev/null
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">fi&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">fi&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">done&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>这段脚本的大致意思就是：遍历 /etc/profile.d 目录下所有以 .sh 结尾的文件和 sh.local 文件。判断它们是否可读（[ -r &amp;ldquo;$i&amp;rdquo;]），如果可读，判断当前 Shell启动方式是不是交互式（$- 中包含 i）的，如果是交互式的，在当前 Shell 进程中执行该脚本（. &amp;ldquo;$i&amp;rdquo;，source &amp;ldquo;$i&amp;rdquo; 的简写， Shell 的模块化方式），否则，也在当前 Shell 进程中执行该脚本，只不过将输出重定向到了 /dev/null 中。&lt;/p>
&lt;blockquote>
&lt;p>${-#*i} 这个表达式的意思是：从左向右，在 - 变量中找到第一个 i ，并截取 i 之后的子串。&lt;/p>
&lt;/blockquote>
&lt;h2 id="用户配置文件对部分用户生效的配置">用户配置文件，对部分用户生效的配置&lt;/h2>
&lt;blockquote>
&lt;p>这些配置文件一般都定义在用户的家目录当中，所以当某一用户使用 shell 时，就会在其家目录中加载这些配置文件。&lt;/p>
&lt;/blockquote>
&lt;p>**~/.bash_profile **# 仅对当前用户有效。该配置文件会对 ~/.bashrc 进行判断，如果存在，则加载 ~/.bashrc。
**~/.bashrc **# 仅对当前用户有效。该配置文件会对 /etc/bashrc 进行判断，如果存在，则加载 /etc/bashrc。
**~/.bash_login **# 仅对当前用户有效。
**~/.profile **# 仅对当前用户有效。&lt;/p>
&lt;p>Note：&lt;/p>
&lt;ul>
&lt;li>仅在登录的第一次读取一次 bash 这些配置文件，如果在里面加了内容想让其实现，需要重新登录或者用 source FILE 命令来让更改的内容生效）&lt;/li>
&lt;li>用户登录时逐一加载 ~/.bash_profile、~/.bashrc、~/.bash_login、~/.profile。当任何一个文件存在时，都不再加载其余文件。&lt;/li>
&lt;li>为什么配置文件会有这么多分类呢？详见 《shell 的四种模式》章节。不同模式，加载的配置文件是不同的&lt;/li>
&lt;/ul>
&lt;h2 id="四种登录与交互模式">四种登录与交互模式&lt;/h2>
&lt;p>这里面的概念推荐有一定 Linux 基础了之，尤其是得真正明白 Shell 到底是什么之后再来看。&lt;/p>
&lt;p>首先，有几种对登录类型的描述：&lt;/p>
&lt;ul>
&lt;li>交互式：一个个地输入命令并及时查看它们的输出结果，整个过程都在跟 Shell 不停地互动。&lt;/li>
&lt;li>非交互式：运行一个 Shell 脚本 文件，让所有命令批量化、一次性地执行。&lt;/li>
&lt;li>登录式：需要输入用户名和密码才能使用。&lt;/li>
&lt;li>非登录式：直接可以使用。&lt;/li>
&lt;/ul>
&lt;p>这几种类型的不通组合，决定了运行 Shell 的模式&lt;/p>
&lt;p>当我们运行一个 Shell 之后，Shell 会选择下面 4 中模式之一，作为运行本次 Shell 的模式，&lt;strong>不同的模式，加载的配置文件是不同的&lt;/strong>。&lt;/p>
&lt;ul>
&lt;li>&lt;strong>login + interactive # 登录交互。&lt;/strong>
&lt;ul>
&lt;li>首先读取并执行 /etc/profile。&lt;/li>
&lt;li>然后逐一加载 ~/.bash_profile、~/.bash_login、~/.profile。当任何一个文件存在时，都不再加载其余文件。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>login + non-interactive # 登录不交互。&lt;/strong>
&lt;ul>
&lt;li>与 登录交互 模式相同。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>non-login + interactive # 不登陆交互&lt;/strong>
&lt;ul>
&lt;li>直接加载 ~/.bashrc 文件&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>non-login + non-interactive # 不登陆不交互&lt;/strong>
&lt;ul>
&lt;li>与 不登录交互 模式相同&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h3 id="如何判断是否为交互式-shell-有两种方式">如何判断是否为交互式 Shell? 有两种方式&lt;/h3>
&lt;p>查看特殊变量 &lt;code>-&lt;/code> ，如果输出的值包含 &lt;code>i&lt;/code>，则是交互式，否则是非交互式&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>echo $-
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># 比如下面的情况&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>root@lichenhao:~# ssh 172.19.42.248
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>root@lichenhao:~# echo $-
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>himBHs
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># 当使用 ssh 登录时，使用 -T 参数不分配终端，则 $- 没有 i&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>root@lichenhao:~# ssh -T 172.19.42.248
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>echo $-
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>hBs
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>查看变量 PS1 是否为空，如果不为空，则是交互式，否则为非交互式&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>echo $PS1
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Note：这里需要对“交互式”这三个字进行一下说明。与平时理解的所谓交互式不太一样，这里面虽然人类还是可以与设备交互，但是依然称为“非交互式”。&lt;/p>
&lt;p>如何判断是否为登录式 Shell ?&lt;/p>
&lt;p>执行命令 shopt login_shell，如果 login_shell 的值为 on 表示登录式，为 off 表示非登录式。&lt;/p>
&lt;pre>&lt;code>[root@master ~]# shopt login_shell
login_shell on
&lt;/code>&lt;/pre>
&lt;h2 id="典型登录模式总结">典型登录模式总结&lt;/h2>
&lt;ul>
&lt;li>登陆机器后的第一个 shell：登录 + 交互&lt;/li>
&lt;li>通过 ssh 登陆到远程主机：登录 + 交互&lt;/li>
&lt;li>新启动一个 shell 进程，如运行 bash ：不登陆 + 交互&lt;/li>
&lt;li>执行脚本，如 bash script.sh ：不登陆 + 不交互&lt;/li>
&lt;li>运行头部有如 #!/usr/bin/env bash 的可执行文件，如 ./executable ：不登陆 + 不交互&lt;/li>
&lt;li>远程执行脚本，如 ssh user@remote script.sh ：不登陆 + 不交互&lt;/li>
&lt;li>远程执行脚本，同时请求控制台，如 ssh user@remote -t &amp;rsquo;echo $PWD&amp;rsquo; ：不登陆 + 交互&lt;/li>
&lt;li>在图形化界面中打开 terminal：不登陆 + 交互&lt;/li>
&lt;/ul>
&lt;h2 id="登录系统后可自动执行的配置文件">登录系统后可自动执行的配置文件&lt;/h2>
&lt;p>/etc/rc.local&lt;/p>
&lt;ul>
&lt;li>注意：centos7 的 rc.local 没有可执行权限，需要添加权限(chmod +x /etc/rc.d/rc.local)，否则无法使用&lt;/li>
&lt;li>官方推荐使用 systemd 来管理启动脚本。而不是这种方式&lt;/li>
&lt;/ul></description></item><item><title>Docs: 5.登录 Linux 与 访问控制</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/5.%E7%99%BB%E5%BD%95-linux-%E4%B8%8E-%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/5.%E7%99%BB%E5%BD%95-linux-%E4%B8%8E-%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;/blockquote>
&lt;p>想要登录 Linux，必须通过 [&lt;strong>Terminal(终端)&lt;/strong>](/docs/IT学习笔记/1.操作系统/4.Terminal%20 与%20Shell/4.Terminal%20 与%20Shell.md 与 Shell.md)，我们才可以与操作系统进行交互。&lt;/p>
&lt;p>本质上，想要登录 Linux，必然需要调用某些程序(比如 Shell)，以便分配一个终端。通常，我们有多种方式可供选择：&lt;/p>
&lt;ul>
&lt;li>本地命令行登录&lt;/li>
&lt;li>远程命令行登录&lt;/li>
&lt;li>图形界面登录&lt;/li>
&lt;/ul>
&lt;p>Linux 操作系统是一个多用户操作系统，所以除了 &lt;strong>Terminal(终端)&lt;/strong> 以外，还需 &lt;strong>Account(账户)&lt;/strong> 才可以登录上去，Linux 操作系统允许多个用户访问安装在一台机器上的单个系统。每个 &lt;strong>User(用户)&lt;/strong> 都在自己的 &lt;strong>Account(账户)&lt;/strong> 下操作。因此，Account Manager 代表了 Linux 系统管理的核心要素。&lt;/p>
&lt;h1 id="登录-linux">登录 Linux&lt;/h1>
&lt;p>我们可以通过多种方式登录 Linux&lt;/p>
&lt;ul>
&lt;li>本地登录&lt;/li>
&lt;li>远程登录&lt;/li>
&lt;/ul>
&lt;h2 id="通过本地-tty-登陆-linux-系统">通过本地 TTY 登陆 Linux 系统&lt;/h2>
&lt;p>登录 Linux 最基本的方式，就是使用 &lt;code>login&lt;/code> 程序。&lt;/p>
&lt;h3 id="login-程序">login 程序&lt;/h3>
&lt;p>由于历史原因，&lt;code>login&lt;/code> 可能被包含在两个包中：&lt;/p>
&lt;ul>
&lt;li>util-linux&lt;/li>
&lt;li>shadow-utils&lt;/li>
&lt;/ul>
&lt;h4 id="login-的登录行为">login 的登录行为&lt;/h4>
&lt;p>当我们刚刚安装完操作系统，systemd-logind.service 服务会让我们看到这样的画面
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/gwpmr6/1634785246289-3a353c73-2899-4b6c-8341-ffc4a02008ef.png" alt="image.png">
想要在服务器本地登录系统，则需要进行认证，在输入用户名之后，实际上是调用了 &lt;code>login&lt;/code> 这个二进制程序，看到：
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/gwpmr6/1634785206973-885fa7fb-3dfb-4fb1-80c8-1c56cb903974.png" alt="image.png">
此时我们通过远程方式(如果可以的话)登录服务器，查看进程，将会看到名为 login 的进程&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>~&lt;span style="color:#f92672">]&lt;/span>$ pgrep login -alf
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">600&lt;/span> /lib/systemd/systemd-logind
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">1476&lt;/span> /bin/login -p --
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>当我们输入完密码，经过[访问控制](/docs/IT学习笔记/1.操作系统/5.登录%20Linux%20 与%20 访问控制/Access%20Control(访问控制).md Linux 与 访问控制/Access Control(访问控制).md)相关程序的认证之后，login 工具会为我们分配一个 ttyX 的终端设备，然后我们就可以通过 tty 所关联的 Shell(通常是 bash)，与系统进行交互
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/gwpmr6/1634785329507-0cb1fcec-8c6e-4fd0-a99f-005a2b19807e.png" alt="image.png">&lt;/p>
&lt;h4 id="login-关联文件与配置">login 关联文件与配置&lt;/h4>
&lt;p>&lt;strong>/etc/login.defs&lt;/strong> # shadow 与 password 套件的配置文件。
&lt;strong>/etc/pam.d/login&lt;/strong> #&lt;/p>
&lt;h2 id="通过远程的方式来登陆-linux-系统">通过远程的方式来登陆 Linux 系统&lt;/h2>
&lt;h3 id="ssh-程序">ssh 程序&lt;/h3>
&lt;p>详见：&lt;a href="https://www.yuque.com/go/doc/33222417">Secure Shell(SSH) 安全外壳协议&lt;/a>&lt;/p>
&lt;pre>&lt;code>root 981 1 0 Jul08 ? Ss 0:00 /usr/sbin/sshd -D
root 1947 981 0 09:05 ? Ss 0:00 \_ sshd: root@pts/0
root 1949 1947 1 09:05 pts/0 Ss 0:00 \_ -bash
root 1970 1949 0 09:05 pts/0 R+ 0:00 \_ ps -ef f
&lt;/code>&lt;/pre>
&lt;p>OpenSSH 会为用户分配一个 Pseudoterminal(伪终端，即 pts) 以便用户可以与操作系统进行交互。&lt;/p>
&lt;h1 id="登录提示信息">登录提示信息&lt;/h1>
&lt;p>通过 &lt;code>touch ~/.hushlogin&lt;/code> 命令可以为当前用户禁用欢迎信息。&lt;/p>
&lt;h2 id="motd">MOTD&lt;/h2>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Motd_(Unix)">Wiki:MOTD&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://man7.org/linux/man-pages/man5/motd.5.html">Manual(手册),MOTD&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>&lt;strong>Message of the day(每日消息，简称 MOTD)&lt;/strong> 是一种比向所有用户发送一个邮件更有效的发送共同的信息的方式&lt;/p>
&lt;h4 id="motd-关联文件">MOTD 关联文件&lt;/h4>
&lt;p>**/etc/default/motd-news **# 动态 MOTD 新闻信息配置，新闻信息主要是互联网相关的
**/etc/update-motd.d/* **# MOTD 执行脚本保存路径
&lt;strong>~/.hushlogin&lt;/strong> # 该文件存在时，将为当前用户禁用 MOTD 消息
&lt;strong>/etc/pam.d/sshd&lt;/strong> # PAM 模块中可以为 sshd 配置 MOTD。&lt;/p>
&lt;h1 id="访问控制">访问控制&lt;/h1>
&lt;p>Linux 的登录与访问控制是相辅相成的，一个用户想要登录 Linux，通常来说都需要经过访问控制系统对其所使用的账户进行认证，只有认证通过后，才可以正常登录。&lt;/p>
&lt;p>一个正常的 Linux 发行版操作系统，通常都提供了多种方式&lt;/p>
&lt;ul>
&lt;li>密码&lt;/li>
&lt;li>会话&lt;/li>
&lt;li>账户锁定&lt;/li>
&lt;li>等等&amp;hellip;&amp;hellip;&lt;/li>
&lt;/ul>
&lt;h2 id="account-manager账户管理">Account Manager(账户管理)&lt;/h2>
&lt;p>详见 [Account Manager(账户管理)](/docs/IT学习笔记/1.操作系统/5.登录%20Linux%20 与%20 访问控制/Account%20Manager(账户管理).md Linux 与 访问控制/Account Manager(账户管理).md)&lt;/p></description></item><item><title>Docs: 6.Package 管理</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/6.package-%E7%AE%A1%E7%90%86/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/6.package-%E7%AE%A1%E7%90%86/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;/blockquote>
&lt;p>在 Linux 操作系统中，Package 就是指应用程序的安装包。保存 Package 的地方(网站、ISO 等)称为 &lt;strong>Repository(简称 Repo)&lt;/strong>，我们可以从各种 Linux 发行版的官方 Repo 中下载对应的可用的 Package，以安装到这些发行版的 Linux 系统中。&lt;/p>
&lt;blockquote>
&lt;p>注意：哪怕两个发行版的包管理器相同，也不代表他们的 Package 是可以公用的，比如 CentOS 和 OpenEuler 都用 yum，但是 CentOS 的 Package 是无法装在 OpenEuler 上的，安装时将会报错(比如包与包之间 &lt;strong>conflict(冲突)&lt;/strong>)&lt;/p>
&lt;/blockquote>
&lt;h1 id="linux-各发行版的官方-repo-站点">Linux 各发行版的官方 Repo 站点&lt;/h1>
&lt;ul>
&lt;li>包含很多发行版的 Repo 站点: &lt;a href="https://pkgs.org/">https://pkgs.org/&lt;/a>&lt;/li>
&lt;li>OpenEuler: &lt;a href="https://repo.openeuler.org/">https://repo.openeuler.org/&lt;/a>&lt;/li>
&lt;li>CentOS: &lt;a href="https://centos.pkgs.org/">https://centos.pkgs.org/&lt;/a>&lt;/li>
&lt;li>Ubuntu: &lt;a href="https://packages.ubuntu.com/">https://packages.ubuntu.com/&lt;/a>
&lt;ul>
&lt;li>在这里可以找到 jammy 版本(20.04 TLS)的所有软件包列表: &lt;a href="https://packages.ubuntu.com/jammy/allpackages">https://packages.ubuntu.com/jammy/allpackages&lt;/a>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul></description></item><item><title>Docs: 7.时间管理</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/7.%E6%97%B6%E9%97%B4%E7%AE%A1%E7%90%86/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/7.%E6%97%B6%E9%97%B4%E7%AE%A1%E7%90%86/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://www.nim.ac.cn/520/node/4.html">中国计量科学研究院,SI 基本单位&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>1983 年，国际计量打会讨论决定，把 1 米的定义修改为光在 1/299792458 秒内走过的距离
1967 年，国际计量大会定义：1 秒是铯 133 原子基态的两个超精细能量间跃迁对应辐射的 9192631770 个周期的持续时间。&lt;/p>
&lt;h1 id="实现-ntp-协议的工具">实现 NTP 协议的工具&lt;/h1>
&lt;p>ntpd #在 centos8 中已不再支持，推荐使用新工具 chrony 来实现 ntp 协议
chrony #&lt;/p>
&lt;h1 id="其他管理系统时间工具">其他管理系统时间工具&lt;/h1>
&lt;h2 id="date--打印或设置系统日期和时间">date # 打印或设置系统日期和时间&lt;/h2>
&lt;h3 id="syntax语法">Syntax(语法)&lt;/h3>
&lt;p>&lt;strong>date [OPTIONS]&amp;hellip; [+FORMAT]&lt;/strong>
可以通过 FORMAT 设置显示时间的格式&lt;/p>
&lt;p>OPTIONS&lt;/p>
&lt;ul>
&lt;li>-&lt;strong>s&lt;/strong> # 从给定的字符串中设定时间。i.e.设置时间&lt;/li>
&lt;li>&lt;strong>-d&lt;/strong> # 从给定的字符串中显示时间，而不是显示现在的时间。常用于判断给定的数字是否符合时间日期的格式 e.g.date -d 9999 +%H%M 不合法，date -d 1011 +%H%M 合法&lt;/li>
&lt;/ul>
&lt;p>FORMAT:&lt;/p>
&lt;ul>
&lt;li>&lt;code>%F&lt;/code> 年月日(年-月-日)&lt;/li>
&lt;li>&lt;code>%Y&lt;/code> 年&lt;/li>
&lt;li>&lt;code>%m&lt;/code> 月&lt;/li>
&lt;li>&lt;code>%d&lt;/code> 日&lt;/li>
&lt;li>&lt;code>%H&lt;/code> 小时&lt;/li>
&lt;li>&lt;code>%M&lt;/code> 分钟&lt;/li>
&lt;li>&lt;code>%S&lt;/code> 秒&lt;/li>
&lt;li>%s #从 1970-01-01 00:00:00 UTC 时间开始经过的秒。&lt;/li>
&lt;/ul>
&lt;p>EXAMPLE&lt;/p>
&lt;ul>
&lt;li>&lt;strong>date -s 2008/05/06&lt;/strong> #&lt;/li>
&lt;li>&lt;strong>date -s 18:40:00&lt;/strong>&lt;/li>
&lt;li>**date +%H:%M **# 显示当前小时与分钟&lt;/li>
&lt;li>&lt;strong>date -d 1011 +%H%M&lt;/strong> # 显示给定的小时与分钟&lt;/li>
&lt;li>&lt;strong>date +%x &amp;ndash;&amp;gt; 10/21/2009&lt;/strong> #&lt;/li>
&lt;li>&lt;strong>date +%m/%d/%Y&lt;/strong> # 10/21/2009&lt;/li>
&lt;li>2009-10-21 15:18:17
&lt;ul>
&lt;li>**date &amp;ldquo;+%Y-%m-%d %H:%M:%S&amp;rdquo; **#&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>2021-12-20_15:41
&lt;ul>
&lt;li>&lt;strong>date +%F_%H:%M&lt;/strong>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h2 id="timedatectl-options-command--控制系统时间和日期">timedatectl [OPTIONS] [COMMAND] # 控制系统时间和日期&lt;/h2>
&lt;p>若不加任何子命令和选项，则显示日期与时间相关信息
&lt;strong>COMMAND：&lt;/strong>
&lt;strong>status # 显示当前时间设定。(默认 COMMAND)&lt;/strong>&lt;/p>
&lt;p>&lt;strong>set-time TIME # 设置系统时间。&lt;/strong>
这也将相应地更新 RTC 时间。时间可以以 “2012-10-30 18:17:16” 格式指定。&lt;/p>
&lt;ul>
&lt;li>EXAMPLE
&lt;ul>
&lt;li>&lt;strong>timedatectl set-time &amp;ldquo;2020-11-5 18:17:16&amp;rdquo;&lt;/strong> # 将系统时间设置为 2020 年 11 月 5 日 18 点 17 分 16 秒&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>set-timezone ZONE # 设置系统的时区&lt;/strong>&lt;/p>
&lt;p>&lt;strong>list-timezones Show known time zones&lt;/strong>&lt;/p>
&lt;p>&lt;strong>set-local-rtc &amp;lt;true|false&amp;gt; # Control whether RTC is in local tim&lt;/strong>e&lt;/p>
&lt;p>&lt;strong>set-ntp &amp;lt;true|false&amp;gt; #控制是否启用 NTP。&lt;/strong>&lt;/p>
&lt;h2 id="hwclock--rw--查看硬件时间bios-的">hwclock [-rw] # 查看硬件时间(BIOS 的)&lt;/h2>
&lt;p>OPTIONS&lt;/p>
&lt;ul>
&lt;li>**-r **# 查看现有 BIOS 时间，默认为－r 参数&lt;/li>
&lt;li>&lt;strong>-w&lt;/strong> # 将现在的 linux 系统时间写入 BIOS 中&lt;/li>
&lt;/ul>
&lt;p>当我们进行完 Linux 时间的校时后，还需要以 hwclock -w 来更新 BIOS 的时间，因为每次开机的时候，系统会重新由 BIOS 将时间读出来，所以， BIOS 才是重要的时间依据。&lt;/p>
&lt;h1 id="linux-校时">Linux 校时&lt;/h1>
&lt;p>调整 linux 系统时间和时区与 Internet 时间同步&lt;/p>
&lt;p>一、修改时区：&lt;/p>
&lt;p>rm -f /etc/localtime&lt;/p>
&lt;p>ln -s /usr/share/zoneinfo/Asia/Shanghai /etc/localtime&lt;/p>
&lt;p>修改为中国的东八区&lt;/p>
&lt;h1 id="vi-etcsysconfigclock">vi /etc/sysconfig/clock&lt;/h1>
&lt;p>ZONE=&amp;ldquo;Asia/Shanghai&amp;rdquo;&lt;/p>
&lt;p>UTC=false&lt;/p>
&lt;p>ARC=false&lt;/p>
&lt;p>同步 BIOS 时钟，强制把系统时间写入 CMOS：&lt;/p>
&lt;h1 id="clock--w">clock -w&lt;/h1>
&lt;p>三、实现 Internet 时间同步（这里可以忽略上面两步）&lt;/p>
&lt;p>方法 1. 开机的时候自动网络校时：&lt;/p>
&lt;p>vi /etc/rc.d/rc.local&lt;/p>
&lt;p>/usr/sbin/ntpdate -u 192.168.0.2 192.168.0.3 192.168.0.4; /sbin/hwclock -w&lt;/p>
&lt;p>方法 2. 设定计划任务&lt;/p>
&lt;p>crontab 格式如下：&lt;/p>
&lt;h1 id="for-details-see-man-4-crontabs">For details see man 4 crontabs&lt;/h1>
&lt;h1 id="example-of-job-definition">Example of job definition:&lt;/h1>
&lt;h1 id="-----------------minute-0---59">.&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;- minute (0 - 59)&lt;/h1>
&lt;h1 id="---------------hour-0---23">| .&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;- hour (0 - 23)&lt;/h1>
&lt;h1 id="-------------day-of-month-1---31">| | .&amp;mdash;&amp;mdash;&amp;mdash;- day of month (1 - 31)&lt;/h1>
&lt;h1 id="-----------month-1---12-or-janfebmarapr-">| | | .&amp;mdash;&amp;mdash;- month (1 - 12) OR jan,feb,mar,apr &amp;hellip;&lt;/h1>
&lt;h1 id="---------day-of-week-0---6-sunday0-or-7-or-sunmontuewedthufrisat">| | | | .&amp;mdash;- day of week (0 - 6) (Sunday=0 or 7) OR sun,mon,tue,wed,thu,fri,sat&lt;/h1>
&lt;h1 id="----">| | | | |&lt;/h1>
&lt;h1 id="-----command-to-be-executed">* * * * * command to be executed&lt;/h1>
&lt;p>设定 crontab 计划任务也有两种方式：&lt;/p>
&lt;p>1、写在/etc/crontab 里&lt;/p>
&lt;p>代码:&lt;/p>
&lt;p>00 11 * * * root ntpdate 210.72.145.44&lt;/p>
&lt;p>每天 11 点与中国国家授时中心同步时间&lt;/p>
&lt;p>每天 11 点与中国国家授时中心同步时间&lt;/p>
&lt;p>当然前提是&lt;/p>
&lt;p>apt-get install ntpdate&lt;/p>
&lt;p>代码也可是&lt;/p>
&lt;p>00 11 * * * root ntpdate us.pool.ntp.org&lt;/p>
&lt;p>2、使用命令 crontab -e&lt;/p>
&lt;p>crontab -e&lt;/p>
&lt;p>10 5 * * * root ntpdate us.pool.ntp.org;hwclock -w&lt;/p>
&lt;p>这样每天 5:10 自动进行网络校时，并同时更新 BIOS 的时间&lt;/p>
&lt;p>################################&lt;/p>
&lt;p>同步网络时间：输入 ntpdate time.nist.gov 同步网络时间&lt;/p>
&lt;p>[root@localhost ~]# ntpdate time.nist.gov&lt;/p>
&lt;p>12 Oct 17:25:01 ntpdate[2784]: step time server 132.163.4.103 offset 1147751.472254 sec&lt;/p>
&lt;p>##出现以上信息说明同步成功##&lt;/p>
&lt;p>注：如提示命令不存在，直接输入：yum install ntp -y 安装 ntp 软件包&lt;/p></description></item><item><title>Docs: 系统审计</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E7%B3%BB%E7%BB%9F%E5%AE%A1%E8%AE%A1/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E7%B3%BB%E7%BB%9F%E5%AE%A1%E8%AE%A1/</guid><description/></item><item><title>Docs: X.Linux 管理</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/x.linux-%E7%AE%A1%E7%90%86/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/x.linux-%E7%AE%A1%E7%90%86/</guid><description/></item><item><title>Docs: Y.Windows 管理</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/y.windows-%E7%AE%A1%E7%90%86/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/y.windows-%E7%AE%A1%E7%90%86/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;/blockquote>
&lt;h1 id="查看崩溃信息">查看崩溃信息&lt;/h1>
&lt;p>&lt;a href="https://its401.com/article/CRJ297486/120602345">https://its401.com/article/CRJ297486/120602345&lt;/a>
特别生气！！！！某一天突然发现拖拽文件拖拽到其他文件夹就会导致资源管理器卡死，然后还以为是自己拖错了，然后越来越频繁。
然后疯狂百度 1.打开控制面板
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/qnpbng/1654348939190-57e80915-99a7-4521-992f-683029eff444.png" alt="image.png"> 2.再进入安全和维护
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/qnpbng/1654348939189-d155d75e-ee86-4dce-8ddf-66eb077b7138.png" alt="image.png"> 3.点击维护查看可靠性历史记录
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/qnpbng/1654348939189-f0bf328c-11eb-449c-91d7-a67f2d7c6e84.png" alt="image.png"> 4.点击关键信息随便个事件进去可以看见因为啥文件导致卡死的。
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/qnpbng/1654348939160-131bfda2-8f0e-466b-b0d9-941a4542d9c0.png" alt="image.png">
我是因为 wps 的某个文件，把 wps 卸了就好了。 5.如果还没解决的话，可以试试利用 Dism 修复系统
管理员打开 cmd 命令行。
直接输入这两条就好了
DISM /Online /Cleanup-image /ScanHealth //这一条指令用来扫描全部系统文件，并扫描计算机中映像文件与官方系统不一致的情况。 DISM /Online /Cleanup-image /RestoreHealth //计算机必须联网，这种命令的好处在于可以在修复时，系统未损坏部分可以继续运行&lt;/p></description></item><item><title>Docs: Linux 源码解析</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/linux-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/linux-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://elixir.bootlin.com/linux/latest/C/ident/disasm_state">源码快查网站&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote></description></item><item><title>Docs: 公众号,码农的荒岛求生-操作系统话题系列文章</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E5%85%AC%E4%BC%97%E5%8F%B7%E7%A0%81%E5%86%9C%E7%9A%84%E8%8D%92%E5%B2%9B%E6%B1%82%E7%94%9F-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%9D%E9%A2%98%E7%B3%BB%E5%88%97%E6%96%87%E7%AB%A0/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E5%85%AC%E4%BC%97%E5%8F%B7%E7%A0%81%E5%86%9C%E7%9A%84%E8%8D%92%E5%B2%9B%E6%B1%82%E7%94%9F-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%9D%E9%A2%98%E7%B3%BB%E5%88%97%E6%96%87%E7%AB%A0/</guid><description/></item></channel></rss>