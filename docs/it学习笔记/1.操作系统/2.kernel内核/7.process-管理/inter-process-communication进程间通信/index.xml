<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>断念梦 – Inter Process Communication(进程间通信)</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2.kernel%E5%86%85%E6%A0%B8/7.process-%E7%AE%A1%E7%90%86/inter-process-communication%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1/</link><description>Recent content in Inter Process Communication(进程间通信) on 断念梦</description><generator>Hugo -- gohugo.io</generator><atom:link href="https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2.kernel%E5%86%85%E6%A0%B8/7.process-%E7%AE%A1%E7%90%86/inter-process-communication%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1/index.xml" rel="self" type="application/rss+xml"/><item><title>Docs: Inter Process Communication(进程间通信)</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2.kernel%E5%86%85%E6%A0%B8/7.process-%E7%AE%A1%E7%90%86/inter-process-communication%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1/inter-process-communication%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2.kernel%E5%86%85%E6%A0%B8/7.process-%E7%AE%A1%E7%90%86/inter-process-communication%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1/inter-process-communication%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Inter-process_communication">Wiki,IPC&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Local_Inter-Process_Communication">Wiki,LPC&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://mp.weixin.qq.com/s/MnIcTR0KKpgnSoA3xaPUSA">公众号,小林 Coding-进程间通信&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>**Inter Process Communication(进程间通信，简称 IPC) **是一种允许多个进程共享数据的机制。IPC 的两个应用可以被分为客户端和服务端，客户端进程请求数据，服务端响应客户端的数据请求。有一些应用本身既是服务器又是客户端，这在分布式计算中，时常可以见到。这些进程可以运行在同一计算机上或网络连接的不同计算机上。&lt;/p>
&lt;p>IPC 对微内核和 nano 内核的设计过程非常重要。 微内核减少了内核提供的功能数量。 然后通过 IPC 与服务器通信获得这些功能，与普通的宏内核相比，IPC 的数量大幅增加。&lt;/p>
&lt;p>IPC 可以分为如下两类：&lt;/p>
&lt;ul>
&lt;li>&lt;strong>Local Procedure Call(本地过程调用，简称 LPC)&lt;/strong> #&lt;/li>
&lt;li>&lt;strong>Remote Procedure Call(远程过程调用，简称 RPC)&lt;/strong> #&lt;/li>
&lt;/ul>
&lt;p>IPC 可以通过多种方式实现：&lt;/p>
&lt;ul>
&lt;li>&lt;strong>file(文件)&lt;/strong> # 多个进程可以通过磁盘上的文件共享数据。&lt;/li>
&lt;li>**Signal(信号) **# 从一个进程发送到另一个进程的系统消息，通常不用于传输数据，而是用于远程命令伙伴进程。&lt;a href="https://www.yuque.com/go/doc/33222681">详见此处&lt;/a>&lt;/li>
&lt;li>**pipe(管道) **# 使用标准输入和输出的单向数据通道。写入管道的写入端的数据由操作系统进行缓冲，直到从管道的读取端读取数据为止。通过使用相反“方向”上的两个管道可以实现过程之间的双向通信。详见[exec、xargs、管道等命令](✏IT 学习笔记/📄1.操作系统/4.Terminal%20 与%20Shell/exec,xargs,管道符等组合命令.md 与 Shell/exec,xargs,管道符等组合命令.md)&lt;/li>
&lt;li>&lt;strong>Socket(套接字)&lt;/strong> # 计算机领域中数据通信的一种约定，或者说是一种方法，《[Socket(套接字)](✏IT 学习笔记/📄1.操作系统/2.Kernel(内核)/7.Process%20 管理/Inter%20Process%20Communication(进程间通信)/Socket(套接字).md Process Communication(进程间通信)/Socket(套接字).md)》。Socket 又分为两种
&lt;ul>
&lt;li>Unix Domain Socket&lt;/li>
&lt;li>Network Socket&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>Shared Memory(共享内存)&lt;/strong> #&lt;/li>
&lt;li>&lt;strong>Message Queue(消息队列)&lt;/strong> # 类似于 Socket 的数据流，但这通常保留了信息的边界。通常由操作系统实现，它们允许多个进程读写消息队列，而不需要彼此直接连接。&lt;/li>
&lt;li>&lt;strong>Mesage Passing(消息传递)&lt;/strong> # 允许多个程序使用消息队列和/或非 OS 托管通道进行通信。常用于并发模型。比如 LPC、RPC 等等。&lt;/li>
&lt;li>&lt;strong>等等&lt;/strong>&lt;/li>
&lt;/ul>
&lt;h1 id="ipc-实现方式概述">IPC 实现方式概述&lt;/h1>
&lt;p>每个进程的用户地址空间都是独立的，一般而言是不能互相访问的，但内核空间是每个进程都共享的，所以进程之间要通信必须通过内核。&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/iuxfg7/1619421762395-81aa05bc-0c16-4377-9584-9381c9433c63.png" alt="">&lt;/p>
&lt;p>Linux 内核提供了不少进程间通信的机制，我们来一起瞧瞧有哪些？&lt;/p>
&lt;h3 id="管道">管道&lt;/h3>
&lt;p>如果你学过 Linux 命令，那你肯定很熟悉 &lt;code>|&lt;/code> 这个竖线。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#960050;background-color:#1e0010">$ &lt;/span>&lt;span style="color:#a6e22e">ps&lt;/span>&lt;span style="color:#960050;background-color:#1e0010"> &lt;/span>&lt;span style="color:#a6e22e">auxf&lt;/span>&lt;span style="color:#960050;background-color:#1e0010"> &lt;/span>|&lt;span style="color:#960050;background-color:#1e0010"> &lt;/span>&lt;span style="color:#a6e22e">grep&lt;/span>&lt;span style="color:#960050;background-color:#1e0010"> &lt;/span>&lt;span style="color:#a6e22e">mysql&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>上面命令行里的 &lt;code>|&lt;/code> 竖线就是一个&lt;strong>管道&lt;/strong>，它的功能是将前一个命令 &lt;code>ps auxf&lt;/code> 的输出，作为后一个命令 &lt;code>grep mysql&lt;/code> 的输入，从这功能描述，可以看出&lt;strong>管道传输数据是单向的&lt;/strong>，如果想相互通信，我们需要创建两个管道才行。&lt;/p>
&lt;p>同时，我们得知上面这种管道是没有名字，所以 &lt;code>|&lt;/code> 表示的管道称为&lt;strong>匿名管道&lt;/strong>，用完了就销毁。&lt;/p>
&lt;p>管道还有另外一个类型是&lt;strong>命名管道&lt;/strong>，也被叫做 &lt;code>FIFO&lt;/code>，因为数据是先进先出的传输方式。&lt;/p>
&lt;p>在使用命名管道前，先需要通过 &lt;code>mkfifo&lt;/code> 命令来创建，并且指定管道名字：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#960050;background-color:#1e0010">$ &lt;/span>&lt;span style="color:#a6e22e">mkfifo&lt;/span>&lt;span style="color:#960050;background-color:#1e0010"> &lt;/span>&lt;span style="color:#a6e22e">myPipe&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>myPipe 就是这个管道的名称，基于 Linux 一切皆文件的理念，所以管道也是以文件的方式存在，我们可以用 ls 看一下，这个文件的类型是 p，也就是 pipe（管道） 的意思：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>$ ls
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>-lprw-r--r--. 1 root    root         0 Jul 17 02:45 myPipe
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>接下来，我们往 myPipe 这个管道写入数据：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>$ echo &lt;span style="color:#e6db74">&amp;#34;hello&amp;#34;&lt;/span> &amp;gt; myPipe  // 将数据写进管道
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> // 停住了 ...
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>你操作了后，你会发现命令执行后就停在这了，这是因为管道里的内容没有被读取，只有当管道里的数据被读完后，命令才可以正常退出。&lt;/p>
&lt;p>于是，我们执行另外一个命令来读取这个管道里的数据：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>$ cat &amp;lt; myPipe  // 读取管道里的数据hello
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>可以看到，管道里的内容被读取出来了，并打印在了终端上，另外一方面，echo 那个命令也正常退出了。&lt;/p>
&lt;p>我们可以看出，&lt;strong>管道这种通信方式效率低，不适合进程间频繁地交换数据&lt;/strong>。当然，它的好处，自然就是简单，同时也我们很容易得知管道里的数据已经被另一个进程读取了。&lt;/p>
&lt;blockquote>
&lt;p>那管道如何创建呢，背后原理是什么？&lt;/p>
&lt;/blockquote>
&lt;p>匿名管道的创建，需要通过下面这个系统调用：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>int pipe&lt;span style="color:#f92672">(&lt;/span>int fd&lt;span style="color:#f92672">[&lt;/span>2&lt;span style="color:#f92672">])&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>这里表示创建一个匿名管道，并返回了两个描述符，一个是管道的读取端描述符 &lt;code>fd[0]&lt;/code>，另一个是管道的写入端描述符 &lt;code>fd[1]&lt;/code>。注意，这个匿名管道是特殊的文件，只存在于内存，不存于文件系统中。
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/iuxfg7/1619421762470-c218e6b2-110b-454f-b314-057383247469.png" alt="">
其实，&lt;strong>所谓的管道，就是内核里面的一串缓存&lt;/strong>。从管道的一段写入的数据，实际上是缓存在内核中的，另一端读取，也就是从内核中读取这段数据。另外，管道传输的数据是无格式的流且大小受限。&lt;/p>
&lt;p>看到这，你可能会有疑问了，这两个描述符都是在一个进程里面，并没有起到进程间通信的作用，怎么样才能使得管道是跨过两个进程的呢？&lt;/p>
&lt;p>我们可以使用 &lt;code>fork&lt;/code> 创建子进程，&lt;strong>创建的子进程会复制父进程的文件描述符&lt;/strong>，这样就做到了两个进程各有两个「 &lt;code>fd[0]&lt;/code> 与 &lt;code>fd[1]&lt;/code>」，两个进程就可以通过各自的 fd 写入和读取同一个管道文件实现跨进程通信了。
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/iuxfg7/1619421762310-ab6819a4-d922-4393-9591-590864172c59.png" alt="">
管道只能一端写入，另一端读出，所以上面这种模式容易造成混乱，因为父进程和子进程都可以同时写入，也都可以读出。那么，为了避免这种情况，通常的做法是：&lt;/p>
&lt;ul>
&lt;li>父进程关闭读取的 fd[0]，只保留写入的 fd[1]；&lt;/li>
&lt;li>子进程关闭写入的 fd[1]，只保留读取的 fd[0]；&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/iuxfg7/1619421762492-d45b7c24-a90b-4fda-aea1-feb733f155bf.png" alt="">
所以说如果需要双向通信，则应该创建两个管道。&lt;/p>
&lt;p>到这里，我们仅仅解析了使用管道进行父进程与子进程之间的通信，但是在我们 shell 里面并不是这样的。&lt;/p>
&lt;p>在 shell 里面执行 &lt;code>A | B&lt;/code> 命令的时候，A 进程和 B 进程都是 shell 创建出来的子进程，A 和 B 之间不存在父子关系，它俩的父进程都是 shell。&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/iuxfg7/1619421762314-89d01b2d-6ffd-4cd8-9b56-6c6e9e6ffa03.png" alt="">&lt;/p>
&lt;p>所以说，在 shell 里通过「&lt;code>|&lt;/code>」匿名管道将多个命令连接在一起，实际上也就是创建了多个子进程，那么在我们编写 shell 脚本时，能使用一个管道搞定的事情，就不要多用一个管道，这样可以减少创建子进程的系统开销。&lt;/p>
&lt;p>我们可以得知，&lt;strong>对于匿名管道，它的通信范围是存在父子关系的进程&lt;/strong>。因为管道没有实体，也就是没有管道文件，只能通过 fork 来复制父进程 fd 文件描述符，来达到通信的目的。&lt;/p>
&lt;p>另外，&lt;strong>对于命名管道，它可以在不相关的进程间也能相互通信&lt;/strong>。因为命令管道，提前创建了一个类型为管道的设备文件，在进程里只要使用这个设备文件，就可以相互通信。&lt;/p>
&lt;p>不管是匿名管道还是命名管道，进程写入的数据都是缓存在内核中，另一个进程读取数据时候自然也是从内核中获取，同时通信数据都遵循&lt;strong>先进先出&lt;/strong>原则，不支持 lseek 之类的文件定位操作。&lt;/p>
&lt;h3 id="消息队列">消息队列&lt;/h3>
&lt;p>前面说到管道的通信方式是效率低的，因此管道不适合进程间频繁地交换数据。&lt;/p>
&lt;p>对于这个问题，&lt;strong>消息队列&lt;/strong>的通信模式就可以解决。比如，A 进程要给 B 进程发送消息，A 进程把数据放在对应的消息队列后就可以正常返回了，B 进程需要的时候再去读取数据就可以了。同理，B 进程要给 A 进程发送消息也是如此。&lt;/p>
&lt;p>再来，&lt;strong>消息队列是保存在内核中的消息链表&lt;/strong>，在发送数据时，会分成一个一个独立的数据单元，也就是消息体（数据块），消息体是用户自定义的数据类型，消息的发送方和接收方要约定好消息体的数据类型，所以每个消息体都是固定大小的存储块，不像管道是无格式的字节流数据。如果进程从消息队列中读取了消息体，内核就会把这个消息体删除。&lt;/p>
&lt;p>消息队列生命周期随内核，如果没有释放消息队列或者没有关闭操作系统，消息队列会一直存在，而前面提到的匿名管道的生命周期，是随进程的创建而建立，随进程的结束而销毁。&lt;/p>
&lt;p>消息这种模型，两个进程之间的通信就像平时发邮件一样，你来一封，我回一封，可以频繁沟通了。&lt;/p>
&lt;p>但邮件的通信方式存在不足的地方有两点，&lt;strong>一是通信不及时，二是附件也有大小限制&lt;/strong>，这同样也是消息队列通信不足的点。&lt;/p>
&lt;p>&lt;strong>消息队列不适合比较大数据的传输&lt;/strong>，因为在内核中每个消息体都有一个最大长度的限制，同时所有队列所包含的全部消息体的总长度也是有上限。在 Linux 内核中，会有两个宏定义 &lt;code>MSGMAX&lt;/code> 和 &lt;code>MSGMNB&lt;/code>，它们以字节为单位，分别定义了一条消息的最大长度和一个队列的最大长度。&lt;/p>
&lt;p>&lt;strong>消息队列通信过程中，存在用户态与内核态之间的数据拷贝开销&lt;/strong>，因为进程写入数据到内核中的消息队列时，会发生从用户态拷贝数据到内核态的过程，同理另一进程读取内核中的消息数据时，会发生从内核态拷贝数据到用户态的过程。&lt;/p>
&lt;h3 id="共享内存">共享内存&lt;/h3>
&lt;p>消息队列的读取和写入的过程，都会有发生用户态与内核态之间的消息拷贝过程。那&lt;strong>共享内存&lt;/strong>的方式，就很好的解决了这一问题。&lt;/p>
&lt;p>现代操作系统，对于内存管理，采用的是虚拟内存技术，也就是每个进程都有自己独立的虚拟内存空间，不同进程的虚拟内存映射到不同的物理内存中。所以，即使进程 A 和 进程 B 的虚拟地址是一样的，其实访问的是不同的物理内存地址，对于数据的增删查改互不影响。&lt;/p>
&lt;p>&lt;strong>共享内存的机制，就是拿出一块虚拟地址空间来，映射到相同的物理内存中&lt;/strong>。这样这个进程写入的东西，另外一个进程马上就能看到了，都不需要拷贝来拷贝去，传来传去，大大提高了进程间通信的速度。&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/iuxfg7/1619421762492-966784b1-cbd4-4545-bdae-300663d06a0b.png" alt="">&lt;/p>
&lt;h3 id="信号量">信号量&lt;/h3>
&lt;p>用了共享内存通信方式，带来新的问题，那就是如果多个进程同时修改同一个共享内存，很有可能就冲突了。例如两个进程都同时写一个地址，那先写的那个进程会发现内容被别人覆盖了。&lt;/p>
&lt;p>为了防止多进程竞争共享资源，而造成的数据错乱，所以需要保护机制，使得共享的资源，在任意时刻只能被一个进程访问。正好，&lt;strong>信号量&lt;/strong>就实现了这一保护机制。&lt;/p>
&lt;p>&lt;strong>信号量其实是一个整型的计数器，主要用于实现进程间的互斥与同步，而不是用于缓存进程间通信的数据&lt;/strong>。&lt;/p>
&lt;p>信号量表示资源的数量，控制信号量的方式有两种原子操作：&lt;/p>
&lt;ul>
&lt;li>一个是 &lt;strong>P 操作&lt;/strong>，这个操作会把信号量减去 -1，相减后如果信号量 &amp;lt;0，则表明资源已被占用，进程需阻塞等待；相减后如果信号量&amp;gt;= 0，则表明还有资源可使用，进程可正常继续执行。&lt;/li>
&lt;li>另一个是 &lt;strong>V 操作&lt;/strong>，这个操作会把信号量加上 1，相加后如果信号量 &amp;lt;= 0，则表明当前有阻塞中的进程，于是会将该进程唤醒运行；相加后如果信号量&amp;gt; 0，则表明当前没有阻塞中的进程；&lt;/li>
&lt;/ul>
&lt;p>P 操作是用在进入共享资源之前，V 操作是用在离开共享资源之后，这两个操作是必须成对出现的。&lt;/p>
&lt;p>接下来，举个例子，如果要使得两个进程互斥访问共享内存，我们可以初始化信号量为 &lt;code>1&lt;/code>。&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/iuxfg7/1619421762415-e1c7a414-1ecb-4d66-a920-881ebf3e3e85.png" alt="">&lt;/p>
&lt;p>具体的过程如下：&lt;/p>
&lt;ul>
&lt;li>进程 A 在访问共享内存前，先执行了 P 操作，由于信号量的初始值为 1，故在进程 A 执行 P 操作后信号量变为 0，表示共享资源可用，于是进程 A 就可以访问共享内存。&lt;/li>
&lt;li>若此时，进程 B 也想访问共享内存，执行了 P 操作，结果信号量变为了 -1，这就意味着临界资源已被占用，因此进程 B 被阻塞。&lt;/li>
&lt;li>直到进程 A 访问完共享内存，才会执行 V 操作，使得信号量恢复为 0，接着就会唤醒阻塞中的线程 B，使得进程 B 可以访问共享内存，最后完成共享内存的访问后，执行 V 操作，使信号量恢复到初始值 1。&lt;/li>
&lt;/ul>
&lt;p>可以发现，信号初始化为 &lt;code>1&lt;/code>，就代表着是&lt;strong>互斥信号量&lt;/strong>，它可以保证共享内存在任何时刻只有一个进程在访问，这就很好的保护了共享内存。&lt;/p>
&lt;p>另外，在多进程里，每个进程并不一定是顺序执行的，它们基本是以各自独立的、不可预知的速度向前推进，但有时候我们又希望多个进程能密切合作，以实现一个共同的任务。&lt;/p>
&lt;p>例如，进程 A 是负责生产数据，而进程 B 是负责读取数据，这两个进程是相互合作、相互依赖的，进程 A 必须先生产了数据，进程 B 才能读取到数据，所以执行是有前后顺序的。&lt;/p>
&lt;p>那么这时候，就可以用信号量来实现多进程同步的方式，我们可以初始化信号量为 &lt;code>0&lt;/code>。&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/iuxfg7/1619421762560-5bd9c203-120b-4f19-8bd1-4cf3bd2433d3.png" alt="">&lt;/p>
&lt;p>具体过程：&lt;/p>
&lt;ul>
&lt;li>如果进程 B 比进程 A 先执行了，那么执行到 P 操作时，由于信号量初始值为 0，故信号量会变为 -1，表示进程 A 还没生产数据，于是进程 B 就阻塞等待；&lt;/li>
&lt;li>接着，当进程 A 生产完数据后，执行了 V 操作，就会使得信号量变为 0，于是就会唤醒阻塞在 P 操作的进程 B；&lt;/li>
&lt;li>最后，进程 B 被唤醒后，意味着进程 A 已经生产了数据，于是进程 B 就可以正常读取数据了。&lt;/li>
&lt;/ul>
&lt;p>可以发现，信号初始化为 &lt;code>0&lt;/code>，就代表着是&lt;strong>同步信号量&lt;/strong>，它可以保证进程 A 应在进程 B 之前执行。&lt;/p>
&lt;h3 id="信号">信号&lt;/h3>
&lt;p>上面说的进程间通信，都是常规状态下的工作模式。&lt;strong>对于异常情况下的工作模式，就需要用「信号」的方式来通知进程。&lt;/strong>&lt;/p>
&lt;p>信号跟信号量虽然名字相似度 66.66%，但两者用途完全不一样，就好像 Java 和 JavaScript 的区别。&lt;/p>
&lt;p>在 Linux 操作系统中， 为了响应各种各样的事件，提供了几十种信号，分别代表不同的意义。我们可以通过 &lt;code>kill -l&lt;/code> 命令，查看所有的信号：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>root@lichenhao:~# kill -l
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> 1&lt;span style="color:#f92672">)&lt;/span> SIGHUP 2&lt;span style="color:#f92672">)&lt;/span> SIGINT 3&lt;span style="color:#f92672">)&lt;/span> SIGQUIT 4&lt;span style="color:#f92672">)&lt;/span> SIGILL 5&lt;span style="color:#f92672">)&lt;/span> SIGTRAP
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> 6&lt;span style="color:#f92672">)&lt;/span> SIGABRT 7&lt;span style="color:#f92672">)&lt;/span> SIGBUS 8&lt;span style="color:#f92672">)&lt;/span> SIGFPE 9&lt;span style="color:#f92672">)&lt;/span> SIGKILL 10&lt;span style="color:#f92672">)&lt;/span> SIGUSR1
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>11&lt;span style="color:#f92672">)&lt;/span> SIGSEGV 12&lt;span style="color:#f92672">)&lt;/span> SIGUSR2 13&lt;span style="color:#f92672">)&lt;/span> SIGPIPE 14&lt;span style="color:#f92672">)&lt;/span> SIGALRM 15&lt;span style="color:#f92672">)&lt;/span> SIGTERM
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>16&lt;span style="color:#f92672">)&lt;/span> SIGSTKFLT 17&lt;span style="color:#f92672">)&lt;/span> SIGCHLD 18&lt;span style="color:#f92672">)&lt;/span> SIGCONT 19&lt;span style="color:#f92672">)&lt;/span> SIGSTOP 20&lt;span style="color:#f92672">)&lt;/span> SIGTSTP
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>21&lt;span style="color:#f92672">)&lt;/span> SIGTTIN 22&lt;span style="color:#f92672">)&lt;/span> SIGTTOU 23&lt;span style="color:#f92672">)&lt;/span> SIGURG 24&lt;span style="color:#f92672">)&lt;/span> SIGXCPU 25&lt;span style="color:#f92672">)&lt;/span> SIGXFSZ
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>26&lt;span style="color:#f92672">)&lt;/span> SIGVTALRM 27&lt;span style="color:#f92672">)&lt;/span> SIGPROF 28&lt;span style="color:#f92672">)&lt;/span> SIGWINCH 29&lt;span style="color:#f92672">)&lt;/span> SIGIO 30&lt;span style="color:#f92672">)&lt;/span> SIGPWR
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>31&lt;span style="color:#f92672">)&lt;/span> SIGSYS 34&lt;span style="color:#f92672">)&lt;/span> SIGRTMIN 35&lt;span style="color:#f92672">)&lt;/span> SIGRTMIN+1 36&lt;span style="color:#f92672">)&lt;/span> SIGRTMIN+2 37&lt;span style="color:#f92672">)&lt;/span> SIGRTMIN+3
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>38&lt;span style="color:#f92672">)&lt;/span> SIGRTMIN+4 39&lt;span style="color:#f92672">)&lt;/span> SIGRTMIN+5 40&lt;span style="color:#f92672">)&lt;/span> SIGRTMIN+6 41&lt;span style="color:#f92672">)&lt;/span> SIGRTMIN+7 42&lt;span style="color:#f92672">)&lt;/span> SIGRTMIN+8
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>43&lt;span style="color:#f92672">)&lt;/span> SIGRTMIN+9 44&lt;span style="color:#f92672">)&lt;/span> SIGRTMIN+10 45&lt;span style="color:#f92672">)&lt;/span> SIGRTMIN+11 46&lt;span style="color:#f92672">)&lt;/span> SIGRTMIN+12 47&lt;span style="color:#f92672">)&lt;/span> SIGRTMIN+13
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>48&lt;span style="color:#f92672">)&lt;/span> SIGRTMIN+14 49&lt;span style="color:#f92672">)&lt;/span> SIGRTMIN+15 50&lt;span style="color:#f92672">)&lt;/span> SIGRTMAX-14 51&lt;span style="color:#f92672">)&lt;/span> SIGRTMAX-13 52&lt;span style="color:#f92672">)&lt;/span> SIGRTMAX-12
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>53&lt;span style="color:#f92672">)&lt;/span> SIGRTMAX-11 54&lt;span style="color:#f92672">)&lt;/span> SIGRTMAX-10 55&lt;span style="color:#f92672">)&lt;/span> SIGRTMAX-9 56&lt;span style="color:#f92672">)&lt;/span> SIGRTMAX-8 57&lt;span style="color:#f92672">)&lt;/span> SIGRTMAX-7
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>58&lt;span style="color:#f92672">)&lt;/span> SIGRTMAX-6 59&lt;span style="color:#f92672">)&lt;/span> SIGRTMAX-5 60&lt;span style="color:#f92672">)&lt;/span> SIGRTMAX-4 61&lt;span style="color:#f92672">)&lt;/span> SIGRTMAX-3 62&lt;span style="color:#f92672">)&lt;/span> SIGRTMAX-2
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>63&lt;span style="color:#f92672">)&lt;/span> SIGRTMAX-1 64&lt;span style="color:#f92672">)&lt;/span> SIGRTMAX
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>运行在 shell 终端的进程，我们可以通过键盘输入某些组合键的时候，给进程发送信号。例如&lt;/p>
&lt;ul>
&lt;li>Ctrl+C 产生 &lt;code>SIGINT&lt;/code> 信号，表示终止该进程；&lt;/li>
&lt;li>Ctrl+Z 产生 &lt;code>SIGTSTP&lt;/code> 信号，表示停止该进程，但还未结束；&lt;/li>
&lt;/ul>
&lt;p>如果进程在后台运行，可以通过 &lt;code>kill&lt;/code> 命令的方式给进程发送信号，但前提需要知道运行中的进程 PID 号，例如：&lt;/p>
&lt;ul>
&lt;li>kill -9 1050 ，表示给 PID 为 1050 的进程发送 &lt;code>SIGKILL&lt;/code> 信号，用来立即结束该进程；&lt;/li>
&lt;/ul>
&lt;p>所以，信号事件的来源主要有硬件来源（如键盘 Cltr+C ）和软件来源（如 kill 命令）。&lt;/p>
&lt;p>信号是进程间通信机制中&lt;strong>唯一的异步通信机制&lt;/strong>，因为可以在任何时候发送信号给某一进程，一旦有信号产生，我们就有下面这几种，用户进程对信号的处理方式。&lt;/p>
&lt;p>&lt;strong>1. 执行默认操作&lt;/strong>。Linux 对每种信号都规定了默认操作，例如，上面列表中的 SIGTERM 信号，就是终止进程的意思。Core 的意思是 Core Dump，也即终止进程后，通过 Core Dump 将当前进程的运行状态保存在文件里面，方便程序员事后进行分析问题在哪里。&lt;/p>
&lt;p>&lt;strong>2. 捕捉信号&lt;/strong>。我们可以为信号定义一个信号处理函数。当信号发生时，我们就执行相应的信号处理函数。&lt;/p>
&lt;p>&lt;strong>3. 忽略信号&lt;/strong>。当我们不希望处理某些信号的时候，就可以忽略该信号，不做任何处理。有两个信号是应用进程无法捕捉和忽略的，即 &lt;code>SIGKILL&lt;/code> 和 &lt;code>SEGSTOP&lt;/code>，它们用于在任何时候中断或结束某一进程。&lt;/p>
&lt;h3 id="socket">Socket&lt;/h3>
&lt;p>前面提到的管道、消息队列、共享内存、信号量和信号都是在同一台主机上进行进程间通信，那要想&lt;strong>跨网络与不同主机上的进程之间通信，就需要 Socket 通信了。&lt;/strong>&lt;/p>
&lt;p>实际上，Socket 通信不仅可以跨网络与不同主机的进程间通信，还可以在同主机上进程间通信。&lt;/p>
&lt;p>我们来看看创建 socket 的系统调用：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">int&lt;/span>&lt;span style="color:#960050;background-color:#1e0010"> &lt;/span>&lt;span style="color:#a6e22e">socket&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span>&lt;span style="color:#960050;background-color:#1e0010"> &lt;/span>&lt;span style="color:#a6e22e">domain&lt;/span>,&lt;span style="color:#960050;background-color:#1e0010"> &lt;/span>&lt;span style="color:#66d9ef">int&lt;/span>&lt;span style="color:#960050;background-color:#1e0010"> &lt;/span>&lt;span style="color:#66d9ef">type&lt;/span>,&lt;span style="color:#960050;background-color:#1e0010"> &lt;/span>&lt;span style="color:#66d9ef">int&lt;/span>&lt;span style="color:#960050;background-color:#1e0010"> &lt;/span>&lt;span style="color:#a6e22e">protocal&lt;/span>)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>三个参数分别代表：&lt;/p>
&lt;ul>
&lt;li>domain 参数用来指定协议族，比如 AF_INET 用于 IPV4、AF_INET6 用于 IPV6、AF_LOCAL/AF_UNIX 用于本机；&lt;/li>
&lt;li>type 参数用来指定通信特性，比如 SOCK_STREAM 表示的是字节流，对应 TCP、SOCK_DGRAM   表示的是数据报，对应 UDP、SOCK_RAW 表示的是原始套接字；&lt;/li>
&lt;li>protocal 参数原本是用来指定通信协议的，但现在基本废弃。因为协议已经通过前面两个参数指定完成，protocol 目前一般写成 0 即可；&lt;/li>
&lt;/ul>
&lt;p>根据创建 socket 类型的不同，通信的方式也就不同：&lt;/p>
&lt;ul>
&lt;li>实现 TCP 字节流通信：socket 类型是 AF_INET 和 SOCK_STREAM；&lt;/li>
&lt;li>实现 UDP 数据报通信：socket 类型是 AF_INET 和 SOCK_DGRAM；&lt;/li>
&lt;li>实现本地进程间通信：
&lt;ul>
&lt;li>「本地字节流 socket 」类型是 AF_LOCAL 和 SOCK_STREAM&lt;/li>
&lt;li>「本地数据报 socket 」类型是 AF_LOCAL 和 SOCK_DGRAM。另外，AF_UNIX 和 AF_LOCAL 是等价的，所以 AF_UNIX 也属于本地 socket；&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>接下来，简单说一下这三种通信的编程模式。&lt;/p>
&lt;blockquote>
&lt;p>针对 TCP 协议通信的 socket 编程模型&lt;/p>
&lt;/blockquote>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/iuxfg7/1619421762556-953130dd-bbfe-4a7d-ac0a-31c69ef31771.png" alt="">&lt;/p>
&lt;ul>
&lt;li>服务端和客户端初始化 &lt;code>socket&lt;/code>，得到文件描述符；&lt;/li>
&lt;li>服务端调用 &lt;code>bind&lt;/code>，将绑定在 IP 地址和端口;&lt;/li>
&lt;li>服务端调用 &lt;code>listen&lt;/code>，进行监听；&lt;/li>
&lt;li>服务端调用 &lt;code>accept&lt;/code>，等待客户端连接；&lt;/li>
&lt;li>客户端调用 &lt;code>connect&lt;/code>，向服务器端的地址和端口发起连接请求；&lt;/li>
&lt;li>服务端 &lt;code>accept&lt;/code> 返回用于传输的 &lt;code>socket&lt;/code> 的文件描述符；&lt;/li>
&lt;li>客户端调用 &lt;code>write&lt;/code> 写入数据；服务端调用 &lt;code>read&lt;/code> 读取数据；&lt;/li>
&lt;li>客户端断开连接时，会调用 &lt;code>close&lt;/code>，那么服务端 &lt;code>read&lt;/code> 读取数据的时候，就会读取到了 &lt;code>EOF&lt;/code>，待处理完数据后，服务端调用 &lt;code>close&lt;/code>，表示连接关闭。&lt;/li>
&lt;/ul>
&lt;p>这里需要注意的是，服务端调用 &lt;code>accept&lt;/code> 时，连接成功了会返回一个已完成连接的 socket，后续用来传输数据。&lt;/p>
&lt;p>所以，监听的 socket 和真正用来传送数据的 socket，是「&lt;strong>两个&lt;/strong>」 socket，一个叫作&lt;strong>监听 socket&lt;/strong>，一个叫作&lt;strong>已完成连接 socket&lt;/strong>。&lt;/p>
&lt;p>成功连接建立之后，双方开始通过 read 和 write 函数来读写数据，就像往一个文件流里面写东西一样。&lt;/p>
&lt;blockquote>
&lt;p>针对 UDP 协议通信的 socket 编程模型&lt;/p>
&lt;/blockquote>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/iuxfg7/1619421762345-95e531c1-8f0d-42d3-80d2-e8981177ed74.png" alt="">&lt;/p>
&lt;p>UDP 是没有连接的，所以不需要三次握手，也就不需要像 TCP 调用 listen 和 connect，但是 UDP 的交互仍然需要 IP 地址和端口号，因此也需要 bind。&lt;/p>
&lt;p>对于 UDP 来说，不需要要维护连接，那么也就没有所谓的发送方和接收方，甚至都不存在客户端和服务端的概念，只要有一个 socket 多台机器就可以任意通信，因此每一个 UDP 的 socket 都需要 bind。&lt;/p>
&lt;p>另外，每次通信时，调用 sendto 和 recvfrom，都要传入目标主机的 IP 地址和端口。&lt;/p>
&lt;blockquote>
&lt;p>针对本地进程间通信的 socket 编程模型&lt;/p>
&lt;/blockquote>
&lt;p>本地 socket   被用于在&lt;strong>同一台主机上进程间通信&lt;/strong>的场景：&lt;/p>
&lt;ul>
&lt;li>本地 socket 的编程接口和 IPv4 、IPv6 套接字编程接口是一致的，可以支持「字节流」和「数据报」两种协议；&lt;/li>
&lt;li>本地 socket 的实现效率大大高于 IPv4 和 IPv6 的字节流、数据报 socket 实现；&lt;/li>
&lt;/ul>
&lt;p>对于本地字节流 socket，其 socket 类型是 AF_LOCAL 和 SOCK_STREAM。&lt;/p>
&lt;p>对于本地数据报 socket，其 socket 类型是 AF_LOCAL 和 SOCK_DGRAM。&lt;/p>
&lt;p>本地字节流 socket 和 本地数据报 socket 在 bind 的时候，不像 TCP 和 UDP 要绑定 IP 地址和端口，而是&lt;strong>绑定一个本地文件&lt;/strong>，这也就是它们之间的最大区别。&lt;/p>
&lt;h3 id="总结">总结&lt;/h3>
&lt;p>由于每个进程的用户空间都是独立的，不能相互访问，这时就需要借助内核空间来实现进程间通信，原因很简单，每个进程都是共享一个内核空间。&lt;/p>
&lt;p>Linux 内核提供了不少进程间通信的方式，其中最简单的方式就是管道，管道分为「匿名管道」和「命名管道」。&lt;/p>
&lt;p>&lt;strong>匿名管道&lt;/strong>顾名思义，它没有名字标识，匿名管道是特殊文件只存在于内存，没有存在于文件系统中，shell 命令中的 &lt;code>|&lt;/code> 竖线就是匿名管道，通信的数据是&lt;strong>无格式的流并且大小受限&lt;/strong>，通信的方式是&lt;strong>单向&lt;/strong>的，数据只能在一个方向上流动，如果要双向通信，需要创建两个管道，再来&lt;strong>匿名管道是只能用于存在父子关系的进程间通信&lt;/strong>，匿名管道的生命周期随着进程创建而建立，随着进程终止而消失。&lt;/p>
&lt;p>&lt;strong>命名管道&lt;/strong>突破了匿名管道只能在亲缘关系进程间的通信限制，因为使用命名管道的前提，需要在文件系统创建一个类型为 p 的设备文件，那么毫无关系的进程就可以通过这个设备文件进行通信。另外，不管是匿名管道还是命名管道，进程写入的数据都是&lt;strong>缓存在内核&lt;/strong>中，另一个进程读取数据时候自然也是从内核中获取，同时通信数据都遵循&lt;strong>先进先出&lt;/strong>原则，不支持 lseek 之类的文件定位操作。&lt;/p>
&lt;p>&lt;strong>消息队列&lt;/strong>克服了管道通信的数据是无格式的字节流的问题，消息队列实际上是保存在内核的「消息链表」，消息队列的消息体是可以用户自定义的数据类型，发送数据时，会被分成一个一个独立的消息体，当然接收数据时，也要与发送方发送的消息体的数据类型保持一致，这样才能保证读取的数据是正确的。消息队列通信的速度不是最及时的，毕竟&lt;strong>每次数据的写入和读取都需要经过用户态与内核态之间的拷贝过程。&lt;/strong>&lt;/p>
&lt;p>&lt;strong>共享内存&lt;/strong>可以解决消息队列通信中用户态与内核态之间数据拷贝过程带来的开销，&lt;strong>它直接分配一个共享空间，每个进程都可以直接访问&lt;/strong>，就像访问进程自己的空间一样快捷方便，不需要陷入内核态或者系统调用，大大提高了通信的速度，享有&lt;strong>最快&lt;/strong>的进程间通信方式之名。但是便捷高效的共享内存通信，&lt;strong>带来新的问题，多进程竞争同个共享资源会造成数据的错乱。&lt;/strong>&lt;/p>
&lt;p>那么，就需要&lt;strong>信号量&lt;/strong>来保护共享资源，以确保任何时刻只能有一个进程访问共享资源，这种方式就是互斥访问。&lt;strong>信号量不仅可以实现访问的互斥性，还可以实现进程间的同步&lt;/strong>，信号量其实是一个计数器，表示的是资源个数，其值可以通过两个原子操作来控制，分别是 &lt;strong>P 操作和 V 操作&lt;/strong>。&lt;/p>
&lt;p>与信号量名字很相似的叫&lt;strong>信号&lt;/strong>，它俩名字虽然相似，但功能一点儿都不一样。信号是进程间通信机制中&lt;strong>唯一的异步通信机制&lt;/strong>，信号可以在应用进程和内核之间直接交互，内核也可以利用信号来通知用户空间的进程发生了哪些系统事件，信号事件的来源主要有硬件来源（如键盘 Cltr+C ）和软件来源（如 kill 命令），一旦有信号发生，&lt;strong>进程有三种方式响应信号 1. 执行默认操作、2. 捕捉信号、3. 忽略信号&lt;/strong>。有两个信号是应用进程无法捕捉和忽略的，即 &lt;code>SIGKILL&lt;/code> 和 &lt;code>SEGSTOP&lt;/code>，这是为了方便我们能在任何时候结束或停止某个进程。&lt;/p>
&lt;p>前面说到的通信机制，都是工作于同一台主机，如果&lt;strong>要与不同主机的进程间通信，那么就需要 Socket 通信了&lt;/strong>。Socket 实际上不仅用于不同的主机进程间通信，还可以用于本地主机进程间通信，可根据创建 Socket 的类型不同，分为三种常见的通信方式，一个是基于 TCP 协议的通信方式，一个是基于 UDP 协议的通信方式，一个是本地进程间通信方式。&lt;/p>
&lt;p>以上，就是进程间通信的主要机制了。你可能会问了，那线程通信间的方式呢？&lt;/p>
&lt;p>同个进程下的线程之间都是共享进程的资源，只要是共享变量都可以做到线程间通信，比如全局变量，所以对于线程间关注的不是通信方式，而是关注多线程竞争共享资源的问题，信号量也同样可以在线程间实现互斥与同步：&lt;/p>
&lt;ul>
&lt;li>互斥的方式，可保证任意时刻只有一个线程访问共享资源；&lt;/li>
&lt;li>同步的方式，可保证线程 A 应在线程 B 之前执行；&lt;/li>
&lt;/ul></description></item><item><title>Docs: RPC</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2.kernel%E5%86%85%E6%A0%B8/7.process-%E7%AE%A1%E7%90%86/inter-process-communication%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1/rpc/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2.kernel%E5%86%85%E6%A0%B8/7.process-%E7%AE%A1%E7%90%86/inter-process-communication%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1/rpc/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Remote_procedure_call">Wiki,RPC&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/GRPC">Wiki,gRPC&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://grpc.io/">gRPC 官网&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>在&lt;a href="https://en.wikipedia.org/wiki/Distributed_computing">分布式计算&lt;/a>中，&lt;strong>Remote Procedure Call(远程过程调用，简称 RPC)&lt;/strong> 是计算机程序使 &lt;a href="https://desistdaydream.github.io/docs/IT%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/2.%E7%BC%96%E7%A8%8B/%E8%A7%A3%E8%B0%9C%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/Function(%E5%87%BD%E6%95%B0)/Function(%E5%87%BD%E6%95%B0).md">Subroutine&lt;/a> 在不同的地址空间（通常在共享网络上的另一台计算机上）执行时，被编码为 &lt;strong>Local Procedure Call(本地过程调用)&lt;/strong>，而无需程序员为远程交互显式编写细节。也就是说，程序员可以为程序编写相同的代码，而不用关心自己编写的程序将会被本地调用还是远程调用。&lt;/p>
&lt;p>其实 LPC 和 RPC 并不是对比的最佳选择，两者都 IPC 的一种方式，也就是说都是两个进程间通讯的一种方式，可能来说，LPC 与 RPC 最大的区别在于是否基于 TCP/IP 来让两个进程进行通信。而如果从网络间两个进程通信的角度看，RPC 又可以与 HTTP 进行对比。&lt;/p>
&lt;p>从某种角度来说， HTTP 其实就是一种 RPC&lt;/p>
&lt;ul>
&lt;li>HTTP 发起请求的 URL 就是 RPC 发起请求的函数名&lt;/li>
&lt;li>请求体就是函数的参数&lt;/li>
&lt;li>响应体就是函数的函数中的处理逻辑或返回值&lt;/li>
&lt;/ul>
&lt;p>只不过 HTTP 是一个协议(也可以说是一种交互标准)，而 RPC 是一种方式、方法，可以使用 HTTP 来进行 RPC 通信，也可以使用其他协议进行 RPC 通信。如果使用 HTTP 标准进行 RPC 通信，那 RPC 的 C/S 之间就是通过文本格式进行交互；但是 RPC 通信最常使用的是 Protobuf 数据格式进行通信。&lt;/p>
&lt;blockquote>
&lt;p>这里说的使用“HTTP 进行 RPC 通信”指的是使用 xml、json 等格式的数据进行 RPC 通信。而在很多 RPC 框架中，RPC 之间交互的信息与 HTTP 之间交互的信息，是可以互通的！~&lt;/p>
&lt;/blockquote>
&lt;p>&lt;strong>RPC 最常见的场景就是“微服务”&lt;/strong>，将一个大而全的产品拆分成多个服务，如果通过 HTTP 调用，那么调用函数时就需要转换为调用 URL，对于关联性非常难强的多个服务来说，这种交互是灾难性的，如果网络上的多个服务之间，可以直接通过函数调用，那么代码写起来，也是非常简洁的。&lt;/p>
&lt;p>通常来说，如果想要调用第三方平台提供的接口，使用 HTTP，而一个产品中关联性非常强，甚至可以合并成一个服务的多个服务之间的接口调用，就要使用 RPC 了，公司内服务之间的 RPC 调用，可以通过定制化的协议来使得通信更高效。&lt;/p></description></item><item><title>Docs: RPC</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2.kernel%E5%86%85%E6%A0%B8/7.process-%E7%AE%A1%E7%90%86/inter-process-communication%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1/rpc/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2.kernel%E5%86%85%E6%A0%B8/7.process-%E7%AE%A1%E7%90%86/inter-process-communication%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1/rpc/</guid><description/></item><item><title>Docs: Signal(信号)</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2.kernel%E5%86%85%E6%A0%B8/7.process-%E7%AE%A1%E7%90%86/inter-process-communication%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1/signal%E4%BF%A1%E5%8F%B7/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2.kernel%E5%86%85%E6%A0%B8/7.process-%E7%AE%A1%E7%90%86/inter-process-communication%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1/signal%E4%BF%A1%E5%8F%B7/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Signal">Wiki,Signal&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>&lt;strong>Signal(信号)&lt;/strong> 是 &lt;a href="https://www.yuque.com/go/doc/33222674">IPC(进程间通信)&lt;/a> 的一种受限形式。信号是发送到进程或同一进程内的特定线程的异步通知，目的是将发生的事件通知给它。发送信号后，操作系统会中断目标进程的正常执行流程以传递信号。在任何非原子指令中，执行都可以中断。如果该进程先前已注册了&lt;strong>信号处理程序&lt;/strong>，则将执行该例程。否则，将执行默认信号处理程序。&lt;/p>
&lt;p>信号类似于中断，区别在于中断由处理器介导并由内核处理，而信号由内核介导（可能通过系统调用）并由进程处理。内核可能会将中断作为信号传递给引起中断的进程（典型示例为 SIGSEGV，SIGBUS，SIGILL 和 SIGFPE）。&lt;/p>
&lt;p>信号类型&lt;/p>
&lt;p>Linux 系统共定义了 64 种信号，分为两大类：可靠信号与不可靠信号，前 32 种信号为不可靠信号，后 32 种为可靠信号。&lt;/p>
&lt;p>1.1 概念&lt;/p>
&lt;ul>
&lt;li>
&lt;p>不可靠信号： 也称为非实时信号，不支持排队，信号可能会丢失, 比如发送多次相同的信号, 进程只能收到一次. 信号值取值区间为 1~31；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>可靠信号： 也称为实时信号，支持排队, 信号不会丢失, 发多少次, 就可以收到多少次. 信号值取值区间为 32~64&lt;/p>
&lt;p>1.2 信号表&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>在终端，可通过 kill -l 查看所有的 signal 信号&lt;/p>
&lt;blockquote>
&lt;p>使用时，这些信号开头的 3 个大写字符(SIG)可以省略&lt;/p>
&lt;/blockquote>
&lt;pre>&lt;code>[root@master-1 libexec]# kill -l
1) SIGHUP 2) SIGINT 3) SIGQUIT 4) SIGILL 5) SIGTRAP
6) SIGABRT 7) SIGBUS 8) SIGFPE 9) SIGKILL 10) SIGUSR1
11) SIGSEGV 12) SIGUSR2 13) SIGPIPE 14) SIGALRM 15) SIGTERM
16) SIGSTKFLT 17) SIGCHLD 18) SIGCONT 19) SIGSTOP 20) SIGTSTP
21) SIGTTIN 22) SIGTTOU 23) SIGURG 24) SIGXCPU 25) SIGXFSZ
26) SIGVTALRM 27) SIGPROF 28) SIGWINCH 29) SIGIO 30) SIGPWR
31) SIGSYS 34) SIGRTMIN 35) SIGRTMIN+1 36) SIGRTMIN+2 37) SIGRTMIN+3
38) SIGRTMIN+4 39) SIGRTMIN+5 40) SIGRTMIN+6 41) SIGRTMIN+7 42) SIGRTMIN+8
43) SIGRTMIN+9 44) SIGRTMIN+10 45) SIGRTMIN+11 46) SIGRTMIN+12 47) SIGRTMIN+13
48) SIGRTMIN+14 49) SIGRTMIN+15 50) SIGRTMAX-14 51) SIGRTMAX-13 52) SIGRTMAX-12
53) SIGRTMAX-11 54) SIGRTMAX-10 55) SIGRTMAX-9 56) SIGRTMAX-8 57) SIGRTMAX-7
58) SIGRTMAX-6 59) SIGRTMAX-5 60) SIGRTMAX-4 61) SIGRTMAX-3 62) SIGRTMAX-2
63) SIGRTMAX-1 64) SIGRTMAX
&lt;/code>&lt;/pre>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>取值&lt;/th>
&lt;th>名称&lt;/th>
&lt;th>解释&lt;/th>
&lt;th>默认动作&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>1&lt;/td>
&lt;td>SIGHUP&lt;/td>
&lt;td>挂起&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>2&lt;/td>
&lt;td>SIGINT&lt;/td>
&lt;td>中断&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>3&lt;/td>
&lt;td>SIGQUIT&lt;/td>
&lt;td>退出&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>4&lt;/td>
&lt;td>SIGILL&lt;/td>
&lt;td>非法指令&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>5&lt;/td>
&lt;td>SIGTRAP&lt;/td>
&lt;td>断点或陷阱指令&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>6&lt;/td>
&lt;td>SIGABRT&lt;/td>
&lt;td>abort 发出的信号&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>7&lt;/td>
&lt;td>SIGBUS&lt;/td>
&lt;td>非法内存访问&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>8&lt;/td>
&lt;td>SIGFPE&lt;/td>
&lt;td>浮点异常&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>9&lt;/td>
&lt;td>SIGKILL&lt;/td>
&lt;td>kill 信号&lt;/td>
&lt;td>不能被忽略、处理和阻塞&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>10&lt;/td>
&lt;td>SIGUSR1&lt;/td>
&lt;td>用户信号 1&lt;/td>
&lt;td>程序自定义的信号，常用这种信号来处理日志或加载配置文件。比如 docker 用这种信号来生成日志&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>11&lt;/td>
&lt;td>SIGSEGV&lt;/td>
&lt;td>无效内存访问&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>12&lt;/td>
&lt;td>SIGUSR2&lt;/td>
&lt;td>用户信号 2&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>13&lt;/td>
&lt;td>SIGPIPE&lt;/td>
&lt;td>管道破损，没有读端的管道写数据&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>14&lt;/td>
&lt;td>SIGALRM&lt;/td>
&lt;td>alarm 发出的信号&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>15&lt;/td>
&lt;td>SIGTERM&lt;/td>
&lt;td>终止信号&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>16&lt;/td>
&lt;td>SIGSTKFLT&lt;/td>
&lt;td>栈溢出&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>17&lt;/td>
&lt;td>SIGCHLD&lt;/td>
&lt;td>子进程退出&lt;/td>
&lt;td>默认忽略&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>18&lt;/td>
&lt;td>SIGCONT&lt;/td>
&lt;td>进程继续&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>19&lt;/td>
&lt;td>SIGSTOP&lt;/td>
&lt;td>进程停止&lt;/td>
&lt;td>不能被忽略、处理和阻塞&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>20&lt;/td>
&lt;td>SIGTSTP&lt;/td>
&lt;td>进程停止&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>21&lt;/td>
&lt;td>SIGTTIN&lt;/td>
&lt;td>进程停止，后台进程从终端读数据时&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>22&lt;/td>
&lt;td>SIGTTOU&lt;/td>
&lt;td>进程停止，后台进程想终端写数据时&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>23&lt;/td>
&lt;td>SIGURG&lt;/td>
&lt;td>I/O 有紧急数据到达当前进程&lt;/td>
&lt;td>默认忽略&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>24&lt;/td>
&lt;td>SIGXCPU&lt;/td>
&lt;td>进程的 CPU 时间片到期&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>25&lt;/td>
&lt;td>SIGXFSZ&lt;/td>
&lt;td>文件大小的超出上限&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>26&lt;/td>
&lt;td>SIGVTALRM&lt;/td>
&lt;td>虚拟时钟超时&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>27&lt;/td>
&lt;td>SIGPROF&lt;/td>
&lt;td>profile 时钟超时&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>28&lt;/td>
&lt;td>SIGWINCH&lt;/td>
&lt;td>窗口大小改变&lt;/td>
&lt;td>默认忽略&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>29&lt;/td>
&lt;td>SIGIO&lt;/td>
&lt;td>I/O 相关&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>30&lt;/td>
&lt;td>SIGPWR&lt;/td>
&lt;td>关机&lt;/td>
&lt;td>默认忽略&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>31&lt;/td>
&lt;td>SIGSYS&lt;/td>
&lt;td>系统调用异常&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>对于 signal 信号，绝大部分的默认处理都是终止进程或停止进程，或 dump 内核映像转储。 上述的 31 的信号为非实时信号，其他的信号 32-64 都是实时信号。&lt;/p>
&lt;h2 id="信号产生">信号产生&lt;/h2>
&lt;p>信号来源分为硬件类和软件类：&lt;/p>
&lt;p>2.1 硬件方式&lt;/p>
&lt;ul>
&lt;li>
&lt;p>用户输入：比如在终端上按下组合键 ctrl+C，产生 SIGINT 信号；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>硬件异常：CPU 检测到内存非法访问等异常，通知内核生成相应信号，并发送给发生事件的进程；&lt;/p>
&lt;p>2.2 软件方式&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>通过系统调用，发送 signal 信号：kill()，raise()，sigqueue()，alarm()，setitimer()，abort()&lt;/p>
&lt;ul>
&lt;li>
&lt;p>kernel,使用 kill_proc_info(）等&lt;/p>
&lt;/li>
&lt;li>
&lt;p>native,使用 kill() 或者 raise()等&lt;/p>
&lt;/li>
&lt;li>
&lt;p>java,使用 Procees.sendSignal()等&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h2 id="信号注册和注销">信号注册和注销&lt;/h2>
&lt;p>3.1 注册&lt;/p>
&lt;p>在进程 task_struct 结构体中有一个未决信号的成员变量 struct sigpending pending。每个信号在进程中注册都会把信号值加入到进程的未决信号集。&lt;/p>
&lt;ul>
&lt;li>
&lt;p>非实时信号发送给进程时，如果该信息已经在进程中注册过，不会再次注册，故信号会丢失；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>实时信号发送给进程时，不管该信号是否在进程中注册过，都会再次注册。故信号不会丢失；&lt;/p>
&lt;p>3.2 注销&lt;/p>
&lt;/li>
&lt;li>
&lt;p>非实时信号：不可重复注册，最多只有一个 sigqueue 结构；当该结构被释放后，把该信号从进程未决信号集中删除，则信号注销完毕；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>实时信号：可重复注册，可能存在多个 sigqueue 结构；当该信号的所有 sigqueue 处理完毕后，把该信号从进程未决信号集中删除，则信号注销完毕；&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h2 id="信号处理">信号处理&lt;/h2>
&lt;p>内核处理进程收到的 signal 是在当前进程的上下文，故进程必须是 Running 状态。当进程唤醒或者调度后获取 CPU，则会从内核态转到用户态时检测是否有 signal 等待处理，处理完，进程会把相应的未决信号从链表中去掉。&lt;/p>
&lt;p>4.1 处理时机&lt;/p>
&lt;p>signal 信号处理时机： 内核态 -&amp;gt; signal 信号处理 -&amp;gt; 用户态：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>在内核态，signal 信号不起作用；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>在用户态，signal 所有未被屏蔽的信号都处理完毕；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>当屏蔽信号，取消屏蔽时，会在下一次内核转用户态的过程中执行；&lt;/p>
&lt;p>4.2 处理方式&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>进程对信号的处理方式： 有 3 种&lt;/p>
&lt;ul>
&lt;li>
&lt;p>默认 接收到信号后按默认的行为处理该信号。 这是多数应用采取的处理方式。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>自定义 用自定义的信号处理函数来执行特定的动作&lt;/p>
&lt;/li>
&lt;li>
&lt;p>忽略 接收到信号后不做任何反应。&lt;/p>
&lt;p>4.3 信号安装&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>进程处理某个信号前，需要先在进程中安装此信号。安装过程主要是建立信号值和进程对相应信息值的动作。&lt;/p>
&lt;p>信号安装函数&lt;/p>
&lt;ul>
&lt;li>
&lt;p>signal()：不支持信号传递信息，主要用于非实时信号安装；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>sigaction():支持信号传递信息，可用于所有信号安装；&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>其中 sigaction 结构体&lt;/p>
&lt;ul>
&lt;li>
&lt;p>sa_handler:信号处理函数&lt;/p>
&lt;/li>
&lt;li>
&lt;p>sa_mask：指定信号处理程序执行过程中需要阻塞的信号；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>sa_flags：标示位&lt;/p>
&lt;/li>
&lt;li>
&lt;p>SA_RESTART：使被信号打断的 syscall 重新发起。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>SA_NOCLDSTOP：使父进程在它的子进程暂停或继续运行时不会收到 SIGCHLD 信号。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>SA_NOCLDWAIT：使父进程在它的子进程退出时不会收到 SIGCHLD 信号，这时子进程如果退出也不会成为僵 尸进程。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>SA_NODEFER：使对信号的屏蔽无效，即在信号处理函数执行期间仍能发出这个信号。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>SA_RESETHAND：信号处理之后重新设置为默认的处理方式。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>SA_SIGINFO：使用 sa_sigaction 成员而不是 sa_handler 作为信号处理函数。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>函数原型：&lt;/p>
&lt;p>int sigaction(int signum, const struct sigaction *act, struct sigaction *oldact);&lt;/p>
&lt;ul>
&lt;li>
&lt;p>signum：要操作的 signal 信号。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>act：设置对 signal 信号的新处理方式。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>oldact：原来对信号的处理方式。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>返回值：0 表示成功，-1 表示有错误发生。&lt;/p>
&lt;p>4.4 信号发送&lt;/p>
&lt;/li>
&lt;li>
&lt;p>kill()：用于向进程或进程组发送信号；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>sigqueue()：只能向一个进程发送信号，不能像进程组发送信号；主要针对实时信号提出，与 sigaction()组合使用，当然也支持非实时信号的发送；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>alarm()：用于调用进程指定时间后发出 SIGALARM 信号；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>setitimer()：设置定时器，计时达到后给进程发送 SIGALRM 信号，功能比 alarm 更强大；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>abort()：向进程发送 SIGABORT 信号，默认进程会异常退出。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>raise()：用于向进程自身发送信号；&lt;/p>
&lt;p>4.5 信号相关函数&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>信号集操作函数&lt;/p>
&lt;ul>
&lt;li>
&lt;p>sigemptyset(sigset_t *set)：信号集全部清 0；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>sigfillset(sigset_t *set)： 信号集全部置 1，则信号集包含 linux 支持的 64 种信号；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>sigaddset(sigset_t *set, int signum)：向信号集中加入 signum 信号；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>sigdelset(sigset_t *set, int signum)：向信号集中删除 signum 信号；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>sigismember(const sigset_t *set, int signum)：判定信号 signum 是否存在信号集中。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>信号阻塞函数&lt;/p>
&lt;ul>
&lt;li>
&lt;p>sigprocmask(int how, const sigset_t *set, sigset_t *oldset))； 不同 how 参数，实现不同功能&lt;/p>
&lt;/li>
&lt;li>
&lt;p>SIG_BLOCK：将 set 指向信号集中的信号，添加到进程阻塞信号集；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>SIG_UNBLOCK：将 set 指向信号集中的信号，从进程阻塞信号集删除；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>SIG_SETMASK：将 set 指向信号集中的信号，设置成进程阻塞信号集；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>sigpending(sigset_t *set))：获取已发送到进程，却被阻塞的所有信号；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>sigsuspend(const sigset_t *mask))：用 mask 代替进程的原有掩码，并暂停进程执行，直到收到信号再恢复原有掩码并继续执行进程。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h1 id="kill-命令行工具--用来将指定的信号发送到指定的进程或进程组">kill 命令行工具 # 用来将指定的信号发送到指定的进程或进程组&lt;/h1>
&lt;p>kill 命令将指定的信号发送到指定的进程或进程组。 如果未指定信号，则发送 TERM 信号。 TERM 信号将杀死不捕获该信号的进程。对于其他过程，由于无法捕获该信号，可能需要使用 KILL（9）信号。&lt;/p>
&lt;p>大多数现代 Shell 具有内置的 kill 函数，其用法与此处描述的命令非常相似。 &amp;lsquo;-a&amp;rsquo; 和&amp;rsquo;-p&amp;rsquo; 选项以及通过命令名称指定进程的可能性是 本地扩展。&lt;/p>
&lt;p>如果 sig 为 0，则不发送信号，但仍执行错误检查。&lt;/p>
&lt;p>“信号 0”有点像精神上的“ ping”。在 shell 程序脚本中使用 kill -0 PID 是判断 PID 是否有效的好方法。信号 0 仅用于检查进程是否存在。&lt;/p>
&lt;h2 id="kill--s-signal-p--q-sigval--a----pid">kill [-s signal|-p] [-q sigval] [-a] [&amp;ndash;] pid&amp;hellip;&lt;/h2>
&lt;p>kill -l [signal]&lt;/p></description></item><item><title>Docs: Socket(套接字)</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2.kernel%E5%86%85%E6%A0%B8/7.process-%E7%AE%A1%E7%90%86/inter-process-communication%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1/socket%E5%A5%97%E6%8E%A5%E5%AD%97/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2.kernel%E5%86%85%E6%A0%B8/7.process-%E7%AE%A1%E7%90%86/inter-process-communication%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1/socket%E5%A5%97%E6%8E%A5%E5%AD%97/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Socket">Wiki,Socket&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Unix_domain_socket">Wiki,Unix domain Socket&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Network_socket">Wiki,Network Scoket&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>&lt;strong>Socket(套接字)&lt;/strong> &lt;strong>是数据通信的基石&lt;/strong>。是计算机领域中数据通信的一种约定，或者说是一种方法。通过 Socket 这种方法，计算机内的进程可以互相交互数据，不同计算机之间也可以互相交互数据。&lt;/p>
&lt;p>Socket(套接字) 原意是&lt;code>插座&lt;/code>，所以 Socket 就像插座的作用一样，只要把插头插上，就能让设备获得电力。同理，只要两个程序通过 Socket 互相套接，也就是说两个程序都插在同一个 Socket 上，那么这两个程序就能交互数据。&lt;/p>
&lt;p>在计算机领域，Socket 有多种类型&lt;/p>
&lt;ul>
&lt;li>&lt;strong>Unix Domain Socket(简称 UDS)&lt;/strong> # 用于同一台设备的不同进程间互相通信&lt;/li>
&lt;li>&lt;strong>Network Socket&lt;/strong> # 用于进程在网络间互相通信&lt;/li>
&lt;li>&lt;strong>Berkeley Sockets API&lt;/strong> # Unix Domain Socket 与 Network Socket 的 API&lt;/li>
&lt;/ul>
&lt;p>在软件上，Socket 负责套接计算机中的数据(可以想象成套接管，套接管即为套管，是用来把两个管连接起来的东西，套接字就是把计算机中的字(即最小数据)连接起来，且只把头部连接起来，套管也是，只把两根很长的管的头端套起来接上)&lt;/p>
&lt;ol>
&lt;li>在系统层面，socket 可以连接系统中的两个进程，进程与进程本身是互相独立的，如果需要传递消息，那么就需要两个进程各自打开一个接口(API)，socket 把两个进程的 api 套住使之连接起来，即可实现进程间的通信。该 socket 是抽象的，虚拟的，只是通过编程函数来实现进程的 API 功能，如果进程没有 API，那么就无法通过 socket 与其余进程通信。&lt;/li>
&lt;li>当然，一个进程也可以监听一个名为 _.scok 的文件，这个文件就像 API 一样，其他程序想与该进程交互，只要指定该 _.sock 文件，然后对这个 sock 文件进行读写即可。&lt;/li>
&lt;li>在网络层面，socket 负责把不在同一主机上的进程(比如主机 A 的进程 C 和主机 B 的进程 D)连接起来，而两个不同主机上的进程如何被套接起来呢，套接至少需要提供一个头端来让套接管(字)包裹住才行。这时候(协议，IP，端口,例如：ftp://192.168.0.1:22)共同组成了网络上的进程标示，该进程逻辑上的头端即为紫色部分的端口号，不同主机的两个进程可以通过套接字把端口号套起来连接，来使两个网络上不同主机的进程进行通信，该同能同样是在程序编程的时候用函数写好的，程序启动为进程的时候，则该接口会被拿出来监听。&lt;/li>
&lt;/ol>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/nlg3b5/1619421243110-2db70bc6-f358-459c-b9a9-e199658b151a.png" alt="">
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/nlg3b5/1619421247179-b40abf99-2621-4f4e-aa6e-1d68bfe9e74b.png" alt="">&lt;/p>
&lt;h2 id="unix-domain-socket">Unix Domain Socket&lt;/h2>
&lt;p>&lt;strong>Unix Domain Socket&lt;/strong> 是 &lt;strong>IPC&lt;/strong> 的一种实现方式。Socket 原本是为了网络通信设计的，但后来在 Socket 的框架上发展出一种 IPC 机制，就是 Unix Domain Socket。虽然 Netork Socket 也可用于统一台主机的进程间通信(通过 loopback 地址 127.0.0.1)，但是 Unix Domain Socket 用于 IPC 更有效率，因为不需要经过网络协议栈，不需要打包拆包、计算校验和、维护序号和应答等，只是将应用层数据从一个进程拷贝到另一个进程。这是因为 IPC 机制本质上是可靠的通讯，而网络协议是为不可靠通讯设计的。&lt;/p>
&lt;p>Unix Domain Socket 是全双工的，API 接口语义丰富，相比其它 IPC 机制有明显的优越性，目前已成为使用最广泛的 IPC 机制，比如 X Window 服务器和 GUI 程序之间就是通过 UNIX domain socket 通讯的。&lt;/p>
&lt;p>Unix domain socket 是 POSIX 标准中的一个组件，所以不要被名字迷惑，linux 系统也是支持它的。&lt;/p>
&lt;h2 id="network-socket">Network Socket&lt;/h2>
&lt;p>详见 [Network Socket](✏IT 学习笔记/🌐4.数据通信/数据通信/Network%20Socket.md Socket.md)&lt;/p>
&lt;h2 id="berkeley-sockets-api">Berkeley Sockets API&lt;/h2>
&lt;p>**Berkeley Sockets **是 Network Socket 和 Unix Domain Sockets 的 应用程序编程接口（API），用于进程间通信（IPC）。通常将其实现为可链接模块的库。它起源于 1983 年发布的 4.2BSD Unix 操作系统。&lt;/p>
&lt;p>套接字是网络通信路径的本地终结点的抽象表示（句柄）。Berkeley 套接字 API 将其表示为 Unix 哲学中的文件描述符（文件句柄），该描述符为输入和输出到数据流提供通用接口。&lt;/p>
&lt;p>伯克利套接字几乎没有任何改动，从_事实上的_标准演变为 POSIX 规范的组件。术语 **POSIX 套接字 **在本质上是_Berkeley 套接字的_同义词，但是它们也称为_BSD 套接字_，这是对 Berkeley Software Distribution 中的第一个实现的认可。&lt;/p></description></item><item><title>Docs: Socket(套接字)</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2.kernel%E5%86%85%E6%A0%B8/7.process-%E7%AE%A1%E7%90%86/inter-process-communication%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1/socket%E5%A5%97%E6%8E%A5%E5%AD%97/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2.kernel%E5%86%85%E6%A0%B8/7.process-%E7%AE%A1%E7%90%86/inter-process-communication%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1/socket%E5%A5%97%E6%8E%A5%E5%AD%97/</guid><description/></item></channel></rss>