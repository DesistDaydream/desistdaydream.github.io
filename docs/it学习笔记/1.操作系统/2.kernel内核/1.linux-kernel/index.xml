<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>断念梦 – Linux Kernel</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2.kernel%E5%86%85%E6%A0%B8/1.linux-kernel/</link><description>Recent content in Linux Kernel on 断念梦</description><generator>Hugo -- gohugo.io</generator><atom:link href="https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2.kernel%E5%86%85%E6%A0%B8/1.linux-kernel/index.xml" rel="self" type="application/rss+xml"/><item><title>Docs: 1.Linux Kernel</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2.kernel%E5%86%85%E6%A0%B8/1.linux-kernel/1.linux-kernel/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2.kernel%E5%86%85%E6%A0%B8/1.linux-kernel/1.linux-kernel/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://github.com/torvalds">Linus Torvalds&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://github.com/torvalds/linux">GitHub,Linux 内核项目&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.kernel.org/">官网&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.kernel.org/doc/html/latest/">官方文档&lt;/a>
&lt;ul>
&lt;li>&lt;a href="https://www.infradead.org/~mchehab/kernel_docs/index.html">https://www.infradead.org/~mchehab/kernel_docs/index.html&lt;/a> 这是哪里的官方文档？&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;a href="https://www.kernel.org/doc/man-pages/index.html">官方 Manual(手册)&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Kernel_(operating_system)">Wiki,Kernel&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki//boot/">Wiki,/boot&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Vmlinux">Wiki,vmlinux&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Initial_ramdisk">Wiki,Initial ramdisk&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/System.map">Wiki,System.map&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://github.com/raspberrypi/linux">树莓派 Linux&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/8/html/managing_monitoring_and_updating_the_kernel/index">RedHat 官方文档,8-管理、监控和更新内核&lt;/a>&lt;/li>
&lt;li>&lt;a href="http://www.linfo.org/vmlinuz.html">http://www.linfo.org/vmlinuz.html&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.zhihu.com/question/22045825">知乎,initrd 和 initramfs 的区别&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>&lt;strong>Kernel(内核)&lt;/strong> 是一个作为操作系统核心的计算机程序，对系统中的一切具有完全控制权。它负责管理系统的进程、内存、设备驱动程序、文件和网络系统，决定着系统的性能和稳定性。&lt;/p>
&lt;p>Kernel 是计算器启动时首先加载程序之一(在 &lt;a href="https://desistdaydream.github.io/docs/IT%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/1.Bootloader/1.Bootloader.md">Bootloader&lt;/a>并处理硬件和软件之间的交互。并且处理启动过程的其余部分、以及内存、外设、和来自软件的输入/输出请求，将他们转换为 CPU 的数据处理指令。&lt;/p>
&lt;h2 id="kernel-组成及系统调用">Kernel 组成及系统调用&lt;/h2>
&lt;p>Linux 内核由如下几部分组成：内存管理、进程管理、设备驱动程序管理、文件系统管理、网络管理等。如图：
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/fkp6xi/1616168349819-c21dd43c-79b7-4ec2-abd4-c8bb0e3c7686.jpeg" alt="">
**System Call Interface(系统调用接口，简称 SCI) **层提供了某些机制执行从用户空间到内核的函数调用。这个接口依赖于体系结构，甚至在相同的处理器家族内也是如此。SCI 实际上是一个非常有用的函数调用多路复用和多路分解服务。&lt;/p>
&lt;p>系统调用介绍详见 &lt;a href="https://desistdaydream.github.io/docs/IT%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2.Kernel(%E5%86%85%E6%A0%B8)/3.System%20Call/System%20Call.md">System Call(系统调用)&lt;/a> 章节&lt;/p>
&lt;h2 id="linux-man-手册使用说明">Linux man 手册使用说明&lt;/h2>
&lt;p>在 Linux Kernel 的官方 man 手册中，记录了用户空间程序使用 Linux 内核 和 C 库的接口。对于 C 库，主要聚焦于 GUN C(glibc)，尽管在已知的情况下，还包括可用于 Linux 的其他 C 库中的变体文档。在这个 man 手册中，分为如下几部分&lt;/p>
&lt;ul>
&lt;li>&lt;strong>&lt;a href="https://man7.org/linux/man-pages/dir_section_1.html">User commands&lt;/a>(用户命令)&lt;/strong> # 介绍一些用户空间的应用程序。&lt;/li>
&lt;li>&lt;strong>&lt;a href="https://man7.org/linux/man-pages/dir_section_2.html">System calls&lt;/a>(系统调用)&lt;/strong> # Linux Kernel 可以提供的所有 System Calls(系统调用)&lt;/li>
&lt;li>&lt;strong>&lt;a href="https://man7.org/linux/man-pages/dir_section_3.html">Library functions&lt;/a>(库函数)&lt;/strong> # C 标准库可以提供的函数。&lt;/li>
&lt;li>&lt;strong>&lt;a href="https://man7.org/linux/man-pages/dir_section_4.html">Devices&lt;/a>(设备)&lt;/strong> # 各种设备的详细信息，这些设备大多都在 /dev 目录中。&lt;/li>
&lt;li>&lt;strong>&lt;a href="https://man7.org/linux/man-pages/dir_section_5.html">Files&lt;/a>(文件)&lt;/strong> # 各种文件格式和文件系统&lt;/li>
&lt;li>&lt;strong>&lt;a href="https://man7.org/linux/man-pages/dir_section_7.html">Overviews, conventions, and miscellaneous&lt;/a>(概述、约定 和 其他)&lt;/strong> #&lt;/li>
&lt;li>&lt;strong>&lt;a href="https://man7.org/linux/man-pages/dir_section_8.html">Superuser and system administration commands&lt;/a>(超级用户和系统管理员命令)&lt;/strong> # 介绍一些 GUN C 库提供的程序。&lt;/li>
&lt;/ul>
&lt;p>在 Linux man 手册中，可以找到 Linux 系统中的一切使用说明。Linux 操作系统围绕 Linux Kernel 构建了一套高效、健壮的应用程序运行环境&lt;/p>
&lt;h1 id="intirdimgvmlinuzsystemmap-文件">intird.img、vmlinuz、System.map 文件&lt;/h1>
&lt;p>Kernel 会被安装到 /boot 目录中，并生成 &lt;strong>config、initrd.img、System.map、vmlinuz&lt;/strong> 这几个文件&lt;/p>
&lt;h2 id="vmlinuz">vmlinuz&lt;/h2>
&lt;p>vmlinuz 是 &lt;a href="http://www.linfo.org/linuxdef.html">Linux&lt;/a> &lt;a href="http://www.linfo.org/kernel.html">&lt;em>内核&lt;/em>&lt;/a> 可执行文件的名称。&lt;/p>
&lt;p>vmlinuz 是一个压缩的 Linux 内核，它是_可引导的_。可引导意味着它能够将操作系统加载到内存中，以便计算机变得可用并且可以运行应用程序。&lt;/p>
&lt;p>vmlinuz 不应与_vmlinux_混淆，后者是非压缩和不可引导形式的内核。vmlinux 通常只是生成 vmlinuz 的中间步骤。&lt;/p>
&lt;p>vmlinuz 位于 /boot 目录中，该目录包含开始引导系统所需的文件。名为 vmlinuz 的文件可能是实际的内核可执行文件本身，也可能是内核可执行文件的链接，该链接可能带有诸如 &lt;code>/boot/vmlinuz-2.4.18-19.8.0&lt;/code> 之类的名称（即特定内核的名称）内核版本）。这可以通过使用 ls &lt;a href="http://www.linfo.org/command.html">命令&lt;/a>（其目的是列出指定目录的内容）及其 -l 选项（它告诉 ls 提供有关指定目录中每个对象的详细信息）来轻松确定，如下所示：&lt;/p>
&lt;blockquote>
&lt;p>&lt;code>ls -l /boot&lt;/code>&lt;/p>
&lt;/blockquote>
&lt;p>如果 vmlinuz 是一个普通文件（包括可执行文件），则第一列中有关它的信息将以连字符开头。如果是链接，它将以字母_l_开头。
通过发出以下命令   来_编译_Linux 内核：&lt;/p>
&lt;blockquote>
&lt;p>&lt;code>make bzImage&lt;/code>&lt;/p>
&lt;/blockquote>
&lt;p>这会在 /usr/src/linux/arch/i386/linux/boot/ 等目录中创建名为_bzImage_的文件。&lt;/p>
&lt;p>编译是将内核的&lt;a href="http://www.linfo.org/source_code.html">&lt;em>源代码&lt;/em>&lt;/a>（即内核由人类编写的原始形式）转换为_目标代码_（计算机处理器可以直接理解）。它由称为&lt;a href="http://www.linfo.org/compiler.html">&lt;em>编译器&lt;/em>&lt;/a>的专门程序执行，通常是&lt;a href="http://www.linfo.org/gcc.html">&lt;em>GCC&lt;/em>&lt;/a>（&lt;a href="http://www.linfo.org/gnu.html">GNU&lt;/a>编译器集合）中的一个。&lt;/p>
&lt;p>然后使用 _cp &lt;em>命令将 bzImage 复制到 /boot 目录，同时使用诸如以下命令   重命名_vmlinuz&lt;/em>&lt;/p>
&lt;blockquote>
&lt;p>&lt;code>cp /usr/src/linux/arch/i386/linux/boot/bzImage /boot/vmlinuz&lt;/code>&lt;/p>
&lt;/blockquote>
&lt;p>vmlinuz 不仅仅是一个压缩图像。它还内置了_gzip_解压缩器代码。gzip 是&lt;a href="http://www.linfo.org/unix-like.html">类 Unix&lt;/a>操作系统上最流行的压缩实用程序之一。&lt;/p>
&lt;p>一个名为_zImage_文件的编译内核是在一些较旧的系统上创建的，并保留在较新的系统上以实现向后兼容性。zImage 和 bzImage 都是用 gzip 压缩的。区别在于 zImage 解压到_低内存_（即前 640kB），bzImage 解压到_高内存_（1MB 以上）。有一个常见的误解，认为 bzImage 是使用_bzip2_实用程序压缩的。实际上，&lt;em>b_只代表_big&lt;/em>。&lt;/p>
&lt;p>&lt;em>vmlinuz&lt;/em> 这个名字很大程度上是历史的偶然。在贝尔实验室开发的原始 UNIX 上的内核二进制文件称为_unix_。当后来在加州大学伯克利分校 (UCB) 编写包含支持&lt;a href="http://www.linfo.org/virtual_memory.html">&lt;em>虚拟内存&lt;/em>&lt;/a>的新内核时，内核二进制文件更名为_vmunix_。&lt;/p>
&lt;p>虚拟内存是使用硬盘驱动器 (HDD) 上的空间来模拟额外的 RAM（随机存取内存）容量。与当时使用的其他一些流行操作系统（例如&lt;a href="http://www.linfo.org/ms-dos.html">MS-DOS）&lt;/a>相比，Linux 内核几乎从 Linux 一开始就支持它。&lt;/p>
&lt;p>因此，Linux 内核很自然地被称为_vmlinux_。由于 Linux 内核可执行文件被制作成压缩文件，并且压缩文件在类 Unix 系统上通常具有_z_或_gz_扩展名，因此压缩内核可执行文件的名称变为_vmlinuz_。&lt;/p>
&lt;h2 id="initrd">initrd&lt;/h2>
&lt;p>&lt;strong>Initial RAM Disk(初始内存磁盘，简称 initrd)&lt;/strong> 是一种将临时根文件系统加载到内存中的方案，可以作为 Linux 启动过程的一部分。有两种方法来实现这种方案：&lt;/p>
&lt;ul>
&lt;li>&lt;strong>initrd # Initial RAM Disk。&lt;/strong> 就是把一块内存（ram）当做磁盘（disk）去挂载，然后找到 ram 里的 init 执行。&lt;/li>
&lt;li>&lt;strong>initramfs # Initial RAM Filesystem。&lt;/strong> 直接在 ram 上挂载文件系统，执行文件系统中的 init。&lt;/li>
&lt;/ul>
&lt;p>这两者通常用于在挂载真正的根文件系统之前执行一些准备工作。&lt;/p>
&lt;blockquote>
&lt;p>不要被文件名迷惑，kernel 2.6 以来都是 initramfs 了，只是很多还沿袭传统使用 initrd 的名字
initramfs 的工作方式更加简单直接一些，启动的时候加载内核和 initramfs 到内存执行，内核初始化之后，切换到用户态执行 initramfs 的程序/脚本，加载需要的驱动模块、必要配置等，然后加载 rootfs 切换到真正的 rootfs 上去执行后续的 init 过程。&lt;/p>
&lt;/blockquote>
&lt;blockquote>
&lt;p>initrd 是 2.4 及更早的用法（现在你能见到的 initrd 文件实际差不多都是 initramfs 了），运行过程大概是内核启动，执行一些 initrd 的内容，加载模块啥的，然后交回控制权给内核，最后再切到用户态去运行用户态的启动流程。&lt;/p>
&lt;/blockquote>
&lt;blockquote>
&lt;p>从格式看，老的 initrd 是一个压缩的内存文件系统，具体是啥忘了，年月太久了。现在的 initramfs 是一个 gzip 压缩的 cpio 文件系统打包，如果遇到什么紧急情况需要处理的时候，你可以建立一个临时目录，把 initramfs 解压之后，直接 cpio -idv 解压出来，改之后再用 cpio 和 gzip 封上即可。虽然大家都喜欢用 tar 打包，但掌握点 cpio 在关键时刻还是可以救命的。&lt;/p>
&lt;/blockquote>
&lt;p>在早期的 Linux 系统中，一般就只有软盘或者硬盘被用来作为 Linux 的根文件系统，因此很容易把这些设备的驱动程序集成到内核中。但是现在根文件系统可能保存在各种存储设备上，包括 SCSI、SATA、U 盘等等。总不能每出一个，就要重新编译一遍内核吧？~这样不但麻烦，也不实用，所以后来 Linux 就提供了一个灵活的方法来解决这些问题。就是 &lt;strong>initrd&lt;/strong>。&lt;/p>
&lt;blockquote>
&lt;p>可以把 initrd 当做 WinPE。当使用 WinPE 启动后会发现你的计算机就算没有硬盘也能在正常运行，其中有个文件系统 B:/ 分区，这个分区就是内存模拟的磁盘。&lt;/p>
&lt;/blockquote>
&lt;p>initrd.img 文件就是个 ram disk 的映像文件。ramdisk 是用一部分内存模拟成磁盘，让操作系统访问。ram disk 是标准内核文件认识的设备(/dev/ram0)文件系统也是标准内核认识的文件系统。内核加载这个 ram disk 作为根文件系统并开始执行其中的&amp;quot;某个文件&amp;quot;（2.6 内核是 init 文件）来加载各种模块，服务等。经过一些配置和运行后，就可以去物理磁盘加载真正的 root 分区了，然后又是一些配置等，最后启动成功。&lt;/p>
&lt;p>也就是你只需要定制适合自己的 initrd.img 文件就可以了。这要比重编内核简单多了，省时省事低风险。&lt;/p>
&lt;h3 id="查看-initrd-文件">查看 initrd 文件&lt;/h3>
&lt;p>我们可以通过如下方式，解压出 initrd.img 文件，下面分别以 Ubuntu 20.04 TLS 系统和 CentOS Stream 8 系统为例：&lt;/p>
&lt;blockquote>
&lt;p>解压方法来源：&lt;a href="https://unix.stackexchange.com/questions/163346/why-is-it-that-my-initrd-only-has-one-directory-namely-kernel">https://unix.stackexchange.com/questions/163346/why-is-it-that-my-initrd-only-has-one-directory-namely-kernel&lt;/a>&lt;/p>
&lt;/blockquote>
&lt;p>Ubuntu 20.04 TLS&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>root@lichenhao:~/test_dir# mkdir -p /root/test_dir/root
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>root@lichenhao:~/test_dir# cp /boot/initrd.img /root/test_dir/
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>root@lichenhao:~/test_dir/root# &lt;span style="color:#f92672">(&lt;/span>cpio -id; cpio -i; unlz4 | cpio -id&lt;span style="color:#f92672">)&lt;/span> &amp;lt; ../initrd.img
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">62&lt;/span> blocks
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">9004&lt;/span> blocks
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">450060&lt;/span> blocks
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>root@lichenhao:~/test_dir/root# ls
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>bin conf cryptroot etc init kernel lib lib32 lib64 libx32 run sbin scripts usr var
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>CentOS Stream 8&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">[&lt;/span>root@master-2 root&lt;span style="color:#f92672">]&lt;/span>&lt;span style="color:#75715e"># mkdir -p /root/test_dir/root&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">[&lt;/span>root@master-2 root&lt;span style="color:#f92672">]&lt;/span>&lt;span style="color:#75715e"># cp /boot/initramfs-4.18.0-294.el8.x86_64.img /root/test_dir&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">[&lt;/span>root@master-2 root&lt;span style="color:#f92672">]&lt;/span>&lt;span style="color:#75715e"># cd /root/test_dir/root&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">[&lt;/span>root@master-2 root&lt;span style="color:#f92672">]&lt;/span>&lt;span style="color:#75715e"># (cpio -id; zcat | cpio -id) &amp;lt; ../initramfs-4.18.0-294.el8.x86_64.img&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">[&lt;/span>root@master-2 root&lt;span style="color:#f92672">]&lt;/span>&lt;span style="color:#75715e"># ls&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>bin dev early_cpio etc init kernel lib lib64 proc root run sbin shutdown sys sysroot tmp usr var
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>可以看到，initrd.img 中包含了一个系统最基本的目录结构&lt;/p>
&lt;h1 id="kernel-关联文件">Kernel 关联文件&lt;/h1>
&lt;p>&lt;strong>/boot/*&lt;/strong> #&lt;/p>
&lt;ul>
&lt;li>&lt;strong>./config-$(uname -r)&lt;/strong> # Kernel 的扩展配置文件。Kernel 文档中，将该文件称为 &lt;strong>Boot Configuration&lt;/strong>。&lt;/li>
&lt;li>&lt;strong>./initrd.img&lt;/strong> # 在内核挂载真正的根文件系统前使用的临时文件系统&lt;/li>
&lt;li>&lt;strong>./vmlinuz&lt;/strong> # Linux 内核&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>/etc/sysctl.conf&lt;/strong> # 系统启动时读取的内核参数文件&lt;/p>
&lt;ul>
&lt;li>&lt;strong>/etc/sysctl.d/*&lt;/strong> # 系统启动时时读取的内核参数目录&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>/usr/lib/sysctl.d/*&lt;/strong> #&lt;/p>
&lt;p>&lt;strong>/proc/sys/*&lt;/strong> # 内核参数(也称为内核变量)所在路径。该目录(从 1.3.57 版本开始)包含许多与内核变量相对应的文件和子目录。 可以使用 &lt;a href="https://www.yuque.com/go/doc/33222789">proc 文件系统&lt;/a> 以及 sysctl(2) 系统读取或加载这些变量，有时可以对其进行修改。&lt;/p></description></item><item><title>Docs: Boot Configuration</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2.kernel%E5%86%85%E6%A0%B8/1.linux-kernel/boot-configuration/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2.kernel%E5%86%85%E6%A0%B8/1.linux-kernel/boot-configuration/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://www.kernel.org/doc/html/latest/admin-guide/bootconfig.html">Linux Kernel 官网文档，Linux 内核用户和管理员指南-内核引导配置&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>Boot Configuration(引导配置) 扩展了当前内核命令行，在引导内核时，可以提供额外的运行时配置。该文件默认在 &lt;code>/boot/config-$(uname -r)&lt;/code>，每个内核版本都有一个对应的文件。&lt;/p>
&lt;p>该文件有几千行，每一行都是一个以 &lt;code>=&lt;/code> 分割的键值对，用来在系统启动内核前的引导阶段，为内核配置运行时行为&lt;/p>
&lt;h1 id="linux-namespace-配置">Linux Namespace 配置&lt;/h1>
&lt;p>CONFIG_CHECKPOINT_RESTORE=y
CONFIG_NAMESPACES=y # 是否启用 Linux Namespace
CONFIG_UTS_NS=y # 是否启用 UTS NS
CONFIG_IPC_NS=y # 是否启用 IPC NS
CONFIG_USER_NS=y
CONFIG_PID_NS=y
CONFIG_NET_NS=y # # 是否启用 NET NS
CONFIG_UIDGID_STRICT_TYPE_CHECKS=y
CONFIG_SCHED_AUTOGROUP=y
CONFIG_MM_OWNER=y&lt;/p></description></item><item><title>Docs: Kernel 参数</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2.kernel%E5%86%85%E6%A0%B8/1.linux-kernel/kernel-%E5%8F%82%E6%95%B0/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2.kernel%E5%86%85%E6%A0%B8/1.linux-kernel/kernel-%E5%8F%82%E6%95%B0/</guid><description/></item><item><title>Docs: Kernel 的安装与卸载</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2.kernel%E5%86%85%E6%A0%B8/1.linux-kernel/kernel-%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E5%8D%B8%E8%BD%BD/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2.kernel%E5%86%85%E6%A0%B8/1.linux-kernel/kernel-%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E5%8D%B8%E8%BD%BD/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://mp.weixin.qq.com/s/1xRc4DzyG4c8e2XYGk28Vg">https://mp.weixin.qq.com/s/1xRc4DzyG4c8e2XYGk28Vg&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;h1 id="ubuntu">Ubuntu&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://kernel.ubuntu.com/~kernel-ppa/mainline/">https://kernel.ubuntu.com/~kernel-ppa/mainline/&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;h2 id="更换内核">更换内核&lt;/h2>
&lt;p>awk -F&amp;rsquo; &amp;lsquo;$1==&amp;quot;\tmenuentry &amp;quot; {print i++ &amp;quot; : &amp;quot; $2}&amp;rsquo; /boot/grub/grub.cfg&lt;/p>
&lt;h1 id="centos">CentOS&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="http://elrepo.org/tiki/tiki-index.php">ELRepo 安装文档&lt;/a>&lt;/li>
&lt;li>elrepo 的内核 rpm 包不全，暂时也不知道去哪找，先把能找到的网址都记下来
&lt;ul>
&lt;li>&lt;a href="https://buildlogs.centos.org/c7-kernels.x86_64/kernel/">https://buildlogs.centos.org/c7-kernels.x86_64/kernel/&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://buildlogs.centos.org/c7-kernels.x86_64/kernel/20200330213326/4.19.113-300.el8.x86_64/?C=N;O=A">https://buildlogs.centos.org/c7-kernels.x86_64/kernel/20200330213326/4.19.113-300.el8.x86_64/?C=N;O=A&lt;/a>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;h2 id="安装-linux-内核的存储库">安装 linux 内核的存储库&lt;/h2>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>rpm --import https://www.elrepo.org/RPM-GPG-KEY-elrepo.org
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>yum install -y https://www.elrepo.org/elrepo-release-7.el7.elrepo.noarch.rpm
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="安装-linux-内核">安装 linux 内核&lt;/h2>
&lt;p>查看可用的 linux 内核版本&lt;/p>
&lt;blockquote>
&lt;p>版本性质：主分支 ml(mainline)，稳定版(stable)，长期维护版 lt(longterm)&lt;/p>
&lt;/blockquote>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>yum --disablerepo&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;*&amp;#34;&lt;/span> --enablerepo&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;elrepo-kernel&amp;#34;&lt;/span> list available
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>安装指定版本的 Linux 内核&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>yum --enablerepo&lt;span style="color:#f92672">=&lt;/span>elrepo-kernel install kernel-lt-devel kernel-lt kernel-lt-headers -y
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>(可选)安装新内核工具&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>yum remove kernel-tools-libs.x86_64 kernel-tools.x86_64
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>yum --disablerepo&lt;span style="color:#f92672">=&lt;/span>* --enablerepo&lt;span style="color:#f92672">=&lt;/span>elrepo-kernel install kernel-lt-tools kernel-tools-libs kernel-lt-headers -y
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="更换默认内核">更换默认内核&lt;/h2>
&lt;h3 id="centos7">CentOS7&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># 查找需要设为默认启动的内核名称&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>grep &lt;span style="color:#e6db74">&amp;#34;^menuentry&amp;#34;&lt;/span> /boot/grub2/grub.cfg | cut -d &lt;span style="color:#e6db74">&amp;#34;&amp;#39;&amp;#34;&lt;/span> -f2
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># 设置默认内核&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>grub2-set-default &lt;span style="color:#e6db74">&amp;#34;CentOS Linux (5.4.173-1.el7.elrepo.x86_64) 7 (Core)&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># 检查默认内核版本&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>grub2-editenv list
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>设置完成后，执行 &lt;code>reboot&lt;/code> 命令重启机器&lt;/p>
&lt;p>卸载旧版内核&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># 使用 package-cleanup 工具卸载旧内核，超过3个才会删&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>package-cleanup --oldkernels
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># 查看 旧版内核信息&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>rpm -qa | grep kernel
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># 卸载旧版内核&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>yum remove kernel-3.10.0-1127.19.1.el7.x86_64
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="centos-8">CentOS 8&lt;/h3>
&lt;p>查看当前默认启动的内核&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">[&lt;/span>root@tiny-server ~&lt;span style="color:#f92672">]&lt;/span>&lt;span style="color:#75715e"># grubby --default-kernel&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>/boot/vmlinuz-4.18.0-193.28.1.el8_2.x86_64
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>查看系统安装的全部内核：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">[&lt;/span>root@tiny-server ~&lt;span style="color:#f92672">]&lt;/span>&lt;span style="color:#75715e"># grubby --info=ALL&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>index&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">0&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>kernel&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;/boot/vmlinuz-5.9.1-1.el8.elrepo.x86_64&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>args&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;ro crashkernel=auto resume=/dev/mapper/cl-swap rd.lvm.lv=cl/root rd.lvm.lv=cl/swap net.ifnames=0 rhgb quiet intel_iommu=on &lt;/span>$tuned_params&lt;span style="color:#e6db74">&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>root&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;/dev/mapper/cl-root&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>initrd&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;/boot/initramfs-5.9.1-1.el8.elrepo.x86_64.img &lt;/span>$tuned_initrd&lt;span style="color:#e6db74">&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>title&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;Red Hat Enterprise Linux (5.9.1-1.el8.elrepo.x86_64) 8.2 (Ootpa)&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>id&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;12ab47b22fef4c02bcdc88b340d5f706-5.9.1-1.el8.elrepo.x86_64&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>index&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>kernel&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;/boot/vmlinuz-4.18.0-193.28.1.el8_2.x86_64&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>args&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;ro crashkernel=auto resume=/dev/mapper/cl-swap rd.lvm.lv=cl/root rd.lvm.lv=cl/swap net.ifnames=0 rhgb quiet intel_iommu=on &lt;/span>$tuned_params&lt;span style="color:#e6db74">&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>root&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;/dev/mapper/cl-root&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>initrd&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;/boot/initramfs-4.18.0-193.28.1.el8_2.x86_64.img &lt;/span>$tuned_initrd&lt;span style="color:#e6db74">&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>title&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;CentOS Linux (4.18.0-193.28.1.el8_2.x86_64) 8 (Core)&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>id&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;12ab47b22fef4c02bcdc88b340d5f706-4.18.0-193.28.1.el8_2.x86_64&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>设置默认启动的内核&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># 使用路径来指定内核，可以使用--set-default=Kernel_PATH&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">[&lt;/span>root@tiny-server ~&lt;span style="color:#f92672">]&lt;/span>&lt;span style="color:#75715e"># grubby --set-default=/boot/vmlinuz-5.9.1-1.el8.elrepo.x86_64&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>The default is /boot/loader/entries/12ab47b22fef4c02bcdc88b340d5f706-5.9.1-1.el8.elrepo.x86_64.conf with index &lt;span style="color:#ae81ff">0&lt;/span> and kernel /boot/vmlinuz-5.9.1-1.el8.elrepo.x86_64
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">[&lt;/span>root@tiny-server ~&lt;span style="color:#f92672">]&lt;/span>&lt;span style="color:#75715e"># grubby --default-kernel&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>/boot/vmlinuz-5.9.1-1.el8.elrepo.x86_64
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># 使用index来指定内核，则使用--set-default-index=INDEX&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">[&lt;/span>root@tiny-server ~&lt;span style="color:#f92672">]&lt;/span>&lt;span style="color:#75715e"># grubby --set-default-index=1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>The default is /boot/loader/entries/12ab47b22fef4c02bcdc88b340d5f706-4.18.0-193.28.1.el8_2.x86_64.conf with index &lt;span style="color:#ae81ff">1&lt;/span> and kernel /boot/vmlinuz-4.18.0-193.28.1.el8_2.x86_64
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">[&lt;/span>root@tiny-server ~&lt;span style="color:#f92672">]&lt;/span>&lt;span style="color:#75715e"># grubby --default-kernel&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>/boot/vmlinuz-4.18.0-193.28.1.el8_2.x86_64
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>添加/删除内核启动参数：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># 对所有的内核都删除某个参数&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">[&lt;/span>root@tiny-server ~&lt;span style="color:#f92672">]&lt;/span>&lt;span style="color:#75715e"># grubby --update-kernel=ALL --remove-args=intel_iommu=on&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># 对所有的内核都添加某个参数&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">[&lt;/span>root@tiny-server ~&lt;span style="color:#f92672">]&lt;/span>&lt;span style="color:#75715e"># grubby --update-kernel=ALL --args=intel_iommu=on&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># 对某个的内核添加启动参数&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">[&lt;/span>root@tiny-server ~&lt;span style="color:#f92672">]&lt;/span>&lt;span style="color:#75715e"># grubby --update-kernel=/boot/vmlinuz-5.9.1-1.el8.elrepo.x86_64 --args=intel_iommu=on&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>查看特定内核的具体信息：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">[&lt;/span>root@tiny-server ~&lt;span style="color:#f92672">]&lt;/span>&lt;span style="color:#75715e"># grubby --info=/boot/vmlinuz-5.9.1-1.el8.elrepo.x86_64&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>index&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">0&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>kernel&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;/boot/vmlinuz-5.9.1-1.el8.elrepo.x86_64&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>args&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;ro crashkernel=auto resume=/dev/mapper/cl-swap rd.lvm.lv=cl/root rd.lvm.lv=cl/swap net.ifnames=0 rhgb quiet intel_iommu=on &lt;/span>$tuned_params&lt;span style="color:#e6db74">&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>root&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;/dev/mapper/cl-root&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>initrd&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;/boot/initramfs-5.9.1-1.el8.elrepo.x86_64.img &lt;/span>$tuned_initrd&lt;span style="color:#e6db74">&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>title&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;Red Hat Enterprise Linux (5.9.1-1.el8.elrepo.x86_64) 8.2 (Ootpa)&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>id&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;12ab47b22fef4c02bcdc88b340d5f706-5.9.1-1.el8.elrepo.x86_64&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div></description></item><item><title>Docs: Module(模块)</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2.kernel%E5%86%85%E6%A0%B8/1.linux-kernel/module%E6%A8%A1%E5%9D%97/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2.kernel%E5%86%85%E6%A0%B8/1.linux-kernel/module%E6%A8%A1%E5%9D%97/</guid><description>
&lt;h1 id="linux-模块介绍">Linux 模块介绍&lt;/h1>
&lt;p>&lt;strong>Loadable Kernel Module(全称为动态可加载内核模块，简称 LKM)，简称为模块&lt;/strong>。模块是具有独立功能的程序，它可以被单独编译，但不能独立运行。它在运行时被链接到内核作为内核的一部分在内核空间运行，这与运行在用户空间的进程是不同的。模块通常由一组函数和数据结构组成，用来实现一种文件系统、一个驱动程序或其他内核上层的功能。&lt;/p>
&lt;p>总之，模块是一个伪内核（从某种意义上来说，内核也是一个模块）或其他内核模块提供使用功能的代码块。&lt;/p>
&lt;p>模块的管理方式：使用 systemd 控制的 unit：systemd-modules-load.service&lt;/p>
&lt;p>该 unit 启动后读取其中指定目录下的配置以加载模块&lt;/p>
&lt;h1 id="模块配置">模块配置&lt;/h1>
&lt;p>系统启动后，依次从上到下从以下目录读取&lt;strong>模块的额外参数&lt;/strong>并应用它们&lt;/p>
&lt;ul>
&lt;li>/etc/modprobe.d/*.conf&lt;/li>
&lt;li>/run/modprobe.d/*.conf&lt;/li>
&lt;li>/usr/lib/modprobe.d/*.conf&lt;/li>
&lt;/ul>
&lt;p>系统启动后，依次从上到下从以下目录读取&lt;strong>模块名称&lt;/strong>以加载它们&lt;/p>
&lt;ul>
&lt;li>/etc/modules-load.d/*.conf&lt;/li>
&lt;li>/run/modules-load.d/*.conf&lt;/li>
&lt;li>/usr/lib/modules-load.d/*.conf&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>~&lt;span style="color:#f92672">]&lt;/span>&lt;span style="color:#75715e"># cat /etc/modules-load.d/br_netfilter.conf&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>br_netfilter
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ul>
&lt;li>该目录格式为每个模块一行&lt;/li>
&lt;li>注意不要给模块名加任何后缀&lt;/li>
&lt;/ul>
&lt;p>/etc/sysconfig/modules/*.modules # 系统读取该目录下的脚本加载用户自定义的模块，该目录下的文件必须要以 &lt;code>.modules&lt;/code> 为文件名结尾。该文件会被系统视为 shell 脚本，因此该文件应以解释器指令作为开头第一行。
/usr/lib/modules/$(uname -r)/kernel/ # 模块所在目录，不同类型的模块有不同目录&lt;/p>
&lt;p>Note：不同版本内核的模块目录不同，所有安装的模块都在该目录下，如果需要把模块加载到内核中，则可以通过命令来加载该目录下的对应模块即可&lt;/p>
&lt;ol>
&lt;li>arch # 与硬件平台有关的项目，例如 CPU 的等级等等&lt;/li>
&lt;li>crypto # 核心所支持的加密的技术，例如 md5 或者 des 等等&lt;/li>
&lt;li>drivers # 一些硬件的驱动程序，例如显卡、网卡、PCI 相关硬件等等&lt;/li>
&lt;li>fs # 核心所支持的 filesystems，例如 vfat、reiserfs、nfs 等等&lt;/li>
&lt;li>lib # 一些函数库&lt;/li>
&lt;li>net # 与网络有关的各项协定数据，还有防火墙模块&lt;/li>
&lt;li>sound # 与音效有关的各项模块&lt;/li>
&lt;/ol>
&lt;p>&lt;strong>模块之间的依赖性&lt;/strong>
使用 depmod 命令读取 &lt;strong>/lib/modules/$(uname -r )/kernel/&lt;/strong> 目录下每个模块并分析，然后把分析结果写入/lib/modules/$(uname -r)/modules.dep 文件中。&lt;/p>
&lt;h1 id="模块管理命令行工具">模块管理命令行工具&lt;/h1>
&lt;h2 id="查看已加载模块的当前参数">查看已加载模块的当前参数&lt;/h2>
&lt;p>参考：&lt;a href="https://serverfault.com/questions/62316/how-do-i-list-loaded-linux-module-parameter-values">https://serverfault.com/questions/62316/how-do-i-list-loaded-linux-module-parameter-values&lt;/a>&lt;/p>
&lt;h2 id="depmod--输出适用于-modprobe-可用性的依赖列表">depmod # 输出适用于 modprobe 可用性的依赖列表&lt;/h2>
&lt;p>depmod 输出的分析结果将会写入 /lib/modules/$(uname -r)/modules.dep 文件中。&lt;/p>
&lt;p>EXAMPLE&lt;/p>
&lt;ol>
&lt;li>depmod -n # 可以不写入文件而把结果输出到屏幕上&lt;/li>
&lt;li>depmod -e # 显示出目前已载入的不可执行的模块名称&lt;/li>
&lt;/ol>
&lt;h2 id="lsmod-显示当前系统下已经加载了哪些模块">lsmod #显示当前系统下已经加载了哪些模块&lt;/h2>
&lt;p>共三列信息 Module(模块名)、size(模块的大小)、Used by(此模块被哪个模块所使用)&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>root@lichenhao:~# lsmod
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Module Size Used by
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>ip_vs &lt;span style="color:#ae81ff">155648&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>xt_conntrack &lt;span style="color:#ae81ff">16384&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>xt_MASQUERADE &lt;span style="color:#ae81ff">20480&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>......略
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>EXAMPLE&lt;/p>
&lt;h2 id="modinfo--通过模块名或者模块文件名来查看模块信息">modinfo # 通过模块名或者模块文件名来查看模块信息&lt;/h2>
&lt;p>下面就是一个 ip_vs 模块的信息示例，第一列是想要显示的信息名称，第二列是该信息的具体内容&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>root@lichenhao:~# modinfo ip_vs
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>filename: /lib/modules/5.4.0-73-generic/kernel/net/netfilter/ipvs/ip_vs.ko
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>license: GPL
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>srcversion: D98100F31C2694A169510A5
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>depends: nf_conntrack,nf_defrag_ipv6,libcrc32c
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>retpoline: Y
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>intree: Y
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>name: ip_vs
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>vermagic: 5.4.0-73-generic SMP mod_unload modversions
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>sig_id: PKCS#7
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>signer: Build time autogenerated kernel key
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>sig_key: 76:5C:D9:9F:5C:00:1C:F9:61:BE:32:67:DA:52:57:FE:F4:C2:E1:6E
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>sig_hashalgo: sha512
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>signature: 40:B0:9F:92:3C:6C:C8:9B:A2:E8:AA:91:15:44:DB:C6:0E:6E:31:0A:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> 04:7F:42:FD:C0:EE:BB:8D:8B:67:49:A0:6A:72:8E:99:14:98:F3:D3:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ......略
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>parm: conn_tab_bits:Set connections&lt;span style="color:#960050;background-color:#1e0010">&amp;#39;&lt;/span> hash size &lt;span style="color:#f92672">(&lt;/span>int&lt;span style="color:#f92672">)&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>我们可以通过 -F 选项来只列出来指定信息的值。&lt;/p>
&lt;p>OPTIONS&lt;/p>
&lt;ul>
&lt;li>&lt;strong>-F,&amp;ndash;field &lt;!-- raw HTML omitted -->&lt;/strong> # 仅仅列出指定字段的值，这对于在脚本中使用非常有用。STRING 就是上面示例中，第一列的字符串，比如 filename、license 等等，效果如下：&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>root@lichenhao:~# modinfo -F filename ip_vs
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>/lib/modules/5.4.0-73-generic/kernel/net/netfilter/ipvs/ip_vs.ko
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>root@lichenhao:~# modinfo -F license ip_vs
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>GPL
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ul>
&lt;li>-F,&amp;ndash;field 选项的简化用法
&lt;ul>
&lt;li>&lt;strong>-a, &amp;ndash;author&lt;/strong> # 仅列出作者名称&lt;/li>
&lt;li>&lt;strong>-d, &amp;ndash;description&lt;/strong> # 仅列出 module 的 description&lt;/li>
&lt;li>&lt;strong>-l, &amp;ndash;license&lt;/strong> # 仅列出 module 的 license&lt;/li>
&lt;li>**-n, &amp;ndash;filename **#仅列出 module 的 filename 项(module 的文件所在路径)&lt;/li>
&lt;li>&lt;strong>-p, &amp;ndash;parameters&lt;/strong> # 仅列出 modeule 的可用参数。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>-b, &amp;ndash;basedir &lt;!-- raw HTML omitted -->&lt;/strong> #&lt;/li>
&lt;li>**-k KERNEL **#&lt;/li>
&lt;/ul>
&lt;p>EXAMPLE&lt;/p>
&lt;h2 id="modprobe--通过-module-的名字管理-module不能通过文件名">modprobe # 通过 module 的名字管理 module(不能通过文件名)&lt;/h2>
&lt;p>&lt;strong>modprobe [OPTIONS] ModuleName&lt;/strong>
如果用该命令不加任何 OPTIONS 则是加载 module，重启后消失&lt;/p>
&lt;p>modprobe(module 探针)(自动处理可载入模块)是 linux 的一个命令，可载入指定的个别模块，或是载入一组相依的模块。modprobe 会根据 depmod.dep 文件的相依关系，决定要载入哪些模块。若在载入过程中发生错误，在 modprobe 会卸载整组的模块&lt;/p>
&lt;p>OPTIONS&lt;/p>
&lt;ul>
&lt;li>&lt;strong>-c&lt;/strong> # 列出目前系统所有的模块&lt;/li>
&lt;li>&lt;strong>-f&lt;/strong> # 强制载入该模块&lt;/li>
&lt;li>&lt;strong>-r&lt;/strong> # 移除摸个 module&lt;/li>
&lt;/ul>
&lt;p>EXAMPLE&lt;/p>
&lt;h2 id="rmmod--卸载模块">rmmod # 卸载模块&lt;/h2>
&lt;h1 id="modeprobed-配置文件详解">modeprobe.d 配置文件详解&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://man7.org/linux/man-pages/man5/modprobe.d.5.html">Manual(手册)，modprobe.d(5)&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>可用指令：&lt;/p>
&lt;ul>
&lt;li>&lt;strong>alias&lt;/strong> &amp;lt;&lt;strong>Wildcard&amp;gt; modulename&lt;/strong> #&lt;/li>
&lt;li>&lt;strong>blacklist&lt;/strong> &lt;strong>&lt;!-- raw HTML omitted -->&lt;/strong>&lt;/li>
&lt;li>&lt;strong>install &lt;!-- raw HTML omitted --> &lt;!-- raw HTML omitted -->&amp;hellip;&lt;/strong> # 该命令指示 modprobe 工具运行我指定的命令，而不是像往常一样在内核中插入模块。该命令可以是任何 shell 命令: 这允许你做任何类型的复杂处理，你可能希望。例如，如果模块 “fred” 与已经安装的模块 “barney” 一起工作得更好 (但它不依赖于它，所以 modprobe 不会自动加载它)，你可以说 “安装 fred /sbin/modprobe barney; /sbin/modprobe-ignore-install fred”，你想做什么就做什么。注意 &amp;ndash; ignore-install，它阻止第二个 modprobe 再次运行相同的 install 命令。另请参阅下面的删除。
&lt;ul>
&lt;li>注意：这个命令作为提供额外模块依赖的问题的解决方案的长期未来是不确定的，它打算用一个警告来代替这个命令，说明它在将来的版本中的某个时候最终被删除或弃用。它的使用使分发工具 (例如 mkinitrd) 对模块依赖关系的自动确定变得复杂 (因为它们现在需要以某种方式解释安装命令可能在做什么。在一个完美的世界中，模块将在不使用此命令的情况下提供所有依赖项信息，并且正在努力在 linux 内核中实现软依赖项支持。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>options &lt;!-- raw HTML omitted --> &lt;!-- raw HTML omitted -->&amp;hellip;&lt;/strong> #&lt;/li>
&lt;li>**remove &lt;!-- raw HTML omitted --> &lt;!-- raw HTML omitted -->&amp;hellip; **#&lt;/li>
&lt;li>&lt;strong>softdep&lt;/strong> &lt;strong>&lt;!-- raw HTML omitted --> pre: modules&amp;hellip; post: modules&amp;hellip;&lt;/strong> #&lt;/li>
&lt;/ul></description></item><item><title>Docs: 硬核致敬Linux ！30岁生日快乐！</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2.kernel%E5%86%85%E6%A0%B8/1.linux-kernel/%E7%A1%AC%E6%A0%B8%E8%87%B4%E6%95%AClinux-30%E5%B2%81%E7%94%9F%E6%97%A5%E5%BF%AB%E4%B9%90/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2.kernel%E5%86%85%E6%A0%B8/1.linux-kernel/%E7%A1%AC%E6%A0%B8%E8%87%B4%E6%95%AClinux-30%E5%B2%81%E7%94%9F%E6%97%A5%E5%BF%AB%E4%B9%90/</guid><description>
&lt;p>&lt;a href="https://mp.weixin.qq.com/s/cE4x63tYxoqrDinifeWqeg">硬核致敬 Linux ！30 岁生日快乐！&lt;/a>&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/1ef62d82-d29c-457a-b63f-3d4dfa09d652/640" alt="">&lt;/p>
&lt;p>1991 年 8 月 25 日，21 岁的 Linus Torvalds（以下简称 Linus）做了一个免费的操作系统 “Linux”，并在这一天向外界公布这个由“业余爱好” 主导的个人项目；如今，全球超级计算机 500 强和超过 70% 的智能手机都在运行 Linux，因此，8 月 25 日也被许多 Linux 的爱好者视为 Linux 真正的诞生日期。&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/1ef62d82-d29c-457a-b63f-3d4dfa09d652/640" alt="">&lt;/p>
&lt;p>30 年前，Linus Torvalds 首次发布 Linux 内核时还是赫尔辛基大学的一名 21 岁学生。他的声明是这样开始的，“我正在做一个（免费的）操作系统（只是一个爱好，不会很大和专业&amp;hellip;&amp;hellip;）”。三十年后，排名前 500 的超级计算机都在运行 Linux，所有智能手机的 70% 以上都是如此。Linux 显然既庞大又专业。&lt;/p>
&lt;p>三十年来，Linus Torvalds 领导了 Linux 内核开发，激励了无数其他开发人员和开源项目。2005 年，Linus 还创建了 Git 来帮助管理内核开发过程，此后它成为最受欢迎的版本控制系统，受到无数开源和专有项目的信赖。&lt;/p>
&lt;h3 id="linux-历史">Linux 历史&lt;/h3>
&lt;p>&lt;strong>OS 史前历史&lt;/strong>&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/1ef62d82-d29c-457a-b63f-3d4dfa09d652/640" alt="">&lt;/p>
&lt;p>&lt;strong>Linux 的历史&lt;/strong>&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/1ef62d82-d29c-457a-b63f-3d4dfa09d652/640" alt="">&lt;/p>
&lt;h3 id="linux-系统">Linux 系统&lt;/h3>
&lt;p>&lt;strong>Linux 系统软件架构&lt;/strong>&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/1ef62d82-d29c-457a-b63f-3d4dfa09d652/640" alt="">&lt;/p>
&lt;p>Linux 系统由硬件、kernel、系统调用、shell、c 库、应用程序组成，架构层次分明，Linux 内的各种层功能独立，程序在用户空间和内核空间之间的分离，能支持更多应用。&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>用户模态&lt;/th>
&lt;th>&lt;strong>用户应用&lt;/strong>&lt;/th>
&lt;th>例如：Bash，LibreOffice，GIMP，Blender，0 A.D.，Mozilla Firefox 等&lt;/th>
&lt;th>&lt;/th>
&lt;th>&lt;/th>
&lt;th>&lt;/th>
&lt;th>&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>&lt;/td>
&lt;td>低层系统构件&lt;/td>
&lt;td>&lt;strong>系统守护进程&lt;/strong>：&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>systemd，runit，logind，networkd，PulseAudio 等&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;strong>窗口系统&lt;/strong>：&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>X11，Wayland，SurfaceFlinger(Android)&lt;/td>
&lt;td>&lt;strong>其他库&lt;/strong>：&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>GTK+, Qt, EFL, SDL, SFML, FLTK, GNUstep 等&lt;/td>
&lt;td>&lt;strong>图形&lt;/strong>：&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Mesa，AMD Catalyst 等&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;/td>
&lt;td>&lt;strong>C 标准库&lt;/strong>&lt;/td>
&lt;td>open()，exec()，sbrk()，socket()，fopen()，calloc()，&amp;hellip; (直到 2000 个子例程)&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>glibc 目标为 POSIX/SUS 兼容，musl 和 uClibc 目标为嵌入式系统，bionic 为 Android 而写等&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>内核模态&lt;/td>
&lt;td>&lt;strong>Linux 内核&lt;/strong>&lt;/td>
&lt;td>stat, splice, dup, read, open, ioctl, write, mmap, close, exit 等（大约 380 个系统调用）&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Linux 内核系统调用接口（SCI，目标为 POSIX/SUS 兼容）&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;td>进程调度子系统&lt;/td>
&lt;td>IPC 子系统&lt;/td>
&lt;td>内存管理子系统&lt;/td>
&lt;td>虚拟文件子系统&lt;/td>
&lt;td>网络子系统&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;td>其他构件：ALSA，DRI，evdev，LVM，device mapper，Linux Network Scheduler，Netfilter&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Linux 安全模块：SELinux，TOMOYO，AppArmor, Smack&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>硬件（CPU，内存，数据存储设备等。）&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>&lt;strong>Linux 内核代码架构&lt;/strong>&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/1ef62d82-d29c-457a-b63f-3d4dfa09d652/640" alt="">&lt;/p>
&lt;p>Linux 代码包含核心几个子系统，比如&lt;strong>内存子系统&lt;/strong>，&lt;strong>I/O 子系统&lt;/strong>，&lt;strong>CPU(调度）子系统&lt;/strong>，&lt;strong>设备驱动子系统&lt;/strong>，&lt;strong>网络子系统&lt;/strong>，&lt;strong>虚拟文件子系统&lt;/strong>等。这里简单介绍一些比较重要的子系统。&lt;/p>
&lt;h3 id="调度子系统">调度子系统&lt;/h3>
&lt;p>&lt;strong>进程调度&lt;/strong>是 Linux 内核中最重要的子系统，它主要提供对 CPU 的访问控制。因为在计算机中，CPU 资源是有限的，而众多的应用程序都要使用 CPU 资源，所以需要 “进程调度子系统” 对 CPU 进行调度管理。&lt;/p>
&lt;p>&lt;strong>进程调度子系统&lt;/strong>包括 4 个子模块（见下图），它们的功能如下：&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/1ef62d82-d29c-457a-b63f-3d4dfa09d652/640" alt="">&lt;/p>
&lt;ol>
&lt;li>Scheduling Policy，实现进程调度的策略，它决定哪个（或哪几个）进程将拥有 CPU。&lt;/li>
&lt;li>Architecture-specific Schedulers，体系结构相关的部分，用于将对不同 CPU 的控制，抽象为统一的接口。这些控制主要在 suspend 和 resume 进程时使用，牵涉到 CPU 的寄存器访问、汇编指令操作等。&lt;/li>
&lt;li>Architecture-independent Scheduler，体系结构无关的部分。它会和 “Scheduling Policy 模块” 沟通，决定接下来要执行哪个进程，然后通过“Architecture-specific Schedulers 模块”resume 指定的进程。&lt;/li>
&lt;li>System Call Interface，系统调用接口。进程调度子系统通过系统调用接口，将需要提供给用户空间的接口开放出去，同时屏蔽掉不需要用户空间程序关心的细节。&lt;/li>
&lt;/ol>
&lt;h3 id="内存子系统">内存子系统&lt;/h3>
&lt;p>&lt;strong>内存管理&lt;/strong>同样是 Linux 内核中最重要的子系统，它主要提供对内存资源的访问控制。Linux 系统会在硬件物理内存和进程所使用的内存（称作虚拟内存）之间建立一种映射关系，这种映射是以进程为单位，因而不同的进程可以使用相同的虚拟内存，而这些相同的虚拟内存，可以映射到不同的物理内存上。&lt;/p>
&lt;p>&lt;strong>内存管理子系统&lt;/strong>包括 3 个子模块（见下图），它们的功能如下：&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/1ef62d82-d29c-457a-b63f-3d4dfa09d652/640" alt="">&lt;/p>
&lt;ol>
&lt;li>Architecture Specific Managers，体系结构相关部分。提供用于访问硬件 Memory 的虚拟接口。&lt;/li>
&lt;li>Architecture Independent Manager，体系结构无关部分。提供所有的内存管理机制，包括：以进程为单位的 memory mapping；虚拟内存的 Swapping。&lt;/li>
&lt;li>System Call Interface，系统调用接口。通过该接口，向用户空间程序应用程序提供内存的分配、释放，文件的 map 等功能。&lt;/li>
&lt;/ol>
&lt;h3 id="虚拟文件子系统virtual-filesystem-vfs">虚拟文件子系统（Virtual Filesystem, VFS）&lt;/h3>
&lt;p>传统意义上的文件系统，是一种存储和组织计算机数据的方法。它用易懂、人性化的方法（文件和目录结构），抽象计算机磁盘、硬盘等设备上冰冷的数据块，从而使对它们的查找和访问变得容易。因而文件系统的实质，就是 “存储和组织数据的方法”，文件系统的表现形式，就是 “从某个设备中读取数据和向某个设备写入数据”。&lt;/p>
&lt;p>随着计算机技术的进步，存储和组织数据的方法也是在不断进步的，从而导致有多种类型的文件系统，例如 FAT、FAT32、NTFS、EXT2、EXT3 等等。而为了兼容，操作系统或者内核，要以相同的表现形式，同时支持多种类型的文件系统，这就延伸出了**虚拟文件系统（VFS）**的概念。VFS 的功能就是管理各种各样的文件系统，屏蔽它们的差异，以统一的方式，为用户程序提供访问文件的接口。&lt;/p>
&lt;p>我们可以从磁盘、硬盘、NAND Flash 等设备中读取或写入数据，因而最初的文件系统都是构建在这些设备之上的。这个概念也可以推广到其它的硬件设备，例如内存、显示器（LCD）、键盘、串口等等。我们对硬件设备的访问控制，也可以归纳为读取或者写入数据，因而可以用统一的文件操作接口访问。Linux 内核就是这样做的，除了传统的磁盘文件系统之外，它还抽象出了设备文件系统、内存文件系统等等。这些逻辑，都是由 VFS 子系统实现。&lt;/p>
&lt;p>&lt;strong>VFS 子系统&lt;/strong>包括 6 个子模块（见下图），它们的功能如下：&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/1ef62d82-d29c-457a-b63f-3d4dfa09d652/640" alt="">&lt;/p>
&lt;ol>
&lt;li>Device Drivers，设备驱动，用于控制所有的外部设备及控制器。由于存在大量不能相互兼容的硬件设备（特别是嵌入式产品），所以也有非常多的设备驱动。因此，Linux 内核中将近一半的 Source Code 都是设备驱动，大多数的 Linux 底层工程师（特别是国内的企业）都是在编写或者维护设备驱动，而无暇估计其它内容（它们恰恰是 Linux 内核的精髓所在）。&lt;/li>
&lt;li>Device Independent Interface， 该模块定义了描述硬件设备的统一方式（统一设备模型），所有的设备驱动都遵守这个定义，可以降低开发的难度。同时可以用一致的形势向上提供接口。&lt;/li>
&lt;li>Logical Systems，每一种文件系统，都会对应一个 Logical System（逻辑文件系统），它会实现具体的文件系统逻辑。&lt;/li>
&lt;li>System Independent Interface，该模块负责以统一的接口（快设备和字符设备）表示硬件设备和逻辑文件系统，这样上层软件就不再关心具体的硬件形态了。&lt;/li>
&lt;li>System Call Interface，系统调用接口，向用户空间提供访问文件系统和硬件设备的统一的接口。&lt;/li>
&lt;/ol>
&lt;h3 id="网络子系统net">网络子系统（Net）&lt;/h3>
&lt;p>&lt;strong>网络子系统&lt;/strong>在 Linux 内核中主要负责管理各种网络设备，并实现各种网络协议栈，最终实现通过网络连接其它系统的功能。在 Linux 内核中，网络子系统几乎是自成体系，它包括 5 个子模块（见下图），它们的功能如下：&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/1ef62d82-d29c-457a-b63f-3d4dfa09d652/640" alt="">&lt;/p>
&lt;ol>
&lt;li>Network Device Drivers，网络设备的驱动，和 VFS 子系统中的设备驱动是一样的。&lt;/li>
&lt;li>Device Independent Interface，和 VFS 子系统中的是一样的。&lt;/li>
&lt;li>Network Protocols，实现各种网络传输协议，例如 IP, TCP, UDP 等等。&lt;/li>
&lt;li>Protocol Independent Interface，屏蔽不同的硬件设备和网络协议，以相同的格式提供接口（socket)。&lt;/li>
&lt;li>System Call interface，系统调用接口，向用户空间提供访问网络设备的统一的接口。&lt;/li>
&lt;/ol>
&lt;p>Linux 内核版本时间线：&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/1ef62d82-d29c-457a-b63f-3d4dfa09d652/640" alt="">&lt;/p>
&lt;p>&lt;strong>Linux 内核支持各种硬件架构&lt;/strong>&lt;/p>
&lt;p>&lt;strong>Linux 内核&lt;/strong>最成功的地方之一就是支持各种硬件架构，为软件提供了公共的平台：&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/1ef62d82-d29c-457a-b63f-3d4dfa09d652/640" alt="">&lt;/p>
&lt;p>基于 Linux 的系统是一个模块化的类 Unix 操作系统。&lt;strong>Linux 操作系统&lt;/strong>的大部分设计思想来源于 20 世纪 70 年代到 80 年代的 Unix 操作系统所建立的基本设计思想。Linux 系统使用宏内核，由 Linux 内核负责处理进程控制、网络，以及外围设备和文件系统的访问。在系统运行的时候，设备驱动程序要么与内核直接整合，要么以加载模块形式添加。&lt;/p>
&lt;p>&lt;strong>Linux 具有设备独立性&lt;/strong>，它内核具有高度适应能力，从而给系统提供了更高级的功能。GNU 用户界面组件是大多数 Linux 操作系统的重要组成部分，提供常用的 C 函数库，Shell，还有许多常见的 Unix 实用工具，可以完成许多基本的操作系统任务。大多数 Linux 系统使用的图形用户界面建立在 X 窗口系统之上，由 X 窗口 (XWindow) 系统通过软件工具及架构协议来建立操作系统所用的图形用户界面.&lt;/p>
&lt;p>&lt;strong>基于 Linux 内核各种衍生 OS 系统&lt;/strong>&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/1ef62d82-d29c-457a-b63f-3d4dfa09d652/640" alt="">&lt;/p>
&lt;p>各种发行版本&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/1ef62d82-d29c-457a-b63f-3d4dfa09d652/640" alt="">&lt;/p>
&lt;p>当前比较流行发行版是：&lt;strong>Debian&lt;/strong>、&lt;strong>Ubuntu&lt;/strong>、&lt;strong>Fedora&lt;/strong>、&lt;strong>CentOS&lt;/strong>、&lt;strong>Arch Linux&lt;/strong>和&lt;strong>openSUSE&lt;/strong>等，每个发行版都有自己优势地方，都有一批忠实用户。&lt;/p>
&lt;p>&lt;strong>基于 Linux 内核著名 OS&lt;/strong>&lt;/p>
&lt;p>&lt;strong>Android&lt;/strong>&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/1ef62d82-d29c-457a-b63f-3d4dfa09d652/640" alt="">&lt;/p>
&lt;p>&lt;strong>Android&lt;/strong>（读音：英：[&amp;lsquo;ændrɔɪd]，美：[ˈænˌdrɔɪd]），中文用户多以非官方名称 “安卓” 称之，是一个基于 Linux 内核与其他开源软件的开放源代码的移动操作系统，Android 的内核是根据 Linux 内核的长期支持的分支，具有典型的 Linux 调度和功能。截至 2018 年，Android 的目标是 Linux 内核的 4.4、4.9 或是 4.14 版本。&lt;/p>
&lt;p>&lt;strong>ChromeOS&lt;/strong>&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/1ef62d82-d29c-457a-b63f-3d4dfa09d652/640" alt="">&lt;/p>
&lt;p>&lt;strong>Chrome OS&lt;/strong>  是由 Google 设计基于 Linux 内核的操作系统，并使用 Google Chrome 浏览器作为其主要用户界面。因此，Chrome OS 主要支持 Web 应用程序[6]，2016 年起开始陆续兼容 Android 应用程序（可通过 Google Play 商店下载）和 Linux 应用程序。&lt;/p>
&lt;p>&lt;strong>鸿蒙 OS&lt;/strong>&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/1ef62d82-d29c-457a-b63f-3d4dfa09d652/640" alt="">&lt;/p>
&lt;p>&lt;strong>鸿蒙&lt;/strong>（&lt;strong>HarmonyOS&lt;/strong>，开发代号 Ark[1]）是华为自 2012 年开发的一款可兼容 Android 应用程序的跨平台分布式操作系统[2]。系统性能包括利用 “分布式” 技术将各款设备融合成一个“超级终端”，便于操作和共享各设备资源。[3][4][5]系统架构支持多内核，包括 Linux 内核、LiteOS 和鸿蒙微内核，可按各种智能设备选择所需内核，例如在低功耗设备上使用 LiteOS 内核。[6][7]2019 年 8 月华为发布首款搭载鸿蒙操作系统的产品 “荣耀智能屏”，之后于 2021 年 6 月发布搭载鸿蒙操作系统的智能手机、平板电脑和智能手表。&lt;/p>
&lt;p>Linux 内核是最大且变动最快的开源项目之一，它由大约 53,600 个文件和近 2,000 万行代码组成。在全世界范围内超过 15,600 位程序员为它贡献代码，Linux 内核项目的维护者使用了如下的协作模型。&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/1ef62d82-d29c-457a-b63f-3d4dfa09d652/640" alt="">&lt;/p>
&lt;p>如果你有&lt;strong>深入 linux 内核的激情&lt;/strong>和&lt;strong>极客精神&lt;/strong>，可以为 Linux 项目贡献源码，具体如何提交第一个补丁，可以详细阅读下面文章，这里篇幅有限不展开：&lt;/p>
&lt;p>&lt;a href="https://opensource.com/article/18/8/first-linux-kernel-patch">https://opensource.com/article/18/8/first-linux-kernel-patch&lt;/a>&lt;/p>
&lt;p>Linux 开源代码仓库：&lt;/p>
&lt;p>&lt;a href="https://github.com/torvalds/linux">https://github.com/torvalds/linux&lt;/a>&lt;/p>
&lt;p>提交给 kernel 的补丁，刚开始可能不需要高深的技术，比如这个补丁，可以   是简单的对于已有内容的格式或拼写错误的修正，比如这个来自 4 岁小朋友的补丁：&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/1ef62d82-d29c-457a-b63f-3d4dfa09d652/640" alt="">&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/1ef62d82-d29c-457a-b63f-3d4dfa09d652/640" alt="">&lt;/p>
&lt;p>&lt;strong>Linux 内核学习资源&lt;/strong>&lt;/p>
&lt;p>&lt;strong>源码：&lt;/strong>&lt;/p>
&lt;p>&lt;a href="https://elixir.bootlin.com/linux/latest/source">https://elixir.bootlin.com/linux/latest/source&lt;/a>&lt;/p>
&lt;p>在线交叉索引看源码，包括 Linux 几乎所有版本；&lt;/p>
&lt;p>&lt;a href="https://github.com/torvalds/linux">https://github.com/torvalds/linux&lt;/a>&lt;/p>
&lt;p>内核 github 仓库，可以下载本地，编译，修改和开发。&lt;/p>
&lt;p>&lt;strong>网站&lt;/strong>&lt;/p>
&lt;p>&lt;a href="http://www.kernel.org">&lt;strong>http://www.kernel.org&lt;/strong>&lt;/a>&lt;/p>
&lt;p>可以通过这个网站上下载内核的源代码和补丁、跟踪内核 bug 等&lt;/p>
&lt;p>&lt;a href="http://lwn.net">&lt;strong>http://lwn.net&lt;/strong>&lt;/a>&lt;/p>
&lt;p>Linux 内核最新消息，提供给了定期的与内核开发相关的报道&lt;/p>
&lt;p>&lt;a href="https://www.wiki.kernel.org/">&lt;strong>https://www.wiki.kernel.org/&lt;/strong>&lt;/a>&lt;/p>
&lt;p>各种子模块 wiki 列表&lt;/p>
&lt;p>&lt;a href="http://www.linuxdoc.org">&lt;strong>http://www.linuxdoc.org&lt;/strong>&lt;/a>&lt;/p>
&lt;p>Linux Documentation Project(Linux 文档项目)，拥有大量称为 “HowTo”
的文档，其中一些是技术性的，并涉及到一些内核相关的主题。&lt;/p>
&lt;p>&lt;a href="http://www.kerneltravel.net/">&lt;strong>http://www.kerneltravel.net/&lt;/strong>&lt;/a>&lt;/p>
&lt;p>国内 Linux 内核之旅开源社区&lt;/p>
&lt;p>&lt;a href="http://www.linux-mm.org">&lt;strong>http://www.linux-mm.org&lt;/strong>&lt;/a>
该页面面向 Linux 内存管理开发，其中包含大量有用的信息，并且还包含大量与内核相关的 Web 站点链接。&lt;/p>
&lt;p>&lt;a href="http://www.wowotech.net">&lt;strong>http://www.wowotech.net&lt;/strong>&lt;/a>&lt;/p>
&lt;p>博客专注分享 linux 内核知识（偏嵌入式方向）, 很多文章都非常精华和透彻，值得内核学习者学习；&lt;/p>
&lt;p>&lt;a href="https://blog.csdn.net/gatieme">&lt;strong>https://blog.csdn.net/gatieme&lt;/strong>&lt;/a>&lt;/p>
&lt;p>操作系统优质博客，可以学习 linux 调度相关内核知识；&lt;/p>
&lt;p>&lt;a href="https://blog.csdn.net/dog250">&lt;strong>https://blog.csdn.net/dog250&lt;/strong>&lt;/a>&lt;/p>
&lt;p>dog250 的文章都比较深刻，属于 Linux 内核进阶，可能不太适合入门，建议入门后，再看这里文章，会让你醍醐灌顶。&lt;/p>
&lt;p>&lt;a href="https://www.kernel.org/doc">&lt;strong>https://www.kernel.org/doc&lt;/strong>&lt;/a>&lt;/p>
&lt;p>内核文档&lt;/p>
&lt;p>&lt;strong>书籍&lt;/strong>&lt;/p>
&lt;p>《深入理解 Linux 内核》&lt;/p>
&lt;p>《深入 Linux 内核架构》&lt;/p>
&lt;p>《Linux 内核设计与实现》&lt;/p>
&lt;p>《Linux 内核源代码情景分析》&lt;/p>
&lt;p>《深入理解 LINUX 网络内幕》&lt;/p>
&lt;p>《深入理解 Linux 虚拟内存管理》&lt;/p>
&lt;p>《Linux 设备驱动程序》&lt;/p>
&lt;h3 id="git-分布式版本控制系统">Git 分布式版本控制系统&lt;/h3>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/1ef62d82-d29c-457a-b63f-3d4dfa09d652/640" alt="">&lt;/p>
&lt;p>2005 年，Linus 还创建了 &lt;strong>Git&lt;/strong>，这是非常流行的分布式源代码控制系统。迅速将 Linux 内核源代码树从专有 Bitkeeper 迁移到新创建的开源 Git。&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/1ef62d82-d29c-457a-b63f-3d4dfa09d652/640" alt="">&lt;/p>
&lt;p>&lt;strong>git 架构&lt;/strong>&lt;/p>
&lt;p>&lt;strong>Git&lt;/strong> 是出于需要而创建的，不是因为发现源代码控制很有趣，而是因为其他多数源代码控制系统不好用，不能满足当时开发需求，并且 git 在 Linux 开发模型中确实运行得相当好，BitKeeper 变得站不住脚。&lt;/p>
&lt;p>完美适应现代开源软件的开发模式，分布式版本管理：&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/1ef62d82-d29c-457a-b63f-3d4dfa09d652/640" alt="">&lt;/p>
&lt;h3 id="linux-内核名人堂">Linux 内核名人堂&lt;/h3>
&lt;p>让我们膜拜一下对 Linux 内核做出核心贡献的大神们：&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/1ef62d82-d29c-457a-b63f-3d4dfa09d652/640" alt="">&lt;/p>
&lt;p>&lt;strong>林纳斯 · 班奈狄克 · 托瓦兹&lt;/strong>（1969 年 12 月 28 日－），生于芬兰赫尔辛基市，拥有美国国籍，Linux 内核的最早作者，随后发起了这个开源项目，担任 Linux 内核的首要架构师与项目协调者，是当今世界最著名的电脑程序员、黑客之一。他还发起了开源项目 Git，并为主要的开发者。&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/1ef62d82-d29c-457a-b63f-3d4dfa09d652/640" alt="">&lt;/p>
&lt;p>&lt;strong>大卫 · 史提芬 · 米勒&lt;/strong>（英语：David Stephen Miller，1974 年 11 月 26 日－），网络昵称为 DaveM，生于美国新泽西州新布朗斯维克，著名程式员与骇客，负责 Linux 核心网络功能以及 SPARC 平台的实作。他也参与其他开源软件的开发，是 GCC 督导委员会的成员之一。根据 2013 年 8 月的统计，米勒是 Linux 核心源代码第二大的贡献者，自 2005 年开始，已经提交过 4989 个 patch。&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/1ef62d82-d29c-457a-b63f-3d4dfa09d652/640" alt="">&lt;/p>
&lt;p>&lt;strong>葛雷格 · 克罗 - 哈曼&lt;/strong>（英语：Greg Kroah-Hartman，姓名缩写为 GKH）， Linux 核心开发者，目前为 Linux 核心中稳定分支（&lt;code>-stable&lt;/code>）的维护者[2]，他也是 staging 子系统[2]、USB[2]driver core、debugfs、kref、kobject、sysfs kernel 子系统[2]、 TTY layer [2]、linux-hotplug、Userspace I/O（与 Hans J. Koch 共同维护）等专案的维护者[2]，也创立了 udev 专案。除此之外，他亦协助维护 Gentoo Linux 中上述程式及 kernel 的套件。&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/1ef62d82-d29c-457a-b63f-3d4dfa09d652/640" alt="">&lt;/p>
&lt;p>&lt;strong>艾伦 · 考克斯&lt;/strong>（英语：Alan Cox，1968 年 7 月 22 日－）是一名英国程序员，生于英格兰索利赫尔。他自 1991 年开始投入 Linux 内核的开发工作，在开发者社群中有很高的地位，是 Linux 开发工作中的关键人物之一。他负责维护 Linux 内核 2.2 版这个分支，在 2.4 版中也提供许多程式码，拥有自己的分支版本。他住在威尔斯斯旺西，他的妻子于 2015 年逝世[1][2][3]。2020 年他再婚[4][5]。他于 1991 年在斯旺西大学获得计算机科学理学学士学位，2005 年在那里获得工商管理硕士学位[6]。&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/1ef62d82-d29c-457a-b63f-3d4dfa09d652/640" alt="">&lt;/p>
&lt;p>&lt;strong>英格 · 蒙内&lt;/strong>（匈牙利语：Ingo Molnár），匈牙利软件程序员与骇客，在 linux 内核上有许多贡献，也拥有自己的 linux 分支版本。对于操作系统的安全性与效能提升方面，他的声名卓著，在 linux 内核中，他于 Linux-2.6.0 版加入 O(1) 排程器，在 Linux-2.6.23 版中加入&lt;strong>完全公平调度器 CFS&lt;/strong>（Completely Fair Scheduler）。&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/1ef62d82-d29c-457a-b63f-3d4dfa09d652/640" alt="">&lt;/p>
&lt;p>&lt;strong>米格尔 · 德伊卡萨&lt;/strong>（西班牙语：Miguel de Icaza ，1972 年 11 月 23 日－），生于墨西哥市，著名墨西哥籍自由软件开发者，为 GNOME 项目与 Mono 项目的发起人。但后来[何时？]退出了 GNOME 项目。&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/1ef62d82-d29c-457a-b63f-3d4dfa09d652/640" alt="">&lt;/p>
&lt;p>&lt;strong>罗伯特 · 马修 · 拉姆&lt;/strong>（英语：Robert Matthew Love，1981 年 9 月 25 日－），生于美国佛罗里达州，为著名自由软件程式开发者、作家，现职为 google 软件工程师。现居于波士顿。他是 linux 核心的主要开发者之一，主要负责程式排程、先占式核心、虚拟内存子系统、核心事件层。他也加入了 GNOME 计划。目前他在 google，主要负责 Android 系统的开发。&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/1ef62d82-d29c-457a-b63f-3d4dfa09d652/640" alt="">&lt;/p>
&lt;p>&lt;strong>安德鲁 · 基斯 · 保罗 · 莫顿&lt;/strong>（英语：Andrew Keith Paul Morton，1959 年－），生于英国英格兰，澳洲软件工程师与著名骇客。他是 Linux 核心开发社群的领导者之一，现为 ext3 的共同维护者，负责区块装置的日志层（Journaling layer for block devices，JBD）。他也是 mm tree 的负责人。&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/1ef62d82-d29c-457a-b63f-3d4dfa09d652/640" alt="">&lt;/p>
&lt;p>&lt;strong>埃里克 · 斯蒂芬 · 雷蒙&lt;/strong>（英语：Eric Steven Raymond，1957 年 12 月 4 日－），是一名程序员，《大教堂与市集》的作者、《新黑客词典》（&amp;ldquo;Jargon File&amp;rdquo;）的维护人、著名黑客。作为《新黑客词典》的主要编撰人以及维护者，雷蒙很早就被认为是黑客文化的历史学家以及人类学家。但是在 1997 年以后，雷蒙被广泛公认为是开放源代码运动的主要领导者之一，并且是最为大众所知道（并最具争议性）的黑客。&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/1ef62d82-d29c-457a-b63f-3d4dfa09d652/640" alt="">&lt;/p>
&lt;p>&lt;strong>西奥多 · 曹&lt;/strong>（英语：Theodore Y. Ts&amp;rsquo;o，1968 年 1 月 23 日－），小名&lt;strong>泰德 · 曹&lt;/strong>（Ted Tso），汉名&lt;strong>曹子德&lt;/strong>[1]，生于美国加利福尼亚州帕罗奥图，著名的自由软件工程师，专长于文件系统设计。他是 Linux 内核在北美最早的开发者，负责 ext2、ext3 与 ext4 文件系统的开发与维护工作。他也是 e2fsprogs 的开发者。为自由标准组织的创始者之一，也曾担任 Linux 基金会首席技术官。&lt;/p>
&lt;p>由于互联网发达，当前不管是从个人爱好，还是工作原因，对内核贡献的国人越来越多：&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/1ef62d82-d29c-457a-b63f-3d4dfa09d652/640" alt="">&lt;/p>
&lt;p>&lt;a href="http://www.remword.com/kps_result/all_whole_line_country.html">http://www.remword.com/kps_result/all_whole_line_country.html&lt;/a>&lt;/p>
&lt;h3 id="最后">最后&lt;/h3>
&lt;p>30 年的时间，Linux 从一个个人玩具变成现在庞然大物，估值超过 100 亿美元，Linux 还带来一股开源潮流，让开源软件百花齐放，对计算机发展和开源文化起到极大促进作用。&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/1ef62d82-d29c-457a-b63f-3d4dfa09d652/640" alt="">&lt;/p>
&lt;p>Linux 庞大的生态与发展过程，Linus 伟大而富有创造力并不足以在一篇文章中尽述。&lt;/p>
&lt;p>匆匆 30 年，Linux 已经不仅仅是改变了世界，而且已经成为了这个世界不可或缺的一部分感谢 Linus Torvalds，感谢为之致力的一切贡献者！&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/1ef62d82-d29c-457a-b63f-3d4dfa09d652/640" alt="">&lt;/p>
&lt;p>最后，为了致敬 Linux，希望大家三连支持，让更多人可以看到！&lt;/p>
&lt;h3 id="参考和扩展">参考和扩展&lt;/h3>
&lt;p>&lt;a href="http://www.atguigu.com/jsfx/5694.html">http://www.atguigu.com/jsfx/5694.html&lt;/a>&lt;/p>
&lt;p>&lt;a href="https://opensource.com/article/16/12/yearbook-9-lessons-25-years-linux-kernel-development">https://opensource.com/article/16/12/yearbook-9-lessons-25-years-linux-kernel-development&lt;/a>&lt;/p>
&lt;p>&lt;a href="https://www.reddit.com/r/linux/comments/2pqqla/kernel_commit_4_year_old_girl_fixes_formatting_to/utm_source=amp&amp;amp;utm_medium=&amp;amp;utm_content=post_title">https://www.reddit.com/r/linux/comments/2pqqla/kernel_commit_4_year_old_girl_fixes_formatting_to/utm_source=amp&amp;amp;utm_medium=&amp;amp;utm_content=post_title&lt;/a>&lt;/p>
&lt;p>&lt;a href="http://oss.org.cn/ossdocs/linux/kernel/a1/index.html">http://oss.org.cn/ossdocs/linux/kernel/a1/index.html&lt;/a>&lt;/p>
&lt;p>&lt;a href="http://www.wowotech.net/linux_kenrel/11.html">http://www.wowotech.net/linux_kenrel/11.html&lt;/a>&lt;/p>
&lt;p>&lt;a href="https://www.wikiwand.com/zh/Linux">https://www.wikiwand.com/zh/Linux&lt;/a>&lt;/p>
&lt;p>&lt;a href="https://zh.wikipedia.org/wiki/Category:Linux%E6%A0%B8%E5%BF%83%E9%A7%AD%E5%AE%A2">https://zh.wikipedia.org/wiki/Category:Linux%E6%A0%B8%E5%BF%83%E9%A7%AD%E5%AE%A2&lt;/a>&lt;/p>
&lt;p>&lt;a href="http://www.chromium.org/chromium-os/chromiumos-design-docs/software-architecture">http://www.chromium.org/chromium-os/chromiumos-design-docs/software-architecture&lt;/a>&lt;/p>
&lt;ul>
&lt;li>END -&lt;/li>
&lt;/ul>
&lt;hr>
&lt;p>&lt;strong>看完一键三连 **&lt;strong>在看 *&lt;/strong>*，&lt;strong>转发 *&lt;/strong>*，点赞 **&lt;/strong>&lt;/p>
&lt;p>&lt;strong>是对文章最大的赞赏，极客重生感谢你&lt;/strong>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/1ef62d82-d29c-457a-b63f-3d4dfa09d652/640" alt="">&lt;/p>
&lt;p>推荐阅读&lt;/p>
&lt;p>&lt;a href="http://mp.weixin.qq.com/s?__biz=MzkyMTIzMTkzNA==&amp;amp;mid=2247510568&amp;amp;idx=1&amp;amp;sn=79f335aaab5c0a36c0a66c5bfb1619ae&amp;amp;chksm=c1845d79f6f3d46f81b6fd24335eb8994c9daf21b6846d80af2cad73d9f638c5dda48b02892c&amp;amp;scene=21#wechat_redirect">图解 Linux 内核 TCP/IP 协议栈实现 | Linux 网络硬核系列&lt;/a>&lt;/p>
&lt;p>&lt;a href="http://mp.weixin.qq.com/s?__biz=MzkyMTIzMTkzNA==&amp;amp;mid=2247532046&amp;amp;idx=2&amp;amp;sn=04ffe282ce1278297d124f0c382ba665&amp;amp;chksm=c184895ff6f300497eb2bcc63d352b6d6b374606399cb7dd5b5bb59a773e674a368f9f4c9169&amp;amp;scene=21#wechat_redirect">Linux 网络子系统&lt;/a>&lt;/p>
&lt;p>&lt;a href="http://mp.weixin.qq.com/s?__biz=MzkyMTIzMTkzNA==&amp;amp;mid=2247530537&amp;amp;idx=1&amp;amp;sn=11ed00203af160568e114e093dc706b4&amp;amp;chksm=c1848f78f6f3066ee21c11b603a683d28cee63924ab8397b5702d10227cdb69a9aab66e1bb0f&amp;amp;scene=21#wechat_redirect">开源, yyds!&lt;/a>&lt;/p>
&lt;p>&lt;a href="http://mp.weixin.qq.com/s?__biz=MzkyMTIzMTkzNA==&amp;amp;mid=2247508731&amp;amp;idx=1&amp;amp;sn=b562efbcdf5183ea4db6c9bced62894c&amp;amp;chksm=c18455aaf6f3dcbcbd225fcc4a8176ffa4401db3d7c9a0da80f0d4a302ce7bee4307ee4e38ee&amp;amp;scene=21#wechat_redirect">操作系统的起源 | 开源运动的兴起&lt;/a>&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/1ef62d82-d29c-457a-b63f-3d4dfa09d652/640" alt="">&lt;/p></description></item></channel></rss>