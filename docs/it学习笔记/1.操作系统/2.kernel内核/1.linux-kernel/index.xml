<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>断念梦 – 1.Linux Kernel</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2.kernel%E5%86%85%E6%A0%B8/1.linux-kernel/</link><description>Recent content in 1.Linux Kernel on 断念梦</description><generator>Hugo -- gohugo.io</generator><atom:link href="https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2.kernel%E5%86%85%E6%A0%B8/1.linux-kernel/index.xml" rel="self" type="application/rss+xml"/><item><title>Docs: Boot Configuration</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2.kernel%E5%86%85%E6%A0%B8/1.linux-kernel/boot-configuration/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2.kernel%E5%86%85%E6%A0%B8/1.linux-kernel/boot-configuration/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://www.kernel.org/doc/html/latest/admin-guide/bootconfig.html">Linux Kernel 官网文档，Linux 内核用户和管理员指南-内核引导配置&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>Boot Configuration(引导配置) 扩展了当前内核命令行，在引导内核时，可以提供额外的运行时配置。该文件默认在 &lt;code>/boot/config-$(uname -r)&lt;/code>，每个内核版本都有一个对应的文件。&lt;/p>
&lt;p>该文件有几千行，每一行都是一个以 &lt;code>=&lt;/code> 分割的键值对，用来在系统启动内核前的引导阶段，为内核配置运行时行为&lt;/p>
&lt;h1 id="linux-namespace-配置">Linux Namespace 配置&lt;/h1>
&lt;p>CONFIG_CHECKPOINT_RESTORE=y
CONFIG_NAMESPACES=y # 是否启用 Linux Namespace
CONFIG_UTS_NS=y # 是否启用 UTS NS
CONFIG_IPC_NS=y # 是否启用 IPC NS
CONFIG_USER_NS=y
CONFIG_PID_NS=y
CONFIG_NET_NS=y # # 是否启用 NET NS
CONFIG_UIDGID_STRICT_TYPE_CHECKS=y
CONFIG_SCHED_AUTOGROUP=y
CONFIG_MM_OWNER=y&lt;/p></description></item><item><title>Docs: fs(文件系统相关参数)</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2.kernel%E5%86%85%E6%A0%B8/1.linux-kernel/kernel-%E5%8F%82%E6%95%B0/fs%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%9B%B8%E5%85%B3%E5%8F%82%E6%95%B0/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2.kernel%E5%86%85%E6%A0%B8/1.linux-kernel/kernel-%E5%8F%82%E6%95%B0/fs%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%9B%B8%E5%85%B3%E5%8F%82%E6%95%B0/</guid><description>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://www.kernel.org/doc/html/latest/admin-guide/sysctl/fs.html">官方文档,Linux 内核用户和管理员指南-/proc/sys 文档-/proc/sys/fs 文档&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;h2 id="file-max-与-file-nr">file-max 与 file-nr&lt;/h2>
&lt;h3 id="fsfile-max--52706963">fs.file-max = 52706963&lt;/h3>
&lt;p>max-file 表示系统级别的能够打开的文件描述符的数量。是对整个系统的限制，并不是针对用户的。&lt;/p>
&lt;blockquote>
&lt;p>ulimit -n 控制进程级别能够打开的文件句柄的数量。提供对 shell 及其启动的进程的可用文件句柄的控制。这是进程级别的。&lt;/p>
&lt;/blockquote>
&lt;p>当系统尝试分配比 file-max 指定的值更多的文件描述符时，通常我们会看到如下报错：&lt;code>VFS: file-max limit &amp;lt;number&amp;gt; reached&lt;/code>&lt;/p>
&lt;h3 id="fsfile-nr--int">fs.file-nr = INT&lt;/h3>
&lt;p>file-nr 中的三个值分别表示：&lt;/p>
&lt;ul>
&lt;li>已分配的文件描述符&lt;/li>
&lt;li>已分配但未使用的文件描述符&lt;/li>
&lt;li>最大文件描述符&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">[&lt;/span>lichenhao@hw-cloud-xngy-jump-server-linux-2 ~&lt;span style="color:#f92672">]&lt;/span>$ cat /proc/sys/fs/file-max
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">9223372036854775807&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">[&lt;/span>lichenhao@hw-cloud-xngy-jump-server-linux-2 ~&lt;span style="color:#f92672">]&lt;/span>$ cat /proc/sys/fs/file-nr
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>2400 0 &lt;span style="color:#ae81ff">9223372036854775807&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>通常情况下 已分配但未使用的文件描述符 的值总是为 0，这并不是错误的，只是意味着 &lt;code>已分配的文件描述符=正在使用的文件描述符&lt;/code>&lt;/p>
&lt;p>由于某些历史原因，内核虽然可以动态分配文件描述符，但是却无法再次释放它们~~~&lt;/p>
&lt;h2 id="其他">其他&lt;/h2>
&lt;h3 id="fsmay_detach_mounts--1">fs.may_detach_mounts = 1&lt;/h3>
&lt;p>未知&lt;/p>
&lt;h3 id="fsnr_open--int64">fs.nr_open = INT64&lt;/h3>
&lt;p>单个进程可分配的最大文件描述符数量。&lt;code>默认值：1024 * 1024&lt;/code>，即 1048576。&lt;/p></description></item><item><title>Docs: Kernel 参数</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2.kernel%E5%86%85%E6%A0%B8/1.linux-kernel/kernel-%E5%8F%82%E6%95%B0/kernel-%E5%8F%82%E6%95%B0/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2.kernel%E5%86%85%E6%A0%B8/1.linux-kernel/kernel-%E5%8F%82%E6%95%B0/kernel-%E5%8F%82%E6%95%B0/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://www.kernel.org/doc/html/latest/admin-guide/sysctl/index.html">官方文档,Linux 内核用户和管理员指南-/proc/sys 文档&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>内核参数是以 key/value 的方式储存的。key 就是 /proc/sys/* 目录下的某个文件，value 就是该文件的内容。&lt;/p>
&lt;p>比如 net.ipv4.ip_forward 这个 key，就在 /proc/sys/net/ipv4/ 目录下。以&lt;code>.&lt;/code>分隔的就是字符就是目录名，最后一个字段就是某某目录下的文件名。&lt;/p>
&lt;p>可以通过修改/proc/sys/*目录下的文件中的值来修改内核的参数。每个文件就是内核的一种功能，文件中的内容就是该内核功能的参数。&lt;/p>
&lt;p>注意事项：&lt;/p>
&lt;ul>
&lt;li>一般情况下，内核参数的 0 和 1 这两个值表示如下含义：
&lt;ul>
&lt;li>**0 &lt;strong>表示&lt;/strong> 否，**即错误、拒绝、关闭等等&lt;/li>
&lt;li>&lt;strong>1&lt;/strong> 表示 **是，**即正确、允许、开启等等&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>sysctl 工具用来配置与显示在 /proc/sys 目录中的内核参数．如果想使参数长期保存，可以通过编辑 /etc/sysctl.conf 文件来实现。&lt;/li>
&lt;li>修改/proc 下内核参数文件内容，不能使用编辑器来修改内核参数文件，理由是由于内核随时可能更改这些文件中的任意一个，另外，这些内核参数文件都是虚拟文件，实际中不存在，因此不能使用编辑器进行编辑，而是使用 echo 命令，然后从命令行将输出重定向至 /proc 下所选定的文件中。参数修改后立即生效，但是重启系统后，该参数又恢复成默认值。因此，想永久更改内核参数，需要修改 /etc/sysctl.conf 文件。
&lt;ul>
&lt;li>&lt;code>echo 1 &amp;gt; /proc/sys/net/ipv4/ip_forward&lt;/code>&lt;/li>
&lt;li>&lt;code>sysctl -w net.ipv4.ip_forward=1&lt;/code>&lt;/li>
&lt;li>永久的方法：
&lt;ul>
&lt;li>&lt;code>echo &amp;quot;net.ipv4.ip_forward=1&amp;quot; &amp;gt;&amp;gt; /etc/sysctl.conf&lt;/code>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>如果想使参数马上生效，也可以执行如下命令 &lt;code>sysctl -p&lt;/code>&lt;/li>
&lt;/ul>
&lt;h1 id="procsys-目录的组成">/proc/sys 目录的组成&lt;/h1>
&lt;p>/proc/sys 目录下的每一个子目录，都表示一种内核参数的分类，大体可以分为如下几类：&lt;/p>
&lt;ul>
&lt;li>&lt;strong>abi/&lt;/strong> # execution domains &amp;amp; personalities&lt;/li>
&lt;li>**debug/ **# &lt;!-- raw HTML omitted -->&lt;/li>
&lt;li>&lt;strong>dev/&lt;/strong> # device specific information (eg dev/cdrom/info)&lt;/li>
&lt;li>&lt;strong>fs/&lt;/strong> # specific filesystems filehandle, inode, dentry and quota tuning binfmt_misc &amp;lt;Kernel Support for miscellaneous Binary Formats (binfmt_misc)&amp;gt;&lt;/li>
&lt;li>&lt;strong>kernel/&lt;/strong> # global kernel info / tuning miscellaneous stuff&lt;/li>
&lt;li>&lt;strong>net/&lt;/strong> # networking stuff, for documentation look in: &amp;lt;Documentation/networking/&amp;gt;&lt;/li>
&lt;li>&lt;strong>proc/&lt;/strong> # &lt;!-- raw HTML omitted -->&lt;/li>
&lt;li>&lt;strong>sunrpc/&lt;/strong> # SUN Remote Procedure Call (NFS)&lt;/li>
&lt;li>&lt;strong>vm/&lt;/strong> # memory management tuning buffer and cache management&lt;/li>
&lt;li>**user/ **# Per user per user namespace limits&lt;/li>
&lt;/ul></description></item><item><title>Docs: Kernel 的安装与卸载</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2.kernel%E5%86%85%E6%A0%B8/1.linux-kernel/kernel-%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E5%8D%B8%E8%BD%BD/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2.kernel%E5%86%85%E6%A0%B8/1.linux-kernel/kernel-%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E5%8D%B8%E8%BD%BD/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://mp.weixin.qq.com/s/1xRc4DzyG4c8e2XYGk28Vg">https://mp.weixin.qq.com/s/1xRc4DzyG4c8e2XYGk28Vg&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;h1 id="ubuntu">Ubuntu&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://kernel.ubuntu.com/~kernel-ppa/mainline/">https://kernel.ubuntu.com/~kernel-ppa/mainline/&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;h2 id="更换内核">更换内核&lt;/h2>
&lt;p>awk -F&amp;rsquo; &amp;lsquo;$1==&amp;quot;\tmenuentry &amp;quot; {print i++ &amp;quot; : &amp;quot; $2}&amp;rsquo; /boot/grub/grub.cfg&lt;/p>
&lt;h1 id="centos">CentOS&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="http://elrepo.org/tiki/tiki-index.php">ELRepo 安装文档&lt;/a>&lt;/li>
&lt;li>elrepo 的内核 rpm 包不全，暂时也不知道去哪找，先把能找到的网址都记下来
&lt;ul>
&lt;li>&lt;a href="https://buildlogs.centos.org/c7-kernels.x86_64/kernel/">https://buildlogs.centos.org/c7-kernels.x86_64/kernel/&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://buildlogs.centos.org/c7-kernels.x86_64/kernel/20200330213326/4.19.113-300.el8.x86_64/?C=N;O=A">https://buildlogs.centos.org/c7-kernels.x86_64/kernel/20200330213326/4.19.113-300.el8.x86_64/?C=N;O=A&lt;/a>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;h2 id="安装-linux-内核的存储库">安装 linux 内核的存储库&lt;/h2>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>rpm --import https://www.elrepo.org/RPM-GPG-KEY-elrepo.org
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>yum install -y https://www.elrepo.org/elrepo-release-7.el7.elrepo.noarch.rpm
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="安装-linux-内核">安装 linux 内核&lt;/h2>
&lt;p>查看可用的 linux 内核版本&lt;/p>
&lt;blockquote>
&lt;p>版本性质：主分支 ml(mainline)，稳定版(stable)，长期维护版 lt(longterm)&lt;/p>
&lt;/blockquote>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>yum --disablerepo&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;*&amp;#34;&lt;/span> --enablerepo&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;elrepo-kernel&amp;#34;&lt;/span> list available
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>安装指定版本的 Linux 内核&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>yum --enablerepo&lt;span style="color:#f92672">=&lt;/span>elrepo-kernel install kernel-lt-devel kernel-lt kernel-lt-headers -y
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>(可选)安装新内核工具&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>yum remove kernel-tools-libs.x86_64 kernel-tools.x86_64
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>yum --disablerepo&lt;span style="color:#f92672">=&lt;/span>* --enablerepo&lt;span style="color:#f92672">=&lt;/span>elrepo-kernel install kernel-lt-tools kernel-tools-libs kernel-lt-headers -y
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="更换默认内核">更换默认内核&lt;/h2>
&lt;h3 id="centos7">CentOS7&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># 查找需要设为默认启动的内核名称&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>grep &lt;span style="color:#e6db74">&amp;#34;^menuentry&amp;#34;&lt;/span> /boot/grub2/grub.cfg | cut -d &lt;span style="color:#e6db74">&amp;#34;&amp;#39;&amp;#34;&lt;/span> -f2
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># 设置默认内核&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>grub2-set-default &lt;span style="color:#e6db74">&amp;#34;CentOS Linux (5.4.173-1.el7.elrepo.x86_64) 7 (Core)&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># 检查默认内核版本&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>grub2-editenv list
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>设置完成后，执行 &lt;code>reboot&lt;/code> 命令重启机器&lt;/p>
&lt;p>卸载旧版内核&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># 使用 package-cleanup 工具卸载旧内核，超过3个才会删&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>package-cleanup --oldkernels
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># 查看 旧版内核信息&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>rpm -qa | grep kernel
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># 卸载旧版内核&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>yum remove kernel-3.10.0-1127.19.1.el7.x86_64
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="centos-8">CentOS 8&lt;/h3>
&lt;p>查看当前默认启动的内核&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">[&lt;/span>root@tiny-server ~&lt;span style="color:#f92672">]&lt;/span>&lt;span style="color:#75715e"># grubby --default-kernel&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>/boot/vmlinuz-4.18.0-193.28.1.el8_2.x86_64
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>查看系统安装的全部内核：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">[&lt;/span>root@tiny-server ~&lt;span style="color:#f92672">]&lt;/span>&lt;span style="color:#75715e"># grubby --info=ALL&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>index&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">0&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>kernel&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;/boot/vmlinuz-5.9.1-1.el8.elrepo.x86_64&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>args&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;ro crashkernel=auto resume=/dev/mapper/cl-swap rd.lvm.lv=cl/root rd.lvm.lv=cl/swap net.ifnames=0 rhgb quiet intel_iommu=on &lt;/span>$tuned_params&lt;span style="color:#e6db74">&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>root&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;/dev/mapper/cl-root&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>initrd&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;/boot/initramfs-5.9.1-1.el8.elrepo.x86_64.img &lt;/span>$tuned_initrd&lt;span style="color:#e6db74">&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>title&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;Red Hat Enterprise Linux (5.9.1-1.el8.elrepo.x86_64) 8.2 (Ootpa)&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>id&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;12ab47b22fef4c02bcdc88b340d5f706-5.9.1-1.el8.elrepo.x86_64&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>index&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>kernel&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;/boot/vmlinuz-4.18.0-193.28.1.el8_2.x86_64&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>args&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;ro crashkernel=auto resume=/dev/mapper/cl-swap rd.lvm.lv=cl/root rd.lvm.lv=cl/swap net.ifnames=0 rhgb quiet intel_iommu=on &lt;/span>$tuned_params&lt;span style="color:#e6db74">&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>root&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;/dev/mapper/cl-root&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>initrd&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;/boot/initramfs-4.18.0-193.28.1.el8_2.x86_64.img &lt;/span>$tuned_initrd&lt;span style="color:#e6db74">&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>title&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;CentOS Linux (4.18.0-193.28.1.el8_2.x86_64) 8 (Core)&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>id&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;12ab47b22fef4c02bcdc88b340d5f706-4.18.0-193.28.1.el8_2.x86_64&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>设置默认启动的内核&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># 使用路径来指定内核，可以使用--set-default=Kernel_PATH&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">[&lt;/span>root@tiny-server ~&lt;span style="color:#f92672">]&lt;/span>&lt;span style="color:#75715e"># grubby --set-default=/boot/vmlinuz-5.9.1-1.el8.elrepo.x86_64&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>The default is /boot/loader/entries/12ab47b22fef4c02bcdc88b340d5f706-5.9.1-1.el8.elrepo.x86_64.conf with index &lt;span style="color:#ae81ff">0&lt;/span> and kernel /boot/vmlinuz-5.9.1-1.el8.elrepo.x86_64
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">[&lt;/span>root@tiny-server ~&lt;span style="color:#f92672">]&lt;/span>&lt;span style="color:#75715e"># grubby --default-kernel&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>/boot/vmlinuz-5.9.1-1.el8.elrepo.x86_64
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># 使用index来指定内核，则使用--set-default-index=INDEX&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">[&lt;/span>root@tiny-server ~&lt;span style="color:#f92672">]&lt;/span>&lt;span style="color:#75715e"># grubby --set-default-index=1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>The default is /boot/loader/entries/12ab47b22fef4c02bcdc88b340d5f706-4.18.0-193.28.1.el8_2.x86_64.conf with index &lt;span style="color:#ae81ff">1&lt;/span> and kernel /boot/vmlinuz-4.18.0-193.28.1.el8_2.x86_64
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">[&lt;/span>root@tiny-server ~&lt;span style="color:#f92672">]&lt;/span>&lt;span style="color:#75715e"># grubby --default-kernel&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>/boot/vmlinuz-4.18.0-193.28.1.el8_2.x86_64
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>添加/删除内核启动参数：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># 对所有的内核都删除某个参数&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">[&lt;/span>root@tiny-server ~&lt;span style="color:#f92672">]&lt;/span>&lt;span style="color:#75715e"># grubby --update-kernel=ALL --remove-args=intel_iommu=on&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># 对所有的内核都添加某个参数&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">[&lt;/span>root@tiny-server ~&lt;span style="color:#f92672">]&lt;/span>&lt;span style="color:#75715e"># grubby --update-kernel=ALL --args=intel_iommu=on&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># 对某个的内核添加启动参数&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">[&lt;/span>root@tiny-server ~&lt;span style="color:#f92672">]&lt;/span>&lt;span style="color:#75715e"># grubby --update-kernel=/boot/vmlinuz-5.9.1-1.el8.elrepo.x86_64 --args=intel_iommu=on&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>查看特定内核的具体信息：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">[&lt;/span>root@tiny-server ~&lt;span style="color:#f92672">]&lt;/span>&lt;span style="color:#75715e"># grubby --info=/boot/vmlinuz-5.9.1-1.el8.elrepo.x86_64&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>index&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">0&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>kernel&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;/boot/vmlinuz-5.9.1-1.el8.elrepo.x86_64&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>args&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;ro crashkernel=auto resume=/dev/mapper/cl-swap rd.lvm.lv=cl/root rd.lvm.lv=cl/swap net.ifnames=0 rhgb quiet intel_iommu=on &lt;/span>$tuned_params&lt;span style="color:#e6db74">&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>root&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;/dev/mapper/cl-root&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>initrd&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;/boot/initramfs-5.9.1-1.el8.elrepo.x86_64.img &lt;/span>$tuned_initrd&lt;span style="color:#e6db74">&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>title&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;Red Hat Enterprise Linux (5.9.1-1.el8.elrepo.x86_64) 8.2 (Ootpa)&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>id&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;12ab47b22fef4c02bcdc88b340d5f706-5.9.1-1.el8.elrepo.x86_64&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div></description></item><item><title>Docs: Module(模块)</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2.kernel%E5%86%85%E6%A0%B8/1.linux-kernel/module%E6%A8%A1%E5%9D%97/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2.kernel%E5%86%85%E6%A0%B8/1.linux-kernel/module%E6%A8%A1%E5%9D%97/</guid><description>
&lt;h1 id="linux-模块介绍">Linux 模块介绍&lt;/h1>
&lt;p>&lt;strong>Loadable Kernel Module(全称为动态可加载内核模块，简称 LKM)，简称为模块&lt;/strong>。模块是具有独立功能的程序，它可以被单独编译，但不能独立运行。它在运行时被链接到内核作为内核的一部分在内核空间运行，这与运行在用户空间的进程是不同的。模块通常由一组函数和数据结构组成，用来实现一种文件系统、一个驱动程序或其他内核上层的功能。&lt;/p>
&lt;p>总之，模块是一个伪内核（从某种意义上来说，内核也是一个模块）或其他内核模块提供使用功能的代码块。&lt;/p>
&lt;p>模块的管理方式：使用 systemd 控制的 unit：systemd-modules-load.service&lt;/p>
&lt;p>该 unit 启动后读取其中指定目录下的配置以加载模块&lt;/p>
&lt;h1 id="模块配置">模块配置&lt;/h1>
&lt;p>系统启动后，依次从上到下从以下目录读取&lt;strong>模块的额外参数&lt;/strong>并应用它们&lt;/p>
&lt;ul>
&lt;li>/etc/modprobe.d/*.conf&lt;/li>
&lt;li>/run/modprobe.d/*.conf&lt;/li>
&lt;li>/usr/lib/modprobe.d/*.conf&lt;/li>
&lt;/ul>
&lt;p>系统启动后，依次从上到下从以下目录读取&lt;strong>模块名称&lt;/strong>以加载它们&lt;/p>
&lt;ul>
&lt;li>/etc/modules-load.d/*.conf&lt;/li>
&lt;li>/run/modules-load.d/*.conf&lt;/li>
&lt;li>/usr/lib/modules-load.d/*.conf&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>~&lt;span style="color:#f92672">]&lt;/span>&lt;span style="color:#75715e"># cat /etc/modules-load.d/br_netfilter.conf&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>br_netfilter
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ul>
&lt;li>该目录格式为每个模块一行&lt;/li>
&lt;li>注意不要给模块名加任何后缀&lt;/li>
&lt;/ul>
&lt;p>/etc/sysconfig/modules/*.modules # 系统读取该目录下的脚本加载用户自定义的模块，该目录下的文件必须要以 &lt;code>.modules&lt;/code> 为文件名结尾。该文件会被系统视为 shell 脚本，因此该文件应以解释器指令作为开头第一行。
/usr/lib/modules/$(uname -r)/kernel/ # 模块所在目录，不同类型的模块有不同目录&lt;/p>
&lt;p>Note：不同版本内核的模块目录不同，所有安装的模块都在该目录下，如果需要把模块加载到内核中，则可以通过命令来加载该目录下的对应模块即可&lt;/p>
&lt;ol>
&lt;li>arch # 与硬件平台有关的项目，例如 CPU 的等级等等&lt;/li>
&lt;li>crypto # 核心所支持的加密的技术，例如 md5 或者 des 等等&lt;/li>
&lt;li>drivers # 一些硬件的驱动程序，例如显卡、网卡、PCI 相关硬件等等&lt;/li>
&lt;li>fs # 核心所支持的 filesystems，例如 vfat、reiserfs、nfs 等等&lt;/li>
&lt;li>lib # 一些函数库&lt;/li>
&lt;li>net # 与网络有关的各项协定数据，还有防火墙模块&lt;/li>
&lt;li>sound # 与音效有关的各项模块&lt;/li>
&lt;/ol>
&lt;p>&lt;strong>模块之间的依赖性&lt;/strong>
使用 depmod 命令读取 &lt;strong>/lib/modules/$(uname -r )/kernel/&lt;/strong> 目录下每个模块并分析，然后把分析结果写入/lib/modules/$(uname -r)/modules.dep 文件中。&lt;/p>
&lt;h1 id="模块管理命令行工具">模块管理命令行工具&lt;/h1>
&lt;h2 id="查看已加载模块的当前参数">查看已加载模块的当前参数&lt;/h2>
&lt;p>参考：&lt;a href="https://serverfault.com/questions/62316/how-do-i-list-loaded-linux-module-parameter-values">https://serverfault.com/questions/62316/how-do-i-list-loaded-linux-module-parameter-values&lt;/a>&lt;/p>
&lt;h2 id="depmod--输出适用于-modprobe-可用性的依赖列表">depmod # 输出适用于 modprobe 可用性的依赖列表&lt;/h2>
&lt;p>depmod 输出的分析结果将会写入 /lib/modules/$(uname -r)/modules.dep 文件中。&lt;/p>
&lt;p>EXAMPLE&lt;/p>
&lt;ol>
&lt;li>depmod -n # 可以不写入文件而把结果输出到屏幕上&lt;/li>
&lt;li>depmod -e # 显示出目前已载入的不可执行的模块名称&lt;/li>
&lt;/ol>
&lt;h2 id="lsmod-显示当前系统下已经加载了哪些模块">lsmod #显示当前系统下已经加载了哪些模块&lt;/h2>
&lt;p>共三列信息 Module(模块名)、size(模块的大小)、Used by(此模块被哪个模块所使用)&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>root@lichenhao:~# lsmod
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Module Size Used by
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>ip_vs &lt;span style="color:#ae81ff">155648&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>xt_conntrack &lt;span style="color:#ae81ff">16384&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>xt_MASQUERADE &lt;span style="color:#ae81ff">20480&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>......略
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>EXAMPLE&lt;/p>
&lt;h2 id="modinfo--通过模块名或者模块文件名来查看模块信息">modinfo # 通过模块名或者模块文件名来查看模块信息&lt;/h2>
&lt;p>下面就是一个 ip_vs 模块的信息示例，第一列是想要显示的信息名称，第二列是该信息的具体内容&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>root@lichenhao:~# modinfo ip_vs
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>filename: /lib/modules/5.4.0-73-generic/kernel/net/netfilter/ipvs/ip_vs.ko
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>license: GPL
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>srcversion: D98100F31C2694A169510A5
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>depends: nf_conntrack,nf_defrag_ipv6,libcrc32c
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>retpoline: Y
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>intree: Y
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>name: ip_vs
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>vermagic: 5.4.0-73-generic SMP mod_unload modversions
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>sig_id: PKCS#7
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>signer: Build time autogenerated kernel key
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>sig_key: 76:5C:D9:9F:5C:00:1C:F9:61:BE:32:67:DA:52:57:FE:F4:C2:E1:6E
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>sig_hashalgo: sha512
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>signature: 40:B0:9F:92:3C:6C:C8:9B:A2:E8:AA:91:15:44:DB:C6:0E:6E:31:0A:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> 04:7F:42:FD:C0:EE:BB:8D:8B:67:49:A0:6A:72:8E:99:14:98:F3:D3:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ......略
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>parm: conn_tab_bits:Set connections&lt;span style="color:#960050;background-color:#1e0010">&amp;#39;&lt;/span> hash size &lt;span style="color:#f92672">(&lt;/span>int&lt;span style="color:#f92672">)&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>我们可以通过 -F 选项来只列出来指定信息的值。&lt;/p>
&lt;p>OPTIONS&lt;/p>
&lt;ul>
&lt;li>&lt;strong>-F,&amp;ndash;field &lt;!-- raw HTML omitted -->&lt;/strong> # 仅仅列出指定字段的值，这对于在脚本中使用非常有用。STRING 就是上面示例中，第一列的字符串，比如 filename、license 等等，效果如下：&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>root@lichenhao:~# modinfo -F filename ip_vs
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>/lib/modules/5.4.0-73-generic/kernel/net/netfilter/ipvs/ip_vs.ko
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>root@lichenhao:~# modinfo -F license ip_vs
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>GPL
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ul>
&lt;li>-F,&amp;ndash;field 选项的简化用法
&lt;ul>
&lt;li>&lt;strong>-a, &amp;ndash;author&lt;/strong> # 仅列出作者名称&lt;/li>
&lt;li>&lt;strong>-d, &amp;ndash;description&lt;/strong> # 仅列出 module 的 description&lt;/li>
&lt;li>&lt;strong>-l, &amp;ndash;license&lt;/strong> # 仅列出 module 的 license&lt;/li>
&lt;li>**-n, &amp;ndash;filename **#仅列出 module 的 filename 项(module 的文件所在路径)&lt;/li>
&lt;li>&lt;strong>-p, &amp;ndash;parameters&lt;/strong> # 仅列出 modeule 的可用参数。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>-b, &amp;ndash;basedir &lt;!-- raw HTML omitted -->&lt;/strong> #&lt;/li>
&lt;li>**-k KERNEL **#&lt;/li>
&lt;/ul>
&lt;p>EXAMPLE&lt;/p>
&lt;h2 id="modprobe--通过-module-的名字管理-module不能通过文件名">modprobe # 通过 module 的名字管理 module(不能通过文件名)&lt;/h2>
&lt;p>&lt;strong>modprobe [OPTIONS] ModuleName&lt;/strong>
如果用该命令不加任何 OPTIONS 则是加载 module，重启后消失&lt;/p>
&lt;p>modprobe(module 探针)(自动处理可载入模块)是 linux 的一个命令，可载入指定的个别模块，或是载入一组相依的模块。modprobe 会根据 depmod.dep 文件的相依关系，决定要载入哪些模块。若在载入过程中发生错误，在 modprobe 会卸载整组的模块&lt;/p>
&lt;p>OPTIONS&lt;/p>
&lt;ul>
&lt;li>&lt;strong>-c&lt;/strong> # 列出目前系统所有的模块&lt;/li>
&lt;li>&lt;strong>-f&lt;/strong> # 强制载入该模块&lt;/li>
&lt;li>&lt;strong>-r&lt;/strong> # 移除摸个 module&lt;/li>
&lt;/ul>
&lt;p>EXAMPLE&lt;/p>
&lt;h2 id="rmmod--卸载模块">rmmod # 卸载模块&lt;/h2>
&lt;h1 id="modeprobed-配置文件详解">modeprobe.d 配置文件详解&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://man7.org/linux/man-pages/man5/modprobe.d.5.html">Manual(手册)，modprobe.d(5)&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>可用指令：&lt;/p>
&lt;ul>
&lt;li>&lt;strong>alias&lt;/strong> &amp;lt;&lt;strong>Wildcard&amp;gt; modulename&lt;/strong> #&lt;/li>
&lt;li>&lt;strong>blacklist&lt;/strong> &lt;strong>&lt;!-- raw HTML omitted -->&lt;/strong>&lt;/li>
&lt;li>&lt;strong>install &lt;!-- raw HTML omitted --> &lt;!-- raw HTML omitted -->&amp;hellip;&lt;/strong> # 该命令指示 modprobe 工具运行我指定的命令，而不是像往常一样在内核中插入模块。该命令可以是任何 shell 命令: 这允许你做任何类型的复杂处理，你可能希望。例如，如果模块 “fred” 与已经安装的模块 “barney” 一起工作得更好 (但它不依赖于它，所以 modprobe 不会自动加载它)，你可以说 “安装 fred /sbin/modprobe barney; /sbin/modprobe-ignore-install fred”，你想做什么就做什么。注意 &amp;ndash; ignore-install，它阻止第二个 modprobe 再次运行相同的 install 命令。另请参阅下面的删除。
&lt;ul>
&lt;li>注意：这个命令作为提供额外模块依赖的问题的解决方案的长期未来是不确定的，它打算用一个警告来代替这个命令，说明它在将来的版本中的某个时候最终被删除或弃用。它的使用使分发工具 (例如 mkinitrd) 对模块依赖关系的自动确定变得复杂 (因为它们现在需要以某种方式解释安装命令可能在做什么。在一个完美的世界中，模块将在不使用此命令的情况下提供所有依赖项信息，并且正在努力在 linux 内核中实现软依赖项支持。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>options &lt;!-- raw HTML omitted --> &lt;!-- raw HTML omitted -->&amp;hellip;&lt;/strong> #&lt;/li>
&lt;li>**remove &lt;!-- raw HTML omitted --> &lt;!-- raw HTML omitted -->&amp;hellip; **#&lt;/li>
&lt;li>&lt;strong>softdep&lt;/strong> &lt;strong>&lt;!-- raw HTML omitted --> pre: modules&amp;hellip; post: modules&amp;hellip;&lt;/strong> #&lt;/li>
&lt;/ul></description></item><item><title>Docs: net(网络相关参数)</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2.kernel%E5%86%85%E6%A0%B8/1.linux-kernel/kernel-%E5%8F%82%E6%95%B0/net%E7%BD%91%E7%BB%9C%E7%9B%B8%E5%85%B3%E5%8F%82%E6%95%B0/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2.kernel%E5%86%85%E6%A0%B8/1.linux-kernel/kernel-%E5%8F%82%E6%95%B0/net%E7%BD%91%E7%BB%9C%E7%9B%B8%E5%85%B3%E5%8F%82%E6%95%B0/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://man7.org/linux/man-pages/man5/proc.5.html#DESCRIPTION">Manual(手册)，/proc/sys 部分&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.kernel.org/doc/html/latest/admin-guide/sysctl/net.html">官方文档，Linux 内核用户和管理员指南-/proc/sys 文档-/proc/sys/net 文档&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.kernel.org/doc/html/latest/networking/ip-sysctl.html">官方文档，Linux 网络文档-IP Sysctl(ipv4、ipv6、bridge 等相关参数)&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>/proc/sys/net 目录下通常包含下面的一个或多个子目录&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>Directory&lt;/th>
&lt;th>Content&lt;/th>
&lt;th>Directory&lt;/th>
&lt;th>Content&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>core&lt;/td>
&lt;td>General parameter&lt;/td>
&lt;td>appletalk&lt;/td>
&lt;td>Appletalk protocol&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>unix&lt;/td>
&lt;td>Unix domain sockets&lt;/td>
&lt;td>netrom&lt;/td>
&lt;td>NET/ROM&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>802&lt;/td>
&lt;td>E802 protocol&lt;/td>
&lt;td>ax25&lt;/td>
&lt;td>AX25&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>ethernet&lt;/td>
&lt;td>Ethernet protocol&lt;/td>
&lt;td>rose&lt;/td>
&lt;td>X.25 PLP layer&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>ipv4&lt;/td>
&lt;td>IP version 4&lt;/td>
&lt;td>x25&lt;/td>
&lt;td>X.25 protocol&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>bridge&lt;/td>
&lt;td>Bridging&lt;/td>
&lt;td>decnet&lt;/td>
&lt;td>DEC net&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>ipv6&lt;/td>
&lt;td>IP version 6&lt;/td>
&lt;td>tipc&lt;/td>
&lt;td>TIPC&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h1 id="ipv4-参数">ipv4 参数&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://www.kernel.org/doc/html/latest/networking/ip-sysctl.html#proc-sys-net-ipv4-variables">官方文档，网络-IP Sysctl-/proc/sys/net/ipv4/* 变量&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;h2 id="netipv4ip_forward--0--非-0">net.ipv4.ip_forward = &amp;lt;0 | 非 0&amp;gt;&lt;/h2>
&lt;p>在多个网络设备间是否允许转发数据包。&lt;code>默认值：0&lt;/code>&lt;/p>
&lt;p>这个变量很特殊，它的改变会将所有配置参数重置为默认状态(&lt;a href="https://www.rfc-editor.org/rfc/rfc1122.html">RFC1122&lt;/a> 用于主机，&lt;a href="https://www.rfc-editor.org/rfc/rfc1812.html">RFC1812&lt;/a> 用于路由器)&lt;/p>
&lt;h2 id="tcp-相关参数">TCP 相关参数:&lt;/h2>
&lt;h3 id="netcoresomaxconn--65535">net.core.somaxconn = 65535&lt;/h3>
&lt;p>服务端所能 accept 即处理数据的最大客户端数量，即完成连接上限，&lt;code>默认值：128&lt;/code>。&lt;/p>
&lt;h3 id="netipv4tcp_fin_timeout--5">net.ipv4.tcp_fin_timeout = 5&lt;/h3>
&lt;p>表示如果 socket 由本端要求关闭，值为整数，单位为秒。这个参数决定了它保持在 FIN-WAIT-2 状态的时间。&lt;/p>
&lt;p>此参数确定孤立(未引用)连接在本地端终止之前等待的时间长度。当发生在远程对等端上的事件阻止或过度延迟响应时，此参数尤其有用。由于用于连接的每个套接字大约消耗 1.5K 字节的内存，内核必须主动中止和清除死的或陈旧的资源。&lt;/p>
&lt;h3 id="netipv4tcp_max_syn_backlog--integer">net.ipv4.tcp_max_syn_backlog = INTEGER&lt;/h3>
&lt;p>所能接受 SYN 报文段的最大客户端数量，即 SYN_REVD 状态(人们常说的半连接)的连接数。&lt;code>默认值：128&lt;/code>。&lt;/p>
&lt;p>设置小一点，可以用来防止 SYN 攻击。设置大一点，可以扩大并发连接&lt;/p>
&lt;p>我们知道，服务器端一般使用 mq 来减轻高并发下的洪峰冲击，将暂时不能处理的请求放入队列，后续再慢慢处理。其实操作系统已经帮我们做了一些类似的东西了，这个东西就是 backlog。服务端一般通过 accept 调用，去获取 socket。但是假设我们的程序处理不过来（比如因为程序 bug，或者设计问题，没能及时地去调用 accept），那么此时的网络请求难道就直接丢掉吗？&lt;/p>
&lt;p>当然不会！这时候，操作系统会帮我们放入 accept 队列，先暂存起来。等我们的程序缓过来了，直接调用 accept 去队列取就行了，这就达到了类似 mq 的效果。&lt;/p>
&lt;p>而 backlog，和另一个参数 /proc/sys/net/core/somaxconn 一起，决定了队列的容量，算法为：min(/proc/sys/net/core/somaxconn, backlog) 。&lt;/p>
&lt;p>&lt;strong>打个简单的比方：&lt;/strong>
某某发布公告要邀请四海之内若干客人到场参加酒席。客人参加酒席分为两个步骤：&lt;/p>
&lt;ol>
&lt;li>到大厅；&lt;/li>
&lt;li>找到座位(吃东西，比如糖果、饭菜、酒等)。&lt;/li>
&lt;/ol>
&lt;p>tcp_max_syn_backlog 用于指定酒席现场面积允许容纳多少人进来；&lt;/p>
&lt;p>somaxconn 用于指定有多少个座位。&lt;/p>
&lt;p>显然 tcp_max_syn_backlog&amp;gt;=somaxconn。&lt;/p>
&lt;p>如果要前来的客人数量超过 tcp_max_syn_backlog，那么多出来的人虽然会跟主任见面握手，但是要在门外等候；&lt;/p>
&lt;p>如果到大厅的客人数量大于 somaxconn，那么多出来的客人就会没有位置坐(必须坐下才能吃东西)，只能等待有人吃完有空位了才能吃东西。.&lt;/p>
&lt;h3 id="netipv4tcp_max_tw_buckets--5000">net.ipv4.tcp_max_tw_buckets = 5000&lt;/h3>
&lt;p>服务器 TIME-WAIT 状态连接的数量上限。&lt;code>默认值：262144&lt;/code>。&lt;/p>
&lt;p>如果超过这个数量， 新来的 TIME-WAIT 套接字会直接释放 (过多的 TIME-WAIT 套接字很影响服务器性能)。&lt;/p>
&lt;h3 id="netipv4tcp_synack_retries--2">net.ipv4.tcp_synack_retries = 2&lt;/h3>
&lt;p>表示回应第二个握手包（SYN+ACK 包）给客户端 IP 后，如果收不到第三次握手包（ACK 包），进行重试的次数。&lt;code>默认值：5&lt;/code>&lt;/p>
&lt;p>修改这个参数为 0，可以加快回收半连接，减少资源消耗，但是有一个副作用：网络状况很差时，如果对方没收到第二个握手包，可能连接服务器失败，但对于一般网站，用户刷新一次页面即可。根据抓包经验，这种情况很少，但为了保险起见，可以只在被 tcp 洪水攻击时临时启用这个参数。之所以可以把 tcp_synack_retries 改为 0，因为客户端还有 tcp_syn_retries 参数，默认是 5，即使服务器端没有重发 SYN+ACK 包，客户端也会重发 SYN 握手包。&lt;/p>
&lt;h3 id="netipv4tcp_syncookies--integer">net.ipv4.tcp_syncookies = INTEGER&lt;/h3>
&lt;p>当出现 SYN 等待队列溢出时，是否开启 cookies 来处理，可防范少量 SYN 攻击。&lt;code>默认值：1&lt;/code>。&lt;/p>
&lt;p>处在 SYN_RECV 的 TCP 连接称为半连接，存储在 SYN 队列。大量 SYN_RECV 会导致队列溢出，后续请求将被内核直接丢弃，也就是 SYN Flood 攻击。开启 syncookies 后，当 SYN 队列满了后，TCP 会通过原地址端口，目的地址端口和时间戳打造一个特别的 Sequence Number(又叫 cookie 发回去，如果是攻击者则不会有响应，如果是正常连接则把这个 SYNCookie 发回来，然后服务器端可以通过 cookie 建立连接(即使不在 SYN 队列)。&lt;/p>
&lt;h3 id="netipv4tcp_tw_recycle--1高内核版本已移除该参数">&lt;del>net.ipv4.tcp_tw_recycle = 1&lt;/del>(高内核版本已移除该参数)&lt;/h3>
&lt;p>~~是否快速回收 TCP 连接中 TIME-WAIT sockets ，~~&lt;code>~~默认值：0~~&lt;/code>&lt;/p>
&lt;h3 id="netipv4tcp_tw_reuse--1">net.ipv4.tcp_tw_reuse = 1&lt;/h3>
&lt;p>是否允许将 TIME-WAIT 状态的 sockets 重新用于新的 TCP 连接。&lt;code>默认值：0&lt;/code>&lt;/p>
&lt;h3 id="tcp-keepalive-相关参数">TCP keepalive 相关参数&lt;/h3>
&lt;p>注意：网络 keepalive 有两种&lt;/p>
&lt;ul>
&lt;li>TCP 层 keepalive&lt;/li>
&lt;li>HTTP 层 Keep-Alive&lt;/li>
&lt;/ul>
&lt;p>这里内核参数调整的是 TCP 层的 keepalive，常用于修复 ipvs 模式下长连接 timeout 问题 小于 900 即可&lt;/p>
&lt;h4 id="netipv4tcp_keepalive_time--7200">net.ipv4.tcp_keepalive_time = 7200&lt;/h4>
&lt;p>当一个 TCP 连接不再收到数据包后，经过 7200 秒后将当前连接标记为 keepalive 状态，并开始发送探测信息。将连接标记为需要保持活动状态后，将不再使用此计数器。&lt;code>默认值：7200&lt;/code>。单位秒，即 2 小时&lt;/p>
&lt;h4 id="netipv4tcp_keepalive_probes--9">net.ipv4.tcp_keepalive_probes = 9&lt;/h4>
&lt;p>TCP 连接在 keepalive 状态下的探测次数。&lt;code>默认值：9&lt;/code>&lt;/p>
&lt;h4 id="netipv4tcp_keepalive_intvl--75">net.ipv4.tcp_keepalive_intvl = 75&lt;/h4>
&lt;p>TCP 连接在 keepalive 状态下的探测间隔。&lt;code>默认值：75&lt;/code>。单位秒
该参数的值乘以 tcp_keepalive_probes 参数的值所得结果，是探测启动后，TCP 断开没有响应的连接的时间。默认情况下探测间隔是 75 秒，那么就说明，11 分钟后，没有响应的 TCP 连接将会断开&lt;/p>
&lt;h4 id="总结">总结&lt;/h4>
&lt;p>也就是说，当一个连接不再收到数据包后，经过 7200 秒后，开始发送探测，每隔 75 秒探测一次，当探测 9 次都失败时，将会断开 TCP 连接。&lt;/p>
&lt;blockquote>
&lt;p>而且，7200 计时器是从连接建立时就开始计算的，不管有没有数据包，这个时间都会持续减小。&lt;/p>
&lt;/blockquote>
&lt;p>比如，我通过 ssh 与 sshd 建立了连接，就会发现有一个 120min 的计时器，这就是 7200 秒
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/qwuk68/1626272435911-652ae22c-fd68-4d2f-b12c-38e57f111971.png" alt="image.png">
当我将 &lt;code>net.ipv4.tcp_keepalive_time&lt;/code> 参数的值改为 60 时，再次登录就会发现只有 60 秒的计时器
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/qwuk68/1626272377586-25617789-baf8-4c2f-a992-d34eccc2f074.png" alt="image.png">&lt;/p>
&lt;p>&lt;strong>为什么需要 TCP keepalive？&lt;/strong>
设想有一种场景：A 和 B 两边通过三次握手建立好 TCP 连接，然后突然间 B 就宕机了，之后时间内 B 再也没有起来。如果 B 宕机后 A 和 B 一直没有数据通信的需求，A 就永远都发现不了 B 已经挂了，那么 A 的内核里还维护着一份关于 A&amp;amp;B 之间 TCP 连接的信息，浪费系统资源。于是在 TCP 层面引入了 keepalive 的机制，A 会定期给 B 发空的数据包，通俗讲就是心跳包，一旦发现到 B 的网络不通就关闭连接。这一点在 LVS 内尤为明显，因为 LVS 维护着两边大量的连接状态信息，一旦超时就需要释放连接。&lt;/p>
&lt;h2 id="vs-相关参数">VS 相关参数&lt;/h2>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://www.kernel.org/doc/html/latest/networking/ipvs-sysctl.html">官方文档，网络-IPvs Sysctl&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;h3 id="netipv4vsconn_reuse_mode--1">net.ipv4.vs.conn_reuse_mode = 1&lt;/h3>
&lt;p>值为 &lt;code>0&lt;/code> 时，ipvs 不会对新连接进行重新负载，而是复用之前的负载结果，将新连接转发到原来的 rs 上；
值为 &lt;code>1&lt;/code> 时，ipvs 则会对新连接进行重新调度。&lt;/p>
&lt;h3 id="netipv4vsexpire_nodest_conn--0--非-0">net.ipv4.vs.expire_nodest_conn = &amp;lt;0 | 非 0&amp;gt;&lt;/h3>
&lt;p>&lt;code>默认值：0&lt;/code>
于控制连接的 rs 不可用时的处理。在开启时，如果后端 rs 不可用，会立即结束掉该连接，使客户端重新发起新的连接请求；否则将数据包&lt;strong>silently drop&lt;/strong>，也就是 DROP 掉数据包但不结束连接，等待客户端的重试。&lt;/p>
&lt;h1 id="bridge-参数">bridge 参数&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://www.kernel.org/doc/html/latest/networking/ip-sysctl.html#proc-sys-net-bridge-variables">官方文档，网络-IP Sysctl-/proc/sys/net/bridge/* 变量&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;h3 id="netbridgebridge-nf-call-iptables--1">net.bridge.bridge-nf-call-iptables = 1&lt;/h3>
&lt;p>经过 bridge 网络设备的数据包，是否会被 iptables 进行过滤处理。&lt;code>默认值：1&lt;/code>。若参数无法设置，加载 br_netfilter 模块即可&lt;/p>
&lt;h3 id="netbridgebridge-nf-call-ip6tables--1">net.bridge.bridge-nf-call-ip6tables = 1&lt;/h3>
&lt;p>经过 bridge 网络设备的数据包，是否会被 ip6tables 进行过滤处理。&lt;code>默认值：1&lt;/code>。若参数无法设置，加载 br_netfilter 模块即可&lt;/p>
&lt;h3 id="netipv6confalldisable_ipv6--1">net.ipv6.conf.all.disable_ipv6 = 1&lt;/h3>
&lt;p>是否关闭所有网络设备(lo 除外)的 ipv6 协议。&lt;code>默认值：0&lt;/code>。&lt;/p>
&lt;h3 id="netipv6conflodisable_ipv6--1">net.ipv6.conf.lo.disable_ipv6 = 1&lt;/h3>
&lt;p>是否关闭 lo 网络设备的 ipv6 协议。&lt;code>默认值：0&lt;/code>。&lt;/p>
&lt;h3 id="netipv4neighdefaultgc_stale_time--120">net.ipv4.neigh.default.gc_stale_time = 120&lt;/h3>
&lt;p>检查一次相邻层记录的有效性的周期(单位是秒)。当相邻层记录失效时，将在给它发送数据前，再解析一次。&lt;code>默认值：60&lt;/code>。&lt;/p>
&lt;h3 id="netipv4confallrp_filter--0">net.ipv4.conf.all.rp_filter = 0&lt;/h3>
&lt;p>是否校验所有网络设备上收到的数据包的源地址。&lt;code>默认值：1&lt;/code>。&lt;/p>
&lt;ul>
&lt;li>0：不开启源地址校验。&lt;/li>
&lt;li>1：开启严格的反向路径校验。对每个进来的数据包，校验其反向路径是否是最佳路径。如果反向路径不是最佳路径，则直接丢弃该数据包。&lt;/li>
&lt;li>2：开启松散的反向路径校验。对每个进来的数据包，校验其源地址是否可达，即反向路径是否能通（通过任意网口），如果反向路径不同，则直接丢弃该数据包。&lt;/li>
&lt;/ul>
&lt;p>rp_filter 参数详解见&lt;a href="https://www.yuque.com/go/doc/33223050">此处&lt;/a>&lt;/p></description></item><item><title>Docs: rp_filter</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2.kernel%E5%86%85%E6%A0%B8/1.linux-kernel/kernel-%E5%8F%82%E6%95%B0/net%E7%BD%91%E7%BB%9C%E7%9B%B8%E5%85%B3%E5%8F%82%E6%95%B0/rp_filter/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2.kernel%E5%86%85%E6%A0%B8/1.linux-kernel/kernel-%E5%8F%82%E6%95%B0/net%E7%BD%91%E7%BB%9C%E7%9B%B8%E5%85%B3%E5%8F%82%E6%95%B0/rp_filter/</guid><description>
&lt;h1 id="heading">&lt;/h1>
&lt;p>rp_filter 参数应用实例&lt;/p>
&lt;p>rp_filter 参数示例&lt;/p>
&lt;p>假设机器有 2 个网口:&lt;/p>
&lt;ul>
&lt;li>
&lt;p>eth0: 192.168.1.100&lt;/p>
&lt;/li>
&lt;li>
&lt;p>eth1：200.153.1.122&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>数据包源 IP：10.75.153.98，目的 IP：200.153.1.122&lt;/p>
&lt;p>系统路由表配置为：&lt;/p>
&lt;p>[root@localhost ~]# route -n&lt;/p>
&lt;p>Kernel IP routing table&lt;/p>
&lt;p>Destination Gateway Genmask Flags Metric Ref Use Iface&lt;/p>
&lt;p>default 192.168.1.234 0.0.0.0 　　 UG 0 0 0 eth0&lt;/p>
&lt;p>192.168.120.0 0.0.0.0 255.255.255.0 U 0 0 0 eth0&lt;/p>
&lt;p>10.75.153.98 0.0.0.0 255.255.255.0 U 0 0 0 eth0&lt;/p>
&lt;p>系统 rp_filter 参数的配置为：&lt;/p>
&lt;p>[root@localhost ~]# sysctl -a | grep rp_filter&lt;/p>
&lt;p>net.ipv4.conf.all.rp_filter=1&lt;/p>
&lt;p>net.ipv4.conf.default.rp_filter=1&lt;/p>
&lt;p>如上所示，数据包发到了 eth1 网卡，如果这时候开启了 rp_filter 参数，并配置为 1，则系统会严格校验数据包的反向路径。从路由表中可以看出，返回响应时数据包要从 eth0 网卡出，即请求数据包进的网卡和响应数据包出的网卡不是同一个网卡，这时候系统会判断该反向路径不是最佳路径，而直接丢弃该请求数据包。（业务进程也收不到该请求数据包）&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/zhv2lk/1616168317314-27937a08-a8c2-41a5-b15c-2cd36722d4ca.png" alt="">&lt;/p>
&lt;p>解决办法：&lt;/p>
&lt;p>1.修改路由表，使响应数据包从 eth1 出，即保证请求数据包进的网卡和响应数据包出的网卡为同一个网卡。&lt;/p>
&lt;p>2.关闭 rp_filter 参数。（注意 all 和 default 的参数都要改）&lt;/p>
&lt;p>1)修改/etc/sysctl.conf 文件，然后 sysctl -p 刷新到内存。&lt;/p>
&lt;p>2)使用 sysctl -w 直接写入内存：sysctl -w net.ipv4.conf.all.rp_filter=0&lt;/p>
&lt;p>3)修改/proc 文件系统： echo &amp;ldquo;0&amp;rdquo;&amp;gt;/proc/sys/net/ipv4/conf/all/rp_filter&lt;/p>
&lt;h2 id="开启-rp_filter-参数的作用">开启 rp_filter 参数的作用&lt;/h2>
&lt;ol>
&lt;li>减少 DDoS 攻击&lt;/li>
&lt;/ol>
&lt;p>校验数据包的反向路径，如果反向路径不合适，则直接丢弃数据包，避免过多的无效连接消耗系统资源。&lt;/p>
&lt;ol start="2">
&lt;li>防止 IP Spoofing&lt;/li>
&lt;/ol>
&lt;p>校验数据包的反向路径，如果客户端伪造的源 IP 地址对应的反向路径不在路由表中，或者反向路径不是最佳路径，则直接丢弃数据包，不会向伪造 IP 的客户端回复响应。&lt;/p>
&lt;h3 id="ps两种常见的非法攻击手段">Ps：两种常见的非法攻击手段：&lt;/h3>
&lt;ol>
&lt;li>DDos 攻击(Distribute Deny of Service)&lt;/li>
&lt;/ol>
&lt;p>分布式拒绝服务攻击。通过构造大量的无用数据包向目标服务发起请求，占用目标服务主机大量的资源，还可能造成网络拥塞，进而影响到正常用户的访问。&lt;/p>
&lt;ol start="2">
&lt;li>IP Spoofing（IP 欺骗）&lt;/li>
&lt;/ol>
&lt;p>IP Spoofing 指一个客户端通过伪造源 IP，冒充另外一个客户端与目标服务进行通信，从而达到某些不可告人的秘密。&lt;/p>
&lt;h2 id="另一种说法">另一种说法：&lt;/h2>
&lt;p>比如一台设备安装两&lt;del>个 &lt;del>haproxy，有多个网&lt;/del>卡&lt;/del>，多个 ip，不同 haproxy 代理不同网段，给不同后端。那么就需要关闭校验。&lt;/p>
&lt;h2 id="另一种说法-1">另一种说法：&lt;/h2>
&lt;p>在 Linux 中用于对 网卡的反向路由过滤策略进行配置的内核参数是 rp_filter，有关此参数的详细介绍以及配置方式请参见 Linux 内核参数 rp_filter。&lt;/p>
&lt;p>LVS 在 VS/TUN 模式下，需要对 tunl0 虚拟网卡的反向路由过滤策略进行配置。最直接的办法是把其值设置为 0。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>net.ipv4.conf.tunl0.rp_filter&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">0&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>net.ipv4.conf.all.rp_filter&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">0&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>因为 Linux 系统在对网卡应用反向路由过滤策略时，除了检查本网卡的 rp_filter 参数外，还会检查 all 配置项上的 rp_filter 参数，并使用这两个值中较大的值作为应用到当前网卡的反向路由过滤策略。所以需要同时把 &lt;code>net.ipv4.conf.all.rp_filter&lt;/code> 参数设置为 0。&lt;/p></description></item><item><title>Docs: vm(内存相关参数)</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2.kernel%E5%86%85%E6%A0%B8/1.linux-kernel/kernel-%E5%8F%82%E6%95%B0/vm%E5%86%85%E5%AD%98%E7%9B%B8%E5%85%B3%E5%8F%82%E6%95%B0/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2.kernel%E5%86%85%E6%A0%B8/1.linux-kernel/kernel-%E5%8F%82%E6%95%B0/vm%E5%86%85%E5%AD%98%E7%9B%B8%E5%85%B3%E5%8F%82%E6%95%B0/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://www.kernel.org/doc/html/latest/admin-guide/sysctl/vm.html">官方文档,Linux 内核用户和管理员指南-/proc/sys 文档-/proc/sys/vm 文档&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>/proc/sys/vm/ 目录下的文件可用于调整 Linux Kernel 中有关 Virtual Memory(虚拟内存) 子系统的操作。&lt;/p>
&lt;h3 id="vmdrop_caches--num">vm.drop_caches = NUM&lt;/h3>
&lt;p>写入该文件可以清理内存中的缓存。详见《[Memory 的缓存机制](Memory%20 的缓存机制.md 管理/Memory 的缓存机制.md)》章节中“缓存清理”部分&lt;/p>
&lt;h3 id="vmswappiness--10">vm.swappiness = 10&lt;/h3>
&lt;p>这个内核参数可以用来调整系统使用 swap 的时机。&lt;code>默认值：60&lt;/code>&lt;/p>
&lt;p>设为 60 即表示：当内存中空闲空间低于 60%的时候，就会开始使用 swap 空间(也就是说系统使用了 40%的内存之后，就开始使用 swap)&lt;/p>
&lt;h3 id="vmmax_map_count--262144">vm.max_map_count = 262144&lt;/h3>
&lt;p>一个进程可以拥有的 VMA(虚拟内存区域) 的数量。&lt;code>默认值：65530&lt;/code>&lt;/p>
&lt;p>常用于运行 Elasticsearch 服务的设备上。&lt;/p>
&lt;h3 id="vmovercommit_memory--1">vm.overcommit_memory = 1&lt;/h3>
&lt;p>配置是否允许[内存 overcommit](Memroy%20 的%20Over%20Commit%20 与%20OOM.md 管理/Memroy 的 Over Commit 与 OOM.md)，有 0、1、2 三种模式。&lt;code>默认值：0&lt;/code>&lt;/p>
&lt;ul>
&lt;li>&lt;strong>0&lt;/strong> # heuristic overcommit(试探式允许 overcommit)。
&lt;ul>
&lt;li>当应用进程尝试申请内存时，内核会做一个检测。内核将检查是否有足够的&lt;strong>可用内存&lt;/strong>可以分配。如果有足够的可用内存，内存申请允许；否则，内存申请失败。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>1&lt;/strong> # always overcommit,never check(总是允许 overcommit)
&lt;ul>
&lt;li>对于内存的申请请求，内核不会做任何检测，并直接分配内存。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>2&lt;/strong> # never overcommit,always check(永不允许 overcommit)
&lt;ul>
&lt;li>说是永不允许 overcommit，其实只是通过其他参数来控制 overcommit(过量使用) 的大小。可以分配的总内存将会受到 /proc/meminfo 中的 CommitLimit 这个参数限制。&lt;/li>
&lt;li>&lt;code>CommitLimit = (total_RAM - total_huge_TLB) * overcommit_ratio / 100 + total_swap&lt;/code>
&lt;ul>
&lt;li>totaol_RAM # 系统内存总量(就是物理内存)&lt;/li>
&lt;li>total_huge_TLB # 为 huge pages 保留的内存量，一般没有保留，都是 0&lt;/li>
&lt;li>overcommit_ratio # /proc/sys/vm/overcommit_ratio 内核参数的值。&lt;/li>
&lt;li>total_swap # swap 空间的总量&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>比如我现在有一个 16G 内存的服务器，swap 空间为 16，overcommit_ratio 参数设为 50，那么 CommitLimit 的计算结果为 24G。
&lt;ul>
&lt;li>此时，如果 /proc/meminfo 中的 Commited_AS 参数 值为 23G，当一个程序申请超过 1G 内存时，则会失败。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>所以从根本上讲，模式 2 下，可以分配的内存总量，受 overcommit_ration 这个内核参数控制。所谓的永远不会 overcommit，则是指 overcommit_ration 参数的值小于 100。&lt;/li>
&lt;li>注意：从 Linux 内核 3.14 开始，如果 /proc/sys/vm/overcommit_kbytes 参数的值不为 0，则&lt;code>CommitLimit = overcommit_kbytes + total_swap&lt;/code>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;blockquote>
&lt;p>所以所有模式都可能会触发 OOM 机制。只不过模式 0 和 1 在程序申请内存时，行为不同；而模式 2 则受 overcommit_ration 参数的限制。&lt;/p>
&lt;/blockquote>
&lt;h3 id="vmovercommit_ration--50">vm.overcommit_ration = 50&lt;/h3>
&lt;p>内存 overcommit(过量使用) 的百分比。&lt;code>默认值：50&lt;/code>。与 vm.overcommit_memory = 2 配合使用，其他情况该参数无效。&lt;/p>
&lt;p>如果该值小于 100 ，那么系统分配给程序的内存，则永远不会超过真实内存，所以也就不存在 overcommit。如果该值超过 100，那么 CommitLimit 的值则会超过真实内存，这时候就相当于 overcommit 了，并且在内存使用超过真实值时会触发 OOM。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># 在没有swap 和 大页预留的情况下&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># vm.overcommit_ration=100 时，CommitLimit 等于 Mem 总量&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">[&lt;/span>root@lichenhao ~&lt;span style="color:#f92672">]&lt;/span>&lt;span style="color:#75715e"># sysctl -w vm.overcommit_ratio=100&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>vm.overcommit_ratio &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">100&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">[&lt;/span>root@lichenhao ~&lt;span style="color:#f92672">]&lt;/span>&lt;span style="color:#75715e"># cat /proc/meminfo | grep Commit&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;amp;&amp;amp;&lt;/span> free -k
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>CommitLimit: &lt;span style="color:#ae81ff">3868968&lt;/span> kB
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Committed_AS: &lt;span style="color:#ae81ff">806056&lt;/span> kB
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> total used free shared buff/cache available
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Mem: &lt;span style="color:#ae81ff">3868968&lt;/span> &lt;span style="color:#ae81ff">282904&lt;/span> &lt;span style="color:#ae81ff">3195972&lt;/span> &lt;span style="color:#ae81ff">8748&lt;/span> &lt;span style="color:#ae81ff">390092&lt;/span> &lt;span style="color:#ae81ff">3368548&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Swap: &lt;span style="color:#ae81ff">0&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># vm.overcommit_ration=50 时，CommitLimit 等于 Mem 总量的一半&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">[&lt;/span>root@lichenhao ~&lt;span style="color:#f92672">]&lt;/span>&lt;span style="color:#75715e"># sysctl -w vm.overcommit_ratio=100&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>vm.overcommit_ratio &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">50&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">[&lt;/span>root@lichenhao ~&lt;span style="color:#f92672">]&lt;/span>&lt;span style="color:#75715e"># cat /proc/meminfo | grep Commit &amp;amp;&amp;amp; free -k&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>CommitLimit: &lt;span style="color:#ae81ff">1934484&lt;/span> kB
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Committed_AS: &lt;span style="color:#ae81ff">800516&lt;/span> kB
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> total used free shared buff/cache available
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Mem: &lt;span style="color:#ae81ff">3868968&lt;/span> &lt;span style="color:#ae81ff">282712&lt;/span> &lt;span style="color:#ae81ff">3196160&lt;/span> &lt;span style="color:#ae81ff">8748&lt;/span> &lt;span style="color:#ae81ff">390096&lt;/span> &lt;span style="color:#ae81ff">3368740&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Swap: &lt;span style="color:#ae81ff">0&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># vm.overcommit_ration=200 时，CommitLimit 等于 Mem 总量的一倍。此时内存可以 overcommit，有可能会触发 OOM&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">[&lt;/span>root@lichenhao ~&lt;span style="color:#f92672">]&lt;/span>&lt;span style="color:#75715e"># sysctl -w vm.overcommit_ratio=100&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>vm.overcommit_ratio &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">200&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">[&lt;/span>root@lichenhao ~&lt;span style="color:#f92672">]&lt;/span>&lt;span style="color:#75715e"># cat /proc/meminfo | grep Commit &amp;amp;&amp;amp; free -k&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>CommitLimit: &lt;span style="color:#ae81ff">7737936&lt;/span> kB
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Committed_AS: &lt;span style="color:#ae81ff">800516&lt;/span> kB
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> total used free shared buff/cache available
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Mem: &lt;span style="color:#ae81ff">3868968&lt;/span> &lt;span style="color:#ae81ff">282872&lt;/span> &lt;span style="color:#ae81ff">3196000&lt;/span> &lt;span style="color:#ae81ff">8748&lt;/span> &lt;span style="color:#ae81ff">390096&lt;/span> &lt;span style="color:#ae81ff">3368580&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Swap: &lt;span style="color:#ae81ff">0&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="vmpanic_on_oom--0">vm.panic_on_oom = 0&lt;/h3>
&lt;p>触发 oom 之后，内核 panic 机制。&lt;code>默认值：0&lt;/code>。&lt;/p>
&lt;ul>
&lt;li>0 # oom 触发后，内核不会 panic。&lt;/li>
&lt;li>1 # oom 触发后，内核会出现 panic 情况。但是，如果某个进程通过内存/ cpusets 限制使用节点，并且这些节点成为内存耗尽状态，则一个进程可能会被 oom-killer 杀死。在这种情况下不内核不会 panic。因为其他节点的内存可能是空闲的。这意味着系统总体状态可能还不是致命的。&lt;/li>
&lt;li>2 # oom 触发后，内核直接 panic。&lt;/li>
&lt;/ul>
&lt;h3 id="vmoom_kill_allocating_task--0">vm.oom_kill_allocating_task = 0&lt;/h3>
&lt;p>触发 oom 后，内核 kill 进程的行为。&lt;code>默认值：0&lt;/code>。&lt;/p>
&lt;ul>
&lt;li>0 # 内核将检查每个进程的分数，分数最高的进程将被 kill 掉&lt;/li>
&lt;li>1 # 那么内核将 kill 掉当前申请内存的进程&lt;/li>
&lt;/ul></description></item><item><title>Docs: 应用实例</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2.kernel%E5%86%85%E6%A0%B8/1.linux-kernel/kernel-%E5%8F%82%E6%95%B0/%E5%BA%94%E7%94%A8%E5%AE%9E%E4%BE%8B/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2.kernel%E5%86%85%E6%A0%B8/1.linux-kernel/kernel-%E5%8F%82%E6%95%B0/%E5%BA%94%E7%94%A8%E5%AE%9E%E4%BE%8B/</guid><description>
&lt;h1 id="tcp-相关参数">TCP 相关参数:&lt;/h1>
&lt;p>net.core.somaxconn = 65535
net.ipv4.tcp_fin_timeout = 5
net.ipv4.tcp_max_syn_backlog = 65536
net.ipv4.tcp_max_tw_buckets = 5000
net.ipv4.tcp_synack_retries = 2
net.ipv4.tcp_syncookies = 1
net.ipv4.tcp_tw_reuse = 1&lt;/p>
&lt;h2 id="tcp-keepalive-相关参数">TCP keepalive 相关参数&lt;/h2>
&lt;p>net.ipv4.tcp_keepalive_intvl = 30
net.ipv4.tcp_keepalive_probes = 10
net.ipv4.tcp_keepalive_time = 600&lt;/p>
&lt;h2 id="其他">其他&lt;/h2>
&lt;p>net.bridge.bridge-nf-call-iptables = 1
net.bridge.bridge-nf-call-ip6tables = 1
net.ipv6.conf.all.disable_ipv6 = 1
net.ipv6.conf.lo.disable_ipv6 = 1
net.ipv4.neigh.default.gc_stale_time = 120
net.ipv4.conf.all.rp_filter = 0&lt;/p>
&lt;h1 id="内存相关相关">内存相关相关&lt;/h1>
&lt;p>vm.drop_caches = NUM
vm.swappiness = 10
vm.max_map_count = 262144
vm.overcommit_memory = 1
vm.overcommit_ration = 50
vm.panic_on_oom = 0
vm.oom_kill_allocating_task = 0&lt;/p>
&lt;h1 id="文件系统相关参数">文件系统相关参数&lt;/h1>
&lt;p>fs.file-max = 52706963
fs.nr_open = 52706963
fs.may_detach_mounts = 1&lt;/p></description></item><item><title>Docs: 硬核致敬Linux ！30岁生日快乐！</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2.kernel%E5%86%85%E6%A0%B8/1.linux-kernel/%E7%A1%AC%E6%A0%B8%E8%87%B4%E6%95%AClinux-30%E5%B2%81%E7%94%9F%E6%97%A5%E5%BF%AB%E4%B9%90/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2.kernel%E5%86%85%E6%A0%B8/1.linux-kernel/%E7%A1%AC%E6%A0%B8%E8%87%B4%E6%95%AClinux-30%E5%B2%81%E7%94%9F%E6%97%A5%E5%BF%AB%E4%B9%90/</guid><description>
&lt;p>&lt;a href="https://mp.weixin.qq.com/s/cE4x63tYxoqrDinifeWqeg">硬核致敬 Linux ！30 岁生日快乐！&lt;/a>&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/1ef62d82-d29c-457a-b63f-3d4dfa09d652/640" alt="">&lt;/p>
&lt;p>1991 年 8 月 25 日，21 岁的 Linus Torvalds（以下简称 Linus）做了一个免费的操作系统 “Linux”，并在这一天向外界公布这个由“业余爱好” 主导的个人项目；如今，全球超级计算机 500 强和超过 70% 的智能手机都在运行 Linux，因此，8 月 25 日也被许多 Linux 的爱好者视为 Linux 真正的诞生日期。&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/1ef62d82-d29c-457a-b63f-3d4dfa09d652/640" alt="">&lt;/p>
&lt;p>30 年前，Linus Torvalds 首次发布 Linux 内核时还是赫尔辛基大学的一名 21 岁学生。他的声明是这样开始的，“我正在做一个（免费的）操作系统（只是一个爱好，不会很大和专业&amp;hellip;&amp;hellip;）”。三十年后，排名前 500 的超级计算机都在运行 Linux，所有智能手机的 70% 以上都是如此。Linux 显然既庞大又专业。&lt;/p>
&lt;p>三十年来，Linus Torvalds 领导了 Linux 内核开发，激励了无数其他开发人员和开源项目。2005 年，Linus 还创建了 Git 来帮助管理内核开发过程，此后它成为最受欢迎的版本控制系统，受到无数开源和专有项目的信赖。&lt;/p>
&lt;h3 id="linux-历史">Linux 历史&lt;/h3>
&lt;p>&lt;strong>OS 史前历史&lt;/strong>&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/1ef62d82-d29c-457a-b63f-3d4dfa09d652/640" alt="">&lt;/p>
&lt;p>&lt;strong>Linux 的历史&lt;/strong>&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/1ef62d82-d29c-457a-b63f-3d4dfa09d652/640" alt="">&lt;/p>
&lt;h3 id="linux-系统">Linux 系统&lt;/h3>
&lt;p>&lt;strong>Linux 系统软件架构&lt;/strong>&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/1ef62d82-d29c-457a-b63f-3d4dfa09d652/640" alt="">&lt;/p>
&lt;p>Linux 系统由硬件、kernel、系统调用、shell、c 库、应用程序组成，架构层次分明，Linux 内的各种层功能独立，程序在用户空间和内核空间之间的分离，能支持更多应用。&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>用户模态&lt;/th>
&lt;th>&lt;strong>用户应用&lt;/strong>&lt;/th>
&lt;th>例如：Bash，LibreOffice，GIMP，Blender，0 A.D.，Mozilla Firefox 等&lt;/th>
&lt;th>&lt;/th>
&lt;th>&lt;/th>
&lt;th>&lt;/th>
&lt;th>&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>&lt;/td>
&lt;td>低层系统构件&lt;/td>
&lt;td>&lt;strong>系统守护进程&lt;/strong>：&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>systemd，runit，logind，networkd，PulseAudio 等&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;strong>窗口系统&lt;/strong>：&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>X11，Wayland，SurfaceFlinger(Android)&lt;/td>
&lt;td>&lt;strong>其他库&lt;/strong>：&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>GTK+, Qt, EFL, SDL, SFML, FLTK, GNUstep 等&lt;/td>
&lt;td>&lt;strong>图形&lt;/strong>：&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Mesa，AMD Catalyst 等&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;/td>
&lt;td>&lt;strong>C 标准库&lt;/strong>&lt;/td>
&lt;td>open()，exec()，sbrk()，socket()，fopen()，calloc()，&amp;hellip; (直到 2000 个子例程)&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>glibc 目标为 POSIX/SUS 兼容，musl 和 uClibc 目标为嵌入式系统，bionic 为 Android 而写等&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>内核模态&lt;/td>
&lt;td>&lt;strong>Linux 内核&lt;/strong>&lt;/td>
&lt;td>stat, splice, dup, read, open, ioctl, write, mmap, close, exit 等（大约 380 个系统调用）&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Linux 内核系统调用接口（SCI，目标为 POSIX/SUS 兼容）&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;td>进程调度子系统&lt;/td>
&lt;td>IPC 子系统&lt;/td>
&lt;td>内存管理子系统&lt;/td>
&lt;td>虚拟文件子系统&lt;/td>
&lt;td>网络子系统&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;td>其他构件：ALSA，DRI，evdev，LVM，device mapper，Linux Network Scheduler，Netfilter&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Linux 安全模块：SELinux，TOMOYO，AppArmor, Smack&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>硬件（CPU，内存，数据存储设备等。）&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>&lt;strong>Linux 内核代码架构&lt;/strong>&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/1ef62d82-d29c-457a-b63f-3d4dfa09d652/640" alt="">&lt;/p>
&lt;p>Linux 代码包含核心几个子系统，比如&lt;strong>内存子系统&lt;/strong>，&lt;strong>I/O 子系统&lt;/strong>，&lt;strong>CPU(调度）子系统&lt;/strong>，&lt;strong>设备驱动子系统&lt;/strong>，&lt;strong>网络子系统&lt;/strong>，&lt;strong>虚拟文件子系统&lt;/strong>等。这里简单介绍一些比较重要的子系统。&lt;/p>
&lt;h3 id="调度子系统">调度子系统&lt;/h3>
&lt;p>&lt;strong>进程调度&lt;/strong>是 Linux 内核中最重要的子系统，它主要提供对 CPU 的访问控制。因为在计算机中，CPU 资源是有限的，而众多的应用程序都要使用 CPU 资源，所以需要 “进程调度子系统” 对 CPU 进行调度管理。&lt;/p>
&lt;p>&lt;strong>进程调度子系统&lt;/strong>包括 4 个子模块（见下图），它们的功能如下：&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/1ef62d82-d29c-457a-b63f-3d4dfa09d652/640" alt="">&lt;/p>
&lt;ol>
&lt;li>Scheduling Policy，实现进程调度的策略，它决定哪个（或哪几个）进程将拥有 CPU。&lt;/li>
&lt;li>Architecture-specific Schedulers，体系结构相关的部分，用于将对不同 CPU 的控制，抽象为统一的接口。这些控制主要在 suspend 和 resume 进程时使用，牵涉到 CPU 的寄存器访问、汇编指令操作等。&lt;/li>
&lt;li>Architecture-independent Scheduler，体系结构无关的部分。它会和 “Scheduling Policy 模块” 沟通，决定接下来要执行哪个进程，然后通过“Architecture-specific Schedulers 模块”resume 指定的进程。&lt;/li>
&lt;li>System Call Interface，系统调用接口。进程调度子系统通过系统调用接口，将需要提供给用户空间的接口开放出去，同时屏蔽掉不需要用户空间程序关心的细节。&lt;/li>
&lt;/ol>
&lt;h3 id="内存子系统">内存子系统&lt;/h3>
&lt;p>&lt;strong>内存管理&lt;/strong>同样是 Linux 内核中最重要的子系统，它主要提供对内存资源的访问控制。Linux 系统会在硬件物理内存和进程所使用的内存（称作虚拟内存）之间建立一种映射关系，这种映射是以进程为单位，因而不同的进程可以使用相同的虚拟内存，而这些相同的虚拟内存，可以映射到不同的物理内存上。&lt;/p>
&lt;p>&lt;strong>内存管理子系统&lt;/strong>包括 3 个子模块（见下图），它们的功能如下：&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/1ef62d82-d29c-457a-b63f-3d4dfa09d652/640" alt="">&lt;/p>
&lt;ol>
&lt;li>Architecture Specific Managers，体系结构相关部分。提供用于访问硬件 Memory 的虚拟接口。&lt;/li>
&lt;li>Architecture Independent Manager，体系结构无关部分。提供所有的内存管理机制，包括：以进程为单位的 memory mapping；虚拟内存的 Swapping。&lt;/li>
&lt;li>System Call Interface，系统调用接口。通过该接口，向用户空间程序应用程序提供内存的分配、释放，文件的 map 等功能。&lt;/li>
&lt;/ol>
&lt;h3 id="虚拟文件子系统virtual-filesystem-vfs">虚拟文件子系统（Virtual Filesystem, VFS）&lt;/h3>
&lt;p>传统意义上的文件系统，是一种存储和组织计算机数据的方法。它用易懂、人性化的方法（文件和目录结构），抽象计算机磁盘、硬盘等设备上冰冷的数据块，从而使对它们的查找和访问变得容易。因而文件系统的实质，就是 “存储和组织数据的方法”，文件系统的表现形式，就是 “从某个设备中读取数据和向某个设备写入数据”。&lt;/p>
&lt;p>随着计算机技术的进步，存储和组织数据的方法也是在不断进步的，从而导致有多种类型的文件系统，例如 FAT、FAT32、NTFS、EXT2、EXT3 等等。而为了兼容，操作系统或者内核，要以相同的表现形式，同时支持多种类型的文件系统，这就延伸出了**虚拟文件系统（VFS）**的概念。VFS 的功能就是管理各种各样的文件系统，屏蔽它们的差异，以统一的方式，为用户程序提供访问文件的接口。&lt;/p>
&lt;p>我们可以从磁盘、硬盘、NAND Flash 等设备中读取或写入数据，因而最初的文件系统都是构建在这些设备之上的。这个概念也可以推广到其它的硬件设备，例如内存、显示器（LCD）、键盘、串口等等。我们对硬件设备的访问控制，也可以归纳为读取或者写入数据，因而可以用统一的文件操作接口访问。Linux 内核就是这样做的，除了传统的磁盘文件系统之外，它还抽象出了设备文件系统、内存文件系统等等。这些逻辑，都是由 VFS 子系统实现。&lt;/p>
&lt;p>&lt;strong>VFS 子系统&lt;/strong>包括 6 个子模块（见下图），它们的功能如下：&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/1ef62d82-d29c-457a-b63f-3d4dfa09d652/640" alt="">&lt;/p>
&lt;ol>
&lt;li>Device Drivers，设备驱动，用于控制所有的外部设备及控制器。由于存在大量不能相互兼容的硬件设备（特别是嵌入式产品），所以也有非常多的设备驱动。因此，Linux 内核中将近一半的 Source Code 都是设备驱动，大多数的 Linux 底层工程师（特别是国内的企业）都是在编写或者维护设备驱动，而无暇估计其它内容（它们恰恰是 Linux 内核的精髓所在）。&lt;/li>
&lt;li>Device Independent Interface， 该模块定义了描述硬件设备的统一方式（统一设备模型），所有的设备驱动都遵守这个定义，可以降低开发的难度。同时可以用一致的形势向上提供接口。&lt;/li>
&lt;li>Logical Systems，每一种文件系统，都会对应一个 Logical System（逻辑文件系统），它会实现具体的文件系统逻辑。&lt;/li>
&lt;li>System Independent Interface，该模块负责以统一的接口（快设备和字符设备）表示硬件设备和逻辑文件系统，这样上层软件就不再关心具体的硬件形态了。&lt;/li>
&lt;li>System Call Interface，系统调用接口，向用户空间提供访问文件系统和硬件设备的统一的接口。&lt;/li>
&lt;/ol>
&lt;h3 id="网络子系统net">网络子系统（Net）&lt;/h3>
&lt;p>&lt;strong>网络子系统&lt;/strong>在 Linux 内核中主要负责管理各种网络设备，并实现各种网络协议栈，最终实现通过网络连接其它系统的功能。在 Linux 内核中，网络子系统几乎是自成体系，它包括 5 个子模块（见下图），它们的功能如下：&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/1ef62d82-d29c-457a-b63f-3d4dfa09d652/640" alt="">&lt;/p>
&lt;ol>
&lt;li>Network Device Drivers，网络设备的驱动，和 VFS 子系统中的设备驱动是一样的。&lt;/li>
&lt;li>Device Independent Interface，和 VFS 子系统中的是一样的。&lt;/li>
&lt;li>Network Protocols，实现各种网络传输协议，例如 IP, TCP, UDP 等等。&lt;/li>
&lt;li>Protocol Independent Interface，屏蔽不同的硬件设备和网络协议，以相同的格式提供接口（socket)。&lt;/li>
&lt;li>System Call interface，系统调用接口，向用户空间提供访问网络设备的统一的接口。&lt;/li>
&lt;/ol>
&lt;p>Linux 内核版本时间线：&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/1ef62d82-d29c-457a-b63f-3d4dfa09d652/640" alt="">&lt;/p>
&lt;p>&lt;strong>Linux 内核支持各种硬件架构&lt;/strong>&lt;/p>
&lt;p>&lt;strong>Linux 内核&lt;/strong>最成功的地方之一就是支持各种硬件架构，为软件提供了公共的平台：&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/1ef62d82-d29c-457a-b63f-3d4dfa09d652/640" alt="">&lt;/p>
&lt;p>基于 Linux 的系统是一个模块化的类 Unix 操作系统。&lt;strong>Linux 操作系统&lt;/strong>的大部分设计思想来源于 20 世纪 70 年代到 80 年代的 Unix 操作系统所建立的基本设计思想。Linux 系统使用宏内核，由 Linux 内核负责处理进程控制、网络，以及外围设备和文件系统的访问。在系统运行的时候，设备驱动程序要么与内核直接整合，要么以加载模块形式添加。&lt;/p>
&lt;p>&lt;strong>Linux 具有设备独立性&lt;/strong>，它内核具有高度适应能力，从而给系统提供了更高级的功能。GNU 用户界面组件是大多数 Linux 操作系统的重要组成部分，提供常用的 C 函数库，Shell，还有许多常见的 Unix 实用工具，可以完成许多基本的操作系统任务。大多数 Linux 系统使用的图形用户界面建立在 X 窗口系统之上，由 X 窗口 (XWindow) 系统通过软件工具及架构协议来建立操作系统所用的图形用户界面.&lt;/p>
&lt;p>&lt;strong>基于 Linux 内核各种衍生 OS 系统&lt;/strong>&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/1ef62d82-d29c-457a-b63f-3d4dfa09d652/640" alt="">&lt;/p>
&lt;p>各种发行版本&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/1ef62d82-d29c-457a-b63f-3d4dfa09d652/640" alt="">&lt;/p>
&lt;p>当前比较流行发行版是：&lt;strong>Debian&lt;/strong>、&lt;strong>Ubuntu&lt;/strong>、&lt;strong>Fedora&lt;/strong>、&lt;strong>CentOS&lt;/strong>、&lt;strong>Arch Linux&lt;/strong>和&lt;strong>openSUSE&lt;/strong>等，每个发行版都有自己优势地方，都有一批忠实用户。&lt;/p>
&lt;p>&lt;strong>基于 Linux 内核著名 OS&lt;/strong>&lt;/p>
&lt;p>&lt;strong>Android&lt;/strong>&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/1ef62d82-d29c-457a-b63f-3d4dfa09d652/640" alt="">&lt;/p>
&lt;p>&lt;strong>Android&lt;/strong>（读音：英：[&amp;lsquo;ændrɔɪd]，美：[ˈænˌdrɔɪd]），中文用户多以非官方名称 “安卓” 称之，是一个基于 Linux 内核与其他开源软件的开放源代码的移动操作系统，Android 的内核是根据 Linux 内核的长期支持的分支，具有典型的 Linux 调度和功能。截至 2018 年，Android 的目标是 Linux 内核的 4.4、4.9 或是 4.14 版本。&lt;/p>
&lt;p>&lt;strong>ChromeOS&lt;/strong>&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/1ef62d82-d29c-457a-b63f-3d4dfa09d652/640" alt="">&lt;/p>
&lt;p>&lt;strong>Chrome OS&lt;/strong>  是由 Google 设计基于 Linux 内核的操作系统，并使用 Google Chrome 浏览器作为其主要用户界面。因此，Chrome OS 主要支持 Web 应用程序[6]，2016 年起开始陆续兼容 Android 应用程序（可通过 Google Play 商店下载）和 Linux 应用程序。&lt;/p>
&lt;p>&lt;strong>鸿蒙 OS&lt;/strong>&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/1ef62d82-d29c-457a-b63f-3d4dfa09d652/640" alt="">&lt;/p>
&lt;p>&lt;strong>鸿蒙&lt;/strong>（&lt;strong>HarmonyOS&lt;/strong>，开发代号 Ark[1]）是华为自 2012 年开发的一款可兼容 Android 应用程序的跨平台分布式操作系统[2]。系统性能包括利用 “分布式” 技术将各款设备融合成一个“超级终端”，便于操作和共享各设备资源。[3][4][5]系统架构支持多内核，包括 Linux 内核、LiteOS 和鸿蒙微内核，可按各种智能设备选择所需内核，例如在低功耗设备上使用 LiteOS 内核。[6][7]2019 年 8 月华为发布首款搭载鸿蒙操作系统的产品 “荣耀智能屏”，之后于 2021 年 6 月发布搭载鸿蒙操作系统的智能手机、平板电脑和智能手表。&lt;/p>
&lt;p>Linux 内核是最大且变动最快的开源项目之一，它由大约 53,600 个文件和近 2,000 万行代码组成。在全世界范围内超过 15,600 位程序员为它贡献代码，Linux 内核项目的维护者使用了如下的协作模型。&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/1ef62d82-d29c-457a-b63f-3d4dfa09d652/640" alt="">&lt;/p>
&lt;p>如果你有&lt;strong>深入 linux 内核的激情&lt;/strong>和&lt;strong>极客精神&lt;/strong>，可以为 Linux 项目贡献源码，具体如何提交第一个补丁，可以详细阅读下面文章，这里篇幅有限不展开：&lt;/p>
&lt;p>&lt;a href="https://opensource.com/article/18/8/first-linux-kernel-patch">https://opensource.com/article/18/8/first-linux-kernel-patch&lt;/a>&lt;/p>
&lt;p>Linux 开源代码仓库：&lt;/p>
&lt;p>&lt;a href="https://github.com/torvalds/linux">https://github.com/torvalds/linux&lt;/a>&lt;/p>
&lt;p>提交给 kernel 的补丁，刚开始可能不需要高深的技术，比如这个补丁，可以   是简单的对于已有内容的格式或拼写错误的修正，比如这个来自 4 岁小朋友的补丁：&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/1ef62d82-d29c-457a-b63f-3d4dfa09d652/640" alt="">&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/1ef62d82-d29c-457a-b63f-3d4dfa09d652/640" alt="">&lt;/p>
&lt;p>&lt;strong>Linux 内核学习资源&lt;/strong>&lt;/p>
&lt;p>&lt;strong>源码：&lt;/strong>&lt;/p>
&lt;p>&lt;a href="https://elixir.bootlin.com/linux/latest/source">https://elixir.bootlin.com/linux/latest/source&lt;/a>&lt;/p>
&lt;p>在线交叉索引看源码，包括 Linux 几乎所有版本；&lt;/p>
&lt;p>&lt;a href="https://github.com/torvalds/linux">https://github.com/torvalds/linux&lt;/a>&lt;/p>
&lt;p>内核 github 仓库，可以下载本地，编译，修改和开发。&lt;/p>
&lt;p>&lt;strong>网站&lt;/strong>&lt;/p>
&lt;p>&lt;a href="http://www.kernel.org">&lt;strong>http://www.kernel.org&lt;/strong>&lt;/a>&lt;/p>
&lt;p>可以通过这个网站上下载内核的源代码和补丁、跟踪内核 bug 等&lt;/p>
&lt;p>&lt;a href="http://lwn.net">&lt;strong>http://lwn.net&lt;/strong>&lt;/a>&lt;/p>
&lt;p>Linux 内核最新消息，提供给了定期的与内核开发相关的报道&lt;/p>
&lt;p>&lt;a href="https://www.wiki.kernel.org/">&lt;strong>https://www.wiki.kernel.org/&lt;/strong>&lt;/a>&lt;/p>
&lt;p>各种子模块 wiki 列表&lt;/p>
&lt;p>&lt;a href="http://www.linuxdoc.org">&lt;strong>http://www.linuxdoc.org&lt;/strong>&lt;/a>&lt;/p>
&lt;p>Linux Documentation Project(Linux 文档项目)，拥有大量称为 “HowTo”
的文档，其中一些是技术性的，并涉及到一些内核相关的主题。&lt;/p>
&lt;p>&lt;a href="http://www.kerneltravel.net/">&lt;strong>http://www.kerneltravel.net/&lt;/strong>&lt;/a>&lt;/p>
&lt;p>国内 Linux 内核之旅开源社区&lt;/p>
&lt;p>&lt;a href="http://www.linux-mm.org">&lt;strong>http://www.linux-mm.org&lt;/strong>&lt;/a>
该页面面向 Linux 内存管理开发，其中包含大量有用的信息，并且还包含大量与内核相关的 Web 站点链接。&lt;/p>
&lt;p>&lt;a href="http://www.wowotech.net">&lt;strong>http://www.wowotech.net&lt;/strong>&lt;/a>&lt;/p>
&lt;p>博客专注分享 linux 内核知识（偏嵌入式方向）, 很多文章都非常精华和透彻，值得内核学习者学习；&lt;/p>
&lt;p>&lt;a href="https://blog.csdn.net/gatieme">&lt;strong>https://blog.csdn.net/gatieme&lt;/strong>&lt;/a>&lt;/p>
&lt;p>操作系统优质博客，可以学习 linux 调度相关内核知识；&lt;/p>
&lt;p>&lt;a href="https://blog.csdn.net/dog250">&lt;strong>https://blog.csdn.net/dog250&lt;/strong>&lt;/a>&lt;/p>
&lt;p>dog250 的文章都比较深刻，属于 Linux 内核进阶，可能不太适合入门，建议入门后，再看这里文章，会让你醍醐灌顶。&lt;/p>
&lt;p>&lt;a href="https://www.kernel.org/doc">&lt;strong>https://www.kernel.org/doc&lt;/strong>&lt;/a>&lt;/p>
&lt;p>内核文档&lt;/p>
&lt;p>&lt;strong>书籍&lt;/strong>&lt;/p>
&lt;p>《深入理解 Linux 内核》&lt;/p>
&lt;p>《深入 Linux 内核架构》&lt;/p>
&lt;p>《Linux 内核设计与实现》&lt;/p>
&lt;p>《Linux 内核源代码情景分析》&lt;/p>
&lt;p>《深入理解 LINUX 网络内幕》&lt;/p>
&lt;p>《深入理解 Linux 虚拟内存管理》&lt;/p>
&lt;p>《Linux 设备驱动程序》&lt;/p>
&lt;h3 id="git-分布式版本控制系统">Git 分布式版本控制系统&lt;/h3>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/1ef62d82-d29c-457a-b63f-3d4dfa09d652/640" alt="">&lt;/p>
&lt;p>2005 年，Linus 还创建了 &lt;strong>Git&lt;/strong>，这是非常流行的分布式源代码控制系统。迅速将 Linux 内核源代码树从专有 Bitkeeper 迁移到新创建的开源 Git。&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/1ef62d82-d29c-457a-b63f-3d4dfa09d652/640" alt="">&lt;/p>
&lt;p>&lt;strong>git 架构&lt;/strong>&lt;/p>
&lt;p>&lt;strong>Git&lt;/strong> 是出于需要而创建的，不是因为发现源代码控制很有趣，而是因为其他多数源代码控制系统不好用，不能满足当时开发需求，并且 git 在 Linux 开发模型中确实运行得相当好，BitKeeper 变得站不住脚。&lt;/p>
&lt;p>完美适应现代开源软件的开发模式，分布式版本管理：&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/1ef62d82-d29c-457a-b63f-3d4dfa09d652/640" alt="">&lt;/p>
&lt;h3 id="linux-内核名人堂">Linux 内核名人堂&lt;/h3>
&lt;p>让我们膜拜一下对 Linux 内核做出核心贡献的大神们：&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/1ef62d82-d29c-457a-b63f-3d4dfa09d652/640" alt="">&lt;/p>
&lt;p>&lt;strong>林纳斯 · 班奈狄克 · 托瓦兹&lt;/strong>（1969 年 12 月 28 日－），生于芬兰赫尔辛基市，拥有美国国籍，Linux 内核的最早作者，随后发起了这个开源项目，担任 Linux 内核的首要架构师与项目协调者，是当今世界最著名的电脑程序员、黑客之一。他还发起了开源项目 Git，并为主要的开发者。&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/1ef62d82-d29c-457a-b63f-3d4dfa09d652/640" alt="">&lt;/p>
&lt;p>&lt;strong>大卫 · 史提芬 · 米勒&lt;/strong>（英语：David Stephen Miller，1974 年 11 月 26 日－），网络昵称为 DaveM，生于美国新泽西州新布朗斯维克，著名程式员与骇客，负责 Linux 核心网络功能以及 SPARC 平台的实作。他也参与其他开源软件的开发，是 GCC 督导委员会的成员之一。根据 2013 年 8 月的统计，米勒是 Linux 核心源代码第二大的贡献者，自 2005 年开始，已经提交过 4989 个 patch。&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/1ef62d82-d29c-457a-b63f-3d4dfa09d652/640" alt="">&lt;/p>
&lt;p>&lt;strong>葛雷格 · 克罗 - 哈曼&lt;/strong>（英语：Greg Kroah-Hartman，姓名缩写为 GKH）， Linux 核心开发者，目前为 Linux 核心中稳定分支（&lt;code>-stable&lt;/code>）的维护者[2]，他也是 staging 子系统[2]、USB[2]driver core、debugfs、kref、kobject、sysfs kernel 子系统[2]、 TTY layer [2]、linux-hotplug、Userspace I/O（与 Hans J. Koch 共同维护）等专案的维护者[2]，也创立了 udev 专案。除此之外，他亦协助维护 Gentoo Linux 中上述程式及 kernel 的套件。&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/1ef62d82-d29c-457a-b63f-3d4dfa09d652/640" alt="">&lt;/p>
&lt;p>&lt;strong>艾伦 · 考克斯&lt;/strong>（英语：Alan Cox，1968 年 7 月 22 日－）是一名英国程序员，生于英格兰索利赫尔。他自 1991 年开始投入 Linux 内核的开发工作，在开发者社群中有很高的地位，是 Linux 开发工作中的关键人物之一。他负责维护 Linux 内核 2.2 版这个分支，在 2.4 版中也提供许多程式码，拥有自己的分支版本。他住在威尔斯斯旺西，他的妻子于 2015 年逝世[1][2][3]。2020 年他再婚[4][5]。他于 1991 年在斯旺西大学获得计算机科学理学学士学位，2005 年在那里获得工商管理硕士学位[6]。&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/1ef62d82-d29c-457a-b63f-3d4dfa09d652/640" alt="">&lt;/p>
&lt;p>&lt;strong>英格 · 蒙内&lt;/strong>（匈牙利语：Ingo Molnár），匈牙利软件程序员与骇客，在 linux 内核上有许多贡献，也拥有自己的 linux 分支版本。对于操作系统的安全性与效能提升方面，他的声名卓著，在 linux 内核中，他于 Linux-2.6.0 版加入 O(1) 排程器，在 Linux-2.6.23 版中加入&lt;strong>完全公平调度器 CFS&lt;/strong>（Completely Fair Scheduler）。&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/1ef62d82-d29c-457a-b63f-3d4dfa09d652/640" alt="">&lt;/p>
&lt;p>&lt;strong>米格尔 · 德伊卡萨&lt;/strong>（西班牙语：Miguel de Icaza ，1972 年 11 月 23 日－），生于墨西哥市，著名墨西哥籍自由软件开发者，为 GNOME 项目与 Mono 项目的发起人。但后来[何时？]退出了 GNOME 项目。&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/1ef62d82-d29c-457a-b63f-3d4dfa09d652/640" alt="">&lt;/p>
&lt;p>&lt;strong>罗伯特 · 马修 · 拉姆&lt;/strong>（英语：Robert Matthew Love，1981 年 9 月 25 日－），生于美国佛罗里达州，为著名自由软件程式开发者、作家，现职为 google 软件工程师。现居于波士顿。他是 linux 核心的主要开发者之一，主要负责程式排程、先占式核心、虚拟内存子系统、核心事件层。他也加入了 GNOME 计划。目前他在 google，主要负责 Android 系统的开发。&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/1ef62d82-d29c-457a-b63f-3d4dfa09d652/640" alt="">&lt;/p>
&lt;p>&lt;strong>安德鲁 · 基斯 · 保罗 · 莫顿&lt;/strong>（英语：Andrew Keith Paul Morton，1959 年－），生于英国英格兰，澳洲软件工程师与著名骇客。他是 Linux 核心开发社群的领导者之一，现为 ext3 的共同维护者，负责区块装置的日志层（Journaling layer for block devices，JBD）。他也是 mm tree 的负责人。&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/1ef62d82-d29c-457a-b63f-3d4dfa09d652/640" alt="">&lt;/p>
&lt;p>&lt;strong>埃里克 · 斯蒂芬 · 雷蒙&lt;/strong>（英语：Eric Steven Raymond，1957 年 12 月 4 日－），是一名程序员，《大教堂与市集》的作者、《新黑客词典》（&amp;ldquo;Jargon File&amp;rdquo;）的维护人、著名黑客。作为《新黑客词典》的主要编撰人以及维护者，雷蒙很早就被认为是黑客文化的历史学家以及人类学家。但是在 1997 年以后，雷蒙被广泛公认为是开放源代码运动的主要领导者之一，并且是最为大众所知道（并最具争议性）的黑客。&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/1ef62d82-d29c-457a-b63f-3d4dfa09d652/640" alt="">&lt;/p>
&lt;p>&lt;strong>西奥多 · 曹&lt;/strong>（英语：Theodore Y. Ts&amp;rsquo;o，1968 年 1 月 23 日－），小名&lt;strong>泰德 · 曹&lt;/strong>（Ted Tso），汉名&lt;strong>曹子德&lt;/strong>[1]，生于美国加利福尼亚州帕罗奥图，著名的自由软件工程师，专长于文件系统设计。他是 Linux 内核在北美最早的开发者，负责 ext2、ext3 与 ext4 文件系统的开发与维护工作。他也是 e2fsprogs 的开发者。为自由标准组织的创始者之一，也曾担任 Linux 基金会首席技术官。&lt;/p>
&lt;p>由于互联网发达，当前不管是从个人爱好，还是工作原因，对内核贡献的国人越来越多：&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/1ef62d82-d29c-457a-b63f-3d4dfa09d652/640" alt="">&lt;/p>
&lt;p>&lt;a href="http://www.remword.com/kps_result/all_whole_line_country.html">http://www.remword.com/kps_result/all_whole_line_country.html&lt;/a>&lt;/p>
&lt;h3 id="最后">最后&lt;/h3>
&lt;p>30 年的时间，Linux 从一个个人玩具变成现在庞然大物，估值超过 100 亿美元，Linux 还带来一股开源潮流，让开源软件百花齐放，对计算机发展和开源文化起到极大促进作用。&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/1ef62d82-d29c-457a-b63f-3d4dfa09d652/640" alt="">&lt;/p>
&lt;p>Linux 庞大的生态与发展过程，Linus 伟大而富有创造力并不足以在一篇文章中尽述。&lt;/p>
&lt;p>匆匆 30 年，Linux 已经不仅仅是改变了世界，而且已经成为了这个世界不可或缺的一部分感谢 Linus Torvalds，感谢为之致力的一切贡献者！&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/1ef62d82-d29c-457a-b63f-3d4dfa09d652/640" alt="">&lt;/p>
&lt;p>最后，为了致敬 Linux，希望大家三连支持，让更多人可以看到！&lt;/p>
&lt;h3 id="参考和扩展">参考和扩展&lt;/h3>
&lt;p>&lt;a href="http://www.atguigu.com/jsfx/5694.html">http://www.atguigu.com/jsfx/5694.html&lt;/a>&lt;/p>
&lt;p>&lt;a href="https://opensource.com/article/16/12/yearbook-9-lessons-25-years-linux-kernel-development">https://opensource.com/article/16/12/yearbook-9-lessons-25-years-linux-kernel-development&lt;/a>&lt;/p>
&lt;p>&lt;a href="https://www.reddit.com/r/linux/comments/2pqqla/kernel_commit_4_year_old_girl_fixes_formatting_to/utm_source=amp&amp;amp;utm_medium=&amp;amp;utm_content=post_title">https://www.reddit.com/r/linux/comments/2pqqla/kernel_commit_4_year_old_girl_fixes_formatting_to/utm_source=amp&amp;amp;utm_medium=&amp;amp;utm_content=post_title&lt;/a>&lt;/p>
&lt;p>&lt;a href="http://oss.org.cn/ossdocs/linux/kernel/a1/index.html">http://oss.org.cn/ossdocs/linux/kernel/a1/index.html&lt;/a>&lt;/p>
&lt;p>&lt;a href="http://www.wowotech.net/linux_kenrel/11.html">http://www.wowotech.net/linux_kenrel/11.html&lt;/a>&lt;/p>
&lt;p>&lt;a href="https://www.wikiwand.com/zh/Linux">https://www.wikiwand.com/zh/Linux&lt;/a>&lt;/p>
&lt;p>&lt;a href="https://zh.wikipedia.org/wiki/Category:Linux%E6%A0%B8%E5%BF%83%E9%A7%AD%E5%AE%A2">https://zh.wikipedia.org/wiki/Category:Linux%E6%A0%B8%E5%BF%83%E9%A7%AD%E5%AE%A2&lt;/a>&lt;/p>
&lt;p>&lt;a href="http://www.chromium.org/chromium-os/chromiumos-design-docs/software-architecture">http://www.chromium.org/chromium-os/chromiumos-design-docs/software-architecture&lt;/a>&lt;/p>
&lt;ul>
&lt;li>END -&lt;/li>
&lt;/ul>
&lt;hr>
&lt;p>&lt;strong>看完一键三连 **&lt;strong>在看 *&lt;/strong>*，&lt;strong>转发 *&lt;/strong>*，点赞 **&lt;/strong>&lt;/p>
&lt;p>&lt;strong>是对文章最大的赞赏，极客重生感谢你&lt;/strong>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/1ef62d82-d29c-457a-b63f-3d4dfa09d652/640" alt="">&lt;/p>
&lt;p>推荐阅读&lt;/p>
&lt;p>&lt;a href="http://mp.weixin.qq.com/s?__biz=MzkyMTIzMTkzNA==&amp;amp;mid=2247510568&amp;amp;idx=1&amp;amp;sn=79f335aaab5c0a36c0a66c5bfb1619ae&amp;amp;chksm=c1845d79f6f3d46f81b6fd24335eb8994c9daf21b6846d80af2cad73d9f638c5dda48b02892c&amp;amp;scene=21#wechat_redirect">图解 Linux 内核 TCP/IP 协议栈实现 | Linux 网络硬核系列&lt;/a>&lt;/p>
&lt;p>&lt;a href="http://mp.weixin.qq.com/s?__biz=MzkyMTIzMTkzNA==&amp;amp;mid=2247532046&amp;amp;idx=2&amp;amp;sn=04ffe282ce1278297d124f0c382ba665&amp;amp;chksm=c184895ff6f300497eb2bcc63d352b6d6b374606399cb7dd5b5bb59a773e674a368f9f4c9169&amp;amp;scene=21#wechat_redirect">Linux 网络子系统&lt;/a>&lt;/p>
&lt;p>&lt;a href="http://mp.weixin.qq.com/s?__biz=MzkyMTIzMTkzNA==&amp;amp;mid=2247530537&amp;amp;idx=1&amp;amp;sn=11ed00203af160568e114e093dc706b4&amp;amp;chksm=c1848f78f6f3066ee21c11b603a683d28cee63924ab8397b5702d10227cdb69a9aab66e1bb0f&amp;amp;scene=21#wechat_redirect">开源, yyds!&lt;/a>&lt;/p>
&lt;p>&lt;a href="http://mp.weixin.qq.com/s?__biz=MzkyMTIzMTkzNA==&amp;amp;mid=2247508731&amp;amp;idx=1&amp;amp;sn=b562efbcdf5183ea4db6c9bced62894c&amp;amp;chksm=c18455aaf6f3dcbcbd225fcc4a8176ffa4401db3d7c9a0da80f0d4a302ce7bee4307ee4e38ee&amp;amp;scene=21#wechat_redirect">操作系统的起源 | 开源运动的兴起&lt;/a>&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/1ef62d82-d29c-457a-b63f-3d4dfa09d652/640" alt="">&lt;/p></description></item></channel></rss>