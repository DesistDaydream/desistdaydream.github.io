<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>断念梦 – Netfilter 流量控制系统</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2.kernel%E5%86%85%E6%A0%B8/8.network-%E7%AE%A1%E7%90%86/linux-%E7%BD%91%E7%BB%9C%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6/netfilter-%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6%E7%B3%BB%E7%BB%9F/</link><description>Recent content in Netfilter 流量控制系统 on 断念梦</description><generator>Hugo -- gohugo.io</generator><atom:link href="https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2.kernel%E5%86%85%E6%A0%B8/8.network-%E7%AE%A1%E7%90%86/linux-%E7%BD%91%E7%BB%9C%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6/netfilter-%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6%E7%B3%BB%E7%BB%9F/index.xml" rel="self" type="application/rss+xml"/><item><title>Docs: Netfilter 流量控制系统</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2.kernel%E5%86%85%E6%A0%B8/8.network-%E7%AE%A1%E7%90%86/linux-%E7%BD%91%E7%BB%9C%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6/netfilter-%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6%E7%B3%BB%E7%BB%9F/netfilter-%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6%E7%B3%BB%E7%BB%9F/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2.kernel%E5%86%85%E6%A0%B8/8.network-%E7%AE%A1%E7%90%86/linux-%E7%BD%91%E7%BB%9C%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6/netfilter-%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6%E7%B3%BB%E7%BB%9F/netfilter-%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6%E7%B3%BB%E7%BB%9F/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://www.netfilter.org/index.html">Netfilter 官网&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.netfilter.org/documentation/index.html">Netfilter 官方文档&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Netfilter">Wiki-Netfilter&lt;/a>&lt;/li>
&lt;li>&lt;a href="http://arthurchiao.art/index.html">arthurchiao.art 的文章&lt;/a>：
&lt;ul>
&lt;li>&lt;a href="http://arthurchiao.art/blog/deep-dive-into-iptables-and-netfilter-arch-zh/">[译] 深入理解 iptables 和 netfilter 架构&lt;/a>&lt;/li>
&lt;li>&lt;a href="http://arthurchiao.art/blog/conntrack-design-and-implementation-zh/">连接跟踪（conntrack）：原理、应用及 Linux 内核实现&lt;/a>&lt;/li>
&lt;li>&lt;a href="http://arthurchiao.art/blog/nat-zh/">[译] NAT - 网络地址转换（2016）&lt;/a>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;h2 id="netfilter">Netfilter&lt;/h2>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/gral7u/1616165512374-db897dd5-0704-42f2-a1d8-441af05f247c.jpeg" alt="">&lt;/p>
&lt;p>Netfilter 是 Linux 操作系统核心层内部的一个数据包处理模块集合的统称。一种网络筛选系统，对数据包进入以及出去本机进行的一些控制与管理。该功能的所有模块可以通过下图所示的目录进行查找，其中还包括 ipvs 等。
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/gral7u/1616165512330-720231f3-a4f2-4a51-96cf-137a36724b74.jpeg" alt="">
Netfilter 项目支持如下功能&lt;/p>
&lt;ul>
&lt;li>网络地址转换(Network Address Translate)&lt;/li>
&lt;li>数据包过滤&lt;/li>
&lt;li>数据包日志记录&lt;/li>
&lt;li>用户空间数据包队列&lt;/li>
&lt;li>其他数据包处理&lt;/li>
&lt;li>等等&lt;/li>
&lt;/ul>
&lt;p>Netfilter Hooks 是 Linux 内核中的一个框架，它会让 Netfilter 的模块在 Linux 网络堆栈的不同位置注册回调函数。然后，为遍历 Linux 网络堆栈中相应 Hook 的每个数据包调用已注册的回调函数。&lt;/p>
&lt;ul>
&lt;li>用白话说：内核加入了 Netfilter 模块后，每个数据包进来之后，都会经过五个 Hooks 点来处理，以便决定每个数据包的走向。&lt;/li>
&lt;/ul>
&lt;h2 id="hooks">Hooks&lt;/h2>
&lt;p>hooks function(钩子函数) 是 Linux 网络栈中的流量检查点。所有流量通过网卡进入内核或从内核出去都会调用 Hook 函数来进行检查，并根据其规则进行过滤。Netfilter 框架中一共有 5 个 Hook，就是下文定义的“五链”。&lt;/p>
&lt;ul>
&lt;li>当一个数据包在其中一个 Hooks 中匹配到自己的规则后，则会进入下一个 Hook 寻找匹配自身的规则，直到将 5 个 Hook 挨个匹配一遍。&lt;/li>
&lt;li>可以把 Hook 想象成地铁站的闸机，通过闸机的人，就是数据流量，这个能不能从闸机过去，则看闸机对这个人身份验证的结果，是放行还是阻止&lt;/li>
&lt;/ul>
&lt;h2 id="iptabelesnftables">iptabeles/nftables&lt;/h2>
&lt;p>工作于用户空间的管理工具，对 5 个 hook 进行规则管理，iptabels 或 nftables 进程，开机后，只是把设定好的规则写进 hook 中&lt;/p>
&lt;p>Netfilter 所设置的规则是存放在内核内存中的，Iptables 是一个应用层(Ring3)的应用程序，它通过 Netfilter 放出的接口来对存放在内核内存中的 Xtables(Netfilter 的配置表)进行修改(这是一个典型的 Ring3 和 Ring0 配合的架构)&lt;/p>
&lt;h1 id="五链chain">五链(Chain)&lt;/h1>
&lt;p>把每个 Hook 上的规则都串起来类似于一条链子，所以称为链，一共 5 个 Hook，所以有 5 个 Chain。每个规则都是由“源 IP、目标 IP、端口、目标”等信息组合起来的。(i.e 对从哪来的或者到哪去的 IP 的哪个端口，要执行什么动作或‘引用什么 Chain 来对这个数据包执行什么动作’)&lt;/p>
&lt;ol>
&lt;li>&lt;strong>PREROUTING 链&lt;/strong> # 路由前，处理刚到达本机并在路由转发前的数据包。它会转换数据包中的目标 IP 地址（destination ip address），通常用于 DNAT(destination NAT)。处理完成之后分成两种情况，目的 IP 为本机网口则 INPUT，目的 IP 非本机网口则 FORWARD&lt;/li>
&lt;li>&lt;strong>INPUT 链&lt;/strong> # 进入，处理来自外部的数据。&lt;/li>
&lt;li>&lt;strong>FORWARD 链&lt;/strong> # 转发，将数据转发到本机的其他网络设备上。(需要开启 linux 的 IP 转发功能 net.ipv4.ip_forward=1 才会进入该流程；就算 ping 的是本机的其余网络设备上的 IP，也是由接收该数据包的网络设备进行回应)，FORWARD 的行为类似于路由器，系统中每个网络设备就是路由器上的每个端口，只有打开转发功能，才可以把数据包路由到其余端口上。
&lt;ol>
&lt;li>虚拟化或容器技术中，如果一台设备中有多个网段，一般都会打开转发功能，以实现不同网段路由互通的效果。&lt;/li>
&lt;li>或者服务器作为 VPN 使用时，由于不同网络设备所属网段不同，也需要打开转发功能。&lt;/li>
&lt;li>等等&lt;/li>
&lt;/ol>
&lt;/li>
&lt;li>**OUTPUT 链 **# 出去，处理向外发送的数据。&lt;/li>
&lt;li>**POSTROUTING 链 **# 路由后，处理即将离开本机的数据包。它会转换数据包中的源 IP 地址（source ip address），通常用于 SNAT（source NAT）。(该路由是通过 Linux 中定义的 route 规则发送的，与内核的 ip_forward 无关)&lt;/li>
&lt;li>**自定义链 **# 用户自己定义的链，不会调用系统 Hook，而是由系统默认的 5 个链在 target 中定义引用&lt;/li>
&lt;/ol>
&lt;h2 id="规则rule匹配match规则的匹配条件匹配的用法详见iptables-框架工具介绍">规则(Rule)匹配(Match)：(规则的匹配条件)匹配的用法详见：iptables 框架工具介绍&lt;/h2>
&lt;p>规则，需要有具体的内容才能称为规则，所以 Match 就是规则中的具体内容。&lt;/p>
&lt;p>每条链上的规则，需要对流量进行匹配后才能对该流量进行相应的处理，匹配内容包括“数据包的源地址、目标地址、协议、目标等”，(e.g.这个数据使用哪个协议从哪来的到哪去的目标是什么)
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/gral7u/1616165512349-f2e6f4c5-d617-4b04-a432-f9a7389120df.jpeg" alt="">
Match 功能的实现依赖于模块(类似于内核的模块)，比如右图，可以使用命令 rpm -ql iptables | grep &amp;ldquo;.so&amp;quot;查看都有哪些模块，其中的 XXX.so 就是各个功能的模块，大写字母是 target 所用的模块，小写字母是基本匹配与扩展匹配所用的模块&lt;/p>
&lt;ol>
&lt;li>基本匹配：源地址、目标地址、协议、入流网卡、出流网卡&lt;/li>
&lt;li>扩展匹配：用于对基本匹配的内容扩充，包括两类，普通的扩展匹配和基于
&lt;ol>
&lt;li>通用扩展匹配，可以直接使用。&lt;/li>
&lt;li>基于基本匹配的扩展匹配。需要有基本匹配规则才可以使用。
&lt;ol>
&lt;li>e.g.需要匹配某些端口，这类匹配必须基于 tcp 匹配规则上使用，否则无效(e.g.-p tcp -m tcp -m multiport &amp;ndash;dport22,23,24)&lt;/li>
&lt;/ol>
&lt;/li>
&lt;/ol>
&lt;/li>
&lt;li>目标(target)：每个规则中的目标。即在每条链上对每个进出流量匹配上之后应该执行什么动作，Target 包括以下几种
&lt;ol>
&lt;li>ACCEPT #允许流量通过&lt;/li>
&lt;li>REJECT #拒绝流量通过&lt;/li>
&lt;li>DROP #丢弃，不响应，发送方无法判断是被拒绝&lt;/li>
&lt;li>RETURN #返回调用链&lt;/li>
&lt;li>MARK #做防火墙标记&lt;/li>
&lt;li>用于 nat 表的 target
&lt;ol>
&lt;li>DNAT|SNAT #{目的|源}地址转换&lt;/li>
&lt;li>REDIRECT #端口重定向&lt;/li>
&lt;li>MASQUERADE #地址伪装类似于 SNAT，但是不用指明要转换的地址，而是自动选择要转换的地址，用于外部地址不固定的情况&lt;/li>
&lt;/ol>
&lt;/li>
&lt;li>用于 raw 表的 target
&lt;ol>
&lt;li>NOTRACK #raw 表专用的 target，用于对匹配规则进行 notrack(不跟踪)处理&lt;/li>
&lt;/ol>
&lt;/li>
&lt;li>LOG #将数据包的相关信息记录日志，执行完该目标后，会继续匹配后面的规则&lt;/li>
&lt;li>引用自定义链 #直接使用“-j 自定义链的名称”即可，让基本 5 个 Chain 上匹配成功的数据包继续执行自定义链上的规则。&lt;/li>
&lt;/ol>
&lt;/li>
&lt;/ol>
&lt;p>注意，这里面的路由指数据包在 Linux 本机内部路由&lt;/p>
&lt;h2 id="linux-数据包路由原理iptablesnetfilter-入门学习">Linux 数据包路由原理、Iptables/netfilter 入门学习&lt;/h2>
&lt;p>数据流处理流程简介&lt;/p>
&lt;p>注意：每个数据包在 CHAIN 中匹配到适用于自己的规则之后，则直接进入下一个 CHAIN，而不会遍历 CHAIN 中每条规则去挨个匹配适用于自己的规则。比如下面两种情况&lt;/p>
&lt;p>INPUT 链默认 DROP，匹配第一条：目的端口是 9090 的数据 DROP，然后不再检查下一项，那么 9090 无法访问&lt;/p>
&lt;pre>&lt;code>-P INPUT DROP
-A INPUT -p tcp -m tcp --dport 9090 -j DROP
-A INPUT -p tcp -m tcp --dport 9090 -j ACCEPT
&lt;/code>&lt;/pre>
&lt;p>INPUT 链默认 DROP，匹配第一条目的端口是 9090 的数据 ACCEPT，然后不再检查下一条规则，则 9090 可以访问&lt;/p>
&lt;pre>&lt;code>-P INPUT DROP
-A INPUT -p tcp -m tcp --dport 9090 -j ACCEPT
-A INPUT -p tcp -m tcp --dport 9090 -j DROP
&lt;/code>&lt;/pre>
&lt;p>匹配条件：根据协议报文特征指定&lt;/p>
&lt;ol>
&lt;li>基本匹配条件&lt;/li>
&lt;li>扩展匹配条件&lt;/li>
&lt;/ol>
&lt;p>处理动作：&lt;/p>
&lt;ol>
&lt;li>内建处理机制&lt;/li>
&lt;li>自定义处理机制&lt;/li>
&lt;li>注意：自定义的链不会有流量经过，而是在主要的 5 链中引用自定义链上的规则，来实现对流量的处理&lt;/li>
&lt;/ol>
&lt;p>下图是从服务器外部进入网卡，再进入网络栈的数据流走向，如果直接是服务器内部服务生成的数据包进入网络栈，则不适用于该图
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/gral7u/1616165512341-aeeeff06-b602-4340-bc4f-cd582144f85f.jpeg" alt="">&lt;/p>
&lt;ol>
&lt;li>当一个数据包进入网卡时，数据包首先进入 PREROUTING 链，在 PREROUTING 链中我们有机会修改数据包的 DestIP(目的 IP)，然后内核的&amp;quot;路由模块&amp;quot;根据&amp;quot;数据包目的 IP&amp;quot;以及&amp;quot;内核中的路由表&amp;quot;判断是否需要转送出去(注意，这个时候数据包的 DestIP 有可能已经被我们修改过了)&lt;/li>
&lt;li>如果数据包就是进入本机的(即数据包的目的 IP 是本机的网口 IP)，数据包就会沿着图向下移动，到达 INPUT 链。数据包到达 INPUT 链后，任何进程都会收到它&lt;/li>
&lt;li>本机上运行的程序也可以发送数据包，这些数据包经过 OUTPUT 链，然后到达 POSTROTING 链输出(注意，这个时候数据包的 SrcIP 有可能已经被我们修改过了)&lt;/li>
&lt;li>如果数据包是要转发出去的(即目的 IP 地址不再当前子网中)，且内核允许转发，数据包就会向右移动，经过 FORWARD 链，然后到达 POSTROUTING 链输出(选择对应子网的网口发送出去)&lt;/li>
&lt;/ol>
&lt;p>出于安全考虑，Linux 系统默认是禁止数据包转发的。所谓转发即当主机拥有多于一块的网卡时，其中一块收到数据包，根据数据包的目的 ip 地址将包发往本机另一网卡，该网卡根据路由表继续发送数据包。这通常就是路由器所要实现的功能。&lt;/p>
&lt;p>配置 Linux 系统的 ip 转发功能，首先保证硬件连通，然后打开系统的转发功能，less /proc/sys/net/ipv4/ip_forward，该文件内容为 0，表示禁止数据包转发，1 表示允许，将其修改为 1。可使用命令 echo &amp;ldquo;1&amp;rdquo; &amp;gt; /proc/sys/net/ipv4/ip_forward 修改文件内容，重启网络服务或主机后效果不再。若要其自动执行，可将命令 echo &amp;ldquo;1&amp;rdquo; &amp;gt; /proc/sys/net/ipv4/ip_forward 写入脚本/etc/rc.d/rc.local 或者 在/etc/sysconfig/network 脚本中添加 FORWARD_IPV4=&amp;ldquo;YES&amp;rdquo;&lt;/p>
&lt;h1 id="natnetwork-address-translation网络地址转换">NAT(Network Address Translation)网络地址转换&lt;/h1>
&lt;p>NAT 为了安全性而产生的，主要用来隐藏本地主机的 IP 地址&lt;/p>
&lt;h2 id="snatsource-源地址转换针对请求报文的源地址而言">SNAT：Source 源地址转换，针对请求报文的源地址而言&lt;/h2>
&lt;p>当想访问外网的时候，把源地址转换，作用于 POSTROUTING 链&lt;/p>
&lt;p>常用于内网私网地址转换成公网地址，比如家用路由器&lt;/p>
&lt;h2 id="dnatdestination-目的地址转换针对请求报文的目标地址而言">DNAT：Destination 目的地址转换，针对请求报文的目标地址而言&lt;/h2>
&lt;p>当从外部访问某 IP 时，把目的 IP 转换，作用于 PREROUTING、FORWARD 链&lt;/p>
&lt;p>把内网中的服务器发布到外网中去，&lt;/p>
&lt;p>常用于公网访问一个公司的公网 IP，但是由私网 IP 来提供服务，比如 LVS 的 nat 模型&lt;/p>
&lt;p>比如在公司内网中提供一个 web 服务，但是由于是私网地址，来自互联网的任何请求无法送达这台 web 服务器，这时候我们可以对外宣称公司的 web 服务在一个公网的 IP 地址上，但是公网的 IP 地址所在服务器上又没有提供 web 服务，这时候，来自外网访问的请求，全部 DNAT 成私网 IP，即可对外提供请求。&lt;/p>
&lt;h2 id="注意">注意：&lt;/h2>
&lt;p>由于 SNAT 与 DNAT 在描述的时候主要是都是针对请求报文而言的，那么当地址转换以后，响应报文响应的是转换后的地址，这时候就无法把响应请求送还给发起请求的设备了，这怎么办呢？这时候，同样需要一个地址转换，只不过通过 NAT 机制自行完成的，如何自动完成呢？这里面会有一个连接追踪机制，跟踪每一个数据连接（详见：&lt;a href="https://www.yuque.com/go/doc/33221811">ConnTrack 连接跟踪机制&lt;/a>），当响应报文到来的时候，根据连接追踪表中的信息记录的请求报文是怎么转换的相关信息，来对响应报文进行 NAT 转换。&lt;/p></description></item><item><title>Docs: Connection Tracking(连接跟踪)机制</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2.kernel%E5%86%85%E6%A0%B8/8.network-%E7%AE%A1%E7%90%86/linux-%E7%BD%91%E7%BB%9C%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6/netfilter-%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6%E7%B3%BB%E7%BB%9F/connection-tracking%E8%BF%9E%E6%8E%A5%E8%B7%9F%E8%B8%AA%E6%9C%BA%E5%88%B6/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2.kernel%E5%86%85%E6%A0%B8/8.network-%E7%AE%A1%E7%90%86/linux-%E7%BD%91%E7%BB%9C%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6/netfilter-%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6%E7%B3%BB%E7%BB%9F/connection-tracking%E8%BF%9E%E6%8E%A5%E8%B7%9F%E8%B8%AA%E6%9C%BA%E5%88%B6/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://conntrack-tools.netfilter.org/manual.html">Netfilter 官方文档，连接跟踪工具用户手册&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://opengers.github.io/openstack/openstack-base-netfilter-framework-overview/">云计算基层技术-netfilter 框架研究&lt;/a>&lt;/li>
&lt;li>&lt;a href="http://arthurchiao.art/index.html">arthurchiao.art 的文章&lt;/a>,&lt;a href="http://arthurchiao.art/blog/conntrack-design-and-implementation-zh/">连接跟踪（conntrack）：原理、应用及 Linux 内核实现&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>&lt;strong>Connection Tracking(连接跟踪系统，简称 ConnTrack、CT)&lt;/strong>，用于跟踪并且记录连接状态。Linux 为每一个经过网络堆栈的数据包，生成一个** ConnTrack Entry(连接跟踪条目，简称 Entry)**，并把该条目记录在一个 &lt;strong>ConnnTrack Table(连接跟踪表)&lt;/strong> 中，条目中主要是包含该连接的协议、源 IP 和 PORT、目标 IP 和 PORT、协议号、数据包的大小等等等信息。此后，在处理数据包时读取该文件，在文件中所有属于此连接的数据包都被唯一地分配给这个连接，并标识连接的状态。该文件中的每一个条目都有一个持续时间，当持续时间结束后，该连接会被自动清除，再有相同的连接进来的时候，则按照新连接来处理。Netfilter 中定义了如下几个连接状态以便对具有这些状态的连接进行处理：&lt;/p>
&lt;p>可跟踪的连接状态有以下几个&lt;/p>
&lt;ol>
&lt;li>NEW：新发出的请求。在连接跟踪文件中(nf_conntrack)不存在此连接。&lt;/li>
&lt;li>ESTABLISHED：已建立的。NEW 状态之后，在 nf_conntrack 文件中为其建立的条目失效之前所进行的通信的状态&lt;/li>
&lt;li>RELATED：有关联的。某个已经建立的连接所建立的新连接；e.g.FTP 的数据传输连接就是控制连接所 RELATED 出来的连接。–icmp-type 8(ping 请求)就是–icmp-type 0(ping 应答) 所 RELATED 出来的。&lt;/li>
&lt;li>INVALIED：无法识别的连接。&lt;/li>
&lt;li>UNTRACKED：不跟踪的链接状态，仅在使用 raw 表的时候该状态才有用，即 raw 不进行链接跟踪的时候，则连接跟踪表中没有记录的数据包就是此状态&lt;/li>
&lt;li>其他：
&lt;ol>
&lt;li>NEW 与 ESTABLISHED 的定义：只要第一次请求就算 NEW(e.g.本机往外第一次发送，外部第一次发往本机的请求)，哪怕对第一个 NEW 请求再回应的都算 ESTABLISHED。注意在 INPUT 和 OUTPUT 链上定义 NEW 的情况，INPUT 是对外部访问本机来说第一次是 NEW；OUTPUT 是对本机访问外部来说第一次是 NEW。&lt;/li>
&lt;/ol>
&lt;/li>
&lt;/ol>
&lt;p>注意：ConnTrack 中所定义的状态与 TCP 等协议所定义的状态不一样，这里面定义的状态只是为了可以通过一种新的方式来处理每一个数据包，并进行过滤，这是 Netfilter 中所定义的状态&lt;/p>
&lt;p>ConnTrack 功能依靠** nf_conntrack **模块来实现的，当启用 iptables 功能时(比如 firewalld)会自动加载该模块&lt;/p>
&lt;p>连接跟踪是防火墙模块的状态检测的基础，同时也是地址转换中实现 SNAT 和 DNAT 的基础，如果在 nat 表上没有连接跟踪，那么则没法进行 nat 转换(比如通过 raw 表来关闭连接跟踪)。&lt;/p>
&lt;h1 id="conntrack-table连接跟踪表">ConnTrack Table(连接跟踪表)&lt;/h1>
&lt;p>ConnTrack 将连接跟踪表保存于系统的内存当中，可以通过 &lt;strong>cat /proc/net/nf_conntrack &lt;strong>或&lt;/strong> conntrack -L &lt;strong>命令查看到当前已跟踪的所有&lt;/strong> ConnTrack Entry(连接跟踪条目)&lt;/strong>。不同的协议，条目的内容也不太一样，下面是一个 tcp 协议的条目内容：&lt;/p>
&lt;ul>
&lt;li>&lt;code>ipv4 2 tcp 6 299 ESTABLISHED src=192.168.2.40 dst=172.38.40.250 sport=61758 dport=22 src=172.38.40.250 dst=192.168.2.40 sport=22 dport=61758 [ASSURED] mark=0 zone=0 use=2&lt;/code>&lt;/li>
&lt;/ul>
&lt;p>nf_conntrack 文件中，每个条目占用单独一行。条目中包含了数据包的原始方向信息(蓝色部分)，和期望的响应包信息(红色部分)，这样内核能够在后续到来的数据包中识别出属于此连接的双向数据包，并更新此连接的状态。&lt;/p>
&lt;p>在内核中，&lt;strong>ConnTrackTable(连接跟踪表)&lt;/strong> 实际上是一个 &lt;strong>hash table(哈希表)&lt;/strong>。收到一个数据包，通过如下步骤判断该数据包是否署一个已有连接(即定位连接跟踪条目)：&lt;/p>
&lt;ul>
&lt;li>第一步：内核提取数据包信息(源 IP、目的 IP、port，协议号)进行 hash 计算得到一个 hash 值，在哈希表中以此 hash 值做索引，索引结果为数据包所属的 &lt;strong>Bucket(储存区)&lt;/strong>。这一步 hash 计算时间固定并且很短。
&lt;ul>
&lt;li>一个 **Bucket(储存区) &lt;strong>里包含一个&lt;/strong> linked list(**已链接的列表，简称 &lt;strong>链表)&lt;/strong>，即已经追踪的条目的列表。也就是说，每个 Bucket 里可以存放多个 ConnTrack Entry。所谓 Bucket 的大小，就是指一个 Bucket 中可以存放多少个 ConnTrack Entry。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>第二步：遍历第一步获取的 Bucket 中的所有条目，查找是否有匹配的条目。这一步是比较耗时的操作，所以说 Bucket 越大，遍历时间越长&lt;/li>
&lt;/ul>
&lt;h2 id="bucket储存区">Bucket(储存区)&lt;/h2>
&lt;p>在 Connection Tracking 系统中的 hash table 中，有若干个 &lt;strong>Bucket(储存区)&lt;/strong>，Bucket 的个数通过两个内核参数计算而来&lt;/p>
&lt;ul>
&lt;li>net.netfilter.nf_conntrack_buckets # 一个表最大的 Bucket 数量。默认通过内存计算得来，内存越高，Bucket 越多。也可以通过设置模块参数指定具体的数值
&lt;ul>
&lt;li>无法通过 sysctl 修改 nf_conntrack_buckets 的值，该值只能通过加载 nf_conntrack 模块时的参数来决定。使用 &lt;code>echo &amp;quot;options nf_conntrack hashsize=16384&amp;quot; &amp;gt; /etc/modprobe.d/nf_conntrack.conf&lt;/code> 命令即可设置该内核参数为 16384&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>net.netfilter.nf_conntrack_max # 一个表最大的 Entry 数量。默认为 nf_conntrack_buckets 值的 4 倍。也就是说，&lt;strong>Bucket 的大小默认为 4&lt;/strong>，即系统默认每个 Bucket 中包含 4 个 ConnTrack Entry。
&lt;ul>
&lt;li>当不使用系统默认的 nf_conntrack_buckets 值时，则 nf_conntrack_max 的值为 nf_conntrack_buckets 的 8 倍&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>如果把一个 Bucket 的大小称为 &lt;code>BucketSize&lt;/code> 的话，那么&lt;code>BucketSize = nf_conntrack_max / nf_conntrack_buckets&lt;/code>(这意思就是说 &lt;code>储存区的大小=条目总数 / 储存区的总数&lt;/code>，所以储存区大小就是指能装多少条目)&lt;/p>
&lt;h2 id="conntrack-entry连接跟踪条目">ConnTrack Entry(连接跟踪条目)&lt;/h2>
&lt;p>conntrack 从经过它的数据包中提取详细的，唯一的信息，因此能保持对每一个连接的跟踪。关于 conntrack 如何确定一个连接，对于 tcp/udp，连接由他们的源目地址，源目端口唯一确定。对于 icmp，由 type，code 和 id 字段确定。&lt;/p>
&lt;pre>&lt;code>ipv4 2 tcp 6 33 SYN_SENT src=172.16.200.119 dst=172.16.202.12 sport=54786 dport=10051 [UNREPLIED] src=172.16.202.12 dst=172.16.200.119 sport=10051 dport=54786 mark=0 zone=0 use=2
&lt;/code>&lt;/pre>
&lt;p>如上是一条 conntrack 条目，它代表当前已跟踪到的某个连接，conntrack 维护的所有信息都包含在这个条目中，通过它就可以知道某个连接处于什么状态&lt;/p>
&lt;ul>
&lt;li>&lt;strong>ipv4&lt;/strong> # 此连接使用 ipv4 协议，是一条 tcp 连接(tcp 的协议类型代码是 6)&lt;/li>
&lt;li>&lt;strong>33&lt;/strong> # 这条 conntrack 条目在当前时间点的生存时间(每个 conntrack 条目都会有生存时间，从设置值开始倒计时，倒计时完后此条目将被清除)，可以使用&lt;code>sysctl -a |grep conntrack | grep timeout&lt;/code>查看不同协议不同状态下生存时间设置值，当然这些设置值都可以调整，注意若后续有收到属于此连接的数据包，则此生存时间将被重置(重新从设置值开始倒计时)，并且状态改变，生存时间设置值也会响应改为新状态的值&lt;/li>
&lt;li>&lt;strong>SYN_SENT&lt;/strong> # 到此刻为止 conntrack 跟踪到的这个连接的状态(内核角度)，&lt;code>SYN_SENT&lt;/code>表示这个连接只在一个方向发送了一初始 TCP SYN 包，还未看到响应的 SYN+ACK 包(只有 tcp 才会有这个字段)。&lt;/li>
&lt;li>&lt;strong>src=172.16.200.119 dst=172.16.202.12 sport=54786 dport=10051&lt;/strong> #从数据包中提取的此连接的源目地址、源目端口，是 conntrack 首次看到此数据包时候的信息。&lt;/li>
&lt;li>&lt;strong>[UNREPLIED]&lt;/strong> # 说明此刻为止这个连接还没有收到任何响应，当一个连接已收到响应时，[UNREPLIED]标志就会被移除&lt;/li>
&lt;li>&lt;strong>src=172.16.202.12 dst=172.16.200.119 sport=10051 dport=54786&lt;/strong> # 地址和端口和前面是相反的，这部分不是数据包中带有的信息，是 conntrack 填充的信息，代表 conntrack 希望收到的响应包信息。意思是若后续 conntrack 跟踪到某个数据包信息与此部分匹配，则此数据包就是此连接的响应数据包。注意这部分确定了 conntrack 如何判断响应包(tcp/udp)，icmp 是依据另外几个字段&lt;/li>
&lt;/ul>
&lt;p>上面是 tcp 连接的条目，而 udp 和 icmp 没有连接建立和关闭过程，因此条目字段会有所不同，后面 iptables 状态匹配部分我们会看到处于各个状态的 conntrack 条目&lt;/p>
&lt;p>注意：conntrack 机制并不能够修改或过滤数据包，它只是跟踪网络连接并维护连接跟踪表，以提供给 iptables 做状态匹配使用，也就是说，如果你 iptables 中用不到状态匹配，那就没必要启用 conntrack&lt;/p>
&lt;h2 id="总结">总结&lt;/h2>
&lt;p>所以，一个 ConnTrack Table 就类似于下面的表：&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>&lt;strong>Hash Table&lt;/strong>&lt;/th>
&lt;th>Bucket 1&lt;/th>
&lt;th>Bucket 2&lt;/th>
&lt;th>Bucket 3&lt;/th>
&lt;th>&amp;hellip;&amp;hellip;.&lt;/th>
&lt;th>Bucket N&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>Entry 1&lt;/td>
&lt;td>条目内容&lt;/td>
&lt;td>条目内容&lt;/td>
&lt;td>条目内容&lt;/td>
&lt;td>条目内容&lt;/td>
&lt;td>条目内容&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Entry 2&lt;/td>
&lt;td>条目内容&lt;/td>
&lt;td>条目内容&lt;/td>
&lt;td>条目内容&lt;/td>
&lt;td>条目内容&lt;/td>
&lt;td>条目内容&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&amp;hellip;&amp;hellip;..&lt;/td>
&lt;td>条目内容&lt;/td>
&lt;td>条目内容&lt;/td>
&lt;td>条目内容&lt;/td>
&lt;td>条目内容&lt;/td>
&lt;td>条目内容&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Entry N&lt;/td>
&lt;td>条目内容&lt;/td>
&lt;td>条目内容&lt;/td>
&lt;td>条目内容&lt;/td>
&lt;td>条目内容&lt;/td>
&lt;td>条目内容&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h1 id="计算连接跟踪表所占内存">计算连接跟踪表所占内存&lt;/h1>
&lt;p>&lt;strong>total&lt;em>mem_used(单位为 Bytes) = nf_conntrack_max * sizeof(struct ip&lt;/em>conntrack) + nf_conntrack_buckets * sizeof(struct list_head)&lt;/strong>&lt;/p>
&lt;ol>
&lt;li>sizeof(struct ip_conntrack) 连接跟踪对象大小，默认 376&lt;/li>
&lt;li>sizeof(struct list_head) 链表项大小，默认为 16&lt;/li>
&lt;/ol>
&lt;p>上述两个值可以通过如下 python 代码计算出来&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>import ctypes
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#不同系统可能此库名不一样，需要修改&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>LIBNETFILTER_CONNTRACK &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#39;libnetfilter_conntrack.so.3.6.0&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>nfct &lt;span style="color:#f92672">=&lt;/span> ctypes.CDLL&lt;span style="color:#f92672">(&lt;/span>LIBNETFILTER_CONNTRACK&lt;span style="color:#f92672">)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>print &lt;span style="color:#e6db74">&amp;#39;sizeof(struct nf_conntrack):&amp;#39;&lt;/span>, nfct.nfct_maxsize&lt;span style="color:#f92672">()&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>print &lt;span style="color:#e6db74">&amp;#39;sizeof(struct list_head):&amp;#39;&lt;/span>, ctypes.sizeof&lt;span style="color:#f92672">(&lt;/span>ctypes.c_void_p&lt;span style="color:#f92672">)&lt;/span> * &lt;span style="color:#ae81ff">2&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>假如，我系统信息如下：&lt;/p>
&lt;pre>&lt;code>[root@node-1 ~]# cat /proc/sys/net/netfilter/nf_conntrack_max
524288
[root@node-1 ~]# cat /proc/sys/net/netfilter/nf_conntrack_buckets
131072
&lt;/code>&lt;/pre>
&lt;p>那么，此系统下，连接跟踪表所占内存即为：&lt;/p>
&lt;pre>&lt;code>(524288 * 376 + 131072 * 16) / 1024 / 1024 = 190MiB
&lt;/code>&lt;/pre>
&lt;h1 id="conntrack-关联文件与配置">ConnTrack 关联文件与配置&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://www.kernel.org/doc/Documentation/networking/nf_conntrack-sysctl.txt">内核官方文档，网络-nf_conntrack-sysctl&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>连接跟踪系统的配置大部分都可以通过修改内核参数来进行，还有一部分需要通过指定 模块的参数 来配置。&lt;/p>
&lt;ul>
&lt;li>**/proc/net/nf_conntrack **# 连接跟踪表，该文件用于记录每一个连接跟踪条目
&lt;ul>
&lt;li>注意：Ubuntu 中没有该文件，可以通过 &lt;code>conntrack -L&lt;/code> 命令获取连接跟踪条目。据说该文件已 deprecated(弃用)，但是未找到官方说明&lt;/li>
&lt;li>&lt;a href="https://forum.ubuntu.com.cn/viewtopic.php?t=480072">https://forum.ubuntu.com.cn/viewtopic.php?t=480072&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://askubuntu.com/questions/266991/in-ubuntu-12-10-how-to-enable-proc-net-ip-conntrack">https://askubuntu.com/questions/266991/in-ubuntu-12-10-how-to-enable-proc-net-ip-conntrack&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://patchwork.ozlabs.org/project/ubuntu-kernel/patch/1341986947-28300-3-git-send-email-bryan.wu@canonical.com/">https://patchwork.ozlabs.org/project/ubuntu-kernel/patch/1341986947-28300-3-git-send-email-bryan.wu@canonical.com/&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://github.com/kubernetes/kubernetes/pull/69589/files#r418929810">https://github.com/kubernetes/kubernetes/pull/69589/files#r418929810&lt;/a>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>/proc/sys/net/nf_conntrack_max&lt;/strong> # 等于 /proc/sys/net/netfilter/nf_conntrack_max 的值。修改这俩参数任意一个值，都会互相同步。&lt;/li>
&lt;li>**/proc/sys/net/netfilter/* **# 网络栈的运行时属性所在的目录
&lt;ul>
&lt;li>&lt;strong>./nf_conntrack_count&lt;/strong> # 当前连接跟踪数。&lt;/li>
&lt;li>**./nf_conntrack_max **# 连接跟踪表的大小，即一个表中有可以存放多少个条目。默认值为 nf_conntrack_buckets *4 。等于 /proc/sys/net/nf_conntrack_max 的值。&lt;/li>
&lt;li>&lt;strong>./nf_conntrack_buckets&lt;/strong> # hash 表的大小，即一个 hash 表中有多少个 Buckets。&lt;/li>
&lt;li>&lt;strong>./nf_conntrack_tcp_timeout_time_wait&lt;/strong> # timewait 状态的条目超时时间。 默认 120 秒&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h1 id="应用实例">应用实例&lt;/h1>
&lt;p>第一次 TCP 或 UDP 或 ICMP 等协议请求建立连接后，有一个持续时间，在持续时间内，这个连接信息会保存在连接跟踪表(记录在 nf_conntrack 文件中)中，当同一个 IP 再次请求的时候，这个请求的数据包则不会被当成 NEW 状态的数据包来处理(具体的状态有几种详见下文)，这个概念可以用在这么一个真实环境当中。&lt;/p>
&lt;h1 id="conntrack-命令行工具">conntrack 命令行工具&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;/blockquote></description></item><item><title>Docs: firewalld(Iptables 的管理工具)</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2.kernel%E5%86%85%E6%A0%B8/8.network-%E7%AE%A1%E7%90%86/linux-%E7%BD%91%E7%BB%9C%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6/netfilter-%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6%E7%B3%BB%E7%BB%9F/firewalldiptables-%E7%9A%84%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2.kernel%E5%86%85%E6%A0%B8/8.network-%E7%AE%A1%E7%90%86/linux-%E7%BD%91%E7%BB%9C%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6/netfilter-%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6%E7%B3%BB%E7%BB%9F/firewalldiptables-%E7%9A%84%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;p>firewalld 与 iptabels 一样，是管理 Linux 内核中的 Netfilter 功能的工具。&lt;/p>
&lt;p>FirewallD 使用两个配置模式：“runtime 运行时”和“permanent 持久”。&lt;/p>
&lt;ol>
&lt;li>runtime 模式：默认模式。所有配置即时生效，在重启系统、重新启动 FirewallD 时、使用&amp;ndash;reload 重载配置等操作是，在该模式下的配置都将被清除。&lt;/li>
&lt;li>permanent 模式：需要使用 &amp;ndash;permanent 选项生效，配置才会永久保存。如果想让 permanetn 模式下的配置立即生效，需要使用&amp;ndash;reload 命令或者重启 firewalld 服务。&lt;/li>
&lt;/ol>
&lt;h2 id="firewalld-中-zone区域的概念">firewalld 中 zone(区域)的概念&lt;/h2>
&lt;p>“区域”是针对给定位置或场景（例如家庭、公共、受信任等）可能具有的各种信任级别的预构建规则集。不同的区域允许不同的网络服务和入站流量类型，而拒绝其他任何流量。 首次启用 FirewallD 后，public 将是默认区域。&lt;/p>
&lt;p>区域也可以用于不同的网络接口。例如，要分离内部网络和互联网的接口，你可以在 internal 区域上允许 DHCP，但在 external 区域仅允许 HTTP 和 SSH。未明确设置为特定区域的任何接口将添加到默认区域。&lt;/p>
&lt;p>所以，一般情况下，所有区域都是拒绝所有新的入站流量，对已经建立连接的不再阻止。在使用 firewall-cmd 命令添加某 service、port、ip 等属性时，相当于允许对应属性的流量入站。i.e.添加进去就表示允许&lt;/p>
&lt;h2 id="zone-的种类与说明">zone 的种类与说明：&lt;/h2>
&lt;ol>
&lt;li>public（公共） #默认的 zone。在公共区域内使用，不能相信网络内的其他计算机不会对您的计算机造成危害，只能接收经过选取的连接。&lt;/li>
&lt;li>block（限制） #任何接收的网络连接都被 IPv4 的 icmp-host-prohibited 信息和 IPv6 的 icmp6-adm-prohibited 信息所拒绝。&lt;/li>
&lt;li>dmz（非军事区） #用于您的非军事区内的电脑，此区域内可公开访问，可以有限地进入您的内部网络，仅仅接收经过选择的连接。&lt;/li>
&lt;li>drop（丢弃） #任何接收的网络数据包都被丢弃，没有任何回复。仅能有发送出去的网络连接。&lt;/li>
&lt;li>external（外部） #特别是为路由器启用了伪装功能的外部网。您不能信任来自网络的其他计算，不能相信它们不会对您的计算机造成危害，只能接收经过选择的连接。&lt;/li>
&lt;li>home（家庭） #用于家庭网络。您可以基本信任网络内的其他计算机不会危害您的计算机。仅仅接收经过选择的连接。&lt;/li>
&lt;li>internal（内部） #用于内部网络。您可以基本上信任网络内的其他计算机不会威胁您的计算机。仅仅接受经过选择的连接。&lt;/li>
&lt;li>trusted（信任） #可接受所有的网络连接。&lt;/li>
&lt;li>work（工作） #用于工作区。您可以基本相信网络内的其他电脑不会危害您的电脑。仅仅接收经过选择的连接。&lt;/li>
&lt;/ol>
&lt;p>用实际举例：将设备某个网卡放在区域中，则流经该网卡的流量都会遵循该区域中所定义的规则。&lt;/p>
&lt;h1 id="firewalld-关联文件与配置">Firewalld 关联文件与配置&lt;/h1>
&lt;p>/usr/lib/firewalld # 保存默认配置，如默认区域和公用服务。 避免修改它们，因为每次 firewall 软件包更新时都会覆盖这些文件。
/etc/firewalld # 保存系统配置文件。这些文件将覆盖默认配置。&lt;/p>
&lt;ul>
&lt;li>firewalld.conf #&lt;/li>
&lt;/ul>
&lt;h1 id="firewall-安装完成后的-iptables-模式的默认配置">firewall 安装完成后的 iptables 模式的默认配置&lt;/h1>
&lt;p>以下是 public 区域下 filter 表的默认配置，大部分都是对于自定义链的规则&lt;/p>
&lt;ul>
&lt;li>
&lt;h1 id="设置-3-个基本链的默认-target">设置 3 个基本链的默认 target&lt;/h1>
&lt;/li>
&lt;li>-P INPUT ACCEPT&lt;/li>
&lt;li>-P FORWARD ACCEPT&lt;/li>
&lt;li>-P OUTPUT ACCEPT&lt;/li>
&lt;li>
&lt;h1 id="默认会创建多个自定义链">默认会创建多个自定义链&lt;/h1>
&lt;/li>
&lt;li>-N FORWARD_IN_ZONES&lt;/li>
&lt;li>-N FORWARD_IN_ZONES_SOURCE&lt;/li>
&lt;li>-N FORWARD_OUT_ZONES&lt;/li>
&lt;li>-N FORWARD_OUT_ZONES_SOURCE&lt;/li>
&lt;li>-N FORWARD_direct&lt;/li>
&lt;li>-N FWDI_public&lt;/li>
&lt;li>-N FWDI_public_allow&lt;/li>
&lt;li>-N FWDI_public_deny&lt;/li>
&lt;li>-N FWDI_public_log&lt;/li>
&lt;li>-N FWDO_public&lt;/li>
&lt;li>-N FWDO_public_allow&lt;/li>
&lt;li>-N FWDO_public_deny&lt;/li>
&lt;li>-N FWDO_public_log&lt;/li>
&lt;li>-N INPUT_ZONES&lt;/li>
&lt;li>-N INPUT_ZONES_SOURCE&lt;/li>
&lt;li>-N INPUT_direct&lt;/li>
&lt;li>-N IN_public&lt;/li>
&lt;li>-N IN_public_allow&lt;/li>
&lt;li>-N IN_public_deny&lt;/li>
&lt;li>-N IN_public_log&lt;/li>
&lt;li>-N OUTPUT_direct&lt;/li>
&lt;li>
&lt;h1 id="设置-input-链基本规则所有流量直接交给-input_directinput_zones_sourceinput_zones-这-3-个自定义链来继续进行规则匹配">设置 INPUT 链基本规则，所有流量直接交给 INPUT_direct、INPUT_ZONES_SOURCE、INPUT_ZONES 这 3 个自定义链来继续进行规则匹配。&lt;/h1>
&lt;/li>
&lt;li>-A INPUT -m conntrack &amp;ndash;ctstate RELATED,ESTABLISHED -j ACCEPT&lt;/li>
&lt;li>-A INPUT -i lo -j ACCEPT&lt;/li>
&lt;li>-A INPUT -j INPUT_direct&lt;/li>
&lt;li>-A INPUT -j INPUT_ZONES_SOURCE&lt;/li>
&lt;li>-A INPUT -j INPUT_ZONES #流量转给 INPUT 的 ZONES&lt;/li>
&lt;li>-A INPUT -m conntrack &amp;ndash;ctstate INVALID -j DROP&lt;/li>
&lt;li>-A INPUT -j REJECT &amp;ndash;reject-with icmp-host-prohibited #在 INPUT 链上拒绝所有流量，并通过 icmp 协议提示客户端 prohibited&lt;/li>
&lt;li>
&lt;h1 id="设置-forward-链基本规则所有流量直接交给">设置 FORWARD 链基本规则，所有流量直接交给&lt;/h1>
&lt;/li>
&lt;li>-A FORWARD -m conntrack &amp;ndash;ctstate RELATED,ESTABLISHED -j ACCEPT&lt;/li>
&lt;li>-A FORWARD -i lo -j ACCEPT&lt;/li>
&lt;li>-A FORWARD -j FORWARD_direct&lt;/li>
&lt;li>-A FORWARD -j FORWARD_IN_ZONES_SOURCE&lt;/li>
&lt;li>-A FORWARD -j FORWARD_IN_ZONES&lt;/li>
&lt;li>-A FORWARD -j FORWARD_OUT_ZONES_SOURCE&lt;/li>
&lt;li>-A FORWARD -j FORWARD_OUT_ZONES&lt;/li>
&lt;li>-A FORWARD -m conntrack &amp;ndash;ctstate INVALID -j DROP&lt;/li>
&lt;li>-A FORWARD -j REJECT &amp;ndash;reject-with icmp-host-prohibited #在 FORWARD 链上拒绝所有流量，并通过 icmp 协议提示客户端 prohibited&lt;/li>
&lt;li>
&lt;h1 id="设置-output-链基本规则直接把后续检查转交给-output_direct-这个自定义-chain-进行规则匹配">设置 OUTPUT 链基本规则，直接把后续检查转交给 OUTPUT_direct 这个自定义 chain 进行规则匹配&lt;/h1>
&lt;/li>
&lt;li>-A OUTPUT -j OUTPUT_direct&lt;/li>
&lt;li>
&lt;h1 id="forward-相关的自定义-chain-规则">FORWARD 相关的自定义 chain 规则&lt;/h1>
&lt;/li>
&lt;li>-A FORWARD_IN_ZONES -i bond0 -g FWDI_public&lt;/li>
&lt;li>-A FORWARD_IN_ZONES -i eth2 -g FWDI_public&lt;/li>
&lt;li>-A FORWARD_IN_ZONES -i eth1 -g FWDI_public&lt;/li>
&lt;li>-A FORWARD_IN_ZONES -i eth0 -g FWDI_public&lt;/li>
&lt;li>-A FORWARD_IN_ZONES -g FWDI_public&lt;/li>
&lt;li>-A FORWARD_OUT_ZONES -o bond0 -g FWDO_public&lt;/li>
&lt;li>-A FORWARD_OUT_ZONES -o eth2 -g FWDO_public&lt;/li>
&lt;li>-A FORWARD_OUT_ZONES -o eth1 -g FWDO_public&lt;/li>
&lt;li>-A FORWARD_OUT_ZONES -o eth0 -g FWDO_public&lt;/li>
&lt;li>-A FORWARD_OUT_ZONES -g FWDO_public&lt;/li>
&lt;li>-A FWDI_public -j FWDI_public_log&lt;/li>
&lt;li>-A FWDI_public -j FWDI_public_deny&lt;/li>
&lt;li>-A FWDI_public -j FWDI_public_allow&lt;/li>
&lt;li>-A FWDI_public -p icmp -j ACCEPT&lt;/li>
&lt;li>-A FWDO_public -j FWDO_public_log&lt;/li>
&lt;li>-A FWDO_public -j FWDO_public_deny&lt;/li>
&lt;li>-A FWDO_public -j FWDO_public_allow&lt;/li>
&lt;li>
&lt;h1 id="input-相关的自定义-chain-规则">INPUT 相关的自定义 chain 规则&lt;/h1>
&lt;/li>
&lt;li>
&lt;h1 id="input_zones-用来将各个网络设备区分到指定的-zone-中">INPUT_ZONES 用来将各个网络设备区分到指定的 ZONE 中&lt;/h1>
&lt;/li>
&lt;li>-A INPUT_ZONES -i bond0 -g IN_public&lt;/li>
&lt;li>-A INPUT_ZONES -i eth2 -g IN_public&lt;/li>
&lt;li>-A INPUT_ZONES -i eth1 -g IN_public&lt;/li>
&lt;li>-A INPUT_ZONES -i eth0 -g IN_public #将 eth0 的流量放到 public 区域中继续进行匹配&lt;/li>
&lt;li>-A INPUT_ZONES -g IN_public&lt;/li>
&lt;li>
&lt;h1 id="input-链上的-public-区域的规则">INPUT 链上的 public 区域的规则&lt;/h1>
&lt;/li>
&lt;li>-A IN_public -j IN_public_log&lt;/li>
&lt;li>-A IN_public -j IN_public_deny&lt;/li>
&lt;li>-A IN_public -j IN_public_allow&lt;/li>
&lt;li>-A IN_public -p icmp -j ACCEPT&lt;/li>
&lt;li>-A IN_public_allow -p tcp -m tcp &amp;ndash;dport 22 -m conntrack &amp;ndash;ctstate NEW -j ACCEPT&lt;/li>
&lt;li>
&lt;h1 id="xxxx-区域的规则">XXXX 区域的规则&lt;/h1>
&lt;/li>
&lt;li>。。。。每当一个网络设备被放到某个区域中，这个区域就会激活，会在整个 iptables 表中显示，可以使用 firewall-cmd &amp;ndash;zone=drop &amp;ndash;change-interface=eth1 进行验证&lt;/li>
&lt;/ul>
&lt;p>从下往上看的话，firewalld 会默认方通 22 端口(i.e.方通 sshd 服务)和 icmp 协议，并且自定义规则链的数据结构详见脑图 firewalld 之 filter 表基本配置图.mindmap&lt;/p></description></item><item><title>Docs: firewalld(Iptables 的管理工具)</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2.kernel%E5%86%85%E6%A0%B8/8.network-%E7%AE%A1%E7%90%86/linux-%E7%BD%91%E7%BB%9C%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6/netfilter-%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6%E7%B3%BB%E7%BB%9F/firewalldiptables-%E7%9A%84%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2.kernel%E5%86%85%E6%A0%B8/8.network-%E7%AE%A1%E7%90%86/linux-%E7%BD%91%E7%BB%9C%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6/netfilter-%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6%E7%B3%BB%E7%BB%9F/firewalldiptables-%E7%9A%84%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/</guid><description/></item><item><title>Docs: iptables(Netfilter 的实现)</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2.kernel%E5%86%85%E6%A0%B8/8.network-%E7%AE%A1%E7%90%86/linux-%E7%BD%91%E7%BB%9C%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6/netfilter-%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6%E7%B3%BB%E7%BB%9F/iptablesnetfilter-%E7%9A%84%E5%AE%9E%E7%8E%B0/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2.kernel%E5%86%85%E6%A0%B8/8.network-%E7%AE%A1%E7%90%86/linux-%E7%BD%91%E7%BB%9C%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6/netfilter-%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6%E7%B3%BB%E7%BB%9F/iptablesnetfilter-%E7%9A%84%E5%AE%9E%E7%8E%B0/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://man7.org/linux/man-pages/man8/iptables.8.html">Manual(手册),iptables(8)&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.frozentux.net/iptables-tutorial/iptables-tutorial.html">Netfilter 官方文档，iptables 教程&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>iptables 是一组工具合集的统称，其中包括 iptables、ip6tables、arptables、ebtables 等，用于与 netfilter 模块进行交互的 CLI 工具&lt;/p>
&lt;p>iptables 和 ip6tables 用于建立、维护和检查 Linux 内核中的 IPv4 和 IPv6 包过滤规则表。可以定义几个不同的表中的各种规则，也可以定义用户定义的链。并把已经定义的规则发送给 netfilter 模块。&lt;/p>
&lt;h2 id="四表table-note四表是-iptables-框架中的概念不是-netfilter-中的">四表(Table) Note:四表是 iptables 框架中的概念，不是 netfilter 中的&lt;/h2>
&lt;p>iptables 框架将流量抽象分为 4 类：过滤类、网络地址转换类、拆解报文类、原始类。每种类型的链作用在 Netfilter 系统中的 Hook 各不不相同，每种类型具有不同的功能。每一类都称为一张表。比如 fileter 表用来在指定链上检查流量是否可以通过，nat 表用来在指定链上检查流量是否可以进行地址转换，等等。Note：不是所有表都可以在所有链上具有规则，下表是 4 个表在 5 个 Hook 上的可用关系。&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>表名\链名&lt;/th>
&lt;th>PREROUTING&lt;/th>
&lt;th>INPUT&lt;/th>
&lt;th>FORWARD&lt;/th>
&lt;th>OUTPUT&lt;/th>
&lt;th>POSTROUTING&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>filter&lt;/td>
&lt;td>&lt;/td>
&lt;td>可用&lt;/td>
&lt;td>可用&lt;/td>
&lt;td>可用&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>nat&lt;/td>
&lt;td>可用&lt;/td>
&lt;td>可用&lt;/td>
&lt;td>&lt;/td>
&lt;td>可用&lt;/td>
&lt;td>可用&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>mangle&lt;/td>
&lt;td>可用&lt;/td>
&lt;td>可用&lt;/td>
&lt;td>可用&lt;/td>
&lt;td>可用&lt;/td>
&lt;td>可用&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>raw&lt;/td>
&lt;td>可用&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;td>可用&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>iptables 中有默认的内置 4 个表，每个表的名称就是其 chain 类型的名称&lt;/p>
&lt;h3 id="filter过滤器--过滤防火墙">filter(过滤器) # 过滤，防火墙&lt;/h3>
&lt;ul>
&lt;li>该类型的链可作用在以下几个 Hook 点上：INPUT、FORWARD、OUTPUT&lt;/li>
&lt;/ul>
&lt;h3 id="nat网络地址转换--网络地址转换">nat(网络地址转换) # 网络地址转换&lt;/h3>
&lt;ul>
&lt;li>该类型的链可作用在以下几个 Hook 点上：PREROUTING(DNAT)、INPUT、OUTPUT、POSTROUTING(SNAT)
&lt;ul>
&lt;li>其中 PREROUTING 与 POSTROUTING 是流量经过物理网卡设备时做 nat 的地方&lt;/li>
&lt;li>其中 INPUT 与 OUTPUT 则是主机内部从网络栈直接下来的流量做 nat 的地方。e.g.从主机一个服务发送数据到同一个主机另一个服务的流量&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h3 id="mangle--拆解报文做出修改封装报文">mangle # 拆解报文，做出修改，封装报文&lt;/h3>
&lt;ul>
&lt;li>该类型的链可作用在以下几个 Hook 点上：PREROUTING、INPUT、FORWARD、OUTPUT、POSTROUTING&lt;/li>
&lt;/ul>
&lt;h3 id="raw原始--用于跳过-nat-表以及连接追踪机制ip_conntrack的处理详见-连接跟踪系统docsit学习笔记1操作系统2kernel内核8network20-管理linux20-网络流量控制connnection20tracking连接跟踪md-tracking连接跟踪md">raw(原始) # 用于跳过 nat 表以及连接追踪机制(ip_conntrack)的处理，详见 [连接跟踪系统](/docs/IT学习笔记/1.操作系统/2.Kernel(内核)/8.Network%20 管理/Linux%20 网络流量控制/Connnection%20Tracking(连接跟踪).md Tracking(连接跟踪).md)。&lt;/h3>
&lt;ul>
&lt;li>该类型的链可作用在以下几个 Hook 点上：PREROUTING、OUTPUT&lt;/li>
&lt;/ul>
&lt;p>整个表只有这一个作用，且仅有一个 target 就是 NOTRACK。具有最高优先级，所有流量先在两个 Hook 的 raw 功能上进行检查。一旦在 raw 上配置了规则，则 raw 表处理完成后，跳过 nat 表和 ip_conntrack 处理，i.e.不再做地址转换和数据包的链接跟踪处理，不把匹配到的数据包保存在“链接跟踪表”中。常用于那些不需要做 nat 的情况下以提高性能。e.g.大量访问的 web 服务器，可以让 80 端口不再让 iptables 做数据包的链接跟踪处理 ，以提高用户的访问速度。不过该功能不影响其余表的连接追踪追踪功能的正常使用，依然会有记录写到连接追踪文件中去&lt;/p>
&lt;ol>
&lt;li>该功能的起源：iptables 表有大小的上限，如果每个数据包进来都要进行检查，会非常影响性能，可以对那些不用进行 nat 功能的数据进行放弃后面的检查，i.e.可以在 raw 配置然后直接让这些数据包跳过后面的表对该数据包的处理&lt;/li>
&lt;/ol>
&lt;p>Note：四表的优先级从高到低依次为：raw-mangle-nat-filter，i.e.数据到达某个 Hook 上，则会优先使用优先级最高类型的链来处理数据包。其实，iptables 表的作用更像是用来划分优先级的。&lt;/p>
&lt;h2 id="iptables-处理链上规则的顺序以及规范">iptables 处理链上规则的顺序以及规范&lt;/h2>
&lt;p>注意：每个数据包在 CHAIN 中匹配到适用于自己的规则之后，则直接进入下一个 CHAIN，而不会遍历 CHAIN 中每条规则去挨个匹配适用于自己的规则。比如下面两种情况&lt;/p>
&lt;p>INPUT 链默认 DROP，匹配第一条：目的端口是 9090 的数据 DROP，然后不再检查下一项，那么 9090 无法访问&lt;/p>
&lt;pre>&lt;code>-P INPUT DROP
-A INPUT -p tcp -m tcp --dport 9090 -j DROP
-A INPUT -p tcp -m tcp --dport 9090 -j ACCEPT
&lt;/code>&lt;/pre>
&lt;p>INPUT 链默认 DROP，匹配第一条目的端口是 9090 的数据 ACCEPT，然后不再检查下一条规则，则 9090 可以访问&lt;/p>
&lt;pre>&lt;code>-P INPUT DROP
-A INPUT -p tcp -m tcp --dport 9090 -j ACCEPT
-A INPUT -p tcp -m tcp --dport 9090 -j DROP
&lt;/code>&lt;/pre>
&lt;h1 id="iptables-关联文件与配置">iptables 关联文件与配置&lt;/h1>
&lt;p>/etc/sysconfig/iptables # 该文件存放用户定义的规则信息，每次重启 iptabels 后，都会读取该配置文件信息并应用到系统中
/etc/sysconfig/iptables-conf # 该文件存放 iptables 工具的具体配置信息
/run/xtables.lock # 该文件在 iptables 程序启动时被使用，以获取排他锁&lt;/p>
&lt;ul>
&lt;li>可以通过 &lt;code>XTABLES_LOCKFILE&lt;/code> 环境变量修改 iptables 需要使用 xtalbes.lock 文件的路径&lt;/li>
&lt;/ul>
&lt;h1 id="iptables-命令行工具详解">iptables 命令行工具详解&lt;/h1>
&lt;h2 id="syntax语法">Syntax(语法)&lt;/h2>
&lt;p>&lt;strong>iptables [-t TABLE] [OPTIONS] SubCOMMAND CHAIN [RuleSpecifitcation]&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>subCommand # 指对命令进行什么操作，CHAIN 指定要执行操作的链&lt;/li>
&lt;li>RuleSpecifitcation=MATCHES TARGET # 由两部分组成 [MATCHES&amp;hellip;] 和 [TARGET]
&lt;ul>
&lt;li>matches 由一个多个参数组成。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h3 id="options">OPTIONS&lt;/h3>
&lt;ul>
&lt;li>&lt;strong>-t TALBLE&lt;/strong> # 指定 iptables 命令要对 TABLE 这个表进行操作，默认 filter 表&lt;/li>
&lt;li>&lt;strong>-n&lt;/strong> # 不显示域名，直接显示 IP&lt;/li>
&lt;li>&lt;strong>&amp;ndash;line-numbers&lt;/strong> # 显示每个 chain 中的行号&lt;/li>
&lt;li>&lt;strong>-v&lt;/strong> # 显示更详细的信息，vv 更详细，vvv 再详细一些
&lt;ul>
&lt;li>pkts #报文数&lt;/li>
&lt;li>bytes #字节数&lt;/li>
&lt;li>target #&lt;/li>
&lt;li>prot #&lt;/li>
&lt;li>in/out #显示要限制的具体网卡，*为所有&lt;/li>
&lt;li>source/destination #&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>-S&lt;/strong> # 以人类方便阅读的方式打印出来 iptables 规则&lt;/li>
&lt;/ul>
&lt;h3 id="subcommand">SubCOMMAND&lt;/h3>
&lt;ul>
&lt;li>增
&lt;ul>
&lt;li>&lt;strong>-I &lt;!-- raw HTML omitted --> [RuleNum] &lt;!-- raw HTML omitted -->&lt;/strong> # 在规则链开头加入规则详情，也可以指定添加到指定的规则号&lt;/li>
&lt;li>&lt;strong>-A &lt;!-- raw HTML omitted --> &lt;!-- raw HTML omitted -->&lt;/strong> # 在规则连末尾加入规则详情&lt;/li>
&lt;li>&lt;strong>-N ChainName&lt;/strong> # 创建名为 ChainName 的自定义规则链&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>删
&lt;ul>
&lt;li>&lt;strong>-F [CHAIN [RuleNum]]&lt;/strong> # 删除所有 chain 下的所有规则，也可删除指定 chain 下的指定的规则&lt;/li>
&lt;li>&lt;strong>-D &lt;!-- raw HTML omitted --> &lt;!-- raw HTML omitted -->&lt;/strong> # 删除一个 chain 中规则，RULE 可以是该 chain 中的行号，也可以是规则具体配置&lt;/li>
&lt;li>&lt;strong>-X [CHAIN]&lt;/strong> # 删除用户自定义的空的 chain&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>改
&lt;ul>
&lt;li>&lt;strong>-P &lt;!-- raw HTML omitted --> &lt;!-- raw HTML omitted -->&lt;/strong> # 设置指定的规则链(CHAIN)的默认策略为指定目标(Targe)&lt;/li>
&lt;li>&lt;strong>-E &lt;!-- raw HTML omitted --> &amp;lt;NewChainName&lt;/strong>&amp;gt;# 重命名自定义 chain，引用计数不为 0 的自定义 chain，无法改名也无法删除&lt;/li>
&lt;li>&lt;strong>-R&lt;/strong> # 替换指定链上的指定规则&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>查
&lt;ul>
&lt;li>&lt;strong>-L [CHAIN [RuleNum]]&lt;/strong> # 列出防火墙所有 CHAIN 的配置，可以列出指定的 CHAIN 的配置&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h3 id="matches">MATCHES&lt;/h3>
&lt;p>一个或多个 parameters(参数) 构成 MATCHES # i.e.Match(匹配)相关的 OPTIONS。在每个 parameters 之前添加!，即可将该匹配取反(比如：不加叹号是匹配某个 IP 地址，加了叹号表示除了这个地址外都匹配)&lt;/p>
&lt;p>MATCHES=[-m] MatchName [Per-Match-Options]&lt;/p>
&lt;p>基本匹配规则&lt;/p>
&lt;ul>
&lt;li>&lt;strong>-s IP/MASK&lt;/strong> # 指定规则中要匹配的来源地址的 IP/MASK&lt;/li>
&lt;li>&lt;strong>-d IP/MASK&lt;/strong> # 指定规则中要匹配的目标地址的 IP/MASK&lt;/li>
&lt;li>&lt;strong>-i 网卡名称&lt;/strong> # 指定数据流入规则中要匹配的网卡，仅用于 PREROUTING、INPUT、FORWARD 链&lt;/li>
&lt;li>&lt;strong>-o 网卡名称&lt;/strong> # 指定数据流出规则中要匹配的网卡，仅用于 FORWARD、OUTPUT、POSTROUTING 链&lt;/li>
&lt;li>&lt;strong>-p tcp|udp|icmp&lt;/strong> # 指定规则中要匹配的协议，即 ip 首部中的 protocols 所标识的协议&lt;/li>
&lt;/ul>
&lt;p>扩展匹配规则(ExtendedMatch)&lt;/p>
&lt;p>使用格式：-m ExtendedMatchName &amp;ndash;MatchRule&lt;/p>
&lt;p>通用的扩展匹配，指定具体的扩展匹配名以及该扩展匹配的匹配规则&lt;/p>
&lt;ul>
&lt;li>&lt;strong>-m conntrack &amp;ndash;ctstate CTState1[,CTState2&amp;hellip;]&lt;/strong> # 匹配指定的名为 CTState 的[连接追踪](/docs/IT学习笔记/1.操作系统/2.Kernel(内核)/8.Network%20 管理/Linux%20 网络流量控制/Netfilter%20 流量控制系统/Connection%20Tracking(连接跟踪)机制.md Tracking(连接跟踪)机制.md)状态。CTState 为 conntrack State，可用的状态有{INVALID|ESTABLISHED|NEW|RELATED|UNTRACKED|SNAT|DNAT}
&lt;ul>
&lt;li>-m state &amp;ndash;state STATE1[,STATE2,&amp;hellip;.] # conntrack 的老式用法，慢慢会被淘汰&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>-m set &amp;ndash;match-set SetName {src|dst}..&lt;/strong>. #匹配指定的{源|目标}IP 是名为 SetName 的 ipset 集合
&lt;ul>
&lt;li>其中 FLAG 是逗号分隔的 src 和 dst 规范列表，其中不能超过六个。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>-&lt;strong>m iprange {&amp;ndash;src-range|&amp;ndash;dst-range} IP1-IP2&lt;/strong> # 匹配的指定的{源|目标}IP 范围&lt;/li>
&lt;li>&lt;strong>-m sting &amp;ndash;MatchRule&lt;/strong> # 指明要匹配的字符串，用于检查报文中出现的字符串(e.g.某个网页出现某个字符串则拒绝)
&lt;ul>
&lt;li>OPTIONS
&lt;ul>
&lt;li>&lt;strong>&amp;ndash;algo {bm|kmp}&lt;/strong> # 指明使用哪个搜索算法&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>基于基本匹配的扩展匹配&lt;/p>
&lt;ul>
&lt;li>-p tcp 的扩展匹配
&lt;ul>
&lt;li>&lt;strong>-m [tcp] &amp;ndash;dport NUM&lt;/strong> # 指定规则中要匹配的目标端口号&lt;/li>
&lt;li>&lt;strong>-m [tcp] &amp;ndash;sport NUM&lt;/strong> # 指定规则中要匹配的来源端口号&lt;/li>
&lt;li>&lt;strong>-m multiport {&amp;ndash;dport|&amp;ndash;sport} NUM&lt;/strong> # 让 tcp 匹配多个端口，可以是目标端口(dport)或者源端口(sport)&lt;/li>
&lt;li>&lt;strong>-m [tcp] &amp;ndash;tcp-flags LIST1 LIST2&lt;/strong> # 检查 LIST1 所指明的所有标志位，且这其中 LIST2 所表示出的所有标志位必须为 1，而余下的必须为 0,；没有 LIST1 中指明的，不做检查(e.g.&amp;ndash;tcp-flags SYN,ACK,FIN,RST SYN)。LIST 包括“SYN ACK FIN RST URG PSH ALL NONE”&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>-p udp 的扩展匹配：&amp;ndash;dport、&amp;ndash;sport 与 tcp 的扩展匹配用法一样&lt;/li>
&lt;li>-p icmp 的扩展匹配
&lt;ul>
&lt;li>&lt;strong>-m [icmp] &amp;ndash;icmp-type TYPE&lt;/strong> # 指定 icmp 的类型，具体类型可以搜 icmp type 获得，可以是数字&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h3 id="target">TARGET&lt;/h3>
&lt;p>&lt;strong>TARGET =-j|g TARGET [Per-Target-Options]&lt;/strong> # 指定规则中的目标(target)是什么。即“如果数据包匹配上规则之后应该做什么”。如果目标是自定义链，则指明具体的自定义 Chain 的名称。TARGET 都有哪些详见 Netfilter 流量控制系统。下面是各种 TARGET 的类型：&lt;/p>
&lt;ul>
&lt;li>ACCEPT # 允许流量通过&lt;/li>
&lt;li>REJECT # 拒绝流量通过
&lt;ul>
&lt;li>OPTIONS
&lt;ul>
&lt;li>--reject-with icmp-host-prohibited # 通过 icmp 协议显示给客户机一条消息:主机拒绝(icmp-host-prohibited)&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>DROP # 丢弃，不响应，发送方无法判断是被拒绝&lt;/li>
&lt;li>RETURN # 返回调用链&lt;/li>
&lt;li>MARK # 做防火墙标记&lt;/li>
&lt;li>用于 nat 表的 target
&lt;ul>
&lt;li>DNAT|SNAT # {目的|源}地址转换&lt;/li>
&lt;li>REDIRECT # 端口重定向&lt;/li>
&lt;li>MASQUERADE #地址伪装类似于 SNAT，但是不用指明要转换的地址，而是自动选择要转换的地址，用于外部地址不固定的情况&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>用于 raw 表的 target
&lt;ul>
&lt;li>NOTRACK # raw 表专用的 target，用于对匹配规则进行 notrack(不跟踪)处理&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>LOG #记录日志信息&lt;/li>
&lt;li>引用自定义链 # 直接使用“-j|-g 自定义链的名称”即可，让基本 5 个 Chain 上匹配成功的数据包继续执行自定义链上的规则。&lt;/li>
&lt;/ul>
&lt;h2 id="example">EXAMPLE&lt;/h2>
&lt;p>注意：在使用 iptables 命令的时候，为了防止配置问题导致网络不通，可以先设置一个定时任务来修改 iptables 规则或者 iptables XX &amp;amp;&amp;amp; sleep 5 &amp;amp;&amp;amp; iptables -P INPUT ACCEPT &amp;amp;&amp;amp; iptables -P OUTPUT ACCEPT&lt;/p>
&lt;h3 id="fileter-表的配置">Fileter 表的配置&lt;/h3>
&lt;h4 id="input-默认为-drop-情况下">INPUT 默认为 DROP 情况下&lt;/h4>
&lt;ul>
&lt;li>iptables -P INPUT DROP&lt;/li>
&lt;/ul>
&lt;p>给 INPUT 链添加一条接受 192.168.19.64/27 这个网段数据包的规则&lt;/p>
&lt;ul>
&lt;li>iptables -I INPUT -s 192.168.19.64/27 -j ACCEPT&lt;/li>
&lt;/ul>
&lt;p>允许指定的网段访问本机的 22 号端口&lt;/p>
&lt;ul>
&lt;li>iptables -A INPUT -s 192.168.1.0/24 -p tcp -m tcp &amp;ndash;dport 22 -j ACCEPT&lt;/li>
&lt;/ul>
&lt;p>允许所有机器进入本机的 1000 到 1100 号端口&lt;/p>
&lt;ul>
&lt;li>iptables -A INPUT -p tcp -m tcp &amp;ndash;dport 1000:1100 -j ACCEPT&lt;/li>
&lt;/ul>
&lt;p>允许源地址是 10.10.100.4 到 10.10.100.10 这 7 个 ip 的流量进入本机&lt;/p>
&lt;ul>
&lt;li>iptables -A INPUT -m iprange &amp;ndash;src-range 10.10.100.4-10.10.100.10 -j ACCEPT&lt;/li>
&lt;/ul>
&lt;p>允许源地址是 10.10.100.4 和 10.10.100.8 且目的端口是 1935 和 4000 的流量进入本机&lt;/p>
&lt;ul>
&lt;li>iptables -A INPUT -m iprange &amp;ndash;src-range 10.10.100.4,10.10.100.8 -p tcp -m multiport &amp;ndash;dports 1935,4000 -j ACCEPT&lt;/li>
&lt;/ul>
&lt;p>允许源地址是 ipset(名为 cdn2) 中的所有 IP，且目标端口为 80 的所有数据包通过&lt;/p>
&lt;ul>
&lt;li>iptables -A INPUT -p tcp -m set &amp;ndash;match-set cdn2 src &amp;ndash;dports 80 -j ACCEPT&lt;/li>
&lt;/ul>
&lt;p>允许源地址是 ipset(名为 cdn1) 中的所有 IP 通过&lt;/p>
&lt;ul>
&lt;li>iptables -A INPUT -m set &amp;ndash;match-set cdn1 src -j ACCEPT&lt;/li>
&lt;/ul>
&lt;h4 id="input-默认为-accept-情况下">INPUT 默认为 ACCEPT 情况下&lt;/h4>
&lt;ul>
&lt;li>iptables -P INPUT DROP&lt;/li>
&lt;/ul>
&lt;p>只放开部分 IP 的 22 端口&lt;/p>
&lt;blockquote>
&lt;p>注意：下面的顺序不可变，由于是顺序执行，指定源地址的先允许之后就不会再拒绝了，凡是没有允许过的源 IP，都会被 DROP&lt;/p>
&lt;/blockquote>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>-P INPUT ACCEPT
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>-P FORWARD ACCEPT
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>-P OUTPUT ACCEPT
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>-A INPUT -s 116.63.160.74/32 -p tcp -m tcp --dport &lt;span style="color:#ae81ff">22&lt;/span> -j ACCEPT
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>-A INPUT -s 122.9.154.106/32 -p tcp -m tcp --dport &lt;span style="color:#ae81ff">22&lt;/span> -j ACCEPT
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>-A INPUT -p tcp -m tcp --dport &lt;span style="color:#ae81ff">22&lt;/span> -j DROP
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>所有 ping 本机的数据包全部丢弃，禁 ping。给 INPUT 链添加一条禁止 icmp 协议的规则&lt;/p>
&lt;ul>
&lt;li>iptables -I INPUT -p icmp -j DROP&lt;/li>
&lt;/ul>
&lt;h4 id="其他">其他&lt;/h4>
&lt;p>显示 INPUT 链中的所有规则，并显示规则行号&lt;/p>
&lt;ul>
&lt;li>iptables -L INPUT &amp;ndash;line-numbers&lt;/li>
&lt;/ul>
&lt;p>删除 INPUT 链中的第 11 条规则&lt;/p>
&lt;ul>
&lt;li>iptables -D INPUT 11&lt;/li>
&lt;/ul>
&lt;p>实现我可以 ping 别人，别人不能 ping 我的方法：&lt;/p>
&lt;ul>
&lt;li>iptables -A INPUT -p icmp &amp;ndash;icmp-type 8 -s 0/0 -j DROP #默认 INPUT 链的策略为 ACCEPT 的时候用&lt;/li>
&lt;li>iptables -A INPUT -p icmp &amp;ndash;icmp-type 0 -s 0/0 -j ACCEPT #默认 INPUT 链的策略为 DROP 的时候用&lt;/li>
&lt;li>iptables -A OUTPUT -p icmp &amp;ndash;icmp-type 0 -s LOCALIP -j DROP #默认 OUTPUT 链的策略为 ACCEPT 的时候用，注意把 Localip 改为本机 IP&lt;/li>
&lt;li>iptables -A OUTPUT -p icmp &amp;ndash;icmp-type 8 -s LOCALIP -j ACCEPT #默认 OUTPUT 链的策略为 DROP 的时候用，注意把 Localip 改为本机 IP&lt;/li>
&lt;/ul>
&lt;h3 id="nat-表的配置">NAT 表的配置&lt;/h3>
&lt;ul>
&lt;li>凡是基于 tcp 协议访问本机 80 端口，且目的地址是 110.119.120.1 的数据包。全部把目的地址转变为 192.168.20.2，且目的端口转换为 8080。
&lt;ul>
&lt;li>iptables -t nat -A PREROUTING -d 110.119.120.1 -p tcp &amp;ndash;dport 80 -j DNAT &amp;ndash;to-destination 192.168.20.2:8080&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>将源地址网段是 192.168.122.0/24 并且目的地址网段不是 192.168.122.0/24 的全部转换成 123.213.1.5 这个地址。常用于公司内使用私网 IP 的设备访问互联网使用
&lt;ul>
&lt;li>iptables -t nat -A POSTROUTING -s 192.168.122.0/24 ! -d 192.168.122.0/24 -j SNAT &amp;ndash;to-source 123.213.1.5&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>将所有到达 eth0 网卡 25 端口的流量转发到 2525 端口。也叫端口转发
&lt;ul>
&lt;li>iptables -t nat -A PREROUTING -i eth0 -p tcp &amp;ndash;dport 25 -j REDIRECT &amp;ndash;to-port 2525&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h3 id="raw-表配置">RAW 表配置&lt;/h3>
&lt;ul>
&lt;li>所有来自 10.0.9.0/24 网段的数据包，都不跟踪。
&lt;ul>
&lt;li>iptables -t raw -A PREROUTING -s 10.0.9.0/24 -j NOTRACK&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h2 id="iptables-save--将-iptables-规则转储到标准输出">iptables-save # 将 iptables 规则转储到标准输出&lt;/h2>
&lt;p>该命令输出的内容更容易被人类阅读，可以用重定向把内容保存到文件中&lt;/p>
&lt;p>该命令显示出的信息说明
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/fadrg5/1616165483878-a0be9032-9c98-4971-922e-592c61529d86.jpeg" alt="">
&lt;strong>Syntax(语法)&lt;/strong>
iptables-save [-M,&amp;ndash;modprobe modprobe] [-c] [-t table]&lt;/p>
&lt;p>&lt;strong>EXAMPLE&lt;/strong>&lt;/p>
&lt;ol>
&lt;li>iptables-save &amp;gt; /etc/sysconfig/iptables.rules&lt;/li>
&lt;/ol>
&lt;h2 id="iptables-restore-从标准输入恢复-iptables-规则可以视同重定向通过文件来读取到标准输入">iptables-restore #从标准输入恢复 iptables 规则，可以视同重定向通过文件来读取到标准输入&lt;/h2>
&lt;p>&lt;strong>EXAMPLE&lt;/strong>&lt;/p>
&lt;ol>
&lt;li>iptables-restore &amp;lt; /etc/sysconfig/iptables.rules&lt;/li>
&lt;/ol>
&lt;h1 id="ipset--ip-集合的管理工具">ipset # IP 集合的管理工具&lt;/h1>
&lt;p>ipset 是 iptables 的一个协助工具。可以通过 ipset 设置一组 IP 并对这一组 IP 统一命名，然后在 iptables 里的匹配规则里通过名字直接引用该组 IP，并对这组 IP 进行流量控制。注意：由于是 iptables 规则引用，所以我直接修改 ipset 集合里的 IP，并不用重启 iptables 服务，就可以直接生效。这类似于域名解析，我的机器指定访问 baidu.com，至于百度公司他们怎么更改 IP 与域名绑定的关系，作为用户都不用更更改 baidu.com 这个域名。&lt;/p>
&lt;h2 id="ipset-options-command-command-options">ipset [OPTIONS] COMMAND [COMMAND-OPTIONS]&lt;/h2>
&lt;p>COMMANDS：Note：ENTRY 指的就是 ip 地址&lt;/p>
&lt;ol>
&lt;li>create SETNAME TYPENAME [type-specific-options] #创建一个新的集合。Create a new set&lt;/li>
&lt;li>add SETNAME ENTRY # 向指定集合中添加条目。i.e.添加 ip。Add entry to the named set&lt;/li>
&lt;li>del SETNAME ENTRY # 从指定集合中删除条目 Delete entry from the named set&lt;/li>
&lt;li>test SETNAME ENTRY # 测试指定集合中是否包含该条目 Test entry in the named set&lt;/li>
&lt;li>destroy [SETNAME] # 摧毁全部或者指定的集合 Destroy a named set or all sets&lt;/li>
&lt;li>list [SETNAME] # 列出全部或者指定集合中的条目 List the entries of a named set or all sets&lt;/li>
&lt;li>save [SETNAME] # 将指定的集合或者所有集合保存到标准输出&lt;/li>
&lt;li>restore # 还原保存的 ipset 信息&lt;/li>
&lt;li>flush [SETNAME] # 删除全部或者指定集合中的所有条目 Flush a named set or all sets&lt;/li>
&lt;li>rename FROM-SETNAME TO-SETNAME # Rename two sets&lt;/li>
&lt;li>swap FROM-SETNAME TO-SETNAME # 交换两个集合中的内容 Swap the contect of two existing sets&lt;/li>
&lt;/ol>
&lt;p>OPTIONS&lt;/p>
&lt;ol>
&lt;li>&lt;strong>-exist&lt;/strong> # 在 create 已经存在的 ipset、add 已经存在的 entry、del 不存在的 entry 时忽略错误。&lt;/li>
&lt;li>&lt;strong>-f&lt;/strong> # 在使用 save 或者 restore 命令时，可以指定文件，而不是从标准输出来保存或者还原 ipset 信息&lt;/li>
&lt;/ol>
&lt;p>{ -exist | -output { plain | save | xml } | -quiet | -resolve | -sorted | -name | -terse | -file filename }&lt;/p>
&lt;p>EXAMPLE&lt;/p>
&lt;ol>
&lt;li>ipset list #列出 ipset 所设置的所有 IP 集合&lt;/li>
&lt;li>ipset create lichenhao hash:net #创建一个 hash:net 类型的名为 lichenhao 的 ipset&lt;/li>
&lt;li>ipset add lichenhao 1.1.1.0/24 #将 1.1.1.0/24 网段添加到名为 lichenhao 的 ipset 中&lt;/li>
&lt;li>ipset flush #清空所有 ipset 下的 ip&lt;/li>
&lt;li>ipset restore -f /etc/sysconfig/ipset #从/etc/sysconfig/ipset 还原 ipset 的集合和条目信息&lt;/li>
&lt;/ol>
&lt;p>9、屏蔽 HTTP 服务 Flood×××&lt;/p>
&lt;p>有时会有用户在某个服务，例如 HTTP 80 上发起大量连接请求，此时我们可以启用如下规则：&lt;/p>
&lt;p>iptables -A INPUT -p tcp &amp;ndash;dport 80 -m limit &amp;ndash;limit 100/minute &amp;ndash;limit-burst 200 -j ACCEPT&lt;/p>
&lt;p>上述命令会将连接限制到每分钟 100 个，上限设定为 200。&lt;/p>
&lt;p>11、允许访问回环网卡&lt;/p>
&lt;p>环回访问（127.0.0.1）是比较重要的，建议大家都开放：&lt;/p>
&lt;p>iptables -A INPUT -i lo -j ACCEPT&lt;/p>
&lt;p>iptables -A OUTPUT -o lo -j ACCEPT&lt;/p>
&lt;p>12、屏蔽指定 MAC 地址&lt;/p>
&lt;p>使用如下规则可以屏蔽指定的 MAC 地址：&lt;/p>
&lt;p>iptables -A INPUT -m mac &amp;ndash;mac-source 00:00:00:00:00:00 -j DROP&lt;/p>
&lt;p>13、限制并发连接数&lt;/p>
&lt;p>如果你不希望来自特定端口的过多并发连接，可以使用如下规则：&lt;/p>
&lt;p>iptables -A INPUT -p tcp &amp;ndash;syn &amp;ndash;dport 22 -m connlimit &amp;ndash;connlimit-above 3 -j REJECT&lt;/p>
&lt;p>以上规则限制每客户端不超过 3 个连接。&lt;/p>
&lt;p>17、允许建立相关连接&lt;/p>
&lt;p>随着网络流量的进出分离，要允许建立传入相关连接，可以使用如下规则：&lt;/p>
&lt;p>iptables -A INPUT -m conntrack &amp;ndash;ctstate ESTABLISHED,RELATED -j ACCEPT&lt;/p>
&lt;p>允许建立传出相关连接的规则：&lt;/p>
&lt;p>iptables -A OUTPUT -m conntrack &amp;ndash;ctstate ESTABLISHED -j ACCEPT&lt;/p>
&lt;p>18、丢弃无效数据包&lt;/p>
&lt;p>很多网络 ××× 都会尝试用 ××× 自定义的非法数据包进行尝试，我们可以使用如下命令来丢弃无效数据包：&lt;/p>
&lt;p>iptables -A INPUT -m conntrack &amp;ndash;ctstate INVALID -j DROP&lt;/p>
&lt;p>19、IPtables 屏蔽邮件发送规则&lt;/p>
&lt;p>如果你的系统不会用于邮件发送，我们可以在规则中屏蔽 SMTP 传出端口：&lt;/p>
&lt;p>iptables -A OUTPUT -p tcp &amp;ndash;dports 25,465,587 -j REJECT&lt;/p></description></item><item><title>Docs: iptables(Netfilter 的实现)</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2.kernel%E5%86%85%E6%A0%B8/8.network-%E7%AE%A1%E7%90%86/linux-%E7%BD%91%E7%BB%9C%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6/netfilter-%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6%E7%B3%BB%E7%BB%9F/iptablesnetfilter-%E7%9A%84%E5%AE%9E%E7%8E%B0/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2.kernel%E5%86%85%E6%A0%B8/8.network-%E7%AE%A1%E7%90%86/linux-%E7%BD%91%E7%BB%9C%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6/netfilter-%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6%E7%B3%BB%E7%BB%9F/iptablesnetfilter-%E7%9A%84%E5%AE%9E%E7%8E%B0/</guid><description/></item><item><title>Docs: nftables(Netfilter 的实现)</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2.kernel%E5%86%85%E6%A0%B8/8.network-%E7%AE%A1%E7%90%86/linux-%E7%BD%91%E7%BB%9C%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6/netfilter-%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6%E7%B3%BB%E7%BB%9F/nftablesnetfilter-%E7%9A%84%E5%AE%9E%E7%8E%B0/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2.kernel%E5%86%85%E6%A0%B8/8.network-%E7%AE%A1%E7%90%86/linux-%E7%BD%91%E7%BB%9C%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6/netfilter-%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6%E7%B3%BB%E7%BB%9F/nftablesnetfilter-%E7%9A%84%E5%AE%9E%E7%8E%B0/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>官方 wiki：&lt;a href="https://wiki.nftables.org/wiki-nftables/index.php/Main_Page">https://wiki.nftables.org/wiki-nftables/index.php/Main_Page&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>nftables 是一个 netfilter 项目，旨在替换现有的 {ip,ip6,arp,eb}tables 框架，为 {ip,ip6}tables 提供一个新的包过滤框架、一个新的用户空间实用程序（nft）和一个兼容层。它使用现有的钩子、链接跟踪系统、用户空间排队组件和 netfilter 日志子系统。&lt;/p>
&lt;p>nftables 主要由三个组件组成：内核实现、libnl netlink 通信、 nftables 用户空间。 其中内核提供了一个 netlink 配置接口以及运行时规则集评估，libnl 包含了与内核通信的基本函数，用户空间可以通过 nft 和用户进行交互。&lt;/p>
&lt;p>nftables 与 iptables 的区别&lt;/p>
&lt;p>nftables 和 iptables 一样，由 table(表)、chain(链)、rule(规则) 组成。nftables 中，表包含链，链包含规则，规则是真正的 action。与 iptables 相比，nftables 主要有以下几个变化：&lt;/p>
&lt;ul>
&lt;li>iptables 规则的布局是基于连续的大块内存的，即数组式布局；而 nftables 的规则采用链式布局。其实就是数组和链表的区别&lt;/li>
&lt;li>iptables 大部分工作在内核态完成，如果要添加新功能，只能重新编译内核；而 nftables 的大部分工作是在用户态完成的，添加新功能很 easy，不需要改内核。&lt;/li>
&lt;li>iptables 有内置的链，即使你只需要一条链，其他的链也会跟着注册；而 nftables 不存在内置的链，你可以按需注册。由于 iptables 内置了一个数据包计数器，所以即使这些内置的链是空的，也会带来性能损耗。&lt;/li>
&lt;li>简化了 IPv4/IPv6 双栈管理&lt;/li>
&lt;li>原生支持集合、字典和映射&lt;/li>
&lt;/ul>
&lt;p>nftables 没有任何默认规则，如果关闭了 firewalld 服务，则命令 nft list ruleset 输出结果为空。意思就是没有任何内置链或者表 2.&lt;/p>
&lt;h2 id="nftables-table-表-与-nftables-family-簇">nftables table 表 与 nftables family 簇&lt;/h2>
&lt;p>nftables 没有内置表，表的数量与名称由用户决定。&lt;/p>
&lt;p>family(簇) 是 nftables 技术引用的新概念。一共有 6 种簇。不同的 family 可以处理不同 Hook 上的数据包。&lt;/p>
&lt;p>Note：&lt;/p>
&lt;ol>
&lt;li>&lt;code>簇&lt;/code> 可以当做 &lt;code>类型&lt;/code> 来理解，比如建立一个名为 test 的表，该表的簇为 inet(i.e.表的类型是 inet)。&lt;/li>
&lt;li>所以每个表应且只应指定一个簇，且当表中的链被指定类型时，只能指定该簇下可以处理的链类型，详情见本文《nftables chain 链》章节&lt;/li>
&lt;/ol>
&lt;p>nftables 中一同以下几种 family：&lt;/p>
&lt;ol>
&lt;li>ip #IPv4 地址簇。对应 iptables 中 iptables 命令行工具所实现的效果。默认簇，nft 命令的所有操作如果不指定具体的 family，则默认对 ip 簇进行操作
&lt;ol>
&lt;li>可处理流量的 Hook：与 inet 簇相同&lt;/li>
&lt;/ol>
&lt;/li>
&lt;li>ip6 #IPv6 地址簇。对应 iptables 中 ip6tables 命令行工具所实现的效果
&lt;ol>
&lt;li>可处理流量的 Hook：与 inet 簇相同&lt;/li>
&lt;/ol>
&lt;/li>
&lt;li>inet #Internet (IPv4/IPv6)地址簇。对应 iptables 中 iptables 和 ip6tables 命令行工具所实现的效果
&lt;ol>
&lt;li>可处理流量的的 Hook：prerouting、input、forward、output、postrouting。ip 与 ip6 簇与 inet 簇所包含的 Hook 相同&lt;/li>
&lt;/ol>
&lt;/li>
&lt;li>arp #ARP 地址簇，处理 IPv4 ARP 包。对应 iptables 中 arptables 命令行工具所实现的效果
&lt;ol>
&lt;li>可处理流量的 Hook：input、output。&lt;/li>
&lt;/ol>
&lt;/li>
&lt;li>bridge #桥地址簇。处理通过桥设备的数据包对应 iptables 中 ebtables 命令行工具所实现的效果
&lt;ol>
&lt;li>可处理流量的 Hook：与 inet 簇相同&lt;/li>
&lt;/ol>
&lt;/li>
&lt;li>netdev #Netdev address family, handling packets from ingress.
&lt;ol>
&lt;li>可处理流量的 Hook：ingress&lt;/li>
&lt;/ol>
&lt;/li>
&lt;/ol>
&lt;p>基本效果示例如下：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">[&lt;/span>root@centos8 ~&lt;span style="color:#f92672">]&lt;/span>&lt;span style="color:#75715e"># nft add table test # 创建名为test的表，簇为默认的ip簇&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">[&lt;/span>root@centos8 ~&lt;span style="color:#f92672">]&lt;/span>&lt;span style="color:#75715e"># nft list ruleset # 列出所有规则&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>table ip test &lt;span style="color:#f92672">{&lt;/span> &lt;span style="color:#75715e"># 仅有一个名为test的表，簇为ip，没有任何规则&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">[&lt;/span>root@centos8 ~&lt;span style="color:#f92672">]&lt;/span>&lt;span style="color:#75715e"># nft add table inet test # 创建名为test的表，使用inet簇&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">[&lt;/span>root@centos8 ~&lt;span style="color:#f92672">]&lt;/span>&lt;span style="color:#75715e"># nft list ruleset&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>table ip test &lt;span style="color:#f92672">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>table inet test &lt;span style="color:#f92672">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="nftables-chain链">nftables chain(链)&lt;/h2>
&lt;p>在 nftables 中，链是用来保存规则的。链在逻辑上被分为下述三种类型：&lt;/p>
&lt;ol>
&lt;li>filter 类型的链 #用于过滤数据包所用
&lt;ol>
&lt;li>允许定义在哪些 family 下：all family&lt;/li>
&lt;li>链中的规则会处理这些 Hook 点的数据包：all Hook&lt;/li>
&lt;/ol>
&lt;/li>
&lt;li>nat 类型的链 #用于进行地址转换
&lt;ol>
&lt;li>允许定义在哪些 family 下：ip、ip6&lt;/li>
&lt;li>链中的规则会处理这些 Hook 点的数据包：prerouting、input、output、postrouting&lt;/li>
&lt;/ol>
&lt;/li>
&lt;li>route 类型的链
&lt;ol>
&lt;li>允许定义在哪些 family 下：ip、ip6&lt;/li>
&lt;li>链中的规则会处理这些 Hook 点的数据包：output&lt;/li>
&lt;/ol>
&lt;/li>
&lt;/ol>
&lt;p>在创建 nftables 中的链时，通常有两种叫法，没有类型的叫常规链，含有类型的叫基本链：&lt;/p>
&lt;p>常规链(也叫自定义链) : 不需要指定钩子类型和优先级，可以用来做链与链之间的跳转，从逻辑上对规则进行分类。&lt;/p>
&lt;p>基本链 : 数据包的入口点，需要指定该链的基本信息(类型、作用的 Hook 点、优先级、默认策略等)才可以让链中的规则生效(在链管理命令的 {} 中添加链信息)。因为链中包含一条一条的规则，所以一个可以正常处理流量的链，需要指定其类型来区分该链上的规则干什么用的，还需要指定 Hook 来指明数据包到哪个 Hook 了来使用这个规则，还需要配置优先级来处理相同类型的规则，该规则应该先执行还是后执行。&lt;/p>
&lt;h2 id="nftables-rule规则">nftables rule(规则)&lt;/h2>
&lt;p>nftables 中的规则标识符有两种，一种 index，一种 handle&lt;/p>
&lt;p>&lt;strong>index #规则的索引。每条规则在其链中，从 0 开始计数(每条链中的规则，第一条规则的 index 为 0，第二条规则的 indext 为 2，依次类推)。&lt;/strong>&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span> chain DOCKER &lt;span style="color:#f92672">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> tcp dport tcpmux accept &lt;span style="color:#75715e"># 规则index为0&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> tcp dport &lt;span style="color:#ae81ff">5&lt;/span> accept &lt;span style="color:#75715e">#规则index为1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> tcp dport &lt;span style="color:#ae81ff">6&lt;/span> accept &lt;span style="color:#75715e">#后续依次类推&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> tcp dport &lt;span style="color:#ae81ff">2&lt;/span> accept
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> tcp dport &lt;span style="color:#ae81ff">3&lt;/span> accept
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> tcp dport afs3-fileserver accept
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;strong>handle #规则的句柄。句柄对于整个 nftalbes 而言，不管添加在哪个链中，第一条规则的句柄为 1，第二条规则句柄为 2。如果规则句柄为 33 号被删除，则新添加的规则的句柄为 34&lt;/strong>&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span> chain DOCKER &lt;span style="color:#f92672">{&lt;/span> &lt;span style="color:#75715e"># handle 4&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> tcp dport tcpmux accept &lt;span style="color:#75715e"># handle 28&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> tcp dport &lt;span style="color:#ae81ff">5&lt;/span> accept &lt;span style="color:#75715e"># handle 32&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> tcp dport &lt;span style="color:#ae81ff">6&lt;/span> accept &lt;span style="color:#75715e"># handle 33&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> tcp dport &lt;span style="color:#ae81ff">2&lt;/span> accept &lt;span style="color:#75715e"># handle 29&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> tcp dport &lt;span style="color:#ae81ff">3&lt;/span> accept &lt;span style="color:#75715e"># handle 30&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> tcp dport afs3-fileserver accept &lt;span style="color:#75715e"># handle 31&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Note：对于每条规则而言，其 index 可以随时改变，当在多个规则中间插入新规则时，新插入规则下面的规则 index 则会改变。而 handle 则不会改变，除非删除后重新添加&lt;/p>
&lt;h2 id="总结">总结：&lt;/h2>
&lt;p>nftables 的结构为：表包含链，链包含规则，这个逻辑是非常清晰明了的。而 iptable 呢，则需要先指定什么类型的表，再添加规则，规则与链则互相存在，让人摸不清关系；其实也可以说，iptables 的表类型，就是 nftables 中的链的类型。&lt;/p>
&lt;h1 id="nftable-配置">Nftable 配置&lt;/h1>
&lt;p>/etc/sysconfig/nftables.conf #CentOS 8 中，nftables.service 的规则被存储在此目录中，其中 include 一些其他的示例规则
/etc/sysconfig/nftables/* #nftables.conf 文件中 include 的文件，都在该目录下&lt;/p>
&lt;p>备份规则：
$ nft list ruleset &amp;gt; /root/nftables.conf&lt;/p>
&lt;h1 id="nftable-的-set集合与-map字典-特性介绍">nftable 的 set(集合)与 map(字典) 特性介绍&lt;/h1>
&lt;p>nftables 的语法原生支持集合，集合可以用来匹配多个 IP 地址、端口号、网卡或其他任何条件。类似于 ipset 的功能。&lt;/p>
&lt;p>集合分为匿名集合与命名集合。&lt;/p>
&lt;h2 id="匿名集合">匿名集合&lt;/h2>
&lt;p>匿名集合比较适合用于未来不需要更改的规则&lt;/p>
&lt;p>例如下面的两个示例，&lt;/p>
&lt;ol>
&lt;li>该规则允许来自源 IP 处于 10.10.10.123 ~ 10.10.10.231 这个区间内的主机的流量通过。
&lt;ol>
&lt;li>nft add rule inet my_table my_filter_chain ip saddr { 10.10.10.123, 10.10.10.231 } accept&lt;/li>
&lt;/ol>
&lt;/li>
&lt;li>该规则允许来自目的端口是 http、nfs、ssh 的流量通过。
&lt;ol>
&lt;li>nft add rule inet my_table my_filter_chain tcp dport { http, nfs, ssh } accept&lt;/li>
&lt;/ol>
&lt;/li>
&lt;/ol>
&lt;p>匿名集合的缺点是，如果需要修改集合中的内容，比如像 ipset 中修改 ip 似的，就得替换规则。如果后面需要频繁修改集合，推荐使用命名集合。&lt;/p>
&lt;h2 id="命令集合">命令集合&lt;/h2>
&lt;p>iptables 可以借助 ipset 来使用集合，而 nftables 中的命名集合就相当于 ipset 的功能。&lt;/p>
&lt;p>命名集合需要使用 nft add set XXXX 命令进行创建，创建时需要指定簇名、表名、以及 set 的属性&lt;/p>
&lt;p>命名集合中包括以下几种属性，其中 type 为必须指定的属性，其余属性可选。&lt;/p>
&lt;ol>
&lt;li>type #集合中所有元素的类型，包括 ipv4_addr(ipv4 地址), ipv6_addr(ipv6 地址), ether_addr(以太网地址), inet_proto(网络协议), inet_service(网络服务), mark(标记类型) 这几类&lt;/li>
&lt;li>flags #集合的标志。包括 constant、interval、timeout 。
&lt;ol>
&lt;li>interval #让集合支持区间模式。默认集合中无法使用这种方式 nft add element inet my_table my_set { 10.20.20.0-10.20.20.255 } 来添加集合 。当给集合添加类型 flag 时，就可以在给集合添加元素时，使用‘区间’的表示方法。因为内核必须提前确认该集合存储的数据类型，以便采用适当的数据结构。&lt;/li>
&lt;/ol>
&lt;/li>
&lt;li>timeout #&lt;/li>
&lt;li>gc-interval #&lt;/li>
&lt;li>elements #&lt;/li>
&lt;li>size #&lt;/li>
&lt;li>policy #&lt;/li>
&lt;li>auto-merge #&lt;/li>
&lt;/ol>
&lt;p>像 ipset 一样，光创建完还没法使用，需要在 iptables 中添加规则引用 ipset 才可以。nftables 的 set 一样，创建完成后，需要在规则中引用，引用集合规则时使用 @ 并跟上集合的名字，即可引用指定的集合(e.g.nft insert rule inet my_table my_filter_chain ip saddr @my_set drop)这条命令即时引用了 my_set 集合中的内容&lt;/p>
&lt;p>级联不同类型&lt;/p>
&lt;p>命名集合也支持对不同类型的元素进行级联，通过级联操作符 . 来分隔。例如，下面的规则可以一次性匹配 IP 地址、协议和端口号。&lt;/p>
&lt;p>$ nft add set inet my_table my_concat_set { type ipv4_addr . inet_proto . inet_service ; }&lt;/p>
&lt;p>$ nft list set inet my_table my_concat_set&lt;/p>
&lt;p>table inet my_table {&lt;/p>
&lt;p>set my_concat_set {&lt;/p>
&lt;p>type ipv4_addr . inet_proto . inet_service&lt;/p>
&lt;pre>&lt;code> }
&lt;/code>&lt;/pre>
&lt;p>}&lt;/p>
&lt;p>向集合中添加元素：&lt;/p>
&lt;p>$ nft add element inet my_table my_concat_set { 10.30.30.30 . tcp . telnet }&lt;/p>
&lt;p>在规则中引用级联类型的集合和之前一样，但需要标明集合中每个元素对应到规则中的哪个位置。&lt;/p>
&lt;p>$ nft add rule inet my_table my_filter_chain ip saddr . meta l4proto . tcp dport @my_concat_set accept&lt;/p>
&lt;p>这就表示如果数据包的源 IP、协议类型、目标端口匹配 10.30.30.30、tcp、telnet 时，nftables 就会允许该数据包通过。&lt;/p>
&lt;p>匿名集合也可以使用级联元素，例如：&lt;/p>
&lt;p>$ nft add rule inet my_table my_filter_chain ip saddr . meta l4proto . udp dport { 10.30.30.30 . udp . bootps } accept&lt;/p>
&lt;p>现在你应该能体会到 nftables 集合的强大之处了吧。&lt;/p>
&lt;p>nftables 级联类型的集合类似于 ipset 的聚合类型，例如 hash:ip,port。&lt;/p>
&lt;h1 id="nft-命令行工具介绍">nft 命令行工具介绍&lt;/h1>
&lt;p>&lt;strong>nft [OPTIONS] [COMMANDS]&lt;/strong>&lt;/p>
&lt;p>COMMANDS 包括：&lt;/p>
&lt;ol>
&lt;li>ruleset #规则集管理命令&lt;/li>
&lt;li>table #表管理命令&lt;/li>
&lt;li>chain #链管理命令&lt;/li>
&lt;li>rule #规则管理命令&lt;/li>
&lt;li>set #集合管理命令&lt;/li>
&lt;li>map #字典管理命令&lt;/li>
&lt;li>NOTE：
&lt;ol>
&lt;li>该 COMMANDS 与后面子命令中的 COMMAND 不同，前者是 nft 命令下的子命令，后者是 nft 命令下子命令的子命令&lt;/li>
&lt;li>nft 子命令默认对 ip 簇进行操作，当指定具体的 FAMILY 时，则对指定的簇进行操作&lt;/li>
&lt;/ol>
&lt;/li>
&lt;/ol>
&lt;p>OPTIONS&lt;/p>
&lt;ol>
&lt;li>-a,&amp;ndash;handle #在使用命令获得输出时，显示每个对象的句柄
&lt;ol>
&lt;li>Note：handle(句柄)在 nftables 中，相当于标识符，nftables 中的每一行内容都有一个 handle。&lt;/li>
&lt;/ol>
&lt;/li>
&lt;li>-e,&amp;ndash;echo #回显已添加、插入或替换的内容&lt;/li>
&lt;li>-f,&amp;ndash;file FILE #从指定的文件 FILE 中读取 netfilter 配置加载到内核中&lt;/li>
&lt;/ol>
&lt;p>EXAMPLE：&lt;/p>
&lt;ol>
&lt;li>nft -f /root/nftables.conf #从 nftables.conf 文件中，将配置规则加载到系统中&lt;/li>
&lt;/ol>
&lt;p>Note：下面子命令中的 FAMILY 如果不指定，则所有命令默认都是对 ip 簇进行操作。&lt;/p>
&lt;h2 id="表管理命令">表管理命令&lt;/h2>
&lt;p>nft COMMAND table [FAMILY] TABLE #FAMILY 指定簇名，TABLE 为表的名称&lt;/p>
&lt;p>nft list tables #列出所有的表，不包含表中的链和规则&lt;/p>
&lt;p>COMMAND&lt;/p>
&lt;ol>
&lt;li>add #添加指定簇下的表。&lt;/li>
&lt;li>create #与 add 命令类似，但是如果表已经存在，则返回错误信息。&lt;/li>
&lt;li>delete #删除指定的表。不管表中是否有内容都一并删除&lt;/li>
&lt;li>flush #清空指定的表下的所有规则，保留链&lt;/li>
&lt;li>list #列出指定的表的所有链，及其链中的规则&lt;/li>
&lt;/ol>
&lt;p>EXAMPLE&lt;/p>
&lt;ol>
&lt;li>nft add table my_table #创建一个 ip 簇的，名为 my_table 的表&lt;/li>
&lt;li>nft add table inet my_table #创建一个 inet 簇的，名为 my_table 的表&lt;/li>
&lt;li>nft list table inet my_table #列出 inet 簇的名为 my_table 的表及其链和规则&lt;/li>
&lt;/ol>
&lt;h2 id="链管理命令">链管理命令&lt;/h2>
&lt;p>nft COMMAND chain [FAMILY] TABLE CHAIN [{ type TYPE hook HOOK [device DEVICE] priority PRIORITY; [policy POLICY;] }] #FAMILY 指定簇名，TABLE 指定表名，CHAIN 指定链名，TYPE 指定该链的类型，HOOK 指定该链作用在哪个 hook 上，DEVICE 指定该链作用在哪个网络设备上，PRIORITY 指定该链的优先级，POLICY 指定该链的策略(i.e.该链的默认策略，accept、drop 等等。)&lt;/p>
&lt;p>nft list chains #列出所有的链&lt;/p>
&lt;p>Note:&lt;/p>
&lt;ul>
&lt;li>在输入命令时，使用反斜线 \ 用来转义分号 ; ，这样 shell 就不会将分号解释为命令的结尾。如果是直接编辑 nftables 的配置文件则不用进行转义&lt;/li>
&lt;li>PRIORITY 采用整数值，可以是负数，值较小的链优先处理。&lt;/li>
&lt;/ul>
&lt;p>COMMAND&lt;/p>
&lt;ol>
&lt;li>add #在指定的表中添加一条链&lt;/li>
&lt;li>create #与 add 命令类似，但是如果链已经存在，则返回错误信息。&lt;/li>
&lt;li>delete #删除指定的链。该链不能包含任何规则，或者被其它规则作为跳转目标，否则删除失败。&lt;/li>
&lt;li>flush #&lt;/li>
&lt;li>list #列出指定表下指定的链，及其链中的规则&lt;/li>
&lt;li>rename #&lt;/li>
&lt;/ol>
&lt;p>EXAMPLE&lt;/p>
&lt;ol>
&lt;li>nft add chain inet my_table my_utility_chain #在 inet 簇的 my_table 表上创建一个名为 my_utility_chain 的常规链，没有任何参数&lt;/li>
&lt;li>nft add chain inet my_table my_filter_chain{type filter hook input priority 0;} #在 inet 簇的 my_table 表上创建一个名为 my_filter_chain 的链，链的类型为 filter，作用在 input 这个 hook 上，优先级为 0&lt;/li>
&lt;li>nft list chain inet my_table my_filter_chain #列出 inet 簇的 my_table 表下的 my_filter_chain 链的信息，包括其所属的表和其包含的规则&lt;/li>
&lt;/ol>
&lt;h2 id="规则管理命令">规则管理命令&lt;/h2>
&lt;p>nft COMMAND rule [FAMILY] TABLE CHAIN [handle HANDLE|index INDEX] STATEMENT&amp;hellip; #FAMILY 指定簇名，HANDLE 和 INDEX 指定规则的句柄值或索引值，STATEMENT 指明该规则的语句&lt;/p>
&lt;p>nft list ruleset [FAMILY] #列出所有规则，包括规则所在的链，链所在的表。i.e.列出 nftables 中的所有信息。可以指定 FAMILY 来列出指定簇的规则信息&lt;/p>
&lt;p>[FAMILY] #清除所有规则，包括表。i.e.清空 nftables 中所有信息。可以指定 FAMILY 来清空指定簇的规则信息&lt;/p>
&lt;p>COMMAND&lt;/p>
&lt;ol>
&lt;li>add #将规则添加到链的末尾，或者指定规则的 handle 或 index 之后&lt;/li>
&lt;li>insert #将规则添加到链的开头，或者指定规则的 handle 或 index 之前&lt;/li>
&lt;li>delete #删除指定的规则。Note:只能通过 handle 删除&lt;/li>
&lt;li>replace #替换指定规则为新规则&lt;/li>
&lt;/ol>
&lt;p>EXAMPLE&lt;/p>
&lt;ol>
&lt;li>nft add rule inet my_table my_filter_chain tcp dport ssh accept #在 inet 簇的 my_table 表中的 my_filter_chain 链中添加一条规则，目标端口是 ssh 服务的数据都接受&lt;/li>
&lt;li>nft add rule inet my_table my_filter_chain ip saddr @my_set drop #创建规则时引用 my_set 集合&lt;/li>
&lt;/ol>
&lt;h2 id="集合管理命令">集合管理命令&lt;/h2>
&lt;p>COMMAND set [FAMILY] table set { type TYPE; [flags FLAGS;] [timeout TIMEOUT ;] [gc-interval GC-INTERVAL ;] [elements = { ELEMENT[,&amp;hellip;] } ;] [size SIZE;] [policy POLICY;] [auto-merge AUTO-MERGE ;] } #各字段解释详见上文 nftables 的 set 与 map 特性介绍&lt;/p>
&lt;p>list sets #列出所有结合&lt;/p>
&lt;p>{add | delete} element [family] table set { element[,&amp;hellip;] } #在指定集合中添加或删除元素&lt;/p>
&lt;p>Note:&lt;/p>
&lt;ul>
&lt;li>在输入命令时，使用反斜线 \ 用来转义分号 ; ，这样 shell 就不会将分号解释为命令的结尾。如果是直接编辑 nftables 的配置文件则不用进行转义&lt;/li>
&lt;/ul>
&lt;p>COMMAND&lt;/p>
&lt;ol>
&lt;li>add&lt;/li>
&lt;li>delete #通过 handle 删除指定的集合&lt;/li>
&lt;li>flush #&lt;/li>
&lt;li>list #&lt;/li>
&lt;/ol>
&lt;p>EXAMPLE&lt;/p>
&lt;ol>
&lt;li>nft add set inet my_table my_set {type ipv4_addr; } #在 inet 簇的 my_table 表中创建一个名为 my_set 的集合，集合的类型为 ipv4_addr&lt;/li>
&lt;li>nft add set my_table my_set {type ipv4_addr; flags interval;} #在默认 ip 簇的 my_table 表中创建一个名为 my_set 的集合，集合类型为 ipv4_addr ，标签为 interval。让该集合支持区间&lt;/li>
&lt;li>nft add element inet my_table my_set { 10.10.10.22, 10.10.10.33 } #向 my_set 集合中添加元素，一共添加了两个元素，是两个 ipv4 的地址&lt;/li>
&lt;/ol>
&lt;h2 id="字典管理命令">字典管理命令&lt;/h2>
&lt;p>字典&lt;/p>
&lt;p>字典是 nftables 的一个高级特性，它可以使用不同类型的数据并将匹配条件映射到某一个规则上面，并且由于是哈希映射的方式，可以完美的避免链式规则跳转的性能开销。&lt;/p>
&lt;p>例如，为了从逻辑上将对 TCP 和 UDP 数据包的处理规则拆分开来，可以使用字典来实现，这样就可以通过一条规则实现上述需求。&lt;/p>
&lt;p>$ nft add chain inet my_table my_tcp_chain&lt;/p>
&lt;p>$ nft add chain inet my_table my_udp_chain&lt;/p>
&lt;p>$ nft add rule inet my_table my_filter_chain meta l4proto vmap { tcp : jump my_tcp_chain, udp : jump my_udp_chain }&lt;/p>
&lt;p>$ nft list chain inet my_table my_filter_chain&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>table inet my_table &lt;span style="color:#f92672">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> chain my_filter_chain &lt;span style="color:#f92672">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ...
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> meta nfproto ipv4 ip saddr . meta l4proto . udp dport &lt;span style="color:#f92672">{&lt;/span> 10.30.30.30 . udp . bootps &lt;span style="color:#f92672">}&lt;/span> accept
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> meta l4proto vmap &lt;span style="color:#f92672">{&lt;/span> tcp : jump my_tcp_chain, udp : jump my_udp_chain &lt;span style="color:#f92672">}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>和集合一样，除了匿名字典之外，还可以创建命名字典：&lt;/p>
&lt;p>$ nft add map inet my_table my_vmap { type inet_proto : verdict ; }&lt;/p>
&lt;p>向字典中添加元素：&lt;/p>
&lt;p>$ nft add element inet my_table my_vmap { 192.168.0.10 : drop, 192.168.0.11 : accept }&lt;/p>
&lt;p>后面就可以在规则中引用字典中的元素了：&lt;/p>
&lt;p>$ nft add rule inet my_table my_filter_chain ip saddr vmap @my_vmap&lt;/p>
&lt;ol start="9">
&lt;li>&lt;/li>
&lt;/ol>
&lt;p>表与命名空间&lt;/p>
&lt;p>在 nftables 中，每个表都是一个独立的命名空间，这就意味着不同的表中的链、集合、字典等都可以有相同的名字。例如：&lt;/p>
&lt;p>$ nft add table inet table_one&lt;/p>
&lt;p>$ nft add chain inet table_one my_chain&lt;/p>
&lt;p>$ nft add table inet table_two&lt;/p>
&lt;p>$ nft add chain inet table_two my_chain&lt;/p>
&lt;p>$ nft list ruleset&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>...
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>table inet table_one &lt;span style="color:#f92672">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> chain my_chain &lt;span style="color:#f92672">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>table inet table_two &lt;span style="color:#f92672">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> chain my_chain &lt;span style="color:#f92672">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>有了这个特性，不同的应用就可以在相互不影响的情况下管理自己的表中的规则，而使用 iptables 就无法做到这一点。&lt;/p>
&lt;p>当然，这个特性也有缺陷，由于每个表都被视为独立的防火墙，那么某个数据包必须被所有表中的规则放行，才算真正的放行，即使 table_one 允许该数据包通过，该数据包仍然有可能被 table_two 拒绝。为了解决这个问题，nftables 引入了优先级，priority 值越高的链优先级越低，所以 priority 值低的链比 priority 值高的链先执行。如果两条链的优先级相同，就会进入竞争状态。&lt;/p>
&lt;p>总结&lt;/p>
&lt;p>希望通过本文的讲解，你能对 nftables 的功能和用法有所了解，当然本文只涉及了一些浅显的用法，更高级的用法可以查看 nftables 的官方 wiki，或者坐等我接下来的文章。相信有了本文的知识储备，你应该可以愉快地使用 nftables 实现 Linux 的智能分流了，具体扫一扫下方的二维码参考这篇文章：Linux 全局智能分流方案。&lt;/p></description></item></channel></rss>