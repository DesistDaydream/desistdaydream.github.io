<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>断念梦 – Linux 网络设备详解</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2.kernel%E5%86%85%E6%A0%B8/8.network-%E7%AE%A1%E7%90%86/linux-%E7%BD%91%E7%BB%9C%E6%A0%88%E7%AE%A1%E7%90%86/linux-%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87%E8%AF%A6%E8%A7%A3/</link><description>Recent content in Linux 网络设备详解 on 断念梦</description><generator>Hugo -- gohugo.io</generator><atom:link href="https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2.kernel%E5%86%85%E6%A0%B8/8.network-%E7%AE%A1%E7%90%86/linux-%E7%BD%91%E7%BB%9C%E6%A0%88%E7%AE%A1%E7%90%86/linux-%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87%E8%AF%A6%E8%A7%A3/index.xml" rel="self" type="application/rss+xml"/><item><title>Docs: Bond 与 Team</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2.kernel%E5%86%85%E6%A0%B8/8.network-%E7%AE%A1%E7%90%86/linux-%E7%BD%91%E7%BB%9C%E6%A0%88%E7%AE%A1%E7%90%86/linux-%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87%E8%AF%A6%E8%A7%A3/bond-%E4%B8%8E-team/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2.kernel%E5%86%85%E6%A0%B8/8.network-%E7%AE%A1%E7%90%86/linux-%E7%BD%91%E7%BB%9C%E6%A0%88%E7%AE%A1%E7%90%86/linux-%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87%E8%AF%A6%E8%A7%A3/bond-%E4%B8%8E-team/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Link_aggregation">Wiki,Link Aggregation&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Media-independent_interface">Wiki,MII&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.kernel.org/doc/html/latest/networking/bonding.html">Linux 内核文档,Linux 网络文档-Linux 以太网 Bonding 驱动入门指南&lt;/a>(这里可以看到所有 Bonding 参数)&lt;/li>
&lt;li>&lt;a href="https://wiki.linuxfoundation.org/networking/bonding">Linux 基金会 Wiki,网络-bonding&lt;/a>&lt;/li>
&lt;li>红帽官方的 bond 说明文档：&lt;a href="https://access.redhat.com/documentation/zh-cn/red_hat_enterprise_linux/7/html/networking_guide/ch-configure_network_bonding">https://access.redhat.com/documentation/zh-cn/red_hat_enterprise_linux/7/html/networking_guide/ch-configure_network_bonding&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.ibm.com/docs/en/linux-on-systems?topic=recommendations-link-monitoring">https://www.ibm.com/docs/en/linux-on-systems?topic=recommendations-link-monitoring&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>&lt;strong>Link Aggregation(链路聚合)&lt;/strong> 技术就是将多条物理链路聚合成一条带宽更高的逻辑链路，该逻辑链路的带宽等于被聚合在一起的多条物理链路的带宽之和。聚合在一起的物理链路的条数可以根据业务的带宽需求来配置。因此链路聚合具有成本低，配置灵活的优点，此外，链路聚合还具有链路冗余备份的功能，聚合在一起的链路彼此动态备份，提高了网络的稳定性。早期链路聚合技术的实现没有统一的标准，各厂商都有自己私有的解决方案，功能不完全相同，也互不兼容。因此，IEEE 专门制定了链路聚合的标准，目前链路聚合技术的正式标准为 IEEE Standard 802.3ad，而 &lt;strong>Link Aggregation Control Protocol(链路汇聚控制协议,LACP)&lt;/strong> 是该标准的主要内容之一，是一种实现链路动态聚合的协议。&lt;/p>
&lt;h2 id="link-aggregation-control-protocol">Link Aggregation Control Protocol&lt;/h2>
&lt;p>**Link Aggregation Control Protocol(链路汇聚控制协议，简称 LACP) **在 IEEE 以太网标准中，提供了一种方法，可以将多个物理链路捆绑在一起以形成单个逻辑链路。LACP 允许网络设备通过将 LACP 数据包发送到 &lt;strong>Peer(对等方)&lt;/strong> 以 &lt;strong>negotiate(协商)&lt;/strong> 链路状态，并实现自动捆绑。&lt;/p>
&lt;blockquote>
&lt;p>Peer(对等方) 指的是与本网络设备直连的可以实现 LACP 的对端网络设备
LACP 数据包通常称为 &lt;strong>Link Aggregation Control Protocol Data Unit(链路汇聚控制协议数据单元，简称 LACPDU)&lt;/strong>&lt;/p>
&lt;/blockquote>
&lt;h1 id="bond网卡绑定">Bond，网卡绑定&lt;/h1>
&lt;p>Bond 类型的网络设备是通过把多个网络设备绑定为一个逻辑网络设备，实现本地网络设备的冗余、带宽扩容和负载均衡。在应用部署中是一种常用的技术。&lt;/p>
&lt;p>Linux 中使用 bonding 模块实现 bonding 驱动程序。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">[&lt;/span>lichenhao@hw-cloud-xngy-jump-server-linux-2 ~&lt;span style="color:#f92672">]&lt;/span>$ modinfo bonding
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>filename: /lib/modules/5.4.0-88-generic/kernel/drivers/net/bonding/bonding.ko
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>author: Thomas Davis, tadavis@lbl.gov and many others
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>description: Ethernet Channel Bonding Driver, v3.7.1
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>version: 3.7.1
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>license: GPL
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>alias: rtnl-link-bond
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>srcversion: B95AF01257E8C745F584C8F
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>depends:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>retpoline: Y
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>intree: Y
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>name: bonding
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>vermagic: 5.4.0-88-generic SMP mod_unload modversions
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>sig_id: PKCS#7
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>signer: Build time autogenerated kernel key
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>sig_key: 2D:2D:71:A0:22:44:6D:60:C8:49:CB:0E:D7:43:D0:D2:7A:5C:0E:F1
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>sig_hashalgo: sha512
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>signature: AE:16:69:2D:17:C0:36:10:F4:52:73:EB:A4:CB:CB:FC:68:78:DE:3A:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>......
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>parm: max_bonds:Max number of bonded devices &lt;span style="color:#f92672">(&lt;/span>int&lt;span style="color:#f92672">)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>parm: tx_queues:Max number of transmit queues &lt;span style="color:#f92672">(&lt;/span>default &lt;span style="color:#f92672">=&lt;/span> 16&lt;span style="color:#f92672">)&lt;/span> &lt;span style="color:#f92672">(&lt;/span>int&lt;span style="color:#f92672">)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>parm: num_grat_arp:Number of peer notifications to send on failover event &lt;span style="color:#f92672">(&lt;/span>alias of num_unsol_na&lt;span style="color:#f92672">)&lt;/span> &lt;span style="color:#f92672">(&lt;/span>int&lt;span style="color:#f92672">)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>parm: num_unsol_na:Number of peer notifications to send on failover event &lt;span style="color:#f92672">(&lt;/span>alias of num_grat_arp&lt;span style="color:#f92672">)&lt;/span> &lt;span style="color:#f92672">(&lt;/span>int&lt;span style="color:#f92672">)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>parm: miimon:Link check interval in milliseconds &lt;span style="color:#f92672">(&lt;/span>int&lt;span style="color:#f92672">)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>parm: updelay:Delay before considering link up, in milliseconds &lt;span style="color:#f92672">(&lt;/span>int&lt;span style="color:#f92672">)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>parm: downdelay:Delay before considering link down, in milliseconds &lt;span style="color:#f92672">(&lt;/span>int&lt;span style="color:#f92672">)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>parm: use_carrier:Use netif_carrier_ok &lt;span style="color:#f92672">(&lt;/span>vs MII ioctls&lt;span style="color:#f92672">)&lt;/span> in miimon; &lt;span style="color:#ae81ff">0&lt;/span> &lt;span style="color:#66d9ef">for&lt;/span> off, &lt;span style="color:#ae81ff">1&lt;/span> &lt;span style="color:#66d9ef">for&lt;/span> on &lt;span style="color:#f92672">(&lt;/span>default&lt;span style="color:#f92672">)&lt;/span> &lt;span style="color:#f92672">(&lt;/span>int&lt;span style="color:#f92672">)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>parm: mode:Mode of operation; &lt;span style="color:#ae81ff">0&lt;/span> &lt;span style="color:#66d9ef">for&lt;/span> balance-rr, &lt;span style="color:#ae81ff">1&lt;/span> &lt;span style="color:#66d9ef">for&lt;/span> active-backup, &lt;span style="color:#ae81ff">2&lt;/span> &lt;span style="color:#66d9ef">for&lt;/span> balance-xor, &lt;span style="color:#ae81ff">3&lt;/span> &lt;span style="color:#66d9ef">for&lt;/span> broadcast, &lt;span style="color:#ae81ff">4&lt;/span> &lt;span style="color:#66d9ef">for&lt;/span> 802.3ad, &lt;span style="color:#ae81ff">5&lt;/span> &lt;span style="color:#66d9ef">for&lt;/span> balance-tlb, &lt;span style="color:#ae81ff">6&lt;/span> &lt;span style="color:#66d9ef">for&lt;/span> balance-alb &lt;span style="color:#f92672">(&lt;/span>charp&lt;span style="color:#f92672">)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>parm: primary:Primary network device to use &lt;span style="color:#f92672">(&lt;/span>charp&lt;span style="color:#f92672">)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>parm: primary_reselect:Reselect primary slave once it comes up; &lt;span style="color:#ae81ff">0&lt;/span> &lt;span style="color:#66d9ef">for&lt;/span> always &lt;span style="color:#f92672">(&lt;/span>default&lt;span style="color:#f92672">)&lt;/span>, &lt;span style="color:#ae81ff">1&lt;/span> &lt;span style="color:#66d9ef">for&lt;/span> only &lt;span style="color:#66d9ef">if&lt;/span> speed of primary is better, &lt;span style="color:#ae81ff">2&lt;/span> &lt;span style="color:#66d9ef">for&lt;/span> only on active slave failure &lt;span style="color:#f92672">(&lt;/span>charp&lt;span style="color:#f92672">)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>parm: lacp_rate:LACPDU tx rate to request from 802.3ad partner; &lt;span style="color:#ae81ff">0&lt;/span> &lt;span style="color:#66d9ef">for&lt;/span> slow, &lt;span style="color:#ae81ff">1&lt;/span> &lt;span style="color:#66d9ef">for&lt;/span> fast &lt;span style="color:#f92672">(&lt;/span>charp&lt;span style="color:#f92672">)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>parm: ad_select:802.3ad aggregation selection logic; &lt;span style="color:#ae81ff">0&lt;/span> &lt;span style="color:#66d9ef">for&lt;/span> stable &lt;span style="color:#f92672">(&lt;/span>default&lt;span style="color:#f92672">)&lt;/span>, &lt;span style="color:#ae81ff">1&lt;/span> &lt;span style="color:#66d9ef">for&lt;/span> bandwidth, &lt;span style="color:#ae81ff">2&lt;/span> &lt;span style="color:#66d9ef">for&lt;/span> count &lt;span style="color:#f92672">(&lt;/span>charp&lt;span style="color:#f92672">)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>parm: min_links:Minimum number of available links before turning on carrier &lt;span style="color:#f92672">(&lt;/span>int&lt;span style="color:#f92672">)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>parm: xmit_hash_policy:balance-alb, balance-tlb, balance-xor, 802.3ad hashing method; &lt;span style="color:#ae81ff">0&lt;/span> &lt;span style="color:#66d9ef">for&lt;/span> layer &lt;span style="color:#ae81ff">2&lt;/span> &lt;span style="color:#f92672">(&lt;/span>default&lt;span style="color:#f92672">)&lt;/span>, &lt;span style="color:#ae81ff">1&lt;/span> &lt;span style="color:#66d9ef">for&lt;/span> layer 3+4, &lt;span style="color:#ae81ff">2&lt;/span> &lt;span style="color:#66d9ef">for&lt;/span> layer 2+3, &lt;span style="color:#ae81ff">3&lt;/span> &lt;span style="color:#66d9ef">for&lt;/span> encap layer 2+3, &lt;span style="color:#ae81ff">4&lt;/span> &lt;span style="color:#66d9ef">for&lt;/span> encap layer 3+4 &lt;span style="color:#f92672">(&lt;/span>charp&lt;span style="color:#f92672">)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>parm: arp_interval:arp interval in milliseconds &lt;span style="color:#f92672">(&lt;/span>int&lt;span style="color:#f92672">)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>parm: arp_ip_target:arp targets in n.n.n.n form &lt;span style="color:#f92672">(&lt;/span>array of charp&lt;span style="color:#f92672">)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>parm: arp_validate:validate src/dst of ARP probes; &lt;span style="color:#ae81ff">0&lt;/span> &lt;span style="color:#66d9ef">for&lt;/span> none &lt;span style="color:#f92672">(&lt;/span>default&lt;span style="color:#f92672">)&lt;/span>, &lt;span style="color:#ae81ff">1&lt;/span> &lt;span style="color:#66d9ef">for&lt;/span> active, &lt;span style="color:#ae81ff">2&lt;/span> &lt;span style="color:#66d9ef">for&lt;/span> backup, &lt;span style="color:#ae81ff">3&lt;/span> &lt;span style="color:#66d9ef">for&lt;/span> all &lt;span style="color:#f92672">(&lt;/span>charp&lt;span style="color:#f92672">)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>parm: arp_all_targets:fail on any/all arp targets timeout; &lt;span style="color:#ae81ff">0&lt;/span> &lt;span style="color:#66d9ef">for&lt;/span> any &lt;span style="color:#f92672">(&lt;/span>default&lt;span style="color:#f92672">)&lt;/span>, &lt;span style="color:#ae81ff">1&lt;/span> &lt;span style="color:#66d9ef">for&lt;/span> all &lt;span style="color:#f92672">(&lt;/span>charp&lt;span style="color:#f92672">)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>parm: fail_over_mac:For active-backup, &lt;span style="color:#66d9ef">do&lt;/span> not set all slaves to the same MAC; &lt;span style="color:#ae81ff">0&lt;/span> &lt;span style="color:#66d9ef">for&lt;/span> none &lt;span style="color:#f92672">(&lt;/span>default&lt;span style="color:#f92672">)&lt;/span>, &lt;span style="color:#ae81ff">1&lt;/span> &lt;span style="color:#66d9ef">for&lt;/span> active, &lt;span style="color:#ae81ff">2&lt;/span> &lt;span style="color:#66d9ef">for&lt;/span> follow &lt;span style="color:#f92672">(&lt;/span>charp&lt;span style="color:#f92672">)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>parm: all_slaves_active:Keep all frames received on an interface by setting active flag &lt;span style="color:#66d9ef">for&lt;/span> all slaves; &lt;span style="color:#ae81ff">0&lt;/span> &lt;span style="color:#66d9ef">for&lt;/span> never &lt;span style="color:#f92672">(&lt;/span>default&lt;span style="color:#f92672">)&lt;/span>, &lt;span style="color:#ae81ff">1&lt;/span> &lt;span style="color:#66d9ef">for&lt;/span> always. &lt;span style="color:#f92672">(&lt;/span>int&lt;span style="color:#f92672">)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>parm: resend_igmp:Number of IGMP membership reports to send on link failure &lt;span style="color:#f92672">(&lt;/span>int&lt;span style="color:#f92672">)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>parm: packets_per_slave:Packets to send per slave in balance-rr mode; &lt;span style="color:#ae81ff">0&lt;/span> &lt;span style="color:#66d9ef">for&lt;/span> a random slave, &lt;span style="color:#ae81ff">1&lt;/span> packet per slave &lt;span style="color:#f92672">(&lt;/span>default&lt;span style="color:#f92672">)&lt;/span>, &amp;gt;1 packets per slave. &lt;span style="color:#f92672">(&lt;/span>int&lt;span style="color:#f92672">)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>parm: lp_interval:The number of seconds between instances where the bonding driver sends learning packets to each slaves peer switch. The default is 1. &lt;span style="color:#f92672">(&lt;/span>uint&lt;span style="color:#f92672">)&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h1 id="bond-参数">Bond 参数&lt;/h1>
&lt;h2 id="arp-监控参数">ARP 监控参数&lt;/h2>
&lt;p>ARP 监控参数与 MII 监控参数不可同时使用&lt;/p>
&lt;p>&lt;strong>arp_interval&lt;/strong> # ARP 监控模式的监控频率，单位 毫秒。&lt;code>默认值：0&lt;/code>。0 值表示禁用 ARP 监控
&lt;strong>arp_ip_target&lt;/strong> #&lt;/p>
&lt;h2 id="mii-监控参数">MII 监控参数&lt;/h2>
&lt;p>&lt;strong>Media Independent Interface(介质无关接口，简称 MII)&lt;/strong>，通过该接口可以检测聚合链路的状态，当某个网络设备故障时，bonding 驱动会将这个故障设备标记为关闭。虽然不会将设备踢出聚合组，但是数据不在通过故障设备传输
MII 监控参数与 ARP 监控参数不可同时使用&lt;/p>
&lt;p>&lt;strong>miimon&lt;/strong> # MII 监控模式的监控频率，单位 毫秒。这决定了每个备链路状态的故障检查频率。&lt;code>默认值：0&lt;/code>。0 值表示禁用 MII 链路监控&lt;/p>
&lt;ul>
&lt;li>通常设置为 100&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>use_carrier&lt;/strong> # 指定 miimon 是否应使用 MII 或 ETHTOOL ioctls 与 netif_carrier_ok() 来确定链接状态。 默认值是 1，这使得可以使用 netif_carrier_ok（）。 这由 Linux on Z 上的 qeth 设备驱动程序支持。
**downdelay **# 检测到网络设备故障后，持续 downdelay 毫秒后，关闭该设备。
&lt;strong>updelay&lt;/strong> # 检测到网络设备恢复后，持续 updelay 毫秒后，启用该设备&lt;/p>
&lt;h2 id="bond-模式参数">Bond 模式参数&lt;/h2>
&lt;p>&lt;strong>mode&lt;/strong> # 指定 bonding 策略。&lt;code>默认值：balance-rr&lt;/code>。常见的 bond 模式有七种：括号中是该模式所对应的数字，使用 nmcli 命令时，不要使用数字代替，NetworkManager 无法识别数字。&lt;/p>
&lt;ul>
&lt;li>&lt;strong>balance-rr(0)&lt;/strong> # 表示负载分担 round-robin，和交换机的聚合强制不协商的方式配合。&lt;/li>
&lt;li>&lt;strong>active-backup(1)&lt;/strong> # 表示主备模式，只有一块网卡是 active,另外一块是备的 standby，这时如果交换机配的是捆绑，将不能正常工作，因为交换机往两块网卡发包，有一半包是丢弃的。
&lt;ul>
&lt;li>注意：vmwork 的虚拟机中只能做 mode=1 的实验，其它的工作模式得用真机来实践，并且需要添加额外参数(fail_over_mac=1)才能实现主备模式&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>balance-xor(2)&lt;/strong> # 表示 XOR Hash 负载分担，和交换机的聚合强制不协商方式配合(需要 xmit_hash_policy)
&lt;ul>
&lt;li>推荐 bond 参数：mode=balance-xor,miimon=100,xmit_hash_policy=layer3+4&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>broadcast(3)&lt;/strong> # 表示所有包从所有 interface 发出，这个不均衡，只有冗余机制&amp;hellip;和交换机的聚合强制不协商方式配合。&lt;/li>
&lt;li>&lt;strong>802.3ad(4)&lt;/strong> # 表示支持 802.3ad 协议，动态链路聚合，需要和交换机的聚合 LACP 方式配合(需要 xmit_hash_policy)
&lt;ul>
&lt;li>推荐 bond 参数：mode=802.3ad,miimon=100,lacp_rate=1,xmit_hash_policy=layer3+4&lt;/li>
&lt;li>802.3ad 模式的 Bond 网络设备的最大带宽是所有 Slave 设备最大带宽之和&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>balance-tlb(5)&lt;/strong> # 是根据每个 slave 的负载情况选择 slave 进行发送，接收时使用当前轮到的 slave&lt;/li>
&lt;li>&lt;strong>balance-alb(6)&lt;/strong> # 在 5 的 tlb 基础上增加了 rlb。Adaptive Load Balancing(简称 ALB) 协议，可以根据网络状态和物理网卡的带宽来动态地将数据包分配到每个物理网卡上。&lt;/li>
&lt;/ul>
&lt;blockquote>
&lt;p>注意：&lt;/p>
&lt;ul>
&lt;li>active-backup、balance-tlb 和 balance-alb 模式不需要交换机的任何特殊配置。其他绑定模式需要配置交换机以便整合链接。例如：Cisco 交换机需要在模式 0、2 和 3 中使用 EtherChannel，但在模式 4 中需要 LACP 和 EtherChannel。有关交换机附带文档，请查看 &lt;a href="https://www.kernel.org/doc/Documentation/networking/bonding.txt">https://www.kernel.org/doc/Documentation/networking/bonding.txt&lt;/a>。&lt;/li>
&lt;li>若想 bond 功能生效，关闭 NetworkManager 服务 或者 在配置文件中的 BONDING_OPTS 中 MODE 的值不要用数字，而是直接使用模式名称来作为值&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>每种模式的理论最大带宽：&lt;/p>
&lt;ul>
&lt;li>0 和 2 模式是所有网络设备的带宽之和&lt;/li>
&lt;li>1 和 3 模式是单个网络设备的带宽&lt;/li>
&lt;li>4 模式也是带宽之和，但是会动态分配，有时候最大值可能会超过带宽之和的上限&lt;/li>
&lt;li>5 和 6 与 4 类似，都是带宽之和，且可能超过上限。&lt;/li>
&lt;/ul>
&lt;h2 id="其他参数">其他参数&lt;/h2>
&lt;p>&lt;strong>lacp_rate&lt;/strong> # 作用于 802.3ad 模式。向聚合链路的对端(通常来说都是交换机)传输** LACPDU** 包的速率。可用的值有如下几个：&lt;/p>
&lt;ul>
&lt;li>slow # 每 30 秒传输一次 LACPDU，即每 30 秒协商一次&lt;/li>
&lt;li>fast # 每秒传输一次 LACPDU，即每秒协商一次&lt;/li>
&lt;li>max_bonds # 指定要为此绑定驱动程序实例创建的绑定设备数。例如，如果 max_bonds 为 3，并且绑定驱动程序尚未加载，则将创建 bond0、bond1 和 bond2。默认值为 1&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>xmit_hash_policy&lt;/strong> # 作用于 balance-xor 和 802.3ad 模式。配置传输 hash 策略。&lt;code>默认值：layer2&lt;/code>。&lt;/p>
&lt;ul>
&lt;li>layer2 # 该策略支持 802.3ad。使用 XOR 或硬件 MAC 地址生成 hash。&lt;/li>
&lt;li>layer2+3 # 该策略支持 802.3ad。使用 XOR 或硬件 MAC 地址与 IP 地址一起生成 hash。&lt;/li>
&lt;li>layer3+4 # 该策略不完全支持 802.3ad&lt;/li>
&lt;li>说明：
&lt;ul>
&lt;li>这里面的 2，3，4 其实就是指的 ISO 模型里的层，2 层就是用 MAC 进行计算，2+3 就是用 MAC 加 IP 进行计算，3+4 就是用 IP 加 PORT 进行计算。&lt;/li>
&lt;li>只使用 2 层的 MAC 进行计算时，会导致同一个网关的数据流将完全从一个端口发送，但是如果使用 2+3 或 3+4，虽然负载更均衡了，但是由于使用了上层协议进行计算，则增加了 hash 的开销。&lt;/li>
&lt;li>计算越负责，负载均衡效果越好，但是资源开销越大。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h1 id="bond-配置">Bond 配置&lt;/h1>
&lt;p>/sys/class/net/bonding_masters # 当前系统下已经启用的 Bond 名称
/sys/class/net/BondName/* # Bond 类型网络设备的运行时信息，这里面某些信息是可以被修改的。&lt;/p>
&lt;ul>
&lt;li>./statistics/* # 网络设备的状态信息，比如 发送/接受 了多少数据包、多少数据量 等等，&lt;code>ip -s&lt;/code> 参数可以从这里获取到信息&lt;/li>
&lt;li>./bonding/* # Bond 参数&lt;/li>
&lt;/ul>
&lt;p>/proc/net/bonding/* # bond 运行时状态信息。其内文件名为 Bond 的名称。查看文件内容解析详见&lt;a href="#cvrU1">《Bonding 在内核中的信息解析》&lt;/a>部分&lt;/p>
&lt;h2 id="bond-基本配置文件详解">Bond 基本配置文件详解&lt;/h2>
&lt;p>首先是配置一个 bond 网络设备，IP 等相关信息配置在 bond 网络设备上。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">[&lt;/span>root@lichenhao network-scripts&lt;span style="color:#f92672">]&lt;/span>&lt;span style="color:#75715e"># cat /etc/sysconfig/network-scripts/ifcfg-bond0&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>BONDING_OPTS&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;mode=balance-rr&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>TYPE&lt;span style="color:#f92672">=&lt;/span>Bond
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>BONDING_MASTER&lt;span style="color:#f92672">=&lt;/span>yes
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>BOOTPROTO&lt;span style="color:#f92672">=&lt;/span>dhcp
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>DEFROUTE&lt;span style="color:#f92672">=&lt;/span>yes
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>NAME&lt;span style="color:#f92672">=&lt;/span>bond0
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>DEVICE&lt;span style="color:#f92672">=&lt;/span>bond0
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>ONBOOT&lt;span style="color:#f92672">=&lt;/span>yes
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>其次配置让一个物理网络设备绑定到该 bond 设备上&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">[&lt;/span>root@lichenhao network-scripts&lt;span style="color:#f92672">]&lt;/span>&lt;span style="color:#75715e"># cat /etc/sysconfig/network-scripts/ifcfg-bond-slave-em1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>TYPE&lt;span style="color:#f92672">=&lt;/span>Ethernet
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>NAME&lt;span style="color:#f92672">=&lt;/span>bond-slave-em1
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>DEVICE&lt;span style="color:#f92672">=&lt;/span>em1
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>ONBOOT&lt;span style="color:#f92672">=&lt;/span>yes
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>MASTER&lt;span style="color:#f92672">=&lt;/span>bond0
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>SLAVE&lt;span style="color:#f92672">=&lt;/span>yes
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h1 id="bond-在内核中的信息解析">Bond 在内核中的信息解析&lt;/h1>
&lt;p>/proc/net/bonding/BondNAME 文件中保存了当前系统中已启动的 Bond 类型的网络设备的信息
这些信息分为多个部分&lt;/p>
&lt;ul>
&lt;li>Bond 类型的网络设备通用信息&lt;/li>
&lt;li>Bond 类型的网络设备特定信息，比如 802.3ad 类型的 Bond 就有独自的信息&lt;/li>
&lt;li>Bond 下 Slave 网络设备通用信息&lt;/li>
&lt;/ul>
&lt;h2 id="balance-rr">balance-rr&lt;/h2>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>Bonding Mode: load balancing &lt;span style="color:#f92672">(&lt;/span>round-robin&lt;span style="color:#f92672">)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>MII Status: up
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>MII Polling Interval &lt;span style="color:#f92672">(&lt;/span>ms&lt;span style="color:#f92672">)&lt;/span>: &lt;span style="color:#ae81ff">100&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Up Delay &lt;span style="color:#f92672">(&lt;/span>ms&lt;span style="color:#f92672">)&lt;/span>: &lt;span style="color:#ae81ff">0&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Down Delay &lt;span style="color:#f92672">(&lt;/span>ms&lt;span style="color:#f92672">)&lt;/span>: &lt;span style="color:#ae81ff">0&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Slave Interface: enp6s0f0
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>MII Status: up
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Speed: &lt;span style="color:#ae81ff">10000&lt;/span> Mbps
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Duplex: full
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Link Failure Count: &lt;span style="color:#ae81ff">0&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Permanent HW addr: 40:a6:b7:25:f2:3c
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Slave queue ID: &lt;span style="color:#ae81ff">0&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Slave Interface: enp6s0f1
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>MII Status: up
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Speed: &lt;span style="color:#ae81ff">10000&lt;/span> Mbps
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Duplex: full
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Link Failure Count: &lt;span style="color:#ae81ff">0&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Permanent HW addr: 40:a6:b7:25:f2:3d
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Slave queue ID: &lt;span style="color:#ae81ff">0&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;strong>Bond 设备&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>&lt;strong>Bonding Mode&lt;/strong> # Bond 模式的名称&lt;/li>
&lt;li>&lt;strong>MII Status&lt;/strong> # 链路监控状态&lt;/li>
&lt;li>&lt;strong>MII Polling Interval&lt;/strong> #&lt;/li>
&lt;li>&lt;strong>Up Delay&lt;/strong> # 检测到 Slave 网络设备恢复后，持续 updelay 毫秒后，启用 Slave 设备&lt;/li>
&lt;li>&lt;strong>Down Delay&lt;/strong> # 检测到 Slave 网络设备故障后，持续 downdelay 毫秒后，关闭 Slave 设备。&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>Slave 设备&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>&lt;strong>Slave Interface&lt;/strong> # 与 Bond 设备关联的 Slave 网络设备的名称&lt;/li>
&lt;li>&lt;strong>MII Status&lt;/strong> # 链路监控状态&lt;/li>
&lt;li>**Speed **# 最大传输速度，即网卡的带宽&lt;/li>
&lt;li>&lt;strong>Duplex&lt;/strong> # 双工模式&lt;/li>
&lt;li>&lt;strong>Link Failure Count&lt;/strong> # 失联总次数&lt;/li>
&lt;li>&lt;strong>Permanent HW addr&lt;/strong> # 关联的物理网卡的硬件地址，即网卡的 MAC 地址&lt;/li>
&lt;li>&lt;strong>Slave queue ID&lt;/strong> # 队列 ID&lt;/li>
&lt;/ul>
&lt;h2 id="balance-xor">balance-xor&lt;/h2>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">[&lt;/span>root@vs-7 bonding&lt;span style="color:#f92672">]&lt;/span>&lt;span style="color:#75715e"># cat /proc/net/bonding/bond0&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Ethernet Channel Bonding Driver: v3.7.1 &lt;span style="color:#f92672">(&lt;/span>April 27, 2011&lt;span style="color:#f92672">)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Bonding Mode: load balancing &lt;span style="color:#f92672">(&lt;/span>xor&lt;span style="color:#f92672">)&lt;/span> &lt;span style="color:#75715e"># 此 bond 的模式&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Transmit Hash Policy: layer3+4 &lt;span style="color:#f92672">(&lt;/span>1&lt;span style="color:#f92672">)&lt;/span> &lt;span style="color:#75715e"># 此 bond 模式的参数&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>MII Status: up
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>MII Polling Interval &lt;span style="color:#f92672">(&lt;/span>ms&lt;span style="color:#f92672">)&lt;/span>: &lt;span style="color:#ae81ff">100&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Up Delay &lt;span style="color:#f92672">(&lt;/span>ms&lt;span style="color:#f92672">)&lt;/span>: &lt;span style="color:#ae81ff">0&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Down Delay &lt;span style="color:#f92672">(&lt;/span>ms&lt;span style="color:#f92672">)&lt;/span>: &lt;span style="color:#ae81ff">0&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Peer Notification Delay &lt;span style="color:#f92672">(&lt;/span>ms&lt;span style="color:#f92672">)&lt;/span>: &lt;span style="color:#ae81ff">0&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Slave Interface: eno1
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>MII Status: up
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Speed: &lt;span style="color:#ae81ff">1000&lt;/span> Mbps
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Duplex: full
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Link Failure Count: &lt;span style="color:#ae81ff">0&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Permanent HW addr: f0:d4:e2:ea:28:54
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Slave queue ID: &lt;span style="color:#ae81ff">0&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Slave Interface: eno2
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>MII Status: up
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Speed: &lt;span style="color:#ae81ff">1000&lt;/span> Mbps
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Duplex: full
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Link Failure Count: &lt;span style="color:#ae81ff">0&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Permanent HW addr: f0:d4:e2:ea:28:55
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Slave queue ID: &lt;span style="color:#ae81ff">0&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="8023ad">802.3ad&lt;/h2>
&lt;blockquote>
&lt;ul>
&lt;li>&lt;a href="https://stackoverflow.com/questions/62173444/churn-state-meaning-in-lacp-bonding">StackOverflow,bonding LACP 模式下 Churn 的含义&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://mlog.club/article/2693580">https://mlog.club/article/2693580&lt;/a>
&lt;ul>
&lt;li>&lt;a href="https://bugzilla.redhat.com/show_bug.cgi?id=1295423">https://bugzilla.redhat.com/show_bug.cgi?id=1295423&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://git.kernel.org/pub/scm/linux/kernel/git/netdev/net.git/commit/?id=ea53abfab960909d622ca37bcfb8e1c5378d21cc">https://git.kernel.org/pub/scm/linux/kernel/git/netdev/net.git/commit/?id=ea53abfab960909d622ca37bcfb8e1c5378d21cc&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://access.redhat.com/solutions/4122011">https://access.redhat.com/solutions/4122011&lt;/a>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;a href="https://github.com/systemd/systemd/issues/15208">https://github.com/systemd/systemd/issues/15208&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">[&lt;/span>root@yihualu-33 test_dir&lt;span style="color:#f92672">]&lt;/span>&lt;span style="color:#75715e"># cat /proc/net/bonding/bond1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Ethernet Channel Bonding Driver: v3.7.1 &lt;span style="color:#f92672">(&lt;/span>April 27, 2011&lt;span style="color:#f92672">)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Bonding Mode: IEEE 802.3ad Dynamic link aggregation
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Transmit Hash Policy: layer3+4 &lt;span style="color:#f92672">(&lt;/span>1&lt;span style="color:#f92672">)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>MII Status: up
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>MII Polling Interval &lt;span style="color:#f92672">(&lt;/span>ms&lt;span style="color:#f92672">)&lt;/span>: &lt;span style="color:#ae81ff">100&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Up Delay &lt;span style="color:#f92672">(&lt;/span>ms&lt;span style="color:#f92672">)&lt;/span>: &lt;span style="color:#ae81ff">0&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Down Delay &lt;span style="color:#f92672">(&lt;/span>ms&lt;span style="color:#f92672">)&lt;/span>: &lt;span style="color:#ae81ff">0&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>802.3ad info
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>LACP rate: slow
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Min links: &lt;span style="color:#ae81ff">0&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Aggregator selection policy &lt;span style="color:#f92672">(&lt;/span>ad_select&lt;span style="color:#f92672">)&lt;/span>: stable
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>System priority: &lt;span style="color:#ae81ff">65535&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>System MAC address: 32:1c:0d:e9:ca:e9
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Active Aggregator Info:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Aggregator ID: &lt;span style="color:#ae81ff">1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Number of ports: &lt;span style="color:#ae81ff">2&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Actor Key: &lt;span style="color:#ae81ff">15&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Partner Key: &lt;span style="color:#ae81ff">6&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Partner Mac Address: 00:00:00:00:00:06
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Slave Interface: enp6s0f0
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>MII Status: up
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Speed: &lt;span style="color:#ae81ff">10000&lt;/span> Mbps
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Duplex: full
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Link Failure Count: &lt;span style="color:#ae81ff">0&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Permanent HW addr: 40:a6:b7:26:60:b4
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Slave queue ID: &lt;span style="color:#ae81ff">0&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Aggregator ID: &lt;span style="color:#ae81ff">1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Actor Churn State: none
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Partner Churn State: none
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Actor Churned Count: &lt;span style="color:#ae81ff">0&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Partner Churned Count: &lt;span style="color:#ae81ff">0&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>details actor lacp pdu:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> system priority: &lt;span style="color:#ae81ff">65535&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> system mac address: 32:1c:0d:e9:ca:e9
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> port key: &lt;span style="color:#ae81ff">15&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> port priority: &lt;span style="color:#ae81ff">255&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> port number: &lt;span style="color:#ae81ff">1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> port state: &lt;span style="color:#ae81ff">61&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>details partner lacp pdu:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> system priority: &lt;span style="color:#ae81ff">6&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> system mac address: 00:00:00:00:00:06
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> oper key: &lt;span style="color:#ae81ff">6&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> port priority: &lt;span style="color:#ae81ff">32768&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> port number: &lt;span style="color:#ae81ff">33862&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> port state: &lt;span style="color:#ae81ff">63&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Slave Interface: enp6s0f1
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>MII Status: up
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Speed: &lt;span style="color:#ae81ff">10000&lt;/span> Mbps
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Duplex: full
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Link Failure Count: &lt;span style="color:#ae81ff">0&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Permanent HW addr: 40:a6:b7:26:60:b5
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Slave queue ID: &lt;span style="color:#ae81ff">0&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Aggregator ID: &lt;span style="color:#ae81ff">1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Actor Churn State: none
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Partner Churn State: none
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Actor Churned Count: &lt;span style="color:#ae81ff">0&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Partner Churned Count: &lt;span style="color:#ae81ff">0&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>details actor lacp pdu:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> system priority: &lt;span style="color:#ae81ff">65535&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> system mac address: 32:1c:0d:e9:ca:e9
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> port key: &lt;span style="color:#ae81ff">15&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> port priority: &lt;span style="color:#ae81ff">255&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> port number: &lt;span style="color:#ae81ff">2&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> port state: &lt;span style="color:#ae81ff">61&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>details partner lacp pdu:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> system priority: &lt;span style="color:#ae81ff">6&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> system mac address: 00:00:00:00:00:06
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> oper key: &lt;span style="color:#ae81ff">6&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> port priority: &lt;span style="color:#ae81ff">32768&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> port number: &lt;span style="color:#ae81ff">33862&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> port state: &lt;span style="color:#ae81ff">63&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>802.3ad 模式的 Bond 需要与交换机交互 LACP 信息，这里对 服务器 和 交换机 的称呼如下：&lt;/p>
&lt;ul>
&lt;li>**Actor **# 指主机，即服务器&lt;/li>
&lt;li>&lt;strong>Partner&lt;/strong> # 指交换机&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>Aggregator ID&lt;/strong> #
&lt;strong>Actor Churn State 与 Partner Churn State&lt;/strong> # 务器与交换机的 Churn 状态&lt;/p>
&lt;ul>
&lt;li>Churn State # Churn 状态共有三种，先是 monitoring，然后是 churned，最后 none 就正常了。
&lt;ul>
&lt;li>monitoring # 等待其他 PDUs 达成共识
&lt;ul>
&lt;li>The bond slave interface is in the process of the initial LACP communication with the LACP peer.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>churned # 扰动、流逝
&lt;ul>
&lt;li>One of the peer&amp;rsquo;s LACP (etherchannel) interfaces is suspended or is otherwise no longer active as an LACP interface&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>none # 链路已同步&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>Actor Churned Count 与 Partner Churned Count&lt;/strong> #
&lt;strong>details actor lacp pdu 与 details partner lacp pdu&lt;/strong> # 服务器与交换机的 LACPDU 信息细节&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/ggzysy/1644663197947-87aaf3c3-d762-4682-8747-059014f1a7bc.png" alt="image.png">&lt;/p>
&lt;h1 id="team类似于-bond比-bond-更优秀">Team，类似于 Bond，比 Bond 更优秀&lt;/h1>
&lt;h1 id="rhel7-中网卡绑定-team-和-bond-的区别">RHEL7 中网卡绑定 team 和 bond 的区别&lt;/h1>
&lt;p>red hat 官方给出的 team 和 bond 特性对比&lt;/p>
&lt;p>A Comparison of Features in Bonding and Team&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>&lt;/th>
&lt;th>&lt;/th>
&lt;th>&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>Feature&lt;/td>
&lt;td>Bonding&lt;/td>
&lt;td>Team&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>broadcast Tx policy&lt;/td>
&lt;td>Yes&lt;/td>
&lt;td>Yes&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>round-robin Tx policy&lt;/td>
&lt;td>Yes&lt;/td>
&lt;td>Yes&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>active-backup Tx policy&lt;/td>
&lt;td>Yes&lt;/td>
&lt;td>Yes&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>LACP (802.3ad) support&lt;/td>
&lt;td>Yes (active only)&lt;/td>
&lt;td>Yes&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Hash-based Tx policy&lt;/td>
&lt;td>Yes&lt;/td>
&lt;td>Yes&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>User can set hash function&lt;/td>
&lt;td>No&lt;/td>
&lt;td>Yes&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Tx load-balancing support (TLB)&lt;/td>
&lt;td>Yes&lt;/td>
&lt;td>Yes&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>LACP hash port select&lt;/td>
&lt;td>Yes&lt;/td>
&lt;td>Yes&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>load-balancing for LACP support&lt;/td>
&lt;td>No&lt;/td>
&lt;td>Yes&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Ethtool link monitoring&lt;/td>
&lt;td>Yes&lt;/td>
&lt;td>Yes&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>ARP link monitoring&lt;/td>
&lt;td>Yes&lt;/td>
&lt;td>Yes&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>NS/NA (IPv6) link monitoring&lt;/td>
&lt;td>No&lt;/td>
&lt;td>Yes&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>ports up/down delays&lt;/td>
&lt;td>Yes&lt;/td>
&lt;td>Yes&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>port priorities and stickiness (“primary”option enhancement)&lt;/td>
&lt;td>No&lt;/td>
&lt;td>Yes&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>separate per-port link monitoring setup&lt;/td>
&lt;td>No&lt;/td>
&lt;td>Yes&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>multiple link monitoring setup&lt;/td>
&lt;td>Limited&lt;/td>
&lt;td>Yes&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>lockless Tx/Rx path&lt;/td>
&lt;td>No (rwlock)&lt;/td>
&lt;td>Yes (RCU)&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>VLAN support&lt;/td>
&lt;td>Yes&lt;/td>
&lt;td>Yes&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>user-space runtime control&lt;/td>
&lt;td>Limited&lt;/td>
&lt;td>Full&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Logic in user-space&lt;/td>
&lt;td>No&lt;/td>
&lt;td>Yes&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Extensibility&lt;/td>
&lt;td>Hard&lt;/td>
&lt;td>Easy&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Modular design&lt;/td>
&lt;td>No&lt;/td>
&lt;td>Yes&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Performance overhead&lt;/td>
&lt;td>Low&lt;/td>
&lt;td>Very Low&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>D-Bus interface&lt;/td>
&lt;td>No&lt;/td>
&lt;td>Yes&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>multiple device stacking&lt;/td>
&lt;td>Yes&lt;/td>
&lt;td>Yes&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>zero config using LLDP&lt;/td>
&lt;td>No&lt;/td>
&lt;td>(in planning)&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>NetworkManager support&lt;/td>
&lt;td>Yes&lt;/td>
&lt;td>Yes&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table></description></item><item><title>Docs: Bridge</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2.kernel%E5%86%85%E6%A0%B8/8.network-%E7%AE%A1%E7%90%86/linux-%E7%BD%91%E7%BB%9C%E6%A0%88%E7%AE%A1%E7%90%86/linux-%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87%E8%AF%A6%E8%A7%A3/bridge/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2.kernel%E5%86%85%E6%A0%B8/8.network-%E7%AE%A1%E7%90%86/linux-%E7%BD%91%E7%BB%9C%E6%A0%88%E7%AE%A1%E7%90%86/linux-%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87%E8%AF%A6%E8%A7%A3/bridge/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>原文链接：&lt;a href="https://mp.weixin.qq.com/s/JnKz1fUgZmGdvfxOm2ehZg">聊聊 Linux 上软件实现的 “交换机” - Bridge！&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>大家好，我是飞哥！&lt;/p>
&lt;p>Linux 中的 veth 是一对儿能互相连接、互相通信的虚拟网卡。通过使用它，我们可以让 Docker 容器和母机通信，或者是在两个 Docker 容器中进行交流。参见&lt;a href="https://mp.weixin.qq.com/s?__biz=MjM5Njg5NDgwNA==&amp;amp;mid=2247486424&amp;amp;idx=1&amp;amp;sn=d66fe4ebf1cd9e5079606f71a0169697&amp;amp;scene=21#wechat_redirect">《轻松理解 Docker 网络虚拟化基础之 veth 设备！》&lt;/a>。&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/50a2c4de-0e0a-4411-b386-112edd0a3fdf/640" alt="">&lt;/p>
&lt;p>不过在实际中，我们会想在一台物理机上我们虚拟出来几个、甚至几十个容器，以求得充分压榨物理机的硬件资源。但这样带来的问题是大量的容器之间的网络互联。很明显上面简单的 veth 互联方案是没有办法直接工作的，我们该怎么办？？？&lt;/p>
&lt;p>回头想一下，在物理机的网络环境中，多台不同的物理机之间是如何连接一起互相通信的呢？没错，那就是以太网交换机。同一网络内的多台物理机通过交换机连在一起，然后它们就可以相互通信了。&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/50a2c4de-0e0a-4411-b386-112edd0a3fdf/640" alt="">&lt;/p>
&lt;p>在我们的网络虚拟化环境里，和物理网络中的交换机一样，也需要这样的一个软件实现的设备。它需要有很多个虚拟端口，能把更多的虚拟网卡连接在一起，通过自己的转发功能让这些虚拟网卡之间可以通信。在 Linux 下这个软件实现交换机的技术就叫做 bridge（再强调下，这是纯软件实现的）。&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/50a2c4de-0e0a-4411-b386-112edd0a3fdf/640" alt="">&lt;/p>
&lt;p>各个 Docker 容器都通过 veth 连接到 bridge 上，bridge 负责在不同的 “端口” 之间转发数据包。这样各个 Docker 之间就可以互相通信了！&lt;/p>
&lt;p>今天我们来展开聊聊 bridge 的详细工作过程。&lt;/p>
&lt;h2 id="一如何使用-bridge">一、如何使用 bridge&lt;/h2>
&lt;p>在分析它的工作原理之前，很有必要先来看一看网桥是如何使用的。&lt;/p>
&lt;p>为了方便大家理解，接下来我们通过动手实践的方式，在一台 Linux 上创建一个小型的虚拟网络出来，并让它们之间互相通信。&lt;/p>
&lt;h3 id="11-创建两个不同的网络">1.1 创建两个不同的网络&lt;/h3>
&lt;p>Bridge 是用来连接两个不同的虚拟网络的，所以在准备实验 bridge 之前我们得先需要用 net namespace 构建出两个不同的网络空间来。&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/50a2c4de-0e0a-4411-b386-112edd0a3fdf/640" alt="">&lt;/p>
&lt;p>具体的创建过程如下。我们通过 ip netns 命令创建 net namespace。首先创建一个 net1：&lt;/p>
&lt;p>&lt;code># ip netns add net1&lt;/code>&lt;/p>
&lt;p>接下来创建一对儿 veth 出来，设备名分别是 veth1 和 veth1_p。并把其中的一头 veth1 放到这个新的 netns 中。&lt;/p>
&lt;p>&lt;code># ip link add veth1 type veth peer name veth1_p # ip link set veth1 netns net1&lt;/code>&lt;/p>
&lt;p>因为我们打算是用这个 veth1 来通信，所以需要为其配置上 ip，并把它启动起来。&lt;/p>
&lt;p>&lt;code># ip netns exec net1 ip addr add 192.168.0.101/24 dev veth1 # ip netns exec net1 ip link set veth1 up&lt;/code>&lt;/p>
&lt;p>查看一下，上述的配置是否成功。&lt;/p>
&lt;p>&lt;code># ip netns exec net1 ip link list # ip netns exec net1 ifconfig&lt;/code>&lt;/p>
&lt;p>重复上述步骤，在创建一个新的 netns 出来，命名分别为。&lt;/p>
&lt;ul>
&lt;li>netns: net2&lt;/li>
&lt;li>veth pair: veth2, veth2_p&lt;/li>
&lt;li>ip: 192.168.0.102&lt;/li>
&lt;/ul>
&lt;p>好了，这样我们就在一台 Linux 就创建出来了两个虚拟的网络环境。&lt;/p>
&lt;h3 id="12-把两个网络连接到一起">1.2 把两个网络连接到一起&lt;/h3>
&lt;p>在上一个步骤中，我们只是创建出来了两个独立的网络环境而已。这个时候这两个环境之间还不能互相通信。我们需要创建一个虚拟交换机 - bridge， 来把这两个网络环境连起来。&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/50a2c4de-0e0a-4411-b386-112edd0a3fdf/640" alt="">&lt;/p>
&lt;p>创建过程如下。创建一个 bridge 设备, 把刚刚创建的两对儿 veth 中剩下的两头 “插” 到 bridge 上来。&lt;/p>
&lt;p>&lt;code># brctl addbr br0 # ip link set dev veth1_p master br0 # ip link set dev veth2_p master br0 # ip addr add 192.168.0.100/24 dev br0&lt;/code>&lt;/p>
&lt;p>再为 bridge 配置上 IP，并把 bridge 以及插在其上的 veth 启动起来。&lt;/p>
&lt;p>&lt;code># ip link set veth1_p up # ip link set veth2_p up # ip link set br0 up&lt;/code>&lt;/p>
&lt;p>查看一下当前 bridge 的状态，确认刚刚的操作是成功了的。&lt;/p>
&lt;p>&lt;code># brctl show bridge name     bridge id               STP enabled     interfaces br0             8000.4e931ecf02b1       no              veth1_p                                                         veth2_p&lt;/code>&lt;/p>
&lt;h3 id="13-网络连通测试">1.3 网络连通测试&lt;/h3>
&lt;p>激动人心的时刻就要到了，我们在 net1 里（通过指定 ip netns exec net1 以及 -I veth1），ping 一下 net2 里的 IP（192.168.0.102）试试。&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/50a2c4de-0e0a-4411-b386-112edd0a3fdf/640" alt="">&lt;/p>
&lt;pre>&lt;code># ip netns exec net1 ping 192.168.0.102 -I veth1PING 192.168.0.102 (192.168.0.102) from 192.168.0.101 veth1: 56(84) bytes of data.64 bytes from 192.168.0.102: icmp_seq=1 ttl=64 time=0.037 ms64 bytes from 192.168.0.102: icmp_seq=2 ttl=64 time=0.008 ms64 bytes from 192.168.0.102: icmp_seq=3 ttl=64 time=0.005 ms
&lt;/code>&lt;/pre>
&lt;p>哇塞，通了通了！！&lt;/p>
&lt;p>这样，我们就在一台 Linux 上虚拟出了 net1 和 net2 两个不同的网络环境。我们还可以按照这种方式创建更多的网络，都可以通过一个 bridge 连接到一起。这就是 Docker 中网络系统工作的基本原理。&lt;/p>
&lt;h2 id="二bridge-是如何创建出来的">二、Bridge 是如何创建出来的&lt;/h2>
&lt;p>在内核中，bridge 是由两个相邻存储的内核对象来表示的。&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/50a2c4de-0e0a-4411-b386-112edd0a3fdf/640" alt="">&lt;/p>
&lt;p>我们先看下它是如何被创建出来的。内核中创建 bridge 的关键代码在 br_add_bridge 这个函数里。&lt;/p>
&lt;p>`//file:net/bridge/br_if.c
int br_add_bridge(struct net _net, const char _name)
{
 // 申请网桥设备，并用  br_dev_setup  来启动它
 dev = alloc_netdev(sizeof(struct net_bridge), name,
      br_dev_setup);&lt;/p>
&lt;p>dev_net_set(dev, net);
 dev-&amp;gt;rtnl_link_ops = &amp;amp;br_link_ops;&lt;/p>
&lt;p>// 注册网桥设备
 res = register_netdev(dev);
 if (res)
  free_netdev(dev);
 return res;
}&lt;/p>
&lt;p>`&lt;/p>
&lt;p>上述代码中注册网桥的关键代码是 alloc_netdev 这一行。在这个函数里，将申请网桥的内核对象 net_device。在这个函数调用里要注意两点。&lt;/p>
&lt;ul>
&lt;li>
&lt;ol>
&lt;li>第一个参数传入了 struct net_bridge 的大小&lt;/li>
&lt;/ol>
&lt;/li>
&lt;li>
&lt;ol start="2">
&lt;li>第三个参数传入的 br_dev_setup 是一个函数。&lt;/li>
&lt;/ol>
&lt;/li>
&lt;/ul>
&lt;p>带着这两点注意事项，我们进入到 alloc_netdev 的实现中。&lt;/p>
&lt;p>&lt;code>//file: include/linux/netdevice.h #define alloc_netdev(sizeof_priv, name, setup) \  alloc_netdev_mqs(sizeof_priv, name, setup, 1, 1)&lt;/code>&lt;/p>
&lt;p>好吧，竟然是个宏。那就得看 alloc_netdev_mqs 了。&lt;/p>
&lt;p>`//file: net/core/dev.c
struct net_device _alloc_netdev_mqs(int sizeof_priv, &amp;hellip;，void (_setup)(struct net_device *))
{
 // 申请网桥设备
 alloc_size = sizeof(struct net_device);
 if (sizeof_priv) {
  alloc_size = ALIGN(alloc_size, NETDEV_ALIGN);
  alloc_size += sizeof_priv;
 }&lt;/p>
&lt;p>p = kzalloc(alloc_size, GFP_KERNEL);
 dev = PTR_ALIGN(p, NETDEV_ALIGN);&lt;/p>
&lt;p>// 网桥设备初始化
 dev-&amp;gt;&amp;hellip; = &amp;hellip;;
 setup(dev); //setup 是一个函数指针，实际使用的是  br_dev_setup&lt;/p>
&lt;p>&amp;hellip;
}&lt;/p>
&lt;p>`&lt;/p>
&lt;p>在上述代码中。kzalloc 是用来在内核态申请内核内存的。需要注意的是，申请的内存大小是一个 struct net_device 再加上一个 struct net_bridge（第一个参数传进来的）。一次性就申请了两个内核对象，这说明&lt;strong>bridge 在内核中是由两个内核数据结构来表示的，分别是 struct net_device 和 struct net_bridge。&lt;/strong>&lt;/p>
&lt;p>申请完了一家紧接着调用 setup，这实际是外部传入的 br_dev_setup 函数。在这个函数内部进行进一步的初始化。&lt;/p>
&lt;p>&lt;code>//file: net/bridge/br_device.c void br_dev_setup(struct net_device *dev) {  struct net_bridge *br = netdev_priv(dev);  dev-&amp;gt;... = ...;  br-&amp;gt;... = ...;  ... }&lt;/code>&lt;/p>
&lt;p>&lt;strong>总之，brctl addbr br0 命令主要就是完成了 bridge 内核对象（struct net_device 和 struct net_bridge）的申请以及初始化。&lt;/strong>&lt;/p>
&lt;h2 id="三添加设备">三、添加设备&lt;/h2>
&lt;p>调用 &lt;code>brctl addif br0 veth0&lt;/code> 给网桥添加设备的时候，会将 veth 设备以虚拟的方式连到网桥上。当添加了若干个 veth 以后，内核中对象的大概逻辑图如下。&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/50a2c4de-0e0a-4411-b386-112edd0a3fdf/640" alt="">&lt;/p>
&lt;p>其中 veth 是由 struct net_device 来表示，bridge 的虚拟插口是由 struct net_bridge_port 来表示。我们接下来看看源码，是如何达成上述的逻辑结果的。&lt;/p>
&lt;p>添加设备会调用到 net/bridge/br_if.c 下面的 br_add_if。&lt;/p>
&lt;p>`//file: net/bridge/br_if.c
int br_add_if(struct net_bridge _br, struct net_device _dev)
{
 //  申请一个  net_bridge_port
 struct net_bridge_port *p;
 p = new_nbp(br, dev);&lt;/p>
&lt;p>//  注册设备帧接收函数
 err = netdev_rx_handler_register(dev, br_handle_frame, p);&lt;/p>
&lt;p>//  添加到  bridge  的已用端口列表里
 list_add_rcu(&amp;amp;p-&amp;gt;list, &amp;amp;br-&amp;gt;port_list);&lt;/p>
&lt;p>&amp;hellip;&amp;hellip;
}&lt;/p>
&lt;p>`&lt;/p>
&lt;p>这个函数中的第二个参数 dev 传入的是要添加的设备。在本文中，就可以认为是 veth 的其中一头。比较关键的是 net_bridge_port 这个结构体，它模拟的是物理交换机上的一个插口。它起到一个连接的作用，把 veth 和 bridge 给连接了起来。见 new_nbp 源码如下：&lt;/p>
&lt;p>`//file: net/bridge/br_if.c
static struct net_bridge_port _new_nbp(struct net_bridge _br,
           struct net_device _dev)
{
 // 申请插口对象
 struct net_bridge_port _p;
 p = kzalloc(sizeof(*p), GFP_KERNEL);&lt;/p>
&lt;p>// 初始化插口
 index = find_portno(br);
 p-&amp;gt;br = br;
 p-&amp;gt;dev = dev;
 p-&amp;gt;port_no = index;
 &amp;hellip;
}&lt;/p>
&lt;p>`&lt;/p>
&lt;p>在 new_nbp 中，先是申请了代表插口的内核对象。find_portno 是在当前 bridge 下寻找一个可用的端口号。接下来插口对象通过 &lt;code>p-&amp;gt;br = br&lt;/code> 和 bridge 设备关联了起来，通过 &lt;code>p-&amp;gt;dev = dev&lt;/code> 和代表 veth 设备的 dev 对象也建立了联系。&lt;/p>
&lt;p>在 br_add_if 中还调用 netdev_rx_handler_register 注册了设备帧接收函数，设置 veth 上的 rx_handler 为 br_handle_frame。&lt;strong>后面在接收包的时候会回调到它&lt;/strong>。&lt;/p>
&lt;p>&lt;code>//file: int netdev_rx_handler_register(struct net_device *dev,           rx_handler_func_t *rx_handler,           void *rx_handler_data) {  ...   rcu_assign_pointer(dev-&amp;gt;rx_handler_data, rx_handler_data);  rcu_assign_pointer(dev-&amp;gt;rx_handler, rx_handler); }&lt;/code>&lt;/p>
&lt;h2 id="四数据包处理过程">四、数据包处理过程&lt;/h2>
&lt;p>在&lt;a href="https://mp.weixin.qq.com/s?__biz=MjM5Njg5NDgwNA==&amp;amp;mid=2247484058&amp;amp;idx=1&amp;amp;sn=a2621bc27c74b313528eefbc81ee8c0f&amp;amp;scene=21#wechat_redirect">图解 Linux 网络包接收过程&lt;/a>中我们讲到过接收包的完整流程。数据包会被网卡先从到 RingBuffer 中，然后依次经过硬中断、软中断处理。在软中断中再依次把包送到设备层、协议栈，最后唤醒应用程序。&lt;/p>
&lt;p>不过，拿 veth 设备来举例，如果它连接到了网桥上的话，在设备层的 __netif_receive_skb_core 函数中和上述过程有所不同。连在 bridge 上的 veth 在收到数据包的时候，不会进入协议栈，而是会进入网桥处理。网桥找到合适的转发口（另一个 veth），通过这个 veth 把数据转发出去。工作流程如下图。&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/50a2c4de-0e0a-4411-b386-112edd0a3fdf/640" alt="">&lt;/p>
&lt;p>我们从 veth1_p 设备的接收看起，所有的设备的接收都一样，都会进入 __netif_receive_skb_core 设备层的关键函数。&lt;/p>
&lt;p>`//file: net/core/dev.c
static int __netif_receive_skb_core(struct sk_buff *skb, bool pfmemalloc)
{
 &amp;hellip;&lt;/p>
&lt;p>// tcpdump  抓包点
 list_for_each_entry_rcu(&amp;hellip;);&lt;/p>
&lt;p>//  执行设备的  rx_handler（也就是  br_handle_frame）
 rx_handler = rcu_dereference(skb-&amp;gt;dev-&amp;gt;rx_handler);
 if (rx_handler) {
  switch (rx_handler(&amp;amp;skb)) { 
  case RX_HANDLER_CONSUMED:
   ret = NET_RX_SUCCESS;
   goto unlock;
  }
 }&lt;/p>
&lt;p>//  送往协议栈
 //&amp;hellip;&lt;/p>
&lt;p>unlock:
 rcu_read_unlock();
out:
 return ret;
}&lt;/p>
&lt;p>`&lt;/p>
&lt;p>在 __netif_receive_skb_core 中先是过了 tcpdump 的抓包点，然后查找和执行了 rx_handler。在上面小节中我们看到，把 veth 连接到网桥上的时候，veth 对应的内核对象 dev 中的 rx_handler 被设置成了 br_handle_frame。&lt;strong>所以连接到网桥上的 veth 在收到包的时候，会将帧送入到网桥处理函数 br_handle_frame 中&lt;/strong>。&lt;/p>
&lt;p>另外要注意的是网桥函数处理完的话，一般来说就 goto unlock 退出了。和普通的网卡数据包接收相比，并不会往下再送到协议栈了。&lt;/p>
&lt;p>接着来看下网桥是咋工作的吧，进入到 br_handle_frame 中来搜寻。&lt;/p>
&lt;p>`//file: net/bridge/br_input.c
rx_handler_result_t br_handle_frame(struct sk_buff **pskb)
{
 &amp;hellip;&lt;/p>
&lt;p>forward:
 NF_HOOK(NFPROTO_BRIDGE, NF_BR_PRE_ROUTING, skb, skb-&amp;gt;dev, NULL,
   br_handle_frame_finish);
}&lt;/p>
&lt;p>`&lt;/p>
&lt;p>上面我对 br_handle_frame 的逻辑进行了充分的简化，简化后它的核心就是调用 br_handle_frame_finish。同样 br_handle_frame_finish 也有点小复杂。本文中，我们主要想了解的 Docker 场景下 bridge 上的 veth 设备转发。所以根据这个场景，我又对该函数进行了充分的简化。&lt;/p>
&lt;p>`//file: net/bridge/br_input.c
int br_handle_frame_finish(struct sk_buff _skb)
{  
 //  获取  veth  所连接的网桥端口、以及网桥设备
 struct net_bridge_port _p = br_port_get_rcu(skb-&amp;gt;dev);
 br = p-&amp;gt;br;&lt;/p>
&lt;p>//  更新和查找转发表
 struct net_bridge_fdb_entry *dst;
 br_fdb_update(br, p, eth_hdr(skb)-&amp;gt;h_source, vid);
 dst = __br_fdb_get(br, dest, vid)&lt;/p>
&lt;p>//  转发
 if (dst) {
  br_forward(dst-&amp;gt;dst, skb, skb2);
 } 
}&lt;/p>
&lt;p>`&lt;/p>
&lt;p>在硬件中，交换机和集线器的主要区别就是它会智能地把数据送到正确的端口上去，而不会像集线器那样给所有的端口都群发一遍。所以在上面的函数中，我们看到了更新和查找转发表的逻辑。这就是网桥在学习，它会根据它的自学习结果来工作。&lt;/p>
&lt;p>在找到要送往的端口后，下一步就是调用 br_forward =&amp;gt; __br_forward 进入真正的转发流程。&lt;/p>
&lt;p>`//file: net/bridge/br_forward.c
static void __br_forward(const struct net_bridge_port _to, struct sk_buff _skb)
{
 //  将  skb  中的  dev  改成新的目的  dev
 skb-&amp;gt;dev = to-&amp;gt;dev;&lt;/p>
&lt;p>NF_HOOK(NFPROTO_BRIDGE, NF_BR_FORWARD, skb, indev, skb-&amp;gt;dev,
  br_forward_finish);
}&lt;/p>
&lt;p>`&lt;/p>
&lt;p>在 __br_forward 中，将 skb 上的设备 dev 改为了新的目的 dev。&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/50a2c4de-0e0a-4411-b386-112edd0a3fdf/640" alt="">&lt;/p>
&lt;p>然后调用 br_forward_finish 进入发送流程。在 br_forward_finish 里会依次调用 br_dev_queue_push_xmit、dev_queue_xmit。&lt;/p>
&lt;p>&lt;code>//file: net/bridge/br_forward.c int br_forward_finish(struct sk_buff *skb) {  return NF_HOOK(NFPROTO_BRIDGE, NF_BR_POST_ROUTING, skb, NULL, skb-&amp;gt;dev,          br_dev_queue_push_xmit); } int br_dev_queue_push_xmit(struct sk_buff *skb) {  dev_queue_xmit(skb);  ... }&lt;/code>&lt;/p>
&lt;p>dev_queue_xmit 就是发送函数，在上一篇&lt;a href="https://mp.weixin.qq.com/s?__biz=MjM5Njg5NDgwNA==&amp;amp;mid=2247486424&amp;amp;idx=1&amp;amp;sn=d66fe4ebf1cd9e5079606f71a0169697&amp;amp;scene=21#wechat_redirect">《轻松理解 Docker 网络虚拟化基础之 veth 设备！》&lt;/a>中我们介绍过，后续的发送过程就是 dev_queue_xmit =&amp;gt; dev_hard_start_xmit =&amp;gt; veth_xmit。在 veth_xmit 中会获取到当前 veth 的对端，然后把数据给它发送过去。&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/50a2c4de-0e0a-4411-b386-112edd0a3fdf/640" alt="">&lt;/p>
&lt;p>至此，bridge 上的转发流程就算是完毕了。要注意到的是，整个 bridge 的工作的源码都是在 net/core/dev.c 或 net/bridge 目录下。都是在设备层工作的。这也就充分印证了我们经常说的 bridge（物理交换机也一样） 是二层上的设备。&lt;/p>
&lt;p>接下来，收到网桥发过来数据的 veth 会把数据包发送给它的对端 veth2，veth2 再开始自己的数据包接收流程。&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/50a2c4de-0e0a-4411-b386-112edd0a3fdf/640" alt="">&lt;/p>
&lt;h2 id="五总结">五、总结&lt;/h2>
&lt;p>所谓网络虚拟化，其实用一句话来概括就是&lt;strong>用软件来模拟实现真实的物理网络连接&lt;/strong>。&lt;/p>
&lt;p>Linux 内核中的 bridge 模拟实现了物理网络中的交换机的角色。和物理网络类似，可以将虚拟设备插入到 bridge 上。不过和物理网络有点不一样的是，一对儿 veth 插入 bridge 的那端其实就不是设备了，可以理解为退化成了一个网线插头。&lt;/p>
&lt;p>当 bridge 接入了多对儿 veth 以后，就可以通过自身实现的网络包转发的功能来让不同的 veth 之间互相通信了。&lt;/p>
&lt;p>回到 Docker 的使用场景上来举例，完整的 Docker 1 和 Docker 2 通信的过程是这样的：&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/50a2c4de-0e0a-4411-b386-112edd0a3fdf/640" alt="">&lt;/p>
&lt;p>大致步骤是：&lt;/p>
&lt;ul>
&lt;li>1.Docker1 往 veth1 上发送数据&lt;/li>
&lt;li>
&lt;ol start="2">
&lt;li>由于 veth1_p 是 veth1 的 pair， 所以这个虚拟设备上可以收到包&lt;/li>
&lt;/ol>
&lt;/li>
&lt;li>3.veth 收到包以后发现自己是连在网桥上的，于是乎进入网桥处理。在网桥设备上寻找要转发到的端口，这时找到了 veth2_p 开始发送。网桥完成了自己的转发工作&lt;/li>
&lt;li>4.veth2 作为 veth2_p 的对端，收到了数据包&lt;/li>
&lt;li>5.Docker2 里的就可以从 veth2 设备上收到数据了&lt;/li>
&lt;/ul>
&lt;p>觉得这个流程图还不过瘾？那我们再继续拉大视野，从两个 Docker 的用户态来开始看一看。&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/50a2c4de-0e0a-4411-b386-112edd0a3fdf/640" alt="">&lt;/p>
&lt;p>Docker 1 在需要发送数据的时候，先通过 send 系统调用发送，这个发送会执行到协议栈进行协议头的封装等处理。经由邻居子系统找到要使用的设备（veth1）后，从这个设备将数据发送出去，veth1 的对端 veth1_p 会收到数据包。&lt;/p>
&lt;p>收到数据的 veth1_p 是一个连接在 bridge 上的设备，这时候 bridge 会接管该 veth 的数据接收过程。从自己连接的所有设备中查找目的设备。找到 veth2_p 以后，调用该设备的发送函数将数据发送出去。同样 veth2_p 的对端 veth2 即将收到数据。&lt;/p>
&lt;p>其中 veth2 收到数据后，将和 lo、eth0 等设备一样，进入正常的数据接收处理过程。Docker 2 中的用户态进程将能够收到 Docker 1 发送过来的数据了就。&lt;/p>
&lt;p>怎么样，今天你有没有更深入地理解了 Docker 的工作原理呢？最后转发到朋友圈，让你的朋友们也一起来学学吧~~~&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/50a2c4de-0e0a-4411-b386-112edd0a3fdf/640" alt="">&lt;/p></description></item></channel></rss>