<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>断念梦 – 3.集群与分布式</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/3.%E9%9B%86%E7%BE%A4%E4%B8%8E%E5%88%86%E5%B8%83%E5%BC%8F/</link><description>Recent content in 3.集群与分布式 on 断念梦</description><generator>Hugo -- gohugo.io</generator><atom:link href="https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/3.%E9%9B%86%E7%BE%A4%E4%B8%8E%E5%88%86%E5%B8%83%E5%BC%8F/index.xml" rel="self" type="application/rss+xml"/><item><title>Docs: 1.1.Keepalived 介绍</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/3.%E9%9B%86%E7%BE%A4%E4%B8%8E%E5%88%86%E5%B8%83%E5%BC%8F/keepalived/1.1.keepalived-%E4%BB%8B%E7%BB%8D/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/3.%E9%9B%86%E7%BE%A4%E4%B8%8E%E5%88%86%E5%B8%83%E5%BC%8F/keepalived/1.1.keepalived-%E4%BB%8B%E7%BB%8D/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>官网：&lt;a href="http://www.keepalived.org/">http://www.keepalived.org/&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;ol>
&lt;li>Active/passive 模式&lt;/li>
&lt;li>Keepalived 是 vrrp 协议在 Linux 主机上以守护进程方式的实现&lt;/li>
&lt;li>能够根据配置文件自动生成 ipvs 规则&lt;/li>
&lt;li>对各 RS 做健康状态检测&lt;/li>
&lt;/ol>
&lt;h1 id="万字长文带你从-0-学习-keepalived">万字长文带你从 0 学习 Keepalived&lt;/h1>
&lt;p>负载均衡器（Load Balancer, LB ）是一组能够将 IP 数据流以负载均衡形式转发到多台物理服务器的集成软件。有硬件负载均衡器和软件负载均衡器之分，硬件负载均衡器主要是在访问网络和服务器之间配置物理负载均衡设备，客户端对物理服务器的访问请求首先会抵达负载均衡设备，然后再由负载均衡设备根据一定的负载算法转发到后端服务器。相比而言，软件负载均衡器不需要特定的物理设备，只需在相应的操作系统上部署具有负载均衡功能的软件即可。&lt;/p>
&lt;p>在 Openstack 高可用集群部署中，服务的负载均衡和高可用主要有两种主流的实现方案，即 HAProxy+ Keepalived 和 Pacemaker+HAProxy 方案。由于 OpenStack 服务组件多样，不同服务均需要进行特定的高可用设计，并且从集群资源统一调度和集群稳定性的角度考虑，后一种方案是多数 OpenStack 厂商的高可用部署方案首选，但是选用后一方案并不意味着 Keepalived 在 OpenStack 高可用集群部署中不被使用。由于 Keepalived 的主要作用之一是进行虚拟路由的故障切换，其在 Neutron 的 L3 高可用设计与实现中起着举足轻重的作用。&lt;/p>
&lt;h1 id="11-keepalived-及-lvs-概述">1.1 keepalived 及 LVS 概述&lt;/h1>
&lt;p>Keepalived 的项目实现的主要目标是简化 LVS 项目的配置并增强其稳定性，即 Keepalived 是对 LVS 项目的扩展增强。&lt;/p>
&lt;p>Keepalived 为 Linux 系统和基于 Linux 的架构提供了负载均衡和高可用能力，其负载均衡功能主要源自集成在 Linux 内核中的 LVS 项目模块 IPVS( IP Virtual Server ），基于 IPVS 提供的 4 层 TCP/IP 协议负载均衡， Keepalived 也具备负载均衡的功能，此外， Keepalived 还实现了基于多层 TCP/IP 协议（ 3 层、4 层、5/7 层）的健康检查机制，因此， Keepalived 在 LVS 负载均衡功能的基础上，还提供了 LVS 集群物理服务器池健康检查和故障节点隔离的功能。&lt;/p>
&lt;p>除了扩展 LVS 的负载均衡服务器健康检查能力， Keepalived 还基于虚拟路由冗余协议（ Virtual Route Redundancy Protocol, VRRP )实现了 LVS 负载均衡服务器的故障切换转移，即 Keepalived 还实现了 LVS 负载均衡器的高可用性。Keepalived 就是为 LVS 集群节点提供健康检查和为 LVS 负载均衡服务器提供故障切换的用户空间进程。&lt;/p>
&lt;p>图为 Keepalived 的原理架构图，从图中可以看到， Keepalived 的多数核心功能模块均位于用户空间，而仅有 IPVS 和 NETLINK 模块位于内核空间，但是这两个内核模块正是 Keepalived 实现负载均衡和路由高可用的核心模块，其中的 NETLINK 主要用于提供高级路由及其相关的网络功能。Keepalived 的大部分功能模块位于用户空间，其中几个核心功能模块的介绍如下。&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/watgs2/1616132514380-d0730061-c06c-433e-8b33-8868d6966373.jpeg" alt="">&lt;/p>
&lt;ul>
&lt;li>WatchDog ：其主要负责监控 Checkers 和 VRRP 子进程的运行状况。&lt;/li>
&lt;li>Checkers ：此功能模块主要负责真实服务器的健康检查（ HealthChecking )，是 Keepalived 最主要的功能之一，因为 HealthChecking 是负载均衡功能稳定运行的基础， LVS 集群节点的故障隔离和重新加入均依赖于 HealthChecking 的结果。&lt;/li>
&lt;li>VRRPStack ：此功能模块主要负责负载均衡器之间的故障切换，如果集群架构中仅使用一个 LVS 负载均衡器，由于本身不具备故障切换的条件，则 VRRPStack 不是必须的。&lt;/li>
&lt;li>IPVS Wrapper ：此模块主要用来发送设定的规则到内核 IPVS 代码。Keepalived 的设计目标是构建高可用的 LVS 负载均衡群集， Keepalived 在运行中将会通过 IPVSWrapper 模块调用 IPVSAdmin 工具来创建虚拟服务器，检查和管理 LVS 集群物理服务器池。&lt;/li>
&lt;li>Netlink Reflector ：此功能模块主要用来设定 VRRP 的 VIP 地址并提供相关的网络功能，该模块通过与内核中的 NETLINK 模块交互，从而为 Keepalived 提供路由高可用功能。&lt;/li>
&lt;/ul>
&lt;p>从 Keepalived 的实现原理和功能来看， Keepalived 是开源负载均衡项目 LVS 的增强和虚拟路由协议 VRRP 实现的集合，即 Keepalived 通过整合和增强 LVS 与 VRRP 来提供高可用的负载均衡系统架构。&lt;/p>
&lt;h1 id="12-keepalived-工作原理">1.2 KeepAlived 工作原理&lt;/h1>
&lt;p>Keepalived 本质上是提供数据流转发与服务器健康检查并具备故障切换的高可用路由，而数据转发与健康检查是对 LVS 功能的扩展和增强，因此也可以认为 Keepalived 是运行在用户空间的 LVS 路由（LVS Router) 进程。在实际应用中， Keepalived 通常部署在两台主备或一主多备的服务器上，即 Keepalived 进程既运行在 Active/Master 状态的 LVS Router 中，也运行在 Passive/Slave 状态的 LVS Router 中，而所有运行 Keepalived 进程的 LVS Router 都遵循虚拟路由冗余协议 VRRP。在 VRRP 的协议框架下，作为 Master 的 Router 将会处理两个主要任务，即转发客户端访问请求到后端物理服务器以进行负载均衡和周期性的发送 VRRP 协议报文，而作为 Slave 的 Routers 则负责接收 VRRP 报文，如果某一时刻作为 Slave 的 Routers 接收 VRRP 报文失败，则认为 Master Router 故障， 并从 Slave Routers 中重新选举产生一个新的 Master Router 。&lt;/p>
&lt;p>Keepalived 是一个与 LVS Router 相关的控制进程，在 RHEL7 /Centos7 系统中，Keepalived 由 Systemctl 命令通过读取/etc/keepalived/keepalived.conf 配置文件来启动。在遵循 VRRP 协议的 Master Router 中， Keepalived 进程会启动内核中的 LVS 服务以创建虚拟服务器，并根据配置拓扑对服务运行状况进行监控。此外，Master Router 还会向 Slave Routers 发送周期性的 VRRP 广播报文，而 Master Router 运行状态的正常与否是由 Slave Routers 上的 VRRP 实例决定的。如果在用户预置的时间段内 Slave Router 不能接收到 VRRP 报文，则 Keepalived 认为 Master Router 故障，同时触发 LVS Router 的 Failover 操作。&lt;/p>
&lt;p>在 Failover 的过程中， Keepalived 创建的虚拟服务器会被清除，新的 Master Router 将接管 VIP 发送 ARP 信息、设置 IPVS Table 记录条目（Virtual Server）以及物理服务器的健康检查和发送 VRRP 广播报文。Keepalived 的 Failover 操作针对的是四层 TCP/ IP 协议，即传输层，因为 TCP 在传输层上进行的是基于链路连接的数据传输。所以，当服务器在响应 TCP 请求时，如果出现设置时间段的 Timeout，则 Keepalived 的健康检查机制将会监测到该情况并认为该服务器故障，然后将其从服务器池中移除（故障服务器隔离） 。图 3-4 是基于 Keepalived 设计的具有二层拓扑的负载均衡架构，该架构分为两个层次。第一层为负载均衡层，由一个 Active 和多个 Backup 的 LVS Routers 组成，其中，每个 LVS Router 都配置有两个网络接口，一个接入 Internet 网络，另一个接入内部私有网络， Active 的 LVS Router 在这两个网络接口间进行数据转发。在图 3-4 的负载均衡架构中，位于第一层的 LVS Routers 和第二层的物理服务器通过私网接口接人相同的局域网中， Active 的 LVSRouter 通过 NAT 技术将 Internet 数据流转发到私网物理服务器上，而这些位于第二层的物理服务器运行着最终响应请求的服务。&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/watgs2/1616132514345-97aedaa2-8dd5-40fa-a7bb-79f9c9fa0ac6.jpeg" alt="">&lt;/p>
&lt;p>位于二层私网中的服务器在与 Internet 交互时必须经过主 LVS Router 的 NAT 转发， 并且对于外部网络中的客户端而言，访问二层私网中的物理服务器就如访问同处 Internet 网络中的服务，因为从客户端的角度来看，访问请求的目的地址正是位于主 LVS Router 上的 VIP 地址，而该 VIP 与客户端地址处于相同网络中， VIP 还可以是管理员指定的互联网域名，如www.example.com 。VIP 在 Keepalived 的配置中通常被指定到一个或者多个虚拟服务器上，而虚拟服务器的主要任务便是监昕 VIP 及相应端口上的请求，当主 LVS Router 进行 Failover 操作的时候， VIP 会从一个 LVS Router 转移到另一个 LVS（因此 VIP 也称为浮动 IP)。&lt;/p>
&lt;p>在 Keepalived 负载均衡架构的 VIP 配置中，每个将 LVS Router 连接到 Internet 的物理网卡接口均可配置多个 VIP ，并且每个 VIP 对应着不同的 Virtual Server ，即多个 VirtualServers 可以同时监听相同物理网卡上的不同 VIP ，其中每个 VIP 都对应着不同的服务。例如， Linux 系统中的接口 eth0 将 LVS Router 连接到 Internet 中，则可以在 eth0 上配置一个地址为 192.168.115.100 的 VIP 以用于响应 HTTP 服务请求，同时还可以在 eth0 上配置另一个地址为 192.168.115.200 的 VIP 以用于响应 FTP 服务请求。在这里， HTTP 服务和 FTP 服务均对应着监听不同 VIP 的 Virtual Server 。在由一个 Active Router 和一个 Backup Router 组成的 Keepalived 负载均衡架构中， Active Router 的主要任务就是将 VIP 上的请求转发到选中的某个后端服务器上，具体服务器的选举机制则由 Keepalived 所支持的负载均衡算法来决定。&lt;/p>
&lt;p>此外， Active Router 还负责动态监控后端服务器上特定服务的健康状况，监控方式主要是 Keepalived 自带的三种健康检测机制，即简单 TCP 连接、HTTP 和 HTTPS。就简单 TCP 连接检测方式， Active Router 会周期性地对服务器上某个特定端口进行 TCP 连接，如果 TCP 连接超时或者中断则认为服务不可用，而对于 HTTP 和 HTTPS 检测方式， ActiveRouter 通过周期性地抓取（ Fetch ）请求 URL 并验证其内容来判断服务的可用性。与此同时， Backup Router 一直处于 Standby 状态， LVS router 的 Failover 由 VRRP 来处理。&lt;/p>
&lt;p>在 Keepalived 进程启动的时候，所有 LVS Routers 会加人一个用来接收和发送 VRRP 广播的多播组， 由于 VRRP 是一种基于优先级的协议，因此在启动之初优先级高的 LVS Router 会被选举为 Master Router ，而 Master Router 将会周期性地向多播组中的成员发送 VRRP 广播。如果多播组中的 Backup Routers 在一定时间内接收 VRRP 广播失败，则重新选举新的 Master Router ，新的 Master Router 将会接管 VIP 并广播地址解析协议（ Address ResolutionProtocol, ARP ）信息。而当故障 Router 重新恢复后，根据该 Router 的优先级情况，其可能恢复到 Master 状态也可能保持为 Backup 状态。&lt;/p>
&lt;p>图中的两层负载均衡架构是最常见的部署环境，主要用于很多数据源变化不是很频繁的数据请求服务中，如静态 Web 页面站点，因为后端独立服务器（Real Severs ）之间不会自动进行数据同步。图 3-5 为基于 Keepalived 的三层负载均衡架构，在三层负载均衡架构中，前端的 LVS Router 负责将访问请求转发到物理服务器（ Real Servers ）中，然后 Real Server 再通过网络形式访问可共享的数据源。&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/watgs2/1616132514381-c261d4f3-8895-48fb-b4c8-ea8a73ab2882.jpeg" alt="">&lt;/p>
&lt;p>对于数据请求比较繁忙的 FTP 站点，三层架构是最为理想的负载均衡架构，在这种架构下，可供访问的数据源集中存储在高可用的集群服务器上， Real Servers 通过 NFS 共享目录或者 Samba 文件共享等网络文件系统形式来访问数据。此外，类似的三层负载均衡架构在需要提供中心化及数据库事务处理高可用的 Web 站点中也被普遍使用，如果将 Keepalived 负载均衡器配置为 Active/Active 双活模式，则还可以将三层负载均衡架构同时用于提供 FTP 和 Web 数据库服务。&lt;/p>
&lt;h1 id="13-keepalived-的负载均衡算法">1.3 KeepAlived 的负载均衡算法&lt;/h1>
&lt;p>Keepalived 所使用的负载均调度机制由集成到内核中的 IPVS 模块提供， IPVS 是 LVS 项目的核心功能模块，其设计的主要目的之一就是解决单 IP 多服务器的工作环境，IPVS 模块使得基于 TCP/IP 传输层（ 第 4 层）的数据交换成为可能。在实际使用中， IPVS 会在内核中创建一个名为 IPVS Table 的表，该表记录了后端服务器的地址及服务运行状态，通过 IPVS Table, Keepalived 便可跟踪并将请求路由到后端物理服务器中， 即 LVS Router 利用此表将来自 Keepalived 虚拟服务器地址的请求转发到后端服务器池中，同时将后端服务器的处理结果转发给客户端。此外， IPVS table 的表结构主要取决于管理员对指定的虚拟服务器所设置的负载均衡算法， Keepalived 支持以下几种负载均衡算法。&lt;/p>
&lt;p>( 1 ) Round-Robin&lt;/p>
&lt;p>即所谓的轮询负载均衡，在这种算法中，服务请求会被依次转发到服务器池中的每一个服务器上，而不去评估服务器的当前负载或者处理能力，服务器池中的每一个服务器都被平等对待。如果使用 Round-Robin 负载均衡算法，每台后端服务器会轮询依次处理服务请求。&lt;/p>
&lt;p>( 2 ) Weighted Round-Robin&lt;/p>
&lt;p>即加权 Round-Robin 算法，是对 Round-Robin 算法的一种扩展。在这种算法中，请求被依次转发到每一台服务器上，但是当前负载较轻或者计算能力较大的服务器会被转发更多的请求，服务器的处理能力通过用户指定的权重因子来决定，权重因子可以根据负载信息动态上调或者下调。如果服务器的配置差别较大，导致不同服务器的处理能力相差较大，则加权的 Round-Robin 算法会是不错的选择，但是如果请求负载频繁变动，则权重较大的服务器可能会超负荷工作。&lt;/p>
&lt;p>( 3 ) Least-Connection&lt;/p>
&lt;p>即最少连接算法，在这种算法中，请求被转发到活动连接较少的服务器上。在 Keepalived 的实际使用中， LVS Router 一直在利用内核中的 IPVS Table 来记录后端服务器的活动连接，从而动态跟踪每个服务器的活动连接数。最少连接数算法是一种动态决策算法，它比较适合服务器池中每个成员的处理能力都大致相当，同时负载请求又频繁变化的场景， 如果不同服务器有不同的处理能力，则下面的加权最少连接数算法较为合适。&lt;/p>
&lt;p>( 4 ) Weighted Least-Connections&lt;/p>
&lt;p>即加权最少连接数算法，在这种算法中，路由会根据服务器的权重，转发更多的请求到连接数较少的服务器上。服务器的处理能力通过用户指定的权重因子来决定，权重因子可以根据负载信息动态上调或者下调。一般来说，服务器加权算法主要用于集群存在不同类型服务器，而服务器配置和处理能力相差较大的场景中。&lt;/p>
&lt;p>( 5) Destination Hash ScheduIing&lt;/p>
&lt;p>即目标地址哈希算法，通过在静态 Hash 表中查询目的 IP 地址来确定请求要转发的服务器，这类算法主要用于缓存代理服务器集群中。&lt;/p>
&lt;p>( 6 ) Source Hash Scheduling&lt;/p>
&lt;p>即源地址哈希算法，通过在静态 Hash 表中查询源 IP 地址来确定请求要转发的服务器，这类算法主要应用于存在多防火墙的 LVS Router 中。&lt;/p>
&lt;p>( 7 ) Shortest Expected Delay&lt;/p>
&lt;p>即最小延时算法，在这种算法中，请求被转发到具有最小连接响应延时的服务器上。&lt;/p>
&lt;h1 id="14-keepalived-路由方式">1.4 Keepalived 路由方式&lt;/h1>
&lt;p>（1） NAT&lt;/p>
&lt;p>图 3-6 为基于 NAT 路由实现的 Keepalived 负载均衡器，在 NAT 机制下，每个 LVS Router 需要两个网络接口。假设 eth0 为接人 Internet 的网络接口，则 eth0 上配置有一个真实的 IP 地址，同时还配置了一个浮动 IP 地址（Floating IP ）假设 eth1 为接入后端私有网络的接口， 则 eth1 上也配置有一个真实 IP 地址和一个浮动 IP 地址。在出现故障切换 Failover 的时候， 接人 Internet 的虚拟接口和接入私有网络的虚拟接口会同时切换到 Backup 的 LVSRouter 上，而为了不影响对 Internet 客户端的请求响应，位于私有网络中的后端服务器均使用 NAT 路由的浮动 IP 作为与主 LVS Router 通信的默认路由。&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/watgs2/1616132514427-959ff4e7-b87e-4b5f-a914-d6b110653af9.jpeg" alt="">&lt;/p>
&lt;p>对外提供服务的公有 VIP(Public Virtual IP Address ）和私有 NAT VIP(NAT Virtual IP Address）均被配置在物理网卡上而最佳的配置方式是将两个 VIP 各自配置到不同的物理网卡上，即在这种配置下，每个 LVS Router 节点最多只需两个物理网卡。在 NAT 路由转发中，主 LVS Router 负责接收请求，并将请求的目的地址替换成 LVS Router 的 NAT Virtual IP 地址，再将其转发到选中的后端服务器上，同时服务器处理后的应答数据也通过 LVS Router 将其地址替换成 LVS Router 的 Public Virtual IP 地址，然后再转发给 Internet 客户端，这个过程也称为 IP 伪装，因为对客户端而言，服务器的真实 IP 地址已被隐藏。&lt;/p>
&lt;p>在 NAT 路由实现的负载均衡中，后端服务器上可以运行各种操作系统，即后端服务器上的操作系统类型并不影响 LVS Router 的 NAT 路由功能，但是，使用 NAT 路由方式存在的一个缺点是， LVS Router 在大规模集群部署中可能会是一个瓶颈，因为 LVS Router 要同时负责进出双向数据流的 IP 地址替换。&lt;/p>
&lt;p>（2） DR&lt;/p>
&lt;p>相对于其他的负载均衡网络拓扑， DR(Direct Routing）路由方式为基于 Keepalived 的负载均衡系统提供了更高的网络性能， DR 路由方式允许后端服务器直接将处理后的应答数据返回给客户端，而无需经过 LVS Router 的处理操作，DR 路由方案极大降低了 LVS Router 造成网络瓶颈的可能性。如图 3-7 所示。在基于 Keepalived 的负载均衡架构中， Keepalived 的最佳路由方式是 DR 路由，即在配置 Keepalived 的路由方式时，优先将其设置为 DR 。&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/watgs2/1616132514433-6d061a2c-ec2a-43ea-a749-4acef265787f.jpeg" alt="">&lt;/p></description></item><item><title>Docs: 1.2.Keepalived 配置详解</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/3.%E9%9B%86%E7%BE%A4%E4%B8%8E%E5%88%86%E5%B8%83%E5%BC%8F/keepalived/1.2.keepalived-%E9%85%8D%E7%BD%AE%E8%AF%A6%E8%A7%A3/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/3.%E9%9B%86%E7%BE%A4%E4%B8%8E%E5%88%86%E5%B8%83%E5%BC%8F/keepalived/1.2.keepalived-%E9%85%8D%E7%BD%AE%E8%AF%A6%E8%A7%A3/</guid><description>
&lt;h1 id="keepalived-使用">Keepalived 使用&lt;/h1>
&lt;p>keepalived 启动流程：&lt;/p>
&lt;ol>
&lt;li>
&lt;p>启动三个进程（主进程、healthcheck 进程、vrrp 进程）之后，先进入 backup 状态，运行一次 vrrp_script 成功后发现没有主，这时候会进入 master 状态，拉起 VIP，完成启动。 &lt;/p>
&lt;/li>
&lt;li>
&lt;p>切换的流程：&lt;/p>
&lt;/li>
&lt;li>
&lt;p>原 keepalived master 节点，运行检查脚本异常，则 keepalived 进入 FAULT 状态，释放 vip，原 backup 的 keepalived 会接管 VIP。 &lt;/p>
&lt;/li>
&lt;li>
&lt;p>注意事项：VIP 必须在 master 上。为了这个要求，需要在主库上先启动 keepalived。&lt;/p>
&lt;/li>
&lt;/ol>
&lt;h1 id="keepalived-配置">Keepalived 配置&lt;/h1>
&lt;p>/etc/sysconfig/keepalived #keepalived 运行时参数配置&lt;/p>
&lt;p>/etc/keepalived/keepalived.conf #keepalived 基本配置文件&lt;/p>
&lt;ol>
&lt;li>Note：keepalived 配置文件的运行时加载功能，可以通过命令 kill -HUP $(cat /var/run/keepalived.pid) 实现。该功能需要在 1.2.20 及以上版本才能实现&lt;/li>
&lt;/ol>
&lt;p>下面是一个基本的 keepalived.conf 文件的配置示例&lt;/p>
&lt;pre>&lt;code>! Configuration File for keepalived
global_defs { #全局配置段
notification_email {
admin@example. com
}
notification_email_from noreply@example.com
smtp_server 127.0.0.1
smtp_connect_timeout 60
router_id LVS_DEVEL
script_user root
}
vrrp_script chk_haproxy {
script &amp;quot;killall -0 haproxy&amp;quot;
interval 1
weight 2
}
vrrp_sync_group VG1 { #VRRP组配置段
group {
VI_1
VI_2
}
}
vrrp_instance VI_1 { #VRRP 实例VI_1配置段
state MASTER
interface eth0
virtual_router_id 50
priority 100
advert_int 1
authentication {
auth_type PASS
auth_pass password123
}
virtual_ipaddress {
10.0.0.1
}
track_script {
chk_haproxy
}
}
vrrp_instance VI_2 { #VRRP 实例VI_2配置段
state MASTER
interface eth1
virtual_router_id 2
priority 100
advert_int 1
authentication{
auth_type PASS
auth_pass password123
}
virtual_ipaddress {
192.168.1.1
}
notify_master &amp;quot;/etc/keepalived/notify.sh master&amp;quot; #定义该节点变为master后执行的脚本
notify_backup &amp;quot;/etc/keepalived/notify.sh backup&amp;quot; #定义该节点变为backup后执行的脚本
notify_fault &amp;quot;/etc/keepalived/notify.sh fault&amp;quot; #定义该节点变为fault后执行的脚本
}
virtual_server 10.0.0.1 80 { #虚拟服务器LVS 配置段
delay_loop 6
lvs_sched rr
lvs_method DR
protocol TCP
sorry_server 127.0.0.1 80
real_server 192.168.1.20 80 { #定义后端服务器1
XXX_CHECK {
connect timeout 10
}
}
real_server 192.168.1.21 80 { #定义后端服务器2
XXX_CHECK {
connect timeout 10
}
}
}
&lt;/code>&lt;/pre>
&lt;p>从 Keepalived 配置文件/etc/keepalived/keepalived.conf 中的内容可以看到， Keepalived 的配置主要分为三个模块， 即全局配置段、VRRP 定义段、虚拟服务器 LVS 配置段。&lt;/p>
&lt;p>配置文件 keywords(关键字) 详解&lt;/p>
&lt;p>注意：各个大版本之间的 keyword 有很大区别，名称以及所在位置都有区别，千万注意！！！！&lt;/p>
&lt;p>1.全局配置段&lt;/p>
&lt;p>全局配置段（ global_defs ）的主要作用之一就是 Keepalived 出现故障时的邮件通知管理员，让管理员以邮件形式知道 Keepalived 的运行情况。通常情况下，邮件通知不是必须的，用户可以选择其他监控方式来对 Keepalived 进行监控，如 Nagios。需要说明的是，全局配置段对 Keepalived 来说是可选的，其内容并不是 Keepalived 配置所必须的。全局配置段的几个主要配置参数说明如下：&lt;/p>
&lt;p>&lt;strong>global_defs&lt;/strong> #&lt;/p>
&lt;ul>
&lt;li>
&lt;p>Notification_email # 用于配置接收邮件的负载均衡器的管理员群组邮箱。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Notification_email_from # 自定义发出邮件的邮箱地址，即管理员邮件显示的发件人。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>SMTP # 指定简单邮件参数协议服务器地址，一般为本机。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>LVS_ID # LVS 负载均衡器标志，同一网络中其值唯一。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>script_user &lt;!-- raw HTML omitted -->&lt;/strong> # 指定 vrrp_script 定义的脚本&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>enable_script_security&lt;/strong> # 开启脚本安全&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>vrrp_script ScriptName { &amp;hellip; }&lt;/strong> # 定义检查脚本以便后面的 track_script 关键字来引用，若检查状态码为非 0 失败，则引用该脚本的 VRRP 变成 Fault 状态，若定义了 weight 字段且优先级比其余节点都低，则变为 Backup 状态&lt;/p>
&lt;ul>
&lt;li>
&lt;p>&lt;strong>script &amp;ldquo;/PATH/FILE&amp;rdquo;&lt;/strong> #定义需要执行的脚本或者需要执行的脚本的路径&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>interval&lt;/strong> #脚本调用间隔的秒数，默认 1 秒&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>timeout&lt;/strong> #定义调用失败多少秒后，确认该脚本失败&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>weight&lt;/strong> #脚本执行失败后，调整调用了该脚本的 vrrp 的优先级(priority)。i.e.降低或者提高优先级的数值，INTEGER 值为-254 到 254 之间&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>rise&lt;/strong> # 判断服务正常的检查次数，正常多少次，会进行状态转变&lt;/p>
&lt;/li>
&lt;li>
&lt;p>**fall **# 判断服务异常的检查次数，异常多少次，会进行状态转转变&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>user USERNAME [GROUPNAME]&lt;/strong> # 运行该脚本的用户&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>init_fail&lt;/strong> # 定义该脚本默认为失败状态&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>2. VRRP 配置段&lt;/p>
&lt;p>VRRP 配置段主要用于定义 VRRP 组，在 Keepalived 发生任何状态变化时，被定义在 VRRP 组中的 VRRP 实例作为逻辑整体一致行动，如在发生 LVS Router 故障切换 Failover 的过程中， VRRP 组中的实例会作为一致整体同时切换。在本节的演示配置中，同一个 VRRP 组内配置了两个 VRRP 实例，分别是针对外部网络的 VRRP_EXT 实例和针对内部私有网络的 VRRP_INT 实例。VRRP 配置段中的关键参数说明如下。&lt;/p>
&lt;p>&lt;strong>vrrp_sync_group {&amp;hellip;}&lt;/strong> # VRRP 实例一致组，用于定义 VRRP 一致组中的成员，组内的 VRRP 实例行为是一致的，如在 Failover 的时候， 一致组内的 VRRP 实例将同时迁移。在本机示例中，当 LBl 出现故障时， VRRP INT 和 VRRP EXT 实例将同时切换到 LB2 上。如果 不定义组，那么如果一台设备上有俩网卡的时候，只有一块网卡坏了的话，定义在另一块网卡上的 VRRP 则还在原来的设备上运行，无法自动切换到备用设备上。&lt;/p>
&lt;p>&lt;strong>vrrp_instance {&amp;hellip;}&lt;/strong> # VRRP 实例，用于配置一个 VRRP 服务进程实例，其中的 state 设定了当前节点 VRRP 实例的主备状态，在主 LVS Router 中，该值应该为 MASTER,在备 LVS Router 中，其值为 BACKUP 。正常情况下只有 Master 的 LVS Router 在工作， Backup 的 LVS Router 处于 Standby 状态。&lt;/p>
&lt;ul>
&lt;li>
&lt;p>&lt;strong>state&lt;/strong> # 当前节点的初始状态&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>interface&lt;/strong> # 对外提供服务的网络接口，如 eth0 和 eth1，选择服务接口时，一定要核实清楚，LV Router 的 VIP 将会配置到这个物理接口上。也可以配置多个实例在同一个网卡上，然后每个实例配置不同优先级，HOST1 上的实例 1 是主实例 2 是备，HOST2 上的实例 1 是备实例 2 是主，这样可以实现两台 HOST 双主模式负载均衡流量&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>virtual_Router_id&lt;/strong> # VRID，虚拟路由标志，同一个 VRRP 实例使用唯一的标识。即同一个 VRRP 实例中，MASTER 和 BACKUP 状态的 VRRP 实例中，VRID 值是相同的，同时在全部 VRRP 组内是唯一的。&lt;/p>
&lt;ul>
&lt;li>Note：如果在同网段有相同的 vrid 号，则 keepalived 会无限输出报错日志。使用 tcpdump -nn -i any net 224.0.0.0/8 |grep vrid 命令可以查到该网段都有哪些 vrid 号正在使用&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>priority&lt;/strong> # 此参数指明了该 VRRP 实例的优先级，数字越大说明优先级越高，取值范围为 0-255 ，在同一个 VRRP 实例里， MASTER 的优先级高于 BACKUP。若 MASTER 的 Priority 值为 100 ，那 BACKUP 的 Priority 只能是 99 或更小的数值。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>nopreempt&lt;/strong> # 开启非抢占模式。允许低优先级的节点保持 MASTER 角色，即使高优先级的节点从故障中恢复也是如此。i.e.不会触发选举过程。只有当前 BACKUP 节点 认为 MASTER 不存在时，才会重新选举。&lt;/p>
&lt;ul>
&lt;li>
&lt;p>Note：该模式会引发这个问题 Keepalived 非抢占模式 VIP 不漂移问题&lt;/p>
&lt;ul>
&lt;li>如果想要使用非抢占模式，主备的 keepalived 的 state 都不能是 MASTER。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>advert_int&lt;/strong> # Master 路由发送 VRRP 广播的时间间隔，单位为秒。默认为 1 秒&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>authentication {&amp;hellip;}&lt;/strong> # 包含验证类型和验证密码，类型主要有 PASS 和 AH 两种，通常使用的类型为 PASS 验证密码为明文，同一 VRRP 实例 MASTER 与 BACKUP 使用相同的密码才能正常通信。&lt;/p>
&lt;ul>
&lt;li>
&lt;p>&lt;strong>auth_type PASS|AH&lt;/strong> #认证类型。Note：只能是 PASS 或 AH 选项，不能写别的，否则报错：unknown authentication type &amp;rsquo;lvs'&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>auth_pass PASSWORD&lt;/strong> #认证的密码&lt;/p>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>virtual_ipaddress {IP}&lt;/strong> # 虚拟 IP 地址，即 VIP，可以有多个虚拟 IP 、地址，每个地址占一行，不需要指定子网掩码。作为 Standby 的负载均衡器，LB2 的 keepalived.conf 配置文件与 LB1 类似，其不同之处在于 VRRP 实例配置段中的的 VRRP 实例 State 和 Priority 参数的设置，如 LB1 中的 State 为 Master, LB2 中的 State 为 BACKUP ，并且 LB2 中 VRRP 实例的 Priority 必须小于 LB1 中的优先级。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>track_script {ScriptName}&lt;/strong> # 引用全局配置段中 vrrp_script 关键字的名为 ScriptName 的脚本&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>notify_master &amp;ldquo;/PATH/ScriptName ARGS&amp;rdquo;&lt;/strong> # 定义该节点变为 master 后执行的脚本&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>notify_backup &amp;ldquo;/PATH/ScriptName ARGS&amp;rdquo;&lt;/strong> # 定义该节点变为 backup 后执行的脚本&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>notify_fault &amp;ldquo;/PATH/ScriptName ARGS&amp;rdquo;&lt;/strong> # 定义该节点变为 fault 后执行的脚本&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>3. 虚拟服务器 LVS 配置段&lt;/p>
&lt;p>虚拟服务器（ Virtual Server ）配置段主要定义 LVS 的监昕虚拟 IP 地址和对应的后端服务器及其健康检测机制，虚拟服务器的定义段是 Keepalived 框架最重要的部分。此部分的定义主要分为一个 Virtual Server 的定义和多个 Real Servers 的定义， Virtual Server 由 VRRP 中定义的 VIP 加上端口号构成，而 Real Server 由后端服务器节点 IP 和端口号构成，相关的配置参数说明如下。&lt;/p>
&lt;p>&lt;strong>virtual_server {&amp;hellip;}&lt;/strong> # lvs 中调度器的配置&lt;/p>
&lt;ul>
&lt;li>
&lt;p>&lt;strong>delay_Loop NUM&lt;/strong> # 健康检查的时间间隔，单位为秒。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>lvs_sched&lt;/strong> # 指定负载均衡算法，示例中的 rr 表示 Round-Robin 轮询算法。(老版本的 keyword 为 lb_algo)&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>lvs_method&lt;/strong> # 采用的路由方法，示例中采用的是 DR 路由，还可以采用 NAT 和 TUN 路由。(老版本的 keyword 为 lb_kind)&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>persistence_timeout&lt;/strong> # 指定连接持久的超时时间。默认 6 分钟。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>**protocol **# 转发协议，一般有 TCP 和 UDP 两种。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>connect_timeout #连接超时时间。默认 5 秒。当 RS 检查失败 5 秒后，即判断该 RS 无响应，从 ipvs 组中踢出&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>retry&lt;/strong> # 重试次数。默认 1 次。当 RS 检查失败后，再次检查的次数。(老版本的 keyword 为 nb_get_retry)&lt;/p>
&lt;/li>
&lt;li>
&lt;p>delay_before_retry #失败后，让 RS 重新加回 ipvs 组重试的次数。默认 1 次。当 rs 检查 1 次成功后，就将该 RS 重新加入 ipvs 组&lt;/p>
&lt;/li>
&lt;li>
&lt;p>sorry_server :用于定义当后端所有 real server 挂掉后，使用哪台设备进行回应&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>real_server IP PORT {&amp;hellip;}&lt;/strong> # 后端服务器配置，i.e.lvs 中 RS 的配置&lt;/p>
&lt;ul>
&lt;li>
&lt;p>&lt;strong>CHECK {&amp;hellip;}&lt;/strong> # 指定健康检查的方式。TCP 就是测试目标端口通不通。HTTP 则是测试指定资源的响应码&lt;/p>
&lt;ul>
&lt;li>
&lt;p>可用的 CHECK 有如下几个，常用的标黄&lt;/p>
&lt;/li>
&lt;li>
&lt;p>HTTP_GET|SSL_GET|TCP_CHECK|SMTP_CHECK|DNS_CHECK|MISC_CHECK|BFD_CHECK|UDP_CHECK|PING_CHECK|FILE_CHECK&lt;/p>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h2 id="4-其他配置">4. 其他配置&lt;/h2>
&lt;p>&lt;strong>include &lt;!-- raw HTML omitted -->&lt;/strong> # 指定要包含的其他配置文件。FILE 可以用绝对路径，也可以使用通配符。指定的 FILE 中的内容将作为 keepalived 配置内容附加到主配置后面&lt;/p>
&lt;h2 id="检查脚本配置示例">检查脚本配置示例&lt;/h2>
&lt;ol>
&lt;li>定义脚本用于把 MASTER 节点的优先值降低 20，以实现主备切换，在指定目录中创建一个 down 文件，也可以使用别的判断方式&lt;/li>
&lt;/ol>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>vrrp_script chk_mantaince_down &lt;span style="color:#f92672">{&lt;/span> &lt;span style="color:#75715e">#配置一个名为chk_mantaince_down的脚本&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e"># 当某个文件存在时，权重减20&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> script &lt;span style="color:#e6db74">&amp;#34;[[ -f /etc/keepalived/down ]] &amp;amp;&amp;amp; exit 1 || exit 0&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> interval &lt;span style="color:#ae81ff">1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> weight -20
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ol>
&lt;li>判断 nginx 进程是否存在，如果不存在则权重-2 使之变为 BACKUP&lt;/li>
&lt;/ol>
&lt;!-- raw HTML omitted -->
&lt;pre>&lt;code>vrrp_script chk_haproxy {
# 判断haproxy进程是否存在，如果不存在则权重-2使之变为BACKUP
script &amp;quot;killall -0 haproxy&amp;quot; # 可以使用这个语句判断nginx，script &amp;quot;killall -0 nginx &amp;amp;&amp;gt; /dev/null&amp;quot;
interval 1 # 运行脚本的时间间隔
weight -2
}
&lt;/code>&lt;/pre>
&lt;ol>
&lt;li>引用脚本&lt;/li>
&lt;/ol>
&lt;!-- raw HTML omitted -->
&lt;pre>&lt;code>vrrp_instance VI_1 {
...
track_script { # 在VRRP实例中引用哪些keepalived.conf中定义的脚本
chk_mantaince_down
}
notify_master &amp;quot;/etc/keepalived/notify.sh master&amp;quot; # 定义该节点变为master后执行的脚本
notify_backup &amp;quot;/etc/keepalived/notify.sh backup&amp;quot; # 定义该节点变为backup后执行的脚本
notify_fault &amp;quot;/etc/keepalived/notify.sh fault&amp;quot; # 定义该节点变为fault后执行的脚本
}
&lt;/code>&lt;/pre></description></item><item><title>Docs: 10.1.Keepalived 配置示例</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/3.%E9%9B%86%E7%BE%A4%E4%B8%8E%E5%88%86%E5%B8%83%E5%BC%8F/keepalived/10.1.keepalived-%E9%85%8D%E7%BD%AE%E7%A4%BA%E4%BE%8B/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/3.%E9%9B%86%E7%BE%A4%E4%B8%8E%E5%88%86%E5%B8%83%E5%BC%8F/keepalived/10.1.keepalived-%E9%85%8D%E7%BD%AE%E7%A4%BA%E4%BE%8B/</guid><description>
&lt;h1 id="满足基本-ha-功能的配置">满足基本 HA 功能的配置&lt;/h1>
&lt;pre>&lt;code>global_defs {
notification_email {
root@localhost
}
notification_email_from Alexandre.Cassen@firewall.loc
smtp_server 127.0.0.1
smtp_connect_timeout 30
router_id LVS_DEVEL
script_user root
}
vrrp_script chk_haproxy {
script “killall -0 haproxy”
interval 1
weight -2
}
vrrp_instance VI_1 {
state MASTER #备节点改成BACKUP
interface ens33
virtual_router_id 51
priority 101 #倍节点改成100
advert_int 1
authentication {
auth_type PASS
auth_pass 1111
}
virtual_ipaddress {
192.168.0.75
}
track_script {
chk_haproxy
}
notify_master &amp;quot;/etc/keepalived/notify master&amp;quot; root
notify_backup &amp;quot;/etc/keepalived/notify backup&amp;quot; root
notify_fault &amp;quot;/etc/keepalived/notify fault&amp;quot; root
}
include /etc/keepalived/include/*
&lt;/code>&lt;/pre>
&lt;p>基本 LVS 的配置&lt;/p>
&lt;pre>&lt;code>virtual_server 192.168.0.63 80 {
delay_loop 6
lvs_sched rr
lvs_method DR
protocol TCP
real_server 192.168.1.71 80 {
TCP_CHECK {
connect_timeout 10
}
}
real_server 192.168.0.72 80 {
TCP_CHECK {
connect_timout 10
}
}
}
&lt;/code>&lt;/pre>
&lt;p>keepalive 双主模型&lt;/p>
&lt;pre>&lt;code>global_defs {
notification_email {
linuxedu@foxmail.com
}
notification_email_from kanotify@magedu.com
smtp_connect_timeout 3
smtp_server 127.0.0.1
router_id LVS_DEVEL
}
vrrp_script chk_haproxy {
script &amp;quot;killall -0 haproxy&amp;quot;
interval 1
weight -2
}
vrrp_instance VI_1 {
interface eth0
state MASTER # BACKUP for slave routers
priority 101 # 100 for BACKUP
virtual_router_id 51
garp_master_delay 1
authentication {
auth_type PASS
auth_pass password
}
track_interface {
eth0
}
virtual_ipaddress {
192.168.0.75
}
track_script {
chk_haproxy
}
notify_master &amp;quot;/etc/keepalived/notify.sh master&amp;quot;
notify_backup &amp;quot;/etc/keepalived/notify.sh backup&amp;quot;
notify_fault &amp;quot;/etc/keepalived/notify.sh fault&amp;quot;
}
vrrp_instance VI_2 {
interface eth0
state BACKUP # BACKUP for slave routers
priority 100 # 100 for BACKUP
virtual_router_id 52
garp_master_delay 1
authentication {
auth_type PASS
auth_pass password
}
track_interface {
eth0
}
virtual_ipaddress {
192.168.0.75
}
track_script {
chk_haproxy
}
notify_master &amp;quot;/etc/keepalived/notify.sh master&amp;quot;
notify_backup &amp;quot;/etc/keepalived/notify.sh backup&amp;quot;
notify_fault &amp;quot;/etc/keepalived/notify.sh fault&amp;quot;
}
&lt;/code>&lt;/pre>
&lt;h1 id="keepalived-所用到的脚本示例">keepalived 所用到的脚本示例&lt;/h1>
&lt;p>下面是一个 notify.sh 脚本的简单示例：&lt;/p>
&lt;pre>&lt;code>#!/bin/bash
# Author: MageEdu &amp;lt;linuxedu@foxmail.com&amp;gt;
# description: An example of notify script
vip=192.168.0.75
contact='root@localhost'
notify() {
mailsubject=&amp;quot;`hostname` to be $1: $vip floating&amp;quot;
mailbody=&amp;quot;`date '+%F %H:%M:%S'`: vrrp transition, `hostname` changed to be $1&amp;quot;
echo $mailbody | mail -s &amp;quot;$mailsubject&amp;quot; $contact
}
case &amp;quot;$1&amp;quot; in
master)
notify master
systemctl start haproxy.service
exit 0
;;
backup)
notify backup
systemctl stop haproxy.service
exit 0
;;
fault)
notify fault
/etc/rc.d/init.d/haproxy stop
exit 0
;;
*)
echo 'Usage: `basename $0` {master|backup|fault}'
exit 1
;;
esac
&lt;/code>&lt;/pre>
&lt;p>keepalived 通知脚本进阶示例：&lt;/p>
&lt;p>下面的脚本可以接受选项，其中：&lt;/p>
&lt;p>-s, &amp;ndash;service SERVICE,&amp;hellip;：指定服务脚本名称，当状态切换时可自动启动、重启或关闭此服务；&lt;/p>
&lt;p>-a, &amp;ndash;address VIP: 指定相关虚拟路由器的 VIP 地址；&lt;/p>
&lt;p>-m, &amp;ndash;mode {mm|mb}：指定虚拟路由的模型，mm 表示主主，mb 表示主备；它们表示相对于同一种服务而方，其 VIP 的工作类型；&lt;/p>
&lt;p>-n, &amp;ndash;notify {master|backup|fault}：指定通知的类型，即 vrrp 角色切换的目标角色；&lt;/p>
&lt;p>-h, &amp;ndash;help：获取脚本的使用帮助；&lt;/p>
&lt;pre>&lt;code>#!/bin/bash
# Author: MageEdu &amp;lt;linuxedu@foxmail.com&amp;gt;
# description: An example of notify script
# Usage: notify.sh -m|--mode {mm|mb} -s|--service SERVICE1,... -a|--address VIP -n|--notify {master|backup|falut} -h|--help
#contact='linuxedu@foxmail.com'
helpflag=0
serviceflag=0
modeflag=0
addressflag=0
notifyflag=0
contact='root@localhost'
Usage() {
echo &amp;quot;Usage: notify.sh [-m|--mode {mm|mb}] [-s|--service SERVICE1,...] &amp;lt;-a|--address VIP&amp;gt; &amp;lt;-n|--notify {master|backup|falut}&amp;gt;&amp;quot;
echo &amp;quot;Usage: notify.sh -h|--help&amp;quot;
}
ParseOptions() {
local I=1;
if [ $# -gt 0 ]; then
while [ $I -le $# ]; do
case $1 in
-s|--service)
[ $# -lt 2 ] &amp;amp;&amp;amp; return 3
serviceflag=1
services=(`echo $2|awk -F&amp;quot;,&amp;quot; '{for(i=1;i&amp;lt;=NF;i++) print $i}'`)
shift 2 ;;
-h|--help)
helpflag=1
return 0
shift
;;
-a|--address)
[ $# -lt 2 ] &amp;amp;&amp;amp; return 3
addressflag=1
vip=$2
shift 2
;;
-m|--mode)
[ $# -lt 2 ] &amp;amp;&amp;amp; return 3
mode=$2
shift 2
;;
-n|--notify)
[ $# -lt 2 ] &amp;amp;&amp;amp; return 3
notifyflag=1
notify=$2
shift 2
;;
*)
echo &amp;quot;Wrong options...&amp;quot;
Usage
return 7
;;
esac
done
return 0
fi
}
#workspace=$(dirname $0)
RestartService() {
if [ ${#@} -gt 0 ]; then
for I in $@; do
if [ -x /etc/rc.d/init.d/$I ]; then
/etc/rc.d/init.d/$I restart
else
echo &amp;quot;$I is not a valid service...&amp;quot;
fi
done
fi
}
StopService() {
if [ ${#@} -gt 0 ]; then
for I in $@; do
if [ -x /etc/rc.d/init.d/$I ]; then
/etc/rc.d/init.d/$I stop
else
echo &amp;quot;$I is not a valid service...&amp;quot;
fi
done
fi
}
Notify() {
mailsubject=&amp;quot;`hostname` to be $1: $vip floating&amp;quot;
mailbody=&amp;quot;`date '+%F %H:%M:%S'`, vrrp transition, `hostname` changed to be $1.&amp;quot;
echo $mailbody | mail -s &amp;quot;$mailsubject&amp;quot; $contact
}
# Main Function
ParseOptions $@
[ $? -ne 0 ] &amp;amp;&amp;amp; Usage &amp;amp;&amp;amp; exit 5
[ $helpflag -eq 1 ] &amp;amp;&amp;amp; Usage &amp;amp;&amp;amp; exit 0
if [ $addressflag -ne 1 -o $notifyflag -ne 1 ]; then
Usage
exit 2
fi
mode=${mode:-mb}
case $notify in
'master')
if [ $serviceflag -eq 1 ]; then
RestartService ${services[*]}
fi
Notify master
;;
'backup')
if [ $serviceflag -eq 1 ]; then
if [ &amp;quot;$mode&amp;quot; == 'mb' ]; then
StopService ${services[*]}
else
RestartService ${services[*]}
fi
fi
Notify backup
;;
'fault')
Notify fault
;;
*)
Usage
exit 4
;;
esac
&lt;/code>&lt;/pre>
&lt;p>在 keepalived.conf 配置文件中，其调用方法如下所示：&lt;/p>
&lt;pre>&lt;code>notify_master &amp;quot;/etc/keepalived/notify.sh -n master -a 172.16.100.1&amp;quot;
notify_backup &amp;quot;/etc/keepalived/notify.sh -n backup -a 172.16.100.1&amp;quot;
notify_fault &amp;quot;/etc/keepalived/notify.sh -n fault -a 172.16.100.1&amp;quot;
&lt;/code>&lt;/pre>
&lt;h1 id="keepalived-日志配置">keepalived 日志配置&lt;/h1>
&lt;p>建议使用 local2 级别日志，因为 keepalived_healthcheckers 默认为 local2 级别，新版 keepalived 已不用改该配置&lt;/p>
&lt;p>修改启动参数,将 -D 改为 -D -d -S 0&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>sed -i &lt;span style="color:#e6db74">&amp;#39;s/\(KEEPALIVED_OPTIONS=\)&amp;#34;-D&amp;#34;/\1&amp;#34;-D -d -S 0&amp;#34;/&amp;#39;&lt;/span> /etc/sysconfig/keepalived
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>修改 rsyslog 配置&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>cat &amp;gt; /etc/rsyslog.d/keepalived-log.conf &lt;span style="color:#e6db74">&amp;lt;&amp;lt; EOF
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">local0.* /var/log/keepalived/keepalived.log
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">&amp;amp; stop
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">EOF&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>配置日志轮替&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>cat &amp;gt; /etc/logrotate.d/keepalived &lt;span style="color:#e6db74">&amp;lt;&amp;lt; \EOF
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">/var/log/keepalived/keepalived.log {
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74"> daily
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74"> copytruncate
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74"> rotate 10
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74"> missingok
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74"> dateext
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74"> notifempty
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74"> compress
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74"> sharedscripts
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74"> postrotate
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74"> /bin/kill -HUP `cat /var/run/syslogd.pid 2&amp;gt; /dev/null` 2&amp;gt; /dev/null || true
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74"> /bin/kill -HUP `cat /var/run/rsyslogd.pid 2&amp;gt; /dev/null` 2&amp;gt; /dev/null || true
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74"> endscript
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">}
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">EOF&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>systemctl restart rsyslog
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div></description></item><item><title>Docs: 10.2.keepalived+nginx 配置示例</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/3.%E9%9B%86%E7%BE%A4%E4%B8%8E%E5%88%86%E5%B8%83%E5%BC%8F/keepalived/10.2.keepalived+nginx-%E9%85%8D%E7%BD%AE%E7%A4%BA%E4%BE%8B/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/3.%E9%9B%86%E7%BE%A4%E4%B8%8E%E5%88%86%E5%B8%83%E5%BC%8F/keepalived/10.2.keepalived+nginx-%E9%85%8D%E7%BD%AE%E7%A4%BA%E4%BE%8B/</guid><description>
&lt;h1 id="适用于-keepalived-的-node-节点的前端负载均衡的配置">适用于 keepalived 的 node 节点的前端负载均衡的配置&lt;/h1>
&lt;h3 id="keepalivedconf-主节点配置内容xa">keepalived.conf 主节点配置内容
&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>cat &amp;gt; /etc/keepalived/keepalived.conf &lt;span style="color:#e6db74">&amp;lt;&amp;lt; EOF
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">global_defs {
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74"> router_id k8s-master-dr
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74"> script_user root
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74"> enable_script_security
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">}
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">vrrp_script check_nginx {
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74"> script &amp;#34;/etc/keepalived/check_nginx.sh&amp;#34;
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74"> interval 3
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74"> weight -2
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74"> fall 2
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74"> rise 2
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">}
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">vrrp_instance VI_K8S {
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74"> state BACKUP
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74"> interface eth0
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74"> virtual_router_id 60
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74"> priority 101
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74"> nopreempt
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74"> authentication {
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74"> auth_type PASS
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74"> auth_pass 4be37dc3b4c90194d1600c483e10ad1d
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74"> }
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74"> virtual_ipaddress {
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74"> 172.40.0.60
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74"> }
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74"> track_script {
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74"> check_nginx
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74"> }
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">}
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">EOF&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="keepalivedconf-备节点配置内容">keepalived.conf 备节点配置内容&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>cat &amp;gt; /etc/keepalived/keepalived.conf &lt;span style="color:#e6db74">&amp;lt;&amp;lt; EOF
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">global_defs {
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74"> router_id k8s-master-dr
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74"> script_user root
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74"> enable_script_security
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">}
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">vrrp_script check_nginx {
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74"> script &amp;#34;/etc/keepalived/check_nginx.sh&amp;#34;
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74"> interval 3
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74"> weight -2
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74"> fall 2
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74"> rise 2
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">}
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">vrrp_instance VI_K8S {
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74"> state BACKUP
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74"> interface eth0
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74"> virtual_router_id 60
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74"> priority 100
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74"> nopreempt
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74"> authentication {
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74"> auth_type PASS
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74"> auth_pass 4be37dc3b4c90194d1600c483e10ad1d
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74"> }
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74"> virtual_ipaddress {
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74"> 172.40.0.60
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74"> }
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74"> track_script {
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74"> check_nginx
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74"> }
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">}
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">EOF&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="check_nginxsh-配置内容">check_nginx.sh 配置内容&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>cat &amp;gt; /etc/keepalived/check_nginx.sh &lt;span style="color:#e6db74">&amp;lt;&amp;lt; \EOF
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">#!/bin/bash
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">pidof nginx #检查memcached服务
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">if [[ $? == 0 ]];then #检查成功
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74"> /sbin/iptables -S | grep vrrp
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74"> if [[ $? == 0 ]]; then #如果iptable中有vrrp的配置，删除它
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74"> /sbin/iptables -D OUTPUT -p vrrp -j DROP
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74"> fi
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74"> exit 0
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">else #检查失败
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74"> /sbin/iptables -S | grep vrrp
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74"> if [[ $? != 0 ]]; then
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74"> /sbin/iptables -A OUTPUT -p vrrp -j DROP #如果iptable中没有vrrp的条目，禁止vrrp发出
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74"> fi
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74"> exit 1
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">fi
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">EOF&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>chmod &lt;span style="color:#ae81ff">755&lt;/span> /etc/keepalived/check_nginx.sh
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div></description></item><item><title>Docs: core 模块指令</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/3.%E9%9B%86%E7%BE%A4%E4%B8%8E%E5%88%86%E5%B8%83%E5%BC%8F/nginx/nginx-%E9%85%8D%E7%BD%AE%E8%AF%A6%E8%A7%A3/core-%E6%A8%A1%E5%9D%97%E6%8C%87%E4%BB%A4/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/3.%E9%9B%86%E7%BE%A4%E4%B8%8E%E5%88%86%E5%B8%83%E5%BC%8F/nginx/nginx-%E9%85%8D%E7%BD%AE%E8%AF%A6%E8%A7%A3/core-%E6%A8%A1%E5%9D%97%E6%8C%87%E4%BB%A4/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="http://nginx.org/en/docs/ngx_core_module.html">org 官方文档,核心功能&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>main 模块主要用来为 nginx 程序的运行方式进行定义，并不涉及流量处理相关工作。&lt;/p>
&lt;h1 id="指令详解">指令详解&lt;/h1>
&lt;p>**user USERNAME [GROUPNAME]; **#指定运行 work 线程的用户和组
&lt;strong>pid /PATH/PidFile;&lt;/strong> # 指定 nginx 守护进程的 pid 文件
&lt;strong>work_rlimit_nofile NUMBER;&lt;/strong> # 指定所有 work 线程加起来所能打开的最大文件句柄数&lt;/p></description></item><item><title>Docs: CoroSync 与 pacemaker</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/3.%E9%9B%86%E7%BE%A4%E4%B8%8E%E5%88%86%E5%B8%83%E5%BC%8F/%E8%80%81%E6%97%A7%E6%8A%80%E6%9C%AF/corosync-%E4%B8%8E-pacemaker/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/3.%E9%9B%86%E7%BE%A4%E4%B8%8E%E5%88%86%E5%B8%83%E5%BC%8F/%E8%80%81%E6%97%A7%E6%8A%80%E6%9C%AF/corosync-%E4%B8%8E-pacemaker/</guid><description>
&lt;h1 id="aisopenaisapplication-interface-standard应用接口规范">AIS：OpenAIS（Application Interface Standard）应用接口规范&lt;/h1>
&lt;p>OpenAIS 提供了一种集群模式，包含集群框架。集群成员管理、通信方式、集群检测，但没有集群资源管理功能&lt;/p>
&lt;p>组件包括：AMF，CLM，CPKT，EVT 等接口&lt;/p>
&lt;p>CoroSync （The Corosync Cluster Engine）集群管理引擎，是 OpenAIS 的一个子组件&lt;/p>
&lt;p>corosync+pacemaker&lt;/p>
&lt;p>crmsh:suse 研发的命令行工具&lt;/p>
&lt;p>pcs:RedHat 研发的命令行工具&lt;/p>
&lt;h1 id="corosync-与-pacemaker-的使用方法">CoroSync 与 Pacemaker 的使用方法&lt;/h1>
&lt;p>CoroSync 可以直接用过源安装，自动解决依赖关系，包名就是 corosync&lt;/p>
&lt;p>Cluster 中的各个 Node 通过相同的组播地址来组成集群，这些 Node 上会拥有相同的配置文件和 corosync-keygen 密钥，如果一个 Node 没有配置文件，则 Pacemaker 也无法控制这个节点，因为这个节点更本就不在这个集群中&lt;/p>
&lt;p>配置文件在/etc/corosync.conf，该文件定义 CoroSync 底层是如何让 Cluster 内的各个 Node 互相通信的&lt;/p>
&lt;ol>
&lt;li>
&lt;p>totem { #图腾，定义 Cluster 的 Messaging Infrastructure 层，各 Node 如何进行通信的&lt;/p>
&lt;/li>
&lt;li>
&lt;p>version：NUM #totem 的版本号&lt;/p>
&lt;/li>
&lt;li>
&lt;p>cluster_name：NAME #定义集群名称&lt;/p>
&lt;/li>
&lt;li>
&lt;p>secauth：on|off #定义是否打开安全认证功能，如果打开了，那么就需要使用 corosync-keygen 命令生成密钥，其余节点需要都拥有该密钥文件&lt;/p>
&lt;/li>
&lt;li>
&lt;p>threads：NUM #定义线程数，默认为 0&lt;/p>
&lt;/li>
&lt;li>
&lt;p>interface { #定义多个节点之间通过哪个接口，基于哪个多播地址，监听什么端口，完成多播通信的&lt;/p>
&lt;/li>
&lt;li>
&lt;p>ringnumber：0 #一般保持为 0 就行&lt;/p>
&lt;/li>
&lt;li>
&lt;p>bindnetaddr:IP #指明把组播地址绑定在哪个网络地址上，注意：是网络地址&lt;/p>
&lt;/li>
&lt;li>
&lt;p>mcastaddr:IP #指明使用的组播地址&lt;/p>
&lt;/li>
&lt;li>
&lt;p>mcastport: NUM #指明组播监听的端口号，默认是 5405&lt;/p>
&lt;/li>
&lt;li>
&lt;p>logging { #指定日志系统信息&lt;/p>
&lt;/li>
&lt;li>
&lt;p>to_logfile: yes|no #定义是否把信息写进日志&lt;/p>
&lt;/li>
&lt;li>
&lt;p>logfile: /PATH #定义日志文件路径，默认为/var/log/corosync/corosync.log&lt;/p>
&lt;/li>
&lt;li>
&lt;p>logger_subsys { #定义 log 子系统&lt;/p>
&lt;/li>
&lt;li>
&lt;p>debug:on|off #定义 debug 是开还是关&lt;/p>
&lt;/li>
&lt;li>
&lt;p>service { #该方法定义 pacemaker 作为 CoroSync 的一个插件来运行&lt;/p>
&lt;pre>&lt;code> ver: 0
name: pacemaker
use_mgmtd:yes
&lt;/code>&lt;/pre>
&lt;/li>
&lt;/ol>
&lt;p>}&lt;/p>
&lt;p>corosync-keygen #如果打开了 secauth，那么需要使用该命令生成一个 corosync 的密钥文件，该命令使用后需要从/dev/random 设备中读取 1024bits 字节数，可以用手输入，或者安装某些程序&lt;/p>
&lt;p>/var/log/XXXXX/corosync.log 日志的使用方法&lt;/p>
&lt;ol>
&lt;li>
&lt;p>grep -e &amp;ldquo;Corosync Cluster Engin&amp;rdquo; -e &amp;ldquo;configuration file&amp;rdquo; corosync.log #查看 CoroSync 引擎是否正常启动&lt;/p>
&lt;/li>
&lt;li>
&lt;p>grep &amp;ldquo;TOTEM&amp;rdquo; corosync.log #查看初始化成员节点通知是否正常发出&lt;/p>
&lt;/li>
&lt;li>
&lt;p>grep &amp;ldquo;pcmk_startup&amp;rdquo; corosync.log #查看 pacemaker 是否正常启动了&lt;/p>
&lt;/li>
&lt;/ol>
&lt;h1 id="crmsh-说明">CRMSH 说明&lt;/h1>
&lt;p>语法结构&lt;/p>
&lt;ol>
&lt;li>
&lt;p>crm [OPTIONS] [COMMAND] [SubCommand &amp;hellip;..]&lt;/p>
&lt;/li>
&lt;li>
&lt;p>#直接输入 crm 命令可以进入 crm shell 界面，在 crm 终端中继续输入相应命令进行操作,或者直接在 crm 后面跟后续命令再接输入的命令中的子命令中的子命令，比如 crm configure show，show 是 configure 的子命令&lt;/p>
&lt;/li>
&lt;li>
&lt;p>COMMAN 与 SubCommand&lt;/p>
&lt;/li>
&lt;/ol>
&lt;ul>
&lt;li>
&lt;p>status #显示当前 Cluster 的状态，如图所示&lt;/p>
&lt;/li>
&lt;li>
&lt;p>configure #对 cluster 进行配置&lt;/p>
&lt;/li>
&lt;li>
&lt;p>show #显示配置信息&lt;/p>
&lt;/li>
&lt;li>
&lt;p>show xml #以 xml 方式显示配置信息&lt;/p>
&lt;/li>
&lt;li>
&lt;p>verify #验证配置完但是还没 commit 的信息是否正确&lt;/p>
&lt;/li>
&lt;li>
&lt;p>commit #提交被改变的配置到 CIB，把在内存中的配置信息写到磁盘中&lt;/p>
&lt;/li>
&lt;li>
&lt;p>primitive|group|clone #定义一个{主|组|克隆}资源，包括该资源代理的类型以及该类型的配置等等信息(注意：如果在定义资源的时候不进行 monitor 监控定义，那么在该资源出现异常无法提供服务的时候，这个资源不会从一个 node 自动切换到另一个 node)&lt;/p>
&lt;/li>
&lt;li>
&lt;p>primitive webip ocf:heartbeat:IPaddr params ip=192.168.100.70 nic=enp0s3 cidr_netmask=16 op monitor interval=10s timeout=20s #定义一个叫 webip 的资源，资源 params(参数)为：ip 地址，网卡，掩码；monitor(监控)信息：间隔时间为 10 秒，超时时间为 20 秒&lt;/p>
&lt;/li>
&lt;li>
&lt;p>间隔时间:每隔多少秒检查一下该资源是否可用&lt;/p>
&lt;/li>
&lt;li>
&lt;p>超时时间：当检测资源是否可用的时间超过多少秒时，则视为该资源失效，需要转移&lt;/p>
&lt;/li>
&lt;li>
&lt;p>primitive webserver lsb:apache2 op monitor interval=10s timeout=20s #定义主资源，资源名为：webserver；资源 params(参数)为：apache2 的进程；monitor(监控)信息：间隔时间为 10 秒，超时时间为 20 秒&lt;/p>
&lt;/li>
&lt;li>
&lt;p>primitive webstore ocf:heartbeat:Filesystem params device=&amp;ldquo;192.168.0.80:/web/htdocs&amp;rdquo; directory=&amp;quot;/var/www/html&amp;quot; fstype=&amp;ldquo;nfs&amp;rdquo; op monitor interval=20s timeout=40s op start timeout=60s op stop timeout=60s #定义一个叫 webstore 的资源，资源 params(参数)为：设备,目录,文件系统类型,monitor(监控)信息:间隔时间为 20 秒，超时时间为 40 秒，资源启动超时时间为 60s，资源停止超时时间为 60 秒&lt;/p>
&lt;/li>
&lt;li>
&lt;p>group webservice webip webserver #定义一个叫 webservice 的组资源，把 webip 和 webserver 两个资源放到同一个资源组&lt;/p>
&lt;/li>
&lt;li>
&lt;p>colocation|location|order #定义{排列约束|位置约束|顺序约束}&lt;/p>
&lt;/li>
&lt;li>
&lt;p>colocation webserver_with_webip inf: webserver webip #定义 webserver 和 webip 排列约束名为 webserver_with_webip，规则为资源在同一个 node 上，约束值 inf 为无穷大(注意：当需要约束的资源同属一个组资源的时候，不用定义该约束)&lt;/p>
&lt;/li>
&lt;li>
&lt;p>order webip_before_webserver Mandatory: webip webserver #定义 webserver 和 webip 顺序约束名为 webip_before_webserver,规则为 webip 第一个启动，webip 不启动，则 webserver 资源也无法启动&lt;/p>
&lt;/li>
&lt;li>
&lt;p>location webip_on_node2 webip rule 50: #uname eq k8s-node2 #定义 webip 资源的位置约束名为 webip_on_node2，规则为 webip 资源倾向于在 node2 上运行，倾向性 50 分，默认分数为 0&lt;/p>
&lt;/li>
&lt;li>
&lt;p>property #配置 Cluster 的全局属性，配置在 show 展示的信息中 property 中的内容，cib 启动程序选项&lt;/p>
&lt;/li>
&lt;li>
&lt;p>property default-resource-stickiness=50 #定义资源默认对当前 node 的粘性，就算另一个 node 的位置约束数值更高，已经在当前节点的资源也不会转移走&lt;/p>
&lt;/li>
&lt;li>
&lt;p>property stonith-enabled=false #定义是否启用 stonith 设备，默认为 true 启动，如果没有 stonith 设备的话，该项配置为 false，否则集群无法使用，两节点集群需要配置为 false&lt;/p>
&lt;/li>
&lt;li>
&lt;p>property no-quorum-policy=ignore #定义在当前节点没有法定票数的时候策略是忽略，两节点集群需要配置为忽略&lt;/p>
&lt;/li>
&lt;li>
&lt;p>edit #修改一个 CIB objects(对象)，以文本形式修改 show 命令展示出的配置信息&lt;/p>
&lt;/li>
&lt;li>
&lt;p>delete #删除一个 CIB objects(对象)&lt;/p>
&lt;/li>
&lt;li>
&lt;p>delete webip_before_webserver #删除一个名字为 webip_before_websrver 的已经被定义了的对象(对象就是各种定义的名字)&lt;/p>
&lt;/li>
&lt;li>
&lt;p>node #对各 node 进行配置&lt;/p>
&lt;/li>
&lt;li>
&lt;p>crm node online #在执行该命令的 node 上线&lt;/p>
&lt;/li>
&lt;li>
&lt;p>crm node standby #在执行该命令的 node 下线变成备用&lt;/p>
&lt;/li>
&lt;li>
&lt;p>resource #对资源进行配置，启动，停止，重启，迁移等&lt;/p>
&lt;/li>
&lt;li>
&lt;p>[un]migrate #迁移一个 resource 到其余 node[迁移一个其余 node 的 resource 至当前 node]&lt;/p>
&lt;/li>
&lt;li>
&lt;p>ra #对资源代理的查看和控制&lt;/p>
&lt;/li>
&lt;li>
&lt;p>classes #查看有哪些资源代理类别&lt;/p>
&lt;/li>
&lt;li>
&lt;p>list #列出 classes 下可支持的所有资源代理&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h1 id="其他说明">其他说明&lt;/h1>
&lt;p>资源类型分类：&lt;/p>
&lt;ol>
&lt;li>
&lt;p>primitive：主资源，只能运行于集群内的某单个节点，也称作 native&lt;/p>
&lt;/li>
&lt;li>
&lt;p>group：组资源，包含一个或多个资源，这些资源可通过“组”这个资源统一进行调度&lt;/p>
&lt;/li>
&lt;li>
&lt;p>clone：克隆资源，可以在同一集群内的多个节点运行多份克隆，每个节点都有一份该资源&lt;/p>
&lt;/li>
&lt;li>
&lt;p>master/slave:主从资源，在同一集群内部与两个节点运行两份资源，其中一个主一个从&lt;/p>
&lt;/li>
&lt;/ol>
&lt;p>HA 的逻辑架构：
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/yal1l0/1616132755527-d5c42b90-751c-4b93-a85c-c02ac1c9b1d2.jpeg" alt="">&lt;/p>
&lt;ol>
&lt;li>
&lt;p>基础设施消息层 Messaging Infrastructure：在 HA 集群的每个节点中部署同一个应用程序以传递各节点的心跳信息以及集群事物信息，从而完成将这些节点构建成一个集群模式，但是该层对集群工作状态的生成的以及对各种事物做出决策，需要由集群管理层实现；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>集群成员关系层 Membership：该层功能可以被合并到 Mesaging Infrastructure 层，这一层主要是用来做决策的，根据法定票数来决定集群的运行，起作用主要是：添加或删除一个节点的时候做决策。在这层用到的一个进程是 CCM（Cluster Consensus Menbership）通过下层的心跳消息来决定其集群的拓扑。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>资源分配层 Resource Allocation:该层提供集群服务。&lt;/p>
&lt;ol>
&lt;li>
&lt;p>CRM 集群管理器（cluster resource manager）：相当于一个由 pacemaker 提供的可操作的命令行工具，通过调用消息层的 API，为上层提供 API 调用接口和管理接口，系统管理员可以通过 CRM 实现管理操作，配置资源的各种约束(即资源运行在哪个 Node 上的定义)等，CRM 类似于一个董事长，可进行决策。&lt;/p>
&lt;ol>
&lt;li>LRM 本地资源管理器（Local Resource Manager）：为 CRM 提供支撑，负责接收 CRM 的指令交给 RA 来实现。&lt;/li>
&lt;/ol>
&lt;/li>
&lt;li>
&lt;p>DC 指派的协调员（Designated Coordinator）：集群中只有一个 DC，在集群中各个节点之间是平等的，但是需要一个协调所有关系的角色，这就是 DC，DC 所在节点即为主节点。对于集群的所有的计算、控制都在这个节点上进行，同时修改 CIB 通常也是在这个节点上进行然后同步到其他节点上去。&lt;/p>
&lt;ol>
&lt;li>
&lt;p>PE 策略引擎（Policy Engine）：通过对这个集群上的所有节点进行计算，来进行决策。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>TE 转移引擎（Transition Engine）：执行决策，是进行监督决策的执行，但本身并不执行，如果是对本机的决策，则直接传给本地的&lt;/p>
&lt;/li>
&lt;/ol>
&lt;/li>
&lt;li>
&lt;p>CIB 集群信息库（Cluster Information Base）：要保证集群中所有节点的服务配置文件完全相同，在服务器之间同步数据的最好方式是使用 xml 格式的数据（其中包括了节点的个数，类型，总权重，以及各个服务器的配置信息等），这个文件就叫 CIB。&lt;/p>
&lt;ol>
&lt;li>cibadmin 命令管理 CIB&lt;/li>
&lt;/ol>
&lt;/li>
&lt;/ol>
&lt;/li>
&lt;li>
&lt;p>资源层 Resources:这一层才是真正提供集群服务资源的。&lt;/p>
&lt;ol>
&lt;li>
&lt;p>资源代理 RA（Resource Agent）：负责实现为下层 LRM 提供启动，停止，监控的资源管理功能，RA 就是很多脚本，大体分为几个类型&lt;/p>
&lt;ol>
&lt;li>
&lt;p>heartbeat V1&lt;/p>
&lt;/li>
&lt;li>
&lt;p>LSB 遵循 linux 规范的 startup 脚本&lt;/p>
&lt;/li>
&lt;li>
&lt;p>OCF 开放式集群格式，类似于 LSB，但是比其更有通用性&lt;/p>
&lt;/li>
&lt;/ol>
&lt;/li>
&lt;/ol>
&lt;/li>
&lt;/ol>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/yal1l0/1616132755522-d36e0eff-da9d-482a-b363-1b6fedee53e2.jpeg" alt="">&lt;/p>
&lt;ul>
&lt;li>
&lt;p>消息层 #HA 的底层通讯模块，负责节点间的通信、心跳信息传递，集群事务消息传递。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>CRM 层 #HA 的资源调度模块，负责资源的配置、管理和调度。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>LRM #负责在每一个节点上执行 CRM 所发出的指令，类似于每个节点安装一个 LRM 然后接收控制节点上 CRM 发出的指令，也可以每个节点都安装 CRM，只不过 LRM 只能对自己所在的节点进行操作，而 CRM 可以给所有节点的 LRM 发送指令&lt;/p>
&lt;/li>
&lt;li>
&lt;p>agent #HA 的资源代理，通过接受 LRM 层的 CRM 指令完成对所在节点的指定类型资源的管理。一个代理对应一类资源(图中的 A,B&amp;hellip;X 指的就是资源)&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>HA 各层的解决方案：&lt;/p>
&lt;ol>
&lt;li>
&lt;p>Messaging Layer：&lt;/p>
&lt;ol>
&lt;li>
&lt;p>heartbeat：分 V1,V2，V3 版本&lt;/p>
&lt;/li>
&lt;li>
&lt;p>corosync：华为 HACS 用该方案&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Cman&lt;/p>
&lt;/li>
&lt;li>
&lt;p>keepalived(工作方式完全不同于以上三种)&lt;/p>
&lt;/li>
&lt;/ol>
&lt;/li>
&lt;li>
&lt;p>资源分配层 Resource Allocation:CRM：cluster resource manager 集群资源管理器(管理)&lt;/p>
&lt;ol>
&lt;li>
&lt;p>Heartbeat V1-HAresources：(配置接口：不通过命令管理，而是通过配置文件管理，配置文件的名称为 haresources)&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Heartbeat V2-crm：在各节点运行一个 crmd 进程，配置接口：命令行客户端程序 crmsh(crm 命令)；GUI 客户端：hb_gui&lt;/p>
&lt;/li>
&lt;li>
&lt;p>pacemaker：从 Heartbeat V3 独立出来，可以以插件或独立方式运行.配置接口：CLI 接口:crmsh，pcs；GUI：hawk，LCMC，pacemaker-mgmt&lt;/p>
&lt;/li>
&lt;li>
&lt;p>rgmanager：resource group manager 资源组管理器。配置接口：CLI：clustat，cman_tool；GUI：Conga&lt;/p>
&lt;/li>
&lt;li>
&lt;p>CRM 分类&lt;/p>
&lt;ol>
&lt;li>
&lt;p>HA-aware：资源自身可直接调用 HA 集群底层的 HA 功能&lt;/p>
&lt;/li>
&lt;li>
&lt;p>非 HA-aware：必须要借助于 CRM 完成在 HA 集群上实现 HA 功能&lt;/p>
&lt;/li>
&lt;/ol>
&lt;/li>
&lt;/ol>
&lt;/li>
&lt;li>
&lt;p>LRM：Local resource manager 本地资源管理器&lt;/p>
&lt;ol>
&lt;li>由 CRM 通过子程序提供&lt;/li>
&lt;/ol>
&lt;/li>
&lt;li>
&lt;p>RA:Resource Agent 资源代理，就是一个脚本，LRM 负责激活该脚本，CRM 负责决定在哪个资源上激活该脚本&lt;/p>
&lt;ol>
&lt;li>
&lt;p>heartbeat legacy：heartbeat 传统类型的 RA，通常位于/etc/ha.d/haresources.d 目录下&lt;/p>
&lt;/li>
&lt;li>
&lt;p>LSB：Linux Standard Base，Linux 基本库，通常位于/etc/rc.d/init.d/目录下，这些脚本至少接收 4 个参数{start|stop|restart|status}&lt;/p>
&lt;/li>
&lt;li>
&lt;p>OCF：(probider)Open Cluster Framework，开发集群框架&lt;/p>
&lt;/li>
&lt;li>
&lt;p>STONITH：专用于实现调用 STONIT 功能设备的资源，通常为 clone 类型&lt;/p>
&lt;/li>
&lt;/ol>
&lt;/li>
&lt;li>
&lt;p>解决方案的组合方式&lt;/p>
&lt;ol>
&lt;li>
&lt;p>corosync+pacemaker&lt;/p>
&lt;/li>
&lt;li>
&lt;p>cman+rgmanager&lt;/p>
&lt;/li>
&lt;li>
&lt;p>等&lt;/p>
&lt;/li>
&lt;/ol>
&lt;/li>
&lt;/ol>
&lt;p>资源的约束(constraints)：启动完一个 HA 集群之后，HA 最终是要支撑业务的运行，业务是由各个节点的资源来提供的。一个资源更倾向于运行在哪个节点上，资源和资源之间是互斥的还是互相吸引的，以及资源和资源之间谁先谁后，是有一定的约束的，通过约束来指挥资源以最优的方式运行于何种节点上&lt;/p>
&lt;ol>
&lt;li>
&lt;p>资源的约束关系&lt;/p>
&lt;ol>
&lt;li>
&lt;p>location：位置约束，定义资源运行于某节点的倾向性，用数值来表示，倾向性指该资源对于该节点之前的感情，类似于女人喜欢钱，但是有另一个更有钱的男人追求她，她更倾向于前者，那么后追的人再有钱也不会跟着去的&lt;/p>
&lt;/li>
&lt;li>
&lt;p>colocation：排列约束，定义资源彼此间是否可以运行在同一节点的倾向性&lt;/p>
&lt;/li>
&lt;li>
&lt;p>order:顺序约束，定义资源在同一个节点上启动的先后顺序，先启动没起来，则后启动的也起不来；后启动的如果&lt;/p>
&lt;/li>
&lt;/ol>
&lt;/li>
&lt;/ol>
&lt;p>心跳信息传递机制：通过 Messaging Layer 层的组件，主节点主动通报类似于&amp;quot;我还活着&amp;quot;的信息。因为多节点集群，只有在主动通报的情况下才会效率最大，否则每个节点都去查看主节点信息就太浪费资源了。该消息通过组播网络进行发送&lt;/p>
&lt;p>udp 单播 组播 广播&lt;/p>
&lt;p>组播地址：用于标识一个 ip 组播域，d 类地址空间，范围是 224.0.0.0-239.255.255.255&lt;/p>
&lt;ol>
&lt;li>
&lt;p>永久组播地址：224.0.0.0-224.0.0.255&lt;/p>
&lt;/li>
&lt;li>
&lt;p>临时组播地址：224.0.1.0-238.255.255.255，自己用&lt;/p>
&lt;/li>
&lt;li>
&lt;p>本地组播地址：239.0.0.0-239.255.255.255，仅在特定本地范围内有效&lt;/p>
&lt;/li>
&lt;/ol>
&lt;p>HA 集群可能发生的故障以及应对情况&lt;/p>
&lt;p>故障一：partitioned cluster 分裂集群，集群脑裂 cluster split brain：当 HA 的各节点之间无法互相通信的时候，无法报告自己的状态信息，每个节点都会认为自己是可用的，别的节点都挂掉了，那么每个节点都会抢夺资源，这就是脑裂&lt;/p>
&lt;p>一般情况下，HA 集群的节点个数推荐为奇数个，这样才能保证产生分裂时，总有那么一方拥有的票数最大，vote system 即是决定该功能的系统&lt;/p>
&lt;ol>
&lt;li>
&lt;p>vote system:投票系统，HA 中的各节点无法探测彼此的心跳信息时，必然无法协调工作，而此种状态即为 partitioned cluster；必须按照少数服从多数的原则，Current DC(当前 DC)的状态分两种&lt;/p>
&lt;ol>
&lt;li>
&lt;p>with quorum #当前具有法定票数，具有这种状态的即为主节点&lt;/p>
&lt;/li>
&lt;li>
&lt;p>without quorum 当前节点没有拥有法定票数，如果出现该状态，则会出现几种处理方式&lt;/p>
&lt;ol>
&lt;li>
&lt;p>stopped #停止&lt;/p>
&lt;/li>
&lt;li>
&lt;p>ignore #忽略&lt;/p>
&lt;/li>
&lt;li>
&lt;p>freeze #冻结&lt;/p>
&lt;/li>
&lt;li>
&lt;p>suicide #自杀&lt;/p>
&lt;/li>
&lt;li>
&lt;p>那么就会被隔离，隔离方式分为两类；&lt;/p>
&lt;ol>
&lt;li>
&lt;p>节点：STONITH：Shooting The Others Node In The Head，直接关掉该节点电源&lt;/p>
&lt;/li>
&lt;li>
&lt;p>资源：fencing 隔离&lt;/p>
&lt;/li>
&lt;/ol>
&lt;/li>
&lt;/ol>
&lt;/li>
&lt;/ol>
&lt;/li>
&lt;/ol>
&lt;p>故障二：正常情况下，当用户请求到路由器的时候，会把请求转发给 HA 中的浮动 ip，该浮动 ip 所在主机的 mac 地址会发送给路由器，路由器更新 arp 表，绑定浮动 ip 与该主机 mac 的关系；当该主机不可用时，用户请求再到路由器时，路由器查询自己的 arp 表，依然把请求转发到那台已经不可用的主机上，这时 HA 就不可用了。&lt;/p>
&lt;ul>
&lt;li>解决方法：当 HA 集群主节点不可用。浮动 ip 转移以后，浮动 ip 所在的新节点会通过一个 arp 脚本 send_arp，广播自己的 mac 与该浮动 ip 的绑定关系，让集群内所有的其余节点和前端路由设备更新自己的 arp 表&lt;/li>
&lt;/ul>
&lt;p>HA 的工作模型：&lt;/p>
&lt;ol>
&lt;li>
&lt;p>A/P：两节点集群，Active，Passive 两个主备模型，一主一备，只有主节点运行 service 的所有 resource&lt;/p>
&lt;/li>
&lt;li>
&lt;p>A/A：两节点集群：Active，Active 两个双活模型，互备，比如：设备 1 运行一个 web service，设备 2 运行 mail service，web sevice 在设备 1 是主，设备 2 是备；mail service 在设备 1 是备，设备 2 是主；每个服务都会有自己独立的浮动 IP(类似于 VRRP 的多个虚拟 IP，每个虚拟 IP 当一个网段的网关)。一般情况下&lt;/p>
&lt;/li>
&lt;li>
&lt;p>N/M：n 个节点 m 个服务(不是资源，多个资源组成服务)，通常 n&amp;gt;m&lt;/p>
&lt;/li>
&lt;li>
&lt;p>N/N：n 个节点 n 个服务&lt;/p>
&lt;/li>
&lt;/ol>
&lt;h3 id="ha-案例一ha-web-services">HA 案例一：HA Web Services&lt;/h3>
&lt;p>所需资源：ip，httpd，filesystem，floating ip&lt;/p>
&lt;p>约束关系：&lt;/p>
&lt;ol>
&lt;li>
&lt;p>使用“组”资源，或通过排列约束让资源运行于同一节点&lt;/p>
&lt;/li>
&lt;li>
&lt;p>顺序约束：有次序地启动资源&lt;/p>
&lt;/li>
&lt;/ol>
&lt;p>解决方案组合：&lt;/p>
&lt;p>heartbeat v2+haresources 或者 crm&lt;/p>
&lt;p>配置 HA 集群的前提：&lt;/p>
&lt;ol>
&lt;li>
&lt;p>节点之间时间必须同步，使用 NTP 协议实现&lt;/p>
&lt;/li>
&lt;li>
&lt;p>节点间需要通过主机名互相通信，必须可以解析主机名至 IP 地址&lt;/p>
&lt;ol>
&lt;li>
&lt;p>建议名称解析功能使用 hosts 文件来实现&lt;/p>
&lt;/li>
&lt;li>
&lt;p>通信中使用的名字与节点名字必须保持一致：“uname -n”命令或者“hostname”命令展示出的名字一样&lt;/p>
&lt;/li>
&lt;/ol>
&lt;/li>
&lt;li>
&lt;p>考虑仲裁设备是否会用到，两节点必会用&lt;/p>
&lt;/li>
&lt;li>
&lt;p>建立各节点之间的 root 用户能够基于密钥认证&lt;/p>
&lt;ol>
&lt;li>
&lt;p>#ssh-keygen -t rsa -P &amp;rsquo; &amp;rsquo; -f FILE&lt;/p>
&lt;/li>
&lt;li>
&lt;p>#ssh-copy-id -i /root/.ssh/id_rsa.pub root@HOSTNAME&lt;/p>
&lt;/li>
&lt;/ol>
&lt;/li>
&lt;li>
&lt;p>注意：定义称为集群服务中的资源，一定不能开机自启动，需要由 crm 统一管理&lt;/p>
&lt;/li>
&lt;/ol>
&lt;p>配置文件说明&lt;/p>
&lt;ol>
&lt;li>
&lt;p>/etc/ha.d 目录下&lt;/p>
&lt;ol>
&lt;li>
&lt;p>ha.cf:主配置文件，定义各节点上的 heartbeat HA 集群的基本属性，以及集群事务信息如何传递的。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>authkeys：集群内节点间彼此传递消息时使用加密算法及密&lt;/p>
&lt;/li>
&lt;li>
&lt;p>haresources：为 heartbeat v1 提供资源管理器配置接口，v1 版本专用配置接口，定义拥有哪些资源，以及节点资源运行的倾向性的&lt;/p>
&lt;/li>
&lt;/ol>
&lt;/li>
&lt;/ol>
&lt;h3 id="ha-案例二ha-mysql">HA 案例二：HA Mysql&lt;/h3>
&lt;h2 id="ha-中常用的术语">HA 中常用的术语&lt;/h2>
&lt;ol>
&lt;li>
&lt;p>SPOF：Single Point of Failure 单点故障，HA 是由于 SPOF 的隐患所产生的高可用冗余方案&lt;/p>
&lt;/li>
&lt;li>
&lt;p>MTBF：mean time between failure 平均无故障时间&lt;/p>
&lt;/li>
&lt;li>
&lt;p>MTTR：mean time to repair 平均修复时长&lt;/p>
&lt;/li>
&lt;li>
&lt;p>A=MTBF/(MTBF+MTTR)，则 0&lt;/p>
&lt;/li>
&lt;li>
&lt;p>director：调度器&lt;/p>
&lt;/li>
&lt;li>
&lt;p>failover：失效转移，故障转移&lt;/p>
&lt;/li>
&lt;li>
&lt;p>failback：失效转回，故障转回&lt;/p>
&lt;/li>
&lt;li>
&lt;p>message layer&lt;/p>
&lt;/li>
&lt;li>
&lt;p>DC：designated coordinator #指派的协调员，在分配为 DC（designated coordinator）的机器上创建 ha.cf&lt;/p>
&lt;/li>
&lt;li>
&lt;p>CIB：Cluster Information Base&lt;/p>
&lt;/li>
&lt;/ol>
&lt;p>异地多活模式，多个机房多活动中心，数据基于机房之间同步&lt;/p>
&lt;p>Real Server：让 director 对其做健康状态检测，并且根据检测的结果自动完成添加或者移除等管理&lt;/p>
&lt;ol>
&lt;li>
&lt;p>基于协议层次检查(lvs 不具备健康检测机制)&lt;/p>
&lt;ol>
&lt;li>
&lt;p>ip:icmp&lt;/p>
&lt;/li>
&lt;li>
&lt;p>传输层：检测端口的开放状态&lt;/p>
&lt;/li>
&lt;li>
&lt;p>应用层：请求获取关键性资源，根据是否获取到资源来进行判断&lt;/p>
&lt;/li>
&lt;/ol>
&lt;/li>
&lt;li>
&lt;p>检查频度&lt;/p>
&lt;/li>
&lt;li>
&lt;p>状态判断&lt;/p>
&lt;/li>
&lt;/ol></description></item><item><title>Docs: events 模块指令</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/3.%E9%9B%86%E7%BE%A4%E4%B8%8E%E5%88%86%E5%B8%83%E5%BC%8F/nginx/nginx-%E9%85%8D%E7%BD%AE%E8%AF%A6%E8%A7%A3/events-%E6%A8%A1%E5%9D%97%E6%8C%87%E4%BB%A4/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/3.%E9%9B%86%E7%BE%A4%E4%B8%8E%E5%88%86%E5%B8%83%E5%BC%8F/nginx/nginx-%E9%85%8D%E7%BD%AE%E8%AF%A6%E8%A7%A3/events-%E6%A8%A1%E5%9D%97%E6%8C%87%E4%BB%A4/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;h1 id="指令详解">指令详解&lt;/h1>
&lt;p>&lt;a href="http://nginx.org/en/docs/ngx_core_module.html#worker_connections">&lt;strong>worker_connections NUMBER;&lt;/strong>&lt;/a> # worker 进程最大并发连接数&lt;/p>
&lt;ul>
&lt;li>默认值：&lt;code>worker_connections 512;&lt;/code>&lt;/li>
&lt;/ul></description></item><item><title>Docs: geo/geoip 模块指令</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/3.%E9%9B%86%E7%BE%A4%E4%B8%8E%E5%88%86%E5%B8%83%E5%BC%8F/nginx/nginx-%E9%85%8D%E7%BD%AE%E8%AF%A6%E8%A7%A3/%E5%A4%9A%E7%94%A8%E9%80%94%E6%A8%A1%E5%9D%97%E7%9A%84%E6%8C%87%E4%BB%A4/geo_geoip-%E6%A8%A1%E5%9D%97%E6%8C%87%E4%BB%A4/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/3.%E9%9B%86%E7%BE%A4%E4%B8%8E%E5%88%86%E5%B8%83%E5%BC%8F/nginx/nginx-%E9%85%8D%E7%BD%AE%E8%AF%A6%E8%A7%A3/%E5%A4%9A%E7%94%A8%E9%80%94%E6%A8%A1%E5%9D%97%E7%9A%84%E6%8C%87%E4%BB%A4/geo_geoip-%E6%A8%A1%E5%9D%97%E6%8C%87%E4%BB%A4/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="http://nginx.org/en/docs/http/ngx_http_geo_module.html">http 模块下的 geo 模块&lt;/a>、&lt;a href="http://nginx.org/en/docs/http/ngx_http_geoip_module.html">geoip 模块&lt;/a>&lt;/li>
&lt;li>&lt;a href="http://nginx.org/en/docs/stream/ngx_stream_geo_module.html">stream 模块下的 geo 模块&lt;/a>、&lt;a href="http://nginx.org/en/docs/stream/ngx_stream_geoip_module.html">geoip 模块&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>geo 与 geoip 模块会根据 客户端的 IP 地址 来创建新的变量。这些变量用来表示 IP 地址所属国际、所属城市、所在经/纬度 等等。&lt;/p>
&lt;p>不同之处在于：&lt;/p>
&lt;ul>
&lt;li>geo 手动设置变量及其值&lt;/li>
&lt;li>geoip 根据 &lt;a href="http://www.maxmind.com/">MaxMind&lt;/a> 数据库中的信息，创建一系列的变量&lt;/li>
&lt;/ul>
&lt;p>通过 geo/geoip 模块，我们可以根据客户端的 IP 地址，获取这些 IP 的一些信息，比如 IP 所属城市、所属国家，所在经/纬度 等等。我们常常可以根据这些分类的信息，&lt;strong>进行 IP 过滤、或日志记录&lt;/strong>。说白了，geo/geoip 模块就是为每个 IP 地址添加一系列的 &lt;strong>Label(标签)&lt;/strong>，以便后续可以根据这些 标签 进行 记录 和 筛选。&lt;/p>
&lt;blockquote>
&lt;p>v2ray 中的测试，有很多 geosite 相关的设置，就是这个道理，每个 IP 地址都可以具有很多标签、甚至连这个 IP 所属的公司都会记录，以便可以根据这些进行来决定一个请求是 直连 还是 代理。&lt;/p>
&lt;/blockquote>
&lt;h1 id="http-模块下的-geo-模块指令">http 模块下的 geo 模块指令&lt;/h1>
&lt;p>&lt;a href="http://nginx.org/en/docs/http/ngx_http_geo_module.html#geo">&lt;strong>geo [ADDRESS] $VARIABLE {}&lt;/strong>&lt;/a>** **# 根据 ADDRESS 定义新的变量
ADDRESS 用来指定要设置变量的 IP 地址。默认来自于 &lt;code>$remote_addr&lt;/code> 变量，也可以自定义为另一个变量。&lt;/p>
&lt;p>假如现在有这么一个配置：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-nginx" data-lang="nginx">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">geo&lt;/span> $country {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">default&lt;/span> &lt;span style="color:#e6db74">ZZ&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">include&lt;/span> &lt;span style="color:#e6db74">conf/geo.conf&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">delete&lt;/span> &lt;span style="color:#ae81ff">127&lt;/span>&lt;span style="color:#e6db74">.0.0.0/16&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">proxy&lt;/span> &lt;span style="color:#ae81ff">192&lt;/span>&lt;span style="color:#e6db74">.168.100.0/24&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">proxy&lt;/span> 2001:&lt;span style="color:#ae81ff">0&lt;/span>&lt;span style="color:#e6db74">db8::/32&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">127.0.0.0/24&lt;/span> &lt;span style="color:#e6db74">US&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">127.0.0.1/32&lt;/span> &lt;span style="color:#e6db74">RU&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">10.1.0.0/16&lt;/span> &lt;span style="color:#e6db74">RU&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">192.168.1.0/24&lt;/span> &lt;span style="color:#e6db74">UK&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>表示 Nginx 将会默认根据 $remote_addr 变量的值设置一个 &lt;code>$country&lt;/code> 变量，也就是根据当前请求的 客户端 IP 地址 来这设置一个 $country 变量。&lt;/p>
&lt;ul>
&lt;li>default # 默认情况下，所有 IP 地址的 &lt;code>$country&lt;/code> 变量的值为 ZZ&lt;/li>
&lt;li>include # 将指令写在其他文件中，并通过 include 包含进来&lt;/li>
&lt;li>delete # 删除 127.0.0.0/16 这段 IP 地址的 &lt;code>$country&lt;/code> 变量&lt;/li>
&lt;li>127.0.0.0/24   US; # 这些 IP 中的 127.0.0.0/24 这一段的的值为 US；127.0.0.1/32 这个
&lt;ul>
&lt;li>后面的以此类推&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h1 id="http-模块下的-geoip-模块指令">http 模块下的 geoip 模块指令&lt;/h1>
&lt;p>geoip 模块并不需要手动设定想要创建的变量，由于 geoip 模块是基于 MaxMind 数据库，所以会根据 geoip 中的指令来创建对应的变量。&lt;/p>
&lt;p>geoip 模块会从 Nginx 获取客户端的 IP 地址(一般都是 $remote_addr 变量中的值)，然后根据 IP 地址从 MaxMind 数据库查找对应的 IP，并将与该 IP 关联的信息写入到新的变量中。&lt;/p>
&lt;p>&lt;a href="http://nginx.org/en/docs/http/ngx_http_geoip_module.html#geoip_country">**geoip_country FILE; **&lt;/a># 围绕国家创建相关变量
该指令一般情况下，将会根据 MaxMind 中的 GeoIP.dat 文件，为每个 IP 地址创建如下变量：&lt;/p>
&lt;ul>
&lt;li>&lt;strong>$geoip_country_code&lt;/strong> # 两个字母的国家代码，比如 CN、US&lt;/li>
&lt;li>&lt;strong>$geoip_country_code3&lt;/strong> # 三个字母的国家代码，比如 CHN、USA&lt;/li>
&lt;li>&lt;strong>$geoip_country_name&lt;/strong> # 国家名称，比如 China、United States&lt;/li>
&lt;/ul>
&lt;p>&lt;a href="http://nginx.org/en/docs/http/ngx_http_geoip_module.html#geoip_city">&lt;strong>geoip_city FILE;&lt;/strong>&lt;/a> # 围绕城市创建相关变量。最常用指令
该指令一般情况下，将会根据 MaxMind 中的 GeoLiteCity.dat 文件，为每个 IP 地址创建如下变量：&lt;/p>
&lt;ul>
&lt;li>&lt;strong>$geoip_area_code&lt;/strong> # 电话区号(仅限 US 有用).
&lt;ul>
&lt;li>此变量可能包含过时的信息，因为不推荐使用相应的数据库字段。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>$geoip_city_continent_code&lt;/strong> # 两个字母的大洲代码，比如 EU、NA&lt;/li>
&lt;li>&lt;strong>$geoip_city_country_code&lt;/strong> # 两个字母的国家代码，比如 CN、US&lt;/li>
&lt;li>&lt;strong>$geoip_city_country_code3&lt;/strong> # 三个字母的国家代码，比如 CHN、USA&lt;/li>
&lt;li>&lt;strong>$geoip_city_country_name&lt;/strong> # 国家名称，比如 China、United States&lt;/li>
&lt;li>&lt;strong>$geoip_dma_code&lt;/strong> # 根据 Google AdWords API 中的地理定位，美国的 DMA 区域代码 (也称为 metro code)。&lt;/li>
&lt;li>&lt;strong>$geoip_latitude&lt;/strong> # latitude(纬度)&lt;/li>
&lt;li>&lt;strong>$geoip_longitude&lt;/strong> # longitude(经度)&lt;/li>
&lt;li>&lt;strong>$geoip_region&lt;/strong> # 两个字母的地区代码，比如 JX
&lt;ul>
&lt;li>region 就是省的概念，直辖市的 省 与 市 同名&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>$geoip_region_name&lt;/strong> # 两个字母的地区名称，比如 Jiangxi&lt;/li>
&lt;li>&lt;strong>$geoip_city&lt;/strong> # 城市名称，比如，Beijing、Tianjin&lt;/li>
&lt;li>&lt;strong>$geoip_postal_code&lt;/strong> # 邮政编码&lt;/li>
&lt;/ul>
&lt;p>这些变量是最常用的，用来描述 IP 地址关于城市相关的信息，比如客户端的 IP 地址为 111.33.112.94，那么这个 IP 就属于天津市，并且还会有关于该城市的相关信息。比如城市所属国家、所属大洲、所在经纬度、邮编、城市代码 等等信息。&lt;/p>
&lt;p>&lt;a href="http://nginx.org/en/docs/http/ngx_http_geoip_module.html#geoip_org">&lt;strong>geoip_org FILE;&lt;/strong>&lt;/a> #
该指令一般情况下，将会根据 MaxMind 中的 GeoLiteCity.dat 文件创建如下变量：&lt;/p>
&lt;ul>
&lt;li>**$geoip_org **# 组织名称，比如 The University of Melbourne&lt;/li>
&lt;/ul></description></item><item><title>Docs: geoip2 模块</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/3.%E9%9B%86%E7%BE%A4%E4%B8%8E%E5%88%86%E5%B8%83%E5%BC%8F/nginx/nginx-%E9%85%8D%E7%BD%AE%E8%AF%A6%E8%A7%A3/%E5%A4%9A%E7%94%A8%E9%80%94%E6%A8%A1%E5%9D%97%E7%9A%84%E6%8C%87%E4%BB%A4/geoip2-%E6%A8%A1%E5%9D%97/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/3.%E9%9B%86%E7%BE%A4%E4%B8%8E%E5%88%86%E5%B8%83%E5%BC%8F/nginx/nginx-%E9%85%8D%E7%BD%AE%E8%AF%A6%E8%A7%A3/%E5%A4%9A%E7%94%A8%E9%80%94%E6%A8%A1%E5%9D%97%E7%9A%84%E6%8C%87%E4%BB%A4/geoip2-%E6%A8%A1%E5%9D%97/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：yqu&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://github.com/leev/ngx_http_geoip2_module">GitHub 项目，leev/ngx_http_geoip2_module&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>由于隐私的原因，&lt;a href="https://blog.maxmind.com/2019/12/18/significant-changes-to-accessing-and-using-geolite2-databases/">MaxMind 在 2019 年 12 月份对数据库进行重大变更&lt;/a>，所以，老式的 geo/geoip 模块不再适用于新的 MaxMind 数据库，所以，geoip2 模块诞生了。&lt;/p>
&lt;p>从&lt;a href="https://www.maxmind.com/en/accounts/545756/geoip/downloads">这个页面可&lt;/a>以下载 GeoIP2 和 旧版的 GeoIP 数据库&lt;/p>
&lt;p>geoip2 模块与 geo/geoip 模块的功能类似。geoip2 模块根据 客户端的 IP 信息，使用 MaxMind 的 geoip2 数据库中的值创建变量。只不过指令用法稍有不同。&lt;/p>
&lt;h2 id="用法示例">用法示例&lt;/h2>
&lt;h3 id="首先通过-mmdblookuphttpsmaxmindgithubiolibmaxminddbmmdblookuphtml-工具查看数据库中的内容">首先通过 &lt;a href="https://maxmind.github.io/libmaxminddb/mmdblookup.html">mmdblookup&lt;/a> 工具查看数据库中的内容&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-json" data-lang="json">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#960050;background-color:#1e0010">root@lichenhao:~/test_dir/downloads#&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">mmdblookup&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">--file&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">./GeoLite&lt;/span>&lt;span style="color:#ae81ff">2&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">-City.mmdb&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">--ip&lt;/span> &lt;span style="color:#ae81ff">59.46&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">.&lt;/span>&lt;span style="color:#ae81ff">138.226&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;city&amp;#34;&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;geoname_id&amp;#34;&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ae81ff">1814087&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">&amp;lt;uint&lt;/span>&lt;span style="color:#ae81ff">32&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#34;names&amp;#34;&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;en&amp;#34;&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#34;Dalian&amp;#34;&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">&amp;lt;utf&lt;/span>&lt;span style="color:#ae81ff">8&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">_string&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#34;ja&amp;#34;&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#34;大連市&amp;#34;&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">&amp;lt;utf&lt;/span>&lt;span style="color:#ae81ff">8&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">_string&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#34;ru&amp;#34;&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#34;Далянь&amp;#34;&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">&amp;lt;utf&lt;/span>&lt;span style="color:#ae81ff">8&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">_string&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#34;zh-CN&amp;#34;&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#34;大连&amp;#34;&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">&amp;lt;utf&lt;/span>&lt;span style="color:#ae81ff">8&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">_string&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#34;continent&amp;#34;&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;code&amp;#34;&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#34;AS&amp;#34;&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">&amp;lt;utf&lt;/span>&lt;span style="color:#ae81ff">8&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">_string&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#34;geoname_id&amp;#34;&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ae81ff">6255147&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">&amp;lt;uint&lt;/span>&lt;span style="color:#ae81ff">32&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#34;names&amp;#34;&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;de&amp;#34;&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#34;Asien&amp;#34;&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">&amp;lt;utf&lt;/span>&lt;span style="color:#ae81ff">8&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">_string&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#34;en&amp;#34;&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#34;Asia&amp;#34;&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">&amp;lt;utf&lt;/span>&lt;span style="color:#ae81ff">8&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">_string&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#34;es&amp;#34;&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#34;Asia&amp;#34;&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">&amp;lt;utf&lt;/span>&lt;span style="color:#ae81ff">8&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">_string&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#34;fr&amp;#34;&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#34;Asie&amp;#34;&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">&amp;lt;utf&lt;/span>&lt;span style="color:#ae81ff">8&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">_string&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#34;ja&amp;#34;&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#34;アジア&amp;#34;&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">&amp;lt;utf&lt;/span>&lt;span style="color:#ae81ff">8&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">_string&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#34;pt-BR&amp;#34;&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#34;Ásia&amp;#34;&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">&amp;lt;utf&lt;/span>&lt;span style="color:#ae81ff">8&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">_string&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#34;ru&amp;#34;&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#34;Азия&amp;#34;&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">&amp;lt;utf&lt;/span>&lt;span style="color:#ae81ff">8&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">_string&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#34;zh-CN&amp;#34;&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#34;亚洲&amp;#34;&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">&amp;lt;utf&lt;/span>&lt;span style="color:#ae81ff">8&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">_string&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#34;country&amp;#34;&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;geoname_id&amp;#34;&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ae81ff">1814991&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">&amp;lt;uint&lt;/span>&lt;span style="color:#ae81ff">32&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#34;iso_code&amp;#34;&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#34;CN&amp;#34;&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">&amp;lt;utf&lt;/span>&lt;span style="color:#ae81ff">8&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">_string&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#34;names&amp;#34;&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;de&amp;#34;&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#34;China&amp;#34;&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">&amp;lt;utf&lt;/span>&lt;span style="color:#ae81ff">8&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">_string&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#34;en&amp;#34;&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#34;China&amp;#34;&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">&amp;lt;utf&lt;/span>&lt;span style="color:#ae81ff">8&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">_string&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#34;es&amp;#34;&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#34;China&amp;#34;&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">&amp;lt;utf&lt;/span>&lt;span style="color:#ae81ff">8&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">_string&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#34;fr&amp;#34;&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#34;Chine&amp;#34;&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">&amp;lt;utf&lt;/span>&lt;span style="color:#ae81ff">8&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">_string&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#34;ja&amp;#34;&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#34;中国&amp;#34;&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">&amp;lt;utf&lt;/span>&lt;span style="color:#ae81ff">8&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">_string&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#34;pt-BR&amp;#34;&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#34;China&amp;#34;&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">&amp;lt;utf&lt;/span>&lt;span style="color:#ae81ff">8&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">_string&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#34;ru&amp;#34;&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#34;Китай&amp;#34;&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">&amp;lt;utf&lt;/span>&lt;span style="color:#ae81ff">8&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">_string&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#34;zh-CN&amp;#34;&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#34;中国&amp;#34;&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">&amp;lt;utf&lt;/span>&lt;span style="color:#ae81ff">8&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">_string&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#34;location&amp;#34;&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;accuracy_radius&amp;#34;&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ae81ff">1000&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">&amp;lt;uint&lt;/span>&lt;span style="color:#ae81ff">16&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#34;latitude&amp;#34;&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ae81ff">38.912200&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">&amp;lt;double&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#34;longitude&amp;#34;&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ae81ff">121.602200&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">&amp;lt;double&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#34;time_zone&amp;#34;&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#34;Asia/Shanghai&amp;#34;&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">&amp;lt;utf&lt;/span>&lt;span style="color:#ae81ff">8&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">_string&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#34;registered_country&amp;#34;&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;geoname_id&amp;#34;&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ae81ff">1814991&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">&amp;lt;uint&lt;/span>&lt;span style="color:#ae81ff">32&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#34;iso_code&amp;#34;&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#34;CN&amp;#34;&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">&amp;lt;utf&lt;/span>&lt;span style="color:#ae81ff">8&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">_string&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#34;names&amp;#34;&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;de&amp;#34;&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#34;China&amp;#34;&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">&amp;lt;utf&lt;/span>&lt;span style="color:#ae81ff">8&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">_string&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#34;en&amp;#34;&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#34;China&amp;#34;&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">&amp;lt;utf&lt;/span>&lt;span style="color:#ae81ff">8&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">_string&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#34;es&amp;#34;&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#34;China&amp;#34;&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">&amp;lt;utf&lt;/span>&lt;span style="color:#ae81ff">8&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">_string&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#34;fr&amp;#34;&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#34;Chine&amp;#34;&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">&amp;lt;utf&lt;/span>&lt;span style="color:#ae81ff">8&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">_string&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#34;ja&amp;#34;&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#34;中国&amp;#34;&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">&amp;lt;utf&lt;/span>&lt;span style="color:#ae81ff">8&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">_string&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#34;pt-BR&amp;#34;&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#34;China&amp;#34;&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">&amp;lt;utf&lt;/span>&lt;span style="color:#ae81ff">8&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">_string&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#34;ru&amp;#34;&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#34;Китай&amp;#34;&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">&amp;lt;utf&lt;/span>&lt;span style="color:#ae81ff">8&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">_string&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#34;zh-CN&amp;#34;&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#34;中国&amp;#34;&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">&amp;lt;utf&lt;/span>&lt;span style="color:#ae81ff">8&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">_string&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#34;subdivisions&amp;#34;&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> [
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;geoname_id&amp;#34;&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ae81ff">2036115&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">&amp;lt;uint&lt;/span>&lt;span style="color:#ae81ff">32&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#34;iso_code&amp;#34;&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#34;LN&amp;#34;&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">&amp;lt;utf&lt;/span>&lt;span style="color:#ae81ff">8&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">_string&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#34;names&amp;#34;&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;en&amp;#34;&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#34;Liaoning&amp;#34;&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">&amp;lt;utf&lt;/span>&lt;span style="color:#ae81ff">8&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">_string&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#34;fr&amp;#34;&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#34;Province de Liaoning&amp;#34;&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">&amp;lt;utf&lt;/span>&lt;span style="color:#ae81ff">8&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">_string&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#34;zh-CN&amp;#34;&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#34;辽宁&amp;#34;&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">&amp;lt;utf&lt;/span>&lt;span style="color:#ae81ff">8&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">_string&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="根据数据库内容定义变量">根据数据库内容，定义变量&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-nginx" data-lang="nginx">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">http&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">...&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e"># 指定数据库路径
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#e6db74">geoip2&lt;/span> &lt;span style="color:#e6db74">/etc/maxmind-country.mmdb&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">auto_reload&lt;/span> &lt;span style="color:#ae81ff">5m&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e"># 根据数据库内容生成变量
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#f92672">$geoip2_metadata_country_build&lt;/span> &lt;span style="color:#e6db74">metadata&lt;/span> &lt;span style="color:#e6db74">build_epoch&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">$geoip2_data_country_code&lt;/span> &lt;span style="color:#e6db74">default=US&lt;/span> &lt;span style="color:#e6db74">source=&lt;/span>$variable_with_ip &lt;span style="color:#e6db74">country&lt;/span> &lt;span style="color:#e6db74">iso_code&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">$geoip2_data_country_name&lt;/span> &lt;span style="color:#e6db74">country&lt;/span> &lt;span style="color:#e6db74">names&lt;/span> &lt;span style="color:#e6db74">en&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e"># 指定数据库路径
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#f92672">geoip2&lt;/span> &lt;span style="color:#e6db74">/etc/maxmind-city.mmdb&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e"># 根据数据库内容生成变量
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#f92672">$geoip2_data_city_name&lt;/span> &lt;span style="color:#e6db74">default=London&lt;/span> &lt;span style="color:#e6db74">city&lt;/span> &lt;span style="color:#e6db74">names&lt;/span> &lt;span style="color:#e6db74">en&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">....&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">fastcgi_param&lt;/span> &lt;span style="color:#e6db74">COUNTRY_CODE&lt;/span> $geoip2_data_country_code;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">fastcgi_param&lt;/span> &lt;span style="color:#e6db74">COUNTRY_NAME&lt;/span> $geoip2_data_country_name;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">fastcgi_param&lt;/span> &lt;span style="color:#e6db74">CITY_NAME&lt;/span> $geoip2_data_city_name;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">....&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#960050;background-color:#1e0010">}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">stream&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">...&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e"># 指定数据库路径
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#e6db74">geoip2&lt;/span> &lt;span style="color:#e6db74">/etc/maxmind-country.mmdb&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e"># 根据数据库内容生成变量
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#f92672">$geoip2_data_country_code&lt;/span> &lt;span style="color:#e6db74">default=US&lt;/span> &lt;span style="color:#e6db74">source=&lt;/span>$remote_addr &lt;span style="color:#e6db74">country&lt;/span> &lt;span style="color:#e6db74">iso_code&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">...&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#960050;background-color:#1e0010">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h1 id="部署并启用模块">部署并启用模块&lt;/h1>
&lt;p>首先按照其&lt;a href="https://github.com/maxmind/libmaxminddb/blob/master/README.md#installing-from-a-tarball">README.md 文件&lt;/a>中的&lt;a href="https://github.com/maxmind/libmaxminddb/blob/master/README.md#installing-from-a-tarball">说明&lt;/a>安装&lt;a href="https://github.com/maxmind/libmaxminddb">libmaxminddb&lt;/a>。
&lt;strong>下载 nginx 源&lt;/strong>&lt;/p>
&lt;pre>&lt;code>wget http://nginx.org/download/nginx-VERSION.tar.gz
tar zxvf nginx-VERSION.tar.gz
cd nginx-VERSION
&lt;/code>&lt;/pre>
&lt;p>&lt;strong>要构建为动态模块（nginx 1.9.11+）：&lt;/strong>&lt;/p>
&lt;pre>&lt;code>./configure --add-dynamic-module=/path/to/ngx_http_geoip2_module
make
make install
&lt;/code>&lt;/pre>
&lt;p>这将产生 &lt;code>objs/ngx_http_geoip2_module.so&lt;/code>。可以将其手动复制到 nginx 的模块存储路径(比如 /etc/nginx/modules 路径下)。
将以下行添加到您的 nginx.conf 中的 main 配置环境中：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-nginx" data-lang="nginx">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">load_module&lt;/span> &lt;span style="color:#e6db74">modules/ngx_http_geoip2_module.so&lt;/span>;
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>然后，就可以在配置文件中使用 geoip2 指令配置 geoip2 模块了&lt;/p>
&lt;h1 id="http-模块下的-geoip2-模块指令">http 模块下的 geoip2 模块指令&lt;/h1>
&lt;h2 id="geoip2-file---根据指定的数据库文件定义变量">geoip2 FILE {} # 根据指定的数据库文件定义变量&lt;/h2>
&lt;p>该指令类似于 geo 模块的 geo 指令，可以自己定义变量名称&lt;/p>
&lt;h3 id="variablename-defaultstring-sourceip-path--定义名为-variablename-的变量">$VariableName [default=STRING] [source=IP] PATH # 定义名为 &lt;code>$VariableName&lt;/code> 的变量&lt;/h3>
&lt;ul>
&lt;li>&lt;strong>PATH&lt;/strong> # MaxMind 数据库中的数据路径，将该路径下的值，赋值给变量 &lt;code>$VariableName&lt;/code>
&lt;ul>
&lt;li>注意：MaxMind 的 GeoIP2 数据库是 JSON 结构，所以 PATH 就是由以空格分割的字段名称组成。可以通过 &lt;a href="https://maxmind.github.io/libmaxminddb/mmdblookup.html">mmdblookup 工具&lt;/a>查找所需数据的路径&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>default=&lt;!-- raw HTML omitted -->&lt;/strong> # 若变量无法获取到值时，应该具有的默认值。&lt;/li>
&lt;li>&lt;strong>source=&lt;!-- raw HTML omitted -->&lt;/strong> # 指定要从数据库获取信息的 IP 地址。默认值来自 &lt;code>$remote_addr&lt;/code> 变量的值&lt;/li>
&lt;/ul>
&lt;h4 id="example">EXAMPLE&lt;/h4>
&lt;ul>
&lt;li>创建 &lt;code>$geoip2_data_country_code&lt;/code> 变量，根据 &lt;code>$remote_addr&lt;/code> 变量中的 IP 地址，查找数据库，将 IP 对应的 &lt;code>.country.iso_code&lt;/code> 字段的值赋值给 &lt;code>$``geoip2_data_country_code&lt;/code> 变量，若 &lt;code>.country.iso_code&lt;/code> 字段为空，则变量的值为 US。
&lt;ul>
&lt;li>&lt;strong>$geoip2_data_country_code default=US source=$remote_addr country iso_code;&lt;/strong>&lt;/li>
&lt;li>其实就是获取两个字母的国家代码&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>创建 &lt;code>$geoip2_city_country_name&lt;/code> 变量，根据 &lt;code>$remote_addr&lt;/code> 变量中的 IP 地址，查找数据库，将 IP 对应的 &lt;code>.country.name.zh-CN&lt;/code> 字段的值赋值给 &lt;code>$geoip2_city_country_name&lt;/code> 变量
&lt;ul>
&lt;li>&lt;strong>$geoip2_city_country_name source=$remote_addr country names zh-CN;&lt;/strong>&lt;/li>
&lt;li>其实就是中文显示的国家名称&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h1 id="配置示例">配置示例&lt;/h1>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-nginx" data-lang="nginx">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">http&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">geoip2&lt;/span> &lt;span style="color:#e6db74">/etc/nginx/geoip/GeoLite2-City.mmdb&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">$geoip2_city_country_code&lt;/span> &lt;span style="color:#e6db74">source=&lt;/span>$remote_addr &lt;span style="color:#e6db74">country&lt;/span> &lt;span style="color:#e6db74">iso_code&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">$geoip2_city_country_name&lt;/span> &lt;span style="color:#e6db74">source=&lt;/span>$remote_addr &lt;span style="color:#e6db74">country&lt;/span> &lt;span style="color:#e6db74">names&lt;/span> &lt;span style="color:#e6db74">zh-CN&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">$geoip2_city&lt;/span> &lt;span style="color:#e6db74">source=&lt;/span>$remote_addr &lt;span style="color:#e6db74">city&lt;/span> &lt;span style="color:#e6db74">names&lt;/span> &lt;span style="color:#e6db74">zh-CN&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">$geoip2_postal_code&lt;/span> &lt;span style="color:#e6db74">source=&lt;/span>$remote_addr &lt;span style="color:#e6db74">postal&lt;/span> &lt;span style="color:#e6db74">code&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">$geoip2_dma_code&lt;/span> &lt;span style="color:#e6db74">source=&lt;/span>$remote_addr &lt;span style="color:#e6db74">location&lt;/span> &lt;span style="color:#e6db74">metro_code&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">$geoip2_latitude&lt;/span> &lt;span style="color:#e6db74">source=&lt;/span>$remote_addr &lt;span style="color:#e6db74">location&lt;/span> &lt;span style="color:#e6db74">latitude&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">$geoip2_longitude&lt;/span> &lt;span style="color:#e6db74">source=&lt;/span>$remote_addr &lt;span style="color:#e6db74">location&lt;/span> &lt;span style="color:#e6db74">longitude&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">$geoip2_time_zone&lt;/span> &lt;span style="color:#e6db74">source=&lt;/span>$remote_addr &lt;span style="color:#e6db74">location&lt;/span> &lt;span style="color:#e6db74">time_zone&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">$geoip2_region_code&lt;/span> &lt;span style="color:#e6db74">source=&lt;/span>$remote_addr &lt;span style="color:#e6db74">subdivisions&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span> &lt;span style="color:#e6db74">iso_code&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">$geoip2_region_name&lt;/span> &lt;span style="color:#e6db74">source=&lt;/span>$remote_addr &lt;span style="color:#e6db74">subdivisions&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span> &lt;span style="color:#e6db74">names&lt;/span> &lt;span style="color:#e6db74">zh-CN&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>上述示例中，定义了如下几个变量，并获取了数据库中指定字段的值：&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>&lt;strong>变量&lt;/strong>&lt;/th>
&lt;th>&lt;strong>数据库中的字段&lt;/strong>&lt;/th>
&lt;th>&lt;strong>含义&lt;/strong>&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>&lt;strong>$geoip2_city_country_code&lt;/strong>&lt;/td>
&lt;td>.country.iso_code&lt;/td>
&lt;td>国家代码&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;strong>$geoip2_city_country_name&lt;/strong>&lt;/td>
&lt;td>.country.names.zh-CN&lt;/td>
&lt;td>国家名称&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;strong>$geoip2_city&lt;/strong>&lt;/td>
&lt;td>.city.name.zh-CN&lt;/td>
&lt;td>城市名称&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;strong>$geoip2_postal_code&lt;/strong>&lt;/td>
&lt;td>.postal.code&lt;/td>
&lt;td>邮编&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;strong>$geoip2_dma_code&lt;/strong>&lt;/td>
&lt;td>.location.metro_code&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;strong>$geoip2_latitude&lt;/strong>&lt;/td>
&lt;td>.location.latitude&lt;/td>
&lt;td>纬度&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;strong>$geoip2_longitude&lt;/strong>&lt;/td>
&lt;td>.location.longitude&lt;/td>
&lt;td>经度&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;strong>$geoip2_time_zone&lt;/strong>&lt;/td>
&lt;td>.location..time_zone&lt;/td>
&lt;td>时区&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;strong>$geoip2_region_code&lt;/strong>&lt;/td>
&lt;td>.subdivisions[0].iso_code&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;strong>$geoip2_region_name&lt;/strong>&lt;/td>
&lt;td>.subdivisions[0].names.zh-CN&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table></description></item><item><title>Docs: HAProxy</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/3.%E9%9B%86%E7%BE%A4%E4%B8%8E%E5%88%86%E5%B8%83%E5%BC%8F/haproxy/haproxy/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/3.%E9%9B%86%E7%BE%A4%E4%B8%8E%E5%88%86%E5%B8%83%E5%BC%8F/haproxy/haproxy/</guid><description>
&lt;h1 id="haproxy">HAProxy&lt;/h1>
&lt;p>可以实现四层以及七层负载均衡&lt;/p>
&lt;p>多用于七层负载均衡&lt;/p>
&lt;p>http 层代理&lt;/p>
&lt;p>tcp 层的负载均衡&lt;/p>
&lt;p>目前，有两种主流的代理模式：tcp 代理(即所谓的 4 层代理)和 http 代理(即所谓的 7 层代理)。在 4 层代理模式下，haproxy 简单的在两端进行双向转发。在 7 层代理模式下，haproxy 会对协议进行分析，可以根据协议来允许、阻塞、切换、增加、修改和移除 request 或 response 中的属性内容。&lt;/p>
&lt;h2 id="haproxy-工作逻辑">haproxy 工作逻辑&lt;/h2>
&lt;p>比如 client 为 114.114.114.114，haproyx 为 192.168.1.2，Server 为 192.168.1.3&lt;/p>
&lt;ol>
&lt;li>
&lt;p>client 发送数据包给 haproxy 所在服务器 192.168.1.2&lt;/p>
&lt;/li>
&lt;li>
&lt;p>192.168.1.2 发现这个数据包是给自己的 haproxy 的，则剥离 IP 与 PORT，并把数据包发送给用户空间的 haproxy&lt;/p>
&lt;/li>
&lt;li>
&lt;p>haproxy 由于在用户空间，所以收到的数据包已经被内核剥离了 IP 与 PORT，此时 haproxy 会根据自身的配置以及数据包内的相关信息来进行匹配选择一个合适的 Server，然后发送给内核，告诉内核这个数据包要发送给某 Server。这是 haproxy 与 Server 建立的一个新 TCP 连接。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>内核根据 Server 这个目的 IP，再封装上 mac 地址从网卡中发送出去。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>这时候 Server 就会收到请求，处理完成后把响应报文发送给 haproxy&lt;/p>
&lt;/li>
&lt;li>
&lt;p>由于 haproxy 与 Client 和 Server 分别建立的两个 TCP 连接，这会生成两个 Socket，所以发送给 client 的响应数据以及之后的数据交互就直接通过两个相连的 socket 来进行。&lt;/p>
&lt;ol>
&lt;li>
&lt;p>socket 介绍详解 TCPIP，UDP，端口 Port，Socket，API.note 的 socket 章节&lt;/p>
&lt;/li>
&lt;li>
&lt;p>haproxy 所在的设备就相当于创建了两个 socket，这两个 socket 又可以直接相连，这时候数据就不用再次经过用户空间而可以直接交互。client 作为客户端随机使用一个端口与 haproxy 监听的端口交互，之后 haproxy 作为客户端随机使用一个端口与 server 监听的端口交互。效果如图&lt;/p>
&lt;/li>
&lt;/ol>
&lt;/li>
&lt;/ol>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/zdm35o/1616132304027-ba04f126-b601-4db8-b244-3b361691fcbd.jpeg" alt="">&lt;/p>
&lt;h2 id="haproxy-建立链接的方式">haproxy 建立链接的方式：&lt;/h2>
&lt;ol>
&lt;li>
&lt;p>比如此时有 5W 个用户请求，haproxy 会与后端服务器建立指定个数的连接，比如 500，这 500 个连接可以让每个连接处理 100 个请求。(并不是一个 Client 与 haproxy 连接，haproxy 就也要与 Server 建立链接，haproxy 两端的连接没有绝对关系。当然，也可以单独进行配置以便让一个 Client 单独享有一个与 Servier 链接的关系)&lt;/p>
&lt;/li>
&lt;li>
&lt;p>每一个客户端需要与 haproxy 要建立链接，但是只占用 haproxy 所监听的端口，haproxy 与后端服务器建立多少连接，就占用 haproxy 所在服务器多少端口。如果每次后端服务器响应完成之后就关闭连接(比如 http-server-close 配置)，那么如果客户端请求数据大，建立的链接数量也就变大大，很有可能会在端口关闭还没释放前，就提前把端口占满了。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>所以，haproxy 最佳的性能不一定是一个客户端请求就让 haproxy 建立一个与后端的连接，当设备性能足够的时候，可以在尽量少建立链接的情况下，让单个链接处理多个请求。这个最佳的连接数，可以通过压测工具来测出来峰值，比如 haproxy 与后端连接数为 1、2、3&amp;hellip;.N 的时候，服务性能在哪个数值可以达到峰值，就可以配置 haproxy 与后端的连接数为多少。&lt;/p>
&lt;/li>
&lt;/ol>
&lt;h3 id="注意-lvs-的四层代理与-haproxy-的-7-层代理的区别">注意 lvs 的四层代理与 haproxy 的 7 层代理的区别&lt;/h3>
&lt;ol>
&lt;li>
&lt;p>虽然从逻辑上看似都是修改了请求报文中的某些信息(比如目的 MAC、目的 IP、源 IP 等等)，但是这种逻辑上的修改其实有区别的&lt;/p>
&lt;ol>
&lt;li>
&lt;p>lvs 在内核空间操作数据包。内核空间的数据包外层还有 mac、ip 地址、port 等，可以由内核模块直接进行修改，然后让数据包不进入用户空间就直接通过网络栈发给网卡。实际上算是一种转发并且是真正的修改&lt;/p>
&lt;/li>
&lt;li>
&lt;p>haproxy 在用户空间操作数据。而一般情况数据本身并没有 ip、mac 等信息，所以，haproxy 就根据数据内容，找到匹配的 RS，把改数据包当做一个新包发送出去。发送的时候其实就是由 haproxy 发起的新请求。只不过在发送请求的时候，haproxy 还会记录这个请求。这样在 RS 响应该报文时，haproxy 就可以把响应数据再发送给 client。如果从 client 来看，确实是修改了目的 IP(虽然 client 并不知道，但是作为操作者纵观全局来说是修改了)，但是实际是 haproxy 把数据当做自己主动发送的数据再发送给别人了。这不是修改了原始数据包的信息而是代替 client 发送数据与 RS 建立一个新的 TCP 连接，是属于代理的类型，而 lvs 更像是转发。&lt;/p>
&lt;/li>
&lt;/ol>
&lt;/li>
&lt;li>
&lt;p>总结起来就是 lvs 是在内核处理数据包、而 haproxy 在用户空间处理数据。所以 haproxy 还有有性能的损耗，因为数据会经由内核空间进到用户空间再进到内核空间发送出去&lt;/p>
&lt;/li>
&lt;/ol>
&lt;p>HAProxy 配置&lt;/p>
&lt;p>/etc/haproxy/haproxy.cfg #haproxy 程序运行所需基本配置&lt;/p>
&lt;p>haproxy.cfg 文件中各个参数解释&lt;/p>
&lt;p>官方参数详解见：&lt;a href="http://cbonte.github.io/haproxy-dconv/1.9/configuration.html#4.1">http://cbonte.github.io/haproxy-dconv/1.9/configuration.html#4.1&lt;/a>&lt;/p>
&lt;h2 id="全局配置段">全局配置段&lt;/h2>
&lt;h3 id="global--全局配置">global # 全局配置&lt;/h3>
&lt;h2 id="代理配置段">代理配置段&lt;/h2>
&lt;ol>
&lt;li>
&lt;p>frontend 和 backend 主要用来实现 7 层代理。两个配置段相互配置。用来匹配代理规则的，用户访问哪一类页面，就把这类请求转发到某后端服务器上。可以与 nginx 的配置互相参考，acl 就是 naginx 的 location 里的匹配规则；backend 里的 server 就是 nginx 里 upstream 的 server；use_backend 就是 nginx 里的 proxy_pass。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>listen 主要用来实现 4 层代理。用户访问 haproxy 设备的哪个端口，就会把请求代理到指定的服务器的 IP:PORT 上&lt;/p>
&lt;/li>
&lt;/ol>
&lt;p>frontend、backend、listen 三个配置段都可以有多个，e.g.根据 acl1 的规则匹配到 backend1，符合 acl2 的规则匹配到 backend2，以此类推&lt;/p>
&lt;h3 id="defaults-defaultsname-为-frontendbackendlisten-三段提供默认配置">defaults [DefaultsName] #为 frontend、backend、listen 三段提供默认配置&lt;/h3>
&lt;p>defaults 中的配置，也可以单独配置在 frontend、backend、listen 配置段中，该段中的配置主要是为了防止后面面的三段中有重复的配置，比如 option http-keep-alive 该选项是保持连接，需要在所有前端配置中配置，这时候，可以在 defaults 配置段段配置一次，即可在所有的 frontend、backend、listen 中生效。&lt;/p>
&lt;h3 id="frontend-frontendname-port-前端配置段">frontend FrontendName *:PORT #前端配置段&lt;/h3>
&lt;p>用于让 haproxy 监听在某个 IP:PORT 上，用来接收客户端请求，然后根据匹配规则把改请求转发给指定 backend&lt;/p>
&lt;h3 id="backend-backendname-后端配置段">backend BackendName #后端配置段&lt;/h3>
&lt;p>负责接收前段配置段转发的请求，后端里可以包含多台服务器来均衡处理前端转发过来的请求。BackendName 与 frontend 中的 default_backend 或 use_backend 所关联。&lt;/p>
&lt;h3 id="listen-listenname-指定一个四层代理名称该配置段无法配置详细的-7-层转发规则">listen ListenName #指定一个四层代理名称，该配置段无法配置详细的 7 层转发规则&lt;/h3>
&lt;h2 id="配置段的关键字keywords">配置段的关键字(keywords)：&lt;/h2>
&lt;h3 id="global-全局配置段-keywords">global 全局配置段 keywords&lt;/h3>
&lt;ol>
&lt;li>
&lt;p>maxconn NUM #设置最大连 z 接数&lt;/p>
&lt;/li>
&lt;li>
&lt;p>log [Len ] [Format ] [ []] #让 haproxy 程序记录日志，并指定记录方式&lt;/p>
&lt;ol>
&lt;li>
&lt;p>ADDRESS #指定要把日志发送到哪台设备上的哪个 PORT，默认 PORT 为 514&lt;/p>
&lt;/li>
&lt;li>
&lt;p>FACILITY #指定要使用的日志设施，一般为 local0-7 其中一个&lt;/p>
&lt;/li>
&lt;li>
&lt;p>LEVEL #指定哪个级别的日志会被记录&lt;/p>
&lt;/li>
&lt;/ol>
&lt;/li>
&lt;li>
&lt;p>user USER #haproxy 以指定的 USER 用户运行&lt;/p>
&lt;/li>
&lt;li>
&lt;p>group GROUP #haproxy 以指定的 GROUP 组运行&lt;/p>
&lt;/li>
&lt;li>
&lt;p>daemon #haproxy 以守护进程运行，不加该参数，则 haproxy 则会运行在前台&lt;/p>
&lt;/li>
&lt;/ol>
&lt;h3 id="defaultsfrontendbackendlisten-代理配置段-keywords">defaults、frontend、backend、listen 代理配置段 keywords&lt;/h3>
&lt;p>defaults、frontend、backend、listen 可用的关键字及其对应的值的简要说明，其余的配置详见官网参数说明&lt;/p>
&lt;p>目前，有两种主流的代理模式：tcp 代理(即所谓的 4 层代理)和 http 代理(即所谓的 7 层代理)。在 4 层代理模式下，haproxy 简单的在两端进行双向转发。在 7 层代理模式下，haproxy 会对协议进行分析，可以根据协议来允许、阻塞、切换、增加、修改和移除 request 或 response 中的属性内容。&lt;/p>
&lt;ol>
&lt;li>
&lt;p>log global #让代理的日志使用 global 中的日志配置&lt;/p>
&lt;/li>
&lt;li>
&lt;p>mode {tcp|http} #设置实例的运行模式或者协议,默认为 tcp&lt;/p>
&lt;ol>
&lt;li>
&lt;p>用于 defaults、frontend、listen、backend&lt;/p>
&lt;/li>
&lt;li>
&lt;p>tcp 模式：该实例将在纯 TCP 模式下工作。 将在客户端和服务器之间建立全双工连接，并且不会执行第 7 层检查。 这是默认模式。 它应该用于 SSL，SSH，SMTP，&amp;hellip;&amp;hellip;&lt;/p>
&lt;/li>
&lt;li>
&lt;p>http 模式：该实例将在 HTTP 模式下工作。 在连接到任何服务器之前，将对客户端请求进行深入分析。 任何不符合 RFC 的请求都将被拒绝。 可以进行第 7 层过滤，处理和切换。这种模式为 HAProxy 带来了最大的价值。&lt;/p>
&lt;/li>
&lt;/ol>
&lt;/li>
&lt;li>
&lt;p>acl CRITERION [FLAG] [OPERATOR] VALUE #定义一个名为 AclName 的规则，匹配规则为 MatchRule。匹配规则主要是针对访问的内容，i.e.用户访问哪一类 URL。e.g.用户访问某个路径下的资源，acl 匹配到后，把请求代理到 use_backend 字段中定义的 backend 上去.acl 官方使用文档：&lt;a href="http://cbonte.github.io/haproxy-dconv/1.9/configuration.html#7.1">http://cbonte.github.io/haproxy-dconv/1.9/configuration.html#7.1&lt;/a>&lt;/p>
&lt;ol>
&lt;li>
&lt;p>用于 frontend、backend、listen。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>EXAMPLE&lt;/p>
&lt;ol>
&lt;li>acl invalid_src src 0.0.0.0/7 #CERITERION(规范)为 src，VALUE(值)为 0.0.0.0/7。规则名为 invalid_src&lt;/li>
&lt;/ol>
&lt;/li>
&lt;/ol>
&lt;/li>
&lt;li>
&lt;p>bind IP:PORT #指定该前端会监听在哪个 IP:PORT 上&lt;/p>
&lt;ol>
&lt;li>用于 frontend、listen &lt;/li>
&lt;/ol>
&lt;/li>
&lt;li>
&lt;p>use_backend BackendName if ACLName #当满足 ACLName 策略的请求代理到 BackendName 这个后端上&lt;/p>
&lt;ol>
&lt;li>用于 frontend、listen。&lt;/li>
&lt;/ol>
&lt;/li>
&lt;li>
&lt;p>default_backend BackendName #定义默认把请求转发到 backend 所定义的一组以 NAME 命名的后端服务器上&lt;/p>
&lt;ol>
&lt;li>用于 defaults、frontend、listen。&lt;/li>
&lt;/ol>
&lt;/li>
&lt;li>
&lt;p>balance SCHEDULER #指明该组后端服务器接收请求的 SCHEDULER(scheduler 调度算法,也可以翻译为调度器)，调度算法可以使用以下的几种机型定义，有的 scheduler 还有子配置，定义在该 scheduler 之下&lt;/p>
&lt;ol>
&lt;li>
&lt;p>用于 defaults、listen、backend。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>动态：权重可动态调整&lt;/p>
&lt;/li>
&lt;li>
&lt;p>静态：调整权重不会实时生效&lt;/p>
&lt;ol>
&lt;li>
&lt;p>roundrobin：动态轮询，基于权重，动态调整权重，每个后端设备最多支持 4128 个连接&lt;/p>
&lt;/li>
&lt;li>
&lt;p>static-rr：静态轮询，基于权重，该组中的每个设备轮流接收请求，无接收上线&lt;/p>
&lt;/li>
&lt;li>
&lt;p>leastconn：根据后端设备的负载数量进行调度，仅适用于长连接的会话&lt;/p>
&lt;/li>
&lt;li>
&lt;p>source：对源 IP 地址进行哈希，用可用服务器的权重总数除以哈希值，根据结果进行分配。只要服务器正常，同一个客户端 IP 地址总是访问同一台服务器。如果哈希的结果随可用服务器数量而变化，那么有的客户端会定向到不同的服务器。该算法一般用于不能插入 cookie 的 TCP 模式。它还可以用于广域网上，为拒绝使用会话 cookie 的客户端提供最有效的粘连。该算法默认是静态的，所以运行时修改服务器的权重是无效的，但是算法会根据&amp;quot;hash-type&amp;quot;的变化做调整。将请求的源地址进行 hash 运算，然后进行调度，使用该 scheduler 后可以使用 hash-type 参数来定义 hash 类型&lt;/p>
&lt;/li>
&lt;li>
&lt;p>uri：将请求的 uri 左边的部分(左边的部分就是 uri 的语法的？之前的内容，相当于资源的位置)进行 hash 运算后进行调度，常用于缓存服务器(可以根据每个资源的 hash 值，来让用户直接访问到该资源上，第一个用户请求到该资源在某台的时候，后续的用户再请求该资源还是会到该设备上，比如 CDN 中，)；使用该 scheduler 后可以使用 hash-type 参数来定义 hash 类型&lt;/p>
&lt;/li>
&lt;li>
&lt;p>url_param：根据 url 中指定的 param 参数的值做 hash 运算后进行调度，可以根据参数中的内容进行会话保持；比如根据 param 中定义的用户名，来规定有哪一部分调度到哪台设备上；使用该 scheduler 后可以使用 hash-type 参数来定义 hash 类型&lt;/p>
&lt;/li>
&lt;li>
&lt;p>hdr(NAME):根据每个请求报文的 header 首部报文的(字段)进行调度&lt;/p>
&lt;/li>
&lt;li>
&lt;p>hash-type #动态调整权重，一致性哈希算法 | 静态，基础映射哈希&lt;/p>
&lt;/li>
&lt;/ol>
&lt;/li>
&lt;/ol>
&lt;/li>
&lt;li>
&lt;p>option httpchk HEAD /PATH/TO/FILE #用于配置健康检查所使用的文件，HEAD 是关键字&lt;/p>
&lt;ol>
&lt;li>用于 defaults、listen、backend。&lt;/li>
&lt;/ol>
&lt;/li>
&lt;li>
&lt;p>option http-keep-alive #启用客户端和服务端与 haproxy 之间的长连接。haproxy 将处理所有请求和响应报文，请求完后 haproxy 两端的连接都处于空闲状态。&lt;/p>
&lt;ol>
&lt;li>用于 defaults、frontend、backend、listen&lt;/li>
&lt;/ol>
&lt;/li>
&lt;li>
&lt;p>option http-server-close #启用在 haproxy 处理完第一次响应之后关闭 haproxy 到服务端之间长连接的功能，但客户端的长连接还保持，后续的每次请求都重新建立和后端的连接，每次响应后都关闭和后端的连接。启用该选项时，haproxy 将会在发送给后端 server 的 request 数据包中添加一个&amp;quot;Connection:Close&amp;quot;标记，后端 Server 看到此标记就会在响应后关闭 tcp 连接。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>用于 defaults、frontend、backend、listen&lt;/p>
&lt;/li>
&lt;li>
&lt;p>一般来说，后端是静态内容缓存服务器时，或者就是静态服务器时，首选使用 http-keep-alive 模式，后端是动态应用程序服务器时，首选使用 http-server-close 模式。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>option httpchk [METHOD] URI [VERSION] #开启 http 协议以检查 server 字段定义的各个服务器的健康状态&lt;/p>
&lt;/li>
&lt;li>
&lt;p>server ServerName IP:PORT check inter 5s rise 2 fall 2 weight 2 #指定被代理的服务器的 IP 与地址还有其余信息&lt;/p>
&lt;/li>
&lt;li>
&lt;p>用于 backend 和 listen。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>在 backend 里声明 server，这些 server 用来处理前端代理过来的请求。可以定义多个 server 来负载均衡这些请求，每个 server 都可以自定义一个 NAME，这些名字用来在 haproxy 的日志中查看是哪个服务器出问题或者接收请求等&lt;/p>
&lt;/li>
&lt;/ol>
&lt;p>实际应用举例&lt;/p>
&lt;pre>&lt;code> ####################全局配置信息########################
#######参数是进程级的，通常和操作系统（OS）相关#########
global
maxconn 20480 #默认最大连接数
log 127.0.0.1 local3 #[err warning info debug]
chroot /var/haproxy #chroot运行的路径
uid 99 #所属运行的用户uid，也可以user后边接用户名
gid 99 #所属运行的用户组 ，也可以改成group后边接组名
daemon #以后台形式运行haproxy
nbproc 1 #进程数量(可以设置多个进程提高性能)
pidfile /var/run/haproxy.pid #haproxy的pid存放路径,启动进程的用户必须有权限访问此文件
ulimit-n 65535 #ulimit的数量限制
#####################默认的全局设置######################
##这些参数可以被利用配置到frontend，backend，listen组件##
defaults
log global
mode http #所处理的类别 (#7层 http;4层tcp )
maxconn 20480 #最大连接数
option httplog #日志类别http日志格式
option httpclose #每次请求完毕后主动关闭http通道
option dontlognull #不记录健康检查的日志信息
option forwardfor #如果后端服务器需要获得客户端真实ip需要配置的参数，可以从Http Header中获得客户端ip
option redispatch #serverId对应的服务器挂掉后,强制定向到其他健康的服务器
option abortonclose #当服务器负载很高的时候，自动结束掉当前队列处理比较久的连接
stats refresh 30 #统计页面刷新间隔
retries 3 #3次连接失败就认为服务不可用，也可以通过后面设置
balance roundrobin #默认的负载均衡的方式,轮询方式
#balance source #默认的负载均衡的方式,类似nginx的ip_hash
#balance leastconn #默认的负载均衡的方式,最小连接
contimeout 5000 #连接超时
clitimeout 50000 #客户端超时
srvtimeout 50000 #服务器超时
timeout check 2000 #心跳检测超时
####################监控页面的设置#######################
listen admin_status #Frontend和Backend的组合体,监控组的名称，按需自定义名称
bind 0.0.0.0:65532 #监听端口
mode http #http的7层模式
log 127.0.0.1 local3 err #错误日志记录
stats refresh 5s #每隔5秒自动刷新监控页面
stats uri /admin?stats #监控页面的url
stats realm itnihao\ itnihao #监控页面的提示信息
stats auth admin:admin #监控页面的用户和密码admin,可以设置多个用户名
stats auth admin1:admin1 #监控页面的用户和密码admin1
stats hide-version #隐藏统计页面上的HAproxy版本信息
stats admin if TRUE #手工启用/禁用,后端服务器(haproxy-1.4.9以后版本)
errorfile 403 /etc/haproxy/errorfiles/403.http
errorfile 500 /etc/haproxy/errorfiles/500.http
errorfile 502 /etc/haproxy/errorfiles/502.http
errorfile 503 /etc/haproxy/errorfiles/503.http
errorfile 504 /etc/haproxy/errorfiles/504.http
#################HAProxy的日志记录内容设置###################
capture request header Host len 40
capture request header Content-Length len 10
capture request header Referer len 200
capture response header Server len 40
capture response header Content-Length len 10
capture response header Cache-Control len 8
#######################网站监测listen配置#####################
###########此用法主要是监控haproxy后端服务器的监控状态############
listen site_status
bind 0.0.0.0:1081 #监听端口
mode http #http的7层模式
log 127.0.0.1 local3 err #[err warning info debug]
monitor-uri /site_status #网站健康检测URL，用来检测HAProxy管理的网站是否可以用，正常返回200，不正常返回503
acl site_dead nbsrv(server_web) lt 2 #定义网站down时的策略当挂在负载均衡上的指定backend的中有效机器数小于1台时返回true
acl site_dead nbsrv(server_blog) lt 2
acl site_dead nbsrv(server_bbs) lt 2
monitor fail if site_dead #当满足策略的时候返回503，网上文档说的是500，实际测试为503
monitor-net 192.168.16.2/32 #来自192.168.16.2的日志信息不会被记录和转发
monitor-net 192.168.16.3/32
########frontend配置############
#####注意，frontend配置里面可以定义多个acl进行匹配操作########
frontend http_80_in
bind 0.0.0.0:80 #监听端口，即haproxy提供web服务的端口，和lvs的vip端口类似
mode http #http的7层模式
log global #应用全局的日志配置
option httplog #启用http的log
option httpclose #每次请求完毕后主动关闭http通道，HA-Proxy不支持keep-alive模式
option forwardfor #如果后端服务器需要获得客户端的真实IP需要配置次参数，将可以从Http Header中获得客户端IP
########acl策略配置#############
acl itnihao_web hdr_reg(host) -i ^(www.itnihao.cn|ww1.itnihao.cn)$
#如果请求的域名满足正则表达式中的2个域名返回true -i是忽略大小写
acl itnihao_blog hdr_dom(host) -i blog.itnihao.cn
#如果请求的域名满足www.itnihao.cn返回true -i是忽略大小写
acl itnihao hdr(host) -i itnihao.cn
#如果请求的域名满足itnihao.cn返回true -i是忽略大小写
acl file_req url_sub -i killall=
#在请求url中包含killall=，则此控制策略返回true,否则为false
acl dir_req url_dir -i allow
#在请求url中存在allow作为部分地址路径，则此控制策略返回true,否则返回false
acl missing_cl hdr_cnt(Content-length) eq 0
#当请求的header中Content-length等于0时返回true
########acl策略匹配相应#############
block if missing_cl
#当请求中header中Content-length等于0阻止请求返回403
block if !file_req || dir_req
#block表示阻止请求，返回403错误，当前表示如果不满足策略file_req，或者满足策略dir_req，则阻止请求
use_backend server_web if itnihao_web
#当满足itnihao_web的策略时使用server_web的backend
use_backend server_blog if itnihao_blog
#当满足itnihao_blog的策略时使用server_blog的backend
redirect prefix http://blog.itniaho.cn code 301 if itnihao
#当访问itnihao.cn的时候，用http的301挑转到http://192.168.16.3
default_backend server_bbs
#以上都不满足的时候使用默认server_bbs的backend
##########backend的设置##############
#下面我将设置三组服务器 server_web，server_blog，server_bbs
###########################backend server_web#############################
backend server_web
mode http #http的7层模式
balance roundrobin #负载均衡的方式，roundrobin平均方式
cookie SERVERID #允许插入serverid到cookie中，serverid后面可以定义
option httpchk GET /index.html #心跳检测的文件
server web1 192.168.16.2:80 cookie web1 check inter 1500 rise 3 fall 3 weight 1
#服务器定义，cookie 1表示serverid为web1，check inter 1500是检测心跳频率rise 3是3次正确认为服务器可用，
#fall 3是3次失败认为服务器不可用，weight代表权重
server web2 192.168.16.3:80 cookie web2 check inter 1500 rise 3 fall 3 weight 2
#服务器定义，cookie 1表示serverid为web2，check inter 1500是检测心跳频率rise 3是3次正确认为服务器可用，
#fall 3是3次失败认为服务器不可用，weight代表权重
###################################backend server_blog###############################################
backend server_blog
mode http #http的7层模式
balance roundrobin #负载均衡的方式，roundrobin平均方式
cookie SERVERID #允许插入serverid到cookie中，serverid后面可以定义
option httpchk GET /index.html #心跳检测的文件
server blog1 192.168.16.2:80 cookie blog1 check inter 1500 rise 3 fall 3 weight 1
#服务器定义，cookie 1表示serverid为web1，check inter 1500是检测心跳频率rise 3是3次正确认为服务器可用，fall 3是3次失败认为服务器不可用，weight代表权重
server blog2 192.168.16.3:80 cookie blog2 check inter 1500 rise 3 fall 3 weight 2
#服务器定义，cookie 1表示serverid为web2，check inter 1500是检测心跳频率rise 3是3次正确认为服务器可用，fall 3是3次失败认为服务器不可用，weight代表权重
###################################backend server_bbs###############################################
backend server_bbs
mode http #http的7层模式
balance roundrobin #负载均衡的方式，roundrobin平均方式
cookie SERVERID #允许插入serverid到cookie中，serverid后面可以定义
option httpchk GET /index.html #心跳检测的文件
server bbs1 192.168.16.2:80 cookie bbs1 check inter 1500 rise 3 fall 3 weight 1
#服务器定义，cookie 1表示serverid为web1，check inter 1500是检测心跳频率rise 3是3次正确认为服务器可用，fall 3是3次失败认为服务器不可用，weight代表权重
server bbs2 192.168.16.3:80 cookie bbs2 check inter 1500 rise 3 fall 3 weight 2
#服务器定义，cookie 1表示serverid为web2，check inter 1500是检测心跳频率rise 3是3次正确认为服务器可用，fall 3是3次失败认为服务器不可用，weight代表权重
&lt;/code>&lt;/pre>
&lt;h1 id="haproxy-日志配置">haproxy 日志配置&lt;/h1>
&lt;p>开启 haproxy 日志，修改 haproxy 配置文件中，log 关键字&lt;/p>
&lt;p>配置 rsyslgo 中 haproxy 的日志保存路径，其中需要让 rsyslog 开启 udp 的 514 端口&lt;/p>
&lt;p>cat &amp;gt; /etc/rsyslog.d/haproxy.conf &amp;laquo; \EOF&lt;/p>
&lt;p>$ModLoad imudp&lt;/p>
&lt;p>$UDPServerRun 514&lt;/p>
&lt;p>local2.* /var/log/haproxy/haproxy.log&lt;/p>
&lt;p>&amp;amp; stop&lt;/p>
&lt;p>EOF&lt;/p>
&lt;p>配置 haproxy 的日志轮替&lt;/p>
&lt;p>cat &amp;gt; /etc/logrotate.d/haproxy &amp;laquo; \EOF&lt;/p>
&lt;p>/var/log/haproxy/haproxy.log {&lt;/p>
&lt;pre>&lt;code>daily
copytruncate
rotate 10
missingok
dateext
notifempty
compress
sharedscripts
postrotate
/bin/kill -HUP `cat /var/run/syslogd.pid 2&amp;gt; /dev/null` 2&amp;gt; /dev/null || true
/bin/kill -HUP `cat /var/run/rsyslogd.pid 2&amp;gt; /dev/null` 2&amp;gt; /dev/null || true
endscript
&lt;/code>&lt;/pre>
&lt;p>}&lt;/p>
&lt;p>EOF&lt;/p></description></item><item><title>Docs: http 模块指令</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/3.%E9%9B%86%E7%BE%A4%E4%B8%8E%E5%88%86%E5%B8%83%E5%BC%8F/nginx/nginx-%E9%85%8D%E7%BD%AE%E8%AF%A6%E8%A7%A3/http-%E6%A8%A1%E5%9D%97%E6%8C%87%E4%BB%A4/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/3.%E9%9B%86%E7%BE%A4%E4%B8%8E%E5%88%86%E5%B8%83%E5%BC%8F/nginx/nginx-%E9%85%8D%E7%BD%AE%E8%AF%A6%E8%A7%A3/http-%E6%A8%A1%E5%9D%97%E6%8C%87%E4%BB%A4/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="http://nginx.org/en/docs/http/ngx_http_core_module.html">org 官方文档,http core 模块&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://docs.nginx.com/nginx/admin-guide/load-balancer/http-load-balancer/">官方文档,管理指南-负载均衡-HTTP 负载均衡&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>http 模块及其子模块通过 &lt;code>http {}&lt;/code> 配置环境中的指令控制行为&lt;/p>
&lt;p>&lt;code>http{}&lt;/code> 配置环境下的每个 &lt;code>server{}&lt;/code> 指令块控制访问特定域名或者 ip 地址上对资源请求的处理。&lt;code>**server{}**&lt;/code>** 指令块中的一个或多个 &lt;strong>&lt;code>**location{}**&lt;/code>&lt;/strong> 指令块定义了根据 URL 来处理流量的规则**&lt;/p>
&lt;ol>
&lt;li>比如用户访问 map.baidu.com 和 baike.baidu.com。看上去是访问了两台服务器，但是实际上，这是经过作为代理设备的 ngxin 来进行选择后的虚拟服务器。一般情况下，baike.baidu.com 与 map.baidu.com 这俩域名所解析出来的 ip 应该是同一个公网 ip(比如 123.123.123.123)(baidu 有钱用很多公网 IP 除外)。所以可以想到，用户在浏览器输入任何一个域名，访问请求都会来到 123.123.123.123，然后根据请求报文中的 Request-URL 字段中的域名与 server_name 进行配对，用户输入的 URL 中域名与哪个 server_name 相同，则该请求就会通过这个 server 来进行处理，然后根据该 server 中 location 的关键字来决定把改请求转发给哪里。&lt;/li>
&lt;/ol>
&lt;p>对于 &lt;code>http{}&lt;/code> 配置环境来说，server{}、server_name、location{}、proxy_pass 是实现 7 层代理的关键指令。server_name 指定接受流量的域名，&lt;code>location{}&lt;/code> 匹配路径，然后通过 proxy_pass 将流量代理到指定的后端。&lt;/p>
&lt;h2 id="简单的-http-配置环境示例">简单的 http{} 配置环境示例&lt;/h2>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-nginx" data-lang="nginx">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">http&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">access_log&lt;/span> &lt;span style="color:#e6db74">/dev/stdout&lt;/span> &lt;span style="color:#e6db74">main&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">upstream&lt;/span> &lt;span style="color:#e6db74">backend&lt;/span> { &lt;span style="color:#75715e"># 后端配置
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#f92672">server&lt;/span> &lt;span style="color:#e6db74">backend1.example.com&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">server&lt;/span> &lt;span style="color:#e6db74">backend2.example.com&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">server&lt;/span> &lt;span style="color:#ae81ff">192&lt;/span>&lt;span style="color:#e6db74">.0.0.1&lt;/span> &lt;span style="color:#e6db74">backup&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">server&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">server_name&lt;/span> &lt;span style="color:#e6db74">localhost&lt;/span>; &lt;span style="color:#75715e"># 流量入口
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#f92672">location&lt;/span> &lt;span style="color:#e6db74">/&lt;/span> { &lt;span style="color:#75715e"># 流量处理
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#f92672">proxy_pass&lt;/span> &lt;span style="color:#e6db74">http://backend&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">include&lt;/span> &lt;span style="color:#e6db74">/etc/nginx/conf.d/*.conf&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#960050;background-color:#1e0010">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h1 id="virtual-server-基本配置">Virtual Server 基本配置&lt;/h1>
&lt;h2 id="流量入口指令">流量入口指令&lt;/h2>
&lt;p>流量入口的指令通常都定义在 &lt;code>**server{} 块指令**&lt;/code> 中。&lt;/p>
&lt;h3 id="server-httpsnginxorgendocshttpngx_http_core_modulehtmlserver">&lt;a href="https://nginx.org/en/docs/http/ngx_http_core_module.html#server">server {}&lt;/a>&lt;/h3>
&lt;ul>
&lt;li>作用范围：http{}&lt;/li>
&lt;/ul>
&lt;p>server{} 指令块用来定义 Virtual Server&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-nginx" data-lang="nginx">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">server&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">listen&lt;/span> &lt;span style="color:#e6db74">[::]:80&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">server_name&lt;/span> &lt;span style="color:#e6db74">&amp;#34;baike.baidu.com&amp;#34;&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">location&lt;/span> &lt;span style="color:#e6db74">/&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">proxy_pass&lt;/span> &lt;span style="color:#e6db74">http://192.168.0.100:8080&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#960050;background-color:#1e0010">}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#960050;background-color:#1e0010">}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">server&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">.......&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#960050;background-color:#1e0010">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>下面详解的各种 简单指令 或 块指令 一般情况，都将会定义在 &lt;code>server{}&lt;/code> 块指令中&lt;/p>
&lt;h3 id="listen-targetparameterhttpsnginxorgendocshttpngx_http_core_modulehtmllisten">&lt;a href="https://nginx.org/en/docs/http/ngx_http_core_module.html#listen">listen TARGET[PARAMETER];&lt;/a>&lt;/h3>
&lt;ul>
&lt;li>默认值：&lt;code>listen *：80 | *：8000;&lt;/code>&lt;/li>
&lt;/ul>
&lt;p>指定 Virtual Server 监听的端口，也可加上 IP:PORT&lt;/p>
&lt;ul>
&lt;li>&lt;strong>TARGET&lt;/strong> # 每个 Virtual Server 的 listen 指令都会让 Nginx 监听一个 TARGET。TARGET 可以有多种格式：
&lt;ul>
&lt;li>ADDRESS:[PORT] # 监听在指定的 IP 和端口上，ADDRESS 可以使用通配符。&lt;/li>
&lt;li>PORT # 省略地址，即监听在所有 IP 的指定端口上。&lt;/li>
&lt;li>UNIX:PATH # 监听在以 unix: 为前缀的 UNIX 套接字上。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>PARAMETER&lt;/strong> # 可以为指定的监听配置参数，多个参数以空格分割：
&lt;ul>
&lt;li>&lt;strong>default_server&lt;/strong> # 将该 Virtual Server 设为默认。若客户端的请求没有匹配到任何 Virtual Server，则该请求由默认 Virtual Server 处理。
&lt;ul>
&lt;li>注意：若没有任何 Virtual Server 配置了 listen 指令的 defautl_server 参数，那么当匹配不到 Virtual Server 时，默认的 Virtual Server 就是&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>ssl&lt;/strong> # 启动 SSL 模块，让此监听上接受的所有连接都应在 SSL 模式下工作&lt;/li>
&lt;li>&amp;hellip;&amp;hellip;&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h3 id="server_name-stringhttpsnginxorgendocshttpngx_http_core_modulehtmlserver_name">&lt;a href="https://nginx.org/en/docs/http/ngx_http_core_module.html#server_name">server_name STRING;&lt;/a>&lt;/h3>
&lt;ul>
&lt;li>默认值：&lt;code>server_name &amp;quot;&amp;quot;;&lt;/code>&lt;/li>
&lt;/ul>
&lt;p>入口名称(也就是 Virtual Server 的名字)。用来匹配一个请求 Header 中的 Host 字段。&lt;/p>
&lt;p>STRING 可以是完整（精确）名称，通配符或正则表达式。通配符是一个字符串，在字符串的开始，结尾或同时包括和都包括星号（*）。星号匹配任何字符序列。 NGINX Plus 对正则表达式使用 Perl 语法;在其前面加上波浪号（〜）。&lt;/p>
&lt;p>server_name 指令是用来匹配用户在浏览器浏览网站时，输入的 域名 或者 IP:PORT 的。比如用户访问 &lt;a href="https://www.baidu.com">www.baidu.com&lt;/a>。server_name 就可以设置为 *.baidu.com&lt;/p>
&lt;p>如果有多个域名，则可以写多个 server_name 指令，也就是说所有来自这些域名的流量都会被统一处理。&lt;/p>
&lt;h2 id="流量处理指令">流量处理指令&lt;/h2>
&lt;p>流量处理的指令通常都在 &lt;code>**location URI {}**&lt;/code>** **块指令内。&lt;/p>
&lt;h3 id="location--uri-httpnginxorgendocshttpngx_http_core_modulehtmllocation">&lt;a href="http://nginx.org/en/docs/http/ngx_http_core_module.html#location">location [=|~|~*|^~] URI {}&lt;/a>&lt;/h3>
&lt;p>根据用户请求的 URI 进行匹配，匹配到时，此请求将被响应的 &lt;code>location{}&lt;/code> 块指令中的指令所处理。对于用户请求的匹配优先级：&lt;/p>
&lt;ul>
&lt;li>&lt;strong>=&lt;/strong> #&lt;/li>
&lt;li>&lt;strong>^~&lt;/strong> #&lt;/li>
&lt;li>&lt;strong>~&lt;/strong> # 正则匹配。区分大小写的匹配&lt;/li>
&lt;li>&lt;strong>~*&lt;/strong> # 正则匹配。不区分大小写&lt;/li>
&lt;li>&lt;strong>无符号&lt;/strong> # 精确匹配,区分大小写,不区分大小写&lt;/li>
&lt;/ul>
&lt;blockquote>
&lt;p>下面详解的各种 简单指令 或 块指令 一般情况，都将会定义在 &lt;code>location URL {}&lt;/code> 块指令中&lt;/p>
&lt;/blockquote>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-nginx" data-lang="nginx">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">location&lt;/span> &lt;span style="color:#e6db74">/&lt;/span> { &lt;span style="color:#75715e"># 用户请求 / 目录下的文件的时候如何处理
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#f92672">limit_except&lt;/span> &lt;span style="color:#e6db74">GET&lt;/span> &lt;span style="color:#e6db74">POST&lt;/span> &lt;span style="color:#e6db74">HEAD&lt;/span>{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">deny&lt;/span> &lt;span style="color:#e6db74">all&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">if&lt;/span> &lt;span style="color:#e6db74">http_version&lt;/span> == &lt;span style="color:#ae81ff">1&lt;/span>&lt;span style="color:#e6db74">.0&lt;/span> &lt;span style="color:#e6db74">then&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">return&lt;/span> &lt;span style="color:#e6db74">ngx.exec(&amp;#34;/hcs_proxy_10&amp;#34;,&lt;/span> &lt;span style="color:#e6db74">args)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">else&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">return&lt;/span> &lt;span style="color:#e6db74">ngx.exec(&amp;#34;/hcs_proxy_11&amp;#34;,&lt;/span> &lt;span style="color:#e6db74">args)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">end&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#960050;background-color:#1e0010">}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">location&lt;/span> ~ &lt;span style="color:#e6db74">\.php$&lt;/span> { &lt;span style="color:#75715e">#用户请求的是.php文件的时候是如何处理的
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#f92672">fastcgi_pass&lt;/span> 127.0.0.1:&lt;span style="color:#ae81ff">9000&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">.......&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#960050;background-color:#1e0010">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="proxy_pass-urlhttpsnginxorgendocshttpngx_http_proxy_modulehtmlproxy_pass">&lt;a href="https://nginx.org/en/docs/http/ngx_http_proxy_module.html#proxy_pass">proxy_pass URL;&lt;/a>&lt;/h3>
&lt;p>代替用户把对 location 定义的请求下的 URL 交给指定的 UPSTREAM 来处理请求。该指令属于 ngx_http_proxy_modeule 模块
URL 有多种表示方法(下面的 Protocol 通常都是 http 或 https)&lt;/p>
&lt;ul>
&lt;li>&lt;strong>Protocol://ServerGroup/URI;&lt;/strong> # 将流量代理到&lt;a href="https://www.yuque.com/go/doc/34075747">一组服务器&lt;/a>上。每个流量都会根据负载均衡的规则交给 upstream{} 指令块中定义的服务器。
&lt;ul>
&lt;li>新版中，也可以省略 Protocol://，直接使用 ServerGroup 的名称即可。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>Protocol://IP:PORT/URI;&lt;/strong> # 将流量代理到指定的服务器上。当只有一台可用的后端服务器时可以使用这种方式，这样就不用再使用 upstream 指令块定义了&lt;/li>
&lt;li>&lt;strong>Protocol:unix:/PATH/TO/FILE:/URI;&lt;/strong> # 将流量代理到本地的 UNIX-domain Socket 上。socket 的路径需要使用 &lt;code>:&lt;/code> 包裹起来。&lt;/li>
&lt;/ul>
&lt;p>在&lt;a href="#1l7qd">其他指令&lt;/a>中，以 &lt;code>proxy_&lt;/code> 开头的简单指令，都可以作为 &lt;code>proxy_pass&lt;/code> 指令的扩充，以定义更加丰富多样的流量处理功能。&lt;/p>
&lt;p>注意：&lt;/p>
&lt;ul>
&lt;li>WebSocket 代理需要特殊配置。详见&lt;a href="https://nginx.org/en/docs/http/websocket.html">官方文档-websocket&lt;/a>&lt;/li>
&lt;/ul>
&lt;h3 id="特殊的流量处理">特殊的流量处理&lt;/h3>
&lt;p>&lt;strong>fastcgi_pass 127.0.0.1:9000;&lt;/strong> # 反向代理重定向该请求到 127.0.0.1:9000 上,Nginx 本身不支持 PHP 等语言，但是它可以通过 FastCGI 来将请求扔给某些语言或框架处理（例如 PHP、Python、Perl)
代理 fastcgi 协议的指令，当协议不是 http 协议的时候，则要使用 fastcgi 模块，注意与 proxy_pass 的区别。由于 nginx 本身并不支持动态内容的 php 等文件，需要由专门的服务器来提供，nginx 收到 .php 等请求的时候，则将该请求通过 fastcgi 协议，转发给后端能处理动态内容的服务器。比如可以在 location 中设定 .php 访问的条件，然后 {} 内中写明 fastcgi 所定义的服务器&lt;/p>
&lt;p>&lt;strong>fastcgi_index index.php;&lt;/strong> #&lt;/p>
&lt;p>&lt;strong>fastcgi_param SCRIPT_FILENAME /scripts$fastcgi_script_name;&lt;/strong> #&lt;/p>
&lt;p>**fastcgi_cache_path path PATH ARGS&amp;hellip;; **#&lt;/p>
&lt;h1 id="其他指令">其他指令&lt;/h1>
&lt;p>这些指令一般都直接定义在顶层的 &lt;code>http{}&lt;/code> 配置环境中，与 &lt;code>server{}&lt;/code>、&lt;code>upstream{}&lt;/code> 等块指令平级。还有一些指令是可以适用于多个指令块中的。定义在顶层的 &lt;code>http{}&lt;/code> 配置环境中时，效果将会应用在每个 Virtual Server 中，同时也可以定义在单独的 指令块让，让指令作用于局部。&lt;/p>
&lt;p>指令使用时的不成文规范：&lt;/p>
&lt;ul>
&lt;li>通常来说，凡是作用范围包含 &lt;code>location {}&lt;/code> 块指令的 简单指令，都直接定义在 &lt;code>location{}&lt;/code> 块指令中。&lt;/li>
&lt;/ul>
&lt;h2 id="ngx_http_core_module-模块指令">ngx_http_core_module 模块指令&lt;/h2>
&lt;blockquote>
&lt;p>代码：&lt;a href="https://github.com/nginx/nginx/blob/master/src/http/ngx_http_core_module.c">https://github.com/nginx/nginx/blob/master/src/http/ngx_http_core_module.c&lt;/a>&lt;/p>
&lt;/blockquote>
&lt;h3 id="alias-pathhttpsnginxorgendocshttpngx_http_core_modulehtmlalias">&lt;a href="https://nginx.org/en/docs/http/ngx_http_core_module.html#alias">alias PATH;&lt;/a>&lt;/h3>
&lt;p>用于 loation 上下文，定义 location 指令定义的路径的别名，注意与 root 指令的区别&lt;/p>
&lt;h3 id="client_body_in_file_only-on--clean--offhttpsnginxorgendocshttpngx_http_core_modulehtmlclient_body_in_file_only">&lt;a href="https://nginx.org/en/docs/http/ngx_http_core_module.html#client_body_in_file_only">client_body_in_file_only on | clean | off;&lt;/a>&lt;/h3>
&lt;ul>
&lt;li>默认值：&lt;code>client_body_in_file_only off;&lt;/code>&lt;/li>
&lt;li>作用范围：http{}、server{}、location{}&lt;/li>
&lt;/ul>
&lt;p>确定 Nginx 是否应该将整个客户端请求正文保存到文件中。可以在调试期间或使用 &lt;code>$request_body_file&lt;/code> 变量或模块 ngx_http_perl_module 的$ r-&amp;gt; request_body_file 方法时使用此指令。
设置为 on 时，请求处理后不会删除临时文件
clean 值将导致请求处理后留下的临时文件被删除。&lt;/p>
&lt;h3 id="client_header_timeout-numhttpsnginxorgendocshttpngx_http_core_modulehtmlclient_header_timeout">&lt;a href="https://nginx.org/en/docs/http/ngx_http_core_module.html#client_header_timeout">client_header_timeout NUM;&lt;/a>&lt;/h3>
&lt;p>读取 http 请求报文首部的超时时长&lt;/p>
&lt;h3 id="error_page-code--urihttpsnginxorgendocshttpngx_http_core_modulehtmlerror_page">&lt;a href="https://nginx.org/en/docs/http/ngx_http_core_module.html#error_page">error_page CODE &amp;hellip; URI;&lt;/a>&lt;/h3>
&lt;p>根据 http 响应状态码来指名特用的错误页面&lt;/p>
&lt;h3 id="ignore_invalid_headers-onoffhttpsnginxorgendocshttpngx_http_core_modulehtmlignore_invalid_headers">&lt;a href="https://nginx.org/en/docs/http/ngx_http_core_module.html#ignore_invalid_headers">ignore_invalid_headers on|off;&lt;/a>&lt;/h3>
&lt;p>是否忽略无效的请求头。&lt;/p>
&lt;ul>
&lt;li>默认值：&lt;code>ignore_invalid_headers on;&lt;/code>&lt;/li>
&lt;li>作用范围：http{}、server{}&lt;/li>
&lt;/ul>
&lt;p>这里指的无效的请求头，主要是针对请求头的 key 来说，有效的请求头的 key 只能是由 英文字母、数字、连字符、下划线 这其中的 1 个或多个，而下划线的有效性，由 underscores_in_headers 指令控制。&lt;/p>
&lt;h3 id="keepalive_disable-msie6safarinonehttpsnginxorgendocshttpngx_http_core_modulehtmlkeepalive_disable">&lt;a href="https://nginx.org/en/docs/http/ngx_http_core_module.html#keepalive_disable">keepalive_disable msie6|safari|none;&lt;/a>&lt;/h3>
&lt;p>为指定类型的 User Agent(说白了就是浏览器) 禁用长连接&lt;/p>
&lt;h3 id="keepalive_requests-numberhttpsnginxorgendocshttpngx_http_core_modulehtmlkeepalive_requests">&lt;a href="https://nginx.org/en/docs/http/ngx_http_core_module.html#keepalive_requests">keepalive_requests NUMBER;&lt;/a>&lt;/h3>
&lt;p>在一个长连接上所能够允许的最大资源数&lt;/p>
&lt;ul>
&lt;li>默认值：&lt;code>keepalive_requests 1000;&lt;/code>&lt;/li>
&lt;li>作用范围：http{}、server{}、location{}&lt;/li>
&lt;/ul>
&lt;h3 id="keepalive_timeout-durationhttpsnginxorgendocshttpngx_http_core_modulehtmlkeepalive_timeout">&lt;a href="https://nginx.org/en/docs/http/ngx_http_core_module.html#keepalive_timeout">keepalive_timeout DURATION;&lt;/a>&lt;/h3>
&lt;p>设定长连接的超时时长为默认 75 秒&lt;/p>
&lt;ul>
&lt;li>默认值：keepalive_timeout 75s;&lt;/li>
&lt;li>作用范围：http{}、server{}、location{}&lt;/li>
&lt;/ul>
&lt;h3 id="root-pathhttpsnginxorgendocshttpngx_http_core_modulehtmlroot">&lt;a href="https://nginx.org/en/docs/http/ngx_http_core_module.html#root">root PATH;&lt;/a>&lt;/h3>
&lt;p>指明请求的 URL 所对应的资源所在文件系统上的起始路径。&lt;/p>
&lt;ul>
&lt;li>作用范围：http{}、server{}、location{}&lt;/li>
&lt;/ul>
&lt;p>把 root 配置指令写到 &lt;code>location / {} 指令块&lt;/code> 中，即表明当用户请求的是 / 下的资源时候，去 root 定义的本地的那个路径去找对应的资源。&lt;/p>
&lt;h3 id="sendfile-onoffhttpsnginxorgendocshttpngx_http_core_modulehtmlsendfile">&lt;a href="https://nginx.org/en/docs/http/ngx_http_core_module.html#sendfile">sendfile on|off;&lt;/a>&lt;/h3>
&lt;p>开启或关闭 sendfile() 功能，即 [零拷贝](✏IT 学习笔记/📄1.操作系统/2.Kernel(内核)/6.File%20System%20 管理/10.1.零拷贝.md System 管理/10.1.零拷贝.md) 功能。&lt;/p>
&lt;ul>
&lt;li>默认值：&lt;code>sendfile off;&lt;/code>&lt;/li>
&lt;li>作用范围：http{}、server{}、location{}&lt;/li>
&lt;/ul>
&lt;p>在此配置中，使用 SF_NODISKIO 标志调用 sendfile()，这将导致它不会在磁盘 I / O 上阻塞，而是报告该数据不在内存中。然后，nginx 通过读取一个字节来启动异步数据加载。第一次读取时，FreeBSD 内核将文件的前 128K 字节加载到内存中，尽管接下来的读取只会加载 16K 块中的数据。可以使用 read_ahead 指令更改此设置。&lt;/p>
&lt;h3 id="server_names_hash_bucket_size-sizehttpnginxorgendocshttpngx_http_core_modulehtmlserver_names_hash_bucket_size">&lt;a href="http://nginx.org/en/docs/http/ngx_http_core_module.html#server_names_hash_bucket_size">server_names_hash_bucket_size SIZE;&lt;/a>&lt;/h3>
&lt;p>设置 server_name 指定设定的服务器名称哈希表的桶容量。默认值取决于处理缓存线的大小。&lt;/p>
&lt;ul>
&lt;li>默认值：&lt;code>server_namers_hash_bucket_size 32|64|128;&lt;/code>&lt;/li>
&lt;li>作用范围：http{}&lt;/li>
&lt;/ul>
&lt;h3 id="tcp_nodelay-onoffhttpnginxorgendocshttpngx_http_core_modulehtmltcp_nodelay">&lt;a href="http://nginx.org/en/docs/http/ngx_http_core_module.html#tcp_nodelay">tcp_nodelay on|off;&lt;/a>&lt;/h3>
&lt;p>是否开启长连接使用 tcp_nodelay 选项&lt;/p>
&lt;h3 id="underscores_in_headers-onoffhttpnginxorgendocshttpngx_http_core_modulehtmlunderscores_in_headers">&lt;a href="http://nginx.org/en/docs/http/ngx_http_core_module.html#underscores_in_headers">underscores_in_headers on|off;&lt;/a>&lt;/h3>
&lt;p>是否允许请求头中的 key 带有下划线。&lt;/p>
&lt;ul>
&lt;li>默认值：&lt;code>underscores_in_headers off;&lt;/code>&lt;/li>
&lt;li>作用范围：http{}、server{}&lt;/li>
&lt;/ul>
&lt;p>默认不允许，所有请求头中带有下划线的请求虽然可以被正常代理，但是其中带有下划线的请求头无法被传递到后端服务器。该指令受 ignore_invalid_headers(忽略无效请求头) 指令约束。若关闭 ignore_invalid_headers 指令，则 underscores_in_headers 指令不管如何配置都没有用。&lt;/p>
&lt;h2 id="ngx_http_log_module-模块指令">ngx_http_log_module 模块指令&lt;/h2>
&lt;blockquote>
&lt;p>代码：&lt;a href="https://github.com/nginx/nginx/blob/master/src/http/modules/ngx_http_log_module.c">https://github.com/nginx/nginx/blob/master/src/http/modules/ngx_http_log_module.c&lt;/a>&lt;/p>
&lt;/blockquote>
&lt;h3 id="access_log-path-format-parameterhttpnginxorgendocshttpngx_http_log_modulehtmlaccess_log">&lt;a href="http://nginx.org/en/docs/http/ngx_http_log_module.html#access_log">access_log PATH FORMAT [PARAMETER];&lt;/a>&lt;/h3>
&lt;p>设置 access 日志的写入路径。&lt;/p>
&lt;ul>
&lt;li>默认值：&lt;code>access_log logs/access.log combined;&lt;/code>&lt;/li>
&lt;li>作用范围：http{}、server{}、location{}&lt;/li>
&lt;/ul>
&lt;p>FORMAT 是 &lt;code>log_format&lt;/code> 指令定义的日志格式名称，若不指定则默认是名为 combined 的日志格式&lt;/p>
&lt;h3 id="log_formatnameescapedefaultjsonnonestringhttpnginxorgendocshttpngx_http_log_modulehtmllog_format">&lt;a href="http://nginx.org/en/docs/http/ngx_http_log_module.html#log_format">log_format NAME [escape=default|json|none] STRING &amp;hellip;;&lt;/a>&lt;/h3>
&lt;p>设定 Nginx 的日志格式。&lt;/p>
&lt;ul>
&lt;li>默认值：&lt;code>log_format combined &amp;quot;...&amp;quot;;&lt;/code>&lt;/li>
&lt;li>作用范围：http{}&lt;/li>
&lt;/ul>
&lt;p>定义一个日志格式并将该格式命名为 NAME，格式名称可以在 access_log 等指令中直接引用。
STRING 就是具体的日志格式，其中可以引用一些自带的变量，类似于编程语言中的 printf 关键字效果。具体可用变量详见官方指令详解。&lt;/p>
&lt;p>combined 是 Nginx 默认的日志格式名称，格式如下：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-nginx" data-lang="nginx">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">log_format&lt;/span> &lt;span style="color:#e6db74">combined&lt;/span> &lt;span style="color:#e6db74">&amp;#39;&lt;/span>$remote_addr &lt;span style="color:#e6db74">-&lt;/span> $remote_user &lt;span style="color:#e6db74">[&lt;/span>$time_local] &lt;span style="color:#e6db74">&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#39;&amp;#34;&lt;/span>$request&amp;#34; $status $body_bytes_sent &lt;span style="color:#e6db74">&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#39;&amp;#34;&lt;/span>$http_referer&amp;#34; &lt;span style="color:#e6db74">&amp;#34;&lt;/span>$http_user_agent&amp;#34;&amp;#39;;
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>更多日志格式设置方法，见 &lt;a href="https://www.yuque.com/go/doc/33182060">log_format 指令详解&lt;/a>。&lt;/p>
&lt;h2 id="ngx_http_proxy_module-模块指令">ngx_http_proxy_module 模块指令&lt;/h2>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://nginx.org/en/docs/http/ngx_http_proxy_module.html">org 官方文档，http-ngx_http_proxy_module&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://github.com/nginx/nginx/blob/master/src/http/modules/ngx_http_proxy_module.c">GitHub 代码：nginx/nginx/src/http/modules/ngx_http_proxy_module.c&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;h3 id="proxy_pass-urlhttpnginxorgendocshttpngx_http_proxy_modulehtmlproxy_pass">&lt;a href="http://nginx.org/en/docs/http/ngx_http_proxy_module.html#proxy_pass">proxy_pass URL;&lt;/a>&lt;/h3>
&lt;ul>
&lt;li>默认值：&lt;code>无&lt;/code>&lt;/li>
&lt;li>作用范围：location{}&lt;/li>
&lt;/ul>
&lt;p>该指令是 ngx_http_proxy_module 模块的核心指令，也是 http{}、stream{} 指令块中用来执行流量处理的指令。&lt;/p>
&lt;blockquote>
&lt;p>参考：&lt;a href="https://mp.weixin.qq.com/s/D3dri6v0Tk45TOWsDb0HqQ">https://mp.weixin.qq.com/s/D3dri6v0Tk45TOWsDb0HqQ&lt;/a>&lt;/p>
&lt;/blockquote>
&lt;p>根据 URL 最后有没有 &lt;code>/&lt;/code> 会分为多种情况（现假设客户端请求 URL 为：&lt;code>https://172.16.1.1/hello/world.html&lt;/code>）：&lt;/p>
&lt;ul>
&lt;li>有 &lt;code>/&lt;/code>&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-nginx" data-lang="nginx">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">location&lt;/span> &lt;span style="color:#e6db74">/hello/&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">proxy_pass&lt;/span> &lt;span style="color:#e6db74">http://127.0.0.1/&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ul>
&lt;li>代理到 http://127.0.0.1/world.html&lt;/li>
&lt;li>无 &lt;code>/&lt;/code>&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-nginx" data-lang="nginx">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">location&lt;/span> &lt;span style="color:#e6db74">/hello/&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">proxy_pass&lt;/span> &lt;span style="color:#e6db74">http://127.0.0.1&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ul>
&lt;li>代理到 URL：http://127.0.0.1/hello/world.html&lt;/li>
&lt;li>有其他路由，且有 &lt;code>/&lt;/code>&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-nginx" data-lang="nginx">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">location&lt;/span> &lt;span style="color:#e6db74">/hello/&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">proxy_pass&lt;/span> &lt;span style="color:#e6db74">http://127.0.0.1/test/&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ul>
&lt;li>代理到 URL：http://127.0.0.1/test/world.html&lt;/li>
&lt;li>有其他路由，且无 &lt;code>/&lt;/code>&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-nginx" data-lang="nginx">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">location&lt;/span> &lt;span style="color:#e6db74">/hello/&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">proxy_pass&lt;/span> &lt;span style="color:#e6db74">http://127.0.0.1/test&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ul>
&lt;li>代理到 URL：http://127.0.0.1/testworld.html&lt;/li>
&lt;/ul>
&lt;h3 id="proxy_cache_path-path-argshttpnginxorgendocshttpngx_http_proxy_modulehtmlproxy_cache_path">&lt;a href="http://nginx.org/en/docs/http/ngx_http_proxy_module.html#proxy_cache_path">proxy_cache_path PATH ARGS&amp;hellip;;&lt;/a>&lt;/h3>
&lt;p>设定代理服务缓存路径和其它参数&lt;/p>
&lt;ul>
&lt;li>作用范围：http{}&lt;/li>
&lt;/ul>
&lt;h3 id="proxy_http_version-versionhttpnginxorgendocshttpngx_http_proxy_modulehtmlproxy_http_version">&lt;a href="http://nginx.org/en/docs/http/ngx_http_proxy_module.html#proxy_http_version">proxy_http_version VERSION;&lt;/a>&lt;/h3>
&lt;p>设置用于代理的 HTTP 协议版本。&lt;/p>
&lt;ul>
&lt;li>默认值：&lt;code>proxy_http_version 1.0;&lt;/code>&lt;/li>
&lt;li>作用范围：http{}、server{}、location{}&lt;/li>
&lt;/ul>
&lt;blockquote>
&lt;p>建议将 1.1 版与 Keepalive 连接和 NTLM 身份验证配合使用。&lt;/p>
&lt;/blockquote>
&lt;h3 id="proxy_intercept_errors-onoffhttpnginxorgendocshttpngx_http_proxy_modulehtmlproxy_intercept_errors">&lt;a href="http://nginx.org/en/docs/http/ngx_http_proxy_module.html#proxy_intercept_errors">proxy_intercept_errors on|off;&lt;/a>&lt;/h3>
&lt;p>确定是否应将代码大于或等于 300 的代理响应传递给客户端，还是应拦截并重定向到 nginx，以便使用 error_page 指令进行处理&lt;/p>
&lt;ul>
&lt;li>作用范围：http{}、server{}、location{}&lt;/li>
&lt;/ul>
&lt;h3 id="proxy_redirect-redirect-replacementhttpnginxorgendocshttpngx_http_proxy_modulehtmlproxy_redirect">&lt;a href="http://nginx.org/en/docs/http/ngx_http_proxy_module.html#proxy_redirect">proxy_redirect REDIRECT REPLACEMENT;&lt;/a>&lt;/h3>
&lt;p>修改被代理服务器的响应头中 Location 和 Refresh 字段的值。&lt;/p>
&lt;ul>
&lt;li>默认值：&lt;code>proxy_redirect default;&lt;/code>&lt;/li>
&lt;li>作用范围：http{}、server{}、location{}&lt;/li>
&lt;/ul>
&lt;p>假如一个被代理的服务器响应头为 &lt;code>Location: http://localhost:8000/two/some/uri/&lt;/code>。那么如果配置了如下指令：&lt;code>proxy_redirect http://localhost:8000/two/ http://frontend/one/;&lt;/code> 之后。Nginx 响应给客户端的头变成了 &lt;code>Location: http://frontend/one/some/uri/&lt;/code>&lt;/p>
&lt;p>&lt;strong>EXAMPLE&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>&lt;code>proxy_redirect http:// https://;&lt;/code>
&lt;ul>
&lt;li>所有 3XX 跳转的 http 的请求都会被转为 https&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h3 id="proxy_set_header-field-valuehttpnginxorgendocshttpngx_http_proxy_modulehtmlproxy_set_header">&lt;a href="http://nginx.org/en/docs/http/ngx_http_proxy_module.html#proxy_set_header">proxy_set_header FIELD VALUE;&lt;/a>&lt;/h3>
&lt;p>用来重定义发往后端服务器的请求 Header 内容。&lt;strong>常用指令&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>默认值：
&lt;ul>
&lt;li>&lt;code>proxy_set_header Host $proxy_host;&lt;/code>&lt;/li>
&lt;li>&lt;code>proxy_set_header Connection close;&lt;/code>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>作用范围：http{}、server{}、location{}&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>FIELD(字段)&lt;/strong> # 指定要重新定义的请求 Header 的字段
&lt;strong>VALUE(值)&lt;/strong> # Header 字段的值。可以是包含文本、变量（nginx 的内置变量）或者它们的组合。&lt;/p>
&lt;ul>
&lt;li>注意：
&lt;ul>
&lt;li>在 nginx 的配置文件中，如果当前模块中没有 proxy_set_header 的设置，则会从上级别继承配置。继承顺序为：http, server, location。&lt;/li>
&lt;li>由于 UPSTREAM 服务器收到的请求报文所含 IP 为代理服务器的 IP，那么就需要在代理服务器上配置该项，把用户 IP 暴露给 UPSTREAM 服务器&lt;/li>
&lt;li>该指令最常用在 &lt;code>location{}&lt;/code> 块指令中，以便为每个路径的 HTTP 请求，都设置各自的 请求头。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h3 id="proxy_ssl_certificate-filehttpnginxorgendocshttpngx_http_proxy_modulehtmlproxy_ssl_certificate">&lt;a href="http://nginx.org/en/docs/http/ngx_http_proxy_module.html#proxy_ssl_certificate">proxy_ssl_certificate file;&lt;/a>&lt;/h3>
&lt;p>指定 PEM 格式的证书文件，Ngxin 作为客户端向被代理的 HTTPS 服务器发起请求时，用来进行身份验证&lt;/p>
&lt;ul>
&lt;li>作用范围：http{}、server{}、location{}&lt;/li>
&lt;/ul>
&lt;h3 id="proxy_ssl_certificate_key-filehttpnginxorgendocshttpngx_http_proxy_modulehtmlproxy_ssl_certificate_key">&lt;a href="http://nginx.org/en/docs/http/ngx_http_proxy_module.html#proxy_ssl_certificate_key">proxy_ssl_certificate_key file;&lt;/a>&lt;/h3>
&lt;p>指定 PEM 格式的密钥，Ngxin 作为客户端向被代理的 HTTPS 服务器发起请求时，用来进行身份验证&lt;/p>
&lt;ul>
&lt;li>作用范围：http{}、server{}、location{}&lt;/li>
&lt;/ul>
&lt;h3 id="proxy_ssl_trusted_certificate-filehttpnginxorgendocshttpngx_http_proxy_modulehtmlproxy_ssl_trusted_certificate">&lt;a href="http://nginx.org/en/docs/http/ngx_http_proxy_module.html#proxy_ssl_trusted_certificate">proxy_ssl_trusted_certificate FILE;&lt;/a>&lt;/h3>
&lt;p>指定想要信任的 CA 证书文件，Ngxin 作为客户端向被代理的 HTTPS 服务器发起请求时，用来进行身份验证&lt;/p>
&lt;ul>
&lt;li>作用范围：http{}、server{}、location{}&lt;/li>
&lt;/ul>
&lt;h3 id="代理超时相关指令">代理超时相关指令&lt;/h3>
&lt;h4 id="proxy_connect_timeout-durationhttpnginxorgendocshttpngx_http_proxy_modulehtmlproxy_connect_timeout">&lt;a href="http://nginx.org/en/docs/http/ngx_http_proxy_module.html#proxy_connect_timeout">proxy_connect_timeout DURATION;&lt;/a>&lt;/h4>
&lt;p>与被代理服务器建立连接的超时时间。&lt;/p>
&lt;ul>
&lt;li>默认值：&lt;code>proxy_connect_timeout 60s;&lt;/code>&lt;/li>
&lt;li>作用范围：http{}、server{}、location{}&lt;/li>
&lt;/ul>
&lt;p>注意：这个超时时间通常不应该超过 75 秒&lt;/p>
&lt;h4 id="proxy_read_timeout-durationhttpnginxorgendocshttpngx_http_proxy_modulehtmlproxy_read_timeout">&lt;a href="http://nginx.org/en/docs/http/ngx_http_proxy_module.html#proxy_read_timeout">proxy_read_timeout DURATION;&lt;/a>&lt;/h4>
&lt;p>从被代理服务器读取响应的超时时间&lt;/p>
&lt;ul>
&lt;li>默认值：&lt;code>proxy_read_timeout 60s;&lt;/code>&lt;/li>
&lt;li>作用范围：http{}、server{}、location{}&lt;/li>
&lt;/ul>
&lt;p>该超时时间仅在两个连续的&lt;strong>读取&lt;/strong>操作时间，而不是用于整个响应的传输。如果被代理服务器在这段时间内&lt;strong>未传输&lt;/strong>任何内容，则连接将关闭。&lt;/p>
&lt;p>所谓的两个连续读取操作，就是发送请求后，尝试读取响应的操作，其实就是读取 socket 中的数据。所以才被称为 等待被代理服务器响应的超时时间。&lt;/p>
&lt;p>当一个请求从 Client 发送到 Nginx 后，Nginx 再转发给被代理服务器，如果被代理服务器的响应时间超过了 proxy_read_timeout，则 Nginx 将会返回给 Client 一个 &lt;strong>504 状态码&lt;/strong>。&lt;/p>
&lt;h4 id="proxy_send_timeout-durationhttpnginxorgendocshttpngx_http_proxy_modulehtmlproxy_send_timeout">&lt;a href="http://nginx.org/en/docs/http/ngx_http_proxy_module.html#proxy_send_timeout">proxy_send_timeout DURATION;&lt;/a>&lt;/h4>
&lt;p>将请求发送到被代理服务器的超时时间。&lt;/p>
&lt;ul>
&lt;li>默认值：&lt;code>proxy_send_timeout 60s;&lt;/code>&lt;/li>
&lt;li>作用范围：http{}、server{}、location{}&lt;/li>
&lt;/ul>
&lt;p>该超时时间仅在两个连续的&lt;strong>写入&lt;/strong>操作时间，而不是用于整个响应的传输。如果被代理服务器在这段时间内&lt;strong>未收到&lt;/strong>任何内容，则连接将关闭&lt;/p>
&lt;h2 id="ngx_http_rewrite_moudle-模块指令">ngx_http_rewrite_moudle 模块指令&lt;/h2>
&lt;blockquote>
&lt;p>代码：&lt;a href="https://github.com/nginx/nginx/blob/master/src/http/modules/ngx_http_rewrite_module.c">https://github.com/nginx/nginx/blob/master/src/http/modules/ngx_http_rewrite_module.c&lt;/a>&lt;/p>
&lt;/blockquote>
&lt;h3 id="if-condition-httpnginxorgendocshttpngx_http_rewrite_modulehtmlif">&lt;a href="http://nginx.org/en/docs/http/ngx_http_rewrite_module.html#if">if (Condition) {&amp;hellip;}&lt;/a>&lt;/h3>
&lt;p>用于 server 和 location 上下文中，类似于 if..else..这种编程语言&lt;/p>
&lt;ul>
&lt;li>作用范围：server{}、location{}&lt;/li>
&lt;/ul>
&lt;p>Condition 是具体的匹配条件&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-nginx" data-lang="nginx">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">if&lt;/span> &lt;span style="color:#e6db74">(&lt;/span>$remote_addr ~ &lt;span style="color:#e6db74">&amp;#34;^(12.34|56.78)&amp;#34;&lt;/span> &lt;span style="color:#e6db74">&amp;amp;&amp;amp;&lt;/span> $http_user_agent ~&lt;span style="color:#e6db74">*&lt;/span> &lt;span style="color:#e6db74">&amp;#34;spider&amp;#34;)&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">return&lt;/span> &lt;span style="color:#ae81ff">403&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="return-code--text--url-httpnginxorgendocshttpngx_http_rewrite_modulehtmlreturn">&lt;a href="http://nginx.org/en/docs/http/ngx_http_rewrite_module.html#return">return CODE [ TEXT | URL ];&lt;/a>&lt;/h3>
&lt;p>停止处理，并讲指定的状态码返回给客户端。常与 listen 指令的 default_server 参数一起使用，并指定状态码非 200，当客户端访问的域名不存在时，通过默认的 Virtual Server 处理，返回非 200 的状态码。&lt;/p>
&lt;ul>
&lt;li>作用范围：server{}、location{}、if{}&lt;/li>
&lt;/ul>
&lt;h3 id="rewrite-regex-replacement-flaghttpnginxorgendocshttpngx_http_rewrite_modulehtmlrewrite">&lt;a href="http://nginx.org/en/docs/http/ngx_http_rewrite_module.html#rewrite">rewrite RegEx Replacement [FLAG];&lt;/a>&lt;/h3>
&lt;p>URL 重写，把 RegEx 匹配到的资源重定向到 Replacement 定义的位置&lt;/p>
&lt;ol>
&lt;li>Flag 的用法：
&lt;ol>
&lt;li>last，此 rewrite 规则重写完成后，不再被后面的其他 rewrite 规则进行处理，由 User Agent 重新对重写后 URL 发起新请求&lt;/li>
&lt;li>break，一旦此 rewrite 规则重写完成后，由 User Agent 重新对重写后的 URL 发起新请求，该新请求不再进行 rewrite 检查&lt;/li>
&lt;li>redirect，以 302 响应码，返回新的 URL，即在 web 界面地址栏上显示的 URL 也变了，注意跟前面两个 Flag 的区别&lt;/li>
&lt;li>permanent，以 301 响应码，返回新的 URL&lt;/li>
&lt;/ol>
&lt;/li>
&lt;li>EXAMPLE
&lt;ol>
&lt;li>rewrite ^/images/(.*.jpg)$ /imgs/$1 break; #把请求到 images 目录下的所有资源重定向到 imgs 目录下&lt;/li>
&lt;/ol>
&lt;/li>
&lt;/ol>
&lt;h2 id="其他模块指令">其他模块指令&lt;/h2>
&lt;h3 id="add_header-name-value-alwayshttpnginxorgendocshttpngx_http_headers_modulehtmladd_header">&lt;a href="http://nginx.org/en/docs/http/ngx_http_headers_module.html#add_header">add_header NAME VALUE [always];&lt;/a>&lt;/h3>
&lt;p>重定义发往 client 的响应首部报文&lt;/p>
&lt;ul>
&lt;li>作用范围：http{}、server{}、location{}&lt;/li>
&lt;/ul>
&lt;h3 id="index-filehttpnginxorgendocshttpngx_http_index_modulehtmlindex">&lt;a href="http://nginx.org/en/docs/http/ngx_http_index_module.html#index">index FILE;&lt;/a>&lt;/h3>
&lt;p>设定默认主页面&lt;/p>
&lt;h3 id="stub_status-onoffhttpnginxorgendocshttpngx_http_stub_status_modulehtmlstub_status">&lt;a href="http://nginx.org/en/docs/http/ngx_http_stub_status_module.html#stub_status">stub_status on|off&lt;/a>&lt;/h3>
&lt;p>开启或关闭监控模块，仅能用于 location 上下文&lt;/p>
&lt;h1 id="配置示例">配置示例&lt;/h1>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-nginx" data-lang="nginx">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">http&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">server&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">location&lt;/span> &lt;span style="color:#e6db74">/&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">proxy_pass&lt;/span> &lt;span style="color:#e6db74">http://wss_svr.desistdaydream.ltd&lt;/span>; &lt;span style="color:#75715e"># 转发
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#f92672">proxy_http_version&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>&lt;span style="color:#e6db74">.1&lt;/span>; &lt;span style="color:#75715e"># 代理所用的 http 版本设为 1.1
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#f92672">proxy_set_header&lt;/span> &lt;span style="color:#e6db74">Host&lt;/span> $host;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">proxy_set_header&lt;/span> &lt;span style="color:#e6db74">X-Real_IP&lt;/span> $remote_addr;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">proxy_set_header&lt;/span> &lt;span style="color:#e6db74">X-Forwarded-For&lt;/span> $remote_addr:$remote_port;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">proxy_set_header&lt;/span> &lt;span style="color:#e6db74">Upgrade&lt;/span> $http_upgrade; &lt;span style="color:#75715e"># set_header表示将http协议头升级为websocket协议
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#f92672">proxy_set_header&lt;/span> &lt;span style="color:#e6db74">Connection&lt;/span> &lt;span style="color:#e6db74">upgrade&lt;/span>; &lt;span style="color:#75715e"># set_header表示将http协议头升级为websocket协议
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div></description></item><item><title>Docs: IPVS</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/3.%E9%9B%86%E7%BE%A4%E4%B8%8E%E5%88%86%E5%B8%83%E5%BC%8F/lvs/ipvs/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/3.%E9%9B%86%E7%BE%A4%E4%B8%8E%E5%88%86%E5%B8%83%E5%BC%8F/lvs/ipvs/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/IP_Virtual_Server">Wiki,IPVS&lt;/a>&lt;/li>
&lt;li>&lt;a href="http://www.linuxvirtualserver.org/software/ipvs.html">官方文档&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>&lt;strong>IP Virtual Service(IP 虚拟服务，简称 IPVS)&lt;/strong> 是基于 [NetFilter](✏IT 学习笔记/📄1.操作系统/2.Kernel(内核)/8.Network%20 管理/Linux%20 网络流量控制/Netfilter%20 流量控制系统.md 管理/Linux 网络流量控制/Netfilter 流量控制系统.md) 的 Linux 内核模块，用来实现&lt;a href=".md"> LVS&lt;/a> 集群中的 **Scheduler(调度器) **功能。启动这个模块的 Linux 服务器就变成了 LVS 系统中的 &lt;strong>Director&lt;/strong>，此时，这个服务器可以看作是一种高效的 Layer-4(四层) 交换机。在 Director 上运行 IPVS 代码是 LVS 的基本要素。&lt;/p>
&lt;p>IPVS 在服务器上运行，并充当 RS 集群前面的负载均衡器。IPVS 可以将基于 TCP 和 UDP 的服务请求定向到真实服务器，并使真实服务器的服务在单个 IP 地址上表现为虚拟服务。当一个 TCP 连接的初始 SYN 报文到达时，IPVS 就选择一台服务器，将报文转发给它。此后通过查发报文的 IP 和 TCP 报文头地址，保证此连接的后继报文被转发到相同的服务器。这样，IPVS 无法检查到请求的内容再选择服务器，这就要求后端的服务器组是提供相同的服务，不管请求被送到哪一台服务器，返回结果都应该是一样的。但是在有一些应用中后端的服务器可能功能不一，有的是提供 HTML 文档的 Web 服务器，有的是提供图片的 Web 服务器，有的是提供 CGI 的 Web 服务器。这时，就需要基于内容请求分发 (Content-Based Request Distribution)，同时基于内容请求分发可以提高后端服务器上访问的局部性。&lt;/p>
&lt;ul>
&lt;li>一个 ipvs 主机可以同时定义多个 cluster service&lt;/li>
&lt;li>一个 cluster service 上至少应该定义一个 real server，定义时指明 lvs-type，以及 lvs scheduler&lt;/li>
&lt;/ul>
&lt;p>用白话理解 IPVS：
IPVS 就是包括 Director 和 RS 在内的所有设备上的 IP，统一虚拟成一个 IP，这个 IP 就是面向用户的唯一 IP，用户通过这个 IP，就可以访问集群，让集群为其提供服务，这也是负载均衡的体现，也是集群的体现，把很多设备当做一个整体来看。&lt;/p>
&lt;h2 id="ipvs-与-lvs-的关系">IPVS 与 LVS 的关系&lt;/h2>
&lt;p>LVS 更偏向于描述一个概念，而 IPVS 程序则是实现 LVS 的最核心部分。通过 IPVS 以及其管理工具 ipvsadm，可以实现 LVS 中的 Director(指挥器)。而 RS，本质上并不需要 LVS 或者 IPVS 代码支持，只需要在 DR 模式下，配置一些内核参数即可。&lt;/p>
&lt;p>而随着发展，IPVS 已经存单独的程序，被包含在 Linux 内核中，成了了默认自带的模块。&lt;/p>
&lt;p>可以这么说，IPVS 就是 LVS；也可以说，LVS 包含 ipvs 与 ipvsadm。&lt;/p>
&lt;h1 id="ipvs-配置">IPVS 配置&lt;/h1>
&lt;p>ipvs 可以通过两种方式进行配置：&lt;/p>
&lt;ul>
&lt;li>ipvsadm 命令&lt;/li>
&lt;li>ipvs 模块参数&lt;/li>
&lt;/ul>
&lt;p>ipvs 是一个内核模块，所以，想要配置 ipvs 则需要以[内核模块](Module(模块).md Kernel/Module(模块).md)的配置方式来进行配置。可以通过 modinfo -p ip_vs 命令查看该模块可以配置的参数&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>root@lichenhao:~# modinfo -p ip_vs
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>conn_tab_bits:Set connections&lt;span style="color:#960050;background-color:#1e0010">&amp;#39;&lt;/span> hash size &lt;span style="color:#f92672">(&lt;/span>int&lt;span style="color:#f92672">)&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>现阶段，可用的参数只有一个：
&lt;strong>conn_tab_bits&lt;/strong> # 设置连接表的大小。&lt;code>默认值：12&lt;/code>。&lt;/p>
&lt;ul>
&lt;li>该参数控制下面示例中 size 的大小，2 的 12 次方，4096&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>root@lichenhao:~# ipvsadm -ln
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>IP Virtual Server version 1.2.1 &lt;span style="color:#f92672">(&lt;/span>size&lt;span style="color:#f92672">=&lt;/span>4096&lt;span style="color:#f92672">)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Prot LocalAddress:Port Scheduler Flags
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> -&amp;gt; RemoteAddress:Port Forward Weight ActiveConn InActConn
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>IPVS connection hash table size，该表用于记录每个进来的连接及路由去向的信息（这个和 iptables 跟踪表类似）。连接的 Hash 表要容纳几百万个并发连接，任何一个报文到达都需要查找连接 Hash 表。Hash 表的查找复杂度为 O(n/m)，其中 n 为 Hash 表中对象的个数，m 为 Hash 表的桶个数。当对象在 Hash 表中均匀分布和 Hash 表的桶个数与对象个数一样多时，Hash 表的查找复杂度可以接近 O(1)&lt;/p>
&lt;p>连接跟踪表中，每行称为一个 hash bucket（hash 桶），桶的个数是一个固定的值 CONFIG_IP_VS_TAB_BITS，默认为 12（2 的 12 次方，4096）。这个值可以调整，该值的大小应该在 8 到 20 之间。&lt;/p>
&lt;p>LVS 的调优建议将 hash table 的值设置为不低于并发连接数。例如，并发连接数为 200，Persistent 时间为 200S，那么 hash 桶的个数应设置为尽可能接近 200x200=40000，2 的 15 次方为 32768 就可以了。当 ip_vs_conn_tab_bits=20 时，哈希表的的大小（条目）为 pow(2,20)，即 1048576。&lt;/p>
&lt;p>这里的 hash 桶的个数，并不是 LVS 最大连接数限制。LVS 使用哈希链表解决“哈希冲突”，当连接数大于这个值时，必然会出现哈稀冲突，会（稍微）降低性能，但是并不对在功能上对 LVS 造成影响。&lt;/p>
&lt;p>修改模块参数：echo &amp;ldquo;options ip_vs conn_tab_bits=22&amp;rdquo; &amp;gt; /etc/modprobe.d/ip_vs.conf，效果如下：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>IP Virtual Server version 1.2.1 &lt;span style="color:#f92672">(&lt;/span>size&lt;span style="color:#f92672">=&lt;/span>4194304&lt;span style="color:#f92672">)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Prot LocalAddress:Port Scheduler Flags
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> -&amp;gt; RemoteAddress:Port Forward Weight ActiveConn InActConn
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>TCP 10.10.9.60:30000 rr persistent &lt;span style="color:#ae81ff">30&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> -&amp;gt; 10.10.9.69:30000 Route &lt;span style="color:#ae81ff">1&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> -&amp;gt; 10.10.9.70:30000 Route &lt;span style="color:#ae81ff">1&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div></description></item><item><title>Docs: ipvsadm 命令行工具</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/3.%E9%9B%86%E7%BE%A4%E4%B8%8E%E5%88%86%E5%B8%83%E5%BC%8F/lvs/ipvs/ipvsadm-%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%B7%A5%E5%85%B7/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/3.%E9%9B%86%E7%BE%A4%E4%B8%8E%E5%88%86%E5%B8%83%E5%BC%8F/lvs/ipvs/ipvsadm-%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%B7%A5%E5%85%B7/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;h1 id="syntax语法">Syntax(语法)&lt;/h1>
&lt;p>处理 Virtual Service 的命令语法：&lt;/p>
&lt;ul>
&lt;li>&lt;strong>ipvsadm COMMAND VirtualService [-s Scheduler] [Persistence OPTIONS]&lt;/strong>&lt;/li>
&lt;/ul>
&lt;p>处理指定 Virtual Service 下的 Real Server 的命令语法：&lt;/p>
&lt;ul>
&lt;li>&lt;strong>ipvsadm COMMAND VirtualService ServerAddress [PacketForwardingMethod] [Weight Options]&lt;/strong>&lt;/li>
&lt;/ul>
&lt;p>**
命令语法中各参数的含义&lt;/p>
&lt;ul>
&lt;li>&lt;strong>VirtuslService&lt;/strong> # 用于指定基于协议或者地址或者端口号的虚拟服务，通过三元组定义：Protocol、IP、PORT。
&lt;ul>
&lt;li>格式：&lt;code>-PROTOCOL IP:PORT&lt;/code>
&lt;ul>
&lt;li>-PROTOCOL 分两种
&lt;ul>
&lt;li>-t, &amp;ndash;tcp-service&lt;/li>
&lt;li>-u, &amp;ndash;udp-service&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>Scheduler&lt;/strong> # Director 的调度方法
&lt;ul>
&lt;li>详见&lt;a href="https://www.yuque.com/go/doc/33184072"> LVS 介绍&lt;/a> 文章中描述的调度方法，使用其中 10 种任意一种的英文简称来写该参数，注意：是小写字母&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>ServerAddress&lt;/strong> # RS 的 IP&lt;/li>
&lt;li>&lt;strong>PacketForwardingMethod&lt;/strong> # 该位置指明 LVS 的工作模式，不写该参数表明默认 DR 类型
&lt;ul>
&lt;li>-g, &amp;ndash;gatewaying # 网关，表示 DR 模式&lt;/li>
&lt;li>-i, &amp;ndash;ipip # IP 封装 IP，表示 TUN 模式&lt;/li>
&lt;li>-m, &amp;ndash;masquerading # 伪装，表示 NAT 模式&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>Weight Options&lt;/strong> # 权重选项&lt;/li>
&lt;/ul>
&lt;h2 id="command">COMMAND&lt;/h2>
&lt;p>管理集群服务的 COMMAND&lt;/p>
&lt;ul>
&lt;li>** -A, &amp;ndash;add-service** # 创建一个 VirtualService . 服务地址由 IP，PORT，protocol(协议)组成&lt;/li>
&lt;li>&lt;strong>-E, &amp;ndash;edit-service&lt;/strong> # 修改一个 VirtualService&lt;/li>
&lt;li>&lt;strong>-D, &amp;ndash;delete-service&lt;/strong> # 删除一个虚拟服务,以及相关的 RS&lt;/li>
&lt;li>&lt;strong>-C, &amp;ndash;clear&lt;/strong> # 清空这个虚拟服务器的表&lt;/li>
&lt;li>&lt;strong>-R, &amp;ndash;restore&lt;/strong> # 从标准输出还原 ipvs 规则&lt;/li>
&lt;li>**-S, &amp;ndash;save **# 保存 ipvs 规则到标准输出&lt;/li>
&lt;/ul>
&lt;p>管理集群服务中的 RS 的 COMMAND&lt;/p>
&lt;ul>
&lt;li>&lt;strong>-a, &amp;ndash;add-server&lt;/strong> # 向指定的 VirtualService 中添加一个 RS&lt;/li>
&lt;li>&lt;strong>-e, &amp;ndash;edit-server&lt;/strong> # 修改指定 VirtualService 中的 RS&lt;/li>
&lt;li>&lt;strong>-d, &amp;ndash;delete-server&lt;/strong> # 从指定的 VirtualService 中移除一个 RS&lt;/li>
&lt;/ul>
&lt;p>通用的 COMMAND&lt;/p>
&lt;ul>
&lt;li>&lt;strong>-Z, &amp;ndash;zero&lt;/strong> # 清空一个或所有 Virtual Service 下的数据包&lt;/li>
&lt;li>&lt;strong>-L, -l, &amp;ndash;list&lt;/strong> # 如果没有指定参数，则列出虚拟服务器表。如果输入了 service-address，只列出该服务。&lt;/li>
&lt;li>**&amp;ndash;set TCP TCPFIN UDP **# 更改用于 IPVS 连接的超时值。 此命令始终使用 3 个参数，分别表示 TCP 会话，接收到 FIN 数据包后的 TCP 会话和 UDP 数据包的超时值（以秒为单位）。 超时值 0 表示保留了相应条目的当前超时值。&lt;code>默认值：900 120 300&lt;/code>。&lt;/li>
&lt;/ul>
&lt;h2 id="options">OPTIONS&lt;/h2>
&lt;ul>
&lt;li>&lt;strong>-p, &amp;ndash;persistent [TIME]&lt;/strong> # 指定持久连接的超时时间&lt;/li>
&lt;/ul>
&lt;h3 id="与--l--l---list-命令搭配使用的选项">与 -L, -l, &amp;ndash;list 命令搭配使用的选项&lt;/h3>
&lt;ul>
&lt;li>&lt;strong>-n&lt;/strong> # 当配合 -l 查询的时候，显示 IP 地址而不显示主机名，即不把 IP 解析成主机名。与 -l 命令配合时，效果如下：&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">[&lt;/span>root@dr-01 ~&lt;span style="color:#f92672">]&lt;/span>&lt;span style="color:#75715e"># ipvsadm -Ln&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>IP Virtual Server version 1.2.1 &lt;span style="color:#f92672">(&lt;/span>size&lt;span style="color:#f92672">=&lt;/span>4194304&lt;span style="color:#f92672">)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Prot LocalAddress:Port Scheduler Flags
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> -&amp;gt; RemoteAddress:Port Forward Weight ActiveConn InActConn
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>TCP 10.10.9.60:80 rr
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> -&amp;gt; 10.10.9.61:80 Route &lt;span style="color:#ae81ff">1&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> -&amp;gt; 10.10.9.62:80 Route &lt;span style="color:#ae81ff">1&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>TCP 10.10.9.60:30000 rr persistent &lt;span style="color:#ae81ff">30&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> -&amp;gt; 10.10.9.69:30000 Route &lt;span style="color:#ae81ff">1&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> -&amp;gt; 10.10.9.70:30000 Route &lt;span style="color:#ae81ff">1&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ul>
&lt;li>Forward # 当前 lvs 的模型，其中 Masq 为 nat 模型，route 为 dr 模型&lt;/li>
&lt;li>Weight # 当前 rs 的权重&lt;/li>
&lt;li>ActiveConn # 活动连接数,也就是 tcp 连接状态的 ESTABLISHED;&lt;/li>
&lt;li>InActConn # 指除了 ESTABLISHED 以外的,所有的其它状态的 tcp 连接.&lt;/li>
&lt;li>&lt;strong>-c, &amp;ndash;connection&lt;/strong> # 输出 ipvs 当 前的连接状态信息。效果如下：&lt;/li>
&lt;/ul>
&lt;!-- raw HTML omitted -->
&lt;pre>&lt;code>[root@node-1 ~]# ipvsadm --list -nc
IPVS connection entries
pro expire state source virtual destination
TCP 14:52 ESTABLISHED 10.244.3.238:60996 10.96.0.1:443 172.38.40.214:6443
UDP 03:39 UDP 10.244.3.244:39398 10.96.0.10:53 10.244.0.39:53
TCP 14:48 ESTABLISHED 10.244.3.238:58412 10.96.0.1:443 172.38.40.214:6443
&lt;/code>&lt;/pre>
&lt;ul>
&lt;li>&lt;strong>&amp;ndash;timeout&lt;/strong> # 输出 TCP 会话，接收到 FIN 数据包后的 TCP 会话和 UDP 数据包的超时值（以秒为单位）。效果如下：&lt;/li>
&lt;/ul>
&lt;!-- raw HTML omitted -->
&lt;pre>&lt;code>[root@node-1 ~]# ipvsadm -ln --timeout
Timeout (tcp tcpfin udp): 900 120 300
&lt;/code>&lt;/pre>
&lt;ul>
&lt;li>**&amp;ndash;daemon **# Daemon information output. The list command with this option will display the daemon status and its multicast interface.&lt;/li>
&lt;li>&lt;strong>&amp;ndash;stats&lt;/strong> # 显示统计数据，效果如下&lt;/li>
&lt;/ul>
&lt;!-- raw HTML omitted -->
&lt;pre>&lt;code>[root@node-1 ~]# ipvsadm -ln --stats
IP Virtual Server version 1.2.1 (size=4096)
Prot LocalAddress:Port Conns InPkts OutPkts InBytes OutBytes
-&amp;gt; RemoteAddress:Port
TCP 172.38.40.216:30080 0 0 0 0 0
-&amp;gt; 10.244.5.86:80 0 0 0 0 0
TCP 10.96.0.1:443 66 4327 4056 500036 4558037
-&amp;gt; 172.38.40.212:6443 22 835 702 147508 743066
-&amp;gt; 172.38.40.213:6443 22 2485 2432 240938 2923352
-&amp;gt; 172.38.40.214:6443 22 1007 922 111590 891619
&lt;/code>&lt;/pre>
&lt;ul>
&lt;li>&lt;strong>&amp;ndash;rate&lt;/strong> # 速率信息输出。显示服务及其服务器的速率信息（例如，连接/秒，字节/秒和数据包/秒）。&lt;/li>
&lt;li>&lt;strong>&amp;ndash;thresholds&lt;/strong> # 输出阈值信息。显示服务列表中每个服务器的上/下连接阈值信息。&lt;/li>
&lt;li>&lt;strong>&amp;ndash;persistent-conn&lt;/strong> # 持久连接信息的输出。在服务列表中显示每个服务器的持久连接计数器信息。持久连接用于将实际连接从同一客户端/网络转发到同一服务器。&lt;/li>
&lt;/ul>
&lt;h1 id="example">EXAMPLE&lt;/h1>
&lt;ul>
&lt;li>管理集群服务
&lt;ul>
&lt;li>ipvsadm -A|E virtual-service [-s SCHEDULER] #增加修改
&lt;ul>
&lt;li>ipvsadm -A -t 192.168.0.63:80 -s rr #添加一个虚拟服务，调度模式为轮询&lt;/li>
&lt;li>ipvsadm -D virtual-service #删除&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>管理集群服务中的 RS
&lt;ul>
&lt;li>ipvsadm -a|e virtual-service -r server-address [-g|i|m] [-w weight] [-x upper] [-y lower]&lt;/li>
&lt;li>ipvsadm -d virtual-service -r server-address
&lt;ul>
&lt;li>ipvsadm -a -t 192.168.0.60:80 -r 192.168.0.62 -g #添加一个 IP 为 0.62 的 RS 到 0.60 的 LVS 中，LVS 类型为-g,dr 类型&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>通用
&lt;ul>
&lt;li>ipvsadm -C # 清空&lt;/li>
&lt;li>ipvsadm -L|l [virtual-service] [options] # 查询&lt;/li>
&lt;li>ipvsadm -R&lt;/li>
&lt;li>ipvsadm -S [-n]&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>ipvsadm -Ln # 查询，直接显示 IP 不显示主机名，信息如下所示&lt;/li>
&lt;/ul>
&lt;p>那既然这样,为什么从 lvs 里看的 ActiveConn 会比在真实机上通过 netstats 看到的 ESTABLISHED 高很多呢?&lt;/p>
&lt;p>原来 lvs 自身也有一个默认超时时间.可以用 ipvsadm -L &amp;ndash;timeout 查看,默认是 900 120 300,分别是 TCP TCPFIN UDP 的时间.也就是说一条 tcp 的连接经过 lvs 后,lvs 会把这台记录保存 15 分钟,而不管这条连接是不是已经失效(哪怕这次 http 请求已经完成切断开连接，但是在 lvs 中有保存记录)!所以如果你的服务器在 15 分钟以内有大量的并发请求连进来的时候,你就会看到这个数值直线上升.&lt;/p>
&lt;p>其实很多时候,我们看 lvs 的这个连接数是想知道现在的每台机器的真实连接数吧?怎么样做到这一点呢?其实知道现在的 ActiveConn 是怎样产生的,做到这一点就简单了.举个例子:比如你的 lvs 是用来负载网站,用的模式是 dr,后台的 web server 用的 nginx 这时候一条请求过来,在程序没有问题的情况下,一条连接最多也就五秒就断开了.这时候你可以这样设置 ipvsadm &amp;ndash;set 5 10 300.设置 tcp 连接只保持 5 秒中.如果现在 ActiveConn 很高你会发现这个数值会很快降下来,直到降到和你用 nginx 的 status 看当前连接数的时候差不多.你可以继续增加或者减小 5 这个数值,直到真实机的 status 连接数和 lvs 里的 ActiveConn，一般保证该数值与后端 RS 中代理服务的连接保持时间相当即可&lt;/p></description></item><item><title>Docs: log_format 模块指令</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/3.%E9%9B%86%E7%BE%A4%E4%B8%8E%E5%88%86%E5%B8%83%E5%BC%8F/nginx/nginx-%E9%85%8D%E7%BD%AE%E8%AF%A6%E8%A7%A3/%E5%A4%9A%E7%94%A8%E9%80%94%E6%A8%A1%E5%9D%97%E7%9A%84%E6%8C%87%E4%BB%A4/log_format-%E6%A8%A1%E5%9D%97%E6%8C%87%E4%BB%A4/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/3.%E9%9B%86%E7%BE%A4%E4%B8%8E%E5%88%86%E5%B8%83%E5%BC%8F/nginx/nginx-%E9%85%8D%E7%BD%AE%E8%AF%A6%E8%A7%A3/%E5%A4%9A%E7%94%A8%E9%80%94%E6%A8%A1%E5%9D%97%E7%9A%84%E6%8C%87%E4%BB%A4/log_format-%E6%A8%A1%E5%9D%97%E6%8C%87%E4%BB%A4/</guid><description>
&lt;h1 id="日志格式示例">日志格式示例&lt;/h1>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-nginx" data-lang="nginx">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#34;args&amp;#34;:&lt;/span> &lt;span style="color:#e6db74">&amp;#34;&lt;/span>$args&amp;#34;,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#34;body_bytes_sent&amp;#34;:&lt;/span> &lt;span style="color:#e6db74">&amp;#34;&lt;/span>$body_bytes_sent&amp;#34;,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#34;bytes_sent&amp;#34;:&lt;/span> &lt;span style="color:#e6db74">&amp;#34;&lt;/span>$bytes_sent&amp;#34;,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#34;connection_requests&amp;#34;:&lt;/span> &lt;span style="color:#e6db74">&amp;#34;&lt;/span>$connection_requests&amp;#34;,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#34;geoip2_city&amp;#34;:&lt;/span> &lt;span style="color:#e6db74">&amp;#34;&lt;/span>$geoip2_city&amp;#34;,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#34;geoip2_city_country_name&amp;#34;:&lt;/span> &lt;span style="color:#e6db74">&amp;#34;&lt;/span>$geoip2_city_country_name&amp;#34;,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#34;geoip2_latitude&amp;#34;:&lt;/span> &lt;span style="color:#e6db74">&amp;#34;&lt;/span>$geoip2_latitude&amp;#34;,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#34;geoip2_longitude&amp;#34;:&lt;/span> &lt;span style="color:#e6db74">&amp;#34;&lt;/span>$geoip2_longitude&amp;#34;,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#34;geoip2_region_name&amp;#34;:&lt;/span> &lt;span style="color:#e6db74">&amp;#34;&lt;/span>$geoip2_region_name&amp;#34;,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#34;http_host&amp;#34;:&lt;/span> &lt;span style="color:#e6db74">&amp;#34;&lt;/span>$http_host&amp;#34;,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#34;http_user_agent&amp;#34;:&lt;/span> &lt;span style="color:#e6db74">&amp;#34;&lt;/span>$http_user_agent&amp;#34;,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#34;http_x_forwarded_for&amp;#34;:&lt;/span> &lt;span style="color:#e6db74">&amp;#34;&lt;/span>$http_x_forwarded_for&amp;#34;,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#34;remote_addr&amp;#34;:&lt;/span> &lt;span style="color:#e6db74">&amp;#34;&lt;/span>$remote_addr&amp;#34;,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#34;remote_port&amp;#34;:&lt;/span> &lt;span style="color:#e6db74">&amp;#34;&lt;/span>$remote_port&amp;#34;,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#34;request&amp;#34;:&lt;/span> &lt;span style="color:#e6db74">&amp;#34;&lt;/span>$request&amp;#34;,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#34;request_uri&amp;#34;:&lt;/span> &lt;span style="color:#e6db74">&amp;#34;&lt;/span>$request_uri&amp;#34;,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#34;request_time&amp;#34;:&lt;/span> &lt;span style="color:#e6db74">&amp;#34;&lt;/span>$request_time&amp;#34;,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#34;request_method&amp;#34;:&lt;/span> &lt;span style="color:#e6db74">&amp;#34;&lt;/span>$request_method&amp;#34;,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#34;scheme&amp;#34;:&lt;/span> &lt;span style="color:#e6db74">&amp;#34;&lt;/span>$scheme&amp;#34;,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#34;server_name&amp;#34;:&lt;/span> &lt;span style="color:#e6db74">&amp;#34;&lt;/span>$server_name&amp;#34;,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#34;server_protocol&amp;#34;:&lt;/span> &lt;span style="color:#e6db74">&amp;#34;&lt;/span>$server_protocol&amp;#34;,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#34;ssl_protocol&amp;#34;:&lt;/span> &lt;span style="color:#e6db74">&amp;#34;&lt;/span>$ssl_protocol&amp;#34;,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#34;ssl_cipher&amp;#34;:&lt;/span> &lt;span style="color:#e6db74">&amp;#34;&lt;/span>$ssl_cipher&amp;#34;,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#34;status&amp;#34;:&lt;/span> &lt;span style="color:#e6db74">&amp;#34;&lt;/span>$status&amp;#34;,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#34;time_iso8601&amp;#34;:&lt;/span> &lt;span style="color:#e6db74">&amp;#34;&lt;/span>$time_iso8601&amp;#34;,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#34;upstream&amp;#34;:&lt;/span> &lt;span style="color:#e6db74">&amp;#34;&lt;/span>$upstream_addr&amp;#34;,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#34;upstream_connect_time&amp;#34;:&lt;/span> &lt;span style="color:#e6db74">&amp;#34;&lt;/span>$upstream_connect_time&amp;#34;,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#34;upstream_response_time&amp;#34;:&lt;/span> &lt;span style="color:#e6db74">&amp;#34;&lt;/span>$upstream_response_time&amp;#34;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#960050;background-color:#1e0010">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-nginx" data-lang="nginx">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">log_format&lt;/span> &lt;span style="color:#e6db74">promtail_json&lt;/span> &lt;span style="color:#e6db74">&amp;#39;&lt;/span>{&lt;span style="color:#f92672">&amp;#34;@timestamp&amp;#34;:&amp;#34;$time_iso8601&amp;#34;,&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#39;&amp;#34;@version&amp;#34;:&amp;#34;Promtail&lt;/span> &lt;span style="color:#e6db74">json&amp;#34;,&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#39;&amp;#34;server_addr&amp;#34;:&amp;#34;&lt;/span>$server_addr&amp;#34;,&amp;#39;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#39;&amp;#34;remote_addr&amp;#34;:&amp;#34;&lt;/span>$remote_addr&amp;#34;,&amp;#39;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#39;&amp;#34;host&amp;#34;:&amp;#34;&lt;/span>$host&amp;#34;,&amp;#39;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#39;&amp;#34;uri&amp;#34;:&amp;#34;&lt;/span>$uri&amp;#34;,&amp;#39;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#39;&amp;#34;body_bytes_sent&amp;#34;:&lt;/span>$body_bytes_sent,&amp;#39;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#39;&amp;#34;bytes_sent&amp;#34;:&lt;/span>$body_bytes_sent,&amp;#39;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#39;&amp;#34;request&amp;#34;:&amp;#34;&lt;/span>$request&amp;#34;,&amp;#39;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#39;&amp;#34;request_length&amp;#34;:&lt;/span>$request_length,&amp;#39;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#39;&amp;#34;request_time&amp;#34;:&lt;/span>$request_time,&amp;#39;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#39;&amp;#34;status&amp;#34;:&amp;#34;&lt;/span>$status&amp;#34;,&amp;#39;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#39;&amp;#34;http_referer&amp;#34;:&amp;#34;&lt;/span>$http_referer&amp;#34;,&amp;#39;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#39;&amp;#34;http_user_agent&amp;#34;:&amp;#34;&lt;/span>$http_user_agent&amp;#34;&amp;#39;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#39;&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">}&lt;/span>&lt;span style="color:#e6db74">&amp;#39;&lt;/span>;
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div></description></item><item><title>Docs: LVS</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/3.%E9%9B%86%E7%BE%A4%E4%B8%8E%E5%88%86%E5%B8%83%E5%BC%8F/lvs/lvs/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/3.%E9%9B%86%E7%BE%A4%E4%B8%8E%E5%88%86%E5%B8%83%E5%BC%8F/lvs/lvs/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Linux_Virtual_Server">Wiki,LVS&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/IP_Virtual_Server">Wiki,IPVS&lt;/a>&lt;/li>
&lt;li>&lt;a href="http://www.linuxvirtualserver.org/">官网&lt;/a>&lt;/li>
&lt;li>&lt;a href="http://www.linuxvirtualserver.org/zh/">官网,中文&lt;/a>&lt;/li>
&lt;li>&lt;a href="http://www.austintek.com/LVS/LVS-HOWTO/HOWTO/">官方文档,HOWTO&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>&lt;strong>Linux Virtual Server(Linux 虚拟服务器，简称 LVC)&lt;/strong> 是一个可以实现虚拟的服务器集群功能的项目，用于实现负载均衡的软件技术。一般情况下，LVS 代之一组服务器，对于外部客户端来说，这似乎是一台服务器，所以，也称为 &lt;strong>。&lt;/strong>&lt;/p>
&lt;p>目前，LVS 项目已经被集成到 Linux 内核中，并通过 &lt;a href="https://desistdaydream.github.io/docs/IT%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/3.%E9%9B%86%E7%BE%A4%E4%B8%8E%E5%88%86%E5%B8%83%E5%BC%8F/LVS/IPVS.md">IPVS&lt;/a>模块实现。LVS 具有良好的可靠性、可扩展性和可操作性，加上其实现最优的集群服务性能所需的低廉成本， LVS 的负载均衡功能经常被用于高性能、高可用的服务器群集中。&lt;/p>
&lt;p>LVS 项目在 1998 年 5 月由&lt;a href="https://baike.baidu.com/item/%E7%AB%A0%E6%96%87%E5%B5%A9/6689425">章文嵩&lt;/a>博士成立，是中国国内最早出现的自由软件项目之一。在 linux2.2 内核时，IPVS 就已经以内核补丁的形式出现。从 2.4 版本以后 IPVS 已经成为 Linux 内核官方标准内核的一部分&lt;/p>
&lt;h2 id="名词解释">名词解释&lt;/h2>
&lt;p>调度器的称呼：scheduler，director，dispatcher，balancer&lt;/p>
&lt;ul>
&lt;li>
&lt;p>&lt;strong>Director(指挥器)&lt;/strong> # 运行 IPVS 的节点。&lt;/p>
&lt;ul>
&lt;li>&lt;strong>IPVS(IP 虚拟服务)&lt;/strong> # 实现调度功能的程序。是一个 Linux 内核模块。实际上，IPVS 就是一个 &lt;strong>Schedulers(调度器)&lt;/strong>。
&lt;ul>
&lt;li>&lt;strong>Forwarding Method(转发方法)&lt;/strong> # Forwarding Method 用来确定 Director 如何将数据包从客户端转发到 Real Servers。如果把 Director 比做路由器，其转发数据包的规则与普通路由器有所不同。
&lt;ul>
&lt;li>Forwarding Method 其实就是指 LVS 的工作模式，当前有 LVS-NAT、LVS-DR、LVS-TUN 这几种。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>ipvsadm&lt;/strong> # 为 IPVS 程序配置调度规则的用户端应用程序。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>Real Server(真实服务器，简称 RS)&lt;/strong> # 处理来自客户端请求的节点&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>Linux Virtual Server(简称 LVS)&lt;/strong> # Director 与 Real Server 共同组成 LVS 集群。这些机器一起构成虚拟服务器，对于客户端来说，它表现为一台机器。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>Client IP&lt;/strong> # CIP,客户端 IP，用户发送请求报文的 IP&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>Director IP&lt;/strong> # DIP,调度器 IP&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>Virual IP&lt;/strong> # VIP,虚拟 IP，用于提供提供虚拟服务的 IP,该 IP 存在于 Director 和 RS 上&lt;/p>
&lt;ul>
&lt;li>为什么叫虚拟的 IP，因为这个 IP 可以代表 Director，也可以代表很多 RS，把 Director 和 RS 的很多 IP 合成 一个 IP，就称为虚拟的 IP。&lt;/li>
&lt;li>为什么需要虚拟 IP 呢，这就涉及到为什么要有 LVS 了，VIP 就是集群服务的一种体现，1.Cluster 集群，LB 负载均衡，HA 高可用.note 在这篇文章中第一段就是说明了集群的作用，为了让用户不用直接找 RS，而把所有的设备当做一个整体，用户看到的只有一个 IP，而不是那么多 RS 的 IP。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>Real Server IP&lt;/strong> # RIP,调度 IP，真实服务器 IP&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h2 id="lvs-architecture架构">LVS Architecture(架构)&lt;/h2>
&lt;p>典型的 LVS 集群架构如图 所示。在 LVS 负载均衡集群架构中，尽管整个集群内部有多个物理节点在处理用户发出的请求，但是在用户看来，所有的内部应用都是透明的，用户只是在使用一个虚拟服务器提供的高性能服务，这也是 Linux 虚拟服务器项目，即 LVS 项目的主要名称来源，如下是对 LVS 集群架构中各个层次的功能描述。
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/zzd89g/1622466145377-4664be5a-f6bd-4537-94eb-72054d13d096.png" alt="">&lt;/p>
&lt;p>在基于 LVS 项目架构的服务器集群系统中，通常包含三个功能层次：&lt;/p>
&lt;ul>
&lt;li>&lt;strong>Load Balancer(负载均衡)&lt;/strong> # 是整个集群系统的前端机器，在一组服务器之间均衡来自客户端的请求，让客户端认为所有服务都来自同一个 IP。
&lt;ul>
&lt;li>Director(调度器) 就是在该层工作&lt;/li>
&lt;li>负载均衡层位于整个集群系统的最前端，由一台或者多台 Director 组成， IPVS 模块就安装在 Director Server 的系统上，而 Director Server 的主要功能类似路由器，其包含了完成 LVS 负载转发功能所设定的路由表， Director 利用这些路由表信息把用户的请求分发到 Sever Cluster 层的物理服务器(Real Server) 上。此外，为了监测各个 Real Server 服务器的健康状况，在 Director Server 上还要安装监控模块 Ldirectord，当监控到某个 Real Server 不可用时，该服务器会被从 LVS 路由表中剔除，恢复时又会重新加入。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>Server Cluster(服务器集群)&lt;/strong> # 这是一组运行实际网络服务的服务器，如 Web、邮件、FTP、DNS 和媒体服务。
&lt;ul>
&lt;li>Real Server(真实服务器) 就是在该层工作&lt;/li>
&lt;li>服务器阵列或服务器池由一组实际运行应用服务的物理机器组成，Real Server 可以是 Web 服务器、Mail 服务器、FTP 服务器、DNS 服务器以及视频服务器中的一个或者多个的组合。每个 Real Server 之间通过高速的 LAN 或分布在各地的 WAN 相连接。在实际应用中，为了减少资源浪费， Director Server 也可以同时兼任 Real Server 的角色，即在 Real Server 同时部署 IPVS 模块。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>Shared Storage(共享存储)&lt;/strong> # 为服务器提供共享的存储空间，便于提供相同的服务。
&lt;ul>
&lt;li>共享存储可以是数据库系统、网络文件系统或分布式文件系统。服务器节点需要动态更新的数据应该存储在基于数据的系统中，当服务器节点在数据库系统中并行读写数据时，数据库系统可以保证并发数据访问的一致性。静态数据通常保存在 NFS、CIFS 等网络文件系统中，以便所有服务器节点共享数据。但是，单个网络文件系统的可扩展性是有限的，例如单个 NFS/CIFS 只能支持 4 到 8 个服务器的数据访问。对于大型集群系统，分布式/集群文件系统可以用于共享存储，例如 GPFS，Coda 和 GFS，然后共享存储也可以根据系统需求进行扩展。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>通常情况下，一个 LVS 集群由两类节点组成：&lt;/p>
&lt;ul>
&lt;li>&lt;strong>Director(指挥器)&lt;/strong> # 前端接收客户端请求的节点，并将请求转发给后端 Real Server。Director 通过 IPVS 与 ipvsadm 来实现。&lt;/li>
&lt;li>**Real Server(真实服务器) **# 处理客户端请求的节点。&lt;/li>
&lt;/ul>
&lt;p>这些服务器一起组成了一个虚拟服务器，对于访问他们的客户端来说，它表现为一台机器。&lt;/p>
&lt;p>LVS 的工作模式&lt;/p>
&lt;p>LVS 的 IP 负载均衡技术是通过 IPVS 模块来实现的， IPVS 是 LVS 集群系统的核心软件，其主要安装在集群的 Director Server 上，并在 Director Server 上虚拟出一个 IP 地址，用户对服务的访问只能通过该虚拟 IP 地址实现。这个虚拟 IP 通常称为 LVS 的 VIP(Virtual IP)，用户的访问请求首先经过 VIP 到达 Director，然后由 Director 从 Real Server 列表中按照一定的负载均衡算法选取一个服务节点响应用户的请求。在这个过程中，当用户的请求到达 Director Server 后， Director Server 如何将请求转发到提供服务的 Real Server 节点，而 Real Server 节点又如何将数据返回给用户， 这是 IPVS 实现负载均衡的核心技术。&lt;/p>
&lt;p>IPVS 实现数据路由转发的机制如下几种：&lt;/p>
&lt;ol>
&lt;li>&lt;strong>NAT&lt;/strong> # 支持端口映射但是 DIP 与 RIP 必须要在同一网段&lt;/li>
&lt;li>&lt;strong>DR&lt;/strong> # 不支持端口影响且调度与 RS 必须在同一网络&lt;/li>
&lt;li>&lt;strong>TUN&lt;/strong> # 各 RS 可以放在不同的地域且都在公网上被人直接访问&lt;/li>
&lt;li>&lt;strong>FullNAT&lt;/strong> # 可以在内部构建复杂网络，比如不同 RS 可以跨机房跨网络，而且可以隐藏 RS 不被公网直接访问)&lt;/li>
&lt;/ol>
&lt;p>NAT(Network Address Translation)&lt;/p>
&lt;p>即通过网络地址转换的虚拟服务器技术。在这种负载转发方案中，当用户的请求到达调度器时，调度器自动将请求报文的目标 IP 地址（ VIP ）替换成 LVS 选中的后端 Real Server 地址，同时报文的目标端口也替换为选中的 Real Server 对应端口， 最后将报文请求发送给选中的 Real Server 进行处理。当 Real Server 处理完请求并将结果数据返回给用户时，需要再次经过负载调度器，此时调度器进行相反的地址替换操作，即将报文的源地址和源端口改成 VIP 地址和相应端口，然后把数据发送给用户，完成整个负载调度过程。可以看出，在这种方式下，用户请求和响应报文都必须经过 Director Server 进行地址转换，请求时进行目的地址转换（ Destination Network Address Translation, DNAT ），响应时进行源地址转换（ Source Network Address Translation, SNAT ）。在这种情况下，如果用户请求越来越多，调度器的处理能力就会成为集群服务快速响应的瓶颈。&lt;/p>
&lt;p>LVS-NAT(Network Address Translation)实测可调度 10 台以内的 RS&lt;/p>
&lt;p>多目标 IP 的 DNAT,通过将请求报文中的目标地址和目标端口改为某挑出的 RS 的 RIP 和 PORT 实现转发&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/zzd89g/1616132542821-5af6ee6a-a6d2-4e55-808d-cc00112912f7.jpeg" alt="">
lvs-nat 的特性&lt;/p>
&lt;ol>
&lt;li>
&lt;p>RS 应该使用私有地址&lt;/p>
&lt;/li>
&lt;li>
&lt;p>RS 的网关必须指向 DIP&lt;/p>
&lt;/li>
&lt;li>
&lt;p>RIP 和 DIP 必须在同一网段内&lt;/p>
&lt;/li>
&lt;li>
&lt;p>请求和响应的报文都得经过 Director，在高负载场景中，Director 很可能成为性能瓶颈(因为既要处理请求报文也要处理响应服方的转发,请求报文一般很小,但响应报文一般都比较大)&lt;/p>
&lt;/li>
&lt;li>
&lt;p>支持端口映射,即可修改请求报文的目标端口.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Director 必须是 Linux 系统，RS 可以是任意支持集群服务的操作系统.&lt;/p>
&lt;/li>
&lt;/ol>
&lt;p>lvs-nat 修改请求报文的目的 IP&lt;/p>
&lt;ol>
&lt;li>注意：该类型中 DIP 与 RIP 必须在同一网段且 RS 的网关为 DIP2，所以 Director 需要有两块网卡，DIP1 与 CIP 想通，DIP2 与 RS 想通。所有请求都经过调度器，包括请求报文和响应报文,调度器压力很大&lt;/li>
&lt;li>数据包到达 Director 时，做 dnat(将 VIP 改为 RIP)，然后发送给 RS。&lt;/li>
&lt;li>RS 处理完数据包返回响应给 Director，源 IP 是 RIP，目标 IP 是 CIP&lt;/li>
&lt;li>这时候 Director 收到响应包后，做 snat(将源 IP 改为 VIP)&lt;/li>
&lt;/ol>
&lt;p>DR(Direct Routing)&lt;/p>
&lt;p>即直接路由技术实现的虚拟服务器。这种技术在调度连接和管理上与 VSNAT 和 VSTUN 技术是一样的，不过它的报文转发方式与前两种均不同， VSDR 通过改写请求报文的 MAC 地址，将请求直接发送到选中的 Real Server ，而 Real Server 则将响应直接返回给客户端。因此，这种技术不仅避免了 VSNAT 中的 IP 地址转换，同时也避免了 VS TUN 中的 IP 隧道开销，所以 VSDR 是三种负载调度机制中性能最高的实现方案。但是，在这种方案下， Director Server 与 Real Sever 必须在同一物理网段上存在互联。&lt;/p>
&lt;p>LVS/DR(Direct Routing 直接路由) 实测可以调度 7、8 十台 RS&lt;/p>
&lt;p>通过为请求报文重新封装一个 MAC 首部进行转发,源 MAC 是 DIP 所在的接口的 MAC,目标 MAC 是某挑选出的 RS 的 RIP 所在接口的 MAC 地址;源 IP/PORT,以及目标 IP/PORT 均保持不变,请求报文经过 Dirctor 但响应报文不再经过 Dirctor
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/zzd89g/1616132542832-728aa1cf-07b1-47b3-8cdf-d8918c6789e6.jpeg" alt="">&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/zzd89g/1616132542795-f5e7f61e-e8c9-4b6e-bcd5-6c038fb30f7f.jpeg" alt="">&lt;/p>
&lt;h3 id="dr-类型工作流程">DR 类型工作流程&lt;/h3>
&lt;p>如上图所示：当客户端请求 VIP 时，通过互联网到达前端路由 Route1，再通过交换机到达 Dirctor 上；而 Dirctor 在收到请求报文后，通过定义在 ipvs 规则中的各 rip 去获得各 RS 的 MAC 地址，并在此报文外再封装一个 MAC 地址,源 MAC 为 Dirctor 的 DIP 端口的 MAC 而目标 MAC 改为其中被调度算法选中一个 RS 的 MAC，但该报文的目标 ip(VIP)不变，最后通过 DIP 接口发送给 RS；为了 RS 能接收 Dirctor 发来的报文，需要在各 RS 上也配置 VIP，但 RS 上的 VIP 是需要隔离前端 arp 广播的，所以需要将各 RS 上的 VIP 隐藏（RS 上的 VIP 通常配置到 lo 网卡接口的别名上，并配合修改 Linux 内核参数来实现隔离 arp 广播）；而 RS 封装响应报文时，源 IP 为 VIP，目标 ip 为 CIP，并通过 RIP 的网络接口直接向外发送响应，不再经过 Dirctor。&lt;/p>
&lt;p>需要注意的是：因为 Route1 的 A 点的 IP 和 Dirctor 的 VIP 在同一网段内，VIP 通常是公网 IP；而 DIP、RIP 通常是私有 IP，且这两个 IP 通常也应在同一物理网络内；假设 RIP 与 Route1 的 A 接口(同 Director 的 VIP DIP)在同一网段，则这时可将 RS 的网关指向 Route1，否则，Route2 只能其它路由器(如 Route2)接口访问互联网，且 Route2 的 C 点的 IP 需要与 RIP 在同一网段内，此时 RIP 响应的报文就通过 Route2 发送。&lt;/p>
&lt;ul>
&lt;li>1.RIP 与 DIP 在同一 IP 网络，RS 可以使用私有地址，也可以使用公网地址，此时可以直接通过互联网连入 RS，以实现配置、监控等&lt;/li>
&lt;li>2.RS 的网关一定不能指向 DIP&lt;/li>
&lt;li>3.RS 跟 Director 要在同一物理网络内（不能有路由器分隔,因为要将报文封装 MAC 首部进行报文转发）&lt;/li>
&lt;li>4.请求报文必须经过 Director，但响应报文不能经过 Director 而是由 RS 直接发往 Client 以释放 Directory 的压力。&lt;/li>
&lt;li>5.不支持端口映射(因为响应报文不经过 Director)&lt;/li>
&lt;li>6.RS 可以使用大多数的操作系统&lt;/li>
&lt;li>7.Director 的 VIP 对外可见，RS 的 VIP 对外不可见&lt;/li>
&lt;li>8.RS 跟 Director 都得配置使用 VIP&lt;/li>
&lt;li>9.确保前端路由器将目标 IP 为 VIP 的请求报文发往 Director(上文的设置)&lt;/li>
&lt;/ul>
&lt;p>lvs-dr(direct routing) #操纵新的 MAC 地址，直接路由，默认的 LVS 类型，通过请求报文的目标 MAC 地址进行转发，即需要 ARP 的 IP 与 MAC 映射表才能转发，由于调度器是基于二层 MAC 来调度的，所以调度器与 RS 必须要在同一个 VLAN 中
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/zzd89g/1616132542782-786ee136-62a7-4fb6-8faf-2a43c660d620.jpeg" alt="">&lt;/p>
&lt;ol>
&lt;li>如图所示，请求报文直接到调度器，然后调度器选择一台 RS，让这台 RS 来响应该请求，RS 与用户直接交互，不再经过调度器，只有请求报文经过调度器，响应报文是不经过调度器的(RS 的网关不能指定到 DIP)所以用户访问的业务 IP 都是该业务的调度器的浮动 IP，通过调度器来给用户选择一台提供服务的主机，这样调度器没有压力。&lt;/li>
&lt;li>RS 构建响应报文响应用户请求的时候，需要使用 VIP 来进行响应，因为用户请求的是 VIP，RS 只能用 VIP 来进行响应。每台 RS 都有一个 VIP，但是用户请求的 VIP 必须要到调度器上，那么这时候在 VIP 上就需要绑定 mac 地址了，以 mac 地址来区分调度器与 RS。&lt;/li>
&lt;li>所以 Director 在调度主机的时候，会把选择的 RS 的物理网卡的 MAC 地址加进请求报文中作为目的 mac 地址，然后转发给 RS。（用户依然会通过 VIP 来访问，但是数据到交换机的时候，是根据 MAC 地址来转发该数据到 RS，这样就实现了 RS 与用户的直接交互；所以当用户断开连接再次请求后，由于请求报文目的 MAC 地址没了，所以交换机会根据本身的 arp 表把，找到 mac 地址，这时候依然是 Director，则数据包到 Director 的时候需要重新配分新的 RS）&lt;/li>
&lt;li>由于 Linux 从哪网卡收的就要从哪个网卡发，为了解决响应报文中的源地址不能是 RS 的 IP 的问题，那么每台 RS 的 VIP 则不配置在物理网卡上，而是配置在这台机器 lo(loopback)接口上，给 lo 起一个别名用作 VIP，具体原因如下
&lt;ol>
&lt;li>由于路由器一般是动态学习 ARP 包的（一般动态配置 DHCP 的话），当内网的机器要发送一个到外部的 ip 包，那么它就会请求 路由器的 Mac 地址，发送一个 arp 请求，这个 arp 请求里面包括了自己的 ip 地址和 Mac 地址，而 linux 默认是使用 ip 的源 ip 地址作为 arp 里面 的源 ip 地址，而不是使用发送设备上面的 ，这样在 lvs 这样的架构下，所有 RS 发送包都是同一个 VIP 地址，那么 arp 请求就会包括 VIP 地址和设备 Mac，而路由器收到这个 arp 请求就会更新自己的 arp 缓存，这样就会造成 ip 欺骗了，VIP 被抢夺，这样调度器的 VIP 就被被 RS 抢走，这样就会出现问题，下一个数据包就无法正确发送给调度器了。所以需要给每台 RS 都要配置 arp 的通告以及响应规则以实现该功能&lt;/li>
&lt;li>&lt;strong>arp_ignore&lt;/strong> # arp 忽略，响应 arp 请求时的动作，由该项参数决定
&lt;ol>
&lt;li>参数 0：默认参数，只要收到 arp 请求，无论是哪个地址，都做出响应&lt;/li>
&lt;li>参数 1：推荐设置，只响应目的 IP 地址为接收网卡上的本地地址的 arp 请求。(如果外面有人询问 VIP，由于 VIP 在 lo 上，不在接收网卡上，所以不会响应询问 VIP 的 arp 通告。这样防止 VIP 的 arp 被抢夺)。&lt;/li>
&lt;li>参数 2：只响应目标 IP 地址是来访网络接口本地地址的 ARP 查询请求,且来访 IP 必须在该网络接口的子网段内&lt;/li>
&lt;li>参数 3：不回应该网络界面的 arp 请求，而只对设置的唯一和连接地址做出回应&lt;/li>
&lt;li>参数 4-7：保留未使用&lt;/li>
&lt;li>参数 8：不回应所有（本地地址）的 arp 查询&lt;/li>
&lt;/ol>
&lt;/li>
&lt;li>**arp_announce **# arp 宣告，通告 arp 给别人时的动作；以及是否接收 arp 通告，并记录；由该项参数决定
&lt;ol>
&lt;li>参数 0：默认参数，把本机所有网卡上的所有地址通告给网络中（不管任何情况，使用发送或者转发的数据包的源 IP 作为发送 ARP 请求的 Sender IP）(与参数 1 的区别：不管目的 IP 与本地接口的 IP 在不在同一个网段，都是用发送源 IP 作为 Sender IP）&lt;/li>
&lt;li>参数 1：尽量避免从本网络的外部接口向非本网络中的网络,通告非本网络中的接口的地址（只有当数据包的目的 IP 与本地某个接口的网段相同时，才使用发送或者转发的数据包的源 IP 作为发送 ARP 请求的 Sender IP，不属于则按参数 2 处理）
&lt;ol>
&lt;li>本网络的意思就是：比如 192.168.0.0/24 是一个网络，192.168.1.0/24 是另一个网络，0.0 网络中的地址尽量不通告给 1.0 网络中的地址，但是当需要发送数据的时候，还是需要进行通告&lt;/li>
&lt;/ol>
&lt;/li>
&lt;li>参数 2：推荐设置，在发送 arp 宣告的时候不使用数据包的源 IP，使用能与目标主机通信的最佳地址来作为发送 ARP 的 Sender IP，优先选择对外接口的主 IP；（loopback 不是对外接口）(e.g.在 RS 给 client 发送响应数据包的时候，默认情况下，会先给发送 arp 通告，询问网关在哪。由于数据包的源 IP 是 VIP，MAC 是发送数据包的物理网卡的 MAC；目的 IP 是 client 的 ip，目的 mac 未知，所以 arp 通告的源 IP 也是 VIP，那么这时候，交换机就会更新 VIP 与 MAC 的对应关系，此时产生问题，因为 VIP 应该与 director 的 MAC 绑定才对，但是现在收到的这个 arp 通告说是 VIP 应该与 RS 绑定，这明显是不应该发生的。所以在发送数据包之前的 arp 通告，不能使用 VIP，而是使用本机的物理网卡来进行 arp 通告。不过这个从 RS 发出的数据包的封包其实源 IP 还是 VIP、源 MAC 是物理网卡的 MAC，这样在 client 收到 RS 的响应包之后与 RS 交互发送数据包，目的 IP 则是 VIP，目的 MAC 则是 RS 物理网卡的 MAC，当交换机收到 client 发的包时，解开封包看到目的 mac 地址是 RS 的，则直接就把数据包交给对应的网口了，至于 IP 则是在三层路由的时候才用的，当交换机已经收到这个包时，就会把 IP 拆开直接使用 MAC 来传输数据包。而当 RS 与 client 断开连接后，client 再次主动发的数据包到交换机时，目的 MAC 是未知的，交换机就会把数据包交给 director 来进行处理，因为交换机的 arp 表里已经把 VIP 与 director 的 mac 绑定了)。arp 原理详见 ARP.note
&lt;ol>
&lt;li>三者 ARP 的通告规则区别：参数 0 是不管什么时候把所有 IP 都通告，参数 1 是不同网段需要通信的时候才通告，有死亡时间，过一段时间，该 ARP 表自动消失，参数 2 是使用最优的 IP 进行 ARP 通告，不是对外接口(比如 loopback)的永不通告&lt;/li>
&lt;/ol>
&lt;/li>
&lt;/ol>
&lt;/li>
&lt;/ol>
&lt;/li>
&lt;li>所以，为了满足 dr 类型的需要，arp_ignore 设置为 1（RS 响应 arp 通告的时候 VIP 不在接收 arp 请求这个接口上就不会响应），arp_announce 需要设置为 2(RS 在发送 arp 通告的时候不使用 VIP 作为源 IP)，该配置为内核参数配置，在/proc/sys/net/ipv4/conf/all 目录和/proc/sys/net/ipv4/conf/lo 目录下的两个文件进行配置&lt;/li>
&lt;li>再次注意：进行 RS 配置的时候，需要先修改 arp 的配置，再配置 lo 的 VIP。否则如果直接配置 VIP，则会使用 lo 的 VIP 来响应询问 VIP 在哪的 arp 通告，这时候 VIP 与 MAC 的对应关系就会一直变化，这样立刻就会发生 arp 抢夺&lt;/li>
&lt;/ol>
&lt;h2 id="tunip-tunneling">TUN(IP Tunneling)&lt;/h2>
&lt;p>即 IP 隧道技术实现的虚拟服务器。VS TUN 与 VSNAT 技术的报文转发方法不同，在 VS TUN 方式中，调度器采用 IP 隧道技术将用户请求转发到某个选中的 Real Server 上，而这个 Real Server 将直接响应用户的请求，不再经过前端调度器。此外， IP TUN 技术对 RealServer 的地域位置没有要求，其既可以与 Director Server 位于同一个网段，也可位于独立网络中。因此，在 VS TUN 方式中，调度器将只处理用户的报文请求，而无需进行转发， 故集群系统的响应速率相对而言得到极大提高。&lt;/p>
&lt;p>LVS/TUN
模型：在原请求 IP 报文之外新加一个 IP 首部(这个新添加的 IP 首部其源 IP 是 DIP,目标 IP 是 RIP),将报文发往挑选出的目标 RS.
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/zzd89g/1616132542822-64d36467-fa78-48c8-af3c-ea93ccfeea8b.jpeg" alt="">
TUN
TUN 类型工作流程(主要是为了容灾,因为 Director 与各 RS 是在不同网段中,所以可以存在于不同的物理空间)&lt;/p>
&lt;p>LVS TUN 类型特性&lt;/p>
&lt;p>1.RIP，DIP，VIP 都得是公网地址&lt;/p>
&lt;p>2.RS 的网关不会指向也不可能指向 DIP&lt;/p>
&lt;p>3.请求报文经过 Directory，但响应报文一定不经过 Director&lt;/p>
&lt;p>4.不支持端口映射&lt;/p>
&lt;p>5.RS 的 OS 必须得支持隧道功能 ??&lt;/p>
&lt;p>2.4 LVS/FULLNAT (LVS 默认不支持此类型)&lt;/p>
&lt;p>通过同时修改请求报文的源 IP 地址和目标 IP 地址进行转发&lt;/p>
&lt;p>报文件从客户端到调度器时的源 目标 IP : CIP&amp;ndash;&amp;gt;VIP&lt;/p>
&lt;p>报文从 Director 到 RS 时的源 目标 IP 分别是: DIP&amp;ndash;&amp;gt;RIP&lt;/p>
&lt;p>特点&lt;/p>
&lt;ol>
&lt;li>VIP 是公网地址,RIP 和 DIP 是私网地址,且通常不在同一 IP 网络,因此,RIP 的网关一般不会指向 DIP&lt;/li>
&lt;li>RS 收到的请求报文源地址是 DIP,因此只需响应给 DIP, 但 Dirctor 还要将其发往 Client&lt;/li>
&lt;li>请求和响应报文都经由 Dirctor&lt;/li>
&lt;li>支持端口映射.&lt;/li>
&lt;/ol>
&lt;p>lvs-tun(ip tunneling) #在原请求 IP 报文之外新加一个 IP 首部，IP 隧道技术&lt;/p>
&lt;ol>
&lt;li>不修改请求报文的 IP 首部，通过在原有的 IP 首部之外，再封装一个 IP 首部(比如为了运送一袋米，我扛着米运相当于 IP 首部，我骑着驴送，驴相当于新封装的 IP 首部)&lt;/li>
&lt;li>调度器收到请求报文时，再封装一层 IP 首部，把源 IP 至目标 IP 中的的 CIP 至 VIP 放在 DIP 至 RIP 的报文里面，DIP 至 RIP 相当于路由，所以可以不在同一网段,并且 RS 必须支持隧道技术，在解封装的时候，必须明白为什么在拆开 IP 首部之后还有一层 IP 首部&lt;/li>
&lt;li>不支持端口映射，且 RS 的网关不能指向 DIP。&lt;/li>
&lt;/ol>
&lt;p>lvs-fullnat #修改请求报文的源和目标 IP&lt;/p>
&lt;ol>
&lt;li>调度器同时修改请求报文的目标地址和源地址进行转发。把源 IP 和目标 IP 从 CIP—VIP 改成 DIP—RIP&lt;/li>
&lt;li>VIP 是公网地址，RIP 和 DIP 是私网地址，二者无须在同一网络中&lt;/li>
&lt;li>RS 接收到的请求报文的源地址为 DIP，因为要响应给 DIP&lt;/li>
&lt;li>调度器一样要承担很大压力&lt;/li>
&lt;/ol>
&lt;h2 id="note">Note&lt;/h2>
&lt;ol>
&lt;li>为什么在 Director 上除了 DIP 本身还需要一个单独的 VIP，而不可以把 DIP 当做 VIP 来用
&lt;ol>
&lt;li>如果 DIP 与 VIP 一样，那么在 Director 发送 arp 广播的时候，RS 在收到 arp 广播后，回应的报文会回给自己(因为 RS 设备上 lo 网卡上的 VIP 就是 DIP)，这样调度器上的 arp 表里就无法获得后端 RS 的 MAC 地址。如果多了一个 VIP，那么 RS 在回应 Director 的 arp 广播时，就不会回应到自己身上，因为 RS 的 lo 网卡上的 IP 为单独的 VIP，而不同于 DIP。&lt;/li>
&lt;li>结论：在调度器上，除了本身的 DIP 以外，必须要一个 VIP&lt;/li>
&lt;/ol>
&lt;/li>
&lt;li>http 本身是 stateless 无状态的，无法追踪目标来源
&lt;ol>
&lt;li>session 保持机制：会话保持机制，保证 http 协议可以在用户终端连接再次连接后还能存有之前的操作记录
&lt;ol>
&lt;li>session 绑定：将来自于同一个 client 的请求始终绑定在一个 RS 上，不会被调度到别的 RS 上&lt;/li>
&lt;li>session 集群:&lt;/li>
&lt;li>session 服务器&lt;/li>
&lt;/ol>
&lt;/li>
&lt;/ol>
&lt;/li>
&lt;/ol>
&lt;h1 id="scheduling调度-方法">Scheduling(调度) 方法&lt;/h1>
&lt;p>LVS 的调度方法分为两类(静态算法、动态算法)，共 10 种&lt;/p>
&lt;p>在转发方式选定的情况下，采用哪种调度算法将决定整个负载均衡的性能表现。不同的算法适用于不同的生产环境，有时可能需要针对特殊需求自行设计调度算法。&lt;/p>
&lt;ol>
&lt;li>静态方法：仅根据算法本身进行调度（注重起点公平）
&lt;ol>
&lt;li>RR(Round Robin) # 轮询，论调，轮流调度，第一个请求给 RS1，第二个请求给 RS2，第 n 个请求给 RSn，第 n+1 个请求给 RS1。。。。。&lt;/li>
&lt;li>WRR(Weighted RR) # 加权(Weight)轮询，能者多劳，给 RS1 一个请求，就给 RS2 几倍的请求&lt;/li>
&lt;li>SH(Source hash) # 源地址哈希，实现 session 保持的机制,来自同一个 IP 的请求将始终调度到同一个 RS&lt;/li>
&lt;li>DH(Destination Hash) # 目标地址哈希，只要请求的是同一个资源，则将请求调度到同一个 RS,比如 CDN 中所有用户都请求一个资源被调度到一台 RS 上&lt;/li>
&lt;/ol>
&lt;/li>
&lt;li>动态方法：根据算法以及各 RS 的当前负载状态进行调度 Overhead
&lt;ol>
&lt;li>LC(Least Connection) # 最小连接数，新来的请求报文调度给连接数最小的 RS
&lt;ol>
&lt;li>Overhead=Active*256+Inactive&lt;/li>
&lt;/ol>
&lt;/li>
&lt;li>WLC(Weighted LC) # 加权(Weight)最小连接数 默认的调度器类型
&lt;ol>
&lt;li>Overhead=(Active*256+Inactive)/weight&lt;/li>
&lt;/ol>
&lt;/li>
&lt;li>SED(Shortest Expection Delay) # 最短期望延迟
&lt;ol>
&lt;li>Overhead=(Active+1)*256/weight&lt;/li>
&lt;/ol>
&lt;/li>
&lt;li>NQ(Never Queue) # SED 算法的改进&lt;/li>
&lt;li>LBLC(Locality-Based LC) # 基于本地的最小连接数，动态的 DH 算法，正向代理情形下的 cache server 调度&lt;/li>
&lt;li>LBLCR(Locality-Based LC with Replication) # 带复制功能的 LBLC，相当于几台 RS(HCS)中的资源可以互相共享&lt;/li>
&lt;/ol>
&lt;/li>
&lt;/ol>
&lt;h1 id="ldirectord-技术介绍以及产生的原因">LDirectorD 技术介绍，以及产生的原因&lt;/h1>
&lt;p>IPVS 有一个缺陷，无法检查后端 Real Server 的健康状态，就是使用 HA 给 LVS 中的 Director 实现了高可用，也不一定能保证后端的各 RS 可以正常响应用户的请求，当其中一台 RS 不能使用时，访问 vip，还会去调度 down 掉的这台 RS，并返回一个错误的页面。这种情况是不合理的，所以我们需要一个 LVS 的健康检查机制，以便当 RS 无法响应时，可以及时通知给 Director，让其不再把请求调度给这台坏掉的 RS 上。为了实现这个功能，就用到了 heartbea 中的 ldirectord，ldirectord 以守护进程运行在后台，提供生成规则以及 Health check 健康检查
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/zzd89g/1616132542796-003ca683-5cd4-4f31-85ec-6b92628f2017.jpeg" alt="">
该程序依赖于自己的配置文件生成 ipvs 规则，因此，定义集群服务、添加 RS、调度方法等都在配置文件中指定，而无须手动用 ipvsadm 命令更改&lt;/p>
&lt;h2 id="配置">配置&lt;/h2>
&lt;p>/etc/ha.d/ldirectord.cf&lt;/p>
&lt;h2 id="ldirectordcf-文件说明">ldirectord.cf 文件说明&lt;/h2>
&lt;p>&lt;strong>Global Directives&lt;/strong> #全局指令，对所有的 Virtual Services 都有效&lt;/p>
&lt;ul>
&lt;li>checktimeout=3 #检查的超时时间，当对 RS 的健康检查时间超过 3 秒的时候的则认为该 RS 不可用&lt;/li>
&lt;li>checkinterval=1 #检查时间间隔，即每 1 秒都对后端 RS 进行一次健康检查&lt;/li>
&lt;li>#fallback=127.0.0.1:80 #&lt;/li>
&lt;li>autoreload=yes #该配置文件是否自动装载&lt;/li>
&lt;li>#logfile=&amp;quot;/var/log/ldirectord.log&amp;quot; #指明日志文件的 PATH&lt;/li>
&lt;li>#logfile=&amp;ldquo;local0&amp;rdquo; #&lt;/li>
&lt;li>#emailalert=&amp;ldquo;&lt;a href="mailto:admin@x.y.z">admin@x.y.z&lt;/a>&amp;rdquo; #警告信息发送的邮箱地址&lt;/li>
&lt;li>#emailalertfreq=3600 #每隔多久发送一次警告信息到邮箱&lt;/li>
&lt;li>#emailalertstatus=all #通知的 email 信息是全部&lt;/li>
&lt;li>quiescent=no #静默工作模式&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>Sample for an XXXXX&lt;/strong> #对于多种虚拟服务的配置样例，直接修改这一部分内容，可以实现健康检查的基本模式，其中前三行为必须要定义的 LVS 的定义以及调度规则，剩下的所有行定义的都是为 ldirectord 对后端 RS 的健康检查方式，当这些健康检查方式失败的时候，则说明该 RS 不可用&lt;/p>
&lt;ul>
&lt;li>virtual=IP:PORT #定义 VIP 的地址和端口&lt;/li>
&lt;li>real=IP[[-&amp;gt;IP]:[PORT]] TYPE #定义 RS 的 IP 地址和 LVS 类型，类型名介绍详见 LB 的 Packet-Forwarding-Method(LVS Type)内容，其中-&amp;gt;IP 可以实现从哪个 IP 至哪个 IP 的地址段的定义
&lt;ul>
&lt;li>gate #TYPE 为 DR 类型&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>fallback=IP:PORT TYPE #定义当 RS 全部失效时，使用的 server 的地址，端口，LVS 类型。&lt;/li>
&lt;li>scheduler=SCHEDULER #定义 LB 集群中的调度规则，规则类型详见 LB 中的 Director 调度方法&lt;/li>
&lt;li>service=TYPE #定义健康检查的应用层 Protocol，注意：只有当 checktype 指定为 negotiate 的时候，该定义才有意义
&lt;ul>
&lt;li>TYPE 类型包括：ftp|http|stmp|mysql 等&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>protocol=tcp #定义健康检查的传输层 Protocol&lt;/li>
&lt;li>checktype=negotiate #定义健康检查的方法
&lt;ul>
&lt;li>connect #传输层检查，向对方端口尝试发送连接请求&lt;/li>
&lt;li>negotiate #应用层检查协商方法&lt;/li>
&lt;li>ping #网络层检查，ICMP 协议&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>checkport=80 #定义健康检查的端口号&lt;/li>
&lt;li>request=&amp;ldquo;index.html&amp;rdquo; #定义健康检查请求目标 server 的哪个页面&lt;/li>
&lt;li>receive=&amp;ldquo;Test Page&amp;rdquo; #定义健康检查中 request 中所定义的页面请求后回复的内容包含什么信息&lt;/li>
&lt;li>virtualhost=www.x.y.z #定义健康检查虚拟主机的主机名&lt;/li>
&lt;/ul></description></item><item><title>Docs: LVS 配置示例</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/3.%E9%9B%86%E7%BE%A4%E4%B8%8E%E5%88%86%E5%B8%83%E5%BC%8F/lvs/lvs-%E9%85%8D%E7%BD%AE%E7%A4%BA%E4%BE%8B/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/3.%E9%9B%86%E7%BE%A4%E4%B8%8E%E5%88%86%E5%B8%83%E5%BC%8F/lvs/lvs-%E9%85%8D%E7%BD%AE%E7%A4%BA%E4%BE%8B/</guid><description>
&lt;h1 id="dr-模型配置样例">DR 模型配置样例&lt;/h1>
&lt;p>Director 配置&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>ipvsadm -A -t 10.10.100.107:80 -s rr
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>ipvsadm -a -t 10.10.100.107:80 -r 10.10.100.111 -g
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>ipvsadm -a -t 10.10.100.107:80 -r 10.10.100.112 -g
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>RS 的配置&lt;/p>
&lt;p>设置 arp 参数&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>cat &amp;gt; /etc/sysctl.d/lvs-sysctl.conf &lt;span style="color:#e6db74">&amp;lt;&amp;lt; EOF
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">net.ipv4.conf.all.arp_ignore = 1
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">net.ipv4.conf.lo.arp_ignore = 1
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">net.ipv4.conf.all.arp_announce = 2
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">net.ipv4.conf.lo.arp_announce = 2
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">EOF&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>sysctl -p /etc/sysctl.d/*
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>配置 lo 网卡&lt;/p>
&lt;pre>&lt;code>cat &amp;gt; /etc/sysconfig/network-scripts/ifcfg-lo:0 &amp;lt;&amp;lt; EOF
DEVICE=lo:0
IPADDR=10.10.100.107
NETMASK=255.255.255.255
ONBOOT=yes
NAME=loopback
EOF
ifup ifcfg-lo\:0
&lt;/code>&lt;/pre>
&lt;h1 id="其他配置样例">其他配置样例&lt;/h1>
&lt;h2 id="配置一个-nat-类型2-台-rs的集群">配置一个 NAT 类型（2 台 RS）的集群&lt;/h2>
&lt;p>LVS(Thinkpad): if1=172.16.53.128/24(VIP) if2=10.1.1.77/16(DIP)&lt;/p>
&lt;p>RS1(ibm1): 10.1.1.78/16(RIP1)&lt;/p>
&lt;p>RS2(ibm2): 10.1.1.79/16(RIP2)&lt;/p>
&lt;p>RS1 与 RS2 主机使用同一个 vmnet 网卡&lt;/p>
&lt;p>如下图：
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/rlona8/1616132564982-5b0ee7e2-e822-4976-8cf0-b10f9108d986.jpeg" alt="">&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/rlona8/1616132564990-81c808d9-696f-4cda-921e-1f3532fc2a6f.jpeg" alt="">&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/rlona8/1616132565016-ee9b26be-4fb0-4104-b1f8-73ccd019bc04.jpeg" alt="">&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/rlona8/1616132565003-365215ad-80a1-43c2-b7d0-2167171bbd4f.jpeg" alt="">&lt;/p>
&lt;p>分别在 ibm1、ibm2 上装上几个服务&lt;/p>
&lt;p>同步 ibm1 与 ibm2 的时间!这个在集群服务中很重要！！下面两步即同&lt;/p>
&lt;p>![1.编辑/etc/chrony.conf 配置文件](http://upload-images.jianshu.io/upload_images/2057465-&amp;gt;&lt;/p>
&lt;p>da3b895ab16765f0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/rlona8/1616132564982-ee55e0f5-4497-47b9-bb50-7c46bf1028ab.jpeg" alt="">&lt;/p>
&lt;p>2.重启 chronyd 服务&lt;/p>
&lt;p>打开 ibm1 与 ibm2 上的配置 httpd 服务如下图效果&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/rlona8/1616132564958-21036f72-e72e-4b9e-a7e6-c529ced28984.jpeg" alt="">&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/rlona8/1616132564984-b8b52892-fdaa-4068-9dee-a1eeb12c4694.jpeg" alt="">&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/rlona8/1616132564979-267630af-71bf-4a2c-9e9e-e068c6f1947e.jpeg" alt="">&lt;/p>
&lt;p>在 Thinkpad 主机上安装 ipvsadm&lt;/p>
&lt;p>将 RS1 RS2 的默认网关指向 Director 的 DIP&lt;/p>
&lt;p>route add default gw 10.1.1.77/16&lt;/p>
&lt;p>当主机及拓扑结构及 ip 与各种软件都设置好的时候，LVS 的设置是非常简单与快速的一件事&lt;/p>
&lt;p>ipvsadm -A -t 10.1.1.77:80 -s rr # 添加 LVS 集群与调度算法 ipvsadm -a -t 10.1.1.77:80 -r 10.1.1.78 -m -w 1 # 添加 LVS 集群主机与 LVS 调度模式及 RS 权重 ipvsadm -a -t 10.1.1.77:80 -r 10.1.1.79 -m -w 1 # 同上[root@Thinkpad ~]# echo 1 &amp;gt; /proc/sys/net/ipv4/ip_forward # 打开 Director 的转发功能&lt;/p>
&lt;p>至此,一个简单的根据 LVS rr 算法调度的负载均衡集群完成了.&lt;/p>
&lt;h2 id="配置一个-dr-类型2-台-rs的集群三台虚拟机都桥接到物理机上">配置一个 DR 类型（2 台 RS）的集群,三台虚拟机都桥接到物理机上.&lt;/h2>
&lt;p>Directory: DIP: 192.168.31.101/24 调度主机只需要一个网卡接口 VIP 用 DIP 的别名生成&lt;/p>
&lt;p>RS1: 192.168.31.194/24&lt;/p>
&lt;p>RS2: 192.168.31.220/24&lt;/p>
&lt;p>编写以下脚本文件并分别在各 RS 上执行.(setparam.sh)&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#!/bin/bash
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#75715e">#&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>vip&lt;span style="color:#f92672">=&lt;/span>192.168.10.21
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>mask&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#39;255.255.255.255&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">case&lt;/span> $1 in
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>start&lt;span style="color:#f92672">)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> echo &lt;span style="color:#ae81ff">1&lt;/span> &amp;gt; /proc/sys/net/ipv4/conf/all/arp_ignore
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> echo &lt;span style="color:#ae81ff">1&lt;/span> &amp;gt; /proc/sys/net/ipv4/conf/lo/arp_ignore
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> echo &lt;span style="color:#ae81ff">2&lt;/span> &amp;gt; /proc/sys/net/ipv4/conf/all/arp_announce
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> echo &lt;span style="color:#ae81ff">2&lt;/span> &amp;gt; /proc/sys/net/ipv4/conf/lo/arp_announce
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> /sbin/ifconfig lo:0 $vip netmask $mask broadcast $vip up
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> route add -host $vip dev lo:0
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ;;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>stop&lt;span style="color:#f92672">)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> /sbin/ifconfig lo:0 down
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> echo &lt;span style="color:#ae81ff">0&lt;/span> &amp;gt; /proc/sys/net/ipv4/conf/all/arp_ignore
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> echo &lt;span style="color:#ae81ff">0&lt;/span> &amp;gt; /proc/sys/net/ipv4/conf/lo/arp_ignore
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> echo &lt;span style="color:#ae81ff">0&lt;/span> &amp;gt; /proc/sys/net/ipv4/conf/all/arp_announce
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> echo &lt;span style="color:#ae81ff">0&lt;/span> &amp;gt; /proc/sys/net/ipv4/conf/lo/arp_announce
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> route del -host $vip dev lo:0
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ;;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>status&lt;span style="color:#f92672">)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e"># Status of LVS-DR real server.&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> islothere&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">`&lt;/span>/sbin/ifconfig lo:0 | grep $vip&lt;span style="color:#e6db74">`&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> isrothere&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">`&lt;/span>netstat -rn | grep &lt;span style="color:#e6db74">&amp;#34;lo:0&amp;#34;&lt;/span> | grep $vip&lt;span style="color:#e6db74">`&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> &lt;span style="color:#f92672">[&lt;/span> ! &lt;span style="color:#e6db74">&amp;#34;&lt;/span>$islothere&lt;span style="color:#e6db74">&amp;#34;&lt;/span> -o ! &lt;span style="color:#e6db74">&amp;#34;isrothere&amp;#34;&lt;/span> &lt;span style="color:#f92672">]&lt;/span>; &lt;span style="color:#66d9ef">then&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e"># Either the route or the lo:0 device&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e"># not found.&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> echo &lt;span style="color:#e6db74">&amp;#34;LVS-DR real server Stopped.&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">else&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> echo &lt;span style="color:#e6db74">&amp;#34;LVS-DR real server Running.&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">fi&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>;;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>*&lt;span style="color:#f92672">)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> echo &lt;span style="color:#e6db74">&amp;#34;Usage &lt;/span>&lt;span style="color:#66d9ef">$(&lt;/span>basename $0&lt;span style="color:#66d9ef">)&lt;/span>&lt;span style="color:#e6db74"> start|stop&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> exit &lt;span style="color:#ae81ff">1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ;;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">esac&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>编写以下脚本在 Director(调度器)上添加 VIP 添加 LVS 规则等操作 (ipvs.sh)&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#!/bin/bash
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#75715e">#&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>vip&lt;span style="color:#f92672">=&lt;/span>192.168.10.21
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>iface&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#39;eth0:0&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>mask&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#39;255.255.255.255&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>port&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#39;80&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>rs1&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#39;192.168.10.22&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>rs2&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#39;192.168.10.23&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>scheduler&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#39;rr&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">case&lt;/span> $1 in
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>start&lt;span style="color:#f92672">)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ifconfig $iface $vip netmask $mask broadcast $vip up
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> iptables -F
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ipvsadm -A -t &lt;span style="color:#e6db74">${&lt;/span>vip&lt;span style="color:#e6db74">}&lt;/span>:&lt;span style="color:#e6db74">${&lt;/span>port&lt;span style="color:#e6db74">}&lt;/span> -s $scheduler
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ipvsadm -a -t &lt;span style="color:#e6db74">${&lt;/span>vip&lt;span style="color:#e6db74">}&lt;/span>:&lt;span style="color:#e6db74">${&lt;/span>port&lt;span style="color:#e6db74">}&lt;/span> -r $rs1 -g
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ipvsadm -a -t &lt;span style="color:#e6db74">${&lt;/span>vip&lt;span style="color:#e6db74">}&lt;/span>:&lt;span style="color:#e6db74">${&lt;/span>port&lt;span style="color:#e6db74">}&lt;/span> -r $rs2 -g
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ;;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>stop&lt;span style="color:#f92672">)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ipvsadm -C
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ifconfig $iface down
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ;;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>*&lt;span style="color:#f92672">)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> echo &lt;span style="color:#e6db74">&amp;#39;&amp;#39;&lt;/span>Usage: &lt;span style="color:#66d9ef">$(&lt;/span>basename $0&lt;span style="color:#66d9ef">)&lt;/span> &lt;span style="color:#f92672">{&lt;/span>start|stop|status&lt;span style="color:#f92672">}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> exit &lt;span style="color:#ae81ff">1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ;;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">esac&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/rlona8/1616132565011-7f0f7b82-c341-4628-ab9b-a729530ca1d5.jpeg" alt="">&lt;/p>
&lt;h2 id="fwmfirewall-mark借助于防火墙标记来分类报文而后基于标记定义集群服务可将多个不同的应用使用同一个集群服务进行调度">FWM(FireWall Mark)借助于防火墙标记来分类报文，而后基于标记定义集群服务，可将多个不同的应用使用同一个集群服务进行调度。&lt;/h2>
&lt;p>示例：&lt;/p>
&lt;pre>&lt;code>iptables -t mangle -A PREROUTING -d 10.1.0.5 -p tcp -m multiport --dports 80,443 -j MARK --set-mark 11
ipvsadm -A -f 11 -s rr
ipvsadm -a -t 192.168.31.100 -r 192.168.31.194 -g -w 1
ipvsadm -a -t 192.168.31.100 -r 192.168.31.220 -g -w 1
&lt;/code>&lt;/pre>
&lt;p>实现目标 2：firewallmark（fwm）&lt;/p>
&lt;p>fwm 是为指定的某一群体打标签，这一群体可以是某几个 ip 地址或者是几个端口，实现的作用是，可以将需要访问的几个目标地址或者端口定向到同一个标签，比如给 80,8080,443 端口打上同一个标签，那么就可以让用户访问这三个端口中的任意一个端口定向到同一个主机。&lt;/p>
&lt;p>在上面的基础上开始实现 fwm：&lt;/p>
&lt;p>1.host1 上面清理掉之前的规则：&lt;/p>
&lt;p>ipvsadm -C&lt;/p>
&lt;p>2.使用 mangle 在 PREROUTING 上面打上标签&lt;/p>
&lt;p>iptables -A PREROUTNG -t mangle -d 172.16.52.57 -p tcp &amp;ndash;dport 80 -j MARK &amp;ndash;set-mark 9&lt;/p>
&lt;p>ipvsadm -A -f 3 -s rr&lt;/p>
&lt;p>ipvsadm -a -f 3 -r 172.16.52.60 -g&lt;/p>
&lt;p>ipvsadm -a -f 3 -r 172.16.52.61 -g&lt;/p>
&lt;h2 id="lvs-的持久连接机制-persiistence-这个功能与-fwm-结合可实现端口姻亲关系">LVS 的持久连接机制 persiistence 这个功能与 FWM 结合可实现端口姻亲关系&lt;/h2>
&lt;p>LVS 基于其的持久连接模板，实现无论使用任何调度算法，在一段时间内，都能实现将来自同一个地址的请求始终发往同一个 RS。不同于 sh 算法在于其是可自定义的且没有超时时长。&lt;/p>
&lt;pre>&lt;code>ipvsadm -A -t 10.1.0.5:80 -s rr -p 60 # 持久连接定义成60秒，在这个时间之后 rr算法才会生效
ipvsadm -a -t 10.1.0.5:80 -r 10.1.0.7 -g -w 1
ipvsadm -a -t 10.1.0.5:80 -r 10.1.0.8 -g -w 1
&lt;/code>&lt;/pre>
&lt;p>port Affinity：端口姻亲关系&lt;/p>
&lt;p>每端口持久：每集群服务单独定义，并定义其持久性&lt;/p>
&lt;p>每防火墙标记持久：基于防火墙标记定义持久的集群服务，可实现将多个端口上的应用统一调度，即所谓的 port Affinity&lt;/p>
&lt;p>每客户端持久&lt;/p>
&lt;p>实现目标 3：持久连接&lt;/p>
&lt;p>eg1：&lt;/p>
&lt;p>[root@localhost scripts]# ipvsadm -A -t 172.16.52.57:80 -s rr -p&lt;/p>
&lt;p>[root@localhost scripts]# ipvsadm -a -t 172.16.52.57:80 -r 172.16.52.60 -g&lt;/p>
&lt;p>[root@localhost scripts]# ipvsadm -a -t 172.16.52.57:80 -r 172.16.52.61 -g&lt;/p>
&lt;p>说明：基于端口的持久连接，-p 是指定持久时长，默认是 360s，但是 man 手册里面说的 300s，常用方式是： -p timeout&lt;/p>
&lt;p>eg2：&lt;/p>
&lt;p>[root@localhost scripts]# ipvsadm -A -t 172.16.52.57:0 -s rr -p&lt;/p>
&lt;p>[root@localhost scripts]# ipvsadm -a -t 172.16.52.57:0 -r 172.16.52.60 -g&lt;/p>
&lt;p>[root@localhost scripts]# ipvsadm -a -t 172.16.52.57:0 -r 172.16.52.61 -g&lt;/p>
&lt;p>说明：基于客户端的持久连接，使用端口号 0，后面必须要跟-p ，不加可以试试看，会报错的。。。&lt;/p>
&lt;p>eg3：&lt;/p>
&lt;p>[root@localhost scripts]# iptables -A PREROUTING -t mangle -d 172.16.52.57 -p tcp &amp;ndash;dport 80 -j MARK &amp;ndash;set-mark 20&lt;/p>
&lt;p>[root@localhost scripts]# iptables -A PREROUTING -t mangle -d 172.16.52.57 -p tcp &amp;ndash;dport 443 -j MARK &amp;ndash;set-mark 20&lt;/p>
&lt;p>[root@localhost scripts]# ipvsadm -A -f 20 -s rr -p&lt;/p>
&lt;p>[root@localhost scripts]# ipvsadm -a -f 20 -r 172.16.52.60 -g -p&lt;/p>
&lt;p>[root@localhost scripts]# ipvsadm -a -f 20 -r 172.16.52.61 -g -p&lt;/p>
&lt;p>说明：通过防火墙标记的方式来进行的持久连接,可以 cat /proc/net/ip_vs_conn 查看连接状态&lt;/p>
&lt;p>总结：持久连接分为上面三种方式，但跟调度算法无关，调度算法无法保持持久连接&lt;/p>
&lt;h1 id="heading">&lt;/h1></description></item><item><title>Docs: Nginx</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/3.%E9%9B%86%E7%BE%A4%E4%B8%8E%E5%88%86%E5%B8%83%E5%BC%8F/nginx/nginx/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/3.%E9%9B%86%E7%BE%A4%E4%B8%8E%E5%88%86%E5%B8%83%E5%BC%8F/nginx/nginx/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://github.com/nginx/nginx">GitHub 项目，nginx/nginx&lt;/a>
&lt;ul>
&lt;li>原始代码：&lt;a href="https://hg.nginx.org/nginx/">https://hg.nginx.org/nginx/&lt;/a>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;a href="http://nginx.org/">org 官方网站&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.nginx.com/">官方网站&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.nginx.com/products/nginx/modules/">官方网站,动态模块列表&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>Nginx 称为 Engine X，可以做为代理服务器、web 服务器、缓存服务器等来使用。&lt;/p>
&lt;p>传统上基于进程或线程模型架构的 web 服务通过每进程或每线程处理并发连接请求，这势必会在网络和 I/O 操作时产生阻塞，其另一个必然结果则是对内存或 CPU 的利用率低下。生成一个新的进程/线程需要事先备好其运行时环境，这包括为其分配堆内存和栈内存，以及为其创建新的执行上下文等。这些操作都需要占用 CPU，而且过多的进程/线程还会带来线程抖动或频繁的上下文切换，系统性能也会由此进一步下降。&lt;/p>
&lt;p>在设计的最初阶段，nginx 的主要着眼点就是其高性能以及对物理计算资源的高密度利用，因此其采用了不同的架构模型。受启发于多种操作系统设计中基于“事件”的高级处理机制，nginx 采用了模块化、事件驱动、异步、单线程及非阻塞的架构，并大量采用了多路复用及事件通知机制。在 nginx 中，连接请求由为数不多的几个仅包含一个线程的进程 worker 以高效的回环(run-loop)机制进行处理，而每个 worker 可以并行处理数千个的并发连接及请求。&lt;/p>
&lt;p>Nginx 会按需同时运行多个进程：一个主进程(master)和几个工作进程(worker)，配置了缓存时还会有缓存加载器进程(cache loader)和缓存管理器进程(cache manager)等。所有进程均是仅含有一个线程，并主要通过“共享内存”的机制实现进程间通信。主进程以 root 用户身份运行，而 worker、cache loader 和 cache manager 均应以非特权用户身份运行。&lt;/p>
&lt;p>Nginx 特性：&lt;/p>
&lt;ol>
&lt;li>模块化设计，较好的扩展性，所有配置均有指定的模块进行处理。&lt;/li>
&lt;li>高可靠 master &amp;ndash;&amp;gt; worker，主控进程不接收和响应用户请求，主控进程负责解析配置文件并生成多个工作进程，工作进程来响应用户请求
&lt;ol>
&lt;li>主控进程读取并验证配置，创建或绑定套接字，启动及终止和维护 worker 进程的个数，无须重启进程让新配置的配置文件进行加载，以及完成平滑版本升级等等&lt;/li>
&lt;li>工作进程，负责缓存加载的(反向代理时候用)，负责响应用户请求，cache manager 缓存管理&lt;/li>
&lt;/ol>
&lt;/li>
&lt;li>低内存消耗，10000 个 keep-alive 模式下的 connection，仅需 2.5MB 内存&lt;/li>
&lt;li>支持热部署，不停机而更新配置文件，日志文件滚动，升级程序版本&lt;/li>
&lt;li>支持事件驱动、AIO、mmap&lt;/li>
&lt;/ol>
&lt;p>基本功能：&lt;/p>
&lt;ul>
&lt;li>静态资源的 web 服务器，能缓存打开的文件描述符&lt;/li>
&lt;li>http、SMTP、pop3 协议的反向代理服务器&lt;/li>
&lt;li>缓存加速、负载均衡&lt;/li>
&lt;li>支持 FastCGI(fpm，LNMP)，uWSGI(Python)等&lt;/li>
&lt;li>模块化(非 DSO 机制)、过滤器 zip、SSI 及图像的大小调整&lt;/li>
&lt;li>支持 SSL(https)&lt;/li>
&lt;/ul>
&lt;p>扩展功能&lt;/p>
&lt;ul>
&lt;li>基于名称和 IP 的虚拟主机&lt;/li>
&lt;li>支持 keepalive&lt;/li>
&lt;li>支持平滑升级&lt;/li>
&lt;li>定制访问日志&lt;/li>
&lt;li>支持 url 重写&lt;/li>
&lt;li>支持路径别名&lt;/li>
&lt;li>支持基于 IP 及用户的访问控制&lt;/li>
&lt;li>支持速率限制，支持并发数限制&lt;/li>
&lt;/ul>
&lt;h2 id="nginx-架构">Nginx 架构&lt;/h2>
&lt;p>详见 &lt;a href="https://www.yuque.com/go/doc/44635547">Nginx 源码解析模块架构&lt;/a>&lt;/p>
&lt;h2 id="总结">总结&lt;/h2>
&lt;p>看似很复杂，其实总结起来 Nginx 主要就是两个功能，这两个功能也是配置文件中的主要内容，各种指令都离不开这两方面。&lt;/p>
&lt;ol>
&lt;li>定义接收流量的人口(port 或者 域名等)&lt;/li>
&lt;li>定义处理流量的规则(转发或者丢弃等)&lt;/li>
&lt;/ol>
&lt;p>所以，&lt;strong>Nginx 的本质，就是流量处理&lt;/strong>&lt;/p>
&lt;h1 id="nginx-部署">Nginx 部署&lt;/h1>
&lt;h2 id="docker-运行-nginx">docker 运行 Nginx&lt;/h2>
&lt;p>(可选)需要在宿主机的 /etc/nginx 下准备 nginx 的配置文件。这些基本配置文件可以先启动一个 nginx 容器，将容器内的配置文件全部拷贝到宿主机上即可。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>docker run -d --name nginx --network host --restart&lt;span style="color:#f92672">=&lt;/span>always &lt;span style="color:#ae81ff">\
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">&lt;/span> -v /etc/nginx:/etc/nginx:ro &lt;span style="color:#ae81ff">\
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">&lt;/span> nginx:stable-alpine
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>也可以使用自己的配置来运行 nginx&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>mkdir -p /opt/nginx/conf/stream.d
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># 生成配置文件&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>cat &amp;gt; /opt/nginx/conf/nginx.conf &lt;span style="color:#e6db74">&amp;lt;&amp;lt;EOF
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">user nginx;
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">worker_processes auto;
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">error_log /var/log/nginx/error.log warn;
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">pid /var/run/nginx.pid;
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">events {
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74"> worker_connections 1024;
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">}
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">stream {
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74"> include /etc/nginx/stream.d/*.conf;
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">}
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">http {
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">}
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">EOF&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># 运行&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>docker run -d --name nginx --network host --restart&lt;span style="color:#f92672">=&lt;/span>always &lt;span style="color:#ae81ff">\
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">&lt;/span> -v /opt/nginx/conf/stream.d:/etc/nginx/stream.d:ro &lt;span style="color:#ae81ff">\
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">&lt;/span> -v /opt/nginx/conf/nginx.conf:/etc/nginx/nginx.conf:ro &lt;span style="color:#ae81ff">\
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">&lt;/span> nginx:stable-alpine
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>挂载一些静态文件到容器中以响应客户端的 web 请求&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>export StaticFiles&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;/root/projects/DesistDaydream/javascript-learning/9_browser&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>docker run -d --name nginx --network host --restart&lt;span style="color:#f92672">=&lt;/span>always &lt;span style="color:#ae81ff">\
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">&lt;/span> -v &lt;span style="color:#e6db74">${&lt;/span>StaticFiles&lt;span style="color:#e6db74">}&lt;/span>:/usr/share/nginx/html:ro &lt;span style="color:#ae81ff">\
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">&lt;/span> nginx:stable-alpine
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h1 id="nginx-关联文件">Nginx 关联文件&lt;/h1>
&lt;p>&lt;strong>/etc/nginx/*&lt;/strong> # nginx 运行所需配置所在目录&lt;/p>
&lt;ul>
&lt;li>**./nginx.conf **# nginx 主程序运行所读取的默认配置文件。&lt;/li>
&lt;/ul>
&lt;p>配置文件官方介绍：&lt;a href="https://docs.nginx.com/nginx/admin-guide/basic-functionality/managing-configuration-files/">https://docs.nginx.com/nginx/admin-guide/basic-functionality/managing-configuration-files/&lt;/a>&lt;/p>
&lt;p>修改完配置后，可以使用 nginx -s reload 命令使之生效&lt;/p>
&lt;p>下面是 nginx 默认的基本配置示例，可以实现一个简单的 web 服务。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-nginx" data-lang="nginx">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">user&lt;/span> &lt;span style="color:#e6db74">nginx&lt;/span>; &lt;span style="color:#75715e"># 指定以nginx用户来运行nginx进程
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">worker_processes&lt;/span> &lt;span style="color:#e6db74">auto&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">error_log&lt;/span> &lt;span style="color:#e6db74">/var/log/nginx/error.log&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">pid&lt;/span> &lt;span style="color:#e6db74">/run/nginx.pid&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">include&lt;/span> /usr/share/nginx/modules/*.conf; &lt;span style="color:#75715e">#包含/usr/share/nginx/modules/目录下以.conf为结尾的所有文件，加载其中的配置
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">events&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">worker_connections&lt;/span> &lt;span style="color:#ae81ff">1024&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">http&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">log_format&lt;/span> &lt;span style="color:#e6db74">main&lt;/span> &lt;span style="color:#e6db74">&amp;#39;&lt;/span>$remote_addr &lt;span style="color:#e6db74">-&lt;/span> $remote_user &lt;span style="color:#e6db74">[&lt;/span>$time_local] &lt;span style="color:#e6db74">&amp;#34;&lt;/span>$request&amp;#34; &lt;span style="color:#e6db74">&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#39;&lt;/span>$status $body_bytes_sent &lt;span style="color:#e6db74">&amp;#34;&lt;/span>$http_referer&amp;#34; &lt;span style="color:#e6db74">&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#39;&amp;#34;&lt;/span>$http_user_agent&amp;#34; &lt;span style="color:#e6db74">&amp;#34;&lt;/span>$http_x_forwarded_for&amp;#34;&amp;#39;;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">access_log&lt;/span> &lt;span style="color:#e6db74">/var/log/nginx/access.log&lt;/span> &lt;span style="color:#e6db74">main&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">sendfile&lt;/span> &lt;span style="color:#66d9ef">on&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">tcp_nopush&lt;/span> &lt;span style="color:#66d9ef">on&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">tcp_nodelay&lt;/span> &lt;span style="color:#66d9ef">on&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">keepalive_timeout&lt;/span> &lt;span style="color:#ae81ff">65&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">types_hash_max_size&lt;/span> &lt;span style="color:#ae81ff">2048&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">include&lt;/span> &lt;span style="color:#e6db74">/etc/nginx/mime.types&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">default_type&lt;/span> &lt;span style="color:#e6db74">application/octet-stream&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">include&lt;/span> &lt;span style="color:#e6db74">/etc/nginx/conf.d/*.conf&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">server&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">listen&lt;/span> &lt;span style="color:#ae81ff">80&lt;/span> &lt;span style="color:#e6db74">default_server&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">listen&lt;/span> &lt;span style="color:#e6db74">[::]:80&lt;/span> &lt;span style="color:#e6db74">default_server&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">server_name&lt;/span> &lt;span style="color:#e6db74">_&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">root&lt;/span> &lt;span style="color:#e6db74">/usr/share/nginx/html&lt;/span>; &lt;span style="color:#75715e">#指定nginx的工作的/目录。i.e.location中/目录的起始位置
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">include&lt;/span> &lt;span style="color:#e6db74">/etc/nginx/default.d/*.conf&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">location&lt;/span> &lt;span style="color:#e6db74">/&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">error_page&lt;/span> &lt;span style="color:#ae81ff">404&lt;/span> &lt;span style="color:#e6db74">/404.html&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">location&lt;/span> = &lt;span style="color:#e6db74">/40x.html&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">error_page&lt;/span> &lt;span style="color:#ae81ff">500&lt;/span> &lt;span style="color:#ae81ff">502&lt;/span> &lt;span style="color:#ae81ff">503&lt;/span> &lt;span style="color:#ae81ff">504&lt;/span> &lt;span style="color:#e6db74">/50x.html&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">location&lt;/span> = &lt;span style="color:#e6db74">/50x.html&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div></description></item><item><title>Docs: Nginx Unit</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/3.%E9%9B%86%E7%BE%A4%E4%B8%8E%E5%88%86%E5%B8%83%E5%BC%8F/nginx/nginx-unit/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/3.%E9%9B%86%E7%BE%A4%E4%B8%8E%E5%88%86%E5%B8%83%E5%BC%8F/nginx/nginx-unit/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://unit.nginx.org/">官网&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote></description></item><item><title>Docs: Nginx 命令行工具</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/3.%E9%9B%86%E7%BE%A4%E4%B8%8E%E5%88%86%E5%B8%83%E5%BC%8F/nginx/nginx-%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%B7%A5%E5%85%B7/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/3.%E9%9B%86%E7%BE%A4%E4%B8%8E%E5%88%86%E5%B8%83%E5%BC%8F/nginx/nginx-%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%B7%A5%E5%85%B7/</guid><description>
&lt;p>EXAMPLE&lt;/p>
&lt;ul>
&lt;li>
&lt;p>让nginx在前台运行，常用于container中&lt;/p>
&lt;ul>
&lt;li>&lt;strong>nginx -g &amp;lsquo;daemon off;&amp;rsquo;&lt;/strong>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul></description></item><item><title>Docs: Nginx 配置详解</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/3.%E9%9B%86%E7%BE%A4%E4%B8%8E%E5%88%86%E5%B8%83%E5%BC%8F/nginx/nginx-%E9%85%8D%E7%BD%AE%E8%AF%A6%E8%A7%A3/nginx-%E9%85%8D%E7%BD%AE%E8%AF%A6%E8%A7%A3/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/3.%E9%9B%86%E7%BE%A4%E4%B8%8E%E5%88%86%E5%B8%83%E5%BC%8F/nginx/nginx-%E9%85%8D%E7%BD%AE%E8%AF%A6%E8%A7%A3/nginx-%E9%85%8D%E7%BD%AE%E8%AF%A6%E8%A7%A3/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="http://nginx.org/en/docs/beginners_guide.html#conf_structure">org 官方文档,初学者指南-配置文件结构&lt;/a>&lt;/li>
&lt;li>&lt;a href="http://nginx.org/en/docs/dirindex.html">org 官方文档,全部指令列表&lt;/a>&lt;/li>
&lt;li>&lt;a href="http://nginx.org/en/docs/varindex.html">org 官方文档,全部变量列表&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://docs.nginx.com/nginx/admin-guide/basic-functionality/managing-configuration-files/#">官方文档,管理指南-基础功能-创建 NGINX 配置文件&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>Nginx 由 &lt;strong>Modules(模块)&lt;/strong> 组成， Modules 由配置文件中的 **Directives(指令) **控制其运行行为。有的 Directives 可以控制多个模块，只不过在控制不同模块时，产生的效果也许会不尽相同。&lt;/p>
&lt;h2 id="directives指令">Directives(指令)&lt;/h2>
&lt;p>Directives(指令) 分为如下几种：&lt;/p>
&lt;ul>
&lt;li>Simple Directives(简单指令)&lt;/li>
&lt;li>Block Directives(块指令)&lt;/li>
&lt;li>Conexts(配置环境 | 上下文)&lt;/li>
&lt;/ul>
&lt;h3 id="simple-directives简单指令">Simple Directives(简单指令)&lt;/h3>
&lt;p>由空格分割的 &lt;strong>Name(指令名称)&lt;/strong> 和 &lt;strong>Parameters(指令参数)&lt;/strong>，以 &lt;code>;&lt;/code> 符号结尾。&lt;/p>
&lt;ul>
&lt;li>如果从 Nginx 的代码角度看，指令就相当于结构体中的属性，参数就是该属性的值。&lt;/li>
&lt;/ul>
&lt;h3 id="block-directives块指令">Block Directives(块指令)&lt;/h3>
&lt;p>将多个相关的简单指令组合在一起的容器，并将它们用 &lt;code>{}&lt;/code> 符号包围起来。&lt;/p>
&lt;h3 id="top-level-directives顶级指令--也称为-contexts配置环境--上下文">Top Level Directives(顶级指令) # 也称为 Contexts(配置环境 | 上下文)。&lt;/h3>
&lt;p>将多个相关的 块指令 和 简单指令 组合在一起的指令。一共分为 4 类 Contexts：&lt;/p>
&lt;ul>
&lt;li>[&lt;strong>events {}&lt;/strong>](✏IT 学习笔记/✨3.集群与分布式/Nginx/Nginx%20 配置详解/events%20 模块指令.md 配置详解/events 模块指令.md)** **# 用于配置如何处理常规连接。&lt;/li>
&lt;li>[&lt;strong>http {}&lt;/strong>](✏IT 学习笔记/✨3.集群与分布式/Nginx/Nginx%20 配置详解/http%20 模块指令.md 配置详解/http 模块指令.md)** **# http 流量处理配置，通常用来配置 7 层代理。由 ngx_http_core_module 模块处理其中配置&lt;/li>
&lt;li>**mail {} **# mail 流量处理配置。由 ngx_mail_core_module 模块处理其中配置&lt;/li>
&lt;li>[&lt;strong>stream {}&lt;/strong>](✏IT 学习笔记/✨3.集群与分布式/Nginx/Nginx%20 配置详解/core%20 模块指令.md 配置详解/core 模块指令.md)** **# TCP 和 UDP 流量处理配置，通常用来配置 4 层代理。由 ngx_stream_core_module 模块处理其中配置&lt;/li>
&lt;/ul>
&lt;p>[&lt;strong>main&lt;/strong>](✏IT 学习笔记/✨3.集群与分布式/Nginx/Nginx%20 配置详解/core%20 模块指令.md 配置详解/core 模块指令.md) # 如果某些指令在上述 4 类 Contexts 之外，则称之为 main Context。可以说，events{}、http{}、mail{}、stream{} 四个 Contexts，都属于 main 上下文中的指令。说白了，main 上下文就是 Nginx 的配置文件~~~其实，main 就是指最顶层的 core 模块指令&lt;/p>
&lt;p>每一个 Context 类型的指令都对应控制一个 NGX_CORE_MODULE 类型的模块&lt;/p>
&lt;ul>
&lt;li>main 指令 —&amp;gt; 控制 core 模块&lt;/li>
&lt;li>events {} 指令 —&amp;gt; 控制 events 模块&lt;/li>
&lt;li>http {} 指令 —&amp;gt; 控制 http 模块&lt;/li>
&lt;li>mail {} 指令 —&amp;gt; 控制 mail 模块&lt;/li>
&lt;li>stream {} 指令 —&amp;gt; 控制 stream 模块&lt;/li>
&lt;/ul>
&lt;p>所以，配置文件的格式实际上也是一个树状结构：
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/tt8mpd/1619841196176-fa5e09e5-44b9-49e2-bdc3-bccc385d0218.png" alt="树形结构.png">
最顶层的 main 指令，包含 简单指令 和 4 个 Contexts，每个 Context 又包含 简单指令/块指令。&lt;/p>
&lt;h2 id="inheritance继承">Inheritance(继承)&lt;/h2>
&lt;p>通常，子块指令 将会继承其 父块指令 中的指令设置。某些 简单指令 可以出现在多个 块指令 中，这种情况下，可以通过在 子块指令 中设置该 简单指令，以便覆盖其从 父块指令 中继承过来的设置。&lt;/p>
&lt;h2 id="variables变量">Variables(变量)&lt;/h2>
&lt;p>在 Nginx 的配置文件中，还可以设置并引用变量，通过 &lt;code>set&lt;/code> 指令，可以定义一个变量，并在其他指令中使用 &lt;code>$变量名&lt;/code> 引用变量。同样，也有环境变量的概念，Nginx 的很多模块在加载并时候后，会产生环境变量，也可以直接引用&lt;/p>
&lt;p>变量最常用的地方就是通过 &lt;code>log_format&lt;/code> 指令定义日志内容~~&lt;/p>
&lt;h2 id="基本配置示例">基本配置示例&lt;/h2>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-nginx" data-lang="nginx">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># 在 4 种配置环境之外的指令属于 main 配置环境，一般用于配置 nginx 运行的基础信息
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">user&lt;/span> &lt;span style="color:#e6db74">nobody&lt;/span>; &lt;span style="color:#75715e"># 这是一个 main context 中的指令
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># 事件配置环境。用于配置连接参数等信息
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">events&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e"># 关于连接处理的配置
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># http 流量处理配置环境
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">http&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e"># 影响所有 virtual servers 的 http 流量的配置
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#f92672">server&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">server_name&lt;/span> &lt;span style="color:#e6db74">localhost&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e"># 配置处理 http 流量的 Virtual Server 1
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#f92672">location&lt;/span> &lt;span style="color:#e6db74">/one&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e"># 配置用于处理以&amp;#39;/one&amp;#39;开头的URI的流量
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">location&lt;/span> &lt;span style="color:#e6db74">/two&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e"># 配置用于处理以&amp;#39;/two&amp;#39;开头的URI的流量
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">server&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e"># 配置处理 http 流量的 Virtual Server 2
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># mail 流量处理环境
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">mail&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">....&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#960050;background-color:#1e0010">}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># TCP 和 UDP 流量处理配置环境
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#e6db74">stream&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e"># 影响所有 virtual servers 的 TCP/UDP 流量的配置
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#f92672">server&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">#配置处理 TCP 流量的 Virtual Server 1
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Note：&lt;/p>
&lt;ol>
&lt;li>通常 &lt;code>{}&lt;/code> 中的指令只对大括号内部内容生效；不在 &lt;code>{}&lt;/code> 中且在文件开头的，则对全局生效；配置指令要以分号结尾&lt;/li>
&lt;li>配置技巧：为了使配置更易于维护，还可以将大段的配置拆分为一组一组存储在 /etc/nginx/conf.d/ 目录下的文件，并在 nginx.conf 这个主配置文件中使用 &lt;code>include&lt;/code> 指令来引用这些文件。&lt;/li>
&lt;/ol>
&lt;h2 id="总结">总结&lt;/h2>
&lt;p>其实，Nginx 的配置本质就是对模块的配置，这些指令就是模块可以接收的形参；而指令的值就是代码中，应该给模块传递的实参。&lt;/p>
&lt;p>而 Nginx 配置文件的组织结构更像 INI 格式的配置文件，Nginx 的 顶级指令就是 Selections(部分) 的概念；简单指令就是 Key/Value Pairs(键/值对) 的概念；块指令其实就是一种嵌套形式的简单指令。&lt;/p>
&lt;h1 id="配置文件详解">配置文件详解&lt;/h1>
&lt;p>本质上，Nginx 的配置文件，就是由 &lt;strong>Directives(指令)&lt;/strong> 与 &lt;strong>Contexts(配置环境 | 上下文)&lt;/strong> 组成，而这些指令和配置环境，又是围绕 Virtual Servers 运转。&lt;/p>
&lt;h2 id="virtual-servers虚拟主机-抽象概念">Virtual Servers(虚拟主机) 抽象概念&lt;/h2>
&lt;p>**Virtual Servers(虚拟主机) **是 Nginx 的抽象概念，Virtual Servers 用来定义 **流量入口 **和 &lt;strong>流量处理&lt;/strong>。而这两块功能也是 Nginx 正常工作的最基本功能。&lt;/p>
&lt;h3 id="流量入口">流量入口&lt;/h3>
&lt;p>流量入口包括监听的地址、域名等。对于发送到 Nginx 的流量，根据流量中的内容，分配到不同的入口，进行后续流量处理。&lt;/p>
&lt;h3 id="流量处理">流量处理&lt;/h3>
&lt;p>流量处理包括将流量代理到何处、是否丢弃、连接超时时长等。&lt;/p>
&lt;h4 id="后端服务器">后端服务器&lt;/h4>
&lt;p>由于流量处理需要将流量代理到指定的服务器，所以还需要配置后端服务器来接收流量。&lt;/p>
&lt;h2 id="总结-1">总结&lt;/h2>
&lt;p>Virtual Server 的概念，通过 **&lt;code>server{}&lt;/code> **指令来实现。在每个流量处理的配置环境中，都应该包含一个或多个 server{} 指令。server{} 指令是 nginx 正常运行的基础配置。虚拟主机，顾名思义，对于用户来说，访问的就是一台一台服务器，但是对于 nginx 来说，是虚拟出来的。&lt;/p>
&lt;ol>
&lt;li>&lt;strong>对于 http 流量(http 配置环境)&lt;/strong> # 每个 &lt;code>server{} 指令块&lt;/code> 控制访问特定域名或者 ip 地址上对资源请求的处理。server 指令块中的一个或多个 location 指令块定义了根据 URI 来处理流量的规则
&lt;ol>
&lt;li>比如用户访问 map.baidu.com 和 baike.baidu.com。看上去是访问了两台服务器，但是实际上，这是经过作为代理设备的 ngxin 来进行选择后的虚拟服务器。一般情况下，baike.baidu.com 与 map.baidu.com 这俩域名所解析出来的 ip 应该是同一个公网 ip(比如 123.123.123.123)(baidu 有钱用很多公网 IP 除外)。所以可以想到，用户在浏览器输入任何一个域名，访问请求都会来到 123.123.123.123，然后根据请求报文中的 Request-URL 字段中的域名与 server_name 进行配对，用户输入的 URL 中域名与哪个 server_name 相同，则该请求就会通过这个 server 来进行处理，然后根据该 server 中 location 的关键字来决定把改请求转发给哪里。&lt;/li>
&lt;/ol>
&lt;/li>
&lt;li>&lt;strong>mail 和 TCP/UDP 流量(mail 和 stream 配置环境)&lt;/strong> # 每个 &lt;code>server{} 指令块&lt;/code> 控制处理到达指定 TCP port 或 UNIX socket 的流量。
&lt;ol>
&lt;li>比如用户访问 30000 端口，则可以根据其中的规则，将 对 30000 端口发起的请求，代理到其他设备的某些端口上。&lt;/li>
&lt;/ol>
&lt;/li>
&lt;/ol>
&lt;p>其实说白了，每个 Virtual Server 都相当于一个独立运行的服务，用来处理客户端的请求。具体如何处理，则在每个 server{} 指令块中定义。可以这么说，Nginx 中所有指令，其实都是为 Virtual Servers 服务的。&lt;/p>
&lt;h1 id="指令详解">指令详解&lt;/h1>
&lt;h2 id="main-模块指令it-学习笔记3集群与分布式nginxnginx20-配置详解core20-模块指令md-配置详解core-模块指令md">[main 模块指令](✏IT 学习笔记/✨3.集群与分布式/Nginx/Nginx%20 配置详解/core%20 模块指令.md 配置详解/core 模块指令.md)**&lt;/h2>
&lt;h2 id="events-模块指令it-学习笔记3集群与分布式nginxnginx20-配置详解events20-模块指令md-配置详解events-模块指令md">[events 模块指令](✏IT 学习笔记/✨3.集群与分布式/Nginx/Nginx%20 配置详解/events%20 模块指令.md 配置详解/events 模块指令.md)&lt;/h2>
&lt;p>[http 模块指令](✏IT 学习笔记/✨3.集群与分布式/Nginx/Nginx%20 配置详解/http%20 模块指令.md 配置详解/http 模块指令.md)&lt;/p>
&lt;p>常用来配置七层代理、web 应用&lt;/p>
&lt;h2 id="mail-模块指令">mail 模块指令&lt;/h2>
&lt;p>[stream 模块指令](✏IT 学习笔记/✨3.集群与分布式/Nginx/Nginx%20 配置详解/stream%20 模块指令.md 配置详解/stream 模块指令.md)&lt;/p>
&lt;p>常用来配置四层代理&lt;/p></description></item><item><title>Docs: Nginx 优化</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/3.%E9%9B%86%E7%BE%A4%E4%B8%8E%E5%88%86%E5%B8%83%E5%BC%8F/nginx/nginx-%E4%BC%98%E5%8C%96/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/3.%E9%9B%86%E7%BE%A4%E4%B8%8E%E5%88%86%E5%B8%83%E5%BC%8F/nginx/nginx-%E4%BC%98%E5%8C%96/</guid><description>
&lt;ol>
&lt;li>性能优化的相关配置
&lt;ol>
&lt;li>work_processes NUM; #常用，指定 work 线程个数，通常应该少于 cpu 物理核心数，设为 auto 为自动判断&lt;/li>
&lt;li>work_cpu_affinity CpuMask; #常用，设定 cpu 掩码，用于绑定给 nginx 专用的 cpu 数&lt;/li>
&lt;li>timer_resolution Num; #计时器解析度，降低此值，可提高性能&lt;/li>
&lt;li>worker_priority NUM; #设定优先级，即 worker 线程的 nice 值&lt;/li>
&lt;/ol>
&lt;/li>
&lt;li>事件相关配置
&lt;ol>
&lt;li>worker_connections NUM; #常用，指定每个 worker 线程所能处理的最大并发连接数&lt;/li>
&lt;li>accept_mutex on|off; #调度用户请求至 worker 线程时使用的负载均衡锁。on 是让多个 worker 轮流的，序列化地响应新请求&lt;/li>
&lt;li>lock_file /PATH/FILE; #指定 accept_mutex 开启后用到的锁文件路径&lt;/li>
&lt;/ol>
&lt;/li>
&lt;li>用于调试、定位问题的配置
&lt;ol>
&lt;li>daemon on|off； #是否以守护进程方式运行 nginx，调试时设置为 off&lt;/li>
&lt;li>master_process on|off； #是否以 master/worker 模式来运行 ngins，调试时可以设置为 off&lt;/li>
&lt;/ol>
&lt;/li>
&lt;/ol>
&lt;h3 id="heading">&lt;/h3>
&lt;h3 id="优化-nginx-数据包头缓存">优化 Nginx 数据包头缓存&lt;/h3>
&lt;p>1）优化前，使用脚本测试长头部请求是否能获得响应&lt;/p>
&lt;pre>&lt;code>[root@proxy ~]# cat lnmp_soft/buffer.sh
#!/bin/bash
URL=http://192.168.4.5/index.html?
for i in {1..5000}
do
URL=${URL}v$i=$i
done
curl $URL //经过5000次循环后，生成一个长的URL地址栏
[root@proxy ~]# ./buffer.sh
.. ..
&amp;lt;center&amp;gt;&amp;lt;h1&amp;gt;414 Request-URI Too Large&amp;lt;/h1&amp;gt;&amp;lt;/center&amp;gt; //提示头部信息过大
&lt;/code>&lt;/pre>
&lt;p>2）修改 Nginx 配置文件，增加数据包头部缓存大小&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-nginx" data-lang="nginx">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># vim /usr/local/nginx/conf/nginx.conf
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">...&lt;/span> &lt;span style="color:#e6db74">..&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">http&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">client_header_buffer_size&lt;/span> &lt;span style="color:#ae81ff">1k&lt;/span>; &lt;span style="color:#f92672">//&lt;/span> &lt;span style="color:#e6db74">默认请求包头信息的缓存&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">large_client_header_buffers&lt;/span> &lt;span style="color:#ae81ff">4&lt;/span> &lt;span style="color:#ae81ff">4k&lt;/span>; &lt;span style="color:#f92672">//&lt;/span> &lt;span style="color:#e6db74">大请求包头部信息的缓存个数与容量&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">..&lt;/span> &lt;span style="color:#e6db74">..&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#960050;background-color:#1e0010">}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># /usr/local/nginx/sbin/nginx -s reload
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>3）优化后，使用脚本测试长头部请求是否能获得响应&lt;/p>
&lt;pre>&lt;code>1.[root@proxy ~]# cat buffer.sh
2.#!/bin/bash
3.URL=http://192.168.4.5/index.html?
4.for i in {1..5000}
5.do
6. URL=${URL}v$i=$i
7.done
8.curl $URL
9.[root@proxy ~]# ./buffer.sh
&lt;/code>&lt;/pre>
&lt;h3 id="浏览器本地缓存静态数据">浏览器本地缓存静态数据&lt;/h3>
&lt;p>1）使用 Firefox 浏览器查看缓存
以 Firefox 浏览器为例，在 Firefox 地址栏内输入 about:cache 将显示 Firefox 浏览器的缓存信息，如图所示，点击 List Cache Entries 可以查看详细信息。
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/bzuh2e/1621231619142-0d5c79d5-689e-48b4-9b82-2e6fd6450a02.webp" alt="">
2）清空 firefox 本地缓存数据，如图所示。
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/bzuh2e/1621231619179-e56a8fb4-8a7c-4e06-afe1-6bb66fe30d1b.webp" alt="">
3）改 Nginx 配置文件，定义对静态页面的缓存时间&lt;/p>
&lt;pre>&lt;code># vim /usr/local/nginx/conf/nginx.conf
server {
listen 80;
server_name localhost;
location / {
root html;
index index.html index.htm;
}
location ~* \.(jpg|jpeg|gif|png|css|js|ico|xml)$ {
expires 30d; //定义客户端缓存时间为30天
}
}
# cp /usr/share/backgrounds/day.jpg /usr/local/nginx/html
# /usr/local/nginx/sbin/nginx -s reload
#请先确保nginx是启动状态，否则运行该命令会报错,报错信息如下：16.#[error] open() &amp;quot;/usr/local/nginx/logs/nginx.pid&amp;quot; failed (2: No such file or directory)
&lt;/code>&lt;/pre>
&lt;p>4）优化后，使用 Firefox 浏览器访问图片，再次查看缓存信息&lt;/p>
&lt;pre>&lt;code># firefox http://192.168.4.5/day.jpg
&lt;/code>&lt;/pre>
&lt;p>在 firefox 地址栏内输入 about:cache，查看本地缓存数据，查看是否有图片以及过期时间是否正确。&lt;/p></description></item><item><title>Docs: Nginx 源码解析</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/3.%E9%9B%86%E7%BE%A4%E4%B8%8E%E5%88%86%E5%B8%83%E5%BC%8F/nginx/nginx-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/3.%E9%9B%86%E7%BE%A4%E4%B8%8E%E5%88%86%E5%B8%83%E5%BC%8F/nginx/nginx-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;p>Nginx 的架构设计是高度模块化的，从 Nginx 的源码目录与 Nginx 模块化及其功能的划分是紧密结合的。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>root@lichenhao:~/projects/someone_else/nginx# tree -d
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>.
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>├── auto
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>├── conf
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>├── contrib
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>├── docs
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>├── misc
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>└── src
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ├── core
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ├── event
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> │   └── modules
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ├── http
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> │   ├── modules
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> │   │   └── perl
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> │   └── v2
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ├── mail
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ├── misc
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ├── os
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> │   ├── unix
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> │   └── win32
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> └── stream
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>每个模块必须要具备 &lt;code>ngx_module_t&lt;/code> 这个数据结构，比如 src/core/nginx.c 文件中，在 ngx_module_t 数据结构中，定义了 ngx_core_module 模块&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-c" data-lang="c">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">ngx_module_t&lt;/span> ngx_core_module &lt;span style="color:#f92672">=&lt;/span> { &lt;span style="color:#75715e">// 定义模块名称为 ngx_core_module
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> NGX_MODULE_V1,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;amp;&lt;/span>ngx_core_module_ctx, &lt;span style="color:#75715e">/* module context */&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// ngx_core_commands 是该模块的指令，这里一般会定义一个数组，数组中每个元素就是一个指令
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> ngx_core_commands, &lt;span style="color:#75715e">/* module directives */&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// NGX_CORE_MODULE 是该模块的类型
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> NGX_CORE_MODULE, &lt;span style="color:#75715e">/* module type */&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> NULL, &lt;span style="color:#75715e">/* init master */&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> NULL, &lt;span style="color:#75715e">/* init module */&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> NULL, &lt;span style="color:#75715e">/* init process */&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> NULL, &lt;span style="color:#75715e">/* init thread */&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> NULL, &lt;span style="color:#75715e">/* exit thread */&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> NULL, &lt;span style="color:#75715e">/* exit process */&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> NULL, &lt;span style="color:#75715e">/* exit master */&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> NGX_MODULE_V1_PADDING
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>};
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>再看 src/http/ngx_http.c 文件&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-c" data-lang="c">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">ngx_module_t&lt;/span> ngx_http_module &lt;span style="color:#f92672">=&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> NGX_MODULE_V1,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;amp;&lt;/span>ngx_http_module_ctx, &lt;span style="color:#75715e">/* module context */&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ngx_http_commands, &lt;span style="color:#75715e">/* module directives */&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// ngx_http_module 模块属于 NGX_CORE_MODULE 类型
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> NGX_CORE_MODULE, &lt;span style="color:#75715e">/* module type */&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> NULL, &lt;span style="color:#75715e">/* init master */&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> NULL, &lt;span style="color:#75715e">/* init module */&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> NULL, &lt;span style="color:#75715e">/* init process */&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> NULL, &lt;span style="color:#75715e">/* init thread */&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> NULL, &lt;span style="color:#75715e">/* exit thread */&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> NULL, &lt;span style="color:#75715e">/* exit process */&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> NULL, &lt;span style="color:#75715e">/* exit master */&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> NGX_MODULE_V1_PADDING
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>};
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>http 模块属于 NGX_CORE_MODULE 类型如果看 src/stream/ngx_stream.c、src/event/ngx_event.src、src/mail/ngx_mail_module.c 这三个文件，里面都有类似的定义&lt;/p>
&lt;p>最后看 src/http/modules/ 目录，这里就是都有属于 NGX_HTTP_MODULE 模块的子模块。定义方式类似。&lt;/p>
&lt;h1 id="总结">总结&lt;/h1>
&lt;p>所以，从代码结构可以看出来，Nginx 模块定义了如下几大类型，并且每一类模块包含不同的模块&lt;/p>
&lt;ul>
&lt;li>&lt;strong>NGX_CORE_MODULE&lt;/strong>&lt;/li>
&lt;li>&lt;strong>NGX_EVENT_MODULE&lt;/strong>&lt;/li>
&lt;li>&lt;strong>NGX_HTTP_MODULE&lt;/strong>&lt;/li>
&lt;li>&lt;strong>NGX_MAIL_MODULE&lt;/strong>&lt;/li>
&lt;li>&lt;strong>NGX_STREAM_MODULE&lt;/strong>&lt;/li>
&lt;/ul>
&lt;p>与此同时，每种类型的模块下，包含很多子模块，模块类型是抽象的概念，主要是为了帮助模块进行分类。而模块，则是真正处理任务的：&lt;/p>
&lt;ul>
&lt;li>&lt;strong>NGX_CORE_MODULE&lt;/strong>
&lt;ul>
&lt;li>ngx_core_module # core 模块，这个比较特殊，core 模块类型下，其实就是包含了一个 core 模块。&lt;/li>
&lt;li>ngx_event_module # event 模块&lt;/li>
&lt;li>ngx_http_module # http 模块&lt;/li>
&lt;li>ngx_mail_module # mail 模块&lt;/li>
&lt;li>ngx_stream_module # stream 模块&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>NGX_EVENT_MODULE&lt;/strong>
&lt;ul>
&lt;li>ngx_event_core_module # event core 模块&lt;/li>
&lt;li>&amp;hellip;&amp;hellip; 太多了就不一一列举了，详见官网&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>NGX_HTTP_MODULE&lt;/strong>
&lt;ul>
&lt;li>ngx_http_core_module # http core 模块&lt;/li>
&lt;li>&amp;hellip;&amp;hellip; 太多了就不一一列举了，详见官网&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>NGX_MAIL_MODULE&lt;/strong>
&lt;ul>
&lt;li>ngx_mail_module # mail core 模块&lt;/li>
&lt;li>&amp;hellip;&amp;hellip; 太多了就不一一列举了，详见官网&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>NGX_STREAM_MODULE&lt;/strong>
&lt;ul>
&lt;li>ngx_stream_module # stream core 模块&lt;/li>
&lt;li>&amp;hellip;&amp;hellip; 太多了就不一一列举了，详见官网&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>从上面的分类也可以看出来，每个类型的模块都有一个被称为 core 的模块来实现这个类型的功能。这其实就可以组成一个树状的结构：
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/eygybr/1619798135171-e81a3491-2566-4f50-ab0f-4b0868a5670e.png" alt="image.png">这个图不太好，有机会自己画一个。&lt;/p>
&lt;p>画成图就是这个样子的：
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/eygybr/1619768579247-4047676f-2ece-4b9c-bed2-7d53d7f32ae4.png" alt="image.png">
就像 &lt;a href="http://nginx.org/en/docs/">官方文档的模块参考&lt;/a> 页面一样，我们可以看到下面这样的命名规则 &lt;code>ngx_XXX_YYY_module&lt;/code>。其中 XXX 就是顶级模块名，YYY 就是属于 XXX 模块的次级模块名。效果如下：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># 包含 core 和 event 模块&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Core functionality
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># http 模块&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>ngx_http_core_module
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>ngx_http_access_module
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>ngx_http_addition_module
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>......
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># mail 模块&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>ngx_mail_core_module
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>ngx_mail_auth_http_module
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>......
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># stream 模块&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>ngx_stream_core_module
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>ngx_stream_access_module
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>ngx_stream_geo_module
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>......
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Nginx 通过这种架构，将各个模块组织成一条链，当有请求到达时，请求依次经过这条链上的部分或者全部模块，进行处理。每个模块实现特定的功能。&lt;/p>
&lt;p>而这些模块的运行行为，就是通过配置文件中的 [&lt;strong>Directive(指令)&lt;/strong>](✏IT 学习笔记/✨3.集群与分布式/Nginx/Nginx%20 配置详解/Nginx%20 配置详解.md 配置详解.md) 实现的。一般每个顶级模块都有一个同名的 顶级指令，比如 http 模块对应 http{} 顶级指令。&lt;/p>
&lt;p>Nginx 模块的架构，也使得 Nginx 实现了灵活得可扩展性。&lt;/p></description></item><item><title>Docs: Nginx 作为web服务器配置示例</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/3.%E9%9B%86%E7%BE%A4%E4%B8%8E%E5%88%86%E5%B8%83%E5%BC%8F/nginx/nginx-%E9%85%8D%E7%BD%AE%E8%AF%A6%E8%A7%A3/nginx-%E4%BD%9C%E4%B8%BAweb%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%85%8D%E7%BD%AE%E7%A4%BA%E4%BE%8B/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/3.%E9%9B%86%E7%BE%A4%E4%B8%8E%E5%88%86%E5%B8%83%E5%BC%8F/nginx/nginx-%E9%85%8D%E7%BD%AE%E8%AF%A6%E8%A7%A3/nginx-%E4%BD%9C%E4%B8%BAweb%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%85%8D%E7%BD%AE%E7%A4%BA%E4%BE%8B/</guid><description>
&lt;h1 id="nginx-的-location-里面的-rootalias-的使用技巧与区别">Nginx 的 location 里面的 root、alias 的使用技巧与区别&lt;/h1>
&lt;blockquote>
&lt;p>知乎：&lt;a href="https://zhuanlan.zhihu.com/p/379076598">https://zhuanlan.zhihu.com/p/379076598&lt;/a>&lt;/p>
&lt;/blockquote>
&lt;h2 id="location">location&lt;/h2>
&lt;p>Nginx 里面的 location，可以针对一个特殊的 URI 路径进行单独的设置。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-javascript" data-lang="javascript">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">location&lt;/span> &lt;span style="color:#f92672">/&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">root&lt;/span> &lt;span style="color:#f92672">/&lt;/span>&lt;span style="color:#a6e22e">tongfu&lt;/span>.&lt;span style="color:#a6e22e">net&lt;/span>&lt;span style="color:#f92672">/&lt;/span>&lt;span style="color:#a6e22e">web&lt;/span>&lt;span style="color:#f92672">/&lt;/span>&lt;span style="color:#66d9ef">static&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>在 location 块里面可以单独设置映射目录、重写逻辑、默认文档等等。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-javascript" data-lang="javascript">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">location&lt;/span> &lt;span style="color:#f92672">/&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">root&lt;/span> &lt;span style="color:#f92672">/&lt;/span>&lt;span style="color:#a6e22e">tongfu&lt;/span>.&lt;span style="color:#a6e22e">net&lt;/span>&lt;span style="color:#f92672">/&lt;/span>&lt;span style="color:#a6e22e">web&lt;/span>&lt;span style="color:#f92672">/&lt;/span>&lt;span style="color:#a6e22e">download&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">index&lt;/span> &lt;span style="color:#a6e22e">index&lt;/span>.&lt;span style="color:#a6e22e">htm&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">location&lt;/span> &lt;span style="color:#f92672">~&lt;/span> &lt;span style="color:#f92672">^&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">\&lt;/span>&lt;span style="color:#f92672">/&lt;/span>&lt;span style="color:#a6e22e">download&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">\&lt;/span>&lt;span style="color:#f92672">/&lt;/span>.&lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">\&lt;/span>.(&lt;span style="color:#a6e22e">zip&lt;/span>&lt;span style="color:#f92672">|&lt;/span>&lt;span style="color:#a6e22e">rar&lt;/span>&lt;span style="color:#f92672">|&lt;/span>&lt;span style="color:#a6e22e">tgz&lt;/span>&lt;span style="color:#f92672">|&lt;/span>&lt;span style="color:#a6e22e">gz&lt;/span>)&lt;span style="color:#a6e22e">$&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">rewrite&lt;/span> &lt;span style="color:#f92672">^&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">\&lt;/span>&lt;span style="color:#f92672">/&lt;/span>&lt;span style="color:#a6e22e">download&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">\&lt;/span>&lt;span style="color:#f92672">/&lt;/span>(.&lt;span style="color:#f92672">*&lt;/span>)&lt;span style="color:#a6e22e">$&lt;/span> &lt;span style="color:#f92672">/&lt;/span>&lt;span style="color:#a6e22e">downloadValidation&lt;/span>.&lt;span style="color:#a6e22e">php&lt;/span>&lt;span style="color:#f92672">?&lt;/span>&lt;span style="color:#a6e22e">$1&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="root">root&lt;/h2>
&lt;p>Nginx 里面的 root 参数用来指定映射根目录，末尾不加“/”。&lt;/p>
&lt;h3 id="主机默认目录">主机默认目录&lt;/h3>
&lt;p>直接在 server 里面设置 root 就是设置主机的根目录。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-javascript" data-lang="javascript">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">server&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">root&lt;/span> &lt;span style="color:#f92672">/&lt;/span>&lt;span style="color:#a6e22e">tongfu&lt;/span>.&lt;span style="color:#a6e22e">net&lt;/span>&lt;span style="color:#f92672">/&lt;/span>&lt;span style="color:#a6e22e">web&lt;/span>&lt;span style="color:#f92672">/&lt;/span>&lt;span style="color:#66d9ef">static&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="匹配-uri-目录">匹配 URI 目录&lt;/h3>
&lt;p>在 location 里面设置 root 就是设置匹配 URI 的根目录。
下面的例子里如果访问 &lt;a href="https://link.zhihu.com/?target=http%3A//localhost/icon/abc.png">http://localhost/icon/abc.png&lt;/a> 网址，映射到的服务器路径是 /tongfu.net/web/icons**/icon/abc.png**。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-javascript" data-lang="javascript">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">location&lt;/span> &lt;span style="color:#f92672">/&lt;/span>&lt;span style="color:#a6e22e">icon&lt;/span>&lt;span style="color:#f92672">/&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">root&lt;/span> &lt;span style="color:#f92672">/&lt;/span>&lt;span style="color:#a6e22e">tongfu&lt;/span>.&lt;span style="color:#a6e22e">net&lt;/span>&lt;span style="color:#f92672">/&lt;/span>&lt;span style="color:#a6e22e">web&lt;/span>&lt;span style="color:#f92672">/&lt;/span>&lt;span style="color:#a6e22e">icons&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="alias">alias&lt;/h2>
&lt;p>Nginx 里面的 root 参数用来指定映射目录，末尾需要加“/”。
下面的例子里如果访问 &lt;a href="https://link.zhihu.com/?target=http%3A//localhost/icon/abc.png">http://localhost/icon/abc.png&lt;/a> 网址，映射到的服务器路径是 /tongfu.net/web/icons/&lt;strong>abc.png&lt;/strong>。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-javascript" data-lang="javascript">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">location&lt;/span> &lt;span style="color:#f92672">/&lt;/span>&lt;span style="color:#a6e22e">icon&lt;/span>&lt;span style="color:#f92672">/&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">alias&lt;/span> &lt;span style="color:#f92672">/&lt;/span>&lt;span style="color:#a6e22e">tongfu&lt;/span>.&lt;span style="color:#a6e22e">net&lt;/span>&lt;span style="color:#f92672">/&lt;/span>&lt;span style="color:#a6e22e">web&lt;/span>&lt;span style="color:#f92672">/&lt;/span>&lt;span style="color:#a6e22e">icons&lt;/span>&lt;span style="color:#f92672">/&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h1 id="nginx-代理-vue-项目的单页应用刷新后-404-问题">Nginx 代理 Vue 项目的单页应用刷新后 404 问题&lt;/h1>
&lt;p>在 location 中添加 &lt;code>try_files $uri $uri/ /index.html;&lt;/code>&lt;/p></description></item><item><title>Docs: Nginx 作为代理服务器配置示例</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/3.%E9%9B%86%E7%BE%A4%E4%B8%8E%E5%88%86%E5%B8%83%E5%BC%8F/nginx/nginx-%E9%85%8D%E7%BD%AE%E8%AF%A6%E8%A7%A3/nginx-%E4%BD%9C%E4%B8%BA%E4%BB%A3%E7%90%86%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%85%8D%E7%BD%AE%E7%A4%BA%E4%BE%8B/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/3.%E9%9B%86%E7%BE%A4%E4%B8%8E%E5%88%86%E5%B8%83%E5%BC%8F/nginx/nginx-%E9%85%8D%E7%BD%AE%E8%AF%A6%E8%A7%A3/nginx-%E4%BD%9C%E4%B8%BA%E4%BB%A3%E7%90%86%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%85%8D%E7%BD%AE%E7%A4%BA%E4%BE%8B/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://mp.weixin.qq.com/s/27IuQAe8UZGXIdNApE2Ljg">公众号，Nginx 代理 WebSocket 方法&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;h1 id="7-层代理配置">7 层代理配置&lt;/h1>
&lt;p>这个配置里的 172.19.42.217 是 kubernetes 集群的入口，一般在 80 和 443 上都起一个 ingress controler，这样，多种域名都代理到同一个 kubernetes 集群，然后由 ingress 再将流量进行路由分配。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-nginx" data-lang="nginx">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">user&lt;/span> &lt;span style="color:#e6db74">nginx&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">worker_processes&lt;/span> &lt;span style="color:#ae81ff">4&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">error_log&lt;/span> &lt;span style="color:#e6db74">/dev/stdout&lt;/span> &lt;span style="color:#e6db74">warn&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">pid&lt;/span> &lt;span style="color:#e6db74">/var/run/nginx.pid&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">events&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">worker_connections&lt;/span> &lt;span style="color:#ae81ff">102400&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">http&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">default_type&lt;/span> &lt;span style="color:#e6db74">application/octet-stream&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">access_log&lt;/span> &lt;span style="color:#e6db74">/dev/stdout&lt;/span> &lt;span style="color:#e6db74">main&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">keepalive_timeout&lt;/span> &lt;span style="color:#ae81ff">120&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">log_format&lt;/span> &lt;span style="color:#e6db74">main&lt;/span> &lt;span style="color:#e6db74">&amp;#39;&lt;/span>$remote_addr &lt;span style="color:#e6db74">-&lt;/span> $remote_user &lt;span style="color:#e6db74">[&lt;/span>$time_local] &lt;span style="color:#e6db74">&amp;#34;&lt;/span>$request&amp;#34; &lt;span style="color:#e6db74">&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#39;&lt;/span>$status $body_bytes_sent &lt;span style="color:#e6db74">&amp;#34;&lt;/span>$http_referer&amp;#34; &lt;span style="color:#e6db74">&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#39;&amp;#34;&lt;/span>$http_user_agent&amp;#34; &lt;span style="color:#e6db74">&amp;#34;&lt;/span>$http_x_forwarded_for&amp;#34;&amp;#39;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#39;&lt;/span>$upstream_addr &lt;span style="color:#e6db74">&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#39;ups_resp_time:&lt;/span> $upstream_response_time &lt;span style="color:#e6db74">&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#39;request_time:&lt;/span> $request_time&amp;#39;;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">sendfile&lt;/span> &lt;span style="color:#66d9ef">on&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">server_names_hash_bucket_size&lt;/span> &lt;span style="color:#ae81ff">256&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">server&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">listen&lt;/span> &lt;span style="color:#ae81ff">80&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">server_name&lt;/span> &lt;span style="color:#e6db74">grafana.desistdaydream.ltd&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">server_name&lt;/span> &lt;span style="color:#e6db74">prometheus.desistdaydream.ltd&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">server_name&lt;/span> &lt;span style="color:#e6db74">alertmanager.desistdaydream.ltd&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">server_name&lt;/span> &lt;span style="color:#e6db74">nacos.desistdaydream.ltd&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">server_name&lt;/span> &lt;span style="color:#e6db74">desistdaydream.ltd&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">server_name&lt;/span> &lt;span style="color:#e6db74">www.desistdaydream.ltd&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">client_body_in_file_only&lt;/span> &lt;span style="color:#e6db74">clean&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">client_body_buffer_size&lt;/span> &lt;span style="color:#e6db74">64K&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">client_max_body_size&lt;/span> &lt;span style="color:#e6db74">40M&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">sendfile&lt;/span> &lt;span style="color:#66d9ef">on&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">send_timeout&lt;/span> &lt;span style="color:#e6db74">300s&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">location&lt;/span> &lt;span style="color:#e6db74">/&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">proxy_pass&lt;/span> &lt;span style="color:#e6db74">http://172.19.42.217/&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">proxy_set_header&lt;/span> &lt;span style="color:#e6db74">X-Real-IP&lt;/span> $remote_addr;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">proxy_set_header&lt;/span> &lt;span style="color:#e6db74">Host&lt;/span> $host;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">proxy_set_header&lt;/span> &lt;span style="color:#e6db74">X-Forwarded-For&lt;/span> $proxy_add_x_forwarded_for;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">proxy_set_header&lt;/span> &lt;span style="color:#e6db74">X-Forwarded-Proto&lt;/span> $scheme;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">proxy_http_version&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>&lt;span style="color:#e6db74">.1&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">proxy_set_header&lt;/span> &lt;span style="color:#e6db74">Upgrade&lt;/span> $http_upgrade;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">proxy_set_header&lt;/span> &lt;span style="color:#e6db74">Connection&lt;/span> &lt;span style="color:#e6db74">&amp;#34;upgrade&amp;#34;&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">include&lt;/span> &lt;span style="color:#e6db74">/etc/nginx/mime.types&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">include&lt;/span> &lt;span style="color:#e6db74">/etc/nginx/conf.d/*.conf&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">include&lt;/span> &lt;span style="color:#e6db74">/etc/nginx/conf.d/protal/*.conf&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h1 id="4-层代理配置">4 层代理配置&lt;/h1>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-nginx" data-lang="nginx">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">user&lt;/span> &lt;span style="color:#e6db74">nginx&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">worker_processes&lt;/span> &lt;span style="color:#e6db74">auto&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">error_log&lt;/span> &lt;span style="color:#e6db74">/var/log/nginx/error.log&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">pid&lt;/span> &lt;span style="color:#e6db74">/run/nginx.pid&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">include&lt;/span> /usr/share/nginx/modules/*.conf;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">events&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">worker_connections&lt;/span> &lt;span style="color:#ae81ff">10240&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">stream&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">include&lt;/span> &lt;span style="color:#e6db74">stream.d/*.conf&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">upstream&lt;/span> &lt;span style="color:#e6db74">grafana&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">server&lt;/span> 172.38.40.216:&lt;span style="color:#ae81ff">30000&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">server&lt;/span> 172.38.40.217:&lt;span style="color:#ae81ff">30000&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">upstream&lt;/span> &lt;span style="color:#e6db74">prometheus&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">server&lt;/span> 172.38.40.216:&lt;span style="color:#ae81ff">30001&lt;/span> &lt;span style="color:#e6db74">weight=8&lt;/span> &lt;span style="color:#e6db74">max_fails=2&lt;/span> &lt;span style="color:#e6db74">fail_timeout=30s&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">server&lt;/span> 172.38.40.217:&lt;span style="color:#ae81ff">30001&lt;/span> &lt;span style="color:#e6db74">weight=8&lt;/span> &lt;span style="color:#e6db74">max_fails=2&lt;/span> &lt;span style="color:#e6db74">fail_timeout=30s&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">server&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">listen&lt;/span> &lt;span style="color:#ae81ff">30000&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">proxy_pass&lt;/span> &lt;span style="color:#e6db74">grafana&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">proxy_connect_timeout&lt;/span> &lt;span style="color:#e6db74">10s&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">server&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">listen&lt;/span> &lt;span style="color:#ae81ff">30001&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">proxy_pass&lt;/span> &lt;span style="color:#e6db74">prometheus&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">proxy_connect_timeout&lt;/span> &lt;span style="color:#e6db74">2s&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">http&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h1 id="待整理配置示例">待整理配置示例&lt;/h1>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-nginx" data-lang="nginx">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">server&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">listen&lt;/span> &lt;span style="color:#ae81ff">80&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">server_name&lt;/span> &lt;span style="color:#e6db74">grafana.desistdaydream.ltd&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">server_name&lt;/span> &lt;span style="color:#e6db74">prometheus.desistdaydream.ltd&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">server_name&lt;/span> &lt;span style="color:#e6db74">alertmanager.desistdaydream.ltd&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">server_name&lt;/span> &lt;span style="color:#e6db74">nacos.desistdaydream.ltd&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">server_name&lt;/span> &lt;span style="color:#e6db74">desistdaydream.ltd&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">server_name&lt;/span> &lt;span style="color:#e6db74">www.desistdaydream.ltd&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">client_body_in_file_only&lt;/span> &lt;span style="color:#e6db74">clean&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">client_body_buffer_size&lt;/span> &lt;span style="color:#e6db74">64K&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">client_max_body_size&lt;/span> &lt;span style="color:#e6db74">40M&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">sendfile&lt;/span> &lt;span style="color:#66d9ef">on&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">send_timeout&lt;/span> &lt;span style="color:#e6db74">300s&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">location&lt;/span> &lt;span style="color:#e6db74">/&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">proxy_pass&lt;/span> &lt;span style="color:#e6db74">http://172.19.42.217/&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">proxy_set_header&lt;/span> &lt;span style="color:#e6db74">X-Real-IP&lt;/span> $remote_addr;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">proxy_set_header&lt;/span> &lt;span style="color:#e6db74">Host&lt;/span> $host;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">proxy_set_header&lt;/span> &lt;span style="color:#e6db74">X-Forwarded-For&lt;/span> $proxy_add_x_forwarded_for;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">proxy_set_header&lt;/span> &lt;span style="color:#e6db74">X-Forwarded-Proto&lt;/span> $scheme;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">proxy_http_version&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>&lt;span style="color:#e6db74">.1&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">proxy_set_header&lt;/span> &lt;span style="color:#e6db74">Upgrade&lt;/span> $http_upgrade;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">proxy_set_header&lt;/span> &lt;span style="color:#e6db74">Connection&lt;/span> &lt;span style="color:#e6db74">&amp;#34;upgrade&amp;#34;&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="https">https&lt;/h2>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-nginx" data-lang="nginx">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">server&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">listen&lt;/span> &lt;span style="color:#ae81ff">80&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">listen&lt;/span> &lt;span style="color:#ae81ff">443&lt;/span> &lt;span style="color:#e6db74">ssl&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">server_name&lt;/span> &lt;span style="color:#e6db74">rancher.desistdaydream.ltd&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">ssl&lt;/span> &lt;span style="color:#66d9ef">on&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e"># crt证书
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#f92672">ssl_certificate&lt;/span> &lt;span style="color:#e6db74">../keys/bj/rancher.desistdaydream.ltd.crt&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e"># key证书
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#f92672">ssl_certificate_key&lt;/span> &lt;span style="color:#e6db74">../keys/bj/rancher.desistdaydream.ltd.key&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">client_body_in_file_only&lt;/span> &lt;span style="color:#e6db74">clean&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">client_body_buffer_size&lt;/span> &lt;span style="color:#e6db74">64K&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">client_max_body_size&lt;/span> &lt;span style="color:#e6db74">40M&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">sendfile&lt;/span> &lt;span style="color:#66d9ef">on&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">send_timeout&lt;/span> &lt;span style="color:#e6db74">300s&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">location&lt;/span> &lt;span style="color:#e6db74">/&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">proxy_pass&lt;/span> &lt;span style="color:#e6db74">https://172.19.42.217:60443/&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">proxy_set_header&lt;/span> &lt;span style="color:#e6db74">X-Real-IP&lt;/span> $remote_addr;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">proxy_set_header&lt;/span> &lt;span style="color:#e6db74">Host&lt;/span> $host;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">proxy_set_header&lt;/span> &lt;span style="color:#e6db74">X-Forwarded-For&lt;/span> $proxy_add_x_forwarded_for;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">proxy_set_header&lt;/span> &lt;span style="color:#e6db74">X-Forwarded-Proto&lt;/span> $scheme;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">proxy_http_version&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>&lt;span style="color:#e6db74">.1&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">proxy_set_header&lt;/span> &lt;span style="color:#e6db74">Upgrade&lt;/span> $http_upgrade;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">proxy_set_header&lt;/span> &lt;span style="color:#e6db74">Connection&lt;/span> &lt;span style="color:#e6db74">&amp;#34;upgrade&amp;#34;&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div></description></item><item><title>Docs: ssl 模块</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/3.%E9%9B%86%E7%BE%A4%E4%B8%8E%E5%88%86%E5%B8%83%E5%BC%8F/nginx/nginx-%E9%85%8D%E7%BD%AE%E8%AF%A6%E8%A7%A3/%E5%A4%9A%E7%94%A8%E9%80%94%E6%A8%A1%E5%9D%97%E7%9A%84%E6%8C%87%E4%BB%A4/ssl-%E6%A8%A1%E5%9D%97/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/3.%E9%9B%86%E7%BE%A4%E4%B8%8E%E5%88%86%E5%B8%83%E5%BC%8F/nginx/nginx-%E9%85%8D%E7%BD%AE%E8%AF%A6%E8%A7%A3/%E5%A4%9A%E7%94%A8%E9%80%94%E6%A8%A1%E5%9D%97%E7%9A%84%E6%8C%87%E4%BB%A4/ssl-%E6%A8%A1%E5%9D%97/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="http://nginx.org/en/docs/http/ngx_http_ssl_module.html">http 模块下的 ssl 模块&lt;/a>&lt;/li>
&lt;li>mail 模块下的 ssl 模块&lt;/li>
&lt;li>&lt;a href="http://nginx.org/en/docs/stream/ngx_stream_ssl_module.html">stream 模块下的 ssl 模块&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>ssl 模块可以作用在 http、mail、stream 模块下，称为 &lt;strong>ngx_http_ssl_module&lt;/strong>、&lt;strong>ngx_mail_ssl_module&lt;/strong>、&lt;strong>ngx_stream_ssl_module&lt;/strong>。&lt;/p>
&lt;p>ssl 模块提供了 SSL/TLS 的必要支持，可以通过 Nginx 来为后端提供 HTTP 的服务配置 SSL、也可以为普通的 4 层服务配置 SSL。&lt;/p>
&lt;h1 id="ngx_http_ssl_module">ngx_http_ssl_module&lt;/h1>
&lt;p>该模块需要 &lt;a href="https://www.openssl.org/">OpenSSL&lt;/a> 库的支持才可以正常使用。&lt;/p>
&lt;p>ssl 模块启用后，Nginx 将可以处理 TLS/SSL 请求。当客户端发起 TLS/SSL 请求时，Nginx 中启用了 ssl 模块的 Virtual Server 作为服务端将会用配置好的证书与客户端进行认证。然后 Nginx 再作为客户端，向被代理的后端 Server 发起 TLS/SSL 请求。&lt;/p>
&lt;p>注意：&lt;/p>
&lt;ul>
&lt;li>如果一个 Virtual Server 代理的后端服务器是 HTTPS 的，那么就必须为 Virtual Server 启用 ssl 模块。因为客户端发起的请求，总是会被该 Virtual Server 重定向到 443 端口。&lt;/li>
&lt;/ul>
&lt;h2 id="ssl-指令">SSL 指令&lt;/h2>
&lt;p>&lt;a href="http://nginx.org/en/docs/http/ngx_http_ssl_module.html#ssl">&lt;strong>ssl on | off;&lt;/strong>&lt;/a> # 启用 ssl 策略。&lt;/p>
&lt;ul>
&lt;li>作用范围：http{}、server{}&lt;/li>
&lt;/ul>
&lt;p>注意：&lt;/p>
&lt;ul>
&lt;li>该指令在 1.15.0 版已过时。应该使用 &lt;code>listen&lt;/code> 指令中的 ssl 参数。&lt;/li>
&lt;li>如果一个端口监听了多个 server，只要有任意一个 server 启用了 ssl 策略，则其他都默认启用。&lt;/li>
&lt;/ul>
&lt;p>&lt;a href="http://nginx.org/en/docs/http/ngx_http_ssl_module.html#ssl_certificate">&lt;strong>ssl_certificate FILE;&lt;/strong>&lt;/a> # 为 Virtual Server 指定 PEM 格式的证书文件&lt;/p>
&lt;ul>
&lt;li>作用范围：http{}、server{}&lt;/li>
&lt;/ul>
&lt;p>&lt;a href="http://nginx.org/en/docs/http/ngx_http_ssl_module.html#ssl_certificate_key">&lt;strong>ssl_certificate_key FILE;&lt;/strong>&lt;/a> # 为 Virtual Server 指定 PEM 格式的密钥文件&lt;/p>
&lt;ul>
&lt;li>作用范围：http{}、server{}&lt;/li>
&lt;/ul>
&lt;p>&lt;a href="http://nginx.org/en/docs/http/ngx_http_ssl_module.html#ssl_client_certificate">&lt;strong>ssl_client_certificate FILE;&lt;/strong>&lt;/a> # 指定一个受信任的 PEM 格式 CA 证书的文件，如果启用 ssl_stapling，该文件用于验证客户端证书和 OCSP 响应。通常用于双向认证。&lt;/p>
&lt;ul>
&lt;li>作用范围：http{}、server{}&lt;/li>
&lt;/ul></description></item><item><title>Docs: stream 模块指令</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/3.%E9%9B%86%E7%BE%A4%E4%B8%8E%E5%88%86%E5%B8%83%E5%BC%8F/nginx/nginx-%E9%85%8D%E7%BD%AE%E8%AF%A6%E8%A7%A3/stream-%E6%A8%A1%E5%9D%97%E6%8C%87%E4%BB%A4/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/3.%E9%9B%86%E7%BE%A4%E4%B8%8E%E5%88%86%E5%B8%83%E5%BC%8F/nginx/nginx-%E9%85%8D%E7%BD%AE%E8%AF%A6%E8%A7%A3/stream-%E6%A8%A1%E5%9D%97%E6%8C%87%E4%BB%A4/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="http://nginx.org/en/docs/stream/ngx_stream_core_module.html">org 官方文档,stream core 模块&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://docs.nginx.com/nginx/admin-guide/load-balancer/tcp-udp-load-balancer/">官方文档,管理指南-负载均衡-TCP 与 UDP 负载均衡&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>stream 模块及其子模块通过 &lt;code>stream {}&lt;/code> 配置环境中的指令控制行为&lt;/p>
&lt;h2 id="简单的-stream-配置环境示例">简单的 stream{} 配置环境示例&lt;/h2>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-nginx" data-lang="nginx">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">stream&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">upstream&lt;/span> &lt;span style="color:#e6db74">stream_backend&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">least_conn&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">server&lt;/span> backend1.example.com:&lt;span style="color:#ae81ff">12345&lt;/span> &lt;span style="color:#e6db74">weight=5&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">server&lt;/span> backend2.example.com:&lt;span style="color:#ae81ff">12345&lt;/span> &lt;span style="color:#e6db74">max_fails=2&lt;/span> &lt;span style="color:#e6db74">fail_timeout=30s&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">server&lt;/span> backend3.example.com:&lt;span style="color:#ae81ff">12345&lt;/span> &lt;span style="color:#e6db74">max_conns=3&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">upstream&lt;/span> &lt;span style="color:#e6db74">dns_servers&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">least_conn&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">server&lt;/span> 192.168.136.130:&lt;span style="color:#ae81ff">53&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">server&lt;/span> 192.168.136.131:&lt;span style="color:#ae81ff">53&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">server&lt;/span> 192.168.136.132:&lt;span style="color:#ae81ff">53&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">server&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">listen&lt;/span> &lt;span style="color:#ae81ff">12345&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">proxy_pass&lt;/span> &lt;span style="color:#e6db74">stream_backend&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">proxy_timeout&lt;/span> &lt;span style="color:#e6db74">3s&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">proxy_connect_timeout&lt;/span> &lt;span style="color:#e6db74">1s&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">server&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">listen&lt;/span> &lt;span style="color:#ae81ff">53&lt;/span> &lt;span style="color:#e6db74">udp&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">proxy_pass&lt;/span> &lt;span style="color:#e6db74">dns_servers&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">server&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">listen&lt;/span> &lt;span style="color:#ae81ff">12346&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">proxy_pass&lt;/span> backend4.example.com:&lt;span style="color:#ae81ff">12346&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h1 id="virtual-server-基本配置">Virtual Server 基本配置&lt;/h1>
&lt;h2 id="流量入口指令">流量入口指令&lt;/h2>
&lt;p>注意：流量入口的指令通常都定义在 &lt;code>server{} 块指令&lt;/code> 中。&lt;/p>
&lt;h3 id="server-httpnginxorgendocshttpngx_http_core_modulehtmlserver">&lt;a href="http://nginx.org/en/docs/http/ngx_http_core_module.html#server">server {&amp;hellip;}&lt;/a>&lt;/h3>
&lt;p>定义 Virtual Server&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-nginx" data-lang="nginx">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">stream&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">server&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">listen&lt;/span> &lt;span style="color:#ae81ff">12345&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e"># ...
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">server&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">listen&lt;/span> &lt;span style="color:#ae81ff">53&lt;/span> &lt;span style="color:#e6db74">udp&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e"># ...
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e"># ...
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="listen-target-parameterhttpnginxorgendocsstreamngx_stream_core_modulehtmllisten">&lt;a href="http://nginx.org/en/docs/stream/ngx_stream_core_module.html#listen">listen TARGET [PARAMETER];&lt;/a>&lt;/h3>
&lt;p>指定 Virtual Server 监听的端口，也可加上 IP:PORT。每个 Virtual Server 的 listen 指令都会让 Nginx 监听一个 TARGET&lt;/p>
&lt;ul>
&lt;li>&lt;strong>TARGET&lt;/strong> 有多种格式
&lt;ul>
&lt;li>&lt;strong>ADDRESS:[PORT]&lt;/strong> # 监听在指定的 IP 和端口上，ADDRESS 可以使用通配符。&lt;/li>
&lt;li>&lt;strong>PORT&lt;/strong> # 省略地址，即监听在所有 IP 的指定端口上。&lt;/li>
&lt;li>&lt;strong>UNIX&lt;/strong> # 监听在以 unix: 为前缀的 UNIX 套接字上。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>PARAMETER&lt;/strong> 可以指定是 tcp 还是 udp 等等额外的信息。&lt;/li>
&lt;/ul>
&lt;h2 id="流量处理指令">流量处理指令&lt;/h2>
&lt;p>&lt;code>stream{}&lt;/code> 配置环境中的流量处理指令直接配置在 &lt;code>server{} 指令块&lt;/code>中即可。与 &lt;code>http{}&lt;/code> 配置环境不太一样，并没有 &lt;code>location{}&lt;/code> 块指令。&lt;/p>
&lt;h3 id="proxy_pass-addresshttpnginxorgendocsstreamngx_stream_proxy_modulehtmlproxy_pass">&lt;a href="http://nginx.org/en/docs/stream/ngx_stream_proxy_module.html#proxy_pass">proxy_pass ADDRESS;&lt;/a>&lt;/h3>
&lt;p>将流量入口进来的流量代理到指定的 ADDRESS 上。该指令是 ngx_stream_proxy_module 模块的核心指令&lt;/p>
&lt;ul>
&lt;li>默认值：&lt;code>无&lt;/code>&lt;/li>
&lt;li>作用范围：server{}&lt;/li>
&lt;/ul>
&lt;p>ADDRESS 有多种表示方法&lt;/p>
&lt;ul>
&lt;li>&lt;strong>ServerGroup&lt;/strong> # 将流量代理到&lt;a href="https://www.yuque.com/go/doc/34075747">一组服务器&lt;/a>上。每个流量都会根据负载均衡的规则交给 upstream{} 指令块中定义的服务器。
&lt;ul>
&lt;li>新版中，也可以省略 Protocol://，直接使用 ServerGroup 的名称即可。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>IP:PORT&lt;/strong> # ，当只有一台可用的后端服务器时可以使用这种方式，这样就不用再使用 upstream 指令块定义了&lt;/li>
&lt;li>&lt;strong>unix:/PATH/TO/FILE;&lt;/strong> # 将流量代理到本地的 UNIX-domain Socket 上&lt;/li>
&lt;/ul>
&lt;p>在[其他指令](✏IT 学习笔记/✨3.集群与分布式/Nginx/Nginx%20 配置详解/stream%20 模块指令.md 模块指令.md)中，以 &lt;code>proxy_&lt;/code> 开头的简单指令，都可以作为 &lt;code>proxy_pass&lt;/code> 指令的扩充，以定义更加丰富多样的流量处理功能。&lt;/p>
&lt;h1 id="其他指令">其他指令&lt;/h1>
&lt;p>这些指令一般都直接定义在顶层的 &lt;code>stream{}&lt;/code> 配置环境中，与 &lt;code>server{}&lt;/code>、&lt;code>upstream{}&lt;/code> 等块指令平级。还有一些指令是可以适用于多个指令块中的。定义在顶层的 &lt;code>stream{}&lt;/code> 配置环境中时，效果将会应用在每个 Virtual Server 中，同时也可以定义在单独的指令块中，让指令作用于局部。&lt;/p>
&lt;h2 id="ngx_stream_proxy_module-模块指令">ngx_stream_proxy_module 模块指令&lt;/h2>
&lt;blockquote>
&lt;p>代码：&lt;a href="https://github.com/nginx/nginx/blob/master/src/stream/ngx_stream_proxy_module.c">https://github.com/nginx/nginx/blob/master/src/stream/ngx_stream_proxy_module.c&lt;/a>&lt;/p>
&lt;/blockquote>
&lt;h3 id="超时相关指令">超时相关指令&lt;/h3>
&lt;h4 id="proxy_connect_timeout-durationhttpnginxorgendocsstreamngx_stream_proxy_modulehtmlproxy_connect_timeout">&lt;a href="http://nginx.org/en/docs/stream/ngx_stream_proxy_module.html#proxy_connect_timeout">proxy_connect_timeout DURATION;&lt;/a>&lt;/h4>
&lt;p>与被代理服务器建立连接的超时时间&lt;/p>
&lt;ul>
&lt;li>默认值：&lt;code>proxy_connect_timeout 60s;&lt;/code>&lt;/li>
&lt;li>作用范围：stream{}、server{}&lt;/li>
&lt;/ul>
&lt;h1 id="配置示例">配置示例&lt;/h1>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-nginx" data-lang="nginx">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">stream&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">upstream&lt;/span> &lt;span style="color:#e6db74">konggang_dashboard&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">server&lt;/span> 10.10.16.19:&lt;span style="color:#ae81ff">32000&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">server&lt;/span> 10.10.16.20:&lt;span style="color:#ae81ff">32000&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">server&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">listen&lt;/span> &lt;span style="color:#ae81ff">32000&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">proxy_pass&lt;/span> &lt;span style="color:#e6db74">konggang_dashboard&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">proxy_connect_timeout&lt;/span> &lt;span style="color:#e6db74">10s&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div></description></item><item><title>Docs: upstream 模块指令</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/3.%E9%9B%86%E7%BE%A4%E4%B8%8E%E5%88%86%E5%B8%83%E5%BC%8F/nginx/nginx-%E9%85%8D%E7%BD%AE%E8%AF%A6%E8%A7%A3/%E5%A4%9A%E7%94%A8%E9%80%94%E6%A8%A1%E5%9D%97%E7%9A%84%E6%8C%87%E4%BB%A4/upstream-%E6%A8%A1%E5%9D%97%E6%8C%87%E4%BB%A4/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/3.%E9%9B%86%E7%BE%A4%E4%B8%8E%E5%88%86%E5%B8%83%E5%BC%8F/nginx/nginx-%E9%85%8D%E7%BD%AE%E8%AF%A6%E8%A7%A3/%E5%A4%9A%E7%94%A8%E9%80%94%E6%A8%A1%E5%9D%97%E7%9A%84%E6%8C%87%E4%BB%A4/upstream-%E6%A8%A1%E5%9D%97%E6%8C%87%E4%BB%A4/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="http://nginx.org/en/docs/http/ngx_http_upstream_module.html">http 模块下的 upstream 模块&lt;/a>&lt;/li>
&lt;li>&lt;a href="http://nginx.org/en/docs/stream/ngx_stream_upstream_module.html">stream 模块下的 upstream 模块&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>http 和 stream 模块下的 upstream 模块都是用来定义一组可以处理流量的后端服务器，称为 &lt;strong>Server Group(服务器组)&lt;/strong>。&lt;/p>
&lt;p>Nginx 中有一个 &lt;strong>Server Group(服务器组)&lt;/strong> 的概念，Server Group 表示一组可以处理流量的后端服务器，&lt;code>proxy_pass&lt;/code> 等指令可以直接引用 服务器组的名称，以便将流量转发到这一组后端服务器上去。并且，可以根据规则，来决定给组内每个服务器分配多少流量，还可以根据规则如何判断 服务器是否掉线，掉线如何处理 等等。&lt;/p>
&lt;p>Server Group 功能通过 upstream 模块实现。而 &lt;code>upstream NAME {}&lt;/code> 指令是一个非常通用的指令，可以作用在顶级的 &lt;code>http{}&lt;/code> 和 &lt;code>stream{}&lt;/code> 配置环境中。因为 ServerGroup 就是定义一组服务器以便被 Nginx 的流量处理相关指令引用，故而属于通用配置，只不过定义在 &lt;code>http{}&lt;/code> 配置环境中的 ServerGroup 不能被 &lt;code>stream{}&lt;/code> 配置环境中的指令引用，反之亦然。&lt;/p>
&lt;blockquote>
&lt;p>注意：虽然 upstream 比较通用，但也是逻辑意义上的通用，对于 &lt;code>http{}&lt;/code> 与 &lt;code>stream{}&lt;/code> 来说，它们都有各自的 &lt;code>upstream{}&lt;/code> 模块&lt;/p>
&lt;/blockquote>
&lt;p>&lt;code>upstream NAME {}&lt;/code> 定义的名为 NAME 的一组服务器，可以被 &lt;code>proxy_pass &lt;/code>、&lt;code>fastcgi_pass&lt;/code>、&lt;code>uwsgi_pass&lt;/code>、&lt;code>scgi_pass&lt;/code>、&lt;code>memcached_pass&lt;/code>、&lt;code>grpc_pass&lt;/code> 这些指令直接引用，以便将流量直接代理到这组服务器上，并且可以根据一定的算法，轮流调度。&lt;/p>
&lt;h2 id="配置示例">配置示例&lt;/h2>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-nginx" data-lang="nginx">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">upstream&lt;/span> &lt;span style="color:#e6db74">backend&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">server&lt;/span> &lt;span style="color:#e6db74">backend1.example.com&lt;/span> &lt;span style="color:#e6db74">weight=5&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">server&lt;/span> backend2.example.com:&lt;span style="color:#ae81ff">8080&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">server&lt;/span> &lt;span style="color:#e6db74">unix:/tmp/backend3&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">server&lt;/span> backup1.example.com:&lt;span style="color:#ae81ff">8080&lt;/span> &lt;span style="color:#e6db74">backup&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">server&lt;/span> backup2.example.com:&lt;span style="color:#ae81ff">8080&lt;/span> &lt;span style="color:#e6db74">backup&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">server&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">location&lt;/span> &lt;span style="color:#e6db74">/&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">proxy_pass&lt;/span> &lt;span style="color:#e6db74">http://backend&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h1 id="服务器组指令">服务器组指令&lt;/h1>
&lt;p>服务器组相关的指令，一般是定义在 &lt;code>upstream{} 指令块&lt;/code> 中。
&lt;a href="http://nginx.org/en/docs/http/ngx_http_upstream_module.html#upstream">&lt;strong>upstream NAME {}&lt;/strong>&lt;/a>** **# 定义一组服务器。当请求代理到该 upstream 时，可以负载均衡到定义的各个 server 上。&lt;/p>
&lt;ul>
&lt;li>作用范围：http{}、stram{}&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-nginx" data-lang="nginx">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">upstream&lt;/span> &lt;span style="color:#e6db74">NAME&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">ip_hash&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">server&lt;/span> &lt;span style="color:#e6db74">BACKEND1.EXAMPLE.COM&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">server&lt;/span> &lt;span style="color:#e6db74">BACKEND2.EXAMPLE.COM&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;a href="http://nginx.org/en/docs/http/ngx_http_upstream_module.html#server">&lt;strong>server ADDRESS [PARAMETERS];&lt;/strong>&lt;/a> # 定义接受流量的服务器的地址和其他参数。&lt;/p>
&lt;ul>
&lt;li>作用范围：upstream NAME {}&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>ADDRESS&lt;/strong> # 可以指定为具有可选端口的域名或 IP 地址，或者使用 &lt;code>unix:&lt;/code> 前缀指定 UNIX 域套接字路径。如果未指定端口，则默认 80。解析为多个 IP 地址的域名一次定义多个服务器。
&lt;strong>PARAMETERS&lt;/strong> # 可以指定一个 server 的调度参数、健康检查时间间隔 等等。&lt;/p>
&lt;ul>
&lt;li>**backup **# 将 server 标记为备份服务器。&lt;/li>
&lt;li>&lt;strong>fail_timeout=&lt;!-- raw HTML omitted -->&lt;/strong> # 与 server 连接的超时时间。&lt;code>默认值：10s&lt;/code>。
&lt;ul>
&lt;li>fail_timeout 与 max_fails 两个参数配合，就是指，当一个服务器持续 fail_timeout 时间不可用，并尝试了 max_fails 次之后依然不可用，则将该服务器从本组中提出，不再将请求调度到这个服务器上。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>max_fails=&lt;!-- raw HTML omitted -->&lt;/strong> # 与 server 连接超时的次数。&lt;code>默认值：1&lt;/code>。&lt;/li>
&lt;li>&lt;strong>max_conns=&lt;!-- raw HTML omitted -->&lt;/strong> # 限制到 server 的最大同时活动连接数，也就是限制 server 的并发数。&lt;code>默认值：0&lt;/code>。默认 0 即表示不限制。&lt;/li>
&lt;li>**weight=&lt;!-- raw HTML omitted --> **# server 的权重。&lt;code>默认值：1&lt;/code>。权重越高，就会有更多的请求调度到这个 server 上。&lt;/li>
&lt;/ul>
&lt;h2 id="example">EXAMPLE&lt;/h2>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-nginx" data-lang="nginx">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">http&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">server&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">......&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#960050;background-color:#1e0010">}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">upstream&lt;/span> &lt;span style="color:#e6db74">backend&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">server&lt;/span> &lt;span style="color:#e6db74">backend1.example.com&lt;/span> &lt;span style="color:#e6db74">weight=5&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">server&lt;/span> &lt;span style="color:#e6db74">backend2.example.com&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">server&lt;/span> &lt;span style="color:#ae81ff">192&lt;/span>&lt;span style="color:#e6db74">.0.0.1&lt;/span> &lt;span style="color:#e6db74">backup&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div></description></item><item><title>Docs: 分布式算法</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/3.%E9%9B%86%E7%BE%A4%E4%B8%8E%E5%88%86%E5%B8%83%E5%BC%8F/%E9%9B%86%E7%BE%A4%E4%B8%8E%E5%88%86%E5%B8%83%E5%BC%8F/%E5%88%86%E5%B8%83%E5%BC%8F%E7%AE%97%E6%B3%95/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/3.%E9%9B%86%E7%BE%A4%E4%B8%8E%E5%88%86%E5%B8%83%E5%BC%8F/%E9%9B%86%E7%BE%A4%E4%B8%8E%E5%88%86%E5%B8%83%E5%BC%8F/%E5%88%86%E5%B8%83%E5%BC%8F%E7%AE%97%E6%B3%95/</guid><description/></item><item><title>Docs: 分布式与集群的区别是什么？</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/3.%E9%9B%86%E7%BE%A4%E4%B8%8E%E5%88%86%E5%B8%83%E5%BC%8F/%E9%9B%86%E7%BE%A4%E4%B8%8E%E5%88%86%E5%B8%83%E5%BC%8F/%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%8E%E9%9B%86%E7%BE%A4%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/3.%E9%9B%86%E7%BE%A4%E4%B8%8E%E5%88%86%E5%B8%83%E5%BC%8F/%E9%9B%86%E7%BE%A4%E4%B8%8E%E5%88%86%E5%B8%83%E5%BC%8F/%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%8E%E9%9B%86%E7%BE%A4%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88/</guid><description>
&lt;h3 id="大白话讲解分布式与集群的区别是什么">大白话讲解：分布式与集群的区别是什么？&lt;/h3>
&lt;p>参考：&lt;a href="https://blog.csdn.net/chenchunlin526/article/details/86077674">原文链接&lt;/a>&lt;/p>
&lt;h3 id="前言">前言：&lt;/h3>
&lt;p>参考了一些其他文章的见解，也补充了一些自己的见解。&lt;/p>
&lt;h3 id="一大白话解说用生活中的例子来说明">&lt;strong>一、大白话解说，用生活中的例子来说明：&lt;/strong>&lt;/h3>
&lt;p>小饭店原来只有一个厨师，切菜洗菜备料炒菜全干。后来客人多了，厨房一个厨师忙不过来，又请了个厨师，两个厨师都能炒一样的菜，两个厨师的关系是&lt;strong>集群&lt;/strong>。&lt;/p>
&lt;p>为了让厨师专心炒菜，把菜做到极致，再请了个配菜师负责切菜，备菜，备料 &amp;hellip; ， 厨师和配菜师的关系是&lt;strong>分布式&lt;/strong>。&lt;/p>
&lt;p>一个配菜师也忙不过来了，又请了个配菜师，两个配菜师关系是&lt;strong>集群&lt;/strong>。&lt;/p>
&lt;p>一个配菜师因故请假了，但是其余的配菜师还是该啥就干啥，只是没请假的配菜师任务均匀的加量了，但他们的任务和职责是不变的，这是&lt;strong>集群&lt;/strong>。&lt;/p>
&lt;p>店里生意很好，当店长接到订单后，看哪个厨师活儿不重，就将新的订单分给谁，这就是&lt;strong>负载均衡&lt;/strong>。&lt;/p>
&lt;hr>
&lt;p>&lt;strong>集群：多个人在一起做同样的事 。&lt;/strong>&lt;/p>
&lt;p>&lt;strong>分布式 ：多个人在一起做不同的事 。&lt;/strong>&lt;/p>
&lt;p>&lt;strong>负载均衡：决定将任务以某种规则分给谁做。&lt;/strong>&lt;/p>
&lt;hr>
&lt;h3 id="二图解">&lt;strong>二、图解：&lt;/strong>&lt;/h3>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/pcfi0a/1616132706039-3a4bf2af-22c7-4086-bd0e-8947e769d090.png" alt="">&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/pcfi0a/1616132706053-725564b4-aed6-487f-b845-4413dffa8ed1.png" alt="">&lt;/p>
&lt;h3 id="三区别联系-其实上面的内容应该已经让你理解-2-者了">&lt;strong>三、区别联系 （其实上面的内容应该已经让你理解 2 者了）&lt;/strong>&lt;/h3>
&lt;p>1）我记得在一本讲 TCP/IP 的书上有这样一句话：&lt;strong>分布式是指多个系统协同合作完成一个特定任务的系统&lt;/strong>。&lt;/p>
&lt;p>&lt;strong>分布式是解决中心化管理的问题，把所有的任务叠加到一个节点处理，太慢了。&lt;/strong>&lt;/p>
&lt;p>&lt;strong>所以**&lt;strong>把一个大的问题拆分为多个小的问题，并分别解决，最终协同合作*&lt;/strong>*。分布式的主要工作是分解任务，将职能拆解&lt;/strong>。&lt;/p>
&lt;p>中心化带来的主要问题是可靠性，若中心节点宕机则整个系统不可用，分布式除了解决部分中心化问题，也倾向于分散负载，&lt;strong>但分布式会带来很多的其他问题，最主要的就是一致性&lt;/strong>。&lt;/p>
&lt;p>这些年吵得很热的&lt;strong>云计算&lt;/strong>实际上只是包装在分布式之外的“新”概念。&lt;/p>
&lt;p>2） &lt;strong>集群&lt;/strong>主要的使用场景是&lt;strong>为了分担请求的压力&lt;/strong>，也就是在几个服务器上部署相同的应用程序，配合负载均衡来分担客户端请求。&lt;/p>
&lt;p>当压力进一步增大的时候，可能在需要存储的部分，mysql 无法面对很多的写压力。因为在 mysql 做成集群之后，主要的写压力还是在 master 的机器上面，其他 slave 机器无法分担写压力，从而这个时候，也就引出来分布式。&lt;/p>
&lt;p>&lt;strong>分布式&lt;/strong>的主要应用场景是&lt;strong>单台机器已经无法满足这种性能的要求，必须要融合多个节点，并且节点之间是相关之间有交互的&lt;/strong>。相当于在写 mysql 的时候，每个节点存储部分数据，也就是&lt;strong>分布式存储&lt;/strong>的由来。在存储一些非结构化数据：静态文件、图片、pdf、小视频 &amp;hellip; 这些也就是分布式文件系统的由来。&lt;/p>
&lt;p>如：现在的 Spring Cloud 的分布式微服务架构，一个系统分解成了多个 Spring Boot 的微服务，各个微服务协同合作完成特定的任务。同个微服务又可以部署多台服务器形成微服务集群，从而提供高可用服务。&lt;/p>
&lt;p>3）&lt;strong>集群主要是简单加机器解决问题，对于问题本身不做任何分解&lt;/strong>；&lt;/p>
&lt;p>分布式处理里必然包含任务分解与答案归并。&lt;strong>分布式&lt;/strong>中的某个子任务节点，可能由一个集群来代替；&lt;strong>集群&lt;/strong>中任一节点，都是做一个完整的任务。&lt;/p>
&lt;p>集群和分布式都是由多个节点组成，但是集群之间的通信协调基本不需要；而分布式各个节点的通信协调必不可少。&lt;/p>
&lt;h3 id="总结">总结：&lt;/h3>
&lt;hr>
&lt;p>&lt;strong>将一套系统拆分成不同子系统部署在不同服务器上（这叫分布式），然后部署多个相同的子系统在不同的服务器上（这叫集群），部署在不同服务器上的同一个子系统需要做负载均衡处理。&lt;/strong>&lt;/p>
&lt;p>&lt;strong>集群是个物理形态，分布式是个工作方式。&lt;/strong>&lt;/p>
&lt;hr>
&lt;p>**分布式：一个业务拆分为多个子业务，部署在多个服务器上 。 **&lt;/p>
&lt;p>&lt;strong>集群：同一个业务，部署在多个服务器上 。&lt;/strong>&lt;/p>
&lt;hr>
&lt;p>&lt;strong>分布式&lt;/strong>：不同的业务模块部署在不同的服务器上或者同一个业务模块分拆多个子业务，部署在不同的服务器上，解决高并发的问题。&lt;/p>
&lt;p>&lt;strong>集群&lt;/strong>：同一个业务部署在多台机器上，提高系统可用性。&lt;/p>
&lt;hr>
&lt;p>【参考】：&lt;a href="https://www.zhihu.com/question/20004877">https://www.zhihu.com/question/20004877&lt;/a>，&lt;a href="https://www.zhihu.com/question/20004877">https://www.zhihu.com/question/20004877&lt;/a>，&lt;a href="https://blog.csdn.net/jiangyu1013/article/details/80417961">https://blog.csdn.net/jiangyu1013/article/details/80417961&lt;/a>&lt;/p></description></item><item><title>Docs: 负载均衡</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/3.%E9%9B%86%E7%BE%A4%E4%B8%8E%E5%88%86%E5%B8%83%E5%BC%8F/%E9%9B%86%E7%BE%A4%E4%B8%8E%E5%88%86%E5%B8%83%E5%BC%8F/%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/3.%E9%9B%86%E7%BE%A4%E4%B8%8E%E5%88%86%E5%B8%83%E5%BC%8F/%E9%9B%86%E7%BE%A4%E4%B8%8E%E5%88%86%E5%B8%83%E5%BC%8F/%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/</guid><description>
&lt;p>四层、七层负载均衡的区别&lt;/p>
&lt;h1 id="一什么是负载均衡load-balancing">一，什么是负载均衡（Load balancing）&lt;/h1>
&lt;p>在网站创立初期，我们一般都使用单台机器对台提供集中式服务，但是随着业务量越来越大，无论是性能上还是稳定性上都有了更大的挑战。这时候我们就会想到通过扩容的方式来提供更好的服务。&lt;/p>
&lt;p>我们一般会把多台机器组成一个集群对外提供服务。然而，我们的网站对外提供的访问入口都是一个的，比如www.taobao.com。那么当用户在浏览器输入www.taobao.com的时候如何将用户的请求分发到集群中不同的机器上呢，这就是负载均衡在做的事情。&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/awekiu/1616132229006-9cc152b6-68bc-4541-b75c-ef38c72b6991.jpeg" alt="">&lt;/p>
&lt;h1 id="二负载均衡按网络七层模型分类">二，负载均衡按网络七层模型分类&lt;/h1>
&lt;p>现在我们知道，负载均衡就是一种计算机网络技术，用来在多个计算机（计算机集群）、网络连接、CPU、磁碟驱动器或其他资源中分配负载，以达到最佳化资源使用、最大化吞吐率、最小化响应时间、同时避免过载的目的。那么，这种计算机技术的实现方式有多种。大致可以分为以下几种，其中最常用的是四层和七层负载均衡：&lt;/p>
&lt;ol>
&lt;li>
&lt;p>二层负载均衡&lt;/p>
&lt;/li>
&lt;li>
&lt;p>负载均衡服务器对外依然提供一个 VIP（虚 IP），集群中不同的机器采用相同 IP 地址，但是机器的 MAC 地址不一样。当负载均衡服务器接受到请求之后，通过改写报文的目标 MAC 地址的方式将请求转发到目标机器实现负载均衡。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>三层负载均衡&lt;/p>
&lt;/li>
&lt;li>
&lt;p>和二层负载均衡类似，负载均衡服务器对外依然提供一个 VIP（虚 IP），但是集群中不同的机器采用不同的 IP 地址。当负载均衡服务器接受到请求之后，根据不同的负载均衡算法，通过 IP 将请求转发至不同的真实服务器。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>四层负载均衡：TCP 层的 Load Balance,转发请求&lt;/p>
&lt;/li>
&lt;li>
&lt;p>四层负载均衡工作在 OSI 模型的传输层，由于在传输层，只有 TCP/UDP 协议，这两种协议中除了包含源 IP、目标 IP 以外，还包含源端口号及目的端口号。四层负载均衡服务器在接受到客户端请求后，以后通过修改数据包的地址信息（IP+端口号）将流量转发到应用服务器。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>应用场景：对于用户请求一个网站的图片，会根据用户请求中 URL 的地址:端口，转发到后端的服务器上，再由后端服务器处理该请求，这时候要求运维人员记住用户请求图片所在的服务器是哪台&lt;/p>
&lt;/li>
&lt;li>
&lt;p>七层负载均衡：HTTP 协议层的反向代理，代理请求&lt;/p>
&lt;/li>
&lt;li>
&lt;p>七层负载均衡工作在 OSI 模型的应用层，应用层协议较多，常用 http、radius、dns 等。七层负载就可以基于这些协议来负载。这些应用层协议中会包含很多有意义的内容。比如同一个 Web 服务器的负载均衡，除了根据 IP 加端口进行负载外，还可根据七层的 URL、浏览器类别、语言来决定是否要进行负载均衡。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>应用场景：对于用户请求一个网站的图片，会根据用户请求的 URL 来代理用户的该请求，重新构建请求报文，根据自身的缓存规则，比如一致性哈希算法，找到该图片的位置，然后把请求发送给该设备。&lt;/p>
&lt;/li>
&lt;/ol>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/awekiu/1616132229033-ae331c0a-6081-46ae-a118-89ff2490cb1c.jpeg" alt="">&lt;/p>
&lt;p>对于一般的应用来说，有了 Nginx 就够了。Nginx 可以用于七层负载均衡。但是对于一些大的网站，一般会采用 DNS+四层负载+七层负载的方式进行多层次负载均衡。&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/awekiu/1616132229056-e7197895-718e-4c41-8470-de541575e410.jpeg" alt="">&lt;/p>
&lt;h1 id="三四层七层负载均衡对比">三、四层、七层负载均衡对比&lt;/h1>
&lt;p>所谓四层即运输层，就是基于 IP + 端口的负载均衡；七层即应用层，就是基于 URL 等应用层信息的负载均衡；&lt;/p>
&lt;p>同理，还有基于 MAC 地址的二层负载均衡和基于 IP 地址的三层负载均衡。&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/awekiu/1616132228994-d0c7ede4-3016-4a5b-9ae2-088fd7fc699c.jpeg" alt="">&lt;/p>
&lt;p>换句换说，&lt;/p>
&lt;p>二层负载均衡会通过一个虚拟 MAC 地址接收请求，然后再分配到真实的 MAC 地址；&lt;/p>
&lt;p>三层负载均衡会通过一个虚拟 IP 地址接收请求，然后再分配到真实的 IP 地址；&lt;/p>
&lt;p>四层通过虚拟 IP + 端口接收请求，然后再分配到真实的服务器；&lt;/p>
&lt;p>七层通过虚拟的 URL 或主机名接收请求，然后再分配到真实的服务器。&lt;/p>
&lt;p>所谓的四到七层负载均衡，就是在对后台的服务器进行负载均衡时，依据四层的信息或七层的信息来决定怎么样转发流量。&lt;/p>
&lt;p>比如四层的负载均衡，就是通过发布三层的 IP 地址（VIP），然后加四层的端口号，来决定哪些流量需要做负载均衡，&lt;/p>
&lt;p>对需要处理的流量进行 NAT 处理，转发至后台服务器，并记录下这个 TCP 或者 UDP 的流量是由哪台服务器处理的，&lt;/p>
&lt;p>后续这个连接的所有流量都同样转发到同一台服务器处理。&lt;/p>
&lt;p>七层的负载均衡，就是在四层的基础上（没有四层是绝对不可能有七层的），再考虑应用层的特征， 比如同一个 Web 服务器的负载均衡，除了根据 VIP 加 80 端口辨别是否需要处理的流量， 还可根据七层的 URL、浏览器类别、语言来决定是否要进行负载均衡。&lt;/p>
&lt;p>举个例子，如果你的 Web 服务器分成两组，一组是中文语言的，一组是英文语言的，&lt;/p>
&lt;p>那么七层负载均衡就可以当用户来访问你的域名时，自动辨别用户语言，然后选择对应的语言服务器组进行负载均衡处理。&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/awekiu/1616132229038-0c054f8b-f050-46b3-9d1d-bf0523bf4501.jpeg" alt="">&lt;/p>
&lt;p>负载均衡器通常称为四层交换机或七层交换机。&lt;/p>
&lt;p>四层交换机主要分析 IP 层及 TCP/UDP 层，实现四层流量负载均衡。&lt;/p>
&lt;p>七层交换机除了支持四层负载均衡以外，还有分析应用层的信息，如 HTTP 协议 URI 或 Cookie 信息。&lt;/p>
&lt;p>负载均衡分为 L4 Switch（四层交换），即在 OSI 第 4 层工作，就是 TCP 层啦。&lt;/p>
&lt;p>此种 Load Balancer 不理解应用协议（如 HTTP/FTP/MySQL 等等）。例子：LVS，F5。&lt;/p>
&lt;p>另一种叫做 L7 Switch（七层交换），OSI 的最高层，应用层。&lt;/p>
&lt;p>此时，该 Load Balancer 能理解应用协议。例子： HAProxy，MySQL Proxy。&lt;/p>
&lt;p>注意：上面的很多 Load Balancer 既可以做四层交换，也可以做七层交换。&lt;/p>
&lt;p>当前可以看到对于 F5, Array 等硬件负载均衡设备本身也是支持 7 层负载均衡的，&lt;/p>
&lt;p>同时在 4 层负载均衡的时候我们还可以设置是否进行会话保持等高级特性。&lt;/p>
&lt;p>要明白 4 层负载均衡本质是转发，而 7 层负载本质是内容交换和代理，具体说明如下：&lt;/p>
&lt;h1 id="四四层七层技术原理上的区别">四、四层，七层技术原理上的区别&lt;/h1>
&lt;p>所谓四层负载均衡，也就是主要通过报文中的目标地址和端口，再加上负载均衡设备设置的服务器选择方式，决定最终选择的内部服务器。&lt;/p>
&lt;p>以常见的 TCP 为例，负载均衡设备在接收到第一个来自客户端的 SYN 请求时，即通过上述方式选择一个最佳的服务器， 并对报文中的目标 IP 地址进行修改(改为后端服务器 IP），直接转发给该服务器。 TCP 的连接建立，即三次握手是客户端和服务器直接建立的，负载均衡设备只是起到一个类似路由器的转发动作。&lt;/p>
&lt;p>在某些部署情况下，为保证服务器回包可以正确返回给负载均衡设备，在转发报文的同时可能还会对报文原来的源地址进行修改。&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/awekiu/1616132229034-860a5b39-2224-4d37-bbe6-c2011888f728.jpeg" alt="">&lt;/p>
&lt;p>所谓七层负载均衡，也称为“内容交换”，也就是主要通过报文中的真正有意义的应用层内容，&lt;/p>
&lt;p>再加上负载均衡设备设置的服务器选择方式，决定最终选择的内部服务器。&lt;/p>
&lt;p>以常见的　 TCP 　为例，负载均衡设备如果要根据真正的应用层内容再选择服务器，&lt;/p>
&lt;p>只能先代理最终的服务器和客户端建立连接（TCP 三次握手）后，才可能接收到客户端发送的真正应用层内容的报文， 然后再根据该报文中的特定字段，再加上负载均衡设备设置的服务器选择方式，决定最终选择的内部服务器。&lt;/p>
&lt;p>负载均衡设备在这种情况下，更类似于一个代理服务器。负载均衡和前端的客户端以及后端的服务器会分别建立 TCP 连接。&lt;/p>
&lt;p>所以从这个技术原理上来看，七层负载均衡明显地对负载均衡设备的要求更高，处理七层的能力也必然会低于四层模式的部署方式。&lt;/p>
&lt;h1 id="五-应用场景的需求">五、 应用场景的需求&lt;/h1>
&lt;p>七层应用负载均衡的好处，是使得整个网络更“智能化”, 例如访问一个网站的用户流量，可以通过七层的方式，&lt;/p>
&lt;p>将对图片类的请求转发到特定的图片服务器并可以使用缓存技术；将对文字类的请求可以转发到特定的文字服务器并可以使用压缩技术。&lt;/p>
&lt;p>当然这只是七层应用的一个小案例，从技术原理上，这种方式可以对客户端的请求和服务器的响应进行任意意义上的修改，极大的提升了应用系统在网络层的灵活性。 很多在后台(例如 Nginx 或者 Apache )上部署的功能可以前移到负载均衡设备上，例如客户请求中的 Header 重写，服务器响应中的关键字过滤或者内容插入等功能。&lt;/p>
&lt;p>另外一个常常被提到功能就是安全性。网络中最常见的 SYN Flood 攻击，即黑客控制众多源客户端，使用虚假 IP 地址对同一目标发送 SYN 攻击，&lt;/p>
&lt;p>通常这种攻击会大量发送 SYN 报文，耗尽服务器上的相关资源，以达到 Denial of Service(DoS) 的目的。&lt;/p>
&lt;p>从技术原理上也可以看出，四层模式下这些 SYN 攻击都会被转发到后端的服务器上；&lt;/p>
&lt;p>而七层模式下这些 SYN 攻击自然在负载均衡设备上就截止，不会影响后台服务器的正常运营。&lt;/p>
&lt;p>另外负载均衡设备可以在七层层面设定多种策略，过滤特定报文，例如 SQL Injection 等应用层面的特定攻击手段，从应用层面进一步提高系统整体安全。&lt;/p>
&lt;p>现在的 7 层负载均衡，主要还是着重于应用广泛的 HTTP 协议，所以其应用范围主要是众多的网站或者内部信息平台等基于 B/S 开发的系统。&lt;/p>
&lt;p>4 层负载均衡则对应其他 TCP 应用，例如基于 C/S 开发的 ERP 等系统。&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/awekiu/1616132229056-b0531047-5625-432f-ab76-8cef95f5fdb1.jpeg" alt="">&lt;/p>
&lt;h1 id="六七层应用需要考虑的问题">六、七层应用需要考虑的问题&lt;/h1>
&lt;p>是否真的必要，七层应用的确可以提高流量智能化，同时必不可免的带来设备配置复杂，负载均衡压力增高以及故障排查上的复杂性等问题。&lt;/p>
&lt;p>在设计系统时需要考虑四层七层同时应用的混杂情况。&lt;/p>
&lt;p>是否真的可以提高安全性。例如 SYN Flood 攻击，七层模式的确将这些流量从服务器屏蔽，但负载均衡设备本身要有强大的抗 DDoS 能力，&lt;/p>
&lt;p>否则即使服务器正常而作为中枢调度的负载均衡设备故障也会导致整个应用的崩溃。&lt;/p>
&lt;p>是否有足够的灵活度。七层应用的优势是可以让整个应用的流量智能化，但是负载均衡设备需要提供完善的七层功能，满足客户根据不同情况的基于应用的调度。&lt;/p>
&lt;p>最简单的一个考核就是能否取代后台 Nginx 或者 Apache 等服务器上的调度功能。&lt;/p>
&lt;p>能够提供一个七层应用开发接口的负载均衡设备，可以让客户根据需求任意设定功能，才真正有可能提供强大的灵活性和智能性。&lt;/p>
&lt;h1 id="七常用负载均衡工具">七、常用负载均衡工具&lt;/h1>
&lt;p>Nginx/LVS/HAProxy 是目前使用最广泛的三种负载均衡软件。&lt;/p>
&lt;p>LVS&lt;/p>
&lt;p>LVS（Linux Virtual Server），也就是 Linux 虚拟服务器, 是一个由章文嵩博士发起的自由软件项目。使用 LVS 技术要达到的目标是：通过 LVS 提供的负载均衡技术和 Linux 操作系统实现一个高性能、高可用的服务器群集，它具有良好可靠性、可扩展性和可操作性。从而以低廉的成本实现最优的服务性能。&lt;/p>
&lt;p>LVS 主要用来做四层负载均衡。&lt;/p>
&lt;p>Nginx&lt;/p>
&lt;p>Nginx（发音同 engine x）是一个网页服务器，它能反向代理 HTTP, HTTPS, SMTP, POP3, IMAP 的协议链接，以及一个负载均衡器和一个 HTTP 缓存。&lt;/p>
&lt;p>Nginx 主要用来做七层负载均衡。&lt;/p>
&lt;p>HAProxy&lt;/p>
&lt;p>HAProxy 是一个使用 C 语言编写的自由及开放源代码软件，其提供高可用性、负载均衡，以及基于 TCP 和 HTTP 的应用程序代理。&lt;/p>
&lt;p>Haproxy 主要用来做七层负载均衡。&lt;/p>
&lt;h1 id="八常见负载均衡算法">八，常见负载均衡算法&lt;/h1>
&lt;p>上面介绍负载均衡技术的时候提到过，负载均衡服务器在决定将请求转发到具体哪台真实服务器的时候，是通过负载均衡算法来实现的。负载均衡算法可以分为两类：静态负载均衡算法和动态负载均衡算法。&lt;/p>
&lt;p>静态负载均衡算法包括：轮询，比率，优先权&lt;/p>
&lt;p>动态负载均衡算法包括: 最少连接数,最快响应速度，观察方法，预测法，动态性能分配，动态服务器补充，服务质量，服务类型，规则模式。&lt;/p>
&lt;p>轮询（Round Robin）：顺序循环将请求一次顺序循环地连接每个服务器。当其中某个服务器发生第二到第 7 层的故障，BIG-IP 就把其从顺序循环队列中拿出，不参加下一次的轮询，直到其恢复正常。&lt;/p>
&lt;p>比率（Ratio）：给每个服务器分配一个加权值为比例，根椐这个比例，把用户的请求分配到每个服务器。当其中某个服务器发生第二到第 7 层的故障，BIG-IP 就把其从服务器队列中拿出，不参加下一次的用户请求的分配, 直到其恢复正常。&lt;/p>
&lt;p>优先权（Priority）：给所有服务器分组,给每个组定义优先权，BIG-IP 用户的请求，分配给优先级最高的服务器组（在同一组内，采用轮询或比率算法，分配用户的请求）；当最高优先级中所有服务器出现故障，BIG-IP 才将请求送给次优先级的服务器组。这种方式，实际为用户提供一种热备份的方式。&lt;/p>
&lt;p>最少的连接方式（Least Connection）：传递新的连接给那些进行最少连接处理的服务器。当其中某个服务器发生第二到第 7 层的故障，BIG-IP 就把其从服务器队列中拿出，不参加下一次的用户请求的分配, 直到其恢复正常。&lt;/p>
&lt;p>最快模式（Fastest）：传递连接给那些响应最快的服务器。当其中某个服务器发生第二到第 7 层的故障，BIG-IP 就把其从服务器队列中拿出，不参加下一次的用户请求的分配，直到其恢复正常。&lt;/p>
&lt;p>观察模式（Observed）：连接数目和响应时间以这两项的最佳平衡为依据为新的请求选择服务器。当其中某个服务器发生第二到第 7 层的故障，BIG-IP 就把其从服务器队列中拿出，不参加下一次的用户请求的分配，直到其恢复正常。&lt;/p>
&lt;p>预测模式（Predictive）：BIG-IP 利用收集到的服务器当前的性能指标，进行预测分析，选择一台服务器在下一个时间片内，其性能将达到最佳的服务器相应用户的请求。(被 BIG-IP 进行检测)&lt;/p>
&lt;p>动态性能分配(Dynamic Ratio-APM):BIG-IP 收集到的应用程序和应用服务器的各项性能参数，动态调整流量分配。&lt;/p>
&lt;p>动态服务器补充(Dynamic Server Act.):当主服务器群中因故障导致数量减少时，动态地将备份服务器补充至主服务器群。&lt;/p>
&lt;p>服务质量(QoS）:按不同的优先级对数据流进行分配。&lt;/p>
&lt;p>服务类型(ToS): 按不同的服务类型（在 Type of Field 中标识）负载均衡对数据流进行分配。&lt;/p>
&lt;p>规则模式：针对不同的数据流设置导向规则，用户可自行。&lt;/p>
&lt;p>文章参考链接：hollischuang.com/archives/1844；jaminzhang.github.io/lb/L4-L7-Load-Balancer-Difference/&lt;/p></description></item><item><title>Docs: 共识算法</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/3.%E9%9B%86%E7%BE%A4%E4%B8%8E%E5%88%86%E5%B8%83%E5%BC%8F/%E9%9B%86%E7%BE%A4%E4%B8%8E%E5%88%86%E5%B8%83%E5%BC%8F/%E5%88%86%E5%B8%83%E5%BC%8F%E7%AE%97%E6%B3%95/%E5%85%B1%E8%AF%86%E7%AE%97%E6%B3%95/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/3.%E9%9B%86%E7%BE%A4%E4%B8%8E%E5%88%86%E5%B8%83%E5%BC%8F/%E9%9B%86%E7%BE%A4%E4%B8%8E%E5%88%86%E5%B8%83%E5%BC%8F/%E5%88%86%E5%B8%83%E5%BC%8F%E7%AE%97%E6%B3%95/%E5%85%B1%E8%AF%86%E7%AE%97%E6%B3%95/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://zhuanlan.zhihu.com/p/130332285">知乎大佬&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>分布式系统中，如何保证集群中所有节点中的数据完全相同并且能够对某个提案(Proposal)达成一致，是分布式系统正常工作的核心问题，而 共识算法 就是用来保证分布式系统一致性的方法。有时候，共识算法也称为“一致性算法”。&lt;/p>
&lt;p>Note：
提案(Proposal) # 在分布式系统中，Proposal 指分布式系统的修改请求，比如当一个客户端将一个数据写入到分布式系统中，负责接收数据的节点就会发起提案，让集群中其余节点写入该数据。&lt;/p>
&lt;p>共识算法的实现：&lt;/p>
&lt;ul>
&lt;li>&lt;strong>Paxos&lt;/strong> #&lt;/li>
&lt;li>&lt;strong>ZAB(muti-paxos)&lt;/strong> #&lt;/li>
&lt;li>&lt;strong>Raft(muti-paxos)&lt;/strong> #Paxos 算法不易实现，Raft 算法是对 Paxos 算法的简化和改进&lt;/li>
&lt;li>&lt;strong>Gossip&lt;/strong> # 这是一个协议，与 Raft 等公式算法不太一样&lt;/li>
&lt;/ul>
&lt;p>由于共识算法的特点(下文会详细介绍，可以看完算法介绍再来看这段描述)，所以一般保证一致性的分布式系统的节点数都是都是奇数个。&lt;/p>
&lt;h1 id="raft-算法">Raft 算法&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="http://thesecretlivesofdata.com/raft/">动画演示&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>一个节点一般具有三种状态：&lt;/p>
&lt;ol>
&lt;li>&lt;strong>Leader&lt;/strong> # 领导者，负责发出提案&lt;/li>
&lt;li>** Candidate** # 候选人，负责争夺 Leader&lt;/li>
&lt;li>&lt;strong>Follower&lt;/strong> # 追随者，负责同意 Leader 发出的提案&lt;/li>
&lt;/ol>
&lt;p>名词解释：&lt;/p>
&lt;ol>
&lt;li>&lt;strong>voted&lt;/strong> # 投票&lt;/li>
&lt;li>&lt;strong>term&lt;/strong> # 期限、任期。用来代指 Leader 产生到结束这一时间段&lt;/li>
&lt;/ol>
&lt;p>Leader 的产生&lt;/p>
&lt;ol>
&lt;li>所有节点的初始状态都是以 Follower，并且持有一个定时器(各节点定时器时间随机，以保证不会同时触发选举)。
&lt;ol>
&lt;li>该定时器被随机分配在 150ms 和 300ms 之间&lt;/li>
&lt;/ol>
&lt;/li>
&lt;li>如果 Followers 在定时器时间到了，而没有收到 Leader 信息的话。那么 Follower 则声明自己是 Candidate 并参与 Leader 选举(此时为自己投票)，同时将请求发给其他节点来争取他们的投票，若其他节点长时间没有响应 Candidate，将重新发送选举信息。&lt;/li>
&lt;li>如果接收投票信息的节点在这个 term 中还没有投过票，那么该节点将对发起该请求的 Candidate 投票，并且该节点重置定时器。&lt;/li>
&lt;li>Candidate 计算总票数(自己+其他节点)，得票数大于 (n+1)/2 时(n 为节点数，除不开向下取整)，则该 Candidate 将称为第 M 任 Leader (M 任是最新的 term)
&lt;ol>
&lt;li>Note：这里面所谓的投票与现实意义中的投票不太一样，没有投同意或者不同意这种说法。&lt;/li>
&lt;li>值要对目标投票，目标就会计算一份得票数&lt;/li>
&lt;/ol>
&lt;/li>
&lt;li>Leader 在 term 内会不断发送心跳信息给集群内其他节点证明自己还活着，其他节点在收到心跳后会清空自己的定时器并回复 Leader 的心跳。这个机制保证其他节点不会在 Leader 任期内参加 Leader 选举。&lt;/li>
&lt;li>当 Leader 节点出现故障而导致 Leader 失联，没有接收到心跳的 Follower 节点将准备成为 Candidate 进入下一轮 Leader 选举(回到步骤 1)。&lt;/li>
&lt;li>若出现两个 Candidate 同时选举并获得了相同的票数，那么这两个 Candidate 将随机推迟一段时间后再向其他节点发出投票请求，这保证了再次发送投票请求以后不冲突。&lt;/li>
&lt;/ol>
&lt;p>状态复制&lt;/p>
&lt;ol>
&lt;li>Leader 负责接收来自 Client 的提案请求。
&lt;ol>
&lt;li>比如提案内容是：写入一个数值 5 。&lt;/li>
&lt;/ol>
&lt;/li>
&lt;li>提案内容将包含在 Leader 发出的下一个心跳中。&lt;/li>
&lt;li>Follower 接收到心跳以后回复 Leader 的心跳&lt;/li>
&lt;li>Leader 接收到多数 Follower 的回复以后，确认提案并写入自己的存储空间并回复 Client 。&lt;/li>
&lt;li>Leader 通知 Follower 节点确认提案并向存储空间写入内容，随后所有的节点都拥有相同的数据。&lt;/li>
&lt;li>若集群中出现网络异常，导致集群被分割，将出现多个 Leader。(比如 5 节点集群被分割成两个集群，一个 2 节点，一个 3 节点)&lt;/li>
&lt;li>被分割出的少数节点的集群将无法达到共识，即脑裂。
&lt;ol>
&lt;li>在状态复制时，&amp;hellip;&amp;hellip;&amp;hellip;.未知&lt;/li>
&lt;/ol>
&lt;/li>
&lt;li>当网络恢复，集群恢复之后，将只听从最新任期 Leader 的指挥，旧 Leader 将&lt;/li>
&lt;li>&amp;hellip;&amp;hellip;.未知&lt;/li>
&lt;/ol></description></item><item><title>Docs: 集群与分布式</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/3.%E9%9B%86%E7%BE%A4%E4%B8%8E%E5%88%86%E5%B8%83%E5%BC%8F/%E9%9B%86%E7%BE%A4%E4%B8%8E%E5%88%86%E5%B8%83%E5%BC%8F/%E9%9B%86%E7%BE%A4%E4%B8%8E%E5%88%86%E5%B8%83%E5%BC%8F/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/3.%E9%9B%86%E7%BE%A4%E4%B8%8E%E5%88%86%E5%B8%83%E5%BC%8F/%E9%9B%86%E7%BE%A4%E4%B8%8E%E5%88%86%E5%B8%83%E5%BC%8F/%E9%9B%86%E7%BE%A4%E4%B8%8E%E5%88%86%E5%B8%83%E5%BC%8F/</guid><description>
&lt;h1 id="cluster集群概述">Cluster(集群)概述&lt;/h1>
&lt;p>当单独一台主机无法承载现有的用户请求量；或者一台主机因为单一故障导致业务中断的时候，就可以增加服务主机数，这些主机在一起提供服务，就叫集群，而用户所看到的依然是单个的主机，用户并不用知道具体是集群内哪台设备为我提供服务，只需要知道访问集群的入口即可。&lt;/p>
&lt;p>集群类型包括：&lt;/p>
&lt;ol>
&lt;li>LB # Load Balancing 负载均衡&lt;/li>
&lt;li>HA # High Availability 高可用，双机主备&lt;/li>
&lt;li>HP # High Performancing 高性能&lt;/li>
&lt;/ol>
&lt;p>构建高可扩展性系统的重要原则：在系统内部尽量避免串行化和交互&lt;/p>
&lt;h2 id="load-balancing负载均衡-集群">Load Balancing(负载均衡) 集群&lt;/h2>
&lt;p>根据请求报文的目标 IP:PORT 将其转发至后端主机集群中的某一台主机&lt;/p>
&lt;p>LB 的作用：将业务请求分摊到多个后端设备进行执行，例如 Web 服务器、FTP 服务器等，当一台 web 服务器为 1W 人提供服务的时候，为了减少单台服务器的压力，可以把 1W 人分成 4 份，增加三台服务器，四台服务器每台 2500 人，共同完成工作任务，就算一台坏掉了，其余三台还能正常提供服务。也是变相实现了高可用，可以解决单点故障&lt;/p>
&lt;p>类似于交换机的转发以及路由器的转发，都是把收到的请求转发到另一个地方，LB 可以称为 4 层交换或 4 层路由，工作在 4 网络 7 层模型中 4 层及以上，主要是对协议请求报文进行广播，转发，广播是对于同一个区域来进行的（LB 整个架构中的每一台设备都相当于交换机一个端口，其中一个端口(调度器)收到请求报文，广播给其余的 RS 或选择一个 RS 进行接收该请求）&lt;/p>
&lt;p>负载均衡实现方式从软硬件来区分，分两种：&lt;/p>
&lt;ol>
&lt;li>硬件负载均衡：通过硬件设备来实现负载均衡功能，国内常用前三家的设备
&lt;ol>
&lt;li>F5 厂家的 BIG-IP，最好的，并发承载能力最高，价格也是最好的&lt;/li>
&lt;li>Citrix(思捷)厂家的 NetScaleer&lt;/li>
&lt;li>A10 厂家的 A10&lt;/li>
&lt;li>Array 厂家&lt;/li>
&lt;li>Redware&lt;/li>
&lt;li>等等等&lt;/li>
&lt;/ol>
&lt;/li>
&lt;li>软件负载均衡：通过软件技术来实现负载均衡功能
&lt;ol>
&lt;li>LVS(Linux virtual server)，Linux 自带的功能 2.LB 之 LVS 概念、类型、调度方法、命令操作与实际配置.note&lt;/li>
&lt;li>haProxy&lt;/li>
&lt;li>Nginx&lt;/li>
&lt;li>ATS(apache traffic service)&lt;/li>
&lt;li>等等。软件负载均衡基于工作的协议层次划分：
&lt;ol>
&lt;li>传输层：lvs，haproxy&lt;/li>
&lt;li>应用层：haproxy，nginx，ats&lt;/li>
&lt;/ol>
&lt;/li>
&lt;/ol>
&lt;/li>
&lt;/ol>
&lt;h3 id="lb-的实现方式">LB 的实现方式&lt;/h3>
&lt;p>在很久很久以前，只有一台服务器来为用户提供服务，用户直接访问这台服务器的 IP 即可，如上文描述，当一台服务器不够用的时候，想让多台服务器同时为用户提供服务，这就是负载均衡的技术，那么这么多台服务器，每个服务器都有自己的 IP，用户如何知道自己访问哪个呢？&lt;/p>
&lt;p>这时候在这些服务器前面就需要有一个调度人员，来处理用户的请求，用户具体访问哪台服务器，由这个调度人员来决定，这个调度人员的工作，也可以同通过一台服务器来实现，这台调度服务器，就是实现 LB 技术的设备。而调度器(Director)的叫法，也是由此而来&lt;/p>
&lt;h2 id="high-availability高可用-集群">High Availability(高可用) 集群&lt;/h2>
&lt;p>为提升系统可用性，组合多台主机构建的集群称为 &lt;strong>High Availability(高可用，简称 HA)&lt;/strong> 集群&lt;/p>
&lt;p>HA 的作用：为避免单一资源损坏导致业务终端，那么就需要增加备用资源，当主资源坏了之后，备用资源可以立刻接替已坏资源的工作继续提供服务。两个资源中间需要交换数据以确认对方是否是正常运行，是否需要把备用资源启动成主资源提供服务，这种检测机制就是 heartbeat 心跳检测。（注意：资源包括但不限于真实物理机，虚拟机，操作系统，系统中的一个应用程序，系统中的一个进程等等。比如，当一台主机宕机了，可以由另一台主机接管；当系统中的 web 进程终止了，由另一台设备的 web 进程提供服务）&lt;/p>
&lt;h3 id="ha-的实现方式">HA 的实现方式&lt;/h3>
&lt;ul>
&lt;li>keepalived&lt;/li>
&lt;/ul>
&lt;h1 id="distributed分布式系统概述">Distributed(分布式)系统概述&lt;/h1>
&lt;blockquote>
&lt;p>参考文章：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://www.cnblogs.com/xybaby/p/7787034.html">https://www.cnblogs.com/xybaby/p/7787034.html&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>分布式系统是由一组通过网络进行通信、为了完成共同的任务而协调工作的计算机节点组成的系统。分布式系统的出现是为了用廉价的、普通的机器完成单个计算机无法完成的计算、存储任务。其目的是利用更多的机器，处理更多的数据。&lt;/p>
&lt;ol>
&lt;li>系统的各个组件分布于网络上的多个 NODE 上&lt;/li>
&lt;li>各组件之间仅仅通过消息传递来通信并协调行动&lt;/li>
&lt;/ol>
&lt;p>分布式系统存在的意义&lt;/p>
&lt;ol>
&lt;li>向上扩展的性价比越来越低&lt;/li>
&lt;li>单机扩展存在性能上升临界点&lt;/li>
&lt;li>处于稳定性以及可用性考虑，单机会存在多方面的问题&lt;/li>
&lt;/ol>
&lt;p>分布式计算：YARN&lt;/p>
&lt;p>batch：MapReduce&lt;/p>
&lt;p>in-memory:spark&lt;/p>
&lt;p>stream：storm&lt;/p>
&lt;h2 id="分布式系统的实现">分布式系统的实现&lt;/h2>
&lt;ul>
&lt;li>
&lt;p>负载均衡：&lt;/p>
&lt;ul>
&lt;li>Nginx：高性能、高并发的 web 服务器；功能包括负载均衡、反向代理、静态内容缓存、访问控制；工作在应用层&lt;/li>
&lt;li>LVS： Linux virtual server，基于集群技术和 Linux 操作系统实现一个高性能、高可用的服务器；工作在网络层&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>webserver：&lt;/p>
&lt;ul>
&lt;li>Java：Tomcat，Apache，Jboss&lt;/li>
&lt;li>Python：gunicorn、uwsgi、twisted、webpy、tornado&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>service：&lt;/p>
&lt;ul>
&lt;li>SOA、微服务、spring boot，django&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>容器：&lt;/p>
&lt;ul>
&lt;li>docker，kubernetes&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>cache：&lt;/p>
&lt;ul>
&lt;li>memcache、redis 等&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>协调中心、仲裁系统：分布式协作协议，分布式系统中只要存在主备节点这种角色，则必须要有一套系统来选举出来哪个是主的，这就是仲裁系统的由来&lt;/p>
&lt;ul>
&lt;li>zookeeper、etcd、VRRP、corosync 等&lt;/li>
&lt;li>zookeeper 使用了 Paxos 协议 Paxos 是强一致性，高可用的去中心化分布式。zookeeper 的使用场景非常广泛，之后细讲。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>rpc 框架：&lt;/p>
&lt;ul>
&lt;li>grpc、dubbo、brpc&lt;/li>
&lt;li>dubbo 是阿里开源的 Java 语言开发的高性能 RPC 框架，在阿里系的诸多架构中，都使用了 dubbo + spring boot&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>消息队列：&lt;/p>
&lt;ul>
&lt;li>kafka、rabbitMQ、rocketMQ、QSP&lt;/li>
&lt;li>消息队列的应用场景：异步处理、应用解耦、流量削锋和消息通讯&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>实时数据平台：&lt;/p>
&lt;ul>
&lt;li>storm、akka&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>离线数据平台：(分布式存储)&lt;/p>
&lt;ul>
&lt;li>hadoop(HDFS)、spark&lt;/li>
&lt;li>PS: apark、akka、kafka 都是 scala 语言写的，看到这个语言还是很牛逼的• dbproxy：&lt;/li>
&lt;li>cobar 也是阿里开源的，在阿里系中使用也非常广泛，是关系型数据库的 sharding + replica 代理&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>db：&lt;/p>
&lt;ul>
&lt;li>mysql、oracle、MongoDB、HBase&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>搜索：&lt;/p>
&lt;ul>
&lt;li>elasticsearch、solr&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>日志：&lt;/p>
&lt;ul>
&lt;li>rsyslog、elk、flume&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h2 id="分布式系统的基本问题可用性与一致性">分布式系统的基本问题：可用性与一致性&lt;/h2>
&lt;p>分布式系统的挑战&lt;/p>
&lt;p>一致性可理解为所有节点都能访问到最新版本的数据，这在单机场景下非常容易实现，使用共享内存和锁即可解决，但数据存储在单机会有两个限制：&lt;/p>
&lt;p>1）单机不可用系统整体将不可用；&lt;/p>
&lt;p>2）系统吞吐量受限于单机的计算能力。&lt;/p>
&lt;p>消除这两个限制的方法是用多机来存储数据的多个副本，负责更新的客户端会同时更新数据的多个副本，于是问题就来了，多机之间的网络可能无法连接，当负责更新的客户端无法同时到连接多个机器时，如何能保证所有客户端都能读到最新版本的数据？&lt;/p>
&lt;p>如下图 1 中所示，Client A 负责更新数据，为了保证 Server 1 和 Server 2 上的数据是一致的，Client A 会将 X=1 的写操作同时发给 Server 1 和 Server 2，但是当 Client A 和 Server 2 之间发生网络分区（网络无法连接）时，此时如果让 write X=1 的写操作在 Server 1 上成功，那 Client B 和 Client C 将从 Server 1 和 Server 2 上读取到不一致的 X 值；此时如果要保持 X 值的一致性，那么 write X=1 的写操作在 Server 1 和 Server 2 上都必须失败，这就是著名的 CAP 理论：在容忍网络分区的前提下，要么牺牲数据的一致性，要么牺牲写操作的可用性。&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/ge97s8/1616132737152-16151a6a-007b-46d9-9f95-30f279dce9c9.jpeg" alt="">&lt;/p>
&lt;p>图 1：CAP 理论示意图&lt;/p>
&lt;p>解决这个问题你可能会想到让 Client C 同时读取 Server 1 和 Server 2 上的 X 值和版本信息，然后取 Server 1 和 Server 2 最新版本的 X 值，如下图 2 所示。但 Client C 和 Server 1 之间也可能发生网络分区，这本质上是牺牲读可用性换取写可用性，并没有突破 CAP 理论。&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/ge97s8/1616132737170-045ed97b-a9dc-4ff6-8c3b-c3f55b86be73.jpeg" alt="">&lt;/p>
&lt;p>图 2：对图 1 中可用性的优化&lt;/p>
&lt;h2 id="cap-理论">CAP 理论&lt;/h2>
&lt;p>CAP 理论由加州大学伯克利分校的计算机教授 Eric Brewer 在 2000 年提出，其核心思想是任何基于网络的数据共享系统最多只能满足数据一致性(Consistency)、可用性(Availability)和网络分区容忍(Partition Tolerance)三个特性中的两个，三个特性的定义如下：&lt;/p>
&lt;ul>
&lt;li>&lt;strong>Consistency(数据一致性)&lt;/strong>：等同于所有节点拥有数据的最新版本&lt;/li>
&lt;li>&lt;strong>Availability(可用性)&lt;/strong>：数据具备高可用性&lt;/li>
&lt;li>&lt;strong>Partition Tolerance(分区容忍)&lt;/strong>：容忍网络出现分区，分区之间网络不可达&lt;/li>
&lt;/ul>
&lt;p>在大规模的分布式环境下，网络分区是必须容忍的现实，于是只能在可用性和一致性两者间做出选择，CAP 理论似乎给分布式系统定义了一个悲观的结局，一时间大家都按照 CAP 理论在对热门的分布式系统进行判定，譬如认为 HBase 是一个 CP 系统、Cassandra 是 AP 系统。&lt;/p>
&lt;p>我个人认为这是不严谨的，理由是 CAP 理论是对分布式系统中一个数据无法同时达到可用性和一致性的断言，而一个系统中往往存在很多类型的数据，部分数据（譬如银行账户中的余额）是需要强一致性的，而另外一部分数据（譬如银行的总客户数）并不要求强一致性，所以拿 CAP 理论来划分整个系统是不严谨的， CAP 理论带来的价值是指引我们在设计分布式系统时需要区分各种数据的特点，并仔细考虑在小概率的网络分区发生时究竟为该数据选择可用性还是一致性。&lt;/p>
&lt;p>对 CAP 理论的另外一种误读是系统设计时选择其一而完全不去优化另外一项，可用性和一致性的取值范围并不是只有 0 和 1，可用性的值域可以定义成 0 到 100%的连续区间，而一致性也可分为强一致性、弱一致性、读写一致性、最终一致性等多个不同的强弱等级，细想下去 CAP 理论定义的其实是在容忍网络分区的条件下，“强一致性”和“极致可用性”无法同时达到。&lt;/p>
&lt;p>（注：这里用“极致可用性”而不用“100%可用性”是因为即使不考虑一致性，多台 server 组成的分布式系统也达不到 100%的可用性，如果单个 server 的可用性是 P，那 n 台 server 的极致可用性是&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/ge97s8/1616132737170-80fe6908-dc56-498a-af88-7f6772b44251.jpeg" alt="">&lt;/p>
&lt;p>，公式的意思是只要任何一台或多台 server 可用就认为系统都是可用的）&lt;/p>
&lt;p>虽然无法达到同时达到强一致性和极致可用性，但我们可以根据数据类型在二者中选择其一后去优化另外一个，Paxos 协议就是一种在保证强一致性前提下把可用性优化到极限的算法。&lt;/p>
&lt;p>Paxos 协议&lt;/p>
&lt;p>Paxos 协议由 Leslie Lamport 最早在 1990 年提出，由于 Paxos 在云计算领域的广泛应用 Leslie Lamport 因此获得了 2013 年度图灵奖。&lt;/p>
&lt;p>Paxos 协议提出只要系统中 2f+1 个节点中的 f+1 个节点可用，那么系统整体就可用并且能保证数据的强一致性，它对于可用性的提升是极大的，仍然假设单节点的可用性是 P，那么 2f+1 个节点中任意组合的 f+1 以上个节点正常的可用性 P(total)=&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/ge97s8/1616132737159-28e7a301-dfb4-412a-92ad-6c68f3331af1.jpeg" alt="">&lt;/p>
&lt;p>，又假设 P=0.99，f=2，P(total)=0.9999901494，可用性将从单节点的 2 个 9 提升到了 5 个 9，这意味着系统每年的宕机时间从 87.6 小时降到 0.086 小时，这已经可以满足地球上 99.99999999%的应用需求。&lt;/p>
&lt;p>Leslie 写的两篇论文：《The Part-Time Parliament》和《Paxos Made Simple》比较完整的阐述了 Paxos 的工作流程和证明过程，Paxos 协议把每个数据写请求比喻成一次提案（proposal），每个提案都有一个独立的编号，提案会转发到提交者（Proposer）来提交，提案必须经过 2f+1 个节点中的 f+1 个节点接受才会生效，2f+1 个节点叫做这次提案的投票委员会(Quorum)，投票委员会中的节点叫做 Acceptor，Paxos 协议流程还需要满足两个约束条件：&lt;/p>
&lt;p>a）Acceptor 必须接受它收到的第一个提案；&lt;/p>
&lt;p>b）如果一个提案的 v 值被大多数 Acceptor 接受过，那后续的所有被接受的提案中也必须包含 v 值（v 值可以理解为提案的内容，提案由一个或多个 v 和提案编号组成）。&lt;/p>
&lt;p>Paxos 协议流程划分为两个阶段，第一阶段是 Proposer 学习提案最新状态的准备阶段；第二阶段是根据学习到的状态组成正确提案提交的阶段，完整的协议过程如下：&lt;/p>
&lt;p>阶段 1&lt;/p>
&lt;ol>
&lt;li>Proposer 选择一个提案编号 n ，然后向半数以上的 Acceptors 发送编号为 n 的 prepare 请求。&lt;/li>
&lt;li>如果一个 Acceptor 收到一个编号为 n 的 prepare 请求，且 n 大于它已经响应的所有 prepare 请求的编号，那么它就会保证不会再通过(accept)任何编号小于 n 的提案，同时将它已经通过的最大编号的提案(如果存在的话)作为响应。&lt;/li>
&lt;/ol>
&lt;p>阶段 2&lt;/p>
&lt;ol>
&lt;li>
&lt;p>如果 Proposer 收到来自半数以上的 Acceptor 对于它的 prepare 请求(编号为 n )的响应，那么它就会发送一个针对编号为 n ，value 值为 v 的提案的 accept 请求给 Acceptors，在这里 v 是收到的响应中编号最大的提案的值，如果响应中不包含提案，那么它就是任意值。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>如果 Acceptor 收到一个针对编号 n 的提案的 accept 请求，只要它还未对编号大于 n 的 prepare 请求作出响应，它就可以通过这个提案。&lt;/p>
&lt;/li>
&lt;/ol>
&lt;p>用时序图来描述 Paxos 协议如图 3 所示：&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/ge97s8/1616132737201-958df2f3-6832-438a-b517-9622d3409615.jpeg" alt="">&lt;/p>
&lt;p>图 3：Paxos 协议流程的时序图&lt;/p>
&lt;p>上述 Paxos 协议流程看起来比较复杂，是因为要保证很多边界条件下的协议完备性，譬如初试值为空、两个 Proposer 同时提交提案等情况，但 Paxos 协议的核心可以简单描述为：Proposer 先从大多数 Acceptor 那里学习提案的最新内容，然后根据学习到的编号最大的提案内容组成新的提案提交，如果提案获得大多数 Acceptor 的投票通过就意味着提案被通过。由于学习提案和通过提案的 Acceptor 集合都超过了半数，所以一定能学到最新通过的提案值，两次提案通过的 Acceptor 集合中也一定存在一个公共的 Acceptor，在满足约束条件 b 时这个公共的 Acceptor 时保证了数据的一致性，于是 Paxos 协议又被称为多数派协议。&lt;/p>
&lt;p>Paxos 协议的真正伟大之处在于它的简洁性，Paxos 协议流程中任何消息都是可以丢失的，一致性保证并不依赖某个特殊消息传递的成功，这极大的简化了分布式系统的设计，极其匹配分布式环境下网络可能分区的特点，相比较在 Paxos 协议之前的“两阶段提交（2PC）”也能保证数据强一致性，但复杂度相当高且依赖单个协调者的可用性。&lt;/p>
&lt;p>那既然 Paxos 如此强大，那为什么还会出现 ZAB 协议？&lt;/p>
&lt;p>ZAB 协议&lt;/p>
&lt;p>Paxos 协议虽然是完备的，但要把它应用到实际的分布式系统中还有些问题要解决：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>在多个 Proposer 的场景下，Paxos 不保证先提交的提案先被接受，实际应用中要保证多提案被接受的先后顺序怎么办？&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Paxos 允许多个 Proposer 提交提案，那有可能出现活锁问题，出现场景是这样的：提案 n 在第二阶段还没有完成时，新的提案 n+1 的第一阶段 prepare 请求到达 Acceptor，按协议规定 Acceptor 将响应新提案的 prepare 请求并保证不会接受小于 n+1 的任何请求，这可能导致提案 n 将不会被通过，同样在 n+1 提案未完成第二阶段时，假如提案 n 的提交者又提交了 n+2 提案，这可能导致 n+1 提案也无法通过。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Paxos 协议规定提案的值 v 只要被大多数 Acceptor 接受过，后续的所有提案不能修改值 v，那现实情况下我还要修改 v 值怎么办？&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>ZooKeeper 的核心算法 ZAB 通过一个简单的约束解决了前 2 个问题：所有提案都转发到唯一的 Leader（通过 Leader 选举算法从 Acceptor 中选出来的）来提交，由 Leader 来保证多个提案之间的先后顺序，同时也避免了多 Proposer 引发的活锁问题。&lt;/p>
&lt;p>ZAB 协议的过程用时序图描述如图 4 所示，相比 Paxos 协议省略了 Prepare 阶段，因为 Leader 本身就有提案的最新状态，不需要有提案内容学习的过程,图中的 Follower 对应 Paxos 协议中的 Acceptor，Observer 对应 Paxos 中的 Learner。&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/ge97s8/1616132737174-2acbb000-a721-40b7-bc06-4c671a70bb72.jpeg" alt="">&lt;/p>
&lt;p>图 4：ZAB 协议的工作过程&lt;/p>
&lt;p>ZAB 引入 Leader 后也会带来一个新问题： Leader 宕机了怎么办？其解决方案是选举出一个新的 Leader，选举 Leader 的过程也是一个 Paxos 提案决议过程，这里不展开讨论。&lt;/p>
&lt;p>那如何做到提案的值 v 可以修改呢？这不是 ZAB 协议的范畴，研究 ZooKeeper 源码后发现它是这么做的：ZooKeeper 提供了一个 znode 的概念，znode 可以被修改，ZooKeeper 对每个 znode 都记录了一个自增且连续的版本号，对 znode 的任何修改操作（create/set/setAcl）都会促发一次 Paxos 多数派投票过程，投票通过后 znode 版本号加 1，这相当于用 znode 不同版本的多次 Paxos 协议来破除单次 Paxos 协议无法修改提案值的限制。&lt;/p>
&lt;p>从保证一致性的算法核心角度看 ZAB 确实是借鉴了 Paxos 的多数派思想，但它提供的全局时序保证以及 ZooKeeper 提供给用户可修改的 znode 才让 Paxos 在开源界大放异彩，所以 ZAB 的价值不仅仅是提供了 Paxos 算法的优化实现，也难怪 ZAB 的作者一直强调 ZAB 和 Paxos 是不一样的算法。&lt;/p>
&lt;p>总结&lt;/p>
&lt;p>CAP 理论告诉我们在分布式环境下网络分区无法避免，需要去权衡选择数据的一致性和可用性，Paxos 协议提出了一种极其简单的算法在保障数据一致性时最大限度的优化了可用性，ZooKeeper 的 ZAB 协议把 Paxos 更加简化，并提供全局时序保证，使得 Paxos 能够广泛应用到工业场景。&lt;/p></description></item><item><title>Docs: 可能是把 ZooKeeper 概念讲的最清楚的一篇文章</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/3.%E9%9B%86%E7%BE%A4%E4%B8%8E%E5%88%86%E5%B8%83%E5%BC%8F/%E9%9B%86%E7%BE%A4%E4%B8%8E%E5%88%86%E5%B8%83%E5%BC%8F/%E5%8F%AF%E8%83%BD%E6%98%AF%E6%8A%8A-zookeeper-%E6%A6%82%E5%BF%B5%E8%AE%B2%E7%9A%84%E6%9C%80%E6%B8%85%E6%A5%9A%E7%9A%84%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/3.%E9%9B%86%E7%BE%A4%E4%B8%8E%E5%88%86%E5%B8%83%E5%BC%8F/%E9%9B%86%E7%BE%A4%E4%B8%8E%E5%88%86%E5%B8%83%E5%BC%8F/%E5%8F%AF%E8%83%BD%E6%98%AF%E6%8A%8A-zookeeper-%E6%A6%82%E5%BF%B5%E8%AE%B2%E7%9A%84%E6%9C%80%E6%B8%85%E6%A5%9A%E7%9A%84%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0/</guid><description>
&lt;h1 id="heading">&lt;/h1>
&lt;blockquote>
&lt;p>该文已加入开源文档：JavaGuide（一份涵盖大部分 Java 程序员所需要掌握的核心知识）。地址:&lt;a href="https://github.com/Snailclimb/JavaGuide">https://github.com/Snailclimb/JavaGuide&lt;/a>.&lt;/p>
&lt;/blockquote>
&lt;p>1. 前言&lt;/p>
&lt;p>相信大家对 ZooKeeper 应该不算陌生。但是你真的了解 ZooKeeper 到底有啥用不？如果别人/面试官让你给他讲讲对于 ZooKeeper 的认识，你能回答到什么地步呢？&lt;/p>
&lt;p>拿我自己来说吧！我本人曾经使用 Dubbo 来做分布式项目的时候，使用了 ZooKeeper 作为注册中心。为了保证分布式系统能够同步访问某个资源，我还使用 ZooKeeper 做过分布式锁。另外，我在学习 Kafka 的时候，知道 Kafka 很多功能的实现依赖了 ZooKeeper。&lt;/p>
&lt;p>前几天，总结项目经验的时候，我突然问自己 ZooKeeper 到底是个什么东西？想了半天，脑海中只是简单的能浮现出几句话：&lt;/p>
&lt;ol>
&lt;li>
&lt;p>ZooKeeper 可以被用作注册中心、分布式锁；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>ZooKeeper 是 Hadoop 生态系统的一员；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>构建 ZooKeeper 集群的时候，使用的服务器最好是奇数台。&lt;/p>
&lt;/li>
&lt;/ol>
&lt;p>由此可见，我对于 ZooKeeper 的理解仅仅是停留在了表面。&lt;/p>
&lt;p>所以，通过本文，希望带大家稍微详细的了解一下 ZooKeeper 。如果没有学过 ZooKeeper ，那么本文将会是你进入 ZooKeeper 大门的垫脚砖。如果你已经接触过 ZooKeeper ，那么本文将带你回顾一下 ZooKeeper 的一些基础概念。&lt;/p>
&lt;p>另外，本文不光会涉及到 ZooKeeper 的一些概念，后面的文章会介绍到 ZooKeeper 常见命令的使用以及使用 Apache Curator 作为 ZooKeeper 的客户端。&lt;/p>
&lt;p>&lt;em>如果文章有任何需要改善和完善的地方，欢迎在评论区指出，共同进步！&lt;/em>&lt;/p>
&lt;h2 id="2-zookeeper-介绍">2. ZooKeeper 介绍&lt;/h2>
&lt;h3 id="21-zookeeper-由来">2.1. ZooKeeper 由来&lt;/h3>
&lt;p>正式介绍 ZooKeeper 之前，我们先来看看 ZooKeeper 的由来，还挺有意思的。&lt;/p>
&lt;p>下面这段内容摘自《从 Paxos 到 ZooKeeper 》第四章第一节，推荐大家阅读一下：&lt;/p>
&lt;blockquote>
&lt;p>ZooKeeper 最早起源于雅虎研究院的一个研究小组。在当时，研究人员发现，在雅虎内部很多大型系统基本都需要依赖一个类似的系统来进行分布式协调，但是这些系统往往都存在分布式单点问题。所以，雅虎的开发人员就试图开发一个通用的无单点问题的分布式协调框架，以便让开发人员将精力集中在处理业务逻辑上。关于“ZooKeeper”这个项目的名字，其实也有一段趣闻。在立项初期，考虑到之前内部很多项目都是使用动物的名字来命名的（例如著名的 Pig 项目),雅虎的工程师希望给这个项目也取一个动物的名字。时任研究院的首席科学家 RaghuRamakrishnan 开玩笑地说：“在这样下去，我们这儿就变成动物园了！”此话一出，大家纷纷表示就叫动物园管理员吧一一一因为各个以动物命名的分布式组件放在一起，雅虎的整个分布式系统看上去就像一个大型的动物园了，而 ZooKeeper 正好要用来进行分布式环境的协调一一于是，ZooKeeper 的名字也就由此诞生了。&lt;/p>
&lt;/blockquote>
&lt;h3 id="22-zookeeper-概览">2.2. ZooKeeper 概览&lt;/h3>
&lt;p>ZooKeeper 是一个开源的&lt;strong>分布式协调服务&lt;/strong>，它的设计目标是将那些复杂且容易出错的分布式一致性服务封装起来，构成一个高效可靠的原语集，并以一系列简单易用的接口提供给用户使用。&lt;/p>
&lt;blockquote>
&lt;p>&lt;strong>原语：&lt;/strong> 操作系统或计算机网络用语范畴。是由若干条指令组成的，用于完成一定功能的一个过程。具有不可分割性·即原语的执行必须是连续的，在执行过程中不允许被中断。&lt;/p>
&lt;/blockquote>
&lt;p>&lt;strong>ZooKeeper 为我们提供了高可用、高性能、稳定的分布式数据一致性解决方案，通常被用于实现诸如数据发布/订阅、负载均衡、命名服务、分布式协调/通知、集群管理、Master 选举、分布式锁和分布式队列等功能。&lt;/strong>&lt;/p>
&lt;p>另外，&lt;strong>ZooKeeper 将数据保存在内存中，性能是非常棒的。 在“读”多于“写”的应用程序中尤其地高性能，因为“写”会导致所有的服务器间同步状态。（“读”多于“写”是协调服务的典型场景）。&lt;/strong>&lt;/p>
&lt;h3 id="23-zookeeper-特点">2.3. ZooKeeper 特点&lt;/h3>
&lt;ul>
&lt;li>
&lt;p>&lt;strong>顺序一致性：&lt;/strong> 从同一客户端发起的事务请求，最终将会严格地按照顺序被应用到 ZooKeeper 中去。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>原子性：&lt;/strong> 所有事务请求的处理结果在整个集群中所有机器上的应用情况是一致的，也就是说，要么整个集群中所有的机器都成功应用了某一个事务，要么都没有应用。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>单一系统映像 ：&lt;/strong> 无论客户端连到哪一个 ZooKeeper 服务器上，其看到的服务端数据模型都是一致的。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>可靠性：&lt;/strong> 一旦一次更改请求被应用，更改的结果就会被持久化，直到被下一次更改覆盖。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h3 id="24-zookeeper-典型应用场景">2.4. ZooKeeper 典型应用场景&lt;/h3>
&lt;p>ZooKeeper 概览中，我们介绍到使用其通常被用于实现诸如数据发布/订阅、负载均衡、命名服务、分布式协调/通知、集群管理、Master 选举、分布式锁和分布式队列等功能。&lt;/p>
&lt;p>下面选 3 个典型的应用场景来专门说说：&lt;/p>
&lt;ol>
&lt;li>
&lt;p>&lt;strong>分布式锁&lt;/strong> ： 通过创建唯一节点获得分布式锁，当获得锁的一方执行完相关代码或者是挂掉之后就释放锁。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>命名服务&lt;/strong> ：可以通过 ZooKeeper 的顺序节点生成全局唯一 ID&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>数据发布/订阅&lt;/strong> ：通过 &lt;strong>Watcher 机制&lt;/strong> 可以很方便地实现数据发布/订阅。当你将数据发布到 ZooKeeper 被监听的节点上，其他机器可通过监听 ZooKeeper 上节点的变化来实现配置的动态更新。&lt;/p>
&lt;/li>
&lt;/ol>
&lt;p>实际上，这些功能的实现基本都得益于 ZooKeeper 可以保存数据的功能，但是 ZooKeeper 不适合保存大量数据，这一点需要注意。&lt;/p>
&lt;h3 id="25-有哪些著名的开源项目用到了-zookeeper">2.5. 有哪些著名的开源项目用到了 ZooKeeper?&lt;/h3>
&lt;ol>
&lt;li>
&lt;p>&lt;strong>Kafka&lt;/strong> : ZooKeeper 主要为 Kafka 提供 Broker 和 Topic 的注册以及多个 Partition 的负载均衡等功能。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>Hbase&lt;/strong> : ZooKeeper 为 Hbase 提供确保整个集群只有一个 Master 以及保存和提供 regionserver 状态信息（是否在线）等功能。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>Hadoop&lt;/strong> : ZooKeeper 为 Namenode 提供高可用支持。&lt;/p>
&lt;/li>
&lt;/ol>
&lt;h2 id="3-zookeeper-重要概念解读">3. ZooKeeper 重要概念解读&lt;/h2>
&lt;p>&lt;em>破音：拿出小本本，下面的内容非常重要哦！&lt;/em>&lt;/p>
&lt;h3 id="31-data-model数据模型">3.1. Data model（数据模型）&lt;/h3>
&lt;p>ZooKeeper 数据模型采用层次化的多叉树形结构，每个节点上都可以存储数据，这些数据可以是数字、字符串或者是二级制序列。并且。每个节点还可以拥有 N 个子节点，最上层是根节点以“/”来代表。每个数据节点在 ZooKeeper 中被称为 &lt;strong>znode&lt;/strong>，它是 ZooKeeper 中数据的最小单元。并且，每个 znode 都一个唯一的路径标识。&lt;/p>
&lt;p>强调一句：&lt;strong>ZooKeeper 主要是用来协调服务的，而不是用来存储业务数据的，所以不要放比较大的数据在 znode 上，ZooKeeper 给出的上限是每个结点的数据大小最大是 1M。&lt;/strong>&lt;/p>
&lt;p>从下图可以更直观地看出：ZooKeeper 节点路径标识方式和 Unix 文件系统路径非常相似，都是由一系列使用斜杠&amp;quot;/&amp;ldquo;进行分割的路径表示，开发人员可以向这个节点中写人数据，也可以在节点下面创建子节点。这些操作我们后面都会介绍到。&lt;/p>
&lt;h3 id="32-znode数据节点">3.2. znode（数据节点）&lt;/h3>
&lt;p>介绍了 ZooKeeper 树形数据模型之后，我们知道每个数据节点在 ZooKeeper 中被称为 &lt;strong>znode&lt;/strong>，它是 ZooKeeper 中数据的最小单元。你要存放的数据就放在上面，是你使用 ZooKeeper 过程中经常需要接触到的一个概念。&lt;/p>
&lt;p>3.2.1. znode 4 种类型&lt;/p>
&lt;p>我们通常是将 znode 分为 4 大类：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>&lt;strong>持久（PERSISTENT）节点&lt;/strong> ：一旦创建就一直存在即使 ZooKeeper 集群宕机，直到将其删除。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>临时（EPHEMERAL）节点&lt;/strong> ：临时节点的生命周期是与 &lt;strong>客户端会话（session）&lt;/strong> 绑定的，&lt;strong>会话消失则节点消失&lt;/strong> 。并且，&lt;strong>临时节点只能做叶子节点&lt;/strong> ，不能创建子节点。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>持久顺序（PERSISTENT_SEQUENTIAL）节点&lt;/strong> ：除了具有持久（PERSISTENT）节点的特性之外， 子节点的名称还具有顺序性。比如 &lt;code>/node1/app0000000001&lt;/code> 、&lt;code>/node1/app0000000002&lt;/code> 。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>临时顺序（EPHEMERAL_SEQUENTIAL）节点&lt;/strong> ：除了具备临时（EPHEMERAL）节点的特性之外，子节点的名称还具有顺序性。&lt;/p>
&lt;p>3.2.2. znode 数据结构&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>每个 znode 由 2 部分组成:&lt;/p>
&lt;ul>
&lt;li>
&lt;p>&lt;strong>stat&lt;/strong> ：状态信息&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>data&lt;/strong> ： 节点存放的数据的具体内容&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>如下所示，我通过 get 命令来获取 根目录下的 dubbo 节点的内容。（get 命令在下面会介绍到）。&lt;/p>
&lt;pre>&lt;code>[zk: 127.0.0.1:2181(CONNECTED) 6] get /dubbo
# 该数据节点关联的数据内容为空
null
# 下面是该数据节点的一些状态信息，其实就是 Stat 对象的格式化输出
cZxid = 0x2
ctime = Tue Nov 27 11:05:34 CST 2018
mZxid = 0x2
mtime = Tue Nov 27 11:05:34 CST 2018
pZxid = 0x3
cversion = 1
dataVersion = 0
aclVersion = 0
ephemeralOwner = 0x0
dataLength = 0
numChildren = 1
&lt;/code>&lt;/pre>
&lt;p>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
Plain Text&lt;/p>
&lt;p>Stat 类中包含了一个数据节点的所有状态信息的字段，包括事务 ID-cZxid、节点创建时间-ctime 和子节点个数-numChildren 等等。&lt;/p>
&lt;p>下面我们来看一下每个 znode 状态信息究竟代表的是什么吧！（下面的内容来源于《从 Paxos 到 ZooKeeper 分布式一致性原理与实践》，因为 Guide 确实也不是特别清楚，要学会参考资料的嘛！ ） ：&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>&lt;/th>
&lt;th>&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>znode 状态信息&lt;/td>
&lt;td>解释&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>cZxid&lt;/td>
&lt;td>create ZXID，即该数据节点被创建时的事务 id&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>ctime&lt;/td>
&lt;td>create time，即该节点的创建时间&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>mZxid&lt;/td>
&lt;td>modified ZXID，即该节点最终一次更新时的事务 id&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>mtime&lt;/td>
&lt;td>modified time，即该节点最后一次的更新时间&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>pZxid&lt;/td>
&lt;td>该节点的子节点列表最后一次修改时的事务 id，只有子节点列表变更才会更新 pZxid，子节点内容变更不会更新&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>cversion&lt;/td>
&lt;td>子节点版本号，当前节点的子节点每次变化时值增加 1&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>dataVersion&lt;/td>
&lt;td>数据节点内容版本号，节点创建时为 0，每更新一次节点内容(不管内容有无变化)该版本号的值增加 1&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>aclVersion&lt;/td>
&lt;td>节点的 ACL 版本号，表示该节点 ACL 信息变更次数&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>ephemeralOwner&lt;/td>
&lt;td>创建该临时节点的会话的 sessionId；如果当前节点为持久节点，则 ephemeralOwner=0&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>dataLength&lt;/td>
&lt;td>数据节点内容长度&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>numChildren&lt;/td>
&lt;td>当前节点的子节点个数&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="33-版本version">3.3. 版本（version）&lt;/h3>
&lt;p>在前面我们已经提到，对应于每个 znode，ZooKeeper 都会为其维护一个叫作 &lt;strong>Stat&lt;/strong> 的数据结构，Stat 中记录了这个 znode 的三个相关的版本：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>&lt;strong>dataVersion&lt;/strong> ：当前 znode 节点的版本号&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>cversion&lt;/strong> ： 当前 znode 子节点的版本&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>aclVersion&lt;/strong> ： 当前 znode 的 ACL 的版本。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h3 id="34-acl权限控制">3.4. ACL（权限控制）&lt;/h3>
&lt;p>ZooKeeper 采用 ACL（AccessControlLists）策略来进行权限控制，类似于 UNIX 文件系统的权限控制。&lt;/p>
&lt;p>对于 znode 操作的权限，ZooKeeper 提供了以下 5 种：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>&lt;strong>CREATE&lt;/strong> : 能创建子节点&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>READ&lt;/strong> ：能获取节点数据和列出其子节点&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>WRITE&lt;/strong> : 能设置/更新节点数据&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>DELETE&lt;/strong> : 能删除子节点&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>ADMIN&lt;/strong> : 能设置节点 ACL 的权限&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>其中尤其需要注意的是，&lt;strong>CREATE&lt;/strong> 和 &lt;strong>DELETE&lt;/strong> 这两种权限都是针对 &lt;strong>子节点&lt;/strong> 的权限控制。&lt;/p>
&lt;p>对于身份认证，提供了以下几种方式：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>&lt;strong>world&lt;/strong> ： 默认方式，所有用户都可无条件访问。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>auth&lt;/strong> :不使用任何 id，代表任何已认证的用户。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>digest&lt;/strong> :用户名:密码认证方式： &lt;em>username:password&lt;/em> 。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>ip&lt;/strong> : 对指定 ip 进行限制。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h3 id="35-watcher事件监听器">3.5. Watcher（事件监听器）&lt;/h3>
&lt;p>Watcher（事件监听器），是 ZooKeeper 中的一个很重要的特性。ZooKeeper 允许用户在指定节点上注册一些 Watcher，并且在一些特定事件触发的时候，ZooKeeper 服务端会将事件通知到感兴趣的客户端上去，该机制是 ZooKeeper 实现分布式协调服务的重要特性。&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/gn3rcr/1616130259256-38dfceb6-4eff-4fb1-a41c-f2383f96b8e9.png" alt="">&lt;/p>
&lt;p>&lt;em>破音：非常有用的一个特性，都能出小本本记好了，后面用到 ZooKeeper 基本离不开 Watcher（事件监听器）机制。&lt;/em>&lt;/p>
&lt;h3 id="36-会话session">3.6. 会话（Session）&lt;/h3>
&lt;p>Session 可以看作是 ZooKeeper 服务器与客户端的之间的一个 TCP 长连接，通过这个连接，客户端能够通过心跳检测与服务器保持有效的会话，也能够向 ZooKeeper 服务器发送请求并接受响应，同时还能够通过该连接接收来自服务器的 Watcher 事件通知。&lt;/p>
&lt;p>Session 有一个属性叫做：&lt;code>sessionTimeout&lt;/code> ，&lt;code>sessionTimeout&lt;/code> 代表会话的超时时间。当由于服务器压力太大、网络故障或是客户端主动断开连接等各种原因导致客户端连接断开时，只要在&lt;code>sessionTimeout&lt;/code>规定的时间内能够重新连接上集群中任意一台服务器，那么之前创建的会话仍然有效。另外，在为客户端创建会话之前，服务端首先会为每个客户端都分配一个 &lt;code>sessionID&lt;/code>。由于 &lt;code>sessionID&lt;/code>是 ZooKeeper 会话的一个重要标识，许多与会话相关的运行机制都是基于这个 &lt;code>sessionID&lt;/code> 的，因此，无论是哪台服务器为客户端分配的 &lt;code>sessionID&lt;/code>，都务必保证全局唯一。&lt;/p>
&lt;h2 id="4-zookeeper-集群">4. ZooKeeper 集群&lt;/h2>
&lt;p>为了保证高可用，最好是以集群形态来部署 ZooKeeper，这样只要集群中大部分机器是可用的（能够容忍一定的机器故障），那么 ZooKeeper 本身仍然是可用的。通常 3 台服务器就可以构成一个 ZooKeeper 集群了。ZooKeeper 官方提供的架构图就是一个 ZooKeeper 集群整体对外提供服务。&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/gn3rcr/1616130259317-567b57ec-3ff9-408d-81ac-fb1c74b69c18.png" alt="">&lt;/p>
&lt;p>上图中每一个 Server 代表一个安装 ZooKeeper 服务的服务器。组成 ZooKeeper 服务的服务器都会在内存中维护当前的服务器状态，并且每台服务器之间都互相保持着通信。集群间通过 ZAB 协议（ZooKeeper Atomic Broadcast）来保持数据的一致性。&lt;/p>
&lt;p>&lt;strong>最典型集群模式： Master/Slave 模式（主备模式）&lt;/strong>。在这种模式中，通常 Master 服务器作为主服务器提供写服务，其他的 Slave 服务器从服务器通过异步复制的方式获取 Master 服务器最新的数据提供读服务。&lt;/p>
&lt;h3 id="41-zookeeper-集群角色">4.1. ZooKeeper 集群角色&lt;/h3>
&lt;p>但是，在 ZooKeeper 中没有选择传统的 Master/Slave 概念，而是引入了 Leader、Follower 和 Observer 三种角色。如下图所示&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/gn3rcr/1616130259179-822f082a-f721-4744-b57a-eab7e0da264b.png" alt="">&lt;/p>
&lt;p>ZooKeeper 集群中的所有机器通过一个 &lt;strong>Leader 选举过程&lt;/strong> 来选定一台称为 “&lt;strong>Leader&lt;/strong>” 的机器，Leader 既可以为客户端提供写服务又能提供读服务。除了 Leader 外，&lt;strong>Follower&lt;/strong> 和 &lt;strong>Observer&lt;/strong> 都只能提供读服务。Follower 和 Observer 唯一的区别在于 Observer 机器不参与 Leader 的选举过程，也不参与写操作的“过半写成功”策略，因此 Observer 机器可以在不影响写性能的情况下提升集群的读性能。&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>&lt;/th>
&lt;th>&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>角色&lt;/td>
&lt;td>说明&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Leader&lt;/td>
&lt;td>为客户端提供读和写的服务，负责投票的发起和决议，更新系统状态。&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Follower&lt;/td>
&lt;td>为客户端提供读服务，如果是写服务则转发给 Leader。在选举过程中参与投票。&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Observer&lt;/td>
&lt;td>为客户端提供读服务器，如果是写服务则转发给 Leader。不参与选举过程中的投票，也不参与“过半写成功”策略。在不影响写性能的情况下提升集群的读性能。此角色于 ZooKeeper3.3 系列新增的角色。&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>当 Leader 服务器出现网络中断、崩溃退出与重启等异常情况时，就会进入 Leader 选举过程，这个过程会选举产生新的 Leader 服务器。&lt;/p>
&lt;p>这个过程大致是这样的：&lt;/p>
&lt;ol>
&lt;li>
&lt;p>&lt;strong>Leader election（选举阶段）&lt;/strong>：节点在一开始都处于选举阶段，只要有一个节点得到超半数节点的票数，它就可以当选准 leader。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>Discovery（发现阶段）&lt;/strong> ：在这个阶段，followers 跟准 leader 进行通信，同步 followers 最近接收的事务提议。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>Synchronization（同步阶段）&lt;/strong> :同步阶段主要是利用 leader 前一阶段获得的最新提议历史，同步集群中所有的副本。同步完成之后 准 leader 才会成为真正的 leader。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>Broadcast（广播阶段）&lt;/strong> :到了这个阶段，ZooKeeper 集群才能正式对外提供事务服务，并且 leader 可以进行消息广播。同时如果有新的节点加入，还需要对新节点进行同步。&lt;/p>
&lt;/li>
&lt;/ol>
&lt;h3 id="42-zookeeper-集群中的服务器状态">4.2. ZooKeeper 集群中的服务器状态&lt;/h3>
&lt;ul>
&lt;li>
&lt;p>&lt;strong>LOOKING&lt;/strong> ：寻找 Leader。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>LEADING&lt;/strong> ：Leader 状态，对应的节点为 Leader。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>FOLLOWING&lt;/strong> ：Follower 状态，对应的节点为 Follower。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>OBSERVING&lt;/strong> ：Observer 状态，对应节点为 Observer，该节点不参与 Leader 选举。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h3 id="43-zookeeper-集群为啥最好奇数台">4.3. ZooKeeper 集群为啥最好奇数台？&lt;/h3>
&lt;p>ZooKeeper 集群在宕掉几个 ZooKeeper 服务器之后，如果剩下的 ZooKeeper 服务器个数大于宕掉的个数的话整个 ZooKeeper 才依然可用。假如我们的集群中有 n 台 ZooKeeper 服务器，那么也就是剩下的服务数必须大于 n/2。先说一下结论，2n 和 2n-1 的容忍度是一样的，都是 n-1，大家可以先自己仔细想一想，这应该是一个很简单的数学问题了。 比如假如我们有 3 台，那么最大允许宕掉 1 台 ZooKeeper 服务器，如果我们有 4 台的的时候也同样只允许宕掉 1 台。 假如我们有 5 台，那么最大允许宕掉 2 台 ZooKeeper 服务器，如果我们有 6 台的的时候也同样只允许宕掉 2 台。&lt;/p>
&lt;p>综上，何必增加那一个不必要的 ZooKeeper 呢？&lt;/p>
&lt;h2 id="5-zab-协议和-paxos-算法">5. ZAB 协议和 Paxos 算法&lt;/h2>
&lt;p>Paxos 算法应该可以说是 ZooKeeper 的灵魂了。但是，ZooKeeper 并没有完全采用 Paxos 算法 ，而是使用 ZAB 协议作为其保证数据一致性的核心算法。另外，在 ZooKeeper 的官方文档中也指出，ZAB 协议并不像 Paxos 算法那样，是一种通用的分布式一致性算法，它是一种特别为 Zookeeper 设计的崩溃可恢复的原子消息广播算法。&lt;/p>
&lt;h3 id="51-zab-协议介绍">5.1. ZAB 协议介绍&lt;/h3>
&lt;p>ZAB（ZooKeeper Atomic Broadcast 原子广播） 协议是为分布式协调服务 ZooKeeper 专门设计的一种支持崩溃恢复的原子广播协议。 在 ZooKeeper 中，主要依赖 ZAB 协议来实现分布式数据一致性，基于该协议，ZooKeeper 实现了一种主备模式的系统架构来保持集群中各个副本之间的数据一致性。&lt;/p>
&lt;h3 id="52-zab-协议两种基本的模式崩溃恢复和消息广播">5.2. ZAB 协议两种基本的模式：崩溃恢复和消息广播&lt;/h3>
&lt;p>ZAB 协议包括两种基本的模式，分别是&lt;/p>
&lt;ul>
&lt;li>
&lt;p>&lt;strong>崩溃恢复&lt;/strong> ：当整个服务框架在启动过程中，或是当 Leader 服务器出现网络中断、崩溃退出与重启等异常情况时，ZAB 协议就会进入恢复模式并选举产生新的 Leader 服务器。当选举产生了新的 Leader 服务器，同时集群中已经有过半的机器与该 Leader 服务器完成了状态同步之后，ZAB 协议就会退出恢复模式。其中，&lt;strong>所谓的状态同步是指数据同步，用来保证集群中存在过半的机器能够和 Leader 服务器的数据状态保持一致&lt;/strong>。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>消息广播&lt;/strong> ：&lt;strong>当集群中已经有过半的 Follower 服务器完成了和 Leader 服务器的状态同步，那么整个服务框架就可以进入消息广播模式了。&lt;/strong> 当一台同样遵守 ZAB 协议的服务器启动后加入到集群中时，如果此时集群中已经存在一个 Leader 服务器在负责进行消息广播，那么新加入的服务器就会自觉地进入数据恢复模式：找到 Leader 所在的服务器，并与其进行数据同步，然后一起参与到消息广播流程中去。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>关于 &lt;strong>ZAB 协议&amp;amp;Paxos 算法&lt;/strong> 需要讲和理解的东西太多了，具体可以看下面这两篇文章：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>图解 Paxos 一致性协议&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Zookeeper ZAB 协议分析&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h2 id="6-总结">6. 总结&lt;/h2>
&lt;ol>
&lt;li>
&lt;p>ZooKeeper 本身就是一个分布式程序（只要半数以上节点存活，ZooKeeper 就能正常服务）。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>为了保证高可用，最好是以集群形态来部署 ZooKeeper，这样只要集群中大部分机器是可用的（能够容忍一定的机器故障），那么 ZooKeeper 本身仍然是可用的。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>ZooKeeper 将数据保存在内存中，这也就保证了 高吞吐量和低延迟（但是内存限制了能够存储的容量不太大，此限制也是保持 znode 中存储的数据量较小的进一步原因）。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>ZooKeeper 是高性能的。 在“读”多于“写”的应用程序中尤其地明显，因为“写”会导致所有的服务器间同步状态。（“读”多于“写”是协调服务的典型场景。）&lt;/p>
&lt;/li>
&lt;li>
&lt;p>ZooKeeper 有临时节点的概念。 当创建临时节点的客户端会话一直保持活动，瞬时节点就一直存在。而当会话终结时，瞬时节点被删除。持久节点是指一旦这个 znode 被创建了，除非主动进行 znode 的移除操作，否则这个 znode 将一直保存在 ZooKeeper 上。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>ZooKeeper 底层其实只提供了两个功能：① 管理（存储、读取）用户程序提交的数据；② 为用户程序提供数据节点监听服务。&lt;/p>
&lt;/li>
&lt;/ol>
&lt;h2 id="7-参考">7. 参考&lt;/h2>
&lt;ol>
&lt;li>《从 Paxos 到 ZooKeeper 分布式一致性原理与实践》&lt;/li>
&lt;/ol></description></item><item><title>Docs: 其他属于 NGX_CORE_MODULE 类型的模块</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/3.%E9%9B%86%E7%BE%A4%E4%B8%8E%E5%88%86%E5%B8%83%E5%BC%8F/nginx/nginx-%E9%85%8D%E7%BD%AE%E8%AF%A6%E8%A7%A3/%E5%85%B6%E4%BB%96%E5%B1%9E%E4%BA%8E-ngx_core_module-%E7%B1%BB%E5%9E%8B%E7%9A%84%E6%A8%A1%E5%9D%97/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/3.%E9%9B%86%E7%BE%A4%E4%B8%8E%E5%88%86%E5%B8%83%E5%BC%8F/nginx/nginx-%E9%85%8D%E7%BD%AE%E8%AF%A6%E8%A7%A3/%E5%85%B6%E4%BB%96%E5%B1%9E%E4%BA%8E-ngx_core_module-%E7%B1%BB%E5%9E%8B%E7%9A%84%E6%A8%A1%E5%9D%97/</guid><description>
&lt;h1 id="ngx_conf_module">NGX_CONF_MODULE&lt;/h1>
&lt;p>&lt;a href="http://nginx.org/en/docs/ngx_core_module.html#include">&lt;strong>include /PATH/FILE&lt;/strong>&lt;/a>** **# 在该配置中包含一个网站-可用的配置文件，即把定义的文件内容引入到这里，(也可以写入多个 include，引入多个配置文件以便管理，包括但不限于 server 配置，还可以是 nginx 的配置文件，mail 的配置文件等)&lt;/p>
&lt;ul>
&lt;li>作用范围：可以作用在任意 Contexts 中&lt;/li>
&lt;/ul>
&lt;p>该指令可以写在任意 块指令 中，只要被包含的文件格式，符合当前 块指令 应该包含的语法即可。&lt;/p></description></item><item><title>Docs: 问题实例：Keepalived 非抢占模式 VIP 不漂移</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/3.%E9%9B%86%E7%BE%A4%E4%B8%8E%E5%88%86%E5%B8%83%E5%BC%8F/keepalived/%E9%97%AE%E9%A2%98%E5%AE%9E%E4%BE%8Bkeepalived-%E9%9D%9E%E6%8A%A2%E5%8D%A0%E6%A8%A1%E5%BC%8F-vip-%E4%B8%8D%E6%BC%82%E7%A7%BB/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/3.%E9%9B%86%E7%BE%A4%E4%B8%8E%E5%88%86%E5%B8%83%E5%BC%8F/keepalived/%E9%97%AE%E9%A2%98%E5%AE%9E%E4%BE%8Bkeepalived-%E9%9D%9E%E6%8A%A2%E5%8D%A0%E6%A8%A1%E5%BC%8F-vip-%E4%B8%8D%E6%BC%82%E7%A7%BB/</guid><description>
&lt;h1 id="keepalived-非抢占模式下-vip-不漂移问题">Keepalived 非抢占模式下 VIP 不漂移问题&lt;/h1>
&lt;p>Keepalived 主要是通过虚拟路由冗余来实现高可用功能。本文将不对 keepalived 的基本原理进行阐述，可参考文章 Keepalived 详细介绍简介、keepalived vip 漂移基本原理及选举算法。本文记录了在实践过程中使用 keepalived 时，在 weight 值变化的情况下 vip 不漂移的问题及解决方法。&lt;/p>
&lt;p>场景&lt;/p>
&lt;p>3 个 keepalived 节点, vip 为 172.31.23.6：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>devops1a-zoocassa0 172.31.23.22&lt;/p>
&lt;/li>
&lt;li>
&lt;p>devops1a-zoocassa1 172.31.23.23&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>预期&lt;/p>
&lt;ol>
&lt;li>
&lt;p>两个节点初始都设为 BACKUP，按照优先级（priority）选举 MASTER；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>在两个节点上检查 memcached 服务状态，失败则降低优先级；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>如果 MASTER(假设为 devops1a-zoocassa0)上检查失败，BACKUP 上检查成功，则优先级高的 BACKUP 节点(假设为 devops1a-zoocassa1)切换为 MASTER 节点；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>之前检查失败的 MASTER(devops1a-zoocassa0)上的服务恢复时, 之前的 BACKUP 节点(devops1a-zoocassa1)服务检查也成功，即使 devops1a-zoocassa0 优先级恢复到高于 devops1a-zoocassa1,也不再成为 MASTER(不抢占)。&lt;/p>
&lt;/li>
&lt;/ol>
&lt;h2 id="不成功配置范例">不成功配置范例&lt;/h2>
&lt;p>主节点 dr-1 配置&lt;/p>
&lt;pre>&lt;code>global_defs {
router_id k8s-master-dr
}
vrrp_script check_nginx {
script &amp;quot;pidof nginx&amp;quot;
interval 3
weight -2
fall 2
rise 2
}
vrrp_instance VI_K8S {
state BACKUP
interface eth0
virtual_router_id 60
priority 101
nopreempt
authentication {
auth_type PASS
auth_pass 4be37dc3b4c90194d1600c483e10ad1d
}
virtual_ipaddress {
172.40.0.60
}
track_script {
check_nginx
}
}
&lt;/code>&lt;/pre>
&lt;p>备节点 dr-2 配置&lt;/p>
&lt;pre>&lt;code>global_defs {
router_id k8s-master-dr
}
vrrp_script check_nginx {
script &amp;quot;pidof nginx&amp;quot;
interval 3
weight -2
fall 2
rise 2
}
vrrp_instance VI_K8S {
state BACKUP
interface eth0
virtual_router_id 60
priority 100
nopreempt
authentication {
auth_type PASS
auth_pass 4be37dc3b4c90194d1600c483e10ad1d
}
virtual_ipaddress {
172.40.0.60
}
track_script {
check_nginx
}
}
&lt;/code>&lt;/pre>
&lt;p>以上述配置文件内容作为 keepalived 配置文件 /etc/keepalived/keepalived.conf，在两个个节点上启动 keepalived：&lt;code>systemctl restart keepalived&lt;/code>&lt;/p>
&lt;p>会发现存在如下问题：&lt;/p>
&lt;ol>
&lt;li>
&lt;p>优先级高的 dr-1 可能没有成为 MASTER 节点（多试几次，可能每次选举的 MASTER 节点都不同），不符合预期中的第 1 点；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>假设 dr-1 成为了 MASTER 节点，关掉 dr-1 上的 memcached 服务：&lt;code>systemctl stop keepalived&lt;/code>&lt;/p>
&lt;/li>
&lt;/ol>
&lt;p>此时运行 service keepalived status，发现 dr-1 的 weight 值降低且低于 dr-2 ，但是 dr-2 并没有成为 MASTER 节点，不符合预期中的第 3 点。&lt;/p>
&lt;ol>
&lt;li>将配置文件中的 nginx 去掉以后，可以解决上述问题，符合预期中的第 1，2，3 点，但是当原 MASTER 节点上服务恢复后，原 MASTER 会重新成为 MASTER 角色，这不符合预期中的第 4 点（不抢占）；&lt;/li>
&lt;/ol>
&lt;h2 id="问题原因">问题原因：&lt;/h2>
&lt;p>在网上查阅到的资料中，大都认为按照上述配置后可以完全符合预期中的 4 个点，不会出现 MASTER 节点服务检查失败后 VIP 不漂移的问题。但是实践是检验真理的唯一标准，配置 nopreemt 后，不仅是会让原 MASTER 节点服务恢复后不抢占，而是会完全的不选举新 MASTER(从头到尾永远不切换，除非 BACKUP 认为当前集群中不存在 MASTER, 才会重新选举)，这样便可以解释出现的问题 1 和问题 2 了：&lt;/p>
&lt;p>问题 1 的原因在于：&lt;/p>
&lt;ol>
&lt;li>
&lt;p>先启动的节点将自己选举为 MASTER, 在收到其他节点的 vrrp 报文后不会按照优先级调整自己的角色；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>后启动的节点收到了 MASTER 的 vrrp 报文，发现已经存在 MASTER，由于不抢占，自动进入 BACKUP 状态；&lt;/p>
&lt;/li>
&lt;/ol>
&lt;p>问题 2 的原因在于：&lt;/p>
&lt;ol>
&lt;li>设置了 nopreempt, 永远不发生角色切换；&lt;/li>
&lt;/ol>
&lt;p>下面是官方文档中对于 nopreempt 的解释：&lt;/p>
&lt;pre>&lt;code>&amp;quot;nopreempt&amp;quot; allows the lower priority machine to maintain the master role,
even when a higher priority machine comes back online.
NOTE: For this to work, the initial state of this entry must be BACKUP.
&lt;/code>&lt;/pre>
&lt;h2 id="解决方案">解决方案&lt;/h2>
&lt;p>要想同时满足预期中的效果，其实只要做到两点：&lt;/p>
&lt;p>当 MASTER 上的服务检查失败时，触发重新选举；&lt;/p>
&lt;p>设置不抢占（已经做到）；&lt;/p>
&lt;p>那么如何实现第一点呢？重新选举意味着:&lt;/p>
&lt;ol>
&lt;li>
&lt;p>BACKUP 成为 MASTER，要求 BACKUP 节点认为当前节点中没有 MASTER 节点；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>MASTER 成为 BACKUP，要求 MASTER 节点感知到环境中存在别的 MASTER 节点，从而进入 BACKUP 状态；&lt;/p>
&lt;/li>
&lt;/ol>
&lt;p>节点之间通过 VRRP 报文获得相互的优先级及状态信息，因此，可以通过在服务检查失败时，配置防火墙，禁止本机的 VRRP 报文发出即可。这样，BACKUP 节点收不到 MASTER 节点的 VRRP 报文，认为 MASTER 节点不存在，同时 MASTER 节点能收到其他节点的 VRRP 报文，感知到新 MASTER 的产生，从而进入 BACKUP 状态。&lt;/p>
&lt;p>配置详见：&lt;a href="https://www.yuque.com/go/doc/33183799">keepalived+nginx 配置示例&lt;/a>&lt;/p>
&lt;p>重启 keepalived 服务，测试成功。&lt;/p></description></item><item><title>Docs: 一致性哈希算法 consistent hashing</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/3.%E9%9B%86%E7%BE%A4%E4%B8%8E%E5%88%86%E5%B8%83%E5%BC%8F/%E9%9B%86%E7%BE%A4%E4%B8%8E%E5%88%86%E5%B8%83%E5%BC%8F/%E5%88%86%E5%B8%83%E5%BC%8F%E7%AE%97%E6%B3%95/%E4%B8%80%E8%87%B4%E6%80%A7%E5%93%88%E5%B8%8C%E7%AE%97%E6%B3%95-consistent-hashing/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/3.%E9%9B%86%E7%BE%A4%E4%B8%8E%E5%88%86%E5%B8%83%E5%BC%8F/%E9%9B%86%E7%BE%A4%E4%B8%8E%E5%88%86%E5%B8%83%E5%BC%8F/%E5%88%86%E5%B8%83%E5%BC%8F%E7%AE%97%E6%B3%95/%E4%B8%80%E8%87%B4%E6%80%A7%E5%93%88%E5%B8%8C%E7%AE%97%E6%B3%95-consistent-hashing/</guid><description>
&lt;p>白话解析：一致性哈希算法 consistent hashing&lt;/p>
&lt;p>2017 年 10 月 22 日 21:46:15&lt;/p>
&lt;p>阅读数：1180&lt;/p>
&lt;p>摘要：&lt;/p>
&lt;p>本文首先以一个经典的分布式缓存的应用场景为铺垫，在了解了这个应用场景之后，生动而又不失风趣地介绍了一致性哈希算法，同时也明确给出了一致性哈希算法的优点、存在的问题及其解决办法。&lt;/p>
&lt;hr>
&lt;p>声明与致谢：&lt;/p>
&lt;p>本文转载于朱双印博主的个人日志《白话解析：一致性哈希算法 consistent hashing》一文。&lt;/p>
&lt;hr>
&lt;p>一. 引子&lt;/p>
&lt;p>在了解一致性哈希算法之前，最好先了解一下缓存中的一个应用场景，了解了这个应用场景之后，再来理解一致性哈希算法，就容易多了，也更能体现出一致性哈希算法的优点，那么，我们先来描述一下这个经典的分布式缓存的应用场景。&lt;/p>
&lt;hr>
&lt;p>1、场景描述&lt;/p>
&lt;p>假设，我们有三台缓存服务器，用于缓存图片，我们为这三台缓存服务器编号为 0 号、1 号、2 号，现在，有 3 万张图片需要缓存，我们希望这些图片被均匀的缓存到这 3 台服务器上，以便它们能够分摊缓存的压力。也就是说，我们希望每台服务器能够缓存 1 万张左右的图片，那么，我们应该怎样做呢？如果我们没有任何规律的将 3 万张图片平均的缓存在 3 台服务器上，可以满足我们的要求吗？可以！但是如果这样做，当我们需要访问某个缓存项时，则需要遍历 3 台缓存服务器，从 3 万个缓存项中找到我们需要访问的缓存，遍历的过程效率太低，时间太长，当我们找到需要访问的缓存项时，时长可能是不能被接收的，也就失去了缓存的意义，缓存的目的就是 提高速度，改善用户体验，减轻后端服务器压力，如果每次访问一个缓存项都需要遍历所有缓存服务器的所有缓存项，想想就觉得很累，那么，我们该怎么办呢？原始的做法是对缓存项的键进行哈希，将 hash 后的结果对缓存服务器的数量进行取模操作，通过取模后的结果，决定缓存项将会缓存在哪一台服务器上，这样说可能不太容易理解，我们举例说明，仍然以刚才描述的场景为例，假设我们使用图片名称作为访问图片的 key，假设图片名称是不重复的，那么，我们可以使用如下公式，计算出图片应该存放在哪台服务器上。&lt;/p>
&lt;hr>
&lt;p>hash（图片名称）% N&lt;/p>
&lt;p>因为图片的名称是不重复的，所以，当我们对同一个图片名称做相同的哈希计算时，得出的结果应该是不变的，如果我们有 3 台服务器，使用哈希后的结果对 3 求余，那么余数一定是 0、1 或者 2，没错，正好与我们之前的服务器编号相同，如果求余的结果为 0， 我们就把当前图片名称对应的图片缓存在 0 号服务器上，如果余数为 1，就把当前图片名对应的图片缓存在 1 号服务器上，如果余数为 2，同理，那么，当我们访问任意一个图片的时候，只要再次对图片名称进行上述运算，即可得出对应的图片应该存放在哪一台缓存服务器上，我们只要在这一台服务器上查找图片即可，如果图片在对应的服务器上不存在，则证明对应的图片没有被缓存，也不用再去遍历其他缓存服务器了，通过这样的方法，即可将 3 万张图片随机的分布到 3 台缓存服务器上了，而且下次访问某张图片时，直接能够判断出该图片应该存在于哪台缓存服务器上，这样就能满足我们的需求了，我们暂时称上述算法为 HASH 算法或者取模算法，取模算法的过程可以用下图表示。&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/hgulx6/1616132202555-a60e8446-0c60-472c-84a4-e164dc32c2eb.jpeg" alt="">&lt;/p>
&lt;p>但是，使用上述 HASH 算法进行缓存时，会出现一些缺陷，试想一下，如果 3 台缓存服务器已经不能满足我们的缓存需求，那么我们应该怎么做呢？没错，很简单，多增加两台缓存服务器不就行了，假设，我们增加了一台缓存服务器，那么缓存服务器的数量就由 3 台变成了 4 台，此时，如果仍然使用上述方法对同一张图片进行缓存，那么这张图片所在的服务器编号必定与原来 3 台服务器时所在的服务器编号不同，因为除数由 3 变为了 4，被除数不变的情况下，余数肯定不同，这种情况带来的结果就是当服务器数量变动时，所有缓存的位置都要发生改变，换句话说，当服务器数量发生改变时，所有缓存在一定时间内是失效的，当应用无法从缓存中获取数据时，则会向后端服务器请求数据，同理，假设 3 台缓存中突然有一台缓存服务器出现了故障，无法进行缓存，那么我们则需要将故障机器移除，但是如果移除了一台缓存服务器，那么缓存服务器数量从 3 台变为 2 台，如果想要访问一张图片，这张图片的缓存位置必定会发生改变，以前缓存的图片也会失去缓存的作用与意义，由于大量缓存在同一时间失效，造成了 缓存雪崩，此时前端缓存已经无法起到承担部分压力的作用，后端服务器将会承受巨大的压力，整个系统很有可能被压垮，所以，我们应该想办法不让这种情况发生，但是由于上述 HASH 算法本身的缘故，使用取模法进行缓存时，这种情况是无法避免的，为了解决这些问题，一致性哈希算法诞生了。&lt;/p>
&lt;p>我们来回顾一下使用上述算法会出现的问题：&lt;/p>
&lt;p>问题 1：当缓存服务器数量发生变化时，会引起缓存的雪崩，可能会引起整体系统压力过大而崩溃（大量缓存同一时间失效）。&lt;/p>
&lt;p>问题 2：当缓存服务器数量发生变化时，几乎所有缓存的位置都会发生改变，怎样才能尽量减少受影响的缓存呢？&lt;/p>
&lt;p>其实，上面两个问题是一个问题，那么，一致性哈希算法能够解决上述问题吗？我们现在就来了解一下一致性哈希算法。&lt;/p>
&lt;hr>
&lt;p>二. 一致性哈希算法的基本概念&lt;/p>
&lt;p>其实，一致性哈希算法也是使用取模的方法，只是，刚才描述的取模法是对服务器的数量进行取模，而一致性哈希算法是对 2^32 取模，什么意思呢？我们慢慢聊。&lt;/p>
&lt;p>首先，我们把二的三十二次方想象成一个圆，就像钟表一样，钟表的圆可以理解成由 60 个点组成的圆，而此处我们把这个圆想象成由 2^32 个点组成的圆，示意图如下：&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/hgulx6/1616132202586-97ba41e2-bd8d-4bcb-ab83-7b07b1876d76.jpeg" alt="">&lt;/p>
&lt;p>圆环的正上方的点代表 0，0 点右侧的第一个点代表 1，以此类推，2、3、4、5、6……直到 2^32-1,也就是说 0 点左侧的第一个点代表 2^32-1&lt;/p>
&lt;p>我们把这个由 2 的 32 次方个点组成的圆环称为 hash 环。&lt;/p>
&lt;p>那么，一致性哈希算法与上图中的圆环有什么关系呢？我们继续聊，仍然以之前描述的场景为例，假设我们有 3 台缓存服务器，服务器 A、服务器 B、服务器 C，那么，在生产环境中，这三台服务器肯定有自己的 IP 地址，我们使用它们各自的 IP 地址进行哈希计算，使用哈希后的结果对 2^32 取模，可以使用如下公式示意。&lt;/p>
&lt;hr>
&lt;p>hash（服务器 A 的 IP 地址） % 2^32&lt;/p>
&lt;p>通过上述公式算出的结果一定是一个 0 到 2^32-1 之间的一个整数，我们就用算出的这个整数，代表服务器 A，既然这个整数肯定处于 0 到 2^32-1 之间，那么，上图中的 hash 环上必定有一个点与这个整数对应，而我们刚才已经说明，使用这个整数代表服务器 A，那么，服务器 A 就可以映射到这个环上，用下图示意：&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/hgulx6/1616132202585-14af29fb-df19-4b5d-a9a8-54b069ac66cb.jpeg" alt="">&lt;/p>
&lt;p>同理，服务器 B 与服务器 C 也可以通过相同的方法映射到上图中的 hash 环中：&lt;/p>
&lt;p>hash（服务器 B 的 IP 地址） % 2^32&lt;/p>
&lt;p>hash（服务器 C 的 IP 地址） % 2^32&lt;/p>
&lt;p>通过上述方法，可以将服务器 B 与服务器 C 映射到上图中的 hash 环上，示意图如下：&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/hgulx6/1616132202603-15e04eaa-c965-4854-84fa-b342412db159.jpeg" alt="">&lt;/p>
&lt;p>假设 3 台服务器映射到 hash 环上以后如上图所示（当然，这是理想的情况，我们慢慢聊）。&lt;/p>
&lt;p>好了，到目前为止，我们已经把缓存服务器与 hash 环联系在了一起，我们通过上述方法，把缓存服务器映射到了 hash 环上，那么使用同样的方法，我们也可以将需要缓存的对象映射到 hash 环上。&lt;/p>
&lt;p>假设，我们需要使用缓存服务器缓存图片，而且我们仍然使用图片的名称作为找到图片的 key，那么我们使用如下公式可以将图片映射到上图中的 hash 环上。&lt;/p>
&lt;hr>
&lt;p>hash（图片名称） % 2^32&lt;/p>
&lt;p>映射后的示意图如下，下图中的橘黄色圆形表示图片：&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/hgulx6/1616132202605-8c3c063d-9556-434e-b6fa-cbeed21e5a3c.jpeg" alt="">&lt;/p>
&lt;p>好了，现在服务器与图片都被映射到了 hash 环上，那么上图中的这个图片到底应该被缓存到哪一台服务器上呢？上图中的图片将会被缓存到服务器 A 上，为什么呢？因为从图片的位置开始，沿顺时针方向遇到的第一个服务器 就是 A 服务器，所以，上图中的图片将会被缓存到服务器 A 上，如下图所示。&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/hgulx6/1616132202623-dbd970a7-40c9-4f77-bf0a-af258f3bf6a5.jpeg" alt="">&lt;/p>
&lt;p>没错，一致性哈希算法就是通过这种方法，判断一个对象应该被缓存到哪台服务器上的，将缓存服务器与被缓存对象都映射到 hash 环上以后，从被缓存对象的位置出发，沿顺时针方向遇到的第一个服务器，就是当前对象将要缓存于的服务器，由于被缓存对象与服务器 hash 后的值是固定的，所以，在服务器不变的情况下，一张图片必定会被缓存到固定的服务器上，那么，当下次想要访问这张图片时，只要再次使用相同的算法进行计算，即可算出这个图片被缓存在哪个服务器上，直接去对应的服务器查找对应的图片即可。/font&amp;gt;&lt;/p>
&lt;p>刚才的示例只使用了一张图片进行演示，假设有四张图片需要缓存，示意图如下：&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/hgulx6/1616132202612-68280120-c095-4f3a-80fe-8f42cf7e71f8.jpeg" alt="">&lt;/p>
&lt;p>1 号、2 号图片将会被缓存到服务器 A 上，3 号图片将会被缓存到服务器 B 上，4 号图片将会被缓存到服务器 C 上。&lt;/p>
&lt;hr>
&lt;p>三. 一致性哈希算法的优点&lt;/p>
&lt;p>经过上述描述，我想兄弟你应该已经明白了一致性哈希算法的原理了，但是话说回来，一致性哈希算法能够解决之前出现的问题吗，我们说过，如果简单的对服务器数量进行取模，那么当服务器数量发生变化时，会产生缓存的雪崩，从而很有可能导致系统崩溃，那么使用一致性哈希算法，能够避免这个问题吗？我们来模拟一遍，即可得到答案。&lt;/p>
&lt;p>假设，服务器 B 出现了故障，我们现在需要将服务器 B 移除，那么，我们将上图中的服务器 B 从 hash 环上移除即可，移除服务器 B 以后示意图如下。&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/hgulx6/1616132202653-039f84ad-a042-419b-ae51-5e181853f80d.jpeg" alt="">&lt;/p>
&lt;p>在服务器 B 未移除时，图片 3 应该被缓存到服务器 B 中，可是当服务器 B 移除以后，按照之前描述的一致性哈希算法的规则，图片 3 应该被缓存到服务器 C 中，因为从图片 3 的位置出发，沿顺时针方向遇到的第一个缓存服务器节点就是服务器 C，也就是说，如果服务器 B 出现故障被移除时，图片 3 的缓存位置会发生改变。&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/hgulx6/1616132202621-d4a2c0fd-f096-4e13-9839-7f50dfe7b430.jpeg" alt="">&lt;/p>
&lt;p>但是，图片 4 仍然会被缓存到服务器 C 中，图片 1 与图片 2 仍然会被缓存到服务器 A 中，这与服务器 B 移除之前并没有任何区别，这就是一致性哈希算法的优点，如果使用之前的 hash 算法，服务器数量发生改变时，所有服务器的所有缓存在同一时间失效了，而使用一致性哈希算法时，服务器的数量如果发生改变，并不是所有缓存都会失效，而是只有部分缓存会失效，前端的缓存仍然能分担整个系统的压力，而不至于所有压力都在同一时间集中到后端服务器上。&lt;/p>
&lt;p>这就是一致性哈希算法所体现出的优点。&lt;/p>
&lt;hr>
&lt;p>四. hash 环的偏斜&lt;/p>
&lt;p>在介绍一致性哈希的概念时，我们理想化的将 3 台服务器均匀的映射到了 hash 环上，如下图所示：&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/hgulx6/1616132202636-2bc6be5c-d885-49aa-a228-3c7a6d13efe6.jpeg" alt="">&lt;/p>
&lt;p>但是，理想很丰满，现实很骨感，我们想象的与实际情况往往不一样。&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/hgulx6/1616132202623-28068a4f-a82e-4dcf-833b-50a5b63b446d.jpeg" alt="">&lt;/p>
&lt;p>在实际的映射中，服务器可能会被映射成如下模样。&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/hgulx6/1616132202670-68b20340-9bdd-4ef1-955a-4bfa4a413343.jpeg" alt="">&lt;/p>
&lt;p>聪明如你一定想到了，如果服务器被映射成上图中的模样，那么被缓存的对象很有可能大部分集中缓存在某一台服务器上，如下图所示。&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/hgulx6/1616132202641-e7413fb2-fab4-46fa-9bf7-ca879555b484.jpeg" alt="">&lt;/p>
&lt;p>上图中，1 号、2 号、3 号、4 号、6 号图片均被缓存在了服务器 A 上，只有 5 号图片被缓存在了服务器 B 上，服务器 C 上甚至没有缓存任何图片，如果出现上图中的情况，A、B、C 三台服务器并没有被合理的平均的充分利用，缓存分布的极度不均匀，而且，如果此时服务器 A 出现故障，那么失效缓存的数量也将达到最大值，在极端情况下，仍然有可能引起系统的崩溃，上图中的情况则被称之为 hash 环的偏斜，那么，我们应该怎样防止 hash 环的偏斜呢？一致性 hash 算法中使用 “虚拟节点” 解决了这个问题，我们继续聊。&lt;/p>
&lt;hr>
&lt;p>五.虚拟节点&lt;/p>
&lt;p>话接上文，由于我们只有 3 台服务器，当我们把服务器映射到 hash 环上的时候，很有可能出现 hash 环偏斜的情况，当 hash 环偏斜以后，缓存往往会极度不均衡的分布在各服务器上，聪明如你一定已经想到了，如果想要均衡的将缓存分布到 3 台服务器上，最好能让这 3 台服务器尽量多的、均匀的出现在 hash 环上，但是，真实的服务器资源只有 3 台，我们怎样凭空的让它们多起来呢，没错，就是凭空的让服务器节点多起来，既然没有多余的真正的物理服务器节点，我们就只能将现有的物理节点通过虚拟的方法复制出来，这些由实际节点虚拟复制而来的节点被称为”虚拟节点”。加入虚拟节点以后的 hash 环如下。&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/hgulx6/1616132202654-66fcca21-b967-41c3-8ebf-aa501e1f51f9.jpeg" alt="">&lt;/p>
&lt;p>“虚拟节点”是”实际节点”（实际的物理服务器）在 hash 环上的复制品,一个实际节点可以对应多个虚拟节点。&lt;/p>
&lt;p>从上图可以看出，A、B、C 三台服务器分别虚拟出了一个虚拟节点，当然，如果你需要，也可以虚拟出更多的虚拟节点。引入虚拟节点的概念后，缓存的分布就均衡多了，上图中，1 号、3 号图片被缓存在服务器 A 中，5 号、4 号图片被缓存在服务器 B 中，6 号、2 号图片被缓存在服务器 C 中，如果你还不放心，可以虚拟出更多的虚拟节点，以便减小 hash 环偏斜所带来的影响，虚拟节点越多，hash 环上的节点就越多，缓存被均匀分布的概率就越大。&lt;/p></description></item></channel></rss>