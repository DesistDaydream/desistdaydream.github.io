<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>断念梦 – _index</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/2.%E7%BC%96%E7%A8%8B/%E8%A7%A3%E8%B0%9C%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/data-type%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B-%E4%B8%8E-literal%E5%AD%97%E9%9D%A2%E9%87%8F/%E5%A4%8D%E5%90%88%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</link><description>Recent content in _index on 断念梦</description><generator>Hugo -- gohugo.io</generator><atom:link href="https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/2.%E7%BC%96%E7%A8%8B/%E8%A7%A3%E8%B0%9C%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/data-type%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B-%E4%B8%8E-literal%E5%AD%97%E9%9D%A2%E9%87%8F/%E5%A4%8D%E5%90%88%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/index.xml" rel="self" type="application/rss+xml"/><item><title>Docs: 复合数据类型</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/2.%E7%BC%96%E7%A8%8B/%E8%A7%A3%E8%B0%9C%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/data-type%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B-%E4%B8%8E-literal%E5%AD%97%E9%9D%A2%E9%87%8F/%E5%A4%8D%E5%90%88%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/%E5%A4%8D%E5%90%88%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/2.%E7%BC%96%E7%A8%8B/%E8%A7%A3%E8%B0%9C%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/data-type%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B-%E4%B8%8E-literal%E5%AD%97%E9%9D%A2%E9%87%8F/%E5%A4%8D%E5%90%88%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/%E5%A4%8D%E5%90%88%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Composite_data_type">Wiki，Composite_data_type&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>原子类型的值是不能分解为组成部分的单个数据项。复合类型 或 聚合类型 的值是可以单独访问的数据项的集合。例如，一个整数通常被认为是原子的，尽管它由一系列位组成，而整数数组肯定是复合的。&lt;/p>
&lt;h1 id="array数组">Array(数组)&lt;/h1>
&lt;p>&lt;strong>为什么很多编程语言要把 0 作为第一个下标索引，而不是直观的 1 呢？&lt;/strong>&lt;/p>
&lt;p>这个问题 Dijkstra 已经解答过了，没错，就是你知道的 Dijkstra，Dijkstra 最短路径算法，荷兰语全名是 Edsger Wybe Dijkstra，于 1972 年获得了图灵奖，除了上面说的最短路径算法，还有众所周知的信号量和 PV 原语、银行家算法等也是这位巨佬提出的。&lt;/p>
&lt;p>原文在这里：https://www.cs.utexas.edu/users/EWD/transcriptions/EWD08xx/EWD831.html，感兴趣的小伙伴可以去看下全文，下面我总结几段核心的观点：&lt;/p>
&lt;p>首先来看个案例，如何用一个不等式（或者说表达式）来表示 &lt;code>[2,3,4,5,6,7,8,9,10,11,12]&lt;/code> 这个连续的整数序列（一共 11 个数）？&lt;/p>
&lt;p>假设 &lt;code>i&lt;/code> 是一个整数，那么我们能够迅速的写出如下四个符合上述连续序列的不等式：&lt;/p>
&lt;p>1）&lt;code>2 &amp;lt;= i &amp;lt; 13&lt;/code>&lt;/p>
&lt;p>2）&lt;code>1 &amp;lt; i &amp;lt;= 12&lt;/code>&lt;/p>
&lt;p>3）&lt;code>2 &amp;lt;= i &amp;lt;= 12&lt;/code>&lt;/p>
&lt;p>4）&lt;code>1 &amp;lt; i &amp;lt; 13&lt;/code>&lt;/p>
&lt;p>以上四个不等式均满足要求，那是否有理由选择其中的一种而不是另一种？&lt;/p>
&lt;p>Dijkstra 说有的，选 1 和 2，因为这俩不等式有个很突出的有点，就是不等式边界的差（不等式右边 - 不等式左边）正好等于连续序列的长度&lt;/p>
&lt;p>这里可以排除掉 3 和 4，那么 1 和 2 该如何选出最优的表示？&lt;/p>
&lt;p>1 和 2 不等式的区别就在于：&lt;/p>
&lt;ul>
&lt;li>1 不等式左边（下界）等于序列中的最小值，不等式右边（上界）大于序列中的最大值&lt;/li>
&lt;li>2 不等式左边（下界）小于序列中的最小值，不等式右边（上界）等于序列中的最大值&lt;/li>
&lt;/ul>
&lt;p>对于第 2 个不等式来说，下界小于序列中的最小值，这会出现一个问题，比如我们的连续序列是 &lt;code>[0,1,2,3,4]&lt;/code>&lt;/p>
&lt;p>那么按照第 2 个不等式的写法，不等式的左边就是 -1，-1 是非自然数，而我们需要表示的连续序列是自然数序列，所以第 2 个不等式很不优雅：我们需要用一个 非自然数 来作为 全是自然数的序列 的下界&lt;/p>
&lt;p>因此，综上所述，不等式 1 是最优雅的选择。&lt;/p>
&lt;p>那么，选出一个看着非常顺眼的不等式来表达长度为 N 的连续序列之后，下一个令人烦恼的问题是该为起始元素分配什么下标值？&lt;/p>
&lt;p>遵循不等式 1 的规则：&lt;/p>
&lt;ul>
&lt;li>当从下标 1 开始时，下标范围 &lt;code>1 ≤ i &amp;lt; N+1&lt;/code>&lt;/li>
&lt;li>当从下标 0 开始时，下标范围 &lt;code>0 ≤ i &amp;lt; N&lt;/code>&lt;/li>
&lt;/ul>
&lt;p>哪个更优雅？&lt;/p>
&lt;p>Dijkstra 是这样解释的：从下标 0 开始能够给出更好的不等式，因为元素的下标就等于序列中它前面的元素数（或者说 “偏移量”）。&lt;/p></description></item></channel></rss>