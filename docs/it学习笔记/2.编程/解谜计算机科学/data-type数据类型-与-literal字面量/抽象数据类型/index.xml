<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>断念梦 – 抽象数据类型</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/2.%E7%BC%96%E7%A8%8B/%E8%A7%A3%E8%B0%9C%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/data-type%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B-%E4%B8%8E-literal%E5%AD%97%E9%9D%A2%E9%87%8F/%E6%8A%BD%E8%B1%A1%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</link><description>Recent content in 抽象数据类型 on 断念梦</description><generator>Hugo -- gohugo.io</generator><atom:link href="https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/2.%E7%BC%96%E7%A8%8B/%E8%A7%A3%E8%B0%9C%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/data-type%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B-%E4%B8%8E-literal%E5%AD%97%E9%9D%A2%E9%87%8F/%E6%8A%BD%E8%B1%A1%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/index.xml" rel="self" type="application/rss+xml"/><item><title>Docs: Pointer(指针)</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/2.%E7%BC%96%E7%A8%8B/%E8%A7%A3%E8%B0%9C%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/data-type%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B-%E4%B8%8E-literal%E5%AD%97%E9%9D%A2%E9%87%8F/%E6%8A%BD%E8%B1%A1%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/pointer%E6%8C%87%E9%92%88/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/2.%E7%BC%96%E7%A8%8B/%E8%A7%A3%E8%B0%9C%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/data-type%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B-%E4%B8%8E-literal%E5%AD%97%E9%9D%A2%E9%87%8F/%E6%8A%BD%E8%B1%A1%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/pointer%E6%8C%87%E9%92%88/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Pointer_(computer_programming)">Wiki,Pointer&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://mp.weixin.qq.com/s/8QbRw7oxDaPjyjEDLPRYdw">公众号,码农的荒岛求生-彻底理解 C 语言中的指针&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>&lt;strong>Pointer(指针)&lt;/strong> 在计算机科学中，是许多编程语言中存储内存地址的对象。这可以是位于计算机内存中的另一个值，或者在某些情况下，是内存映射计算机硬件的值。指针引用内存中的某个位置，获取存储在该位置的值称为取消引用该指针。打个比方，一本书索引中的页码可以被认为是指向相应页面的指针；将通过翻到具有给定页码的页面并阅读在该页面上找到的文本来取消引用这样的指针。指针变量的实际格式和内容取决于底层计算机体系结构。&lt;/p>
&lt;h1 id="彻底理解-c-语言中的指针">彻底理解 C 语言中的指针&lt;/h1>
&lt;p>大家好，我是小风哥。&lt;/p>
&lt;p>假定给你一块非常小的内存，这块内存只有 8 字节，这里也没有高级语言，没有操作系统，你操作的数据单位是单个字节，你该怎样读写这块内存呢？&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/e7633768-1a36-49bc-a06b-f756beb54e62/640" alt="">&lt;/p>
&lt;p>注意这里的限定，再读一遍，没有高级语言，没有操作系统，在这样的限制之下，&lt;strong>你必须直面内存读写的本质&lt;/strong>。&lt;/p>
&lt;p>这个本质是什么呢？&lt;/p>
&lt;p>本质是你需要意识到内存就是一个一个装有字节的小盒子，这些小盒子从 0 到 N 编好了序号。&lt;/p>
&lt;p>这时如果你想计算 1+2，那么你必须先把 1 和 2 分别放到两个小盒子中，假设我们使用 Store 指令，把数字 1 放到第 6 号小盒子，那么用指令表示就是这样：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-nginx" data-lang="nginx">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">store&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span> &lt;span style="color:#ae81ff">6&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>注意看这条指令，这里出现了两个数字：1 和 6，虽然都是数字，但这两个数字的含义是不同的，&lt;strong>一个代表数值，一个代表内存地址&lt;/strong>。&lt;/p>
&lt;p>与写对应的是读，假设我们使用 load 指令，就像这样：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-nginx" data-lang="nginx">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">load&lt;/span> &lt;span style="color:#e6db74">r1&lt;/span> &lt;span style="color:#ae81ff">6&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>现在依然有一个问题，这条指令到底是数字 6 写入 r1 寄存器还是把第 6 号小盒子中装的数字写入 r1 寄存器？&lt;/p>
&lt;p>可以看到，数字在这里是有歧义的，它既可以表示数值也可以表示地址，为加以区分我们需要给数字添加一个标识，比如对于前面加上$符号的就表示数值，否则就是地址：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-nginx" data-lang="nginx">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">store&lt;/span> $1 &lt;span style="color:#ae81ff">6&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">load&lt;/span> &lt;span style="color:#e6db74">r1&lt;/span> &lt;span style="color:#ae81ff">6&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>这样就不会有歧义了。&lt;/p>
&lt;p>现在第 6 号内存中装入了数值 1：&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/e7633768-1a36-49bc-a06b-f756beb54e62/640" alt="">&lt;/p>
&lt;p>即地址 6 代表数字 1：&lt;/p>
&lt;pre>&lt;code>`地址6 -&amp;gt; 数字1`
&lt;/code>&lt;/pre>
&lt;p>但“地址 6”对人类来说太不友好了，人类更喜欢代号，也就是起名字，假设我们给“地址 6”换一个名字，叫做 a，a 代表的就是地址 6，a 中存储的值就是 1，用人类在代数中直观的表示就是：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-ini" data-lang="ini">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">a&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">1&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>就这样所谓的变量一词诞生了。&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/e7633768-1a36-49bc-a06b-f756beb54e62/640" alt="">&lt;/p>
&lt;p>我们可以看到，从表面上看变量 a 等价于数值 1，但背后还隐藏着一个重要的信息，&lt;strong>那就是变量 a 代表的数字 1 存储在第 6 号内存地址上&lt;/strong>，即变量 a 或者说符号 a 背后的含义是：&lt;/p>
&lt;ol>
&lt;li>表示数值 1&lt;/li>
&lt;li>该数值存储在第 6 号内存地址&lt;/li>
&lt;/ol>
&lt;p>到现在为止第 2 个信息好像不太重要，先不用管它。&lt;/p>
&lt;p>既然有变量 a，就会有变量 b，如果有这样一个表示：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-ini" data-lang="ini">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">b&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">a&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>把 a 的值给到 b，这个赋值在内存中该怎么表示呢？&lt;/p>
&lt;p>很简单，我们为变量 b 也找一个小盒子，假设变量 b 放在第 2 号小盒子上：&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/e7633768-1a36-49bc-a06b-f756beb54e62/640" alt="">&lt;/p>
&lt;p>可以看到，我们完全 copy 了一份变量 a 的数据。&lt;/p>
&lt;p>现在有了变量，接下来让我们升级一下，假设变量 a 不仅仅可以表示占用 1 个字节的数据，也可以表示占用任意多内存的数据，就像这样：&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/e7633768-1a36-49bc-a06b-f756beb54e62/640" alt="">&lt;/p>
&lt;p>现在变量 a 占据 5 个字节，足足占用了整个内存的一大半空间，此时如果我们依然想要表示 b = a 会怎样呢？&lt;/p>
&lt;p>如果你依然采用 copy 的方法会发现我们的内存空间已经不够用了，因为整个内存大小就 8 字节，采用 copy 的方法仅这两个变量代表的数据就将占据 10 字节。&lt;/p>
&lt;p>怎么办呢？&lt;/p>
&lt;p>不要忘了变量 a 背后可是有两个含义的，再让我们看一下：&lt;/p>
&lt;ol>
&lt;li>&lt;strong>表示数值 1&lt;/strong>&lt;/li>
&lt;li>&lt;strong>该数值存储在第 6 号内存地址&lt;/strong>&lt;/li>
&lt;/ol>
&lt;p>重点看一下第 2 个含义，这个含义告诉我们什么呢？&lt;/p>
&lt;p>它告诉我们不管一个变量占据多少内存空间，我们总可以通过它在内存中地址找到该数据，而内存地址仅仅就是一个数字，这个数字和该数据占用空间的大小无关。&lt;/p>
&lt;p>啊哈，现在变量的第 2 个含义终于排上用场了，如果我们想用变量 b 也去指代变量 a，干嘛非要直接 copy 一份数据呢？直接使用地址就不好了，就像这样：&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/e7633768-1a36-49bc-a06b-f756beb54e62/640" alt="">&lt;/p>
&lt;p>变量 a 在内存中地址为 3，因此变量 b 中我们可以仅仅存储 3 这个数字即可。&lt;/p>
&lt;p>现在变量 b 就开始变得非常有趣了。&lt;/p>
&lt;p>&lt;strong>首先变量 b 没什么特殊的，只不过变量 b 存储的东西我们不可以按照数值来解释，而是必须按照地址来解释。&lt;/strong>&lt;/p>
&lt;p>当一个变量不仅仅可以用来保存数值也可以保存内存地址时，指针诞生了。&lt;/p>
&lt;p>有很多资料仅仅说指针就是地址，但小风哥认为这是一种偷懒的解释，仅仅停留在汇编层面来理解，有失偏颇，在高级语言中，指针首先是一个变量，只不过这个变量保存的恰好是地址而已，&lt;strong>指针是内存地址的更高一级抽象&lt;/strong>。&lt;/p>
&lt;p>如果仅仅把指针理解为内存地址的话你就必须知道所谓的间接寻址。&lt;/p>
&lt;p>这是什么意思呢？&lt;/p>
&lt;p>如果使用汇编语言来加载变量 a 的值该怎么写呢？&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-nginx" data-lang="nginx">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">load&lt;/span> &lt;span style="color:#e6db74">r1&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>想一想，这是不是会有问题，因此这样的话该指令会把数值 3 加载到 r1 寄存器中，然而我们想要把内存地址 1 中保存的数值也解释为内存地址，这时必须为 1 再次添加一个标识，比如@：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-css" data-lang="css">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">load&lt;/span> &lt;span style="color:#f92672">r1&lt;/span> @&lt;span style="color:#66d9ef">1&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>这时该指令会首先把内存地址 1 中保存的值读取出来发现是 3，然后再次把 3 按照内存地址进行解释，3 指向的数据就是变了 a：&lt;/p>
&lt;pre tabindex="0">&lt;code>
`地址1 -&amp;gt; 地址3 -&amp;gt; 数据a`
&lt;/code>&lt;/pre>&lt;p>这就是所谓的间接寻址，Indirect addressing，在汇编语言下你必须能意识到这一层间接寻址，&lt;strong>因为在汇编语言中是没有变量这个概念的&lt;/strong>。&lt;/p>
&lt;p>然而高级语言则不同，这里有变量的概念，此时地址 1 代表变量 b，但使用变量的一个好处就在于很多情况下我们只需要关心其第一个含义，也就是说我们只需要关心变量 b 中保存了地址 3，而不需要关心变量 b 到底存储在哪里，这样使用变量 b 时我们就不需在大脑里想一圈间接寻址这一问题了，在程序员的大脑里变量 b 直接指向数据 a：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-nginx" data-lang="nginx">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">b&lt;/span> &lt;span style="color:#e6db74">-&amp;gt;&lt;/span> &lt;span style="color:#e6db74">数据a&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>再来对比一下：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>地址1 -&amp;gt; 地址3 -&amp;gt; 数据a   
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>变量b -&amp;gt; 数据a
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>这就是为什么我说指针其实是内存地址的更高级抽象，这个抽象的目的就在于屏蔽间接寻址。&lt;/p>
&lt;p>当变量不仅仅可以存值也可以存放地址时，一个全新的时代到来了：**看似松散的内存在内部竟然可以通过指针组织起来，同时这也让程序直接处理复杂的数据结构成为可能，**比如就像下图这样：&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/e7633768-1a36-49bc-a06b-f756beb54e62/640" alt="">&lt;/p>
&lt;p>这就是所谓的链表了。&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/e7633768-1a36-49bc-a06b-f756beb54e62/640" alt="">&lt;/p>
&lt;p>指针这个概念首次出现在 PL/I 语言中，当时是为了增加链表处理能力，大家不要以为链表这种数据结构是非常司空见惯的，这在 1964 年左右并不是一件容易的事情，关于链表你还可以参考这篇《&lt;a href="http://mp.weixin.qq.com/s?__biz=Mzg4OTYzODM4Mw==&amp;amp;mid=2247486325&amp;amp;idx=1&amp;amp;sn=c2c6e11468bac9aa50dcc7f172f02c6d&amp;amp;chksm=cfe997f5f89e1ee304f4ba251b90af1ccdee043c6cb12c9a1658ab0e74dd42a4bd88ef1d87c2&amp;amp;scene=21#wechat_redirect">彻底理解链表&lt;/a>》。&lt;/p>
&lt;p>值得一提的是，Multics 操作系统就是 PL/I 语言实现的，这也是第一个用高级语言实现的操作系统，然而 Multics 操作系统在商业上并不成功，参与该项目的 Ken Thompson, Dennis Ritchie 后来决定自己写一个更简单的，Unix 以及 C 语言诞生了，或许是在开发 Multic 时见识到了 PL/I 语言中指针的威力，C 语言中也有指针的概念。&lt;/p>
&lt;p>那么指针在 C 语言中是一个什么样的概念？为什么说指针威力强大但又破坏性十足？引用和指针又有什么关联？&lt;/p>
&lt;p>下一篇文章将会给你答案，敬请期待。&lt;/p>
&lt;p>最后推荐一下小风哥自己写的书《&lt;strong>深入理解操作系统&lt;/strong>》，如果你对操作系统感兴趣同时也喜欢小风哥&lt;strong>通俗易懂&lt;/strong>的写作风格，这本书绝不能错过。&lt;/p></description></item><item><title>Docs: Tree Data Structure(树型数据结构)</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/2.%E7%BC%96%E7%A8%8B/%E8%A7%A3%E8%B0%9C%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/data-type%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B-%E4%B8%8E-literal%E5%AD%97%E9%9D%A2%E9%87%8F/%E6%8A%BD%E8%B1%A1%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/tree-data-structure%E6%A0%91%E5%9E%8B%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/2.%E7%BC%96%E7%A8%8B/%E8%A7%A3%E8%B0%9C%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/data-type%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B-%E4%B8%8E-literal%E5%AD%97%E9%9D%A2%E9%87%8F/%E6%8A%BD%E8%B1%A1%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/tree-data-structure%E6%A0%91%E5%9E%8B%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;a href="https://en.wikipedia.org/wiki/Tree_(data_structure)">Wiki-TreeDataStructure&lt;/a>&lt;/p>
&lt;/blockquote>
&lt;p>在&lt;a href="https://en.wikipedia.org/wiki/Computer_science">计算机科学中&lt;/a>，&lt;strong>Tree&lt;/strong> 是一种广泛使用的&lt;a href="https://en.wikipedia.org/wiki/Abstract_data_type">抽象数据类型&lt;/a>，它模拟分层&lt;a href="https://en.wikipedia.org/wiki/Tree_structure">树结构&lt;/a>，其根值和具有&lt;a href="https://en.wikipedia.org/wiki/Tree_(data_structure)#Terminology">父节点的&lt;/a>子级子树表示为一组链接&lt;a href="https://en.wikipedia.org/wiki/Node_(computer_science)">节点&lt;/a>。&lt;/p>
&lt;p>可以将树数据结构&lt;a href="https://en.wikipedia.org/wiki/Recursion">递归&lt;/a>定义为节点的集合（从根节点开始），其中每个节点都是由值组成的数据结构，以及对节点（“子级”）的引用列表，其中约束，即没有重复的引用，也没有指向根的约束。或者，可以将树抽象为一个整体（全局地）定义为&lt;a href="https://en.wikipedia.org/wiki/Ordered_tree">有序树&lt;/a>，并为每个节点分配一个值。这两种观点都很有用：虽然一棵树可以作为一个整体进行数学分析，但是当实际上表示为数据结构时，它通常由节点表示和使用（而不是作为一组节点和节点之间的&lt;a href="https://en.wikipedia.org/wiki/Adjacency_list">邻接表）&lt;/a>，例如表示一个&lt;a href="https://en.wikipedia.org/wiki/Tree_(data_structure)#Digraphs">有向图&lt;/a>）。例如，从整体上看一棵树，可以谈论给定节点的“父节点”，但是通常，给定节点作为数据结构仅包含其子节点列表，但不包含引用。给它的父母（如果有的话）。&lt;/p>
&lt;h1 id="术语">术语&lt;/h1>
&lt;p>1、结点(Node)：表示树中的数据元素，由数据项和数据元素之间的关系组成。在图 1 中，共有 10 个结点。
2、结点的度(Degree of Node)：结点所拥有的子树的个数，在图 1 中，结点 A 的度为 3。
3、树的度(Degree of Tree)：树中各结点度的最大值。在图 1 中，树的度为 3。
4、叶子结点(Leaf Node)：度为 0 的结点，也叫终端结点。在图 1 中，结点 E、F、G、H、I、J 都是叶子结点。
5、分支结点(Branch Node)：度不为 0 的结点，也叫非终端结点或内部结点。在图 1 中，结点 A、B、C、D 是分支结点。
6、孩子(Child)：结点子树的根。在图 1 中，结点 B、C、D 是结点 A 的孩子。
7、双亲(Parent)：结点的上层结点叫该结点的双亲。在图 1 中，结点 B、C、D 的双亲是结点 A。
8、祖先(Ancestor)：从根到该结点所经分支上的所有结点。在图 1 中，结点 E 的祖先是 A 和 B。
9、子孙(Descendant)：以某结点为根的子树中的任一结点。在图 1 中，除 A 之外的所有结点都是 A 的子孙。
10、兄弟(Brother)：同一双亲的孩子。在图 1 中，结点 B、C、D 互为兄弟。
11、结点的层次(Level of Node)：从根结点到树中某结点所经路径上的分支数称为该结点的层次。根结点的层次规定为 1，其余结点的层次等于其双亲结点的层次加 1。
12、堂兄弟(Sibling)：同一层的双亲不同的结点。在图 1 中，G 和 H 互为堂兄弟。
13、树的深度(Depth of Tree)：树中结点的最大层次数。在图 1 中，树的深度为 3。
14、无序树(Unordered Tree)：树中任意一个结点的各孩子结点之间的次序构成无关紧要的树。通常树指无序树。
15、有序树(Ordered Tree)：树中任意一个结点的各孩子结点有严格排列次序的树。二叉树是有序树，因为二叉树中每个孩子结点都确切定义为是该结点的左孩子结点还是右孩子结点。
16、森林(Forest)：m(m≥0)棵树的集合。自然界中的树和森林的概念差别很大，但在数据结构中树和森林的概念差别很小。从定义可知，一棵树有根结点和 m 个子树构成，若把树的根结点删除，则树变成了包含 m 棵树的森林。当然，根据定义，一棵树也可以称为森林。&lt;/p></description></item></channel></rss>