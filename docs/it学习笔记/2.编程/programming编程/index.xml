<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>断念梦 – Programming(编程)</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/2.%E7%BC%96%E7%A8%8B/programming%E7%BC%96%E7%A8%8B/</link><description>Recent content in Programming(编程) on 断念梦</description><generator>Hugo -- gohugo.io</generator><atom:link href="https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/2.%E7%BC%96%E7%A8%8B/programming%E7%BC%96%E7%A8%8B/index.xml" rel="self" type="application/rss+xml"/><item><title>Docs: Programming(编程)</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/2.%E7%BC%96%E7%A8%8B/programming%E7%BC%96%E7%A8%8B/programming%E7%BC%96%E7%A8%8B/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/2.%E7%BC%96%E7%A8%8B/programming%E7%BC%96%E7%A8%8B/programming%E7%BC%96%E7%A8%8B/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Computer_programming">Wiki,Computer Programming&lt;/a>(计算机编程)&lt;/li>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Programming_language">Wiki,Programmig Language(编程语言)&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>无论处于上层的软件多么的高级, 想要在 CPU 执行, 就必须被翻译成“机器码”， 翻译这个工作由编译器来执行. 编译器在这个过程中, 要经过“编译”，“汇编”，“链接”几个步骤, 最后生成“&lt;a href="https://so.csdn.net/so/search?q=%E5%8F%AF%E6%89%A7%E8%A1%8C%E6%96%87%E4%BB%B6&amp;amp;spm=1001.2101.3001.7020">可执行文件&lt;/a>”. 可执行文件中保存的是二进制机器码. 这串机器码可以直接被 CPU 读取和执行。&lt;/p>
&lt;h1 id="编程学习资料">编程学习资料&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://mp.weixin.qq.com/s/WdTRq31CRjy90KiN88dwtw">公众号，微软带头打了 30 年，这场屏幕的大乱斗，终于要结束了&lt;/a>(前端浏览器的历史)&lt;/li>
&lt;li>&lt;a href="http://www.manongjc.com/">码农教程&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;h2 id="菜鸟教程">菜鸟教程&lt;/h2>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://www.runoob.com/">官网&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>&lt;a href="https://www.runoob.com/">菜鸟教程&lt;/a>提供了基础编程技术教程。
菜鸟教程的 Slogan 为：学的不仅是技术，更是梦想！
记住：再牛逼的梦想也抵不住傻逼似的坚持！
本站域名为 runoob.com, runoob 为 Running Noob 的缩写，意为：奔跑吧！菜鸟。
本站包括了 HTML、CSS、Javascript、PHP、C、Python 等各种基础编程教程。
同时本站中也提供了大量的在线实例，通过实例，您可以更好地学习如何建站。
本站致力于推广各种编程语言技术，所有资源是完全免费的，并且会根据当前互联网的变化实时更新本站内容。
同时本站内容如果有不足的地方，也欢迎广大编程爱好者在本站留言提供意见。&lt;/p>
&lt;h2 id="w3school">W3school&lt;/h2>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://www.w3schools.com/">官网&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.w3school.com.cn/about/about_us.asp">W3school 中文&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>开发者资源网站(各种语言的教程、各种参考手册等等)&lt;/p>
&lt;h2 id="mdn">MDN&lt;/h2>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/MDN_Web_Docs">Wiki,MDN&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://github.com/mdn/">GitHub MDN 组织&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>&lt;a href="https://developer.mozilla.org">Mozilla Developer Network(Mozilla 开发者网络，简称 MDN) 官网&lt;/a>，这是一个汇集了众多 Mozilla 基金会产品和网络技术开发文档的网站。
该网站都是前端所需要的东西&lt;/p>
&lt;h1 id="代码类型">代码类型&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Source_code">Wiki,Source code&lt;/a>(源码)&lt;/li>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Assembly_language">Wiki,Assembly code&lt;/a>(汇编码)，也可以称为 Assembly language(汇编语言)&lt;/li>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Machine_code">Wiki,Machine code&lt;/a>(机器码)
&lt;ul>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Opcode">Wiki,Operation code&lt;/a>(操作码)&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Bytecode">Wiki,Bytecode&lt;/a>(字节码)&lt;/li>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Microcode">Wiki,Microcode&lt;/a>(微码)&lt;/li>
&lt;li>&lt;a href="https://juejin.cn/post/6946382168641765412">掘金，机器码和计算机指令到底是怎么回事&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>所有的 &lt;strong>Code(代码)&lt;/strong>，都可以看作是 &lt;strong>Instructions(指令)&lt;/strong> 的&lt;strong>集合&lt;/strong>。&lt;/p>
&lt;ul>
&lt;li>C、Go 等高级语言编写的代码是源码，源码通过编译器，将源码转换为汇编码&lt;/li>
&lt;li>各种类型的汇编语言编写的代码是汇编码，汇编码通过汇编器，将汇编码转换为机器码&lt;/li>
&lt;/ul>
&lt;h2 id="source-code源码">Source Code(源码)&lt;/h2>
&lt;p>在计算机编程中，&lt;strong>Soure Code(源码)&lt;/strong> 是使用人类可读的编程语言编写的任何&lt;strong>代码指令的集合&lt;/strong>。程序的源代码是专门为方便计算机程序员的工作而设计的，他们主要通过编写源代码来指定计算机要执行的操作。源代码通常由汇编器或编译器转换为可由计算机执行的二进制机器代码。然后可能会存储机器代码以供稍后执行。或者，源代码可以被解释并因此立即执行。&lt;/p>
&lt;h2 id="machine-code机器码">Machine Code(机器码)&lt;/h2>
&lt;p>在计算机编程中，&lt;strong>Machine Code(机器码)&lt;/strong> 是任何符合 &lt;a href="#NKiSr">ISA&lt;/a>(指令集架构) 的 &lt;strong>Machine Instruction(机器指令)&lt;strong>的&lt;/strong>集合&lt;/strong>，用于控制对应 ISA 标准下的 CPU。其中的每条指令都会使 CPU 执行一项具体的任务。例如对 CPU 寄存器中的一个或多个数据单元进行 加载、存储、调准、算数逻辑单元 等操作。&lt;/p>
&lt;blockquote>
&lt;p>Machhine Code(机器码) 也可以称为 Machine Instruction(机器指令)&lt;/p>
&lt;/blockquote>
&lt;p>比如，MIPS 架构为每条机器指令始终是 32 bit 长的机器码提供了一个特定的示例：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ae81ff">6&lt;/span> &lt;span style="color:#ae81ff">5&lt;/span> &lt;span style="color:#ae81ff">5&lt;/span> &lt;span style="color:#ae81ff">5&lt;/span> &lt;span style="color:#ae81ff">5&lt;/span> &lt;span style="color:#ae81ff">6&lt;/span> bits
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">[&lt;/span> op | rs | rt | rd |shamt| funct&lt;span style="color:#f92672">]&lt;/span> R-type
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">[&lt;/span> op | rs | rt | address/immediate&lt;span style="color:#f92672">]&lt;/span> I-type
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">[&lt;/span> op | target address &lt;span style="color:#f92672">]&lt;/span> J-type
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>MIPS 架构中将所有机器指令分为 3 类：&lt;/p>
&lt;ul>
&lt;li>&lt;strong>R-type(Register 寄存器)&lt;/strong> # 一般用来执行算术逻辑操作，里面有读取和写入数据寄存器的地址，如果是逻辑位移操作，还有位移量，最后的 funct 是功能码，用以补充操作码&lt;/li>
&lt;li>&lt;strong>I-type(Immediate 立即)&lt;/strong> # 通常用来执行数据传输、条件分支、立即数操作。&lt;/li>
&lt;li>&lt;strong>J-type(Jump 跳转)&lt;/strong> # 通常用来执行无条件跳转操作。每条指令后面通常都会接一条跳转指令以便 CPU 可以跳转到下一个位置执行后面的指令。&lt;/li>
&lt;/ul>
&lt;p>每种类型的机器指令最高由 32 bit 表示，不同类型的指令中每个 bit 所表示的含义是不一样的，通常前 6 bit 都是 op，用以表示这条指令具体需要执行的行为是什么。后面的 bits 则根据指令的不同而有所区别&lt;/p>
&lt;ul>
&lt;li>&lt;strong>op&lt;/strong> # &lt;strong>Operation Code(操作码，简称 opcode)&lt;/strong> 也称为 Instruction machine code(指令机器码)、Instruction code(指令码)、Instruction syllable()、Instruction parcel、opstring。op 代表这条指令具体是一条什么样的指令。
&lt;ul>
&lt;li>op 码 与 实际行为 的对应关系，需要参考各个 ISA 规范&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>rs、rt、rd&lt;/strong> # 寄存器 XX
&lt;ul>
&lt;li>R 指令中 rd 是存放结果的目的寄存器&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>immediate&lt;/strong> 或 **address **# 需要操作的“数”。
&lt;ul>
&lt;li>可以是一个“具体的可以直接操作的数”或“存放数的地址”&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>target address&lt;/strong> # 目标地址&lt;/li>
&lt;/ul>
&lt;p>若一个 CPU 是 32 位 或 64 位，那寄存器中可以存储的 bit 数即为 32 bit 或 64 bit
比如我们可以通过 I-type 指令将数据存储到指定的寄存器中，然后通过 R-type 指令计算指定寄存器中的数据，并将结果放到另一个寄存器中，最后通过 J-type 指令跳转到下一个位置继续执行后续的指令。
简单示例：
将寄存器 1 和 2 相加并将结果放入寄存器 6 的编码如下：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">[&lt;/span> op | rs | rt | rd |shamt| funct&lt;span style="color:#f92672">]&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ae81ff">0&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span> &lt;span style="color:#ae81ff">2&lt;/span> &lt;span style="color:#ae81ff">6&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span> &lt;span style="color:#ae81ff">32&lt;/span> 十进制表示
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ae81ff">000000&lt;/span> &lt;span style="color:#ae81ff">00001&lt;/span> &lt;span style="color:#ae81ff">00010&lt;/span> &lt;span style="color:#ae81ff">00110&lt;/span> &lt;span style="color:#ae81ff">00000&lt;/span> &lt;span style="color:#ae81ff">100000&lt;/span> 二进制表示
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> 0X???? 十六进制表示。怎么转换还没找到资料
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>将一个值加载到寄存器 8 中，该值取自寄存器 3 中列出的位置之后的存储单元 68 个单元：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">[&lt;/span> op | rs | rt | address/immediate&lt;span style="color:#f92672">]&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ae81ff">35&lt;/span> &lt;span style="color:#ae81ff">3&lt;/span> &lt;span style="color:#ae81ff">8&lt;/span> &lt;span style="color:#ae81ff">68&lt;/span> 十进制表示
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ae81ff">100011&lt;/span> &lt;span style="color:#ae81ff">00011&lt;/span> &lt;span style="color:#ae81ff">01000&lt;/span> &lt;span style="color:#ae81ff">00000&lt;/span> &lt;span style="color:#ae81ff">00001&lt;/span> &lt;span style="color:#ae81ff">000100&lt;/span> 二进制表示
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> 0X???? 十六进制表示。怎么转换还没找到资料
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>跳转到地址 1024：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">[&lt;/span> op | target address &lt;span style="color:#f92672">]&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ae81ff">2&lt;/span> &lt;span style="color:#ae81ff">1024&lt;/span> 十进制表示
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ae81ff">000010&lt;/span> &lt;span style="color:#ae81ff">00000&lt;/span> &lt;span style="color:#ae81ff">00000&lt;/span> &lt;span style="color:#ae81ff">00000&lt;/span> &lt;span style="color:#ae81ff">10000&lt;/span> &lt;span style="color:#ae81ff">000000&lt;/span> 二进制表示
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> 0X???? 十六进制表示。怎么转换还没找到资料
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="总结">总结&lt;/h3>
&lt;p>机器码的结构其实和各种协议的封装结构非常类似，都是通过某些规范，将 bits 划分为几块，每块 bits 数表示的含义是不一样的
而决定机器码结构的，就是 &lt;a href="#NKiSr">ISA(指令集架构)&lt;/a> 了，根据 ISA 生产的 CPU 在处理机器码时，会根据自身的 ISA 来解析这些机器码，隔几 bit 识别一次，然后执行识别到的结果，若是 CPU 在识别机器码时发现是在自己的 ISA 规范中，那么这条机器码将会被转成微码并在 CPU 内流动，若机器码错了，那么是没法通过 CPU 的译码阶段，控制点路将会报错。这时如果是 windows 系统往往就会蓝屏，因为 CPU 无法识别机器码中的指令，不知道自己应该执行什么。
机器码与源码最大的区别在于&lt;/p>
&lt;ul>
&lt;li>源码可以用多种高级语言编写；而每条机器码是与每行汇编码是一一对应的&lt;/li>
&lt;li>源码是人类可读的；机器码人类读不懂&lt;/li>
&lt;li>源码通常都是文本；机器码是 0 和 1 数字的集合(当然，二进制也可以通过某些规则，编码为 10 进制、16 进制等，用于传播与存储)&lt;/li>
&lt;/ul>
&lt;p>最后说一点：&lt;/p>
&lt;ul>
&lt;li>&lt;strong>源码是与人交互的，需要符合人的规矩，也就是各种高级编程语言的格式&lt;/strong>&lt;/li>
&lt;li>&lt;strong>机器码是与机器交互的，需要符合机器的规矩，也就是各种指令集架构&lt;/strong>&lt;/li>
&lt;/ul>
&lt;p>所以，就算是好多好多 0 和 1 的数字，也需要符合某些规范，才可以被 CPU 识别。当 CPU 识别时，假如现在我规定，每隔 10 bit 识别一次，然后发现 10 个 01 组成的数字，在自己的规范中没有任何描述，那么这 CPU 也就执行不下去了。这也是一个程序无法在多种架构的 CPU 上执行的原因。因为当一个程序经过汇编之后，01 的排列是以一种架构实现的，这种排列方式在其他架构上是识别不出来的~~~~&lt;/p>
&lt;h3 id="机器码与汇编码">机器码与汇编码&lt;/h3>
&lt;p>由于机器码对人类来说非常不可读，所以早期人们创造了汇编语言，汇编语言的作用就是使用人类可读的汇编码与机器码建立一一对应的关系，这样，人们在编写程序时，就不用一直编写 01 了，而是使用单词来描述一条指令。
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/cr7gm9/1653022184400-445fedc6-a6d6-4b0a-9e61-269ae5aff029.webp" alt="">
以上 C 语言编译成汇编语言，再由汇编语言翻译成机器码，也就是 0 和 1 的机器语言。一条条的 16 进制数字，就是机器能读懂的计算机指令
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/cr7gm9/1653020400830-d392e057-dc98-4605-bf86-043f243c7779.webp" alt="">
linux 系统上可以使用 gcc 和 objdump，把汇编码和机器码都打印出来。汇编代码和机器码是一一对应的，一条汇编对应一条机器码。
可以说，汇编码就是给“给人看的机器码”
通常，同一个 ISA 规范下，每条机器码，通常都对应一行汇编代码~~&lt;/p>
&lt;h2 id="bytecode字节码">Bytecode(字节码)&lt;/h2>
&lt;p>&lt;strong>Bytecode(字节码)&lt;/strong> 也称为 &lt;strong>p-code(p 码)&lt;/strong>，是一种特殊的可以被执行的机器码 ** **，只不过被虚拟机执行。之所以称之为字节码，是指这里面的操作码(opcode)是—个字节长。一般机器指令由操作码和操作数组成，字节码(虚拟的机器码)也是由操作码(opcode)和操作数(op)组成。对于字节码，它是按照一套虚机指令集格式来组织。&lt;/p>
&lt;h1 id="指令--指令集--指令集架构">指令 &amp;amp; 指令集 &amp;amp; 指令集架构&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Instruction_set_architecture">Wiki,InstructionSetArchitecture&lt;/a>(指令集架构)&lt;/li>
&lt;li>&lt;a href="https://picture.iczhiku.com/weixin/message1583925567196.html">https://picture.iczhiku.com/weixin/message1583925567196.html&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://a-suozhang.xyz/2019/09/27/ISA/">https://a-suozhang.xyz/2019/09/27/ISA/&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>&lt;strong>Instruction set architecture(指令集架构，简称 ISA)&lt;/strong> 是软件和硬件之间的接口，是一套&lt;strong>标准规范&lt;/strong>，并不具备实体，我们可以根据这套规范去设计 CPU 和对应的软件系统，并最终形成产品。
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/cr7gm9/1652863904250-81b4f27e-82b5-446b-bba7-4ca408b4fb4c.png" alt="image.png">
常见的指令集如&lt;/p>
&lt;ul>
&lt;li>X86&lt;/li>
&lt;li>ARM&lt;/li>
&lt;li>RISC-V&lt;/li>
&lt;li>等&lt;/li>
&lt;/ul>
&lt;p>如果把软件和硬件看成螺母和螺钉，那么 ISA 就是螺母和螺钉之间对接的规范(e.g.尺寸、螺纹 之类的)。螺母和螺钉都按照相同的尺寸(i.e.相同的规范)去设计，即使是由不同的厂商来生产，也可以保证最终所有的螺钉都能拧到螺母上。
指令集向上承载的是整个软件生态，向下则规范了以处理器芯片为代表的整个硬件生态。根据一份指令集规范，设计一款处理器，其上可以运行同样遵循该指令集规范所编写的软件代码。&lt;strong>故而，我们在提到指令集的时候，有时候也指的是其背后的整个软硬件生态系统，包括外围芯片、操作系统、编译器和诸多应用软件（浏览器、游戏软件等）&lt;/strong>。事实证明，每一种芯片在市场竞争中要取得成功，很大程度上取决于其&lt;strong>生态系统&lt;/strong>。&lt;/p>
&lt;h1 id="crud增删改查">CRUD(增删改查)&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Create,_read,_update_and_delete">Wiki,CRUD&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>在计算机编程中，&lt;strong>Create、Read、Update、Delete(创建、读取、更新、删除，简称 增删改查(CRUD))&lt;/strong> 是持久性存储的四个基本操作。[1] CRUD 有时也用于描述用户界面约定，这些约定便于使用基于计算机的表单和报告查看、搜索和更改信息。这个词很可能是詹姆斯·马丁 (James Martin) 在他的 1983 著作《管理数据库环境》中首次推广的。
are the four basic operations of &lt;a href="https://en.wikipedia.org/wiki/Persistent_storage">persistent storage&lt;/a>.&lt;a href="https://en.wikipedia.org/wiki/Create,_read,_update_and_delete#cite_note-james-martin-1">[1]&lt;/a> CRUD is also sometimes used to describe &lt;a href="https://en.wikipedia.org/wiki/User_interface">user interface&lt;/a> conventions that facilitate viewing, searching, and changing information using computer-based &lt;a href="https://en.wikipedia.org/wiki/Form_(document)">forms&lt;/a> and &lt;a href="https://en.wikipedia.org/wiki/Report">reports&lt;/a>. The term was likely first popularized by &lt;a href="https://en.wikipedia.org/wiki/James_Martin_(author)">James Martin&lt;/a> in his 1983 book &lt;em>Managing the Data-base environment&lt;/em>.&lt;/p>
&lt;h1 id="projects项目">Projects(项目)&lt;/h1>
&lt;p>项目一般就是指开发一个程序。
从写代码的角度看，一个项目就是一个文件夹，该文件夹中包含该项目所需要依赖的第三方库，项目主体的代码，可执行文件等。&lt;/p>
&lt;h1 id="前端与后端">前端与后端&lt;/h1>
&lt;p>后端：一般是用来处理客户端发送的请求，并将前端写的 页面代码 文件，发送给客户端；或者从数据库获取数据，并填充到前端页面中；等等
前端：一般用来展示的，客户端收到的页面文件(比如输入用户名和密码的框，下拉框等等)，都是由前端工程师来写的，一般是 html 等。&lt;/p>
&lt;h2 id="前后端交互">前后端交互&lt;/h2>
&lt;p>前端与后端之间的交互取决于是前后端分离还不分离&lt;/p>
&lt;ul>
&lt;li>前后端不分离时，通常由后端代码渲染 html 等静态资源文件，&lt;strong>此时客户端访问的是由后端代码监听的端口&lt;/strong>&lt;/li>
&lt;li>前后端分离时，又分多种情况
&lt;ul>
&lt;li>将 html 等静态资源放在 Nginx 等可以提供 HTTP 服务的程序中，然后通过后端提供的 API 进行交互，&lt;strong>此时客户端访问的是由提供 HTTP 服务程序监听的端口&lt;/strong>&lt;/li>
&lt;li>将 html 等静态资源与后端代码放在一起，这种行为通常称为“XX 语言嵌入静态资源”，&lt;strong>此时客户端访问的是由后端程序监听的端口&lt;/strong>
&lt;ul>
&lt;li>比如 Go 语言在 1.16 版本中推出的 embed 库即可实现该效果&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h2 id="前端">前端&lt;/h2>
&lt;p>&lt;strong>htmx&lt;/strong> # 不使用 JavaScript 也可以和浏览器进行交互&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://mp.weixin.qq.com/s/oGk8QtvHwvPDDkOpR5dLzQ">https://mp.weixin.qq.com/s/oGk8QtvHwvPDDkOpR5dLzQ&lt;/a>&lt;/li>
&lt;/ul>
&lt;h1 id="库标准库第三方库与框架">库、标准库、第三方库与框架&lt;/h1>
&lt;p>每种编程语言都具有最基本的功能，比如输入、输出等，这些都属于基本库。比如我使用 print 想输出一些内容，则是调用输出所用的库来实现这个效果。这些基本库都是内置在各个编程语言当中的，可以直接调用。
但是有时候会有很复杂的需求， 比如对系统的某些程序进行操作、对数据库进行操作、写出来的程序如何设置子命令和参数等等等。这些复杂的需求，如果使用基本的编程语言来实现，是非常麻烦的，这时候如果有人可以提前使用编程语言的基本功能来创作一个可以实现某个具体功能的程序就好了。
这个创作出来的基本程序就可以称之为“库或者框架”
至于库和框架的区别：库的英语为 Library ( 简写 Lib )，框架的英语为 Framework。库和框架都是一种有别于软件、面向程序开发者的产品形式。正因为如此，也有很多人误以为库就是框架，或者认为指定语言的库就是框架。&lt;/p>
&lt;ul>
&lt;li>库：库是将代码集合成的一个产品，供程序员调用。面向对象的代码组织形式而成的库也叫类库。面向过程的代码组织形式而成的库也叫函数库。在函数库中的可直接使用的函数叫库函数。开发者在使用库的时候，只需要使用库的一部分类或函数，然后继续实现自己的功能。
&lt;ul>
&lt;li>标准库：就是各种语言自带的库，比如 go 里的 fmt 库，用来输出。这些标准库与语言的关键字构成了编程语言的基本功能。&lt;/li>
&lt;li>第三方库：是对编程语言的扩展，比如一种语言需要更多丰富的功能，而不仅有标准库的功能的时候，可以导入第三方库并使用它们。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>框架：框架则是为解决一个(一类)问题而开发的产品，框架用户一般只需要使用框架提供的类或函数，即可实现全部功能。可以说，框架是库的升级版。开发者在使用框架的时候，必须使用这个框架的全部代码。&lt;/li>
&lt;/ul>
&lt;p>库更像一个一个小的功能，比如使代码可以操作数据库这个功能，使代码可以监听在设备的某个端口上等等。
而框架则更像一个还没完成的程序，只有一些大体框架，其中具体的内容，可以根据自己的喜好去填充，说白了，就是一种规范，只要根据这个规范，就可以实现自己的某个程序。比如想开发一个 web 程序，就可以使用一个 web 框架，这个框架会给开发者直接提供一个基本的后端，至于其中的内容，开发者再去详细填写就好了
框架和库的比较可以想像为:
假如我们要买一台电脑：电脑内的每个部件就是编程语言的一个个关键字&lt;/p>
&lt;ol>
&lt;li>框架为我们提供了已经装好的电脑，我们只要买回来就能用，但你必须把整个电脑买回来。这样用户自然轻松许多，但会导致很多人用一样的电脑，或你想自定义某个部件将需要修改这个框架。&lt;/li>
&lt;li>库就如自己组装的电脑。库为我们提供了很多部件，我们需要自己组装，如果某个部件库未提供，我们也可以自己做。库的使用非常灵活，但没有框架方便。&lt;/li>
&lt;/ol>
&lt;p>然后通过对库和框架的使用，可以使该电脑实现我们自己想要的功能，比如玩游戏、办公、看电影等等。
程序开发中的框架(例如 1000 万+行的 Qt)往往是对常见功能的封装(类似于成语对常用含义的代指，不同点在于应用框架最终对 CPU 表达含义时候会把成语替换为原本含义-通过函数调用),抛开框架，程序会变得因缺少一些&amp;rsquo;固定成语&amp;rsquo;(函数)的&amp;rsquo;释义&amp;rsquo;(函数实现)而变得无法执行。
所以，程序框架理解为基础或者机械标准件(例如螺丝螺母这些有明确标准的机械部件)更为贴切。
这样理解，假如你要造一辆马车，在没有框架的情况下，你需要自己去伐木，去把木头做成木板，木棍，然后组成轮子，门，等部件，然后组装起来，但如果你用了框架，就相当于你有现成的轮子，门等部件，你只需要组装一下就可以了。
可以说，一个框架是一个可复用的设计构件，它规定了应用的体系结构，阐明了整个设计、协作构件之间的依赖关系、责任分配和控制流程，表现为一组抽象类以及其实例之间协作的方法，它为构件复用提供了上下文(Context)关系。因此构件库的大规模重用也需要框架。
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/cr7gm9/1616163790618-a4887423-a11b-4cfa-be93-a852be8c838f.jpeg" alt="">
拓展资料：
框架（Framework）是整个或部分系统的可重用设计，表现为一组抽象构件及构件实例间交互的方法;另一种定义认为，框架是可被应用开发者定制的应用骨架。前者是从应用方面而后者是从目的方面给出的定义。&lt;/p>
&lt;h2 id="例子">例子&lt;/h2>
&lt;p>拿 go 语言举例，当获取完一个第三方库之后(比如通过 go get 命令安装)，有时候会有一个命令行工具，比如 cobra，所以，也可以把库当做一个应用程序。而大部分时候，是不会出现一个命令行工具的，在获取完库之后，需要在 import 代码中进行引用，即可使用库中的相关函数。&lt;/p>
&lt;h1 id="编程规范">编程规范&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://mp.weixin.qq.com/s/EFMhFazZGVAoKkfwegm_TQ">无法忍受不做单元测试和内卷，我离开了这家在美中国企业&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;h2 id="method-stub">Method Stub&lt;/h2>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Method_stub">Wiki,Method stub&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>在软件开发中，&lt;strong>Method stub(方法存根)&lt;/strong> 是一段代码，用于代替某些其他编程功能&lt;/p></description></item><item><title>Docs: 开发框架</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/2.%E7%BC%96%E7%A8%8B/programming%E7%BC%96%E7%A8%8B/%E5%BC%80%E5%8F%91%E6%A1%86%E6%9E%B6/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/2.%E7%BC%96%E7%A8%8B/programming%E7%BC%96%E7%A8%8B/%E5%BC%80%E5%8F%91%E6%A1%86%E6%9E%B6/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;h2 id="参考">参考：&lt;/h2>
&lt;/blockquote>
&lt;h1 id="桌面软件开发框架">桌面软件开发框架&lt;/h1>
&lt;p>&lt;a href="https://www.bilibili.com/video/BV1Kr4y1u7Yx">https://www.bilibili.com/video/BV1Kr4y1u7Yx&lt;/a>&lt;/p>
&lt;h2 id="传统开发框架">传统开发框架&lt;/h2>
&lt;p>Qt # 推荐
wxWidgets
GTK
FLTK
Swing
JavaFX&lt;/p>
&lt;h2 id="新兴开发框架">新兴开发框架&lt;/h2>
&lt;p>MAUI
Flutter Desktop # 推荐
Compose Multiplatform&lt;/p>
&lt;h2 id="基于浏览器的桌面软件开发框架">基于浏览器的桌面软件开发框架&lt;/h2>
&lt;p>Electron # 推荐
NW.js
CEF # 推荐
Sciter
WebView2
WebView
TAURI&lt;/p>
&lt;h2 id="及时渲染桌面软件开发框架">及时渲染桌面软件开发框架&lt;/h2>
&lt;p>Dear ImGui
Nuklear
RmIUi* # 推荐&lt;/p></description></item></channel></rss>