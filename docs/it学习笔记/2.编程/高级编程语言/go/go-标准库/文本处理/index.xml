<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>断念梦 – 文本处理</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/2.%E7%BC%96%E7%A8%8B/%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/go/go-%E6%A0%87%E5%87%86%E5%BA%93/%E6%96%87%E6%9C%AC%E5%A4%84%E7%90%86/</link><description>Recent content in 文本处理 on 断念梦</description><generator>Hugo -- gohugo.io</generator><atom:link href="https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/2.%E7%BC%96%E7%A8%8B/%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/go/go-%E6%A0%87%E5%87%86%E5%BA%93/%E6%96%87%E6%9C%AC%E5%A4%84%E7%90%86/index.xml" rel="self" type="application/rss+xml"/><item><title>Docs: JSON 数据格式处理</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/2.%E7%BC%96%E7%A8%8B/%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/go/go-%E6%A0%87%E5%87%86%E5%BA%93/%E6%96%87%E6%9C%AC%E5%A4%84%E7%90%86/json-%E6%95%B0%E6%8D%AE%E6%A0%BC%E5%BC%8F%E5%A4%84%E7%90%86/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/2.%E7%BC%96%E7%A8%8B/%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/go/go-%E6%A0%87%E5%87%86%E5%BA%93/%E6%96%87%E6%9C%AC%E5%A4%84%E7%90%86/json-%E6%95%B0%E6%8D%AE%E6%A0%BC%E5%BC%8F%E5%A4%84%E7%90%86/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://pkg.go.dev/encoding/json">Go 包，标准库-encoding/json&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://blog.golang.org/json">Go 官方博客《JSON and Go》&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.cnblogs.com/f-ck-need-u/p/10080793.html">骏马金龙&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://transform.tools/json-to-go">在线 JSON 转 Go Struct&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>&lt;strong>JavaScript Object Notation(简称 JSON)&lt;/strong> 是一种简单的数据交换格式。从句法上讲，它类似于 JavaScript 的对象和列表。它最常用于 Web 后端与浏览器中运行的 JavaScript 程序之间的通信，但它也用于许多其他地方。它的主页 json.org 提供了一个清晰，简洁的标准定义。&lt;/p>
&lt;p>&lt;strong>JSON 类型 与 Go 类型 对应关系&lt;/strong>&lt;/p>
&lt;pre>&lt;code>boolean &amp;gt;&amp;gt; bool
number &amp;gt;&amp;gt; float32,float64,int, int64, uint64
string &amp;gt;&amp;gt; string
null &amp;gt;&amp;gt; nil
array &amp;gt;&amp;gt; []interface{}
object &amp;gt;&amp;gt; map[string]interface{}
&lt;/code>&lt;/pre>
&lt;p>使用 json 包，可以轻松地从 Go 程序中读取和写入 JSON 数据。&lt;/p>
&lt;h1 id="encoding-与-decoding">Encoding 与 Decoding&lt;/h1>
&lt;p>&lt;strong>Encoding(编码)&lt;/strong> 与 &lt;strong>Decoding(解码)&lt;/strong> 是 JSON 数据处理的基本操作&lt;/p>
&lt;p>在 json 包中，使用&lt;code>Marshal()&lt;/code>和 &lt;code>Unmarshal()&lt;/code> 函数来执行最基本的 Encoding 与 Decoding 行为。&lt;/p>
&lt;p>Marshal:直译为“编排、整理、排列、序列”，表示整理指定的内容，将内容整理成 json 数据。所以有时候也称此行为叫 **serializable(序列化)。**这种称呼是相对的。在计算机中特指将数据按某种描述格式编排出来，通常来说一般是从非文本格式到文本格式的数据转化。unmarshal 自然是指 marshal 的逆过程。&lt;/p>
&lt;blockquote>
&lt;p>比如在 WebService 中，我们需要把 go 的 struct 以 JSON 方式表示并在网络间传输，把 go struct 转化成 JSON 的过程就是 marshal.&lt;/p>
&lt;/blockquote>
&lt;p>用白话说：&lt;/p>
&lt;ul>
&lt;li>&lt;strong>Encoding 就是将 struct、slice、array、map 等 转换为 JSON 格式&lt;/strong>&lt;/li>
&lt;li>&lt;strong>Decoding 就是将 JSON 格式转换为 struct、slice、array、map。&lt;/strong>&lt;/li>
&lt;/ul>
&lt;h3 id="sturct-结构与-json-结构的对应关系">sturct 结构与 JSON 结构的对应关系&lt;/h3>
&lt;p>这是一个 JSON 结构的数据&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-json" data-lang="json">&lt;span style="display:flex;">&lt;span>{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;id&amp;#34;&lt;/span>: &lt;span style="color:#ae81ff">1&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;content&amp;#34;&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;hello world&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;author&amp;#34;&lt;/span>: {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;id&amp;#34;&lt;/span>: &lt;span style="color:#ae81ff">2&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;name&amp;#34;&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;userA&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> },
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;published&amp;#34;&lt;/span>: &lt;span style="color:#66d9ef">true&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;label&amp;#34;&lt;/span>: [],
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;nextPost&amp;#34;&lt;/span>: &lt;span style="color:#66d9ef">null&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;comments&amp;#34;&lt;/span>: [
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;id&amp;#34;&lt;/span>: &lt;span style="color:#ae81ff">3&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;content&amp;#34;&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;good post1&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;author&amp;#34;&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;userB&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> },
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;id&amp;#34;&lt;/span>: &lt;span style="color:#ae81ff">4&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;content&amp;#34;&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;good post2&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;author&amp;#34;&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;userC&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>如果想要让 struct 可以存储上述 JSON 格式数据，那么需要如下定义方式：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">type&lt;/span> &lt;span style="color:#a6e22e">Post&lt;/span> &lt;span style="color:#66d9ef">struct&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">ID&lt;/span> &lt;span style="color:#66d9ef">int64&lt;/span> &lt;span style="color:#e6db74">`json:&amp;#34;id&amp;#34;`&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">Content&lt;/span> &lt;span style="color:#66d9ef">string&lt;/span> &lt;span style="color:#e6db74">`json:&amp;#34;content&amp;#34;`&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">Author&lt;/span> &lt;span style="color:#a6e22e">Author&lt;/span> &lt;span style="color:#e6db74">`json:&amp;#34;author&amp;#34;`&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">Published&lt;/span> &lt;span style="color:#66d9ef">bool&lt;/span> &lt;span style="color:#e6db74">`json:&amp;#34;published&amp;#34;`&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">Label&lt;/span> []&lt;span style="color:#66d9ef">string&lt;/span> &lt;span style="color:#e6db74">`json:&amp;#34;label&amp;#34;`&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">NextPost&lt;/span> &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">Post&lt;/span> &lt;span style="color:#e6db74">`json:&amp;#34;nextPost&amp;#34;`&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">Comments&lt;/span> []&lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">Comment&lt;/span> &lt;span style="color:#e6db74">`json:&amp;#34;comments&amp;#34;`&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">type&lt;/span> &lt;span style="color:#a6e22e">Author&lt;/span> &lt;span style="color:#66d9ef">struct&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">ID&lt;/span> &lt;span style="color:#66d9ef">int64&lt;/span> &lt;span style="color:#e6db74">`json:&amp;#34;id&amp;#34;`&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">Name&lt;/span> &lt;span style="color:#66d9ef">string&lt;/span> &lt;span style="color:#e6db74">`json:&amp;#34;name&amp;#34;`&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">type&lt;/span> &lt;span style="color:#a6e22e">Comment&lt;/span> &lt;span style="color:#66d9ef">struct&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">ID&lt;/span> &lt;span style="color:#66d9ef">int64&lt;/span> &lt;span style="color:#e6db74">`json:&amp;#34;id&amp;#34;`&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">Content&lt;/span> &lt;span style="color:#66d9ef">string&lt;/span> &lt;span style="color:#e6db74">`json:&amp;#34;content&amp;#34;`&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">Author&lt;/span> &lt;span style="color:#66d9ef">string&lt;/span> &lt;span style="color:#e6db74">`json:&amp;#34;author&amp;#34;`&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="encoding编码">Encoding(编码)&lt;/h2>
&lt;p>&lt;strong>Encoding(编码)&lt;/strong> 就是指将其他类型数据封装成 JSON 格式的数据。编码编码，也就是将某些数据编排一下变成另外一种样子。&lt;/p>
&lt;p>数据转换时，遵循着一定的规范：&lt;/p>
&lt;ul>
&lt;li>&lt;strong>只有可以表示为有效 JSON 的数据结构才会被编码：&lt;/strong>
&lt;ul>
&lt;li>&lt;strong>struct、slice、array、map 都可以转换成 json&lt;/strong>&lt;/li>
&lt;li>&lt;strong>struct 转换成 json 的时候，struck 中只有字段首字母大写的属性才会被转换&lt;/strong>&lt;/li>
&lt;li>&lt;strong>map 转换的时候，key 必须为 string&lt;/strong>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>封装的时候，如果是指针，会追踪指针指向的对象进行封装&lt;/strong>&lt;/li>
&lt;li>JSON 对象仅支持字符串作为键；要编码 Go map 类型，它必须采用以下形式&lt;code>map[string]T&lt;/code>（&lt;code>T&lt;/code> json 包支持的所有 Go 类型）。&lt;/li>
&lt;li>Channel、complex、function 类型无法编码。&lt;/li>
&lt;li>不支持循环数据结构；它们将导致&lt;code>Marshal&lt;/code>陷入无限循环。&lt;/li>
&lt;li>指针将被编码为其所指向的值（如果指针为，则为“ null” &lt;code>nil&lt;/code>）。&lt;/li>
&lt;li>json 包仅访问结构类型（以大写字母开头的结构类型）的导出字段。因此，仅 struct 的导出字段将出现在 JSON 输出中。&lt;/li>
&lt;/ul>
&lt;p>在 json 包中，可以使用&lt;code>Marshal()&lt;/code>或者 &lt;code>Mashallndent()&lt;/code> 函数来执行 Encoding 行为。&lt;/p>
&lt;pre>&lt;code>func Marshal(v interface{}) ([]byte, error)
&lt;/code>&lt;/pre>
&lt;h3 id="简单示例">简单示例&lt;/h3>
&lt;p>假如现在有一个名为&lt;code>Message&lt;/code>的 struct(结构体)，这个结构体表示一条消息中应该具有的属性。比如发送者、消息内容、发送时间，等等。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">type&lt;/span> &lt;span style="color:#a6e22e">Message&lt;/span> &lt;span style="color:#66d9ef">struct&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">Name&lt;/span> &lt;span style="color:#66d9ef">string&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">Body&lt;/span> &lt;span style="color:#66d9ef">string&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">Time&lt;/span> &lt;span style="color:#66d9ef">int64&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>要想将这个 struct 中的数据转换为 JSON 格式，只需要使用 &lt;code>Marshal()&lt;/code> 函数即可&lt;/p>
&lt;p>和一个实例 &lt;code>Message&lt;/code>&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 向结构体中写入数据
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#a6e22e">m&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">Message&lt;/span>{&lt;span style="color:#e6db74">&amp;#34;DesistDaydream&amp;#34;&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;Hello&amp;#34;&lt;/span>, &lt;span style="color:#ae81ff">1294706395881547000&lt;/span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 使用 Marshal() 方法，将 m 编码为 b
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#a6e22e">b&lt;/span>, &lt;span style="color:#a6e22e">err&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">json&lt;/span>.&lt;span style="color:#a6e22e">Marshal&lt;/span>(&lt;span style="color:#a6e22e">m&lt;/span>)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;code>Marshal()&lt;/code> 返回的是一个 &lt;code>[]byte&lt;/code> 类型，现在变量 b 就存储了一段 &lt;code>[]byte&lt;/code> 类型的 JSONG 格式数据。可以使用 &lt;code>string()&lt;/code> 将类型转换为人类可读的字符串类型：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">fmt&lt;/span>.&lt;span style="color:#a6e22e">Println&lt;/span>(string(&lt;span style="color:#a6e22e">b&lt;/span>))
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>输出结果为：&lt;/p>
&lt;pre>&lt;code>{&amp;quot;Name&amp;quot;:&amp;quot;Alice&amp;quot;,&amp;quot;Body&amp;quot;:&amp;quot;Hello&amp;quot;,&amp;quot;Time&amp;quot;:1294706395881547000}
&lt;/code>&lt;/pre>
&lt;p>注意：
由于转换规范的原因导致 json 格式数据的 key 的首字母都是大写的，如果想要小写的，只需要给 struct 属性添加注释可，比如：&lt;/p>
&lt;pre>&lt;code>type Message struct {
Name string `json:&amp;quot;name&amp;quot;`
Body string `json:&amp;quot;body&amp;quot;`
Time int64 `json:&amp;quot;time&amp;quot;`
}
&lt;/code>&lt;/pre>
&lt;p>那么输出结果就是这样的：&lt;/p>
&lt;pre>&lt;code>{&amp;quot;name&amp;quot;:&amp;quot;Alice&amp;quot;,&amp;quot;body&amp;quot;:&amp;quot;Hello&amp;quot;,&amp;quot;time&amp;quot;:1294706395881547000}
&lt;/code>&lt;/pre>
&lt;p>MarshalIndent() 函数，则是可以在 Encoding 成 JSON 的时候进行美化，将会自动添加前缀和缩进(前缀字符串一般设置为空)&lt;/p>
&lt;pre>&lt;code>c,err := json.MarshalIndent(Message,&amp;quot;&amp;quot;,&amp;quot;\t&amp;quot;)
if err != nil {
fmt.Println(nil)
}
fmt.Println(string(c))
&lt;/code>&lt;/pre>
&lt;p>输出结果为：&lt;/p>
&lt;pre>&lt;code>{
&amp;quot;Name&amp;quot;: &amp;quot;Alice&amp;quot;,
&amp;quot;Body&amp;quot;: &amp;quot;Hello&amp;quot;,
&amp;quot;Time&amp;quot;: 1294706395881547000
}
&lt;/code>&lt;/pre>
&lt;h2 id="decoding解码">Decoding(解码)&lt;/h2>
&lt;p>要解码 JSON 数据，我们使用&lt;code>Unmarshal()&lt;/code>函数。&lt;/p>
&lt;blockquote>
&lt;p>Marshal 有整理、排列、序列的含义，表示整理指定的内容，将内容整理成 json 数据。那么 Unmarshal 就是 打散 这种含义。有时候也称为 &lt;strong>反序列化。&lt;/strong>
比如可以这么描述：将 json 数据反序列化成指定的数据&lt;/p>
&lt;/blockquote>
&lt;pre>&lt;code>func Unmarshal(data []byte, v interface{}) error
&lt;/code>&lt;/pre>
&lt;p>我们首先必须创建一个存储解码数据的地方&lt;/p>
&lt;pre>&lt;code>var m Message
&lt;/code>&lt;/pre>
&lt;p>并调用&lt;code>json.Unmarshal&lt;/code>，将&lt;code>[]byte&lt;/code>JSON 数据和一个指针传递给它&lt;code>m&lt;/code>&lt;/p>
&lt;pre>&lt;code>err := json.Unmarshal(b, &amp;amp;m)
&lt;/code>&lt;/pre>
&lt;p>如果&lt;code>b&lt;/code>包含有效的 JSON，适合在&lt;code>m&lt;/code>后电话&lt;code>err&lt;/code>将&lt;code>nil&lt;/code>与从数据&lt;code>b&lt;/code>将被存储在结构&lt;code>m&lt;/code>，仿佛像一个任务：&lt;/p>
&lt;pre>&lt;code>m = Message{
Name: &amp;quot;Alice&amp;quot;,
Body: &amp;quot;Hello&amp;quot;,
Time: 1294706395881547000,
}
&lt;/code>&lt;/pre>
&lt;p>如何&lt;code>Unmarshal&lt;/code>识别存储解码数据的字段？对于给定的 JSON 键&lt;code>&amp;quot;Foo&amp;quot;&lt;/code>， &lt;code>Unmarshal&lt;/code>将浏览目标结构的字段以查找(按优先顺序)：&lt;/p>
&lt;ul>
&lt;li>标记为的导出字段&lt;code>&amp;quot;Foo&amp;quot;&lt;/code>（ 有关 struct 标记的更多信息，请参见 Go 规范），&lt;/li>
&lt;li>名为&lt;code>&amp;quot;Foo&amp;quot;&lt;/code>或的导出字段&lt;/li>
&lt;li>名为&lt;code>&amp;quot;FOO&amp;quot;&lt;/code>或&lt;code>&amp;quot;FoO&amp;quot;&lt;/code>或其他不区分大小写的匹配项的导出字段&lt;code>&amp;quot;Foo&amp;quot;&lt;/code>。&lt;/li>
&lt;/ul>
&lt;p>当 JSON 数据的结构与 Go 类型不完全匹配时会发生什么？&lt;/p>
&lt;pre>&lt;code>b := []byte(`{&amp;quot;Name&amp;quot;:&amp;quot;Bob&amp;quot;,&amp;quot;Food&amp;quot;:&amp;quot;Pickle&amp;quot;}`)
var m Message
err := json.Unmarshal(b, &amp;amp;m)
&lt;/code>&lt;/pre>
&lt;p>&lt;code>Unmarshal&lt;/code>只会解码在目标类型中可以找到的字段。在这种情况下，将仅填充 m 的 Name 字段，而 Food 字段将被忽略。当您希望从大型 JSON Blob 中仅选择几个特定字段时，此行为特别有用。这也意味着目标 struct 中所有未导出的字段都不会受到的影响&lt;code>Unmarshal&lt;/code>。&lt;/p>
&lt;p>但是，如果您事先不知道 JSON 数据的结构怎么办？&lt;/p>
&lt;h1 id="使用-interface-存放通用-json-数据">使用 interface{} 存放通用 JSON 数据&lt;/h1>
&lt;p>的&lt;code>interface{}&lt;/code>（空接口）类型描述了具有零种方法的接口。每个 Go 类型至少实现零个方法，因此满足空接口。&lt;/p>
&lt;p>空接口用作常规容器类型：&lt;/p>
&lt;pre>&lt;code>var i interface{}
i = &amp;quot;a string&amp;quot;
i = 2011
i = 2.777
&lt;/code>&lt;/pre>
&lt;p>类型断言访问基础的具体类型：&lt;/p>
&lt;pre>&lt;code>r := i.(float64)
fmt.Println(&amp;quot;the circle's area&amp;quot;, math.Pi*r*r)
&lt;/code>&lt;/pre>
&lt;p>或者，如果基础类型未知，则由类型开关确定类型：&lt;/p>
&lt;pre>&lt;code>switch v := i.(type) {
case int:
fmt.Println(&amp;quot;twice i is&amp;quot;, v*2)
case float64:
fmt.Println(&amp;quot;the reciprocal of i is&amp;quot;, 1/v)
case string:
h := len(v) / 2
fmt.Println(&amp;quot;i swapped by halves is&amp;quot;, v[h:]+v[:h])
default:
// i isn't one of the types above
}
&lt;/code>&lt;/pre>
&lt;p>json 包使用&lt;code>map[string]interface{}&lt;/code>和 &lt;code>[]interface{}&lt;/code>值来存储任意 JSON 对象和数组；它将很乐意将任何有效的 JSON Blob 解组为纯 &lt;code>interface{}&lt;/code>值。默认的具体 Go 类型为：&lt;/p>
&lt;ul>
&lt;li>&lt;code>bool&lt;/code> 对于 JSON 布尔值，&lt;/li>
&lt;li>&lt;code>float64&lt;/code> 对于 JSON 数字，&lt;/li>
&lt;li>&lt;code>string&lt;/code> 用于 JSON 字符串，以及&lt;/li>
&lt;li>&lt;code>nil&lt;/code> JSON null。&lt;/li>
&lt;/ul>
&lt;h1 id="解码任意数据">解码任意数据&lt;/h1>
&lt;p>考虑以下存储在变量中的 JSON 数据&lt;code>b&lt;/code>：&lt;/p>
&lt;pre>&lt;code>b := []byte(`{&amp;quot;Name&amp;quot;:&amp;quot;Wednesday&amp;quot;,&amp;quot;Age&amp;quot;:6,&amp;quot;Parents&amp;quot;:[&amp;quot;Gomez&amp;quot;,&amp;quot;Morticia&amp;quot;]}`)
&lt;/code>&lt;/pre>
&lt;p>在不知道此数据结构的情况下，我们可以使用以下命令将其解码为一个&lt;code>interface{}&lt;/code>值&lt;code>Unmarshal&lt;/code>：&lt;/p>
&lt;pre>&lt;code>var f interface{}
err := json.Unmarshal(b, &amp;amp;f)
&lt;/code>&lt;/pre>
&lt;p>此时，Go 值&lt;code>f&lt;/code>将是一个映射，其键为字符串，其值本身存储为空接口值：&lt;/p>
&lt;pre>&lt;code>f = map[string]interface{}{
&amp;quot;Name&amp;quot;: &amp;quot;Wednesday&amp;quot;,
&amp;quot;Age&amp;quot;: 6,
&amp;quot;Parents&amp;quot;: []interface{}{
&amp;quot;Gomez&amp;quot;,
&amp;quot;Morticia&amp;quot;,
},
}
&lt;/code>&lt;/pre>
&lt;p>要访问此数据，我们可以使用类型断言来访问&lt;code>f&lt;/code>的底层&lt;code>map[string]interface{}&lt;/code>：&lt;/p>
&lt;pre>&lt;code>m := f.(map[string]interface{})
&lt;/code>&lt;/pre>
&lt;p>1
Plain Text&lt;/p>
&lt;p>然后，我们可以使用 range 语句遍历 map，并使用类型开关将其值作为其具体类型来访问：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">for&lt;/span> &lt;span style="color:#a6e22e">k&lt;/span>, &lt;span style="color:#a6e22e">v&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#66d9ef">range&lt;/span> &lt;span style="color:#a6e22e">m&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">switch&lt;/span> &lt;span style="color:#a6e22e">vv&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">v&lt;/span>.(&lt;span style="color:#66d9ef">type&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">case&lt;/span> &lt;span style="color:#66d9ef">string&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">fmt&lt;/span>.&lt;span style="color:#a6e22e">Println&lt;/span>(&lt;span style="color:#a6e22e">k&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;is string&amp;#34;&lt;/span>, &lt;span style="color:#a6e22e">vv&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">case&lt;/span> &lt;span style="color:#66d9ef">float64&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">fmt&lt;/span>.&lt;span style="color:#a6e22e">Println&lt;/span>(&lt;span style="color:#a6e22e">k&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;is float64&amp;#34;&lt;/span>, &lt;span style="color:#a6e22e">vv&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">case&lt;/span> []&lt;span style="color:#66d9ef">interface&lt;/span>{}:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">fmt&lt;/span>.&lt;span style="color:#a6e22e">Println&lt;/span>(&lt;span style="color:#a6e22e">k&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;is an array:&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span> &lt;span style="color:#a6e22e">i&lt;/span>, &lt;span style="color:#a6e22e">u&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#66d9ef">range&lt;/span> &lt;span style="color:#a6e22e">vv&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">fmt&lt;/span>.&lt;span style="color:#a6e22e">Println&lt;/span>(&lt;span style="color:#a6e22e">i&lt;/span>, &lt;span style="color:#a6e22e">u&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">default&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">fmt&lt;/span>.&lt;span style="color:#a6e22e">Println&lt;/span>(&lt;span style="color:#a6e22e">k&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;is of a type I don&amp;#39;t know how to handle&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>这样，您可以使用未知的 JSON 数据，同时仍然享有类型安全的好处。&lt;/p>
&lt;h1 id="参考类型">参考类型&lt;/h1>
&lt;p>让我们定义一个 Go 类型以包含上一个示例中的数据：&lt;/p>
&lt;pre>&lt;code>type FamilyMember struct {
Name string
Age int
Parents []string
}
var m FamilyMember
err := json.Unmarshal(b, &amp;amp;m)
&lt;/code>&lt;/pre>
&lt;p>将数据分解为一个&lt;code>FamilyMember&lt;/code>值可以按预期工作，但是如果仔细观察，我们可以看到发生了一件了不起的事情。使用 var 语句，我们分配了一个&lt;code>FamilyMember&lt;/code>结构，然后将指向该值的指针提供给&lt;code>Unmarshal&lt;/code>，但那时该&lt;code>Parents&lt;/code>字段是一个&lt;code>nil&lt;/code>切片值。要填充该&lt;code>Parents&lt;/code>字段，请&lt;code>Unmarshal&lt;/code>在幕后分配一个新切片。这是&lt;code>Unmarshal&lt;/code>与支持的参考类型（指针，切片和地图）一起使用的典型方式。
考虑拆封到此数据结构中：&lt;/p>
&lt;pre>&lt;code>type Foo struct {
Bar *Bar
}
&lt;/code>&lt;/pre>
&lt;p>如果&lt;code>Bar&lt;/code>JSON 对象中有一个字段，&lt;code>Unmarshal&lt;/code>则将分配一个新字段 &lt;code>Bar&lt;/code>并填充它。如果不是，&lt;code>Bar&lt;/code>则将其留为&lt;code>nil&lt;/code>指针。
由此产生一种有用的模式：如果您的应用程序接收一些不同的消息类型，则可以定义“接收器”结构，例如&lt;/p>
&lt;pre>&lt;code>type IncomingMessage struct {
Cmd *Command
Msg *Message
}
&lt;/code>&lt;/pre>
&lt;p>发送方可以根据他们想要传达的消息类型来填充顶级 JSON 对象的&lt;code>Cmd&lt;/code>字段和/或&lt;code>Msg&lt;/code>字段。 &lt;code>Unmarshal&lt;/code>，当将 JSON 解码为&lt;code>IncomingMessage&lt;/code>结构时，只会分配 JSON 数据中存在的数据结构。要知道这消息的过程中，程序员需要简单地测试，要么&lt;code>Cmd&lt;/code>或&lt;code>Msg&lt;/code>不是&lt;code>nil&lt;/code>。&lt;/p>
&lt;h1 id="流编码器和解码器">流编码器和解码器&lt;/h1>
&lt;p>json 包提供了&lt;code>Decoder&lt;/code>和&lt;code>Encoder&lt;/code>类型，以支持读写 JSON 数据流的通用操作。的&lt;code>NewDecoder&lt;/code>和&lt;code>NewEncoder&lt;/code>功能包裹&lt;code>[io.Reader](https://golang.org/pkg/io/#Reader)&lt;/code> 和&lt;code>[io.Writer](https://golang.org/pkg/io/#Writer)&lt;/code>接口类型。&lt;/p>
&lt;pre>&lt;code>func NewDecoder(r io.Reader) *Decoder
func NewEncoder(w io.Writer) *Encoder
&lt;/code>&lt;/pre>
&lt;p>这是一个示例程序，该程序从标准输入读取一系列 JSON 对象，&lt;code>Name&lt;/code>从每个对象中删除除字段以外的所有内容，然后将这些对象写入标准输出：&lt;/p>
&lt;pre>&lt;code>package main
import (
&amp;quot;encoding/json&amp;quot;
&amp;quot;log&amp;quot;
&amp;quot;os&amp;quot;
)
func main() {
dec := json.NewDecoder(os.Stdin)
enc := json.NewEncoder(os.Stdout)
for {
var v map[string]interface{}
if err := dec.Decode(&amp;amp;v); err != nil {
log.Println(err)
return
}
for k := range v {
if k != &amp;quot;Name&amp;quot; {
delete(v, k)
}
}
if err := enc.Encode(&amp;amp;v); err != nil {
log.Println(err)
}
}
}
&lt;/code>&lt;/pre>
&lt;p>由于读取器和编写的普及，这些&lt;code>Encoder&lt;/code>和&lt;code>Decoder&lt;/code>类型可以在宽范围内的情况下，如读出和写入 HTTP 连接，的 WebSockets，或文件中使用。&lt;/p>
&lt;h2 id="参考">参考&lt;/h2>
&lt;p>有关更多信息，请参阅&lt;a href="https://golang.org/pkg/encoding/json/">json 包文档&lt;/a>。有关 json 的用法示例，请参阅&lt;a href="https://golang.org/pkg/net/rpc/jsonrpc/">jsonrpc 包&lt;/a>的源文件。&lt;/p>
&lt;h1 id="相关文章">相关文章&lt;/h1>
&lt;ul>
&lt;li>&lt;a href="https://blog.golang.org/protobuf-apiv2">用于协议缓冲区的新 Go API&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://blog.golang.org/go1.13-errors">在 Go 1.13 中处理错误&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://blog.golang.org/debug-opt">调试在 Go 1.12 中部署的内容&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://blog.golang.org/h2push">HTTP / 2 服务器推送&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://blog.golang.org/http-tracing">介绍 HTTP 跟踪&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://blog.golang.org/generate">产生程式码&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://blog.golang.org/race-detector">隆重推出 Go Race Detector&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://blog.golang.org/maps">行动地图&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://blog.golang.org/gofmt">去你的代码&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://blog.golang.org/organizing-go-code">组织 Go 代码&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://blog.golang.org/debug-gdb">使用 GNU 调试器调试 Go 程序&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://blog.golang.org/image-draw">Go 图片/绘图包&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://blog.golang.org/image">Go 图像包&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://blog.golang.org/laws-of-reflection">反射定律&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://blog.golang.org/error-handling-and-go">错误处理和执行&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://blog.golang.org/functions-codewalk">Go 中的一流函数&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://blog.golang.org/pprof">分析 Go 程序&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://blog.golang.org/gif-decoder">GIF 解码器：Go 接口中的练习&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://blog.golang.org/introducing-gofix">介绍 Gofix&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://blog.golang.org/godoc">Godoc：记录 Go 代码&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://blog.golang.org/gob">数据块&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://blog.golang.org/cgo">C？走？go！&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://blog.golang.org/slices-intro">切成薄片：用法和内部原理&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://blog.golang.org/concurrency-timeouts">Go 并发模式：超时，继续前进&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://blog.golang.org/defer-panic-and-recover">推迟，恐慌和恢复&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://blog.golang.org/codelab-share">通过通信共享内存&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://blog.golang.org/json-rpc">JSON-RPC：接口的故事&lt;/a>&lt;/li>
&lt;/ul>
&lt;h1 id="其他文章">其他文章&lt;/h1>
&lt;p>使用了太长时间的 python，对于强类型的 Golang 适应起来稍微有点费力，不过操作一次之后发现，只有这么严格的类型规定，才能让数据尽量减少在传输和解析过程中的错误。我尝试使用 Golang 创建了一个公司的 OpenAPI 的 demo，记录一下中间遇到的问题。&lt;/p>
&lt;h2 id="编码encodejson">编码(Encode)Json：&lt;/h2>
&lt;p>首先来看下如何将字典编码成 Json：&lt;/p>
&lt;pre>&lt;code>// 首先使用字面量来申明和初始化一个字典
param := map[string]int{&amp;quot;page_no&amp;quot;: 1, &amp;quot;page_size&amp;quot;: 40}
paramJson, err := json.Marshal(param)
&lt;/code>&lt;/pre>
&lt;p>1
2
3
Go&lt;/p>
&lt;p>使用 json.Marshal 接收需要 json.encode 的变量。而 json.Marshal 接收的是 interface{}接口变量，该接口变量可以接收任何类型的数据。&lt;/p>
&lt;h2 id="http-包的-post-请求来实践对-json-的序列化反序列化">Http 包的 POST 请求来实践对 JSON 的序列化、反序列化：&lt;/h2>
&lt;p>当我们把 json 编码好之后我们需要将信息传递给服务器。所以用到了 http 包。&lt;/p>
&lt;p>在使用了之后我觉得 go 的 http 包真的非常方便，的确如传言中描述的强大和人性化，方便实用。&lt;/p>
&lt;pre>&lt;code>resp , err := http.PostForm(requestUrl, url.Values{&amp;quot;api_key&amp;quot;: {ApiKey}, &amp;quot;api_sign&amp;quot;: {apiSign},
&amp;quot;param&amp;quot;: {string(param)}, &amp;quot;time&amp;quot;: {now_time}, &amp;quot;version&amp;quot;: {version}})
&lt;/code>&lt;/pre>
&lt;p>1
2
Go&lt;/p>
&lt;p>这里我使用 http.PostForm 方法使用带参数传递的 post 方法请求服务器。url.Values 后面可以跟 key[string][]string 的形式传递参数。返回一个 http.response 结构体指针和一个 error 类型。&lt;/p>
&lt;p>http.response 具体带有哪些属性可以详细查看一下包，这里我们会去解析他的 Body 字段，里面存储着返回的内容：&lt;/p>
&lt;pre>&lt;code>// The Body is automatically dechunked if the server replied
// with a &amp;quot;chunked&amp;quot; Transfer-Encoding.
Body io.ReadCloser
&lt;/code>&lt;/pre>
&lt;p>1
2
3
Go&lt;/p>
&lt;p>这里 Body 是一个有 io.ReadCloser 接口的值。io.ReadCloser 接口实现了 Read()和 Write()方法。&lt;/p>
&lt;p>我会用 json 的 Decoder 去解析它：&lt;/p>
&lt;pre>&lt;code>var response openApiResponse
resp := request.RequestHeader(paramJson, version, SyncUrl)
err1 := json.NewDecoder(resp.Body).Decode(&amp;amp;response)
if err1 != nil {
log.Println(err1)
}
return resp
&lt;/code>&lt;/pre>
&lt;p>1
2
3
4
5
6
7
Go&lt;/p>
&lt;p>这里 json.NewDecoder 接收一个有 Reader 方法的变量，之后我们调用了 Decoder 的方法 decode 将里面的内容都存入事先申请好的 response 结构体变量中。这个变量初始化了我们通过文档了解到的返回的结构体字段类型。&lt;/p>
&lt;pre>&lt;code>openApiResponse struct {
Success bool `json:&amp;quot;success&amp;quot;`
ResultCode int `json:&amp;quot;result_code&amp;quot;`
ResultMsg string `json:&amp;quot;result_msg&amp;quot;`
// 接收JSON字段
Result GoodsSyncResult `json:&amp;quot;result&amp;quot;`
}
&lt;/code>&lt;/pre>
&lt;p>1
2
3
4
5
6
7
Go&lt;/p>
&lt;p>这样一级一级解析下去，在构造接收返回回来数据的结构体的时候，注意到后面的 json 字段。他是一个 tag，可以在解析 json 的时候将对应名字的 tag 解析到对应的变量中。&lt;/p>
&lt;p>这样就相当于你做好了数据结构，然后将对应的数据放到对应的字段里面去。&lt;/p>
&lt;p>当然还有一种办法，当你不知道你所接收数据的数据结构的时候，你是没有办法提前声明好这些数据结构然后来接收的。这时我们可以申明一个空接口 interface{}，让空接口的指针来接收这组数据，可以查看这组数据的数据结构。&lt;/p>
&lt;pre>&lt;code>var hahaha interface{}
resp := request.RequestHeader(paramJson, version, SyncUrl)
err1 := json.NewDecoder(resp.Body).Decode(&amp;amp;hahaha)
if err1 != nil {
log.Println(err1)
}
&lt;/code>&lt;/pre>
&lt;p>1
2
3
4
5
6
Go&lt;/p>
&lt;p>上面的 hahaha 可以接收并 decodejson，来接收这组数据。并且可以直接使用 fmt.Print 之类函数直接打印接收到的数据。如果想直接使用，我们可以使用类型断言但是更推荐的方法是，我们可以根据这组数据来写对应的结构体，然后将数据接收到结构体上进行操作。就像上面一样。&lt;/p>
&lt;p>同样的我们还可以使用一个 map[string]interface{}来接收这个 Json 以方便对其进行后续操作，避免不需要的多余的反射。&lt;/p>
&lt;pre>&lt;code>var hahaha map[string]interface{}
resp := request.RequestHeader(paramJson, version, SyncUrl)
err1 := json.NewDecoder(resp.Body).Decode(&amp;amp;hahaha)
return hahaha
&lt;/code>&lt;/pre>
&lt;p>1
2
3
4
Plain Text&lt;/p>
&lt;p>除了实现一个 decoder 来处理数据，我们往往有 Json 序列化之后就立即需要序列化的操作，这个同样很容易使用：&lt;/p>
&lt;pre>&lt;code>json.Unmarshal([]byte, &amp;amp;xx)
&lt;/code>&lt;/pre>
&lt;p>1
Plain Text&lt;/p>
&lt;p>来处理就好了。参数一是需要 decode 的 Json 数据, 参数二是用于接收这组数据的结构体字段。同样的我们也可以使用一个空接口来接收数据，也可以使用一一对应的结构体来放置数据。&lt;/p>
&lt;p>看了上面的一堆介绍有一个感觉，就处理 Json 数据和类型转换来说。。python 真是简单到爆炸，一个 dumps 一个 loads 轻松搞定。但是 Golang 严格的参数类型缺可以保证解析过来的数据一定是对应的数据结构和数据类型。不会在类型上报错更为严谨。个人觉得这很有趣，也很喜欢。&lt;/p></description></item><item><title>Docs: JSON 数据格式处理</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/2.%E7%BC%96%E7%A8%8B/%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/go/go-%E6%A0%87%E5%87%86%E5%BA%93/%E6%96%87%E6%9C%AC%E5%A4%84%E7%90%86/json-%E6%95%B0%E6%8D%AE%E6%A0%BC%E5%BC%8F%E5%A4%84%E7%90%86/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/2.%E7%BC%96%E7%A8%8B/%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/go/go-%E6%A0%87%E5%87%86%E5%BA%93/%E6%96%87%E6%9C%AC%E5%A4%84%E7%90%86/json-%E6%95%B0%E6%8D%AE%E6%A0%BC%E5%BC%8F%E5%A4%84%E7%90%86/</guid><description/></item><item><title>Docs: YAML 数据处理</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/2.%E7%BC%96%E7%A8%8B/%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/go/go-%E6%A0%87%E5%87%86%E5%BA%93/%E6%96%87%E6%9C%AC%E5%A4%84%E7%90%86/yaml-%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/2.%E7%BC%96%E7%A8%8B/%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/go/go-%E6%A0%87%E5%87%86%E5%BA%93/%E6%96%87%E6%9C%AC%E5%A4%84%E7%90%86/yaml-%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/</guid><description>
&lt;p>YAML解析库 沿用了 JSON解析库 的相关说法。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">package&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">import&lt;/span> (
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#34;fmt&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#34;io/ioutil&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#34;log&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#34;gopkg.in/yaml.v2&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">//Nginx nginx 配置
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">type&lt;/span> &lt;span style="color:#a6e22e">Nginx&lt;/span> &lt;span style="color:#66d9ef">struct&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">Port&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#e6db74">`yaml:&amp;#34;Port&amp;#34;`&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">LogPath&lt;/span> &lt;span style="color:#66d9ef">string&lt;/span> &lt;span style="color:#e6db74">`yaml:&amp;#34;LogPath&amp;#34;`&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">Path&lt;/span> &lt;span style="color:#66d9ef">string&lt;/span> &lt;span style="color:#e6db74">`yaml:&amp;#34;Path&amp;#34;`&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">//Config 系统配置配置
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">type&lt;/span> &lt;span style="color:#a6e22e">Config&lt;/span> &lt;span style="color:#66d9ef">struct&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">Name&lt;/span> &lt;span style="color:#66d9ef">string&lt;/span> &lt;span style="color:#e6db74">`yaml:&amp;#34;SiteName&amp;#34;`&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">Addr&lt;/span> &lt;span style="color:#66d9ef">string&lt;/span> &lt;span style="color:#e6db74">`yaml:&amp;#34;SiteAddr&amp;#34;`&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">HTTPS&lt;/span> &lt;span style="color:#66d9ef">bool&lt;/span> &lt;span style="color:#e6db74">`yaml:&amp;#34;Https&amp;#34;`&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">SiteNginx&lt;/span> &lt;span style="color:#a6e22e">Nginx&lt;/span> &lt;span style="color:#e6db74">`yaml:&amp;#34;Nginx&amp;#34;`&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">func&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">var&lt;/span> &lt;span style="color:#a6e22e">setting&lt;/span> &lt;span style="color:#a6e22e">Config&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">config&lt;/span>, &lt;span style="color:#a6e22e">errRead&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">ioutil&lt;/span>.&lt;span style="color:#a6e22e">ReadFile&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;./info.yaml&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> &lt;span style="color:#a6e22e">errRead&lt;/span> &lt;span style="color:#f92672">!=&lt;/span> &lt;span style="color:#66d9ef">nil&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">fmt&lt;/span>.&lt;span style="color:#a6e22e">Print&lt;/span>(&lt;span style="color:#a6e22e">errRead&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">errUnmarshal&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">yaml&lt;/span>.&lt;span style="color:#a6e22e">Unmarshal&lt;/span>(&lt;span style="color:#a6e22e">config&lt;/span>, &lt;span style="color:#f92672">&amp;amp;&lt;/span>&lt;span style="color:#a6e22e">setting&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> &lt;span style="color:#a6e22e">errUnmarshal&lt;/span> &lt;span style="color:#f92672">!=&lt;/span> &lt;span style="color:#66d9ef">nil&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">log&lt;/span>.&lt;span style="color:#a6e22e">Fatalf&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;error: %v&amp;#34;&lt;/span>, &lt;span style="color:#a6e22e">errUnmarshal&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">fmt&lt;/span>.&lt;span style="color:#a6e22e">Println&lt;/span>(&lt;span style="color:#a6e22e">setting&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">fmt&lt;/span>.&lt;span style="color:#a6e22e">Println&lt;/span>(&lt;span style="color:#a6e22e">setting&lt;/span>.&lt;span style="color:#a6e22e">Name&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">fmt&lt;/span>.&lt;span style="color:#a6e22e">Println&lt;/span>(&lt;span style="color:#a6e22e">setting&lt;/span>.&lt;span style="color:#a6e22e">Addr&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">fmt&lt;/span>.&lt;span style="color:#a6e22e">Println&lt;/span>(&lt;span style="color:#a6e22e">setting&lt;/span>.&lt;span style="color:#a6e22e">HTTPS&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">fmt&lt;/span>.&lt;span style="color:#a6e22e">Println&lt;/span>(&lt;span style="color:#a6e22e">setting&lt;/span>.&lt;span style="color:#a6e22e">SiteNginx&lt;/span>.&lt;span style="color:#a6e22e">Port&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">fmt&lt;/span>.&lt;span style="color:#a6e22e">Println&lt;/span>(&lt;span style="color:#a6e22e">setting&lt;/span>.&lt;span style="color:#a6e22e">SiteNginx&lt;/span>.&lt;span style="color:#a6e22e">LogPath&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">fmt&lt;/span>.&lt;span style="color:#a6e22e">Println&lt;/span>(&lt;span style="color:#a6e22e">setting&lt;/span>.&lt;span style="color:#a6e22e">SiteNginx&lt;/span>.&lt;span style="color:#a6e22e">Path&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div></description></item><item><title>Docs: 正则处理</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/2.%E7%BC%96%E7%A8%8B/%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/go/go-%E6%A0%87%E5%87%86%E5%BA%93/%E6%96%87%E6%9C%AC%E5%A4%84%E7%90%86/%E6%AD%A3%E5%88%99%E5%A4%84%E7%90%86/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/2.%E7%BC%96%E7%A8%8B/%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/go/go-%E6%A0%87%E5%87%86%E5%BA%93/%E6%96%87%E6%9C%AC%E5%A4%84%E7%90%86/%E6%AD%A3%E5%88%99%E5%A4%84%E7%90%86/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://www.cnblogs.com/williamjie/p/9686311.html">原文链接&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>手机号码正则匹配&lt;/p>
&lt;pre>&lt;code>String PHONE_NUMBER_REG = &amp;quot;^(13[0-9]|14[579]|15[0-3,5-9]|16[6]|17[0135678]|18[0-9]|19[89])\\d{8}$&amp;quot;;
/**
* JS 使用
*/
&amp;quot;18016381232&amp;quot;.match(/^(13[0-9]|14[579]|15[0-3,5-9]|16[6]|17[0135678]|18[0-9]|19[89])\d{8}$/)
&lt;/code>&lt;/pre>
&lt;h2 id="元字符">元字符：&lt;/h2>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;/table>
&lt;p>| 代码
说明
.
匹配除换行符以外的任意字符
\w
匹配字母或数字或下划线或汉字
\s
匹配任意的空白符
\d
匹配数字
\b
匹配单词的开始或结束
^
匹配字符串的开始
$
匹配字符串的结束 |
| |&lt;/p>
&lt;h2 id="字符转义">字符转义：&lt;/h2>
&lt;p>如果你想查找元字符本身的话，比如你查找.,或者*,就出现了问题：你没办法指定它们，因为它们会被解释成别的意思。这时你就得使用\来取消这些字符的特殊意义。因此，你应该使用.和*。当然，要查找\本身，你也得用\.&lt;/p>
&lt;p>例如：deerchao.net 匹配 deerchao.net，C:\Windows 匹配 C:\Windows&lt;/p>
&lt;h2 id="重复">重复：&lt;/h2>
&lt;p>你已经看过了前面的*,+,{2},{5,12}这几个匹配重复的方式了。下面是正则表达式中所有的限定符(指定数量的代码，例如*,{5,12}等)：&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>&lt;/th>
&lt;th>&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>代码/语法&lt;/td>
&lt;td>说明&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>*&lt;/td>
&lt;td>重复零次或更多次&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>+&lt;/td>
&lt;td>重复一次或更多次&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>?&lt;/td>
&lt;td>重复零次或一次&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>{n}&lt;/td>
&lt;td>重复 n 次&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>{n,}&lt;/td>
&lt;td>重复 n 次或更多次&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>{n,m}&lt;/td>
&lt;td>重复 n 到 m 次&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>下面是一些使用重复的例子：&lt;/p>
&lt;p>Windows\d+匹配 Windows 后面跟 1 个或更多数字&lt;/p>
&lt;p>^\w+匹配一行的第一个单词(或整个字符串的第一个单词，具体匹配哪个意思得看选项设置)&lt;/p>
&lt;h2 id="字符类">字符类：&lt;/h2>
&lt;p>要想查找数字，字母或数字，空白是很简单的，因为已经有了对应这些字符集合的元字符，但是如果你想匹配没有预定义元字符的字符集合(比如元音字母 a,e,i,o,u),应该怎么办？&lt;/p>
&lt;p>很简单，你只需要在方括号里列出它们就行了，像[aeiou]就匹配任何一个英文元音字母，[.?!]匹配标点符号(.或?或!)。&lt;/p>
&lt;p>我们也可以轻松地指定一个字符范围，像[0-9]代表的含意与\d 就是完全一致的：一位数字；同理[a-z0-9A-Z_]也完全等同于\w（如果只考虑英文的话）。&lt;/p>
&lt;p>下面是一个更复杂的表达式：(?0\d{2}[) -]?\d{8}。&lt;/p>
&lt;p>“(”和“)”也是元字符，后面的分组节里会提到，所以在这里需要使用转义。&lt;/p>
&lt;p>这个表达式可以匹配几种格式的电话号码，像(010)88886666，或 022-22334455，或 02912345678 等。我们对它进行一些分析吧：首先是一个转义字符(,它能出现 0 次或 1 次(?),然后是一个 0，后面跟着 2 个数字(\d{2})，然后是)或-或空格中的一个，它出现 1 次或不出现(?)，最后是 8 个数字(\d{8})。&lt;/p>
&lt;h2 id="分枝条件">分枝条件：&lt;/h2>
&lt;p>不幸的是，刚才那个表达式也能匹配 010)12345678 或(022-87654321 这样的“不正确”的格式。要解决这个问题，我们需要用到分枝条件。正则表达式里的分枝条件指的是有几种规则，如果满足其中任意一种规则都应该当成匹配，具体方法是用|把不同的规则分隔开。听不明白？没关系，看例子：&lt;/p>
&lt;p>0\d{2}-\d{8}|0\d{3}-\d{7}这个表达式能匹配两种以连字号分隔的电话号码：一种是三位区号，8 位本地号(如 010-12345678)，一种是 4 位区号，7 位本地号(0376-2233445)。&lt;/p>
&lt;p>(?0\d{2})?[- ]?\d{8}|0\d{2}[- ]?\d{8}这个表达式匹配 3 位区号的电话号码，其中区号可以用小括号括起来，也可以不用，区号与本地号间可以用连字号或空格间隔，也可以没有间隔。你可以试试用分枝条件把这个表达式扩展成也支持 4 位区号的。&lt;/p>
&lt;p>\d{5}-\d{4}|\d{5}这个表达式用于匹配美国的邮政编码。美国邮编的规则是 5 位数字，或者用连字号间隔的 9 位数字。之所以要给出这个例子是因为它能说明一个问题：&lt;strong>使用分枝条件时，要注意各个条件的顺序&lt;/strong>。如果你把它改成\d{5}|\d{5}-\d{4}的话，那么就只会匹配 5 位的邮编(以及 9 位邮编的前 5 位)。原因是匹配分枝条件时，将会从左到右地测试每个条件，如果满足了某个分枝的话，就不会去再管其它的条件了。&lt;/p>
&lt;h2 id="分组">分组&lt;/h2>
&lt;p>我们已经提到了怎么重复单个字符（直接在字符后面加上限定符就行了）；但如果想要重复多个字符又该怎么办？你可以用小括号来指定子表达式(也叫做分组)，然后你就可以指定这个子表达式的重复次数了，你也可以对子表达式进行其它一些操作(后面会有介绍)。&lt;/p>
&lt;p>(\d{1,3}.){3}\d{1,3}是一个简单的 IP 地址匹配表达式。要理解这个表达式，请按下列顺序分析它：\d{1,3}匹配 1 到 3 位的数字，(\d{1,3}.){3}匹配三位数字加上一个英文句号(这个整体也就是这个分组)重复 3 次，最后再加上一个一到三位的数字(\d{1,3})。&lt;/p>
&lt;p>IP 地址中每个数字都不能大于 255. 经常有人问我, 01.02.03.04 这样前面带有 0 的数字, 是不是正确的 IP 地址呢? 答案是: 是的, IP 地址里的数字可以包含有前导 0 (leading zeroes).&lt;/p>
&lt;p>不幸的是，它也将匹配 256.300.888.999 这种不可能存在的 IP 地址。如果能使用算术比较的话，或许能简单地解决这个问题，但是正则表达式中并不提供关于数学的任何功能，所以只能使用冗长的分组，选择，字符类来描述一个正确的 IP 地址：((2[0-4]\d|25[0-5]|[01]?\d\d?).){3}(2[0-4]\d|25[0-5]|[01]?\d\d?)。&lt;/p>
&lt;p>理解这个表达式的关键是理解 2[0-4]\d|25[0-5]|[01]?\d\d?，这里我就不细说了，你自己应该能分析得出来它的意义。&lt;/p>
&lt;h2 id="反义">反义&lt;/h2>
&lt;p>有时需要查找不属于某个能简单定义的字符类的字符。比如想查找除了数字以外，其它任意字符都行的情况，这时需要用到反义：&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>&lt;/th>
&lt;th>&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>代码/语法&lt;/td>
&lt;td>说明&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>\W&lt;/td>
&lt;td>匹配任意不是字母，数字，下划线，汉字的字符&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>\S&lt;/td>
&lt;td>匹配任意不是空白符的字符&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>\D&lt;/td>
&lt;td>匹配任意非数字的字符&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>\B&lt;/td>
&lt;td>匹配不是单词开头或结束的位置&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>[^x]&lt;/td>
&lt;td>匹配除了 x 以外的任意字符&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>[^aeiou]&lt;/td>
&lt;td>匹配除了 aeiou 这几个字母以外的任意字符&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>例子：\S+匹配不包含空白符的字符串。&lt;/p>
&lt;p>&amp;lt;a[^&amp;gt;]+&amp;gt;匹配用尖括号括起来的以 a 开头的字符串。&lt;/p>
&lt;h2 id="后向引用">后向引用&lt;/h2>
&lt;p>使用小括号指定一个子表达式后，&lt;strong>匹配这个子表达式的文本&lt;/strong>(也就是此分组捕获的内容)可以在表达式或其它程序中作进一步的处理。默认情况下，每个分组会自动拥有一个组号，规则是：从左向右，以分组的左括号为标志，第一个出现的分组的组号为 1，第二个为 2，以此类推。&lt;/p>
&lt;p>呃……其实,组号分配还不像我刚说得那么简单：&lt;/p>
&lt;ul>
&lt;li>分组 0 对应整个正则表达式&lt;/li>
&lt;li>实际上组号分配过程是要从左向右扫描两遍的：第一遍只给未命名组分配，第二遍只给命名组分配－－因此所有命名组的组号都大于未命名的组号&lt;/li>
&lt;li>你可以使用(?:exp)这样的语法来剥夺一个分组对组号分配的参与权．&lt;/li>
&lt;/ul>
&lt;p>后向引用用于重复搜索前面某个分组匹配的文本。例如，\1 代表分组 1 匹配的文本。难以理解？请看示例：&lt;/p>
&lt;p>\b(\w+)\b\s+\1\b 可以用来匹配重复的单词，像 go go, 或者 kitty kitty。这个表达式首先是一个单词，也就是单词开始处和结束处之间的多于一个的字母或数字(\b(\w+)\b)，这个单词会被捕获到编号为 1 的分组中，然后是 1 个或几个空白符(\s+)，最后是分组 1 中捕获的内容（也就是前面匹配的那个单词）(\1)。&lt;/p>
&lt;p>你也可以自己指定子表达式的组名。要指定一个子表达式的组名，请使用这样的语法：(?&lt;!-- raw HTML omitted -->\w+)(或者把尖括号换成&amp;rsquo;也行：(?&amp;lsquo;Word&amp;rsquo;\w+)),这样就把\w+的组名指定为 Word 了。要反向引用这个分组捕获的内容，你可以使用\k&lt;!-- raw HTML omitted -->,所以上一个例子也可以写成这样：\b(?&lt;!-- raw HTML omitted -->\w+)\b\s+\k&lt;!-- raw HTML omitted -->\b。&lt;/p>
&lt;p>使用小括号的时候，还有很多特定用途的语法。下面列出了最常用的一些：&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>&lt;/th>
&lt;th>&lt;/th>
&lt;th>&lt;/th>
&lt;th>&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>分类&lt;/td>
&lt;td>代码/语法&lt;/td>
&lt;td>说明&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>捕获&lt;/td>
&lt;td>(exp)&lt;/td>
&lt;td>匹配 exp,并捕获文本到自动命名的组里&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;td>(?&lt;!-- raw HTML omitted -->exp)&lt;/td>
&lt;td>匹配 exp,并捕获文本到名称为 name 的组里，也可以写成(?&amp;rsquo;name&amp;rsquo;exp)&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;td>(?:exp)&lt;/td>
&lt;td>匹配 exp,不捕获匹配的文本，也不给此分组分配组号&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>零宽断言&lt;/td>
&lt;td>(?=exp)&lt;/td>
&lt;td>匹配 exp 前面的位置&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;td>(?&amp;lt;=exp)&lt;/td>
&lt;td>匹配 exp 后面的位置&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;td>(?!exp)&lt;/td>
&lt;td>匹配后面跟的不是 exp 的位置&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;td>(?&amp;lt;!exp)&lt;/td>
&lt;td>匹配前面不是 exp 的位置&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>注释&lt;/td>
&lt;td>(?#comment)&lt;/td>
&lt;td>这种类型的分组不对正则表达式的处理产生任何影响，用于提供注释让人阅读&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>我们已经讨论了前两种语法。第三个(?:exp)不会改变正则表达式的处理方式，只是这样的组匹配的内容不会像前两种那样被捕获到某个组里面，也不会拥有组号。“我为什么会想要这样做？”——好问题，你觉得为什么呢？&lt;/p>
&lt;h2 id="零宽断言">零宽断言&lt;/h2>
&lt;p>地球人，是不是觉得这些术语名称太复杂，太难记了？我也有同感。知道有这么一种东西就行了，它叫什么，随它去吧！人若无名，便可专心练剑；物若无名，便可随意取舍……&lt;/p>
&lt;p>接下来的四个用于查找在某些内容(但并不包括这些内容)之前或之后的东西，也就是说它们像\b,^,$那样用于指定一个位置，这个位置应该满足一定的条件(即断言)，因此它们也被称为零宽断言。最好还是拿例子来说明吧：&lt;/p>
&lt;p>断言用来声明一个应该为真的事实。正则表达式中只有当断言为真时才会继续进行匹配。&lt;/p>
&lt;p>(?=exp)也叫零宽度正预测先行断言，它断言自身出现的位置的后面能匹配表达式 exp。比如\b\w+(?=ing\b)，匹配以 ing 结尾的单词的前面部分(除了 ing 以外的部分)，如查找 I&amp;rsquo;m singing while you&amp;rsquo;re dancing.时，它会匹配 sing 和 danc。&lt;/p>
&lt;p>(?&amp;lt;=exp)也叫零宽度正回顾后发断言，它断言自身出现的位置的前面能匹配表达式 exp。比如(?&amp;lt;=\bre)\w+\b 会匹配以 re 开头的单词的后半部分(除了 re 以外的部分)，例如在查找 reading a book 时，它匹配 ading。&lt;/p>
&lt;p>假如你想要给一个很长的数字中每三位间加一个逗号(当然是从右边加起了)，你可以这样查找需要在前面和里面添加逗号的部分：((?&amp;lt;=\d)\d{3})+\b，用它对 1234567890 进行查找时结果是 234567890。&lt;/p>
&lt;p>下面这个例子同时使用了这两种断言：(?&amp;lt;=\s)\d+(?=\s)匹配以空白符间隔的数字(再次强调，不包括这些空白符)。&lt;/p>
&lt;h2 id="负向零宽断言">负向零宽断言&lt;/h2>
&lt;p>前面我们提到过怎么查找&lt;strong>不是某个字符或不在某个字符类里&lt;/strong>的字符的方法(反义)。但是如果我们只是想要&lt;strong>确保某个字符没有出现，但并不想去匹配它&lt;/strong>时怎么办？例如，如果我们想查找这样的单词&amp;ndash;它里面出现了字母 q,但是 q 后面跟的不是字母 u,我们可以尝试这样：&lt;/p>
&lt;p>\b\w&lt;em>q[^u]\w&lt;/em>\b 匹配包含&lt;strong>后面不是字母 u 的字母 q&lt;/strong>的单词。但是如果多做测试(或者你思维足够敏锐，直接就观察出来了)，你会发现，如果 q 出现在单词的结尾的话，像&lt;strong>Iraq&lt;/strong>,&lt;strong>Benq&lt;/strong>，这个表达式就会出错。这是因为[^u]总要匹配一个字符，所以如果 q 是单词的最后一个字符的话，后面的[^u]将会匹配 q 后面的单词分隔符(可能是空格，或者是句号或其它的什么)，后面的\w*\b 将会匹配下一个单词，于是\b\w&lt;em>q[^u]\w&lt;/em>\b 就能匹配整个 Iraq fighting。负向零宽断言能解决这样的问题，因为它只匹配一个位置，并不&lt;strong>消费&lt;/strong>任何字符。现在，我们可以这样来解决这个问题：\b\w*q(?!u)\w*\b。&lt;/p>
&lt;p>零宽度负预测先行断言(?!exp)，断言此位置的后面不能匹配表达式 exp。例如：\d{3}(?!\d)匹配三位数字，而且这三位数字的后面不能是数字；\b((?!abc)\w)+\b 匹配不包含连续字符串 abc 的单词。&lt;/p>
&lt;p>同理，我们可以用(?&amp;lt;!exp),零宽度负回顾后发断言来断言此位置的前面不能匹配表达式 exp：(?&amp;lt;![a-z])\d{7}匹配前面不是小写字母的七位数字。&lt;/p>
&lt;p>请详细分析表达式(?&amp;lt;=&amp;lt;(\w+)).*(?=&amp;lt;/\1)，这个表达式最能表现零宽断言的真正用途。&lt;/p>
&lt;p>一个更复杂的例子：(?&amp;lt;=&amp;lt;(\w+)).&lt;em>(?=&amp;lt;/\1)匹配不包含属性的简单 HTML 标签内里的内容。(?&amp;lt;=&amp;lt;(\w+))指定了这样的前缀：被尖括号括起来的单词(比如可能是&amp;lt;b)，然后是.&lt;/em>(任意的字符串),最后是一个后缀(?=&amp;lt;/\1)。注意后缀里的/，它用到了前面提过的字符转义；\1 则是一个反向引用，引用的正是捕获的第一组，前面的(\w+)匹配的内容，这样如果前缀实际上是&lt;!-- raw HTML omitted -->的话，后缀就是&lt;!-- raw HTML omitted -->了。整个表达式匹配的是&lt;!-- raw HTML omitted -->和&lt;!-- raw HTML omitted -->之间的内容(再次提醒，不包括前缀和后缀本身)。&lt;/p>
&lt;h2 id="注释">注释&lt;/h2>
&lt;p>小括号的另一种用途是通过语法(?#comment)来包含注释。例如：2[0-4]\d(?#200-249)|25&lt;a href="?#250-255">0-5&lt;/a>|[01]?\d\d?(?#0-199)。&lt;/p>
&lt;p>要包含注释的话，最好是启用“忽略模式里的空白符”选项，这样在编写表达式时能任意的添加空格，Tab，换行，而实际使用时这些都将被忽略。启用这个选项后，在#后面到这一行结束的所有文本都将被当成注释忽略掉。例如，我们可以前面的一个表达式写成这样：&lt;/p>
&lt;pre>&lt;code>(?&amp;lt;= # 断言要匹配的文本的前缀
&amp;lt;(\w+)&amp;gt; # 查找尖括号括起来的字母或数字(即HTML/XML标签)
) # 前缀结束
.* # 匹配任意文本
(?= # 断言要匹配的文本的后缀
&amp;lt;\/\1&amp;gt; # 查找尖括号括起来的内容：前面是一个&amp;quot;/&amp;quot;，后面是先前捕获的标签
) # 后缀结束
golang 实现
&lt;/code>&lt;/pre>
&lt;p>1
2
3
4
5
6
7
8
9
10
Plain Text&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/tbnqr6/1616162510403-cd577bc1-0f1e-42ec-84a9-3bdce633d710.gif" alt="">&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/tbnqr6/1616162510621-adae5bae-c887-40db-b3f8-9583cec0d566.gif" alt="">&lt;/p>
&lt;pre>&lt;code>1 package lib
2
3 import (
4 &amp;quot;regexp&amp;quot;
5 )
6
7 func IsEmail(email string) bool {
8 if email != &amp;quot;&amp;quot; {
9 if isOk, _ := regexp.MatchString(&amp;quot;^[_a-z0-9-]+(\\.[_a-z0-9-]+)*@[a-z0-9-]+(\\.[a-z0-9-]+)*(\\.[a-z]{2,4})$&amp;quot;, email); isOk {
10 return true
11 }
12 }
13
14 return false
15 }
16
17 func IsPhone(phoneStr string) bool {
18 if phoneStr != &amp;quot;&amp;quot; {
19 if isOk, _ := regexp.MatchString(`^\([\d]{3}\) [\d]{3}-[\d]{4}$`, phoneStr); isOk {
20 return isOk
21 }
22 }
23
24 return false
25 }
&lt;/code>&lt;/pre>
&lt;p>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
Plain Text&lt;/p>
&lt;pre>&lt;code>1 数字：^[0-9]*$
2 n位的数字：^\d{n}$
3 至少n位的数字：^\d{n,}$
4 m-n位的数字：^\d{m,n}$
5 零和非零开头的数字：^(0|[1-9][0-9]*)$
6 非零开头的最多带两位小数的数字：^([1-9][0-9]*)+(.[0-9]{1,2})?$
7 带1-2位小数的正数或负数：^(\-)?\d+(\.\d{1,2})?$
8 正数、负数、和小数：^(\-|\+)?\d+(\.\d+)?$
9 有两位小数的正实数：^[0-9]+(.[0-9]{2})?$
10 有1~3位小数的正实数：^[0-9]+(.[0-9]{1,3})?$
11 非零的正整数：^[1-9]\d*$ 或 ^([1-9][0-9]*){1,3}$ 或 ^\+?[1-9][0-9]*$
12 非零的负整数：^\-[1-9][]0-9&amp;quot;*$ 或 ^-[1-9]\d*$
13 非负整数：^\d+$ 或 ^[1-9]\d*|0$
14 非正整数：^-[1-9]\d*|0$ 或 ^((-\d+)|(0+))$
15 非负浮点数：^\d+(\.\d+)?$ 或 ^[1-9]\d*\.\d*|0\.\d*[1-9]\d*|0?\.0+|0$
16 非正浮点数：^((-\d+(\.\d+)?)|(0+(\.0+)?))$ 或 ^(-([1-9]\d*\.\d*|0\.\d*[1-9]\d*))|0?\.0+|0$
17 正浮点数：^[1-9]\d*\.\d*|0\.\d*[1-9]\d*$ 或 ^(([0-9]+\.[0-9]*[1-9][0-9]*)|([0-9]*[1-9][0-9]*\.[0-9]+)|([0-9]*[1-9][0-9]*))$
18 负浮点数：^-([1-9]\d*\.\d*|0\.\d*[1-9]\d*)$ 或 ^(-(([0-9]+\.[0-9]*[1-9][0-9]*)|([0-9]*[1-9][0-9]*\.[0-9]+)|([0-9]*[1-9][0-9]*)))$
19 浮点数：^(-?\d+)(\.\d+)?$ 或 ^-?([1-9]\d*\.\d*|0\.\d*[1-9]\d*|0?\.0+|0)$
二、校验字符的表达式
1 汉字：^[\u4e00-\u9fa5]{0,}$
2 英文和数字：^[A-Za-z0-9]+$ 或 ^[A-Za-z0-9]{4,40}$
3 长度为3-20的所有字符：^.{3,20}$
4 由26个英文字母组成的字符串：^[A-Za-z]+$
5 由26个大写英文字母组成的字符串：^[A-Z]+$
6 由26个小写英文字母组成的字符串：^[a-z]+$
7 由数字和26个英文字母组成的字符串：^[A-Za-z0-9]+$
8 由数字、26个英文字母或者下划线组成的字符串：^\w+$ 或 ^\w{3,20}$
9 中文、英文、数字包括下划线：^[\u4E00-\u9FA5A-Za-z0-9_]+$
10 中文、英文、数字但不包括下划线等符号：^[\u4E00-\u9FA5A-Za-z0-9]+$ 或 ^[\u4E00-\u9FA5A-Za-z0-9]{2,20}$
11 可以输入含有^%&amp;amp;',;=?$\&amp;quot;等字符：[^%&amp;amp;',;=?$\x22]+ 12 禁止输入含有~的字符：[^~\x22]+
三、特殊需求表达式
1 Email地址：^\w+([-+.]\w+)*@\w+([-.]\w+)*\.\w+([-.]\w+)*$
2 域名：[a-zA-Z0-9][-a-zA-Z0-9]{0,62}(/.[a-zA-Z0-9][-a-zA-Z0-9]{0,62})+/.?
3 InternetURL：[a-zA-z]+://[^\s]* 或 ^http://([\w-]+\.)+[\w-]+(/[\w-./?%&amp;amp;=]*)?$
4 手机号码：^(13[0-9]|14[5|7]|15[0|1|2|3|5|6|7|8|9]|18[0|1|2|3|5|6|7|8|9])\d{8}$
5 电话号码(&amp;quot;XXX-XXXXXXX&amp;quot;、&amp;quot;XXXX-XXXXXXXX&amp;quot;、&amp;quot;XXX-XXXXXXX&amp;quot;、&amp;quot;XXX-XXXXXXXX&amp;quot;、&amp;quot;XXXXXXX&amp;quot;和&amp;quot;XXXXXXXX)：^(\(\d{3,4}-)|\d{3.4}-)?\d{7,8}$
6 国内电话号码(0511-4405222、021-87888822)：\d{3}-\d{8}|\d{4}-\d{7}
7 身份证号(15位、18位数字)：^\d{15}|\d{18}$
8 短身份证号码(数字、字母x结尾)：^([0-9]){7,18}(x|X)?$ 或 ^\d{8,18}|[0-9x]{8,18}|[0-9X]{8,18}?$
9 帐号是否合法(字母开头，允许5-16字节，允许字母数字下划线)：^[a-zA-Z][a-zA-Z0-9_]{4,15}$
10 密码(以字母开头，长度在6~18之间，只能包含字母、数字和下划线)：^[a-zA-Z]\w{5,17}$
11 强密码(必须包含大小写字母和数字的组合，不能使用特殊字符，长度在8-10之间)：^(?=.*\d)(?=.*[a-z])(?=.*[A-Z]).{8,10}$
12 日期格式：^\d{4}-\d{1,2}-\d{1,2}
13 一年的12个月(01～09和1～12)：^(0?[1-9]|1[0-2])$
14 一个月的31天(01～09和1～31)：^((0?[1-9])|((1|2)[0-9])|30|31)$
15 钱的输入格式：
16 1.有四种钱的表示形式我们可以接受:&amp;quot;10000.00&amp;quot; 和 &amp;quot;10,000.00&amp;quot;, 和没有 &amp;quot;分&amp;quot; 的 &amp;quot;10000&amp;quot; 和 &amp;quot;10,000&amp;quot;：^[1-9][0-9]*$
17 2.这表示任意一个不以0开头的数字,但是,这也意味着一个字符&amp;quot;0&amp;quot;不通过,所以我们采用下面的形式：^(0|[1-9][0-9]*)$
18 3.一个0或者一个不以0开头的数字.我们还可以允许开头有一个负号：^(0|-?[1-9][0-9]*)$
19 4.这表示一个0或者一个可能为负的开头不为0的数字.让用户以0开头好了.把负号的也去掉,因为钱总不能是负的吧.下面我们要加的是说明可能的小数部分：^[0-9]+(.[0-9]+)?$
20 5.必须说明的是,小数点后面至少应该有1位数,所以&amp;quot;10.&amp;quot;是不通过的,但是 &amp;quot;10&amp;quot; 和 &amp;quot;10.2&amp;quot; 是通过的：^[0-9]+(.[0-9]{2})?$
21 6.这样我们规定小数点后面必须有两位,如果你认为太苛刻了,可以这样：^[0-9]+(.[0-9]{1,2})?$
22 7.这样就允许用户只写一位小数.下面我们该考虑数字中的逗号了,我们可以这样：^[0-9]{1,3}(,[0-9]{3})*(.[0-9]{1,2})?$
23 8.1到3个数字,后面跟着任意个 逗号+3个数字,逗号成为可选,而不是必须：^([0-9]+|[0-9]{1,3}(,[0-9]{3})*)(.[0-9]{1,2})?$
24 备注：这就是最终结果了,别忘了&amp;quot;+&amp;quot;可以用&amp;quot;*&amp;quot;替代如果你觉得空字符串也可以接受的话(奇怪,为什么?)最后,别忘了在用函数时去掉去掉那个反斜杠,一般的错误都在这里
25 xml文件：^([a-zA-Z]+-?)+[a-zA-Z0-9]+\\.[x|X][m|M][l|L]$
26 中文字符的正则表达式：[\u4e00-\u9fa5]
27 双字节字符：[^\x00-\xff] (包括汉字在内，可以用来计算字符串的长度(一个双字节字符长度计2，ASCII字符计1))
28 空白行的正则表达式：\n\s*\r (可以用来删除空白行)
29 HTML标记的正则表达式：&amp;lt;(\S*?)[^&amp;gt;]*&amp;gt;.*?|&amp;lt;.*? /&amp;gt; (网上流传的版本太糟糕，上面这个也仅仅能部分，对于复杂的嵌套标记依旧无能为力)
30 首尾空白字符的正则表达式：^\s*|\s*$或(^\s*)|(\s*$) (可以用来删除行首行尾的空白字符(包括空格、制表符、换页符等等)，非常有用的表达式)
31 腾讯QQ号：[1-9][0-9]{4,} (腾讯QQ号从10000开始)
32 中国邮政编码：[1-9]\d{5}(?!\d) (中国邮政编码为6位数字)
33 IP地址：\d+\.\d+\.\d+\.\d+ (提取IP地址时有用)
34 IP地址：((?:(?:25[0-5]|2[0-4]\\d|[01]?\\d?\\d)\\.){3}(?:25[0-5]|2[0-4]\\d|[01]?\\d?\\d))
package main
import (
&amp;quot;regexp&amp;quot;
)
const (
regular = &amp;quot;^(13[0-9]|14[57]|15[0-35-9]|18[07-9])\\\\d{8}$&amp;quot;
)
func validate(mobileNum string) bool {
reg := regexp.MustCompile(regular)
return reg.MatchString(mobileNum)
}
func main() {
if validate(&amp;quot;13888888888&amp;quot;) {
println(&amp;quot;是手机号&amp;quot;)
return
}
println(&amp;quot;不是手机号&amp;quot;)
}
//该片段来自
&lt;/code>&lt;/pre>
&lt;p>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
88
89
90
91
92
93
94
95
96
97
98
99
100
101
102
Plain Text&lt;/p>
&lt;pre>&lt;code>------------------------------------------------------------
Golang中的正则表达式
------------------------------------------------------------
用法：
------------------------------
单一：
. 匹配任意一个字符，如果设置 s = true，则可以匹配换行符
[字符类] 匹配“字符类”中的一个字符，“字符类”见后面的说明
[^字符类] 匹配“字符类”外的一个字符，“字符类”见后面的说明
\小写Perl标记 匹配“Perl类”中的一个字符，“Perl类”见后面的说明
\大写Perl标记 匹配“Perl类”外的一个字符，“Perl类”见后面的说明
[:ASCII类名:] 匹配“ASCII类”中的一个字符，“ASCII类”见后面的说明
[:^ASCII类名:] 匹配“ASCII类”外的一个字符，“ASCII类”见后面的说明
\pUnicode普通类名 匹配“Unicode类”中的一个字符(仅普通类)，“Unicode类”见后面的说明
\PUnicode普通类名 匹配“Unicode类”外的一个字符(仅普通类)，“Unicode类”见后面的说明
\p{Unicode类名} 匹配“Unicode类”中的一个字符，“Unicode类”见后面的说明
\P{Unicode类名} 匹配“Unicode类”外的一个字符，“Unicode类”见后面的说明
------------------------------
复合：
xy 匹配 xy（x 后面跟随 y）
x|y 匹配 x 或 y (优先匹配 x)
------------------------------
重复：
x* 匹配零个或多个 x，优先匹配更多(贪婪)
x+ 匹配一个或多个 x，优先匹配更多(贪婪)
x? 匹配零个或一个 x，优先匹配一个(贪婪)
x{n,m} 匹配 n 到 m 个 x，优先匹配更多(贪婪)
x{n,} 匹配 n 个或多个 x，优先匹配更多(贪婪)
x{n} 只匹配 n 个 x
x*? 匹配零个或多个 x，优先匹配更少(非贪婪)
x+? 匹配一个或多个 x，优先匹配更少(非贪婪)
x?? 匹配零个或一个 x，优先匹配零个(非贪婪)
x{n,m}? 匹配 n 到 m 个 x，优先匹配更少(非贪婪)
x{n,}? 匹配 n 个或多个 x，优先匹配更少(非贪婪)
x{n}? 只匹配 n 个 x
------------------------------
分组：
(子表达式) 被捕获的组，该组被编号 (子匹配)
(?P&amp;lt;命名&amp;gt;子表达式) 被捕获的组，该组被编号且被命名 (子匹配)
(?:子表达式) 非捕获的组 (子匹配)
(?标记) 在组内设置标记，非捕获，标记影响当前组后的正则表达式
(?标记:子表达式) 在组内设置标记，非捕获，标记影响当前组内的子表达式
标记的语法是：
xyz (设置 xyz 标记)
-xyz (清除 xyz 标记)
xy-z (设置 xy 标记, 清除 z 标记)
可以设置的标记有：
i 不区分大小写 (默认为 false)
m 多行模式：让 ^ 和 $ 匹配整个文本的开头和结尾，而非行首和行尾(默认为 false)
s 让 . 匹配 \n (默认为 false)
U 非贪婪模式：交换 x* 和 x*? 等的含义 (默认为 false)
------------------------------
位置标记：
^ 如果标记 m=true 则匹配行首，否则匹配整个文本的开头（m 默认为 false）
$ 如果标记 m=true 则匹配行尾，否则匹配整个文本的结尾（m 默认为 false）
\A 匹配整个文本的开头，忽略 m 标记
\b 匹配单词边界
\B 匹配非单词边界
\z 匹配整个文本的结尾，忽略 m 标记
------------------------------
转义序列：
\a 匹配响铃符 （相当于 \x07）
注意：正则表达式中不能使用 \b 匹配退格符，因为 \b 被用来匹配单词边界，
可以使用 \x08 表示退格符。
\f 匹配换页符 （相当于 \x0C）
\t 匹配横向制表符（相当于 \x09）
\n 匹配换行符 （相当于 \x0A）
\r 匹配回车符 （相当于 \x0D）
\v 匹配纵向制表符（相当于 \x0B）
\123 匹配 8 進制编码所代表的字符（必须是 3 位数字）
\x7F 匹配 16 進制编码所代表的字符（必须是 3 位数字）
\x{10FFFF} 匹配 16 進制编码所代表的字符（最大值 10FFFF ）
\Q...\E 匹配 \Q 和 \E 之间的文本，忽略文本中的正则语法
\\ 匹配字符 \
\^ 匹配字符 ^
\$ 匹配字符 $
\. 匹配字符 .
* 匹配字符 *
\+ 匹配字符 +
\? 匹配字符 ?
\{ 匹配字符 {
\} 匹配字符 }
\( 匹配字符 (
\) 匹配字符 )
\[ 匹配字符 [
\] 匹配字符 ]
\| 匹配字符 |
------------------------------
可以将“命名字符类”作为“字符类”的元素：
[\d] 匹配数字 (相当于 \d)
[^\d] 匹配非数字 (相当于 \D)
[\D] 匹配非数字 (相当于 \D)
[^\D] 匹配数字 (相当于 \d)
[[:name:]] 命名的“ASCII 类”包含在“字符类”中 (相当于 [:name:])
[^[:name:]] 命名的“ASCII 类”不包含在“字符类”中 (相当于 [:^name:])
[\p{Name}] 命名的“Unicode 类”包含在“字符类”中 (相当于 \p{Name})
[^\p{Name}] 命名的“Unicode 类”不包含在“字符类”中 (相当于 \P{Name})
------------------------------------------------------------
说明：
------------------------------
“字符类”取值如下（“字符类”包含“Perl类”、“ASCII类”、“Unicode类”）：
x 单个字符
A-Z 字符范围(包含首尾字符)
\小写字母 Perl类
[:ASCII类名:] ASCII类
\p{Unicode脚本类名} Unicode类 (脚本类)
\pUnicode普通类名 Unicode类 (普通类)
------------------------------
“Perl 类”取值如下：
\d 数字 (相当于 [0-9])
\D 非数字 (相当于 [^0-9])
\s 空白 (相当于 [\t\n\f\r ])
\S 非空白 (相当于[^\t\n\f\r ])
\w 单词字符 (相当于 [0-9A-Za-z_])
\W 非单词字符 (相当于 [^0-9A-Za-z_])
------------------------------
“ASCII 类”取值如下
[:alnum:] 字母数字 (相当于 [0-9A-Za-z])
[:alpha:] 字母 (相当于 [A-Za-z])
[:ascii:] ASCII 字符集 (相当于 [\x00-\x7F])
[:blank:] 空白占位符 (相当于 [\t ])
[:cntrl:] 控制字符 (相当于 [\x00-\x1F\x7F])
[:digit:] 数字 (相当于 [0-9])
[:graph:] 图形字符 (相当于 [!-~])
[:lower:] 小写字母 (相当于 [a-z])
[:print:] 可打印字符 (相当于 [ -~] 相当于 [ [:graph:]])
[:punct:] 标点符号 (相当于 [!-/:-@[-反引号{-~])
[:space:] 空白字符(相当于 [\t\n\v\f\r ])
[:upper:] 大写字母(相当于 [A-Z])
[:word:] 单词字符(相当于 [0-9A-Za-z_])
[:xdigit:] 16 進制字符集(相当于 [0-9A-Fa-f])
------------------------------
“Unicode 类”取值如下---普通类：
C -其他- (other)
Cc 控制字符 (control)
Cf 格式 (format)
Co 私人使用区 (private use)
Cs 代理区 (surrogate)
L -字母- (letter)
Ll 小写字母 (lowercase letter)
Lm 修饰字母 (modifier letter)
Lo 其它字母 (other letter)
Lt 首字母大写字母 (titlecase letter)
Lu 大写字母 (uppercase letter)
M -标记- (mark)
Mc 间距标记 (spacing mark)
Me 关闭标记 (enclosing mark)
Mn 非间距标记 (non-spacing mark)
N -数字- (number)
Nd 十進制数字 (decimal number)
Nl 字母数字 (letter number)
No 其它数字 (other number)
P -标点- (punctuation)
Pc 连接符标点 (connector punctuation)
Pd 破折号标点符号 (dash punctuation)
Pe 关闭的标点符号 (close punctuation)
Pf 最后的标点符号 (final punctuation)
Pi 最初的标点符号 (initial punctuation)
Po 其他标点符号 (other punctuation)
Ps 开放的标点符号 (open punctuation)
S -符号- (symbol)
Sc 货币符号 (currency symbol)
Sk 修饰符号 (modifier symbol)
Sm 数学符号 (math symbol)
So 其他符号 (other symbol)
Z -分隔符- (separator)
Zl 行分隔符 (line separator)
Zp 段落分隔符 (paragraph separator)
Zs 空白分隔符 (space separator)
------------------------------
“Unicode 类”取值如下---脚本类：
Arabic 阿拉伯文
Armenian 亚美尼亚文
Balinese 巴厘岛文
Bengali 孟加拉文
Bopomofo 汉语拼音字母
Braille 盲文
Buginese 布吉文
Buhid 布希德文
Canadian_Aboriginal 加拿大土著文
Carian 卡里亚文
Cham 占族文
Cherokee 切诺基文
Common 普通的，字符不是特定于一个脚本
Coptic 科普特文
Cuneiform 楔形文字
Cypriot 塞浦路斯文
Cyrillic 斯拉夫文
Deseret 犹他州文
Devanagari 梵文
Ethiopic 衣索比亚文
Georgian 格鲁吉亚文
Glagolitic 格拉哥里文
Gothic 哥特文
Greek 希腊
Gujarati 古吉拉特文
Gurmukhi 果鲁穆奇文
Han 汉文
Hangul 韩文
Hanunoo 哈鲁喏文
Hebrew 希伯来文
Hiragana 平假名（日语）
Inherited 继承前一个字符的脚本
Kannada 坎那达文
Katakana 片假名（日语）
Kayah_Li 克耶字母
Kharoshthi 卡罗须提文
Khmer 高棉文
Lao 老挝文
Latin 拉丁文
Lepcha 雷布查文
Limbu 林布文
Linear_B B类线形文字（古希腊）
Lycian 利西亚文
Lydian 吕底亚文
Malayalam 马拉雅拉姆文
Mongolian 蒙古文
Myanmar 缅甸文
New_Tai_Lue 新傣仂文
Nko Nko文
Ogham 欧甘文
Ol_Chiki 桑塔利文
Old_Italic 古意大利文
Old_Persian 古波斯文
Oriya 奥里亚文
Osmanya 奥斯曼亚文
Phags_Pa 八思巴文
Phoenician 腓尼基文
Rejang 拉让文
Runic 古代北欧文字
Saurashtra 索拉什特拉文（印度县城）
Shavian 萧伯纳文
Sinhala 僧伽罗文
Sundanese 巽他文
Syloti_Nagri 锡尔赫特文
Syriac 叙利亚文
Tagalog 塔加拉文
Tagbanwa 塔格巴努亚文
Tai_Le 德宏傣文
Tamil 泰米尔文
Telugu 泰卢固文
Thaana 塔安那文
Thai 泰文
Tibetan 藏文
Tifinagh 提非纳文
Ugaritic 乌加里特文
Vai 瓦伊文
Yi 彝文
------------------------------------------------------------
注意：
　　对于 [a-z] 这样的正则表达式，如果要在 [] 中匹配 - ，可以将 - 放在 [] 的开头或结尾，例如 [-a-z] 或 [a-z-]
　　可以在 [] 中使用转义字符：\f、\t、\n、\r、\v、\377、\xFF、\x{10FFFF}、\\、\^、\$、\.、*、\+、\?、\{、\}、\(、\)、\[、\]、\|（具体含义见上面的说明）
　　如果在正则表达式中使用了分组，则在执行正则替换的时候，“替换内容”中可以使用 $1、${1}、$name、${name} 这样的“分组引用符”获取相应的分组内容。其中 $0 代表整个匹配项，$1 代表第 1 个分组，$2 代表第 2 个分组，……。
　　如果“分组引用符”是 $name 的形式，则在解析的时候，name 是取尽可能长的字符串，比如：$1x 相当于 ${1x}，而不是${1}x，再比如：$10 相当于 ${10}，而不是 ${1}0。
　　由于 $ 字符会被转义，所以要在“替换内容”中使用 $ 字符，可以用 \$ 代替。
　　上面介绍的正则表达式语法是“Perl 语法”，除了“Perl 语法”外，Go 语言中还有另一种“POSIX 语法”，“POSIX 语法”除了不能使用“Perl 类”之外，其它都一样。
------------------------------------------------------------
// 示例
func main() {
text := `Hello 世界！123 Go.`
// 查找连续的小写字母
reg := regexp.MustCompile(`[a-z]+`)
fmt.Printf(&amp;quot;%q\n&amp;quot;, reg.FindAllString(text, -1))
// [&amp;quot;ello&amp;quot; &amp;quot;o&amp;quot;]
// 查找连续的非小写字母
reg = regexp.MustCompile(`[^a-z]+`)
fmt.Printf(&amp;quot;%q\n&amp;quot;, reg.FindAllString(text, -1))
// [&amp;quot;H&amp;quot; &amp;quot; 世界！123 G&amp;quot; &amp;quot;.&amp;quot;]
// 查找连续的单词字母
reg = regexp.MustCompile(`[\w]+`)
fmt.Printf(&amp;quot;%q\n&amp;quot;, reg.FindAllString(text, -1))
// [&amp;quot;Hello&amp;quot; &amp;quot;123&amp;quot; &amp;quot;Go&amp;quot;]
// 查找连续的非单词字母、非空白字符
reg = regexp.MustCompile(`[^\w\s]+`)
fmt.Printf(&amp;quot;%q\n&amp;quot;, reg.FindAllString(text, -1))
// [&amp;quot;世界！&amp;quot; &amp;quot;.&amp;quot;]
// 查找连续的大写字母
reg = regexp.MustCompile(`[[:upper:]]+`)
fmt.Printf(&amp;quot;%q\n&amp;quot;, reg.FindAllString(text, -1))
// [&amp;quot;H&amp;quot; &amp;quot;G&amp;quot;]
// 查找连续的非 ASCII 字符
reg = regexp.MustCompile(`[[:^ascii:]]+`)
fmt.Printf(&amp;quot;%q\n&amp;quot;, reg.FindAllString(text, -1))
// [&amp;quot;世界！&amp;quot;]
// 查找连续的标点符号
reg = regexp.MustCompile(`[\pP]+`)
fmt.Printf(&amp;quot;%q\n&amp;quot;, reg.FindAllString(text, -1))
// [&amp;quot;！&amp;quot; &amp;quot;.&amp;quot;]
// 查找连续的非标点符号字符
reg = regexp.MustCompile(`[\PP]+`)
fmt.Printf(&amp;quot;%q\n&amp;quot;, reg.FindAllString(text, -1))
// [&amp;quot;Hello 世界&amp;quot; &amp;quot;123 Go&amp;quot;]
// 查找连续的汉字
reg = regexp.MustCompile(`[\p{Han}]+`)
fmt.Printf(&amp;quot;%q\n&amp;quot;, reg.FindAllString(text, -1))
// [&amp;quot;世界&amp;quot;]
// 查找连续的非汉字字符
reg = regexp.MustCompile(`[\P{Han}]+`)
fmt.Printf(&amp;quot;%q\n&amp;quot;, reg.FindAllString(text, -1))
// [&amp;quot;Hello &amp;quot; &amp;quot;！123 Go.&amp;quot;]
// 查找 Hello 或 Go
reg = regexp.MustCompile(`Hello|Go`)
fmt.Printf(&amp;quot;%q\n&amp;quot;, reg.FindAllString(text, -1))
// [&amp;quot;Hello&amp;quot; &amp;quot;Go&amp;quot;]
// 查找行首以 H 开头，以空格结尾的字符串
reg = regexp.MustCompile(`^H.*\s`)
fmt.Printf(&amp;quot;%q\n&amp;quot;, reg.FindAllString(text, -1))
// [&amp;quot;Hello 世界！123 &amp;quot;]
// 查找行首以 H 开头，以空白结尾的字符串（非贪婪模式）
reg = regexp.MustCompile(`(?U)^H.*\s`)
fmt.Printf(&amp;quot;%q\n&amp;quot;, reg.FindAllString(text, -1))
// [&amp;quot;Hello &amp;quot;]
// 查找以 hello 开头（忽略大小写），以 Go 结尾的字符串
reg = regexp.MustCompile(`(?i:^hello).*Go`)
fmt.Printf(&amp;quot;%q\n&amp;quot;, reg.FindAllString(text, -1))
// [&amp;quot;Hello 世界！123 Go&amp;quot;]
// 查找 Go.
reg = regexp.MustCompile(`\QGo.\E`)
fmt.Printf(&amp;quot;%q\n&amp;quot;, reg.FindAllString(text, -1))
// [&amp;quot;Go.&amp;quot;]
// 查找从行首开始，以空格结尾的字符串（非贪婪模式）
reg = regexp.MustCompile(`(?U)^.* `)
fmt.Printf(&amp;quot;%q\n&amp;quot;, reg.FindAllString(text, -1))
// [&amp;quot;Hello &amp;quot;]
// 查找以空格开头，到行尾结束，中间不包含空格字符串
reg = regexp.MustCompile(` [^ ]*$`)
fmt.Printf(&amp;quot;%q\n&amp;quot;, reg.FindAllString(text, -1))
// [&amp;quot; Go.&amp;quot;]
// 查找“单词边界”之间的字符串
reg = regexp.MustCompile(`(?U)\b.+\b`)
fmt.Printf(&amp;quot;%q\n&amp;quot;, reg.FindAllString(text, -1))
// [&amp;quot;Hello&amp;quot; &amp;quot; 世界！&amp;quot; &amp;quot;123&amp;quot; &amp;quot; &amp;quot; &amp;quot;Go&amp;quot;]
// 查找连续 1 次到 4 次的非空格字符，并以 o 结尾的字符串
reg = regexp.MustCompile(`[^ ]{1,4}o`)
fmt.Printf(&amp;quot;%q\n&amp;quot;, reg.FindAllString(text, -1))
// [&amp;quot;Hello&amp;quot; &amp;quot;Go&amp;quot;]
// 查找 Hello 或 Go
reg = regexp.MustCompile(`(?:Hell|G)o`)
fmt.Printf(&amp;quot;%q\n&amp;quot;, reg.FindAllString(text, -1))
// [&amp;quot;Hello&amp;quot; &amp;quot;Go&amp;quot;]
// 查找 Hello 或 Go，替换为 Hellooo、Gooo
reg = regexp.MustCompile(`(?PHell|G)o`)
fmt.Printf(&amp;quot;%q\n&amp;quot;, reg.ReplaceAllString(text, &amp;quot;${n}ooo&amp;quot;))
// &amp;quot;Hellooo 世界！123 Gooo.&amp;quot;
// 交换 Hello 和 Go
reg = regexp.MustCompile(`(Hello)(.*)(Go)`)
fmt.Printf(&amp;quot;%q\n&amp;quot;, reg.ReplaceAllString(text, &amp;quot;$3$2$1&amp;quot;))
// &amp;quot;Go 世界！123 Hello.&amp;quot;
// 特殊字符的查找
reg = regexp.MustCompile(`[\f\t\n\r\v\123\x7F\x{10FFFF}\\\^\$\.*\+\?\{\}\(\)\[\]\|]`)
fmt.Printf(&amp;quot;%q\n&amp;quot;, reg.ReplaceAllString(&amp;quot;\f\t\n\r\v\123\x7F\U0010FFFF\\^$.*+?{}()[]|&amp;quot;, &amp;quot;-&amp;quot;))
// &amp;quot;----------------------&amp;quot;
}
&lt;/code>&lt;/pre></description></item></channel></rss>