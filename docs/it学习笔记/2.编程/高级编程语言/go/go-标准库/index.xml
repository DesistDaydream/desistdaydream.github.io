<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>断念梦 – Go 标准库</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/2.%E7%BC%96%E7%A8%8B/%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/go/go-%E6%A0%87%E5%87%86%E5%BA%93/</link><description>Recent content in Go 标准库 on 断念梦</description><generator>Hugo -- gohugo.io</generator><atom:link href="https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/2.%E7%BC%96%E7%A8%8B/%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/go/go-%E6%A0%87%E5%87%86%E5%BA%93/index.xml" rel="self" type="application/rss+xml"/><item><title>Docs: Arrays(数组) 与 Slices(切片)</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/2.%E7%BC%96%E7%A8%8B/%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/go/go-%E6%A0%87%E5%87%86%E5%BA%93/arrays%E6%95%B0%E7%BB%84-%E4%B8%8E-slices%E5%88%87%E7%89%87/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/2.%E7%BC%96%E7%A8%8B/%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/go/go-%E6%A0%87%E5%87%86%E5%BA%93/arrays%E6%95%B0%E7%BB%84-%E4%B8%8E-slices%E5%88%87%E7%89%87/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;h1 id="array数组">Array(数组)&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://go.dev/tour/moretypes/6">Go 语言之旅，Arrays&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>&lt;strong>Array(数组)&lt;/strong> 是具有相同的唯一类型的一组 &lt;strong>已编号&lt;/strong>、且&lt;strong>长度固定&lt;/strong> 的数据项序列。每个数据项称为 &lt;strong>element(元素)&lt;/strong>、长度指的是&lt;strong>元素的个数&lt;/strong>、编号指每个元素的 **index(索引)，**索引号从 0 开始。&lt;/p>
&lt;p>&lt;code>[n]T&lt;/code> 用以表示一个数组，该数组包含 n 个 T 类型的值。&lt;/p>
&lt;h2 id="array-的声明">Array 的声明&lt;/h2>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">var&lt;/span> &lt;span style="color:#a6e22e">ArrayID&lt;/span> [&lt;span style="color:#a6e22e">LENGTH&lt;/span>]&lt;span style="color:#a6e22e">TYPE&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ul>
&lt;li>&lt;strong>ArrayID&lt;/strong> # 标识符(i.e.数组的名字)&lt;/li>
&lt;li>&lt;strong>LENGTH&lt;/strong> # 数组长度(i.e.元素的个数)&lt;/li>
&lt;li>&lt;strong>TYPE&lt;/strong> # 每个元素的数据的类型。&lt;/li>
&lt;li>&lt;code>**[ ]**&lt;/code> # 括号是数组类型的标识符，不要忘记写。&lt;/li>
&lt;/ul>
&lt;p>比如：&lt;code>var arr [10]int&lt;/code>这定义了一个名为 arr 的数组，这个数组由 10 个 int 类型的数据组成。简化点的口头语，声明了一个长度为 10 的整形数组。&lt;/p>
&lt;h2 id="array-的赋值">Array 的赋值&lt;/h2>
&lt;p>&lt;code>arr[0] = &amp;quot;Hello&amp;quot;&lt;/code> 为数组的 0 号元素赋值。&lt;/p>
&lt;h2 id="array-的实例化">Array 的实例化&lt;/h2>
&lt;p>数组声明后，默认初始化每个元素的值为 0，后续可以对每个元素进行赋值。数组可以有两种初始化方式&lt;/p>
&lt;ul>
&lt;li>每次对一个元素进行赋值，一般使用循环来实现&lt;/li>
&lt;li>使用&lt;code>{}&lt;/code>大括号，直接对数组进行初始化
&lt;ul>
&lt;li>e.g.&lt;code>var arr = [5]int{1,5,23,2,10}&lt;/code>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h2 id="array-的引用">Array 的引用&lt;/h2>
&lt;h3 id="引用数组的长度">引用数组的长度&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>len(&lt;span style="color:#a6e22e">MapID&lt;/span>)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>使用 &lt;code>len()&lt;/code> 函数，括号内为数组标识符。数组的长度也就是元素的数目，必须是固定的并且在声明该数组时就给出，数组长度最大为 2Gb。格式为 &lt;code>len(ARRAYS)&lt;/code> len 是 length 的缩写，ARRAYS 是数组变量的名称。&lt;/p>
&lt;ul>
&lt;li>e.g.对于上面例子中定义的数组，数组的长度为&lt;code>len(arr)&lt;/code>&lt;/li>
&lt;/ul>
&lt;h3 id="引用数组中的元素">引用数组中的元素&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">ArrayID&lt;/span>[&lt;span style="color:#a6e22e">INDEX&lt;/span>]
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ul>
&lt;li>&lt;strong>ArrayID&lt;/strong> # 数组标识符&lt;/li>
&lt;li>&lt;strong>INDEX&lt;/strong> # 元素编号&lt;/li>
&lt;/ul>
&lt;p>数组的元素可以通过&lt;strong>索引&lt;/strong>(数组的位置，索引有时候也叫作数组中元素的&lt;strong>编号&lt;/strong>)来读取(或修改)，索引从 0 开始，第一个元素的索引为 0，第二个索引为 1，以此类推(长度为 3 的数组，元素的索引为 0、1、2)。&lt;/p>
&lt;ul>
&lt;li>e.g.对于上面例子中定义的数组，第一个元素是&lt;code>arr[0]&lt;/code>,第二个元素是&lt;code>arr[1]&lt;/code>&amp;hellip;..第五个元素是&lt;code>arr[4]&lt;/code>&lt;/li>
&lt;/ul>
&lt;h2 id="多维数组">多维数组&lt;/h2>
&lt;p>数组通常是一维的，但是可以用来组装成多维数组。e.g.&lt;code>[3][5]int&lt;/code>有行有列,&lt;code>[2][2][2]float64&lt;/code>立体效果。代码示例：multidim_array.go&lt;/p>
&lt;h1 id="slice切片">Slice(切片)&lt;/h1>
&lt;p>&lt;strong>Slice(切片)&lt;/strong> 是一个&lt;strong>长度可变的数组&lt;/strong>，是&lt;strong>数组的一部分&lt;/strong>；是对数组一个连续片段的&lt;strong>引用&lt;/strong>。这个片段可以是整个数组、或是由起始和终止索引标识中间的元素子集，注意：终止索引标识符的元素不包括在切片内。&lt;/p>
&lt;p>切片的由来：Go 中的数组是一个值，数组变量表示整个数组，而不是指向数组第一个元素的指针。这就意味，将一个数组当作参数传递时，会完全拷贝数组中的内容(当数组非常大的时候，会非常占用资源，使用起来也不便利)，这时候就可以是使用切片来作为参数进行传递。**可以把数组当成一个存储元素的地方，具有索引，有着固定的大小。而切片则是指向这个存储元素地方的指针。**所以 Golang 中一般使用切片来对数组进行引用和传递参数。&lt;/p>
&lt;p>注意：绝对不要用指针指向切片。切片本身已经是一个引用类型，所以它本身就是一个指针！&lt;/p>
&lt;h2 id="slice-的声明">Slice 的声明&lt;/h2>
&lt;p>&lt;code>var SliceID []TYPE&lt;/code>。MapID 为该切片的名字，[]中括号内不指明长度&lt;/p>
&lt;h2 id="slice-的实例化">Slice 的实例化&lt;/h2>
&lt;p>&lt;code>var SliceID []TYPE = ARR[START:END]&lt;/code>。切片通过数组 ARR 从 START 号索引到 END-1 号索引之间的元素构成自己(切分数组，&lt;code>START:END&lt;/code>被称为 slice 表达式)。切片的长度为 &lt;code>END-START&lt;/code>，切片的容量为&lt;code>从所引用的数组索引号START这个元素到这个数组最后一个元素的所有元素的个数&lt;/code>&lt;/p>
&lt;ul>
&lt;li>e.g.如果定义了一个数组 &lt;code>var arr1 [7]int&lt;/code>
&lt;ul>
&lt;li>&lt;code>var slice1 []type = arr1[2:5]&lt;/code>。&lt;code>slice1[0]&lt;/code>等于&lt;code>arr1[2]&lt;/code>。&lt;code>len(slice1)&lt;/code>切片长度为 3,&lt;code>cap(slice1)&lt;/code>切片容量为 5&lt;/li>
&lt;li>&lt;code>var slice2 []type = arr1[:]&lt;/code> 切片 slice2 等于完整的 arr1 数组。另一种表示方式：&lt;code>slice2 = &amp;amp;arr1&lt;/code>&lt;/li>
&lt;li>&lt;code>arr1[2:]&lt;/code> 和 &lt;code>arr1[2:len(arr1)]&lt;/code> 相同，表示包含了数组的 2 号索引到最后最一个索引的所有元素。&lt;/li>
&lt;li>&lt;code>arr1[:3]&lt;/code> 和 &lt;code>arr1[0:3]&lt;/code> 相同，表示包含了从数组的 0 号索引到 2 号索引的所有元素(不包括 3 号索引的元素)。&lt;/li>
&lt;li>&lt;code>s := [3]int{1,2,3}[:]&lt;/code>和&lt;code>s := []int{1,2,3}&lt;/code> 相同，表示由数字 1、2、3 组成的切片&lt;/li>
&lt;li>&lt;code>s2 := s[:]&lt;/code>使用切片组成的切片，拥有相同的元素，但是仍然指向相同的相关数组&lt;/li>
&lt;li>&lt;code>var x = []int{2,3,4,5,11}&lt;/code> 创建了一个长度为 5 的数组且创建了一个相关切片。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h3 id="使用make函数来创建一个切片同时创建好相关数组">使用&lt;code>make()&lt;/code>函数来创建一个切片，同时创建好相关数组。&lt;/h3>
&lt;p>格式：&lt;code>var SliceID []TYPE = make([]TYPE, LEN, CAP)&lt;/code>也可以简写为&lt;code>SliceD ：= make([]TYPE, LEN, CAP)&lt;/code>（其中 CAP 是可省的，默认与 LEN 相同）。&lt;code>MapID&lt;/code>为切片名；&lt;code>TYPE&lt;/code>为该切片的数据类型；&lt;code>LEN&lt;/code>为该切片的长度；&lt;code>CAP&lt;/code>为该切片的总容量。CAP 可以理解为切片所引用的数组的长度，切片的长度不能超过容量 i.e.不能超过所引用的数组的长度。make()函数接受 2 个参数：元素的类型、切片的个数。&lt;/p>
&lt;ul>
&lt;li>e.g.&lt;code>s2 := make([]int, 10)&lt;/code>。定义了一个名为 s2，长度与容量都为 10 的整型切片
&lt;ul>
&lt;li>这个例子可以拆解为两句，首先会声明一个数组&lt;code>var XX [10]int&lt;/code>，然后使用该数组初始化一个切片&lt;code>var s2 []int = XX[:]&lt;/code>Note:使用 make，而不是直接使用&lt;code>var persons []Person&lt;/code>的声明方式。还是有所差别的，使用 make 的方式，当数组切片没有元素的时候，Json 会返回[]。如果直接声明，json 会返回 null&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h2 id="slice-的引用">Slice 的引用&lt;/h2>
&lt;h3 id="for-range-结构">for-range 结构&lt;/h3>
&lt;p>使用该结构可以对数组或切片中的索引和元素的值进行相关操作，该结构可以返回索引与元素的值&lt;/p>
&lt;p>格式：&lt;code>for INDEX,VAL := range SliceID {...}&lt;/code>。&lt;/p>
&lt;p>返回值 INDEX 为数组或切片的索引；返回值 VAL 为该索引位置的值；MapID 为该数组或切片的名字代码示例：for-range.go\&lt;/p>
&lt;h2 id="slice-的-reslice重组">Slice 的 reslice(重组)&lt;/h2>
&lt;p>在使用 &lt;code>make()&lt;/code> 函数创建切片的时候，LEN 作为切片的初始长度，而 CAP 作为所切片所相关的数组的长度。这么做的好处是切片在达到 LEN 所定义的上限后，可以扩容，直到扩容到 CAP 定义的容量。改变切片长度的过程称之为&lt;strong>切片的重组(reslicinig)&lt;/strong>。&lt;/p>
&lt;h2 id="slice-的追加-append-与复制-copy">Slice 的追加 append() 与复制 copy()&lt;/h2>
&lt;p>&lt;code>append()&lt;/code> 格式 1：&lt;code>SLICE2 := append(SLICE1, X1, X2...)&lt;/code>
df
把 X1,X2 等元素追加给切片 SLICE1，追加的元素必须和原切片的元素类型相同。如果 SLICE1 的容量不足以存储新增的元素，append 会分配新的切片来保证已有切片元素和新增元素的存储。因此，返回的切片可能已经指向一个不同的相关数组了。append 方法总是返回成功，除非系统内存耗尽了。&lt;/p>
&lt;p>append 格式 2：&lt;code>SLICE2 := append(SLICE1, SLICE3)&lt;/code>&lt;/p>
&lt;p>可以将切片 SLICE3 追加到 SLICE1 的后面&lt;/p>
&lt;p>copy 格式：&lt;code>copy(SLICE1, SLICE2)&lt;/code>把切片 2 复制给切片 1&lt;/p>
&lt;h2 id="slice-的删除">Slice 的删除&lt;/h2>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://www.jianshu.com/p/604ba2ff5e67">https://www.jianshu.com/p/604ba2ff5e67&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>Go 语言并没有对删除切片元素提供专用的语法或者接口，需要使用切片本身的特性来删除元素，根据要删除元素的位置有三种情况，分别是从开头位置删除、从中间位置删除和从尾部删除，其中删除切片尾部的元素速度最快。&lt;/p>
&lt;p>Go 语言中切片删除元素的本质是：以被删除元素为分界点，将前后两个部分的内存重新连接起来。&lt;/p>
&lt;p>Go 语言中切片元素的删除过程并没有提供任何的语法糖或者方法封装，无论是初学者学习，还是实际使用都是极为麻烦的。&lt;/p>
&lt;p>连续容器的元素删除无论是在任何语言中，都要将删除点前后的元素移动到新的位置。随着元素的增加，这个过程将会变得极为耗时。因此，当业务需要大量、频繁地从一个切片中删除元素时，如果对性能要求较高，就需要反思是否需要更换其他的容器（如双链表等能快速从删除点删除元素）。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">seq&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> []&lt;span style="color:#66d9ef">string&lt;/span>{&lt;span style="color:#e6db74">&amp;#34;a&amp;#34;&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;b&amp;#34;&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;c&amp;#34;&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;d&amp;#34;&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;e&amp;#34;&lt;/span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 指定删除位置
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#a6e22e">index&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#ae81ff">2&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 查看删除位置之前的元素和之后的元素
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#a6e22e">fmt&lt;/span>.&lt;span style="color:#a6e22e">Println&lt;/span>(&lt;span style="color:#a6e22e">seq&lt;/span>[:&lt;span style="color:#a6e22e">index&lt;/span>], &lt;span style="color:#a6e22e">seq&lt;/span>[&lt;span style="color:#a6e22e">index&lt;/span>&lt;span style="color:#f92672">+&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>:])
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 将删除点前后的元素连接起来
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#a6e22e">seq&lt;/span> = append(&lt;span style="color:#a6e22e">seq&lt;/span>[:&lt;span style="color:#a6e22e">index&lt;/span>], &lt;span style="color:#a6e22e">seq&lt;/span>[&lt;span style="color:#a6e22e">index&lt;/span>&lt;span style="color:#f92672">+&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>:]&lt;span style="color:#f92672">...&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">fmt&lt;/span>.&lt;span style="color:#a6e22e">Println&lt;/span>(&lt;span style="color:#a6e22e">seq&lt;/span>)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>代码输出结果：
[a b] [d e]
[a b d e]
第 1 行，声明一个整型切片，保存含有从 a 到 e 的字符串。
第 4 行，为了演示和讲解方便，使用 index 变量保存需要删除的元素位置。
第 7 行中：seq[:index] 表示的就是被删除元素的前半部分，值为：
[1 2]
seq[index+1:] 表示的是被删除元素的后半部分，值为：
[4 5]
第 10 行使用 append() 函数将两个切片连接起来。
第 12 行，输出连接好的新切片。此时，索引为 2 的元素已经被删除。
代码的删除过程可以使用下图来描述。
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/sky27i/1666685042618-499422dc-7970-4f11-93d5-72f67a8321bd.png" alt="image.png">&lt;/p>
&lt;h1 id="排序">排序&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://pkg.go.dev/sort">Go 包，标准库，sort&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>Go 的 sort 包可以对内置的数据类型以及自定义数据类型进行排序。通常都是作用在对应类型的数组、切片中。&lt;/p></description></item><item><title>Docs: Control Structures(控制结构)</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/2.%E7%BC%96%E7%A8%8B/%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/go/go-%E6%A0%87%E5%87%86%E5%BA%93/control-structures%E6%8E%A7%E5%88%B6%E7%BB%93%E6%9E%84/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/2.%E7%BC%96%E7%A8%8B/%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/go/go-%E6%A0%87%E5%87%86%E5%BA%93/control-structures%E6%8E%A7%E5%88%B6%E7%BB%93%E6%9E%84/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;p>当我们需要只在满足一些特定情况时才执行某些代码的时候，也就是说在代码里进行条件判断。针对这个需求，Go 语言提供了 4 中条件结构和分支结构。&lt;/p>
&lt;p>在结构中，可以使用&lt;code>break&lt;/code>和&lt;code>continue&lt;/code>这样的关键字来中途改变结构的状态。还可以使用&lt;code>return&lt;/code>来结束某个函数的执行，或使用&lt;code>goto&lt;/code>和标签来调整程序的执行位置&lt;/p>
&lt;h1 id="for-循环">For 循环&lt;/h1>
&lt;p>用于测试某个条件(布尔型或逻辑型)的语句，初始化语句执行完成之后；如果该条件成立，则会执行 if 后由大括号括起来的代码块，然后执行修饰语句，之后再次判断条件语句是否成立，如此循环；直到条件语句不成立时，就忽略该代码块继续执行后续的代码。&lt;/p>
&lt;ul>
&lt;li>基本格式：for 初始化语句;条件语句;修饰语句 {代码块}&lt;/li>
&lt;/ul>
&lt;h1 id="if-else-判断">If-else 判断&lt;/h1>
&lt;h1 id="switch-判断">Switch 判断&lt;/h1>
&lt;p>给定一个变量，当该变量满足某个条件时执行某个代码。&lt;/p>
&lt;h1 id="select">select&lt;/h1>
&lt;h1 id="break-与-continue">break 与 continue&lt;/h1>
&lt;ul>
&lt;li>&lt;code>break&lt;/code> 用于退出当前当前代码块&lt;/li>
&lt;li>&lt;code>continue&lt;/code> 用于忽略当前循环，继续执行后续循环，只用于 for 结构体中 Note：注意！是退出当前代码块，如果循环有多层嵌套，那么只是退出当前循环；如果循环中套用 select 等，则也是退出当前控制结构。&lt;/li>
&lt;/ul>
&lt;h1 id="标签与-goto">标签与 goto&lt;/h1>
&lt;ul>
&lt;li>标签用于在出现标签关键字的时候，代码回到标签定义行再继续执行下面的代码。某一行以&lt;code>:&lt;/code>冒号结尾的单词即可定义标签。标签区分大小写&lt;/li>
&lt;/ul></description></item><item><title>Docs: Data Type(数据类型)</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/2.%E7%BC%96%E7%A8%8B/%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/go/go-%E6%A0%87%E5%87%86%E5%BA%93/data-type%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/2.%E7%BC%96%E7%A8%8B/%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/go/go-%E6%A0%87%E5%87%86%E5%BA%93/data-type%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://go.dev/ref/spec#Types">官方文档，参考-规范-类型&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>**Data Type(数据类型) **用来对一组相关值进行分类，描述可对其执行的操作并定义它们的存储方式。 通常也会称为 &lt;strong>Literal(字面量)&lt;/strong>&lt;/p>
&lt;p>Go 语言将数据类型分为四类：基础类型、复合类型、引用类型和接口类型。虽然数据类型有很多，但是这些数据类型都是对程序中一个变量或状态的间接引用。这意味着对任一引用类型数据的修改都会影响所有该引用的拷贝。所谓的引用，是对值的引用。注意引用与指针的区别，详见 pointer.go&lt;/p>
&lt;h2 id="underlying-type基本类型">Underlying Type(基本类型)&lt;/h2>
&lt;p>数据中最基本的类型，是构成其余数据类型以及对象的最小单位，当定义其他数据类型时，同样需要定义基础数据类型。基础数据类型也是 Go 语言的&lt;strong>内置数据类型&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>&lt;strong>Numeric(数字类型)&lt;/strong>
&lt;ul>
&lt;li>Integer Type(整数类型)&lt;/li>
&lt;li>Floating Point Numbers(浮点数型)&lt;/li>
&lt;li>complex 复数共两种复数，complex64 和 complex128，分别对应 float32 和 float64 两种浮点数精度。内置的 complex 函数用于构建复数，内建的 real 和 imag 函数分别返回复数的实部和虚部&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>**Strings(字符类型) **# 格式化标识&lt;code>%s&lt;/code>&lt;/li>
&lt;li>&lt;strong>Booleans(布尔类型)&lt;/strong> #
&lt;ul>
&lt;li>注意：很多时候，Booleans 类型的值可以用数字表示
&lt;ul>
&lt;li>1 表示 true(真)&lt;/li>
&lt;li>0 表示 false(假)&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h2 id="composite-type复合类型">Composite Type(复合类型)&lt;/h2>
&lt;p>是通过组合基础数据类型，来表达更复杂的数据结构&lt;/p>
&lt;ul>
&lt;li>Arrays(数组) # 多个相同基础类型的数据组合在一起&lt;/li>
&lt;li>Slices(切片)&lt;/li>
&lt;li>Maps(字典)&lt;/li>
&lt;li>Functions(函数，这里面主要指的是函数的参数的数据类型)&lt;/li>
&lt;li>Structs(结构体) #&lt;/li>
&lt;li>Interfaces(接口)&lt;/li>
&lt;li>Channels(通道)&lt;/li>
&lt;li>Pointers(指针)&lt;/li>
&lt;/ul>
&lt;h2 id="自定义数据类型类型定义">自定义数据类型(类型定义)&lt;/h2>
&lt;p>变量或表达式的 Type 定义了对应存储值的属性特征，例如数值在内存的存储大小（或者是元素的 bit 个数），它们在内部是如何表达的，是否支持一些操作符，以及它们自己关联的方法集等。&lt;/p>
&lt;p>在任何程序中都会存在一些变量有着相同的内部结构，但是却表示完全不同的概念。例如，一个 int 类型的变量可以用来表示一个循环的迭代索引、或者一个时间戳、或者一个文件描述符、或者一个月份；一个 float64 类型的变量可以用来表示每秒移动几米的速度、或者是不同温度单位下的温度；一个字符串可以用来表示一个密码或者一个颜色的名称。这些基于基本数据类型所生成的新数据类型都叫数据类型。再比如数组、切片、字典等，虽然在有的时候他们的基础数据类型可以使一样的，但是他们本身所表示的数据类型是不同的含义。&lt;/p>
&lt;p>一个类型声明语句创建了一个新的类型名称，和现有类型具有相同的底层结构。新命名的类型提供了一个方法，用来分隔不同概念的类型，这样即使它们底层类型相同也是不兼容的。&lt;/p>
&lt;p>格式：&lt;code>type TypeID BaseType&lt;/code>&lt;/p>
&lt;p>如果自定义数据类型的 BaseType 是由零个或多个任意类型的值(每个值对应一个类型)聚合成的实体，则需要使用 [Struct](/docs/IT学习笔记/2.编程/高级编程语言/Go/Go%20 标准库/Maps(映射)%20 与%20Struct(结构体).md 与 Struct(结构体).md)&lt;/p>
&lt;p>&lt;strong>Type Definition(类型定义)&lt;/strong> 是 Go 实现面向对象编程的最基本要素&lt;/p>
&lt;h1 id="类型检测">类型检测&lt;/h1>
&lt;p>详见 [反射](&amp;lt;/docs/IT学习笔记/2.编程/高级编程语言/Go/Go%20 标准库/Method(方法)、Interface(接口).md&amp;raquo;) 特性&lt;/p>
&lt;h1 id="类型转换">类型转换&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://go.dev/tour/basics/13">官方 Tour，基础-13&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>语法：&lt;code>Type(Expression)&lt;/code>&lt;/p>
&lt;ul>
&lt;li>将 Expression 获取到的值转换为 Type 类型。&lt;/li>
&lt;/ul>
&lt;blockquote>
&lt;p>注意：这种语法属于强制类型转换，若出现错误将会 panic。如果想要处理错误，可以使用 strconv 库等&lt;/p>
&lt;/blockquote>
&lt;p>注意：若 Type 为指针类型，最好写成这样：&lt;code>(Type)(Expression)&lt;/code>，比如：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">type&lt;/span> &lt;span style="color:#a6e22e">stringValue&lt;/span> &lt;span style="color:#66d9ef">string&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">p&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> new(&lt;span style="color:#66d9ef">string&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">a&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> (&lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">stringValue&lt;/span>)(&lt;span style="color:#a6e22e">p&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">fmt&lt;/span>.&lt;span style="color:#a6e22e">Println&lt;/span>(&lt;span style="color:#a6e22e">a&lt;/span>)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h1 id="格式化占位符">格式化占位符&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://pkg.go.dev/fmt#hdr-Printing">Go 包，标准库-fmt&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.cnblogs.com/qing123/articles/4353353.html">博客园，情三-golang fmt 格式“占位符”&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>格式化占位符，也可以称为 &lt;strong>format verbs(格式化动词)&lt;/strong>。这些动词可以在输出时，告诉数据应该以什么类型、样式输出。这类似于 C 语言的 printf 和 scanf，但是更简洁。&lt;/p>
&lt;p>以下面的代码为例：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">type&lt;/span> &lt;span style="color:#a6e22e">Human&lt;/span> &lt;span style="color:#66d9ef">struct&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">Name&lt;/span> &lt;span style="color:#66d9ef">string&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">var&lt;/span> &lt;span style="color:#a6e22e">people&lt;/span> = &lt;span style="color:#a6e22e">Human&lt;/span>{&lt;span style="color:#a6e22e">Name&lt;/span>:&lt;span style="color:#e6db74">&amp;#34;zhangsan&amp;#34;&lt;/span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="普通占位符">普通占位符&lt;/h2>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>占位符&lt;/th>
&lt;th>说明&lt;/th>
&lt;th>举例&lt;/th>
&lt;th>输出&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>%v&lt;/td>
&lt;td>根据值来自动推断类型的默认格式&lt;/td>
&lt;td>Printf(&amp;quot;%v&amp;quot;, people)&lt;/td>
&lt;td>{zhangsan}，&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>%+v&lt;/td>
&lt;td>打印结构体时，会添加字段名&lt;/td>
&lt;td>Printf(&amp;quot;%+v&amp;quot;, people)&lt;/td>
&lt;td>{Name:zhangsan}&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>%#v&lt;/td>
&lt;td>相应值的 Go 语法表示&lt;/td>
&lt;td>Printf(&amp;quot;#v&amp;quot;, people)&lt;/td>
&lt;td>main.Human{Name:&amp;ldquo;zhangsan&amp;rdquo;}&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>%T&lt;/td>
&lt;td>相应值的类型的 Go 语法表示&lt;/td>
&lt;td>Printf(&amp;quot;%T&amp;quot;, people)&lt;/td>
&lt;td>main.Human&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>%%&lt;/td>
&lt;td>字面上的百分号，并非值的占位符&lt;/td>
&lt;td>Printf(&amp;quot;%%&amp;quot;)&lt;/td>
&lt;td>%&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h2 id="布尔占位符">布尔占位符&lt;/h2>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>占位符&lt;/th>
&lt;th>说明&lt;/th>
&lt;th>举例&lt;/th>
&lt;th>输出&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>%t&lt;/td>
&lt;td>true 或 false。&lt;/td>
&lt;td>Printf(&amp;quot;%t&amp;quot;, true)&lt;/td>
&lt;td>true&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h2 id="整数占位符">整数占位符&lt;/h2>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>占位符&lt;/th>
&lt;th>说明&lt;/th>
&lt;th>举例&lt;/th>
&lt;th>输出&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>%b&lt;/td>
&lt;td>二进制表示&lt;/td>
&lt;td>Printf(&amp;quot;%b&amp;quot;, 5)&lt;/td>
&lt;td>101&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>%c&lt;/td>
&lt;td>相应 Unicode 码点所表示的字符&lt;/td>
&lt;td>Printf(&amp;quot;%c&amp;quot;, 0x4E2D)&lt;/td>
&lt;td>中&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>%d&lt;/td>
&lt;td>十进制表示&lt;/td>
&lt;td>Printf(&amp;quot;%d&amp;quot;, 0x12)&lt;/td>
&lt;td>18&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>%o&lt;/td>
&lt;td>八进制表示&lt;/td>
&lt;td>Printf(&amp;quot;%d&amp;quot;, 10)&lt;/td>
&lt;td>12&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>%q&lt;/td>
&lt;td>单引号围绕的字符字面值，由 Go 语法安全地转义&lt;/td>
&lt;td>Printf(&amp;quot;%q&amp;quot;, 0x4E2D)&lt;/td>
&lt;td>&amp;lsquo;中&amp;rsquo;&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>%x&lt;/td>
&lt;td>十六进制表示，字母形式为小写 a-f&lt;/td>
&lt;td>Printf(&amp;quot;%x&amp;quot;, 13)&lt;/td>
&lt;td>d&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>%X&lt;/td>
&lt;td>十六进制表示，字母形式为大写 A-F&lt;/td>
&lt;td>Printf(&amp;quot;%x&amp;quot;, 13)&lt;/td>
&lt;td>D&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>%U&lt;/td>
&lt;td>Unicode 格式：U+1234，等同于 &amp;ldquo;U+%04X&amp;rdquo;&lt;/td>
&lt;td>Printf(&amp;quot;%U&amp;quot;, 0x4E2D)&lt;/td>
&lt;td>U+4E2D&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h2 id="浮点数和复数的组成部分实部和虚部">浮点数和复数的组成部分(实部和虚部)&lt;/h2>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>占位符&lt;/th>
&lt;th>说明&lt;/th>
&lt;th>举例&lt;/th>
&lt;th>输出&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>%b&lt;/td>
&lt;td>无小数部分的，指数为二的幂的科学计数法,与 strconv.FormatFloat 的 &amp;lsquo;b&amp;rsquo; 转换格式一致。&lt;/td>
&lt;td>&lt;/td>
&lt;td>-123456p-78&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>%e&lt;/td>
&lt;td>科学计数法，例如 -1234.456e+78&lt;/td>
&lt;td>Printf(&amp;quot;%e&amp;quot;, 10.2)&lt;/td>
&lt;td>1.020000e+01&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>%E&lt;/td>
&lt;td>科学计数法，例如 -1234.456E+78&lt;/td>
&lt;td>Printf(&amp;quot;%e&amp;quot;, 10.2)&lt;/td>
&lt;td>1.020000E+01&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>%f&lt;/td>
&lt;td>有小数点而无指数，例如 123.456&lt;/td>
&lt;td>Printf(&amp;quot;%f&amp;quot;, 10.2)&lt;/td>
&lt;td>10.200000&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>%g&lt;/td>
&lt;td>根据情况选择 %e 或 %f 以产生更紧凑的(无末尾的 0)输出&lt;/td>
&lt;td>Printf(&amp;quot;%g&amp;quot;, 10.20)&lt;/td>
&lt;td>10.2&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>%G&lt;/td>
&lt;td>根据情况选择 %E 或 %f 以产生更紧凑的(无末尾的 0)输出&lt;/td>
&lt;td>Printf(&amp;quot;%G&amp;quot;, 10.20+2i)&lt;/td>
&lt;td>(10.2+2i)&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h2 id="字符串与字节切片">字符串与字节切片&lt;/h2>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>占位符&lt;/th>
&lt;th>说明&lt;/th>
&lt;th>举例&lt;/th>
&lt;th>输出&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>%s&lt;/td>
&lt;td>输出字符串表示(string 类型或[]byte)&lt;/td>
&lt;td>Printf(&amp;quot;%s&amp;quot;, []byte(&amp;ldquo;Go 语言&amp;rdquo;))&lt;/td>
&lt;td>Go 语言&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>%q&lt;/td>
&lt;td>双引号围绕的字符串，由 Go 语法安全地转义&lt;/td>
&lt;td>Printf(&amp;quot;%q&amp;quot;, &amp;ldquo;Go 语言&amp;rdquo;)&lt;/td>
&lt;td>&amp;ldquo;Go 语言&amp;rdquo;&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>%x&lt;/td>
&lt;td>十六进制，小写字母，每字节两个字符&lt;/td>
&lt;td>Printf(&amp;quot;%x&amp;quot;, &amp;ldquo;golang&amp;rdquo;)&lt;/td>
&lt;td>676f6c616e67&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>%X&lt;/td>
&lt;td>十六进制，大写字母，每字节两个字符&lt;/td>
&lt;td>Printf(&amp;quot;%X&amp;quot;, &amp;ldquo;golang&amp;rdquo;)&lt;/td>
&lt;td>676F6C616E67&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h2 id="指针">指针&lt;/h2>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>占位符&lt;/th>
&lt;th>说明&lt;/th>
&lt;th>举例&lt;/th>
&lt;th>输出&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>%p&lt;/td>
&lt;td>十六进制表示，前缀 0x&lt;/td>
&lt;td>Printf(&amp;quot;%p&amp;quot;, &amp;amp;people)&lt;/td>
&lt;td>0x4f57f0&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h2 id="其它标记">其它标记&lt;/h2>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>占位符&lt;/th>
&lt;th>说明&lt;/th>
&lt;th>举例&lt;/th>
&lt;th>输出&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>+&lt;/td>
&lt;td>总打印数值的正负号；对于%q(%+q)保证只输出 ASCII 编码的字符。&lt;/td>
&lt;td>Printf(&amp;quot;%+q&amp;quot;, &amp;ldquo;中文&amp;rdquo;)&lt;/td>
&lt;td>&amp;ldquo;\u4e2d\u6587&amp;rdquo;&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>-&lt;/td>
&lt;td>在右侧而非左侧填充空格(左对齐该区域)&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>#&lt;/td>
&lt;td>备用格式：为八进制添加前导 0(%#o)&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>为十六进制添加前导 0x(%#x)或 0X(%#X)，为 %p(%#p)去掉前导 0x；如果可能的话，%q(%#q)会打印原始 (即反引号围绕的)字符串；如果是可打印字符，%U(%#U)会写出该字符的 Unicode 编码形式(如字符 x 会被打印成 U+0078 &amp;lsquo;x&amp;rsquo;)。&lt;/td>
&lt;td>Printf(&amp;quot;%#U&amp;quot;, &amp;lsquo;中&amp;rsquo;)&lt;/td>
&lt;td>U+4E2D&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&amp;rsquo; '&lt;/td>
&lt;td>(空格)为数值中省略的正负号留出空白(% d)；以十六进制(% x, % X)打印字符串或切片时，在字节之间用空格隔开&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>0&lt;/td>
&lt;td>填充前导的 0 而非空格；对于数字，这会将填充移到正负号之后&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>golang 没有 &amp;lsquo;%u&amp;rsquo; 点位符，若整数为无符号类型，默认就会被打印成无符号的。&lt;/p>
&lt;p>宽度与精度的控制格式以 Unicode 码点为单位。宽度为该数值占用区域的最小宽度；精度为小数点之后的位数。&lt;/p>
&lt;p>操作数的类型为 int 时，宽度与精度都可用字符&lt;code>*&lt;/code>表示。&lt;/p>
&lt;p>对于 %g/%G 而言，精度为所有数字的总数，例如：123.45，%.4g 会打印 123.5，(而 %6.2f 会打印 123.45)。&lt;/p>
&lt;p>%e 和 %f 的默认精度为 6&lt;/p>
&lt;p>对大多数的数值类型而言，宽度为输出的最小字符数，如果必要的话会为已格式化的形式填充空格。&lt;/p>
&lt;p>而以字符串类型，精度为输出的最大字符数，如果必要的话会直接截断。&lt;/p></description></item><item><title>Docs: Function(函数)</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/2.%E7%BC%96%E7%A8%8B/%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/go/go-%E6%A0%87%E5%87%86%E5%BA%93/function%E5%87%BD%E6%95%B0/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/2.%E7%BC%96%E7%A8%8B/%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/go/go-%E6%A0%87%E5%87%86%E5%BA%93/function%E5%87%BD%E6%95%B0/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;h2 id="参考">参考：&lt;/h2>
&lt;/blockquote>
&lt;p>DRY 原则：Don&amp;rsquo;t Repeart Yourself(不要重复你自己)&lt;/p>
&lt;p>Golang 有 3 种类型的函数：&lt;/p>
&lt;ul>
&lt;li>普通的带有名字的函数&lt;/li>
&lt;li>匿名函数或者 lambda 函数&lt;/li>
&lt;li>Methods(方法) 除了 main()、init()函数外，其余所有类型的函数都可以有参数与返回值。函数参数、返回值以及它们的类型统称为&lt;strong>函数签名&lt;/strong>。&lt;/li>
&lt;/ul>
&lt;h2 id="function-的声明">Function 的声明&lt;/h2>
&lt;pre>&lt;code>func FunctionName([Parameter]) [(ReturnValue)] {
代码块
}
&lt;/code>&lt;/pre>
&lt;ul>
&lt;li>&lt;code>()&lt;/code> 里的 Parameter 以及 returnValue 可以省略，但是至少要包含一个&lt;code>()&lt;/code>，哪怕这个小括号内没有任何内容。i.e.一个函数可以没有参数，与返回值，仅仅执行本身所提供的功能&lt;/li>
&lt;li>Parameter(形式参数) # 这是一个参数列表，包括参数名以及参数类型。参数一般情况是变量、或者另一个函数(这个函数也可以当做变量来使用，是函数类型的变量，在调用时，可以通过实参改变该函数)。&lt;/li>
&lt;li>ReturnValue(返回值) # 同样包括参数名以及参数类型，参数一般是变量。可以直接定义变量名与类型，也可以省略变量名直接指明返回值的类型&lt;/li>
&lt;li>其中 Parameter 与 returnValue 都是可省的，最简化的定义格式为 &lt;code>function Name(){}&lt;/code>&lt;/li>
&lt;/ul>
&lt;h2 id="function-的调用">Function 的调用&lt;/h2>
&lt;p>调用函数 就是指 使用函数&lt;/p>
&lt;p>格式为：
&lt;code>[Pack.]Function([ARG1, ARG2, ..., ARGn])&lt;/code>&lt;/p>
&lt;p>其中 Pack 与 ARG 都是可省的，若在同一个包中，则 Pack 可省，若不用传递参数，则 ARG 可省。&lt;/p>
&lt;p>包名.函数名(实际参数)。&lt;code>Function&lt;/code>是&lt;code>Pack&lt;/code>包里的一个函数，括号里的是被调用函数的实参，这些实参的值被传递给被调用函数的形参，参数的传递是一一对应的，第一位传递给第一位，第二位传递给第二位，以此类推。在引用的时候参数可省略为空，但是括号必须要有&lt;/p>
&lt;ol>
&lt;li>&lt;strong>actual parameter(实际参数，简称 实参)&lt;/strong> # 一般用 arguments 表示，在调用函数时使用实参&lt;/li>
&lt;li>&lt;strong>formal parameter(形式参数，简称 形参)&lt;/strong> # 一般用 parameter 表示，在定义函数时使用形参&lt;/li>
&lt;/ol>
&lt;p>注意：
在使用函数返回值对变量进行赋值的时候，可以使用&lt;code>_&lt;/code>下划线，来把函数的某一个返回值丢弃。详见&lt;a href="https://desistdaydream.github.io/5.Functions/return.go">return.go&lt;/a>中下划线的使用方法&lt;/p>
&lt;p>如果在同一个包下的多个文件之间互相调用函数，在执行 go run XXX.go 命令时，需要指定所有文件，即 go run *.go 只有这样在引用其他文件中的函数时，才可以成功。&lt;/p>
&lt;h3 id="回调函数">回调函数&lt;/h3>
&lt;p>函数可以作为其他函数的参数进行传递，然后在其它函数内调用执行，一般称之为&lt;strong>回调&lt;/strong>。e.g.function_parameter.go&lt;/p>
&lt;h3 id="内置函数">内置函数&lt;/h3>
&lt;p>一些不需要进行导入操作就可以使用的函数就是内置函数。&lt;/p>
&lt;p>通俗来说，是在不使用&lt;code>import&lt;/code>关键字导入任何包，就可以在 main 下直接使用的各种函数。&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>名称&lt;/th>
&lt;th>说明&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>close&lt;/td>
&lt;td>用于管道通信&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>len、cap&lt;/td>
&lt;td>len 用于返回某个类型的长度或数量(字符串、数组、切片、map 和管道)；cap 是容量的意思，用于返回某个类型的最大容量(只能用于切片和 map)&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>new、make&lt;/td>
&lt;td>new 和 make 均是用于分配内存：new 用于值类型和用户定义的类型，如自定义结构，make 用于内置引用类型（切片、map 和管道）。它们的用法就像是函数，但是将类型作为参数：new(type)、make(type)。new(T) 分配类型 T 的零值并返回其地址，也就是指向类型 T 的指针（详见第 10.1 节）。它也可以被用于基本类型：v := new(int)。make(T) 返回类型 T 的初始化之后的值，因此它比 new 进行更多的工作&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>&lt;code>new()&lt;/code>
是一个函数，不要忘记它的括号 |
| copy、append | 用于复制和连接切片 |
| panic、recover | 两者均用于错误处理机制 |
| print、println | 底层打印函数，在部署环境中建议使用 fmt 包内的打印函数 |
| complex、real imag | 用于创建和操作复数 |&lt;/p>
&lt;h1 id="variadic-functions可变参数函数">Variadic Functions(可变参数函数)&lt;/h1>
&lt;p>代码示例 variadic.go&lt;/p>
&lt;p>如果函数的最后一个参数是采用&lt;code>...type&lt;/code>的形式，那么这个函数就可以处理一个变长的参数，这个长度可以为 0，这样的函数称为 VariadicFunctions。&lt;/p>
&lt;p>格式为：&lt;code>func Funcition(Param1,Param2,...ParamX ...TYPE) {}&lt;/code>。最后一个参数&lt;code>ParamX&lt;/code>类型为&lt;code>TYPE切片&lt;/code>，这个参数称为&lt;code>变长参数&lt;/code>，该参数可接收多个值。&lt;/p>
&lt;p>e.g. 示例函数以及调用&lt;/p>
&lt;pre>&lt;code>func Greeting(prefix string, who ...string)
Greeting(&amp;quot;hello:&amp;quot;, &amp;quot;Joe&amp;quot;, &amp;quot;Anna&amp;quot;, &amp;quot;Eileen&amp;quot;)
&lt;/code>&lt;/pre>
&lt;p>该例子中，变量&lt;code>who&lt;/code>的值为&lt;code>[]string{&amp;quot;Joe&amp;quot;, &amp;quot;Anna&amp;quot;, &amp;quot;Eileen&amp;quot;}&lt;/code> 这类函数可以接受&lt;strong>任意数量的形参&lt;/strong>，因为使用的是 &lt;code>...&lt;/code> 作为形参列表&lt;/p>
&lt;h1 id="closure闭包-与-anonymousfunctions匿名函数">Closure(闭包) 与 AnonymousFunctions(匿名函数)&lt;/h1>
&lt;p>&lt;strong>Closure(闭包)&lt;/strong> 通俗得讲，就是函数 a 的内部函数 b，被函数 a 外部的一个变量引用的时候，就创建了一个闭包代码示例 closure.go&lt;/p>
&lt;p>&lt;strong>Anonymous Functions(匿名函数)&lt;/strong>，当我们不希望给函起名字的时候可以使用&lt;code>匿名函数&lt;/code>。&lt;/p>
&lt;p>匿名函数不能够独立存在&lt;/p>
&lt;ul>
&lt;li>可以把匿名函数赋值于某个变量。i.e.保存函数的地址到变量中。
&lt;ul>
&lt;li>&lt;code>fplus := func(x, y int) int { return x+y }&lt;/code>
&lt;ul>
&lt;li>然后可以同通过变量名对函数进行调用 i.e.&lt;code>fplus(3,4)&lt;/code>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>可以让匿名函数仅仅实现自身逻辑即可
&lt;ul>
&lt;li>&lt;code>func(x, y int) { fmt.Println(x + y) }(3, 4)&lt;/code>
&lt;ul>
&lt;li>第一个括号 &lt;code>(x, y int)&lt;/code> 表示该函数的形参&lt;/li>
&lt;li>最后的括号 &lt;code>(3, 4)&lt;/code> 表示调用该函数的实参&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>所谓的匿名函数，其实就是定义时即调用运行，而普通函数，定义后，在定义后不调用之前，是不会运行的。&lt;/p>
&lt;p>&lt;strong>匿名函数 &lt;strong>可以构造&lt;/strong> Closure(闭包)&lt;/strong>。&lt;/p>
&lt;p>闭包的特性：&lt;/p>
&lt;ol>
&lt;li>封闭性：外界无法访问闭包内部的数据，如果在闭包内声明变量，外界是无法访问的，除非闭包主动向外界提供范文接口&lt;/li>
&lt;li>持久性：一般的函数，在调用完毕后，系统自动注销函数，而对于闭包来说，在外部函数被调用之后，闭包的结构依然保存在系统中，闭包中的数据依然存在&lt;/li>
&lt;li>闭包会占用内存资源，过多的使用会导致内存溢出。&lt;/li>
&lt;/ol>
&lt;p>闭包是一个有状态(不消失的私有数据)的函数。闭包是一个有记忆的函数。闭包相当于一个只有一个方法的紧凑对象。&lt;/p>
&lt;h1 id="recursion递归">Recursion(递归)&lt;/h1>
&lt;p>当一个函数在其函数体内调用自身，则称之为&lt;strong>递归&lt;/strong>。最经典的例子是计算斐波那契数列，即前两个数为 1，从第三个数开始每个数均为前两个数之和。\&lt;/p>
&lt;h1 id="make-与-new">make() 与 new()&lt;/h1>
&lt;ul>
&lt;li>&lt;code>make(t Type, size ...IntegerType)&lt;/code> 用于为 &lt;strong>内建类型(map、slice、channel)&lt;/strong> 分配内存。&lt;/li>
&lt;li>&lt;code>new(Type)&lt;/code> 用于为 &lt;strong>各种类型&lt;/strong>_ _分配内存。&lt;/li>
&lt;/ul>
&lt;p>第一个参数是类型，而不是值，返回的值是指向该类型新分配的零值的指针。&lt;/p>
&lt;p>&lt;code>make(T,args)&lt;/code> 与 &lt;code>new(T)&lt;/code> 有着不同的功能，make 只能创建 slice,map,channel，并且返回一个有初始值(非零)的 T 类型，而不是&lt;code>*T&lt;/code>&lt;/p>
&lt;p>&lt;code>new(T)&lt;/code> 分配了零值填充的 &lt;code>T类型&lt;/code> 的内存空间，并且返回其地址，即一个 &lt;code>*T&lt;/code> 类型的值(GO 语言的术语：返回了一个指针，指向新分配的类型 T 的零值)&lt;/p>
&lt;p>&lt;code>new()&lt;/code> 是 go 语言中很重要的一种 &lt;strong>设计思想&lt;/strong>,在原生基础包里，仅仅返回一个类型的指针。而在实际项目中，人们常常将 new() 思想与 struct 相结合。比如下面这个例子：&lt;/p>
&lt;pre>&lt;code>// 声明一个结构体
type MemorySession struct {
sessionID string
data map[string]interface{}
rwlock sync.RWMutex
}
// NewMemorySession 返回一个储存 Session 的内存引擎
func NewMemorySession(id string) *MemorySession {
s := &amp;amp;MemorySession{}
return s
}
&lt;/code>&lt;/pre>
&lt;p>这个例子中，就使用了 new() 的思想，通过一个函数，来生成一个结构体的指针，这个指针通常称为该结构体的 &lt;strong>instance(实例)&lt;/strong>。这样，后续要操作这个结构体属性的值，调用这些指针(i.e.实例)即可&lt;/p>
&lt;pre>&lt;code>s := NeNewMemorySession(&amp;quot;DD&amp;quot;)
s.METHOD1
s.METHOD2
....等等
&lt;/code>&lt;/pre>
&lt;p>再比如在 kubernetes 项目中，也可以在很多地方看到这类&lt;strong>设计思想&lt;/strong>&lt;/p>
&lt;p>这里用 kubelet 的一段代码举例：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">type&lt;/span> &lt;span style="color:#a6e22e">HollowKubelet&lt;/span> &lt;span style="color:#66d9ef">struct&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">KubeletFlags&lt;/span> &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">options&lt;/span>.&lt;span style="color:#a6e22e">KubeletFlags&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">KubeletConfiguration&lt;/span> &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">kubeletconfig&lt;/span>.&lt;span style="color:#a6e22e">KubeletConfiguration&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">KubeletDeps&lt;/span> &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">kubelet&lt;/span>.&lt;span style="color:#a6e22e">Dependencies&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">func&lt;/span> &lt;span style="color:#a6e22e">NewHollowKubelet&lt;/span>(
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">flags&lt;/span> &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">options&lt;/span>.&lt;span style="color:#a6e22e">KubeletFlags&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">...&lt;/span>..
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#f92672">&amp;amp;&lt;/span>&lt;span style="color:#a6e22e">HollowKubelet&lt;/span>{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">KubeletFlags&lt;/span>: &lt;span style="color:#a6e22e">flags&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">KubeletConfiguration&lt;/span>: &lt;span style="color:#a6e22e">config&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">KubeletDeps&lt;/span>: &lt;span style="color:#a6e22e">d&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>这里用 NewHollowKubelet() 函数实例化了一个 HollowKubelet 结构体。后续想要使用时，调用 New 函数，生成一个实例(指针变量)，然后调用作用在这个结构体上的方法即可。&lt;/p>
&lt;h3 id="总结">&lt;strong>总结：&lt;/strong>&lt;/h3>
&lt;p>&lt;code>new&lt;/code>负责分配内存，&lt;code>new(T)&lt;/code>返回&lt;code>*T&lt;/code>指向一个零值&lt;code>T&lt;/code>的指针&lt;/p>
&lt;p>make 负责初始化值，make(T) 返回初始化后的 T ，而非指针&lt;/p>
&lt;p>最重要的一点：make 仅适用于 slice，map 和 channel&lt;/p>
&lt;p>关于，并非是空值，而是一种“变量未填充前”的默认值，通常为 0，如下&lt;/p>
&lt;pre>&lt;code>int 0
int8 0
int32 0
int64 0
uint 0x0
rune 0 //rune的实际类型是 int32
byte 0x0 //byte的实际类型是uint8
float32 0 //长度为4 byte
float64 0 //长度为8 byte
bool false
string &amp;quot;&amp;quot;
&lt;/code>&lt;/pre>
&lt;h1 id="other">Other&lt;/h1>
&lt;p>展示一个计算过程所消耗的时间：使用 time 包中的&lt;code>Now()&lt;/code>和&lt;code>Sub()&lt;/code>函数，在计算开始之前设置一个起始时间，再由计算结束时的结束时间与起始时间相减，即为执行计算的消耗时间。代码示例:fibonnaci.go&lt;/p></description></item><item><title>Docs: Generic(泛型)</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/2.%E7%BC%96%E7%A8%8B/%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/go/go-%E6%A0%87%E5%87%86%E5%BA%93/generic%E6%B3%9B%E5%9E%8B/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/2.%E7%BC%96%E7%A8%8B/%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/go/go-%E6%A0%87%E5%87%86%E5%BA%93/generic%E6%B3%9B%E5%9E%8B/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Generic_programming">Wiki,Generic proramming&lt;/a>(泛型编程)&lt;/li>
&lt;li>&lt;a href="https://mp.weixin.qq.com/s/Ymxs4Z2p62hQ7RA3q23drg">公众号-OSC 开源社区，使用 Go 泛型的最佳时机&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://mp.weixin.qq.com/s/MVZxoh8pYYUJ1_Dyj8Sh7g">公众号-OSC 开源社区，Go 语言之父介绍泛型&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://mp.weixin.qq.com/s/Zk24GsvpryB64hlSAp06Iw">公众号-InfoQ，Go 中的泛型：激动人心的突破&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://mp.weixin.qq.com/s/3Yc7_mvYdr3KtSE0jnAJww">公众号-幼麟实验室，Go 泛型的实现&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>泛型让我们在定义接口、函数、结构体时将其中的类型&lt;strong>参数化&lt;/strong>。我们从古老的 Ada 语言的第一个版本就开始使用泛型了，后来 C++ 的模板中也有泛型，直到 Java 和 C# 中的现代实现都是很常见的例子。&lt;/p>
&lt;p>泛型为 Go 添加了三个新的重要内容：&lt;/p>
&lt;ul>
&lt;li>面向函数和类型的“类型形参” (type parameters)&lt;/li>
&lt;li>将接口类型定义为类型集合，包括没有方法的接口类型&lt;/li>
&lt;li>类型推断：在大多数情况下，在调用泛型函数时可省略“类型实参” (type arguments)&lt;/li>
&lt;/ul>
&lt;h2 id="类型形参与约束">类型形参与约束&lt;/h2>
&lt;p>下面是一个初步理解泛型的最简单例子：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 泛型
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 使用类型形参编写 Go 函数以处理多种类型
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// comparable 是一个内置 Constraint(约束)，用来表示类型形参可以接收的类型实参的种类，所谓的“约束”就是指，T 被约束为可以使用哪几种类型。
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// comparable 包含所有可以比较类型，包括：booleans、numbers、strings、pointers、channels、可比较的 arrays、structs 中的属性
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// comparable 可以改为 any，表示 T 可以是任意类型
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">func&lt;/span> &lt;span style="color:#a6e22e">Index&lt;/span>[&lt;span style="color:#a6e22e">T&lt;/span> &lt;span style="color:#a6e22e">comparable&lt;/span>](&lt;span style="color:#a6e22e">s&lt;/span> []&lt;span style="color:#a6e22e">T&lt;/span>, &lt;span style="color:#a6e22e">x&lt;/span> &lt;span style="color:#a6e22e">T&lt;/span>) &lt;span style="color:#66d9ef">int&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span> &lt;span style="color:#a6e22e">i&lt;/span>, &lt;span style="color:#a6e22e">v&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#66d9ef">range&lt;/span> &lt;span style="color:#a6e22e">s&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 这里的 v 和 x 都是 T 类型，且 T 类型具有可以比较的约束，因此这里可以使用 ==
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">if&lt;/span> &lt;span style="color:#a6e22e">v&lt;/span> &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#a6e22e">x&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#a6e22e">i&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#f92672">-&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">func&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// Index() 函数适用于 int 类型的切片
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#a6e22e">si&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> []&lt;span style="color:#66d9ef">int&lt;/span>{&lt;span style="color:#ae81ff">10&lt;/span>, &lt;span style="color:#ae81ff">20&lt;/span>, &lt;span style="color:#ae81ff">15&lt;/span>, &lt;span style="color:#f92672">-&lt;/span>&lt;span style="color:#ae81ff">10&lt;/span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">fmt&lt;/span>.&lt;span style="color:#a6e22e">Println&lt;/span>(&lt;span style="color:#a6e22e">Index&lt;/span>(&lt;span style="color:#a6e22e">si&lt;/span>, &lt;span style="color:#ae81ff">15&lt;/span>))
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// Index() 函数同样也使用于 string 类型的切片
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#a6e22e">ss&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> []&lt;span style="color:#66d9ef">string&lt;/span>{&lt;span style="color:#e6db74">&amp;#34;foo&amp;#34;&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;bar&amp;#34;&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;baz&amp;#34;&lt;/span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">fmt&lt;/span>.&lt;span style="color:#a6e22e">Println&lt;/span>(&lt;span style="color:#a6e22e">Index&lt;/span>(&lt;span style="color:#a6e22e">ss&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;hello&amp;#34;&lt;/span>))
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>可以看到，我们将 a、b 的类型&lt;strong>参数化&lt;/strong>了。这里的 T，可以称之为&lt;strong>泛型类型&lt;/strong>，同时也是 Max() 方法的 &lt;strong>Type Parameters(类型形参)&lt;/strong>。当我们调用 Max() 时，可以传递参数告诉 &lt;code>Max()&lt;/code> 当前应该使用类型执行其中的代码&lt;/p>
&lt;p>如果没有泛型，那么我们的 &lt;code>Index()&lt;/code> 函数就要写两遍(有多少种类型，就要写多少遍)：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">func&lt;/span> &lt;span style="color:#a6e22e">IndexInt&lt;/span>(&lt;span style="color:#a6e22e">s&lt;/span> []&lt;span style="color:#66d9ef">int&lt;/span>, &lt;span style="color:#a6e22e">x&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span>) &lt;span style="color:#66d9ef">int&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// Do Somthing
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">func&lt;/span> &lt;span style="color:#a6e22e">IndexString&lt;/span>(&lt;span style="color:#a6e22e">s&lt;/span> []&lt;span style="color:#66d9ef">string&lt;/span>, &lt;span style="color:#a6e22e">x&lt;/span> &lt;span style="color:#66d9ef">string&lt;/span>) &lt;span style="color:#66d9ef">int&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// Do Somthing
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>还可以使用 any 关键字，以便让约束变为任意类型&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">func&lt;/span> &lt;span style="color:#a6e22e">Do&lt;/span>[&lt;span style="color:#a6e22e">R&lt;/span> &lt;span style="color:#a6e22e">any&lt;/span>, &lt;span style="color:#a6e22e">S&lt;/span> &lt;span style="color:#a6e22e">any&lt;/span>, &lt;span style="color:#a6e22e">T&lt;/span> &lt;span style="color:#a6e22e">any&lt;/span>](&lt;span style="color:#a6e22e">a&lt;/span> &lt;span style="color:#a6e22e">R&lt;/span>, &lt;span style="color:#a6e22e">b&lt;/span> &lt;span style="color:#a6e22e">S&lt;/span>) &lt;span style="color:#a6e22e">T&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// Do Somthing
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">func&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">fmt&lt;/span>.&lt;span style="color:#a6e22e">Println&lt;/span>(&lt;span style="color:#a6e22e">Do&lt;/span>[&lt;span style="color:#66d9ef">int&lt;/span>, &lt;span style="color:#66d9ef">uint&lt;/span>, &lt;span style="color:#66d9ef">float64&lt;/span>](&lt;span style="color:#ae81ff">1&lt;/span>, &lt;span style="color:#ae81ff">2&lt;/span>))
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 上面的代码的行为与下面的函数完全相同:
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// Do(a int, b uint) float64
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h1 id="其他">其他&lt;/h1>
&lt;h2 id="类型形参">类型形参&lt;/h2>
&lt;p>现在函数和类型都具有类型形参” (type parameters)，类型形参列表看起来就是一个普通的参数列表，除了它使用的是方括号而不是小括号。&lt;/p>
&lt;p>先从浮点值的基本非泛型 Min 函数开始：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">func&lt;/span> &lt;span style="color:#a6e22e">Min&lt;/span>(&lt;span style="color:#a6e22e">x&lt;/span>, &lt;span style="color:#a6e22e">y&lt;/span> &lt;span style="color:#66d9ef">float64&lt;/span>) &lt;span style="color:#66d9ef">float64&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> &lt;span style="color:#a6e22e">x&lt;/span> &amp;lt; &lt;span style="color:#a6e22e">y&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#a6e22e">x&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#a6e22e">y&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>通过添加类型形参列表来使这个函数泛型化——使其适用于不同的类型。在此示例中，添加了一个带有单个类型形参&lt;code>T&lt;/code>的类型参数列表，并替换了&lt;code>float64&lt;/code>。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">import&lt;/span> &lt;span style="color:#e6db74">&amp;#34;golang.org/x/exp/constraints&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">func&lt;/span> &lt;span style="color:#a6e22e">GMin&lt;/span>[&lt;span style="color:#a6e22e">T&lt;/span> &lt;span style="color:#a6e22e">constraints&lt;/span>.&lt;span style="color:#a6e22e">Ordered&lt;/span>](&lt;span style="color:#a6e22e">x&lt;/span>, &lt;span style="color:#a6e22e">y&lt;/span> &lt;span style="color:#a6e22e">T&lt;/span>) &lt;span style="color:#a6e22e">T&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> &lt;span style="color:#a6e22e">x&lt;/span> &amp;lt; &lt;span style="color:#a6e22e">y&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#a6e22e">x&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#a6e22e">y&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>然后就可以使用类型实参调用此函数：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">x&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">GMin&lt;/span>[&lt;span style="color:#66d9ef">int&lt;/span>](&lt;span style="color:#ae81ff">2&lt;/span>, &lt;span style="color:#ae81ff">3&lt;/span>)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>向  GMin 提供类型参数，在这种情况下&lt;code>int&lt;/code>称为实例化。实例化分两步进行。首先，编译器在泛型函数或泛型类型中用所有类型形参替换它们各自的类型实参。然后，编译器验证每个类型形参是否满足各自的约束。如果第二步失败，实例化就会失败并且程序无效。&lt;/p>
&lt;p>成功实例化后，即可产生非泛型函数，它可以像任何其他函数一样被调用。比如：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">fmin&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">GMin&lt;/span>[&lt;span style="color:#66d9ef">float64&lt;/span>]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">m&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">fmin&lt;/span>(&lt;span style="color:#ae81ff">2.71&lt;/span>, &lt;span style="color:#ae81ff">3.14&lt;/span>)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;code>GMin[float64]&lt;/code>的实例化产生了一个与&lt;code>Min&lt;/code>函数等效的函数，可以在函数调用中使用它。类型形参也可以与类型一起使用。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">type&lt;/span> &lt;span style="color:#a6e22e">Tree&lt;/span>[&lt;span style="color:#a6e22e">T&lt;/span> &lt;span style="color:#66d9ef">interface&lt;/span>{}] &lt;span style="color:#66d9ef">struct&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">left&lt;/span>, &lt;span style="color:#a6e22e">right&lt;/span> &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">Tree&lt;/span>[&lt;span style="color:#a6e22e">T&lt;/span>]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">value&lt;/span> &lt;span style="color:#a6e22e">T&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">func&lt;/span> (&lt;span style="color:#a6e22e">t&lt;/span> &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">Tree&lt;/span>[&lt;span style="color:#a6e22e">T&lt;/span>]) &lt;span style="color:#a6e22e">Lookup&lt;/span>(&lt;span style="color:#a6e22e">x&lt;/span> &lt;span style="color:#a6e22e">T&lt;/span>) &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">Tree&lt;/span>[&lt;span style="color:#a6e22e">T&lt;/span>] { &lt;span style="color:#f92672">...&lt;/span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">var&lt;/span> &lt;span style="color:#a6e22e">stringTree&lt;/span> &lt;span style="color:#a6e22e">Tree&lt;/span>[&lt;span style="color:#66d9ef">string&lt;/span>]
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>在上面的例子中，泛型类型&lt;code>Tree&lt;/code>存储了类型形参&lt;code>T&lt;/code>的值。泛型类型也可以有方法，比如本例中的&lt;code>Lookup&lt;/code>。为了使用泛型类型，它必须被实例化；&lt;code>Tree[string]&lt;/code>是使用类型实参&lt;code>string&lt;/code>来实例化&lt;code>Tree&lt;/code>的示例。&lt;/p>
&lt;h2 id="类型推断">类型推断&lt;/h2>
&lt;p>此项功能是最复杂的变更，主要包括：&lt;/p>
&lt;ul>
&lt;li>函数参数类型推断 (Function argument type inference)&lt;/li>
&lt;li>约束类型推断 (Constraint type inference)&lt;/li>
&lt;/ul>
&lt;p>虽然类型推断的工作原理细节很复杂，但使用它并不复杂：类型推断要么成功，要么失败。如果它成功，类型实参可以被省略，调用泛型函数看起来与调用普通函数没有什么不同。如果类型推断失败，编译器将给出错误消息，在这种情况下，只需提供必要的类型实参。&lt;/p>
&lt;hr>
&lt;p>泛型是 Go 1.18 的重要新语言特性，Robert Griesemer 和 Ian Lance Taylor 表示，这个功能实现得很好并且质量很高。虽然他们鼓励在有必要的场景中使用泛型，但在生产环境中部署泛型代码时，请务必谨慎。&lt;/p>
&lt;p>更多介绍查看原文：https://go.dev/blog/intro-generics。&lt;/p>
&lt;h1 id="使用泛型的最佳时机">使用泛型的最佳时机&lt;/h1>
&lt;p>从历史上看，C++、D 乃至 Rust 等系统语言一直采用单态化方法实现泛型。然而，Go 1.18 的泛型实现并不完全依靠单态化 (Monomorphization)，而是采用了一种被称为&amp;quot;GCShape stenciling with Dictionaries&amp;quot;的部分单态化技术。这种方法的好处是可以大幅减少代码量，但在特定情况下，会导致代码速度变慢。&lt;/p>
&lt;p>Ian Lance Taylor 表示，Go 的通用开发准则有要求：开发者应通过编写代码而不是定义类型来编写 Go 程序。当涉及到泛型时，如果通过定义类型参数约束来编写程序，那一开始就走错了路。正解应该是从编写函数开始，当明确了类型参数的作用后，再添加类型参数就很容易了。&lt;/p>
&lt;p>接着，Ian 列举了 4 种类型参数能有效发挥作用的情况：&lt;/p>
&lt;ol>
&lt;li>使用语言定义的特殊容器类型&lt;/li>
&lt;li>通用数据结构&lt;/li>
&lt;li>类型参数首选是函数，而非方法的情况&lt;/li>
&lt;li>不同类型需要实现通用方法&lt;/li>
&lt;/ol>
&lt;p>同时也提醒了不适合使用类型参数的情况：&lt;/p>
&lt;ol>
&lt;li>不要使用类型参数替换接口类型 (Interface Type)&lt;/li>
&lt;li>如果方法实现不同，不要使用类型参数&lt;/li>
&lt;li>在适当的地方使用反射 (reflection)&lt;/li>
&lt;/ol>
&lt;p>最后，Ian 给出了简要的泛型使用方针，当开发者发现自己多次编写完全相同的代码，而这些副本之间的唯一区别仅在于使用了不同类型，这时候便可以考虑使用类型参数。换句话说，即开发者应避免使用类型参数，直到发现自己要多次编写完全相同的代码。&lt;/p>
&lt;h2 id="最佳实践">最佳实践&lt;/h2>
&lt;p>泛型的最佳时机，就是当两个“对象”的某些“方法”的行为完全一样时，我们可以通过泛型来声明这些方法，以防止重复编写完全相同的代码。就像下面这段代码中，ProductGorm 与 UserGorm 的两个方法代码其实是完全相同的，如果使用 interface{}，那么我们需要重复写了 Create() 与 Get() 方法。其实，本质上 ProductGorm 与 UserGorm 所需要执行的 SQL 是完全一样，不一样的只是其中的列名而已。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">package&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">import&lt;/span> (
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#34;fmt&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#34;github.com/go-gorm/driver/sqlite&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#34;github.com/go-gorm/gorm&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">type&lt;/span> &lt;span style="color:#a6e22e">ProductGorm&lt;/span> &lt;span style="color:#66d9ef">struct&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">gorm&lt;/span>.&lt;span style="color:#a6e22e">Model&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">Name&lt;/span> &lt;span style="color:#66d9ef">string&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">Price&lt;/span> &lt;span style="color:#66d9ef">uint&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">type&lt;/span> &lt;span style="color:#a6e22e">UserGorm&lt;/span> &lt;span style="color:#66d9ef">struct&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">gorm&lt;/span>.&lt;span style="color:#a6e22e">Model&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">FirstName&lt;/span> &lt;span style="color:#66d9ef">string&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">LastName&lt;/span> &lt;span style="color:#66d9ef">string&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">type&lt;/span> &lt;span style="color:#a6e22e">Repository&lt;/span>[&lt;span style="color:#a6e22e">T&lt;/span> &lt;span style="color:#a6e22e">any&lt;/span>] &lt;span style="color:#66d9ef">struct&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">db&lt;/span> &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">gorm&lt;/span>.&lt;span style="color:#a6e22e">DB&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">func&lt;/span> (&lt;span style="color:#a6e22e">r&lt;/span> &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">Repository&lt;/span>[&lt;span style="color:#a6e22e">T&lt;/span>]) &lt;span style="color:#a6e22e">Create&lt;/span>(&lt;span style="color:#a6e22e">t&lt;/span> &lt;span style="color:#a6e22e">T&lt;/span>) &lt;span style="color:#66d9ef">error&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#a6e22e">r&lt;/span>.&lt;span style="color:#a6e22e">db&lt;/span>.&lt;span style="color:#a6e22e">Create&lt;/span>(&lt;span style="color:#f92672">&amp;amp;&lt;/span>&lt;span style="color:#a6e22e">t&lt;/span>).&lt;span style="color:#a6e22e">Error&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">func&lt;/span> (&lt;span style="color:#a6e22e">r&lt;/span> &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">Repository&lt;/span>[&lt;span style="color:#a6e22e">T&lt;/span>]) &lt;span style="color:#a6e22e">Get&lt;/span>(&lt;span style="color:#a6e22e">id&lt;/span> &lt;span style="color:#66d9ef">uint&lt;/span>) (&lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">T&lt;/span>, &lt;span style="color:#66d9ef">error&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">var&lt;/span> &lt;span style="color:#a6e22e">t&lt;/span> &lt;span style="color:#a6e22e">T&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">err&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">r&lt;/span>.&lt;span style="color:#a6e22e">db&lt;/span>.&lt;span style="color:#a6e22e">Where&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;id = ?&amp;#34;&lt;/span>, &lt;span style="color:#a6e22e">id&lt;/span>).&lt;span style="color:#a6e22e">First&lt;/span>(&lt;span style="color:#f92672">&amp;amp;&lt;/span>&lt;span style="color:#a6e22e">t&lt;/span>).&lt;span style="color:#a6e22e">Error&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#f92672">&amp;amp;&lt;/span>&lt;span style="color:#a6e22e">t&lt;/span>, &lt;span style="color:#a6e22e">err&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">func&lt;/span> &lt;span style="color:#a6e22e">NewProductRepository&lt;/span>(&lt;span style="color:#a6e22e">db&lt;/span> &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">gorm&lt;/span>.&lt;span style="color:#a6e22e">DB&lt;/span>) &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">Repository&lt;/span>[&lt;span style="color:#a6e22e">ProductGorm&lt;/span>] {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">db&lt;/span>.&lt;span style="color:#a6e22e">AutoMigrate&lt;/span>(&lt;span style="color:#f92672">&amp;amp;&lt;/span>&lt;span style="color:#a6e22e">ProductGorm&lt;/span>{})
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#f92672">&amp;amp;&lt;/span>&lt;span style="color:#a6e22e">Repository&lt;/span>[&lt;span style="color:#a6e22e">ProductGorm&lt;/span>]{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">db&lt;/span>: &lt;span style="color:#a6e22e">db&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">func&lt;/span> &lt;span style="color:#a6e22e">NewUserRepository&lt;/span>(&lt;span style="color:#a6e22e">db&lt;/span> &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">gorm&lt;/span>.&lt;span style="color:#a6e22e">DB&lt;/span>) &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">Repository&lt;/span>[&lt;span style="color:#a6e22e">UserGorm&lt;/span>] {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">db&lt;/span>.&lt;span style="color:#a6e22e">AutoMigrate&lt;/span>(&lt;span style="color:#f92672">&amp;amp;&lt;/span>&lt;span style="color:#a6e22e">UserGorm&lt;/span>{})
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#f92672">&amp;amp;&lt;/span>&lt;span style="color:#a6e22e">Repository&lt;/span>[&lt;span style="color:#a6e22e">UserGorm&lt;/span>]{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">db&lt;/span>: &lt;span style="color:#a6e22e">db&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">func&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">db&lt;/span>, &lt;span style="color:#a6e22e">err&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">gorm&lt;/span>.&lt;span style="color:#a6e22e">Open&lt;/span>(&lt;span style="color:#a6e22e">sqlite&lt;/span>.&lt;span style="color:#a6e22e">Open&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;test.db&amp;#34;&lt;/span>), &lt;span style="color:#f92672">&amp;amp;&lt;/span>&lt;span style="color:#a6e22e">gorm&lt;/span>.&lt;span style="color:#a6e22e">Config&lt;/span>{})
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> &lt;span style="color:#a6e22e">err&lt;/span> &lt;span style="color:#f92672">!=&lt;/span> &lt;span style="color:#66d9ef">nil&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> panic(&lt;span style="color:#e6db74">&amp;#34;failed to connect database&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">productRepo&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">NewProductRepository&lt;/span>(&lt;span style="color:#a6e22e">db&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">productRepo&lt;/span>.&lt;span style="color:#a6e22e">Create&lt;/span>(&lt;span style="color:#a6e22e">ProductGorm&lt;/span>{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">Name&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;product&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">Price&lt;/span>: &lt;span style="color:#ae81ff">100&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> })
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">fmt&lt;/span>.&lt;span style="color:#a6e22e">Println&lt;/span>(&lt;span style="color:#a6e22e">productRepo&lt;/span>.&lt;span style="color:#a6e22e">Get&lt;/span>(&lt;span style="color:#ae81ff">1&lt;/span>))
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">userRepo&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">NewUserRepository&lt;/span>(&lt;span style="color:#a6e22e">db&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">userRepo&lt;/span>.&lt;span style="color:#a6e22e">Create&lt;/span>(&lt;span style="color:#a6e22e">UserGorm&lt;/span>{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">FirstName&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;first&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">LastName&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;last&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> })
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">fmt&lt;/span>.&lt;span style="color:#a6e22e">Println&lt;/span>(&lt;span style="color:#a6e22e">userRepo&lt;/span>.&lt;span style="color:#a6e22e">Get&lt;/span>(&lt;span style="color:#ae81ff">1&lt;/span>))
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">//
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">//
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// Out:
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// &amp;amp;{{1 2021-11-23 22:50:14.595342 +0100 +0100 2021-11-23 22:50:14.595342 +0100 +0100 {0001-01-01 00:00:00 +0000 UTC false}} 100} &amp;lt;nil&amp;gt;
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// &amp;amp;{{1 2021-11-23 22:50:44.802705 +0100 +0100 2021-11-23 22:50:44.802705 +0100
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div></description></item><item><title>Docs: Go 标准库</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/2.%E7%BC%96%E7%A8%8B/%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/go/go-%E6%A0%87%E5%87%86%E5%BA%93/go-%E6%A0%87%E5%87%86%E5%BA%93/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/2.%E7%BC%96%E7%A8%8B/%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/go/go-%E6%A0%87%E5%87%86%E5%BA%93/go-%E6%A0%87%E5%87%86%E5%BA%93/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://github.com/DesistDaydream/go-learning">GitHub,DesistDaydream/go-learning&lt;/a>(学习代码)&lt;/li>
&lt;li>&lt;a href="https://pkg.go.dev/std">Go 包，标准库&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://studygolang.com/pkgdoc">中文文档&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://go.dev/tour/list">go.dev,Tour(Go 语言之旅，通过在线解析器体验 Go 语言的各种特性)&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>&lt;strong>Go Standard Library(Go 标准库)&lt;/strong> 也可以称为 &lt;strong>Package(包)&lt;/strong>，每个 package 都可以实现一类功能。&lt;/p>
&lt;p>&lt;a href="https://pkg.go.dev/std">Standard Library(标准库)&lt;/a> 就是 Go 语言 中的 package。每个 package 里有他们对应的常量、变量、函数、方法等。每个库就是一类功能，比如 bufio 库，这里面就是关于实现读写功能的各种内容；而 fmt 库则是关于实现格式化输入输出等功能。在&lt;a href="https://pkg.go.dev/std?tab=packages">这里&lt;/a>可以看到 go 语言 原生支持的所有标准库。&lt;/p>
&lt;p>与 标准库 相对应的就是 &lt;a href="https://www.teambition.com/project/5f90e312755d8a00446050eb/app/5eba5fba6a92214d420a3219/workspaces/5f90e312c800160016ea22fb/folders/5f9d3b0f4cc5830001c21a7c">第三方库&lt;/a> ，第三方库一般属于由个人开发，实现更多丰富功能的库。在 &lt;a href="https://pkg.go.dev/">Go.dev &lt;/a>可以搜索自己想要使用的所有库。&lt;/p>
&lt;p>&lt;a href="https://pkg.go.dev/">Go.dev&lt;/a> 是 golang.org 的配套网站。 Golang.org 是开源项目和发行版的所在地，而 go.dev 是 Go 用户的中心，可从整个 Go 生态系统中提供集中和精选的资源。&lt;/p>
&lt;p>Go.dev 提供：&lt;/p>
&lt;ul>
&lt;li>在 index.golang.org 上发布的 Go 软件包和模块的集中信息。&lt;/li>
&lt;li>基本学习资源&lt;/li>
&lt;li>关键用例和案例研究&lt;/li>
&lt;/ul>
&lt;p>Go.dev 当前处于 MVP 状态。我们为自己的建设感到自豪，并很高兴与社区分享。我们希望您能在使用 go.dev 的过程中找到价值和乐趣。 Go.dev 只有一小部分我们打算构建的功能，我们正在积极寻求反馈。如果您有任何想法，建议或问题，请告诉我们.&lt;/p></description></item><item><title>Docs: Goroutines 与 Channels</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/2.%E7%BC%96%E7%A8%8B/%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/go/go-%E6%A0%87%E5%87%86%E5%BA%93/goroutines-%E4%B8%8E-channels/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/2.%E7%BC%96%E7%A8%8B/%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/go/go-%E6%A0%87%E5%87%86%E5%BA%93/goroutines-%E4%B8%8E-channels/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考:&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://mp.weixin.qq.com/s/67XCr7nc_q3gHu6MMO606A">公众号,马哥 Linux 运维-golang channel 使用总结&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://mp.weixin.qq.com/s/CJ9renN4ho7sasGhYSWBqw">公众号，田飞雨-Golang GPM 模型剖析&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;h1 id="go-语言的并发">Go 语言的并发&lt;/h1>
&lt;p>&lt;strong>不要通过共享来通信，而要通过通信来共享。&lt;/strong>&lt;/p>
&lt;p>通过 &lt;code>Goroutines(协程)&lt;/code> 与 &lt;code>Channels(通道)&lt;/code> 实现 &lt;code>并发编程&lt;/code>&lt;/p>
&lt;p>&lt;strong>并发&lt;/strong>与&lt;strong>并行&lt;/strong>的区别&lt;/p>
&lt;ul>
&lt;li>&lt;strong>Concurrency(并发)&lt;/strong> # 一个处理器或者内核上，一个并发程序可以使用多个线程来&lt;strong>交替运行&lt;/strong>。反义词为顺序
&lt;ul>
&lt;li>实际例子：你有一张嘴，电话来了，你停了下来接了电话，吃一口说一句话，直到说完话并且吃完饭，这是并发&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>Parallelism(并行)&lt;/strong> # 多个处理器或者多核上，一个程序在某个时间、在多个处理器上&lt;strong>同时运行&lt;/strong>。反义词为串行
&lt;ul>
&lt;li>实际例子：你有两张嘴，电话来了，你一边打电话一边吃饭，直到说完话并且吃完饭，这是并行&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>并行是并发的真子集。并发不全是并行，但并行一定并发。(单核并发不并行，多核并行也属于并发)，除非该程序无法使用多线程执行任务。&lt;/p>
&lt;p>并行不一定会加快运行速度，因为并行运行的组件之间可能需要相互通信。比如运行在两个 CPU 上的两个组件之间需要互相通信。并发系统上，这种通信开销很小。但在多核的并行系统上，组件间的通信开销就很高了。所以，并行不一定会加快运行速度！&lt;/p>
&lt;p>一个程序是运行在机器上的一个进程，进程是一个运行在自己内存空间里的独立执行体。一个进程由一个或多个操作系统线程组成，这些线程其实是共享同一个内存地址空间在一起工作的执行体。几乎所有&lt;code>正式&lt;/code>的程序都是多线程的，以便让用户或计算机不必等待，或能够同时服务多个请求(e.g.Web 服务器)，或增加性能和吞吐量。&lt;/p>
&lt;p>不要使用全局变量或共享内存，他们会给代码在并发运算的时候带来危险。&lt;/p>
&lt;h1 id="goroutines协程">Goroutines(协程)&lt;/h1>
&lt;p>处理应用程序&lt;strong>并发&lt;/strong>功能的就是 &lt;code>Goroutines(协程)&lt;/code>&lt;/p>
&lt;p>Go 协程是与其他函数或方法一起并发运行的函数或方法。&lt;/p>
&lt;p>调用函数或者方法时，在前面加上关键字 go，可以让一个新的 Go 协程并发地运行。i.e.有关键字&lt;code>go&lt;/code>的函数或方法，即算协程，可以并发运行。 main()函数算主协程，可以没有&lt;code>go&lt;/code>关键字&lt;/p>
&lt;p>一个基本的协程代码示例：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">package&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">import&lt;/span> (
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#34;fmt&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#34;sync&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#34;time&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">var&lt;/span> &lt;span style="color:#a6e22e">wg&lt;/span> &lt;span style="color:#a6e22e">sync&lt;/span>.&lt;span style="color:#a6e22e">WaitGroup&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">func&lt;/span> &lt;span style="color:#a6e22e">hello&lt;/span>(&lt;span style="color:#a6e22e">m&lt;/span> &lt;span style="color:#66d9ef">string&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> &lt;span style="color:#a6e22e">m&lt;/span> &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#e6db74">&amp;#34;waitgroup&amp;#34;&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 让 WaitGroup 计数器 -1
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">defer&lt;/span> &lt;span style="color:#a6e22e">wg&lt;/span>.&lt;span style="color:#a6e22e">Done&lt;/span>()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">i&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">fmt&lt;/span>.&lt;span style="color:#a6e22e">Printf&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;Hello world goroutine,%v\n&amp;#34;&lt;/span>, &lt;span style="color:#a6e22e">i&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">i&lt;/span> &lt;span style="color:#f92672">+=&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> &lt;span style="color:#a6e22e">i&lt;/span> &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#ae81ff">3&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">func&lt;/span> &lt;span style="color:#a6e22e">timeSleepGotourine&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 调用了 go hello() 之后，程序控制没有等待 hello 协程结束，
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#75715e">// 立即返回到了代码下一行，打印 main function。
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#75715e">// 接着由于没有其他可执行的代码，Go 主协程终止，
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#75715e">// 于是 hello 协程就没有机会运行了。
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">go&lt;/span> &lt;span style="color:#a6e22e">hello&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;timesleep&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 调用了 time 包里的函数 Sleep，该函数会休眠执行它的 Go 协程。
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#75715e">// 在这里，我们使 Go 主协程休眠了 1 秒。因此在主协程终止之前，
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#75715e">// 调用 go hello() 就有足够的时间来执行了。
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#75715e">// 该程序首先打印 Hello world goroutine，等待 1 秒钟之后，接着打印 main function。
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#a6e22e">time&lt;/span>.&lt;span style="color:#a6e22e">Sleep&lt;/span>(&lt;span style="color:#ae81ff">1&lt;/span> &lt;span style="color:#f92672">*&lt;/span> &lt;span style="color:#a6e22e">time&lt;/span>.&lt;span style="color:#a6e22e">Second&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 也可以使用下面的方式让程序在手动按回车才结束。
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#75715e">// fmt.Scanln()
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#a6e22e">fmt&lt;/span>.&lt;span style="color:#a6e22e">Println&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;main function&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">func&lt;/span> &lt;span style="color:#a6e22e">waitGroupGotoutine&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 为 WaitGroup 计数器 +1
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#a6e22e">wg&lt;/span>.&lt;span style="color:#a6e22e">Add&lt;/span>(&lt;span style="color:#ae81ff">1&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">go&lt;/span> &lt;span style="color:#a6e22e">hello&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;waitgroup&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 等待 WaitGroup 计数器归零，归零后，wg.Wait() 释放，并继续执行后面的代码、
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#a6e22e">wg&lt;/span>.&lt;span style="color:#a6e22e">Wait&lt;/span>()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">fmt&lt;/span>.&lt;span style="color:#a6e22e">Println&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;main function&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">func&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 通过睡眠，让 main() 等待协程完成
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#a6e22e">timeSleepGotourine&lt;/span>()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 通过 WaitGroup，让 main() 等待协程完成
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#a6e22e">waitGroupGotoutine&lt;/span>()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h1 id="channels通道">Channels(通道)&lt;/h1>
&lt;p>&lt;code>Channels(通道)&lt;/code>，可以想象成 Goroutines 之间通信的管道。如同管道中的水会从一端流到另一端，通过使用通道，数据也可以从一端发送，在另一端接收。&lt;/p>
&lt;p>如果两个协程需要通信，则必须要给它们同一个通道作为参数才可以。&lt;/p>
&lt;p>基本声明格式：&lt;code>var ChanID chan Type&lt;/code>。声明一个通道，指定这个通道里可以传输的类型是什么&lt;/p>
&lt;p>初始化格式：&lt;code>ChanID = make(chan Type)&lt;/code>。因为 channel 是引用类型，所以可以使用 make()函数来给它分配内存 channel 的操作符：&lt;code>&amp;lt;-&lt;/code>。这个操作符表示数据按照箭头的方向流动。下面有几个例子：&lt;/p>
&lt;ul>
&lt;li>&lt;code>ch &amp;lt;- int1&lt;/code>。流向通道(发送)。表示发送变量 int1 的数据到通道 ch 中。i.e.int1 变量中的数据会发送给通道 ch。&lt;/li>
&lt;li>&lt;code>int2 = &amp;lt;- ch&lt;/code>。从通道流出(接收)。表示变量 int2 从通道 ch 中接收数据。i.e.ch 中的数据会发送给 int2&lt;/li>
&lt;li>&lt;code>&amp;lt;- ch&lt;/code>。单独调用通道的值，当前值会被丢弃。&lt;/li>
&lt;/ul>
&lt;p>一个基本的通道代码示例：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">package&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">import&lt;/span> (
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#34;fmt&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">func&lt;/span> &lt;span style="color:#a6e22e">correct&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 使用make函数创建一个新的通道。通道类型就是他们需要传递值的类型
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#a6e22e">messages&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> make(&lt;span style="color:#66d9ef">chan&lt;/span> &lt;span style="color:#66d9ef">string&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 使用`ChannelID &amp;lt;-`语法发送(send)一个新的值到通道中
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">go&lt;/span> &lt;span style="color:#66d9ef">func&lt;/span>() { &lt;span style="color:#a6e22e">messages&lt;/span> &lt;span style="color:#f92672">&amp;lt;-&lt;/span> &lt;span style="color:#e6db74">&amp;#34;ping&amp;#34;&lt;/span> }()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 使用`&amp;lt;- ChannelID`语法从通道中接收(receives)一个值
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#a6e22e">msg&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#f92672">&amp;lt;-&lt;/span>&lt;span style="color:#a6e22e">messages&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">fmt&lt;/span>.&lt;span style="color:#a6e22e">Println&lt;/span>(&lt;span style="color:#a6e22e">msg&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">func&lt;/span> error() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">messages&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> make(&lt;span style="color:#66d9ef">chan&lt;/span> &lt;span style="color:#66d9ef">string&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 如果不使用协程，则运行程序时，会报“死锁”的错,错误信息如下：
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#75715e">// fatal error: all goroutines are asleep - deadlock!
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#75715e">// 因为，代码是一行一行执行的，如果一个没有缓存的通道在接收数据之后，需要同步把数据发送给接收者。
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#75715e">// 可是当前行的代码还没执行完，怎么能执行后面的呢，没有后面的代码，也就没有接收者，所以这就是错误产生的原因。
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#75715e">// 当通道使用协程的方式运行时，就算当前时刻没有接收者，这个通过协程运行起来的通道，一会自动阻塞，并等待接收者。否则不通过协程启动通道，那么就跟普通代码一样。
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">func&lt;/span>() { &lt;span style="color:#a6e22e">messages&lt;/span> &lt;span style="color:#f92672">&amp;lt;-&lt;/span> &lt;span style="color:#e6db74">&amp;#34;ping&amp;#34;&lt;/span> }()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 可以使用如下方式直接输出通道内的数据，相当于fmt.Println就是通道的接收者
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#a6e22e">fmt&lt;/span>.&lt;span style="color:#a6e22e">Println&lt;/span>(&lt;span style="color:#f92672">-&lt;/span>&lt;span style="color:#a6e22e">messages&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">func&lt;/span> &lt;span style="color:#a6e22e">buffer&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">messages&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> make(&lt;span style="color:#66d9ef">chan&lt;/span> &lt;span style="color:#66d9ef">string&lt;/span>, &lt;span style="color:#ae81ff">1&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 带缓冲的通道可以不使用协程。
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#a6e22e">messages&lt;/span> &lt;span style="color:#f92672">&amp;lt;-&lt;/span> &lt;span style="color:#e6db74">&amp;#34;ping&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">fmt&lt;/span>.&lt;span style="color:#a6e22e">Println&lt;/span>(&lt;span style="color:#f92672">-&lt;/span>&lt;span style="color:#a6e22e">messages&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">func&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">fmt&lt;/span>.&lt;span style="color:#a6e22e">Println&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;1.通道正确的示例&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// correct()
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#a6e22e">fmt&lt;/span>.&lt;span style="color:#a6e22e">Println&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;2.通道会导致死锁的示例&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// error()
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#a6e22e">fmt&lt;/span>.&lt;span style="color:#a6e22e">Println&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;3.通道缓冲&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">buffer&lt;/span>()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 默认发送和接收操作是阻塞的，直到发送方和接收方都准备完毕。
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 这个特性允许我们，不使用任何其它的同步操作，来在程序结尾等待消息&amp;#34;ping&amp;#34;
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="通道阻塞">通道阻塞&lt;/h2>
&lt;p>默认情况下，数据通信是同步且无缓冲的，i.e.一边发就需要一边接收，在有接收者接收数据之前，发送不会结束，也不会继续发送新数据，这种情况称为&lt;strong>阻塞&lt;/strong>。必须要有一个接收者准备好接收通道的数据，然后发送者可以直接把数据发送给接收者。或者可以使用带缓冲的通道，这样，在给通道发送数据时，可以把数据先存储在缓冲区，而不用直接让接收者接收。&lt;/p>
&lt;p>对于通道阻塞有非常严格的规定：&lt;/p>
&lt;ul>
&lt;li>对于同一个通道，发送操作（协程或者函数中的），在接收者准备好之前是阻塞的：如果 ch 中的数据无人接收，就无法再给通道传入其他数据：新的输入无法在通道非空的情况下传入。所以发送操作会等待 ch 再次变为可用状态：就是通道值被接收时（可以传入变量）。&lt;/li>
&lt;li>对于同一个通道，接收操作是阻塞的（协程或函数中的），直到发送者可用：如果通道中没有数据，接收者就阻塞了。&lt;/li>
&lt;/ul>
&lt;p>为通道提供数据的也叫&lt;strong>生产者&lt;/strong>，从通道中拿去数据的也叫&lt;strong>消费者&lt;/strong>&lt;/p>
&lt;p>&lt;strong>注意:&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>channel.go 例子中，有通道的错误使用方法，请注意！&lt;/li>
&lt;/ul>
&lt;h2 id="带缓冲的通道">带缓冲的通道&lt;/h2>
&lt;p>格式：&lt;code>ChanID = make(chan Type, CapValue)&lt;/code>。
CapValue 为容量值。如果容量大于 0，通道就是异步的了：缓冲满载（发送）或变空（接收）之前通信不会阻塞，元素会按照发送的顺序被接收。如果容量是 0 或者未设置，通信仅在收发双方准备好的情况下才可以成功。&lt;/p>
&lt;h2 id="单向通道">单向通道&lt;/h2>
&lt;ul>
&lt;li>&lt;code>var VarID chan&amp;lt;- int&lt;/code>。通道仅能发送数据。i.e.关键字：&lt;code>chan&amp;lt;-&lt;/code>&lt;/li>
&lt;li>&lt;code>var VarID &amp;lt;-chan int&lt;/code>。通道仅能接收数据。i.e.关键字：&lt;code>&amp;lt;-chan&lt;/code>&lt;/li>
&lt;/ul>
&lt;p>只接收的通道 &lt;code>&amp;lt;-chan T&lt;/code> 无法关闭，因为关闭通道是发送者用来表示不再给通道发送值了，所以对只接收通道是没有意义的。\&lt;/p>
&lt;h1 id="通道与协程的配合">通道与协程的配合&lt;/h1>
&lt;p>展示了一个通道连通了两个协程，使得数据从一个协程进入通道，再从通道另一端出去到另一个协程的过程&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">package&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">import&lt;/span> (
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#34;fmt&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#34;sync&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// &amp;#34;time&amp;#34;
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">func&lt;/span> &lt;span style="color:#a6e22e">sendData&lt;/span>(&lt;span style="color:#a6e22e">ch&lt;/span> &lt;span style="color:#66d9ef">chan&lt;/span> &lt;span style="color:#66d9ef">string&lt;/span>, &lt;span style="color:#a6e22e">done&lt;/span> &lt;span style="color:#66d9ef">chan&lt;/span> &lt;span style="color:#66d9ef">bool&lt;/span>, &lt;span style="color:#a6e22e">wg&lt;/span> &lt;span style="color:#a6e22e">sync&lt;/span>.&lt;span style="color:#a6e22e">WaitGroup&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 该函数把几个字符串发送给通道ch，使得这些字符串会存在一个管道中，等待输出
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#a6e22e">ch&lt;/span> &lt;span style="color:#f92672">&amp;lt;-&lt;/span> &lt;span style="color:#e6db74">&amp;#34;Tianjin&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">ch&lt;/span> &lt;span style="color:#f92672">&amp;lt;-&lt;/span> &lt;span style="color:#e6db74">&amp;#34;Beijing&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">ch&lt;/span> &lt;span style="color:#f92672">&amp;lt;-&lt;/span> &lt;span style="color:#e6db74">&amp;#34;China&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 当完成数据发送时，发送通知
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#a6e22e">done&lt;/span> &lt;span style="color:#f92672">&amp;lt;-&lt;/span> &lt;span style="color:#66d9ef">true&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 让 WaitGroup 计数器 -1
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#a6e22e">wg&lt;/span>.&lt;span style="color:#a6e22e">Done&lt;/span>()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">func&lt;/span> &lt;span style="color:#a6e22e">recvData&lt;/span>(&lt;span style="color:#a6e22e">ch&lt;/span> &lt;span style="color:#66d9ef">chan&lt;/span> &lt;span style="color:#66d9ef">string&lt;/span>, &lt;span style="color:#a6e22e">done&lt;/span> &lt;span style="color:#66d9ef">chan&lt;/span> &lt;span style="color:#66d9ef">bool&lt;/span>, &lt;span style="color:#a6e22e">wg&lt;/span> &lt;span style="color:#a6e22e">sync&lt;/span>.&lt;span style="color:#a6e22e">WaitGroup&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">I&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">select&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 把通道中的字符串都赋值给变量input
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">case&lt;/span> &lt;span style="color:#a6e22e">input&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#f92672">&amp;lt;-&lt;/span>&lt;span style="color:#a6e22e">ch&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">fmt&lt;/span>.&lt;span style="color:#a6e22e">Println&lt;/span>(&lt;span style="color:#a6e22e">input&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 当通道通知完成数据传输时，跳出循环
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">case&lt;/span> &lt;span style="color:#f92672">&amp;lt;-&lt;/span>&lt;span style="color:#a6e22e">done&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">break&lt;/span> &lt;span style="color:#a6e22e">I&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 让 WaitGroup 计数器 -1
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#a6e22e">wg&lt;/span>.&lt;span style="color:#a6e22e">Done&lt;/span>()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">func&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 声明 WaitGroup 计数器
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#75715e">// WaitGroup 等待一组 goroutine 完成。主 goroutine 调用 Add 来设置要等待的 goroutine 的数量。
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#75715e">// 然后每个 goroutine 运行并在完成时调用 Done。 同时，Wait 可用于阻塞，直到所有 goroutine 完成。
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">var&lt;/span> &lt;span style="color:#a6e22e">wg&lt;/span> &lt;span style="color:#a6e22e">sync&lt;/span>.&lt;span style="color:#a6e22e">WaitGroup&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 为 WaitGroup 计数器 +2，当计数器减为 0 时，wg.Wait() 将会释放，并继续执行后面的代码。
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#a6e22e">wg&lt;/span>.&lt;span style="color:#a6e22e">Add&lt;/span>(&lt;span style="color:#ae81ff">2&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// ch通道用来传递数据；done通道用来传递任务是否完成的消息。
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#a6e22e">ch&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> make(&lt;span style="color:#66d9ef">chan&lt;/span> &lt;span style="color:#66d9ef">string&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">done&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> make(&lt;span style="color:#66d9ef">chan&lt;/span> &lt;span style="color:#66d9ef">bool&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 把通道ch作为参数传递给两个协程函数
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#75715e">// 可以理解为把通道的两端分别连接到两个协程函数上
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">go&lt;/span> &lt;span style="color:#a6e22e">sendData&lt;/span>(&lt;span style="color:#a6e22e">ch&lt;/span>, &lt;span style="color:#a6e22e">done&lt;/span>, &lt;span style="color:#a6e22e">wg&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">go&lt;/span> &lt;span style="color:#a6e22e">recvData&lt;/span>(&lt;span style="color:#a6e22e">ch&lt;/span>, &lt;span style="color:#a6e22e">done&lt;/span>, &lt;span style="color:#a6e22e">wg&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 通过 wg.Wait() 让 main() 等待协程完成。
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#75715e">// 如果不让 main() 等待，则无任何输出，或者报错 panic: send on closed channel。因为协程是并发运行，不用等代码运行完成就会执行后续代码。
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#75715e">// 如果后续代码执行完了，协程中的代码还没执行完成，就会没有任何输出。
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#75715e">// 如果后续代码中包含了关闭通道的操作，那么程序将会 panic，并报错 send on closed channel
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#a6e22e">wg&lt;/span>.&lt;span style="color:#a6e22e">Wait&lt;/span>()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>比如聊天室功能中俩人聊天，两个 goroutine 就是两人的聊天窗口，channel 就是连接两人的管道，直到一个人向 channel 发送消息前，channel 都是阻塞的，当发送消息后，消息就会从 channel 的另一头流出，让另一个人收到。&lt;/p></description></item><item><title>Docs: Goroutines 与 Channels</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/2.%E7%BC%96%E7%A8%8B/%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/go/go-%E6%A0%87%E5%87%86%E5%BA%93/goroutines-%E4%B8%8E-channels/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/2.%E7%BC%96%E7%A8%8B/%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/go/go-%E6%A0%87%E5%87%86%E5%BA%93/goroutines-%E4%B8%8E-channels/</guid><description/></item><item><title>Docs: I_O</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/2.%E7%BC%96%E7%A8%8B/%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/go/go-%E6%A0%87%E5%87%86%E5%BA%93/i_o/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/2.%E7%BC%96%E7%A8%8B/%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/go/go-%E6%A0%87%E5%87%86%E5%BA%93/i_o/</guid><description/></item><item><title>Docs: I/O</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/2.%E7%BC%96%E7%A8%8B/%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/go/go-%E6%A0%87%E5%87%86%E5%BA%93/i_o/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/2.%E7%BC%96%E7%A8%8B/%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/go/go-%E6%A0%87%E5%87%86%E5%BA%93/i_o/</guid><description>
&lt;p>Go写文件的几种姿势，你喜欢哪一种？&lt;a href="https://mp.weixin.qq.com/s/56g5k17Zt4iytbWkYcouig">https://mp.weixin.qq.com/s/56g5k17Zt4iytbWkYcouig&lt;/a>&lt;/p></description></item><item><title>Docs: Maps(映射) 与 Struct(结构体)</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/2.%E7%BC%96%E7%A8%8B/%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/go/go-%E6%A0%87%E5%87%86%E5%BA%93/maps%E6%98%A0%E5%B0%84-%E4%B8%8E-struct%E7%BB%93%E6%9E%84%E4%BD%93/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/2.%E7%BC%96%E7%A8%8B/%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/go/go-%E6%A0%87%E5%87%86%E5%BA%93/maps%E6%98%A0%E5%B0%84-%E4%B8%8E-struct%E7%BB%93%E6%9E%84%E4%BD%93/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://go.dev/ref/spec#Map_types">官方文档，参考-规范-Map 类型&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://go.dev/ref/spec#Struct_types">官方文档，参考-规范-Struct 类型&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;h1 id="maps映射">Maps(映射)&lt;/h1>
&lt;p>map 是 &lt;strong>key-value pairs(键值对)&lt;/strong> 的无序集合。这种结构也称 &lt;strong>关联数组&lt;/strong>(associative array)、&lt;strong>字典&lt;/strong>(dictionary)、&lt;strong>散列表/哈希表&lt;/strong>(hash table)。这是一种快速寻找值的理想结构：给定 Key，对应的 Value 可以迅速定位。&lt;/p>
&lt;h2 id="map-的声明">map 的声明&lt;/h2>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">var&lt;/span> &lt;span style="color:#a6e22e">MapID&lt;/span> &lt;span style="color:#66d9ef">map&lt;/span>[&lt;span style="color:#a6e22e">KeyType&lt;/span>]&lt;span style="color:#a6e22e">ValueType&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="map-的实例化">map 的实例化&lt;/h2>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">MapID&lt;/span> = make(&lt;span style="color:#66d9ef">map&lt;/span>[&lt;span style="color:#a6e22e">KeyType&lt;/span>]&lt;span style="color:#a6e22e">ValueType&lt;/span>)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="赋值">赋值&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">MapID&lt;/span>[&lt;span style="color:#a6e22e">KEY&lt;/span>] = &lt;span style="color:#a6e22e">VAL&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="实例化的同时进行赋值">实例化的同时进行赋值&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">MapID&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#66d9ef">map&lt;/span>[&lt;span style="color:#a6e22e">KeyType&lt;/span>]&lt;span style="color:#a6e22e">ValType&lt;/span>{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">KEY_1&lt;/span>:&lt;span style="color:#a6e22e">VAL_1&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">KEY_2&lt;/span>:&lt;span style="color:#a6e22e">VAL_2&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">...&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">KEY_n&lt;/span>:&lt;span style="color:#a6e22e">VAL_n&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>这相当于：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">MapID&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> make(&lt;span style="color:#66d9ef">map&lt;/span>[&lt;span style="color:#a6e22e">KeyType&lt;/span>]&lt;span style="color:#a6e22e">ValueType&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">MapID&lt;/span>[&lt;span style="color:#e6db74">&amp;#34;KEY_1&amp;#34;&lt;/span>] = &lt;span style="color:#e6db74">&amp;#34;VALUE_1&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">MapID&lt;/span>[&lt;span style="color:#e6db74">&amp;#34;KEY_2&amp;#34;&lt;/span>] = &lt;span style="color:#e6db74">&amp;#34;VALUE_2&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="map-的引用">map 的引用&lt;/h2>
&lt;p>下面是引用 map 中指定 KEY 的 VALUE 的方法：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">MapID&lt;/span>[&lt;span style="color:#a6e22e">KEY&lt;/span>]
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="引用-map-的长度">引用 map 的长度&lt;/h3>
&lt;p>map 的长度指的是键值对的个数，有几个键值对，长度就是几&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>len(&lt;span style="color:#a6e22e">MapID&lt;/span>)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>引用 map 中某个 Key 的 Value&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">MapID&lt;/span>[&lt;span style="color:#e6db74">&amp;#34;KEY&amp;#34;&lt;/span>]
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="keyvalue-的删除">Key/Value 的删除&lt;/h2>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">MapID&lt;/span>[&lt;span style="color:#e6db74">&amp;#34;KEY&amp;#34;&lt;/span>]
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>删除 MapID 这个 map 的 KEY 以及对应的 VAL&lt;/p>
&lt;h1 id="struct结构体">Struct(结构体)&lt;/h1>
&lt;p>&lt;strong>Struct(结构体)&lt;/strong> 是一种&lt;strong>复合数据类型&lt;/strong>，当需要一个 自定义 Type，且这个 Type 由一系列的 &lt;strong>Fields(字段，有的地方也称为属性)&lt;/strong> 组成，每个字段通常都包含 &lt;strong>名称&lt;/strong> 和 &lt;strong>类型&lt;/strong>。Struct 把数据聚集在一起，然后访问这些数据的时候，好像这些数据是一个独立实体的一部分。Struct 也是值类型，可以通过 &lt;code>* new()&lt;/code> 函数创建。&lt;/p>
&lt;p>组成结构体的属性分两部分：&lt;/p>
&lt;ul>
&lt;li>&lt;strong>FieldName(字段名称)&lt;/strong> # 字段的名称&lt;/li>
&lt;li>&lt;strong>BaseType(基础类型)&lt;/strong> # 基础类型可以是另一个结构体,表示该结构体包含另一个结构体&lt;/li>
&lt;/ul>
&lt;p>每个字段都有其对应的基础数据类型，在一个结构体中，FIELD 名字必须是唯一的。代码示例：struct.go&lt;/p>
&lt;h2 id="struct-的定义">Struct 的定义&lt;/h2>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">type&lt;/span> &lt;span style="color:#a6e22e">StructID&lt;/span> &lt;span style="color:#66d9ef">struct&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">Name1&lt;/span> &lt;span style="color:#a6e22e">BaseType1&lt;/span> [&lt;span style="color:#e6db74">&amp;#34;TAG&amp;#34;&lt;/span>]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">Name2&lt;/span> &lt;span style="color:#a6e22e">BaseType2&lt;/span> [&lt;span style="color:#e6db74">`TAG`&lt;/span>]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">...&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 也可以使用简单的方法定义一个结构体:
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 这个结构体中，两个属性的类型都是 int
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">type&lt;/span> &lt;span style="color:#a6e22e">T&lt;/span> &lt;span style="color:#66d9ef">struct&lt;/span> {&lt;span style="color:#a6e22e">a&lt;/span>, &lt;span style="color:#a6e22e">b&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="struct-的声明">Struct 的声明&lt;/h2>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">var&lt;/span> &lt;span style="color:#a6e22e">StructVarID&lt;/span> &lt;span style="color:#a6e22e">StructID&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="struct-的实例化">Struct 的实例化&lt;/h2>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">StructVarID&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> new(&lt;span style="color:#a6e22e">StructID&lt;/span>)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="struct-的引用">Struct 的引用&lt;/h2>
&lt;p>&lt;strong>结构体中属性的引用&lt;/strong>
结构体名，中间跟一个点，再接该结构体内的字段名。即可引用该结构体中的某个字段&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">StrcutID&lt;/span>.&lt;span style="color:#a6e22e">FIELD1&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>在 Go 语言中，这个 &lt;code>.&lt;/code> 点符号叫做 &lt;strong>Selector(选择器)&lt;/strong>。无论定义的变量是一个结构体类型还是一个结构体类型指针，都是用同样的 **selector-notation(选择器符) **来引用结构体的字段。&lt;/p>
&lt;h2 id="tag">TAG&lt;/h2>
&lt;p>除了 FIeld 和 BaseType 之外，还可以给该属性添加 &lt;strong>TAG(标签)&lt;/strong>，TAG 使用 &lt;code>双引号&lt;/code> 或者 &lt;code>重音号&lt;/code> 来表示。这些 TAG 能被用来做文档或者重要的标签(比如在使用 JSON、YAML 等解析时，这些解析库会读取 TAG 中的内容，将结构体中的每个属性对应到 json 或 yaml 的字段上)。&lt;/p>
&lt;p>TAG 里面的内容在正常编程中没有作用。一般在 &lt;strong>Reflect(反射)&lt;/strong>、某些第三方库(比如 gin 的数据绑定功能)、等等地方可以起到关键的作用。Strcut 中的 Tag 在通常的编程中无法使用，&lt;strong>只有 reflect 包中的方法可以获取这些 Tag 的信息&lt;/strong>。&lt;/p>
&lt;h2 id="struct-常见用法">Struct 常见用法&lt;/h2>
&lt;p>在日常使用中，我们常常自己定义一个 函数，用于初始化一个接口体&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">func&lt;/span> &lt;span style="color:#a6e22e">NewStructID&lt;/span>() &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">StructID&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#f92672">&amp;amp;&lt;/span>&lt;span style="color:#a6e22e">StructID&lt;/span>(
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">FIELED1&lt;/span>: &lt;span style="color:#a6e22e">XXXX&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">FIELED2&lt;/span>: &lt;span style="color:#a6e22e">XXXX&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">......&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> )
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>然后直接调用该方法即可，使用方式其实与 new() 函数一样&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">func&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">StructVar&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">NewStructID&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="将一个结构体中的值拷贝到另一个相似的结构体中">将一个结构体中的值拷贝到另一个相似的结构体中&lt;/h2>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://github.com/jinzhu/copier">GitHub 项目，jinzhu/copier&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.zhihu.com/question/449267385">知乎，Golang 如何优雅得转换两个相似的结构体&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>使用 jinzhu/copier 项目即可轻松得将一个结构体中的值复制到另一个结构体中&lt;/p></description></item><item><title>Docs: Method(方法)、Interface(接口)</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/2.%E7%BC%96%E7%A8%8B/%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/go/go-%E6%A0%87%E5%87%86%E5%BA%93/method%E6%96%B9%E6%B3%95interface%E6%8E%A5%E5%8F%A3/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/2.%E7%BC%96%E7%A8%8B/%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/go/go-%E6%A0%87%E5%87%86%E5%BA%93/method%E6%96%B9%E6%B3%95interface%E6%8E%A5%E5%8F%A3/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://mp.weixin.qq.com/s/gpMzEoRofGE9LmayeYw1qw">公众号-新亮笔记，回答连个被频繁问道的代码写法问题&lt;/a>
&lt;ul>
&lt;li>1.强制检查类型是否实现接口&lt;/li>
&lt;li>2.强制接口中所有方法只能在本包中实现&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>Method 与 Interface 是 Go 语言是想面向对象变成的一种解决方式，但是更轻量。&lt;/p>
&lt;p>&lt;strong>Go 是面向对象的编程语言吗？&lt;/strong>
官方 FAQ 给出了标准答案: Yes and No。&lt;/p>
&lt;p>当然，Go 有面向对象编程的类型和方法的概念，但是它没有继承(hierarchy)一说。Go 语言的接口实现和其它的编程语言不一样，Go 开发者的初衷就是保证它易于使用，用途更广泛。&lt;/p>
&lt;p>还有一种“模拟”产生子类的方法，拿就是通过在类型中嵌入其它的类型，但是这是一种“组合”的方式，而不是继承。&lt;/p>
&lt;p>没有了继承， Go 语言的对象变得比 C++和 Java 中更轻量级。&lt;/p>
&lt;p>在 Go 语言中，接口定义了一套方法的集合，任何实现这些方法的对象都可以被认为实现了这个接口，这也称作 Duck Type。这不像其它语言比如 java 需要预先声明类型实现了某个或者某些接口，这使得 Go 接口和类型变得很轻量级，它解耦了接口和具体实现的硬绑定。显然这是 Go 的开发者深思熟虑的一个决定。&lt;/p>
&lt;blockquote>
&lt;p>if something looks like a duck, swims like a duck and quacks like a duck then it’s probably a duck.&lt;/p>
&lt;/blockquote>
&lt;p>因为没有继承，你也只能通过 Go 接口实现面向对象编程的多态。本身 Go 接口在内部实现上也是一个(其实是两种,其中一种专门处理 &lt;code>interface{}&lt;/code>)结构体，它的虚函数指向具体的类型的实现。在编译代码的时候，Go 编译器还会做优化，不需要接口的时候，它会使用具体的方法来代替接口使用，这样进一步优化性能，这叫做 devirtualize 调用。&lt;/p>
&lt;h1 id="methods-方法">Methods 方法&lt;/h1>
&lt;p>&lt;strong>Method(方法)&lt;/strong> 是一种特殊类型的 &lt;strong>Function(函数)&lt;/strong>。是作用在 &lt;strong>Receiver(接收者)&lt;/strong> 上的一个函数，&lt;code>接收者&lt;/code>是某种类型的&lt;strong>变量&lt;/strong>。接收者不能是一个接口类型；也不能是一个指针类型，但是可以使任何其他允许类型的指针。&lt;/p>
&lt;blockquote>
&lt;p>在日常描述中，称为作用在 XX 类型上的方法&lt;/p>
&lt;/blockquote>
&lt;p>&lt;strong>方法的声明&lt;/strong>：&lt;code>func (RecvID RecvType) MethodID(ParameterList) (ReturnValueList) {...}&lt;/code>。&lt;/p>
&lt;ul>
&lt;li>RecvID # Receiver(接受者) 的标识符，即：Recv 类型的&lt;strong>变量&lt;/strong>。如果 Method 不需要 Recv 的值，可以用 &lt;code>_&lt;/code> 代替 RecvID。定义方法就是用类型来定义其方法&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>方法的调用&lt;/strong>：&lt;code>RecvID.MethodID()&lt;/code>。i.e.调用某个类型上的方法。因为方法是作用在类型上的，所以不用初始化，直接调用即可。&lt;/p>
&lt;h2 id="方法与结构体的关系">方法与结构体的关系&lt;/h2>
&lt;p>比如：有一个矩形的结构体，里面有两个属性，长和宽；如果想让整个矩形得出面积，需要一个方法，这个求面积的方法可以给矩形发消息，告诉矩形这是你求面积的方法；这时候这个矩形就可以拿着这个方法，自己算出自己的面积&lt;/p>
&lt;p>用白话说：其实一个结构体就是一个对象，这个对象有很多很多的属性，想要根据这个对象的属性来得出某些结果，就可以将这个对象作用在某个方法上，这个方法就可以根据这个对象的某些属性进行计算来得出结果。再举一个例子，有一个人有多种属性(身高，体重，性别，腰围)；根据这些属性，可以创建一个计算体型的方法，这个方法根据这些属性中的 1 个或者多个计算出结果是偏瘦、偏胖还是适中。&lt;/p>
&lt;h2 id="总结">总结&lt;/h2>
&lt;p>Go 的 Methods 就是面向对象编程的基础，Go 语言中并没有一个所谓的 “类”(也就是建模中的模板)，Go 所有被方法作用的接收者都可以称之为“对象”，所以，想要声明一个“模板”，只需要声明一个类型即可，这个类型可以是 int、string、struct(虽然~真正处理需求的时候，大部分情况下都是用 struct 作为“模板”~~o(∩_∩)o)，只要为这个类型声明了其所拥有的方法，这个类型就可以称之为“模板”。&lt;/p>
&lt;h1 id="interfaces-接口">Interfaces 接口&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://www.zhihu.com/question/318138275">知乎《如何理解 Golang 中的接口》&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://mp.weixin.qq.com/s/EbxkBokYBajkCR-MazL0ZA">公众号-码农桃花源，深度解密 Go 语言之关于 interface 的 10 个问题&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;blockquote>
&lt;p>本文的总结部分，将会根据实际案例，列举，并总结一些&lt;strong>编程思想&lt;/strong>&lt;/p>
&lt;/blockquote>
&lt;p>首先，&lt;strong>Interface(接口) 是一种类型。更准确地说，Interface(接口)&lt;/strong> 是仅包含方法名、参数、返回值的未具体实现的&lt;strong>一组方法的集合&lt;/strong>。当一个类型定义了接口中所有的方法(注意：是所有方法)，就称这个类型 &lt;strong>implements(实现了)&lt;/strong> 该接口，这个类型就称为这个接口的 &lt;strong>implementator(实现者)&lt;/strong>。&lt;/p>
&lt;p>接口定义了一个类型应该具有的方法，并由该类型决定如何实现这些方法。接口里不能包含变量。代码示例：&lt;a href="https://www.yuque.com/go/doc/33219875">interface.go&lt;/a>
接口也可以算自定义类型的一种，使用关键字 &lt;code>type&lt;/code> 与 &lt;code>interface&lt;/code> 来定义，所以可以对接口赋值，并且接口可以动态改变其自身的类型，只要某个类型实现了该接口，该接口类型在使用这个类型的时候，就会变成这个类型，这称为接口的**多态性。**再深入一点的描述详见代码中的注释部分&lt;/p>
&lt;p>&lt;strong>接口的定义&lt;/strong>：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">type&lt;/span> &lt;span style="color:#a6e22e">InterfaceID&lt;/span> &lt;span style="color:#66d9ef">interface&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">Method1&lt;/span>(&lt;span style="color:#a6e22e">ParameterList&lt;/span>) &lt;span style="color:#a6e22e">ReturnType&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">Method2&lt;/span>(&lt;span style="color:#a6e22e">ParameterList&lt;/span>) &lt;span style="color:#a6e22e">ReturnType&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">...&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;strong>接口变量的声明&lt;/strong>：&lt;code>var InterfaceVarID InterfaceID&lt;/code>。接口可以有值，&lt;code>InterfaceVarID&lt;/code>是一个 multiword(多字)。数字结构，值为 nil。本质上是一个指针，但又不完全是一回事。&lt;/p>
&lt;p>&lt;strong>接口的赋值&lt;/strong>：&lt;code>InterfaceVarID=TypeVarID&lt;/code>。使用类型变量对接口变量进行赋值(i.e.接口变量包含一个指向类型变量的引用)。&lt;/p>
&lt;p>其实，对接口所谓的赋值，并不是真正的值(不像&lt;code>a=2,b=&amp;quot;sting&amp;quot;&lt;/code>这类)，这里面所赋的值，其实是一个类型。与其说 &lt;code>赋值&lt;/code>，不如叫&lt;code> 赋类型&lt;/code>。当接口变量具有一个类型时，接口变量的值就是这个类型所声明的变量的值&lt;/p>
&lt;p>&lt;strong>接口的引用&lt;/strong>：&lt;code>InterfaceVarID.MethodID()&lt;/code>。&lt;/p>
&lt;blockquote>
&lt;p>这里的引用实际上引用接口内的方法，但是，光引用一个接口是没有什么太大意义的。不给接口变量赋值的话，引用时将会报错如下内容
panic: runtime error: invalid memory address or nil pointer dereference&lt;/p>
&lt;/blockquote>
&lt;p>只有为接口变量赋值，通过赋值，将接口转换为对应的类型，这时，再引用接口上的方法，其实就是引用对应类型上的方法。这种方式使此方法更具有一般性。接口变量里包含了接收者实例的值和指向对应方法表的指针。&lt;/p>
&lt;p>接口的特性：&lt;/p>
&lt;ul>
&lt;li>指向接口值的 **指针 **是 **非法 **的，不仅一点用没有，还会导致代码错误。说白了就是使用接口时不要带 &lt;code>*&lt;/code> 符号&lt;/li>
&lt;li>&lt;strong>接口=某个类型、某个类型=接口&lt;/strong>。当某个类型实现了一个接口，就可以像加粗字那么描述。
&lt;ul>
&lt;li>因为下面这个代码可以看到，&lt;code>DoDuck()&lt;/code> 的形参是接口类型，但是 &lt;code>main()&lt;/code> 中调用 &lt;code>DoDuck()&lt;/code> 的时候，是可以传递一个 &lt;code>Chicken&lt;/code> 这个结构体类型。所以，当一个类型实现一个接口时，这个类型=接口。并且，&lt;code>d.Quack()&lt;/code> 实际上是执行的 &lt;code>c.Qucak()&lt;/code>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">type&lt;/span> &lt;span style="color:#a6e22e">Duck&lt;/span> &lt;span style="color:#66d9ef">interface&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">Quack&lt;/span>()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">func&lt;/span> &lt;span style="color:#a6e22e">DoDuck&lt;/span>(&lt;span style="color:#a6e22e">d&lt;/span> &lt;span style="color:#a6e22e">Duck&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">d&lt;/span>.&lt;span style="color:#a6e22e">Quack&lt;/span>()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">type&lt;/span> &lt;span style="color:#a6e22e">Chicken&lt;/span> &lt;span style="color:#66d9ef">struct&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">func&lt;/span> (&lt;span style="color:#a6e22e">c&lt;/span> &lt;span style="color:#a6e22e">Chicken&lt;/span>) &lt;span style="color:#a6e22e">Quack&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">fmt&lt;/span>.&lt;span style="color:#a6e22e">Println&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;嘎嘎&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">func&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">c&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">Chicken&lt;/span>{}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">DoDuck&lt;/span>(&lt;span style="color:#a6e22e">c&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ul>
&lt;li>当某个类型(比如 struct、slice 等)实现了接口方法集中的方法，每一个方法的实现说明了此方法是如何作用于该类型的。i.e.**Implement Interface(实现接口)。**同时方法集也构成了该类型的接口。实现了 InterfaceID 接口类型的变量可以赋值给 VarID(接收者值)，此时方法表中的指针会指向被实现的接口方法。如果另一个类型(也实现了该接口)的变量被赋值给 VarID，这两者(指针和方法实现)也会随之改变。&lt;/li>
&lt;li>多个类型可以实现同一个接口，所以类型不用显式得声明其实现了哪一个接口，所以接口会被隐式得实现。i.e.接口里只需要看到方法是什么，不用关心方法作用在哪个类型上。&lt;/li>
&lt;li>一个类型可以实现多个接口&lt;/li>
&lt;li>实现某个接口的类型可以有其他办法&lt;/li>
&lt;li>有的时候，也会以一种稍微不同的方式来使用接口这个词：从类型的角度来看，它的接口指的是：它的所有导出方法，只不过没有显式地为这些导出方法额外定一个接口而已。&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>接口嵌套接口&lt;/strong>
一个接口可以包含一个或多个其他的接口，这相当于直接将这些内嵌接口的方法列举在外层接口中一样。
比如下面的例子接口&lt;code>File&lt;/code>包含了&lt;code>ReadWrite&lt;/code>和&lt;code>Lock&lt;/code>的所有方法，它还额外有一个&lt;code>Close()&lt;/code>方法。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">type&lt;/span> &lt;span style="color:#a6e22e">ReadWrite&lt;/span> &lt;span style="color:#66d9ef">interface&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">Read&lt;/span>(&lt;span style="color:#a6e22e">b&lt;/span> &lt;span style="color:#a6e22e">Buffer&lt;/span>) &lt;span style="color:#66d9ef">bool&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">Write&lt;/span>(&lt;span style="color:#a6e22e">b&lt;/span> &lt;span style="color:#a6e22e">Buffer&lt;/span>) &lt;span style="color:#66d9ef">bool&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">type&lt;/span> &lt;span style="color:#a6e22e">Lock&lt;/span> &lt;span style="color:#66d9ef">interface&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">Lock&lt;/span>()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">Unlock&lt;/span>()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">type&lt;/span> &lt;span style="color:#a6e22e">File&lt;/span> &lt;span style="color:#66d9ef">interface&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">ReadWrite&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">Lock&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">Close&lt;/span>()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="空接口">&lt;strong>空接口&lt;/strong>&lt;/h2>
&lt;p>空接口或者最小接口不包含任何方法，它对实现不做任何要求&lt;/p>
&lt;p>定义格式：&lt;code>type InterfaceID interface {}&lt;/code>&lt;/p>
&lt;p>可以给一个空接口类型的变量赋任何类型的值&lt;/p>
&lt;p>如果一个 interface 中如果没有定义任何方法，即为空 interface，表示为 interface{}。如此一来，任何类型就都能满足它，这也是为什么当函数参数类型为 interface{} 时，可以给它传任意类型的参数。&lt;/p>
&lt;p>示例代码，如下：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">package&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">import&lt;/span> &lt;span style="color:#e6db74">&amp;#34;fmt&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">func&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">var&lt;/span> &lt;span style="color:#a6e22e">i&lt;/span> &lt;span style="color:#66d9ef">interface&lt;/span>{} = &lt;span style="color:#ae81ff">1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">fmt&lt;/span>.&lt;span style="color:#a6e22e">Println&lt;/span>(&lt;span style="color:#a6e22e">i&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>更常用的场景，Go 的 interface{} 常常会被作为函数的参数传递，用以帮助我们实现其他语言中的泛型效果。Go 中暂时不支持 泛型，不过 Go 2 的方案中似乎将支持泛型。&lt;/p>
&lt;h2 id="接口的-polymorphism多态性">接口的 polymorphism(多态性)&lt;/h2>
&lt;p>代码示例 1：interface_formula.go 其中接口变量的类型可以动态得随着不同的值而变化为对应的类型。&lt;/p>
&lt;p>代码示例 2：interface_salary.go 其中接口变量切片中的元素可以是任意类型；不像普通的切片，所有元素都是同一个类型。&lt;/p>
&lt;h2 id="type-assertion类型断言">Type Assertion(类型断言)&lt;/h2>
&lt;p>&lt;strong>检测和转换接口变量的类型&lt;/strong>&lt;/p>
&lt;p>一个接口类型的变量 &lt;code>InterfaceVar&lt;/code> 中可以包含任何类型的值，必须有一种方式来检测它的动态类型。i.e.运行时在接口变量中存储的值的实际类型。在执行过程中动态类型可能会有所不同，但是它总是可以分配给接口变量本身的类型。通常我们可以使用 **TypeAssertion(类型断言) **来测试在当前执行该语句的时候&lt;code>InterfaceVar&lt;/code>所定义的接口是否是&lt;code>Type&lt;/code>这个类型&lt;/p>
&lt;p>使用格式：&lt;code>v := InterfaceVar.(Type)&lt;/code>&lt;/p>
&lt;p>类型断言可能是无效的，虽然编译器会尽力检查转换是否有效，但是它不可能预见所有的可能性。如果转换在程序运行时失败会导致错误发生。更安全的方式是使用以下形式来进行类型断言：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">if&lt;/span> &lt;span style="color:#a6e22e">v&lt;/span>, &lt;span style="color:#a6e22e">ok&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">InterfaceVar&lt;/span>.(&lt;span style="color:#a6e22e">Type&lt;/span>); &lt;span style="color:#a6e22e">ok&lt;/span> { &lt;span style="color:#75715e">// checked type assertion
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#a6e22e">Process&lt;/span>(&lt;span style="color:#a6e22e">v&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>如果转换合法，则 &lt;code>v&lt;/code> 是 &lt;code>InterfaceVar&lt;/code> 转换到类型 &lt;code>Type&lt;/code> 的值，&lt;code>ok&lt;/code> 会是 &lt;code>true&lt;/code>；否则 &lt;code>v&lt;/code> 是类型 &lt;code>Type&lt;/code> 的零值，&lt;code>ok&lt;/code> 是 &lt;code>false&lt;/code>，也没有运行时错误发生。&lt;/p>
&lt;blockquote>
&lt;p>说白了，就是给 v 赋值&lt;/p>
&lt;/blockquote>
&lt;h2 id="强制检查某类型是否实现了某接口">强制检查某类型是否实现了某接口&lt;/h2>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">var&lt;/span> &lt;span style="color:#a6e22e">_&lt;/span> &lt;span style="color:#a6e22e">Signature&lt;/span> = (&lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">signature&lt;/span>)(&lt;span style="color:#66d9ef">nil&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 或
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">var&lt;/span> &lt;span style="color:#a6e22e">_&lt;/span> &lt;span style="color:#a6e22e">Signature&lt;/span> = &lt;span style="color:#a6e22e">signature&lt;/span>{}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// var 关键字可省略
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>上述两种写法可以让编译器检查 &lt;code>signature&lt;/code> 类型是否实现了 &lt;code>Signature&lt;/code> 接口。
比如：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">package&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">import&lt;/span> &lt;span style="color:#e6db74">&amp;#34;fmt&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">var&lt;/span> &lt;span style="color:#a6e22e">_&lt;/span> &lt;span style="color:#a6e22e">Study&lt;/span> = (&lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">study&lt;/span>)(&lt;span style="color:#66d9ef">nil&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">type&lt;/span> &lt;span style="color:#a6e22e">study&lt;/span> &lt;span style="color:#66d9ef">struct&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">Name&lt;/span> &lt;span style="color:#66d9ef">string&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">type&lt;/span> &lt;span style="color:#a6e22e">Study&lt;/span> &lt;span style="color:#66d9ef">interface&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">Listen&lt;/span>(&lt;span style="color:#a6e22e">message&lt;/span> &lt;span style="color:#66d9ef">string&lt;/span>) &lt;span style="color:#66d9ef">string&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">func&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">fmt&lt;/span>.&lt;span style="color:#a6e22e">Println&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;hello world&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>运行后会抛出异常：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>./main.go:5:5: cannot use &lt;span style="color:#f92672">(&lt;/span>*study&lt;span style="color:#f92672">)(&lt;/span>nil&lt;span style="color:#f92672">)&lt;/span> &lt;span style="color:#f92672">(&lt;/span>type *study&lt;span style="color:#f92672">)&lt;/span> as type Study in assignment:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> *study does not implement Study &lt;span style="color:#f92672">(&lt;/span>missing Listen method&lt;span style="color:#f92672">)&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>只有去掉 &lt;code>var _ Study = (*study)(nil)&lt;/code>才可以正常运行。
在某个类型需要实现接口时，推荐使用这种语法进行判断，以便出现问题时可以快速定位。
在 mysql exporter 中的各种采集器中，大量使用了这种特性&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://github.com/prometheus/mysqld_exporter/blob/main/collector/binlog.go#L142">https://github.com/prometheus/mysqld_exporter/blob/main/collector/binlog.go#L142&lt;/a>&lt;/li>
&lt;/ul>
&lt;h2 id="强制接口中的方法只能在本包中实现">强制接口中的方法只能在本包中实现&lt;/h2>
&lt;p>在接口中定义一个小写字母开头的方法即可
比如：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">package&lt;/span> &lt;span style="color:#a6e22e">study&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">type&lt;/span> &lt;span style="color:#a6e22e">Study&lt;/span> &lt;span style="color:#66d9ef">interface&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">Listen&lt;/span>(&lt;span style="color:#a6e22e">message&lt;/span> &lt;span style="color:#66d9ef">string&lt;/span>) &lt;span style="color:#66d9ef">string&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">i&lt;/span>()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">func&lt;/span> &lt;span style="color:#a6e22e">Speak&lt;/span>(&lt;span style="color:#a6e22e">s&lt;/span> &lt;span style="color:#a6e22e">Study&lt;/span>) &lt;span style="color:#66d9ef">string&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#a6e22e">s&lt;/span>.&lt;span style="color:#a6e22e">Listen&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;abc&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">package&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">type&lt;/span> &lt;span style="color:#a6e22e">stu&lt;/span> &lt;span style="color:#66d9ef">struct&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">Name&lt;/span> &lt;span style="color:#66d9ef">string&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">func&lt;/span> (&lt;span style="color:#a6e22e">s&lt;/span> &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">stu&lt;/span>) &lt;span style="color:#a6e22e">Listen&lt;/span>(&lt;span style="color:#a6e22e">message&lt;/span> &lt;span style="color:#66d9ef">string&lt;/span>) &lt;span style="color:#66d9ef">string&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#a6e22e">s&lt;/span>.&lt;span style="color:#a6e22e">Name&lt;/span> &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#e6db74">&amp;#34; 听 &amp;#34;&lt;/span> &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#a6e22e">message&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">func&lt;/span> (&lt;span style="color:#a6e22e">s&lt;/span> &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">stu&lt;/span>) &lt;span style="color:#a6e22e">i&lt;/span>() {}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">func&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">message&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">study&lt;/span>.&lt;span style="color:#a6e22e">Speak&lt;/span>(new(&lt;span style="color:#a6e22e">stu&lt;/span>))
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">fmt&lt;/span>.&lt;span style="color:#a6e22e">Println&lt;/span>(&lt;span style="color:#a6e22e">message&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>此时运行后将会抛出异常：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>./main.go:19:28: cannot use new&lt;span style="color:#f92672">(&lt;/span>stu&lt;span style="color:#f92672">)&lt;/span> &lt;span style="color:#f92672">(&lt;/span>type *stu&lt;span style="color:#f92672">)&lt;/span> as type study.Study in argument to study.Speak:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> *stu does not implement study.Study &lt;span style="color:#f92672">(&lt;/span>missing study.i method&lt;span style="color:#f92672">)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> have i&lt;span style="color:#f92672">()&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> want study.i&lt;span style="color:#f92672">()&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>只要去掉接口中 &lt;code>i()&lt;/code> 方法即可，或者都改成大写。&lt;/p>
&lt;h1 id="总结-1">总结：&lt;/h1>
&lt;p>结构体、方法、接口，这三者在项目开发中，占有很大的比重，也是一个 go 项目的设计思路。&lt;/p>
&lt;p>Interface(接口) 在 Go 语言有着至关重要的地位。接口是 Go 语言这个类型系统的基石，让 Go 语言在基础编程哲学的探索上达到了前所未有的高度。&lt;/p>
&lt;p>接口解除了类型依赖，有助于减少用户的可视方法，屏蔽了内部结构和实现细节。但是接口实现机制会有运行期开销，也不能滥用接口。相对于包，或者不会频繁变化的内部模块之间，不需要抽象出接口来强行分离。&lt;/p>
&lt;p>接口最常用的&lt;strong>使用场景&lt;/strong>，是&lt;strong>对包提供访问&lt;/strong>，或&lt;strong>预留扩展空间&lt;/strong>。也是体现多态很重要的手段。说到底，接口的意义：就是解耦合，降低程序和程序之间的关联程度，降低耦合性。&lt;/p>
&lt;p>当使用一个第三方库的时候，这个第三方库实现了很多接口，当我们需要使用这些接口时，就需要实现这些接口的方法。因为，这个第三方库内的某些函数(或方法)会将这些接口作为需要传入的参数，以实现自身的逻辑。&lt;/p>
&lt;p>struct 和 interface 都是一种类型，所以都可以声明，并赋值。如果该函数的形参是一个接口类型，在使用该函数，传递的实参就可以是任意类型。这时，如果我们自定义的这个 struct 实现了第三方库的接口中的方法，那么这个函数就可以调用这些自己定义的方法，来根据自身的函数逻辑，处理这个自己定义的 struct。&lt;/p>
&lt;p>所以，所谓的接口，就是接收某种类型的值，然后通过内部的某些处理逻辑，来根据这个值进行处理。&lt;/p>
&lt;p>其实&lt;strong>接口跟函数的概念是一样的&lt;/strong>，只不过是一层更抽象的东西，而且可以接收比函数更多的类型的值；并且，可以通过更多的函数处理这个接收到的值。如果说函数是一种行为的行为的话，那接口就是一类行为的统称。&lt;/p>
&lt;blockquote>
&lt;p>struct 实现了某个接口，并通过某些方法调用之后，接口后面的函数用不用 struct 所实现的 方法，就是库中接口后面的具体函数(i.e.函数行为) 来决定的。&lt;/p>
&lt;/blockquote>
&lt;p>也可以这么说，&lt;strong>如果把接口比作变量(实际上，也确实可以声明一个接口类型的变量)，&lt;strong>那么这个&lt;/strong>类型实例化后的变量就可以作为值，直接赋予给这个接口变量。&lt;/strong>&lt;/p>
&lt;p>&lt;strong>函数 与 类型(i.e.值)，可以说是构成代码的最基础的东西&lt;/strong>&lt;/p>
&lt;h2 id="用-usb-来类比接口非常形象">用 USB 来类比接口非常形象：&lt;/h2>
&lt;p>参考：&lt;a href="https://github.com/DesistDaydream/GoLearning/tree/master/practice/usb_interface">文中代码在 GitHub 的 GoLearning 项目中&lt;/a>&lt;/p>
&lt;h3 id="单独描述">单独描述&lt;/h3>
&lt;p>USB 接口规定了他可以处理 &lt;code>Start()&lt;/code> 和 &lt;code>End()&lt;/code> 两个方法，这与这俩方法中的具体实现他不管。并且还有一个 &lt;code>OperatorRead()&lt;/code> 函数，将&lt;code>接口&lt;/code>作为形参，并调用接口里的方法实现一些功能。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">type&lt;/span> &lt;span style="color:#a6e22e">USB&lt;/span> &lt;span style="color:#66d9ef">interface&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">Start&lt;/span>()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">End&lt;/span>()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">func&lt;/span> &lt;span style="color:#a6e22e">OperatorRead&lt;/span>(&lt;span style="color:#a6e22e">u&lt;/span> &lt;span style="color:#a6e22e">USB&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">u&lt;/span>.&lt;span style="color:#a6e22e">Start&lt;/span>()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">fmt&lt;/span>.&lt;span style="color:#a6e22e">Printf&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;当前连接设备的信息为：%v\n&amp;#34;&lt;/span>, &lt;span style="color:#a6e22e">u&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">u&lt;/span>.&lt;span style="color:#a6e22e">End&lt;/span>()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>USB 接口的意思就是，我不管要插我的是什么，鼠标键盘也罢，移动硬盘也行，U 盘也行。只要这些要插入 USB 接口的对象能满足两个方法(其实就相当于规定使用 USB 连接协议，类似 HTTP 协议)，都可以连接。连接后，你们具体怎么操作，就看你们各自对象自己的实现了。&lt;/p>
&lt;blockquote>
&lt;p>假设这一段代码是一个第三方库的话，那这就是一个 usb 接口库，可以给其他人使用。只要实现了接口的方法，就可以使用我的库中的绝大部分功能。&lt;/p>
&lt;/blockquote>
&lt;p>现在有一个金士顿的硬盘想要使用 USB 接口读取数据，这时，它只要实现两个方法即可通过接口后面的 &lt;code>OperatorRead()&lt;/code> 来获取数据。在这里金士顿硬盘的 &lt;code>Start()&lt;/code> 方法中，有一个行为。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// KingstonDisk 金士顿牌移动硬盘
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">type&lt;/span> &lt;span style="color:#a6e22e">KingstonDisk&lt;/span> &lt;span style="color:#66d9ef">struct&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">Name&lt;/span> &lt;span style="color:#66d9ef">string&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">Type&lt;/span> &lt;span style="color:#66d9ef">string&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">Data&lt;/span> &lt;span style="color:#66d9ef">string&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// NewKingstonDisk is
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">func&lt;/span> &lt;span style="color:#a6e22e">NewKingstonDisk&lt;/span>() &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">KingstonDisk&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#f92672">&amp;amp;&lt;/span>&lt;span style="color:#a6e22e">KingstonDisk&lt;/span>{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">Name&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;A1&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">Type&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;SSD&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">Data&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;KingstonDisk fastest SSD&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// Start is
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">func&lt;/span> (&lt;span style="color:#a6e22e">k&lt;/span> &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">KingstonDisk&lt;/span>) &lt;span style="color:#a6e22e">Start&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">fmt&lt;/span>.&lt;span style="color:#a6e22e">Println&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;金士顿SSD硬盘已连接&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// End is
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">func&lt;/span> (&lt;span style="color:#a6e22e">k&lt;/span> &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">KingstonDisk&lt;/span>) &lt;span style="color:#a6e22e">End&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>这时，我们就可以让 KingstonDisk 插入 USB 接口了，初始化(相当于打开插头的帽)，并调用 USB 接口后面的 &lt;code>OperatorRead()&lt;/code> 函数，调用函数时，需要将 KingstonDisk 实例化的变量作为参数传递进去(这就等于插在 USB 接口，想要执行 OperatorRead 行为)&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">func&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">//
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#a6e22e">k&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">NewKingstonDisk&lt;/span>()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">usbinterface&lt;/span>.&lt;span style="color:#a6e22e">OperatorRead&lt;/span>(&lt;span style="color:#a6e22e">k&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="组织一下这段代码文件大概是这样的">组织一下这段代码文件，大概是这样的：&lt;/h3>
&lt;pre>&lt;code>practice/usb_interface/
├── main.go
├── usb_device
│ └── disk.go
└── usb_interface
└── interface.go
&lt;/code>&lt;/pre>
&lt;p>&lt;strong>interface.go&lt;/strong>&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">package&lt;/span> &lt;span style="color:#a6e22e">usbinterface&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">import&lt;/span> &lt;span style="color:#e6db74">&amp;#34;fmt&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// USB is
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">type&lt;/span> &lt;span style="color:#a6e22e">USB&lt;/span> &lt;span style="color:#66d9ef">interface&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">Start&lt;/span>()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">End&lt;/span>()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// OperatorRead 启动插入接口的设备并从中读取信息读取、读取后结束
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">func&lt;/span> &lt;span style="color:#a6e22e">OperatorRead&lt;/span>(&lt;span style="color:#a6e22e">u&lt;/span> &lt;span style="color:#a6e22e">USB&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">u&lt;/span>.&lt;span style="color:#a6e22e">Start&lt;/span>()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">fmt&lt;/span>.&lt;span style="color:#a6e22e">Printf&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;当前连接设备的信息为：%v\n&amp;#34;&lt;/span>, &lt;span style="color:#a6e22e">u&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">u&lt;/span>.&lt;span style="color:#a6e22e">End&lt;/span>()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;strong>disk.go&lt;/strong>&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">package&lt;/span> &lt;span style="color:#a6e22e">usb_device&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">import&lt;/span> &lt;span style="color:#e6db74">&amp;#34;fmt&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// KingstonDisk 金士顿牌移动硬盘
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">type&lt;/span> &lt;span style="color:#a6e22e">KingstonDisk&lt;/span> &lt;span style="color:#66d9ef">struct&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">Name&lt;/span> &lt;span style="color:#66d9ef">string&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">Type&lt;/span> &lt;span style="color:#66d9ef">string&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">Data&lt;/span> &lt;span style="color:#66d9ef">string&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// NewKingstonDisk is
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">func&lt;/span> &lt;span style="color:#a6e22e">NewKingstonDisk&lt;/span>() &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">KingstonDisk&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#f92672">&amp;amp;&lt;/span>&lt;span style="color:#a6e22e">KingstonDisk&lt;/span>{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">Name&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;A1&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">Type&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;SSD&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">Data&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;KingstonDisk fastest SSD&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// Start is
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">func&lt;/span> (&lt;span style="color:#a6e22e">k&lt;/span> &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">KingstonDisk&lt;/span>) &lt;span style="color:#a6e22e">Start&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">fmt&lt;/span>.&lt;span style="color:#a6e22e">Println&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;金士顿SSD硬盘已连接&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// End is
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">func&lt;/span> (&lt;span style="color:#a6e22e">k&lt;/span> &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">KingstonDisk&lt;/span>) &lt;span style="color:#a6e22e">End&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">//
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;strong>main.go&lt;/strong>&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">package&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">import&lt;/span> (
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">usbinterface&lt;/span> &lt;span style="color:#e6db74">&amp;#34;github.com/DesistDaydream/GoLearning/practice/usb_interface/usb_interface&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">usbdevice&lt;/span> &lt;span style="color:#e6db74">&amp;#34;github.com/DesistDaydream/GoLearning/practice/usb_interface/usb_device&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">func&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">k&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">usbdevice&lt;/span>.&lt;span style="color:#a6e22e">NewKingstonDisk&lt;/span>()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">usbinterface&lt;/span>.&lt;span style="color:#a6e22e">OperatorRead&lt;/span>(&lt;span style="color:#a6e22e">k&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>运行结果：&lt;/p>
&lt;pre>&lt;code>root@lichenhao:~/projects/GoLearning# go run practice/usb_interface/main.go
金士顿SSD硬盘已连接
当前连接的设备信息为：&amp;amp;{A1 SSD KingstonDisk fastest SSD}
&lt;/code>&lt;/pre>
&lt;h4 id="总结-2">总结&lt;/h4>
&lt;p>从结果可以看出来，在 &lt;code>OperatorRead()&lt;/code> 函数的代码逻辑中，并没打印 &lt;code>金士顿SSD硬盘已连接&lt;/code> 这段文字。&lt;/p>
&lt;blockquote>
&lt;p>而且 OperatorRead() 的&lt;strong>形参是接口类型&lt;/strong>，但是我们在调用的时候传递的&lt;strong>实参是结构体类型&lt;/strong>。可以这么说，如果结构体实现了接口内的方法，这个结构体就是接口。&lt;/p>
&lt;/blockquote>
&lt;p>所以此时 OperatorRead() 中调用的 &lt;code>u.Start()&lt;/code> 其实是 &lt;code>k.Start()&lt;/code>，也就是说，此时 &lt;strong>OperatorRead() 代码逻辑中，变量 u 的类型&lt;/strong>已经**变为 &lt;strong>&lt;code>**KingstonDisk**&lt;/code>&lt;/strong> 这个结构体类型了，**所以调用的是实现 KingstonDisk 这个结构体的方法(也就是 &lt;code>k.Start()&lt;/code>)。这种效果，就称为接口的 **polymorphism(多态) **特性，就是说接口可以接收任意类型。&lt;/p>
&lt;p>所以在 main() 中，使用 KingstonDisk 作为参数调用 usbinterface.OperatorRead(k) 时，实际上，就是把实现 KingstonDisk 的两个方法，也带入了接口中，接口中任何调用这俩方法的代码，实际都是在调用 实现 KingstonDisk 这个结构体的方法。&lt;/p>
&lt;p>也可以这么说，凡是&lt;strong>实现了接口的结构体&lt;/strong>，这个&lt;strong>结构体就是这个接口&lt;/strong>。&lt;strong>如果把接口比作变量(实际上，也确实可以声明一个接口类型的变量)，那么结构体就是这个变量的值。&lt;/strong>&lt;/p>
&lt;p>还可以这么说，假设结构体 B &lt;strong>实现了接口&lt;/strong>，这个&lt;strong>接口就是 B&lt;/strong>。调用接口内的方法时，就是调用接口变量当前值(也就是 B)的方法。&lt;/p>
&lt;p>比如我现在在 &lt;code>main()&lt;/code> 中声明一个 map，key 设置为 USB 接口类型，value 设置为 bool 类型。当我们给这个 map 设置值的时候，凡是实现了这个接口的结构体，都可以作为该 map 的 key 使用。并且在输出 map 时，可以根据这个 key 来输出。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// usbs 测试接口多态效果，
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#a6e22e">usbs&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#66d9ef">map&lt;/span>[&lt;span style="color:#a6e22e">usbinterface&lt;/span>.&lt;span style="color:#a6e22e">USB&lt;/span>]&lt;span style="color:#66d9ef">bool&lt;/span>{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;amp;&lt;/span>&lt;span style="color:#a6e22e">usbdevice&lt;/span>.&lt;span style="color:#a6e22e">KingstonDisk&lt;/span>{}: &lt;span style="color:#66d9ef">true&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;amp;&lt;/span>&lt;span style="color:#a6e22e">usbdevice&lt;/span>.&lt;span style="color:#a6e22e">Mouse&lt;/span>{}: &lt;span style="color:#66d9ef">true&lt;/span>, &lt;span style="color:#75715e">// 这是后面讲到的另一个实现了接口的结构体
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">fmt&lt;/span>.&lt;span style="color:#a6e22e">Println&lt;/span>(&lt;span style="color:#a6e22e">usbs&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 这是一个最简单的，把接口当作变量，把结构体当作值，然后调用接口下方法的例子
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#75715e">// 此时 结构体=方法，所以在调用作用在 usbVar 变量上的方法，实际上就是 func (k *KingstonDisk) Start() {}
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">var&lt;/span> &lt;span style="color:#a6e22e">usbsVar&lt;/span> &lt;span style="color:#a6e22e">usbinterface&lt;/span>.&lt;span style="color:#a6e22e">USB&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">usbsVar&lt;/span> = &lt;span style="color:#a6e22e">usbdevice&lt;/span>.&lt;span style="color:#a6e22e">KingstonDisk&lt;/span>()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">usbsVar&lt;/span>.&lt;span style="color:#a6e22e">Start&lt;/span>()
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>输出结果：&lt;/p>
&lt;pre>&lt;code>root@lichenhao:~/projects/GoLearning# go run practice/usb_interface/main.go
map[0xc00005c1e0:true]
金士顿SSD硬盘已连接
&lt;/code>&lt;/pre>
&lt;p>从输出结果可以看到，usbs 这个 map 类型的 key 是当前接口体的指针。&lt;/p>
&lt;blockquote>
&lt;p>为什么 key 是指针呢？因为我们在实现 KingstonDisk 结构体时，用的都是指针，所以这里的 key 就是结构体的内存地址
如果将实现结构体时的指针都去掉，这里 map 的 key，实际上就行结构体内的值，但是这里没有给结构体赋值，所以这是 key 应该为 &lt;code>{ }&lt;/code>，也就是空值)。&lt;/p>
&lt;/blockquote>
&lt;p>所以，从这个示例就可以看出来，实现了接口的结构体，那么这个结构体就是这个接口。&lt;/p>
&lt;p>平时口头交流老说给啥啥啥传值，在这里，就可以描述为&lt;strong>给接口传个结构体&lt;/strong>。嘿嘿~~~&lt;/p>
&lt;h3 id="如果不使用接口">如果不使用接口&lt;/h3>
&lt;p>上面的例子非常繁琐，为什么我们要花这么大劲儿写个接口呢，如果不写接口行 不行？行，当然行，我来改一下~&lt;/p>
&lt;p>我们只需要不使用 USB interface 类型，并修改 OperatorRead() 所接收的&lt;strong>形参&lt;/strong>即可，其他文件都不用修改&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">package&lt;/span> &lt;span style="color:#a6e22e">usbinterface&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">import&lt;/span> (
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#34;fmt&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">usbdevice&lt;/span> &lt;span style="color:#e6db74">&amp;#34;github.com/DesistDaydream/GoLearning/practice/usb_interface/usb_device&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// USB 接口
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// type USB interface {
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// Start()
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// End()
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// }
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// OperatorRead 启动插入接口的设备并从中读取信息读取、读取后结束
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">func&lt;/span> &lt;span style="color:#a6e22e">OperatorRead&lt;/span>(&lt;span style="color:#a6e22e">u&lt;/span> &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">usbdevice&lt;/span>.&lt;span style="color:#a6e22e">KingstonDisk&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">u&lt;/span>.&lt;span style="color:#a6e22e">Start&lt;/span>()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">fmt&lt;/span>.&lt;span style="color:#a6e22e">Printf&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;当前连接的设备信息为：%v\n&amp;#34;&lt;/span>, &lt;span style="color:#a6e22e">u&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">u&lt;/span>.&lt;span style="color:#a6e22e">End&lt;/span>()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>这样得出的输出结果时一样的。&lt;/p>
&lt;h3 id="不使用接口有什么问题呢">不使用接口有什么问题呢？&lt;/h3>
&lt;p>此时，如果我添加了一个新的对象，比如鼠标、键盘等，也想通过 OperatorRead() 来执行操作并输出结果。也就是我需要新的结构体，这该怎么办呢？&lt;/p>
&lt;p>首先，需要再添加一个 OperatorRead() 以便让他接收其他类型的参数。变成这样&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// OperatorRead 启动插入接口的设备并从中读取信息读取、读取后结束
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">func&lt;/span> &lt;span style="color:#a6e22e">OperatorRead&lt;/span>(&lt;span style="color:#a6e22e">u&lt;/span> &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">usbdevice&lt;/span>.&lt;span style="color:#a6e22e">KingstonDisk&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">u&lt;/span>.&lt;span style="color:#a6e22e">Start&lt;/span>()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">fmt&lt;/span>.&lt;span style="color:#a6e22e">Printf&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;当前连接的设备信息为：%v\n&amp;#34;&lt;/span>, &lt;span style="color:#a6e22e">u&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">u&lt;/span>.&lt;span style="color:#a6e22e">End&lt;/span>()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// OperatorRead 启动插入接口的设备并从中读取信息读取、读取后结束
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">func&lt;/span> &lt;span style="color:#a6e22e">OperatorRead2&lt;/span>(&lt;span style="color:#a6e22e">u&lt;/span> &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">usbdevice&lt;/span>.&lt;span style="color:#a6e22e">Mouse&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">u&lt;/span>.&lt;span style="color:#a6e22e">Start&lt;/span>()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">fmt&lt;/span>.&lt;span style="color:#a6e22e">Printf&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;当前连接的设备信息为：%v\n&amp;#34;&lt;/span>, &lt;span style="color:#a6e22e">u&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">u&lt;/span>.&lt;span style="color:#a6e22e">End&lt;/span>()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>并且调用时，也需要分别调用&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">func&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">k&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">usbdevice&lt;/span>.&lt;span style="color:#a6e22e">NewKingstonDisk&lt;/span>()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">usbinterface&lt;/span>.&lt;span style="color:#a6e22e">OperatorRead&lt;/span>(&lt;span style="color:#a6e22e">k&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">m&lt;/span>&lt;span style="color:#f92672">:=&lt;/span>&lt;span style="color:#a6e22e">usbdevice&lt;/span>.&lt;span style="color:#a6e22e">NewMouse&lt;/span>()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">usbinterface&lt;/span>.&lt;span style="color:#a6e22e">OperatorReadMouse&lt;/span>(&lt;span style="color:#a6e22e">m&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>问题点：&lt;/p>
&lt;ul>
&lt;li>修改了我们已经设计好的 OperatorRead() 功能，每当其他人想要使用我们设计的这个功能时，我都要重新修改。这大大增加了代码的不可维护性。&lt;/li>
&lt;/ul>
&lt;h3 id="结论">结论&lt;/h3>
&lt;p>而如果使用了接口，不管增加多少 USB 设备，只要这些设备想使用 OperatorRead() 的功能，直接调用即可。在添加完结构体文件后，只需要在 main() 中直接调用即可：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">func&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">k&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">usbdevice&lt;/span>.&lt;span style="color:#a6e22e">NewKingstonDisk&lt;/span>()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">usbinterface&lt;/span>.&lt;span style="color:#a6e22e">OperatorRead&lt;/span>(&lt;span style="color:#a6e22e">k&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">m&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">usbdevice&lt;/span>.&lt;span style="color:#a6e22e">NewMouse&lt;/span>()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">usbinterface&lt;/span>.&lt;span style="color:#a6e22e">OperatorRead&lt;/span>(&lt;span style="color:#a6e22e">m&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="通过鸭子模型理解-go-接口">通过鸭子模型理解 Go 接口&lt;/h2>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://www.zhihu.com/question/318138275">知乎，如何理解 Golang 中的接口&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;h3 id="鸭子模型">鸭子模型&lt;/h3>
&lt;p>那什么鸭子模型？&lt;/p>
&lt;p>鸭子模型的解释，通常会用了一个非常有趣的例子，一个东西究竟是不是鸭子，取决于它的能力。游泳起来像鸭子、叫起来也像鸭子，那么就可以是鸭子。&lt;/p>
&lt;p>动态语言，比如 Python 和 Javascript 天然支持这种特性，不过相对于静态语言，动态语言的类型缺乏了必要的类型检查。&lt;/p>
&lt;p>Go 接口设计和鸭子模型有密切关系，但又和动态语言的鸭子模型有所区别，在编译时，即可实现必要的类型检查。&lt;/p>
&lt;h3 id="用-go-接口实现鸭子模型">用 Go 接口实现鸭子模型&lt;/h3>
&lt;p>Go 接口是一组方法的集合，可以理解为抽象的类型。它提供了一种非侵入式的接口。任何类型，只要实现了该接口中方法集，那么就属于这个类型。&lt;/p>
&lt;p>举个例子，假设定义一个鸭子的接口。如下：&lt;/p>
&lt;pre>&lt;code>type Duck interface {
Quack() // 鸭子叫
DuckGo() // 鸭子走
}
&lt;/code>&lt;/pre>
&lt;p>我们定义一个函数，负责执行鸭子能做的事情。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">func&lt;/span> &lt;span style="color:#a6e22e">DoDuck&lt;/span>(&lt;span style="color:#a6e22e">d&lt;/span> &lt;span style="color:#a6e22e">Duck&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">d&lt;/span>.&lt;span style="color:#a6e22e">Quack&lt;/span>()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">d&lt;/span>.&lt;span style="color:#a6e22e">DuckGo&lt;/span>()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>假设现在有一个鸡类型，结构如下：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">type&lt;/span> &lt;span style="color:#a6e22e">Chicken&lt;/span> &lt;span style="color:#66d9ef">struct&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">func&lt;/span> (&lt;span style="color:#a6e22e">c&lt;/span> &lt;span style="color:#a6e22e">Chicken&lt;/span>) &lt;span style="color:#a6e22e">IsChicken&lt;/span>() &lt;span style="color:#66d9ef">bool&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">fmt&lt;/span>.&lt;span style="color:#a6e22e">Println&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;我是小鸡&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>这只鸡和一般的小鸡不一样，它比较聪明，也可以做鸭子能做的事情。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">func&lt;/span> (&lt;span style="color:#a6e22e">c&lt;/span> &lt;span style="color:#a6e22e">Chicken&lt;/span>) &lt;span style="color:#a6e22e">Quack&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">fmt&lt;/span>.&lt;span style="color:#a6e22e">Println&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;嘎嘎&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">func&lt;/span> (&lt;span style="color:#a6e22e">c&lt;/span> &lt;span style="color:#a6e22e">Chicken&lt;/span>) &lt;span style="color:#a6e22e">DuckGo&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">fmt&lt;/span>.&lt;span style="color:#a6e22e">Println&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;大摇大摆的走&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;blockquote>
&lt;p>注意，这里只是实现了 Duck 接口方法，并没有将鸡类型和鸭子接口显式绑定。这是一种非侵入式的设计。&lt;/p>
&lt;/blockquote>
&lt;p>因为小鸡实现了鸭子的所有方法，所以小鸡也是鸭。那么在 main 函数中就可以这么写了。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">func&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 声明结构体
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#a6e22e">c&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">Chicken&lt;/span>{}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 结构体类型作为实参调用 DoDuck()
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#a6e22e">DoDuck&lt;/span>(&lt;span style="color:#a6e22e">c&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>执行正常。如此是不是很类似于其他语言的多态，其实这就是 Go 多态的实现方法。&lt;/p>
&lt;h2 id="heading">&lt;/h2></description></item><item><title>Docs: Method(方法)、Interface(接口)</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/2.%E7%BC%96%E7%A8%8B/%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/go/go-%E6%A0%87%E5%87%86%E5%BA%93/method%E6%96%B9%E6%B3%95interface%E6%8E%A5%E5%8F%A3/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/2.%E7%BC%96%E7%A8%8B/%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/go/go-%E6%A0%87%E5%87%86%E5%BA%93/method%E6%96%B9%E6%B3%95interface%E6%8E%A5%E5%8F%A3/</guid><description/></item><item><title>Docs: Pointers(指针)</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/2.%E7%BC%96%E7%A8%8B/%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/go/go-%E6%A0%87%E5%87%86%E5%BA%93/pointers%E6%8C%87%E9%92%88/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/2.%E7%BC%96%E7%A8%8B/%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/go/go-%E6%A0%87%E5%87%86%E5%BA%93/pointers%E6%8C%87%E9%92%88/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://go.dev/ref/spec#Pointer_types">Go 官方文档，参考-指针类型&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>在 Go 语言中，指针可以有两种含义：&lt;/p>
&lt;ul>
&lt;li>通过 &lt;code>&amp;amp;&lt;/code> 符号获取一个变量的内存地址，即&lt;strong>指针&lt;/strong>。通常使用十六进制数表示。这种方式称为&lt;strong>指针引用&lt;/strong>&lt;/li>
&lt;li>指针也可以表示一种&lt;strong>数据类型&lt;/strong>。可以声明一个指针类型的变量，用以存储内存地址。&lt;/li>
&lt;/ul>
&lt;p>一个&lt;strong>指针变量&lt;/strong>可以指向任何一个&lt;strong>值的内存地址&lt;/strong>。这个内存地址，在 32 位机器上占用 4 个字节，在 64 位机器上占用 8 个字节，并且与其所指向的值得的大小无关。
在 Go 语言中，不能进行指针运算。&lt;/p>
&lt;h2 id="指针的引用">指针的引用&lt;/h2>
&lt;p>每一个变量都有指针，我们可以通过 &lt;code>&amp;amp;&lt;/code> 符号引用该变量的指针，也就是获取该变量的内存地址。&lt;/p>
&lt;blockquote>
&lt;p>我们平时说引用指针，并不是引用指针类型的变量，指针类型的变量也是一种变量，正常使用变量名称即可引用。&lt;/p>
&lt;/blockquote>
&lt;p>这里说要说的指针的引用是指&lt;strong>引用一个变量的内存地址，即变量的指针&lt;/strong>
**格式：**在变量名称前加上 &lt;code>&amp;amp;&lt;/code> 符号，即可获取该变量的内存地址，即该变量的指针。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">&amp;amp;&lt;/span>&lt;span style="color:#a6e22e">VarID&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;strong>注意：若该变量的值为空，则该变量依然具有内存地址：&lt;/strong>&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">var&lt;/span> &lt;span style="color:#a6e22e">a&lt;/span> &lt;span style="color:#66d9ef">string&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">fmt&lt;/span>.&lt;span style="color:#a6e22e">Println&lt;/span>(&lt;span style="color:#f92672">&amp;amp;&lt;/span>&lt;span style="color:#a6e22e">a&lt;/span>)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>这将会输出：0xc000010250&lt;/p>
&lt;h2 id="指针变量的声明">指针变量的声明&lt;/h2>
&lt;p>&lt;strong>格式：&lt;/strong>&lt;code>*&lt;/code> 与 &lt;code>数据类型&lt;/code> 的组合书写，即代表指针类型：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">var&lt;/span> &lt;span style="color:#a6e22e">VarID&lt;/span> &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">TYPE&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>这里需要注意的是，当一个指针变量被声明后，它的值为&lt;code>nil&lt;/code>，但是这个变量本身是具有指针的&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">func&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 声明一个 `字符串指针` 类型的变量
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">var&lt;/span> &lt;span style="color:#a6e22e">VarID&lt;/span> &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#66d9ef">string&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">fmt&lt;/span>.&lt;span style="color:#a6e22e">Println&lt;/span>(&lt;span style="color:#a6e22e">VarID&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">fmt&lt;/span>.&lt;span style="color:#a6e22e">Println&lt;/span>(&lt;span style="color:#f92672">&amp;amp;&lt;/span>&lt;span style="color:#a6e22e">VarID&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>输出结果：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>&amp;lt;nil&amp;gt;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>0xc000014088
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>一个指针类型的变量可以保存内存地址，同时自己也具有内存地址。&lt;/p>
&lt;h2 id="指针变量的赋值">指针变量的赋值&lt;/h2>
&lt;p>&lt;strong>格式：&lt;/strong>&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">var&lt;/span> &lt;span style="color:#a6e22e">ptr&lt;/span> &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#66d9ef">string&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">stringVar&lt;/span> = &lt;span style="color:#e6db74">&amp;#34;pointer string&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">ptr&lt;/span> = &lt;span style="color:#f92672">&amp;amp;&lt;/span>&lt;span style="color:#a6e22e">stringVar&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>虽然一个指针类型的变量的值是类似 0xc000010250 这样的内存地址，但是若我们声明了一个&lt;strong>字符串指针类型&lt;/strong>的变量，那么给该变量赋值时，也要使用&lt;strong>保存字符串的内存地址&lt;/strong>；如果使用保存其他类型(比如 int)的内存地址，将会报错：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">normalVar&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#ae81ff">5&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">var&lt;/span> &lt;span style="color:#a6e22e">ptr&lt;/span> &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#66d9ef">string&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">ptr&lt;/span> = &lt;span style="color:#f92672">&amp;amp;&lt;/span>&lt;span style="color:#a6e22e">normalVar&lt;/span> &lt;span style="color:#75715e">// 这里将会报错：cannot use &amp;amp;normalVar (value of type *int) as type *string in assignment
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>因为 &lt;code>*string&lt;/code> 和 &lt;code>*int&lt;/code> 是两个不同的类型。&lt;/p>
&lt;h2 id="指针变量的解除引用">指针变量的解除引用&lt;/h2>
&lt;p>在上面指针变量的赋值中，我们在最后使用指针变量的 Dereferences(解除引用)，以获取具体的值。
&lt;strong>格式：&lt;/strong>&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">PointerTypeVarID&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>在某个指针类型的变量前面添加 &lt;code>*&lt;/code> 则会解除指针引用，从而&lt;strong>获取指针变量中的值，所指向的内存空间中的值。&lt;/strong>
注意：若指针变量未实例化(即指针变量为 nil)，那么解除引用时将会报错：panic: runtime error: invalid memory address or nil pointer dereference。主要错误在于 nil pointer dereference(空指针接触引用)&lt;/p>
&lt;h2 id="指针变量的实例化">指针变量的实例化&lt;/h2>
&lt;p>通过 var 关键字声明的指针变量的默认值为 nil，无法通过解引用的方式为该内存空间填入值，或者获取内存空间的值，因为内存空间不存在，是 nil。
此时可以通过 &lt;code>new()&lt;/code> 函数，在声明的指针变量的同时实例化该指针，并为指针变量的值赋予一个值。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">ptrNew&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> new(&lt;span style="color:#66d9ef">string&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">ptrNew&lt;/span> = &lt;span style="color:#e6db74">&amp;#34;a&amp;#34;&lt;/span> &lt;span style="color:#75715e">// 由于此时 ptrNew 具有内存地址，所以可以直接通过解引用的方式为 ptrNew 内存地址空间内赋予值
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#a6e22e">fmt&lt;/span>.&lt;span style="color:#a6e22e">Println&lt;/span>(&lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">ptrNew&lt;/span>) &lt;span style="color:#75715e">// 将会输出：a
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="var-与-new-的区别">var 与 new() 的区别&lt;/h3>
&lt;p>主要区别在于系统是否会为指针变量初始化一个值，var 不会， new() 会
若一个指针变量没有被初始化一个值，那么解除引用将会失败，因为指针变量没有值，也就是说这个指针变量内没有内存地址，此时接触引用将会失败，也就是 nil pointer dereference&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">var&lt;/span> &lt;span style="color:#a6e22e">ptr&lt;/span> &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#66d9ef">string&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">ptr&lt;/span> = &lt;span style="color:#e6db74">&amp;#34;5&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 只声明未实例化，上面两行报错：panic: runtime error: invalid memory address or nil pointer dereference
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">ptr&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> new(&lt;span style="color:#66d9ef">string&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">ptr&lt;/span> = &lt;span style="color:#e6db74">&amp;#34;5&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 这两行不报错
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="todo">TODO&lt;/h2>
&lt;p>这是什么语法？&lt;code>(*stringValue)(p)&lt;/code>？&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">func&lt;/span> &lt;span style="color:#a6e22e">newStringValue&lt;/span>(&lt;span style="color:#a6e22e">val&lt;/span> &lt;span style="color:#66d9ef">string&lt;/span>, &lt;span style="color:#a6e22e">p&lt;/span> &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#66d9ef">string&lt;/span>) &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">stringValue&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">p&lt;/span> = &lt;span style="color:#a6e22e">val&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> (&lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">stringValue&lt;/span>)(&lt;span style="color:#a6e22e">p&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="简单示例">简单示例&lt;/h2>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">func&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">normalVar&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#ae81ff">5&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 通过 &amp;amp; 符号取得变量 a 的内存地址，即指向 a 的指针
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#a6e22e">fmt&lt;/span>.&lt;span style="color:#a6e22e">Println&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;变量 a 的内存地址，即指针为：&amp;#34;&lt;/span>, &lt;span style="color:#f92672">&amp;amp;&lt;/span>&lt;span style="color:#a6e22e">normalVar&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 声明一个指针类型的变量
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">var&lt;/span> &lt;span style="color:#a6e22e">ptr&lt;/span> &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#66d9ef">string&lt;/span> &lt;span style="color:#75715e">// 这是一个字符串指针类型的变量
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#a6e22e">fmt&lt;/span>.&lt;span style="color:#a6e22e">Println&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;刚刚声明的指针没有任何内存地址，默认值为 nil：&amp;#34;&lt;/span>, &lt;span style="color:#a6e22e">ptr&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 指针赋值
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#75715e">// 错误示例：不可以使用 *int 类型给 *string 类型赋值，虽然都是内存地址，但是不可以这么做
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#75715e">// ptr = &amp;amp;normalVar
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#75715e">// 正确示例:
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#a6e22e">newPtr&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">strconv&lt;/span>.&lt;span style="color:#a6e22e">Itoa&lt;/span>(&lt;span style="color:#a6e22e">normalVar&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">ptr&lt;/span> = &lt;span style="color:#f92672">&amp;amp;&lt;/span>&lt;span style="color:#a6e22e">newPtr&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">fmt&lt;/span>.&lt;span style="color:#a6e22e">Println&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;为指针类型变量赋予一个内存地址后，获取该内存地址内保存的值：&amp;#34;&lt;/span>, &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">ptr&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>输出结果：&lt;/p>
&lt;pre>&lt;code>变量 a 的内存地址，即指针为： 0xc0000ba000
刚刚声明的指针没有任何内存地址，默认值为 nil： &amp;lt;nil&amp;gt;
为指针类型变量赋予一个内存地址后，获取该内存地址内保存的值： 5
&lt;/code>&lt;/pre>
&lt;h2 id="通过指针改变变量的值">通过指针改变变量的值&lt;/h2>
&lt;p>由于指针的特殊性，我们可以在任何地方修改一个局部变量的值。这就是人们常说的“值传递”和“引用传递”。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">package&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">import&lt;/span> &lt;span style="color:#e6db74">&amp;#34;fmt&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">func&lt;/span> &lt;span style="color:#a6e22e">zeroval&lt;/span>(&lt;span style="color:#a6e22e">ival&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">ival&lt;/span> = &lt;span style="color:#ae81ff">0&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">func&lt;/span> &lt;span style="color:#a6e22e">zeroptr&lt;/span>(&lt;span style="color:#a6e22e">iptr&lt;/span> &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#66d9ef">int&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">iptr&lt;/span> = &lt;span style="color:#ae81ff">0&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">func&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">i&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">fmt&lt;/span>.&lt;span style="color:#a6e22e">Println&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;initial:&amp;#34;&lt;/span>, &lt;span style="color:#a6e22e">i&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">zeroval&lt;/span>(&lt;span style="color:#a6e22e">i&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">fmt&lt;/span>.&lt;span style="color:#a6e22e">Println&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;zeroval:&amp;#34;&lt;/span>, &lt;span style="color:#a6e22e">i&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">zeroptr&lt;/span>(&lt;span style="color:#f92672">&amp;amp;&lt;/span>&lt;span style="color:#a6e22e">i&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">fmt&lt;/span>.&lt;span style="color:#a6e22e">Println&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;zeroptr:&amp;#34;&lt;/span>, &lt;span style="color:#a6e22e">i&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">fmt&lt;/span>.&lt;span style="color:#a6e22e">Println&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;pointer:&amp;#34;&lt;/span>, &lt;span style="color:#f92672">&amp;amp;&lt;/span>&lt;span style="color:#a6e22e">i&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>运行结果&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>$ go run pointers.go
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>initial: &lt;span style="color:#ae81ff">1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>zeroval: &lt;span style="color:#ae81ff">1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>zeroptr: &lt;span style="color:#ae81ff">0&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>pointer: 0x42131100
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>在 &lt;code>zeroptr()&lt;/code> 函数中，我们将变量 i 的指针传递进去，此时在函数内修改，将会影响变量 i 的值&lt;/p>
&lt;h1 id="结构体与指针">结构体与指针&lt;/h1>
&lt;p>TODO：&lt;/p>
&lt;h1 id="细嗦-golang-的指针">细嗦 Golang 的指针&lt;/h1>
&lt;blockquote>
&lt;p>原文链接：&lt;a href="https://juejin.cn/post/7114673293084819492">稀土掘金，细嗦 Golang 的指针&lt;/a>&lt;/p>
&lt;/blockquote>
&lt;p>与 C 语言一样，Go 语言中同样有指针，通过指针，我们可以只传递变量的内存地址，而不是传递整个变量，这在一定程度上可以&lt;strong>节省内存的占用&lt;/strong>，但凡事有利有弊，Go 指针在使用也有一些注意点，稍不留神就会踩坑，下面就让我们一起来细嗦下。&lt;/p>
&lt;h2 id="1指针类型的变量">1.指针类型的变量&lt;/h2>
&lt;p>在 Golang 中，我们可以通过**取地址符号&amp;amp;**得到变量的地址，而这个新的变量就是一个指针类型的变量，指针变量与普通变量的区别在于，它存的是内存地址，而不是实际的值。
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/zmk3gz/1661497969122-a72c48b8-e325-49e7-a651-164ec9e0ff92.webp" alt="">
图一&lt;/p>
&lt;p>如果是普通类型的指针变量（比如 &lt;code>**int**&lt;/code>），是无法直接对其赋值的，必须通过 &lt;code>* 取值符号&lt;/code>才行。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">func&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">num&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">numP&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#f92672">&amp;amp;&lt;/span>&lt;span style="color:#a6e22e">num&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">numP&lt;/span> = &lt;span style="color:#ae81ff">2&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>但结构体却比较特殊，在日常开发中，我们经常看到一个结构体指针的内部变量仍然可以被赋值，比如下面这个例子，这是为什么呢？&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">type&lt;/span> &lt;span style="color:#a6e22e">Test&lt;/span> &lt;span style="color:#66d9ef">struct&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">Num&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">func&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">test&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">Test&lt;/span>{&lt;span style="color:#a6e22e">Num&lt;/span>: &lt;span style="color:#ae81ff">1&lt;/span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">test&lt;/span>.&lt;span style="color:#a6e22e">Num&lt;/span> = &lt;span style="color:#ae81ff">3&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">fmt&lt;/span>.&lt;span style="color:#a6e22e">Println&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;v1&amp;#34;&lt;/span>, &lt;span style="color:#a6e22e">test&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">testP&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#f92672">&amp;amp;&lt;/span>&lt;span style="color:#a6e22e">test&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">testP&lt;/span>.&lt;span style="color:#a6e22e">Num&lt;/span> = &lt;span style="color:#ae81ff">4&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">fmt&lt;/span>.&lt;span style="color:#a6e22e">Println&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;v2&amp;#34;&lt;/span>, &lt;span style="color:#a6e22e">test&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>这是因为结构体本身是一个连续的内存，通过 &lt;code>testP.Num&lt;/code> ，本质上拿到的是一个普通变量，并不是一个指针变量，所以可以直接赋值。&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/zmk3gz/1661497969139-3b504293-af29-4ebc-8dd7-4033fd651b53.webp" alt="">&lt;/p>
&lt;p>图二&lt;/p>
&lt;p>那 slice、map、channel 这些又该怎么理解呢？为什么不用取地址符号也能打印它们的地址？比如下面的例子&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>func main&lt;span style="color:#f92672">()&lt;/span> &lt;span style="color:#f92672">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> nums :&lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#f92672">[]&lt;/span>int&lt;span style="color:#f92672">{&lt;/span>1, 2, 3&lt;span style="color:#f92672">}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> fmt.Printf&lt;span style="color:#f92672">(&lt;/span>&lt;span style="color:#e6db74">&amp;#34;%p\n&amp;#34;&lt;/span>, nums&lt;span style="color:#f92672">)&lt;/span> // 0xc0000160c0
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> fmt.Printf&lt;span style="color:#f92672">(&lt;/span>&lt;span style="color:#e6db74">&amp;#34;%p\n&amp;#34;&lt;/span>, &amp;amp;nums&lt;span style="color:#f92672">[&lt;/span>0&lt;span style="color:#f92672">])&lt;/span> // 0xc0000160c0
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> maps :&lt;span style="color:#f92672">=&lt;/span> map&lt;span style="color:#f92672">[&lt;/span>string&lt;span style="color:#f92672">]&lt;/span>string&lt;span style="color:#f92672">{&lt;/span>&lt;span style="color:#e6db74">&amp;#34;aa&amp;#34;&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;bb&amp;#34;&lt;/span>&lt;span style="color:#f92672">}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> fmt.Printf&lt;span style="color:#f92672">(&lt;/span>&lt;span style="color:#e6db74">&amp;#34;%p\n&amp;#34;&lt;/span>, maps&lt;span style="color:#f92672">)&lt;/span> // 0xc000076180
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ch :&lt;span style="color:#f92672">=&lt;/span> make&lt;span style="color:#f92672">(&lt;/span>chan int, 0&lt;span style="color:#f92672">)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> fmt.Printf&lt;span style="color:#f92672">(&lt;/span>&lt;span style="color:#e6db74">&amp;#34;%p\n&amp;#34;&lt;/span>, ch&lt;span style="color:#f92672">)&lt;/span> // 0xc00006c060
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>这是因为，&lt;strong>它们本身就是指针类型&lt;/strong>！只不过 Go 内部为了书写的方便，并没有要求我们在前面加上 &lt;strong>* 符号&lt;/strong>。&lt;/p>
&lt;p>在 Golang 的运行时内部，创建 slice 的时候其实返回的就是一个指针：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">func&lt;/span> &lt;span style="color:#a6e22e">makeslice&lt;/span>(&lt;span style="color:#a6e22e">et&lt;/span> &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">_type&lt;/span>, &lt;span style="color:#a6e22e">len&lt;/span>, &lt;span style="color:#a6e22e">cap&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span>) &lt;span style="color:#a6e22e">unsafe&lt;/span>.&lt;span style="color:#a6e22e">Pointer&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">mem&lt;/span>, &lt;span style="color:#a6e22e">overflow&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">math&lt;/span>.&lt;span style="color:#a6e22e">MulUintptr&lt;/span>(&lt;span style="color:#a6e22e">et&lt;/span>.&lt;span style="color:#a6e22e">size&lt;/span>, uintptr(&lt;span style="color:#a6e22e">cap&lt;/span>))
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> &lt;span style="color:#a6e22e">overflow&lt;/span> &lt;span style="color:#f92672">||&lt;/span> &lt;span style="color:#a6e22e">mem&lt;/span> &amp;gt; &lt;span style="color:#a6e22e">maxAlloc&lt;/span> &lt;span style="color:#f92672">||&lt;/span> &lt;span style="color:#a6e22e">len&lt;/span> &amp;lt; &lt;span style="color:#ae81ff">0&lt;/span> &lt;span style="color:#f92672">||&lt;/span> &lt;span style="color:#a6e22e">len&lt;/span> &amp;gt; &lt;span style="color:#a6e22e">cap&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">mem&lt;/span>, &lt;span style="color:#a6e22e">overflow&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">math&lt;/span>.&lt;span style="color:#a6e22e">MulUintptr&lt;/span>(&lt;span style="color:#a6e22e">et&lt;/span>.&lt;span style="color:#a6e22e">size&lt;/span>, uintptr(&lt;span style="color:#a6e22e">len&lt;/span>))
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> &lt;span style="color:#a6e22e">overflow&lt;/span> &lt;span style="color:#f92672">||&lt;/span> &lt;span style="color:#a6e22e">mem&lt;/span> &amp;gt; &lt;span style="color:#a6e22e">maxAlloc&lt;/span> &lt;span style="color:#f92672">||&lt;/span> &lt;span style="color:#a6e22e">len&lt;/span> &amp;lt; &lt;span style="color:#ae81ff">0&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">panicmakeslicelen&lt;/span>()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">panicmakeslicecap&lt;/span>()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#a6e22e">mallocgc&lt;/span>(&lt;span style="color:#a6e22e">mem&lt;/span>, &lt;span style="color:#a6e22e">et&lt;/span>, &lt;span style="color:#66d9ef">true&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>而且返回的指针地址其实就是&lt;strong>slice 第一个元素的地址&lt;/strong>（上面的例子也体现了），当然如果 slice 是一个 nil，则返回的是 &lt;code>0x0&lt;/code> 的地址。slice 在参数传递的时候其实拷贝的指针的地址，底层数据是共用的，所以对其修改也会影响到函数外的 slice，在下面也会讲到。&lt;/p>
&lt;p>map 和 slice 其实也是类似的，在在 Golang 的运行时内部，创建 map 的时候其实返回的就是一个 hchan 指针：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">func&lt;/span> &lt;span style="color:#a6e22e">makechan&lt;/span>(&lt;span style="color:#a6e22e">t&lt;/span> &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">chantype&lt;/span>, &lt;span style="color:#a6e22e">size&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span>) &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">hchan&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">elem&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">t&lt;/span>.&lt;span style="color:#a6e22e">elem&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> &lt;span style="color:#a6e22e">elem&lt;/span>.&lt;span style="color:#a6e22e">size&lt;/span> &lt;span style="color:#f92672">&amp;gt;=&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>&lt;span style="color:#f92672">&amp;lt;&amp;lt;&lt;/span>&lt;span style="color:#ae81ff">16&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">throw&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;makechan: invalid channel element type&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">...&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#a6e22e">c&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>最后，为什么 &lt;code>fmt.Printf&lt;/code> 函数能够直接打印 slice、map 的地址，除了上面的原因，还有一个原因是其内部也做了特殊处理：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">func&lt;/span> &lt;span style="color:#a6e22e">Printf&lt;/span>(&lt;span style="color:#a6e22e">format&lt;/span> &lt;span style="color:#66d9ef">string&lt;/span>, &lt;span style="color:#a6e22e">a&lt;/span> &lt;span style="color:#f92672">...&lt;/span>&lt;span style="color:#66d9ef">interface&lt;/span>{}) (&lt;span style="color:#a6e22e">n&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span>, &lt;span style="color:#a6e22e">err&lt;/span> &lt;span style="color:#66d9ef">error&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#a6e22e">Fprintf&lt;/span>(&lt;span style="color:#a6e22e">os&lt;/span>.&lt;span style="color:#a6e22e">Stdout&lt;/span>, &lt;span style="color:#a6e22e">format&lt;/span>, &lt;span style="color:#a6e22e">a&lt;/span>&lt;span style="color:#f92672">...&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">func&lt;/span> &lt;span style="color:#a6e22e">Fprintf&lt;/span>(&lt;span style="color:#a6e22e">w&lt;/span> &lt;span style="color:#a6e22e">io&lt;/span>.&lt;span style="color:#a6e22e">Writer&lt;/span>, &lt;span style="color:#a6e22e">format&lt;/span> &lt;span style="color:#66d9ef">string&lt;/span>, &lt;span style="color:#a6e22e">a&lt;/span> &lt;span style="color:#f92672">...&lt;/span>&lt;span style="color:#66d9ef">interface&lt;/span>{}) (&lt;span style="color:#a6e22e">n&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span>, &lt;span style="color:#a6e22e">err&lt;/span> &lt;span style="color:#66d9ef">error&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">p&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">newPrinter&lt;/span>()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">p&lt;/span>.&lt;span style="color:#a6e22e">doPrintf&lt;/span>(&lt;span style="color:#a6e22e">format&lt;/span>, &lt;span style="color:#a6e22e">a&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">n&lt;/span>, &lt;span style="color:#a6e22e">err&lt;/span> = &lt;span style="color:#a6e22e">w&lt;/span>.&lt;span style="color:#a6e22e">Write&lt;/span>(&lt;span style="color:#a6e22e">p&lt;/span>.&lt;span style="color:#a6e22e">buf&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">p&lt;/span>.&lt;span style="color:#a6e22e">free&lt;/span>()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">func&lt;/span> (&lt;span style="color:#a6e22e">p&lt;/span> &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">pp&lt;/span>) &lt;span style="color:#a6e22e">doPrintf&lt;/span>(&lt;span style="color:#a6e22e">format&lt;/span> &lt;span style="color:#66d9ef">string&lt;/span>, &lt;span style="color:#a6e22e">a&lt;/span> []&lt;span style="color:#66d9ef">interface&lt;/span>{}) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">...&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">default&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> &lt;span style="color:#e6db74">&amp;#39;a&amp;#39;&lt;/span> &lt;span style="color:#f92672">&amp;lt;=&lt;/span> &lt;span style="color:#a6e22e">c&lt;/span> &lt;span style="color:#f92672">&amp;amp;&amp;amp;&lt;/span> &lt;span style="color:#a6e22e">c&lt;/span> &lt;span style="color:#f92672">&amp;lt;=&lt;/span> &lt;span style="color:#e6db74">&amp;#39;z&amp;#39;&lt;/span> &lt;span style="color:#f92672">&amp;amp;&amp;amp;&lt;/span> &lt;span style="color:#a6e22e">argNum&lt;/span> &amp;lt; len(&lt;span style="color:#a6e22e">a&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">...&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">p&lt;/span>.&lt;span style="color:#a6e22e">printArg&lt;/span>(&lt;span style="color:#a6e22e">a&lt;/span>[&lt;span style="color:#a6e22e">argNum&lt;/span>], rune(&lt;span style="color:#a6e22e">c&lt;/span>))
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">argNum&lt;/span>&lt;span style="color:#f92672">++&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">i&lt;/span>&lt;span style="color:#f92672">++&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">continue&lt;/span> &lt;span style="color:#a6e22e">formatLoop&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">break&lt;/span> &lt;span style="color:#a6e22e">simpleFormat&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">func&lt;/span> (&lt;span style="color:#a6e22e">p&lt;/span> &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">pp&lt;/span>) &lt;span style="color:#a6e22e">printArg&lt;/span>(&lt;span style="color:#a6e22e">arg&lt;/span> &lt;span style="color:#66d9ef">interface&lt;/span>{}, &lt;span style="color:#a6e22e">verb&lt;/span> &lt;span style="color:#66d9ef">rune&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">p&lt;/span>.&lt;span style="color:#a6e22e">arg&lt;/span> = &lt;span style="color:#a6e22e">arg&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">p&lt;/span>.&lt;span style="color:#a6e22e">value&lt;/span> = &lt;span style="color:#a6e22e">reflect&lt;/span>.&lt;span style="color:#a6e22e">Value&lt;/span>{}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">...&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">case&lt;/span> &lt;span style="color:#e6db74">&amp;#39;p&amp;#39;&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">p&lt;/span>.&lt;span style="color:#a6e22e">fmtPointer&lt;/span>(&lt;span style="color:#a6e22e">reflect&lt;/span>.&lt;span style="color:#a6e22e">ValueOf&lt;/span>(&lt;span style="color:#a6e22e">arg&lt;/span>), &lt;span style="color:#e6db74">&amp;#39;p&amp;#39;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">...&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">func&lt;/span> (&lt;span style="color:#a6e22e">p&lt;/span> &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">pp&lt;/span>) &lt;span style="color:#a6e22e">fmtPointer&lt;/span>(&lt;span style="color:#a6e22e">value&lt;/span> &lt;span style="color:#a6e22e">reflect&lt;/span>.&lt;span style="color:#a6e22e">Value&lt;/span>, &lt;span style="color:#a6e22e">verb&lt;/span> &lt;span style="color:#66d9ef">rune&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">var&lt;/span> &lt;span style="color:#a6e22e">u&lt;/span> &lt;span style="color:#66d9ef">uintptr&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">switch&lt;/span> &lt;span style="color:#a6e22e">value&lt;/span>.&lt;span style="color:#a6e22e">Kind&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">case&lt;/span> &lt;span style="color:#a6e22e">reflect&lt;/span>.&lt;span style="color:#a6e22e">Chan&lt;/span>, &lt;span style="color:#a6e22e">reflect&lt;/span>.&lt;span style="color:#a6e22e">Func&lt;/span>, &lt;span style="color:#a6e22e">reflect&lt;/span>.&lt;span style="color:#a6e22e">Map&lt;/span>, &lt;span style="color:#a6e22e">reflect&lt;/span>.&lt;span style="color:#a6e22e">Ptr&lt;/span>, &lt;span style="color:#a6e22e">reflect&lt;/span>.&lt;span style="color:#a6e22e">Slice&lt;/span>, &lt;span style="color:#a6e22e">reflect&lt;/span>.&lt;span style="color:#a6e22e">UnsafePointer&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">u&lt;/span> = &lt;span style="color:#a6e22e">value&lt;/span>.&lt;span style="color:#a6e22e">Pointer&lt;/span>()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">default&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">p&lt;/span>.&lt;span style="color:#a6e22e">badVerb&lt;/span>(&lt;span style="color:#a6e22e">verb&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">...&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="2go-只有值传递没有引用传递">2.Go 只有值传递，没有引用传递&lt;/h2>
&lt;p>值传递和引用传递相信大家都比较了解，在函数的调用过程中，如果是值传递，则在传递过程中，其实就是将参数的值复制一份传递到函数中，如果在函数内对其修改，&lt;strong>并不会影响函数外面的参数值&lt;/strong>，而引用传递则相反。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">type&lt;/span> &lt;span style="color:#a6e22e">User&lt;/span> &lt;span style="color:#66d9ef">struct&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">Name&lt;/span> &lt;span style="color:#66d9ef">string&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">Age&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">func&lt;/span> &lt;span style="color:#a6e22e">setNameV1&lt;/span>(&lt;span style="color:#a6e22e">user&lt;/span> &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">User&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">user&lt;/span>.&lt;span style="color:#a6e22e">Name&lt;/span> = &lt;span style="color:#e6db74">&amp;#34;test_v1&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">func&lt;/span> &lt;span style="color:#a6e22e">setNameV2&lt;/span>(&lt;span style="color:#a6e22e">user&lt;/span> &lt;span style="color:#a6e22e">User&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">user&lt;/span>.&lt;span style="color:#a6e22e">Name&lt;/span> = &lt;span style="color:#e6db74">&amp;#34;test_v2&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">func&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">u&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">User&lt;/span>{&lt;span style="color:#a6e22e">Name&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;init&amp;#34;&lt;/span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">fmt&lt;/span>.&lt;span style="color:#a6e22e">Println&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;init&amp;#34;&lt;/span>, &lt;span style="color:#a6e22e">u&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">up&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#f92672">&amp;amp;&lt;/span>&lt;span style="color:#a6e22e">u&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">setNameV1&lt;/span>(&lt;span style="color:#a6e22e">up&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">fmt&lt;/span>.&lt;span style="color:#a6e22e">Println&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;v1&amp;#34;&lt;/span>, &lt;span style="color:#a6e22e">u&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">setNameV2&lt;/span>(&lt;span style="color:#a6e22e">u&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">fmt&lt;/span>.&lt;span style="color:#a6e22e">Println&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;v2&amp;#34;&lt;/span>, &lt;span style="color:#a6e22e">u&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>但在 Golang 中，这所谓的“引用传递”其实&lt;strong>本质上是值传递&lt;/strong>，因为这时候也发生了拷贝，只不过这时拷贝的是指针，而不是变量的值，所以**“Golang 的引用传递其实是引用的拷贝”。**&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/zmk3gz/1661497969124-2aa0ee1c-5b91-4d5c-8d77-fefa46caa8c9.webp" alt="">&lt;/p>
&lt;p>图三&lt;/p>
&lt;p>可以通过以下代码验证：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">type&lt;/span> &lt;span style="color:#a6e22e">User&lt;/span> &lt;span style="color:#66d9ef">struct&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">Name&lt;/span> &lt;span style="color:#66d9ef">string&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">Age&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">func&lt;/span> &lt;span style="color:#a6e22e">setNameV1&lt;/span>(&lt;span style="color:#a6e22e">user&lt;/span> &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">User&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">fmt&lt;/span>.&lt;span style="color:#a6e22e">Printf&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;v1: %p\n&amp;#34;&lt;/span>, &lt;span style="color:#a6e22e">user&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">fmt&lt;/span>.&lt;span style="color:#a6e22e">Printf&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;v1_p: %p\n&amp;#34;&lt;/span>, &lt;span style="color:#f92672">&amp;amp;&lt;/span>&lt;span style="color:#a6e22e">user&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">user&lt;/span>.&lt;span style="color:#a6e22e">Name&lt;/span> = &lt;span style="color:#e6db74">&amp;#34;test_v1&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">func&lt;/span> &lt;span style="color:#a6e22e">setNameV2&lt;/span>(&lt;span style="color:#a6e22e">user&lt;/span> &lt;span style="color:#a6e22e">User&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">fmt&lt;/span>.&lt;span style="color:#a6e22e">Printf&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;v2_p: %p\n&amp;#34;&lt;/span>, &lt;span style="color:#f92672">&amp;amp;&lt;/span>&lt;span style="color:#a6e22e">user&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">user&lt;/span>.&lt;span style="color:#a6e22e">Name&lt;/span> = &lt;span style="color:#e6db74">&amp;#34;test_v2&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">func&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">u&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">User&lt;/span>{&lt;span style="color:#a6e22e">Name&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;init&amp;#34;&lt;/span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">up&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#f92672">&amp;amp;&lt;/span>&lt;span style="color:#a6e22e">u&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">fmt&lt;/span>.&lt;span style="color:#a6e22e">Printf&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;init: %p \n&amp;#34;&lt;/span>, &lt;span style="color:#a6e22e">up&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">setNameV1&lt;/span>(&lt;span style="color:#a6e22e">up&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">setNameV2&lt;/span>(&lt;span style="color:#a6e22e">u&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>注：slice、map 等本质也是如此。&lt;/p>
&lt;h2 id="3for-range与指针">3.&lt;code>for range&lt;/code>与指针&lt;/h2>
&lt;p>&lt;code>for range&lt;/code>是在 Golang 中用于遍历元素，当它与指针结合时，稍不留神就会踩坑，这里有一段经典代码：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">type&lt;/span> &lt;span style="color:#a6e22e">User&lt;/span> &lt;span style="color:#66d9ef">struct&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">Name&lt;/span> &lt;span style="color:#66d9ef">string&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">Age&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">func&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">userList&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> []&lt;span style="color:#a6e22e">User&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">User&lt;/span>{&lt;span style="color:#a6e22e">Name&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;aa&amp;#34;&lt;/span>, &lt;span style="color:#a6e22e">Age&lt;/span>: &lt;span style="color:#ae81ff">1&lt;/span>},
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">User&lt;/span>{&lt;span style="color:#a6e22e">Name&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;bb&amp;#34;&lt;/span>, &lt;span style="color:#a6e22e">Age&lt;/span>: &lt;span style="color:#ae81ff">1&lt;/span>},
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">var&lt;/span> &lt;span style="color:#a6e22e">newUser&lt;/span> []&lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">User&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span> &lt;span style="color:#a6e22e">_&lt;/span>, &lt;span style="color:#a6e22e">u&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#66d9ef">range&lt;/span> &lt;span style="color:#a6e22e">userList&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">newUser&lt;/span> = append(&lt;span style="color:#a6e22e">newUser&lt;/span>, &lt;span style="color:#f92672">&amp;amp;&lt;/span>&lt;span style="color:#a6e22e">u&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span> &lt;span style="color:#a6e22e">_&lt;/span>, &lt;span style="color:#a6e22e">nu&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#66d9ef">range&lt;/span> &lt;span style="color:#a6e22e">newUser&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">fmt&lt;/span>.&lt;span style="color:#a6e22e">Printf&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;%+v&amp;#34;&lt;/span>, &lt;span style="color:#a6e22e">nu&lt;/span>.&lt;span style="color:#a6e22e">Name&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>按照正常的理解，应该第一次输出&lt;code>aa&lt;/code>，第二次输出&lt;code>bb&lt;/code>，但实际上两次都输出了&lt;code>bb&lt;/code>，这是因为 &lt;code>for range&lt;/code> 的时候，&lt;strong>变量 u 实际上只初始化了一次&lt;/strong>（每次遍历的时候 u 都会被重新赋值，但是地址不变），导致每次 append 的时候，&lt;strong>添加的都是同一个内存地址&lt;/strong>，所以最终指向的都是最后一个值 bb。&lt;/p>
&lt;p>我们可以通过打印指针地址来验证：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">func&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">userList&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> []&lt;span style="color:#a6e22e">User&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">User&lt;/span>{&lt;span style="color:#a6e22e">Name&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;aa&amp;#34;&lt;/span>, &lt;span style="color:#a6e22e">Age&lt;/span>: &lt;span style="color:#ae81ff">1&lt;/span>},
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">User&lt;/span>{&lt;span style="color:#a6e22e">Name&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;bb&amp;#34;&lt;/span>, &lt;span style="color:#a6e22e">Age&lt;/span>: &lt;span style="color:#ae81ff">1&lt;/span>},
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">var&lt;/span> &lt;span style="color:#a6e22e">newUser&lt;/span> []&lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">User&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span> &lt;span style="color:#a6e22e">_&lt;/span>, &lt;span style="color:#a6e22e">u&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#66d9ef">range&lt;/span> &lt;span style="color:#a6e22e">userList&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">fmt&lt;/span>.&lt;span style="color:#a6e22e">Printf&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;point: %p\n&amp;#34;&lt;/span>, &lt;span style="color:#f92672">&amp;amp;&lt;/span>&lt;span style="color:#a6e22e">u&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">fmt&lt;/span>.&lt;span style="color:#a6e22e">Printf&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;val: %s\n&amp;#34;&lt;/span>, &lt;span style="color:#a6e22e">u&lt;/span>.&lt;span style="color:#a6e22e">Name&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">newUser&lt;/span> = append(&lt;span style="color:#a6e22e">newUser&lt;/span>, &lt;span style="color:#f92672">&amp;amp;&lt;/span>&lt;span style="color:#a6e22e">u&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">point&lt;/span>: &lt;span style="color:#ae81ff">0xc00000c030&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">val&lt;/span>: &lt;span style="color:#a6e22e">aa&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">point&lt;/span>: &lt;span style="color:#ae81ff">0xc00000c030&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">val&lt;/span>: &lt;span style="color:#a6e22e">bb&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="两种解决方式">两种解决方式&lt;/h3>
&lt;p>使用 &lt;code>for&lt;/code> 代替 &lt;code>for...range&lt;/code>&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">func&lt;/span> &lt;span style="color:#a6e22e">CorrectUsageOfForAndPointer&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">userList&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> []&lt;span style="color:#a6e22e">User&lt;/span>{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {&lt;span style="color:#a6e22e">Name&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;aa&amp;#34;&lt;/span>, &lt;span style="color:#a6e22e">Age&lt;/span>: &lt;span style="color:#ae81ff">1&lt;/span>},
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {&lt;span style="color:#a6e22e">Name&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;bb&amp;#34;&lt;/span>, &lt;span style="color:#a6e22e">Age&lt;/span>: &lt;span style="color:#ae81ff">1&lt;/span>},
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">var&lt;/span> &lt;span style="color:#a6e22e">newUser&lt;/span> []&lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">User&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span> &lt;span style="color:#a6e22e">i&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>; &lt;span style="color:#a6e22e">i&lt;/span> &amp;lt; len(&lt;span style="color:#a6e22e">userList&lt;/span>); &lt;span style="color:#a6e22e">i&lt;/span>&lt;span style="color:#f92672">++&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">newUser&lt;/span> = append(&lt;span style="color:#a6e22e">newUser&lt;/span>, &lt;span style="color:#f92672">&amp;amp;&lt;/span>&lt;span style="color:#a6e22e">userList&lt;/span>[&lt;span style="color:#a6e22e">i&lt;/span>])
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span> &lt;span style="color:#a6e22e">_&lt;/span>, &lt;span style="color:#a6e22e">nu&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#66d9ef">range&lt;/span> &lt;span style="color:#a6e22e">newUser&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">fmt&lt;/span>.&lt;span style="color:#a6e22e">Printf&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;%+v\n&amp;#34;&lt;/span>, &lt;span style="color:#a6e22e">nu&lt;/span>.&lt;span style="color:#a6e22e">Name&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>创建一个 Struct，将数组包含在其中&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">type&lt;/span> &lt;span style="color:#a6e22e">Users&lt;/span> &lt;span style="color:#66d9ef">struct&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">Users&lt;/span> []&lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">User&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">type&lt;/span> &lt;span style="color:#a6e22e">User&lt;/span> &lt;span style="color:#66d9ef">struct&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">Name&lt;/span> &lt;span style="color:#66d9ef">string&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">Age&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 正确用法一
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">func&lt;/span> &lt;span style="color:#a6e22e">CorrectUsageOfForrangeAndPointer&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">usersList&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">Users&lt;/span>{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">Users&lt;/span>: []&lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">User&lt;/span>{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {&lt;span style="color:#a6e22e">Name&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;aa&amp;#34;&lt;/span>, &lt;span style="color:#a6e22e">Age&lt;/span>: &lt;span style="color:#ae81ff">1&lt;/span>},
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {&lt;span style="color:#a6e22e">Name&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;bb&amp;#34;&lt;/span>, &lt;span style="color:#a6e22e">Age&lt;/span>: &lt;span style="color:#ae81ff">1&lt;/span>},
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> },
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">var&lt;/span> &lt;span style="color:#a6e22e">newUser&lt;/span> []&lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">User&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span> &lt;span style="color:#a6e22e">_&lt;/span>, &lt;span style="color:#a6e22e">u&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#66d9ef">range&lt;/span> &lt;span style="color:#a6e22e">usersList&lt;/span>.&lt;span style="color:#a6e22e">Users&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">newUser&lt;/span> = append(&lt;span style="color:#a6e22e">newUser&lt;/span>, &lt;span style="color:#a6e22e">u&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span> &lt;span style="color:#a6e22e">_&lt;/span>, &lt;span style="color:#a6e22e">nu&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#66d9ef">range&lt;/span> &lt;span style="color:#a6e22e">newUser&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">fmt&lt;/span>.&lt;span style="color:#a6e22e">Printf&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;%+v\n&amp;#34;&lt;/span>, &lt;span style="color:#a6e22e">nu&lt;/span>.&lt;span style="color:#a6e22e">Name&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>类似的错误在&lt;code>Goroutine&lt;/code>也经常发生：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">func&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span> &lt;span style="color:#a6e22e">i&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>; &lt;span style="color:#a6e22e">i&lt;/span> &amp;lt; &lt;span style="color:#ae81ff">10&lt;/span>; &lt;span style="color:#a6e22e">i&lt;/span>&lt;span style="color:#f92672">++&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">go&lt;/span> &lt;span style="color:#66d9ef">func&lt;/span>(&lt;span style="color:#a6e22e">idx&lt;/span> &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#66d9ef">int&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">fmt&lt;/span>.&lt;span style="color:#a6e22e">Println&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;go: &amp;#34;&lt;/span>, &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">idx&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }(&lt;span style="color:#f92672">&amp;amp;&lt;/span>&lt;span style="color:#a6e22e">i&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">time&lt;/span>.&lt;span style="color:#a6e22e">Sleep&lt;/span>(&lt;span style="color:#ae81ff">5&lt;/span> &lt;span style="color:#f92672">*&lt;/span> &lt;span style="color:#a6e22e">time&lt;/span>.&lt;span style="color:#a6e22e">Second&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="4闭包与指针">4.闭包与指针&lt;/h2>
&lt;p>什么是闭包，一个函数和对其周围状态（&lt;strong>lexical environment，词法环境&lt;/strong>）的引用捆绑在一起（或者说函数被引用包围），这样的组合就是&lt;strong>闭包&lt;/strong>（&lt;strong>closure&lt;/strong>）。也就是说，闭包让你可以在一个&lt;strong>内层函数中访问到其外层函数的作用域&lt;/strong>。&lt;/p>
&lt;p>当闭包与指针进行结合时，如果闭包里面是一个指针变量，则外部变量的改变，也会影响到该闭包，起到意想不到的效果，让我们继续在举几个例子进行说明：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">func&lt;/span> &lt;span style="color:#a6e22e">incr1&lt;/span>(&lt;span style="color:#a6e22e">x&lt;/span> &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#66d9ef">int&lt;/span>) &lt;span style="color:#66d9ef">func&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#66d9ef">func&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">x&lt;/span> = &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">x&lt;/span> &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">fmt&lt;/span>.&lt;span style="color:#a6e22e">Printf&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;incr point x = %d\n&amp;#34;&lt;/span>, &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">x&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">func&lt;/span> &lt;span style="color:#a6e22e">incr2&lt;/span>(&lt;span style="color:#a6e22e">x&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span>) &lt;span style="color:#66d9ef">func&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#66d9ef">func&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">x&lt;/span> = &lt;span style="color:#a6e22e">x&lt;/span> &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">fmt&lt;/span>.&lt;span style="color:#a6e22e">Printf&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;incr normal x = %d\n&amp;#34;&lt;/span>, &lt;span style="color:#a6e22e">x&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">func&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">x&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">i1&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">incr1&lt;/span>(&lt;span style="color:#f92672">&amp;amp;&lt;/span>&lt;span style="color:#a6e22e">x&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">i2&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">incr2&lt;/span>(&lt;span style="color:#a6e22e">x&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">i1&lt;/span>()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">i2&lt;/span>()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">i1&lt;/span>()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">i2&lt;/span>()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">x&lt;/span> = &lt;span style="color:#ae81ff">100&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">i1&lt;/span>()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">i2&lt;/span>()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">i1&lt;/span>()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">i2&lt;/span>()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="5指针与内存逃逸">5.指针与内存逃逸&lt;/h2>
&lt;p>内存逃逸的场景有很多，这里只讨论由指针引发的内存逃逸。理想情况下，肯定是尽量减少内存逃逸，因为这意味着 GC（垃圾回收）的压力会减小，程序也会运行得更快。不过，使用指针又能减少内存的占用，所以这本质是内存和 GC 的权衡，需要合理使用。&lt;/p>
&lt;p>下面是指针引发的内存逃逸的三种场景（欢迎大家补充~）&lt;/p>
&lt;p>第一种场景：函数返回局部变量的指针&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">type&lt;/span> &lt;span style="color:#a6e22e">Escape&lt;/span> &lt;span style="color:#66d9ef">struct&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">Num1&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">Str1&lt;/span> &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#66d9ef">string&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">Slice&lt;/span> []&lt;span style="color:#66d9ef">int&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">func&lt;/span> &lt;span style="color:#a6e22e">NewEscape&lt;/span>() &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">Escape&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#f92672">&amp;amp;&lt;/span>&lt;span style="color:#a6e22e">Escape&lt;/span>{}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">func&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">e&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#f92672">&amp;amp;&lt;/span>&lt;span style="color:#a6e22e">Escape&lt;/span>{&lt;span style="color:#a6e22e">Num1&lt;/span>: &lt;span style="color:#ae81ff">0&lt;/span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>第二种场景：被已经逃逸的变量引用的指针&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">func&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">e&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">NewEscape&lt;/span>()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">e&lt;/span>.&lt;span style="color:#a6e22e">SetNum1&lt;/span>(&lt;span style="color:#ae81ff">10&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">name&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#e6db74">&amp;#34;aa&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">e&lt;/span>.&lt;span style="color:#a6e22e">Str1&lt;/span> = &lt;span style="color:#f92672">&amp;amp;&lt;/span>&lt;span style="color:#a6e22e">name&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>第三种场景：被指针类型的 slice、map 和 chan 引用的指针&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">func&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">e&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">NewEscape&lt;/span>()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">e&lt;/span>.&lt;span style="color:#a6e22e">SetNum1&lt;/span>(&lt;span style="color:#ae81ff">10&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">name&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#e6db74">&amp;#34;aa&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">e&lt;/span>.&lt;span style="color:#a6e22e">Str1&lt;/span> = &lt;span style="color:#f92672">&amp;amp;&lt;/span>&lt;span style="color:#a6e22e">name&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">arr&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> make([]&lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#66d9ef">int&lt;/span>, &lt;span style="color:#ae81ff">2&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">n&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#ae81ff">10&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">arr&lt;/span>[&lt;span style="color:#ae81ff">0&lt;/span>] = &lt;span style="color:#f92672">&amp;amp;&lt;/span>&lt;span style="color:#a6e22e">n&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>欢迎大家继续补充指针的其他注意事项~&lt;/p>
&lt;h2 id="参考">参考&lt;/h2>
&lt;p>&lt;a href="https://link.juejin.cn/?target=https%3A%2F%2Fdeveloper.51cto.com%2Farticle%2F664004.html">又吵起来了，Go 是传值还是传引用？&lt;/a>&lt;/p>
&lt;p>&lt;a href="https://link.juejin.cn/?target=https%3A%2F%2Fwww.cnblogs.com%2Fhualou%2Fp%2F12069815.html">GO 语言变量逃逸分析&lt;/a>&lt;/p></description></item><item><title>Docs: Reflection(反射)</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/2.%E7%BC%96%E7%A8%8B/%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/go/go-%E6%A0%87%E5%87%86%E5%BA%93/reflection%E5%8F%8D%E5%B0%84/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/2.%E7%BC%96%E7%A8%8B/%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/go/go-%E6%A0%87%E5%87%86%E5%BA%93/reflection%E5%8F%8D%E5%B0%84/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://pkg.go.dev/reflect">Go 包，标准库-reflect&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.cnblogs.com/qcrao-2018/p/10822655.html">博客园-Stefno，深度解密 Go 语言之反射&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>反射是用程序检查其所拥有的结构，尤其是类型的一种能力。可以通过反射来分析一个结构体。反射可以在运行时检查类型和变量，例如它的大小、方法和动态的调用这些方法。
&lt;code>reflect.TypeOf()&lt;/code>和&lt;code>reflect.ValueOf()&lt;/code>两个函数返回被检查对象的类型和值。e.g.&lt;code>var x float64 = 3.4&lt;/code>,那么 reflect.TypeOf(x)返回 float64，reflect.ValueOf(x)返回 x 的值
忠告：反射是一个强大并富有表达力的工具，但是它应该被小心地使用，原因有三：&lt;/p>
&lt;ol>
&lt;li>基于反射的代码是比较脆弱的。对于每一个会导致编译器报告类型错误的问题，在反射中都有与之相对应的误用问题，不同的是编译器会在构建时马上报告错误，而反射则是在真正运行到的时候才会抛出 panic 异常，可能是写完代码很久之后了，而且程序也可能运行了很长的时间。&lt;/li>
&lt;li>即使对应类型提供了相同文档，但是反射的操作不能做静态类型检查，而且大量反射的代码通常难以理解。总是需要小心翼翼地为每个导出的类型和其它接受 interface{}或 reflect.Value 类型参数的函数维护说明文档。&lt;/li>
&lt;li>基于反射的代码通常比正常的代码运行速度慢一到两个数量级。对于一个典型的项目，大部分函数的性能和程序的整体性能关系不大，所以使用反射可能会使程序更加清晰。测试是一个特别适合使用反射的场景，因为每个测试的数据集都很小。但是对于性能关键路径的函数，最好避免使用反射。&lt;/li>
&lt;/ol>
&lt;h1 id="什么是反射">什么是反射&lt;/h1>
&lt;p>反射和 Interface 息息相关，而 Interface 是我们&lt;a href="https://mp.weixin.qq.com/s/EbxkBokYBajkCR-MazL0ZA">上一篇文章&lt;/a>的内容。在开始正文前，和大家说点题外话。
直接看维基百科上的定义：&lt;/p>
&lt;blockquote>
&lt;p>在计算机科学中，反射是指计算机程序在运行时（Run time）可以访问、检测和修改它本身状态或行为的一种能力。用比喻来说，反射就是程序在运行的时候能够“观察”并且修改自己的行为。&lt;/p>
&lt;/blockquote>
&lt;p>那我就要问个问题了：不用反射就不能在运行时访问、检测和修改它本身的状态和行为吗？
问题的回答，其实要首先理解什么叫访问、检测和修改它本身状态或行为，它的本质是什么？
实际上，它的本质是程序在运行期探知对象的类型信息和内存结构，不用反射能行吗？可以的！使用汇编语言，直接和内层打交道，什么信息不能获取？但是，当编程迁移到高级语言上来之后，就不行了！就只能通过&lt;code>反射&lt;/code>来达到此项技能。
不同语言的反射模型不尽相同，有些语言还不支持反射。《Go 语言圣经》中是这样定义反射的：&lt;/p>
&lt;blockquote>
&lt;p>Go 语言提供了一种机制在运行时更新变量和检查它们的值、调用它们的方法，但是在编译时并不知道这些变量的具体类型，这称为反射机制。&lt;/p>
&lt;/blockquote>
&lt;h1 id="为什么要用反射">为什么要用反射&lt;/h1>
&lt;p>需要反射的 2 个常见场景：&lt;/p>
&lt;ol>
&lt;li>有时你需要编写一个函数，但是并不知道传给你的参数类型是什么，可能是没约定好；也可能是传入的类型很多，这些类型并不能统一表示。这时反射就会用的上了。&lt;/li>
&lt;li>有时候需要根据某些条件决定调用哪个函数，比如根据用户的输入来决定。这时就需要对函数和函数的参数进行反射，在运行期间动态地执行函数。&lt;/li>
&lt;/ol>
&lt;p>在讲反射的原理以及如何用之前，还是说几点不使用反射的理由：&lt;/p>
&lt;ol>
&lt;li>与反射相关的代码，经常是难以阅读的。在软件工程中，代码可读性也是一个非常重要的指标。&lt;/li>
&lt;li>Go 语言作为一门静态语言，编码过程中，编译器能提前发现一些类型错误，但是对于反射代码是无能为力的。所以包含反射相关的代码，很可能会运行很久，才会出错，这时候经常是直接 panic，可能会造成严重的后果。&lt;/li>
&lt;li>反射对性能影响还是比较大的，比正常代码运行速度慢一到两个数量级。所以，对于一个项目中处于运行效率关键位置的代码，尽量避免使用反射特性。&lt;/li>
&lt;/ol>
&lt;h1 id="反射是如何实现的">反射是如何实现的&lt;/h1>
&lt;p>上一篇文章讲到了 &lt;code>interface&lt;/code>，它是 Go 语言实现抽象的一个非常强大的工具。当向接口变量赋予一个实体类型的时候，接口会存储实体的类型信息，反射就是通过接口的类型信息实现的，反射建立在类型的基础上。
Go 语言在 reflect 包里定义了各种类型，实现了反射的各种函数，通过它们可以在运行时检测类型的信息、改变类型的值。&lt;/p>
&lt;h2 id="types-和-interface">types 和 interface&lt;/h2>
&lt;p>Go 语言中，每个变量都有一个静态类型，在编译阶段就确定了的，比如 &lt;code>int, float64, []int&lt;/code> 等等。注意，这个类型是声明时候的类型，不是底层数据类型。
Go 官方博客里就举了一个例子：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">type&lt;/span> &lt;span style="color:#a6e22e">MyInt&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">var&lt;/span> &lt;span style="color:#a6e22e">i&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">var&lt;/span> &lt;span style="color:#a6e22e">j&lt;/span> &lt;span style="color:#a6e22e">MyInt&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>尽管 i，j 的底层类型都是 int，但我们知道，他们是不同的静态类型，除非进行类型转换，否则，i 和 j 不能同时出现在等号两侧。j 的静态类型就是 &lt;code>MyInt&lt;/code>。
反射主要与 interface{} 类型相关。前面一篇关于 interface 相关的文章已经探讨过 interface 的底层结构，这里再来复习一下。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">type&lt;/span> &lt;span style="color:#a6e22e">iface&lt;/span> &lt;span style="color:#66d9ef">struct&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">tab&lt;/span> &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">itab&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">data&lt;/span> &lt;span style="color:#a6e22e">unsafe&lt;/span>.&lt;span style="color:#a6e22e">Pointer&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">type&lt;/span> &lt;span style="color:#a6e22e">itab&lt;/span> &lt;span style="color:#66d9ef">struct&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">inter&lt;/span> &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">interfacetype&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">_type&lt;/span> &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">_type&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">link&lt;/span> &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">itab&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">hash&lt;/span> &lt;span style="color:#66d9ef">uint32&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">bad&lt;/span> &lt;span style="color:#66d9ef">bool&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">inhash&lt;/span> &lt;span style="color:#66d9ef">bool&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">unused&lt;/span> [&lt;span style="color:#ae81ff">2&lt;/span>]&lt;span style="color:#66d9ef">byte&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">fun&lt;/span> [&lt;span style="color:#ae81ff">1&lt;/span>]&lt;span style="color:#66d9ef">uintptr&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>其中 &lt;code>itab&lt;/code> 由具体类型 &lt;code>_type&lt;/code> 以及 &lt;code>interfacetype&lt;/code> 组成。&lt;code>_type&lt;/code> 表示具体类型，而 &lt;code>interfacetype&lt;/code> 则表示具体类型实现的接口类型。
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/tgz38n/1616980149620-8d9ae6eb-1f40-4451-af9c-68139cf480c4.png" alt="">
实际上，iface 描述的是非空接口，它包含方法；与之相对的是 &lt;code>eface&lt;/code>，描述的是空接口，不包含任何方法，Go 语言里有的类型都 &lt;code>“实现了”&lt;/code> 空接口。&lt;/p>
&lt;pre>&lt;code>type eface struct {
_type *_type
data unsafe.Pointer
}
&lt;/code>&lt;/pre>
&lt;p>相比 &lt;code>iface&lt;/code>，&lt;code>eface&lt;/code> 就比较简单了。只维护了一个 &lt;code>_type&lt;/code> 字段，表示空接口所承载的具体的实体类型。&lt;code>data&lt;/code> 描述了具体的值。
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/tgz38n/1616980149625-83be7464-5375-4d6f-a02d-2fc237058398.png" alt="">
还是用 Go 官方关于反射的博客里的例子，当然，我会用图形来详细解释，结合两者来看会更清楚。顺便提一下，搞技术的不要害怕英文资料，要想成为技术专家，读英文原始资料是技术提高的一条必经之路。
先明确一点：接口变量可以存储任何实现了接口定义的所有方法的变量。
Go 语言中最常见的就是 &lt;code>Reader&lt;/code> 和 &lt;code>Writer&lt;/code> 接口：&lt;/p>
&lt;pre>&lt;code>type Reader interface {
Read(p []byte) (n int, err error)
}
type Writer interface {
Write(p []byte) (n int, err error)
}
&lt;/code>&lt;/pre>
&lt;p>接下来，就是接口之间的各种转换和赋值了：&lt;/p>
&lt;pre>&lt;code>var r io.Reader
tty, err := os.OpenFile(&amp;quot;/Users/qcrao/Desktop/test&amp;quot;, os.O_RDWR, 0)
if err != nil {
return nil, err
}
r = tty
&lt;/code>&lt;/pre>
&lt;p>首先声明 &lt;code>r&lt;/code> 的类型是 &lt;code>io.Reader&lt;/code>，注意，这是 &lt;code>r&lt;/code> 的静态类型，此时它的动态类型为 &lt;code>nil&lt;/code>，并且它的动态值也是 &lt;code>nil&lt;/code>。
之后，&lt;code>r = tty&lt;/code> 这一语句，将 &lt;code>r&lt;/code> 的动态类型变成 &lt;code>*os.File&lt;/code>，动态值则变成非空，表示打开的文件对象。这时，r 可以用&lt;code>&amp;lt;value, type&amp;gt;&lt;/code>对来表示为： &lt;code>&amp;lt;tty, *os.File&amp;gt;&lt;/code>。
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/tgz38n/1616980149687-af8ef79f-2537-497d-bc50-134e4725a0c9.png" alt="">
注意看上图，此时虽然 &lt;code>fun&lt;/code> 所指向的函数只有一个 &lt;code>Read&lt;/code> 函数，其实 &lt;code>*os.File&lt;/code> 还包含 &lt;code>Write&lt;/code> 函数，也就是说 &lt;code>*os.File&lt;/code> 其实还实现了 &lt;code>io.Writer&lt;/code> 接口。因此下面的断言语句可以执行：&lt;/p>
&lt;pre>&lt;code>var w io.Writer
w = r.(io.Writer)
&lt;/code>&lt;/pre>
&lt;p>之所以用断言，而不能直接赋值，是因为 &lt;code>r&lt;/code> 的静态类型是 &lt;code>io.Reader&lt;/code>，并没有实现 &lt;code>io.Writer&lt;/code> 接口。断言能否成功，看 &lt;code>r&lt;/code> 的动态类型是否符合要求。
这样，w 也可以表示成 &lt;code>&amp;lt;tty, *os.File&amp;gt;&lt;/code>，仅管它和 &lt;code>r&lt;/code> 一样，但是 w 可调用的函数取决于它的静态类型 &lt;code>io.Writer&lt;/code>，也就是说它只能有这样的调用形式： &lt;code>w.Write()&lt;/code> 。&lt;code>w&lt;/code> 的内存形式如下图：
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/tgz38n/1616980149626-01ade0ef-5895-40ae-a674-955cb575928c.png" alt="">
和 &lt;code>r&lt;/code> 相比，仅仅是 &lt;code>fun&lt;/code> 对应的函数变了：&lt;code>Read -&amp;gt; Write&lt;/code>。
最后，再来一个赋值：&lt;/p>
&lt;pre>&lt;code>var empty interface{}
empty = w
&lt;/code>&lt;/pre>
&lt;p>由于 &lt;code>empty&lt;/code> 是一个空接口，因此所有的类型都实现了它，w 可以直接赋给它，不需要执行断言操作。
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/tgz38n/1616980149635-574005ab-9192-4e44-b076-b481e10b091d.png" alt="">
从上面的三张图可以看到，interface 包含三部分信息：&lt;code>_type&lt;/code> 是类型信息，&lt;code>*data&lt;/code> 指向实际类型的实际值，&lt;code>itab&lt;/code> 包含实际类型的信息，包括大小、包路径，还包含绑定在类型上的各种方法（图上没有画出方法），补充一下关于 os.File 结构体的图：
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/tgz38n/1616980149693-bbbe2f1b-3087-420f-8ee1-22ddb31eb3e7.png" alt="">
这一节的最后，复习一下上一篇关于 interface 的文章，提到的一个技巧，这里再展示一下：
先参考源码，分别定义一个&lt;code>“伪装”&lt;/code>的 iface 和 eface 结构体。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">type&lt;/span> &lt;span style="color:#a6e22e">iface&lt;/span> &lt;span style="color:#66d9ef">struct&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">tab&lt;/span> &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">itab&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">data&lt;/span> &lt;span style="color:#a6e22e">unsafe&lt;/span>.&lt;span style="color:#a6e22e">Pointer&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">type&lt;/span> &lt;span style="color:#a6e22e">itab&lt;/span> &lt;span style="color:#66d9ef">struct&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">inter&lt;/span> &lt;span style="color:#66d9ef">uintptr&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">_type&lt;/span> &lt;span style="color:#66d9ef">uintptr&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">link&lt;/span> &lt;span style="color:#66d9ef">uintptr&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">hash&lt;/span> &lt;span style="color:#66d9ef">uint32&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">_&lt;/span> [&lt;span style="color:#ae81ff">4&lt;/span>]&lt;span style="color:#66d9ef">byte&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">fun&lt;/span> [&lt;span style="color:#ae81ff">1&lt;/span>]&lt;span style="color:#66d9ef">uintptr&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">type&lt;/span> &lt;span style="color:#a6e22e">eface&lt;/span> &lt;span style="color:#66d9ef">struct&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">_type&lt;/span> &lt;span style="color:#66d9ef">uintptr&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">data&lt;/span> &lt;span style="color:#a6e22e">unsafe&lt;/span>.&lt;span style="color:#a6e22e">Pointer&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>接着，将接口变量占据的内存内容强制解释成上面定义的类型，再打印出来：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">package&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">import&lt;/span> (
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#34;os&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#34;fmt&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#34;io&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#34;unsafe&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">func&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">var&lt;/span> &lt;span style="color:#a6e22e">r&lt;/span> &lt;span style="color:#a6e22e">io&lt;/span>.&lt;span style="color:#a6e22e">Reader&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">fmt&lt;/span>.&lt;span style="color:#a6e22e">Printf&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;initial r: %T, %v\n&amp;#34;&lt;/span>, &lt;span style="color:#a6e22e">r&lt;/span>, &lt;span style="color:#a6e22e">r&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">tty&lt;/span>, &lt;span style="color:#a6e22e">_&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">os&lt;/span>.&lt;span style="color:#a6e22e">OpenFile&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;/Users/qcrao/Desktop/test&amp;#34;&lt;/span>, &lt;span style="color:#a6e22e">os&lt;/span>.&lt;span style="color:#a6e22e">O_RDWR&lt;/span>, &lt;span style="color:#ae81ff">0&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">fmt&lt;/span>.&lt;span style="color:#a6e22e">Printf&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;tty: %T, %v\n&amp;#34;&lt;/span>, &lt;span style="color:#a6e22e">tty&lt;/span>, &lt;span style="color:#a6e22e">tty&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 给 r 赋值
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#a6e22e">r&lt;/span> = &lt;span style="color:#a6e22e">tty&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">fmt&lt;/span>.&lt;span style="color:#a6e22e">Printf&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;r: %T, %v\n&amp;#34;&lt;/span>, &lt;span style="color:#a6e22e">r&lt;/span>, &lt;span style="color:#a6e22e">r&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">rIface&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> (&lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">iface&lt;/span>)(&lt;span style="color:#a6e22e">unsafe&lt;/span>.&lt;span style="color:#a6e22e">Pointer&lt;/span>(&lt;span style="color:#f92672">&amp;amp;&lt;/span>&lt;span style="color:#a6e22e">r&lt;/span>))
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">fmt&lt;/span>.&lt;span style="color:#a6e22e">Printf&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;r: iface.tab._type = %#x, iface.data = %#x\n&amp;#34;&lt;/span>, &lt;span style="color:#a6e22e">rIface&lt;/span>.&lt;span style="color:#a6e22e">tab&lt;/span>.&lt;span style="color:#a6e22e">_type&lt;/span>, &lt;span style="color:#a6e22e">rIface&lt;/span>.&lt;span style="color:#a6e22e">data&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 给 w 赋值
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">var&lt;/span> &lt;span style="color:#a6e22e">w&lt;/span> &lt;span style="color:#a6e22e">io&lt;/span>.&lt;span style="color:#a6e22e">Writer&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">w&lt;/span> = &lt;span style="color:#a6e22e">r&lt;/span>.(&lt;span style="color:#a6e22e">io&lt;/span>.&lt;span style="color:#a6e22e">Writer&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">fmt&lt;/span>.&lt;span style="color:#a6e22e">Printf&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;w: %T, %v\n&amp;#34;&lt;/span>, &lt;span style="color:#a6e22e">w&lt;/span>, &lt;span style="color:#a6e22e">w&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">wIface&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> (&lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">iface&lt;/span>)(&lt;span style="color:#a6e22e">unsafe&lt;/span>.&lt;span style="color:#a6e22e">Pointer&lt;/span>(&lt;span style="color:#f92672">&amp;amp;&lt;/span>&lt;span style="color:#a6e22e">w&lt;/span>))
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">fmt&lt;/span>.&lt;span style="color:#a6e22e">Printf&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;w: iface.tab._type = %#x, iface.data = %#x\n&amp;#34;&lt;/span>, &lt;span style="color:#a6e22e">wIface&lt;/span>.&lt;span style="color:#a6e22e">tab&lt;/span>.&lt;span style="color:#a6e22e">_type&lt;/span>, &lt;span style="color:#a6e22e">wIface&lt;/span>.&lt;span style="color:#a6e22e">data&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 给 empty 赋值
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">var&lt;/span> &lt;span style="color:#a6e22e">empty&lt;/span> &lt;span style="color:#66d9ef">interface&lt;/span>{}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">empty&lt;/span> = &lt;span style="color:#a6e22e">w&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">fmt&lt;/span>.&lt;span style="color:#a6e22e">Printf&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;empty: %T, %v\n&amp;#34;&lt;/span>, &lt;span style="color:#a6e22e">empty&lt;/span>, &lt;span style="color:#a6e22e">empty&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">emptyEface&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> (&lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">eface&lt;/span>)(&lt;span style="color:#a6e22e">unsafe&lt;/span>.&lt;span style="color:#a6e22e">Pointer&lt;/span>(&lt;span style="color:#f92672">&amp;amp;&lt;/span>&lt;span style="color:#a6e22e">empty&lt;/span>))
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">fmt&lt;/span>.&lt;span style="color:#a6e22e">Printf&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;empty: eface._type = %#x, eface.data = %#x\n&amp;#34;&lt;/span>, &lt;span style="color:#a6e22e">emptyEface&lt;/span>.&lt;span style="color:#a6e22e">_type&lt;/span>, &lt;span style="color:#a6e22e">emptyEface&lt;/span>.&lt;span style="color:#a6e22e">data&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>运行结果：&lt;/p>
&lt;pre>&lt;code>initial r: &amp;lt;nil&amp;gt;, &amp;lt;nil&amp;gt;
tty: *os.File, &amp;amp;{0xc4200820f0}
r: *os.File, &amp;amp;{0xc4200820f0}
r: iface.tab._type = 0x10bfcc0, iface.data = 0xc420080020
w: *os.File, &amp;amp;{0xc4200820f0}
w: iface.tab._type = 0x10bfcc0, iface.data = 0xc420080020
empty: *os.File, &amp;amp;{0xc4200820f0}
empty: eface._type = 0x10bfcc0, eface.data = 0xc420080020
&lt;/code>&lt;/pre>
&lt;p>&lt;code>r，w，empty&lt;/code> 的动态类型和动态值都一样。不再详细解释了，结合前面的图可以看得非常清晰。&lt;/p>
&lt;h2 id="反射的基本函数">反射的基本函数&lt;/h2>
&lt;p>reflect 包里定义了一个接口和一个结构体，即 &lt;code>reflect.Type&lt;/code> 和 &lt;code>reflect.Value&lt;/code>，它们提供很多函数来获取存储在接口里的类型信息。
&lt;code>reflect.Type&lt;/code> 主要提供关于类型相关的信息，所以它和 &lt;code>_type&lt;/code> 关联比较紧密；&lt;code>reflect.Value&lt;/code> 则结合 &lt;code>_type&lt;/code> 和 &lt;code>data&lt;/code> 两者，因此程序员可以获取甚至改变类型的值。
reflect 包中提供了两个基础的关于反射的函数来获取上述的接口和结构体：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">func&lt;/span> &lt;span style="color:#a6e22e">TypeOf&lt;/span>(&lt;span style="color:#a6e22e">i&lt;/span> &lt;span style="color:#66d9ef">interface&lt;/span>{}) &lt;span style="color:#a6e22e">Type&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">func&lt;/span> &lt;span style="color:#a6e22e">ValueOf&lt;/span>(&lt;span style="color:#a6e22e">i&lt;/span> &lt;span style="color:#66d9ef">interface&lt;/span>{}) &lt;span style="color:#a6e22e">Value&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="typeof-函数与-type-接口">TypeOf() 函数与 Type{} 接口&lt;/h3>
&lt;p>&lt;code>TypeOf&lt;/code> 函数用来提取一个接口中值的类型信息。由于它的输入参数是一个空的 &lt;code>interface{}&lt;/code>，调用此函数时，实参会先被转化为 &lt;code>interface{}&lt;/code>类型。这样，实参的类型信息、方法集、值信息都存储到 &lt;code>interface{}&lt;/code> 变量里了。
看下源码：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">func&lt;/span> &lt;span style="color:#a6e22e">TypeOf&lt;/span>(&lt;span style="color:#a6e22e">i&lt;/span> &lt;span style="color:#66d9ef">interface&lt;/span>{}) &lt;span style="color:#a6e22e">Type&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">eface&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#f92672">*&lt;/span>(&lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">emptyInterface&lt;/span>)(&lt;span style="color:#a6e22e">unsafe&lt;/span>.&lt;span style="color:#a6e22e">Pointer&lt;/span>(&lt;span style="color:#f92672">&amp;amp;&lt;/span>&lt;span style="color:#a6e22e">i&lt;/span>))
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#a6e22e">toType&lt;/span>(&lt;span style="color:#a6e22e">eface&lt;/span>.&lt;span style="color:#a6e22e">typ&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>这里的 &lt;code>emptyInterface&lt;/code> 和上面提到的 &lt;code>eface&lt;/code> 是一回事（字段名略有差异，字段是相同的），且在不同的源码包：前者在 &lt;code>reflect&lt;/code> 包，后者在 &lt;code>runtime&lt;/code> 包。 &lt;code>eface.typ&lt;/code> 就是动态类型。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">type&lt;/span> &lt;span style="color:#a6e22e">emptyInterface&lt;/span> &lt;span style="color:#66d9ef">struct&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">typ&lt;/span> &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">rtype&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">word&lt;/span> &lt;span style="color:#a6e22e">unsafe&lt;/span>.&lt;span style="color:#a6e22e">Pointer&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>至于 &lt;code>toType&lt;/code> 函数，只是做了一个类型转换：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">func&lt;/span> &lt;span style="color:#a6e22e">toType&lt;/span>(&lt;span style="color:#a6e22e">t&lt;/span> &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">rtype&lt;/span>) &lt;span style="color:#a6e22e">Type&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> &lt;span style="color:#a6e22e">t&lt;/span> &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#66d9ef">nil&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#66d9ef">nil&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#a6e22e">t&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>注意，返回值 &lt;code>Type&lt;/code> 实际上是一个接口，定义了很多方法，用来获取类型相关的各种信息，而 &lt;code>*rtype&lt;/code> 实现了 &lt;code>Type&lt;/code> 接口。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">type&lt;/span> &lt;span style="color:#a6e22e">Type&lt;/span> &lt;span style="color:#66d9ef">interface&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 所有的类型都可以调用下面这些函数
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#75715e">// 此类型的变量对齐后所占用的字节数
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#a6e22e">Align&lt;/span>() &lt;span style="color:#66d9ef">int&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 如果是 struct 的字段，对齐后占用的字节数
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#a6e22e">FieldAlign&lt;/span>() &lt;span style="color:#66d9ef">int&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 返回类型方法集里的第 `i` (传入的参数)个方法
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#a6e22e">Method&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span>) &lt;span style="color:#a6e22e">Method&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 通过名称获取方法
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#a6e22e">MethodByName&lt;/span>(&lt;span style="color:#66d9ef">string&lt;/span>) (&lt;span style="color:#a6e22e">Method&lt;/span>, &lt;span style="color:#66d9ef">bool&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 获取类型方法集里导出的方法个数
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#a6e22e">NumMethod&lt;/span>() &lt;span style="color:#66d9ef">int&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 类型名称
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#a6e22e">Name&lt;/span>() &lt;span style="color:#66d9ef">string&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 返回类型所在的路径，如：encoding/base64
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#a6e22e">PkgPath&lt;/span>() &lt;span style="color:#66d9ef">string&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 返回类型的大小，和 unsafe.Sizeof 功能类似
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#a6e22e">Size&lt;/span>() &lt;span style="color:#66d9ef">uintptr&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 返回类型的字符串表示形式
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#a6e22e">String&lt;/span>() &lt;span style="color:#66d9ef">string&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 返回类型的类型值
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#a6e22e">Kind&lt;/span>() &lt;span style="color:#a6e22e">Kind&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 类型是否实现了接口 u
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#a6e22e">Implements&lt;/span>(&lt;span style="color:#a6e22e">u&lt;/span> &lt;span style="color:#a6e22e">Type&lt;/span>) &lt;span style="color:#66d9ef">bool&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 是否可以赋值给 u
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#a6e22e">AssignableTo&lt;/span>(&lt;span style="color:#a6e22e">u&lt;/span> &lt;span style="color:#a6e22e">Type&lt;/span>) &lt;span style="color:#66d9ef">bool&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 是否可以类型转换成 u
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#a6e22e">ConvertibleTo&lt;/span>(&lt;span style="color:#a6e22e">u&lt;/span> &lt;span style="color:#a6e22e">Type&lt;/span>) &lt;span style="color:#66d9ef">bool&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 类型是否可以比较
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#a6e22e">Comparable&lt;/span>() &lt;span style="color:#66d9ef">bool&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 下面这些函数只有特定类型可以调用
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#75715e">// 如：Key, Elem 两个方法就只能是 Map 类型才能调用
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 类型所占据的位数
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#a6e22e">Bits&lt;/span>() &lt;span style="color:#66d9ef">int&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 返回通道的方向，只能是 chan 类型调用
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#a6e22e">ChanDir&lt;/span>() &lt;span style="color:#a6e22e">ChanDir&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 返回类型是否是可变参数，只能是 func 类型调用
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#75715e">// 比如 t 是类型 func(x int, y ... float64)
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#75715e">// 那么 t.IsVariadic() == true
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#a6e22e">IsVariadic&lt;/span>() &lt;span style="color:#66d9ef">bool&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 返回内部子元素类型，只能由类型 Array, Chan, Map, Ptr, or Slice 调用
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#a6e22e">Elem&lt;/span>() &lt;span style="color:#a6e22e">Type&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 返回结构体类型的第 i 个字段，只能是结构体类型调用
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#75715e">// 如果 i 超过了总字段数，就会 panic
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#a6e22e">Field&lt;/span>(&lt;span style="color:#a6e22e">i&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span>) &lt;span style="color:#a6e22e">StructField&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 返回嵌套的结构体的字段
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#a6e22e">FieldByIndex&lt;/span>(&lt;span style="color:#a6e22e">index&lt;/span> []&lt;span style="color:#66d9ef">int&lt;/span>) &lt;span style="color:#a6e22e">StructField&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 通过字段名称获取字段
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#a6e22e">FieldByName&lt;/span>(&lt;span style="color:#a6e22e">name&lt;/span> &lt;span style="color:#66d9ef">string&lt;/span>) (&lt;span style="color:#a6e22e">StructField&lt;/span>, &lt;span style="color:#66d9ef">bool&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// FieldByNameFunc returns the struct field with a name
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#75715e">// 返回名称符合 func 函数的字段
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#a6e22e">FieldByNameFunc&lt;/span>(&lt;span style="color:#a6e22e">match&lt;/span> &lt;span style="color:#66d9ef">func&lt;/span>(&lt;span style="color:#66d9ef">string&lt;/span>) &lt;span style="color:#66d9ef">bool&lt;/span>) (&lt;span style="color:#a6e22e">StructField&lt;/span>, &lt;span style="color:#66d9ef">bool&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 获取函数类型的第 i 个参数的类型
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#a6e22e">In&lt;/span>(&lt;span style="color:#a6e22e">i&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span>) &lt;span style="color:#a6e22e">Type&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 返回 map 的 key 类型，只能由类型 map 调用
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#a6e22e">Key&lt;/span>() &lt;span style="color:#a6e22e">Type&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 返回 Array 的长度，只能由类型 Array 调用
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#a6e22e">Len&lt;/span>() &lt;span style="color:#66d9ef">int&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 返回类型字段的数量，只能由类型 Struct 调用
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#a6e22e">NumField&lt;/span>() &lt;span style="color:#66d9ef">int&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 返回函数类型的输入参数个数
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#a6e22e">NumIn&lt;/span>() &lt;span style="color:#66d9ef">int&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 返回函数类型的返回值个数
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#a6e22e">NumOut&lt;/span>() &lt;span style="color:#66d9ef">int&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 返回函数类型的第 i 个值的类型
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#a6e22e">Out&lt;/span>(&lt;span style="color:#a6e22e">i&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span>) &lt;span style="color:#a6e22e">Type&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 返回类型结构体的相同部分
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#a6e22e">common&lt;/span>() &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">rtype&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 返回类型结构体的不同部分
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#a6e22e">uncommon&lt;/span>() &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">uncommonType&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>可见 &lt;code>Type&lt;/code> 定义了非常多的方法，通过它们可以获取类型的一切信息，大家一定要完整的过一遍上面所有的方法。
注意到 &lt;code>Type&lt;/code> 方法集的倒数第二个方法 &lt;code>common&lt;/code>
返回的 &lt;code>rtype&lt;/code>类型，它和上一篇文章讲到的 &lt;code>_type&lt;/code> 是一回事，而且源代码里也注释了：两边要保持同步：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// rtype must be kept in sync with ../runtime/type.go:/^type._type.
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">type&lt;/span> &lt;span style="color:#a6e22e">rtype&lt;/span> &lt;span style="color:#66d9ef">struct&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">size&lt;/span> &lt;span style="color:#66d9ef">uintptr&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">ptrdata&lt;/span> &lt;span style="color:#66d9ef">uintptr&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">hash&lt;/span> &lt;span style="color:#66d9ef">uint32&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">tflag&lt;/span> &lt;span style="color:#a6e22e">tflag&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">align&lt;/span> &lt;span style="color:#66d9ef">uint8&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">fieldAlign&lt;/span> &lt;span style="color:#66d9ef">uint8&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">kind&lt;/span> &lt;span style="color:#66d9ef">uint8&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">alg&lt;/span> &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">typeAlg&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">gcdata&lt;/span> &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#66d9ef">byte&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">str&lt;/span> &lt;span style="color:#a6e22e">nameOff&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">ptrToThis&lt;/span> &lt;span style="color:#a6e22e">typeOff&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>所有的类型都会包含 &lt;code>rtype&lt;/code> 这个字段，表示各种类型的公共信息；另外，不同类型包含自己的一些独特的部分。
比如下面的 &lt;code>arrayType&lt;/code> 和 &lt;code>chanType&lt;/code> 都包含 &lt;code>rytpe&lt;/code>，而前者还包含 slice，len 等和数组相关的信息；后者则包含 &lt;code>dir&lt;/code> 表示通道方向的信息。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// arrayType represents a fixed array type.
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">type&lt;/span> &lt;span style="color:#a6e22e">arrayType&lt;/span> &lt;span style="color:#66d9ef">struct&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">rtype&lt;/span> &lt;span style="color:#e6db74">`reflect:&amp;#34;array&amp;#34;`&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">elem&lt;/span> &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">rtype&lt;/span> &lt;span style="color:#75715e">// array element type
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#a6e22e">slice&lt;/span> &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">rtype&lt;/span> &lt;span style="color:#75715e">// slice type
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#a6e22e">len&lt;/span> &lt;span style="color:#66d9ef">uintptr&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// chanType represents a channel type.
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">type&lt;/span> &lt;span style="color:#a6e22e">chanType&lt;/span> &lt;span style="color:#66d9ef">struct&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">rtype&lt;/span> &lt;span style="color:#e6db74">`reflect:&amp;#34;chan&amp;#34;`&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">elem&lt;/span> &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">rtype&lt;/span> &lt;span style="color:#75715e">// channel element type
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#a6e22e">dir&lt;/span> &lt;span style="color:#66d9ef">uintptr&lt;/span> &lt;span style="color:#75715e">// channel direction (ChanDir)
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>注意到，&lt;code>Type&lt;/code> 接口实现了 &lt;code>String()&lt;/code> 函数，满足 &lt;code>fmt.Stringer&lt;/code> 接口，因此使用 &lt;code>fmt.Println&lt;/code> 打印的时候，输出的是 &lt;code>String()&lt;/code> 的结果。另外，&lt;code>fmt.Printf()&lt;/code> 函数，如果使用 &lt;code>%T&lt;/code> 来作为格式参数，输出的是 &lt;code>reflect.TypeOf&lt;/code> 的结果，也就是动态类型。例如：&lt;/p>
&lt;pre>&lt;code>fmt.Printf(&amp;quot;%T&amp;quot;, 3) // int
&lt;/code>&lt;/pre>
&lt;h3 id="valueof-函数与-value-结构体">ValueOf() 函数与 Value{} 结构体&lt;/h3>
&lt;p>讲完了 &lt;code>TypeOf&lt;/code> 函数，再来看一下 &lt;code>ValueOf&lt;/code> 函数。返回值 &lt;code>reflect.Value&lt;/code> 表示 &lt;code>interface{}&lt;/code> 里存储的实际变量，它能提供实际变量的各种信息。相关的方法常常是需要结合类型信息和值信息。例如，如果要提取一个结构体的字段信息，那就需要用到 _type (具体到这里是指 structType) 类型持有的关于结构体的字段信息、偏移信息，以及 &lt;code>*data&lt;/code> 所指向的内容 —— 结构体的实际值。
源码如下：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">func&lt;/span> &lt;span style="color:#a6e22e">ValueOf&lt;/span>(&lt;span style="color:#a6e22e">i&lt;/span> &lt;span style="color:#66d9ef">interface&lt;/span>{}) &lt;span style="color:#a6e22e">Value&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> &lt;span style="color:#a6e22e">i&lt;/span> &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#66d9ef">nil&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#a6e22e">Value&lt;/span>{}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// ……
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#a6e22e">unpackEface&lt;/span>(&lt;span style="color:#a6e22e">i&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 分解 eface
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">func&lt;/span> &lt;span style="color:#a6e22e">unpackEface&lt;/span>(&lt;span style="color:#a6e22e">i&lt;/span> &lt;span style="color:#66d9ef">interface&lt;/span>{}) &lt;span style="color:#a6e22e">Value&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">e&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> (&lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">emptyInterface&lt;/span>)(&lt;span style="color:#a6e22e">unsafe&lt;/span>.&lt;span style="color:#a6e22e">Pointer&lt;/span>(&lt;span style="color:#f92672">&amp;amp;&lt;/span>&lt;span style="color:#a6e22e">i&lt;/span>))
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">t&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">e&lt;/span>.&lt;span style="color:#a6e22e">typ&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> &lt;span style="color:#a6e22e">t&lt;/span> &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#66d9ef">nil&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#a6e22e">Value&lt;/span>{}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">f&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">flag&lt;/span>(&lt;span style="color:#a6e22e">t&lt;/span>.&lt;span style="color:#a6e22e">Kind&lt;/span>())
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> &lt;span style="color:#a6e22e">ifaceIndir&lt;/span>(&lt;span style="color:#a6e22e">t&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">f&lt;/span> &lt;span style="color:#f92672">|=&lt;/span> &lt;span style="color:#a6e22e">flagIndir&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#a6e22e">Value&lt;/span>{&lt;span style="color:#a6e22e">t&lt;/span>, &lt;span style="color:#a6e22e">e&lt;/span>.&lt;span style="color:#a6e22e">word&lt;/span>, &lt;span style="color:#a6e22e">f&lt;/span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>从源码看，比较简单：将先将 &lt;code>i&lt;/code> 转换成 &lt;code>*emptyInterface&lt;/code> 类型， 再将它的 &lt;code>typ&lt;/code> 字段和 &lt;code>word&lt;/code> 字段以及一个标志位字段组装成一个 &lt;code>Value&lt;/code> 结构体，而这就是 &lt;code>ValueOf&lt;/code> 函数的返回值，它包含类型结构体指针、真实数据的地址、标志位。
Value 结构体定义了很多方法，通过这些方法可以直接操作 Value 字段 ptr 所指向的实际数据：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 设置切片的 len 字段，如果类型不是切片，就会panic
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">func&lt;/span> (&lt;span style="color:#a6e22e">v&lt;/span> &lt;span style="color:#a6e22e">Value&lt;/span>) &lt;span style="color:#a6e22e">SetLen&lt;/span>(&lt;span style="color:#a6e22e">n&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 设置切片的 cap 字段
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">func&lt;/span> (&lt;span style="color:#a6e22e">v&lt;/span> &lt;span style="color:#a6e22e">Value&lt;/span>) &lt;span style="color:#a6e22e">SetCap&lt;/span>(&lt;span style="color:#a6e22e">n&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 设置字典的 kv
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">func&lt;/span> (&lt;span style="color:#a6e22e">v&lt;/span> &lt;span style="color:#a6e22e">Value&lt;/span>) &lt;span style="color:#a6e22e">SetMapIndex&lt;/span>(&lt;span style="color:#a6e22e">key&lt;/span>, &lt;span style="color:#a6e22e">val&lt;/span> &lt;span style="color:#a6e22e">Value&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 返回切片、字符串、数组的索引 i 处的值
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">func&lt;/span> (&lt;span style="color:#a6e22e">v&lt;/span> &lt;span style="color:#a6e22e">Value&lt;/span>) &lt;span style="color:#a6e22e">Index&lt;/span>(&lt;span style="color:#a6e22e">i&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span>) &lt;span style="color:#a6e22e">Value&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 根据名称获取结构体的内部字段值
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">func&lt;/span> (&lt;span style="color:#a6e22e">v&lt;/span> &lt;span style="color:#a6e22e">Value&lt;/span>) &lt;span style="color:#a6e22e">FieldByName&lt;/span>(&lt;span style="color:#a6e22e">name&lt;/span> &lt;span style="color:#66d9ef">string&lt;/span>) &lt;span style="color:#a6e22e">Value&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// ……
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;code>Value&lt;/code> 字段还有很多其他的方法。例如：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 用来获取 int 类型的值
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">func&lt;/span> (&lt;span style="color:#a6e22e">v&lt;/span> &lt;span style="color:#a6e22e">Value&lt;/span>) &lt;span style="color:#a6e22e">Int&lt;/span>() &lt;span style="color:#66d9ef">int64&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 用来获取结构体字段（成员）数量
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">func&lt;/span> (&lt;span style="color:#a6e22e">v&lt;/span> &lt;span style="color:#a6e22e">Value&lt;/span>) &lt;span style="color:#a6e22e">NumField&lt;/span>() &lt;span style="color:#66d9ef">int&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 尝试向通道发送数据（不会阻塞）
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">func&lt;/span> (&lt;span style="color:#a6e22e">v&lt;/span> &lt;span style="color:#a6e22e">Value&lt;/span>) &lt;span style="color:#a6e22e">TrySend&lt;/span>(&lt;span style="color:#a6e22e">x&lt;/span> &lt;span style="color:#a6e22e">reflect&lt;/span>.&lt;span style="color:#a6e22e">Value&lt;/span>) &lt;span style="color:#66d9ef">bool&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 通过参数列表 in 调用 v 值所代表的函数（或方法
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">func&lt;/span> (&lt;span style="color:#a6e22e">v&lt;/span> &lt;span style="color:#a6e22e">Value&lt;/span>) &lt;span style="color:#a6e22e">Call&lt;/span>(&lt;span style="color:#a6e22e">in&lt;/span> []&lt;span style="color:#a6e22e">Value&lt;/span>) (&lt;span style="color:#a6e22e">r&lt;/span> []&lt;span style="color:#a6e22e">Value&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 调用变参长度可变的函数
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">func&lt;/span> (&lt;span style="color:#a6e22e">v&lt;/span> &lt;span style="color:#a6e22e">Value&lt;/span>) &lt;span style="color:#a6e22e">CallSlice&lt;/span>(&lt;span style="color:#a6e22e">in&lt;/span> []&lt;span style="color:#a6e22e">Value&lt;/span>) []&lt;span style="color:#a6e22e">Value&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>不一一列举了，反正是非常多。可以去 &lt;code>src/reflect/value.go&lt;/code> 去看看源码，搜索 &lt;code>func (v Value)&lt;/code> 就能看到。&lt;/p>
&lt;h3 id="type-方法与-interface-方法">Type() 方法与 Interface() 方法&lt;/h3>
&lt;p>另外，通过 &lt;code>Type()&lt;/code> 方法和 &lt;code>Interface()&lt;/code> 方法可以打通 &lt;code>interface&lt;/code>、&lt;code>Type&lt;/code>、&lt;code>Value&lt;/code> 三者。Type() 方法也可以返回变量的类型信息，与 &lt;code>reflect.TypeOf()&lt;/code> 函数等价。&lt;code>Interface()&lt;/code> 方法可以将 Value 还原成原来的 interface。
这里引用老钱《快学 Go 语言第十五课——反射》的一张图：
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/tgz38n/1616980149650-1e6b2b6d-0b40-43d1-bf91-a46890012e73.png" alt="">
总结一下：&lt;code>TypeOf()&lt;/code> 函数返回一个接口，这个接口定义了一系列方法，利用这些方法可以获取关于类型的所有信息； &lt;code>ValueOf()&lt;/code> 函数返回一个结构体变量，包含类型信息以及实际值。
用一张图来串一下：
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/tgz38n/1616980149652-cd48e788-6a67-421d-ad95-1d89d7ae5241.png" alt="">
上图中，&lt;code>rtye&lt;/code> 实现了 &lt;code>Type&lt;/code> 接口，是所有类型的公共部分。emptyface 结构体和 eface 其实是一个东西，而 rtype 其实和 _type 是一个东西，只是一些字段稍微有点差别，比如 emptyface 的 word 字段和 eface 的 data 字段名称不同，但是数据型是一样的。&lt;/p>
&lt;h2 id="反射的三大定律">反射的三大定律&lt;/h2>
&lt;p>根据 Go 官方关于反射的博客，反射有三大定律：&lt;/p>
&lt;blockquote>
&lt;ol>
&lt;li>Reflection goes from interface value to reflection object.&lt;/li>
&lt;li>Reflection goes from reflection object to interface value.&lt;/li>
&lt;li>To modify a reflection object, the value must be settable.&lt;/li>
&lt;/ol>
&lt;/blockquote>
&lt;p>第一条是最基本的：反射是一种检测存储在 &lt;code>interface&lt;/code> 中的类型和值机制。这可以通过 &lt;code>TypeOf&lt;/code> 函数和 &lt;code>ValueOf&lt;/code> 函数得到。
第二条实际上和第一条是相反的机制，它将 &lt;code>ValueOf&lt;/code> 的返回值通过 &lt;code>Interface()&lt;/code> 函数反向转变成 &lt;code>interface&lt;/code> 变量。
前两条就是说 &lt;code>接口型变量&lt;/code> 和 &lt;code>反射类型对象&lt;/code> 可以相互转化，反射类型对象实际上就是指的前面说的 &lt;code>reflect.Type&lt;/code> 和 &lt;code>reflect.Value&lt;/code>。
第三条不太好懂：如果需要操作一个反射变量，那么它必须是可设置的。反射变量可设置的本质是它存储了原变量本身，这样对反射变量的操作，就会反映到原变量本身；反之，如果反射变量不能代表原变量，那么操作了反射变量，不会对原变量产生任何影响，这会给使用者带来疑惑。所以第二种情况在语言层面是不被允许的。
举一个经典例子：&lt;/p>
&lt;pre>&lt;code>var x float64 = 3.4
v := reflect.ValueOf(x)
v.SetFloat(7.1) // Error: will panic.
&lt;/code>&lt;/pre>
&lt;p>执行上面的代码会产生 panic，原因是反射变量 &lt;code>v&lt;/code> 不能代表 &lt;code>x&lt;/code> 本身，为什么？因为调用 &lt;code>reflect.ValueOf(x)&lt;/code> 这一行代码的时候，传入的参数在函数内部只是一个拷贝，是值传递，所以 &lt;code>v&lt;/code> 代表的只是 &lt;code>x&lt;/code> 的一个拷贝，因此对 &lt;code>v&lt;/code> 进行操作是被禁止的。
可设置是反射变量 &lt;code>Value&lt;/code> 的一个性质，但不是所有的 &lt;code>Value&lt;/code> 都是可被设置的。
就像在一般的函数里那样，当我们想改变传入的变量时，使用指针就可以解决了。&lt;/p>
&lt;pre>&lt;code>var x float64 = 3.4
p := reflect.ValueOf(&amp;amp;x)
fmt.Println(&amp;quot;type of p:&amp;quot;, p.Type())
fmt.Println(&amp;quot;settability of p:&amp;quot;, p.CanSet())
&lt;/code>&lt;/pre>
&lt;p>输出是这样的：&lt;/p>
&lt;pre>&lt;code>type of p: *float64
settability of p: false
&lt;/code>&lt;/pre>
&lt;p>&lt;code>p&lt;/code> 还不是代表 &lt;code>x&lt;/code>，&lt;code>p.Elem()&lt;/code> 才真正代表 &lt;code>x&lt;/code>，这样就可以真正操作 &lt;code>x&lt;/code> 了：&lt;/p>
&lt;pre>&lt;code>v := p.Elem()
v.SetFloat(7.1)
fmt.Println(v.Interface()) // 7.1
fmt.Println(x) // 7.1
&lt;/code>&lt;/pre>
&lt;p>关于第三条，记住一句话：如果想要操作原变量，反射变量 &lt;code>Value&lt;/code> 必须要 hold 住原变量的地址才行。&lt;/p>
&lt;h1 id="反射相关函数的使用">反射相关函数的使用&lt;/h1>
&lt;h2 id="代码样例">代码样例&lt;/h2>
&lt;p>网络上各种博客文章里使用反射的样例代码非常多，读过这篇文章后，基本没有看不懂的，哈哈！不过，我这里还是举一个例子，并讲解一番：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">package&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">import&lt;/span> (
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#34;reflect&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#34;fmt&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">type&lt;/span> &lt;span style="color:#a6e22e">Child&lt;/span> &lt;span style="color:#66d9ef">struct&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">Name&lt;/span> &lt;span style="color:#66d9ef">string&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">Grade&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">Handsome&lt;/span> &lt;span style="color:#66d9ef">bool&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">type&lt;/span> &lt;span style="color:#a6e22e">Adult&lt;/span> &lt;span style="color:#66d9ef">struct&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">ID&lt;/span> &lt;span style="color:#66d9ef">string&lt;/span> &lt;span style="color:#e6db74">`qson:&amp;#34;Name&amp;#34;`&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">Occupation&lt;/span> &lt;span style="color:#66d9ef">string&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">Handsome&lt;/span> &lt;span style="color:#66d9ef">bool&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 如果输入参数 i 是 Slice，元素是结构体，有一个字段名为 `Handsome`，
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 并且有一个字段的 tag 或者字段名是 `Name` ，
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 如果该 `Name` 字段的值是 `qcrao`，
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 就把结构体中名为 `Handsome` 的字段值设置为 true。
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">func&lt;/span> &lt;span style="color:#a6e22e">handsome&lt;/span>(&lt;span style="color:#a6e22e">i&lt;/span> &lt;span style="color:#66d9ef">interface&lt;/span>{}) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 获取 i 的反射变量 Value
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#a6e22e">v&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">reflect&lt;/span>.&lt;span style="color:#a6e22e">ValueOf&lt;/span>(&lt;span style="color:#a6e22e">i&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 确定 v 是一个 Slice
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">if&lt;/span> &lt;span style="color:#a6e22e">v&lt;/span>.&lt;span style="color:#a6e22e">Kind&lt;/span>() &lt;span style="color:#f92672">!=&lt;/span> &lt;span style="color:#a6e22e">reflect&lt;/span>.&lt;span style="color:#a6e22e">Slice&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 确定 v 是的元素为结构体
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">if&lt;/span> &lt;span style="color:#a6e22e">e&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">v&lt;/span>.&lt;span style="color:#a6e22e">Type&lt;/span>().&lt;span style="color:#a6e22e">Elem&lt;/span>(); &lt;span style="color:#a6e22e">e&lt;/span>.&lt;span style="color:#a6e22e">Kind&lt;/span>() &lt;span style="color:#f92672">!=&lt;/span> &lt;span style="color:#a6e22e">reflect&lt;/span>.&lt;span style="color:#a6e22e">Struct&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 确定结构体的字段名含有 &amp;#34;ID&amp;#34; 或者 json tag 标签为 `name`
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#75715e">// 确定结构体的字段名 &amp;#34;Handsome&amp;#34;
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#a6e22e">st&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">v&lt;/span>.&lt;span style="color:#a6e22e">Type&lt;/span>().&lt;span style="color:#a6e22e">Elem&lt;/span>()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 寻找字段名为 Name 或者 tag 的值为 Name 的字段
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#a6e22e">foundName&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#66d9ef">false&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span> &lt;span style="color:#a6e22e">i&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>; &lt;span style="color:#a6e22e">i&lt;/span> &amp;lt; &lt;span style="color:#a6e22e">st&lt;/span>.&lt;span style="color:#a6e22e">NumField&lt;/span>(); &lt;span style="color:#a6e22e">i&lt;/span>&lt;span style="color:#f92672">++&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">f&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">st&lt;/span>.&lt;span style="color:#a6e22e">Field&lt;/span>(&lt;span style="color:#a6e22e">i&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">tag&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">f&lt;/span>.&lt;span style="color:#a6e22e">Tag&lt;/span>.&lt;span style="color:#a6e22e">Get&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;qson&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (&lt;span style="color:#a6e22e">tag&lt;/span> &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#e6db74">&amp;#34;Name&amp;#34;&lt;/span> &lt;span style="color:#f92672">||&lt;/span> &lt;span style="color:#a6e22e">f&lt;/span>.&lt;span style="color:#a6e22e">Name&lt;/span> &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#e6db74">&amp;#34;Name&amp;#34;&lt;/span>) &lt;span style="color:#f92672">&amp;amp;&amp;amp;&lt;/span> &lt;span style="color:#a6e22e">f&lt;/span>.&lt;span style="color:#a6e22e">Type&lt;/span>.&lt;span style="color:#a6e22e">Kind&lt;/span>() &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#a6e22e">reflect&lt;/span>.&lt;span style="color:#a6e22e">String&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">foundName&lt;/span> = &lt;span style="color:#66d9ef">true&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">break&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> !&lt;span style="color:#a6e22e">foundName&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> &lt;span style="color:#a6e22e">niceField&lt;/span>, &lt;span style="color:#a6e22e">foundHandsome&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">st&lt;/span>.&lt;span style="color:#a6e22e">FieldByName&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;Handsome&amp;#34;&lt;/span>); &lt;span style="color:#a6e22e">foundHandsome&lt;/span> &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#66d9ef">false&lt;/span> &lt;span style="color:#f92672">||&lt;/span> &lt;span style="color:#a6e22e">niceField&lt;/span>.&lt;span style="color:#a6e22e">Type&lt;/span>.&lt;span style="color:#a6e22e">Kind&lt;/span>() &lt;span style="color:#f92672">!=&lt;/span> &lt;span style="color:#a6e22e">reflect&lt;/span>.&lt;span style="color:#a6e22e">Bool&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 设置名字为 &amp;#34;qcrao&amp;#34; 的对象的 &amp;#34;Handsome&amp;#34; 字段为 true
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">for&lt;/span> &lt;span style="color:#a6e22e">i&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>; &lt;span style="color:#a6e22e">i&lt;/span> &amp;lt; &lt;span style="color:#a6e22e">v&lt;/span>.&lt;span style="color:#a6e22e">Len&lt;/span>(); &lt;span style="color:#a6e22e">i&lt;/span>&lt;span style="color:#f92672">++&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">e&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">v&lt;/span>.&lt;span style="color:#a6e22e">Index&lt;/span>(&lt;span style="color:#a6e22e">i&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">handsome&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">e&lt;/span>.&lt;span style="color:#a6e22e">FieldByName&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;Handsome&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 寻找字段名为 Name 或者 tag 的值为 Name 的字段
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">var&lt;/span> &lt;span style="color:#a6e22e">name&lt;/span> &lt;span style="color:#a6e22e">reflect&lt;/span>.&lt;span style="color:#a6e22e">Value&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span> &lt;span style="color:#a6e22e">j&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>; &lt;span style="color:#a6e22e">j&lt;/span> &amp;lt; &lt;span style="color:#a6e22e">st&lt;/span>.&lt;span style="color:#a6e22e">NumField&lt;/span>(); &lt;span style="color:#a6e22e">j&lt;/span>&lt;span style="color:#f92672">++&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">f&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">st&lt;/span>.&lt;span style="color:#a6e22e">Field&lt;/span>(&lt;span style="color:#a6e22e">j&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">tag&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">f&lt;/span>.&lt;span style="color:#a6e22e">Tag&lt;/span>.&lt;span style="color:#a6e22e">Get&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;qson&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> &lt;span style="color:#a6e22e">tag&lt;/span> &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#e6db74">&amp;#34;Name&amp;#34;&lt;/span> &lt;span style="color:#f92672">||&lt;/span> &lt;span style="color:#a6e22e">f&lt;/span>.&lt;span style="color:#a6e22e">Name&lt;/span> &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#e6db74">&amp;#34;Name&amp;#34;&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">name&lt;/span> = &lt;span style="color:#a6e22e">v&lt;/span>.&lt;span style="color:#a6e22e">Index&lt;/span>(&lt;span style="color:#a6e22e">i&lt;/span>).&lt;span style="color:#a6e22e">Field&lt;/span>(&lt;span style="color:#a6e22e">j&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> &lt;span style="color:#a6e22e">name&lt;/span>.&lt;span style="color:#a6e22e">String&lt;/span>() &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#e6db74">&amp;#34;qcrao&amp;#34;&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">handsome&lt;/span>.&lt;span style="color:#a6e22e">SetBool&lt;/span>(&lt;span style="color:#66d9ef">true&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">func&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">children&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> []&lt;span style="color:#a6e22e">Child&lt;/span>{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {&lt;span style="color:#a6e22e">Name&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;Ava&amp;#34;&lt;/span>, &lt;span style="color:#a6e22e">Grade&lt;/span>: &lt;span style="color:#ae81ff">3&lt;/span>, &lt;span style="color:#a6e22e">Handsome&lt;/span>: &lt;span style="color:#66d9ef">true&lt;/span>},
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {&lt;span style="color:#a6e22e">Name&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;qcrao&amp;#34;&lt;/span>, &lt;span style="color:#a6e22e">Grade&lt;/span>: &lt;span style="color:#ae81ff">6&lt;/span>, &lt;span style="color:#a6e22e">Handsome&lt;/span>: &lt;span style="color:#66d9ef">false&lt;/span>},
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">adults&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> []&lt;span style="color:#a6e22e">Adult&lt;/span>{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {&lt;span style="color:#a6e22e">ID&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;Steve&amp;#34;&lt;/span>, &lt;span style="color:#a6e22e">Occupation&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;Clerk&amp;#34;&lt;/span>, &lt;span style="color:#a6e22e">Handsome&lt;/span>: &lt;span style="color:#66d9ef">true&lt;/span>},
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {&lt;span style="color:#a6e22e">ID&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;qcrao&amp;#34;&lt;/span>, &lt;span style="color:#a6e22e">Occupation&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;Go Programmer&amp;#34;&lt;/span>, &lt;span style="color:#a6e22e">Handsome&lt;/span>: &lt;span style="color:#66d9ef">false&lt;/span>},
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">fmt&lt;/span>.&lt;span style="color:#a6e22e">Printf&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;adults before handsome: %v\n&amp;#34;&lt;/span>, &lt;span style="color:#a6e22e">adults&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">handsome&lt;/span>(&lt;span style="color:#a6e22e">adults&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">fmt&lt;/span>.&lt;span style="color:#a6e22e">Printf&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;adults after handsome: %v\n&amp;#34;&lt;/span>, &lt;span style="color:#a6e22e">adults&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">fmt&lt;/span>.&lt;span style="color:#a6e22e">Println&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;-------------&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">fmt&lt;/span>.&lt;span style="color:#a6e22e">Printf&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;children before handsome: %v\n&amp;#34;&lt;/span>, &lt;span style="color:#a6e22e">children&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">handsome&lt;/span>(&lt;span style="color:#a6e22e">children&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">fmt&lt;/span>.&lt;span style="color:#a6e22e">Printf&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;children after handsome: %v\n&amp;#34;&lt;/span>, &lt;span style="color:#a6e22e">children&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>代码运行结果：&lt;/p>
&lt;pre>&lt;code>adults before handsome: [{Steve Clerk true} {qcrao Go Programmer false}]
adults after handsome: [{Steve Clerk true} {qcrao Go Programmer true}]
-------------
children before handsome: [{Ava 3 true} {qcrao 6 false}]
children after handsome: [{Ava 3 true} {qcrao 6 true}]
&lt;/code>&lt;/pre>
&lt;p>代码主要做的事情是：找出传入的参数为 Slice，并且 Slice 的元素为结构体，如果其中有一个字段名是 &lt;code>Name&lt;/code> 或者是 标签名称为 &lt;code>Name&lt;/code>，并且还有一个字段名是 &lt;code>Handsome&lt;/code> 的情形。如果找到，并且字段名称为 &lt;code>Name&lt;/code> 的实际值是 &lt;code>qcrao&lt;/code> 的话，就把另一个字段 &lt;code>Handsome&lt;/code> 的值置为 true。
程序并不关心传入的结构体到底是什么，只要它的字段名包含 &lt;code>Name&lt;/code> 和 &lt;code>Handsome&lt;/code>，都是 handsome 函数要工作的对象。
注意一点，&lt;code>Adult&lt;/code> 结构体的标签 &lt;code>qson:&amp;quot;Name&amp;quot;&lt;/code>，中间是没有空格的，否则 &lt;code>Tag.Get(&amp;quot;qson&amp;quot;)&lt;/code> 识别不出来。&lt;/p>
&lt;h2 id="未导出成员">未导出成员&lt;/h2>
&lt;p>利用反射机制，对于结构体中未导出成员，可以读取，但不能修改其值。
注意，正常情况下，代码是不能读取结构体未导出成员的，但通过反射可以越过这层限制。另外，通过反射，结构体中可以被修改的成员只有是导出成员，也就是字段名的首字母是大写的。&lt;/p>
&lt;blockquote>
&lt;p>一个可取地址的 reflect.Value 变量会记录一个结构体成员是否是未导出成员，如果是的话则拒绝修改操作。
CanAddr 不能说明一个变量是否可以被修改。
CanSet 则可以检查对应的 reflect.Value 是否可取地址并可被修改。&lt;/p>
&lt;/blockquote>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">package&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">import&lt;/span> (
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#34;reflect&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#34;fmt&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">type&lt;/span> &lt;span style="color:#a6e22e">Child&lt;/span> &lt;span style="color:#66d9ef">struct&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">Name&lt;/span> &lt;span style="color:#66d9ef">string&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">handsome&lt;/span> &lt;span style="color:#66d9ef">bool&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">func&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">qcrao&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">Child&lt;/span>{&lt;span style="color:#a6e22e">Name&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;qcrao&amp;#34;&lt;/span>, &lt;span style="color:#a6e22e">handsome&lt;/span>: &lt;span style="color:#66d9ef">true&lt;/span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">v&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">reflect&lt;/span>.&lt;span style="color:#a6e22e">ValueOf&lt;/span>(&lt;span style="color:#f92672">&amp;amp;&lt;/span>&lt;span style="color:#a6e22e">qcrao&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">f&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">v&lt;/span>.&lt;span style="color:#a6e22e">Elem&lt;/span>().&lt;span style="color:#a6e22e">FieldByName&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;Name&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">fmt&lt;/span>.&lt;span style="color:#a6e22e">Println&lt;/span>(&lt;span style="color:#a6e22e">f&lt;/span>.&lt;span style="color:#a6e22e">String&lt;/span>())
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">f&lt;/span>.&lt;span style="color:#a6e22e">SetString&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;stefno&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">fmt&lt;/span>.&lt;span style="color:#a6e22e">Println&lt;/span>(&lt;span style="color:#a6e22e">f&lt;/span>.&lt;span style="color:#a6e22e">String&lt;/span>())
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">f&lt;/span> = &lt;span style="color:#a6e22e">v&lt;/span>.&lt;span style="color:#a6e22e">Elem&lt;/span>().&lt;span style="color:#a6e22e">FieldByName&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;handsome&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 这一句会导致 panic，因为 handsome 字段未导出
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#75715e">//f.SetBool(true)
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#a6e22e">fmt&lt;/span>.&lt;span style="color:#a6e22e">Println&lt;/span>(&lt;span style="color:#a6e22e">f&lt;/span>.&lt;span style="color:#a6e22e">Bool&lt;/span>())
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>执行结果：&lt;/p>
&lt;pre>&lt;code>qcrao
stefno
true
&lt;/code>&lt;/pre>
&lt;p>上面的例子中，handsome 字段未导出，可以读取，但不能调用相关 set 方法，否则会 panic。反射用起来一定要小心，调用类型不匹配的方法，会导致各种 panic。&lt;/p>
&lt;h1 id="反射的实际应用">反射的实际应用&lt;/h1>
&lt;p>反射的实际应用非常广：IDE 中的代码自动补全功能、对象序列化（json 函数库）、fmt 相关函数的实现、ORM（全称是：Object Relational Mapping，对象关系映射）……
这里举 2 个例子：json 序列化和 DeepEqual 函数。&lt;/p>
&lt;h2 id="json-序列化">json 序列化&lt;/h2>
&lt;p>开发过 web 服务的同学，一定用过 &lt;code>json&lt;/code> 数据格式。&lt;code>json&lt;/code> 是一种独立于语言的数据格式。最早用于浏览器和服务器之间的实时无状态的数据交换，并由此发展起来。
Go 语言中，主要提供 2 个函数用于序列化和反序列化：&lt;/p>
&lt;pre>&lt;code>func Marshal(v interface{}) ([]byte, error)
func Unmarshal(data []byte, v interface{}) error
&lt;/code>&lt;/pre>
&lt;p>两个函数的参数都包含 &lt;code>interface&lt;/code>，具体实现的时候，都会用到反射相关的特性。
对于序列化和反序列化函数，均需要知道参数的所有字段，包括字段类型和值，再调用相关的 get 函数或者 set 函数进行实际的操作。&lt;/p>
&lt;h2 id="deepequal-的作用及原理">DeepEqual 的作用及原理&lt;/h2>
&lt;p>在测试函数中，经常会需要这样的函数：判断两个变量的实际内容完全一致。
例如：如何判断两个 slice 所有的元素完全相同；如何判断两个 map 的 key 和 value 完全相同等等。
上述问题，可以通过 &lt;code>DeepEqual&lt;/code> 函数实现。&lt;/p>
&lt;pre>&lt;code>func DeepEqual(x, y interface{}) bool
&lt;/code>&lt;/pre>
&lt;p>&lt;code>DeepEqual&lt;/code> 函数的参数是两个 &lt;code>interface&lt;/code>，实际上也就是可以输入任意类型，输出 true 或者 flase 表示输入的两个变量是否是“深度”相等。
先明白一点，如果是不同的类型，即使是底层类型相同，相应的值也相同，那么两者也不是“深度”相等。&lt;/p>
&lt;pre>&lt;code>type MyInt int
type YourInt int
func main() {
m := MyInt(1)
y := YourInt(1)
fmt.Println(reflect.DeepEqual(m, y)) // false
}
&lt;/code>&lt;/pre>
&lt;p>上面的代码中，m, y 底层都是 int，而且值都是 1，但是两者静态类型不同，前者是 &lt;code>MyInt&lt;/code>，后者是 &lt;code>YourInt&lt;/code>，因此两者不是“深度”相等。
在源码里，有对 DeepEqual 函数的非常清楚地注释，列举了不同类型，DeepEqual 的比较情形，这里做一个总结：&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>类型&lt;/th>
&lt;th>深度相等情形&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>Array&lt;/td>
&lt;td>相同索引处的元素“深度”相等&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Struct&lt;/td>
&lt;td>相应字段，包含导出和不导出，“深度”相等&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Func&lt;/td>
&lt;td>只有两者都是 nil 时&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Interface&lt;/td>
&lt;td>两者存储的具体值“深度”相等&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Map&lt;/td>
&lt;td>1、都为 nil；2、非空、长度相等，指向同一个 map 实体对象，或者相应的 key 指向的 value “深度”相等&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Pointer&lt;/td>
&lt;td>1、使用 == 比较的结果相等；2、指向的实体“深度”相等&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Slice&lt;/td>
&lt;td>1、都为 nil；2、非空、长度相等，首元素指向同一个底层数组的相同元素，即 &amp;amp;x[0] == &amp;amp;y[0] 或者 相同索引处的元素“深度”相等&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>numbers, bools, strings, and channels&lt;/td>
&lt;td>使用 == 比较的结果为真&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>一般情况下，DeepEqual 的实现只需要递归地调用 == 就可以比较两个变量是否是真的“深度”相等。
但是，有一些异常情况：比如 func 类型是不可比较的类型，只有在两个 func 类型都是 nil 的情况下，才是“深度”相等；float 类型，由于精度的原因，也是不能使用 == 比较的；包含 func 类型或者 float 类型的 struct， interface， array 等。
对于指针而言，当两个值相等的指针就是“深度”相等，因为两者指向的内容是相等的，即使两者指向的是 func 类型或者 float 类型，这种情况下不关心指针所指向的内容。
同样，对于指向相同 slice， map 的两个变量也是“深度”相等的，不关心 slice， map 具体的内容。
对于“有环”的类型，比如循环链表，比较两者是否“深度”相等的过程中，需要对已比较的内容作一个标记，一旦发现两个指针之前比较过，立即停止比较，并判定二者是深度相等的。这样做的原因是，及时停止比较，避免陷入无限循环。
来看源码：&lt;/p>
&lt;pre>&lt;code>func DeepEqual(x, y interface{}) bool {
if x == nil || y == nil {
return x == y
}
v1 := ValueOf(x)
v2 := ValueOf(y)
if v1.Type() != v2.Type() {
return false
}
return deepValueEqual(v1, v2, make(map[visit]bool), 0)
}
&lt;/code>&lt;/pre>
&lt;p>首先查看两者是否有一个是 nil 的情况，这种情况下，只有两者都是 nil，函数才会返回 true。
接着，使用反射，获取 x，y 的反射对象，并且立即比较两者的类型，根据前面的内容，这里实际上是动态类型，如果类型不同，直接返回 false。
最后，最核心的内容在子函数 &lt;code>deepValueEqual&lt;/code> 中。
代码比较长，思路却比较简单清晰：核心是一个 switch 语句，识别输入参数的不同类型，分别递归调用 deepValueEqual 函数，一直递归到最基本的数据类型，比较 int，string 等可以直接得出 true 或者 false，再一层层地返回，最终得到“深度”相等的比较结果。
实际上，各种类型的比较套路比较相似，这里就直接节选一个稍微复杂一点的 &lt;code>map&lt;/code> 类型的比较：&lt;/p>
&lt;pre>&lt;code>// deepValueEqual 函数
// ……
case Map:
if v1.IsNil() != v2.IsNil() {
return false
}
if v1.Len() != v2.Len() {
return false
}
if v1.Pointer() == v2.Pointer() {
return true
}
for _, k := range v1.MapKeys() {
val1 := v1.MapIndex(k)
val2 := v2.MapIndex(k)
if !val1.IsValid() || !val2.IsValid() || !deepValueEqual(v1.MapIndex(k), v2.MapIndex(k), visited, depth+1) {
return false
}
}
return true
// ……
&lt;/code>&lt;/pre>
&lt;p>和前文总结的表格里，比较 map 是否相等的思路比较一致，也不需要多说什么。说明一点，&lt;code>visited&lt;/code> 是一个 map，记录递归过程中，比较过的“对”：&lt;/p>
&lt;pre>&lt;code>type visit struct {
a1 unsafe.Pointer
a2 unsafe.Pointer
typ Type
}
map[visit]bool
&lt;/code>&lt;/pre>
&lt;p>比较过程中，一旦发现比较的“对”，已经在 map 里出现过的话，直接判定“深度”比较结果的是 &lt;code>true&lt;/code>。&lt;/p>
&lt;h1 id="总结">总结&lt;/h1>
&lt;p>Go 作为一门静态语言，相比 Python 等动态语言，在编写过程中灵活性会受到一定的限制。但是通过接口加反射实现了类似于动态语言的能力：可以在程序运行时动态地捕获甚至改变类型的信息和值。
Go 语言的反射实现的基础是类型，或者说是 interface，当我们使用反射特性时，实际上用到的就是存储在 interface 变量中的和类型相关的信息，也就是常说的 &lt;code>&amp;lt;type, value&amp;gt;&lt;/code> 对。
只有 interface 才有反射的说法。
反射在 reflect 包中实现，涉及到两个相关函数：&lt;/p>
&lt;pre>&lt;code>func TypeOf ( i interface{} ) Type
func ValueOf ( i interface{} ) Value
&lt;/code>&lt;/pre>
&lt;p>Type 是一个接口，定义了很多相关方法，用于获取类型信息。Value 则持有类型的具体值。Type、Value、Interface 三者间通过函数 TypeOf，ValueOf，Interface 进行相互转换。
最后温习一下反射三大定律：&lt;/p>
&lt;blockquote>
&lt;ol>
&lt;li>Reflection goes from interface value to reflection object.&lt;/li>
&lt;li>Reflection goes from reflection object to interface value.&lt;/li>
&lt;li>To modify a reflection object, the value must be settable.&lt;/li>
&lt;/ol>
&lt;/blockquote>
&lt;p>翻译一下：&lt;/p>
&lt;blockquote>
&lt;ol>
&lt;li>反射将接口变量转换成反射对象 Type 和 Value；&lt;/li>
&lt;li>反射可以通过反射对象 Value 还原成原先的接口变量；&lt;/li>
&lt;li>反射可以用来修改一个变量的值，前提是这个值可以被修改。&lt;/li>
&lt;/ol>
&lt;/blockquote>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/tgz38n/1616980149660-85acb022-e70f-4ef8-91ab-10d7186fd785.png" alt="">&lt;/p>
&lt;h1 id="参考资料">参考资料&lt;/h1>
&lt;p>【维基百科中文】&lt;a href="https://zh.wikipedia.org/wiki/%E5%8F%8D%E5%B0%84_(%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6)">https://zh.wikipedia.org/wiki/反射_(计算机科学)&lt;/a>
【码洞老钱 反射】&lt;a href="https://juejin.im/post/5c2040d76fb9a049c643d9bd">https://juejin.im/post/5c2040d76fb9a049c643d9bd&lt;/a>
【Go 官方博客 reflection】&lt;a href="https://blog.golang.org/laws-of-reflection">https://blog.golang.org/laws-of-reflection&lt;/a>
【GCTT 译文，不错】&lt;a href="https://mp.weixin.qq.com/s/dkgJ_fA0smvpv69t5Nv-7A">https://mp.weixin.qq.com/s/dkgJ_fA0smvpv69t5Nv-7A&lt;/a>
【json 库 源码分析】&lt;a href="https://zhuanlan.zhihu.com/p/37165706">https://zhuanlan.zhihu.com/p/37165706&lt;/a>
【reflect 代码例子和图比较好】&lt;a href="https://blog.gopheracademy.com/advent-2018/interfaces-and-reflect/">https://blog.gopheracademy.com/advent-2018/interfaces-and-reflect/&lt;/a>
【反射使用讲得不错】&lt;a href="https://juejin.im/post/5a75a4fb5188257a82110544">https://juejin.im/post/5a75a4fb5188257a82110544&lt;/a>
【接口和反射的关系 ，english】&lt;a href="https://blog.gopheracademy.com/advent-2018/interfaces-and-reflect/">https://blog.gopheracademy.com/advent-2018/interfaces-and-reflect/&lt;/a>
【总结成知识点】&lt;a href="http://www.cnblogs.com/susufufu/p/7653579.html">http://www.cnblogs.com/susufufu/p/7653579.html&lt;/a>
【Type Value】&lt;a href="https://colobu.com/2016/07/09/dive-into-go-13/">https://colobu.com/2016/07/09/dive-into-go-13/&lt;/a>
【讲得比较清晰简单】&lt;a href="https://www.lijiaocn.com/%E7%BC%96%E7%A8%8B/2017/11/06/golang-reflection.html">https://www.lijiaocn.com/编程/2017/11/06/golang-reflection.html&lt;/a>
【DeepEqual】&lt;a href="https://github.com/Chasiny/Blog/blob/master/blog/go/package/go-reflect-deepequal.md">https://github.com/Chasiny/Blog/blob/master/blog/go/package/go-reflect-deepequal.md&lt;/a>
【反射使用场景】&lt;a href="https://yq.aliyun.com/articles/599584">https://yq.aliyun.com/articles/599584&lt;/a>&lt;/p></description></item><item><title>Docs: Template(模板)</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/2.%E7%BC%96%E7%A8%8B/%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/go/go-%E6%A0%87%E5%87%86%E5%BA%93/template%E6%A8%A1%E6%9D%BF/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/2.%E7%BC%96%E7%A8%8B/%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/go/go-%E6%A0%87%E5%87%86%E5%BA%93/template%E6%A8%A1%E6%9D%BF/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://www.cnblogs.com/f-ck-need-u/p/10053124.html">骏马金龙，Go 标准库：Go template 用法详解&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://pkg.go.dev/text/template">Go Package，标准库-text-template&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>本文只介绍 template 的语法和用法，关于 template 包的函数、方法、template 的结构和原理，见：&lt;a href="https://www.cnblogs.com/f-ck-need-u/p/10035768.html">深入剖析 Go template&lt;/a>。&lt;/p>
&lt;h2 id="入门示例">入门示例&lt;/h2>
&lt;p>以下为 test.html 文件的内容，里面使用了一个 template 语法&lt;code>{{.}}&lt;/code>。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-html" data-lang="html">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&amp;lt;!DOCTYPE html&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&amp;lt;&lt;span style="color:#f92672">html&lt;/span>&amp;gt;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &amp;lt;&lt;span style="color:#f92672">head&lt;/span>&amp;gt;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &amp;lt;&lt;span style="color:#f92672">meta&lt;/span> &lt;span style="color:#a6e22e">http-equiv&lt;/span>&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;Content-Type&amp;#34;&lt;/span> &lt;span style="color:#a6e22e">content&lt;/span>&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;text/html; charset=utf-8&amp;#34;&lt;/span> /&amp;gt;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &amp;lt;&lt;span style="color:#f92672">title&lt;/span>&amp;gt;Go Web&amp;lt;/&lt;span style="color:#f92672">title&lt;/span>&amp;gt;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &amp;lt;/&lt;span style="color:#f92672">head&lt;/span>&amp;gt;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &amp;lt;&lt;span style="color:#f92672">body&lt;/span>&amp;gt;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {{ . }}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &amp;lt;/&lt;span style="color:#f92672">body&lt;/span>&amp;gt;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&amp;lt;/&lt;span style="color:#f92672">html&lt;/span>&amp;gt;
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>以下是 test.html 同目录下的一个 go web 程序：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">package&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">import&lt;/span> (
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#34;html/template&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#34;net/http&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">func&lt;/span> &lt;span style="color:#a6e22e">tmpl&lt;/span>(&lt;span style="color:#a6e22e">w&lt;/span> &lt;span style="color:#a6e22e">http&lt;/span>.&lt;span style="color:#a6e22e">ResponseWriter&lt;/span>, &lt;span style="color:#a6e22e">r&lt;/span> &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">http&lt;/span>.&lt;span style="color:#a6e22e">Request&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">t1&lt;/span>, &lt;span style="color:#a6e22e">err&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">template&lt;/span>.&lt;span style="color:#a6e22e">ParseFiles&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;test.html&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> &lt;span style="color:#a6e22e">err&lt;/span> &lt;span style="color:#f92672">!=&lt;/span> &lt;span style="color:#66d9ef">nil&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> panic(&lt;span style="color:#a6e22e">err&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">t1&lt;/span>.&lt;span style="color:#a6e22e">Execute&lt;/span>(&lt;span style="color:#a6e22e">w&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;hello world&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">func&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">server&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">http&lt;/span>.&lt;span style="color:#a6e22e">Server&lt;/span>{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">Addr&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;127.0.0.1:8080&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">http&lt;/span>.&lt;span style="color:#a6e22e">HandleFunc&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;/tmpl&amp;#34;&lt;/span>, &lt;span style="color:#a6e22e">tmpl&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">server&lt;/span>.&lt;span style="color:#a6e22e">ListenAndServe&lt;/span>()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>前面的 html 文件中使用了一个 template 的语法&lt;code>{{.}}&lt;/code>，这部分是需要通过 go 的 template 引擎进行解析，然后替换成对应的内容。
在 go 程序中，handler 函数中使用&lt;code>template.ParseFiles(&amp;quot;test.html&amp;quot;)&lt;/code>，它会自动创建一个模板(关联到变量 t1 上)，并解析一个或多个文本文件(不仅仅是 html 文件)，解析之后就可以使用&lt;code>Execute(w,&amp;quot;hello world&amp;quot;)&lt;/code>去执行解析后的模板对象，执行过程是合并、替换的过程。例如上面的&lt;code>{{.}}&lt;/code>中的&lt;code>.&lt;/code>会替换成当前对象&amp;quot;hello world&amp;quot;，并和其它纯字符串内容进行合并，最后写入 w 中，也就是发送到浏览器&amp;quot;hello world&amp;quot;。
本文不解释这些 template 包的函数、方法以及更底层的理论知识，本文只解释 template 的语法，如果觉得这些无法理解，或者看不懂官方手册，请看&lt;a href="https://www.cnblogs.com/f-ck-need-u/p/10035768.html">深入剖析 Go template&lt;/a>。&lt;/p>
&lt;h2 id="关于点--和作用域">关于点 &lt;code>.&lt;/code> 和作用域&lt;/h2>
&lt;p>在写 template 的时候，会经常用到&amp;quot;.&amp;quot;。比如&lt;code>{{.}}&lt;/code>、&lt;code>{{len .}}&lt;/code>、&lt;code>{{.Name}}&lt;/code>、&lt;code>{{$x.Name}}&lt;/code>等等。
在 template 中，点&amp;quot;.&amp;ldquo;代表&lt;strong>当前作用域的当前对象&lt;/strong>。它类似于 java/c++的 this 关键字，类似于 perl/python 的 self。如果了解 perl，它更可以简单地理解为默认变量&lt;code>$_&lt;/code>。
例如，前面示例 test.html 中&lt;code>{{.}}&lt;/code>，这个点是顶级作用域范围内的，它代表&lt;code>Execute(w,&amp;quot;hello worold&amp;quot;)&lt;/code>的第二个参数&amp;quot;hello world&amp;rdquo;。也就是说它代表这个字符串对象。
再例如，有一个 Person struct。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">type&lt;/span> &lt;span style="color:#a6e22e">Person&lt;/span> &lt;span style="color:#66d9ef">struct&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">Name&lt;/span> &lt;span style="color:#66d9ef">string&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">Age&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">func&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>(){
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">p&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">Person&lt;/span>{&lt;span style="color:#e6db74">&amp;#34;longshuai&amp;#34;&lt;/span>,&lt;span style="color:#ae81ff">23&lt;/span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">tmpl&lt;/span>, &lt;span style="color:#a6e22e">_&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">template&lt;/span>.&lt;span style="color:#a6e22e">New&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;test&amp;#34;&lt;/span>).&lt;span style="color:#a6e22e">Parse&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;Name: {{.Name}}, Age: {{.Age}}&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">_&lt;/span> = &lt;span style="color:#a6e22e">tmpl&lt;/span>.&lt;span style="color:#a6e22e">Execute&lt;/span>(&lt;span style="color:#a6e22e">os&lt;/span>.&lt;span style="color:#a6e22e">Stdout&lt;/span>, &lt;span style="color:#a6e22e">p&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>这里&lt;code>{{.Name}}&lt;/code>和&lt;code>{{.Age}}&lt;/code>中的点&amp;quot;.&amp;ldquo;代表的是顶级作用域的对象 p，所以 Execute()方法执行的时候，会将&lt;code>{{.Name}}&lt;/code>替换成&lt;code>p.Name&lt;/code>，同理&lt;code>{{.Age}}&lt;/code>替换成&lt;code>{{p.Age}}&lt;/code>。
但是并非只有一个顶级作用域，range、with、if 等内置 action 都有自己的本地作用域。它们的用法后文解释，这里仅引入它们的作用域来解释&amp;rdquo;.&amp;quot;。
例如下面的例子，如果看不懂也没关系，只要从中理解&amp;quot;.&amp;ldquo;即可。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">package&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">import&lt;/span> (
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#34;os&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#34;text/template&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">type&lt;/span> &lt;span style="color:#a6e22e">Friend&lt;/span> &lt;span style="color:#66d9ef">struct&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">Fname&lt;/span> &lt;span style="color:#66d9ef">string&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">type&lt;/span> &lt;span style="color:#a6e22e">Person&lt;/span> &lt;span style="color:#66d9ef">struct&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">UserName&lt;/span> &lt;span style="color:#66d9ef">string&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">Emails&lt;/span> []&lt;span style="color:#66d9ef">string&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">Friends&lt;/span> []&lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">Friend&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">func&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">f1&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">Friend&lt;/span>{&lt;span style="color:#a6e22e">Fname&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;xiaofang&amp;#34;&lt;/span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">f2&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">Friend&lt;/span>{&lt;span style="color:#a6e22e">Fname&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;wugui&amp;#34;&lt;/span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">t&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">template&lt;/span>.&lt;span style="color:#a6e22e">New&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;test&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">t&lt;/span> = &lt;span style="color:#a6e22e">template&lt;/span>.&lt;span style="color:#a6e22e">Must&lt;/span>(&lt;span style="color:#a6e22e">t&lt;/span>.&lt;span style="color:#a6e22e">Parse&lt;/span>(
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">`hello &lt;/span>&lt;span style="color:#75715e">{{&lt;/span>&lt;span style="color:#a6e22e">.UserName&lt;/span>&lt;span style="color:#75715e">}}&lt;/span>&lt;span style="color:#e6db74">!
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">&lt;/span>&lt;span style="color:#75715e">{{&lt;/span> &lt;span style="color:#66d9ef">range&lt;/span> &lt;span style="color:#a6e22e">.Emails&lt;/span> &lt;span style="color:#75715e">}}&lt;/span>&lt;span style="color:#e6db74">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">an email &lt;/span>&lt;span style="color:#75715e">{{&lt;/span> &lt;span style="color:#a6e22e">.&lt;/span> &lt;span style="color:#75715e">}}&lt;/span>&lt;span style="color:#e6db74">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">&lt;/span>&lt;span style="color:#75715e">{{-&lt;/span> &lt;span style="color:#66d9ef">end&lt;/span> &lt;span style="color:#75715e">}}&lt;/span>&lt;span style="color:#e6db74">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">&lt;/span>&lt;span style="color:#75715e">{{&lt;/span> &lt;span style="color:#66d9ef">with&lt;/span> &lt;span style="color:#a6e22e">.Friends&lt;/span> &lt;span style="color:#75715e">}}&lt;/span>&lt;span style="color:#e6db74">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">&lt;/span>&lt;span style="color:#75715e">{{-&lt;/span> &lt;span style="color:#66d9ef">range&lt;/span> &lt;span style="color:#a6e22e">.&lt;/span> &lt;span style="color:#75715e">}}&lt;/span>&lt;span style="color:#e6db74">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">my friend name is &lt;/span>&lt;span style="color:#75715e">{{&lt;/span>&lt;span style="color:#a6e22e">.Fname&lt;/span>&lt;span style="color:#75715e">}}&lt;/span>&lt;span style="color:#e6db74">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">&lt;/span>&lt;span style="color:#75715e">{{-&lt;/span> &lt;span style="color:#66d9ef">end&lt;/span> &lt;span style="color:#75715e">}}&lt;/span>&lt;span style="color:#e6db74">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">&lt;/span>&lt;span style="color:#75715e">{{&lt;/span> &lt;span style="color:#66d9ef">end&lt;/span> &lt;span style="color:#75715e">}}&lt;/span>&lt;span style="color:#e6db74">`&lt;/span>))
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">p&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">Person&lt;/span>{&lt;span style="color:#a6e22e">UserName&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;longshuai&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">Emails&lt;/span>: []&lt;span style="color:#66d9ef">string&lt;/span>{&lt;span style="color:#e6db74">&amp;#34;a1@qq.com&amp;#34;&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;a2@gmail.com&amp;#34;&lt;/span>},
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">Friends&lt;/span>: []&lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">Friend&lt;/span>{&lt;span style="color:#f92672">&amp;amp;&lt;/span>&lt;span style="color:#a6e22e">f1&lt;/span>, &lt;span style="color:#f92672">&amp;amp;&lt;/span>&lt;span style="color:#a6e22e">f2&lt;/span>}}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">t&lt;/span>.&lt;span style="color:#a6e22e">Execute&lt;/span>(&lt;span style="color:#a6e22e">os&lt;/span>.&lt;span style="color:#a6e22e">Stdout&lt;/span>, &lt;span style="color:#a6e22e">p&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>输出结果：&lt;/p>
&lt;pre>&lt;code>1
2
3
4
5
6
7
hello longshuai!
an email a1@qq.com
an email a2@gmail.com
my friend name is xiaofang
my friend name is wugui
&lt;/code>&lt;/pre>
&lt;p>这里定义了一个 Person 结构，它有两个 slice 结构的字段。在 Parse()方法中：&lt;/p>
&lt;ul>
&lt;li>顶级作用域的&lt;code>{{.UserName}}&lt;/code>、&lt;code>{{.Emails}}&lt;/code>、&lt;code>{{.Friends}}&lt;/code>中的点都代表 Execute()的第二个参数，也就是 Person 对象 p，它们在执行的时候会分别被替换成 p.UserName、p.Emails、p.Friends。&lt;/li>
&lt;li>因为 Emails 和 Friend 字段都是可迭代的，在&lt;code>{{range .Emails}}...{{end}}&lt;/code>这一段结构内部&lt;code>an email {{.}}&lt;/code>，这个&amp;rdquo;.&amp;ldquo;代表的是 range 迭代时的每个元素对象，也就是 p.Emails 这个 slice 中的每个元素。&lt;/li>
&lt;li>同理，with 结构内部&lt;code>{{range .}}&lt;/code>的&amp;rdquo;.&amp;ldquo;代表的是 p.Friends，也就是各个，再此 range 中又有一层迭代，此内层&lt;code>{{.Fname}}&lt;/code>的点代表 Friend 结构的实例，分别是&lt;code>&amp;amp;f1&lt;/code>和&lt;code>&amp;amp;f2&lt;/code>，所以&lt;code>{{.Fname}}&lt;/code>代表实例对象的 Fname 字段。&lt;/li>
&lt;/ul>
&lt;h2 id="去除空白">去除空白&lt;/h2>
&lt;p>template 引擎在进行替换的时候，是完全按照文本格式进行替换的。除了需要评估和替换的地方，所有的行分隔符、空格等等空白都原样保留。所以，&lt;strong>对于要解析的内容，不要随意缩进、随意换行&lt;/strong>。
可以在&lt;code>{{&lt;/code>符号的后面加上短横线并保留一个或多个空格&amp;rdquo;- &amp;ldquo;来去除它前面的空白(包括换行符、制表符、空格等)，即&lt;code>{{- xxxx&lt;/code>。
在&lt;code>}}&lt;/code>的前面加上一个或多个空格以及一个短横线&amp;rdquo;-&amp;ldquo;来去除它后面的空白，即&lt;code>xxxx -}}&lt;/code>。
例如：&lt;/p>
&lt;pre>&lt;code>{{23}} &amp;lt; {{45}} -&amp;gt; 23 &amp;lt; 45
{{23}} &amp;lt; {{- 45}} -&amp;gt; 23 &amp;lt;45
{{23 -}} &amp;lt; {{45}} -&amp;gt; 23&amp;lt; 45
{{23 -}} &amp;lt; {{- 45}} -&amp;gt; 23&amp;lt;45
&lt;/code>&lt;/pre>
&lt;p>其中&lt;code>{{23 -}}&lt;/code>中的短横线去除了这个替换结构后面的空格，即&lt;code>}} &amp;lt;&lt;/code>中间的空白。同理&lt;code>{{- 45}}&lt;/code>的短横线去除了&lt;code>&amp;lt; {{&lt;/code>中间的空白。
再看上一节的例子中：&lt;/p>
&lt;pre>&lt;code>t.Parse(
`hello {{.UserName}}!
{{ range .Emails }}
an email {{ . }}
{{- end }}
{{ with .Friends }}
{{- range . }}
my friend name is {{.Fname}}
{{- end }}
{{ end }}`)
&lt;/code>&lt;/pre>
&lt;p>注意，上面没有进行缩进。因为缩进的制表符或空格在替换的时候会保留。
第一行和第二行之间输出时会换行输出，不仅如此，&lt;code>range {{.Emails}}&lt;/code>自身也占一行，在替换的时候它会被保留为空行。除非 range 前面没加&lt;code>{{-&lt;/code>。由于 range 的&lt;code>{{- end&lt;/code>加上了去除前缀空白，所以每次迭代的时候，每个元素之间都换行输出但却不多一空行，如果这里的 end 去掉&lt;code>{{-&lt;/code>，则每个迭代的元素之间输出的时候都会有空行。同理后面的 with 和 range。&lt;/p>
&lt;h2 id="注释">注释&lt;/h2>
&lt;p>注释方式：&lt;code>{{/* a comment */}}&lt;/code>。
注释后的内容不会被引擎进行替换。但需要注意，注释行在替换的时候也会占用行，所以应该去除前缀和后缀空白，否则会多一空行。&lt;/p>
&lt;pre>&lt;code>1
2
3
{{- /* a comment without prefix/suffix space */}}
{{/* a comment without prefix/suffix space */ -}}
{{- /* a comment without prefix/suffix space */ -}}
&lt;/code>&lt;/pre>
&lt;p>注意，应该只去除前缀或后缀空白，不要同时都去除，否则会破坏原有的格式。例如：&lt;/p>
&lt;pre>&lt;code>1
2
3
4
5
6
t.Parse(
`hello {{.UserName}}!
{{- /* this line is a comment */}}
{{ range .Emails }}
an email {{ . }}
{{- end }}
&lt;/code>&lt;/pre>
&lt;h2 id="pipeline管道">pipeline(管道)&lt;/h2>
&lt;p>pipeline 是指产生数据的操作。比如&lt;code>{{.}}&lt;/code>、&lt;code>{{.Name}}&lt;/code>、&lt;code>funcname args&lt;/code>等。
可以使用管道符号&lt;code>|&lt;/code>链接多个命令，用法和 unix 下的管道类似：&lt;code>|&lt;/code>前面的命令将运算结果(或返回值)传递给后一个命令的最后一个位置。
例如：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>{{.}} | &lt;span style="color:#a6e22e">printf&lt;/span> &lt;span style="color:#e6db74">&amp;#34;%s\n&amp;#34;&lt;/span> &lt;span style="color:#e6db74">&amp;#34;abcd&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;code>{{.}}&lt;/code>的结果将传递给 printf，且传递的参数位置是&amp;quot;abcd&amp;quot;之后。
命令可以有超过 1 个的返回值，这时第二个返回值必须为 err 类型。
需要注意的是，并非只有使用了&lt;code>|&lt;/code>才是 pipeline。Go template 中，pipeline 的概念是传递数据，只要能产生数据的，都是 pipeline。这使得某些操作可以作为另一些操作内部的表达式先运行得到结果，就像是 Unix 下的命令替换一样。
例如，下面的&lt;code>(len &amp;quot;output&amp;quot;)&lt;/code>是 pipeline，它整体先运行。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>{{&lt;span style="color:#a6e22e">println&lt;/span> (&lt;span style="color:#a6e22e">len&lt;/span> &lt;span style="color:#e6db74">&amp;#34;output&amp;#34;&lt;/span>)}}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>下面是 Pipeline 的几种示例，它们都输出&lt;code>&amp;quot;output&amp;quot;&lt;/code>：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>{{&lt;span style="color:#e6db74">`&amp;#34;output&amp;#34;`&lt;/span>}}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>{{&lt;span style="color:#a6e22e">printf&lt;/span> &lt;span style="color:#e6db74">&amp;#34;%q&amp;#34;&lt;/span> &lt;span style="color:#e6db74">&amp;#34;output&amp;#34;&lt;/span>}}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>{{&lt;span style="color:#e6db74">&amp;#34;output&amp;#34;&lt;/span> | &lt;span style="color:#a6e22e">printf&lt;/span> &lt;span style="color:#e6db74">&amp;#34;%q&amp;#34;&lt;/span>}}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>{{&lt;span style="color:#a6e22e">printf&lt;/span> &lt;span style="color:#e6db74">&amp;#34;%q&amp;#34;&lt;/span> (&lt;span style="color:#a6e22e">print&lt;/span> &lt;span style="color:#e6db74">&amp;#34;out&amp;#34;&lt;/span> &lt;span style="color:#e6db74">&amp;#34;put&amp;#34;&lt;/span>)}}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>{{&lt;span style="color:#e6db74">&amp;#34;put&amp;#34;&lt;/span> | &lt;span style="color:#a6e22e">printf&lt;/span> &lt;span style="color:#e6db74">&amp;#34;%s%s&amp;#34;&lt;/span> &lt;span style="color:#e6db74">&amp;#34;out&amp;#34;&lt;/span> | &lt;span style="color:#a6e22e">printf&lt;/span> &lt;span style="color:#e6db74">&amp;#34;%q&amp;#34;&lt;/span>}}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>{{&lt;span style="color:#e6db74">&amp;#34;output&amp;#34;&lt;/span> | &lt;span style="color:#a6e22e">printf&lt;/span> &lt;span style="color:#e6db74">&amp;#34;%s&amp;#34;&lt;/span> | &lt;span style="color:#a6e22e">printf&lt;/span> &lt;span style="color:#e6db74">&amp;#34;%q&amp;#34;&lt;/span>}}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="变量">变量&lt;/h2>
&lt;p>可以在 template 中定义变量：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 未定义过的变量
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">$&lt;/span>&lt;span style="color:#66d9ef">var&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">pipeline&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 已定义过的变量
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">$&lt;/span>&lt;span style="color:#66d9ef">var&lt;/span> = &lt;span style="color:#a6e22e">pipeline&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>例如：&lt;/p>
&lt;pre>&lt;code>{{- $how_long :=(len &amp;quot;output&amp;quot;)}}
{{- println $how_long}} // 输出6
&lt;/code>&lt;/pre>
&lt;p>再例如：&lt;/p>
&lt;pre>&lt;code>tx := template.Must(template.New(&amp;quot;hh&amp;quot;).Parse(
`{{range $x := . -}}
{{$y := 333}}
{{- if (gt $x 33)}}{{println $x $y ($z := 444)}}{{- end}}
{{- end}}
`))
s := []int{11, 22, 33, 44, 55}
_ = tx.Execute(os.Stdout, s)
&lt;/code>&lt;/pre>
&lt;p>输出结果：&lt;/p>
&lt;pre>&lt;code>44 333 444
55 333 444
&lt;/code>&lt;/pre>
&lt;p>上面的示例中，使用 range 迭代 slice，每个元素都被赋值给变量&lt;code>$x&lt;/code>，每次迭代过程中，都新设置一个变量&lt;code>$y&lt;/code>，在内层嵌套的 if 结构中，可以使用这个两个外层的变量。在 if 的条件表达式中，使用了一个内置的比较函数 gt，如果&lt;code>$x&lt;/code>大于 33，则为 true。在 println 的参数中还定义了一个&lt;code>$z&lt;/code>，之所以能定义，是因为&lt;code>($z := 444)&lt;/code>的过程是一个 Pipeline，可以先运行。
需要注意三点：&lt;/p>
&lt;ol>
&lt;li>&lt;strong>变量有作用域，只要出现 end，则当前层次的作用域结束。内层可以访问外层变量，但外层不能访问内层变量&lt;/strong>。&lt;/li>
&lt;li>&lt;strong>有一个特殊变量&lt;/strong>&lt;code>**$**&lt;/code>&lt;strong>，它代表模板的最顶级作用域对象(通俗地理解，是以模板为全局作用域的全局变量)，在 Execute()执行的时候进行赋值，且一直不变&lt;/strong>。例如上面的示例中，&lt;code>$ = [11 22 33 44 55]&lt;/code>。再例如，define 定义了一个模板 t1，则 t1 中的&lt;code>$&lt;/code>作用域只属于这个 t1。&lt;/li>
&lt;li>&lt;strong>变量不可在模板之间继承&lt;/strong>。普通变量可能比较容易理解，但对于特殊变量&amp;rdquo;.&amp;ldquo;和&amp;rdquo;$&amp;quot;，比较容易搞混。见下面的例子。&lt;/li>
&lt;/ol>
&lt;p>例如：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">func&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">t1&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">template&lt;/span>.&lt;span style="color:#a6e22e">New&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;test1&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">tmpl&lt;/span>, &lt;span style="color:#a6e22e">_&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">t1&lt;/span>.&lt;span style="color:#a6e22e">Parse&lt;/span>(
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">`
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">&lt;/span>&lt;span style="color:#75715e">{{-&lt;/span> &lt;span style="color:#a6e22e">define&lt;/span> &lt;span style="color:#e6db74">&amp;#34;T1&amp;#34;&lt;/span>&lt;span style="color:#75715e">}}&lt;/span>&lt;span style="color:#e6db74">ONE &lt;/span>&lt;span style="color:#75715e">{{&lt;/span>&lt;span style="color:#66d9ef">println&lt;/span> &lt;span style="color:#a6e22e">.&lt;/span>&lt;span style="color:#75715e">}}{{&lt;/span>&lt;span style="color:#66d9ef">end&lt;/span>&lt;span style="color:#75715e">}}&lt;/span>&lt;span style="color:#e6db74">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">&lt;/span>&lt;span style="color:#75715e">{{-&lt;/span> &lt;span style="color:#a6e22e">define&lt;/span> &lt;span style="color:#e6db74">&amp;#34;T2&amp;#34;&lt;/span>&lt;span style="color:#75715e">}}{{&lt;/span>&lt;span style="color:#66d9ef">template&lt;/span> &lt;span style="color:#e6db74">&amp;#34;T1&amp;#34;&lt;/span> &lt;span style="color:#a6e22e">$&lt;/span>&lt;span style="color:#75715e">}}{{&lt;/span>&lt;span style="color:#66d9ef">end&lt;/span>&lt;span style="color:#75715e">}}&lt;/span>&lt;span style="color:#e6db74">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">&lt;/span>&lt;span style="color:#75715e">{{-&lt;/span> &lt;span style="color:#66d9ef">template&lt;/span> &lt;span style="color:#e6db74">&amp;#34;T2&amp;#34;&lt;/span> &lt;span style="color:#a6e22e">.&lt;/span> &lt;span style="color:#75715e">-}}&lt;/span>&lt;span style="color:#e6db74">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">`&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">_&lt;/span> = &lt;span style="color:#a6e22e">tmpl&lt;/span>.&lt;span style="color:#a6e22e">Execute&lt;/span>(&lt;span style="color:#a6e22e">os&lt;/span>.&lt;span style="color:#a6e22e">Stdout&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;hello world&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>上面使用 define 额外定义了 T1 和 T2 两个模板，T2 中嵌套了 T1。&lt;code>{{template &amp;quot;T2&amp;quot; .}}&lt;/code>的点代表顶级作用域的&amp;quot;hello world&amp;quot;对象。在 T2 中使用了特殊变量&lt;code>$&lt;/code>，这个&lt;code>$&lt;/code>的范围是 T2 的，不会继承顶级作用域&amp;quot;hello world&amp;quot;。但因为执行 T2 的时候，传递的是&amp;quot;.&amp;quot;，所以这里的&lt;code>$&lt;/code>的值仍然是&amp;quot;hello world&amp;quot;。
不仅&lt;code>$&lt;/code>不会在模板之间继承，&lt;code>.&lt;/code>也不会在模板之间继承(其它所有变量都不会继承)。实际上，template 可以看作是一个函数，它的执行过程是&lt;code>template(&amp;quot;T2&amp;quot;,.)&lt;/code>。如果把上面的&lt;code>$&lt;/code>换成&amp;quot;.&amp;quot;，结果是一样的。如果换成&lt;code>{{template &amp;quot;T2&amp;quot;}}&lt;/code>，则&lt;code>$=nil&lt;/code>
如果看不懂这些，后文有解释。&lt;/p>
&lt;h2 id="条件判断">条件判断&lt;/h2>
&lt;p>有以下几种 if 条件判断语句，其中第三和第四是等价的。&lt;/p>
&lt;pre>&lt;code>{{if pipeline}} T1 {{end}}
{{if pipeline}} T1 {{else}} T0 {{end}}
{{if pipeline}} T1 {{else if pipeline}} T0 {{end}}
{{if pipeline}} T1 {{else}}{{if pipeline}} T0 {{end}}{{end}}
&lt;/code>&lt;/pre>
&lt;p>需要注意的是，pipeline 为 false 的情况是各种数据对象的 0 值：数值 0，指针或接口是 nil，数组、slice、map 或 string 则是 len 为 0。&lt;/p>
&lt;h2 id="rangeend-迭代">range&amp;hellip;end 迭代&lt;/h2>
&lt;p>有两种迭代表达式类型：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>{{&lt;span style="color:#66d9ef">range&lt;/span> &lt;span style="color:#a6e22e">pipeline&lt;/span>}} &lt;span style="color:#a6e22e">T1&lt;/span> {{&lt;span style="color:#a6e22e">end&lt;/span>}}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>{{&lt;span style="color:#66d9ef">range&lt;/span> &lt;span style="color:#a6e22e">pipeline&lt;/span>}} &lt;span style="color:#a6e22e">T1&lt;/span> {{&lt;span style="color:#66d9ef">else&lt;/span>}} &lt;span style="color:#a6e22e">T0&lt;/span> {{&lt;span style="color:#a6e22e">end&lt;/span>}}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>range 可以迭代 slice、数组、map 或 channel。迭代的时候，会设置&amp;quot;.&amp;ldquo;为当前正在迭代的元素。
对于第一个表达式，当迭代对象的值为 0 值时，则 range 直接跳过，就像 if 一样。对于第二个表达式，则在迭代到 0 值时执行 else 语句。&lt;/p>
&lt;pre>&lt;code>tx := template.Must(template.New(&amp;quot;hh&amp;quot;).Parse(
`{{range $x := . -}}
{{println $x}}
{{- end}}
`))
s := []int{11, 22, 33, 44, 55}
_ = tx.Execute(os.Stdout, s)
&lt;/code>&lt;/pre>
&lt;p>需注意的是，range 的参数部分是 pipeline，所以在迭代的过程中是可以进行赋值的。但有两种赋值情况：&lt;/p>
&lt;pre>&lt;code>{{range $value := .}}
{{range $key,$value := .}}
&lt;/code>&lt;/pre>
&lt;p>如果 range 中只赋值给一个变量，则这个变量是当前正在迭代元素的值。如果赋值给两个变量，则第一个变量是索引值(map/slice 是数值，map 是 key)，第二个变量是当前正在迭代元素的值。
下面是在 html 中使用 range 的一个示例。test.html 文件内容如下：&lt;/p>
&lt;pre>&lt;code>&amp;lt;html&amp;gt;
&amp;lt;head&amp;gt;
&amp;lt;meta http-equiv=&amp;quot;Content-Type&amp;quot; content=&amp;quot;text/html; charset=utf-8&amp;quot;&amp;gt;
&amp;lt;title&amp;gt;Go Web&amp;lt;/title&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
&amp;lt;ul&amp;gt;
{{ range . }}
&amp;lt;li&amp;gt;{{ . }}&amp;lt;/li&amp;gt;
{{ else }}
&amp;lt;li&amp;gt; Nothing to show &amp;lt;/li&amp;gt;
{{ end}}
&amp;lt;/ul&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/code>&lt;/pre>
&lt;p>以下是 test.html 同目录下的 go 程序文件：&lt;/p>
&lt;pre>&lt;code>package main
import (
&amp;quot;html/template&amp;quot;
&amp;quot;net/http&amp;quot;
)
func main() {
server := http.Server{
Addr: &amp;quot;127.0.0.1:8080&amp;quot;,
}
http.HandleFunc(&amp;quot;/process&amp;quot;, process)
server.ListenAndServe()
}
func process(w http.ResponseWriter, r *http.Request) {
t1 := template.Must(template.ParseFiles(&amp;quot;test.html&amp;quot;))
s := []string{
&amp;quot;星期一&amp;quot;,
&amp;quot;星期二&amp;quot;,
&amp;quot;星期三&amp;quot;,
&amp;quot;星期四&amp;quot;,
&amp;quot;星期五&amp;quot;,
&amp;quot;星期六&amp;quot;,
&amp;quot;星期日&amp;quot;,}
t1.Execute(w, s)
}
&lt;/code>&lt;/pre>
&lt;h2 id="withend">with&amp;hellip;end&lt;/h2>
&lt;p>&lt;strong>with 用来设置&amp;rdquo;.&amp;ldquo;的值&lt;/strong>。两种格式：&lt;/p>
&lt;pre>&lt;code>{{with pipeline}} T1 {{end}}
{{with pipeline}} T1 {{else}} T0 {{end}}
&lt;/code>&lt;/pre>
&lt;p>对于第一种格式，当 pipeline 不为 0 值的时候，点&amp;rdquo;.&amp;ldquo;设置为 pipeline 运算的值，否则跳过。对于第二种格式，当 pipeline 为 0 值时，执行 else 语句块，否则&amp;rdquo;.&amp;ldquo;设置为 pipeline 运算的值，并执行 T1。
例如：&lt;/p>
&lt;pre>&lt;code>{{with &amp;quot;xx&amp;quot;}}{{println .}}{{end}}
&lt;/code>&lt;/pre>
&lt;p>上面将输出&lt;code>xx&lt;/code>，因为&amp;rdquo;.&amp;ldquo;已经设置为&amp;quot;xx&amp;rdquo;。&lt;/p>
&lt;h2 id="内置函数和自定义函数">内置函数和自定义函数&lt;/h2>
&lt;p>template 定义了一些内置函数，也支持自定义函数。关于如何自定义函数，见&lt;a href="https://www.cnblogs.com/f-ck-need-u/p/10035768.html">深入剖析 Go template&lt;/a>。
以下是内置的函数列表：
and
返回第一个为空的参数或最后一个参数。可以有任意多个参数。
and x y 等价于 if x then y else x
not
布尔取反。只能一个参数。
or
返回第一个不为空的参数或最后一个参数。可以有任意多个参数。
&amp;ldquo;or x y&amp;quot;等价于&amp;quot;if x then x else y&amp;rdquo;。
print
printf
println
分别等价于 fmt 包中的 Sprint、Sprintf、Sprintln
len
返回参数的 length。
index
对可索引对象进行索引取值。第一个参数是索引对象，后面的参数是索引位。
&amp;ldquo;index x 1 2 3&amp;quot;代表的是 x[1][2][3]。
可索引对象包括 map、slice、array。
call
显式调用函数。第一个参数必须是函数类型，且不是 template 中的函数，而是外部函数。
例如一个 struct 中的某个字段是 func 类型的。
&amp;ldquo;call .X.Y 1 2&amp;quot;表示调用 dot.X.Y(1, 2)，Y 必须是 func 类型，函数参数是 1 和 2。
函数必须只能有一个或 2 个返回值，如果有第二个返回值，则必须为 error 类型。
除此之外，还内置一些用于比较的函数：&lt;/p>
&lt;pre>&lt;code>eq arg1 arg2：
arg1 == arg2时为true
ne arg1 arg2：
arg1 != arg2时为true
lt arg1 arg2：
arg1 &amp;lt; arg2时为true
le arg1 arg2：
arg1 &amp;lt;= arg2时为true
gt arg1 arg2：
arg1 &amp;gt; arg2时为true
ge arg1 arg2：
arg1 &amp;gt;= arg2时为true
&lt;/code>&lt;/pre>
&lt;p>对于 eq 函数，支持多个参数：&lt;/p>
&lt;pre>&lt;code>eq arg1 arg2 arg3 arg4...
&lt;/code>&lt;/pre>
&lt;p>它们都和第一个参数 arg1 进行比较。它等价于：&lt;/p>
&lt;pre>&lt;code>arg1==arg2 || arg1==arg3 || arg1==arg4
&lt;/code>&lt;/pre>
&lt;p>示例：&lt;/p>
&lt;pre>&lt;code>{{ if (gt $x 33) }}{{println $x}}{{ end }}
&lt;/code>&lt;/pre>
&lt;h2 id="嵌套模板define-和-template">嵌套模板：define 和 template&lt;/h2>
&lt;p>&lt;code>define&lt;/code> 关键字可以直接在待解析内容中定义一个模板，这个模板会加入到 common 结构组中，并关联到关联名称上。如果不理解，还是建议阅读&lt;a href="https://www.cnblogs.com/f-ck-need-u/p/10035768.html">深入剖析 Go template&lt;/a>。
定义了模板之后，可以使用 &lt;code>template&lt;/code> 关键字来引用模板。&lt;code>template&lt;/code> 有两种格式：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>{{&lt;span style="color:#a6e22e">template&lt;/span> &lt;span style="color:#e6db74">&amp;#34;name&amp;#34;&lt;/span>}}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>{{&lt;span style="color:#a6e22e">template&lt;/span> &lt;span style="color:#e6db74">&amp;#34;name&amp;#34;&lt;/span> &lt;span style="color:#a6e22e">pipeline&lt;/span>}}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>第一种是直接执行名为 name 的 template，点设置为 nil。第二种是点&amp;rdquo;.&amp;ldquo;设置为 pipeline 的值，并执行名为 name 的 template。可以将 template 看作是函数：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">template&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;name)
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">template(&amp;#34;&lt;/span>&lt;span style="color:#a6e22e">name&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">&amp;#34;&lt;/span>,&lt;span style="color:#a6e22e">pipeline&lt;/span>)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>例如：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">func&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">t1&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">template&lt;/span>.&lt;span style="color:#a6e22e">New&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;test1&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">tmpl&lt;/span>, &lt;span style="color:#a6e22e">_&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">t1&lt;/span>.&lt;span style="color:#a6e22e">Parse&lt;/span>(
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">`&lt;/span>&lt;span style="color:#75715e">{{-&lt;/span> &lt;span style="color:#a6e22e">define&lt;/span> &lt;span style="color:#e6db74">&amp;#34;T1&amp;#34;&lt;/span>&lt;span style="color:#75715e">}}&lt;/span>&lt;span style="color:#e6db74">ONE &lt;/span>&lt;span style="color:#75715e">{{&lt;/span>&lt;span style="color:#66d9ef">println&lt;/span> &lt;span style="color:#a6e22e">.&lt;/span>&lt;span style="color:#75715e">}}{{&lt;/span>&lt;span style="color:#66d9ef">end&lt;/span>&lt;span style="color:#75715e">}}&lt;/span>&lt;span style="color:#e6db74">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">&lt;/span>&lt;span style="color:#75715e">{{-&lt;/span> &lt;span style="color:#a6e22e">define&lt;/span> &lt;span style="color:#e6db74">&amp;#34;T2&amp;#34;&lt;/span>&lt;span style="color:#75715e">}}&lt;/span>&lt;span style="color:#e6db74">TWO &lt;/span>&lt;span style="color:#75715e">{{&lt;/span>&lt;span style="color:#66d9ef">println&lt;/span> &lt;span style="color:#a6e22e">.&lt;/span>&lt;span style="color:#75715e">}}{{&lt;/span>&lt;span style="color:#66d9ef">end&lt;/span>&lt;span style="color:#75715e">}}&lt;/span>&lt;span style="color:#e6db74">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">&lt;/span>&lt;span style="color:#75715e">{{-&lt;/span> &lt;span style="color:#a6e22e">define&lt;/span> &lt;span style="color:#e6db74">&amp;#34;T3&amp;#34;&lt;/span>&lt;span style="color:#75715e">}}{{&lt;/span>&lt;span style="color:#66d9ef">template&lt;/span> &lt;span style="color:#e6db74">&amp;#34;T1&amp;#34;&lt;/span>&lt;span style="color:#75715e">}}{{&lt;/span>&lt;span style="color:#66d9ef">template&lt;/span> &lt;span style="color:#e6db74">&amp;#34;T2&amp;#34;&lt;/span> &lt;span style="color:#e6db74">&amp;#34;haha&amp;#34;&lt;/span>&lt;span style="color:#75715e">}}{{&lt;/span>&lt;span style="color:#66d9ef">end&lt;/span>&lt;span style="color:#75715e">}}&lt;/span>&lt;span style="color:#e6db74">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">&lt;/span>&lt;span style="color:#75715e">{{-&lt;/span> &lt;span style="color:#66d9ef">template&lt;/span> &lt;span style="color:#e6db74">&amp;#34;T3&amp;#34;&lt;/span> &lt;span style="color:#75715e">-}}&lt;/span>&lt;span style="color:#e6db74">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">`&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">_&lt;/span> = &lt;span style="color:#a6e22e">tmpl&lt;/span>.&lt;span style="color:#a6e22e">Execute&lt;/span>(&lt;span style="color:#a6e22e">os&lt;/span>.&lt;span style="color:#a6e22e">Stdout&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;hello world&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>输出结果：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">ONE&lt;/span> &amp;lt;&lt;span style="color:#66d9ef">nil&lt;/span>&amp;gt;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">TWO&lt;/span> &lt;span style="color:#a6e22e">haha&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>上面定义了 4 个模板，一个是 test1，另外三个是使用 define 来定义的 T1、T2、T3，其中 t1 是 test1 模板的关联名称。T1、T2、T3 和 test1 共享一个 common 结构。其中 T3 中包含了执行 T1 和 T2 的语句。最后只要&lt;code>{{template T3}}&lt;/code>就可以执行 T3，执行 T3 又会执行 T1 和 T2。也就是实现了嵌套。此外，执行&lt;code>{{template &amp;quot;T1&amp;quot;}}&lt;/code>时，点设置为 nil，而&lt;code>{{temlate &amp;quot;T2&amp;quot; &amp;quot;haha&amp;quot;}}&lt;/code>的点设置为了&amp;quot;haha&amp;rdquo;。
注意，&lt;strong>模板之间的变量是不会继承的&lt;/strong>。
下面是 html 文件中嵌套模板的几个示例。
t1.html 文件内容如下：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-html" data-lang="html">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&amp;lt;!DOCTYPE html&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&amp;lt;&lt;span style="color:#f92672">html&lt;/span> &lt;span style="color:#a6e22e">lang&lt;/span>&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;en&amp;#34;&lt;/span>&amp;gt;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &amp;lt;&lt;span style="color:#f92672">head&lt;/span>&amp;gt;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &amp;lt;&lt;span style="color:#f92672">meta&lt;/span> &lt;span style="color:#a6e22e">charset&lt;/span>&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;utf-8&amp;#34;&lt;/span> /&amp;gt;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &amp;lt;&lt;span style="color:#f92672">meta&lt;/span> &lt;span style="color:#a6e22e">http-equiv&lt;/span>&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;X-UA-Compatible&amp;#34;&lt;/span> &lt;span style="color:#a6e22e">content&lt;/span>&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;IE=9&amp;#34;&lt;/span> /&amp;gt;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &amp;lt;&lt;span style="color:#f92672">title&lt;/span>&amp;gt;Go Web Programming&amp;lt;/&lt;span style="color:#f92672">title&lt;/span>&amp;gt;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &amp;lt;/&lt;span style="color:#f92672">head&lt;/span>&amp;gt;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &amp;lt;&lt;span style="color:#f92672">body&lt;/span>&amp;gt;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &amp;lt;&lt;span style="color:#f92672">div&lt;/span>&amp;gt;This is t1.html before&amp;lt;/&lt;span style="color:#f92672">div&lt;/span>&amp;gt;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &amp;lt;&lt;span style="color:#f92672">div&lt;/span>&amp;gt;This is the value of the dot in t1.html - [{{ . }}]&amp;lt;/&lt;span style="color:#f92672">div&lt;/span>&amp;gt;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &amp;lt;&lt;span style="color:#f92672">hr&lt;/span> /&amp;gt;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {{ template &amp;#34;t2.html&amp;#34; }}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &amp;lt;&lt;span style="color:#f92672">hr&lt;/span> /&amp;gt;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &amp;lt;&lt;span style="color:#f92672">div&lt;/span>&amp;gt;This is t1.html after&amp;lt;/&lt;span style="color:#f92672">div&lt;/span>&amp;gt;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &amp;lt;/&lt;span style="color:#f92672">body&lt;/span>&amp;gt;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&amp;lt;/&lt;span style="color:#f92672">html&lt;/span>&amp;gt;
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>因为内部有&lt;code>{{template &amp;quot;t2.html&amp;quot;}}&lt;/code>，且此处没有使用 define 去定义名为&amp;quot;t2.html&amp;quot;的模板，所以需要加载解析名为 t2.html 的文件。t2.html 文件内容如下：&lt;/p>
&lt;pre>&lt;code>1
2
3
4
&amp;lt;div style=&amp;quot;background-color: yellow;&amp;quot;&amp;gt;
This is t2.html&amp;lt;br/&amp;gt;
This is the value of the dot in t2.html - [{{ . }}]
&amp;lt;/div&amp;gt;
&lt;/code>&lt;/pre>
&lt;p>处理这两个文件的 handler 函数如下：&lt;/p>
&lt;pre>&lt;code>1
2
3
4
func process(w http.ResponseWriter, r *http.Request) {
t, _ := template.ParseFiles(&amp;quot;t1.html&amp;quot;, &amp;quot;t2.html&amp;quot;)
t.Execute(w, &amp;quot;Hello World!&amp;quot;)
}
&lt;/code>&lt;/pre>
&lt;p>上面也可以不额外定义 t2.html 文件，而是直接在 t1.html 文件中使用 define 定义一个模板。修改 t1.html 文件如下：&lt;/p>
&lt;pre>&lt;code>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html lang=&amp;quot;en&amp;quot;&amp;gt;
&amp;lt;head&amp;gt;
&amp;lt;meta charset=&amp;quot;utf-8&amp;quot;&amp;gt;
&amp;lt;meta http-equiv=&amp;quot;X-UA-Compatible&amp;quot; content=&amp;quot;IE=9&amp;quot;&amp;gt;
&amp;lt;title&amp;gt;Go Web Programming&amp;lt;/title&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
&amp;lt;div&amp;gt; This is t1.html before&amp;lt;/div&amp;gt;
&amp;lt;div&amp;gt;This is the value of the dot in t1.html - [{{ . }}]&amp;lt;/div&amp;gt;
&amp;lt;hr /&amp;gt;
{{ template &amp;quot;t2.html&amp;quot; }}
&amp;lt;hr /&amp;gt;
&amp;lt;div&amp;gt; This is t1.html after&amp;lt;/div&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
{{define &amp;quot;t2.html&amp;quot;}}
&amp;lt;div style=&amp;quot;background-color: yellow;&amp;quot;&amp;gt;
This is t2.html&amp;lt;br/&amp;gt;
This is the value of the dot in t2.html - [{{ . }}]
&amp;lt;/div&amp;gt;
{{end}}
&lt;/code>&lt;/pre>
&lt;p>然后在 handler 中，只需解析 t1.html 一个文件即可。&lt;/p>
&lt;pre>&lt;code>1
2
3
4
func process(w http.ResponseWriter, r *http.Request) {
t, _ := template.ParseFiles(&amp;quot;t1.html&amp;quot;)
t.Execute(w, &amp;quot;Hello World!&amp;quot;)
}
&lt;/code>&lt;/pre>
&lt;h2 id="block-块">block 块&lt;/h2>
&lt;pre>&lt;code>1
2
3
4
5
6
7
{{block &amp;quot;name&amp;quot; pipeline}} T1 {{end}}
A block is shorthand for defining a template
{{define &amp;quot;name&amp;quot;}} T1 {{end}}
and then executing it in place
{{template &amp;quot;name&amp;quot; pipeline}}
The typical use is to define a set of root templates that are
then customized by redefining the block templates within.
&lt;/code>&lt;/pre>
&lt;p>根据官方文档的解释：block 等价于 define 定义一个名为 name 的模板，并在&amp;quot;有需要&amp;quot;的地方执行这个模板，执行时将&amp;rdquo;.&amp;ldquo;设置为 pipeline 的值。
但应该注意，&lt;strong>block 的第一个动作是执行名为 name 的模板，如果不存在，则在此处自动定义这个模板，并执行这个临时定义的模板。换句话说，block 可以认为是设置一个默认模板&lt;/strong>。
例如：&lt;/p>
&lt;pre>&lt;code>{{block &amp;quot;T1&amp;quot; .}} one {{end}}
&lt;/code>&lt;/pre>
&lt;p>它首先表示&lt;code>{{template &amp;quot;T1&amp;quot; .}}&lt;/code>，也就是说先找到 T1 模板，如果 T1 存在，则执行找到的 T1，如果没找到 T1，则临时定义一个&lt;code>{{define &amp;quot;T1&amp;quot;}} one {{end}}&lt;/code>，并执行它。
下面是正常情况下不使用 block 的示例。
home.html 文件内容如下：&lt;/p>
&lt;pre>&lt;code>1
2
3
4
5
6
7
8
9
&amp;lt;html&amp;gt;
&amp;lt;head&amp;gt;
&amp;lt;meta http-equiv=&amp;quot;Content-Type&amp;quot; content=&amp;quot;text/html; charset=utf-8&amp;quot;&amp;gt;
&amp;lt;title&amp;gt;Go Web Programming&amp;lt;/title&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
{{ template &amp;quot;content&amp;quot; }}
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/code>&lt;/pre>
&lt;p>在此文件中指定了要执行一个名为&amp;quot;content&amp;quot;的模板，但此文件中没有使用 define 定义该模板，所以需要在其它文件中定义名为 content 的模板。现在分别在两个文件中定义两个 content 模板：
red.html 文件内容如下：&lt;/p>
&lt;pre>&lt;code>1
2
3
{{ define &amp;quot;content&amp;quot; }}
&amp;lt;h1 style=&amp;quot;color: red;&amp;quot;&amp;gt;Hello World!&amp;lt;/h1&amp;gt;
{{ end }}
&lt;/code>&lt;/pre>
&lt;p>blue.html 文件内容如下：&lt;/p>
&lt;pre>&lt;code>1
2
3
{{ define &amp;quot;content&amp;quot; }}
&amp;lt;h1 style=&amp;quot;color: blue;&amp;quot;&amp;gt;Hello World!&amp;lt;/h1&amp;gt;
{{ end }}
&lt;/code>&lt;/pre>
&lt;p>在 handler 中，除了解析 home.html，还根据需要解析 red.html 或 blue.html：&lt;/p>
&lt;pre>&lt;code>1
2
3
4
5
6
7
8
9
10
func process(w http.ResponseWriter, r *http.Request) {
rand.Seed(time.Now().Unix())
t := template.New(&amp;quot;test&amp;quot;)
if rand.Intn(10) &amp;gt; 5 {
t, _ = template.ParseFiles(&amp;quot;home.html&amp;quot;, &amp;quot;red.html&amp;quot;)
} else {
t, _ = template.ParseFiles(&amp;quot;home.html&amp;quot;, &amp;quot;blue.html&amp;quot;)
}
t.Execute(w,&amp;quot;&amp;quot;)
}
&lt;/code>&lt;/pre>
&lt;p>如果使用 block，那么可以设置默认的 content 模板。例如将原本定义在 blue.html 中的 content 设置为默认模板。
修改 home.html：&lt;/p>
&lt;pre>&lt;code>1
2
3
4
5
6
7
8
9
10
11
&amp;lt;html&amp;gt;
&amp;lt;head&amp;gt;
&amp;lt;meta http-equiv=&amp;quot;Content-Type&amp;quot; content=&amp;quot;text/html; charset=utf-8&amp;quot;&amp;gt;
&amp;lt;title&amp;gt;Go Web Programming&amp;lt;/title&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
{{ block &amp;quot;content&amp;quot; . }}
&amp;lt;h1 style=&amp;quot;color: blue;&amp;quot;&amp;gt;Hello World!&amp;lt;/h1&amp;gt;
{{ end }}
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/code>&lt;/pre>
&lt;p>然后修改 handler:&lt;/p>
&lt;pre>&lt;code>1
2
3
4
5
6
7
8
9
10
func process(w http.ResponseWriter, r *http.Request) {
rand.Seed(time.Now().Unix())
t := template.New(&amp;quot;test&amp;quot;)
if rand.Intn(10) &amp;gt; 5 {
t, _ = template.ParseFiles(&amp;quot;home.html&amp;quot;, &amp;quot;red.html&amp;quot;)
} else {
t, _ = template.ParseFiles(&amp;quot;home.html&amp;quot;)
}
t.Execute(w,&amp;quot;&amp;quot;)
}
&lt;/code>&lt;/pre>
&lt;p>当执行 else 语句块的时候，发现 home.html 中要执行名为 content 的模板，但在 ParseFiles()中并没有解析包含 content 模板的文件。于是执行 block 定义的 content 模板。而执行非 else 语句的时候，因为 red.html 中定义了 content，会直接执行 red.html 中的 content。
block 通常设置在顶级的根文件中，例如上面的 home.html 中。&lt;/p>
&lt;h2 id="htmltemplate-的上下文感知">html/template 的上下文感知&lt;/h2>
&lt;p>对于 html/template 包，有一个很好用的功能：上下文感知。text/template 没有该功能。
上下文感知具体指的是根据所处环境 css、js、html、url 的 path、url 的 query，自动进行不同格式的转义。
例如，一个 handler 函数的代码如下：&lt;/p>
&lt;pre>&lt;code>func process(w http.ResponseWriter, r *http.Request) {
t, _ := template.ParseFiles(&amp;quot;test.html&amp;quot;)
content := `I asked: &amp;lt;i&amp;gt;&amp;quot;What's up?&amp;quot;&amp;lt;/i&amp;gt;`
t.Execute(w, content)
}
&lt;/code>&lt;/pre>
&lt;p>上面 content 是 Execute 的第二个参数，它的内容是包含了特殊符号的字符串。
下面是 test.html 文件的内容：&lt;/p>
&lt;pre>&lt;code>&amp;lt;html&amp;gt;
&amp;lt;head&amp;gt;
&amp;lt;meta http-equiv=&amp;quot;Content-Type&amp;quot; content=&amp;quot;text/html; charset=utf-8&amp;quot;&amp;gt;
&amp;lt;title&amp;gt;Go Web Programming&amp;lt;/title&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
&amp;lt;div&amp;gt;{{ . }}&amp;lt;/div&amp;gt;
&amp;lt;div&amp;gt;&amp;lt;a href=&amp;quot;/{{ . }}&amp;quot;&amp;gt;Path&amp;lt;/a&amp;gt;&amp;lt;/div&amp;gt;
&amp;lt;div&amp;gt;&amp;lt;a href=&amp;quot;/?q={{ . }}&amp;quot;&amp;gt;Query&amp;lt;/a&amp;gt;&amp;lt;/div&amp;gt;
&amp;lt;div&amp;gt;&amp;lt;a onclick=&amp;quot;f('{{ . }}')&amp;quot;&amp;gt;Onclick&amp;lt;/a&amp;gt;&amp;lt;/div&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/code>&lt;/pre>
&lt;p>上面 test.html 中有 4 个不同的环境，分别是 html 环境、url 的 path 环境、url 的 query 环境以及 js 环境。虽然对象都是&lt;code>{{.}}&lt;/code>，但解析执行后的值是不一样的。如果使用 curl 获取源代码，结果将如下：&lt;/p>
&lt;pre>&lt;code>&amp;lt;html&amp;gt;
&amp;lt;head&amp;gt;
&amp;lt;meta http-equiv=&amp;quot;Content-Type&amp;quot; content=&amp;quot;text/html; charset=utf-8&amp;quot;&amp;gt;
&amp;lt;title&amp;gt;Go Web Programming&amp;lt;/title&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
&amp;lt;div&amp;gt;I asked: &amp;amp;lt;i&amp;amp;gt;&amp;amp;#34;What&amp;amp;#39;s up?&amp;amp;#34;&amp;amp;lt;/i&amp;amp;gt;&amp;lt;/div&amp;gt;
&amp;lt;div&amp;gt;
&amp;lt;a href=&amp;quot;/I%20asked:%20%3ci%3e%22What%27s%20up?%22%3c/i%3e&amp;quot;&amp;gt;
Path
&amp;lt;/a&amp;gt;
&amp;lt;/div&amp;gt;
&amp;lt;div&amp;gt;
&amp;lt;a href=&amp;quot;/?q=I%20asked%3a%20%3ci%3e%22What%27s%20up%3f%22%3c%2fi%3e&amp;quot;&amp;gt;
Query
&amp;lt;/a&amp;gt;
&amp;lt;/div&amp;gt;
&amp;lt;div&amp;gt;
&amp;lt;a onclick=&amp;quot;f('I asked: \x3ci\x3e\x22What\x27s up?\x22\x3c\/i\x3e')&amp;quot;&amp;gt;
Onclick
&amp;lt;/a&amp;gt;
&amp;lt;/div&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/code>&lt;/pre>
&lt;h3 id="不转义">不转义&lt;/h3>
&lt;p>上下文感知的自动转义能让程序更加安全，比如防止 XSS 攻击(例如在表单中输入带有&lt;code>&amp;lt;script&amp;gt;...&amp;lt;/script&amp;gt;&lt;/code>的内容并提交，会使得用户提交的这部分 script 被执行)。
如果确实不想转义，可以进行类型转换。&lt;/p>
&lt;pre>&lt;code>1
2
3
4
type CSS
type HTML
type JS
type URL
&lt;/code>&lt;/pre>
&lt;p>转换成指定个时候，字符都将是字面意义。
例如：&lt;/p>
&lt;pre>&lt;code>1
2
3
4
func process(w http.ResponseWriter, r *http.Request) {
t, _ := template.ParseFiles(&amp;quot;tmpl.html&amp;quot;)
t.Execute(w, template.HTML(r.FormValue(&amp;quot;comment&amp;quot;)))
}
&lt;/code>&lt;/pre>
&lt;p>&lt;strong>转载请注明出处：&lt;/strong>&lt;a href="https://www.cnblogs.com/f-ck-need-u/p/10053124.html">&lt;strong>https://www.cnblogs.com/f-ck-need-u/p/10053124.html&lt;/strong>&lt;/a>&lt;/p></description></item><item><title>Docs: Unit test(单元测试)</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/2.%E7%BC%96%E7%A8%8B/%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/go/go-%E6%A0%87%E5%87%86%E5%BA%93/unit-test%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/2.%E7%BC%96%E7%A8%8B/%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/go/go-%E6%A0%87%E5%87%86%E5%BA%93/unit-test%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://go.dev/doc/tutorial/add-a-test">官方文档，教程-添加一个测试&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://geektutu.com/post/quick-go-test.html">https://geektutu.com/post/quick-go-test.html&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;h2 id="1-如何写好单元测试">1 如何写好单元测试&lt;/h2>
&lt;p>单元测试(Unit Tests, UT) 是一个优秀项目不可或缺的一部分，特别是在一些频繁变动和多人合作开发的项目中尤为重要。你或多或少都会有因为自己的提交，导致应用挂掉或服务宕机的经历。如果这个时候你的修改导致测试用例失败，你再重新审视自己的修改，发现之前的修改还有一些特殊场景没有包含，恭喜你减少了一次上库失误。也会有这样的情况，项目很大，启动环境很复杂，你优化了一个函数的性能，或是添加了某个新的特性，如果部署在正式环境上之后再进行测试，成本太高。对于这种场景，几个小小的测试用例或许就能够覆盖大部分的测试场景。而且在开发过程中，效率最高的莫过于所见即所得了，单元测试也能够帮助你做到这一点，试想一下，假如你一口气写完一千行代码，debug 的过程也不会轻松，如果在这个过程中，对于一些逻辑较为复杂的函数，同时添加一些测试用例，即时确保正确性，最后集成的时候，会是另外一番体验。&lt;/p>
&lt;p>如何写好单元测试呢？&lt;/p>
&lt;p>首先，学会写测试用例。比如如何测试单个函数/方法；比如如何做基准测试；比如如何写出简洁精炼的测试代码；再比如遇到数据库访问等的方法调用时，如何 &lt;code>mock&lt;/code>。&lt;/p>
&lt;p>然后，写可测试的代码。&lt;code>高内聚，低耦合&lt;/code>是软件工程的原则，同样，对测试而言，函数/方法写法不同，测试难度也是不一样的。职责单一，参数类型简单，与其他函数耦合度低的函数往往更容易测试。我们经常会说，“这种代码没法测试”，这种时候，就得思考函数的写法可不可以改得更好一些。为了代码可测试而重构是值得的。&lt;/p>
&lt;p>接下来将介绍如何使用 Go 语言的标准库 &lt;code>testing&lt;/code> 进行单元测试。&lt;/p>
&lt;h2 id="2-一个简单例子">2 一个简单例子&lt;/h2>
&lt;p>Go 语言推荐测试文件和源代码文件放在一块，测试文件以 &lt;code>_test.go&lt;/code> 结尾。比如，当前 package 有 &lt;code>calc.go&lt;/code> 一个文件，我们想测试 &lt;code>calc.go&lt;/code> 中的 &lt;code>Add&lt;/code> 和 &lt;code>Mul&lt;/code> 函数，那么应该新建 &lt;code>calc_test.go&lt;/code> 作为测试文件。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>example/
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> |--calc.go
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> |--calc_test.go
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>假如 &lt;code>calc.go&lt;/code> 的代码如下：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">package&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">func&lt;/span> &lt;span style="color:#a6e22e">Add&lt;/span>(&lt;span style="color:#a6e22e">a&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span>, &lt;span style="color:#a6e22e">b&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span>) &lt;span style="color:#66d9ef">int&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#a6e22e">a&lt;/span> &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#a6e22e">b&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">func&lt;/span> &lt;span style="color:#a6e22e">Mul&lt;/span>(&lt;span style="color:#a6e22e">a&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span>, &lt;span style="color:#a6e22e">b&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span>) &lt;span style="color:#66d9ef">int&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#a6e22e">a&lt;/span> &lt;span style="color:#f92672">*&lt;/span> &lt;span style="color:#a6e22e">b&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>那么 &lt;code>calc_test.go&lt;/code> 中的测试用例可以这么写：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">package&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">import&lt;/span> &lt;span style="color:#e6db74">&amp;#34;testing&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">func&lt;/span> &lt;span style="color:#a6e22e">TestAdd&lt;/span>(&lt;span style="color:#a6e22e">t&lt;/span> &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">testing&lt;/span>.&lt;span style="color:#a6e22e">T&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> &lt;span style="color:#a6e22e">ans&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">Add&lt;/span>(&lt;span style="color:#ae81ff">1&lt;/span>, &lt;span style="color:#ae81ff">2&lt;/span>); &lt;span style="color:#a6e22e">ans&lt;/span> &lt;span style="color:#f92672">!=&lt;/span> &lt;span style="color:#ae81ff">3&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">t&lt;/span>.&lt;span style="color:#a6e22e">Errorf&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;1 + 2 expected be 3, but %d got&amp;#34;&lt;/span>, &lt;span style="color:#a6e22e">ans&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> &lt;span style="color:#a6e22e">ans&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">Add&lt;/span>(&lt;span style="color:#f92672">-&lt;/span>&lt;span style="color:#ae81ff">10&lt;/span>, &lt;span style="color:#f92672">-&lt;/span>&lt;span style="color:#ae81ff">20&lt;/span>); &lt;span style="color:#a6e22e">ans&lt;/span> &lt;span style="color:#f92672">!=&lt;/span> &lt;span style="color:#f92672">-&lt;/span>&lt;span style="color:#ae81ff">30&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">t&lt;/span>.&lt;span style="color:#a6e22e">Errorf&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;-10 + -20 expected be -30, but %d got&amp;#34;&lt;/span>, &lt;span style="color:#a6e22e">ans&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ul>
&lt;li>测试用例名称一般命名为 &lt;code>Test + 待测试的方法名&lt;/code>。&lt;/li>
&lt;li>测试用的参数有且只有一个，在这里是 &lt;code>t *testing.T&lt;/code>。&lt;/li>
&lt;li>基准测试(benchmark)的参数是 &lt;code>*testing.B&lt;/code>，TestMain 的参数是 &lt;code>*testing.M&lt;/code> 类型。&lt;/li>
&lt;/ul>
&lt;p>运行 &lt;code>go test&lt;/code>，该 package 下所有的测试用例都会被执行。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>$ go test
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>ok example 0.009s
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>或 &lt;code>go test -v&lt;/code>，&lt;code>-v&lt;/code> 参数会显示每个用例的测试结果，另外 &lt;code>-cover&lt;/code> 参数可以查看覆盖率。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>$ go test -v
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">===&lt;/span> RUN TestAdd
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>--- PASS: TestAdd &lt;span style="color:#f92672">(&lt;/span>0.00s&lt;span style="color:#f92672">)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">===&lt;/span> RUN TestMul
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>--- PASS: TestMul &lt;span style="color:#f92672">(&lt;/span>0.00s&lt;span style="color:#f92672">)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>PASS
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>ok example 0.007s
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>如果只想运行其中的一个用例，例如 &lt;code>TestAdd&lt;/code>，可以用 &lt;code>-run&lt;/code> 参数指定，该参数支持通配符 &lt;code>*&lt;/code>，和部分正则表达式，例如 &lt;code>^&lt;/code>、&lt;code>$&lt;/code>。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>$ go test -run TestAdd -v
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">===&lt;/span> RUN TestAdd
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>--- PASS: TestAdd &lt;span style="color:#f92672">(&lt;/span>0.00s&lt;span style="color:#f92672">)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>PASS
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>ok example 0.007s
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="3-子测试subtests">3 子测试(Subtests)&lt;/h2>
&lt;p>子测试是 Go 语言内置支持的，可以在某个测试用例中，根据测试场景使用 &lt;code>t.Run&lt;/code>创建不同的子测试用例：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">func&lt;/span> &lt;span style="color:#a6e22e">TestMul&lt;/span>(&lt;span style="color:#a6e22e">t&lt;/span> &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">testing&lt;/span>.&lt;span style="color:#a6e22e">T&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">t&lt;/span>.&lt;span style="color:#a6e22e">Run&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;pos&amp;#34;&lt;/span>, &lt;span style="color:#66d9ef">func&lt;/span>(&lt;span style="color:#a6e22e">t&lt;/span> &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">testing&lt;/span>.&lt;span style="color:#a6e22e">T&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> &lt;span style="color:#a6e22e">Mul&lt;/span>(&lt;span style="color:#ae81ff">2&lt;/span>, &lt;span style="color:#ae81ff">3&lt;/span>) &lt;span style="color:#f92672">!=&lt;/span> &lt;span style="color:#ae81ff">6&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">t&lt;/span>.&lt;span style="color:#a6e22e">Fatal&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;fail&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> })
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">t&lt;/span>.&lt;span style="color:#a6e22e">Run&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;neg&amp;#34;&lt;/span>, &lt;span style="color:#66d9ef">func&lt;/span>(&lt;span style="color:#a6e22e">t&lt;/span> &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">testing&lt;/span>.&lt;span style="color:#a6e22e">T&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> &lt;span style="color:#a6e22e">Mul&lt;/span>(&lt;span style="color:#ae81ff">2&lt;/span>, &lt;span style="color:#f92672">-&lt;/span>&lt;span style="color:#ae81ff">3&lt;/span>) &lt;span style="color:#f92672">!=&lt;/span> &lt;span style="color:#f92672">-&lt;/span>&lt;span style="color:#ae81ff">6&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">t&lt;/span>.&lt;span style="color:#a6e22e">Fatal&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;fail&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> })
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ul>
&lt;li>之前的例子测试失败时使用 &lt;code>t.Error/t.Errorf&lt;/code>，这个例子中使用 &lt;code>t.Fatal/t.Fatalf&lt;/code>，区别在于前者遇错不停，还会继续执行其他的测试用例，后者遇错即停。&lt;/li>
&lt;/ul>
&lt;p>运行某个测试用例的子测试：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>$ go test -run TestMul/pos -v
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">===&lt;/span> RUN TestMul
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">===&lt;/span> RUN TestMul/pos
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>--- PASS: TestMul &lt;span style="color:#f92672">(&lt;/span>0.00s&lt;span style="color:#f92672">)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> --- PASS: TestMul/pos &lt;span style="color:#f92672">(&lt;/span>0.00s&lt;span style="color:#f92672">)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>PASS
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>ok example 0.008s
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>对于多个子测试的场景，更推荐如下的写法(table-driven tests)：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">func&lt;/span> &lt;span style="color:#a6e22e">TestMul&lt;/span>(&lt;span style="color:#a6e22e">t&lt;/span> &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">testing&lt;/span>.&lt;span style="color:#a6e22e">T&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">cases&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> []&lt;span style="color:#66d9ef">struct&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">Name&lt;/span> &lt;span style="color:#66d9ef">string&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">A&lt;/span>, &lt;span style="color:#a6e22e">B&lt;/span>, &lt;span style="color:#a6e22e">Expected&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {&lt;span style="color:#e6db74">&amp;#34;pos&amp;#34;&lt;/span>, &lt;span style="color:#ae81ff">2&lt;/span>, &lt;span style="color:#ae81ff">3&lt;/span>, &lt;span style="color:#ae81ff">6&lt;/span>},
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {&lt;span style="color:#e6db74">&amp;#34;neg&amp;#34;&lt;/span>, &lt;span style="color:#ae81ff">2&lt;/span>, &lt;span style="color:#f92672">-&lt;/span>&lt;span style="color:#ae81ff">3&lt;/span>, &lt;span style="color:#f92672">-&lt;/span>&lt;span style="color:#ae81ff">6&lt;/span>},
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {&lt;span style="color:#e6db74">&amp;#34;zero&amp;#34;&lt;/span>, &lt;span style="color:#ae81ff">2&lt;/span>, &lt;span style="color:#ae81ff">0&lt;/span>, &lt;span style="color:#ae81ff">0&lt;/span>},
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span> &lt;span style="color:#a6e22e">_&lt;/span>, &lt;span style="color:#a6e22e">c&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#66d9ef">range&lt;/span> &lt;span style="color:#a6e22e">cases&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">t&lt;/span>.&lt;span style="color:#a6e22e">Run&lt;/span>(&lt;span style="color:#a6e22e">c&lt;/span>.&lt;span style="color:#a6e22e">Name&lt;/span>, &lt;span style="color:#66d9ef">func&lt;/span>(&lt;span style="color:#a6e22e">t&lt;/span> &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">testing&lt;/span>.&lt;span style="color:#a6e22e">T&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> &lt;span style="color:#a6e22e">ans&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">Mul&lt;/span>(&lt;span style="color:#a6e22e">c&lt;/span>.&lt;span style="color:#a6e22e">A&lt;/span>, &lt;span style="color:#a6e22e">c&lt;/span>.&lt;span style="color:#a6e22e">B&lt;/span>); &lt;span style="color:#a6e22e">ans&lt;/span> &lt;span style="color:#f92672">!=&lt;/span> &lt;span style="color:#a6e22e">c&lt;/span>.&lt;span style="color:#a6e22e">Expected&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">t&lt;/span>.&lt;span style="color:#a6e22e">Fatalf&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;%d * %d expected %d, but %d got&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">c&lt;/span>.&lt;span style="color:#a6e22e">A&lt;/span>, &lt;span style="color:#a6e22e">c&lt;/span>.&lt;span style="color:#a6e22e">B&lt;/span>, &lt;span style="color:#a6e22e">c&lt;/span>.&lt;span style="color:#a6e22e">Expected&lt;/span>, &lt;span style="color:#a6e22e">ans&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> })
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>所有用例的数据组织在切片 &lt;code>cases&lt;/code> 中，看起来就像一张表，借助循环创建子测试。这样写的好处有：&lt;/p>
&lt;ul>
&lt;li>新增用例非常简单，只需给 cases 新增一条测试数据即可。&lt;/li>
&lt;li>测试代码可读性好，直观地能够看到每个子测试的参数和期待的返回值。&lt;/li>
&lt;li>用例失败时，报错信息的格式比较统一，测试报告易于阅读。&lt;/li>
&lt;/ul>
&lt;p>如果数据量较大，或是一些二进制数据，推荐使用相对路径从文件中读取。&lt;/p>
&lt;h2 id="4-帮助函数helpers">4 帮助函数(helpers)&lt;/h2>
&lt;p>对一些重复的逻辑，抽取出来作为公共的帮助函数(helpers)，可以增加测试代码的可读性和可维护性。 借助帮助函数，可以让测试用例的主逻辑看起来更清晰。&lt;/p>
&lt;p>例如，我们可以将创建子测试的逻辑抽取出来：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">package&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">import&lt;/span> &lt;span style="color:#e6db74">&amp;#34;testing&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">type&lt;/span> &lt;span style="color:#a6e22e">calcCase&lt;/span> &lt;span style="color:#66d9ef">struct&lt;/span>{ &lt;span style="color:#a6e22e">A&lt;/span>, &lt;span style="color:#a6e22e">B&lt;/span>, &lt;span style="color:#a6e22e">Expected&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">func&lt;/span> &lt;span style="color:#a6e22e">createMulTestCase&lt;/span>(&lt;span style="color:#a6e22e">t&lt;/span> &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">testing&lt;/span>.&lt;span style="color:#a6e22e">T&lt;/span>, &lt;span style="color:#a6e22e">c&lt;/span> &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">calcCase&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> &lt;span style="color:#a6e22e">ans&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">Mul&lt;/span>(&lt;span style="color:#a6e22e">c&lt;/span>.&lt;span style="color:#a6e22e">A&lt;/span>, &lt;span style="color:#a6e22e">c&lt;/span>.&lt;span style="color:#a6e22e">B&lt;/span>); &lt;span style="color:#a6e22e">ans&lt;/span> &lt;span style="color:#f92672">!=&lt;/span> &lt;span style="color:#a6e22e">c&lt;/span>.&lt;span style="color:#a6e22e">Expected&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">t&lt;/span>.&lt;span style="color:#a6e22e">Fatalf&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;%d * %d expected %d, but %d got&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">c&lt;/span>.&lt;span style="color:#a6e22e">A&lt;/span>, &lt;span style="color:#a6e22e">c&lt;/span>.&lt;span style="color:#a6e22e">B&lt;/span>, &lt;span style="color:#a6e22e">c&lt;/span>.&lt;span style="color:#a6e22e">Expected&lt;/span>, &lt;span style="color:#a6e22e">ans&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">func&lt;/span> &lt;span style="color:#a6e22e">TestMul&lt;/span>(&lt;span style="color:#a6e22e">t&lt;/span> &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">testing&lt;/span>.&lt;span style="color:#a6e22e">T&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">createMulTestCase&lt;/span>(&lt;span style="color:#a6e22e">t&lt;/span>, &lt;span style="color:#f92672">&amp;amp;&lt;/span>&lt;span style="color:#a6e22e">calcCase&lt;/span>{&lt;span style="color:#ae81ff">2&lt;/span>, &lt;span style="color:#ae81ff">3&lt;/span>, &lt;span style="color:#ae81ff">6&lt;/span>})
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">createMulTestCase&lt;/span>(&lt;span style="color:#a6e22e">t&lt;/span>, &lt;span style="color:#f92672">&amp;amp;&lt;/span>&lt;span style="color:#a6e22e">calcCase&lt;/span>{&lt;span style="color:#ae81ff">2&lt;/span>, &lt;span style="color:#f92672">-&lt;/span>&lt;span style="color:#ae81ff">3&lt;/span>, &lt;span style="color:#f92672">-&lt;/span>&lt;span style="color:#ae81ff">6&lt;/span>})
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">createMulTestCase&lt;/span>(&lt;span style="color:#a6e22e">t&lt;/span>, &lt;span style="color:#f92672">&amp;amp;&lt;/span>&lt;span style="color:#a6e22e">calcCase&lt;/span>{&lt;span style="color:#ae81ff">2&lt;/span>, &lt;span style="color:#ae81ff">0&lt;/span>, &lt;span style="color:#ae81ff">1&lt;/span>})
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>在这里，我们故意创建了一个错误的测试用例，运行 &lt;code>go test&lt;/code>，用例失败，会报告错误发生的文件和行号信息：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>$ go test
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>--- FAIL: TestMul &lt;span style="color:#f92672">(&lt;/span>0.00s&lt;span style="color:#f92672">)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> calc_test.go:11: &lt;span style="color:#ae81ff">2&lt;/span> * &lt;span style="color:#ae81ff">0&lt;/span> expected 1, but &lt;span style="color:#ae81ff">0&lt;/span> got
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>FAIL
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>exit status &lt;span style="color:#ae81ff">1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>FAIL example 0.007s
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>可以看到，错误发生在第 11 行，也就是帮助函数 &lt;code>createMulTestCase&lt;/code> 内部。18, 19, 20 行都调用了该方法，我们第一时间并不能够确定是哪一行发生了错误。有些帮助函数还可能在不同的函数中被调用，报错信息都在同一处，不方便问题定位。因此，Go 语言在 1.9 版本中引入了 &lt;code>t.Helper()&lt;/code>，用于标注该函数是帮助函数，报错时将输出帮助函数调用者的信息，而不是帮助函数的内部信息。&lt;/p>
&lt;p>修改 &lt;code>createMulTestCase&lt;/code>，调用 &lt;code>t.Helper()&lt;/code>&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">func&lt;/span> &lt;span style="color:#a6e22e">createMulTestCase&lt;/span>(&lt;span style="color:#a6e22e">c&lt;/span> &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">calcCase&lt;/span>, &lt;span style="color:#a6e22e">t&lt;/span> &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">testing&lt;/span>.&lt;span style="color:#a6e22e">T&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">t&lt;/span>.&lt;span style="color:#a6e22e">Helper&lt;/span>()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">t&lt;/span>.&lt;span style="color:#a6e22e">Run&lt;/span>(&lt;span style="color:#a6e22e">c&lt;/span>.&lt;span style="color:#a6e22e">Name&lt;/span>, &lt;span style="color:#66d9ef">func&lt;/span>(&lt;span style="color:#a6e22e">t&lt;/span> &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">testing&lt;/span>.&lt;span style="color:#a6e22e">T&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> &lt;span style="color:#a6e22e">ans&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">Mul&lt;/span>(&lt;span style="color:#a6e22e">c&lt;/span>.&lt;span style="color:#a6e22e">A&lt;/span>, &lt;span style="color:#a6e22e">c&lt;/span>.&lt;span style="color:#a6e22e">B&lt;/span>); &lt;span style="color:#a6e22e">ans&lt;/span> &lt;span style="color:#f92672">!=&lt;/span> &lt;span style="color:#a6e22e">c&lt;/span>.&lt;span style="color:#a6e22e">Expected&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">t&lt;/span>.&lt;span style="color:#a6e22e">Fatalf&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;%d * %d expected %d, but %d got&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">c&lt;/span>.&lt;span style="color:#a6e22e">A&lt;/span>, &lt;span style="color:#a6e22e">c&lt;/span>.&lt;span style="color:#a6e22e">B&lt;/span>, &lt;span style="color:#a6e22e">c&lt;/span>.&lt;span style="color:#a6e22e">Expected&lt;/span>, &lt;span style="color:#a6e22e">ans&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> })
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>运行 &lt;code>go test&lt;/code>，报错信息如下，可以非常清晰地知道，错误发生在第 20 行。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>$ go test
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>--- FAIL: TestMul &lt;span style="color:#f92672">(&lt;/span>0.00s&lt;span style="color:#f92672">)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> calc_test.go:20: &lt;span style="color:#ae81ff">2&lt;/span> * &lt;span style="color:#ae81ff">0&lt;/span> expected 1, but &lt;span style="color:#ae81ff">0&lt;/span> got
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>FAIL
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>exit status &lt;span style="color:#ae81ff">1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>FAIL example 0.006s
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>关于 &lt;code>helper&lt;/code> 函数的 2 个建议：&lt;/p>
&lt;ul>
&lt;li>不要返回错误， 帮助函数内部直接使用 &lt;code>t.Error&lt;/code> 或 &lt;code>t.Fatal&lt;/code> 即可，在用例主逻辑中不会因为太多的错误处理代码，影响可读性。&lt;/li>
&lt;li>调用 &lt;code>t.Helper()&lt;/code> 让报错信息更准确，有助于定位。&lt;/li>
&lt;/ul>
&lt;h2 id="5-setup-和-teardown">5 setup 和 teardown&lt;/h2>
&lt;p>如果在同一个测试文件中，每一个测试用例运行前后的逻辑是相同的，一般会写在 setup 和 teardown 函数中。例如执行前需要实例化待测试的对象，如果这个对象比较复杂，很适合将这一部分逻辑提取出来；执行后，可能会做一些资源回收类的工作，例如关闭网络连接，释放文件等。标准库 &lt;code>testing&lt;/code> 提供了这样的机制：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">func&lt;/span> &lt;span style="color:#a6e22e">setup&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">fmt&lt;/span>.&lt;span style="color:#a6e22e">Println&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;Before all tests&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">func&lt;/span> &lt;span style="color:#a6e22e">teardown&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">fmt&lt;/span>.&lt;span style="color:#a6e22e">Println&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;After all tests&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">func&lt;/span> &lt;span style="color:#a6e22e">Test1&lt;/span>(&lt;span style="color:#a6e22e">t&lt;/span> &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">testing&lt;/span>.&lt;span style="color:#a6e22e">T&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">fmt&lt;/span>.&lt;span style="color:#a6e22e">Println&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;I&amp;#39;m test1&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">func&lt;/span> &lt;span style="color:#a6e22e">Test2&lt;/span>(&lt;span style="color:#a6e22e">t&lt;/span> &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">testing&lt;/span>.&lt;span style="color:#a6e22e">T&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">fmt&lt;/span>.&lt;span style="color:#a6e22e">Println&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;I&amp;#39;m test2&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">func&lt;/span> &lt;span style="color:#a6e22e">TestMain&lt;/span>(&lt;span style="color:#a6e22e">m&lt;/span> &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">testing&lt;/span>.&lt;span style="color:#a6e22e">M&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">setup&lt;/span>()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">code&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">m&lt;/span>.&lt;span style="color:#a6e22e">Run&lt;/span>()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">teardown&lt;/span>()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">os&lt;/span>.&lt;span style="color:#a6e22e">Exit&lt;/span>(&lt;span style="color:#a6e22e">code&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ul>
&lt;li>在这个测试文件中，包含有 2 个测试用例，&lt;code>Test1&lt;/code> 和 &lt;code>Test2&lt;/code>。&lt;/li>
&lt;li>如果测试文件中包含函数 &lt;code>TestMain&lt;/code>，那么生成的测试将调用 TestMain(m)，而不是直接运行测试。&lt;/li>
&lt;li>调用 &lt;code>m.Run()&lt;/code> 触发所有测试用例的执行，并使用 &lt;code>os.Exit()&lt;/code> 处理返回的状态码，如果不为 0，说明有用例失败。&lt;/li>
&lt;li>因此可以在调用 &lt;code>m.Run()&lt;/code> 前后做一些额外的准备(setup)和回收(teardown)工作。&lt;/li>
&lt;/ul>
&lt;p>执行 &lt;code>go test&lt;/code>，将会输出&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>$ go test
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Before all tests
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>I&lt;span style="color:#e6db74">&amp;#39;m test1
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">I&amp;#39;&lt;/span>m test2
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>PASS
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>After all tests
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>ok example 0.006s
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="6-网络测试network">6 网络测试(Network)&lt;/h2>
&lt;h3 id="61-tcphttp">6.1 TCP/HTTP&lt;/h3>
&lt;p>假设需要测试某个 API 接口的 handler 能够正常工作，例如 helloHandler&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">func&lt;/span> &lt;span style="color:#a6e22e">helloHandler&lt;/span>(&lt;span style="color:#a6e22e">w&lt;/span> &lt;span style="color:#a6e22e">http&lt;/span>.&lt;span style="color:#a6e22e">ResponseWriter&lt;/span>, &lt;span style="color:#a6e22e">r&lt;/span> &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">http&lt;/span>.&lt;span style="color:#a6e22e">Request&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">w&lt;/span>.&lt;span style="color:#a6e22e">Write&lt;/span>([]byte(&lt;span style="color:#e6db74">&amp;#34;hello world&amp;#34;&lt;/span>))
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>那我们可以创建真实的网络连接进行测试：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">import&lt;/span> (
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#34;io/ioutil&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#34;net&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#34;net/http&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#34;testing&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">func&lt;/span> &lt;span style="color:#a6e22e">handleError&lt;/span>(&lt;span style="color:#a6e22e">t&lt;/span> &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">testing&lt;/span>.&lt;span style="color:#a6e22e">T&lt;/span>, &lt;span style="color:#a6e22e">err&lt;/span> &lt;span style="color:#66d9ef">error&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">t&lt;/span>.&lt;span style="color:#a6e22e">Helper&lt;/span>()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> &lt;span style="color:#a6e22e">err&lt;/span> &lt;span style="color:#f92672">!=&lt;/span> &lt;span style="color:#66d9ef">nil&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">t&lt;/span>.&lt;span style="color:#a6e22e">Fatal&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;failed&amp;#34;&lt;/span>, &lt;span style="color:#a6e22e">err&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">func&lt;/span> &lt;span style="color:#a6e22e">TestConn&lt;/span>(&lt;span style="color:#a6e22e">t&lt;/span> &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">testing&lt;/span>.&lt;span style="color:#a6e22e">T&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">ln&lt;/span>, &lt;span style="color:#a6e22e">err&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">net&lt;/span>.&lt;span style="color:#a6e22e">Listen&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;tcp&amp;#34;&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;127.0.0.1:0&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">handleError&lt;/span>(&lt;span style="color:#a6e22e">t&lt;/span>, &lt;span style="color:#a6e22e">err&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">defer&lt;/span> &lt;span style="color:#a6e22e">ln&lt;/span>.&lt;span style="color:#a6e22e">Close&lt;/span>()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">http&lt;/span>.&lt;span style="color:#a6e22e">HandleFunc&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;/hello&amp;#34;&lt;/span>, &lt;span style="color:#a6e22e">helloHandler&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">go&lt;/span> &lt;span style="color:#a6e22e">http&lt;/span>.&lt;span style="color:#a6e22e">Serve&lt;/span>(&lt;span style="color:#a6e22e">ln&lt;/span>, &lt;span style="color:#66d9ef">nil&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">resp&lt;/span>, &lt;span style="color:#a6e22e">err&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">http&lt;/span>.&lt;span style="color:#a6e22e">Get&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;http://&amp;#34;&lt;/span> &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#a6e22e">ln&lt;/span>.&lt;span style="color:#a6e22e">Addr&lt;/span>().&lt;span style="color:#a6e22e">String&lt;/span>() &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#e6db74">&amp;#34;/hello&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">handleError&lt;/span>(&lt;span style="color:#a6e22e">t&lt;/span>, &lt;span style="color:#a6e22e">err&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">defer&lt;/span> &lt;span style="color:#a6e22e">resp&lt;/span>.&lt;span style="color:#a6e22e">Body&lt;/span>.&lt;span style="color:#a6e22e">Close&lt;/span>()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">body&lt;/span>, &lt;span style="color:#a6e22e">err&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">ioutil&lt;/span>.&lt;span style="color:#a6e22e">ReadAll&lt;/span>(&lt;span style="color:#a6e22e">resp&lt;/span>.&lt;span style="color:#a6e22e">Body&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">handleError&lt;/span>(&lt;span style="color:#a6e22e">t&lt;/span>, &lt;span style="color:#a6e22e">err&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> string(&lt;span style="color:#a6e22e">body&lt;/span>) &lt;span style="color:#f92672">!=&lt;/span> &lt;span style="color:#e6db74">&amp;#34;hello world&amp;#34;&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">t&lt;/span>.&lt;span style="color:#a6e22e">Fatal&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;expected hello world, but got&amp;#34;&lt;/span>, string(&lt;span style="color:#a6e22e">body&lt;/span>))
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ul>
&lt;li>&lt;code>net.Listen(&amp;quot;tcp&amp;quot;, &amp;quot;127.0.0.1:0&amp;quot;)&lt;/code>：监听一个未被占用的端口，并返回 Listener。&lt;/li>
&lt;li>调用 &lt;code>http.Serve(ln, nil)&lt;/code> 启动 http 服务。&lt;/li>
&lt;li>使用 &lt;code>http.Get&lt;/code> 发起一个 Get 请求，检查返回值是否正确。&lt;/li>
&lt;li>尽量不对 &lt;code>http&lt;/code> 和 &lt;code>net&lt;/code> 库使用 mock，这样可以覆盖较为真实的场景。&lt;/li>
&lt;/ul>
&lt;h3 id="62-httptest">6.2 httptest&lt;/h3>
&lt;p>针对 http 开发的场景，使用标准库 &lt;code>net/http/httptest&lt;/code> 进行测试更为高效。&lt;/p>
&lt;p>上述的测试用例改写如下：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">import&lt;/span> (
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#34;io/ioutil&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#34;net/http&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#34;net/http/httptest&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#34;testing&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">func&lt;/span> &lt;span style="color:#a6e22e">TestConn&lt;/span>(&lt;span style="color:#a6e22e">t&lt;/span> &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">testing&lt;/span>.&lt;span style="color:#a6e22e">T&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">req&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">httptest&lt;/span>.&lt;span style="color:#a6e22e">NewRequest&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;GET&amp;#34;&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;http://example.com/foo&amp;#34;&lt;/span>, &lt;span style="color:#66d9ef">nil&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">w&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">httptest&lt;/span>.&lt;span style="color:#a6e22e">NewRecorder&lt;/span>()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">helloHandler&lt;/span>(&lt;span style="color:#a6e22e">w&lt;/span>, &lt;span style="color:#a6e22e">req&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">bytes&lt;/span>, &lt;span style="color:#a6e22e">_&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">ioutil&lt;/span>.&lt;span style="color:#a6e22e">ReadAll&lt;/span>(&lt;span style="color:#a6e22e">w&lt;/span>.&lt;span style="color:#a6e22e">Result&lt;/span>().&lt;span style="color:#a6e22e">Body&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> string(&lt;span style="color:#a6e22e">bytes&lt;/span>) &lt;span style="color:#f92672">!=&lt;/span> &lt;span style="color:#e6db74">&amp;#34;hello world&amp;#34;&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">t&lt;/span>.&lt;span style="color:#a6e22e">Fatal&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;expected hello world, but got&amp;#34;&lt;/span>, string(&lt;span style="color:#a6e22e">bytes&lt;/span>))
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>使用 httptest 模拟请求对象(req)和响应对象(w)，达到了相同的目的。&lt;/p>
&lt;h2 id="7-benchmark-基准测试">7 Benchmark 基准测试&lt;/h2>
&lt;p>基准测试用例的定义如下：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">func&lt;/span> &lt;span style="color:#a6e22e">BenchmarkName&lt;/span>(&lt;span style="color:#a6e22e">b&lt;/span> &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">testing&lt;/span>.&lt;span style="color:#a6e22e">B&lt;/span>){
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ul>
&lt;li>函数名必须以 &lt;code>Benchmark&lt;/code> 开头，后面一般跟待测试的函数名&lt;/li>
&lt;li>参数为 &lt;code>b *testing.B&lt;/code>。&lt;/li>
&lt;li>执行基准测试时，需要添加 &lt;code>-bench&lt;/code> 参数。&lt;/li>
&lt;/ul>
&lt;p>例如：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">func&lt;/span> &lt;span style="color:#a6e22e">BenchmarkHello&lt;/span>(&lt;span style="color:#a6e22e">b&lt;/span> &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">testing&lt;/span>.&lt;span style="color:#a6e22e">B&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span> &lt;span style="color:#a6e22e">i&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>; &lt;span style="color:#a6e22e">i&lt;/span> &amp;lt; &lt;span style="color:#a6e22e">b&lt;/span>.&lt;span style="color:#a6e22e">N&lt;/span>; &lt;span style="color:#a6e22e">i&lt;/span>&lt;span style="color:#f92672">++&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">fmt&lt;/span>.&lt;span style="color:#a6e22e">Sprintf&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;hello&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>$ go test -benchmem -bench .
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>...
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>BenchmarkHello-16 &lt;span style="color:#ae81ff">15991854&lt;/span> 71.6 ns/op &lt;span style="color:#ae81ff">5&lt;/span> B/op &lt;span style="color:#ae81ff">1&lt;/span> allocs/op
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>...
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>基准测试报告每一列值对应的含义如下：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">type&lt;/span> &lt;span style="color:#a6e22e">BenchmarkResult&lt;/span> &lt;span style="color:#66d9ef">struct&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">N&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">T&lt;/span> &lt;span style="color:#a6e22e">time&lt;/span>.&lt;span style="color:#a6e22e">Duration&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">Bytes&lt;/span> &lt;span style="color:#66d9ef">int64&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">MemAllocs&lt;/span> &lt;span style="color:#66d9ef">uint64&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">MemBytes&lt;/span> &lt;span style="color:#66d9ef">uint64&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>如果在运行前基准测试需要一些耗时的配置，则可以使用 &lt;code>b.ResetTimer()&lt;/code> 先重置定时器，例如：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">func&lt;/span> &lt;span style="color:#a6e22e">BenchmarkHello&lt;/span>(&lt;span style="color:#a6e22e">b&lt;/span> &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">testing&lt;/span>.&lt;span style="color:#a6e22e">B&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">...&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">b&lt;/span>.&lt;span style="color:#a6e22e">ResetTimer&lt;/span>()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span> &lt;span style="color:#a6e22e">i&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>; &lt;span style="color:#a6e22e">i&lt;/span> &amp;lt; &lt;span style="color:#a6e22e">b&lt;/span>.&lt;span style="color:#a6e22e">N&lt;/span>; &lt;span style="color:#a6e22e">i&lt;/span>&lt;span style="color:#f92672">++&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">fmt&lt;/span>.&lt;span style="color:#a6e22e">Sprintf&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;hello&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>使用 &lt;code>RunParallel&lt;/code> 测试并发性能&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">func&lt;/span> &lt;span style="color:#a6e22e">BenchmarkParallel&lt;/span>(&lt;span style="color:#a6e22e">b&lt;/span> &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">testing&lt;/span>.&lt;span style="color:#a6e22e">B&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">templ&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">template&lt;/span>.&lt;span style="color:#a6e22e">Must&lt;/span>(&lt;span style="color:#a6e22e">template&lt;/span>.&lt;span style="color:#a6e22e">New&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;test&amp;#34;&lt;/span>).&lt;span style="color:#a6e22e">Parse&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;Hello, {{.}}!&amp;#34;&lt;/span>))
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">b&lt;/span>.&lt;span style="color:#a6e22e">RunParallel&lt;/span>(&lt;span style="color:#66d9ef">func&lt;/span>(&lt;span style="color:#a6e22e">pb&lt;/span> &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">testing&lt;/span>.&lt;span style="color:#a6e22e">PB&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">var&lt;/span> &lt;span style="color:#a6e22e">buf&lt;/span> &lt;span style="color:#a6e22e">bytes&lt;/span>.&lt;span style="color:#a6e22e">Buffer&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span> &lt;span style="color:#a6e22e">pb&lt;/span>.&lt;span style="color:#a6e22e">Next&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">buf&lt;/span>.&lt;span style="color:#a6e22e">Reset&lt;/span>()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">templ&lt;/span>.&lt;span style="color:#a6e22e">Execute&lt;/span>(&lt;span style="color:#f92672">&amp;amp;&lt;/span>&lt;span style="color:#a6e22e">buf&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;World&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> })
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>$ go test -benchmem -bench .
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>...
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>BenchmarkParallel-16 &lt;span style="color:#ae81ff">3325430&lt;/span> &lt;span style="color:#ae81ff">375&lt;/span> ns/op &lt;span style="color:#ae81ff">272&lt;/span> B/op &lt;span style="color:#ae81ff">8&lt;/span> allocs/op
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>...
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="附-参考">附 参考&lt;/h2>
&lt;ul>
&lt;li>&lt;a href="https://geektutu.com/post/quick-gomock.html">Go Mock (gomock) 简明教程&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://golang.org/pkg/testing/">testing - golang.org&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://about.sourcegraph.com/go/advanced-testing-in-go">Advanced Testing in Go - sourcegraph.com&lt;/a>&lt;/li>
&lt;/ul>
&lt;hr>
&lt;hr>
&lt;p>&lt;a href="https://geektutu.com/post/geecache.html">上一篇 « 7 天用 Go 从零实现分布式缓存 GeeCache&lt;/a> &lt;a href="https://geektutu.com/post/geecache-day1.html">下一篇 » 动手写分布式缓存 - GeeCache 第一天 LRU 缓存淘汰策略&lt;/a>&lt;/p></description></item><item><title>Docs: Variables(变量)</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/2.%E7%BC%96%E7%A8%8B/%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/go/go-%E6%A0%87%E5%87%86%E5%BA%93/variables%E5%8F%98%E9%87%8F/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/2.%E7%BC%96%E7%A8%8B/%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/go/go-%E6%A0%87%E5%87%86%E5%BA%93/variables%E5%8F%98%E9%87%8F/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://go.dev/ref/spec#Variables">Go 官方文档-参考-规范-变量&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://go.dev/ref/spec#Declarations_and_scope">Go 官方文档-参考-规范-声明和范围&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;ul>
&lt;li>How to Name a Variable(如何命名一个变量)&lt;/li>
&lt;li>Scope(范围)&lt;/li>
&lt;li>Constants(常量)&lt;/li>
&lt;li>Defining Multiple Variables 定义多个变量空白标识符&lt;code>_&lt;/code>用于抛弃值，e.g.值 5 在：&lt;code>_, b = 5, 7&lt;/code>中被抛弃。&lt;code>_&lt;/code>空白标识符是一个只写变量，不能获得它的值。这样做是因为 Go 语言中必须使用所有被声明的变量，但有时候并不需要使用从一个函数得到的所有返回值(e.g.上例中的 5 与 7 是通过某个函数获得的值且该函数一定会获得 2 个值，但是其中一个却用不上)。&lt;/li>
&lt;/ul>
&lt;h1 id="声明变量">声明变量&lt;/h1>
&lt;p>格式：&lt;code>var VarID TYPE = EXP&lt;/code>&lt;/p>
&lt;ul>
&lt;li>VarID # 变量的标识符&lt;/li>
&lt;li>TYPE # 详见 &lt;a href="https://www.yuque.com/desistdaydream/learning/hmvgmw">TYPE 章节&lt;/a>&lt;/li>
&lt;li>EXP # 初始化时使用的表达式。i.e.即给该变量一个值。&lt;/li>
&lt;/ul>
&lt;p>其中 &lt;code>TYPE&lt;/code> 或者 &lt;code>= EXP&lt;/code> 这两个部分可以省略其中之一，如果省略 TYPE，那么将根据初始化 EXP 来自动推导变量的类型；如果初始化的 EXP&lt;/p>
&lt;h1 id="引用变量">引用变量&lt;/h1>
&lt;h1 id="variables-scope变量范围">Variables Scope(变量范围)&lt;/h1>
&lt;p>Variables Scope(变量范围) 就是变量的作用域，定义在哪里的变量，可以在哪里被引用，不可以在哪里被引用，都是变量范围所决定的。&lt;/p></description></item><item><title>Docs: 加密与解密</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/2.%E7%BC%96%E7%A8%8B/%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/go/go-%E6%A0%87%E5%87%86%E5%BA%93/%E5%8A%A0%E5%AF%86%E4%B8%8E%E8%A7%A3%E5%AF%86/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/2.%E7%BC%96%E7%A8%8B/%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/go/go-%E6%A0%87%E5%87%86%E5%BA%93/%E5%8A%A0%E5%AF%86%E4%B8%8E%E8%A7%A3%E5%AF%86/</guid><description/></item><item><title>Docs: 加密与解密</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/2.%E7%BC%96%E7%A8%8B/%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/go/go-%E6%A0%87%E5%87%86%E5%BA%93/%E5%8A%A0%E5%AF%86%E4%B8%8E%E8%A7%A3%E5%AF%86/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/2.%E7%BC%96%E7%A8%8B/%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/go/go-%E6%A0%87%E5%87%86%E5%BA%93/%E5%8A%A0%E5%AF%86%E4%B8%8E%E8%A7%A3%E5%AF%86/</guid><description/></item><item><title>Docs: 嵌入静态文件</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/2.%E7%BC%96%E7%A8%8B/%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/go/go-%E6%A0%87%E5%87%86%E5%BA%93/%E5%B5%8C%E5%85%A5%E9%9D%99%E6%80%81%E6%96%87%E4%BB%B6/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/2.%E7%BC%96%E7%A8%8B/%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/go/go-%E6%A0%87%E5%87%86%E5%BA%93/%E5%B5%8C%E5%85%A5%E9%9D%99%E6%80%81%E6%96%87%E4%BB%B6/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://pkg.go.dev/embed">Go 包，标准库-embed&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://colobu.com/2021/01/17/go-embed-tutorial/">https://colobu.com/2021/01/17/go-embed-tutorial/&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>embed 包可以让我们在编译时，将各种静态文件也编译进 Go 的二进制文件中。所以称之为 &lt;strong>embed(嵌入)。&lt;/strong>
要使用 embed 包，除了导入以外，还需要在在声明变量时，添加注释 &lt;code>//go:ebed /PATH/TO/FILE&lt;/code> 以使用 &lt;code>go:embed&lt;/code> 指令，embed 包将会读取所有 .go 文件中的 &lt;code>go:embed&lt;/code> 指令，并将其中的文件加载到变量中，该变量将会保存需要嵌入的静态文件。&lt;/p>
&lt;blockquote>
&lt;p>注意，注释中 // 和后面的 go:ebed 中间不能有空格&lt;/p>
&lt;/blockquote>
&lt;p>&lt;code>go:ebed&lt;/code> 指令有 3 种格式导入静态文件
一、将一个文件嵌入为字符格式&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">package&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">import&lt;/span> (
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">_&lt;/span> &lt;span style="color:#e6db74">&amp;#34;embed&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#34;fmt&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">//go:embed hello.txt
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">var&lt;/span> &lt;span style="color:#a6e22e">s&lt;/span> &lt;span style="color:#66d9ef">string&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">func&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">fmt&lt;/span>.&lt;span style="color:#a6e22e">Println&lt;/span>(&lt;span style="color:#a6e22e">s&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>二、将一个文件嵌入为 bytes 切片&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">package&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">import&lt;/span> (
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">_&lt;/span> &lt;span style="color:#e6db74">&amp;#34;embed&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#34;fmt&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">//go:embed hello.txt
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">var&lt;/span> &lt;span style="color:#a6e22e">b&lt;/span> []&lt;span style="color:#66d9ef">byte&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">func&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">fmt&lt;/span>.&lt;span style="color:#a6e22e">Println&lt;/span>(string(&lt;span style="color:#a6e22e">b&lt;/span>))
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>三、将一个或多个文件嵌入到文件系统中&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">package&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">import&lt;/span> (
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#34;embed&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#34;fmt&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">//go:embed hello.txt
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">var&lt;/span> &lt;span style="color:#a6e22e">f&lt;/span> &lt;span style="color:#a6e22e">embed&lt;/span>.&lt;span style="color:#a6e22e">FS&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">func&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">data&lt;/span>, &lt;span style="color:#a6e22e">_&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">f&lt;/span>.&lt;span style="color:#a6e22e">ReadFile&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;hello.txt&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> print(string(&lt;span style="color:#a6e22e">data&lt;/span>))
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>静态文件的嵌入功能，最常用于 Web 程序，我们可以将前端的所有静态资源文件嵌入到编译好的二进制文件中，这样，不再需要 Nginx，只使用一个 Go 的二进制文件，即可随处运行~~比如：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">package&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">import&lt;/span> (
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#34;embed&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#34;net/http&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">var&lt;/span> (
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">//go:embed hello.txt
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#a6e22e">f&lt;/span> &lt;span style="color:#a6e22e">embed&lt;/span>.&lt;span style="color:#a6e22e">FS&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">func&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">http&lt;/span>.&lt;span style="color:#a6e22e">Handle&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;/&amp;#34;&lt;/span>, &lt;span style="color:#a6e22e">http&lt;/span>.&lt;span style="color:#a6e22e">FileServer&lt;/span>(&lt;span style="color:#a6e22e">http&lt;/span>.&lt;span style="color:#a6e22e">FS&lt;/span>(&lt;span style="color:#a6e22e">f&lt;/span>)))
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">http&lt;/span>.&lt;span style="color:#a6e22e">ListenAndServe&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;:8080&amp;#34;&lt;/span>, &lt;span style="color:#66d9ef">nil&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div></description></item><item><title>Docs: 时间处理</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/2.%E7%BC%96%E7%A8%8B/%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/go/go-%E6%A0%87%E5%87%86%E5%BA%93/%E6%97%B6%E9%97%B4%E5%A4%84%E7%90%86/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/2.%E7%BC%96%E7%A8%8B/%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/go/go-%E6%A0%87%E5%87%86%E5%BA%93/%E6%97%B6%E9%97%B4%E5%A4%84%E7%90%86/</guid><description/></item><item><title>Docs: 时间处理</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/2.%E7%BC%96%E7%A8%8B/%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/go/go-%E6%A0%87%E5%87%86%E5%BA%93/%E6%97%B6%E9%97%B4%E5%A4%84%E7%90%86/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/2.%E7%BC%96%E7%A8%8B/%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/go/go-%E6%A0%87%E5%87%86%E5%BA%93/%E6%97%B6%E9%97%B4%E5%A4%84%E7%90%86/</guid><description/></item><item><title>Docs: 文本处理</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/2.%E7%BC%96%E7%A8%8B/%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/go/go-%E6%A0%87%E5%87%86%E5%BA%93/%E6%96%87%E6%9C%AC%E5%A4%84%E7%90%86/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/2.%E7%BC%96%E7%A8%8B/%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/go/go-%E6%A0%87%E5%87%86%E5%BA%93/%E6%96%87%E6%9C%AC%E5%A4%84%E7%90%86/</guid><description>
&lt;h1 id="类型转换">类型转换&lt;/h1>
&lt;h1 id="byte-转-string-以及-string-转-byte">[]byte 转 String 以及 String 转 []byte&lt;/h1>
&lt;p>通常我在 python 里面使用 json.dumps 来对字典进行序列化的时候，我通常认为出来的值是一个 string，可以将其作为 string 进行操作。但是这里很明显返回的不是字符串(string)类型，而是一个[]byte 类型。所以如果有需要，我们可以将[]byte 类型，转换回 string 进行操作。这里有几种方法可供选择：&lt;/p>
&lt;pre>&lt;code>直接使用：
string([]byte)
或使用：
String([]byte[:])
&lt;/code>&lt;/pre>
&lt;p>ps：现在这两个得到的结果会是一样的，我现在使用的版本是 1.8。1.8 以前好像会是不同的表现。&lt;/p>
&lt;p>同时我们也会遇到想要将 string 转换回[]byte 的时候。方法如下：&lt;/p>
&lt;pre>&lt;code>[]byte(string)
&lt;/code>&lt;/pre></description></item><item><title>Docs: 文本处理</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/2.%E7%BC%96%E7%A8%8B/%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/go/go-%E6%A0%87%E5%87%86%E5%BA%93/%E6%96%87%E6%9C%AC%E5%A4%84%E7%90%86/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/2.%E7%BC%96%E7%A8%8B/%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/go/go-%E6%A0%87%E5%87%86%E5%BA%93/%E6%96%87%E6%9C%AC%E5%A4%84%E7%90%86/</guid><description/></item></channel></rss>