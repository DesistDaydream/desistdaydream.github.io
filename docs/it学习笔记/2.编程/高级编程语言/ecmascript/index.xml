<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>断念梦 – ECMAScript</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/2.%E7%BC%96%E7%A8%8B/%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/ecmascript/</link><description>Recent content in ECMAScript on 断念梦</description><generator>Hugo -- gohugo.io</generator><atom:link href="https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/2.%E7%BC%96%E7%A8%8B/%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/ecmascript/index.xml" rel="self" type="application/rss+xml"/><item><title>Docs: ECMAScript 第三方库</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/2.%E7%BC%96%E7%A8%8B/%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/ecmascript/ecmascript-%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/2.%E7%BC%96%E7%A8%8B/%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/ecmascript/ecmascript-%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;h2 id="参考">参考：&lt;/h2>
&lt;/blockquote></description></item><item><title>Docs: ECMAScript</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/2.%E7%BC%96%E7%A8%8B/%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/ecmascript/ecmascript/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/2.%E7%BC%96%E7%A8%8B/%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/ecmascript/ecmascript/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/ECMAScript">Wiki,ECMAScript&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.javascript.com/">JavaScript 官网&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.typescriptlang.org/">TypeScript 官网&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>ECMAScript 是一种编程语言的&lt;strong>标准&lt;/strong>，起源于 JavaScripts。&lt;/p>
&lt;p>1996 年 8 月，微软模仿 JavaScript 开发了一种相近的语言，取名为 JScript（JavaScript 是 Netscape 的注册商标，微软不能用），首先内置于 IE 3.0。Netscape 公司面临丧失浏览器脚本语言的主导权的局面。&lt;/p>
&lt;p>1996 年 11 月，Netscape 公司决定将 JavaScript 提交给国际标准化组织 ECMA（European Computer Manufacturers Association），希望 JavaScript 能够成为国际标准，以此抵抗微软。ECMA 的 39 号技术委员会（Technical Committee 39）负责制定和审核这个标准，成员由业内的大公司派出的工程师组成，目前共 25 个人。该委员会定期开会，所有的邮件讨论和会议记录，都是公开的。&lt;/p>
&lt;p>1997 年 7 月，ECMA 组织发布 262 号标准文件（ECMA-262）的第一版，规定了浏览器脚本语言的标准，并将这种语言称为 ECMAScript。这个版本就是 ECMAScript 1.0 版。之所以不叫 JavaScript，一方面是由于商标的关系，Java 是 Sun 公司的商标，根据一份授权协议，只有 Netscape 公司可以合法地使用 JavaScript 这个名字，且 JavaScript 已经被 Netscape 公司注册为商标，另一方面也是想体现这门语言的制定者是 ECMA，不是 Netscape，这样有利于保证这门语言的开放性和中立性。因此，ECMAScript 和 JavaScript 的关系是，前者是后者的规范，后者是前者的一种实现。在日常场合，这两个词是可以互换的。&lt;/p>
&lt;p>ECMAScript 只用来标准化 JavaScript 这种语言的基本语法结构，与部署环境相关的标准都由其他标准规定，比如 DOM 的标准就是由 W3C 组织（World Wide Web Consortium）制定的。&lt;/p>
&lt;p>ECMA-262 标准后来也被另一个国际标准化组织 ISO（International Organization for Standardization）批准，标准号是 ISO-16262。&lt;/p>
&lt;h2 id="es6-标准">ES6 标准&lt;/h2>
&lt;p>ECMAScript 6.0 是 ECMA 的最新标准，于 2015 年 6 月发布，官方称为 ES2015 标准(ES6 的叫法更民间)。&lt;/p>
&lt;p>2011 年，ECMAScript 5.1 版发布后，就开始制定 6.0 版了。因此，ES6 这个词的原意，就是指 JavaScript 语言的下一个版本。&lt;/p>
&lt;p>但是，因为这个版本引入的语法功能太多，而且制定过程当中，还有很多组织和个人不断提交新功能。事情很快就变得清楚了，不可能在一个版本里面包括所有将要引入的功能。常规的做法是先发布 6.0 版，过一段时间再发 6.1 版，然后是 6.2 版、6.3 版等等。&lt;/p>
&lt;p>但是，标准的制定者不想这样做。他们想让标准的升级成为常规流程：任何人在任何时候，都可以向标准委员会提交新语法的提案，然后标准委员会每个月开一次会，评估这些提案是否可以接受，需要哪些改进。如果经过多次会议以后，一个提案足够成熟了，就可以正式进入标准了。这就是说，标准的版本升级成为了一个不断滚动的流程，每个月都会有变动。&lt;/p>
&lt;p>标准委员会最终决定，标准在每年的 6 月份正式发布一次，作为当年的正式版本。接下来的时间，就在这个版本的基础上做改动，直到下一年的 6 月份，草案就自然变成了新一年的版本。这样一来，就不需要以前的版本号了，只要用年份标记就可以了。&lt;/p>
&lt;p>ES6 的第一个版本，就这样在 2015 年 6 月发布了，正式名称就是《ECMAScript 2015 标准》（简称 ES2015）。2016 年 6 月，小幅修订的《ECMAScript 2016 标准》（简称 ES2016）如期发布，这个版本可以看作是 ES6.1 版，因为两者的差异非常小（只新增了数组实例的 includes 方法和指数运算符），基本上是同一个标准。根据计划，2017 年 6 月发布 ES2017 标准。&lt;/p>
&lt;p>因此，ES6 既是一个历史名词，也是一个泛指，含义是 5.1 版以后的 JavaScript 的下一代标准，涵盖了 ES2015、ES2016、ES2017 等等，而 ES2015 则是正式名称，特指该年发布的正式版本的语言标准。本书中提到 ES6 的地方，一般是指 ES2015 标准，但有时也是泛指“下一代 JavaScript 语言”。&lt;/p>
&lt;h2 id="ecmascript-的三大核心组成">ECMAScript 的三大核心组成&lt;/h2>
&lt;p>&lt;strong>ECMAScript&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>JS 的书写语法和规则&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>Browser Ojbect Model(浏览器对象模型，简称 BOM)&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>JS 控制浏览器的属性和方法。
&lt;ul>
&lt;li>比如浏览器右侧的滚动条，可以通过 JS 代码来控制。比如某些网页有个叫回到顶部的按钮，按一下，就等于是 JS 操作滚动条移动到最上面了。&lt;/li>
&lt;li>比如很多手机，我们从屏幕最左侧往右滑，一般返回上一页。这是因为这个滑动行为被 JS 代码捕获后，操作浏览器点击了一下后腿按钮。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>Document Object Model(文档对象模型，简称 DOM)&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>JS 控制文档流的属性和方法。
&lt;ul>
&lt;li>比如很多网页最上面中间都有一个图片，按一下图片左右两边的箭头，就会换到另一个图片&lt;/li>
&lt;li>也就是说，JS 控制什么时候，让页面元素发生一些变化&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h1 id="学习资料">学习资料&lt;/h1>
&lt;p>&lt;a href="https://developer.mozilla.org/en-US/docs/Web">MDN 官方文档，Web 开发技术&lt;/a>((通常指的是网站首页的 References 标签中的文档))&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript">JavaScript&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Lexical_grammar#keywords">JavaScript-参考-词汇文法-关键字&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Statements">JavaScript-参考-语句和声明&lt;/a>(这里就是 JS 的关键字的用法)&lt;/li>
&lt;/ul>
&lt;p>&lt;a href="https://www.liaoxuefeng.com/wiki/1022910821149312">廖雪峰，JavaScript&lt;/a>
&lt;a href="https://wangdoc.com/javascript/index.html">网道，JavaScript&lt;/a>&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://wangdoc.com/javascript/basic/grammar.html">网道，JavaScript-JavaScript 的基本语法&lt;/a>&lt;/li>
&lt;/ul>
&lt;p>电子书&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://github.com/javascript-tutorial/zh.javascript.info/tree/master">GitHub 项目，javascript/zh.javascript.info&lt;/a>(现代 JavaScript 教程)&lt;/li>
&lt;/ul>
&lt;h1 id="hello-world">Hello World&lt;/h1>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-html" data-lang="html">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&amp;lt;!DOCTYPE html&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&amp;lt;&lt;span style="color:#f92672">html&lt;/span>&amp;gt;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &amp;lt;&lt;span style="color:#f92672">head&lt;/span>&amp;gt;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &amp;lt;&lt;span style="color:#f92672">meta&lt;/span> &lt;span style="color:#a6e22e">charset&lt;/span>&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;UTF-8&amp;#34;&lt;/span> /&amp;gt;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &amp;lt;&lt;span style="color:#f92672">title&lt;/span>&amp;gt;Hello World&amp;lt;/&lt;span style="color:#f92672">title&lt;/span>&amp;gt;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &amp;lt;/&lt;span style="color:#f92672">head&lt;/span>&amp;gt;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &amp;lt;&lt;span style="color:#f92672">body&lt;/span>&amp;gt;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">&amp;lt;!-- 有多种方式可以在书写 JS 代码 --&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">&amp;lt;!-- 行内式， JS 代码写在标签上--&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">&amp;lt;!-- a 标签，书写在 href 属性上 --&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &amp;lt;&lt;span style="color:#f92672">a&lt;/span> &lt;span style="color:#a6e22e">href&lt;/span>&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;javascript: alert(&amp;#39;Hello World，行内式，a 标签&amp;#39;);&amp;#34;&lt;/span>&amp;gt;点我&amp;lt;/&lt;span style="color:#f92672">a&lt;/span>&amp;gt;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">&amp;lt;!-- 非 a 标签，书写在行为属性上 --&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &amp;lt;&lt;span style="color:#f92672">div&lt;/span> &lt;span style="color:#a6e22e">onclick&lt;/span>&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;alert(&amp;#39;Hello World，行内式，非 a 标签&amp;#39;)&amp;#34;&lt;/span>&amp;gt;点我&amp;lt;/&lt;span style="color:#f92672">div&lt;/span>&amp;gt;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">&amp;lt;!-- 内嵌式，JS 代码写在 script 标签中 --&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &amp;lt;&lt;span style="color:#f92672">script&lt;/span>&amp;gt;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 在前端页面上显示的内容
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#a6e22e">alert&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;Hello World 内嵌式&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 在后端控制台显示的内容
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#a6e22e">console&lt;/span>.&lt;span style="color:#a6e22e">log&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;Hello World backend&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &amp;lt;/&lt;span style="color:#f92672">script&lt;/span>&amp;gt;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">&amp;lt;!-- 外链试，JS 代码写在单独的 .js 文件中，并通过 script 标签的 src 属性引入 .js 文件 --&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &amp;lt;&lt;span style="color:#f92672">script&lt;/span> &lt;span style="color:#a6e22e">src&lt;/span>&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;./hello_world.js&amp;#34;&lt;/span>&amp;gt;&amp;lt;/&lt;span style="color:#f92672">script&lt;/span>&amp;gt;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">&amp;lt;!-- 总结：
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> 行内式 # 强烈不推荐。不利于代码维护，也会导致 HTML 文件过于臃肿。
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> 内嵌式 # 一般测试或者学习时，使用这种方式，不用建立很多 .js 文件。
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> 外链式 # 强烈推荐
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> --&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &amp;lt;/&lt;span style="color:#f92672">body&lt;/span>&amp;gt;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&amp;lt;/&lt;span style="color:#f92672">html&lt;/span>&amp;gt;
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h1 id="javascript-语言关键字">JavaScript 语言关键字&lt;/h1>
&lt;p>break
case
catch
class
const
continue
debugger
default
delete
do
else
enum
export
extends
false
finally
for
function
if
implements
import
in
instanceof
interface
let
new
null
package
private
protected
public
return
super
switch
static
this
throw
try
true
typeof
var
void
while
with
yield&lt;/p>
&lt;h1 id="javascript-基本语法规范">JavaScript 基本语法规范&lt;/h1>
&lt;h2 id="语句">语句&lt;/h2>
&lt;p>JavaScript 程序的执行单位为行（line），也就是一行一行地执行。一般情况下，每一行就是一个语句。&lt;/p>
&lt;p>语句（statement）是为了完成某种任务而进行的操作，比如下面就是一行赋值语句。&lt;/p>
&lt;pre>&lt;code>var a = 1 + 3;
&lt;/code>&lt;/pre>
&lt;p>这条语句先用&lt;code>var&lt;/code>命令，声明了变量&lt;code>a&lt;/code>，然后将&lt;code>1 + 3&lt;/code>的运算结果赋值给变量&lt;code>a&lt;/code>。&lt;/p>
&lt;p>&lt;code>1 + 3&lt;/code>叫做表达式（expression），指一个为了得到返回值的计算式。语句和表达式的区别在于，前者主要为了进行某种操作，一般情况下不需要返回值；后者则是为了得到返回值，一定会返回一个值。凡是 JavaScript 语言中预期为值的地方，都可以使用表达式。比如，赋值语句的等号右边，预期是一个值，因此可以放置各种表达式。&lt;/p>
&lt;p>语句以分号结尾，一个分号就表示一个语句结束。多个语句可以写在一行内。&lt;/p>
&lt;pre>&lt;code>var a = 1 + 3 ; var b = 'abc';
&lt;/code>&lt;/pre>
&lt;p>分号前面可以没有任何内容，JavaScript 引擎将其视为空语句。&lt;/p>
&lt;pre>&lt;code>;;;
&lt;/code>&lt;/pre>
&lt;p>上面的代码就表示 3 个空语句。&lt;/p>
&lt;p>表达式不需要分号结尾。一旦在表达式后面添加分号，则 JavaScript 引擎就将表达式视为语句，这样会产生一些没有任何意义的语句。&lt;/p>
&lt;pre>&lt;code>1 + 3;
'abc';
&lt;/code>&lt;/pre>
&lt;p>上面两行语句只是单纯地产生一个值，并没有任何实际的意义。&lt;/p>
&lt;h2 id="变量">变量&lt;/h2>
&lt;h3 id="概念">概念&lt;/h3>
&lt;p>变量是对“值”的具名引用。变量就是为“值”起名，然后引用这个名字，就等同于引用这个值。变量的名字就是变量名。&lt;/p>
&lt;pre>&lt;code>var a = 1;
&lt;/code>&lt;/pre>
&lt;p>上面的代码先声明变量&lt;code>a&lt;/code>，然后在变量&lt;code>a&lt;/code>与数值 1 之间建立引用关系，称为将数值 1“赋值”给变量&lt;code>a&lt;/code>。以后，引用变量名&lt;code>a&lt;/code>就会得到数值 1。最前面的&lt;code>var&lt;/code>，是变量声明命令。它表示通知解释引擎，要创建一个变量&lt;code>a&lt;/code>。&lt;/p>
&lt;p>注意，JavaScript 的变量名区分大小写，&lt;code>A&lt;/code>和&lt;code>a&lt;/code>是两个不同的变量。&lt;/p>
&lt;p>变量的声明和赋值，是分开的两个步骤，上面的代码将它们合在了一起，实际的步骤是下面这样。&lt;/p>
&lt;pre>&lt;code>var a;
a = 1;
&lt;/code>&lt;/pre>
&lt;p>如果只是声明变量而没有赋值，则该变量的值是&lt;code>undefined&lt;/code>。&lt;code>undefined&lt;/code>是一个特殊的值，表示“无定义”。&lt;/p>
&lt;pre>&lt;code>var a;
a
&lt;/code>&lt;/pre>
&lt;p>如果变量赋值的时候，忘了写&lt;code>var&lt;/code>命令，这条语句也是有效的。&lt;/p>
&lt;pre>&lt;code>var a = 1;
a = 1;
&lt;/code>&lt;/pre>
&lt;p>但是，不写&lt;code>var&lt;/code>的做法，不利于表达意图，而且容易不知不觉地创建全局变量，所以建议总是使用&lt;code>var&lt;/code>命令声明变量。&lt;/p>
&lt;p>如果一个变量没有声明就直接使用，JavaScript 会报错，告诉你变量未定义。&lt;/p>
&lt;pre>&lt;code>x
&lt;/code>&lt;/pre>
&lt;p>上面代码直接使用变量&lt;code>x&lt;/code>，系统就报错，告诉你变量&lt;code>x&lt;/code>没有声明。&lt;/p>
&lt;p>可以在同一条&lt;code>var&lt;/code>命令中声明多个变量。&lt;/p>
&lt;pre>&lt;code>var a, b;
&lt;/code>&lt;/pre>
&lt;p>JavaScript 是一种动态类型语言，也就是说，变量的类型没有限制，变量可以随时更改类型。&lt;/p>
&lt;pre>&lt;code>var a = 1;
a = 'hello';
&lt;/code>&lt;/pre>
&lt;p>上面代码中，变量&lt;code>a&lt;/code>起先被赋值为一个数值，后来又被重新赋值为一个字符串。第二次赋值的时候，因为变量&lt;code>a&lt;/code>已经存在，所以不需要使用&lt;code>var&lt;/code>命令。&lt;/p>
&lt;p>如果使用&lt;code>var&lt;/code>重新声明一个已经存在的变量，是无效的。&lt;/p>
&lt;pre>&lt;code>var x = 1;
var x;
x
&lt;/code>&lt;/pre>
&lt;p>上面代码中，变量&lt;code>x&lt;/code>声明了两次，第二次声明是无效的。&lt;/p>
&lt;p>但是，如果第二次声明的时候还进行了赋值，则会覆盖掉前面的值。&lt;/p>
&lt;pre>&lt;code>var x = 1;
var x = 2;
var x = 1;
var x;
x = 2;
&lt;/code>&lt;/pre>
&lt;h3 id="variables-hoisting变量提升">Variables Hoisting(变量提升)&lt;/h3>
&lt;p>JavaScript 引擎的工作方式是，先解析代码，获取所有被声明的变量，然后再一行一行地运行。这造成的结果，就是所有的变量的声明语句，都会被提升到代码的头部，这就叫做变量提升（hoisting）。&lt;/p>
&lt;pre>&lt;code>console.log(a);
var a = 1;
&lt;/code>&lt;/pre>
&lt;p>上面代码首先使用&lt;code>console.log&lt;/code>方法，在控制台（console）显示变量&lt;code>a&lt;/code>的值。这时变量&lt;code>a&lt;/code>还没有声明和赋值，所以这是一种错误的做法，但是实际上不会报错。因为存在变量提升，真正运行的是下面的代码。&lt;/p>
&lt;pre>&lt;code>var a;
console.log(a);
a = 1;
&lt;/code>&lt;/pre>
&lt;p>最后的结果是显示&lt;code>undefined&lt;/code>，表示变量&lt;code>a&lt;/code>已声明，但还未赋值。&lt;/p>
&lt;h2 id="标识符">标识符&lt;/h2>
&lt;p>标识符（identifier）指的是用来识别各种值的合法名称。最常见的标识符就是变量名，以及后面要提到的函数名。JavaScript 语言的标识符对大小写敏感，所以&lt;code>a&lt;/code>和&lt;code>A&lt;/code>是两个不同的标识符。&lt;/p>
&lt;p>标识符有一套命名规则，不符合规则的就是非法标识符。JavaScript 引擎遇到非法标识符，就会报错。&lt;/p>
&lt;p>简单说，标识符命名规则如下。&lt;/p>
&lt;ul>
&lt;li>第一个字符，可以是任意 Unicode 字母（包括英文字母和其他语言的字母），以及美元符号（&lt;code>$&lt;/code>）和下划线（&lt;code>_&lt;/code>）。&lt;/li>
&lt;li>第二个字符及后面的字符，除了 Unicode 字母、美元符号和下划线，还可以用数字&lt;code>0-9&lt;/code>。&lt;/li>
&lt;/ul>
&lt;p>下面这些都是合法的标识符。&lt;/p>
&lt;pre>&lt;code>arg0
_tmp
$elem
π
&lt;/code>&lt;/pre>
&lt;p>下面这些则是不合法的标识符。&lt;/p>
&lt;pre>&lt;code>1a
23
***
a+b
-d
&lt;/code>&lt;/pre>
&lt;p>中文是合法的标识符，可以用作变量名。&lt;/p>
&lt;pre>&lt;code>var 临时变量 = 1;
&lt;/code>&lt;/pre>
&lt;blockquote>
&lt;p>JavaScript 有一些保留字，不能用作标识符：arguments、break、case、catch、class、const、continue、debugger、default、delete、do、else、enum、eval、export、extends、false、finally、for、function、if、implements、import、in、instanceof、interface、let、new、null、package、private、protected、public、return、static、super、switch、this、throw、true、try、typeof、var、void、while、with、yield。&lt;/p>
&lt;/blockquote>
&lt;h2 id="注释">注释&lt;/h2>
&lt;p>源码中被 JavaScript 引擎忽略的部分就叫做注释，它的作用是对代码进行解释。JavaScript 提供两种注释的写法：一种是单行注释，用&lt;code>//&lt;/code>起头；另一种是多行注释，放在&lt;code>/*&lt;/code>和&lt;code>*/&lt;/code>之间。&lt;/p>
&lt;p>此外，由于历史上 JavaScript 可以兼容 HTML 代码的注释，所以&lt;code>&amp;lt;!--&lt;/code>和&lt;code>--&amp;gt;&lt;/code>也被视为合法的单行注释。&lt;/p>
&lt;pre>&lt;code>x = 1; &amp;lt;!-- x = 2;
--&amp;gt; x = 3;
&lt;/code>&lt;/pre>
&lt;p>上面代码中，只有&lt;code>x = 1&lt;/code>会执行，其他的部分都被注释掉了。&lt;/p>
&lt;p>需要注意的是，&lt;code>--&amp;gt;&lt;/code>只有在行首，才会被当成单行注释，否则会当作正常的运算。&lt;/p>
&lt;pre>&lt;code>function countdown(n) {
while (n --&amp;gt; 0) console.log(n);
}
countdown(3)
&lt;/code>&lt;/pre>
&lt;p>上面代码中，&lt;code>n --&amp;gt; 0&lt;/code>实际上会当作&lt;code>n-- &amp;gt; 0&lt;/code>，因此输出 2、1、0。&lt;/p>
&lt;h2 id="区块">区块&lt;/h2>
&lt;p>JavaScript 使用大括号，将多个相关的语句组合在一起，称为“区块”（block）。&lt;/p>
&lt;p>对于&lt;code>var&lt;/code>命令来说，JavaScript 的区块不构成单独的作用域（scope）。&lt;/p>
&lt;pre>&lt;code>{
var a = 1;
}
a
&lt;/code>&lt;/pre>
&lt;p>上面代码在区块内部，使用&lt;code>var&lt;/code>命令声明并赋值了变量&lt;code>a&lt;/code>，然后在区块外部，变量&lt;code>a&lt;/code>依然有效，区块对于&lt;code>var&lt;/code>命令不构成单独的作用域，与不使用区块的情况没有任何区别。在 JavaScript 语言中，单独使用区块并不常见，区块往往用来构成其他更复杂的语法结构，比如&lt;code>for&lt;/code>、&lt;code>if&lt;/code>、&lt;code>while&lt;/code>、&lt;code>function&lt;/code>等。&lt;/p>
&lt;h2 id="条件语句">条件语句&lt;/h2>
&lt;p>JavaScript 提供&lt;code>if&lt;/code>结构和&lt;code>switch&lt;/code>结构，完成条件判断，即只有满足预设的条件，才会执行相应的语句。&lt;/p>
&lt;h3 id="if-结构">if 结构&lt;/h3>
&lt;p>&lt;code>if&lt;/code>结构先判断一个表达式的布尔值，然后根据布尔值的真伪，执行不同的语句。所谓布尔值，指的是 JavaScript 的两个特殊值，&lt;code>true&lt;/code>表示“真”，&lt;code>false&lt;/code>表示“伪”。&lt;/p>
&lt;pre>&lt;code>if (布尔值)
语句;
if (布尔值) 语句;
&lt;/code>&lt;/pre>
&lt;p>上面是&lt;code>if&lt;/code>结构的基本形式。需要注意的是，“布尔值”往往由一个条件表达式产生的，必须放在圆括号中，表示对表达式求值。如果表达式的求值结果为&lt;code>true&lt;/code>，就执行紧跟在后面的语句；如果结果为&lt;code>false&lt;/code>，则跳过紧跟在后面的语句。&lt;/p>
&lt;pre>&lt;code>if (m === 3)
m = m + 1;
&lt;/code>&lt;/pre>
&lt;p>上面代码表示，只有在&lt;code>m&lt;/code>等于 3 时，才会将其值加上 1。&lt;/p>
&lt;p>这种写法要求条件表达式后面只能有一个语句。如果想执行多个语句，必须在&lt;code>if&lt;/code>的条件判断之后，加上大括号，表示代码块（多个语句合并成一个语句）。&lt;/p>
&lt;pre>&lt;code>if (m === 3) {
m += 1;
}
&lt;/code>&lt;/pre>
&lt;p>建议总是在&lt;code>if&lt;/code>语句中使用大括号，因为这样方便插入语句。&lt;/p>
&lt;p>注意，&lt;code>if&lt;/code>后面的表达式之中，不要混淆赋值表达式（&lt;code>=&lt;/code>）、严格相等运算符（&lt;code>===&lt;/code>）和相等运算符（&lt;code>==&lt;/code>）。尤其是赋值表达式不具有比较作用。&lt;/p>
&lt;pre>&lt;code>var x = 1;
var y = 2;
if (x = y) {
console.log(x);
}
&lt;/code>&lt;/pre>
&lt;p>上面代码的原意是，当&lt;code>x&lt;/code>等于&lt;code>y&lt;/code>的时候，才执行相关语句。但是，不小心将严格相等运算符写成赋值表达式，结果变成了将&lt;code>y&lt;/code>赋值给变量&lt;code>x&lt;/code>，再判断变量&lt;code>x&lt;/code>的值（等于 2）的布尔值（结果为&lt;code>true&lt;/code>）。&lt;/p>
&lt;p>这种错误可以正常生成一个布尔值，因而不会报错。为了避免这种情况，有些开发者习惯将常量写在运算符的左边，这样的话，一旦不小心将相等运算符写成赋值运算符，就会报错，因为常量不能被赋值。&lt;/p>
&lt;pre>&lt;code>if (x = 2) {
if (2 = x) {
&lt;/code>&lt;/pre>
&lt;p>至于为什么优先采用“严格相等运算符”（&lt;code>===&lt;/code>），而不是“相等运算符”（&lt;code>==&lt;/code>），请参考《运算符》章节。&lt;/p>
&lt;h3 id="ifelse-结构">if&amp;hellip;else 结构&lt;/h3>
&lt;p>&lt;code>if&lt;/code>代码块后面，还可以跟一个&lt;code>else&lt;/code>代码块，表示不满足条件时，所要执行的代码。&lt;/p>
&lt;pre>&lt;code>if (m === 3) {
} else {
}
&lt;/code>&lt;/pre>
&lt;p>上面代码判断变量&lt;code>m&lt;/code>是否等于 3，如果等于就执行&lt;code>if&lt;/code>代码块，否则执行&lt;code>else&lt;/code>代码块。&lt;/p>
&lt;p>对同一个变量进行多次判断时，多个&lt;code>if...else&lt;/code>语句可以连写在一起。&lt;/p>
&lt;pre>&lt;code>if (m === 0) {
} else if (m === 1) {
} else if (m === 2) {
} else {
}
&lt;/code>&lt;/pre>
&lt;p>&lt;code>else&lt;/code>代码块总是与离自己最近的那个&lt;code>if&lt;/code>语句配对。&lt;/p>
&lt;pre>&lt;code>var m = 1;
var n = 2;
if (m !== 1)
if (n === 2) console.log('hello');
else console.log('world');
&lt;/code>&lt;/pre>
&lt;p>上面代码不会有任何输出，&lt;code>else&lt;/code>代码块不会得到执行，因为它跟着的是最近的那个&lt;code>if&lt;/code>语句，相当于下面这样。&lt;/p>
&lt;pre>&lt;code>if (m !== 1) {
if (n === 2) {
console.log('hello');
} else {
console.log('world');
}
}
&lt;/code>&lt;/pre>
&lt;p>如果想让&lt;code>else&lt;/code>代码块跟随最上面的那个&lt;code>if&lt;/code>语句，就要改变大括号的位置。&lt;/p>
&lt;pre>&lt;code>if (m !== 1) {
if (n === 2) {
console.log('hello');
}
} else {
console.log('world');
}
&lt;/code>&lt;/pre>
&lt;h3 id="switch-结构">switch 结构&lt;/h3>
&lt;p>多个&lt;code>if...else&lt;/code>连在一起使用的时候，可以转为使用更方便的&lt;code>switch&lt;/code>结构。&lt;/p>
&lt;pre>&lt;code>switch (fruit) {
case &amp;quot;banana&amp;quot;:
break;
case &amp;quot;apple&amp;quot;:
break;
default:
}
&lt;/code>&lt;/pre>
&lt;p>上面代码根据变量&lt;code>fruit&lt;/code>的值，选择执行相应的&lt;code>case&lt;/code>。如果所有&lt;code>case&lt;/code>都不符合，则执行最后的&lt;code>default&lt;/code>部分。需要注意的是，每个&lt;code>case&lt;/code>代码块内部的&lt;code>break&lt;/code>语句不能少，否则会接下去执行下一个&lt;code>case&lt;/code>代码块，而不是跳出&lt;code>switch&lt;/code>结构。&lt;/p>
&lt;pre>&lt;code>var x = 1;
switch (x) {
case 1:
console.log('x 等于1');
case 2:
console.log('x 等于2');
default:
console.log('x 等于其他值');
}
&lt;/code>&lt;/pre>
&lt;p>上面代码中，&lt;code>case&lt;/code>代码块之中没有&lt;code>break&lt;/code>语句，导致不会跳出&lt;code>switch&lt;/code>结构，而会一直执行下去。正确的写法是像下面这样。&lt;/p>
&lt;pre>&lt;code>switch (x) {
case 1:
console.log('x 等于1');
break;
case 2:
console.log('x 等于2');
break;
default:
console.log('x 等于其他值');
}
&lt;/code>&lt;/pre>
&lt;p>&lt;code>switch&lt;/code>语句部分和&lt;code>case&lt;/code>语句部分，都可以使用表达式。&lt;/p>
&lt;pre>&lt;code>switch (1 + 3) {
case 2 + 2:
f();
break;
default:
neverHappens();
}
&lt;/code>&lt;/pre>
&lt;p>上面代码的&lt;code>default&lt;/code>部分，是永远不会执行到的。&lt;/p>
&lt;p>需要注意的是，&lt;code>switch&lt;/code>语句后面的表达式，与&lt;code>case&lt;/code>语句后面的表示式比较运行结果时，采用的是严格相等运算符（&lt;code>===&lt;/code>），而不是相等运算符（&lt;code>==&lt;/code>），这意味着比较时不会发生类型转换。&lt;/p>
&lt;pre>&lt;code>var x = 1;
switch (x) {
case true:
console.log('x 发生类型转换');
break;
default:
console.log('x 没有发生类型转换');
}
&lt;/code>&lt;/pre>
&lt;p>上面代码中，由于变量&lt;code>x&lt;/code>没有发生类型转换，所以不会执行&lt;code>case true&lt;/code>的情况。这表明，&lt;code>switch&lt;/code>语句内部采用的是“严格相等运算符”，详细解释请参考《运算符》一节。&lt;/p>
&lt;h3 id="三元运算符-">三元运算符 ?:&lt;/h3>
&lt;p>JavaScript 还有一个三元运算符（即该运算符需要三个运算子）&lt;code>?:&lt;/code>，也可以用于逻辑判断。&lt;/p>
&lt;pre>&lt;code>(条件) ? 表达式1 : 表达式2
&lt;/code>&lt;/pre>
&lt;p>上面代码中，如果“条件”为&lt;code>true&lt;/code>，则返回“表达式 1”的值，否则返回“表达式 2”的值。&lt;/p>
&lt;pre>&lt;code>var even = (n % 2 === 0) ? true : false;
&lt;/code>&lt;/pre>
&lt;p>上面代码中，如果&lt;code>n&lt;/code>可以被 2 整除，则&lt;code>even&lt;/code>等于&lt;code>true&lt;/code>，否则等于&lt;code>false&lt;/code>。它等同于下面的形式。&lt;/p>
&lt;pre>&lt;code>var even;
if (n % 2 === 0) {
even = true;
} else {
even = false;
}
&lt;/code>&lt;/pre>
&lt;p>这个三元运算符可以被视为&lt;code>if...else...&lt;/code>的简写形式，因此可以用于多种场合。&lt;/p>
&lt;pre>&lt;code>var myVar;
console.log(
myVar ?
'myVar has a value' :
'myVar does not have a value'
)
&lt;/code>&lt;/pre>
&lt;p>上面代码利用三元运算符，输出相应的提示。&lt;/p>
&lt;pre>&lt;code>var msg = '数字' + n + '是' + (n % 2 === 0 ? '偶数' : '奇数');
&lt;/code>&lt;/pre>
&lt;p>上面代码利用三元运算符，在字符串之中插入不同的值。&lt;/p>
&lt;h2 id="循环语句">循环语句&lt;/h2>
&lt;p>循环语句用于重复执行某个操作，它有多种形式。&lt;/p>
&lt;h3 id="while-循环">while 循环&lt;/h3>
&lt;p>&lt;code>While&lt;/code>语句包括一个循环条件和一段代码块，只要条件为真，就不断循环执行代码块。&lt;/p>
&lt;pre>&lt;code>while (条件)
语句;
while (条件) 语句;
&lt;/code>&lt;/pre>
&lt;p>&lt;code>while&lt;/code>语句的循环条件是一个表达式，必须放在圆括号中。代码块部分，如果只有一条语句，可以省略大括号，否则就必须加上大括号。&lt;/p>
&lt;pre>&lt;code>while (条件) {
语句;
}
&lt;/code>&lt;/pre>
&lt;p>下面是&lt;code>while&lt;/code>语句的一个例子。&lt;/p>
&lt;pre>&lt;code>var i = 0;
while (i &amp;lt; 100) {
console.log('i 当前为：' + i);
i = i + 1;
}
&lt;/code>&lt;/pre>
&lt;p>上面的代码将循环 100 次，直到&lt;code>i&lt;/code>等于 100 为止。&lt;/p>
&lt;p>下面的例子是一个无限循环，因为循环条件总是为真。&lt;/p>
&lt;pre>&lt;code>while (true) {
console.log('Hello, world');
}
&lt;/code>&lt;/pre>
&lt;h3 id="for-循环">for 循环&lt;/h3>
&lt;p>&lt;code>for&lt;/code>语句是循环命令的另一种形式，可以指定循环的起点、终点和终止条件。它的格式如下。&lt;/p>
&lt;pre>&lt;code>for (初始化表达式; 条件; 递增表达式)
语句
for (初始化表达式; 条件; 递增表达式) {
语句
}
&lt;/code>&lt;/pre>
&lt;p>&lt;code>for&lt;/code>语句后面的括号里面，有三个表达式。&lt;/p>
&lt;ul>
&lt;li>初始化表达式（initialize）：确定循环变量的初始值，只在循环开始时执行一次。&lt;/li>
&lt;li>条件表达式（test）：每轮循环开始时，都要执行这个条件表达式，只有值为真，才继续进行循环。&lt;/li>
&lt;li>递增表达式（increment）：每轮循环的最后一个操作，通常用来递增循环变量。&lt;/li>
&lt;/ul>
&lt;p>下面是一个例子。&lt;/p>
&lt;pre>&lt;code>var x = 3;
for (var i = 0; i &amp;lt; x; i++) {
console.log(i);
}
&lt;/code>&lt;/pre>
&lt;p>上面代码中，初始化表达式是&lt;code>var i = 0&lt;/code>，即初始化一个变量&lt;code>i&lt;/code>；测试表达式是&lt;code>i &amp;lt; x&lt;/code>，即只要&lt;code>i&lt;/code>小于&lt;code>x&lt;/code>，就会执行循环；递增表达式是&lt;code>i++&lt;/code>，即每次循环结束后，&lt;code>i&lt;/code>增大 1。&lt;/p>
&lt;p>所有&lt;code>for&lt;/code>循环，都可以改写成&lt;code>while&lt;/code>循环。上面的例子改为&lt;code>while&lt;/code>循环，代码如下。&lt;/p>
&lt;pre>&lt;code>var x = 3;
var i = 0;
while (i &amp;lt; x) {
console.log(i);
i++;
}
&lt;/code>&lt;/pre>
&lt;p>&lt;code>for&lt;/code>语句的三个部分（initialize、test、increment），可以省略任何一个，也可以全部省略。&lt;/p>
&lt;pre>&lt;code>for ( ; ; ){
console.log('Hello World');
}
&lt;/code>&lt;/pre>
&lt;p>上面代码省略了&lt;code>for&lt;/code>语句表达式的三个部分，结果就导致了一个无限循环。&lt;/p>
&lt;h3 id="dowhile-循环">do&amp;hellip;while 循环&lt;/h3>
&lt;p>&lt;code>do...while&lt;/code>循环与&lt;code>while&lt;/code>循环类似，唯一的区别就是先运行一次循环体，然后判断循环条件。&lt;/p>
&lt;pre>&lt;code>do
语句
while (条件);
do {
语句
} while (条件);
&lt;/code>&lt;/pre>
&lt;p>不管条件是否为真，&lt;code>do...while&lt;/code>循环至少运行一次，这是这种结构最大的特点。另外，&lt;code>while&lt;/code>语句后面的分号注意不要省略。&lt;/p>
&lt;p>下面是一个例子。&lt;/p>
&lt;pre>&lt;code>var x = 3;
var i = 0;
do {
console.log(i);
i++;
} while(i &amp;lt; x);
&lt;/code>&lt;/pre>
&lt;h3 id="break-语句和-continue-语句">break 语句和 continue 语句&lt;/h3>
&lt;p>&lt;code>break&lt;/code>语句和&lt;code>continue&lt;/code>语句都具有跳转作用，可以让代码不按既有的顺序执行。&lt;/p>
&lt;p>&lt;code>break&lt;/code>语句用于跳出代码块或循环。&lt;/p>
&lt;pre>&lt;code>var i = 0;
while(i &amp;lt; 100) {
console.log('i 当前为：' + i);
i++;
if (i === 10) break;
}
&lt;/code>&lt;/pre>
&lt;p>上面代码只会执行 10 次循环，一旦&lt;code>i&lt;/code>等于 10，就会跳出循环。&lt;/p>
&lt;p>&lt;code>for&lt;/code>循环也可以使用&lt;code>break&lt;/code>语句跳出循环。&lt;/p>
&lt;pre>&lt;code>for (var i = 0; i &amp;lt; 5; i++) {
console.log(i);
if (i === 3)
break;
}
&lt;/code>&lt;/pre>
&lt;p>上面代码执行到&lt;code>i&lt;/code>等于 3，就会跳出循环。&lt;/p>
&lt;p>&lt;code>continue&lt;/code>语句用于立即终止本轮循环，返回循环结构的头部，开始下一轮循环。&lt;/p>
&lt;pre>&lt;code>var i = 0;
while (i &amp;lt; 100){
i++;
if (i % 2 === 0) continue;
console.log('i 当前为：' + i);
}
&lt;/code>&lt;/pre>
&lt;p>上面代码只有在&lt;code>i&lt;/code>为奇数时，才会输出&lt;code>i&lt;/code>的值。如果&lt;code>i&lt;/code>为偶数，则直接进入下一轮循环。&lt;/p>
&lt;p>如果存在多重循环，不带参数的&lt;code>break&lt;/code>语句和&lt;code>continue&lt;/code>语句都只针对最内层循环。&lt;/p>
&lt;h3 id="标签label">标签（label）&lt;/h3>
&lt;p>JavaScript 语言允许，语句的前面有标签（label），相当于定位符，用于跳转到程序的任意位置，标签的格式如下。&lt;/p>
&lt;pre>&lt;code>label:
语句
&lt;/code>&lt;/pre>
&lt;p>标签可以是任意的标识符，但不能是保留字，语句部分可以是任意语句。&lt;/p>
&lt;p>标签通常与&lt;code>break&lt;/code>语句和&lt;code>continue&lt;/code>语句配合使用，跳出特定的循环。&lt;/p>
&lt;pre>&lt;code>top:
for (var i = 0; i &amp;lt; 3; i++){
for (var j = 0; j &amp;lt; 3; j++){
if (i === 1 &amp;amp;&amp;amp; j === 1) break top;
console.log('i=' + i + ', j=' + j);
}
}
&lt;/code>&lt;/pre>
&lt;p>上面代码为一个双重循环区块，&lt;code>break&lt;/code>命令后面加上了&lt;code>top&lt;/code>标签（注意，&lt;code>top&lt;/code>不用加引号），满足条件时，直接跳出双层循环。如果&lt;code>break&lt;/code>语句后面不使用标签，则只能跳出内层循环，进入下一次的外层循环。&lt;/p>
&lt;p>标签也可以用于跳出代码块。&lt;/p>
&lt;pre>&lt;code>foo: {
console.log(1);
break foo;
console.log('本行不会输出');
}
console.log(2);
&lt;/code>&lt;/pre>
&lt;p>上面代码执行到&lt;code>break foo&lt;/code>，就会跳出区块。&lt;/p>
&lt;p>&lt;code>continue&lt;/code>语句也可以与标签配合使用。&lt;/p>
&lt;pre>&lt;code>top:
for (var i = 0; i &amp;lt; 3; i++){
for (var j = 0; j &amp;lt; 3; j++){
if (i === 1 &amp;amp;&amp;amp; j === 1) continue top;
console.log('i=' + i + ', j=' + j);
}
}
&lt;/code>&lt;/pre>
&lt;p>上面代码中，&lt;code>continue&lt;/code>命令后面有一个标签名，满足条件时，会跳过当前循环，直接进入下一轮外层循环。如果&lt;code>continue&lt;/code>语句后面不使用标签，则只能进入下一轮的内层循环。&lt;/p>
&lt;h2 id="参考链接">参考链接&lt;/h2>
&lt;ul>
&lt;li>Axel Rauschmayer, &lt;a href="http://www.2ality.com/2011/10/javascript-overview.html">A quick overview of JavaScript&lt;/a>&lt;/li>
&lt;/ul></description></item><item><title>Docs: ECMAScript 工具</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/2.%E7%BC%96%E7%A8%8B/%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/ecmascript/ecmascript-%E5%B7%A5%E5%85%B7/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/2.%E7%BC%96%E7%A8%8B/%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/ecmascript/ecmascript-%E5%B7%A5%E5%85%B7/</guid><description/></item><item><title>Docs: ECMAScript 环境安装与使用</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/2.%E7%BC%96%E7%A8%8B/%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/ecmascript/ecmascript-%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/2.%E7%BC%96%E7%A8%8B/%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/ecmascript/ecmascript-%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8/</guid><description/></item><item><title>Docs: JavaScript 标准库</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/2.%E7%BC%96%E7%A8%8B/%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/ecmascript/javascript-%E6%A0%87%E5%87%86%E5%BA%93/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/2.%E7%BC%96%E7%A8%8B/%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/ecmascript/javascript-%E6%A0%87%E5%87%86%E5%BA%93/</guid><description/></item><item><title>Docs: TypeScript 标准库</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/2.%E7%BC%96%E7%A8%8B/%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/ecmascript/typescript-%E6%A0%87%E5%87%86%E5%BA%93/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/2.%E7%BC%96%E7%A8%8B/%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/ecmascript/typescript-%E6%A0%87%E5%87%86%E5%BA%93/</guid><description/></item><item><title>Docs: Vue</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/2.%E7%BC%96%E7%A8%8B/%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/ecmascript/vue/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/2.%E7%BC%96%E7%A8%8B/%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/ecmascript/vue/</guid><description/></item><item><title>Docs: 常用编程技巧</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/2.%E7%BC%96%E7%A8%8B/%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/ecmascript/%E5%B8%B8%E7%94%A8%E7%BC%96%E7%A8%8B%E6%8A%80%E5%B7%A7/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/2.%E7%BC%96%E7%A8%8B/%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/ecmascript/%E5%B8%B8%E7%94%A8%E7%BC%96%E7%A8%8B%E6%8A%80%E5%B7%A7/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://www.bilibili.com/video/BV1dG411j7uW">B 站，【JavaScript】前端超有用的 10 个 JS 工具函数&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;h1 id="防抖与节流">防抖与节流&lt;/h1>
&lt;p>本质上是优化高频率执行代码的一种手段
如：浏览器的 resize、scroll、keypress、mousemove 等事件在触发时，会不断地调用绑定在事件上的回调函数，极大地浪费资源，降低前端性能
为了优化体验，需要对这类事件进行调用次数的限制，对此我们就可以采用 防抖（debounce） 和 节流（throttle） 的方式来减少调用频率&lt;/p>
&lt;h4 id="定义">定义&lt;/h4>
&lt;ul>
&lt;li>节流: n 秒内只运行一次，若在 n 秒内重复触发，只有一次生效&lt;/li>
&lt;li>防抖: n 秒后在执行该事件，若在 n 秒内被重复触发，则重新计时&lt;/li>
&lt;/ul>
&lt;p>一个经典的比喻:
想象每天上班大厦底下的电梯。把电梯完成一次运送，类比为一次函数的执行和响应
假设电梯有两种运行策略 debounce 和 throttle，超时设定为 15 秒，不考虑容量限制
电梯第一个人进来后，15 秒后准时运送一次，这是节流
电梯第一个人进来后，等待 15 秒。如果过程中又有人进来，15 秒等待重新计时，直到 15 秒后开始运送，这是防抖&lt;/p>
&lt;h1 id="大小写转换">大小写转换&lt;/h1>
&lt;h1 id="数组中对象类型的元素去重">数组中对象类型的元素去重&lt;/h1>
&lt;h1 id="校验数据类型">校验数据类型&lt;/h1>
&lt;h1 id="滚动到页面顶部">滚动到页面顶部&lt;/h1>
&lt;h1 id="滚动到对应元素的位置">滚动到对应元素的位置&lt;/h1>
&lt;h1 id="获取当前时间">获取当前时间&lt;/h1>
&lt;h1 id="获取当月的第一天和最后一天">获取当月的第一天和最后一天&lt;/h1>
&lt;h1 id="模糊查询">模糊查询&lt;/h1></description></item></channel></rss>