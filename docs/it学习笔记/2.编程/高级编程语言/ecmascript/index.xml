<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>断念梦 – ECMAScript</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/2.%E7%BC%96%E7%A8%8B/%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/ecmascript/</link><description>Recent content in ECMAScript on 断念梦</description><generator>Hugo -- gohugo.io</generator><atom:link href="https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/2.%E7%BC%96%E7%A8%8B/%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/ecmascript/index.xml" rel="self" type="application/rss+xml"/><item><title>Docs: ECMAScript</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/2.%E7%BC%96%E7%A8%8B/%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/ecmascript/ecmascript/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/2.%E7%BC%96%E7%A8%8B/%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/ecmascript/ecmascript/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/ECMAScript">Wiki,ECMAScript&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.javascript.com/">JavaScript 官网&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.typescriptlang.org/">TypeScript 官网&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>ECMAScript 是一种编程语言的&lt;strong>标准&lt;/strong>，起源于 JavaScripts。&lt;/p>
&lt;p>1996 年 8 月，微软模仿 JavaScript 开发了一种相近的语言，取名为 JScript（JavaScript 是 Netscape 的注册商标，微软不能用），首先内置于 IE 3.0。Netscape 公司面临丧失浏览器脚本语言的主导权的局面。&lt;/p>
&lt;p>1996 年 11 月，Netscape 公司决定将 JavaScript 提交给国际标准化组织 ECMA（European Computer Manufacturers Association），希望 JavaScript 能够成为国际标准，以此抵抗微软。ECMA 的 39 号技术委员会（Technical Committee 39）负责制定和审核这个标准，成员由业内的大公司派出的工程师组成，目前共 25 个人。该委员会定期开会，所有的邮件讨论和会议记录，都是公开的。&lt;/p>
&lt;p>1997 年 7 月，ECMA 组织发布 262 号标准文件（ECMA-262）的第一版，规定了浏览器脚本语言的标准，并将这种语言称为 ECMAScript。这个版本就是 ECMAScript 1.0 版。之所以不叫 JavaScript，一方面是由于商标的关系，Java 是 Sun 公司的商标，根据一份授权协议，只有 Netscape 公司可以合法地使用 JavaScript 这个名字，且 JavaScript 已经被 Netscape 公司注册为商标，另一方面也是想体现这门语言的制定者是 ECMA，不是 Netscape，这样有利于保证这门语言的开放性和中立性。因此，ECMAScript 和 JavaScript 的关系是，前者是后者的规范，后者是前者的一种实现。在日常场合，这两个词是可以互换的。&lt;/p>
&lt;p>ECMAScript 只用来标准化 JavaScript 这种语言的基本语法结构，与部署环境相关的标准都由其他标准规定，比如 DOM 的标准就是由 W3C 组织（World Wide Web Consortium）制定的。&lt;/p>
&lt;p>ECMA-262 标准后来也被另一个国际标准化组织 ISO（International Organization for Standardization）批准，标准号是 ISO-16262。&lt;/p>
&lt;h2 id="es6-标准">ES6 标准&lt;/h2>
&lt;p>ECMAScript 6.0 是 ECMA 的最新标准，于 2015 年 6 月发布，官方称为 ES2015 标准(ES6 的叫法更民间)。&lt;/p>
&lt;p>2011 年，ECMAScript 5.1 版发布后，就开始制定 6.0 版了。因此，ES6 这个词的原意，就是指 JavaScript 语言的下一个版本。&lt;/p>
&lt;p>但是，因为这个版本引入的语法功能太多，而且制定过程当中，还有很多组织和个人不断提交新功能。事情很快就变得清楚了，不可能在一个版本里面包括所有将要引入的功能。常规的做法是先发布 6.0 版，过一段时间再发 6.1 版，然后是 6.2 版、6.3 版等等。&lt;/p>
&lt;p>但是，标准的制定者不想这样做。他们想让标准的升级成为常规流程：任何人在任何时候，都可以向标准委员会提交新语法的提案，然后标准委员会每个月开一次会，评估这些提案是否可以接受，需要哪些改进。如果经过多次会议以后，一个提案足够成熟了，就可以正式进入标准了。这就是说，标准的版本升级成为了一个不断滚动的流程，每个月都会有变动。&lt;/p>
&lt;p>标准委员会最终决定，标准在每年的 6 月份正式发布一次，作为当年的正式版本。接下来的时间，就在这个版本的基础上做改动，直到下一年的 6 月份，草案就自然变成了新一年的版本。这样一来，就不需要以前的版本号了，只要用年份标记就可以了。&lt;/p>
&lt;p>ES6 的第一个版本，就这样在 2015 年 6 月发布了，正式名称就是《ECMAScript 2015 标准》（简称 ES2015）。2016 年 6 月，小幅修订的《ECMAScript 2016 标准》（简称 ES2016）如期发布，这个版本可以看作是 ES6.1 版，因为两者的差异非常小（只新增了数组实例的 includes 方法和指数运算符），基本上是同一个标准。根据计划，2017 年 6 月发布 ES2017 标准。&lt;/p>
&lt;p>因此，ES6 既是一个历史名词，也是一个泛指，含义是 5.1 版以后的 JavaScript 的下一代标准，涵盖了 ES2015、ES2016、ES2017 等等，而 ES2015 则是正式名称，特指该年发布的正式版本的语言标准。本书中提到 ES6 的地方，一般是指 ES2015 标准，但有时也是泛指“下一代 JavaScript 语言”。&lt;/p>
&lt;h2 id="ecmascript-的三大核心组成">ECMAScript 的三大核心组成&lt;/h2>
&lt;p>&lt;strong>ECMAScript&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>JS 的书写语法和规则&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>Browser Ojbect Model(浏览器对象模型，简称 BOM)&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>JS 控制浏览器的属性和方法。
&lt;ul>
&lt;li>比如浏览器右侧的滚动条，可以通过 JS 代码来控制。比如某些网页有个叫回到顶部的按钮，按一下，就等于是 JS 操作滚动条移动到最上面了。&lt;/li>
&lt;li>比如很多手机，我们从屏幕最左侧往右滑，一般返回上一页。这是因为这个滑动行为被 JS 代码捕获后，操作浏览器点击了一下后腿按钮。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>Document Object Model(文档对象模型，简称 DOM)&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>JS 控制文档流的属性和方法。
&lt;ul>
&lt;li>比如很多网页最上面中间都有一个图片，按一下图片左右两边的箭头，就会换到另一个图片&lt;/li>
&lt;li>也就是说，JS 控制什么时候，让页面元素发生一些变化&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h1 id="学习资料">学习资料&lt;/h1>
&lt;p>&lt;a href="https://developer.mozilla.org/en-US/docs/Web">MDN 官方文档，Web 开发技术&lt;/a>((通常指的是网站首页的 References 标签中的文档))&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript">JavaScript&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Lexical_grammar#keywords">JavaScript-参考-词汇文法-关键字&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Statements">JavaScript-参考-语句和声明&lt;/a>(这里就是 JS 的关键字的用法)&lt;/li>
&lt;/ul>
&lt;p>&lt;a href="https://www.liaoxuefeng.com/wiki/1022910821149312">廖雪峰，JavaScript&lt;/a>
&lt;a href="https://wangdoc.com/javascript/index.html">网道，JavaScript&lt;/a>&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://wangdoc.com/javascript/basic/grammar.html">网道，JavaScript-JavaScript 的基本语法&lt;/a>&lt;/li>
&lt;/ul>
&lt;p>电子书&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://github.com/javascript-tutorial/zh.javascript.info/tree/master">GitHub 项目，javascript/zh.javascript.info&lt;/a>(现代 JavaScript 教程)&lt;/li>
&lt;/ul>
&lt;h1 id="hello-world">Hello World&lt;/h1>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-html" data-lang="html">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&amp;lt;!DOCTYPE html&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&amp;lt;&lt;span style="color:#f92672">html&lt;/span>&amp;gt;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &amp;lt;&lt;span style="color:#f92672">head&lt;/span>&amp;gt;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &amp;lt;&lt;span style="color:#f92672">meta&lt;/span> &lt;span style="color:#a6e22e">charset&lt;/span>&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;UTF-8&amp;#34;&lt;/span> /&amp;gt;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &amp;lt;&lt;span style="color:#f92672">title&lt;/span>&amp;gt;Hello World&amp;lt;/&lt;span style="color:#f92672">title&lt;/span>&amp;gt;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &amp;lt;/&lt;span style="color:#f92672">head&lt;/span>&amp;gt;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &amp;lt;&lt;span style="color:#f92672">body&lt;/span>&amp;gt;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">&amp;lt;!-- 有多种方式可以在书写 JS 代码 --&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">&amp;lt;!-- 行内式， JS 代码写在标签上--&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">&amp;lt;!-- a 标签，书写在 href 属性上 --&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &amp;lt;&lt;span style="color:#f92672">a&lt;/span> &lt;span style="color:#a6e22e">href&lt;/span>&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;javascript: alert(&amp;#39;Hello World，行内式，a 标签&amp;#39;);&amp;#34;&lt;/span>&amp;gt;点我&amp;lt;/&lt;span style="color:#f92672">a&lt;/span>&amp;gt;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">&amp;lt;!-- 非 a 标签，书写在行为属性上 --&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &amp;lt;&lt;span style="color:#f92672">div&lt;/span> &lt;span style="color:#a6e22e">onclick&lt;/span>&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;alert(&amp;#39;Hello World，行内式，非 a 标签&amp;#39;)&amp;#34;&lt;/span>&amp;gt;点我&amp;lt;/&lt;span style="color:#f92672">div&lt;/span>&amp;gt;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">&amp;lt;!-- 内嵌式，JS 代码写在 script 标签中 --&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &amp;lt;&lt;span style="color:#f92672">script&lt;/span>&amp;gt;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 在前端页面上显示的内容
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#a6e22e">alert&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;Hello World 内嵌式&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 在后端控制台显示的内容
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#a6e22e">console&lt;/span>.&lt;span style="color:#a6e22e">log&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;Hello World backend&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &amp;lt;/&lt;span style="color:#f92672">script&lt;/span>&amp;gt;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">&amp;lt;!-- 外链试，JS 代码写在单独的 .js 文件中，并通过 script 标签的 src 属性引入 .js 文件 --&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &amp;lt;&lt;span style="color:#f92672">script&lt;/span> &lt;span style="color:#a6e22e">src&lt;/span>&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;./hello_world.js&amp;#34;&lt;/span>&amp;gt;&amp;lt;/&lt;span style="color:#f92672">script&lt;/span>&amp;gt;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">&amp;lt;!-- 总结：
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> 行内式 # 强烈不推荐。不利于代码维护，也会导致 HTML 文件过于臃肿。
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> 内嵌式 # 一般测试或者学习时，使用这种方式，不用建立很多 .js 文件。
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> 外链式 # 强烈推荐
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> --&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &amp;lt;/&lt;span style="color:#f92672">body&lt;/span>&amp;gt;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&amp;lt;/&lt;span style="color:#f92672">html&lt;/span>&amp;gt;
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h1 id="javascript-语言关键字">JavaScript 语言关键字&lt;/h1>
&lt;p>break
case
catch
class
const
continue
debugger
default
delete
do
else
enum
export
extends
false
finally
for
function
if
implements
import
in
instanceof
interface
let
new
null
package
private
protected
public
return
super
switch
static
this
throw
try
true
typeof
var
void
while
with
yield&lt;/p>
&lt;h1 id="javascript-基本语法规范">JavaScript 基本语法规范&lt;/h1>
&lt;h2 id="语句-e8afade58fa5">语句 &lt;a href="#%E8%AF%AD%E5%8F%A5">#&lt;/a>&lt;/h2>
&lt;p>JavaScript 程序的执行单位为行（line），也就是一行一行地执行。一般情况下，每一行就是一个语句。&lt;/p>
&lt;p>语句（statement）是为了完成某种任务而进行的操作，比如下面就是一行赋值语句。&lt;/p>
&lt;pre>&lt;code>var a = 1 + 3;
&lt;/code>&lt;/pre>
&lt;p>这条语句先用&lt;code>var&lt;/code>命令，声明了变量&lt;code>a&lt;/code>，然后将&lt;code>1 + 3&lt;/code>的运算结果赋值给变量&lt;code>a&lt;/code>。&lt;/p>
&lt;p>&lt;code>1 + 3&lt;/code>叫做表达式（expression），指一个为了得到返回值的计算式。语句和表达式的区别在于，前者主要为了进行某种操作，一般情况下不需要返回值；后者则是为了得到返回值，一定会返回一个值。凡是 JavaScript 语言中预期为值的地方，都可以使用表达式。比如，赋值语句的等号右边，预期是一个值，因此可以放置各种表达式。&lt;/p>
&lt;p>语句以分号结尾，一个分号就表示一个语句结束。多个语句可以写在一行内。&lt;/p>
&lt;pre>&lt;code>var a = 1 + 3 ; var b = 'abc';
&lt;/code>&lt;/pre>
&lt;p>分号前面可以没有任何内容，JavaScript 引擎将其视为空语句。&lt;/p>
&lt;pre>&lt;code>;;;
&lt;/code>&lt;/pre>
&lt;p>上面的代码就表示 3 个空语句。&lt;/p>
&lt;p>表达式不需要分号结尾。一旦在表达式后面添加分号，则 JavaScript 引擎就将表达式视为语句，这样会产生一些没有任何意义的语句。&lt;/p>
&lt;pre>&lt;code>1 + 3;
'abc';
&lt;/code>&lt;/pre>
&lt;p>上面两行语句只是单纯地产生一个值，并没有任何实际的意义。&lt;/p>
&lt;h2 id="变量-e58f98e9878f">变量 &lt;a href="#%E5%8F%98%E9%87%8F">#&lt;/a>&lt;/h2>
&lt;h3 id="概念-e6a682e5bfb5">概念 &lt;a href="#%E6%A6%82%E5%BF%B5">#&lt;/a>&lt;/h3>
&lt;p>变量是对“值”的具名引用。变量就是为“值”起名，然后引用这个名字，就等同于引用这个值。变量的名字就是变量名。&lt;/p>
&lt;pre>&lt;code>var a = 1;
&lt;/code>&lt;/pre>
&lt;p>上面的代码先声明变量&lt;code>a&lt;/code>，然后在变量&lt;code>a&lt;/code>与数值 1 之间建立引用关系，称为将数值 1“赋值”给变量&lt;code>a&lt;/code>。以后，引用变量名&lt;code>a&lt;/code>就会得到数值 1。最前面的&lt;code>var&lt;/code>，是变量声明命令。它表示通知解释引擎，要创建一个变量&lt;code>a&lt;/code>。&lt;/p>
&lt;p>注意，JavaScript 的变量名区分大小写，&lt;code>A&lt;/code>和&lt;code>a&lt;/code>是两个不同的变量。&lt;/p>
&lt;p>变量的声明和赋值，是分开的两个步骤，上面的代码将它们合在了一起，实际的步骤是下面这样。&lt;/p>
&lt;pre>&lt;code>var a;
a = 1;
&lt;/code>&lt;/pre>
&lt;p>如果只是声明变量而没有赋值，则该变量的值是&lt;code>undefined&lt;/code>。&lt;code>undefined&lt;/code>是一个特殊的值，表示“无定义”。&lt;/p>
&lt;pre>&lt;code>var a;
a
&lt;/code>&lt;/pre>
&lt;p>如果变量赋值的时候，忘了写&lt;code>var&lt;/code>命令，这条语句也是有效的。&lt;/p>
&lt;pre>&lt;code>var a = 1;
a = 1;
&lt;/code>&lt;/pre>
&lt;p>但是，不写&lt;code>var&lt;/code>的做法，不利于表达意图，而且容易不知不觉地创建全局变量，所以建议总是使用&lt;code>var&lt;/code>命令声明变量。&lt;/p>
&lt;p>如果一个变量没有声明就直接使用，JavaScript 会报错，告诉你变量未定义。&lt;/p>
&lt;pre>&lt;code>x
&lt;/code>&lt;/pre>
&lt;p>上面代码直接使用变量&lt;code>x&lt;/code>，系统就报错，告诉你变量&lt;code>x&lt;/code>没有声明。&lt;/p>
&lt;p>可以在同一条&lt;code>var&lt;/code>命令中声明多个变量。&lt;/p>
&lt;pre>&lt;code>var a, b;
&lt;/code>&lt;/pre>
&lt;p>JavaScript 是一种动态类型语言，也就是说，变量的类型没有限制，变量可以随时更改类型。&lt;/p>
&lt;pre>&lt;code>var a = 1;
a = 'hello';
&lt;/code>&lt;/pre>
&lt;p>上面代码中，变量&lt;code>a&lt;/code>起先被赋值为一个数值，后来又被重新赋值为一个字符串。第二次赋值的时候，因为变量&lt;code>a&lt;/code>已经存在，所以不需要使用&lt;code>var&lt;/code>命令。&lt;/p>
&lt;p>如果使用&lt;code>var&lt;/code>重新声明一个已经存在的变量，是无效的。&lt;/p>
&lt;pre>&lt;code>var x = 1;
var x;
x
&lt;/code>&lt;/pre>
&lt;p>上面代码中，变量&lt;code>x&lt;/code>声明了两次，第二次声明是无效的。&lt;/p>
&lt;p>但是，如果第二次声明的时候还进行了赋值，则会覆盖掉前面的值。&lt;/p>
&lt;pre>&lt;code>var x = 1;
var x = 2;
var x = 1;
var x;
x = 2;
&lt;/code>&lt;/pre>
&lt;h3 id="variables-hoisting变量提升">Variables Hoisting(变量提升)&lt;/h3>
&lt;p>JavaScript 引擎的工作方式是，先解析代码，获取所有被声明的变量，然后再一行一行地运行。这造成的结果，就是所有的变量的声明语句，都会被提升到代码的头部，这就叫做变量提升（hoisting）。&lt;/p>
&lt;pre>&lt;code>console.log(a);
var a = 1;
&lt;/code>&lt;/pre>
&lt;p>上面代码首先使用&lt;code>console.log&lt;/code>方法，在控制台（console）显示变量&lt;code>a&lt;/code>的值。这时变量&lt;code>a&lt;/code>还没有声明和赋值，所以这是一种错误的做法，但是实际上不会报错。因为存在变量提升，真正运行的是下面的代码。&lt;/p>
&lt;pre>&lt;code>var a;
console.log(a);
a = 1;
&lt;/code>&lt;/pre>
&lt;p>最后的结果是显示&lt;code>undefined&lt;/code>，表示变量&lt;code>a&lt;/code>已声明，但还未赋值。&lt;/p>
&lt;h2 id="标识符-e6a087e8af86e7aca6">标识符 &lt;a href="#%E6%A0%87%E8%AF%86%E7%AC%A6">#&lt;/a>&lt;/h2>
&lt;p>标识符（identifier）指的是用来识别各种值的合法名称。最常见的标识符就是变量名，以及后面要提到的函数名。JavaScript 语言的标识符对大小写敏感，所以&lt;code>a&lt;/code>和&lt;code>A&lt;/code>是两个不同的标识符。&lt;/p>
&lt;p>标识符有一套命名规则，不符合规则的就是非法标识符。JavaScript 引擎遇到非法标识符，就会报错。&lt;/p>
&lt;p>简单说，标识符命名规则如下。&lt;/p>
&lt;ul>
&lt;li>第一个字符，可以是任意 Unicode 字母（包括英文字母和其他语言的字母），以及美元符号（&lt;code>$&lt;/code>）和下划线（&lt;code>_&lt;/code>）。&lt;/li>
&lt;li>第二个字符及后面的字符，除了 Unicode 字母、美元符号和下划线，还可以用数字&lt;code>0-9&lt;/code>。&lt;/li>
&lt;/ul>
&lt;p>下面这些都是合法的标识符。&lt;/p>
&lt;pre>&lt;code>arg0
_tmp
$elem
π
&lt;/code>&lt;/pre>
&lt;p>下面这些则是不合法的标识符。&lt;/p>
&lt;pre>&lt;code>1a
23
***
a+b
-d
&lt;/code>&lt;/pre>
&lt;p>中文是合法的标识符，可以用作变量名。&lt;/p>
&lt;pre>&lt;code>var 临时变量 = 1;
&lt;/code>&lt;/pre>
&lt;blockquote>
&lt;p>JavaScript 有一些保留字，不能用作标识符：arguments、break、case、catch、class、const、continue、debugger、default、delete、do、else、enum、eval、export、extends、false、finally、for、function、if、implements、import、in、instanceof、interface、let、new、null、package、private、protected、public、return、static、super、switch、this、throw、true、try、typeof、var、void、while、with、yield。&lt;/p>
&lt;/blockquote>
&lt;h2 id="注释-e6b3a8e9878a">注释 &lt;a href="#%E6%B3%A8%E9%87%8A">#&lt;/a>&lt;/h2>
&lt;p>源码中被 JavaScript 引擎忽略的部分就叫做注释，它的作用是对代码进行解释。JavaScript 提供两种注释的写法：一种是单行注释，用&lt;code>//&lt;/code>起头；另一种是多行注释，放在&lt;code>/*&lt;/code>和&lt;code>*/&lt;/code>之间。&lt;/p>
&lt;p>此外，由于历史上 JavaScript 可以兼容 HTML 代码的注释，所以&lt;code>&amp;lt;!--&lt;/code>和&lt;code>--&amp;gt;&lt;/code>也被视为合法的单行注释。&lt;/p>
&lt;pre>&lt;code>x = 1; &amp;lt;!-- x = 2;
--&amp;gt; x = 3;
&lt;/code>&lt;/pre>
&lt;p>上面代码中，只有&lt;code>x = 1&lt;/code>会执行，其他的部分都被注释掉了。&lt;/p>
&lt;p>需要注意的是，&lt;code>--&amp;gt;&lt;/code>只有在行首，才会被当成单行注释，否则会当作正常的运算。&lt;/p>
&lt;pre>&lt;code>function countdown(n) {
while (n --&amp;gt; 0) console.log(n);
}
countdown(3)
&lt;/code>&lt;/pre>
&lt;p>上面代码中，&lt;code>n --&amp;gt; 0&lt;/code>实际上会当作&lt;code>n-- &amp;gt; 0&lt;/code>，因此输出 2、1、0。&lt;/p>
&lt;h2 id="区块-e58cbae59d97">区块 &lt;a href="#%E5%8C%BA%E5%9D%97">#&lt;/a>&lt;/h2>
&lt;p>JavaScript 使用大括号，将多个相关的语句组合在一起，称为“区块”（block）。&lt;/p>
&lt;p>对于&lt;code>var&lt;/code>命令来说，JavaScript 的区块不构成单独的作用域（scope）。&lt;/p>
&lt;pre>&lt;code>{
var a = 1;
}
a
&lt;/code>&lt;/pre>
&lt;p>上面代码在区块内部，使用&lt;code>var&lt;/code>命令声明并赋值了变量&lt;code>a&lt;/code>，然后在区块外部，变量&lt;code>a&lt;/code>依然有效，区块对于&lt;code>var&lt;/code>命令不构成单独的作用域，与不使用区块的情况没有任何区别。在 JavaScript 语言中，单独使用区块并不常见，区块往往用来构成其他更复杂的语法结构，比如&lt;code>for&lt;/code>、&lt;code>if&lt;/code>、&lt;code>while&lt;/code>、&lt;code>function&lt;/code>等。&lt;/p>
&lt;h2 id="条件语句-e69da1e4bbb6e8afade58fa5">条件语句 &lt;a href="#%E6%9D%A1%E4%BB%B6%E8%AF%AD%E5%8F%A5">#&lt;/a>&lt;/h2>
&lt;p>JavaScript 提供&lt;code>if&lt;/code>结构和&lt;code>switch&lt;/code>结构，完成条件判断，即只有满足预设的条件，才会执行相应的语句。&lt;/p>
&lt;h3 id="if-结构-if-e7bb93e69e84">if 结构 &lt;a href="#if-%E7%BB%93%E6%9E%84">#&lt;/a>&lt;/h3>
&lt;p>&lt;code>if&lt;/code>结构先判断一个表达式的布尔值，然后根据布尔值的真伪，执行不同的语句。所谓布尔值，指的是 JavaScript 的两个特殊值，&lt;code>true&lt;/code>表示“真”，&lt;code>false&lt;/code>表示“伪”。&lt;/p>
&lt;pre>&lt;code>if (布尔值)
语句;
if (布尔值) 语句;
&lt;/code>&lt;/pre>
&lt;p>上面是&lt;code>if&lt;/code>结构的基本形式。需要注意的是，“布尔值”往往由一个条件表达式产生的，必须放在圆括号中，表示对表达式求值。如果表达式的求值结果为&lt;code>true&lt;/code>，就执行紧跟在后面的语句；如果结果为&lt;code>false&lt;/code>，则跳过紧跟在后面的语句。&lt;/p>
&lt;pre>&lt;code>if (m === 3)
m = m + 1;
&lt;/code>&lt;/pre>
&lt;p>上面代码表示，只有在&lt;code>m&lt;/code>等于 3 时，才会将其值加上 1。&lt;/p>
&lt;p>这种写法要求条件表达式后面只能有一个语句。如果想执行多个语句，必须在&lt;code>if&lt;/code>的条件判断之后，加上大括号，表示代码块（多个语句合并成一个语句）。&lt;/p>
&lt;pre>&lt;code>if (m === 3) {
m += 1;
}
&lt;/code>&lt;/pre>
&lt;p>建议总是在&lt;code>if&lt;/code>语句中使用大括号，因为这样方便插入语句。&lt;/p>
&lt;p>注意，&lt;code>if&lt;/code>后面的表达式之中，不要混淆赋值表达式（&lt;code>=&lt;/code>）、严格相等运算符（&lt;code>===&lt;/code>）和相等运算符（&lt;code>==&lt;/code>）。尤其是赋值表达式不具有比较作用。&lt;/p>
&lt;pre>&lt;code>var x = 1;
var y = 2;
if (x = y) {
console.log(x);
}
&lt;/code>&lt;/pre>
&lt;p>上面代码的原意是，当&lt;code>x&lt;/code>等于&lt;code>y&lt;/code>的时候，才执行相关语句。但是，不小心将严格相等运算符写成赋值表达式，结果变成了将&lt;code>y&lt;/code>赋值给变量&lt;code>x&lt;/code>，再判断变量&lt;code>x&lt;/code>的值（等于 2）的布尔值（结果为&lt;code>true&lt;/code>）。&lt;/p>
&lt;p>这种错误可以正常生成一个布尔值，因而不会报错。为了避免这种情况，有些开发者习惯将常量写在运算符的左边，这样的话，一旦不小心将相等运算符写成赋值运算符，就会报错，因为常量不能被赋值。&lt;/p>
&lt;pre>&lt;code>if (x = 2) {
if (2 = x) {
&lt;/code>&lt;/pre>
&lt;p>至于为什么优先采用“严格相等运算符”（&lt;code>===&lt;/code>），而不是“相等运算符”（&lt;code>==&lt;/code>），请参考《运算符》章节。&lt;/p>
&lt;h3 id="ifelse-结构-ifelse-e7bb93e69e84">if&amp;hellip;else 结构 &lt;a href="#ifelse-%E7%BB%93%E6%9E%84">#&lt;/a>&lt;/h3>
&lt;p>&lt;code>if&lt;/code>代码块后面，还可以跟一个&lt;code>else&lt;/code>代码块，表示不满足条件时，所要执行的代码。&lt;/p>
&lt;pre>&lt;code>if (m === 3) {
} else {
}
&lt;/code>&lt;/pre>
&lt;p>上面代码判断变量&lt;code>m&lt;/code>是否等于 3，如果等于就执行&lt;code>if&lt;/code>代码块，否则执行&lt;code>else&lt;/code>代码块。&lt;/p>
&lt;p>对同一个变量进行多次判断时，多个&lt;code>if...else&lt;/code>语句可以连写在一起。&lt;/p>
&lt;pre>&lt;code>if (m === 0) {
} else if (m === 1) {
} else if (m === 2) {
} else {
}
&lt;/code>&lt;/pre>
&lt;p>&lt;code>else&lt;/code>代码块总是与离自己最近的那个&lt;code>if&lt;/code>语句配对。&lt;/p>
&lt;pre>&lt;code>var m = 1;
var n = 2;
if (m !== 1)
if (n === 2) console.log('hello');
else console.log('world');
&lt;/code>&lt;/pre>
&lt;p>上面代码不会有任何输出，&lt;code>else&lt;/code>代码块不会得到执行，因为它跟着的是最近的那个&lt;code>if&lt;/code>语句，相当于下面这样。&lt;/p>
&lt;pre>&lt;code>if (m !== 1) {
if (n === 2) {
console.log('hello');
} else {
console.log('world');
}
}
&lt;/code>&lt;/pre>
&lt;p>如果想让&lt;code>else&lt;/code>代码块跟随最上面的那个&lt;code>if&lt;/code>语句，就要改变大括号的位置。&lt;/p>
&lt;pre>&lt;code>if (m !== 1) {
if (n === 2) {
console.log('hello');
}
} else {
console.log('world');
}
&lt;/code>&lt;/pre>
&lt;h3 id="switch-结构-switch-e7bb93e69e84">switch 结构 &lt;a href="#switch-%E7%BB%93%E6%9E%84">#&lt;/a>&lt;/h3>
&lt;p>多个&lt;code>if...else&lt;/code>连在一起使用的时候，可以转为使用更方便的&lt;code>switch&lt;/code>结构。&lt;/p>
&lt;pre>&lt;code>switch (fruit) {
case &amp;quot;banana&amp;quot;:
break;
case &amp;quot;apple&amp;quot;:
break;
default:
}
&lt;/code>&lt;/pre>
&lt;p>上面代码根据变量&lt;code>fruit&lt;/code>的值，选择执行相应的&lt;code>case&lt;/code>。如果所有&lt;code>case&lt;/code>都不符合，则执行最后的&lt;code>default&lt;/code>部分。需要注意的是，每个&lt;code>case&lt;/code>代码块内部的&lt;code>break&lt;/code>语句不能少，否则会接下去执行下一个&lt;code>case&lt;/code>代码块，而不是跳出&lt;code>switch&lt;/code>结构。&lt;/p>
&lt;pre>&lt;code>var x = 1;
switch (x) {
case 1:
console.log('x 等于1');
case 2:
console.log('x 等于2');
default:
console.log('x 等于其他值');
}
&lt;/code>&lt;/pre>
&lt;p>上面代码中，&lt;code>case&lt;/code>代码块之中没有&lt;code>break&lt;/code>语句，导致不会跳出&lt;code>switch&lt;/code>结构，而会一直执行下去。正确的写法是像下面这样。&lt;/p>
&lt;pre>&lt;code>switch (x) {
case 1:
console.log('x 等于1');
break;
case 2:
console.log('x 等于2');
break;
default:
console.log('x 等于其他值');
}
&lt;/code>&lt;/pre>
&lt;p>&lt;code>switch&lt;/code>语句部分和&lt;code>case&lt;/code>语句部分，都可以使用表达式。&lt;/p>
&lt;pre>&lt;code>switch (1 + 3) {
case 2 + 2:
f();
break;
default:
neverHappens();
}
&lt;/code>&lt;/pre>
&lt;p>上面代码的&lt;code>default&lt;/code>部分，是永远不会执行到的。&lt;/p>
&lt;p>需要注意的是，&lt;code>switch&lt;/code>语句后面的表达式，与&lt;code>case&lt;/code>语句后面的表示式比较运行结果时，采用的是严格相等运算符（&lt;code>===&lt;/code>），而不是相等运算符（&lt;code>==&lt;/code>），这意味着比较时不会发生类型转换。&lt;/p>
&lt;pre>&lt;code>var x = 1;
switch (x) {
case true:
console.log('x 发生类型转换');
break;
default:
console.log('x 没有发生类型转换');
}
&lt;/code>&lt;/pre>
&lt;p>上面代码中，由于变量&lt;code>x&lt;/code>没有发生类型转换，所以不会执行&lt;code>case true&lt;/code>的情况。这表明，&lt;code>switch&lt;/code>语句内部采用的是“严格相等运算符”，详细解释请参考《运算符》一节。&lt;/p>
&lt;h3 id="三元运算符--e4b889e58583e8bf90e7ae97e7aca6-">三元运算符 ?: &lt;a href="#%E4%B8%89%E5%85%83%E8%BF%90%E7%AE%97%E7%AC%A6-">#&lt;/a>&lt;/h3>
&lt;p>JavaScript 还有一个三元运算符（即该运算符需要三个运算子）&lt;code>?:&lt;/code>，也可以用于逻辑判断。&lt;/p>
&lt;pre>&lt;code>(条件) ? 表达式1 : 表达式2
&lt;/code>&lt;/pre>
&lt;p>上面代码中，如果“条件”为&lt;code>true&lt;/code>，则返回“表达式 1”的值，否则返回“表达式 2”的值。&lt;/p>
&lt;pre>&lt;code>var even = (n % 2 === 0) ? true : false;
&lt;/code>&lt;/pre>
&lt;p>上面代码中，如果&lt;code>n&lt;/code>可以被 2 整除，则&lt;code>even&lt;/code>等于&lt;code>true&lt;/code>，否则等于&lt;code>false&lt;/code>。它等同于下面的形式。&lt;/p>
&lt;pre>&lt;code>var even;
if (n % 2 === 0) {
even = true;
} else {
even = false;
}
&lt;/code>&lt;/pre>
&lt;p>这个三元运算符可以被视为&lt;code>if...else...&lt;/code>的简写形式，因此可以用于多种场合。&lt;/p>
&lt;pre>&lt;code>var myVar;
console.log(
myVar ?
'myVar has a value' :
'myVar does not have a value'
)
&lt;/code>&lt;/pre>
&lt;p>上面代码利用三元运算符，输出相应的提示。&lt;/p>
&lt;pre>&lt;code>var msg = '数字' + n + '是' + (n % 2 === 0 ? '偶数' : '奇数');
&lt;/code>&lt;/pre>
&lt;p>上面代码利用三元运算符，在字符串之中插入不同的值。&lt;/p>
&lt;h2 id="循环语句-e5beaae78eafe8afade58fa5">循环语句 &lt;a href="#%E5%BE%AA%E7%8E%AF%E8%AF%AD%E5%8F%A5">#&lt;/a>&lt;/h2>
&lt;p>循环语句用于重复执行某个操作，它有多种形式。&lt;/p>
&lt;h3 id="while-循环-while-e5beaae78eaf">while 循环 &lt;a href="#while-%E5%BE%AA%E7%8E%AF">#&lt;/a>&lt;/h3>
&lt;p>&lt;code>While&lt;/code>语句包括一个循环条件和一段代码块，只要条件为真，就不断循环执行代码块。&lt;/p>
&lt;pre>&lt;code>while (条件)
语句;
while (条件) 语句;
&lt;/code>&lt;/pre>
&lt;p>&lt;code>while&lt;/code>语句的循环条件是一个表达式，必须放在圆括号中。代码块部分，如果只有一条语句，可以省略大括号，否则就必须加上大括号。&lt;/p>
&lt;pre>&lt;code>while (条件) {
语句;
}
&lt;/code>&lt;/pre>
&lt;p>下面是&lt;code>while&lt;/code>语句的一个例子。&lt;/p>
&lt;pre>&lt;code>var i = 0;
while (i &amp;lt; 100) {
console.log('i 当前为：' + i);
i = i + 1;
}
&lt;/code>&lt;/pre>
&lt;p>上面的代码将循环 100 次，直到&lt;code>i&lt;/code>等于 100 为止。&lt;/p>
&lt;p>下面的例子是一个无限循环，因为循环条件总是为真。&lt;/p>
&lt;pre>&lt;code>while (true) {
console.log('Hello, world');
}
&lt;/code>&lt;/pre>
&lt;h3 id="for-循环-for-e5beaae78eaf">for 循环 &lt;a href="#for-%E5%BE%AA%E7%8E%AF">#&lt;/a>&lt;/h3>
&lt;p>&lt;code>for&lt;/code>语句是循环命令的另一种形式，可以指定循环的起点、终点和终止条件。它的格式如下。&lt;/p>
&lt;pre>&lt;code>for (初始化表达式; 条件; 递增表达式)
语句
for (初始化表达式; 条件; 递增表达式) {
语句
}
&lt;/code>&lt;/pre>
&lt;p>&lt;code>for&lt;/code>语句后面的括号里面，有三个表达式。&lt;/p>
&lt;ul>
&lt;li>初始化表达式（initialize）：确定循环变量的初始值，只在循环开始时执行一次。&lt;/li>
&lt;li>条件表达式（test）：每轮循环开始时，都要执行这个条件表达式，只有值为真，才继续进行循环。&lt;/li>
&lt;li>递增表达式（increment）：每轮循环的最后一个操作，通常用来递增循环变量。&lt;/li>
&lt;/ul>
&lt;p>下面是一个例子。&lt;/p>
&lt;pre>&lt;code>var x = 3;
for (var i = 0; i &amp;lt; x; i++) {
console.log(i);
}
&lt;/code>&lt;/pre>
&lt;p>上面代码中，初始化表达式是&lt;code>var i = 0&lt;/code>，即初始化一个变量&lt;code>i&lt;/code>；测试表达式是&lt;code>i &amp;lt; x&lt;/code>，即只要&lt;code>i&lt;/code>小于&lt;code>x&lt;/code>，就会执行循环；递增表达式是&lt;code>i++&lt;/code>，即每次循环结束后，&lt;code>i&lt;/code>增大 1。&lt;/p>
&lt;p>所有&lt;code>for&lt;/code>循环，都可以改写成&lt;code>while&lt;/code>循环。上面的例子改为&lt;code>while&lt;/code>循环，代码如下。&lt;/p>
&lt;pre>&lt;code>var x = 3;
var i = 0;
while (i &amp;lt; x) {
console.log(i);
i++;
}
&lt;/code>&lt;/pre>
&lt;p>&lt;code>for&lt;/code>语句的三个部分（initialize、test、increment），可以省略任何一个，也可以全部省略。&lt;/p>
&lt;pre>&lt;code>for ( ; ; ){
console.log('Hello World');
}
&lt;/code>&lt;/pre>
&lt;p>上面代码省略了&lt;code>for&lt;/code>语句表达式的三个部分，结果就导致了一个无限循环。&lt;/p>
&lt;h3 id="dowhile-循环-dowhile-e5beaae78eaf">do&amp;hellip;while 循环 &lt;a href="#dowhile-%E5%BE%AA%E7%8E%AF">#&lt;/a>&lt;/h3>
&lt;p>&lt;code>do...while&lt;/code>循环与&lt;code>while&lt;/code>循环类似，唯一的区别就是先运行一次循环体，然后判断循环条件。&lt;/p>
&lt;pre>&lt;code>do
语句
while (条件);
do {
语句
} while (条件);
&lt;/code>&lt;/pre>
&lt;p>不管条件是否为真，&lt;code>do...while&lt;/code>循环至少运行一次，这是这种结构最大的特点。另外，&lt;code>while&lt;/code>语句后面的分号注意不要省略。&lt;/p>
&lt;p>下面是一个例子。&lt;/p>
&lt;pre>&lt;code>var x = 3;
var i = 0;
do {
console.log(i);
i++;
} while(i &amp;lt; x);
&lt;/code>&lt;/pre>
&lt;h3 id="break-语句和-continue-语句-break-e8afade58fa5e5928c-continue-e8afade58fa5">break 语句和 continue 语句 &lt;a href="#break-%E8%AF%AD%E5%8F%A5%E5%92%8C-continue-%E8%AF%AD%E5%8F%A5">#&lt;/a>&lt;/h3>
&lt;p>&lt;code>break&lt;/code>语句和&lt;code>continue&lt;/code>语句都具有跳转作用，可以让代码不按既有的顺序执行。&lt;/p>
&lt;p>&lt;code>break&lt;/code>语句用于跳出代码块或循环。&lt;/p>
&lt;pre>&lt;code>var i = 0;
while(i &amp;lt; 100) {
console.log('i 当前为：' + i);
i++;
if (i === 10) break;
}
&lt;/code>&lt;/pre>
&lt;p>上面代码只会执行 10 次循环，一旦&lt;code>i&lt;/code>等于 10，就会跳出循环。&lt;/p>
&lt;p>&lt;code>for&lt;/code>循环也可以使用&lt;code>break&lt;/code>语句跳出循环。&lt;/p>
&lt;pre>&lt;code>for (var i = 0; i &amp;lt; 5; i++) {
console.log(i);
if (i === 3)
break;
}
&lt;/code>&lt;/pre>
&lt;p>上面代码执行到&lt;code>i&lt;/code>等于 3，就会跳出循环。&lt;/p>
&lt;p>&lt;code>continue&lt;/code>语句用于立即终止本轮循环，返回循环结构的头部，开始下一轮循环。&lt;/p>
&lt;pre>&lt;code>var i = 0;
while (i &amp;lt; 100){
i++;
if (i % 2 === 0) continue;
console.log('i 当前为：' + i);
}
&lt;/code>&lt;/pre>
&lt;p>上面代码只有在&lt;code>i&lt;/code>为奇数时，才会输出&lt;code>i&lt;/code>的值。如果&lt;code>i&lt;/code>为偶数，则直接进入下一轮循环。&lt;/p>
&lt;p>如果存在多重循环，不带参数的&lt;code>break&lt;/code>语句和&lt;code>continue&lt;/code>语句都只针对最内层循环。&lt;/p>
&lt;h3 id="标签label-e6a087e7adbelabel">标签（label） &lt;a href="#%E6%A0%87%E7%AD%BElabel">#&lt;/a>&lt;/h3>
&lt;p>JavaScript 语言允许，语句的前面有标签（label），相当于定位符，用于跳转到程序的任意位置，标签的格式如下。&lt;/p>
&lt;pre>&lt;code>label:
语句
&lt;/code>&lt;/pre>
&lt;p>标签可以是任意的标识符，但不能是保留字，语句部分可以是任意语句。&lt;/p>
&lt;p>标签通常与&lt;code>break&lt;/code>语句和&lt;code>continue&lt;/code>语句配合使用，跳出特定的循环。&lt;/p>
&lt;pre>&lt;code>top:
for (var i = 0; i &amp;lt; 3; i++){
for (var j = 0; j &amp;lt; 3; j++){
if (i === 1 &amp;amp;&amp;amp; j === 1) break top;
console.log('i=' + i + ', j=' + j);
}
}
&lt;/code>&lt;/pre>
&lt;p>上面代码为一个双重循环区块，&lt;code>break&lt;/code>命令后面加上了&lt;code>top&lt;/code>标签（注意，&lt;code>top&lt;/code>不用加引号），满足条件时，直接跳出双层循环。如果&lt;code>break&lt;/code>语句后面不使用标签，则只能跳出内层循环，进入下一次的外层循环。&lt;/p>
&lt;p>标签也可以用于跳出代码块。&lt;/p>
&lt;pre>&lt;code>foo: {
console.log(1);
break foo;
console.log('本行不会输出');
}
console.log(2);
&lt;/code>&lt;/pre>
&lt;p>上面代码执行到&lt;code>break foo&lt;/code>，就会跳出区块。&lt;/p>
&lt;p>&lt;code>continue&lt;/code>语句也可以与标签配合使用。&lt;/p>
&lt;pre>&lt;code>top:
for (var i = 0; i &amp;lt; 3; i++){
for (var j = 0; j &amp;lt; 3; j++){
if (i === 1 &amp;amp;&amp;amp; j === 1) continue top;
console.log('i=' + i + ', j=' + j);
}
}
&lt;/code>&lt;/pre>
&lt;p>上面代码中，&lt;code>continue&lt;/code>命令后面有一个标签名，满足条件时，会跳过当前循环，直接进入下一轮外层循环。如果&lt;code>continue&lt;/code>语句后面不使用标签，则只能进入下一轮的内层循环。&lt;/p>
&lt;h2 id="参考链接-e58f82e88083e993bee68ea5">参考链接 &lt;a href="#%E5%8F%82%E8%80%83%E9%93%BE%E6%8E%A5">#&lt;/a>&lt;/h2>
&lt;ul>
&lt;li>Axel Rauschmayer, &lt;a href="http://www.2ality.com/2011/10/javascript-overview.html">A quick overview of JavaScript&lt;/a>&lt;/li>
&lt;/ul></description></item><item><title>Docs: ECMAScript 第三方库</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/2.%E7%BC%96%E7%A8%8B/%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/ecmascript/ecmascript-%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/2.%E7%BC%96%E7%A8%8B/%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/ecmascript/ecmascript-%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/</guid><description>
&lt;h1 id="postman">Postman&lt;/h1>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-javascript" data-lang="javascript">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 将响应体解析为 JSON 格式
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#a6e22e">respBodyJSON&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#a6e22e">JSON&lt;/span>.&lt;span style="color:#a6e22e">parse&lt;/span>(&lt;span style="color:#a6e22e">responseBody&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">respBodyJSON&lt;/span>.&lt;span style="color:#a6e22e">data&lt;/span>.&lt;span style="color:#a6e22e">forEach&lt;/span>(&lt;span style="color:#66d9ef">function&lt;/span> (&lt;span style="color:#a6e22e">item&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">console&lt;/span>.&lt;span style="color:#a6e22e">log&lt;/span>(&lt;span style="color:#a6e22e">item&lt;/span>.&lt;span style="color:#a6e22e">title&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>})
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h1 id="axios">Axios&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://github.com/axios/axios">GitHub 项目，axios/axios&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://axios-http.com/">官网&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>Axios 是用于浏览器和 node.js 的基于 Promise 的 HTTP 客户端&lt;/p>
&lt;h1 id="element-plus">Element Plus&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://github.com/element-plus/element-plus">GitHub 项目，element-plus/element-plus&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://element-plus.org/">官网&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>Element Plus 是一个基于 Vue3 的 UI 框架。它是 Element UI 基于 Vue3 的重构版本。&lt;/p></description></item><item><title>Docs: ECMAScript 工具</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/2.%E7%BC%96%E7%A8%8B/%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/ecmascript/ecmascript-%E5%B7%A5%E5%85%B7/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/2.%E7%BC%96%E7%A8%8B/%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/ecmascript/ecmascript-%E5%B7%A5%E5%85%B7/</guid><description>
&lt;h1 id="概述">概述&lt;/h1></description></item><item><title>Docs: ECMAScript 工具</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/2.%E7%BC%96%E7%A8%8B/%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/ecmascript/ecmascript-%E5%B7%A5%E5%85%B7/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/2.%E7%BC%96%E7%A8%8B/%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/ecmascript/ecmascript-%E5%B7%A5%E5%85%B7/</guid><description/></item><item><title>Docs: ECMAScript 环境安装与使用</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/2.%E7%BC%96%E7%A8%8B/%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/ecmascript/ecmascript-%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/2.%E7%BC%96%E7%A8%8B/%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/ecmascript/ecmascript-%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;h2 id="参考">参考：&lt;/h2>
&lt;/blockquote>
&lt;p>有两种运行时环境可以运行 ECMAScript 代码(Javascript、Typescript)&lt;/p>
&lt;ul>
&lt;li>**Browser **# 浏览器就是 ECMAScript 的运行时环境。&lt;/li>
&lt;li>&lt;strong>Node.js&lt;/strong> # 在服务器或 PC 上安装 Node.js 环境以运行 ECMAScript 代码&lt;/li>
&lt;li>&lt;strong>Deno&lt;/strong> # &lt;a href="https://github.com/denoland/deno">GtiHub 项目，denoland/deno&lt;/a>。据说要替代 Node.js，很尴尬的是。。。早期 18 年的 issue 中被各种国人无意义灌水&lt;/li>
&lt;li>&lt;strong>Bun&lt;/strong> # &lt;a href="https://github.com/oven-sh/bun">GtiHub 项目，oven-sh/bun&lt;/a>&lt;/li>
&lt;/ul>
&lt;p>但是这两者可以提供的 API 能力各不相同&lt;/p>
&lt;ul>
&lt;li>Browser 可以提供的 dockument、window 和其他关于 DOM 或其他 Web 平台 API 的对象。&lt;/li>
&lt;li>Node.js 则可以提供很多操作系统相关的 API，比如文件的读写、进程管理、网络通信等等。&lt;/li>
&lt;/ul>
&lt;p>Node.js 与 Browser 都是基于 Chrome V8 引擎的 ECMAScript 运行时环境&lt;/p>
&lt;p>你也许会想，直接在我的硬盘上创建好 HTML 和 JavaScript 文件，然后用浏览器打开，不就可以看到效果了吗？&lt;/p>
&lt;p>这种方式运行部分 JavaScript 代码没有问题，但由于浏览器的安全限制，以 file:// 开头的地址无法执行如联网等 JavaScript 代码，最终，你还是需要架设一个 Web 服务器，然后以 http:// 开头的地址来正常执行所有 JavaScript 代码。&lt;/p>
&lt;p>所以，想要运行 JavaScript 编写的静态文件，通常都需要一个可以提供 HTTP 服务的程序，以便响应客户端的请求返回这些静态文件。通常在生产环境中，我们都会将静态资源文件放到 Nginx 的目录中，由 Nginx 为客户端提供 HTTP 服务。&lt;/p>
&lt;p>而本地测试时，我们通过 npm 与 yarn 工具即可安装一个简易的 HTTP 服务，这个 HTTP 服务都是由 JS 代码写的，必须要保证本地有 Node.js 环境，即可启动一个 HTTP 服务&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># Npm 安装 http-server&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>~&lt;span style="color:#f92672">]&lt;/span>&lt;span style="color:#75715e"># npm install http-server&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># Yarn 安装 http-server&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>~&lt;span style="color:#f92672">]&lt;/span>&lt;span style="color:#75715e"># yarn add http-server&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>http-server 来源于 &lt;a href="https://github.com/http-party/http-server">GitHub 项目，http-party/http-server&lt;/a>&lt;/p>
&lt;p>通过 &lt;code>npm exec serve&lt;/code> 命令将会安装另一个名为 serve 的库以运行 HTTP 服务，默认在 3000 端口上启动 HTTP 服务，通过浏览器访问 localhost:3000 即可获取到所有自己编写的静态文件，便于让开发人员在本地调试。&lt;/p>
&lt;h2 id="重点运行具有-module模块-功能的静态资源">(重点)运行具有 Module(模块) 功能的静态资源&lt;/h2>
&lt;p>从《ECMAScript 模块》章节可以看到，当我们使用 &lt;code>import name from './one.js'&lt;/code> 导入的模块是一个文件时，那么这个文件将会被响应给浏览器，如果使用 &lt;code>import name from 'one'&lt;/code> 导入的模块是一组文件时，此时浏览器无法直接识别，将会产生报错。因为浏览器想要执行这一组文件需要发起很多次的请求将所有文件都加载到本地，这其中的路由路径将是不可控的。&lt;/p>
&lt;p>所以，此时我们则需要想办法将这一组文件变为一个文件响应给浏览器以便加载代码。这个转换的操作，我们可以使用打包工具(i.e.Webpack、Vite 等等) 将源代码&lt;strong>打包编译&lt;/strong>成新的静态文件即可。&lt;/p>
&lt;p>后面的逻辑，与基本运行 ECMAScript 代码的行为就是一样的了。&lt;/p>
&lt;h2 id="使用-vite-运行-ecmascript-代码">使用 Vite 运行 ECMAScript 代码&lt;/h2>
&lt;p>npm、yarn 的打包后运行代码的速度非常缓慢，才是推荐使用 Vite 工具启动 HTTP 服务并运行 JS/TS 代码，详见：[《Vite》](✏IT 学习笔记/👨‍💻2.编程/高级编程语言/ECMAScript/ECMAScript%20 工具/Vite.md 工具/Vite.md) 章节&lt;/p>
&lt;h2 id="运行-typesript">运行 TypeSript&lt;/h2>
&lt;p>Node.js 和 浏览器都无法直接运行 TypeScript 代码，这是因为 TS 的代码需要先转换为 JS 代码才可以运行。此时就需要一种工具，先转换再运行，或者直接转换运行一体。&lt;/p>
&lt;ul>
&lt;li>&lt;strong>tsc&lt;/strong> # 将 TS 代码转换为 JS 代码。&lt;code>npm install -g typescript&lt;/code>&lt;/li>
&lt;li>&lt;strong>ts-node&lt;/strong> # 可以直接转换并运行 TS 代码，&lt;code>npm install -g ts-node&lt;/code> 安装即可&lt;/li>
&lt;/ul>
&lt;h1 id="nodejs">NodeJS&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://nodejs.org/en/">org 官网&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://nodejs.dev/">dev 官网&lt;/a>&lt;/li>
&lt;li>&lt;a href="http://nodejs.cn/">dev 官网中文翻译&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Node.js">Wiki,Node.js&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>Node.js 是基于 Chrome V8 引擎的 ECMAScript 运行时环境，由 RyanDahl 于 2009 年 5 月 27 日发布。转年(i.e.2010 年 1 月)，为 Node.js 环境引入了一个名为 npm 的包管理器。包管理器使程序员更容易发布和共享 Node.js 的源代码，旨在简化包的安装、更新、卸载。&lt;/p>
&lt;p>Browser 和 Node.js 都是 ECMAScript 的运行时环境，但是这两者可以提供的 API 能力各不相同&lt;/p>
&lt;ul>
&lt;li>Browser 可以提供的 dockument、window 和其他关于 DOM 或其他 Web 平台 API 的对象。&lt;/li>
&lt;li>Node.js 则可以提供很多操作系统相关的 API，比如文件的读写、进程管理、网络通信等等。&lt;/li>
&lt;/ul>
&lt;p>通过 Node.js，可以让我们使用一种语言编写前端与后端。我们甚至可以通过 npm 与 yarn 安装第三方库后，使用 Node.js 在本地监听端口并响应给客户端静态资源文件。&lt;/p>
&lt;h2 id="安装-nodejs">安装 NodeJS&lt;/h2>
&lt;h3 id="linux">Linux&lt;/h3>
&lt;p>从&lt;a href="https://nodejs.org/zh-cn/download/">官网&lt;/a>下载 Linux 版的 &lt;code>.tar.xg&lt;/code> 包，并解压&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>export NodejsVersion&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;v16.15.0&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>wget https://nodejs.org/dist/&lt;span style="color:#e6db74">${&lt;/span>NodejsVersion&lt;span style="color:#e6db74">}&lt;/span>/node-&lt;span style="color:#e6db74">${&lt;/span>NodejsVersion&lt;span style="color:#e6db74">}&lt;/span>-linux-x64.tar.xz
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>tar -xvf node-&lt;span style="color:#e6db74">${&lt;/span>NodejsVersion&lt;span style="color:#e6db74">}&lt;/span>-linux-x64.tar.xz -C /usr/local/
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>mv /usr/local/node-&lt;span style="color:#e6db74">${&lt;/span>NodejsVersion&lt;span style="color:#e6db74">}&lt;/span>-linux-x64 /usr/local/nodejs
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>配置环境变量&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>sudo tee /etc/profile.d/nodejs.sh &amp;gt; /dev/null &amp;lt;&amp;lt;-&lt;span style="color:#e6db74">&amp;#34;EOF&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>export PATH&lt;span style="color:#f92672">=&lt;/span>$PATH:/usr/local/nodejs/bin
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>EOF
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="windows">Windows&lt;/h3>
&lt;h2 id="nvm">NVM&lt;/h2>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://github.com/nvm-sh/nvm">GitHub 项目，nvm-sh/nvm&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>&lt;strong>Node Version Manager(Node.js 版本管理器，简称 NVM)&lt;/strong>&lt;/p>
&lt;h2 id="nodejs-配置与关联文件">Node.js 配置与关联文件&lt;/h2>
&lt;p>&lt;strong>${PREFIX}/*&lt;/strong> # $PREFIX 指 Node.js 的安装路径，个人通常装在 /usr/local/nodejs 目录下&lt;/p>
&lt;ul>
&lt;li>&lt;strong>./bin/*&lt;/strong> # 第三方模块可用的工具以及 node 二进制文件保存路径
&lt;ul>
&lt;li>这个目录下的第三方模块工具通常都是一个软链接，指向 ${PREFIX}/lib/node_modeuls/XX 目录下的某个目录中文件，具体路径由模块自身定义&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>./lib/node_modules/*&lt;/strong> # 通过 npm、yarn 等包管理器安装&lt;strong>全局&lt;/strong>的第三方依赖包的保存路径。通常 Node.js 默认自带 corepack、npm 这两个包
&lt;ul>
&lt;li>&lt;strong>./corepack/*&lt;/strong> # corepack 工具&lt;/li>
&lt;li>&lt;strong>./npm/*&lt;/strong> # npm 工具&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h1 id="初始化项目">初始化项目&lt;/h1>
&lt;p>由于现阶段都是各种框架学习，所以通过 npm 等包管理工具下载完框架后，会自动生成项目目录，这些目录是已经初始化完成的项目，包含了很多必要的文件，比如 package.json 等。&lt;/p>
&lt;p>随着学习深入，会逐步总结一个前端项目如果不使用框架从头构建的话会需要什么。&lt;/p>
&lt;ul>
&lt;li>&lt;strong>public/&lt;/strong> 目录存放公共资源&lt;/li>
&lt;li>&lt;strong>src/&lt;/strong> # 所有代码都在 src/ 目录下&lt;/li>
&lt;li>&lt;strong>.eslintrc.cjs&lt;/strong> # ESLint 程序配置&lt;/li>
&lt;li>&lt;strong>.prettierc.json&lt;/strong> # Prettier 插件的配置&lt;/li>
&lt;li>&lt;strong>env.d.ts&lt;/strong> #&lt;/li>
&lt;li>&lt;strong>index.html&lt;/strong> # 程序入口&lt;/li>
&lt;li>[&lt;strong>package.json&lt;/strong>](✏IT 学习笔记/👨‍💻2.编程/高级编程语言/ECMAScript/ECMAScript%20 环境安装与使用/package.json.md 环境安装与使用/package.json.md) # 包管理器配置文件，比如 npm、pnpm 等&lt;/li>
&lt;li>&lt;strong>vite.config.ts&lt;/strong> # Vite 程序给项目打包时使用的配置&lt;/li>
&lt;li>&lt;strong>tsconfig.json&lt;/strong> #&lt;/li>
&lt;li>&lt;strong>tsconfig.config.json&lt;/strong> # [TSConfig](✏IT 学习笔记/👨‍💻2.编程/高级编程语言/ECMAScript/ECMAScript%20 环境安装与使用/TSConfig.md 环境安装与使用/TSConfig.md) 文件&lt;/li>
&lt;/ul>
&lt;h2 id="javascript-项目初始化">JavaScript 项目初始化&lt;/h2>
&lt;p>无&lt;/p>
&lt;h2 id="typescript-项目初始化">TypeScript 项目初始化&lt;/h2>
&lt;p>使用 &lt;code>npm install -g typescript&lt;/code> 安装 tsc 命令。&lt;/p>
&lt;p>使用 &lt;code>tsc init&lt;/code> 命令将会生成 [TSConfig](✏IT 学习笔记/👨‍💻2.编程/高级编程语言/ECMAScript/ECMAScript%20 环境安装与使用/TSConfig.md 环境安装与使用/TSConfig.md) 文件。&lt;/p>
&lt;h1 id="编译与打包">编译与打包&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://github.com/webpack/webpack">GitHub 项目，webpack/webpack&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://github.com/rollup/rollup">GitHub 项目，rollup/rollup&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>大型项目通常都要打包，打包工具有很多：&lt;/p>
&lt;ul>
&lt;li>Webpack&lt;/li>
&lt;li>Rollup&lt;/li>
&lt;li>Vite&lt;/li>
&lt;li>&amp;hellip;&amp;hellip;等等&lt;/li>
&lt;/ul>
&lt;h1 id="常见问题">常见问题&lt;/h1>
&lt;h2 id="nodejs-无法使用-es6-语法问题">Node.js 无法使用 ES6 语法问题&lt;/h2>
&lt;p>无法使用 import 关键字导入模块。参考 &lt;a href="https://nodejs.org/docs/latest-v16.x/api/esm.html#enabling">https://nodejs.org/docs/latest-v16.x/api/esm.html#enabling&lt;/a>，在 package.json 文件中设置 &lt;code>&amp;quot;type&amp;quot;: &amp;quot;module&amp;quot;&lt;/code> 或者使用 &lt;code>--input-type=module&lt;/code> 命令行参数以告诉 Node.js 使用 ECMAScript 模块加载器。默认情况下，Node.js 使用 CommonJS 模块加载器。&lt;/p></description></item><item><title>Docs: ECMAScript 环境安装与使用</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/2.%E7%BC%96%E7%A8%8B/%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/ecmascript/ecmascript-%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/2.%E7%BC%96%E7%A8%8B/%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/ecmascript/ecmascript-%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8/</guid><description/></item><item><title>Docs: JavaScript 标准库</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/2.%E7%BC%96%E7%A8%8B/%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/ecmascript/javascript-%E6%A0%87%E5%87%86%E5%BA%93/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/2.%E7%BC%96%E7%A8%8B/%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/ecmascript/javascript-%E6%A0%87%E5%87%86%E5%BA%93/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://github.com/DesistDaydream/javascript-learning">GitHub,DesistDaydream/javascript-learning&lt;/a>(个人学习代码)&lt;/li>
&lt;li>&lt;a href="https://developer.mozilla.org/en-US/docs/Web/API">MDN 官方文档，Web 开发技术-Web APIs&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures">MDN 官方文档，JavaScript-JavaScript 数据类型和数据结构&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects">MDN 官方文档，Javascript 标准内置对象&lt;/a>(所有类型的对象的列表)&lt;/li>
&lt;li>&lt;a href="https://wangdoc.com/javascript/oop/new.html">网道，JavaScript 教程-面向对象编程-实例对象与 new 命令&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.bilibili.com/video/BV1W54y1J7Ed?p=50">https://www.bilibili.com/video/BV1W54y1J7Ed?p=50&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;h1 id="javascript-语言中的数据类型">JavaScript 语言中的数据类型&lt;/h1>
&lt;p>&lt;strong>Primitive Type(原始类型，有的地方也称为基本数据类型)&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>&lt;strong>Number(数值)&lt;/strong> # 十进制数字、科学计数法、其他进程表示方式的数字&lt;/li>
&lt;li>&lt;strong>String(字符串)&lt;/strong> # 单引号或双引号内的一切内容&lt;/li>
&lt;li>&lt;strong>Boolean(布尔)&lt;/strong> # ture 和 false&lt;/li>
&lt;li>&lt;strong>Null(空)&lt;/strong> #
&lt;ul>
&lt;li>Undefined&lt;/li>
&lt;li>Null # Null 类型是 Object，这是由于历史原因造成的。1995 年的 JavaScript 语言第一版，只设计了五种数据类型（对象、整数、浮点数、字符串和布尔值），没考虑 null，只把它当作 object 的一种特殊值。后来 null 独立出来，作为一种单独的数据类型，为了兼容以前的代码，typeof null 返回 object 就没法改变了。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>Complex Type(合成类型，有的地方也称为引用数据类型)&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>&lt;strong>object(对象)&lt;/strong> # 各种值组成的集合，也就是下文提到的 &lt;a href="#p3TIB">标准内置对象&lt;/a>。在很多场景下，第一个 O 是小写的。
&lt;ul>
&lt;li>Object 又划分为很多子类型：
&lt;ul>
&lt;li>&lt;strong>Ojbect(对象)&lt;/strong> # 与 字典、映射 等同义的那个对象。&lt;/li>
&lt;li>&lt;strong>Array(数组)&lt;/strong> #&lt;/li>
&lt;li>&lt;strong>Functiom(函数)&lt;/strong> # JavaScript 中将 Function 当做一种类型来处理&lt;/li>
&lt;li>&lt;strong>其他&lt;/strong> #&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>通常我们这么描述： Object 类型的 object、Array 类型的 object、String 类型的 object、等等。简化一点就是 Object 对象、Array 对象、String 对象、等等。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h2 id="数据类型检测">数据类型检测&lt;/h2>
&lt;h1 id="object对象">object(对象)&lt;/h1>
&lt;p>&lt;strong>object(对象)&lt;/strong> 是 Javascript 语言的核心概念。所有的数据类型都可以称之为 object。&lt;/p>
&lt;blockquote>
&lt;p>注意：Javascript 还有一个 Object 类型的的数据也可以称为 object&lt;del>&lt;del>挺绕的&lt;/del>0.0。我们通常使用 Object 的 O 字母大小写来区分&lt;/del>~~~&lt;/p>
&lt;ul>
&lt;li>Object 是一种狭义的数据类型，与 字典、映射 等同义&lt;/li>
&lt;li>object 是
&lt;ul>
&lt;li>包含数据和用于处理数据的指令的数据结构。&lt;/li>
&lt;li>一种合成类型，一种在 JS 中最复杂的数据类型。&lt;/li>
&lt;li>一种将任意数据类型构建为 object 类型的方法&lt;/li>
&lt;li>也是一个逻辑上的对象，通过特定方法实例化的类型都可以称为对象。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-javascript" data-lang="javascript">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">var&lt;/span> &lt;span style="color:#a6e22e">objectType&lt;/span> &lt;span style="color:#f92672">=&lt;/span> {}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">console&lt;/span>.&lt;span style="color:#a6e22e">log&lt;/span>(&lt;span style="color:#a6e22e">objectType&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">console&lt;/span>.&lt;span style="color:#a6e22e">log&lt;/span>(&lt;span style="color:#66d9ef">typeof&lt;/span> &lt;span style="color:#a6e22e">objectType&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">var&lt;/span> &lt;span style="color:#a6e22e">arrayType&lt;/span> &lt;span style="color:#f92672">=&lt;/span> []
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">console&lt;/span>.&lt;span style="color:#a6e22e">log&lt;/span>(&lt;span style="color:#a6e22e">arrayType&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">console&lt;/span>.&lt;span style="color:#a6e22e">log&lt;/span>(&lt;span style="color:#66d9ef">typeof&lt;/span> &lt;span style="color:#a6e22e">arrayType&lt;/span>)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>上面代码的输出结果如果从浏览器看的话，效果如下图：
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/th2szn/1641957269181-cffe1052-765a-403f-b3af-7ff732eceb78.png" alt="image.png">
可以看到，object 是一种类型，而 Array 和 Object 类型都属于 object 类型的原型类；也就是 Array 类型的 object、Object 类型的 object。&lt;/p>
&lt;h2 id="constructor构造函数">Constructor(构造函数)&lt;/h2>
&lt;p>面向对象编程的第一步，就是要生成对象。对象是单个实物的抽象。通常需要一个模板，表示某一类实物的共同特征，然后对象根据这个模板生成。&lt;/p>
&lt;p>典型的面向对象编程语言（比如 C++ 和 Java），都有“类”（class）这个概念。所谓“类”就是对象的模板，对象就是“类”的实例。但是，JavaScript 语言的对象体系，不是基于“类”的，而是基于 &lt;strong>Constructor(构造函数)&lt;/strong> 和 &lt;strong>Prototype(原型类)&lt;/strong>。&lt;/p>
&lt;p>JavaScript 语言使用 &lt;strong>Constructor(构造函数)&lt;/strong> 作为&lt;strong>对象的模板&lt;/strong>。所谓“构造函数”，就是用来描述对象的基本结构。通过一个构造函数，可以生成多个实例对象，这些实例对象都有相同的结构。而 &lt;strong>Prototype(原型类)&lt;/strong> 则是这个对象中的一个属性，用来标明该对象实例原始的类型，以便可以调用这个类型对象下的方法。&lt;/p>
&lt;p>构造函数的特点有两个：&lt;/p>
&lt;ul>
&lt;li>函数体内部使用了 &lt;code>this&lt;/code> 关键字，代表了所要生成的对象实例。&lt;/li>
&lt;li>生成对象的时候，必须使用 &lt;code>new&lt;/code> 关键字。
&lt;ul>
&lt;li>想要生成什么类型的对象，就使用对应的 Constructor，通常来说，Constructor 的名称与类型名称相同，只不过首字母大写。比如：
&lt;ul>
&lt;li>我要构造一个 String 类型的 object，则使用 &lt;code>String()&lt;/code> 函数。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>构造函数也是一个普通的函数，只不过具有某些特有的特征和用法：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-javascript" data-lang="javascript">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">function&lt;/span> &lt;span style="color:#a6e22e">Person&lt;/span>(&lt;span style="color:#a6e22e">name&lt;/span>, &lt;span style="color:#a6e22e">age&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 若没有 this 关键字，则这俩不会变为 Person 的属性，仅仅只是一个赋值操作
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">name&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#a6e22e">name&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">age&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#a6e22e">age&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">Person&lt;/span>.&lt;span style="color:#a6e22e">prototype&lt;/span>.&lt;span style="color:#a6e22e">showInfo&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">function&lt;/span> () {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">name&lt;/span> &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#e6db74">&amp;#34; is &amp;#34;&lt;/span> &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">age&lt;/span> &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#e6db74">&amp;#34; years old.&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">var&lt;/span> &lt;span style="color:#a6e22e">p1&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> &lt;span style="color:#a6e22e">Person&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;张三&amp;#34;&lt;/span>, &lt;span style="color:#ae81ff">18&lt;/span>)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ul>
&lt;li>&lt;code>Point()&lt;/code> 是构造函数，第一个字母通常都是大写的，且内部使用 &lt;code>this&lt;/code> 关键字&lt;/li>
&lt;li>&lt;code>price&lt;/code> 是构造函数的一个属性。&lt;/li>
&lt;/ul>
&lt;p>然后，我们可以通过 &lt;code>new&lt;/code> 关键字生成 &lt;code>Point()&lt;/code> 的一个实例。&lt;/p>
&lt;p>如果用面向对象的概念来类比的话：&lt;/p>
&lt;ul>
&lt;li>Point 是一个对象&lt;/li>
&lt;li>x 和 y 是对象中的一个属性&lt;/li>
&lt;li>p 是对象在实例化后的实体&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/th2szn/1650787512457-aee108cf-2ec9-488a-82ac-363293db2764.png" alt="image.png">
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/th2szn/1650789606739-0e7d0eb8-f5ef-4151-ba29-d6402090becf.png" alt="image.png">&lt;/p>
&lt;h3 id="es6-语法">ES6 语法&lt;/h3>
&lt;p>上面这种写法跟传统的面向对象语言（比如 C++ 和 Java）差异很大，很容易让新学习这门语言的程序员感到困惑。
ES6 提供了更接近传统语言的写法，引入了 Class（类）这个概念，作为对象的模板。通过 class 关键字，可以定义类。&lt;/p>
&lt;p>基本上，ES6 的 class 可以看作只是一个语法糖，它的绝大部分功能，ES5 都可以做到，新的 class 写法只是让对象原型的写法更加清晰、更像面向对象编程的语法而已。上面的代码用 ES6 的 class 改写，就是下面这样：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-javascript" data-lang="javascript">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">Person&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">constructor&lt;/span>(&lt;span style="color:#a6e22e">name&lt;/span>, &lt;span style="color:#a6e22e">age&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">name&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#a6e22e">name&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">age&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#a6e22e">age&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">showInfo&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">name&lt;/span> &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#e6db74">&amp;#34; is &amp;#34;&lt;/span> &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">age&lt;/span> &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#e6db74">&amp;#34; years old.&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">var&lt;/span> &lt;span style="color:#a6e22e">p1&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> &lt;span style="color:#a6e22e">Person&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;张三&amp;#34;&lt;/span>, &lt;span style="color:#ae81ff">18&lt;/span>)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="prototype原型">Prototype(原型)&lt;/h3>
&lt;p>每一个构造函数都会自带一个 prototype 属性。为了解决实例化时，对象上的方法被重复创建占用过多内存空间的问题。所以，想要定义对象上的方法，就是使用 &lt;code>OjbectName.pototype.MethodName&lt;/code> 语法。&lt;/p>
&lt;h3 id="内置构造函数示例">内置构造函数示例&lt;/h3>
&lt;p>用一个最简单的声明字符串变量为例：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-javascript" data-lang="javascript">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 基本字符串
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">var&lt;/span> &lt;span style="color:#a6e22e">stringType&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#34;Hello_World&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 字符串对象
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">var&lt;/span> &lt;span style="color:#a6e22e">stringObjType&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> String(&lt;span style="color:#e6db74">&amp;#34;Hello_World&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">console&lt;/span>.&lt;span style="color:#a6e22e">log&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;基本字符串的类型:&amp;#34;&lt;/span>, &lt;span style="color:#66d9ef">typeof&lt;/span> &lt;span style="color:#a6e22e">stringType&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">console&lt;/span>.&lt;span style="color:#a6e22e">log&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;字符串对象的类型:&amp;#34;&lt;/span>, &lt;span style="color:#66d9ef">typeof&lt;/span> &lt;span style="color:#a6e22e">stringObjType&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">console&lt;/span>.&lt;span style="color:#a6e22e">log&lt;/span>(&lt;span style="color:#a6e22e">stringType&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">console&lt;/span>.&lt;span style="color:#a6e22e">log&lt;/span>(&lt;span style="color:#a6e22e">stringObjType&lt;/span>)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>这里的 &lt;code>String()&lt;/code> 是一个构造函数&lt;/p>
&lt;p>执行结果如下：
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/th2szn/1640327798825-cba5f4ac-6cb9-4ed2-9c17-62a10d4fd2b2.png" alt="image.png">
使用 &lt;code>new&lt;/code> 构造函数后，一个普通的字符串成为了 object 类型，并且 &lt;strong>Prototype(原型类)&lt;/strong> 是 String。&lt;/p>
&lt;ul>
&lt;li>字符串字面量 (通过单引号或双引号定义) 是&lt;strong>基本字符串&lt;/strong>。&lt;/li>
&lt;li>通过 &lt;code>new&lt;/code> 构造出来的是&lt;strong>字符串对象&lt;/strong>。&lt;/li>
&lt;/ul>
&lt;p>注意：当基本字符串需要调用一个字符串对象才有的方法或者查询值的时候(基本字符串是没有这些方法的)，&lt;strong>JavaScript 会自动将基本字符串转化为字符串对象&lt;/strong>并且调用相应的方法或者执行查询。&lt;/p>
&lt;h2 id="内置对象的方法">内置对象的方法&lt;/h2>
&lt;p>Javascript 中，提供了很多方法可以对数据直接进行操作(比如 类型转换、数组排序、遍历 等等)。在 &lt;a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects">MDN 官方文档，Javascript 标准内置对象&lt;/a> 中可以查看所有 Javascript 中内置的操作，这里是以对象类型进行分类，每个类型的对象都有很多可以操作其自身的方法。&lt;/p>
&lt;blockquote>
&lt;p>[这里](✏IT 学习笔记/👨‍💻2.编程/高级编程语言/ECMAScript/JavaScript%20 标准库/各种类型的%20object(对象)%20 的常见方法.md 标准库/各种类型的 object(对象) 的常见方法.md)也列出了一些日常使用率非常高的对象方法&lt;/p>
&lt;/blockquote>
&lt;p>这种行为本质就是调用对象上的方法，与其他语言是类似的效果，我们使用 &lt;code>new&lt;/code> 关键字与构造函数创建出 A 类型的实例化对象(其实就是一个变量)，这个变量是 A 数据类型，然后就可以直接调用 A 数据类型下所有可用的方法。&lt;/p>
&lt;p>比如：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-javascript" data-lang="javascript">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">const&lt;/span> &lt;span style="color:#a6e22e">arrayObject&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> Array(&lt;span style="color:#ae81ff">9&lt;/span>, &lt;span style="color:#ae81ff">6&lt;/span>, &lt;span style="color:#ae81ff">3&lt;/span>, &lt;span style="color:#ae81ff">1&lt;/span>, &lt;span style="color:#ae81ff">2&lt;/span>, &lt;span style="color:#ae81ff">4&lt;/span>, &lt;span style="color:#ae81ff">5&lt;/span>, &lt;span style="color:#ae81ff">7&lt;/span>, &lt;span style="color:#ae81ff">8&lt;/span>, &lt;span style="color:#ae81ff">0&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">arrayObject&lt;/span>.&lt;span style="color:#a6e22e">sort&lt;/span>()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">console&lt;/span>.&lt;span style="color:#a6e22e">log&lt;/span>(&lt;span style="color:#a6e22e">arrayObject&lt;/span>)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>我实例化了一个 Array 类型的对象：arrayObject，此时可以直接调用该类型下的方法 &lt;code>sort()&lt;/code> 对数据进行排序&lt;/p>
&lt;h2 id="原型链">原型链&lt;/h2>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/th2szn/1650791286870-fafece55-15db-47be-ae76-3d5f80ea30de.png" alt="image.png">
原型链是用 &lt;strong>proto&lt;/strong> 串联起来的对象链状结构，该结构用来在访问对象的成员的时候，提供访问路径。&lt;/p>
&lt;p>对方访问机制：&lt;/p>
&lt;ul>
&lt;li>首先在自己身上查找，如果有直接使用&lt;/li>
&lt;li>如果没有，自动去 &lt;strong>proto&lt;/strong> 上查找&lt;/li>
&lt;li>如果还没有，就再去 &lt;strong>proto&lt;/strong> 上查找&lt;/li>
&lt;li>直到 Ojbect.prototype 都没有，那么返回 undefiend&lt;/li>
&lt;/ul>
&lt;h2 id="总结">总结&lt;/h2>
&lt;p>其实，Javascript 的 object 可以简单理解为面向对象编程中的对象，通过构建各种类型的对象，以便使用对象上的方法。&lt;/p></description></item><item><title>Docs: JavaScript 标准库</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/2.%E7%BC%96%E7%A8%8B/%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/ecmascript/javascript-%E6%A0%87%E5%87%86%E5%BA%93/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/2.%E7%BC%96%E7%A8%8B/%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/ecmascript/javascript-%E6%A0%87%E5%87%86%E5%BA%93/</guid><description/></item><item><title>Docs: TypeScript 标准库</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/2.%E7%BC%96%E7%A8%8B/%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/ecmascript/typescript-%E6%A0%87%E5%87%86%E5%BA%93/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/2.%E7%BC%96%E7%A8%8B/%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/ecmascript/typescript-%E6%A0%87%E5%87%86%E5%BA%93/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;h1 id="数据类型">数据类型&lt;/h1>
&lt;p>&lt;a href="https://www.runoob.com/typescript/ts-type.html">https://www.runoob.com/typescript/ts-type.html&lt;/a>&lt;/p></description></item><item><title>Docs: TypeScript 标准库</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/2.%E7%BC%96%E7%A8%8B/%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/ecmascript/typescript-%E6%A0%87%E5%87%86%E5%BA%93/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/2.%E7%BC%96%E7%A8%8B/%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/ecmascript/typescript-%E6%A0%87%E5%87%86%E5%BA%93/</guid><description/></item><item><title>Docs: Vue</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/2.%E7%BC%96%E7%A8%8B/%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/ecmascript/vue/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/2.%E7%BC%96%E7%A8%8B/%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/ecmascript/vue/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://github.com/vuejs/">GitHub 组织，vuejs&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://vuejs.org/">官网&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://staging-cn.vuejs.org/">官网-中文&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://cn.vuejs.org/tutorial/">Vue 互动教程&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Vue.js">Wiki,Vue.js&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>Vue 是一套用于构建用户界面的渐进式 ECMAScript 框架。Vue3 于 2020 年 9 月发布，已全面采用 TypeScript 编写；在 2022 年 2 月份成为默认版本&lt;/p>
&lt;h2 id="组件化">组件化&lt;/h2>
&lt;p>Vue 是“组件化”模式，一个页面的各个部分，可以拆分成一个一个的组件：
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/cye267/1651220067462-1822075c-2b85-4cf4-abd8-eebfa658e531.png" alt="image.png">
&lt;strong>Single-File Component(单文件组件，简称 SFC)&lt;/strong>。顾名思义，Vue 的单文件组件会将一个组件的逻辑 (JavaScript)，模板 (HTML) 和样式 (CSS) 封装在同一个文件里。&lt;/p>
&lt;p>&lt;strong>同时，多个组件可以自由组合拼接，形成一个完整的页面。&lt;/strong>&lt;/p>
&lt;p>单文件组件是 Vue 的标志性功能。如果你的用例需要进行构建，我们推荐用它来编写 Vue 组件。你可以在后续相关章节里了解更多关于&lt;a href="https://cn.vuejs.org/guide/scaling-up/sfc.html">单文件组件的用法及用途&lt;/a>。但你暂时只需要知道 Vue 会帮忙处理所有这些构建工具的配置就好。&lt;/p>
&lt;p>这些组件通常被组织在 &lt;strong>XXX.vue&lt;/strong> 文件中，通常保存在项目根目录的 &lt;code>components/&lt;/code> 目录下。&lt;/p>
&lt;p>组件化开发是一个树状结构，从一个“根组件”开始：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>App &lt;span style="color:#f92672">(&lt;/span>root component&lt;span style="color:#f92672">)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>├─ TodoList
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>│ └─ TodoItem
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>│ ├─ TodoDeleteButton
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>│ └─ TodoEditButton
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>└─ TodoFooter
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ├─ TodoClearButton
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> └─ TodoStatistics
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>就像下面这样：
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/cye267/1666837624381-ce56eb28-5092-4e8a-a1c8-de01ed1e1f7f.png" alt="image.png">&lt;/p>
&lt;h2 id="声明式">声明式&lt;/h2>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/cye267/1651220139947-ac46307c-fa52-4370-b7ed-16e2ad92629a.png" alt="image.png">
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/cye267/1666836325564-89bbb0d6-be23-45ea-aa56-bc7183a2eb46.png" alt="image.png">
有了 VUE 就不用手动操作 DOM 了？&lt;/p>
&lt;h2 id="api-风格">API 风格&lt;/h2>
&lt;p>&lt;strong>选项式 API&lt;/strong> 与 **组合式 API。**推荐组合式。&lt;/p>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://www.bilibili.com/video/BV1mK411f7Kt/?p=51">https://www.bilibili.com/video/BV1mK411f7Kt/?p=51&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>选项式：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-typescript" data-lang="typescript">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">export&lt;/span> &lt;span style="color:#66d9ef">default&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">data() {&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">count&lt;/span>: &lt;span style="color:#66d9ef">1&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> },
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// `mounted` 是生命周期钩子，之后我们会讲到
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#a6e22e">mounted() {&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// `this` 指向当前组件实例
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#a6e22e">console&lt;/span>.&lt;span style="color:#a6e22e">log&lt;/span>(&lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">count&lt;/span>) &lt;span style="color:#75715e">// =&amp;gt; 1
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 数据属性也可以被更改
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">count&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">2&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> },
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>组合式：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-typescript" data-lang="typescript">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">import&lt;/span> { &lt;span style="color:#a6e22e">reactive&lt;/span> } &lt;span style="color:#66d9ef">from&lt;/span> &lt;span style="color:#e6db74">&amp;#34;vue&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">export&lt;/span> &lt;span style="color:#66d9ef">default&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// `setup` 是一个专门用于组合式 API 的特殊钩子函数
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#a6e22e">setup() {&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">const&lt;/span> &lt;span style="color:#a6e22e">state&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#a6e22e">reactive&lt;/span>({ &lt;span style="color:#a6e22e">count&lt;/span>: &lt;span style="color:#66d9ef">0&lt;/span> })
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 暴露 state 到模板
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">return&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">state&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> },
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>选项式 API 将需要处理的数据放在 &lt;code>data()&lt;/code> 中 ，关于处理数据的逻辑写在 &lt;code>methods:&lt;/code>、&lt;code>computed:&lt;/code>、&lt;code>watch:&lt;/code> 等等地方，如果数据很多，那么处理数据的逻辑在编辑器中将会非常跳跃，就像下图左侧一样，同样颜色的逻辑，不够集中，那么将会形成非常乱的代码结构。
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/cye267/1667871595181-70833fc5-41d3-48f1-954f-16c912da8749.png" alt="image.png">
所以说，组合式，主要组合的是对于数据处理的逻辑，将处理同一个数据的逻辑组合在一起，以便编写出更易读的代码。&lt;/p>
&lt;h1 id="学习资料">学习资料&lt;/h1>
&lt;p>&lt;a href="https://github.com/vuejs/awesome-vue">GitHub 项目，vuejs/awesome-vue&lt;/a> # 一些常用的第三方库
&lt;a href="https://swiperjs.com/vue">Swiperjs-Vue&lt;/a>&lt;/p>
&lt;h2 id="vue-第三方库">Vue 第三方库&lt;/h2>
&lt;p>&lt;a href="https://github.com/element-plus/element-plus">element plus&lt;/a> # Element 团队制作的 Vue.js 3 UI 库&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://github.com/nmxiaowei/avue">nmxiaowei/avue &lt;/a># 基于现有的 element-ui 库进行的二次封装，简化一些繁琐的操作&lt;/li>
&lt;/ul>
&lt;p>&lt;a href="https://github.com/HC200ok/vue3-easy-data-table/">vue3-easy-data-table&lt;/a> # 数据表组件
&lt;a href="https://github.com/x-extends/vxe-table">x-extends/vxe-table&lt;/a> # vue 表格解决方案
&lt;a href="https://github.com/mirari/v-viewer">mirari/v-viewer&lt;/a> # vue 的图片查看器组件，支持旋转、缩放、缩放等&lt;/p>
&lt;h3 id="小组件">小组件&lt;/h3>
&lt;p>&lt;a href="https://github.com/yanmiao99/vue3-go-crud-project">yanmiao99/vue3-go-crud-project&lt;/a>&lt;/p>
&lt;h3 id="待学习">待学习&lt;/h3>
&lt;p>&lt;a href="https://www.bilibili.com/video/BV1yV4y177jC">B 站，Vue3.2 + Vite + Element-Plus 实现最基础的 CRUD&lt;/a>
&lt;a href="https://www.bilibili.com/video/BV1sP4y127Re">B 站，Vue3 项目实战、Vue3+Element-plus 项目实战系列课程（数据管理平台）&lt;/a>
&lt;a href="https://www.bilibili.com/video/BV1pq4y1c7oy">B 站，Vue3.2 后台管理系统&lt;/a>
&lt;a href="https://www.bilibili.com/video/BV1md4y1C7wS">B 站，一天之内快速搭建 vue 后台管理系统-代码写到起飞,接单接到手软&lt;/a>&lt;/p>
&lt;h2 id="可以学习的项目">可以学习的项目&lt;/h2>
&lt;p>&lt;a href="https://github.com/HalseySpicy/Geeker-Admin">https://github.com/HalseySpicy/Geeker-Admin&lt;/a> # Geeker Admin，基于 Vue3.2、TypeScript、Vite2、Pinia、Element-Plus 开源的一套后台管理框架。
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/cye267/1667712440759-38351016-d3de-4246-96ce-f139fb24099c.png" alt="image.png">
&lt;a href="https://github.com/flipped-aurora/gin-vue-admin">https://github.com/flipped-aurora/gin-vue-admin&lt;/a> # 基于 vite+vue3+gin 搭建的开发基础平台（支持 TS,JS 混用），集成 jwt 鉴权，权限管理，动态路由，显隐可控组件，分页封装，多点登录拦截，资源权限，上传下载，代码生成器，表单生成器等开发必备功能。
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/cye267/1667712396903-5c478114-4b5d-42c8-9caf-e301ac58f2fc.png" alt="image.png">
&lt;a href="https://github.com/go-admin-team/go-admin">https://github.com/go-admin-team/go-admin&lt;/a> # 基于 Gin + Vue + Element UI 的前后端分离权限管理系统脚手架（包含了：多租户的支持，基础用户管理功能，jwt 鉴权，代码生成器，RBAC 资源控制，表单构建，定时任务等）3 分钟构建自己的中后台项目；
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/cye267/1667712379792-273c7485-92f4-46ed-9a98-65e745b1c8df.png" alt="image.png">&lt;/p>
&lt;h1 id="vue-指令">Vue 指令&lt;/h1>
&lt;p>指令是带有 &lt;code>v-&lt;/code> 前缀的特殊 attribute。Vue 提供了许多&lt;a href="https://cn.vuejs.org/api/built-in-directives.html">内置指令&lt;/a>。&lt;/p>
&lt;h1 id="vue-规范">Vue 规范&lt;/h1>
&lt;h2 id="项目结构">项目结构&lt;/h2>
&lt;p>使用 Vite 创建的 Vue 项目&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>.
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>├── README.md
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>├── index.html
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>├── node_modules
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>├── package.json
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>├── pnpm-lock.yaml
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>├── public
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>│ └── favicon.ico
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>├── src
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>│ ├── App.vue
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>│ ├── assets/
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>│ ├── components/
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>│ └── main.js
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>└── vite.config.js
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ul>
&lt;li>&lt;/li>
&lt;li>
&lt;p>public/ 目录存放公共资源&lt;/p>
&lt;/li>
&lt;li>
&lt;p>所有代码都在 src/ 目录下&lt;/p>
&lt;ul>
&lt;li>index.html 指向 main.js，main.js 中创建应用的根组件&lt;/li>
&lt;li>根组件的代码在 App.vue 文件中&lt;/li>
&lt;li>所有根组件下的组件的代码都放在 components/ 目录下&lt;/li>
&lt;li>assets 存放静态资源，图片、css 样式 等等&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>.eslintrc.cjs&lt;/strong> # ESLint 程序配置&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>.prettierc.json&lt;/strong> # Prettier 插件的配置&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>env.d.ts&lt;/strong> #&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>index.html&lt;/strong> # 程序入口&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>package.json&lt;/strong> # 包管理器配置文件，比如 npm、pnpm 等&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>vite.config.ts&lt;/strong> # Vite 程序给项目打包时使用的配置&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>tsconfig.json&lt;/strong> #&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>tsconfig.config.json&lt;/strong> #&lt;/p>
&lt;/li>
&lt;/ul></description></item><item><title>Docs: Vue</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/2.%E7%BC%96%E7%A8%8B/%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/ecmascript/vue/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/2.%E7%BC%96%E7%A8%8B/%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/ecmascript/vue/</guid><description/></item><item><title>Docs: 常用编程技巧</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/2.%E7%BC%96%E7%A8%8B/%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/ecmascript/%E5%B8%B8%E7%94%A8%E7%BC%96%E7%A8%8B%E6%8A%80%E5%B7%A7/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/2.%E7%BC%96%E7%A8%8B/%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/ecmascript/%E5%B8%B8%E7%94%A8%E7%BC%96%E7%A8%8B%E6%8A%80%E5%B7%A7/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://www.bilibili.com/video/BV1dG411j7uW">B 站，【JavaScript】前端超有用的 10 个 JS 工具函数&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;h1 id="防抖与节流">防抖与节流&lt;/h1>
&lt;p>本质上是优化高频率执行代码的一种手段
如：浏览器的 resize、scroll、keypress、mousemove 等事件在触发时，会不断地调用绑定在事件上的回调函数，极大地浪费资源，降低前端性能
为了优化体验，需要对这类事件进行调用次数的限制，对此我们就可以采用 防抖（debounce） 和 节流（throttle） 的方式来减少调用频率&lt;/p>
&lt;h4 id="定义">定义&lt;/h4>
&lt;ul>
&lt;li>节流: n 秒内只运行一次，若在 n 秒内重复触发，只有一次生效&lt;/li>
&lt;li>防抖: n 秒后在执行该事件，若在 n 秒内被重复触发，则重新计时&lt;/li>
&lt;/ul>
&lt;p>一个经典的比喻:
想象每天上班大厦底下的电梯。把电梯完成一次运送，类比为一次函数的执行和响应
假设电梯有两种运行策略 debounce 和 throttle，超时设定为 15 秒，不考虑容量限制
电梯第一个人进来后，15 秒后准时运送一次，这是节流
电梯第一个人进来后，等待 15 秒。如果过程中又有人进来，15 秒等待重新计时，直到 15 秒后开始运送，这是防抖&lt;/p>
&lt;h1 id="大小写转换">大小写转换&lt;/h1>
&lt;h1 id="数组中对象类型的元素去重">数组中对象类型的元素去重&lt;/h1>
&lt;h1 id="校验数据类型">校验数据类型&lt;/h1>
&lt;h1 id="滚动到页面顶部">滚动到页面顶部&lt;/h1>
&lt;h1 id="滚动到对应元素的位置">滚动到对应元素的位置&lt;/h1>
&lt;h1 id="获取当前时间">获取当前时间&lt;/h1>
&lt;h1 id="获取当月的第一天和最后一天">获取当月的第一天和最后一天&lt;/h1>
&lt;h1 id="模糊查询">模糊查询&lt;/h1></description></item><item><title>Docs: 代码格式化</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/2.%E7%BC%96%E7%A8%8B/%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/ecmascript/%E4%BB%A3%E7%A0%81%E6%A0%BC%E5%BC%8F%E5%8C%96/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/2.%E7%BC%96%E7%A8%8B/%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/ecmascript/%E4%BB%A3%E7%A0%81%E6%A0%BC%E5%BC%8F%E5%8C%96/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;/blockquote>
&lt;h1 id="prettier">Prettier&lt;/h1>
&lt;h2 id="关联文件与配置">关联文件与配置&lt;/h2>
&lt;p>&lt;strong>.prettierrc.json&lt;/strong> # 通常保存在项目根目录下&lt;/p>
&lt;h2 id="配置详解">配置详解&lt;/h2>
&lt;p>&lt;strong>tabWidth: &lt;!-- raw HTML omitted -->&lt;/strong> # 一个制表符相当于几个空格
&lt;strong>semi: &lt;!-- raw HTML omitted -->&lt;/strong> # 行尾是否添加分号
&lt;strong>htmlWhitespaceSensitivity: &lt;!-- raw HTML omitted -->&lt;/strong> # 使用 ignore 解决尖括号右侧被换行问题
&lt;strong>bracketSameLine: &lt;!-- raw HTML omitted -->&lt;/strong> # 不要给 &lt;code>&amp;gt;&lt;/code> 另起一行&lt;/p>
&lt;pre>&lt;code>&amp;quot;prettier.printWidth&amp;quot;: 100, // 超过最大值换行
&amp;quot;prettier.tabWidth&amp;quot;: 4, // 缩进字节数
&amp;quot;prettier.useTabs&amp;quot;: false, // 缩进不使用tab，使用空格
&amp;quot;prettier.semi&amp;quot;: true, // 句尾添加分号
&amp;quot;prettier.singleQuote&amp;quot;: true, // 使用单引号代替双引号
&amp;quot;prettier.proseWrap&amp;quot;: &amp;quot;preserve&amp;quot;, // 默认值。因为使用了一些折行敏感型的渲染器（如GitHub comment）而按照markdown文本样式进行折行
&amp;quot;prettier.arrowParens&amp;quot;: &amp;quot;avoid&amp;quot;, //  (x) =&amp;gt; {} 箭头函数参数只有一个时是否要有小括号。avoid：省略括号
&amp;quot;prettier.bracketSpacing&amp;quot;: true, // 在对象，数组括号与文字之间加空格 &amp;quot;{ foo: bar }&amp;quot;
&amp;quot;prettier.disableLanguages&amp;quot;: [&amp;quot;vue&amp;quot;], // 不格式化vue文件，vue文件的格式化单独设置
&amp;quot;prettier.endOfLine&amp;quot;: &amp;quot;auto&amp;quot;, // 结尾是 \n \r \n\r auto
&amp;quot;prettier.eslintIntegration&amp;quot;: false, //不让prettier使用eslint的代码格式进行校验
&amp;quot;prettier.htmlWhitespaceSensitivity&amp;quot;: &amp;quot;ignore&amp;quot;,//包裹文字时候结束标签的结尾尖括号掉到了下一行
&amp;quot;prettier.ignorePath&amp;quot;: &amp;quot;.prettierignore&amp;quot;, // 不使用prettier格式化的文件填写在项目的.prettierignore文件中
&amp;quot;prettier.jsxBracketSameLine&amp;quot;: false, // 在jsx中把'&amp;gt;' 是否单独放一行
&amp;quot;prettier.jsxSingleQuote&amp;quot;: false, // 在jsx中使用单引号代替双引号
&amp;quot;prettier.parser&amp;quot;: &amp;quot;babylon&amp;quot;, // 格式化的解析器，默认是babylon
&amp;quot;prettier.requireConfig&amp;quot;: false, // Require a 'prettierconfig' to format prettier
&amp;quot;prettier.stylelintIntegration&amp;quot;: false, //不让prettier使用stylelint的代码格式进行校验
&amp;quot;prettier.trailingComma&amp;quot;: &amp;quot;es5&amp;quot;, // 在对象或数组最后一个元素后面是否加逗号（在ES5中加尾逗号）
&amp;quot;prettier.tslintIntegration&amp;quot;: false// 不让prettier使用tslint的代码格式进行校验
&lt;/code>&lt;/pre>
&lt;h1 id="eslint">ESLint&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://eslint.bootcss.com/">官网&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote></description></item></channel></rss>