<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>断念梦 – ECMAScript 环境安装与使用</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/2.%E7%BC%96%E7%A8%8B/%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/ecmascript/ecmascript-%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8/</link><description>Recent content in ECMAScript 环境安装与使用 on 断念梦</description><generator>Hugo -- gohugo.io</generator><atom:link href="https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/2.%E7%BC%96%E7%A8%8B/%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/ecmascript/ecmascript-%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8/index.xml" rel="self" type="application/rss+xml"/><item><title>Docs: ECMAScript 包管理器</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/2.%E7%BC%96%E7%A8%8B/%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/ecmascript/ecmascript-%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8/ecmascript-%E5%8C%85%E7%AE%A1%E7%90%86%E5%99%A8/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/2.%E7%BC%96%E7%A8%8B/%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/ecmascript/ecmascript-%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8/ecmascript-%E5%8C%85%E7%AE%A1%E7%90%86%E5%99%A8/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;h2 id="参考">参考：&lt;/h2>
&lt;/blockquote>
&lt;p>当我们使用包管理命令安装各种第三方库(依赖包)及其衍生物通常会保存在两类地方&lt;/p>
&lt;ul>
&lt;li>&lt;strong>Locally(本地)&lt;/strong> # 这是默认的行为，安装的东西放在当前目录的 &lt;code>./node_modules/&lt;/code> 目录中
&lt;ul>
&lt;li>当我们想要在代码中使用 require() 或 import 导入模块时，通常安装在本地&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>Globally(全局)&lt;/strong> # 使用 &lt;code>-g&lt;/code> 选项，将安装的东西放在 &lt;code>${PREFIX}/lib/node_modules/&lt;/code> 目录中；若安装的东西中具有可以在 CLI 执行的工具，则同时会在 &lt;code>${PREFIX}/bin/&lt;/code> 目录下生成指向原始文件的软链接，&lt;code>${PREFIX}/bin/&lt;/code> 目录通常都会加入到 &lt;code>${PATH}&lt;/code> 变量中。
&lt;ul>
&lt;li>当我们想要在命令行上运行安装的命令行工具，通常安装在全局&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>随着时代的发展，出现了 pnpm、(期待有更好的)等 工具，可以让我们将各种不同的项目的依赖放在同一个路径下进行统一管理。&lt;/p>
&lt;h1 id="npm">NPM&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://www.npmjs.com/">官网&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://docs.npmjs.com/cli">官方文档，cli&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>&lt;strong>Node.js Package Manager(简称 NPM)&lt;/strong> 是 Node.js 自带的包管理工具，通常与 Node.js 一同安装，最初版本于 2010 年 1 月发行。NPM 本质是一个第三方模块，可以在 &lt;strong>${PREFIX}/lib/node_modules/npm/*&lt;/strong> 目录下找到 npm 的所有文件。&lt;/p>
&lt;blockquote>
&lt;p>注意：&lt;/p>
&lt;ul>
&lt;li>&lt;code>${PREFIX}&lt;/code> 指 &lt;strong>Node.js 的安装路径&lt;/strong>，Linux 中通常装在 /usr/local/nodejs 目录下，Windows 则随意了~~&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;h2 id="npx">npx&lt;/h2>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://www.ruanyifeng.com/blog/2019/02/npx.html">https://www.ruanyifeng.com/blog/2019/02/npx.html&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>npx 是 NPM 中自带的工具&lt;/p>
&lt;p>通过 &lt;code>npx serve&lt;/code> 命令(与 &lt;code>npm exec serve&lt;/code> 命令类似)可以启动一个 HTTP 服务，以访问当前目录下的所有静态资源文件。便于本地开发调试。&lt;/p>
&lt;h2 id="npm-关联文件与配置">npm 关联文件与配置&lt;/h2>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://docs.npmjs.com/cli/v8/configuring-npm/folders">官方文档，cli-配置 npm-文件夹&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://docs.npmjs.com/cli/v8/using-npm/config">官方文档，cli-使用 npm-配置&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>当我们使用 &lt;code>npm install&lt;/code> 命令安装各种第三方库(依赖包)及其衍生物通常会保存在两类地方&lt;/p>
&lt;ul>
&lt;li>&lt;strong>Locally(本地)&lt;/strong> # 这是默认的行为，安装的东西放在当前目录的 &lt;code>./node_modules/&lt;/code> 目录中
&lt;ul>
&lt;li>当我们想要在代码中使用 require() 或 import 导入模块时，通常安装在本地&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>Globally(全局)&lt;/strong> # 使用 &lt;code>-g&lt;/code> 选项，将安装的东西放在 &lt;code>${PREFIX}/lib/node_modules/&lt;/code> 目录中；若安装的东西中具有可以在 CLI 执行的工具，则同时会在 &lt;code>${PREFIX}/bin/&lt;/code> 目录下生成指向原始文件的软链接，&lt;code>${PREFIX}/bin/&lt;/code> 目录通常都会加入到 &lt;code>${PATH}&lt;/code> 变量中。
&lt;ul>
&lt;li>当我们想要在命令行上运行安装的命令行工具，通常安装在全局&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>npm 从 命令行、环境变量、npmrc 文件、某些情况下从 package.json 文件 这些地方获取其配置信息&lt;/p>
&lt;p>npm 从以下地方获取其运行时配置&lt;/p>
&lt;ul>
&lt;li>&lt;strong>命令行标志&lt;/strong>&lt;/li>
&lt;li>&lt;strong>环境变量&lt;/strong>&lt;/li>
&lt;li>&lt;strong>npmrc 文件&lt;/strong> # npm 从以下几个地方依次读取 nmrc 文件
&lt;ul>
&lt;li>&lt;strong>/PATH/TO/NPM/npmrc&lt;/strong> # npm 内置的配置文件&lt;/li>
&lt;li>&lt;strong>${PREFIX}/etc/npmrc&lt;/strong> # 全局配置文件，可以通过 &lt;code>--globalconfig&lt;/code> 命令行选项或 &lt;code>${NPM_CONFIG_GLOBALCONFIG}&lt;/code> 环境变量改变其值&lt;/li>
&lt;li>&lt;strong>~/.npmrc&lt;/strong> # 用户&lt;/li>
&lt;li>配置文件，可以通过 &lt;code>--userconfig&lt;/code> 命令行选项或 &lt;code>${NPM_CONFIG_USERCONFIG}&lt;/code> 环境变量改变其值&lt;/li>
&lt;li>&lt;strong>/PATH/TO/MY/PROJECT/.npmrc&lt;/strong> # 每个项目自己的配置&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>**${PREFIX}/lib/node_modules/npm/* **# npm 作为一个第三方模块，跟随 Node.js 一起安装，被放在该目录下。
**${PREFIX}/bin* **# npm 安装的各种依赖包中若包含命令行工具，则会在此目录创建软链接。该目录通常都会加入到 &lt;code>${PATH}&lt;/code> 变量中。&lt;/p>
&lt;h3 id="配置文件详解">配置文件详解&lt;/h3>
&lt;p>所有可供配置的信息可从 &lt;a href="https://docs.npmjs.com/cli/v8/using-npm/config#config-settings">https://docs.npmjs.com/cli/v8/using-npm/config#config-settings&lt;/a> 查看&lt;/p>
&lt;h1 id="pnpm">PNPM&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://github.com/pnpm/pnpm">GitHub 项目，pnpm/pnpm&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://pnpm.io/">官网&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://juejin.cn/post/7047556067877716004">稀土掘金，pnpm 对比 npm/yarn 好在哪里&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>当使用 npm 或 Yarn 时，如果你有 100 个项目使用了某个依赖（dependency），就会有 100 份该依赖的副本保存在硬盘上。 而在使用 pnpm 时，依赖会被存储在内容可寻址的存储中，所以：&lt;/p>
&lt;ol>
&lt;li>如果你用到了某依赖项的不同版本，只会将不同版本间有差异的文件添加到仓库。 例如，如果某个包有 100 个文件，而它的新版本只改变了其中 1 个文件。那么 pnpm update 时只会向存储中心额外添加 1 个新文件，而不会因为仅仅一个文件的改变复制整新版本包的内容。&lt;/li>
&lt;li>所有文件都会存储在硬盘上的某一位置。 当软件包被被安装时，包里的文件会硬链接到这一位置，而不会占用额外的磁盘空间。 这允许你跨项目地共享同一版本的依赖。&lt;/li>
&lt;/ol>
&lt;p>因此，您在磁盘上节省了大量空间，这与项目和依赖项的数量成正比，并且安装速度要快得多！&lt;/p>
&lt;h2 id="安装-pnpm">安装 pnpm&lt;/h2>
&lt;p>使用 &lt;code>corepack enable&lt;/code> 指令启用 pnpm。
设置包的存储路径：&lt;/p>
&lt;ul>
&lt;li>Windows：&lt;code>pnpm config set store-dir D:\Projects\.pnpm-store&lt;/code>&lt;/li>
&lt;li>Linux：&lt;code>pnpm config set store-dir /mnt/d/Projects/.pnpm-store&lt;/code>&lt;/li>
&lt;/ul>
&lt;p>配置镜像源 &lt;code>pnpm config set registry=&amp;quot;https://registry.npmmirror.com&amp;quot;&lt;/code>&lt;/p>
&lt;p>若 Windows 无法执行 pnpm，报错：&lt;code>pnpm : 无法加载文件 D:\Tools\nodejs\pnpm.ps1，因为在此系统上禁止运行脚本。有关详细信息，请参阅 https:/go.microsoft.com/fwlink/?LinkID=135170 中的 about_Execution_Policies。&lt;/code>&lt;/p>
&lt;ul>
&lt;li>此时需要在 PowerShell 中执行 &lt;code>Set-ExecutionPolicy -Scope CurrentUser RemoteSigned&lt;/code> 指令。详见&lt;a href="https://learn.microsoft.com/zh-cn/powershell/module/microsoft.powershell.core/about/about_execution_policies?view=powershell-7.2">微软官网解释&lt;/a>。
&lt;ul>
&lt;li>其中 &lt;code>-Scope CurrentUser&lt;/code> 是指针对当前用户的操作，若使用管理员运行 VSCode 或 PowerShell，则不用加这个选项。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h3 id="更新">更新&lt;/h3>
&lt;p>corepack prepare &lt;a href="mailto:pnpm@7.14.1">pnpm@7.14.1&lt;/a> &amp;ndash;activate&lt;/p>
&lt;h2 id="pnpm-关键文件与配置">pnpm 关键文件与配置&lt;/h2>
&lt;p>&lt;strong>/PATH/TO/.pnpm-store&lt;/strong> # 存放各项目依赖的目录&lt;/p>
&lt;h1 id="npm-与-pnpm-syntax语法">npm 与 pnpm Syntax(语法)&lt;/h1>
&lt;blockquote>
&lt;h2 id="参考-1">参考：&lt;/h2>
&lt;/blockquote>
&lt;p>通常，适用于 npm 的选项，也适用于 pnpm&lt;/p>
&lt;p>&lt;strong>npm [OPTIONS] COMMAND [OPTIONS]&lt;/strong>&lt;/p>
&lt;p>&lt;strong>OPTIONS&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>&lt;strong>-g, &amp;ndash;global&lt;/strong> # 指定命令作用范围为全局。默认情况下 npm 的所有子命令作用范围是当前目录&lt;/li>
&lt;/ul>
&lt;h2 id="npm-config">npm config&lt;/h2>
&lt;p>npm config 用来管理 npm 的配置文件，i.e.npmrc 文件。&lt;/p>
&lt;h3 id="syntax语法">Syntax(语法)&lt;/h3>
&lt;p>&lt;strong>npm config set &lt;!-- raw HTML omitted -->=&lt;!-- raw HTML omitted --> [&lt;!-- raw HTML omitted -->=&lt;!-- raw HTML omitted --> &amp;hellip;]&lt;/strong>
&lt;strong>npm config get [&lt;!-- raw HTML omitted --> [&lt;!-- raw HTML omitted --> &amp;hellip;]]&lt;/strong>
&lt;strong>npm config delete &lt;!-- raw HTML omitted --> [&lt;!-- raw HTML omitted --> &amp;hellip;]&lt;/strong>
&lt;strong>npm config list [&amp;ndash;json]&lt;/strong>
&lt;strong>npm config edit&lt;/strong>&lt;/p>
&lt;p>OPTIONS&lt;/p>
&lt;ul>
&lt;li>&lt;strong>-g, &amp;ndash;global&lt;/strong> # 对全局配置文件(${PREFIX}/etc/npmrc) 执行操作&lt;/li>
&lt;/ul>
&lt;h3 id="example">EXAMPLE&lt;/h3>
&lt;ul>
&lt;li>配置镜像源为淘宝的
&lt;ul>
&lt;li>&lt;code>npm config set registry=&amp;quot;https://registry.npmmirror.com&amp;quot;&lt;/code>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h2 id="npm-exec">npm exec&lt;/h2>
&lt;p>从本地或远程 npm 包运行命令&lt;/p>
&lt;h3 id="syntax语法-1">Syntax(语法)&lt;/h3>
&lt;p>&lt;strong>npm exec &amp;ndash; &lt;!-- raw HTML omitted -->[@&lt;!-- raw HTML omitted -->] [args&amp;hellip;]&lt;/strong>
&lt;strong>npm exec &amp;ndash;package=&lt;!-- raw HTML omitted -->[@&lt;!-- raw HTML omitted -->] &amp;ndash; &lt;!-- raw HTML omitted --> [args&amp;hellip;]&lt;/strong>
&lt;strong>npm exec -c &amp;lsquo;&lt;!-- raw HTML omitted --> [args&amp;hellip;]&amp;rsquo;&lt;/strong>
&lt;strong>npm exec &amp;ndash;package=foo -c &amp;lsquo;&lt;!-- raw HTML omitted --> [args&amp;hellip;]&amp;rsquo;&lt;/strong>&lt;/p>
&lt;p>OPTIONS&lt;/p>
&lt;ul>
&lt;li>&lt;/li>
&lt;/ul>
&lt;h2 id="npm-install">npm install&lt;/h2>
&lt;h3 id="syntax语法-2">Syntax(语法)&lt;/h3>
&lt;p>OPTIONS&lt;/p>
&lt;ul>
&lt;li>&lt;strong>-D, &amp;ndash;save-dev&lt;/strong> # 安装的包将会出现在 &lt;code>devDependencies&lt;/code> 中&lt;/li>
&lt;/ul>
&lt;h2 id="npm-init">npm init&lt;/h2>
&lt;p>创建一个 package.json 文件。用来初始化一个项目&lt;/p>
&lt;h3 id="syntax语法-3">Syntax(语法)&lt;/h3>
&lt;p>&lt;strong>npm init [&amp;ndash;force|-f|&amp;ndash;yes|-y|&amp;ndash;scope]&lt;/strong>
&lt;strong>npm init &amp;lt;@scope&amp;gt; (same as &lt;code>npx &amp;lt;@scope&amp;gt;/create&lt;/code>)&lt;/strong>
&lt;strong>npm init [&amp;lt;@scope&amp;gt;]&lt;!-- raw HTML omitted --> (same as &lt;code>npx [&amp;lt;@scope&amp;gt;/]create-&amp;lt;name&amp;gt;&lt;/code>)&lt;/strong>&lt;/p>
&lt;p>OPTIONS&lt;/p>
&lt;ul>
&lt;li>&lt;/li>
&lt;/ul>
&lt;h2 id="npm-list">npm list&lt;/h2>
&lt;p>列出所有已经安装的包。默认列出当前项目中已安装的包，通常检查如下目录：&lt;code>node_modules/&lt;/code>&lt;/p>
&lt;h2 id="npm-update">npm update&lt;/h2>
&lt;p>更新已安装的包&lt;/p>
&lt;h1 id="yarn">Yarn&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://yarnpkg.com/">官网&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>管理 Yarn 的首选方式是通过 &lt;a href="https://nodejs.org/dist/latest/docs/api/corepack.html">Corepack&lt;/a>，这是从 16.10 开始随所有 Node.js 版本一起提供的新二进制文件。它充当我们和 Yarn 之间的中介，让我们在多个项目中使用不同的包管理器版本，而无需再签入 Yarn 二进制文件。&lt;/p>
&lt;p>Node.js &amp;gt;=16.10
Corepack 默认包含在所有 Node.js 安装中，但目前是可选的。要启用它，请运行以下命令：
&lt;code>corepack enable&lt;/code>&lt;/p>
&lt;p>Node.js &amp;lt;16.10
在 16.10 之前的版本中，Node.js 不包含 Corepack；为了解决这个问题，运行：
&lt;code>npm i -g corepack&lt;/code>&lt;/p>
&lt;p>配置镜像源以加速下载各种依赖包&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>yarn config set registry https://registry.npmmirror.com -g
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>配置 $PATH 以便可以直接执行通过 yarn 安装的各种工具&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>export PATH&lt;span style="color:#f92672">=&lt;/span>$PATH:~/.config/yarn/global/node_modules/.bin
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="yarn-关联文件与配置">Yarn 关联文件与配置&lt;/h2>
&lt;p>&lt;strong>~/.yarnrc&lt;/strong> # 配置文件
&lt;strong>~/.config/yarn/&lt;/strong>* #&lt;/p>
&lt;h1 id="yarn-syntax语法">yarn Syntax(语法)&lt;/h1></description></item><item><title>Docs: ECMAScript 环境安装与使用</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/2.%E7%BC%96%E7%A8%8B/%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/ecmascript/ecmascript-%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8/ecmascript-%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/2.%E7%BC%96%E7%A8%8B/%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/ecmascript/ecmascript-%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8/ecmascript-%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;/blockquote>
&lt;p>有两种运行时环境可以运行 ECMAScript 代码(Javascript、Typescript)&lt;/p>
&lt;ul>
&lt;li>**Browser **# 浏览器就是 ECMAScript 的运行时环境。&lt;/li>
&lt;li>&lt;strong>Node.js&lt;/strong> # 在服务器或 PC 上安装 Node.js 环境以运行 ECMAScript 代码&lt;/li>
&lt;li>&lt;strong>Deno&lt;/strong> # &lt;a href="https://github.com/denoland/deno">GtiHub 项目，denoland/deno&lt;/a>。据说要替代 Node.js，很尴尬的是。。。早期 18 年的 issue 中被各种国人无意义灌水&lt;/li>
&lt;li>&lt;strong>Bun&lt;/strong> # &lt;a href="https://github.com/oven-sh/bun">GtiHub 项目，oven-sh/bun&lt;/a>&lt;/li>
&lt;/ul>
&lt;p>但是这两者可以提供的 API 能力各不相同&lt;/p>
&lt;ul>
&lt;li>Browser 可以提供的 dockument、window 和其他关于 DOM 或其他 Web 平台 API 的对象。&lt;/li>
&lt;li>Node.js 则可以提供很多操作系统相关的 API，比如文件的读写、进程管理、网络通信等等。&lt;/li>
&lt;/ul>
&lt;p>Node.js 与 Browser 都是基于 Chrome V8 引擎的 ECMAScript 运行时环境&lt;/p>
&lt;p>你也许会想，直接在我的硬盘上创建好 HTML 和 JavaScript 文件，然后用浏览器打开，不就可以看到效果了吗？&lt;/p>
&lt;p>这种方式运行部分 JavaScript 代码没有问题，但由于浏览器的安全限制，以 file:// 开头的地址无法执行如联网等 JavaScript 代码，最终，你还是需要架设一个 Web 服务器，然后以 http:// 开头的地址来正常执行所有 JavaScript 代码。&lt;/p>
&lt;p>所以，想要运行 JavaScript 编写的静态文件，通常都需要一个可以提供 HTTP 服务的程序，以便响应客户端的请求返回这些静态文件。通常在生产环境中，我们都会将静态资源文件放到 Nginx 的目录中，由 Nginx 为客户端提供 HTTP 服务。&lt;/p>
&lt;p>而本地测试时，我们通过 npm 与 yarn 工具即可安装一个简易的 HTTP 服务，这个 HTTP 服务都是由 JS 代码写的，必须要保证本地有 Node.js 环境，即可启动一个 HTTP 服务&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># Npm 安装 http-server&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>~&lt;span style="color:#f92672">]&lt;/span>&lt;span style="color:#75715e"># npm install http-server&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># Yarn 安装 http-server&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>~&lt;span style="color:#f92672">]&lt;/span>&lt;span style="color:#75715e"># yarn add http-server&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>http-server 来源于 &lt;a href="https://github.com/http-party/http-server">GitHub 项目，http-party/http-server&lt;/a>&lt;/p>
&lt;p>通过 &lt;code>npm exec serve&lt;/code> 命令将会安装另一个名为 serve 的库以运行 HTTP 服务，默认在 3000 端口上启动 HTTP 服务，通过浏览器访问 localhost:3000 即可获取到所有自己编写的静态文件，便于让开发人员在本地调试。&lt;/p>
&lt;h2 id="重点运行具有-module模块-功能的静态资源">(重点)运行具有 Module(模块) 功能的静态资源&lt;/h2>
&lt;p>从《ECMAScript 模块》章节可以看到，当我们使用 &lt;code>import name from './one.js'&lt;/code> 导入的模块是一个文件时，那么这个文件将会被响应给浏览器，如果使用 &lt;code>import name from 'one'&lt;/code> 导入的模块是一组文件时，此时浏览器无法直接识别，将会产生报错。因为浏览器想要执行这一组文件需要发起很多次的请求将所有文件都加载到本地，这其中的路由路径将是不可控的。&lt;/p>
&lt;p>所以，此时我们则需要想办法将这一组文件变为一个文件响应给浏览器以便加载代码。这个转换的操作，我们可以使用打包工具(i.e.Webpack、Vite 等等) 将源代码&lt;strong>打包编译&lt;/strong>成新的静态文件即可。&lt;/p>
&lt;p>后面的逻辑，与基本运行 ECMAScript 代码的行为就是一样的了。&lt;/p>
&lt;h2 id="使用-vite-运行-ecmascript-代码">使用 Vite 运行 ECMAScript 代码&lt;/h2>
&lt;p>npm、yarn 的打包后运行代码的速度非常缓慢，才是推荐使用 Vite 工具启动 HTTP 服务并运行 JS/TS 代码，详见：[《Vite》](/docs/IT学习笔记/2.编程/高级编程语言/ECMAScript/ECMAScript%20 工具/Vite.md 工具/Vite.md) 章节&lt;/p>
&lt;h2 id="运行-typesript">运行 TypeSript&lt;/h2>
&lt;p>Node.js 和 浏览器都无法直接运行 TypeScript 代码，这是因为 TS 的代码需要先转换为 JS 代码才可以运行。此时就需要一种工具，先转换再运行，或者直接转换运行一体。&lt;/p>
&lt;ul>
&lt;li>&lt;strong>tsc&lt;/strong> # 将 TS 代码转换为 JS 代码。&lt;code>npm install -g typescript&lt;/code>&lt;/li>
&lt;li>&lt;strong>ts-node&lt;/strong> # 可以直接转换并运行 TS 代码，&lt;code>npm install -g ts-node&lt;/code> 安装即可&lt;/li>
&lt;/ul>
&lt;h1 id="nodejs">NodeJS&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://nodejs.org/en/">org 官网&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://nodejs.dev/">dev 官网&lt;/a>&lt;/li>
&lt;li>&lt;a href="http://nodejs.cn/">dev 官网中文翻译&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Node.js">Wiki,Node.js&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>Node.js 是基于 Chrome V8 引擎的 ECMAScript 运行时环境，由 RyanDahl 于 2009 年 5 月 27 日发布。转年(i.e.2010 年 1 月)，为 Node.js 环境引入了一个名为 npm 的包管理器。包管理器使程序员更容易发布和共享 Node.js 的源代码，旨在简化包的安装、更新、卸载。&lt;/p>
&lt;p>Browser 和 Node.js 都是 ECMAScript 的运行时环境，但是这两者可以提供的 API 能力各不相同&lt;/p>
&lt;ul>
&lt;li>Browser 可以提供的 dockument、window 和其他关于 DOM 或其他 Web 平台 API 的对象。&lt;/li>
&lt;li>Node.js 则可以提供很多操作系统相关的 API，比如文件的读写、进程管理、网络通信等等。&lt;/li>
&lt;/ul>
&lt;p>通过 Node.js，可以让我们使用一种语言编写前端与后端。我们甚至可以通过 npm 与 yarn 安装第三方库后，使用 Node.js 在本地监听端口并响应给客户端静态资源文件。&lt;/p>
&lt;h2 id="安装-nodejs">安装 NodeJS&lt;/h2>
&lt;h3 id="linux">Linux&lt;/h3>
&lt;p>从&lt;a href="https://nodejs.org/zh-cn/download/">官网&lt;/a>下载 Linux 版的 &lt;code>.tar.xg&lt;/code> 包，并解压&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>export NodejsVersion&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;v16.15.0&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>wget https://nodejs.org/dist/&lt;span style="color:#e6db74">${&lt;/span>NodejsVersion&lt;span style="color:#e6db74">}&lt;/span>/node-&lt;span style="color:#e6db74">${&lt;/span>NodejsVersion&lt;span style="color:#e6db74">}&lt;/span>-linux-x64.tar.xz
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>tar -xvf node-&lt;span style="color:#e6db74">${&lt;/span>NodejsVersion&lt;span style="color:#e6db74">}&lt;/span>-linux-x64.tar.xz -C /usr/local/
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>mv /usr/local/node-&lt;span style="color:#e6db74">${&lt;/span>NodejsVersion&lt;span style="color:#e6db74">}&lt;/span>-linux-x64 /usr/local/nodejs
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>配置环境变量&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>sudo tee /etc/profile.d/nodejs.sh &amp;gt; /dev/null &amp;lt;&amp;lt;-&lt;span style="color:#e6db74">&amp;#34;EOF&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>export PATH&lt;span style="color:#f92672">=&lt;/span>$PATH:/usr/local/nodejs/bin
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>EOF
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="windows">Windows&lt;/h3>
&lt;h2 id="nvm">NVM&lt;/h2>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://github.com/nvm-sh/nvm">GitHub 项目，nvm-sh/nvm&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>&lt;strong>Node Version Manager(Node.js 版本管理器，简称 NVM)&lt;/strong>&lt;/p>
&lt;h2 id="nodejs-配置与关联文件">Node.js 配置与关联文件&lt;/h2>
&lt;p>&lt;strong>${PREFIX}/*&lt;/strong> # $PREFIX 指 Node.js 的安装路径，个人通常装在 /usr/local/nodejs 目录下&lt;/p>
&lt;ul>
&lt;li>&lt;strong>./bin/*&lt;/strong> # 第三方模块可用的工具以及 node 二进制文件保存路径
&lt;ul>
&lt;li>这个目录下的第三方模块工具通常都是一个软链接，指向 ${PREFIX}/lib/node_modeuls/XX 目录下的某个目录中文件，具体路径由模块自身定义&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>./lib/node_modules/*&lt;/strong> # 通过 npm、yarn 等包管理器安装&lt;strong>全局&lt;/strong>的第三方依赖包的保存路径。通常 Node.js 默认自带 corepack、npm 这两个包
&lt;ul>
&lt;li>&lt;strong>./corepack/*&lt;/strong> # corepack 工具&lt;/li>
&lt;li>&lt;strong>./npm/*&lt;/strong> # npm 工具&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h1 id="初始化项目">初始化项目&lt;/h1>
&lt;p>由于现阶段都是各种框架学习，所以通过 npm 等包管理工具下载完框架后，会自动生成项目目录，这些目录是已经初始化完成的项目，包含了很多必要的文件，比如 package.json 等。&lt;/p>
&lt;p>随着学习深入，会逐步总结一个前端项目如果不使用框架从头构建的话会需要什么。&lt;/p>
&lt;ul>
&lt;li>&lt;strong>public/&lt;/strong> 目录存放公共资源&lt;/li>
&lt;li>&lt;strong>src/&lt;/strong> # 所有代码都在 src/ 目录下&lt;/li>
&lt;li>&lt;strong>.eslintrc.cjs&lt;/strong> # ESLint 程序配置&lt;/li>
&lt;li>&lt;strong>.prettierc.json&lt;/strong> # Prettier 插件的配置&lt;/li>
&lt;li>&lt;strong>env.d.ts&lt;/strong> #&lt;/li>
&lt;li>&lt;strong>index.html&lt;/strong> # 程序入口&lt;/li>
&lt;li>[&lt;strong>package.json&lt;/strong>](/docs/IT学习笔记/2.编程/高级编程语言/ECMAScript/ECMAScript%20 环境安装与使用/package.json.md 环境安装与使用/package.json.md) # 包管理器配置文件，比如 npm、pnpm 等&lt;/li>
&lt;li>&lt;strong>vite.config.ts&lt;/strong> # Vite 程序给项目打包时使用的配置&lt;/li>
&lt;li>&lt;strong>tsconfig.json&lt;/strong> #&lt;/li>
&lt;li>&lt;strong>tsconfig.config.json&lt;/strong> # [TSConfig](/docs/IT学习笔记/2.编程/高级编程语言/ECMAScript/ECMAScript%20 环境安装与使用/TSConfig.md 环境安装与使用/TSConfig.md) 文件&lt;/li>
&lt;/ul>
&lt;h2 id="javascript-项目初始化">JavaScript 项目初始化&lt;/h2>
&lt;p>无&lt;/p>
&lt;h2 id="typescript-项目初始化">TypeScript 项目初始化&lt;/h2>
&lt;p>使用 &lt;code>npm install -g typescript&lt;/code> 安装 tsc 命令。&lt;/p>
&lt;p>使用 &lt;code>tsc init&lt;/code> 命令将会生成 [TSConfig](/docs/IT学习笔记/2.编程/高级编程语言/ECMAScript/ECMAScript%20 环境安装与使用/TSConfig.md 环境安装与使用/TSConfig.md) 文件。&lt;/p>
&lt;h1 id="编译与打包">编译与打包&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://github.com/webpack/webpack">GitHub 项目，webpack/webpack&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://github.com/rollup/rollup">GitHub 项目，rollup/rollup&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>大型项目通常都要打包，打包工具有很多：&lt;/p>
&lt;ul>
&lt;li>Webpack&lt;/li>
&lt;li>Rollup&lt;/li>
&lt;li>Vite&lt;/li>
&lt;li>&amp;hellip;&amp;hellip;等等&lt;/li>
&lt;/ul>
&lt;h1 id="常见问题">常见问题&lt;/h1>
&lt;h2 id="nodejs-无法使用-es6-语法问题">Node.js 无法使用 ES6 语法问题&lt;/h2>
&lt;p>无法使用 import 关键字导入模块。参考 &lt;a href="https://nodejs.org/docs/latest-v16.x/api/esm.html#enabling">https://nodejs.org/docs/latest-v16.x/api/esm.html#enabling&lt;/a>，在 package.json 文件中设置 &lt;code>&amp;quot;type&amp;quot;: &amp;quot;module&amp;quot;&lt;/code> 或者使用 &lt;code>--input-type=module&lt;/code> 命令行参数以告诉 Node.js 使用 ECMAScript 模块加载器。默认情况下，Node.js 使用 CommonJS 模块加载器。&lt;/p></description></item><item><title>Docs: ECMAScript 模块与包</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/2.%E7%BC%96%E7%A8%8B/%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/ecmascript/ecmascript-%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8/ecmascript-%E6%A8%A1%E5%9D%97%E4%B8%8E%E5%8C%85/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/2.%E7%BC%96%E7%A8%8B/%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/ecmascript/ecmascript-%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8/ecmascript-%E6%A8%A1%E5%9D%97%E4%B8%8E%E5%8C%85/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Modules">MDN-参考，JavaScript-JavaScript 指南-JavaScript 模块&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://wangdoc.com/es6/module.html">网道，ES6 教程-Module 的语法&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.zhangxinxu.com/wordpress/2018/08/browser-native-es6-export-import-module/">https://www.zhangxinxu.com/wordpress/2018/08/browser-native-es6-export-import-module/&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>历史上，JavaScript 一直没有 Module(模块) 体系，无法将一个大程序拆分成互相依赖的小文件，再用简单的方法拼装起来。其他语言都有这项功能，比如 Ruby 的 require、Python 的 import，甚至就连 CSS 都有@import，但是 JavaScript 任何这方面的支持都没有，这对开发大型的、复杂的项目形成了巨大障碍。&lt;/p>
&lt;p>在 ES6 之前，社区制定了一些模块加载方案，最主要的有 2009 年 1 月发起的 CommonJS 和 AMD 两种，前者用于服务器，后者用于浏览器。&lt;/p>
&lt;blockquote>
&lt;p>2013 年 5 月，npm 的作者宣布 Node.js 已经废弃 CommonJS，详见 &lt;a href="https://github.com/nodejs/node-v0.x-archive/issues/5132#issuecomment-15432598">GitHub issue-5132，nodejs/node-v0.x-archive&lt;/a> &amp;gt; &lt;a href="https://en.wikipedia.org/wiki/Asynchronous_module_definition">Wiki,Asynchronous_module_definition&lt;/a>(异步模块定义，简称 AMD)&lt;/p>
&lt;/blockquote>
&lt;p>比如，CommonJS 模块就是对象，输入时必须查找对象属性。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-javascript" data-lang="javascript">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// CommonJS 标准
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">let&lt;/span> { &lt;span style="color:#a6e22e">stat&lt;/span>, &lt;span style="color:#a6e22e">exists&lt;/span>, &lt;span style="color:#a6e22e">readfile&lt;/span> } &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#a6e22e">require&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;fs&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 等同于 js 代码
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">let&lt;/span> &lt;span style="color:#a6e22e">_fs&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#a6e22e">require&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;fs&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">let&lt;/span> &lt;span style="color:#a6e22e">stat&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#a6e22e">_fs&lt;/span>.&lt;span style="color:#a6e22e">stat&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">let&lt;/span> &lt;span style="color:#a6e22e">exists&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#a6e22e">_fs&lt;/span>.&lt;span style="color:#a6e22e">exists&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">let&lt;/span> &lt;span style="color:#a6e22e">readfile&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#a6e22e">_fs&lt;/span>.&lt;span style="color:#a6e22e">readfile&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>上面代码的实质是整体加载 fs 模块（即加载 fs 的所有方法），生成一个对象（_fs），然后再从这个对象上面读取 3 个方法。这种加载称为“运行时加载”，因为只有运行时才能得到这个对象，导致完全没办法在编译时做“静态优化”。&lt;/p>
&lt;h2 id="es6-module">ES6 Module&lt;/h2>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://beginor.github.io/2021/08/16/using-es-modules-in-borwser-with-importmaps.html">https://beginor.github.io/2021/08/16/using-es-modules-in-borwser-with-importmaps.html&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>&lt;strong>ES6 Module(ES6 模块，简称 ESM)&lt;/strong>，ES6 在语言标准的层面上，实现了模块功能，而且实现得相当简单，完全可以取代 CommonJS 和 AMD 规范，成为浏览器和服务器通用的模块解决方案。这种模块功能与 ES6 一起发布于 2015 年&lt;/p>
&lt;p>ES6 模块的设计思想是尽量的静态化，使得编译时就能确定模块的依赖关系，以及输入和输出的变量。CommonJS 和 AMD 模块，都只能在运行时确定这些东西。&lt;/p>
&lt;p>通常来说，&lt;strong>一个模块指的一组文件的合集&lt;/strong>，只不过在通过编译工具编译后，将合并成一个文件。&lt;/p>
&lt;p>ES6 模块不是对象，而是通过 export 命令显式指定输出的代码，再通过 import 命令输入。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-javascript" data-lang="javascript">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// ES6 模块
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">import&lt;/span> { &lt;span style="color:#a6e22e">stat&lt;/span>, &lt;span style="color:#a6e22e">exists&lt;/span>, &lt;span style="color:#a6e22e">readFile&lt;/span> } &lt;span style="color:#a6e22e">from&lt;/span> &lt;span style="color:#e6db74">&amp;#34;fs&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>上面代码的实质是从 fs 模块加载 3 个方法，其他方法不加载。这种加载称为“编译时加载”或者静态加载，即 ES6 可以在编译时就完成模块加载，效率要比 CommonJS 模块的加载方式高。当然，这也导致了没法引用 ES6 模块本身，因为它不是对象。&lt;/p>
&lt;blockquote>
&lt;p>只支持相对路径或者绝对路径下的 ES 模块 (./, ../, /, http://, https://) ， 同时也受服务器跨域请求策略、 HTTPS 策略的约束。&lt;/p>
&lt;/blockquote>
&lt;p>由于 ES6 模块是编译时加载，使得静态分析成为可能。有了它，就能进一步拓宽 JavaScript 的语法，比如引入宏（macro）和类型检验（type system）这些只能靠静态分析实现的功能。&lt;/p>
&lt;p>除了静态加载带来的各种好处，ES6 模块还有以下好处。&lt;/p>
&lt;ul>
&lt;li>不再需要 UMD 模块格式了，将来服务器和浏览器都会支持 ES6 模块格式。目前，通过各种工具库，其实已经做到了这一点。&lt;/li>
&lt;li>将来浏览器的新 API 就能用模块格式提供，不再必须做成全局变量或者 navigator 对象的属性。&lt;/li>
&lt;li>不再需要对象作为命名空间（比如 Math 对象），未来这些功能可以通过模块提供。&lt;/li>
&lt;/ul>
&lt;h2 id="import-maps">Import maps&lt;/h2>
&lt;p>&lt;a href="https://beginor.github.io/2021/08/16/using-es-modules-in-borwser-with-importmaps.html">https://beginor.github.io/2021/08/16/using-es-modules-in-borwser-with-importmaps.html&lt;/a>&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-html" data-lang="html">&lt;span style="display:flex;">&lt;span>&amp;lt;&lt;span style="color:#f92672">script&lt;/span> &lt;span style="color:#a6e22e">type&lt;/span>&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;importmap&amp;#34;&lt;/span>&amp;gt;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#34;imports&amp;#34;&lt;/span>&lt;span style="color:#f92672">:&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#34;vue&amp;#34;&lt;/span>&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#e6db74">&amp;#34;https://unpkg.com/vue@3/dist/vue.esm-browser.js&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&amp;lt;/&lt;span style="color:#f92672">script&lt;/span>&amp;gt;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&amp;lt;&lt;span style="color:#f92672">script&lt;/span> &lt;span style="color:#a6e22e">type&lt;/span>&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;module&amp;#34;&lt;/span>&amp;gt;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">import&lt;/span> { &lt;span style="color:#a6e22e">createApp&lt;/span> } &lt;span style="color:#a6e22e">from&lt;/span> &lt;span style="color:#e6db74">&amp;#34;vue&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&amp;lt;/&lt;span style="color:#f92672">script&lt;/span>&amp;gt;
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h1 id="模块的加载方式">模块的加载方式&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://stackoverflow.com/questions/47403478/es6-modules-in-local-files-the-server-responded-with-a-non-javascript-mime-typ">https://stackoverflow.com/questions/47403478/es6-modules-in-local-files-the-server-responded-with-a-non-javascript-mime-typ&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://localcoder.org/es6-modules-in-local-files-the-server-responded-with-a-non-javascript-mime-typ">https://localcoder.org/es6-modules-in-local-files-the-server-responded-with-a-non-javascript-mime-typ&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://axellarsson.com/blog/expected-javascript-module-script-server-response-mimetype-text-html/">https://axellarsson.com/blog/expected-javascript-module-script-server-response-mimetype-text-html/&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>在 Node.js 环境和 Browser 环境中加载 ESM 的方式不太一样&lt;/p>
&lt;ul>
&lt;li>&lt;strong>Node.js&lt;/strong> # 可以使用模块名称。从根目录下的 node_modules 中查找模块&lt;/li>
&lt;li>&lt;strong>Browser&lt;/strong> # 不可以使用模块名称。必须通过编译工具将模块编译成单一文件，并修改 import 指向单一文件，以便可以发起请求获取这个静态资源&lt;/li>
&lt;/ul>
&lt;h2 id="浏览器中使用-esm-的常见问题">浏览器中使用 ESM 的常见问题&lt;/h2>
&lt;p>使用 &lt;code>import * as Vue from 'vue'&lt;/code> 将会产生如下报错：
&lt;code>Failed to resolve module specifier &amp;quot;vue&amp;quot;. Relative references must start with either &amp;quot;/&amp;quot;, &amp;quot;./&amp;quot;, or &amp;quot;../&amp;quot;.&lt;/code>
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/mm0ymr/1651724399014-d2052b6f-cd7c-4ec0-b6fc-b748bd5a11ed.png" alt="image.png">
接着修改为 &lt;code>import * as Vue from '../node_modules/vue'&lt;/code> 将会产生如下报错：
&lt;code>Failed to load module script: The server responded with a non-JavaScript MIME type of &amp;quot;text/html&amp;quot;. Strict MIME type checking is enforced for module scripts per HTML spec.&lt;/code>&lt;/p>
&lt;blockquote>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/mm0ymr/1651724430503-b62b86bd-4cc7-48b8-ac73-69fa62564ed5.png" alt="image.png" title="firefox">&lt;/p>
&lt;/blockquote>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/mm0ymr/1651724407422-526db251-775f-40d5-a25e-402791aa38cc.png" alt="image.png" title="chrome">
问题原因：
这个情况的原因是浏览器在处理 import 逻辑时导致的。浏览器在发现 import 语句时，将会请求 from 后面的静态文件，当 from 指定的是模块名称而不是模块文件的路径时时，浏览器无法发起请求，因为浏览器不知道如何获取到模块文件。&lt;/p>
&lt;p>解决方式：&lt;/p>
&lt;ul>
&lt;li>使用配置文件告诉 JavaScript 引擎如何从名为 XX 的模块中获取模块文件&lt;/li>
&lt;li>编译代码，js 代码被编译后，导入的模块的一组文件将会被打包、压缩为一个文件；并且 from 后面的模块名将被修改为模块文件的路径，即可在浏览器中运行&lt;/li>
&lt;/ul>
&lt;p>这几种解决方式通常都是通过编译工具实现的，比如 Webpack、Vite 等工具。&lt;/p></description></item><item><title>Docs: package.json</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/2.%E7%BC%96%E7%A8%8B/%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/ecmascript/ecmascript-%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8/package.json/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/2.%E7%BC%96%E7%A8%8B/%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/ecmascript/ecmascript-%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8/package.json/</guid><description>
&lt;h2 id="概述">概述&lt;/h2>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://nodejs.dev/learn/the-package-json-guide">dev 官网，学习-package.json 指南&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>package.json 文件是项目的清单。 它可以做很多完全互不相关的事情。 例如，它是用于工具的配置中心。 它也是 npm 和 yarn 等包管理工具管理依赖的地方。&lt;/p></description></item><item><title>Docs: TSConfig</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/2.%E7%BC%96%E7%A8%8B/%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/ecmascript/ecmascript-%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8/tsconfig/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/2.%E7%BC%96%E7%A8%8B/%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/ecmascript/ecmascript-%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8/tsconfig/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://www.typescriptlang.org/docs/handbook/tsconfig-json.html">官方文档，项目配置-tsconfig.json 是什么&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.typescriptlang.org/tsconfig">官方文档，TSConfig 参考&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>TSConfig 通常是名为 tsconfig.json 或 jsconfig.json 的文件，当目录中出现了 tsconfig.json 文件，则说明该目录是 TypeScript 项目的根目录。tsconfig.json 文件指定了编译项目所需的根目录下的文件以及编译选项。&lt;/p>
&lt;h2 id="简单示例">简单示例&lt;/h2>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-json" data-lang="json">&lt;span style="display:flex;">&lt;span>{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;extends&amp;#34;&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;@vue/tsconfig/tsconfig.web.json&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;include&amp;#34;&lt;/span>: [
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#34;env.d.ts&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 两个 * 表示任意层数的所有目录
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#e6db74">&amp;#34;src/**/*&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#34;src/**/*.vue&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 导出所有接口目录到全局
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#e6db74">&amp;#34;src/api/**/*&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ],
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;compilerOptions&amp;#34;&lt;/span>: {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;baseUrl&amp;#34;&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;.&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 配置路径别名。这样在使用 import 导入时，我们可以通过 @/xxx 来代替 /src/xxx
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#f92672">&amp;#34;paths&amp;#34;&lt;/span>: {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;@/*&amp;#34;&lt;/span>: [&lt;span style="color:#e6db74">&amp;#34;src/*&amp;#34;&lt;/span>]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> },
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;references&amp;#34;&lt;/span>: [
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;path&amp;#34;&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;./tsconfig.config.json&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;strong>include&lt;/strong> # 通过在 include 中指定文件或目录，我们可以将声明的 interface 等默认导出并在其他地方使用，而不用在每个需要使用的地方使用 import 关键字显式导入了。&lt;/p>
&lt;h1 id="compileroptions">compilerOptions&lt;/h1>
&lt;h2 id="baseurl">baseUrl&lt;/h2>
&lt;h2 id="paths">paths&lt;/h2>
&lt;p>配置路径别名。
若使用 Vite 打包代码，则需要在 vite.config.ts 文件中也同步配置 &lt;code>resolve.alias&lt;/code>：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-typescript" data-lang="typescript">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">export&lt;/span> &lt;span style="color:#66d9ef">default&lt;/span> &lt;span style="color:#a6e22e">defineConfig&lt;/span>({
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">resolve&lt;/span>&lt;span style="color:#f92672">:&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">alias&lt;/span>&lt;span style="color:#f92672">:&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 让我们在导入时使用可以使用 @ 符号作为 src 目录的别名，而不是相对路径，比如：
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#75715e">// import App from &amp;#39;@/App.vue&amp;#39;
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#75715e">// 而不是
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#75715e">// import App from &amp;#39;../../App.vue&amp;#39;
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#e6db74">&amp;#34;@&amp;#34;&lt;/span>&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#a6e22e">fileURLToPath&lt;/span>(&lt;span style="color:#66d9ef">new&lt;/span> &lt;span style="color:#a6e22e">URL&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;./src&amp;#34;&lt;/span>, &lt;span style="color:#66d9ef">import&lt;/span>.&lt;span style="color:#a6e22e">meta&lt;/span>.&lt;span style="color:#a6e22e">url&lt;/span>)),
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> },
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> },
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>})
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div></description></item></channel></rss>